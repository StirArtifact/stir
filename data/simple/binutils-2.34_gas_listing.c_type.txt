typedef	O
struct	O
file_info_struct	struct
{	O
struct	O
file_info_struct	struct
*	O
next	pointer
;	O
char	O
*	O
filename	pointer
;	O
long	O
pos	long
;	O
unsigned	O
int	O
linenum	int
;	O
int	O
at_end	int
;	O
}	O
file_info_type	struct
;	O
enum	O
edict_enum	enum
{	O
EDICT_NONE	int
,	O
EDICT_SBTTL	int
,	O
EDICT_TITLE	int
,	O
EDICT_NOLIST	int
,	O
EDICT_LIST	int
,	O
EDICT_NOLIST_NEXT	int
,	O
EDICT_EJECT	int
}	O
;	O
struct	O
list_message	struct
{	O
char	O
*	O
message	pointer
;	O
struct	O
list_message	struct
*	O
next	pointer
;	O
}	O
;	O
struct	O
list_info_struct	struct
{	O
fragS	struct
*	O
frag	struct
;	O
unsigned	O
int	O
line	int
;	O
file_info_type	struct
*	O
file	pointer
;	O
char	O
*	O
line_contents	pointer
;	O
struct	O
list_info_struct	struct
*	O
next	pointer
;	O
file_info_type	struct
*	O
hll_file	pointer
;	O
unsigned	O
int	O
hll_line	int
;	O
struct	O
list_message	struct
*	O
messages	pointer
,	O
*	O
last_message	pointer
;	O
enum	O
edict_enum	enum
edict	enum
;	O
char	O
*	O
edict_arg	pointer
;	O
int	O
debugging	int
;	O
}	O
;	O
typedef	O
struct	O
list_info_struct	struct
list_info_type	struct
;	O
int	O
listing_lhs_width	int
=	O
LISTING_LHS_WIDTH	O
;	O
int	O
listing_lhs_width_second	int
=	O
LISTING_LHS_WIDTH_SECOND	O
;	O
int	O
listing_lhs_cont_lines	int
=	O
LISTING_LHS_CONT_LINES	int
;	O
int	O
listing_rhs_width	int
=	O
LISTING_RHS_WIDTH	int
;	O
struct	O
list_info_struct	struct
*	O
listing_tail	pointer
;	O
static	O
file_info_type	struct
*	O
file_info_head	pointer
;	O
static	O
file_info_type	struct
*	O
last_open_file_info	pointer
;	O
static	O
FILE	struct
*	O
last_open_file	pointer
;	O
static	O
struct	O
list_info_struct	struct
*	O
head	pointer
;	O
static	O
int	O
paper_width	int
=	O
200	int
;	O
static	O
int	O
paper_height	int
=	O
60	int
;	O
extern	O
int	O
listing	int
;	O
static	O
FILE	struct
*	O
list_file	pointer
;	O
static	O
char	O
*	O
data_buffer	pointer
;	O
static	O
void	O
listing_message	function
(	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
file_info_type	struct
*	O
file_info	function
(	O
const	O
char	O
*	O
)	O
;	O
static	O
void	O
new_frag	function
(	O
void	O
)	O
;	O
static	O
void	O
listing_page	function
(	O
list_info_type	struct
*	O
)	O
;	O
static	O
unsigned	O
int	O
calc_hex	function
(	O
list_info_type	struct
*	O
)	O
;	O
static	O
void	O
print_lines	function
(	O
list_info_type	struct
*	O
,	O
unsigned	O
int	O
,	O
const	O
char	O
*	O
,	O
unsigned	O
int	O
)	O
;	O
static	O
void	O
list_symbol_table	function
(	O
void	O
)	O
;	O
static	O
int	O
debugging_pseudo	function
(	O
list_info_type	struct
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
void	O
listing_listing	function
(	O
char	O
*	O
)	O
;	O
static	O
void	O
listing_message	function
(	O
const	O
char	O
*	O
name	pointer
,	O
const	O
char	O
*	O
message	pointer
)	O
{	O
if	O
(	O
listing_tail	pointer
!=	O
(	O
list_info_type	struct
*	O
)	O
NULL	O
)	O
{	O
char	O
*	O
n	int
=	O
concat	function
(	O
name	pointer
,	O
message	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
struct	O
list_message	struct
*	O
lm	pointer
=	O
XNEW	O
(	O
struct	O
list_message	struct
)	O
;	O
lm	pointer
->	O
message	pointer
=	O
n	int
;	O
lm	pointer
->	O
next	pointer
=	O
NULL	O
;	O
if	O
(	O
listing_tail	pointer
->	O
last_message	pointer
)	O
listing_tail	pointer
->	O
last_message	pointer
->	O
next	pointer
=	O
lm	pointer
;	O
else	O
listing_tail	pointer
->	O
messages	pointer
=	O
lm	pointer
;	O
listing_tail	pointer
->	O
last_message	pointer
=	O
lm	pointer
;	O
}	O
}	O
void	O
listing_warning	function
(	O
const	O
char	O
*	O
message	pointer
)	O
{	O
listing_message	function
(	O
_	O
(	O
"Warning: "	pointer
)	O
,	O
message	pointer
)	O
;	O
}	O
void	O
listing_error	function
(	O
const	O
char	O
*	O
message	pointer
)	O
{	O
listing_message	function
(	O
_	O
(	O
"Error: "	pointer
)	O
,	O
message	pointer
)	O
;	O
}	O
static	O
file_info_type	struct
*	O
file_info	function
(	O
const	O
char	O
*	O
file_name	pointer
)	O
{	O
file_info_type	struct
*	O
p	pointer
=	O
file_info_head	pointer
;	O
while	O
(	O
p	pointer
!=	O
(	O
file_info_type	struct
*	O
)	O
NULL	O
)	O
{	O
if	O
(	O
filename_cmp	function
(	O
p	pointer
->	O
filename	pointer
,	O
file_name	pointer
)	O
==	O
0	int
)	O
return	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
;	O
}	O
p	pointer
=	O
XNEW	O
(	O
file_info_type	struct
)	O
;	O
p	pointer
->	O
next	pointer
=	O
file_info_head	pointer
;	O
file_info_head	pointer
=	O
p	pointer
;	O
p	pointer
->	O
filename	pointer
=	O
xstrdup	function
(	O
file_name	pointer
)	O
;	O
p	pointer
->	O
pos	long
=	O
0	int
;	O
p	pointer
->	O
linenum	int
=	O
0	int
;	O
p	pointer
->	O
at_end	int
=	O
0	int
;	O
return	O
p	pointer
;	O
}	O
static	O
void	O
new_frag	function
(	O
void	O
)	O
{	O
frag_wane	function
(	O
frag_now	pointer
)	O
;	O
frag_new	function
(	O
0	int
)	O
;	O
}	O
void	O
listing_newline	function
(	O
char	O
*	O
ps	pointer
)	O
{	O
const	O
char	O
*	O
file	pointer
;	O
unsigned	O
int	O
line	int
;	O
static	O
unsigned	O
int	O
last_line	int
=	O
0xffff	int
;	O
static	O
const	O
char	O
*	O
last_file	pointer
=	O
NULL	O
;	O
list_info_type	struct
*	O
new_i	pointer
=	O
NULL	O
;	O
if	O
(	O
listing	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
now_seg	pointer
==	O
absolute_section	O
)	O
return	O
;	O
if	O
(	O
(	O
listing	int
&	O
LISTING_NODEBUG	int
)	O
!=	O
0	int
&&	O
listing_tail	pointer
!=	O
NULL	O
&&	O
!	O
listing_tail	pointer
->	O
debugging	int
)	O
{	O
const	O
char	O
*	O
segname	pointer
;	O
segname	pointer
=	O
segment_name	O
(	O
now_seg	pointer
)	O
;	O
if	O
(	O
strncmp	function
(	O
segname	pointer
,	O
".debug"	pointer
,	O
sizeof	O
".debug"	pointer
-	O
1	int
)	O
==	O
0	int
||	O
strncmp	function
(	O
segname	pointer
,	O
".line"	pointer
,	O
sizeof	O
".line"	pointer
-	O
1	int
)	O
==	O
0	int
)	O
listing_tail	pointer
->	O
debugging	int
=	O
1	int
;	O
}	O
if	O
(	O
listing	int
&	O
LISTING_HLL	int
)	O
file	pointer
=	O
as_where	function
(	O
&	O
line	int
)	O
;	O
else	O
file	pointer
=	O
as_where_physical	function
(	O
&	O
line	int
)	O
;	O
if	O
(	O
ps	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
line	int
==	O
last_line	int
&&	O
!	O
(	O
last_file	pointer
&&	O
file	pointer
&&	O
filename_cmp	function
(	O
file	pointer
,	O
last_file	pointer
)	O
)	O
)	O
return	O
;	O
new_i	pointer
=	O
XNEW	O
(	O
list_info_type	struct
)	O
;	O
if	O
(	O
strcmp	function
(	O
file	pointer
,	O
_	O
(	O
"{standard input}"	pointer
)	O
)	O
==	O
0	int
&&	O
input_line_pointer	pointer
!=	O
NULL	O
)	O
{	O
char	O
*	O
copy	int
,	O
*	O
src	pointer
,	O
*	O
dest	pointer
;	O
int	O
len	long
;	O
int	O
seen_quote	int
=	O
0	int
;	O
int	O
seen_slash	int
=	O
0	int
;	O
for	O
(	O
copy	int
=	O
input_line_pointer	pointer
;	O
*	O
copy	int
&&	O
(	O
seen_quote	int
||	O
is_end_of_line	array
[	O
(	O
unsigned	O
char	O
)	O
*	O
copy	int
]	O
!=	O
1	int
)	O
;	O
copy	int
++	O
)	O
{	O
if	O
(	O
seen_slash	int
)	O
seen_slash	int
=	O
0	int
;	O
else	O
if	O
(	O
*	O
copy	int
==	O
'\\'	O
)	O
seen_slash	int
=	O
1	int
;	O
else	O
if	O
(	O
*	O
copy	int
==	O
'"'	O
)	O
seen_quote	int
=	O
!	O
seen_quote	int
;	O
}	O
len	long
=	O
copy	int
-	O
input_line_pointer	pointer
+	O
1	int
;	O
copy	int
=	O
XNEWVEC	O
(	O
char	O
,	O
len	long
)	O
;	O
src	pointer
=	O
input_line_pointer	pointer
;	O
dest	pointer
=	O
copy	int
;	O
while	O
(	O
--	O
len	long
)	O
{	O
unsigned	O
char	O
c	struct
=	O
*	O
src	pointer
++	O
;	O
if	O
(	O
!	O
ISCNTRL	O
(	O
c	struct
)	O
)	O
*	O
dest	pointer
++	O
=	O
c	struct
;	O
}	O
*	O
dest	pointer
=	O
0	int
;	O
new_i	pointer
->	O
line_contents	pointer
=	O
copy	int
;	O
}	O
else	O
new_i	pointer
->	O
line_contents	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
new_i	pointer
=	O
XNEW	O
(	O
list_info_type	struct
)	O
;	O
new_i	pointer
->	O
line_contents	pointer
=	O
ps	pointer
;	O
}	O
last_line	int
=	O
line	int
;	O
last_file	pointer
=	O
file	pointer
;	O
new_frag	function
(	O
)	O
;	O
if	O
(	O
listing_tail	pointer
)	O
listing_tail	pointer
->	O
next	pointer
=	O
new_i	pointer
;	O
else	O
head	pointer
=	O
new_i	pointer
;	O
listing_tail	pointer
=	O
new_i	pointer
;	O
new_i	pointer
->	O
frag	struct
=	O
frag_now	pointer
;	O
new_i	pointer
->	O
line	int
=	O
line	int
;	O
new_i	pointer
->	O
file	pointer
=	O
file_info	function
(	O
file	pointer
)	O
;	O
new_i	pointer
->	O
next	pointer
=	O
(	O
list_info_type	struct
*	O
)	O
NULL	O
;	O
new_i	pointer
->	O
messages	pointer
=	O
NULL	O
;	O
new_i	pointer
->	O
last_message	pointer
=	O
NULL	O
;	O
new_i	pointer
->	O
edict	enum
=	O
EDICT_NONE	int
;	O
new_i	pointer
->	O
hll_file	pointer
=	O
(	O
file_info_type	struct
*	O
)	O
NULL	O
;	O
new_i	pointer
->	O
hll_line	int
=	O
0	int
;	O
new_i	pointer
->	O
debugging	int
=	O
0	int
;	O
new_frag	function
(	O
)	O
;	O
if	O
(	O
(	O
listing	int
&	O
LISTING_NODEBUG	int
)	O
!=	O
0	int
)	O
{	O
const	O
char	O
*	O
segname	pointer
;	O
segname	pointer
=	O
segment_name	O
(	O
now_seg	pointer
)	O
;	O
if	O
(	O
strncmp	function
(	O
segname	pointer
,	O
".debug"	pointer
,	O
sizeof	O
".debug"	pointer
-	O
1	int
)	O
==	O
0	int
||	O
strncmp	function
(	O
segname	pointer
,	O
".line"	pointer
,	O
sizeof	O
".line"	pointer
-	O
1	int
)	O
==	O
0	int
)	O
new_i	pointer
->	O
debugging	int
=	O
1	int
;	O
}	O
}	O
void	O
listing_prev_line	function
(	O
void	O
)	O
{	O
list_info_type	struct
*	O
l	long
;	O
fragS	struct
*	O
f	pointer
;	O
if	O
(	O
head	pointer
==	O
(	O
list_info_type	struct
*	O
)	O
NULL	O
||	O
head	pointer
==	O
listing_tail	pointer
)	O
return	O
;	O
new_frag	function
(	O
)	O
;	O
for	O
(	O
l	long
=	O
head	pointer
;	O
l	long
->	O
next	pointer
!=	O
listing_tail	pointer
;	O
l	long
=	O
l	long
->	O
next	pointer
)	O
;	O
for	O
(	O
f	pointer
=	O
frchain_now	pointer
->	O
frch_root	pointer
;	O
f	pointer
!=	O
(	O
fragS	struct
*	O
)	O
NULL	O
;	O
f	pointer
=	O
f	pointer
->	O
fr_next	pointer
)	O
if	O
(	O
f	pointer
->	O
line	int
==	O
listing_tail	pointer
)	O
f	pointer
->	O
line	int
=	O
l	long
;	O
listing_tail	pointer
->	O
frag	struct
=	O
frag_now	pointer
;	O
new_frag	function
(	O
)	O
;	O
}	O
static	O
const	O
char	O
*	O
buffer_line	function
(	O
file_info_type	struct
*	O
file	pointer
,	O
char	O
*	O
line	int
,	O
unsigned	O
int	O
size	int
)	O
{	O
unsigned	O
int	O
count	int
=	O
0	int
;	O
int	O
c	struct
;	O
char	O
*	O
p	pointer
=	O
line	int
;	O
if	O
(	O
file	pointer
->	O
at_end	int
)	O
return	O
""	pointer
;	O
if	O
(	O
!	O
last_open_file_info	pointer
||	O
file	pointer
!=	O
last_open_file_info	pointer
)	O
{	O
if	O
(	O
last_open_file	pointer
)	O
{	O
last_open_file_info	pointer
->	O
pos	long
=	O
ftell	function
(	O
last_open_file	pointer
)	O
;	O
fclose	function
(	O
last_open_file	pointer
)	O
;	O
}	O
last_open_file_info	pointer
=	O
file	pointer
;	O
last_open_file	pointer
=	O
fopen	function
(	O
file	pointer
->	O
filename	pointer
,	O
FOPEN_RB	pointer
)	O
;	O
if	O
(	O
last_open_file	pointer
==	O
NULL	O
)	O
{	O
file	pointer
->	O
at_end	int
=	O
1	int
;	O
return	O
""	pointer
;	O
}	O
if	O
(	O
file	pointer
->	O
pos	long
)	O
fseek	function
(	O
last_open_file	pointer
,	O
file	pointer
->	O
pos	long
,	O
SEEK_SET	int
)	O
;	O
}	O
size	int
-=	O
1	int
;	O
c	struct
=	O
fgetc	function
(	O
last_open_file	pointer
)	O
;	O
while	O
(	O
c	struct
!=	O
EOF	O
&&	O
c	struct
!=	O
'\n'	O
&&	O
c	struct
!=	O
'\r'	O
)	O
{	O
if	O
(	O
count	int
<	O
size	int
)	O
*	O
p	pointer
++	O
=	O
c	struct
;	O
count	int
++	O
;	O
c	struct
=	O
fgetc	function
(	O
last_open_file	pointer
)	O
;	O
}	O
if	O
(	O
c	struct
==	O
'\r'	O
||	O
c	struct
==	O
'\n'	O
)	O
{	O
int	O
next	pointer
=	O
fgetc	function
(	O
last_open_file	pointer
)	O
;	O
if	O
(	O
(	O
c	struct
==	O
'\r'	O
&&	O
next	pointer
!=	O
'\n'	O
)	O
||	O
(	O
c	struct
==	O
'\n'	O
&&	O
next	pointer
!=	O
'\r'	O
)	O
)	O
ungetc	function
(	O
next	pointer
,	O
last_open_file	pointer
)	O
;	O
}	O
if	O
(	O
c	struct
==	O
EOF	O
)	O
{	O
file	pointer
->	O
at_end	int
=	O
1	int
;	O
if	O
(	O
count	int
+	O
2	int
<	O
size	int
)	O
{	O
*	O
p	pointer
++	O
=	O
'.'	O
;	O
*	O
p	pointer
++	O
=	O
'.'	O
;	O
*	O
p	pointer
++	O
=	O
'.'	O
;	O
}	O
}	O
file	pointer
->	O
linenum	int
++	O
;	O
*	O
p	pointer
++	O
=	O
0	int
;	O
return	O
line	int
;	O
}	O
static	O
void	O
rebuffer_line	function
(	O
file_info_type	struct
*	O
file	pointer
,	O
unsigned	O
int	O
linenum	int
,	O
char	O
*	O
buffer	pointer
,	O
unsigned	O
int	O
size	int
)	O
{	O
unsigned	O
int	O
count	int
=	O
0	int
;	O
unsigned	O
int	O
current_line	int
;	O
char	O
*	O
p	pointer
=	O
buffer	pointer
;	O
long	O
pos	long
;	O
long	O
pos2	long
;	O
int	O
c	struct
;	O
bfd_boolean	int
found	int
=	O
FALSE	int
;	O
if	O
(	O
file	pointer
==	O
NULL	O
||	O
buffer	pointer
==	O
NULL	O
||	O
size	int
<=	O
1	int
||	O
file	pointer
->	O
linenum	int
<=	O
linenum	int
)	O
return	O
;	O
if	O
(	O
last_open_file_info	pointer
==	O
NULL	O
||	O
file	pointer
!=	O
last_open_file_info	pointer
)	O
{	O
if	O
(	O
last_open_file	pointer
)	O
{	O
last_open_file_info	pointer
->	O
pos	long
=	O
ftell	function
(	O
last_open_file	pointer
)	O
;	O
fclose	function
(	O
last_open_file	pointer
)	O
;	O
}	O
last_open_file_info	pointer
=	O
file	pointer
;	O
last_open_file	pointer
=	O
fopen	function
(	O
file	pointer
->	O
filename	pointer
,	O
FOPEN_RB	pointer
)	O
;	O
if	O
(	O
last_open_file	pointer
==	O
NULL	O
)	O
{	O
file	pointer
->	O
at_end	int
=	O
1	int
;	O
return	O
;	O
}	O
if	O
(	O
file	pointer
->	O
pos	long
)	O
fseek	function
(	O
last_open_file	pointer
,	O
file	pointer
->	O
pos	long
,	O
SEEK_SET	int
)	O
;	O
}	O
pos2	long
=	O
pos	long
=	O
ftell	function
(	O
last_open_file	pointer
)	O
;	O
if	O
(	O
pos	long
<	O
3	int
)	O
return	O
;	O
current_line	int
=	O
file	pointer
->	O
linenum	int
;	O
size	int
-=	O
1	int
;	O
buffer	pointer
[	O
size	int
]	O
=	O
0	int
;	O
++	O
current_line	int
;	O
while	O
(	O
pos2	long
>	O
0	int
&&	O
!	O
found	int
)	O
{	O
char	O
*	O
ptr	pointer
;	O
pos2	long
=	O
(	O
long	O
)	O
size	int
>	O
pos2	long
?	O
0	int
:	O
pos2	long
-	O
size	int
;	O
fseek	function
(	O
last_open_file	pointer
,	O
pos2	long
,	O
SEEK_SET	int
)	O
;	O
if	O
(	O
fread	function
(	O
buffer	pointer
,	O
1	int
,	O
size	int
,	O
last_open_file	pointer
)	O
!=	O
size	int
)	O
{	O
as_warn	function
(	O
_	O
(	O
"unable to rebuffer file: %s\n"	pointer
)	O
,	O
file	pointer
->	O
filename	pointer
)	O
;	O
return	O
;	O
}	O
for	O
(	O
ptr	pointer
=	O
buffer	pointer
+	O
size	int
;	O
ptr	pointer
>=	O
buffer	pointer
;	O
--	O
ptr	pointer
)	O
{	O
if	O
(	O
*	O
ptr	pointer
==	O
'\n'	O
)	O
{	O
--	O
current_line	int
;	O
if	O
(	O
current_line	int
==	O
linenum	int
)	O
{	O
found	int
=	O
TRUE	int
;	O
pos2	long
+=	O
(	O
ptr	pointer
-	O
buffer	pointer
)	O
;	O
if	O
(	O
ptr	pointer
+	O
1	int
==	O
buffer	pointer
+	O
size	int
)	O
{	O
++	O
pos2	long
;	O
if	O
(	O
fgetc	function
(	O
last_open_file	pointer
)	O
==	O
'\r'	O
)	O
++	O
pos2	long
;	O
}	O
else	O
pos2	long
+=	O
(	O
ptr	pointer
[	O
1	int
]	O
==	O
'\r'	O
?	O
2	int
:	O
1	int
)	O
;	O
fseek	function
(	O
last_open_file	pointer
,	O
pos2	long
,	O
SEEK_SET	int
)	O
;	O
break	O
;	O
}	O
}	O
}	O
}	O
c	struct
=	O
fgetc	function
(	O
last_open_file	pointer
)	O
;	O
while	O
(	O
c	struct
!=	O
EOF	O
&&	O
c	struct
!=	O
'\n'	O
&&	O
c	struct
!=	O
'\r'	O
)	O
{	O
if	O
(	O
count	int
<	O
size	int
)	O
*	O
p	pointer
++	O
=	O
c	struct
;	O
count	int
++	O
;	O
c	struct
=	O
fgetc	function
(	O
last_open_file	pointer
)	O
;	O
}	O
if	O
(	O
c	struct
==	O
'\r'	O
||	O
c	struct
==	O
'\n'	O
)	O
{	O
int	O
next	pointer
=	O
fgetc	function
(	O
last_open_file	pointer
)	O
;	O
if	O
(	O
(	O
c	struct
==	O
'\r'	O
&&	O
next	pointer
!=	O
'\n'	O
)	O
||	O
(	O
c	struct
==	O
'\n'	O
&&	O
next	pointer
!=	O
'\r'	O
)	O
)	O
ungetc	function
(	O
next	pointer
,	O
last_open_file	pointer
)	O
;	O
}	O
*	O
p	pointer
++	O
=	O
0	int
;	O
fseek	function
(	O
last_open_file	pointer
,	O
pos	long
,	O
SEEK_SET	int
)	O
;	O
}	O
static	O
const	O
char	O
*	O
fn	pointer
;	O
static	O
unsigned	O
int	O
eject	int
;	O
static	O
unsigned	O
int	O
page	int
;	O
static	O
const	O
char	O
*	O
title	pointer
;	O
static	O
const	O
char	O
*	O
subtitle	pointer
;	O
static	O
unsigned	O
int	O
on_page	int
;	O
static	O
void	O
listing_page	function
(	O
list_info_type	struct
*	O
list	pointer
)	O
{	O
if	O
(	O
(	O
eject	int
||	O
(	O
on_page	int
>=	O
(	O
unsigned	O
int	O
)	O
paper_height	int
)	O
)	O
&&	O
paper_height	int
!=	O
0	int
)	O
{	O
unsigned	O
int	O
c	struct
=	O
10	int
;	O
int	O
had_title	int
=	O
0	int
;	O
int	O
had_subtitle	int
=	O
0	int
;	O
page	int
++	O
;	O
while	O
(	O
c	struct
!=	O
0	int
&&	O
list	pointer
)	O
{	O
if	O
(	O
list	pointer
->	O
edict	enum
==	O
EDICT_SBTTL	int
&&	O
!	O
had_subtitle	int
)	O
{	O
had_subtitle	int
=	O
1	int
;	O
subtitle	pointer
=	O
list	pointer
->	O
edict_arg	pointer
;	O
}	O
if	O
(	O
list	pointer
->	O
edict	enum
==	O
EDICT_TITLE	int
&&	O
!	O
had_title	int
)	O
{	O
had_title	int
=	O
1	int
;	O
title	pointer
=	O
list	pointer
->	O
edict_arg	pointer
;	O
}	O
list	pointer
=	O
list	pointer
->	O
next	pointer
;	O
c	struct
--	O
;	O
}	O
if	O
(	O
page	int
>	O
1	int
)	O
{	O
fprintf	function
(	O
list_file	pointer
,	O
"\f"	pointer
)	O
;	O
}	O
fprintf	function
(	O
list_file	pointer
,	O
"%s %s \t\t\tpage %d\n"	pointer
,	O
LISTING_HEADER	pointer
,	O
fn	pointer
,	O
page	int
)	O
;	O
fprintf	function
(	O
list_file	pointer
,	O
"%s\n"	pointer
,	O
title	pointer
)	O
;	O
fprintf	function
(	O
list_file	pointer
,	O
"%s\n"	pointer
,	O
subtitle	pointer
)	O
;	O
on_page	int
=	O
3	int
;	O
eject	int
=	O
0	int
;	O
}	O
}	O
static	O
void	O
emit_line	function
(	O
list_info_type	struct
*	O
list	pointer
,	O
const	O
char	O
*	O
format	enum
,	O
...	O
)	O
{	O
va_list	array
args	array
;	O
va_start	O
(	O
args	array
,	O
format	enum
)	O
;	O
vfprintf	function
(	O
list_file	pointer
,	O
format	enum
,	O
args	array
)	O
;	O
on_page	int
++	O
;	O
listing_page	function
(	O
list	pointer
)	O
;	O
va_end	O
(	O
args	array
)	O
;	O
}	O
static	O
unsigned	O
int	O
calc_hex	function
(	O
list_info_type	struct
*	O
list	pointer
)	O
{	O
int	O
data_buffer_size	int
;	O
list_info_type	struct
*	O
first	pointer
=	O
list	pointer
;	O
unsigned	O
int	O
address	long
=	O
~	O
(	O
unsigned	O
int	O
)	O
0	int
;	O
fragS	struct
*	O
frag	struct
;	O
fragS	struct
*	O
frag_ptr	pointer
;	O
unsigned	O
int	O
octet_in_frag	int
;	O
frag	struct
=	O
list	pointer
->	O
frag	struct
;	O
while	O
(	O
frag	struct
&&	O
frag	struct
->	O
line	int
!=	O
list	pointer
)	O
frag	struct
=	O
frag	struct
->	O
fr_next	pointer
;	O
frag_ptr	pointer
=	O
frag	struct
;	O
data_buffer_size	int
=	O
0	int
;	O
while	O
(	O
frag_ptr	pointer
!=	O
(	O
fragS	struct
*	O
)	O
NULL	O
&&	O
frag_ptr	pointer
->	O
line	int
==	O
first	pointer
)	O
{	O
octet_in_frag	int
=	O
0	int
;	O
while	O
(	O
octet_in_frag	int
<	O
frag_ptr	pointer
->	O
fr_fix	long
&&	O
data_buffer_size	int
<	O
MAX_BYTES	O
-	O
3	int
)	O
{	O
if	O
(	O
address	long
==	O
~	O
(	O
unsigned	O
int	O
)	O
0	int
)	O
address	long
=	O
frag_ptr	pointer
->	O
fr_address	long
/	O
OCTETS_PER_BYTE	O
;	O
sprintf	function
(	O
data_buffer	pointer
+	O
data_buffer_size	int
,	O
"%02X"	pointer
,	O
(	O
frag_ptr	pointer
->	O
fr_literal	array
[	O
octet_in_frag	int
]	O
)	O
&	O
0xff	int
)	O
;	O
data_buffer_size	int
+=	O
2	int
;	O
octet_in_frag	int
++	O
;	O
}	O
if	O
(	O
frag_ptr	pointer
->	O
fr_type	enum
==	O
rs_fill	int
)	O
{	O
unsigned	O
int	O
var_rep_max	int
=	O
octet_in_frag	int
;	O
unsigned	O
int	O
var_rep_idx	int
=	O
octet_in_frag	int
;	O
while	O
(	O
(	O
octet_in_frag	int
<	O
frag_ptr	pointer
->	O
fr_fix	long
+	O
frag_ptr	pointer
->	O
fr_var	long
*	O
frag_ptr	pointer
->	O
fr_offset	long
)	O
&&	O
data_buffer_size	int
<	O
MAX_BYTES	O
-	O
3	int
)	O
{	O
if	O
(	O
address	long
==	O
~	O
(	O
unsigned	O
int	O
)	O
0	int
)	O
address	long
=	O
frag_ptr	pointer
->	O
fr_address	long
/	O
OCTETS_PER_BYTE	O
;	O
sprintf	function
(	O
data_buffer	pointer
+	O
data_buffer_size	int
,	O
"%02X"	pointer
,	O
(	O
frag_ptr	pointer
->	O
fr_literal	array
[	O
var_rep_idx	int
]	O
)	O
&	O
0xff	int
)	O
;	O
data_buffer_size	int
+=	O
2	int
;	O
var_rep_idx	int
++	O
;	O
octet_in_frag	int
++	O
;	O
if	O
(	O
var_rep_idx	int
>=	O
frag_ptr	pointer
->	O
fr_fix	long
+	O
frag_ptr	pointer
->	O
fr_var	long
)	O
var_rep_idx	int
=	O
var_rep_max	int
;	O
}	O
}	O
frag_ptr	pointer
=	O
frag_ptr	pointer
->	O
fr_next	pointer
;	O
}	O
data_buffer	pointer
[	O
data_buffer_size	int
]	O
=	O
'\0'	O
;	O
return	O
address	long
;	O
}	O
static	O
void	O
print_lines	function
(	O
list_info_type	struct
*	O
list	pointer
,	O
unsigned	O
int	O
lineno	pointer
,	O
const	O
char	O
*	O
string	pointer
,	O
unsigned	O
int	O
address	long
)	O
{	O
unsigned	O
int	O
idx	int
;	O
unsigned	O
int	O
nchars	long
;	O
unsigned	O
int	O
lines	int
;	O
unsigned	O
int	O
octet_in_word	int
=	O
0	int
;	O
char	O
*	O
src	pointer
=	O
data_buffer	pointer
;	O
int	O
cur	int
;	O
struct	O
list_message	struct
*	O
msg	pointer
;	O
listing_page	function
(	O
list	pointer
)	O
;	O
nchars	long
=	O
(	O
LISTING_WORD_SIZE	int
*	O
2	int
+	O
1	int
)	O
*	O
listing_lhs_width	int
;	O
if	O
(	O
address	long
==	O
~	O
(	O
unsigned	O
int	O
)	O
0	int
)	O
{	O
fprintf	function
(	O
list_file	pointer
,	O
"% 4d     "	pointer
,	O
lineno	pointer
)	O
;	O
for	O
(	O
idx	int
=	O
0	int
;	O
idx	int
<	O
nchars	long
;	O
idx	int
++	O
)	O
fprintf	function
(	O
list_file	pointer
,	O
" "	pointer
)	O
;	O
emit_line	function
(	O
NULL	O
,	O
"\t%s\n"	pointer
,	O
string	pointer
?	O
string	pointer
:	O
""	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
had_errors	function
(	O
)	O
)	O
fprintf	function
(	O
list_file	pointer
,	O
"% 4d ???? "	pointer
,	O
lineno	pointer
)	O
;	O
else	O
fprintf	function
(	O
list_file	pointer
,	O
"% 4d %04x "	pointer
,	O
lineno	pointer
,	O
address	long
)	O
;	O
idx	int
=	O
0	int
;	O
cur	int
=	O
0	int
;	O
while	O
(	O
src	pointer
[	O
cur	int
]	O
&&	O
idx	int
<	O
nchars	long
)	O
{	O
int	O
offset	long
;	O
offset	long
=	O
cur	int
;	O
fprintf	function
(	O
list_file	pointer
,	O
"%c%c"	pointer
,	O
src	pointer
[	O
offset	long
]	O
,	O
src	pointer
[	O
offset	long
+	O
1	int
]	O
)	O
;	O
cur	int
+=	O
2	int
;	O
octet_in_word	int
++	O
;	O
if	O
(	O
octet_in_word	int
==	O
LISTING_WORD_SIZE	int
)	O
{	O
fprintf	function
(	O
list_file	pointer
,	O
" "	pointer
)	O
;	O
idx	int
++	O
;	O
octet_in_word	int
=	O
0	int
;	O
}	O
idx	int
+=	O
2	int
;	O
}	O
for	O
(	O
;	O
idx	int
<	O
nchars	long
;	O
idx	int
++	O
)	O
fprintf	function
(	O
list_file	pointer
,	O
" "	pointer
)	O
;	O
emit_line	function
(	O
list	pointer
,	O
"\t%s\n"	pointer
,	O
string	pointer
?	O
string	pointer
:	O
""	pointer
)	O
;	O
for	O
(	O
msg	pointer
=	O
list	pointer
->	O
messages	pointer
;	O
msg	pointer
;	O
msg	pointer
=	O
msg	pointer
->	O
next	pointer
)	O
emit_line	function
(	O
list	pointer
,	O
"****  %s\n"	pointer
,	O
msg	pointer
->	O
message	pointer
)	O
;	O
for	O
(	O
lines	int
=	O
0	int
;	O
lines	int
<	O
(	O
unsigned	O
int	O
)	O
listing_lhs_cont_lines	int
&&	O
src	pointer
[	O
cur	int
]	O
;	O
lines	int
++	O
)	O
{	O
nchars	long
=	O
(	O
(	O
LISTING_WORD_SIZE	int
*	O
2	int
)	O
+	O
1	int
)	O
*	O
listing_lhs_width_second	int
-	O
1	int
;	O
idx	int
=	O
0	int
;	O
fprintf	function
(	O
list_file	pointer
,	O
"% 4d      "	pointer
,	O
lineno	pointer
)	O
;	O
while	O
(	O
src	pointer
[	O
cur	int
]	O
&&	O
idx	int
<	O
nchars	long
)	O
{	O
int	O
offset	long
;	O
offset	long
=	O
cur	int
;	O
fprintf	function
(	O
list_file	pointer
,	O
"%c%c"	pointer
,	O
src	pointer
[	O
offset	long
]	O
,	O
src	pointer
[	O
offset	long
+	O
1	int
]	O
)	O
;	O
cur	int
+=	O
2	int
;	O
idx	int
+=	O
2	int
;	O
octet_in_word	int
++	O
;	O
if	O
(	O
octet_in_word	int
==	O
LISTING_WORD_SIZE	int
)	O
{	O
fprintf	function
(	O
list_file	pointer
,	O
" "	pointer
)	O
;	O
idx	int
++	O
;	O
octet_in_word	int
=	O
0	int
;	O
}	O
}	O
emit_line	function
(	O
list	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
}	O
static	O
void	O
list_symbol_table	function
(	O
void	O
)	O
{	O
extern	O
symbolS	struct
*	O
symbol_rootP	pointer
;	O
int	O
got_some	int
=	O
0	int
;	O
symbolS	struct
*	O
ptr	pointer
;	O
eject	int
=	O
1	int
;	O
listing_page	function
(	O
NULL	O
)	O
;	O
for	O
(	O
ptr	pointer
=	O
symbol_rootP	pointer
;	O
ptr	pointer
!=	O
(	O
symbolS	struct
*	O
)	O
NULL	O
;	O
ptr	pointer
=	O
symbol_next	function
(	O
ptr	pointer
)	O
)	O
{	O
if	O
(	O
SEG_NORMAL	O
(	O
S_GET_SEGMENT	function
(	O
ptr	pointer
)	O
)	O
||	O
S_GET_SEGMENT	function
(	O
ptr	pointer
)	O
==	O
absolute_section	O
)	O
{	O
if	O
(	O
symbol_section_p	function
(	O
ptr	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
S_GET_NAME	function
(	O
ptr	pointer
)	O
)	O
{	O
char	O
buf	pointer
[	O
30	int
]	O
,	O
fmt	pointer
[	O
8	int
]	O
;	O
valueT	long
val	int
=	O
S_GET_VALUE	function
(	O
ptr	pointer
)	O
;	O
if	O
(	O
sizeof	O
(	O
val	int
)	O
==	O
4	int
&&	O
sizeof	O
(	O
int	O
)	O
==	O
4	int
)	O
sprintf	function
(	O
buf	pointer
,	O
"%08lx"	pointer
,	O
(	O
unsigned	O
long	O
)	O
val	int
)	O
;	O
else	O
if	O
(	O
sizeof	O
(	O
val	int
)	O
<=	O
sizeof	O
(	O
unsigned	O
long	O
)	O
)	O
{	O
sprintf	function
(	O
fmt	pointer
,	O
"%%0%lulx"	pointer
,	O
(	O
unsigned	O
long	O
)	O
(	O
sizeof	O
(	O
val	int
)	O
*	O
2	int
)	O
)	O
;	O
sprintf	function
(	O
buf	pointer
,	O
fmt	pointer
,	O
(	O
unsigned	O
long	O
)	O
val	int
)	O
;	O
}	O
else	O
if	O
(	O
sizeof	O
(	O
val	int
)	O
>	O
4	int
)	O
sprintf_vma	O
(	O
buf	pointer
,	O
val	int
)	O
;	O
else	O
abort	function
(	O
)	O
;	O
if	O
(	O
!	O
got_some	int
)	O
{	O
fprintf	function
(	O
list_file	pointer
,	O
"DEFINED SYMBOLS\n"	pointer
)	O
;	O
on_page	int
++	O
;	O
got_some	int
=	O
1	int
;	O
}	O
if	O
(	O
symbol_get_frag	function
(	O
ptr	pointer
)	O
&&	O
symbol_get_frag	function
(	O
ptr	pointer
)	O
->	O
line	int
)	O
{	O
fprintf	function
(	O
list_file	pointer
,	O
"%20s:%-5d  %s:%s %s\n"	pointer
,	O
symbol_get_frag	function
(	O
ptr	pointer
)	O
->	O
line	int
->	O
file	pointer
->	O
filename	pointer
,	O
symbol_get_frag	function
(	O
ptr	pointer
)	O
->	O
line	int
->	O
line	int
,	O
segment_name	O
(	O
S_GET_SEGMENT	function
(	O
ptr	pointer
)	O
)	O
,	O
buf	pointer
,	O
S_GET_NAME	function
(	O
ptr	pointer
)	O
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
list_file	pointer
,	O
"%33s:%s %s\n"	pointer
,	O
segment_name	O
(	O
S_GET_SEGMENT	function
(	O
ptr	pointer
)	O
)	O
,	O
buf	pointer
,	O
S_GET_NAME	function
(	O
ptr	pointer
)	O
)	O
;	O
}	O
on_page	int
++	O
;	O
listing_page	function
(	O
NULL	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
got_some	int
)	O
{	O
fprintf	function
(	O
list_file	pointer
,	O
"NO DEFINED SYMBOLS\n"	pointer
)	O
;	O
on_page	int
++	O
;	O
}	O
emit_line	function
(	O
NULL	O
,	O
"\n"	pointer
)	O
;	O
got_some	int
=	O
0	int
;	O
for	O
(	O
ptr	pointer
=	O
symbol_rootP	pointer
;	O
ptr	pointer
!=	O
(	O
symbolS	struct
*	O
)	O
NULL	O
;	O
ptr	pointer
=	O
symbol_next	function
(	O
ptr	pointer
)	O
)	O
{	O
if	O
(	O
S_GET_NAME	function
(	O
ptr	pointer
)	O
&&	O
strlen	function
(	O
S_GET_NAME	function
(	O
ptr	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
S_GET_SEGMENT	function
(	O
ptr	pointer
)	O
==	O
undefined_section	O
)	O
{	O
if	O
(	O
!	O
got_some	int
)	O
{	O
got_some	int
=	O
1	int
;	O
emit_line	function
(	O
NULL	O
,	O
"UNDEFINED SYMBOLS\n"	pointer
)	O
;	O
}	O
emit_line	function
(	O
NULL	O
,	O
"%s\n"	pointer
,	O
S_GET_NAME	function
(	O
ptr	pointer
)	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
got_some	int
)	O
emit_line	function
(	O
NULL	O
,	O
"NO UNDEFINED SYMBOLS\n"	pointer
)	O
;	O
}	O
typedef	O
struct	O
cached_line	struct
{	O
file_info_type	struct
*	O
file	pointer
;	O
unsigned	O
int	O
line	int
;	O
char	O
buffer	pointer
[	O
LISTING_RHS_WIDTH	int
]	O
;	O
}	O
cached_line	struct
;	O
static	O
void	O
print_source	function
(	O
file_info_type	struct
*	O
current_file	pointer
,	O
list_info_type	struct
*	O
list	pointer
,	O
unsigned	O
int	O
width	int
)	O
{	O
static	O
cached_line	struct
cached_lines	array
[	O
NUM_CACHE_LINES	int
]	O
;	O
static	O
int	O
next_free_line	int
=	O
0	int
;	O
cached_line	struct
*	O
cache	pointer
=	O
NULL	O
;	O
if	O
(	O
current_file	pointer
->	O
linenum	int
>	O
list	pointer
->	O
hll_line	int
&&	O
list	pointer
->	O
hll_line	int
>	O
0	int
)	O
{	O
int	O
i	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
NUM_CACHE_LINES	int
;	O
i	pointer
++	O
)	O
if	O
(	O
cached_lines	array
[	O
i	pointer
]	O
.	O
file	pointer
==	O
current_file	pointer
&&	O
cached_lines	array
[	O
i	pointer
]	O
.	O
line	int
==	O
list	pointer
->	O
hll_line	int
)	O
{	O
cache	pointer
=	O
cached_lines	array
+	O
i	pointer
;	O
break	O
;	O
}	O
if	O
(	O
i	pointer
==	O
NUM_CACHE_LINES	int
)	O
{	O
cache	pointer
=	O
cached_lines	array
+	O
next_free_line	int
;	O
next_free_line	int
++	O
;	O
if	O
(	O
next_free_line	int
==	O
NUM_CACHE_LINES	int
)	O
next_free_line	int
=	O
0	int
;	O
cache	pointer
->	O
file	pointer
=	O
current_file	pointer
;	O
cache	pointer
->	O
line	int
=	O
list	pointer
->	O
hll_line	int
;	O
cache	pointer
->	O
buffer	pointer
[	O
0	int
]	O
=	O
0	int
;	O
rebuffer_line	function
(	O
current_file	pointer
,	O
cache	pointer
->	O
line	int
,	O
cache	pointer
->	O
buffer	pointer
,	O
width	int
)	O
;	O
}	O
emit_line	function
(	O
list	pointer
,	O
"%4u:%-13s **** %s\n"	pointer
,	O
cache	pointer
->	O
line	int
,	O
cache	pointer
->	O
file	pointer
->	O
filename	pointer
,	O
cache	pointer
->	O
buffer	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
current_file	pointer
->	O
at_end	int
)	O
{	O
int	O
num_lines_shown	int
=	O
0	int
;	O
while	O
(	O
current_file	pointer
->	O
linenum	int
<	O
list	pointer
->	O
hll_line	int
&&	O
!	O
current_file	pointer
->	O
at_end	int
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
cache	pointer
=	O
cached_lines	array
+	O
next_free_line	int
;	O
cache	pointer
->	O
file	pointer
=	O
current_file	pointer
;	O
cache	pointer
->	O
line	int
=	O
current_file	pointer
->	O
linenum	int
+	O
1	int
;	O
cache	pointer
->	O
buffer	pointer
[	O
0	int
]	O
=	O
0	int
;	O
p	pointer
=	O
buffer_line	function
(	O
current_file	pointer
,	O
cache	pointer
->	O
buffer	pointer
,	O
width	int
)	O
;	O
if	O
(	O
num_lines_shown	int
==	O
0	int
)	O
{	O
next_free_line	int
++	O
;	O
if	O
(	O
next_free_line	int
==	O
NUM_CACHE_LINES	int
)	O
next_free_line	int
=	O
0	int
;	O
}	O
emit_line	function
(	O
list	pointer
,	O
"%4u:%-13s **** %s\n"	pointer
,	O
cache	pointer
->	O
line	int
,	O
cache	pointer
->	O
file	pointer
->	O
filename	pointer
,	O
p	pointer
)	O
;	O
num_lines_shown	int
++	O
;	O
}	O
}	O
}	O
static	O
int	O
debugging_pseudo	function
(	O
list_info_type	struct
*	O
list	pointer
,	O
const	O
char	O
*	O
line	int
)	O
{	O
static	O
int	O
in_debug	int
;	O
int	O
was_debug	int
;	O
if	O
(	O
list	pointer
->	O
debugging	int
)	O
{	O
in_debug	int
=	O
1	int
;	O
return	O
1	int
;	O
}	O
was_debug	int
=	O
in_debug	int
;	O
in_debug	int
=	O
0	int
;	O
while	O
(	O
ISSPACE	O
(	O
*	O
line	int
)	O
)	O
line	int
++	O
;	O
if	O
(	O
*	O
line	int
!=	O
'.'	O
)	O
{	O
if	O
(	O
was_debug	int
&&	O
*	O
line	int
==	O
'\0'	O
&&	O
list	pointer
->	O
next	pointer
!=	O
NULL	O
&&	O
list	pointer
->	O
next	pointer
->	O
debugging	int
)	O
{	O
in_debug	int
=	O
1	int
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
line	int
++	O
;	O
if	O
(	O
strncmp	function
(	O
line	int
,	O
"def"	pointer
,	O
3	int
)	O
==	O
0	int
)	O
return	O
1	int
;	O
if	O
(	O
strncmp	function
(	O
line	int
,	O
"val"	pointer
,	O
3	int
)	O
==	O
0	int
)	O
return	O
1	int
;	O
if	O
(	O
strncmp	function
(	O
line	int
,	O
"scl"	pointer
,	O
3	int
)	O
==	O
0	int
)	O
return	O
1	int
;	O
if	O
(	O
strncmp	function
(	O
line	int
,	O
"line"	pointer
,	O
4	int
)	O
==	O
0	int
)	O
return	O
1	int
;	O
if	O
(	O
strncmp	function
(	O
line	int
,	O
"endef"	pointer
,	O
5	int
)	O
==	O
0	int
)	O
return	O
1	int
;	O
if	O
(	O
strncmp	function
(	O
line	int
,	O
"ln"	pointer
,	O
2	int
)	O
==	O
0	int
)	O
return	O
1	int
;	O
if	O
(	O
strncmp	function
(	O
line	int
,	O
"type"	pointer
,	O
4	int
)	O
==	O
0	int
)	O
return	O
1	int
;	O
if	O
(	O
strncmp	function
(	O
line	int
,	O
"size"	pointer
,	O
4	int
)	O
==	O
0	int
)	O
return	O
1	int
;	O
if	O
(	O
strncmp	function
(	O
line	int
,	O
"dim"	pointer
,	O
3	int
)	O
==	O
0	int
)	O
return	O
1	int
;	O
if	O
(	O
strncmp	function
(	O
line	int
,	O
"tag"	pointer
,	O
3	int
)	O
==	O
0	int
)	O
return	O
1	int
;	O
if	O
(	O
strncmp	function
(	O
line	int
,	O
"stabs"	pointer
,	O
5	int
)	O
==	O
0	int
)	O
return	O
1	int
;	O
if	O
(	O
strncmp	function
(	O
line	int
,	O
"stabn"	pointer
,	O
5	int
)	O
==	O
0	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
listing_listing	function
(	O
char	O
*	O
name	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
list_info_type	struct
*	O
list	pointer
=	O
head	pointer
;	O
file_info_type	struct
*	O
current_hll_file	pointer
=	O
(	O
file_info_type	struct
*	O
)	O
NULL	O
;	O
char	O
*	O
buffer	pointer
;	O
const	O
char	O
*	O
p	pointer
;	O
int	O
show_listing	int
=	O
1	int
;	O
unsigned	O
int	O
width	int
;	O
buffer	pointer
=	O
XNEWVEC	O
(	O
char	O
,	O
listing_rhs_width	int
)	O
;	O
data_buffer	pointer
=	O
XNEWVEC	O
(	O
char	O
,	O
MAX_BYTES	O
)	O
;	O
eject	int
=	O
1	int
;	O
list	pointer
=	O
head	pointer
->	O
next	pointer
;	O
while	O
(	O
list	pointer
)	O
{	O
unsigned	O
int	O
list_line	int
;	O
width	int
=	O
listing_rhs_width	int
>	O
paper_width	int
?	O
paper_width	int
:	O
listing_rhs_width	int
;	O
list_line	int
=	O
list	pointer
->	O
line	int
;	O
switch	O
(	O
list	pointer
->	O
edict	enum
)	O
{	O
case	O
EDICT_LIST	int
:	O
list_line	int
--	O
;	O
break	O
;	O
case	O
EDICT_NOLIST	int
:	O
show_listing	int
--	O
;	O
break	O
;	O
case	O
EDICT_NOLIST_NEXT	int
:	O
if	O
(	O
show_listing	int
==	O
0	int
)	O
list_line	int
--	O
;	O
break	O
;	O
case	O
EDICT_EJECT	int
:	O
break	O
;	O
case	O
EDICT_NONE	int
:	O
break	O
;	O
case	O
EDICT_TITLE	int
:	O
title	pointer
=	O
list	pointer
->	O
edict_arg	pointer
;	O
break	O
;	O
case	O
EDICT_SBTTL	int
:	O
subtitle	pointer
=	O
list	pointer
->	O
edict_arg	pointer
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
if	O
(	O
show_listing	int
<=	O
0	int
)	O
{	O
while	O
(	O
list	pointer
->	O
file	pointer
->	O
linenum	int
<	O
list_line	int
&&	O
!	O
list	pointer
->	O
file	pointer
->	O
at_end	int
)	O
p	pointer
=	O
buffer_line	function
(	O
list	pointer
->	O
file	pointer
,	O
buffer	pointer
,	O
width	int
)	O
;	O
}	O
if	O
(	O
list	pointer
->	O
edict	enum
==	O
EDICT_LIST	int
||	O
(	O
list	pointer
->	O
edict	enum
==	O
EDICT_NOLIST_NEXT	int
&&	O
show_listing	int
==	O
0	int
)	O
)	O
{	O
list_line	int
++	O
;	O
show_listing	int
++	O
;	O
}	O
if	O
(	O
show_listing	int
>	O
0	int
)	O
{	O
if	O
(	O
list	pointer
->	O
hll_file	pointer
)	O
current_hll_file	pointer
=	O
list	pointer
->	O
hll_file	pointer
;	O
if	O
(	O
current_hll_file	pointer
&&	O
list	pointer
->	O
hll_line	int
&&	O
(	O
listing	int
&	O
LISTING_HLL	int
)	O
)	O
print_source	function
(	O
current_hll_file	pointer
,	O
list	pointer
,	O
width	int
)	O
;	O
if	O
(	O
list	pointer
->	O
line_contents	pointer
)	O
{	O
if	O
(	O
!	O
(	O
(	O
listing	int
&	O
LISTING_NODEBUG	int
)	O
&&	O
debugging_pseudo	function
(	O
list	pointer
,	O
list	pointer
->	O
line_contents	pointer
)	O
)	O
)	O
print_lines	function
(	O
list	pointer
,	O
list	pointer
->	O
file	pointer
->	O
linenum	int
==	O
0	int
?	O
list	pointer
->	O
line	int
:	O
list	pointer
->	O
file	pointer
->	O
linenum	int
,	O
list	pointer
->	O
line_contents	pointer
,	O
calc_hex	function
(	O
list	pointer
)	O
)	O
;	O
free	function
(	O
list	pointer
->	O
line_contents	pointer
)	O
;	O
list	pointer
->	O
line_contents	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
while	O
(	O
list	pointer
->	O
file	pointer
->	O
linenum	int
<	O
list_line	int
&&	O
!	O
list	pointer
->	O
file	pointer
->	O
at_end	int
)	O
{	O
unsigned	O
int	O
address	long
;	O
p	pointer
=	O
buffer_line	function
(	O
list	pointer
->	O
file	pointer
,	O
buffer	pointer
,	O
width	int
)	O
;	O
if	O
(	O
list	pointer
->	O
file	pointer
->	O
linenum	int
<	O
list_line	int
)	O
address	long
=	O
~	O
(	O
unsigned	O
int	O
)	O
0	int
;	O
else	O
address	long
=	O
calc_hex	function
(	O
list	pointer
)	O
;	O
if	O
(	O
!	O
(	O
(	O
listing	int
&	O
LISTING_NODEBUG	int
)	O
&&	O
debugging_pseudo	function
(	O
list	pointer
,	O
p	pointer
)	O
)	O
)	O
print_lines	function
(	O
list	pointer
,	O
list	pointer
->	O
file	pointer
->	O
linenum	int
,	O
p	pointer
,	O
address	long
)	O
;	O
}	O
}	O
if	O
(	O
list	pointer
->	O
edict	enum
==	O
EDICT_EJECT	int
)	O
eject	int
=	O
1	int
;	O
}	O
if	O
(	O
list	pointer
->	O
edict	enum
==	O
EDICT_NOLIST_NEXT	int
&&	O
show_listing	int
==	O
1	int
)	O
--	O
show_listing	int
;	O
list	pointer
=	O
list	pointer
->	O
next	pointer
;	O
}	O
free	function
(	O
buffer	pointer
)	O
;	O
free	function
(	O
data_buffer	pointer
)	O
;	O
data_buffer	pointer
=	O
NULL	O
;	O
}	O
static	O
void	O
print_timestamp	function
(	O
void	O
)	O
{	O
const	O
time_t	long
now	long
=	O
time	struct
(	O
NULL	O
)	O
;	O
struct	O
tm	struct
*	O
timestamp	pointer
;	O
char	O
stampstr	array
[	O
MAX_DATELEN	int
]	O
;	O
timestamp	pointer
=	O
localtime	function
(	O
&	O
now	long
)	O
;	O
strftime	function
(	O
stampstr	array
,	O
MAX_DATELEN	int
,	O
"%Y-%m-%dT%H:%M:%S.000%z"	pointer
,	O
timestamp	pointer
)	O
;	O
fprintf	function
(	O
list_file	pointer
,	O
_	O
(	O
"\n time stamp    \t: %s\n\n"	pointer
)	O
,	O
stampstr	array
)	O
;	O
}	O
static	O
void	O
print_single_option	function
(	O
char	O
*	O
opt	pointer
,	O
int	O
*	O
pos	long
)	O
{	O
int	O
opt_len	int
=	O
strlen	function
(	O
opt	pointer
)	O
;	O
if	O
(	O
(	O
*	O
pos	long
+	O
opt_len	int
)	O
<	O
paper_width	int
)	O
{	O
fprintf	function
(	O
list_file	pointer
,	O
_	O
(	O
"%s "	pointer
)	O
,	O
opt	pointer
)	O
;	O
*	O
pos	long
=	O
*	O
pos	long
+	O
opt_len	int
;	O
}	O
else	O
{	O
fprintf	function
(	O
list_file	pointer
,	O
_	O
(	O
"\n\t%s "	pointer
)	O
,	O
opt	pointer
)	O
;	O
*	O
pos	long
=	O
opt_len	int
;	O
}	O
}	O
static	O
void	O
print_options	function
(	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
const	O
char	O
*	O
field_name	pointer
=	O
_	O
(	O
"\n options passed\t: "	pointer
)	O
;	O
int	O
pos	long
=	O
strlen	function
(	O
field_name	pointer
)	O
;	O
char	O
*	O
*	O
p	pointer
;	O
fputs	function
(	O
field_name	pointer
,	O
list_file	pointer
)	O
;	O
for	O
(	O
p	pointer
=	O
&	O
argv	pointer
[	O
1	int
]	O
;	O
*	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
++	O
)	O
if	O
(	O
*	O
*	O
p	pointer
==	O
'-'	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
*	O
p	pointer
,	O
"-o"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
p	pointer
[	O
1	int
]	O
!=	O
NULL	O
)	O
p	pointer
++	O
;	O
continue	O
;	O
}	O
if	O
(	O
strcmp	function
(	O
*	O
p	pointer
,	O
"-v"	pointer
)	O
==	O
0	int
)	O
continue	O
;	O
print_single_option	function
(	O
*	O
p	pointer
,	O
&	O
pos	long
)	O
;	O
}	O
}	O
static	O
void	O
listing_general_info	function
(	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
eject	int
=	O
1	int
;	O
listing_page	function
(	O
NULL	O
)	O
;	O
fprintf	function
(	O
list_file	pointer
,	O
_	O
(	O
" GNU assembler version %s (%s)\n\t using BFD version %s."	pointer
)	O
,	O
VERSION	pointer
,	O
TARGET_ALIAS	pointer
,	O
BFD_VERSION_STRING	O
)	O
;	O
print_options	function
(	O
argv	pointer
)	O
;	O
fprintf	function
(	O
list_file	pointer
,	O
_	O
(	O
"\n input file    \t: %s"	pointer
)	O
,	O
fn	pointer
)	O
;	O
fprintf	function
(	O
list_file	pointer
,	O
_	O
(	O
"\n output file   \t: %s"	pointer
)	O
,	O
out_file_name	pointer
)	O
;	O
fprintf	function
(	O
list_file	pointer
,	O
_	O
(	O
"\n target        \t: %s"	pointer
)	O
,	O
TARGET_CANONICAL	pointer
)	O
;	O
print_timestamp	function
(	O
)	O
;	O
}	O
void	O
listing_print	function
(	O
char	O
*	O
name	pointer
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
using_stdout	int
;	O
title	pointer
=	O
""	pointer
;	O
subtitle	pointer
=	O
""	pointer
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
{	O
list_file	pointer
=	O
stdout	pointer
;	O
using_stdout	int
=	O
1	int
;	O
}	O
else	O
{	O
list_file	pointer
=	O
fopen	function
(	O
name	pointer
,	O
FOPEN_WT	pointer
)	O
;	O
if	O
(	O
list_file	pointer
!=	O
NULL	O
)	O
using_stdout	int
=	O
0	int
;	O
else	O
{	O
as_warn	function
(	O
_	O
(	O
"can't open %s: %s"	pointer
)	O
,	O
name	pointer
,	O
xstrerror	function
(	O
errno	O
)	O
)	O
;	O
list_file	pointer
=	O
stdout	pointer
;	O
using_stdout	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
listing	int
&	O
LISTING_NOFORM	int
)	O
paper_height	int
=	O
0	int
;	O
if	O
(	O
listing	int
&	O
LISTING_GENERAL	int
)	O
listing_general_info	function
(	O
argv	pointer
)	O
;	O
if	O
(	O
listing	int
&	O
LISTING_LISTING	int
)	O
listing_listing	function
(	O
name	pointer
)	O
;	O
if	O
(	O
listing	int
&	O
LISTING_SYMBOLS	int
)	O
list_symbol_table	function
(	O
)	O
;	O
if	O
(	O
!	O
using_stdout	int
)	O
{	O
if	O
(	O
fclose	function
(	O
list_file	pointer
)	O
==	O
EOF	O
)	O
as_warn	function
(	O
_	O
(	O
"can't close %s: %s"	pointer
)	O
,	O
name	pointer
,	O
xstrerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
if	O
(	O
last_open_file	pointer
)	O
fclose	function
(	O
last_open_file	pointer
)	O
;	O
}	O
void	O
listing_file	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
fn	pointer
=	O
name	pointer
;	O
}	O
void	O
listing_eject	function
(	O
int	O
ignore	int
ATTRIBUTE_UNUSED	O
)	O
{	O
if	O
(	O
listing	int
)	O
listing_tail	pointer
->	O
edict	enum
=	O
EDICT_EJECT	int
;	O
}	O
void	O
listing_list	function
(	O
int	O
on	int
)	O
{	O
if	O
(	O
listing	int
)	O
{	O
switch	O
(	O
on	int
)	O
{	O
case	O
0	int
:	O
if	O
(	O
listing_tail	pointer
->	O
edict	enum
==	O
EDICT_LIST	int
)	O
listing_tail	pointer
->	O
edict	enum
=	O
EDICT_NONE	int
;	O
else	O
listing_tail	pointer
->	O
edict	enum
=	O
EDICT_NOLIST	int
;	O
break	O
;	O
case	O
1	int
:	O
if	O
(	O
listing_tail	pointer
->	O
edict	enum
==	O
EDICT_NOLIST	int
||	O
listing_tail	pointer
->	O
edict	enum
==	O
EDICT_NOLIST_NEXT	int
)	O
listing_tail	pointer
->	O
edict	enum
=	O
EDICT_NONE	int
;	O
else	O
listing_tail	pointer
->	O
edict	enum
=	O
EDICT_LIST	int
;	O
break	O
;	O
case	O
2	int
:	O
listing_tail	pointer
->	O
edict	enum
=	O
EDICT_NOLIST_NEXT	int
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
}	O
}	O
void	O
listing_psize	function
(	O
int	O
width_only	int
)	O
{	O
if	O
(	O
!	O
width_only	int
)	O
{	O
paper_height	int
=	O
get_absolute_expression	function
(	O
)	O
;	O
if	O
(	O
paper_height	int
<	O
0	int
||	O
paper_height	int
>	O
1000	int
)	O
{	O
paper_height	int
=	O
0	int
;	O
as_warn	function
(	O
_	O
(	O
"strange paper height, set to no form"	pointer
)	O
)	O
;	O
}	O
if	O
(	O
*	O
input_line_pointer	pointer
!=	O
','	O
)	O
{	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
++	O
input_line_pointer	pointer
;	O
}	O
paper_width	int
=	O
get_absolute_expression	function
(	O
)	O
;	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
}	O
void	O
listing_nopage	function
(	O
int	O
ignore	int
ATTRIBUTE_UNUSED	O
)	O
{	O
paper_height	int
=	O
0	int
;	O
}	O
void	O
listing_title	function
(	O
int	O
depth	int
)	O
{	O
int	O
quoted	int
;	O
char	O
*	O
start	pointer
;	O
char	O
*	O
ttl	pointer
;	O
unsigned	O
int	O
length	char
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	pointer
!=	O
'\"'	O
)	O
quoted	int
=	O
0	int
;	O
else	O
{	O
quoted	int
=	O
1	int
;	O
++	O
input_line_pointer	pointer
;	O
}	O
start	pointer
=	O
input_line_pointer	pointer
;	O
while	O
(	O
*	O
input_line_pointer	pointer
)	O
{	O
if	O
(	O
quoted	int
?	O
*	O
input_line_pointer	pointer
==	O
'\"'	O
:	O
is_end_of_line	array
[	O
(	O
unsigned	O
char	O
)	O
*	O
input_line_pointer	pointer
]	O
)	O
{	O
if	O
(	O
listing	int
)	O
{	O
length	char
=	O
input_line_pointer	pointer
-	O
start	pointer
;	O
ttl	pointer
=	O
xmemdup0	function
(	O
start	pointer
,	O
length	char
)	O
;	O
listing_tail	pointer
->	O
edict	enum
=	O
depth	int
?	O
EDICT_SBTTL	int
:	O
EDICT_TITLE	int
;	O
listing_tail	pointer
->	O
edict_arg	pointer
=	O
ttl	pointer
;	O
}	O
if	O
(	O
quoted	int
)	O
input_line_pointer	pointer
++	O
;	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
else	O
if	O
(	O
*	O
input_line_pointer	pointer
==	O
'\n'	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"new line in title"	pointer
)	O
)	O
;	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
else	O
{	O
input_line_pointer	pointer
++	O
;	O
}	O
}	O
}	O
void	O
listing_source_line	function
(	O
unsigned	O
int	O
line	int
)	O
{	O
if	O
(	O
listing	int
)	O
{	O
new_frag	function
(	O
)	O
;	O
listing_tail	pointer
->	O
hll_line	int
=	O
line	int
;	O
new_frag	function
(	O
)	O
;	O
}	O
}	O
void	O
listing_source_file	function
(	O
const	O
char	O
*	O
file	pointer
)	O
{	O
if	O
(	O
listing	int
)	O
listing_tail	pointer
->	O
hll_file	pointer
=	O
file_info	function
(	O
file	pointer
)	O
;	O
}	O
