int	O
gsl_sum_levin_u_accel	function
(	O
const	O
double	O
*	O
array	pointer
,	O
const	O
size_t	long
array_size	long
,	O
gsl_sum_levin_u_workspace	struct
*	O
w	pointer
,	O
double	O
*	O
sum_accel	pointer
,	O
double	O
*	O
abserr	pointer
)	O
{	O
return	O
gsl_sum_levin_u_minmax	function
(	O
array	pointer
,	O
array_size	long
,	O
0	int
,	O
array_size	long
-	O
1	int
,	O
w	pointer
,	O
sum_accel	pointer
,	O
abserr	pointer
)	O
;	O
}	O
int	O
gsl_sum_levin_u_minmax	function
(	O
const	O
double	O
*	O
array	pointer
,	O
const	O
size_t	long
array_size	long
,	O
const	O
size_t	long
min_terms	long
,	O
const	O
size_t	long
max_terms	long
,	O
gsl_sum_levin_u_workspace	struct
*	O
w	pointer
,	O
double	O
*	O
sum_accel	pointer
,	O
double	O
*	O
abserr	pointer
)	O
{	O
size_t	long
size	long
=	O
array_size	long
;	O
while	O
(	O
size	long
>	O
0	int
&&	O
array	pointer
[	O
size	long
-	O
1	int
]	O
==	O
0	int
)	O
{	O
size	long
--	O
;	O
}	O
if	O
(	O
size	long
==	O
0	int
)	O
{	O
*	O
sum_accel	pointer
=	O
0.0	int
;	O
*	O
abserr	pointer
=	O
0.0	int
;	O
w	pointer
->	O
sum_plain	double
=	O
0.0	int
;	O
w	pointer
->	O
terms_used	long
=	O
0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
size	long
==	O
1	int
)	O
{	O
*	O
sum_accel	pointer
=	O
array	pointer
[	O
0	int
]	O
;	O
*	O
abserr	pointer
=	O
0.0	int
;	O
w	pointer
->	O
sum_plain	double
=	O
array	pointer
[	O
0	int
]	O
;	O
w	pointer
->	O
terms_used	long
=	O
1	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
const	O
double	O
SMALL	double
=	O
0.01	int
;	O
const	O
size_t	long
nmax	long
=	O
GSL_MAX	O
(	O
max_terms	long
,	O
array_size	long
)	O
-	O
1	int
;	O
double	O
noise_n	double
=	O
0.0	int
,	O
noise_nm1	double
=	O
0.0	int
;	O
double	O
trunc_n	double
=	O
0.0	int
,	O
trunc_nm1	double
=	O
0.0	int
;	O
double	O
actual_trunc_n	double
=	O
0.0	int
,	O
actual_trunc_nm1	double
=	O
0.0	int
;	O
double	O
result_n	double
=	O
0.0	int
,	O
result_nm1	double
=	O
0.0	int
;	O
double	O
variance	double
=	O
0	int
;	O
size_t	long
n	int
;	O
unsigned	O
int	O
i	long
;	O
int	O
better	int
=	O
0	int
;	O
int	O
before	int
=	O
0	int
;	O
int	O
converging	int
=	O
0	int
;	O
double	O
least_trunc	double
=	O
GSL_DBL_MAX	int
;	O
double	O
least_trunc_noise	double
=	O
GSL_DBL_MAX	int
;	O
double	O
least_trunc_result	double
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
min_terms	long
;	O
n	int
++	O
)	O
{	O
const	O
double	O
t	double
=	O
array	pointer
[	O
n	int
]	O
;	O
result_nm1	double
=	O
result_n	double
;	O
gsl_sum_levin_u_step	function
(	O
t	double
,	O
n	int
,	O
nmax	long
,	O
w	pointer
,	O
&	O
result_n	double
)	O
;	O
}	O
least_trunc_result	double
=	O
result_n	double
;	O
variance	double
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
)	O
{	O
double	O
dn	double
=	O
w	pointer
->	O
dsum	pointer
[	O
i	long
]	O
*	O
GSL_MACH_EPS	O
*	O
array	pointer
[	O
i	long
]	O
;	O
variance	double
+=	O
dn	double
*	O
dn	double
;	O
}	O
noise_n	double
=	O
sqrt	function
(	O
variance	double
)	O
;	O
for	O
(	O
;	O
n	int
<=	O
nmax	long
;	O
n	int
++	O
)	O
{	O
const	O
double	O
t	double
=	O
array	pointer
[	O
n	int
]	O
;	O
result_nm1	double
=	O
result_n	double
;	O
gsl_sum_levin_u_step	function
(	O
t	double
,	O
n	int
,	O
nmax	long
,	O
w	pointer
,	O
&	O
result_n	double
)	O
;	O
actual_trunc_nm1	double
=	O
actual_trunc_n	double
;	O
actual_trunc_n	double
=	O
fabs	function
(	O
result_n	double
-	O
result_nm1	double
)	O
;	O
trunc_nm1	double
=	O
trunc_n	double
;	O
trunc_n	double
=	O
0.5	int
*	O
(	O
actual_trunc_n	double
+	O
actual_trunc_nm1	double
)	O
;	O
noise_nm1	double
=	O
noise_n	double
;	O
variance	double
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<=	O
n	int
;	O
i	long
++	O
)	O
{	O
double	O
dn	double
=	O
w	pointer
->	O
dsum	pointer
[	O
i	long
]	O
*	O
GSL_MACH_EPS	O
*	O
array	pointer
[	O
i	long
]	O
;	O
variance	double
+=	O
dn	double
*	O
dn	double
;	O
}	O
noise_n	double
=	O
sqrt	function
(	O
variance	double
)	O
;	O
better	int
=	O
(	O
trunc_n	double
<	O
trunc_nm1	double
||	O
trunc_n	double
<	O
SMALL	double
*	O
fabs	function
(	O
result_n	double
)	O
)	O
;	O
converging	int
=	O
converging	int
||	O
(	O
better	int
&&	O
before	int
)	O
;	O
before	int
=	O
better	int
;	O
if	O
(	O
converging	int
)	O
{	O
if	O
(	O
trunc_n	double
<	O
least_trunc	double
)	O
{	O
least_trunc_result	double
=	O
result_n	double
;	O
least_trunc	double
=	O
trunc_n	double
;	O
least_trunc_noise	double
=	O
noise_n	double
;	O
}	O
if	O
(	O
noise_n	double
>	O
trunc_n	double
/	O
3.0	int
)	O
break	O
;	O
if	O
(	O
trunc_n	double
<	O
10.0	int
*	O
GSL_MACH_EPS	O
*	O
fabs	function
(	O
result_n	double
)	O
)	O
break	O
;	O
}	O
}	O
if	O
(	O
converging	int
)	O
{	O
*	O
sum_accel	pointer
=	O
least_trunc_result	double
;	O
*	O
abserr	pointer
=	O
GSL_MAX_DBL	function
(	O
least_trunc	double
,	O
least_trunc_noise	double
)	O
;	O
w	pointer
->	O
terms_used	long
=	O
n	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
*	O
sum_accel	pointer
=	O
result_n	double
;	O
*	O
abserr	pointer
=	O
GSL_MAX_DBL	function
(	O
trunc_n	double
,	O
noise_n	double
)	O
;	O
w	pointer
->	O
terms_used	long
=	O
n	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
}	O
int	O
gsl_sum_levin_u_step	function
(	O
const	O
double	O
term	double
,	O
const	O
size_t	long
n	int
,	O
const	O
size_t	long
nmax	long
,	O
gsl_sum_levin_u_workspace	struct
*	O
w	pointer
,	O
double	O
*	O
sum_accel	pointer
)	O
{	O
if	O
(	O
n	int
==	O
0	int
)	O
{	O
*	O
sum_accel	pointer
=	O
term	double
;	O
w	pointer
->	O
sum_plain	double
=	O
term	double
;	O
w	pointer
->	O
q_den	pointer
[	O
0	int
]	O
=	O
1.0	int
/	O
term	double
;	O
w	pointer
->	O
q_num	pointer
[	O
0	int
]	O
=	O
1.0	int
;	O
w	pointer
->	O
dq_den	pointer
[	O
I	O
(	O
0	int
,	O
0	int
)	O
]	O
=	O
-	O
1.0	int
/	O
(	O
term	double
*	O
term	double
)	O
;	O
w	pointer
->	O
dq_num	pointer
[	O
I	O
(	O
0	int
,	O
0	int
)	O
]	O
=	O
0.0	int
;	O
w	pointer
->	O
dsum	pointer
[	O
0	int
]	O
=	O
1.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
double	O
result	double
;	O
double	O
factor	double
=	O
1.0	int
;	O
double	O
ratio	double
=	O
(	O
double	O
)	O
n	int
/	O
(	O
n	int
+	O
1.0	int
)	O
;	O
unsigned	O
int	O
i	long
;	O
int	O
j	int
;	O
w	pointer
->	O
sum_plain	double
+=	O
term	double
;	O
w	pointer
->	O
q_den	pointer
[	O
n	int
]	O
=	O
1.0	int
/	O
(	O
term	double
*	O
(	O
n	int
+	O
1.0	int
)	O
*	O
(	O
n	int
+	O
1.0	int
)	O
)	O
;	O
w	pointer
->	O
q_num	pointer
[	O
n	int
]	O
=	O
w	pointer
->	O
sum_plain	double
*	O
w	pointer
->	O
q_den	pointer
[	O
n	int
]	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
)	O
{	O
w	pointer
->	O
dq_den	pointer
[	O
I	O
(	O
i	long
,	O
n	int
)	O
]	O
=	O
0	int
;	O
w	pointer
->	O
dq_num	pointer
[	O
I	O
(	O
i	long
,	O
n	int
)	O
]	O
=	O
w	pointer
->	O
q_den	pointer
[	O
n	int
]	O
;	O
}	O
w	pointer
->	O
dq_den	pointer
[	O
I	O
(	O
n	int
,	O
n	int
)	O
]	O
=	O
-	O
w	pointer
->	O
q_den	pointer
[	O
n	int
]	O
/	O
term	double
;	O
w	pointer
->	O
dq_num	pointer
[	O
I	O
(	O
n	int
,	O
n	int
)	O
]	O
=	O
w	pointer
->	O
q_den	pointer
[	O
n	int
]	O
+	O
w	pointer
->	O
sum_plain	double
*	O
(	O
w	pointer
->	O
dq_den	pointer
[	O
I	O
(	O
n	int
,	O
n	int
)	O
]	O
)	O
;	O
for	O
(	O
j	int
=	O
n	int
-	O
1	int
;	O
j	int
>=	O
0	int
;	O
j	int
--	O
)	O
{	O
double	O
c	double
=	O
factor	double
*	O
(	O
j	int
+	O
1	int
)	O
/	O
(	O
n	int
+	O
1	int
)	O
;	O
factor	double
*=	O
ratio	double
;	O
w	pointer
->	O
q_den	pointer
[	O
j	int
]	O
=	O
w	pointer
->	O
q_den	pointer
[	O
j	int
+	O
1	int
]	O
-	O
c	double
*	O
w	pointer
->	O
q_den	pointer
[	O
j	int
]	O
;	O
w	pointer
->	O
q_num	pointer
[	O
j	int
]	O
=	O
w	pointer
->	O
q_num	pointer
[	O
j	int
+	O
1	int
]	O
-	O
c	double
*	O
w	pointer
->	O
q_num	pointer
[	O
j	int
]	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
)	O
{	O
w	pointer
->	O
dq_den	pointer
[	O
I	O
(	O
i	long
,	O
j	int
)	O
]	O
=	O
w	pointer
->	O
dq_den	pointer
[	O
I	O
(	O
i	long
,	O
j	int
+	O
1	int
)	O
]	O
-	O
c	double
*	O
w	pointer
->	O
dq_den	pointer
[	O
I	O
(	O
i	long
,	O
j	int
)	O
]	O
;	O
w	pointer
->	O
dq_num	pointer
[	O
I	O
(	O
i	long
,	O
j	int
)	O
]	O
=	O
w	pointer
->	O
dq_num	pointer
[	O
I	O
(	O
i	long
,	O
j	int
+	O
1	int
)	O
]	O
-	O
c	double
*	O
w	pointer
->	O
dq_num	pointer
[	O
I	O
(	O
i	long
,	O
j	int
)	O
]	O
;	O
}	O
w	pointer
->	O
dq_den	pointer
[	O
I	O
(	O
n	int
,	O
j	int
)	O
]	O
=	O
w	pointer
->	O
dq_den	pointer
[	O
I	O
(	O
n	int
,	O
j	int
+	O
1	int
)	O
]	O
;	O
w	pointer
->	O
dq_num	pointer
[	O
I	O
(	O
n	int
,	O
j	int
)	O
]	O
=	O
w	pointer
->	O
dq_num	pointer
[	O
I	O
(	O
n	int
,	O
j	int
+	O
1	int
)	O
]	O
;	O
}	O
result	double
=	O
w	pointer
->	O
q_num	pointer
[	O
0	int
]	O
/	O
w	pointer
->	O
q_den	pointer
[	O
0	int
]	O
;	O
*	O
sum_accel	pointer
=	O
result	double
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<=	O
n	int
;	O
i	long
++	O
)	O
{	O
w	pointer
->	O
dsum	pointer
[	O
i	long
]	O
=	O
(	O
w	pointer
->	O
dq_num	pointer
[	O
I	O
(	O
i	long
,	O
0	int
)	O
]	O
-	O
result	double
*	O
w	pointer
->	O
dq_den	pointer
[	O
I	O
(	O
i	long
,	O
0	int
)	O
]	O
)	O
/	O
w	pointer
->	O
q_den	pointer
[	O
0	int
]	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
