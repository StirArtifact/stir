struct	O
rec_type_s	struct
{	O
char	O
*	O
name	pointer
;	O
enum	O
rec_type_kind_e	enum
kind	enum
;	O
char	O
*	O
expr	pointer
;	O
size_t	long
size	pointer
;	O
union	O
{	O
size_t	long
max_size	long
;	O
int	O
range	array
[	O
2	int
]	O
;	O
regex_t	struct
regexp	pointer
;	O
char	O
*	O
recname	pointer
;	O
char	O
*	O
*	O
names	pointer
;	O
}	O
data	pointer
;	O
}	O
;	O
struct	O
rec_type_reg_entry_s	struct
{	O
char	O
*	O
type_name	pointer
;	O
rec_type_t	pointer
type	enum
;	O
char	O
*	O
to_type	pointer
;	O
bool	bool
visited_p	bool
;	O
}	O
;	O
struct	O
rec_type_reg_s	struct
{	O
size_t	long
num_types	long
;	O
struct	O
rec_type_reg_entry_s	struct
*	O
types	pointer
;	O
}	O
;	O
static	O
enum	O
rec_type_kind_e	enum
rec_type_parse_type_kind	function
(	O
char	O
*	O
str	pointer
)	O
;	O
static	O
bool	bool
rec_type_check_int	function
(	O
rec_type_t	pointer
type	enum
,	O
const	O
char	O
*	O
str	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
;	O
static	O
bool	bool
rec_type_check_bool	function
(	O
rec_type_t	pointer
type	enum
,	O
const	O
char	O
*	O
str	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
;	O
static	O
bool	bool
rec_type_check_range	function
(	O
rec_type_t	pointer
type	enum
,	O
const	O
char	O
*	O
str	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
;	O
static	O
bool	bool
rec_type_check_real	function
(	O
rec_type_t	pointer
type	enum
,	O
const	O
char	O
*	O
str	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
;	O
static	O
bool	bool
rec_type_check_size	function
(	O
rec_type_t	pointer
type	enum
,	O
const	O
char	O
*	O
str	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
;	O
static	O
bool	bool
rec_type_check_line	function
(	O
rec_type_t	pointer
type	enum
,	O
const	O
char	O
*	O
str	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
;	O
static	O
bool	bool
rec_type_check_regexp	function
(	O
rec_type_t	pointer
type	enum
,	O
const	O
char	O
*	O
str	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
;	O
static	O
bool	bool
rec_type_check_date	function
(	O
rec_type_t	pointer
type	enum
,	O
const	O
char	O
*	O
str	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
;	O
static	O
bool	bool
rec_type_check_email	function
(	O
rec_type_t	pointer
type	enum
,	O
const	O
char	O
*	O
str	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
;	O
static	O
bool	bool
rec_type_check_enum	function
(	O
rec_type_t	pointer
type	enum
,	O
const	O
char	O
*	O
str	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
;	O
static	O
bool	bool
rec_type_check_field	function
(	O
rec_type_t	pointer
type	enum
,	O
const	O
char	O
*	O
str	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
;	O
static	O
bool	bool
rec_type_check_rec	function
(	O
rec_type_t	pointer
type	enum
,	O
const	O
char	O
*	O
str	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
;	O
static	O
bool	bool
rec_type_check_uuid	function
(	O
rec_type_t	pointer
type	enum
,	O
const	O
char	O
*	O
str	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
;	O
static	O
const	O
char	O
*	O
rec_type_parse_size	function
(	O
const	O
char	O
*	O
str	pointer
,	O
rec_type_t	pointer
type	enum
)	O
;	O
static	O
const	O
char	O
*	O
rec_type_parse_enum	function
(	O
const	O
char	O
*	O
str	pointer
,	O
rec_type_t	pointer
type	enum
)	O
;	O
static	O
const	O
char	O
*	O
rec_type_parse_regexp_type	function
(	O
const	O
char	O
*	O
str	pointer
,	O
rec_type_t	pointer
type	enum
)	O
;	O
static	O
const	O
char	O
*	O
rec_type_parse_range	function
(	O
const	O
char	O
*	O
str	pointer
,	O
rec_type_t	pointer
type	enum
)	O
;	O
static	O
const	O
char	O
*	O
rec_type_parse_rec	function
(	O
const	O
char	O
*	O
str	pointer
,	O
rec_type_t	pointer
type	enum
)	O
;	O
bool	bool
rec_type_descr_p	function
(	O
const	O
char	O
*	O
str	pointer
)	O
{	O
bool	bool
ret	bool
;	O
rec_type_t	pointer
aux_type	pointer
;	O
ret	bool
=	O
false	int
;	O
aux_type	pointer
=	O
rec_type_new	function
(	O
str	pointer
)	O
;	O
if	O
(	O
aux_type	pointer
)	O
{	O
ret	bool
=	O
true	int
;	O
rec_type_destroy	function
(	O
aux_type	pointer
)	O
;	O
}	O
return	O
ret	bool
;	O
}	O
char	O
*	O
rec_type_descr_type	function
(	O
char	O
*	O
str	pointer
)	O
{	O
char	O
*	O
result	pointer
=	O
NULL	O
;	O
char	O
*	O
name	pointer
;	O
const	O
char	O
*	O
p	pointer
;	O
if	O
(	O
rec_type_descr_p	function
(	O
str	pointer
)	O
)	O
{	O
p	pointer
=	O
str	pointer
;	O
rec_skip_blanks	function
(	O
&	O
p	pointer
)	O
;	O
if	O
(	O
rec_parse_regexp	function
(	O
&	O
p	pointer
,	O
"^"	pointer
REC_FNAME_RE	pointer
"(,"	pointer
REC_FNAME_RE	pointer
")*"	pointer
,	O
&	O
name	pointer
)	O
)	O
{	O
free	function
(	O
name	pointer
)	O
;	O
}	O
rec_skip_blanks	function
(	O
&	O
p	pointer
)	O
;	O
result	pointer
=	O
strdup	function
(	O
p	pointer
)	O
;	O
}	O
return	O
result	pointer
;	O
}	O
rec_type_t	pointer
rec_type_new	function
(	O
const	O
char	O
*	O
str	pointer
)	O
{	O
rec_type_t	pointer
new	pointer
;	O
const	O
char	O
*	O
p	pointer
;	O
char	O
*	O
type_kind_str	pointer
=	O
NULL	O
;	O
p	pointer
=	O
str	pointer
;	O
new	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
struct	O
rec_type_s	struct
)	O
)	O
;	O
if	O
(	O
!	O
new	pointer
)	O
{	O
goto	O
exit	function
;	O
}	O
new	pointer
->	O
name	pointer
=	O
NULL	O
;	O
new	pointer
->	O
size	pointer
=	O
0	int
;	O
rec_skip_blanks	function
(	O
&	O
p	pointer
)	O
;	O
if	O
(	O
!	O
rec_parse_regexp	function
(	O
&	O
p	pointer
,	O
"^"	pointer
REC_TYPE_CLASS_RE	O
,	O
&	O
type_kind_str	pointer
)	O
)	O
{	O
free	function
(	O
new	pointer
)	O
;	O
new	pointer
=	O
NULL	O
;	O
goto	O
exit	function
;	O
}	O
new	pointer
->	O
kind	enum
=	O
rec_type_parse_type_kind	function
(	O
type_kind_str	pointer
)	O
;	O
switch	O
(	O
new	pointer
->	O
kind	enum
)	O
{	O
case	O
REC_TYPE_SIZE	int
:	O
{	O
p	pointer
=	O
rec_type_parse_size	function
(	O
p	pointer
,	O
new	pointer
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
free	function
(	O
new	pointer
)	O
;	O
new	pointer
=	O
NULL	O
;	O
}	O
break	O
;	O
}	O
case	O
REC_TYPE_ENUM	int
:	O
{	O
p	pointer
=	O
rec_type_parse_enum	function
(	O
p	pointer
,	O
new	pointer
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
free	function
(	O
new	pointer
)	O
;	O
new	pointer
=	O
NULL	O
;	O
}	O
break	O
;	O
}	O
case	O
REC_TYPE_REGEXP	int
:	O
{	O
p	pointer
=	O
rec_type_parse_regexp_type	function
(	O
p	pointer
,	O
new	pointer
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
free	function
(	O
new	pointer
)	O
;	O
new	pointer
=	O
NULL	O
;	O
}	O
break	O
;	O
}	O
case	O
REC_TYPE_RANGE	int
:	O
{	O
p	pointer
=	O
rec_type_parse_range	function
(	O
p	pointer
,	O
new	pointer
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
free	function
(	O
new	pointer
)	O
;	O
new	pointer
=	O
NULL	O
;	O
}	O
break	O
;	O
}	O
case	O
REC_TYPE_REC	int
:	O
{	O
p	pointer
=	O
rec_type_parse_rec	function
(	O
p	pointer
,	O
new	pointer
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
free	function
(	O
new	pointer
)	O
;	O
new	pointer
=	O
NULL	O
;	O
}	O
break	O
;	O
}	O
case	O
REC_TYPE_INT	int
:	O
case	O
REC_TYPE_BOOL	int
:	O
case	O
REC_TYPE_REAL	int
:	O
case	O
REC_TYPE_LINE	int
:	O
case	O
REC_TYPE_FIELD	int
:	O
case	O
REC_TYPE_DATE	int
:	O
case	O
REC_TYPE_EMAIL	int
:	O
case	O
REC_TYPE_UUID	int
:	O
{	O
break	O
;	O
}	O
case	O
REC_TYPE_NONE	int
:	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"internal error: rec-types: got REC_TYPE_NONE from rec_type_parse_type_kind() in rec_type_new().\n"	pointer
)	O
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
new	pointer
)	O
{	O
while	O
(	O
*	O
p	pointer
!=	O
'\0'	O
)	O
{	O
if	O
(	O
!	O
rec_blank_p	function
(	O
*	O
p	pointer
)	O
)	O
{	O
rec_type_destroy	function
(	O
new	pointer
)	O
;	O
new	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
p	pointer
++	O
;	O
}	O
}	O
exit	function
:	O
free	function
(	O
type_kind_str	pointer
)	O
;	O
return	O
new	pointer
;	O
}	O
enum	O
rec_type_kind_e	enum
rec_type_kind	function
(	O
rec_type_t	pointer
type	enum
)	O
{	O
return	O
type	enum
->	O
kind	enum
;	O
}	O
char	O
*	O
rec_type_kind_str	function
(	O
rec_type_t	pointer
type	enum
)	O
{	O
char	O
*	O
res	pointer
;	O
switch	O
(	O
type	enum
->	O
kind	enum
)	O
{	O
case	O
REC_TYPE_NONE	int
:	O
{	O
res	pointer
=	O
""	pointer
;	O
break	O
;	O
}	O
case	O
REC_TYPE_INT	int
:	O
{	O
res	pointer
=	O
REC_TYPE_INT_NAME	pointer
;	O
break	O
;	O
}	O
case	O
REC_TYPE_BOOL	int
:	O
{	O
res	pointer
=	O
REC_TYPE_BOOL_NAME	pointer
;	O
break	O
;	O
}	O
case	O
REC_TYPE_RANGE	int
:	O
{	O
res	pointer
=	O
REC_TYPE_RANGE_NAME	pointer
;	O
break	O
;	O
}	O
case	O
REC_TYPE_REAL	int
:	O
{	O
res	pointer
=	O
REC_TYPE_REAL_NAME	pointer
;	O
break	O
;	O
}	O
case	O
REC_TYPE_SIZE	int
:	O
{	O
res	pointer
=	O
REC_TYPE_SIZE_NAME	pointer
;	O
break	O
;	O
}	O
case	O
REC_TYPE_LINE	int
:	O
{	O
res	pointer
=	O
REC_TYPE_LINE_NAME	pointer
;	O
break	O
;	O
}	O
case	O
REC_TYPE_REGEXP	int
:	O
{	O
res	pointer
=	O
REC_TYPE_REGEXP_NAME	pointer
;	O
break	O
;	O
}	O
case	O
REC_TYPE_DATE	int
:	O
{	O
res	pointer
=	O
REC_TYPE_DATE_NAME	pointer
;	O
break	O
;	O
}	O
case	O
REC_TYPE_EMAIL	int
:	O
{	O
res	pointer
=	O
REC_TYPE_EMAIL_NAME	pointer
;	O
break	O
;	O
}	O
case	O
REC_TYPE_ENUM	int
:	O
{	O
res	pointer
=	O
REC_TYPE_ENUM_NAME	pointer
;	O
break	O
;	O
}	O
case	O
REC_TYPE_FIELD	int
:	O
{	O
res	pointer
=	O
REC_TYPE_FIELD_NAME	pointer
;	O
break	O
;	O
}	O
case	O
REC_TYPE_REC	int
:	O
{	O
res	pointer
=	O
REC_TYPE_REC_NAME	pointer
;	O
break	O
;	O
}	O
case	O
REC_TYPE_UUID	int
:	O
{	O
res	pointer
=	O
REC_TYPE_UUID_NAME	pointer
;	O
break	O
;	O
}	O
default	O
:	O
{	O
res	pointer
=	O
REC_TYPE_NONE	int
;	O
break	O
;	O
}	O
}	O
return	O
res	pointer
;	O
}	O
bool	bool
rec_type_check	function
(	O
rec_type_t	pointer
type	enum
,	O
const	O
char	O
*	O
str	pointer
,	O
char	O
*	O
*	O
error_str	pointer
)	O
{	O
bool	bool
res	pointer
;	O
rec_buf_t	pointer
errors	pointer
;	O
char	O
*	O
err_str	pointer
;	O
size_t	long
errors_size	long
;	O
errors	pointer
=	O
rec_buf_new	function
(	O
&	O
err_str	pointer
,	O
&	O
errors_size	long
)	O
;	O
res	pointer
=	O
false	int
;	O
switch	O
(	O
type	enum
->	O
kind	enum
)	O
{	O
case	O
REC_TYPE_NONE	int
:	O
{	O
res	pointer
=	O
true	int
;	O
break	O
;	O
}	O
case	O
REC_TYPE_INT	int
:	O
{	O
res	pointer
=	O
rec_type_check_int	function
(	O
type	enum
,	O
str	pointer
,	O
errors	pointer
)	O
;	O
break	O
;	O
}	O
case	O
REC_TYPE_BOOL	int
:	O
{	O
res	pointer
=	O
rec_type_check_bool	function
(	O
type	enum
,	O
str	pointer
,	O
errors	pointer
)	O
;	O
break	O
;	O
}	O
case	O
REC_TYPE_RANGE	int
:	O
{	O
res	pointer
=	O
rec_type_check_range	function
(	O
type	enum
,	O
str	pointer
,	O
errors	pointer
)	O
;	O
break	O
;	O
}	O
case	O
REC_TYPE_REAL	int
:	O
{	O
res	pointer
=	O
rec_type_check_real	function
(	O
type	enum
,	O
str	pointer
,	O
errors	pointer
)	O
;	O
break	O
;	O
}	O
case	O
REC_TYPE_SIZE	int
:	O
{	O
res	pointer
=	O
rec_type_check_size	function
(	O
type	enum
,	O
str	pointer
,	O
errors	pointer
)	O
;	O
break	O
;	O
}	O
case	O
REC_TYPE_LINE	int
:	O
{	O
res	pointer
=	O
rec_type_check_line	function
(	O
type	enum
,	O
str	pointer
,	O
errors	pointer
)	O
;	O
break	O
;	O
}	O
case	O
REC_TYPE_REGEXP	int
:	O
{	O
res	pointer
=	O
rec_type_check_regexp	function
(	O
type	enum
,	O
str	pointer
,	O
errors	pointer
)	O
;	O
break	O
;	O
}	O
case	O
REC_TYPE_DATE	int
:	O
{	O
res	pointer
=	O
rec_type_check_date	function
(	O
type	enum
,	O
str	pointer
,	O
errors	pointer
)	O
;	O
break	O
;	O
}	O
case	O
REC_TYPE_EMAIL	int
:	O
{	O
res	pointer
=	O
rec_type_check_email	function
(	O
type	enum
,	O
str	pointer
,	O
errors	pointer
)	O
;	O
break	O
;	O
}	O
case	O
REC_TYPE_ENUM	int
:	O
{	O
res	pointer
=	O
rec_type_check_enum	function
(	O
type	enum
,	O
str	pointer
,	O
errors	pointer
)	O
;	O
break	O
;	O
}	O
case	O
REC_TYPE_FIELD	int
:	O
{	O
res	pointer
=	O
rec_type_check_field	function
(	O
type	enum
,	O
str	pointer
,	O
errors	pointer
)	O
;	O
break	O
;	O
}	O
case	O
REC_TYPE_REC	int
:	O
{	O
res	pointer
=	O
rec_type_check_rec	function
(	O
type	enum
,	O
str	pointer
,	O
errors	pointer
)	O
;	O
break	O
;	O
}	O
case	O
REC_TYPE_UUID	int
:	O
{	O
res	pointer
=	O
rec_type_check_uuid	function
(	O
type	enum
,	O
str	pointer
,	O
errors	pointer
)	O
;	O
break	O
;	O
}	O
}	O
rec_buf_close	function
(	O
errors	pointer
)	O
;	O
if	O
(	O
error_str	pointer
)	O
{	O
*	O
error_str	pointer
=	O
err_str	pointer
;	O
}	O
else	O
{	O
free	function
(	O
err_str	pointer
)	O
;	O
}	O
return	O
res	pointer
;	O
}	O
void	O
rec_type_destroy	function
(	O
rec_type_t	pointer
type	enum
)	O
{	O
int	O
i	long
;	O
if	O
(	O
type	enum
)	O
{	O
if	O
(	O
type	enum
->	O
kind	enum
==	O
REC_TYPE_ENUM	int
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
type	enum
->	O
size	pointer
;	O
i	long
++	O
)	O
{	O
free	function
(	O
type	enum
->	O
data	pointer
.	O
names	pointer
[	O
i	long
]	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
type	enum
->	O
kind	enum
==	O
REC_TYPE_REGEXP	int
)	O
{	O
regfree	O
(	O
&	O
type	enum
->	O
data	pointer
.	O
regexp	pointer
)	O
;	O
}	O
free	function
(	O
type	enum
->	O
name	pointer
)	O
;	O
free	function
(	O
type	enum
)	O
;	O
}	O
}	O
rec_type_reg_t	pointer
rec_type_reg_new	function
(	O
void	O
)	O
{	O
rec_type_reg_t	pointer
new	pointer
;	O
new	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
struct	O
rec_type_reg_s	struct
)	O
)	O
;	O
if	O
(	O
new	pointer
)	O
{	O
new	pointer
->	O
num_types	long
=	O
0	int
;	O
new	pointer
->	O
types	pointer
=	O
NULL	O
;	O
}	O
return	O
new	pointer
;	O
}	O
void	O
rec_type_reg_destroy	function
(	O
rec_type_reg_t	pointer
reg	pointer
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
reg	pointer
->	O
num_types	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
reg	pointer
->	O
types	pointer
[	O
i	long
]	O
.	O
type	enum
)	O
{	O
rec_type_destroy	function
(	O
reg	pointer
->	O
types	pointer
[	O
i	long
]	O
.	O
type	enum
)	O
;	O
}	O
free	function
(	O
reg	pointer
->	O
types	pointer
[	O
i	long
]	O
.	O
type_name	pointer
)	O
;	O
free	function
(	O
reg	pointer
->	O
types	pointer
[	O
i	long
]	O
.	O
to_type	pointer
)	O
;	O
}	O
free	function
(	O
reg	pointer
->	O
types	pointer
)	O
;	O
free	function
(	O
reg	pointer
)	O
;	O
}	O
void	O
rec_type_reg_add	function
(	O
rec_type_reg_t	pointer
reg	pointer
,	O
rec_type_t	pointer
type	enum
)	O
{	O
size_t	long
i	long
;	O
const	O
char	O
*	O
type_name	pointer
=	O
NULL	O
;	O
type_name	pointer
=	O
rec_type_name	function
(	O
type	enum
)	O
;	O
if	O
(	O
!	O
type_name	pointer
)	O
{	O
return	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
reg	pointer
->	O
num_types	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
reg	pointer
->	O
types	pointer
[	O
i	long
]	O
.	O
type_name	pointer
,	O
type_name	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
reg	pointer
->	O
types	pointer
[	O
i	long
]	O
.	O
type	enum
)	O
{	O
rec_type_destroy	function
(	O
reg	pointer
->	O
types	pointer
[	O
i	long
]	O
.	O
type	enum
)	O
;	O
}	O
free	function
(	O
reg	pointer
->	O
types	pointer
[	O
i	long
]	O
.	O
type_name	pointer
)	O
;	O
free	function
(	O
reg	pointer
->	O
types	pointer
[	O
i	long
]	O
.	O
to_type	pointer
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
i	long
==	O
reg	pointer
->	O
num_types	long
)	O
{	O
reg	pointer
->	O
types	pointer
=	O
realloc	function
(	O
reg	pointer
->	O
types	pointer
,	O
(	O
(	O
i	long
/	O
REC_TYPE_REG_ALLOC_TYPES	int
)	O
+	O
1	int
)	O
*	O
(	O
sizeof	O
(	O
struct	O
rec_type_reg_entry_s	struct
*	O
)	O
*	O
REC_TYPE_REG_ALLOC_TYPES	int
)	O
)	O
;	O
reg	pointer
->	O
num_types	long
++	O
;	O
}	O
reg	pointer
->	O
types	pointer
[	O
i	long
]	O
.	O
type_name	pointer
=	O
strdup	function
(	O
rec_type_name	function
(	O
type	enum
)	O
)	O
;	O
reg	pointer
->	O
types	pointer
[	O
i	long
]	O
.	O
type	enum
=	O
type	enum
;	O
reg	pointer
->	O
types	pointer
[	O
i	long
]	O
.	O
to_type	pointer
=	O
NULL	O
;	O
reg	pointer
->	O
types	pointer
[	O
i	long
]	O
.	O
visited_p	bool
=	O
false	int
;	O
}	O
void	O
rec_type_reg_add_synonym	function
(	O
rec_type_reg_t	pointer
reg	pointer
,	O
const	O
char	O
*	O
type_name	pointer
,	O
const	O
char	O
*	O
to_type	pointer
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
reg	pointer
->	O
num_types	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
reg	pointer
->	O
types	pointer
[	O
i	long
]	O
.	O
type_name	pointer
,	O
type_name	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
reg	pointer
->	O
types	pointer
[	O
i	long
]	O
.	O
type	enum
)	O
{	O
rec_type_destroy	function
(	O
reg	pointer
->	O
types	pointer
[	O
i	long
]	O
.	O
type	enum
)	O
;	O
}	O
free	function
(	O
reg	pointer
->	O
types	pointer
[	O
i	long
]	O
.	O
type_name	pointer
)	O
;	O
free	function
(	O
reg	pointer
->	O
types	pointer
[	O
i	long
]	O
.	O
to_type	pointer
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
i	long
==	O
reg	pointer
->	O
num_types	long
)	O
{	O
reg	pointer
->	O
types	pointer
=	O
realloc	function
(	O
reg	pointer
->	O
types	pointer
,	O
(	O
(	O
i	long
/	O
REC_TYPE_REG_ALLOC_TYPES	int
)	O
+	O
1	int
)	O
*	O
(	O
sizeof	O
(	O
struct	O
rec_type_reg_entry_s	struct
*	O
)	O
*	O
REC_TYPE_REG_ALLOC_TYPES	int
)	O
)	O
;	O
reg	pointer
->	O
num_types	long
++	O
;	O
}	O
reg	pointer
->	O
types	pointer
[	O
i	long
]	O
.	O
type_name	pointer
=	O
strdup	function
(	O
type_name	pointer
)	O
;	O
reg	pointer
->	O
types	pointer
[	O
i	long
]	O
.	O
to_type	pointer
=	O
strdup	function
(	O
to_type	pointer
)	O
;	O
reg	pointer
->	O
types	pointer
[	O
i	long
]	O
.	O
type	enum
=	O
NULL	O
;	O
reg	pointer
->	O
types	pointer
[	O
i	long
]	O
.	O
visited_p	bool
=	O
false	int
;	O
}	O
rec_type_t	pointer
rec_type_reg_get	function
(	O
rec_type_reg_t	pointer
reg	pointer
,	O
const	O
char	O
*	O
type_name	pointer
)	O
{	O
size_t	long
i	long
;	O
rec_type_t	pointer
type	enum
=	O
NULL	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
reg	pointer
->	O
num_types	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
reg	pointer
->	O
types	pointer
[	O
i	long
]	O
.	O
type_name	pointer
,	O
type_name	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
reg	pointer
->	O
types	pointer
[	O
i	long
]	O
.	O
type	enum
)	O
{	O
type	enum
=	O
reg	pointer
->	O
types	pointer
[	O
i	long
]	O
.	O
type	enum
;	O
break	O
;	O
}	O
else	O
{	O
if	O
(	O
reg	pointer
->	O
types	pointer
[	O
i	long
]	O
.	O
visited_p	bool
)	O
{	O
break	O
;	O
}	O
reg	pointer
->	O
types	pointer
[	O
i	long
]	O
.	O
visited_p	bool
=	O
true	int
;	O
type	enum
=	O
rec_type_reg_get	function
(	O
reg	pointer
,	O
reg	pointer
->	O
types	pointer
[	O
i	long
]	O
.	O
to_type	pointer
)	O
;	O
}	O
}	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
reg	pointer
->	O
num_types	long
;	O
i	long
++	O
)	O
{	O
reg	pointer
->	O
types	pointer
[	O
i	long
]	O
.	O
visited_p	bool
=	O
false	int
;	O
}	O
return	O
type	enum
;	O
}	O
const	O
char	O
*	O
rec_type_name	function
(	O
rec_type_t	pointer
type	enum
)	O
{	O
return	O
type	enum
->	O
name	pointer
;	O
}	O
void	O
rec_type_set_name	function
(	O
rec_type_t	pointer
type	enum
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
type	enum
->	O
name	pointer
=	O
strdup	function
(	O
name	pointer
)	O
;	O
}	O
bool	bool
rec_type_equal_p	function
(	O
rec_type_t	pointer
type1	pointer
,	O
rec_type_t	pointer
type2	int
)	O
{	O
bool	bool
ret	bool
;	O
size_t	long
i	long
;	O
ret	bool
=	O
true	int
;	O
if	O
(	O
type1	pointer
->	O
kind	enum
!=	O
type2	int
->	O
kind	enum
)	O
{	O
ret	bool
=	O
false	int
;	O
}	O
else	O
{	O
if	O
(	O
type1	pointer
->	O
kind	enum
==	O
REC_TYPE_SIZE	int
)	O
{	O
ret	bool
=	O
(	O
type1	pointer
->	O
data	pointer
.	O
max_size	long
==	O
type2	int
->	O
data	pointer
.	O
max_size	long
)	O
;	O
}	O
else	O
if	O
(	O
type1	pointer
->	O
kind	enum
==	O
REC_TYPE_RANGE	int
)	O
{	O
ret	bool
=	O
(	O
(	O
type1	pointer
->	O
data	pointer
.	O
range	array
[	O
0	int
]	O
==	O
type2	int
->	O
data	pointer
.	O
range	array
[	O
0	int
]	O
)	O
&&	O
(	O
type1	pointer
->	O
data	pointer
.	O
range	array
[	O
1	int
]	O
==	O
type2	int
->	O
data	pointer
.	O
range	array
[	O
1	int
]	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
type1	pointer
->	O
kind	enum
==	O
REC_TYPE_ENUM	int
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
type1	pointer
->	O
size	pointer
;	O
i	long
++	O
)	O
{	O
ret	bool
=	O
(	O
(	O
i	long
<	O
type2	int
->	O
size	pointer
)	O
&&	O
(	O
strcmp	function
(	O
type1	pointer
->	O
data	pointer
.	O
names	pointer
[	O
i	long
]	O
,	O
type2	int
->	O
data	pointer
.	O
names	pointer
[	O
i	long
]	O
)	O
==	O
0	int
)	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
type1	pointer
->	O
kind	enum
==	O
REC_TYPE_REGEXP	int
)	O
{	O
ret	bool
=	O
false	int
;	O
}	O
}	O
return	O
ret	bool
;	O
}	O
int	O
rec_type_min	function
(	O
rec_type_t	pointer
type	enum
)	O
{	O
int	O
res	pointer
;	O
if	O
(	O
type	enum
->	O
kind	enum
!=	O
REC_TYPE_RANGE	int
)	O
{	O
res	pointer
=	O
-	O
1	int
;	O
}	O
else	O
{	O
res	pointer
=	O
type	enum
->	O
data	pointer
.	O
range	array
[	O
0	int
]	O
;	O
}	O
return	O
res	pointer
;	O
}	O
int	O
rec_type_max	function
(	O
rec_type_t	pointer
type	enum
)	O
{	O
int	O
res	pointer
;	O
if	O
(	O
type	enum
->	O
kind	enum
!=	O
REC_TYPE_RANGE	int
)	O
{	O
res	pointer
=	O
-	O
1	int
;	O
}	O
else	O
{	O
res	pointer
=	O
type	enum
->	O
data	pointer
.	O
range	array
[	O
1	int
]	O
;	O
}	O
return	O
res	pointer
;	O
}	O
const	O
char	O
*	O
rec_type_rec	function
(	O
rec_type_t	pointer
type	enum
)	O
{	O
const	O
char	O
*	O
res	pointer
=	O
NULL	O
;	O
if	O
(	O
type	enum
->	O
kind	enum
==	O
REC_TYPE_REC	int
)	O
{	O
res	pointer
=	O
type	enum
->	O
data	pointer
.	O
recname	pointer
;	O
}	O
return	O
res	pointer
;	O
}	O
int	O
rec_type_values_cmp	function
(	O
rec_type_t	pointer
type	enum
,	O
const	O
char	O
*	O
val1	pointer
,	O
const	O
char	O
*	O
val2	pointer
)	O
{	O
int	O
type_comparison	int
;	O
enum	O
rec_type_kind_e	enum
kind	enum
=	O
REC_TYPE_NONE	int
;	O
if	O
(	O
type	enum
)	O
{	O
kind	enum
=	O
type	enum
->	O
kind	enum
;	O
}	O
switch	O
(	O
kind	enum
)	O
{	O
case	O
REC_TYPE_INT	int
:	O
case	O
REC_TYPE_RANGE	int
:	O
{	O
int	O
int1	int
,	O
int2	int
=	O
0	int
;	O
if	O
(	O
!	O
rec_atoi	function
(	O
val1	pointer
,	O
&	O
int1	int
)	O
||	O
!	O
rec_atoi	function
(	O
val2	pointer
,	O
&	O
int2	int
)	O
)	O
{	O
goto	O
lexi	O
;	O
}	O
if	O
(	O
int1	int
<	O
int2	int
)	O
{	O
type_comparison	int
=	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
int1	int
>	O
int2	int
)	O
{	O
type_comparison	int
=	O
1	int
;	O
}	O
else	O
{	O
type_comparison	int
=	O
0	int
;	O
}	O
break	O
;	O
}	O
case	O
REC_TYPE_REAL	int
:	O
{	O
double	O
real1	double
,	O
real2	double
=	O
0	int
;	O
if	O
(	O
!	O
rec_atod	function
(	O
val1	pointer
,	O
&	O
real1	double
)	O
||	O
!	O
rec_atod	function
(	O
val2	pointer
,	O
&	O
real2	double
)	O
)	O
{	O
goto	O
lexi	O
;	O
}	O
if	O
(	O
real1	double
<	O
real2	double
)	O
{	O
type_comparison	int
=	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
real1	double
>	O
real2	double
)	O
{	O
type_comparison	int
=	O
1	int
;	O
}	O
else	O
{	O
type_comparison	int
=	O
0	int
;	O
}	O
break	O
;	O
}	O
case	O
REC_TYPE_BOOL	int
:	O
{	O
bool	bool
bool1	bool
,	O
bool2	bool
=	O
false	int
;	O
bool1	bool
=	O
rec_match	function
(	O
val1	pointer
,	O
REC_TYPE_ZBLANKS_RE	O
"("	pointer
REC_TYPE_BOOL_TRUE_VALUES_RE	pointer
")"	pointer
REC_TYPE_ZBLANKS_RE	O
)	O
;	O
bool2	bool
=	O
rec_match	function
(	O
val2	pointer
,	O
REC_TYPE_ZBLANKS_RE	O
"("	pointer
REC_TYPE_BOOL_TRUE_VALUES_RE	pointer
")"	pointer
REC_TYPE_ZBLANKS_RE	O
)	O
;	O
if	O
(	O
!	O
bool1	bool
&&	O
bool2	bool
)	O
{	O
type_comparison	int
=	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
bool1	bool
==	O
bool2	bool
)	O
{	O
type_comparison	int
=	O
0	int
;	O
}	O
else	O
{	O
type_comparison	int
=	O
1	int
;	O
}	O
break	O
;	O
}	O
case	O
REC_TYPE_DATE	int
:	O
{	O
struct	O
timespec	struct
op1	struct
;	O
struct	O
timespec	struct
op2	struct
;	O
struct	O
timespec	struct
diff	struct
;	O
if	O
(	O
parse_datetime	function
(	O
&	O
op1	struct
,	O
val1	pointer
,	O
NULL	O
)	O
&&	O
parse_datetime	function
(	O
&	O
op2	struct
,	O
val2	pointer
,	O
NULL	O
)	O
)	O
{	O
if	O
(	O
(	O
op1	struct
.	O
tv_sec	long
==	O
op2	struct
.	O
tv_sec	long
)	O
&&	O
(	O
op1	struct
.	O
tv_nsec	long
==	O
op2	struct
.	O
tv_nsec	long
)	O
)	O
{	O
type_comparison	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
rec_timespec_subtract	function
(	O
&	O
diff	struct
,	O
&	O
op1	struct
,	O
&	O
op2	struct
)	O
)	O
{	O
type_comparison	int
=	O
-	O
1	int
;	O
}	O
else	O
{	O
type_comparison	int
=	O
1	int
;	O
}	O
}	O
else	O
{	O
goto	O
lexi	O
;	O
}	O
break	O
;	O
}	O
default	O
:	O
{	O
lexi	O
:	O
type_comparison	int
=	O
strcmp	function
(	O
val1	pointer
,	O
val2	pointer
)	O
;	O
break	O
;	O
}	O
}	O
return	O
type_comparison	int
;	O
}	O
static	O
enum	O
rec_type_kind_e	enum
rec_type_parse_type_kind	function
(	O
char	O
*	O
str	pointer
)	O
{	O
enum	O
rec_type_kind_e	enum
res	pointer
;	O
res	pointer
=	O
REC_TYPE_NONE	int
;	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
REC_TYPE_INT_NAME	pointer
)	O
==	O
0	int
)	O
{	O
res	pointer
=	O
REC_TYPE_INT	int
;	O
}	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
REC_TYPE_BOOL_NAME	pointer
)	O
==	O
0	int
)	O
{	O
res	pointer
=	O
REC_TYPE_BOOL	int
;	O
}	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
REC_TYPE_RANGE_NAME	pointer
)	O
==	O
0	int
)	O
{	O
res	pointer
=	O
REC_TYPE_RANGE	int
;	O
}	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
REC_TYPE_REAL_NAME	pointer
)	O
==	O
0	int
)	O
{	O
res	pointer
=	O
REC_TYPE_REAL	int
;	O
}	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
REC_TYPE_SIZE_NAME	pointer
)	O
==	O
0	int
)	O
{	O
res	pointer
=	O
REC_TYPE_SIZE	int
;	O
}	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
REC_TYPE_LINE_NAME	pointer
)	O
==	O
0	int
)	O
{	O
res	pointer
=	O
REC_TYPE_LINE	int
;	O
}	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
REC_TYPE_REGEXP_NAME	pointer
)	O
==	O
0	int
)	O
{	O
res	pointer
=	O
REC_TYPE_REGEXP	int
;	O
}	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
REC_TYPE_DATE_NAME	pointer
)	O
==	O
0	int
)	O
{	O
res	pointer
=	O
REC_TYPE_DATE	int
;	O
}	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
REC_TYPE_EMAIL_NAME	pointer
)	O
==	O
0	int
)	O
{	O
res	pointer
=	O
REC_TYPE_EMAIL	int
;	O
}	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
REC_TYPE_ENUM_NAME	pointer
)	O
==	O
0	int
)	O
{	O
res	pointer
=	O
REC_TYPE_ENUM	int
;	O
}	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
REC_TYPE_FIELD_NAME	pointer
)	O
==	O
0	int
)	O
{	O
res	pointer
=	O
REC_TYPE_FIELD	int
;	O
}	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
REC_TYPE_REC_NAME	pointer
)	O
==	O
0	int
)	O
{	O
res	pointer
=	O
REC_TYPE_REC	int
;	O
}	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
REC_TYPE_UUID_NAME	pointer
)	O
==	O
0	int
)	O
{	O
res	pointer
=	O
REC_TYPE_UUID	int
;	O
}	O
return	O
res	pointer
;	O
}	O
static	O
bool	bool
rec_type_check_int	function
(	O
rec_type_t	pointer
type	enum
,	O
const	O
char	O
*	O
str	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
{	O
bool	bool
ret	bool
;	O
ret	bool
=	O
rec_match	function
(	O
str	pointer
,	O
REC_TYPE_INT_VALUE_RE	O
)	O
;	O
if	O
(	O
!	O
ret	bool
&&	O
errors	pointer
)	O
{	O
rec_buf_puts	function
(	O
_	O
(	O
"invalid integer."	pointer
)	O
,	O
errors	pointer
)	O
;	O
}	O
return	O
ret	bool
;	O
}	O
static	O
bool	bool
rec_type_check_rec	function
(	O
rec_type_t	pointer
type	enum
,	O
const	O
char	O
*	O
str	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
{	O
return	O
true	int
;	O
}	O
static	O
bool	bool
rec_type_check_field	function
(	O
rec_type_t	pointer
type	enum
,	O
const	O
char	O
*	O
str	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
{	O
bool	bool
ret	bool
;	O
ret	bool
=	O
rec_match	function
(	O
str	pointer
,	O
REC_TYPE_FIELD_VALUE_RE	O
)	O
;	O
if	O
(	O
!	O
ret	bool
&&	O
errors	pointer
)	O
{	O
rec_buf_puts	function
(	O
_	O
(	O
"invalid 'field' value."	pointer
)	O
,	O
errors	pointer
)	O
;	O
}	O
return	O
ret	bool
;	O
}	O
static	O
bool	bool
rec_type_check_uuid	function
(	O
rec_type_t	pointer
type	enum
,	O
const	O
char	O
*	O
str	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
{	O
int	O
ret	bool
;	O
uuid_t	array
uu	array
;	O
ret	bool
=	O
uuid_parse	function
(	O
str	pointer
,	O
uu	array
)	O
;	O
if	O
(	O
(	O
ret	bool
==	O
-	O
1	int
)	O
&&	O
errors	pointer
)	O
{	O
rec_buf_puts	function
(	O
_	O
(	O
"invalid 'uuid' value."	pointer
)	O
,	O
errors	pointer
)	O
;	O
}	O
return	O
(	O
ret	bool
==	O
0	int
)	O
;	O
}	O
static	O
bool	bool
rec_type_check_bool	function
(	O
rec_type_t	pointer
type	enum
,	O
const	O
char	O
*	O
str	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
{	O
bool	bool
ret	bool
;	O
ret	bool
=	O
rec_match	function
(	O
str	pointer
,	O
REC_TYPE_BOOL_VALUE_RE	O
)	O
;	O
if	O
(	O
!	O
ret	bool
&&	O
errors	pointer
)	O
{	O
rec_buf_puts	function
(	O
_	O
(	O
"invalid 'bool' value."	pointer
)	O
,	O
errors	pointer
)	O
;	O
}	O
return	O
ret	bool
;	O
}	O
static	O
bool	bool
rec_type_check_range	function
(	O
rec_type_t	pointer
type	enum
,	O
const	O
char	O
*	O
str	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
{	O
bool	bool
ret	bool
;	O
const	O
char	O
*	O
p	pointer
;	O
int	O
num	pointer
;	O
char	O
*	O
tmp	pointer
;	O
p	pointer
=	O
str	pointer
;	O
rec_skip_blanks	function
(	O
&	O
p	pointer
)	O
;	O
if	O
(	O
!	O
rec_parse_int	function
(	O
&	O
p	pointer
,	O
&	O
num	pointer
)	O
)	O
{	O
if	O
(	O
errors	pointer
)	O
{	O
rec_buf_puts	function
(	O
_	O
(	O
"invalid 'range' value."	pointer
)	O
,	O
errors	pointer
)	O
;	O
}	O
return	O
false	int
;	O
}	O
ret	bool
=	O
(	O
(	O
num	pointer
>=	O
type	enum
->	O
data	pointer
.	O
range	array
[	O
0	int
]	O
)	O
&&	O
(	O
num	pointer
<=	O
type	enum
->	O
data	pointer
.	O
range	array
[	O
1	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
ret	bool
&&	O
errors	pointer
)	O
{	O
if	O
(	O
asprintf	function
(	O
&	O
tmp	pointer
,	O
_	O
(	O
"expected an integer between %d and %d."	pointer
)	O
,	O
type	enum
->	O
data	pointer
.	O
range	array
[	O
0	int
]	O
,	O
type	enum
->	O
data	pointer
.	O
range	array
[	O
1	int
]	O
)	O
!=	O
-	O
1	int
)	O
{	O
rec_buf_puts	function
(	O
tmp	pointer
,	O
errors	pointer
)	O
;	O
free	function
(	O
tmp	pointer
)	O
;	O
}	O
}	O
return	O
ret	bool
;	O
}	O
static	O
bool	bool
rec_type_check_real	function
(	O
rec_type_t	pointer
type	enum
,	O
const	O
char	O
*	O
str	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
{	O
bool	bool
ret	bool
;	O
ret	bool
=	O
rec_match	function
(	O
str	pointer
,	O
REC_TYPE_REAL_VALUE_RE	O
)	O
;	O
if	O
(	O
!	O
ret	bool
&&	O
errors	pointer
)	O
{	O
rec_buf_puts	function
(	O
_	O
(	O
"invalid 'real' value."	pointer
)	O
,	O
errors	pointer
)	O
;	O
}	O
return	O
ret	bool
;	O
}	O
static	O
bool	bool
rec_type_check_size	function
(	O
rec_type_t	pointer
type	enum
,	O
const	O
char	O
*	O
str	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
{	O
bool	bool
ret	bool
;	O
char	O
*	O
tmp	pointer
;	O
ret	bool
=	O
(	O
strlen	function
(	O
str	pointer
)	O
<=	O
type	enum
->	O
data	pointer
.	O
max_size	long
)	O
;	O
if	O
(	O
!	O
ret	bool
&&	O
errors	pointer
)	O
{	O
if	O
(	O
asprintf	function
(	O
&	O
tmp	pointer
,	O
_	O
(	O
"value too large.  Expected a size <= %zu."	pointer
)	O
,	O
type	enum
->	O
data	pointer
.	O
max_size	long
)	O
!=	O
-	O
1	int
)	O
{	O
rec_buf_puts	function
(	O
tmp	pointer
,	O
errors	pointer
)	O
;	O
free	function
(	O
tmp	pointer
)	O
;	O
}	O
}	O
return	O
(	O
strlen	function
(	O
str	pointer
)	O
<=	O
type	enum
->	O
data	pointer
.	O
max_size	long
)	O
;	O
}	O
static	O
bool	bool
rec_type_check_line	function
(	O
rec_type_t	pointer
type	enum
,	O
const	O
char	O
*	O
str	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
{	O
bool	bool
ret	bool
;	O
ret	bool
=	O
rec_match	function
(	O
str	pointer
,	O
REC_TYPE_LINE_VALUE_RE	pointer
)	O
;	O
if	O
(	O
!	O
ret	bool
&&	O
errors	pointer
)	O
{	O
rec_buf_puts	function
(	O
_	O
(	O
"invalid 'line' value."	pointer
)	O
,	O
errors	pointer
)	O
;	O
}	O
return	O
ret	bool
;	O
}	O
static	O
bool	bool
rec_type_check_regexp	function
(	O
rec_type_t	pointer
type	enum
,	O
const	O
char	O
*	O
str	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
{	O
bool	bool
ret	bool
;	O
ret	bool
=	O
(	O
regexec	O
(	O
&	O
type	enum
->	O
data	pointer
.	O
regexp	pointer
,	O
str	pointer
,	O
0	int
,	O
NULL	O
,	O
0	int
)	O
==	O
0	int
)	O
;	O
if	O
(	O
!	O
ret	bool
&&	O
errors	pointer
)	O
{	O
rec_buf_puts	function
(	O
_	O
(	O
"value does not match the regexp."	pointer
)	O
,	O
errors	pointer
)	O
;	O
}	O
return	O
ret	bool
;	O
}	O
static	O
bool	bool
rec_type_check_date	function
(	O
rec_type_t	pointer
type	enum
,	O
const	O
char	O
*	O
str	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
{	O
bool	bool
ret	bool
;	O
struct	O
timespec	struct
tm	struct
;	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
""	pointer
)	O
==	O
0	int
)	O
{	O
return	O
false	int
;	O
}	O
ret	bool
=	O
parse_datetime	function
(	O
&	O
tm	struct
,	O
str	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
ret	bool
&&	O
errors	pointer
)	O
{	O
rec_buf_puts	function
(	O
_	O
(	O
"invalid date."	pointer
)	O
,	O
errors	pointer
)	O
;	O
}	O
return	O
ret	bool
;	O
}	O
static	O
bool	bool
rec_type_check_email	function
(	O
rec_type_t	pointer
type	enum
,	O
const	O
char	O
*	O
str	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
{	O
bool	bool
ret	bool
;	O
ret	bool
=	O
rec_match	function
(	O
str	pointer
,	O
REC_TYPE_EMAIL_VALUE_RE	O
)	O
;	O
if	O
(	O
!	O
ret	bool
&&	O
errors	pointer
)	O
{	O
rec_buf_puts	function
(	O
_	O
(	O
"invalid email."	pointer
)	O
,	O
errors	pointer
)	O
;	O
}	O
return	O
ret	bool
;	O
}	O
static	O
bool	bool
rec_type_check_enum	function
(	O
rec_type_t	pointer
type	enum
,	O
const	O
char	O
*	O
str	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
{	O
size_t	long
i	long
;	O
const	O
char	O
*	O
p	pointer
,	O
*	O
b	pointer
;	O
char	O
name	pointer
[	O
100	int
]	O
;	O
if	O
(	O
rec_match	function
(	O
str	pointer
,	O
REC_TYPE_ENUM_VALUE_RE	O
)	O
)	O
{	O
p	pointer
=	O
str	pointer
;	O
while	O
(	O
p	pointer
&&	O
rec_blank_p	function
(	O
*	O
p	pointer
)	O
)	O
{	O
p	pointer
++	O
;	O
}	O
b	pointer
=	O
p	pointer
;	O
while	O
(	O
p	pointer
&&	O
(	O
rec_letter_p	function
(	O
*	O
p	pointer
)	O
||	O
rec_letter_p	function
(	O
*	O
p	pointer
)	O
||	O
rec_digit_p	function
(	O
*	O
p	pointer
)	O
||	O
(	O
*	O
p	pointer
==	O
'_'	O
)	O
||	O
(	O
*	O
p	pointer
==	O
'-'	O
)	O
)	O
)	O
{	O
name	pointer
[	O
p	pointer
-	O
b	pointer
]	O
=	O
*	O
p	pointer
;	O
p	pointer
++	O
;	O
}	O
name	pointer
[	O
p	pointer
-	O
b	pointer
]	O
=	O
'\0'	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
type	enum
->	O
size	pointer
;	O
i	long
++	O
)	O
if	O
(	O
strcmp	function
(	O
name	pointer
,	O
type	enum
->	O
data	pointer
.	O
names	pointer
[	O
i	long
]	O
)	O
==	O
0	int
)	O
return	O
true	int
;	O
}	O
if	O
(	O
errors	pointer
)	O
{	O
rec_buf_puts	function
(	O
_	O
(	O
"invalid enum value."	pointer
)	O
,	O
errors	pointer
)	O
;	O
}	O
return	O
false	int
;	O
}	O
static	O
const	O
char	O
*	O
rec_type_parse_size	function
(	O
const	O
char	O
*	O
str	pointer
,	O
rec_type_t	pointer
type	enum
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
int	O
size	pointer
;	O
p	pointer
=	O
str	pointer
;	O
rec_skip_blanks	function
(	O
&	O
p	pointer
)	O
;	O
if	O
(	O
rec_parse_int	function
(	O
&	O
p	pointer
,	O
&	O
size	pointer
)	O
&&	O
(	O
size	pointer
>=	O
0	int
)	O
)	O
{	O
type	enum
->	O
data	pointer
.	O
max_size	long
=	O
size	pointer
;	O
}	O
else	O
{	O
p	pointer
=	O
NULL	O
;	O
}	O
return	O
p	pointer
;	O
}	O
static	O
const	O
char	O
*	O
rec_type_parse_enum	function
(	O
const	O
char	O
*	O
str	pointer
,	O
rec_type_t	pointer
type	enum
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
size_t	long
i	long
;	O
p	pointer
=	O
str	pointer
;	O
type	enum
->	O
size	pointer
=	O
0	int
;	O
type	enum
->	O
data	pointer
.	O
names	pointer
=	O
NULL	O
;	O
while	O
(	O
*	O
p	pointer
)	O
{	O
if	O
(	O
(	O
type	enum
->	O
size	pointer
%	O
REC_ENUM_ALLOC_NAMES	int
)	O
==	O
0	int
)	O
type	enum
->	O
data	pointer
.	O
names	pointer
=	O
realloc	function
(	O
type	enum
->	O
data	pointer
.	O
names	pointer
,	O
(	O
(	O
type	enum
->	O
size	pointer
/	O
REC_ENUM_ALLOC_NAMES	int
)	O
+	O
1	int
)	O
*	O
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
REC_ENUM_ALLOC_NAMES	int
)	O
)	O
;	O
rec_skip_blanks	function
(	O
&	O
p	pointer
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'('	O
)	O
{	O
p	pointer
++	O
;	O
while	O
(	O
*	O
p	pointer
&&	O
(	O
*	O
p	pointer
!=	O
')'	O
)	O
&&	O
(	O
*	O
p	pointer
!=	O
'('	O
)	O
)	O
{	O
p	pointer
++	O
;	O
}	O
if	O
(	O
*	O
p	pointer
==	O
')'	O
)	O
{	O
p	pointer
++	O
;	O
}	O
else	O
{	O
p	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
*	O
p	pointer
)	O
{	O
if	O
(	O
!	O
rec_parse_regexp	function
(	O
&	O
p	pointer
,	O
"^"	pointer
REC_TYPE_ENUM_NAME_RE	pointer
,	O
&	O
(	O
type	enum
->	O
data	pointer
.	O
names	pointer
[	O
type	enum
->	O
size	pointer
++	O
]	O
)	O
)	O
)	O
{	O
p	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
type	enum
->	O
size	pointer
==	O
0	int
)	O
{	O
return	O
NULL	O
;	O
}	O
if	O
(	O
!	O
p	pointer
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
type	enum
->	O
size	pointer
;	O
i	long
++	O
)	O
{	O
free	function
(	O
type	enum
->	O
data	pointer
.	O
names	pointer
[	O
i	long
]	O
)	O
;	O
}	O
}	O
return	O
p	pointer
;	O
}	O
static	O
const	O
char	O
*	O
rec_type_parse_regexp_type	function
(	O
const	O
char	O
*	O
str	pointer
,	O
rec_type_t	pointer
type	enum
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
char	O
re	pointer
[	O
200	int
]	O
;	O
bool	bool
end_regexp	bool
;	O
size_t	long
i	long
;	O
char	O
delim_char	char
;	O
p	pointer
=	O
str	pointer
;	O
rec_skip_blanks	function
(	O
&	O
p	pointer
)	O
;	O
end_regexp	bool
=	O
false	int
;	O
delim_char	char
=	O
*	O
p	pointer
;	O
p	pointer
++	O
;	O
i	long
=	O
0	int
;	O
while	O
(	O
*	O
p	pointer
)	O
{	O
if	O
(	O
*	O
p	pointer
==	O
delim_char	char
)	O
{	O
if	O
(	O
*	O
(	O
p	pointer
+	O
1	int
)	O
==	O
delim_char	char
)	O
{	O
re	pointer
[	O
i	long
++	O
]	O
=	O
delim_char	char
;	O
p	pointer
++	O
;	O
}	O
else	O
{	O
p	pointer
++	O
;	O
end_regexp	bool
=	O
true	int
;	O
break	O
;	O
}	O
}	O
else	O
{	O
re	pointer
[	O
i	long
++	O
]	O
=	O
*	O
p	pointer
;	O
}	O
p	pointer
++	O
;	O
}	O
re	pointer
[	O
i	long
]	O
=	O
'\0'	O
;	O
if	O
(	O
!	O
end_regexp	bool
)	O
{	O
p	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
if	O
(	O
regcomp	O
(	O
&	O
type	enum
->	O
data	pointer
.	O
regexp	pointer
,	O
re	pointer
,	O
REG_EXTENDED	int
)	O
!=	O
0	int
)	O
{	O
p	pointer
=	O
NULL	O
;	O
}	O
}	O
return	O
p	pointer
;	O
}	O
static	O
const	O
char	O
*	O
rec_type_parse_rec	function
(	O
const	O
char	O
*	O
str	pointer
,	O
rec_type_t	pointer
type	enum
)	O
{	O
const	O
char	O
*	O
p	pointer
=	O
str	pointer
;	O
rec_skip_blanks	function
(	O
&	O
p	pointer
)	O
;	O
if	O
(	O
!	O
rec_parse_regexp	function
(	O
&	O
p	pointer
,	O
"^"	pointer
REC_RECORD_TYPE_RE	O
,	O
&	O
(	O
type	enum
->	O
data	pointer
.	O
recname	pointer
)	O
)	O
)	O
{	O
return	O
NULL	O
;	O
}	O
return	O
p	pointer
;	O
}	O
static	O
bool	bool
rec_type_parse_range_point	function
(	O
const	O
char	O
*	O
*	O
str	pointer
,	O
int	O
*	O
num	pointer
)	O
{	O
if	O
(	O
rec_match	function
(	O
*	O
str	pointer
,	O
"^MIN"	pointer
)	O
)	O
{	O
*	O
num	pointer
=	O
INT_MIN	O
;	O
*	O
str	pointer
+=	O
3	int
;	O
}	O
else	O
if	O
(	O
rec_match	function
(	O
*	O
str	pointer
,	O
"^MAX"	pointer
)	O
)	O
{	O
*	O
num	pointer
=	O
INT_MAX	O
;	O
*	O
str	pointer
+=	O
3	int
;	O
}	O
else	O
if	O
(	O
!	O
rec_parse_int	function
(	O
str	pointer
,	O
num	pointer
)	O
)	O
{	O
return	O
false	int
;	O
}	O
return	O
true	int
;	O
}	O
static	O
const	O
char	O
*	O
rec_type_parse_range	function
(	O
const	O
char	O
*	O
str	pointer
,	O
rec_type_t	pointer
type	enum
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
p	pointer
=	O
str	pointer
;	O
rec_skip_blanks	function
(	O
&	O
p	pointer
)	O
;	O
if	O
(	O
!	O
rec_type_parse_range_point	function
(	O
&	O
p	pointer
,	O
&	O
(	O
type	enum
->	O
data	pointer
.	O
range	array
[	O
0	int
]	O
)	O
)	O
)	O
{	O
return	O
NULL	O
;	O
}	O
rec_skip_blanks	function
(	O
&	O
p	pointer
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'\0'	O
)	O
{	O
type	enum
->	O
data	pointer
.	O
range	array
[	O
1	int
]	O
=	O
type	enum
->	O
data	pointer
.	O
range	array
[	O
0	int
]	O
;	O
type	enum
->	O
data	pointer
.	O
range	array
[	O
0	int
]	O
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
rec_type_parse_range_point	function
(	O
&	O
p	pointer
,	O
&	O
(	O
type	enum
->	O
data	pointer
.	O
range	array
[	O
1	int
]	O
)	O
)	O
)	O
{	O
return	O
NULL	O
;	O
}	O
}	O
return	O
p	pointer
;	O
}	O
