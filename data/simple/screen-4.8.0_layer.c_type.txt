extern	O
struct	O
display	struct
*	O
display	struct
,	O
*	O
displays	pointer
;	O
extern	O
struct	O
mline	struct
mline_blank	struct
,	O
mline_null	struct
;	O
extern	O
struct	O
mchar	struct
mchar_blank	struct
,	O
mchar_null	struct
;	O
extern	O
struct	O
layer	struct
*	O
flayer	pointer
;	O
extern	O
struct	O
LayFuncs	struct
WinLf	struct
;	O
extern	O
struct	O
LayFuncs	struct
BlankLf	struct
;	O
static	O
struct	O
mline	struct
*	O
mloff	function
__P	O
(	O
(	O
struct	O
mline	struct
*	O
,	O
int	O
)	O
)	O
;	O
static	O
struct	O
mline	struct
*	O
mloff	function
(	O
struct	O
mline	struct
*	O
ml	pointer
,	O
int	O
off	int
)	O
{	O
static	O
struct	O
mline	struct
mml	struct
;	O
if	O
(	O
ml	pointer
==	O
0	int
)	O
return	O
0	int
;	O
mml	struct
.	O
image	char
=	O
ml	pointer
->	O
image	char
+	O
off	int
;	O
mml	struct
.	O
attr	char
=	O
ml	pointer
->	O
attr	char
+	O
off	int
;	O
mml	struct
.	O
font	char
=	O
ml	pointer
->	O
font	char
+	O
off	int
;	O
mml	struct
.	O
fontx	char
=	O
ml	pointer
->	O
fontx	char
+	O
off	int
;	O
mml	struct
.	O
color	char
=	O
ml	pointer
->	O
color	char
+	O
off	int
;	O
return	O
&	O
mml	struct
;	O
}	O
void	O
LGotoPos	function
(	O
struct	O
layer	struct
*	O
l	pointer
,	O
int	O
x	int
,	O
int	O
y	int
)	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
struct	O
viewport	struct
*	O
vp	pointer
;	O
int	O
x2	int
,	O
y2	int
;	O
if	O
(	O
l	pointer
->	O
l_pause	struct
.	O
d	int
)	O
LayPauseUpdateRegion	function
(	O
l	pointer
,	O
x	int
,	O
x	int
,	O
y	int
,	O
y	int
)	O
;	O
FOR_EACH_UNPAUSED_CANVAS	O
(	O
l	pointer
,	O
{	O
display	struct
=	O
cv	pointer
->	O
c_display	pointer
;	O
if	O
(	O
D_blocked	O
)	O
continue	O
;	O
if	O
(	O
cv	pointer
!=	O
D_forecv	O
)	O
continue	O
;	O
x2	int
=	O
x	int
+	O
cv	pointer
->	O
c_xoff	int
;	O
y2	int
=	O
y	int
+	O
cv	pointer
->	O
c_yoff	int
;	O
debug2	O
(	O
"---LGotoPos %d %d\n"	pointer
,	O
x2	int
,	O
y2	int
)	O
;	O
if	O
(	O
x2	int
<	O
cv	pointer
->	O
c_xs	int
)	O
x2	int
=	O
cv	pointer
->	O
c_xs	int
;	O
if	O
(	O
y2	int
<	O
cv	pointer
->	O
c_ys	int
)	O
y2	int
=	O
cv	pointer
->	O
c_ys	int
;	O
if	O
(	O
x2	int
>	O
cv	pointer
->	O
c_xe	int
)	O
x2	int
=	O
cv	pointer
->	O
c_xe	int
;	O
if	O
(	O
y2	int
>	O
cv	pointer
->	O
c_ye	int
)	O
y2	int
=	O
cv	pointer
->	O
c_ye	int
;	O
for	O
(	O
vp	pointer
=	O
cv	pointer
->	O
c_vplist	pointer
;	O
vp	pointer
;	O
vp	pointer
=	O
vp	pointer
->	O
v_next	pointer
)	O
{	O
if	O
(	O
x2	int
<	O
vp	pointer
->	O
v_xs	int
||	O
x2	int
>	O
vp	pointer
->	O
v_xe	int
)	O
continue	O
;	O
if	O
(	O
y2	int
<	O
vp	pointer
->	O
v_ys	int
||	O
y2	int
>	O
vp	pointer
->	O
v_ye	int
)	O
continue	O
;	O
GotoPos	function
(	O
x2	int
,	O
y2	int
)	O
;	O
break	O
;	O
}	O
}	O
)	O
;	O
}	O
void	O
LScrollH	function
(	O
struct	O
layer	struct
*	O
l	pointer
,	O
int	O
n	int
,	O
int	O
y	int
,	O
int	O
xs	int
,	O
int	O
xe	int
,	O
int	O
bce	int
,	O
struct	O
mline	struct
*	O
ol	pointer
)	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
struct	O
viewport	struct
*	O
vp	pointer
;	O
int	O
y2	int
,	O
xs2	int
,	O
xe2	int
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
l	pointer
->	O
l_pause	struct
.	O
d	int
)	O
LayPauseUpdateRegion	function
(	O
l	pointer
,	O
xs	int
,	O
xe	int
,	O
y	int
,	O
y	int
)	O
;	O
FOR_EACH_UNPAUSED_CANVAS	O
(	O
l	pointer
,	O
for	O
(	O
vp	pointer
=	O
cv	pointer
->	O
c_vplist	pointer
;	O
vp	pointer
;	O
vp	pointer
=	O
vp	pointer
->	O
v_next	pointer
)	O
{	O
y2	int
=	O
y	int
+	O
vp	pointer
->	O
v_yoff	int
;	O
if	O
(	O
y2	int
<	O
vp	pointer
->	O
v_ys	int
||	O
y2	int
>	O
vp	pointer
->	O
v_ye	int
)	O
continue	O
;	O
xs2	int
=	O
xs	int
+	O
vp	pointer
->	O
v_xoff	int
;	O
xe2	int
=	O
xe	int
+	O
vp	pointer
->	O
v_xoff	int
;	O
if	O
(	O
xs2	int
<	O
vp	pointer
->	O
v_xs	int
)	O
xs2	int
=	O
vp	pointer
->	O
v_xs	int
;	O
if	O
(	O
xe2	int
>	O
vp	pointer
->	O
v_xe	int
)	O
xe2	int
=	O
vp	pointer
->	O
v_xe	int
;	O
if	O
(	O
xs2	int
>	O
xe2	int
)	O
continue	O
;	O
display	struct
=	O
cv	pointer
->	O
c_display	pointer
;	O
if	O
(	O
D_blocked	O
)	O
continue	O
;	O
ScrollH	function
(	O
y2	int
,	O
xs2	int
,	O
xe2	int
,	O
n	int
,	O
bce	int
,	O
ol	pointer
?	O
mloff	function
(	O
ol	pointer
,	O
-	O
vp	pointer
->	O
v_xoff	int
)	O
:	O
0	int
)	O
;	O
if	O
(	O
xe2	int
-	O
xs2	int
==	O
xe	int
-	O
xs	int
)	O
continue	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
{	O
xs2	int
=	O
xe2	int
+	O
1	int
-	O
n	int
;	O
xe2	int
=	O
xe	int
+	O
vp	pointer
->	O
v_xoff	int
-	O
n	int
;	O
}	O
else	O
{	O
xe2	int
=	O
xs2	int
-	O
1	int
-	O
n	int
;	O
xs2	int
=	O
xs	int
+	O
vp	pointer
->	O
v_xoff	int
-	O
n	int
;	O
}	O
if	O
(	O
xs2	int
<	O
vp	pointer
->	O
v_xs	int
)	O
xs2	int
=	O
vp	pointer
->	O
v_xs	int
;	O
if	O
(	O
xe2	int
>	O
vp	pointer
->	O
v_xe	int
)	O
xe2	int
=	O
vp	pointer
->	O
v_xe	int
;	O
if	O
(	O
xs2	int
<=	O
xe2	int
)	O
RefreshArea	function
(	O
xs2	int
,	O
y2	int
,	O
xe2	int
,	O
y2	int
,	O
1	int
)	O
;	O
}	O
)	O
;	O
}	O
void	O
LScrollV	function
(	O
struct	O
layer	struct
*	O
l	pointer
,	O
int	O
n	int
,	O
int	O
ys	int
,	O
int	O
ye	int
,	O
int	O
bce	int
)	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
struct	O
viewport	struct
*	O
vp	pointer
;	O
int	O
ys2	int
,	O
ye2	int
,	O
xs2	int
,	O
xe2	int
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
l	pointer
->	O
l_pause	struct
.	O
d	int
)	O
LayPauseUpdateRegion	function
(	O
l	pointer
,	O
0	int
,	O
l	pointer
->	O
l_width	int
-	O
1	int
,	O
ys	int
,	O
ye	int
)	O
;	O
FOR_EACH_UNPAUSED_CANVAS	O
(	O
l	pointer
,	O
for	O
(	O
vp	pointer
=	O
cv	pointer
->	O
c_vplist	pointer
;	O
vp	pointer
;	O
vp	pointer
=	O
vp	pointer
->	O
v_next	pointer
)	O
{	O
xs2	int
=	O
vp	pointer
->	O
v_xoff	int
;	O
xe2	int
=	O
l	pointer
->	O
l_width	int
-	O
1	int
+	O
vp	pointer
->	O
v_xoff	int
;	O
ys2	int
=	O
ys	int
+	O
vp	pointer
->	O
v_yoff	int
;	O
ye2	int
=	O
ye	int
+	O
vp	pointer
->	O
v_yoff	int
;	O
if	O
(	O
xs2	int
<	O
vp	pointer
->	O
v_xs	int
)	O
xs2	int
=	O
vp	pointer
->	O
v_xs	int
;	O
if	O
(	O
xe2	int
>	O
vp	pointer
->	O
v_xe	int
)	O
xe2	int
=	O
vp	pointer
->	O
v_xe	int
;	O
if	O
(	O
ys2	int
<	O
vp	pointer
->	O
v_ys	int
)	O
ys2	int
=	O
vp	pointer
->	O
v_ys	int
;	O
if	O
(	O
ye2	int
>	O
vp	pointer
->	O
v_ye	int
)	O
ye2	int
=	O
vp	pointer
->	O
v_ye	int
;	O
if	O
(	O
ys2	int
>	O
ye2	int
||	O
xs2	int
>	O
xe2	int
)	O
continue	O
;	O
display	struct
=	O
cv	pointer
->	O
c_display	pointer
;	O
if	O
(	O
D_blocked	O
)	O
continue	O
;	O
ScrollV	function
(	O
vp	pointer
->	O
v_xs	int
,	O
ys2	int
,	O
vp	pointer
->	O
v_xe	int
,	O
ye2	int
,	O
n	int
,	O
bce	int
)	O
;	O
debug2	O
(	O
"LScrollV: %d %d"	pointer
,	O
ys	int
,	O
ye	int
)	O
;	O
debug2	O
(	O
" -> %d %d\n"	pointer
,	O
ys2	int
,	O
ye2	int
)	O
;	O
if	O
(	O
ye2	int
-	O
ys2	int
==	O
ye	int
-	O
ys	int
)	O
continue	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
{	O
ys2	int
=	O
ye2	int
+	O
1	int
-	O
n	int
;	O
ye2	int
=	O
ye	int
+	O
vp	pointer
->	O
v_yoff	int
-	O
n	int
;	O
}	O
else	O
{	O
ye2	int
=	O
ys2	int
-	O
1	int
-	O
n	int
;	O
ys2	int
=	O
ys	int
+	O
vp	pointer
->	O
v_yoff	int
-	O
n	int
;	O
}	O
debug2	O
(	O
"LScrollV: - %d %d\n"	pointer
,	O
ys2	int
,	O
ye2	int
)	O
;	O
if	O
(	O
ys2	int
<	O
vp	pointer
->	O
v_ys	int
)	O
ys2	int
=	O
vp	pointer
->	O
v_ys	int
;	O
if	O
(	O
ye2	int
>	O
vp	pointer
->	O
v_ye	int
)	O
ye2	int
=	O
vp	pointer
->	O
v_ye	int
;	O
debug2	O
(	O
"LScrollV: - %d %d\n"	pointer
,	O
ys2	int
,	O
ye2	int
)	O
;	O
if	O
(	O
ys2	int
<=	O
ye2	int
)	O
RefreshArea	function
(	O
xs2	int
,	O
ys2	int
,	O
xe2	int
,	O
ye2	int
,	O
1	int
)	O
;	O
}	O
)	O
;	O
}	O
void	O
LInsChar	function
(	O
struct	O
layer	struct
*	O
l	pointer
,	O
struct	O
mchar	struct
*	O
c	pointer
,	O
int	O
x	int
,	O
int	O
y	int
,	O
struct	O
mline	struct
*	O
ol	pointer
)	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
struct	O
viewport	struct
*	O
vp	pointer
;	O
int	O
xs2	int
,	O
xe2	int
,	O
y2	int
,	O
f	int
;	O
struct	O
mchar	struct
*	O
c2	pointer
,	O
cc	struct
;	O
struct	O
mline	struct
*	O
rol	pointer
;	O
if	O
(	O
l	pointer
->	O
l_pause	struct
.	O
d	int
)	O
LayPauseUpdateRegion	function
(	O
l	pointer
,	O
x	int
,	O
l	pointer
->	O
l_width	int
-	O
1	int
,	O
y	int
,	O
y	int
)	O
;	O
FOR_EACH_UNPAUSED_CANVAS	O
(	O
l	pointer
,	O
for	O
(	O
vp	pointer
=	O
cv	pointer
->	O
c_vplist	pointer
;	O
vp	pointer
;	O
vp	pointer
=	O
vp	pointer
->	O
v_next	pointer
)	O
{	O
y2	int
=	O
y	int
+	O
vp	pointer
->	O
v_yoff	int
;	O
if	O
(	O
y2	int
<	O
vp	pointer
->	O
v_ys	int
||	O
y2	int
>	O
vp	pointer
->	O
v_ye	int
)	O
continue	O
;	O
xs2	int
=	O
x	int
+	O
vp	pointer
->	O
v_xoff	int
;	O
xe2	int
=	O
l	pointer
->	O
l_width	int
-	O
1	int
+	O
vp	pointer
->	O
v_xoff	int
;	O
c2	pointer
=	O
c	pointer
;	O
f	int
=	O
0	int
;	O
if	O
(	O
xs2	int
<	O
vp	pointer
->	O
v_xs	int
)	O
{	O
xs2	int
=	O
vp	pointer
->	O
v_xs	int
;	O
c2	pointer
=	O
&	O
mchar_blank	struct
;	O
if	O
(	O
ol	pointer
)	O
{	O
int	O
i	int
=	O
xs2	int
-	O
vp	pointer
->	O
v_xoff	int
-	O
1	int
;	O
if	O
(	O
i	int
>=	O
0	int
&&	O
i	int
<	O
l	pointer
->	O
l_width	int
)	O
{	O
copy_mline2mchar	O
(	O
&	O
cc	struct
,	O
ol	pointer
,	O
i	int
)	O
;	O
c2	pointer
=	O
&	O
cc	struct
;	O
}	O
}	O
else	O
f	int
=	O
1	int
;	O
}	O
if	O
(	O
xe2	int
>	O
vp	pointer
->	O
v_xe	int
)	O
xe2	int
=	O
vp	pointer
->	O
v_xe	int
;	O
if	O
(	O
xs2	int
>	O
xe2	int
)	O
continue	O
;	O
display	struct
=	O
cv	pointer
->	O
c_display	pointer
;	O
if	O
(	O
D_blocked	O
)	O
continue	O
;	O
rol	pointer
=	O
RECODE_MLINE	O
(	O
ol	pointer
)	O
;	O
InsChar	function
(	O
RECODE_MCHAR	O
(	O
c2	pointer
)	O
,	O
xs2	int
,	O
xe2	int
,	O
y2	int
,	O
mloff	function
(	O
rol	pointer
,	O
-	O
vp	pointer
->	O
v_xoff	int
)	O
)	O
;	O
if	O
(	O
f	int
)	O
RefreshArea	function
(	O
xs2	int
,	O
y2	int
,	O
xs2	int
,	O
y2	int
,	O
1	int
)	O
;	O
}	O
)	O
;	O
}	O
void	O
LPutChar	function
(	O
struct	O
layer	struct
*	O
l	pointer
,	O
struct	O
mchar	struct
*	O
c	pointer
,	O
int	O
x	int
,	O
int	O
y	int
)	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
struct	O
viewport	struct
*	O
vp	pointer
;	O
int	O
x2	int
,	O
y2	int
;	O
if	O
(	O
l	pointer
->	O
l_pause	struct
.	O
d	int
)	O
LayPauseUpdateRegion	function
(	O
l	pointer
,	O
x	int
,	O
x	int
+	O
(	O
c	pointer
->	O
mbcs	char
?	O
1	int
:	O
0	int
)	O
,	O
y	int
,	O
y	int
)	O
;	O
FOR_EACH_UNPAUSED_CANVAS	O
(	O
l	pointer
,	O
{	O
display	struct
=	O
cv	pointer
->	O
c_display	pointer
;	O
if	O
(	O
D_blocked	O
)	O
continue	O
;	O
for	O
(	O
vp	pointer
=	O
cv	pointer
->	O
c_vplist	pointer
;	O
vp	pointer
;	O
vp	pointer
=	O
vp	pointer
->	O
v_next	pointer
)	O
{	O
y2	int
=	O
y	int
+	O
vp	pointer
->	O
v_yoff	int
;	O
if	O
(	O
y2	int
<	O
vp	pointer
->	O
v_ys	int
||	O
y2	int
>	O
vp	pointer
->	O
v_ye	int
)	O
continue	O
;	O
x2	int
=	O
x	int
+	O
vp	pointer
->	O
v_xoff	int
;	O
if	O
(	O
x2	int
<	O
vp	pointer
->	O
v_xs	int
||	O
x2	int
>	O
vp	pointer
->	O
v_xe	int
)	O
continue	O
;	O
PutChar	function
(	O
RECODE_MCHAR	O
(	O
c	pointer
)	O
,	O
x2	int
,	O
y2	int
)	O
;	O
break	O
;	O
}	O
}	O
)	O
;	O
}	O
void	O
LPutStr	function
(	O
struct	O
layer	struct
*	O
l	pointer
,	O
char	O
*	O
s	pointer
,	O
int	O
n	int
,	O
struct	O
mchar	struct
*	O
r	pointer
,	O
int	O
x	int
,	O
int	O
y	int
)	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
struct	O
viewport	struct
*	O
vp	pointer
;	O
char	O
*	O
s2	pointer
;	O
int	O
xs2	int
,	O
xe2	int
,	O
y2	int
;	O
if	O
(	O
x	int
+	O
n	int
>	O
l	pointer
->	O
l_width	int
)	O
n	int
=	O
l	pointer
->	O
l_width	int
-	O
x	int
;	O
if	O
(	O
l	pointer
->	O
l_pause	struct
.	O
d	int
)	O
LayPauseUpdateRegion	function
(	O
l	pointer
,	O
x	int
,	O
x	int
+	O
n	int
-	O
1	int
,	O
y	int
,	O
y	int
)	O
;	O
FOR_EACH_UNPAUSED_CANVAS	O
(	O
l	pointer
,	O
for	O
(	O
vp	pointer
=	O
cv	pointer
->	O
c_vplist	pointer
;	O
vp	pointer
;	O
vp	pointer
=	O
vp	pointer
->	O
v_next	pointer
)	O
{	O
y2	int
=	O
y	int
+	O
vp	pointer
->	O
v_yoff	int
;	O
if	O
(	O
y2	int
<	O
vp	pointer
->	O
v_ys	int
||	O
y2	int
>	O
vp	pointer
->	O
v_ye	int
)	O
continue	O
;	O
xs2	int
=	O
x	int
+	O
vp	pointer
->	O
v_xoff	int
;	O
xe2	int
=	O
xs2	int
+	O
n	int
-	O
1	int
;	O
if	O
(	O
xs2	int
<	O
vp	pointer
->	O
v_xs	int
)	O
xs2	int
=	O
vp	pointer
->	O
v_xs	int
;	O
if	O
(	O
xe2	int
>	O
vp	pointer
->	O
v_xe	int
)	O
xe2	int
=	O
vp	pointer
->	O
v_xe	int
;	O
if	O
(	O
xs2	int
>	O
xe2	int
)	O
continue	O
;	O
display	struct
=	O
cv	pointer
->	O
c_display	pointer
;	O
if	O
(	O
D_blocked	O
)	O
continue	O
;	O
GotoPos	function
(	O
xs2	int
,	O
y2	int
)	O
;	O
SetRendition	function
(	O
r	pointer
)	O
;	O
s2	pointer
=	O
s	pointer
+	O
xs2	int
-	O
x	int
-	O
vp	pointer
->	O
v_xoff	int
;	O
if	O
(	O
D_encoding	O
==	O
UTF8	int
&&	O
l	pointer
->	O
l_encoding	int
!=	O
UTF8	int
&&	O
(	O
r	pointer
->	O
font	char
||	O
r	pointer
->	O
fontx	char
||	O
l	pointer
->	O
l_encoding	int
)	O
)	O
{	O
struct	O
mchar	struct
mc	struct
;	O
mc	struct
=	O
*	O
r	pointer
;	O
while	O
(	O
xs2	int
<=	O
xe2	int
)	O
{	O
mc	struct
.	O
image	char
=	O
*	O
s2	pointer
++	O
;	O
PutChar	function
(	O
RECODE_MCHAR	O
(	O
&	O
mc	struct
)	O
,	O
xs2	int
++	O
,	O
y2	int
)	O
;	O
}	O
continue	O
;	O
}	O
while	O
(	O
xs2	int
++	O
<=	O
xe2	int
)	O
PUTCHARLP	function
(	O
*	O
s2	pointer
++	O
)	O
;	O
}	O
)	O
;	O
}	O
void	O
LPutWinMsg	function
(	O
struct	O
layer	struct
*	O
l	pointer
,	O
char	O
*	O
s	pointer
,	O
int	O
n	int
,	O
struct	O
mchar	struct
*	O
r	pointer
,	O
int	O
x	int
,	O
int	O
y	int
)	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
struct	O
viewport	struct
*	O
vp	pointer
;	O
int	O
xs2	int
,	O
xe2	int
,	O
y2	int
,	O
len	int
,	O
len2	int
;	O
struct	O
mchar	struct
or	struct
;	O
if	O
(	O
x	int
+	O
n	int
>	O
l	pointer
->	O
l_width	int
)	O
n	int
=	O
l	pointer
->	O
l_width	int
-	O
x	int
;	O
if	O
(	O
l	pointer
->	O
l_pause	struct
.	O
d	int
)	O
LayPauseUpdateRegion	function
(	O
l	pointer
,	O
x	int
,	O
x	int
+	O
n	int
-	O
1	int
,	O
y	int
,	O
y	int
)	O
;	O
len	int
=	O
strlen	function
(	O
s	pointer
)	O
;	O
if	O
(	O
len	int
>	O
n	int
)	O
len	int
=	O
n	int
;	O
FOR_EACH_UNPAUSED_CANVAS	O
(	O
l	pointer
,	O
for	O
(	O
vp	pointer
=	O
cv	pointer
->	O
c_vplist	pointer
;	O
vp	pointer
;	O
vp	pointer
=	O
vp	pointer
->	O
v_next	pointer
)	O
{	O
y2	int
=	O
y	int
+	O
vp	pointer
->	O
v_yoff	int
;	O
if	O
(	O
y2	int
<	O
vp	pointer
->	O
v_ys	int
||	O
y2	int
>	O
vp	pointer
->	O
v_ye	int
)	O
continue	O
;	O
xs2	int
=	O
x	int
+	O
vp	pointer
->	O
v_xoff	int
;	O
xe2	int
=	O
xs2	int
+	O
n	int
-	O
1	int
;	O
if	O
(	O
xs2	int
<	O
vp	pointer
->	O
v_xs	int
)	O
xs2	int
=	O
vp	pointer
->	O
v_xs	int
;	O
if	O
(	O
xe2	int
>	O
vp	pointer
->	O
v_xe	int
)	O
xe2	int
=	O
vp	pointer
->	O
v_xe	int
;	O
if	O
(	O
xs2	int
>	O
xe2	int
)	O
continue	O
;	O
display	struct
=	O
cv	pointer
->	O
c_display	pointer
;	O
if	O
(	O
D_blocked	O
)	O
continue	O
;	O
GotoPos	function
(	O
xs2	int
,	O
y2	int
)	O
;	O
SetRendition	function
(	O
r	pointer
)	O
;	O
len2	int
=	O
xe2	int
-	O
(	O
x	int
+	O
vp	pointer
->	O
v_xoff	int
)	O
+	O
1	int
;	O
if	O
(	O
len2	int
>	O
len	int
)	O
len2	int
=	O
len	int
;	O
PutWinMsg	function
(	O
s	pointer
,	O
xs2	int
-	O
x	int
-	O
vp	pointer
->	O
v_xoff	int
,	O
len2	int
)	O
;	O
xs2	int
=	O
x	int
+	O
vp	pointer
->	O
v_xoff	int
+	O
len2	int
;	O
if	O
(	O
xs2	int
<	O
vp	pointer
->	O
v_xs	int
)	O
xs2	int
=	O
vp	pointer
->	O
v_xs	int
;	O
or	struct
=	O
D_rend	O
;	O
GotoPos	function
(	O
xs2	int
,	O
y2	int
)	O
;	O
SetRendition	function
(	O
&	O
or	struct
)	O
;	O
while	O
(	O
xs2	int
++	O
<=	O
xe2	int
)	O
PUTCHARLP	function
(	O
' '	O
)	O
;	O
}	O
)	O
;	O
}	O
void	O
LClearLine	function
(	O
struct	O
layer	struct
*	O
l	pointer
,	O
int	O
y	int
,	O
int	O
xs	int
,	O
int	O
xe	int
,	O
int	O
bce	int
,	O
struct	O
mline	struct
*	O
ol	pointer
)	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
struct	O
viewport	struct
*	O
vp	pointer
;	O
int	O
y2	int
,	O
xs2	int
,	O
xe2	int
;	O
if	O
(	O
xs	int
>=	O
l	pointer
->	O
l_width	int
)	O
xs	int
=	O
l	pointer
->	O
l_width	int
-	O
1	int
;	O
if	O
(	O
xe	int
>=	O
l	pointer
->	O
l_width	int
)	O
xe	int
=	O
l	pointer
->	O
l_width	int
-	O
1	int
;	O
if	O
(	O
l	pointer
->	O
l_pause	struct
.	O
d	int
)	O
LayPauseUpdateRegion	function
(	O
l	pointer
,	O
xs	int
,	O
xe	int
,	O
y	int
,	O
y	int
)	O
;	O
FOR_EACH_UNPAUSED_CANVAS	O
(	O
l	pointer
,	O
for	O
(	O
vp	pointer
=	O
cv	pointer
->	O
c_vplist	pointer
;	O
vp	pointer
;	O
vp	pointer
=	O
vp	pointer
->	O
v_next	pointer
)	O
{	O
xs2	int
=	O
xs	int
+	O
vp	pointer
->	O
v_xoff	int
;	O
xe2	int
=	O
xe	int
+	O
vp	pointer
->	O
v_xoff	int
;	O
y2	int
=	O
y	int
+	O
vp	pointer
->	O
v_yoff	int
;	O
if	O
(	O
y2	int
<	O
vp	pointer
->	O
v_ys	int
||	O
y2	int
>	O
vp	pointer
->	O
v_ye	int
)	O
continue	O
;	O
if	O
(	O
xs2	int
<	O
vp	pointer
->	O
v_xs	int
)	O
xs2	int
=	O
vp	pointer
->	O
v_xs	int
;	O
if	O
(	O
xe2	int
>	O
vp	pointer
->	O
v_xe	int
)	O
xe2	int
=	O
vp	pointer
->	O
v_xe	int
;	O
if	O
(	O
xs2	int
>	O
xe2	int
)	O
continue	O
;	O
display	struct
=	O
cv	pointer
->	O
c_display	pointer
;	O
if	O
(	O
D_blocked	O
)	O
continue	O
;	O
ClearLine	function
(	O
ol	pointer
?	O
mloff	function
(	O
RECODE_MLINE	O
(	O
ol	pointer
)	O
,	O
-	O
vp	pointer
->	O
v_xoff	int
)	O
:	O
(	O
struct	O
mline	struct
*	O
)	O
0	int
,	O
y2	int
,	O
xs2	int
,	O
xe2	int
,	O
bce	int
)	O
;	O
}	O
)	O
;	O
}	O
void	O
LClearArea	function
(	O
struct	O
layer	struct
*	O
l	pointer
,	O
int	O
xs	int
,	O
int	O
ys	int
,	O
int	O
xe	int
,	O
int	O
ye	int
,	O
int	O
bce	int
,	O
int	O
uself	int
)	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
struct	O
viewport	struct
*	O
vp	pointer
;	O
int	O
xs2	int
,	O
ys2	int
,	O
xe2	int
,	O
ye2	int
;	O
if	O
(	O
ys	int
<	O
0	int
||	O
ye	int
<	O
ys	int
)	O
return	O
;	O
if	O
(	O
xs	int
>=	O
l	pointer
->	O
l_width	int
)	O
xs	int
=	O
l	pointer
->	O
l_width	int
-	O
1	int
;	O
if	O
(	O
xe	int
>=	O
l	pointer
->	O
l_width	int
)	O
xe	int
=	O
l	pointer
->	O
l_width	int
-	O
1	int
;	O
if	O
(	O
l	pointer
->	O
l_pause	struct
.	O
d	int
)	O
LayPauseUpdateRegion	function
(	O
l	pointer
,	O
xs	int
,	O
xe	int
,	O
ys	int
,	O
ye	int
)	O
;	O
FOR_EACH_UNPAUSED_CANVAS	O
(	O
l	pointer
,	O
{	O
display	struct
=	O
cv	pointer
->	O
c_display	pointer
;	O
if	O
(	O
D_blocked	O
)	O
continue	O
;	O
for	O
(	O
vp	pointer
=	O
cv	pointer
->	O
c_vplist	pointer
;	O
vp	pointer
;	O
vp	pointer
=	O
vp	pointer
->	O
v_next	pointer
)	O
{	O
xs2	int
=	O
xs	int
+	O
vp	pointer
->	O
v_xoff	int
;	O
xe2	int
=	O
xe	int
+	O
vp	pointer
->	O
v_xoff	int
;	O
ys2	int
=	O
ys	int
+	O
vp	pointer
->	O
v_yoff	int
;	O
ye2	int
=	O
ye	int
+	O
vp	pointer
->	O
v_yoff	int
;	O
if	O
(	O
xs2	int
<	O
vp	pointer
->	O
v_xs	int
)	O
xs2	int
=	O
vp	pointer
->	O
v_xs	int
;	O
if	O
(	O
xe2	int
>	O
vp	pointer
->	O
v_xe	int
)	O
xe2	int
=	O
vp	pointer
->	O
v_xe	int
;	O
if	O
(	O
xs2	int
>	O
vp	pointer
->	O
v_xe	int
)	O
ys2	int
++	O
;	O
if	O
(	O
xe2	int
<	O
vp	pointer
->	O
v_xs	int
)	O
ye2	int
--	O
;	O
if	O
(	O
ys2	int
<	O
vp	pointer
->	O
v_ys	int
)	O
ys2	int
=	O
vp	pointer
->	O
v_ys	int
;	O
if	O
(	O
ye2	int
>	O
vp	pointer
->	O
v_ye	int
)	O
ye2	int
=	O
vp	pointer
->	O
v_ye	int
;	O
if	O
(	O
ys2	int
>	O
ye2	int
)	O
continue	O
;	O
if	O
(	O
xs	int
==	O
0	int
||	O
ys2	int
!=	O
ys	int
+	O
vp	pointer
->	O
v_yoff	int
)	O
xs2	int
=	O
vp	pointer
->	O
v_xs	int
;	O
if	O
(	O
xe	int
==	O
l	pointer
->	O
l_width	int
-	O
1	int
||	O
ye2	int
!=	O
ye	int
+	O
vp	pointer
->	O
v_yoff	int
)	O
xe2	int
=	O
vp	pointer
->	O
v_xe	int
;	O
display	struct
=	O
cv	pointer
->	O
c_display	pointer
;	O
ClearArea	function
(	O
xs2	int
,	O
ys2	int
,	O
vp	pointer
->	O
v_xs	int
,	O
vp	pointer
->	O
v_xe	int
,	O
xe2	int
,	O
ye2	int
,	O
bce	int
,	O
uself	int
)	O
;	O
if	O
(	O
xe	int
==	O
l	pointer
->	O
l_width	int
-	O
1	int
&&	O
xe2	int
>	O
vp	pointer
->	O
v_xoff	int
+	O
xe	int
)	O
{	O
int	O
y	int
;	O
SetRendition	function
(	O
&	O
mchar_blank	struct
)	O
;	O
for	O
(	O
y	int
=	O
ys2	int
;	O
y	int
<=	O
ye2	int
;	O
y	int
++	O
)	O
{	O
GotoPos	function
(	O
xe	int
+	O
vp	pointer
->	O
v_xoff	int
+	O
1	int
,	O
y	int
)	O
;	O
PUTCHARLP	function
(	O
'|'	O
)	O
;	O
}	O
}	O
}	O
}	O
)	O
;	O
}	O
void	O
LCDisplayLine	function
(	O
struct	O
layer	struct
*	O
l	pointer
,	O
struct	O
mline	struct
*	O
ml	pointer
,	O
int	O
y	int
,	O
int	O
xs	int
,	O
int	O
xe	int
,	O
int	O
isblank	int
)	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
struct	O
viewport	struct
*	O
vp	pointer
;	O
int	O
xs2	int
,	O
xe2	int
,	O
y2	int
;	O
if	O
(	O
l	pointer
->	O
l_pause	struct
.	O
d	int
)	O
LayPauseUpdateRegion	function
(	O
l	pointer
,	O
xs	int
,	O
xe	int
,	O
y	int
,	O
y	int
)	O
;	O
FOR_EACH_UNPAUSED_CANVAS	O
(	O
l	pointer
,	O
{	O
display	struct
=	O
cv	pointer
->	O
c_display	pointer
;	O
if	O
(	O
D_blocked	O
)	O
continue	O
;	O
for	O
(	O
vp	pointer
=	O
cv	pointer
->	O
c_vplist	pointer
;	O
vp	pointer
;	O
vp	pointer
=	O
vp	pointer
->	O
v_next	pointer
)	O
{	O
xs2	int
=	O
xs	int
+	O
vp	pointer
->	O
v_xoff	int
;	O
xe2	int
=	O
xe	int
+	O
vp	pointer
->	O
v_xoff	int
;	O
y2	int
=	O
y	int
+	O
vp	pointer
->	O
v_yoff	int
;	O
if	O
(	O
y2	int
<	O
vp	pointer
->	O
v_ys	int
||	O
y2	int
>	O
vp	pointer
->	O
v_ye	int
)	O
continue	O
;	O
if	O
(	O
xs2	int
<	O
vp	pointer
->	O
v_xs	int
)	O
xs2	int
=	O
vp	pointer
->	O
v_xs	int
;	O
if	O
(	O
xe2	int
>	O
vp	pointer
->	O
v_xe	int
)	O
xe2	int
=	O
vp	pointer
->	O
v_xe	int
;	O
if	O
(	O
xs2	int
>	O
xe2	int
)	O
continue	O
;	O
display	struct
=	O
cv	pointer
->	O
c_display	pointer
;	O
debug3	O
(	O
"LCDisplayLine: DisplayLine %d, %d-%d"	pointer
,	O
y2	int
,	O
xs2	int
,	O
xe2	int
)	O
;	O
debug1	O
(	O
"  mloff = %d\n"	pointer
,	O
-	O
vp	pointer
->	O
v_xoff	int
)	O
;	O
DisplayLine	function
(	O
isblank	int
?	O
&	O
mline_blank	struct
:	O
&	O
mline_null	struct
,	O
mloff	function
(	O
RECODE_MLINE	O
(	O
ml	pointer
)	O
,	O
-	O
vp	pointer
->	O
v_xoff	int
)	O
,	O
y2	int
,	O
xs2	int
,	O
xe2	int
)	O
;	O
}	O
}	O
)	O
;	O
}	O
void	O
LCDisplayLineWrap	function
(	O
struct	O
layer	struct
*	O
l	pointer
,	O
struct	O
mline	struct
*	O
ml	pointer
,	O
int	O
y	int
,	O
int	O
from	int
,	O
int	O
to	int
,	O
int	O
isblank	int
)	O
{	O
struct	O
mchar	struct
nc	struct
;	O
copy_mline2mchar	O
(	O
&	O
nc	struct
,	O
ml	pointer
,	O
0	int
)	O
;	O
if	O
(	O
dw_left	O
(	O
ml	pointer
,	O
0	int
,	O
l	pointer
->	O
l_encoding	int
)	O
)	O
{	O
nc	struct
.	O
mbcs	char
=	O
ml	pointer
->	O
image	char
[	O
1	int
]	O
;	O
from	int
++	O
;	O
}	O
LWrapChar	function
(	O
l	pointer
,	O
&	O
nc	struct
,	O
y	int
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
0	int
)	O
;	O
from	int
++	O
;	O
if	O
(	O
from	int
<=	O
to	int
)	O
LCDisplayLine	function
(	O
l	pointer
,	O
ml	pointer
,	O
y	int
,	O
from	int
,	O
to	int
,	O
isblank	int
)	O
;	O
}	O
void	O
LSetRendition	function
(	O
struct	O
layer	struct
*	O
l	pointer
,	O
struct	O
mchar	struct
*	O
r	pointer
)	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
for	O
(	O
cv	pointer
=	O
l	pointer
->	O
l_cvlist	pointer
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_lnext	pointer
)	O
{	O
display	struct
=	O
cv	pointer
->	O
c_display	pointer
;	O
if	O
(	O
D_blocked	O
)	O
continue	O
;	O
SetRendition	function
(	O
r	pointer
)	O
;	O
}	O
}	O
void	O
LWrapChar	function
(	O
struct	O
layer	struct
*	O
l	pointer
,	O
struct	O
mchar	struct
*	O
c	pointer
,	O
int	O
y	int
,	O
int	O
top	int
,	O
int	O
bot	int
,	O
int	O
ins	int
)	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
,	O
*	O
cvlist	pointer
,	O
*	O
cvlnext	pointer
;	O
struct	O
viewport	struct
*	O
vp	pointer
,	O
*	O
evp	pointer
,	O
*	O
*	O
vpp	pointer
;	O
int	O
yy	int
,	O
y2	int
,	O
yy2	int
,	O
top2	int
,	O
bot2	int
;	O
int	O
bce	int
;	O
if	O
(	O
l	pointer
->	O
l_pause	struct
.	O
d	int
)	O
LayPauseUpdateRegion	function
(	O
l	pointer
,	O
0	int
,	O
l	pointer
->	O
l_width	int
-	O
1	int
,	O
top	int
,	O
bot	int
)	O
;	O
bce	int
=	O
rend_getbg	O
(	O
c	pointer
)	O
;	O
if	O
(	O
y	int
!=	O
bot	int
)	O
{	O
yy	int
=	O
y	int
==	O
l	pointer
->	O
l_height	int
-	O
1	int
?	O
y	int
:	O
y	int
+	O
1	int
;	O
FOR_EACH_UNPAUSED_CANVAS	O
(	O
l	pointer
,	O
{	O
y2	int
=	O
0	int
;	O
display	struct
=	O
cv	pointer
->	O
c_display	pointer
;	O
if	O
(	O
D_blocked	O
)	O
continue	O
;	O
for	O
(	O
vp	pointer
=	O
cv	pointer
->	O
c_vplist	pointer
;	O
vp	pointer
;	O
vp	pointer
=	O
vp	pointer
->	O
v_next	pointer
)	O
{	O
y2	int
=	O
y	int
+	O
vp	pointer
->	O
v_yoff	int
;	O
yy2	int
=	O
yy	int
+	O
vp	pointer
->	O
v_yoff	int
;	O
if	O
(	O
yy2	int
>=	O
vp	pointer
->	O
v_ys	int
&&	O
yy2	int
<=	O
vp	pointer
->	O
v_ye	int
&&	O
vp	pointer
->	O
v_xoff	int
>=	O
vp	pointer
->	O
v_xs	int
&&	O
vp	pointer
->	O
v_xoff	int
<=	O
vp	pointer
->	O
v_xe	int
)	O
break	O
;	O
}	O
if	O
(	O
vp	pointer
==	O
0	int
)	O
continue	O
;	O
for	O
(	O
evp	pointer
=	O
cv	pointer
->	O
c_vplist	pointer
;	O
evp	pointer
;	O
evp	pointer
=	O
evp	pointer
->	O
v_next	pointer
)	O
if	O
(	O
y2	int
>=	O
evp	pointer
->	O
v_ys	int
&&	O
y2	int
<=	O
evp	pointer
->	O
v_ye	int
&&	O
evp	pointer
->	O
v_xoff	int
+	O
l	pointer
->	O
l_width	int
-	O
1	int
>=	O
evp	pointer
->	O
v_xs	int
&&	O
evp	pointer
->	O
v_xoff	int
+	O
l	pointer
->	O
l_width	int
-	O
1	int
<=	O
evp	pointer
->	O
v_xe	int
)	O
break	O
;	O
if	O
(	O
evp	pointer
==	O
0	int
||	O
(	O
ins	int
&&	O
vp	pointer
->	O
v_xoff	int
+	O
l	pointer
->	O
l_width	int
-	O
1	int
>	O
vp	pointer
->	O
v_ye	int
)	O
)	O
{	O
debug	O
(	O
"LWrap: can't wrap!\n"	pointer
)	O
;	O
cvlist	pointer
=	O
l	pointer
->	O
l_cvlist	pointer
;	O
cvlnext	pointer
=	O
cv	pointer
->	O
c_lnext	pointer
;	O
l	pointer
->	O
l_cvlist	pointer
=	O
cv	pointer
;	O
cv	pointer
->	O
c_lnext	pointer
=	O
0	int
;	O
if	O
(	O
ins	int
)	O
LInsChar	function
(	O
l	pointer
,	O
c	pointer
,	O
0	int
,	O
yy	int
,	O
0	int
)	O
;	O
else	O
LPutChar	function
(	O
l	pointer
,	O
c	pointer
,	O
0	int
,	O
yy	int
)	O
;	O
l	pointer
->	O
l_cvlist	pointer
=	O
cvlist	pointer
;	O
cv	pointer
->	O
c_lnext	pointer
=	O
cvlnext	pointer
;	O
}	O
else	O
WrapChar	function
(	O
RECODE_MCHAR	O
(	O
c	pointer
)	O
,	O
vp	pointer
->	O
v_xoff	int
+	O
l	pointer
->	O
l_width	int
,	O
y2	int
,	O
vp	pointer
->	O
v_xoff	int
,	O
-	O
1	int
,	O
vp	pointer
->	O
v_xoff	int
+	O
l	pointer
->	O
l_width	int
-	O
1	int
,	O
-	O
1	int
,	O
ins	int
)	O
;	O
}	O
)	O
;	O
}	O
else	O
{	O
FOR_EACH_UNPAUSED_CANVAS	O
(	O
l	pointer
,	O
{	O
display	struct
=	O
cv	pointer
->	O
c_display	pointer
;	O
if	O
(	O
D_blocked	O
)	O
continue	O
;	O
for	O
(	O
vpp	pointer
=	O
&	O
cv	pointer
->	O
c_vplist	pointer
;	O
(	O
vp	pointer
=	O
*	O
vpp	pointer
)	O
;	O
vpp	pointer
=	O
&	O
vp	pointer
->	O
v_next	pointer
)	O
{	O
yy2	int
=	O
bot	int
+	O
vp	pointer
->	O
v_yoff	int
;	O
if	O
(	O
yy2	int
>=	O
vp	pointer
->	O
v_ys	int
&&	O
yy2	int
<=	O
vp	pointer
->	O
v_ye	int
&&	O
vp	pointer
->	O
v_xoff	int
>=	O
vp	pointer
->	O
v_xs	int
&&	O
vp	pointer
->	O
v_xoff	int
+	O
l	pointer
->	O
l_width	int
-	O
1	int
<=	O
vp	pointer
->	O
v_xe	int
)	O
break	O
;	O
}	O
if	O
(	O
vp	pointer
)	O
{	O
*	O
vpp	pointer
=	O
vp	pointer
->	O
v_next	pointer
;	O
}	O
if	O
(	O
cv	pointer
->	O
c_vplist	pointer
)	O
{	O
cvlist	pointer
=	O
l	pointer
->	O
l_cvlist	pointer
;	O
cvlnext	pointer
=	O
cv	pointer
->	O
c_lnext	pointer
;	O
l	pointer
->	O
l_cvlist	pointer
=	O
cv	pointer
;	O
cv	pointer
->	O
c_lnext	pointer
=	O
0	int
;	O
LScrollV	function
(	O
l	pointer
,	O
1	int
,	O
top	int
,	O
bot	int
,	O
bce	int
)	O
;	O
if	O
(	O
!	O
vp	pointer
)	O
{	O
if	O
(	O
ins	int
)	O
LInsChar	function
(	O
l	pointer
,	O
c	pointer
,	O
0	int
,	O
bot	int
,	O
0	int
)	O
;	O
else	O
LPutChar	function
(	O
l	pointer
,	O
c	pointer
,	O
0	int
,	O
bot	int
)	O
;	O
}	O
l	pointer
->	O
l_cvlist	pointer
=	O
cvlist	pointer
;	O
cv	pointer
->	O
c_lnext	pointer
=	O
cvlnext	pointer
;	O
}	O
if	O
(	O
vp	pointer
)	O
{	O
*	O
vpp	pointer
=	O
vp	pointer
;	O
top2	int
=	O
top	int
+	O
vp	pointer
->	O
v_yoff	int
;	O
bot2	int
=	O
bot	int
+	O
vp	pointer
->	O
v_yoff	int
;	O
if	O
(	O
top2	int
<	O
vp	pointer
->	O
v_ys	int
)	O
top2	int
=	O
vp	pointer
->	O
v_ys	int
;	O
WrapChar	function
(	O
RECODE_MCHAR	O
(	O
c	pointer
)	O
,	O
vp	pointer
->	O
v_xoff	int
+	O
l	pointer
->	O
l_width	int
,	O
bot2	int
,	O
vp	pointer
->	O
v_xoff	int
,	O
top2	int
,	O
vp	pointer
->	O
v_xoff	int
+	O
l	pointer
->	O
l_width	int
-	O
1	int
,	O
bot2	int
,	O
ins	int
)	O
;	O
}	O
}	O
)	O
;	O
}	O
}	O
void	O
LCursorVisibility	function
(	O
struct	O
layer	struct
*	O
l	pointer
,	O
int	O
vis	int
)	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
for	O
(	O
cv	pointer
=	O
l	pointer
->	O
l_cvlist	pointer
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_lnext	pointer
)	O
{	O
display	struct
=	O
cv	pointer
->	O
c_display	pointer
;	O
if	O
(	O
D_blocked	O
)	O
continue	O
;	O
if	O
(	O
cv	pointer
!=	O
D_forecv	O
)	O
continue	O
;	O
CursorVisibility	function
(	O
vis	int
)	O
;	O
}	O
}	O
void	O
LSetFlow	function
(	O
struct	O
layer	struct
*	O
l	pointer
,	O
int	O
flow	int
)	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
for	O
(	O
cv	pointer
=	O
l	pointer
->	O
l_cvlist	pointer
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_lnext	pointer
)	O
{	O
display	struct
=	O
cv	pointer
->	O
c_display	pointer
;	O
if	O
(	O
cv	pointer
!=	O
D_forecv	O
)	O
continue	O
;	O
SetFlow	function
(	O
flow	int
)	O
;	O
}	O
}	O
void	O
LKeypadMode	function
(	O
struct	O
layer	struct
*	O
l	pointer
,	O
int	O
on	int
)	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
for	O
(	O
cv	pointer
=	O
l	pointer
->	O
l_cvlist	pointer
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_lnext	pointer
)	O
{	O
display	struct
=	O
cv	pointer
->	O
c_display	pointer
;	O
if	O
(	O
D_blocked	O
)	O
continue	O
;	O
if	O
(	O
cv	pointer
!=	O
D_forecv	O
)	O
continue	O
;	O
KeypadMode	function
(	O
on	int
)	O
;	O
}	O
}	O
void	O
LCursorkeysMode	function
(	O
struct	O
layer	struct
*	O
l	pointer
,	O
int	O
on	int
)	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
for	O
(	O
cv	pointer
=	O
l	pointer
->	O
l_cvlist	pointer
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_lnext	pointer
)	O
{	O
display	struct
=	O
cv	pointer
->	O
c_display	pointer
;	O
if	O
(	O
D_blocked	O
)	O
continue	O
;	O
if	O
(	O
cv	pointer
!=	O
D_forecv	O
)	O
continue	O
;	O
CursorkeysMode	function
(	O
on	int
)	O
;	O
}	O
}	O
void	O
LMouseMode	function
(	O
struct	O
layer	struct
*	O
l	pointer
,	O
int	O
on	int
)	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
for	O
(	O
cv	pointer
=	O
l	pointer
->	O
l_cvlist	pointer
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_lnext	pointer
)	O
{	O
display	struct
=	O
cv	pointer
->	O
c_display	pointer
;	O
if	O
(	O
D_blocked	O
)	O
continue	O
;	O
if	O
(	O
cv	pointer
!=	O
D_forecv	O
)	O
continue	O
;	O
MouseMode	function
(	O
on	int
)	O
;	O
}	O
}	O
void	O
LClearAll	function
(	O
struct	O
layer	struct
*	O
l	pointer
,	O
int	O
uself	int
)	O
{	O
LClearArea	function
(	O
l	pointer
,	O
0	int
,	O
0	int
,	O
l	pointer
->	O
l_width	int
-	O
1	int
,	O
l	pointer
->	O
l_height	int
-	O
1	int
,	O
0	int
,	O
uself	int
)	O
;	O
}	O
void	O
LRefreshAll	function
(	O
struct	O
layer	struct
*	O
l	pointer
,	O
int	O
isblank	int
)	O
{	O
struct	O
layer	struct
*	O
oldflayer	pointer
;	O
int	O
y	int
;	O
debug1	O
(	O
"LRefreshAll isblank=%d\n"	pointer
,	O
isblank	int
)	O
;	O
oldflayer	pointer
=	O
flayer	pointer
;	O
flayer	pointer
=	O
l	pointer
;	O
if	O
(	O
!	O
isblank	int
)	O
LClearArea	function
(	O
l	pointer
,	O
0	int
,	O
0	int
,	O
l	pointer
->	O
l_width	int
-	O
1	int
,	O
l	pointer
->	O
l_height	int
-	O
1	int
,	O
0	int
,	O
0	int
)	O
;	O
LayRedisplayLine	O
(	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
1	int
)	O
;	O
for	O
(	O
y	int
=	O
0	int
;	O
y	int
<	O
l	pointer
->	O
l_height	int
;	O
y	int
++	O
)	O
LayRedisplayLine	O
(	O
y	int
,	O
0	int
,	O
l	pointer
->	O
l_width	int
-	O
1	int
,	O
1	int
)	O
;	O
flayer	pointer
=	O
oldflayer	pointer
;	O
}	O
void	O
LMsg	function
(	O
int	O
err	long
,	O
const	O
char	O
*	O
fmt	pointer
,	O
VA_DOTS	O
)	O
{	O
VA_LIST	O
(	O
ap	array
)	O
char	O
buf	pointer
[	O
MAXPATHLEN	O
*	O
2	int
]	O
;	O
char	O
*	O
p	pointer
=	O
buf	pointer
;	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
VA_START	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
fmt	pointer
=	O
DoNLS	function
(	O
fmt	pointer
)	O
;	O
(	O
void	O
)	O
vsnprintf	function
(	O
p	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
-	O
100	int
,	O
fmt	pointer
,	O
VA_ARGS	O
(	O
ap	array
)	O
)	O
;	O
VA_END	O
(	O
ap	array
)	O
;	O
if	O
(	O
err	long
)	O
{	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
;	O
*	O
p	pointer
++	O
=	O
':'	O
;	O
*	O
p	pointer
++	O
=	O
' '	O
;	O
strncpy	function
(	O
p	pointer
,	O
strerror	function
(	O
err	long
)	O
,	O
buf	pointer
+	O
sizeof	O
(	O
buf	pointer
)	O
-	O
p	pointer
-	O
1	int
)	O
;	O
buf	pointer
[	O
sizeof	O
(	O
buf	pointer
)	O
-	O
1	int
]	O
=	O
0	int
;	O
}	O
debug2	O
(	O
"LMsg('%s') (%#x);\n"	pointer
,	O
buf	pointer
,	O
(	O
unsigned	O
int	O
)	O
flayer	pointer
)	O
;	O
for	O
(	O
display	struct
=	O
displays	pointer
;	O
display	struct
;	O
display	struct
=	O
display	struct
->	O
d_next	pointer
)	O
{	O
for	O
(	O
cv	pointer
=	O
D_cvlist	O
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_next	pointer
)	O
if	O
(	O
cv	pointer
->	O
c_layer	pointer
==	O
flayer	pointer
)	O
break	O
;	O
if	O
(	O
cv	pointer
==	O
0	int
)	O
continue	O
;	O
MakeStatus	function
(	O
buf	pointer
)	O
;	O
}	O
}	O
void	O
LExtMouseMode	function
(	O
l	pointer
,	O
on	int
)	O
struct	O
layer	struct
*	O
l	pointer
;	O
int	O
on	int
;	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
for	O
(	O
cv	pointer
=	O
l	pointer
->	O
l_cvlist	pointer
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_lnext	pointer
)	O
{	O
display	struct
=	O
cv	pointer
->	O
c_display	pointer
;	O
if	O
(	O
D_blocked	O
)	O
continue	O
;	O
if	O
(	O
cv	pointer
!=	O
D_forecv	O
)	O
continue	O
;	O
ExtMouseMode	function
(	O
on	int
)	O
;	O
}	O
}	O
void	O
KillLayerChain	function
(	O
struct	O
layer	struct
*	O
lay	pointer
)	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
,	O
*	O
ncv	pointer
;	O
struct	O
layer	struct
*	O
l	pointer
,	O
*	O
oldflayer	pointer
;	O
oldflayer	pointer
=	O
flayer	pointer
;	O
debug1	O
(	O
"KillLayerChain %#x\n"	pointer
,	O
lay	pointer
)	O
;	O
for	O
(	O
l	pointer
=	O
lay	pointer
;	O
l	pointer
;	O
l	pointer
=	O
l	pointer
->	O
l_next	pointer
)	O
{	O
if	O
(	O
l	pointer
->	O
l_layfn	pointer
==	O
&	O
WinLf	struct
||	O
l	pointer
->	O
l_layfn	pointer
==	O
&	O
BlankLf	struct
)	O
break	O
;	O
debug1	O
(	O
"- killing %#x\n"	pointer
,	O
l	pointer
)	O
;	O
if	O
(	O
oldflayer	pointer
==	O
l	pointer
)	O
oldflayer	pointer
=	O
0	int
;	O
for	O
(	O
cv	pointer
=	O
l	pointer
->	O
l_cvlist	pointer
;	O
cv	pointer
;	O
cv	pointer
=	O
ncv	pointer
)	O
{	O
ncv	pointer
=	O
cv	pointer
->	O
c_lnext	pointer
;	O
cv	pointer
->	O
c_layer	pointer
=	O
0	int
;	O
cv	pointer
->	O
c_lnext	pointer
=	O
0	int
;	O
}	O
}	O
flayer	pointer
=	O
lay	pointer
;	O
while	O
(	O
flayer	pointer
!=	O
l	pointer
)	O
ExitOverlayPage	function
(	O
)	O
;	O
flayer	pointer
=	O
oldflayer	pointer
;	O
}	O
int	O
InitOverlayPage	function
(	O
int	O
datasize	int
,	O
struct	O
LayFuncs	struct
*	O
lf	pointer
,	O
int	O
block	int
)	O
{	O
char	O
*	O
data	pointer
;	O
struct	O
layer	struct
*	O
newlay	pointer
;	O
struct	O
canvas	struct
*	O
cv	pointer
,	O
*	O
cvp	pointer
,	O
*	O
*	O
cvpp	pointer
;	O
struct	O
win	struct
*	O
p	pointer
;	O
ASSERT	O
(	O
flayer	pointer
)	O
;	O
cv	pointer
=	O
0	int
;	O
if	O
(	O
display	struct
&&	O
D_forecv	O
->	O
c_layer	pointer
==	O
flayer	pointer
)	O
cv	pointer
=	O
D_forecv	O
;	O
if	O
(	O
(	O
newlay	pointer
=	O
(	O
struct	O
layer	struct
*	O
)	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
struct	O
layer	struct
)	O
)	O
)	O
==	O
0	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"No memory for layer struct"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
debug2	O
(	O
"Entering new layer on top of %#x: %#x\n"	pointer
,	O
(	O
unsigned	O
int	O
)	O
flayer	pointer
,	O
newlay	pointer
)	O
;	O
data	pointer
=	O
0	int
;	O
if	O
(	O
datasize	int
)	O
{	O
if	O
(	O
(	O
data	pointer
=	O
calloc	function
(	O
1	int
,	O
datasize	int
)	O
)	O
==	O
0	int
)	O
{	O
free	function
(	O
(	O
char	O
*	O
)	O
newlay	pointer
)	O
;	O
Msg	function
(	O
0	int
,	O
"No memory for layer data"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
p	pointer
=	O
Layer2Window	O
(	O
flayer	pointer
)	O
;	O
if	O
(	O
p	pointer
&&	O
(	O
p	pointer
->	O
w_savelayer	pointer
==	O
flayer	pointer
||	O
(	O
block	int
&&	O
flayer	pointer
->	O
l_next	pointer
==	O
0	int
)	O
)	O
)	O
{	O
if	O
(	O
p	pointer
->	O
w_savelayer	pointer
&&	O
p	pointer
->	O
w_savelayer	pointer
!=	O
flayer	pointer
&&	O
p	pointer
->	O
w_savelayer	pointer
->	O
l_cvlist	pointer
==	O
0	int
)	O
KillLayerChain	function
(	O
p	pointer
->	O
w_savelayer	pointer
)	O
;	O
p	pointer
->	O
w_savelayer	pointer
=	O
newlay	pointer
;	O
}	O
if	O
(	O
cv	pointer
&&	O
flayer	pointer
->	O
l_next	pointer
==	O
0	int
&&	O
!	O
block	int
)	O
{	O
struct	O
display	struct
*	O
olddisplay	pointer
=	O
display	struct
;	O
display	struct
=	O
cv	pointer
->	O
c_display	pointer
;	O
RemoveStatus	function
(	O
)	O
;	O
display	struct
=	O
olddisplay	pointer
;	O
for	O
(	O
cvpp	pointer
=	O
&	O
flayer	pointer
->	O
l_cvlist	pointer
;	O
(	O
cvp	pointer
=	O
*	O
cvpp	pointer
)	O
;	O
cvpp	pointer
=	O
&	O
cvp	pointer
->	O
c_lnext	pointer
)	O
if	O
(	O
cvp	pointer
==	O
cv	pointer
)	O
break	O
;	O
ASSERT	O
(	O
cvp	pointer
)	O
;	O
*	O
cvpp	pointer
=	O
cv	pointer
->	O
c_lnext	pointer
;	O
newlay	pointer
->	O
l_cvlist	pointer
=	O
cv	pointer
;	O
cv	pointer
->	O
c_lnext	pointer
=	O
0	int
;	O
cv	pointer
->	O
c_layer	pointer
=	O
newlay	pointer
;	O
}	O
else	O
{	O
LAY_DISPLAYS	O
(	O
flayer	pointer
,	O
RemoveStatus	function
(	O
)	O
)	O
;	O
if	O
(	O
block	int
)	O
debug	O
(	O
"layer is blocking\n"	pointer
)	O
;	O
if	O
(	O
block	int
&&	O
flayer	pointer
->	O
l_layfn	pointer
==	O
&	O
WinLf	struct
)	O
{	O
debug	O
(	O
"...and is first, so window gets blocked\n"	pointer
)	O
;	O
ASSERT	O
(	O
p	pointer
->	O
w_blocked	int
==	O
0	int
)	O
;	O
p	pointer
->	O
w_blocked	int
++	O
;	O
newlay	pointer
->	O
l_blocking	int
=	O
1	int
;	O
}	O
newlay	pointer
->	O
l_cvlist	pointer
=	O
flayer	pointer
->	O
l_cvlist	pointer
;	O
for	O
(	O
cvp	pointer
=	O
newlay	pointer
->	O
l_cvlist	pointer
;	O
cvp	pointer
;	O
cvp	pointer
=	O
cvp	pointer
->	O
c_lnext	pointer
)	O
cvp	pointer
->	O
c_layer	pointer
=	O
newlay	pointer
;	O
flayer	pointer
->	O
l_cvlist	pointer
=	O
0	int
;	O
}	O
newlay	pointer
->	O
l_width	int
=	O
flayer	pointer
->	O
l_width	int
;	O
newlay	pointer
->	O
l_height	int
=	O
flayer	pointer
->	O
l_height	int
;	O
newlay	pointer
->	O
l_encoding	int
=	O
0	int
;	O
newlay	pointer
->	O
l_layfn	pointer
=	O
lf	pointer
;	O
newlay	pointer
->	O
l_data	pointer
=	O
data	pointer
;	O
newlay	pointer
->	O
l_next	pointer
=	O
flayer	pointer
;	O
newlay	pointer
->	O
l_bottom	pointer
=	O
flayer	pointer
->	O
l_bottom	pointer
;	O
flayer	pointer
=	O
newlay	pointer
;	O
LayRestore	O
(	O
)	O
;	O
return	O
0	int
;	O
}	O
extern	O
struct	O
layout	struct
*	O
layouts	pointer
;	O
void	O
ExitOverlayPage	function
(	O
)	O
{	O
struct	O
layer	struct
*	O
oldlay	pointer
;	O
struct	O
win	struct
*	O
p	pointer
;	O
int	O
doredisplay	int
=	O
0	int
;	O
struct	O
canvas	struct
*	O
cv	pointer
,	O
*	O
ocv	pointer
;	O
struct	O
layout	struct
*	O
lay	pointer
;	O
ASSERT	O
(	O
flayer	pointer
)	O
;	O
debug1	O
(	O
"Exiting layer %#x\n"	pointer
,	O
(	O
unsigned	O
int	O
)	O
flayer	pointer
)	O
;	O
oldlay	pointer
=	O
flayer	pointer
;	O
if	O
(	O
oldlay	pointer
->	O
l_data	pointer
)	O
{	O
if	O
(	O
oldlay	pointer
->	O
l_layfn	pointer
->	O
lf_LayFree	pointer
)	O
LayFree	O
(	O
oldlay	pointer
->	O
l_data	pointer
)	O
;	O
free	function
(	O
oldlay	pointer
->	O
l_data	pointer
)	O
;	O
}	O
p	pointer
=	O
Layer2Window	O
(	O
flayer	pointer
)	O
;	O
flayer	pointer
=	O
oldlay	pointer
->	O
l_next	pointer
;	O
if	O
(	O
flayer	pointer
->	O
l_layfn	pointer
==	O
&	O
WinLf	struct
)	O
{	O
if	O
(	O
oldlay	pointer
->	O
l_blocking	int
)	O
{	O
ASSERT	O
(	O
p	pointer
->	O
w_blocked	int
>	O
0	int
)	O
;	O
p	pointer
->	O
w_blocked	int
--	O
;	O
debug1	O
(	O
"layer was blocking, -> w_blocked now %d\n"	pointer
,	O
p	pointer
->	O
w_blocked	int
)	O
;	O
}	O
if	O
(	O
p	pointer
->	O
w_blocked	int
&&	O
p	pointer
->	O
w_savelayer	pointer
&&	O
p	pointer
->	O
w_savelayer	pointer
!=	O
flayer	pointer
&&	O
oldlay	pointer
->	O
l_cvlist	pointer
)	O
{	O
debug	O
(	O
"warping to top of blocking chain!\n"	pointer
)	O
;	O
flayer	pointer
=	O
p	pointer
->	O
w_savelayer	pointer
;	O
doredisplay	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
p	pointer
&&	O
p	pointer
->	O
w_savelayer	pointer
==	O
oldlay	pointer
)	O
p	pointer
->	O
w_savelayer	pointer
=	O
flayer	pointer
;	O
if	O
(	O
p	pointer
&&	O
oldlay	pointer
==	O
p	pointer
->	O
w_paster	struct
.	O
pa_pastelayer	pointer
)	O
p	pointer
->	O
w_paster	struct
.	O
pa_pastelayer	pointer
=	O
0	int
;	O
for	O
(	O
lay	pointer
=	O
layouts	pointer
;	O
lay	pointer
;	O
lay	pointer
=	O
lay	pointer
->	O
lay_next	pointer
)	O
for	O
(	O
cv	pointer
=	O
lay	pointer
->	O
lay_cvlist	pointer
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_next	pointer
)	O
if	O
(	O
cv	pointer
->	O
c_layer	pointer
==	O
oldlay	pointer
)	O
cv	pointer
->	O
c_layer	pointer
=	O
flayer	pointer
;	O
for	O
(	O
ocv	pointer
=	O
0	int
,	O
cv	pointer
=	O
oldlay	pointer
->	O
l_cvlist	pointer
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_lnext	pointer
)	O
{	O
cv	pointer
->	O
c_layer	pointer
=	O
flayer	pointer
;	O
ocv	pointer
=	O
cv	pointer
;	O
}	O
if	O
(	O
ocv	pointer
)	O
{	O
cv	pointer
=	O
flayer	pointer
->	O
l_cvlist	pointer
;	O
ocv	pointer
->	O
c_lnext	pointer
=	O
0	int
;	O
flayer	pointer
->	O
l_cvlist	pointer
=	O
oldlay	pointer
->	O
l_cvlist	pointer
;	O
if	O
(	O
doredisplay	int
)	O
LRefreshAll	function
(	O
flayer	pointer
,	O
0	int
)	O
;	O
ocv	pointer
->	O
c_lnext	pointer
=	O
cv	pointer
;	O
}	O
oldlay	pointer
->	O
l_cvlist	pointer
=	O
0	int
;	O
LayerCleanupMemory	function
(	O
oldlay	pointer
)	O
;	O
free	function
(	O
(	O
char	O
*	O
)	O
oldlay	pointer
)	O
;	O
LayRestore	O
(	O
)	O
;	O
LaySetCursor	O
(	O
)	O
;	O
}	O
int	O
LayProcessMouse	function
(	O
struct	O
layer	struct
*	O
l	pointer
,	O
unsigned	O
char	O
ch	char
)	O
{	O
int	O
len	int
;	O
if	O
(	O
l	pointer
->	O
l_mouseevent	struct
.	O
len	int
>=	O
sizeof	O
(	O
l	pointer
->	O
l_mouseevent	struct
.	O
buffer	array
)	O
)	O
return	O
-	O
1	int
;	O
len	int
=	O
l	pointer
->	O
l_mouseevent	struct
.	O
len	int
++	O
;	O
l	pointer
->	O
l_mouseevent	struct
.	O
buffer	array
[	O
len	int
]	O
=	O
(	O
len	int
>	O
0	int
?	O
ch	char
-	O
33	int
:	O
ch	char
)	O
;	O
return	O
(	O
l	pointer
->	O
l_mouseevent	struct
.	O
len	int
==	O
sizeof	O
(	O
l	pointer
->	O
l_mouseevent	struct
.	O
buffer	array
)	O
)	O
;	O
}	O
void	O
LayProcessMouseSwitch	function
(	O
struct	O
layer	struct
*	O
l	pointer
,	O
int	O
s	pointer
)	O
{	O
if	O
(	O
(	O
l	pointer
->	O
l_mouseevent	struct
.	O
start	int
=	O
s	pointer
)	O
)	O
l	pointer
->	O
l_mouseevent	struct
.	O
len	int
=	O
0	int
;	O
}	O
void	O
LayPause	function
(	O
struct	O
layer	struct
*	O
layer	struct
,	O
int	O
pause	function
)	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
int	O
line	array
;	O
struct	O
win	struct
*	O
win	struct
;	O
pause	function
=	O
!	O
!	O
pause	function
;	O
if	O
(	O
layer	struct
->	O
l_pause	struct
.	O
d	int
==	O
pause	function
)	O
return	O
;	O
if	O
(	O
(	O
layer	struct
->	O
l_pause	struct
.	O
d	int
=	O
pause	function
)	O
)	O
{	O
layer	struct
->	O
l_pause	struct
.	O
top	int
=	O
layer	struct
->	O
l_pause	struct
.	O
bottom	int
=	O
-	O
1	int
;	O
return	O
;	O
}	O
if	O
(	O
layer	struct
->	O
l_pause	struct
.	O
top	int
==	O
-	O
1	int
&&	O
layer	struct
->	O
l_pause	struct
.	O
bottom	int
==	O
-	O
1	int
)	O
return	O
;	O
if	O
(	O
layer	struct
->	O
l_layfn	pointer
==	O
&	O
WinLf	struct
)	O
win	struct
=	O
layer	struct
->	O
l_data	pointer
;	O
else	O
win	struct
=	O
NULL	O
;	O
for	O
(	O
cv	pointer
=	O
layer	struct
->	O
l_cvlist	pointer
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_lnext	pointer
)	O
{	O
struct	O
viewport	struct
*	O
vp	pointer
;	O
if	O
(	O
!	O
cv	pointer
->	O
c_slorient	int
)	O
continue	O
;	O
display	struct
=	O
cv	pointer
->	O
c_display	pointer
;	O
for	O
(	O
vp	pointer
=	O
cv	pointer
->	O
c_vplist	pointer
;	O
vp	pointer
;	O
vp	pointer
=	O
vp	pointer
->	O
v_next	pointer
)	O
{	O
for	O
(	O
line	array
=	O
layer	struct
->	O
l_pause	struct
.	O
top	int
;	O
line	array
<=	O
layer	struct
->	O
l_pause	struct
.	O
bottom	int
;	O
line	array
++	O
)	O
{	O
int	O
xs	int
,	O
xe	int
;	O
if	O
(	O
line	array
+	O
vp	pointer
->	O
v_yoff	int
>=	O
vp	pointer
->	O
v_ys	int
&&	O
line	array
+	O
vp	pointer
->	O
v_yoff	int
<=	O
vp	pointer
->	O
v_ye	int
&&	O
(	O
(	O
xs	int
=	O
layer	struct
->	O
l_pause	struct
.	O
left	pointer
[	O
line	array
]	O
)	O
>=	O
0	int
)	O
&&	O
(	O
(	O
xe	int
=	O
layer	struct
->	O
l_pause	struct
.	O
right	pointer
[	O
line	array
]	O
)	O
>=	O
0	int
)	O
)	O
{	O
xs	int
+=	O
vp	pointer
->	O
v_xoff	int
;	O
xe	int
+=	O
vp	pointer
->	O
v_xoff	int
;	O
if	O
(	O
xs	int
<	O
vp	pointer
->	O
v_xs	int
)	O
xs	int
=	O
vp	pointer
->	O
v_xs	int
;	O
if	O
(	O
xe	int
>	O
vp	pointer
->	O
v_xe	int
)	O
xe	int
=	O
vp	pointer
->	O
v_xe	int
;	O
if	O
(	O
layer	struct
->	O
l_encoding	int
==	O
UTF8	int
&&	O
xe	int
<	O
vp	pointer
->	O
v_xe	int
&&	O
win	struct
)	O
{	O
struct	O
mline	struct
*	O
ml	pointer
=	O
win	struct
->	O
w_mlines	pointer
+	O
line	array
;	O
if	O
(	O
dw_left	O
(	O
ml	pointer
,	O
xe	int
,	O
UTF8	int
)	O
)	O
xe	int
++	O
;	O
}	O
if	O
(	O
xs	int
<=	O
xe	int
)	O
RefreshLine	function
(	O
line	array
+	O
vp	pointer
->	O
v_yoff	int
,	O
xs	int
,	O
xe	int
,	O
0	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
cv	pointer
==	O
D_forecv	O
)	O
{	O
int	O
cx	int
=	O
layer	struct
->	O
l_x	int
+	O
cv	pointer
->	O
c_xoff	int
;	O
int	O
cy	int
=	O
layer	struct
->	O
l_y	int
+	O
cv	pointer
->	O
c_yoff	int
;	O
if	O
(	O
cx	int
<	O
cv	pointer
->	O
c_xs	int
)	O
cx	int
=	O
cv	pointer
->	O
c_xs	int
;	O
if	O
(	O
cy	int
<	O
cv	pointer
->	O
c_ys	int
)	O
cy	int
=	O
cv	pointer
->	O
c_ys	int
;	O
if	O
(	O
cx	int
>	O
cv	pointer
->	O
c_xe	int
)	O
cx	int
=	O
cv	pointer
->	O
c_xe	int
;	O
if	O
(	O
cy	int
>	O
cv	pointer
->	O
c_ye	int
)	O
cy	int
=	O
cv	pointer
->	O
c_ye	int
;	O
GotoPos	function
(	O
cx	int
,	O
cy	int
)	O
;	O
}	O
}	O
for	O
(	O
line	array
=	O
layer	struct
->	O
l_pause	struct
.	O
top	int
;	O
line	array
<=	O
layer	struct
->	O
l_pause	struct
.	O
bottom	int
;	O
line	array
++	O
)	O
layer	struct
->	O
l_pause	struct
.	O
left	pointer
[	O
line	array
]	O
=	O
layer	struct
->	O
l_pause	struct
.	O
right	pointer
[	O
line	array
]	O
=	O
-	O
1	int
;	O
}	O
void	O
LayPauseUpdateRegion	function
(	O
struct	O
layer	struct
*	O
layer	struct
,	O
int	O
xs	int
,	O
int	O
xe	int
,	O
int	O
ys	int
,	O
int	O
ye	int
)	O
{	O
if	O
(	O
!	O
layer	struct
->	O
l_pause	struct
.	O
d	int
)	O
return	O
;	O
if	O
(	O
ys	int
<	O
0	int
)	O
ys	int
=	O
0	int
;	O
if	O
(	O
ye	int
>=	O
layer	struct
->	O
l_height	int
)	O
ye	int
=	O
layer	struct
->	O
l_height	int
-	O
1	int
;	O
if	O
(	O
xe	int
>=	O
layer	struct
->	O
l_width	int
)	O
xe	int
=	O
layer	struct
->	O
l_width	int
-	O
1	int
;	O
if	O
(	O
layer	struct
->	O
l_pause	struct
.	O
top	int
==	O
-	O
1	int
||	O
layer	struct
->	O
l_pause	struct
.	O
top	int
>	O
ys	int
)	O
layer	struct
->	O
l_pause	struct
.	O
top	int
=	O
ys	int
;	O
if	O
(	O
layer	struct
->	O
l_pause	struct
.	O
bottom	int
<	O
ye	int
)	O
{	O
layer	struct
->	O
l_pause	struct
.	O
bottom	int
=	O
ye	int
;	O
if	O
(	O
layer	struct
->	O
l_pause	struct
.	O
lines	int
<=	O
ye	int
)	O
{	O
int	O
o	int
=	O
layer	struct
->	O
l_pause	struct
.	O
lines	int
;	O
layer	struct
->	O
l_pause	struct
.	O
lines	int
=	O
ye	int
+	O
32	int
;	O
layer	struct
->	O
l_pause	struct
.	O
left	pointer
=	O
realloc	function
(	O
layer	struct
->	O
l_pause	struct
.	O
left	pointer
,	O
sizeof	O
(	O
int	O
)	O
*	O
layer	struct
->	O
l_pause	struct
.	O
lines	int
)	O
;	O
layer	struct
->	O
l_pause	struct
.	O
right	pointer
=	O
realloc	function
(	O
layer	struct
->	O
l_pause	struct
.	O
right	pointer
,	O
sizeof	O
(	O
int	O
)	O
*	O
layer	struct
->	O
l_pause	struct
.	O
lines	int
)	O
;	O
while	O
(	O
o	int
<	O
layer	struct
->	O
l_pause	struct
.	O
lines	int
)	O
{	O
layer	struct
->	O
l_pause	struct
.	O
left	pointer
[	O
o	int
]	O
=	O
layer	struct
->	O
l_pause	struct
.	O
right	pointer
[	O
o	int
]	O
=	O
-	O
1	int
;	O
o	int
++	O
;	O
}	O
}	O
}	O
while	O
(	O
ys	int
<=	O
ye	int
)	O
{	O
if	O
(	O
layer	struct
->	O
l_pause	struct
.	O
left	pointer
[	O
ys	int
]	O
==	O
-	O
1	int
||	O
layer	struct
->	O
l_pause	struct
.	O
left	pointer
[	O
ys	int
]	O
>	O
xs	int
)	O
layer	struct
->	O
l_pause	struct
.	O
left	pointer
[	O
ys	int
]	O
=	O
xs	int
;	O
if	O
(	O
layer	struct
->	O
l_pause	struct
.	O
right	pointer
[	O
ys	int
]	O
<	O
xe	int
)	O
layer	struct
->	O
l_pause	struct
.	O
right	pointer
[	O
ys	int
]	O
=	O
xe	int
;	O
ys	int
++	O
;	O
}	O
}	O
void	O
LayerCleanupMemory	function
(	O
struct	O
layer	struct
*	O
layer	struct
)	O
{	O
if	O
(	O
layer	struct
->	O
l_pause	struct
.	O
left	pointer
)	O
free	function
(	O
layer	struct
->	O
l_pause	struct
.	O
left	pointer
)	O
;	O
if	O
(	O
layer	struct
->	O
l_pause	struct
.	O
right	pointer
)	O
free	function
(	O
layer	struct
->	O
l_pause	struct
.	O
right	pointer
)	O
;	O
}	O
