int	O
dfa_verbose	int
=	O
0	int
;	O
static	O
dfa_t	struct
aux_dfa	array
[	O
DFA_BINS	int
]	O
;	O
static	O
dfa_t	struct
aux_temp	struct
;	O
static	O
int	O
dfa_was_initialized	int
=	O
0	int
;	O
static	O
int	O
aux_count	int
=	O
0	int
;	O
static	O
const	O
char	O
att2val	array
[	O
8	int
]	O
=	O
{	O
'.'	O
,	O
'X'	O
,	O
'O'	O
,	O
'x'	O
,	O
'o'	O
,	O
','	O
,	O
'a'	O
,	O
'!'	O
}	O
;	O
static	O
void	O
clean_dfa	function
(	O
dfa_t	struct
*	O
pdfa	pointer
)	O
;	O
static	O
void	O
resize_dfa	function
(	O
dfa_t	struct
*	O
pdfa	pointer
,	O
int	O
max_states	int
,	O
int	O
max_indexes	int
)	O
;	O
static	O
void	O
create_dfa	function
(	O
dfa_t	struct
*	O
pdfa	pointer
,	O
const	O
char	O
*	O
str	int
,	O
int	O
att_val	int
)	O
;	O
static	O
void	O
do_sync_product	function
(	O
int	O
l	int
,	O
int	O
r	int
)	O
;	O
static	O
void	O
sync_product	function
(	O
dfa_t	struct
*	O
pout	pointer
,	O
dfa_t	struct
*	O
pleft	pointer
,	O
dfa_t	struct
*	O
pright	pointer
)	O
;	O
static	O
void	O
dfa_prepare_rotation_data	function
(	O
void	O
)	O
;	O
static	O
int	O
member_att	function
(	O
dfa_t	struct
*	O
pdfa	pointer
,	O
int	O
att	char
,	O
int	O
val	long
)	O
{	O
while	O
(	O
att	char
!=	O
0	int
)	O
{	O
if	O
(	O
pdfa	pointer
->	O
indexes	pointer
[	O
att	char
]	O
.	O
val	long
==	O
val	long
)	O
return	O
1	int
;	O
att	char
=	O
pdfa	pointer
->	O
indexes	pointer
[	O
att	char
]	O
.	O
next	pointer
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
union_att	function
(	O
dfa_t	struct
*	O
pdfa	pointer
,	O
dfa_t	struct
*	O
pdfa1	pointer
,	O
int	O
att1	int
,	O
dfa_t	struct
*	O
pdfa2	pointer
,	O
int	O
att2	int
)	O
{	O
int	O
att	char
;	O
int	O
att_aux	int
;	O
att	char
=	O
0	int
;	O
while	O
(	O
att1	int
!=	O
0	int
)	O
{	O
pdfa	pointer
->	O
last_index	int
++	O
;	O
if	O
(	O
pdfa	pointer
->	O
last_index	int
>=	O
pdfa	pointer
->	O
max_indexes	int
)	O
resize_dfa	function
(	O
pdfa	pointer
,	O
pdfa	pointer
->	O
max_states	int
,	O
pdfa	pointer
->	O
max_indexes	int
+	O
DFA_RESIZE_STEP	int
)	O
;	O
att_aux	int
=	O
pdfa	pointer
->	O
last_index	int
;	O
pdfa	pointer
->	O
indexes	pointer
[	O
att_aux	int
]	O
.	O
val	long
=	O
pdfa1	pointer
->	O
indexes	pointer
[	O
att1	int
]	O
.	O
val	long
;	O
pdfa	pointer
->	O
indexes	pointer
[	O
att_aux	int
]	O
.	O
next	pointer
=	O
att	char
;	O
att	char
=	O
att_aux	int
;	O
att1	int
=	O
pdfa1	pointer
->	O
indexes	pointer
[	O
att1	int
]	O
.	O
next	pointer
;	O
}	O
while	O
(	O
att2	int
!=	O
0	int
)	O
{	O
if	O
(	O
!	O
member_att	function
(	O
pdfa	pointer
,	O
att	char
,	O
pdfa2	pointer
->	O
indexes	pointer
[	O
att2	int
]	O
.	O
val	long
)	O
)	O
{	O
pdfa	pointer
->	O
last_index	int
++	O
;	O
if	O
(	O
pdfa	pointer
->	O
last_index	int
>=	O
pdfa	pointer
->	O
max_indexes	int
)	O
resize_dfa	function
(	O
pdfa	pointer
,	O
pdfa	pointer
->	O
max_states	int
,	O
pdfa	pointer
->	O
max_indexes	int
+	O
DFA_RESIZE_STEP	int
)	O
;	O
att_aux	int
=	O
pdfa	pointer
->	O
last_index	int
;	O
pdfa	pointer
->	O
indexes	pointer
[	O
att_aux	int
]	O
.	O
val	long
=	O
pdfa2	pointer
->	O
indexes	pointer
[	O
att2	int
]	O
.	O
val	long
;	O
pdfa	pointer
->	O
indexes	pointer
[	O
att_aux	int
]	O
.	O
next	pointer
=	O
att	char
;	O
att	char
=	O
att_aux	int
;	O
}	O
att2	int
=	O
pdfa2	pointer
->	O
indexes	pointer
[	O
att2	int
]	O
.	O
next	pointer
;	O
}	O
return	O
att	char
;	O
}	O
static	O
void	O
compactify_att	function
(	O
dfa_t	struct
*	O
pdfa	pointer
)	O
{	O
int	O
k	int
;	O
int	O
last	pointer
=	O
0	int
;	O
int	O
save_last	int
=	O
pdfa	pointer
->	O
last_index	int
;	O
int	O
*	O
map	pointer
;	O
int	O
*	O
search_first	pointer
;	O
int	O
*	O
search_next	pointer
;	O
int	O
size	int
=	O
(	O
save_last	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
int	O
)	O
;	O
map	pointer
=	O
malloc	function
(	O
size	int
)	O
;	O
map	pointer
[	O
0	int
]	O
=	O
0	int
;	O
search_first	pointer
=	O
malloc	function
(	O
size	int
)	O
;	O
memset	function
(	O
search_first	pointer
,	O
0	int
,	O
size	int
)	O
;	O
search_next	pointer
=	O
malloc	function
(	O
size	int
)	O
;	O
memset	function
(	O
search_next	pointer
,	O
0	int
,	O
size	int
)	O
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<=	O
save_last	int
;	O
k	int
++	O
)	O
{	O
int	O
i	int
=	O
search_first	pointer
[	O
pdfa	pointer
->	O
indexes	pointer
[	O
k	int
]	O
.	O
val	long
]	O
;	O
if	O
(	O
i	int
)	O
{	O
while	O
(	O
pdfa	pointer
->	O
indexes	pointer
[	O
i	int
]	O
.	O
next	pointer
!=	O
pdfa	pointer
->	O
indexes	pointer
[	O
k	int
]	O
.	O
next	pointer
)	O
{	O
if	O
(	O
!	O
search_next	pointer
[	O
i	int
]	O
)	O
{	O
search_next	pointer
[	O
i	int
]	O
=	O
++	O
last	pointer
;	O
i	int
=	O
0	int
;	O
break	O
;	O
}	O
i	int
=	O
search_next	pointer
[	O
i	int
]	O
;	O
}	O
}	O
else	O
search_first	pointer
[	O
pdfa	pointer
->	O
indexes	pointer
[	O
k	int
]	O
.	O
val	long
]	O
=	O
++	O
last	pointer
;	O
if	O
(	O
i	int
)	O
map	pointer
[	O
k	int
]	O
=	O
i	int
;	O
else	O
{	O
map	pointer
[	O
k	int
]	O
=	O
last	pointer
;	O
pdfa	pointer
->	O
indexes	pointer
[	O
last	pointer
]	O
=	O
pdfa	pointer
->	O
indexes	pointer
[	O
k	int
]	O
;	O
}	O
}	O
free	function
(	O
search_first	pointer
)	O
;	O
free	function
(	O
search_next	pointer
)	O
;	O
if	O
(	O
last	pointer
<	O
save_last	int
)	O
{	O
pdfa	pointer
->	O
last_index	int
=	O
last	pointer
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<=	O
pdfa	pointer
->	O
last_index	int
;	O
k	int
++	O
)	O
pdfa	pointer
->	O
indexes	pointer
[	O
k	int
]	O
.	O
next	pointer
=	O
map	pointer
[	O
pdfa	pointer
->	O
indexes	pointer
[	O
k	int
]	O
.	O
next	pointer
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<=	O
pdfa	pointer
->	O
last_state	int
;	O
k	int
++	O
)	O
pdfa	pointer
->	O
states	pointer
[	O
k	int
]	O
.	O
att	char
=	O
map	pointer
[	O
pdfa	pointer
->	O
states	pointer
[	O
k	int
]	O
.	O
att	char
]	O
;	O
if	O
(	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"compactified: %d attributes left of %d\n"	pointer
,	O
last	pointer
,	O
save_last	int
)	O
;	O
compactify_att	function
(	O
pdfa	pointer
)	O
;	O
}	O
free	function
(	O
map	pointer
)	O
;	O
}	O
int	O
dfa_size	function
(	O
dfa_t	struct
*	O
pdfa	pointer
)	O
{	O
int	O
states_size	int
,	O
indexes_size	int
;	O
states_size	int
=	O
(	O
pdfa	pointer
->	O
last_state	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
state_rt_t	struct
)	O
;	O
indexes_size	int
=	O
(	O
pdfa	pointer
->	O
last_index	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
attrib_rt_t	struct
)	O
;	O
return	O
(	O
states_size	int
+	O
indexes_size	int
+	O
sizeof	O
(	O
dfa_rt_t	struct
)	O
)	O
/	O
1024	int
;	O
}	O
static	O
void	O
resize_dfa	function
(	O
dfa_t	struct
*	O
pdfa	pointer
,	O
int	O
max_states	int
,	O
int	O
max_indexes	int
)	O
{	O
state_t	struct
*	O
pBuf	pointer
;	O
attrib_t	struct
*	O
pBuf2	pointer
;	O
int	O
i	int
;	O
if	O
(	O
dfa_verbose	int
>	O
1	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"Resizing dfa %s\n"	pointer
,	O
pdfa	pointer
->	O
name	short
)	O
;	O
assert	O
(	O
pdfa	pointer
->	O
last_state	int
<=	O
pdfa	pointer
->	O
max_states	int
)	O
;	O
assert	O
(	O
pdfa	pointer
->	O
last_index	int
<=	O
pdfa	pointer
->	O
max_indexes	int
)	O
;	O
pBuf	pointer
=	O
realloc	function
(	O
pdfa	pointer
->	O
states	pointer
,	O
max_states	int
*	O
sizeof	O
(	O
*	O
pBuf	pointer
)	O
)	O
;	O
pBuf2	pointer
=	O
realloc	function
(	O
pdfa	pointer
->	O
indexes	pointer
,	O
max_indexes	int
*	O
sizeof	O
(	O
*	O
pBuf2	pointer
)	O
)	O
;	O
if	O
(	O
pBuf	pointer
==	O
NULL	O
||	O
pBuf2	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"No memory left for dfa: %s"	pointer
,	O
pdfa	pointer
->	O
name	short
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
for	O
(	O
i	int
=	O
pdfa	pointer
->	O
max_states	int
;	O
i	int
<	O
max_states	int
;	O
i	int
++	O
)	O
memset	function
(	O
pBuf	pointer
+	O
i	int
,	O
0	int
,	O
sizeof	O
(	O
state_t	struct
)	O
)	O
;	O
for	O
(	O
i	int
=	O
pdfa	pointer
->	O
max_indexes	int
;	O
i	int
<	O
max_indexes	int
;	O
i	int
++	O
)	O
memset	function
(	O
pBuf2	pointer
+	O
i	int
,	O
0	int
,	O
sizeof	O
(	O
attrib_t	struct
)	O
)	O
;	O
pdfa	pointer
->	O
states	pointer
=	O
pBuf	pointer
;	O
pdfa	pointer
->	O
max_states	int
=	O
max_states	int
;	O
pdfa	pointer
->	O
indexes	pointer
=	O
pBuf2	pointer
;	O
pdfa	pointer
->	O
max_indexes	int
=	O
max_indexes	int
;	O
}	O
static	O
const	O
char	O
*	O
line	int
=	O
"----------------------------------------------------\n"	pointer
;	O
void	O
dump_dfa	function
(	O
FILE	struct
*	O
f	pointer
,	O
dfa_t	struct
*	O
pdfa	pointer
)	O
{	O
int	O
i	int
;	O
int	O
att	char
,	O
k	int
;	O
fprintf	function
(	O
f	pointer
,	O
line	int
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
" name : %s\n"	pointer
,	O
pdfa	pointer
->	O
name	short
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
" Nb states :  %7d, max= %d\n"	pointer
,	O
pdfa	pointer
->	O
last_state	int
+	O
1	int
,	O
pdfa	pointer
->	O
max_states	int
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
" Nb Indexes : %7d, max= %d\n"	pointer
,	O
pdfa	pointer
->	O
last_index	int
,	O
pdfa	pointer
->	O
max_indexes	int
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
" memory needed : %d Mb\n"	pointer
,	O
dfa_size	function
(	O
pdfa	pointer
)	O
/	O
1024	int
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
line	int
)	O
;	O
if	O
(	O
dfa_size	function
(	O
pdfa	pointer
)	O
>	O
10000	int
)	O
return	O
;	O
fprintf	function
(	O
f	pointer
,	O
" state  |   .    |   O    |   X    |   #    |  att \n"	pointer
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
line	int
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
!=	O
pdfa	pointer
->	O
last_state	int
+	O
1	int
;	O
i	int
++	O
)	O
{	O
int	O
*	O
pnext	pointer
=	O
pdfa	pointer
->	O
states	pointer
[	O
i	int
]	O
.	O
next	pointer
;	O
fprintf	function
(	O
f	pointer
,	O
" %6d |"	pointer
,	O
i	int
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
" %6d | %6d | %6d |"	pointer
,	O
pnext	pointer
[	O
0	int
]	O
,	O
pnext	pointer
[	O
1	int
]	O
,	O
pnext	pointer
[	O
2	int
]	O
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
" %6d |"	pointer
,	O
pnext	pointer
[	O
OUT_BOARD	int
]	O
)	O
;	O
att	char
=	O
pdfa	pointer
->	O
states	pointer
[	O
i	int
]	O
.	O
att	char
;	O
k	int
=	O
0	int
;	O
fprintf	function
(	O
f	pointer
,	O
" %5d:"	pointer
,	O
att	char
)	O
;	O
while	O
(	O
att	char
!=	O
0	int
&&	O
k	int
<	O
10	int
)	O
{	O
fprintf	function
(	O
f	pointer
,	O
" %4d"	pointer
,	O
pdfa	pointer
->	O
indexes	pointer
[	O
att	char
]	O
.	O
val	long
)	O
;	O
att	char
=	O
pdfa	pointer
->	O
indexes	pointer
[	O
att	char
]	O
.	O
next	pointer
;	O
k	int
++	O
;	O
}	O
if	O
(	O
att	char
!=	O
0	int
)	O
fprintf	function
(	O
f	pointer
,	O
" ..."	pointer
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
fprintf	function
(	O
f	pointer
,	O
line	int
)	O
;	O
fflush	function
(	O
f	pointer
)	O
;	O
}	O
static	O
void	O
clean_dfa	function
(	O
dfa_t	struct
*	O
pdfa	pointer
)	O
{	O
memset	function
(	O
pdfa	pointer
->	O
states	pointer
,	O
0	int
,	O
pdfa	pointer
->	O
max_states	int
*	O
sizeof	O
(	O
state_t	struct
)	O
)	O
;	O
memset	function
(	O
pdfa	pointer
->	O
indexes	pointer
,	O
0	int
,	O
pdfa	pointer
->	O
max_indexes	int
*	O
sizeof	O
(	O
attrib_t	struct
)	O
)	O
;	O
pdfa	pointer
->	O
last_state	int
=	O
1	int
;	O
pdfa	pointer
->	O
last_index	int
=	O
0	int
;	O
pdfa	pointer
->	O
indexes	pointer
[	O
0	int
]	O
.	O
val	long
=	O
-	O
1	int
;	O
}	O
void	O
new_dfa	function
(	O
dfa_t	struct
*	O
pdfa	pointer
,	O
const	O
char	O
*	O
name	short
)	O
{	O
memset	function
(	O
pdfa	pointer
,	O
0	int
,	O
sizeof	O
(	O
dfa_t	struct
)	O
)	O
;	O
resize_dfa	function
(	O
pdfa	pointer
,	O
DFA_INIT_SIZE	int
,	O
DFA_INIT_SIZE	int
)	O
;	O
clean_dfa	function
(	O
pdfa	pointer
)	O
;	O
if	O
(	O
name	short
!=	O
NULL	O
)	O
strcpy	function
(	O
pdfa	pointer
->	O
name	short
,	O
name	short
)	O
;	O
else	O
strcpy	function
(	O
pdfa	pointer
->	O
name	short
,	O
"noname "	pointer
)	O
;	O
if	O
(	O
dfa_verbose	int
>	O
1	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"dfa %s is born :)\n"	pointer
,	O
pdfa	pointer
->	O
name	short
)	O
;	O
}	O
void	O
kill_dfa	function
(	O
dfa_t	struct
*	O
pdfa	pointer
)	O
{	O
free	function
(	O
pdfa	pointer
->	O
states	pointer
)	O
;	O
free	function
(	O
pdfa	pointer
->	O
indexes	pointer
)	O
;	O
if	O
(	O
dfa_verbose	int
>	O
1	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"dfa %s is dead :(\n"	pointer
,	O
pdfa	pointer
->	O
name	short
)	O
;	O
memset	function
(	O
pdfa	pointer
,	O
0	int
,	O
sizeof	O
(	O
dfa_t	struct
)	O
)	O
;	O
}	O
void	O
copy_dfa	function
(	O
dfa_t	struct
*	O
p_to	pointer
,	O
dfa_t	struct
*	O
p_from	pointer
)	O
{	O
assert	O
(	O
p_to	pointer
!=	O
p_from	pointer
)	O
;	O
if	O
(	O
p_to	pointer
->	O
max_states	int
<	O
p_from	pointer
->	O
last_state	int
)	O
resize_dfa	function
(	O
p_to	pointer
,	O
p_from	pointer
->	O
max_states	int
,	O
p_to	pointer
->	O
max_indexes	int
)	O
;	O
if	O
(	O
p_to	pointer
->	O
max_indexes	int
<	O
p_from	pointer
->	O
last_index	int
)	O
resize_dfa	function
(	O
p_to	pointer
,	O
p_to	pointer
->	O
max_states	int
,	O
p_from	pointer
->	O
max_indexes	int
)	O
;	O
clean_dfa	function
(	O
p_to	pointer
)	O
;	O
memcpy	function
(	O
p_to	pointer
->	O
states	pointer
,	O
p_from	pointer
->	O
states	pointer
,	O
sizeof	O
(	O
state_t	struct
)	O
*	O
(	O
p_from	pointer
->	O
last_state	int
+	O
1	int
)	O
)	O
;	O
memcpy	function
(	O
p_to	pointer
->	O
indexes	pointer
,	O
p_from	pointer
->	O
indexes	pointer
,	O
sizeof	O
(	O
attrib_t	struct
)	O
*	O
(	O
p_from	pointer
->	O
last_index	int
+	O
1	int
)	O
)	O
;	O
p_to	pointer
->	O
last_state	int
=	O
p_from	pointer
->	O
last_state	int
;	O
p_to	pointer
->	O
last_index	int
=	O
p_from	pointer
->	O
last_index	int
;	O
}	O
void	O
print_c_dfa	function
(	O
FILE	struct
*	O
of	pointer
,	O
const	O
char	O
*	O
name	short
,	O
dfa_t	struct
*	O
pdfa	pointer
)	O
{	O
int	O
i	int
;	O
if	O
(	O
sizeof	O
(	O
unsigned	O
short	O
)	O
<	O
2	int
)	O
{	O
fprintf	function
(	O
of	pointer
,	O
"#error shorts too short"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Error: shorts are expected to be at least 2 bytes long.\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
assert	O
(	O
dfa_minmax_delta	function
(	O
pdfa	pointer
,	O
-	O
1	int
,	O
1	int
)	O
>	O
-	O
32768	int
)	O
;	O
if	O
(	O
dfa_minmax_delta	function
(	O
pdfa	pointer
,	O
-	O
1	int
,	O
0	int
)	O
>	O
32768	int
)	O
{	O
fprintf	function
(	O
of	pointer
,	O
"#error too many states"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Error: The dfa states are too disperse. Can't fit delta into a short.\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
pdfa	pointer
->	O
last_index	int
+	O
1	int
>	O
65535	int
)	O
{	O
fprintf	function
(	O
of	pointer
,	O
"#error too many states"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Error: Too many index entries. Can't fit delta into a short.\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
fprintf	function
(	O
of	pointer
,	O
"\n#include \"dfa-mkpat.h\"\n"	pointer
)	O
;	O
fprintf	function
(	O
of	pointer
,	O
"static const state_rt_t state_%s[%d] = {\n"	pointer
,	O
name	short
,	O
pdfa	pointer
->	O
last_state	int
+	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
!=	O
pdfa	pointer
->	O
last_state	int
+	O
1	int
;	O
i	int
++	O
)	O
{	O
int	O
j	int
;	O
fprintf	function
(	O
of	pointer
,	O
"{{"	pointer
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
4	int
;	O
j	int
++	O
)	O
{	O
int	O
n	int
=	O
pdfa	pointer
->	O
states	pointer
[	O
i	int
]	O
.	O
next	pointer
[	O
j	int
]	O
;	O
assert	O
(	O
(	O
n	int
==	O
0	int
)	O
||	O
(	O
abs	function
(	O
n	int
-	O
i	int
)	O
<	O
32768	int
)	O
)	O
;	O
fprintf	function
(	O
of	pointer
,	O
"%d"	pointer
,	O
n	int
?	O
n	int
-	O
i	int
:	O
0	int
)	O
;	O
if	O
(	O
j	int
!=	O
3	int
)	O
fprintf	function
(	O
of	pointer
,	O
","	pointer
)	O
;	O
}	O
fprintf	function
(	O
of	pointer
,	O
"}, %d},%s"	pointer
,	O
pdfa	pointer
->	O
states	pointer
[	O
i	int
]	O
.	O
att	char
,	O
(	O
(	O
i	int
+	O
1	int
)	O
%	O
3	int
?	O
"\t"	pointer
:	O
"\n"	pointer
)	O
)	O
;	O
}	O
fprintf	function
(	O
of	pointer
,	O
"};\n\n"	pointer
)	O
;	O
fprintf	function
(	O
of	pointer
,	O
"static const attrib_rt_t idx_%s[%d] = {\n"	pointer
,	O
name	short
,	O
pdfa	pointer
->	O
last_index	int
+	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
!=	O
pdfa	pointer
->	O
last_index	int
+	O
1	int
;	O
i	int
++	O
)	O
fprintf	function
(	O
of	pointer
,	O
"{%d,%d},%s"	pointer
,	O
pdfa	pointer
->	O
indexes	pointer
[	O
i	int
]	O
.	O
val	long
,	O
pdfa	pointer
->	O
indexes	pointer
[	O
i	int
]	O
.	O
next	pointer
,	O
(	O
(	O
i	int
+	O
1	int
)	O
%	O
4	int
?	O
"\t"	pointer
:	O
"\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
of	pointer
,	O
"};\n\n"	pointer
)	O
;	O
fprintf	function
(	O
of	pointer
,	O
"static dfa_rt_t dfa_%s = {\n"	pointer
,	O
name	short
)	O
;	O
fprintf	function
(	O
of	pointer
,	O
" \"%s\",\n"	pointer
,	O
name	short
)	O
;	O
fprintf	function
(	O
of	pointer
,	O
"state_%s,\n"	pointer
,	O
name	short
)	O
;	O
fprintf	function
(	O
of	pointer
,	O
"idx_%s"	pointer
,	O
name	short
)	O
;	O
fprintf	function
(	O
of	pointer
,	O
"};\n"	pointer
)	O
;	O
}	O
static	O
void	O
create_dfa	function
(	O
dfa_t	struct
*	O
pdfa	pointer
,	O
const	O
char	O
*	O
str	int
,	O
int	O
att_val	int
)	O
{	O
int	O
new_state	int
;	O
if	O
(	O
dfa_verbose	int
>	O
1	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"linear dfa in %s with string: %s\n"	pointer
,	O
pdfa	pointer
->	O
name	short
,	O
str	int
)	O
;	O
assert	O
(	O
str	int
!=	O
NULL	O
)	O
;	O
assert	O
(	O
pdfa	pointer
->	O
max_states	int
>	O
1	int
)	O
;	O
assert	O
(	O
pdfa	pointer
->	O
max_indexes	int
>	O
1	int
)	O
;	O
clean_dfa	function
(	O
pdfa	pointer
)	O
;	O
new_state	int
=	O
1	int
;	O
for	O
(	O
;	O
*	O
str	int
!=	O
'\0'	O
&&	O
strchr	function
(	O
"$#+-|OoXx.?,!a*"	pointer
,	O
*	O
str	int
)	O
;	O
str	int
++	O
)	O
{	O
memset	function
(	O
pdfa	pointer
->	O
states	pointer
[	O
new_state	int
]	O
.	O
next	pointer
,	O
0	int
,	O
4	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
if	O
(	O
strchr	function
(	O
"$?.ox,a!*"	pointer
,	O
*	O
str	int
)	O
)	O
pdfa	pointer
->	O
states	pointer
[	O
new_state	int
]	O
.	O
next	pointer
[	O
0	int
]	O
=	O
new_state	int
+	O
1	int
;	O
if	O
(	O
strchr	function
(	O
"$?Oo"	pointer
,	O
*	O
str	int
)	O
)	O
pdfa	pointer
->	O
states	pointer
[	O
new_state	int
]	O
.	O
next	pointer
[	O
1	int
]	O
=	O
new_state	int
+	O
1	int
;	O
if	O
(	O
strchr	function
(	O
"$?Xx"	pointer
,	O
*	O
str	int
)	O
)	O
pdfa	pointer
->	O
states	pointer
[	O
new_state	int
]	O
.	O
next	pointer
[	O
2	int
]	O
=	O
new_state	int
+	O
1	int
;	O
if	O
(	O
strchr	function
(	O
"$#+-|"	pointer
,	O
*	O
str	int
)	O
)	O
pdfa	pointer
->	O
states	pointer
[	O
new_state	int
]	O
.	O
next	pointer
[	O
OUT_BOARD	int
]	O
=	O
new_state	int
+	O
1	int
;	O
new_state	int
++	O
;	O
if	O
(	O
new_state	int
>=	O
pdfa	pointer
->	O
max_states	int
)	O
resize_dfa	function
(	O
pdfa	pointer
,	O
pdfa	pointer
->	O
max_states	int
+	O
DFA_RESIZE_STEP	int
,	O
pdfa	pointer
->	O
max_indexes	int
)	O
;	O
}	O
memset	function
(	O
pdfa	pointer
->	O
states	pointer
[	O
new_state	int
]	O
.	O
next	pointer
,	O
0	int
,	O
4	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
pdfa	pointer
->	O
last_index	int
++	O
;	O
if	O
(	O
pdfa	pointer
->	O
last_index	int
>=	O
pdfa	pointer
->	O
max_indexes	int
)	O
resize_dfa	function
(	O
pdfa	pointer
,	O
pdfa	pointer
->	O
max_states	int
,	O
pdfa	pointer
->	O
max_indexes	int
+	O
DFA_RESIZE_STEP	int
)	O
;	O
memset	function
(	O
&	O
(	O
pdfa	pointer
->	O
indexes	pointer
[	O
pdfa	pointer
->	O
last_index	int
]	O
)	O
,	O
0	int
,	O
sizeof	O
(	O
attrib_t	struct
)	O
)	O
;	O
pdfa	pointer
->	O
states	pointer
[	O
new_state	int
]	O
.	O
att	char
=	O
pdfa	pointer
->	O
last_index	int
;	O
pdfa	pointer
->	O
indexes	pointer
[	O
pdfa	pointer
->	O
states	pointer
[	O
new_state	int
]	O
.	O
att	char
]	O
.	O
val	long
=	O
att_val	int
;	O
pdfa	pointer
->	O
indexes	pointer
[	O
pdfa	pointer
->	O
states	pointer
[	O
new_state	int
]	O
.	O
att	char
]	O
.	O
next	pointer
=	O
0	int
;	O
pdfa	pointer
->	O
last_state	int
=	O
new_state	int
;	O
}	O
typedef	O
struct	O
entry	array
{	O
int	O
l	int
,	O
r	int
;	O
int	O
val	long
;	O
struct	O
entry	array
*	O
pnext	pointer
;	O
}	O
entry_t	struct
;	O
typedef	O
struct	O
test_array	struct
{	O
entry_t	struct
*	O
hash	array
[	O
MAX_HASH_VALUE	int
]	O
;	O
}	O
test_array_t	struct
;	O
static	O
void	O
new_test_array	function
(	O
test_array_t	struct
*	O
pta	pointer
)	O
{	O
int	O
h	int
;	O
for	O
(	O
h	int
=	O
0	int
;	O
h	int
!=	O
MAX_HASH_VALUE	int
;	O
h	int
++	O
)	O
pta	pointer
->	O
hash	array
[	O
h	int
]	O
=	O
NULL	O
;	O
}	O
static	O
int	O
get_from_entry_list	function
(	O
entry_t	struct
*	O
plist	pointer
,	O
int	O
l	int
,	O
int	O
r	int
)	O
{	O
int	O
val	long
=	O
0	int
;	O
while	O
(	O
plist	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
plist	pointer
->	O
l	int
==	O
l	int
&&	O
plist	pointer
->	O
r	int
==	O
r	int
)	O
val	long
=	O
plist	pointer
->	O
val	long
;	O
plist	pointer
=	O
plist	pointer
->	O
pnext	pointer
;	O
}	O
return	O
val	long
;	O
}	O
static	O
int	O
get_from_test_array	function
(	O
test_array_t	struct
*	O
pta	pointer
,	O
int	O
l	int
,	O
int	O
r	int
)	O
{	O
return	O
get_from_entry_list	function
(	O
pta	pointer
->	O
hash	array
[	O
(	O
l	int
+	O
r	int
)	O
%	O
MAX_HASH_VALUE	int
]	O
,	O
l	int
,	O
r	int
)	O
;	O
}	O
static	O
void	O
add_to_entry_list	function
(	O
entry_t	struct
*	O
*	O
pplist	pointer
,	O
int	O
l	int
,	O
int	O
r	int
,	O
int	O
val	long
)	O
{	O
entry_t	struct
*	O
new_entry	pointer
;	O
assert	O
(	O
val	long
>	O
0	int
)	O
;	O
assert	O
(	O
!	O
get_from_entry_list	function
(	O
*	O
pplist	pointer
,	O
l	int
,	O
r	int
)	O
)	O
;	O
new_entry	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
*	O
new_entry	pointer
)	O
)	O
;	O
if	O
(	O
new_entry	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"No memory left for new entry\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
new_entry	pointer
->	O
pnext	pointer
=	O
*	O
pplist	pointer
;	O
new_entry	pointer
->	O
l	int
=	O
l	int
;	O
new_entry	pointer
->	O
r	int
=	O
r	int
;	O
new_entry	pointer
->	O
val	long
=	O
val	long
;	O
*	O
pplist	pointer
=	O
new_entry	pointer
;	O
}	O
static	O
void	O
add_to_test_array	function
(	O
test_array_t	struct
*	O
pta	pointer
,	O
int	O
l	int
,	O
int	O
r	int
,	O
int	O
val	long
)	O
{	O
add_to_entry_list	function
(	O
&	O
(	O
pta	pointer
->	O
hash	array
[	O
(	O
l	int
+	O
r	int
)	O
%	O
MAX_HASH_VALUE	int
]	O
)	O
,	O
l	int
,	O
r	int
,	O
val	long
)	O
;	O
}	O
static	O
void	O
free_entry_list	function
(	O
entry_t	struct
*	O
plist	pointer
)	O
{	O
entry_t	struct
*	O
pentry	pointer
;	O
while	O
(	O
plist	pointer
!=	O
NULL	O
)	O
{	O
pentry	pointer
=	O
plist	pointer
;	O
plist	pointer
=	O
plist	pointer
->	O
pnext	pointer
;	O
free	function
(	O
pentry	pointer
)	O
;	O
}	O
}	O
static	O
void	O
free_test_array	function
(	O
test_array_t	struct
*	O
pta	pointer
)	O
{	O
int	O
h	int
;	O
for	O
(	O
h	int
=	O
0	int
;	O
h	int
!=	O
MAX_HASH_VALUE	int
;	O
h	int
++	O
)	O
{	O
free_entry_list	function
(	O
pta	pointer
->	O
hash	array
[	O
h	int
]	O
)	O
;	O
pta	pointer
->	O
hash	array
[	O
h	int
]	O
=	O
NULL	O
;	O
}	O
}	O
static	O
dfa_t	struct
*	O
gpout	pointer
,	O
*	O
gpleft	pointer
,	O
*	O
gpright	pointer
;	O
static	O
test_array_t	struct
gtest	struct
;	O
static	O
void	O
do_sync_product	function
(	O
int	O
l	int
,	O
int	O
r	int
)	O
{	O
int	O
c	char
;	O
int	O
nextl	int
,	O
nextr	int
;	O
int	O
state	pointer
;	O
state	pointer
=	O
gpout	pointer
->	O
last_state	int
;	O
gpout	pointer
->	O
states	pointer
[	O
state	pointer
]	O
.	O
att	char
=	O
union_att	function
(	O
gpout	pointer
,	O
gpleft	pointer
,	O
gpleft	pointer
->	O
states	pointer
[	O
l	int
]	O
.	O
att	char
,	O
gpright	pointer
,	O
gpright	pointer
->	O
states	pointer
[	O
r	int
]	O
.	O
att	char
)	O
;	O
for	O
(	O
c	char
=	O
0	int
;	O
c	char
!=	O
4	int
;	O
c	char
++	O
)	O
{	O
nextl	int
=	O
gpleft	pointer
->	O
states	pointer
[	O
l	int
]	O
.	O
next	pointer
[	O
c	char
]	O
;	O
nextr	int
=	O
gpright	pointer
->	O
states	pointer
[	O
r	int
]	O
.	O
next	pointer
[	O
c	char
]	O
;	O
assert	O
(	O
nextl	int
<	O
gpleft	pointer
->	O
last_state	int
+	O
1	int
)	O
;	O
assert	O
(	O
nextr	int
<	O
gpright	pointer
->	O
last_state	int
+	O
1	int
)	O
;	O
if	O
(	O
nextl	int
!=	O
0	int
||	O
nextr	int
!=	O
0	int
)	O
{	O
if	O
(	O
get_from_test_array	function
(	O
&	O
gtest	struct
,	O
nextl	int
,	O
nextr	int
)	O
==	O
0	int
)	O
{	O
gpout	pointer
->	O
last_state	int
++	O
;	O
if	O
(	O
gpout	pointer
->	O
last_state	int
>=	O
gpout	pointer
->	O
max_states	int
)	O
resize_dfa	function
(	O
gpout	pointer
,	O
gpout	pointer
->	O
max_states	int
+	O
DFA_RESIZE_STEP	int
,	O
gpout	pointer
->	O
max_indexes	int
)	O
;	O
add_to_test_array	function
(	O
&	O
gtest	struct
,	O
nextl	int
,	O
nextr	int
,	O
gpout	pointer
->	O
last_state	int
)	O
;	O
gpout	pointer
->	O
states	pointer
[	O
state	pointer
]	O
.	O
next	pointer
[	O
c	char
]	O
=	O
gpout	pointer
->	O
last_state	int
;	O
do_sync_product	function
(	O
nextl	int
,	O
nextr	int
)	O
;	O
}	O
else	O
{	O
gpout	pointer
->	O
states	pointer
[	O
state	pointer
]	O
.	O
next	pointer
[	O
c	char
]	O
=	O
get_from_test_array	function
(	O
&	O
gtest	struct
,	O
nextl	int
,	O
nextr	int
)	O
;	O
}	O
}	O
else	O
{	O
gpout	pointer
->	O
states	pointer
[	O
state	pointer
]	O
.	O
next	pointer
[	O
c	char
]	O
=	O
0	int
;	O
}	O
}	O
}	O
static	O
void	O
sync_product	function
(	O
dfa_t	struct
*	O
pout	pointer
,	O
dfa_t	struct
*	O
pleft	pointer
,	O
dfa_t	struct
*	O
pright	pointer
)	O
{	O
pout	pointer
->	O
last_index	int
=	O
0	int
;	O
if	O
(	O
dfa_verbose	int
>	O
2	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Product between %s and %s\n"	pointer
,	O
pleft	pointer
->	O
name	short
,	O
pright	pointer
->	O
name	short
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"result in %s\n"	pointer
,	O
pout	pointer
->	O
name	short
)	O
;	O
}	O
gpout	pointer
=	O
pout	pointer
;	O
gpleft	pointer
=	O
pleft	pointer
;	O
gpright	pointer
=	O
pright	pointer
;	O
new_test_array	function
(	O
&	O
gtest	struct
)	O
;	O
add_to_test_array	function
(	O
&	O
gtest	struct
,	O
1	int
,	O
1	int
,	O
1	int
)	O
;	O
pout	pointer
->	O
last_state	int
=	O
1	int
;	O
do_sync_product	function
(	O
1	int
,	O
1	int
)	O
;	O
free_test_array	function
(	O
&	O
gtest	struct
)	O
;	O
}	O
void	O
dfa_init	function
(	O
void	O
)	O
{	O
int	O
j	int
;	O
if	O
(	O
dfa_verbose	int
>	O
1	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"dfa: init\n"	pointer
)	O
;	O
dfa_was_initialized	int
++	O
;	O
build_spiral_order	function
(	O
)	O
;	O
dfa_prepare_rotation_data	function
(	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
DFA_BINS	int
;	O
j	int
++	O
)	O
new_dfa	function
(	O
&	O
(	O
aux_dfa	array
[	O
j	int
]	O
)	O
,	O
"binAux "	pointer
)	O
;	O
new_dfa	function
(	O
&	O
aux_temp	struct
,	O
"tempAux "	pointer
)	O
;	O
}	O
void	O
dfa_end	function
(	O
void	O
)	O
{	O
int	O
j	int
;	O
if	O
(	O
dfa_verbose	int
>	O
1	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"dfa: end\n"	pointer
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
DFA_BINS	int
;	O
j	int
++	O
)	O
kill_dfa	function
(	O
&	O
(	O
aux_dfa	array
[	O
j	int
]	O
)	O
)	O
;	O
kill_dfa	function
(	O
&	O
aux_temp	struct
)	O
;	O
dfa_was_initialized	int
--	O
;	O
}	O
int	O
dfa_minmax_delta	function
(	O
dfa_t	struct
*	O
pdfa	pointer
,	O
int	O
next_index	int
,	O
int	O
isMin	int
)	O
{	O
int	O
ret	int
,	O
i	int
,	O
j	int
;	O
assert	O
(	O
next_index	int
<=	O
3	int
)	O
;	O
if	O
(	O
isMin	int
)	O
ret	int
=	O
99999	int
;	O
else	O
ret	int
=	O
-	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
pdfa	pointer
->	O
last_state	int
;	O
i	int
++	O
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
4	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
j	int
==	O
next_index	int
||	O
next_index	int
<	O
0	int
)	O
{	O
int	O
next	pointer
=	O
pdfa	pointer
->	O
states	pointer
[	O
i	int
]	O
.	O
next	pointer
[	O
j	int
]	O
;	O
if	O
(	O
!	O
next	pointer
)	O
continue	O
;	O
if	O
(	O
isMin	int
)	O
{	O
if	O
(	O
ret	int
>	O
next	pointer
-	O
i	int
)	O
ret	int
=	O
next	pointer
-	O
i	int
;	O
}	O
else	O
{	O
if	O
(	O
ret	int
<	O
next	pointer
-	O
i	int
)	O
ret	int
=	O
next	pointer
-	O
i	int
;	O
}	O
}	O
}	O
}	O
return	O
ret	int
;	O
}	O
void	O
dfa_shuffle	function
(	O
dfa_t	struct
*	O
pdfa	pointer
)	O
{	O
struct	O
state	pointer
*	O
old_states	pointer
;	O
int	O
*	O
state_to	pointer
;	O
int	O
*	O
state_from	pointer
;	O
int	O
*	O
queue1	pointer
;	O
int	O
*	O
queue2	pointer
;	O
int	O
*	O
tempq	pointer
;	O
int	O
next_new_state	int
;	O
int	O
q1p	int
;	O
int	O
q2p	int
;	O
int	O
i	int
,	O
j	int
;	O
state_to	pointer
=	O
calloc	function
(	O
pdfa	pointer
->	O
last_state	int
+	O
1	int
,	O
sizeof	O
(	O
*	O
state_to	pointer
)	O
)	O
;	O
state_from	pointer
=	O
calloc	function
(	O
pdfa	pointer
->	O
last_state	int
+	O
1	int
,	O
sizeof	O
(	O
*	O
state_from	pointer
)	O
)	O
;	O
queue1	pointer
=	O
malloc	function
(	O
(	O
pdfa	pointer
->	O
last_state	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
*	O
queue1	pointer
)	O
)	O
;	O
queue2	pointer
=	O
malloc	function
(	O
(	O
pdfa	pointer
->	O
last_state	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
*	O
queue2	pointer
)	O
)	O
;	O
q1p	int
=	O
1	int
;	O
q2p	int
=	O
0	int
;	O
queue1	pointer
[	O
0	int
]	O
=	O
1	int
;	O
state_from	pointer
[	O
0	int
]	O
=	O
state_to	pointer
[	O
0	int
]	O
=	O
0	int
;	O
state_from	pointer
[	O
1	int
]	O
=	O
state_to	pointer
[	O
1	int
]	O
=	O
1	int
;	O
next_new_state	int
=	O
2	int
;	O
while	O
(	O
q1p	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
q1p	int
;	O
i	int
++	O
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
4	int
;	O
j	int
++	O
)	O
{	O
int	O
n	int
=	O
pdfa	pointer
->	O
states	pointer
[	O
queue1	pointer
[	O
i	int
]	O
]	O
.	O
next	pointer
[	O
j	int
]	O
;	O
while	O
(	O
n	int
&&	O
!	O
state_to	pointer
[	O
n	int
]	O
)	O
{	O
state_to	pointer
[	O
n	int
]	O
=	O
next_new_state	int
;	O
state_from	pointer
[	O
next_new_state	int
]	O
=	O
n	int
;	O
next_new_state	int
++	O
;	O
queue2	pointer
[	O
q2p	int
++	O
]	O
=	O
n	int
;	O
n	int
=	O
pdfa	pointer
->	O
states	pointer
[	O
n	int
]	O
.	O
next	pointer
[	O
0	int
]	O
;	O
}	O
}	O
}	O
tempq	pointer
=	O
queue1	pointer
;	O
queue1	pointer
=	O
queue2	pointer
;	O
queue2	pointer
=	O
tempq	pointer
;	O
q1p	int
=	O
q2p	int
;	O
q2p	int
=	O
0	int
;	O
}	O
old_states	pointer
=	O
malloc	function
(	O
(	O
pdfa	pointer
->	O
last_state	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
*	O
old_states	pointer
)	O
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
pdfa	pointer
->	O
last_state	int
;	O
i	int
++	O
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
4	int
;	O
j	int
++	O
)	O
{	O
old_states	pointer
[	O
i	int
]	O
.	O
next	pointer
[	O
j	int
]	O
=	O
pdfa	pointer
->	O
states	pointer
[	O
i	int
]	O
.	O
next	pointer
[	O
j	int
]	O
;	O
old_states	pointer
[	O
i	int
]	O
.	O
att	char
=	O
pdfa	pointer
->	O
states	pointer
[	O
i	int
]	O
.	O
att	char
;	O
}	O
}	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
pdfa	pointer
->	O
last_state	int
;	O
i	int
++	O
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
4	int
;	O
j	int
++	O
)	O
{	O
assert	O
(	O
state_to	pointer
[	O
i	int
]	O
>	O
0	int
)	O
;	O
pdfa	pointer
->	O
states	pointer
[	O
i	int
]	O
.	O
next	pointer
[	O
j	int
]	O
=	O
state_to	pointer
[	O
old_states	pointer
[	O
state_from	pointer
[	O
i	int
]	O
]	O
.	O
next	pointer
[	O
j	int
]	O
]	O
;	O
}	O
pdfa	pointer
->	O
states	pointer
[	O
i	int
]	O
.	O
att	char
=	O
old_states	pointer
[	O
state_from	pointer
[	O
i	int
]	O
]	O
.	O
att	char
;	O
}	O
}	O
int	O
dfa_calculate_max_matched_patterns	function
(	O
dfa_t	struct
*	O
pdfa	pointer
)	O
{	O
int	O
total_max	int
=	O
0	int
;	O
int	O
*	O
state_max	pointer
=	O
calloc	function
(	O
pdfa	pointer
->	O
last_state	int
+	O
1	int
,	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
char	O
*	O
queued	pointer
=	O
calloc	function
(	O
pdfa	pointer
->	O
last_state	int
+	O
1	int
,	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
int	O
*	O
queue	pointer
=	O
malloc	function
(	O
pdfa	pointer
->	O
last_state	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
int	O
queue_start	int
=	O
0	int
;	O
int	O
queue_end	int
=	O
1	int
;	O
queue	pointer
[	O
0	int
]	O
=	O
1	int
;	O
while	O
(	O
queue_start	int
<	O
queue_end	int
)	O
{	O
int	O
state	pointer
=	O
queue	pointer
[	O
queue_start	int
++	O
]	O
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
pdfa	pointer
->	O
states	pointer
[	O
state	pointer
]	O
.	O
att	char
;	O
k	int
;	O
k	int
=	O
pdfa	pointer
->	O
indexes	pointer
[	O
k	int
]	O
.	O
next	pointer
)	O
state_max	pointer
[	O
state	pointer
]	O
++	O
;	O
if	O
(	O
total_max	int
<	O
state_max	pointer
[	O
state	pointer
]	O
)	O
total_max	int
=	O
state_max	pointer
[	O
state	pointer
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
next	pointer
=	O
pdfa	pointer
->	O
states	pointer
[	O
state	pointer
]	O
.	O
next	pointer
[	O
k	int
]	O
;	O
if	O
(	O
next	pointer
!=	O
0	int
)	O
{	O
if	O
(	O
!	O
queued	pointer
[	O
next	pointer
]	O
)	O
{	O
queue	pointer
[	O
queue_end	int
++	O
]	O
=	O
next	pointer
;	O
queued	pointer
[	O
next	pointer
]	O
=	O
1	int
;	O
}	O
if	O
(	O
state_max	pointer
[	O
next	pointer
]	O
<	O
state_max	pointer
[	O
state	pointer
]	O
)	O
state_max	pointer
[	O
next	pointer
]	O
=	O
state_max	pointer
[	O
state	pointer
]	O
;	O
}	O
}	O
}	O
assert	O
(	O
queue_end	int
==	O
pdfa	pointer
->	O
last_state	int
)	O
;	O
free	function
(	O
state_max	pointer
)	O
;	O
free	function
(	O
queued	pointer
)	O
;	O
free	function
(	O
queue	pointer
)	O
;	O
return	O
total_max	int
;	O
}	O
void	O
dfa_finalize	function
(	O
dfa_t	struct
*	O
pdfa	pointer
)	O
{	O
int	O
j	int
;	O
int	O
next_bin	int
=	O
aux_count	int
;	O
int	O
last_bin	int
=	O
aux_count	int
+	O
DFA_BINS	int
-	O
1	int
;	O
while	O
(	O
next_bin	int
+	O
1	int
!=	O
last_bin	int
)	O
{	O
for	O
(	O
j	int
=	O
aux_count	int
+	O
1	int
;	O
j	int
<=	O
last_bin	int
;	O
j	int
+=	O
2	int
)	O
{	O
if	O
(	O
j	int
+	O
1	int
==	O
next_bin	int
)	O
copy_dfa	function
(	O
&	O
aux_dfa	array
[	O
next_bin	int
%	O
DFA_BINS	int
]	O
,	O
&	O
aux_dfa	array
[	O
j	int
%	O
DFA_BINS	int
]	O
)	O
;	O
else	O
sync_product	function
(	O
&	O
aux_dfa	array
[	O
next_bin	int
%	O
DFA_BINS	int
]	O
,	O
&	O
aux_dfa	array
[	O
j	int
%	O
DFA_BINS	int
]	O
,	O
&	O
aux_dfa	array
[	O
(	O
j	int
+	O
1	int
)	O
%	O
DFA_BINS	int
]	O
)	O
;	O
next_bin	int
++	O
;	O
}	O
last_bin	int
=	O
next_bin	int
-	O
1	int
;	O
aux_count	int
--	O
;	O
next_bin	int
=	O
aux_count	int
;	O
}	O
copy_dfa	function
(	O
pdfa	pointer
,	O
&	O
aux_dfa	array
[	O
last_bin	int
%	O
DFA_BINS	int
]	O
)	O
;	O
compactify_att	function
(	O
pdfa	pointer
)	O
;	O
}	O
float	O
dfa_add_string	function
(	O
dfa_t	struct
*	O
pdfa	pointer
,	O
const	O
char	O
*	O
str	int
,	O
int	O
pattern_index	int
,	O
int	O
ll	int
)	O
{	O
dfa_t	struct
*	O
new_dfa	function
=	O
&	O
(	O
aux_dfa	array
[	O
aux_count	int
%	O
DFA_BINS	int
]	O
)	O
;	O
dfa_t	struct
*	O
old_dfa	pointer
=	O
&	O
(	O
aux_dfa	array
[	O
(	O
aux_count	int
+	O
1	int
)	O
%	O
DFA_BINS	int
]	O
)	O
;	O
float	O
ratio	float
;	O
if	O
(	O
dfa_verbose	int
>	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Adding to dfa %s the string: %s\n"	pointer
,	O
pdfa	pointer
->	O
name	short
,	O
str	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"  pat_ind: %d; rotation: %d at bin: %d\n"	pointer
,	O
pattern_index	int
,	O
ll	int
,	O
aux_count	int
)	O
;	O
}	O
assert	O
(	O
dfa_was_initialized	int
>	O
0	int
)	O
;	O
assert	O
(	O
pdfa	pointer
!=	O
NULL	O
)	O
;	O
create_dfa	function
(	O
&	O
aux_temp	struct
,	O
str	int
,	O
pattern_index	int
)	O
;	O
sync_product	function
(	O
new_dfa	function
,	O
old_dfa	pointer
,	O
&	O
aux_temp	struct
)	O
;	O
aux_count	int
++	O
;	O
ratio	float
=	O
1	int
;	O
if	O
(	O
dfa_size	function
(	O
old_dfa	pointer
)	O
>	O
0	int
)	O
ratio	float
=	O
(	O
float	O
)	O
(	O
dfa_size	function
(	O
new_dfa	function
)	O
/	O
dfa_size	function
(	O
old_dfa	pointer
)	O
)	O
;	O
return	O
ratio	float
;	O
}	O
static	O
int	O
dfa_rotation_data	array
[	O
DFA_BASE	O
*	O
DFA_BASE	O
]	O
;	O
static	O
void	O
dfa_prepare_rotation_data	function
(	O
void	O
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
DFA_MAX_ORDER	O
;	O
k	int
++	O
)	O
dfa_rotation_data	array
[	O
DFA_POS	O
(	O
0	int
,	O
0	int
)	O
+	O
spiral	array
[	O
k	int
]	O
[	O
0	int
]	O
]	O
=	O
k	int
;	O
}	O
void	O
dfa_rotate_string	function
(	O
char	O
*	O
rotated_string	pointer
,	O
const	O
char	O
*	O
string	int
,	O
int	O
transformation	array
)	O
{	O
if	O
(	O
transformation	array
>	O
0	int
)	O
{	O
int	O
k	int
;	O
int	O
length	int
=	O
strlen	function
(	O
string	int
)	O
;	O
int	O
new_length	int
=	O
0	int
;	O
memset	function
(	O
rotated_string	pointer
,	O
'$'	O
,	O
DFA_MAX_ORDER	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
length	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
string	int
[	O
k	int
]	O
!=	O
'$'	O
)	O
{	O
int	O
string_position	int
=	O
dfa_rotation_data	array
[	O
DFA_POS	O
(	O
0	int
,	O
0	int
)	O
+	O
spiral	array
[	O
k	int
]	O
[	O
transformation	array
]	O
]	O
;	O
rotated_string	pointer
[	O
string_position	int
]	O
=	O
string	int
[	O
k	int
]	O
;	O
if	O
(	O
string_position	int
+	O
1	int
>	O
new_length	int
)	O
new_length	int
=	O
string_position	int
+	O
1	int
;	O
}	O
}	O
rotated_string	pointer
[	O
new_length	int
]	O
=	O
0	int
;	O
}	O
else	O
strcpy	function
(	O
rotated_string	pointer
,	O
string	int
)	O
;	O
}	O
void	O
pattern_2_string	function
(	O
struct	O
pattern	pointer
*	O
pat	pointer
,	O
struct	O
patval_b	struct
*	O
elements	pointer
,	O
char	O
*	O
str	int
,	O
int	O
ci	int
,	O
int	O
cj	int
)	O
{	O
char	O
work_space	array
[	O
DFA_MAX_BOARD	O
*	O
4	int
]	O
[	O
DFA_MAX_BOARD	O
*	O
4	int
]	O
;	O
int	O
m	int
,	O
n	int
;	O
int	O
edges	int
,	O
borders	int
,	O
to_test	int
;	O
int	O
i	int
,	O
j	int
,	O
k	int
;	O
char	O
c	char
;	O
m	int
=	O
DFA_MAX_BOARD	O
*	O
2	int
+	O
ci	int
;	O
n	int
=	O
DFA_MAX_BOARD	O
*	O
2	int
+	O
cj	int
;	O
assert	O
(	O
dfa_was_initialized	int
)	O
;	O
memset	function
(	O
str	int
,	O
0	int
,	O
DFA_MAX_ORDER	O
)	O
;	O
memset	function
(	O
work_space	array
,	O
'#'	O
,	O
sizeof	O
(	O
work_space	array
)	O
)	O
;	O
if	O
(	O
dfa_verbose	int
>	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"converting pattern into string.\n"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
DFA_MAX_BOARD	O
;	O
i	int
!=	O
DFA_MAX_BOARD	O
*	O
3	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
DFA_MAX_BOARD	O
;	O
j	int
!=	O
DFA_MAX_BOARD	O
*	O
3	int
;	O
j	int
++	O
)	O
work_space	array
[	O
i	int
]	O
[	O
j	int
]	O
=	O
'$'	O
;	O
for	O
(	O
i	int
=	O
pat	pointer
->	O
mini	int
+	O
m	int
;	O
i	int
!=	O
pat	pointer
->	O
maxi	int
+	O
m	int
+	O
1	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
pat	pointer
->	O
minj	int
+	O
n	int
;	O
j	int
!=	O
pat	pointer
->	O
maxj	int
+	O
n	int
+	O
1	int
;	O
j	int
++	O
)	O
work_space	array
[	O
i	int
]	O
[	O
j	int
]	O
=	O
'?'	O
;	O
if	O
(	O
pat	pointer
->	O
edge_constraints	int
&	O
SOUTH_EDGE	int
)	O
{	O
for	O
(	O
i	int
=	O
m	int
+	O
pat	pointer
->	O
maxi	int
+	O
1	int
;	O
i	int
!=	O
DFA_MAX_BOARD	O
*	O
3	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
!=	O
DFA_MAX_BOARD	O
*	O
3	int
;	O
j	int
++	O
)	O
work_space	array
[	O
i	int
]	O
[	O
j	int
]	O
=	O
'-'	O
;	O
}	O
if	O
(	O
pat	pointer
->	O
edge_constraints	int
&	O
EAST_EDGE	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
!=	O
DFA_MAX_BOARD	O
*	O
3	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
n	int
+	O
pat	pointer
->	O
maxj	int
+	O
1	int
;	O
j	int
!=	O
DFA_MAX_BOARD	O
*	O
3	int
;	O
j	int
++	O
)	O
work_space	array
[	O
i	int
]	O
[	O
j	int
]	O
=	O
'|'	O
;	O
}	O
if	O
(	O
pat	pointer
->	O
edge_constraints	int
&	O
NORTH_EDGE	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
!=	O
m	int
+	O
pat	pointer
->	O
mini	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
!=	O
DFA_MAX_BOARD	O
*	O
4	int
;	O
j	int
++	O
)	O
work_space	array
[	O
i	int
]	O
[	O
j	int
]	O
=	O
'-'	O
;	O
}	O
if	O
(	O
pat	pointer
->	O
edge_constraints	int
&	O
WEST_EDGE	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
!=	O
m	int
+	O
pat	pointer
->	O
maxi	int
+	O
1	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
!=	O
n	int
+	O
pat	pointer
->	O
minj	int
;	O
j	int
++	O
)	O
work_space	array
[	O
i	int
]	O
[	O
j	int
]	O
=	O
'|'	O
;	O
if	O
(	O
!	O
(	O
pat	pointer
->	O
edge_constraints	int
&	O
SOUTH_EDGE	int
)	O
)	O
{	O
for	O
(	O
i	int
=	O
m	int
+	O
pat	pointer
->	O
maxi	int
+	O
1	int
;	O
i	int
!=	O
DFA_MAX_BOARD	O
*	O
3	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
!=	O
n	int
+	O
pat	pointer
->	O
minj	int
;	O
j	int
++	O
)	O
work_space	array
[	O
i	int
]	O
[	O
j	int
]	O
=	O
'|'	O
;	O
}	O
}	O
if	O
(	O
dfa_verbose	int
>	O
4	int
)	O
{	O
for	O
(	O
i	int
=	O
DFA_MAX_BOARD	O
-	O
1	int
;	O
i	int
!=	O
DFA_MAX_BOARD	O
*	O
3	int
+	O
1	int
;	O
i	int
++	O
)	O
{	O
for	O
(	O
j	int
=	O
DFA_MAX_BOARD	O
-	O
1	int
;	O
j	int
!=	O
DFA_MAX_BOARD	O
*	O
3	int
+	O
1	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
i	int
==	O
m	int
&&	O
j	int
==	O
n	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"s"	pointer
)	O
;	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
"%c"	pointer
,	O
work_space	array
[	O
i	int
]	O
[	O
j	int
]	O
)	O
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
!=	O
pat	pointer
->	O
patlen	int
;	O
k	int
++	O
)	O
{	O
c	char
=	O
EXPECTED_VAL	O
(	O
elements	pointer
[	O
k	int
]	O
.	O
att	char
)	O
;	O
assert	O
(	O
work_space	array
[	O
m	int
+	O
elements	pointer
[	O
k	int
]	O
.	O
x	int
-	O
ci	int
]	O
[	O
n	int
+	O
elements	pointer
[	O
k	int
]	O
.	O
y	int
-	O
cj	int
]	O
==	O
'?'	O
)	O
;	O
work_space	array
[	O
m	int
+	O
elements	pointer
[	O
k	int
]	O
.	O
x	int
-	O
ci	int
]	O
[	O
n	int
+	O
elements	pointer
[	O
k	int
]	O
.	O
y	int
-	O
cj	int
]	O
=	O
c	char
;	O
}	O
if	O
(	O
dfa_verbose	int
>	O
3	int
)	O
{	O
for	O
(	O
i	int
=	O
DFA_MAX_BOARD	O
-	O
1	int
;	O
i	int
!=	O
DFA_MAX_BOARD	O
*	O
3	int
+	O
1	int
;	O
i	int
++	O
)	O
{	O
for	O
(	O
j	int
=	O
DFA_MAX_BOARD	O
-	O
1	int
;	O
j	int
!=	O
DFA_MAX_BOARD	O
*	O
3	int
+	O
1	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
i	int
==	O
m	int
&&	O
j	int
==	O
n	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"s"	pointer
)	O
;	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
"%c"	pointer
,	O
work_space	array
[	O
i	int
]	O
[	O
j	int
]	O
)	O
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
to_test	int
=	O
pat	pointer
->	O
patlen	int
;	O
edges	int
=	O
pat	pointer
->	O
edge_constraints	int
;	O
borders	int
=	O
0xF	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
(	O
k	int
!=	O
DFA_MAX_ORDER	O
-	O
1	int
)	O
&&	O
(	O
(	O
borders	int
>	O
0	int
)	O
||	O
edges	int
||	O
to_test	int
>	O
0	int
)	O
;	O
k	int
++	O
)	O
{	O
j	int
=	O
spiral	array
[	O
k	int
]	O
[	O
0	int
]	O
%	O
DFA_BASE	O
;	O
if	O
(	O
j	int
>=	O
DFA_MAX_BOARD	O
)	O
j	int
-=	O
DFA_BASE	O
;	O
if	O
(	O
j	int
<=	O
-	O
DFA_MAX_BOARD	O
)	O
j	int
+=	O
DFA_BASE	O
;	O
i	int
=	O
(	O
spiral	array
[	O
k	int
]	O
[	O
0	int
]	O
-	O
j	int
)	O
/	O
DFA_BASE	O
;	O
if	O
(	O
i	int
==	O
pat	pointer
->	O
maxi	int
)	O
borders	int
&=	O
~	O
SOUTH_EDGE	int
;	O
if	O
(	O
i	int
==	O
pat	pointer
->	O
mini	int
)	O
borders	int
&=	O
~	O
NORTH_EDGE	int
;	O
if	O
(	O
j	int
==	O
pat	pointer
->	O
maxj	int
)	O
borders	int
&=	O
~	O
EAST_EDGE	int
;	O
if	O
(	O
j	int
==	O
pat	pointer
->	O
minj	int
)	O
borders	int
&=	O
~	O
WEST_EDGE	int
;	O
assert	O
(	O
m	int
+	O
i	int
<	O
DFA_MAX_BOARD	O
*	O
3	int
&&	O
m	int
+	O
i	int
<	O
DFA_MAX_BOARD	O
*	O
3	int
)	O
;	O
str	int
[	O
k	int
]	O
=	O
work_space	array
[	O
m	int
+	O
i	int
]	O
[	O
n	int
+	O
j	int
]	O
;	O
assert	O
(	O
strchr	function
(	O
"XOxo.,a!?$#|-+"	pointer
,	O
str	int
[	O
k	int
]	O
)	O
)	O
;	O
if	O
(	O
strchr	function
(	O
"XOxo.,a!"	pointer
,	O
str	int
[	O
k	int
]	O
)	O
)	O
to_test	int
--	O
;	O
if	O
(	O
strchr	function
(	O
"#|-+"	pointer
,	O
str	int
[	O
k	int
]	O
)	O
)	O
{	O
if	O
(	O
i	int
>	O
pat	pointer
->	O
maxi	int
)	O
edges	int
&=	O
~	O
SOUTH_EDGE	int
;	O
if	O
(	O
i	int
<	O
pat	pointer
->	O
mini	int
)	O
edges	int
&=	O
~	O
NORTH_EDGE	int
;	O
if	O
(	O
j	int
>	O
pat	pointer
->	O
maxj	int
)	O
edges	int
&=	O
~	O
EAST_EDGE	int
;	O
if	O
(	O
j	int
<	O
pat	pointer
->	O
minj	int
)	O
edges	int
&=	O
~	O
WEST_EDGE	int
;	O
}	O
}	O
assert	O
(	O
k	int
<	O
DFA_MAX_ORDER	O
)	O
;	O
str	int
[	O
k	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
0	int
&&	O
dfa_verbose	int
>	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"converted pattern %s into string: %s\n"	pointer
,	O
pat	pointer
->	O
name	short
,	O
str	int
)	O
;	O
}	O
static	O
dfa_attrib	struct
*	O
dfa_attrib_new	function
(	O
dfa_attrib_array	struct
*	O
array	pointer
,	O
int	O
string_index	int
)	O
{	O
dfa_attrib	struct
*	O
attribute	pointer
;	O
if	O
(	O
array	pointer
->	O
allocated	int
==	O
DFA_ATTRIB_BLOCK_SIZE	int
)	O
{	O
dfa_attrib_block	struct
*	O
new_block	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
*	O
new_block	pointer
)	O
)	O
;	O
assert	O
(	O
new_block	pointer
)	O
;	O
new_block	pointer
->	O
previous	pointer
=	O
array	pointer
->	O
last_block	pointer
;	O
array	pointer
->	O
last_block	pointer
=	O
new_block	pointer
;	O
array	pointer
->	O
allocated	int
=	O
0	int
;	O
}	O
attribute	pointer
=	O
&	O
(	O
array	pointer
->	O
last_block	pointer
->	O
attrib	struct
[	O
array	pointer
->	O
allocated	int
++	O
]	O
)	O
;	O
attribute	pointer
->	O
next	pointer
=	O
NULL	O
;	O
attribute	pointer
->	O
string_index	int
=	O
string_index	int
;	O
return	O
attribute	pointer
;	O
}	O
static	O
void	O
dfa_attrib_array_reset	function
(	O
dfa_attrib_array	struct
*	O
array	pointer
)	O
{	O
array	pointer
->	O
last_block	pointer
=	O
NULL	O
;	O
array	pointer
->	O
allocated	int
=	O
DFA_ATTRIB_BLOCK_SIZE	int
;	O
}	O
static	O
void	O
dfa_attrib_array_partially_clear	function
(	O
dfa_attrib_block	struct
*	O
cutoff_point	pointer
)	O
{	O
if	O
(	O
cutoff_point	pointer
)	O
{	O
dfa_attrib_block	struct
*	O
block	pointer
=	O
cutoff_point	pointer
->	O
previous	pointer
;	O
while	O
(	O
block	pointer
)	O
{	O
dfa_attrib_block	struct
*	O
previous	pointer
=	O
block	pointer
->	O
previous	pointer
;	O
free	function
(	O
block	pointer
)	O
;	O
block	pointer
=	O
previous	pointer
;	O
}	O
cutoff_point	pointer
->	O
previous	pointer
=	O
NULL	O
;	O
}	O
}	O
static	O
void	O
dfa_attrib_array_clear	function
(	O
dfa_attrib_array	struct
*	O
array	pointer
)	O
{	O
if	O
(	O
array	pointer
->	O
last_block	pointer
)	O
{	O
dfa_attrib_array_partially_clear	function
(	O
array	pointer
->	O
last_block	pointer
)	O
;	O
free	function
(	O
array	pointer
->	O
last_block	pointer
)	O
;	O
array	pointer
->	O
last_block	pointer
=	O
NULL	O
;	O
}	O
array	pointer
->	O
allocated	int
=	O
DFA_ATTRIB_BLOCK_SIZE	int
;	O
}	O
static	O
dfa_node	struct
*	O
dfa_node_new	function
(	O
dfa_graph	struct
*	O
graph	struct
)	O
{	O
dfa_node	struct
*	O
node	pointer
;	O
if	O
(	O
graph	struct
->	O
allocated	int
==	O
DFA_NODE_BLOCK_SIZE	int
)	O
{	O
dfa_node_block	struct
*	O
new_block	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
*	O
new_block	pointer
)	O
)	O
;	O
assert	O
(	O
new_block	pointer
)	O
;	O
new_block	pointer
->	O
previous	pointer
=	O
graph	struct
->	O
last_block	pointer
;	O
graph	struct
->	O
last_block	pointer
=	O
new_block	pointer
;	O
graph	struct
->	O
allocated	int
=	O
0	int
;	O
}	O
graph	struct
->	O
num_nodes	int
++	O
;	O
node	pointer
=	O
&	O
(	O
graph	struct
->	O
last_block	pointer
->	O
node	pointer
[	O
graph	struct
->	O
allocated	int
++	O
]	O
)	O
;	O
memset	function
(	O
node	pointer
,	O
0	int
,	O
sizeof	O
(	O
dfa_node	struct
)	O
)	O
;	O
return	O
node	pointer
;	O
}	O
static	O
dfa_hash_entry	struct
*	O
dfa_hash_table	array
[	O
DFA_HASH_TABLE_SIZE	int
]	O
;	O
static	O
dfa_hash_block	struct
*	O
dfa_hash_last_block	pointer
=	O
NULL	O
;	O
static	O
int	O
dfa_hash_allocated	int
;	O
static	O
dfa_hash_entry	struct
*	O
dfa_hash_entry_new	function
(	O
void	O
)	O
{	O
if	O
(	O
dfa_hash_allocated	int
==	O
DFA_HASH_BLOCK_SIZE	int
)	O
{	O
dfa_hash_block	struct
*	O
new_block	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
*	O
new_block	pointer
)	O
)	O
;	O
assert	O
(	O
new_block	pointer
)	O
;	O
new_block	pointer
->	O
previous	pointer
=	O
dfa_hash_last_block	pointer
;	O
dfa_hash_last_block	pointer
=	O
new_block	pointer
;	O
dfa_hash_allocated	int
=	O
0	int
;	O
}	O
return	O
&	O
(	O
dfa_hash_last_block	pointer
->	O
entry	array
[	O
dfa_hash_allocated	int
++	O
]	O
)	O
;	O
}	O
static	O
void	O
dfa_hash_clear	function
(	O
void	O
)	O
{	O
memset	function
(	O
dfa_hash_table	array
,	O
0	int
,	O
DFA_HASH_TABLE_SIZE	int
*	O
sizeof	O
(	O
dfa_hash_entry	struct
*	O
)	O
)	O
;	O
if	O
(	O
dfa_hash_last_block	pointer
)	O
{	O
dfa_hash_block	struct
*	O
block	pointer
=	O
dfa_hash_last_block	pointer
->	O
previous	pointer
;	O
while	O
(	O
block	pointer
)	O
{	O
dfa_hash_block	struct
*	O
previous	pointer
=	O
block	pointer
->	O
previous	pointer
;	O
free	function
(	O
block	pointer
)	O
;	O
block	pointer
=	O
previous	pointer
;	O
}	O
dfa_hash_last_block	pointer
->	O
previous	pointer
=	O
NULL	O
;	O
dfa_hash_allocated	int
=	O
0	int
;	O
}	O
else	O
dfa_hash_allocated	int
=	O
DFA_HASH_BLOCK_SIZE	int
;	O
}	O
static	O
int	O
dfa_hash_value	function
(	O
dfa_attrib	struct
*	O
key	pointer
)	O
{	O
int	O
hash_value	int
=	O
DFA_HASH_VALUE_1	int
*	O
key	pointer
->	O
string_index	int
;	O
if	O
(	O
key	pointer
->	O
next	pointer
)	O
{	O
hash_value	int
+=	O
DFA_HASH_VALUE_2	int
*	O
key	pointer
->	O
next	pointer
->	O
string_index	int
;	O
if	O
(	O
key	pointer
->	O
next	pointer
->	O
next	pointer
)	O
hash_value	int
+=	O
DFA_HASH_VALUE_3	int
*	O
key	pointer
->	O
next	pointer
->	O
next	pointer
->	O
string_index	int
;	O
}	O
return	O
hash_value	int
%	O
DFA_HASH_TABLE_SIZE	int
;	O
}	O
static	O
dfa_node	struct
*	O
dfa_hash_search	function
(	O
dfa_attrib	struct
*	O
key	pointer
)	O
{	O
int	O
hash_value	int
=	O
dfa_hash_value	function
(	O
key	pointer
)	O
;	O
dfa_hash_entry	struct
*	O
entry	array
;	O
for	O
(	O
entry	array
=	O
dfa_hash_table	array
[	O
hash_value	int
]	O
;	O
entry	array
;	O
entry	array
=	O
entry	array
->	O
next	pointer
)	O
{	O
dfa_attrib	struct
*	O
left	pointer
=	O
key	pointer
;	O
dfa_attrib	struct
*	O
right	pointer
=	O
entry	array
->	O
key	pointer
;	O
while	O
(	O
left	pointer
&&	O
right	pointer
)	O
{	O
if	O
(	O
left	pointer
->	O
string_index	int
!=	O
right	pointer
->	O
string_index	int
)	O
break	O
;	O
left	pointer
=	O
left	pointer
->	O
next	pointer
;	O
right	pointer
=	O
right	pointer
->	O
next	pointer
;	O
}	O
if	O
(	O
!	O
left	pointer
&&	O
!	O
right	pointer
)	O
return	O
entry	array
->	O
value	pointer
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
void	O
dfa_hash_add_node	function
(	O
dfa_node	struct
*	O
node	pointer
)	O
{	O
int	O
hash_value	int
=	O
dfa_hash_value	function
(	O
node	pointer
->	O
passing_strings	pointer
)	O
;	O
dfa_hash_entry	struct
*	O
entry	array
;	O
entry	array
=	O
dfa_hash_entry_new	function
(	O
)	O
;	O
entry	array
->	O
next	pointer
=	O
dfa_hash_table	array
[	O
hash_value	int
]	O
;	O
dfa_hash_table	array
[	O
hash_value	int
]	O
=	O
entry	array
;	O
entry	array
->	O
key	pointer
=	O
node	pointer
->	O
passing_strings	pointer
;	O
entry	array
->	O
value	pointer
=	O
node	pointer
;	O
}	O
static	O
dfa_node_block	struct
*	O
dfa_iterator_block	pointer
;	O
static	O
int	O
dfa_iterator_node_num	int
;	O
static	O
dfa_node	struct
*	O
dfa_iterator_reset	function
(	O
dfa_graph	struct
*	O
graph	struct
)	O
{	O
assert	O
(	O
graph	struct
->	O
last_block	pointer
)	O
;	O
if	O
(	O
graph	struct
->	O
allocated	int
>	O
0	int
)	O
{	O
dfa_iterator_block	pointer
=	O
graph	struct
->	O
last_block	pointer
;	O
dfa_iterator_node_num	int
=	O
graph	struct
->	O
allocated	int
-	O
1	int
;	O
}	O
else	O
{	O
dfa_iterator_block	pointer
=	O
graph	struct
->	O
last_block	pointer
->	O
previous	pointer
;	O
assert	O
(	O
dfa_iterator_block	pointer
)	O
;	O
dfa_iterator_node_num	int
=	O
DFA_NODE_BLOCK_SIZE	int
-	O
1	int
;	O
}	O
return	O
&	O
(	O
dfa_iterator_block	pointer
->	O
node	pointer
[	O
dfa_iterator_node_num	int
]	O
)	O
;	O
}	O
static	O
dfa_node	struct
*	O
dfa_iterate	function
(	O
void	O
)	O
{	O
dfa_iterator_node_num	int
--	O
;	O
if	O
(	O
dfa_iterator_node_num	int
<	O
0	int
)	O
{	O
dfa_iterator_block	pointer
=	O
dfa_iterator_block	pointer
->	O
previous	pointer
;	O
assert	O
(	O
dfa_iterator_block	pointer
)	O
;	O
dfa_iterator_node_num	int
=	O
DFA_NODE_BLOCK_SIZE	int
-	O
1	int
;	O
}	O
return	O
&	O
(	O
dfa_iterator_block	pointer
->	O
node	pointer
[	O
dfa_iterator_node_num	int
]	O
)	O
;	O
}	O
void	O
dfa_graph_reset	function
(	O
dfa_graph	struct
*	O
graph	struct
)	O
{	O
graph	struct
->	O
num_nodes	int
=	O
0	int
;	O
graph	struct
->	O
root	pointer
=	O
NULL	O
;	O
graph	struct
->	O
last_block	pointer
=	O
NULL	O
;	O
graph	struct
->	O
allocated	int
=	O
DFA_NODE_BLOCK_SIZE	int
;	O
dfa_attrib_array_reset	function
(	O
&	O
(	O
graph	struct
->	O
attributes	pointer
)	O
)	O
;	O
}	O
static	O
void	O
dfa_graph_clear	function
(	O
dfa_graph	struct
*	O
graph	struct
)	O
{	O
dfa_node_block	struct
*	O
block	pointer
=	O
graph	struct
->	O
last_block	pointer
;	O
graph	struct
->	O
num_nodes	int
=	O
0	int
;	O
graph	struct
->	O
root	pointer
=	O
NULL	O
;	O
while	O
(	O
block	pointer
)	O
{	O
dfa_node_block	struct
*	O
previous	pointer
=	O
block	pointer
->	O
previous	pointer
;	O
free	function
(	O
block	pointer
)	O
;	O
block	pointer
=	O
previous	pointer
;	O
}	O
graph	struct
->	O
last_block	pointer
=	O
NULL	O
;	O
graph	struct
->	O
allocated	int
=	O
DFA_NODE_BLOCK_SIZE	int
;	O
dfa_attrib_array_clear	function
(	O
&	O
(	O
graph	struct
->	O
attributes	pointer
)	O
)	O
;	O
}	O
static	O
void	O
dfa_graph_build_level	function
(	O
dfa_graph	struct
*	O
graph	struct
,	O
char	O
*	O
*	O
strings	array
,	O
int	O
level	int
,	O
dfa_node	struct
*	O
terminal_node	pointer
,	O
dfa_attrib_array	struct
*	O
passing_strings_array	pointer
)	O
{	O
int	O
save_num_nodes	int
=	O
graph	struct
->	O
num_nodes	int
;	O
dfa_attrib_block	struct
*	O
cutoff_point	pointer
;	O
dfa_node	struct
*	O
node	pointer
;	O
dfa_node	struct
*	O
this_terminal_node	pointer
=	O
dfa_iterator_reset	function
(	O
graph	struct
)	O
;	O
cutoff_point	pointer
=	O
passing_strings_array	pointer
->	O
last_block	pointer
;	O
dfa_hash_clear	function
(	O
)	O
;	O
for	O
(	O
node	pointer
=	O
this_terminal_node	pointer
;	O
node	pointer
!=	O
terminal_node	pointer
;	O
node	pointer
=	O
dfa_iterate	function
(	O
)	O
)	O
{	O
int	O
k	int
;	O
int	O
num_masks	int
=	O
0	int
;	O
char	O
mask	array
[	O
4	int
]	O
;	O
dfa_attrib	struct
*	O
passing_string	pointer
;	O
dfa_attrib	struct
*	O
*	O
link	function
=	O
&	O
(	O
node	pointer
->	O
attributes	pointer
)	O
;	O
dfa_attrib	struct
*	O
new_passing_strings	array
[	O
4	int
]	O
;	O
dfa_attrib	struct
*	O
*	O
new_link	array
[	O
4	int
]	O
;	O
for	O
(	O
passing_string	pointer
=	O
node	pointer
->	O
passing_strings	pointer
;	O
passing_string	pointer
&&	O
num_masks	int
<	O
4	int
;	O
passing_string	pointer
=	O
passing_string	pointer
->	O
next	pointer
)	O
{	O
int	O
index	function
=	O
passing_string	pointer
->	O
string_index	int
;	O
char	O
string_mask	char
=	O
strings	array
[	O
index	function
]	O
[	O
level	int
]	O
;	O
if	O
(	O
string_mask	char
)	O
{	O
int	O
limit	int
=	O
num_masks	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
limit	int
;	O
k	int
++	O
)	O
{	O
char	O
common_branches	char
=	O
string_mask	char
&	O
mask	array
[	O
k	int
]	O
;	O
if	O
(	O
common_branches	char
&&	O
common_branches	char
!=	O
mask	array
[	O
k	int
]	O
)	O
{	O
mask	array
[	O
k	int
]	O
^=	O
common_branches	char
;	O
mask	array
[	O
num_masks	int
++	O
]	O
=	O
common_branches	char
;	O
}	O
string_mask	char
^=	O
common_branches	char
;	O
}	O
if	O
(	O
string_mask	char
)	O
{	O
mask	array
[	O
num_masks	int
++	O
]	O
=	O
string_mask	char
;	O
}	O
}	O
else	O
{	O
*	O
link	function
=	O
dfa_attrib_new	function
(	O
&	O
(	O
graph	struct
->	O
attributes	pointer
)	O
,	O
index	function
)	O
;	O
link	function
=	O
&	O
(	O
(	O
*	O
link	function
)	O
->	O
next	pointer
)	O
;	O
}	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_masks	int
;	O
k	int
++	O
)	O
new_link	array
[	O
k	int
]	O
=	O
&	O
(	O
new_passing_strings	array
[	O
k	int
]	O
)	O
;	O
for	O
(	O
passing_string	pointer
=	O
node	pointer
->	O
passing_strings	pointer
;	O
passing_string	pointer
;	O
passing_string	pointer
=	O
passing_string	pointer
->	O
next	pointer
)	O
{	O
int	O
index	function
=	O
passing_string	pointer
->	O
string_index	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_masks	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
strings	array
[	O
index	function
]	O
[	O
level	int
]	O
&	O
mask	array
[	O
k	int
]	O
)	O
{	O
*	O
(	O
new_link	array
[	O
k	int
]	O
)	O
=	O
dfa_attrib_new	function
(	O
passing_strings_array	pointer
,	O
index	function
)	O
;	O
new_link	array
[	O
k	int
]	O
=	O
&	O
(	O
(	O
*	O
(	O
new_link	array
[	O
k	int
]	O
)	O
)	O
->	O
next	pointer
)	O
;	O
}	O
}	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_masks	int
;	O
k	int
++	O
)	O
{	O
int	O
i	int
;	O
dfa_node	struct
*	O
new_node	pointer
=	O
dfa_hash_search	function
(	O
new_passing_strings	array
[	O
k	int
]	O
)	O
;	O
if	O
(	O
!	O
new_node	pointer
)	O
{	O
new_node	pointer
=	O
dfa_node_new	function
(	O
graph	struct
)	O
;	O
new_node	pointer
->	O
passing_strings	pointer
=	O
new_passing_strings	array
[	O
k	int
]	O
;	O
dfa_hash_add_node	function
(	O
new_node	pointer
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
mask	array
[	O
k	int
]	O
&	O
(	O
1	int
<<	O
i	int
)	O
)	O
node	pointer
->	O
branch	array
[	O
i	int
]	O
=	O
new_node	pointer
;	O
}	O
}	O
}	O
dfa_attrib_array_partially_clear	function
(	O
cutoff_point	pointer
)	O
;	O
if	O
(	O
graph	struct
->	O
num_nodes	int
!=	O
save_num_nodes	int
)	O
{	O
dfa_graph_build_level	function
(	O
graph	struct
,	O
strings	array
,	O
level	int
+	O
1	int
,	O
this_terminal_node	pointer
,	O
passing_strings_array	pointer
)	O
;	O
}	O
}	O
static	O
char	O
*	O
dfa_prepare_string	function
(	O
const	O
char	O
*	O
string	int
)	O
{	O
int	O
k	int
;	O
int	O
l	int
=	O
strlen	function
(	O
string	int
)	O
;	O
char	O
*	O
dfa_string	pointer
=	O
malloc	function
(	O
l	int
+	O
1	int
)	O
;	O
assert	O
(	O
dfa_string	pointer
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
l	int
;	O
k	int
++	O
)	O
{	O
switch	O
(	O
string	int
[	O
k	int
]	O
)	O
{	O
case	O
'$'	O
:	O
dfa_string	pointer
[	O
k	int
]	O
=	O
15	int
;	O
break	O
;	O
case	O
'-'	O
:	O
case	O
'|'	O
:	O
case	O
'+'	O
:	O
case	O
'#'	O
:	O
dfa_string	pointer
[	O
k	int
]	O
=	O
8	int
;	O
break	O
;	O
case	O
'.'	O
:	O
case	O
','	O
:	O
case	O
'!'	O
:	O
case	O
'a'	O
:	O
dfa_string	pointer
[	O
k	int
]	O
=	O
1	int
;	O
break	O
;	O
case	O
'?'	O
:	O
dfa_string	pointer
[	O
k	int
]	O
=	O
7	int
;	O
break	O
;	O
case	O
'O'	O
:	O
dfa_string	pointer
[	O
k	int
]	O
=	O
2	int
;	O
break	O
;	O
case	O
'X'	O
:	O
dfa_string	pointer
[	O
k	int
]	O
=	O
4	int
;	O
break	O
;	O
case	O
'o'	O
:	O
dfa_string	pointer
[	O
k	int
]	O
=	O
3	int
;	O
break	O
;	O
case	O
'x'	O
:	O
dfa_string	pointer
[	O
k	int
]	O
=	O
5	int
;	O
break	O
;	O
default	O
:	O
assert	O
(	O
0	int
)	O
;	O
}	O
}	O
dfa_string	pointer
[	O
l	int
]	O
=	O
0	int
;	O
return	O
dfa_string	pointer
;	O
}	O
void	O
dfa_patterns_reset	function
(	O
dfa_patterns	struct
*	O
patterns	pointer
)	O
{	O
patterns	pointer
->	O
num_patterns	int
=	O
0	int
;	O
patterns	pointer
->	O
patterns	pointer
=	O
NULL	O
;	O
patterns	pointer
->	O
last_pattern	pointer
=	O
NULL	O
;	O
dfa_graph_reset	function
(	O
&	O
(	O
patterns	pointer
->	O
graph	struct
)	O
)	O
;	O
}	O
void	O
dfa_patterns_clear	function
(	O
dfa_patterns	struct
*	O
patterns	pointer
)	O
{	O
dfa_pattern	struct
*	O
pattern	pointer
=	O
patterns	pointer
->	O
patterns	pointer
;	O
while	O
(	O
pattern	pointer
)	O
{	O
int	O
k	int
;	O
dfa_pattern	struct
*	O
next	pointer
=	O
pattern	pointer
->	O
next	pointer
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
pattern	pointer
->	O
num_variations	char
;	O
k	int
++	O
)	O
free	function
(	O
pattern	pointer
->	O
variation	array
[	O
k	int
]	O
)	O
;	O
free	function
(	O
pattern	pointer
)	O
;	O
pattern	pointer
=	O
next	pointer
;	O
}	O
patterns	pointer
->	O
num_patterns	int
=	O
0	int
;	O
patterns	pointer
->	O
patterns	pointer
=	O
NULL	O
;	O
patterns	pointer
->	O
last_pattern	pointer
=	O
NULL	O
;	O
dfa_graph_clear	function
(	O
&	O
(	O
patterns	pointer
->	O
graph	struct
)	O
)	O
;	O
}	O
void	O
dfa_patterns_add_pattern	function
(	O
dfa_patterns	struct
*	O
patterns	pointer
,	O
const	O
char	O
*	O
string	int
,	O
int	O
index	function
)	O
{	O
dfa_pattern	struct
*	O
pattern	pointer
=	O
NULL	O
;	O
if	O
(	O
index	function
==	O
patterns	pointer
->	O
num_patterns	int
-	O
1	int
)	O
{	O
assert	O
(	O
patterns	pointer
->	O
last_pattern	pointer
)	O
;	O
assert	O
(	O
patterns	pointer
->	O
last_pattern	pointer
->	O
num_variations	char
<	O
8	int
)	O
;	O
pattern	pointer
=	O
patterns	pointer
->	O
last_pattern	pointer
;	O
}	O
else	O
{	O
assert	O
(	O
patterns	pointer
->	O
num_patterns	int
<=	O
index	function
)	O
;	O
while	O
(	O
patterns	pointer
->	O
num_patterns	int
<=	O
index	function
)	O
{	O
patterns	pointer
->	O
num_patterns	int
++	O
;	O
pattern	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
*	O
pattern	pointer
)	O
)	O
;	O
pattern	pointer
->	O
num_variations	char
=	O
0	int
;	O
if	O
(	O
patterns	pointer
->	O
last_pattern	pointer
)	O
patterns	pointer
->	O
last_pattern	pointer
->	O
next	pointer
=	O
pattern	pointer
;	O
else	O
patterns	pointer
->	O
patterns	pointer
=	O
pattern	pointer
;	O
patterns	pointer
->	O
last_pattern	pointer
=	O
pattern	pointer
;	O
}	O
pattern	pointer
->	O
current_variation	int
=	O
0	int
;	O
pattern	pointer
->	O
next	pointer
=	O
NULL	O
;	O
}	O
pattern	pointer
->	O
variation	array
[	O
pattern	pointer
->	O
num_variations	char
++	O
]	O
=	O
dfa_prepare_string	function
(	O
string	int
)	O
;	O
}	O
void	O
dfa_patterns_set_last_pattern_variation	function
(	O
dfa_patterns	struct
*	O
patterns	pointer
,	O
int	O
variation	array
)	O
{	O
assert	O
(	O
patterns	pointer
->	O
last_pattern	pointer
)	O
;	O
assert	O
(	O
patterns	pointer
->	O
last_pattern	pointer
->	O
num_variations	char
>	O
variation	array
)	O
;	O
patterns	pointer
->	O
last_pattern	pointer
->	O
current_variation	int
=	O
variation	array
;	O
}	O
void	O
dfa_patterns_select_shortest_variation	function
(	O
dfa_patterns	struct
*	O
patterns	pointer
)	O
{	O
int	O
k	int
;	O
int	O
min_length	int
;	O
dfa_pattern	struct
*	O
pattern	pointer
=	O
patterns	pointer
->	O
last_pattern	pointer
;	O
assert	O
(	O
pattern	pointer
)	O
;	O
pattern	pointer
->	O
current_variation	int
=	O
0	int
;	O
min_length	int
=	O
strlen	function
(	O
pattern	pointer
->	O
variation	array
[	O
0	int
]	O
)	O
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<	O
pattern	pointer
->	O
num_variations	char
;	O
k	int
++	O
)	O
{	O
int	O
length	int
=	O
strlen	function
(	O
pattern	pointer
->	O
variation	array
[	O
k	int
]	O
)	O
;	O
if	O
(	O
length	int
<	O
min_length	int
)	O
{	O
pattern	pointer
->	O
current_variation	int
=	O
k	int
;	O
min_length	int
=	O
length	int
;	O
}	O
}	O
}	O
void	O
dfa_patterns_build_graph	function
(	O
dfa_patterns	struct
*	O
patterns	pointer
)	O
{	O
int	O
k	int
=	O
0	int
;	O
char	O
*	O
*	O
strings	array
;	O
dfa_attrib_array	struct
passing_strings_array	pointer
;	O
dfa_attrib	struct
*	O
*	O
link	function
;	O
dfa_node	struct
*	O
error_state	pointer
;	O
dfa_graph	struct
*	O
graph	struct
=	O
&	O
(	O
patterns	pointer
->	O
graph	struct
)	O
;	O
dfa_pattern	struct
*	O
pattern	pointer
;	O
strings	array
=	O
malloc	function
(	O
patterns	pointer
->	O
num_patterns	int
*	O
sizeof	O
(	O
*	O
strings	array
)	O
)	O
;	O
assert	O
(	O
strings	array
)	O
;	O
dfa_graph_clear	function
(	O
graph	struct
)	O
;	O
dfa_attrib_array_reset	function
(	O
&	O
passing_strings_array	pointer
)	O
;	O
error_state	pointer
=	O
dfa_node_new	function
(	O
graph	struct
)	O
;	O
graph	struct
->	O
root	pointer
=	O
dfa_node_new	function
(	O
graph	struct
)	O
;	O
link	function
=	O
&	O
(	O
graph	struct
->	O
root	pointer
->	O
passing_strings	pointer
)	O
;	O
for	O
(	O
pattern	pointer
=	O
patterns	pointer
->	O
patterns	pointer
;	O
pattern	pointer
;	O
pattern	pointer
=	O
pattern	pointer
->	O
next	pointer
,	O
k	int
++	O
)	O
{	O
if	O
(	O
pattern	pointer
->	O
num_variations	char
>	O
0	int
)	O
{	O
assert	O
(	O
pattern	pointer
->	O
current_variation	int
<	O
pattern	pointer
->	O
num_variations	char
)	O
;	O
strings	array
[	O
k	int
]	O
=	O
pattern	pointer
->	O
variation	array
[	O
pattern	pointer
->	O
current_variation	int
]	O
;	O
*	O
link	function
=	O
dfa_attrib_new	function
(	O
&	O
passing_strings_array	pointer
,	O
k	int
)	O
;	O
link	function
=	O
&	O
(	O
(	O
*	O
link	function
)	O
->	O
next	pointer
)	O
;	O
}	O
else	O
strings	array
[	O
k	int
]	O
=	O
NULL	O
;	O
}	O
dfa_graph_build_level	function
(	O
graph	struct
,	O
strings	array
,	O
0	int
,	O
error_state	pointer
,	O
&	O
passing_strings_array	pointer
)	O
;	O
free	function
(	O
strings	array
)	O
;	O
dfa_attrib_array_clear	function
(	O
&	O
passing_strings_array	pointer
)	O
;	O
}	O
int	O
*	O
dfa_patterns_optimize_variations	function
(	O
dfa_patterns	struct
*	O
patterns	pointer
,	O
int	O
iterations	int
)	O
{	O
int	O
k	int
=	O
0	int
;	O
int	O
failed_iterations	int
=	O
0	int
;	O
int	O
min_nodes_so_far	int
;	O
int	O
num_nodes_original	int
;	O
int	O
*	O
best_variations	pointer
;	O
double	O
lower_limit	double
=	O
2.0	int
/	O
patterns	pointer
->	O
num_patterns	int
;	O
double	O
upper_limit	double
=	O
6.0	int
/	O
patterns	pointer
->	O
num_patterns	int
;	O
double	O
change_probability	double
=	O
4.0	int
/	O
patterns	pointer
->	O
num_patterns	int
;	O
dfa_pattern	struct
*	O
pattern	pointer
;	O
best_variations	pointer
=	O
malloc	function
(	O
patterns	pointer
->	O
num_patterns	int
*	O
sizeof	O
(	O
*	O
best_variations	pointer
)	O
)	O
;	O
assert	O
(	O
best_variations	pointer
)	O
;	O
for	O
(	O
pattern	pointer
=	O
patterns	pointer
->	O
patterns	pointer
;	O
pattern	pointer
;	O
pattern	pointer
=	O
pattern	pointer
->	O
next	pointer
,	O
k	int
++	O
)	O
best_variations	pointer
[	O
k	int
]	O
=	O
pattern	pointer
->	O
current_variation	int
;	O
dfa_patterns_build_graph	function
(	O
patterns	pointer
)	O
;	O
num_nodes_original	int
=	O
patterns	pointer
->	O
graph	struct
.	O
num_nodes	int
;	O
min_nodes_so_far	int
=	O
num_nodes_original	int
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Original number of DFA states: %d\n"	pointer
,	O
min_nodes_so_far	int
-	O
1	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Trying to optimize in %d iterations\n"	pointer
,	O
iterations	int
)	O
;	O
gg_srand	function
(	O
num_nodes_original	int
+	O
patterns	pointer
->	O
num_patterns	int
)	O
;	O
while	O
(	O
iterations	int
--	O
)	O
{	O
int	O
changed_variations	int
=	O
0	int
;	O
int	O
k	int
=	O
0	int
;	O
for	O
(	O
pattern	pointer
=	O
patterns	pointer
->	O
patterns	pointer
;	O
pattern	pointer
;	O
pattern	pointer
=	O
pattern	pointer
->	O
next	pointer
,	O
k	int
++	O
)	O
{	O
if	O
(	O
gg_drand	function
(	O
)	O
<	O
change_probability	double
&&	O
pattern	pointer
->	O
num_variations	char
>	O
1	int
)	O
{	O
int	O
new_variation	int
=	O
gg_rand	function
(	O
)	O
%	O
(	O
pattern	pointer
->	O
num_variations	char
-	O
1	int
)	O
;	O
if	O
(	O
new_variation	int
>=	O
pattern	pointer
->	O
current_variation	int
)	O
new_variation	int
++	O
;	O
pattern	pointer
->	O
current_variation	int
=	O
new_variation	int
;	O
changed_variations	int
++	O
;	O
}	O
else	O
pattern	pointer
->	O
current_variation	int
=	O
best_variations	pointer
[	O
k	int
]	O
;	O
}	O
if	O
(	O
changed_variations	int
==	O
0	int
)	O
{	O
iterations	int
++	O
;	O
continue	O
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"."	pointer
)	O
;	O
dfa_patterns_build_graph	function
(	O
patterns	pointer
)	O
;	O
if	O
(	O
patterns	pointer
->	O
graph	struct
.	O
num_nodes	int
<	O
min_nodes_so_far	int
)	O
{	O
int	O
k	int
=	O
0	int
;	O
for	O
(	O
pattern	pointer
=	O
patterns	pointer
->	O
patterns	pointer
;	O
pattern	pointer
;	O
pattern	pointer
=	O
pattern	pointer
->	O
next	pointer
,	O
k	int
++	O
)	O
best_variations	pointer
[	O
k	int
]	O
=	O
pattern	pointer
->	O
current_variation	int
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\nOptimized: %d => %d states (%d iterations left)\n"	pointer
,	O
min_nodes_so_far	int
-	O
1	int
,	O
patterns	pointer
->	O
graph	struct
.	O
num_nodes	int
-	O
1	int
,	O
iterations	int
)	O
;	O
min_nodes_so_far	int
=	O
patterns	pointer
->	O
graph	struct
.	O
num_nodes	int
;	O
failed_iterations	int
=	O
0	int
;	O
}	O
else	O
failed_iterations	int
++	O
;	O
if	O
(	O
failed_iterations	int
>=	O
30	int
)	O
{	O
double	O
delta	array
=	O
gg_drand	function
(	O
)	O
/	O
patterns	pointer
->	O
num_patterns	int
;	O
if	O
(	O
change_probability	double
>	O
upper_limit	double
||	O
(	O
change_probability	double
>=	O
lower_limit	double
&&	O
gg_rand	function
(	O
)	O
%	O
2	int
==	O
0	int
)	O
)	O
delta	array
=	O
-	O
delta	array
;	O
change_probability	double
+=	O
delta	array
;	O
failed_iterations	int
=	O
0	int
;	O
}	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"\nTotal optimization result: %d => %d states\n"	pointer
,	O
num_nodes_original	int
-	O
1	int
,	O
min_nodes_so_far	int
-	O
1	int
)	O
;	O
dfa_graph_clear	function
(	O
&	O
(	O
patterns	pointer
->	O
graph	struct
)	O
)	O
;	O
return	O
best_variations	pointer
;	O
}	O
