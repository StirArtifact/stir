int	O
interactive	int
;	O
char	O
*	O
prompt	pointer
;	O
static	O
void	O
ds_prefix	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
;	O
static	O
void	O
ds_help	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
;	O
static	O
void	O
ds_quiet	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
;	O
static	O
void	O
ds_prompt	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
;	O
static	O
char	O
*	O
*	O
no_compl	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
int	O
ws	pointer
)	O
;	O
char	O
*	O
helptext	array
[	O
]	O
[	O
2	int
]	O
=	O
{	O
{	O
N_	O
(	O
"WORD"	pointer
)	O
,	O
N_	O
(	O
"Define WORD."	pointer
)	O
}	O
,	O
{	O
N_	O
(	O
"/WORD"	pointer
)	O
,	O
N_	O
(	O
"Match WORD."	pointer
)	O
}	O
,	O
{	O
"/"	pointer
,	O
N_	O
(	O
"Redisplay previous matches."	pointer
)	O
}	O
,	O
{	O
N_	O
(	O
"NUMBER"	pointer
)	O
,	O
N_	O
(	O
"Define NUMBERth match."	pointer
)	O
}	O
,	O
}	O
;	O
struct	O
funtab	struct
funtab	struct
[	O
]	O
=	O
{	O
{	O
"open"	pointer
,	O
1	int
,	O
3	int
,	O
N_	O
(	O
"[HOST [PORT]]"	pointer
)	O
,	O
N_	O
(	O
"Connect to a DICT server."	pointer
)	O
,	O
ds_open	function
,	O
no_compl	function
}	O
,	O
{	O
"close"	pointer
,	O
1	int
,	O
1	int
,	O
NULL	O
,	O
N_	O
(	O
"Close the connection."	pointer
)	O
,	O
ds_close	function
,	O
}	O
,	O
{	O
"database"	pointer
,	O
1	int
,	O
2	int
,	O
N_	O
(	O
"[NAME]"	pointer
)	O
,	O
N_	O
(	O
"Set or display current database name."	pointer
)	O
,	O
ds_database	function
,	O
ds_compl_database	function
}	O
,	O
{	O
"strategy"	pointer
,	O
1	int
,	O
2	int
,	O
N_	O
(	O
"[NAME]"	pointer
)	O
,	O
N_	O
(	O
"Set or display current strategy."	pointer
)	O
,	O
ds_strategy	function
,	O
ds_compl_strategy	function
}	O
,	O
{	O
"distance"	pointer
,	O
1	int
,	O
2	int
,	O
N_	O
(	O
"[NUM]"	pointer
)	O
,	O
N_	O
(	O
"Set or query Levenshtein distance (server-dependent)."	pointer
)	O
,	O
ds_distance	function
,	O
no_compl	function
}	O
,	O
{	O
"ls"	pointer
,	O
1	int
,	O
1	int
,	O
NULL	O
,	O
N_	O
(	O
"List available matching strategies"	pointer
)	O
,	O
ds_show_strat	function
,	O
}	O
,	O
{	O
"ld"	pointer
,	O
1	int
,	O
1	int
,	O
NULL	O
,	O
N_	O
(	O
"List all accessible databases"	pointer
)	O
,	O
ds_show_db	function
,	O
}	O
,	O
{	O
"info"	pointer
,	O
1	int
,	O
2	int
,	O
N_	O
(	O
"[DB]"	pointer
)	O
,	O
N_	O
(	O
"Display the information about the database."	pointer
)	O
,	O
ds_show_info	function
,	O
ds_compl_database	function
}	O
,	O
{	O
"prefix"	pointer
,	O
1	int
,	O
2	int
,	O
N_	O
(	O
"[CHAR]"	pointer
)	O
,	O
N_	O
(	O
"Set or display command prefix."	pointer
)	O
,	O
ds_prefix	function
,	O
}	O
,	O
{	O
"transcript"	pointer
,	O
1	int
,	O
2	int
,	O
N_	O
(	O
"[BOOL]"	pointer
)	O
,	O
N_	O
(	O
"Set or display session transcript mode."	pointer
)	O
,	O
ds_transcript	function
,	O
no_compl	function
}	O
,	O
{	O
"verbose"	pointer
,	O
1	int
,	O
2	int
,	O
N_	O
(	O
"[NUMBER]"	pointer
)	O
,	O
N_	O
(	O
"Set or display verbosity level."	pointer
)	O
,	O
ds_verbose	function
,	O
no_compl	function
}	O
,	O
{	O
"prompt"	pointer
,	O
2	int
,	O
2	int
,	O
N_	O
(	O
"STRING"	pointer
)	O
,	O
N_	O
(	O
"Change command line prompt."	pointer
)	O
,	O
ds_prompt	function
,	O
no_compl	function
}	O
,	O
{	O
"pager"	pointer
,	O
1	int
,	O
2	int
,	O
N_	O
(	O
"STRING"	pointer
)	O
,	O
N_	O
(	O
"Change or display pager settings."	pointer
)	O
,	O
ds_pager	function
,	O
no_compl	function
}	O
,	O
{	O
"autologin"	pointer
,	O
1	int
,	O
2	int
,	O
N_	O
(	O
"[FILE]"	pointer
)	O
,	O
N_	O
(	O
"Set or display autologin file name."	pointer
)	O
,	O
ds_autologin	function
,	O
}	O
,	O
{	O
"sasl"	pointer
,	O
1	int
,	O
2	int
,	O
N_	O
(	O
"[BOOL]"	pointer
)	O
,	O
N_	O
(	O
"Enable SASL authentication."	pointer
)	O
,	O
ds_sasl	function
,	O
no_compl	function
}	O
,	O
{	O
"help"	pointer
,	O
1	int
,	O
1	int
,	O
NULL	O
,	O
N_	O
(	O
"Display this help text."	pointer
)	O
,	O
ds_help	function
,	O
}	O
,	O
{	O
"version"	pointer
,	O
1	int
,	O
1	int
,	O
NULL	O
,	O
N_	O
(	O
"Print program version."	pointer
)	O
,	O
ds_version	function
,	O
}	O
,	O
{	O
"warranty"	pointer
,	O
1	int
,	O
1	int
,	O
NULL	O
,	O
N_	O
(	O
"Print copyright statement."	pointer
)	O
,	O
ds_warranty	function
,	O
}	O
,	O
{	O
"quiet"	pointer
,	O
2	int
,	O
2	int
,	O
NULL	O
,	O
NULL	O
,	O
ds_quiet	function
}	O
,	O
{	O
"quit"	pointer
,	O
1	int
,	O
1	int
,	O
NULL	O
,	O
N_	O
(	O
"Quit the shell."	pointer
)	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
struct	O
funtab	struct
*	O
find_funtab	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
funtab	struct
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
funtab	struct
;	O
p	pointer
->	O
name	pointer
;	O
p	pointer
++	O
)	O
if	O
(	O
strcmp	function
(	O
p	pointer
->	O
name	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
return	O
p	pointer
;	O
return	O
NULL	O
;	O
}	O
int	O
cmdprefix	int
;	O
char	O
special_prefixes	array
[	O
2	int
]	O
;	O
static	O
void	O
ds_prefix	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
if	O
(	O
argc	int
==	O
1	int
)	O
printf	function
(	O
_	O
(	O
"Command prefix is %c\n"	pointer
)	O
,	O
cmdprefix	int
)	O
;	O
else	O
if	O
(	O
!	O
(	O
!	O
argv	pointer
[	O
1	int
]	O
[	O
1	int
]	O
&&	O
argv	pointer
[	O
1	int
]	O
[	O
0	int
]	O
!=	O
'#'	O
&&	O
ispunct	function
(	O
argv	pointer
[	O
1	int
]	O
[	O
0	int
]	O
)	O
)	O
)	O
script_error	function
(	O
_	O
(	O
"Expected a single punctuation character"	pointer
)	O
)	O
;	O
else	O
{	O
cmdprefix	int
=	O
argv	pointer
[	O
1	int
]	O
[	O
0	int
]	O
;	O
strcpy	function
(	O
special_prefixes	array
,	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
}	O
}	O
static	O
void	O
ds_help	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
static	O
size_t	long
nlines	long
;	O
dico_stream_t	pointer
str	pointer
;	O
struct	O
funtab	struct
*	O
ft	pointer
;	O
size_t	long
i	long
;	O
if	O
(	O
nlines	long
==	O
0	int
)	O
{	O
nlines	long
=	O
DICO_ARRAY_SIZE	O
(	O
helptext	array
)	O
+	O
1	int
;	O
for	O
(	O
ft	pointer
=	O
funtab	struct
;	O
ft	pointer
->	O
name	pointer
;	O
ft	pointer
++	O
)	O
{	O
if	O
(	O
ft	pointer
->	O
docstring	pointer
)	O
nlines	long
++	O
;	O
}	O
}	O
str	pointer
=	O
create_pager_stream	function
(	O
nlines	long
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
DICO_ARRAY_SIZE	O
(	O
helptext	array
)	O
;	O
i	long
++	O
)	O
{	O
stream_printf	function
(	O
str	pointer
,	O
"%-24s %s\n"	pointer
,	O
gettext	function
(	O
helptext	array
[	O
i	long
]	O
[	O
0	int
]	O
)	O
,	O
gettext	function
(	O
helptext	array
[	O
i	long
]	O
[	O
1	int
]	O
)	O
)	O
;	O
}	O
dico_stream_write	function
(	O
str	pointer
,	O
"\n"	pointer
,	O
1	int
)	O
;	O
for	O
(	O
ft	pointer
=	O
funtab	struct
;	O
ft	pointer
->	O
name	pointer
;	O
ft	pointer
++	O
)	O
{	O
int	O
len	long
=	O
0	int
;	O
const	O
char	O
*	O
args	pointer
;	O
if	O
(	O
ft	pointer
->	O
docstring	pointer
==	O
NULL	O
)	O
continue	O
;	O
if	O
(	O
cmdprefix	int
)	O
{	O
stream_printf	function
(	O
str	pointer
,	O
"%c"	pointer
,	O
cmdprefix	int
)	O
;	O
len	long
++	O
;	O
}	O
stream_printf	function
(	O
str	pointer
,	O
"%s "	pointer
,	O
ft	pointer
->	O
name	pointer
)	O
;	O
len	long
+=	O
strlen	function
(	O
ft	pointer
->	O
name	pointer
)	O
+	O
1	int
;	O
if	O
(	O
ft	pointer
->	O
argdoc	pointer
)	O
args	pointer
=	O
gettext	function
(	O
ft	pointer
->	O
argdoc	pointer
)	O
;	O
else	O
args	pointer
=	O
""	pointer
;	O
if	O
(	O
len	long
<	O
24	int
)	O
len	long
=	O
24	int
-	O
len	long
;	O
else	O
len	long
=	O
0	int
;	O
stream_printf	function
(	O
str	pointer
,	O
"%-*s %s\n"	pointer
,	O
len	long
,	O
args	pointer
,	O
gettext	function
(	O
ft	pointer
->	O
docstring	pointer
)	O
)	O
;	O
}	O
dico_stream_close	function
(	O
str	pointer
)	O
;	O
dico_stream_destroy	function
(	O
&	O
str	pointer
)	O
;	O
}	O
static	O
void	O
ds_quiet	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
set_bool	function
(	O
&	O
quiet_option	int
,	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
}	O
typedef	O
int	O
(	O
*	O
script_getln_fn	pointer
)	O
(	O
void	O
*	O
data	pointer
,	O
char	O
*	O
*	O
buf	pointer
)	O
;	O
int	O
line	int
=	O
0	int
;	O
const	O
char	O
*	O
filename	pointer
;	O
void	O
script_diag	function
(	O
int	O
category	int
,	O
int	O
errcode	int
,	O
const	O
char	O
*	O
fmt	pointer
,	O
va_list	array
ap	array
)	O
{	O
const	O
char	O
*	O
pfx	pointer
;	O
char	O
*	O
newfmt	pointer
;	O
if	O
(	O
category	int
==	O
L_WARN	int
)	O
pfx	pointer
=	O
_	O
(	O
"warning: "	pointer
)	O
;	O
else	O
pfx	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
filename	pointer
)	O
asprintf	function
(	O
&	O
newfmt	pointer
,	O
"%s%s"	pointer
,	O
pfx	pointer
?	O
pfx	pointer
:	O
""	pointer
,	O
fmt	pointer
)	O
;	O
else	O
{	O
asprintf	function
(	O
&	O
newfmt	pointer
,	O
"%s:%d: %s%s"	pointer
,	O
filename	pointer
,	O
line	int
,	O
pfx	pointer
?	O
pfx	pointer
:	O
""	pointer
,	O
fmt	pointer
)	O
;	O
}	O
dico_vlog	function
(	O
category	int
,	O
errcode	int
,	O
newfmt	pointer
,	O
ap	array
)	O
;	O
free	function
(	O
newfmt	pointer
)	O
;	O
}	O
void	O
script_warning	function
(	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
script_diag	function
(	O
L_WARN	int
,	O
0	int
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
}	O
void	O
script_error	function
(	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
script_diag	function
(	O
L_ERR	int
,	O
0	int
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
}	O
static	O
int	O
is_command	function
(	O
char	O
*	O
*	O
ptr	pointer
)	O
{	O
if	O
(	O
!	O
cmdprefix	int
)	O
return	O
1	int
;	O
if	O
(	O
(	O
*	O
ptr	pointer
)	O
[	O
0	int
]	O
==	O
cmdprefix	int
)	O
{	O
++	O
*	O
ptr	pointer
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
parse_script_file	function
(	O
const	O
char	O
*	O
fname	pointer
,	O
script_getln_fn	pointer
getln	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
char	O
*	O
buf	pointer
=	O
NULL	O
;	O
struct	O
dico_tokbuf	struct
tb	pointer
;	O
int	O
argc	int
;	O
char	O
*	O
*	O
argv	pointer
;	O
filename	pointer
=	O
fname	pointer
;	O
line	int
=	O
0	int
;	O
dico_tokenize_begin	function
(	O
&	O
tb	pointer
)	O
;	O
while	O
(	O
getln	pointer
(	O
data	pointer
,	O
&	O
buf	pointer
)	O
)	O
{	O
char	O
*	O
p	pointer
,	O
*	O
start	pointer
;	O
char	O
*	O
xargv	array
[	O
3	int
]	O
;	O
line	int
++	O
;	O
start	pointer
=	O
skipws	function
(	O
buf	pointer
)	O
;	O
dico_trim_nl	function
(	O
start	pointer
)	O
;	O
if	O
(	O
*	O
start	pointer
==	O
0	int
||	O
*	O
start	pointer
==	O
'#'	O
)	O
continue	O
;	O
xdico_tokenize_string	function
(	O
&	O
tb	pointer
,	O
start	pointer
)	O
;	O
argc	int
=	O
tb	pointer
.	O
tb_tokc	int
;	O
argv	pointer
=	O
tb	pointer
.	O
tb_tokv	pointer
;	O
if	O
(	O
argc	int
==	O
0	int
)	O
continue	O
;	O
p	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
switch	O
(	O
p	pointer
[	O
0	int
]	O
)	O
{	O
case	O
'/'	O
:	O
xargv	array
[	O
0	int
]	O
=	O
"match"	pointer
;	O
xargv	array
[	O
1	int
]	O
=	O
skipws	function
(	O
start	pointer
+	O
1	int
)	O
;	O
xargv	array
[	O
2	int
]	O
=	O
NULL	O
;	O
ds_match	function
(	O
2	int
,	O
xargv	array
)	O
;	O
continue	O
;	O
case	O
'?'	O
:	O
ds_help	function
(	O
0	int
,	O
NULL	O
)	O
;	O
continue	O
;	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
if	O
(	O
argc	int
==	O
1	int
)	O
{	O
char	O
*	O
q	pointer
;	O
size_t	long
num	int
=	O
strtoul	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
&	O
q	pointer
,	O
10	int
)	O
;	O
if	O
(	O
*	O
q	pointer
==	O
0	int
)	O
{	O
ds_define_nth	function
(	O
num	int
)	O
;	O
continue	O
;	O
}	O
}	O
}	O
if	O
(	O
is_command	function
(	O
&	O
p	pointer
)	O
)	O
{	O
struct	O
funtab	struct
*	O
ft	pointer
=	O
find_funtab	function
(	O
p	pointer
)	O
;	O
if	O
(	O
!	O
ft	pointer
)	O
{	O
script_error	function
(	O
_	O
(	O
"unknown command"	pointer
)	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
ft	pointer
->	O
argmin	int
==	O
0	int
)	O
{	O
argc	int
=	O
2	int
;	O
xargv	array
[	O
0	int
]	O
=	O
argv	pointer
[	O
0	int
]	O
;	O
xargv	array
[	O
1	int
]	O
=	O
skipws	function
(	O
buf	pointer
+	O
strlen	function
(	O
xargv	array
[	O
0	int
]	O
)	O
)	O
;	O
xargv	array
[	O
2	int
]	O
=	O
NULL	O
;	O
argv	pointer
=	O
xargv	array
;	O
}	O
else	O
if	O
(	O
argc	int
<	O
ft	pointer
->	O
argmin	int
)	O
{	O
script_error	function
(	O
_	O
(	O
"not enough arguments"	pointer
)	O
)	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
argc	int
>	O
ft	pointer
->	O
argmax	int
)	O
{	O
script_error	function
(	O
_	O
(	O
"too many arguments"	pointer
)	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
ft	pointer
->	O
fun	pointer
)	O
ft	pointer
->	O
fun	pointer
(	O
argc	int
,	O
argv	pointer
)	O
;	O
else	O
{	O
ds_silent_close	function
(	O
)	O
;	O
break	O
;	O
}	O
}	O
else	O
{	O
xargv	array
[	O
0	int
]	O
=	O
"define"	pointer
;	O
xargv	array
[	O
1	int
]	O
=	O
start	pointer
;	O
xargv	array
[	O
2	int
]	O
=	O
NULL	O
;	O
ds_define	function
(	O
2	int
,	O
xargv	array
)	O
;	O
}	O
}	O
dico_tokenize_end	function
(	O
&	O
tb	pointer
)	O
;	O
}	O
struct	O
init_script	struct
{	O
FILE	struct
*	O
fp	pointer
;	O
char	O
*	O
buf	pointer
;	O
size_t	long
size	long
;	O
}	O
;	O
int	O
script_getline	function
(	O
void	O
*	O
data	pointer
,	O
char	O
*	O
*	O
buf	pointer
)	O
{	O
struct	O
init_script	struct
*	O
p	pointer
=	O
data	pointer
;	O
int	O
rc	int
=	O
getline	function
(	O
&	O
p	pointer
->	O
buf	pointer
,	O
&	O
p	pointer
->	O
size	long
,	O
p	pointer
->	O
fp	pointer
)	O
;	O
*	O
buf	pointer
=	O
p	pointer
->	O
buf	pointer
;	O
return	O
rc	int
>	O
0	int
;	O
}	O
void	O
parse_init_script	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
init_script	struct
scr	struct
;	O
scr	struct
.	O
fp	pointer
=	O
fopen	function
(	O
name	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
!	O
scr	struct
.	O
fp	pointer
)	O
{	O
if	O
(	O
errno	O
!=	O
ENOENT	int
)	O
dico_log	function
(	O
L_ERR	int
,	O
errno	O
,	O
_	O
(	O
"Cannot open init file %s"	pointer
)	O
,	O
name	pointer
)	O
;	O
return	O
;	O
}	O
scr	struct
.	O
buf	pointer
=	O
NULL	O
;	O
scr	struct
.	O
size	long
=	O
0	int
;	O
parse_script_file	function
(	O
name	pointer
,	O
script_getline	function
,	O
&	O
scr	struct
)	O
;	O
fclose	function
(	O
scr	struct
.	O
fp	pointer
)	O
;	O
free	function
(	O
scr	struct
.	O
buf	pointer
)	O
;	O
}	O
void	O
parse_init_scripts	function
(	O
void	O
)	O
{	O
char	O
*	O
name	pointer
=	O
dico_full_file_name	function
(	O
get_homedir	function
(	O
)	O
,	O
".dico"	pointer
)	O
;	O
parse_init_script	function
(	O
name	pointer
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
parse_init_script	function
(	O
".dico"	pointer
)	O
;	O
}	O
static	O
void	O
ds_prompt	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
xdico_assign_string	function
(	O
&	O
prompt	pointer
,	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
}	O
char	O
*	O
*	O
dict_completion_matches	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
int	O
ws	pointer
,	O
char	O
*	O
(	O
*	O
generator	pointer
)	O
(	O
const	O
char	O
*	O
,	O
int	O
)	O
)	O
{	O
}	O
static	O
char	O
*	O
*	O
no_compl	function
(	O
int	O
argc	int
DICO_ARG_UNUSED	O
,	O
char	O
*	O
*	O
argv	pointer
DICO_ARG_UNUSED	O
,	O
int	O
ws	pointer
DICO_ARG_UNUSED	O
)	O
{	O
return	O
NULL	O
;	O
}	O
void	O
shell_init	function
(	O
struct	O
init_script	struct
*	O
p	pointer
)	O
{	O
interactive	int
=	O
isatty	function
(	O
fileno	function
(	O
stdin	pointer
)	O
)	O
;	O
p	pointer
->	O
fp	pointer
=	O
stdin	pointer
;	O
p	pointer
->	O
buf	pointer
=	O
NULL	O
;	O
p	pointer
->	O
size	long
=	O
0	int
;	O
}	O
void	O
shell_finish	function
(	O
struct	O
init_script	struct
*	O
p	pointer
)	O
{	O
free	function
(	O
p	pointer
->	O
buf	pointer
)	O
;	O
}	O
int	O
shell_getline	function
(	O
void	O
*	O
data	pointer
,	O
char	O
*	O
*	O
buf	pointer
)	O
{	O
if	O
(	O
interactive	int
)	O
{	O
fprintf	function
(	O
stdout	pointer
,	O
"%s"	pointer
,	O
prompt	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
}	O
return	O
script_getline	function
(	O
data	pointer
,	O
buf	pointer
)	O
;	O
}	O
void	O
dico_shell	function
(	O
void	O
)	O
{	O
struct	O
init_script	struct
dat	struct
;	O
shell_init	function
(	O
&	O
dat	struct
)	O
;	O
if	O
(	O
interactive	int
)	O
{	O
xdico_assign_string	function
(	O
&	O
prompt	pointer
,	O
DICO_PROMPT	pointer
)	O
;	O
if	O
(	O
!	O
quiet_option	int
)	O
shell_banner	function
(	O
)	O
;	O
}	O
if	O
(	O
!	O
cmdprefix	int
)	O
cmdprefix	int
=	O
'.'	O
;	O
parse_script_file	function
(	O
NULL	O
,	O
shell_getline	function
,	O
&	O
dat	struct
)	O
;	O
shell_finish	function
(	O
&	O
dat	struct
)	O
;	O
}	O
