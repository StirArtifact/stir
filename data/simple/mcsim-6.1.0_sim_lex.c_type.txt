PSTR	pointer
vrgszLexTypes	array
[	O
]	O
=	O
{	O
"null-type??"	pointer
,	O
"identifier"	pointer
,	O
"integer"	pointer
,	O
"integer-or-id"	pointer
,	O
"floating-point"	pointer
,	O
"float-or-id"	pointer
,	O
"number"	pointer
,	O
"number-or-id"	pointer
,	O
"punctuation"	pointer
,	O
"invalid lexical type"	pointer
,	O
"invalid lexical type"	pointer
,	O
"invalid lexical type"	pointer
,	O
"invalid lexical type"	pointer
,	O
"invalid lexical type"	pointer
,	O
"invalid lexical type"	pointer
,	O
"invalid lexical type"	pointer
,	O
"quoted-string"	pointer
,	O
""	pointer
}	O
;	O
void	O
PreventLexSplit	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
int	O
iOffset	int
)	O
{	O
long	O
lDelta	long
;	O
PBUF	pointer
pbufEOB	pointer
=	O
pibIn	pointer
->	O
pbufOrg	pointer
+	O
iOffset	int
;	O
PBUF	pointer
pbufEOBOld	pointer
;	O
if	O
(	O
!	O
EOB	O
(	O
pibIn	pointer
)	O
||	O
(	O
iOffset	int
==	O
BUFFER_SIZE	int
)	O
)	O
{	O
pbufEOBOld	pointer
=	O
pbufEOB	pointer
;	O
while	O
(	O
*	O
(	O
--	O
pbufEOB	pointer
)	O
!=	O
CH_EOLN	O
)	O
;	O
*	O
pbufEOB	pointer
=	O
'\0'	O
;	O
if	O
(	O
(	O
lDelta	long
=	O
(	O
long	O
)	O
(	O
pbufEOB	pointer
-	O
pbufEOBOld	pointer
)	O
)	O
)	O
fseek	function
(	O
pibIn	pointer
->	O
pfileIn	pointer
,	O
lDelta	long
,	O
SEEK_CUR	int
)	O
;	O
}	O
else	O
*	O
pbufEOB	pointer
=	O
'\0'	O
;	O
}	O
int	O
FillBuffer	function
(	O
PINPUTBUF	pointer
pibIn	pointer
)	O
{	O
int	O
iReturn	int
=	O
0	int
;	O
int	O
iOffset	int
;	O
if	O
(	O
pibIn	pointer
&&	O
pibIn	pointer
->	O
pfileIn	pointer
&&	O
pibIn	pointer
->	O
pbufOrg	pointer
)	O
{	O
if	O
(	O
(	O
iOffset	int
=	O
fread	function
(	O
pibIn	pointer
->	O
pbufOrg	pointer
,	O
1	int
,	O
BUFFER_SIZE	int
,	O
pibIn	pointer
->	O
pfileIn	pointer
)	O
)	O
)	O
{	O
iReturn	int
=	O
(	O
int	O
)	O
iOffset	int
;	O
PreventLexSplit	function
(	O
pibIn	pointer
,	O
iOffset	int
)	O
;	O
pibIn	pointer
->	O
pbufCur	pointer
=	O
pibIn	pointer
->	O
pbufOrg	pointer
;	O
}	O
else	O
if	O
(	O
feof	function
(	O
pibIn	pointer
->	O
pfileIn	pointer
)	O
)	O
iReturn	int
=	O
EOF	O
;	O
else	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_FATAL	int
,	O
"Unexpected end of file."	pointer
,	O
NULL	O
)	O
;	O
}	O
return	O
(	O
iReturn	int
)	O
;	O
}	O
BOOL	int
InitBuffer	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PSTR	pointer
szFullPathname	pointer
)	O
{	O
BOOL	int
bReturn	int
=	O
0	int
;	O
if	O
(	O
!	O
pibIn	pointer
)	O
return	O
FALSE	int
;	O
pibIn	pointer
->	O
iLineNum	int
=	O
1	int
;	O
pibIn	pointer
->	O
iLNPrev	int
=	O
0	int
;	O
pibIn	pointer
->	O
cErrors	int
=	O
0	int
;	O
pibIn	pointer
->	O
pInfo	pointer
=	O
NULL	O
;	O
pibIn	pointer
->	O
pbufCur	pointer
=	O
NULL	O
;	O
if	O
(	O
(	O
pibIn	pointer
->	O
pfileIn	pointer
=	O
fopen	function
(	O
szFullPathname	pointer
,	O
"r"	pointer
)	O
)	O
)	O
{	O
if	O
(	O
(	O
pibIn	pointer
->	O
pbufOrg	pointer
=	O
(	O
PBUF	pointer
)	O
malloc	function
(	O
BUFFER_SIZE	int
)	O
)	O
)	O
bReturn	int
=	O
FillBuffer	function
(	O
pibIn	pointer
)	O
;	O
else	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"InitBuffer"	pointer
,	O
NULL	O
)	O
;	O
}	O
else	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_FILENOTFOUND	int
|	O
RE_FATAL	int
,	O
szFullPathname	pointer
,	O
NULL	O
)	O
;	O
return	O
(	O
bReturn	int
)	O
;	O
}	O
void	O
MakeStringBuffer	function
(	O
PINPUTBUF	pointer
pBuf	pointer
,	O
PINPUTBUF	pointer
pbufStr	pointer
,	O
PSTR	pointer
sz	pointer
)	O
{	O
pbufStr	pointer
->	O
pfileIn	pointer
=	O
NULL	O
;	O
pbufStr	pointer
->	O
pbufCur	pointer
=	O
pbufStr	pointer
->	O
pbufOrg	pointer
=	O
sz	pointer
;	O
pbufStr	pointer
->	O
iLineNum	int
=	O
0	int
;	O
pbufStr	pointer
->	O
iLNPrev	int
=	O
0	int
;	O
pbufStr	pointer
->	O
pInfo	pointer
=	O
(	O
pBuf	pointer
?	O
pBuf	pointer
->	O
pInfo	pointer
:	O
NULL	O
)	O
;	O
if	O
(	O
pBuf	pointer
)	O
{	O
pbufStr	pointer
->	O
iLineNum	int
=	O
pBuf	pointer
->	O
iLineNum	int
;	O
pbufStr	pointer
->	O
iLNPrev	int
=	O
TRUE	int
;	O
}	O
}	O
void	O
FlushBuffer	function
(	O
PINPUTBUF	pointer
pibIn	pointer
)	O
{	O
PBUF	pointer
pbuf	pointer
=	O
pibIn	pointer
->	O
pbufOrg	pointer
;	O
while	O
(	O
*	O
pbuf	pointer
)	O
printf	function
(	O
"%c"	pointer
,	O
*	O
pbuf	pointer
++	O
)	O
;	O
printf	function
(	O
""	pointer
)	O
;	O
}	O
int	O
SkipWhitespace	function
(	O
PINPUTBUF	pointer
pibIn	pointer
)	O
{	O
char	O
c	char
;	O
int	O
fSkipped	int
=	O
0	int
;	O
if	O
(	O
!	O
pibIn	pointer
)	O
return	O
0	int
;	O
if	O
(	O
!	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
&&	O
pibIn	pointer
->	O
pfileIn	pointer
)	O
FillBuffer	function
(	O
pibIn	pointer
)	O
;	O
while	O
(	O
isspace	function
(	O
c	char
=	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
)	O
||	O
c	char
==	O
CH_COMMENT	O
)	O
{	O
fSkipped	int
=	O
1	int
;	O
if	O
(	O
c	char
==	O
CH_COMMENT	O
)	O
SkipComment	function
(	O
pibIn	pointer
)	O
;	O
else	O
{	O
if	O
(	O
c	char
==	O
'\n'	O
)	O
pibIn	pointer
->	O
iLineNum	int
++	O
;	O
if	O
(	O
!	O
*	O
(	O
++	O
pibIn	pointer
->	O
pbufCur	pointer
)	O
&&	O
pibIn	pointer
->	O
pfileIn	pointer
)	O
if	O
(	O
FillBuffer	function
(	O
pibIn	pointer
)	O
==	O
EOF	O
)	O
break	O
;	O
}	O
}	O
return	O
(	O
fSkipped	int
)	O
;	O
}	O
void	O
GetArrayBounds	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PLONG	pointer
piLB	pointer
,	O
PLONG	pointer
piUB	pointer
)	O
{	O
PSTRLEX	array
szTmp	array
;	O
if	O
(	O
ENextLex	function
(	O
pibIn	pointer
,	O
szTmp	array
,	O
LX_INTEGER	int
)	O
)	O
{	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_INIT	int
|	O
RE_FATAL	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
*	O
piLB	pointer
=	O
atol	function
(	O
szTmp	array
)	O
;	O
if	O
(	O
*	O
piLB	pointer
<	O
0	int
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_POSITIVE	int
|	O
RE_FATAL	int
,	O
szTmp	array
,	O
NULL	O
)	O
;	O
if	O
(	O
NextChar	function
(	O
pibIn	pointer
)	O
==	O
'-'	O
)	O
{	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
;	O
if	O
(	O
ENextLex	function
(	O
pibIn	pointer
,	O
szTmp	array
,	O
LX_INTEGER	int
)	O
)	O
{	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_INIT	int
|	O
RE_FATAL	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
*	O
piUB	pointer
=	O
atol	function
(	O
szTmp	array
)	O
+	O
1	int
;	O
if	O
(	O
*	O
piUB	pointer
<=	O
*	O
piLB	pointer
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_UNKNOWN	int
|	O
RE_FATAL	int
,	O
""	pointer
,	O
"Upper bound must be higher than lower bound"	pointer
)	O
;	O
}	O
if	O
(	O
!	O
GetPunct	function
(	O
pibIn	pointer
,	O
szTmp	array
,	O
']'	O
)	O
)	O
{	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
|	O
RE_FATAL	int
,	O
"]"	pointer
,	O
NULL	O
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
GetPunct	function
(	O
pibIn	pointer
,	O
szTmp	array
,	O
']'	O
)	O
)	O
{	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
|	O
RE_FATAL	int
,	O
"]"	pointer
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
*	O
piUB	pointer
=	O
*	O
piLB	pointer
+	O
1	int
;	O
}	O
}	O
}	O
}	O
void	O
GetaString	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PSTR	pointer
szLex	pointer
)	O
{	O
int	O
i	int
=	O
0	int
;	O
if	O
(	O
!	O
pibIn	pointer
||	O
!	O
szLex	pointer
)	O
return	O
;	O
if	O
(	O
IsString	O
(	O
(	O
PSTR	pointer
)	O
pibIn	pointer
->	O
pbufCur	pointer
)	O
)	O
{	O
do	O
szLex	pointer
[	O
i	int
++	O
]	O
=	O
*	O
++	O
pibIn	pointer
->	O
pbufCur	pointer
;	O
while	O
(	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
)	O
&&	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
!=	O
CH_STRDELIM	O
)	O
&&	O
(	O
i	int
<	O
MAX_LEX	int
-	O
1	int
)	O
)	O
;	O
}	O
if	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
==	O
CH_STRDELIM	O
)	O
{	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
;	O
i	int
--	O
;	O
}	O
szLex	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
}	O
void	O
GetIdentifier	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PSTR	pointer
szLex	pointer
)	O
{	O
int	O
i	int
=	O
0	int
;	O
if	O
(	O
!	O
pibIn	pointer
||	O
!	O
szLex	pointer
)	O
return	O
;	O
if	O
(	O
isalpha	function
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
)	O
||	O
IsUnderscore	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
)	O
)	O
{	O
do	O
szLex	pointer
[	O
i	int
++	O
]	O
=	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
;	O
while	O
(	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
)	O
&&	O
(	O
isalnum	function
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
)	O
||	O
IsUnderscore	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
)	O
)	O
&&	O
(	O
i	int
<	O
MAX_LEX	int
-	O
1	int
)	O
)	O
;	O
}	O
szLex	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
}	O
void	O
GetNumber	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PSTR	pointer
szLex	pointer
,	O
PINT	pointer
piLexType	pointer
)	O
{	O
int	O
i	int
=	O
0	int
;	O
char	O
c	char
;	O
BOOL	int
bHasSign	int
=	O
FALSE	int
;	O
BOOL	int
bLeadingDigits	int
=	O
FALSE	int
;	O
enum	O
States	enum
{	O
Start	int
,	O
Digits1	int
,	O
Point	int
,	O
Digits2	int
,	O
Exp	int
,	O
ExpSign	int
,	O
Digits3	int
,	O
End	int
}	O
eState	enum
;	O
if	O
(	O
!	O
pibIn	pointer
||	O
!	O
szLex	pointer
||	O
!	O
piLexType	pointer
)	O
return	O
;	O
eState	enum
=	O
Start	int
;	O
*	O
piLexType	pointer
=	O
LX_NULL	int
;	O
while	O
(	O
(	O
c	char
=	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
)	O
&&	O
i	int
<	O
MAX_LEX	int
-	O
1	int
&&	O
eState	enum
!=	O
End	int
)	O
{	O
switch	O
(	O
eState	enum
)	O
{	O
case	O
Start	int
:	O
if	O
(	O
c	char
==	O
'.'	O
)	O
eState	enum
=	O
Point	int
;	O
else	O
if	O
(	O
!	O
bHasSign	int
&&	O
IsSign	O
(	O
c	char
)	O
)	O
bHasSign	int
=	O
TRUE	int
;	O
else	O
if	O
(	O
isdigit	function
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
)	O
)	O
{	O
bLeadingDigits	int
=	O
*	O
piLexType	pointer
=	O
LX_INTEGER	int
;	O
eState	enum
=	O
Digits1	int
;	O
}	O
else	O
eState	enum
=	O
End	int
;	O
break	O
;	O
case	O
Digits1	int
:	O
if	O
(	O
c	char
==	O
'.'	O
)	O
eState	enum
=	O
Point	int
;	O
else	O
if	O
(	O
c	char
==	O
'e'	O
||	O
c	char
==	O
'E'	O
)	O
eState	enum
=	O
Exp	int
;	O
else	O
if	O
(	O
!	O
isdigit	function
(	O
c	char
)	O
)	O
eState	enum
=	O
End	int
;	O
break	O
;	O
case	O
Point	int
:	O
*	O
piLexType	pointer
=	O
LX_FLOAT	int
;	O
if	O
(	O
bLeadingDigits	int
&&	O
(	O
c	char
==	O
'e'	O
||	O
c	char
==	O
'E'	O
)	O
)	O
eState	enum
=	O
Exp	int
;	O
else	O
if	O
(	O
isdigit	function
(	O
c	char
)	O
)	O
eState	enum
=	O
Digits2	int
;	O
else	O
{	O
if	O
(	O
!	O
bLeadingDigits	int
)	O
*	O
piLexType	pointer
=	O
LX_NULL	int
;	O
eState	enum
=	O
End	int
;	O
}	O
break	O
;	O
case	O
Digits2	int
:	O
if	O
(	O
c	char
==	O
'e'	O
||	O
c	char
==	O
'E'	O
)	O
eState	enum
=	O
Exp	int
;	O
else	O
if	O
(	O
!	O
isdigit	function
(	O
c	char
)	O
)	O
eState	enum
=	O
End	int
;	O
break	O
;	O
case	O
Exp	int
:	O
*	O
piLexType	pointer
=	O
LX_FLOAT	int
;	O
if	O
(	O
IsSign	O
(	O
c	char
)	O
)	O
{	O
eState	enum
=	O
ExpSign	int
;	O
break	O
;	O
}	O
case	O
ExpSign	int
:	O
if	O
(	O
isdigit	function
(	O
c	char
)	O
)	O
eState	enum
=	O
Digits3	int
;	O
else	O
{	O
*	O
piLexType	pointer
=	O
LX_NULL	int
;	O
eState	enum
=	O
End	int
;	O
}	O
break	O
;	O
case	O
Digits3	int
:	O
if	O
(	O
!	O
isdigit	function
(	O
c	char
)	O
)	O
eState	enum
=	O
End	int
;	O
break	O
;	O
case	O
End	int
:	O
break	O
;	O
}	O
if	O
(	O
eState	enum
!=	O
End	int
)	O
szLex	pointer
[	O
i	int
++	O
]	O
=	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
;	O
}	O
szLex	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
}	O
void	O
NextLex	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PSTRLEX	array
szLex	pointer
,	O
PINT	pointer
piLexType	pointer
)	O
{	O
char	O
c	char
;	O
BOOL	int
fDone	int
=	O
FALSE	int
;	O
*	O
piLexType	pointer
=	O
LX_NULL	int
;	O
if	O
(	O
!	O
pibIn	pointer
||	O
!	O
szLex	pointer
||	O
!	O
piLexType	pointer
||	O
!	O
pibIn	pointer
->	O
pbufCur	pointer
)	O
return	O
;	O
while	O
(	O
!	O
fDone	int
)	O
{	O
fDone	int
=	O
TRUE	int
;	O
SkipWhitespace	function
(	O
pibIn	pointer
)	O
;	O
if	O
(	O
!	O
EOB	O
(	O
pibIn	pointer
)	O
)	O
{	O
c	char
=	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
;	O
if	O
(	O
c	char
==	O
CH_COMMENT	O
)	O
{	O
fDone	int
=	O
FALSE	int
;	O
SkipComment	function
(	O
pibIn	pointer
)	O
;	O
}	O
else	O
if	O
(	O
isalpha	function
(	O
c	char
)	O
||	O
IsUnderscore	O
(	O
c	char
)	O
)	O
{	O
*	O
piLexType	pointer
=	O
LX_IDENTIFIER	int
;	O
GetIdentifier	function
(	O
pibIn	pointer
,	O
szLex	pointer
)	O
;	O
}	O
else	O
if	O
(	O
isdigit	function
(	O
c	char
)	O
||	O
c	char
==	O
'.'	O
||	O
IsSign	O
(	O
c	char
)	O
)	O
{	O
GetNumber	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
piLexType	pointer
)	O
;	O
if	O
(	O
IsSign	O
(	O
c	char
)	O
&&	O
!	O
*	O
piLexType	pointer
)	O
{	O
szLex	pointer
[	O
0	int
]	O
=	O
c	char
;	O
szLex	pointer
[	O
1	int
]	O
=	O
'\0'	O
;	O
*	O
piLexType	pointer
=	O
LX_PUNCT	int
;	O
}	O
}	O
else	O
if	O
(	O
c	char
==	O
CH_STRDELIM	O
)	O
{	O
*	O
piLexType	pointer
=	O
LX_STRING	int
;	O
GetaString	function
(	O
pibIn	pointer
,	O
szLex	pointer
)	O
;	O
}	O
else	O
{	O
*	O
piLexType	pointer
=	O
LX_PUNCT	int
;	O
szLex	pointer
[	O
0	int
]	O
=	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
;	O
szLex	pointer
[	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
}	O
}	O
}	O
BOOL	int
ENextLex	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PSTRLEX	array
szLex	pointer
,	O
int	O
iType	int
)	O
{	O
int	O
iLex	int
,	O
iErr	int
;	O
NextLex	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
&	O
iLex	int
)	O
;	O
if	O
(	O
(	O
iErr	int
=	O
!	O
(	O
iType	int
&	O
iLex	int
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
,	O
vrgszLexTypes	array
[	O
iType	int
]	O
,	O
szLex	pointer
)	O
;	O
return	O
(	O
iErr	int
)	O
;	O
}	O
void	O
SkipComment	function
(	O
PINPUTBUF	pointer
pibIn	pointer
)	O
{	O
if	O
(	O
!	O
pibIn	pointer
)	O
return	O
;	O
if	O
(	O
!	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
)	O
FillBuffer	function
(	O
pibIn	pointer
)	O
;	O
while	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
!=	O
CH_EOLN	O
)	O
if	O
(	O
!	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
)	O
if	O
(	O
FillBuffer	function
(	O
pibIn	pointer
)	O
==	O
EOF	O
)	O
break	O
;	O
pibIn	pointer
->	O
iLineNum	int
++	O
;	O
if	O
(	O
!	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
)	O
FillBuffer	function
(	O
pibIn	pointer
)	O
;	O
}	O
char	O
NextChar	function
(	O
PINPUTBUF	pointer
pibIn	pointer
)	O
{	O
if	O
(	O
!	O
pibIn	pointer
||	O
(	O
!	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
&&	O
FillBuffer	function
(	O
pibIn	pointer
)	O
==	O
EOF	O
)	O
)	O
return	O
(	O
0	int
)	O
;	O
else	O
return	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
)	O
;	O
}	O
int	O
GetOptPunct	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PSTR	pointer
szLex	pointer
,	O
char	O
chPunct	char
)	O
{	O
int	O
iReturn	int
,	O
iType	int
;	O
iReturn	int
=	O
SkipWhitespace	function
(	O
pibIn	pointer
)	O
;	O
if	O
(	O
NextChar	function
(	O
pibIn	pointer
)	O
==	O
chPunct	char
)	O
{	O
iReturn	int
=	O
TRUE	int
;	O
NextLex	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
&	O
iType	int
)	O
;	O
}	O
return	O
(	O
iReturn	int
)	O
;	O
}	O
int	O
GetPunct	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PSTR	pointer
szLex	pointer
,	O
char	O
chPunct	char
)	O
{	O
int	O
iType	int
;	O
NextLex	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
&	O
iType	int
)	O
;	O
return	O
(	O
(	O
iType	int
==	O
LX_PUNCT	int
)	O
&&	O
szLex	pointer
[	O
0	int
]	O
==	O
chPunct	char
)	O
;	O
}	O
int	O
EGetPunct	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PSTR	pointer
szLex	pointer
,	O
char	O
chPunct	char
)	O
{	O
int	O
iReturn	int
;	O
iReturn	int
=	O
!	O
GetPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
chPunct	char
)	O
;	O
if	O
(	O
iReturn	int
)	O
{	O
szLex	pointer
[	O
1	int
]	O
=	O
chPunct	char
;	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_EXPECTED	int
,	O
szLex	pointer
,	O
NULL	O
)	O
;	O
}	O
return	O
(	O
iReturn	int
)	O
;	O
}	O
void	O
EatStatement	function
(	O
PINPUTBUF	pointer
pib	pointer
)	O
{	O
char	O
c	char
;	O
if	O
(	O
!	O
pib	pointer
)	O
return	O
;	O
while	O
(	O
(	O
c	char
=	O
NextChar	function
(	O
pib	pointer
)	O
)	O
&&	O
(	O
c	char
!=	O
CH_STMTTERM	O
)	O
)	O
{	O
if	O
(	O
c	char
==	O
CH_EOLN	O
)	O
pib	pointer
->	O
iLineNum	int
++	O
;	O
pib	pointer
->	O
pbufCur	pointer
++	O
;	O
}	O
if	O
(	O
c	char
)	O
pib	pointer
->	O
pbufCur	pointer
++	O
;	O
}	O
void	O
GetStatement	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PSTR	pointer
szStmt	pointer
)	O
{	O
int	O
i	int
,	O
fDone	int
=	O
0	int
;	O
if	O
(	O
!	O
pibIn	pointer
||	O
!	O
szStmt	pointer
)	O
return	O
;	O
SkipWhitespace	function
(	O
pibIn	pointer
)	O
;	O
i	int
=	O
0	int
;	O
if	O
(	O
!	O
EOB	O
(	O
pibIn	pointer
)	O
)	O
{	O
while	O
(	O
!	O
fDone	int
)	O
{	O
if	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
)	O
{	O
if	O
(	O
!	O
(	O
fDone	int
=	O
(	O
NextChar	function
(	O
pibIn	pointer
)	O
==	O
CH_STMTTERM	O
)	O
)	O
)	O
{	O
if	O
(	O
i	int
<	O
MAX_EQN	int
-	O
2	int
)	O
{	O
if	O
(	O
(	O
szStmt	pointer
[	O
i	int
++	O
]	O
=	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
)	O
==	O
CH_EOLN	O
)	O
pibIn	pointer
->	O
iLineNum	int
++	O
;	O
}	O
else	O
{	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_EQNTOOLONG	int
|	O
RE_FATAL	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
}	O
}	O
else	O
{	O
fDone	int
=	O
(	O
FillBuffer	function
(	O
pibIn	pointer
)	O
==	O
EOF	O
)	O
;	O
}	O
}	O
szStmt	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
!	O
i	int
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
|	O
RE_FATAL	int
,	O
"rvalue to assignment"	pointer
,	O
NULL	O
)	O
;	O
}	O
int	O
NextListItem	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PSTR	pointer
szLex	pointer
,	O
int	O
bIdTypes	int
,	O
int	O
fItemNum	int
,	O
char	O
cListTerm	char
)	O
{	O
int	O
iType	int
,	O
iReturn	int
=	O
0	int
;	O
if	O
(	O
!	O
fItemNum	int
||	O
GetOptPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
','	O
)	O
)	O
{	O
if	O
(	O
NextChar	function
(	O
pibIn	pointer
)	O
!=	O
cListTerm	char
)	O
{	O
NextLex	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
&	O
iType	int
)	O
;	O
if	O
(	O
iType	int
&	O
bIdTypes	int
)	O
iReturn	int
=	O
1	int
;	O
else	O
iReturn	int
=	O
-	O
1	int
;	O
}	O
}	O
return	O
(	O
iReturn	int
)	O
;	O
}	O
BOOL	int
GetFuncArgs	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
int	O
nArgs	int
,	O
int	O
rgiArgTypes	array
[	O
]	O
,	O
PSTR	pointer
szArgs	pointer
)	O
{	O
BOOL	int
bOK	int
=	O
TRUE	int
;	O
int	O
i	int
,	O
iType	int
;	O
PSTRLEX	array
szPunct	array
;	O
if	O
(	O
!	O
(	O
bOK	int
=	O
GetPunct	function
(	O
pibIn	pointer
,	O
szPunct	array
,	O
CH_LPAREN	O
)	O
)	O
)	O
{	O
szPunct	array
[	O
1	int
]	O
=	O
CH_LPAREN	O
;	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_EXPECTED	int
,	O
szPunct	array
,	O
NULL	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nArgs	int
&&	O
bOK	int
;	O
i	int
++	O
,	O
szArgs	pointer
+=	O
MAX_LEX	int
)	O
{	O
if	O
(	O
i	int
)	O
if	O
(	O
!	O
(	O
bOK	int
=	O
GetOptPunct	function
(	O
pibIn	pointer
,	O
szArgs	pointer
,	O
','	O
)	O
)	O
)	O
{	O
*	O
(	O
szArgs	pointer
+	O
1	int
)	O
=	O
','	O
;	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_EXPECTED	int
,	O
szArgs	pointer
,	O
NULL	O
)	O
;	O
return	O
(	O
bOK	int
)	O
;	O
}	O
NextLex	function
(	O
pibIn	pointer
,	O
szArgs	pointer
,	O
&	O
iType	int
)	O
;	O
if	O
(	O
!	O
(	O
bOK	int
&=	O
(	O
iType	int
&	O
rgiArgTypes	array
[	O
i	int
]	O
)	O
>	O
0	int
)	O
)	O
{	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
,	O
vrgszLexTypes	array
[	O
rgiArgTypes	array
[	O
i	int
]	O
]	O
,	O
szArgs	pointer
)	O
;	O
return	O
(	O
bOK	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
(	O
bOK	int
=	O
GetPunct	function
(	O
pibIn	pointer
,	O
szPunct	array
,	O
CH_RPAREN	O
)	O
)	O
)	O
{	O
szPunct	array
[	O
1	int
]	O
=	O
CH_RPAREN	O
;	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_EXPECTED	int
,	O
szPunct	array
,	O
NULL	O
)	O
;	O
}	O
return	O
(	O
bOK	int
)	O
;	O
}	O
void	O
UnrollEquation	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
long	O
index	function
,	O
PSTR	pointer
szEqn	pointer
,	O
PSTR	pointer
szEqnU	pointer
)	O
{	O
int	O
j	int
=	O
0	int
,	O
k	int
=	O
0	int
,	O
m	int
;	O
BOOL	int
bExpress	int
=	O
FALSE	int
;	O
PSTRLEX	array
szExpression	array
;	O
while	O
(	O
(	O
szEqn	pointer
[	O
j	int
]	O
!=	O
'\0'	O
)	O
&&	O
(	O
k	int
<	O
MAX_EQN	int
-	O
1	int
)	O
)	O
{	O
if	O
(	O
bExpress	int
)	O
{	O
m	int
=	O
0	int
;	O
while	O
(	O
(	O
szEqn	pointer
[	O
j	int
]	O
!=	O
'\0'	O
)	O
&&	O
(	O
szEqn	pointer
[	O
j	int
]	O
!=	O
']'	O
)	O
&&	O
(	O
m	int
<	O
MAX_EQN	int
-	O
1	int
)	O
)	O
{	O
szExpression	array
[	O
m	int
]	O
=	O
szEqn	pointer
[	O
j	int
]	O
;	O
j	int
++	O
;	O
m	int
++	O
;	O
}	O
if	O
(	O
szEqn	pointer
[	O
j	int
]	O
==	O
']'	O
)	O
{	O
j	int
++	O
;	O
bExpress	int
=	O
FALSE	int
;	O
}	O
if	O
(	O
(	O
szEqn	pointer
[	O
j	int
]	O
!=	O
'\0'	O
)	O
&&	O
(	O
m	int
==	O
MAX_EQN	int
-	O
1	int
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_EQNTOOLONG	int
|	O
RE_FATAL	int
,	O
NULL	O
,	O
"(Occured while unrolling a loop)"	pointer
)	O
;	O
szExpression	array
[	O
m	int
]	O
=	O
'\0'	O
;	O
m	int
=	O
0	int
;	O
while	O
(	O
(	O
szExpression	array
[	O
m	int
]	O
!=	O
'\0'	O
)	O
&&	O
(	O
m	int
<	O
MAX_EQN	int
-	O
1	int
)	O
)	O
{	O
szEqnU	pointer
[	O
k	int
]	O
=	O
szExpression	array
[	O
m	int
]	O
;	O
k	int
++	O
;	O
m	int
++	O
;	O
}	O
}	O
else	O
switch	O
(	O
szEqn	pointer
[	O
j	int
]	O
)	O
{	O
case	O
'['	O
:	O
szEqnU	pointer
[	O
k	int
]	O
=	O
'_'	O
;	O
j	int
++	O
;	O
k	int
++	O
;	O
bExpress	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
']'	O
:	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_UNEXPECTED	int
|	O
RE_FATAL	int
,	O
"]"	pointer
,	O
"(Could be nested brackets)"	pointer
)	O
;	O
default	O
:	O
szEqnU	pointer
[	O
k	int
]	O
=	O
szEqn	pointer
[	O
j	int
]	O
;	O
j	int
++	O
;	O
k	int
++	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
(	O
szEqn	pointer
[	O
j	int
]	O
!=	O
'\0'	O
)	O
&&	O
(	O
k	int
==	O
MAX_EQN	int
-	O
1	int
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_EQNTOOLONG	int
|	O
RE_FATAL	int
,	O
NULL	O
,	O
"(Occured in UnrollEquation)"	pointer
)	O
;	O
szEqnU	pointer
[	O
k	int
]	O
=	O
'\0'	O
;	O
}	O
