struct	O
mem	struct
*	O
stack_top	pointer
=	O
NULL	O
;	O
struct	O
dsa	struct
*	O
active_dsa	pointer
=	O
NULL	O
;	O
struct	O
dsa	struct
*	O
global_dsa	pointer
=	O
NULL	O
;	O
int	O
real2int	function
(	O
double	O
x	double
)	O
{	O
x	double
=	O
floor	function
(	O
x	double
+	O
0.5	int
)	O
;	O
if	O
(	O
!	O
(	O
(	O
double	O
)	O
INT_MIN	O
<=	O
x	double
&&	O
x	double
<=	O
(	O
double	O
)	O
INT_MAX	O
)	O
)	O
fault	function
(	O
"real number to be converted out of integer range"	pointer
)	O
;	O
return	O
(	O
int	O
)	O
x	double
;	O
}	O
double	O
int2real	function
(	O
int	O
x	double
)	O
{	O
return	O
(	O
double	O
)	O
x	double
;	O
}	O
double	O
expr	function
(	O
double	O
x	double
,	O
double	O
r	double
)	O
{	O
double	O
ret	double
;	O
if	O
(	O
x	double
>	O
0.0	int
)	O
ret	double
=	O
pow	function
(	O
x	double
,	O
r	double
)	O
;	O
else	O
if	O
(	O
x	double
==	O
0.0	int
&&	O
r	double
>	O
0.0	int
)	O
ret	double
=	O
0.0	int
;	O
else	O
fault	function
(	O
"expr undefined "	pointer
REAL_FMT	pointer
,	O
x	double
)	O
;	O
return	O
ret	double
;	O
}	O
int	O
expi	function
(	O
int	O
i	int
,	O
int	O
j	int
)	O
{	O
int	O
ret	double
;	O
unsigned	O
u	union
;	O
if	O
(	O
j	int
<	O
0	int
||	O
(	O
i	int
==	O
0	int
&&	O
j	int
==	O
0	int
)	O
)	O
fault	function
(	O
"expi undefined %d"	pointer
,	O
j	int
)	O
;	O
ret	double
=	O
1	int
;	O
u	union
=	O
j	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
u	union
&	O
1	int
)	O
ret	double
*=	O
i	int
;	O
if	O
(	O
u	union
>>=	O
1	int
)	O
i	int
*=	O
i	int
;	O
else	O
break	O
;	O
}	O
return	O
ret	double
;	O
}	O
double	O
expn	function
(	O
double	O
x	double
,	O
int	O
n	int
)	O
{	O
double	O
ret	double
;	O
unsigned	O
u	union
;	O
if	O
(	O
n	int
==	O
0	int
&&	O
x	double
==	O
0.0	int
)	O
fault	function
(	O
"expn undefined "	pointer
REAL_FMT	pointer
,	O
x	double
)	O
;	O
ret	double
=	O
1.0	int
;	O
u	union
=	O
(	O
n	int
>=	O
0	int
?	O
n	int
:	O
(	O
x	double
=	O
1.0	int
/	O
x	double
,	O
-	O
n	int
)	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
u	union
&	O
1	int
)	O
ret	double
*=	O
x	double
;	O
if	O
(	O
u	union
>>=	O
1	int
)	O
x	double
*=	O
x	double
;	O
else	O
break	O
;	O
}	O
return	O
ret	double
;	O
}	O
double	O
get_real	function
(	O
struct	O
desc	struct
x	double
)	O
{	O
double	O
val	double
;	O
switch	O
(	O
x	double
.	O
type	int
)	O
{	O
case	O
'r'	O
:	O
val	double
=	O
(	O
x	double
.	O
lval	int
?	O
*	O
x	double
.	O
u	union
.	O
real_ptr	pointer
:	O
x	double
.	O
u	union
.	O
real_val	double
)	O
;	O
break	O
;	O
case	O
'i'	O
:	O
val	double
=	O
int2real	function
(	O
x	double
.	O
lval	int
?	O
*	O
x	double
.	O
u	union
.	O
int_ptr	pointer
:	O
x	double
.	O
u	union
.	O
int_val	int
)	O
;	O
break	O
;	O
default	O
:	O
fault	function
(	O
"evaluation of a real formal parameter not possible b"	pointer
"ecause final actual parameter is not of arithmetic type"	pointer
)	O
;	O
}	O
return	O
val	double
;	O
}	O
int	O
get_int	function
(	O
struct	O
desc	struct
x	double
)	O
{	O
int	O
val	double
;	O
switch	O
(	O
x	double
.	O
type	int
)	O
{	O
case	O
'r'	O
:	O
val	double
=	O
real2int	function
(	O
x	double
.	O
lval	int
?	O
*	O
x	double
.	O
u	union
.	O
real_ptr	pointer
:	O
x	double
.	O
u	union
.	O
real_val	double
)	O
;	O
break	O
;	O
case	O
'i'	O
:	O
val	double
=	O
(	O
x	double
.	O
lval	int
?	O
*	O
x	double
.	O
u	union
.	O
int_ptr	pointer
:	O
x	double
.	O
u	union
.	O
int_val	int
)	O
;	O
break	O
;	O
default	O
:	O
fault	function
(	O
"evaluation of an integer formal parameter not possib"	pointer
"le because final actual parameter is not of arithmetic "	pointer
"type"	pointer
)	O
;	O
}	O
return	O
val	double
;	O
}	O
bool	int
get_bool	function
(	O
struct	O
desc	struct
x	double
)	O
{	O
bool	int
val	double
;	O
switch	O
(	O
x	double
.	O
type	int
)	O
{	O
case	O
'b'	O
:	O
val	double
=	O
(	O
x	double
.	O
lval	int
?	O
*	O
x	double
.	O
u	union
.	O
bool_ptr	pointer
:	O
x	double
.	O
u	union
.	O
bool_val	int
)	O
;	O
break	O
;	O
default	O
:	O
fault	function
(	O
"evaluation of a Boolean formal parameter not possibl"	pointer
"e because final actual parameter is not of Boolean type"	pointer
)	O
;	O
}	O
return	O
val	double
;	O
}	O
struct	O
label	struct
get_label	function
(	O
struct	O
desc	struct
x	double
)	O
{	O
switch	O
(	O
x	double
.	O
type	int
)	O
{	O
case	O
'l'	O
:	O
assert	O
(	O
!	O
x	double
.	O
lval	int
)	O
;	O
break	O
;	O
default	O
:	O
fault	function
(	O
"evaluation of a formal label not possible because fi"	pointer
"nal actual parameter is not of label type"	pointer
)	O
;	O
}	O
return	O
x	double
.	O
u	union
.	O
label	struct
;	O
}	O
double	O
set_real	function
(	O
struct	O
desc	struct
x	double
,	O
double	O
val	double
)	O
{	O
if	O
(	O
!	O
x	double
.	O
lval	int
)	O
fault	function
(	O
"assignment to a real formal parameter called by name no"	pointer
"t possible because final actual parameter is not a variabl"	pointer
"e"	pointer
)	O
;	O
switch	O
(	O
x	double
.	O
type	int
)	O
{	O
case	O
'r'	O
:	O
*	O
x	double
.	O
u	union
.	O
real_ptr	pointer
=	O
val	double
;	O
break	O
;	O
case	O
'i'	O
:	O
*	O
x	double
.	O
u	union
.	O
int_ptr	pointer
=	O
real2int	function
(	O
val	double
)	O
;	O
break	O
;	O
default	O
:	O
fault	function
(	O
"assignment to a real formal parameter called by name"	pointer
" not possible because final actual parameter is not of "	pointer
"arithmetic type"	pointer
)	O
;	O
}	O
return	O
val	double
;	O
}	O
int	O
set_int	function
(	O
struct	O
desc	struct
x	double
,	O
int	O
val	double
)	O
{	O
if	O
(	O
!	O
x	double
.	O
lval	int
)	O
fault	function
(	O
"assignment to an integer formal parameter called by nam"	pointer
"e not possible because final actual parameter is not a var"	pointer
"iable"	pointer
)	O
;	O
switch	O
(	O
x	double
.	O
type	int
)	O
{	O
case	O
'r'	O
:	O
*	O
x	double
.	O
u	union
.	O
real_ptr	pointer
=	O
int2real	function
(	O
val	double
)	O
;	O
break	O
;	O
case	O
'i'	O
:	O
*	O
x	double
.	O
u	union
.	O
int_ptr	pointer
=	O
val	double
;	O
break	O
;	O
default	O
:	O
fault	function
(	O
"assignment to an integer formal parameter called by "	pointer
"name not possible because final actual parameter is not"	pointer
" of arithmetic type"	pointer
)	O
;	O
}	O
return	O
val	double
;	O
}	O
bool	int
set_bool	function
(	O
struct	O
desc	struct
x	double
,	O
bool	int
val	double
)	O
{	O
if	O
(	O
!	O
x	double
.	O
lval	int
)	O
fault	function
(	O
"assignment to a Boolean formal parameter called by name"	pointer
" not possible because final actual parameter is not a vari"	pointer
"able"	pointer
)	O
;	O
switch	O
(	O
x	double
.	O
type	int
)	O
{	O
case	O
'b'	O
:	O
*	O
x	double
.	O
u	union
.	O
bool_ptr	pointer
=	O
val	double
;	O
break	O
;	O
default	O
:	O
fault	function
(	O
"assignment to a Boolean formal parameter called by n"	pointer
"ame not possible because final actual parameter is not "	pointer
"of Boolean type"	pointer
)	O
;	O
}	O
return	O
val	double
;	O
}	O
struct	O
arg	struct
make_arg	function
(	O
void	O
*	O
arg1	pointer
,	O
void	O
*	O
arg2	pointer
)	O
{	O
struct	O
arg	struct
arg	struct
;	O
arg	struct
.	O
arg1	pointer
=	O
arg1	pointer
;	O
arg	struct
.	O
arg2	pointer
=	O
arg2	pointer
;	O
return	O
arg	struct
;	O
}	O
struct	O
label	struct
make_label	function
(	O
void	O
*	O
jump	pointer
,	O
int	O
kase	int
)	O
{	O
struct	O
label	struct
x	double
;	O
x	double
.	O
jump	pointer
=	O
jump	pointer
;	O
x	double
.	O
kase	int
=	O
kase	int
;	O
return	O
x	double
;	O
}	O
void	O
go_to	function
(	O
struct	O
label	struct
x	double
)	O
{	O
longjmp	function
(	O
x	double
.	O
jump	pointer
,	O
x	double
.	O
kase	int
)	O
;	O
}	O
static	O
void	O
*	O
my_malloc	function
(	O
int	O
size	int
)	O
{	O
void	O
*	O
ptr	pointer
;	O
assert	O
(	O
size	int
>	O
0	int
)	O
;	O
ptr	pointer
=	O
malloc	function
(	O
size	int
)	O
;	O
if	O
(	O
ptr	pointer
==	O
NULL	O
)	O
fault	function
(	O
"main storage requested not available"	pointer
)	O
;	O
return	O
ptr	pointer
;	O
}	O
static	O
void	O
my_free	function
(	O
void	O
*	O
ptr	pointer
)	O
{	O
assert	O
(	O
ptr	pointer
!=	O
NULL	O
)	O
;	O
free	function
(	O
ptr	pointer
)	O
;	O
return	O
;	O
}	O
static	O
void	O
*	O
push_stack	function
(	O
int	O
size	int
)	O
{	O
struct	O
mem	struct
*	O
top	pointer
;	O
assert	O
(	O
size	int
>	O
0	int
)	O
;	O
if	O
(	O
size	int
>	O
INT_MAX	O
-	O
offsetof	O
(	O
struct	O
mem	struct
,	O
body	array
)	O
)	O
fault	function
(	O
"main storage requested not available"	pointer
)	O
;	O
top	pointer
=	O
my_malloc	function
(	O
offsetof	O
(	O
struct	O
mem	struct
,	O
body	array
)	O
+	O
size	int
)	O
;	O
top	pointer
->	O
size	int
=	O
size	int
;	O
top	pointer
->	O
ptr	pointer
=	O
stack_top	pointer
;	O
stack_top	pointer
=	O
top	pointer
;	O
return	O
&	O
top	pointer
->	O
body	array
;	O
}	O
void	O
pop_stack	function
(	O
struct	O
mem	struct
*	O
top	pointer
)	O
{	O
while	O
(	O
stack_top	pointer
!=	O
top	pointer
)	O
{	O
struct	O
mem	struct
*	O
ptr	pointer
;	O
ptr	pointer
=	O
stack_top	pointer
;	O
stack_top	pointer
=	O
stack_top	pointer
->	O
ptr	pointer
;	O
my_free	function
(	O
ptr	pointer
)	O
;	O
}	O
return	O
;	O
}	O
static	O
struct	O
dv	struct
*	O
copy_dv	function
(	O
int	O
own	int
,	O
struct	O
dv	struct
*	O
dope	pointer
)	O
{	O
struct	O
dv	struct
*	O
dv	struct
;	O
int	O
size	int
;	O
assert	O
(	O
1	int
<=	O
dope	pointer
->	O
n	int
&&	O
dope	pointer
->	O
n	int
<=	O
9	int
)	O
;	O
size	int
=	O
offsetof	O
(	O
struct	O
dv	struct
,	O
d	array
[	O
dope	pointer
->	O
n	int
]	O
)	O
;	O
dv	struct
=	O
own	int
?	O
my_malloc	function
(	O
size	int
)	O
:	O
push_stack	function
(	O
size	int
)	O
;	O
memcpy	function
(	O
dv	struct
,	O
dope	pointer
,	O
size	int
)	O
;	O
return	O
dv	struct
;	O
}	O
static	O
struct	O
dv	struct
*	O
make_dv	function
(	O
int	O
own	int
,	O
int	O
n	int
,	O
va_list	array
arg	struct
)	O
{	O
struct	O
dv	struct
dv	struct
;	O
int	O
k	int
;	O
assert	O
(	O
1	int
<=	O
n	int
&&	O
n	int
<=	O
9	int
)	O
;	O
dv	struct
.	O
base	pointer
=	O
NULL	O
;	O
dv	struct
.	O
n	int
=	O
n	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
n	int
;	O
k	int
++	O
)	O
{	O
dv	struct
.	O
d	array
[	O
k	int
]	O
.	O
lo	int
=	O
va_arg	O
(	O
arg	struct
,	O
int	O
)	O
;	O
dv	struct
.	O
d	array
[	O
k	int
]	O
.	O
up	int
=	O
va_arg	O
(	O
arg	struct
,	O
int	O
)	O
;	O
}	O
return	O
copy_dv	function
(	O
own	int
,	O
&	O
dv	struct
)	O
;	O
}	O
static	O
int	O
array_size	function
(	O
int	O
type	int
,	O
struct	O
dv	struct
*	O
dv	struct
)	O
{	O
int	O
size	int
,	O
k	int
;	O
switch	O
(	O
type	int
)	O
{	O
case	O
'r'	O
:	O
size	int
=	O
sizeof	O
(	O
double	O
)	O
;	O
break	O
;	O
case	O
'i'	O
:	O
size	int
=	O
sizeof	O
(	O
int	O
)	O
;	O
break	O
;	O
case	O
'b'	O
:	O
size	int
=	O
sizeof	O
(	O
bool	int
)	O
;	O
break	O
;	O
default	O
:	O
assert	O
(	O
type	int
!=	O
type	int
)	O
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
dv	struct
->	O
n	int
;	O
k	int
++	O
)	O
if	O
(	O
dv	struct
->	O
d	array
[	O
k	int
]	O
.	O
lo	int
>	O
dv	struct
->	O
d	array
[	O
k	int
]	O
.	O
up	int
)	O
return	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
dv	struct
->	O
n	int
;	O
k	int
++	O
)	O
{	O
int	O
lo	int
=	O
dv	struct
->	O
d	array
[	O
k	int
]	O
.	O
lo	int
;	O
int	O
up	int
=	O
dv	struct
->	O
d	array
[	O
k	int
]	O
.	O
up	int
;	O
int	O
t	int
;	O
if	O
(	O
lo	int
<	O
0	int
&&	O
up	int
>	O
(	O
INT_MAX	O
+	O
lo	int
)	O
-	O
1	int
)	O
too	O
:	O
fault	function
(	O
"unable to allocate too long array"	pointer
)	O
;	O
t	int
=	O
up	int
-	O
lo	int
+	O
1	int
;	O
if	O
(	O
size	int
>	O
INT_MAX	O
/	O
t	int
)	O
goto	O
too	O
;	O
size	int
*=	O
t	int
;	O
}	O
return	O
size	int
;	O
}	O
struct	O
dv	struct
*	O
alloc_array	function
(	O
int	O
type	int
,	O
int	O
n	int
,	O
...	O
)	O
{	O
struct	O
dv	struct
*	O
dv	struct
;	O
int	O
size	int
;	O
va_list	array
arg	struct
;	O
va_start	O
(	O
arg	struct
,	O
n	int
)	O
;	O
dv	struct
=	O
make_dv	function
(	O
0	int
,	O
n	int
,	O
arg	struct
)	O
;	O
va_end	O
(	O
arg	struct
)	O
;	O
size	int
=	O
array_size	function
(	O
type	int
,	O
dv	struct
)	O
;	O
dv	struct
->	O
base	pointer
=	O
size	int
==	O
0	int
?	O
NULL	O
:	O
push_stack	function
(	O
size	int
)	O
;	O
return	O
dv	struct
;	O
}	O
struct	O
dv	struct
*	O
alloc_same	function
(	O
int	O
type	int
,	O
struct	O
dv	struct
*	O
dope	pointer
)	O
{	O
struct	O
dv	struct
*	O
dv	struct
;	O
int	O
size	int
;	O
dv	struct
=	O
copy_dv	function
(	O
0	int
,	O
dope	pointer
)	O
;	O
size	int
=	O
array_size	function
(	O
type	int
,	O
dv	struct
)	O
;	O
dv	struct
->	O
base	pointer
=	O
size	int
==	O
0	int
?	O
NULL	O
:	O
push_stack	function
(	O
size	int
)	O
;	O
return	O
dv	struct
;	O
}	O
struct	O
dv	struct
*	O
own_array	function
(	O
int	O
type	int
,	O
int	O
n	int
,	O
...	O
)	O
{	O
struct	O
dv	struct
*	O
dv	struct
;	O
int	O
size	int
;	O
va_list	array
arg	struct
;	O
va_start	O
(	O
arg	struct
,	O
n	int
)	O
;	O
dv	struct
=	O
make_dv	function
(	O
1	int
,	O
n	int
,	O
arg	struct
)	O
;	O
va_end	O
(	O
arg	struct
)	O
;	O
size	int
=	O
array_size	function
(	O
type	int
,	O
dv	struct
)	O
;	O
dv	struct
->	O
base	pointer
=	O
size	int
==	O
0	int
?	O
NULL	O
:	O
my_malloc	function
(	O
size	int
)	O
;	O
if	O
(	O
size	int
!=	O
0	int
)	O
memset	function
(	O
dv	struct
->	O
base	pointer
,	O
0	int
,	O
size	int
)	O
;	O
return	O
dv	struct
;	O
}	O
struct	O
dv	struct
*	O
own_same	function
(	O
int	O
type	int
,	O
struct	O
dv	struct
*	O
dope	pointer
)	O
{	O
struct	O
dv	struct
*	O
dv	struct
;	O
int	O
size	int
;	O
dv	struct
=	O
copy_dv	function
(	O
1	int
,	O
dope	pointer
)	O
;	O
size	int
=	O
array_size	function
(	O
type	int
,	O
dv	struct
)	O
;	O
dv	struct
->	O
base	pointer
=	O
size	int
==	O
0	int
?	O
NULL	O
:	O
my_malloc	function
(	O
size	int
)	O
;	O
if	O
(	O
size	int
!=	O
0	int
)	O
memset	function
(	O
dv	struct
->	O
base	pointer
,	O
0	int
,	O
size	int
)	O
;	O
return	O
dv	struct
;	O
}	O
struct	O
dv	struct
*	O
copy_real	function
(	O
struct	O
arg	struct
arg	struct
)	O
{	O
struct	O
dv	struct
*	O
dope	pointer
=	O
arg	struct
.	O
arg1	pointer
;	O
int	O
type	int
=	O
(	O
int	O
)	O
arg	struct
.	O
arg2	pointer
;	O
struct	O
dv	struct
*	O
dv	struct
;	O
int	O
size	int
;	O
dv	struct
=	O
copy_dv	function
(	O
0	int
,	O
dope	pointer
)	O
;	O
size	int
=	O
array_size	function
(	O
'r'	O
,	O
dv	struct
)	O
;	O
dv	struct
->	O
base	pointer
=	O
size	int
==	O
0	int
?	O
NULL	O
:	O
push_stack	function
(	O
size	int
)	O
;	O
if	O
(	O
type	int
==	O
'r'	O
)	O
{	O
if	O
(	O
size	int
!=	O
0	int
)	O
memcpy	function
(	O
dv	struct
->	O
base	pointer
,	O
dope	pointer
->	O
base	pointer
,	O
size	int
)	O
;	O
}	O
else	O
if	O
(	O
type	int
==	O
'i'	O
)	O
{	O
int	O
*	O
s	pointer
;	O
double	O
*	O
t	int
;	O
for	O
(	O
s	pointer
=	O
dope	pointer
->	O
base	pointer
,	O
t	int
=	O
dv	struct
->	O
base	pointer
;	O
size	int
>	O
0	int
;	O
s	pointer
++	O
,	O
t	int
++	O
,	O
size	int
-=	O
sizeof	O
(	O
double	O
)	O
)	O
*	O
t	int
=	O
int2real	function
(	O
*	O
s	pointer
)	O
;	O
}	O
else	O
fault	function
(	O
"creation of a real formal array called by value not pos"	pointer
"sible because final actual parameter is not an array of ar"	pointer
"ithmetic type"	pointer
)	O
;	O
return	O
dv	struct
;	O
}	O
struct	O
dv	struct
*	O
copy_int	function
(	O
struct	O
arg	struct
arg	struct
)	O
{	O
struct	O
dv	struct
*	O
dope	pointer
=	O
arg	struct
.	O
arg1	pointer
;	O
int	O
type	int
=	O
(	O
int	O
)	O
arg	struct
.	O
arg2	pointer
;	O
struct	O
dv	struct
*	O
dv	struct
;	O
int	O
size	int
;	O
dv	struct
=	O
copy_dv	function
(	O
0	int
,	O
dope	pointer
)	O
;	O
size	int
=	O
array_size	function
(	O
'i'	O
,	O
dv	struct
)	O
;	O
dv	struct
->	O
base	pointer
=	O
size	int
==	O
0	int
?	O
NULL	O
:	O
push_stack	function
(	O
size	int
)	O
;	O
if	O
(	O
type	int
==	O
'r'	O
)	O
{	O
double	O
*	O
s	pointer
;	O
int	O
*	O
t	int
;	O
for	O
(	O
s	pointer
=	O
dope	pointer
->	O
base	pointer
,	O
t	int
=	O
dv	struct
->	O
base	pointer
;	O
size	int
>	O
0	int
;	O
s	pointer
++	O
,	O
t	int
++	O
,	O
size	int
-=	O
sizeof	O
(	O
int	O
)	O
)	O
*	O
t	int
=	O
real2int	function
(	O
*	O
s	pointer
)	O
;	O
}	O
else	O
if	O
(	O
type	int
==	O
'i'	O
)	O
{	O
if	O
(	O
size	int
!=	O
0	int
)	O
memcpy	function
(	O
dv	struct
->	O
base	pointer
,	O
dope	pointer
->	O
base	pointer
,	O
size	int
)	O
;	O
}	O
else	O
fault	function
(	O
"creation of an integer formal array called by value not"	pointer
" possible because final actual parameter is not an array o"	pointer
"f arithmetic type"	pointer
)	O
;	O
return	O
dv	struct
;	O
}	O
struct	O
dv	struct
*	O
copy_bool	function
(	O
struct	O
arg	struct
arg	struct
)	O
{	O
struct	O
dv	struct
*	O
dope	pointer
=	O
arg	struct
.	O
arg1	pointer
;	O
int	O
type	int
=	O
(	O
int	O
)	O
arg	struct
.	O
arg2	pointer
;	O
struct	O
dv	struct
*	O
dv	struct
;	O
int	O
size	int
;	O
dv	struct
=	O
copy_dv	function
(	O
0	int
,	O
dope	pointer
)	O
;	O
size	int
=	O
array_size	function
(	O
'b'	O
,	O
dv	struct
)	O
;	O
dv	struct
->	O
base	pointer
=	O
size	int
==	O
0	int
?	O
NULL	O
:	O
push_stack	function
(	O
size	int
)	O
;	O
if	O
(	O
type	int
==	O
'b'	O
)	O
{	O
if	O
(	O
size	int
!=	O
0	int
)	O
memcpy	function
(	O
dv	struct
->	O
base	pointer
,	O
dope	pointer
->	O
base	pointer
,	O
size	int
)	O
;	O
}	O
else	O
fault	function
(	O
"creation of a Boolean formal array called by value not "	pointer
"possible because final actual parameter is not an array of"	pointer
" Boolean type"	pointer
)	O
;	O
return	O
dv	struct
;	O
}	O
static	O
int	O
loc_elem	function
(	O
struct	O
dv	struct
*	O
dv	struct
,	O
int	O
n	int
,	O
va_list	array
arg	struct
)	O
{	O
int	O
loc	int
,	O
k	int
;	O
if	O
(	O
dv	struct
->	O
n	int
!=	O
n	int
)	O
fault	function
(	O
"unequal number of dimensions for actual and formal para"	pointer
"meter array"	pointer
)	O
;	O
loc	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
n	int
;	O
k	int
++	O
)	O
{	O
int	O
lo	int
=	O
dv	struct
->	O
d	array
[	O
k	int
]	O
.	O
lo	int
;	O
int	O
up	int
=	O
dv	struct
->	O
d	array
[	O
k	int
]	O
.	O
up	int
;	O
int	O
i	int
=	O
va_arg	O
(	O
arg	struct
,	O
int	O
)	O
;	O
if	O
(	O
!	O
(	O
lo	int
<=	O
i	int
&&	O
i	int
<=	O
up	int
)	O
)	O
fault	function
(	O
"value of subscript expression not within declared bo"	pointer
"unds of array"	pointer
)	O
;	O
loc	int
=	O
(	O
up	int
-	O
lo	int
+	O
1	int
)	O
*	O
loc	int
+	O
(	O
i	int
-	O
lo	int
)	O
;	O
}	O
return	O
loc	int
;	O
}	O
double	O
*	O
loc_real	function
(	O
struct	O
dv	struct
*	O
dv	struct
,	O
int	O
n	int
,	O
...	O
)	O
{	O
va_list	array
arg	struct
;	O
int	O
loc	int
;	O
va_start	O
(	O
arg	struct
,	O
n	int
)	O
;	O
loc	int
=	O
loc_elem	function
(	O
dv	struct
,	O
n	int
,	O
arg	struct
)	O
;	O
va_end	O
(	O
arg	struct
)	O
;	O
return	O
(	O
double	O
*	O
)	O
dv	struct
->	O
base	pointer
+	O
loc	int
;	O
}	O
int	O
*	O
loc_int	function
(	O
struct	O
dv	struct
*	O
dv	struct
,	O
int	O
n	int
,	O
...	O
)	O
{	O
va_list	array
arg	struct
;	O
int	O
loc	int
;	O
va_start	O
(	O
arg	struct
,	O
n	int
)	O
;	O
loc	int
=	O
loc_elem	function
(	O
dv	struct
,	O
n	int
,	O
arg	struct
)	O
;	O
va_end	O
(	O
arg	struct
)	O
;	O
return	O
(	O
int	O
*	O
)	O
dv	struct
->	O
base	pointer
+	O
loc	int
;	O
}	O
bool	int
*	O
loc_bool	function
(	O
struct	O
dv	struct
*	O
dv	struct
,	O
int	O
n	int
,	O
...	O
)	O
{	O
va_list	array
arg	struct
;	O
int	O
loc	int
;	O
va_start	O
(	O
arg	struct
,	O
n	int
)	O
;	O
loc	int
=	O
loc_elem	function
(	O
dv	struct
,	O
n	int
,	O
arg	struct
)	O
;	O
va_end	O
(	O
arg	struct
)	O
;	O
return	O
(	O
bool	int
*	O
)	O
dv	struct
->	O
base	pointer
+	O
loc	int
;	O
}	O
static	O
FILE	struct
*	O
stream	array
[	O
CHANNEL_MAX	int
]	O
;	O
static	O
int	O
status	array
[	O
CHANNEL_MAX	int
]	O
;	O
void	O
fault	function
(	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
arg	struct
;	O
struct	O
dsa	struct
*	O
dsa	struct
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"fault: "	pointer
)	O
;	O
va_start	O
(	O
arg	struct
,	O
fmt	pointer
)	O
;	O
vfprintf	function
(	O
stderr	pointer
,	O
fmt	pointer
,	O
arg	struct
)	O
;	O
va_end	O
(	O
arg	struct
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
for	O
(	O
dsa	struct
=	O
active_dsa	pointer
;	O
dsa	struct
!=	O
NULL	O
;	O
dsa	struct
=	O
dsa	struct
->	O
parent	pointer
)	O
{	O
if	O
(	O
dsa	struct
->	O
parent	pointer
==	O
NULL	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
"main program"	pointer
)	O
;	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
"procedure %s"	pointer
,	O
dsa	struct
->	O
proc	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
", file %s, line %d\n"	pointer
,	O
dsa	struct
->	O
file	pointer
,	O
dsa	struct
->	O
line	int
)	O
;	O
}	O
fflush	function
(	O
stderr	pointer
)	O
;	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
CHANNEL_MAX	int
;	O
k	int
++	O
)	O
if	O
(	O
status	array
[	O
k	int
]	O
==	O
'w'	O
)	O
fflush	function
(	O
stream	array
[	O
k	int
]	O
)	O
;	O
}	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
static	O
void	O
connect	function
(	O
int	O
channel	int
,	O
int	O
mode	int
)	O
{	O
if	O
(	O
!	O
(	O
0	int
<=	O
channel	int
&&	O
channel	int
<	O
CHANNEL_MAX	int
)	O
)	O
fault	function
(	O
"channel number %d out of range"	pointer
,	O
channel	int
)	O
;	O
assert	O
(	O
mode	int
==	O
'r'	O
||	O
mode	int
==	O
'w'	O
)	O
;	O
if	O
(	O
status	array
[	O
channel	int
]	O
!=	O
mode	int
)	O
{	O
if	O
(	O
channel	int
==	O
0	int
)	O
{	O
if	O
(	O
mode	int
==	O
'w'	O
)	O
fault	function
(	O
"output to standard input channel not allowed"	pointer
)	O
;	O
if	O
(	O
status	array
[	O
channel	int
]	O
==	O
0	int
)	O
{	O
stream	array
[	O
channel	int
]	O
=	O
stdin	pointer
;	O
status	array
[	O
channel	int
]	O
=	O
'r'	O
;	O
}	O
}	O
else	O
if	O
(	O
channel	int
==	O
1	int
)	O
{	O
if	O
(	O
mode	int
==	O
'r'	O
)	O
fault	function
(	O
"input from standard output channel not allowed"	pointer
)	O
;	O
if	O
(	O
status	array
[	O
channel	int
]	O
==	O
0	int
)	O
{	O
stream	array
[	O
channel	int
]	O
=	O
stdout	pointer
;	O
status	array
[	O
channel	int
]	O
=	O
'w'	O
;	O
}	O
}	O
else	O
{	O
char	O
dd_name	array
[	O
15	int
+	O
1	int
]	O
,	O
*	O
filename	pointer
;	O
if	O
(	O
status	array
[	O
channel	int
]	O
!=	O
0	int
)	O
fclose	function
(	O
stream	array
[	O
channel	int
]	O
)	O
;	O
sprintf	function
(	O
dd_name	array
,	O
"FILE_%d"	pointer
,	O
channel	int
)	O
;	O
filename	pointer
=	O
getenv	function
(	O
dd_name	array
)	O
;	O
if	O
(	O
filename	pointer
==	O
NULL	O
)	O
filename	pointer
=	O
dd_name	array
;	O
stream	array
[	O
channel	int
]	O
=	O
fopen	function
(	O
filename	pointer
,	O
mode	int
==	O
'w'	O
?	O
"w"	pointer
:	O
"r"	pointer
)	O
;	O
if	O
(	O
stream	array
[	O
channel	int
]	O
==	O
NULL	O
)	O
fault	function
(	O
"unable to connect channel %d to file `%s' for %s "	pointer
"- %s"	pointer
,	O
channel	int
,	O
filename	pointer
,	O
mode	int
==	O
'w'	O
?	O
"output"	pointer
:	O
"input"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
status	array
[	O
channel	int
]	O
=	O
mode	int
;	O
}	O
}	O
return	O
;	O
}	O
int	O
inchar	function
(	O
int	O
channel	int
)	O
{	O
int	O
c	int
;	O
connect	function
(	O
channel	int
,	O
'r'	O
)	O
;	O
c	int
=	O
fgetc	function
(	O
stream	array
[	O
channel	int
]	O
)	O
;	O
if	O
(	O
ferror	function
(	O
stream	array
[	O
channel	int
]	O
)	O
)	O
fault	function
(	O
"unable to input from channel %d - %s"	pointer
,	O
channel	int
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
if	O
(	O
feof	function
(	O
stream	array
[	O
channel	int
]	O
)	O
)	O
fault	function
(	O
"unable to input from channel %d - input request beyond "	pointer
"end of data"	pointer
,	O
channel	int
)	O
;	O
return	O
c	int
;	O
}	O
void	O
outchar	function
(	O
int	O
channel	int
,	O
int	O
c	int
)	O
{	O
connect	function
(	O
channel	int
,	O
'w'	O
)	O
;	O
fputc	function
(	O
c	int
,	O
stream	array
[	O
channel	int
]	O
)	O
;	O
if	O
(	O
ferror	function
(	O
stream	array
[	O
channel	int
]	O
)	O
)	O
fault	function
(	O
"unable to output to channel %d - %s"	pointer
,	O
channel	int
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
;	O
}	O
void	O
outstring	function
(	O
int	O
channel	int
,	O
char	O
*	O
str	pointer
)	O
{	O
connect	function
(	O
channel	int
,	O
'w'	O
)	O
;	O
fprintf	function
(	O
stream	array
[	O
channel	int
]	O
,	O
"%s"	pointer
,	O
str	pointer
)	O
;	O
return	O
;	O
}	O
static	O
char	O
*	O
input_data	function
(	O
int	O
channel	int
)	O
{	O
static	O
char	O
str	pointer
[	O
255	int
+	O
1	int
]	O
;	O
int	O
len	int
=	O
0	int
,	O
c	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
c	int
=	O
inchar	function
(	O
channel	int
)	O
;	O
if	O
(	O
!	O
isspace	function
(	O
c	int
)	O
)	O
break	O
;	O
}	O
while	O
(	O
!	O
isspace	function
(	O
c	int
)	O
)	O
{	O
if	O
(	O
len	int
==	O
sizeof	O
(	O
str	pointer
)	O
-	O
1	int
)	O
{	O
str	pointer
[	O
len	int
]	O
=	O
'\0'	O
;	O
fault	function
(	O
"input data item `%.12s...' too long"	pointer
,	O
str	pointer
)	O
;	O
}	O
str	pointer
[	O
len	int
++	O
]	O
=	O
(	O
char	O
)	O
c	int
;	O
c	int
=	O
inchar	function
(	O
channel	int
)	O
;	O
}	O
str	pointer
[	O
len	int
]	O
=	O
'\0'	O
;	O
return	O
str	pointer
;	O
}	O
int	O
ininteger	function
(	O
int	O
channel	int
)	O
{	O
int	O
x	double
;	O
char	O
*	O
str	pointer
,	O
*	O
ptr	pointer
;	O
str	pointer
=	O
input_data	function
(	O
channel	int
)	O
;	O
x	double
=	O
strtol	function
(	O
str	pointer
,	O
&	O
ptr	pointer
,	O
10	int
)	O
;	O
if	O
(	O
*	O
ptr	pointer
!=	O
'\0'	O
)	O
fault	function
(	O
"unable to convert `%s' to integer number"	pointer
,	O
str	pointer
)	O
;	O
return	O
x	double
;	O
}	O
void	O
outinteger	function
(	O
int	O
channel	int
,	O
int	O
val	double
)	O
{	O
connect	function
(	O
channel	int
,	O
'w'	O
)	O
;	O
fprintf	function
(	O
stream	array
[	O
channel	int
]	O
,	O
"%d "	pointer
,	O
val	double
)	O
;	O
return	O
;	O
}	O
double	O
inreal	function
(	O
int	O
channel	int
)	O
{	O
double	O
x	double
;	O
char	O
*	O
str	pointer
,	O
*	O
ptr	pointer
;	O
str	pointer
=	O
input_data	function
(	O
channel	int
)	O
;	O
x	double
=	O
strtod	function
(	O
str	pointer
,	O
&	O
ptr	pointer
)	O
;	O
if	O
(	O
*	O
ptr	pointer
!=	O
'\0'	O
)	O
fault	function
(	O
"unable to convert `%s' to real number"	pointer
,	O
str	pointer
)	O
;	O
return	O
x	double
;	O
}	O
void	O
outreal	function
(	O
int	O
channel	int
,	O
double	O
val	double
)	O
{	O
connect	function
(	O
channel	int
,	O
'w'	O
)	O
;	O
fprintf	function
(	O
stream	array
[	O
channel	int
]	O
,	O
REAL_FMT	pointer
" "	pointer
,	O
val	double
)	O
;	O
return	O
;	O
}	O
