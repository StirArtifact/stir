struct	O
dt_needed	struct
{	O
bfd	struct
*	O
by	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
}	O
;	O
const	O
char	O
*	O
ldelf_emit_note_gnu_build_id	pointer
;	O
static	O
struct	O
bfd_link_needed_list	struct
*	O
global_needed	pointer
;	O
static	O
lang_input_statement_type	struct
*	O
global_found	pointer
;	O
static	O
struct	O
stat	struct
global_stat	struct
;	O
static	O
struct	O
bfd_link_needed_list	struct
*	O
global_vercheck_needed	pointer
;	O
static	O
bfd_boolean	int
global_vercheck_failed	int
;	O
void	O
ldelf_after_parse	function
(	O
void	O
)	O
{	O
if	O
(	O
bfd_link_pie	O
(	O
&	O
link_info	struct
)	O
)	O
link_info	struct
.	O
flags_1	long
|=	O
(	O
bfd_vma	long
)	O
DF_1_PIE	int
;	O
if	O
(	O
bfd_link_executable	O
(	O
&	O
link_info	struct
)	O
&&	O
link_info	struct
.	O
nointerp	int
)	O
{	O
if	O
(	O
link_info	struct
.	O
dynamic_undefined_weak	int
>	O
0	int
)	O
einfo	pointer
(	O
_	O
(	O
"%P: warning: -z dynamic-undefined-weak ignored\n"	pointer
)	O
)	O
;	O
link_info	struct
.	O
dynamic_undefined_weak	int
=	O
0	int
;	O
}	O
after_parse_default	function
(	O
)	O
;	O
}	O
bfd_boolean	int
ldelf_load_symbols	function
(	O
lang_input_statement_type	struct
*	O
entry	pointer
)	O
{	O
int	O
link_class	int
=	O
0	int
;	O
if	O
(	O
entry	pointer
->	O
flags	int
.	O
add_DT_NEEDED_for_regular	int
)	O
link_class	int
=	O
DYN_AS_NEEDED	int
;	O
if	O
(	O
!	O
entry	pointer
->	O
flags	int
.	O
add_DT_NEEDED_for_dynamic	int
)	O
link_class	int
|=	O
DYN_NO_ADD_NEEDED	int
;	O
if	O
(	O
entry	pointer
->	O
flags	int
.	O
just_syms	int
&&	O
(	O
bfd_get_file_flags	function
(	O
entry	pointer
->	O
the_bfd	pointer
)	O
&	O
DYNAMIC	int
)	O
!=	O
0	int
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: %pB: --just-symbols may not be used on DSO\n"	pointer
)	O
,	O
entry	pointer
->	O
the_bfd	pointer
)	O
;	O
if	O
(	O
link_class	int
==	O
0	int
||	O
(	O
bfd_get_file_flags	function
(	O
entry	pointer
->	O
the_bfd	pointer
)	O
&	O
DYNAMIC	int
)	O
==	O
0	int
)	O
return	O
FALSE	int
;	O
bfd_elf_set_dyn_lib_class	function
(	O
entry	pointer
->	O
the_bfd	pointer
,	O
(	O
enum	O
dynamic_lib_link_class	enum
)	O
link_class	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
static	O
void	O
ldelf_vercheck	function
(	O
lang_input_statement_type	struct
*	O
s	pointer
)	O
{	O
const	O
char	O
*	O
soname	pointer
;	O
struct	O
bfd_link_needed_list	struct
*	O
l	pointer
;	O
if	O
(	O
global_vercheck_failed	int
)	O
return	O
;	O
if	O
(	O
s	pointer
->	O
the_bfd	pointer
==	O
NULL	O
||	O
(	O
bfd_get_file_flags	function
(	O
s	pointer
->	O
the_bfd	pointer
)	O
&	O
DYNAMIC	int
)	O
==	O
0	int
)	O
return	O
;	O
soname	pointer
=	O
bfd_elf_get_dt_soname	function
(	O
s	pointer
->	O
the_bfd	pointer
)	O
;	O
if	O
(	O
soname	pointer
==	O
NULL	O
)	O
soname	pointer
=	O
lbasename	function
(	O
bfd_get_filename	function
(	O
s	pointer
->	O
the_bfd	pointer
)	O
)	O
;	O
for	O
(	O
l	pointer
=	O
global_vercheck_needed	pointer
;	O
l	pointer
!=	O
NULL	O
;	O
l	pointer
=	O
l	pointer
->	O
next	pointer
)	O
{	O
const	O
char	O
*	O
suffix	pointer
;	O
if	O
(	O
filename_cmp	function
(	O
soname	pointer
,	O
l	pointer
->	O
name	pointer
)	O
==	O
0	int
)	O
{	O
continue	O
;	O
}	O
if	O
(	O
strchr	function
(	O
l	pointer
->	O
name	pointer
,	O
'/'	O
)	O
!=	O
NULL	O
)	O
continue	O
;	O
suffix	pointer
=	O
strstr	function
(	O
l	pointer
->	O
name	pointer
,	O
".so."	pointer
)	O
;	O
if	O
(	O
suffix	pointer
==	O
NULL	O
)	O
continue	O
;	O
suffix	pointer
+=	O
sizeof	O
".so."	pointer
-	O
1	int
;	O
if	O
(	O
filename_ncmp	function
(	O
soname	pointer
,	O
l	pointer
->	O
name	pointer
,	O
suffix	pointer
-	O
l	pointer
->	O
name	pointer
)	O
==	O
0	int
)	O
{	O
global_vercheck_failed	int
=	O
TRUE	int
;	O
return	O
;	O
}	O
}	O
}	O
static	O
void	O
ldelf_stat_needed	function
(	O
lang_input_statement_type	struct
*	O
s	pointer
)	O
{	O
struct	O
stat	struct
st	struct
;	O
const	O
char	O
*	O
suffix	pointer
;	O
const	O
char	O
*	O
soname	pointer
;	O
if	O
(	O
global_found	pointer
!=	O
NULL	O
)	O
return	O
;	O
if	O
(	O
s	pointer
->	O
the_bfd	pointer
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
(	O
bfd_elf_get_dyn_lib_class	function
(	O
s	pointer
->	O
the_bfd	pointer
)	O
&	O
DYN_AS_NEEDED	int
)	O
!=	O
0	int
)	O
return	O
;	O
if	O
(	O
bfd_stat	function
(	O
s	pointer
->	O
the_bfd	pointer
,	O
&	O
st	struct
)	O
!=	O
0	int
)	O
{	O
einfo	pointer
(	O
_	O
(	O
"%P: %pB: bfd_stat failed: %E\n"	pointer
)	O
,	O
s	pointer
->	O
the_bfd	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
st	struct
.	O
st_dev	long
==	O
global_stat	struct
.	O
st_dev	long
&&	O
st	struct
.	O
st_ino	long
==	O
global_stat	struct
.	O
st_ino	long
&&	O
st	struct
.	O
st_ino	long
!=	O
0	int
)	O
{	O
global_found	pointer
=	O
s	pointer
;	O
return	O
;	O
}	O
if	O
(	O
strchr	function
(	O
global_needed	pointer
->	O
name	pointer
,	O
'/'	O
)	O
!=	O
NULL	O
)	O
return	O
;	O
suffix	pointer
=	O
strstr	function
(	O
global_needed	pointer
->	O
name	pointer
,	O
".so."	pointer
)	O
;	O
if	O
(	O
suffix	pointer
==	O
NULL	O
)	O
return	O
;	O
suffix	pointer
+=	O
sizeof	O
".so."	pointer
-	O
1	int
;	O
soname	pointer
=	O
bfd_elf_get_dt_soname	function
(	O
s	pointer
->	O
the_bfd	pointer
)	O
;	O
if	O
(	O
soname	pointer
==	O
NULL	O
)	O
soname	pointer
=	O
lbasename	function
(	O
s	pointer
->	O
filename	pointer
)	O
;	O
if	O
(	O
filename_ncmp	function
(	O
soname	pointer
,	O
global_needed	pointer
->	O
name	pointer
,	O
suffix	pointer
-	O
global_needed	pointer
->	O
name	pointer
)	O
==	O
0	int
)	O
einfo	pointer
(	O
_	O
(	O
"%P: warning: %s, needed by %pB, may conflict with %s\n"	pointer
)	O
,	O
global_needed	pointer
->	O
name	pointer
,	O
global_needed	pointer
->	O
by	pointer
,	O
soname	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
ldelf_try_needed	function
(	O
struct	O
dt_needed	struct
*	O
needed	pointer
,	O
int	O
force	int
,	O
int	O
is_linux	int
)	O
{	O
bfd	struct
*	O
abfd	pointer
;	O
const	O
char	O
*	O
name	pointer
=	O
needed	pointer
->	O
name	pointer
;	O
const	O
char	O
*	O
soname	pointer
;	O
int	O
link_class	int
;	O
abfd	pointer
=	O
bfd_openr	function
(	O
name	pointer
,	O
bfd_get_target	function
(	O
link_info	struct
.	O
output_bfd	pointer
)	O
)	O
;	O
if	O
(	O
abfd	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
verbose	int
)	O
info_msg	function
(	O
_	O
(	O
"attempt to open %s failed\n"	pointer
)	O
,	O
name	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
abfd	pointer
->	O
flags	int
|=	O
BFD_DECOMPRESS	int
;	O
if	O
(	O
!	O
bfd_check_format	function
(	O
abfd	pointer
,	O
bfd_object	int
)	O
)	O
{	O
bfd_close	function
(	O
abfd	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
(	O
bfd_get_file_flags	function
(	O
abfd	pointer
)	O
&	O
DYNAMIC	int
)	O
==	O
0	int
)	O
{	O
bfd_close	function
(	O
abfd	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
abfd	pointer
->	O
xvec	pointer
!=	O
link_info	struct
.	O
output_bfd	pointer
->	O
xvec	pointer
)	O
{	O
bfd_close	function
(	O
abfd	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
!	O
force	int
)	O
{	O
struct	O
bfd_link_needed_list	struct
*	O
needs	pointer
;	O
if	O
(	O
!	O
bfd_elf_get_bfd_needed_list	function
(	O
abfd	pointer
,	O
&	O
needs	pointer
)	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: %pB: bfd_elf_get_bfd_needed_list failed: %E\n"	pointer
)	O
,	O
abfd	pointer
)	O
;	O
if	O
(	O
needs	pointer
!=	O
NULL	O
)	O
{	O
global_vercheck_needed	pointer
=	O
needs	pointer
;	O
global_vercheck_failed	int
=	O
FALSE	int
;	O
lang_for_each_input_file	function
(	O
ldelf_vercheck	function
)	O
;	O
if	O
(	O
global_vercheck_failed	int
)	O
{	O
bfd_close	function
(	O
abfd	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
is_linux	int
)	O
{	O
struct	O
bfd_link_needed_list	struct
*	O
l	pointer
;	O
for	O
(	O
l	pointer
=	O
needs	pointer
;	O
l	pointer
!=	O
NULL	O
;	O
l	pointer
=	O
l	pointer
->	O
next	pointer
)	O
if	O
(	O
CONST_STRNEQ	O
(	O
l	pointer
->	O
name	pointer
,	O
"libc.so"	pointer
)	O
)	O
break	O
;	O
if	O
(	O
l	pointer
==	O
NULL	O
)	O
{	O
bfd_close	function
(	O
abfd	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
bfd_stat	function
(	O
abfd	pointer
,	O
&	O
global_stat	struct
)	O
!=	O
0	int
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: %pB: bfd_stat failed: %E\n"	pointer
)	O
,	O
abfd	pointer
)	O
;	O
soname	pointer
=	O
lbasename	function
(	O
bfd_get_filename	function
(	O
abfd	pointer
)	O
)	O
;	O
if	O
(	O
verbose	int
)	O
info_msg	function
(	O
_	O
(	O
"found %s at %s\n"	pointer
)	O
,	O
soname	pointer
,	O
name	pointer
)	O
;	O
global_found	pointer
=	O
NULL	O
;	O
lang_for_each_input_file	function
(	O
ldelf_stat_needed	function
)	O
;	O
if	O
(	O
global_found	pointer
!=	O
NULL	O
)	O
{	O
return	O
TRUE	int
;	O
}	O
bfd_elf_set_dt_needed_name	function
(	O
abfd	pointer
,	O
soname	pointer
)	O
;	O
link_class	int
=	O
DYN_DT_NEEDED	int
;	O
if	O
(	O
needed	pointer
->	O
by	pointer
!=	O
NULL	O
&&	O
(	O
bfd_elf_get_dyn_lib_class	function
(	O
needed	pointer
->	O
by	pointer
)	O
&	O
DYN_NO_ADD_NEEDED	int
)	O
!=	O
0	int
)	O
link_class	int
|=	O
DYN_NO_NEEDED	int
|	O
DYN_NO_ADD_NEEDED	int
;	O
bfd_elf_set_dyn_lib_class	function
(	O
abfd	pointer
,	O
(	O
enum	O
dynamic_lib_link_class	enum
)	O
link_class	int
)	O
;	O
if	O
(	O
!	O
bfd_link_add_symbols	O
(	O
abfd	pointer
,	O
&	O
link_info	struct
)	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: %pB: error adding symbols: %E\n"	pointer
)	O
,	O
abfd	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
ldelf_search_needed	function
(	O
const	O
char	O
*	O
path	pointer
,	O
struct	O
dt_needed	struct
*	O
n	long
,	O
int	O
force	int
,	O
int	O
is_linux	int
,	O
int	O
elfsize	int
)	O
{	O
const	O
char	O
*	O
s	pointer
;	O
const	O
char	O
*	O
name	pointer
=	O
n	long
->	O
name	pointer
;	O
size_t	long
len	long
;	O
struct	O
dt_needed	struct
needed	pointer
;	O
if	O
(	O
name	pointer
[	O
0	int
]	O
==	O
'/'	O
)	O
return	O
ldelf_try_needed	function
(	O
n	long
,	O
force	int
,	O
is_linux	int
)	O
;	O
if	O
(	O
path	pointer
==	O
NULL	O
||	O
*	O
path	pointer
==	O
'\0'	O
)	O
return	O
FALSE	int
;	O
needed	pointer
.	O
by	pointer
=	O
n	long
->	O
by	pointer
;	O
needed	pointer
.	O
name	pointer
=	O
n	long
->	O
name	pointer
;	O
len	long
=	O
strlen	function
(	O
name	pointer
)	O
;	O
while	O
(	O
1	int
)	O
{	O
unsigned	O
offset	long
=	O
0	int
;	O
char	O
*	O
var	pointer
;	O
char	O
*	O
filename	pointer
,	O
*	O
sset	pointer
;	O
s	pointer
=	O
strchr	function
(	O
path	pointer
,	O
config	struct
.	O
rpath_separator	char
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
s	pointer
=	O
path	pointer
+	O
strlen	function
(	O
path	pointer
)	O
;	O
filename	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
s	pointer
-	O
path	pointer
+	O
len	long
+	O
2	int
)	O
;	O
if	O
(	O
s	pointer
==	O
path	pointer
)	O
sset	pointer
=	O
filename	pointer
;	O
else	O
{	O
memcpy	function
(	O
filename	pointer
,	O
path	pointer
,	O
s	pointer
-	O
path	pointer
)	O
;	O
filename	pointer
[	O
s	pointer
-	O
path	pointer
]	O
=	O
'/'	O
;	O
sset	pointer
=	O
filename	pointer
+	O
(	O
s	pointer
-	O
path	pointer
)	O
+	O
1	int
;	O
}	O
strcpy	function
(	O
sset	pointer
,	O
name	pointer
)	O
;	O
while	O
(	O
(	O
var	pointer
=	O
strchr	function
(	O
filename	pointer
+	O
offset	long
,	O
'$'	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
char	O
*	O
end	pointer
=	O
strchr	function
(	O
var	pointer
,	O
'/'	O
)	O
;	O
const	O
char	O
*	O
replacement	pointer
=	O
NULL	O
;	O
char	O
*	O
v	pointer
=	O
var	pointer
+	O
1	int
;	O
char	O
*	O
freeme	pointer
=	O
NULL	O
;	O
unsigned	O
flen	int
=	O
strlen	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
end	pointer
!=	O
NULL	O
)	O
*	O
end	pointer
=	O
0	int
;	O
if	O
(	O
*	O
v	pointer
==	O
'{'	O
)	O
++	O
v	pointer
;	O
switch	O
(	O
*	O
v	pointer
++	O
)	O
{	O
case	O
'O'	O
:	O
if	O
(	O
strcmp	function
(	O
v	pointer
,	O
"RIGIN"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
v	pointer
,	O
"RIGIN}"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
needed	pointer
.	O
by	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
link_info	struct
.	O
output_bfd	pointer
==	O
NULL	O
)	O
{	O
break	O
;	O
}	O
else	O
replacement	pointer
=	O
bfd_get_filename	function
(	O
link_info	struct
.	O
output_bfd	pointer
)	O
;	O
}	O
else	O
replacement	pointer
=	O
bfd_get_filename	function
(	O
needed	pointer
.	O
by	pointer
)	O
;	O
if	O
(	O
replacement	pointer
)	O
{	O
char	O
*	O
slash	pointer
;	O
if	O
(	O
replacement	pointer
[	O
0	int
]	O
==	O
'/'	O
)	O
freeme	pointer
=	O
xstrdup	function
(	O
replacement	pointer
)	O
;	O
else	O
{	O
char	O
*	O
current_dir	pointer
=	O
getpwd	function
(	O
)	O
;	O
freeme	pointer
=	O
xmalloc	function
(	O
strlen	function
(	O
replacement	pointer
)	O
+	O
strlen	function
(	O
current_dir	pointer
)	O
+	O
2	int
)	O
;	O
sprintf	function
(	O
freeme	pointer
,	O
"%s/%s"	pointer
,	O
current_dir	pointer
,	O
replacement	pointer
)	O
;	O
}	O
replacement	pointer
=	O
freeme	pointer
;	O
if	O
(	O
(	O
slash	pointer
=	O
strrchr	function
(	O
replacement	pointer
,	O
'/'	O
)	O
)	O
!=	O
NULL	O
)	O
*	O
slash	pointer
=	O
0	int
;	O
}	O
}	O
break	O
;	O
case	O
'L'	O
:	O
if	O
(	O
strcmp	function
(	O
v	pointer
,	O
"IB"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
v	pointer
,	O
"IB}"	pointer
)	O
==	O
0	int
)	O
{	O
switch	O
(	O
elfsize	int
)	O
{	O
case	O
32	int
:	O
replacement	pointer
=	O
"lib"	pointer
;	O
break	O
;	O
case	O
64	int
:	O
replacement	pointer
=	O
"lib64"	pointer
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
}	O
break	O
;	O
case	O
'P'	O
:	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
replacement	pointer
)	O
{	O
char	O
*	O
filename2	pointer
=	O
xmalloc	function
(	O
flen	int
+	O
strlen	function
(	O
replacement	pointer
)	O
)	O
;	O
if	O
(	O
end	pointer
)	O
{	O
sprintf	function
(	O
filename2	pointer
,	O
"%.*s%s/%s"	pointer
,	O
(	O
int	O
)	O
(	O
var	pointer
-	O
filename	pointer
)	O
,	O
filename	pointer
,	O
replacement	pointer
,	O
end	pointer
+	O
1	int
)	O
;	O
offset	long
=	O
(	O
var	pointer
-	O
filename	pointer
)	O
+	O
1	int
+	O
strlen	function
(	O
replacement	pointer
)	O
;	O
}	O
else	O
{	O
sprintf	function
(	O
filename2	pointer
,	O
"%.*s%s"	pointer
,	O
(	O
int	O
)	O
(	O
var	pointer
-	O
filename	pointer
)	O
,	O
filename	pointer
,	O
replacement	pointer
)	O
;	O
offset	long
=	O
var	pointer
-	O
filename	pointer
+	O
strlen	function
(	O
replacement	pointer
)	O
;	O
}	O
free	function
(	O
filename	pointer
)	O
;	O
filename	pointer
=	O
filename2	pointer
;	O
}	O
else	O
{	O
if	O
(	O
verbose	int
)	O
info_msg	function
(	O
_	O
(	O
"unrecognised or unsupported token "	pointer
"'%s' in search path\n"	pointer
)	O
,	O
var	pointer
)	O
;	O
if	O
(	O
end	pointer
)	O
*	O
end	pointer
=	O
'/'	O
;	O
offset	long
=	O
(	O
var	pointer
+	O
1	int
)	O
-	O
filename	pointer
;	O
}	O
free	function
(	O
freeme	pointer
)	O
;	O
}	O
needed	pointer
.	O
name	pointer
=	O
filename	pointer
;	O
if	O
(	O
ldelf_try_needed	function
(	O
&	O
needed	pointer
,	O
force	int
,	O
is_linux	int
)	O
)	O
return	O
TRUE	int
;	O
free	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
*	O
s	pointer
==	O
'\0'	O
)	O
break	O
;	O
path	pointer
=	O
s	pointer
+	O
1	int
;	O
}	O
return	O
FALSE	int
;	O
}	O
static	O
const	O
char	O
*	O
ldelf_add_sysroot	function
(	O
const	O
char	O
*	O
path	pointer
)	O
{	O
size_t	long
len	long
,	O
extra	pointer
;	O
const	O
char	O
*	O
p	pointer
;	O
char	O
*	O
ret	pointer
,	O
*	O
q	pointer
;	O
int	O
dos_drive_sysroot	int
=	O
HAS_DRIVE_SPEC	O
(	O
ld_sysroot	pointer
)	O
;	O
len	long
=	O
strlen	function
(	O
ld_sysroot	pointer
)	O
;	O
for	O
(	O
extra	pointer
=	O
0	int
,	O
p	pointer
=	O
path	pointer
;	O
;	O
)	O
{	O
int	O
dos_drive	int
=	O
HAS_DRIVE_SPEC	O
(	O
p	pointer
)	O
;	O
if	O
(	O
dos_drive	int
)	O
p	pointer
+=	O
2	int
;	O
if	O
(	O
IS_DIR_SEPARATOR	O
(	O
*	O
p	pointer
)	O
&&	O
(	O
!	O
dos_drive	int
||	O
(	O
dos_drive_sysroot	int
&&	O
ld_sysroot	pointer
[	O
0	int
]	O
==	O
p	pointer
[	O
-	O
2	int
]	O
)	O
)	O
)	O
{	O
if	O
(	O
dos_drive	int
&&	O
dos_drive_sysroot	int
)	O
extra	pointer
+=	O
len	long
-	O
2	int
;	O
else	O
extra	pointer
+=	O
len	long
;	O
}	O
p	pointer
=	O
strchr	function
(	O
p	pointer
,	O
config	struct
.	O
rpath_separator	char
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
break	O
;	O
++	O
p	pointer
;	O
}	O
ret	pointer
=	O
xmalloc	function
(	O
strlen	function
(	O
path	pointer
)	O
+	O
extra	pointer
+	O
1	int
)	O
;	O
for	O
(	O
q	pointer
=	O
ret	pointer
,	O
p	pointer
=	O
path	pointer
;	O
;	O
)	O
{	O
const	O
char	O
*	O
end	pointer
;	O
int	O
dos_drive	int
=	O
HAS_DRIVE_SPEC	O
(	O
p	pointer
)	O
;	O
if	O
(	O
dos_drive	int
)	O
{	O
*	O
q	pointer
++	O
=	O
*	O
p	pointer
++	O
;	O
*	O
q	pointer
++	O
=	O
*	O
p	pointer
++	O
;	O
}	O
if	O
(	O
IS_DIR_SEPARATOR	O
(	O
*	O
p	pointer
)	O
&&	O
(	O
!	O
dos_drive	int
||	O
(	O
dos_drive_sysroot	int
&&	O
ld_sysroot	pointer
[	O
0	int
]	O
==	O
p	pointer
[	O
-	O
2	int
]	O
)	O
)	O
)	O
{	O
if	O
(	O
dos_drive	int
&&	O
dos_drive_sysroot	int
)	O
{	O
strcpy	function
(	O
q	pointer
,	O
ld_sysroot	pointer
+	O
2	int
)	O
;	O
q	pointer
+=	O
len	long
-	O
2	int
;	O
}	O
else	O
{	O
strcpy	function
(	O
q	pointer
,	O
ld_sysroot	pointer
)	O
;	O
q	pointer
+=	O
len	long
;	O
}	O
}	O
end	pointer
=	O
strchr	function
(	O
p	pointer
,	O
config	struct
.	O
rpath_separator	char
)	O
;	O
if	O
(	O
end	pointer
)	O
{	O
size_t	long
n	long
=	O
end	pointer
-	O
p	pointer
+	O
1	int
;	O
strncpy	function
(	O
q	pointer
,	O
p	pointer
,	O
n	long
)	O
;	O
q	pointer
+=	O
n	long
;	O
p	pointer
+=	O
n	long
;	O
}	O
else	O
{	O
strcpy	function
(	O
q	pointer
,	O
p	pointer
)	O
;	O
break	O
;	O
}	O
}	O
return	O
ret	pointer
;	O
}	O
static	O
bfd_boolean	int
ldelf_check_ld_elf_hints	function
(	O
const	O
struct	O
bfd_link_needed_list	struct
*	O
l	pointer
,	O
int	O
force	int
,	O
int	O
elfsize	int
)	O
{	O
static	O
bfd_boolean	int
initialized	int
;	O
static	O
const	O
char	O
*	O
ld_elf_hints	pointer
;	O
struct	O
dt_needed	struct
needed	pointer
;	O
if	O
(	O
!	O
initialized	int
)	O
{	O
FILE	struct
*	O
f	pointer
;	O
char	O
*	O
tmppath	pointer
;	O
tmppath	pointer
=	O
concat	function
(	O
ld_sysroot	pointer
,	O
_PATH_ELF_HINTS	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
)	O
;	O
f	pointer
=	O
fopen	function
(	O
tmppath	pointer
,	O
FOPEN_RB	pointer
)	O
;	O
free	function
(	O
tmppath	pointer
)	O
;	O
if	O
(	O
f	pointer
!=	O
NULL	O
)	O
{	O
struct	O
elfhints_hdr	struct
hdr	pointer
;	O
if	O
(	O
fread	function
(	O
&	O
hdr	pointer
,	O
1	int
,	O
sizeof	O
(	O
hdr	pointer
)	O
,	O
f	pointer
)	O
==	O
sizeof	O
(	O
hdr	pointer
)	O
&&	O
hdr	pointer
.	O
magic	int
==	O
ELFHINTS_MAGIC	int
&&	O
hdr	pointer
.	O
version	pointer
==	O
1	int
)	O
{	O
if	O
(	O
fseek	function
(	O
f	pointer
,	O
hdr	pointer
.	O
strtab	pointer
+	O
hdr	pointer
.	O
dirlist	int
,	O
SEEK_SET	int
)	O
!=	O
-	O
1	int
)	O
{	O
char	O
*	O
b	pointer
;	O
b	pointer
=	O
xmalloc	function
(	O
hdr	pointer
.	O
dirlistlen	int
+	O
1	int
)	O
;	O
if	O
(	O
fread	function
(	O
b	pointer
,	O
1	int
,	O
hdr	pointer
.	O
dirlistlen	int
+	O
1	int
,	O
f	pointer
)	O
==	O
hdr	pointer
.	O
dirlistlen	int
+	O
1	int
)	O
ld_elf_hints	pointer
=	O
ldelf_add_sysroot	function
(	O
b	pointer
)	O
;	O
free	function
(	O
b	pointer
)	O
;	O
}	O
}	O
fclose	function
(	O
f	pointer
)	O
;	O
}	O
initialized	int
=	O
TRUE	int
;	O
}	O
if	O
(	O
ld_elf_hints	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
needed	pointer
.	O
by	pointer
=	O
l	pointer
->	O
by	pointer
;	O
needed	pointer
.	O
name	pointer
=	O
l	pointer
->	O
name	pointer
;	O
return	O
ldelf_search_needed	function
(	O
ld_elf_hints	pointer
,	O
&	O
needed	pointer
,	O
force	int
,	O
FALSE	int
,	O
elfsize	int
)	O
;	O
}	O
struct	O
ldelf_ld_so_conf	struct
{	O
char	O
*	O
path	pointer
;	O
size_t	long
len	long
,	O
alloc	long
;	O
}	O
;	O
static	O
bfd_boolean	int
ldelf_parse_ld_so_conf	function
(	O
struct	O
ldelf_ld_so_conf	struct
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
void	O
ldelf_parse_ld_so_conf_include	function
(	O
struct	O
ldelf_ld_so_conf	struct
*	O
info	pointer
,	O
const	O
char	O
*	O
filename	pointer
,	O
const	O
char	O
*	O
pattern	pointer
)	O
{	O
char	O
*	O
newp	pointer
=	O
NULL	O
;	O
glob_t	struct
gl	struct
;	O
if	O
(	O
pattern	pointer
[	O
0	int
]	O
!=	O
'/'	O
)	O
{	O
char	O
*	O
p	pointer
=	O
strrchr	function
(	O
filename	pointer
,	O
'/'	O
)	O
;	O
size_t	long
patlen	long
=	O
strlen	function
(	O
pattern	pointer
)	O
+	O
1	int
;	O
newp	pointer
=	O
xmalloc	function
(	O
p	pointer
-	O
filename	pointer
+	O
1	int
+	O
patlen	long
)	O
;	O
memcpy	function
(	O
newp	pointer
,	O
filename	pointer
,	O
p	pointer
-	O
filename	pointer
+	O
1	int
)	O
;	O
memcpy	function
(	O
newp	pointer
+	O
(	O
p	pointer
-	O
filename	pointer
+	O
1	int
)	O
,	O
pattern	pointer
,	O
patlen	long
)	O
;	O
pattern	pointer
=	O
newp	pointer
;	O
}	O
if	O
(	O
glob	function
(	O
pattern	pointer
,	O
0	int
,	O
NULL	O
,	O
&	O
gl	struct
)	O
==	O
0	int
)	O
{	O
size_t	long
i	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
gl	struct
.	O
gl_pathc	long
;	O
++	O
i	pointer
)	O
ldelf_parse_ld_so_conf	function
(	O
info	pointer
,	O
gl	struct
.	O
gl_pathv	pointer
[	O
i	pointer
]	O
)	O
;	O
globfree	function
(	O
&	O
gl	struct
)	O
;	O
}	O
if	O
(	O
newp	pointer
)	O
free	function
(	O
newp	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
ldelf_parse_ld_so_conf	function
(	O
struct	O
ldelf_ld_so_conf	struct
*	O
info	pointer
,	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
FILE	struct
*	O
f	pointer
=	O
fopen	function
(	O
filename	pointer
,	O
FOPEN_RT	pointer
)	O
;	O
char	O
*	O
line	pointer
;	O
size_t	long
linelen	long
;	O
if	O
(	O
f	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
linelen	long
=	O
256	int
;	O
line	pointer
=	O
xmalloc	function
(	O
linelen	long
)	O
;	O
do	O
{	O
char	O
*	O
p	pointer
=	O
line	pointer
,	O
*	O
q	pointer
;	O
while	O
(	O
(	O
q	pointer
=	O
fgets	function
(	O
p	pointer
,	O
linelen	long
-	O
(	O
p	pointer
-	O
line	pointer
)	O
,	O
f	pointer
)	O
)	O
!=	O
NULL	O
&&	O
strlen	function
(	O
q	pointer
)	O
==	O
linelen	long
-	O
(	O
p	pointer
-	O
line	pointer
)	O
-	O
1	int
&&	O
line	pointer
[	O
linelen	long
-	O
2	int
]	O
!=	O
'\n'	O
)	O
{	O
line	pointer
=	O
xrealloc	function
(	O
line	pointer
,	O
2	int
*	O
linelen	long
)	O
;	O
p	pointer
=	O
line	pointer
+	O
linelen	long
-	O
1	int
;	O
linelen	long
+=	O
linelen	long
;	O
}	O
if	O
(	O
q	pointer
==	O
NULL	O
&&	O
p	pointer
==	O
line	pointer
)	O
break	O
;	O
p	pointer
=	O
strchr	function
(	O
line	pointer
,	O
'\n'	O
)	O
;	O
if	O
(	O
p	pointer
)	O
*	O
p	pointer
=	O
'\0'	O
;	O
p	pointer
=	O
strchr	function
(	O
line	pointer
,	O
'#'	O
)	O
;	O
if	O
(	O
p	pointer
)	O
*	O
p	pointer
=	O
'\0'	O
;	O
p	pointer
=	O
line	pointer
;	O
while	O
(	O
*	O
p	pointer
==	O
' '	O
||	O
*	O
p	pointer
==	O
'\f'	O
||	O
*	O
p	pointer
==	O
'\r'	O
||	O
*	O
p	pointer
==	O
'\t'	O
||	O
*	O
p	pointer
==	O
'\v'	O
)	O
++	O
p	pointer
;	O
if	O
(	O
p	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
continue	O
;	O
if	O
(	O
CONST_STRNEQ	O
(	O
p	pointer
,	O
"include"	pointer
)	O
&&	O
(	O
p	pointer
[	O
7	int
]	O
==	O
' '	O
||	O
p	pointer
[	O
7	int
]	O
==	O
'\t'	O
)	O
)	O
{	O
char	O
*	O
dir	pointer
,	O
c	struct
;	O
p	pointer
+=	O
8	int
;	O
do	O
{	O
while	O
(	O
*	O
p	pointer
==	O
' '	O
||	O
*	O
p	pointer
==	O
'\t'	O
)	O
++	O
p	pointer
;	O
if	O
(	O
*	O
p	pointer
==	O
'\0'	O
)	O
break	O
;	O
dir	pointer
=	O
p	pointer
;	O
while	O
(	O
*	O
p	pointer
!=	O
' '	O
&&	O
*	O
p	pointer
!=	O
'\t'	O
&&	O
*	O
p	pointer
)	O
++	O
p	pointer
;	O
c	struct
=	O
*	O
p	pointer
;	O
*	O
p	pointer
++	O
=	O
'\0'	O
;	O
if	O
(	O
dir	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
ldelf_parse_ld_so_conf_include	function
(	O
info	pointer
,	O
filename	pointer
,	O
dir	pointer
)	O
;	O
}	O
while	O
(	O
c	struct
!=	O
'\0'	O
)	O
;	O
}	O
else	O
{	O
char	O
*	O
dir	pointer
=	O
p	pointer
;	O
while	O
(	O
*	O
p	pointer
&&	O
*	O
p	pointer
!=	O
'='	O
&&	O
*	O
p	pointer
!=	O
' '	O
&&	O
*	O
p	pointer
!=	O
'\t'	O
&&	O
*	O
p	pointer
!=	O
'\f'	O
&&	O
*	O
p	pointer
!=	O
'\r'	O
&&	O
*	O
p	pointer
!=	O
'\v'	O
)	O
++	O
p	pointer
;	O
while	O
(	O
p	pointer
!=	O
dir	pointer
&&	O
p	pointer
[	O
-	O
1	int
]	O
==	O
'/'	O
)	O
--	O
p	pointer
;	O
if	O
(	O
info	pointer
->	O
path	pointer
==	O
NULL	O
)	O
{	O
info	pointer
->	O
alloc	long
=	O
p	pointer
-	O
dir	pointer
+	O
1	int
+	O
256	int
;	O
info	pointer
->	O
path	pointer
=	O
xmalloc	function
(	O
info	pointer
->	O
alloc	long
)	O
;	O
info	pointer
->	O
len	long
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
info	pointer
->	O
len	long
+	O
1	int
+	O
(	O
p	pointer
-	O
dir	pointer
)	O
>=	O
info	pointer
->	O
alloc	long
)	O
{	O
info	pointer
->	O
alloc	long
+=	O
p	pointer
-	O
dir	pointer
+	O
256	int
;	O
info	pointer
->	O
path	pointer
=	O
xrealloc	function
(	O
info	pointer
->	O
path	pointer
,	O
info	pointer
->	O
alloc	long
)	O
;	O
}	O
info	pointer
->	O
path	pointer
[	O
info	pointer
->	O
len	long
++	O
]	O
=	O
config	struct
.	O
rpath_separator	char
;	O
}	O
memcpy	function
(	O
info	pointer
->	O
path	pointer
+	O
info	pointer
->	O
len	long
,	O
dir	pointer
,	O
p	pointer
-	O
dir	pointer
)	O
;	O
info	pointer
->	O
len	long
+=	O
p	pointer
-	O
dir	pointer
;	O
info	pointer
->	O
path	pointer
[	O
info	pointer
->	O
len	long
]	O
=	O
'\0'	O
;	O
}	O
}	O
while	O
(	O
!	O
feof	function
(	O
f	pointer
)	O
)	O
;	O
free	function
(	O
line	pointer
)	O
;	O
fclose	function
(	O
f	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
ldelf_check_ld_so_conf	function
(	O
const	O
struct	O
bfd_link_needed_list	struct
*	O
l	pointer
,	O
int	O
force	int
,	O
int	O
elfsize	int
,	O
const	O
char	O
*	O
prefix	pointer
)	O
{	O
static	O
bfd_boolean	int
initialized	int
;	O
static	O
const	O
char	O
*	O
ld_so_conf	pointer
;	O
struct	O
dt_needed	struct
needed	pointer
;	O
if	O
(	O
!	O
initialized	int
)	O
{	O
char	O
*	O
tmppath	pointer
;	O
struct	O
ldelf_ld_so_conf	struct
info	pointer
;	O
info	pointer
.	O
path	pointer
=	O
NULL	O
;	O
info	pointer
.	O
len	long
=	O
info	pointer
.	O
alloc	long
=	O
0	int
;	O
tmppath	pointer
=	O
concat	function
(	O
ld_sysroot	pointer
,	O
prefix	pointer
,	O
"/etc/ld.so.conf"	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
)	O
;	O
if	O
(	O
!	O
ldelf_parse_ld_so_conf	function
(	O
&	O
info	pointer
,	O
tmppath	pointer
)	O
)	O
{	O
free	function
(	O
tmppath	pointer
)	O
;	O
tmppath	pointer
=	O
concat	function
(	O
ld_sysroot	pointer
,	O
"/etc/ld.so.conf"	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
)	O
;	O
ldelf_parse_ld_so_conf	function
(	O
&	O
info	pointer
,	O
tmppath	pointer
)	O
;	O
}	O
free	function
(	O
tmppath	pointer
)	O
;	O
if	O
(	O
info	pointer
.	O
path	pointer
)	O
{	O
ld_so_conf	pointer
=	O
ldelf_add_sysroot	function
(	O
info	pointer
.	O
path	pointer
)	O
;	O
free	function
(	O
info	pointer
.	O
path	pointer
)	O
;	O
}	O
initialized	int
=	O
TRUE	int
;	O
}	O
if	O
(	O
ld_so_conf	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
needed	pointer
.	O
by	pointer
=	O
l	pointer
->	O
by	pointer
;	O
needed	pointer
.	O
name	pointer
=	O
l	pointer
->	O
name	pointer
;	O
return	O
ldelf_search_needed	function
(	O
ld_so_conf	pointer
,	O
&	O
needed	pointer
,	O
force	int
,	O
TRUE	int
,	O
elfsize	int
)	O
;	O
}	O
static	O
void	O
ldelf_check_needed	function
(	O
lang_input_statement_type	struct
*	O
s	pointer
)	O
{	O
const	O
char	O
*	O
soname	pointer
;	O
if	O
(	O
global_found	pointer
!=	O
NULL	O
&&	O
(	O
bfd_elf_get_dyn_lib_class	function
(	O
global_found	pointer
->	O
the_bfd	pointer
)	O
&	O
DYN_AS_NEEDED	int
)	O
==	O
0	int
)	O
return	O
;	O
if	O
(	O
s	pointer
->	O
filename	pointer
==	O
NULL	O
||	O
s	pointer
->	O
the_bfd	pointer
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
global_found	pointer
!=	O
NULL	O
&&	O
(	O
bfd_elf_get_dyn_lib_class	function
(	O
s	pointer
->	O
the_bfd	pointer
)	O
&	O
DYN_AS_NEEDED	int
)	O
!=	O
0	int
)	O
return	O
;	O
if	O
(	O
filename_cmp	function
(	O
s	pointer
->	O
filename	pointer
,	O
global_needed	pointer
->	O
name	pointer
)	O
==	O
0	int
)	O
{	O
global_found	pointer
=	O
s	pointer
;	O
return	O
;	O
}	O
if	O
(	O
s	pointer
->	O
flags	int
.	O
search_dirs	int
)	O
{	O
const	O
char	O
*	O
f	pointer
=	O
strrchr	function
(	O
s	pointer
->	O
filename	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
f	pointer
!=	O
NULL	O
&&	O
filename_cmp	function
(	O
f	pointer
+	O
1	int
,	O
global_needed	pointer
->	O
name	pointer
)	O
==	O
0	int
)	O
{	O
global_found	pointer
=	O
s	pointer
;	O
return	O
;	O
}	O
}	O
soname	pointer
=	O
bfd_elf_get_dt_soname	function
(	O
s	pointer
->	O
the_bfd	pointer
)	O
;	O
if	O
(	O
soname	pointer
!=	O
NULL	O
&&	O
filename_cmp	function
(	O
soname	pointer
,	O
global_needed	pointer
->	O
name	pointer
)	O
==	O
0	int
)	O
{	O
global_found	pointer
=	O
s	pointer
;	O
return	O
;	O
}	O
}	O
void	O
ldelf_after_open	function
(	O
int	O
use_libpath	int
,	O
int	O
native	int
,	O
int	O
is_linux	int
,	O
int	O
is_freebsd	int
,	O
int	O
elfsize	int
,	O
const	O
char	O
*	O
prefix	pointer
)	O
{	O
struct	O
bfd_link_needed_list	struct
*	O
needed	pointer
,	O
*	O
l	pointer
;	O
struct	O
elf_link_hash_table	struct
*	O
htab	struct
;	O
asection	struct
*	O
s	pointer
;	O
bfd	struct
*	O
abfd	pointer
;	O
after_open_default	function
(	O
)	O
;	O
htab	struct
=	O
elf_hash_table	O
(	O
&	O
link_info	struct
)	O
;	O
if	O
(	O
!	O
is_elf_hash_table	O
(	O
htab	struct
)	O
)	O
return	O
;	O
if	O
(	O
command_line	struct
.	O
out_implib_filename	pointer
)	O
{	O
unlink_if_ordinary	function
(	O
command_line	struct
.	O
out_implib_filename	pointer
)	O
;	O
link_info	struct
.	O
out_implib_bfd	pointer
=	O
bfd_openw	function
(	O
command_line	struct
.	O
out_implib_filename	pointer
,	O
bfd_get_target	function
(	O
link_info	struct
.	O
output_bfd	pointer
)	O
)	O
;	O
if	O
(	O
link_info	struct
.	O
out_implib_bfd	pointer
==	O
NULL	O
)	O
{	O
einfo	pointer
(	O
_	O
(	O
"%F%P: %s: can't open for writing: %E\n"	pointer
)	O
,	O
command_line	struct
.	O
out_implib_filename	pointer
)	O
;	O
}	O
}	O
if	O
(	O
ldelf_emit_note_gnu_build_id	pointer
!=	O
NULL	O
)	O
{	O
for	O
(	O
abfd	pointer
=	O
link_info	struct
.	O
input_bfds	pointer
;	O
abfd	pointer
!=	O
(	O
bfd	struct
*	O
)	O
NULL	O
;	O
abfd	pointer
=	O
abfd	pointer
->	O
link	function
.	O
next	pointer
)	O
if	O
(	O
bfd_get_flavour	function
(	O
abfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
&&	O
bfd_count_sections	function
(	O
abfd	pointer
)	O
!=	O
0	int
&&	O
!	O
bfd_input_just_syms	function
(	O
abfd	pointer
)	O
)	O
break	O
;	O
if	O
(	O
abfd	pointer
==	O
NULL	O
||	O
!	O
ldelf_setup_build_id	function
(	O
abfd	pointer
)	O
)	O
{	O
free	function
(	O
(	O
char	O
*	O
)	O
ldelf_emit_note_gnu_build_id	pointer
)	O
;	O
ldelf_emit_note_gnu_build_id	pointer
=	O
NULL	O
;	O
}	O
}	O
get_elf_backend_data	O
(	O
link_info	struct
.	O
output_bfd	pointer
)	O
->	O
setup_gnu_properties	pointer
(	O
&	O
link_info	struct
)	O
;	O
if	O
(	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
)	O
{	O
if	O
(	O
link_info	struct
.	O
execstack	int
==	O
!	O
link_info	struct
.	O
noexecstack	int
)	O
{	O
flagword	int
flags	int
=	O
SEC_READONLY	int
|	O
(	O
link_info	struct
.	O
execstack	int
?	O
SEC_CODE	int
:	O
0	int
)	O
;	O
(	O
void	O
)	O
bfd_make_section_with_flags	function
(	O
link_info	struct
.	O
input_bfds	pointer
,	O
".note.GNU-stack"	pointer
,	O
flags	int
)	O
;	O
}	O
return	O
;	O
}	O
if	O
(	O
!	O
link_info	struct
.	O
traditional_format	int
)	O
{	O
bfd	struct
*	O
elfbfd	pointer
=	O
NULL	O
;	O
bfd_boolean	int
warn_eh_frame	int
=	O
FALSE	int
;	O
int	O
seen_type	int
=	O
0	int
;	O
for	O
(	O
abfd	pointer
=	O
link_info	struct
.	O
input_bfds	pointer
;	O
abfd	pointer
;	O
abfd	pointer
=	O
abfd	pointer
->	O
link	function
.	O
next	pointer
)	O
{	O
int	O
type	enum
=	O
0	int
;	O
if	O
(	O
bfd_input_just_syms	function
(	O
abfd	pointer
)	O
)	O
continue	O
;	O
for	O
(	O
s	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
s	pointer
&&	O
type	enum
<	O
COMPACT_EH_HDR	int
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
{	O
const	O
char	O
*	O
name	pointer
=	O
bfd_section_name	function
(	O
s	pointer
)	O
;	O
if	O
(	O
bfd_is_abs_section	function
(	O
s	pointer
->	O
output_section	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
CONST_STRNEQ	O
(	O
name	pointer
,	O
".eh_frame_entry"	pointer
)	O
)	O
type	enum
=	O
COMPACT_EH_HDR	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
name	pointer
,	O
".eh_frame"	pointer
)	O
==	O
0	int
&&	O
s	pointer
->	O
size	int
>	O
8	int
)	O
type	enum
=	O
DWARF2_EH_HDR	int
;	O
}	O
if	O
(	O
type	enum
!=	O
0	int
)	O
{	O
if	O
(	O
seen_type	int
==	O
0	int
)	O
{	O
seen_type	int
=	O
type	enum
;	O
}	O
else	O
if	O
(	O
seen_type	int
!=	O
type	enum
)	O
{	O
einfo	pointer
(	O
_	O
(	O
"%F%P: compact frame descriptions incompatible with"	pointer
" DWARF2 .eh_frame from %pB\n"	pointer
)	O
,	O
type	enum
==	O
DWARF2_EH_HDR	int
?	O
abfd	pointer
:	O
elfbfd	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
elfbfd	pointer
&&	O
(	O
type	enum
==	O
COMPACT_EH_HDR	int
||	O
link_info	struct
.	O
eh_frame_hdr_type	int
!=	O
0	int
)	O
)	O
{	O
if	O
(	O
bfd_get_flavour	function
(	O
abfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
)	O
elfbfd	pointer
=	O
abfd	pointer
;	O
warn_eh_frame	int
=	O
TRUE	int
;	O
}	O
}	O
if	O
(	O
seen_type	int
==	O
COMPACT_EH_HDR	int
)	O
link_info	struct
.	O
eh_frame_hdr_type	int
=	O
COMPACT_EH_HDR	int
;	O
}	O
if	O
(	O
elfbfd	pointer
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
elfbfd	pointer
)	O
;	O
s	pointer
=	O
bfd_make_section_with_flags	function
(	O
elfbfd	pointer
,	O
".eh_frame_hdr"	pointer
,	O
bed	pointer
->	O
dynamic_sec_flags	int
|	O
SEC_READONLY	int
)	O
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
&&	O
bfd_set_section_alignment	function
(	O
s	pointer
,	O
2	int
)	O
)	O
{	O
htab	struct
->	O
eh_info	struct
.	O
hdr_sec	pointer
=	O
s	pointer
;	O
warn_eh_frame	int
=	O
FALSE	int
;	O
}	O
}	O
if	O
(	O
warn_eh_frame	int
)	O
einfo	pointer
(	O
_	O
(	O
"%P: warning: cannot create .eh_frame_hdr section,"	pointer
" --eh-frame-hdr ignored\n"	pointer
)	O
)	O
;	O
}	O
needed	pointer
=	O
bfd_elf_get_needed_list	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
&	O
link_info	struct
)	O
;	O
for	O
(	O
l	pointer
=	O
needed	pointer
;	O
l	pointer
!=	O
NULL	O
;	O
l	pointer
=	O
l	pointer
->	O
next	pointer
)	O
{	O
struct	O
bfd_link_needed_list	struct
*	O
ll	pointer
;	O
struct	O
dt_needed	struct
n	long
,	O
nn	struct
;	O
int	O
force	int
;	O
if	O
(	O
l	pointer
->	O
by	pointer
!=	O
NULL	O
&&	O
(	O
bfd_elf_get_dyn_lib_class	function
(	O
l	pointer
->	O
by	pointer
)	O
&	O
DYN_AS_NEEDED	int
)	O
!=	O
0	int
)	O
continue	O
;	O
if	O
(	O
l	pointer
->	O
by	pointer
!=	O
NULL	O
&&	O
link_info	struct
.	O
unresolved_syms_in_shared_libs	enum
==	O
RM_IGNORE	int
&&	O
(	O
bfd_elf_get_dyn_lib_class	function
(	O
l	pointer
->	O
by	pointer
)	O
&	O
DYN_NO_ADD_NEEDED	int
)	O
!=	O
0	int
)	O
continue	O
;	O
for	O
(	O
ll	pointer
=	O
needed	pointer
;	O
ll	pointer
!=	O
l	pointer
;	O
ll	pointer
=	O
ll	pointer
->	O
next	pointer
)	O
if	O
(	O
(	O
ll	pointer
->	O
by	pointer
==	O
NULL	O
||	O
(	O
bfd_elf_get_dyn_lib_class	function
(	O
ll	pointer
->	O
by	pointer
)	O
&	O
DYN_AS_NEEDED	int
)	O
==	O
0	int
)	O
&&	O
strcmp	function
(	O
ll	pointer
->	O
name	pointer
,	O
l	pointer
->	O
name	pointer
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
ll	pointer
!=	O
l	pointer
)	O
continue	O
;	O
global_needed	pointer
=	O
l	pointer
;	O
global_found	pointer
=	O
NULL	O
;	O
lang_for_each_input_file	function
(	O
ldelf_check_needed	function
)	O
;	O
if	O
(	O
global_found	pointer
!=	O
NULL	O
&&	O
(	O
bfd_elf_get_dyn_lib_class	function
(	O
global_found	pointer
->	O
the_bfd	pointer
)	O
&	O
DYN_AS_NEEDED	int
)	O
==	O
0	int
)	O
continue	O
;	O
n	long
.	O
by	pointer
=	O
l	pointer
->	O
by	pointer
;	O
n	long
.	O
name	pointer
=	O
l	pointer
->	O
name	pointer
;	O
nn	struct
.	O
by	pointer
=	O
l	pointer
->	O
by	pointer
;	O
if	O
(	O
verbose	int
)	O
info_msg	function
(	O
_	O
(	O
"%s needed by %pB\n"	pointer
)	O
,	O
l	pointer
->	O
name	pointer
,	O
l	pointer
->	O
by	pointer
)	O
;	O
if	O
(	O
global_found	pointer
!=	O
NULL	O
)	O
{	O
nn	struct
.	O
name	pointer
=	O
global_found	pointer
->	O
filename	pointer
;	O
if	O
(	O
ldelf_try_needed	function
(	O
&	O
nn	struct
,	O
TRUE	int
,	O
is_linux	int
)	O
)	O
continue	O
;	O
}	O
for	O
(	O
force	int
=	O
0	int
;	O
force	int
<	O
2	int
;	O
force	int
++	O
)	O
{	O
size_t	long
len	long
;	O
search_dirs_type	struct
*	O
search	pointer
;	O
const	O
char	O
*	O
path	pointer
;	O
struct	O
bfd_link_needed_list	struct
*	O
rp	pointer
;	O
int	O
found	int
;	O
if	O
(	O
ldelf_search_needed	function
(	O
command_line	struct
.	O
rpath_link	pointer
,	O
&	O
n	long
,	O
force	int
,	O
is_linux	int
,	O
elfsize	int
)	O
)	O
break	O
;	O
if	O
(	O
use_libpath	int
)	O
{	O
path	pointer
=	O
command_line	struct
.	O
rpath	pointer
;	O
if	O
(	O
path	pointer
)	O
{	O
path	pointer
=	O
ldelf_add_sysroot	function
(	O
path	pointer
)	O
;	O
found	int
=	O
ldelf_search_needed	function
(	O
path	pointer
,	O
&	O
n	long
,	O
force	int
,	O
is_linux	int
,	O
elfsize	int
)	O
;	O
free	function
(	O
(	O
char	O
*	O
)	O
path	pointer
)	O
;	O
if	O
(	O
found	int
)	O
break	O
;	O
}	O
}	O
if	O
(	O
native	int
)	O
{	O
if	O
(	O
command_line	struct
.	O
rpath_link	pointer
==	O
NULL	O
&&	O
command_line	struct
.	O
rpath	pointer
==	O
NULL	O
)	O
{	O
path	pointer
=	O
(	O
const	O
char	O
*	O
)	O
getenv	function
(	O
"LD_RUN_PATH"	pointer
)	O
;	O
if	O
(	O
path	pointer
&&	O
ldelf_search_needed	function
(	O
path	pointer
,	O
&	O
n	long
,	O
force	int
,	O
is_linux	int
,	O
elfsize	int
)	O
)	O
break	O
;	O
}	O
path	pointer
=	O
(	O
const	O
char	O
*	O
)	O
getenv	function
(	O
"LD_LIBRARY_PATH"	pointer
)	O
;	O
if	O
(	O
path	pointer
&&	O
ldelf_search_needed	function
(	O
path	pointer
,	O
&	O
n	long
,	O
force	int
,	O
is_linux	int
,	O
elfsize	int
)	O
)	O
break	O
;	O
}	O
if	O
(	O
use_libpath	int
)	O
{	O
found	int
=	O
0	int
;	O
rp	pointer
=	O
bfd_elf_get_runpath_list	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
&	O
link_info	struct
)	O
;	O
for	O
(	O
;	O
!	O
found	int
&&	O
rp	pointer
!=	O
NULL	O
;	O
rp	pointer
=	O
rp	pointer
->	O
next	pointer
)	O
{	O
path	pointer
=	O
ldelf_add_sysroot	function
(	O
rp	pointer
->	O
name	pointer
)	O
;	O
found	int
=	O
(	O
rp	pointer
->	O
by	pointer
==	O
l	pointer
->	O
by	pointer
&&	O
ldelf_search_needed	function
(	O
path	pointer
,	O
&	O
n	long
,	O
force	int
,	O
is_linux	int
,	O
elfsize	int
)	O
)	O
;	O
free	function
(	O
(	O
char	O
*	O
)	O
path	pointer
)	O
;	O
}	O
if	O
(	O
found	int
)	O
break	O
;	O
if	O
(	O
is_freebsd	int
&&	O
ldelf_check_ld_elf_hints	function
(	O
l	pointer
,	O
force	int
,	O
elfsize	int
)	O
)	O
break	O
;	O
if	O
(	O
is_linux	int
&&	O
ldelf_check_ld_so_conf	function
(	O
l	pointer
,	O
force	int
,	O
elfsize	int
,	O
prefix	pointer
)	O
)	O
break	O
;	O
}	O
len	long
=	O
strlen	function
(	O
l	pointer
->	O
name	pointer
)	O
;	O
for	O
(	O
search	pointer
=	O
search_head	pointer
;	O
search	pointer
!=	O
NULL	O
;	O
search	pointer
=	O
search	pointer
->	O
next	pointer
)	O
{	O
char	O
*	O
filename	pointer
;	O
if	O
(	O
search	pointer
->	O
cmdline	int
)	O
continue	O
;	O
filename	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
strlen	function
(	O
search	pointer
->	O
name	pointer
)	O
+	O
len	long
+	O
2	int
)	O
;	O
sprintf	function
(	O
filename	pointer
,	O
"%s/%s"	pointer
,	O
search	pointer
->	O
name	pointer
,	O
l	pointer
->	O
name	pointer
)	O
;	O
nn	struct
.	O
name	pointer
=	O
filename	pointer
;	O
if	O
(	O
ldelf_try_needed	function
(	O
&	O
nn	struct
,	O
force	int
,	O
is_linux	int
)	O
)	O
break	O
;	O
free	function
(	O
filename	pointer
)	O
;	O
}	O
if	O
(	O
search	pointer
!=	O
NULL	O
)	O
break	O
;	O
}	O
if	O
(	O
force	int
<	O
2	int
)	O
continue	O
;	O
einfo	pointer
(	O
_	O
(	O
"%P: warning: %s, needed by %pB, not found "	pointer
"(try using -rpath or -rpath-link)\n"	pointer
)	O
,	O
l	pointer
->	O
name	pointer
,	O
l	pointer
->	O
by	pointer
)	O
;	O
}	O
if	O
(	O
link_info	struct
.	O
eh_frame_hdr_type	int
==	O
COMPACT_EH_HDR	int
)	O
if	O
(	O
!	O
bfd_elf_parse_eh_frame_entries	function
(	O
NULL	O
,	O
&	O
link_info	struct
)	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: failed to parse EH frame entries\n"	pointer
)	O
)	O
;	O
}	O
static	O
bfd_size_type	long
id_note_section_size	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
const	O
char	O
*	O
style	pointer
=	O
ldelf_emit_note_gnu_build_id	pointer
;	O
bfd_size_type	long
size	int
;	O
bfd_size_type	long
build_id_size	long
;	O
size	int
=	O
offsetof	O
(	O
Elf_External_Note	struct
,	O
name	pointer
[	O
sizeof	O
"GNU"	pointer
]	O
)	O
;	O
size	int
=	O
(	O
size	int
+	O
3	int
)	O
&	O
-	O
(	O
bfd_size_type	long
)	O
4	int
;	O
build_id_size	long
=	O
compute_build_id_size	function
(	O
style	pointer
)	O
;	O
if	O
(	O
build_id_size	long
)	O
size	int
+=	O
build_id_size	long
;	O
else	O
size	int
=	O
0	int
;	O
return	O
size	int
;	O
}	O
static	O
bfd_boolean	int
write_build_id	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
struct	O
elf_obj_tdata	struct
*	O
t	pointer
=	O
elf_tdata	O
(	O
abfd	pointer
)	O
;	O
const	O
char	O
*	O
style	pointer
;	O
asection	struct
*	O
asec	pointer
;	O
Elf_Internal_Shdr	struct
*	O
i_shdr	pointer
;	O
unsigned	O
char	O
*	O
contents	pointer
,	O
*	O
id_bits	pointer
;	O
bfd_size_type	long
size	int
;	O
file_ptr	long
position	long
;	O
Elf_External_Note	struct
*	O
e_note	pointer
;	O
style	pointer
=	O
t	pointer
->	O
o	pointer
->	O
build_id	pointer
.	O
style	pointer
;	O
asec	pointer
=	O
t	pointer
->	O
o	pointer
->	O
build_id	pointer
.	O
sec	pointer
;	O
if	O
(	O
bfd_is_abs_section	function
(	O
asec	pointer
->	O
output_section	pointer
)	O
)	O
{	O
einfo	pointer
(	O
_	O
(	O
"%P: warning: .note.gnu.build-id section discarded,"	pointer
" --build-id ignored\n"	pointer
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
i_shdr	pointer
=	O
&	O
elf_section_data	O
(	O
asec	pointer
->	O
output_section	pointer
)	O
->	O
this_hdr	struct
;	O
if	O
(	O
i_shdr	pointer
->	O
contents	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
asec	pointer
->	O
contents	pointer
==	O
NULL	O
)	O
asec	pointer
->	O
contents	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
xmalloc	function
(	O
asec	pointer
->	O
size	int
)	O
;	O
contents	pointer
=	O
asec	pointer
->	O
contents	pointer
;	O
}	O
else	O
contents	pointer
=	O
i_shdr	pointer
->	O
contents	pointer
+	O
asec	pointer
->	O
output_offset	long
;	O
e_note	pointer
=	O
(	O
Elf_External_Note	struct
*	O
)	O
contents	pointer
;	O
size	int
=	O
offsetof	O
(	O
Elf_External_Note	struct
,	O
name	pointer
[	O
sizeof	O
"GNU"	pointer
]	O
)	O
;	O
size	int
=	O
(	O
size	int
+	O
3	int
)	O
&	O
-	O
(	O
bfd_size_type	long
)	O
4	int
;	O
id_bits	pointer
=	O
contents	pointer
+	O
size	int
;	O
size	int
=	O
asec	pointer
->	O
size	int
-	O
size	int
;	O
bfd_h_put_32	O
(	O
abfd	pointer
,	O
sizeof	O
"GNU"	pointer
,	O
&	O
e_note	pointer
->	O
namesz	array
)	O
;	O
bfd_h_put_32	O
(	O
abfd	pointer
,	O
size	int
,	O
&	O
e_note	pointer
->	O
descsz	array
)	O
;	O
bfd_h_put_32	O
(	O
abfd	pointer
,	O
NT_GNU_BUILD_ID	int
,	O
&	O
e_note	pointer
->	O
type	enum
)	O
;	O
memcpy	function
(	O
e_note	pointer
->	O
name	pointer
,	O
"GNU"	pointer
,	O
sizeof	O
"GNU"	pointer
)	O
;	O
generate_build_id	function
(	O
abfd	pointer
,	O
style	pointer
,	O
bed	pointer
->	O
s	pointer
->	O
checksum_contents	pointer
,	O
id_bits	pointer
,	O
size	int
)	O
;	O
position	long
=	O
i_shdr	pointer
->	O
sh_offset	array
+	O
asec	pointer
->	O
output_offset	long
;	O
size	int
=	O
asec	pointer
->	O
size	int
;	O
return	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
position	long
,	O
SEEK_SET	int
)	O
==	O
0	int
&&	O
bfd_bwrite	function
(	O
contents	pointer
,	O
size	int
,	O
abfd	pointer
)	O
==	O
size	int
)	O
;	O
}	O
bfd_boolean	int
ldelf_setup_build_id	function
(	O
bfd	struct
*	O
ibfd	pointer
)	O
{	O
asection	struct
*	O
s	pointer
;	O
bfd_size_type	long
size	int
;	O
flagword	int
flags	int
;	O
size	int
=	O
id_note_section_size	function
(	O
ibfd	pointer
)	O
;	O
if	O
(	O
size	int
==	O
0	int
)	O
{	O
einfo	pointer
(	O
_	O
(	O
"%P: warning: unrecognized --build-id style ignored\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
flags	int
=	O
(	O
SEC_ALLOC	int
|	O
SEC_LOAD	int
|	O
SEC_IN_MEMORY	int
|	O
SEC_LINKER_CREATED	int
|	O
SEC_READONLY	int
|	O
SEC_DATA	int
)	O
;	O
s	pointer
=	O
bfd_make_section_with_flags	function
(	O
ibfd	pointer
,	O
".note.gnu.build-id"	pointer
,	O
flags	int
)	O
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
&&	O
bfd_set_section_alignment	function
(	O
s	pointer
,	O
2	int
)	O
)	O
{	O
struct	O
elf_obj_tdata	struct
*	O
t	pointer
=	O
elf_tdata	O
(	O
link_info	struct
.	O
output_bfd	pointer
)	O
;	O
t	pointer
->	O
o	pointer
->	O
build_id	pointer
.	O
after_write_object_contents	pointer
=	O
&	O
write_build_id	function
;	O
t	pointer
->	O
o	pointer
->	O
build_id	pointer
.	O
style	pointer
=	O
ldelf_emit_note_gnu_build_id	pointer
;	O
t	pointer
->	O
o	pointer
->	O
build_id	pointer
.	O
sec	pointer
=	O
s	pointer
;	O
elf_section_type	O
(	O
s	pointer
)	O
=	O
SHT_NOTE	int
;	O
s	pointer
->	O
size	int
=	O
size	int
;	O
return	O
TRUE	int
;	O
}	O
einfo	pointer
(	O
_	O
(	O
"%P: warning: cannot create .note.gnu.build-id section,"	pointer
" --build-id ignored\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
static	O
void	O
ldelf_find_exp_assignment	function
(	O
etree_type	union
*	O
exp	pointer
)	O
{	O
bfd_boolean	int
provide	int
=	O
FALSE	int
;	O
switch	O
(	O
exp	pointer
->	O
type	enum
.	O
node_class	enum
)	O
{	O
case	O
etree_provide	int
:	O
case	O
etree_provided	int
:	O
provide	int
=	O
TRUE	int
;	O
case	O
etree_assign	int
:	O
if	O
(	O
strcmp	function
(	O
exp	pointer
->	O
assign	struct
.	O
dst	pointer
,	O
"."	pointer
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
!	O
bfd_elf_record_link_assignment	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
&	O
link_info	struct
,	O
exp	pointer
->	O
assign	struct
.	O
dst	pointer
,	O
provide	int
,	O
exp	pointer
->	O
assign	struct
.	O
hidden	int
)	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: failed to record assignment to %s: %E\n"	pointer
)	O
,	O
exp	pointer
->	O
assign	struct
.	O
dst	pointer
)	O
;	O
}	O
ldelf_find_exp_assignment	function
(	O
exp	pointer
->	O
assign	struct
.	O
src	pointer
)	O
;	O
break	O
;	O
case	O
etree_binary	int
:	O
ldelf_find_exp_assignment	function
(	O
exp	pointer
->	O
binary	int
.	O
lhs	pointer
)	O
;	O
ldelf_find_exp_assignment	function
(	O
exp	pointer
->	O
binary	int
.	O
rhs	pointer
)	O
;	O
break	O
;	O
case	O
etree_trinary	int
:	O
ldelf_find_exp_assignment	function
(	O
exp	pointer
->	O
trinary	struct
.	O
cond	pointer
)	O
;	O
ldelf_find_exp_assignment	function
(	O
exp	pointer
->	O
trinary	struct
.	O
lhs	pointer
)	O
;	O
ldelf_find_exp_assignment	function
(	O
exp	pointer
->	O
trinary	struct
.	O
rhs	pointer
)	O
;	O
break	O
;	O
case	O
etree_unary	int
:	O
ldelf_find_exp_assignment	function
(	O
exp	pointer
->	O
unary	struct
.	O
child	pointer
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
static	O
void	O
ldelf_find_statement_assignment	function
(	O
lang_statement_union_type	union
*	O
s	pointer
)	O
{	O
if	O
(	O
s	pointer
->	O
header	struct
.	O
type	enum
==	O
lang_assignment_statement_enum	int
)	O
ldelf_find_exp_assignment	function
(	O
s	pointer
->	O
assignment_statement	struct
.	O
exp	pointer
)	O
;	O
}	O
void	O
ldelf_append_to_separated_string	function
(	O
char	O
*	O
*	O
to	pointer
,	O
char	O
*	O
op_arg	pointer
)	O
{	O
if	O
(	O
*	O
to	pointer
==	O
NULL	O
)	O
*	O
to	pointer
=	O
xstrdup	function
(	O
op_arg	pointer
)	O
;	O
else	O
{	O
size_t	long
to_len	long
=	O
strlen	function
(	O
*	O
to	pointer
)	O
;	O
size_t	long
op_arg_len	long
=	O
strlen	function
(	O
op_arg	pointer
)	O
;	O
char	O
*	O
buf	pointer
;	O
char	O
*	O
cp	pointer
=	O
*	O
to	pointer
;	O
do	O
{	O
if	O
(	O
strncmp	function
(	O
op_arg	pointer
,	O
cp	pointer
,	O
op_arg_len	long
)	O
==	O
0	int
&&	O
(	O
cp	pointer
[	O
op_arg_len	long
]	O
==	O
0	int
||	O
cp	pointer
[	O
op_arg_len	long
]	O
==	O
config	struct
.	O
rpath_separator	char
)	O
)	O
break	O
;	O
cp	pointer
=	O
strchr	function
(	O
cp	pointer
,	O
config	struct
.	O
rpath_separator	char
)	O
;	O
if	O
(	O
cp	pointer
!=	O
NULL	O
)	O
++	O
cp	pointer
;	O
}	O
while	O
(	O
cp	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
cp	pointer
==	O
NULL	O
)	O
{	O
buf	pointer
=	O
xmalloc	function
(	O
to_len	long
+	O
op_arg_len	long
+	O
2	int
)	O
;	O
sprintf	function
(	O
buf	pointer
,	O
"%s%c%s"	pointer
,	O
*	O
to	pointer
,	O
config	struct
.	O
rpath_separator	char
,	O
op_arg	pointer
)	O
;	O
free	function
(	O
*	O
to	pointer
)	O
;	O
*	O
to	pointer
=	O
buf	pointer
;	O
}	O
}	O
}	O
void	O
ldelf_before_allocation	function
(	O
char	O
*	O
audit	pointer
,	O
char	O
*	O
depaudit	pointer
,	O
const	O
char	O
*	O
default_interpreter_name	pointer
)	O
{	O
const	O
char	O
*	O
rpath	pointer
;	O
asection	struct
*	O
sinterp	pointer
;	O
bfd	struct
*	O
abfd	pointer
;	O
struct	O
bfd_link_hash_entry	struct
*	O
ehdr_start	pointer
=	O
NULL	O
;	O
unsigned	O
char	O
ehdr_start_save_type	char
=	O
0	int
;	O
char	O
ehdr_start_save_u	array
[	O
sizeof	O
ehdr_start	pointer
->	O
u	union
-	O
sizeof	O
ehdr_start	pointer
->	O
u	union
.	O
def	struct
.	O
next	pointer
]	O
=	O
""	pointer
;	O
if	O
(	O
is_elf_hash_table	O
(	O
link_info	struct
.	O
hash	long
)	O
)	O
{	O
_bfd_elf_tls_setup	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
&	O
link_info	struct
)	O
;	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
)	O
{	O
struct	O
elf_link_hash_table	struct
*	O
htab	struct
=	O
elf_hash_table	O
(	O
&	O
link_info	struct
)	O
;	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
=	O
elf_link_hash_lookup	O
(	O
htab	struct
,	O
"__ehdr_start"	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
&&	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_new	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefined	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefweak	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_common	int
)	O
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
link_info	struct
.	O
output_bfd	pointer
)	O
;	O
(	O
*	O
bed	pointer
->	O
elf_backend_hide_symbol	pointer
)	O
(	O
&	O
link_info	struct
,	O
h	pointer
,	O
TRUE	int
)	O
;	O
if	O
(	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
!=	O
STV_INTERNAL	int
)	O
h	pointer
->	O
other	int
=	O
(	O
h	pointer
->	O
other	int
&	O
~	O
ELF_ST_VISIBILITY	O
(	O
-	O
1	int
)	O
)	O
|	O
STV_HIDDEN	int
;	O
ehdr_start	pointer
=	O
&	O
h	pointer
->	O
root	struct
;	O
ehdr_start_save_type	char
=	O
ehdr_start	pointer
->	O
type	enum
;	O
memcpy	function
(	O
ehdr_start_save_u	array
,	O
(	O
char	O
*	O
)	O
&	O
ehdr_start	pointer
->	O
u	union
+	O
sizeof	O
ehdr_start	pointer
->	O
u	union
.	O
def	struct
.	O
next	pointer
,	O
sizeof	O
ehdr_start_save_u	array
)	O
;	O
ehdr_start	pointer
->	O
type	enum
=	O
bfd_link_hash_defined	int
;	O
ehdr_start	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
=	O
bfd_abs_section_ptr	O
;	O
ehdr_start	pointer
->	O
u	union
.	O
def	struct
.	O
value	long
=	O
0	int
;	O
}	O
}	O
lang_for_each_statement	function
(	O
ldelf_find_statement_assignment	function
)	O
;	O
}	O
rpath	pointer
=	O
command_line	struct
.	O
rpath	pointer
;	O
if	O
(	O
rpath	pointer
==	O
NULL	O
)	O
rpath	pointer
=	O
(	O
const	O
char	O
*	O
)	O
getenv	function
(	O
"LD_RUN_PATH"	pointer
)	O
;	O
for	O
(	O
abfd	pointer
=	O
link_info	struct
.	O
input_bfds	pointer
;	O
abfd	pointer
;	O
abfd	pointer
=	O
abfd	pointer
->	O
link	function
.	O
next	pointer
)	O
if	O
(	O
bfd_get_flavour	function
(	O
abfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
)	O
{	O
const	O
char	O
*	O
audit_libs	pointer
=	O
elf_dt_audit	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
audit_libs	pointer
&&	O
*	O
audit_libs	pointer
!=	O
'\0'	O
)	O
{	O
char	O
*	O
cp	pointer
=	O
xstrdup	function
(	O
audit_libs	pointer
)	O
;	O
do	O
{	O
int	O
more	int
=	O
0	int
;	O
char	O
*	O
cp2	pointer
=	O
strchr	function
(	O
cp	pointer
,	O
config	struct
.	O
rpath_separator	char
)	O
;	O
if	O
(	O
cp2	pointer
)	O
{	O
*	O
cp2	pointer
=	O
'\0'	O
;	O
more	int
=	O
1	int
;	O
}	O
if	O
(	O
cp	pointer
!=	O
NULL	O
&&	O
*	O
cp	pointer
!=	O
'\0'	O
)	O
ldelf_append_to_separated_string	function
(	O
&	O
depaudit	pointer
,	O
cp	pointer
)	O
;	O
cp	pointer
=	O
more	int
?	O
++	O
cp2	pointer
:	O
NULL	O
;	O
}	O
while	O
(	O
cp	pointer
!=	O
NULL	O
)	O
;	O
}	O
}	O
if	O
(	O
!	O
(	O
bfd_elf_size_dynamic_sections	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
command_line	struct
.	O
soname	pointer
,	O
rpath	pointer
,	O
command_line	struct
.	O
filter_shlib	pointer
,	O
audit	pointer
,	O
depaudit	pointer
,	O
(	O
const	O
char	O
*	O
const	O
*	O
)	O
command_line	struct
.	O
auxiliary_filters	pointer
,	O
&	O
link_info	struct
,	O
&	O
sinterp	pointer
)	O
)	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: failed to set dynamic section sizes: %E\n"	pointer
)	O
)	O
;	O
if	O
(	O
sinterp	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
command_line	struct
.	O
interpreter	pointer
!=	O
NULL	O
)	O
default_interpreter_name	pointer
=	O
command_line	struct
.	O
interpreter	pointer
;	O
if	O
(	O
default_interpreter_name	pointer
!=	O
NULL	O
)	O
{	O
sinterp	pointer
->	O
contents	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
default_interpreter_name	pointer
;	O
sinterp	pointer
->	O
size	int
=	O
strlen	function
(	O
(	O
char	O
*	O
)	O
sinterp	pointer
->	O
contents	pointer
)	O
+	O
1	int
;	O
}	O
}	O
{	O
LANG_FOR_EACH_INPUT_STATEMENT	O
(	O
is	pointer
)	O
{	O
asection	struct
*	O
s	pointer
;	O
bfd_size_type	long
sz	long
;	O
char	O
*	O
msg	pointer
;	O
if	O
(	O
is	pointer
->	O
flags	int
.	O
just_syms	int
)	O
continue	O
;	O
s	pointer
=	O
bfd_get_section_by_name	function
(	O
is	pointer
->	O
the_bfd	pointer
,	O
".gnu.warning"	pointer
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
continue	O
;	O
sz	long
=	O
s	pointer
->	O
size	int
;	O
msg	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
(	O
size_t	long
)	O
(	O
sz	long
+	O
1	int
)	O
)	O
;	O
if	O
(	O
!	O
bfd_get_section_contents	function
(	O
is	pointer
->	O
the_bfd	pointer
,	O
s	pointer
,	O
msg	pointer
,	O
(	O
file_ptr	long
)	O
0	int
,	O
sz	long
)	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: %pB: can't read contents of section .gnu.warning: %E\n"	pointer
)	O
,	O
is	pointer
->	O
the_bfd	pointer
)	O
;	O
msg	pointer
[	O
sz	long
]	O
=	O
'\0'	O
;	O
(	O
*	O
link_info	struct
.	O
callbacks	pointer
->	O
warning	pointer
)	O
(	O
&	O
link_info	struct
,	O
msg	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
is	pointer
->	O
the_bfd	pointer
,	O
(	O
asection	struct
*	O
)	O
NULL	O
,	O
(	O
bfd_vma	long
)	O
0	int
)	O
;	O
free	function
(	O
msg	pointer
)	O
;	O
if	O
(	O
s	pointer
->	O
output_section	pointer
!=	O
NULL	O
&&	O
s	pointer
->	O
output_section	pointer
->	O
rawsize	long
>=	O
s	pointer
->	O
size	int
)	O
s	pointer
->	O
output_section	pointer
->	O
rawsize	long
-=	O
s	pointer
->	O
size	int
;	O
s	pointer
->	O
size	int
=	O
0	int
;	O
s	pointer
->	O
flags	int
|=	O
SEC_EXCLUDE	int
|	O
SEC_KEEP	int
;	O
}	O
}	O
before_allocation_default	function
(	O
)	O
;	O
if	O
(	O
!	O
bfd_elf_size_dynsym_hash_dynstr	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
&	O
link_info	struct
)	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: failed to set dynamic section sizes: %E\n"	pointer
)	O
)	O
;	O
if	O
(	O
ehdr_start	pointer
!=	O
NULL	O
)	O
{	O
ehdr_start	pointer
->	O
type	enum
=	O
ehdr_start_save_type	char
;	O
memcpy	function
(	O
(	O
char	O
*	O
)	O
&	O
ehdr_start	pointer
->	O
u	union
+	O
sizeof	O
ehdr_start	pointer
->	O
u	union
.	O
def	struct
.	O
next	pointer
,	O
ehdr_start_save_u	array
,	O
sizeof	O
ehdr_start_save_u	array
)	O
;	O
}	O
}	O
bfd_boolean	int
ldelf_open_dynamic_archive	function
(	O
const	O
char	O
*	O
arch	enum
,	O
search_dirs_type	struct
*	O
search	pointer
,	O
lang_input_statement_type	struct
*	O
entry	pointer
)	O
{	O
const	O
char	O
*	O
filename	pointer
;	O
char	O
*	O
string	pointer
;	O
size_t	long
len	long
;	O
bfd_boolean	int
opened	int
=	O
FALSE	int
;	O
if	O
(	O
!	O
entry	pointer
->	O
flags	int
.	O
maybe_archive	int
)	O
return	O
FALSE	int
;	O
filename	pointer
=	O
entry	pointer
->	O
filename	pointer
;	O
len	long
=	O
strlen	function
(	O
search	pointer
->	O
name	pointer
)	O
+	O
strlen	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
entry	pointer
->	O
flags	int
.	O
full_name_provided	int
)	O
{	O
len	long
+=	O
sizeof	O
"/"	pointer
;	O
string	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
len	long
)	O
;	O
sprintf	function
(	O
string	pointer
,	O
"%s/%s"	pointer
,	O
search	pointer
->	O
name	pointer
,	O
filename	pointer
)	O
;	O
}	O
else	O
{	O
size_t	long
xlen	long
=	O
0	int
;	O
len	long
+=	O
strlen	function
(	O
arch	enum
)	O
+	O
sizeof	O
"/lib.so"	pointer
;	O
string	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
len	long
+	O
xlen	long
)	O
;	O
sprintf	function
(	O
string	pointer
,	O
"%s/lib%s%s.so"	pointer
,	O
search	pointer
->	O
name	pointer
,	O
filename	pointer
,	O
arch	enum
)	O
;	O
}	O
if	O
(	O
!	O
opened	int
&&	O
!	O
ldfile_try_open_bfd	function
(	O
string	pointer
,	O
entry	pointer
)	O
)	O
{	O
free	function
(	O
string	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
entry	pointer
->	O
filename	pointer
=	O
string	pointer
;	O
if	O
(	O
bfd_check_format	function
(	O
entry	pointer
->	O
the_bfd	pointer
,	O
bfd_object	int
)	O
&&	O
(	O
entry	pointer
->	O
the_bfd	pointer
->	O
flags	int
&	O
DYNAMIC	int
)	O
!=	O
0	int
)	O
{	O
ASSERT	O
(	O
entry	pointer
->	O
flags	int
.	O
maybe_archive	int
&&	O
entry	pointer
->	O
flags	int
.	O
search_dirs	int
)	O
;	O
if	O
(	O
!	O
entry	pointer
->	O
flags	int
.	O
full_name_provided	int
)	O
filename	pointer
=	O
lbasename	function
(	O
entry	pointer
->	O
filename	pointer
)	O
;	O
bfd_elf_set_dt_needed_name	function
(	O
entry	pointer
->	O
the_bfd	pointer
,	O
filename	pointer
)	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
lang_output_section_statement_type	struct
*	O
output_rel_find	function
(	O
int	O
isdyn	int
,	O
int	O
rela	struct
)	O
{	O
lang_output_section_statement_type	struct
*	O
lookup	pointer
;	O
lang_output_section_statement_type	struct
*	O
last	pointer
=	O
NULL	O
;	O
lang_output_section_statement_type	struct
*	O
last_alloc	pointer
=	O
NULL	O
;	O
lang_output_section_statement_type	struct
*	O
last_ro_alloc	pointer
=	O
NULL	O
;	O
lang_output_section_statement_type	struct
*	O
last_rel	pointer
=	O
NULL	O
;	O
lang_output_section_statement_type	struct
*	O
last_rel_alloc	pointer
=	O
NULL	O
;	O
for	O
(	O
lookup	pointer
=	O
(	O
void	O
*	O
)	O
lang_os_list	struct
.	O
head	pointer
;	O
lookup	pointer
!=	O
NULL	O
;	O
lookup	pointer
=	O
lookup	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
lookup	pointer
->	O
constraint	int
>=	O
0	int
&&	O
CONST_STRNEQ	O
(	O
lookup	pointer
->	O
name	pointer
,	O
".rel"	pointer
)	O
)	O
{	O
int	O
lookrela	int
=	O
lookup	pointer
->	O
name	pointer
[	O
4	int
]	O
==	O
'a'	O
;	O
if	O
(	O
isdyn	int
)	O
break	O
;	O
if	O
(	O
strcmp	function
(	O
".plt"	pointer
,	O
lookup	pointer
->	O
name	pointer
+	O
4	int
+	O
lookrela	int
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
rela	struct
==	O
lookrela	int
||	O
last_rel	pointer
==	O
NULL	O
)	O
last_rel	pointer
=	O
lookup	pointer
;	O
if	O
(	O
(	O
rela	struct
==	O
lookrela	int
||	O
last_rel_alloc	pointer
==	O
NULL	O
)	O
&&	O
lookup	pointer
->	O
bfd_section	struct
!=	O
NULL	O
&&	O
(	O
lookup	pointer
->	O
bfd_section	struct
->	O
flags	int
&	O
SEC_ALLOC	int
)	O
!=	O
0	int
)	O
last_rel_alloc	pointer
=	O
lookup	pointer
;	O
}	O
last	pointer
=	O
lookup	pointer
;	O
if	O
(	O
lookup	pointer
->	O
bfd_section	struct
!=	O
NULL	O
&&	O
(	O
lookup	pointer
->	O
bfd_section	struct
->	O
flags	int
&	O
SEC_ALLOC	int
)	O
!=	O
0	int
)	O
{	O
last_alloc	pointer
=	O
lookup	pointer
;	O
if	O
(	O
(	O
lookup	pointer
->	O
bfd_section	struct
->	O
flags	int
&	O
SEC_READONLY	int
)	O
!=	O
0	int
)	O
last_ro_alloc	pointer
=	O
lookup	pointer
;	O
}	O
}	O
if	O
(	O
last_rel_alloc	pointer
)	O
return	O
last_rel_alloc	pointer
;	O
if	O
(	O
last_rel	pointer
)	O
return	O
last_rel	pointer
;	O
if	O
(	O
last_ro_alloc	pointer
)	O
return	O
last_ro_alloc	pointer
;	O
if	O
(	O
last_alloc	pointer
)	O
return	O
last_alloc	pointer
;	O
return	O
last	pointer
;	O
}	O
static	O
bfd_boolean	int
elf_orphan_compatible	function
(	O
asection	struct
*	O
in	pointer
,	O
asection	struct
*	O
out	pointer
)	O
{	O
if	O
(	O
elf_section_data	O
(	O
out	pointer
)	O
->	O
this_hdr	struct
.	O
sh_info	array
!=	O
elf_section_data	O
(	O
in	pointer
)	O
->	O
this_hdr	struct
.	O
sh_info	array
)	O
return	O
FALSE	int
;	O
if	O
(	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
&&	O
(	O
elf_next_in_group	O
(	O
out	pointer
)	O
!=	O
NULL	O
||	O
(	O
(	O
elf_section_flags	O
(	O
out	pointer
)	O
^	O
elf_section_flags	O
(	O
in	pointer
)	O
)	O
&	O
SHF_EXCLUDE	int
)	O
!=	O
0	int
)	O
)	O
return	O
FALSE	int
;	O
return	O
_bfd_elf_match_sections_by_type	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
out	pointer
,	O
in	pointer
->	O
owner	pointer
,	O
in	pointer
)	O
;	O
}	O
lang_output_section_statement_type	struct
*	O
ldelf_place_orphan	function
(	O
asection	struct
*	O
s	pointer
,	O
const	O
char	O
*	O
secname	pointer
,	O
int	O
constraint	int
)	O
{	O
static	O
struct	O
orphan_save	struct
hold	array
[	O
]	O
=	O
{	O
{	O
".text"	pointer
,	O
SEC_HAS_CONTENTS	int
|	O
SEC_ALLOC	int
|	O
SEC_LOAD	int
|	O
SEC_READONLY	int
|	O
SEC_CODE	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
".rodata"	pointer
,	O
SEC_HAS_CONTENTS	int
|	O
SEC_ALLOC	int
|	O
SEC_LOAD	int
|	O
SEC_READONLY	int
|	O
SEC_DATA	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
".tdata"	pointer
,	O
SEC_HAS_CONTENTS	int
|	O
SEC_ALLOC	int
|	O
SEC_LOAD	int
|	O
SEC_DATA	int
|	O
SEC_THREAD_LOCAL	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
".data"	pointer
,	O
SEC_HAS_CONTENTS	int
|	O
SEC_ALLOC	int
|	O
SEC_LOAD	int
|	O
SEC_DATA	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
".bss"	pointer
,	O
SEC_ALLOC	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
SEC_HAS_CONTENTS	int
|	O
SEC_ALLOC	int
|	O
SEC_LOAD	int
|	O
SEC_READONLY	int
|	O
SEC_DATA	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
".interp"	pointer
,	O
SEC_HAS_CONTENTS	int
|	O
SEC_ALLOC	int
|	O
SEC_LOAD	int
|	O
SEC_READONLY	int
|	O
SEC_DATA	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
".sdata"	pointer
,	O
SEC_HAS_CONTENTS	int
|	O
SEC_ALLOC	int
|	O
SEC_LOAD	int
|	O
SEC_DATA	int
|	O
SEC_SMALL_DATA	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
".comment"	pointer
,	O
SEC_HAS_CONTENTS	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
}	O
;	O
enum	O
orphan_save_index	enum
{	O
orphan_text	int
=	O
0	int
,	O
orphan_rodata	int
,	O
orphan_tdata	int
,	O
orphan_data	int
,	O
orphan_bss	int
,	O
orphan_rel	int
,	O
orphan_interp	int
,	O
orphan_sdata	int
,	O
orphan_nonalloc	int
}	O
;	O
static	O
int	O
orphan_init_done	int
=	O
0	int
;	O
struct	O
orphan_save	struct
*	O
place	pointer
;	O
lang_output_section_statement_type	struct
*	O
after	pointer
;	O
lang_output_section_statement_type	struct
*	O
os	int
;	O
lang_output_section_statement_type	struct
*	O
match_by_name	pointer
=	O
NULL	O
;	O
int	O
isdyn	int
=	O
0	int
;	O
int	O
elfinput	int
=	O
s	pointer
->	O
owner	pointer
->	O
xvec	pointer
->	O
flavour	enum
==	O
bfd_target_elf_flavour	int
;	O
int	O
elfoutput	int
=	O
link_info	struct
.	O
output_bfd	pointer
->	O
xvec	pointer
->	O
flavour	enum
==	O
bfd_target_elf_flavour	int
;	O
unsigned	O
int	O
sh_type	array
=	O
elfinput	int
?	O
elf_section_type	O
(	O
s	pointer
)	O
:	O
SHT_NULL	int
;	O
flagword	int
flags	int
;	O
asection	struct
*	O
nexts	pointer
;	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
&&	O
link_info	struct
.	O
combreloc	int
&&	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_ALLOC	int
)	O
)	O
{	O
if	O
(	O
elfinput	int
)	O
switch	O
(	O
sh_type	array
)	O
{	O
case	O
SHT_RELA	int
:	O
secname	pointer
=	O
".rela.dyn"	pointer
;	O
isdyn	int
=	O
1	int
;	O
break	O
;	O
case	O
SHT_REL	int
:	O
secname	pointer
=	O
".rel.dyn"	pointer
;	O
isdyn	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
else	O
if	O
(	O
CONST_STRNEQ	O
(	O
secname	pointer
,	O
".rel"	pointer
)	O
)	O
{	O
secname	pointer
=	O
secname	pointer
[	O
4	int
]	O
==	O
'a'	O
?	O
".rela.dyn"	pointer
:	O
".rel.dyn"	pointer
;	O
isdyn	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
&&	O
elfinput	int
&&	O
elfoutput	int
&&	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_ALLOC	int
)	O
!=	O
0	int
&&	O
(	O
elf_tdata	O
(	O
s	pointer
->	O
owner	pointer
)	O
->	O
has_gnu_osabi	enum
&	O
elf_gnu_osabi_mbind	int
)	O
!=	O
0	int
&&	O
(	O
elf_section_flags	O
(	O
s	pointer
)	O
&	O
SHF_GNU_MBIND	int
)	O
!=	O
0	int
)	O
{	O
for	O
(	O
os	int
=	O
(	O
void	O
*	O
)	O
lang_os_list	struct
.	O
head	pointer
;	O
os	int
!=	O
NULL	O
;	O
os	int
=	O
os	int
->	O
next	pointer
)	O
if	O
(	O
os	int
->	O
bfd_section	struct
!=	O
NULL	O
&&	O
!	O
bfd_is_abs_section	function
(	O
os	int
->	O
bfd_section	struct
)	O
&&	O
(	O
elf_section_flags	O
(	O
os	int
->	O
bfd_section	struct
)	O
&	O
SHF_GNU_MBIND	int
)	O
!=	O
0	int
&&	O
(	O
(	O
s	pointer
->	O
flags	int
&	O
(	O
SEC_ALLOC	int
|	O
SEC_LOAD	int
|	O
SEC_HAS_CONTENTS	int
|	O
SEC_READONLY	int
|	O
SEC_CODE	int
)	O
)	O
==	O
(	O
os	int
->	O
bfd_section	struct
->	O
flags	int
&	O
(	O
SEC_ALLOC	int
|	O
SEC_LOAD	int
|	O
SEC_HAS_CONTENTS	int
|	O
SEC_READONLY	int
|	O
SEC_CODE	int
)	O
)	O
)	O
&&	O
(	O
elf_section_data	O
(	O
os	int
->	O
bfd_section	struct
)	O
->	O
this_hdr	struct
.	O
sh_info	array
==	O
elf_section_data	O
(	O
s	pointer
)	O
->	O
this_hdr	struct
.	O
sh_info	array
)	O
)	O
{	O
lang_add_section	function
(	O
&	O
os	int
->	O
children	struct
,	O
s	pointer
,	O
NULL	O
,	O
os	int
)	O
;	O
return	O
os	int
;	O
}	O
if	O
(	O
(	O
s	pointer
->	O
flags	int
&	O
(	O
SEC_LOAD	int
|	O
SEC_HAS_CONTENTS	int
)	O
)	O
==	O
0	int
)	O
secname	pointer
=	O
".mbind.bss"	pointer
;	O
else	O
if	O
(	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_READONLY	int
)	O
==	O
0	int
)	O
secname	pointer
=	O
".mbind.data"	pointer
;	O
else	O
if	O
(	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_CODE	int
)	O
==	O
0	int
)	O
secname	pointer
=	O
".mbind.rodata"	pointer
;	O
else	O
secname	pointer
=	O
".mbind.text"	pointer
;	O
elf_tdata	O
(	O
link_info	struct
.	O
output_bfd	pointer
)	O
->	O
has_gnu_osabi	enum
|=	O
elf_gnu_osabi_mbind	int
;	O
}	O
if	O
(	O
constraint	int
==	O
0	int
)	O
for	O
(	O
os	int
=	O
lang_output_section_find	O
(	O
secname	pointer
)	O
;	O
os	int
!=	O
NULL	O
;	O
os	int
=	O
next_matching_output_section_statement	function
(	O
os	int
,	O
0	int
)	O
)	O
{	O
constraint	int
=	O
SPECIAL	int
;	O
if	O
(	O
os	int
->	O
bfd_section	struct
!=	O
NULL	O
&&	O
(	O
os	int
->	O
bfd_section	struct
->	O
flags	int
==	O
0	int
||	O
(	O
(	O
(	O
s	pointer
->	O
flags	int
^	O
os	int
->	O
bfd_section	struct
->	O
flags	int
)	O
&	O
(	O
SEC_LOAD	int
|	O
SEC_ALLOC	int
)	O
)	O
==	O
0	int
&&	O
(	O
!	O
elfinput	int
||	O
!	O
elfoutput	int
||	O
elf_orphan_compatible	function
(	O
s	pointer
,	O
os	int
->	O
bfd_section	struct
)	O
)	O
)	O
)	O
)	O
{	O
lang_add_section	function
(	O
&	O
os	int
->	O
children	struct
,	O
s	pointer
,	O
NULL	O
,	O
os	int
)	O
;	O
return	O
os	int
;	O
}	O
if	O
(	O
os	int
->	O
bfd_section	struct
==	O
NULL	O
)	O
match_by_name	pointer
=	O
os	int
;	O
}	O
if	O
(	O
match_by_name	pointer
)	O
{	O
lang_add_section	function
(	O
&	O
match_by_name	pointer
->	O
children	struct
,	O
s	pointer
,	O
NULL	O
,	O
match_by_name	pointer
)	O
;	O
return	O
match_by_name	pointer
;	O
}	O
if	O
(	O
!	O
orphan_init_done	int
)	O
{	O
struct	O
orphan_save	struct
*	O
ho	pointer
;	O
for	O
(	O
ho	pointer
=	O
hold	array
;	O
ho	pointer
<	O
hold	array
+	O
sizeof	O
(	O
hold	array
)	O
/	O
sizeof	O
(	O
hold	array
[	O
0	int
]	O
)	O
;	O
++	O
ho	pointer
)	O
if	O
(	O
ho	pointer
->	O
name	pointer
!=	O
NULL	O
)	O
{	O
ho	pointer
->	O
os	int
=	O
lang_output_section_find	O
(	O
ho	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
ho	pointer
->	O
os	int
!=	O
NULL	O
&&	O
ho	pointer
->	O
os	int
->	O
flags	int
==	O
0	int
)	O
ho	pointer
->	O
os	int
->	O
flags	int
=	O
ho	pointer
->	O
flags	int
;	O
}	O
orphan_init_done	int
=	O
1	int
;	O
}	O
if	O
(	O
bfd_link_executable	O
(	O
&	O
link_info	struct
)	O
&&	O
CONST_STRNEQ	O
(	O
s	pointer
->	O
name	pointer
,	O
".gnu.warning."	pointer
)	O
&&	O
hold	array
[	O
orphan_text	int
]	O
.	O
os	int
!=	O
NULL	O
)	O
{	O
os	int
=	O
hold	array
[	O
orphan_text	int
]	O
.	O
os	int
;	O
lang_add_section	function
(	O
&	O
os	int
->	O
children	struct
,	O
s	pointer
,	O
NULL	O
,	O
os	int
)	O
;	O
return	O
os	int
;	O
}	O
flags	int
=	O
s	pointer
->	O
flags	int
;	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
)	O
{	O
nexts	pointer
=	O
s	pointer
;	O
while	O
(	O
(	O
nexts	pointer
=	O
bfd_get_next_section_by_name	function
(	O
nexts	pointer
->	O
owner	pointer
,	O
nexts	pointer
)	O
)	O
!=	O
NULL	O
)	O
if	O
(	O
nexts	pointer
->	O
output_section	pointer
==	O
NULL	O
&&	O
(	O
nexts	pointer
->	O
flags	int
&	O
SEC_EXCLUDE	int
)	O
==	O
0	int
&&	O
(	O
(	O
nexts	pointer
->	O
flags	int
^	O
flags	int
)	O
&	O
(	O
SEC_LOAD	int
|	O
SEC_ALLOC	int
)	O
)	O
==	O
0	int
&&	O
(	O
nexts	pointer
->	O
owner	pointer
->	O
flags	int
&	O
DYNAMIC	int
)	O
==	O
0	int
&&	O
!	O
bfd_input_just_syms	function
(	O
nexts	pointer
->	O
owner	pointer
)	O
&&	O
_bfd_elf_match_sections_by_type	function
(	O
nexts	pointer
->	O
owner	pointer
,	O
nexts	pointer
,	O
s	pointer
->	O
owner	pointer
,	O
s	pointer
)	O
)	O
flags	int
=	O
(	O
(	O
(	O
flags	int
^	O
SEC_READONLY	int
)	O
|	O
(	O
nexts	pointer
->	O
flags	int
^	O
SEC_READONLY	int
)	O
)	O
^	O
SEC_READONLY	int
)	O
;	O
}	O
place	pointer
=	O
NULL	O
;	O
if	O
(	O
(	O
flags	int
&	O
(	O
SEC_ALLOC	int
|	O
SEC_DEBUGGING	int
)	O
)	O
==	O
0	int
)	O
place	pointer
=	O
&	O
hold	array
[	O
orphan_nonalloc	int
]	O
;	O
else	O
if	O
(	O
(	O
flags	int
&	O
SEC_ALLOC	int
)	O
==	O
0	int
)	O
;	O
else	O
if	O
(	O
(	O
flags	int
&	O
SEC_LOAD	int
)	O
!=	O
0	int
&&	O
(	O
elfinput	int
?	O
sh_type	array
==	O
SHT_NOTE	int
:	O
CONST_STRNEQ	O
(	O
secname	pointer
,	O
".note"	pointer
)	O
)	O
)	O
place	pointer
=	O
&	O
hold	array
[	O
orphan_interp	int
]	O
;	O
else	O
if	O
(	O
(	O
flags	int
&	O
(	O
SEC_LOAD	int
|	O
SEC_HAS_CONTENTS	int
|	O
SEC_THREAD_LOCAL	int
)	O
)	O
==	O
0	int
)	O
place	pointer
=	O
&	O
hold	array
[	O
orphan_bss	int
]	O
;	O
else	O
if	O
(	O
(	O
flags	int
&	O
SEC_SMALL_DATA	int
)	O
!=	O
0	int
)	O
place	pointer
=	O
&	O
hold	array
[	O
orphan_sdata	int
]	O
;	O
else	O
if	O
(	O
(	O
flags	int
&	O
SEC_THREAD_LOCAL	int
)	O
!=	O
0	int
)	O
place	pointer
=	O
&	O
hold	array
[	O
orphan_tdata	int
]	O
;	O
else	O
if	O
(	O
(	O
flags	int
&	O
SEC_READONLY	int
)	O
==	O
0	int
)	O
place	pointer
=	O
&	O
hold	array
[	O
orphan_data	int
]	O
;	O
else	O
if	O
(	O
(	O
flags	int
&	O
SEC_LOAD	int
)	O
!=	O
0	int
&&	O
(	O
elfinput	int
?	O
sh_type	array
==	O
SHT_RELA	int
||	O
sh_type	array
==	O
SHT_REL	int
:	O
CONST_STRNEQ	O
(	O
secname	pointer
,	O
".rel"	pointer
)	O
)	O
)	O
place	pointer
=	O
&	O
hold	array
[	O
orphan_rel	int
]	O
;	O
else	O
if	O
(	O
(	O
flags	int
&	O
SEC_CODE	int
)	O
==	O
0	int
)	O
place	pointer
=	O
&	O
hold	array
[	O
orphan_rodata	int
]	O
;	O
else	O
place	pointer
=	O
&	O
hold	array
[	O
orphan_text	int
]	O
;	O
after	pointer
=	O
NULL	O
;	O
if	O
(	O
place	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
place	pointer
->	O
os	int
==	O
NULL	O
)	O
{	O
if	O
(	O
place	pointer
->	O
name	pointer
!=	O
NULL	O
)	O
place	pointer
->	O
os	int
=	O
lang_output_section_find	O
(	O
place	pointer
->	O
name	pointer
)	O
;	O
else	O
{	O
int	O
rela	struct
=	O
elfinput	int
?	O
sh_type	array
==	O
SHT_RELA	int
:	O
secname	pointer
[	O
4	int
]	O
==	O
'a'	O
;	O
place	pointer
->	O
os	int
=	O
output_rel_find	function
(	O
isdyn	int
,	O
rela	struct
)	O
;	O
}	O
}	O
after	pointer
=	O
place	pointer
->	O
os	int
;	O
if	O
(	O
after	pointer
==	O
NULL	O
)	O
after	pointer
=	O
lang_output_section_find_by_flags	function
(	O
s	pointer
,	O
flags	int
,	O
&	O
place	pointer
->	O
os	int
,	O
_bfd_elf_match_sections_by_type	function
)	O
;	O
if	O
(	O
after	pointer
==	O
NULL	O
)	O
after	pointer
=	O
(	O
void	O
*	O
)	O
lang_os_list	struct
.	O
head	pointer
;	O
}	O
return	O
lang_insert_orphan	function
(	O
s	pointer
,	O
secname	pointer
,	O
constraint	int
,	O
after	pointer
,	O
place	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
