extern	O
int	O
(	O
*	O
wrapx	pointer
)	O
(	O
)	O
,	O
(	O
*	O
wrapy	pointer
)	O
(	O
)	O
;	O
extern	O
Sworld	struct
world	struct
;	O
extern	O
struct	O
s_desig_map	struct
desig_map	array
[	O
]	O
;	O
extern	O
struct	O
s_altitude_map	struct
altitude_map	array
[	O
]	O
;	O
extern	O
struct	O
item_map	struct
terrains	array
[	O
]	O
;	O
extern	O
struct	O
item_map	struct
climates	array
[	O
]	O
;	O
extern	O
Suser	struct
user	struct
;	O
int	O
viewall	int
;	O
extern	O
int	O
debug	int
;	O
WINDOW	struct
*	O
sectw	pointer
;	O
int	O
interrupt	function
(	O
)	O
{	O
printf	function
(	O
"\r\ngot an interrupt.  quitting nicely...\r\n"	pointer
)	O
;	O
cleanup	function
(	O
)	O
;	O
clean_exit	function
(	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
int	O
alarm_interrupt	function
(	O
)	O
{	O
char	O
message	array
[	O
100	int
]	O
;	O
int	O
i	int
,	O
j	int
;	O
sprintf	function
(	O
message	array
,	O
"You have timed out after %d seconds; quitting nicely"	pointer
,	O
TIMEOUT_SECS	O
)	O
;	O
standout	function
(	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
strlen	function
(	O
message	array
)	O
+	O
3	int
;	O
++	O
i	int
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
3	int
;	O
++	O
j	int
)	O
{	O
move	function
(	O
LINES	int
/	O
2	int
-	O
1	int
+	O
j	int
,	O
(	O
COLS	int
-	O
10	int
-	O
strlen	function
(	O
message	array
)	O
)	O
/	O
2	int
+	O
i	int
)	O
;	O
addch	function
(	O
' '	O
)	O
;	O
}	O
}	O
move	function
(	O
LINES	int
/	O
2	int
,	O
(	O
COLS	int
-	O
strlen	function
(	O
message	array
)	O
)	O
/	O
2	int
-	O
3	int
)	O
;	O
addstr	function
(	O
message	array
)	O
;	O
standend	function
(	O
)	O
;	O
cleanup	function
(	O
)	O
;	O
clean_exit	function
(	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
void	O
show_nation	function
(	O
Snation	struct
*	O
np	pointer
)	O
{	O
printf	function
(	O
"\n\tname: %s (id = %d)\n"	pointer
,	O
np	pointer
->	O
name	array
,	O
np	pointer
->	O
id	short
)	O
;	O
printf	function
(	O
"\tleader: %s\n"	pointer
,	O
np	pointer
->	O
leader	array
)	O
;	O
printf	function
(	O
"\tpasswd: %s\n"	pointer
,	O
np	pointer
->	O
passwd	array
)	O
;	O
printf	function
(	O
"\tcapital is at (%d, %d)\n"	pointer
,	O
np	pointer
->	O
capital	struct
.	O
x	int
,	O
np	pointer
->	O
capital	struct
.	O
y	int
)	O
;	O
printf	function
(	O
"\trace is %s\n"	pointer
,	O
np	pointer
->	O
race	struct
.	O
name	array
)	O
;	O
printf	function
(	O
"\tnation mark is %c\n"	pointer
,	O
np	pointer
->	O
mark	char
)	O
;	O
printf	function
(	O
"\t%d civilians; %d soldiers; %d armies.\n"	pointer
,	O
get_n_civil	function
(	O
np	pointer
)	O
,	O
get_n_soldiers	function
(	O
np	pointer
)	O
,	O
np	pointer
->	O
n_armies	int
)	O
;	O
printf	function
(	O
"\tmagical order %s\n"	pointer
,	O
np	pointer
->	O
mag_order	array
)	O
;	O
}	O
char	O
hex_mark	function
(	O
val	int
)	O
int	O
val	int
;	O
{	O
char	O
mark	char
;	O
if	O
(	O
val	int
<	O
0	int
)	O
{	O
mark	char
=	O
'-'	O
;	O
}	O
else	O
if	O
(	O
val	int
<=	O
9	int
)	O
{	O
mark	char
=	O
val	int
+	O
'0'	O
;	O
}	O
else	O
if	O
(	O
val	int
<=	O
15	int
)	O
{	O
mark	char
=	O
val	int
-	O
10	int
+	O
'a'	O
;	O
}	O
else	O
{	O
mark	char
=	O
'+'	O
;	O
}	O
return	O
mark	char
;	O
}	O
int	O
free_nation_mark	function
(	O
Sworld	struct
*	O
wp	pointer
,	O
Symbol	char
c	char
)	O
{	O
int	O
i	int
;	O
if	O
(	O
!	O
isprint	function
(	O
c	char
)	O
)	O
{	O
return	O
0	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
wp	pointer
->	O
n_nations	int
;	O
++	O
i	int
)	O
{	O
if	O
(	O
wp	pointer
->	O
nations	pointer
[	O
i	int
]	O
.	O
mark	char
==	O
c	char
)	O
{	O
return	O
0	int
;	O
}	O
}	O
return	O
1	int
;	O
}	O
void	O
getline	function
(	O
char	O
s	array
[	O
]	O
,	O
int	O
n	int
)	O
{	O
fgets	function
(	O
s	array
,	O
n	int
,	O
stdin	pointer
)	O
;	O
if	O
(	O
s	array
[	O
strlen	function
(	O
s	array
)	O
-	O
1	int
]	O
==	O
'\n'	O
)	O
{	O
s	array
[	O
strlen	function
(	O
s	array
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
}	O
void	O
get_crypt_pass	function
(	O
char	O
prompt	array
[	O
]	O
,	O
char	O
pass	array
[	O
]	O
,	O
WINDOW	struct
*	O
w	pointer
,	O
char	O
def_pass	array
[	O
]	O
)	O
{	O
char	O
*	O
s1	array
,	O
s2	array
[	O
PASSLEN	int
]	O
,	O
*	O
getpass	function
(	O
)	O
,	O
*	O
crypt	function
(	O
)	O
;	O
if	O
(	O
def_pass	array
!=	O
NULL	O
&&	O
strlen	function
(	O
def_pass	array
)	O
>	O
0	int
)	O
{	O
strcpy	function
(	O
s2	array
,	O
def_pass	array
)	O
;	O
s1	array
=	O
crypt	function
(	O
s2	array
,	O
SALT	pointer
)	O
;	O
strcpy	function
(	O
pass	array
,	O
s1	array
+	O
2	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
w	pointer
==	O
NULL	O
)	O
{	O
s1	array
=	O
getpass	function
(	O
prompt	array
)	O
;	O
strcpy	function
(	O
s2	array
,	O
s1	array
)	O
;	O
s1	array
=	O
crypt	function
(	O
s2	array
,	O
SALT	pointer
)	O
;	O
strcpy	function
(	O
pass	array
,	O
s1	array
+	O
2	int
)	O
;	O
}	O
else	O
{	O
wprintw	function
(	O
w	pointer
,	O
"%s"	pointer
,	O
prompt	array
)	O
;	O
wrefresh	function
(	O
w	pointer
)	O
;	O
wscanw	function
(	O
w	pointer
,	O
"%s"	pointer
,	O
s2	array
)	O
;	O
s1	array
=	O
crypt	function
(	O
s2	array
,	O
SALT	pointer
)	O
;	O
strcpy	function
(	O
pass	array
,	O
s1	array
+	O
2	int
)	O
;	O
}	O
}	O
void	O
cpass	function
(	O
Snation	struct
*	O
np	pointer
,	O
char	O
pass	array
[	O
]	O
)	O
{	O
char	O
s	array
[	O
EXECLEN	int
]	O
;	O
sprintf	function
(	O
s	array
,	O
"CPASS:%d:%s\n"	pointer
,	O
np	pointer
->	O
id	short
,	O
pass	array
)	O
;	O
gen_exec	function
(	O
s	array
)	O
;	O
}	O
int	O
which_mark	function
(	O
int	O
x	int
,	O
int	O
y	int
,	O
Suser	struct
*	O
up	pointer
)	O
{	O
int	O
highlight	int
=	O
1	int
;	O
int	O
owner	int
=	O
world	struct
.	O
map	pointer
[	O
x	int
]	O
[	O
y	int
]	O
.	O
owner	int
,	O
mark	char
=	O
'\0'	O
;	O
Ssector	struct
*	O
sectp	pointer
=	O
&	O
world	struct
.	O
map	pointer
[	O
x	int
]	O
[	O
y	int
]	O
;	O
int	O
visibility	int
=	O
user	struct
.	O
visible_sectors	pointer
[	O
x	int
]	O
[	O
y	int
]	O
;	O
int	O
cost	int
;	O
Sarmy	struct
*	O
ap	pointer
,	O
*	O
get_army	function
(	O
)	O
;	O
struct	O
armyid	struct
*	O
alist	pointer
;	O
if	O
(	O
!	O
user	struct
.	O
underwater	int
&&	O
sectp	pointer
->	O
altitude	short
<	O
SEA_LEVEL	int
)	O
{	O
mark	char
=	O
'~'	O
;	O
}	O
if	O
(	O
user	struct
.	O
underwater	int
&&	O
sectp	pointer
->	O
altitude	short
>=	O
SEA_LEVEL	int
)	O
{	O
mark	char
=	O
'.'	O
;	O
}	O
if	O
(	O
!	O
mark	char
)	O
{	O
switch	O
(	O
up	pointer
->	O
display	int
)	O
{	O
case	O
DESIGNATION	int
:	O
if	O
(	O
owner	int
==	O
up	pointer
->	O
id	short
)	O
{	O
mark	char
=	O
desig_map	array
[	O
sectp	pointer
->	O
designation	short
]	O
.	O
mark	char
;	O
}	O
else	O
{	O
if	O
(	O
world	struct
.	O
nations	pointer
[	O
owner	int
]	O
.	O
mark	char
==	O
'-'	O
)	O
{	O
mark	char
=	O
altitude_map	array
[	O
map_alt	function
(	O
sectp	pointer
->	O
altitude	short
)	O
]	O
.	O
mark	char
;	O
}	O
else	O
{	O
mark	char
=	O
world	struct
.	O
nations	pointer
[	O
owner	int
]	O
.	O
mark	char
;	O
}	O
}	O
break	O
;	O
case	O
NATION_MARK	int
:	O
mark	char
=	O
world	struct
.	O
nations	pointer
[	O
owner	int
]	O
.	O
mark	char
;	O
break	O
;	O
case	O
SOIL	int
:	O
if	O
(	O
visibility	int
&	O
SEE_RESOURCES	int
)	O
{	O
mark	char
=	O
hex_mark	function
(	O
sectp	pointer
->	O
soil	short
)	O
;	O
}	O
else	O
{	O
mark	char
=	O
'?'	O
;	O
}	O
break	O
;	O
case	O
METAL	int
:	O
if	O
(	O
visibility	int
&	O
SEE_RESOURCES	int
)	O
{	O
mark	char
=	O
hex_mark	function
(	O
sectp	pointer
->	O
metal	int
)	O
;	O
}	O
else	O
{	O
mark	char
=	O
'?'	O
;	O
}	O
break	O
;	O
case	O
JEWELS	int
:	O
if	O
(	O
visibility	int
&	O
SEE_RESOURCES	int
)	O
{	O
mark	char
=	O
hex_mark	function
(	O
sectp	pointer
->	O
jewels	int
)	O
;	O
}	O
else	O
{	O
mark	char
=	O
'?'	O
;	O
}	O
break	O
;	O
case	O
ALTITUDE	int
:	O
if	O
(	O
visibility	int
&	O
SEE_LAND_WATER	int
)	O
{	O
if	O
(	O
sectp	pointer
->	O
altitude	short
>	O
9	int
)	O
{	O
mark	char
=	O
'+'	O
;	O
}	O
else	O
if	O
(	O
sectp	pointer
->	O
altitude	short
>=	O
0	int
)	O
{	O
mark	char
=	O
sectp	pointer
->	O
altitude	short
+	O
'0'	O
;	O
}	O
else	O
{	O
mark	char
=	O
(	O
-	O
1	int
*	O
sectp	pointer
->	O
altitude	short
)	O
+	O
'0'	O
;	O
}	O
}	O
else	O
{	O
mark	char
=	O
'?'	O
;	O
}	O
break	O
;	O
case	O
CLIMATE	int
:	O
if	O
(	O
visibility	int
&	O
SEE_LAND_WATER	int
)	O
{	O
mark	char
=	O
climates	array
[	O
sectp	pointer
->	O
climate	short
]	O
.	O
mark	char
;	O
}	O
else	O
{	O
mark	char
=	O
'?'	O
;	O
}	O
break	O
;	O
case	O
POPULATION	int
:	O
if	O
(	O
visibility	int
&	O
SEE_POPULATION	int
)	O
{	O
if	O
(	O
sectp	pointer
->	O
n_people	int
<	O
0	int
)	O
{	O
mark	char
=	O
'-'	O
;	O
}	O
else	O
if	O
(	O
sectp	pointer
->	O
n_people	int
<	O
950	int
)	O
{	O
mark	char
=	O
(	O
sectp	pointer
->	O
n_people	int
<	O
950	int
)	O
?	O
(	O
sectp	pointer
->	O
n_people	int
+	O
50	int
)	O
/	O
100	int
+	O
'0'	O
:	O
'+'	O
;	O
}	O
else	O
if	O
(	O
sectp	pointer
->	O
n_people	int
<	O
4501	int
)	O
{	O
mark	char
=	O
'I'	O
;	O
}	O
else	O
if	O
(	O
sectp	pointer
->	O
n_people	int
<	O
9501	int
)	O
{	O
mark	char
=	O
'V'	O
;	O
}	O
else	O
{	O
mark	char
=	O
'X'	O
;	O
}	O
}	O
else	O
{	O
mark	char
=	O
'?'	O
;	O
}	O
break	O
;	O
case	O
ARMY_MOVECOST	int
:	O
if	O
(	O
visibility	int
&	O
SEE_LAND_WATER	int
)	O
{	O
if	O
(	O
(	O
ap	pointer
=	O
get_army	function
(	O
&	O
world	struct
.	O
nations	pointer
[	O
up	pointer
->	O
id	short
]	O
,	O
user	struct
.	O
current_army	int
)	O
)	O
==	O
NULL	O
)	O
{	O
cost	int
=	O
get_generic_move_cost	function
(	O
&	O
world	struct
.	O
nations	pointer
[	O
up	pointer
->	O
id	short
]	O
,	O
sectp	pointer
)	O
;	O
}	O
else	O
{	O
cost	int
=	O
get_army_move_cost	function
(	O
&	O
world	struct
.	O
nations	pointer
[	O
up	pointer
->	O
id	short
]	O
,	O
sectp	pointer
,	O
ap	pointer
)	O
;	O
}	O
if	O
(	O
cost	int
==	O
TOO_MUCH_MOVE_COST	int
)	O
{	O
mark	char
=	O
'X'	O
;	O
}	O
else	O
if	O
(	O
cost	int
==	O
STOP_MOVE_COST	int
)	O
{	O
mark	char
=	O
'S'	O
;	O
}	O
else	O
{	O
mark	char
=	O
hex_mark	function
(	O
cost	int
)	O
;	O
}	O
}	O
else	O
{	O
mark	char
=	O
'?'	O
;	O
}	O
break	O
;	O
case	O
MOVECOST	int
:	O
if	O
(	O
visibility	int
&	O
SEE_LAND_WATER	int
)	O
{	O
cost	int
=	O
get_generic_move_cost	function
(	O
&	O
world	struct
.	O
nations	pointer
[	O
up	pointer
->	O
id	short
]	O
,	O
sectp	pointer
)	O
;	O
if	O
(	O
cost	int
==	O
TOO_MUCH_MOVE_COST	int
)	O
{	O
mark	char
=	O
'X'	O
;	O
}	O
else	O
if	O
(	O
cost	int
==	O
STOP_MOVE_COST	int
)	O
{	O
mark	char
=	O
'S'	O
;	O
}	O
else	O
{	O
mark	char
=	O
hex_mark	function
(	O
cost	int
)	O
;	O
}	O
}	O
else	O
{	O
mark	char
=	O
'?'	O
;	O
}	O
break	O
;	O
case	O
TERRAIN	int
:	O
if	O
(	O
visibility	int
&	O
SEE_LAND_WATER	int
)	O
{	O
mark	char
=	O
terrains	array
[	O
sectp	pointer
->	O
terrain	short
-	O
MIN_TERRAIN	O
]	O
.	O
mark	char
;	O
}	O
else	O
{	O
mark	char
=	O
'?'	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
switch	O
(	O
up	pointer
->	O
highlight	int
)	O
{	O
case	O
H_OWNED	int
:	O
if	O
(	O
sectp	pointer
->	O
owner	int
==	O
up	pointer
->	O
id	short
)	O
{	O
highlight	int
=	O
-	O
1	int
;	O
}	O
break	O
;	O
case	O
H_ARMIES	int
:	O
if	O
(	O
(	O
user	struct
.	O
visible_sectors	pointer
[	O
sectp	pointer
->	O
loc	struct
.	O
x	int
]	O
[	O
sectp	pointer
->	O
loc	struct
.	O
y	int
]	O
&	O
SEE_ARMIES	int
)	O
&&	O
has_visible_army	function
(	O
sectp	pointer
,	O
&	O
user	struct
)	O
)	O
{	O
highlight	int
=	O
-	O
1	int
;	O
}	O
break	O
;	O
case	O
H_HOSTILE	int
:	O
if	O
(	O
has_hostile	O
(	O
sectp	pointer
)	O
)	O
{	O
highlight	int
=	O
-	O
1	int
;	O
}	O
break	O
;	O
case	O
H_PATROL	int
:	O
case	O
H_INTERCEPT	int
:	O
case	O
H_P_OR_I	int
:	O
if	O
(	O
sect_is_patrolled	function
(	O
sectp	pointer
,	O
up	pointer
->	O
highlight	int
)	O
&&	O
(	O
user	struct
.	O
id	short
==	O
sectp	pointer
->	O
owner	int
)	O
)	O
{	O
highlight	int
=	O
-	O
1	int
;	O
}	O
break	O
;	O
case	O
H_YOUR_ARMIES	int
:	O
if	O
(	O
sectp	pointer
->	O
alist	pointer
!=	O
NULL	O
&&	O
(	O
user	struct
.	O
visible_sectors	pointer
[	O
sectp	pointer
->	O
loc	struct
.	O
x	int
]	O
[	O
sectp	pointer
->	O
loc	struct
.	O
y	int
]	O
&	O
SEE_ARMIES	int
)	O
)	O
{	O
alist	pointer
=	O
sectp	pointer
->	O
alist	pointer
;	O
while	O
(	O
alist	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
alist	pointer
->	O
owner	int
==	O
user	struct
.	O
id	short
)	O
{	O
highlight	int
=	O
-	O
1	int
;	O
break	O
;	O
}	O
alist	pointer
=	O
alist	pointer
->	O
next	pointer
;	O
}	O
}	O
break	O
;	O
case	O
H_OTHER_ARMIES	int
:	O
if	O
(	O
sectp	pointer
->	O
alist	pointer
!=	O
NULL	O
&&	O
(	O
user	struct
.	O
visible_sectors	pointer
[	O
sectp	pointer
->	O
loc	struct
.	O
x	int
]	O
[	O
sectp	pointer
->	O
loc	struct
.	O
y	int
]	O
&	O
SEE_ARMIES	int
)	O
)	O
{	O
alist	pointer
=	O
sectp	pointer
->	O
alist	pointer
;	O
ap	pointer
=	O
get_army	function
(	O
&	O
world	struct
.	O
nations	pointer
[	O
alist	pointer
->	O
owner	int
]	O
,	O
alist	pointer
->	O
id	short
)	O
;	O
while	O
(	O
alist	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
alist	pointer
->	O
owner	int
!=	O
user	struct
.	O
id	short
&&	O
!	O
is_hidden	O
(	O
ap	pointer
)	O
)	O
{	O
highlight	int
=	O
-	O
1	int
;	O
break	O
;	O
}	O
alist	pointer
=	O
alist	pointer
->	O
next	pointer
;	O
}	O
}	O
break	O
;	O
case	O
H_MOVE_LEFT	int
:	O
if	O
(	O
sectp	pointer
->	O
alist	pointer
!=	O
NULL	O
&&	O
(	O
user	struct
.	O
visible_sectors	pointer
[	O
sectp	pointer
->	O
loc	struct
.	O
x	int
]	O
[	O
sectp	pointer
->	O
loc	struct
.	O
y	int
]	O
&	O
SEE_ARMIES	int
)	O
)	O
{	O
highlight	int
=	O
1	int
;	O
alist	pointer
=	O
sectp	pointer
->	O
alist	pointer
;	O
while	O
(	O
alist	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
alist	pointer
->	O
owner	int
==	O
user	struct
.	O
id	short
)	O
{	O
ap	pointer
=	O
get_army	function
(	O
&	O
world	struct
.	O
nations	pointer
[	O
alist	pointer
->	O
owner	int
]	O
,	O
alist	pointer
->	O
id	short
)	O
;	O
if	O
(	O
ap	pointer
->	O
mvpts	int
>	O
0	int
)	O
{	O
highlight	int
=	O
-	O
1	int
;	O
}	O
}	O
alist	pointer
=	O
alist	pointer
->	O
next	pointer
;	O
}	O
}	O
else	O
{	O
highlight	int
=	O
1	int
;	O
}	O
break	O
;	O
case	O
H_UNEMP	int
:	O
if	O
(	O
(	O
sectp	pointer
->	O
n_people	int
>	O
n_workers	function
(	O
sectp	pointer
)	O
)	O
&&	O
(	O
sectp	pointer
->	O
owner	int
==	O
up	pointer
->	O
id	short
)	O
)	O
{	O
highlight	int
=	O
-	O
1	int
;	O
}	O
break	O
;	O
case	O
H_NONE	int
:	O
highlight	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
return	O
highlight	int
*	O
mark	char
;	O
}	O
void	O
addsector	function
(	O
Snation	struct
*	O
np	pointer
,	O
int	O
x	int
,	O
int	O
y	int
)	O
{	O
struct	O
pt_list	struct
*	O
sect	pointer
;	O
sect	pointer
=	O
(	O
struct	O
pt_list	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
struct	O
pt_list	struct
)	O
)	O
;	O
sect	pointer
->	O
pt	struct
.	O
x	int
=	O
x	int
;	O
sect	pointer
->	O
pt	struct
.	O
y	int
=	O
y	int
;	O
sect	pointer
->	O
next	pointer
=	O
np	pointer
->	O
ptlist	pointer
;	O
np	pointer
->	O
ptlist	pointer
=	O
sect	pointer
;	O
np	pointer
->	O
n_sects	int
++	O
;	O
world	struct
.	O
map	pointer
[	O
x	int
]	O
[	O
y	int
]	O
.	O
owner	int
=	O
np	pointer
->	O
id	short
;	O
}	O
int	O
subtsector	function
(	O
Snation	struct
*	O
np	pointer
,	O
int	O
x	int
,	O
int	O
y	int
)	O
{	O
struct	O
pt_list	struct
*	O
sect	pointer
,	O
*	O
temp	pointer
;	O
int	O
rtvl	int
=	O
0	int
;	O
sect	pointer
=	O
np	pointer
->	O
ptlist	pointer
;	O
if	O
(	O
sect	pointer
->	O
pt	struct
.	O
x	int
==	O
x	int
&&	O
sect	pointer
->	O
pt	struct
.	O
y	int
==	O
y	int
)	O
{	O
temp	pointer
=	O
sect	pointer
;	O
np	pointer
->	O
ptlist	pointer
=	O
sect	pointer
->	O
next	pointer
;	O
(	O
np	pointer
->	O
n_sects	int
)	O
--	O
;	O
free	function
(	O
temp	pointer
)	O
;	O
}	O
else	O
{	O
temp	pointer
=	O
sect	pointer
;	O
while	O
(	O
(	O
sect	pointer
->	O
pt	struct
.	O
x	int
!=	O
x	int
||	O
sect	pointer
->	O
pt	struct
.	O
y	int
!=	O
y	int
)	O
&&	O
sect	pointer
->	O
next	pointer
!=	O
NULL	O
)	O
{	O
temp	pointer
=	O
sect	pointer
;	O
sect	pointer
=	O
sect	pointer
->	O
next	pointer
;	O
}	O
if	O
(	O
sect	pointer
->	O
pt	struct
.	O
x	int
==	O
x	int
&&	O
sect	pointer
->	O
pt	struct
.	O
y	int
==	O
y	int
)	O
{	O
temp	pointer
->	O
next	pointer
=	O
sect	pointer
->	O
next	pointer
;	O
free	function
(	O
sect	pointer
)	O
;	O
(	O
np	pointer
->	O
n_sects	int
)	O
--	O
;	O
}	O
else	O
{	O
printf	function
(	O
"Error - deleting sector not in list!\n"	pointer
)	O
;	O
rtvl	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
np	pointer
->	O
n_sects	int
==	O
0	int
)	O
{	O
np	pointer
->	O
ptlist	pointer
=	O
NULL	O
;	O
}	O
return	O
rtvl	int
;	O
}	O
void	O
destroy_nation	function
(	O
int	O
id	short
)	O
{	O
struct	O
pt_list	struct
*	O
ptlist	pointer
,	O
*	O
pt_tmp	pointer
;	O
Sarmy	struct
*	O
army_list	pointer
,	O
*	O
ap_tmp	pointer
;	O
Snation	struct
*	O
np	pointer
=	O
&	O
world	struct
.	O
nations	pointer
[	O
id	short
]	O
;	O
Ssector	struct
*	O
sp	int
;	O
if	O
(	O
np	pointer
->	O
id	short
==	O
0	int
)	O
{	O
return	O
;	O
}	O
ptlist	pointer
=	O
np	pointer
->	O
ptlist	pointer
;	O
while	O
(	O
ptlist	pointer
)	O
{	O
world	struct
.	O
map	pointer
[	O
ptlist	pointer
->	O
pt	struct
.	O
x	int
]	O
[	O
ptlist	pointer
->	O
pt	struct
.	O
y	int
]	O
.	O
owner	int
=	O
0	int
;	O
world	struct
.	O
map	pointer
[	O
ptlist	pointer
->	O
pt	struct
.	O
x	int
]	O
[	O
ptlist	pointer
->	O
pt	struct
.	O
y	int
]	O
.	O
designation	short
=	O
D_NODESIG	int
;	O
world	struct
.	O
map	pointer
[	O
ptlist	pointer
->	O
pt	struct
.	O
x	int
]	O
[	O
ptlist	pointer
->	O
pt	struct
.	O
y	int
]	O
.	O
n_people	int
=	O
0	int
;	O
pt_tmp	pointer
=	O
ptlist	pointer
->	O
next	pointer
;	O
free	function
(	O
ptlist	pointer
)	O
;	O
--	O
np	pointer
->	O
n_sects	int
;	O
ptlist	pointer
=	O
pt_tmp	pointer
;	O
}	O
np	pointer
->	O
ptlist	pointer
=	O
NULL	O
;	O
army_list	pointer
=	O
np	pointer
->	O
armies	pointer
;	O
while	O
(	O
army_list	pointer
)	O
{	O
ap_tmp	pointer
=	O
army_list	pointer
->	O
next	pointer
;	O
sp	int
=	O
&	O
world	struct
.	O
map	pointer
[	O
army_list	pointer
->	O
pos	struct
.	O
x	int
]	O
[	O
army_list	pointer
->	O
pos	struct
.	O
y	int
]	O
;	O
delete_army_sector	function
(	O
sp	int
,	O
army_list	pointer
)	O
;	O
delete_army_nation	function
(	O
np	pointer
,	O
army_list	pointer
)	O
;	O
army_list	pointer
=	O
np	pointer
->	O
armies	pointer
;	O
}	O
np	pointer
->	O
armies	pointer
=	O
NULL	O
;	O
np	pointer
->	O
capital	struct
.	O
x	int
=	O
-	O
1	int
;	O
np	pointer
->	O
capital	struct
.	O
y	int
=	O
-	O
1	int
;	O
}	O
int	O
get_n_cities	function
(	O
Snation	struct
*	O
np	pointer
)	O
{	O
Ssector	struct
*	O
sp	int
;	O
struct	O
pt_list	struct
*	O
ptlist	pointer
=	O
np	pointer
->	O
ptlist	pointer
;	O
int	O
n_cities	int
=	O
0	int
;	O
while	O
(	O
ptlist	pointer
!=	O
NULL	O
)	O
{	O
sp	int
=	O
&	O
world	struct
.	O
map	pointer
[	O
ptlist	pointer
->	O
pt	struct
.	O
x	int
]	O
[	O
ptlist	pointer
->	O
pt	struct
.	O
y	int
]	O
;	O
if	O
(	O
sp	int
->	O
designation	short
==	O
D_CITY	int
||	O
sp	int
->	O
designation	short
==	O
D_CAPITAL	int
)	O
{	O
++	O
n_cities	int
;	O
}	O
ptlist	pointer
=	O
ptlist	pointer
->	O
next	pointer
;	O
}	O
return	O
n_cities	int
;	O
}	O
int	O
get_n_civil	function
(	O
Snation	struct
*	O
np	pointer
)	O
{	O
Ssector	struct
*	O
sp	int
;	O
struct	O
pt_list	struct
*	O
ptlist	pointer
=	O
np	pointer
->	O
ptlist	pointer
;	O
int	O
n_civil	int
=	O
0	int
;	O
while	O
(	O
ptlist	pointer
!=	O
NULL	O
)	O
{	O
sp	int
=	O
&	O
world	struct
.	O
map	pointer
[	O
ptlist	pointer
->	O
pt	struct
.	O
x	int
]	O
[	O
ptlist	pointer
->	O
pt	struct
.	O
y	int
]	O
;	O
n_civil	int
+=	O
sp	int
->	O
n_people	int
;	O
ptlist	pointer
=	O
ptlist	pointer
->	O
next	pointer
;	O
}	O
return	O
n_civil	int
;	O
}	O
int	O
get_n_soldiers	function
(	O
Snation	struct
*	O
np	pointer
)	O
{	O
Sarmy	struct
*	O
armies	pointer
=	O
np	pointer
->	O
armies	pointer
;	O
int	O
n_sold	int
=	O
0	int
;	O
while	O
(	O
armies	pointer
!=	O
NULL	O
)	O
{	O
n_sold	int
+=	O
armies	pointer
->	O
n_soldiers	int
;	O
armies	pointer
=	O
armies	pointer
->	O
next	pointer
;	O
}	O
return	O
n_sold	int
;	O
}	O
int	O
unique_name	function
(	O
char	O
name	array
[	O
]	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
world	struct
.	O
n_nations	int
;	O
++	O
i	int
)	O
{	O
if	O
(	O
strcmp	function
(	O
world	struct
.	O
nations	pointer
[	O
i	int
]	O
.	O
name	array
,	O
name	array
)	O
==	O
0	int
)	O
{	O
return	O
0	int
;	O
}	O
}	O
return	O
1	int
;	O
}	O
void	O
null_key	function
(	O
)	O
{	O
}	O
int	O
free_army_id	function
(	O
Snation	struct
*	O
np	pointer
)	O
{	O
Sarmy	struct
*	O
ap	pointer
=	O
np	pointer
->	O
armies	pointer
,	O
*	O
ap_prev	pointer
=	O
np	pointer
->	O
armies	pointer
;	O
int	O
id	short
;	O
if	O
(	O
ap	pointer
==	O
NULL	O
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
ap	pointer
->	O
id	short
>	O
0	int
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
ap	pointer
->	O
next	pointer
==	O
NULL	O
)	O
{	O
return	O
1	int
;	O
}	O
while	O
(	O
ap	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
ap	pointer
->	O
id	short
>	O
ap_prev	pointer
->	O
id	short
+	O
1	int
)	O
{	O
id	short
=	O
ap_prev	pointer
->	O
id	short
+	O
1	int
;	O
return	O
id	short
;	O
}	O
ap_prev	pointer
=	O
ap	pointer
;	O
ap	pointer
=	O
ap	pointer
->	O
next	pointer
;	O
}	O
id	short
=	O
ap_prev	pointer
->	O
id	short
+	O
1	int
;	O
return	O
id	short
;	O
}	O
int	O
dom_min_int	function
(	O
a	int
,	O
b	int
)	O
int	O
a	int
,	O
b	int
;	O
{	O
return	O
(	O
a	int
<	O
b	int
)	O
?	O
a	int
:	O
b	int
;	O
}	O
int	O
dom_max_int	function
(	O
a	int
,	O
b	int
)	O
int	O
a	int
,	O
b	int
;	O
{	O
return	O
(	O
a	int
>	O
b	int
)	O
?	O
a	int
:	O
b	int
;	O
}	O
void	O
statline	function
(	O
char	O
s1	array
[	O
]	O
,	O
char	O
s2	array
[	O
]	O
)	O
{	O
mvaddstr	function
(	O
LINES	int
-	O
1	int
,	O
0	int
,	O
s1	array
)	O
;	O
clrtoeol	function
(	O
)	O
;	O
standout	function
(	O
)	O
;	O
mvaddstr	function
(	O
LINES	int
-	O
1	int
,	O
COLS	int
-	O
strlen	function
(	O
s2	array
)	O
-	O
2	int
,	O
s2	array
)	O
;	O
standend	function
(	O
)	O
;	O
refresh	function
(	O
)	O
;	O
}	O
void	O
statline2	function
(	O
char	O
s1	array
[	O
]	O
,	O
char	O
s2	array
[	O
]	O
)	O
{	O
mvprintw	function
(	O
LINES	int
-	O
2	int
,	O
0	int
,	O
"%s"	pointer
,	O
s1	array
)	O
;	O
clrtoeol	function
(	O
)	O
;	O
standout	function
(	O
)	O
;	O
mvprintw	function
(	O
LINES	int
-	O
2	int
,	O
COLS	int
-	O
strlen	function
(	O
s2	array
)	O
-	O
2	int
,	O
"%s"	pointer
,	O
s2	array
)	O
;	O
standend	function
(	O
)	O
;	O
refresh	function
(	O
)	O
;	O
}	O
void	O
statline_prompt	function
(	O
char	O
s1	array
[	O
]	O
,	O
char	O
s2	array
[	O
]	O
)	O
{	O
statline	function
(	O
s1	array
,	O
s2	array
)	O
;	O
move	function
(	O
LINES	int
-	O
1	int
,	O
strlen	function
(	O
s1	array
)	O
)	O
;	O
refresh	function
(	O
)	O
;	O
}	O
void	O
statline2_prompt	function
(	O
char	O
s1	array
[	O
]	O
,	O
char	O
s2	array
[	O
]	O
)	O
{	O
statline2	function
(	O
s1	array
,	O
s2	array
)	O
;	O
move	function
(	O
LINES	int
-	O
2	int
,	O
strlen	function
(	O
s1	array
)	O
)	O
;	O
refresh	function
(	O
)	O
;	O
}	O
void	O
init_screen	function
(	O
)	O
{	O
printf	function
(	O
"initializing screen...\r\n"	pointer
)	O
;	O
initscr	function
(	O
)	O
;	O
savetty	function
(	O
)	O
;	O
cbreak	function
(	O
)	O
;	O
noecho	function
(	O
)	O
;	O
clear	function
(	O
)	O
;	O
sectw	pointer
=	O
newwin	function
(	O
SECTW_SIZE_Y	int
,	O
SECTW_SIZE_X	int
,	O
SECTW_Y	O
,	O
SECTW_X	O
)	O
;	O
if	O
(	O
user	struct
.	O
map_style	int
==	O
NORMAL_MAP	int
)	O
{	O
move	function
(	O
user	struct
.	O
cursor	struct
.	O
y	int
,	O
user	struct
.	O
cursor	struct
.	O
x	int
)	O
;	O
}	O
else	O
{	O
move	function
(	O
2	int
*	O
user	struct
.	O
cursor	struct
.	O
y	int
,	O
user	struct
.	O
cursor	struct
.	O
x	int
)	O
;	O
}	O
}	O
struct	O
spirit_type	struct
*	O
get_spirit_type	function
(	O
up	pointer
,	O
type	array
)	O
Suser	struct
*	O
up	pointer
;	O
char	O
type	array
[	O
]	O
;	O
{	O
int	O
i	int
;	O
extern	O
struct	O
spirit_type	struct
*	O
spirit_types	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
up	pointer
->	O
n_spirit_types	int
;	O
++	O
i	int
)	O
{	O
if	O
(	O
strcmp	function
(	O
type	array
,	O
spirit_types	pointer
[	O
i	int
]	O
.	O
type	array
)	O
==	O
0	int
)	O
{	O
return	O
&	O
(	O
spirit_types	pointer
[	O
i	int
]	O
)	O
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
void	O
gen_exec	function
(	O
char	O
*	O
s	array
)	O
{	O
FILE	struct
*	O
fp	pointer
,	O
*	O
fopen	function
(	O
)	O
;	O
char	O
exec_file	array
[	O
NAMELEN	int
]	O
;	O
int	O
i	int
;	O
sprintf	function
(	O
exec_file	array
,	O
"exec/exec%d"	pointer
,	O
user	struct
.	O
id	short
)	O
;	O
if	O
(	O
(	O
s	array
!=	O
NULL	O
)	O
&&	O
(	O
strlen	function
(	O
s	array
)	O
==	O
0	int
)	O
)	O
{	O
return	O
;	O
}	O
if	O
(	O
s	array
!=	O
NULL	O
)	O
{	O
strcpy	function
(	O
user	struct
.	O
exec_lines	array
[	O
user	struct
.	O
n_execs	int
]	O
,	O
s	array
)	O
;	O
++	O
user	struct
.	O
n_execs	int
;	O
}	O
if	O
(	O
(	O
user	struct
.	O
n_execs	int
>=	O
N_EXECS	int
)	O
||	O
(	O
s	array
==	O
NULL	O
)	O
)	O
{	O
if	O
(	O
(	O
fp	pointer
=	O
fopen	function
(	O
exec_file	array
,	O
"a"	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
printf	function
(	O
"cannot open your exec file, this is serious\n"	pointer
)	O
;	O
clean_exit	function
(	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
critical	function
(	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
user	struct
.	O
n_execs	int
;	O
++	O
i	int
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"%s"	pointer
,	O
user	struct
.	O
exec_lines	array
[	O
i	int
]	O
)	O
;	O
}	O
fclose	function
(	O
fp	pointer
)	O
;	O
noncritical	function
(	O
)	O
;	O
user	struct
.	O
n_execs	int
=	O
0	int
;	O
}	O
}	O
int	O
is_good_order	function
(	O
char	O
name	array
[	O
]	O
)	O
{	O
int	O
good	int
=	O
0	int
;	O
FILE	struct
*	O
fp	pointer
,	O
*	O
fopen	function
(	O
)	O
;	O
char	O
line	array
[	O
200	int
]	O
;	O
int	O
i	int
,	O
n_orders	int
;	O
if	O
(	O
(	O
fp	pointer
=	O
fopen	function
(	O
MAG_ORDERS	pointer
,	O
"r"	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
printf	function
(	O
"cannot find file %s.  this is bad.\n"	pointer
,	O
MAG_ORDERS	pointer
)	O
;	O
clean_exit	function
(	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
while	O
(	O
fgets	function
(	O
line	array
,	O
200	int
,	O
fp	pointer
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
line	array
[	O
0	int
]	O
!=	O
'#'	O
)	O
{	O
sscanf	function
(	O
line	array
,	O
"%d"	pointer
,	O
&	O
n_orders	int
)	O
;	O
break	O
;	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_orders	int
;	O
)	O
{	O
fgets	function
(	O
line	array
,	O
NAMELEN	int
,	O
fp	pointer
)	O
;	O
if	O
(	O
line	array
[	O
strlen	function
(	O
line	array
)	O
-	O
1	int
]	O
==	O
'\n'	O
)	O
{	O
line	array
[	O
strlen	function
(	O
line	array
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
line	array
[	O
0	int
]	O
!=	O
'#'	O
)	O
{	O
if	O
(	O
strncmp	function
(	O
line	array
,	O
name	array
,	O
NAMELEN	int
)	O
==	O
0	int
)	O
{	O
good	int
=	O
1	int
;	O
}	O
++	O
i	int
;	O
}	O
}	O
return	O
good	int
;	O
}	O
int	O
has_visible_army	function
(	O
Ssector	struct
*	O
sp	int
,	O
Suser	struct
*	O
up	pointer
)	O
{	O
struct	O
armyid	struct
*	O
alist	pointer
=	O
sp	int
->	O
alist	pointer
;	O
Sarmy	struct
*	O
ap	pointer
,	O
*	O
get_army	function
(	O
)	O
;	O
int	O
found	int
=	O
0	int
;	O
while	O
(	O
alist	pointer
)	O
{	O
ap	pointer
=	O
get_army	function
(	O
&	O
world	struct
.	O
nations	pointer
[	O
alist	pointer
->	O
owner	int
]	O
,	O
alist	pointer
->	O
id	short
)	O
;	O
if	O
(	O
!	O
is_hidden	O
(	O
ap	pointer
)	O
)	O
{	O
found	int
=	O
1	int
;	O
break	O
;	O
}	O
alist	pointer
=	O
alist	pointer
->	O
next	pointer
;	O
}	O
return	O
found	int
;	O
}	O
void	O
find_visible_sectors	function
(	O
int	O
*	O
*	O
visible_sectors	pointer
)	O
{	O
int	O
x	int
,	O
y	int
,	O
i	int
,	O
j	int
;	O
struct	O
pt_list	struct
*	O
plist	pointer
;	O
Sarmy	struct
*	O
ap	pointer
;	O
Ssector	struct
*	O
sp	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
world	struct
.	O
xmax	int
;	O
++	O
i	int
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
world	struct
.	O
ymax	int
;	O
++	O
j	int
)	O
{	O
visible_sectors	pointer
[	O
i	int
]	O
[	O
j	int
]	O
=	O
viewall	int
?	O
SEE_ALL	int
:	O
SEE_NOTHING	int
;	O
}	O
}	O
for	O
(	O
plist	pointer
=	O
user	struct
.	O
np	pointer
->	O
ptlist	pointer
;	O
plist	pointer
!=	O
NULL	O
;	O
plist	pointer
=	O
plist	pointer
->	O
next	pointer
)	O
{	O
x	int
=	O
plist	pointer
->	O
pt	struct
.	O
x	int
;	O
y	int
=	O
plist	pointer
->	O
pt	struct
.	O
y	int
;	O
visible_sectors	pointer
[	O
x	int
]	O
[	O
y	int
]	O
=	O
SEE_ALL	int
;	O
for	O
(	O
i	int
=	O
x	int
-	O
LAND_SIGHT	int
;	O
i	int
<=	O
x	int
+	O
LAND_SIGHT	int
;	O
++	O
i	int
)	O
{	O
for	O
(	O
j	int
=	O
y	int
-	O
LAND_SIGHT	int
;	O
j	int
<=	O
y	int
+	O
LAND_SIGHT	int
;	O
++	O
j	int
)	O
{	O
sp	int
=	O
&	O
world	struct
.	O
map	pointer
[	O
(	O
*	O
wrapx	pointer
)	O
(	O
i	int
,	O
j	int
)	O
]	O
[	O
(	O
*	O
wrapy	pointer
)	O
(	O
i	int
,	O
j	int
)	O
]	O
;	O
if	O
(	O
has_hidden	O
(	O
sp	int
)	O
&&	O
sp	int
->	O
owner	int
!=	O
user	struct
.	O
id	short
)	O
{	O
visible_sectors	pointer
[	O
x	int
]	O
[	O
y	int
]	O
|=	O
SEE_ARMIES	int
;	O
}	O
else	O
{	O
visible_sectors	pointer
[	O
(	O
*	O
wrapx	pointer
)	O
(	O
i	int
,	O
j	int
)	O
]	O
[	O
(	O
*	O
wrapy	pointer
)	O
(	O
i	int
,	O
j	int
)	O
]	O
|=	O
(	O
SEE_LAND_WATER	int
|	O
SEE_OWNER	int
|	O
SEE_DESIG	int
|	O
SEE_POPULATION	int
)	O
;	O
}	O
if	O
(	O
world	struct
.	O
map	pointer
[	O
(	O
*	O
wrapx	pointer
)	O
(	O
i	int
,	O
j	int
)	O
]	O
[	O
(	O
*	O
wrapy	pointer
)	O
(	O
i	int
,	O
j	int
)	O
]	O
.	O
owner	int
==	O
0	int
)	O
{	O
visible_sectors	pointer
[	O
(	O
*	O
wrapx	pointer
)	O
(	O
i	int
,	O
j	int
)	O
]	O
[	O
(	O
*	O
wrapy	pointer
)	O
(	O
i	int
,	O
j	int
)	O
]	O
|=	O
SEE_RESOURCES	int
;	O
}	O
}	O
}	O
}	O
for	O
(	O
ap	pointer
=	O
user	struct
.	O
np	pointer
->	O
armies	pointer
;	O
ap	pointer
!=	O
NULL	O
;	O
ap	pointer
=	O
ap	pointer
->	O
next	pointer
)	O
{	O
x	int
=	O
ap	pointer
->	O
pos	struct
.	O
x	int
;	O
y	int
=	O
ap	pointer
->	O
pos	struct
.	O
y	int
;	O
sp	int
=	O
&	O
world	struct
.	O
map	pointer
[	O
x	int
]	O
[	O
y	int
]	O
;	O
if	O
(	O
has_hidden	O
(	O
sp	int
)	O
&&	O
sp	int
->	O
owner	int
!=	O
user	struct
.	O
id	short
)	O
{	O
visible_sectors	pointer
[	O
x	int
]	O
[	O
y	int
]	O
=	O
SEE_ARMIES	int
;	O
}	O
else	O
{	O
visible_sectors	pointer
[	O
x	int
]	O
[	O
y	int
]	O
=	O
SEE_ALL	int
;	O
}	O
for	O
(	O
i	int
=	O
x	int
-	O
ARMY_SIGHT	int
;	O
i	int
<=	O
x	int
+	O
ARMY_SIGHT	int
;	O
++	O
i	int
)	O
{	O
for	O
(	O
j	int
=	O
y	int
-	O
ARMY_SIGHT	int
;	O
j	int
<=	O
y	int
+	O
ARMY_SIGHT	int
;	O
++	O
j	int
)	O
{	O
sp	int
=	O
&	O
world	struct
.	O
map	pointer
[	O
(	O
*	O
wrapx	pointer
)	O
(	O
i	int
,	O
j	int
)	O
]	O
[	O
(	O
*	O
wrapy	pointer
)	O
(	O
i	int
,	O
j	int
)	O
]	O
;	O
if	O
(	O
!	O
has_hidden	O
(	O
sp	int
)	O
)	O
{	O
visible_sectors	pointer
[	O
(	O
*	O
wrapx	pointer
)	O
(	O
i	int
,	O
j	int
)	O
]	O
[	O
(	O
*	O
wrapy	pointer
)	O
(	O
i	int
,	O
j	int
)	O
]	O
|=	O
(	O
SEE_LAND_WATER	int
|	O
SEE_OWNER	int
|	O
SEE_DESIG	int
|	O
SEE_POPULATION	int
|	O
SEE_ARMIES	int
)	O
;	O
}	O
if	O
(	O
world	struct
.	O
map	pointer
[	O
(	O
*	O
wrapx	pointer
)	O
(	O
i	int
,	O
j	int
)	O
]	O
[	O
(	O
*	O
wrapy	pointer
)	O
(	O
i	int
,	O
j	int
)	O
]	O
.	O
owner	int
==	O
0	int
)	O
{	O
visible_sectors	pointer
[	O
(	O
*	O
wrapx	pointer
)	O
(	O
i	int
,	O
j	int
)	O
]	O
[	O
(	O
*	O
wrapy	pointer
)	O
(	O
i	int
,	O
j	int
)	O
]	O
|=	O
SEE_RESOURCES	int
;	O
}	O
}	O
}	O
}	O
}	O
char	O
*	O
contents	function
(	O
int	O
money	int
,	O
int	O
metal	int
,	O
int	O
jewels	int
,	O
int	O
food	int
,	O
int	O
people	int
,	O
int	O
army	int
,	O
Pt	struct
*	O
title	struct
,	O
int	O
sp	int
)	O
{	O
char	O
*	O
rcontents	pointer
;	O
char	O
tmps	array
[	O
60	int
]	O
;	O
if	O
(	O
(	O
rcontents	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
char	O
)	O
*	O
100	int
)	O
)	O
==	O
NULL	O
)	O
{	O
clean_exit	function
(	O
)	O
;	O
exit	function
(	O
-	O
1	int
)	O
;	O
}	O
sprintf	function
(	O
rcontents	pointer
,	O
"%s"	pointer
,	O
""	pointer
)	O
;	O
if	O
(	O
money	int
>	O
0	int
)	O
{	O
sprintf	function
(	O
tmps	array
,	O
"/%d sk."	pointer
,	O
money	int
)	O
;	O
strcat	function
(	O
rcontents	pointer
,	O
tmps	array
)	O
;	O
}	O
if	O
(	O
metal	int
>	O
0	int
)	O
{	O
sprintf	function
(	O
tmps	array
,	O
"/%d met"	pointer
,	O
metal	int
)	O
;	O
strcat	function
(	O
rcontents	pointer
,	O
tmps	array
)	O
;	O
}	O
if	O
(	O
jewels	int
>	O
0	int
)	O
{	O
sprintf	function
(	O
tmps	array
,	O
"/%d jwl"	pointer
,	O
jewels	int
)	O
;	O
strcat	function
(	O
rcontents	pointer
,	O
tmps	array
)	O
;	O
}	O
if	O
(	O
food	int
>	O
0	int
)	O
{	O
sprintf	function
(	O
tmps	array
,	O
"/%d food"	pointer
,	O
food	int
)	O
;	O
strcat	function
(	O
rcontents	pointer
,	O
tmps	array
)	O
;	O
}	O
if	O
(	O
people	int
>	O
0	int
)	O
{	O
sprintf	function
(	O
tmps	array
,	O
"/%d peop"	pointer
,	O
people	int
)	O
;	O
strcat	function
(	O
rcontents	pointer
,	O
tmps	array
)	O
;	O
}	O
if	O
(	O
army	int
>=	O
0	int
)	O
{	O
sprintf	function
(	O
tmps	array
,	O
"/army %d"	pointer
,	O
army	int
)	O
;	O
strcat	function
(	O
rcontents	pointer
,	O
tmps	array
)	O
;	O
}	O
if	O
(	O
title	struct
&&	O
title	struct
->	O
x	int
!=	O
-	O
1	int
)	O
{	O
sprintf	function
(	O
tmps	array
,	O
"/sect %d,%d"	pointer
,	O
xrel	function
(	O
title	struct
->	O
x	int
,	O
title	struct
->	O
y	int
,	O
user	struct
.	O
np	pointer
->	O
capital	struct
)	O
,	O
yrel	function
(	O
title	struct
->	O
x	int
,	O
title	struct
->	O
y	int
,	O
user	struct
.	O
np	pointer
->	O
capital	struct
)	O
)	O
;	O
strcat	function
(	O
rcontents	pointer
,	O
tmps	array
)	O
;	O
}	O
if	O
(	O
sp	int
>	O
0	int
)	O
{	O
sprintf	function
(	O
tmps	array
,	O
"/%d sp"	pointer
,	O
sp	int
)	O
;	O
strcat	function
(	O
rcontents	pointer
,	O
tmps	array
)	O
;	O
}	O
if	O
(	O
rcontents	pointer
[	O
0	int
]	O
==	O
'/'	O
)	O
{	O
strcpy	function
(	O
rcontents	pointer
,	O
rcontents	pointer
+	O
1	int
)	O
;	O
}	O
return	O
rcontents	pointer
;	O
}	O
int	O
univ_intel	function
(	O
Snation	struct
*	O
np	pointer
)	O
{	O
double	O
sqrt	function
(	O
)	O
;	O
int	O
ret	int
;	O
if	O
(	O
get_n_civil	function
(	O
np	pointer
)	O
)	O
{	O
ret	int
=	O
(	O
int	O
)	O
(	O
100	int
*	O
get_n_students	function
(	O
np	pointer
)	O
/	O
get_n_civil	function
(	O
np	pointer
)	O
)	O
;	O
}	O
else	O
{	O
ret	int
=	O
0	int
;	O
}	O
return	O
ret	int
;	O
}	O
int	O
priestliness	function
(	O
Snation	struct
*	O
np	pointer
)	O
{	O
double	O
sqrt	function
(	O
)	O
;	O
int	O
ret	int
;	O
if	O
(	O
get_n_civil	function
(	O
np	pointer
)	O
)	O
{	O
ret	int
=	O
(	O
int	O
)	O
(	O
100	int
*	O
get_n_priests	function
(	O
np	pointer
)	O
/	O
get_n_civil	function
(	O
np	pointer
)	O
)	O
;	O
}	O
else	O
{	O
ret	int
=	O
0	int
;	O
}	O
return	O
ret	int
;	O
}	O
int	O
are_all_digits	function
(	O
char	O
*	O
s	array
)	O
{	O
while	O
(	O
*	O
s	array
)	O
{	O
if	O
(	O
!	O
isdigit	function
(	O
*	O
s	array
)	O
)	O
{	O
return	O
0	int
;	O
}	O
++	O
s	array
;	O
}	O
return	O
1	int
;	O
}	O
char	O
next_free_nation_mark	function
(	O
)	O
{	O
char	O
mark	char
;	O
for	O
(	O
mark	char
=	O
'a'	O
;	O
mark	char
<=	O
'z'	O
;	O
mark	char
++	O
)	O
{	O
if	O
(	O
free_nation_mark	function
(	O
&	O
world	struct
,	O
mark	char
)	O
)	O
{	O
return	O
mark	char
;	O
}	O
}	O
for	O
(	O
mark	char
=	O
'A'	O
;	O
mark	char
<=	O
'Z'	O
;	O
mark	char
++	O
)	O
{	O
if	O
(	O
free_nation_mark	function
(	O
&	O
world	struct
,	O
mark	char
)	O
)	O
{	O
return	O
mark	char
;	O
}	O
}	O
return	O
0	int
;	O
}	O
