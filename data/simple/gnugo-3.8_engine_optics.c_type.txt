struct	O
vital_points	struct
{	O
int	O
attacks	array
[	O
4	int
*	O
MAXEYE	int
]	O
;	O
int	O
defenses	array
[	O
4	int
*	O
MAXEYE	int
]	O
;	O
int	O
num_attacks	int
;	O
int	O
num_defenses	int
;	O
}	O
;	O
static	O
void	O
compute_primary_domains	function
(	O
int	O
color	int
,	O
int	O
domain	array
[	O
BOARDMAX	O
]	O
,	O
int	O
lively	array
[	O
BOARDMAX	O
]	O
,	O
int	O
false_margins	array
[	O
BOARDMAX	O
]	O
,	O
int	O
first_time	int
)	O
;	O
static	O
void	O
count_neighbours	function
(	O
struct	O
eye_data	struct
eyedata	array
[	O
BOARDMAX	O
]	O
)	O
;	O
static	O
int	O
is_lively	function
(	O
int	O
owl_call	int
,	O
int	O
pos	int
)	O
;	O
static	O
int	O
false_margin	function
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
lively	array
[	O
BOARDMAX	O
]	O
)	O
;	O
static	O
void	O
originate_eye	function
(	O
int	O
origin	int
,	O
int	O
pos	int
,	O
int	O
*	O
esize	int
,	O
int	O
*	O
msize	int
,	O
struct	O
eye_data	struct
eye	array
[	O
BOARDMAX	O
]	O
)	O
;	O
static	O
int	O
read_eye	function
(	O
int	O
pos	int
,	O
int	O
*	O
attack_point	pointer
,	O
int	O
*	O
defense_point	pointer
,	O
struct	O
eyevalue	struct
*	O
value	pointer
,	O
struct	O
eye_data	struct
eye	array
[	O
BOARDMAX	O
]	O
,	O
struct	O
half_eye_data	struct
heye	int
[	O
BOARDMAX	O
]	O
,	O
int	O
add_moves	int
)	O
;	O
static	O
int	O
recognize_eye	function
(	O
int	O
pos	int
,	O
int	O
*	O
attack_point	pointer
,	O
int	O
*	O
defense_point	pointer
,	O
struct	O
eyevalue	struct
*	O
value	pointer
,	O
struct	O
eye_data	struct
eye	array
[	O
BOARDMAX	O
]	O
,	O
struct	O
half_eye_data	struct
heye	int
[	O
BOARDMAX	O
]	O
,	O
struct	O
vital_points	struct
*	O
vp	pointer
)	O
;	O
static	O
void	O
guess_eye_space	function
(	O
int	O
pos	int
,	O
int	O
effective_eyesize	int
,	O
int	O
margins	int
,	O
int	O
bulk_score	int
,	O
struct	O
eye_data	struct
eye	array
[	O
BOARDMAX	O
]	O
,	O
struct	O
eyevalue	struct
*	O
value	pointer
,	O
int	O
*	O
pessimistic_min	pointer
)	O
;	O
static	O
void	O
reset_map	function
(	O
int	O
size	int
)	O
;	O
static	O
void	O
first_map	function
(	O
int	O
*	O
map_value	pointer
)	O
;	O
static	O
int	O
next_map	function
(	O
int	O
*	O
q	pointer
,	O
int	O
map	array
[	O
MAXEYE	int
]	O
)	O
;	O
static	O
void	O
print_eye	function
(	O
struct	O
eye_data	struct
eye	array
[	O
BOARDMAX	O
]	O
,	O
struct	O
half_eye_data	struct
heye	int
[	O
BOARDMAX	O
]	O
,	O
int	O
pos	int
)	O
;	O
static	O
void	O
add_false_eye	function
(	O
int	O
pos	int
,	O
struct	O
eye_data	struct
eye	array
[	O
BOARDMAX	O
]	O
,	O
struct	O
half_eye_data	struct
heye	int
[	O
BOARDMAX	O
]	O
)	O
;	O
static	O
float	O
topological_eye	function
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
struct	O
eye_data	struct
my_eye	array
[	O
BOARDMAX	O
]	O
,	O
struct	O
half_eye_data	struct
heye	int
[	O
BOARDMAX	O
]	O
)	O
;	O
static	O
float	O
evaluate_diagonal_intersection	function
(	O
int	O
m	int
,	O
int	O
n	int
,	O
int	O
color	int
,	O
int	O
*	O
attack_point	pointer
,	O
int	O
*	O
defense_point	pointer
,	O
struct	O
eye_data	struct
my_eye	array
[	O
BOARDMAX	O
]	O
)	O
;	O
static	O
int	O
black_domain	array
[	O
BOARDMAX	O
]	O
;	O
static	O
int	O
white_domain	array
[	O
BOARDMAX	O
]	O
;	O
static	O
int	O
map_size	int
;	O
static	O
signed	O
char	O
used_index	array
[	O
MAXEYE	int
]	O
;	O
void	O
make_domains	function
(	O
struct	O
eye_data	struct
b_eye	array
[	O
BOARDMAX	O
]	O
,	O
struct	O
eye_data	struct
w_eye	array
[	O
BOARDMAX	O
]	O
,	O
int	O
owl_call	int
)	O
{	O
int	O
k	int
;	O
int	O
pos	int
;	O
int	O
lively	array
[	O
BOARDMAX	O
]	O
;	O
int	O
false_margins	array
[	O
BOARDMAX	O
]	O
;	O
memset	function
(	O
black_domain	array
,	O
0	int
,	O
sizeof	O
(	O
black_domain	array
)	O
)	O
;	O
memset	function
(	O
white_domain	array
,	O
0	int
,	O
sizeof	O
(	O
white_domain	array
)	O
)	O
;	O
memset	function
(	O
false_margins	array
,	O
0	int
,	O
sizeof	O
(	O
false_margins	array
)	O
)	O
;	O
if	O
(	O
b_eye	array
)	O
memset	function
(	O
b_eye	array
,	O
0	int
,	O
BOARDMAX	O
*	O
sizeof	O
(	O
b_eye	array
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
w_eye	array
)	O
memset	function
(	O
w_eye	array
,	O
0	int
,	O
BOARDMAX	O
*	O
sizeof	O
(	O
w_eye	array
[	O
0	int
]	O
)	O
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
lively	array
[	O
pos	int
]	O
=	O
is_lively	function
(	O
owl_call	int
,	O
pos	int
)	O
;	O
compute_primary_domains	function
(	O
BLACK	int
,	O
black_domain	array
,	O
lively	array
,	O
false_margins	array
,	O
1	int
)	O
;	O
compute_primary_domains	function
(	O
WHITE	int
,	O
white_domain	array
,	O
lively	array
,	O
false_margins	array
,	O
0	int
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
||	O
!	O
lively	array
[	O
pos	int
]	O
)	O
{	O
if	O
(	O
black_domain	array
[	O
pos	int
]	O
==	O
0	int
&&	O
white_domain	array
[	O
pos	int
]	O
==	O
0	int
)	O
{	O
if	O
(	O
w_eye	array
)	O
w_eye	array
[	O
pos	int
]	O
.	O
color	int
=	O
GRAY	int
;	O
if	O
(	O
b_eye	array
)	O
b_eye	array
[	O
pos	int
]	O
.	O
color	int
=	O
GRAY	int
;	O
}	O
else	O
if	O
(	O
black_domain	array
[	O
pos	int
]	O
==	O
1	int
&&	O
white_domain	array
[	O
pos	int
]	O
==	O
0	int
&&	O
b_eye	array
)	O
{	O
b_eye	array
[	O
pos	int
]	O
.	O
color	int
=	O
BLACK	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
apos	int
=	O
pos	int
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
apos	int
)	O
&&	O
white_domain	array
[	O
apos	int
]	O
&&	O
!	O
black_domain	array
[	O
apos	int
]	O
)	O
{	O
b_eye	array
[	O
pos	int
]	O
.	O
marginal	char
=	O
1	int
;	O
break	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
black_domain	array
[	O
pos	int
]	O
==	O
0	int
&&	O
white_domain	array
[	O
pos	int
]	O
==	O
1	int
&&	O
w_eye	array
)	O
{	O
w_eye	array
[	O
pos	int
]	O
.	O
color	int
=	O
WHITE	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
apos	int
=	O
pos	int
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
apos	int
)	O
&&	O
black_domain	array
[	O
apos	int
]	O
&&	O
!	O
white_domain	array
[	O
apos	int
]	O
)	O
{	O
w_eye	array
[	O
pos	int
]	O
.	O
marginal	char
=	O
1	int
;	O
break	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
black_domain	array
[	O
pos	int
]	O
==	O
1	int
&&	O
white_domain	array
[	O
pos	int
]	O
==	O
1	int
)	O
{	O
if	O
(	O
b_eye	array
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
apos	int
=	O
pos	int
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
apos	int
)	O
&&	O
black_domain	array
[	O
apos	int
]	O
&&	O
!	O
white_domain	array
[	O
apos	int
]	O
)	O
{	O
b_eye	array
[	O
pos	int
]	O
.	O
marginal	char
=	O
1	int
;	O
b_eye	array
[	O
pos	int
]	O
.	O
color	int
=	O
BLACK	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
k	int
==	O
4	int
)	O
b_eye	array
[	O
pos	int
]	O
.	O
color	int
=	O
GRAY	int
;	O
}	O
if	O
(	O
w_eye	array
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
apos	int
=	O
pos	int
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
apos	int
)	O
&&	O
white_domain	array
[	O
apos	int
]	O
&&	O
!	O
black_domain	array
[	O
apos	int
]	O
)	O
{	O
w_eye	array
[	O
pos	int
]	O
.	O
marginal	char
=	O
1	int
;	O
w_eye	array
[	O
pos	int
]	O
.	O
color	int
=	O
WHITE	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
k	int
==	O
4	int
)	O
w_eye	array
[	O
pos	int
]	O
.	O
color	int
=	O
GRAY	int
;	O
}	O
}	O
}	O
}	O
partition_eyespaces	function
(	O
b_eye	array
,	O
BLACK	int
)	O
;	O
partition_eyespaces	function
(	O
w_eye	array
,	O
WHITE	int
)	O
;	O
}	O
void	O
partition_eyespaces	function
(	O
struct	O
eye_data	struct
eye	array
[	O
BOARDMAX	O
]	O
,	O
int	O
color	int
)	O
{	O
int	O
pos	int
;	O
if	O
(	O
!	O
eye	array
)	O
return	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
eye	array
[	O
pos	int
]	O
.	O
origin	int
=	O
NO_MOVE	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
if	O
(	O
eye	array
[	O
pos	int
]	O
.	O
origin	int
==	O
NO_MOVE	O
&&	O
eye	array
[	O
pos	int
]	O
.	O
color	int
==	O
color	int
)	O
{	O
int	O
esize	int
=	O
0	int
;	O
int	O
msize	int
=	O
0	int
;	O
originate_eye	function
(	O
pos	int
,	O
pos	int
,	O
&	O
esize	int
,	O
&	O
msize	int
,	O
eye	array
)	O
;	O
eye	array
[	O
pos	int
]	O
.	O
esize	int
=	O
esize	int
;	O
eye	array
[	O
pos	int
]	O
.	O
msize	int
=	O
msize	int
;	O
}	O
}	O
count_neighbours	function
(	O
eye	array
)	O
;	O
}	O
static	O
void	O
compute_primary_domains	function
(	O
int	O
color	int
,	O
int	O
domain	array
[	O
BOARDMAX	O
]	O
,	O
int	O
lively	array
[	O
BOARDMAX	O
]	O
,	O
int	O
false_margins	array
[	O
BOARDMAX	O
]	O
,	O
int	O
first_time	int
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
i	int
,	O
j	int
,	O
k	int
;	O
int	O
pos	int
,	O
pos2	int
;	O
int	O
own	int
,	O
enemy	int
;	O
signed	O
char	O
threshold	array
[	O
BOARDMAX	O
]	O
;	O
signed	O
char	O
influence	array
[	O
BOARDMAX	O
]	O
;	O
int	O
list	array
[	O
BOARDMAX	O
]	O
;	O
int	O
size	int
=	O
0	int
,	O
lastchange	int
=	O
0	int
;	O
memset	function
(	O
threshold	array
,	O
0	int
,	O
sizeof	O
(	O
threshold	array
)	O
)	O
;	O
memset	function
(	O
influence	array
,	O
0	int
,	O
sizeof	O
(	O
influence	array
)	O
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
if	O
(	O
lively	array
[	O
pos	int
]	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
color	int
)	O
{	O
domain	array
[	O
pos	int
]	O
=	O
1	int
;	O
influence	array
[	O
pos	int
]	O
=	O
1	int
;	O
}	O
else	O
influence	array
[	O
pos	int
]	O
=	O
-	O
1	int
;	O
continue	O
;	O
}	O
own	int
=	O
enemy	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
pos2	int
=	O
pos	int
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
pos2	int
)	O
&&	O
lively	array
[	O
pos2	int
]	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos2	int
]	O
==	O
color	int
)	O
own	int
=	O
1	int
;	O
else	O
enemy	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
own	int
)	O
{	O
if	O
(	O
first_time	int
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
&&	O
(	O
false_margin	function
(	O
pos	int
,	O
color	int
,	O
lively	array
)	O
||	O
false_margin	function
(	O
pos	int
,	O
other	int
,	O
lively	array
)	O
)	O
)	O
false_margins	array
[	O
pos	int
]	O
=	O
1	int
;	O
else	O
{	O
domain	array
[	O
pos	int
]	O
=	O
1	int
;	O
influence	array
[	O
pos	int
]	O
=	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
!=	O
EMPTY	int
||	O
!	O
false_margins	array
[	O
pos	int
]	O
)	O
{	O
domain	array
[	O
pos	int
]	O
=	O
1	int
;	O
influence	array
[	O
pos	int
]	O
=	O
1	int
;	O
}	O
}	O
else	O
list	array
[	O
size	int
++	O
]	O
=	O
pos	int
;	O
if	O
(	O
enemy	int
)	O
{	O
threshold	array
[	O
pos	int
]	O
=	O
1	int
;	O
influence	array
[	O
pos	int
]	O
--	O
;	O
}	O
else	O
if	O
(	O
is_edge_vertex	function
(	O
pos	int
)	O
)	O
influence	array
[	O
pos	int
]	O
--	O
;	O
}	O
if	O
(	O
size	int
)	O
{	O
k	int
=	O
size	int
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
!	O
k	int
)	O
k	int
=	O
size	int
;	O
pos	int
=	O
list	array
[	O
--	O
k	int
]	O
;	O
if	O
(	O
sufficient_influence	O
(	O
pos	int
,	O
SOUTH	O
(	O
pos	int
)	O
,	O
SE	O
(	O
pos	int
)	O
)	O
||	O
sufficient_influence	O
(	O
pos	int
,	O
SOUTH	O
(	O
pos	int
)	O
,	O
SW	O
(	O
pos	int
)	O
)	O
||	O
sufficient_influence	O
(	O
pos	int
,	O
EAST	O
(	O
pos	int
)	O
,	O
SE	O
(	O
pos	int
)	O
)	O
||	O
sufficient_influence	O
(	O
pos	int
,	O
EAST	O
(	O
pos	int
)	O
,	O
NE	O
(	O
pos	int
)	O
)	O
||	O
sufficient_influence	O
(	O
pos	int
,	O
WEST	O
(	O
pos	int
)	O
,	O
SW	O
(	O
pos	int
)	O
)	O
||	O
sufficient_influence	O
(	O
pos	int
,	O
WEST	O
(	O
pos	int
)	O
,	O
NW	O
(	O
pos	int
)	O
)	O
||	O
sufficient_influence	O
(	O
pos	int
,	O
NORTH	O
(	O
pos	int
)	O
,	O
NW	O
(	O
pos	int
)	O
)	O
||	O
sufficient_influence	O
(	O
pos	int
,	O
NORTH	O
(	O
pos	int
)	O
,	O
NE	O
(	O
pos	int
)	O
)	O
)	O
{	O
domain	array
[	O
pos	int
]	O
=	O
1	int
;	O
influence	array
[	O
pos	int
]	O
++	O
;	O
if	O
(	O
!	O
--	O
size	int
)	O
break	O
;	O
if	O
(	O
k	int
<	O
size	int
)	O
list	array
[	O
k	int
]	O
=	O
list	array
[	O
size	int
]	O
;	O
else	O
k	int
--	O
;	O
lastchange	int
=	O
k	int
;	O
}	O
else	O
if	O
(	O
k	int
==	O
lastchange	int
)	O
break	O
;	O
}	O
}	O
if	O
(	O
0	int
&&	O
(	O
debug	int
&	O
DEBUG_EYES	int
)	O
)	O
{	O
start_draw_board	function
(	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
board_size	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
board_size	int
;	O
j	int
++	O
)	O
{	O
draw_color_char	function
(	O
i	int
,	O
j	int
,	O
domain	array
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
?	O
'1'	O
:	O
'0'	O
,	O
GG_COLOR_BLACK	int
)	O
;	O
}	O
end_draw_board	function
(	O
)	O
;	O
}	O
}	O
static	O
void	O
count_neighbours	function
(	O
struct	O
eye_data	struct
eyedata	array
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
pos	int
;	O
int	O
k	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
||	O
eyedata	array
[	O
pos	int
]	O
.	O
origin	int
==	O
NO_MOVE	O
)	O
continue	O
;	O
eyedata	array
[	O
pos	int
]	O
.	O
esize	int
=	O
eyedata	array
[	O
eyedata	array
[	O
pos	int
]	O
.	O
origin	int
]	O
.	O
esize	int
;	O
eyedata	array
[	O
pos	int
]	O
.	O
msize	int
=	O
eyedata	array
[	O
eyedata	array
[	O
pos	int
]	O
.	O
origin	int
]	O
.	O
msize	int
;	O
eyedata	array
[	O
pos	int
]	O
.	O
neighbors	int
=	O
0	int
;	O
eyedata	array
[	O
pos	int
]	O
.	O
marginal_neighbors	char
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
pos2	int
=	O
pos	int
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
pos2	int
)	O
&&	O
eyedata	array
[	O
pos2	int
]	O
.	O
origin	int
==	O
eyedata	array
[	O
pos	int
]	O
.	O
origin	int
)	O
{	O
eyedata	array
[	O
pos	int
]	O
.	O
neighbors	int
++	O
;	O
if	O
(	O
eyedata	array
[	O
pos2	int
]	O
.	O
marginal	char
)	O
eyedata	array
[	O
pos	int
]	O
.	O
marginal_neighbors	char
++	O
;	O
}	O
}	O
}	O
}	O
static	O
int	O
is_lively	function
(	O
int	O
owl_call	int
,	O
int	O
pos	int
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
return	O
0	int
;	O
if	O
(	O
owl_call	int
)	O
return	O
owl_lively	function
(	O
pos	int
)	O
;	O
else	O
return	O
(	O
!	O
worm	array
[	O
pos	int
]	O
.	O
inessential	int
&&	O
(	O
worm	array
[	O
pos	int
]	O
.	O
attack_codes	array
[	O
0	int
]	O
==	O
0	int
||	O
worm	array
[	O
pos	int
]	O
.	O
defense_codes	array
[	O
0	int
]	O
!=	O
0	int
)	O
)	O
;	O
}	O
static	O
int	O
false_margin	function
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
lively	array
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
neighbors	int
=	O
0	int
;	O
int	O
k	int
;	O
int	O
all_lively	int
;	O
int	O
potential_false_margin	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
+	O
delta	array
[	O
k	int
]	O
)	O
)	O
neighbors	int
|=	O
board	pointer
[	O
pos	int
+	O
delta	array
[	O
k	int
]	O
]	O
;	O
if	O
(	O
neighbors	int
!=	O
(	O
WHITE	int
|	O
BLACK	int
)	O
)	O
return	O
0	int
;	O
all_lively	int
=	O
1	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
if	O
(	O
board	pointer
[	O
pos	int
+	O
delta	array
[	O
k	int
]	O
]	O
==	O
other	int
&&	O
!	O
lively	array
[	O
pos	int
+	O
delta	array
[	O
k	int
]	O
]	O
)	O
all_lively	int
=	O
0	int
;	O
if	O
(	O
all_lively	int
)	O
return	O
0	int
;	O
potential_false_margin	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
apos	int
=	O
pos	int
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
board	pointer
[	O
apos	int
]	O
!=	O
other	int
||	O
!	O
lively	array
[	O
apos	int
]	O
)	O
continue	O
;	O
if	O
(	O
stackp	int
==	O
0	int
&&	O
worm	array
[	O
apos	int
]	O
.	O
attack_codes	array
[	O
0	int
]	O
==	O
0	int
)	O
potential_false_margin	int
=	O
1	int
;	O
if	O
(	O
stackp	int
>	O
0	int
&&	O
!	O
attack	function
(	O
apos	int
,	O
NULL	O
)	O
)	O
potential_false_margin	int
=	O
1	int
;	O
}	O
if	O
(	O
potential_false_margin	int
&&	O
safe_move	function
(	O
pos	int
,	O
other	int
)	O
==	O
0	int
)	O
{	O
DEBUG	O
(	O
DEBUG_EYES	int
,	O
"False margin for %C at %1m.\n"	pointer
,	O
color	int
,	O
pos	int
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
originate_eye	function
(	O
int	O
origin	int
,	O
int	O
pos	int
,	O
int	O
*	O
esize	int
,	O
int	O
*	O
msize	int
,	O
struct	O
eye_data	struct
eye	array
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
k	int
;	O
ASSERT_ON_BOARD1	O
(	O
origin	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
gg_assert	O
(	O
esize	int
!=	O
NULL	O
)	O
;	O
gg_assert	O
(	O
msize	int
!=	O
NULL	O
)	O
;	O
eye	array
[	O
pos	int
]	O
.	O
origin	int
=	O
origin	int
;	O
(	O
*	O
esize	int
)	O
++	O
;	O
if	O
(	O
eye	array
[	O
pos	int
]	O
.	O
marginal	char
)	O
(	O
*	O
msize	int
)	O
++	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
pos2	int
=	O
pos	int
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
pos2	int
)	O
&&	O
eye	array
[	O
pos2	int
]	O
.	O
color	int
==	O
eye	array
[	O
pos	int
]	O
.	O
color	int
&&	O
eye	array
[	O
pos2	int
]	O
.	O
origin	int
==	O
NO_MOVE	O
&&	O
(	O
!	O
eye	array
[	O
pos2	int
]	O
.	O
marginal	char
||	O
!	O
eye	array
[	O
pos	int
]	O
.	O
marginal	char
)	O
)	O
originate_eye	function
(	O
origin	int
,	O
pos2	int
,	O
esize	int
,	O
msize	int
,	O
eye	array
)	O
;	O
}	O
}	O
void	O
propagate_eye	function
(	O
int	O
origin	int
,	O
struct	O
eye_data	struct
eye	array
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
pos	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
eye	array
[	O
pos	int
]	O
.	O
origin	int
==	O
origin	int
)	O
{	O
eye	array
[	O
pos	int
]	O
.	O
color	int
=	O
eye	array
[	O
origin	int
]	O
.	O
color	int
;	O
eye	array
[	O
pos	int
]	O
.	O
esize	int
=	O
eye	array
[	O
origin	int
]	O
.	O
esize	int
;	O
eye	array
[	O
pos	int
]	O
.	O
msize	int
=	O
eye	array
[	O
origin	int
]	O
.	O
msize	int
;	O
eye	array
[	O
pos	int
]	O
.	O
origin	int
=	O
eye	array
[	O
origin	int
]	O
.	O
origin	int
;	O
eye	array
[	O
pos	int
]	O
.	O
value	pointer
=	O
eye	array
[	O
origin	int
]	O
.	O
value	pointer
;	O
}	O
}	O
int	O
find_eye_dragons	function
(	O
int	O
origin	int
,	O
struct	O
eye_data	struct
eye	array
[	O
BOARDMAX	O
]	O
,	O
int	O
eye_color	int
,	O
int	O
dragons	array
[	O
]	O
,	O
int	O
max_dragons	int
)	O
{	O
int	O
mx	array
[	O
BOARDMAX	O
]	O
;	O
int	O
num_dragons	int
=	O
0	int
;	O
int	O
pos	int
;	O
memset	function
(	O
mx	array
,	O
0	int
,	O
sizeof	O
(	O
mx	array
)	O
)	O
;	O
DEBUG	O
(	O
DEBUG_MISCELLANEOUS	int
,	O
"find_eye_dragons: %1m %C\n"	pointer
,	O
origin	int
,	O
eye_color	int
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
eye_color	int
&&	O
mx	array
[	O
dragon	int
[	O
pos	int
]	O
.	O
origin	int
]	O
==	O
0	int
&&	O
(	O
(	O
ON_BOARD	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
&&	O
eye	array
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
.	O
origin	int
==	O
origin	int
&&	O
!	O
eye	array
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
.	O
marginal	char
)	O
||	O
(	O
ON_BOARD	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
&&	O
eye	array
[	O
WEST	O
(	O
pos	int
)	O
]	O
.	O
origin	int
==	O
origin	int
&&	O
!	O
eye	array
[	O
WEST	O
(	O
pos	int
)	O
]	O
.	O
marginal	char
)	O
||	O
(	O
ON_BOARD	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
&&	O
eye	array
[	O
NORTH	O
(	O
pos	int
)	O
]	O
.	O
origin	int
==	O
origin	int
&&	O
!	O
eye	array
[	O
NORTH	O
(	O
pos	int
)	O
]	O
.	O
marginal	char
)	O
||	O
(	O
ON_BOARD	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
&&	O
eye	array
[	O
EAST	O
(	O
pos	int
)	O
]	O
.	O
origin	int
==	O
origin	int
&&	O
!	O
eye	array
[	O
EAST	O
(	O
pos	int
)	O
]	O
.	O
marginal	char
)	O
)	O
)	O
{	O
DEBUG	O
(	O
DEBUG_MISCELLANEOUS	int
,	O
"  dragon: %1m %1m\n"	pointer
,	O
pos	int
,	O
dragon	int
[	O
pos	int
]	O
.	O
origin	int
)	O
;	O
mx	array
[	O
dragon	int
[	O
pos	int
]	O
.	O
origin	int
]	O
=	O
1	int
;	O
if	O
(	O
dragons	array
!=	O
NULL	O
&&	O
num_dragons	int
<	O
max_dragons	int
)	O
dragons	array
[	O
num_dragons	int
]	O
=	O
dragon	int
[	O
pos	int
]	O
.	O
origin	int
;	O
num_dragons	int
++	O
;	O
}	O
}	O
return	O
num_dragons	int
;	O
}	O
static	O
void	O
print_eye	function
(	O
struct	O
eye_data	struct
eye	array
[	O
BOARDMAX	O
]	O
,	O
struct	O
half_eye_data	struct
heye	int
[	O
BOARDMAX	O
]	O
,	O
int	O
pos	int
)	O
{	O
int	O
m	int
,	O
n	int
;	O
int	O
pos2	int
;	O
int	O
mini	int
,	O
maxi	int
;	O
int	O
minj	int
,	O
maxj	int
;	O
int	O
origin	int
=	O
eye	array
[	O
pos	int
]	O
.	O
origin	int
;	O
gprintf	function
(	O
"Eyespace at %1m: color=%C, esize=%d, msize=%d\n"	pointer
,	O
pos	int
,	O
eye	array
[	O
pos	int
]	O
.	O
color	int
,	O
eye	array
[	O
pos	int
]	O
.	O
esize	int
,	O
eye	array
[	O
pos	int
]	O
.	O
msize	int
)	O
;	O
for	O
(	O
pos2	int
=	O
BOARDMIN	O
;	O
pos2	int
<	O
BOARDMAX	O
;	O
pos2	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos2	int
)	O
)	O
continue	O
;	O
if	O
(	O
eye	array
[	O
pos2	int
]	O
.	O
origin	int
!=	O
pos	int
)	O
continue	O
;	O
if	O
(	O
eye	array
[	O
pos2	int
]	O
.	O
marginal	char
&&	O
IS_STONE	O
(	O
board	pointer
[	O
pos2	int
]	O
)	O
)	O
gprintf	function
(	O
"%1m (X!)\n"	pointer
,	O
pos2	int
)	O
;	O
else	O
if	O
(	O
is_halfeye	function
(	O
heye	int
,	O
pos2	int
)	O
&&	O
IS_STONE	O
(	O
board	pointer
[	O
pos2	int
]	O
)	O
)	O
{	O
if	O
(	O
heye	int
[	O
pos2	int
]	O
.	O
value	pointer
==	O
3.0	int
)	O
gprintf	function
(	O
"%1m (XH)\n"	pointer
,	O
pos2	int
)	O
;	O
else	O
gprintf	function
(	O
"%1m (XH) (topological eye value = %f)\n"	pointer
,	O
pos2	int
,	O
heye	int
[	O
pos2	int
]	O
.	O
value	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
eye	array
[	O
pos2	int
]	O
.	O
marginal	char
&&	O
IS_STONE	O
(	O
board	pointer
[	O
pos2	int
]	O
)	O
)	O
gprintf	function
(	O
"%1m (X)\n"	pointer
,	O
pos2	int
)	O
;	O
else	O
if	O
(	O
eye	array
[	O
pos2	int
]	O
.	O
marginal	char
&&	O
board	pointer
[	O
pos2	int
]	O
==	O
EMPTY	int
)	O
gprintf	function
(	O
"%1m (!)\n"	pointer
,	O
pos2	int
)	O
;	O
else	O
if	O
(	O
is_halfeye	function
(	O
heye	int
,	O
pos2	int
)	O
&&	O
board	pointer
[	O
pos2	int
]	O
==	O
EMPTY	int
)	O
{	O
if	O
(	O
heye	int
[	O
pos2	int
]	O
.	O
value	pointer
==	O
3.0	int
)	O
gprintf	function
(	O
"%1m (H)\n"	pointer
,	O
pos2	int
)	O
;	O
else	O
gprintf	function
(	O
"%1m (H) (topological eye value = %f)\n"	pointer
,	O
pos2	int
,	O
heye	int
[	O
pos2	int
]	O
.	O
value	pointer
)	O
;	O
}	O
else	O
gprintf	function
(	O
"%1m\n"	pointer
,	O
pos2	int
)	O
;	O
}	O
gprintf	function
(	O
"\n"	pointer
)	O
;	O
mini	int
=	O
board_size	int
;	O
maxi	int
=	O
-	O
1	int
;	O
minj	int
=	O
board_size	int
;	O
maxj	int
=	O
-	O
1	int
;	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
board_size	int
;	O
m	int
++	O
)	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
board_size	int
;	O
n	int
++	O
)	O
{	O
if	O
(	O
eye	array
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
.	O
origin	int
!=	O
origin	int
)	O
continue	O
;	O
if	O
(	O
m	int
<	O
mini	int
)	O
mini	int
=	O
m	int
;	O
if	O
(	O
m	int
>	O
maxi	int
)	O
maxi	int
=	O
m	int
;	O
if	O
(	O
n	int
<	O
minj	int
)	O
minj	int
=	O
n	int
;	O
if	O
(	O
n	int
>	O
maxj	int
)	O
maxj	int
=	O
n	int
;	O
}	O
for	O
(	O
m	int
=	O
mini	int
;	O
m	int
<=	O
maxi	int
;	O
m	int
++	O
)	O
{	O
gprintf	function
(	O
""	pointer
)	O
;	O
for	O
(	O
n	int
=	O
minj	int
;	O
n	int
<=	O
maxj	int
;	O
n	int
++	O
)	O
{	O
int	O
pos2	int
=	O
POS	O
(	O
m	int
,	O
n	int
)	O
;	O
if	O
(	O
eye	array
[	O
pos2	int
]	O
.	O
origin	int
==	O
origin	int
)	O
{	O
if	O
(	O
board	pointer
[	O
pos2	int
]	O
==	O
EMPTY	int
)	O
{	O
if	O
(	O
eye	array
[	O
pos2	int
]	O
.	O
marginal	char
)	O
gprintf	function
(	O
"%o!"	pointer
)	O
;	O
else	O
if	O
(	O
is_halfeye	function
(	O
heye	int
,	O
pos2	int
)	O
)	O
gprintf	function
(	O
"%oh"	pointer
)	O
;	O
else	O
gprintf	function
(	O
"%o."	pointer
)	O
;	O
}	O
else	O
if	O
(	O
is_halfeye	function
(	O
heye	int
,	O
pos2	int
)	O
)	O
gprintf	function
(	O
"%oH"	pointer
)	O
;	O
else	O
gprintf	function
(	O
"%oX"	pointer
)	O
;	O
}	O
else	O
gprintf	function
(	O
"%o "	pointer
)	O
;	O
}	O
gprintf	function
(	O
"\n"	pointer
)	O
;	O
}	O
}	O
void	O
compute_eyes	function
(	O
int	O
pos	int
,	O
struct	O
eyevalue	struct
*	O
value	pointer
,	O
int	O
*	O
attack_point	pointer
,	O
int	O
*	O
defense_point	pointer
,	O
struct	O
eye_data	struct
eye	array
[	O
BOARDMAX	O
]	O
,	O
struct	O
half_eye_data	struct
heye	int
[	O
BOARDMAX	O
]	O
,	O
int	O
add_moves	int
)	O
{	O
if	O
(	O
attack_point	pointer
)	O
*	O
attack_point	pointer
=	O
NO_MOVE	O
;	O
if	O
(	O
defense_point	pointer
)	O
*	O
defense_point	pointer
=	O
NO_MOVE	O
;	O
if	O
(	O
debug	int
&	O
DEBUG_EYES	int
)	O
{	O
print_eye	function
(	O
eye	array
,	O
heye	int
,	O
pos	int
)	O
;	O
DEBUG	O
(	O
DEBUG_EYES	int
,	O
"\n"	pointer
)	O
;	O
}	O
if	O
(	O
read_eye	function
(	O
pos	int
,	O
attack_point	pointer
,	O
defense_point	pointer
,	O
value	pointer
,	O
eye	array
,	O
heye	int
,	O
add_moves	int
)	O
)	O
return	O
;	O
if	O
(	O
eye	array
[	O
pos	int
]	O
.	O
esize	int
-	O
2	int
*	O
eye	array
[	O
pos	int
]	O
.	O
msize	int
>	O
3	int
)	O
set_eyevalue	function
(	O
value	pointer
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
)	O
;	O
else	O
if	O
(	O
eye	array
[	O
pos	int
]	O
.	O
esize	int
-	O
2	int
*	O
eye	array
[	O
pos	int
]	O
.	O
msize	int
>	O
0	int
)	O
set_eyevalue	function
(	O
value	pointer
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
)	O
;	O
else	O
set_eyevalue	function
(	O
value	pointer
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
}	O
void	O
compute_eyes_pessimistic	function
(	O
int	O
pos	int
,	O
struct	O
eyevalue	struct
*	O
value	pointer
,	O
int	O
*	O
pessimistic_min	pointer
,	O
int	O
*	O
attack_point	pointer
,	O
int	O
*	O
defense_point	pointer
,	O
struct	O
eye_data	struct
eye	array
[	O
BOARDMAX	O
]	O
,	O
struct	O
half_eye_data	struct
heye	int
[	O
BOARDMAX	O
]	O
)	O
{	O
static	O
int	O
bulk_coefficients	array
[	O
5	int
]	O
=	O
{	O
-	O
1	int
,	O
-	O
1	int
,	O
1	int
,	O
4	int
,	O
12	int
}	O
;	O
int	O
pos2	int
;	O
int	O
margins	int
=	O
0	int
;	O
int	O
halfeyes	int
=	O
0	int
;	O
int	O
margins_adjacent_to_margin	int
=	O
0	int
;	O
int	O
effective_eyesize	int
;	O
int	O
bulk_score	int
=	O
0	int
;	O
signed	O
char	O
chainlinks	function
[	O
BOARDMAX	O
]	O
;	O
int	O
interior_stones	int
=	O
0	int
;	O
memset	function
(	O
chainlinks	function
,	O
0	int
,	O
BOARDMAX	O
)	O
;	O
for	O
(	O
pos2	int
=	O
BOARDMIN	O
;	O
pos2	int
<	O
BOARDMAX	O
;	O
pos2	int
++	O
)	O
{	O
int	O
k	int
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos2	int
)	O
||	O
eye	array
[	O
pos2	int
]	O
.	O
origin	int
!=	O
pos	int
)	O
continue	O
;	O
if	O
(	O
eye	array
[	O
pos2	int
]	O
.	O
marginal	char
||	O
is_halfeye	function
(	O
heye	int
,	O
pos2	int
)	O
)	O
{	O
margins	int
++	O
;	O
if	O
(	O
eye	array
[	O
pos2	int
]	O
.	O
marginal	char
&&	O
eye	array
[	O
pos2	int
]	O
.	O
marginal_neighbors	char
>	O
0	int
)	O
margins_adjacent_to_margin	int
++	O
;	O
if	O
(	O
is_halfeye	function
(	O
heye	int
,	O
pos2	int
)	O
)	O
halfeyes	int
++	O
;	O
}	O
else	O
if	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
pos2	int
]	O
)	O
)	O
interior_stones	int
++	O
;	O
bulk_score	int
+=	O
bulk_coefficients	array
[	O
(	O
int	O
)	O
eye	array
[	O
pos2	int
]	O
.	O
neighbors	int
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
neighbor	int
=	O
pos2	int
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
board	pointer
[	O
neighbor	int
]	O
==	O
eye	array
[	O
pos	int
]	O
.	O
color	int
)	O
{	O
if	O
(	O
!	O
chainlinks	function
[	O
neighbor	int
]	O
)	O
{	O
bulk_score	int
+=	O
4	int
;	O
mark_string	function
(	O
neighbor	int
,	O
chainlinks	function
,	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
ON_BOARD	O
(	O
neighbor	int
)	O
)	O
bulk_score	int
+=	O
2	int
;	O
}	O
}	O
effective_eyesize	int
=	O
(	O
eye	array
[	O
pos	int
]	O
.	O
esize	int
+	O
halfeyes	int
-	O
2	int
*	O
margins	int
-	O
margins_adjacent_to_margin	int
)	O
;	O
if	O
(	O
attack_point	pointer
)	O
*	O
attack_point	pointer
=	O
NO_MOVE	O
;	O
if	O
(	O
defense_point	pointer
)	O
*	O
defense_point	pointer
=	O
NO_MOVE	O
;	O
if	O
(	O
debug	int
&	O
DEBUG_EYES	int
)	O
{	O
print_eye	function
(	O
eye	array
,	O
heye	int
,	O
pos	int
)	O
;	O
DEBUG	O
(	O
DEBUG_EYES	int
,	O
"\n"	pointer
)	O
;	O
}	O
if	O
(	O
read_eye	function
(	O
pos	int
,	O
attack_point	pointer
,	O
defense_point	pointer
,	O
value	pointer
,	O
eye	array
,	O
heye	int
,	O
0	int
)	O
)	O
{	O
*	O
pessimistic_min	pointer
=	O
min_eyes	function
(	O
value	pointer
)	O
-	O
margins	int
;	O
if	O
(	O
eye	array
[	O
pos	int
]	O
.	O
esize	int
==	O
1	int
&&	O
is_ko	function
(	O
pos	int
,	O
OTHER_COLOR	O
(	O
eye	array
[	O
pos	int
]	O
.	O
color	int
)	O
,	O
NULL	O
)	O
)	O
*	O
pessimistic_min	pointer
=	O
0	int
;	O
DEBUG	O
(	O
DEBUG_EYES	int
,	O
"  graph matching - %s, pessimistic_min=%d\n"	pointer
,	O
eyevalue_to_string	function
(	O
value	pointer
)	O
,	O
*	O
pessimistic_min	pointer
)	O
;	O
}	O
else	O
{	O
guess_eye_space	function
(	O
pos	int
,	O
effective_eyesize	int
,	O
margins	int
,	O
bulk_score	int
,	O
eye	array
,	O
value	pointer
,	O
pessimistic_min	pointer
)	O
;	O
DEBUG	O
(	O
DEBUG_EYES	int
,	O
"  guess_eye - %s, pessimistic_min=%d\n"	pointer
,	O
eyevalue_to_string	function
(	O
value	pointer
)	O
,	O
*	O
pessimistic_min	pointer
)	O
;	O
}	O
if	O
(	O
*	O
pessimistic_min	pointer
<	O
0	int
)	O
{	O
*	O
pessimistic_min	pointer
=	O
0	int
;	O
DEBUG	O
(	O
DEBUG_EYES	int
,	O
"  pessimistic min revised to 0\n"	pointer
)	O
;	O
}	O
if	O
(	O
*	O
pessimistic_min	pointer
<	O
1	int
&&	O
interior_stones	int
>=	O
2	int
)	O
{	O
*	O
pessimistic_min	pointer
=	O
1	int
;	O
DEBUG	O
(	O
DEBUG_EYES	int
,	O
"  pessimistic min revised to 1 (interior stones)\n"	pointer
)	O
;	O
}	O
if	O
(	O
attack_point	pointer
&&	O
*	O
attack_point	pointer
==	O
NO_MOVE	O
&&	O
max_eyes	function
(	O
value	pointer
)	O
!=	O
*	O
pessimistic_min	pointer
)	O
{	O
int	O
best_attack_point	int
=	O
NO_MOVE	O
;	O
int	O
best_defense_point	int
=	O
NO_MOVE	O
;	O
float	O
score	float
=	O
0.0	int
;	O
for	O
(	O
pos2	int
=	O
BOARDMIN	O
;	O
pos2	int
<	O
BOARDMAX	O
;	O
pos2	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
pos2	int
)	O
&&	O
eye	array
[	O
pos2	int
]	O
.	O
origin	int
==	O
pos	int
)	O
{	O
float	O
this_score	float
=	O
0.0	int
;	O
int	O
this_attack_point	int
=	O
NO_MOVE	O
;	O
int	O
this_defense_point	int
=	O
NO_MOVE	O
;	O
if	O
(	O
eye	array
[	O
pos2	int
]	O
.	O
marginal	char
&&	O
board	pointer
[	O
pos2	int
]	O
==	O
EMPTY	int
)	O
{	O
this_score	float
=	O
eye	array
[	O
pos2	int
]	O
.	O
neighbors	int
;	O
this_attack_point	int
=	O
pos2	int
;	O
this_defense_point	int
=	O
pos2	int
;	O
if	O
(	O
is_self_atari	function
(	O
pos2	int
,	O
OTHER_COLOR	O
(	O
eye	array
[	O
pos	int
]	O
.	O
color	int
)	O
)	O
)	O
this_score	float
-=	O
0.5	int
;	O
if	O
(	O
is_edge_vertex	function
(	O
pos2	int
)	O
)	O
this_score	float
-=	O
0.1	int
;	O
}	O
else	O
if	O
(	O
is_halfeye	function
(	O
heye	int
,	O
pos2	int
)	O
)	O
{	O
this_score	float
=	O
0.75	int
;	O
this_defense_point	int
=	O
heye	int
[	O
pos2	int
]	O
.	O
defense_point	pointer
[	O
0	int
]	O
;	O
this_attack_point	int
=	O
heye	int
[	O
pos2	int
]	O
.	O
attack_point	pointer
[	O
0	int
]	O
;	O
}	O
else	O
continue	O
;	O
if	O
(	O
gg_normalize_float2int	function
(	O
this_score	float
,	O
0.01	int
)	O
>	O
gg_normalize_float2int	function
(	O
score	float
,	O
0.01	int
)	O
)	O
{	O
best_attack_point	int
=	O
this_attack_point	int
;	O
best_defense_point	int
=	O
this_defense_point	int
;	O
score	float
=	O
this_score	float
;	O
}	O
}	O
}	O
if	O
(	O
score	float
>	O
0.0	int
)	O
{	O
if	O
(	O
defense_point	pointer
)	O
*	O
defense_point	pointer
=	O
best_defense_point	int
;	O
if	O
(	O
attack_point	pointer
)	O
*	O
attack_point	pointer
=	O
best_attack_point	int
;	O
}	O
}	O
if	O
(	O
defense_point	pointer
&&	O
*	O
defense_point	pointer
!=	O
NO_MOVE	O
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
*	O
defense_point	pointer
)	O
;	O
}	O
if	O
(	O
attack_point	pointer
&&	O
*	O
attack_point	pointer
!=	O
NO_MOVE	O
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
*	O
attack_point	pointer
)	O
;	O
}	O
}	O
static	O
void	O
guess_eye_space	function
(	O
int	O
pos	int
,	O
int	O
effective_eyesize	int
,	O
int	O
margins	int
,	O
int	O
bulk_score	int
,	O
struct	O
eye_data	struct
eye	array
[	O
BOARDMAX	O
]	O
,	O
struct	O
eyevalue	struct
*	O
value	pointer
,	O
int	O
*	O
pessimistic_min	pointer
)	O
{	O
if	O
(	O
effective_eyesize	int
>	O
3	int
)	O
{	O
set_eyevalue	function
(	O
value	pointer
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
)	O
;	O
*	O
pessimistic_min	pointer
=	O
1	int
;	O
if	O
(	O
(	O
margins	int
==	O
0	int
&&	O
effective_eyesize	int
>	O
7	int
)	O
||	O
(	O
margins	int
>	O
0	int
&&	O
effective_eyesize	int
>	O
9	int
)	O
)	O
{	O
int	O
eyes	int
=	O
2	int
+	O
(	O
effective_eyesize	int
-	O
2	int
*	O
(	O
margins	int
>	O
0	int
)	O
-	O
8	int
)	O
/	O
2	int
;	O
int	O
threshold	array
=	O
(	O
4	int
*	O
(	O
eye	array
[	O
pos	int
]	O
.	O
esize	int
-	O
2	int
)	O
+	O
(	O
effective_eyesize	int
-	O
8	int
)	O
*	O
(	O
effective_eyesize	int
-	O
9	int
)	O
)	O
;	O
DEBUG	O
(	O
DEBUG_EYES	int
,	O
"size: %d(%d), threshold: %d, bulk score: %d\n"	pointer
,	O
eye	array
[	O
pos	int
]	O
.	O
esize	int
,	O
effective_eyesize	int
,	O
threshold	array
,	O
bulk_score	int
)	O
;	O
if	O
(	O
bulk_score	int
>	O
threshold	array
&&	O
effective_eyesize	int
<	O
15	int
)	O
eyes	int
=	O
gg_max	O
(	O
2	int
,	O
eyes	int
-	O
(	O
(	O
bulk_score	int
-	O
threshold	array
)	O
/	O
eye	array
[	O
pos	int
]	O
.	O
esize	int
)	O
)	O
;	O
if	O
(	O
bulk_score	int
<	O
threshold	array
+	O
eye	array
[	O
pos	int
]	O
.	O
esize	int
||	O
effective_eyesize	int
>=	O
15	int
)	O
*	O
pessimistic_min	pointer
=	O
eyes	int
;	O
set_eyevalue	function
(	O
value	pointer
,	O
eyes	int
,	O
eyes	int
,	O
eyes	int
,	O
eyes	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
effective_eyesize	int
>	O
0	int
)	O
{	O
set_eyevalue	function
(	O
value	pointer
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
)	O
;	O
if	O
(	O
margins	int
>	O
0	int
)	O
*	O
pessimistic_min	pointer
=	O
0	int
;	O
else	O
*	O
pessimistic_min	pointer
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
eye	array
[	O
pos	int
]	O
.	O
esize	int
-	O
margins	int
>	O
2	int
)	O
set_eyevalue	function
(	O
value	pointer
,	O
0	int
,	O
0	int
,	O
1	int
,	O
1	int
)	O
;	O
else	O
set_eyevalue	function
(	O
value	pointer
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
*	O
pessimistic_min	pointer
=	O
0	int
;	O
}	O
}	O
static	O
int	O
read_eye	function
(	O
int	O
pos	int
,	O
int	O
*	O
attack_point	pointer
,	O
int	O
*	O
defense_point	pointer
,	O
struct	O
eyevalue	struct
*	O
value	pointer
,	O
struct	O
eye_data	struct
eye	array
[	O
BOARDMAX	O
]	O
,	O
struct	O
half_eye_data	struct
heye	int
[	O
BOARDMAX	O
]	O
,	O
int	O
add_moves	int
)	O
{	O
int	O
eye_color	int
;	O
int	O
k	int
;	O
int	O
pos2	int
;	O
int	O
combination_halfeye	int
=	O
NO_MOVE	O
;	O
int	O
combination_attack	int
=	O
NO_MOVE	O
;	O
int	O
combination_defense	int
=	O
NO_MOVE	O
;	O
int	O
num_ko_halfeyes	int
=	O
0	int
;	O
int	O
ko_halfeye	int
=	O
NO_MOVE	O
;	O
struct	O
vital_points	struct
vp	pointer
;	O
struct	O
vital_points	struct
ko_vp	struct
;	O
struct	O
vital_points	struct
*	O
best_vp	pointer
=	O
&	O
vp	pointer
;	O
eye_color	int
=	O
recognize_eye	function
(	O
pos	int
,	O
attack_point	pointer
,	O
defense_point	pointer
,	O
value	pointer
,	O
eye	array
,	O
heye	int
,	O
&	O
vp	pointer
)	O
;	O
if	O
(	O
!	O
eye_color	int
)	O
return	O
0	int
;	O
for	O
(	O
pos2	int
=	O
BOARDMIN	O
;	O
pos2	int
<	O
BOARDMAX	O
;	O
pos2	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
pos2	int
)	O
&&	O
eye	array
[	O
pos2	int
]	O
.	O
origin	int
==	O
pos	int
&&	O
heye	int
[	O
pos2	int
]	O
.	O
type	char
==	O
HALF_EYE	int
)	O
{	O
if	O
(	O
combination_halfeye	int
==	O
NO_MOVE	O
)	O
{	O
int	O
apos	int
=	O
NO_MOVE	O
;	O
int	O
dpos	int
=	O
NO_MOVE	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
heye	int
[	O
pos2	int
]	O
.	O
num_attacks	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
eye	array
[	O
heye	int
[	O
pos2	int
]	O
.	O
attack_point	pointer
[	O
k	int
]	O
]	O
.	O
origin	int
==	O
pos	int
)	O
{	O
apos	int
=	O
heye	int
[	O
pos2	int
]	O
.	O
attack_point	pointer
[	O
k	int
]	O
;	O
break	O
;	O
}	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
heye	int
[	O
pos2	int
]	O
.	O
num_defenses	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
eye	array
[	O
heye	int
[	O
pos2	int
]	O
.	O
defense_point	pointer
[	O
k	int
]	O
]	O
.	O
origin	int
==	O
pos	int
)	O
{	O
dpos	int
=	O
heye	int
[	O
pos2	int
]	O
.	O
defense_point	pointer
[	O
k	int
]	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
apos	int
||	O
dpos	int
)	O
{	O
combination_halfeye	int
=	O
pos2	int
;	O
combination_attack	int
=	O
apos	int
;	O
combination_defense	int
=	O
dpos	int
;	O
}	O
}	O
if	O
(	O
heye	int
[	O
pos2	int
]	O
.	O
value	pointer
<	O
3.0	int
)	O
{	O
num_ko_halfeyes	int
++	O
;	O
ko_halfeye	int
=	O
pos2	int
;	O
}	O
}	O
}	O
if	O
(	O
combination_halfeye	int
!=	O
NO_MOVE	O
)	O
{	O
int	O
result	int
;	O
int	O
apos	int
=	O
NO_MOVE	O
;	O
int	O
dpos	int
=	O
NO_MOVE	O
;	O
struct	O
eyevalue	struct
combination_value	struct
;	O
struct	O
vital_points	struct
combination_vp	struct
;	O
heye	int
[	O
combination_halfeye	int
]	O
.	O
type	char
=	O
0	int
;	O
result	int
=	O
recognize_eye	function
(	O
pos	int
,	O
&	O
apos	int
,	O
&	O
dpos	int
,	O
&	O
combination_value	struct
,	O
eye	array
,	O
heye	int
,	O
&	O
combination_vp	struct
)	O
;	O
heye	int
[	O
combination_halfeye	int
]	O
.	O
type	char
=	O
HALF_EYE	int
;	O
if	O
(	O
result	int
)	O
{	O
if	O
(	O
combination_attack	int
&&	O
min_eyes	function
(	O
value	pointer
)	O
>	O
min_eyes	function
(	O
&	O
combination_value	struct
)	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
combination_vp	struct
.	O
num_attacks	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
combination_vp	struct
.	O
attacks	array
[	O
k	int
]	O
==	O
combination_attack	int
)	O
{	O
value	pointer
->	O
a	char
=	O
combination_value	struct
.	O
a	char
;	O
value	pointer
->	O
b	char
=	O
combination_value	struct
.	O
b	char
;	O
*	O
attack_point	pointer
=	O
apos	int
;	O
best_vp	pointer
->	O
num_attacks	int
=	O
1	int
;	O
best_vp	pointer
->	O
attacks	array
[	O
0	int
]	O
=	O
combination_attack	int
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
combination_defense	int
&&	O
max_eyes	function
(	O
value	pointer
)	O
<	O
max_eyes	function
(	O
&	O
combination_value	struct
)	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
combination_vp	struct
.	O
num_defenses	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
combination_vp	struct
.	O
defenses	array
[	O
k	int
]	O
==	O
combination_defense	int
)	O
{	O
value	pointer
->	O
c	char
=	O
combination_value	struct
.	O
c	char
;	O
value	pointer
->	O
d	int
=	O
combination_value	struct
.	O
d	int
;	O
*	O
defense_point	pointer
=	O
dpos	int
;	O
best_vp	pointer
->	O
num_defenses	int
=	O
1	int
;	O
best_vp	pointer
->	O
defenses	array
[	O
0	int
]	O
=	O
combination_defense	int
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
min_eyes	function
(	O
value	pointer
)	O
!=	O
max_eyes	function
(	O
value	pointer
)	O
)	O
{	O
ASSERT1	O
(	O
combination_attack	int
||	O
combination_defense	int
,	O
combination_halfeye	int
)	O
;	O
if	O
(	O
*	O
attack_point	pointer
==	O
NO_MOVE	O
)	O
{	O
*	O
attack_point	pointer
=	O
combination_attack	int
;	O
if	O
(	O
*	O
attack_point	pointer
==	O
NO_MOVE	O
)	O
*	O
attack_point	pointer
=	O
combination_defense	int
;	O
}	O
if	O
(	O
*	O
defense_point	pointer
==	O
NO_MOVE	O
)	O
{	O
*	O
defense_point	pointer
=	O
combination_defense	int
;	O
if	O
(	O
*	O
defense_point	pointer
==	O
NO_MOVE	O
)	O
*	O
defense_point	pointer
=	O
combination_defense	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
num_ko_halfeyes	int
==	O
1	int
)	O
{	O
int	O
result	int
;	O
int	O
apos	int
=	O
NO_MOVE	O
;	O
int	O
dpos	int
=	O
NO_MOVE	O
;	O
struct	O
eyevalue	struct
ko_value	struct
;	O
heye	int
[	O
ko_halfeye	int
]	O
.	O
type	char
=	O
0	int
;	O
result	int
=	O
recognize_eye	function
(	O
pos	int
,	O
&	O
apos	int
,	O
&	O
dpos	int
,	O
&	O
ko_value	struct
,	O
eye	array
,	O
heye	int
,	O
&	O
ko_vp	struct
)	O
;	O
heye	int
[	O
ko_halfeye	int
]	O
.	O
type	char
=	O
HALF_EYE	int
;	O
if	O
(	O
result	int
&&	O
max_eyes	function
(	O
value	pointer
)	O
<	O
max_eyes	function
(	O
&	O
ko_value	struct
)	O
)	O
{	O
*	O
value	pointer
=	O
ko_value	struct
;	O
*	O
attack_point	pointer
=	O
apos	int
;	O
*	O
defense_point	pointer
=	O
dpos	int
;	O
best_vp	pointer
=	O
&	O
ko_vp	struct
;	O
}	O
}	O
if	O
(	O
add_moves	int
)	O
{	O
struct	O
vital_eye_points	struct
*	O
vital	pointer
;	O
if	O
(	O
eye_color	int
==	O
WHITE	int
)	O
vital	pointer
=	O
white_vital_points	array
;	O
else	O
vital	pointer
=	O
black_vital_points	array
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
best_vp	pointer
->	O
num_defenses	int
&&	O
k	int
<	O
MAX_EYE_ATTACKS	int
;	O
k	int
++	O
)	O
vital	pointer
[	O
pos	int
]	O
.	O
defense_points	array
[	O
k	int
]	O
=	O
best_vp	pointer
->	O
defenses	array
[	O
k	int
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
best_vp	pointer
->	O
num_attacks	int
&&	O
k	int
<	O
MAX_EYE_ATTACKS	int
;	O
k	int
++	O
)	O
vital	pointer
[	O
pos	int
]	O
.	O
attack_points	array
[	O
k	int
]	O
=	O
best_vp	pointer
->	O
attacks	array
[	O
k	int
]	O
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
recognize_eye	function
(	O
int	O
pos	int
,	O
int	O
*	O
attack_point	pointer
,	O
int	O
*	O
defense_point	pointer
,	O
struct	O
eyevalue	struct
*	O
value	pointer
,	O
struct	O
eye_data	struct
eye	array
[	O
BOARDMAX	O
]	O
,	O
struct	O
half_eye_data	struct
heye	int
[	O
BOARDMAX	O
]	O
,	O
struct	O
vital_points	struct
*	O
vp	pointer
)	O
{	O
int	O
pos2	int
;	O
int	O
eye_color	int
;	O
int	O
eye_size	int
=	O
0	int
;	O
int	O
num_marginals	int
=	O
0	int
;	O
int	O
vpos	array
[	O
MAXEYE	int
]	O
;	O
signed	O
char	O
marginal	char
[	O
MAXEYE	int
]	O
,	O
edge	char
[	O
MAXEYE	int
]	O
,	O
neighbors	int
[	O
MAXEYE	int
]	O
;	O
int	O
graph	int
;	O
int	O
map	array
[	O
MAXEYE	int
]	O
;	O
int	O
best_score	int
;	O
int	O
r	int
;	O
gg_assert	O
(	O
attack_point	pointer
!=	O
NULL	O
)	O
;	O
gg_assert	O
(	O
defense_point	pointer
!=	O
NULL	O
)	O
;	O
eye_color	int
=	O
eye	array
[	O
pos	int
]	O
.	O
color	int
;	O
if	O
(	O
eye	array
[	O
pos	int
]	O
.	O
esize	int
-	O
eye	array
[	O
pos	int
]	O
.	O
msize	int
>	O
8	int
)	O
return	O
0	int
;	O
if	O
(	O
eye	array
[	O
pos	int
]	O
.	O
msize	int
>	O
MAXEYE	int
)	O
return	O
0	int
;	O
for	O
(	O
pos2	int
=	O
BOARDMIN	O
;	O
pos2	int
<	O
BOARDMAX	O
;	O
pos2	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos2	int
)	O
)	O
continue	O
;	O
if	O
(	O
eye	array
[	O
pos2	int
]	O
.	O
origin	int
==	O
pos	int
)	O
{	O
vpos	array
[	O
eye_size	int
]	O
=	O
pos2	int
;	O
marginal	char
[	O
eye_size	int
]	O
=	O
eye	array
[	O
pos2	int
]	O
.	O
marginal	char
;	O
if	O
(	O
marginal	char
[	O
eye_size	int
]	O
)	O
num_marginals	int
++	O
;	O
neighbors	int
[	O
eye_size	int
]	O
=	O
eye	array
[	O
pos2	int
]	O
.	O
neighbors	int
;	O
if	O
(	O
0	int
)	O
{	O
if	O
(	O
marginal	char
[	O
eye_size	int
]	O
)	O
TRACE	O
(	O
"(%1m)"	pointer
,	O
vpos	array
[	O
eye_size	int
]	O
)	O
;	O
else	O
TRACE	O
(	O
" %1m "	pointer
,	O
vpos	array
[	O
eye_size	int
]	O
)	O
;	O
TRACE	O
(	O
"\n"	pointer
)	O
;	O
}	O
if	O
(	O
is_corner_vertex	function
(	O
pos2	int
)	O
)	O
edge	char
[	O
eye_size	int
]	O
=	O
2	int
;	O
else	O
if	O
(	O
is_edge_vertex	function
(	O
pos2	int
)	O
)	O
edge	char
[	O
eye_size	int
]	O
=	O
1	int
;	O
else	O
edge	char
[	O
eye_size	int
]	O
=	O
0	int
;	O
if	O
(	O
is_halfeye	function
(	O
heye	int
,	O
pos2	int
)	O
)	O
{	O
neighbors	int
[	O
eye_size	int
]	O
++	O
;	O
eye_size	int
++	O
;	O
vpos	array
[	O
eye_size	int
]	O
=	O
NO_MOVE	O
;	O
marginal	char
[	O
eye_size	int
]	O
=	O
1	int
;	O
num_marginals	int
++	O
;	O
edge	char
[	O
eye_size	int
]	O
=	O
0	int
;	O
neighbors	int
[	O
eye_size	int
]	O
=	O
1	int
;	O
}	O
eye_size	int
++	O
;	O
}	O
}	O
for	O
(	O
graph	int
=	O
0	int
;	O
graphs	array
[	O
graph	int
]	O
.	O
vertex	pointer
!=	O
NULL	O
;	O
graph	int
++	O
)	O
{	O
int	O
q	pointer
;	O
if	O
(	O
graphs	array
[	O
graph	int
]	O
.	O
esize	int
!=	O
eye_size	int
||	O
graphs	array
[	O
graph	int
]	O
.	O
msize	int
!=	O
num_marginals	int
)	O
continue	O
;	O
reset_map	function
(	O
eye_size	int
)	O
;	O
q	pointer
=	O
0	int
;	O
first_map	function
(	O
&	O
map	array
[	O
0	int
]	O
)	O
;	O
while	O
(	O
1	int
)	O
{	O
struct	O
eye_vertex	struct
*	O
gv	pointer
=	O
&	O
graphs	array
[	O
graph	int
]	O
.	O
vertex	pointer
[	O
q	pointer
]	O
;	O
int	O
mv	int
=	O
map	array
[	O
q	pointer
]	O
;	O
int	O
ok	int
=	O
1	int
;	O
if	O
(	O
0	int
)	O
TRACE	O
(	O
"q=%d: %d %d %d %d %d %d\n"	pointer
,	O
q	pointer
,	O
map	array
[	O
0	int
]	O
,	O
map	array
[	O
1	int
]	O
,	O
map	array
[	O
2	int
]	O
,	O
map	array
[	O
3	int
]	O
,	O
map	array
[	O
4	int
]	O
,	O
map	array
[	O
5	int
]	O
)	O
;	O
if	O
(	O
neighbors	int
[	O
mv	int
]	O
!=	O
gv	pointer
->	O
neighbors	int
||	O
marginal	char
[	O
mv	int
]	O
!=	O
gv	pointer
->	O
marginal	char
||	O
edge	char
[	O
mv	int
]	O
<	O
gv	pointer
->	O
edge	char
)	O
ok	int
=	O
0	int
;	O
if	O
(	O
ok	int
)	O
{	O
if	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
vpos	array
[	O
mv	int
]	O
]	O
)	O
)	O
{	O
if	O
(	O
!	O
(	O
gv	pointer
->	O
flags	char
&	O
CAN_CONTAIN_STONE	int
)	O
)	O
ok	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
!	O
(	O
gv	pointer
->	O
flags	char
&	O
CAN_BE_EMPTY	int
)	O
)	O
ok	int
=	O
0	int
;	O
}	O
if	O
(	O
ok	int
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
gv	pointer
->	O
neighbors	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
gv	pointer
->	O
n	int
[	O
k	int
]	O
<	O
q	pointer
)	O
{	O
int	O
mn	int
=	O
map	array
[	O
gv	pointer
->	O
n	int
[	O
k	int
]	O
]	O
;	O
if	O
(	O
vpos	array
[	O
mv	int
]	O
!=	O
SOUTH	O
(	O
vpos	array
[	O
mn	int
]	O
)	O
&&	O
vpos	array
[	O
mv	int
]	O
!=	O
WEST	O
(	O
vpos	array
[	O
mn	int
]	O
)	O
&&	O
vpos	array
[	O
mv	int
]	O
!=	O
NORTH	O
(	O
vpos	array
[	O
mn	int
]	O
)	O
&&	O
vpos	array
[	O
mv	int
]	O
!=	O
EAST	O
(	O
vpos	array
[	O
mn	int
]	O
)	O
&&	O
(	O
mv	int
!=	O
mn	int
-	O
1	int
||	O
vpos	array
[	O
mv	int
]	O
==	O
NO_MOVE	O
||	O
heye	int
[	O
vpos	array
[	O
mv	int
]	O
]	O
.	O
type	char
!=	O
HALF_EYE	int
)	O
&&	O
(	O
mn	int
!=	O
mv	int
-	O
1	int
||	O
vpos	array
[	O
mn	int
]	O
==	O
NO_MOVE	O
||	O
heye	int
[	O
vpos	array
[	O
mn	int
]	O
]	O
.	O
type	char
!=	O
HALF_EYE	int
)	O
)	O
{	O
ok	int
=	O
0	int
;	O
break	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
!	O
ok	int
)	O
{	O
if	O
(	O
!	O
next_map	function
(	O
&	O
q	pointer
,	O
map	array
)	O
)	O
break	O
;	O
if	O
(	O
0	int
)	O
gprintf	function
(	O
"  q=%d, esize=%d: %d %d %d %d %d\n"	pointer
,	O
q	pointer
,	O
eye_size	int
,	O
map	array
[	O
0	int
]	O
,	O
map	array
[	O
1	int
]	O
,	O
map	array
[	O
2	int
]	O
,	O
map	array
[	O
3	int
]	O
,	O
map	array
[	O
4	int
]	O
)	O
;	O
}	O
else	O
{	O
q	pointer
++	O
;	O
if	O
(	O
q	pointer
==	O
eye_size	int
)	O
break	O
;	O
first_map	function
(	O
&	O
map	array
[	O
q	pointer
]	O
)	O
;	O
}	O
}	O
if	O
(	O
q	pointer
==	O
eye_size	int
)	O
{	O
*	O
value	pointer
=	O
graphs	array
[	O
graph	int
]	O
.	O
value	pointer
;	O
vp	pointer
->	O
num_attacks	int
=	O
0	int
;	O
vp	pointer
->	O
num_defenses	int
=	O
0	int
;	O
if	O
(	O
eye_move_urgency	function
(	O
value	pointer
)	O
>	O
0	int
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
eye_size	int
;	O
k	int
++	O
)	O
{	O
struct	O
eye_vertex	struct
*	O
ev	pointer
=	O
&	O
graphs	array
[	O
graph	int
]	O
.	O
vertex	pointer
[	O
k	int
]	O
;	O
if	O
(	O
ev	pointer
->	O
flags	char
&	O
EYE_ATTACK_POINT	int
)	O
{	O
if	O
(	O
ev	pointer
->	O
marginal	char
&&	O
map	array
[	O
k	int
]	O
>	O
0	int
&&	O
vpos	array
[	O
map	array
[	O
k	int
]	O
-	O
1	int
]	O
!=	O
NO_MOVE	O
&&	O
is_halfeye	function
(	O
heye	int
,	O
vpos	array
[	O
map	array
[	O
k	int
]	O
-	O
1	int
]	O
)	O
)	O
{	O
int	O
ix	int
;	O
struct	O
half_eye_data	struct
*	O
he	pointer
=	O
&	O
heye	int
[	O
vpos	array
[	O
map	array
[	O
k	int
]	O
-	O
1	int
]	O
]	O
;	O
for	O
(	O
ix	int
=	O
0	int
;	O
ix	int
<	O
he	pointer
->	O
num_attacks	int
;	O
ix	int
++	O
)	O
vp	pointer
->	O
attacks	array
[	O
vp	pointer
->	O
num_attacks	int
++	O
]	O
=	O
he	pointer
->	O
attack_point	pointer
[	O
ix	int
]	O
;	O
}	O
else	O
vp	pointer
->	O
attacks	array
[	O
vp	pointer
->	O
num_attacks	int
++	O
]	O
=	O
vpos	array
[	O
map	array
[	O
k	int
]	O
]	O
;	O
}	O
if	O
(	O
ev	pointer
->	O
flags	char
&	O
EYE_DEFENSE_POINT	int
)	O
{	O
if	O
(	O
ev	pointer
->	O
marginal	char
&&	O
map	array
[	O
k	int
]	O
>	O
0	int
&&	O
vpos	array
[	O
map	array
[	O
k	int
]	O
-	O
1	int
]	O
!=	O
NO_MOVE	O
&&	O
is_halfeye	function
(	O
heye	int
,	O
vpos	array
[	O
map	array
[	O
k	int
]	O
-	O
1	int
]	O
)	O
)	O
{	O
int	O
ix	int
;	O
struct	O
half_eye_data	struct
*	O
he	pointer
=	O
&	O
heye	int
[	O
vpos	array
[	O
map	array
[	O
k	int
]	O
-	O
1	int
]	O
]	O
;	O
for	O
(	O
ix	int
=	O
0	int
;	O
ix	int
<	O
he	pointer
->	O
num_defenses	int
;	O
ix	int
++	O
)	O
vp	pointer
->	O
defenses	array
[	O
vp	pointer
->	O
num_defenses	int
++	O
]	O
=	O
he	pointer
->	O
defense_point	pointer
[	O
ix	int
]	O
;	O
}	O
else	O
vp	pointer
->	O
defenses	array
[	O
vp	pointer
->	O
num_defenses	int
++	O
]	O
=	O
vpos	array
[	O
map	array
[	O
k	int
]	O
]	O
;	O
}	O
}	O
gg_assert	O
(	O
vp	pointer
->	O
num_attacks	int
>	O
0	int
&&	O
vp	pointer
->	O
num_defenses	int
>	O
0	int
)	O
;	O
best_score	int
=	O
-	O
10	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
vp	pointer
->	O
num_attacks	int
;	O
k	int
++	O
)	O
{	O
int	O
apos	int
=	O
vp	pointer
->	O
attacks	array
[	O
k	int
]	O
;	O
int	O
score	float
=	O
0	int
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
8	int
;	O
r	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
apos	int
+	O
delta	array
[	O
r	int
]	O
)	O
&&	O
eye	array
[	O
apos	int
+	O
delta	array
[	O
r	int
]	O
]	O
.	O
color	int
==	O
eye	array
[	O
pos	int
]	O
.	O
color	int
&&	O
!	O
eye	array
[	O
apos	int
+	O
delta	array
[	O
r	int
]	O
]	O
.	O
marginal	char
)	O
{	O
score	float
++	O
;	O
if	O
(	O
r	int
<	O
4	int
)	O
{	O
score	float
++	O
;	O
if	O
(	O
board	pointer
[	O
apos	int
+	O
delta	array
[	O
r	int
]	O
]	O
!=	O
EMPTY	int
)	O
score	float
++	O
;	O
}	O
}	O
if	O
(	O
score	float
==	O
0	int
)	O
score	float
+=	O
2	int
;	O
if	O
(	O
0	int
)	O
gprintf	function
(	O
"attack point %1m score %d\n"	pointer
,	O
apos	int
,	O
score	float
)	O
;	O
if	O
(	O
score	float
>	O
best_score	int
)	O
{	O
*	O
attack_point	pointer
=	O
apos	int
;	O
best_score	int
=	O
score	float
;	O
}	O
}	O
best_score	int
=	O
-	O
10	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
vp	pointer
->	O
num_defenses	int
;	O
k	int
++	O
)	O
{	O
int	O
dpos	int
=	O
vp	pointer
->	O
defenses	array
[	O
k	int
]	O
;	O
int	O
score	float
=	O
0	int
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
8	int
;	O
r	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
dpos	int
+	O
delta	array
[	O
r	int
]	O
)	O
&&	O
eye	array
[	O
dpos	int
+	O
delta	array
[	O
r	int
]	O
]	O
.	O
color	int
==	O
eye	array
[	O
pos	int
]	O
.	O
color	int
&&	O
!	O
eye	array
[	O
dpos	int
+	O
delta	array
[	O
r	int
]	O
]	O
.	O
marginal	char
)	O
{	O
score	float
++	O
;	O
if	O
(	O
r	int
<	O
4	int
)	O
{	O
score	float
++	O
;	O
if	O
(	O
board	pointer
[	O
dpos	int
+	O
delta	array
[	O
r	int
]	O
]	O
!=	O
EMPTY	int
)	O
score	float
++	O
;	O
}	O
}	O
if	O
(	O
safe_move	function
(	O
dpos	int
,	O
eye_color	int
)	O
!=	O
WIN	int
)	O
score	float
-=	O
5	int
;	O
if	O
(	O
score	float
==	O
0	int
)	O
score	float
+=	O
2	int
;	O
if	O
(	O
0	int
)	O
gprintf	function
(	O
"defense point %1m score %d\n"	pointer
,	O
dpos	int
,	O
score	float
)	O
;	O
if	O
(	O
score	float
>	O
best_score	int
)	O
{	O
*	O
defense_point	pointer
=	O
dpos	int
;	O
best_score	int
=	O
score	float
;	O
}	O
}	O
DEBUG	O
(	O
DEBUG_EYES	int
,	O
"  vital points: %1m (attack) %1m (defense)\n"	pointer
,	O
*	O
attack_point	pointer
,	O
*	O
defense_point	pointer
)	O
;	O
DEBUG	O
(	O
DEBUG_EYES	int
,	O
"  pattern matched:  %d\n"	pointer
,	O
graphs	array
[	O
graph	int
]	O
.	O
patnum	int
)	O
;	O
}	O
TRACE	O
(	O
"eye space at %1m of type %d\n"	pointer
,	O
pos	int
,	O
graphs	array
[	O
graph	int
]	O
.	O
patnum	int
)	O
;	O
return	O
eye_color	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
reset_map	function
(	O
int	O
size	int
)	O
{	O
map_size	int
=	O
size	int
;	O
memset	function
(	O
used_index	array
,	O
0	int
,	O
size	int
*	O
sizeof	O
(	O
used_index	array
[	O
0	int
]	O
)	O
)	O
;	O
}	O
static	O
void	O
first_map	function
(	O
int	O
*	O
map_value	pointer
)	O
{	O
int	O
k	int
=	O
0	int
;	O
while	O
(	O
used_index	array
[	O
k	int
]	O
)	O
k	int
++	O
;	O
used_index	array
[	O
k	int
]	O
=	O
1	int
;	O
*	O
map_value	pointer
=	O
k	int
;	O
}	O
static	O
int	O
next_map	function
(	O
int	O
*	O
q	pointer
,	O
int	O
map	array
[	O
MAXEYE	int
]	O
)	O
{	O
int	O
k	int
;	O
do	O
{	O
used_index	array
[	O
map	array
[	O
*	O
q	pointer
]	O
]	O
=	O
0	int
;	O
for	O
(	O
k	int
=	O
map	array
[	O
*	O
q	pointer
]	O
;	O
++	O
k	int
<	O
map_size	int
;	O
)	O
{	O
if	O
(	O
!	O
used_index	array
[	O
k	int
]	O
)	O
{	O
used_index	array
[	O
k	int
]	O
=	O
1	int
;	O
map	array
[	O
*	O
q	pointer
]	O
=	O
k	int
;	O
return	O
1	int
;	O
}	O
}	O
(	O
*	O
q	pointer
)	O
--	O
;	O
}	O
while	O
(	O
*	O
q	pointer
>=	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
add_false_eye	function
(	O
int	O
pos	int
,	O
struct	O
eye_data	struct
eye	array
[	O
BOARDMAX	O
]	O
,	O
struct	O
half_eye_data	struct
heye	int
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
k	int
;	O
ASSERT1	O
(	O
heye	int
[	O
pos	int
]	O
.	O
type	char
==	O
FALSE_EYE	int
,	O
pos	int
)	O
;	O
DEBUG	O
(	O
DEBUG_EYES	int
,	O
"false eye found at %1m\n"	pointer
,	O
pos	int
)	O
;	O
if	O
(	O
eye	array
[	O
pos	int
]	O
.	O
color	int
==	O
GRAY	int
||	O
eye	array
[	O
pos	int
]	O
.	O
marginal	char
!=	O
0	int
)	O
return	O
;	O
eye	array
[	O
pos	int
]	O
.	O
marginal	char
=	O
1	int
;	O
eye	array
[	O
eye	array
[	O
pos	int
]	O
.	O
origin	int
]	O
.	O
msize	int
++	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
+	O
delta	array
[	O
k	int
]	O
)	O
&&	O
eye	array
[	O
pos	int
+	O
delta	array
[	O
k	int
]	O
]	O
.	O
origin	int
==	O
eye	array
[	O
pos	int
]	O
.	O
origin	int
)	O
eye	array
[	O
pos	int
+	O
delta	array
[	O
k	int
]	O
]	O
.	O
marginal_neighbors	char
++	O
;	O
propagate_eye	function
(	O
eye	array
[	O
pos	int
]	O
.	O
origin	int
,	O
eye	array
)	O
;	O
}	O
int	O
is_eye_space	function
(	O
int	O
pos	int
)	O
{	O
return	O
(	O
white_eye	array
[	O
pos	int
]	O
.	O
color	int
==	O
WHITE	int
||	O
black_eye	array
[	O
pos	int
]	O
.	O
color	int
==	O
BLACK	int
)	O
;	O
}	O
int	O
is_proper_eye_space	function
(	O
int	O
pos	int
)	O
{	O
return	O
(	O
(	O
white_eye	array
[	O
pos	int
]	O
.	O
color	int
==	O
WHITE	int
&&	O
!	O
white_eye	array
[	O
pos	int
]	O
.	O
marginal	char
)	O
||	O
(	O
black_eye	array
[	O
pos	int
]	O
.	O
color	int
==	O
BLACK	int
&&	O
!	O
black_eye	array
[	O
pos	int
]	O
.	O
marginal	char
)	O
)	O
;	O
}	O
int	O
max_eye_value	function
(	O
int	O
pos	int
)	O
{	O
int	O
max_white	int
=	O
0	int
;	O
int	O
max_black	int
=	O
0	int
;	O
if	O
(	O
white_eye	array
[	O
pos	int
]	O
.	O
color	int
==	O
WHITE	int
)	O
max_white	int
=	O
max_eyes	function
(	O
&	O
white_eye	array
[	O
pos	int
]	O
.	O
value	pointer
)	O
;	O
if	O
(	O
black_eye	array
[	O
pos	int
]	O
.	O
color	int
==	O
BLACK	int
)	O
max_black	int
=	O
max_eyes	function
(	O
&	O
black_eye	array
[	O
pos	int
]	O
.	O
value	pointer
)	O
;	O
return	O
gg_max	O
(	O
max_white	int
,	O
max_black	int
)	O
;	O
}	O
int	O
is_marginal_eye_space	function
(	O
int	O
pos	int
)	O
{	O
return	O
(	O
white_eye	array
[	O
pos	int
]	O
.	O
marginal	char
||	O
black_eye	array
[	O
pos	int
]	O
.	O
marginal	char
)	O
;	O
}	O
int	O
is_halfeye	function
(	O
struct	O
half_eye_data	struct
heye	int
[	O
BOARDMAX	O
]	O
,	O
int	O
pos	int
)	O
{	O
return	O
heye	int
[	O
pos	int
]	O
.	O
type	char
==	O
HALF_EYE	int
;	O
}	O
int	O
is_false_eye	function
(	O
struct	O
half_eye_data	struct
heye	int
[	O
BOARDMAX	O
]	O
,	O
int	O
pos	int
)	O
{	O
return	O
heye	int
[	O
pos	int
]	O
.	O
type	char
==	O
FALSE_EYE	int
;	O
}	O
void	O
find_half_and_false_eyes	function
(	O
int	O
color	int
,	O
struct	O
eye_data	struct
eye	array
[	O
BOARDMAX	O
]	O
,	O
struct	O
half_eye_data	struct
heye	int
[	O
BOARDMAX	O
]	O
,	O
int	O
find_mask	array
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
eye_color	int
=	O
color	int
;	O
int	O
pos	int
;	O
float	O
sum	pointer
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
||	O
(	O
find_mask	array
&&	O
find_mask	array
[	O
eye	array
[	O
pos	int
]	O
.	O
origin	int
]	O
<=	O
1	int
)	O
)	O
continue	O
;	O
if	O
(	O
eye	array
[	O
pos	int
]	O
.	O
color	int
!=	O
eye_color	int
||	O
eye	array
[	O
pos	int
]	O
.	O
marginal	char
||	O
eye	array
[	O
pos	int
]	O
.	O
neighbors	int
>	O
1	int
)	O
continue	O
;	O
sum	pointer
=	O
topological_eye	function
(	O
pos	int
,	O
color	int
,	O
eye	array
,	O
heye	int
)	O
;	O
if	O
(	O
sum	pointer
>=	O
4.0	int
)	O
{	O
heye	int
[	O
pos	int
]	O
.	O
type	char
=	O
FALSE_EYE	int
;	O
if	O
(	O
eye	array
[	O
pos	int
]	O
.	O
esize	int
==	O
1	int
||	O
is_legal	function
(	O
pos	int
,	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
||	O
board	pointer
[	O
pos	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
add_false_eye	function
(	O
pos	int
,	O
eye	array
,	O
heye	int
)	O
;	O
}	O
else	O
if	O
(	O
sum	pointer
>	O
2.0	int
)	O
{	O
heye	int
[	O
pos	int
]	O
.	O
type	char
=	O
HALF_EYE	int
;	O
ASSERT1	O
(	O
heye	int
[	O
pos	int
]	O
.	O
num_attacks	int
>	O
0	int
,	O
pos	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
heye	int
[	O
pos	int
]	O
.	O
attack_point	pointer
[	O
0	int
]	O
)	O
;	O
ASSERT1	O
(	O
heye	int
[	O
pos	int
]	O
.	O
num_defenses	int
>	O
0	int
,	O
pos	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
heye	int
[	O
pos	int
]	O
.	O
defense_point	pointer
[	O
0	int
]	O
)	O
;	O
}	O
}	O
}	O
static	O
float	O
topological_eye	function
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
struct	O
eye_data	struct
my_eye	array
[	O
BOARDMAX	O
]	O
,	O
struct	O
half_eye_data	struct
heye	int
[	O
BOARDMAX	O
]	O
)	O
{	O
float	O
sum	pointer
=	O
0.0	int
;	O
float	O
val	long
;	O
int	O
num_attacks	int
=	O
0	int
;	O
int	O
num_defenses	int
=	O
0	int
;	O
int	O
attack_values	array
[	O
4	int
]	O
;	O
int	O
defense_values	array
[	O
4	int
]	O
;	O
int	O
k	int
;	O
int	O
r	int
;	O
int	O
attack_point	pointer
;	O
int	O
defense_point	pointer
;	O
int	O
attack_value	int
;	O
int	O
defense_value	int
;	O
memset	function
(	O
attack_values	array
,	O
0	int
,	O
sizeof	O
(	O
attack_values	array
)	O
)	O
;	O
memset	function
(	O
defense_values	array
,	O
0	int
,	O
sizeof	O
(	O
defense_values	array
)	O
)	O
;	O
for	O
(	O
k	int
=	O
4	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
{	O
int	O
diag	int
=	O
pos	int
+	O
delta	array
[	O
k	int
]	O
;	O
val	long
=	O
evaluate_diagonal_intersection	function
(	O
I	O
(	O
pos	int
)	O
+	O
deltai	array
[	O
k	int
]	O
,	O
J	O
(	O
pos	int
)	O
+	O
deltaj	array
[	O
k	int
]	O
,	O
color	int
,	O
&	O
attack_point	pointer
,	O
&	O
defense_point	pointer
,	O
my_eye	array
)	O
;	O
if	O
(	O
val	long
<	O
2.0	int
&&	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
diag	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
&&	O
!	O
is_edge_vertex	function
(	O
pos	int
)	O
&&	O
neighbor_of_string	function
(	O
pos	int
,	O
diag	int
)	O
&&	O
countstones	function
(	O
diag	int
)	O
>=	O
3	int
)	O
{	O
int	O
strings	array
[	O
3	int
]	O
;	O
int	O
string_count	int
;	O
int	O
s	int
;	O
string_count	int
=	O
0	int
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
4	int
;	O
r	int
++	O
)	O
{	O
int	O
str	int
;	O
str	int
=	O
pos	int
+	O
delta	array
[	O
r	int
]	O
;	O
if	O
(	O
board	pointer
[	O
str	int
]	O
!=	O
color	int
)	O
continue	O
;	O
ASSERT1	O
(	O
string_count	int
<	O
3	int
,	O
pos	int
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
string_count	int
;	O
s	int
++	O
)	O
if	O
(	O
same_string	function
(	O
str	int
,	O
strings	array
[	O
s	int
]	O
)	O
)	O
break	O
;	O
if	O
(	O
s	int
!=	O
string_count	int
)	O
continue	O
;	O
strings	array
[	O
string_count	int
++	O
]	O
=	O
str	int
;	O
}	O
if	O
(	O
string_count	int
>	O
1	int
)	O
{	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
string_count	int
;	O
s	int
++	O
)	O
{	O
int	O
libs	pointer
[	O
MAX_LIBERTIES	int
]	O
;	O
int	O
adj_eye_count	int
;	O
int	O
lib_count	int
;	O
adj_eye_count	int
=	O
0	int
;	O
lib_count	int
=	O
findlib	function
(	O
strings	array
[	O
s	int
]	O
,	O
MAX_LIBERTIES	int
,	O
libs	pointer
)	O
;	O
if	O
(	O
lib_count	int
>	O
MAX_LIBERTIES	int
)	O
continue	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
lib_count	int
&&	O
adj_eye_count	int
<	O
2	int
;	O
r	int
++	O
)	O
if	O
(	O
my_eye	array
[	O
libs	pointer
[	O
r	int
]	O
]	O
.	O
color	int
==	O
OTHER_COLOR	O
(	O
color	int
)	O
&&	O
!	O
my_eye	array
[	O
libs	pointer
[	O
r	int
]	O
]	O
.	O
marginal	char
)	O
adj_eye_count	int
++	O
;	O
if	O
(	O
adj_eye_count	int
<	O
2	int
)	O
{	O
val	long
=	O
2.0	int
;	O
break	O
;	O
}	O
}	O
}	O
}	O
sum	pointer
+=	O
val	long
;	O
if	O
(	O
val	long
>	O
0.0	int
&&	O
val	long
<	O
2.0	int
)	O
{	O
if	O
(	O
attack_point	pointer
!=	O
NO_MOVE	O
&&	O
defense_point	pointer
!=	O
NO_MOVE	O
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
attack_point	pointer
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
defense_point	pointer
)	O
;	O
if	O
(	O
val	long
==	O
1.0	int
)	O
{	O
attack_value	int
=	O
3	int
;	O
defense_value	int
=	O
3	int
;	O
}	O
else	O
if	O
(	O
val	long
<	O
1.0	int
)	O
{	O
attack_value	int
=	O
2	int
;	O
defense_value	int
=	O
1	int
;	O
}	O
else	O
{	O
attack_value	int
=	O
1	int
;	O
defense_value	int
=	O
2	int
;	O
}	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
4	int
;	O
r	int
++	O
)	O
{	O
if	O
(	O
attack_values	array
[	O
r	int
]	O
<	O
attack_value	int
)	O
{	O
int	O
tmp_value	int
=	O
attack_values	array
[	O
r	int
]	O
;	O
int	O
tmp_point	int
;	O
if	O
(	O
tmp_value	int
)	O
tmp_point	int
=	O
heye	int
[	O
pos	int
]	O
.	O
attack_point	pointer
[	O
r	int
]	O
;	O
else	O
tmp_point	int
=	O
0	int
;	O
attack_values	array
[	O
r	int
]	O
=	O
attack_value	int
;	O
heye	int
[	O
pos	int
]	O
.	O
attack_point	pointer
[	O
r	int
]	O
=	O
attack_point	pointer
;	O
attack_value	int
=	O
tmp_value	int
;	O
attack_point	pointer
=	O
tmp_point	int
;	O
}	O
if	O
(	O
defense_values	array
[	O
r	int
]	O
<	O
defense_value	int
)	O
{	O
int	O
tmp_value	int
=	O
defense_values	array
[	O
r	int
]	O
;	O
int	O
tmp_point	int
;	O
if	O
(	O
tmp_value	int
)	O
tmp_point	int
=	O
heye	int
[	O
pos	int
]	O
.	O
defense_point	pointer
[	O
r	int
]	O
;	O
else	O
tmp_point	int
=	O
0	int
;	O
defense_values	array
[	O
r	int
]	O
=	O
defense_value	int
;	O
heye	int
[	O
pos	int
]	O
.	O
defense_point	pointer
[	O
r	int
]	O
=	O
defense_point	pointer
;	O
defense_value	int
=	O
tmp_value	int
;	O
defense_point	pointer
=	O
tmp_point	int
;	O
}	O
}	O
num_attacks	int
++	O
;	O
num_defenses	int
++	O
;	O
}	O
}	O
}	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
num_attacks	int
;	O
r	int
++	O
)	O
{	O
if	O
(	O
attack_values	array
[	O
r	int
]	O
<	O
attack_values	array
[	O
0	int
]	O
)	O
{	O
num_attacks	int
=	O
r	int
;	O
break	O
;	O
}	O
}	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
num_defenses	int
;	O
r	int
++	O
)	O
{	O
if	O
(	O
defense_values	array
[	O
r	int
]	O
<	O
defense_values	array
[	O
0	int
]	O
)	O
{	O
num_defenses	int
=	O
r	int
;	O
break	O
;	O
}	O
}	O
heye	int
[	O
pos	int
]	O
.	O
num_attacks	int
=	O
num_attacks	int
;	O
heye	int
[	O
pos	int
]	O
.	O
num_defenses	int
=	O
num_defenses	int
;	O
heye	int
[	O
pos	int
]	O
.	O
value	pointer
=	O
sum	pointer
;	O
return	O
sum	pointer
;	O
}	O
static	O
float	O
evaluate_diagonal_intersection	function
(	O
int	O
m	int
,	O
int	O
n	int
,	O
int	O
color	int
,	O
int	O
*	O
attack_point	pointer
,	O
int	O
*	O
defense_point	pointer
,	O
struct	O
eye_data	struct
my_eye	array
[	O
BOARDMAX	O
]	O
)	O
{	O
float	O
value	pointer
=	O
0	int
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
pos	int
=	O
POS	O
(	O
m	int
,	O
n	int
)	O
;	O
int	O
acode	int
=	O
0	int
;	O
int	O
apos	int
=	O
NO_MOVE	O
;	O
int	O
dcode	int
=	O
0	int
;	O
int	O
dpos	int
=	O
NO_MOVE	O
;	O
int	O
off_edge	int
=	O
0	int
;	O
const	O
float	O
a	char
=	O
0.75	int
;	O
const	O
float	O
b	char
=	O
2	int
-	O
a	char
;	O
*	O
attack_point	pointer
=	O
NO_MOVE	O
;	O
*	O
defense_point	pointer
=	O
NO_MOVE	O
;	O
if	O
(	O
m	int
<	O
0	int
||	O
m	int
>=	O
board_size	int
)	O
off_edge	int
++	O
;	O
if	O
(	O
n	int
<	O
0	int
||	O
n	int
>=	O
board_size	int
)	O
off_edge	int
++	O
;	O
if	O
(	O
off_edge	int
>	O
0	int
)	O
return	O
(	O
float	O
)	O
(	O
off_edge	int
%	O
2	int
)	O
;	O
if	O
(	O
my_eye	array
[	O
pos	int
]	O
.	O
color	int
==	O
color	int
&&	O
!	O
my_eye	array
[	O
pos	int
]	O
.	O
marginal	char
&&	O
my_eye	array
[	O
pos	int
]	O
.	O
marginal_neighbors	char
<	O
2	int
&&	O
!	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
&&	O
does_capture_something	function
(	O
pos	int
,	O
other	int
)	O
)	O
)	O
return	O
0.0	int
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
{	O
int	O
your_safety	int
=	O
safe_move	function
(	O
pos	int
,	O
other	int
)	O
;	O
apos	int
=	O
pos	int
;	O
dpos	int
=	O
pos	int
;	O
if	O
(	O
your_safety	int
==	O
0	int
)	O
value	pointer
=	O
0.0	int
;	O
else	O
if	O
(	O
your_safety	int
!=	O
WIN	int
)	O
value	pointer
=	O
a	char
;	O
else	O
{	O
int	O
our_safety	int
=	O
safe_move	function
(	O
pos	int
,	O
color	int
)	O
;	O
if	O
(	O
our_safety	int
==	O
0	int
)	O
{	O
int	O
k	int
;	O
value	pointer
=	O
2.0	int
;	O
for	O
(	O
k	int
=	O
4	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
{	O
int	O
diagonal	int
=	O
pos	int
+	O
delta	array
[	O
k	int
]	O
;	O
int	O
lib	int
;	O
if	O
(	O
board	pointer
[	O
diagonal	int
]	O
==	O
other	int
&&	O
findlib	function
(	O
diagonal	int
,	O
1	int
,	O
&	O
lib	int
)	O
==	O
1	int
)	O
{	O
if	O
(	O
lib	int
!=	O
pos	int
&&	O
does_secure	function
(	O
color	int
,	O
lib	int
,	O
pos	int
)	O
)	O
{	O
value	pointer
=	O
1.0	int
;	O
apos	int
=	O
lib	int
;	O
break	O
;	O
}	O
}	O
}	O
}	O
else	O
if	O
(	O
our_safety	int
==	O
WIN	int
)	O
value	pointer
=	O
1.0	int
;	O
else	O
value	pointer
=	O
b	char
;	O
}	O
}	O
else	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
color	int
)	O
{	O
value	pointer
=	O
0.0	int
;	O
}	O
else	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
other	int
)	O
{	O
if	O
(	O
stackp	int
==	O
0	int
)	O
{	O
acode	int
=	O
worm	array
[	O
pos	int
]	O
.	O
attack_codes	array
[	O
0	int
]	O
;	O
apos	int
=	O
worm	array
[	O
pos	int
]	O
.	O
attack_points	array
[	O
0	int
]	O
;	O
dcode	int
=	O
worm	array
[	O
pos	int
]	O
.	O
defense_codes	array
[	O
0	int
]	O
;	O
dpos	int
=	O
worm	array
[	O
pos	int
]	O
.	O
defense_points	array
[	O
0	int
]	O
;	O
}	O
else	O
attack_and_defend	function
(	O
pos	int
,	O
&	O
acode	int
,	O
&	O
apos	int
,	O
&	O
dcode	int
,	O
&	O
dpos	int
)	O
;	O
if	O
(	O
acode	int
==	O
0	int
)	O
value	pointer
=	O
2.0	int
;	O
else	O
if	O
(	O
dcode	int
==	O
0	int
)	O
value	pointer
=	O
0.0	int
;	O
else	O
if	O
(	O
acode	int
==	O
WIN	int
&&	O
dcode	int
==	O
WIN	int
)	O
value	pointer
=	O
1.0	int
;	O
else	O
if	O
(	O
acode	int
==	O
WIN	int
&&	O
dcode	int
!=	O
WIN	int
)	O
value	pointer
=	O
a	char
;	O
else	O
if	O
(	O
acode	int
!=	O
WIN	int
&&	O
dcode	int
==	O
WIN	int
)	O
value	pointer
=	O
b	char
;	O
else	O
if	O
(	O
acode	int
!=	O
WIN	int
&&	O
dcode	int
!=	O
WIN	int
)	O
value	pointer
=	O
1.0	int
;	O
}	O
if	O
(	O
value	pointer
>	O
0.0	int
&&	O
value	pointer
<	O
2.0	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
apos	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
dpos	int
)	O
;	O
*	O
attack_point	pointer
=	O
dpos	int
;	O
*	O
defense_point	pointer
=	O
apos	int
;	O
}	O
return	O
value	pointer
;	O
}	O
int	O
obvious_false_eye	function
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
int	O
i	int
=	O
I	O
(	O
pos	int
)	O
;	O
int	O
j	int
=	O
J	O
(	O
pos	int
)	O
;	O
int	O
k	int
;	O
int	O
diagonal_sum	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
4	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
{	O
int	O
di	int
=	O
deltai	array
[	O
k	int
]	O
;	O
int	O
dj	int
=	O
deltaj	array
[	O
k	int
]	O
;	O
if	O
(	O
!	O
ON_BOARD2	O
(	O
i	int
+	O
di	int
,	O
j	int
)	O
&&	O
!	O
ON_BOARD2	O
(	O
i	int
,	O
j	int
+	O
dj	int
)	O
)	O
diagonal_sum	int
--	O
;	O
if	O
(	O
!	O
ON_BOARD2	O
(	O
i	int
+	O
di	int
,	O
j	int
+	O
dj	int
)	O
)	O
diagonal_sum	int
++	O
;	O
else	O
if	O
(	O
BOARD	O
(	O
i	int
+	O
di	int
,	O
j	int
+	O
dj	int
)	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
&&	O
!	O
attack	function
(	O
POS	O
(	O
i	int
+	O
di	int
,	O
j	int
+	O
dj	int
)	O
,	O
NULL	O
)	O
)	O
diagonal_sum	int
+=	O
2	int
;	O
}	O
return	O
diagonal_sum	int
>=	O
4	int
;	O
}	O
void	O
set_eyevalue	function
(	O
struct	O
eyevalue	struct
*	O
e	pointer
,	O
int	O
a	char
,	O
int	O
b	char
,	O
int	O
c	char
,	O
int	O
d	int
)	O
{	O
e	pointer
->	O
a	char
=	O
a	char
;	O
e	pointer
->	O
b	char
=	O
b	char
;	O
e	pointer
->	O
c	char
=	O
c	char
;	O
e	pointer
->	O
d	int
=	O
d	int
;	O
}	O
int	O
min_eye_threat	function
(	O
struct	O
eyevalue	struct
*	O
e	pointer
)	O
{	O
return	O
e	pointer
->	O
a	char
;	O
}	O
int	O
min_eyes	function
(	O
struct	O
eyevalue	struct
*	O
e	pointer
)	O
{	O
return	O
e	pointer
->	O
b	char
;	O
}	O
int	O
max_eyes	function
(	O
struct	O
eyevalue	struct
*	O
e	pointer
)	O
{	O
return	O
e	pointer
->	O
c	char
;	O
}	O
int	O
max_eye_threat	function
(	O
struct	O
eyevalue	struct
*	O
e	pointer
)	O
{	O
return	O
e	pointer
->	O
d	int
;	O
}	O
void	O
add_eyevalues	function
(	O
struct	O
eyevalue	struct
*	O
e1	pointer
,	O
struct	O
eyevalue	struct
*	O
e2	pointer
,	O
struct	O
eyevalue	struct
*	O
sum	pointer
)	O
{	O
struct	O
eyevalue	struct
res	struct
;	O
res	struct
.	O
a	char
=	O
gg_min	O
(	O
gg_min	O
(	O
e1	pointer
->	O
a	char
+	O
e2	pointer
->	O
c	char
,	O
e1	pointer
->	O
c	char
+	O
e2	pointer
->	O
a	char
)	O
,	O
gg_max	O
(	O
e1	pointer
->	O
a	char
+	O
e2	pointer
->	O
b	char
,	O
e1	pointer
->	O
b	char
+	O
e2	pointer
->	O
a	char
)	O
)	O
;	O
res	struct
.	O
b	char
=	O
gg_min	O
(	O
gg_max	O
(	O
e1	pointer
->	O
b	char
+	O
e2	pointer
->	O
b	char
,	O
gg_min	O
(	O
e1	pointer
->	O
a	char
+	O
e2	pointer
->	O
d	int
,	O
e1	pointer
->	O
b	char
+	O
e2	pointer
->	O
c	char
)	O
)	O
,	O
gg_max	O
(	O
e1	pointer
->	O
b	char
+	O
e2	pointer
->	O
b	char
,	O
gg_min	O
(	O
e1	pointer
->	O
d	int
+	O
e2	pointer
->	O
a	char
,	O
e1	pointer
->	O
c	char
+	O
e2	pointer
->	O
b	char
)	O
)	O
)	O
;	O
res	struct
.	O
c	char
=	O
gg_max	O
(	O
gg_min	O
(	O
e1	pointer
->	O
c	char
+	O
e2	pointer
->	O
c	char
,	O
gg_max	O
(	O
e1	pointer
->	O
d	int
+	O
e2	pointer
->	O
a	char
,	O
e1	pointer
->	O
c	char
+	O
e2	pointer
->	O
b	char
)	O
)	O
,	O
gg_min	O
(	O
e1	pointer
->	O
c	char
+	O
e2	pointer
->	O
c	char
,	O
gg_max	O
(	O
e1	pointer
->	O
a	char
+	O
e2	pointer
->	O
d	int
,	O
e1	pointer
->	O
b	char
+	O
e2	pointer
->	O
c	char
)	O
)	O
)	O
;	O
res	struct
.	O
d	int
=	O
gg_max	O
(	O
gg_max	O
(	O
e1	pointer
->	O
d	int
+	O
e2	pointer
->	O
b	char
,	O
e1	pointer
->	O
b	char
+	O
e2	pointer
->	O
d	int
)	O
,	O
gg_min	O
(	O
e1	pointer
->	O
d	int
+	O
e2	pointer
->	O
c	char
,	O
e1	pointer
->	O
c	char
+	O
e2	pointer
->	O
d	int
)	O
)	O
;	O
if	O
(	O
(	O
e1	pointer
->	O
d	int
-	O
e1	pointer
->	O
c	char
==	O
2	int
&&	O
e2	pointer
->	O
c	char
-	O
e2	pointer
->	O
b	char
==	O
1	int
)	O
||	O
(	O
e1	pointer
->	O
c	char
-	O
e1	pointer
->	O
b	char
==	O
1	int
&&	O
e2	pointer
->	O
d	int
-	O
e2	pointer
->	O
c	char
==	O
2	int
)	O
)	O
{	O
res	struct
.	O
d	int
=	O
gg_max	O
(	O
gg_min	O
(	O
e1	pointer
->	O
c	char
+	O
e2	pointer
->	O
d	int
,	O
e1	pointer
->	O
d	int
+	O
e2	pointer
->	O
b	char
)	O
,	O
gg_min	O
(	O
e1	pointer
->	O
d	int
+	O
e2	pointer
->	O
c	char
,	O
e1	pointer
->	O
b	char
+	O
e2	pointer
->	O
d	int
)	O
)	O
;	O
}	O
sum	pointer
->	O
a	char
=	O
res	struct
.	O
a	char
;	O
sum	pointer
->	O
b	char
=	O
res	struct
.	O
b	char
;	O
sum	pointer
->	O
c	char
=	O
res	struct
.	O
c	char
;	O
sum	pointer
->	O
d	int
=	O
res	struct
.	O
d	int
;	O
}	O
int	O
eye_move_urgency	function
(	O
struct	O
eyevalue	struct
*	O
e	pointer
)	O
{	O
int	O
a	char
=	O
gg_min	O
(	O
e	pointer
->	O
a	char
,	O
2	int
)	O
;	O
int	O
b	char
=	O
gg_min	O
(	O
e	pointer
->	O
b	char
,	O
2	int
)	O
;	O
int	O
c	char
=	O
gg_min	O
(	O
e	pointer
->	O
c	char
,	O
2	int
)	O
;	O
int	O
d	int
=	O
gg_min	O
(	O
e	pointer
->	O
d	int
,	O
2	int
)	O
;	O
if	O
(	O
b	char
==	O
c	char
)	O
return	O
0	int
;	O
else	O
return	O
d	int
+	O
c	char
-	O
b	char
-	O
a	char
;	O
}	O
char	O
*	O
eyevalue_to_string	function
(	O
struct	O
eyevalue	struct
*	O
e	pointer
)	O
{	O
static	O
char	O
result	int
[	O
30	int
]	O
;	O
if	O
(	O
e	pointer
->	O
a	char
<	O
10	int
&&	O
e	pointer
->	O
b	char
<	O
10	int
&&	O
e	pointer
->	O
c	char
<	O
10	int
&&	O
e	pointer
->	O
d	int
<	O
10	int
)	O
gg_snprintf	function
(	O
result	int
,	O
29	int
,	O
"%d%d%d%d"	pointer
,	O
e	pointer
->	O
a	char
,	O
e	pointer
->	O
b	char
,	O
e	pointer
->	O
c	char
,	O
e	pointer
->	O
d	int
)	O
;	O
else	O
gg_snprintf	function
(	O
result	int
,	O
29	int
,	O
"[%d,%d,%d,%d]"	pointer
,	O
e	pointer
->	O
a	char
,	O
e	pointer
->	O
b	char
,	O
e	pointer
->	O
c	char
,	O
e	pointer
->	O
d	int
)	O
;	O
return	O
result	int
;	O
}	O
void	O
test_eyeshape	function
(	O
int	O
eyesize	int
,	O
int	O
*	O
eye_vertices	pointer
)	O
{	O
int	O
k	int
;	O
int	O
n	int
,	O
N	int
;	O
int	O
mx	array
[	O
BOARDMAX	O
]	O
;	O
int	O
pos	int
;	O
int	O
str	int
=	O
NO_MOVE	O
;	O
int	O
attack_code	pointer
;	O
int	O
attack_point	pointer
;	O
int	O
defense_code	int
;	O
int	O
defense_point	pointer
;	O
int	O
save_verbose	int
;	O
struct	O
board_state	struct
starting_position	struct
;	O
clear_board	function
(	O
)	O
;	O
reset_engine	function
(	O
)	O
;	O
memset	function
(	O
mx	array
,	O
0	int
,	O
sizeof	O
(	O
mx	array
)	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
eyesize	int
;	O
k	int
++	O
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
eye_vertices	pointer
[	O
k	int
]	O
)	O
;	O
mx	array
[	O
eye_vertices	pointer
[	O
k	int
]	O
]	O
=	O
1	int
;	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
||	O
mx	array
[	O
pos	int
]	O
==	O
1	int
)	O
continue	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
+	O
delta	array
[	O
k	int
]	O
)	O
&&	O
mx	array
[	O
pos	int
+	O
delta	array
[	O
k	int
]	O
]	O
==	O
1	int
)	O
{	O
play_move	function
(	O
pos	int
,	O
WHITE	int
)	O
;	O
str	int
=	O
pos	int
;	O
break	O
;	O
}	O
}	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
mx	array
[	O
pos	int
]	O
==	O
1	int
||	O
board	pointer
[	O
pos	int
]	O
!=	O
EMPTY	int
||	O
liberty_of_string	function
(	O
pos	int
,	O
str	int
)	O
)	O
continue	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
+	O
delta	array
[	O
k	int
]	O
)	O
&&	O
liberty_of_string	function
(	O
pos	int
+	O
delta	array
[	O
k	int
]	O
,	O
str	int
)	O
)	O
{	O
play_move	function
(	O
pos	int
,	O
BLACK	int
)	O
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
verbose	int
)	O
showboard	function
(	O
0	int
)	O
;	O
save_verbose	int
=	O
verbose	int
;	O
verbose	int
=	O
0	int
;	O
store_board	function
(	O
&	O
starting_position	struct
)	O
;	O
N	int
=	O
1	int
<<	O
eyesize	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
N	int
;	O
n	int
++	O
)	O
{	O
int	O
valid	int
=	O
1	int
;	O
int	O
internal_stones	int
=	O
0	int
;	O
restore_board	function
(	O
&	O
starting_position	struct
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
eyesize	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
n	int
&	O
(	O
1	int
<<	O
k	int
)	O
)	O
{	O
if	O
(	O
!	O
is_legal	function
(	O
eye_vertices	pointer
[	O
k	int
]	O
,	O
BLACK	int
)	O
)	O
{	O
valid	int
=	O
0	int
;	O
break	O
;	O
}	O
play_move	function
(	O
eye_vertices	pointer
[	O
k	int
]	O
,	O
BLACK	int
)	O
;	O
internal_stones	int
++	O
;	O
}	O
}	O
if	O
(	O
!	O
valid	int
)	O
continue	O
;	O
if	O
(	O
save_verbose	int
>	O
1	int
)	O
showboard	function
(	O
0	int
)	O
;	O
examine_position	function
(	O
EXAMINE_DRAGONS_WITHOUT_OWL	int
,	O
0	int
)	O
;	O
attack_code	pointer
=	O
owl_attack	function
(	O
str	int
,	O
&	O
attack_point	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
attack_code	pointer
==	O
0	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
eyesize	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
eye_vertices	pointer
[	O
k	int
]	O
]	O
==	O
EMPTY	int
&&	O
is_legal	function
(	O
eye_vertices	pointer
[	O
k	int
]	O
,	O
BLACK	int
)	O
&&	O
owl_does_attack	function
(	O
eye_vertices	pointer
[	O
k	int
]	O
,	O
str	int
,	O
NULL	O
)	O
)	O
{	O
gprintf	function
(	O
"%1m alive, but %1m attacks:\n"	pointer
,	O
str	int
,	O
eye_vertices	pointer
[	O
k	int
]	O
)	O
;	O
showboard	function
(	O
0	int
)	O
;	O
gprintf	function
(	O
"\n"	pointer
)	O
;	O
}	O
}	O
if	O
(	O
internal_stones	int
==	O
eyesize	int
-	O
1	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
eyesize	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
eye_vertices	pointer
[	O
k	int
]	O
]	O
==	O
EMPTY	int
&&	O
!	O
owl_does_defend	function
(	O
eye_vertices	pointer
[	O
k	int
]	O
,	O
str	int
,	O
NULL	O
)	O
)	O
{	O
gprintf	function
(	O
"%1m alive, but almost filled with nakade:\n"	pointer
,	O
str	int
)	O
;	O
showboard	function
(	O
0	int
)	O
;	O
}	O
}	O
}	O
}	O
else	O
{	O
defense_code	int
=	O
owl_defend	function
(	O
str	int
,	O
&	O
defense_point	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
defense_code	int
==	O
0	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
eyesize	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
eye_vertices	pointer
[	O
k	int
]	O
]	O
==	O
EMPTY	int
&&	O
is_legal	function
(	O
eye_vertices	pointer
[	O
k	int
]	O
,	O
WHITE	int
)	O
&&	O
owl_does_defend	function
(	O
eye_vertices	pointer
[	O
k	int
]	O
,	O
str	int
,	O
NULL	O
)	O
)	O
{	O
gprintf	function
(	O
"%1m dead, but %1m defends:\n"	pointer
,	O
str	int
,	O
eye_vertices	pointer
[	O
k	int
]	O
)	O
;	O
showboard	function
(	O
0	int
)	O
;	O
gprintf	function
(	O
"\n"	pointer
)	O
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
board	pointer
[	O
attack_point	pointer
]	O
!=	O
EMPTY	int
||	O
!	O
is_legal	function
(	O
attack_point	pointer
,	O
BLACK	int
)	O
)	O
{	O
gprintf	function
(	O
"Bad attack point %1m:\n"	pointer
,	O
attack_point	pointer
)	O
;	O
showboard	function
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
!	O
owl_does_attack	function
(	O
attack_point	pointer
,	O
str	int
,	O
NULL	O
)	O
)	O
{	O
gprintf	function
(	O
"Attack point %1m failed:\n"	pointer
,	O
attack_point	pointer
)	O
;	O
showboard	function
(	O
0	int
)	O
;	O
}	O
if	O
(	O
board	pointer
[	O
defense_point	pointer
]	O
!=	O
EMPTY	int
||	O
!	O
is_legal	function
(	O
defense_point	pointer
,	O
WHITE	int
)	O
)	O
{	O
gprintf	function
(	O
"Bad defense point %1m:\n"	pointer
,	O
defense_point	pointer
)	O
;	O
showboard	function
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
!	O
owl_does_defend	function
(	O
defense_point	pointer
,	O
str	int
,	O
NULL	O
)	O
)	O
{	O
gprintf	function
(	O
"Defense point %1m failed:\n"	pointer
,	O
defense_point	pointer
)	O
;	O
showboard	function
(	O
0	int
)	O
;	O
}	O
}	O
}	O
}	O
verbose	int
=	O
save_verbose	int
;	O
}	O
static	O
int	O
eyegraph_trymove	function
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
const	O
char	O
*	O
message	pointer
,	O
int	O
str	int
)	O
{	O
static	O
Hash_data	struct
remembered_board_hashes	array
[	O
MAXSTACK	O
]	O
;	O
int	O
k	int
;	O
int	O
does_capture	int
=	O
does_capture_something	function
(	O
pos	int
,	O
color	int
)	O
;	O
remembered_board_hashes	array
[	O
stackp	int
]	O
=	O
board_hash	struct
;	O
if	O
(	O
!	O
trymove	function
(	O
pos	int
,	O
color	int
,	O
message	pointer
,	O
str	int
)	O
)	O
return	O
0	int
;	O
if	O
(	O
does_capture	int
)	O
return	O
1	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
stackp	int
;	O
k	int
++	O
)	O
if	O
(	O
hashdata_is_equal	O
(	O
board_hash	struct
,	O
remembered_board_hashes	array
[	O
k	int
]	O
)	O
)	O
{	O
popgo	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
eyegraph_is_margin_or_outer_liberty	function
(	O
int	O
vertex	pointer
)	O
{	O
int	O
k	int
;	O
int	O
r	int
;	O
int	O
num_libs	int
;	O
int	O
libs	pointer
[	O
MAXLIBS	O
]	O
;	O
int	O
eyes	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
vertex	pointer
+	O
delta	array
[	O
k	int
]	O
]	O
==	O
BLACK	int
)	O
{	O
eyes	int
=	O
0	int
;	O
num_libs	int
=	O
findlib	function
(	O
vertex	pointer
+	O
delta	array
[	O
k	int
]	O
,	O
MAXLIBS	O
,	O
libs	pointer
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
num_libs	int
;	O
r	int
++	O
)	O
if	O
(	O
is_suicide	function
(	O
libs	pointer
[	O
r	int
]	O
,	O
WHITE	int
)	O
)	O
eyes	int
++	O
;	O
if	O
(	O
eyes	int
>=	O
2	int
)	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
eyegraph_order_moves	function
(	O
int	O
num_vertices	int
,	O
int	O
*	O
vertices	pointer
,	O
int	O
color_to_move	int
,	O
int	O
*	O
moves	array
)	O
{	O
int	O
num_moves	int
=	O
0	int
;	O
int	O
scores	array
[	O
BOARDMAX	O
]	O
;	O
int	O
move	pointer
;	O
int	O
score	float
;	O
int	O
k	int
;	O
int	O
r	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_vertices	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
k	int
>=	O
num_vertices	int
-	O
3	int
)	O
{	O
if	O
(	O
color_to_move	int
==	O
WHITE	int
)	O
break	O
;	O
if	O
(	O
k	int
==	O
num_vertices	int
-	O
2	int
&&	O
board	pointer
[	O
vertices	pointer
[	O
num_vertices	int
-	O
3	int
]	O
]	O
==	O
EMPTY	int
)	O
continue	O
;	O
}	O
move	pointer
=	O
vertices	pointer
[	O
k	int
]	O
;	O
score	float
=	O
0	int
;	O
if	O
(	O
board	pointer
[	O
move	pointer
]	O
!=	O
EMPTY	int
)	O
continue	O
;	O
if	O
(	O
eyegraph_is_margin_or_outer_liberty	function
(	O
move	pointer
)	O
)	O
{	O
if	O
(	O
k	int
<	O
num_vertices	int
-	O
3	int
)	O
score	float
=	O
5	int
;	O
else	O
score	float
=	O
-	O
10	int
;	O
}	O
if	O
(	O
accuratelib	function
(	O
move	pointer
,	O
color_to_move	int
,	O
2	int
,	O
NULL	O
)	O
==	O
1	int
)	O
score	float
-=	O
3	int
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
4	int
;	O
r	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
move	pointer
+	O
delta	array
[	O
r	int
]	O
]	O
==	O
EMPTY	int
)	O
score	float
+=	O
2	int
;	O
else	O
if	O
(	O
board	pointer
[	O
move	pointer
+	O
delta	array
[	O
r	int
]	O
]	O
==	O
BLACK	int
)	O
score	float
+=	O
3	int
;	O
}	O
moves	array
[	O
num_moves	int
]	O
=	O
move	pointer
;	O
scores	array
[	O
num_moves	int
]	O
=	O
score	float
;	O
num_moves	int
++	O
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_moves	int
;	O
k	int
++	O
)	O
{	O
int	O
maxscore	int
=	O
scores	array
[	O
k	int
]	O
;	O
int	O
max_at	int
=	O
0	int
;	O
for	O
(	O
r	int
=	O
k	int
+	O
1	int
;	O
r	int
<	O
num_moves	int
;	O
r	int
++	O
)	O
{	O
if	O
(	O
scores	array
[	O
r	int
]	O
>	O
maxscore	int
)	O
{	O
maxscore	int
=	O
scores	array
[	O
r	int
]	O
;	O
max_at	int
=	O
r	int
;	O
}	O
}	O
if	O
(	O
max_at	int
!=	O
0	int
)	O
{	O
int	O
temp	int
=	O
moves	array
[	O
max_at	int
]	O
;	O
moves	array
[	O
max_at	int
]	O
=	O
moves	array
[	O
k	int
]	O
;	O
moves	array
[	O
k	int
]	O
=	O
temp	int
;	O
temp	int
=	O
scores	array
[	O
max_at	int
]	O
;	O
scores	array
[	O
max_at	int
]	O
=	O
scores	array
[	O
k	int
]	O
;	O
scores	array
[	O
k	int
]	O
=	O
temp	int
;	O
}	O
}	O
return	O
num_moves	int
;	O
}	O
static	O
int	O
white_area	int
(	O
int	O
mx	array
[	O
BOARDMAX	O
]	O
,	O
int	O
pos	int
,	O
int	O
up	int
,	O
int	O
right	int
,	O
int	O
marginpos	int
,	O
int	O
distance	int
)	O
{	O
int	O
u	int
,	O
v	int
;	O
int	O
k	int
;	O
int	O
edge	char
=	O
is_edge_vertex	function
(	O
marginpos	int
)	O
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<	O
distance	int
;	O
k	int
++	O
)	O
if	O
(	O
!	O
ON_BOARD	O
(	O
marginpos	int
+	O
k	int
*	O
up	int
)	O
||	O
mx	array
[	O
marginpos	int
+	O
k	int
*	O
up	int
]	O
!=	O
WHITE	int
)	O
return	O
0	int
;	O
for	O
(	O
u	int
=	O
-	O
1	int
;	O
u	int
<=	O
4	int
;	O
u	int
++	O
)	O
for	O
(	O
v	int
=	O
-	O
1	int
;	O
v	int
<=	O
4	int
;	O
v	int
++	O
)	O
{	O
int	O
pos2	int
=	O
pos	int
+	O
u	int
*	O
up	int
+	O
v	int
*	O
right	int
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos2	int
)	O
)	O
{	O
if	O
(	O
!	O
edge	char
)	O
return	O
0	int
;	O
else	O
if	O
(	O
u	int
>=	O
0	int
&&	O
u	int
<=	O
3	int
&&	O
v	int
>=	O
0	int
&&	O
v	int
<=	O
3	int
)	O
return	O
0	int
;	O
else	O
if	O
(	O
I	O
(	O
pos2	int
)	O
!=	O
I	O
(	O
NORTH	O
(	O
marginpos	int
)	O
)	O
&&	O
I	O
(	O
pos2	int
)	O
!=	O
I	O
(	O
SOUTH	O
(	O
marginpos	int
)	O
)	O
&&	O
J	O
(	O
pos2	int
)	O
!=	O
J	O
(	O
WEST	O
(	O
marginpos	int
)	O
)	O
&&	O
J	O
(	O
pos2	int
)	O
!=	O
J	O
(	O
EAST	O
(	O
marginpos	int
)	O
)	O
)	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
mx	array
[	O
pos2	int
]	O
!=	O
WHITE	int
)	O
return	O
0	int
;	O
}	O
for	O
(	O
u	int
=	O
0	int
;	O
u	int
<=	O
3	int
;	O
u	int
++	O
)	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<=	O
3	int
;	O
v	int
++	O
)	O
{	O
int	O
pos2	int
=	O
pos	int
+	O
u	int
*	O
up	int
+	O
v	int
*	O
right	int
;	O
mx	array
[	O
pos2	int
]	O
=	O
BLACK	int
;	O
}	O
mx	array
[	O
pos	int
+	O
up	int
+	O
right	int
]	O
=	O
EMPTY	int
;	O
mx	array
[	O
pos	int
+	O
2	int
*	O
up	int
+	O
2	int
*	O
right	int
]	O
=	O
EMPTY	int
;	O
return	O
1	int
;	O
}	O
static	O
int	O
tactical_life_defend	function
(	O
int	O
str	int
,	O
int	O
num_vertices	int
,	O
int	O
*	O
vertices	pointer
,	O
unsigned	O
char	O
*	O
results	pointer
)	O
;	O
static	O
int	O
tactical_life_attack	function
(	O
int	O
str	int
,	O
int	O
num_vertices	int
,	O
int	O
*	O
vertices	pointer
,	O
unsigned	O
char	O
*	O
results	pointer
)	O
{	O
int	O
k	int
;	O
int	O
hash	int
=	O
0	int
;	O
int	O
cached_result	int
;	O
int	O
result	int
;	O
int	O
num_moves	int
;	O
int	O
moves	array
[	O
BOARDMAX	O
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_vertices	int
;	O
k	int
++	O
)	O
{	O
hash	int
*=	O
3	int
;	O
hash	int
+=	O
board	pointer
[	O
vertices	pointer
[	O
k	int
]	O
]	O
;	O
}	O
hash	int
*=	O
2	int
;	O
hash	int
+=	O
(	O
board_ko_pos	int
!=	O
NO_MOVE	O
)	O
;	O
cached_result	int
=	O
results	pointer
[	O
hash	int
]	O
&	O
3	int
;	O
if	O
(	O
0	int
)	O
{	O
showboard	function
(	O
0	int
)	O
;	O
gprintf	function
(	O
"%d %d (%d)\n"	pointer
,	O
hash	int
,	O
cached_result	int
,	O
results	pointer
[	O
hash	int
]	O
)	O
;	O
}	O
if	O
(	O
cached_result	int
==	O
2	int
)	O
EYEGRAPH_RETURN	O
(	O
0	int
,	O
"tactical_life_attack: 0 (cached)"	pointer
)	O
;	O
if	O
(	O
cached_result	int
==	O
3	int
)	O
EYEGRAPH_RETURN	O
(	O
1	int
,	O
"tactical_life_attack: win (cached)"	pointer
)	O
;	O
if	O
(	O
cached_result	int
==	O
1	int
)	O
EYEGRAPH_RETURN	O
(	O
1	int
,	O
"tactical_life_attack: win (open node in cache)"	pointer
)	O
;	O
results	pointer
[	O
hash	int
]	O
|=	O
1	int
;	O
num_moves	int
=	O
eyegraph_order_moves	function
(	O
num_vertices	int
,	O
vertices	pointer
,	O
OTHER_COLOR	O
(	O
board	pointer
[	O
str	int
]	O
)	O
,	O
moves	array
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_moves	int
;	O
k	int
++	O
)	O
{	O
int	O
move	pointer
=	O
moves	array
[	O
k	int
]	O
;	O
if	O
(	O
eyegraph_trymove	function
(	O
move	pointer
,	O
OTHER_COLOR	O
(	O
board	pointer
[	O
str	int
]	O
)	O
,	O
"tactical_life_attack"	pointer
,	O
str	int
)	O
)	O
{	O
if	O
(	O
board	pointer
[	O
str	int
]	O
==	O
EMPTY	int
)	O
result	int
=	O
1	int
;	O
else	O
result	int
=	O
!	O
tactical_life_defend	function
(	O
str	int
,	O
num_vertices	int
,	O
vertices	pointer
,	O
results	pointer
)	O
;	O
popgo	function
(	O
)	O
;	O
if	O
(	O
result	int
==	O
1	int
)	O
{	O
results	pointer
[	O
hash	int
]	O
=	O
(	O
results	pointer
[	O
hash	int
]	O
&	O
(	O
~	O
3	int
)	O
)	O
|	O
3	int
;	O
EYEGRAPH_RETURN	O
(	O
1	int
,	O
"tactical_life_attack: win"	pointer
)	O
;	O
}	O
}	O
}	O
results	pointer
[	O
hash	int
]	O
=	O
(	O
results	pointer
[	O
hash	int
]	O
&	O
(	O
~	O
3	int
)	O
)	O
|	O
2	int
;	O
EYEGRAPH_RETURN	O
(	O
0	int
,	O
"tactical_life_attack: 0"	pointer
)	O
;	O
}	O
static	O
int	O
tactical_life_defend	function
(	O
int	O
str	int
,	O
int	O
num_vertices	int
,	O
int	O
*	O
vertices	pointer
,	O
unsigned	O
char	O
*	O
results	pointer
)	O
{	O
int	O
k	int
;	O
int	O
hash	int
=	O
0	int
;	O
int	O
cached_result	int
;	O
int	O
result	int
;	O
int	O
num_moves	int
;	O
int	O
moves	array
[	O
BOARDMAX	O
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_vertices	int
;	O
k	int
++	O
)	O
{	O
hash	int
*=	O
3	int
;	O
ASSERT1	O
(	O
board	pointer
[	O
vertices	pointer
[	O
k	int
]	O
]	O
<=	O
2	int
,	O
vertices	pointer
[	O
k	int
]	O
)	O
;	O
hash	int
+=	O
board	pointer
[	O
vertices	pointer
[	O
k	int
]	O
]	O
;	O
}	O
hash	int
*=	O
2	int
;	O
hash	int
+=	O
(	O
board_ko_pos	int
!=	O
NO_MOVE	O
)	O
;	O
cached_result	int
=	O
(	O
results	pointer
[	O
hash	int
]	O
>>	O
2	int
)	O
&	O
3	int
;	O
if	O
(	O
0	int
)	O
{	O
showboard	function
(	O
0	int
)	O
;	O
gprintf	function
(	O
"%d %d (%d)\n"	pointer
,	O
hash	int
,	O
cached_result	int
,	O
results	pointer
[	O
hash	int
]	O
)	O
;	O
}	O
if	O
(	O
cached_result	int
==	O
2	int
)	O
EYEGRAPH_RETURN	O
(	O
0	int
,	O
"tactical_life_defend: 0 (cached)"	pointer
)	O
;	O
if	O
(	O
cached_result	int
==	O
3	int
)	O
EYEGRAPH_RETURN	O
(	O
1	int
,	O
"tactical_life_defend: win (cached)"	pointer
)	O
;	O
if	O
(	O
cached_result	int
==	O
1	int
)	O
EYEGRAPH_RETURN	O
(	O
1	int
,	O
"tactical_life_defend: win (node open in cache)"	pointer
)	O
;	O
results	pointer
[	O
hash	int
]	O
|=	O
(	O
1	int
<<	O
2	int
)	O
;	O
num_moves	int
=	O
eyegraph_order_moves	function
(	O
num_vertices	int
,	O
vertices	pointer
,	O
board	pointer
[	O
str	int
]	O
,	O
moves	array
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_moves	int
;	O
k	int
++	O
)	O
{	O
int	O
move	pointer
=	O
moves	array
[	O
k	int
]	O
;	O
if	O
(	O
(	O
!	O
is_suicide	function
(	O
move	pointer
,	O
OTHER_COLOR	O
(	O
board	pointer
[	O
str	int
]	O
)	O
)	O
||	O
does_capture_something	function
(	O
move	pointer
,	O
board	pointer
[	O
str	int
]	O
)	O
)	O
&&	O
eyegraph_trymove	function
(	O
move	pointer
,	O
board	pointer
[	O
str	int
]	O
,	O
"tactical_life_defend"	pointer
,	O
str	int
)	O
)	O
{	O
result	int
=	O
!	O
tactical_life_attack	function
(	O
str	int
,	O
num_vertices	int
,	O
vertices	pointer
,	O
results	pointer
)	O
;	O
popgo	function
(	O
)	O
;	O
if	O
(	O
result	int
==	O
1	int
)	O
{	O
results	pointer
[	O
hash	int
]	O
=	O
(	O
results	pointer
[	O
hash	int
]	O
&	O
(	O
~	O
12	int
)	O
)	O
|	O
(	O
3	int
<<	O
2	int
)	O
;	O
EYEGRAPH_RETURN	O
(	O
1	int
,	O
"tactical_life_defend: win"	pointer
)	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
tactical_life_attack	function
(	O
str	int
,	O
num_vertices	int
,	O
vertices	pointer
,	O
results	pointer
)	O
)	O
{	O
results	pointer
[	O
hash	int
]	O
=	O
(	O
results	pointer
[	O
hash	int
]	O
&	O
(	O
~	O
12	int
)	O
)	O
|	O
(	O
3	int
<<	O
2	int
)	O
;	O
EYEGRAPH_RETURN	O
(	O
1	int
,	O
"tactical_life_defend: win"	pointer
)	O
;	O
}	O
results	pointer
[	O
hash	int
]	O
=	O
(	O
results	pointer
[	O
hash	int
]	O
&	O
(	O
~	O
12	int
)	O
)	O
|	O
(	O
2	int
<<	O
2	int
)	O
;	O
EYEGRAPH_RETURN	O
(	O
0	int
,	O
"tactical_life_defend: 0"	pointer
)	O
;	O
}	O
static	O
void	O
tactical_life	function
(	O
int	O
have_eye	int
,	O
int	O
num_vertices	int
,	O
int	O
*	O
vertices	pointer
,	O
int	O
*	O
attack_code	pointer
,	O
int	O
*	O
num_attacks	int
,	O
int	O
*	O
attack_points	array
,	O
int	O
*	O
defense_code	int
,	O
int	O
*	O
num_defenses	int
,	O
int	O
*	O
defense_points	array
,	O
unsigned	O
char	O
*	O
results	pointer
)	O
{	O
int	O
k	int
;	O
int	O
str	int
;	O
int	O
num_moves	int
;	O
int	O
moves	array
[	O
BOARDMAX	O
]	O
;	O
gg_assert	O
(	O
attack_code	pointer
!=	O
NULL	O
&&	O
defense_code	int
!=	O
NULL	O
)	O
;	O
str	int
=	O
POS	O
(	O
1	int
,	O
0	int
)	O
;	O
if	O
(	O
board	pointer
[	O
str	int
]	O
==	O
EMPTY	int
)	O
{	O
*	O
attack_code	pointer
=	O
WIN	int
;	O
*	O
defense_code	int
=	O
0	int
;	O
return	O
;	O
}	O
if	O
(	O
!	O
have_eye	int
)	O
{	O
if	O
(	O
!	O
eyegraph_trymove	function
(	O
POS	O
(	O
0	int
,	O
0	int
)	O
,	O
WHITE	int
,	O
"tactical_life-A"	pointer
,	O
NO_MOVE	O
)	O
)	O
{	O
*	O
attack_code	pointer
=	O
WIN	int
;	O
*	O
defense_code	int
=	O
0	int
;	O
return	O
;	O
}	O
}	O
*	O
attack_code	pointer
=	O
0	int
;	O
*	O
defense_code	int
=	O
0	int
;	O
if	O
(	O
tactical_life_attack	function
(	O
str	int
,	O
num_vertices	int
,	O
vertices	pointer
,	O
results	pointer
)	O
)	O
{	O
*	O
attack_code	pointer
=	O
WIN	int
;	O
if	O
(	O
tactical_life_defend	function
(	O
str	int
,	O
num_vertices	int
,	O
vertices	pointer
,	O
results	pointer
)	O
)	O
*	O
defense_code	int
=	O
WIN	int
;	O
}	O
else	O
*	O
defense_code	int
=	O
WIN	int
;	O
if	O
(	O
*	O
attack_code	pointer
!=	O
0	int
&&	O
*	O
defense_code	int
!=	O
0	int
)	O
{	O
if	O
(	O
num_attacks	int
!=	O
NULL	O
&&	O
attack_points	array
!=	O
NULL	O
)	O
{	O
*	O
num_attacks	int
=	O
0	int
;	O
num_moves	int
=	O
eyegraph_order_moves	function
(	O
num_vertices	int
,	O
vertices	pointer
,	O
OTHER_COLOR	O
(	O
board	pointer
[	O
str	int
]	O
)	O
,	O
moves	array
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_moves	int
;	O
k	int
++	O
)	O
{	O
int	O
move	pointer
=	O
moves	array
[	O
k	int
]	O
;	O
if	O
(	O
eyegraph_trymove	function
(	O
move	pointer
,	O
OTHER_COLOR	O
(	O
board	pointer
[	O
str	int
]	O
)	O
,	O
"tactical_life-B"	pointer
,	O
str	int
)	O
)	O
{	O
if	O
(	O
board	pointer
[	O
str	int
]	O
==	O
EMPTY	int
||	O
!	O
tactical_life_defend	function
(	O
str	int
,	O
num_vertices	int
,	O
vertices	pointer
,	O
results	pointer
)	O
)	O
attack_points	array
[	O
(	O
*	O
num_attacks	int
)	O
++	O
]	O
=	O
move	pointer
;	O
popgo	function
(	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
num_defenses	int
!=	O
NULL	O
&&	O
defense_points	array
!=	O
NULL	O
)	O
{	O
*	O
num_defenses	int
=	O
0	int
;	O
num_moves	int
=	O
eyegraph_order_moves	function
(	O
num_vertices	int
,	O
vertices	pointer
,	O
board	pointer
[	O
str	int
]	O
,	O
moves	array
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_moves	int
;	O
k	int
++	O
)	O
{	O
int	O
move	pointer
=	O
moves	array
[	O
k	int
]	O
;	O
if	O
(	O
eyegraph_trymove	function
(	O
move	pointer
,	O
board	pointer
[	O
str	int
]	O
,	O
"tactical_life-C"	pointer
,	O
str	int
)	O
)	O
{	O
if	O
(	O
!	O
tactical_life_attack	function
(	O
str	int
,	O
num_vertices	int
,	O
vertices	pointer
,	O
results	pointer
)	O
)	O
defense_points	array
[	O
(	O
*	O
num_defenses	int
)	O
++	O
]	O
=	O
move	pointer
;	O
popgo	function
(	O
)	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
!	O
have_eye	int
)	O
popgo	function
(	O
)	O
;	O
}	O
static	O
void	O
evaluate_eyespace	function
(	O
struct	O
eyevalue	struct
*	O
result	int
,	O
int	O
num_vertices	int
,	O
int	O
*	O
vertices	pointer
,	O
int	O
*	O
num_vital_attacks	pointer
,	O
int	O
*	O
vital_attacks	pointer
,	O
int	O
*	O
num_vital_defenses	pointer
,	O
int	O
*	O
vital_defenses	pointer
,	O
unsigned	O
char	O
*	O
tactical_life_results	pointer
)	O
{	O
int	O
k	int
;	O
int	O
attack_code	pointer
;	O
int	O
num_attacks	int
;	O
int	O
attack_points	array
[	O
BOARDMAX	O
]	O
;	O
int	O
defense_code	int
;	O
int	O
num_defenses	int
;	O
int	O
defense_points	array
[	O
BOARDMAX	O
]	O
;	O
int	O
attack_code2	int
;	O
int	O
num_attacks2	int
;	O
int	O
attack_points2	array
[	O
BOARDMAX	O
]	O
;	O
int	O
defense_code2	int
;	O
struct	O
eyevalue	struct
result2	struct
;	O
int	O
num_vital_attacks2	int
;	O
int	O
vital_attacks2	array
[	O
BOARDMAX	O
]	O
;	O
int	O
num_vital_defenses2	int
;	O
int	O
vital_defenses2	array
[	O
BOARDMAX	O
]	O
;	O
int	O
num_moves	int
;	O
int	O
moves	array
[	O
BOARDMAX	O
]	O
;	O
*	O
num_vital_attacks	pointer
=	O
0	int
;	O
*	O
num_vital_defenses	pointer
=	O
0	int
;	O
tactical_life	function
(	O
0	int
,	O
num_vertices	int
,	O
vertices	pointer
,	O
&	O
attack_code	pointer
,	O
&	O
num_attacks	int
,	O
attack_points	array
,	O
&	O
defense_code	int
,	O
&	O
num_defenses	int
,	O
defense_points	array
,	O
tactical_life_results	pointer
)	O
;	O
if	O
(	O
attack_code	pointer
==	O
0	int
)	O
{	O
int	O
a	char
=	O
2	int
;	O
if	O
(	O
sgf_dumptree	pointer
)	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
"Alive without extra eye.\n"	pointer
)	O
;	O
num_moves	int
=	O
eyegraph_order_moves	function
(	O
num_vertices	int
,	O
vertices	pointer
,	O
BLACK	int
,	O
moves	array
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_moves	int
;	O
k	int
++	O
)	O
{	O
int	O
acode	int
,	O
dcode	int
;	O
int	O
move	pointer
=	O
moves	array
[	O
k	int
]	O
;	O
if	O
(	O
eyegraph_trymove	function
(	O
move	pointer
,	O
BLACK	int
,	O
"evaluate_eyespace-A"	pointer
,	O
NO_MOVE	O
)	O
)	O
{	O
tactical_life	function
(	O
0	int
,	O
num_vertices	int
,	O
vertices	pointer
,	O
&	O
acode	int
,	O
NULL	O
,	O
NULL	O
,	O
&	O
dcode	int
,	O
NULL	O
,	O
NULL	O
,	O
tactical_life_results	pointer
)	O
;	O
if	O
(	O
acode	int
!=	O
0	int
)	O
{	O
tactical_life	function
(	O
1	int
,	O
num_vertices	int
,	O
vertices	pointer
,	O
&	O
acode	int
,	O
NULL	O
,	O
NULL	O
,	O
&	O
dcode	int
,	O
NULL	O
,	O
NULL	O
,	O
tactical_life_results	pointer
)	O
;	O
if	O
(	O
acode	int
!=	O
0	int
)	O
{	O
if	O
(	O
a	char
==	O
1	int
)	O
*	O
num_vital_attacks	pointer
=	O
0	int
;	O
a	char
=	O
0	int
;	O
vital_attacks	pointer
[	O
(	O
*	O
num_vital_attacks	pointer
)	O
++	O
]	O
=	O
move	pointer
;	O
if	O
(	O
sgf_dumptree	pointer
)	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
"Ko threat to remove both eyes.\n"	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
a	char
!=	O
0	int
)	O
{	O
vital_attacks	pointer
[	O
(	O
*	O
num_vital_attacks	pointer
)	O
++	O
]	O
=	O
move	pointer
;	O
a	char
=	O
1	int
;	O
}	O
if	O
(	O
sgf_dumptree	pointer
)	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
"Ko threat to remove one eye.\n"	pointer
)	O
;	O
}	O
}	O
popgo	function
(	O
)	O
;	O
}	O
}	O
set_eyevalue	function
(	O
result	int
,	O
a	char
,	O
2	int
,	O
2	int
,	O
2	int
)	O
;	O
if	O
(	O
sgf_dumptree	pointer
)	O
{	O
if	O
(	O
a	char
==	O
0	int
)	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
"Eyevalue 0222.\n"	pointer
)	O
;	O
else	O
if	O
(	O
a	char
==	O
1	int
)	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
"Eyevalue 1222.\n"	pointer
)	O
;	O
else	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
"Eyevalue 2222.\n"	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
defense_code	int
!=	O
0	int
)	O
{	O
if	O
(	O
sgf_dumptree	pointer
)	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
"Critical without extra eye.\n"	pointer
)	O
;	O
tactical_life	function
(	O
1	int
,	O
num_vertices	int
,	O
vertices	pointer
,	O
&	O
attack_code2	int
,	O
&	O
num_attacks2	int
,	O
attack_points2	array
,	O
&	O
defense_code2	int
,	O
NULL	O
,	O
NULL	O
,	O
tactical_life_results	pointer
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_defenses	int
;	O
k	int
++	O
)	O
vital_defenses	pointer
[	O
(	O
*	O
num_vital_defenses	pointer
)	O
++	O
]	O
=	O
defense_points	array
[	O
k	int
]	O
;	O
if	O
(	O
attack_code2	int
==	O
WIN	int
)	O
{	O
set_eyevalue	function
(	O
result	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
2	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_attacks2	int
;	O
k	int
++	O
)	O
vital_attacks	pointer
[	O
(	O
*	O
num_vital_attacks	pointer
)	O
++	O
]	O
=	O
attack_points2	array
[	O
k	int
]	O
;	O
if	O
(	O
sgf_dumptree	pointer
)	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
"Eyevalue: 0022.\n"	pointer
)	O
;	O
}	O
else	O
{	O
int	O
a	char
=	O
1	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_attacks	int
;	O
k	int
++	O
)	O
{	O
int	O
move	pointer
=	O
attack_points	array
[	O
k	int
]	O
;	O
if	O
(	O
eyegraph_trymove	function
(	O
move	pointer
,	O
BLACK	int
,	O
"evaluate_eyespace-B"	pointer
,	O
NO_MOVE	O
)	O
)	O
{	O
evaluate_eyespace	function
(	O
&	O
result2	struct
,	O
num_vertices	int
,	O
vertices	pointer
,	O
&	O
num_vital_attacks2	int
,	O
vital_attacks2	array
,	O
&	O
num_vital_defenses2	int
,	O
vital_defenses2	array
,	O
tactical_life_results	pointer
)	O
;	O
if	O
(	O
min_eyes	function
(	O
&	O
result2	struct
)	O
==	O
0	int
&&	O
max_eyes	function
(	O
&	O
result2	struct
)	O
==	O
1	int
&&	O
max_eye_threat	function
(	O
&	O
result2	struct
)	O
==	O
1	int
)	O
{	O
if	O
(	O
a	char
==	O
1	int
)	O
*	O
num_vital_attacks	pointer
=	O
0	int
;	O
a	char
=	O
0	int
;	O
vital_attacks	pointer
[	O
(	O
*	O
num_vital_attacks	pointer
)	O
++	O
]	O
=	O
move	pointer
;	O
}	O
else	O
if	O
(	O
a	char
==	O
1	int
)	O
vital_attacks	pointer
[	O
(	O
*	O
num_vital_attacks	pointer
)	O
++	O
]	O
=	O
move	pointer
;	O
popgo	function
(	O
)	O
;	O
}	O
}	O
set_eyevalue	function
(	O
result	int
,	O
a	char
,	O
1	int
,	O
2	int
,	O
2	int
)	O
;	O
if	O
(	O
sgf_dumptree	pointer
)	O
{	O
if	O
(	O
a	char
==	O
0	int
)	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
"Eyevalue: 0122.\n"	pointer
)	O
;	O
else	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
"Eyevalue: 1122.\n"	pointer
)	O
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
sgf_dumptree	pointer
)	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
"Dead without extra eye.\n"	pointer
)	O
;	O
tactical_life	function
(	O
1	int
,	O
num_vertices	int
,	O
vertices	pointer
,	O
&	O
attack_code	pointer
,	O
&	O
num_attacks	int
,	O
attack_points	array
,	O
&	O
defense_code	int
,	O
&	O
num_defenses	int
,	O
defense_points	array
,	O
tactical_life_results	pointer
)	O
;	O
if	O
(	O
attack_code	pointer
==	O
0	int
)	O
{	O
int	O
a	char
=	O
1	int
;	O
int	O
d	int
=	O
1	int
;	O
if	O
(	O
sgf_dumptree	pointer
)	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
"Alive with extra eye.\n"	pointer
)	O
;	O
num_moves	int
=	O
eyegraph_order_moves	function
(	O
num_vertices	int
,	O
vertices	pointer
,	O
BLACK	int
,	O
moves	array
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_moves	int
;	O
k	int
++	O
)	O
{	O
int	O
acode	int
,	O
dcode	int
;	O
int	O
move	pointer
=	O
moves	array
[	O
k	int
]	O
;	O
if	O
(	O
eyegraph_trymove	function
(	O
move	pointer
,	O
BLACK	int
,	O
"evaluate_eyespace-C"	pointer
,	O
NO_MOVE	O
)	O
)	O
{	O
tactical_life	function
(	O
1	int
,	O
num_vertices	int
,	O
vertices	pointer
,	O
&	O
acode	int
,	O
NULL	O
,	O
NULL	O
,	O
&	O
dcode	int
,	O
NULL	O
,	O
NULL	O
,	O
tactical_life_results	pointer
)	O
;	O
if	O
(	O
acode	int
!=	O
0	int
)	O
{	O
evaluate_eyespace	function
(	O
&	O
result2	struct
,	O
num_vertices	int
,	O
vertices	pointer
,	O
&	O
num_vital_attacks2	int
,	O
vital_attacks2	array
,	O
&	O
num_vital_defenses2	int
,	O
vital_defenses2	array
,	O
tactical_life_results	pointer
)	O
;	O
if	O
(	O
max_eye_threat	function
(	O
&	O
result2	struct
)	O
==	O
1	int
)	O
{	O
vital_attacks	pointer
[	O
(	O
*	O
num_vital_attacks	pointer
)	O
++	O
]	O
=	O
move	pointer
;	O
a	char
=	O
0	int
;	O
if	O
(	O
sgf_dumptree	pointer
)	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
"Attacking ko threat.\n"	pointer
)	O
;	O
}	O
}	O
popgo	function
(	O
)	O
;	O
}	O
}	O
num_moves	int
=	O
eyegraph_order_moves	function
(	O
num_vertices	int
,	O
vertices	pointer
,	O
WHITE	int
,	O
moves	array
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_moves	int
;	O
k	int
++	O
)	O
{	O
int	O
acode	int
,	O
dcode	int
;	O
int	O
move	pointer
=	O
moves	array
[	O
k	int
]	O
;	O
if	O
(	O
eyegraph_trymove	function
(	O
move	pointer
,	O
WHITE	int
,	O
"evaluate_eyespace-D"	pointer
,	O
NO_MOVE	O
)	O
)	O
{	O
tactical_life	function
(	O
0	int
,	O
num_vertices	int
,	O
vertices	pointer
,	O
&	O
acode	int
,	O
NULL	O
,	O
NULL	O
,	O
&	O
dcode	int
,	O
NULL	O
,	O
NULL	O
,	O
tactical_life_results	pointer
)	O
;	O
if	O
(	O
dcode	int
!=	O
0	int
)	O
{	O
evaluate_eyespace	function
(	O
&	O
result2	struct
,	O
num_vertices	int
,	O
vertices	pointer
,	O
&	O
num_vital_attacks2	int
,	O
vital_attacks2	array
,	O
&	O
num_vital_defenses2	int
,	O
vital_defenses2	array
,	O
tactical_life_results	pointer
)	O
;	O
if	O
(	O
min_eye_threat	function
(	O
&	O
result2	struct
)	O
==	O
1	int
)	O
{	O
vital_defenses	pointer
[	O
(	O
*	O
num_vital_defenses	pointer
)	O
++	O
]	O
=	O
move	pointer
;	O
d	int
=	O
2	int
;	O
if	O
(	O
sgf_dumptree	pointer
)	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
"Defending ko threat.\n"	pointer
)	O
;	O
}	O
}	O
popgo	function
(	O
)	O
;	O
}	O
}	O
set_eyevalue	function
(	O
result	int
,	O
a	char
,	O
1	int
,	O
1	int
,	O
d	int
)	O
;	O
if	O
(	O
sgf_dumptree	pointer
)	O
{	O
if	O
(	O
a	char
==	O
0	int
&&	O
d	int
==	O
1	int
)	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
"Eyevalue 0111.\n"	pointer
)	O
;	O
else	O
if	O
(	O
a	char
==	O
0	int
&&	O
d	int
==	O
2	int
)	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
"Eyevalue 0112.\n"	pointer
)	O
;	O
else	O
if	O
(	O
a	char
==	O
1	int
&&	O
d	int
==	O
1	int
)	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
"Eyevalue 1111.\n"	pointer
)	O
;	O
else	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
"Eyevalue 1112.\n"	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
defense_code	int
!=	O
0	int
)	O
{	O
int	O
d	int
=	O
1	int
;	O
if	O
(	O
sgf_dumptree	pointer
)	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
"Critical with extra eye.\n"	pointer
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_attacks	int
;	O
k	int
++	O
)	O
vital_attacks	pointer
[	O
(	O
*	O
num_vital_attacks	pointer
)	O
++	O
]	O
=	O
attack_points	array
[	O
k	int
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_defenses	int
;	O
k	int
++	O
)	O
{	O
int	O
move	pointer
=	O
defense_points	array
[	O
k	int
]	O
;	O
if	O
(	O
eyegraph_trymove	function
(	O
move	pointer
,	O
WHITE	int
,	O
"evaluate_eyespace-E"	pointer
,	O
NO_MOVE	O
)	O
)	O
{	O
evaluate_eyespace	function
(	O
&	O
result2	struct
,	O
num_vertices	int
,	O
vertices	pointer
,	O
&	O
num_vital_attacks2	int
,	O
vital_attacks2	array
,	O
&	O
num_vital_defenses2	int
,	O
vital_defenses2	array
,	O
tactical_life_results	pointer
)	O
;	O
if	O
(	O
min_eye_threat	function
(	O
&	O
result2	struct
)	O
==	O
1	int
&&	O
min_eyes	function
(	O
&	O
result2	struct
)	O
==	O
1	int
&&	O
max_eyes	function
(	O
&	O
result2	struct
)	O
==	O
2	int
)	O
{	O
if	O
(	O
d	int
==	O
1	int
)	O
*	O
num_vital_defenses	pointer
=	O
0	int
;	O
d	int
=	O
2	int
;	O
vital_defenses	pointer
[	O
(	O
*	O
num_vital_defenses	pointer
)	O
++	O
]	O
=	O
move	pointer
;	O
}	O
else	O
if	O
(	O
d	int
==	O
1	int
)	O
vital_defenses	pointer
[	O
(	O
*	O
num_vital_defenses	pointer
)	O
++	O
]	O
=	O
move	pointer
;	O
popgo	function
(	O
)	O
;	O
}	O
}	O
set_eyevalue	function
(	O
result	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
d	int
)	O
;	O
if	O
(	O
sgf_dumptree	pointer
)	O
{	O
if	O
(	O
d	int
==	O
1	int
)	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
"Eyevalue: 0011.\n"	pointer
)	O
;	O
else	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
"Eyevalue: 0012.\n"	pointer
)	O
;	O
}	O
}	O
else	O
{	O
int	O
d	int
=	O
0	int
;	O
if	O
(	O
sgf_dumptree	pointer
)	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
"Dead with extra eye.\n"	pointer
)	O
;	O
num_moves	int
=	O
eyegraph_order_moves	function
(	O
num_vertices	int
,	O
vertices	pointer
,	O
WHITE	int
,	O
moves	array
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_moves	int
;	O
k	int
++	O
)	O
{	O
int	O
acode	int
,	O
dcode	int
;	O
int	O
move	pointer
=	O
moves	array
[	O
k	int
]	O
;	O
if	O
(	O
eyegraph_trymove	function
(	O
move	pointer
,	O
WHITE	int
,	O
"evaluate_eyespace-F"	pointer
,	O
NO_MOVE	O
)	O
)	O
{	O
tactical_life	function
(	O
1	int
,	O
num_vertices	int
,	O
vertices	pointer
,	O
&	O
acode	int
,	O
NULL	O
,	O
NULL	O
,	O
&	O
dcode	int
,	O
NULL	O
,	O
NULL	O
,	O
tactical_life_results	pointer
)	O
;	O
if	O
(	O
dcode	int
!=	O
0	int
)	O
{	O
tactical_life	function
(	O
0	int
,	O
num_vertices	int
,	O
vertices	pointer
,	O
&	O
acode	int
,	O
NULL	O
,	O
NULL	O
,	O
&	O
dcode	int
,	O
NULL	O
,	O
NULL	O
,	O
tactical_life_results	pointer
)	O
;	O
if	O
(	O
dcode	int
!=	O
0	int
)	O
{	O
if	O
(	O
d	int
==	O
1	int
)	O
*	O
num_vital_defenses	pointer
=	O
0	int
;	O
d	int
=	O
2	int
;	O
vital_defenses	pointer
[	O
(	O
*	O
num_vital_defenses	pointer
)	O
++	O
]	O
=	O
move	pointer
;	O
if	O
(	O
sgf_dumptree	pointer
)	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
"Ko threat to make two eyes.\n"	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
d	int
!=	O
2	int
)	O
{	O
vital_defenses	pointer
[	O
(	O
*	O
num_vital_defenses	pointer
)	O
++	O
]	O
=	O
move	pointer
;	O
d	int
=	O
1	int
;	O
}	O
if	O
(	O
sgf_dumptree	pointer
)	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
"Ko threat to make one eye.\n"	pointer
)	O
;	O
}	O
}	O
popgo	function
(	O
)	O
;	O
}	O
}	O
set_eyevalue	function
(	O
result	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
d	int
)	O
;	O
if	O
(	O
sgf_dumptree	pointer
)	O
{	O
if	O
(	O
d	int
==	O
0	int
)	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
"Eyevalue 0000.\n"	pointer
)	O
;	O
else	O
if	O
(	O
d	int
==	O
1	int
)	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
"Eyevalue 0001.\n"	pointer
)	O
;	O
else	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
"Eyevalue 0002.\n"	pointer
)	O
;	O
}	O
}	O
}	O
}	O
static	O
int	O
add_margins	function
(	O
int	O
num_margins	int
,	O
int	O
*	O
margins	int
,	O
int	O
mx	array
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
k	int
;	O
int	O
i	int
,	O
j	int
;	O
int	O
old_mx	array
[	O
BOARDMAX	O
]	O
;	O
int	O
pos	int
;	O
if	O
(	O
num_margins	int
==	O
0	int
)	O
return	O
1	int
;	O
memcpy	function
(	O
old_mx	array
,	O
mx	array
,	O
sizeof	O
(	O
old_mx	array
)	O
)	O
;	O
pos	int
=	O
margins	int
[	O
num_margins	int
-	O
1	int
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
up	int
=	O
delta	array
[	O
k	int
]	O
;	O
int	O
right	int
=	O
delta	array
[	O
(	O
k	int
+	O
1	int
)	O
%	O
4	int
]	O
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
+	O
up	int
)	O
)	O
continue	O
;	O
if	O
(	O
mx	array
[	O
pos	int
+	O
up	int
]	O
==	O
WHITE	int
&&	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
+	O
up	int
+	O
right	int
)	O
||	O
mx	array
[	O
pos	int
+	O
up	int
+	O
right	int
]	O
==	O
WHITE	int
)	O
&&	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
+	O
up	int
-	O
right	int
)	O
||	O
mx	array
[	O
pos	int
+	O
up	int
-	O
right	int
]	O
==	O
WHITE	int
)	O
)	O
{	O
for	O
(	O
i	int
=	O
-	O
3	int
;	O
i	int
<=	O
0	int
;	O
i	int
++	O
)	O
{	O
for	O
(	O
j	int
=	O
2	int
;	O
j	int
<	O
6	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
white_area	int
(	O
mx	array
,	O
pos	int
+	O
j	int
*	O
up	int
+	O
i	int
*	O
right	int
,	O
up	int
,	O
right	int
,	O
pos	int
,	O
j	int
)	O
)	O
{	O
int	O
s	int
=	O
1	int
;	O
while	O
(	O
mx	array
[	O
pos	int
+	O
s	int
*	O
up	int
]	O
==	O
WHITE	int
)	O
{	O
mx	array
[	O
pos	int
+	O
s	int
*	O
up	int
]	O
=	O
BLACK	int
;	O
s	int
++	O
;	O
}	O
if	O
(	O
add_margins	function
(	O
num_margins	int
-	O
1	int
,	O
margins	int
,	O
mx	array
)	O
)	O
return	O
1	int
;	O
else	O
memcpy	function
(	O
mx	array
,	O
old_mx	array
,	O
sizeof	O
(	O
old_mx	array
)	O
)	O
;	O
}	O
}	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
int	O
analyze_eyegraph	function
(	O
const	O
char	O
*	O
coded_eyegraph	pointer
,	O
struct	O
eyevalue	struct
*	O
value	pointer
,	O
char	O
*	O
analyzed_eyegraph	pointer
)	O
{	O
int	O
k	int
;	O
int	O
i	int
,	O
j	int
;	O
int	O
mini	int
,	O
minj	int
;	O
int	O
mx	array
[	O
BOARDMAX	O
]	O
;	O
char	O
mg	array
[	O
BOARDMAX	O
]	O
;	O
int	O
pos	int
;	O
int	O
num_vital_attacks	pointer
;	O
int	O
vital_attacks	pointer
[	O
BOARDMAX	O
]	O
;	O
int	O
num_vital_defenses	pointer
;	O
int	O
vital_defenses	pointer
[	O
BOARDMAX	O
]	O
;	O
int	O
maxwidth	int
;	O
int	O
current_width	int
;	O
int	O
num_rows	int
;	O
int	O
horizontal_edge	int
;	O
int	O
vertical_edge	int
;	O
int	O
num_margins	int
;	O
int	O
margins	int
[	O
BOARDMAX	O
]	O
;	O
int	O
num_vertices	int
;	O
int	O
vertices	pointer
[	O
BOARDMAX	O
]	O
;	O
int	O
table_size	int
;	O
unsigned	O
char	O
*	O
tactical_life_results	pointer
;	O
if	O
(	O
0	int
)	O
gprintf	function
(	O
"Analyze eyegraph %s\n"	pointer
,	O
coded_eyegraph	pointer
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
mx	array
[	O
pos	int
]	O
=	O
WHITE	int
;	O
maxwidth	int
=	O
0	int
;	O
current_width	int
=	O
0	int
;	O
num_rows	int
=	O
1	int
;	O
horizontal_edge	int
=	O
-	O
1	int
;	O
vertical_edge	int
=	O
-	O
1	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
(	O
int	O
)	O
strlen	function
(	O
coded_eyegraph	pointer
)	O
;	O
k	int
++	O
)	O
{	O
if	O
(	O
coded_eyegraph	pointer
[	O
k	int
]	O
==	O
'\n'	O
)	O
continue	O
;	O
if	O
(	O
coded_eyegraph	pointer
[	O
k	int
]	O
==	O
'%'	O
)	O
{	O
num_rows	int
++	O
;	O
if	O
(	O
current_width	int
>	O
maxwidth	int
)	O
maxwidth	int
=	O
current_width	int
;	O
current_width	int
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
coded_eyegraph	pointer
[	O
k	int
]	O
==	O
'-'	O
)	O
horizontal_edge	int
=	O
num_rows	int
-	O
1	int
;	O
else	O
if	O
(	O
coded_eyegraph	pointer
[	O
k	int
]	O
==	O
'|'	O
)	O
vertical_edge	int
=	O
current_width	int
;	O
current_width	int
++	O
;	O
}	O
}	O
if	O
(	O
current_width	int
>	O
maxwidth	int
)	O
maxwidth	int
=	O
current_width	int
;	O
num_margins	int
=	O
0	int
;	O
num_vertices	int
=	O
0	int
;	O
if	O
(	O
horizontal_edge	int
==	O
0	int
)	O
mini	int
=	O
-	O
1	int
;	O
else	O
if	O
(	O
horizontal_edge	int
>	O
0	int
)	O
mini	int
=	O
board_size	int
-	O
num_rows	int
+	O
1	int
;	O
else	O
mini	int
=	O
(	O
board_size	int
-	O
num_rows	int
)	O
/	O
2	int
;	O
if	O
(	O
vertical_edge	int
==	O
0	int
)	O
minj	int
=	O
-	O
1	int
;	O
else	O
if	O
(	O
vertical_edge	int
>	O
0	int
)	O
minj	int
=	O
board_size	int
-	O
maxwidth	int
+	O
1	int
;	O
else	O
minj	int
=	O
(	O
board_size	int
-	O
maxwidth	int
)	O
/	O
2	int
;	O
i	int
=	O
mini	int
;	O
j	int
=	O
minj	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
(	O
int	O
)	O
strlen	function
(	O
coded_eyegraph	pointer
)	O
;	O
k	int
++	O
)	O
{	O
char	O
c	char
=	O
coded_eyegraph	pointer
[	O
k	int
]	O
;	O
if	O
(	O
c	char
==	O
'\n'	O
)	O
continue	O
;	O
if	O
(	O
c	char
==	O
'%'	O
)	O
{	O
i	int
++	O
;	O
j	int
=	O
minj	int
-	O
1	int
;	O
}	O
else	O
if	O
(	O
c	char
==	O
'X'	O
||	O
c	char
==	O
'$'	O
)	O
mx	array
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
=	O
BLACK	int
;	O
else	O
if	O
(	O
c	char
==	O
'.'	O
||	O
c	char
==	O
'*'	O
||	O
c	char
==	O
'<'	O
||	O
c	char
==	O
'>'	O
||	O
c	char
==	O
'!'	O
||	O
c	char
==	O
'@'	O
||	O
c	char
==	O
'('	O
||	O
c	char
==	O
')'	O
)	O
mx	array
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
=	O
EMPTY	int
;	O
if	O
(	O
c	char
==	O
'!'	O
||	O
c	char
==	O
'@'	O
||	O
c	char
==	O
'('	O
||	O
c	char
==	O
')'	O
||	O
c	char
==	O
'$'	O
)	O
margins	int
[	O
num_margins	int
++	O
]	O
=	O
POS	O
(	O
i	int
,	O
j	int
)	O
;	O
if	O
(	O
c	char
!=	O
'|'	O
&&	O
c	char
!=	O
'-'	O
&&	O
c	char
!=	O
'+'	O
&&	O
c	char
!=	O
'%'	O
&&	O
ON_BOARD	O
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
)	O
&&	O
mx	array
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
!=	O
WHITE	int
)	O
vertices	pointer
[	O
num_vertices	int
++	O
]	O
=	O
POS	O
(	O
i	int
,	O
j	int
)	O
;	O
j	int
++	O
;	O
}	O
pos	int
=	O
POS	O
(	O
board_size	int
-	O
2	int
,	O
1	int
)	O
;	O
if	O
(	O
(	O
vertical_edge	int
==	O
0	int
&&	O
horizontal_edge	int
!=	O
0	int
)	O
||	O
(	O
horizontal_edge	int
>	O
0	int
&&	O
vertical_edge	int
<=	O
0	int
)	O
)	O
pos	int
=	O
POS	O
(	O
1	int
,	O
board_size	int
-	O
2	int
)	O
;	O
mx	array
[	O
pos	int
]	O
=	O
EMPTY	int
;	O
mx	array
[	O
NORTH	O
(	O
pos	int
)	O
]	O
=	O
BLACK	int
;	O
mx	array
[	O
NW	O
(	O
pos	int
)	O
]	O
=	O
BLACK	int
;	O
mx	array
[	O
NE	O
(	O
pos	int
)	O
]	O
=	O
EMPTY	int
;	O
mx	array
[	O
WEST	O
(	O
pos	int
)	O
]	O
=	O
BLACK	int
;	O
mx	array
[	O
EAST	O
(	O
pos	int
)	O
]	O
=	O
BLACK	int
;	O
mx	array
[	O
SW	O
(	O
pos	int
)	O
]	O
=	O
EMPTY	int
;	O
mx	array
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
=	O
BLACK	int
;	O
mx	array
[	O
SE	O
(	O
pos	int
)	O
]	O
=	O
BLACK	int
;	O
if	O
(	O
ON_BOARD	O
(	O
NN	O
(	O
pos	int
)	O
)	O
)	O
mx	array
[	O
NN	O
(	O
pos	int
)	O
]	O
=	O
EMPTY	int
;	O
else	O
mx	array
[	O
SS	O
(	O
pos	int
)	O
]	O
=	O
EMPTY	int
;	O
if	O
(	O
ON_BOARD	O
(	O
NN	O
(	O
pos	int
)	O
)	O
)	O
{	O
vertices	pointer
[	O
num_vertices	int
++	O
]	O
=	O
NE	O
(	O
pos	int
)	O
;	O
vertices	pointer
[	O
num_vertices	int
++	O
]	O
=	O
NN	O
(	O
pos	int
)	O
;	O
}	O
else	O
{	O
vertices	pointer
[	O
num_vertices	int
++	O
]	O
=	O
SW	O
(	O
pos	int
)	O
;	O
vertices	pointer
[	O
num_vertices	int
++	O
]	O
=	O
SS	O
(	O
pos	int
)	O
;	O
}	O
mx	array
[	O
POS	O
(	O
0	int
,	O
0	int
)	O
]	O
=	O
EMPTY	int
;	O
vertices	pointer
[	O
num_vertices	int
++	O
]	O
=	O
POS	O
(	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
!	O
add_margins	function
(	O
num_margins	int
,	O
margins	int
,	O
mx	array
)	O
)	O
return	O
0	int
;	O
clear_board	function
(	O
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
{	O
if	O
(	O
mx	array
[	O
pos	int
]	O
==	O
WHITE	int
)	O
add_stone	function
(	O
pos	int
,	O
WHITE	int
)	O
;	O
else	O
if	O
(	O
mx	array
[	O
pos	int
]	O
==	O
BLACK	int
)	O
add_stone	function
(	O
pos	int
,	O
BLACK	int
)	O
;	O
}	O
if	O
(	O
verbose	int
)	O
showboard	function
(	O
0	int
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
WHITE	int
&&	O
!	O
same_string	function
(	O
pos	int
,	O
POS	O
(	O
1	int
,	O
0	int
)	O
)	O
)	O
{	O
vertices	pointer
[	O
num_vertices	int
]	O
=	O
vertices	pointer
[	O
num_vertices	int
-	O
1	int
]	O
;	O
vertices	pointer
[	O
num_vertices	int
-	O
1	int
]	O
=	O
vertices	pointer
[	O
num_vertices	int
-	O
2	int
]	O
;	O
vertices	pointer
[	O
num_vertices	int
-	O
2	int
]	O
=	O
vertices	pointer
[	O
num_vertices	int
-	O
3	int
]	O
;	O
vertices	pointer
[	O
num_vertices	int
-	O
3	int
]	O
=	O
pos	int
;	O
num_vertices	int
++	O
;	O
}	O
if	O
(	O
verbose	int
)	O
{	O
int	O
k	int
;	O
gprintf	function
(	O
"\nPlayable vertices:\n"	pointer
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_vertices	int
;	O
k	int
++	O
)	O
gprintf	function
(	O
"%1m "	pointer
,	O
vertices	pointer
[	O
k	int
]	O
)	O
;	O
gprintf	function
(	O
"\n\n"	pointer
)	O
;	O
}	O
if	O
(	O
num_vertices	int
>	O
17	int
)	O
{	O
gprintf	function
(	O
"analyze_eyegraph: too large eyespace, %d vertices\n"	pointer
,	O
num_vertices	int
)	O
;	O
gg_assert	O
(	O
num_vertices	int
<=	O
17	int
)	O
;	O
}	O
table_size	int
=	O
2	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_vertices	int
;	O
k	int
++	O
)	O
table_size	int
*=	O
3	int
;	O
tactical_life_results	pointer
=	O
malloc	function
(	O
table_size	int
)	O
;	O
if	O
(	O
!	O
tactical_life_results	pointer
)	O
{	O
gprintf	function
(	O
"analyze_eyegraph: failed to allocate %d bytes\n"	pointer
,	O
table_size	int
)	O
;	O
gg_assert	O
(	O
tactical_life_results	pointer
!=	O
NULL	O
)	O
;	O
}	O
memset	function
(	O
tactical_life_results	pointer
,	O
0	int
,	O
table_size	int
)	O
;	O
if	O
(	O
sgf_dumptree	pointer
)	O
sgffile_printboard	function
(	O
sgf_dumptree	pointer
)	O
;	O
evaluate_eyespace	function
(	O
value	pointer
,	O
num_vertices	int
,	O
vertices	pointer
,	O
&	O
num_vital_attacks	pointer
,	O
vital_attacks	pointer
,	O
&	O
num_vital_defenses	pointer
,	O
vital_defenses	pointer
,	O
tactical_life_results	pointer
)	O
;	O
free	function
(	O
tactical_life_results	pointer
)	O
;	O
if	O
(	O
verbose	int
)	O
{	O
gprintf	function
(	O
"Eyevalue: %s\n"	pointer
,	O
eyevalue_to_string	function
(	O
value	pointer
)	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_vital_attacks	pointer
;	O
k	int
++	O
)	O
gprintf	function
(	O
"  vital attack point %1m\n"	pointer
,	O
vital_attacks	pointer
[	O
k	int
]	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_vital_defenses	pointer
;	O
k	int
++	O
)	O
gprintf	function
(	O
"  vital defense point %1m\n"	pointer
,	O
vital_defenses	pointer
[	O
k	int
]	O
)	O
;	O
}	O
memset	function
(	O
mg	array
,	O
' '	O
,	O
sizeof	O
(	O
mg	array
)	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_vertices	int
-	O
2	int
;	O
k	int
++	O
)	O
mg	array
[	O
vertices	pointer
[	O
k	int
]	O
]	O
=	O
(	O
board	pointer
[	O
vertices	pointer
[	O
k	int
]	O
]	O
==	O
BLACK	int
?	O
'X'	O
:	O
'.'	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_margins	int
;	O
k	int
++	O
)	O
mg	array
[	O
margins	int
[	O
k	int
]	O
]	O
=	O
(	O
mg	array
[	O
margins	int
[	O
k	int
]	O
]	O
==	O
'X'	O
?	O
'$'	O
:	O
'!'	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_vital_attacks	pointer
;	O
k	int
++	O
)	O
mg	array
[	O
vital_attacks	pointer
[	O
k	int
]	O
]	O
=	O
(	O
mg	array
[	O
vital_attacks	pointer
[	O
k	int
]	O
]	O
==	O
'!'	O
?	O
'('	O
:	O
'<'	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_vital_defenses	pointer
;	O
k	int
++	O
)	O
{	O
int	O
pos	int
=	O
vital_defenses	pointer
[	O
k	int
]	O
;	O
if	O
(	O
mg	array
[	O
pos	int
]	O
==	O
'.'	O
)	O
mg	array
[	O
pos	int
]	O
=	O
'>'	O
;	O
else	O
if	O
(	O
mg	array
[	O
pos	int
]	O
==	O
'!'	O
)	O
mg	array
[	O
pos	int
]	O
=	O
')'	O
;	O
else	O
if	O
(	O
mg	array
[	O
pos	int
]	O
==	O
'<'	O
)	O
mg	array
[	O
pos	int
]	O
=	O
'*'	O
;	O
else	O
if	O
(	O
mg	array
[	O
pos	int
]	O
==	O
'('	O
)	O
mg	array
[	O
pos	int
]	O
=	O
'@'	O
;	O
}	O
k	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
mini	int
;	O
i	int
<	O
mini	int
+	O
num_rows	int
;	O
i	int
++	O
)	O
{	O
for	O
(	O
j	int
=	O
minj	int
;	O
j	int
<	O
minj	int
+	O
maxwidth	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
(	O
i	int
<	O
0	int
||	O
i	int
>=	O
board_size	int
)	O
&&	O
(	O
j	int
<	O
0	int
||	O
j	int
>=	O
board_size	int
)	O
)	O
analyzed_eyegraph	pointer
[	O
k	int
++	O
]	O
=	O
'+'	O
;	O
else	O
if	O
(	O
i	int
<	O
0	int
||	O
i	int
>=	O
board_size	int
)	O
analyzed_eyegraph	pointer
[	O
k	int
++	O
]	O
=	O
'-'	O
;	O
else	O
if	O
(	O
j	int
<	O
0	int
||	O
j	int
>=	O
board_size	int
)	O
analyzed_eyegraph	pointer
[	O
k	int
++	O
]	O
=	O
'|'	O
;	O
else	O
analyzed_eyegraph	pointer
[	O
k	int
++	O
]	O
=	O
mg	array
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
;	O
}	O
analyzed_eyegraph	pointer
[	O
k	int
++	O
]	O
=	O
'\n'	O
;	O
}	O
analyzed_eyegraph	pointer
[	O
k	int
-	O
1	int
]	O
=	O
0	int
;	O
return	O
1	int
;	O
}	O
