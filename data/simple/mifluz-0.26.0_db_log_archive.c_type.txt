static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: log_archive.c,v 1.3 2000/06/28 16:47:02 loic Exp $"	pointer
;	O
static	O
int	O
__absname	function
__P	O
(	O
(	O
DB_ENV	struct
*	O
,	O
char	O
*	O
,	O
char	O
*	O
,	O
char	O
*	O
*	O
)	O
)	O
;	O
static	O
int	O
__build_data	function
__P	O
(	O
(	O
DB_ENV	struct
*	O
,	O
char	O
*	O
,	O
char	O
*	O
*	O
*	O
,	O
void	O
*	O
(	O
*	O
)	O
(	O
size_t	long
)	O
)	O
)	O
;	O
static	O
int	O
__cmpfunc	function
__P	O
(	O
(	O
const	O
void	O
*	O
,	O
const	O
void	O
*	O
)	O
)	O
;	O
static	O
int	O
__usermem	function
__P	O
(	O
(	O
DB_ENV	struct
*	O
,	O
char	O
*	O
*	O
*	O
,	O
void	O
*	O
(	O
*	O
)	O
(	O
size_t	long
)	O
)	O
)	O
;	O
int	O
CDB_log_archive	function
(	O
dbenv	pointer
,	O
listp	pointer
,	O
flags	int
,	O
db_malloc	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
char	O
*	O
*	O
*	O
listp	pointer
;	O
u_int32_t	int
flags	int
;	O
void	O
*	O
(	O
*	O
db_malloc	pointer
)	O
__P	O
(	O
(	O
size_t	long
)	O
)	O
;	O
{	O
DBT	struct
rec	struct
;	O
DB_LOG	struct
*	O
dblp	pointer
;	O
DB_LSN	struct
stable_lsn	struct
;	O
u_int32_t	int
fnum	int
;	O
int	O
array_size	int
,	O
n	int
,	O
ret	int
;	O
char	O
*	O
*	O
array	pointer
,	O
*	O
*	O
arrayp	pointer
,	O
*	O
name	pointer
,	O
*	O
p	pointer
,	O
*	O
pref	pointer
,	O
buf	pointer
[	O
MAXPATHLEN	int
]	O
;	O
PANIC_CHECK	O
(	O
dbenv	pointer
)	O
;	O
ENV_REQUIRES_CONFIG	O
(	O
dbenv	pointer
,	O
dbenv	pointer
->	O
lg_handle	pointer
,	O
DB_INIT_LOG	int
)	O
;	O
name	pointer
=	O
NULL	O
;	O
dblp	pointer
=	O
dbenv	pointer
->	O
lg_handle	pointer
;	O
COMPQUIET	O
(	O
fnum	int
,	O
0	int
)	O
;	O
if	O
(	O
flags	int
!=	O
0	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_fchk	function
(	O
dbenv	pointer
,	O
"CDB_log_archive"	pointer
,	O
flags	int
,	O
OKFLAGS	O
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_fcchk	function
(	O
dbenv	pointer
,	O
"CDB_log_archive"	pointer
,	O
flags	int
,	O
DB_ARCH_DATA	int
,	O
DB_ARCH_LOG	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
LF_ISSET	O
(	O
DB_ARCH_ABS	int
)	O
)	O
{	O
CDB___os_set_errno	function
(	O
0	int
)	O
;	O
if	O
(	O
(	O
pref	pointer
=	O
getcwd	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
if	O
(	O
CDB___os_get_errno	function
(	O
)	O
==	O
0	int
)	O
CDB___os_set_errno	function
(	O
ENOMEM	int
)	O
;	O
return	O
(	O
CDB___os_get_errno	function
(	O
)	O
)	O
;	O
}	O
}	O
else	O
pref	pointer
=	O
NULL	O
;	O
switch	O
(	O
LF_ISSET	O
(	O
~	O
DB_ARCH_ABS	int
)	O
)	O
{	O
case	O
DB_ARCH_DATA	int
:	O
return	O
(	O
__build_data	function
(	O
dbenv	pointer
,	O
pref	pointer
,	O
listp	pointer
,	O
db_malloc	pointer
)	O
)	O
;	O
case	O
DB_ARCH_LOG	int
:	O
memset	function
(	O
&	O
rec	struct
,	O
0	int
,	O
sizeof	O
(	O
rec	struct
)	O
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
dbenv	pointer
,	O
DB_ENV_THREAD	int
)	O
)	O
F_SET	O
(	O
&	O
rec	struct
,	O
DB_DBT_MALLOC	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_log_get	function
(	O
dbenv	pointer
,	O
&	O
stable_lsn	struct
,	O
&	O
rec	struct
,	O
DB_LAST	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
dbenv	pointer
,	O
DB_ENV_THREAD	int
)	O
)	O
CDB___os_free	function
(	O
rec	struct
.	O
data	pointer
,	O
rec	struct
.	O
size	int
)	O
;	O
fnum	int
=	O
stable_lsn	struct
.	O
file	int
;	O
break	O
;	O
case	O
0	int
:	O
if	O
(	O
(	O
ret	int
=	O
CDB___log_findckp	function
(	O
dbenv	pointer
,	O
&	O
stable_lsn	struct
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
ret	int
!=	O
DB_NOTFOUND	O
)	O
return	O
(	O
ret	int
)	O
;	O
*	O
listp	pointer
=	O
NULL	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
fnum	int
=	O
stable_lsn	struct
.	O
file	int
-	O
1	int
;	O
break	O
;	O
}	O
array_size	int
=	O
10	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbenv	pointer
,	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
array_size	int
,	O
NULL	O
,	O
&	O
array	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
array	pointer
[	O
0	int
]	O
=	O
NULL	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
fnum	int
>	O
0	int
;	O
--	O
fnum	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___log_name	function
(	O
dblp	pointer
,	O
fnum	int
,	O
&	O
name	pointer
,	O
NULL	O
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
CDB___os_exists	function
(	O
name	pointer
,	O
NULL	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
LF_ISSET	O
(	O
DB_ARCH_LOG	int
)	O
&&	O
fnum	int
==	O
stable_lsn	struct
.	O
file	int
)	O
continue	O
;	O
CDB___os_freestr	function
(	O
name	pointer
)	O
;	O
name	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
if	O
(	O
n	int
>=	O
array_size	int
-	O
1	int
)	O
{	O
array_size	int
+=	O
LIST_INCREMENT	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_realloc	function
(	O
dbenv	pointer
,	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
array_size	int
,	O
NULL	O
,	O
&	O
array	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
LF_ISSET	O
(	O
DB_ARCH_ABS	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
__absname	function
(	O
dbenv	pointer
,	O
pref	pointer
,	O
name	pointer
,	O
&	O
array	pointer
[	O
n	int
]	O
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
CDB___os_freestr	function
(	O
name	pointer
)	O
;	O
}	O
else	O
if	O
(	O
(	O
p	pointer
=	O
CDB___db_rpath	function
(	O
name	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_strdup	function
(	O
dbenv	pointer
,	O
p	pointer
+	O
1	int
,	O
&	O
array	pointer
[	O
n	int
]	O
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
CDB___os_freestr	function
(	O
name	pointer
)	O
;	O
}	O
else	O
array	pointer
[	O
n	int
]	O
=	O
name	pointer
;	O
name	pointer
=	O
NULL	O
;	O
array	pointer
[	O
++	O
n	int
]	O
=	O
NULL	O
;	O
}	O
if	O
(	O
n	int
==	O
0	int
)	O
{	O
*	O
listp	pointer
=	O
NULL	O
;	O
ret	int
=	O
0	int
;	O
goto	O
err	pointer
;	O
}	O
qsort	function
(	O
array	pointer
,	O
(	O
size_t	long
)	O
n	int
,	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
__cmpfunc	function
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
__usermem	function
(	O
dbenv	pointer
,	O
&	O
array	pointer
,	O
db_malloc	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
*	O
listp	pointer
=	O
array	pointer
;	O
return	O
(	O
0	int
)	O
;	O
err	pointer
:	O
if	O
(	O
array	pointer
!=	O
NULL	O
)	O
{	O
for	O
(	O
arrayp	pointer
=	O
array	pointer
;	O
*	O
arrayp	pointer
!=	O
NULL	O
;	O
++	O
arrayp	pointer
)	O
CDB___os_freestr	function
(	O
*	O
arrayp	pointer
)	O
;	O
CDB___os_free	function
(	O
array	pointer
,	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
array_size	int
)	O
;	O
}	O
if	O
(	O
name	pointer
!=	O
NULL	O
)	O
CDB___os_freestr	function
(	O
name	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__build_data	function
(	O
dbenv	pointer
,	O
pref	pointer
,	O
listp	pointer
,	O
db_malloc	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
char	O
*	O
pref	pointer
,	O
*	O
*	O
*	O
listp	pointer
;	O
void	O
*	O
(	O
*	O
db_malloc	pointer
)	O
__P	O
(	O
(	O
size_t	long
)	O
)	O
;	O
{	O
DBT	struct
rec	struct
;	O
DB_LSN	struct
lsn	struct
;	O
__log_register_args	struct
*	O
argp	pointer
;	O
u_int32_t	int
rectype	int
;	O
int	O
array_size	int
,	O
last	int
,	O
n	int
,	O
nxt	int
,	O
ret	int
;	O
char	O
*	O
*	O
array	pointer
,	O
*	O
*	O
arrayp	pointer
,	O
*	O
p	pointer
,	O
*	O
real_name	pointer
;	O
array_size	int
=	O
10	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbenv	pointer
,	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
array_size	int
,	O
NULL	O
,	O
&	O
array	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
array	pointer
[	O
0	int
]	O
=	O
NULL	O
;	O
memset	function
(	O
&	O
rec	struct
,	O
0	int
,	O
sizeof	O
(	O
rec	struct
)	O
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
dbenv	pointer
,	O
DB_ENV_THREAD	int
)	O
)	O
F_SET	O
(	O
&	O
rec	struct
,	O
DB_DBT_MALLOC	int
)	O
;	O
for	O
(	O
n	int
=	O
0	int
,	O
ret	int
=	O
CDB_log_get	function
(	O
dbenv	pointer
,	O
&	O
lsn	struct
,	O
&	O
rec	struct
,	O
DB_FIRST	int
)	O
;	O
ret	int
==	O
0	int
;	O
ret	int
=	O
CDB_log_get	function
(	O
dbenv	pointer
,	O
&	O
lsn	struct
,	O
&	O
rec	struct
,	O
DB_NEXT	int
)	O
)	O
{	O
if	O
(	O
rec	struct
.	O
size	int
<	O
sizeof	O
(	O
rectype	int
)	O
)	O
{	O
ret	int
=	O
EINVAL	int
;	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB_log_archive: bad log record"	pointer
)	O
;	O
goto	O
lg_free	O
;	O
}	O
memcpy	function
(	O
&	O
rectype	int
,	O
rec	struct
.	O
data	pointer
,	O
sizeof	O
(	O
rectype	int
)	O
)	O
;	O
if	O
(	O
rectype	int
!=	O
DB_log_register	int
)	O
{	O
if	O
(	O
F_ISSET	O
(	O
dbenv	pointer
,	O
DB_ENV_THREAD	int
)	O
)	O
{	O
CDB___os_free	function
(	O
rec	struct
.	O
data	pointer
,	O
rec	struct
.	O
size	int
)	O
;	O
rec	struct
.	O
data	pointer
=	O
NULL	O
;	O
}	O
continue	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___log_register_read	function
(	O
dbenv	pointer
,	O
rec	struct
.	O
data	pointer
,	O
&	O
argp	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
ret	int
=	O
EINVAL	int
;	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB_log_archive: unable to read log record"	pointer
)	O
;	O
goto	O
lg_free	O
;	O
}	O
if	O
(	O
n	int
>=	O
array_size	int
-	O
1	int
)	O
{	O
array_size	int
+=	O
LIST_INCREMENT	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_realloc	function
(	O
dbenv	pointer
,	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
array_size	int
,	O
NULL	O
,	O
&	O
array	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
lg_free	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_strdup	function
(	O
dbenv	pointer
,	O
argp	pointer
->	O
name	pointer
.	O
data	pointer
,	O
&	O
array	pointer
[	O
n	int
]	O
)	O
)	O
!=	O
0	int
)	O
{	O
lg_free	O
:	O
if	O
(	O
F_ISSET	O
(	O
&	O
rec	struct
,	O
DB_DBT_MALLOC	int
)	O
&&	O
rec	struct
.	O
data	pointer
!=	O
NULL	O
)	O
CDB___os_free	function
(	O
rec	struct
.	O
data	pointer
,	O
rec	struct
.	O
size	int
)	O
;	O
goto	O
err1	O
;	O
}	O
array	pointer
[	O
++	O
n	int
]	O
=	O
NULL	O
;	O
CDB___os_free	function
(	O
argp	pointer
,	O
0	int
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
dbenv	pointer
,	O
DB_ENV_THREAD	int
)	O
)	O
{	O
CDB___os_free	function
(	O
rec	struct
.	O
data	pointer
,	O
rec	struct
.	O
size	int
)	O
;	O
rec	struct
.	O
data	pointer
=	O
NULL	O
;	O
}	O
}	O
if	O
(	O
n	int
==	O
0	int
)	O
{	O
ret	int
=	O
0	int
;	O
*	O
listp	pointer
=	O
NULL	O
;	O
goto	O
err1	O
;	O
}	O
qsort	function
(	O
array	pointer
,	O
(	O
size_t	long
)	O
n	int
,	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
__cmpfunc	function
)	O
;	O
for	O
(	O
last	int
=	O
nxt	int
=	O
0	int
;	O
nxt	int
<	O
n	int
;	O
)	O
{	O
if	O
(	O
last	int
!=	O
nxt	int
)	O
{	O
array	pointer
[	O
last	int
]	O
=	O
array	pointer
[	O
nxt	int
]	O
;	O
array	pointer
[	O
nxt	int
]	O
=	O
NULL	O
;	O
}	O
for	O
(	O
++	O
nxt	int
;	O
nxt	int
<	O
n	int
&&	O
strcmp	function
(	O
array	pointer
[	O
last	int
]	O
,	O
array	pointer
[	O
nxt	int
]	O
)	O
==	O
0	int
;	O
++	O
nxt	int
)	O
{	O
CDB___os_freestr	function
(	O
array	pointer
[	O
nxt	int
]	O
)	O
;	O
array	pointer
[	O
nxt	int
]	O
=	O
NULL	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_appname	function
(	O
dbenv	pointer
,	O
DB_APP_DATA	int
,	O
NULL	O
,	O
array	pointer
[	O
last	int
]	O
,	O
0	int
,	O
NULL	O
,	O
&	O
real_name	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err2	O
;	O
if	O
(	O
CDB___os_exists	function
(	O
real_name	pointer
,	O
NULL	O
)	O
!=	O
0	int
)	O
{	O
CDB___os_freestr	function
(	O
real_name	pointer
)	O
;	O
CDB___os_freestr	function
(	O
array	pointer
[	O
last	int
]	O
)	O
;	O
array	pointer
[	O
last	int
]	O
=	O
NULL	O
;	O
continue	O
;	O
}	O
CDB___os_freestr	function
(	O
array	pointer
[	O
last	int
]	O
)	O
;	O
array	pointer
[	O
last	int
]	O
=	O
NULL	O
;	O
if	O
(	O
pref	pointer
!=	O
NULL	O
)	O
{	O
ret	int
=	O
__absname	function
(	O
dbenv	pointer
,	O
pref	pointer
,	O
real_name	pointer
,	O
&	O
array	pointer
[	O
last	int
]	O
)	O
;	O
CDB___os_freestr	function
(	O
real_name	pointer
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
goto	O
err2	O
;	O
}	O
else	O
if	O
(	O
(	O
p	pointer
=	O
CDB___db_rpath	function
(	O
real_name	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
ret	int
=	O
CDB___os_strdup	function
(	O
dbenv	pointer
,	O
p	pointer
+	O
1	int
,	O
&	O
array	pointer
[	O
last	int
]	O
)	O
;	O
CDB___os_freestr	function
(	O
real_name	pointer
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
goto	O
err2	O
;	O
}	O
else	O
array	pointer
[	O
last	int
]	O
=	O
real_name	pointer
;	O
++	O
last	int
;	O
}	O
array	pointer
[	O
last	int
]	O
=	O
NULL	O
;	O
if	O
(	O
(	O
ret	int
=	O
__usermem	function
(	O
dbenv	pointer
,	O
&	O
array	pointer
,	O
db_malloc	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err1	O
;	O
*	O
listp	pointer
=	O
array	pointer
;	O
return	O
(	O
0	int
)	O
;	O
err2	O
:	O
if	O
(	O
array	pointer
!=	O
NULL	O
)	O
for	O
(	O
;	O
nxt	int
<	O
n	int
;	O
++	O
nxt	int
)	O
CDB___os_freestr	function
(	O
array	pointer
[	O
nxt	int
]	O
)	O
;	O
err1	O
:	O
if	O
(	O
array	pointer
!=	O
NULL	O
)	O
{	O
for	O
(	O
arrayp	pointer
=	O
array	pointer
;	O
*	O
arrayp	pointer
!=	O
NULL	O
;	O
++	O
arrayp	pointer
)	O
CDB___os_freestr	function
(	O
*	O
arrayp	pointer
)	O
;	O
CDB___os_free	function
(	O
array	pointer
,	O
array_size	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
}	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__absname	function
(	O
dbenv	pointer
,	O
pref	pointer
,	O
name	pointer
,	O
newnamep	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
char	O
*	O
pref	pointer
,	O
*	O
name	pointer
,	O
*	O
*	O
newnamep	pointer
;	O
{	O
size_t	long
l_pref	long
,	O
l_name	long
;	O
int	O
isabspath	int
,	O
ret	int
;	O
char	O
*	O
newname	pointer
;	O
l_name	long
=	O
strlen	function
(	O
name	pointer
)	O
;	O
isabspath	int
=	O
CDB___os_abspath	function
(	O
name	pointer
)	O
;	O
l_pref	long
=	O
isabspath	int
?	O
0	int
:	O
strlen	function
(	O
pref	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbenv	pointer
,	O
l_pref	long
+	O
l_name	long
+	O
2	int
,	O
NULL	O
,	O
&	O
newname	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
*	O
newnamep	pointer
=	O
newname	pointer
;	O
if	O
(	O
!	O
isabspath	int
)	O
{	O
memcpy	function
(	O
newname	pointer
,	O
pref	pointer
,	O
l_pref	long
)	O
;	O
if	O
(	O
strchr	function
(	O
PATH_SEPARATOR	pointer
,	O
newname	pointer
[	O
l_pref	long
-	O
1	int
]	O
)	O
==	O
NULL	O
)	O
newname	pointer
[	O
l_pref	long
++	O
]	O
=	O
PATH_SEPARATOR	pointer
[	O
0	int
]	O
;	O
}	O
memcpy	function
(	O
newname	pointer
+	O
l_pref	long
,	O
name	pointer
,	O
l_name	long
+	O
1	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__usermem	function
(	O
dbenv	pointer
,	O
listp	pointer
,	O
db_malloc	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
char	O
*	O
*	O
*	O
listp	pointer
;	O
void	O
*	O
(	O
*	O
db_malloc	pointer
)	O
__P	O
(	O
(	O
size_t	long
)	O
)	O
;	O
{	O
size_t	long
len	int
;	O
int	O
ret	int
;	O
char	O
*	O
*	O
array	pointer
,	O
*	O
*	O
arrayp	pointer
,	O
*	O
*	O
orig	pointer
,	O
*	O
strp	pointer
;	O
for	O
(	O
len	int
=	O
0	int
,	O
orig	pointer
=	O
*	O
listp	pointer
;	O
*	O
orig	pointer
!=	O
NULL	O
;	O
++	O
orig	pointer
)	O
len	int
+=	O
sizeof	O
(	O
char	O
*	O
)	O
+	O
strlen	function
(	O
*	O
orig	pointer
)	O
+	O
1	int
;	O
len	int
+=	O
sizeof	O
(	O
char	O
*	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbenv	pointer
,	O
len	int
,	O
db_malloc	pointer
,	O
&	O
array	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
strp	pointer
=	O
(	O
char	O
*	O
)	O
(	O
array	pointer
+	O
(	O
orig	pointer
-	O
*	O
listp	pointer
)	O
+	O
1	int
)	O
;	O
for	O
(	O
orig	pointer
=	O
*	O
listp	pointer
,	O
arrayp	pointer
=	O
array	pointer
;	O
*	O
orig	pointer
!=	O
NULL	O
;	O
++	O
orig	pointer
,	O
++	O
arrayp	pointer
)	O
{	O
len	int
=	O
strlen	function
(	O
*	O
orig	pointer
)	O
;	O
memcpy	function
(	O
strp	pointer
,	O
*	O
orig	pointer
,	O
len	int
+	O
1	int
)	O
;	O
*	O
arrayp	pointer
=	O
strp	pointer
;	O
strp	pointer
+=	O
len	int
+	O
1	int
;	O
CDB___os_freestr	function
(	O
*	O
orig	pointer
)	O
;	O
}	O
*	O
arrayp	pointer
=	O
NULL	O
;	O
CDB___os_free	function
(	O
*	O
listp	pointer
,	O
0	int
)	O
;	O
*	O
listp	pointer
=	O
array	pointer
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__cmpfunc	function
(	O
p1	pointer
,	O
p2	pointer
)	O
const	O
void	O
*	O
p1	pointer
,	O
*	O
p2	pointer
;	O
{	O
return	O
(	O
strcmp	function
(	O
*	O
(	O
(	O
char	O
*	O
const	O
*	O
)	O
p1	pointer
)	O
,	O
*	O
(	O
(	O
char	O
*	O
const	O
*	O
)	O
p2	pointer
)	O
)	O
)	O
;	O
}	O
