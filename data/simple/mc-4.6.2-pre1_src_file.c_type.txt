int	O
verbose	int
=	O
1	int
;	O
int	O
file_op_compute_totals	int
=	O
1	int
;	O
struct	O
link	function
{	O
struct	O
link	function
*	O
next	pointer
;	O
struct	O
vfs_class	struct
*	O
vfs	pointer
;	O
dev_t	long
dev	int
;	O
ino_t	long
ino	long
;	O
short	O
linkcount	short
;	O
mode_t	int
st_mode	int
;	O
char	O
name	pointer
[	O
1	int
]	O
;	O
}	O
;	O
static	O
struct	O
link	function
*	O
linklist	pointer
=	O
NULL	O
;	O
static	O
struct	O
link	function
*	O
erase_list	pointer
;	O
static	O
struct	O
link	function
*	O
dest_dirs	pointer
=	O
0	int
;	O
const	O
char	O
*	O
op_names	array
[	O
3	int
]	O
=	O
{	O
N_	O
(	O
" Copy "	pointer
)	O
,	O
N_	O
(	O
" Move "	pointer
)	O
,	O
N_	O
(	O
" Delete "	pointer
)	O
}	O
;	O
static	O
int	O
query_replace	function
(	O
FileOpContext	struct
*	O
ctx	pointer
,	O
const	O
char	O
*	O
destname	pointer
,	O
struct	O
stat	struct
*	O
_s_stat	pointer
,	O
struct	O
stat	struct
*	O
_d_stat	pointer
)	O
;	O
static	O
int	O
query_recursive	function
(	O
FileOpContext	struct
*	O
ctx	pointer
,	O
const	O
char	O
*	O
s	pointer
)	O
;	O
static	O
int	O
do_file_error	function
(	O
const	O
char	O
*	O
str	pointer
)	O
;	O
static	O
int	O
erase_dir_iff_empty	function
(	O
FileOpContext	struct
*	O
ctx	pointer
,	O
const	O
char	O
*	O
s	pointer
)	O
;	O
static	O
int	O
erase_file	function
(	O
FileOpContext	struct
*	O
ctx	pointer
,	O
const	O
char	O
*	O
s	pointer
,	O
off_t	long
*	O
progress_count	long
,	O
double	O
*	O
progress_bytes	double
,	O
int	O
is_toplevel_file	int
)	O
;	O
static	O
int	O
files_error	function
(	O
const	O
char	O
*	O
format	pointer
,	O
const	O
char	O
*	O
file1	pointer
,	O
const	O
char	O
*	O
file2	pointer
)	O
;	O
enum	O
CaseConvs	enum
{	O
NO_CONV	int
=	O
0	int
,	O
UP_CHAR	int
=	O
1	int
,	O
LOW_CHAR	int
=	O
2	int
,	O
UP_SECT	int
=	O
4	int
,	O
LOW_SECT	int
=	O
8	int
}	O
;	O
static	O
char	O
convert_case	function
(	O
char	O
c	int
,	O
enum	O
CaseConvs	enum
*	O
conversion	pointer
)	O
{	O
if	O
(	O
*	O
conversion	pointer
&	O
UP_CHAR	int
)	O
{	O
*	O
conversion	pointer
&=	O
~	O
UP_CHAR	int
;	O
return	O
toupper	function
(	O
(	O
unsigned	O
char	O
)	O
c	int
)	O
;	O
}	O
else	O
if	O
(	O
*	O
conversion	pointer
&	O
LOW_CHAR	int
)	O
{	O
*	O
conversion	pointer
&=	O
~	O
LOW_CHAR	int
;	O
return	O
tolower	function
(	O
(	O
unsigned	O
char	O
)	O
c	int
)	O
;	O
}	O
else	O
if	O
(	O
*	O
conversion	pointer
&	O
UP_SECT	int
)	O
{	O
return	O
toupper	function
(	O
(	O
unsigned	O
char	O
)	O
c	int
)	O
;	O
}	O
else	O
if	O
(	O
*	O
conversion	pointer
&	O
LOW_SECT	int
)	O
{	O
return	O
tolower	function
(	O
(	O
unsigned	O
char	O
)	O
c	int
)	O
;	O
}	O
else	O
return	O
c	int
;	O
}	O
static	O
int	O
transform_error	int
=	O
0	int
;	O
static	O
const	O
char	O
*	O
do_transform_source	function
(	O
FileOpContext	struct
*	O
ctx	pointer
,	O
const	O
char	O
*	O
source	pointer
)	O
{	O
size_t	long
j	long
,	O
k	long
,	O
l	pointer
,	O
len	int
;	O
const	O
char	O
*	O
fnsource	pointer
=	O
x_basename	function
(	O
source	pointer
)	O
;	O
int	O
next_reg	int
;	O
enum	O
CaseConvs	enum
case_conv	enum
=	O
NO_CONV	int
;	O
static	O
char	O
fntarget	array
[	O
MC_MAXPATHLEN	O
]	O
;	O
len	int
=	O
strlen	function
(	O
fnsource	pointer
)	O
;	O
j	long
=	O
re_match	function
(	O
&	O
ctx	pointer
->	O
rx	struct
,	O
fnsource	pointer
,	O
len	int
,	O
0	int
,	O
&	O
ctx	pointer
->	O
regs	struct
)	O
;	O
if	O
(	O
j	long
!=	O
len	int
)	O
{	O
transform_error	int
=	O
FILE_SKIP	int
;	O
return	O
NULL	O
;	O
}	O
for	O
(	O
next_reg	int
=	O
1	int
,	O
j	long
=	O
0	int
,	O
k	long
=	O
0	int
;	O
j	long
<	O
strlen	function
(	O
ctx	pointer
->	O
dest_mask	pointer
)	O
;	O
j	long
++	O
)	O
{	O
switch	O
(	O
ctx	pointer
->	O
dest_mask	pointer
[	O
j	long
]	O
)	O
{	O
case	O
'\\'	O
:	O
j	long
++	O
;	O
if	O
(	O
!	O
isdigit	function
(	O
(	O
unsigned	O
char	O
)	O
ctx	pointer
->	O
dest_mask	pointer
[	O
j	long
]	O
)	O
)	O
{	O
switch	O
(	O
ctx	pointer
->	O
dest_mask	pointer
[	O
j	long
]	O
)	O
{	O
case	O
'U'	O
:	O
case_conv	enum
|=	O
UP_SECT	int
;	O
case_conv	enum
&=	O
~	O
LOW_SECT	int
;	O
break	O
;	O
case	O
'u'	O
:	O
case_conv	enum
|=	O
UP_CHAR	int
;	O
break	O
;	O
case	O
'L'	O
:	O
case_conv	enum
|=	O
LOW_SECT	int
;	O
case_conv	enum
&=	O
~	O
UP_SECT	int
;	O
break	O
;	O
case	O
'l'	O
:	O
case_conv	enum
|=	O
LOW_CHAR	int
;	O
break	O
;	O
case	O
'E'	O
:	O
case_conv	enum
=	O
NO_CONV	int
;	O
break	O
;	O
default	O
:	O
fntarget	array
[	O
k	long
++	O
]	O
=	O
convert_case	function
(	O
ctx	pointer
->	O
dest_mask	pointer
[	O
j	long
]	O
,	O
&	O
case_conv	enum
)	O
;	O
}	O
break	O
;	O
}	O
else	O
{	O
next_reg	int
=	O
ctx	pointer
->	O
dest_mask	pointer
[	O
j	long
]	O
-	O
'0'	O
;	O
}	O
case	O
'*'	O
:	O
if	O
(	O
next_reg	int
<	O
0	int
||	O
next_reg	int
>=	O
RE_NREGS	int
||	O
ctx	pointer
->	O
regs	struct
.	O
start	pointer
[	O
next_reg	int
]	O
<	O
0	int
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" Invalid target mask "	pointer
)	O
)	O
;	O
transform_error	int
=	O
FILE_ABORT	int
;	O
return	O
NULL	O
;	O
}	O
for	O
(	O
l	pointer
=	O
(	O
size_t	long
)	O
ctx	pointer
->	O
regs	struct
.	O
start	pointer
[	O
next_reg	int
]	O
;	O
l	pointer
<	O
(	O
size_t	long
)	O
ctx	pointer
->	O
regs	struct
.	O
end	pointer
[	O
next_reg	int
]	O
;	O
l	pointer
++	O
)	O
fntarget	array
[	O
k	long
++	O
]	O
=	O
convert_case	function
(	O
fnsource	pointer
[	O
l	pointer
]	O
,	O
&	O
case_conv	enum
)	O
;	O
next_reg	int
++	O
;	O
break	O
;	O
default	O
:	O
fntarget	array
[	O
k	long
++	O
]	O
=	O
convert_case	function
(	O
ctx	pointer
->	O
dest_mask	pointer
[	O
j	long
]	O
,	O
&	O
case_conv	enum
)	O
;	O
break	O
;	O
}	O
}	O
fntarget	array
[	O
k	long
]	O
=	O
0	int
;	O
return	O
fntarget	array
;	O
}	O
static	O
const	O
char	O
*	O
transform_source	function
(	O
FileOpContext	struct
*	O
ctx	pointer
,	O
const	O
char	O
*	O
source	pointer
)	O
{	O
char	O
*	O
s	pointer
=	O
g_strdup	function
(	O
source	pointer
)	O
;	O
char	O
*	O
q	pointer
;	O
const	O
char	O
*	O
p	pointer
;	O
for	O
(	O
q	pointer
=	O
s	pointer
;	O
*	O
q	pointer
;	O
q	pointer
++	O
)	O
{	O
if	O
(	O
*	O
q	pointer
==	O
'\n'	O
)	O
*	O
q	pointer
=	O
' '	O
;	O
}	O
p	pointer
=	O
do_transform_source	function
(	O
ctx	pointer
,	O
s	pointer
)	O
;	O
g_free	function
(	O
s	pointer
)	O
;	O
return	O
p	pointer
;	O
}	O
static	O
void	O
free_linklist	function
(	O
struct	O
link	function
*	O
*	O
linklist	pointer
)	O
{	O
struct	O
link	function
*	O
lp	pointer
,	O
*	O
lp2	pointer
;	O
for	O
(	O
lp	pointer
=	O
*	O
linklist	pointer
;	O
lp	pointer
!=	O
NULL	O
;	O
lp	pointer
=	O
lp2	pointer
)	O
{	O
lp2	pointer
=	O
lp	pointer
->	O
next	pointer
;	O
g_free	function
(	O
lp	pointer
)	O
;	O
}	O
*	O
linklist	pointer
=	O
NULL	O
;	O
}	O
static	O
int	O
is_in_linklist	function
(	O
struct	O
link	function
*	O
lp	pointer
,	O
const	O
char	O
*	O
path	pointer
,	O
struct	O
stat	struct
*	O
sb	pointer
)	O
{	O
ino_t	long
ino	long
=	O
sb	pointer
->	O
st_ino	long
;	O
dev_t	long
dev	int
=	O
sb	pointer
->	O
st_dev	long
;	O
struct	O
vfs_class	struct
*	O
vfs	pointer
=	O
vfs_get_class	function
(	O
path	pointer
)	O
;	O
while	O
(	O
lp	pointer
)	O
{	O
if	O
(	O
lp	pointer
->	O
vfs	pointer
==	O
vfs	pointer
)	O
if	O
(	O
lp	pointer
->	O
ino	long
==	O
ino	long
&&	O
lp	pointer
->	O
dev	int
==	O
dev	int
)	O
return	O
1	int
;	O
lp	pointer
=	O
lp	pointer
->	O
next	pointer
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
check_hardlinks	function
(	O
const	O
char	O
*	O
src_name	pointer
,	O
const	O
char	O
*	O
dst_name	pointer
,	O
struct	O
stat	struct
*	O
pstat	pointer
)	O
{	O
struct	O
link	function
*	O
lp	pointer
;	O
struct	O
vfs_class	struct
*	O
my_vfs	pointer
=	O
vfs_get_class	function
(	O
src_name	pointer
)	O
;	O
ino_t	long
ino	long
=	O
pstat	pointer
->	O
st_ino	long
;	O
dev_t	long
dev	int
=	O
pstat	pointer
->	O
st_dev	long
;	O
struct	O
stat	struct
link_stat	struct
;	O
const	O
char	O
*	O
p	pointer
;	O
if	O
(	O
vfs_file_class_flags	function
(	O
src_name	pointer
)	O
&	O
VFSF_NOLINKS	int
)	O
return	O
0	int
;	O
for	O
(	O
lp	pointer
=	O
linklist	pointer
;	O
lp	pointer
!=	O
NULL	O
;	O
lp	pointer
=	O
lp	pointer
->	O
next	pointer
)	O
if	O
(	O
lp	pointer
->	O
vfs	pointer
==	O
my_vfs	pointer
&&	O
lp	pointer
->	O
ino	long
==	O
ino	long
&&	O
lp	pointer
->	O
dev	int
==	O
dev	int
)	O
{	O
if	O
(	O
!	O
mc_stat	function
(	O
lp	pointer
->	O
name	pointer
,	O
&	O
link_stat	struct
)	O
&&	O
link_stat	struct
.	O
st_ino	long
==	O
ino	long
&&	O
link_stat	struct
.	O
st_dev	long
==	O
dev	int
&&	O
vfs_get_class	function
(	O
lp	pointer
->	O
name	pointer
)	O
==	O
my_vfs	pointer
)	O
{	O
p	pointer
=	O
strchr	function
(	O
lp	pointer
->	O
name	pointer
,	O
0	int
)	O
+	O
1	int
;	O
if	O
(	O
vfs_get_class	function
(	O
dst_name	pointer
)	O
==	O
vfs_get_class	function
(	O
p	pointer
)	O
)	O
{	O
if	O
(	O
!	O
mc_stat	function
(	O
p	pointer
,	O
&	O
link_stat	struct
)	O
)	O
{	O
if	O
(	O
!	O
mc_link	function
(	O
p	pointer
,	O
dst_name	pointer
)	O
)	O
return	O
1	int
;	O
}	O
}	O
}	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" Cannot make the hardlink "	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
lp	pointer
=	O
(	O
struct	O
link	function
*	O
)	O
g_malloc	function
(	O
sizeof	O
(	O
struct	O
link	function
)	O
+	O
strlen	function
(	O
src_name	pointer
)	O
+	O
strlen	function
(	O
dst_name	pointer
)	O
+	O
1	int
)	O
;	O
if	O
(	O
lp	pointer
)	O
{	O
char	O
*	O
lpdstname	pointer
;	O
lp	pointer
->	O
vfs	pointer
=	O
my_vfs	pointer
;	O
lp	pointer
->	O
ino	long
=	O
ino	long
;	O
lp	pointer
->	O
dev	int
=	O
dev	int
;	O
strcpy	function
(	O
lp	pointer
->	O
name	pointer
,	O
src_name	pointer
)	O
;	O
lpdstname	pointer
=	O
lp	pointer
->	O
name	pointer
+	O
strlen	function
(	O
lp	pointer
->	O
name	pointer
)	O
+	O
1	int
;	O
strcpy	function
(	O
lpdstname	pointer
,	O
dst_name	pointer
)	O
;	O
lp	pointer
->	O
next	pointer
=	O
linklist	pointer
;	O
linklist	pointer
=	O
lp	pointer
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
make_symlink	function
(	O
FileOpContext	struct
*	O
ctx	pointer
,	O
const	O
char	O
*	O
src_path	pointer
,	O
const	O
char	O
*	O
dst_path	pointer
)	O
{	O
char	O
link_target	array
[	O
MC_MAXPATHLEN	O
]	O
;	O
int	O
len	int
;	O
int	O
return_status	int
;	O
struct	O
stat	struct
sb	pointer
;	O
int	O
dst_is_symlink	int
;	O
if	O
(	O
mc_lstat	function
(	O
dst_path	pointer
,	O
&	O
sb	pointer
)	O
==	O
0	int
&&	O
S_ISLNK	O
(	O
sb	pointer
.	O
st_mode	int
)	O
)	O
dst_is_symlink	int
=	O
1	int
;	O
else	O
dst_is_symlink	int
=	O
0	int
;	O
retry_src_readlink	O
:	O
len	int
=	O
mc_readlink	function
(	O
src_path	pointer
,	O
link_target	array
,	O
MC_MAXPATHLEN	O
-	O
1	int
)	O
;	O
if	O
(	O
len	int
<	O
0	int
)	O
{	O
return_status	int
=	O
file_error	function
(	O
_	O
(	O
" Cannot read source link \"%s\" \n %s "	pointer
)	O
,	O
src_path	pointer
)	O
;	O
if	O
(	O
return_status	int
==	O
FILE_RETRY	int
)	O
goto	O
retry_src_readlink	O
;	O
return	O
return_status	int
;	O
}	O
link_target	array
[	O
len	int
]	O
=	O
0	int
;	O
if	O
(	O
ctx	pointer
->	O
stable_symlinks	int
)	O
if	O
(	O
!	O
vfs_file_is_local	function
(	O
src_path	pointer
)	O
||	O
!	O
vfs_file_is_local	function
(	O
dst_path	pointer
)	O
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" Cannot make stable symlinks across "	pointer
"non-local filesystems: \n\n"	pointer
" Option Stable Symlinks will be disabled "	pointer
)	O
)	O
;	O
ctx	pointer
->	O
stable_symlinks	int
=	O
0	int
;	O
}	O
if	O
(	O
ctx	pointer
->	O
stable_symlinks	int
&&	O
*	O
link_target	array
!=	O
PATH_SEP	char
)	O
{	O
char	O
*	O
p	pointer
,	O
*	O
q	pointer
,	O
*	O
s	pointer
;	O
const	O
char	O
*	O
r	pointer
=	O
strrchr	function
(	O
src_path	pointer
,	O
PATH_SEP	char
)	O
;	O
if	O
(	O
r	pointer
)	O
{	O
p	pointer
=	O
g_strndup	function
(	O
src_path	pointer
,	O
r	pointer
-	O
src_path	pointer
+	O
1	int
)	O
;	O
if	O
(	O
*	O
dst_path	pointer
==	O
PATH_SEP	char
)	O
q	pointer
=	O
g_strdup	function
(	O
dst_path	pointer
)	O
;	O
else	O
q	pointer
=	O
g_strconcat	function
(	O
p	pointer
,	O
dst_path	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
s	pointer
=	O
strrchr	function
(	O
q	pointer
,	O
PATH_SEP	char
)	O
;	O
if	O
(	O
s	pointer
)	O
{	O
s	pointer
[	O
1	int
]	O
=	O
0	int
;	O
s	pointer
=	O
g_strconcat	function
(	O
p	pointer
,	O
link_target	array
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
g_free	function
(	O
p	pointer
)	O
;	O
g_strlcpy	function
(	O
link_target	array
,	O
s	pointer
,	O
sizeof	O
(	O
link_target	array
)	O
)	O
;	O
g_free	function
(	O
s	pointer
)	O
;	O
s	pointer
=	O
diff_two_paths	function
(	O
q	pointer
,	O
link_target	array
)	O
;	O
if	O
(	O
s	pointer
)	O
{	O
g_strlcpy	function
(	O
link_target	array
,	O
s	pointer
,	O
sizeof	O
(	O
link_target	array
)	O
)	O
;	O
g_free	function
(	O
s	pointer
)	O
;	O
}	O
}	O
else	O
g_free	function
(	O
p	pointer
)	O
;	O
g_free	function
(	O
q	pointer
)	O
;	O
}	O
}	O
retry_dst_symlink	O
:	O
if	O
(	O
mc_symlink	function
(	O
link_target	array
,	O
dst_path	pointer
)	O
==	O
0	int
)	O
return	O
FILE_CONT	int
;	O
if	O
(	O
dst_is_symlink	int
)	O
{	O
if	O
(	O
!	O
mc_unlink	function
(	O
dst_path	pointer
)	O
)	O
if	O
(	O
mc_symlink	function
(	O
link_target	array
,	O
dst_path	pointer
)	O
==	O
0	int
)	O
return	O
FILE_CONT	int
;	O
}	O
return_status	int
=	O
file_error	function
(	O
_	O
(	O
" Cannot create target symlink \"%s\" \n %s "	pointer
)	O
,	O
dst_path	pointer
)	O
;	O
if	O
(	O
return_status	int
==	O
FILE_RETRY	int
)	O
goto	O
retry_dst_symlink	O
;	O
return	O
return_status	int
;	O
}	O
static	O
int	O
progress_update_one	function
(	O
FileOpContext	struct
*	O
ctx	pointer
,	O
off_t	long
*	O
progress_count	long
,	O
double	O
*	O
progress_bytes	double
,	O
off_t	long
add	long
,	O
int	O
is_toplevel_file	int
)	O
{	O
int	O
ret	int
;	O
if	O
(	O
is_toplevel_file	int
||	O
ctx	pointer
->	O
progress_totals_computed	int
)	O
{	O
(	O
*	O
progress_count	long
)	O
++	O
;	O
(	O
*	O
progress_bytes	double
)	O
+=	O
add	long
;	O
}	O
ret	int
=	O
file_progress_show_count	function
(	O
ctx	pointer
,	O
*	O
progress_count	long
,	O
ctx	pointer
->	O
progress_count	long
)	O
;	O
if	O
(	O
ret	int
!=	O
FILE_CONT	int
)	O
return	O
ret	int
;	O
ret	int
=	O
file_progress_show_bytes	function
(	O
ctx	pointer
,	O
*	O
progress_bytes	double
,	O
ctx	pointer
->	O
progress_bytes	double
)	O
;	O
return	O
ret	int
;	O
}	O
enum	O
{	O
DEST_NONE	int
,	O
DEST_SHORT	int
,	O
DEST_FULL	int
}	O
;	O
int	O
copy_file_file	function
(	O
FileOpContext	struct
*	O
ctx	pointer
,	O
const	O
char	O
*	O
src_path	pointer
,	O
const	O
char	O
*	O
dst_path	pointer
,	O
int	O
ask_overwrite	int
,	O
off_t	long
*	O
progress_count	long
,	O
double	O
*	O
progress_bytes	double
,	O
int	O
is_toplevel_file	int
)	O
{	O
uid_t	int
src_uid	int
=	O
(	O
uid_t	int
)	O
-	O
1	int
;	O
gid_t	int
src_gid	int
=	O
(	O
gid_t	int
)	O
-	O
1	int
;	O
char	O
*	O
buf	pointer
=	O
NULL	O
;	O
int	O
buf_size	long
=	O
BUF_8K	int
;	O
int	O
src_desc	int
,	O
dest_desc	int
=	O
-	O
1	int
;	O
int	O
n_read	int
,	O
n_written	int
;	O
mode_t	int
src_mode	int
=	O
0	int
;	O
struct	O
stat	struct
sb	pointer
,	O
sb2	struct
;	O
struct	O
utimbuf	struct
utb	struct
;	O
int	O
dst_exists	int
=	O
0	int
,	O
appending	int
=	O
0	int
;	O
off_t	long
n_read_total	long
=	O
0	int
,	O
file_size	long
=	O
-	O
1	int
;	O
int	O
return_status	int
,	O
temp_status	int
;	O
struct	O
timeval	struct
tv_transfer_start	struct
;	O
int	O
dst_status	int
=	O
DEST_NONE	int
;	O
ctx	pointer
->	O
do_reget	long
=	O
0	int
;	O
return_status	int
=	O
FILE_RETRY	int
;	O
if	O
(	O
file_progress_show_source	function
(	O
ctx	pointer
,	O
src_path	pointer
)	O
==	O
FILE_ABORT	int
||	O
file_progress_show_target	function
(	O
ctx	pointer
,	O
dst_path	pointer
)	O
==	O
FILE_ABORT	int
)	O
return	O
FILE_ABORT	int
;	O
mc_refresh	function
(	O
)	O
;	O
while	O
(	O
mc_stat	function
(	O
dst_path	pointer
,	O
&	O
sb2	struct
)	O
==	O
0	int
)	O
{	O
if	O
(	O
S_ISDIR	O
(	O
sb2	struct
.	O
st_mode	int
)	O
)	O
{	O
return_status	int
=	O
file_error	function
(	O
_	O
(	O
" Cannot overwrite directory \"%s\" \n %s "	pointer
)	O
,	O
dst_path	pointer
)	O
;	O
if	O
(	O
return_status	int
==	O
FILE_RETRY	int
)	O
continue	O
;	O
return	O
return_status	int
;	O
}	O
dst_exists	int
=	O
1	int
;	O
break	O
;	O
}	O
while	O
(	O
(	O
*	O
ctx	pointer
->	O
stat_func	pointer
)	O
(	O
src_path	pointer
,	O
&	O
sb	pointer
)	O
)	O
{	O
return_status	int
=	O
file_error	function
(	O
_	O
(	O
" Cannot stat source file \"%s\" \n %s "	pointer
)	O
,	O
src_path	pointer
)	O
;	O
if	O
(	O
return_status	int
!=	O
FILE_RETRY	int
)	O
return	O
return_status	int
;	O
}	O
if	O
(	O
dst_exists	int
)	O
{	O
if	O
(	O
sb	pointer
.	O
st_dev	long
==	O
sb2	struct
.	O
st_dev	long
&&	O
sb	pointer
.	O
st_ino	long
==	O
sb2	struct
.	O
st_ino	long
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" `%s' and `%s' are the same file "	pointer
)	O
,	O
src_path	pointer
,	O
dst_path	pointer
)	O
;	O
do_refresh	function
(	O
)	O
;	O
return	O
FILE_SKIP	int
;	O
}	O
if	O
(	O
ask_overwrite	int
)	O
{	O
ctx	pointer
->	O
do_reget	long
=	O
0	int
;	O
return_status	int
=	O
query_replace	function
(	O
ctx	pointer
,	O
dst_path	pointer
,	O
&	O
sb	pointer
,	O
&	O
sb2	struct
)	O
;	O
if	O
(	O
return_status	int
!=	O
FILE_CONT	int
)	O
return	O
return_status	int
;	O
}	O
}	O
if	O
(	O
!	O
ctx	pointer
->	O
do_append	int
)	O
{	O
if	O
(	O
!	O
ctx	pointer
->	O
follow_links	int
&&	O
sb	pointer
.	O
st_nlink	long
>	O
1	int
&&	O
check_hardlinks	function
(	O
src_path	pointer
,	O
dst_path	pointer
,	O
&	O
sb	pointer
)	O
==	O
1	int
)	O
{	O
return	O
FILE_CONT	int
;	O
}	O
if	O
(	O
S_ISLNK	O
(	O
sb	pointer
.	O
st_mode	int
)	O
)	O
{	O
int	O
retval	pointer
;	O
retval	pointer
=	O
make_symlink	function
(	O
ctx	pointer
,	O
src_path	pointer
,	O
dst_path	pointer
)	O
;	O
return	O
retval	pointer
;	O
}	O
if	O
(	O
S_ISCHR	O
(	O
sb	pointer
.	O
st_mode	int
)	O
||	O
S_ISBLK	O
(	O
sb	pointer
.	O
st_mode	int
)	O
||	O
S_ISFIFO	O
(	O
sb	pointer
.	O
st_mode	int
)	O
||	O
S_ISNAM	int
(	O
sb	pointer
.	O
st_mode	int
)	O
||	O
S_ISSOCK	O
(	O
sb	pointer
.	O
st_mode	int
)	O
)	O
{	O
while	O
(	O
mc_mknod	function
(	O
dst_path	pointer
,	O
sb	pointer
.	O
st_mode	int
&	O
ctx	pointer
->	O
umask_kill	int
,	O
sb	pointer
.	O
st_rdev	long
)	O
<	O
0	int
)	O
{	O
return_status	int
=	O
file_error	function
(	O
_	O
(	O
" Cannot create special file \"%s\" \n %s "	pointer
)	O
,	O
dst_path	pointer
)	O
;	O
if	O
(	O
return_status	int
==	O
FILE_RETRY	int
)	O
continue	O
;	O
return	O
return_status	int
;	O
}	O
while	O
(	O
ctx	pointer
->	O
preserve_uidgid	int
&&	O
mc_chown	function
(	O
dst_path	pointer
,	O
sb	pointer
.	O
st_uid	int
,	O
sb	pointer
.	O
st_gid	int
)	O
)	O
{	O
temp_status	int
=	O
file_error	function
(	O
_	O
(	O
" Cannot chown target file \"%s\" \n %s "	pointer
)	O
,	O
dst_path	pointer
)	O
;	O
if	O
(	O
temp_status	int
==	O
FILE_RETRY	int
)	O
continue	O
;	O
return	O
temp_status	int
;	O
}	O
while	O
(	O
ctx	pointer
->	O
preserve	int
&&	O
mc_chmod	function
(	O
dst_path	pointer
,	O
sb	pointer
.	O
st_mode	int
&	O
ctx	pointer
->	O
umask_kill	int
)	O
)	O
{	O
temp_status	int
=	O
file_error	function
(	O
_	O
(	O
" Cannot chmod target file \"%s\" \n %s "	pointer
)	O
,	O
dst_path	pointer
)	O
;	O
if	O
(	O
temp_status	int
==	O
FILE_RETRY	int
)	O
continue	O
;	O
return	O
temp_status	int
;	O
}	O
return	O
FILE_CONT	int
;	O
}	O
}	O
gettimeofday	function
(	O
&	O
tv_transfer_start	struct
,	O
(	O
struct	O
timezone	short
*	O
)	O
NULL	O
)	O
;	O
while	O
(	O
(	O
src_desc	int
=	O
mc_open	function
(	O
src_path	pointer
,	O
O_RDONLY	int
|	O
O_LINEAR	O
)	O
)	O
<	O
0	int
)	O
{	O
return_status	int
=	O
file_error	function
(	O
_	O
(	O
" Cannot open source file \"%s\" \n %s "	pointer
)	O
,	O
src_path	pointer
)	O
;	O
if	O
(	O
return_status	int
==	O
FILE_RETRY	int
)	O
continue	O
;	O
ctx	pointer
->	O
do_append	int
=	O
0	int
;	O
return	O
return_status	int
;	O
}	O
if	O
(	O
ctx	pointer
->	O
do_reget	long
)	O
{	O
if	O
(	O
mc_lseek	function
(	O
src_desc	int
,	O
ctx	pointer
->	O
do_reget	long
,	O
SEEK_SET	int
)	O
!=	O
ctx	pointer
->	O
do_reget	long
)	O
{	O
message	pointer
(	O
1	int
,	O
_	O
(	O
"Warning"	pointer
)	O
,	O
_	O
(	O
" Reget failed, about to overwrite file "	pointer
)	O
)	O
;	O
ctx	pointer
->	O
do_reget	long
=	O
ctx	pointer
->	O
do_append	int
=	O
0	int
;	O
}	O
}	O
while	O
(	O
mc_fstat	function
(	O
src_desc	int
,	O
&	O
sb	pointer
)	O
)	O
{	O
return_status	int
=	O
file_error	function
(	O
_	O
(	O
" Cannot fstat source file \"%s\" \n %s "	pointer
)	O
,	O
src_path	pointer
)	O
;	O
if	O
(	O
return_status	int
==	O
FILE_RETRY	int
)	O
continue	O
;	O
ctx	pointer
->	O
do_append	int
=	O
0	int
;	O
goto	O
ret	int
;	O
}	O
src_mode	int
=	O
sb	pointer
.	O
st_mode	int
;	O
src_uid	int
=	O
sb	pointer
.	O
st_uid	int
;	O
src_gid	int
=	O
sb	pointer
.	O
st_gid	int
;	O
utb	struct
.	O
actime	long
=	O
sb	pointer
.	O
st_atime	O
;	O
utb	struct
.	O
modtime	long
=	O
sb	pointer
.	O
st_mtime	O
;	O
file_size	long
=	O
sb	pointer
.	O
st_size	long
;	O
while	O
(	O
(	O
dest_desc	int
=	O
mc_open	function
(	O
dst_path	pointer
,	O
O_WRONLY	int
|	O
(	O
ctx	pointer
->	O
do_append	int
?	O
O_APPEND	int
:	O
(	O
O_CREAT	int
|	O
O_TRUNC	int
)	O
)	O
,	O
0600	int
)	O
)	O
<	O
0	int
)	O
{	O
return_status	int
=	O
file_error	function
(	O
_	O
(	O
" Cannot create target file \"%s\" \n %s "	pointer
)	O
,	O
dst_path	pointer
)	O
;	O
if	O
(	O
return_status	int
==	O
FILE_RETRY	int
)	O
continue	O
;	O
ctx	pointer
->	O
do_append	int
=	O
0	int
;	O
goto	O
ret	int
;	O
}	O
dst_status	int
=	O
DEST_SHORT	int
;	O
appending	int
=	O
ctx	pointer
->	O
do_append	int
;	O
ctx	pointer
->	O
do_append	int
=	O
0	int
;	O
while	O
(	O
mc_fstat	function
(	O
dest_desc	int
,	O
&	O
sb	pointer
)	O
)	O
{	O
return_status	int
=	O
file_error	function
(	O
_	O
(	O
" Cannot fstat target file \"%s\" \n %s "	pointer
)	O
,	O
dst_path	pointer
)	O
;	O
if	O
(	O
return_status	int
==	O
FILE_RETRY	int
)	O
continue	O
;	O
goto	O
ret	int
;	O
}	O
buf	pointer
=	O
g_malloc	function
(	O
buf_size	long
)	O
;	O
ctx	pointer
->	O
eta_secs	double
=	O
0.0	int
;	O
ctx	pointer
->	O
bps	long
=	O
0	int
;	O
return_status	int
=	O
file_progress_show	function
(	O
ctx	pointer
,	O
0	int
,	O
file_size	long
)	O
;	O
mc_refresh	function
(	O
)	O
;	O
if	O
(	O
return_status	int
!=	O
FILE_CONT	int
)	O
goto	O
ret	int
;	O
{	O
struct	O
timeval	struct
tv_current	struct
,	O
tv_last_update	struct
,	O
tv_last_input	struct
;	O
int	O
secs	int
,	O
update_secs	int
;	O
long	O
dt	long
;	O
const	O
char	O
*	O
stalled_msg	pointer
;	O
tv_last_update	struct
=	O
tv_transfer_start	struct
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
mc_ctl	function
(	O
src_desc	int
,	O
VFS_CTL_IS_NOTREADY	int
,	O
0	int
)	O
)	O
n_read	int
=	O
-	O
1	int
;	O
else	O
while	O
(	O
(	O
n_read	int
=	O
mc_read	function
(	O
src_desc	int
,	O
buf	pointer
,	O
buf_size	long
)	O
)	O
<	O
0	int
)	O
{	O
return_status	int
=	O
file_error	function
(	O
_	O
(	O
" Cannot read source file \"%s\" \n %s "	pointer
)	O
,	O
src_path	pointer
)	O
;	O
if	O
(	O
return_status	int
==	O
FILE_RETRY	int
)	O
continue	O
;	O
goto	O
ret	int
;	O
}	O
if	O
(	O
n_read	int
==	O
0	int
)	O
break	O
;	O
gettimeofday	function
(	O
&	O
tv_current	struct
,	O
NULL	O
)	O
;	O
if	O
(	O
n_read	int
>	O
0	int
)	O
{	O
char	O
*	O
t	long
=	O
buf	pointer
;	O
n_read_total	long
+=	O
n_read	int
;	O
if	O
(	O
!	O
(	O
src_mode	int
&	O
(	O
S_IRWXU	O
|	O
S_IRWXG	O
|	O
S_IRWXO	O
)	O
)	O
)	O
src_mode	int
=	O
S_IRUSR	O
|	O
S_IWUSR	O
|	O
S_IRGRP	O
|	O
S_IROTH	O
;	O
gettimeofday	function
(	O
&	O
tv_last_input	struct
,	O
NULL	O
)	O
;	O
while	O
(	O
(	O
n_written	int
=	O
mc_write	function
(	O
dest_desc	int
,	O
t	long
,	O
n_read	int
)	O
)	O
<	O
n_read	int
)	O
{	O
if	O
(	O
n_written	int
>	O
0	int
)	O
{	O
n_read	int
-=	O
n_written	int
;	O
t	long
+=	O
n_written	int
;	O
continue	O
;	O
}	O
return_status	int
=	O
file_error	function
(	O
_	O
(	O
" Cannot write target file \"%s\" \n %s "	pointer
)	O
,	O
dst_path	pointer
)	O
;	O
if	O
(	O
return_status	int
!=	O
FILE_RETRY	int
)	O
goto	O
ret	int
;	O
}	O
}	O
secs	int
=	O
(	O
tv_current	struct
.	O
tv_sec	long
-	O
tv_last_update	struct
.	O
tv_sec	long
)	O
;	O
if	O
(	O
secs	int
>	O
2	int
)	O
{	O
rotate_dash	function
(	O
)	O
;	O
tv_last_update	struct
=	O
tv_current	struct
;	O
}	O
update_secs	int
=	O
(	O
tv_current	struct
.	O
tv_sec	long
-	O
tv_last_input	struct
.	O
tv_sec	long
)	O
;	O
stalled_msg	pointer
=	O
""	pointer
;	O
if	O
(	O
update_secs	int
>	O
4	int
)	O
{	O
stalled_msg	pointer
=	O
_	O
(	O
"(stalled)"	pointer
)	O
;	O
}	O
if	O
(	O
secs	int
>	O
2	int
)	O
{	O
dt	long
=	O
(	O
tv_current	struct
.	O
tv_sec	long
-	O
tv_transfer_start	struct
.	O
tv_sec	long
)	O
;	O
if	O
(	O
n_read_total	long
)	O
{	O
ctx	pointer
->	O
eta_secs	double
=	O
(	O
(	O
dt	long
/	O
(	O
double	O
)	O
n_read_total	long
)	O
*	O
file_size	long
)	O
-	O
dt	long
;	O
ctx	pointer
->	O
bps	long
=	O
n_read_total	long
/	O
(	O
(	O
dt	long
<	O
1	int
)	O
?	O
1	int
:	O
dt	long
)	O
;	O
}	O
else	O
ctx	pointer
->	O
eta_secs	double
=	O
0.0	int
;	O
}	O
if	O
(	O
secs	int
>	O
2	int
)	O
{	O
ctx	pointer
->	O
bps_time	long
=	O
(	O
tv_current	struct
.	O
tv_sec	long
-	O
tv_transfer_start	struct
.	O
tv_sec	long
)	O
;	O
if	O
(	O
ctx	pointer
->	O
bps_time	long
<	O
1	int
)	O
ctx	pointer
->	O
bps_time	long
=	O
1	int
;	O
ctx	pointer
->	O
bps	long
=	O
n_read_total	long
/	O
ctx	pointer
->	O
bps_time	long
;	O
}	O
file_progress_set_stalled_label	function
(	O
ctx	pointer
,	O
stalled_msg	pointer
)	O
;	O
return_status	int
=	O
file_progress_show_bytes	function
(	O
ctx	pointer
,	O
*	O
progress_bytes	double
+	O
n_read_total	long
+	O
ctx	pointer
->	O
do_reget	long
,	O
ctx	pointer
->	O
progress_bytes	double
)	O
;	O
if	O
(	O
return_status	int
==	O
FILE_CONT	int
)	O
{	O
return_status	int
=	O
file_progress_show	function
(	O
ctx	pointer
,	O
n_read_total	long
+	O
ctx	pointer
->	O
do_reget	long
,	O
file_size	long
)	O
;	O
}	O
mc_refresh	function
(	O
)	O
;	O
if	O
(	O
return_status	int
!=	O
FILE_CONT	int
)	O
goto	O
ret	int
;	O
}	O
}	O
dst_status	int
=	O
DEST_FULL	int
;	O
ret	int
:	O
g_free	function
(	O
buf	pointer
)	O
;	O
while	O
(	O
src_desc	int
!=	O
-	O
1	int
&&	O
mc_close	function
(	O
src_desc	int
)	O
<	O
0	int
)	O
{	O
temp_status	int
=	O
file_error	function
(	O
_	O
(	O
" Cannot close source file \"%s\" \n %s "	pointer
)	O
,	O
src_path	pointer
)	O
;	O
if	O
(	O
temp_status	int
==	O
FILE_RETRY	int
)	O
continue	O
;	O
if	O
(	O
temp_status	int
==	O
FILE_ABORT	int
)	O
return_status	int
=	O
temp_status	int
;	O
break	O
;	O
}	O
while	O
(	O
dest_desc	int
!=	O
-	O
1	int
&&	O
mc_close	function
(	O
dest_desc	int
)	O
<	O
0	int
)	O
{	O
temp_status	int
=	O
file_error	function
(	O
_	O
(	O
" Cannot close target file \"%s\" \n %s "	pointer
)	O
,	O
dst_path	pointer
)	O
;	O
if	O
(	O
temp_status	int
==	O
FILE_RETRY	int
)	O
continue	O
;	O
return_status	int
=	O
temp_status	int
;	O
break	O
;	O
}	O
if	O
(	O
dst_status	int
==	O
DEST_SHORT	int
)	O
{	O
int	O
result	long
;	O
result	long
=	O
query_dialog	function
(	O
_	O
(	O
"Copy"	pointer
)	O
,	O
_	O
(	O
"Incomplete file was retrieved. Keep it?"	pointer
)	O
,	O
D_ERROR	int
,	O
2	int
,	O
_	O
(	O
"&Delete"	pointer
)	O
,	O
_	O
(	O
"&Keep"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
result	long
)	O
mc_unlink	function
(	O
dst_path	pointer
)	O
;	O
}	O
else	O
if	O
(	O
dst_status	int
==	O
DEST_FULL	int
)	O
{	O
if	O
(	O
!	O
appending	int
&&	O
ctx	pointer
->	O
preserve_uidgid	int
)	O
{	O
while	O
(	O
mc_chown	function
(	O
dst_path	pointer
,	O
src_uid	int
,	O
src_gid	int
)	O
)	O
{	O
temp_status	int
=	O
file_error	function
(	O
_	O
(	O
" Cannot chown target file \"%s\" \n %s "	pointer
)	O
,	O
dst_path	pointer
)	O
;	O
if	O
(	O
temp_status	int
==	O
FILE_RETRY	int
)	O
continue	O
;	O
return_status	int
=	O
temp_status	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
appending	int
)	O
{	O
while	O
(	O
mc_chmod	function
(	O
dst_path	pointer
,	O
(	O
src_mode	int
&	O
ctx	pointer
->	O
umask_kill	int
)	O
)	O
)	O
{	O
temp_status	int
=	O
file_error	function
(	O
_	O
(	O
" Cannot chmod target file \"%s\" \n %s "	pointer
)	O
,	O
dst_path	pointer
)	O
;	O
if	O
(	O
temp_status	int
!=	O
FILE_RETRY	int
)	O
{	O
return_status	int
=	O
temp_status	int
;	O
break	O
;	O
}	O
}	O
mc_utime	function
(	O
dst_path	pointer
,	O
&	O
utb	struct
)	O
;	O
}	O
}	O
if	O
(	O
return_status	int
==	O
FILE_CONT	int
)	O
return_status	int
=	O
progress_update_one	function
(	O
ctx	pointer
,	O
progress_count	long
,	O
progress_bytes	double
,	O
file_size	long
,	O
is_toplevel_file	int
)	O
;	O
return	O
return_status	int
;	O
}	O
int	O
copy_dir_dir	function
(	O
FileOpContext	struct
*	O
ctx	pointer
,	O
const	O
char	O
*	O
s	pointer
,	O
const	O
char	O
*	O
d	double
,	O
int	O
toplevel	int
,	O
int	O
move_over	int
,	O
int	O
delete	int
,	O
struct	O
link	function
*	O
parent_dirs	pointer
,	O
off_t	long
*	O
progress_count	long
,	O
double	O
*	O
progress_bytes	double
)	O
{	O
struct	O
dirent	struct
*	O
next	pointer
;	O
struct	O
stat	struct
buf	pointer
,	O
cbuf	struct
;	O
DIR	struct
*	O
reading	pointer
;	O
char	O
*	O
path	pointer
,	O
*	O
mdpath	pointer
,	O
*	O
dest_file	pointer
,	O
*	O
dest_dir	pointer
;	O
int	O
return_status	int
=	O
FILE_CONT	int
;	O
struct	O
utimbuf	struct
utb	struct
;	O
struct	O
link	function
*	O
lp	pointer
;	O
retry_src_stat	O
:	O
if	O
(	O
(	O
*	O
ctx	pointer
->	O
stat_func	pointer
)	O
(	O
s	pointer
,	O
&	O
cbuf	struct
)	O
)	O
{	O
return_status	int
=	O
file_error	function
(	O
_	O
(	O
" Cannot stat source directory \"%s\" \n %s "	pointer
)	O
,	O
s	pointer
)	O
;	O
if	O
(	O
return_status	int
==	O
FILE_RETRY	int
)	O
goto	O
retry_src_stat	O
;	O
return	O
return_status	int
;	O
}	O
if	O
(	O
is_in_linklist	function
(	O
dest_dirs	pointer
,	O
s	pointer
,	O
&	O
cbuf	struct
)	O
)	O
{	O
return	O
FILE_CONT	int
;	O
}	O
if	O
(	O
ctx	pointer
->	O
preserve	int
&&	O
cbuf	struct
.	O
st_nlink	long
>	O
1	int
&&	O
check_hardlinks	function
(	O
s	pointer
,	O
d	double
,	O
&	O
cbuf	struct
)	O
==	O
1	int
)	O
{	O
return	O
return_status	int
;	O
}	O
if	O
(	O
!	O
S_ISDIR	O
(	O
cbuf	struct
.	O
st_mode	int
)	O
)	O
{	O
return_status	int
=	O
file_error	function
(	O
_	O
(	O
" Source \"%s\" is not a directory \n %s "	pointer
)	O
,	O
s	pointer
)	O
;	O
if	O
(	O
return_status	int
==	O
FILE_RETRY	int
)	O
goto	O
retry_src_stat	O
;	O
return	O
return_status	int
;	O
}	O
if	O
(	O
is_in_linklist	function
(	O
parent_dirs	pointer
,	O
s	pointer
,	O
&	O
cbuf	struct
)	O
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" Cannot copy cyclic symbolic link \n `%s' "	pointer
)	O
,	O
s	pointer
)	O
;	O
return	O
FILE_SKIP	int
;	O
}	O
lp	pointer
=	O
g_new	O
(	O
struct	O
link	function
,	O
1	int
)	O
;	O
lp	pointer
->	O
vfs	pointer
=	O
vfs_get_class	function
(	O
s	pointer
)	O
;	O
lp	pointer
->	O
ino	long
=	O
cbuf	struct
.	O
st_ino	long
;	O
lp	pointer
->	O
dev	int
=	O
cbuf	struct
.	O
st_dev	long
;	O
lp	pointer
->	O
next	pointer
=	O
parent_dirs	pointer
;	O
parent_dirs	pointer
=	O
lp	pointer
;	O
retry_dst_stat	O
:	O
if	O
(	O
mc_stat	function
(	O
d	double
,	O
&	O
buf	pointer
)	O
)	O
{	O
if	O
(	O
move_over	int
)	O
{	O
if	O
(	O
mc_rename	function
(	O
s	pointer
,	O
d	double
)	O
==	O
0	int
)	O
{	O
g_free	function
(	O
parent_dirs	pointer
)	O
;	O
return	O
FILE_CONT	int
;	O
}	O
}	O
dest_dir	pointer
=	O
g_strdup	function
(	O
d	double
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
S_ISDIR	O
(	O
buf	pointer
.	O
st_mode	int
)	O
)	O
{	O
return_status	int
=	O
file_error	function
(	O
_	O
(	O
" Destination \"%s\" must be a directory \n %s "	pointer
)	O
,	O
d	double
)	O
;	O
if	O
(	O
return_status	int
==	O
FILE_RETRY	int
)	O
goto	O
retry_dst_stat	O
;	O
g_free	function
(	O
parent_dirs	pointer
)	O
;	O
return	O
return_status	int
;	O
}	O
if	O
(	O
toplevel	int
&&	O
ctx	pointer
->	O
dive_into_subdirs	int
)	O
{	O
dest_dir	pointer
=	O
concat_dir_and_file	function
(	O
d	double
,	O
x_basename	function
(	O
s	pointer
)	O
)	O
;	O
}	O
else	O
{	O
dest_dir	pointer
=	O
g_strdup	function
(	O
d	double
)	O
;	O
goto	O
dont_mkdir	O
;	O
}	O
}	O
while	O
(	O
my_mkdir	function
(	O
dest_dir	pointer
,	O
(	O
cbuf	struct
.	O
st_mode	int
&	O
ctx	pointer
->	O
umask_kill	int
)	O
|	O
S_IRWXU	O
)	O
)	O
{	O
return_status	int
=	O
file_error	function
(	O
_	O
(	O
" Cannot create target directory \"%s\" \n %s "	pointer
)	O
,	O
dest_dir	pointer
)	O
;	O
if	O
(	O
return_status	int
!=	O
FILE_RETRY	int
)	O
goto	O
ret	int
;	O
}	O
lp	pointer
=	O
g_new	O
(	O
struct	O
link	function
,	O
1	int
)	O
;	O
mc_stat	function
(	O
dest_dir	pointer
,	O
&	O
buf	pointer
)	O
;	O
lp	pointer
->	O
vfs	pointer
=	O
vfs_get_class	function
(	O
dest_dir	pointer
)	O
;	O
lp	pointer
->	O
ino	long
=	O
buf	pointer
.	O
st_ino	long
;	O
lp	pointer
->	O
dev	int
=	O
buf	pointer
.	O
st_dev	long
;	O
lp	pointer
->	O
next	pointer
=	O
dest_dirs	pointer
;	O
dest_dirs	pointer
=	O
lp	pointer
;	O
if	O
(	O
ctx	pointer
->	O
preserve_uidgid	int
)	O
{	O
while	O
(	O
mc_chown	function
(	O
dest_dir	pointer
,	O
cbuf	struct
.	O
st_uid	int
,	O
cbuf	struct
.	O
st_gid	int
)	O
)	O
{	O
return_status	int
=	O
file_error	function
(	O
_	O
(	O
" Cannot chown target directory \"%s\" \n %s "	pointer
)	O
,	O
dest_dir	pointer
)	O
;	O
if	O
(	O
return_status	int
!=	O
FILE_RETRY	int
)	O
goto	O
ret	int
;	O
}	O
}	O
dont_mkdir	O
:	O
if	O
(	O
(	O
reading	pointer
=	O
mc_opendir	function
(	O
s	pointer
)	O
)	O
==	O
0	int
)	O
{	O
goto	O
ret	int
;	O
}	O
while	O
(	O
(	O
next	pointer
=	O
mc_readdir	function
(	O
reading	pointer
)	O
)	O
&&	O
return_status	int
!=	O
FILE_ABORT	int
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
next	pointer
->	O
d_name	array
,	O
"."	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
next	pointer
->	O
d_name	array
,	O
".."	pointer
)	O
)	O
continue	O
;	O
path	pointer
=	O
concat_dir_and_file	function
(	O
s	pointer
,	O
next	pointer
->	O
d_name	array
)	O
;	O
(	O
*	O
ctx	pointer
->	O
stat_func	pointer
)	O
(	O
path	pointer
,	O
&	O
buf	pointer
)	O
;	O
if	O
(	O
S_ISDIR	O
(	O
buf	pointer
.	O
st_mode	int
)	O
)	O
{	O
mdpath	pointer
=	O
concat_dir_and_file	function
(	O
dest_dir	pointer
,	O
next	pointer
->	O
d_name	array
)	O
;	O
return_status	int
=	O
copy_dir_dir	function
(	O
ctx	pointer
,	O
path	pointer
,	O
mdpath	pointer
,	O
0	int
,	O
0	int
,	O
delete	int
,	O
parent_dirs	pointer
,	O
progress_count	long
,	O
progress_bytes	double
)	O
;	O
g_free	function
(	O
mdpath	pointer
)	O
;	O
}	O
else	O
{	O
dest_file	pointer
=	O
concat_dir_and_file	function
(	O
dest_dir	pointer
,	O
x_basename	function
(	O
path	pointer
)	O
)	O
;	O
return_status	int
=	O
copy_file_file	function
(	O
ctx	pointer
,	O
path	pointer
,	O
dest_file	pointer
,	O
1	int
,	O
progress_count	long
,	O
progress_bytes	double
,	O
0	int
)	O
;	O
g_free	function
(	O
dest_file	pointer
)	O
;	O
}	O
if	O
(	O
delete	int
&&	O
return_status	int
==	O
FILE_CONT	int
)	O
{	O
if	O
(	O
ctx	pointer
->	O
erase_at_end	int
)	O
{	O
static	O
struct	O
link	function
*	O
tail	pointer
;	O
lp	pointer
=	O
g_malloc	function
(	O
sizeof	O
(	O
struct	O
link	function
)	O
+	O
strlen	function
(	O
path	pointer
)	O
)	O
;	O
strcpy	function
(	O
lp	pointer
->	O
name	pointer
,	O
path	pointer
)	O
;	O
lp	pointer
->	O
st_mode	int
=	O
buf	pointer
.	O
st_mode	int
;	O
lp	pointer
->	O
next	pointer
=	O
0	int
;	O
if	O
(	O
erase_list	pointer
)	O
{	O
tail	pointer
->	O
next	pointer
=	O
lp	pointer
;	O
tail	pointer
=	O
lp	pointer
;	O
}	O
else	O
erase_list	pointer
=	O
tail	pointer
=	O
lp	pointer
;	O
}	O
else	O
{	O
if	O
(	O
S_ISDIR	O
(	O
buf	pointer
.	O
st_mode	int
)	O
)	O
{	O
return_status	int
=	O
erase_dir_iff_empty	function
(	O
ctx	pointer
,	O
path	pointer
)	O
;	O
}	O
else	O
return_status	int
=	O
erase_file	function
(	O
ctx	pointer
,	O
path	pointer
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
}	O
}	O
g_free	function
(	O
path	pointer
)	O
;	O
}	O
mc_closedir	function
(	O
reading	pointer
)	O
;	O
if	O
(	O
ctx	pointer
->	O
preserve	int
)	O
{	O
mc_chmod	function
(	O
dest_dir	pointer
,	O
cbuf	struct
.	O
st_mode	int
&	O
ctx	pointer
->	O
umask_kill	int
)	O
;	O
utb	struct
.	O
actime	long
=	O
cbuf	struct
.	O
st_atime	O
;	O
utb	struct
.	O
modtime	long
=	O
cbuf	struct
.	O
st_mtime	O
;	O
mc_utime	function
(	O
dest_dir	pointer
,	O
&	O
utb	struct
)	O
;	O
}	O
ret	int
:	O
g_free	function
(	O
dest_dir	pointer
)	O
;	O
g_free	function
(	O
parent_dirs	pointer
)	O
;	O
return	O
return_status	int
;	O
}	O
static	O
int	O
move_file_file	function
(	O
FileOpContext	struct
*	O
ctx	pointer
,	O
const	O
char	O
*	O
s	pointer
,	O
const	O
char	O
*	O
d	double
,	O
off_t	long
*	O
progress_count	long
,	O
double	O
*	O
progress_bytes	double
)	O
{	O
struct	O
stat	struct
src_stats	struct
,	O
dst_stats	struct
;	O
int	O
return_status	int
=	O
FILE_CONT	int
;	O
gboolean	int
copy_done	int
=	O
FALSE	O
;	O
if	O
(	O
file_progress_show_source	function
(	O
ctx	pointer
,	O
s	pointer
)	O
==	O
FILE_ABORT	int
||	O
file_progress_show_target	function
(	O
ctx	pointer
,	O
d	double
)	O
==	O
FILE_ABORT	int
)	O
return	O
FILE_ABORT	int
;	O
mc_refresh	function
(	O
)	O
;	O
while	O
(	O
mc_lstat	function
(	O
s	pointer
,	O
&	O
src_stats	struct
)	O
!=	O
0	int
)	O
{	O
return_status	int
=	O
file_error	function
(	O
_	O
(	O
" Cannot stat file \"%s\" \n %s "	pointer
)	O
,	O
s	pointer
)	O
;	O
if	O
(	O
return_status	int
!=	O
FILE_RETRY	int
)	O
return	O
return_status	int
;	O
}	O
if	O
(	O
mc_lstat	function
(	O
d	double
,	O
&	O
dst_stats	struct
)	O
==	O
0	int
)	O
{	O
if	O
(	O
src_stats	struct
.	O
st_dev	long
==	O
dst_stats	struct
.	O
st_dev	long
&&	O
src_stats	struct
.	O
st_ino	long
==	O
dst_stats	struct
.	O
st_ino	long
)	O
{	O
int	O
msize	int
=	O
COLS	O
-	O
36	int
;	O
char	O
st	pointer
[	O
MC_MAXPATHLEN	O
]	O
;	O
char	O
dt	long
[	O
MC_MAXPATHLEN	O
]	O
;	O
if	O
(	O
msize	int
<	O
0	int
)	O
msize	int
=	O
40	int
;	O
msize	int
/=	O
2	int
;	O
strcpy	function
(	O
st	pointer
,	O
path_trunc	function
(	O
s	pointer
,	O
msize	int
)	O
)	O
;	O
strcpy	function
(	O
dt	long
,	O
path_trunc	function
(	O
d	double
,	O
msize	int
)	O
)	O
;	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" `%s' and `%s' are the same file "	pointer
)	O
,	O
st	pointer
,	O
dt	long
)	O
;	O
do_refresh	function
(	O
)	O
;	O
return	O
FILE_SKIP	int
;	O
}	O
if	O
(	O
S_ISDIR	O
(	O
dst_stats	struct
.	O
st_mode	int
)	O
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" Cannot overwrite directory `%s' "	pointer
)	O
,	O
d	double
)	O
;	O
do_refresh	function
(	O
)	O
;	O
return	O
FILE_SKIP	int
;	O
}	O
if	O
(	O
confirm_overwrite	int
)	O
{	O
return_status	int
=	O
query_replace	function
(	O
ctx	pointer
,	O
d	double
,	O
&	O
src_stats	struct
,	O
&	O
dst_stats	struct
)	O
;	O
if	O
(	O
return_status	int
!=	O
FILE_CONT	int
)	O
return	O
return_status	int
;	O
}	O
}	O
if	O
(	O
!	O
ctx	pointer
->	O
do_append	int
)	O
{	O
if	O
(	O
S_ISLNK	O
(	O
src_stats	struct
.	O
st_mode	int
)	O
&&	O
ctx	pointer
->	O
stable_symlinks	int
)	O
{	O
if	O
(	O
(	O
return_status	int
=	O
make_symlink	function
(	O
ctx	pointer
,	O
s	pointer
,	O
d	double
)	O
)	O
==	O
FILE_CONT	int
)	O
{	O
goto	O
retry_src_remove	O
;	O
}	O
else	O
return	O
return_status	int
;	O
}	O
if	O
(	O
mc_rename	function
(	O
s	pointer
,	O
d	double
)	O
==	O
0	int
)	O
{	O
return	O
progress_update_one	function
(	O
ctx	pointer
,	O
progress_count	long
,	O
progress_bytes	double
,	O
src_stats	struct
.	O
st_size	long
,	O
1	int
)	O
;	O
}	O
}	O
return_status	int
=	O
copy_file_file	function
(	O
ctx	pointer
,	O
s	pointer
,	O
d	double
,	O
0	int
,	O
progress_count	long
,	O
progress_bytes	double
,	O
1	int
)	O
;	O
if	O
(	O
return_status	int
!=	O
FILE_CONT	int
)	O
return	O
return_status	int
;	O
copy_done	int
=	O
TRUE	O
;	O
if	O
(	O
(	O
return_status	int
=	O
file_progress_show_source	function
(	O
ctx	pointer
,	O
NULL	O
)	O
)	O
!=	O
FILE_CONT	int
||	O
(	O
return_status	int
=	O
file_progress_show	function
(	O
ctx	pointer
,	O
0	int
,	O
0	int
)	O
)	O
!=	O
FILE_CONT	int
)	O
return	O
return_status	int
;	O
mc_refresh	function
(	O
)	O
;	O
retry_src_remove	O
:	O
if	O
(	O
mc_unlink	function
(	O
s	pointer
)	O
)	O
{	O
return_status	int
=	O
file_error	function
(	O
_	O
(	O
" Cannot remove file \"%s\" \n %s "	pointer
)	O
,	O
s	pointer
)	O
;	O
if	O
(	O
return_status	int
==	O
FILE_RETRY	int
)	O
goto	O
retry_src_remove	O
;	O
return	O
return_status	int
;	O
}	O
if	O
(	O
!	O
copy_done	int
)	O
{	O
return_status	int
=	O
progress_update_one	function
(	O
ctx	pointer
,	O
progress_count	long
,	O
progress_bytes	double
,	O
src_stats	struct
.	O
st_size	long
,	O
1	int
)	O
;	O
}	O
return	O
return_status	int
;	O
}	O
int	O
move_dir_dir	function
(	O
FileOpContext	struct
*	O
ctx	pointer
,	O
const	O
char	O
*	O
s	pointer
,	O
const	O
char	O
*	O
d	double
,	O
off_t	long
*	O
progress_count	long
,	O
double	O
*	O
progress_bytes	double
)	O
{	O
struct	O
stat	struct
sbuf	struct
,	O
dbuf	struct
,	O
destbuf	struct
;	O
struct	O
link	function
*	O
lp	pointer
;	O
char	O
*	O
destdir	pointer
;	O
int	O
return_status	int
;	O
int	O
move_over	int
=	O
0	int
;	O
if	O
(	O
file_progress_show_source	function
(	O
ctx	pointer
,	O
s	pointer
)	O
==	O
FILE_ABORT	int
||	O
file_progress_show_target	function
(	O
ctx	pointer
,	O
d	double
)	O
==	O
FILE_ABORT	int
)	O
return	O
FILE_ABORT	int
;	O
mc_refresh	function
(	O
)	O
;	O
mc_stat	function
(	O
s	pointer
,	O
&	O
sbuf	struct
)	O
;	O
if	O
(	O
mc_stat	function
(	O
d	double
,	O
&	O
dbuf	struct
)	O
)	O
destdir	pointer
=	O
g_strdup	function
(	O
d	double
)	O
;	O
else	O
if	O
(	O
!	O
ctx	pointer
->	O
dive_into_subdirs	int
)	O
{	O
destdir	pointer
=	O
g_strdup	function
(	O
d	double
)	O
;	O
move_over	int
=	O
1	int
;	O
}	O
else	O
destdir	pointer
=	O
concat_dir_and_file	function
(	O
d	double
,	O
x_basename	function
(	O
s	pointer
)	O
)	O
;	O
if	O
(	O
sbuf	struct
.	O
st_dev	long
==	O
dbuf	struct
.	O
st_dev	long
&&	O
sbuf	struct
.	O
st_ino	long
==	O
dbuf	struct
.	O
st_ino	long
)	O
{	O
int	O
msize	int
=	O
COLS	O
-	O
36	int
;	O
char	O
st	pointer
[	O
MC_MAXPATHLEN	O
]	O
;	O
char	O
dt	long
[	O
MC_MAXPATHLEN	O
]	O
;	O
if	O
(	O
msize	int
<	O
0	int
)	O
msize	int
=	O
40	int
;	O
msize	int
/=	O
2	int
;	O
strcpy	function
(	O
st	pointer
,	O
path_trunc	function
(	O
s	pointer
,	O
msize	int
)	O
)	O
;	O
strcpy	function
(	O
dt	long
,	O
path_trunc	function
(	O
d	double
,	O
msize	int
)	O
)	O
;	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" `%s' and `%s' are the same directory "	pointer
)	O
,	O
st	pointer
,	O
dt	long
)	O
;	O
do_refresh	function
(	O
)	O
;	O
return	O
FILE_SKIP	int
;	O
}	O
retry_dst_stat	O
:	O
if	O
(	O
!	O
mc_stat	function
(	O
destdir	pointer
,	O
&	O
destbuf	struct
)	O
)	O
{	O
if	O
(	O
move_over	int
)	O
{	O
return_status	int
=	O
copy_dir_dir	function
(	O
ctx	pointer
,	O
s	pointer
,	O
destdir	pointer
,	O
0	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
progress_count	long
,	O
progress_bytes	double
)	O
;	O
if	O
(	O
return_status	int
!=	O
FILE_CONT	int
)	O
goto	O
ret	int
;	O
goto	O
oktoret	O
;	O
}	O
else	O
{	O
if	O
(	O
S_ISDIR	O
(	O
destbuf	struct
.	O
st_mode	int
)	O
)	O
return_status	int
=	O
file_error	function
(	O
_	O
(	O
" Cannot overwrite directory \"%s\" %s "	pointer
)	O
,	O
destdir	pointer
)	O
;	O
else	O
return_status	int
=	O
file_error	function
(	O
_	O
(	O
" Cannot overwrite file \"%s\" %s "	pointer
)	O
,	O
destdir	pointer
)	O
;	O
if	O
(	O
return_status	int
==	O
FILE_RETRY	int
)	O
goto	O
retry_dst_stat	O
;	O
}	O
g_free	function
(	O
destdir	pointer
)	O
;	O
return	O
return_status	int
;	O
}	O
retry_rename	O
:	O
if	O
(	O
mc_rename	function
(	O
s	pointer
,	O
destdir	pointer
)	O
==	O
0	int
)	O
{	O
return_status	int
=	O
FILE_CONT	int
;	O
goto	O
ret	int
;	O
}	O
if	O
(	O
errno	O
!=	O
EXDEV	int
)	O
{	O
return_status	int
=	O
files_error	function
(	O
_	O
(	O
" Cannot move directory \"%s\" to \"%s\" \n %s "	pointer
)	O
,	O
s	pointer
,	O
d	double
)	O
;	O
if	O
(	O
return_status	int
==	O
FILE_RETRY	int
)	O
goto	O
retry_rename	O
;	O
goto	O
ret	int
;	O
}	O
return_status	int
=	O
copy_dir_dir	function
(	O
ctx	pointer
,	O
s	pointer
,	O
destdir	pointer
,	O
0	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
progress_count	long
,	O
progress_bytes	double
)	O
;	O
if	O
(	O
return_status	int
!=	O
FILE_CONT	int
)	O
goto	O
ret	int
;	O
oktoret	O
:	O
if	O
(	O
(	O
return_status	int
=	O
file_progress_show_source	function
(	O
ctx	pointer
,	O
NULL	O
)	O
)	O
!=	O
FILE_CONT	int
||	O
(	O
return_status	int
=	O
file_progress_show	function
(	O
ctx	pointer
,	O
0	int
,	O
0	int
)	O
)	O
!=	O
FILE_CONT	int
)	O
goto	O
ret	int
;	O
mc_refresh	function
(	O
)	O
;	O
if	O
(	O
ctx	pointer
->	O
erase_at_end	int
)	O
{	O
for	O
(	O
;	O
erase_list	pointer
&&	O
return_status	int
!=	O
FILE_ABORT	int
;	O
)	O
{	O
if	O
(	O
S_ISDIR	O
(	O
erase_list	pointer
->	O
st_mode	int
)	O
)	O
{	O
return_status	int
=	O
erase_dir_iff_empty	function
(	O
ctx	pointer
,	O
erase_list	pointer
->	O
name	pointer
)	O
;	O
}	O
else	O
return_status	int
=	O
erase_file	function
(	O
ctx	pointer
,	O
erase_list	pointer
->	O
name	pointer
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
lp	pointer
=	O
erase_list	pointer
;	O
erase_list	pointer
=	O
erase_list	pointer
->	O
next	pointer
;	O
g_free	function
(	O
lp	pointer
)	O
;	O
}	O
}	O
erase_dir_iff_empty	function
(	O
ctx	pointer
,	O
s	pointer
)	O
;	O
ret	int
:	O
g_free	function
(	O
destdir	pointer
)	O
;	O
while	O
(	O
erase_list	pointer
)	O
{	O
lp	pointer
=	O
erase_list	pointer
;	O
erase_list	pointer
=	O
erase_list	pointer
->	O
next	pointer
;	O
g_free	function
(	O
lp	pointer
)	O
;	O
}	O
return	O
return_status	int
;	O
}	O
static	O
int	O
erase_file	function
(	O
FileOpContext	struct
*	O
ctx	pointer
,	O
const	O
char	O
*	O
s	pointer
,	O
off_t	long
*	O
progress_count	long
,	O
double	O
*	O
progress_bytes	double
,	O
int	O
is_toplevel_file	int
)	O
{	O
int	O
return_status	int
;	O
struct	O
stat	struct
buf	pointer
;	O
if	O
(	O
file_progress_show_deleting	function
(	O
ctx	pointer
,	O
s	pointer
)	O
==	O
FILE_ABORT	int
)	O
return	O
FILE_ABORT	int
;	O
mc_refresh	function
(	O
)	O
;	O
if	O
(	O
progress_count	long
&&	O
mc_lstat	function
(	O
s	pointer
,	O
&	O
buf	pointer
)	O
)	O
{	O
buf	pointer
.	O
st_size	long
=	O
0	int
;	O
}	O
while	O
(	O
mc_unlink	function
(	O
s	pointer
)	O
)	O
{	O
return_status	int
=	O
file_error	function
(	O
_	O
(	O
" Cannot delete file \"%s\" \n %s "	pointer
)	O
,	O
s	pointer
)	O
;	O
if	O
(	O
return_status	int
!=	O
FILE_RETRY	int
)	O
return	O
return_status	int
;	O
}	O
if	O
(	O
progress_count	long
)	O
return	O
progress_update_one	function
(	O
ctx	pointer
,	O
progress_count	long
,	O
progress_bytes	double
,	O
buf	pointer
.	O
st_size	long
,	O
is_toplevel_file	int
)	O
;	O
else	O
return	O
FILE_CONT	int
;	O
}	O
static	O
int	O
recursive_erase	function
(	O
FileOpContext	struct
*	O
ctx	pointer
,	O
const	O
char	O
*	O
s	pointer
,	O
off_t	long
*	O
progress_count	long
,	O
double	O
*	O
progress_bytes	double
)	O
{	O
struct	O
dirent	struct
*	O
next	pointer
;	O
struct	O
stat	struct
buf	pointer
;	O
DIR	struct
*	O
reading	pointer
;	O
char	O
*	O
path	pointer
;	O
int	O
return_status	int
=	O
FILE_CONT	int
;	O
if	O
(	O
!	O
strcmp	function
(	O
s	pointer
,	O
".."	pointer
)	O
)	O
return	O
1	int
;	O
reading	pointer
=	O
mc_opendir	function
(	O
s	pointer
)	O
;	O
if	O
(	O
!	O
reading	pointer
)	O
return	O
1	int
;	O
while	O
(	O
(	O
next	pointer
=	O
mc_readdir	function
(	O
reading	pointer
)	O
)	O
&&	O
return_status	int
==	O
FILE_CONT	int
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
next	pointer
->	O
d_name	array
,	O
"."	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
next	pointer
->	O
d_name	array
,	O
".."	pointer
)	O
)	O
continue	O
;	O
path	pointer
=	O
concat_dir_and_file	function
(	O
s	pointer
,	O
next	pointer
->	O
d_name	array
)	O
;	O
if	O
(	O
mc_lstat	function
(	O
path	pointer
,	O
&	O
buf	pointer
)	O
)	O
{	O
g_free	function
(	O
path	pointer
)	O
;	O
mc_closedir	function
(	O
reading	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
S_ISDIR	O
(	O
buf	pointer
.	O
st_mode	int
)	O
)	O
return_status	int
=	O
(	O
recursive_erase	function
(	O
ctx	pointer
,	O
path	pointer
,	O
progress_count	long
,	O
progress_bytes	double
)	O
!=	O
FILE_CONT	int
)	O
;	O
else	O
return_status	int
=	O
erase_file	function
(	O
ctx	pointer
,	O
path	pointer
,	O
progress_count	long
,	O
progress_bytes	double
,	O
0	int
)	O
;	O
g_free	function
(	O
path	pointer
)	O
;	O
}	O
mc_closedir	function
(	O
reading	pointer
)	O
;	O
if	O
(	O
return_status	int
!=	O
FILE_CONT	int
)	O
return	O
return_status	int
;	O
if	O
(	O
file_progress_show_deleting	function
(	O
ctx	pointer
,	O
s	pointer
)	O
==	O
FILE_ABORT	int
)	O
return	O
FILE_ABORT	int
;	O
mc_refresh	function
(	O
)	O
;	O
while	O
(	O
my_rmdir	function
(	O
s	pointer
)	O
)	O
{	O
return_status	int
=	O
file_error	function
(	O
_	O
(	O
" Cannot remove directory \"%s\" \n %s "	pointer
)	O
,	O
s	pointer
)	O
;	O
if	O
(	O
return_status	int
!=	O
FILE_RETRY	int
)	O
return	O
return_status	int
;	O
}	O
return	O
FILE_CONT	int
;	O
}	O
static	O
int	O
check_dir_is_empty	function
(	O
const	O
char	O
*	O
path	pointer
)	O
{	O
DIR	struct
*	O
dir	pointer
;	O
struct	O
dirent	struct
*	O
d	double
;	O
int	O
i	array
;	O
dir	pointer
=	O
mc_opendir	function
(	O
path	pointer
)	O
;	O
if	O
(	O
!	O
dir	pointer
)	O
return	O
-	O
1	int
;	O
for	O
(	O
i	array
=	O
1	int
,	O
d	double
=	O
mc_readdir	function
(	O
dir	pointer
)	O
;	O
d	double
;	O
d	double
=	O
mc_readdir	function
(	O
dir	pointer
)	O
)	O
{	O
if	O
(	O
d	double
->	O
d_name	array
[	O
0	int
]	O
==	O
'.'	O
&&	O
(	O
d	double
->	O
d_name	array
[	O
1	int
]	O
==	O
'\0'	O
||	O
(	O
d	double
->	O
d_name	array
[	O
1	int
]	O
==	O
'.'	O
&&	O
d	double
->	O
d_name	array
[	O
2	int
]	O
==	O
'\0'	O
)	O
)	O
)	O
continue	O
;	O
i	array
=	O
0	int
;	O
break	O
;	O
}	O
mc_closedir	function
(	O
dir	pointer
)	O
;	O
return	O
i	array
;	O
}	O
int	O
erase_dir	function
(	O
FileOpContext	struct
*	O
ctx	pointer
,	O
const	O
char	O
*	O
s	pointer
,	O
off_t	long
*	O
progress_count	long
,	O
double	O
*	O
progress_bytes	double
)	O
{	O
int	O
error	pointer
;	O
if	O
(	O
strcmp	function
(	O
s	pointer
,	O
".."	pointer
)	O
==	O
0	int
)	O
return	O
FILE_SKIP	int
;	O
if	O
(	O
strcmp	function
(	O
s	pointer
,	O
"."	pointer
)	O
==	O
0	int
)	O
return	O
FILE_SKIP	int
;	O
if	O
(	O
file_progress_show_deleting	function
(	O
ctx	pointer
,	O
s	pointer
)	O
==	O
FILE_ABORT	int
)	O
return	O
FILE_ABORT	int
;	O
mc_refresh	function
(	O
)	O
;	O
error	pointer
=	O
check_dir_is_empty	function
(	O
s	pointer
)	O
;	O
if	O
(	O
error	pointer
==	O
0	int
)	O
{	O
error	pointer
=	O
query_recursive	function
(	O
ctx	pointer
,	O
s	pointer
)	O
;	O
if	O
(	O
error	pointer
==	O
FILE_CONT	int
)	O
return	O
recursive_erase	function
(	O
ctx	pointer
,	O
s	pointer
,	O
progress_count	long
,	O
progress_bytes	double
)	O
;	O
else	O
return	O
error	pointer
;	O
}	O
while	O
(	O
my_rmdir	function
(	O
s	pointer
)	O
==	O
-	O
1	int
)	O
{	O
error	pointer
=	O
file_error	function
(	O
_	O
(	O
" Cannot remove directory \"%s\" \n %s "	pointer
)	O
,	O
s	pointer
)	O
;	O
if	O
(	O
error	pointer
!=	O
FILE_RETRY	int
)	O
return	O
error	pointer
;	O
}	O
return	O
FILE_CONT	int
;	O
}	O
static	O
int	O
erase_dir_iff_empty	function
(	O
FileOpContext	struct
*	O
ctx	pointer
,	O
const	O
char	O
*	O
s	pointer
)	O
{	O
int	O
error	pointer
;	O
if	O
(	O
strcmp	function
(	O
s	pointer
,	O
".."	pointer
)	O
==	O
0	int
)	O
return	O
FILE_SKIP	int
;	O
if	O
(	O
strcmp	function
(	O
s	pointer
,	O
"."	pointer
)	O
==	O
0	int
)	O
return	O
FILE_SKIP	int
;	O
if	O
(	O
file_progress_show_deleting	function
(	O
ctx	pointer
,	O
s	pointer
)	O
==	O
FILE_ABORT	int
)	O
return	O
FILE_ABORT	int
;	O
mc_refresh	function
(	O
)	O
;	O
if	O
(	O
1	int
!=	O
check_dir_is_empty	function
(	O
s	pointer
)	O
)	O
return	O
FILE_CONT	int
;	O
while	O
(	O
my_rmdir	function
(	O
s	pointer
)	O
)	O
{	O
error	pointer
=	O
file_error	function
(	O
_	O
(	O
" Cannot remove directory \"%s\" \n %s "	pointer
)	O
,	O
s	pointer
)	O
;	O
if	O
(	O
error	pointer
!=	O
FILE_RETRY	int
)	O
return	O
error	pointer
;	O
}	O
return	O
FILE_CONT	int
;	O
}	O
static	O
char	O
*	O
panel_get_file	function
(	O
WPanel	struct
*	O
panel	pointer
,	O
struct	O
stat	struct
*	O
stat_buf	pointer
)	O
{	O
int	O
i	array
;	O
if	O
(	O
get_current_type	function
(	O
)	O
==	O
view_tree	int
)	O
{	O
WTree	struct
*	O
tree	pointer
=	O
(	O
WTree	struct
*	O
)	O
get_panel_widget	function
(	O
get_current_index	function
(	O
)	O
)	O
;	O
char	O
*	O
tree_name	pointer
=	O
tree_selected_name	function
(	O
tree	pointer
)	O
;	O
mc_stat	function
(	O
tree_name	pointer
,	O
stat_buf	pointer
)	O
;	O
return	O
tree_name	pointer
;	O
}	O
if	O
(	O
panel	pointer
->	O
marked	int
)	O
{	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
panel	pointer
->	O
count	int
;	O
i	array
++	O
)	O
if	O
(	O
panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
i	array
]	O
.	O
f	float
.	O
marked	int
)	O
{	O
*	O
stat_buf	pointer
=	O
panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
i	array
]	O
.	O
st	pointer
;	O
return	O
panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
i	array
]	O
.	O
fname	pointer
;	O
}	O
}	O
else	O
{	O
*	O
stat_buf	pointer
=	O
panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
panel	pointer
->	O
selected	int
]	O
.	O
st	pointer
;	O
return	O
panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
panel	pointer
->	O
selected	int
]	O
.	O
fname	pointer
;	O
}	O
g_assert_not_reached	O
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
void	O
compute_dir_size	function
(	O
const	O
char	O
*	O
dirname	pointer
,	O
off_t	long
*	O
ret_marked	pointer
,	O
double	O
*	O
ret_total	pointer
)	O
{	O
DIR	struct
*	O
dir	pointer
;	O
struct	O
dirent	struct
*	O
dirent	struct
;	O
dir	pointer
=	O
mc_opendir	function
(	O
dirname	pointer
)	O
;	O
if	O
(	O
!	O
dir	pointer
)	O
return	O
;	O
while	O
(	O
(	O
dirent	struct
=	O
mc_readdir	function
(	O
dir	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
struct	O
stat	struct
s	pointer
;	O
char	O
*	O
fullname	pointer
;	O
int	O
res	int
;	O
if	O
(	O
strcmp	function
(	O
dirent	struct
->	O
d_name	array
,	O
"."	pointer
)	O
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
strcmp	function
(	O
dirent	struct
->	O
d_name	array
,	O
".."	pointer
)	O
==	O
0	int
)	O
continue	O
;	O
fullname	pointer
=	O
concat_dir_and_file	function
(	O
dirname	pointer
,	O
dirent	struct
->	O
d_name	array
)	O
;	O
res	int
=	O
mc_lstat	function
(	O
fullname	pointer
,	O
&	O
s	pointer
)	O
;	O
if	O
(	O
res	int
!=	O
0	int
)	O
{	O
g_free	function
(	O
fullname	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
S_ISDIR	O
(	O
s	pointer
.	O
st_mode	int
)	O
)	O
{	O
off_t	long
subdir_count	long
=	O
0	int
;	O
double	O
subdir_bytes	double
=	O
0	int
;	O
compute_dir_size	function
(	O
fullname	pointer
,	O
&	O
subdir_count	long
,	O
&	O
subdir_bytes	double
)	O
;	O
*	O
ret_marked	pointer
+=	O
subdir_count	long
;	O
*	O
ret_total	pointer
+=	O
subdir_bytes	double
;	O
}	O
else	O
{	O
(	O
*	O
ret_marked	pointer
)	O
++	O
;	O
*	O
ret_total	pointer
+=	O
s	pointer
.	O
st_size	long
;	O
}	O
g_free	function
(	O
fullname	pointer
)	O
;	O
}	O
mc_closedir	function
(	O
dir	pointer
)	O
;	O
}	O
static	O
void	O
panel_compute_totals	function
(	O
WPanel	struct
*	O
panel	pointer
,	O
off_t	long
*	O
ret_marked	pointer
,	O
double	O
*	O
ret_total	pointer
)	O
{	O
int	O
i	array
;	O
*	O
ret_marked	pointer
=	O
0	int
;	O
*	O
ret_total	pointer
=	O
0.0	int
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
panel	pointer
->	O
count	int
;	O
i	array
++	O
)	O
{	O
struct	O
stat	struct
*	O
s	pointer
;	O
if	O
(	O
!	O
panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
i	array
]	O
.	O
f	float
.	O
marked	int
)	O
continue	O
;	O
s	pointer
=	O
&	O
panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
i	array
]	O
.	O
st	pointer
;	O
if	O
(	O
S_ISDIR	O
(	O
s	pointer
->	O
st_mode	int
)	O
)	O
{	O
char	O
*	O
dir_name	pointer
;	O
off_t	long
subdir_count	long
=	O
0	int
;	O
double	O
subdir_bytes	double
=	O
0	int
;	O
dir_name	pointer
=	O
concat_dir_and_file	function
(	O
panel	pointer
->	O
cwd	short
,	O
panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
i	array
]	O
.	O
fname	pointer
)	O
;	O
compute_dir_size	function
(	O
dir_name	pointer
,	O
&	O
subdir_count	long
,	O
&	O
subdir_bytes	double
)	O
;	O
*	O
ret_marked	pointer
+=	O
subdir_count	long
;	O
*	O
ret_total	pointer
+=	O
subdir_bytes	double
;	O
g_free	function
(	O
dir_name	pointer
)	O
;	O
}	O
else	O
{	O
(	O
*	O
ret_marked	pointer
)	O
++	O
;	O
*	O
ret_total	pointer
+=	O
s	pointer
->	O
st_size	long
;	O
}	O
}	O
}	O
static	O
const	O
char	O
*	O
op_names1	array
[	O
]	O
=	O
{	O
N_	O
(	O
"1Copy"	pointer
)	O
,	O
N_	O
(	O
"1Move"	pointer
)	O
,	O
N_	O
(	O
"1Delete"	pointer
)	O
}	O
;	O
int	O
fmd_xlen	int
=	O
FMD_XLEN	int
;	O
static	O
const	O
char	O
*	O
one_format	pointer
=	O
N_	O
(	O
"%o %f \"%s\"%m"	pointer
)	O
;	O
static	O
const	O
char	O
*	O
many_format	pointer
=	O
N_	O
(	O
"%o %d %f%m"	pointer
)	O
;	O
static	O
const	O
char	O
*	O
prompt_parts	array
[	O
]	O
=	O
{	O
N_	O
(	O
"file"	pointer
)	O
,	O
N_	O
(	O
"files"	pointer
)	O
,	O
N_	O
(	O
"directory"	pointer
)	O
,	O
N_	O
(	O
"directories"	pointer
)	O
,	O
N_	O
(	O
"files/directories"	pointer
)	O
,	O
N_	O
(	O
" with source mask:"	pointer
)	O
,	O
N_	O
(	O
" to:"	pointer
)	O
}	O
;	O
static	O
void	O
panel_operate_generate_prompt	function
(	O
const	O
WPanel	struct
*	O
panel	pointer
,	O
const	O
int	O
operation	enum
,	O
const	O
char	O
*	O
single_source	pointer
,	O
const	O
struct	O
stat	struct
*	O
src_stat	pointer
)	O
{	O
register	O
const	O
char	O
*	O
sp	pointer
,	O
*	O
cp	pointer
;	O
register	O
int	O
i	array
;	O
char	O
format_string	pointer
[	O
BUF_MEDIUM	int
]	O
;	O
char	O
*	O
dp	pointer
=	O
format_string	pointer
;	O
static	O
int	O
i18n_flag	int
=	O
0	int
;	O
if	O
(	O
!	O
i18n_flag	int
)	O
{	O
fmd_init_i18n	function
(	O
FALSE	O
)	O
;	O
for	O
(	O
i	array
=	O
sizeof	O
(	O
op_names1	array
)	O
/	O
sizeof	O
(	O
op_names1	array
[	O
0	int
]	O
)	O
;	O
i	array
--	O
;	O
)	O
op_names1	array
[	O
i	array
]	O
=	O
_	O
(	O
op_names1	array
[	O
i	array
]	O
)	O
;	O
for	O
(	O
i	array
=	O
sizeof	O
(	O
prompt_parts	array
)	O
/	O
sizeof	O
(	O
prompt_parts	array
[	O
0	int
]	O
)	O
;	O
i	array
--	O
;	O
)	O
prompt_parts	array
[	O
i	array
]	O
=	O
_	O
(	O
prompt_parts	array
[	O
i	array
]	O
)	O
;	O
one_format	pointer
=	O
_	O
(	O
one_format	pointer
)	O
;	O
many_format	pointer
=	O
_	O
(	O
many_format	pointer
)	O
;	O
i18n_flag	int
=	O
1	int
;	O
}	O
sp	pointer
=	O
single_source	pointer
?	O
one_format	pointer
:	O
many_format	pointer
;	O
while	O
(	O
*	O
sp	pointer
)	O
{	O
switch	O
(	O
*	O
sp	pointer
)	O
{	O
case	O
'%'	O
:	O
cp	pointer
=	O
NULL	O
;	O
switch	O
(	O
sp	pointer
[	O
1	int
]	O
)	O
{	O
case	O
'o'	O
:	O
cp	pointer
=	O
op_names1	array
[	O
operation	enum
]	O
+	O
1	int
;	O
break	O
;	O
case	O
'm'	O
:	O
cp	pointer
=	O
operation	enum
==	O
OP_DELETE	int
?	O
"?"	pointer
:	O
prompt_parts	array
[	O
5	int
]	O
;	O
break	O
;	O
case	O
'e'	O
:	O
cp	pointer
=	O
operation	enum
==	O
OP_DELETE	int
?	O
"?"	pointer
:	O
prompt_parts	array
[	O
6	int
]	O
;	O
break	O
;	O
case	O
'f'	O
:	O
if	O
(	O
single_source	pointer
)	O
{	O
cp	pointer
=	O
S_ISDIR	O
(	O
src_stat	pointer
->	O
st_mode	int
)	O
?	O
prompt_parts	array
[	O
2	int
]	O
:	O
prompt_parts	array
[	O
0	int
]	O
;	O
}	O
else	O
{	O
cp	pointer
=	O
(	O
panel	pointer
->	O
marked	int
==	O
panel	pointer
->	O
dirs_marked	int
)	O
?	O
prompt_parts	array
[	O
3	int
]	O
:	O
(	O
panel	pointer
->	O
dirs_marked	int
?	O
prompt_parts	array
[	O
4	int
]	O
:	O
prompt_parts	array
[	O
1	int
]	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
*	O
dp	pointer
++	O
=	O
*	O
sp	pointer
++	O
;	O
}	O
if	O
(	O
cp	pointer
)	O
{	O
sp	pointer
+=	O
2	int
;	O
while	O
(	O
*	O
cp	pointer
)	O
*	O
dp	pointer
++	O
=	O
*	O
cp	pointer
++	O
;	O
}	O
break	O
;	O
default	O
:	O
*	O
dp	pointer
++	O
=	O
*	O
sp	pointer
++	O
;	O
}	O
}	O
*	O
dp	pointer
=	O
'\0'	O
;	O
if	O
(	O
single_source	pointer
)	O
{	O
i	array
=	O
fmd_xlen	int
-	O
strlen	function
(	O
format_string	pointer
)	O
-	O
4	int
;	O
g_snprintf	function
(	O
cmd_buf	array
,	O
sizeof	O
(	O
cmd_buf	array
)	O
,	O
format_string	pointer
,	O
name_trunc	function
(	O
single_source	pointer
,	O
i	array
)	O
)	O
;	O
}	O
else	O
{	O
g_snprintf	function
(	O
cmd_buf	array
,	O
sizeof	O
(	O
cmd_buf	array
)	O
,	O
format_string	pointer
,	O
panel	pointer
->	O
marked	int
)	O
;	O
i	array
=	O
strlen	function
(	O
cmd_buf	array
)	O
+	O
6	int
-	O
fmd_xlen	int
;	O
if	O
(	O
i	array
>	O
0	int
)	O
{	O
fmd_xlen	int
+=	O
i	array
;	O
fmd_init_i18n	function
(	O
TRUE	O
)	O
;	O
}	O
}	O
}	O
int	O
panel_operate	function
(	O
void	O
*	O
source_panel	pointer
,	O
FileOperation	enum
operation	enum
,	O
int	O
force_single	int
)	O
{	O
WPanel	struct
*	O
panel	pointer
=	O
source_panel	pointer
;	O
char	O
*	O
source_with_path	pointer
=	O
NULL	O
;	O
char	O
*	O
source	pointer
=	O
NULL	O
;	O
char	O
*	O
dest	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
temp	pointer
=	O
NULL	O
;	O
char	O
*	O
save_cwd	pointer
=	O
NULL	O
,	O
*	O
save_dest	pointer
=	O
NULL	O
;	O
int	O
single_entry	int
=	O
(	O
get_current_type	function
(	O
)	O
==	O
view_tree	int
)	O
||	O
(	O
panel	pointer
->	O
marked	int
<=	O
1	int
)	O
||	O
force_single	int
;	O
struct	O
stat	struct
src_stat	pointer
,	O
dst_stat	struct
;	O
int	O
i	array
,	O
value	pointer
;	O
FileOpContext	struct
*	O
ctx	pointer
;	O
off_t	long
count	int
=	O
0	int
;	O
double	O
bytes	pointer
=	O
0	int
;	O
int	O
dst_result	int
;	O
int	O
do_bg	int
=	O
0	int
;	O
free_linklist	function
(	O
&	O
linklist	pointer
)	O
;	O
free_linklist	function
(	O
&	O
dest_dirs	pointer
)	O
;	O
if	O
(	O
single_entry	int
)	O
{	O
if	O
(	O
force_single	int
)	O
{	O
source	pointer
=	O
selection	O
(	O
panel	pointer
)	O
->	O
fname	pointer
;	O
src_stat	pointer
=	O
selection	O
(	O
panel	pointer
)	O
->	O
st	pointer
;	O
}	O
else	O
{	O
source	pointer
=	O
panel_get_file	function
(	O
panel	pointer
,	O
&	O
src_stat	pointer
)	O
;	O
}	O
if	O
(	O
!	O
strcmp	function
(	O
source	pointer
,	O
".."	pointer
)	O
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" Cannot operate on \"..\"! "	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
panel_operate_generate_prompt	function
(	O
panel	pointer
,	O
operation	enum
,	O
source	pointer
,	O
&	O
src_stat	pointer
)	O
;	O
ctx	pointer
=	O
file_op_context_new	function
(	O
operation	enum
)	O
;	O
if	O
(	O
operation	enum
==	O
OP_DELETE	int
&&	O
confirm_delete	int
)	O
{	O
if	O
(	O
safe_delete	int
)	O
query_set_sel	function
(	O
1	int
)	O
;	O
i	array
=	O
query_dialog	function
(	O
_	O
(	O
op_names	array
[	O
operation	enum
]	O
)	O
,	O
cmd_buf	array
,	O
D_ERROR	int
,	O
2	int
,	O
_	O
(	O
"&Yes"	pointer
)	O
,	O
_	O
(	O
"&No"	pointer
)	O
)	O
;	O
if	O
(	O
i	array
!=	O
0	int
)	O
{	O
file_op_context_destroy	function
(	O
ctx	pointer
)	O
;	O
return	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
operation	enum
!=	O
OP_DELETE	int
)	O
{	O
char	O
*	O
dest_dir	pointer
;	O
if	O
(	O
force_single	int
)	O
dest_dir	pointer
=	O
source	pointer
;	O
else	O
if	O
(	O
get_other_type	function
(	O
)	O
==	O
view_listing	int
)	O
dest_dir	pointer
=	O
other_panel	O
->	O
cwd	short
;	O
else	O
dest_dir	pointer
=	O
panel	pointer
->	O
cwd	short
;	O
dest	pointer
=	O
file_mask_dialog	function
(	O
ctx	pointer
,	O
operation	enum
,	O
cmd_buf	array
,	O
dest_dir	pointer
,	O
single_entry	int
,	O
&	O
do_bg	int
)	O
;	O
if	O
(	O
!	O
dest	pointer
)	O
{	O
file_op_context_destroy	function
(	O
ctx	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
*	O
dest	pointer
)	O
{	O
file_op_context_destroy	function
(	O
ctx	pointer
)	O
;	O
g_free	function
(	O
dest	pointer
)	O
;	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
do_bg	int
)	O
{	O
int	O
v	pointer
;	O
v	pointer
=	O
do_background	function
(	O
ctx	pointer
,	O
g_strconcat	function
(	O
op_names	array
[	O
operation	enum
]	O
,	O
": "	pointer
,	O
panel	pointer
->	O
cwd	short
,	O
NULL	O
)	O
)	O
;	O
if	O
(	O
v	pointer
==	O
-	O
1	int
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" Sorry, I could not put the job in background "	pointer
)	O
)	O
;	O
}	O
if	O
(	O
v	pointer
==	O
1	int
)	O
{	O
mc_setctl	function
(	O
panel	pointer
->	O
cwd	short
,	O
VFS_SETCTL_FORGET	int
,	O
NULL	O
)	O
;	O
mc_setctl	function
(	O
dest	pointer
,	O
VFS_SETCTL_FORGET	int
,	O
NULL	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
dest	pointer
)	O
{	O
if	O
(	O
mc_setctl	function
(	O
dest	pointer
,	O
VFS_SETCTL_STALE_DATA	int
,	O
(	O
void	O
*	O
)	O
1	int
)	O
)	O
save_dest	pointer
=	O
g_strdup	function
(	O
dest	pointer
)	O
;	O
}	O
if	O
(	O
panel	pointer
->	O
cwd	short
)	O
{	O
if	O
(	O
mc_setctl	function
(	O
panel	pointer
->	O
cwd	short
,	O
VFS_SETCTL_STALE_DATA	int
,	O
(	O
void	O
*	O
)	O
1	int
)	O
)	O
save_cwd	pointer
=	O
g_strdup	function
(	O
panel	pointer
->	O
cwd	short
)	O
;	O
}	O
if	O
(	O
do_bg	int
)	O
ctx	pointer
->	O
ui	pointer
=	O
NULL	O
;	O
else	O
file_op_context_create_ui	function
(	O
ctx	pointer
,	O
1	int
)	O
;	O
if	O
(	O
single_entry	int
)	O
{	O
if	O
(	O
operation	enum
!=	O
OP_COPY	int
&&	O
get_current_type	function
(	O
)	O
==	O
view_tree	int
)	O
mc_chdir	function
(	O
PATH_SEP_STR	pointer
)	O
;	O
source_with_path	pointer
=	O
concat_dir_and_file	function
(	O
panel	pointer
->	O
cwd	short
,	O
source	pointer
)	O
;	O
if	O
(	O
operation	enum
==	O
OP_DELETE	int
)	O
{	O
if	O
(	O
S_ISDIR	O
(	O
src_stat	pointer
.	O
st_mode	int
)	O
)	O
value	pointer
=	O
erase_dir	function
(	O
ctx	pointer
,	O
source_with_path	pointer
,	O
&	O
count	int
,	O
&	O
bytes	pointer
)	O
;	O
else	O
value	pointer
=	O
erase_file	function
(	O
ctx	pointer
,	O
source_with_path	pointer
,	O
&	O
count	int
,	O
&	O
bytes	pointer
,	O
1	int
)	O
;	O
}	O
else	O
{	O
temp	pointer
=	O
transform_source	function
(	O
ctx	pointer
,	O
source_with_path	pointer
)	O
;	O
if	O
(	O
temp	pointer
==	O
NULL	O
)	O
{	O
value	pointer
=	O
transform_error	int
;	O
}	O
else	O
{	O
char	O
*	O
temp2	pointer
=	O
concat_dir_and_file	function
(	O
dest	pointer
,	O
temp	pointer
)	O
;	O
g_free	function
(	O
dest	pointer
)	O
;	O
dest	pointer
=	O
temp2	pointer
;	O
temp	pointer
=	O
NULL	O
;	O
switch	O
(	O
operation	enum
)	O
{	O
case	O
OP_COPY	int
:	O
(	O
*	O
ctx	pointer
->	O
stat_func	pointer
)	O
(	O
source_with_path	pointer
,	O
&	O
src_stat	pointer
)	O
;	O
if	O
(	O
S_ISDIR	O
(	O
src_stat	pointer
.	O
st_mode	int
)	O
)	O
value	pointer
=	O
copy_dir_dir	function
(	O
ctx	pointer
,	O
source_with_path	pointer
,	O
dest	pointer
,	O
1	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
&	O
count	int
,	O
&	O
bytes	pointer
)	O
;	O
else	O
value	pointer
=	O
copy_file_file	function
(	O
ctx	pointer
,	O
source_with_path	pointer
,	O
dest	pointer
,	O
1	int
,	O
&	O
count	int
,	O
&	O
bytes	pointer
,	O
1	int
)	O
;	O
break	O
;	O
case	O
OP_MOVE	int
:	O
if	O
(	O
S_ISDIR	O
(	O
src_stat	pointer
.	O
st_mode	int
)	O
)	O
value	pointer
=	O
move_dir_dir	function
(	O
ctx	pointer
,	O
source_with_path	pointer
,	O
dest	pointer
,	O
&	O
count	int
,	O
&	O
bytes	pointer
)	O
;	O
else	O
value	pointer
=	O
move_file_file	function
(	O
ctx	pointer
,	O
source_with_path	pointer
,	O
dest	pointer
,	O
&	O
count	int
,	O
&	O
bytes	pointer
)	O
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
(	O
value	pointer
==	O
FILE_CONT	int
)	O
&&	O
!	O
force_single	int
)	O
unmark_files	function
(	O
panel	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
operation	enum
!=	O
OP_DELETE	int
)	O
{	O
retry_many_dst_stat	O
:	O
dst_result	int
=	O
mc_stat	function
(	O
dest	pointer
,	O
&	O
dst_stat	struct
)	O
;	O
if	O
(	O
dst_result	int
==	O
0	int
&&	O
!	O
S_ISDIR	O
(	O
dst_stat	struct
.	O
st_mode	int
)	O
)	O
{	O
if	O
(	O
file_error	function
(	O
_	O
(	O
" Destination \"%s\" must be a directory \n %s "	pointer
)	O
,	O
dest	pointer
)	O
==	O
FILE_RETRY	int
)	O
goto	O
retry_many_dst_stat	O
;	O
goto	O
clean_up	O
;	O
}	O
}	O
if	O
(	O
operation	enum
!=	O
OP_MOVE	int
&&	O
verbose	int
&&	O
file_op_compute_totals	int
)	O
{	O
panel_compute_totals	function
(	O
panel	pointer
,	O
&	O
ctx	pointer
->	O
progress_count	long
,	O
&	O
ctx	pointer
->	O
progress_bytes	double
)	O
;	O
ctx	pointer
->	O
progress_totals_computed	int
=	O
1	int
;	O
}	O
else	O
{	O
ctx	pointer
->	O
progress_totals_computed	int
=	O
0	int
;	O
ctx	pointer
->	O
progress_count	long
=	O
panel	pointer
->	O
marked	int
;	O
ctx	pointer
->	O
progress_bytes	double
=	O
panel	pointer
->	O
total	double
;	O
}	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
panel	pointer
->	O
count	int
;	O
i	array
++	O
)	O
{	O
if	O
(	O
!	O
panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
i	array
]	O
.	O
f	float
.	O
marked	int
)	O
continue	O
;	O
source	pointer
=	O
panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
i	array
]	O
.	O
fname	pointer
;	O
src_stat	pointer
=	O
panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
i	array
]	O
.	O
st	pointer
;	O
g_free	function
(	O
source_with_path	pointer
)	O
;	O
source_with_path	pointer
=	O
concat_dir_and_file	function
(	O
panel	pointer
->	O
cwd	short
,	O
source	pointer
)	O
;	O
if	O
(	O
operation	enum
==	O
OP_DELETE	int
)	O
{	O
if	O
(	O
S_ISDIR	O
(	O
src_stat	pointer
.	O
st_mode	int
)	O
)	O
value	pointer
=	O
erase_dir	function
(	O
ctx	pointer
,	O
source_with_path	pointer
,	O
&	O
count	int
,	O
&	O
bytes	pointer
)	O
;	O
else	O
value	pointer
=	O
erase_file	function
(	O
ctx	pointer
,	O
source_with_path	pointer
,	O
&	O
count	int
,	O
&	O
bytes	pointer
,	O
1	int
)	O
;	O
}	O
else	O
{	O
temp	pointer
=	O
transform_source	function
(	O
ctx	pointer
,	O
source_with_path	pointer
)	O
;	O
if	O
(	O
temp	pointer
==	O
NULL	O
)	O
value	pointer
=	O
transform_error	int
;	O
else	O
{	O
char	O
*	O
temp2	pointer
=	O
concat_dir_and_file	function
(	O
dest	pointer
,	O
temp	pointer
)	O
;	O
switch	O
(	O
operation	enum
)	O
{	O
case	O
OP_COPY	int
:	O
(	O
*	O
ctx	pointer
->	O
stat_func	pointer
)	O
(	O
source_with_path	pointer
,	O
&	O
src_stat	pointer
)	O
;	O
if	O
(	O
S_ISDIR	O
(	O
src_stat	pointer
.	O
st_mode	int
)	O
)	O
value	pointer
=	O
copy_dir_dir	function
(	O
ctx	pointer
,	O
source_with_path	pointer
,	O
temp2	pointer
,	O
1	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
&	O
count	int
,	O
&	O
bytes	pointer
)	O
;	O
else	O
value	pointer
=	O
copy_file_file	function
(	O
ctx	pointer
,	O
source_with_path	pointer
,	O
temp2	pointer
,	O
1	int
,	O
&	O
count	int
,	O
&	O
bytes	pointer
,	O
1	int
)	O
;	O
free_linklist	function
(	O
&	O
dest_dirs	pointer
)	O
;	O
break	O
;	O
case	O
OP_MOVE	int
:	O
if	O
(	O
S_ISDIR	O
(	O
src_stat	pointer
.	O
st_mode	int
)	O
)	O
value	pointer
=	O
move_dir_dir	function
(	O
ctx	pointer
,	O
source_with_path	pointer
,	O
temp2	pointer
,	O
&	O
count	int
,	O
&	O
bytes	pointer
)	O
;	O
else	O
value	pointer
=	O
move_file_file	function
(	O
ctx	pointer
,	O
source_with_path	pointer
,	O
temp2	pointer
,	O
&	O
count	int
,	O
&	O
bytes	pointer
)	O
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
g_free	function
(	O
temp2	pointer
)	O
;	O
}	O
}	O
if	O
(	O
value	pointer
==	O
FILE_ABORT	int
)	O
goto	O
clean_up	O
;	O
if	O
(	O
value	pointer
==	O
FILE_CONT	int
)	O
do_file_mark	function
(	O
panel	pointer
,	O
i	array
,	O
0	int
)	O
;	O
if	O
(	O
file_progress_show_count	function
(	O
ctx	pointer
,	O
count	int
,	O
ctx	pointer
->	O
progress_count	long
)	O
==	O
FILE_ABORT	int
)	O
goto	O
clean_up	O
;	O
if	O
(	O
verbose	int
&&	O
file_progress_show_bytes	function
(	O
ctx	pointer
,	O
bytes	pointer
,	O
ctx	pointer
->	O
progress_bytes	double
)	O
==	O
FILE_ABORT	int
)	O
goto	O
clean_up	O
;	O
if	O
(	O
operation	enum
!=	O
OP_DELETE	int
&&	O
verbose	int
&&	O
file_progress_show	function
(	O
ctx	pointer
,	O
0	int
,	O
0	int
)	O
==	O
FILE_ABORT	int
)	O
goto	O
clean_up	O
;	O
mc_refresh	function
(	O
)	O
;	O
}	O
}	O
clean_up	O
:	O
if	O
(	O
save_cwd	pointer
)	O
{	O
mc_setctl	function
(	O
save_cwd	pointer
,	O
VFS_SETCTL_STALE_DATA	int
,	O
NULL	O
)	O
;	O
g_free	function
(	O
save_cwd	pointer
)	O
;	O
}	O
if	O
(	O
save_dest	pointer
)	O
{	O
mc_setctl	function
(	O
save_dest	pointer
,	O
VFS_SETCTL_STALE_DATA	int
,	O
NULL	O
)	O
;	O
g_free	function
(	O
save_dest	pointer
)	O
;	O
}	O
free_linklist	function
(	O
&	O
linklist	pointer
)	O
;	O
free_linklist	function
(	O
&	O
dest_dirs	pointer
)	O
;	O
g_free	function
(	O
source_with_path	pointer
)	O
;	O
g_free	function
(	O
dest	pointer
)	O
;	O
g_free	function
(	O
ctx	pointer
->	O
dest_mask	pointer
)	O
;	O
ctx	pointer
->	O
dest_mask	pointer
=	O
NULL	O
;	O
if	O
(	O
we_are_background	int
)	O
{	O
vfs_shut	function
(	O
)	O
;	O
_exit	function
(	O
0	int
)	O
;	O
}	O
file_op_context_destroy	function
(	O
ctx	pointer
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
real_do_file_error	function
(	O
enum	O
OperationMode	enum
mode	int
,	O
const	O
char	O
*	O
error	pointer
)	O
{	O
int	O
result	long
;	O
const	O
char	O
*	O
msg	pointer
;	O
msg	pointer
=	O
mode	int
==	O
Foreground	int
?	O
MSG_ERROR	O
:	O
_	O
(	O
" Background process error "	pointer
)	O
;	O
result	long
=	O
query_dialog	function
(	O
msg	pointer
,	O
error	pointer
,	O
D_ERROR	int
,	O
3	int
,	O
_	O
(	O
"&Skip"	pointer
)	O
,	O
_	O
(	O
"&Retry"	pointer
)	O
,	O
_	O
(	O
"&Abort"	pointer
)	O
)	O
;	O
switch	O
(	O
result	long
)	O
{	O
case	O
0	int
:	O
do_refresh	function
(	O
)	O
;	O
return	O
FILE_SKIP	int
;	O
case	O
1	int
:	O
do_refresh	function
(	O
)	O
;	O
return	O
FILE_RETRY	int
;	O
case	O
2	int
:	O
default	O
:	O
return	O
FILE_ABORT	int
;	O
}	O
}	O
int	O
file_error	function
(	O
const	O
char	O
*	O
format	pointer
,	O
const	O
char	O
*	O
file	pointer
)	O
{	O
g_snprintf	function
(	O
cmd_buf	array
,	O
sizeof	O
(	O
cmd_buf	array
)	O
,	O
format	pointer
,	O
path_trunc	function
(	O
file	pointer
,	O
30	int
)	O
,	O
unix_error_string	function
(	O
errno	O
)	O
)	O
;	O
return	O
do_file_error	function
(	O
cmd_buf	array
)	O
;	O
}	O
static	O
int	O
files_error	function
(	O
const	O
char	O
*	O
format	pointer
,	O
const	O
char	O
*	O
file1	pointer
,	O
const	O
char	O
*	O
file2	pointer
)	O
{	O
char	O
nfile1	array
[	O
16	int
]	O
;	O
char	O
nfile2	array
[	O
16	int
]	O
;	O
strcpy	function
(	O
nfile1	array
,	O
path_trunc	function
(	O
file1	pointer
,	O
15	int
)	O
)	O
;	O
strcpy	function
(	O
nfile2	array
,	O
path_trunc	function
(	O
file2	pointer
,	O
15	int
)	O
)	O
;	O
g_snprintf	function
(	O
cmd_buf	array
,	O
sizeof	O
(	O
cmd_buf	array
)	O
,	O
format	pointer
,	O
nfile1	array
,	O
nfile2	array
,	O
unix_error_string	function
(	O
errno	O
)	O
)	O
;	O
return	O
do_file_error	function
(	O
cmd_buf	array
)	O
;	O
}	O
static	O
int	O
real_query_recursive	function
(	O
FileOpContext	struct
*	O
ctx	pointer
,	O
enum	O
OperationMode	enum
mode	int
,	O
const	O
char	O
*	O
s	pointer
)	O
{	O
gchar	char
*	O
text	pointer
;	O
if	O
(	O
ctx	pointer
->	O
recursive_result	int
<	O
RECURSIVE_ALWAYS	int
)	O
{	O
const	O
char	O
*	O
msg	pointer
=	O
mode	int
==	O
Foreground	int
?	O
_	O
(	O
"\n   Directory not empty.   \n"	pointer
"   Delete it recursively? "	pointer
)	O
:	O
_	O
(	O
"\n   Background process: Directory not empty \n"	pointer
"   Delete it recursively? "	pointer
)	O
;	O
text	pointer
=	O
g_strconcat	function
(	O
_	O
(	O
" Delete: "	pointer
)	O
,	O
path_trunc	function
(	O
s	pointer
,	O
30	int
)	O
,	O
" "	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
if	O
(	O
safe_delete	int
)	O
query_set_sel	function
(	O
1	int
)	O
;	O
ctx	pointer
->	O
recursive_result	int
=	O
query_dialog	function
(	O
text	pointer
,	O
msg	pointer
,	O
D_ERROR	int
,	O
5	int
,	O
_	O
(	O
"&Yes"	pointer
)	O
,	O
_	O
(	O
"&No"	pointer
)	O
,	O
_	O
(	O
"A&ll"	pointer
)	O
,	O
_	O
(	O
"Non&e"	pointer
)	O
,	O
_	O
(	O
"&Abort"	pointer
)	O
)	O
;	O
if	O
(	O
ctx	pointer
->	O
recursive_result	int
!=	O
RECURSIVE_ABORT	int
)	O
do_refresh	function
(	O
)	O
;	O
g_free	function
(	O
text	pointer
)	O
;	O
}	O
switch	O
(	O
ctx	pointer
->	O
recursive_result	int
)	O
{	O
case	O
RECURSIVE_YES	int
:	O
case	O
RECURSIVE_ALWAYS	int
:	O
return	O
FILE_CONT	int
;	O
case	O
RECURSIVE_NO	int
:	O
case	O
RECURSIVE_NEVER	int
:	O
return	O
FILE_SKIP	int
;	O
case	O
RECURSIVE_ABORT	int
:	O
default	O
:	O
return	O
FILE_ABORT	int
;	O
}	O
}	O
static	O
int	O
do_file_error	function
(	O
const	O
char	O
*	O
str	pointer
)	O
{	O
if	O
(	O
we_are_background	int
)	O
return	O
parent_call	function
(	O
real_do_file_error	function
,	O
NULL	O
,	O
1	int
,	O
strlen	function
(	O
str	pointer
)	O
,	O
str	pointer
)	O
;	O
else	O
return	O
real_do_file_error	function
(	O
Foreground	int
,	O
str	pointer
)	O
;	O
}	O
static	O
int	O
query_recursive	function
(	O
FileOpContext	struct
*	O
ctx	pointer
,	O
const	O
char	O
*	O
s	pointer
)	O
{	O
if	O
(	O
we_are_background	int
)	O
return	O
parent_call	function
(	O
real_query_recursive	function
,	O
ctx	pointer
,	O
1	int
,	O
strlen	function
(	O
s	pointer
)	O
,	O
s	pointer
)	O
;	O
else	O
return	O
real_query_recursive	function
(	O
ctx	pointer
,	O
Foreground	int
,	O
s	pointer
)	O
;	O
}	O
static	O
int	O
query_replace	function
(	O
FileOpContext	struct
*	O
ctx	pointer
,	O
const	O
char	O
*	O
destname	pointer
,	O
struct	O
stat	struct
*	O
_s_stat	pointer
,	O
struct	O
stat	struct
*	O
_d_stat	pointer
)	O
{	O
if	O
(	O
we_are_background	int
)	O
return	O
parent_call	function
(	O
(	O
void	O
*	O
)	O
file_progress_real_query_replace	function
,	O
ctx	pointer
,	O
3	int
,	O
strlen	function
(	O
destname	pointer
)	O
,	O
destname	pointer
,	O
sizeof	O
(	O
struct	O
stat	struct
)	O
,	O
_s_stat	pointer
,	O
sizeof	O
(	O
struct	O
stat	struct
)	O
,	O
_d_stat	pointer
)	O
;	O
else	O
return	O
file_progress_real_query_replace	function
(	O
ctx	pointer
,	O
Foreground	int
,	O
destname	pointer
,	O
_s_stat	pointer
,	O
_d_stat	pointer
)	O
;	O
}	O
