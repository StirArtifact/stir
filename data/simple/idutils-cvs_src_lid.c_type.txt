typedef	O
void	O
(	O
*	O
report_func_t	pointer
)	O
(	O
char	O
const	O
*	O
name	pointer
,	O
struct	O
file_link	struct
*	O
*	O
flinkv	pointer
)	O
;	O
typedef	O
int	O
(	O
*	O
query_func_t	pointer
)	O
(	O
char	O
const	O
*	O
arg	pointer
,	O
report_func_t	pointer
)	O
;	O
enum	O
delimiter_style	enum
{	O
ds_bogus	int
,	O
ds_contextual	int
,	O
ds_word	int
,	O
ds_substring	int
}	O
;	O
enum	O
pattern_style	enum
{	O
ps_bogus	int
,	O
ps_contextual	int
,	O
ps_literal	int
,	O
ps_regexp	int
}	O
;	O
enum	O
key_style	enum
{	O
ks_bogus	int
,	O
ks_none	int
,	O
ks_token	int
,	O
ks_pattern	int
}	O
;	O
enum	O
result_style	enum
{	O
rs_bogus	int
,	O
rs_none	int
,	O
rs_filenames	int
,	O
rs_grep	int
,	O
rs_edit	int
}	O
;	O
enum	O
radix	enum
{	O
radix_oct	int
=	O
1	int
,	O
radix_dec	int
=	O
2	int
,	O
radix_hex	int
=	O
4	int
,	O
radix_all	int
=	O
radix_dec	int
|	O
radix_oct	int
|	O
radix_hex	int
}	O
;	O
void	O
usage	function
(	O
void	O
)	O
;	O
static	O
void	O
help_me	function
(	O
void	O
)	O
;	O
void	O
lower_caseify	function
(	O
char	O
*	O
str	pointer
)	O
;	O
enum	O
key_style	enum
parse_key_style	function
(	O
char	O
const	O
*	O
arg	pointer
)	O
;	O
enum	O
result_style	enum
parse_result_style	function
(	O
char	O
const	O
*	O
arg	pointer
)	O
;	O
query_func_t	pointer
get_query_func	function
(	O
char	O
*	O
pattern	pointer
)	O
;	O
report_func_t	pointer
get_report_func	function
(	O
void	O
)	O
;	O
void	O
report_filenames	function
(	O
char	O
const	O
*	O
name	pointer
,	O
struct	O
file_link	struct
*	O
*	O
flinkv	pointer
)	O
;	O
void	O
report_grep	function
(	O
char	O
const	O
*	O
name	pointer
,	O
struct	O
file_link	struct
*	O
*	O
flinkv	pointer
)	O
;	O
void	O
report_edit	function
(	O
char	O
const	O
*	O
name	pointer
,	O
struct	O
file_link	struct
*	O
*	O
flinkv	pointer
)	O
;	O
void	O
report_nothing	function
(	O
char	O
const	O
*	O
name	pointer
,	O
struct	O
file_link	struct
*	O
*	O
flinkv	pointer
)	O
;	O
int	O
vector_cardinality	function
(	O
void	O
*	O
vector	pointer
)	O
;	O
int	O
search_flinkv	function
(	O
struct	O
file_link	struct
*	O
*	O
flinkv	pointer
)	O
;	O
int	O
query_literal_word	function
(	O
char	O
const	O
*	O
pattern	pointer
,	O
report_func_t	pointer
report_func	pointer
)	O
;	O
int	O
query_literal_prefix	function
(	O
char	O
const	O
*	O
pattern	pointer
,	O
report_func_t	pointer
report_func	pointer
)	O
;	O
int	O
query_regexp	function
(	O
char	O
const	O
*	O
pattern_0	pointer
,	O
report_func_t	pointer
report_func	pointer
)	O
;	O
char	O
const	O
*	O
add_regexp_word_delimiters	function
(	O
char	O
const	O
*	O
pattern_0	pointer
)	O
;	O
int	O
query_number	function
(	O
char	O
const	O
*	O
pattern	pointer
,	O
report_func_t	pointer
report_func	pointer
)	O
;	O
int	O
query_ambiguous_prefix	function
(	O
unsigned	O
int	O
,	O
report_func_t	pointer
report_func	pointer
)	O
;	O
int	O
query_literal_substring	function
(	O
char	O
const	O
*	O
pattern	pointer
,	O
report_func_t	pointer
report_func	pointer
)	O
;	O
void	O
parse_frequency_arg	function
(	O
char	O
const	O
*	O
arg	pointer
)	O
;	O
int	O
desired_frequency	function
(	O
char	O
const	O
*	O
tok	pointer
)	O
;	O
char	O
*	O
strcasestr	function
(	O
char	O
const	O
*	O
s1	pointer
,	O
char	O
const	O
*	O
s2	pointer
)	O
;	O
char	O
const	O
*	O
file_regexp	function
(	O
char	O
const	O
*	O
name_0	pointer
,	O
char	O
const	O
*	O
left_delimit	pointer
,	O
char	O
const	O
*	O
right_delimit	pointer
)	O
;	O
off_t	long
query_binary_search	function
(	O
char	O
const	O
*	O
token	pointer
)	O
;	O
int	O
is_regexp	function
(	O
char	O
*	O
name	pointer
)	O
;	O
int	O
has_left_delimiter	function
(	O
char	O
const	O
*	O
pattern	pointer
)	O
;	O
int	O
has_right_delimiter	function
(	O
char	O
const	O
*	O
pattern	pointer
)	O
;	O
int	O
file_name_wildcard	function
(	O
char	O
const	O
*	O
re	pointer
,	O
char	O
const	O
*	O
fn	pointer
)	O
;	O
int	O
word_match	function
(	O
char	O
const	O
*	O
name_0	pointer
,	O
char	O
const	O
*	O
line	pointer
)	O
;	O
int	O
get_radix	function
(	O
char	O
const	O
*	O
str	pointer
)	O
;	O
int	O
is_number	function
(	O
char	O
const	O
*	O
str	pointer
)	O
;	O
int	O
stoi	function
(	O
char	O
const	O
*	O
str	pointer
)	O
;	O
int	O
otoi	function
(	O
char	O
const	O
*	O
str	pointer
)	O
;	O
int	O
dtoi	function
(	O
char	O
const	O
*	O
str	pointer
)	O
;	O
int	O
xtoi	function
(	O
char	O
const	O
*	O
str	pointer
)	O
;	O
unsigned	O
char	O
*	O
tree8_to_bits	function
(	O
unsigned	O
char	O
*	O
bits_vec	pointer
,	O
unsigned	O
char	O
const	O
*	O
hits_tree8	pointer
)	O
;	O
void	O
tree8_to_bits_1	function
(	O
unsigned	O
char	O
*	O
*	O
bits_vec	pointer
,	O
unsigned	O
char	O
const	O
*	O
*	O
hits_tree8	pointer
,	O
int	O
level	int
)	O
;	O
struct	O
file_link	struct
*	O
*	O
tree8_to_flinkv	function
(	O
unsigned	O
char	O
const	O
*	O
hits_tree8	pointer
)	O
;	O
struct	O
file_link	struct
*	O
*	O
bits_to_flinkv	function
(	O
unsigned	O
char	O
const	O
*	O
bits_vec	pointer
)	O
;	O
void	O
savetty	function
(	O
void	O
)	O
;	O
void	O
restoretty	function
(	O
void	O
)	O
;	O
void	O
linetty	function
(	O
void	O
)	O
;	O
void	O
chartty	function
(	O
void	O
)	O
;	O
char	O
anchor_dir	array
[	O
BUFSIZ	int
]	O
;	O
int	O
tree8_levels	int
;	O
unsigned	O
int	O
bits_vec_size	int
;	O
struct	O
idhead	struct
idh	struct
;	O
char	O
*	O
hits_buf_1	pointer
;	O
char	O
*	O
hits_buf_2	pointer
;	O
unsigned	O
char	O
*	O
bits_vec	pointer
;	O
char	O
const	O
*	O
program_name	pointer
;	O
static	O
int	O
show_help	int
;	O
static	O
int	O
show_version	int
;	O
int	O
radix_flag	int
=	O
radix_all	int
;	O
int	O
ignore_case_flag	int
=	O
0	int
;	O
enum	O
delimiter_style	enum
delimiter_style	enum
=	O
ds_contextual	int
;	O
enum	O
pattern_style	enum
pattern_style	enum
=	O
ps_contextual	int
;	O
enum	O
key_style	enum
key_style	enum
=	O
ks_token	int
;	O
enum	O
result_style	enum
result_style	enum
=	O
rs_filenames	int
;	O
enum	O
separator_style	enum
separator_style	enum
=	O
ss_contextual	int
;	O
unsigned	O
int	O
ambiguous_prefix_length	int
=	O
0	int
;	O
report_func_t	pointer
report_function	pointer
;	O
query_func_t	pointer
query_function	pointer
;	O
unsigned	O
int	O
frequency_low	int
=	O
1	int
;	O
unsigned	O
int	O
frequency_high	int
=	O
USHRT_MAX	O
;	O
struct	O
file_link	struct
*	O
cw_dlink	pointer
;	O
struct	O
file_link	struct
*	O
*	O
members_0	pointer
;	O
static	O
struct	O
option	struct
const	O
long_options	array
[	O
]	O
=	O
{	O
{	O
"file"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'f'	O
}	O
,	O
{	O
"frequency"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'F'	O
}	O
,	O
{	O
"ambiguous"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'a'	O
}	O
,	O
{	O
"key"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'k'	O
}	O
,	O
{	O
"result"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'R'	O
}	O
,	O
{	O
"separator"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'S'	O
}	O
,	O
{	O
"ignore-case"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'i'	O
}	O
,	O
{	O
"literal"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'l'	O
}	O
,	O
{	O
"regexp"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'r'	O
}	O
,	O
{	O
"word"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'w'	O
}	O
,	O
{	O
"substring"	pointer
,	O
no_argument	int
,	O
0	int
,	O
's'	O
}	O
,	O
{	O
"hex"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'x'	O
}	O
,	O
{	O
"decimal"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'd'	O
}	O
,	O
{	O
"octal"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'o'	O
}	O
,	O
{	O
"help"	pointer
,	O
no_argument	int
,	O
&	O
show_help	int
,	O
1	int
}	O
,	O
{	O
"version"	pointer
,	O
no_argument	int
,	O
&	O
show_version	int
,	O
1	int
}	O
,	O
{	O
0	int
}	O
}	O
;	O
void	O
usage	function
(	O
void	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Try `%s --help' for more information.\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
static	O
void	O
help_me	function
(	O
void	O
)	O
{	O
printf	function
(	O
_	O
(	O
"Usage: %s [OPTION]... PATTERN...\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Query ID database and report results.\nBy default, output consists of multiple lines, each line containing the\nmatched identifier followed by the list of file names in which it occurs.\n\n  -f, --file=FILE       file name of ID database\n\n  -i, --ignore-case     match PATTERN case insensitively\n  -l, --literal         match PATTERN as a literal string\n  -r, --regexp          match PATTERN as a regular expression\n  -w, --word            match PATTERN as a delimited word\n  -s, --substring       match PATTERN as a substring\n            Note: If PATTERN contains extended regular expression meta-\n            characters, it is interpreted as a regular expression substring.\n            Otherwise, PATTERN is interpreted as a literal word.\n\n  -k, --key=STYLE       STYLE is one of `token', `pattern' or `none'\n  -R, --result=STYLE    STYLE is one of `filenames', `grep', `edit' or `none'\n  -S, --separator=STYLE STYLE is one of `braces', `space' or `newline' and\n                        only applies to file names when `--result=filenames'\n            The above STYLE options control how query results are presented.\n            Defaults are --key=token --result=filenames --separator=%s\n\n  -F, --frequency=FREQ  find tokens that occur FREQ times, where FREQ\n                        is a range expressed as `N..M'.  If N is omitted, it\n                        defaults to 1, if M is omitted it defaults to MAX_USHRT\n  -a, --ambiguous=LEN   find tokens whose names are ambiguous for LEN chars\n\n  -x, --hex             only find numbers expressed as hexadecimal\n  -d, --decimal         only find numbers expressed as decimal\n  -o, --octal           only find numbers expressed as octal\n            By default, searches match numbers of any radix.\n\n      --help            display this help and exit\n      --version         output version information and exit\n"	pointer
)	O
,	O
(	O
separator_style	enum
==	O
ss_braces	int
?	O
_	O
(	O
"braces"	pointer
)	O
:	O
_	O
(	O
"space"	pointer
)	O
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"\nReport bugs to "	pointer
PACKAGE_BUGREPORT	pointer
"\n\n"	pointer
)	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
program_name	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
idh	struct
.	O
idh_file_name	pointer
=	O
0	int
;	O
setlocale	function
(	O
LC_ALL	O
,	O
""	pointer
)	O
;	O
bindtextdomain	function
(	O
PACKAGE	pointer
,	O
LOCALEDIR	O
)	O
;	O
textdomain	function
(	O
PACKAGE	pointer
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
optc	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
"f:F:a:k:R:S:ilrwsxdo"	pointer
,	O
long_options	array
,	O
(	O
int	O
*	O
)	O
0	int
)	O
;	O
if	O
(	O
optc	int
<	O
0	int
)	O
break	O
;	O
switch	O
(	O
optc	int
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
'f'	O
:	O
idh	struct
.	O
idh_file_name	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'F'	O
:	O
parse_frequency_arg	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'a'	O
:	O
ambiguous_prefix_length	int
=	O
stoi	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'k'	O
:	O
key_style	enum
=	O
parse_key_style	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'R'	O
:	O
result_style	enum
=	O
parse_result_style	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'S'	O
:	O
separator_style	enum
=	O
parse_separator_style	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'i'	O
:	O
ignore_case_flag	int
=	O
REG_ICASE	O
;	O
break	O
;	O
case	O
'l'	O
:	O
pattern_style	enum
=	O
ps_literal	int
;	O
break	O
;	O
case	O
'r'	O
:	O
pattern_style	enum
=	O
ps_regexp	int
;	O
break	O
;	O
case	O
'e'	O
:	O
pattern_style	enum
=	O
ps_regexp	int
;	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"notice: use of `-e' is deprecated, use `-r' instead"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
'w'	O
:	O
delimiter_style	enum
=	O
ds_word	int
;	O
break	O
;	O
case	O
's'	O
:	O
delimiter_style	enum
=	O
ds_substring	int
;	O
break	O
;	O
case	O
'x'	O
:	O
radix_flag	int
|=	O
radix_hex	int
;	O
break	O
;	O
case	O
'd'	O
:	O
radix_flag	int
|=	O
radix_dec	int
;	O
break	O
;	O
case	O
'o'	O
:	O
radix_flag	int
|=	O
radix_oct	int
;	O
break	O
;	O
default	O
:	O
usage	function
(	O
)	O
;	O
}	O
}	O
if	O
(	O
show_version	int
)	O
{	O
printf	function
(	O
"%s - %s\n"	pointer
,	O
program_name	pointer
,	O
PACKAGE_VERSION	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
if	O
(	O
show_help	int
)	O
help_me	function
(	O
)	O
;	O
if	O
(	O
separator_style	enum
==	O
ss_contextual	int
)	O
{	O
if	O
(	O
isatty	function
(	O
STDOUT_FILENO	int
)	O
)	O
separator_style	enum
=	O
DEFAULT_SEPARATOR_STYLE	O
;	O
else	O
if	O
(	O
key_style	enum
==	O
ks_none	int
)	O
separator_style	enum
=	O
ss_newline	int
;	O
else	O
separator_style	enum
=	O
ss_space	int
;	O
}	O
argc	int
-=	O
optind	int
;	O
argv	pointer
+=	O
optind	int
;	O
if	O
(	O
argc	int
==	O
0	int
)	O
{	O
static	O
char	O
dot	array
[	O
]	O
=	O
"."	pointer
;	O
static	O
char	O
*	O
dotp	pointer
=	O
dot	array
;	O
argc	int
=	O
1	int
;	O
argv	pointer
=	O
&	O
dotp	pointer
;	O
}	O
idh	struct
.	O
idh_file_name	pointer
=	O
locate_id_file_name	function
(	O
idh	struct
.	O
idh_file_name	pointer
)	O
;	O
if	O
(	O
idh	struct
.	O
idh_file_name	pointer
==	O
0	int
)	O
error	function
(	O
1	int
,	O
errno	O
,	O
_	O
(	O
"can't locate `ID'"	pointer
)	O
)	O
;	O
init_idh_obstacks	function
(	O
&	O
idh	struct
)	O
;	O
init_idh_tables	function
(	O
&	O
idh	struct
)	O
;	O
cw_dlink	pointer
=	O
get_current_dir_link	function
(	O
)	O
;	O
members_0	pointer
=	O
read_id_file	function
(	O
idh	struct
.	O
idh_file_name	pointer
,	O
&	O
idh	struct
)	O
;	O
bits_vec_size	int
=	O
(	O
idh	struct
.	O
idh_files	long
+	O
7	int
)	O
/	O
4	int
;	O
tree8_levels	int
=	O
tree8_count_levels	function
(	O
idh	struct
.	O
idh_files	long
)	O
;	O
hits_buf_1	pointer
=	O
xmalloc	function
(	O
idh	struct
.	O
idh_buf_size	long
)	O
;	O
hits_buf_2	pointer
=	O
xmalloc	function
(	O
idh	struct
.	O
idh_buf_size	long
)	O
;	O
bits_vec	pointer
=	O
xmalloc	function
(	O
bits_vec_size	int
)	O
;	O
report_function	pointer
=	O
get_report_func	function
(	O
)	O
;	O
if	O
(	O
ambiguous_prefix_length	int
)	O
{	O
if	O
(	O
!	O
query_ambiguous_prefix	function
(	O
ambiguous_prefix_length	int
,	O
report_function	pointer
)	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"All identifiers are non-ambiguous within the first %d characters\n"	pointer
)	O
,	O
ambiguous_prefix_length	int
)	O
;	O
}	O
else	O
{	O
while	O
(	O
argc	int
)	O
{	O
char	O
*	O
pattern	pointer
=	O
(	O
argc	int
--	O
,	O
*	O
argv	pointer
++	O
)	O
;	O
if	O
(	O
ignore_case_flag	int
)	O
lower_caseify	function
(	O
pattern	pointer
)	O
;	O
query_function	pointer
=	O
get_query_func	function
(	O
pattern	pointer
)	O
;	O
(	O
*	O
query_function	pointer
)	O
(	O
pattern	pointer
,	O
report_function	pointer
)	O
;	O
}	O
}	O
fclose	function
(	O
idh	struct
.	O
idh_FILE	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
void	O
lower_caseify	function
(	O
char	O
*	O
str	pointer
)	O
{	O
while	O
(	O
*	O
str	pointer
)	O
{	O
*	O
str	pointer
=	O
TOLOWER	O
(	O
*	O
str	pointer
)	O
;	O
str	pointer
++	O
;	O
}	O
}	O
enum	O
key_style	enum
parse_key_style	function
(	O
char	O
const	O
*	O
arg	pointer
)	O
{	O
MAYBE_RETURN_PREFIX_MATCH	O
(	O
arg	pointer
,	O
"none"	pointer
,	O
ks_none	int
)	O
;	O
MAYBE_RETURN_PREFIX_MATCH	O
(	O
arg	pointer
,	O
"token"	pointer
,	O
ks_token	int
)	O
;	O
MAYBE_RETURN_PREFIX_MATCH	O
(	O
arg	pointer
,	O
"pattern"	pointer
,	O
ks_pattern	int
)	O
;	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"invalid `--key' style: `%s'"	pointer
)	O
,	O
arg	pointer
)	O
;	O
usage	function
(	O
)	O
;	O
return	O
ks_bogus	int
;	O
}	O
enum	O
result_style	enum
parse_result_style	function
(	O
char	O
const	O
*	O
arg	pointer
)	O
{	O
MAYBE_RETURN_PREFIX_MATCH	O
(	O
arg	pointer
,	O
"none"	pointer
,	O
rs_none	int
)	O
;	O
MAYBE_RETURN_PREFIX_MATCH	O
(	O
arg	pointer
,	O
"filenames"	pointer
,	O
rs_filenames	int
)	O
;	O
MAYBE_RETURN_PREFIX_MATCH	O
(	O
arg	pointer
,	O
"grep"	pointer
,	O
rs_grep	int
)	O
;	O
MAYBE_RETURN_PREFIX_MATCH	O
(	O
arg	pointer
,	O
"edit"	pointer
,	O
rs_edit	int
)	O
;	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"invalid `--result' style: `%s'"	pointer
)	O
,	O
arg	pointer
)	O
;	O
usage	function
(	O
)	O
;	O
return	O
rs_bogus	int
;	O
}	O
query_func_t	pointer
get_query_func	function
(	O
char	O
*	O
pattern	pointer
)	O
{	O
switch	O
(	O
pattern_style	enum
)	O
{	O
case	O
ps_regexp	int
:	O
return	O
query_regexp	function
;	O
case	O
ps_literal	int
:	O
if	O
(	O
delimiter_style	enum
==	O
ds_substring	int
)	O
return	O
query_literal_substring	function
;	O
else	O
return	O
query_literal_word	function
;	O
default	O
:	O
if	O
(	O
is_regexp	function
(	O
pattern	pointer
)	O
)	O
return	O
query_regexp	function
;	O
else	O
if	O
(	O
has_left_delimiter	function
(	O
pattern	pointer
)	O
)	O
return	O
query_literal_prefix	function
;	O
else	O
if	O
(	O
delimiter_style	enum
==	O
ds_substring	int
)	O
return	O
query_literal_substring	function
;	O
else	O
if	O
(	O
is_number	function
(	O
pattern	pointer
)	O
)	O
return	O
query_number	function
;	O
else	O
if	O
(	O
delimiter_style	enum
==	O
ds_word	int
)	O
return	O
query_literal_word	function
;	O
else	O
return	O
query_literal_word	function
;	O
}	O
}	O
report_func_t	pointer
get_report_func	function
(	O
void	O
)	O
{	O
switch	O
(	O
result_style	enum
)	O
{	O
case	O
rs_filenames	int
:	O
return	O
report_filenames	function
;	O
case	O
rs_grep	int
:	O
return	O
report_grep	function
;	O
case	O
rs_edit	int
:	O
return	O
report_edit	function
;	O
default	O
:	O
return	O
report_nothing	function
;	O
}	O
}	O
void	O
report_filenames	function
(	O
char	O
const	O
*	O
name	pointer
,	O
struct	O
file_link	struct
*	O
*	O
flinkv	pointer
)	O
{	O
if	O
(	O
name	pointer
&&	O
key_style	enum
!=	O
ks_none	int
)	O
printf	function
(	O
"%-14s "	pointer
,	O
name	pointer
)	O
;	O
print_filenames	function
(	O
flinkv	pointer
,	O
separator_style	enum
)	O
;	O
}	O
void	O
report_grep	function
(	O
char	O
const	O
*	O
name	pointer
,	O
struct	O
file_link	struct
*	O
*	O
flinkv	pointer
)	O
{	O
char	O
line	pointer
[	O
1	int
<<	O
020	int
]	O
;	O
char	O
const	O
*	O
pattern	pointer
=	O
0	int
;	O
regex_t	struct
compiled	struct
;	O
char	O
*	O
file_name	pointer
=	O
alloca	O
(	O
PATH_MAX	int
)	O
;	O
if	O
(	O
key_style	enum
==	O
ks_pattern	int
)	O
{	O
pattern	pointer
=	O
file_regexp	function
(	O
name	pointer
,	O
"[^a-zA-Z0-9_\300-\377]_*"	pointer
,	O
"[^a-zA-Z0-9_\300-\377]"	pointer
)	O
;	O
if	O
(	O
pattern	pointer
)	O
{	O
int	O
regcomp_errno	int
=	O
regcomp	O
(	O
&	O
compiled	struct
,	O
pattern	pointer
,	O
ignore_case_flag	int
|	O
REG_EXTENDED	int
)	O
;	O
if	O
(	O
regcomp_errno	int
)	O
{	O
char	O
buf	pointer
[	O
BUFSIZ	int
]	O
;	O
regerror	O
(	O
regcomp_errno	int
,	O
&	O
compiled	struct
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
;	O
error	function
(	O
1	int
,	O
0	int
,	O
"%s"	pointer
,	O
buf	pointer
)	O
;	O
}	O
}	O
}	O
line	pointer
[	O
0	int
]	O
=	O
' '	O
;	O
while	O
(	O
*	O
flinkv	pointer
)	O
{	O
int	O
line_number	int
=	O
0	int
;	O
FILE	struct
*	O
source_FILE	pointer
;	O
maybe_relative_file_name	function
(	O
file_name	pointer
,	O
*	O
flinkv	pointer
++	O
,	O
cw_dlink	pointer
)	O
;	O
source_FILE	pointer
=	O
fopen	function
(	O
file_name	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
source_FILE	pointer
==	O
0	int
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
"can't open `%s'"	pointer
,	O
file_name	pointer
)	O
;	O
continue	O
;	O
}	O
while	O
(	O
fgets	function
(	O
line	pointer
+	O
1	int
,	O
sizeof	O
(	O
line	pointer
)	O
-	O
1	int
,	O
source_FILE	pointer
)	O
)	O
{	O
line_number	int
++	O
;	O
if	O
(	O
pattern	pointer
)	O
{	O
int	O
regexec_errno	int
=	O
regexec	O
(	O
&	O
compiled	struct
,	O
line	pointer
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
regexec_errno	int
==	O
REG_ESPACE	O
)	O
error	function
(	O
1	int
,	O
0	int
,	O
"can't match regular-expression: memory exhausted"	pointer
)	O
;	O
else	O
if	O
(	O
regexec_errno	int
)	O
continue	O
;	O
}	O
else	O
if	O
(	O
word_match	function
(	O
name	pointer
,	O
line	pointer
)	O
)	O
printf	function
(	O
"%s:%d:%s"	pointer
,	O
file_name	pointer
,	O
line_number	int
,	O
line	pointer
+	O
1	int
)	O
;	O
}	O
fclose	function
(	O
source_FILE	pointer
)	O
;	O
}	O
}	O
static	O
char	O
*	O
*	O
get_editor_argv	function
(	O
char	O
*	O
fullstring	pointer
,	O
int	O
*	O
argc	int
)	O
{	O
int	O
i	int
;	O
char	O
*	O
mark	pointer
;	O
char	O
*	O
*	O
argv	pointer
;	O
static	O
int	O
already_called	int
;	O
assert	O
(	O
already_called	int
==	O
0	int
)	O
;	O
*	O
argc	int
=	O
1	int
;	O
mark	pointer
=	O
fullstring	pointer
;	O
while	O
(	O
(	O
mark	pointer
=	O
strchr	function
(	O
mark	pointer
,	O
' '	O
)	O
)	O
)	O
{	O
(	O
*	O
argc	int
)	O
++	O
;	O
mark	pointer
+=	O
strspn	function
(	O
mark	pointer
,	O
" "	pointer
)	O
;	O
}	O
argv	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
*	O
argc	int
+	O
1	int
)	O
)	O
;	O
fullstring	pointer
=	O
strdup	function
(	O
fullstring	pointer
)	O
;	O
argv	pointer
[	O
0	int
]	O
=	O
strtok	function
(	O
fullstring	pointer
,	O
" "	pointer
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
(	O
*	O
argc	int
+	O
1	int
)	O
;	O
i	int
++	O
)	O
{	O
argv	pointer
[	O
i	int
]	O
=	O
strtok	function
(	O
NULL	O
,	O
" "	pointer
)	O
;	O
}	O
already_called	int
=	O
1	int
;	O
return	O
argv	pointer
;	O
}	O
void	O
report_edit	function
(	O
char	O
const	O
*	O
name	pointer
,	O
struct	O
file_link	struct
*	O
*	O
flinkv	pointer
)	O
{	O
static	O
char	O
*	O
editor	pointer
;	O
static	O
char	O
*	O
*	O
editor_argv	pointer
;	O
static	O
int	O
editor_argc	int
;	O
static	O
char	O
const	O
*	O
eid_arg	pointer
;	O
static	O
char	O
const	O
*	O
eid_right_del	pointer
;	O
static	O
char	O
const	O
*	O
eid_left_del	pointer
;	O
char	O
regexp_buf	array
[	O
BUFSIZ	int
]	O
;	O
char	O
ed_arg_buffer	array
[	O
BUFSIZ	int
]	O
;	O
char	O
const	O
*	O
pattern	pointer
;	O
int	O
c	int
;	O
int	O
skip	int
;	O
if	O
(	O
!	O
editor	pointer
)	O
if	O
(	O
!	O
(	O
editor	pointer
=	O
getenv	function
(	O
"VISUAL"	pointer
)	O
)	O
)	O
if	O
(	O
!	O
(	O
editor	pointer
=	O
getenv	function
(	O
"EDITOR"	pointer
)	O
)	O
)	O
editor	pointer
=	O
"vi"	pointer
;	O
if	O
(	O
!	O
editor_argv	pointer
)	O
editor_argv	pointer
=	O
get_editor_argv	function
(	O
editor	pointer
,	O
&	O
editor_argc	int
)	O
;	O
if	O
(	O
!	O
eid_arg	pointer
)	O
{	O
int	O
using_vi	int
;	O
using_vi	int
=	O
strequ	O
(	O
"vi"	pointer
,	O
base_name	function
(	O
editor	pointer
)	O
)	O
||	O
strequ	O
(	O
"vim"	pointer
,	O
base_name	function
(	O
editor	pointer
)	O
)	O
;	O
eid_arg	pointer
=	O
getenv	function
(	O
"EIDARG"	pointer
)	O
;	O
if	O
(	O
!	O
eid_arg	pointer
)	O
eid_arg	pointer
=	O
(	O
using_vi	int
?	O
"+1;/%s/"	pointer
:	O
""	pointer
)	O
;	O
eid_left_del	pointer
=	O
getenv	function
(	O
"EIDLDEL"	pointer
)	O
;	O
if	O
(	O
eid_left_del	pointer
==	O
0	int
)	O
eid_left_del	pointer
=	O
(	O
using_vi	int
?	O
"\\<"	pointer
:	O
""	pointer
)	O
;	O
eid_right_del	pointer
=	O
getenv	function
(	O
"EIDRDEL"	pointer
)	O
;	O
if	O
(	O
eid_right_del	pointer
==	O
0	int
)	O
eid_right_del	pointer
=	O
(	O
using_vi	int
?	O
"\\>"	pointer
:	O
""	pointer
)	O
;	O
}	O
report_filenames	function
(	O
name	pointer
,	O
flinkv	pointer
)	O
;	O
savetty	function
(	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
printf	function
(	O
_	O
(	O
"edit? [y1-9^S/nq] "	pointer
)	O
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
chartty	function
(	O
)	O
;	O
c	int
=	O
(	O
getchar	function
(	O
)	O
&	O
0177	int
)	O
;	O
restoretty	function
(	O
)	O
;	O
switch	O
(	O
TOLOWER	O
(	O
c	int
)	O
)	O
{	O
case	O
'/'	O
:	O
case	O
(	O
's'	O
&	O
037	int
)	O
:	O
putchar	function
(	O
'/'	O
)	O
;	O
skip	int
=	O
search_flinkv	function
(	O
flinkv	pointer
)	O
;	O
if	O
(	O
skip	int
<	O
0	int
)	O
continue	O
;	O
flinkv	pointer
+=	O
skip	int
;	O
goto	O
editit	O
;	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
putchar	function
(	O
c	int
)	O
;	O
skip	int
=	O
c	int
-	O
'0'	O
;	O
break	O
;	O
case	O
'y'	O
:	O
putchar	function
(	O
c	int
)	O
;	O
skip	int
=	O
0	int
;	O
break	O
;	O
case	O
'\n'	O
:	O
case	O
'\r'	O
:	O
putchar	function
(	O
'y'	O
)	O
;	O
skip	int
=	O
0	int
;	O
break	O
;	O
case	O
'q'	O
:	O
putchar	function
(	O
c	int
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
case	O
'n'	O
:	O
putchar	function
(	O
c	int
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
return	O
;	O
default	O
:	O
putchar	function
(	O
c	int
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
continue	O
;	O
}	O
putchar	function
(	O
'\n'	O
)	O
;	O
while	O
(	O
skip	int
--	O
)	O
if	O
(	O
*	O
++	O
flinkv	pointer
==	O
0	int
)	O
continue	O
;	O
break	O
;	O
}	O
editit	O
:	O
if	O
(	O
key_style	enum
==	O
ks_pattern	int
)	O
pattern	pointer
=	O
file_regexp	function
(	O
name	pointer
,	O
eid_left_del	pointer
,	O
eid_right_del	pointer
)	O
;	O
else	O
pattern	pointer
=	O
0	int
;	O
if	O
(	O
pattern	pointer
==	O
0	int
)	O
{	O
pattern	pointer
=	O
regexp_buf	array
;	O
sprintf	function
(	O
regexp_buf	array
,	O
"%s%s%s"	pointer
,	O
eid_left_del	pointer
,	O
name	pointer
,	O
eid_right_del	pointer
)	O
;	O
}	O
switch	O
(	O
fork	function
(	O
)	O
)	O
{	O
case	O
-	O
1	int
:	O
error	function
(	O
1	int
,	O
errno	O
,	O
_	O
(	O
"can't fork"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
0	int
:	O
{	O
int	O
i	int
;	O
char	O
*	O
*	O
argv	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
editor_argc	int
+	O
2	int
+	O
vector_cardinality	function
(	O
flinkv	pointer
)	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
editor_argc	int
;	O
i	int
++	O
)	O
argv	pointer
[	O
i	int
]	O
=	O
editor_argv	pointer
[	O
i	int
]	O
;	O
if	O
(	O
*	O
eid_arg	pointer
)	O
{	O
sprintf	function
(	O
ed_arg_buffer	array
,	O
eid_arg	pointer
,	O
pattern	pointer
)	O
;	O
argv	pointer
[	O
i	int
++	O
]	O
=	O
ed_arg_buffer	array
;	O
}	O
while	O
(	O
*	O
flinkv	pointer
)	O
argv	pointer
[	O
i	int
++	O
]	O
=	O
maybe_relative_file_name	function
(	O
0	int
,	O
*	O
flinkv	pointer
++	O
,	O
cw_dlink	pointer
)	O
;	O
argv	pointer
[	O
i	int
]	O
=	O
0	int
;	O
execvp	function
(	O
editor_argv	pointer
[	O
0	int
]	O
,	O
argv	pointer
)	O
;	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"can't exec `%s'"	pointer
)	O
,	O
editor_argv	pointer
[	O
0	int
]	O
)	O
;	O
}	O
default	O
:	O
{	O
void	O
(	O
*	O
oldint	pointer
)	O
(	O
int	O
)	O
=	O
signal	function
(	O
SIGINT	int
,	O
SIG_IGN	O
)	O
;	O
void	O
(	O
*	O
oldquit	pointer
)	O
(	O
int	O
)	O
=	O
signal	function
(	O
SIGQUIT	int
,	O
SIG_IGN	O
)	O
;	O
while	O
(	O
wait	function
(	O
0	int
)	O
==	O
-	O
1	int
&&	O
errno	O
==	O
EINTR	int
)	O
;	O
signal	function
(	O
SIGINT	int
,	O
oldint	pointer
)	O
;	O
signal	function
(	O
SIGQUIT	int
,	O
oldquit	pointer
)	O
;	O
}	O
break	O
;	O
}	O
}	O
void	O
report_nothing	function
(	O
char	O
const	O
*	O
name	pointer
,	O
struct	O
file_link	struct
*	O
*	O
flinkv	pointer
)	O
{	O
if	O
(	O
key_style	enum
!=	O
ks_none	int
)	O
puts	function
(	O
name	pointer
)	O
;	O
}	O
int	O
vector_cardinality	function
(	O
void	O
*	O
vector	pointer
)	O
{	O
void	O
*	O
*	O
v	pointer
=	O
(	O
void	O
*	O
*	O
)	O
vector	pointer
;	O
int	O
count	int
=	O
0	int
;	O
while	O
(	O
*	O
v	pointer
++	O
)	O
count	int
++	O
;	O
return	O
count	int
;	O
}	O
int	O
search_flinkv	function
(	O
struct	O
file_link	struct
*	O
*	O
flinkv	pointer
)	O
{	O
char	O
pattern	pointer
[	O
BUFSIZ	int
]	O
;	O
unsigned	O
int	O
count	int
;	O
char	O
*	O
file_name	pointer
=	O
alloca	O
(	O
PATH_MAX	int
)	O
;	O
char	O
*	O
eol	pointer
;	O
if	O
(	O
fgets	function
(	O
pattern	pointer
,	O
sizeof	O
(	O
pattern	pointer
)	O
,	O
stdin	pointer
)	O
==	O
0	int
)	O
return	O
-	O
1	int
;	O
eol	pointer
=	O
strchr	function
(	O
pattern	pointer
,	O
'\n'	O
)	O
;	O
if	O
(	O
eol	pointer
)	O
*	O
eol	pointer
=	O
0	int
;	O
for	O
(	O
count	int
=	O
0	int
;	O
*	O
flinkv	pointer
;	O
count	int
++	O
,	O
flinkv	pointer
++	O
)	O
{	O
maybe_relative_file_name	function
(	O
file_name	pointer
,	O
*	O
flinkv	pointer
,	O
cw_dlink	pointer
)	O
;	O
if	O
(	O
strcasestr	function
(	O
file_name	pointer
,	O
pattern	pointer
)	O
)	O
return	O
count	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
int	O
query_literal_word	function
(	O
char	O
const	O
*	O
arg	pointer
,	O
report_func_t	pointer
report_func	pointer
)	O
{	O
if	O
(	O
ignore_case_flag	int
)	O
return	O
query_literal_substring	function
(	O
arg	pointer
,	O
report_func	pointer
)	O
;	O
if	O
(	O
query_binary_search	function
(	O
arg	pointer
)	O
==	O
0	int
)	O
return	O
0	int
;	O
gets_past_00	function
(	O
hits_buf_1	pointer
,	O
idh	struct
.	O
idh_FILE	pointer
)	O
;	O
assert	O
(	O
*	O
hits_buf_1	pointer
)	O
;	O
if	O
(	O
!	O
desired_frequency	function
(	O
hits_buf_1	pointer
)	O
)	O
return	O
0	int
;	O
(	O
*	O
report_func	pointer
)	O
(	O
hits_buf_1	pointer
,	O
tree8_to_flinkv	function
(	O
token_hits_addr	function
(	O
hits_buf_1	pointer
)	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
int	O
query_literal_prefix	function
(	O
char	O
const	O
*	O
arg	pointer
,	O
report_func_t	pointer
report_func	pointer
)	O
{	O
int	O
count	int
;	O
unsigned	O
int	O
length	int
;	O
if	O
(	O
ignore_case_flag	int
)	O
return	O
query_regexp	function
(	O
arg	pointer
,	O
report_func	pointer
)	O
;	O
if	O
(	O
query_binary_search	function
(	O
++	O
arg	pointer
)	O
==	O
0	int
)	O
return	O
0	int
;	O
length	int
=	O
strlen	function
(	O
arg	pointer
)	O
;	O
count	int
=	O
0	int
;	O
if	O
(	O
key_style	enum
!=	O
ks_token	int
)	O
memset	function
(	O
bits_vec	pointer
,	O
0	int
,	O
bits_vec_size	int
)	O
;	O
while	O
(	O
gets_past_00	function
(	O
hits_buf_1	pointer
,	O
idh	struct
.	O
idh_FILE	pointer
)	O
>	O
0	int
)	O
{	O
assert	O
(	O
*	O
hits_buf_1	pointer
)	O
;	O
if	O
(	O
!	O
desired_frequency	function
(	O
hits_buf_1	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
!	O
strnequ	O
(	O
arg	pointer
,	O
hits_buf_1	pointer
,	O
length	int
)	O
)	O
break	O
;	O
if	O
(	O
key_style	enum
==	O
ks_token	int
)	O
(	O
*	O
report_func	pointer
)	O
(	O
hits_buf_1	pointer
,	O
tree8_to_flinkv	function
(	O
token_hits_addr	function
(	O
hits_buf_1	pointer
)	O
)	O
)	O
;	O
else	O
tree8_to_bits	function
(	O
bits_vec	pointer
,	O
token_hits_addr	function
(	O
hits_buf_1	pointer
)	O
)	O
;	O
count	int
++	O
;	O
}	O
if	O
(	O
key_style	enum
!=	O
ks_token	int
&&	O
count	int
)	O
(	O
*	O
report_func	pointer
)	O
(	O
--	O
arg	pointer
,	O
bits_to_flinkv	function
(	O
bits_vec	pointer
)	O
)	O
;	O
return	O
count	int
;	O
}	O
int	O
query_regexp	function
(	O
char	O
const	O
*	O
pattern_0	pointer
,	O
report_func_t	pointer
report_func	pointer
)	O
{	O
int	O
count	int
;	O
regex_t	struct
compiled	struct
;	O
int	O
regcomp_errno	int
;	O
char	O
const	O
*	O
pattern	pointer
=	O
pattern_0	pointer
;	O
if	O
(	O
delimiter_style	enum
==	O
ds_word	int
)	O
pattern	pointer
=	O
add_regexp_word_delimiters	function
(	O
pattern	pointer
)	O
;	O
regcomp_errno	int
=	O
regcomp	O
(	O
&	O
compiled	struct
,	O
pattern	pointer
,	O
ignore_case_flag	int
|	O
REG_EXTENDED	int
)	O
;	O
if	O
(	O
regcomp_errno	int
)	O
{	O
char	O
buf	pointer
[	O
BUFSIZ	int
]	O
;	O
regerror	O
(	O
regcomp_errno	int
,	O
&	O
compiled	struct
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
;	O
error	function
(	O
1	int
,	O
0	int
,	O
"%s"	pointer
,	O
buf	pointer
)	O
;	O
}	O
fseek	function
(	O
idh	struct
.	O
idh_FILE	pointer
,	O
idh	struct
.	O
idh_tokens_offset	long
,	O
SEEK_SET	int
)	O
;	O
count	int
=	O
0	int
;	O
if	O
(	O
key_style	enum
!=	O
ks_token	int
)	O
memset	function
(	O
bits_vec	pointer
,	O
0	int
,	O
bits_vec_size	int
)	O
;	O
while	O
(	O
gets_past_00	function
(	O
hits_buf_1	pointer
,	O
idh	struct
.	O
idh_FILE	pointer
)	O
>	O
0	int
)	O
{	O
int	O
regexec_errno	int
;	O
assert	O
(	O
*	O
hits_buf_1	pointer
)	O
;	O
if	O
(	O
!	O
desired_frequency	function
(	O
hits_buf_1	pointer
)	O
)	O
continue	O
;	O
regexec_errno	int
=	O
regexec	O
(	O
&	O
compiled	struct
,	O
hits_buf_1	pointer
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
regexec_errno	int
==	O
REG_ESPACE	O
)	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"can't match regular-expression: memory exhausted"	pointer
)	O
)	O
;	O
else	O
if	O
(	O
regexec_errno	int
)	O
continue	O
;	O
if	O
(	O
key_style	enum
==	O
ks_token	int
)	O
(	O
*	O
report_func	pointer
)	O
(	O
hits_buf_1	pointer
,	O
tree8_to_flinkv	function
(	O
token_hits_addr	function
(	O
hits_buf_1	pointer
)	O
)	O
)	O
;	O
else	O
tree8_to_bits	function
(	O
bits_vec	pointer
,	O
token_hits_addr	function
(	O
hits_buf_1	pointer
)	O
)	O
;	O
count	int
++	O
;	O
}	O
if	O
(	O
key_style	enum
!=	O
ks_token	int
&&	O
count	int
)	O
(	O
*	O
report_func	pointer
)	O
(	O
pattern	pointer
,	O
bits_to_flinkv	function
(	O
bits_vec	pointer
)	O
)	O
;	O
if	O
(	O
pattern	pointer
!=	O
pattern_0	pointer
)	O
free	function
(	O
(	O
char	O
*	O
)	O
pattern	pointer
)	O
;	O
return	O
count	int
;	O
}	O
char	O
const	O
*	O
add_regexp_word_delimiters	function
(	O
char	O
const	O
*	O
pattern_0	pointer
)	O
{	O
int	O
length	int
=	O
strlen	function
(	O
pattern_0	pointer
)	O
;	O
int	O
has_left	int
=	O
has_left_delimiter	function
(	O
pattern_0	pointer
)	O
;	O
int	O
has_right	int
=	O
has_right_delimiter	function
(	O
&	O
pattern_0	pointer
[	O
length	int
]	O
)	O
;	O
if	O
(	O
has_left	int
&&	O
has_right	int
)	O
return	O
pattern_0	pointer
;	O
else	O
{	O
char	O
*	O
pattern	pointer
=	O
xmalloc	function
(	O
length	int
+	O
4	int
)	O
;	O
if	O
(	O
has_left	int
)	O
strcpy	function
(	O
pattern	pointer
,	O
pattern_0	pointer
)	O
;	O
else	O
{	O
length	int
+=	O
2	int
;	O
strcpy	function
(	O
pattern	pointer
,	O
"\\<"	pointer
)	O
;	O
strcpy	function
(	O
pattern	pointer
+	O
2	int
,	O
pattern_0	pointer
)	O
;	O
}	O
if	O
(	O
!	O
has_right	int
)	O
strcpy	function
(	O
pattern	pointer
+	O
length	int
,	O
"\\>"	pointer
)	O
;	O
return	O
pattern	pointer
;	O
}	O
}	O
int	O
query_number	function
(	O
char	O
const	O
*	O
arg	pointer
,	O
report_func_t	pointer
report_func	pointer
)	O
{	O
int	O
count	int
;	O
int	O
radix	enum
;	O
int	O
val	int
;	O
int	O
hit_digits	int
=	O
0	int
;	O
radix	enum
=	O
(	O
val	int
=	O
stoi	function
(	O
arg	pointer
)	O
)	O
?	O
radix_all	int
:	O
get_radix	function
(	O
arg	pointer
)	O
;	O
fseek	function
(	O
idh	struct
.	O
idh_FILE	pointer
,	O
idh	struct
.	O
idh_tokens_offset	long
,	O
SEEK_SET	int
)	O
;	O
count	int
=	O
0	int
;	O
if	O
(	O
key_style	enum
!=	O
ks_token	int
)	O
memset	function
(	O
bits_vec	pointer
,	O
0	int
,	O
bits_vec_size	int
)	O
;	O
while	O
(	O
gets_past_00	function
(	O
hits_buf_1	pointer
,	O
idh	struct
.	O
idh_FILE	pointer
)	O
>	O
0	int
)	O
{	O
if	O
(	O
hit_digits	int
)	O
{	O
if	O
(	O
!	O
isdigit	function
(	O
*	O
hits_buf_1	pointer
)	O
)	O
break	O
;	O
}	O
else	O
{	O
if	O
(	O
isdigit	function
(	O
*	O
hits_buf_1	pointer
)	O
)	O
hit_digits	int
=	O
1	int
;	O
}	O
if	O
(	O
!	O
(	O
(	O
radix_flag	int
?	O
radix_flag	int
:	O
radix	enum
)	O
&	O
get_radix	function
(	O
hits_buf_1	pointer
)	O
)	O
||	O
stoi	function
(	O
hits_buf_1	pointer
)	O
!=	O
val	int
)	O
continue	O
;	O
if	O
(	O
key_style	enum
==	O
ks_token	int
)	O
(	O
*	O
report_func	pointer
)	O
(	O
hits_buf_1	pointer
,	O
tree8_to_flinkv	function
(	O
token_hits_addr	function
(	O
hits_buf_1	pointer
)	O
)	O
)	O
;	O
else	O
tree8_to_bits	function
(	O
bits_vec	pointer
,	O
token_hits_addr	function
(	O
hits_buf_1	pointer
)	O
)	O
;	O
count	int
++	O
;	O
}	O
if	O
(	O
key_style	enum
!=	O
ks_token	int
&&	O
count	int
)	O
(	O
*	O
report_func	pointer
)	O
(	O
arg	pointer
,	O
bits_to_flinkv	function
(	O
bits_vec	pointer
)	O
)	O
;	O
return	O
count	int
;	O
}	O
int	O
query_ambiguous_prefix	function
(	O
unsigned	O
int	O
limit	pointer
,	O
report_func_t	pointer
report_func	pointer
)	O
{	O
char	O
*	O
old	pointer
=	O
hits_buf_1	pointer
;	O
char	O
*	O
new	pointer
=	O
hits_buf_2	pointer
;	O
int	O
consecutive	int
=	O
0	int
;	O
int	O
count	int
=	O
0	int
;	O
char	O
name	pointer
[	O
1024	int
]	O
;	O
if	O
(	O
limit	pointer
<=	O
1	int
)	O
usage	function
(	O
)	O
;	O
assert	O
(	O
limit	pointer
<	O
sizeof	O
(	O
name	pointer
)	O
)	O
;	O
name	pointer
[	O
0	int
]	O
=	O
'^'	O
;	O
*	O
new	pointer
=	O
'\0'	O
;	O
fseek	function
(	O
idh	struct
.	O
idh_FILE	pointer
,	O
idh	struct
.	O
idh_tokens_offset	long
,	O
SEEK_SET	int
)	O
;	O
while	O
(	O
gets_past_00	function
(	O
old	pointer
,	O
idh	struct
.	O
idh_FILE	pointer
)	O
>	O
0	int
)	O
{	O
char	O
*	O
tmp	pointer
;	O
if	O
(	O
!	O
(	O
token_flags	function
(	O
old	pointer
)	O
&	O
TOK_NAME	int
)	O
)	O
continue	O
;	O
tmp	pointer
=	O
old	pointer
;	O
old	pointer
=	O
new	pointer
;	O
new	pointer
=	O
tmp	pointer
;	O
if	O
(	O
!	O
strnequ	O
(	O
new	pointer
,	O
old	pointer
,	O
limit	pointer
)	O
)	O
{	O
if	O
(	O
consecutive	int
&&	O
key_style	enum
!=	O
ks_token	int
)	O
{	O
strncpy	function
(	O
&	O
name	pointer
[	O
1	int
]	O
,	O
old	pointer
,	O
limit	pointer
)	O
;	O
(	O
*	O
report_func	pointer
)	O
(	O
name	pointer
,	O
bits_to_flinkv	function
(	O
bits_vec	pointer
)	O
)	O
;	O
}	O
consecutive	int
=	O
0	int
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
consecutive	int
++	O
)	O
{	O
if	O
(	O
key_style	enum
!=	O
ks_token	int
)	O
tree8_to_bits	function
(	O
bits_vec	pointer
,	O
token_hits_addr	function
(	O
old	pointer
)	O
)	O
;	O
else	O
(	O
*	O
report_func	pointer
)	O
(	O
old	pointer
,	O
tree8_to_flinkv	function
(	O
token_hits_addr	function
(	O
old	pointer
)	O
)	O
)	O
;	O
count	int
++	O
;	O
}	O
if	O
(	O
key_style	enum
==	O
ks_token	int
)	O
(	O
*	O
report_func	pointer
)	O
(	O
new	pointer
,	O
tree8_to_flinkv	function
(	O
token_hits_addr	function
(	O
new	pointer
)	O
)	O
)	O
;	O
else	O
tree8_to_bits	function
(	O
bits_vec	pointer
,	O
token_hits_addr	function
(	O
new	pointer
)	O
)	O
;	O
count	int
++	O
;	O
}	O
if	O
(	O
consecutive	int
&&	O
key_style	enum
!=	O
ks_token	int
)	O
{	O
strncpy	function
(	O
&	O
name	pointer
[	O
1	int
]	O
,	O
new	pointer
,	O
limit	pointer
)	O
;	O
(	O
*	O
report_func	pointer
)	O
(	O
name	pointer
,	O
bits_to_flinkv	function
(	O
bits_vec	pointer
)	O
)	O
;	O
}	O
return	O
count	int
;	O
}	O
int	O
query_literal_substring	function
(	O
char	O
const	O
*	O
arg	pointer
,	O
report_func_t	pointer
report_func	pointer
)	O
{	O
int	O
count	int
;	O
int	O
arg_length	int
=	O
0	int
;	O
char	O
*	O
(	O
*	O
strstr_func	pointer
)	O
(	O
char	O
const	O
*	O
,	O
char	O
const	O
*	O
)	O
;	O
fseek	function
(	O
idh	struct
.	O
idh_FILE	pointer
,	O
idh	struct
.	O
idh_tokens_offset	long
,	O
SEEK_SET	int
)	O
;	O
if	O
(	O
delimiter_style	enum
==	O
ds_word	int
)	O
arg_length	int
=	O
strlen	function
(	O
arg	pointer
)	O
;	O
count	int
=	O
0	int
;	O
if	O
(	O
key_style	enum
!=	O
ks_token	int
)	O
memset	function
(	O
bits_vec	pointer
,	O
0	int
,	O
bits_vec_size	int
)	O
;	O
strstr_func	pointer
=	O
(	O
ignore_case_flag	int
?	O
strcasestr	function
:	O
strstr	function
)	O
;	O
while	O
(	O
gets_past_00	function
(	O
hits_buf_1	pointer
,	O
idh	struct
.	O
idh_FILE	pointer
)	O
>	O
0	int
)	O
{	O
char	O
*	O
match	pointer
;	O
assert	O
(	O
*	O
hits_buf_1	pointer
)	O
;	O
if	O
(	O
!	O
desired_frequency	function
(	O
hits_buf_1	pointer
)	O
)	O
continue	O
;	O
match	pointer
=	O
(	O
*	O
strstr_func	pointer
)	O
(	O
hits_buf_1	pointer
,	O
arg	pointer
)	O
;	O
if	O
(	O
match	pointer
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
delimiter_style	enum
==	O
ds_word	int
&&	O
(	O
match	pointer
>	O
hits_buf_1	pointer
||	O
strlen	function
(	O
hits_buf_1	pointer
)	O
>	O
arg_length	int
)	O
)	O
continue	O
;	O
if	O
(	O
key_style	enum
==	O
ks_token	int
)	O
(	O
*	O
report_func	pointer
)	O
(	O
hits_buf_1	pointer
,	O
tree8_to_flinkv	function
(	O
token_hits_addr	function
(	O
hits_buf_1	pointer
)	O
)	O
)	O
;	O
else	O
tree8_to_bits	function
(	O
bits_vec	pointer
,	O
token_hits_addr	function
(	O
hits_buf_1	pointer
)	O
)	O
;	O
count	int
++	O
;	O
}	O
if	O
(	O
key_style	enum
!=	O
ks_token	int
&&	O
count	int
)	O
(	O
*	O
report_func	pointer
)	O
(	O
arg	pointer
,	O
bits_to_flinkv	function
(	O
bits_vec	pointer
)	O
)	O
;	O
return	O
count	int
;	O
}	O
void	O
parse_frequency_arg	function
(	O
char	O
const	O
*	O
arg	pointer
)	O
{	O
if	O
(	O
strnequ	O
(	O
arg	pointer
,	O
".."	pointer
,	O
2	int
)	O
)	O
frequency_low	int
=	O
1	int
;	O
else	O
{	O
frequency_low	int
=	O
atoi	function
(	O
arg	pointer
)	O
;	O
while	O
(	O
isdigit	function
(	O
*	O
arg	pointer
)	O
)	O
arg	pointer
++	O
;	O
if	O
(	O
strnequ	O
(	O
arg	pointer
,	O
".."	pointer
,	O
2	int
)	O
)	O
arg	pointer
+=	O
2	int
;	O
}	O
if	O
(	O
*	O
arg	pointer
)	O
frequency_high	int
=	O
atoi	function
(	O
arg	pointer
)	O
;	O
else	O
if	O
(	O
strnequ	O
(	O
&	O
arg	pointer
[	O
-	O
1	int
]	O
,	O
".."	pointer
,	O
2	int
)	O
)	O
frequency_high	int
=	O
USHRT_MAX	O
;	O
else	O
frequency_high	int
=	O
frequency_low	int
;	O
if	O
(	O
frequency_low	int
>	O
frequency_high	int
)	O
{	O
unsigned	O
int	O
tmp	pointer
=	O
frequency_low	int
;	O
frequency_low	int
=	O
frequency_high	int
;	O
frequency_high	int
=	O
tmp	pointer
;	O
}	O
}	O
int	O
desired_frequency	function
(	O
char	O
const	O
*	O
tok	pointer
)	O
{	O
unsigned	O
int	O
count	int
=	O
token_count	function
(	O
tok	pointer
)	O
;	O
return	O
(	O
frequency_low	int
<=	O
count	int
&&	O
count	int
<=	O
frequency_high	int
)	O
;	O
}	O
char	O
*	O
strcasestr	function
(	O
char	O
const	O
*	O
s1	pointer
,	O
char	O
const	O
*	O
s2	pointer
)	O
{	O
char	O
const	O
*	O
s1p	pointer
;	O
char	O
const	O
*	O
s2p	pointer
;	O
char	O
const	O
*	O
s1last	pointer
;	O
for	O
(	O
s1last	pointer
=	O
&	O
s1	pointer
[	O
strlen	function
(	O
s1	pointer
)	O
-	O
strlen	function
(	O
s2	pointer
)	O
]	O
;	O
s1	pointer
<=	O
s1last	pointer
;	O
s1	pointer
++	O
)	O
for	O
(	O
s1p	pointer
=	O
s1	pointer
,	O
s2p	pointer
=	O
s2	pointer
;	O
TOLOWER	O
(	O
*	O
s1p	pointer
)	O
==	O
TOLOWER	O
(	O
*	O
s2p	pointer
)	O
;	O
s1p	pointer
++	O
)	O
if	O
(	O
*	O
++	O
s2p	pointer
==	O
'\0'	O
)	O
return	O
(	O
char	O
*	O
)	O
s1	pointer
;	O
return	O
0	int
;	O
}	O
char	O
const	O
*	O
file_regexp	function
(	O
char	O
const	O
*	O
name_0	pointer
,	O
char	O
const	O
*	O
left_delimit	pointer
,	O
char	O
const	O
*	O
right_delimit	pointer
)	O
{	O
static	O
char	O
pat_buf	array
[	O
BUFSIZ	int
]	O
;	O
char	O
*	O
name	pointer
=	O
(	O
char	O
*	O
)	O
name_0	pointer
;	O
if	O
(	O
query_function	pointer
==	O
query_number	function
&&	O
key_style	enum
==	O
ks_pattern	int
)	O
{	O
sprintf	function
(	O
pat_buf	array
,	O
"%s0*[Xx]*0*%d[Ll]*%s"	pointer
,	O
left_delimit	pointer
,	O
stoi	function
(	O
name	pointer
)	O
,	O
right_delimit	pointer
)	O
;	O
return	O
pat_buf	array
;	O
}	O
if	O
(	O
!	O
is_regexp	function
(	O
name	pointer
)	O
&&	O
name	pointer
[	O
0	int
]	O
!=	O
'^'	O
)	O
return	O
0	int
;	O
if	O
(	O
name	pointer
[	O
0	int
]	O
==	O
'^'	O
)	O
name_0	pointer
++	O
;	O
else	O
left_delimit	pointer
=	O
""	pointer
;	O
while	O
(	O
*	O
++	O
name	pointer
)	O
;	O
if	O
(	O
*	O
--	O
name	pointer
==	O
'$'	O
)	O
*	O
name	pointer
=	O
'\0'	O
;	O
else	O
right_delimit	pointer
=	O
""	pointer
;	O
sprintf	function
(	O
pat_buf	array
,	O
"%s%s%s"	pointer
,	O
left_delimit	pointer
,	O
name_0	pointer
,	O
right_delimit	pointer
)	O
;	O
return	O
pat_buf	array
;	O
}	O
off_t	long
query_binary_search	function
(	O
char	O
const	O
*	O
token_0	pointer
)	O
{	O
off_t	long
offset	long
=	O
0	int
;	O
off_t	long
start	pointer
=	O
idh	struct
.	O
idh_tokens_offset	long
-	O
2	int
;	O
off_t	long
end	pointer
=	O
idh	struct
.	O
idh_end_offset	long
;	O
off_t	long
anchor_offset	long
=	O
0	int
;	O
int	O
order	int
=	O
-	O
1	int
;	O
while	O
(	O
start	pointer
<	O
end	pointer
)	O
{	O
int	O
c	int
;	O
int	O
incr	int
=	O
1	int
;	O
char	O
const	O
*	O
token	pointer
;	O
offset	long
=	O
start	pointer
+	O
(	O
end	pointer
-	O
start	pointer
)	O
/	O
2	int
;	O
fseek	function
(	O
idh	struct
.	O
idh_FILE	pointer
,	O
offset	long
,	O
SEEK_SET	int
)	O
;	O
offset	long
+=	O
skip_past_00	function
(	O
idh	struct
.	O
idh_FILE	pointer
)	O
;	O
if	O
(	O
offset	long
>=	O
end	pointer
)	O
{	O
offset	long
=	O
start	pointer
+	O
2	int
;	O
fseek	function
(	O
idh	struct
.	O
idh_FILE	pointer
,	O
offset	long
,	O
SEEK_SET	int
)	O
;	O
}	O
token	pointer
=	O
token_0	pointer
;	O
while	O
(	O
*	O
token	pointer
==	O
(	O
c	int
=	O
getc	function
(	O
idh	struct
.	O
idh_FILE	pointer
)	O
)	O
&&	O
*	O
token	pointer
&&	O
c	int
)	O
{	O
token	pointer
++	O
;	O
incr	int
++	O
;	O
}	O
if	O
(	O
c	int
&&	O
!	O
*	O
token	pointer
&&	O
query_function	pointer
==	O
query_literal_prefix	function
)	O
anchor_offset	long
=	O
offset	long
;	O
order	int
=	O
*	O
token	pointer
-	O
c	int
;	O
if	O
(	O
order	int
<	O
0	int
)	O
end	pointer
=	O
offset	long
-	O
2	int
;	O
else	O
if	O
(	O
order	int
>	O
0	int
)	O
start	pointer
=	O
offset	long
+	O
incr	int
+	O
skip_past_00	function
(	O
idh	struct
.	O
idh_FILE	pointer
)	O
-	O
2	int
;	O
else	O
break	O
;	O
}	O
if	O
(	O
order	int
)	O
{	O
if	O
(	O
anchor_offset	long
)	O
offset	long
=	O
anchor_offset	long
;	O
else	O
return	O
0	int
;	O
}	O
fseek	function
(	O
idh	struct
.	O
idh_FILE	pointer
,	O
offset	long
,	O
SEEK_SET	int
)	O
;	O
return	O
offset	long
;	O
}	O
int	O
is_regexp	function
(	O
char	O
*	O
name	pointer
)	O
{	O
int	O
backslash	int
=	O
0	int
;	O
if	O
(	O
*	O
name	pointer
==	O
'^'	O
)	O
name	pointer
++	O
;	O
else	O
if	O
(	O
strnequ	O
(	O
name	pointer
,	O
"\\<"	pointer
,	O
2	int
)	O
)	O
name	pointer
+=	O
2	int
;	O
while	O
(	O
*	O
name	pointer
)	O
{	O
if	O
(	O
*	O
name	pointer
==	O
'\\'	O
)	O
{	O
if	O
(	O
strchr	function
(	O
"<>"	pointer
,	O
name	pointer
[	O
1	int
]	O
)	O
)	O
return	O
1	int
;	O
name	pointer
++	O
,	O
backslash	int
++	O
;	O
}	O
else	O
if	O
(	O
strchr	function
(	O
"[]().*+^$"	pointer
,	O
*	O
name	pointer
)	O
)	O
return	O
1	int
;	O
name	pointer
++	O
;	O
}	O
if	O
(	O
backslash	int
)	O
while	O
(	O
*	O
name	pointer
)	O
{	O
if	O
(	O
*	O
name	pointer
==	O
'\\'	O
)	O
strcpy	function
(	O
name	pointer
,	O
name	pointer
+	O
1	int
)	O
;	O
name	pointer
++	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
has_left_delimiter	function
(	O
char	O
const	O
*	O
pattern	pointer
)	O
{	O
return	O
(	O
*	O
pattern	pointer
==	O
'^'	O
||	O
strnequ	O
(	O
pattern	pointer
,	O
"\\<"	pointer
,	O
2	int
)	O
)	O
;	O
}	O
int	O
has_right_delimiter	function
(	O
char	O
const	O
*	O
pattern	pointer
)	O
{	O
return	O
(	O
pattern	pointer
[	O
-	O
1	int
]	O
==	O
'$'	O
||	O
strequ	O
(	O
pattern	pointer
-	O
2	int
,	O
"\\>"	pointer
)	O
)	O
;	O
}	O
int	O
file_name_wildcard	function
(	O
char	O
const	O
*	O
pattern	pointer
,	O
char	O
const	O
*	O
fn	pointer
)	O
{	O
int	O
c	int
;	O
int	O
i	int
;	O
char	O
set	array
[	O
256	int
]	O
;	O
int	O
revset	int
;	O
while	O
(	O
(	O
c	int
=	O
*	O
pattern	pointer
++	O
)	O
!=	O
'\0'	O
)	O
{	O
if	O
(	O
c	int
==	O
'*'	O
)	O
{	O
if	O
(	O
*	O
pattern	pointer
==	O
'\0'	O
)	O
return	O
1	int
;	O
while	O
(	O
*	O
fn	pointer
!=	O
'\0'	O
)	O
{	O
if	O
(	O
file_name_wildcard	function
(	O
pattern	pointer
,	O
fn	pointer
)	O
)	O
return	O
1	int
;	O
++	O
fn	pointer
;	O
}	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'?'	O
)	O
{	O
if	O
(	O
*	O
fn	pointer
++	O
==	O
'\0'	O
)	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'['	O
)	O
{	O
c	int
=	O
*	O
pattern	pointer
++	O
;	O
memset	function
(	O
set	array
,	O
0	int
,	O
256	int
)	O
;	O
if	O
(	O
c	int
==	O
'!'	O
)	O
{	O
revset	int
=	O
1	int
;	O
c	int
=	O
*	O
pattern	pointer
++	O
;	O
}	O
else	O
revset	int
=	O
0	int
;	O
while	O
(	O
c	int
!=	O
']'	O
)	O
{	O
if	O
(	O
c	int
==	O
'\\'	O
)	O
c	int
=	O
*	O
pattern	pointer
++	O
;	O
set	array
[	O
c	int
]	O
=	O
1	int
;	O
if	O
(	O
(	O
*	O
pattern	pointer
==	O
'-'	O
)	O
&&	O
(	O
*	O
(	O
pattern	pointer
+	O
1	int
)	O
!=	O
']'	O
)	O
)	O
{	O
pattern	pointer
+=	O
1	int
;	O
while	O
(	O
++	O
c	int
<=	O
*	O
pattern	pointer
)	O
set	array
[	O
c	int
]	O
=	O
1	int
;	O
++	O
pattern	pointer
;	O
}	O
c	int
=	O
*	O
pattern	pointer
++	O
;	O
}	O
if	O
(	O
revset	int
)	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
256	int
;	O
++	O
i	int
)	O
set	array
[	O
i	int
]	O
=	O
!	O
set	array
[	O
i	int
]	O
;	O
if	O
(	O
!	O
set	array
[	O
(	O
int	O
)	O
*	O
fn	pointer
++	O
]	O
)	O
return	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
c	int
==	O
'\\'	O
)	O
c	int
=	O
*	O
pattern	pointer
++	O
;	O
if	O
(	O
c	int
!=	O
*	O
fn	pointer
++	O
)	O
return	O
0	int
;	O
}	O
}	O
return	O
(	O
*	O
fn	pointer
==	O
'\0'	O
)	O
;	O
}	O
int	O
word_match	function
(	O
char	O
const	O
*	O
name_0	pointer
,	O
char	O
const	O
*	O
line	pointer
)	O
{	O
char	O
const	O
*	O
name	pointer
=	O
name_0	pointer
;	O
for	O
(	O
;	O
;	O
)	O
{	O
while	O
(	O
*	O
line	pointer
!=	O
*	O
name	pointer
)	O
{	O
if	O
(	O
*	O
line	pointer
==	O
'\0'	O
||	O
*	O
line	pointer
==	O
'\n'	O
)	O
return	O
0	int
;	O
line	pointer
++	O
;	O
}	O
if	O
(	O
IS_ALNUM	O
(	O
line	pointer
[	O
-	O
1	int
]	O
)	O
)	O
{	O
line	pointer
++	O
;	O
continue	O
;	O
}	O
while	O
(	O
*	O
++	O
name	pointer
==	O
*	O
++	O
line	pointer
)	O
;	O
if	O
(	O
*	O
name	pointer
==	O
'\0'	O
&&	O
!	O
IS_ALNUM	O
(	O
*	O
line	pointer
)	O
)	O
return	O
1	int
;	O
name	pointer
=	O
name_0	pointer
;	O
}	O
}	O
int	O
get_radix	function
(	O
char	O
const	O
*	O
str	pointer
)	O
{	O
if	O
(	O
!	O
isdigit	function
(	O
*	O
str	pointer
)	O
)	O
return	O
0	int
;	O
if	O
(	O
*	O
str	pointer
!=	O
'0'	O
)	O
return	O
radix_dec	int
;	O
str	pointer
++	O
;	O
if	O
(	O
*	O
str	pointer
==	O
'x'	O
||	O
*	O
str	pointer
==	O
'X'	O
)	O
return	O
radix_hex	int
;	O
while	O
(	O
*	O
str	pointer
&&	O
*	O
str	pointer
==	O
'0'	O
)	O
str	pointer
++	O
;	O
return	O
(	O
*	O
str	pointer
?	O
radix_oct	int
:	O
(	O
radix_oct	int
|	O
radix_dec	int
)	O
)	O
;	O
}	O
int	O
is_number	function
(	O
char	O
const	O
*	O
str	pointer
)	O
{	O
if	O
(	O
str	pointer
[	O
0	int
]	O
==	O
'0'	O
&&	O
(	O
str	pointer
[	O
1	int
]	O
==	O
'x'	O
||	O
str	pointer
[	O
1	int
]	O
==	O
'X'	O
)	O
)	O
{	O
str	pointer
+=	O
2	int
;	O
str	pointer
+=	O
strspn	function
(	O
str	pointer
,	O
"0123456789aAbBcCdDeEfF"	pointer
)	O
;	O
}	O
else	O
{	O
size_t	long
offn	long
;	O
str	pointer
+=	O
(	O
offn	long
=	O
strspn	function
(	O
str	pointer
,	O
"0123456789"	pointer
)	O
)	O
;	O
if	O
(	O
offn	long
)	O
str	pointer
+=	O
strspn	function
(	O
str	pointer
,	O
"uUlL"	pointer
)	O
;	O
}	O
return	O
(	O
*	O
str	pointer
==	O
'\0'	O
)	O
;	O
}	O
int	O
stoi	function
(	O
char	O
const	O
*	O
str	pointer
)	O
{	O
switch	O
(	O
get_radix	function
(	O
str	pointer
)	O
)	O
{	O
case	O
radix_dec	int
:	O
return	O
(	O
dtoi	function
(	O
str	pointer
)	O
)	O
;	O
case	O
radix_oct	int
:	O
return	O
(	O
otoi	function
(	O
&	O
str	pointer
[	O
1	int
]	O
)	O
)	O
;	O
case	O
radix_hex	int
:	O
return	O
(	O
xtoi	function
(	O
&	O
str	pointer
[	O
2	int
]	O
)	O
)	O
;	O
case	O
radix_dec	int
|	O
radix_oct	int
:	O
return	O
0	int
;	O
default	O
:	O
return	O
-	O
1	int
;	O
}	O
}	O
int	O
otoi	function
(	O
char	O
const	O
*	O
str	pointer
)	O
{	O
int	O
n	long
=	O
0	int
;	O
while	O
(	O
*	O
str	pointer
>=	O
'0'	O
&&	O
*	O
str	pointer
<=	O
'7'	O
)	O
{	O
n	long
*=	O
010	int
;	O
n	long
+=	O
*	O
str	pointer
++	O
-	O
'0'	O
;	O
}	O
while	O
(	O
*	O
str	pointer
&&	O
strchr	function
(	O
"uUlL"	pointer
,	O
*	O
str	pointer
)	O
)	O
str	pointer
++	O
;	O
return	O
(	O
*	O
str	pointer
?	O
-	O
1	int
:	O
n	long
)	O
;	O
}	O
int	O
dtoi	function
(	O
char	O
const	O
*	O
str	pointer
)	O
{	O
int	O
n	long
=	O
0	int
;	O
while	O
(	O
isdigit	function
(	O
*	O
str	pointer
)	O
)	O
{	O
n	long
*=	O
10	int
;	O
n	long
+=	O
*	O
str	pointer
++	O
-	O
'0'	O
;	O
}	O
while	O
(	O
*	O
str	pointer
&&	O
strchr	function
(	O
"uUlL"	pointer
,	O
*	O
str	pointer
)	O
)	O
str	pointer
++	O
;	O
return	O
(	O
*	O
str	pointer
?	O
-	O
1	int
:	O
n	long
)	O
;	O
}	O
int	O
xtoi	function
(	O
char	O
const	O
*	O
str	pointer
)	O
{	O
int	O
n	long
=	O
0	int
;	O
while	O
(	O
isxdigit	function
(	O
*	O
str	pointer
)	O
)	O
{	O
n	long
*=	O
0x10	int
;	O
if	O
(	O
isdigit	function
(	O
*	O
str	pointer
)	O
)	O
n	long
+=	O
*	O
str	pointer
++	O
-	O
'0'	O
;	O
else	O
if	O
(	O
islower	function
(	O
*	O
str	pointer
)	O
)	O
n	long
+=	O
0xa	int
+	O
*	O
str	pointer
++	O
-	O
'a'	O
;	O
else	O
n	long
+=	O
0xA	int
+	O
*	O
str	pointer
++	O
-	O
'A'	O
;	O
}	O
while	O
(	O
*	O
str	pointer
&&	O
strchr	function
(	O
"uUlL"	pointer
,	O
*	O
str	pointer
)	O
)	O
str	pointer
++	O
;	O
return	O
(	O
*	O
str	pointer
?	O
-	O
1	int
:	O
n	long
)	O
;	O
}	O
unsigned	O
char	O
*	O
tree8_to_bits	function
(	O
unsigned	O
char	O
*	O
bv_0	pointer
,	O
unsigned	O
char	O
const	O
*	O
hits_tree8	pointer
)	O
{	O
unsigned	O
char	O
*	O
bv	pointer
=	O
bv_0	pointer
;	O
tree8_to_bits_1	function
(	O
&	O
bv	pointer
,	O
&	O
hits_tree8	pointer
,	O
tree8_levels	int
)	O
;	O
return	O
bv_0	pointer
;	O
}	O
void	O
tree8_to_bits_1	function
(	O
unsigned	O
char	O
*	O
*	O
bv	pointer
,	O
unsigned	O
char	O
const	O
*	O
*	O
hits_tree8	pointer
,	O
int	O
level	int
)	O
{	O
int	O
hits	int
=	O
*	O
(	O
*	O
hits_tree8	pointer
)	O
++	O
;	O
if	O
(	O
--	O
level	int
)	O
{	O
int	O
incr	int
=	O
1	int
<<	O
(	O
(	O
level	int
-	O
1	int
)	O
*	O
3	int
)	O
;	O
int	O
bit	int
;	O
for	O
(	O
bit	int
=	O
1	int
;	O
bit	int
&	O
0xff	int
;	O
bit	int
<<=	O
1	int
)	O
{	O
if	O
(	O
bit	int
&	O
hits	int
)	O
tree8_to_bits_1	function
(	O
bv	pointer
,	O
hits_tree8	pointer
,	O
level	int
)	O
;	O
else	O
*	O
bv	pointer
+=	O
incr	int
;	O
}	O
}	O
else	O
*	O
(	O
*	O
bv	pointer
)	O
++	O
|=	O
hits	int
;	O
}	O
struct	O
file_link	struct
*	O
*	O
bits_to_flinkv	function
(	O
unsigned	O
char	O
const	O
*	O
bv	pointer
)	O
{	O
int	O
const	O
reserved_flinkv_slots	int
=	O
3	int
;	O
static	O
struct	O
file_link	struct
*	O
*	O
flinkv_0	pointer
;	O
struct	O
file_link	struct
*	O
*	O
flinkv	pointer
;	O
struct	O
file_link	struct
*	O
*	O
members	pointer
=	O
members_0	pointer
;	O
struct	O
file_link	struct
*	O
*	O
end	pointer
=	O
&	O
members_0	pointer
[	O
idh	struct
.	O
idh_files	long
]	O
;	O
if	O
(	O
flinkv_0	pointer
==	O
0	int
)	O
flinkv_0	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
file_link	struct
*	O
)	O
*	O
(	O
idh	struct
.	O
idh_files	long
+	O
reserved_flinkv_slots	int
+	O
2	int
)	O
)	O
;	O
flinkv	pointer
=	O
&	O
flinkv_0	pointer
[	O
reserved_flinkv_slots	int
]	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
hits	int
;	O
int	O
bit	int
;	O
while	O
(	O
*	O
bv	pointer
==	O
0	int
)	O
{	O
bv	pointer
++	O
;	O
members	pointer
+=	O
8	int
;	O
if	O
(	O
members	pointer
>=	O
end	pointer
)	O
goto	O
out	O
;	O
}	O
hits	int
=	O
*	O
bv	pointer
++	O
;	O
for	O
(	O
bit	int
=	O
1	int
;	O
bit	int
&	O
0xff	int
;	O
bit	int
<<=	O
1	int
)	O
{	O
if	O
(	O
bit	int
&	O
hits	int
)	O
*	O
flinkv	pointer
++	O
=	O
*	O
members	pointer
;	O
if	O
(	O
++	O
members	pointer
>=	O
end	pointer
)	O
goto	O
out	O
;	O
}	O
}	O
out	O
:	O
*	O
flinkv	pointer
=	O
0	int
;	O
return	O
&	O
flinkv_0	pointer
[	O
reserved_flinkv_slots	int
]	O
;	O
}	O
struct	O
file_link	struct
*	O
*	O
tree8_to_flinkv	function
(	O
unsigned	O
char	O
const	O
*	O
hits_tree8	pointer
)	O
{	O
memset	function
(	O
bits_vec	pointer
,	O
0	int
,	O
bits_vec_size	int
)	O
;	O
return	O
bits_to_flinkv	function
(	O
tree8_to_bits	function
(	O
bits_vec	pointer
,	O
hits_tree8	pointer
)	O
)	O
;	O
}	O
struct	O
termios	struct
linemode	struct
;	O
struct	O
termios	struct
charmode	struct
;	O
struct	O
termios	struct
savemode	struct
;	O
void	O
savetty	function
(	O
void	O
)	O
{	O
GET_TTY_MODES	O
(	O
&	O
savemode	struct
)	O
;	O
charmode	struct
=	O
linemode	struct
=	O
savemode	struct
;	O
charmode	struct
.	O
c_lflag	int
&=	O
~	O
(	O
ECHO	int
|	O
ICANON	int
|	O
ISIG	int
)	O
;	O
charmode	struct
.	O
c_cc	array
[	O
VMIN	int
]	O
=	O
1	int
;	O
charmode	struct
.	O
c_cc	array
[	O
VTIME	int
]	O
=	O
0	int
;	O
linemode	struct
.	O
c_lflag	int
|=	O
(	O
ECHO	int
|	O
ICANON	int
|	O
ISIG	int
)	O
;	O
linemode	struct
.	O
c_cc	array
[	O
VEOF	int
]	O
=	O
'd'	O
&	O
037	int
;	O
linemode	struct
.	O
c_cc	array
[	O
VEOL	int
]	O
=	O
0377	int
;	O
}	O
void	O
restoretty	function
(	O
void	O
)	O
{	O
SET_TTY_MODES	O
(	O
&	O
savemode	struct
)	O
;	O
}	O
void	O
linetty	function
(	O
void	O
)	O
{	O
SET_TTY_MODES	O
(	O
&	O
linemode	struct
)	O
;	O
}	O
void	O
chartty	function
(	O
void	O
)	O
{	O
SET_TTY_MODES	O
(	O
&	O
charmode	struct
)	O
;	O
}	O
