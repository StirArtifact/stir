extern	O
void	O
_rl_free_history_entry	function
PARAMS	O
(	O
(	O
HIST_ENTRY	struct
*	O
)	O
)	O
;	O
extern	O
void	O
_rl_parse_colors	function
PARAMS	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
char	O
*	O
readline_internal	function
PARAMS	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
readline_initialize_everything	function
PARAMS	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
bind_arrow_keys_internal	function
PARAMS	O
(	O
(	O
Keymap	pointer
)	O
)	O
;	O
static	O
void	O
bind_arrow_keys	function
PARAMS	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
bind_bracketed_paste_prefix	function
PARAMS	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
readline_default_bindings	function
PARAMS	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
reset_default_bindings	function
PARAMS	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
int	O
_rl_subseq_result	function
PARAMS	O
(	O
(	O
int	O
,	O
Keymap	pointer
,	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
int	O
_rl_subseq_getchar	function
PARAMS	O
(	O
(	O
int	O
)	O
)	O
;	O
const	O
char	O
*	O
rl_library_version	pointer
=	O
RL_LIBRARY_VERSION	int
;	O
int	O
rl_readline_version	int
=	O
RL_READLINE_VERSION	int
;	O
int	O
rl_gnu_readline_p	int
=	O
1	int
;	O
Keymap	pointer
_rl_keymap	pointer
=	O
emacs_standard_keymap	array
;	O
int	O
rl_editing_mode	int
=	O
emacs_mode	int
;	O
int	O
rl_insert_mode	int
=	O
RL_IM_DEFAULT	O
;	O
int	O
rl_dispatching	int
;	O
int	O
_rl_last_command_was_kill	int
=	O
0	int
;	O
int	O
rl_numeric_arg	int
=	O
1	int
;	O
int	O
rl_explicit_arg	int
=	O
0	int
;	O
int	O
rl_arg_sign	int
=	O
1	int
;	O
static	O
int	O
rl_initialized	int
;	O
unsigned	O
long	O
rl_readline_state	long
=	O
RL_STATE_NONE	int
;	O
int	O
rl_point	int
;	O
int	O
rl_mark	int
;	O
int	O
rl_end	int
;	O
int	O
rl_done	int
;	O
rl_command_func_t	function
*	O
rl_last_func	pointer
=	O
(	O
rl_command_func_t	function
*	O
)	O
NULL	O
;	O
procenv_t	O
_rl_top_level	array
;	O
FILE	struct
*	O
_rl_in_stream	pointer
,	O
*	O
_rl_out_stream	pointer
;	O
FILE	struct
*	O
rl_instream	pointer
=	O
(	O
FILE	struct
*	O
)	O
NULL	O
;	O
FILE	struct
*	O
rl_outstream	pointer
=	O
(	O
FILE	struct
*	O
)	O
NULL	O
;	O
int	O
_rl_echoing_p	int
=	O
0	int
;	O
char	O
*	O
rl_prompt	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
int	O
rl_visible_prompt_length	int
=	O
0	int
;	O
int	O
rl_already_prompted	int
=	O
0	int
;	O
int	O
rl_key_sequence_length	int
=	O
0	int
;	O
rl_hook_func_t	function
*	O
rl_startup_hook	pointer
=	O
(	O
rl_hook_func_t	function
*	O
)	O
NULL	O
;	O
rl_hook_func_t	function
*	O
rl_pre_input_hook	pointer
=	O
(	O
rl_hook_func_t	function
*	O
)	O
NULL	O
;	O
static	O
char	O
*	O
the_line	pointer
;	O
int	O
_rl_eof_char	int
=	O
CTRL	O
(	O
'D'	O
)	O
;	O
int	O
rl_pending_input	int
=	O
0	int
;	O
const	O
char	O
*	O
rl_terminal_name	pointer
=	O
(	O
const	O
char	O
*	O
)	O
NULL	O
;	O
int	O
_rl_horizontal_scroll_mode	int
=	O
0	int
;	O
int	O
_rl_mark_modified_lines	int
=	O
0	int
;	O
int	O
_rl_bell_preference	int
=	O
AUDIBLE_BELL	int
;	O
char	O
*	O
_rl_comment_begin	pointer
;	O
Keymap	pointer
rl_executing_keymap	pointer
;	O
Keymap	pointer
_rl_dispatching_keymap	pointer
;	O
int	O
rl_erase_empty_line	int
=	O
0	int
;	O
int	O
rl_num_chars_to_read	int
;	O
char	O
*	O
rl_line_buffer	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
int	O
rl_line_buffer_len	int
=	O
0	int
;	O
_rl_keyseq_cxt	struct
*	O
_rl_kscxt	pointer
=	O
0	int
;	O
int	O
rl_executing_key	int
;	O
char	O
*	O
rl_executing_keyseq	pointer
=	O
0	int
;	O
int	O
_rl_executing_keyseq_size	int
=	O
0	int
;	O
int	O
_rl_keyseq_timeout	int
=	O
500	int
;	O
unsigned	O
char	O
_rl_parsing_conditionalized_out	char
=	O
0	int
;	O
int	O
_rl_convert_meta_chars_to_ascii	int
=	O
1	int
;	O
int	O
_rl_output_meta_chars	int
=	O
0	int
;	O
int	O
_rl_bind_stty_chars	int
=	O
1	int
;	O
int	O
_rl_revert_all_at_newline	int
=	O
0	int
;	O
int	O
_rl_echo_control_chars	int
=	O
1	int
;	O
int	O
_rl_show_mode_in_prompt	int
=	O
0	int
;	O
int	O
_rl_enable_bracketed_paste	int
=	O
0	int
;	O
int	O
_rl_meta_flag	int
=	O
0	int
;	O
int	O
rl_set_prompt	function
(	O
prompt	pointer
)	O
const	O
char	O
*	O
prompt	pointer
;	O
{	O
FREE	O
(	O
rl_prompt	pointer
)	O
;	O
rl_prompt	pointer
=	O
prompt	pointer
?	O
savestring	O
(	O
prompt	pointer
)	O
:	O
(	O
char	O
*	O
)	O
NULL	O
;	O
rl_display_prompt	pointer
=	O
rl_prompt	pointer
?	O
rl_prompt	pointer
:	O
""	pointer
;	O
rl_visible_prompt_length	int
=	O
rl_expand_prompt	function
(	O
rl_prompt	pointer
)	O
;	O
return	O
0	int
;	O
}	O
char	O
*	O
readline	function
(	O
prompt	pointer
)	O
const	O
char	O
*	O
prompt	pointer
;	O
{	O
char	O
*	O
value	pointer
;	O
if	O
(	O
rl_pending_input	int
==	O
EOF	O
)	O
{	O
rl_clear_pending_input	function
(	O
)	O
;	O
return	O
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
rl_set_prompt	function
(	O
prompt	pointer
)	O
;	O
rl_initialize	function
(	O
)	O
;	O
if	O
(	O
rl_prep_term_function	pointer
)	O
(	O
*	O
rl_prep_term_function	pointer
)	O
(	O
_rl_meta_flag	int
)	O
;	O
rl_set_signals	function
(	O
)	O
;	O
value	pointer
=	O
readline_internal	function
(	O
)	O
;	O
if	O
(	O
rl_deprep_term_function	pointer
)	O
(	O
*	O
rl_deprep_term_function	pointer
)	O
(	O
)	O
;	O
rl_clear_signals	function
(	O
)	O
;	O
return	O
(	O
value	pointer
)	O
;	O
}	O
STATIC_CALLBACK	O
void	O
readline_internal_setup	function
(	O
)	O
{	O
char	O
*	O
nprompt	pointer
;	O
_rl_in_stream	pointer
=	O
rl_instream	pointer
;	O
_rl_out_stream	pointer
=	O
rl_outstream	pointer
;	O
if	O
(	O
_rl_enable_meta	int
&	O
RL_ISSTATE	O
(	O
RL_STATE_TERMPREPPED	int
)	O
)	O
_rl_enable_meta_key	function
(	O
)	O
;	O
if	O
(	O
rl_startup_hook	pointer
)	O
(	O
*	O
rl_startup_hook	pointer
)	O
(	O
)	O
;	O
if	O
(	O
rl_editing_mode	int
==	O
vi_mode	int
)	O
rl_vi_insertion_mode	function
(	O
1	int
,	O
'i'	O
)	O
;	O
if	O
(	O
_rl_echoing_p	int
==	O
0	int
&&	O
rl_redisplay_function	pointer
==	O
rl_redisplay	function
)	O
{	O
if	O
(	O
rl_prompt	pointer
&&	O
rl_already_prompted	int
==	O
0	int
)	O
{	O
nprompt	pointer
=	O
_rl_strip_prompt	function
(	O
rl_prompt	pointer
)	O
;	O
fprintf	function
(	O
_rl_out_stream	pointer
,	O
"%s"	pointer
,	O
nprompt	pointer
)	O
;	O
fflush	function
(	O
_rl_out_stream	pointer
)	O
;	O
xfree	function
(	O
nprompt	pointer
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
rl_prompt	pointer
&&	O
rl_already_prompted	int
)	O
rl_on_new_line_with_prompt	function
(	O
)	O
;	O
else	O
rl_on_new_line	function
(	O
)	O
;	O
(	O
*	O
rl_redisplay_function	pointer
)	O
(	O
)	O
;	O
}	O
if	O
(	O
rl_pre_input_hook	pointer
)	O
(	O
*	O
rl_pre_input_hook	pointer
)	O
(	O
)	O
;	O
RL_CHECK_SIGNALS	O
(	O
)	O
;	O
}	O
STATIC_CALLBACK	O
char	O
*	O
readline_internal_teardown	function
(	O
eof	int
)	O
int	O
eof	int
;	O
{	O
char	O
*	O
temp	pointer
;	O
HIST_ENTRY	struct
*	O
entry	pointer
;	O
RL_CHECK_SIGNALS	O
(	O
)	O
;	O
entry	pointer
=	O
current_history	function
(	O
)	O
;	O
if	O
(	O
entry	pointer
&&	O
rl_undo_list	pointer
)	O
{	O
temp	pointer
=	O
savestring	O
(	O
the_line	pointer
)	O
;	O
rl_revert_line	function
(	O
1	int
,	O
0	int
)	O
;	O
entry	pointer
=	O
replace_history_entry	function
(	O
where_history	function
(	O
)	O
,	O
the_line	pointer
,	O
(	O
histdata_t	pointer
)	O
NULL	O
)	O
;	O
_rl_free_history_entry	function
(	O
entry	pointer
)	O
;	O
strcpy	function
(	O
the_line	pointer
,	O
temp	pointer
)	O
;	O
xfree	function
(	O
temp	pointer
)	O
;	O
}	O
if	O
(	O
_rl_revert_all_at_newline	int
)	O
_rl_revert_all_lines	function
(	O
)	O
;	O
if	O
(	O
rl_undo_list	pointer
)	O
rl_free_undo_list	function
(	O
)	O
;	O
_rl_disable_meta_key	function
(	O
)	O
;	O
_rl_set_insert_mode	function
(	O
RL_IM_INSERT	int
,	O
0	int
)	O
;	O
return	O
(	O
eof	int
?	O
(	O
char	O
*	O
)	O
NULL	O
:	O
savestring	O
(	O
the_line	pointer
)	O
)	O
;	O
}	O
void	O
_rl_internal_char_cleanup	function
(	O
)	O
{	O
if	O
(	O
rl_editing_mode	int
==	O
vi_mode	int
&&	O
_rl_keymap	pointer
==	O
vi_movement_keymap	array
)	O
rl_vi_check	function
(	O
)	O
;	O
if	O
(	O
rl_num_chars_to_read	int
&&	O
rl_end	int
>=	O
rl_num_chars_to_read	int
)	O
{	O
(	O
*	O
rl_redisplay_function	pointer
)	O
(	O
)	O
;	O
_rl_want_redisplay	int
=	O
0	int
;	O
rl_newline	function
(	O
1	int
,	O
'\n'	O
)	O
;	O
}	O
if	O
(	O
rl_done	int
==	O
0	int
)	O
{	O
(	O
*	O
rl_redisplay_function	pointer
)	O
(	O
)	O
;	O
_rl_want_redisplay	int
=	O
0	int
;	O
}	O
if	O
(	O
rl_erase_empty_line	int
&&	O
rl_done	int
&&	O
rl_last_func	pointer
==	O
rl_newline	function
&&	O
rl_point	int
==	O
0	int
&&	O
rl_end	int
==	O
0	int
)	O
_rl_erase_entire_line	function
(	O
)	O
;	O
}	O
STATIC_CALLBACK	O
int	O
readline_internal_char	function
(	O
)	O
{	O
static	O
int	O
lastc	int
,	O
eof_found	int
;	O
int	O
c	int
,	O
code	int
,	O
lk	int
;	O
lastc	int
=	O
EOF	O
;	O
lk	int
=	O
_rl_last_command_was_kill	int
;	O
code	int
=	O
sigsetjmp	O
(	O
_rl_top_level	array
,	O
0	int
)	O
;	O
if	O
(	O
code	int
)	O
{	O
(	O
*	O
rl_redisplay_function	pointer
)	O
(	O
)	O
;	O
_rl_want_redisplay	int
=	O
0	int
;	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
)	O
return	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
rl_pending_input	int
==	O
0	int
)	O
{	O
_rl_reset_argument	function
(	O
)	O
;	O
rl_executing_keyseq	pointer
[	O
rl_key_sequence_length	int
=	O
0	int
]	O
=	O
'\0'	O
;	O
}	O
RL_SETSTATE	O
(	O
RL_STATE_READCMD	int
)	O
;	O
c	int
=	O
rl_read_key	function
(	O
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_READCMD	int
)	O
;	O
if	O
(	O
c	int
==	O
READERR	O
)	O
{	O
RL_SETSTATE	O
(	O
RL_STATE_DONE	int
)	O
;	O
return	O
(	O
rl_done	int
=	O
1	int
)	O
;	O
}	O
if	O
(	O
c	int
==	O
EOF	O
&&	O
rl_end	int
)	O
{	O
if	O
(	O
RL_SIG_RECEIVED	O
(	O
)	O
)	O
{	O
RL_CHECK_SIGNALS	O
(	O
)	O
;	O
if	O
(	O
rl_signal_event_hook	pointer
)	O
(	O
*	O
rl_signal_event_hook	pointer
)	O
(	O
)	O
;	O
}	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_TERMPREPPED	int
)	O
)	O
{	O
if	O
(	O
lastc	int
==	O
_rl_eof_char	int
||	O
lastc	int
==	O
EOF	O
)	O
rl_end	int
=	O
0	int
;	O
else	O
c	int
=	O
_rl_eof_char	int
;	O
}	O
else	O
c	int
=	O
NEWLINE	char
;	O
}	O
if	O
(	O
(	O
(	O
c	int
==	O
_rl_eof_char	int
&&	O
lastc	int
!=	O
c	int
)	O
||	O
c	int
==	O
EOF	O
)	O
&&	O
rl_end	int
==	O
0	int
)	O
{	O
RL_SETSTATE	O
(	O
RL_STATE_DONE	int
)	O
;	O
return	O
(	O
rl_done	int
=	O
1	int
)	O
;	O
}	O
lastc	int
=	O
c	int
;	O
_rl_dispatch	function
(	O
(	O
unsigned	O
char	O
)	O
c	int
,	O
_rl_keymap	pointer
)	O
;	O
RL_CHECK_SIGNALS	O
(	O
)	O
;	O
if	O
(	O
rl_pending_input	int
==	O
0	int
&&	O
lk	int
==	O
_rl_last_command_was_kill	int
)	O
_rl_last_command_was_kill	int
=	O
0	int
;	O
_rl_internal_char_cleanup	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
readline_internal_charloop	function
(	O
)	O
{	O
int	O
eof	int
=	O
1	int
;	O
while	O
(	O
rl_done	int
==	O
0	int
)	O
eof	int
=	O
readline_internal_char	function
(	O
)	O
;	O
return	O
(	O
eof	int
)	O
;	O
}	O
static	O
char	O
*	O
readline_internal	function
(	O
)	O
{	O
int	O
eof	int
;	O
readline_internal_setup	function
(	O
)	O
;	O
eof	int
=	O
readline_internal_charloop	function
(	O
)	O
;	O
return	O
(	O
readline_internal_teardown	function
(	O
eof	int
)	O
)	O
;	O
}	O
void	O
_rl_init_line_state	function
(	O
)	O
{	O
rl_point	int
=	O
rl_end	int
=	O
rl_mark	int
=	O
0	int
;	O
the_line	pointer
=	O
rl_line_buffer	pointer
;	O
the_line	pointer
[	O
0	int
]	O
=	O
0	int
;	O
}	O
void	O
_rl_set_the_line	function
(	O
)	O
{	O
the_line	pointer
=	O
rl_line_buffer	pointer
;	O
}	O
_rl_keyseq_cxt	struct
*	O
_rl_keyseq_cxt_alloc	function
(	O
)	O
{	O
_rl_keyseq_cxt	struct
*	O
cxt	pointer
;	O
cxt	pointer
=	O
(	O
_rl_keyseq_cxt	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
_rl_keyseq_cxt	struct
)	O
)	O
;	O
cxt	pointer
->	O
flags	int
=	O
cxt	pointer
->	O
subseq_arg	int
=	O
cxt	pointer
->	O
subseq_retval	int
=	O
0	int
;	O
cxt	pointer
->	O
okey	int
=	O
0	int
;	O
cxt	pointer
->	O
ocxt	pointer
=	O
_rl_kscxt	pointer
;	O
cxt	pointer
->	O
childval	int
=	O
42	int
;	O
return	O
cxt	pointer
;	O
}	O
void	O
_rl_keyseq_cxt_dispose	function
(	O
cxt	pointer
)	O
_rl_keyseq_cxt	struct
*	O
cxt	pointer
;	O
{	O
xfree	function
(	O
cxt	pointer
)	O
;	O
}	O
void	O
_rl_keyseq_chain_dispose	function
(	O
)	O
{	O
_rl_keyseq_cxt	struct
*	O
cxt	pointer
;	O
while	O
(	O
_rl_kscxt	pointer
)	O
{	O
cxt	pointer
=	O
_rl_kscxt	pointer
;	O
_rl_kscxt	pointer
=	O
_rl_kscxt	pointer
->	O
ocxt	pointer
;	O
_rl_keyseq_cxt_dispose	function
(	O
cxt	pointer
)	O
;	O
}	O
}	O
static	O
int	O
_rl_subseq_getchar	function
(	O
key	int
)	O
int	O
key	int
;	O
{	O
int	O
k	int
;	O
if	O
(	O
key	int
==	O
ESC	O
)	O
RL_SETSTATE	O
(	O
RL_STATE_METANEXT	int
)	O
;	O
RL_SETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
k	int
=	O
rl_read_key	function
(	O
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
if	O
(	O
key	int
==	O
ESC	O
)	O
RL_UNSETSTATE	O
(	O
RL_STATE_METANEXT	int
)	O
;	O
return	O
k	int
;	O
}	O
int	O
_rl_dispatch_callback	function
(	O
cxt	pointer
)	O
_rl_keyseq_cxt	struct
*	O
cxt	pointer
;	O
{	O
int	O
nkey	int
,	O
r	int
;	O
if	O
(	O
(	O
cxt	pointer
->	O
flags	int
&	O
KSEQ_DISPATCHED	int
)	O
==	O
0	int
)	O
{	O
nkey	int
=	O
_rl_subseq_getchar	function
(	O
cxt	pointer
->	O
okey	int
)	O
;	O
if	O
(	O
nkey	int
<	O
0	int
)	O
{	O
_rl_abort_internal	function
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
r	int
=	O
_rl_dispatch_subseq	function
(	O
nkey	int
,	O
cxt	pointer
->	O
dmap	pointer
,	O
cxt	pointer
->	O
subseq_arg	int
)	O
;	O
cxt	pointer
->	O
flags	int
|=	O
KSEQ_DISPATCHED	int
;	O
}	O
else	O
r	int
=	O
cxt	pointer
->	O
childval	int
;	O
if	O
(	O
r	int
!=	O
-	O
3	int
)	O
r	int
=	O
_rl_subseq_result	function
(	O
r	int
,	O
cxt	pointer
->	O
oldmap	pointer
,	O
cxt	pointer
->	O
okey	int
,	O
(	O
cxt	pointer
->	O
flags	int
&	O
KSEQ_SUBSEQ	int
)	O
)	O
;	O
RL_CHECK_SIGNALS	O
(	O
)	O
;	O
if	O
(	O
r	int
>=	O
0	int
||	O
(	O
r	int
==	O
-	O
1	int
&&	O
(	O
cxt	pointer
->	O
flags	int
&	O
KSEQ_SUBSEQ	int
)	O
==	O
0	int
)	O
)	O
{	O
_rl_keyseq_chain_dispose	function
(	O
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_MULTIKEY	int
)	O
;	O
return	O
r	int
;	O
}	O
if	O
(	O
r	int
!=	O
-	O
3	int
)	O
_rl_kscxt	pointer
=	O
cxt	pointer
->	O
ocxt	pointer
;	O
if	O
(	O
_rl_kscxt	pointer
)	O
_rl_kscxt	pointer
->	O
childval	int
=	O
r	int
;	O
if	O
(	O
r	int
!=	O
-	O
3	int
)	O
_rl_keyseq_cxt_dispose	function
(	O
cxt	pointer
)	O
;	O
return	O
r	int
;	O
}	O
int	O
_rl_dispatch	function
(	O
key	int
,	O
map	pointer
)	O
register	O
int	O
key	int
;	O
Keymap	pointer
map	pointer
;	O
{	O
_rl_dispatching_keymap	pointer
=	O
map	pointer
;	O
return	O
_rl_dispatch_subseq	function
(	O
key	int
,	O
map	pointer
,	O
0	int
)	O
;	O
}	O
int	O
_rl_dispatch_subseq	function
(	O
key	int
,	O
map	pointer
,	O
got_subseq	int
)	O
register	O
int	O
key	int
;	O
Keymap	pointer
map	pointer
;	O
int	O
got_subseq	int
;	O
{	O
int	O
r	int
,	O
newkey	int
;	O
char	O
*	O
macro	pointer
;	O
rl_command_func_t	function
*	O
func	pointer
;	O
_rl_keyseq_cxt	struct
*	O
cxt	pointer
;	O
if	O
(	O
META_CHAR	O
(	O
key	int
)	O
&&	O
_rl_convert_meta_chars_to_ascii	int
)	O
{	O
if	O
(	O
map	pointer
[	O
ESC	O
]	O
.	O
type	enum
==	O
ISKMAP	int
)	O
{	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_MACRODEF	int
)	O
)	O
_rl_add_macro_char	function
(	O
ESC	O
)	O
;	O
RESIZE_KEYSEQ_BUFFER	O
(	O
)	O
;	O
rl_executing_keyseq	pointer
[	O
rl_key_sequence_length	int
++	O
]	O
=	O
ESC	O
;	O
map	pointer
=	O
FUNCTION_TO_KEYMAP	O
(	O
map	pointer
,	O
ESC	O
)	O
;	O
key	int
=	O
UNMETA	O
(	O
key	int
)	O
;	O
return	O
(	O
_rl_dispatch	function
(	O
key	int
,	O
map	pointer
)	O
)	O
;	O
}	O
else	O
rl_ding	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_MACRODEF	int
)	O
)	O
_rl_add_macro_char	function
(	O
key	int
)	O
;	O
r	int
=	O
0	int
;	O
switch	O
(	O
map	pointer
[	O
key	int
]	O
.	O
type	enum
)	O
{	O
case	O
ISFUNC	int
:	O
func	pointer
=	O
map	pointer
[	O
key	int
]	O
.	O
function	pointer
;	O
if	O
(	O
func	pointer
)	O
{	O
if	O
(	O
func	pointer
==	O
rl_do_lowercase_version	function
)	O
return	O
(	O
_rl_dispatch	function
(	O
_rl_to_lower	function
(	O
(	O
unsigned	O
char	O
)	O
key	int
)	O
,	O
map	pointer
)	O
)	O
;	O
rl_executing_keymap	pointer
=	O
map	pointer
;	O
rl_executing_key	int
=	O
key	int
;	O
RESIZE_KEYSEQ_BUFFER	O
(	O
)	O
;	O
rl_executing_keyseq	pointer
[	O
rl_key_sequence_length	int
++	O
]	O
=	O
key	int
;	O
rl_executing_keyseq	pointer
[	O
rl_key_sequence_length	int
]	O
=	O
'\0'	O
;	O
rl_dispatching	int
=	O
1	int
;	O
RL_SETSTATE	O
(	O
RL_STATE_DISPATCHING	int
)	O
;	O
r	int
=	O
(	O
*	O
func	pointer
)	O
(	O
rl_numeric_arg	int
*	O
rl_arg_sign	int
,	O
key	int
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_DISPATCHING	int
)	O
;	O
rl_dispatching	int
=	O
0	int
;	O
if	O
(	O
rl_pending_input	int
==	O
0	int
&&	O
map	pointer
[	O
key	int
]	O
.	O
function	pointer
!=	O
rl_digit_argument	function
)	O
rl_last_func	pointer
=	O
map	pointer
[	O
key	int
]	O
.	O
function	pointer
;	O
RL_CHECK_SIGNALS	O
(	O
)	O
;	O
}	O
else	O
if	O
(	O
map	pointer
[	O
ANYOTHERKEY	O
]	O
.	O
function	pointer
)	O
{	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_MACROINPUT	int
)	O
)	O
_rl_prev_macro_key	function
(	O
)	O
;	O
else	O
_rl_unget_char	function
(	O
key	int
)	O
;	O
return	O
-	O
2	int
;	O
}	O
else	O
if	O
(	O
got_subseq	int
)	O
{	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_MACROINPUT	int
)	O
)	O
_rl_prev_macro_key	function
(	O
)	O
;	O
else	O
_rl_unget_char	function
(	O
key	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
RL_UNSETSTATE	O
(	O
RL_STATE_MULTIKEY	int
)	O
;	O
_rl_keyseq_chain_dispose	function
(	O
)	O
;	O
_rl_abort_internal	function
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
break	O
;	O
case	O
ISKMAP	int
:	O
if	O
(	O
map	pointer
[	O
key	int
]	O
.	O
function	pointer
!=	O
0	int
)	O
{	O
if	O
(	O
rl_editing_mode	int
==	O
vi_mode	int
&&	O
key	int
==	O
ESC	O
&&	O
map	pointer
==	O
vi_insertion_keymap	array
&&	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_INPUTPENDING	int
|	O
RL_STATE_MACROINPUT	int
)	O
==	O
0	int
)	O
&&	O
_rl_pushed_input_available	function
(	O
)	O
==	O
0	int
&&	O
_rl_input_queued	function
(	O
(	O
_rl_keyseq_timeout	int
>	O
0	int
)	O
?	O
_rl_keyseq_timeout	int
*	O
1000	int
:	O
0	int
)	O
==	O
0	int
)	O
return	O
(	O
_rl_dispatch	function
(	O
ANYOTHERKEY	O
,	O
FUNCTION_TO_KEYMAP	O
(	O
map	pointer
,	O
key	int
)	O
)	O
)	O
;	O
RESIZE_KEYSEQ_BUFFER	O
(	O
)	O
;	O
rl_executing_keyseq	pointer
[	O
rl_key_sequence_length	int
++	O
]	O
=	O
key	int
;	O
_rl_dispatching_keymap	pointer
=	O
FUNCTION_TO_KEYMAP	O
(	O
map	pointer
,	O
key	int
)	O
;	O
if	O
(	O
_rl_vi_redoing	int
&&	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
&&	O
map	pointer
[	O
ANYOTHERKEY	O
]	O
.	O
function	pointer
!=	O
0	int
)	O
return	O
(	O
_rl_subseq_result	function
(	O
-	O
2	int
,	O
map	pointer
,	O
key	int
,	O
got_subseq	int
)	O
)	O
;	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
)	O
{	O
r	int
=	O
RL_ISSTATE	O
(	O
RL_STATE_MULTIKEY	int
)	O
?	O
-	O
3	int
:	O
0	int
;	O
cxt	pointer
=	O
_rl_keyseq_cxt_alloc	function
(	O
)	O
;	O
if	O
(	O
got_subseq	int
)	O
cxt	pointer
->	O
flags	int
|=	O
KSEQ_SUBSEQ	int
;	O
cxt	pointer
->	O
okey	int
=	O
key	int
;	O
cxt	pointer
->	O
oldmap	pointer
=	O
map	pointer
;	O
cxt	pointer
->	O
dmap	pointer
=	O
_rl_dispatching_keymap	pointer
;	O
cxt	pointer
->	O
subseq_arg	int
=	O
got_subseq	int
||	O
cxt	pointer
->	O
dmap	pointer
[	O
ANYOTHERKEY	O
]	O
.	O
function	pointer
;	O
RL_SETSTATE	O
(	O
RL_STATE_MULTIKEY	int
)	O
;	O
_rl_kscxt	pointer
=	O
cxt	pointer
;	O
return	O
r	int
;	O
}	O
if	O
(	O
_rl_keyseq_timeout	int
>	O
0	int
&&	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_INPUTPENDING	int
|	O
RL_STATE_MACROINPUT	int
)	O
==	O
0	int
)	O
&&	O
_rl_pushed_input_available	function
(	O
)	O
==	O
0	int
&&	O
_rl_dispatching_keymap	pointer
[	O
ANYOTHERKEY	O
]	O
.	O
function	pointer
&&	O
_rl_input_queued	function
(	O
_rl_keyseq_timeout	int
*	O
1000	int
)	O
==	O
0	int
)	O
return	O
(	O
_rl_subseq_result	function
(	O
-	O
2	int
,	O
map	pointer
,	O
key	int
,	O
got_subseq	int
)	O
)	O
;	O
newkey	int
=	O
_rl_subseq_getchar	function
(	O
key	int
)	O
;	O
if	O
(	O
newkey	int
<	O
0	int
)	O
{	O
_rl_abort_internal	function
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
r	int
=	O
_rl_dispatch_subseq	function
(	O
newkey	int
,	O
_rl_dispatching_keymap	pointer
,	O
got_subseq	int
||	O
map	pointer
[	O
ANYOTHERKEY	O
]	O
.	O
function	pointer
)	O
;	O
return	O
_rl_subseq_result	function
(	O
r	int
,	O
map	pointer
,	O
key	int
,	O
got_subseq	int
)	O
;	O
}	O
else	O
{	O
_rl_abort_internal	function
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
break	O
;	O
case	O
ISMACR	int
:	O
if	O
(	O
map	pointer
[	O
key	int
]	O
.	O
function	pointer
!=	O
0	int
)	O
{	O
rl_executing_keyseq	pointer
[	O
rl_key_sequence_length	int
]	O
=	O
'\0'	O
;	O
macro	pointer
=	O
savestring	O
(	O
(	O
char	O
*	O
)	O
map	pointer
[	O
key	int
]	O
.	O
function	pointer
)	O
;	O
_rl_with_macro_input	function
(	O
macro	pointer
)	O
;	O
return	O
0	int
;	O
}	O
break	O
;	O
}	O
if	O
(	O
rl_editing_mode	int
==	O
vi_mode	int
&&	O
_rl_keymap	pointer
==	O
vi_movement_keymap	array
&&	O
key	int
!=	O
ANYOTHERKEY	O
&&	O
_rl_dispatching_keymap	pointer
==	O
vi_movement_keymap	array
&&	O
_rl_vi_textmod_command	function
(	O
key	int
)	O
)	O
_rl_vi_set_last	function
(	O
key	int
,	O
rl_numeric_arg	int
,	O
rl_arg_sign	int
)	O
;	O
return	O
(	O
r	int
)	O
;	O
}	O
static	O
int	O
_rl_subseq_result	function
(	O
r	int
,	O
map	pointer
,	O
key	int
,	O
got_subseq	int
)	O
int	O
r	int
;	O
Keymap	pointer
map	pointer
;	O
int	O
key	int
,	O
got_subseq	int
;	O
{	O
Keymap	pointer
m	pointer
;	O
int	O
type	enum
,	O
nt	int
;	O
rl_command_func_t	function
*	O
func	pointer
,	O
*	O
nf	pointer
;	O
if	O
(	O
r	int
==	O
-	O
2	int
)	O
{	O
m	pointer
=	O
_rl_dispatching_keymap	pointer
;	O
type	enum
=	O
m	pointer
[	O
ANYOTHERKEY	O
]	O
.	O
type	enum
;	O
func	pointer
=	O
m	pointer
[	O
ANYOTHERKEY	O
]	O
.	O
function	pointer
;	O
if	O
(	O
type	enum
==	O
ISFUNC	int
&&	O
func	pointer
==	O
rl_do_lowercase_version	function
)	O
r	int
=	O
_rl_dispatch	function
(	O
_rl_to_lower	function
(	O
(	O
unsigned	O
char	O
)	O
key	int
)	O
,	O
map	pointer
)	O
;	O
else	O
if	O
(	O
type	enum
==	O
ISFUNC	int
)	O
{	O
nt	int
=	O
m	pointer
[	O
key	int
]	O
.	O
type	enum
;	O
nf	pointer
=	O
m	pointer
[	O
key	int
]	O
.	O
function	pointer
;	O
m	pointer
[	O
key	int
]	O
.	O
type	enum
=	O
type	enum
;	O
m	pointer
[	O
key	int
]	O
.	O
function	pointer
=	O
func	pointer
;	O
_rl_dispatching_keymap	pointer
=	O
map	pointer
;	O
r	int
=	O
_rl_dispatch_subseq	function
(	O
key	int
,	O
m	pointer
,	O
0	int
)	O
;	O
m	pointer
[	O
key	int
]	O
.	O
type	enum
=	O
nt	int
;	O
m	pointer
[	O
key	int
]	O
.	O
function	pointer
=	O
nf	pointer
;	O
}	O
else	O
r	int
=	O
_rl_dispatch	function
(	O
ANYOTHERKEY	O
,	O
m	pointer
)	O
;	O
}	O
else	O
if	O
(	O
r	int
&&	O
map	pointer
[	O
ANYOTHERKEY	O
]	O
.	O
function	pointer
)	O
{	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_MACROINPUT	int
)	O
)	O
_rl_prev_macro_key	function
(	O
)	O
;	O
else	O
_rl_unget_char	function
(	O
key	int
)	O
;	O
_rl_dispatching_keymap	pointer
=	O
map	pointer
;	O
return	O
-	O
2	int
;	O
}	O
else	O
if	O
(	O
r	int
&&	O
got_subseq	int
)	O
{	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_MACROINPUT	int
)	O
)	O
_rl_prev_macro_key	function
(	O
)	O
;	O
else	O
_rl_unget_char	function
(	O
key	int
)	O
;	O
_rl_dispatching_keymap	pointer
=	O
map	pointer
;	O
return	O
-	O
1	int
;	O
}	O
return	O
r	int
;	O
}	O
int	O
rl_initialize	function
(	O
)	O
{	O
if	O
(	O
!	O
rl_initialized	int
)	O
{	O
RL_SETSTATE	O
(	O
RL_STATE_INITIALIZING	int
)	O
;	O
readline_initialize_everything	function
(	O
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_INITIALIZING	int
)	O
;	O
rl_initialized	int
++	O
;	O
RL_SETSTATE	O
(	O
RL_STATE_INITIALIZED	int
)	O
;	O
}	O
_rl_init_line_state	function
(	O
)	O
;	O
rl_done	int
=	O
0	int
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_DONE	int
)	O
;	O
_rl_start_using_history	function
(	O
)	O
;	O
rl_reset_line_state	function
(	O
)	O
;	O
rl_last_func	pointer
=	O
(	O
rl_command_func_t	function
*	O
)	O
NULL	O
;	O
_rl_parsing_conditionalized_out	char
=	O
0	int
;	O
if	O
(	O
rl_editing_mode	int
==	O
vi_mode	int
)	O
_rl_vi_initialize_line	function
(	O
)	O
;	O
_rl_set_insert_mode	function
(	O
RL_IM_DEFAULT	O
,	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
readline_initialize_everything	function
(	O
)	O
{	O
if	O
(	O
!	O
rl_instream	pointer
)	O
rl_instream	pointer
=	O
stdin	pointer
;	O
if	O
(	O
!	O
rl_outstream	pointer
)	O
rl_outstream	pointer
=	O
stdout	pointer
;	O
_rl_in_stream	pointer
=	O
rl_instream	pointer
;	O
_rl_out_stream	pointer
=	O
rl_outstream	pointer
;	O
if	O
(	O
rl_line_buffer	pointer
==	O
0	int
)	O
rl_line_buffer	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
rl_line_buffer_len	int
=	O
DEFAULT_BUFFER_SIZE	int
)	O
;	O
if	O
(	O
rl_terminal_name	pointer
==	O
0	int
)	O
rl_terminal_name	pointer
=	O
sh_get_env_value	function
(	O
"TERM"	pointer
)	O
;	O
_rl_init_terminal_io	function
(	O
rl_terminal_name	pointer
)	O
;	O
readline_default_bindings	function
(	O
)	O
;	O
rl_initialize_funmap	function
(	O
)	O
;	O
_rl_init_eightbit	function
(	O
)	O
;	O
rl_read_init_file	function
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
if	O
(	O
_rl_horizontal_scroll_mode	int
&&	O
_rl_term_autowrap	int
)	O
{	O
_rl_screenwidth	int
--	O
;	O
_rl_screenchars	int
-=	O
_rl_screenheight	int
;	O
}	O
rl_set_keymap_from_edit_mode	function
(	O
)	O
;	O
bind_arrow_keys	function
(	O
)	O
;	O
bind_bracketed_paste_prefix	function
(	O
)	O
;	O
if	O
(	O
rl_completer_word_break_characters	pointer
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
rl_completer_word_break_characters	pointer
=	O
(	O
char	O
*	O
)	O
rl_basic_word_break_characters	pointer
;	O
if	O
(	O
_rl_colored_stats	int
||	O
_rl_colored_completion_prefix	int
)	O
_rl_parse_colors	function
(	O
)	O
;	O
rl_executing_keyseq	pointer
=	O
malloc	function
(	O
_rl_executing_keyseq_size	int
=	O
16	int
)	O
;	O
if	O
(	O
rl_executing_keyseq	pointer
)	O
rl_executing_keyseq	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
}	O
static	O
void	O
readline_default_bindings	function
(	O
)	O
{	O
if	O
(	O
_rl_bind_stty_chars	int
)	O
rl_tty_set_default_bindings	function
(	O
_rl_keymap	pointer
)	O
;	O
}	O
static	O
void	O
reset_default_bindings	function
(	O
)	O
{	O
if	O
(	O
_rl_bind_stty_chars	int
)	O
{	O
rl_tty_unset_default_bindings	function
(	O
_rl_keymap	pointer
)	O
;	O
rl_tty_set_default_bindings	function
(	O
_rl_keymap	pointer
)	O
;	O
}	O
}	O
static	O
void	O
bind_arrow_keys_internal	function
(	O
map	pointer
)	O
Keymap	pointer
map	pointer
;	O
{	O
Keymap	pointer
xkeymap	pointer
;	O
xkeymap	pointer
=	O
_rl_keymap	pointer
;	O
_rl_keymap	pointer
=	O
map	pointer
;	O
rl_bind_keyseq_if_unbound	function
(	O
"\033[A"	pointer
,	O
rl_get_previous_history	function
)	O
;	O
rl_bind_keyseq_if_unbound	function
(	O
"\033[B"	pointer
,	O
rl_get_next_history	function
)	O
;	O
rl_bind_keyseq_if_unbound	function
(	O
"\033[C"	pointer
,	O
rl_forward_char	function
)	O
;	O
rl_bind_keyseq_if_unbound	function
(	O
"\033[D"	pointer
,	O
rl_backward_char	function
)	O
;	O
rl_bind_keyseq_if_unbound	function
(	O
"\033[H"	pointer
,	O
rl_beg_of_line	function
)	O
;	O
rl_bind_keyseq_if_unbound	function
(	O
"\033[F"	pointer
,	O
rl_end_of_line	function
)	O
;	O
rl_bind_keyseq_if_unbound	function
(	O
"\033OA"	pointer
,	O
rl_get_previous_history	function
)	O
;	O
rl_bind_keyseq_if_unbound	function
(	O
"\033OB"	pointer
,	O
rl_get_next_history	function
)	O
;	O
rl_bind_keyseq_if_unbound	function
(	O
"\033OC"	pointer
,	O
rl_forward_char	function
)	O
;	O
rl_bind_keyseq_if_unbound	function
(	O
"\033OD"	pointer
,	O
rl_backward_char	function
)	O
;	O
rl_bind_keyseq_if_unbound	function
(	O
"\033OH"	pointer
,	O
rl_beg_of_line	function
)	O
;	O
rl_bind_keyseq_if_unbound	function
(	O
"\033OF"	pointer
,	O
rl_end_of_line	function
)	O
;	O
_rl_keymap	pointer
=	O
xkeymap	pointer
;	O
}	O
static	O
void	O
bind_arrow_keys	function
(	O
)	O
{	O
bind_arrow_keys_internal	function
(	O
emacs_standard_keymap	array
)	O
;	O
bind_arrow_keys_internal	function
(	O
vi_movement_keymap	array
)	O
;	O
if	O
(	O
vi_movement_keymap	array
[	O
ESC	O
]	O
.	O
type	enum
==	O
ISKMAP	int
)	O
rl_bind_keyseq_in_map	function
(	O
"\033"	pointer
,	O
(	O
rl_command_func_t	function
*	O
)	O
NULL	O
,	O
vi_movement_keymap	array
)	O
;	O
bind_arrow_keys_internal	function
(	O
vi_insertion_keymap	array
)	O
;	O
}	O
static	O
void	O
bind_bracketed_paste_prefix	function
(	O
)	O
{	O
Keymap	pointer
xkeymap	pointer
;	O
xkeymap	pointer
=	O
_rl_keymap	pointer
;	O
_rl_keymap	pointer
=	O
emacs_standard_keymap	array
;	O
rl_bind_keyseq_if_unbound	function
(	O
BRACK_PASTE_PREF	pointer
,	O
rl_bracketed_paste_begin	function
)	O
;	O
_rl_keymap	pointer
=	O
vi_insertion_keymap	array
;	O
rl_bind_keyseq_if_unbound	function
(	O
BRACK_PASTE_PREF	pointer
,	O
rl_bracketed_paste_begin	function
)	O
;	O
_rl_keymap	pointer
=	O
xkeymap	pointer
;	O
}	O
int	O
rl_save_state	function
(	O
sp	pointer
)	O
struct	O
readline_state	struct
*	O
sp	pointer
;	O
{	O
if	O
(	O
sp	pointer
==	O
0	int
)	O
return	O
-	O
1	int
;	O
sp	pointer
->	O
point	int
=	O
rl_point	int
;	O
sp	pointer
->	O
end	int
=	O
rl_end	int
;	O
sp	pointer
->	O
mark	int
=	O
rl_mark	int
;	O
sp	pointer
->	O
buffer	pointer
=	O
rl_line_buffer	pointer
;	O
sp	pointer
->	O
buflen	int
=	O
rl_line_buffer_len	int
;	O
sp	pointer
->	O
ul	pointer
=	O
rl_undo_list	pointer
;	O
sp	pointer
->	O
prompt	pointer
=	O
rl_prompt	pointer
;	O
sp	pointer
->	O
rlstate	int
=	O
rl_readline_state	long
;	O
sp	pointer
->	O
done	int
=	O
rl_done	int
;	O
sp	pointer
->	O
kmap	pointer
=	O
_rl_keymap	pointer
;	O
sp	pointer
->	O
lastfunc	pointer
=	O
rl_last_func	pointer
;	O
sp	pointer
->	O
insmode	int
=	O
rl_insert_mode	int
;	O
sp	pointer
->	O
edmode	int
=	O
rl_editing_mode	int
;	O
sp	pointer
->	O
kseq	pointer
=	O
rl_executing_keyseq	pointer
;	O
sp	pointer
->	O
kseqlen	int
=	O
rl_key_sequence_length	int
;	O
sp	pointer
->	O
inf	pointer
=	O
rl_instream	pointer
;	O
sp	pointer
->	O
outf	pointer
=	O
rl_outstream	pointer
;	O
sp	pointer
->	O
pendingin	int
=	O
rl_pending_input	int
;	O
sp	pointer
->	O
macro	pointer
=	O
rl_executing_macro	pointer
;	O
sp	pointer
->	O
catchsigs	int
=	O
rl_catch_signals	int
;	O
sp	pointer
->	O
catchsigwinch	int
=	O
rl_catch_sigwinch	int
;	O
sp	pointer
->	O
entryfunc	pointer
=	O
rl_completion_entry_function	pointer
;	O
sp	pointer
->	O
menuentryfunc	pointer
=	O
rl_menu_completion_entry_function	pointer
;	O
sp	pointer
->	O
ignorefunc	pointer
=	O
rl_ignore_some_completions_function	pointer
;	O
sp	pointer
->	O
attemptfunc	pointer
=	O
rl_attempted_completion_function	pointer
;	O
sp	pointer
->	O
wordbreakchars	pointer
=	O
rl_completer_word_break_characters	pointer
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_restore_state	function
(	O
sp	pointer
)	O
struct	O
readline_state	struct
*	O
sp	pointer
;	O
{	O
if	O
(	O
sp	pointer
==	O
0	int
)	O
return	O
-	O
1	int
;	O
rl_point	int
=	O
sp	pointer
->	O
point	int
;	O
rl_end	int
=	O
sp	pointer
->	O
end	int
;	O
rl_mark	int
=	O
sp	pointer
->	O
mark	int
;	O
the_line	pointer
=	O
rl_line_buffer	pointer
=	O
sp	pointer
->	O
buffer	pointer
;	O
rl_line_buffer_len	int
=	O
sp	pointer
->	O
buflen	int
;	O
rl_undo_list	pointer
=	O
sp	pointer
->	O
ul	pointer
;	O
rl_prompt	pointer
=	O
sp	pointer
->	O
prompt	pointer
;	O
rl_readline_state	long
=	O
sp	pointer
->	O
rlstate	int
;	O
rl_done	int
=	O
sp	pointer
->	O
done	int
;	O
_rl_keymap	pointer
=	O
sp	pointer
->	O
kmap	pointer
;	O
rl_last_func	pointer
=	O
sp	pointer
->	O
lastfunc	pointer
;	O
rl_insert_mode	int
=	O
sp	pointer
->	O
insmode	int
;	O
rl_editing_mode	int
=	O
sp	pointer
->	O
edmode	int
;	O
rl_executing_keyseq	pointer
=	O
sp	pointer
->	O
kseq	pointer
;	O
rl_key_sequence_length	int
=	O
sp	pointer
->	O
kseqlen	int
;	O
rl_instream	pointer
=	O
sp	pointer
->	O
inf	pointer
;	O
rl_outstream	pointer
=	O
sp	pointer
->	O
outf	pointer
;	O
rl_pending_input	int
=	O
sp	pointer
->	O
pendingin	int
;	O
rl_executing_macro	pointer
=	O
sp	pointer
->	O
macro	pointer
;	O
rl_catch_signals	int
=	O
sp	pointer
->	O
catchsigs	int
;	O
rl_catch_sigwinch	int
=	O
sp	pointer
->	O
catchsigwinch	int
;	O
rl_completion_entry_function	pointer
=	O
sp	pointer
->	O
entryfunc	pointer
;	O
rl_menu_completion_entry_function	pointer
=	O
sp	pointer
->	O
menuentryfunc	pointer
;	O
rl_ignore_some_completions_function	pointer
=	O
sp	pointer
->	O
ignorefunc	pointer
;	O
rl_attempted_completion_function	pointer
=	O
sp	pointer
->	O
attemptfunc	pointer
;	O
rl_completer_word_break_characters	pointer
=	O
sp	pointer
->	O
wordbreakchars	pointer
;	O
return	O
(	O
0	int
)	O
;	O
}	O
