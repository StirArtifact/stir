extern	O
char	O
*	O
*	O
environ	pointer
;	O
char	O
*	O
rush_config_file	pointer
=	O
CONFIG_FILE	O
;	O
int	O
lint_option	int
=	O
0	int
;	O
int	O
scanner_test	int
=	O
0	int
;	O
unsigned	O
sleep_time	int
=	O
5	int
;	O
unsigned	O
debug_level	int
;	O
int	O
debug_option	int
;	O
char	O
*	O
dump_option	pointer
;	O
int	O
parser_traces	int
;	O
struct	O
rush_rule	struct
*	O
rule_head	pointer
,	O
*	O
rule_tail	pointer
;	O
struct	O
passwd	struct
*	O
rush_pw	pointer
;	O
struct	O
error_msg	struct
{	O
char	O
*	O
text	pointer
;	O
int	O
custom	int
;	O
}	O
;	O
struct	O
error_msg	struct
error_msg	struct
[	O
]	O
=	O
{	O
{	O
N_	O
(	O
"You are not permitted to execute this command.\n"	pointer
"Contact the systems administrator for further assistance.\n"	pointer
)	O
,	O
}	O
,	O
{	O
N_	O
(	O
"You do not have interactive login access to this machine.\n"	pointer
"Contact the systems administrator for further assistance.\n"	pointer
)	O
}	O
,	O
{	O
N_	O
(	O
"Local configuration error occurred.\n"	pointer
"Contact the systems administrator for further assistance.\n"	pointer
)	O
}	O
,	O
{	O
N_	O
(	O
"A system error occurred while attempting to execute command.\n"	pointer
"Contact the systems administrator for further assistance.\n"	pointer
)	O
}	O
}	O
;	O
void	O
set_error_msg	function
(	O
enum	O
error_type	enum
type	enum
,	O
char	O
*	O
text	pointer
)	O
{	O
error_msg	struct
[	O
type	enum
]	O
.	O
text	pointer
=	O
text	pointer
;	O
error_msg	struct
[	O
type	enum
]	O
.	O
custom	int
=	O
1	int
;	O
}	O
int	O
string_to_error_index	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
static	O
const	O
char	O
*	O
error_msg_name	array
[	O
]	O
=	O
{	O
[	O
usage_error	int
]	O
=	O
"usage-error"	pointer
,	O
[	O
nologin_error	int
]	O
=	O
"nologin-error"	pointer
,	O
[	O
config_error	int
]	O
=	O
"config-error"	pointer
,	O
[	O
system_error	int
]	O
=	O
"system-error"	pointer
,	O
NULL	O
}	O
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
error_msg_name	array
[	O
i	int
]	O
;	O
i	int
++	O
)	O
if	O
(	O
strcmp	function
(	O
error_msg_name	array
[	O
i	int
]	O
,	O
name	pointer
)	O
==	O
0	int
)	O
return	O
i	int
;	O
return	O
-	O
1	int
;	O
}	O
struct	O
rush_error	struct
*	O
new_standard_error	function
(	O
int	O
fd	int
,	O
int	O
idx	int
)	O
{	O
struct	O
rush_error	struct
*	O
err	long
=	O
xmalloc	function
(	O
sizeof	O
(	O
*	O
err	long
)	O
)	O
;	O
err	long
->	O
fd	int
=	O
fd	int
;	O
err	long
->	O
idx	int
=	O
idx	int
;	O
return	O
err	long
;	O
}	O
static	O
inline	O
char	O
*	O
error_text_ptr	function
(	O
struct	O
rush_error	struct
const	O
*	O
err	long
)	O
{	O
return	O
(	O
char	O
*	O
)	O
(	O
err	long
+	O
1	int
)	O
;	O
}	O
struct	O
rush_error	struct
*	O
new_error	function
(	O
int	O
fd	int
,	O
char	O
const	O
*	O
text	pointer
,	O
int	O
unescape	int
)	O
{	O
struct	O
rush_error	struct
*	O
err	long
;	O
size_t	long
len	long
=	O
strlen	function
(	O
text	pointer
)	O
;	O
int	O
add_nl	int
=	O
len	long
>	O
0	int
&&	O
text	pointer
[	O
len	long
-	O
1	int
]	O
!=	O
'\n'	O
;	O
int	O
c	int
;	O
char	O
*	O
p	pointer
;	O
err	long
=	O
xmalloc	function
(	O
sizeof	O
(	O
*	O
err	long
)	O
+	O
strlen	function
(	O
text	pointer
)	O
+	O
(	O
add_nl	int
?	O
1	int
:	O
0	int
)	O
+	O
1	int
)	O
;	O
err	long
->	O
fd	int
=	O
fd	int
;	O
err	long
->	O
idx	int
=	O
-	O
1	int
;	O
p	pointer
=	O
error_text_ptr	function
(	O
err	long
)	O
;	O
while	O
(	O
(	O
c	int
=	O
*	O
text	pointer
++	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
unescape	int
&&	O
c	int
==	O
'\\'	O
&&	O
*	O
text	pointer
)	O
{	O
int	O
c1	int
=	O
wordsplit_c_unquote_char	function
(	O
*	O
text	pointer
)	O
;	O
if	O
(	O
c1	int
)	O
c	int
=	O
c1	int
;	O
else	O
c	int
=	O
*	O
text	pointer
;	O
text	pointer
++	O
;	O
}	O
*	O
p	pointer
++	O
=	O
c	int
;	O
}	O
if	O
(	O
add_nl	int
)	O
*	O
p	pointer
++	O
=	O
'\n'	O
;	O
*	O
p	pointer
=	O
0	int
;	O
return	O
err	long
;	O
}	O
char	O
const	O
*	O
rush_error_msg	function
(	O
struct	O
rush_error	struct
const	O
*	O
err	long
,	O
struct	O
rush_i18n	struct
const	O
*	O
i18n	struct
)	O
{	O
const	O
char	O
*	O
msg	pointer
;	O
if	O
(	O
err	long
->	O
idx	int
>=	O
0	int
)	O
{	O
msg	pointer
=	O
error_msg	struct
[	O
err	long
->	O
idx	int
]	O
.	O
text	pointer
;	O
if	O
(	O
error_msg	struct
[	O
err	long
->	O
idx	int
]	O
.	O
custom	int
)	O
{	O
if	O
(	O
i18n	struct
)	O
msg	pointer
=	O
user_gettext	function
(	O
i18n	struct
->	O
locale	pointer
,	O
i18n	struct
->	O
text_domain	pointer
,	O
i18n	struct
->	O
localedir	pointer
,	O
msg	pointer
)	O
;	O
}	O
else	O
msg	pointer
=	O
gettext	function
(	O
msg	pointer
)	O
;	O
}	O
else	O
msg	pointer
=	O
gettext	function
(	O
error_text_ptr	function
(	O
err	long
)	O
)	O
;	O
return	O
msg	pointer
;	O
}	O
void	O
send_msg	function
(	O
const	O
char	O
*	O
msg	pointer
,	O
size_t	long
len	long
)	O
{	O
if	O
(	O
write	pointer
(	O
STDERR_FILENO	int
,	O
msg	pointer
,	O
len	long
)	O
<	O
0	int
)	O
{	O
logmsg	function
(	O
LOG_ERR	int
,	O
_	O
(	O
"failed to write message to stderr: %s"	pointer
)	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
if	O
(	O
write	pointer
(	O
STDOUT_FILENO	int
,	O
msg	pointer
,	O
len	long
)	O
<	O
0	int
)	O
logmsg	function
(	O
LOG_ERR	int
,	O
_	O
(	O
"failed to write message to stdout: %s"	pointer
)	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
}	O
void	O
vlogmsg	function
(	O
int	O
prio	int
,	O
const	O
char	O
*	O
fmt	pointer
,	O
va_list	array
ap	array
)	O
{	O
if	O
(	O
lint_option	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: "	pointer
,	O
program_name	pointer
)	O
;	O
switch	O
(	O
prio	int
)	O
{	O
case	O
LOG_DEBUG	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Debug: "	pointer
)	O
)	O
;	O
break	O
;	O
case	O
LOG_INFO	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Info: "	pointer
)	O
)	O
;	O
break	O
;	O
case	O
LOG_NOTICE	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Notice: "	pointer
)	O
)	O
;	O
break	O
;	O
case	O
LOG_WARNING	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Warning: "	pointer
)	O
)	O
;	O
break	O
;	O
case	O
LOG_ERR	int
:	O
case	O
LOG_CRIT	int
:	O
case	O
LOG_ALERT	int
:	O
case	O
LOG_EMERG	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Error: "	pointer
)	O
)	O
;	O
}	O
vfprintf	function
(	O
stderr	pointer
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
stderr	pointer
)	O
;	O
}	O
else	O
vsyslog	function
(	O
prio	int
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
}	O
void	O
logmsg	function
(	O
int	O
prio	int
,	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
vlogmsg	function
(	O
prio	int
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
}	O
void	O
die	function
(	O
enum	O
error_type	enum
type	enum
,	O
struct	O
rush_i18n	struct
*	O
i18n	struct
,	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
if	O
(	O
fmt	pointer
)	O
{	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
vlogmsg	function
(	O
LOG_ERR	int
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
}	O
if	O
(	O
!	O
lint_option	int
)	O
{	O
const	O
char	O
*	O
msg	pointer
=	O
error_msg	struct
[	O
type	enum
]	O
.	O
text	pointer
;	O
if	O
(	O
error_msg	struct
[	O
type	enum
]	O
.	O
custom	int
)	O
{	O
if	O
(	O
i18n	struct
)	O
msg	pointer
=	O
user_gettext	function
(	O
i18n	struct
->	O
locale	pointer
,	O
i18n	struct
->	O
text_domain	pointer
,	O
i18n	struct
->	O
localedir	pointer
,	O
msg	pointer
)	O
;	O
}	O
else	O
msg	pointer
=	O
gettext	function
(	O
msg	pointer
)	O
;	O
send_msg	function
(	O
msg	pointer
,	O
strlen	function
(	O
msg	pointer
)	O
)	O
;	O
sleep	function
(	O
sleep_time	int
)	O
;	O
}	O
exit	function
(	O
1	int
)	O
;	O
}	O
void	O
die_usage	function
(	O
struct	O
cfloc	struct
const	O
*	O
loc	pointer
,	O
char	O
const	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
vcferror	function
(	O
loc	pointer
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
die	function
(	O
usage_error	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
void	O
xalloc_die	function
(	O
)	O
{	O
die	function
(	O
system_error	int
,	O
NULL	O
,	O
_	O
(	O
"Not enough memory"	pointer
)	O
)	O
;	O
}	O
static	O
rush_bool_t	enum
eval_cmpn	function
(	O
struct	O
test_node	struct
*	O
node	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
rush_request	struct
*	O
req	pointer
)	O
{	O
char	O
*	O
str	pointer
=	O
rush_expand_string	function
(	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
larg	pointer
,	O
req	pointer
)	O
;	O
char	O
*	O
p	pointer
;	O
unsigned	O
long	O
n	long
;	O
errno	O
=	O
0	int
;	O
n	long
=	O
strtoul	function
(	O
str	pointer
,	O
&	O
p	pointer
,	O
0	int
)	O
;	O
if	O
(	O
errno	O
||	O
*	O
p	pointer
)	O
die	function
(	O
system_error	int
,	O
NULL	O
,	O
_	O
(	O
"%s: not a number"	pointer
)	O
,	O
str	pointer
)	O
;	O
free	function
(	O
str	pointer
)	O
;	O
switch	O
(	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
op	enum
)	O
{	O
case	O
cmp_eq	int
:	O
return	O
n	long
==	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
rarg	union
.	O
num	long
;	O
case	O
cmp_ne	int
:	O
return	O
n	long
!=	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
rarg	union
.	O
num	long
;	O
case	O
cmp_lt	int
:	O
return	O
n	long
<	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
rarg	union
.	O
num	long
;	O
case	O
cmp_le	int
:	O
return	O
n	long
<=	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
rarg	union
.	O
num	long
;	O
case	O
cmp_gt	int
:	O
return	O
n	long
>	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
rarg	union
.	O
num	long
;	O
case	O
cmp_ge	int
:	O
return	O
n	long
>=	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
rarg	union
.	O
num	long
;	O
default	O
:	O
die	function
(	O
system_error	int
,	O
NULL	O
,	O
_	O
(	O
"INTERNAL ERROR at %s:%d: unrecognized opcode %d"	pointer
)	O
,	O
__FILE__	O
,	O
__LINE__	O
,	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
op	enum
)	O
;	O
}	O
}	O
static	O
int	O
eval_regex	function
(	O
struct	O
rush_request	struct
*	O
req	pointer
,	O
regex_t	struct
*	O
rx	struct
,	O
char	O
const	O
*	O
subj	pointer
)	O
{	O
int	O
rc	int
;	O
struct	O
rush_backref	struct
*	O
bref	pointer
=	O
&	O
req	pointer
->	O
backref	array
[	O
!	O
req	pointer
->	O
backref_cur	int
]	O
;	O
size_t	long
n	long
=	O
rx	struct
->	O
re_nsub	long
+	O
1	int
;	O
if	O
(	O
n	long
>	O
bref	pointer
->	O
maxmatch	long
)	O
{	O
bref	pointer
->	O
match	pointer
=	O
xrealloc	function
(	O
bref	pointer
->	O
match	pointer
,	O
sizeof	O
(	O
bref	pointer
->	O
match	pointer
[	O
0	int
]	O
)	O
*	O
n	long
)	O
;	O
bref	pointer
->	O
maxmatch	long
=	O
n	long
;	O
}	O
rc	int
=	O
regexec	O
(	O
rx	struct
,	O
subj	pointer
,	O
bref	pointer
->	O
maxmatch	long
,	O
bref	pointer
->	O
match	pointer
,	O
0	int
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
free	function
(	O
bref	pointer
->	O
subject	pointer
)	O
;	O
bref	pointer
->	O
subject	pointer
=	O
xstrdup	function
(	O
subj	pointer
)	O
;	O
bref	pointer
->	O
nmatch	long
=	O
n	long
;	O
req	pointer
->	O
backref_cur	int
=	O
!	O
req	pointer
->	O
backref_cur	int
;	O
}	O
return	O
rc	int
;	O
}	O
static	O
rush_bool_t	enum
eval_cmps	function
(	O
struct	O
test_node	struct
*	O
node	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
rush_request	struct
*	O
req	pointer
)	O
{	O
char	O
*	O
str	pointer
=	O
rush_expand_string	function
(	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
larg	pointer
,	O
req	pointer
)	O
;	O
rush_bool_t	enum
res	enum
=	O
rush_false	int
;	O
switch	O
(	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
op	enum
)	O
{	O
case	O
cmp_eq	int
:	O
res	enum
=	O
strcmp	function
(	O
str	pointer
,	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
rarg	union
.	O
str	pointer
)	O
==	O
0	int
;	O
break	O
;	O
case	O
cmp_ne	int
:	O
res	enum
=	O
strcmp	function
(	O
str	pointer
,	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
rarg	union
.	O
str	pointer
)	O
!=	O
0	int
;	O
break	O
;	O
case	O
cmp_match	int
:	O
res	enum
=	O
!	O
eval_regex	function
(	O
req	pointer
,	O
&	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
rarg	union
.	O
rx	struct
,	O
str	pointer
)	O
;	O
break	O
;	O
default	O
:	O
die	function
(	O
system_error	int
,	O
NULL	O
,	O
_	O
(	O
"INTERNAL ERROR at %s:%d: unrecognized opcode %d"	pointer
)	O
,	O
__FILE__	O
,	O
__LINE__	O
,	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
op	enum
)	O
;	O
}	O
free	function
(	O
str	pointer
)	O
;	O
return	O
res	enum
;	O
}	O
static	O
rush_bool_t	enum
eval_in	function
(	O
struct	O
test_node	struct
*	O
node	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
rush_request	struct
*	O
req	pointer
)	O
{	O
size_t	long
i	int
;	O
rush_bool_t	enum
res	enum
=	O
rush_false	int
;	O
char	O
*	O
str	pointer
=	O
rush_expand_string	function
(	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
larg	pointer
,	O
req	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
rarg	union
.	O
strv	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
node	pointer
->	O
v	union
.	O
cmp	struct
.	O
rarg	union
.	O
strv	pointer
[	O
i	int
]	O
)	O
==	O
0	int
)	O
{	O
res	enum
=	O
rush_true	int
;	O
break	O
;	O
}	O
free	function
(	O
str	pointer
)	O
;	O
return	O
res	enum
;	O
}	O
static	O
rush_bool_t	enum
groupmember	function
(	O
char	O
const	O
*	O
gname	pointer
,	O
struct	O
passwd	struct
const	O
*	O
pw	pointer
)	O
{	O
struct	O
group	struct
*	O
grp	pointer
=	O
getgrnam	function
(	O
gname	pointer
)	O
;	O
if	O
(	O
grp	pointer
)	O
{	O
char	O
*	O
*	O
p	pointer
;	O
if	O
(	O
pw	pointer
->	O
pw_gid	int
==	O
grp	pointer
->	O
gr_gid	int
)	O
return	O
rush_true	int
;	O
for	O
(	O
p	pointer
=	O
grp	pointer
->	O
gr_mem	pointer
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
*	O
p	pointer
,	O
pw	pointer
->	O
pw_name	pointer
)	O
==	O
0	int
)	O
return	O
rush_true	int
;	O
}	O
}	O
return	O
rush_false	int
;	O
}	O
static	O
rush_bool_t	enum
eval_member	function
(	O
struct	O
test_node	struct
*	O
node	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
rush_request	struct
*	O
req	pointer
)	O
{	O
size_t	long
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
node	pointer
->	O
v	union
.	O
groups	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
groupmember	function
(	O
node	pointer
->	O
v	union
.	O
groups	pointer
[	O
i	int
]	O
,	O
req	pointer
->	O
pw	pointer
)	O
)	O
return	O
rush_true	int
;	O
}	O
return	O
rush_false	int
;	O
}	O
rush_bool_t	enum
test_eval	function
(	O
struct	O
test_node	struct
*	O
node	pointer
,	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
rush_request	struct
*	O
req	pointer
)	O
{	O
switch	O
(	O
node	pointer
->	O
type	enum
)	O
{	O
case	O
test_cmpn	int
:	O
return	O
eval_cmpn	function
(	O
node	pointer
,	O
rule	pointer
,	O
req	pointer
)	O
;	O
case	O
test_cmps	int
:	O
return	O
eval_cmps	function
(	O
node	pointer
,	O
rule	pointer
,	O
req	pointer
)	O
;	O
case	O
test_in	int
:	O
return	O
eval_in	function
(	O
node	pointer
,	O
rule	pointer
,	O
req	pointer
)	O
;	O
case	O
test_group	int
:	O
return	O
eval_member	function
(	O
node	pointer
,	O
rule	pointer
,	O
req	pointer
)	O
;	O
case	O
test_and	int
:	O
if	O
(	O
!	O
test_eval	function
(	O
node	pointer
->	O
v	union
.	O
arg	struct
[	O
0	int
]	O
,	O
rule	pointer
,	O
req	pointer
)	O
)	O
return	O
0	int
;	O
return	O
test_eval	function
(	O
node	pointer
->	O
v	union
.	O
arg	struct
[	O
1	int
]	O
,	O
rule	pointer
,	O
req	pointer
)	O
;	O
case	O
test_or	int
:	O
if	O
(	O
test_eval	function
(	O
node	pointer
->	O
v	union
.	O
arg	struct
[	O
0	int
]	O
,	O
rule	pointer
,	O
req	pointer
)	O
)	O
return	O
1	int
;	O
return	O
test_eval	function
(	O
node	pointer
->	O
v	union
.	O
arg	struct
[	O
1	int
]	O
,	O
rule	pointer
,	O
req	pointer
)	O
;	O
case	O
test_not	int
:	O
return	O
!	O
test_eval	function
(	O
node	pointer
->	O
v	union
.	O
arg	struct
[	O
0	int
]	O
,	O
rule	pointer
,	O
req	pointer
)	O
;	O
default	O
:	O
die	function
(	O
system_error	int
,	O
NULL	O
,	O
_	O
(	O
"INTERNAL ERROR at %s:%d: unrecognized node type %d"	pointer
)	O
,	O
__FILE__	O
,	O
__LINE__	O
,	O
node	pointer
->	O
type	enum
)	O
;	O
}	O
}	O
char	O
*	O
make_file_name	function
(	O
const	O
char	O
*	O
dir	enum
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
size_t	long
dlen	long
=	O
strlen	function
(	O
dir	enum
)	O
;	O
size_t	long
len	long
=	O
dlen	long
+	O
strlen	function
(	O
name	pointer
)	O
+	O
1	int
;	O
char	O
*	O
res	enum
=	O
xmalloc	function
(	O
len	long
+	O
1	int
)	O
;	O
strcpy	function
(	O
res	enum
,	O
dir	enum
)	O
;	O
if	O
(	O
dlen	long
>	O
0	int
&&	O
res	enum
[	O
dlen	long
-	O
1	int
]	O
!=	O
'/'	O
)	O
res	enum
[	O
dlen	long
++	O
]	O
=	O
'/'	O
;	O
strcpy	function
(	O
res	enum
+	O
dlen	long
,	O
name	pointer
)	O
;	O
return	O
res	enum
;	O
}	O
char	O
*	O
expand_tilde	function
(	O
const	O
char	O
*	O
dir	enum
,	O
const	O
char	O
*	O
home	pointer
)	O
{	O
char	O
*	O
res	enum
;	O
if	O
(	O
dir	enum
[	O
0	int
]	O
==	O
'~'	O
)	O
{	O
if	O
(	O
dir	enum
[	O
1	int
]	O
==	O
'/'	O
)	O
{	O
size_t	long
hlen	long
=	O
strlen	function
(	O
home	pointer
)	O
;	O
size_t	long
len	long
=	O
hlen	long
+	O
strlen	function
(	O
dir	enum
+	O
1	int
)	O
;	O
res	enum
=	O
xmalloc	function
(	O
len	long
+	O
1	int
)	O
;	O
strcpy	function
(	O
res	enum
,	O
home	pointer
)	O
;	O
if	O
(	O
hlen	long
>	O
0	int
&&	O
res	enum
[	O
hlen	long
-	O
1	int
]	O
!=	O
'/'	O
)	O
res	enum
[	O
hlen	long
++	O
]	O
=	O
'/'	O
;	O
strcpy	function
(	O
res	enum
+	O
hlen	long
,	O
dir	enum
+	O
2	int
)	O
;	O
}	O
else	O
res	enum
=	O
xstrdup	function
(	O
home	pointer
)	O
;	O
}	O
else	O
res	enum
=	O
xstrdup	function
(	O
dir	enum
)	O
;	O
return	O
res	enum
;	O
}	O
char	O
*	O
expand_dir	function
(	O
const	O
char	O
*	O
dir	enum
,	O
struct	O
rush_request	struct
*	O
req	pointer
)	O
{	O
char	O
*	O
exp	pointer
=	O
rush_expand_string	function
(	O
dir	enum
,	O
req	pointer
)	O
;	O
if	O
(	O
exp	pointer
[	O
0	int
]	O
==	O
'~'	O
)	O
{	O
char	O
*	O
t	pointer
=	O
expand_tilde	function
(	O
exp	pointer
,	O
req	pointer
->	O
pw	pointer
->	O
pw_dir	pointer
)	O
;	O
free	function
(	O
exp	pointer
)	O
;	O
exp	pointer
=	O
t	pointer
;	O
}	O
return	O
exp	pointer
;	O
}	O
void	O
request_set_env	function
(	O
struct	O
rush_request	struct
*	O
req	pointer
)	O
{	O
size_t	long
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
environ	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
;	O
req	pointer
->	O
env_count	long
=	O
i	int
;	O
req	pointer
->	O
env_max	long
=	O
i	int
+	O
1	int
;	O
req	pointer
->	O
env	pointer
=	O
xcalloc	function
(	O
req	pointer
->	O
env_max	long
,	O
sizeof	O
(	O
req	pointer
->	O
env	pointer
[	O
0	int
]	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
req	pointer
->	O
env_count	long
;	O
i	int
++	O
)	O
req	pointer
->	O
env	pointer
[	O
i	int
]	O
=	O
xstrdup	function
(	O
environ	pointer
[	O
i	int
]	O
)	O
;	O
req	pointer
->	O
env	pointer
[	O
i	int
]	O
=	O
NULL	O
;	O
}	O
static	O
ssize_t	long
getenvind	function
(	O
struct	O
rush_request	struct
*	O
req	pointer
,	O
char	O
const	O
*	O
name	pointer
,	O
char	O
*	O
*	O
pval	pointer
)	O
{	O
size_t	long
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
req	pointer
->	O
env_count	long
;	O
i	int
++	O
)	O
{	O
char	O
const	O
*	O
p	pointer
;	O
char	O
*	O
q	pointer
;	O
for	O
(	O
p	pointer
=	O
name	pointer
,	O
q	pointer
=	O
req	pointer
->	O
env	pointer
[	O
i	int
]	O
;	O
*	O
p	pointer
==	O
*	O
q	pointer
;	O
p	pointer
++	O
,	O
q	pointer
++	O
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
0	int
&&	O
*	O
q	pointer
==	O
'='	O
)	O
{	O
if	O
(	O
pval	pointer
)	O
*	O
pval	pointer
=	O
q	pointer
+	O
1	int
;	O
return	O
i	int
;	O
}	O
}	O
return	O
-	O
1	int
;	O
}	O
static	O
enum	O
rush_three_state	enum
envarmatch	function
(	O
struct	O
envar	struct
*	O
ev	pointer
,	O
char	O
const	O
*	O
var	pointer
,	O
int	O
len	long
)	O
{	O
if	O
(	O
ev	pointer
->	O
value	pointer
)	O
{	O
if	O
(	O
strncmp	function
(	O
ev	pointer
->	O
name	pointer
,	O
var	pointer
,	O
len	long
)	O
==	O
0	int
)	O
{	O
return	O
strcmp	function
(	O
var	pointer
+	O
len	long
+	O
1	int
,	O
ev	pointer
->	O
value	pointer
)	O
==	O
0	int
?	O
rush_true	int
:	O
rush_false	int
;	O
}	O
}	O
else	O
if	O
(	O
wildmatch	function
(	O
ev	pointer
->	O
name	pointer
,	O
var	pointer
,	O
len	long
)	O
==	O
0	int
)	O
{	O
return	O
rush_true	int
;	O
}	O
return	O
rush_undefined	int
;	O
}	O
static	O
rush_bool_t	enum
keep_envar	function
(	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
char	O
const	O
*	O
var	pointer
)	O
{	O
struct	O
envar	struct
*	O
ev	pointer
;	O
int	O
len	long
=	O
strcspn	function
(	O
var	pointer
,	O
"="	pointer
)	O
;	O
for	O
(	O
ev	pointer
=	O
rule	pointer
->	O
envar_head	pointer
;	O
ev	pointer
;	O
ev	pointer
=	O
ev	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
ev	pointer
->	O
type	enum
==	O
envar_keep	int
)	O
{	O
enum	O
rush_three_state	enum
res	enum
=	O
envarmatch	function
(	O
ev	pointer
,	O
var	pointer
,	O
len	long
)	O
;	O
switch	O
(	O
res	enum
)	O
{	O
case	O
rush_true	int
:	O
case	O
rush_false	int
:	O
return	O
res	enum
;	O
case	O
rush_undefined	int
:	O
break	O
;	O
}	O
}	O
}	O
return	O
rush_false	int
;	O
}	O
static	O
void	O
unset_envar	function
(	O
struct	O
rush_request	struct
*	O
req	pointer
,	O
struct	O
envar	struct
*	O
ev	pointer
)	O
{	O
size_t	long
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
req	pointer
->	O
env_count	long
;	O
)	O
{	O
int	O
len	long
=	O
strcspn	function
(	O
req	pointer
->	O
env	pointer
[	O
i	int
]	O
,	O
"="	pointer
)	O
;	O
if	O
(	O
envarmatch	function
(	O
ev	pointer
,	O
req	pointer
->	O
env	pointer
[	O
i	int
]	O
,	O
len	long
)	O
==	O
rush_true	int
)	O
{	O
free	function
(	O
req	pointer
->	O
env	pointer
[	O
i	int
]	O
)	O
;	O
memmove	function
(	O
req	pointer
->	O
env	pointer
+	O
i	int
,	O
req	pointer
->	O
env	pointer
+	O
i	int
+	O
1	int
,	O
(	O
req	pointer
->	O
env_count	long
-	O
i	int
)	O
*	O
sizeof	O
(	O
req	pointer
->	O
env	pointer
[	O
0	int
]	O
)	O
)	O
;	O
req	pointer
->	O
env_count	long
--	O
;	O
}	O
else	O
i	int
++	O
;	O
}	O
}	O
static	O
void	O
env_setup	function
(	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
rush_request	struct
*	O
req	pointer
)	O
{	O
struct	O
envar	struct
*	O
ev	pointer
;	O
size_t	long
i	int
;	O
if	O
(	O
rule	pointer
->	O
clrenv	int
)	O
{	O
size_t	long
keep_count	long
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
req	pointer
->	O
env_count	long
;	O
i	int
++	O
)	O
{	O
if	O
(	O
keep_envar	function
(	O
rule	pointer
,	O
req	pointer
->	O
env	pointer
[	O
i	int
]	O
)	O
)	O
{	O
if	O
(	O
i	int
>	O
keep_count	long
)	O
{	O
req	pointer
->	O
env	pointer
[	O
keep_count	long
]	O
=	O
req	pointer
->	O
env	pointer
[	O
i	int
]	O
;	O
req	pointer
->	O
env	pointer
[	O
i	int
]	O
=	O
NULL	O
;	O
}	O
keep_count	long
++	O
;	O
}	O
else	O
{	O
free	function
(	O
req	pointer
->	O
env	pointer
[	O
i	int
]	O
)	O
;	O
req	pointer
->	O
env	pointer
[	O
i	int
]	O
=	O
NULL	O
;	O
}	O
}	O
req	pointer
->	O
env_count	long
=	O
keep_count	long
;	O
}	O
for	O
(	O
ev	pointer
=	O
rule	pointer
->	O
envar_head	pointer
;	O
ev	pointer
;	O
ev	pointer
=	O
ev	pointer
->	O
next	pointer
)	O
{	O
char	O
*	O
val	array
;	O
ssize_t	long
n	long
;	O
size_t	long
len	long
;	O
switch	O
(	O
ev	pointer
->	O
type	enum
)	O
{	O
case	O
envar_keep	int
:	O
break	O
;	O
case	O
envar_unset	int
:	O
unset_envar	function
(	O
req	pointer
,	O
ev	pointer
)	O
;	O
break	O
;	O
case	O
envar_set	int
:	O
val	array
=	O
rush_expand_string	function
(	O
ev	pointer
->	O
value	pointer
,	O
req	pointer
)	O
;	O
n	long
=	O
getenvind	function
(	O
req	pointer
,	O
ev	pointer
->	O
name	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
n	long
==	O
-	O
1	int
)	O
{	O
if	O
(	O
req	pointer
->	O
env_count	long
+	O
1	int
>=	O
req	pointer
->	O
env_max	long
)	O
req	pointer
->	O
env	pointer
=	O
x2nrealloc	function
(	O
req	pointer
->	O
env	pointer
,	O
&	O
req	pointer
->	O
env_max	long
,	O
sizeof	O
(	O
req	pointer
->	O
env	pointer
[	O
0	int
]	O
)	O
)	O
;	O
n	long
=	O
req	pointer
->	O
env_count	long
++	O
;	O
req	pointer
->	O
env	pointer
[	O
req	pointer
->	O
env_count	long
]	O
=	O
NULL	O
;	O
}	O
free	function
(	O
req	pointer
->	O
env	pointer
[	O
n	long
]	O
)	O
;	O
len	long
=	O
strlen	function
(	O
ev	pointer
->	O
name	pointer
)	O
+	O
strlen	function
(	O
val	array
)	O
+	O
2	int
;	O
req	pointer
->	O
env	pointer
[	O
n	long
]	O
=	O
xmalloc	function
(	O
len	long
)	O
;	O
strcat	function
(	O
strcat	function
(	O
strcpy	function
(	O
req	pointer
->	O
env	pointer
[	O
n	long
]	O
,	O
ev	pointer
->	O
name	pointer
)	O
,	O
"="	pointer
)	O
,	O
val	array
)	O
;	O
free	function
(	O
val	array
)	O
;	O
break	O
;	O
case	O
envar_eval	int
:	O
free	function
(	O
rush_expand_string	function
(	O
ev	pointer
->	O
value	pointer
,	O
req	pointer
)	O
)	O
;	O
break	O
;	O
default	O
:	O
die	function
(	O
system_error	int
,	O
NULL	O
,	O
_	O
(	O
"INTERNAL ERROR at %s:%d: invalid envar type %d"	pointer
)	O
,	O
__FILE__	O
,	O
__LINE__	O
,	O
ev	pointer
->	O
type	enum
)	O
;	O
}	O
}	O
if	O
(	O
__debug_p	O
(	O
2	int
)	O
)	O
{	O
logmsg	function
(	O
LOG_DEBUG	int
,	O
_	O
(	O
"Final environment:"	pointer
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
req	pointer
->	O
env	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
logmsg	function
(	O
LOG_DEBUG	int
,	O
"%4zu: %s"	pointer
,	O
i	int
,	O
req	pointer
->	O
env	pointer
[	O
i	int
]	O
)	O
;	O
}	O
}	O
static	O
void	O
reparse_cmdline	function
(	O
struct	O
rush_request	struct
*	O
req	pointer
)	O
{	O
struct	O
wordsplit	struct
ws	pointer
;	O
argcv_free	function
(	O
req	pointer
->	O
argc	int
,	O
req	pointer
->	O
argv	pointer
)	O
;	O
ws	pointer
.	O
ws_options	int
=	O
WRDSO_NOVARSPLIT	int
|	O
WRDSO_NOCMDSPLIT	int
;	O
if	O
(	O
wordsplit	struct
(	O
req	pointer
->	O
cmdline	pointer
,	O
&	O
ws	pointer
,	O
WRDSF_DEFFLAGS	O
|	O
WRDSF_OPTIONS	int
)	O
)	O
die	function
(	O
system_error	int
,	O
&	O
req	pointer
->	O
i18n	struct
,	O
_	O
(	O
"wordsplit(%s) failed: %s"	pointer
)	O
,	O
req	pointer
->	O
cmdline	pointer
,	O
wordsplit_strerror	function
(	O
&	O
ws	pointer
)	O
)	O
;	O
wordsplit_get_words	function
(	O
&	O
ws	pointer
,	O
&	O
req	pointer
->	O
argc	int
,	O
&	O
req	pointer
->	O
argv	pointer
)	O
;	O
wordsplit_free	function
(	O
&	O
ws	pointer
)	O
;	O
free	function
(	O
req	pointer
->	O
prog	pointer
)	O
;	O
req	pointer
->	O
prog	pointer
=	O
NULL	O
;	O
}	O
static	O
void	O
rebuild_cmdline	function
(	O
struct	O
rush_request	struct
*	O
req	pointer
)	O
{	O
free	function
(	O
req	pointer
->	O
cmdline	pointer
)	O
;	O
req	pointer
->	O
cmdline	pointer
=	O
argcv_string	function
(	O
req	pointer
->	O
argc	int
,	O
req	pointer
->	O
argv	pointer
)	O
;	O
}	O
static	O
int	O
get_arg_no	function
(	O
int	O
index	function
,	O
struct	O
rush_request	struct
*	O
req	pointer
)	O
{	O
int	O
arg_no	int
=	O
ARG_NO	O
(	O
index	function
,	O
req	pointer
->	O
argc	int
)	O
;	O
if	O
(	O
arg_no	int
<	O
0	int
||	O
arg_no	int
>	O
req	pointer
->	O
argc	int
)	O
die	function
(	O
config_error	int
,	O
&	O
req	pointer
->	O
i18n	struct
,	O
_	O
(	O
"no argument at index %d in command: %s"	pointer
)	O
,	O
index	function
,	O
req	pointer
->	O
cmdline	pointer
)	O
;	O
return	O
arg_no	int
;	O
}	O
static	O
int	O
remove_optarg	function
(	O
struct	O
rush_request	struct
*	O
req	pointer
,	O
struct	O
option_defn	struct
*	O
opt	pointer
,	O
size_t	long
n	long
,	O
char	O
*	O
tail	pointer
)	O
{	O
size_t	long
c	int
;	O
if	O
(	O
opt	pointer
->	O
s_opt	pointer
[	O
1	int
]	O
==	O
':'	O
)	O
{	O
if	O
(	O
*	O
tail	pointer
)	O
c	int
=	O
1	int
;	O
else	O
if	O
(	O
opt	pointer
->	O
s_opt	pointer
[	O
2	int
]	O
==	O
':'	O
)	O
c	int
=	O
1	int
;	O
else	O
c	int
=	O
2	int
;	O
}	O
else	O
c	int
=	O
1	int
;	O
if	O
(	O
n	long
+	O
c	int
<	O
req	pointer
->	O
argc	int
)	O
{	O
memmove	function
(	O
&	O
req	pointer
->	O
argv	pointer
[	O
n	long
]	O
,	O
&	O
req	pointer
->	O
argv	pointer
[	O
n	long
+	O
c	int
]	O
,	O
(	O
req	pointer
->	O
argc	int
-	O
n	long
+	O
1	int
-	O
c	int
)	O
*	O
sizeof	O
req	pointer
->	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
req	pointer
->	O
argc	int
-=	O
c	int
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
remove_option	function
(	O
struct	O
rush_request	struct
*	O
req	pointer
,	O
struct	O
option_defn	struct
*	O
opt	pointer
)	O
{	O
size_t	long
i	int
;	O
size_t	long
l_len	long
=	O
opt	pointer
->	O
l_opt	pointer
?	O
strlen	function
(	O
opt	pointer
->	O
l_opt	pointer
)	O
:	O
0	int
;	O
int	O
mod	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
req	pointer
->	O
argc	int
;	O
i	int
++	O
)	O
{	O
char	O
*	O
arg	struct
=	O
req	pointer
->	O
argv	pointer
[	O
i	int
]	O
;	O
if	O
(	O
*	O
arg	struct
==	O
'-'	O
)	O
{	O
char	O
*	O
p	pointer
;	O
++	O
arg	struct
;	O
if	O
(	O
*	O
arg	struct
==	O
'-'	O
)	O
{	O
size_t	long
a_len	long
;	O
++	O
arg	struct
;	O
if	O
(	O
*	O
arg	struct
==	O
0	int
)	O
break	O
;	O
if	O
(	O
opt	pointer
->	O
l_opt	pointer
==	O
NULL	O
)	O
continue	O
;	O
a_len	long
=	O
strcspn	function
(	O
arg	struct
,	O
"="	pointer
)	O
;	O
if	O
(	O
l_len	long
<	O
a_len	long
)	O
continue	O
;	O
if	O
(	O
arg	struct
[	O
a_len	long
]	O
==	O
'='	O
&&	O
opt	pointer
->	O
s_opt	pointer
[	O
1	int
]	O
!=	O
':'	O
)	O
continue	O
;	O
if	O
(	O
memcmp	function
(	O
arg	struct
,	O
opt	pointer
->	O
l_opt	pointer
,	O
a_len	long
)	O
)	O
continue	O
;	O
p	pointer
=	O
arg	struct
+	O
a_len	long
;	O
}	O
else	O
if	O
(	O
(	O
p	pointer
=	O
strchr	function
(	O
arg	struct
,	O
opt	pointer
->	O
s_opt	pointer
[	O
0	int
]	O
)	O
)	O
)	O
{	O
if	O
(	O
opt	pointer
->	O
s_opt	pointer
[	O
1	int
]	O
==	O
0	int
)	O
{	O
memmove	function
(	O
p	pointer
,	O
p	pointer
+	O
1	int
,	O
strlen	function
(	O
p	pointer
+	O
1	int
)	O
+	O
1	int
)	O
;	O
if	O
(	O
*	O
arg	struct
)	O
{	O
continue	O
;	O
}	O
}	O
else	O
if	O
(	O
p	pointer
>	O
arg	struct
)	O
{	O
if	O
(	O
p	pointer
[	O
1	int
]	O
||	O
opt	pointer
->	O
s_opt	pointer
[	O
2	int
]	O
==	O
':'	O
)	O
*	O
p	pointer
=	O
0	int
;	O
continue	O
;	O
}	O
}	O
else	O
{	O
continue	O
;	O
}	O
if	O
(	O
remove_optarg	function
(	O
req	pointer
,	O
opt	pointer
,	O
i	int
,	O
p	pointer
+	O
1	int
)	O
)	O
{	O
i	int
--	O
;	O
mod	int
=	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
mod	int
)	O
rebuild_cmdline	function
(	O
req	pointer
)	O
;	O
}	O
static	O
void	O
rush_transform	function
(	O
struct	O
transform_node	struct
*	O
node	pointer
,	O
struct	O
rush_request	struct
*	O
req	pointer
)	O
{	O
char	O
*	O
*	O
target_ptr	pointer
;	O
char	O
*	O
target_src	pointer
;	O
char	O
*	O
newval	pointer
=	O
NULL	O
;	O
int	O
arg_no	int
;	O
void	O
(	O
*	O
postprocess	pointer
)	O
(	O
struct	O
rush_request	struct
*	O
)	O
=	O
NULL	O
;	O
if	O
(	O
node	pointer
->	O
type	enum
==	O
transform_remopt	int
)	O
{	O
debug	O
(	O
2	int
,	O
_	O
(	O
"Removing option %s %s"	pointer
)	O
,	O
node	pointer
->	O
v	union
.	O
remopt	struct
.	O
s_opt	pointer
,	O
node	pointer
->	O
v	union
.	O
remopt	struct
.	O
l_opt	pointer
?	O
node	pointer
->	O
v	union
.	O
remopt	struct
.	O
l_opt	pointer
:	O
"(null)"	pointer
)	O
;	O
remove_option	function
(	O
req	pointer
,	O
&	O
node	pointer
->	O
v	union
.	O
remopt	struct
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
node	pointer
->	O
target	struct
.	O
type	enum
)	O
{	O
case	O
target_command	int
:	O
target_ptr	pointer
=	O
&	O
req	pointer
->	O
cmdline	pointer
;	O
target_src	pointer
=	O
req	pointer
->	O
cmdline	pointer
;	O
postprocess	pointer
=	O
reparse_cmdline	function
;	O
debug	O
(	O
2	int
,	O
"%s"	pointer
,	O
_	O
(	O
"Transforming command line"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
target_program	int
:	O
target_ptr	pointer
=	O
&	O
req	pointer
->	O
prog	pointer
;	O
target_src	pointer
=	O
PROGFILE	O
(	O
req	pointer
)	O
;	O
debug	O
(	O
2	int
,	O
_	O
(	O
"Transforming program name (%s)"	pointer
)	O
,	O
target_src	pointer
)	O
;	O
break	O
;	O
case	O
target_arg	int
:	O
arg_no	int
=	O
get_arg_no	function
(	O
node	pointer
->	O
target	struct
.	O
v	union
.	O
arg	struct
.	O
idx	int
,	O
req	pointer
)	O
;	O
if	O
(	O
arg_no	int
==	O
req	pointer
->	O
argc	int
||	O
node	pointer
->	O
target	struct
.	O
v	union
.	O
arg	struct
.	O
ins	int
)	O
{	O
req	pointer
->	O
argv	pointer
=	O
xrealloc	function
(	O
req	pointer
->	O
argv	pointer
,	O
(	O
req	pointer
->	O
argc	int
+	O
2	int
)	O
*	O
sizeof	O
(	O
req	pointer
->	O
argv	pointer
[	O
0	int
]	O
)	O
)	O
;	O
req	pointer
->	O
argc	int
++	O
;	O
memmove	function
(	O
&	O
req	pointer
->	O
argv	pointer
[	O
arg_no	int
+	O
1	int
]	O
,	O
&	O
req	pointer
->	O
argv	pointer
[	O
arg_no	int
]	O
,	O
(	O
req	pointer
->	O
argc	int
-	O
arg_no	int
)	O
*	O
sizeof	O
req	pointer
->	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
req	pointer
->	O
argv	pointer
[	O
arg_no	int
]	O
=	O
NULL	O
;	O
}	O
target_ptr	pointer
=	O
&	O
req	pointer
->	O
argv	pointer
[	O
arg_no	int
]	O
;	O
target_src	pointer
=	O
req	pointer
->	O
argv	pointer
[	O
arg_no	int
]	O
;	O
postprocess	pointer
=	O
rebuild_cmdline	function
;	O
debug	O
(	O
2	int
,	O
_	O
(	O
"Transforming argv[%d]"	pointer
)	O
,	O
arg_no	int
)	O
;	O
break	O
;	O
case	O
target_var	int
:	O
target_ptr	pointer
=	O
rush_getvarptr	function
(	O
req	pointer
,	O
node	pointer
->	O
target	struct
.	O
v	union
.	O
name	pointer
)	O
;	O
target_src	pointer
=	O
*	O
target_ptr	pointer
;	O
debug	O
(	O
2	int
,	O
_	O
(	O
"Transforming variable %s=%s"	pointer
)	O
,	O
node	pointer
->	O
target	struct
.	O
v	union
.	O
name	pointer
,	O
target_src	pointer
?	O
target_src	pointer
:	O
"(null)"	pointer
)	O
;	O
break	O
;	O
case	O
target_env	int
:	O
die	function
(	O
system_error	int
,	O
NULL	O
,	O
_	O
(	O
"environment transformation is not yet implemented"	pointer
)	O
)	O
;	O
case	O
target_readonly	int
:	O
die	function
(	O
system_error	int
,	O
NULL	O
,	O
_	O
(	O
"INTERNAL ERROR at %s:%d: can't modify read-only target"	pointer
)	O
,	O
__FILE__	O
,	O
__LINE__	O
)	O
;	O
}	O
switch	O
(	O
node	pointer
->	O
type	enum
)	O
{	O
case	O
transform_set	int
:	O
if	O
(	O
node	pointer
->	O
v	union
.	O
xf	struct
.	O
pattern	pointer
)	O
{	O
newval	pointer
=	O
rush_expand_string	function
(	O
node	pointer
->	O
v	union
.	O
xf	struct
.	O
pattern	pointer
,	O
req	pointer
)	O
;	O
target_src	pointer
=	O
newval	pointer
;	O
}	O
if	O
(	O
node	pointer
->	O
v	union
.	O
xf	struct
.	O
trans	pointer
)	O
{	O
char	O
*	O
p	pointer
=	O
transform_string	function
(	O
node	pointer
->	O
v	union
.	O
xf	struct
.	O
trans	pointer
,	O
target_src	pointer
)	O
;	O
free	function
(	O
newval	pointer
)	O
;	O
newval	pointer
=	O
p	pointer
;	O
}	O
break	O
;	O
case	O
transform_map	int
:	O
debug	O
(	O
2	int
,	O
_	O
(	O
"Transformation map: %s, %s, %s, %u, %u, %s"	pointer
)	O
,	O
node	pointer
->	O
v	union
.	O
map	struct
.	O
file	pointer
,	O
node	pointer
->	O
v	union
.	O
map	struct
.	O
delim	pointer
,	O
node	pointer
->	O
v	union
.	O
map	struct
.	O
key	pointer
,	O
node	pointer
->	O
v	union
.	O
map	struct
.	O
key_field	int
,	O
node	pointer
->	O
v	union
.	O
map	struct
.	O
val_field	int
,	O
node	pointer
->	O
v	union
.	O
map	struct
.	O
defval	pointer
)	O
;	O
newval	pointer
=	O
map_string	function
(	O
&	O
node	pointer
->	O
v	union
.	O
map	struct
,	O
req	pointer
)	O
;	O
if	O
(	O
!	O
newval	pointer
)	O
return	O
;	O
break	O
;	O
default	O
:	O
die	function
(	O
system_error	int
,	O
NULL	O
,	O
_	O
(	O
"INTERNAL ERROR at %s:%d: invalid node type %d"	pointer
)	O
,	O
__FILE__	O
,	O
__LINE__	O
,	O
node	pointer
->	O
type	enum
)	O
;	O
break	O
;	O
}	O
free	function
(	O
*	O
target_ptr	pointer
)	O
;	O
*	O
target_ptr	pointer
=	O
newval	pointer
;	O
if	O
(	O
postprocess	pointer
)	O
postprocess	pointer
(	O
req	pointer
)	O
;	O
}	O
static	O
void	O
rush_transform_delete	function
(	O
struct	O
transform_node	struct
*	O
node	pointer
,	O
struct	O
rush_request	struct
*	O
req	pointer
)	O
{	O
int	O
arg_no	int
,	O
arg_end	int
,	O
i	int
;	O
switch	O
(	O
node	pointer
->	O
target	struct
.	O
type	enum
)	O
{	O
case	O
target_arg	int
:	O
arg_no	int
=	O
get_arg_no	function
(	O
node	pointer
->	O
target	struct
.	O
v	union
.	O
arg	struct
.	O
idx	int
,	O
req	pointer
)	O
;	O
arg_end	int
=	O
get_arg_no	function
(	O
node	pointer
->	O
v	union
.	O
arg_end	int
,	O
req	pointer
)	O
;	O
if	O
(	O
arg_end	int
<	O
arg_no	int
)	O
{	O
int	O
x	int
=	O
arg_end	int
;	O
arg_end	int
=	O
arg_no	int
;	O
arg_no	int
=	O
x	int
;	O
}	O
debug	O
(	O
2	int
,	O
_	O
(	O
"Deleting arguments %d-%d"	pointer
)	O
,	O
arg_no	int
,	O
arg_end	int
)	O
;	O
if	O
(	O
arg_no	int
==	O
0	int
||	O
arg_end	int
==	O
0	int
)	O
die	function
(	O
config_error	int
,	O
&	O
req	pointer
->	O
i18n	struct
,	O
_	O
(	O
"Deleting argv[0] is prohibited"	pointer
)	O
)	O
;	O
for	O
(	O
i	int
=	O
arg_no	int
;	O
i	int
<=	O
arg_end	int
;	O
i	int
++	O
)	O
free	function
(	O
req	pointer
->	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
i	int
=	O
arg_end	int
-	O
arg_no	int
+	O
1	int
;	O
memmove	function
(	O
req	pointer
->	O
argv	pointer
+	O
arg_no	int
,	O
req	pointer
->	O
argv	pointer
+	O
arg_end	int
+	O
1	int
,	O
(	O
req	pointer
->	O
argc	int
-	O
i	int
)	O
*	O
sizeof	O
(	O
req	pointer
->	O
argv	pointer
[	O
0	int
]	O
)	O
)	O
;	O
req	pointer
->	O
argc	int
-=	O
i	int
;	O
rebuild_cmdline	function
(	O
req	pointer
)	O
;	O
break	O
;	O
case	O
target_var	int
:	O
rush_request_delvar	function
(	O
req	pointer
,	O
node	pointer
->	O
target	struct
.	O
v	union
.	O
name	pointer
)	O
;	O
break	O
;	O
case	O
target_env	int
:	O
die	function
(	O
system_error	int
,	O
NULL	O
,	O
_	O
(	O
"environment transformation is not yet implemented"	pointer
)	O
)	O
;	O
default	O
:	O
die	function
(	O
system_error	int
,	O
NULL	O
,	O
_	O
(	O
"INTERNAL ERROR at %s:%d: invalid target type %d"	pointer
)	O
,	O
__FILE__	O
,	O
__LINE__	O
,	O
node	pointer
->	O
type	enum
)	O
;	O
}	O
}	O
static	O
void	O
run_transforms	function
(	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
rush_request	struct
*	O
req	pointer
)	O
{	O
struct	O
transform_node	struct
*	O
node	pointer
;	O
for	O
(	O
node	pointer
=	O
rule	pointer
->	O
transform_head	pointer
;	O
node	pointer
;	O
node	pointer
=	O
node	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
node	pointer
->	O
type	enum
==	O
transform_delete	int
)	O
rush_transform_delete	function
(	O
node	pointer
,	O
req	pointer
)	O
;	O
else	O
rush_transform	function
(	O
node	pointer
,	O
req	pointer
)	O
;	O
}	O
if	O
(	O
__debug_p	O
(	O
2	int
)	O
)	O
{	O
int	O
i	int
;	O
logmsg	function
(	O
LOG_DEBUG	int
,	O
_	O
(	O
"Program name: %s"	pointer
)	O
,	O
PROGFILE	O
(	O
req	pointer
)	O
)	O
;	O
logmsg	function
(	O
LOG_DEBUG	int
,	O
_	O
(	O
"Final arguments:"	pointer
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
req	pointer
->	O
argc	int
;	O
i	int
++	O
)	O
logmsg	function
(	O
LOG_DEBUG	int
,	O
"% 4d: %s"	pointer
,	O
i	int
,	O
req	pointer
->	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
}	O
}	O
static	O
void	O
acct_on	function
(	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
rush_request	struct
*	O
req	pointer
,	O
pid_t	int
pid	int
)	O
{	O
struct	O
rush_wtmp	struct
wtmp	pointer
;	O
wtmp	pointer
.	O
pid	int
=	O
pid	int
;	O
wtmp	pointer
.	O
user	pointer
=	O
req	pointer
->	O
pw	pointer
->	O
pw_name	pointer
;	O
wtmp	pointer
.	O
rule	pointer
=	O
rule	pointer
->	O
tag	pointer
;	O
wtmp	pointer
.	O
command	pointer
=	O
req	pointer
->	O
cmdline	pointer
;	O
if	O
(	O
rushdb_start	function
(	O
&	O
wtmp	pointer
)	O
)	O
die	function
(	O
system_error	int
,	O
&	O
req	pointer
->	O
i18n	struct
,	O
_	O
(	O
"error writing to database %s: %s"	pointer
)	O
,	O
RUSH_DB	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
static	O
void	O
acct_off	function
(	O
void	O
)	O
{	O
if	O
(	O
rushdb_stop	function
(	O
)	O
)	O
logmsg	function
(	O
LOG_ERR	int
,	O
_	O
(	O
"error writing stop to database file %s: %s"	pointer
)	O
,	O
RUSH_DB	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
rushdb_close	function
(	O
)	O
;	O
}	O
static	O
void	O
fork_process	function
(	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
rush_request	struct
*	O
req	pointer
)	O
{	O
int	O
status	int
;	O
pid_t	int
pid	int
;	O
signal	function
(	O
SIGCHLD	int
,	O
SIG_DFL	O
)	O
;	O
pid	int
=	O
fork	function
(	O
)	O
;	O
if	O
(	O
pid	int
==	O
0	int
)	O
{	O
return	O
;	O
}	O
if	O
(	O
pid	int
==	O
-	O
1	int
)	O
die	function
(	O
system_error	int
,	O
&	O
req	pointer
->	O
i18n	struct
,	O
_	O
(	O
"%s:%d: %s: cannot fork: %s"	pointer
)	O
,	O
rule	pointer
->	O
file	pointer
,	O
rule	pointer
->	O
line	int
,	O
rule	pointer
->	O
tag	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
close	pointer
(	O
0	int
)	O
;	O
close	pointer
(	O
1	int
)	O
;	O
close	pointer
(	O
2	int
)	O
;	O
if	O
(	O
req	pointer
->	O
acct	function
==	O
rush_true	int
)	O
acct_on	function
(	O
rule	pointer
,	O
req	pointer
,	O
pid	int
)	O
;	O
debug	O
(	O
2	int
,	O
_	O
(	O
"Forked process %lu"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
pid	int
)	O
;	O
waitpid	function
(	O
pid	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
if	O
(	O
WIFEXITED	O
(	O
status	int
)	O
)	O
{	O
status	int
=	O
WEXITSTATUS	O
(	O
status	int
)	O
;	O
debug	O
(	O
2	int
,	O
_	O
(	O
"%s: subprocess exited with code %d"	pointer
)	O
,	O
rule	pointer
->	O
tag	pointer
,	O
status	int
)	O
;	O
}	O
else	O
if	O
(	O
WIFSIGNALED	O
(	O
status	int
)	O
)	O
{	O
logmsg	function
(	O
LOG_NOTICE	int
,	O
_	O
(	O
"%s: subprocess terminated on signal %d"	pointer
)	O
,	O
rule	pointer
->	O
tag	pointer
,	O
WTERMSIG	O
(	O
status	int
)	O
)	O
;	O
}	O
else	O
logmsg	function
(	O
LOG_NOTICE	int
,	O
_	O
(	O
"%s: subprocess terminated"	pointer
)	O
,	O
rule	pointer
->	O
tag	pointer
)	O
;	O
if	O
(	O
req	pointer
->	O
acct	function
==	O
rush_true	int
)	O
acct_off	function
(	O
)	O
;	O
if	O
(	O
req	pointer
->	O
post_sockaddr	struct
)	O
post_socket_send	function
(	O
req	pointer
->	O
post_sockaddr	struct
,	O
rule	pointer
,	O
req	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
static	O
int	O
membergid	function
(	O
gid_t	int
gid	int
,	O
size_t	long
gc	long
,	O
gid_t	int
*	O
gv	pointer
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
gc	long
;	O
i	int
++	O
)	O
if	O
(	O
gv	pointer
[	O
i	int
]	O
==	O
gid	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
get_user_groups	function
(	O
struct	O
rush_request	struct
*	O
req	pointer
,	O
size_t	long
*	O
pgidc	pointer
,	O
gid_t	int
*	O
*	O
pgidv	pointer
)	O
{	O
size_t	long
gidc	long
=	O
0	int
,	O
n	long
=	O
0	int
;	O
gid_t	int
*	O
gidv	pointer
=	O
NULL	O
;	O
struct	O
group	struct
*	O
gr	pointer
;	O
n	long
=	O
32	int
;	O
gidv	pointer
=	O
xcalloc	function
(	O
n	long
,	O
sizeof	O
(	O
gidv	pointer
[	O
0	int
]	O
)	O
)	O
;	O
gidv	pointer
[	O
0	int
]	O
=	O
req	pointer
->	O
gid	int
==	O
NO_GID	O
?	O
req	pointer
->	O
pw	pointer
->	O
pw_gid	int
:	O
req	pointer
->	O
gid	int
;	O
gidc	long
=	O
1	int
;	O
setgrent	function
(	O
)	O
;	O
while	O
(	O
(	O
gr	pointer
=	O
getgrent	function
(	O
)	O
)	O
)	O
{	O
char	O
*	O
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
gr	pointer
->	O
gr_mem	pointer
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
if	O
(	O
strcmp	function
(	O
*	O
p	pointer
,	O
req	pointer
->	O
pw	pointer
->	O
pw_name	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
n	long
==	O
gidc	long
)	O
{	O
n	long
+=	O
32	int
;	O
gidv	pointer
=	O
xrealloc	function
(	O
gidv	pointer
,	O
n	long
*	O
sizeof	O
(	O
gidv	pointer
[	O
0	int
]	O
)	O
)	O
;	O
}	O
if	O
(	O
!	O
membergid	function
(	O
gr	pointer
->	O
gr_gid	int
,	O
gidc	long
,	O
gidv	pointer
)	O
)	O
gidv	pointer
[	O
gidc	long
++	O
]	O
=	O
gr	pointer
->	O
gr_gid	int
;	O
}	O
}	O
endgrent	function
(	O
)	O
;	O
*	O
pgidc	pointer
=	O
gidc	long
;	O
*	O
pgidv	pointer
=	O
gidv	pointer
;	O
}	O
static	O
void	O
setowner	function
(	O
struct	O
rush_request	struct
*	O
req	pointer
)	O
{	O
size_t	long
gidc	long
;	O
gid_t	int
*	O
gidv	pointer
;	O
get_user_groups	function
(	O
req	pointer
,	O
&	O
gidc	long
,	O
&	O
gidv	pointer
)	O
;	O
if	O
(	O
setgroups	function
(	O
gidc	long
,	O
gidv	pointer
)	O
<	O
0	int
)	O
die	function
(	O
system_error	int
,	O
&	O
req	pointer
->	O
i18n	struct
,	O
"setgroups: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
if	O
(	O
setgid	function
(	O
gidv	pointer
[	O
0	int
]	O
)	O
)	O
die	function
(	O
system_error	int
,	O
&	O
req	pointer
->	O
i18n	struct
,	O
_	O
(	O
"cannot enforce gid %lu: %s"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
gidv	pointer
[	O
0	int
]	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
free	function
(	O
gidv	pointer
)	O
;	O
if	O
(	O
setuid	function
(	O
req	pointer
->	O
pw	pointer
->	O
pw_uid	int
)	O
)	O
die	function
(	O
system_error	int
,	O
&	O
req	pointer
->	O
i18n	struct
,	O
_	O
(	O
"cannot enforce uid %lu: %s"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
req	pointer
->	O
pw	pointer
->	O
pw_uid	int
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
if	O
(	O
req	pointer
->	O
pw	pointer
->	O
pw_uid	int
&&	O
setuid	function
(	O
0	int
)	O
==	O
0	int
)	O
die	function
(	O
system_error	int
,	O
&	O
req	pointer
->	O
i18n	struct
,	O
_	O
(	O
"seteuid(0) succeeded when it should not"	pointer
)	O
)	O
;	O
}	O
static	O
void	O
run_rule	function
(	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
struct	O
rush_request	struct
*	O
req	pointer
)	O
{	O
debug	O
(	O
2	int
,	O
_	O
(	O
"Rule %s at %s:%d matched"	pointer
)	O
,	O
rule	pointer
->	O
tag	pointer
,	O
rule	pointer
->	O
file	pointer
,	O
rule	pointer
->	O
line	int
)	O
;	O
env_setup	function
(	O
rule	pointer
,	O
req	pointer
)	O
;	O
if	O
(	O
rule	pointer
->	O
i18n	struct
.	O
text_domain	pointer
)	O
req	pointer
->	O
i18n	struct
.	O
text_domain	pointer
=	O
rule	pointer
->	O
i18n	struct
.	O
text_domain	pointer
;	O
if	O
(	O
rule	pointer
->	O
i18n	struct
.	O
localedir	pointer
)	O
req	pointer
->	O
i18n	struct
.	O
localedir	pointer
=	O
rule	pointer
->	O
i18n	struct
.	O
localedir	pointer
;	O
if	O
(	O
rule	pointer
->	O
i18n	struct
.	O
locale	pointer
)	O
req	pointer
->	O
i18n	struct
.	O
locale	pointer
=	O
rule	pointer
->	O
i18n	struct
.	O
locale	pointer
;	O
if	O
(	O
rule	pointer
->	O
error	pointer
)	O
{	O
const	O
char	O
*	O
msg	pointer
=	O
rush_error_msg	function
(	O
rule	pointer
->	O
error	pointer
,	O
&	O
rule	pointer
->	O
i18n	struct
)	O
;	O
debug	O
(	O
2	int
,	O
_	O
(	O
"Error message: %s"	pointer
)	O
,	O
msg	pointer
)	O
;	O
if	O
(	O
write	pointer
(	O
rule	pointer
->	O
error	pointer
->	O
fd	int
,	O
msg	pointer
,	O
strlen	function
(	O
msg	pointer
)	O
)	O
<	O
0	int
)	O
die	function
(	O
system_error	int
,	O
&	O
req	pointer
->	O
i18n	struct
,	O
_	O
(	O
"Error sending diagnostic message to descriptor %d: %s"	pointer
)	O
,	O
rule	pointer
->	O
error	pointer
->	O
fd	int
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
set_user_limits	function
(	O
req	pointer
->	O
pw	pointer
->	O
pw_name	pointer
,	O
rule	pointer
->	O
limits	pointer
)	O
)	O
die	function
(	O
usage_error	int
,	O
&	O
req	pointer
->	O
i18n	struct
,	O
_	O
(	O
"cannot set limits for %s"	pointer
)	O
,	O
req	pointer
->	O
pw	pointer
->	O
pw_name	pointer
)	O
;	O
run_transforms	function
(	O
rule	pointer
,	O
req	pointer
)	O
;	O
if	O
(	O
rule	pointer
->	O
chroot_dir	pointer
)	O
{	O
char	O
*	O
dir	enum
=	O
expand_dir	function
(	O
rule	pointer
->	O
chroot_dir	pointer
,	O
req	pointer
)	O
;	O
debug	O
(	O
2	int
,	O
_	O
(	O
"Chroot dir: %s"	pointer
)	O
,	O
dir	enum
)	O
;	O
free	function
(	O
req	pointer
->	O
chroot_dir	pointer
)	O
;	O
req	pointer
->	O
chroot_dir	pointer
=	O
dir	enum
;	O
}	O
if	O
(	O
rule	pointer
->	O
home_dir	pointer
)	O
{	O
free	function
(	O
req	pointer
->	O
home_dir	pointer
)	O
;	O
req	pointer
->	O
home_dir	pointer
=	O
expand_dir	function
(	O
rule	pointer
->	O
home_dir	pointer
,	O
req	pointer
)	O
;	O
debug	O
(	O
2	int
,	O
_	O
(	O
"Home dir: %s"	pointer
)	O
,	O
req	pointer
->	O
home_dir	pointer
)	O
;	O
}	O
if	O
(	O
rule	pointer
->	O
gid	int
!=	O
NO_GID	O
)	O
{	O
req	pointer
->	O
gid	int
=	O
rule	pointer
->	O
gid	int
;	O
debug	O
(	O
2	int
,	O
_	O
(	O
"GID: %lu"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
req	pointer
->	O
gid	int
)	O
;	O
}	O
if	O
(	O
rule	pointer
->	O
post_sockaddr	struct
.	O
len	long
)	O
req	pointer
->	O
post_sockaddr	struct
=	O
&	O
rule	pointer
->	O
post_sockaddr	struct
;	O
if	O
(	O
rule	pointer
->	O
acct	function
!=	O
rush_undefined	int
)	O
req	pointer
->	O
acct	function
=	O
rule	pointer
->	O
acct	function
;	O
if	O
(	O
req	pointer
->	O
acct	function
==	O
rush_true	int
)	O
req	pointer
->	O
fork	function
=	O
rush_true	int
;	O
else	O
if	O
(	O
rule	pointer
->	O
post_sockaddr	struct
.	O
len	long
)	O
req	pointer
->	O
fork	function
=	O
rush_true	int
;	O
else	O
if	O
(	O
rule	pointer
->	O
fork	function
!=	O
rush_undefined	int
)	O
req	pointer
->	O
fork	function
=	O
rule	pointer
->	O
fork	function
;	O
if	O
(	O
rule	pointer
->	O
mask	int
!=	O
NO_UMASK	O
)	O
req	pointer
->	O
umask	function
=	O
rule	pointer
->	O
mask	int
;	O
if	O
(	O
rule	pointer
->	O
fall_through	int
)	O
return	O
;	O
if	O
(	O
req	pointer
->	O
acct	function
==	O
rush_true	int
&&	O
rushdb_open	function
(	O
RUSH_DB	O
,	O
1	int
)	O
!=	O
rushdb_result_ok	int
)	O
die	function
(	O
system_error	int
,	O
&	O
req	pointer
->	O
i18n	struct
,	O
_	O
(	O
"cannot open database %s: %s"	pointer
)	O
,	O
RUSH_DB	O
,	O
rushdb_error_string	pointer
)	O
;	O
if	O
(	O
req	pointer
->	O
chroot_dir	pointer
)	O
{	O
uid_t	int
uid	int
;	O
struct	O
passwd	struct
*	O
pw	pointer
;	O
if	O
(	O
chroot	function
(	O
req	pointer
->	O
chroot_dir	pointer
)	O
)	O
die	function
(	O
system_error	int
,	O
&	O
req	pointer
->	O
i18n	struct
,	O
_	O
(	O
"cannot chroot to %s: %s"	pointer
)	O
,	O
req	pointer
->	O
chroot_dir	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
uid	int
=	O
req	pointer
->	O
pw	pointer
->	O
pw_uid	int
;	O
pw	pointer
=	O
getpwuid	function
(	O
uid	int
)	O
;	O
if	O
(	O
!	O
pw	pointer
)	O
die	function
(	O
req	pointer
->	O
interactive	int
?	O
nologin_error	int
:	O
usage_error	int
,	O
NULL	O
,	O
_	O
(	O
"invalid uid %lu"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
uid	int
)	O
;	O
req	pointer
->	O
pw	pointer
=	O
pw	pointer
;	O
}	O
if	O
(	O
req	pointer
->	O
home_dir	pointer
)	O
{	O
debug	O
(	O
2	int
,	O
_	O
(	O
"chdir %s"	pointer
)	O
,	O
req	pointer
->	O
home_dir	pointer
)	O
;	O
if	O
(	O
chdir	function
(	O
req	pointer
->	O
home_dir	pointer
)	O
)	O
die	function
(	O
system_error	int
,	O
&	O
req	pointer
->	O
i18n	struct
,	O
_	O
(	O
"cannot change to dir %s: %s"	pointer
)	O
,	O
req	pointer
->	O
home_dir	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
debug	O
(	O
2	int
,	O
_	O
(	O
"Executing %s, %s"	pointer
)	O
,	O
PROGFILE	O
(	O
req	pointer
)	O
,	O
req	pointer
->	O
cmdline	pointer
)	O
;	O
if	O
(	O
lint_option	int
)	O
{	O
if	O
(	O
dump_option	pointer
)	O
dump_request	function
(	O
req	pointer
,	O
stdout	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
if	O
(	O
req	pointer
->	O
fork	function
==	O
rush_true	int
)	O
fork_process	function
(	O
rule	pointer
,	O
req	pointer
)	O
;	O
setowner	function
(	O
req	pointer
)	O
;	O
umask	function
(	O
req	pointer
->	O
umask	function
)	O
;	O
execve	function
(	O
PROGFILE	O
(	O
req	pointer
)	O
,	O
req	pointer
->	O
argv	pointer
,	O
req	pointer
->	O
env	pointer
)	O
;	O
die	function
(	O
system_error	int
,	O
&	O
req	pointer
->	O
i18n	struct
,	O
_	O
(	O
"%s:%d: %s: cannot execute %s: %s"	pointer
)	O
,	O
rule	pointer
->	O
file	pointer
,	O
rule	pointer
->	O
line	int
,	O
rule	pointer
->	O
tag	pointer
,	O
req	pointer
->	O
cmdline	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
static	O
char	O
*	O
command	pointer
=	O
NULL	O
;	O
static	O
char	O
*	O
test_user_name	pointer
=	O
NULL	O
;	O
static	O
int	O
interactive	int
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
uid_t	int
uid	int
;	O
struct	O
rush_rule	struct
*	O
rule	pointer
;	O
struct	O
rush_request	struct
req	pointer
;	O
rush_set_program_name	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
rush_i18n_init	function
(	O
)	O
;	O
umask	function
(	O
~	O
(	O
mode_t	int
)	O
0	int
)	O
;	O
openlog	function
(	O
program_name	pointer
,	O
LOG_NDELAY	int
|	O
LOG_PID	int
,	O
LOG_AUTHPRIV	O
)	O
;	O
get_options	function
(	O
argc	int
,	O
argv	pointer
)	O
;	O
cfgram_debug	function
(	O
parser_traces	int
>	O
0	int
)	O
;	O
cflex_debug	function
(	O
parser_traces	int
>	O
1	int
)	O
;	O
if	O
(	O
scanner_test	int
)	O
{	O
cfck_keyword	function
(	O
"none"	pointer
)	O
;	O
if	O
(	O
argc	int
>	O
optind	int
+	O
1	int
)	O
{	O
logmsg	function
(	O
LOG_ERR	int
,	O
"%s"	pointer
,	O
_	O
(	O
"too many arguments"	pointer
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
cflex_test	function
(	O
argv	pointer
[	O
optind	int
]	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
if	O
(	O
argc	int
==	O
optind	int
+	O
1	int
)	O
{	O
if	O
(	O
lint_option	int
)	O
rush_config_file	pointer
=	O
argv	pointer
[	O
optind	int
]	O
;	O
else	O
die	function
(	O
usage_error	int
,	O
NULL	O
,	O
_	O
(	O
"invalid command line"	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
argc	int
>	O
optind	int
)	O
die	function
(	O
usage_error	int
,	O
NULL	O
,	O
_	O
(	O
"invalid command line"	pointer
)	O
)	O
;	O
if	O
(	O
lint_option	int
)	O
{	O
if	O
(	O
setuid	function
(	O
getuid	function
(	O
)	O
)	O
)	O
die	function
(	O
system_error	int
,	O
NULL	O
,	O
"setuid: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
if	O
(	O
test_user_name	pointer
)	O
{	O
struct	O
passwd	struct
*	O
pw	pointer
=	O
getpwnam	function
(	O
test_user_name	pointer
)	O
;	O
if	O
(	O
!	O
pw	pointer
)	O
die	function
(	O
usage_error	int
,	O
NULL	O
,	O
_	O
(	O
"invalid user name"	pointer
)	O
)	O
;	O
if	O
(	O
setreuid	function
(	O
pw	pointer
->	O
pw_uid	int
,	O
0	int
)	O
)	O
die	function
(	O
system_error	int
,	O
NULL	O
,	O
"setreuid: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
uid	int
=	O
getuid	function
(	O
)	O
;	O
if	O
(	O
(	O
rush_pw	pointer
=	O
getpwuid	function
(	O
uid	int
)	O
)	O
==	O
NULL	O
)	O
die	function
(	O
system_error	int
,	O
NULL	O
,	O
_	O
(	O
"invalid uid %lu"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
uid	int
)	O
;	O
debug	O
(	O
2	int
,	O
_	O
(	O
"user %s, uid %lu"	pointer
)	O
,	O
rush_pw	pointer
->	O
pw_name	pointer
,	O
(	O
unsigned	O
long	O
)	O
rush_pw	pointer
->	O
pw_uid	int
)	O
;	O
cfparse	function
(	O
)	O
;	O
if	O
(	O
!	O
command	pointer
)	O
{	O
if	O
(	O
lint_option	int
&&	O
!	O
interactive	int
)	O
exit	function
(	O
0	int
)	O
;	O
}	O
if	O
(	O
__debug_p	O
(	O
2	int
)	O
)	O
{	O
int	O
i	int
;	O
logmsg	function
(	O
LOG_DEBUG	int
,	O
_	O
(	O
"Command line:"	pointer
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
logmsg	function
(	O
LOG_DEBUG	int
,	O
"% 4d: %s"	pointer
,	O
i	int
,	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
logmsg	function
(	O
LOG_DEBUG	int
,	O
_	O
(	O
"Environment:"	pointer
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
environ	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
logmsg	function
(	O
LOG_DEBUG	int
,	O
"% 4d %s"	pointer
,	O
i	int
,	O
environ	pointer
[	O
i	int
]	O
)	O
;	O
}	O
memset	function
(	O
&	O
req	pointer
,	O
0	int
,	O
sizeof	O
(	O
req	pointer
)	O
)	O
;	O
if	O
(	O
!	O
command	pointer
)	O
{	O
req	pointer
.	O
interactive	int
=	O
1	int
;	O
command	pointer
=	O
"/bin/sh"	pointer
;	O
}	O
req	pointer
.	O
cmdline	pointer
=	O
xstrdup	function
(	O
command	pointer
)	O
;	O
request_set_env	function
(	O
&	O
req	pointer
)	O
;	O
reparse_cmdline	function
(	O
&	O
req	pointer
)	O
;	O
req	pointer
.	O
pw	pointer
=	O
rush_pw	pointer
;	O
req	pointer
.	O
umask	function
=	O
022	int
;	O
req	pointer
.	O
chroot_dir	pointer
=	O
NULL	O
;	O
req	pointer
.	O
home_dir	pointer
=	O
NULL	O
;	O
req	pointer
.	O
gid	int
=	O
NO_GID	O
;	O
req	pointer
.	O
fork	function
=	O
rush_undefined	int
;	O
req	pointer
.	O
acct	function
=	O
rush_undefined	int
;	O
for	O
(	O
rule	pointer
=	O
rule_head	pointer
;	O
rule	pointer
;	O
rule	pointer
=	O
rule	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
req	pointer
.	O
interactive	int
!=	O
rule	pointer
->	O
interactive	int
)	O
continue	O
;	O
if	O
(	O
rule	pointer
->	O
test_node	struct
&&	O
!	O
test_eval	function
(	O
rule	pointer
->	O
test_node	struct
,	O
rule	pointer
,	O
&	O
req	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
debug_level	int
)	O
{	O
if	O
(	O
req	pointer
.	O
interactive	int
)	O
logmsg	function
(	O
LOG_NOTICE	int
,	O
_	O
(	O
"Serving interactive shell request for %s by rule %s"	pointer
)	O
,	O
req	pointer
.	O
pw	pointer
->	O
pw_name	pointer
,	O
rule	pointer
->	O
tag	pointer
)	O
;	O
else	O
logmsg	function
(	O
LOG_NOTICE	int
,	O
_	O
(	O
"Serving request \"%s\" for %s by rule %s"	pointer
)	O
,	O
command	pointer
,	O
req	pointer
.	O
pw	pointer
->	O
pw_name	pointer
,	O
rule	pointer
->	O
tag	pointer
)	O
;	O
}	O
run_rule	function
(	O
rule	pointer
,	O
&	O
req	pointer
)	O
;	O
}	O
die	function
(	O
req	pointer
.	O
interactive	int
?	O
nologin_error	int
:	O
usage_error	int
,	O
&	O
req	pointer
.	O
i18n	struct
,	O
_	O
(	O
"no matching rule for \"%s\", user %s"	pointer
)	O
,	O
req	pointer
.	O
cmdline	pointer
,	O
req	pointer
.	O
pw	pointer
->	O
pw_name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
