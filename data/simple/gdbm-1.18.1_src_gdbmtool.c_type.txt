char	O
*	O
file_name	pointer
=	O
NULL	O
;	O
GDBM_FILE	pointer
gdbm_file	pointer
=	O
NULL	O
;	O
datum	struct
key_data	struct
;	O
datum	struct
return_data	struct
;	O
int	O
open_mode	int
;	O
unsigned	O
input_line	int
;	O
static	O
void	O
closedb	function
(	O
void	O
)	O
{	O
if	O
(	O
gdbm_file	pointer
)	O
{	O
gdbm_close	function
(	O
gdbm_file	pointer
)	O
;	O
gdbm_file	pointer
=	O
NULL	O
;	O
free	function
(	O
file_name	pointer
)	O
;	O
file_name	pointer
=	O
NULL	O
;	O
}	O
}	O
static	O
int	O
opendb	function
(	O
char	O
*	O
dbname	pointer
)	O
{	O
int	O
cache_size	long
=	O
0	int
;	O
int	O
block_size	int
=	O
0	int
;	O
int	O
flags	int
=	O
0	int
;	O
int	O
filemode	int
;	O
GDBM_FILE	pointer
db	pointer
;	O
switch	O
(	O
variable_get	function
(	O
"cachesize"	pointer
,	O
VART_INT	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
cache_size	long
)	O
)	O
{	O
case	O
VAR_OK	int
:	O
case	O
VAR_ERR_NOTSET	int
:	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
switch	O
(	O
variable_get	function
(	O
"blocksize"	pointer
,	O
VART_INT	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
block_size	int
)	O
)	O
{	O
case	O
VAR_OK	int
:	O
case	O
VAR_ERR_NOTSET	int
:	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
if	O
(	O
!	O
variable_is_true	function
(	O
"lock"	pointer
)	O
)	O
flags	int
|=	O
GDBM_NOLOCK	int
;	O
if	O
(	O
!	O
variable_is_true	function
(	O
"mmap"	pointer
)	O
)	O
flags	int
|=	O
GDBM_NOMMAP	int
;	O
if	O
(	O
variable_is_true	function
(	O
"sync"	pointer
)	O
)	O
flags	int
|=	O
GDBM_SYNC	int
;	O
if	O
(	O
open_mode	int
==	O
GDBM_NEWDB	int
)	O
{	O
if	O
(	O
interactive	function
(	O
)	O
&&	O
variable_is_true	function
(	O
"confirm"	pointer
)	O
&&	O
access	function
(	O
dbname	pointer
,	O
F_OK	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
!	O
getyn	function
(	O
_	O
(	O
"database %s already exists; overwrite"	pointer
)	O
,	O
dbname	pointer
)	O
)	O
return	O
1	int
;	O
}	O
}	O
if	O
(	O
variable_get	function
(	O
"filemode"	pointer
,	O
VART_INT	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
filemode	int
)	O
)	O
abort	function
(	O
)	O
;	O
db	pointer
=	O
gdbm_open	function
(	O
dbname	pointer
,	O
block_size	int
,	O
open_mode	int
|	O
flags	int
,	O
filemode	int
,	O
NULL	O
)	O
;	O
if	O
(	O
db	pointer
==	O
NULL	O
)	O
{	O
terror	function
(	O
_	O
(	O
"cannot open database %s: %s"	pointer
)	O
,	O
dbname	pointer
,	O
gdbm_strerror	function
(	O
gdbm_errno	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
cache_size	long
&&	O
gdbm_setopt	function
(	O
db	pointer
,	O
GDBM_CACHESIZE	O
,	O
&	O
cache_size	long
,	O
sizeof	O
(	O
int	O
)	O
)	O
==	O
-	O
1	int
)	O
terror	function
(	O
_	O
(	O
"gdbm_setopt failed: %s"	pointer
)	O
,	O
gdbm_strerror	function
(	O
gdbm_errno	O
)	O
)	O
;	O
if	O
(	O
variable_is_true	function
(	O
"coalesce"	pointer
)	O
)	O
{	O
int	O
t	int
=	O
1	int
;	O
if	O
(	O
gdbm_setopt	function
(	O
db	pointer
,	O
GDBM_SETCOALESCEBLKS	int
,	O
&	O
t	int
,	O
sizeof	O
(	O
t	int
)	O
)	O
==	O
-	O
1	int
)	O
terror	function
(	O
_	O
(	O
"gdbm_setopt failed: %s"	pointer
)	O
,	O
gdbm_strerror	function
(	O
gdbm_errno	O
)	O
)	O
;	O
}	O
if	O
(	O
variable_is_true	function
(	O
"centfree"	pointer
)	O
)	O
{	O
int	O
t	int
=	O
1	int
;	O
if	O
(	O
gdbm_setopt	function
(	O
db	pointer
,	O
GDBM_SETCENTFREE	int
,	O
&	O
t	int
,	O
sizeof	O
(	O
t	int
)	O
)	O
==	O
-	O
1	int
)	O
terror	function
(	O
_	O
(	O
"gdbm_setopt failed: %s"	pointer
)	O
,	O
gdbm_strerror	function
(	O
gdbm_errno	O
)	O
)	O
;	O
}	O
if	O
(	O
gdbm_file	pointer
)	O
gdbm_close	function
(	O
gdbm_file	pointer
)	O
;	O
gdbm_file	pointer
=	O
db	pointer
;	O
return	O
0	int
;	O
}	O
static	O
int	O
checkdb	function
(	O
void	O
)	O
{	O
if	O
(	O
!	O
gdbm_file	pointer
)	O
{	O
if	O
(	O
!	O
file_name	pointer
)	O
{	O
file_name	pointer
=	O
estrdup	function
(	O
GDBMTOOL_DEFFILE	pointer
)	O
;	O
terror	function
(	O
_	O
(	O
"warning: using default database file %s"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
}	O
return	O
opendb	function
(	O
file_name	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
checkdb_begin	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
GDBM_ARG_UNUSED	O
,	O
size_t	long
*	O
exp_count	pointer
GDBM_ARG_UNUSED	O
)	O
{	O
return	O
checkdb	function
(	O
)	O
;	O
}	O
size_t	long
bucket_print_lines	function
(	O
hash_bucket	struct
*	O
bucket	pointer
)	O
{	O
return	O
6	int
+	O
gdbm_file	pointer
->	O
header	pointer
->	O
bucket_elems	int
+	O
3	int
+	O
bucket	pointer
->	O
av_count	int
;	O
}	O
static	O
void	O
format_key_start	function
(	O
FILE	struct
*	O
fp	pointer
,	O
bucket_element	struct
*	O
elt	pointer
)	O
{	O
int	O
size	int
=	O
SMALL	int
<	O
elt	pointer
->	O
key_size	int
?	O
SMALL	int
:	O
elt	pointer
->	O
key_size	int
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
size	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
isprint	function
(	O
elt	pointer
->	O
key_start	array
[	O
i	int
]	O
)	O
)	O
fprintf	function
(	O
fp	pointer
,	O
"   %c"	pointer
,	O
elt	pointer
->	O
key_start	array
[	O
i	int
]	O
)	O
;	O
else	O
fprintf	function
(	O
fp	pointer
,	O
" %03o"	pointer
,	O
elt	pointer
->	O
key_start	array
[	O
i	int
]	O
)	O
;	O
}	O
}	O
void	O
print_bucket	function
(	O
FILE	struct
*	O
fp	pointer
,	O
hash_bucket	struct
*	O
bucket	pointer
,	O
const	O
char	O
*	O
mesg	pointer
,	O
...	O
)	O
{	O
int	O
index	function
;	O
va_list	array
ap	array
;	O
fprintf	function
(	O
fp	pointer
,	O
"******* "	pointer
)	O
;	O
va_start	O
(	O
ap	array
,	O
mesg	pointer
)	O
;	O
vfprintf	function
(	O
fp	pointer
,	O
mesg	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
" **********\n\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
_	O
(	O
"bits = %d\ncount= %d\nHash Table:\n"	pointer
)	O
,	O
bucket	pointer
->	O
bucket_bits	int
,	O
bucket	pointer
->	O
count	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
_	O
(	O
"    #    hash value     key size    data size     data adr home  key start\n"	pointer
)	O
)	O
;	O
for	O
(	O
index	function
=	O
0	int
;	O
index	function
<	O
gdbm_file	pointer
->	O
header	pointer
->	O
bucket_elems	int
;	O
index	function
++	O
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
" %4d  %12x  %11d  %11d  %11lu %4d"	pointer
,	O
index	function
,	O
bucket	pointer
->	O
h_table	array
[	O
index	function
]	O
.	O
hash_value	int
,	O
bucket	pointer
->	O
h_table	array
[	O
index	function
]	O
.	O
key_size	int
,	O
bucket	pointer
->	O
h_table	array
[	O
index	function
]	O
.	O
data_size	int
,	O
(	O
unsigned	O
long	O
)	O
bucket	pointer
->	O
h_table	array
[	O
index	function
]	O
.	O
data_pointer	long
,	O
bucket	pointer
->	O
h_table	array
[	O
index	function
]	O
.	O
hash_value	int
%	O
gdbm_file	pointer
->	O
header	pointer
->	O
bucket_elems	int
)	O
;	O
if	O
(	O
bucket	pointer
->	O
h_table	array
[	O
index	function
]	O
.	O
key_size	int
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
" "	pointer
)	O
;	O
format_key_start	function
(	O
fp	pointer
,	O
&	O
bucket	pointer
->	O
h_table	array
[	O
index	function
]	O
)	O
;	O
}	O
fprintf	function
(	O
fp	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
fprintf	function
(	O
fp	pointer
,	O
_	O
(	O
"\nAvail count = %1d\n"	pointer
)	O
,	O
bucket	pointer
->	O
av_count	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
_	O
(	O
"Address           size\n"	pointer
)	O
)	O
;	O
for	O
(	O
index	function
=	O
0	int
;	O
index	function
<	O
bucket	pointer
->	O
av_count	int
;	O
index	function
++	O
)	O
fprintf	function
(	O
fp	pointer
,	O
"%11lu%9d\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
bucket	pointer
->	O
bucket_avail	array
[	O
index	function
]	O
.	O
av_adr	long
,	O
bucket	pointer
->	O
bucket_avail	array
[	O
index	function
]	O
.	O
av_size	int
)	O
;	O
}	O
size_t	long
_gdbm_avail_list_size	function
(	O
GDBM_FILE	pointer
dbf	pointer
,	O
size_t	long
min_size	long
)	O
{	O
int	O
temp	int
;	O
int	O
size	int
;	O
avail_block	struct
*	O
av_stk	pointer
;	O
size_t	long
lines	long
;	O
lines	long
=	O
4	int
+	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
count	int
;	O
if	O
(	O
lines	long
>	O
min_size	long
)	O
return	O
lines	long
;	O
temp	int
=	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
next_block	long
;	O
size	int
=	O
(	O
(	O
(	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
size	int
*	O
sizeof	O
(	O
avail_elem	struct
)	O
)	O
>>	O
1	int
)	O
+	O
sizeof	O
(	O
avail_block	struct
)	O
)	O
;	O
av_stk	pointer
=	O
emalloc	function
(	O
size	int
)	O
;	O
while	O
(	O
temp	int
)	O
{	O
if	O
(	O
gdbm_file_seek	function
(	O
dbf	pointer
,	O
temp	int
,	O
SEEK_SET	int
)	O
!=	O
temp	int
)	O
{	O
terror	function
(	O
"lseek: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
_gdbm_full_read	function
(	O
dbf	pointer
,	O
av_stk	pointer
,	O
size	int
)	O
)	O
{	O
terror	function
(	O
"read: %s"	pointer
,	O
gdbm_db_strerror	function
(	O
dbf	pointer
)	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
gdbm_avail_block_valid_p	function
(	O
av_stk	pointer
)	O
)	O
{	O
lines	long
+=	O
av_stk	pointer
->	O
count	int
;	O
if	O
(	O
lines	long
>	O
min_size	long
)	O
break	O
;	O
}	O
temp	int
=	O
av_stk	pointer
->	O
next_block	long
;	O
}	O
free	function
(	O
av_stk	pointer
)	O
;	O
return	O
lines	long
;	O
}	O
static	O
void	O
av_table_display	function
(	O
avail_elem	struct
*	O
av_table	array
,	O
int	O
count	int
,	O
FILE	struct
*	O
fp	pointer
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
count	int
;	O
i	int
++	O
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"  %15d   %10lu \n"	pointer
,	O
av_table	array
[	O
i	int
]	O
.	O
av_size	int
,	O
(	O
unsigned	O
long	O
)	O
av_table	array
[	O
i	int
]	O
.	O
av_adr	long
)	O
;	O
}	O
}	O
void	O
_gdbm_print_avail_list	function
(	O
FILE	struct
*	O
fp	pointer
,	O
GDBM_FILE	pointer
dbf	pointer
)	O
{	O
int	O
temp	int
;	O
int	O
size	int
;	O
avail_block	struct
*	O
av_stk	pointer
;	O
fprintf	function
(	O
fp	pointer
,	O
_	O
(	O
"\nheader block\nsize  = %d\ncount = %d\n"	pointer
)	O
,	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
size	int
,	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
count	int
)	O
;	O
av_table_display	function
(	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
av_table	array
,	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
count	int
,	O
fp	pointer
)	O
;	O
temp	int
=	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
next_block	long
;	O
size	int
=	O
(	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
size	int
*	O
sizeof	O
(	O
avail_elem	struct
)	O
)	O
+	O
sizeof	O
(	O
avail_block	struct
)	O
;	O
av_stk	pointer
=	O
emalloc	function
(	O
size	int
)	O
;	O
while	O
(	O
temp	int
)	O
{	O
if	O
(	O
gdbm_file_seek	function
(	O
dbf	pointer
,	O
temp	int
,	O
SEEK_SET	int
)	O
!=	O
temp	int
)	O
{	O
terror	function
(	O
"lseek: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
_gdbm_full_read	function
(	O
dbf	pointer
,	O
av_stk	pointer
,	O
size	int
)	O
)	O
{	O
terror	function
(	O
"read: %s"	pointer
,	O
gdbm_db_strerror	function
(	O
dbf	pointer
)	O
)	O
;	O
break	O
;	O
}	O
fprintf	function
(	O
fp	pointer
,	O
_	O
(	O
"\nblock = %d\nsize  = %d\ncount = %d\n"	pointer
)	O
,	O
temp	int
,	O
av_stk	pointer
->	O
size	int
,	O
av_stk	pointer
->	O
count	int
)	O
;	O
if	O
(	O
gdbm_avail_block_validate	function
(	O
dbf	pointer
,	O
av_stk	pointer
)	O
==	O
0	int
)	O
av_table_display	function
(	O
av_stk	pointer
->	O
av_table	array
,	O
av_stk	pointer
->	O
count	int
,	O
fp	pointer
)	O
;	O
else	O
terror	function
(	O
_	O
(	O
"invalid avail_block"	pointer
)	O
)	O
;	O
temp	int
=	O
av_stk	pointer
->	O
next_block	long
;	O
}	O
free	function
(	O
av_stk	pointer
)	O
;	O
}	O
void	O
_gdbm_print_bucket_cache	function
(	O
FILE	struct
*	O
fp	pointer
,	O
GDBM_FILE	pointer
dbf	pointer
)	O
{	O
int	O
index	function
;	O
char	O
changed	char
;	O
if	O
(	O
dbf	pointer
->	O
bucket_cache	pointer
!=	O
NULL	O
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
_	O
(	O
"Bucket Cache (size %zu):\n  Index:         Address  Changed  Data_Hash \n"	pointer
)	O
,	O
dbf	pointer
->	O
cache_size	long
)	O
;	O
for	O
(	O
index	function
=	O
0	int
;	O
index	function
<	O
dbf	pointer
->	O
cache_size	long
;	O
index	function
++	O
)	O
{	O
changed	char
=	O
dbf	pointer
->	O
bucket_cache	pointer
[	O
index	function
]	O
.	O
ca_changed	char
;	O
fprintf	function
(	O
fp	pointer
,	O
"  %5d:  %15lu %7s  %x\n"	pointer
,	O
index	function
,	O
(	O
unsigned	O
long	O
)	O
dbf	pointer
->	O
bucket_cache	pointer
[	O
index	function
]	O
.	O
ca_adr	long
,	O
(	O
changed	char
?	O
_	O
(	O
"True"	pointer
)	O
:	O
_	O
(	O
"False"	pointer
)	O
)	O
,	O
dbf	pointer
->	O
bucket_cache	pointer
[	O
index	function
]	O
.	O
ca_data	struct
.	O
hash_val	int
)	O
;	O
}	O
}	O
else	O
fprintf	function
(	O
fp	pointer
,	O
_	O
(	O
"Bucket cache has not been initialized.\n"	pointer
)	O
)	O
;	O
}	O
int	O
trimnl	function
(	O
char	O
*	O
str	pointer
)	O
{	O
int	O
len	int
=	O
strlen	function
(	O
str	pointer
)	O
;	O
if	O
(	O
str	pointer
[	O
len	int
-	O
1	int
]	O
==	O
'\n'	O
)	O
{	O
str	pointer
[	O
--	O
len	int
]	O
=	O
0	int
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
get_screen_lines	function
(	O
)	O
{	O
if	O
(	O
isatty	function
(	O
1	int
)	O
)	O
{	O
struct	O
winsize	struct
ws	struct
;	O
ws	struct
.	O
ws_col	short
=	O
ws	struct
.	O
ws_row	short
=	O
0	int
;	O
if	O
(	O
(	O
ioctl	function
(	O
1	int
,	O
TIOCGWINSZ	int
,	O
(	O
char	O
*	O
)	O
&	O
ws	struct
)	O
<	O
0	int
)	O
||	O
ws	struct
.	O
ws_row	short
==	O
0	int
)	O
{	O
const	O
char	O
*	O
lines	long
=	O
getenv	function
(	O
"LINES"	pointer
)	O
;	O
if	O
(	O
lines	long
)	O
ws	struct
.	O
ws_row	short
=	O
strtol	function
(	O
lines	long
,	O
NULL	O
,	O
10	int
)	O
;	O
}	O
return	O
ws	struct
.	O
ws_row	short
;	O
}	O
return	O
-	O
1	int
;	O
}	O
void	O
open_handler	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
)	O
{	O
char	O
*	O
name	pointer
=	O
tildexpand	function
(	O
PARAM_STRING	O
(	O
param	pointer
,	O
0	int
)	O
)	O
;	O
closedb	function
(	O
)	O
;	O
if	O
(	O
opendb	function
(	O
name	pointer
)	O
==	O
0	int
)	O
file_name	pointer
=	O
name	pointer
;	O
else	O
free	function
(	O
name	pointer
)	O
;	O
}	O
void	O
close_handler	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
)	O
{	O
if	O
(	O
!	O
gdbm_file	pointer
)	O
terror	function
(	O
_	O
(	O
"nothing to close"	pointer
)	O
)	O
;	O
else	O
closedb	function
(	O
)	O
;	O
}	O
static	O
char	O
*	O
count_to_str	function
(	O
gdbm_count_t	long long
count	int
,	O
char	O
*	O
buf	pointer
,	O
size_t	long
bufsize	long
)	O
{	O
char	O
*	O
p	pointer
=	O
buf	pointer
+	O
bufsize	long
;	O
*	O
--	O
p	pointer
=	O
0	int
;	O
if	O
(	O
count	int
==	O
0	int
)	O
*	O
--	O
p	pointer
=	O
'0'	O
;	O
else	O
while	O
(	O
count	int
)	O
{	O
if	O
(	O
p	pointer
==	O
buf	pointer
)	O
return	O
NULL	O
;	O
*	O
--	O
p	pointer
=	O
'0'	O
+	O
count	int
%	O
10	int
;	O
count	int
/=	O
10	int
;	O
}	O
return	O
p	pointer
;	O
}	O
void	O
count_handler	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
)	O
{	O
gdbm_count_t	long long
count	int
;	O
if	O
(	O
gdbm_count	function
(	O
gdbm_file	pointer
,	O
&	O
count	int
)	O
)	O
terror	function
(	O
"gdbm_count: %s"	pointer
,	O
gdbm_strerror	function
(	O
gdbm_errno	O
)	O
)	O
;	O
else	O
{	O
char	O
buf	pointer
[	O
128	int
]	O
;	O
char	O
*	O
p	pointer
=	O
count_to_str	function
(	O
count	int
,	O
buf	pointer
,	O
sizeof	O
buf	pointer
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
terror	function
(	O
_	O
(	O
"count buffer overflow"	pointer
)	O
)	O
;	O
else	O
fprintf	function
(	O
param	pointer
->	O
fp	pointer
,	O
ngettext	function
(	O
"There is %s item in the database.\n"	pointer
,	O
"There are %s items in the database.\n"	pointer
,	O
count	int
)	O
,	O
p	pointer
)	O
;	O
}	O
}	O
void	O
delete_handler	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
)	O
{	O
if	O
(	O
gdbm_delete	function
(	O
gdbm_file	pointer
,	O
PARAM_DATUM	O
(	O
param	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
gdbm_errno	O
==	O
GDBM_ITEM_NOT_FOUND	int
)	O
terror	function
(	O
_	O
(	O
"Item not found"	pointer
)	O
)	O
;	O
else	O
terror	function
(	O
_	O
(	O
"Can't delete: %s"	pointer
)	O
,	O
gdbm_strerror	function
(	O
gdbm_errno	O
)	O
)	O
;	O
}	O
}	O
void	O
fetch_handler	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
)	O
{	O
return_data	struct
=	O
gdbm_fetch	function
(	O
gdbm_file	pointer
,	O
PARAM_DATUM	O
(	O
param	pointer
,	O
0	int
)	O
)	O
;	O
if	O
(	O
return_data	struct
.	O
dptr	pointer
!=	O
NULL	O
)	O
{	O
datum_format	function
(	O
param	pointer
->	O
fp	pointer
,	O
&	O
return_data	struct
,	O
dsdef	array
[	O
DS_CONTENT	int
]	O
)	O
;	O
fputc	function
(	O
'\n'	O
,	O
param	pointer
->	O
fp	pointer
)	O
;	O
free	function
(	O
return_data	struct
.	O
dptr	pointer
)	O
;	O
}	O
else	O
if	O
(	O
gdbm_errno	O
==	O
GDBM_ITEM_NOT_FOUND	int
)	O
terror	function
(	O
"%s"	pointer
,	O
_	O
(	O
"No such item found."	pointer
)	O
)	O
;	O
else	O
terror	function
(	O
_	O
(	O
"Can't fetch data: %s"	pointer
)	O
,	O
gdbm_strerror	function
(	O
gdbm_errno	O
)	O
)	O
;	O
}	O
void	O
store_handler	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
)	O
{	O
if	O
(	O
gdbm_store	function
(	O
gdbm_file	pointer
,	O
PARAM_DATUM	O
(	O
param	pointer
,	O
0	int
)	O
,	O
PARAM_DATUM	O
(	O
param	pointer
,	O
1	int
)	O
,	O
GDBM_REPLACE	int
)	O
!=	O
0	int
)	O
terror	function
(	O
_	O
(	O
"Item not inserted: %s."	pointer
)	O
,	O
gdbm_db_strerror	function
(	O
gdbm_file	pointer
)	O
)	O
;	O
}	O
void	O
firstkey_handler	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
)	O
{	O
if	O
(	O
key_data	struct
.	O
dptr	pointer
!=	O
NULL	O
)	O
free	function
(	O
key_data	struct
.	O
dptr	pointer
)	O
;	O
key_data	struct
=	O
gdbm_firstkey	function
(	O
gdbm_file	pointer
)	O
;	O
if	O
(	O
key_data	struct
.	O
dptr	pointer
!=	O
NULL	O
)	O
{	O
datum_format	function
(	O
param	pointer
->	O
fp	pointer
,	O
&	O
key_data	struct
,	O
dsdef	array
[	O
DS_KEY	int
]	O
)	O
;	O
fputc	function
(	O
'\n'	O
,	O
param	pointer
->	O
fp	pointer
)	O
;	O
return_data	struct
=	O
gdbm_fetch	function
(	O
gdbm_file	pointer
,	O
key_data	struct
)	O
;	O
datum_format	function
(	O
param	pointer
->	O
fp	pointer
,	O
&	O
return_data	struct
,	O
dsdef	array
[	O
DS_CONTENT	int
]	O
)	O
;	O
fputc	function
(	O
'\n'	O
,	O
param	pointer
->	O
fp	pointer
)	O
;	O
free	function
(	O
return_data	struct
.	O
dptr	pointer
)	O
;	O
}	O
else	O
if	O
(	O
gdbm_errno	O
==	O
GDBM_ITEM_NOT_FOUND	int
)	O
fprintf	function
(	O
param	pointer
->	O
fp	pointer
,	O
_	O
(	O
"No such item found.\n"	pointer
)	O
)	O
;	O
else	O
terror	function
(	O
_	O
(	O
"Can't find key: %s"	pointer
)	O
,	O
gdbm_strerror	function
(	O
gdbm_errno	O
)	O
)	O
;	O
}	O
void	O
nextkey_handler	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
)	O
{	O
if	O
(	O
param	pointer
->	O
argc	int
==	O
1	int
)	O
{	O
if	O
(	O
key_data	struct
.	O
dptr	pointer
!=	O
NULL	O
)	O
free	function
(	O
key_data	struct
.	O
dptr	pointer
)	O
;	O
key_data	struct
.	O
dptr	pointer
=	O
emalloc	function
(	O
PARAM_DATUM	O
(	O
param	pointer
,	O
0	int
)	O
.	O
dsize	int
)	O
;	O
key_data	struct
.	O
dsize	int
=	O
PARAM_DATUM	O
(	O
param	pointer
,	O
0	int
)	O
.	O
dsize	int
;	O
memcpy	function
(	O
key_data	struct
.	O
dptr	pointer
,	O
PARAM_DATUM	O
(	O
param	pointer
,	O
0	int
)	O
.	O
dptr	pointer
,	O
key_data	struct
.	O
dsize	int
)	O
;	O
}	O
return_data	struct
=	O
gdbm_nextkey	function
(	O
gdbm_file	pointer
,	O
key_data	struct
)	O
;	O
if	O
(	O
return_data	struct
.	O
dptr	pointer
!=	O
NULL	O
)	O
{	O
key_data	struct
=	O
return_data	struct
;	O
datum_format	function
(	O
param	pointer
->	O
fp	pointer
,	O
&	O
key_data	struct
,	O
dsdef	array
[	O
DS_KEY	int
]	O
)	O
;	O
fputc	function
(	O
'\n'	O
,	O
param	pointer
->	O
fp	pointer
)	O
;	O
return_data	struct
=	O
gdbm_fetch	function
(	O
gdbm_file	pointer
,	O
key_data	struct
)	O
;	O
datum_format	function
(	O
param	pointer
->	O
fp	pointer
,	O
&	O
return_data	struct
,	O
dsdef	array
[	O
DS_CONTENT	int
]	O
)	O
;	O
fputc	function
(	O
'\n'	O
,	O
param	pointer
->	O
fp	pointer
)	O
;	O
free	function
(	O
return_data	struct
.	O
dptr	pointer
)	O
;	O
}	O
else	O
if	O
(	O
gdbm_errno	O
==	O
GDBM_ITEM_NOT_FOUND	int
)	O
{	O
terror	function
(	O
"%s"	pointer
,	O
_	O
(	O
"No such item found."	pointer
)	O
)	O
;	O
free	function
(	O
key_data	struct
.	O
dptr	pointer
)	O
;	O
key_data	struct
.	O
dptr	pointer
=	O
NULL	O
;	O
}	O
else	O
terror	function
(	O
_	O
(	O
"Can't find key: %s"	pointer
)	O
,	O
gdbm_strerror	function
(	O
gdbm_errno	O
)	O
)	O
;	O
}	O
void	O
reorganize_handler	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
GDBM_ARG_UNUSED	O
)	O
{	O
if	O
(	O
gdbm_reorganize	function
(	O
gdbm_file	pointer
)	O
)	O
terror	function
(	O
"%s"	pointer
,	O
_	O
(	O
"Reorganization failed."	pointer
)	O
)	O
;	O
else	O
fprintf	function
(	O
param	pointer
->	O
fp	pointer
,	O
"%s\n"	pointer
,	O
_	O
(	O
"Reorganization succeeded."	pointer
)	O
)	O
;	O
}	O
static	O
void	O
err_printer	function
(	O
void	O
*	O
data	pointer
GDBM_ARG_UNUSED	O
,	O
char	O
const	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
vfprintf	function
(	O
stderr	pointer
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
void	O
recover_handler	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
)	O
{	O
gdbm_recovery	struct
rcvr	pointer
;	O
int	O
flags	int
=	O
0	int
;	O
int	O
rc	int
;	O
int	O
i	int
;	O
char	O
*	O
p	pointer
;	O
int	O
summary	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
param	pointer
->	O
argc	int
;	O
i	int
++	O
)	O
{	O
char	O
*	O
arg	pointer
=	O
PARAM_STRING	O
(	O
param	pointer
,	O
i	int
)	O
;	O
if	O
(	O
strcmp	function
(	O
arg	pointer
,	O
"verbose"	pointer
)	O
==	O
0	int
)	O
{	O
rcvr	pointer
.	O
errfun	pointer
=	O
err_printer	function
;	O
flags	int
|=	O
GDBM_RCVR_ERRFUN	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
arg	pointer
,	O
"force"	pointer
)	O
==	O
0	int
)	O
{	O
flags	int
|=	O
GDBM_RCVR_FORCE	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
arg	pointer
,	O
"summary"	pointer
)	O
==	O
0	int
)	O
{	O
summary	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
arg	pointer
,	O
"backup"	pointer
)	O
==	O
0	int
)	O
{	O
flags	int
|=	O
GDBM_RCVR_BACKUP	int
;	O
}	O
else	O
if	O
(	O
strncmp	function
(	O
arg	pointer
,	O
"max-failures="	pointer
,	O
13	int
)	O
==	O
0	int
)	O
{	O
rcvr	pointer
.	O
max_failures	long
=	O
strtoul	function
(	O
arg	pointer
+	O
13	int
,	O
&	O
p	pointer
,	O
10	int
)	O
;	O
if	O
(	O
*	O
p	pointer
)	O
{	O
printf	function
(	O
_	O
(	O
"not a number (stopped near %s)\n"	pointer
)	O
,	O
p	pointer
)	O
;	O
return	O
;	O
}	O
flags	int
|=	O
GDBM_RCVR_MAX_FAILURES	int
;	O
}	O
else	O
if	O
(	O
strncmp	function
(	O
arg	pointer
,	O
"max-failed-keys="	pointer
,	O
16	int
)	O
==	O
0	int
)	O
{	O
rcvr	pointer
.	O
max_failed_keys	long
=	O
strtoul	function
(	O
arg	pointer
+	O
16	int
,	O
&	O
p	pointer
,	O
10	int
)	O
;	O
if	O
(	O
*	O
p	pointer
)	O
{	O
printf	function
(	O
_	O
(	O
"not a number (stopped near %s)\n"	pointer
)	O
,	O
p	pointer
)	O
;	O
return	O
;	O
}	O
flags	int
|=	O
GDBM_RCVR_MAX_FAILED_KEYS	int
;	O
}	O
else	O
if	O
(	O
strncmp	function
(	O
arg	pointer
,	O
"max-failed-buckets="	pointer
,	O
19	int
)	O
==	O
0	int
)	O
{	O
rcvr	pointer
.	O
max_failures	long
=	O
strtoul	function
(	O
arg	pointer
+	O
19	int
,	O
&	O
p	pointer
,	O
10	int
)	O
;	O
if	O
(	O
*	O
p	pointer
)	O
{	O
printf	function
(	O
_	O
(	O
"not a number (stopped near %s)\n"	pointer
)	O
,	O
p	pointer
)	O
;	O
return	O
;	O
}	O
flags	int
|=	O
GDBM_RCVR_MAX_FAILED_BUCKETS	int
;	O
}	O
else	O
{	O
terror	function
(	O
_	O
(	O
"unrecognized argument: %s"	pointer
)	O
,	O
arg	pointer
)	O
;	O
return	O
;	O
}	O
}	O
rc	int
=	O
gdbm_recover	function
(	O
gdbm_file	pointer
,	O
&	O
rcvr	pointer
,	O
flags	int
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
fprintf	function
(	O
param	pointer
->	O
fp	pointer
,	O
_	O
(	O
"Recovery succeeded.\n"	pointer
)	O
)	O
;	O
if	O
(	O
summary	int
)	O
{	O
fprintf	function
(	O
param	pointer
->	O
fp	pointer
,	O
_	O
(	O
"Keys recovered: %lu, failed: %lu, duplicate: %lu\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
rcvr	pointer
.	O
recovered_keys	long
,	O
(	O
unsigned	O
long	O
)	O
rcvr	pointer
.	O
failed_keys	long
,	O
(	O
unsigned	O
long	O
)	O
rcvr	pointer
.	O
duplicate_keys	long
)	O
;	O
fprintf	function
(	O
param	pointer
->	O
fp	pointer
,	O
_	O
(	O
"Buckets recovered: %lu, failed: %lu\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
rcvr	pointer
.	O
recovered_buckets	long
,	O
(	O
unsigned	O
long	O
)	O
rcvr	pointer
.	O
failed_buckets	long
)	O
;	O
}	O
if	O
(	O
rcvr	pointer
.	O
backup_name	pointer
)	O
{	O
fprintf	function
(	O
param	pointer
->	O
fp	pointer
,	O
_	O
(	O
"Original database preserved in file %s"	pointer
)	O
,	O
rcvr	pointer
.	O
backup_name	pointer
)	O
;	O
free	function
(	O
rcvr	pointer
.	O
backup_name	pointer
)	O
;	O
}	O
fputc	function
(	O
'\n'	O
,	O
param	pointer
->	O
fp	pointer
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Recovery failed: %s"	pointer
)	O
,	O
gdbm_strerror	function
(	O
gdbm_errno	O
)	O
)	O
;	O
if	O
(	O
gdbm_syserr	array
[	O
gdbm_errno	O
]	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
": %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
fputc	function
(	O
'\n'	O
,	O
stderr	pointer
)	O
;	O
}	O
}	O
int	O
avail_begin	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
GDBM_ARG_UNUSED	O
,	O
size_t	long
*	O
exp_count	pointer
)	O
{	O
if	O
(	O
checkdb	function
(	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
exp_count	pointer
)	O
*	O
exp_count	pointer
=	O
_gdbm_avail_list_size	function
(	O
gdbm_file	pointer
,	O
SIZE_T_MAX	O
)	O
;	O
return	O
0	int
;	O
}	O
void	O
avail_handler	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
)	O
{	O
_gdbm_print_avail_list	function
(	O
param	pointer
->	O
fp	pointer
,	O
gdbm_file	pointer
)	O
;	O
}	O
int	O
print_current_bucket_begin	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
GDBM_ARG_UNUSED	O
,	O
size_t	long
*	O
exp_count	pointer
)	O
{	O
if	O
(	O
checkdb	function
(	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
!	O
gdbm_file	pointer
->	O
bucket	pointer
)	O
return	O
0	int
;	O
if	O
(	O
exp_count	pointer
)	O
*	O
exp_count	pointer
=	O
gdbm_file	pointer
->	O
bucket	pointer
?	O
bucket_print_lines	function
(	O
gdbm_file	pointer
->	O
bucket	pointer
)	O
+	O
3	int
:	O
1	int
;	O
return	O
0	int
;	O
}	O
void	O
print_current_bucket_handler	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
)	O
{	O
if	O
(	O
!	O
gdbm_file	pointer
->	O
bucket	pointer
)	O
fprintf	function
(	O
param	pointer
->	O
fp	pointer
,	O
_	O
(	O
"no current bucket\n"	pointer
)	O
)	O
;	O
else	O
{	O
if	O
(	O
param	pointer
->	O
argc	int
)	O
print_bucket	function
(	O
param	pointer
->	O
fp	pointer
,	O
gdbm_file	pointer
->	O
bucket	pointer
,	O
_	O
(	O
"Bucket #%s"	pointer
)	O
,	O
PARAM_STRING	O
(	O
param	pointer
,	O
0	int
)	O
)	O
;	O
else	O
print_bucket	function
(	O
param	pointer
->	O
fp	pointer
,	O
gdbm_file	pointer
->	O
bucket	pointer
,	O
"%s"	pointer
,	O
_	O
(	O
"Current bucket"	pointer
)	O
)	O
;	O
fprintf	function
(	O
param	pointer
->	O
fp	pointer
,	O
_	O
(	O
"\n current directory entry = %d.\n"	pointer
)	O
,	O
gdbm_file	pointer
->	O
bucket_dir	int
)	O
;	O
fprintf	function
(	O
param	pointer
->	O
fp	pointer
,	O
_	O
(	O
" current bucket address  = %lu.\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
gdbm_file	pointer
->	O
cache_entry	pointer
->	O
ca_adr	long
)	O
;	O
}	O
}	O
int	O
getnum	function
(	O
int	O
*	O
pnum	pointer
,	O
char	O
*	O
arg	pointer
,	O
char	O
*	O
*	O
endp	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
unsigned	O
long	O
x	long
=	O
strtoul	function
(	O
arg	pointer
,	O
&	O
p	pointer
,	O
10	int
)	O
;	O
if	O
(	O
*	O
p	pointer
&&	O
!	O
isspace	function
(	O
*	O
p	pointer
)	O
)	O
{	O
printf	function
(	O
_	O
(	O
"not a number (stopped near %s)\n"	pointer
)	O
,	O
p	pointer
)	O
;	O
return	O
1	int
;	O
}	O
while	O
(	O
*	O
p	pointer
&&	O
isspace	function
(	O
*	O
p	pointer
)	O
)	O
p	pointer
++	O
;	O
if	O
(	O
endp	pointer
)	O
*	O
endp	pointer
=	O
p	pointer
;	O
else	O
if	O
(	O
*	O
p	pointer
)	O
{	O
printf	function
(	O
_	O
(	O
"not a number (stopped near %s)\n"	pointer
)	O
,	O
p	pointer
)	O
;	O
return	O
1	int
;	O
}	O
*	O
pnum	pointer
=	O
x	long
;	O
return	O
0	int
;	O
}	O
int	O
print_bucket_begin	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
,	O
size_t	long
*	O
exp_count	pointer
)	O
{	O
int	O
temp	int
;	O
if	O
(	O
checkdb	function
(	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
getnum	function
(	O
&	O
temp	int
,	O
PARAM_STRING	O
(	O
param	pointer
,	O
0	int
)	O
,	O
NULL	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
temp	int
>=	O
GDBM_DIR_COUNT	O
(	O
gdbm_file	pointer
)	O
)	O
{	O
terror	function
(	O
_	O
(	O
"Not a bucket."	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
_gdbm_get_bucket	function
(	O
gdbm_file	pointer
,	O
temp	int
)	O
)	O
{	O
terror	function
(	O
"%s"	pointer
,	O
gdbm_db_strerror	function
(	O
gdbm_file	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
exp_count	pointer
)	O
*	O
exp_count	pointer
=	O
bucket_print_lines	function
(	O
gdbm_file	pointer
->	O
bucket	pointer
)	O
+	O
3	int
;	O
return	O
0	int
;	O
}	O
int	O
print_dir_begin	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
GDBM_ARG_UNUSED	O
,	O
size_t	long
*	O
exp_count	pointer
)	O
{	O
if	O
(	O
checkdb	function
(	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
exp_count	pointer
)	O
*	O
exp_count	pointer
=	O
GDBM_DIR_COUNT	O
(	O
gdbm_file	pointer
)	O
+	O
3	int
;	O
return	O
0	int
;	O
}	O
static	O
size_t	long
bucket_count	function
(	O
void	O
)	O
{	O
int	O
i	int
;	O
off_t	long
last	long
=	O
0	int
;	O
size_t	long
count	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
GDBM_DIR_COUNT	O
(	O
gdbm_file	pointer
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
gdbm_file	pointer
->	O
dir	long
[	O
i	int
]	O
!=	O
last	long
)	O
{	O
++	O
count	int
;	O
last	long
=	O
gdbm_file	pointer
->	O
dir	long
[	O
i	int
]	O
;	O
}	O
}	O
return	O
count	int
;	O
}	O
void	O
print_dir_handler	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
)	O
{	O
int	O
i	int
;	O
fprintf	function
(	O
param	pointer
->	O
fp	pointer
,	O
_	O
(	O
"Hash table directory.\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
param	pointer
->	O
fp	pointer
,	O
_	O
(	O
"  Size =  %d.  Bits = %d,  Buckets = %zu.\n\n"	pointer
)	O
,	O
gdbm_file	pointer
->	O
header	pointer
->	O
dir_size	int
,	O
gdbm_file	pointer
->	O
header	pointer
->	O
dir_bits	int
,	O
bucket_count	function
(	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
GDBM_DIR_COUNT	O
(	O
gdbm_file	pointer
)	O
;	O
i	int
++	O
)	O
fprintf	function
(	O
param	pointer
->	O
fp	pointer
,	O
"  %10d:  %12lu\n"	pointer
,	O
i	int
,	O
(	O
unsigned	O
long	O
)	O
gdbm_file	pointer
->	O
dir	long
[	O
i	int
]	O
)	O
;	O
}	O
int	O
print_header_begin	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
GDBM_ARG_UNUSED	O
,	O
size_t	long
*	O
exp_count	pointer
)	O
{	O
if	O
(	O
checkdb	function
(	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
exp_count	pointer
)	O
*	O
exp_count	pointer
=	O
14	int
;	O
return	O
0	int
;	O
}	O
void	O
print_header_handler	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
)	O
{	O
FILE	struct
*	O
fp	pointer
=	O
param	pointer
->	O
fp	pointer
;	O
fprintf	function
(	O
fp	pointer
,	O
_	O
(	O
"\nFile Header: \n\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
_	O
(	O
"  table        = %lu\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
gdbm_file	pointer
->	O
header	pointer
->	O
dir	long
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
_	O
(	O
"  table size   = %d\n"	pointer
)	O
,	O
gdbm_file	pointer
->	O
header	pointer
->	O
dir_size	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
_	O
(	O
"  table bits   = %d\n"	pointer
)	O
,	O
gdbm_file	pointer
->	O
header	pointer
->	O
dir_bits	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
_	O
(	O
"  block size   = %d\n"	pointer
)	O
,	O
gdbm_file	pointer
->	O
header	pointer
->	O
block_size	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
_	O
(	O
"  bucket elems = %d\n"	pointer
)	O
,	O
gdbm_file	pointer
->	O
header	pointer
->	O
bucket_elems	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
_	O
(	O
"  bucket size  = %d\n"	pointer
)	O
,	O
gdbm_file	pointer
->	O
header	pointer
->	O
bucket_size	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
_	O
(	O
"  header magic = %x\n"	pointer
)	O
,	O
gdbm_file	pointer
->	O
header	pointer
->	O
header_magic	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
_	O
(	O
"  next block   = %lu\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
gdbm_file	pointer
->	O
header	pointer
->	O
next_block	long
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
_	O
(	O
"  avail size   = %d\n"	pointer
)	O
,	O
gdbm_file	pointer
->	O
header	pointer
->	O
avail	struct
.	O
size	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
_	O
(	O
"  avail count  = %d\n"	pointer
)	O
,	O
gdbm_file	pointer
->	O
header	pointer
->	O
avail	struct
.	O
count	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
_	O
(	O
"  avail nx blk = %lu\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
gdbm_file	pointer
->	O
header	pointer
->	O
avail	struct
.	O
next_block	long
)	O
;	O
}	O
void	O
hash_handler	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
)	O
{	O
if	O
(	O
gdbm_file	pointer
)	O
{	O
int	O
hashval	int
,	O
bucket	pointer
,	O
off	long
;	O
_gdbm_hash_key	function
(	O
gdbm_file	pointer
,	O
PARAM_DATUM	O
(	O
param	pointer
,	O
0	int
)	O
,	O
&	O
hashval	int
,	O
&	O
bucket	pointer
,	O
&	O
off	long
)	O
;	O
fprintf	function
(	O
param	pointer
->	O
fp	pointer
,	O
_	O
(	O
"hash value = %x, bucket #%u, slot %u"	pointer
)	O
,	O
hashval	int
,	O
hashval	int
>>	O
(	O
GDBM_HASH_BITS	int
-	O
gdbm_file	pointer
->	O
header	pointer
->	O
dir_bits	int
)	O
,	O
hashval	int
%	O
gdbm_file	pointer
->	O
header	pointer
->	O
bucket_elems	int
)	O
;	O
}	O
else	O
fprintf	function
(	O
param	pointer
->	O
fp	pointer
,	O
_	O
(	O
"hash value = %x"	pointer
)	O
,	O
_gdbm_hash	function
(	O
PARAM_DATUM	O
(	O
param	pointer
,	O
0	int
)	O
)	O
)	O
;	O
fprintf	function
(	O
param	pointer
->	O
fp	pointer
,	O
".\n"	pointer
)	O
;	O
}	O
int	O
print_cache_begin	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
GDBM_ARG_UNUSED	O
,	O
size_t	long
*	O
exp_count	pointer
)	O
{	O
if	O
(	O
checkdb	function
(	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
exp_count	pointer
)	O
*	O
exp_count	pointer
=	O
gdbm_file	pointer
->	O
bucket_cache	pointer
?	O
gdbm_file	pointer
->	O
cache_size	long
+	O
1	int
:	O
1	int
;	O
return	O
0	int
;	O
}	O
void	O
print_cache_handler	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
)	O
{	O
_gdbm_print_bucket_cache	function
(	O
param	pointer
->	O
fp	pointer
,	O
gdbm_file	pointer
)	O
;	O
}	O
void	O
print_version_handler	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
)	O
{	O
fprintf	function
(	O
param	pointer
->	O
fp	pointer
,	O
"%s\n"	pointer
,	O
gdbm_version	pointer
)	O
;	O
}	O
int	O
list_begin	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
GDBM_ARG_UNUSED	O
,	O
size_t	long
*	O
exp_count	pointer
)	O
{	O
if	O
(	O
checkdb	function
(	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
exp_count	pointer
)	O
{	O
gdbm_count_t	long long
count	int
;	O
if	O
(	O
gdbm_count	function
(	O
gdbm_file	pointer
,	O
&	O
count	int
)	O
)	O
*	O
exp_count	pointer
=	O
0	int
;	O
else	O
if	O
(	O
count	int
>	O
SIZE_T_MAX	O
)	O
*	O
exp_count	pointer
=	O
SIZE_T_MAX	O
;	O
else	O
*	O
exp_count	pointer
=	O
count	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
list_handler	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
)	O
{	O
datum	struct
key	struct
;	O
datum	struct
data	pointer
;	O
key	struct
=	O
gdbm_firstkey	function
(	O
gdbm_file	pointer
)	O
;	O
while	O
(	O
key	struct
.	O
dptr	pointer
)	O
{	O
datum	struct
nextkey	struct
=	O
gdbm_nextkey	function
(	O
gdbm_file	pointer
,	O
key	struct
)	O
;	O
data	pointer
=	O
gdbm_fetch	function
(	O
gdbm_file	pointer
,	O
key	struct
)	O
;	O
if	O
(	O
!	O
data	pointer
.	O
dptr	pointer
)	O
{	O
terror	function
(	O
_	O
(	O
"%s; the key was:"	pointer
)	O
,	O
gdbm_db_strerror	function
(	O
gdbm_file	pointer
)	O
)	O
;	O
datum_format	function
(	O
stderr	pointer
,	O
&	O
key	struct
,	O
dsdef	array
[	O
DS_KEY	int
]	O
)	O
;	O
}	O
else	O
{	O
datum_format	function
(	O
param	pointer
->	O
fp	pointer
,	O
&	O
key	struct
,	O
dsdef	array
[	O
DS_KEY	int
]	O
)	O
;	O
fputc	function
(	O
' '	O
,	O
param	pointer
->	O
fp	pointer
)	O
;	O
datum_format	function
(	O
param	pointer
->	O
fp	pointer
,	O
&	O
data	pointer
,	O
dsdef	array
[	O
DS_CONTENT	int
]	O
)	O
;	O
fputc	function
(	O
'\n'	O
,	O
param	pointer
->	O
fp	pointer
)	O
;	O
free	function
(	O
data	pointer
.	O
dptr	pointer
)	O
;	O
}	O
free	function
(	O
key	struct
.	O
dptr	pointer
)	O
;	O
key	struct
=	O
nextkey	struct
;	O
}	O
}	O
void	O
quit_handler	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
GDBM_ARG_UNUSED	O
)	O
{	O
closedb	function
(	O
)	O
;	O
input_done	function
(	O
)	O
;	O
exit	function
(	O
EXIT_OK	int
)	O
;	O
}	O
void	O
export_handler	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
)	O
{	O
int	O
format	pointer
=	O
GDBM_DUMP_FMT_ASCII	int
;	O
int	O
flags	int
=	O
GDBM_WRCREAT	int
;	O
int	O
i	int
;	O
int	O
filemode	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
param	pointer
->	O
argc	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
PARAM_STRING	O
(	O
param	pointer
,	O
i	int
)	O
,	O
"truncate"	pointer
)	O
==	O
0	int
)	O
flags	int
=	O
GDBM_NEWDB	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
PARAM_STRING	O
(	O
param	pointer
,	O
i	int
)	O
,	O
"binary"	pointer
)	O
==	O
0	int
)	O
format	pointer
=	O
GDBM_DUMP_FMT_BINARY	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
PARAM_STRING	O
(	O
param	pointer
,	O
i	int
)	O
,	O
"ascii"	pointer
)	O
==	O
0	int
)	O
format	pointer
=	O
GDBM_DUMP_FMT_ASCII	int
;	O
else	O
{	O
terror	function
(	O
_	O
(	O
"unrecognized argument: %s"	pointer
)	O
,	O
PARAM_STRING	O
(	O
param	pointer
,	O
i	int
)	O
)	O
;	O
return	O
;	O
}	O
}	O
if	O
(	O
variable_get	function
(	O
"filemode"	pointer
,	O
VART_INT	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
filemode	int
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
gdbm_dump	function
(	O
gdbm_file	pointer
,	O
PARAM_STRING	O
(	O
param	pointer
,	O
0	int
)	O
,	O
format	pointer
,	O
flags	int
,	O
filemode	int
)	O
)	O
{	O
terror	function
(	O
_	O
(	O
"error dumping database: %s"	pointer
)	O
,	O
gdbm_strerror	function
(	O
gdbm_errno	O
)	O
)	O
;	O
}	O
}	O
void	O
import_handler	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
)	O
{	O
int	O
flag	int
=	O
GDBM_INSERT	int
;	O
unsigned	O
long	O
err_line	long
;	O
int	O
meta_mask	int
=	O
0	int
;	O
int	O
i	int
;	O
int	O
rc	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
param	pointer
->	O
argc	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
PARAM_STRING	O
(	O
param	pointer
,	O
i	int
)	O
,	O
"replace"	pointer
)	O
==	O
0	int
)	O
flag	int
=	O
GDBM_REPLACE	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
PARAM_STRING	O
(	O
param	pointer
,	O
i	int
)	O
,	O
"nometa"	pointer
)	O
==	O
0	int
)	O
meta_mask	int
=	O
GDBM_META_MASK_MODE	int
|	O
GDBM_META_MASK_OWNER	int
;	O
else	O
{	O
terror	function
(	O
_	O
(	O
"unrecognized argument: %s"	pointer
)	O
,	O
PARAM_STRING	O
(	O
param	pointer
,	O
i	int
)	O
)	O
;	O
return	O
;	O
}	O
}	O
rc	int
=	O
gdbm_load	function
(	O
&	O
gdbm_file	pointer
,	O
PARAM_STRING	O
(	O
param	pointer
,	O
0	int
)	O
,	O
flag	int
,	O
meta_mask	int
,	O
&	O
err_line	long
)	O
;	O
if	O
(	O
rc	int
&&	O
gdbm_errno	O
==	O
GDBM_NO_DBNAME	int
)	O
{	O
int	O
t	int
=	O
open_mode	int
;	O
open_mode	int
=	O
GDBM_NEWDB	int
;	O
rc	int
=	O
checkdb	function
(	O
)	O
;	O
open_mode	int
=	O
t	int
;	O
if	O
(	O
rc	int
)	O
return	O
;	O
rc	int
=	O
gdbm_load	function
(	O
&	O
gdbm_file	pointer
,	O
PARAM_STRING	O
(	O
param	pointer
,	O
0	int
)	O
,	O
flag	int
,	O
meta_mask	int
,	O
&	O
err_line	long
)	O
;	O
}	O
if	O
(	O
rc	int
)	O
{	O
switch	O
(	O
gdbm_errno	O
)	O
{	O
case	O
GDBM_ERR_FILE_OWNER	int
:	O
case	O
GDBM_ERR_FILE_MODE	int
:	O
terror	function
(	O
_	O
(	O
"error restoring metadata: %s (%s)"	pointer
)	O
,	O
gdbm_strerror	function
(	O
gdbm_errno	O
)	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
err_line	long
)	O
terror	function
(	O
"%s:%lu: %s"	pointer
,	O
PARAM_STRING	O
(	O
param	pointer
,	O
0	int
)	O
,	O
err_line	long
,	O
gdbm_strerror	function
(	O
gdbm_errno	O
)	O
)	O
;	O
else	O
terror	function
(	O
_	O
(	O
"cannot load from %s: %s"	pointer
)	O
,	O
PARAM_STRING	O
(	O
param	pointer
,	O
0	int
)	O
,	O
gdbm_strerror	function
(	O
gdbm_errno	O
)	O
)	O
;	O
}	O
return	O
;	O
}	O
free	function
(	O
file_name	pointer
)	O
;	O
if	O
(	O
gdbm_setopt	function
(	O
gdbm_file	pointer
,	O
GDBM_GETDBNAME	int
,	O
&	O
file_name	pointer
,	O
sizeof	O
(	O
file_name	pointer
)	O
)	O
)	O
terror	function
(	O
_	O
(	O
"gdbm_setopt failed: %s"	pointer
)	O
,	O
gdbm_strerror	function
(	O
gdbm_errno	O
)	O
)	O
;	O
}	O
void	O
status_handler	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
)	O
{	O
if	O
(	O
file_name	pointer
)	O
fprintf	function
(	O
param	pointer
->	O
fp	pointer
,	O
_	O
(	O
"Database file: %s\n"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
else	O
fprintf	function
(	O
param	pointer
->	O
fp	pointer
,	O
"%s\n"	pointer
,	O
_	O
(	O
"No database name"	pointer
)	O
)	O
;	O
if	O
(	O
gdbm_file	pointer
)	O
fprintf	function
(	O
param	pointer
->	O
fp	pointer
,	O
"%s\n"	pointer
,	O
_	O
(	O
"Database is open"	pointer
)	O
)	O
;	O
else	O
fprintf	function
(	O
param	pointer
->	O
fp	pointer
,	O
"%s\n"	pointer
,	O
_	O
(	O
"Database is not open"	pointer
)	O
)	O
;	O
dsprint	function
(	O
param	pointer
->	O
fp	pointer
,	O
DS_KEY	int
,	O
dsdef	array
[	O
DS_KEY	int
]	O
)	O
;	O
dsprint	function
(	O
param	pointer
->	O
fp	pointer
,	O
DS_CONTENT	int
,	O
dsdef	array
[	O
DS_CONTENT	int
]	O
)	O
;	O
}	O
void	O
debug_handler	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
)	O
{	O
terror	function
(	O
"%s"	pointer
,	O
_	O
(	O
"compiled without debug support"	pointer
)	O
)	O
;	O
}	O
void	O
source_handler	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
)	O
{	O
char	O
*	O
fname	pointer
=	O
tildexpand	function
(	O
PARAM_STRING	O
(	O
param	pointer
,	O
0	int
)	O
)	O
;	O
instream_t	pointer
istr	pointer
=	O
instream_file_create	function
(	O
fname	pointer
)	O
;	O
free	function
(	O
fname	pointer
)	O
;	O
if	O
(	O
istr	pointer
&&	O
input_context_push	function
(	O
istr	pointer
)	O
==	O
0	int
)	O
yyparse	function
(	O
)	O
;	O
}	O
void	O
help_handler	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
)	O
;	O
int	O
help_begin	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
,	O
size_t	long
*	O
exp_count	pointer
)	O
;	O
struct	O
argdef	struct
{	O
char	O
*	O
name	pointer
;	O
int	O
type	int
;	O
int	O
ds	pointer
;	O
}	O
;	O
enum	O
command_repeat_type	enum
{	O
REPEAT_NEVER	int
,	O
REPEAT_ALWAYS	int
,	O
REPEAT_NOARG	int
}	O
;	O
struct	O
command	struct
{	O
char	O
*	O
name	pointer
;	O
size_t	long
len	int
;	O
int	O
tok	int
;	O
int	O
(	O
*	O
begin	pointer
)	O
(	O
struct	O
handler_param	struct
*	O
param	pointer
,	O
size_t	long
*	O
)	O
;	O
void	O
(	O
*	O
handler	pointer
)	O
(	O
struct	O
handler_param	struct
*	O
param	pointer
)	O
;	O
void	O
(	O
*	O
end	struct
)	O
(	O
void	O
*	O
data	pointer
)	O
;	O
struct	O
argdef	struct
args	array
[	O
NARGS	int
]	O
;	O
int	O
variadic	int
;	O
enum	O
command_repeat_type	enum
repeat	enum
;	O
char	O
*	O
doc	pointer
;	O
}	O
;	O
struct	O
command	struct
command_tab	array
[	O
]	O
=	O
{	O
{	O
S	O
(	O
count	int
)	O
,	O
T_CMD	int
,	O
checkdb_begin	function
,	O
count_handler	function
,	O
NULL	O
,	O
{	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"count (number of entries)"	pointer
)	O
}	O
,	O
{	O
S	O
(	O
delete	O
)	O
,	O
T_CMD	int
,	O
checkdb_begin	function
,	O
delete_handler	function
,	O
NULL	O
,	O
{	O
{	O
N_	O
(	O
"KEY"	pointer
)	O
,	O
GDBM_ARG_DATUM	int
,	O
DS_KEY	int
}	O
,	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"delete a record"	pointer
)	O
}	O
,	O
{	O
S	O
(	O
export	O
)	O
,	O
T_CMD	int
,	O
checkdb_begin	function
,	O
export_handler	function
,	O
NULL	O
,	O
{	O
{	O
N_	O
(	O
"FILE"	pointer
)	O
,	O
GDBM_ARG_STRING	int
}	O
,	O
{	O
"[truncate]"	pointer
,	O
GDBM_ARG_STRING	int
}	O
,	O
{	O
"[binary|ascii]"	pointer
,	O
GDBM_ARG_STRING	int
}	O
,	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"export"	pointer
)	O
}	O
,	O
{	O
S	O
(	O
fetch	O
)	O
,	O
T_CMD	int
,	O
checkdb_begin	function
,	O
fetch_handler	function
,	O
NULL	O
,	O
{	O
{	O
N_	O
(	O
"KEY"	pointer
)	O
,	O
GDBM_ARG_DATUM	int
,	O
DS_KEY	int
}	O
,	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"fetch record"	pointer
)	O
}	O
,	O
{	O
S	O
(	O
import	O
)	O
,	O
T_CMD	int
,	O
NULL	O
,	O
import_handler	function
,	O
NULL	O
,	O
{	O
{	O
N_	O
(	O
"FILE"	pointer
)	O
,	O
GDBM_ARG_STRING	int
}	O
,	O
{	O
"[replace]"	pointer
,	O
GDBM_ARG_STRING	int
}	O
,	O
{	O
"[nometa]"	pointer
,	O
GDBM_ARG_STRING	int
}	O
,	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
FALSE	int
,	O
N_	O
(	O
"import"	pointer
)	O
}	O
,	O
{	O
S	O
(	O
list	O
)	O
,	O
T_CMD	int
,	O
list_begin	function
,	O
list_handler	function
,	O
NULL	O
,	O
{	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"list"	pointer
)	O
}	O
,	O
{	O
S	O
(	O
next	pointer
)	O
,	O
T_CMD	int
,	O
checkdb_begin	function
,	O
nextkey_handler	function
,	O
NULL	O
,	O
{	O
{	O
N_	O
(	O
"[KEY]"	pointer
)	O
,	O
GDBM_ARG_DATUM	int
,	O
DS_KEY	int
}	O
,	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NOARG	int
,	O
N_	O
(	O
"nextkey"	pointer
)	O
}	O
,	O
{	O
S	O
(	O
store	O
)	O
,	O
T_CMD	int
,	O
checkdb_begin	function
,	O
store_handler	function
,	O
NULL	O
,	O
{	O
{	O
N_	O
(	O
"KEY"	pointer
)	O
,	O
GDBM_ARG_DATUM	int
,	O
DS_KEY	int
}	O
,	O
{	O
N_	O
(	O
"DATA"	pointer
)	O
,	O
GDBM_ARG_DATUM	int
,	O
DS_CONTENT	int
}	O
,	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"store"	pointer
)	O
}	O
,	O
{	O
S	O
(	O
first	O
)	O
,	O
T_CMD	int
,	O
checkdb_begin	function
,	O
firstkey_handler	function
,	O
NULL	O
,	O
{	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"firstkey"	pointer
)	O
}	O
,	O
{	O
S	O
(	O
reorganize	O
)	O
,	O
T_CMD	int
,	O
checkdb_begin	function
,	O
reorganize_handler	function
,	O
NULL	O
,	O
{	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"reorganize"	pointer
)	O
}	O
,	O
{	O
S	O
(	O
recover	O
)	O
,	O
T_CMD	int
,	O
checkdb_begin	function
,	O
recover_handler	function
,	O
NULL	O
,	O
{	O
{	O
"[verbose]"	pointer
,	O
GDBM_ARG_STRING	int
}	O
,	O
{	O
"[summary]"	pointer
,	O
GDBM_ARG_STRING	int
}	O
,	O
{	O
"[backup]"	pointer
,	O
GDBM_ARG_STRING	int
}	O
,	O
{	O
"[force]"	pointer
,	O
GDBM_ARG_STRING	int
}	O
,	O
{	O
"[max-failed-keys=N]"	pointer
,	O
GDBM_ARG_STRING	int
}	O
,	O
{	O
"[max-failed-buckets=N]"	pointer
,	O
GDBM_ARG_STRING	int
}	O
,	O
{	O
"[max-failures=N]"	pointer
,	O
GDBM_ARG_STRING	int
}	O
,	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"recover the database"	pointer
)	O
}	O
,	O
{	O
S	O
(	O
avail	struct
)	O
,	O
T_CMD	int
,	O
avail_begin	function
,	O
avail_handler	function
,	O
NULL	O
,	O
{	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"print avail list"	pointer
)	O
}	O
,	O
{	O
S	O
(	O
bucket	pointer
)	O
,	O
T_CMD	int
,	O
print_bucket_begin	function
,	O
print_current_bucket_handler	function
,	O
NULL	O
,	O
{	O
{	O
N_	O
(	O
"NUMBER"	pointer
)	O
,	O
GDBM_ARG_STRING	int
}	O
,	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"print a bucket"	pointer
)	O
}	O
,	O
{	O
S	O
(	O
current	O
)	O
,	O
T_CMD	int
,	O
print_current_bucket_begin	function
,	O
print_current_bucket_handler	function
,	O
NULL	O
,	O
{	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"print current bucket"	pointer
)	O
}	O
,	O
{	O
S	O
(	O
dir	long
)	O
,	O
T_CMD	int
,	O
print_dir_begin	function
,	O
print_dir_handler	function
,	O
NULL	O
,	O
{	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"print hash directory"	pointer
)	O
}	O
,	O
{	O
S	O
(	O
header	pointer
)	O
,	O
T_CMD	int
,	O
print_header_begin	function
,	O
print_header_handler	function
,	O
NULL	O
,	O
{	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"print database file header"	pointer
)	O
}	O
,	O
{	O
S	O
(	O
hash	pointer
)	O
,	O
T_CMD	int
,	O
NULL	O
,	O
hash_handler	function
,	O
NULL	O
,	O
{	O
{	O
N_	O
(	O
"KEY"	pointer
)	O
,	O
GDBM_ARG_DATUM	int
,	O
DS_KEY	int
}	O
,	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"hash value of key"	pointer
)	O
}	O
,	O
{	O
S	O
(	O
cache	O
)	O
,	O
T_CMD	int
,	O
print_cache_begin	function
,	O
print_cache_handler	function
,	O
NULL	O
,	O
{	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"print the bucket cache"	pointer
)	O
}	O
,	O
{	O
S	O
(	O
status	O
)	O
,	O
T_CMD	int
,	O
NULL	O
,	O
status_handler	function
,	O
NULL	O
,	O
{	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"print current program status"	pointer
)	O
}	O
,	O
{	O
S	O
(	O
version	O
)	O
,	O
T_CMD	int
,	O
NULL	O
,	O
print_version_handler	function
,	O
NULL	O
,	O
{	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"print version of gdbm"	pointer
)	O
}	O
,	O
{	O
S	O
(	O
help	O
)	O
,	O
T_CMD	int
,	O
help_begin	function
,	O
help_handler	function
,	O
NULL	O
,	O
{	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"print this help list"	pointer
)	O
}	O
,	O
{	O
S	O
(	O
quit	O
)	O
,	O
T_CMD	int
,	O
NULL	O
,	O
quit_handler	function
,	O
NULL	O
,	O
{	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"quit the program"	pointer
)	O
}	O
,	O
{	O
S	O
(	O
set	O
)	O
,	O
T_SET	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
{	O
{	O
"[VAR=VALUE...]"	pointer
}	O
,	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"set or list variables"	pointer
)	O
}	O
,	O
{	O
S	O
(	O
unset	O
)	O
,	O
T_UNSET	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
{	O
{	O
"VAR..."	pointer
}	O
,	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"unset variables"	pointer
)	O
}	O
,	O
{	O
S	O
(	O
define	O
)	O
,	O
T_DEF	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
{	O
{	O
"key|content"	pointer
,	O
GDBM_ARG_STRING	int
}	O
,	O
{	O
"{ FIELD-LIST }"	pointer
,	O
GDBM_ARG_STRING	int
}	O
,	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"define datum structure"	pointer
)	O
}	O
,	O
{	O
S	O
(	O
source	pointer
)	O
,	O
T_CMD	int
,	O
NULL	O
,	O
source_handler	function
,	O
NULL	O
,	O
{	O
{	O
"FILE"	pointer
,	O
GDBM_ARG_STRING	int
}	O
,	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"source command script"	pointer
)	O
}	O
,	O
{	O
S	O
(	O
close	function
)	O
,	O
T_CMD	int
,	O
NULL	O
,	O
close_handler	function
,	O
NULL	O
,	O
{	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"close the database"	pointer
)	O
}	O
,	O
{	O
S	O
(	O
open	function
)	O
,	O
T_CMD	int
,	O
NULL	O
,	O
open_handler	function
,	O
NULL	O
,	O
{	O
{	O
"FILE"	pointer
,	O
GDBM_ARG_STRING	int
}	O
,	O
{	O
NULL	O
}	O
}	O
,	O
FALSE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"open new database"	pointer
)	O
}	O
,	O
{	O
S	O
(	O
debug	O
)	O
,	O
T_CMD	int
,	O
NULL	O
,	O
debug_handler	function
,	O
NULL	O
,	O
{	O
{	O
NULL	O
}	O
}	O
,	O
TRUE	int
,	O
REPEAT_NEVER	int
,	O
N_	O
(	O
"query/set debug level"	pointer
)	O
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
int	O
cmdcmp	function
(	O
const	O
void	O
*	O
a	array
,	O
const	O
void	O
*	O
b	array
)	O
{	O
struct	O
command	struct
const	O
*	O
ac	pointer
=	O
a	array
;	O
struct	O
command	struct
const	O
*	O
bc	pointer
=	O
b	array
;	O
return	O
strcmp	function
(	O
ac	pointer
->	O
name	pointer
,	O
bc	pointer
->	O
name	pointer
)	O
;	O
}	O
void	O
sort_commands	function
(	O
)	O
{	O
qsort	function
(	O
command_tab	array
,	O
sizeof	O
(	O
command_tab	array
)	O
/	O
sizeof	O
(	O
command_tab	array
[	O
0	int
]	O
)	O
-	O
1	int
,	O
sizeof	O
(	O
command_tab	array
[	O
0	int
]	O
)	O
,	O
cmdcmp	function
)	O
;	O
}	O
char	O
*	O
command_generator	function
(	O
const	O
char	O
*	O
text	pointer
,	O
int	O
state	pointer
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
static	O
int	O
len	int
;	O
static	O
struct	O
command	struct
*	O
cmd	pointer
;	O
if	O
(	O
!	O
state	pointer
)	O
{	O
cmd	pointer
=	O
command_tab	array
;	O
len	int
=	O
strlen	function
(	O
text	pointer
)	O
;	O
}	O
if	O
(	O
!	O
cmd	pointer
||	O
!	O
cmd	pointer
->	O
name	pointer
)	O
return	O
NULL	O
;	O
while	O
(	O
(	O
name	pointer
=	O
cmd	pointer
->	O
name	pointer
)	O
)	O
{	O
cmd	pointer
++	O
;	O
if	O
(	O
strncmp	function
(	O
name	pointer
,	O
text	pointer
,	O
len	int
)	O
==	O
0	int
)	O
return	O
strdup	function
(	O
name	pointer
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
int	O
help_begin	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
GDBM_ARG_UNUSED	O
,	O
size_t	long
*	O
exp_count	pointer
)	O
{	O
if	O
(	O
exp_count	pointer
)	O
*	O
exp_count	pointer
=	O
sizeof	O
(	O
command_tab	array
)	O
/	O
sizeof	O
(	O
command_tab	array
[	O
0	int
]	O
)	O
+	O
1	int
;	O
return	O
0	int
;	O
}	O
void	O
help_handler	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
)	O
{	O
struct	O
command	struct
*	O
cmd	pointer
;	O
FILE	struct
*	O
fp	pointer
=	O
param	pointer
->	O
fp	pointer
;	O
for	O
(	O
cmd	pointer
=	O
command_tab	array
;	O
cmd	pointer
->	O
name	pointer
;	O
cmd	pointer
++	O
)	O
{	O
int	O
i	int
;	O
int	O
n	int
;	O
n	int
=	O
fprintf	function
(	O
fp	pointer
,	O
" %s"	pointer
,	O
cmd	pointer
->	O
name	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NARGS	int
&&	O
cmd	pointer
->	O
args	array
[	O
i	int
]	O
.	O
name	pointer
;	O
i	int
++	O
)	O
n	int
+=	O
fprintf	function
(	O
fp	pointer
,	O
" %s"	pointer
,	O
gettext	function
(	O
cmd	pointer
->	O
args	array
[	O
i	int
]	O
.	O
name	pointer
)	O
)	O
;	O
if	O
(	O
n	int
<	O
CMDCOLS	int
)	O
fprintf	function
(	O
fp	pointer
,	O
"%*.s"	pointer
,	O
CMDCOLS	int
-	O
n	int
,	O
""	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
" %s"	pointer
,	O
gettext	function
(	O
cmd	pointer
->	O
doc	pointer
)	O
)	O
;	O
fputc	function
(	O
'\n'	O
,	O
fp	pointer
)	O
;	O
}	O
}	O
int	O
command_lookup	function
(	O
const	O
char	O
*	O
str	pointer
,	O
struct	O
locus	struct
*	O
loc	pointer
,	O
struct	O
command	struct
*	O
*	O
pcmd	pointer
)	O
{	O
enum	O
{	O
fcom_init	int
,	O
fcom_found	int
,	O
fcom_ambig	int
,	O
fcom_abort	int
}	O
state	pointer
=	O
fcom_init	int
;	O
struct	O
command	struct
*	O
cmd	pointer
,	O
*	O
found	pointer
=	O
NULL	O
;	O
size_t	long
len	int
=	O
strlen	function
(	O
str	pointer
)	O
;	O
for	O
(	O
cmd	pointer
=	O
command_tab	array
;	O
state	pointer
!=	O
fcom_abort	int
&&	O
cmd	pointer
->	O
name	pointer
;	O
cmd	pointer
++	O
)	O
{	O
if	O
(	O
memcmp	function
(	O
cmd	pointer
->	O
name	pointer
,	O
str	pointer
,	O
len	int
<	O
cmd	pointer
->	O
len	int
?	O
len	int
:	O
cmd	pointer
->	O
len	int
)	O
==	O
0	int
)	O
{	O
switch	O
(	O
state	pointer
)	O
{	O
case	O
fcom_init	int
:	O
found	pointer
=	O
cmd	pointer
;	O
state	pointer
=	O
fcom_found	int
;	O
break	O
;	O
case	O
fcom_found	int
:	O
if	O
(	O
!	O
interactive	function
(	O
)	O
)	O
{	O
state	pointer
=	O
fcom_abort	int
;	O
found	pointer
=	O
NULL	O
;	O
continue	O
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"ambiguous command: %s\n"	pointer
,	O
str	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"    %s\n"	pointer
,	O
found	pointer
->	O
name	pointer
)	O
;	O
found	pointer
=	O
NULL	O
;	O
state	pointer
=	O
fcom_ambig	int
;	O
case	O
fcom_ambig	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"    %s\n"	pointer
,	O
cmd	pointer
->	O
name	pointer
)	O
;	O
break	O
;	O
case	O
fcom_abort	int
:	O
abort	function
(	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
state	pointer
==	O
fcom_init	int
)	O
lerror	function
(	O
loc	pointer
,	O
interactive	function
(	O
)	O
?	O
_	O
(	O
"Invalid command. Try ? for help."	pointer
)	O
:	O
_	O
(	O
"Unknown command"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
found	pointer
)	O
return	O
T_BOGUS	int
;	O
*	O
pcmd	pointer
=	O
found	pointer
;	O
return	O
found	pointer
->	O
tok	int
;	O
}	O
char	O
*	O
parseopt_program_doc	pointer
=	O
N_	O
(	O
"examine and/or modify a GDBM database"	pointer
)	O
;	O
char	O
*	O
parseopt_program_args	pointer
=	O
N_	O
(	O
"DBFILE [COMMAND [ARG ...]]"	pointer
)	O
;	O
enum	O
{	O
OPT_LEX_TRACE	int
=	O
256	int
,	O
OPT_GRAM_TRACE	int
}	O
;	O
struct	O
gdbm_option	struct
optab	array
[	O
]	O
=	O
{	O
{	O
'b'	O
,	O
"block-size"	pointer
,	O
N_	O
(	O
"SIZE"	pointer
)	O
,	O
N_	O
(	O
"set block size"	pointer
)	O
}	O
,	O
{	O
'c'	O
,	O
"cache-size"	pointer
,	O
N_	O
(	O
"SIZE"	pointer
)	O
,	O
N_	O
(	O
"set cache size"	pointer
)	O
}	O
,	O
{	O
'f'	O
,	O
"file"	pointer
,	O
N_	O
(	O
"FILE"	pointer
)	O
,	O
N_	O
(	O
"read commands from FILE"	pointer
)	O
}	O
,	O
{	O
'g'	O
,	O
NULL	O
,	O
"FILE"	pointer
,	O
NULL	O
,	O
PARSEOPT_HIDDEN	int
}	O
,	O
{	O
'l'	O
,	O
"no-lock"	pointer
,	O
NULL	O
,	O
N_	O
(	O
"disable file locking"	pointer
)	O
}	O
,	O
{	O
'm'	O
,	O
"no-mmap"	pointer
,	O
NULL	O
,	O
N_	O
(	O
"do not use mmap"	pointer
)	O
}	O
,	O
{	O
'n'	O
,	O
"newdb"	pointer
,	O
NULL	O
,	O
N_	O
(	O
"create database"	pointer
)	O
}	O
,	O
{	O
'N'	O
,	O
"norc"	pointer
,	O
NULL	O
,	O
N_	O
(	O
"do not read .gdbmtoolrc file"	pointer
)	O
}	O
,	O
{	O
'r'	O
,	O
"read-only"	pointer
,	O
NULL	O
,	O
N_	O
(	O
"open database in read-only mode"	pointer
)	O
}	O
,	O
{	O
's'	O
,	O
"synchronize"	pointer
,	O
NULL	O
,	O
N_	O
(	O
"synchronize to disk after each write"	pointer
)	O
}	O
,	O
{	O
'q'	O
,	O
"quiet"	pointer
,	O
NULL	O
,	O
N_	O
(	O
"don't print initial banner"	pointer
)	O
}	O
,	O
{	O
0	int
}	O
}	O
;	O
struct	O
gdbmarg	struct
*	O
gdbmarg_string	function
(	O
char	O
*	O
string	pointer
,	O
struct	O
locus	struct
*	O
loc	pointer
)	O
{	O
struct	O
gdbmarg	struct
*	O
arg	pointer
=	O
ecalloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
arg	pointer
)	O
)	O
;	O
arg	pointer
->	O
next	pointer
=	O
NULL	O
;	O
arg	pointer
->	O
type	int
=	O
GDBM_ARG_STRING	int
;	O
arg	pointer
->	O
ref	int
=	O
1	int
;	O
if	O
(	O
loc	pointer
)	O
arg	pointer
->	O
loc	pointer
=	O
*	O
loc	pointer
;	O
arg	pointer
->	O
v	union
.	O
string	pointer
=	O
string	pointer
;	O
return	O
arg	pointer
;	O
}	O
struct	O
gdbmarg	struct
*	O
gdbmarg_datum	function
(	O
datum	struct
*	O
dat	struct
,	O
struct	O
locus	struct
*	O
loc	pointer
)	O
{	O
struct	O
gdbmarg	struct
*	O
arg	pointer
=	O
ecalloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
arg	pointer
)	O
)	O
;	O
arg	pointer
->	O
next	pointer
=	O
NULL	O
;	O
arg	pointer
->	O
type	int
=	O
GDBM_ARG_DATUM	int
;	O
arg	pointer
->	O
ref	int
=	O
1	int
;	O
if	O
(	O
loc	pointer
)	O
arg	pointer
->	O
loc	pointer
=	O
*	O
loc	pointer
;	O
arg	pointer
->	O
v	union
.	O
dat	struct
=	O
*	O
dat	struct
;	O
return	O
arg	pointer
;	O
}	O
struct	O
gdbmarg	struct
*	O
gdbmarg_kvpair	function
(	O
struct	O
kvpair	struct
*	O
kvp	pointer
,	O
struct	O
locus	struct
*	O
loc	pointer
)	O
{	O
struct	O
gdbmarg	struct
*	O
arg	pointer
=	O
ecalloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
arg	pointer
)	O
)	O
;	O
arg	pointer
->	O
next	pointer
=	O
NULL	O
;	O
arg	pointer
->	O
type	int
=	O
GDBM_ARG_KVPAIR	int
;	O
arg	pointer
->	O
ref	int
=	O
1	int
;	O
if	O
(	O
loc	pointer
)	O
arg	pointer
->	O
loc	pointer
=	O
*	O
loc	pointer
;	O
arg	pointer
->	O
v	union
.	O
kvpair	struct
=	O
kvp	pointer
;	O
return	O
arg	pointer
;	O
}	O
struct	O
slist	struct
*	O
slist_new_s	function
(	O
char	O
*	O
s	pointer
)	O
{	O
struct	O
slist	struct
*	O
lp	pointer
=	O
emalloc	function
(	O
sizeof	O
(	O
*	O
lp	pointer
)	O
)	O
;	O
lp	pointer
->	O
next	pointer
=	O
NULL	O
;	O
lp	pointer
->	O
str	pointer
=	O
s	pointer
;	O
return	O
lp	pointer
;	O
}	O
struct	O
slist	struct
*	O
slist_new	function
(	O
char	O
const	O
*	O
s	pointer
)	O
{	O
return	O
slist_new_s	function
(	O
estrdup	function
(	O
s	pointer
)	O
)	O
;	O
}	O
struct	O
slist	struct
*	O
slist_new_l	function
(	O
char	O
const	O
*	O
s	pointer
,	O
size_t	long
l	long
)	O
{	O
char	O
*	O
copy	pointer
=	O
emalloc	function
(	O
l	long
+	O
1	int
)	O
;	O
memcpy	function
(	O
copy	pointer
,	O
s	pointer
,	O
l	long
)	O
;	O
copy	pointer
[	O
l	long
]	O
=	O
0	int
;	O
return	O
slist_new_s	function
(	O
copy	pointer
)	O
;	O
}	O
void	O
slist_free	function
(	O
struct	O
slist	struct
*	O
lp	pointer
)	O
{	O
while	O
(	O
lp	pointer
)	O
{	O
struct	O
slist	struct
*	O
next	pointer
=	O
lp	pointer
->	O
next	pointer
;	O
free	function
(	O
lp	pointer
->	O
str	pointer
)	O
;	O
free	function
(	O
lp	pointer
)	O
;	O
lp	pointer
=	O
next	pointer
;	O
}	O
}	O
void	O
slist_insert	function
(	O
struct	O
slist	struct
*	O
*	O
where	pointer
,	O
struct	O
slist	struct
*	O
what	pointer
)	O
{	O
if	O
(	O
*	O
where	pointer
)	O
{	O
while	O
(	O
what	pointer
->	O
next	pointer
)	O
what	pointer
=	O
what	pointer
->	O
next	pointer
;	O
what	pointer
->	O
next	pointer
=	O
(	O
*	O
where	pointer
)	O
->	O
next	pointer
;	O
(	O
*	O
where	pointer
)	O
->	O
next	pointer
=	O
what	pointer
;	O
}	O
else	O
what	pointer
->	O
next	pointer
=	O
NULL	O
;	O
*	O
where	pointer
=	O
what	pointer
;	O
}	O
struct	O
kvpair	struct
*	O
kvpair_string	function
(	O
struct	O
locus	struct
*	O
loc	pointer
,	O
char	O
*	O
val	union
)	O
{	O
struct	O
kvpair	struct
*	O
p	pointer
=	O
ecalloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
p	pointer
)	O
)	O
;	O
p	pointer
->	O
type	int
=	O
KV_STRING	int
;	O
if	O
(	O
loc	pointer
)	O
p	pointer
->	O
loc	pointer
=	O
*	O
loc	pointer
;	O
p	pointer
->	O
val	union
.	O
s	pointer
=	O
val	union
;	O
return	O
p	pointer
;	O
}	O
struct	O
kvpair	struct
*	O
kvpair_list	function
(	O
struct	O
locus	struct
*	O
loc	pointer
,	O
struct	O
slist	struct
*	O
s	pointer
)	O
{	O
struct	O
kvpair	struct
*	O
p	pointer
=	O
ecalloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
p	pointer
)	O
)	O
;	O
p	pointer
->	O
type	int
=	O
KV_LIST	int
;	O
if	O
(	O
loc	pointer
)	O
p	pointer
->	O
loc	pointer
=	O
*	O
loc	pointer
;	O
p	pointer
->	O
val	union
.	O
l	long
=	O
s	pointer
;	O
return	O
p	pointer
;	O
}	O
static	O
void	O
kvlist_free	function
(	O
struct	O
kvpair	struct
*	O
kvp	pointer
)	O
{	O
while	O
(	O
kvp	pointer
)	O
{	O
struct	O
kvpair	struct
*	O
next	pointer
=	O
kvp	pointer
->	O
next	pointer
;	O
free	function
(	O
kvp	pointer
->	O
key	struct
)	O
;	O
switch	O
(	O
kvp	pointer
->	O
type	int
)	O
{	O
case	O
KV_STRING	int
:	O
free	function
(	O
kvp	pointer
->	O
val	union
.	O
s	pointer
)	O
;	O
break	O
;	O
case	O
KV_LIST	int
:	O
slist_free	function
(	O
kvp	pointer
->	O
val	union
.	O
l	long
)	O
;	O
break	O
;	O
}	O
free	function
(	O
kvp	pointer
)	O
;	O
kvp	pointer
=	O
next	pointer
;	O
}	O
}	O
int	O
gdbmarg_free	function
(	O
struct	O
gdbmarg	struct
*	O
arg	pointer
)	O
{	O
if	O
(	O
arg	pointer
&&	O
--	O
arg	pointer
->	O
ref	int
==	O
0	int
)	O
{	O
switch	O
(	O
arg	pointer
->	O
type	int
)	O
{	O
case	O
GDBM_ARG_STRING	int
:	O
free	function
(	O
arg	pointer
->	O
v	union
.	O
string	pointer
)	O
;	O
break	O
;	O
case	O
GDBM_ARG_KVPAIR	int
:	O
kvlist_free	function
(	O
arg	pointer
->	O
v	union
.	O
kvpair	struct
)	O
;	O
break	O
;	O
case	O
GDBM_ARG_DATUM	int
:	O
free	function
(	O
arg	pointer
->	O
v	union
.	O
dat	struct
.	O
dptr	pointer
)	O
;	O
break	O
;	O
}	O
free	function
(	O
arg	pointer
)	O
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
void	O
gdbmarg_destroy	function
(	O
struct	O
gdbmarg	struct
*	O
*	O
parg	pointer
)	O
{	O
if	O
(	O
parg	pointer
&&	O
gdbmarg_free	function
(	O
*	O
parg	pointer
)	O
)	O
*	O
parg	pointer
=	O
NULL	O
;	O
}	O
void	O
gdbmarglist_init	function
(	O
struct	O
gdbmarglist	struct
*	O
lst	pointer
,	O
struct	O
gdbmarg	struct
*	O
arg	pointer
)	O
{	O
if	O
(	O
arg	pointer
)	O
arg	pointer
->	O
next	pointer
=	O
NULL	O
;	O
lst	pointer
->	O
head	pointer
=	O
lst	pointer
->	O
tail	pointer
=	O
arg	pointer
;	O
}	O
void	O
gdbmarglist_add	function
(	O
struct	O
gdbmarglist	struct
*	O
lst	pointer
,	O
struct	O
gdbmarg	struct
*	O
arg	pointer
)	O
{	O
arg	pointer
->	O
next	pointer
=	O
NULL	O
;	O
if	O
(	O
lst	pointer
->	O
tail	pointer
)	O
lst	pointer
->	O
tail	pointer
->	O
next	pointer
=	O
arg	pointer
;	O
else	O
lst	pointer
->	O
head	pointer
=	O
arg	pointer
;	O
lst	pointer
->	O
tail	pointer
=	O
arg	pointer
;	O
}	O
void	O
gdbmarglist_free	function
(	O
struct	O
gdbmarglist	struct
*	O
lst	pointer
)	O
{	O
struct	O
gdbmarg	struct
*	O
arg	pointer
;	O
for	O
(	O
arg	pointer
=	O
lst	pointer
->	O
head	pointer
;	O
arg	pointer
;	O
)	O
{	O
struct	O
gdbmarg	struct
*	O
next	pointer
=	O
arg	pointer
->	O
next	pointer
;	O
gdbmarg_free	function
(	O
arg	pointer
)	O
;	O
arg	pointer
=	O
next	pointer
;	O
}	O
lst	pointer
->	O
head	pointer
=	O
lst	pointer
->	O
tail	pointer
=	O
NULL	O
;	O
}	O
struct	O
handler_param	struct
param	pointer
;	O
size_t	long
argmax	long
;	O
void	O
param_free_argv	function
(	O
struct	O
handler_param	struct
*	O
param	pointer
,	O
int	O
n	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
gdbmarg_destroy	function
(	O
&	O
param	pointer
->	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
param	pointer
->	O
argc	int
=	O
0	int
;	O
}	O
typedef	O
struct	O
gdbmarg	struct
*	O
(	O
*	O
coerce_type_t	pointer
)	O
(	O
struct	O
gdbmarg	struct
*	O
arg	pointer
,	O
struct	O
argdef	struct
*	O
def	pointer
)	O
;	O
struct	O
gdbmarg	struct
*	O
coerce_ref	function
(	O
struct	O
gdbmarg	struct
*	O
arg	pointer
,	O
struct	O
argdef	struct
*	O
def	pointer
)	O
{	O
++	O
arg	pointer
->	O
ref	int
;	O
return	O
arg	pointer
;	O
}	O
struct	O
gdbmarg	struct
*	O
coerce_k2d	function
(	O
struct	O
gdbmarg	struct
*	O
arg	pointer
,	O
struct	O
argdef	struct
*	O
def	pointer
)	O
{	O
datum	struct
d	struct
;	O
if	O
(	O
datum_scan	function
(	O
&	O
d	struct
,	O
dsdef	array
[	O
def	pointer
->	O
ds	pointer
]	O
,	O
arg	pointer
->	O
v	union
.	O
kvpair	struct
)	O
)	O
return	O
NULL	O
;	O
return	O
gdbmarg_datum	function
(	O
&	O
d	struct
,	O
&	O
arg	pointer
->	O
loc	pointer
)	O
;	O
}	O
struct	O
gdbmarg	struct
*	O
coerce_s2d	function
(	O
struct	O
gdbmarg	struct
*	O
arg	pointer
,	O
struct	O
argdef	struct
*	O
def	pointer
)	O
{	O
datum	struct
d	struct
;	O
struct	O
kvpair	struct
kvp	pointer
;	O
memset	function
(	O
&	O
kvp	pointer
,	O
0	int
,	O
sizeof	O
(	O
kvp	pointer
)	O
)	O
;	O
kvp	pointer
.	O
type	int
=	O
KV_STRING	int
;	O
kvp	pointer
.	O
val	union
.	O
s	pointer
=	O
arg	pointer
->	O
v	union
.	O
string	pointer
;	O
if	O
(	O
datum_scan	function
(	O
&	O
d	struct
,	O
dsdef	array
[	O
def	pointer
->	O
ds	pointer
]	O
,	O
&	O
kvp	pointer
)	O
)	O
return	O
NULL	O
;	O
return	O
gdbmarg_datum	function
(	O
&	O
d	struct
,	O
&	O
arg	pointer
->	O
loc	pointer
)	O
;	O
}	O
coerce_type_t	pointer
coerce_tab	array
[	O
GDBM_ARG_MAX	int
]	O
[	O
GDBM_ARG_MAX	int
]	O
=	O
{	O
{	O
coerce_ref	function
,	O
coerce_fail	O
,	O
coerce_fail	O
}	O
,	O
{	O
coerce_s2d	function
,	O
coerce_ref	function
,	O
coerce_k2d	function
}	O
,	O
{	O
coerce_fail	O
,	O
coerce_fail	O
,	O
coerce_ref	function
}	O
}	O
;	O
char	O
*	O
argtypestr	array
[	O
]	O
=	O
{	O
"string"	pointer
,	O
"datum"	pointer
,	O
"k/v pair"	pointer
}	O
;	O
struct	O
gdbmarg	struct
*	O
coerce	function
(	O
struct	O
gdbmarg	struct
*	O
arg	pointer
,	O
struct	O
argdef	struct
*	O
def	pointer
)	O
{	O
if	O
(	O
!	O
coerce_tab	array
[	O
def	pointer
->	O
type	int
]	O
[	O
arg	pointer
->	O
type	int
]	O
)	O
{	O
lerror	function
(	O
&	O
arg	pointer
->	O
loc	pointer
,	O
_	O
(	O
"cannot coerce %s to %s"	pointer
)	O
,	O
argtypestr	array
[	O
arg	pointer
->	O
type	int
]	O
,	O
argtypestr	array
[	O
def	pointer
->	O
type	int
]	O
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
coerce_tab	array
[	O
def	pointer
->	O
type	int
]	O
[	O
arg	pointer
->	O
type	int
]	O
(	O
arg	pointer
,	O
def	pointer
)	O
;	O
}	O
static	O
struct	O
command	struct
*	O
last_cmd	pointer
;	O
static	O
struct	O
gdbmarglist	struct
last_args	struct
;	O
void	O
run_last_command	function
(	O
void	O
)	O
{	O
if	O
(	O
interactive	function
(	O
)	O
)	O
{	O
if	O
(	O
last_cmd	pointer
)	O
{	O
switch	O
(	O
last_cmd	pointer
->	O
repeat	enum
)	O
{	O
case	O
REPEAT_NEVER	int
:	O
break	O
;	O
case	O
REPEAT_NOARG	int
:	O
gdbmarglist_free	function
(	O
&	O
last_args	struct
)	O
;	O
case	O
REPEAT_ALWAYS	int
:	O
if	O
(	O
run_command	function
(	O
last_cmd	pointer
,	O
&	O
last_args	struct
)	O
)	O
exit	function
(	O
EXIT_USAGE	int
)	O
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
}	O
}	O
}	O
int	O
run_command	function
(	O
struct	O
command	struct
*	O
cmd	pointer
,	O
struct	O
gdbmarglist	struct
*	O
arglist	pointer
)	O
{	O
int	O
i	int
;	O
struct	O
gdbmarg	struct
*	O
arg	pointer
;	O
char	O
*	O
pager	pointer
=	O
NULL	O
;	O
char	O
argbuf	array
[	O
128	int
]	O
;	O
size_t	long
expected_lines	long
,	O
*	O
expected_lines_ptr	pointer
;	O
FILE	struct
*	O
pagfp	pointer
=	O
NULL	O
;	O
variable_get	function
(	O
"pager"	pointer
,	O
VART_STRING	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
pager	pointer
)	O
;	O
arg	pointer
=	O
arglist	pointer
?	O
arglist	pointer
->	O
head	pointer
:	O
NULL	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
cmd	pointer
->	O
args	array
[	O
i	int
]	O
.	O
name	pointer
&&	O
arg	pointer
;	O
i	int
++	O
,	O
arg	pointer
=	O
arg	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
i	int
>=	O
argmax	long
)	O
{	O
argmax	long
+=	O
ARGINC	int
;	O
param	pointer
.	O
argv	pointer
=	O
erealloc	function
(	O
param	pointer
.	O
argv	pointer
,	O
sizeof	O
(	O
param	pointer
.	O
argv	pointer
[	O
0	int
]	O
)	O
*	O
argmax	long
)	O
;	O
}	O
if	O
(	O
(	O
param	pointer
.	O
argv	pointer
[	O
i	int
]	O
=	O
coerce	function
(	O
arg	pointer
,	O
&	O
cmd	pointer
->	O
args	array
[	O
i	int
]	O
)	O
)	O
==	O
NULL	O
)	O
{	O
param_free_argv	function
(	O
&	O
param	pointer
,	O
i	int
)	O
;	O
return	O
1	int
;	O
}	O
}	O
for	O
(	O
;	O
cmd	pointer
->	O
args	array
[	O
i	int
]	O
.	O
name	pointer
;	O
i	int
++	O
)	O
{	O
char	O
*	O
argname	pointer
=	O
cmd	pointer
->	O
args	array
[	O
i	int
]	O
.	O
name	pointer
;	O
struct	O
gdbmarg	struct
*	O
t	int
;	O
if	O
(	O
*	O
argname	pointer
==	O
'['	O
)	O
break	O
;	O
if	O
(	O
!	O
interactive	function
(	O
)	O
)	O
{	O
terror	function
(	O
_	O
(	O
"%s: not enough arguments"	pointer
)	O
,	O
cmd	pointer
->	O
name	pointer
)	O
;	O
return	O
1	int
;	O
}	O
printf	function
(	O
"%s? "	pointer
,	O
argname	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
if	O
(	O
fgets	function
(	O
argbuf	array
,	O
sizeof	O
argbuf	array
,	O
stdin	pointer
)	O
==	O
NULL	O
)	O
{	O
terror	function
(	O
_	O
(	O
"unexpected eof"	pointer
)	O
)	O
;	O
exit	function
(	O
EXIT_USAGE	int
)	O
;	O
}	O
trimnl	function
(	O
argbuf	array
)	O
;	O
if	O
(	O
i	int
>=	O
argmax	long
)	O
{	O
argmax	long
+=	O
ARGINC	int
;	O
param	pointer
.	O
argv	pointer
=	O
erealloc	function
(	O
param	pointer
.	O
argv	pointer
,	O
sizeof	O
(	O
param	pointer
.	O
argv	pointer
[	O
0	int
]	O
)	O
*	O
argmax	long
)	O
;	O
}	O
t	int
=	O
gdbmarg_string	function
(	O
estrdup	function
(	O
argbuf	array
)	O
,	O
&	O
yylloc	struct
)	O
;	O
if	O
(	O
(	O
param	pointer
.	O
argv	pointer
[	O
i	int
]	O
=	O
coerce	function
(	O
t	int
,	O
&	O
cmd	pointer
->	O
args	array
[	O
i	int
]	O
)	O
)	O
==	O
NULL	O
)	O
{	O
gdbmarg_free	function
(	O
t	int
)	O
;	O
param_free_argv	function
(	O
&	O
param	pointer
,	O
i	int
)	O
;	O
return	O
1	int
;	O
}	O
}	O
if	O
(	O
arg	pointer
&&	O
!	O
cmd	pointer
->	O
variadic	int
)	O
{	O
terror	function
(	O
_	O
(	O
"%s: too many arguments"	pointer
)	O
,	O
cmd	pointer
->	O
name	pointer
)	O
;	O
return	O
1	int
;	O
}	O
param	pointer
.	O
argc	int
=	O
i	int
;	O
if	O
(	O
!	O
param	pointer
.	O
argv	pointer
)	O
{	O
argmax	long
=	O
ARGINC	int
;	O
param	pointer
.	O
argv	pointer
=	O
ecalloc	function
(	O
argmax	long
,	O
sizeof	O
(	O
param	pointer
.	O
argv	pointer
[	O
0	int
]	O
)	O
)	O
;	O
}	O
param	pointer
.	O
argv	pointer
[	O
i	int
]	O
=	O
NULL	O
;	O
param	pointer
.	O
vararg	pointer
=	O
arg	pointer
;	O
param	pointer
.	O
fp	pointer
=	O
NULL	O
;	O
param	pointer
.	O
data	pointer
=	O
NULL	O
;	O
pagfp	pointer
=	O
NULL	O
;	O
expected_lines	long
=	O
0	int
;	O
expected_lines_ptr	pointer
=	O
(	O
interactive	function
(	O
)	O
&&	O
pager	pointer
)	O
?	O
&	O
expected_lines	long
:	O
NULL	O
;	O
if	O
(	O
!	O
(	O
cmd	pointer
->	O
begin	pointer
&&	O
cmd	pointer
->	O
begin	pointer
(	O
&	O
param	pointer
,	O
expected_lines_ptr	pointer
)	O
)	O
)	O
{	O
if	O
(	O
pager	pointer
&&	O
expected_lines	long
>	O
get_screen_lines	function
(	O
)	O
)	O
{	O
pagfp	pointer
=	O
popen	function
(	O
pager	pointer
,	O
"w"	pointer
)	O
;	O
if	O
(	O
pagfp	pointer
)	O
param	pointer
.	O
fp	pointer
=	O
pagfp	pointer
;	O
else	O
{	O
terror	function
(	O
_	O
(	O
"cannot run pager `%s': %s"	pointer
)	O
,	O
pager	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
pager	pointer
=	O
NULL	O
;	O
param	pointer
.	O
fp	pointer
=	O
stdout	pointer
;	O
}	O
}	O
else	O
param	pointer
.	O
fp	pointer
=	O
stdout	pointer
;	O
cmd	pointer
->	O
handler	pointer
(	O
&	O
param	pointer
)	O
;	O
if	O
(	O
cmd	pointer
->	O
end	struct
)	O
cmd	pointer
->	O
end	struct
(	O
param	pointer
.	O
data	pointer
)	O
;	O
else	O
if	O
(	O
param	pointer
.	O
data	pointer
)	O
free	function
(	O
param	pointer
.	O
data	pointer
)	O
;	O
if	O
(	O
pagfp	pointer
)	O
pclose	function
(	O
pagfp	pointer
)	O
;	O
}	O
param_free_argv	function
(	O
&	O
param	pointer
,	O
param	pointer
.	O
argc	int
)	O
;	O
last_cmd	pointer
=	O
cmd	pointer
;	O
if	O
(	O
arglist	pointer
->	O
head	pointer
!=	O
last_args	struct
.	O
head	pointer
)	O
{	O
gdbmarglist_free	function
(	O
&	O
last_args	struct
)	O
;	O
last_args	struct
=	O
*	O
arglist	pointer
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
source_rcfile	function
(	O
void	O
)	O
{	O
instream_t	pointer
istr	pointer
=	O
NULL	O
;	O
if	O
(	O
access	function
(	O
GDBMTOOLRC	pointer
,	O
R_OK	int
)	O
==	O
0	int
)	O
{	O
istr	pointer
=	O
instream_file_create	function
(	O
GDBMTOOLRC	pointer
)	O
;	O
}	O
else	O
{	O
char	O
*	O
fname	pointer
;	O
char	O
*	O
p	pointer
=	O
getenv	function
(	O
"HOME"	pointer
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
struct	O
passwd	struct
*	O
pw	pointer
=	O
getpwuid	function
(	O
getuid	function
(	O
)	O
)	O
;	O
if	O
(	O
!	O
pw	pointer
)	O
{	O
terror	function
(	O
_	O
(	O
"cannot find home directory"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
p	pointer
=	O
pw	pointer
->	O
pw_dir	pointer
;	O
}	O
fname	pointer
=	O
mkfilename	function
(	O
p	pointer
,	O
GDBMTOOLRC	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
access	function
(	O
fname	pointer
,	O
R_OK	int
)	O
==	O
0	int
)	O
{	O
istr	pointer
=	O
instream_file_create	function
(	O
GDBMTOOLRC	pointer
)	O
;	O
}	O
free	function
(	O
fname	pointer
)	O
;	O
}	O
if	O
(	O
istr	pointer
)	O
{	O
if	O
(	O
input_context_push	function
(	O
istr	pointer
)	O
)	O
exit	function
(	O
EXIT_FATAL	int
)	O
;	O
yyparse	function
(	O
)	O
;	O
}	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
int	O
opt	int
;	O
int	O
bv	int
;	O
int	O
norc	int
=	O
0	int
;	O
int	O
res	int
;	O
char	O
*	O
source	pointer
=	O
NULL	O
;	O
instream_t	pointer
input	pointer
=	O
NULL	O
;	O
set_progname	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
setlocale	function
(	O
LC_ALL	O
,	O
""	pointer
)	O
;	O
bindtextdomain	function
(	O
PACKAGE	pointer
,	O
LOCALEDIR	O
)	O
;	O
textdomain	function
(	O
PACKAGE	pointer
)	O
;	O
sort_commands	function
(	O
)	O
;	O
dsdef	array
[	O
DS_KEY	int
]	O
=	O
dsegm_new_field	function
(	O
datadef_lookup	function
(	O
"string"	pointer
)	O
,	O
NULL	O
,	O
1	int
)	O
;	O
dsdef	array
[	O
DS_CONTENT	int
]	O
=	O
dsegm_new_field	function
(	O
datadef_lookup	function
(	O
"string"	pointer
)	O
,	O
NULL	O
,	O
1	int
)	O
;	O
variable_set	function
(	O
"open"	pointer
,	O
VART_STRING	int
,	O
"wrcreat"	pointer
)	O
;	O
variable_set	function
(	O
"pager"	pointer
,	O
VART_STRING	int
,	O
getenv	function
(	O
"PAGER"	pointer
)	O
)	O
;	O
input_init	function
(	O
)	O
;	O
lex_trace	function
(	O
0	int
)	O
;	O
for	O
(	O
opt	int
=	O
parseopt_first	function
(	O
argc	int
,	O
argv	pointer
,	O
optab	array
)	O
;	O
opt	int
!=	O
EOF	O
;	O
opt	int
=	O
parseopt_next	function
(	O
)	O
)	O
switch	O
(	O
opt	int
)	O
{	O
case	O
'f'	O
:	O
source	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'l'	O
:	O
bv	int
=	O
0	int
;	O
variable_set	function
(	O
"lock"	pointer
,	O
VART_BOOL	int
,	O
&	O
bv	int
)	O
;	O
break	O
;	O
case	O
'm'	O
:	O
bv	int
=	O
0	int
;	O
variable_set	function
(	O
"mmap"	pointer
,	O
VART_BOOL	int
,	O
&	O
bv	int
)	O
;	O
break	O
;	O
case	O
's'	O
:	O
bv	int
=	O
1	int
;	O
variable_set	function
(	O
"sync"	pointer
,	O
VART_BOOL	int
,	O
&	O
bv	int
)	O
;	O
break	O
;	O
case	O
'r'	O
:	O
variable_set	function
(	O
"open"	pointer
,	O
VART_STRING	int
,	O
"readonly"	pointer
)	O
;	O
break	O
;	O
case	O
'n'	O
:	O
variable_set	function
(	O
"open"	pointer
,	O
VART_STRING	int
,	O
"newdb"	pointer
)	O
;	O
break	O
;	O
case	O
'N'	O
:	O
norc	int
=	O
1	int
;	O
break	O
;	O
case	O
'c'	O
:	O
variable_set	function
(	O
"cachesize"	pointer
,	O
VART_STRING	int
,	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'b'	O
:	O
variable_set	function
(	O
"blocksize"	pointer
,	O
VART_STRING	int
,	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'g'	O
:	O
file_name	pointer
=	O
estrdup	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'q'	O
:	O
bv	int
=	O
1	int
;	O
variable_set	function
(	O
"quiet"	pointer
,	O
VART_BOOL	int
,	O
&	O
bv	int
)	O
;	O
break	O
;	O
case	O
OPT_LEX_TRACE	int
:	O
lex_trace	function
(	O
1	int
)	O
;	O
break	O
;	O
case	O
OPT_GRAM_TRACE	int
:	O
gram_trace	function
(	O
1	int
)	O
;	O
break	O
;	O
default	O
:	O
terror	function
(	O
_	O
(	O
"unknown option; try `%s -h' for more info"	pointer
)	O
,	O
progname	pointer
)	O
;	O
exit	function
(	O
EXIT_USAGE	int
)	O
;	O
}	O
argc	int
-=	O
optind	int
;	O
argv	pointer
+=	O
optind	int
;	O
if	O
(	O
source	pointer
&&	O
strcmp	function
(	O
source	pointer
,	O
"-"	pointer
)	O
)	O
{	O
input	pointer
=	O
instream_file_create	function
(	O
source	pointer
)	O
;	O
if	O
(	O
!	O
input	pointer
)	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
argc	int
>=	O
1	int
)	O
{	O
file_name	pointer
=	O
estrdup	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
argc	int
--	O
;	O
argv	pointer
++	O
;	O
if	O
(	O
argc	int
)	O
{	O
if	O
(	O
input	pointer
)	O
{	O
terror	function
(	O
_	O
(	O
"--file and command cannot be used together"	pointer
)	O
)	O
;	O
exit	function
(	O
EXIT_USAGE	int
)	O
;	O
}	O
input	pointer
=	O
instream_argv_create	function
(	O
argc	int
,	O
argv	pointer
)	O
;	O
if	O
(	O
!	O
input	pointer
)	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
signal	function
(	O
SIGPIPE	int
,	O
SIG_IGN	O
)	O
;	O
memset	function
(	O
&	O
param	pointer
,	O
0	int
,	O
sizeof	O
(	O
param	pointer
)	O
)	O
;	O
argmax	long
=	O
0	int
;	O
if	O
(	O
!	O
norc	int
)	O
source_rcfile	function
(	O
)	O
;	O
if	O
(	O
!	O
input	pointer
)	O
input	pointer
=	O
instream_stdin_create	function
(	O
)	O
;	O
if	O
(	O
instream_interactive	function
(	O
input	pointer
)	O
&&	O
!	O
variable_is_true	function
(	O
"quiet"	pointer
)	O
)	O
printf	function
(	O
_	O
(	O
"\nWelcome to the gdbm tool.  Type ? for help.\n\n"	pointer
)	O
)	O
;	O
if	O
(	O
input_context_push	function
(	O
input	pointer
)	O
)	O
exit	function
(	O
EXIT_FATAL	int
)	O
;	O
res	int
=	O
yyparse	function
(	O
)	O
;	O
closedb	function
(	O
)	O
;	O
input_done	function
(	O
)	O
;	O
return	O
res	int
;	O
}	O
