const	O
char	O
*	O
argp_program_version	pointer
=	O
"radtest ("	pointer
PACKAGE	pointer
") "	pointer
VERSION	pointer
;	O
static	O
char	O
doc	pointer
[	O
]	O
=	O
N_	O
(	O
"Radius client shell"	pointer
)	O
;	O
static	O
struct	O
argp_option	struct
options	pointer
[	O
]	O
=	O
{	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"radtest specific switches:"	pointer
)	O
,	O
0	int
}	O
,	O
{	O
"assign"	pointer
,	O
'a'	O
,	O
N_	O
(	O
"VARIABLE=VALUE"	pointer
)	O
,	O
0	int
,	O
N_	O
(	O
"assign a VALUE to VARIABLE"	pointer
)	O
,	O
0	int
}	O
,	O
{	O
"debug"	pointer
,	O
'x'	O
,	O
"DEBUGSPEC"	pointer
,	O
0	int
,	O
N_	O
(	O
"set debugging level"	pointer
)	O
,	O
0	int
}	O
,	O
{	O
"file"	pointer
,	O
'f'	O
,	O
N_	O
(	O
"FILE"	pointer
)	O
,	O
0	int
,	O
N_	O
(	O
"Read input from FILE. Stops further processing of the command line."	pointer
)	O
,	O
0	int
}	O
,	O
{	O
"quick"	pointer
,	O
'q'	O
,	O
NULL	O
,	O
0	int
,	O
"Do not read the configuration file"	pointer
,	O
0	int
}	O
,	O
{	O
"retry"	pointer
,	O
'r'	O
,	O
N_	O
(	O
"NUMBER"	pointer
)	O
,	O
0	int
,	O
N_	O
(	O
"set number of retries"	pointer
)	O
,	O
0	int
}	O
,	O
{	O
"server"	pointer
,	O
's'	O
,	O
N_	O
(	O
"SERVER"	pointer
)	O
,	O
0	int
,	O
N_	O
(	O
"set radius server parameters"	pointer
)	O
,	O
0	int
}	O
,	O
{	O
"timeout"	pointer
,	O
't'	O
,	O
N_	O
(	O
"NUMBER"	pointer
)	O
,	O
0	int
,	O
N_	O
(	O
"set timeout"	pointer
)	O
,	O
0	int
}	O
,	O
{	O
"verbose"	pointer
,	O
'v'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"verbose mode"	pointer
)	O
,	O
0	int
}	O
,	O
{	O
"no-interactive"	pointer
,	O
'i'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"disable interactive mode"	pointer
)	O
,	O
0	int
}	O
,	O
{	O
"dry-run"	pointer
,	O
'n'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Check the input file syntax and exit"	pointer
)	O
,	O
0	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
int	O
verbose	int
;	O
int	O
quick	int
=	O
0	int
;	O
char	O
*	O
filename	pointer
=	O
NULL	O
;	O
char	O
*	O
server	pointer
=	O
NULL	O
;	O
int	O
retry	int
=	O
0	int
;	O
int	O
timeout	int
=	O
0	int
;	O
int	O
disable_readline	int
;	O
int	O
dry_run	int
;	O
static	O
void	O
assign	function
(	O
char	O
*	O
s	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
radtest_variable_t	struct
*	O
var	pointer
;	O
radtest_datum_t	union
datum	union
;	O
radtest_data_type	enum
type	int
=	O
rtv_undefined	int
;	O
p	pointer
=	O
strchr	function
(	O
s	pointer
,	O
'='	O
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"assign: expected `='\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
*	O
p	pointer
++	O
=	O
0	int
;	O
type	int
=	O
parse_datum	function
(	O
p	pointer
,	O
&	O
datum	union
)	O
;	O
if	O
(	O
type	int
==	O
rtv_undefined	int
)	O
return	O
;	O
var	pointer
=	O
(	O
radtest_variable_t	struct
*	O
)	O
grad_sym_install	function
(	O
vartab	pointer
,	O
s	pointer
)	O
;	O
var	pointer
->	O
type	int
=	O
type	int
;	O
var	pointer
->	O
datum	union
=	O
datum	union
;	O
}	O
static	O
error_t	int
parse_opt	function
(	O
int	O
key	int
,	O
char	O
*	O
arg	pointer
,	O
struct	O
argp_state	struct
*	O
state	pointer
)	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
'a'	O
:	O
assign	function
(	O
arg	pointer
)	O
;	O
break	O
;	O
case	O
'q'	O
:	O
quick	int
++	O
;	O
break	O
;	O
case	O
'r'	O
:	O
retry	int
=	O
strtol	function
(	O
arg	pointer
,	O
NULL	O
,	O
0	int
)	O
;	O
break	O
;	O
case	O
's'	O
:	O
server	pointer
=	O
arg	pointer
;	O
break	O
;	O
case	O
'f'	O
:	O
filename	pointer
=	O
arg	pointer
;	O
*	O
(	O
int	O
*	O
)	O
state	pointer
->	O
input	pointer
=	O
state	pointer
->	O
next	pointer
;	O
state	pointer
->	O
next	pointer
=	O
state	pointer
->	O
argc	int
;	O
break	O
;	O
case	O
'i'	O
:	O
disable_readline	int
=	O
1	int
;	O
break	O
;	O
case	O
'n'	O
:	O
dry_run	int
=	O
1	int
;	O
break	O
;	O
case	O
't'	O
:	O
timeout	int
=	O
strtol	function
(	O
arg	pointer
,	O
NULL	O
,	O
0	int
)	O
;	O
break	O
;	O
case	O
'x'	O
:	O
grad_set_debug_levels	function
(	O
arg	pointer
)	O
;	O
break	O
;	O
case	O
'v'	O
:	O
verbose	int
++	O
;	O
grad_set_module_debug_level	function
(	O
"radpdu"	pointer
,	O
100	int
)	O
;	O
grad_set_module_debug_level	function
(	O
"client"	pointer
,	O
100	int
)	O
;	O
break	O
;	O
default	O
:	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
argp	struct
argp	struct
=	O
{	O
options	pointer
,	O
parse_opt	function
,	O
NULL	O
,	O
doc	pointer
,	O
grad_common_argp_child	array
,	O
NULL	O
,	O
NULL	O
}	O
;	O
int	O
radtest_parse_options	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
index	function
;	O
return	O
argp_parse	function
(	O
&	O
argp	struct
,	O
argc	int
,	O
argv	pointer
,	O
ARGP_NO_EXIT	int
,	O
NULL	O
,	O
&	O
index	function
)	O
;	O
}	O
grad_server_queue_t	struct
*	O
srv_queue	pointer
;	O
grad_symtab_t	struct
*	O
vartab	pointer
;	O
grad_symtab_t	struct
*	O
functab	pointer
;	O
int	O
reply_code	int
;	O
grad_avp_t	struct
*	O
reply_list	pointer
;	O
grad_list_t	struct
*	O
toplevel_env	pointer
;	O
static	O
void	O
init_symbols	function
(	O
)	O
{	O
radtest_variable_t	struct
*	O
var	pointer
;	O
vartab	pointer
=	O
grad_symtab_create	function
(	O
sizeof	O
(	O
radtest_variable_t	struct
)	O
,	O
NULL	O
)	O
;	O
var	pointer
=	O
(	O
radtest_variable_t	struct
*	O
)	O
grad_sym_install	function
(	O
vartab	pointer
,	O
"REPLY_CODE"	pointer
)	O
;	O
var	pointer
->	O
type	int
=	O
rtv_integer	int
;	O
var	pointer
=	O
(	O
radtest_variable_t	struct
*	O
)	O
grad_sym_install	function
(	O
vartab	pointer
,	O
"REPLY"	pointer
)	O
;	O
var	pointer
->	O
type	int
=	O
rtv_avl	int
;	O
var	pointer
=	O
(	O
radtest_variable_t	struct
*	O
)	O
grad_sym_install	function
(	O
vartab	pointer
,	O
"SOURCEIP"	pointer
)	O
;	O
var	pointer
->	O
type	int
=	O
rtv_ipaddress	int
;	O
functab	pointer
=	O
grad_symtab_create	function
(	O
sizeof	O
(	O
radtest_function_t	struct
)	O
,	O
NULL	O
)	O
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
int	O
index	function
,	O
argind	int
;	O
radtest_variable_t	struct
*	O
var	pointer
;	O
grad_app_setup	function
(	O
)	O
;	O
init_symbols	function
(	O
)	O
;	O
index	function
=	O
0	int
;	O
if	O
(	O
grad_argp_parse	function
(	O
&	O
argp	struct
,	O
&	O
argc	int
,	O
&	O
argv	pointer
,	O
ARGP_IN_ORDER	int
,	O
&	O
argind	int
,	O
&	O
index	function
)	O
)	O
return	O
1	int
;	O
if	O
(	O
index	function
==	O
0	int
)	O
index	function
=	O
argind	int
;	O
argv	pointer
+=	O
index	function
;	O
argc	int
-=	O
index	function
;	O
set_yydebug	function
(	O
)	O
;	O
grad_path_init	function
(	O
)	O
;	O
srand	function
(	O
time	struct
(	O
NULL	O
)	O
+	O
getpid	function
(	O
)	O
)	O
;	O
if	O
(	O
grad_dict_init	function
(	O
)	O
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"error reading dictionary file"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
srv_queue	pointer
=	O
grad_client_create_queue	function
(	O
!	O
quick	int
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
!	O
srv_queue	pointer
)	O
return	O
1	int
;	O
var	pointer
=	O
(	O
radtest_variable_t	struct
*	O
)	O
grad_sym_lookup	function
(	O
vartab	pointer
,	O
"SOURCEIP"	pointer
)	O
;	O
var	pointer
->	O
datum	union
.	O
ipaddr	int
=	O
srv_queue	pointer
->	O
source_ip	int
;	O
if	O
(	O
timeout	int
)	O
srv_queue	pointer
->	O
timeout	int
=	O
timeout	int
;	O
if	O
(	O
retry	int
)	O
srv_queue	pointer
->	O
retries	int
=	O
retry	int
;	O
if	O
(	O
server	pointer
)	O
{	O
grad_server_t	struct
serv	struct
;	O
int	O
i	int
,	O
argc	int
;	O
char	O
*	O
*	O
argv	pointer
;	O
if	O
(	O
grad_argcv_get	function
(	O
server	pointer
,	O
":"	pointer
,	O
NULL	O
,	O
&	O
argc	int
,	O
&	O
argv	pointer
)	O
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"can't parse server definition"	pointer
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
argc	int
<	O
3	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"no shared secret for the server"	pointer
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
memset	function
(	O
&	O
serv	struct
,	O
0	int
,	O
sizeof	O
serv	struct
)	O
;	O
serv	struct
.	O
name	pointer
=	O
"default"	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
switch	O
(	O
i	int
)	O
{	O
case	O
0	int
:	O
serv	struct
.	O
addr	int
=	O
grad_ip_gethostaddr	function
(	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
if	O
(	O
!	O
serv	struct
.	O
addr	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"bad IP address or host name: %s"	pointer
)	O
,	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
break	O
;	O
case	O
2	int
:	O
serv	struct
.	O
secret	pointer
=	O
argv	pointer
[	O
i	int
]	O
;	O
break	O
;	O
case	O
4	int
:	O
serv	struct
.	O
port	array
[	O
0	int
]	O
=	O
strtol	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
&	O
p	pointer
,	O
0	int
)	O
;	O
if	O
(	O
*	O
p	pointer
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"bad port number %s"	pointer
)	O
,	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
6	int
:	O
serv	struct
.	O
port	array
[	O
1	int
]	O
=	O
strtol	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
&	O
p	pointer
,	O
0	int
)	O
;	O
if	O
(	O
*	O
p	pointer
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"bad port number %s"	pointer
)	O
,	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
default	O
:	O
if	O
(	O
argv	pointer
[	O
i	int
]	O
[	O
0	int
]	O
!=	O
':'	O
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"bad separator near %s"	pointer
)	O
,	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
break	O
;	O
}	O
}	O
if	O
(	O
argc	int
<	O
4	int
)	O
serv	struct
.	O
port	array
[	O
0	int
]	O
=	O
DEF_AUTH_PORT	int
;	O
if	O
(	O
argc	int
<	O
6	int
)	O
serv	struct
.	O
port	array
[	O
1	int
]	O
=	O
DEF_ACCT_PORT	int
;	O
grad_client_append_server	function
(	O
srv_queue	pointer
,	O
grad_client_alloc_server	function
(	O
&	O
serv	struct
)	O
)	O
;	O
grad_argcv_free	function
(	O
argc	int
,	O
argv	pointer
)	O
;	O
}	O
if	O
(	O
grad_list_count	function
(	O
srv_queue	pointer
->	O
servers	pointer
)	O
==	O
0	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"No servers specfied. Use -s option.\n"	pointer
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
toplevel_env	pointer
=	O
grad_list_create	function
(	O
)	O
;	O
radtest_env_add_string	function
(	O
toplevel_env	pointer
,	O
filename	pointer
?	O
filename	pointer
:	O
""	pointer
)	O
;	O
for	O
(	O
;	O
argc	int
;	O
argv	pointer
++	O
,	O
argc	int
--	O
)	O
{	O
if	O
(	O
(	O
p	pointer
=	O
strchr	function
(	O
*	O
argv	pointer
,	O
'='	O
)	O
)	O
!=	O
NULL	O
&&	O
!	O
(	O
p	pointer
>	O
*	O
argv	pointer
&&	O
p	pointer
[	O
-	O
1	int
]	O
==	O
'\\'	O
)	O
)	O
assign	function
(	O
*	O
argv	pointer
)	O
;	O
else	O
radtest_env_add_string	function
(	O
toplevel_env	pointer
,	O
*	O
argv	pointer
)	O
;	O
}	O
return	O
read_and_eval	function
(	O
filename	pointer
)	O
;	O
}	O
radtest_data_type	enum
parse_datum	function
(	O
char	O
*	O
p	pointer
,	O
radtest_datum_t	union
*	O
dp	pointer
)	O
{	O
radtest_data_type	enum
type	int
=	O
rtv_undefined	int
;	O
int	O
length	short
;	O
if	O
(	O
*	O
p	pointer
==	O
'"'	O
)	O
{	O
length	short
=	O
strlen	function
(	O
++	O
p	pointer
)	O
;	O
if	O
(	O
length	short
==	O
0	int
||	O
p	pointer
[	O
length	short
-	O
1	int
]	O
!=	O
'"'	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"assign: missing closing quote\n"	pointer
)	O
)	O
;	O
return	O
rtv_undefined	int
;	O
}	O
p	pointer
[	O
length	short
-	O
1	int
]	O
=	O
0	int
;	O
type	int
=	O
rtv_string	int
;	O
dp	pointer
->	O
string	pointer
=	O
grad_estrdup	function
(	O
p	pointer
)	O
;	O
}	O
else	O
if	O
(	O
isdigit	function
(	O
*	O
p	pointer
)	O
)	O
{	O
char	O
*	O
endp	pointer
;	O
dp	pointer
->	O
number	long
=	O
strtol	function
(	O
p	pointer
,	O
&	O
endp	pointer
,	O
0	int
)	O
;	O
if	O
(	O
*	O
endp	pointer
==	O
0	int
)	O
{	O
type	int
=	O
rtv_integer	int
;	O
}	O
else	O
{	O
if	O
(	O
(	O
dp	pointer
->	O
ipaddr	int
=	O
grad_ip_gethostaddr	function
(	O
p	pointer
)	O
)	O
!=	O
0	int
)	O
type	int
=	O
rtv_ipaddress	int
;	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"assign: invalid IP address: %s\n"	pointer
)	O
,	O
p	pointer
)	O
;	O
return	O
rtv_undefined	int
;	O
}	O
}	O
}	O
else	O
if	O
(	O
strchr	function
(	O
p	pointer
,	O
'.'	O
)	O
)	O
{	O
if	O
(	O
(	O
dp	pointer
->	O
ipaddr	int
=	O
grad_ip_gethostaddr	function
(	O
p	pointer
)	O
)	O
!=	O
0	int
)	O
type	int
=	O
rtv_ipaddress	int
;	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"assign: invalid IP address: %s\n"	pointer
)	O
,	O
p	pointer
)	O
;	O
return	O
rtv_undefined	int
;	O
}	O
}	O
else	O
{	O
type	int
=	O
rtv_string	int
;	O
dp	pointer
->	O
string	pointer
=	O
grad_estrdup	function
(	O
p	pointer
)	O
;	O
}	O
return	O
type	int
;	O
}	O
void	O
print_pairs	function
(	O
FILE	struct
*	O
fp	pointer
,	O
grad_avp_t	struct
*	O
pair	pointer
)	O
{	O
for	O
(	O
;	O
pair	pointer
;	O
pair	pointer
=	O
pair	pointer
->	O
next	pointer
)	O
{	O
char	O
*	O
save	pointer
;	O
fprintf	function
(	O
fp	pointer
,	O
" %s"	pointer
,	O
grad_format_pair	function
(	O
pair	pointer
,	O
1	int
,	O
&	O
save	pointer
)	O
)	O
;	O
free	function
(	O
save	pointer
)	O
;	O
if	O
(	O
pair	pointer
->	O
next	pointer
)	O
fprintf	function
(	O
fp	pointer
,	O
","	pointer
)	O
;	O
else	O
fprintf	function
(	O
fp	pointer
,	O
" "	pointer
)	O
;	O
}	O
}	O
void	O
var_print	function
(	O
radtest_variable_t	struct
*	O
var	pointer
)	O
{	O
char	O
buf	pointer
[	O
GRAD_IPV4_STRING_LENGTH	int
]	O
;	O
if	O
(	O
!	O
var	pointer
)	O
return	O
;	O
switch	O
(	O
var	pointer
->	O
type	int
)	O
{	O
case	O
rtv_undefined	int
:	O
printf	function
(	O
"UNDEFINED"	pointer
)	O
;	O
break	O
;	O
case	O
rtv_integer	int
:	O
printf	function
(	O
"%ld"	pointer
,	O
var	pointer
->	O
datum	union
.	O
number	long
)	O
;	O
break	O
;	O
case	O
rtv_ipaddress	int
:	O
printf	function
(	O
"%s"	pointer
,	O
grad_ip_iptostr	function
(	O
var	pointer
->	O
datum	union
.	O
ipaddr	int
,	O
buf	pointer
)	O
)	O
;	O
break	O
;	O
case	O
rtv_bstring	int
:	O
{	O
int	O
len	int
=	O
grad_format_string_visual	function
(	O
NULL	O
,	O
3	int
,	O
var	pointer
->	O
datum	union
.	O
bstring	struct
.	O
ptr	pointer
,	O
var	pointer
->	O
datum	union
.	O
bstring	struct
.	O
length	short
)	O
;	O
char	O
*	O
pbuf	pointer
=	O
grad_emalloc	function
(	O
len	int
+	O
1	int
)	O
;	O
grad_format_string_visual	function
(	O
pbuf	pointer
,	O
3	int
,	O
var	pointer
->	O
datum	union
.	O
bstring	struct
.	O
ptr	pointer
,	O
var	pointer
->	O
datum	union
.	O
bstring	struct
.	O
length	short
)	O
;	O
printf	function
(	O
"%s"	pointer
,	O
pbuf	pointer
)	O
;	O
grad_free	function
(	O
pbuf	pointer
)	O
;	O
}	O
break	O
;	O
case	O
rtv_string	int
:	O
printf	function
(	O
"%s"	pointer
,	O
var	pointer
->	O
datum	union
.	O
string	pointer
)	O
;	O
break	O
;	O
case	O
rtv_avl	int
:	O
printf	function
(	O
"("	pointer
)	O
;	O
print_pairs	function
(	O
stdout	pointer
,	O
var	pointer
->	O
datum	union
.	O
avl	pointer
)	O
;	O
printf	function
(	O
")"	pointer
)	O
;	O
break	O
;	O
case	O
rtv_pairlist	int
:	O
abort	function
(	O
)	O
;	O
}	O
}	O
int	O
var_free	function
(	O
radtest_variable_t	struct
*	O
var	pointer
)	O
{	O
switch	O
(	O
var	pointer
->	O
type	int
)	O
{	O
case	O
rtv_string	int
:	O
grad_free	function
(	O
var	pointer
->	O
datum	union
.	O
string	pointer
)	O
;	O
break	O
;	O
case	O
rtv_avl	int
:	O
grad_avl_free	function
(	O
var	pointer
->	O
datum	union
.	O
avl	pointer
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
void	O
radtest_send	function
(	O
int	O
port	array
,	O
int	O
code	char
,	O
grad_avp_t	struct
*	O
avl	pointer
,	O
grad_symtab_t	struct
*	O
cntl	pointer
)	O
{	O
grad_request_t	struct
*	O
auth	pointer
;	O
radtest_variable_t	struct
*	O
p	pointer
;	O
if	O
(	O
reply_list	pointer
)	O
grad_avl_free	function
(	O
reply_list	pointer
)	O
;	O
reply_list	pointer
=	O
NULL	O
;	O
reply_code	int
=	O
0	int
;	O
if	O
(	O
!	O
cntl	pointer
)	O
{	O
auth	pointer
=	O
grad_client_send	function
(	O
srv_queue	pointer
,	O
port	array
,	O
code	char
,	O
avl	pointer
)	O
;	O
}	O
else	O
{	O
int	O
id	char
;	O
u_char	char
authenticator	array
[	O
GRAD_AUTHENTICATOR_LENGTH	int
]	O
;	O
int	O
sflags	int
=	O
0	int
;	O
int	O
retry	int
=	O
1	int
;	O
radtest_variable_t	struct
*	O
delay	long
=	O
(	O
radtest_variable_t	struct
*	O
)	O
grad_sym_lookup	function
(	O
cntl	pointer
,	O
"delay"	pointer
)	O
;	O
p	pointer
=	O
(	O
radtest_variable_t	struct
*	O
)	O
grad_sym_lookup	function
(	O
cntl	pointer
,	O
"repeat"	pointer
)	O
;	O
if	O
(	O
p	pointer
)	O
retry	int
=	O
p	pointer
->	O
datum	union
.	O
number	long
;	O
p	pointer
=	O
(	O
radtest_variable_t	struct
*	O
)	O
grad_sym_lookup	function
(	O
cntl	pointer
,	O
"id"	pointer
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
sflags	int
|=	O
RADCLT_ID	int
;	O
id	char
=	O
p	pointer
->	O
datum	union
.	O
number	long
;	O
}	O
p	pointer
=	O
(	O
radtest_variable_t	struct
*	O
)	O
grad_sym_lookup	function
(	O
cntl	pointer
,	O
"keepauth"	pointer
)	O
;	O
if	O
(	O
p	pointer
&&	O
p	pointer
->	O
datum	union
.	O
number	long
)	O
sflags	int
|=	O
RADCLT_AUTHENTICATOR	int
;	O
auth	pointer
=	O
grad_client_send0	function
(	O
srv_queue	pointer
,	O
port	array
,	O
code	char
,	O
avl	pointer
,	O
0	int
,	O
&	O
id	char
,	O
authenticator	array
)	O
;	O
while	O
(	O
--	O
retry	int
)	O
{	O
if	O
(	O
delay	long
)	O
sleep	function
(	O
delay	long
->	O
datum	union
.	O
number	long
)	O
;	O
auth	pointer
=	O
grad_client_send0	function
(	O
srv_queue	pointer
,	O
port	array
,	O
code	char
,	O
avl	pointer
,	O
sflags	int
,	O
&	O
id	char
,	O
authenticator	array
)	O
;	O
}	O
}	O
if	O
(	O
!	O
auth	pointer
)	O
return	O
;	O
reply_code	int
=	O
auth	pointer
->	O
code	char
;	O
p	pointer
=	O
(	O
radtest_variable_t	struct
*	O
)	O
grad_sym_lookup	function
(	O
vartab	pointer
,	O
"REPLY_CODE"	pointer
)	O
;	O
p	pointer
->	O
type	int
=	O
rtv_integer	int
;	O
p	pointer
->	O
datum	union
.	O
number	long
=	O
reply_code	int
;	O
reply_list	pointer
=	O
grad_client_decrypt_pairlist	function
(	O
grad_avl_dup	function
(	O
auth	pointer
->	O
avlist	pointer
)	O
,	O
auth	pointer
->	O
authenticator	array
,	O
auth	pointer
->	O
secret	pointer
)	O
;	O
p	pointer
=	O
(	O
radtest_variable_t	struct
*	O
)	O
grad_sym_lookup	function
(	O
vartab	pointer
,	O
"REPLY"	pointer
)	O
;	O
p	pointer
->	O
type	int
=	O
rtv_avl	int
;	O
p	pointer
->	O
datum	union
.	O
avl	pointer
=	O
reply_list	pointer
;	O
grad_request_free	function
(	O
auth	pointer
)	O
;	O
}	O
int	O
comp_op	function
(	O
enum	O
grad_operator	enum
op	enum
,	O
int	O
result	pointer
)	O
{	O
switch	O
(	O
op	enum
)	O
{	O
default	O
:	O
case	O
grad_operator_equal	int
:	O
if	O
(	O
result	pointer
!=	O
0	int
)	O
return	O
-	O
1	int
;	O
break	O
;	O
case	O
grad_operator_not_equal	int
:	O
if	O
(	O
result	pointer
==	O
0	int
)	O
return	O
-	O
1	int
;	O
break	O
;	O
case	O
grad_operator_less_than	int
:	O
if	O
(	O
result	pointer
>=	O
0	int
)	O
return	O
-	O
1	int
;	O
break	O
;	O
case	O
grad_operator_greater_than	int
:	O
if	O
(	O
result	pointer
<=	O
0	int
)	O
return	O
-	O
1	int
;	O
break	O
;	O
case	O
grad_operator_less_equal	int
:	O
if	O
(	O
result	pointer
>	O
0	int
)	O
return	O
-	O
1	int
;	O
break	O
;	O
case	O
grad_operator_greater_equal	int
:	O
if	O
(	O
result	pointer
<	O
0	int
)	O
return	O
-	O
1	int
;	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
compare_lists	function
(	O
grad_avp_t	struct
*	O
reply_list	pointer
,	O
grad_avp_t	struct
*	O
sample	pointer
)	O
{	O
int	O
result	pointer
=	O
0	int
;	O
grad_avp_t	struct
*	O
reply	pointer
=	O
grad_avl_dup	function
(	O
reply_list	pointer
)	O
;	O
for	O
(	O
;	O
sample	pointer
&&	O
result	pointer
==	O
0	int
;	O
sample	pointer
=	O
sample	pointer
->	O
next	pointer
)	O
{	O
grad_avp_t	struct
*	O
p	pointer
,	O
*	O
prev	pointer
=	O
NULL	O
;	O
if	O
(	O
sample	pointer
->	O
attribute	int
>	O
255	int
)	O
continue	O
;	O
for	O
(	O
p	pointer
=	O
reply	pointer
;	O
p	pointer
&&	O
p	pointer
->	O
attribute	int
!=	O
sample	pointer
->	O
attribute	int
;	O
prev	pointer
=	O
p	pointer
,	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
-	O
1	int
;	O
switch	O
(	O
p	pointer
->	O
type	int
)	O
{	O
case	O
GRAD_TYPE_STRING	int
:	O
result	pointer
=	O
strcmp	function
(	O
sample	pointer
->	O
avp_strvalue	O
,	O
p	pointer
->	O
avp_strvalue	O
)	O
;	O
break	O
;	O
case	O
GRAD_TYPE_INTEGER	int
:	O
case	O
GRAD_TYPE_IPADDR	int
:	O
result	pointer
=	O
sample	pointer
->	O
avp_lvalue	O
-	O
p	pointer
->	O
avp_lvalue	O
;	O
break	O
;	O
default	O
:	O
result	pointer
=	O
-	O
1	int
;	O
}	O
result	pointer
=	O
comp_op	function
(	O
sample	pointer
->	O
operator	enum
,	O
result	pointer
)	O
;	O
if	O
(	O
result	pointer
==	O
0	int
)	O
{	O
if	O
(	O
!	O
prev	pointer
)	O
reply	pointer
=	O
p	pointer
->	O
next	pointer
;	O
else	O
prev	pointer
->	O
next	pointer
=	O
p	pointer
->	O
next	pointer
;	O
grad_avp_free	function
(	O
p	pointer
)	O
;	O
}	O
}	O
grad_avl_free	function
(	O
reply	pointer
)	O
;	O
return	O
result	pointer
;	O
}	O
