void	O
sgffile_add_debuginfo	function
(	O
SGFNode	struct
*	O
node	pointer
,	O
float	O
value	pointer
)	O
{	O
int	O
pos	int
;	O
char	O
comment	pointer
[	O
24	int
]	O
;	O
if	O
(	O
!	O
outfilename	array
[	O
0	int
]	O
)	O
return	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
if	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
pos	int
]	O
)	O
&&	O
(	O
output_flags	int
&	O
OUTPUT_MARKDRAGONS	int
)	O
)	O
{	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
crude_status	function
==	O
DEAD	int
)	O
sgfLabel	function
(	O
node	pointer
,	O
"X"	pointer
,	O
I	O
(	O
pos	int
)	O
,	O
J	O
(	O
pos	int
)	O
)	O
;	O
else	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
crude_status	function
==	O
CRITICAL	int
)	O
sgfLabel	function
(	O
node	pointer
,	O
"!"	pointer
,	O
I	O
(	O
pos	int
)	O
,	O
J	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
potential_moves	array
[	O
pos	int
]	O
>	O
0.0	int
&&	O
(	O
output_flags	int
&	O
OUTPUT_MOVEVALUES	int
)	O
)	O
{	O
if	O
(	O
potential_moves	array
[	O
pos	int
]	O
<	O
1.0	int
)	O
sgfLabel	function
(	O
node	pointer
,	O
"<1"	pointer
,	O
I	O
(	O
pos	int
)	O
,	O
J	O
(	O
pos	int
)	O
)	O
;	O
else	O
sgfLabelInt	function
(	O
node	pointer
,	O
(	O
int	O
)	O
potential_moves	array
[	O
pos	int
]	O
,	O
I	O
(	O
pos	int
)	O
,	O
J	O
(	O
pos	int
)	O
)	O
;	O
}	O
}	O
if	O
(	O
value	pointer
>	O
0.0	int
&&	O
(	O
output_flags	int
&	O
OUTPUT_MOVEVALUES	int
)	O
)	O
{	O
sprintf	function
(	O
comment	pointer
,	O
"Value of move: %.2f"	pointer
,	O
value	pointer
)	O
;	O
sgfAddComment	function
(	O
node	pointer
,	O
comment	pointer
)	O
;	O
}	O
}	O
void	O
sgffile_output	function
(	O
SGFTree	struct
*	O
tree	pointer
)	O
{	O
if	O
(	O
outfilename	array
[	O
0	int
]	O
)	O
writesgf	function
(	O
tree	pointer
->	O
root	pointer
,	O
outfilename	array
)	O
;	O
}	O
void	O
sgffile_begindump	function
(	O
SGFTree	struct
*	O
tree	pointer
)	O
{	O
static	O
SGFTree	struct
local_tree	struct
;	O
gg_assert	O
(	O
sgf_dumptree	pointer
==	O
NULL	O
)	O
;	O
if	O
(	O
tree	pointer
==	O
NULL	O
)	O
sgf_dumptree	pointer
=	O
&	O
local_tree	struct
;	O
else	O
sgf_dumptree	pointer
=	O
tree	pointer
;	O
sgftree_clear	function
(	O
sgf_dumptree	pointer
)	O
;	O
sgftreeCreateHeaderNode	function
(	O
sgf_dumptree	pointer
,	O
board_size	int
,	O
komi	float
,	O
handicap	int
)	O
;	O
sgffile_printboard	function
(	O
sgf_dumptree	pointer
)	O
;	O
}	O
void	O
sgffile_enddump	function
(	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
if	O
(	O
filename	pointer
&&	O
*	O
filename	pointer
&&	O
sgf_dumptree	pointer
)	O
{	O
if	O
(	O
writesgf	function
(	O
sgf_dumptree	pointer
->	O
root	pointer
,	O
filename	pointer
)	O
)	O
{	O
sgfFreeNode	function
(	O
sgf_dumptree	pointer
->	O
root	pointer
)	O
;	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
}	O
}	O
}	O
void	O
sgffile_printsgf	function
(	O
int	O
color_to_play	int
,	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
SGFTree	struct
sgftree	struct
;	O
int	O
m	int
,	O
n	int
;	O
char	O
pos	int
[	O
3	int
]	O
;	O
char	O
str	int
[	O
128	int
]	O
;	O
float	O
relative_komi	float
;	O
relative_komi	float
=	O
komi	float
+	O
black_captured	int
-	O
white_captured	int
;	O
sgftree_clear	function
(	O
&	O
sgftree	struct
)	O
;	O
sgftreeCreateHeaderNode	function
(	O
&	O
sgftree	struct
,	O
board_size	int
,	O
relative_komi	float
,	O
handicap	int
)	O
;	O
sgf_write_header	function
(	O
sgftree	struct
.	O
root	pointer
,	O
1	int
,	O
get_random_seed	function
(	O
)	O
,	O
relative_komi	float
,	O
handicap	int
,	O
get_level	function
(	O
)	O
,	O
chinese_rules	int
)	O
;	O
gg_snprintf	function
(	O
str	int
,	O
128	int
,	O
"GNU Go %s load and print"	pointer
,	O
gg_version	function
(	O
)	O
)	O
;	O
sgfOverwriteProperty	function
(	O
sgftree	struct
.	O
root	pointer
,	O
"GN"	pointer
,	O
str	int
)	O
;	O
sgffile_printboard	function
(	O
&	O
sgftree	struct
)	O
;	O
if	O
(	O
color_to_play	int
!=	O
EMPTY	int
)	O
{	O
sgfAddProperty	function
(	O
sgftree	struct
.	O
lastnode	pointer
,	O
"PL"	pointer
,	O
(	O
color_to_play	int
==	O
WHITE	int
?	O
"W"	pointer
:	O
"B"	pointer
)	O
)	O
;	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
board_size	int
;	O
++	O
m	int
)	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
board_size	int
;	O
++	O
n	int
)	O
if	O
(	O
BOARD	O
(	O
m	int
,	O
n	int
)	O
==	O
EMPTY	int
&&	O
!	O
is_legal	function
(	O
POS	O
(	O
m	int
,	O
n	int
)	O
,	O
color_to_play	int
)	O
)	O
{	O
gg_snprintf	function
(	O
pos	int
,	O
3	int
,	O
"%c%c"	pointer
,	O
'a'	O
+	O
n	int
,	O
'a'	O
+	O
m	int
)	O
;	O
sgfAddProperty	function
(	O
sgftree	struct
.	O
lastnode	pointer
,	O
"IL"	pointer
,	O
pos	int
)	O
;	O
}	O
}	O
writesgf	function
(	O
sgftree	struct
.	O
root	pointer
,	O
filename	pointer
)	O
;	O
}	O
void	O
sgffile_printboard	function
(	O
SGFTree	struct
*	O
tree	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
SGFNode	struct
*	O
node	pointer
;	O
gg_assert	O
(	O
tree	pointer
)	O
;	O
node	pointer
=	O
tree	pointer
->	O
lastnode	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
board_size	int
;	O
i	int
++	O
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
board_size	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
WHITE	int
)	O
sgfAddStone	function
(	O
node	pointer
,	O
WHITE	int
,	O
i	int
,	O
j	int
)	O
;	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
board_size	int
;	O
i	int
++	O
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
board_size	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
BLACK	int
)	O
sgfAddStone	function
(	O
node	pointer
,	O
BLACK	int
,	O
i	int
,	O
j	int
)	O
;	O
}	O
}	O
sgftreeSetLastNode	function
(	O
tree	pointer
,	O
node	pointer
)	O
;	O
}	O
void	O
sgffile_recordboard	function
(	O
SGFNode	struct
*	O
node	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
if	O
(	O
node	pointer
)	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
board_size	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
board_size	int
;	O
j	int
++	O
)	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
BLACK	int
)	O
sgfAddStone	function
(	O
node	pointer
,	O
BLACK	int
,	O
i	int
,	O
j	int
)	O
;	O
}	O
int	O
get_sgfmove	function
(	O
SGFProperty	struct
*	O
property	pointer
)	O
{	O
return	O
POS	O
(	O
get_moveX	function
(	O
property	pointer
,	O
board_size	int
)	O
,	O
get_moveY	function
(	O
property	pointer
,	O
board_size	int
)	O
)	O
;	O
}	O
