void	O
stringbuf_init	function
(	O
struct	O
stringbuf	struct
*	O
sb	pointer
)	O
{	O
sb	pointer
->	O
buffer	pointer
=	O
NULL	O
;	O
sb	pointer
->	O
size	long
=	O
0	int
;	O
sb	pointer
->	O
pos	long
=	O
0	int
;	O
}	O
void	O
stringbuf_free	function
(	O
struct	O
stringbuf	struct
*	O
sb	pointer
)	O
{	O
free	function
(	O
sb	pointer
->	O
buffer	pointer
)	O
;	O
stringbuf_init	function
(	O
sb	pointer
)	O
;	O
}	O
void	O
stringbuf_add_char	function
(	O
struct	O
stringbuf	struct
*	O
sb	pointer
,	O
int	O
c	int
)	O
{	O
if	O
(	O
sb	pointer
->	O
pos	long
+	O
1	int
>	O
sb	pointer
->	O
size	long
)	O
sb	pointer
->	O
buffer	pointer
=	O
x2realloc	function
(	O
sb	pointer
->	O
buffer	pointer
,	O
&	O
sb	pointer
->	O
size	long
)	O
;	O
sb	pointer
->	O
buffer	pointer
[	O
sb	pointer
->	O
pos	long
++	O
]	O
=	O
c	int
;	O
}	O
void	O
stringbuf_add_array	function
(	O
struct	O
stringbuf	struct
*	O
sb	pointer
,	O
char	O
const	O
*	O
str	pointer
,	O
size_t	long
len	long
)	O
{	O
while	O
(	O
sb	pointer
->	O
pos	long
+	O
len	long
>	O
sb	pointer
->	O
size	long
)	O
sb	pointer
->	O
buffer	pointer
=	O
x2realloc	function
(	O
sb	pointer
->	O
buffer	pointer
,	O
&	O
sb	pointer
->	O
size	long
)	O
;	O
memcpy	function
(	O
sb	pointer
->	O
buffer	pointer
+	O
sb	pointer
->	O
pos	long
,	O
str	pointer
,	O
len	long
)	O
;	O
sb	pointer
->	O
pos	long
+=	O
len	long
;	O
}	O
void	O
stringbuf_add_string	function
(	O
struct	O
stringbuf	struct
*	O
sb	pointer
,	O
char	O
const	O
*	O
str	pointer
)	O
{	O
stringbuf_add_array	function
(	O
sb	pointer
,	O
str	pointer
,	O
strlen	function
(	O
str	pointer
)	O
)	O
;	O
}	O
void	O
stringbuf_add_num	function
(	O
struct	O
stringbuf	struct
*	O
sb	pointer
,	O
unsigned	O
n	long
)	O
{	O
size_t	long
i	long
=	O
sb	pointer
->	O
pos	long
,	O
j	long
;	O
do	O
{	O
static	O
char	O
dig	array
[	O
]	O
=	O
"0123456789"	pointer
;	O
stringbuf_add_char	function
(	O
sb	pointer
,	O
dig	array
[	O
n	long
%	O
10	int
]	O
)	O
;	O
n	long
/=	O
10	int
;	O
}	O
while	O
(	O
n	long
>	O
0	int
)	O
;	O
for	O
(	O
j	long
=	O
sb	pointer
->	O
pos	long
-	O
1	int
;	O
j	long
>	O
i	long
;	O
i	long
++	O
,	O
j	long
--	O
)	O
{	O
char	O
c	int
=	O
sb	pointer
->	O
buffer	pointer
[	O
i	long
]	O
;	O
sb	pointer
->	O
buffer	pointer
[	O
i	long
]	O
=	O
sb	pointer
->	O
buffer	pointer
[	O
j	long
]	O
;	O
sb	pointer
->	O
buffer	pointer
[	O
j	long
]	O
=	O
c	int
;	O
}	O
}	O
void	O
stringbuf_finish	function
(	O
struct	O
stringbuf	struct
*	O
sb	pointer
)	O
{	O
stringbuf_add_char	function
(	O
sb	pointer
,	O
0	int
)	O
;	O
}	O
void	O
cfpoint_format	function
(	O
struct	O
cfpoint	struct
const	O
*	O
cfp	pointer
,	O
struct	O
stringbuf	struct
*	O
sb	pointer
)	O
{	O
if	O
(	O
cfp	pointer
->	O
filename	pointer
)	O
{	O
stringbuf_add_string	function
(	O
sb	pointer
,	O
cfp	pointer
->	O
filename	pointer
)	O
;	O
stringbuf_add_char	function
(	O
sb	pointer
,	O
':'	O
)	O
;	O
stringbuf_add_num	function
(	O
sb	pointer
,	O
cfp	pointer
->	O
line	int
)	O
;	O
if	O
(	O
cfp	pointer
->	O
column	int
)	O
{	O
stringbuf_add_char	function
(	O
sb	pointer
,	O
'.'	O
)	O
;	O
stringbuf_add_num	function
(	O
sb	pointer
,	O
cfp	pointer
->	O
column	int
)	O
;	O
}	O
}	O
}	O
void	O
cfloc_format	function
(	O
struct	O
cfloc	struct
const	O
*	O
cfl	pointer
,	O
struct	O
stringbuf	struct
*	O
sb	pointer
)	O
{	O
cfpoint_format	function
(	O
&	O
cfl	pointer
->	O
beg	struct
,	O
sb	pointer
)	O
;	O
if	O
(	O
cfl	pointer
->	O
end	pointer
.	O
filename	pointer
)	O
{	O
if	O
(	O
cfl	pointer
->	O
beg	struct
.	O
filename	pointer
!=	O
cfl	pointer
->	O
end	pointer
.	O
filename	pointer
)	O
{	O
stringbuf_add_char	function
(	O
sb	pointer
,	O
'-'	O
)	O
;	O
cfpoint_format	function
(	O
&	O
cfl	pointer
->	O
end	pointer
,	O
sb	pointer
)	O
;	O
}	O
else	O
if	O
(	O
cfl	pointer
->	O
beg	struct
.	O
line	int
!=	O
cfl	pointer
->	O
end	pointer
.	O
line	int
)	O
{	O
stringbuf_add_char	function
(	O
sb	pointer
,	O
'-'	O
)	O
;	O
stringbuf_add_num	function
(	O
sb	pointer
,	O
cfl	pointer
->	O
end	pointer
.	O
line	int
)	O
;	O
if	O
(	O
cfl	pointer
->	O
end	pointer
.	O
column	int
)	O
{	O
stringbuf_add_char	function
(	O
sb	pointer
,	O
'.'	O
)	O
;	O
stringbuf_add_num	function
(	O
sb	pointer
,	O
cfl	pointer
->	O
end	pointer
.	O
column	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
cfl	pointer
->	O
beg	struct
.	O
column	int
&&	O
cfl	pointer
->	O
beg	struct
.	O
column	int
!=	O
cfl	pointer
->	O
end	pointer
.	O
column	int
)	O
{	O
stringbuf_add_char	function
(	O
sb	pointer
,	O
'-'	O
)	O
;	O
stringbuf_add_num	function
(	O
sb	pointer
,	O
cfl	pointer
->	O
end	pointer
.	O
column	int
)	O
;	O
}	O
}	O
}	O
void	O
cfloc_print	function
(	O
struct	O
cfloc	struct
const	O
*	O
cfl	pointer
,	O
FILE	struct
*	O
fp	pointer
)	O
{	O
struct	O
stringbuf	struct
sb	pointer
;	O
stringbuf_init	function
(	O
&	O
sb	pointer
)	O
;	O
cfloc_format	function
(	O
cfl	pointer
,	O
&	O
sb	pointer
)	O
;	O
fwrite	function
(	O
sb	pointer
.	O
buffer	pointer
,	O
sb	pointer
.	O
pos	long
,	O
1	int
,	O
fp	pointer
)	O
;	O
stringbuf_free	function
(	O
&	O
sb	pointer
)	O
;	O
}	O
void	O
vcferror	function
(	O
struct	O
cfloc	struct
const	O
*	O
loc	pointer
,	O
char	O
const	O
*	O
fmt	pointer
,	O
va_list	array
ap	array
)	O
{	O
struct	O
stringbuf	struct
sb	pointer
;	O
stringbuf_init	function
(	O
&	O
sb	pointer
)	O
;	O
cfloc_format	function
(	O
loc	pointer
,	O
&	O
sb	pointer
)	O
;	O
stringbuf_add_array	function
(	O
&	O
sb	pointer
,	O
": "	pointer
,	O
2	int
)	O
;	O
stringbuf_add_string	function
(	O
&	O
sb	pointer
,	O
fmt	pointer
)	O
;	O
stringbuf_finish	function
(	O
&	O
sb	pointer
)	O
;	O
vlogmsg	function
(	O
LOG_ERR	int
,	O
sb	pointer
.	O
buffer	pointer
,	O
ap	array
)	O
;	O
stringbuf_free	function
(	O
&	O
sb	pointer
)	O
;	O
}	O
void	O
cferror	function
(	O
struct	O
cfloc	struct
const	O
*	O
loc	pointer
,	O
char	O
const	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
vcferror	function
(	O
loc	pointer
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
}	O
struct	O
cfstream_file	struct
{	O
CFSTREAM	struct
base	struct
;	O
FILE	struct
*	O
fp	pointer
;	O
}	O
;	O
static	O
CFSTREAM	struct
*	O
cfstream_create	function
(	O
int	O
fd	int
,	O
size_t	long
bs	long
)	O
{	O
CFSTREAM	struct
*	O
cf	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
*	O
cf	pointer
)	O
)	O
;	O
cf	pointer
->	O
fd	int
=	O
fd	int
;	O
cf	pointer
->	O
buffer	pointer
=	O
xmalloc	function
(	O
bs	long
)	O
;	O
cf	pointer
->	O
size	long
=	O
bs	long
;	O
cf	pointer
->	O
level	long
=	O
0	int
;	O
cf	pointer
->	O
pos	long
=	O
0	int
;	O
cf	pointer
->	O
eol	int
=	O
0	int
;	O
cf	pointer
->	O
eof	int
=	O
0	int
;	O
return	O
cf	pointer
;	O
}	O
CFSTREAM	struct
*	O
cfstream_open_file	function
(	O
char	O
const	O
*	O
filename	pointer
)	O
{	O
int	O
fd	int
;	O
struct	O
stat	struct
st	pointer
;	O
if	O
(	O
stat	struct
(	O
filename	pointer
,	O
&	O
st	pointer
)	O
)	O
{	O
die	function
(	O
system_error	int
,	O
NULL	O
,	O
_	O
(	O
"cannot stat file %s: %s"	pointer
)	O
,	O
filename	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
if	O
(	O
check_config_permissions	function
(	O
filename	pointer
,	O
&	O
st	pointer
)	O
)	O
die	function
(	O
config_error	int
,	O
NULL	O
,	O
_	O
(	O
"%s: file is not safe"	pointer
)	O
,	O
filename	pointer
)	O
;	O
fd	int
=	O
open	function
(	O
filename	pointer
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
fd	int
==	O
-	O
1	int
)	O
die	function
(	O
system_error	int
,	O
NULL	O
,	O
_	O
(	O
"cannot open file %s: %s"	pointer
)	O
,	O
filename	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
cfstream_create	function
(	O
fd	int
,	O
CFSTREAM_BUFSIZE	int
)	O
;	O
}	O
CFSTREAM	struct
*	O
cfstream_open_stdin	function
(	O
void	O
)	O
{	O
return	O
cfstream_create	function
(	O
0	int
,	O
CFSTREAM_BUFSIZE	int
)	O
;	O
}	O
CFSTREAM	struct
*	O
cfstream_open_mem	function
(	O
char	O
const	O
*	O
buffer	pointer
,	O
size_t	long
len	long
)	O
{	O
CFSTREAM	struct
*	O
cf	pointer
=	O
cfstream_create	function
(	O
-	O
1	int
,	O
len	long
)	O
;	O
memcpy	function
(	O
cf	pointer
->	O
buffer	pointer
,	O
buffer	pointer
,	O
len	long
)	O
;	O
cf	pointer
->	O
size	long
=	O
len	long
;	O
cf	pointer
->	O
level	long
=	O
len	long
;	O
return	O
cf	pointer
;	O
}	O
void	O
cfstream_close	function
(	O
CFSTREAM	struct
*	O
cf	pointer
)	O
{	O
if	O
(	O
cf	pointer
->	O
fd	int
!=	O
-	O
1	int
)	O
close	pointer
(	O
cf	pointer
->	O
fd	int
)	O
;	O
free	function
(	O
cf	pointer
->	O
buffer	pointer
)	O
;	O
free	function
(	O
cf	pointer
)	O
;	O
}	O
void	O
cfstream_rewind	function
(	O
CFSTREAM	struct
*	O
cf	pointer
)	O
{	O
if	O
(	O
cf	pointer
->	O
fd	int
>=	O
0	int
)	O
{	O
if	O
(	O
lseek	function
(	O
cf	pointer
->	O
fd	int
,	O
0	int
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
die	function
(	O
system_error	int
,	O
NULL	O
,	O
"lseek: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
cf	pointer
->	O
level	long
=	O
0	int
;	O
}	O
else	O
cf	pointer
->	O
level	long
=	O
cf	pointer
->	O
size	long
;	O
cf	pointer
->	O
pos	long
=	O
0	int
;	O
cf	pointer
->	O
eol	int
=	O
0	int
;	O
cf	pointer
->	O
eof	int
=	O
0	int
;	O
}	O
static	O
inline	O
size_t	long
cfstream_buf_avail	function
(	O
CFSTREAM	struct
*	O
cf	pointer
)	O
{	O
return	O
cf	pointer
->	O
level	long
-	O
cf	pointer
->	O
pos	long
;	O
}	O
static	O
size_t	long
cfstream_avail	function
(	O
CFSTREAM	struct
*	O
cf	pointer
)	O
{	O
size_t	long
avail	long
=	O
cfstream_buf_avail	function
(	O
cf	pointer
)	O
;	O
if	O
(	O
avail	long
==	O
0	int
)	O
{	O
if	O
(	O
cf	pointer
->	O
eof	int
||	O
cf	pointer
->	O
fd	int
==	O
-	O
1	int
)	O
return	O
0	int
;	O
else	O
{	O
ssize_t	long
rc	long
;	O
rc	long
=	O
read	pointer
(	O
cf	pointer
->	O
fd	int
,	O
cf	pointer
->	O
buffer	pointer
,	O
cf	pointer
->	O
size	long
)	O
;	O
if	O
(	O
rc	long
==	O
-	O
1	int
)	O
die	function
(	O
system_error	int
,	O
NULL	O
,	O
"read: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
cf	pointer
->	O
level	long
=	O
rc	long
;	O
cf	pointer
->	O
pos	long
=	O
0	int
;	O
if	O
(	O
rc	long
==	O
0	int
)	O
{	O
cf	pointer
->	O
eof	int
=	O
1	int
;	O
return	O
0	int
;	O
}	O
avail	long
=	O
cfstream_buf_avail	function
(	O
cf	pointer
)	O
;	O
}	O
}	O
return	O
avail	long
;	O
}	O
static	O
inline	O
char	O
const	O
*	O
cfstream_buf_ptr	function
(	O
CFSTREAM	struct
*	O
cf	pointer
)	O
{	O
return	O
cf	pointer
->	O
buffer	pointer
+	O
cf	pointer
->	O
pos	long
;	O
}	O
static	O
inline	O
void	O
cfstream_buf_advance	function
(	O
CFSTREAM	struct
*	O
cf	pointer
,	O
size_t	long
n	long
)	O
{	O
cf	pointer
->	O
pos	long
+=	O
n	long
;	O
}	O
ssize_t	long
cfstream_read	function
(	O
CFSTREAM	struct
*	O
cf	pointer
,	O
char	O
*	O
bufptr	pointer
,	O
size_t	long
bufsize	long
)	O
{	O
size_t	long
nrd	long
=	O
0	int
;	O
if	O
(	O
!	O
cf	pointer
)	O
return	O
0	int
;	O
while	O
(	O
nrd	long
<	O
bufsize	long
)	O
{	O
size_t	long
n	long
=	O
bufsize	long
-	O
nrd	long
;	O
size_t	long
avail	long
=	O
cfstream_avail	function
(	O
cf	pointer
)	O
;	O
if	O
(	O
avail	long
==	O
0	int
)	O
{	O
if	O
(	O
!	O
cf	pointer
->	O
eol	int
)	O
{	O
bufptr	pointer
[	O
nrd	long
++	O
]	O
=	O
'\n'	O
;	O
cf	pointer
->	O
eol	int
=	O
1	int
;	O
}	O
break	O
;	O
}	O
if	O
(	O
n	long
>	O
avail	long
)	O
n	long
=	O
avail	long
;	O
memcpy	function
(	O
bufptr	pointer
+	O
nrd	long
,	O
cfstream_buf_ptr	function
(	O
cf	pointer
)	O
,	O
n	long
)	O
;	O
cfstream_buf_advance	function
(	O
cf	pointer
,	O
n	long
)	O
;	O
nrd	long
+=	O
n	long
;	O
cf	pointer
->	O
eol	int
=	O
bufptr	pointer
[	O
nrd	long
-	O
1	int
]	O
==	O
'\n'	O
;	O
}	O
return	O
nrd	long
;	O
}	O
int	O
cfstream_same_file	function
(	O
CFSTREAM	struct
*	O
cf	pointer
,	O
struct	O
stat	struct
const	O
*	O
st	pointer
)	O
{	O
struct	O
stat	struct
fst	struct
;	O
if	O
(	O
cf	pointer
->	O
fd	int
<	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
fstat	function
(	O
cf	pointer
->	O
fd	int
,	O
&	O
fst	struct
)	O
)	O
{	O
logmsg	function
(	O
LOG_ERR	int
,	O
"fstat: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
return	O
fst	struct
.	O
st_dev	long
==	O
st	pointer
->	O
st_dev	long
&&	O
fst	struct
.	O
st_ino	long
==	O
st	pointer
->	O
st_ino	long
;	O
}	O
const	O
char	O
default_entry	array
[	O
]	O
=	O
""	pointer
;	O
void	O
cfparse	function
(	O
void	O
)	O
{	O
CFSTREAM	struct
*	O
cf	pointer
;	O
char	O
const	O
*	O
filename	pointer
;	O
if	O
(	O
access	function
(	O
rush_config_file	pointer
,	O
F_OK	int
)	O
==	O
0	int
)	O
{	O
cf	pointer
=	O
cfstream_open_file	function
(	O
rush_config_file	pointer
)	O
;	O
filename	pointer
=	O
rush_config_file	pointer
;	O
}	O
else	O
if	O
(	O
default_entry	array
[	O
0	int
]	O
)	O
{	O
cf	pointer
=	O
cfstream_open_mem	function
(	O
default_entry	array
,	O
sizeof	O
(	O
default_entry	array
)	O
-	O
1	int
)	O
;	O
filename	pointer
=	O
"<built-in>"	pointer
;	O
}	O
else	O
{	O
die	function
(	O
usage_error	int
,	O
NULL	O
,	O
_	O
(	O
"configuration file does not exist and no default is provided"	pointer
)	O
)	O
;	O
}	O
cflex_setup	function
(	O
cf	pointer
,	O
filename	pointer
,	O
1	int
)	O
;	O
if	O
(	O
yyparse	function
(	O
)	O
)	O
die	function
(	O
config_error	int
,	O
NULL	O
,	O
_	O
(	O
"errors in configuration file"	pointer
)	O
)	O
;	O
}	O
int	O
parse_file_mode	function
(	O
const	O
char	O
*	O
val	array
,	O
mode_t	int
*	O
mode	pointer
,	O
struct	O
cfloc	struct
const	O
*	O
loc	pointer
)	O
{	O
char	O
*	O
q	pointer
;	O
unsigned	O
int	O
n	long
=	O
strtoul	function
(	O
val	array
,	O
&	O
q	pointer
,	O
8	int
)	O
;	O
if	O
(	O
*	O
q	pointer
||	O
(	O
n	long
&	O
~	O
0777	int
)	O
)	O
{	O
cferror	function
(	O
loc	pointer
,	O
"%s"	pointer
,	O
_	O
(	O
"not a valid file mode"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
*	O
mode	pointer
=	O
n	long
;	O
return	O
0	int
;	O
}	O
int	O
absolute_dir_p	function
(	O
const	O
char	O
*	O
dir	enum
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
enum	O
{	O
state_init	int
,	O
state_dot	int
,	O
state_double_dot	int
}	O
state	pointer
=	O
state_init	int
;	O
if	O
(	O
dir	enum
[	O
0	int
]	O
!=	O
'/'	O
)	O
return	O
0	int
;	O
for	O
(	O
p	pointer
=	O
dir	enum
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
{	O
switch	O
(	O
*	O
p	pointer
)	O
{	O
case	O
'.'	O
:	O
switch	O
(	O
state	pointer
)	O
{	O
case	O
state_init	int
:	O
state	pointer
=	O
state_dot	int
;	O
break	O
;	O
case	O
state_dot	int
:	O
state	pointer
=	O
state_double_dot	int
;	O
break	O
;	O
case	O
state_double_dot	int
:	O
state	pointer
=	O
state_init	int
;	O
}	O
break	O
;	O
case	O
'/'	O
:	O
if	O
(	O
state	pointer
!=	O
state_init	int
)	O
return	O
0	int
;	O
break	O
;	O
default	O
:	O
state	pointer
=	O
state_init	int
;	O
}	O
}	O
return	O
state	pointer
==	O
state_init	int
;	O
}	O
static	O
int	O
check_dir	function
(	O
const	O
char	O
*	O
dir	enum
,	O
struct	O
cfloc	struct
const	O
*	O
loc	pointer
)	O
{	O
struct	O
stat	struct
st	pointer
;	O
if	O
(	O
dir	enum
[	O
0	int
]	O
==	O
'~'	O
)	O
{	O
if	O
(	O
dir	enum
[	O
1	int
]	O
&&	O
!	O
absolute_dir_p	function
(	O
dir	enum
+	O
1	int
)	O
)	O
{	O
cferror	function
(	O
loc	pointer
,	O
"%s"	pointer
,	O
_	O
(	O
"not an absolute directory name"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
!	O
absolute_dir_p	function
(	O
dir	enum
)	O
)	O
{	O
cferror	function
(	O
loc	pointer
,	O
"%s"	pointer
,	O
_	O
(	O
"not an absolute directory name"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
stat	struct
(	O
dir	enum
,	O
&	O
st	pointer
)	O
)	O
{	O
cferror	function
(	O
loc	pointer
,	O
_	O
(	O
"cannot stat %s: %s"	pointer
)	O
,	O
dir	enum
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
!	O
S_ISDIR	O
(	O
st	pointer
.	O
st_mode	int
)	O
)	O
{	O
cferror	function
(	O
loc	pointer
,	O
_	O
(	O
"%s is not a directory"	pointer
)	O
,	O
dir	enum
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
get_bool	function
(	O
const	O
char	O
*	O
val	array
,	O
int	O
*	O
res	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
val	array
,	O
"yes"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
val	array
,	O
"on"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
val	array
,	O
"t"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
val	array
,	O
"true"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
val	array
,	O
"1"	pointer
)	O
==	O
0	int
)	O
*	O
res	pointer
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
val	array
,	O
"no"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
val	array
,	O
"off"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
val	array
,	O
"nil"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
val	array
,	O
"false"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
val	array
,	O
"0"	pointer
)	O
==	O
0	int
)	O
*	O
res	pointer
=	O
0	int
;	O
else	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
copy_part	function
(	O
const	O
char	O
*	O
cstr	pointer
,	O
const	O
char	O
*	O
p	pointer
,	O
char	O
*	O
*	O
pbuf	pointer
)	O
{	O
size_t	long
len	long
=	O
p	pointer
-	O
cstr	pointer
;	O
char	O
*	O
buf	pointer
=	O
malloc	function
(	O
len	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
buf	pointer
)	O
return	O
1	int
;	O
memcpy	function
(	O
buf	pointer
,	O
cstr	pointer
,	O
len	long
)	O
;	O
buf	pointer
[	O
len	long
]	O
=	O
0	int
;	O
*	O
pbuf	pointer
=	O
buf	pointer
;	O
return	O
0	int
;	O
}	O
static	O
int	O
parse_conn	function
(	O
const	O
char	O
*	O
cstr	pointer
,	O
char	O
*	O
*	O
pport	pointer
,	O
char	O
*	O
*	O
ppath	pointer
)	O
{	O
const	O
char	O
*	O
p	pointer
=	O
strchr	function
(	O
cstr	pointer
,	O
':'	O
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
*	O
pport	pointer
=	O
NULL	O
;	O
*	O
ppath	pointer
=	O
strdup	function
(	O
cstr	pointer
)	O
;	O
return	O
*	O
ppath	pointer
==	O
NULL	O
;	O
}	O
else	O
if	O
(	O
copy_part	function
(	O
cstr	pointer
,	O
p	pointer
,	O
ppath	pointer
)	O
)	O
return	O
1	int
;	O
else	O
cstr	pointer
=	O
p	pointer
+	O
1	int
;	O
*	O
pport	pointer
=	O
strdup	function
(	O
cstr	pointer
)	O
;	O
return	O
*	O
pport	pointer
==	O
NULL	O
;	O
}	O
struct	O
socket_family	struct
{	O
char	O
*	O
name	pointer
;	O
size_t	long
len	long
;	O
int	O
family	int
;	O
}	O
;	O
static	O
struct	O
socket_family	struct
socket_family	struct
[	O
]	O
=	O
{	O
DEF	O
(	O
inet	O
,	O
AF_INET	O
)	O
,	O
DEF	O
(	O
unix	O
,	O
AF_UNIX	O
)	O
,	O
DEF	O
(	O
local	O
,	O
AF_UNIX	O
)	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
struct	O
socket_family	struct
*	O
find_family	function
(	O
const	O
char	O
*	O
s	long
,	O
size_t	long
len	long
)	O
{	O
struct	O
socket_family	struct
*	O
fp	pointer
;	O
for	O
(	O
fp	pointer
=	O
socket_family	struct
;	O
fp	pointer
->	O
name	pointer
;	O
fp	pointer
++	O
)	O
if	O
(	O
len	long
==	O
fp	pointer
->	O
len	long
)	O
return	O
fp	pointer
;	O
return	O
NULL	O
;	O
}	O
static	O
int	O
parse_url	function
(	O
struct	O
cfloc	struct
const	O
*	O
loc	pointer
,	O
const	O
char	O
*	O
cstr	pointer
,	O
int	O
*	O
pfamily	pointer
,	O
char	O
*	O
*	O
pport	pointer
,	O
char	O
*	O
*	O
ppath	pointer
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
p	pointer
=	O
strchr	function
(	O
cstr	pointer
,	O
':'	O
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
struct	O
socket_family	struct
*	O
fp	pointer
=	O
find_family	function
(	O
cstr	pointer
,	O
p	pointer
-	O
cstr	pointer
)	O
;	O
if	O
(	O
!	O
fp	pointer
)	O
{	O
cferror	function
(	O
loc	pointer
,	O
"%s"	pointer
,	O
_	O
(	O
"unknown address family"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
*	O
pfamily	pointer
=	O
fp	pointer
->	O
family	int
;	O
cstr	pointer
=	O
p	pointer
+	O
1	int
;	O
if	O
(	O
cstr	pointer
[	O
0	int
]	O
==	O
'/'	O
)	O
{	O
if	O
(	O
cstr	pointer
[	O
1	int
]	O
==	O
'/'	O
)	O
{	O
return	O
parse_conn	function
(	O
cstr	pointer
+	O
2	int
,	O
pport	pointer
,	O
ppath	pointer
)	O
;	O
}	O
else	O
if	O
(	O
*	O
pfamily	pointer
==	O
AF_UNIX	O
)	O
{	O
*	O
pport	pointer
=	O
NULL	O
;	O
*	O
ppath	pointer
=	O
strdup	function
(	O
cstr	pointer
)	O
;	O
return	O
*	O
ppath	pointer
==	O
NULL	O
;	O
}	O
}	O
else	O
{	O
cferror	function
(	O
loc	pointer
,	O
"%s"	pointer
,	O
_	O
(	O
"malformed URL"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
else	O
{	O
*	O
pfamily	pointer
=	O
AF_UNIX	O
;	O
*	O
pport	pointer
=	O
NULL	O
;	O
*	O
ppath	pointer
=	O
strdup	function
(	O
cstr	pointer
)	O
;	O
return	O
*	O
ppath	pointer
==	O
NULL	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
make_socket	function
(	O
struct	O
cfloc	struct
const	O
*	O
loc	pointer
,	O
int	O
family	int
,	O
char	O
*	O
port	pointer
,	O
char	O
*	O
path	pointer
,	O
struct	O
rush_sockaddr	struct
*	O
pa	pointer
)	O
{	O
union	O
{	O
struct	O
sockaddr	struct
sa	pointer
;	O
struct	O
sockaddr_un	struct
s_un	struct
;	O
struct	O
sockaddr_in	struct
s_in	struct
;	O
}	O
addr	union
;	O
socklen_t	int
socklen	int
;	O
short	O
pnum	short
;	O
long	O
num	long
;	O
char	O
*	O
p	pointer
;	O
switch	O
(	O
family	int
)	O
{	O
case	O
AF_UNIX	O
:	O
if	O
(	O
port	pointer
)	O
{	O
cferror	function
(	O
loc	pointer
,	O
"%s"	pointer
,	O
_	O
(	O
"port is meaningless for UNIX sockets"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
strlen	function
(	O
path	pointer
)	O
>	O
sizeof	O
addr	union
.	O
s_un	struct
.	O
sun_path	array
)	O
{	O
errno	O
=	O
EINVAL	int
;	O
cferror	function
(	O
loc	pointer
,	O
"%s"	pointer
,	O
_	O
(	O
"UNIX socket name too long"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
addr	union
.	O
sa	pointer
.	O
sa_family	short
=	O
PF_UNIX	O
;	O
socklen	int
=	O
sizeof	O
(	O
addr	union
.	O
s_un	struct
)	O
;	O
strcpy	function
(	O
addr	union
.	O
s_un	struct
.	O
sun_path	array
,	O
path	pointer
)	O
;	O
break	O
;	O
case	O
AF_INET	O
:	O
addr	union
.	O
sa	pointer
.	O
sa_family	short
=	O
PF_INET	int
;	O
socklen	int
=	O
sizeof	O
(	O
addr	union
.	O
s_in	struct
)	O
;	O
num	long
=	O
pnum	short
=	O
strtol	function
(	O
port	pointer
,	O
&	O
p	pointer
,	O
0	int
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
0	int
)	O
{	O
if	O
(	O
num	long
!=	O
pnum	short
)	O
{	O
cferror	function
(	O
loc	pointer
,	O
"%s"	pointer
,	O
_	O
(	O
"bad port number"	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
pnum	short
=	O
htons	function
(	O
pnum	short
)	O
;	O
}	O
else	O
{	O
struct	O
servent	struct
*	O
sp	pointer
=	O
getservbyname	function
(	O
port	pointer
,	O
"tcp"	pointer
)	O
;	O
if	O
(	O
!	O
sp	pointer
)	O
{	O
cferror	function
(	O
loc	pointer
,	O
"%s"	pointer
,	O
_	O
(	O
"unknown service name"	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
pnum	short
=	O
sp	pointer
->	O
s_port	int
;	O
}	O
if	O
(	O
!	O
path	pointer
)	O
addr	union
.	O
s_in	struct
.	O
sin_addr	struct
.	O
s_addr	int
=	O
INADDR_ANY	O
;	O
else	O
{	O
struct	O
hostent	struct
*	O
hp	pointer
=	O
gethostbyname	function
(	O
path	pointer
)	O
;	O
if	O
(	O
!	O
hp	pointer
)	O
{	O
cferror	function
(	O
loc	pointer
,	O
"%s"	pointer
,	O
_	O
(	O
"unknown host name %s"	pointer
)	O
,	O
path	pointer
)	O
;	O
return	O
1	int
;	O
}	O
addr	union
.	O
sa	pointer
.	O
sa_family	short
=	O
hp	pointer
->	O
h_addrtype	int
;	O
switch	O
(	O
hp	pointer
->	O
h_addrtype	int
)	O
{	O
case	O
AF_INET	O
:	O
memmove	function
(	O
&	O
addr	union
.	O
s_in	struct
.	O
sin_addr	struct
,	O
hp	pointer
->	O
h_addr	O
,	O
4	int
)	O
;	O
addr	union
.	O
s_in	struct
.	O
sin_port	short
=	O
pnum	short
;	O
break	O
;	O
default	O
:	O
cferror	function
(	O
loc	pointer
,	O
"%s"	pointer
,	O
_	O
(	O
"unsupported address family"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
break	O
;	O
default	O
:	O
cferror	function
(	O
loc	pointer
,	O
"%s"	pointer
,	O
_	O
(	O
"unsupported address family"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
pa	pointer
->	O
len	long
=	O
socklen	int
;	O
pa	pointer
->	O
sa	pointer
=	O
xmalloc	function
(	O
socklen	int
)	O
;	O
memcpy	function
(	O
pa	pointer
->	O
sa	pointer
,	O
&	O
addr	union
.	O
sa	pointer
,	O
socklen	int
)	O
;	O
return	O
0	int
;	O
}	O
int	O
attrib_umask	function
(	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
char	O
const	O
*	O
arg	struct
,	O
struct	O
cfloc	struct
const	O
*	O
loc	pointer
)	O
{	O
return	O
parse_file_mode	function
(	O
arg	struct
,	O
&	O
rule	pointer
->	O
mask	int
,	O
loc	pointer
)	O
;	O
}	O
int	O
attrib_chroot	function
(	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
char	O
const	O
*	O
arg	struct
,	O
struct	O
cfloc	struct
const	O
*	O
loc	pointer
)	O
{	O
char	O
*	O
chroot_dir	pointer
=	O
xstrdup	function
(	O
arg	struct
)	O
;	O
int	O
rc	long
=	O
0	int
;	O
if	O
(	O
trimslash	function
(	O
chroot_dir	pointer
)	O
==	O
0	int
)	O
{	O
cferror	function
(	O
loc	pointer
,	O
"%s"	pointer
,	O
_	O
(	O
"invalid chroot directory"	pointer
)	O
)	O
;	O
rc	long
=	O
1	int
;	O
}	O
else	O
if	O
(	O
check_dir	function
(	O
chroot_dir	pointer
,	O
loc	pointer
)	O
)	O
rc	long
=	O
1	int
;	O
if	O
(	O
rc	long
)	O
free	function
(	O
chroot_dir	pointer
)	O
;	O
else	O
rule	pointer
->	O
chroot_dir	pointer
=	O
chroot_dir	pointer
;	O
return	O
rc	long
;	O
}	O
int	O
attrib_chdir	function
(	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
char	O
const	O
*	O
arg	struct
,	O
struct	O
cfloc	struct
const	O
*	O
loc	pointer
)	O
{	O
rule	pointer
->	O
home_dir	pointer
=	O
xstrdup	function
(	O
arg	struct
)	O
;	O
if	O
(	O
trimslash	function
(	O
rule	pointer
->	O
home_dir	pointer
)	O
==	O
0	int
)	O
{	O
cferror	function
(	O
loc	pointer
,	O
"%s"	pointer
,	O
_	O
(	O
"invalid home directory"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
attrib_fork	function
(	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
char	O
const	O
*	O
arg	struct
,	O
struct	O
cfloc	struct
const	O
*	O
loc	pointer
)	O
{	O
int	O
yes	int
;	O
if	O
(	O
get_bool	function
(	O
arg	struct
,	O
&	O
yes	int
)	O
)	O
{	O
cferror	function
(	O
loc	pointer
,	O
_	O
(	O
"expected boolean value, but found `%s'"	pointer
)	O
,	O
arg	struct
)	O
;	O
return	O
1	int
;	O
}	O
rule	pointer
->	O
fork	function
=	O
yes	int
?	O
rush_true	int
:	O
rush_false	int
;	O
return	O
0	int
;	O
}	O
int	O
attrib_acct	function
(	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
char	O
const	O
*	O
arg	struct
,	O
struct	O
cfloc	struct
const	O
*	O
loc	pointer
)	O
{	O
int	O
yes	int
;	O
if	O
(	O
get_bool	function
(	O
arg	struct
,	O
&	O
yes	int
)	O
)	O
{	O
cferror	function
(	O
loc	pointer
,	O
_	O
(	O
"expected boolean value, but found `%s'"	pointer
)	O
,	O
arg	struct
)	O
;	O
return	O
1	int
;	O
}	O
rule	pointer
->	O
acct	function
=	O
yes	int
?	O
rush_true	int
:	O
rush_false	int
;	O
return	O
0	int
;	O
}	O
int	O
attrib_post_socket	function
(	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
char	O
const	O
*	O
arg	struct
,	O
struct	O
cfloc	struct
const	O
*	O
loc	pointer
)	O
{	O
int	O
family	int
;	O
char	O
*	O
path	pointer
;	O
char	O
*	O
port	pointer
;	O
int	O
rc	long
;	O
if	O
(	O
parse_url	function
(	O
loc	pointer
,	O
arg	struct
,	O
&	O
family	int
,	O
&	O
port	pointer
,	O
&	O
path	pointer
)	O
)	O
return	O
1	int
;	O
rc	long
=	O
make_socket	function
(	O
loc	pointer
,	O
family	int
,	O
port	pointer
?	O
port	pointer
:	O
"tcpmux"	pointer
,	O
path	pointer
,	O
&	O
rule	pointer
->	O
post_sockaddr	struct
)	O
;	O
free	function
(	O
port	pointer
)	O
;	O
free	function
(	O
path	pointer
)	O
;	O
return	O
rc	long
;	O
}	O
static	O
int	O
attrib_text_domain	function
(	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
char	O
const	O
*	O
arg	struct
,	O
struct	O
cfloc	struct
const	O
*	O
loc	pointer
)	O
{	O
rule	pointer
->	O
i18n	struct
.	O
text_domain	pointer
=	O
xstrdup	function
(	O
arg	struct
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
attrib_locale_dir	function
(	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
char	O
const	O
*	O
arg	struct
,	O
struct	O
cfloc	struct
const	O
*	O
loc	pointer
)	O
{	O
rule	pointer
->	O
i18n	struct
.	O
localedir	pointer
=	O
xstrdup	function
(	O
arg	struct
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
attrib_locale	function
(	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
char	O
const	O
*	O
arg	struct
,	O
struct	O
cfloc	struct
const	O
*	O
loc	pointer
)	O
{	O
rule	pointer
->	O
i18n	struct
.	O
locale	pointer
=	O
xstrdup	function
(	O
arg	struct
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
attrib_interactive	function
(	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
char	O
const	O
*	O
arg	struct
,	O
struct	O
cfloc	struct
const	O
*	O
loc	pointer
)	O
{	O
if	O
(	O
get_bool	function
(	O
arg	struct
,	O
&	O
rule	pointer
->	O
interactive	int
)	O
)	O
{	O
cferror	function
(	O
loc	pointer
,	O
_	O
(	O
"expected boolean value, but found `%s'"	pointer
)	O
,	O
arg	struct
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
attrib_newgroup	function
(	O
struct	O
rush_rule	struct
*	O
rule	pointer
,	O
char	O
const	O
*	O
arg	struct
,	O
struct	O
cfloc	struct
const	O
*	O
loc	pointer
)	O
{	O
struct	O
group	struct
*	O
grp	pointer
;	O
if	O
(	O
c_isdigit	function
(	O
arg	struct
[	O
0	int
]	O
)	O
)	O
{	O
char	O
*	O
p	pointer
;	O
unsigned	O
long	O
n	long
=	O
strtoul	function
(	O
arg	struct
,	O
&	O
p	pointer
,	O
10	int
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
0	int
)	O
{	O
rule	pointer
->	O
gid	int
=	O
n	long
;	O
return	O
0	int
;	O
}	O
}	O
grp	pointer
=	O
getgrnam	function
(	O
arg	struct
)	O
;	O
if	O
(	O
!	O
grp	pointer
)	O
{	O
cferror	function
(	O
loc	pointer
,	O
_	O
(	O
"no such group: %s"	pointer
)	O
,	O
arg	struct
)	O
;	O
return	O
1	int
;	O
}	O
rule	pointer
->	O
gid	int
=	O
grp	pointer
->	O
gr_gid	int
;	O
return	O
0	int
;	O
}	O
struct	O
rule_attrib	struct
{	O
char	O
const	O
*	O
name	pointer
;	O
rule_attrib_setter_t	pointer
setter	pointer
;	O
}	O
;	O
static	O
struct	O
rule_attrib	struct
attrib	array
[	O
]	O
=	O
{	O
{	O
"umask"	pointer
,	O
attrib_umask	function
}	O
,	O
{	O
"chroot"	pointer
,	O
attrib_chroot	function
}	O
,	O
{	O
"chdir"	pointer
,	O
attrib_chdir	function
}	O
,	O
{	O
"fork"	pointer
,	O
attrib_fork	function
}	O
,	O
{	O
"acct"	pointer
,	O
attrib_acct	function
}	O
,	O
{	O
"post-socket"	pointer
,	O
attrib_post_socket	function
}	O
,	O
{	O
"text-domain"	pointer
,	O
attrib_text_domain	function
}	O
,	O
{	O
"locale-dir"	pointer
,	O
attrib_locale_dir	function
}	O
,	O
{	O
"locale"	pointer
,	O
attrib_locale	function
}	O
,	O
{	O
"interactive"	pointer
,	O
attrib_interactive	function
}	O
,	O
{	O
"newgroup"	pointer
,	O
attrib_newgroup	function
}	O
,	O
{	O
"newgrp"	pointer
,	O
attrib_newgroup	function
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
rule_attrib_setter_t	pointer
rule_attrib_lookup	function
(	O
char	O
const	O
*	O
name	pointer
)	O
{	O
struct	O
rule_attrib	struct
*	O
ap	array
;	O
for	O
(	O
ap	array
=	O
attrib	array
;	O
ap	array
->	O
name	pointer
;	O
ap	array
++	O
)	O
if	O
(	O
strcmp	function
(	O
ap	array
->	O
name	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
return	O
ap	array
->	O
setter	pointer
;	O
return	O
NULL	O
;	O
}	O
static	O
int	O
glattrib_debug	function
(	O
int	O
argc	int
,	O
struct	O
argval	struct
*	O
arghead	pointer
)	O
{	O
if	O
(	O
debug_level	int
==	O
0	int
)	O
debug_level	int
=	O
arghead	pointer
->	O
intval	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
glattrib_sleep_time	function
(	O
int	O
argc	int
,	O
struct	O
argval	struct
*	O
arghead	pointer
)	O
{	O
sleep_time	int
=	O
arghead	pointer
->	O
intval	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
glattrib_message	function
(	O
int	O
argc	int
,	O
struct	O
argval	struct
*	O
arghead	pointer
)	O
{	O
int	O
n	long
=	O
string_to_error_index	function
(	O
arghead	pointer
->	O
strval	pointer
)	O
;	O
if	O
(	O
n	long
==	O
-	O
1	int
)	O
{	O
cferror	function
(	O
&	O
arghead	pointer
->	O
loc	pointer
,	O
_	O
(	O
"Unknown message reference"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
set_error_msg	function
(	O
n	long
,	O
arghead	pointer
->	O
next	pointer
->	O
strval	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
glattrib_regexp	function
(	O
int	O
argc	int
,	O
struct	O
argval	struct
*	O
arg	struct
)	O
{	O
for	O
(	O
;	O
arg	struct
;	O
arg	struct
=	O
arg	struct
->	O
next	pointer
)	O
{	O
int	O
enable	int
,	O
flag	pointer
;	O
char	O
*	O
p	pointer
=	O
arg	struct
->	O
strval	pointer
;	O
switch	O
(	O
*	O
p	pointer
)	O
{	O
case	O
'+'	O
:	O
p	pointer
++	O
;	O
enable	int
=	O
1	int
;	O
break	O
;	O
case	O
'-'	O
:	O
p	pointer
++	O
;	O
enable	int
=	O
0	int
;	O
break	O
;	O
default	O
:	O
enable	int
=	O
1	int
;	O
}	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"extended"	pointer
)	O
==	O
0	int
)	O
flag	pointer
=	O
REG_EXTENDED	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"basic"	pointer
)	O
==	O
0	int
)	O
{	O
flag	pointer
=	O
REG_EXTENDED	int
;	O
enable	int
=	O
!	O
enable	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"icase"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
p	pointer
,	O
"ignore-case"	pointer
)	O
==	O
0	int
)	O
flag	pointer
=	O
REG_ICASE	O
;	O
else	O
{	O
cferror	function
(	O
&	O
arg	struct
->	O
loc	pointer
,	O
_	O
(	O
"unknown regexp flag: %s"	pointer
)	O
,	O
p	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
enable	int
)	O
re_flags	int
|=	O
flag	pointer
;	O
else	O
re_flags	int
&=	O
~	O
flag	pointer
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
glattrib_include_security	function
(	O
int	O
argc	int
,	O
struct	O
argval	struct
*	O
arg	struct
)	O
{	O
int	O
rc	long
=	O
0	int
;	O
for	O
(	O
;	O
arg	struct
;	O
arg	struct
=	O
arg	struct
->	O
next	pointer
)	O
{	O
if	O
(	O
cfck_keyword	function
(	O
arg	struct
->	O
strval	pointer
)	O
)	O
{	O
cferror	function
(	O
&	O
arg	struct
->	O
loc	pointer
,	O
_	O
(	O
"unknown keyword: %s"	pointer
)	O
,	O
arg	struct
->	O
strval	pointer
)	O
;	O
rc	long
=	O
1	int
;	O
}	O
}	O
return	O
rc	long
;	O
}	O
static	O
int	O
glattrib_acct_file_mode	function
(	O
int	O
argc	int
,	O
struct	O
argval	struct
*	O
arg	struct
)	O
{	O
return	O
parse_file_mode	function
(	O
arg	struct
->	O
strval	pointer
,	O
&	O
rushdb_file_mode	int
,	O
&	O
arg	struct
->	O
loc	pointer
)	O
;	O
}	O
static	O
int	O
glattrib_acct_dir_mode	function
(	O
int	O
argc	int
,	O
struct	O
argval	struct
*	O
arg	struct
)	O
{	O
return	O
parse_file_mode	function
(	O
arg	struct
->	O
strval	pointer
,	O
&	O
rushdb_dir_mode	int
,	O
&	O
arg	struct
->	O
loc	pointer
)	O
;	O
}	O
static	O
int	O
glattrib_acct_umask	function
(	O
int	O
argc	int
,	O
struct	O
argval	struct
*	O
arg	struct
)	O
{	O
return	O
parse_file_mode	function
(	O
arg	struct
->	O
strval	pointer
,	O
&	O
rushdb_umask	int
,	O
&	O
arg	struct
->	O
loc	pointer
)	O
;	O
}	O
static	O
int	O
glattrib_expand_undef	function
(	O
int	O
argc	int
,	O
struct	O
argval	struct
*	O
arg	struct
)	O
{	O
expand_undefined	int
=	O
arg	struct
->	O
intval	int
;	O
return	O
0	int
;	O
}	O
static	O
struct	O
global_attrib	struct
global_attrib	struct
[	O
]	O
=	O
{	O
{	O
"debug"	pointer
,	O
"n"	pointer
,	O
glattrib_debug	function
}	O
,	O
{	O
"sleep-time"	pointer
,	O
"n"	pointer
,	O
glattrib_sleep_time	function
}	O
,	O
{	O
"message"	pointer
,	O
"ss"	pointer
,	O
glattrib_message	function
}	O
,	O
{	O
"regexp"	pointer
,	O
"s."	pointer
,	O
glattrib_regexp	function
}	O
,	O
{	O
"include-security"	pointer
,	O
"s."	pointer
,	O
glattrib_include_security	function
}	O
,	O
{	O
"acct-file-mode"	pointer
,	O
"s"	pointer
,	O
glattrib_acct_file_mode	function
}	O
,	O
{	O
"acct-dir-mode"	pointer
,	O
"s"	pointer
,	O
glattrib_acct_dir_mode	function
}	O
,	O
{	O
"acct-umask"	pointer
,	O
"s"	pointer
,	O
glattrib_acct_umask	function
}	O
,	O
{	O
"expand-undefined"	pointer
,	O
"b"	pointer
,	O
glattrib_expand_undef	function
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
struct	O
global_attrib	struct
*	O
global_attrib_lookup	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
global_attrib	struct
*	O
ap	array
;	O
for	O
(	O
ap	array
=	O
global_attrib	struct
;	O
ap	array
->	O
name	pointer
;	O
ap	array
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
ap	array
->	O
name	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
return	O
ap	array
;	O
}	O
return	O
NULL	O
;	O
}	O
void	O
global_attrib_set	function
(	O
struct	O
global_attrib	struct
*	O
glatt	pointer
,	O
int	O
argc	int
,	O
struct	O
argval	struct
*	O
arghead	pointer
,	O
struct	O
cfloc	struct
const	O
*	O
loc	pointer
)	O
{	O
struct	O
argval	struct
*	O
arg	struct
;	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
0	int
,	O
arg	struct
=	O
arghead	pointer
;	O
arg	struct
;	O
arg	struct
=	O
arg	struct
->	O
next	pointer
)	O
{	O
switch	O
(	O
glatt	pointer
->	O
argt	pointer
[	O
i	long
]	O
)	O
{	O
case	O
'n'	O
:	O
if	O
(	O
!	O
arg	struct
->	O
isnum	int
)	O
{	O
cferror	function
(	O
&	O
arg	struct
->	O
loc	pointer
,	O
"%s"	pointer
,	O
_	O
(	O
"expected numeric argument"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
i	long
++	O
;	O
break	O
;	O
case	O
's'	O
:	O
i	long
++	O
;	O
break	O
;	O
case	O
'b'	O
:	O
if	O
(	O
get_bool	function
(	O
arg	struct
->	O
strval	pointer
,	O
&	O
arg	struct
->	O
intval	int
)	O
)	O
{	O
cferror	function
(	O
loc	pointer
,	O
_	O
(	O
"expected boolean value, but found `%s'"	pointer
)	O
,	O
arg	struct
->	O
strval	pointer
)	O
;	O
return	O
;	O
}	O
i	long
++	O
;	O
break	O
;	O
case	O
'.'	O
:	O
break	O
;	O
case	O
0	int
:	O
cferror	function
(	O
&	O
arg	struct
->	O
loc	pointer
,	O
"%s"	pointer
,	O
_	O
(	O
"too many arguments"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
}	O
if	O
(	O
glatt	pointer
->	O
argt	pointer
[	O
i	long
]	O
&&	O
glatt	pointer
->	O
argt	pointer
[	O
i	long
]	O
!=	O
'.'	O
)	O
{	O
cferror	function
(	O
loc	pointer
,	O
"%s"	pointer
,	O
_	O
(	O
"not enough many arguments"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
glatt	pointer
->	O
setter	pointer
(	O
argc	int
,	O
arghead	pointer
)	O
;	O
}	O
void	O
arglist_free	function
(	O
struct	O
argval	struct
*	O
arg	struct
)	O
{	O
while	O
(	O
arg	struct
)	O
{	O
struct	O
argval	struct
*	O
next	pointer
=	O
arg	struct
->	O
next	pointer
;	O
free	function
(	O
arg	struct
->	O
strval	pointer
)	O
;	O
free	function
(	O
arg	struct
)	O
;	O
arg	struct
=	O
next	pointer
;	O
}	O
}	O
