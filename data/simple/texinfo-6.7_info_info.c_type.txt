char	O
*	O
program_name	pointer
=	O
"info"	pointer
;	O
static	O
int	O
apropos_p	int
=	O
0	int
;	O
static	O
char	O
*	O
apropos_search_string	pointer
=	O
NULL	O
;	O
static	O
int	O
index_search_p	int
=	O
0	int
;	O
static	O
int	O
goto_invocation_p	int
=	O
0	int
;	O
static	O
char	O
*	O
invocation_program_name	pointer
=	O
0	int
;	O
static	O
char	O
*	O
index_search_string	pointer
=	O
NULL	O
;	O
static	O
int	O
print_version_p	int
=	O
0	int
;	O
static	O
int	O
print_help_p	int
=	O
0	int
;	O
static	O
char	O
*	O
initial_file	pointer
=	O
0	int
;	O
static	O
char	O
*	O
*	O
user_nodenames	pointer
=	O
NULL	O
;	O
static	O
size_t	long
user_nodenames_index	long
=	O
0	int
;	O
static	O
size_t	long
user_nodenames_slots	long
=	O
0	int
;	O
static	O
REFERENCE	struct
*	O
*	O
ref_list	pointer
=	O
NULL	O
;	O
static	O
size_t	long
ref_slots	long
=	O
0	int
;	O
static	O
size_t	long
ref_index	long
=	O
0	int
;	O
static	O
char	O
*	O
user_filename	pointer
=	O
NULL	O
;	O
static	O
char	O
*	O
user_output_filename	pointer
=	O
NULL	O
;	O
int	O
dump_subnodes	int
=	O
0	int
;	O
int	O
vi_keys_p	int
=	O
0	int
;	O
int	O
raw_escapes_p	int
=	O
1	int
;	O
static	O
int	O
all_matches_p	int
=	O
0	int
;	O
static	O
int	O
print_where_p	int
=	O
0	int
;	O
int	O
strict_node_location_p	int
=	O
0	int
;	O
static	O
struct	O
option	struct
long_options	array
[	O
]	O
=	O
{	O
{	O
"all"	pointer
,	O
0	int
,	O
0	int
,	O
'a'	O
}	O
,	O
{	O
"apropos"	pointer
,	O
1	int
,	O
0	int
,	O
'k'	O
}	O
,	O
{	O
"debug"	pointer
,	O
1	int
,	O
0	int
,	O
'x'	O
}	O
,	O
{	O
"directory"	pointer
,	O
1	int
,	O
0	int
,	O
'd'	O
}	O
,	O
{	O
"dribble"	pointer
,	O
1	int
,	O
0	int
,	O
DRIBBLE_OPTION	int
}	O
,	O
{	O
"file"	pointer
,	O
1	int
,	O
0	int
,	O
'f'	O
}	O
,	O
{	O
"help"	pointer
,	O
0	int
,	O
&	O
print_help_p	int
,	O
1	int
}	O
,	O
{	O
"index-search"	pointer
,	O
1	int
,	O
0	int
,	O
IDXSRCH_OPTION	int
}	O
,	O
{	O
"init-file"	pointer
,	O
1	int
,	O
0	int
,	O
INITFLE_OPTION	int
}	O
,	O
{	O
"location"	pointer
,	O
0	int
,	O
&	O
print_where_p	int
,	O
1	int
}	O
,	O
{	O
"node"	pointer
,	O
1	int
,	O
0	int
,	O
'n'	O
}	O
,	O
{	O
"output"	pointer
,	O
1	int
,	O
0	int
,	O
'o'	O
}	O
,	O
{	O
"raw-escapes"	pointer
,	O
0	int
,	O
&	O
raw_escapes_p	int
,	O
1	int
}	O
,	O
{	O
"no-raw-escapes"	pointer
,	O
0	int
,	O
&	O
raw_escapes_p	int
,	O
0	int
}	O
,	O
{	O
"show-malformed-multibytes"	pointer
,	O
0	int
,	O
&	O
show_malformed_multibyte_p	int
,	O
1	int
}	O
,	O
{	O
"no-show-malformed-multibytes"	pointer
,	O
0	int
,	O
&	O
show_malformed_multibyte_p	int
,	O
0	int
}	O
,	O
{	O
"restore"	pointer
,	O
1	int
,	O
0	int
,	O
RESTORE_OPTION	int
}	O
,	O
{	O
"show-options"	pointer
,	O
0	int
,	O
0	int
,	O
'O'	O
}	O
,	O
{	O
"strict-node-location"	pointer
,	O
0	int
,	O
&	O
strict_node_location_p	int
,	O
1	int
}	O
,	O
{	O
"subnodes"	pointer
,	O
0	int
,	O
&	O
dump_subnodes	int
,	O
1	int
}	O
,	O
{	O
"usage"	pointer
,	O
0	int
,	O
0	int
,	O
'O'	O
}	O
,	O
{	O
"variable"	pointer
,	O
1	int
,	O
0	int
,	O
'v'	O
}	O
,	O
{	O
"version"	pointer
,	O
0	int
,	O
&	O
print_version_p	int
,	O
1	int
}	O
,	O
{	O
"vi-keys"	pointer
,	O
0	int
,	O
&	O
vi_keys_p	int
,	O
1	int
}	O
,	O
{	O
"where"	pointer
,	O
0	int
,	O
&	O
print_where_p	int
,	O
1	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
char	O
*	O
short_options	pointer
=	O
"ak:d:n:f:ho:ORv:wsx:"	pointer
;	O
int	O
info_windows_initialized_p	int
=	O
0	int
;	O
static	O
void	O
info_short_help	function
(	O
void	O
)	O
;	O
static	O
void	O
init_messages	function
(	O
void	O
)	O
;	O
static	O
void	O
get_initial_file	function
(	O
int	O
*	O
argc	pointer
,	O
char	O
*	O
*	O
*	O
argv	pointer
,	O
char	O
*	O
*	O
error	pointer
)	O
{	O
REFERENCE	struct
*	O
entry	pointer
;	O
if	O
(	O
user_filename	pointer
)	O
{	O
if	O
(	O
!	O
IS_ABSOLUTE	O
(	O
user_filename	pointer
)	O
&&	O
HAS_SLASH	O
(	O
user_filename	pointer
)	O
&&	O
!	O
(	O
user_filename	pointer
[	O
0	int
]	O
==	O
'.'	O
&&	O
IS_SLASH	O
(	O
user_filename	pointer
[	O
1	int
]	O
)	O
)	O
)	O
{	O
char	O
*	O
s	pointer
;	O
asprintf	function
(	O
&	O
s	pointer
,	O
"%s%s"	pointer
,	O
"./"	pointer
,	O
user_filename	pointer
)	O
;	O
free	function
(	O
user_filename	pointer
)	O
;	O
user_filename	pointer
=	O
s	pointer
;	O
}	O
if	O
(	O
IS_ABSOLUTE	O
(	O
user_filename	pointer
)	O
||	O
HAS_SLASH	O
(	O
user_filename	pointer
)	O
)	O
initial_file	pointer
=	O
info_add_extension	function
(	O
0	int
,	O
user_filename	pointer
,	O
0	int
)	O
;	O
else	O
initial_file	pointer
=	O
info_find_fullpath	function
(	O
user_filename	pointer
,	O
0	int
)	O
;	O
if	O
(	O
!	O
initial_file	pointer
)	O
{	O
if	O
(	O
!	O
filesys_error_number	int
)	O
filesys_error_number	int
=	O
ENOENT	int
;	O
*	O
error	pointer
=	O
filesys_error_string	function
(	O
user_filename	pointer
,	O
filesys_error_number	int
)	O
;	O
}	O
return	O
;	O
}	O
if	O
(	O
!	O
(	O
*	O
argv	pointer
)	O
[	O
0	int
]	O
)	O
{	O
initial_file	pointer
=	O
xstrdup	function
(	O
"dir"	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
(	O
*	O
argv	pointer
)	O
[	O
0	int
]	O
[	O
0	int
]	O
==	O
'('	O
)	O
{	O
info_parse_node	function
(	O
(	O
*	O
argv	pointer
)	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
info_parsed_filename	pointer
)	O
{	O
initial_file	pointer
=	O
info_find_fullpath	function
(	O
info_parsed_filename	pointer
,	O
0	int
)	O
;	O
if	O
(	O
initial_file	pointer
)	O
{	O
add_pointer_to_array	O
(	O
info_new_reference	function
(	O
initial_file	pointer
,	O
info_parsed_nodename	pointer
)	O
,	O
ref_index	long
,	O
ref_list	pointer
,	O
ref_slots	long
,	O
2	int
)	O
;	O
memmove	function
(	O
*	O
argv	pointer
,	O
*	O
argv	pointer
+	O
1	int
,	O
*	O
argc	pointer
--	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
return	O
;	O
}	O
}	O
}	O
{	O
if	O
(	O
(	O
*	O
argv	pointer
)	O
[	O
0	int
]	O
&&	O
mbscasecmp	function
(	O
(	O
*	O
argv	pointer
)	O
[	O
0	int
]	O
,	O
"info"	pointer
)	O
==	O
0	int
)	O
(	O
*	O
argv	pointer
)	O
[	O
0	int
]	O
=	O
"info-stnd"	pointer
;	O
entry	pointer
=	O
lookup_dir_entry	function
(	O
(	O
*	O
argv	pointer
)	O
[	O
0	int
]	O
,	O
0	int
)	O
;	O
if	O
(	O
entry	pointer
)	O
{	O
initial_file	pointer
=	O
info_find_fullpath	function
(	O
entry	pointer
->	O
filename	pointer
,	O
0	int
)	O
;	O
if	O
(	O
initial_file	pointer
)	O
{	O
REFERENCE	struct
*	O
copy	pointer
;	O
(	O
*	O
argv	pointer
)	O
++	O
;	O
(	O
*	O
argc	pointer
)	O
--	O
;	O
copy	pointer
=	O
info_copy_reference	function
(	O
entry	pointer
)	O
;	O
free	function
(	O
copy	pointer
->	O
filename	pointer
)	O
;	O
copy	pointer
->	O
filename	pointer
=	O
xstrdup	function
(	O
initial_file	pointer
)	O
;	O
add_pointer_to_array	O
(	O
copy	pointer
,	O
ref_index	long
,	O
ref_list	pointer
,	O
ref_slots	long
,	O
2	int
)	O
;	O
return	O
;	O
}	O
}	O
}	O
{	O
initial_file	pointer
=	O
info_find_fullpath	function
(	O
(	O
*	O
argv	pointer
)	O
[	O
0	int
]	O
,	O
0	int
)	O
;	O
if	O
(	O
initial_file	pointer
)	O
{	O
add_pointer_to_array	O
(	O
info_new_reference	function
(	O
(	O
*	O
argv	pointer
)	O
[	O
0	int
]	O
,	O
"Top"	pointer
)	O
,	O
ref_index	long
,	O
ref_list	pointer
,	O
ref_slots	long
,	O
2	int
)	O
;	O
(	O
*	O
argv	pointer
)	O
++	O
;	O
(	O
*	O
argc	pointer
)	O
--	O
;	O
return	O
;	O
}	O
else	O
asprintf	function
(	O
error	pointer
,	O
_	O
(	O
"No menu item '%s' in node '%s'"	pointer
)	O
,	O
(	O
*	O
argv	pointer
)	O
[	O
0	int
]	O
,	O
"(dir)Top"	pointer
)	O
;	O
}	O
{	O
NODE	struct
*	O
man_node	pointer
;	O
debug	O
(	O
3	int
,	O
(	O
"falling back to manpage node"	pointer
)	O
)	O
;	O
man_node	pointer
=	O
get_manpage_node	function
(	O
(	O
*	O
argv	pointer
)	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
man_node	pointer
)	O
{	O
add_pointer_to_array	O
(	O
info_new_reference	function
(	O
MANPAGE_FILE_BUFFER_NAME	pointer
,	O
(	O
*	O
argv	pointer
)	O
[	O
0	int
]	O
)	O
,	O
ref_index	long
,	O
ref_list	pointer
,	O
ref_slots	long
,	O
2	int
)	O
;	O
initial_file	pointer
=	O
MANPAGE_FILE_BUFFER_NAME	pointer
;	O
free	function
(	O
man_node	pointer
)	O
;	O
return	O
;	O
}	O
}	O
{	O
entry	pointer
=	O
lookup_dir_entry	function
(	O
(	O
*	O
argv	pointer
)	O
[	O
0	int
]	O
,	O
1	int
)	O
;	O
if	O
(	O
entry	pointer
)	O
{	O
initial_file	pointer
=	O
info_find_fullpath	function
(	O
entry	pointer
->	O
filename	pointer
,	O
0	int
)	O
;	O
if	O
(	O
initial_file	pointer
)	O
{	O
REFERENCE	struct
*	O
copy	pointer
;	O
(	O
*	O
argv	pointer
)	O
++	O
;	O
(	O
*	O
argc	pointer
)	O
--	O
;	O
free	function
(	O
*	O
error	pointer
)	O
;	O
*	O
error	pointer
=	O
0	int
;	O
copy	pointer
=	O
info_copy_reference	function
(	O
entry	pointer
)	O
;	O
free	function
(	O
copy	pointer
->	O
filename	pointer
)	O
;	O
copy	pointer
->	O
filename	pointer
=	O
initial_file	pointer
;	O
add_pointer_to_array	O
(	O
copy	pointer
,	O
ref_index	long
,	O
ref_list	pointer
,	O
ref_slots	long
,	O
2	int
)	O
;	O
return	O
;	O
}	O
}	O
}	O
return	O
;	O
}	O
static	O
void	O
add_initial_nodes	function
(	O
int	O
argc	pointer
,	O
char	O
*	O
*	O
argv	pointer
,	O
char	O
*	O
*	O
error	pointer
)	O
{	O
if	O
(	O
user_nodenames	pointer
)	O
{	O
int	O
i	int
;	O
if	O
(	O
user_nodenames_index	long
>	O
0	int
&&	O
ref_index	long
>	O
0	int
)	O
{	O
info_reference_free	function
(	O
ref_list	pointer
[	O
0	int
]	O
)	O
;	O
ref_list	pointer
[	O
0	int
]	O
=	O
0	int
;	O
ref_index	long
=	O
0	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
user_nodenames	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
char	O
*	O
node_filename	pointer
=	O
0	int
;	O
char	O
*	O
node_nodename	pointer
=	O
0	int
;	O
info_parse_node	function
(	O
user_nodenames	pointer
[	O
i	int
]	O
)	O
;	O
if	O
(	O
info_parsed_filename	pointer
)	O
{	O
node_filename	pointer
=	O
info_parsed_filename	pointer
;	O
node_nodename	pointer
=	O
info_parsed_nodename	pointer
;	O
}	O
else	O
{	O
FILE_BUFFER	struct
*	O
file_buffer	pointer
;	O
TAG	struct
*	O
tag	pointer
;	O
int	O
j	int
;	O
if	O
(	O
!	O
initial_file	pointer
)	O
continue	O
;	O
node_filename	pointer
=	O
initial_file	pointer
;	O
node_nodename	pointer
=	O
0	int
;	O
file_buffer	pointer
=	O
info_find_file	function
(	O
node_filename	pointer
)	O
;	O
if	O
(	O
!	O
file_buffer	pointer
)	O
continue	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
(	O
tag	pointer
=	O
file_buffer	pointer
->	O
tags	pointer
[	O
j	int
]	O
)	O
;	O
j	int
++	O
)	O
if	O
(	O
strcmp	function
(	O
user_nodenames	pointer
[	O
i	int
]	O
,	O
tag	pointer
->	O
nodename	pointer
)	O
==	O
0	int
)	O
{	O
node_nodename	pointer
=	O
tag	pointer
->	O
nodename	pointer
;	O
break	O
;	O
}	O
if	O
(	O
!	O
node_nodename	pointer
)	O
{	O
int	O
best_guess	int
=	O
-	O
1	int
;	O
int	O
len	long
=	O
strlen	function
(	O
user_nodenames	pointer
[	O
i	int
]	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
(	O
tag	pointer
=	O
file_buffer	pointer
->	O
tags	pointer
[	O
j	int
]	O
)	O
;	O
j	int
++	O
)	O
{	O
if	O
(	O
mbscasecmp	function
(	O
user_nodenames	pointer
[	O
i	int
]	O
,	O
tag	pointer
->	O
nodename	pointer
)	O
==	O
0	int
)	O
{	O
node_nodename	pointer
=	O
tag	pointer
->	O
nodename	pointer
;	O
best_guess	int
=	O
-	O
1	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
best_guess	int
==	O
-	O
1	int
&&	O
(	O
mbsncasecmp	function
(	O
user_nodenames	pointer
[	O
i	int
]	O
,	O
tag	pointer
->	O
nodename	pointer
,	O
len	long
)	O
==	O
0	int
)	O
)	O
best_guess	int
=	O
j	int
;	O
}	O
if	O
(	O
best_guess	int
!=	O
-	O
1	int
)	O
{	O
node_nodename	pointer
=	O
file_buffer	pointer
->	O
tags	pointer
[	O
best_guess	int
]	O
->	O
nodename	pointer
;	O
}	O
}	O
if	O
(	O
!	O
node_nodename	pointer
)	O
{	O
free	function
(	O
*	O
error	pointer
)	O
;	O
asprintf	function
(	O
error	pointer
,	O
_	O
(	O
"Cannot find node '%s'"	pointer
)	O
,	O
user_nodenames	pointer
[	O
i	int
]	O
)	O
;	O
continue	O
;	O
}	O
}	O
if	O
(	O
node_filename	pointer
&&	O
node_nodename	pointer
)	O
add_pointer_to_array	O
(	O
info_new_reference	function
(	O
node_filename	pointer
,	O
node_nodename	pointer
)	O
,	O
ref_index	long
,	O
ref_list	pointer
,	O
ref_slots	long
,	O
2	int
)	O
;	O
}	O
}	O
if	O
(	O
goto_invocation_p	int
)	O
{	O
NODE	struct
*	O
top_node	pointer
=	O
0	int
;	O
REFERENCE	struct
*	O
invoc_ref	pointer
=	O
0	int
;	O
char	O
*	O
program	pointer
;	O
if	O
(	O
ref_index	long
==	O
0	int
)	O
{	O
info_error	function
(	O
_	O
(	O
"No program name given"	pointer
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
invocation_program_name	pointer
)	O
program	pointer
=	O
xstrdup	function
(	O
invocation_program_name	pointer
)	O
;	O
else	O
if	O
(	O
ref_list	pointer
[	O
0	int
]	O
&&	O
ref_list	pointer
[	O
0	int
]	O
->	O
filename	pointer
)	O
program	pointer
=	O
program_name_from_file_name	function
(	O
ref_list	pointer
[	O
0	int
]	O
->	O
filename	pointer
)	O
;	O
else	O
program	pointer
=	O
xstrdup	function
(	O
""	pointer
)	O
;	O
if	O
(	O
ref_index	long
>	O
0	int
)	O
top_node	pointer
=	O
info_get_node	function
(	O
ref_list	pointer
[	O
0	int
]	O
->	O
filename	pointer
,	O
ref_list	pointer
[	O
0	int
]	O
->	O
nodename	pointer
)	O
;	O
if	O
(	O
top_node	pointer
)	O
invoc_ref	pointer
=	O
info_intuit_options_node	function
(	O
top_node	pointer
,	O
program	pointer
)	O
;	O
if	O
(	O
invoc_ref	pointer
)	O
{	O
info_reference_free	function
(	O
ref_list	pointer
[	O
0	int
]	O
)	O
;	O
ref_index	long
=	O
0	int
;	O
add_pointer_to_array	O
(	O
invoc_ref	pointer
,	O
ref_index	long
,	O
ref_list	pointer
,	O
ref_slots	long
,	O
2	int
)	O
;	O
}	O
free	function
(	O
program	pointer
)	O
;	O
}	O
if	O
(	O
ref_index	long
==	O
0	int
&&	O
initial_file	pointer
)	O
{	O
add_pointer_to_array	O
(	O
info_new_reference	function
(	O
initial_file	pointer
,	O
"Top"	pointer
)	O
,	O
ref_index	long
,	O
ref_list	pointer
,	O
ref_slots	long
,	O
2	int
)	O
;	O
}	O
if	O
(	O
*	O
argv	pointer
&&	O
ref_index	long
>	O
0	int
)	O
{	O
NODE	struct
*	O
initial_node	pointer
;	O
NODE	struct
*	O
node_via_menus	pointer
;	O
initial_node	pointer
=	O
info_get_node_with_defaults	function
(	O
ref_list	pointer
[	O
0	int
]	O
->	O
filename	pointer
,	O
ref_list	pointer
[	O
0	int
]	O
->	O
nodename	pointer
,	O
0	int
)	O
;	O
if	O
(	O
!	O
initial_node	pointer
)	O
return	O
;	O
node_via_menus	pointer
=	O
info_follow_menus	function
(	O
initial_node	pointer
,	O
argv	pointer
,	O
error	pointer
,	O
1	int
)	O
;	O
if	O
(	O
node_via_menus	pointer
)	O
{	O
argv	pointer
+=	O
argc	pointer
;	O
argc	pointer
=	O
0	int
;	O
info_reference_free	function
(	O
ref_list	pointer
[	O
0	int
]	O
)	O
;	O
ref_list	pointer
[	O
0	int
]	O
=	O
info_new_reference	function
(	O
node_via_menus	pointer
->	O
fullpath	pointer
,	O
node_via_menus	pointer
->	O
nodename	pointer
)	O
;	O
free_history_node	function
(	O
node_via_menus	pointer
)	O
;	O
}	O
else	O
if	O
(	O
argc	pointer
==	O
1	int
&&	O
argv	pointer
[	O
0	int
]	O
)	O
{	O
FILE_BUFFER	struct
*	O
fb	pointer
;	O
REFERENCE	struct
*	O
match	pointer
;	O
debug	O
(	O
3	int
,	O
(	O
"looking in indices"	pointer
)	O
)	O
;	O
fb	pointer
=	O
info_find_file	function
(	O
ref_list	pointer
[	O
0	int
]	O
->	O
filename	pointer
)	O
;	O
if	O
(	O
fb	pointer
)	O
{	O
match	pointer
=	O
look_in_indices	function
(	O
fb	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
0	int
)	O
;	O
if	O
(	O
match	pointer
)	O
{	O
argv	pointer
+=	O
argc	pointer
;	O
argc	pointer
=	O
0	int
;	O
free	function
(	O
*	O
error	pointer
)	O
;	O
*	O
error	pointer
=	O
0	int
;	O
info_reference_free	function
(	O
ref_list	pointer
[	O
0	int
]	O
)	O
;	O
ref_list	pointer
[	O
0	int
]	O
=	O
info_copy_reference	function
(	O
match	pointer
)	O
;	O
}	O
}	O
}	O
if	O
(	O
argc	pointer
!=	O
0	int
)	O
{	O
initial_node	pointer
=	O
info_get_node_with_defaults	function
(	O
ref_list	pointer
[	O
0	int
]	O
->	O
filename	pointer
,	O
ref_list	pointer
[	O
0	int
]	O
->	O
nodename	pointer
,	O
0	int
)	O
;	O
free	function
(	O
*	O
error	pointer
)	O
;	O
*	O
error	pointer
=	O
0	int
;	O
node_via_menus	pointer
=	O
info_follow_menus	function
(	O
initial_node	pointer
,	O
argv	pointer
,	O
error	pointer
,	O
0	int
)	O
;	O
if	O
(	O
node_via_menus	pointer
)	O
{	O
if	O
(	O
argc	pointer
>=	O
2	int
||	O
!	O
*	O
error	pointer
)	O
{	O
argv	pointer
+=	O
argc	pointer
;	O
argc	pointer
=	O
0	int
;	O
info_reference_free	function
(	O
ref_list	pointer
[	O
0	int
]	O
)	O
;	O
ref_list	pointer
[	O
0	int
]	O
=	O
info_new_reference	function
(	O
node_via_menus	pointer
->	O
fullpath	pointer
,	O
node_via_menus	pointer
->	O
nodename	pointer
)	O
;	O
}	O
free_history_node	function
(	O
node_via_menus	pointer
)	O
;	O
}	O
}	O
if	O
(	O
argc	pointer
==	O
1	int
)	O
{	O
FILE_BUFFER	struct
*	O
fb	pointer
;	O
REFERENCE	struct
*	O
nearest	pointer
;	O
debug	O
(	O
3	int
,	O
(	O
"looking in indices sloppily"	pointer
)	O
)	O
;	O
fb	pointer
=	O
info_find_file	function
(	O
ref_list	pointer
[	O
0	int
]	O
->	O
filename	pointer
)	O
;	O
if	O
(	O
fb	pointer
)	O
{	O
nearest	pointer
=	O
look_in_indices	function
(	O
fb	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
1	int
)	O
;	O
if	O
(	O
nearest	pointer
)	O
{	O
argv	pointer
+=	O
argc	pointer
;	O
argc	pointer
=	O
0	int
;	O
free	function
(	O
*	O
error	pointer
)	O
;	O
*	O
error	pointer
=	O
0	int
;	O
info_reference_free	function
(	O
ref_list	pointer
[	O
0	int
]	O
)	O
;	O
ref_list	pointer
[	O
0	int
]	O
=	O
info_copy_reference	function
(	O
nearest	pointer
)	O
;	O
}	O
}	O
}	O
}	O
return	O
;	O
}	O
static	O
void	O
info_find_matching_files	function
(	O
char	O
*	O
filename	pointer
)	O
{	O
int	O
i	int
;	O
char	O
*	O
searchdir	pointer
;	O
NODE	struct
*	O
man_node	pointer
;	O
i	int
=	O
0	int
;	O
for	O
(	O
searchdir	pointer
=	O
infopath_first	function
(	O
&	O
i	int
)	O
;	O
searchdir	pointer
;	O
searchdir	pointer
=	O
infopath_next	function
(	O
&	O
i	int
)	O
)	O
{	O
REFERENCE	struct
*	O
new_ref	pointer
=	O
dir_entry_of_infodir	function
(	O
filename	pointer
,	O
searchdir	pointer
)	O
;	O
if	O
(	O
new_ref	pointer
)	O
add_pointer_to_array	O
(	O
new_ref	pointer
,	O
ref_index	long
,	O
ref_list	pointer
,	O
ref_slots	long
,	O
2	int
)	O
;	O
}	O
i	int
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
char	O
*	O
p	pointer
;	O
int	O
j	int
;	O
p	pointer
=	O
info_file_find_next_in_path	function
(	O
filename	pointer
,	O
&	O
i	int
,	O
0	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
break	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
ref_index	long
;	O
j	int
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
p	pointer
,	O
ref_list	pointer
[	O
j	int
]	O
->	O
filename	pointer
)	O
)	O
break	O
;	O
}	O
if	O
(	O
j	int
==	O
ref_index	long
)	O
{	O
add_pointer_to_array	O
(	O
info_new_reference	function
(	O
p	pointer
,	O
0	int
)	O
,	O
ref_index	long
,	O
ref_list	pointer
,	O
ref_slots	long
,	O
2	int
)	O
;	O
}	O
free	function
(	O
p	pointer
)	O
;	O
}	O
man_node	pointer
=	O
get_manpage_node	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
man_node	pointer
)	O
{	O
free	function
(	O
man_node	pointer
)	O
;	O
add_pointer_to_array	O
(	O
info_new_reference	function
(	O
MANPAGE_FILE_BUFFER_NAME	pointer
,	O
filename	pointer
)	O
,	O
ref_index	long
,	O
ref_list	pointer
,	O
ref_slots	long
,	O
2	int
)	O
;	O
}	O
}	O
static	O
void	O
set_debug_level	function
(	O
const	O
char	O
*	O
arg	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
long	O
n	long
=	O
strtol	function
(	O
arg	pointer
,	O
&	O
p	pointer
,	O
10	int
)	O
;	O
if	O
(	O
*	O
p	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"invalid number: %s\n"	pointer
)	O
,	O
arg	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
n	long
<	O
0	int
||	O
n	long
>	O
UINT_MAX	O
)	O
debug_level	int
=	O
UINT_MAX	O
;	O
else	O
debug_level	int
=	O
n	long
;	O
}	O
static	O
void	O
add_file_directory_to_path	function
(	O
char	O
*	O
filename	pointer
)	O
{	O
char	O
*	O
directory_name	pointer
=	O
xstrdup	function
(	O
filename	pointer
)	O
;	O
char	O
*	O
temp	pointer
=	O
filename_non_directory	function
(	O
directory_name	pointer
)	O
;	O
if	O
(	O
temp	pointer
!=	O
directory_name	pointer
)	O
{	O
if	O
(	O
HAVE_DRIVE	O
(	O
directory_name	pointer
)	O
&&	O
temp	pointer
==	O
directory_name	pointer
+	O
2	int
)	O
{	O
*	O
temp	pointer
=	O
'.'	O
;	O
temp	pointer
+=	O
2	int
;	O
}	O
temp	pointer
[	O
-	O
1	int
]	O
=	O
0	int
;	O
infopath_add	function
(	O
directory_name	pointer
)	O
;	O
}	O
free	function
(	O
directory_name	pointer
)	O
;	O
}	O
int	O
main	function
(	O
int	O
argc	pointer
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
int	O
getopt_long_index	int
;	O
char	O
*	O
init_file	pointer
=	O
0	int
;	O
char	O
*	O
error	pointer
=	O
0	int
;	O
setlocale	function
(	O
LC_ALL	O
,	O
""	pointer
)	O
;	O
bindtextdomain	function
(	O
PACKAGE	pointer
,	O
LOCALEDIR	O
)	O
;	O
textdomain	function
(	O
PACKAGE	pointer
)	O
;	O
init_messages	function
(	O
)	O
;	O
while	O
(	O
1	int
)	O
{	O
int	O
option_character	int
;	O
option_character	int
=	O
getopt_long	function
(	O
argc	pointer
,	O
argv	pointer
,	O
short_options	pointer
,	O
long_options	array
,	O
&	O
getopt_long_index	int
)	O
;	O
if	O
(	O
option_character	int
==	O
EOF	O
)	O
break	O
;	O
if	O
(	O
option_character	int
==	O
0	int
&&	O
long_options	array
[	O
getopt_long_index	int
]	O
.	O
flag	pointer
==	O
0	int
)	O
option_character	int
=	O
long_options	array
[	O
getopt_long_index	int
]	O
.	O
val	int
;	O
switch	O
(	O
option_character	int
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
'a'	O
:	O
all_matches_p	int
=	O
1	int
;	O
break	O
;	O
case	O
'd'	O
:	O
infopath_add	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'n'	O
:	O
add_pointer_to_array	O
(	O
optarg	pointer
,	O
user_nodenames_index	long
,	O
user_nodenames	pointer
,	O
user_nodenames_slots	long
,	O
10	int
)	O
;	O
break	O
;	O
case	O
'f'	O
:	O
if	O
(	O
user_filename	pointer
)	O
free	function
(	O
user_filename	pointer
)	O
;	O
user_filename	pointer
=	O
xstrdup	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'h'	O
:	O
print_help_p	int
=	O
1	int
;	O
break	O
;	O
case	O
'o'	O
:	O
if	O
(	O
user_output_filename	pointer
)	O
free	function
(	O
user_output_filename	pointer
)	O
;	O
user_output_filename	pointer
=	O
xstrdup	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'O'	O
:	O
goto_invocation_p	int
=	O
1	int
;	O
break	O
;	O
case	O
'R'	O
:	O
raw_escapes_p	int
=	O
1	int
;	O
break	O
;	O
case	O
's'	O
:	O
dump_subnodes	int
=	O
1	int
;	O
break	O
;	O
case	O
'w'	O
:	O
print_where_p	int
=	O
1	int
;	O
break	O
;	O
case	O
'k'	O
:	O
apropos_p	int
=	O
1	int
;	O
free	function
(	O
apropos_search_string	pointer
)	O
;	O
apropos_search_string	pointer
=	O
xstrdup	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
DRIBBLE_OPTION	int
:	O
close_dribble_file	function
(	O
)	O
;	O
open_dribble_file	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
RESTORE_OPTION	int
:	O
info_set_input_from_file	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
IDXSRCH_OPTION	int
:	O
index_search_p	int
=	O
1	int
;	O
free	function
(	O
index_search_string	pointer
)	O
;	O
index_search_string	pointer
=	O
xstrdup	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
INITFLE_OPTION	int
:	O
init_file	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'v'	O
:	O
{	O
VARIABLE_ALIST	struct
*	O
var	pointer
;	O
char	O
*	O
p	pointer
;	O
p	pointer
=	O
strchr	function
(	O
optarg	pointer
,	O
'='	O
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
info_error	function
(	O
_	O
(	O
"malformed variable assignment: %s"	pointer
)	O
,	O
optarg	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
*	O
p	pointer
++	O
=	O
0	int
;	O
if	O
(	O
!	O
(	O
var	pointer
=	O
variable_by_name	function
(	O
optarg	pointer
)	O
)	O
)	O
{	O
info_error	function
(	O
_	O
(	O
"%s: no such variable"	pointer
)	O
,	O
optarg	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
!	O
set_variable_to_value	function
(	O
var	pointer
,	O
p	pointer
,	O
SET_ON_COMMAND_LINE	int
)	O
)	O
{	O
info_error	function
(	O
_	O
(	O
"value %s is not valid for variable %s"	pointer
)	O
,	O
p	pointer
,	O
optarg	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
break	O
;	O
case	O
'x'	O
:	O
set_debug_level	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Try --help for more information.\n"	pointer
)	O
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
if	O
(	O
(	O
!	O
isatty	function
(	O
fileno	function
(	O
stdout	pointer
)	O
)	O
)	O
&&	O
(	O
user_output_filename	pointer
==	O
NULL	O
)	O
)	O
{	O
user_output_filename	pointer
=	O
xstrdup	function
(	O
"-"	pointer
)	O
;	O
dump_subnodes	int
=	O
1	int
;	O
}	O
if	O
(	O
print_version_p	int
)	O
{	O
printf	function
(	O
"info (GNU %s) %s\n"	pointer
,	O
PACKAGE	pointer
,	O
VERSION	pointer
)	O
;	O
puts	function
(	O
""	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Copyright (C) %s Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n"	pointer
)	O
,	O
"2019"	pointer
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
if	O
(	O
print_help_p	int
)	O
{	O
info_short_help	function
(	O
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
argc	pointer
-=	O
optind	int
;	O
argv	pointer
+=	O
optind	int
;	O
if	O
(	O
!	O
user_filename	pointer
&&	O
argv	pointer
[	O
0	int
]	O
&&	O
HAS_SLASH	O
(	O
argv	pointer
[	O
0	int
]	O
)	O
)	O
{	O
user_filename	pointer
=	O
xstrdup	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
argv	pointer
++	O
;	O
argc	pointer
--	O
;	O
}	O
if	O
(	O
user_filename	pointer
)	O
add_file_directory_to_path	function
(	O
user_filename	pointer
)	O
;	O
initialize_terminal_and_keymaps	function
(	O
init_file	pointer
)	O
;	O
infopath_init	function
(	O
)	O
;	O
if	O
(	O
apropos_p	int
)	O
{	O
REFERENCE	struct
*	O
*	O
apropos_list	pointer
;	O
apropos_list	pointer
=	O
apropos_in_all_indices	function
(	O
apropos_search_string	pointer
,	O
0	int
)	O
;	O
if	O
(	O
!	O
apropos_list	pointer
)	O
info_error	function
(	O
_	O
(	O
APROPOS_NONE	O
)	O
,	O
apropos_search_string	pointer
)	O
;	O
else	O
{	O
register	O
int	O
i	int
;	O
REFERENCE	struct
*	O
entry	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
entry	pointer
=	O
apropos_list	pointer
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
fprintf	function
(	O
stdout	pointer
,	O
"\"(%s)%s\" -- %s\n"	pointer
,	O
entry	pointer
->	O
filename	pointer
,	O
entry	pointer
->	O
nodename	pointer
,	O
entry	pointer
->	O
label	pointer
)	O
;	O
}	O
exit	function
(	O
0	int
)	O
;	O
}	O
add_pointer_to_array	O
(	O
0	int
,	O
ref_index	long
,	O
ref_list	pointer
,	O
ref_slots	long
,	O
2	int
)	O
;	O
ref_index	long
--	O
;	O
if	O
(	O
all_matches_p	int
&&	O
!	O
index_search_p	int
)	O
{	O
if	O
(	O
!	O
user_filename	pointer
&&	O
argv	pointer
[	O
0	int
]	O
)	O
{	O
user_filename	pointer
=	O
xstrdup	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
argv	pointer
++	O
;	O
argc	pointer
--	O
;	O
}	O
else	O
if	O
(	O
!	O
user_filename	pointer
)	O
{	O
exit	function
(	O
1	int
)	O
;	O
}	O
info_find_matching_files	function
(	O
user_filename	pointer
)	O
;	O
if	O
(	O
ref_index	long
==	O
1	int
)	O
all_matches_p	int
=	O
0	int
;	O
if	O
(	O
print_where_p	int
)	O
{	O
int	O
i	int
;	O
if	O
(	O
!	O
ref_list	pointer
)	O
exit	function
(	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
ref_list	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
printf	function
(	O
"%s\n"	pointer
,	O
ref_list	pointer
[	O
i	int
]	O
->	O
filename	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
goto_invocation_p	int
)	O
{	O
char	O
*	O
*	O
p	pointer
=	O
argv	pointer
;	O
if	O
(	O
*	O
p	pointer
)	O
{	O
while	O
(	O
p	pointer
[	O
1	int
]	O
)	O
p	pointer
++	O
;	O
invocation_program_name	pointer
=	O
*	O
p	pointer
;	O
}	O
}	O
get_initial_file	function
(	O
&	O
argc	pointer
,	O
&	O
argv	pointer
,	O
&	O
error	pointer
)	O
;	O
if	O
(	O
index_search_p	int
&&	O
all_matches_p	int
&&	O
initial_file	pointer
)	O
{	O
FILE_BUFFER	struct
*	O
initial_fb	pointer
;	O
initial_fb	pointer
=	O
info_find_file	function
(	O
initial_file	pointer
)	O
;	O
if	O
(	O
initial_fb	pointer
)	O
{	O
NODE	struct
*	O
node	pointer
=	O
create_virtual_index	function
(	O
initial_fb	pointer
,	O
index_search_string	pointer
)	O
;	O
if	O
(	O
node	pointer
)	O
{	O
if	O
(	O
user_output_filename	pointer
)	O
{	O
FILE	struct
*	O
output_stream	pointer
=	O
0	int
;	O
if	O
(	O
strcmp	function
(	O
user_output_filename	pointer
,	O
"-"	pointer
)	O
==	O
0	int
)	O
output_stream	pointer
=	O
stdout	pointer
;	O
else	O
output_stream	pointer
=	O
fopen	function
(	O
user_output_filename	pointer
,	O
"w"	pointer
)	O
;	O
if	O
(	O
output_stream	pointer
)	O
{	O
write_node_to_stream	function
(	O
node	pointer
,	O
output_stream	pointer
)	O
;	O
}	O
exit	function
(	O
0	int
)	O
;	O
}	O
else	O
{	O
initialize_info_session	function
(	O
)	O
;	O
info_set_node_of_window	function
(	O
active_window	pointer
,	O
node	pointer
)	O
;	O
info_read_and_dispatch	function
(	O
)	O
;	O
close_info_session	function
(	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
}	O
}	O
}	O
else	O
if	O
(	O
index_search_p	int
&&	O
initial_file	pointer
&&	O
!	O
user_output_filename	pointer
)	O
{	O
FILE_BUFFER	struct
*	O
initial_fb	pointer
;	O
initial_fb	pointer
=	O
info_find_file	function
(	O
initial_file	pointer
)	O
;	O
if	O
(	O
initial_fb	pointer
)	O
{	O
REFERENCE	struct
*	O
result	pointer
;	O
int	O
i	int
,	O
match_offset	pointer
;	O
result	pointer
=	O
next_index_match	function
(	O
initial_fb	pointer
,	O
index_search_string	pointer
,	O
0	int
,	O
1	int
,	O
&	O
i	int
,	O
&	O
match_offset	pointer
)	O
;	O
if	O
(	O
result	pointer
)	O
{	O
initialize_info_session	function
(	O
)	O
;	O
report_index_match	function
(	O
i	int
,	O
match_offset	pointer
)	O
;	O
info_select_reference	function
(	O
active_window	pointer
,	O
result	pointer
)	O
;	O
info_read_and_dispatch	function
(	O
)	O
;	O
close_info_session	function
(	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"no index entries found for '%s'\n"	pointer
)	O
,	O
index_search_string	pointer
)	O
;	O
close_dribble_file	function
(	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
!	O
ref_list	pointer
[	O
0	int
]	O
||	O
strcmp	function
(	O
ref_list	pointer
[	O
0	int
]	O
->	O
filename	pointer
,	O
MANPAGE_FILE_BUFFER_NAME	pointer
)	O
)	O
{	O
add_initial_nodes	function
(	O
argc	pointer
,	O
argv	pointer
,	O
&	O
error	pointer
)	O
;	O
}	O
if	O
(	O
print_where_p	int
)	O
{	O
if	O
(	O
initial_file	pointer
)	O
printf	function
(	O
"%s\n"	pointer
,	O
initial_file	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
}	O
if	O
(	O
user_output_filename	pointer
)	O
{	O
if	O
(	O
error	pointer
)	O
info_error	function
(	O
"%s"	pointer
,	O
error	pointer
)	O
;	O
preprocess_nodes_p	int
=	O
0	int
;	O
dump_nodes_to_file	function
(	O
ref_list	pointer
,	O
user_output_filename	pointer
,	O
dump_subnodes	int
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
if	O
(	O
ref_index	long
==	O
0	int
)	O
{	O
if	O
(	O
error	pointer
)	O
{	O
info_error	function
(	O
"%s"	pointer
,	O
error	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
exit	function
(	O
0	int
)	O
;	O
}	O
info_session	function
(	O
ref_list	pointer
,	O
all_matches_p	int
?	O
user_filename	pointer
:	O
0	int
,	O
error	pointer
)	O
;	O
close_info_session	function
(	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
static	O
void	O
info_short_help	function
(	O
void	O
)	O
{	O
printf	function
(	O
_	O
(	O
"Usage: %s [OPTION]... [MENU-ITEM...]\n\nRead documentation in Info format.\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
puts	function
(	O
""	pointer
)	O
;	O
puts	function
(	O
_	O
(	O
"Frequently-used options:\n  -a, --all                    use all matching manuals\n  -k, --apropos=STRING         look up STRING in all indices of all manuals\n  -d, --directory=DIR          add DIR to INFOPATH\n  -f, --file=MANUAL            specify Info manual to visit"	pointer
)	O
)	O
;	O
puts	function
(	O
_	O
(	O
"  -h, --help                   display this help and exit\n      --index-search=STRING    go to node pointed by index entry STRING\n  -n, --node=NODENAME          specify nodes in first visited Info file\n  -o, --output=FILE            output selected nodes to FILE"	pointer
)	O
)	O
;	O
puts	function
(	O
_	O
(	O
"  -O, --show-options, --usage  go to command-line options node"	pointer
)	O
)	O
;	O
puts	function
(	O
_	O
(	O
"      --subnodes               recursively output menu items\n  -v, --variable VAR=VALUE     assign VALUE to Info variable VAR\n      --version                display version information and exit\n  -w, --where, --location      print physical location of Info file"	pointer
)	O
)	O
;	O
puts	function
(	O
_	O
(	O
"\nThe first non-option argument, if present, is the menu entry to start from;\nit is searched for in all 'dir' files along INFOPATH.\nIf it is not present, info merges all 'dir' files and shows the result.\nAny remaining arguments are treated as the names of menu\nitems relative to the initial node visited."	pointer
)	O
)	O
;	O
puts	function
(	O
_	O
(	O
"\nFor a summary of key bindings, type H within Info."	pointer
)	O
)	O
;	O
puts	function
(	O
_	O
(	O
"\nExamples:\n  info                         show top-level dir menu\n  info info-stnd               show the manual for this Info program\n  info emacs                   start at emacs node from top-level dir\n  info emacs buffers           select buffers menu entry in emacs manual\n  info emacs -n Files          start at Files node within emacs manual\n  info '(emacs)Files'          alternative way to start at Files node\n  info --show-options emacs    start at node with emacs' command line options\n  info --subnodes -o out.txt emacs\n                               dump entire emacs manual to out.txt\n  info -f ./foo.info           show file ./foo.info, not searching dir"	pointer
)	O
)	O
;	O
puts	function
(	O
""	pointer
)	O
;	O
puts	function
(	O
_	O
(	O
"Email bug reports to bug-texinfo@gnu.org,\ngeneral questions and discussion to help-texinfo@gnu.org.\nTexinfo home page: http://www.gnu.org/software/texinfo/"	pointer
)	O
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
const	O
char	O
*	O
msg_cant_find_node	pointer
;	O
const	O
char	O
*	O
msg_cant_file_node	pointer
;	O
const	O
char	O
*	O
msg_cant_find_window	pointer
;	O
const	O
char	O
*	O
msg_cant_find_point	pointer
;	O
const	O
char	O
*	O
msg_cant_kill_last	pointer
;	O
const	O
char	O
*	O
msg_no_menu_node	pointer
;	O
const	O
char	O
*	O
msg_no_foot_node	pointer
;	O
const	O
char	O
*	O
msg_no_xref_node	pointer
;	O
const	O
char	O
*	O
msg_no_pointer	pointer
;	O
const	O
char	O
*	O
msg_unknown_command	pointer
;	O
const	O
char	O
*	O
msg_term_too_dumb	pointer
;	O
const	O
char	O
*	O
msg_at_node_bottom	pointer
;	O
const	O
char	O
*	O
msg_at_node_top	pointer
;	O
const	O
char	O
*	O
msg_one_window	pointer
;	O
const	O
char	O
*	O
msg_win_too_small	pointer
;	O
const	O
char	O
*	O
msg_cant_make_help	pointer
;	O
static	O
void	O
init_messages	function
(	O
void	O
)	O
{	O
msg_cant_find_node	pointer
=	O
_	O
(	O
"Cannot find node '%s'"	pointer
)	O
;	O
msg_cant_file_node	pointer
=	O
_	O
(	O
"Cannot find node '(%s)%s'"	pointer
)	O
;	O
msg_cant_find_window	pointer
=	O
_	O
(	O
"Cannot find a window!"	pointer
)	O
;	O
msg_cant_find_point	pointer
=	O
_	O
(	O
"Point doesn't appear within this window's node!"	pointer
)	O
;	O
msg_cant_kill_last	pointer
=	O
_	O
(	O
"Cannot delete the last window"	pointer
)	O
;	O
msg_no_menu_node	pointer
=	O
_	O
(	O
"No menu in this node"	pointer
)	O
;	O
msg_no_foot_node	pointer
=	O
_	O
(	O
"No footnotes in this node"	pointer
)	O
;	O
msg_no_xref_node	pointer
=	O
_	O
(	O
"No cross references in this node"	pointer
)	O
;	O
msg_no_pointer	pointer
=	O
_	O
(	O
"No '%s' pointer for this node"	pointer
)	O
;	O
msg_unknown_command	pointer
=	O
_	O
(	O
"Unknown Info command '%c'; try '?' for help"	pointer
)	O
;	O
msg_term_too_dumb	pointer
=	O
_	O
(	O
"Terminal type '%s' is not smart enough to run Info"	pointer
)	O
;	O
msg_at_node_bottom	pointer
=	O
_	O
(	O
"You are already at the last page of this node"	pointer
)	O
;	O
msg_at_node_top	pointer
=	O
_	O
(	O
"You are already at the first page of this node"	pointer
)	O
;	O
msg_one_window	pointer
=	O
_	O
(	O
"Only one window"	pointer
)	O
;	O
msg_win_too_small	pointer
=	O
_	O
(	O
"Resulting window would be too small"	pointer
)	O
;	O
msg_cant_make_help	pointer
=	O
_	O
(	O
"Not enough room for a help window, please delete a window"	pointer
)	O
;	O
}	O
