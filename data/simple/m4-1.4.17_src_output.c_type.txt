typedef	O
struct	O
temp_dir	struct
m4_temp_dir	struct
;	O
typedef	O
struct	O
m4_diversion	struct
m4_diversion	struct
;	O
struct	O
m4_diversion	struct
{	O
union	O
{	O
FILE	struct
*	O
file	pointer
;	O
char	O
*	O
buffer	pointer
;	O
m4_diversion	struct
*	O
next	pointer
;	O
}	O
u	union
;	O
int	O
divnum	int
;	O
int	O
size	pointer
;	O
int	O
used	int
;	O
}	O
;	O
static	O
gl_oset_t	pointer
diversion_table	pointer
;	O
static	O
m4_diversion	struct
div0	struct
;	O
static	O
m4_diversion	struct
*	O
free_list	pointer
;	O
static	O
struct	O
obstack	struct
diversion_storage	struct
;	O
static	O
int	O
total_buffer_size	int
;	O
int	O
current_diversion	int
;	O
static	O
m4_diversion	struct
*	O
output_diversion	pointer
;	O
static	O
FILE	struct
*	O
output_file	pointer
;	O
static	O
char	O
*	O
output_cursor	pointer
;	O
static	O
int	O
output_unused	int
;	O
int	O
output_current_line	int
;	O
static	O
m4_temp_dir	struct
*	O
output_temp_dir	pointer
;	O
static	O
FILE	struct
*	O
tmp_file1	pointer
;	O
static	O
FILE	struct
*	O
tmp_file2	pointer
;	O
static	O
int	O
tmp_file1_owner	int
;	O
static	O
int	O
tmp_file2_owner	int
;	O
static	O
bool	bool
tmp_file2_recent	bool
;	O
static	O
int	O
cmp_diversion_CB	function
(	O
const	O
void	O
*	O
elt1	pointer
,	O
const	O
void	O
*	O
elt2	pointer
)	O
{	O
const	O
m4_diversion	struct
*	O
d1	pointer
=	O
(	O
const	O
m4_diversion	struct
*	O
)	O
elt1	pointer
;	O
const	O
m4_diversion	struct
*	O
d2	pointer
=	O
(	O
const	O
m4_diversion	struct
*	O
)	O
elt2	pointer
;	O
return	O
d1	pointer
->	O
divnum	int
-	O
d2	pointer
->	O
divnum	int
;	O
}	O
static	O
bool	bool
threshold_diversion_CB	function
(	O
const	O
void	O
*	O
elt	pointer
,	O
const	O
void	O
*	O
threshold	pointer
)	O
{	O
const	O
m4_diversion	struct
*	O
diversion	pointer
=	O
(	O
const	O
m4_diversion	struct
*	O
)	O
elt	pointer
;	O
return	O
diversion	pointer
->	O
divnum	int
>=	O
*	O
(	O
const	O
int	O
*	O
)	O
threshold	pointer
;	O
}	O
static	O
void	O
cleanup_tmpfile	function
(	O
void	O
)	O
{	O
bool	bool
fail	bool
=	O
false	int
;	O
if	O
(	O
diversion_table	pointer
)	O
{	O
const	O
void	O
*	O
elt	pointer
;	O
gl_oset_iterator_t	struct
iter	struct
=	O
gl_oset_iterator	function
(	O
diversion_table	pointer
)	O
;	O
while	O
(	O
gl_oset_iterator_next	function
(	O
&	O
iter	struct
,	O
&	O
elt	pointer
)	O
)	O
{	O
m4_diversion	struct
*	O
diversion	pointer
=	O
(	O
m4_diversion	struct
*	O
)	O
elt	pointer
;	O
if	O
(	O
!	O
diversion	pointer
->	O
size	pointer
&&	O
diversion	pointer
->	O
u	union
.	O
file	pointer
&&	O
close_stream_temp	function
(	O
diversion	pointer
->	O
u	union
.	O
file	pointer
)	O
!=	O
0	int
)	O
{	O
M4ERROR	O
(	O
(	O
0	int
,	O
errno	O
,	O
"cannot clean temporary file for diversion"	pointer
)	O
)	O
;	O
fail	bool
=	O
true	int
;	O
}	O
}	O
gl_oset_iterator_free	function
(	O
&	O
iter	struct
)	O
;	O
}	O
if	O
(	O
cleanup_temp_dir	function
(	O
output_temp_dir	pointer
)	O
!=	O
0	int
)	O
fail	bool
=	O
true	int
;	O
if	O
(	O
fail	bool
)	O
_exit	function
(	O
exit_failure	int
)	O
;	O
}	O
static	O
const	O
char	O
*	O
m4_tmpname	function
(	O
int	O
divnum	int
)	O
{	O
static	O
char	O
*	O
buffer	pointer
;	O
static	O
char	O
*	O
tail	pointer
;	O
if	O
(	O
buffer	pointer
==	O
NULL	O
)	O
{	O
tail	pointer
=	O
xasprintf	function
(	O
"%s/m4-%d"	pointer
,	O
output_temp_dir	pointer
->	O
dir_name	pointer
,	O
INT_MAX	O
)	O
;	O
buffer	pointer
=	O
(	O
char	O
*	O
)	O
obstack_copy0	O
(	O
&	O
diversion_storage	struct
,	O
tail	pointer
,	O
strlen	function
(	O
tail	pointer
)	O
)	O
;	O
free	function
(	O
tail	pointer
)	O
;	O
tail	pointer
=	O
strrchr	function
(	O
buffer	pointer
,	O
'-'	O
)	O
+	O
1	int
;	O
}	O
assert	O
(	O
0	int
<	O
divnum	int
)	O
;	O
sprintf	function
(	O
tail	pointer
,	O
"%d"	pointer
,	O
divnum	int
)	O
;	O
return	O
buffer	pointer
;	O
}	O
static	O
FILE	struct
*	O
m4_tmpfile	function
(	O
int	O
divnum	int
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
FILE	struct
*	O
file	pointer
;	O
if	O
(	O
output_temp_dir	pointer
==	O
NULL	O
)	O
{	O
output_temp_dir	pointer
=	O
create_temp_dir	function
(	O
"m4-"	pointer
,	O
NULL	O
,	O
true	int
)	O
;	O
if	O
(	O
output_temp_dir	pointer
==	O
NULL	O
)	O
M4ERROR	O
(	O
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"cannot create temporary file for diversion"	pointer
)	O
)	O
;	O
atexit	function
(	O
cleanup_tmpfile	function
)	O
;	O
}	O
name	pointer
=	O
m4_tmpname	function
(	O
divnum	int
)	O
;	O
register_temp_file	function
(	O
output_temp_dir	pointer
,	O
name	pointer
)	O
;	O
file	pointer
=	O
fopen_temp	function
(	O
name	pointer
,	O
O_BINARY	int
?	O
"wb+"	pointer
:	O
"w+"	pointer
)	O
;	O
if	O
(	O
file	pointer
==	O
NULL	O
)	O
{	O
unregister_temp_file	function
(	O
output_temp_dir	pointer
,	O
name	pointer
)	O
;	O
M4ERROR	O
(	O
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"cannot create temporary file for diversion"	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
set_cloexec_flag	function
(	O
fileno	function
(	O
file	pointer
)	O
,	O
true	int
)	O
!=	O
0	int
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
errno	O
,	O
"Warning: cannot protect diversion across forks"	pointer
)	O
)	O
;	O
return	O
file	pointer
;	O
}	O
static	O
FILE	struct
*	O
m4_tmpopen	function
(	O
int	O
divnum	int
,	O
bool	bool
reread	bool
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
FILE	struct
*	O
file	pointer
;	O
if	O
(	O
tmp_file1_owner	int
==	O
divnum	int
)	O
{	O
if	O
(	O
reread	bool
&&	O
fseeko	function
(	O
tmp_file1	pointer
,	O
0	int
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
m4_error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"cannot seek within diversion"	pointer
)	O
)	O
;	O
tmp_file2_recent	bool
=	O
false	int
;	O
return	O
tmp_file1	pointer
;	O
}	O
else	O
if	O
(	O
tmp_file2_owner	int
==	O
divnum	int
)	O
{	O
if	O
(	O
reread	bool
&&	O
fseeko	function
(	O
tmp_file2	pointer
,	O
0	int
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
m4_error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"cannot seek within diversion"	pointer
)	O
)	O
;	O
tmp_file2_recent	bool
=	O
true	int
;	O
return	O
tmp_file2	pointer
;	O
}	O
name	pointer
=	O
m4_tmpname	function
(	O
divnum	int
)	O
;	O
file	pointer
=	O
fopen_temp	function
(	O
name	pointer
,	O
O_BINARY	int
?	O
"rb+"	pointer
:	O
"r+"	pointer
)	O
;	O
if	O
(	O
file	pointer
==	O
NULL	O
)	O
M4ERROR	O
(	O
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"cannot create temporary file for diversion"	pointer
)	O
)	O
;	O
else	O
if	O
(	O
set_cloexec_flag	function
(	O
fileno	function
(	O
file	pointer
)	O
,	O
true	int
)	O
!=	O
0	int
)	O
m4_error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"cannot protect diversion across forks"	pointer
)	O
)	O
;	O
else	O
if	O
(	O
!	O
reread	bool
&&	O
fseeko	function
(	O
file	pointer
,	O
0	int
,	O
SEEK_END	int
)	O
!=	O
0	int
)	O
m4_error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"cannot seek within diversion"	pointer
)	O
)	O
;	O
return	O
file	pointer
;	O
}	O
static	O
int	O
m4_tmpclose	function
(	O
FILE	struct
*	O
file	pointer
,	O
int	O
divnum	int
)	O
{	O
int	O
result	pointer
=	O
0	int
;	O
if	O
(	O
divnum	int
!=	O
tmp_file1_owner	int
&&	O
divnum	int
!=	O
tmp_file2_owner	int
)	O
{	O
if	O
(	O
tmp_file2_recent	bool
)	O
{	O
if	O
(	O
tmp_file1_owner	int
)	O
result	pointer
=	O
close_stream_temp	function
(	O
tmp_file1	pointer
)	O
;	O
tmp_file1	pointer
=	O
file	pointer
;	O
tmp_file1_owner	int
=	O
divnum	int
;	O
}	O
else	O
{	O
if	O
(	O
tmp_file2_owner	int
)	O
result	pointer
=	O
close_stream_temp	function
(	O
tmp_file2	pointer
)	O
;	O
tmp_file2	pointer
=	O
file	pointer
;	O
tmp_file2_owner	int
=	O
divnum	int
;	O
}	O
}	O
return	O
result	pointer
;	O
}	O
static	O
int	O
m4_tmpremove	function
(	O
int	O
divnum	int
)	O
{	O
if	O
(	O
divnum	int
==	O
tmp_file1_owner	int
)	O
{	O
int	O
result	pointer
=	O
close_stream_temp	function
(	O
tmp_file1	pointer
)	O
;	O
if	O
(	O
result	pointer
)	O
return	O
result	pointer
;	O
tmp_file1_owner	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
divnum	int
==	O
tmp_file2_owner	int
)	O
{	O
int	O
result	pointer
=	O
close_stream_temp	function
(	O
tmp_file2	pointer
)	O
;	O
if	O
(	O
result	pointer
)	O
return	O
result	pointer
;	O
tmp_file2_owner	int
=	O
0	int
;	O
}	O
return	O
cleanup_temp_file	function
(	O
output_temp_dir	pointer
,	O
m4_tmpname	function
(	O
divnum	int
)	O
)	O
;	O
}	O
static	O
FILE	struct
*	O
m4_tmprename	function
(	O
int	O
oldnum	int
,	O
int	O
newnum	int
)	O
{	O
char	O
*	O
oldname	pointer
=	O
xstrdup	function
(	O
m4_tmpname	function
(	O
oldnum	int
)	O
)	O
;	O
const	O
char	O
*	O
newname	pointer
=	O
m4_tmpname	function
(	O
newnum	int
)	O
;	O
register_temp_file	function
(	O
output_temp_dir	pointer
,	O
newname	pointer
)	O
;	O
if	O
(	O
oldnum	int
==	O
tmp_file1_owner	int
)	O
{	O
if	O
(	O
RENAME_OPEN_FILE_WORKS	int
)	O
tmp_file1_owner	int
=	O
newnum	int
;	O
else	O
{	O
if	O
(	O
close_stream_temp	function
(	O
tmp_file1	pointer
)	O
)	O
m4_error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"cannot close temporary file for diversion"	pointer
)	O
)	O
;	O
tmp_file1_owner	int
=	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
oldnum	int
==	O
tmp_file2_owner	int
)	O
{	O
if	O
(	O
RENAME_OPEN_FILE_WORKS	int
)	O
tmp_file2_owner	int
=	O
newnum	int
;	O
else	O
{	O
if	O
(	O
close_stream_temp	function
(	O
tmp_file2	pointer
)	O
)	O
m4_error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"cannot close temporary file for diversion"	pointer
)	O
)	O
;	O
tmp_file2_owner	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
rename	function
(	O
oldname	pointer
,	O
newname	pointer
)	O
)	O
m4_error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"cannot create temporary file for diversion"	pointer
)	O
)	O
;	O
unregister_temp_file	function
(	O
output_temp_dir	pointer
,	O
oldname	pointer
)	O
;	O
free	function
(	O
oldname	pointer
)	O
;	O
return	O
m4_tmpopen	function
(	O
newnum	int
,	O
false	int
)	O
;	O
}	O
void	O
output_init	function
(	O
void	O
)	O
{	O
diversion_table	pointer
=	O
gl_oset_create_empty	function
(	O
GL_AVLTREE_OSET	O
,	O
cmp_diversion_CB	function
,	O
NULL	O
)	O
;	O
div0	struct
.	O
u	union
.	O
file	pointer
=	O
stdout	pointer
;	O
output_diversion	pointer
=	O
&	O
div0	struct
;	O
output_file	pointer
=	O
stdout	pointer
;	O
obstack_init	O
(	O
&	O
diversion_storage	struct
)	O
;	O
}	O
void	O
output_exit	function
(	O
void	O
)	O
{	O
gl_oset_t	pointer
table	pointer
=	O
diversion_table	pointer
;	O
if	O
(	O
tmp_file1_owner	int
)	O
m4_tmpremove	function
(	O
tmp_file1_owner	int
)	O
;	O
if	O
(	O
tmp_file2_owner	int
)	O
m4_tmpremove	function
(	O
tmp_file2_owner	int
)	O
;	O
diversion_table	pointer
=	O
NULL	O
;	O
gl_oset_free	function
(	O
table	pointer
)	O
;	O
obstack_free	function
(	O
&	O
diversion_storage	struct
,	O
NULL	O
)	O
;	O
}	O
static	O
void	O
make_room_for	function
(	O
int	O
length	long
)	O
{	O
int	O
wanted_size	int
;	O
m4_diversion	struct
*	O
selected_diversion	pointer
=	O
NULL	O
;	O
output_diversion	pointer
->	O
used	int
=	O
output_diversion	pointer
->	O
size	pointer
-	O
output_unused	int
;	O
for	O
(	O
wanted_size	int
=	O
output_diversion	pointer
->	O
size	pointer
;	O
wanted_size	int
<	O
output_diversion	pointer
->	O
used	int
+	O
length	long
;	O
wanted_size	int
=	O
wanted_size	int
==	O
0	int
?	O
INITIAL_BUFFER_SIZE	int
:	O
wanted_size	int
*	O
2	int
)	O
;	O
if	O
(	O
total_buffer_size	int
-	O
output_diversion	pointer
->	O
size	pointer
+	O
wanted_size	int
>	O
MAXIMUM_TOTAL_SIZE	O
)	O
{	O
int	O
selected_used	int
;	O
char	O
*	O
selected_buffer	pointer
;	O
m4_diversion	struct
*	O
diversion	pointer
;	O
int	O
count	long
;	O
gl_oset_iterator_t	struct
iter	struct
;	O
const	O
void	O
*	O
elt	pointer
;	O
selected_diversion	pointer
=	O
output_diversion	pointer
;	O
selected_used	int
=	O
output_diversion	pointer
->	O
used	int
+	O
length	long
;	O
iter	struct
=	O
gl_oset_iterator	function
(	O
diversion_table	pointer
)	O
;	O
while	O
(	O
gl_oset_iterator_next	function
(	O
&	O
iter	struct
,	O
&	O
elt	pointer
)	O
)	O
{	O
diversion	pointer
=	O
(	O
m4_diversion	struct
*	O
)	O
elt	pointer
;	O
if	O
(	O
diversion	pointer
->	O
used	int
>	O
selected_used	int
)	O
{	O
selected_diversion	pointer
=	O
diversion	pointer
;	O
selected_used	int
=	O
diversion	pointer
->	O
used	int
;	O
}	O
}	O
gl_oset_iterator_free	function
(	O
&	O
iter	struct
)	O
;	O
selected_buffer	pointer
=	O
selected_diversion	pointer
->	O
u	union
.	O
buffer	pointer
;	O
total_buffer_size	int
-=	O
selected_diversion	pointer
->	O
size	pointer
;	O
selected_diversion	pointer
->	O
size	pointer
=	O
0	int
;	O
selected_diversion	pointer
->	O
u	union
.	O
file	pointer
=	O
NULL	O
;	O
selected_diversion	pointer
->	O
u	union
.	O
file	pointer
=	O
m4_tmpfile	function
(	O
selected_diversion	pointer
->	O
divnum	int
)	O
;	O
if	O
(	O
selected_diversion	pointer
->	O
used	int
>	O
0	int
)	O
{	O
count	long
=	O
fwrite	function
(	O
selected_buffer	pointer
,	O
(	O
size_t	long
)	O
selected_diversion	pointer
->	O
used	int
,	O
1	int
,	O
selected_diversion	pointer
->	O
u	union
.	O
file	pointer
)	O
;	O
if	O
(	O
count	long
!=	O
1	int
)	O
M4ERROR	O
(	O
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"ERROR: cannot flush diversion to temporary file"	pointer
)	O
)	O
;	O
}	O
free	function
(	O
selected_buffer	pointer
)	O
;	O
selected_diversion	pointer
->	O
used	int
=	O
1	int
;	O
}	O
if	O
(	O
output_diversion	pointer
==	O
selected_diversion	pointer
)	O
{	O
output_file	pointer
=	O
output_diversion	pointer
->	O
u	union
.	O
file	pointer
;	O
output_cursor	pointer
=	O
NULL	O
;	O
output_unused	int
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
selected_diversion	pointer
)	O
{	O
FILE	struct
*	O
file	pointer
=	O
selected_diversion	pointer
->	O
u	union
.	O
file	pointer
;	O
selected_diversion	pointer
->	O
u	union
.	O
file	pointer
=	O
NULL	O
;	O
if	O
(	O
m4_tmpclose	function
(	O
file	pointer
,	O
selected_diversion	pointer
->	O
divnum	int
)	O
!=	O
0	int
)	O
m4_error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"cannot close temporary file for diversion"	pointer
)	O
)	O
;	O
}	O
{	O
char	O
*	O
buffer	pointer
=	O
output_diversion	pointer
->	O
u	union
.	O
buffer	pointer
;	O
output_diversion	pointer
->	O
u	union
.	O
buffer	pointer
=	O
xcharalloc	function
(	O
(	O
size_t	long
)	O
wanted_size	int
)	O
;	O
memcpy	function
(	O
output_diversion	pointer
->	O
u	union
.	O
buffer	pointer
,	O
buffer	pointer
,	O
output_diversion	pointer
->	O
used	int
)	O
;	O
free	function
(	O
buffer	pointer
)	O
;	O
}	O
total_buffer_size	int
+=	O
wanted_size	int
-	O
output_diversion	pointer
->	O
size	pointer
;	O
output_diversion	pointer
->	O
size	pointer
=	O
wanted_size	int
;	O
output_cursor	pointer
=	O
output_diversion	pointer
->	O
u	union
.	O
buffer	pointer
+	O
output_diversion	pointer
->	O
used	int
;	O
output_unused	int
=	O
wanted_size	int
-	O
output_diversion	pointer
->	O
used	int
;	O
}	O
}	O
static	O
void	O
output_character_helper	function
(	O
int	O
character	int
)	O
{	O
make_room_for	function
(	O
1	int
)	O
;	O
if	O
(	O
output_file	pointer
)	O
putc	function
(	O
character	int
,	O
output_file	pointer
)	O
;	O
else	O
{	O
*	O
output_cursor	pointer
++	O
=	O
character	int
;	O
output_unused	int
--	O
;	O
}	O
}	O
void	O
output_text	function
(	O
const	O
char	O
*	O
text	pointer
,	O
int	O
length	long
)	O
{	O
int	O
count	long
;	O
if	O
(	O
!	O
output_diversion	pointer
||	O
!	O
length	long
)	O
return	O
;	O
if	O
(	O
!	O
output_file	pointer
&&	O
length	long
>	O
output_unused	int
)	O
make_room_for	function
(	O
length	long
)	O
;	O
if	O
(	O
output_file	pointer
)	O
{	O
count	long
=	O
fwrite	function
(	O
text	pointer
,	O
length	long
,	O
1	int
,	O
output_file	pointer
)	O
;	O
if	O
(	O
count	long
!=	O
1	int
)	O
M4ERROR	O
(	O
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"ERROR: copying inserted file"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
memcpy	function
(	O
output_cursor	pointer
,	O
text	pointer
,	O
(	O
size_t	long
)	O
length	long
)	O
;	O
output_cursor	pointer
+=	O
length	long
;	O
output_unused	int
-=	O
length	long
;	O
}	O
}	O
void	O
shipout_text	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
const	O
char	O
*	O
text	pointer
,	O
int	O
length	long
,	O
int	O
line	int
)	O
{	O
static	O
bool	bool
start_of_output_line	bool
=	O
true	int
;	O
const	O
char	O
*	O
cursor	pointer
;	O
if	O
(	O
obs	pointer
!=	O
NULL	O
)	O
{	O
obstack_grow	O
(	O
obs	pointer
,	O
text	pointer
,	O
length	long
)	O
;	O
return	O
;	O
}	O
if	O
(	O
output_diversion	pointer
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
!	O
sync_output	int
)	O
switch	O
(	O
length	long
)	O
{	O
case	O
8	int
:	O
OUTPUT_CHARACTER	O
(	O
*	O
text	pointer
)	O
;	O
text	pointer
++	O
;	O
case	O
7	int
:	O
OUTPUT_CHARACTER	O
(	O
*	O
text	pointer
)	O
;	O
text	pointer
++	O
;	O
case	O
6	int
:	O
OUTPUT_CHARACTER	O
(	O
*	O
text	pointer
)	O
;	O
text	pointer
++	O
;	O
case	O
5	int
:	O
OUTPUT_CHARACTER	O
(	O
*	O
text	pointer
)	O
;	O
text	pointer
++	O
;	O
case	O
4	int
:	O
OUTPUT_CHARACTER	O
(	O
*	O
text	pointer
)	O
;	O
text	pointer
++	O
;	O
case	O
3	int
:	O
OUTPUT_CHARACTER	O
(	O
*	O
text	pointer
)	O
;	O
text	pointer
++	O
;	O
case	O
2	int
:	O
OUTPUT_CHARACTER	O
(	O
*	O
text	pointer
)	O
;	O
text	pointer
++	O
;	O
case	O
1	int
:	O
OUTPUT_CHARACTER	O
(	O
*	O
text	pointer
)	O
;	O
case	O
0	int
:	O
return	O
;	O
default	O
:	O
output_text	function
(	O
text	pointer
,	O
length	long
)	O
;	O
}	O
else	O
{	O
if	O
(	O
start_of_output_line	bool
)	O
{	O
start_of_output_line	bool
=	O
false	int
;	O
output_current_line	int
++	O
;	O
if	O
(	O
output_current_line	int
!=	O
line	int
)	O
{	O
OUTPUT_CHARACTER	O
(	O
'#'	O
)	O
;	O
OUTPUT_CHARACTER	O
(	O
'l'	O
)	O
;	O
OUTPUT_CHARACTER	O
(	O
'i'	O
)	O
;	O
OUTPUT_CHARACTER	O
(	O
'n'	O
)	O
;	O
OUTPUT_CHARACTER	O
(	O
'e'	O
)	O
;	O
OUTPUT_CHARACTER	O
(	O
' '	O
)	O
;	O
for	O
(	O
cursor	pointer
=	O
ntoa	function
(	O
line	int
,	O
10	int
)	O
;	O
*	O
cursor	pointer
;	O
cursor	pointer
++	O
)	O
OUTPUT_CHARACTER	O
(	O
*	O
cursor	pointer
)	O
;	O
if	O
(	O
output_current_line	int
<	O
1	int
&&	O
current_file	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
OUTPUT_CHARACTER	O
(	O
' '	O
)	O
;	O
OUTPUT_CHARACTER	O
(	O
'"'	O
)	O
;	O
for	O
(	O
cursor	pointer
=	O
current_file	pointer
;	O
*	O
cursor	pointer
;	O
cursor	pointer
++	O
)	O
OUTPUT_CHARACTER	O
(	O
*	O
cursor	pointer
)	O
;	O
OUTPUT_CHARACTER	O
(	O
'"'	O
)	O
;	O
}	O
OUTPUT_CHARACTER	O
(	O
'\n'	O
)	O
;	O
output_current_line	int
=	O
line	int
;	O
}	O
}	O
for	O
(	O
;	O
length	long
--	O
>	O
0	int
;	O
text	pointer
++	O
)	O
{	O
if	O
(	O
start_of_output_line	bool
)	O
{	O
start_of_output_line	bool
=	O
false	int
;	O
output_current_line	int
++	O
;	O
}	O
OUTPUT_CHARACTER	O
(	O
*	O
text	pointer
)	O
;	O
if	O
(	O
*	O
text	pointer
==	O
'\n'	O
)	O
start_of_output_line	bool
=	O
true	int
;	O
}	O
}	O
}	O
void	O
make_diversion	function
(	O
int	O
divnum	int
)	O
{	O
m4_diversion	struct
*	O
diversion	pointer
=	O
NULL	O
;	O
if	O
(	O
current_diversion	int
==	O
divnum	int
)	O
return	O
;	O
if	O
(	O
output_diversion	pointer
)	O
{	O
if	O
(	O
!	O
output_diversion	pointer
->	O
size	pointer
&&	O
!	O
output_diversion	pointer
->	O
u	union
.	O
file	pointer
)	O
{	O
assert	O
(	O
!	O
output_diversion	pointer
->	O
used	int
)	O
;	O
if	O
(	O
!	O
gl_oset_remove	function
(	O
diversion_table	pointer
,	O
output_diversion	pointer
)	O
)	O
assert	O
(	O
false	int
)	O
;	O
output_diversion	pointer
->	O
u	union
.	O
next	pointer
=	O
free_list	pointer
;	O
free_list	pointer
=	O
output_diversion	pointer
;	O
}	O
else	O
if	O
(	O
output_diversion	pointer
->	O
size	pointer
)	O
output_diversion	pointer
->	O
used	int
=	O
output_diversion	pointer
->	O
size	pointer
-	O
output_unused	int
;	O
else	O
if	O
(	O
output_diversion	pointer
->	O
used	int
)	O
{	O
FILE	struct
*	O
file	pointer
=	O
output_diversion	pointer
->	O
u	union
.	O
file	pointer
;	O
output_diversion	pointer
->	O
u	union
.	O
file	pointer
=	O
NULL	O
;	O
if	O
(	O
m4_tmpclose	function
(	O
file	pointer
,	O
output_diversion	pointer
->	O
divnum	int
)	O
!=	O
0	int
)	O
m4_error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"cannot close temporary file for diversion"	pointer
)	O
)	O
;	O
}	O
output_diversion	pointer
=	O
NULL	O
;	O
output_file	pointer
=	O
NULL	O
;	O
output_cursor	pointer
=	O
NULL	O
;	O
output_unused	int
=	O
0	int
;	O
}	O
current_diversion	int
=	O
divnum	int
;	O
if	O
(	O
divnum	int
<	O
0	int
)	O
return	O
;	O
if	O
(	O
divnum	int
==	O
0	int
)	O
diversion	pointer
=	O
&	O
div0	struct
;	O
else	O
{	O
const	O
void	O
*	O
elt	pointer
;	O
if	O
(	O
gl_oset_search_atleast	function
(	O
diversion_table	pointer
,	O
threshold_diversion_CB	function
,	O
&	O
divnum	int
,	O
&	O
elt	pointer
)	O
)	O
{	O
m4_diversion	struct
*	O
temp	union
=	O
(	O
m4_diversion	struct
*	O
)	O
elt	pointer
;	O
if	O
(	O
temp	union
->	O
divnum	int
==	O
divnum	int
)	O
diversion	pointer
=	O
temp	union
;	O
}	O
}	O
if	O
(	O
diversion	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
free_list	pointer
)	O
{	O
diversion	pointer
=	O
free_list	pointer
;	O
free_list	pointer
=	O
diversion	pointer
->	O
u	union
.	O
next	pointer
;	O
}	O
else	O
{	O
diversion	pointer
=	O
(	O
m4_diversion	struct
*	O
)	O
obstack_alloc	O
(	O
&	O
diversion_storage	struct
,	O
sizeof	O
*	O
diversion	pointer
)	O
;	O
diversion	pointer
->	O
size	pointer
=	O
0	int
;	O
diversion	pointer
->	O
used	int
=	O
0	int
;	O
}	O
diversion	pointer
->	O
u	union
.	O
file	pointer
=	O
NULL	O
;	O
diversion	pointer
->	O
divnum	int
=	O
divnum	int
;	O
gl_oset_add	function
(	O
diversion_table	pointer
,	O
diversion	pointer
)	O
;	O
}	O
output_diversion	pointer
=	O
diversion	pointer
;	O
if	O
(	O
output_diversion	pointer
->	O
size	pointer
)	O
{	O
output_cursor	pointer
=	O
output_diversion	pointer
->	O
u	union
.	O
buffer	pointer
+	O
output_diversion	pointer
->	O
used	int
;	O
output_unused	int
=	O
output_diversion	pointer
->	O
size	pointer
-	O
output_diversion	pointer
->	O
used	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
output_diversion	pointer
->	O
u	union
.	O
file	pointer
&&	O
output_diversion	pointer
->	O
used	int
)	O
output_diversion	pointer
->	O
u	union
.	O
file	pointer
=	O
m4_tmpopen	function
(	O
output_diversion	pointer
->	O
divnum	int
,	O
false	int
)	O
;	O
output_file	pointer
=	O
output_diversion	pointer
->	O
u	union
.	O
file	pointer
;	O
}	O
output_current_line	int
=	O
-	O
1	int
;	O
}	O
void	O
insert_file	function
(	O
FILE	struct
*	O
file	pointer
)	O
{	O
static	O
char	O
buffer	pointer
[	O
COPY_BUFFER_SIZE	O
]	O
;	O
size_t	long
length	long
;	O
if	O
(	O
!	O
output_diversion	pointer
)	O
return	O
;	O
while	O
(	O
1	int
)	O
{	O
length	long
=	O
fread	function
(	O
buffer	pointer
,	O
1	int
,	O
sizeof	O
buffer	pointer
,	O
file	pointer
)	O
;	O
if	O
(	O
ferror	function
(	O
file	pointer
)	O
)	O
M4ERROR	O
(	O
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"error reading inserted file"	pointer
)	O
)	O
;	O
if	O
(	O
length	long
==	O
0	int
)	O
break	O
;	O
output_text	function
(	O
buffer	pointer
,	O
length	long
)	O
;	O
}	O
}	O
static	O
void	O
insert_diversion_helper	function
(	O
m4_diversion	struct
*	O
diversion	pointer
)	O
{	O
if	O
(	O
output_diversion	pointer
)	O
{	O
if	O
(	O
diversion	pointer
->	O
size	pointer
)	O
{	O
if	O
(	O
!	O
output_diversion	pointer
->	O
u	union
.	O
file	pointer
)	O
{	O
assert	O
(	O
!	O
output_diversion	pointer
->	O
used	int
&&	O
output_diversion	pointer
!=	O
&	O
div0	struct
&&	O
!	O
output_file	pointer
)	O
;	O
output_diversion	pointer
->	O
u	union
.	O
buffer	pointer
=	O
diversion	pointer
->	O
u	union
.	O
buffer	pointer
;	O
output_diversion	pointer
->	O
size	pointer
=	O
diversion	pointer
->	O
size	pointer
;	O
output_cursor	pointer
=	O
diversion	pointer
->	O
u	union
.	O
buffer	pointer
+	O
diversion	pointer
->	O
used	int
;	O
output_unused	int
=	O
diversion	pointer
->	O
size	pointer
-	O
diversion	pointer
->	O
used	int
;	O
diversion	pointer
->	O
u	union
.	O
buffer	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
total_buffer_size	int
-=	O
diversion	pointer
->	O
size	pointer
;	O
output_text	function
(	O
diversion	pointer
->	O
u	union
.	O
buffer	pointer
,	O
diversion	pointer
->	O
used	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
output_diversion	pointer
->	O
u	union
.	O
file	pointer
)	O
{	O
assert	O
(	O
!	O
output_diversion	pointer
->	O
used	int
&&	O
output_diversion	pointer
!=	O
&	O
div0	struct
&&	O
!	O
output_file	pointer
)	O
;	O
output_diversion	pointer
->	O
u	union
.	O
file	pointer
=	O
m4_tmprename	function
(	O
diversion	pointer
->	O
divnum	int
,	O
output_diversion	pointer
->	O
divnum	int
)	O
;	O
output_diversion	pointer
->	O
used	int
=	O
1	int
;	O
output_file	pointer
=	O
output_diversion	pointer
->	O
u	union
.	O
file	pointer
;	O
diversion	pointer
->	O
u	union
.	O
file	pointer
=	O
NULL	O
;	O
diversion	pointer
->	O
size	pointer
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
diversion	pointer
->	O
u	union
.	O
file	pointer
)	O
diversion	pointer
->	O
u	union
.	O
file	pointer
=	O
m4_tmpopen	function
(	O
diversion	pointer
->	O
divnum	int
,	O
true	int
)	O
;	O
insert_file	function
(	O
diversion	pointer
->	O
u	union
.	O
file	pointer
)	O
;	O
}	O
output_current_line	int
=	O
-	O
1	int
;	O
}	O
if	O
(	O
diversion	pointer
->	O
size	pointer
)	O
{	O
if	O
(	O
!	O
output_diversion	pointer
)	O
total_buffer_size	int
-=	O
diversion	pointer
->	O
size	pointer
;	O
free	function
(	O
diversion	pointer
->	O
u	union
.	O
buffer	pointer
)	O
;	O
diversion	pointer
->	O
size	pointer
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
diversion	pointer
->	O
u	union
.	O
file	pointer
)	O
{	O
FILE	struct
*	O
file	pointer
=	O
diversion	pointer
->	O
u	union
.	O
file	pointer
;	O
diversion	pointer
->	O
u	union
.	O
file	pointer
=	O
NULL	O
;	O
if	O
(	O
m4_tmpclose	function
(	O
file	pointer
,	O
diversion	pointer
->	O
divnum	int
)	O
!=	O
0	int
)	O
m4_error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"cannot clean temporary file for diversion"	pointer
)	O
)	O
;	O
}	O
if	O
(	O
m4_tmpremove	function
(	O
diversion	pointer
->	O
divnum	int
)	O
!=	O
0	int
)	O
M4ERROR	O
(	O
(	O
0	int
,	O
errno	O
,	O
"cannot clean temporary file for diversion"	pointer
)	O
)	O
;	O
}	O
diversion	pointer
->	O
used	int
=	O
0	int
;	O
gl_oset_remove	function
(	O
diversion_table	pointer
,	O
diversion	pointer
)	O
;	O
diversion	pointer
->	O
u	union
.	O
next	pointer
=	O
free_list	pointer
;	O
free_list	pointer
=	O
diversion	pointer
;	O
}	O
void	O
insert_diversion	function
(	O
int	O
divnum	int
)	O
{	O
const	O
void	O
*	O
elt	pointer
;	O
if	O
(	O
divnum	int
<=	O
0	int
||	O
current_diversion	int
==	O
divnum	int
)	O
return	O
;	O
if	O
(	O
gl_oset_search_atleast	function
(	O
diversion_table	pointer
,	O
threshold_diversion_CB	function
,	O
&	O
divnum	int
,	O
&	O
elt	pointer
)	O
)	O
{	O
m4_diversion	struct
*	O
diversion	pointer
=	O
(	O
m4_diversion	struct
*	O
)	O
elt	pointer
;	O
if	O
(	O
diversion	pointer
->	O
divnum	int
==	O
divnum	int
)	O
insert_diversion_helper	function
(	O
diversion	pointer
)	O
;	O
}	O
}	O
void	O
undivert_all	function
(	O
void	O
)	O
{	O
const	O
void	O
*	O
elt	pointer
;	O
gl_oset_iterator_t	struct
iter	struct
=	O
gl_oset_iterator	function
(	O
diversion_table	pointer
)	O
;	O
while	O
(	O
gl_oset_iterator_next	function
(	O
&	O
iter	struct
,	O
&	O
elt	pointer
)	O
)	O
{	O
m4_diversion	struct
*	O
diversion	pointer
=	O
(	O
m4_diversion	struct
*	O
)	O
elt	pointer
;	O
if	O
(	O
diversion	pointer
->	O
divnum	int
!=	O
current_diversion	int
)	O
insert_diversion_helper	function
(	O
diversion	pointer
)	O
;	O
}	O
gl_oset_iterator_free	function
(	O
&	O
iter	struct
)	O
;	O
}	O
void	O
freeze_diversions	function
(	O
FILE	struct
*	O
file	pointer
)	O
{	O
int	O
saved_number	int
;	O
int	O
last_inserted	int
;	O
gl_oset_iterator_t	struct
iter	struct
;	O
const	O
void	O
*	O
elt	pointer
;	O
saved_number	int
=	O
current_diversion	int
;	O
last_inserted	int
=	O
0	int
;	O
make_diversion	function
(	O
0	int
)	O
;	O
output_file	pointer
=	O
file	pointer
;	O
iter	struct
=	O
gl_oset_iterator	function
(	O
diversion_table	pointer
)	O
;	O
while	O
(	O
gl_oset_iterator_next	function
(	O
&	O
iter	struct
,	O
&	O
elt	pointer
)	O
)	O
{	O
m4_diversion	struct
*	O
diversion	pointer
=	O
(	O
m4_diversion	struct
*	O
)	O
elt	pointer
;	O
if	O
(	O
diversion	pointer
->	O
size	pointer
||	O
diversion	pointer
->	O
used	int
)	O
{	O
if	O
(	O
diversion	pointer
->	O
size	pointer
)	O
xfprintf	function
(	O
file	pointer
,	O
"D%d,%d\n"	pointer
,	O
diversion	pointer
->	O
divnum	int
,	O
diversion	pointer
->	O
used	int
)	O
;	O
else	O
{	O
struct	O
stat	struct
file_stat	struct
;	O
diversion	pointer
->	O
u	union
.	O
file	pointer
=	O
m4_tmpopen	function
(	O
diversion	pointer
->	O
divnum	int
,	O
true	int
)	O
;	O
if	O
(	O
fstat	function
(	O
fileno	function
(	O
diversion	pointer
->	O
u	union
.	O
file	pointer
)	O
,	O
&	O
file_stat	struct
)	O
<	O
0	int
)	O
M4ERROR	O
(	O
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"cannot stat diversion"	pointer
)	O
)	O
;	O
if	O
(	O
file_stat	struct
.	O
st_size	long
<	O
0	int
||	O
(	O
file_stat	struct
.	O
st_size	long
+	O
0UL	int
!=	O
(	O
unsigned	O
long	O
int	O
)	O
file_stat	struct
.	O
st_size	long
)	O
)	O
M4ERROR	O
(	O
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"diversion too large"	pointer
)	O
)	O
;	O
xfprintf	function
(	O
file	pointer
,	O
"D%d,%lu\n"	pointer
,	O
diversion	pointer
->	O
divnum	int
,	O
(	O
unsigned	O
long	O
int	O
)	O
file_stat	struct
.	O
st_size	long
)	O
;	O
}	O
insert_diversion_helper	function
(	O
diversion	pointer
)	O
;	O
putc	function
(	O
'\n'	O
,	O
file	pointer
)	O
;	O
last_inserted	int
=	O
diversion	pointer
->	O
divnum	int
;	O
}	O
}	O
gl_oset_iterator_free	function
(	O
&	O
iter	struct
)	O
;	O
if	O
(	O
saved_number	int
!=	O
last_inserted	int
)	O
xfprintf	function
(	O
file	pointer
,	O
"D%d,0\n\n"	pointer
,	O
saved_number	int
)	O
;	O
}	O
