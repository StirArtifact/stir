static	O
uid_t	int
ruid	int
(	O
void	O
)	O
{	O
cacheid	O
(	O
ruid	int
,	O
getuid	function
(	O
)	O
)	O
;	O
}	O
bool	bool
stat_mine_p	function
(	O
struct	O
stat	struct
*	O
st	pointer
)	O
{	O
return	O
ruid	int
(	O
)	O
==	O
st	pointer
->	O
st_uid	int
;	O
}	O
static	O
uid_t	int
euid	int
(	O
void	O
)	O
{	O
cacheid	O
(	O
euid	int
,	O
geteuid	function
(	O
)	O
)	O
;	O
}	O
bool	bool
currently_setuid_p	function
(	O
void	O
)	O
{	O
return	O
euid	int
(	O
)	O
!=	O
ruid	int
(	O
)	O
;	O
}	O
static	O
void	O
set_uid_to	function
(	O
uid_t	int
u	struct
)	O
{	O
if	O
(	O
!	O
currently_setuid_p	function
(	O
)	O
)	O
return	O
;	O
if	O
(	O
PROB	O
(	O
seteuid	function
(	O
u	struct
)	O
)	O
)	O
fatal_sys	function
(	O
"setuid"	pointer
)	O
;	O
if	O
(	O
geteuid	function
(	O
)	O
!=	O
u	struct
)	O
{	O
if	O
(	O
BE	O
(	O
already_setuid	bool
)	O
)	O
return	O
;	O
BE	O
(	O
already_setuid	bool
)	O
=	O
true	int
;	O
PFATAL	O
(	O
"root setuid not supported"	pointer
+	O
(	O
u	struct
?	O
5	int
:	O
0	int
)	O
)	O
;	O
}	O
}	O
void	O
nosetid	function
(	O
void	O
)	O
{	O
BE	O
(	O
stick_with_euid	bool
)	O
=	O
true	int
;	O
}	O
void	O
seteid	function
(	O
void	O
)	O
{	O
if	O
(	O
!	O
BE	O
(	O
stick_with_euid	bool
)	O
)	O
set_uid_to	function
(	O
euid	int
(	O
)	O
)	O
;	O
}	O
void	O
setrid	function
(	O
void	O
)	O
{	O
if	O
(	O
!	O
BE	O
(	O
stick_with_euid	bool
)	O
)	O
set_uid_to	function
(	O
ruid	int
(	O
)	O
)	O
;	O
}	O
char	O
const	O
*	O
getusername	function
(	O
bool	bool
suspicious	bool
)	O
{	O
if	O
(	O
!	O
BE	O
(	O
username	pointer
)	O
)	O
{	O
char	O
buf	pointer
[	O
BUFSIZ	int
]	O
;	O
if	O
(	O
suspicious	bool
||	O
(	O
!	O
JAM	O
(	O
cgetenv	function
(	O
"LOGNAME"	pointer
)	O
)	O
&&	O
!	O
JAM	O
(	O
cgetenv	function
(	O
"USER"	pointer
)	O
)	O
&&	O
!	O
(	O
0	int
==	O
getlogin_r	function
(	O
buf	pointer
,	O
BUFSIZ	int
)	O
&&	O
JAM	O
(	O
str_save	function
(	O
buf	pointer
)	O
)	O
)	O
)	O
)	O
{	O
struct	O
passwd	struct
pwbuf	struct
,	O
*	O
pw	pointer
=	O
NULL	O
;	O
if	O
(	O
getpwuid_r	function
(	O
ruid	int
(	O
)	O
,	O
&	O
pwbuf	struct
,	O
buf	pointer
,	O
BUFSIZ	int
,	O
&	O
pw	pointer
)	O
||	O
&	O
pwbuf	struct
!=	O
pw	pointer
||	O
!	O
pw	pointer
->	O
pw_name	pointer
)	O
PFATAL	O
(	O
"no password entry for userid %d"	pointer
,	O
ruid	int
(	O
)	O
)	O
;	O
JAM	O
(	O
str_save	function
(	O
pw	pointer
->	O
pw_name	pointer
)	O
)	O
;	O
}	O
checksid	function
(	O
BE	O
(	O
username	pointer
)	O
)	O
;	O
}	O
return	O
BE	O
(	O
username	pointer
)	O
;	O
}	O
char	O
const	O
*	O
getcaller	function
(	O
void	O
)	O
{	O
return	O
getusername	function
(	O
currently_setuid_p	function
(	O
)	O
)	O
;	O
}	O
bool	bool
caller_login_p	function
(	O
char	O
const	O
*	O
login	pointer
)	O
{	O
return	O
STR_SAME	O
(	O
getcaller	function
(	O
)	O
,	O
login	pointer
)	O
;	O
}	O
struct	O
link	function
*	O
lock_memq	function
(	O
struct	O
link	function
*	O
ls	pointer
,	O
bool	bool
loginp	bool
,	O
void	O
const	O
*	O
x	pointer
)	O
{	O
struct	O
rcslock	struct
const	O
*	O
rl	pointer
;	O
for	O
(	O
;	O
ls	pointer
->	O
next	pointer
;	O
ls	pointer
=	O
ls	pointer
->	O
next	pointer
)	O
{	O
rl	pointer
=	O
ls	pointer
->	O
next	pointer
->	O
entry	pointer
;	O
if	O
(	O
loginp	bool
?	O
STR_SAME	O
(	O
x	pointer
,	O
rl	pointer
->	O
login	pointer
)	O
:	O
x	pointer
==	O
rl	pointer
->	O
delta	struct
)	O
return	O
ls	pointer
;	O
}	O
return	O
NULL	O
;	O
}	O
struct	O
rcslock	struct
const	O
*	O
lock_on	function
(	O
struct	O
delta	struct
const	O
*	O
delta	struct
)	O
{	O
for	O
(	O
struct	O
link	function
*	O
ls	pointer
=	O
GROK	O
(	O
locks	pointer
)	O
;	O
ls	pointer
;	O
ls	pointer
=	O
ls	pointer
->	O
next	pointer
)	O
{	O
struct	O
rcslock	struct
const	O
*	O
rl	pointer
=	O
ls	pointer
->	O
entry	pointer
;	O
if	O
(	O
delta	struct
==	O
rl	pointer
->	O
delta	struct
)	O
return	O
rl	pointer
;	O
}	O
return	O
NULL	O
;	O
}	O
void	O
lock_drop	function
(	O
struct	O
link	function
*	O
box	pointer
,	O
struct	O
link	function
*	O
tp	pointer
)	O
{	O
struct	O
rcslock	struct
const	O
*	O
rl	pointer
=	O
tp	pointer
->	O
next	pointer
->	O
entry	pointer
;	O
rl	pointer
->	O
delta	struct
->	O
lockedby	pointer
=	O
NULL	O
;	O
tp	pointer
->	O
next	pointer
=	O
tp	pointer
->	O
next	pointer
->	O
next	pointer
;	O
GROK	O
(	O
locks	pointer
)	O
=	O
box	pointer
->	O
next	pointer
;	O
}	O
int	O
addlock	function
(	O
struct	O
delta	struct
*	O
delta	struct
,	O
bool	bool
verbose	bool
)	O
{	O
register	O
struct	O
rcslock	struct
*	O
rl	pointer
;	O
struct	O
rcslock	struct
const	O
*	O
was	pointer
=	O
lock_on	function
(	O
delta	struct
)	O
;	O
if	O
(	O
was	pointer
)	O
{	O
if	O
(	O
caller_login_p	function
(	O
was	pointer
->	O
login	pointer
)	O
)	O
return	O
0	int
;	O
if	O
(	O
verbose	bool
)	O
RERR	O
(	O
"Revision %s is already locked by %s."	pointer
,	O
delta	struct
->	O
num	pointer
,	O
was	pointer
->	O
login	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
rl	pointer
=	O
FALLOC	O
(	O
struct	O
rcslock	struct
)	O
;	O
rl	pointer
->	O
login	pointer
=	O
delta	struct
->	O
lockedby	pointer
=	O
getcaller	function
(	O
)	O
;	O
rl	pointer
->	O
delta	struct
=	O
delta	struct
;	O
GROK	O
(	O
locks	pointer
)	O
=	O
prepend	function
(	O
rl	pointer
,	O
GROK	O
(	O
locks	pointer
)	O
,	O
SINGLE	O
)	O
;	O
return	O
1	int
;	O
}	O
