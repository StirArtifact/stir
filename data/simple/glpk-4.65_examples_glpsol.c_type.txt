struct	O
csa	struct
{	O
glp_prob	struct
*	O
prob	pointer
;	O
glp_bfcp	struct
bfcp	struct
;	O
glp_smcp	struct
smcp	struct
;	O
glp_iptcp	struct
iptcp	struct
;	O
glp_iocp	struct
iocp	struct
;	O
glp_tran	struct
*	O
tran	pointer
;	O
glp_graph	struct
*	O
graph	pointer
;	O
int	O
format	int
;	O
const	O
char	O
*	O
in_file	pointer
;	O
int	O
ndf	int
;	O
const	O
char	O
*	O
in_data	array
[	O
1	int
+	O
DATA_MAX	int
]	O
;	O
const	O
char	O
*	O
out_dpy	pointer
;	O
int	O
seed	int
;	O
int	O
solution	int
;	O
const	O
char	O
*	O
in_res	pointer
;	O
int	O
dir	int
;	O
int	O
scale	int
;	O
const	O
char	O
*	O
out_sol	pointer
;	O
const	O
char	O
*	O
out_res	pointer
;	O
const	O
char	O
*	O
out_ranges	pointer
;	O
int	O
check	int
;	O
const	O
char	O
*	O
new_name	pointer
;	O
int	O
hide	int
;	O
const	O
char	O
*	O
out_mps	pointer
;	O
const	O
char	O
*	O
out_freemps	pointer
;	O
const	O
char	O
*	O
out_cpxlp	pointer
;	O
const	O
char	O
*	O
out_glp	pointer
;	O
const	O
char	O
*	O
out_cnf	pointer
;	O
const	O
char	O
*	O
log_file	pointer
;	O
int	O
crash	int
;	O
const	O
char	O
*	O
ini_file	pointer
;	O
int	O
exact	int
;	O
int	O
xcheck	int
;	O
int	O
nomip	int
;	O
int	O
minisat	int
;	O
int	O
use_bnd	int
;	O
int	O
obj_bnd	int
;	O
const	O
char	O
*	O
use_sol	int
;	O
}	O
;	O
static	O
int	O
str2int	function
(	O
const	O
char	O
*	O
s	pointer
,	O
int	O
*	O
x	array
)	O
{	O
long	O
t	int
;	O
char	O
*	O
endptr	pointer
;	O
t	int
=	O
strtol	function
(	O
s	pointer
,	O
&	O
endptr	pointer
,	O
10	int
)	O
;	O
if	O
(	O
*	O
endptr	pointer
!=	O
'\0'	O
)	O
return	O
2	int
;	O
if	O
(	O
!	O
(	O
INT_MIN	O
<=	O
t	int
&&	O
t	int
<=	O
INT_MAX	O
)	O
)	O
return	O
1	int
;	O
*	O
x	array
=	O
t	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
str2num	function
(	O
const	O
char	O
*	O
s	pointer
,	O
double	O
*	O
x	array
)	O
{	O
double	O
t	int
;	O
char	O
*	O
endptr	pointer
;	O
t	int
=	O
strtod	function
(	O
s	pointer
,	O
&	O
endptr	pointer
)	O
;	O
if	O
(	O
*	O
endptr	pointer
!=	O
'\0'	O
)	O
return	O
2	int
;	O
if	O
(	O
!	O
(	O
-	O
DBL_MAX	O
<=	O
t	int
&&	O
t	int
<=	O
+	O
DBL_MAX	O
)	O
)	O
return	O
1	int
;	O
*	O
x	array
=	O
t	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
print_help	function
(	O
const	O
char	O
*	O
my_name	pointer
)	O
{	O
xprintf	O
(	O
"Usage: %s [options...] filename\n"	pointer
,	O
my_name	pointer
)	O
;	O
xprintf	O
(	O
"\n"	pointer
)	O
;	O
xprintf	O
(	O
"General options:\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --mps             read LP/MIP problem in fixed MPS fo"	pointer
"rmat\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --freemps         read LP/MIP problem in free MPS for"	pointer
"mat (default)\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --lp              read LP/MIP problem in CPLEX LP for"	pointer
"mat\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --glp             read LP/MIP problem in GLPK format "	pointer
"\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --math            read LP/MIP model written in GNU Ma"	pointer
"thProg modeling\n"	pointer
)	O
;	O
xprintf	O
(	O
"                     language\n"	pointer
)	O
;	O
xprintf	O
(	O
"   -m filename, --model filename\n"	pointer
)	O
;	O
xprintf	O
(	O
"                     read model section and optional dat"	pointer
"a section from\n"	pointer
)	O
;	O
xprintf	O
(	O
"                     filename (same as --math)\n"	pointer
)	O
;	O
xprintf	O
(	O
"   -d filename, --data filename\n"	pointer
)	O
;	O
xprintf	O
(	O
"                     read data section from filename (fo"	pointer
"r --math only);\n"	pointer
)	O
;	O
xprintf	O
(	O
"                     if model file also has data section"	pointer
", it is ignored\n"	pointer
)	O
;	O
xprintf	O
(	O
"   -y filename, --display filename\n"	pointer
)	O
;	O
xprintf	O
(	O
"                     send display output to filename (fo"	pointer
"r --math only);\n"	pointer
)	O
;	O
xprintf	O
(	O
"                     by default the output is sent to te"	pointer
"rminal\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --seed value      initialize pseudo-random number gen"	pointer
"erator used in\n"	pointer
)	O
;	O
xprintf	O
(	O
"                     MathProg model with specified seed "	pointer
"(any integer);\n"	pointer
)	O
;	O
xprintf	O
(	O
"                     if seed value is ?, some random see"	pointer
"d will be used\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --mincost         read min-cost flow problem in DIMAC"	pointer
"S format\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --maxflow         read maximum flow problem in DIMACS"	pointer
" format\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --cnf             read CNF-SAT problem in DIMACS form"	pointer
"at\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --simplex         use simplex method (default)\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --interior        use interior point method (LP only)"	pointer
"\n"	pointer
)	O
;	O
xprintf	O
(	O
"   -r filename, --read filename\n"	pointer
)	O
;	O
xprintf	O
(	O
"                     read solution from filename rather "	pointer
"to find it with\n"	pointer
)	O
;	O
xprintf	O
(	O
"                     the solver\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --min             minimization\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --max             maximization\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --scale           scale problem (default)\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --noscale         do not scale problem\n"	pointer
)	O
;	O
xprintf	O
(	O
"   -o filename, --output filename\n"	pointer
)	O
;	O
xprintf	O
(	O
"                     write solution to filename in print"	pointer
"able format\n"	pointer
)	O
;	O
xprintf	O
(	O
"   -w filename, --write filename\n"	pointer
)	O
;	O
xprintf	O
(	O
"                     write solution to filename in plain"	pointer
" text format\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --ranges filename\n"	pointer
)	O
;	O
xprintf	O
(	O
"                     write sensitivity analysis report t"	pointer
"o filename in\n"	pointer
)	O
;	O
xprintf	O
(	O
"                     printable format (simplex only)\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --tmlim nnn       limit solution time to nnn seconds "	pointer
"\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --memlim nnn      limit available memory to nnn megab"	pointer
"ytes\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --check           do not solve problem, check input d"	pointer
"ata only\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --name probname   change problem name to probname\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --hide            remove all symbolic names from prob"	pointer
"lem object\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --wmps filename   write problem to filename in fixed "	pointer
"MPS format\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --wfreemps filename\n"	pointer
)	O
;	O
xprintf	O
(	O
"                     write problem to filename in free M"	pointer
"PS format\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --wlp filename    write problem to filename in CPLEX "	pointer
"LP format\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --wglp filename   write problem to filename in GLPK f"	pointer
"ormat\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --wcnf filename   write problem to filename in DIMACS"	pointer
" CNF-SAT format\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --log filename    write copy of terminal output to fi"	pointer
"lename\n"	pointer
)	O
;	O
xprintf	O
(	O
"   -h, --help        display this help information and e"	pointer
"xit\n"	pointer
)	O
;	O
xprintf	O
(	O
"   -v, --version     display program version and exit\n"	pointer
)	O
;	O
xprintf	O
(	O
"\n"	pointer
)	O
;	O
xprintf	O
(	O
"LP basis factorization options:\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --luf             plain LU-factorization (default)\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --btf             block triangular LU-factorization\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --ft              Forrest-Tomlin update (requires --l"	pointer
"uf; default)\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --cbg             Schur complement + Bartels-Golub up"	pointer
"date\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --cgr             Schur complement + Givens rotation "	pointer
"update\n"	pointer
)	O
;	O
xprintf	O
(	O
"\n"	pointer
)	O
;	O
xprintf	O
(	O
"Options specific to simplex solver:\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --primal          use primal simplex (default)\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --dual            use dual simplex\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --std             use standard initial basis of all s"	pointer
"lacks\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --adv             use advanced initial basis (default"	pointer
")\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --bib             use Bixby's initial basis\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --ini filename    use as initial basis previously sav"	pointer
"ed with -w\n"	pointer
)	O
;	O
xprintf	O
(	O
"                     (disables LP presolver)\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --steep           use steepest edge technique (defaul"	pointer
"t)\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --nosteep         use standard \"textbook\" pricing\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --relax           use Harris' two-pass ratio test (de"	pointer
"fault)\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --norelax         use standard \"textbook\" ratio tes"	pointer
"t\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --flip            use long-step ratio test\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --presol          use presolver (default; assumes --s"	pointer
"cale and --adv)\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --nopresol        do not use presolver\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --exact           use simplex method based on exact a"	pointer
"rithmetic\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --xcheck          check final basis using exact arith"	pointer
"metic\n"	pointer
)	O
;	O
xprintf	O
(	O
"\n"	pointer
)	O
;	O
xprintf	O
(	O
"Options specific to interior-point solver:\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --nord            use natural (original) ordering\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --qmd             use quotient minimum degree orderin"	pointer
"g\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --amd             use approximate minimum degree orde"	pointer
"ring (default)\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --symamd          use approximate minimum degree orde"	pointer
"ring\n"	pointer
)	O
;	O
xprintf	O
(	O
"\n"	pointer
)	O
;	O
xprintf	O
(	O
"Options specific to MIP solver:\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --nomip           consider all integer variables as c"	pointer
"ontinuous\n"	pointer
)	O
;	O
xprintf	O
(	O
"                     (allows solving MIP as pure LP)\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --first           branch on first integer variable\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --last            branch on last integer variable\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --mostf           branch on most fractional variable "	pointer
"\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --drtom           branch using heuristic by Driebeck "	pointer
"and Tomlin\n"	pointer
)	O
;	O
xprintf	O
(	O
"                     (default)\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --pcost           branch using hybrid pseudocost heur"	pointer
"istic (may be\n"	pointer
)	O
;	O
xprintf	O
(	O
"                     useful for hard instances)\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --dfs             backtrack using depth first search "	pointer
"\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --bfs             backtrack using breadth first searc"	pointer
"h\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --bestp           backtrack using the best projection"	pointer
" heuristic\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --bestb           backtrack using node with best loca"	pointer
"l bound\n"	pointer
)	O
;	O
xprintf	O
(	O
"                     (default)\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --intopt          use MIP presolver (default)\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --nointopt        do not use MIP presolver\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --binarize        replace general integer variables b"	pointer
"y binary ones\n"	pointer
)	O
;	O
xprintf	O
(	O
"                     (assumes --intopt)\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --fpump           apply feasibility pump heuristic\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --proxy [nnn]     apply proximity search heuristic (n"	pointer
"nn is time limit\n"	pointer
)	O
;	O
xprintf	O
(	O
"                     in seconds; default is 60)\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --gomory          generate Gomory's mixed integer cut"	pointer
"s\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --mir             generate MIR (mixed integer roundin"	pointer
"g) cuts\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --cover           generate mixed cover cuts\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --clique          generate clique cuts\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --cuts            generate all cuts above\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --mipgap tol      set relative mip gap tolerance to t"	pointer
"ol\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --minisat         translate integer feasibility probl"	pointer
"em to CNF-SAT\n"	pointer
)	O
;	O
xprintf	O
(	O
"                     and solve it with MiniSat solver\n"	pointer
)	O
;	O
xprintf	O
(	O
"   --objbnd bound    add inequality obj <= bound (minimi"	pointer
"zation) or\n"	pointer
)	O
;	O
xprintf	O
(	O
"                     obj >= bound (maximization) to inte"	pointer
"ger feasibility\n"	pointer
)	O
;	O
xprintf	O
(	O
"                     problem (assumes --minisat)\n"	pointer
)	O
;	O
xprintf	O
(	O
"\n"	pointer
)	O
;	O
xprintf	O
(	O
"For description of the MPS and CPLEX LP formats see Refe"	pointer
"rence Manual.\n"	pointer
)	O
;	O
xprintf	O
(	O
"For description of the modeling language see \"GLPK: Mod"	pointer
"eling Language\n"	pointer
)	O
;	O
xprintf	O
(	O
"GNU MathProg\". Both documents are included in the GLPK "	pointer
"distribution.\n"	pointer
)	O
;	O
xprintf	O
(	O
"\n"	pointer
)	O
;	O
xprintf	O
(	O
"See GLPK web page at <http://www.gnu.org/software/glpk/g"	pointer
"lpk.html>.\n"	pointer
)	O
;	O
xprintf	O
(	O
"\n"	pointer
)	O
;	O
xprintf	O
(	O
"Please report bugs to <bug-glpk@gnu.org>.\n"	pointer
)	O
;	O
return	O
;	O
}	O
static	O
void	O
print_version	function
(	O
int	O
briefly	int
)	O
{	O
xprintf	O
(	O
"GLPSOL: GLPK LP/MIP Solver, v%s\n"	pointer
,	O
glp_version	function
(	O
)	O
)	O
;	O
if	O
(	O
briefly	int
)	O
goto	O
done	O
;	O
xprintf	O
(	O
"Copyright (C) 2000-2017 Andrew Makhorin, Department for "	pointer
"Applied\n"	pointer
)	O
;	O
xprintf	O
(	O
"Informatics, Moscow Aviation Institute, Moscow, Russia. "	pointer
"All rights\n"	pointer
)	O
;	O
xprintf	O
(	O
"reserved. E-mail: <mao@gnu.org>.\n"	pointer
)	O
;	O
xprintf	O
(	O
"\n"	pointer
)	O
;	O
xprintf	O
(	O
"This program has ABSOLUTELY NO WARRANTY.\n"	pointer
)	O
;	O
xprintf	O
(	O
"\n"	pointer
)	O
;	O
xprintf	O
(	O
"This program is free software; you may re-distribute it "	pointer
"under the terms\n"	pointer
)	O
;	O
xprintf	O
(	O
"of the GNU General Public License version 3 or later.\n"	pointer
)	O
;	O
done	O
:	O
return	O
;	O
}	O
static	O
int	O
parse_cmdline	function
(	O
struct	O
csa	struct
*	O
csa	struct
,	O
int	O
argc	int
,	O
char	O
*	O
argv	array
[	O
]	O
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<	O
argc	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
p	int
(	O
"--mps"	pointer
)	O
)	O
csa	struct
->	O
format	int
=	O
FMT_MPS_DECK	int
;	O
else	O
if	O
(	O
p	int
(	O
"--freemps"	pointer
)	O
)	O
csa	struct
->	O
format	int
=	O
FMT_MPS_FILE	int
;	O
else	O
if	O
(	O
p	int
(	O
"--lp"	pointer
)	O
||	O
p	int
(	O
"--cpxlp"	pointer
)	O
)	O
csa	struct
->	O
format	int
=	O
FMT_LP	int
;	O
else	O
if	O
(	O
p	int
(	O
"--glp"	pointer
)	O
)	O
csa	struct
->	O
format	int
=	O
FMT_GLP	int
;	O
else	O
if	O
(	O
p	int
(	O
"--math"	pointer
)	O
||	O
p	int
(	O
"-m"	pointer
)	O
||	O
p	int
(	O
"--model"	pointer
)	O
)	O
csa	struct
->	O
format	int
=	O
FMT_MATHPROG	int
;	O
else	O
if	O
(	O
p	int
(	O
"-d"	pointer
)	O
||	O
p	int
(	O
"--data"	pointer
)	O
)	O
{	O
k	int
++	O
;	O
if	O
(	O
k	int
==	O
argc	int
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'\0'	O
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
xprintf	O
(	O
"No input data file specified\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
csa	struct
->	O
ndf	int
==	O
DATA_MAX	int
)	O
{	O
xprintf	O
(	O
"Too many input data files\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
csa	struct
->	O
in_data	array
[	O
++	O
(	O
csa	struct
->	O
ndf	int
)	O
]	O
=	O
argv	array
[	O
k	int
]	O
;	O
}	O
else	O
if	O
(	O
p	int
(	O
"-y"	pointer
)	O
||	O
p	int
(	O
"--display"	pointer
)	O
)	O
{	O
k	int
++	O
;	O
if	O
(	O
k	int
==	O
argc	int
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'\0'	O
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
xprintf	O
(	O
"No display output file specified\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
csa	struct
->	O
out_dpy	pointer
!=	O
NULL	O
)	O
{	O
xprintf	O
(	O
"Only one display output file allowed\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
csa	struct
->	O
out_dpy	pointer
=	O
argv	array
[	O
k	int
]	O
;	O
}	O
else	O
if	O
(	O
p	int
(	O
"--seed"	pointer
)	O
)	O
{	O
k	int
++	O
;	O
if	O
(	O
k	int
==	O
argc	int
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'\0'	O
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'-'	O
&&	O
!	O
isdigit	function
(	O
(	O
unsigned	O
char	O
)	O
argv	array
[	O
k	int
]	O
[	O
1	int
]	O
)	O
)	O
{	O
xprintf	O
(	O
"No seed value specified\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
strcmp	function
(	O
argv	array
[	O
k	int
]	O
,	O
"?"	pointer
)	O
==	O
0	int
)	O
csa	struct
->	O
seed	int
=	O
0x80000000	int
;	O
else	O
if	O
(	O
str2int	function
(	O
argv	array
[	O
k	int
]	O
,	O
&	O
csa	struct
->	O
seed	int
)	O
)	O
{	O
xprintf	O
(	O
"Invalid seed value '%s'\n"	pointer
,	O
argv	array
[	O
k	int
]	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
p	int
(	O
"--mincost"	pointer
)	O
)	O
csa	struct
->	O
format	int
=	O
FMT_MIN_COST	int
;	O
else	O
if	O
(	O
p	int
(	O
"--maxflow"	pointer
)	O
)	O
csa	struct
->	O
format	int
=	O
FMT_MAX_FLOW	int
;	O
else	O
if	O
(	O
p	int
(	O
"--cnf"	pointer
)	O
)	O
csa	struct
->	O
format	int
=	O
FMT_CNF	int
;	O
else	O
if	O
(	O
p	int
(	O
"--simplex"	pointer
)	O
)	O
csa	struct
->	O
solution	int
=	O
SOL_BASIC	int
;	O
else	O
if	O
(	O
p	int
(	O
"--interior"	pointer
)	O
)	O
csa	struct
->	O
solution	int
=	O
SOL_INTERIOR	int
;	O
else	O
if	O
(	O
p	int
(	O
"--alien"	pointer
)	O
)	O
csa	struct
->	O
iocp	struct
.	O
alien	int
=	O
GLP_ON	int
;	O
else	O
if	O
(	O
p	int
(	O
"-r"	pointer
)	O
||	O
p	int
(	O
"--read"	pointer
)	O
)	O
{	O
k	int
++	O
;	O
if	O
(	O
k	int
==	O
argc	int
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'\0'	O
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
xprintf	O
(	O
"No input solution file specified\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
csa	struct
->	O
in_res	pointer
!=	O
NULL	O
)	O
{	O
xprintf	O
(	O
"Only one input solution file allowed\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
csa	struct
->	O
in_res	pointer
=	O
argv	array
[	O
k	int
]	O
;	O
}	O
else	O
if	O
(	O
p	int
(	O
"--min"	pointer
)	O
)	O
csa	struct
->	O
dir	int
=	O
GLP_MIN	int
;	O
else	O
if	O
(	O
p	int
(	O
"--max"	pointer
)	O
)	O
csa	struct
->	O
dir	int
=	O
GLP_MAX	int
;	O
else	O
if	O
(	O
p	int
(	O
"--scale"	pointer
)	O
)	O
csa	struct
->	O
scale	int
=	O
1	int
;	O
else	O
if	O
(	O
p	int
(	O
"--noscale"	pointer
)	O
)	O
csa	struct
->	O
scale	int
=	O
0	int
;	O
else	O
if	O
(	O
p	int
(	O
"-o"	pointer
)	O
||	O
p	int
(	O
"--output"	pointer
)	O
)	O
{	O
k	int
++	O
;	O
if	O
(	O
k	int
==	O
argc	int
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'\0'	O
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
xprintf	O
(	O
"No output solution file specified\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
csa	struct
->	O
out_sol	pointer
!=	O
NULL	O
)	O
{	O
xprintf	O
(	O
"Only one output solution file allowed\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
csa	struct
->	O
out_sol	pointer
=	O
argv	array
[	O
k	int
]	O
;	O
}	O
else	O
if	O
(	O
p	int
(	O
"-w"	pointer
)	O
||	O
p	int
(	O
"--write"	pointer
)	O
)	O
{	O
k	int
++	O
;	O
if	O
(	O
k	int
==	O
argc	int
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'\0'	O
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
xprintf	O
(	O
"No output solution file specified\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
csa	struct
->	O
out_res	pointer
!=	O
NULL	O
)	O
{	O
xprintf	O
(	O
"Only one output solution file allowed\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
csa	struct
->	O
out_res	pointer
=	O
argv	array
[	O
k	int
]	O
;	O
}	O
else	O
if	O
(	O
p	int
(	O
"--ranges"	pointer
)	O
||	O
p	int
(	O
"--bounds"	pointer
)	O
)	O
{	O
k	int
++	O
;	O
if	O
(	O
k	int
==	O
argc	int
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'\0'	O
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
xprintf	O
(	O
"No output file specified to write sensitivity a"	pointer
"nalysis report\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
csa	struct
->	O
out_ranges	pointer
!=	O
NULL	O
)	O
{	O
xprintf	O
(	O
"Only one output file allowed to write sensitivi"	pointer
"ty analysis report\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
csa	struct
->	O
out_ranges	pointer
=	O
argv	array
[	O
k	int
]	O
;	O
}	O
else	O
if	O
(	O
p	int
(	O
"--tmlim"	pointer
)	O
)	O
{	O
int	O
tm_lim	int
;	O
k	int
++	O
;	O
if	O
(	O
k	int
==	O
argc	int
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'\0'	O
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
xprintf	O
(	O
"No time limit specified\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
str2int	function
(	O
argv	array
[	O
k	int
]	O
,	O
&	O
tm_lim	int
)	O
||	O
tm_lim	int
<	O
0	int
)	O
{	O
xprintf	O
(	O
"Invalid time limit '%s'\n"	pointer
,	O
argv	array
[	O
k	int
]	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
tm_lim	int
<=	O
INT_MAX	O
/	O
1000	int
)	O
csa	struct
->	O
smcp	struct
.	O
tm_lim	int
=	O
csa	struct
->	O
iocp	struct
.	O
tm_lim	int
=	O
1000	int
*	O
tm_lim	int
;	O
else	O
csa	struct
->	O
smcp	struct
.	O
tm_lim	int
=	O
csa	struct
->	O
iocp	struct
.	O
tm_lim	int
=	O
INT_MAX	O
;	O
}	O
else	O
if	O
(	O
p	int
(	O
"--memlim"	pointer
)	O
)	O
{	O
int	O
mem_lim	int
;	O
k	int
++	O
;	O
if	O
(	O
k	int
==	O
argc	int
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'\0'	O
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
xprintf	O
(	O
"No memory limit specified\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
str2int	function
(	O
argv	array
[	O
k	int
]	O
,	O
&	O
mem_lim	int
)	O
||	O
mem_lim	int
<	O
1	int
)	O
{	O
xprintf	O
(	O
"Invalid memory limit '%s'\n"	pointer
,	O
argv	array
[	O
k	int
]	O
)	O
;	O
return	O
1	int
;	O
}	O
glp_mem_limit	function
(	O
mem_lim	int
)	O
;	O
}	O
else	O
if	O
(	O
p	int
(	O
"--check"	pointer
)	O
)	O
csa	struct
->	O
check	int
=	O
1	int
;	O
else	O
if	O
(	O
p	int
(	O
"--name"	pointer
)	O
)	O
{	O
k	int
++	O
;	O
if	O
(	O
k	int
==	O
argc	int
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'\0'	O
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
xprintf	O
(	O
"No problem name specified\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
csa	struct
->	O
new_name	pointer
!=	O
NULL	O
)	O
{	O
xprintf	O
(	O
"Only one problem name allowed\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
csa	struct
->	O
new_name	pointer
=	O
argv	array
[	O
k	int
]	O
;	O
}	O
else	O
if	O
(	O
p	int
(	O
"--hide"	pointer
)	O
)	O
csa	struct
->	O
hide	int
=	O
1	int
;	O
else	O
if	O
(	O
p	int
(	O
"--wmps"	pointer
)	O
)	O
{	O
k	int
++	O
;	O
if	O
(	O
k	int
==	O
argc	int
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'\0'	O
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
xprintf	O
(	O
"No fixed MPS output file specified\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
csa	struct
->	O
out_mps	pointer
!=	O
NULL	O
)	O
{	O
xprintf	O
(	O
"Only one fixed MPS output file allowed\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
csa	struct
->	O
out_mps	pointer
=	O
argv	array
[	O
k	int
]	O
;	O
}	O
else	O
if	O
(	O
p	int
(	O
"--wfreemps"	pointer
)	O
)	O
{	O
k	int
++	O
;	O
if	O
(	O
k	int
==	O
argc	int
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'\0'	O
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
xprintf	O
(	O
"No free MPS output file specified\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
csa	struct
->	O
out_freemps	pointer
!=	O
NULL	O
)	O
{	O
xprintf	O
(	O
"Only one free MPS output file allowed\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
csa	struct
->	O
out_freemps	pointer
=	O
argv	array
[	O
k	int
]	O
;	O
}	O
else	O
if	O
(	O
p	int
(	O
"--wlp"	pointer
)	O
||	O
p	int
(	O
"--wcpxlp"	pointer
)	O
||	O
p	int
(	O
"--wlpt"	pointer
)	O
)	O
{	O
k	int
++	O
;	O
if	O
(	O
k	int
==	O
argc	int
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'\0'	O
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
xprintf	O
(	O
"No CPLEX LP output file specified\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
csa	struct
->	O
out_cpxlp	pointer
!=	O
NULL	O
)	O
{	O
xprintf	O
(	O
"Only one CPLEX LP output file allowed\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
csa	struct
->	O
out_cpxlp	pointer
=	O
argv	array
[	O
k	int
]	O
;	O
}	O
else	O
if	O
(	O
p	int
(	O
"--wglp"	pointer
)	O
)	O
{	O
k	int
++	O
;	O
if	O
(	O
k	int
==	O
argc	int
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'\0'	O
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
xprintf	O
(	O
"No GLPK LP/MIP output file specified\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
csa	struct
->	O
out_glp	pointer
!=	O
NULL	O
)	O
{	O
xprintf	O
(	O
"Only one GLPK LP/MIP output file allowed\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
csa	struct
->	O
out_glp	pointer
=	O
argv	array
[	O
k	int
]	O
;	O
}	O
else	O
if	O
(	O
p	int
(	O
"--wcnf"	pointer
)	O
)	O
{	O
k	int
++	O
;	O
if	O
(	O
k	int
==	O
argc	int
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'\0'	O
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
xprintf	O
(	O
"No problem output file specified\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
csa	struct
->	O
out_cnf	pointer
!=	O
NULL	O
)	O
{	O
xprintf	O
(	O
"Only one output DIMACS CNF-SAT file allowed\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
csa	struct
->	O
out_cnf	pointer
=	O
argv	array
[	O
k	int
]	O
;	O
}	O
else	O
if	O
(	O
p	int
(	O
"--log"	pointer
)	O
)	O
{	O
k	int
++	O
;	O
if	O
(	O
k	int
==	O
argc	int
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'\0'	O
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
xprintf	O
(	O
"No log file specified\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
csa	struct
->	O
log_file	pointer
!=	O
NULL	O
)	O
{	O
xprintf	O
(	O
"Only one log file allowed\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
csa	struct
->	O
log_file	pointer
=	O
argv	array
[	O
k	int
]	O
;	O
}	O
else	O
if	O
(	O
p	int
(	O
"-h"	pointer
)	O
||	O
p	int
(	O
"--help"	pointer
)	O
)	O
{	O
print_help	function
(	O
argv	array
[	O
0	int
]	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
p	int
(	O
"-v"	pointer
)	O
||	O
p	int
(	O
"--version"	pointer
)	O
)	O
{	O
print_version	function
(	O
0	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
p	int
(	O
"--luf"	pointer
)	O
)	O
{	O
csa	struct
->	O
bfcp	struct
.	O
type	int
&=	O
0x0F	int
;	O
csa	struct
->	O
bfcp	struct
.	O
type	int
|=	O
GLP_BF_LUF	int
;	O
}	O
else	O
if	O
(	O
p	int
(	O
"--btf"	pointer
)	O
)	O
{	O
csa	struct
->	O
bfcp	struct
.	O
type	int
&=	O
0x0F	int
;	O
csa	struct
->	O
bfcp	struct
.	O
type	int
|=	O
GLP_BF_BTF	int
;	O
}	O
else	O
if	O
(	O
p	int
(	O
"--ft"	pointer
)	O
)	O
{	O
csa	struct
->	O
bfcp	struct
.	O
type	int
&=	O
0xF0	int
;	O
csa	struct
->	O
bfcp	struct
.	O
type	int
|=	O
GLP_BF_FT	int
;	O
}	O
else	O
if	O
(	O
p	int
(	O
"--cbg"	pointer
)	O
)	O
{	O
csa	struct
->	O
bfcp	struct
.	O
type	int
&=	O
0xF0	int
;	O
csa	struct
->	O
bfcp	struct
.	O
type	int
|=	O
GLP_BF_BG	int
;	O
}	O
else	O
if	O
(	O
p	int
(	O
"--cgr"	pointer
)	O
)	O
{	O
csa	struct
->	O
bfcp	struct
.	O
type	int
&=	O
0xF0	int
;	O
csa	struct
->	O
bfcp	struct
.	O
type	int
|=	O
GLP_BF_GR	int
;	O
}	O
else	O
if	O
(	O
p	int
(	O
"--primal"	pointer
)	O
)	O
csa	struct
->	O
smcp	struct
.	O
meth	int
=	O
GLP_PRIMAL	int
;	O
else	O
if	O
(	O
p	int
(	O
"--dual"	pointer
)	O
)	O
csa	struct
->	O
smcp	struct
.	O
meth	int
=	O
GLP_DUAL	int
;	O
else	O
if	O
(	O
p	int
(	O
"--std"	pointer
)	O
)	O
csa	struct
->	O
crash	int
=	O
USE_STD_BASIS	int
;	O
else	O
if	O
(	O
p	int
(	O
"--adv"	pointer
)	O
)	O
csa	struct
->	O
crash	int
=	O
USE_ADV_BASIS	int
;	O
else	O
if	O
(	O
p	int
(	O
"--bib"	pointer
)	O
)	O
csa	struct
->	O
crash	int
=	O
USE_CPX_BASIS	int
;	O
else	O
if	O
(	O
p	int
(	O
"--ini"	pointer
)	O
)	O
{	O
csa	struct
->	O
crash	int
=	O
USE_INI_BASIS	int
;	O
csa	struct
->	O
smcp	struct
.	O
presolve	int
=	O
GLP_OFF	int
;	O
k	int
++	O
;	O
if	O
(	O
k	int
==	O
argc	int
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'\0'	O
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
xprintf	O
(	O
"No initial basis file specified\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
csa	struct
->	O
ini_file	pointer
!=	O
NULL	O
)	O
{	O
xprintf	O
(	O
"Only one initial basis file allowed\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
csa	struct
->	O
ini_file	pointer
=	O
argv	array
[	O
k	int
]	O
;	O
}	O
else	O
if	O
(	O
p	int
(	O
"--steep"	pointer
)	O
)	O
csa	struct
->	O
smcp	struct
.	O
pricing	int
=	O
GLP_PT_PSE	int
;	O
else	O
if	O
(	O
p	int
(	O
"--nosteep"	pointer
)	O
)	O
csa	struct
->	O
smcp	struct
.	O
pricing	int
=	O
GLP_PT_STD	int
;	O
else	O
if	O
(	O
p	int
(	O
"--relax"	pointer
)	O
)	O
csa	struct
->	O
smcp	struct
.	O
r_test	int
=	O
GLP_RT_HAR	int
;	O
else	O
if	O
(	O
p	int
(	O
"--norelax"	pointer
)	O
)	O
csa	struct
->	O
smcp	struct
.	O
r_test	int
=	O
GLP_RT_STD	int
;	O
else	O
if	O
(	O
p	int
(	O
"--flip"	pointer
)	O
)	O
{	O
csa	struct
->	O
smcp	struct
.	O
r_test	int
=	O
GLP_RT_FLIP	int
;	O
csa	struct
->	O
iocp	struct
.	O
flip	int
=	O
GLP_ON	int
;	O
}	O
else	O
if	O
(	O
p	int
(	O
"--presol"	pointer
)	O
)	O
csa	struct
->	O
smcp	struct
.	O
presolve	int
=	O
GLP_ON	int
;	O
else	O
if	O
(	O
p	int
(	O
"--nopresol"	pointer
)	O
)	O
csa	struct
->	O
smcp	struct
.	O
presolve	int
=	O
GLP_OFF	int
;	O
else	O
if	O
(	O
p	int
(	O
"--exact"	pointer
)	O
)	O
csa	struct
->	O
exact	int
=	O
1	int
;	O
else	O
if	O
(	O
p	int
(	O
"--xcheck"	pointer
)	O
)	O
csa	struct
->	O
xcheck	int
=	O
1	int
;	O
else	O
if	O
(	O
p	int
(	O
"--nord"	pointer
)	O
)	O
csa	struct
->	O
iptcp	struct
.	O
ord_alg	int
=	O
GLP_ORD_NONE	int
;	O
else	O
if	O
(	O
p	int
(	O
"--qmd"	pointer
)	O
)	O
csa	struct
->	O
iptcp	struct
.	O
ord_alg	int
=	O
GLP_ORD_QMD	int
;	O
else	O
if	O
(	O
p	int
(	O
"--amd"	pointer
)	O
)	O
csa	struct
->	O
iptcp	struct
.	O
ord_alg	int
=	O
GLP_ORD_AMD	int
;	O
else	O
if	O
(	O
p	int
(	O
"--symamd"	pointer
)	O
)	O
csa	struct
->	O
iptcp	struct
.	O
ord_alg	int
=	O
GLP_ORD_SYMAMD	int
;	O
else	O
if	O
(	O
p	int
(	O
"--nomip"	pointer
)	O
)	O
csa	struct
->	O
nomip	int
=	O
1	int
;	O
else	O
if	O
(	O
p	int
(	O
"--first"	pointer
)	O
)	O
csa	struct
->	O
iocp	struct
.	O
br_tech	int
=	O
GLP_BR_FFV	int
;	O
else	O
if	O
(	O
p	int
(	O
"--last"	pointer
)	O
)	O
csa	struct
->	O
iocp	struct
.	O
br_tech	int
=	O
GLP_BR_LFV	int
;	O
else	O
if	O
(	O
p	int
(	O
"--drtom"	pointer
)	O
)	O
csa	struct
->	O
iocp	struct
.	O
br_tech	int
=	O
GLP_BR_DTH	int
;	O
else	O
if	O
(	O
p	int
(	O
"--mostf"	pointer
)	O
)	O
csa	struct
->	O
iocp	struct
.	O
br_tech	int
=	O
GLP_BR_MFV	int
;	O
else	O
if	O
(	O
p	int
(	O
"--pcost"	pointer
)	O
)	O
csa	struct
->	O
iocp	struct
.	O
br_tech	int
=	O
GLP_BR_PCH	int
;	O
else	O
if	O
(	O
p	int
(	O
"--dfs"	pointer
)	O
)	O
csa	struct
->	O
iocp	struct
.	O
bt_tech	int
=	O
GLP_BT_DFS	int
;	O
else	O
if	O
(	O
p	int
(	O
"--bfs"	pointer
)	O
)	O
csa	struct
->	O
iocp	struct
.	O
bt_tech	int
=	O
GLP_BT_BFS	int
;	O
else	O
if	O
(	O
p	int
(	O
"--bestp"	pointer
)	O
)	O
csa	struct
->	O
iocp	struct
.	O
bt_tech	int
=	O
GLP_BT_BPH	int
;	O
else	O
if	O
(	O
p	int
(	O
"--bestb"	pointer
)	O
)	O
csa	struct
->	O
iocp	struct
.	O
bt_tech	int
=	O
GLP_BT_BLB	int
;	O
else	O
if	O
(	O
p	int
(	O
"--intopt"	pointer
)	O
)	O
csa	struct
->	O
iocp	struct
.	O
presolve	int
=	O
GLP_ON	int
;	O
else	O
if	O
(	O
p	int
(	O
"--nointopt"	pointer
)	O
)	O
csa	struct
->	O
iocp	struct
.	O
presolve	int
=	O
GLP_OFF	int
;	O
else	O
if	O
(	O
p	int
(	O
"--binarize"	pointer
)	O
)	O
csa	struct
->	O
iocp	struct
.	O
presolve	int
=	O
csa	struct
->	O
iocp	struct
.	O
binarize	int
=	O
GLP_ON	int
;	O
else	O
if	O
(	O
p	int
(	O
"--fpump"	pointer
)	O
)	O
csa	struct
->	O
iocp	struct
.	O
fp_heur	int
=	O
GLP_ON	int
;	O
else	O
if	O
(	O
p	int
(	O
"--proxy"	pointer
)	O
)	O
{	O
csa	struct
->	O
iocp	struct
.	O
ps_heur	int
=	O
GLP_ON	int
;	O
if	O
(	O
argv	array
[	O
k	int
+	O
1	int
]	O
&&	O
isdigit	function
(	O
(	O
unsigned	O
char	O
)	O
argv	array
[	O
k	int
+	O
1	int
]	O
[	O
0	int
]	O
)	O
)	O
{	O
int	O
nnn	int
;	O
k	int
++	O
;	O
if	O
(	O
str2int	function
(	O
argv	array
[	O
k	int
]	O
,	O
&	O
nnn	int
)	O
||	O
nnn	int
<	O
1	int
)	O
{	O
xprintf	O
(	O
"Invalid proxy time limit '%s'\n"	pointer
,	O
argv	array
[	O
k	int
]	O
)	O
;	O
return	O
1	int
;	O
}	O
csa	struct
->	O
iocp	struct
.	O
ps_tm_lim	int
=	O
1000	int
*	O
nnn	int
;	O
}	O
}	O
else	O
if	O
(	O
p	int
(	O
"--gomory"	pointer
)	O
)	O
csa	struct
->	O
iocp	struct
.	O
gmi_cuts	int
=	O
GLP_ON	int
;	O
else	O
if	O
(	O
p	int
(	O
"--mir"	pointer
)	O
)	O
csa	struct
->	O
iocp	struct
.	O
mir_cuts	int
=	O
GLP_ON	int
;	O
else	O
if	O
(	O
p	int
(	O
"--cover"	pointer
)	O
)	O
csa	struct
->	O
iocp	struct
.	O
cov_cuts	int
=	O
GLP_ON	int
;	O
else	O
if	O
(	O
p	int
(	O
"--clique"	pointer
)	O
)	O
csa	struct
->	O
iocp	struct
.	O
clq_cuts	int
=	O
GLP_ON	int
;	O
else	O
if	O
(	O
p	int
(	O
"--cuts"	pointer
)	O
)	O
csa	struct
->	O
iocp	struct
.	O
gmi_cuts	int
=	O
csa	struct
->	O
iocp	struct
.	O
mir_cuts	int
=	O
csa	struct
->	O
iocp	struct
.	O
cov_cuts	int
=	O
csa	struct
->	O
iocp	struct
.	O
clq_cuts	int
=	O
GLP_ON	int
;	O
else	O
if	O
(	O
p	int
(	O
"--mipgap"	pointer
)	O
)	O
{	O
double	O
mip_gap	double
;	O
k	int
++	O
;	O
if	O
(	O
k	int
==	O
argc	int
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'\0'	O
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
xprintf	O
(	O
"No relative gap tolerance specified\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
str2num	function
(	O
argv	array
[	O
k	int
]	O
,	O
&	O
mip_gap	double
)	O
||	O
mip_gap	double
<	O
0.0	int
)	O
{	O
xprintf	O
(	O
"Invalid relative mip gap tolerance '%s'\n"	pointer
,	O
argv	array
[	O
k	int
]	O
)	O
;	O
return	O
1	int
;	O
}	O
csa	struct
->	O
iocp	struct
.	O
mip_gap	double
=	O
mip_gap	double
;	O
}	O
else	O
if	O
(	O
p	int
(	O
"--minisat"	pointer
)	O
)	O
csa	struct
->	O
minisat	int
=	O
1	int
;	O
else	O
if	O
(	O
p	int
(	O
"--objbnd"	pointer
)	O
)	O
{	O
k	int
++	O
;	O
if	O
(	O
k	int
==	O
argc	int
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'\0'	O
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'-'	O
&&	O
!	O
isdigit	function
(	O
(	O
unsigned	O
char	O
)	O
argv	array
[	O
k	int
]	O
[	O
1	int
]	O
)	O
)	O
{	O
xprintf	O
(	O
"No objective bound specified\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
csa	struct
->	O
minisat	int
=	O
1	int
;	O
csa	struct
->	O
use_bnd	int
=	O
1	int
;	O
if	O
(	O
str2int	function
(	O
argv	array
[	O
k	int
]	O
,	O
&	O
csa	struct
->	O
obj_bnd	int
)	O
)	O
{	O
xprintf	O
(	O
"Invalid objective bound '%s' (should be integer"	pointer
" value)\n"	pointer
,	O
argv	array
[	O
k	int
]	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
p	int
(	O
"--use"	pointer
)	O
)	O
{	O
k	int
++	O
;	O
if	O
(	O
k	int
==	O
argc	int
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'\0'	O
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
xprintf	O
(	O
"No input MIP solution file specified\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
csa	struct
->	O
use_sol	int
!=	O
NULL	O
)	O
{	O
xprintf	O
(	O
"Only one input MIP solution file allowed\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
csa	struct
->	O
use_sol	int
=	O
argv	array
[	O
k	int
]	O
;	O
}	O
else	O
if	O
(	O
p	int
(	O
"--save"	pointer
)	O
)	O
{	O
k	int
++	O
;	O
if	O
(	O
k	int
==	O
argc	int
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'\0'	O
||	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
xprintf	O
(	O
"No output MIP solution file specified\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
csa	struct
->	O
iocp	struct
.	O
save_sol	pointer
!=	O
NULL	O
)	O
{	O
xprintf	O
(	O
"Only one output MIP solution file allowed\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
csa	struct
->	O
iocp	struct
.	O
save_sol	pointer
=	O
argv	array
[	O
k	int
]	O
;	O
}	O
else	O
if	O
(	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'-'	O
||	O
(	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'-'	O
&&	O
argv	array
[	O
k	int
]	O
[	O
1	int
]	O
==	O
'-'	O
)	O
)	O
{	O
xprintf	O
(	O
"Invalid option '%s'; try %s --help\n"	pointer
,	O
argv	array
[	O
k	int
]	O
,	O
argv	array
[	O
0	int
]	O
)	O
;	O
return	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
csa	struct
->	O
in_file	pointer
!=	O
NULL	O
)	O
{	O
xprintf	O
(	O
"Only one input problem file allowed\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
csa	struct
->	O
in_file	pointer
=	O
argv	array
[	O
k	int
]	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
typedef	O
struct	O
{	O
double	O
rhs	double
,	O
pi	double
;	O
}	O
v_data	struct
;	O
typedef	O
struct	O
{	O
double	O
low	double
,	O
cap	double
,	O
cost	double
,	O
x	array
;	O
}	O
a_data	struct
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array
[	O
]	O
)	O
{	O
struct	O
csa	struct
_csa	struct
,	O
*	O
csa	struct
=	O
&	O
_csa	struct
;	O
int	O
ret	int
;	O
double	O
start	double
;	O
csa	struct
->	O
prob	pointer
=	O
glp_create_prob	function
(	O
)	O
;	O
glp_get_bfcp	function
(	O
csa	struct
->	O
prob	pointer
,	O
&	O
csa	struct
->	O
bfcp	struct
)	O
;	O
glp_init_smcp	function
(	O
&	O
csa	struct
->	O
smcp	struct
)	O
;	O
csa	struct
->	O
smcp	struct
.	O
presolve	int
=	O
GLP_ON	int
;	O
glp_init_iptcp	function
(	O
&	O
csa	struct
->	O
iptcp	struct
)	O
;	O
glp_init_iocp	function
(	O
&	O
csa	struct
->	O
iocp	struct
)	O
;	O
csa	struct
->	O
iocp	struct
.	O
presolve	int
=	O
GLP_ON	int
;	O
csa	struct
->	O
tran	pointer
=	O
NULL	O
;	O
csa	struct
->	O
graph	pointer
=	O
NULL	O
;	O
csa	struct
->	O
format	int
=	O
FMT_MPS_FILE	int
;	O
csa	struct
->	O
in_file	pointer
=	O
NULL	O
;	O
csa	struct
->	O
ndf	int
=	O
0	int
;	O
csa	struct
->	O
out_dpy	pointer
=	O
NULL	O
;	O
csa	struct
->	O
seed	int
=	O
1	int
;	O
csa	struct
->	O
solution	int
=	O
SOL_BASIC	int
;	O
csa	struct
->	O
in_res	pointer
=	O
NULL	O
;	O
csa	struct
->	O
dir	int
=	O
0	int
;	O
csa	struct
->	O
scale	int
=	O
1	int
;	O
csa	struct
->	O
out_sol	pointer
=	O
NULL	O
;	O
csa	struct
->	O
out_res	pointer
=	O
NULL	O
;	O
csa	struct
->	O
out_ranges	pointer
=	O
NULL	O
;	O
csa	struct
->	O
check	int
=	O
0	int
;	O
csa	struct
->	O
new_name	pointer
=	O
NULL	O
;	O
csa	struct
->	O
hide	int
=	O
0	int
;	O
csa	struct
->	O
out_mps	pointer
=	O
NULL	O
;	O
csa	struct
->	O
out_freemps	pointer
=	O
NULL	O
;	O
csa	struct
->	O
out_cpxlp	pointer
=	O
NULL	O
;	O
csa	struct
->	O
out_glp	pointer
=	O
NULL	O
;	O
csa	struct
->	O
out_cnf	pointer
=	O
NULL	O
;	O
csa	struct
->	O
log_file	pointer
=	O
NULL	O
;	O
csa	struct
->	O
crash	int
=	O
USE_ADV_BASIS	int
;	O
csa	struct
->	O
ini_file	pointer
=	O
NULL	O
;	O
csa	struct
->	O
exact	int
=	O
0	int
;	O
csa	struct
->	O
xcheck	int
=	O
0	int
;	O
csa	struct
->	O
nomip	int
=	O
0	int
;	O
csa	struct
->	O
minisat	int
=	O
0	int
;	O
csa	struct
->	O
use_bnd	int
=	O
0	int
;	O
csa	struct
->	O
obj_bnd	int
=	O
0	int
;	O
csa	struct
->	O
use_sol	int
=	O
NULL	O
;	O
ret	int
=	O
parse_cmdline	function
(	O
csa	struct
,	O
argc	int
,	O
argv	array
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
{	O
ret	int
=	O
EXIT_SUCCESS	int
;	O
goto	O
done	O
;	O
}	O
if	O
(	O
ret	int
>	O
0	int
)	O
{	O
ret	int
=	O
EXIT_FAILURE	int
;	O
goto	O
done	O
;	O
}	O
if	O
(	O
csa	struct
->	O
out_dpy	pointer
!=	O
NULL	O
)	O
remove	function
(	O
csa	struct
->	O
out_dpy	pointer
)	O
;	O
if	O
(	O
csa	struct
->	O
out_sol	pointer
!=	O
NULL	O
)	O
remove	function
(	O
csa	struct
->	O
out_sol	pointer
)	O
;	O
if	O
(	O
csa	struct
->	O
out_res	pointer
!=	O
NULL	O
)	O
remove	function
(	O
csa	struct
->	O
out_res	pointer
)	O
;	O
if	O
(	O
csa	struct
->	O
out_ranges	pointer
!=	O
NULL	O
)	O
remove	function
(	O
csa	struct
->	O
out_ranges	pointer
)	O
;	O
if	O
(	O
csa	struct
->	O
out_mps	pointer
!=	O
NULL	O
)	O
remove	function
(	O
csa	struct
->	O
out_mps	pointer
)	O
;	O
if	O
(	O
csa	struct
->	O
out_freemps	pointer
!=	O
NULL	O
)	O
remove	function
(	O
csa	struct
->	O
out_freemps	pointer
)	O
;	O
if	O
(	O
csa	struct
->	O
out_cpxlp	pointer
!=	O
NULL	O
)	O
remove	function
(	O
csa	struct
->	O
out_cpxlp	pointer
)	O
;	O
if	O
(	O
csa	struct
->	O
out_glp	pointer
!=	O
NULL	O
)	O
remove	function
(	O
csa	struct
->	O
out_glp	pointer
)	O
;	O
if	O
(	O
csa	struct
->	O
out_cnf	pointer
!=	O
NULL	O
)	O
remove	function
(	O
csa	struct
->	O
out_cnf	pointer
)	O
;	O
if	O
(	O
csa	struct
->	O
log_file	pointer
!=	O
NULL	O
)	O
remove	function
(	O
csa	struct
->	O
log_file	pointer
)	O
;	O
if	O
(	O
csa	struct
->	O
log_file	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
glp_open_tee	function
(	O
csa	struct
->	O
log_file	pointer
)	O
)	O
{	O
xprintf	O
(	O
"Unable to create log file\n"	pointer
)	O
;	O
ret	int
=	O
EXIT_FAILURE	int
;	O
goto	O
done	O
;	O
}	O
}	O
print_version	function
(	O
1	int
)	O
;	O
if	O
(	O
argc	int
>	O
1	int
)	O
{	O
int	O
k	int
,	O
len	int
=	O
INT_MAX	O
;	O
xprintf	O
(	O
"Parameter(s) specified in the command line:"	pointer
)	O
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<	O
argc	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
len	int
>	O
72	int
)	O
xprintf	O
(	O
"\n"	pointer
)	O
,	O
len	int
=	O
0	int
;	O
xprintf	O
(	O
" %s"	pointer
,	O
argv	array
[	O
k	int
]	O
)	O
;	O
len	int
+=	O
1	int
+	O
strlen	function
(	O
argv	array
[	O
k	int
]	O
)	O
;	O
}	O
xprintf	O
(	O
"\n"	pointer
)	O
;	O
}	O
if	O
(	O
csa	struct
->	O
in_file	pointer
==	O
NULL	O
)	O
{	O
xprintf	O
(	O
"No input problem file specified; try %s --help\n"	pointer
,	O
argv	array
[	O
0	int
]	O
)	O
;	O
ret	int
=	O
EXIT_FAILURE	int
;	O
goto	O
done	O
;	O
}	O
if	O
(	O
csa	struct
->	O
format	int
==	O
FMT_MPS_DECK	int
)	O
{	O
ret	int
=	O
glp_read_mps	function
(	O
csa	struct
->	O
prob	pointer
,	O
GLP_MPS_DECK	int
,	O
NULL	O
,	O
csa	struct
->	O
in_file	pointer
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
err1	O
:	O
{	O
xprintf	O
(	O
"MPS file processing error\n"	pointer
)	O
;	O
ret	int
=	O
EXIT_FAILURE	int
;	O
goto	O
done	O
;	O
}	O
}	O
else	O
if	O
(	O
csa	struct
->	O
format	int
==	O
FMT_MPS_FILE	int
)	O
{	O
ret	int
=	O
glp_read_mps	function
(	O
csa	struct
->	O
prob	pointer
,	O
GLP_MPS_FILE	int
,	O
NULL	O
,	O
csa	struct
->	O
in_file	pointer
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
goto	O
err1	O
;	O
}	O
else	O
if	O
(	O
csa	struct
->	O
format	int
==	O
FMT_LP	int
)	O
{	O
ret	int
=	O
glp_read_lp	function
(	O
csa	struct
->	O
prob	pointer
,	O
NULL	O
,	O
csa	struct
->	O
in_file	pointer
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
{	O
xprintf	O
(	O
"CPLEX LP file processing error\n"	pointer
)	O
;	O
ret	int
=	O
EXIT_FAILURE	int
;	O
goto	O
done	O
;	O
}	O
}	O
else	O
if	O
(	O
csa	struct
->	O
format	int
==	O
FMT_GLP	int
)	O
{	O
ret	int
=	O
glp_read_prob	function
(	O
csa	struct
->	O
prob	pointer
,	O
0	int
,	O
csa	struct
->	O
in_file	pointer
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
{	O
xprintf	O
(	O
"GLPK LP/MIP file processing error\n"	pointer
)	O
;	O
ret	int
=	O
EXIT_FAILURE	int
;	O
goto	O
done	O
;	O
}	O
}	O
else	O
if	O
(	O
csa	struct
->	O
format	int
==	O
FMT_MATHPROG	int
)	O
{	O
int	O
k	int
;	O
csa	struct
->	O
tran	pointer
=	O
glp_mpl_alloc_wksp	function
(	O
)	O
;	O
if	O
(	O
csa	struct
->	O
seed	int
==	O
0x80000000	int
)	O
{	O
csa	struct
->	O
seed	int
=	O
(	O
int	O
)	O
fmod	function
(	O
glp_time	function
(	O
)	O
,	O
1000000000.0	int
)	O
;	O
xprintf	O
(	O
"Seed value %d will be used\n"	pointer
,	O
csa	struct
->	O
seed	int
)	O
;	O
}	O
glp_mpl_init_rand	function
(	O
csa	struct
->	O
tran	pointer
,	O
csa	struct
->	O
seed	int
)	O
;	O
if	O
(	O
glp_mpl_read_model	function
(	O
csa	struct
->	O
tran	pointer
,	O
csa	struct
->	O
in_file	pointer
,	O
csa	struct
->	O
ndf	int
>	O
0	int
)	O
)	O
err2	O
:	O
{	O
xprintf	O
(	O
"MathProg model processing error\n"	pointer
)	O
;	O
ret	int
=	O
EXIT_FAILURE	int
;	O
goto	O
done	O
;	O
}	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<=	O
csa	struct
->	O
ndf	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
glp_mpl_read_data	function
(	O
csa	struct
->	O
tran	pointer
,	O
csa	struct
->	O
in_data	array
[	O
k	int
]	O
)	O
)	O
goto	O
err2	O
;	O
}	O
if	O
(	O
glp_mpl_generate	function
(	O
csa	struct
->	O
tran	pointer
,	O
csa	struct
->	O
out_dpy	pointer
)	O
)	O
goto	O
err2	O
;	O
glp_mpl_build_prob	function
(	O
csa	struct
->	O
tran	pointer
,	O
csa	struct
->	O
prob	pointer
)	O
;	O
}	O
else	O
if	O
(	O
csa	struct
->	O
format	int
==	O
FMT_MIN_COST	int
)	O
{	O
csa	struct
->	O
graph	pointer
=	O
glp_create_graph	function
(	O
sizeof	O
(	O
v_data	struct
)	O
,	O
sizeof	O
(	O
a_data	struct
)	O
)	O
;	O
ret	int
=	O
glp_read_mincost	function
(	O
csa	struct
->	O
graph	pointer
,	O
offsetof	O
(	O
v_data	struct
,	O
rhs	double
)	O
,	O
offsetof	O
(	O
a_data	struct
,	O
low	double
)	O
,	O
offsetof	O
(	O
a_data	struct
,	O
cap	double
)	O
,	O
offsetof	O
(	O
a_data	struct
,	O
cost	double
)	O
,	O
csa	struct
->	O
in_file	pointer
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
{	O
xprintf	O
(	O
"DIMACS file processing error\n"	pointer
)	O
;	O
ret	int
=	O
EXIT_FAILURE	int
;	O
goto	O
done	O
;	O
}	O
glp_mincost_lp	function
(	O
csa	struct
->	O
prob	pointer
,	O
csa	struct
->	O
graph	pointer
,	O
GLP_ON	int
,	O
offsetof	O
(	O
v_data	struct
,	O
rhs	double
)	O
,	O
offsetof	O
(	O
a_data	struct
,	O
low	double
)	O
,	O
offsetof	O
(	O
a_data	struct
,	O
cap	double
)	O
,	O
offsetof	O
(	O
a_data	struct
,	O
cost	double
)	O
)	O
;	O
glp_set_prob_name	function
(	O
csa	struct
->	O
prob	pointer
,	O
csa	struct
->	O
in_file	pointer
)	O
;	O
}	O
else	O
if	O
(	O
csa	struct
->	O
format	int
==	O
FMT_MAX_FLOW	int
)	O
{	O
int	O
s	pointer
,	O
t	int
;	O
csa	struct
->	O
graph	pointer
=	O
glp_create_graph	function
(	O
sizeof	O
(	O
v_data	struct
)	O
,	O
sizeof	O
(	O
a_data	struct
)	O
)	O
;	O
ret	int
=	O
glp_read_maxflow	function
(	O
csa	struct
->	O
graph	pointer
,	O
&	O
s	pointer
,	O
&	O
t	int
,	O
offsetof	O
(	O
a_data	struct
,	O
cap	double
)	O
,	O
csa	struct
->	O
in_file	pointer
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
{	O
xprintf	O
(	O
"DIMACS file processing error\n"	pointer
)	O
;	O
ret	int
=	O
EXIT_FAILURE	int
;	O
goto	O
done	O
;	O
}	O
glp_maxflow_lp	function
(	O
csa	struct
->	O
prob	pointer
,	O
csa	struct
->	O
graph	pointer
,	O
GLP_ON	int
,	O
s	pointer
,	O
t	int
,	O
offsetof	O
(	O
a_data	struct
,	O
cap	double
)	O
)	O
;	O
glp_set_prob_name	function
(	O
csa	struct
->	O
prob	pointer
,	O
csa	struct
->	O
in_file	pointer
)	O
;	O
}	O
else	O
if	O
(	O
csa	struct
->	O
format	int
==	O
FMT_CNF	int
)	O
{	O
ret	int
=	O
glp_read_cnfsat	function
(	O
csa	struct
->	O
prob	pointer
,	O
csa	struct
->	O
in_file	pointer
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
{	O
xprintf	O
(	O
"DIMACS file processing error\n"	pointer
)	O
;	O
ret	int
=	O
EXIT_FAILURE	int
;	O
goto	O
done	O
;	O
}	O
glp_set_prob_name	function
(	O
csa	struct
->	O
prob	pointer
,	O
csa	struct
->	O
in_file	pointer
)	O
;	O
}	O
else	O
xassert	O
(	O
csa	struct
!=	O
csa	struct
)	O
;	O
if	O
(	O
csa	struct
->	O
new_name	pointer
!=	O
NULL	O
)	O
glp_set_prob_name	function
(	O
csa	struct
->	O
prob	pointer
,	O
csa	struct
->	O
new_name	pointer
)	O
;	O
if	O
(	O
csa	struct
->	O
dir	int
!=	O
0	int
)	O
glp_set_obj_dir	function
(	O
csa	struct
->	O
prob	pointer
,	O
csa	struct
->	O
dir	int
)	O
;	O
glp_sort_matrix	function
(	O
csa	struct
->	O
prob	pointer
)	O
;	O
if	O
(	O
csa	struct
->	O
hide	int
)	O
{	O
int	O
i	int
,	O
j	int
;	O
glp_set_obj_name	function
(	O
csa	struct
->	O
prob	pointer
,	O
NULL	O
)	O
;	O
glp_delete_index	function
(	O
csa	struct
->	O
prob	pointer
)	O
;	O
for	O
(	O
i	int
=	O
glp_get_num_rows	function
(	O
csa	struct
->	O
prob	pointer
)	O
;	O
i	int
>=	O
1	int
;	O
i	int
--	O
)	O
glp_set_row_name	function
(	O
csa	struct
->	O
prob	pointer
,	O
i	int
,	O
NULL	O
)	O
;	O
for	O
(	O
j	int
=	O
glp_get_num_cols	function
(	O
csa	struct
->	O
prob	pointer
)	O
;	O
j	int
>=	O
1	int
;	O
j	int
--	O
)	O
glp_set_col_name	function
(	O
csa	struct
->	O
prob	pointer
,	O
j	int
,	O
NULL	O
)	O
;	O
}	O
if	O
(	O
csa	struct
->	O
out_mps	pointer
!=	O
NULL	O
)	O
{	O
ret	int
=	O
glp_write_mps	function
(	O
csa	struct
->	O
prob	pointer
,	O
GLP_MPS_DECK	int
,	O
NULL	O
,	O
csa	struct
->	O
out_mps	pointer
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
{	O
xprintf	O
(	O
"Unable to write problem in fixed MPS format\n"	pointer
)	O
;	O
ret	int
=	O
EXIT_FAILURE	int
;	O
goto	O
done	O
;	O
}	O
}	O
if	O
(	O
csa	struct
->	O
out_freemps	pointer
!=	O
NULL	O
)	O
{	O
ret	int
=	O
glp_write_mps	function
(	O
csa	struct
->	O
prob	pointer
,	O
GLP_MPS_FILE	int
,	O
NULL	O
,	O
csa	struct
->	O
out_freemps	pointer
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
{	O
xprintf	O
(	O
"Unable to write problem in free MPS format\n"	pointer
)	O
;	O
ret	int
=	O
EXIT_FAILURE	int
;	O
goto	O
done	O
;	O
}	O
}	O
if	O
(	O
csa	struct
->	O
out_cpxlp	pointer
!=	O
NULL	O
)	O
{	O
ret	int
=	O
glp_write_lp	function
(	O
csa	struct
->	O
prob	pointer
,	O
NULL	O
,	O
csa	struct
->	O
out_cpxlp	pointer
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
{	O
xprintf	O
(	O
"Unable to write problem in CPLEX LP format\n"	pointer
)	O
;	O
ret	int
=	O
EXIT_FAILURE	int
;	O
goto	O
done	O
;	O
}	O
}	O
if	O
(	O
csa	struct
->	O
out_glp	pointer
!=	O
NULL	O
)	O
{	O
ret	int
=	O
glp_write_prob	function
(	O
csa	struct
->	O
prob	pointer
,	O
0	int
,	O
csa	struct
->	O
out_glp	pointer
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
{	O
xprintf	O
(	O
"Unable to write problem in GLPK format\n"	pointer
)	O
;	O
ret	int
=	O
EXIT_FAILURE	int
;	O
goto	O
done	O
;	O
}	O
}	O
if	O
(	O
csa	struct
->	O
out_cnf	pointer
!=	O
NULL	O
)	O
{	O
ret	int
=	O
glp_write_cnfsat	function
(	O
csa	struct
->	O
prob	pointer
,	O
csa	struct
->	O
out_cnf	pointer
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
{	O
xprintf	O
(	O
"Unable to write problem in DIMACS CNF-SAT format\n"	pointer
)	O
;	O
ret	int
=	O
EXIT_FAILURE	int
;	O
goto	O
done	O
;	O
}	O
}	O
if	O
(	O
csa	struct
->	O
check	int
)	O
{	O
int	O
j	int
,	O
cnt	int
=	O
0	int
;	O
xprintf	O
(	O
"--- Problem Characteristics ---\n"	pointer
)	O
;	O
xprintf	O
(	O
"Number of rows               = %8d\n"	pointer
,	O
glp_get_num_rows	function
(	O
csa	struct
->	O
prob	pointer
)	O
)	O
;	O
xprintf	O
(	O
"Number of columns            = %8d\n"	pointer
,	O
glp_get_num_cols	function
(	O
csa	struct
->	O
prob	pointer
)	O
)	O
;	O
xprintf	O
(	O
"Number of non-zeros (matrix) = %8d\n"	pointer
,	O
glp_get_num_nz	function
(	O
csa	struct
->	O
prob	pointer
)	O
)	O
;	O
for	O
(	O
j	int
=	O
glp_get_num_cols	function
(	O
csa	struct
->	O
prob	pointer
)	O
;	O
j	int
>=	O
1	int
;	O
j	int
--	O
)	O
{	O
if	O
(	O
glp_get_obj_coef	function
(	O
csa	struct
->	O
prob	pointer
,	O
j	int
)	O
!=	O
0.0	int
)	O
cnt	int
++	O
;	O
}	O
xprintf	O
(	O
"Number of non-zeros (objrow) = %8d\n"	pointer
,	O
cnt	int
)	O
;	O
ret	int
=	O
EXIT_SUCCESS	int
;	O
goto	O
done	O
;	O
}	O
if	O
(	O
!	O
csa	struct
->	O
nomip	int
&&	O
glp_get_num_int	function
(	O
csa	struct
->	O
prob	pointer
)	O
+	O
glp_get_num_bin	function
(	O
csa	struct
->	O
prob	pointer
)	O
>	O
0	int
)	O
{	O
if	O
(	O
csa	struct
->	O
solution	int
==	O
SOL_INTERIOR	int
)	O
{	O
xprintf	O
(	O
"Interior-point method is not able to solve MIP pro"	pointer
"blem; use --simplex\n"	pointer
)	O
;	O
ret	int
=	O
EXIT_FAILURE	int
;	O
goto	O
done	O
;	O
}	O
csa	struct
->	O
solution	int
=	O
SOL_INTEGER	int
;	O
}	O
if	O
(	O
csa	struct
->	O
in_res	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
csa	struct
->	O
solution	int
==	O
SOL_BASIC	int
)	O
ret	int
=	O
glp_read_sol	function
(	O
csa	struct
->	O
prob	pointer
,	O
csa	struct
->	O
in_res	pointer
)	O
;	O
else	O
if	O
(	O
csa	struct
->	O
solution	int
==	O
SOL_INTERIOR	int
)	O
ret	int
=	O
glp_read_ipt	function
(	O
csa	struct
->	O
prob	pointer
,	O
csa	struct
->	O
in_res	pointer
)	O
;	O
else	O
if	O
(	O
csa	struct
->	O
solution	int
==	O
SOL_INTEGER	int
)	O
ret	int
=	O
glp_read_mip	function
(	O
csa	struct
->	O
prob	pointer
,	O
csa	struct
->	O
in_res	pointer
)	O
;	O
else	O
xassert	O
(	O
csa	struct
!=	O
csa	struct
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
{	O
xprintf	O
(	O
"Unable to read problem solution\n"	pointer
)	O
;	O
ret	int
=	O
EXIT_FAILURE	int
;	O
goto	O
done	O
;	O
}	O
goto	O
skip	int
;	O
}	O
if	O
(	O
csa	struct
->	O
solution	int
==	O
SOL_INTEGER	int
&&	O
csa	struct
->	O
use_sol	int
!=	O
NULL	O
)	O
{	O
ret	int
=	O
glp_read_mip	function
(	O
csa	struct
->	O
prob	pointer
,	O
csa	struct
->	O
use_sol	int
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
{	O
xprintf	O
(	O
"Unable to read initial MIP solution\n"	pointer
)	O
;	O
ret	int
=	O
EXIT_FAILURE	int
;	O
goto	O
done	O
;	O
}	O
csa	struct
->	O
iocp	struct
.	O
use_sol	int
=	O
GLP_ON	int
;	O
}	O
if	O
(	O
csa	struct
->	O
scale	int
)	O
{	O
if	O
(	O
csa	struct
->	O
solution	int
==	O
SOL_BASIC	int
&&	O
!	O
csa	struct
->	O
smcp	struct
.	O
presolve	int
||	O
csa	struct
->	O
solution	int
==	O
SOL_INTERIOR	int
||	O
csa	struct
->	O
solution	int
==	O
SOL_INTEGER	int
&&	O
!	O
csa	struct
->	O
iocp	struct
.	O
presolve	int
)	O
glp_scale_prob	function
(	O
csa	struct
->	O
prob	pointer
,	O
GLP_SF_AUTO	int
)	O
;	O
}	O
if	O
(	O
csa	struct
->	O
solution	int
==	O
SOL_BASIC	int
&&	O
!	O
csa	struct
->	O
smcp	struct
.	O
presolve	int
||	O
csa	struct
->	O
solution	int
==	O
SOL_INTEGER	int
&&	O
!	O
csa	struct
->	O
iocp	struct
.	O
presolve	int
)	O
{	O
if	O
(	O
csa	struct
->	O
crash	int
==	O
USE_STD_BASIS	int
)	O
glp_std_basis	function
(	O
csa	struct
->	O
prob	pointer
)	O
;	O
else	O
if	O
(	O
csa	struct
->	O
crash	int
==	O
USE_ADV_BASIS	int
)	O
glp_adv_basis	function
(	O
csa	struct
->	O
prob	pointer
,	O
0	int
)	O
;	O
else	O
if	O
(	O
csa	struct
->	O
crash	int
==	O
USE_CPX_BASIS	int
)	O
glp_cpx_basis	function
(	O
csa	struct
->	O
prob	pointer
)	O
;	O
else	O
if	O
(	O
csa	struct
->	O
crash	int
==	O
USE_INI_BASIS	int
)	O
{	O
ret	int
=	O
glp_read_sol	function
(	O
csa	struct
->	O
prob	pointer
,	O
csa	struct
->	O
ini_file	pointer
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
{	O
xprintf	O
(	O
"Unable to read initial basis\n"	pointer
)	O
;	O
ret	int
=	O
EXIT_FAILURE	int
;	O
goto	O
done	O
;	O
}	O
}	O
else	O
xassert	O
(	O
csa	struct
!=	O
csa	struct
)	O
;	O
}	O
start	double
=	O
glp_time	function
(	O
)	O
;	O
if	O
(	O
csa	struct
->	O
solution	int
==	O
SOL_BASIC	int
)	O
{	O
if	O
(	O
!	O
csa	struct
->	O
exact	int
)	O
{	O
glp_set_bfcp	function
(	O
csa	struct
->	O
prob	pointer
,	O
&	O
csa	struct
->	O
bfcp	struct
)	O
;	O
glp_simplex	function
(	O
csa	struct
->	O
prob	pointer
,	O
&	O
csa	struct
->	O
smcp	struct
)	O
;	O
if	O
(	O
csa	struct
->	O
xcheck	int
)	O
{	O
if	O
(	O
csa	struct
->	O
smcp	struct
.	O
presolve	int
&&	O
glp_get_status	function
(	O
csa	struct
->	O
prob	pointer
)	O
!=	O
GLP_OPT	int
)	O
xprintf	O
(	O
"If you need to check final basis for non-opt"	pointer
"imal solution, use --nopresol\n"	pointer
)	O
;	O
else	O
glp_exact	function
(	O
csa	struct
->	O
prob	pointer
,	O
&	O
csa	struct
->	O
smcp	struct
)	O
;	O
}	O
if	O
(	O
csa	struct
->	O
out_sol	pointer
!=	O
NULL	O
||	O
csa	struct
->	O
out_res	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
csa	struct
->	O
smcp	struct
.	O
presolve	int
&&	O
glp_get_status	function
(	O
csa	struct
->	O
prob	pointer
)	O
!=	O
GLP_OPT	int
)	O
xprintf	O
(	O
"If you need actual output for non-optimal solut"	pointer
"ion, use --nopresol\n"	pointer
)	O
;	O
}	O
}	O
else	O
glp_exact	function
(	O
csa	struct
->	O
prob	pointer
,	O
&	O
csa	struct
->	O
smcp	struct
)	O
;	O
}	O
else	O
if	O
(	O
csa	struct
->	O
solution	int
==	O
SOL_INTERIOR	int
)	O
glp_interior	function
(	O
csa	struct
->	O
prob	pointer
,	O
&	O
csa	struct
->	O
iptcp	struct
)	O
;	O
else	O
if	O
(	O
csa	struct
->	O
solution	int
==	O
SOL_INTEGER	int
&&	O
csa	struct
->	O
minisat	int
)	O
{	O
if	O
(	O
glp_check_cnfsat	function
(	O
csa	struct
->	O
prob	pointer
)	O
==	O
0	int
)	O
glp_minisat1	function
(	O
csa	struct
->	O
prob	pointer
)	O
;	O
else	O
glp_intfeas1	function
(	O
csa	struct
->	O
prob	pointer
,	O
csa	struct
->	O
use_bnd	int
,	O
csa	struct
->	O
obj_bnd	int
)	O
;	O
}	O
else	O
if	O
(	O
csa	struct
->	O
solution	int
==	O
SOL_INTEGER	int
)	O
{	O
glp_set_bfcp	function
(	O
csa	struct
->	O
prob	pointer
,	O
&	O
csa	struct
->	O
bfcp	struct
)	O
;	O
if	O
(	O
!	O
csa	struct
->	O
iocp	struct
.	O
presolve	int
)	O
glp_simplex	function
(	O
csa	struct
->	O
prob	pointer
,	O
&	O
csa	struct
->	O
smcp	struct
)	O
;	O
glp_intopt	function
(	O
csa	struct
->	O
prob	pointer
,	O
&	O
csa	struct
->	O
iocp	struct
)	O
;	O
}	O
else	O
xassert	O
(	O
csa	struct
!=	O
csa	struct
)	O
;	O
xprintf	O
(	O
"Time used:   %.1f secs\n"	pointer
,	O
glp_difftime	function
(	O
glp_time	function
(	O
)	O
,	O
start	double
)	O
)	O
;	O
{	O
size_t	long
tpeak	pointer
;	O
glp_mem_usage	function
(	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
&	O
tpeak	pointer
)	O
;	O
xprintf	O
(	O
"Memory used: %.1f Mb (%.0f bytes)\n"	pointer
,	O
(	O
double	O
)	O
tpeak	pointer
/	O
1048576.0	int
,	O
(	O
double	O
)	O
tpeak	pointer
)	O
;	O
}	O
skip	int
:	O
if	O
(	O
csa	struct
->	O
tran	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
csa	struct
->	O
solution	int
==	O
SOL_BASIC	int
)	O
{	O
if	O
(	O
!	O
(	O
glp_get_status	function
(	O
csa	struct
->	O
prob	pointer
)	O
==	O
GLP_OPT	int
||	O
glp_get_status	function
(	O
csa	struct
->	O
prob	pointer
)	O
==	O
GLP_FEAS	int
)	O
)	O
ret	int
=	O
-	O
1	int
;	O
else	O
ret	int
=	O
glp_mpl_postsolve	function
(	O
csa	struct
->	O
tran	pointer
,	O
csa	struct
->	O
prob	pointer
,	O
GLP_SOL	int
)	O
;	O
}	O
else	O
if	O
(	O
csa	struct
->	O
solution	int
==	O
SOL_INTERIOR	int
)	O
{	O
if	O
(	O
!	O
(	O
glp_ipt_status	function
(	O
csa	struct
->	O
prob	pointer
)	O
==	O
GLP_OPT	int
||	O
glp_ipt_status	function
(	O
csa	struct
->	O
prob	pointer
)	O
==	O
GLP_FEAS	int
)	O
)	O
ret	int
=	O
-	O
1	int
;	O
else	O
ret	int
=	O
glp_mpl_postsolve	function
(	O
csa	struct
->	O
tran	pointer
,	O
csa	struct
->	O
prob	pointer
,	O
GLP_IPT	int
)	O
;	O
}	O
else	O
if	O
(	O
csa	struct
->	O
solution	int
==	O
SOL_INTEGER	int
)	O
{	O
if	O
(	O
!	O
(	O
glp_mip_status	function
(	O
csa	struct
->	O
prob	pointer
)	O
==	O
GLP_OPT	int
||	O
glp_mip_status	function
(	O
csa	struct
->	O
prob	pointer
)	O
==	O
GLP_FEAS	int
)	O
)	O
ret	int
=	O
-	O
1	int
;	O
else	O
ret	int
=	O
glp_mpl_postsolve	function
(	O
csa	struct
->	O
tran	pointer
,	O
csa	struct
->	O
prob	pointer
,	O
GLP_MIP	int
)	O
;	O
}	O
else	O
xassert	O
(	O
csa	struct
!=	O
csa	struct
)	O
;	O
if	O
(	O
ret	int
>	O
0	int
)	O
{	O
xprintf	O
(	O
"Model postsolving error\n"	pointer
)	O
;	O
ret	int
=	O
EXIT_FAILURE	int
;	O
goto	O
done	O
;	O
}	O
}	O
if	O
(	O
csa	struct
->	O
out_sol	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
csa	struct
->	O
solution	int
==	O
SOL_BASIC	int
)	O
ret	int
=	O
glp_print_sol	function
(	O
csa	struct
->	O
prob	pointer
,	O
csa	struct
->	O
out_sol	pointer
)	O
;	O
else	O
if	O
(	O
csa	struct
->	O
solution	int
==	O
SOL_INTERIOR	int
)	O
ret	int
=	O
glp_print_ipt	function
(	O
csa	struct
->	O
prob	pointer
,	O
csa	struct
->	O
out_sol	pointer
)	O
;	O
else	O
if	O
(	O
csa	struct
->	O
solution	int
==	O
SOL_INTEGER	int
)	O
ret	int
=	O
glp_print_mip	function
(	O
csa	struct
->	O
prob	pointer
,	O
csa	struct
->	O
out_sol	pointer
)	O
;	O
else	O
xassert	O
(	O
csa	struct
!=	O
csa	struct
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
{	O
xprintf	O
(	O
"Unable to write problem solution\n"	pointer
)	O
;	O
ret	int
=	O
EXIT_FAILURE	int
;	O
goto	O
done	O
;	O
}	O
}	O
if	O
(	O
csa	struct
->	O
out_res	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
csa	struct
->	O
solution	int
==	O
SOL_BASIC	int
)	O
ret	int
=	O
glp_write_sol	function
(	O
csa	struct
->	O
prob	pointer
,	O
csa	struct
->	O
out_res	pointer
)	O
;	O
else	O
if	O
(	O
csa	struct
->	O
solution	int
==	O
SOL_INTERIOR	int
)	O
ret	int
=	O
glp_write_ipt	function
(	O
csa	struct
->	O
prob	pointer
,	O
csa	struct
->	O
out_res	pointer
)	O
;	O
else	O
if	O
(	O
csa	struct
->	O
solution	int
==	O
SOL_INTEGER	int
)	O
ret	int
=	O
glp_write_mip	function
(	O
csa	struct
->	O
prob	pointer
,	O
csa	struct
->	O
out_res	pointer
)	O
;	O
else	O
xassert	O
(	O
csa	struct
!=	O
csa	struct
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
{	O
xprintf	O
(	O
"Unable to write problem solution\n"	pointer
)	O
;	O
ret	int
=	O
EXIT_FAILURE	int
;	O
goto	O
done	O
;	O
}	O
}	O
if	O
(	O
csa	struct
->	O
out_ranges	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
csa	struct
->	O
solution	int
==	O
SOL_BASIC	int
)	O
{	O
if	O
(	O
glp_get_status	function
(	O
csa	struct
->	O
prob	pointer
)	O
==	O
GLP_OPT	int
)	O
{	O
if	O
(	O
glp_bf_exists	function
(	O
csa	struct
->	O
prob	pointer
)	O
)	O
ranges	O
:	O
{	O
ret	int
=	O
glp_print_ranges	function
(	O
csa	struct
->	O
prob	pointer
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
csa	struct
->	O
out_ranges	pointer
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
{	O
xprintf	O
(	O
"Unable to write sensitivity analysis repo"	pointer
"rt\n"	pointer
)	O
;	O
ret	int
=	O
EXIT_FAILURE	int
;	O
goto	O
done	O
;	O
}	O
}	O
else	O
{	O
ret	int
=	O
glp_factorize	function
(	O
csa	struct
->	O
prob	pointer
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
goto	O
ranges	O
;	O
xprintf	O
(	O
"Cannot produce sensitivity analysis report d"	pointer
"ue to error in basis factorization (glp_factorize"	pointer
" returned %d); try --nopresol\n"	pointer
,	O
ret	int
)	O
;	O
}	O
}	O
else	O
xprintf	O
(	O
"Cannot produce sensitivity analysis report for "	pointer
"non-optimal basic solution\n"	pointer
)	O
;	O
}	O
else	O
xprintf	O
(	O
"Cannot produce sensitivity analysis report for int"	pointer
"erior-point or MIP solution\n"	pointer
)	O
;	O
}	O
ret	int
=	O
EXIT_SUCCESS	int
;	O
done	O
:	O
if	O
(	O
csa	struct
->	O
prob	pointer
!=	O
NULL	O
)	O
glp_delete_prob	function
(	O
csa	struct
->	O
prob	pointer
)	O
;	O
if	O
(	O
csa	struct
->	O
tran	pointer
!=	O
NULL	O
)	O
glp_mpl_free_wksp	function
(	O
csa	struct
->	O
tran	pointer
)	O
;	O
if	O
(	O
csa	struct
->	O
graph	pointer
!=	O
NULL	O
)	O
glp_delete_graph	function
(	O
csa	struct
->	O
graph	pointer
)	O
;	O
if	O
(	O
csa	struct
->	O
log_file	pointer
!=	O
NULL	O
)	O
glp_close_tee	function
(	O
)	O
;	O
{	O
int	O
count	pointer
;	O
size_t	long
total	pointer
;	O
glp_mem_usage	function
(	O
&	O
count	pointer
,	O
NULL	O
,	O
&	O
total	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
count	pointer
!=	O
0	int
)	O
xerror	O
(	O
"Error: %d memory block(s) were lost\n"	pointer
,	O
count	pointer
)	O
;	O
xassert	O
(	O
total	pointer
==	O
0	int
)	O
;	O
}	O
glp_free_env	function
(	O
)	O
;	O
return	O
ret	int
;	O
}	O
