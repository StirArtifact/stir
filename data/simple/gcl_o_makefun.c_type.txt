object	function
MakeAfun	function
(	O
object	function
(	O
*	O
addr	pointer
)	O
(	O
object	function
,	O
object	function
)	O
,	O
unsigned	O
int	O
argd	int
,	O
object	function
data	int
)	O
{	O
int	O
type	int
=	O
(	O
F_ARG_FLAGS_P	function
(	O
argd	int
,	O
F_requires_fun_passed	O
)	O
?	O
t_closure	O
:	O
t_afun	O
)	O
;	O
object	function
x	int
=	O
alloc_object	O
(	O
type	int
)	O
;	O
x	int
->	O
sfn	O
.	O
sfn_name	O
=	O
Cnil	O
;	O
x	int
->	O
sfn	O
.	O
sfn_self	O
=	O
addr	pointer
;	O
x	int
->	O
sfn	O
.	O
sfn_argd	O
=	O
argd	int
;	O
if	O
(	O
type	int
==	O
t_closure	O
)	O
{	O
x	int
->	O
cl	O
.	O
cl_env	O
=	O
0	int
;	O
x	int
->	O
cl	O
.	O
cl_envdim	O
=	O
0	int
;	O
}	O
x	int
->	O
sfn	O
.	O
sfn_data	O
=	O
data	int
;	O
return	O
x	int
;	O
}	O
static	O
object	function
fSmakefun	function
(	O
object	function
sym	int
,	O
object	function
(	O
*	O
addr	pointer
)	O
(	O
)	O
,	O
unsigned	O
int	O
argd	int
)	O
{	O
object	function
ans	O
=	O
MakeAfun	function
(	O
addr	pointer
,	O
argd	int
,	O
(	O
sSPmemory	O
&&	O
sSPmemory	O
->	O
s	O
.	O
s_dbind	O
&&	O
type_of	function
(	O
sSPmemory	O
->	O
s	O
.	O
s_dbind	O
)	O
==	O
t_cfdata	O
)	O
?	O
sSPmemory	O
->	O
s	O
.	O
s_dbind	O
:	O
0	int
)	O
;	O
ans	O
->	O
sfn	O
.	O
sfn_name	O
=	O
sym	int
;	O
return	O
ans	O
;	O
}	O
static	O
void	O
IsetClosure	function
(	O
object	function
x	int
,	O
int	O
n	int
,	O
va_list	O
ap	int
)	O
{	O
object	function
*	O
p	O
;	O
if	O
(	O
type_of	function
(	O
x	int
)	O
!=	O
t_closure	O
)	O
{	O
FEerror	function
(	O
"Not a closure"	pointer
,	O
0	int
)	O
;	O
}	O
if	O
(	O
x	int
->	O
cl	O
.	O
cl_envdim	O
<	O
n	int
)	O
{	O
BEGIN_NO_INTERRUPT	O
;	O
x	int
->	O
cl	O
.	O
cl_env	O
=	O
(	O
object	function
*	O
)	O
alloc_relblock	O
(	O
n	int
)	O
;	O
x	int
->	O
cl	O
.	O
cl_envdim	O
=	O
n	int
;	O
END_NO_INTERRUPT	O
;	O
}	O
p	O
=	O
x	int
->	O
cl	O
.	O
cl_env	O
;	O
while	O
(	O
--	O
n	int
>=	O
0	int
)	O
{	O
*	O
p	O
++	O
=	O
va_arg	function
(	O
ap	int
,	O
object	function
)	O
;	O
}	O
}	O
DEFUN_NEW	function
(	O
"INITFUN"	pointer
,	O
object	function
,	O
fSinitfun	O
,	O
SI	O
,	O
3	int
,	O
ARG_LIMIT	O
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	function
sym	int
,	O
object	function
addr_ind	O
,	O
object	function
argd	int
,	O
...	O
)	O
,	O
"Store a compiled function on SYMBOL whose body is in the VV array at INDEX, and whose argd descriptor is ARGD.  If more arguments IND1, IND2,.. are supplied these are indices in the VV array for the environment of this closure."	pointer
)	O
{	O
int	O
nargs	int
=	O
F_NARGS	function
(	O
VFUN_NARGS	O
)	O
-	O
3	int
;	O
va_list	O
ap	int
;	O
object	function
fun	O
=	O
fSmakefun	function
(	O
IisSymbol	O
(	O
sym	int
)	O
,	O
PADDR	O
(	O
addr_ind	O
)	O
,	O
Mfix	function
(	O
argd	int
)	O
)	O
;	O
if	O
(	O
nargs	int
>	O
0	int
)	O
{	O
va_start	O
(	O
ap	int
,	O
argd	int
)	O
;	O
IsetClosure	function
(	O
fun	O
,	O
nargs	int
,	O
ap	int
)	O
;	O
while	O
(	O
--	O
nargs	int
>=	O
0	int
)	O
{	O
fun	O
->	O
cl	O
.	O
cl_env	O
[	O
nargs	int
]	O
=	O
(	O
object	function
)	O
PADDR	O
(	O
fun	O
->	O
cl	O
.	O
cl_env	O
[	O
nargs	int
]	O
)	O
;	O
}	O
va_end	O
(	O
ap	int
)	O
;	O
}	O
fSfset	function
(	O
sym	int
,	O
fun	O
)	O
;	O
return	O
sym	int
;	O
}	O
DEFUN_NEW	function
(	O
"INITMACRO"	pointer
,	O
object	function
,	O
fSinitmacro	O
,	O
SI	O
,	O
4	int
,	O
ARG_LIMIT	O
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	function
first	O
,	O
...	O
)	O
,	O
"Like INITFUN, but makes then sets the 'macro' flag on this symbol"	pointer
)	O
{	O
va_list	O
ap	int
;	O
object	function
res	O
;	O
int	O
n	int
=	O
VFUN_NARGS	O
;	O
object	function
*	O
new	O
;	O
va_start	O
(	O
ap	int
,	O
first	O
)	O
;	O
COERCE_VA_LIST_NEW	function
(	O
new	O
,	O
first	O
,	O
ap	int
,	O
n	int
)	O
;	O
res	O
=	O
c_apply_n_f	function
(	O
(	O
void	O
*	O
)	O
FFN	function
(	O
fSinitfun	O
)	O
,	O
n	int
,	O
new	O
,	O
3	int
,	O
ARG_LIMIT	O
)	O
;	O
va_end	O
(	O
ap	int
)	O
;	O
res	O
->	O
s	O
.	O
s_mflag	O
=	O
1	int
;	O
return	O
res	O
;	O
}	O
DEFUN_NEW	function
(	O
"SET-KEY-STRUCT"	pointer
,	O
object	function
,	O
fSset_key_struct	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	function
key_struct_ind	O
)	O
,	O
"Called inside the loader.  The keystruct is set up in the file with    indexes rather than the actual entries.  We change these indices to    the objects"	pointer
)	O
{	O
set_key_struct	function
(	O
PADDR	O
(	O
key_struct_ind	O
)	O
,	O
sSPmemory	O
->	O
s	O
.	O
s_dbind	O
)	O
;	O
return	O
Cnil	O
;	O
}	O
static	O
void	O
put_fn_procls	function
(	O
object	function
sym	int
,	O
fixnum	O
argd	int
,	O
fixnum	O
oneval	int
,	O
object	function
def	int
,	O
object	function
rdef	int
)	O
{	O
unsigned	O
int	O
atypes	int
=	O
F_TYPES	function
(	O
argd	int
)	O
>>	O
F_TYPE_WIDTH	O
;	O
unsigned	O
int	O
minargs	int
=	O
F_MIN_ARGS	function
(	O
argd	int
)	O
;	O
unsigned	O
int	O
maxargs	int
=	O
F_MAX_ARGS	function
(	O
argd	int
)	O
;	O
unsigned	O
int	O
rettype	int
=	O
F_RESULT_TYPE	function
(	O
argd	int
)	O
;	O
unsigned	O
int	O
i	int
;	O
object	function
ta	O
=	O
Cnil	O
,	O
na	O
=	O
Cnil	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
minargs	int
;	O
i	int
++	O
,	O
atypes	int
>>=	O
F_TYPE_WIDTH	O
)	O
switch	O
(	O
maxargs	int
!=	O
minargs	int
?	O
F_object	O
:	O
atypes	int
&	O
MASK_RANGE	function
(	O
0	int
,	O
F_TYPE_WIDTH	O
)	O
)	O
{	O
case	O
F_object	O
:	O
collect	O
(	O
ta	O
,	O
na	O
,	O
def	int
)	O
;	O
break	O
;	O
case	O
F_int	O
:	O
collect	O
(	O
ta	O
,	O
na	O
,	O
sLfixnum	O
)	O
;	O
break	O
;	O
case	O
F_shortfloat	O
:	O
collect	O
(	O
ta	O
,	O
na	O
,	O
sLshort_float	O
)	O
;	O
break	O
;	O
case	O
F_double_ptr	O
:	O
collect	O
(	O
ta	O
,	O
na	O
,	O
sLlong_float	O
)	O
;	O
break	O
;	O
default	O
:	O
FEerror	function
(	O
"Bad sfn declaration"	pointer
,	O
0	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
maxargs	int
!=	O
minargs	int
)	O
collect	O
(	O
ta	O
,	O
na	O
,	O
sLA	O
)	O
;	O
putprop	function
(	O
sym	int
,	O
ta	O
,	O
sSproclaimed_arg_types	O
)	O
;	O
ta	O
=	O
na	O
=	O
Cnil	O
;	O
if	O
(	O
oneval	int
)	O
switch	O
(	O
rettype	int
)	O
{	O
case	O
F_object	O
:	O
ta	O
=	O
rdef	int
;	O
break	O
;	O
case	O
F_int	O
:	O
ta	O
=	O
sLfixnum	O
;	O
break	O
;	O
case	O
F_shortfloat	O
:	O
ta	O
=	O
sLshort_float	O
;	O
break	O
;	O
case	O
F_double_ptr	O
:	O
ta	O
=	O
sLlong_float	O
;	O
break	O
;	O
default	O
:	O
FEerror	function
(	O
"Bad sfn declaration"	pointer
,	O
0	int
)	O
;	O
break	O
;	O
}	O
else	O
ta	O
=	O
sLA	O
;	O
putprop	function
(	O
sym	int
,	O
ta	O
,	O
sSproclaimed_return_type	O
)	O
;	O
if	O
(	O
oneval	int
)	O
putprop	function
(	O
sym	int
,	O
Ct	O
,	O
sSproclaimed_function	O
)	O
;	O
}	O
void	O
SI_makefun	function
(	O
char	O
*	O
strg	pointer
,	O
void	O
*	O
fn	pointer
,	O
unsigned	O
int	O
argd	int
)	O
{	O
object	function
sym	int
=	O
make_si_ordinary	O
(	O
strg	pointer
)	O
;	O
fSfset	function
(	O
sym	int
,	O
fSmakefun	function
(	O
sym	int
,	O
fn	pointer
,	O
argd	int
)	O
)	O
;	O
put_fn_procls	function
(	O
sym	int
,	O
argd	int
,	O
1	int
,	O
Ct	O
,	O
Ct	O
)	O
;	O
}	O
void	O
LISP_makefun	function
(	O
char	O
*	O
strg	pointer
,	O
void	O
*	O
fn	pointer
,	O
unsigned	O
int	O
argd	int
)	O
{	O
object	function
sym	int
=	O
make_ordinary	O
(	O
strg	pointer
)	O
;	O
fSfset	function
(	O
sym	int
,	O
fSmakefun	function
(	O
sym	int
,	O
fn	pointer
,	O
argd	int
)	O
)	O
;	O
put_fn_procls	function
(	O
sym	int
,	O
argd	int
,	O
1	int
,	O
Ct	O
,	O
Ct	O
)	O
;	O
}	O
void	O
SI_makefunm	function
(	O
char	O
*	O
strg	pointer
,	O
void	O
*	O
fn	pointer
,	O
unsigned	O
int	O
argd	int
)	O
{	O
object	function
sym	int
=	O
make_si_ordinary	O
(	O
strg	pointer
)	O
;	O
fSfset	function
(	O
sym	int
,	O
fSmakefun	function
(	O
sym	int
,	O
fn	pointer
,	O
argd	int
)	O
)	O
;	O
put_fn_procls	function
(	O
sym	int
,	O
argd	int
,	O
0	int
,	O
Ct	O
,	O
Ct	O
)	O
;	O
}	O
void	O
LISP_makefunm	function
(	O
char	O
*	O
strg	pointer
,	O
void	O
*	O
fn	pointer
,	O
unsigned	O
int	O
argd	int
)	O
{	O
object	function
sym	int
=	O
make_ordinary	O
(	O
strg	pointer
)	O
;	O
fSfset	function
(	O
sym	int
,	O
fSmakefun	function
(	O
sym	int
,	O
fn	pointer
,	O
argd	int
)	O
)	O
;	O
put_fn_procls	function
(	O
sym	int
,	O
argd	int
,	O
0	int
,	O
Ct	O
,	O
Ct	O
)	O
;	O
}	O
DEFUN_NEW	function
(	O
"INVOKE"	pointer
,	O
object	function
,	O
fSinvoke	O
,	O
SI	O
,	O
1	int
,	O
ARG_LIMIT	O
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	function
x	int
)	O
,	O
"Invoke a C function whose body is at INDEX in the VV array"	pointer
)	O
{	O
int	O
(	O
*	O
fn	pointer
)	O
(	O
)	O
;	O
fn	pointer
=	O
(	O
void	O
*	O
)	O
PADDR	O
(	O
x	int
)	O
;	O
(	O
*	O
fn	pointer
)	O
(	O
)	O
;	O
return	O
Cnil	O
;	O
}	O
