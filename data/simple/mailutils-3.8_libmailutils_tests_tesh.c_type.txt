static	O
struct	O
mu_tesh_command	struct
*	O
find_command	function
(	O
struct	O
mu_tesh_command	struct
*	O
cmd	enum
,	O
char	O
const	O
*	O
name	pointer
)	O
{	O
while	O
(	O
cmd	enum
->	O
verb	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
cmd	enum
->	O
verb	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
return	O
cmd	enum
;	O
cmd	enum
++	O
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
int	O
cmdspecial	function
(	O
char	O
const	O
*	O
special	pointer
,	O
struct	O
mu_tesh_command	struct
*	O
cmdtab	pointer
,	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	pointer
,	O
mu_assoc_t	pointer
opt	pointer
,	O
void	O
*	O
env	pointer
,	O
int	O
defval	int
)	O
{	O
struct	O
mu_tesh_command	struct
*	O
cmd	enum
=	O
find_command	function
(	O
cmdtab	pointer
,	O
special	pointer
)	O
;	O
if	O
(	O
cmd	enum
)	O
return	O
cmd	enum
->	O
func	pointer
(	O
argc	long
,	O
argv	pointer
,	O
opt	pointer
,	O
env	pointer
)	O
;	O
return	O
defval	int
;	O
}	O
static	O
int	O
is_reserved	function
(	O
char	O
const	O
*	O
str	pointer
)	O
{	O
return	O
mu_string_prefix	function
(	O
str	pointer
,	O
"__"	pointer
)	O
&&	O
mu_string_suffix	function
(	O
str	pointer
,	O
"__"	pointer
)	O
;	O
}	O
static	O
int	O
interpret	function
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
xargv	pointer
,	O
struct	O
mu_tesh_command	struct
*	O
cmdtab	pointer
,	O
void	O
*	O
env	pointer
)	O
{	O
int	O
rc	int
;	O
struct	O
mu_tesh_command	struct
*	O
cmd	enum
;	O
mu_assoc_t	pointer
options	pointer
=	O
NULL	O
;	O
char	O
*	O
*	O
argv	pointer
=	O
xargv	pointer
;	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
"help"	pointer
)	O
==	O
0	int
)	O
{	O
mu_tesh_help	function
(	O
cmdtab	pointer
,	O
env	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
is_reserved	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
)	O
cmd	enum
=	O
NULL	O
;	O
else	O
cmd	enum
=	O
find_command	function
(	O
cmdtab	pointer
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
if	O
(	O
!	O
cmd	enum
)	O
{	O
if	O
(	O
cmdspecial	function
(	O
"__NOCMD__"	pointer
,	O
cmdtab	pointer
,	O
argc	long
,	O
argv	pointer
,	O
NULL	O
,	O
env	pointer
,	O
MU_ERR_NOENT	O
)	O
)	O
{	O
mu_error	function
(	O
"%s: no such command"	pointer
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
return	O
MU_ERR_NOENT	O
;	O
}	O
return	O
0	int
;	O
}	O
if	O
(	O
cmd	enum
->	O
param_min	int
==	O
0	int
)	O
{	O
struct	O
mu_wordsplit	struct
ws	pointer
;	O
if	O
(	O
mu_wordsplit	struct
(	O
cmd	enum
->	O
args	pointer
,	O
&	O
ws	pointer
,	O
MU_WRDSF_NOVAR	O
|	O
MU_WRDSF_NOCMD	O
|	O
MU_WRDSF_ALLOC_DIE	O
|	O
MU_WRDSF_SHOWERR	O
)	O
)	O
return	O
MU_ERR_PARSE	O
;	O
if	O
(	O
ws	pointer
.	O
ws_wordc	long
==	O
0	int
)	O
{	O
cmd	enum
->	O
param_min	int
=	O
cmd	enum
->	O
param_max	int
=	O
1	int
;	O
cmd	enum
->	O
options	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
int	O
i	long
;	O
int	O
variadic	int
=	O
0	int
;	O
cmd	enum
->	O
param_min	int
=	O
cmd	enum
->	O
param_max	int
=	O
1	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
ws	pointer
.	O
ws_wordc	long
;	O
i	long
++	O
)	O
{	O
char	O
*	O
argdef	pointer
=	O
ws	pointer
.	O
ws_wordv	pointer
[	O
i	long
]	O
;	O
if	O
(	O
mu_string_suffix	function
(	O
argdef	pointer
,	O
"..."	pointer
)	O
)	O
{	O
variadic	int
=	O
1	int
;	O
argdef	pointer
[	O
strlen	function
(	O
argdef	pointer
)	O
-	O
3	int
]	O
=	O
0	int
;	O
if	O
(	O
argdef	pointer
[	O
0	int
]	O
==	O
0	int
)	O
{	O
if	O
(	O
i	long
!=	O
ws	pointer
.	O
ws_wordc	long
-	O
1	int
)	O
{	O
mu_error	function
(	O
"%s: ellipsis must be last (found at #%d)"	pointer
,	O
cmd	enum
->	O
args	pointer
,	O
i	long
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
break	O
;	O
}	O
}	O
if	O
(	O
mu_string_prefix	function
(	O
argdef	pointer
,	O
"[-"	pointer
)	O
&&	O
mu_string_suffix	function
(	O
argdef	pointer
,	O
"]"	pointer
)	O
)	O
{	O
int	O
*	O
type	int
;	O
char	O
*	O
p	pointer
;	O
type	int
=	O
mu_alloc	function
(	O
sizeof	O
(	O
*	O
type	int
)	O
)	O
;	O
argdef	pointer
+=	O
2	int
;	O
argdef	pointer
[	O
strlen	function
(	O
argdef	pointer
)	O
-	O
1	int
]	O
=	O
0	int
;	O
if	O
(	O
!	O
cmd	enum
->	O
options	pointer
)	O
{	O
MU_ASSERT	O
(	O
mu_assoc_create	function
(	O
&	O
cmd	enum
->	O
options	pointer
,	O
0	int
)	O
)	O
;	O
}	O
p	pointer
=	O
strchr	function
(	O
argdef	pointer
,	O
'='	O
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
*	O
p	pointer
=	O
0	int
;	O
if	O
(	O
p	pointer
[	O
-	O
1	int
]	O
==	O
'['	O
&&	O
mu_string_suffix	function
(	O
argdef	pointer
,	O
"]"	pointer
)	O
)	O
{	O
*	O
type	int
=	O
mu_tesh_arg_optional	int
;	O
p	pointer
[	O
-	O
1	int
]	O
=	O
0	int
;	O
}	O
else	O
*	O
type	int
=	O
mu_tesh_arg_required	int
;	O
}	O
else	O
*	O
type	int
=	O
mu_tesh_noarg	int
;	O
MU_ASSERT	O
(	O
mu_assoc_install	function
(	O
cmd	enum
->	O
options	pointer
,	O
argdef	pointer
,	O
type	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
mu_string_prefix	function
(	O
argdef	pointer
,	O
"["	pointer
)	O
)	O
{	O
int	O
j	int
;	O
int	O
lev	int
=	O
0	int
;	O
for	O
(	O
j	int
=	O
i	long
;	O
j	int
<	O
ws	pointer
.	O
ws_wordc	long
;	O
)	O
{	O
if	O
(	O
mu_string_prefix	function
(	O
ws	pointer
.	O
ws_wordv	pointer
[	O
j	int
]	O
,	O
"["	pointer
)	O
)	O
lev	int
++	O
;	O
if	O
(	O
mu_string_suffix	function
(	O
ws	pointer
.	O
ws_wordv	pointer
[	O
j	int
]	O
,	O
"]"	pointer
)	O
)	O
lev	int
--	O
;	O
j	int
++	O
;	O
if	O
(	O
lev	int
==	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
lev	int
==	O
0	int
)	O
{	O
cmd	enum
->	O
param_max	int
+=	O
j	int
-	O
i	long
;	O
i	long
=	O
j	int
;	O
}	O
}	O
else	O
{	O
cmd	enum
->	O
param_min	int
++	O
;	O
cmd	enum
->	O
param_max	int
++	O
;	O
}	O
}	O
if	O
(	O
!	O
variadic	int
&&	O
mu_string_prefix	function
(	O
ws	pointer
.	O
ws_wordv	pointer
[	O
ws	pointer
.	O
ws_wordc	long
-	O
1	int
]	O
,	O
"["	pointer
)	O
&&	O
mu_string_suffix	function
(	O
ws	pointer
.	O
ws_wordv	pointer
[	O
ws	pointer
.	O
ws_wordc	long
-	O
1	int
]	O
,	O
"...]"	pointer
)	O
)	O
{	O
variadic	int
=	O
1	int
;	O
}	O
if	O
(	O
variadic	int
)	O
cmd	enum
->	O
param_max	int
=	O
VARIADIC	O
;	O
mu_wordsplit_free	function
(	O
&	O
ws	pointer
)	O
;	O
}	O
}	O
if	O
(	O
cmd	enum
->	O
options	pointer
)	O
{	O
int	O
i	long
;	O
MU_ASSERT	O
(	O
mu_assoc_create	function
(	O
&	O
options	pointer
,	O
0	int
)	O
)	O
;	O
for	O
(	O
i	long
=	O
1	int
;	O
i	long
<	O
argc	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	long
]	O
,	O
"--"	pointer
)	O
==	O
0	int
)	O
{	O
i	long
++	O
;	O
break	O
;	O
}	O
if	O
(	O
argv	pointer
[	O
i	long
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
int	O
*	O
type	int
;	O
char	O
*	O
opt	pointer
=	O
argv	pointer
[	O
i	long
]	O
;	O
char	O
*	O
arg	pointer
;	O
arg	pointer
=	O
strchr	function
(	O
opt	pointer
,	O
'='	O
)	O
;	O
if	O
(	O
arg	pointer
)	O
*	O
arg	pointer
++	O
=	O
0	int
;	O
rc	int
=	O
mu_assoc_lookup	function
(	O
cmd	enum
->	O
options	pointer
,	O
opt	pointer
+	O
1	int
,	O
&	O
type	int
)	O
;	O
if	O
(	O
rc	int
==	O
MU_ERR_NOENT	O
)	O
{	O
mu_error	function
(	O
"%s: no such option %s"	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
opt	pointer
)	O
;	O
mu_assoc_destroy	function
(	O
&	O
options	pointer
)	O
;	O
return	O
MU_ERR_NOENT	O
;	O
}	O
if	O
(	O
arg	pointer
)	O
{	O
if	O
(	O
*	O
type	int
==	O
mu_tesh_noarg	int
)	O
{	O
mu_error	function
(	O
"%s: option %s doesn't take argument"	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
opt	pointer
)	O
;	O
mu_assoc_destroy	function
(	O
&	O
options	pointer
)	O
;	O
return	O
MU_ERR_PARSE	O
;	O
}	O
}	O
else	O
if	O
(	O
*	O
type	int
==	O
mu_tesh_arg_required	int
)	O
{	O
if	O
(	O
i	long
+	O
1	int
<	O
argc	long
)	O
arg	pointer
=	O
argv	pointer
[	O
++	O
i	long
]	O
;	O
else	O
{	O
mu_error	function
(	O
"%s: option %s requires argument"	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
opt	pointer
)	O
;	O
mu_assoc_destroy	function
(	O
&	O
options	pointer
)	O
;	O
return	O
MU_ERR_PARSE	O
;	O
}	O
}	O
if	O
(	O
arg	pointer
)	O
arg	pointer
=	O
mu_strdup	function
(	O
arg	pointer
)	O
;	O
MU_ASSERT	O
(	O
mu_assoc_install	function
(	O
options	pointer
,	O
opt	pointer
+	O
1	int
,	O
arg	pointer
)	O
)	O
;	O
}	O
else	O
break	O
;	O
}	O
if	O
(	O
i	long
>	O
1	int
)	O
{	O
char	O
*	O
t	long
;	O
--	O
i	long
;	O
t	long
=	O
argv	pointer
[	O
i	long
]	O
;	O
argv	pointer
[	O
i	long
]	O
=	O
argv	pointer
[	O
0	int
]	O
;	O
argv	pointer
[	O
0	int
]	O
=	O
t	long
;	O
argc	long
-=	O
i	long
;	O
argv	pointer
+=	O
i	long
;	O
}	O
}	O
if	O
(	O
argc	long
<	O
cmd	enum
->	O
param_min	int
)	O
{	O
mu_error	function
(	O
"%s: not enough arguments"	pointer
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
return	O
MU_ERR_PARSE	O
;	O
}	O
if	O
(	O
cmd	enum
->	O
param_max	int
!=	O
VARIADIC	O
&&	O
argc	long
>	O
cmd	enum
->	O
param_max	int
)	O
{	O
mu_error	function
(	O
"%s: too many arguments"	pointer
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
return	O
MU_ERR_PARSE	O
;	O
}	O
rc	int
=	O
cmdspecial	function
(	O
"__ENVINIT__"	pointer
,	O
cmdtab	pointer
,	O
argc	long
,	O
argv	pointer
,	O
options	pointer
,	O
env	pointer
,	O
0	int
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
rc	int
=	O
cmd	enum
->	O
func	pointer
(	O
argc	long
,	O
argv	pointer
,	O
options	pointer
,	O
env	pointer
)	O
;	O
cmdspecial	function
(	O
"__ENVFINI__"	pointer
,	O
cmdtab	pointer
,	O
argc	long
,	O
argv	pointer
,	O
options	pointer
,	O
env	pointer
,	O
0	int
)	O
;	O
}	O
mu_assoc_destroy	function
(	O
&	O
options	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
void	O
cleanup	function
(	O
struct	O
mu_tesh_command	struct
*	O
cmd	enum
)	O
{	O
while	O
(	O
cmd	enum
->	O
verb	pointer
)	O
{	O
mu_assoc_destroy	function
(	O
&	O
cmd	enum
->	O
options	pointer
)	O
;	O
cmd	enum
++	O
;	O
}	O
}	O
void	O
mu_tesh_read_and_eval	function
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	pointer
,	O
struct	O
mu_tesh_command	struct
*	O
cmd	enum
,	O
void	O
*	O
env	pointer
)	O
{	O
if	O
(	O
argc	long
)	O
{	O
while	O
(	O
argc	long
)	O
{	O
int	O
i	long
,	O
n	pointer
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
argc	long
;	O
i	long
++	O
)	O
{	O
size_t	long
len	long
=	O
strlen	function
(	O
argv	pointer
[	O
i	long
]	O
)	O
;	O
if	O
(	O
argv	pointer
[	O
i	long
]	O
[	O
len	long
-	O
1	int
]	O
==	O
';'	O
)	O
{	O
if	O
(	O
len	long
==	O
1	int
)	O
n	pointer
=	O
1	int
;	O
else	O
argv	pointer
[	O
i	long
]	O
[	O
len	long
-	O
1	int
]	O
=	O
0	int
;	O
i	long
++	O
;	O
break	O
;	O
}	O
}	O
interpret	function
(	O
i	long
-	O
n	pointer
,	O
argv	pointer
,	O
cmd	enum
,	O
env	pointer
)	O
;	O
argc	long
-=	O
i	long
;	O
argv	pointer
+=	O
i	long
;	O
}	O
}	O
else	O
{	O
char	O
*	O
buf	pointer
=	O
NULL	O
;	O
size_t	long
size	long
=	O
0	int
,	O
n	pointer
;	O
struct	O
mu_wordsplit	struct
ws	pointer
;	O
int	O
wsflags	int
;	O
int	O
rc	int
;	O
wsflags	int
=	O
MU_WRDSF_DEFFLAGS	O
|	O
MU_WRDSF_COMMENT	O
|	O
MU_WRDSF_ALLOC_DIE	O
|	O
MU_WRDSF_SHOWERR	O
;	O
ws	pointer
.	O
ws_comment	pointer
=	O
"#"	pointer
;	O
while	O
(	O
(	O
rc	int
=	O
mu_stream_getline	function
(	O
mu_strin	pointer
,	O
&	O
buf	pointer
,	O
&	O
size	long
,	O
&	O
n	pointer
)	O
)	O
==	O
0	int
&&	O
n	pointer
>	O
0	int
)	O
{	O
char	O
*	O
larg	array
[	O
2	int
]	O
;	O
mu_ltrim_class	function
(	O
buf	pointer
,	O
MU_CTYPE_SPACE	int
)	O
;	O
mu_rtrim_class	function
(	O
buf	pointer
,	O
MU_CTYPE_SPACE	int
)	O
;	O
larg	array
[	O
0	int
]	O
=	O
buf	pointer
;	O
larg	array
[	O
1	int
]	O
=	O
NULL	O
;	O
if	O
(	O
!	O
cmdspecial	function
(	O
"__LINEPROC__"	pointer
,	O
cmd	enum
,	O
1	int
,	O
larg	array
,	O
NULL	O
,	O
env	pointer
,	O
MU_ERR_NOENT	O
)	O
)	O
continue	O
;	O
MU_ASSERT	O
(	O
mu_wordsplit	struct
(	O
larg	array
[	O
0	int
]	O
,	O
&	O
ws	pointer
,	O
wsflags	int
)	O
)	O
;	O
wsflags	int
|=	O
MU_WRDSF_REUSE	O
;	O
if	O
(	O
ws	pointer
.	O
ws_wordc	long
==	O
0	int
)	O
continue	O
;	O
interpret	function
(	O
ws	pointer
.	O
ws_wordc	long
,	O
ws	pointer
.	O
ws_wordv	pointer
,	O
cmd	enum
,	O
env	pointer
)	O
;	O
}	O
if	O
(	O
wsflags	int
&	O
MU_WRDSF_REUSE	O
)	O
mu_wordsplit_free	function
(	O
&	O
ws	pointer
)	O
;	O
}	O
cleanup	function
(	O
cmd	enum
)	O
;	O
}	O
void	O
mu_tesh_init	function
(	O
char	O
const	O
*	O
argv0	pointer
)	O
{	O
mu_set_program_name	function
(	O
argv0	pointer
)	O
;	O
mu_stdstream_setup	function
(	O
MU_STDSTREAM_RESET_NONE	int
)	O
;	O
}	O
void	O
mu_tesh_help	function
(	O
struct	O
mu_tesh_command	struct
*	O
cmd	enum
,	O
void	O
*	O
env	pointer
)	O
{	O
cmdspecial	function
(	O
"__HELPINIT__"	pointer
,	O
cmd	enum
,	O
0	int
,	O
NULL	O
,	O
NULL	O
,	O
env	pointer
,	O
0	int
)	O
;	O
for	O
(	O
;	O
cmd	enum
->	O
verb	pointer
;	O
cmd	enum
++	O
)	O
if	O
(	O
!	O
is_reserved	function
(	O
cmd	enum
->	O
verb	pointer
)	O
)	O
mu_printf	function
(	O
" %s %s\n"	pointer
,	O
cmd	enum
->	O
verb	pointer
,	O
cmd	enum
->	O
args	pointer
)	O
;	O
cmdspecial	function
(	O
"__HELPFINI__"	pointer
,	O
cmd	enum
,	O
0	int
,	O
NULL	O
,	O
NULL	O
,	O
env	pointer
,	O
0	int
)	O
;	O
}	O
