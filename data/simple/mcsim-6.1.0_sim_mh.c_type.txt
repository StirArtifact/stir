void	O
CalculateMeanAndVariance	function
(	O
long	O
n	int
,	O
double	O
x	pointer
,	O
double	O
*	O
xi_bari	pointer
,	O
double	O
*	O
si_2i	pointer
)	O
{	O
if	O
(	O
n	int
==	O
1	int
)	O
{	O
*	O
xi_bari	pointer
=	O
x	pointer
;	O
*	O
si_2i	pointer
=	O
0	int
;	O
return	O
;	O
}	O
double	O
mTmp	double
=	O
*	O
xi_bari	pointer
;	O
*	O
xi_bari	pointer
=	O
*	O
xi_bari	pointer
+	O
(	O
x	pointer
-	O
*	O
xi_bari	pointer
)	O
/	O
n	int
;	O
*	O
si_2i	pointer
=	O
*	O
si_2i	pointer
+	O
(	O
x	pointer
-	O
mTmp	double
)	O
*	O
(	O
x	pointer
-	O
*	O
xi_bari	pointer
)	O
;	O
}	O
int	O
checkConvergence	function
(	O
int	O
nOut	int
,	O
int	O
variableCount	int
,	O
int	O
p_count	int
,	O
double	O
*	O
*	O
meansForAll	pointer
,	O
double	O
*	O
*	O
varsForAll	pointer
,	O
double	O
*	O
Rhat	pointer
)	O
{	O
int	O
vi	int
,	O
pi	int
;	O
int	O
converged	int
=	O
0	int
;	O
double	O
varsofvars	double
,	O
meansofmeans	double
,	O
varsofmeans	double
,	O
meansofvars	double
;	O
for	O
(	O
vi	int
=	O
0	int
;	O
vi	int
<	O
variableCount	int
;	O
vi	int
++	O
)	O
{	O
meansofmeans	double
=	O
0.0	int
;	O
for	O
(	O
pi	int
=	O
0	int
;	O
pi	int
<	O
p_count	int
;	O
pi	int
++	O
)	O
{	O
CalculateMeanAndVariance	function
(	O
(	O
pi	int
+	O
1	int
)	O
,	O
meansForAll	pointer
[	O
pi	int
]	O
[	O
vi	int
]	O
,	O
&	O
meansofmeans	double
,	O
&	O
varsofmeans	double
)	O
;	O
CalculateMeanAndVariance	function
(	O
(	O
pi	int
+	O
1	int
)	O
,	O
varsForAll	pointer
[	O
pi	int
]	O
[	O
vi	int
]	O
,	O
&	O
meansofvars	double
,	O
&	O
varsofvars	double
)	O
;	O
}	O
if	O
(	O
(	O
meansofvars	double
==	O
0	int
)	O
&&	O
(	O
varsofmeans	double
==	O
0	int
)	O
)	O
{	O
*	O
Rhat	pointer
=	O
1	int
;	O
converged	int
++	O
;	O
}	O
else	O
{	O
double	O
s2	double
=	O
(	O
(	O
nOut	int
-	O
1	int
)	O
*	O
meansofvars	double
+	O
varsofmeans	double
)	O
/	O
nOut	int
;	O
double	O
Vhat	double
=	O
s2	double
+	O
varsofmeans	double
/	O
(	O
nOut	int
*	O
p_count	int
)	O
;	O
*	O
Rhat	pointer
=	O
Vhat	double
/	O
meansofvars	double
;	O
if	O
(	O
*	O
Rhat	pointer
<	O
1.05	int
)	O
converged	int
++	O
;	O
}	O
}	O
return	O
converged	int
;	O
}	O
void	O
CollectConvInfo	function
(	O
PLEVEL	pointer
plevel	pointer
,	O
char	O
*	O
*	O
args	pointer
)	O
{	O
double	O
*	O
*	O
mean_dest	pointer
=	O
(	O
double	O
*	O
*	O
)	O
args	pointer
[	O
0	int
]	O
;	O
double	O
*	O
*	O
var_dest	pointer
=	O
(	O
double	O
*	O
*	O
)	O
args	pointer
[	O
1	int
]	O
;	O
long	O
*	O
n	int
=	O
(	O
long	O
*	O
)	O
args	pointer
[	O
2	int
]	O
;	O
long	O
i	long
;	O
PMCVAR	pointer
pMCVar	pointer
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
plevel	pointer
->	O
nMCVars	long
;	O
i	long
++	O
)	O
{	O
pMCVar	pointer
=	O
plevel	pointer
->	O
rgpMCVars	pointer
[	O
i	long
]	O
;	O
*	O
*	O
mean_dest	pointer
=	O
pMCVar	pointer
->	O
dVal_mean	double
;	O
*	O
*	O
var_dest	pointer
=	O
pMCVar	pointer
->	O
dVal_var	double
/	O
(	O
*	O
n	int
-	O
1	int
)	O
;	O
(	O
*	O
mean_dest	pointer
)	O
++	O
;	O
(	O
*	O
var_dest	pointer
)	O
++	O
;	O
}	O
}	O
void	O
AnnounceMarkov	function
(	O
int	O
size	int
,	O
int	O
nSimTypeFlag	long
,	O
long	O
nIter	long
)	O
{	O
switch	O
(	O
nSimTypeFlag	long
)	O
{	O
case	O
0	int
:	O
printf	function
(	O
"\nDoing %ld Metropolis within Gibbs simulation"	pointer
,	O
nIter	long
)	O
;	O
printf	function
(	O
(	O
nIter	long
!=	O
1	int
?	O
"s"	pointer
:	O
""	pointer
)	O
)	O
;	O
if	O
(	O
size	int
>	O
1	int
)	O
printf	function
(	O
" on each of %d processors\n"	pointer
,	O
size	int
)	O
;	O
else	O
printf	function
(	O
"\n"	pointer
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	function
(	O
"\nPrinting data and predictions for the last line of the "	pointer
"restart file\n"	pointer
)	O
;	O
break	O
;	O
case	O
2	int
:	O
printf	function
(	O
"\nDoing %ld Metropolis-Hastings simulation"	pointer
,	O
nIter	long
)	O
;	O
printf	function
(	O
(	O
nIter	long
!=	O
1	int
?	O
"s"	pointer
:	O
""	pointer
)	O
)	O
;	O
if	O
(	O
size	int
>	O
1	int
)	O
printf	function
(	O
" on each of %d processors\n"	pointer
,	O
size	int
)	O
;	O
else	O
printf	function
(	O
"\n"	pointer
)	O
;	O
break	O
;	O
case	O
3	int
:	O
printf	function
(	O
"\nDoing %ld Metropolis within Gibbs posterior "	pointer
"tempered simulation"	pointer
,	O
nIter	long
)	O
;	O
printf	function
(	O
(	O
nIter	long
!=	O
1	int
?	O
"s\n"	pointer
:	O
"\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
4	int
:	O
printf	function
(	O
"\nDoing %ld Metropolis within Gibbs likelihood "	pointer
"tempered simulation"	pointer
,	O
nIter	long
)	O
;	O
printf	function
(	O
(	O
nIter	long
!=	O
1	int
?	O
"s\n"	pointer
:	O
"\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
5	int
:	O
printf	function
(	O
"\nDoing Stochastic optimization\n"	pointer
)	O
;	O
break	O
;	O
}	O
}	O
void	O
CalculateTotals	function
(	O
PLEVEL	pointer
plevel	pointer
,	O
char	O
*	O
*	O
args	pointer
)	O
{	O
PANALYSIS	pointer
panal	pointer
=	O
(	O
PANALYSIS	pointer
)	O
args	pointer
[	O
0	int
]	O
;	O
double	O
*	O
pdLnPrior	pointer
=	O
(	O
double	O
*	O
)	O
args	pointer
[	O
1	int
]	O
;	O
long	O
n	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	pointer
->	O
nMCVars	long
;	O
n	int
++	O
)	O
{	O
*	O
pdLnPrior	pointer
+=	O
LnDensity	function
(	O
plevel	pointer
->	O
rgpMCVars	pointer
[	O
n	int
]	O
,	O
panal	pointer
)	O
;	O
}	O
}	O
void	O
CheckForFixed	function
(	O
PLEVEL	pointer
plevel	pointer
,	O
char	O
*	O
*	O
args	pointer
)	O
{	O
long	O
n	int
,	O
m	long
;	O
PMCVAR	pointer
pMCVar	pointer
;	O
PVARMOD	pointer
pFVar	pointer
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	pointer
->	O
nMCVars	long
;	O
n	int
++	O
)	O
{	O
pMCVar	pointer
=	O
plevel	pointer
->	O
rgpMCVars	pointer
[	O
n	int
]	O
;	O
for	O
(	O
m	long
=	O
0	int
;	O
m	long
<	O
plevel	pointer
->	O
nFixedVars	long
;	O
m	long
++	O
)	O
{	O
pFVar	pointer
=	O
plevel	pointer
->	O
rgpFixedVars	pointer
[	O
m	long
]	O
;	O
if	O
(	O
pMCVar	pointer
->	O
hvar	long
==	O
pFVar	pointer
->	O
hvar	long
)	O
{	O
pMCVar	pointer
->	O
bIsFixed	int
=	O
TRUE	int
;	O
if	O
(	O
IsInput	function
(	O
pFVar	pointer
->	O
hvar	long
)	O
)	O
{	O
printf	function
(	O
"Error: a sampled parameter cannot be assigned an input\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
else	O
pMCVar	pointer
->	O
dVal	double
=	O
pFVar	pointer
->	O
uvar	union
.	O
dVal	double
;	O
}	O
}	O
}	O
}	O
void	O
CheckPrintStatements	function
(	O
PLEVEL	pointer
plevel	pointer
,	O
char	O
*	O
*	O
args	pointer
)	O
{	O
PANALYSIS	pointer
panal	pointer
=	O
(	O
PANALYSIS	pointer
)	O
args	pointer
[	O
0	int
]	O
;	O
POUTSPEC	pointer
pos	pointer
;	O
long	O
i	long
,	O
j	long
;	O
if	O
(	O
plevel	pointer
->	O
pexpt	pointer
==	O
NULL	O
)	O
return	O
;	O
pos	pointer
=	O
&	O
(	O
plevel	pointer
->	O
pexpt	pointer
->	O
os	struct
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
pos	pointer
->	O
nOutputs	int
;	O
j	long
++	O
)	O
for	O
(	O
i	long
=	O
j	long
+	O
1	int
;	O
i	long
<	O
pos	pointer
->	O
nOutputs	int
;	O
i	long
++	O
)	O
if	O
(	O
pos	pointer
->	O
phvar_out	pointer
[	O
j	long
]	O
==	O
pos	pointer
->	O
phvar_out	pointer
[	O
i	long
]	O
)	O
ReportRunTimeError	function
(	O
panal	pointer
,	O
RE_DUPVARINEXPRT	int
|	O
RE_FATAL	int
,	O
pos	pointer
->	O
pszOutputNames	pointer
[	O
i	long
]	O
,	O
"Print"	pointer
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
pos	pointer
->	O
nData	int
;	O
j	long
++	O
)	O
for	O
(	O
i	long
=	O
j	long
+	O
1	int
;	O
i	long
<	O
pos	pointer
->	O
nData	int
;	O
i	long
++	O
)	O
if	O
(	O
pos	pointer
->	O
phvar_dat	pointer
[	O
j	long
]	O
==	O
pos	pointer
->	O
phvar_dat	pointer
[	O
i	long
]	O
)	O
ReportRunTimeError	function
(	O
panal	pointer
,	O
RE_DUPVARINEXPRT	int
|	O
RE_FATAL	int
,	O
pos	pointer
->	O
pszDataNames	pointer
[	O
i	long
]	O
,	O
"Data"	pointer
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
pos	pointer
->	O
nOutputs	int
;	O
j	long
++	O
)	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
pos	pointer
->	O
nData	int
;	O
i	long
++	O
)	O
if	O
(	O
(	O
pos	pointer
->	O
phvar_out	pointer
[	O
j	long
]	O
==	O
pos	pointer
->	O
phvar_dat	pointer
[	O
i	long
]	O
)	O
&&	O
(	O
pos	pointer
->	O
pcOutputTimes	pointer
[	O
j	long
]	O
!=	O
pos	pointer
->	O
pcData	pointer
[	O
i	long
]	O
)	O
)	O
{	O
printf	function
(	O
"\nError: unequal times in Print and Data statements for %s\n"	pointer
"Exiting.\n\n"	pointer
,	O
pos	pointer
->	O
pszOutputNames	pointer
[	O
j	long
]	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
}	O
BOOL	int
CheckAllTransitions	function
(	O
PGIBBSDATA	pointer
pgd	pointer
)	O
{	O
BOOL	int
bOK	int
;	O
double	O
AcceptRate	double
;	O
int	O
i	long
;	O
i	long
=	O
pgd	pointer
->	O
startT	int
;	O
bOK	int
=	O
TRUE	int
;	O
while	O
(	O
(	O
i	long
<=	O
pgd	pointer
->	O
endT	int
-	O
1	int
)	O
&&	O
bOK	int
)	O
{	O
if	O
(	O
pgd	pointer
->	O
rglTransAttempts	pointer
[	O
i	long
]	O
<	O
10	int
)	O
{	O
bOK	int
=	O
FALSE	int
;	O
break	O
;	O
}	O
else	O
AcceptRate	double
=	O
pgd	pointer
->	O
rglTransAccepts	pointer
[	O
i	long
]	O
/	O
(	O
(	O
double	O
)	O
pgd	pointer
->	O
rglTransAttempts	pointer
[	O
i	long
]	O
)	O
;	O
bOK	int
=	O
(	O
AcceptRate	double
>	O
0.15	int
)	O
;	O
i	long
++	O
;	O
}	O
return	O
bOK	int
;	O
}	O
int	O
CheckTransitions	function
(	O
PGIBBSDATA	pointer
pgd	pointer
)	O
{	O
double	O
AcceptRate	double
;	O
int	O
i	long
;	O
i	long
=	O
pgd	pointer
->	O
startT	int
;	O
if	O
(	O
pgd	pointer
->	O
rglTransAttempts	pointer
[	O
i	long
]	O
<	O
10	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
else	O
AcceptRate	double
=	O
pgd	pointer
->	O
rglTransAccepts	pointer
[	O
i	long
]	O
/	O
(	O
(	O
double	O
)	O
pgd	pointer
->	O
rglTransAttempts	pointer
[	O
i	long
]	O
)	O
;	O
if	O
(	O
AcceptRate	double
<	O
0.30	int
)	O
{	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
AcceptRate	double
<	O
1	int
)	O
{	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
{	O
return	O
(	O
+	O
1	int
)	O
;	O
}	O
}	O
}	O
void	O
CloneLikes	function
(	O
PLEVEL	pointer
plevel	pointer
,	O
char	O
*	O
*	O
args	pointer
)	O
{	O
long	O
nLikes	long
;	O
long	O
i	long
,	O
j	long
,	O
k	pointer
;	O
PLEVEL	pointer
pLower	pointer
;	O
PMCVAR	pointer
pClone	pointer
;	O
PMCVAR	pointer
pMCVar	pointer
;	O
BOOL	int
bFound	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
plevel	pointer
->	O
iInstances	int
;	O
i	long
++	O
)	O
{	O
pLower	pointer
=	O
plevel	pointer
->	O
pLevels	array
[	O
i	long
]	O
;	O
pLower	pointer
->	O
nLikes	long
=	O
nLikes	long
=	O
plevel	pointer
->	O
nLikes	long
+	O
ListLength	O
(	O
plevel	pointer
->	O
plistLikes	pointer
)	O
;	O
if	O
(	O
pLower	pointer
->	O
nLikes	long
!=	O
0	int
)	O
{	O
if	O
(	O
!	O
(	O
pLower	pointer
->	O
rgpLikes	pointer
=	O
(	O
PMCVAR	pointer
*	O
)	O
malloc	function
(	O
pLower	pointer
->	O
nLikes	long
*	O
sizeof	O
(	O
PMCVAR	pointer
)	O
)	O
)	O
)	O
ReportError	function
(	O
NULL	O
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"CloneLikes"	pointer
,	O
NULL	O
)	O
;	O
}	O
}	O
nLikes	long
=	O
0	int
;	O
ForAllList3	function
(	O
plevel	pointer
->	O
plistLikes	pointer
,	O
&	O
CloneLikesL	function
,	O
plevel	pointer
,	O
&	O
nLikes	long
,	O
NULL	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
plevel	pointer
->	O
iInstances	int
;	O
i	long
++	O
)	O
{	O
pLower	pointer
=	O
plevel	pointer
->	O
pLevels	array
[	O
i	long
]	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
plevel	pointer
->	O
nLikes	long
;	O
j	long
++	O
)	O
{	O
pMCVar	pointer
=	O
plevel	pointer
->	O
rgpLikes	pointer
[	O
j	long
]	O
;	O
bFound	int
=	O
FALSE	int
;	O
k	pointer
=	O
0	int
;	O
while	O
(	O
(	O
k	pointer
<	O
nLikes	long
)	O
&&	O
(	O
!	O
bFound	int
)	O
)	O
{	O
bFound	int
=	O
(	O
pMCVar	pointer
->	O
hvar	long
==	O
pLower	pointer
->	O
rgpLikes	pointer
[	O
k	pointer
]	O
->	O
hvar	long
)	O
;	O
if	O
(	O
!	O
bFound	int
)	O
k	pointer
++	O
;	O
}	O
if	O
(	O
!	O
bFound	int
)	O
{	O
if	O
(	O
!	O
(	O
pClone	pointer
=	O
(	O
PMCVAR	pointer
)	O
malloc	function
(	O
sizeof	O
(	O
MCVAR	struct
)	O
)	O
)	O
)	O
ReportError	function
(	O
NULL	O
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"CloneLikes"	pointer
,	O
NULL	O
)	O
;	O
memcpy	function
(	O
pClone	pointer
,	O
pMCVar	pointer
,	O
sizeof	O
(	O
MCVAR	struct
)	O
)	O
;	O
pLower	pointer
->	O
rgpLikes	pointer
[	O
nLikes	long
+	O
j	long
]	O
=	O
pClone	pointer
;	O
}	O
}	O
}	O
}	O
void	O
CloneLikesL	function
(	O
PVOID	pointer
pData	pointer
,	O
PVOID	pointer
pUser1	pointer
,	O
PVOID	pointer
pUser2	pointer
,	O
PVOID	pointer
pUser3	pointer
)	O
{	O
PMCVAR	pointer
pMCVar	pointer
=	O
(	O
PMCVAR	pointer
)	O
pData	pointer
;	O
PLEVEL	pointer
plevel	pointer
=	O
(	O
PLEVEL	pointer
)	O
pUser1	pointer
;	O
long	O
*	O
pnLikes	pointer
=	O
(	O
long	O
*	O
)	O
pUser2	pointer
;	O
long	O
i	long
;	O
PLEVEL	pointer
pLower	pointer
;	O
PMCVAR	pointer
pClone	pointer
;	O
++	O
pMCVar	pointer
->	O
iDepth	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
plevel	pointer
->	O
iInstances	int
;	O
i	long
++	O
)	O
{	O
pLower	pointer
=	O
plevel	pointer
->	O
pLevels	array
[	O
i	long
]	O
;	O
if	O
(	O
!	O
(	O
pClone	pointer
=	O
(	O
PMCVAR	pointer
)	O
malloc	function
(	O
sizeof	O
(	O
MCVAR	struct
)	O
)	O
)	O
)	O
ReportError	function
(	O
NULL	O
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"CloneLikeL"	pointer
,	O
NULL	O
)	O
;	O
memcpy	function
(	O
pClone	pointer
,	O
pMCVar	pointer
,	O
sizeof	O
(	O
MCVAR	struct
)	O
)	O
;	O
pLower	pointer
->	O
rgpLikes	pointer
[	O
*	O
pnLikes	pointer
]	O
=	O
pClone	pointer
;	O
}	O
++	O
(	O
*	O
pnLikes	pointer
)	O
;	O
}	O
void	O
CloneMCVars	function
(	O
PLEVEL	pointer
plevel	pointer
,	O
char	O
*	O
*	O
args	pointer
)	O
{	O
long	O
nMCVars	long
=	O
ListLength	O
(	O
plevel	pointer
->	O
plistMCVars	pointer
)	O
;	O
long	O
n	int
;	O
PLEVEL	pointer
pLower	pointer
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	pointer
->	O
iInstances	int
;	O
n	int
++	O
)	O
{	O
pLower	pointer
=	O
plevel	pointer
->	O
pLevels	array
[	O
n	int
]	O
;	O
pLower	pointer
->	O
nMCVars	long
=	O
nMCVars	long
;	O
if	O
(	O
nMCVars	long
!=	O
0	int
)	O
{	O
if	O
(	O
!	O
(	O
pLower	pointer
->	O
rgpMCVars	pointer
=	O
(	O
PMCVAR	pointer
*	O
)	O
malloc	function
(	O
nMCVars	long
*	O
sizeof	O
(	O
PMCVAR	pointer
)	O
)	O
)	O
)	O
ReportError	function
(	O
NULL	O
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"CloneMCVars"	pointer
,	O
NULL	O
)	O
;	O
}	O
}	O
nMCVars	long
=	O
0	int
;	O
ForAllList3	function
(	O
plevel	pointer
->	O
plistMCVars	pointer
,	O
&	O
CloneMCVarsL	function
,	O
plevel	pointer
,	O
&	O
nMCVars	long
,	O
NULL	O
)	O
;	O
}	O
void	O
CloneMCVarsL	function
(	O
PVOID	pointer
pData	pointer
,	O
PVOID	pointer
pUser1	pointer
,	O
PVOID	pointer
pUser2	pointer
,	O
PVOID	pointer
pUser3	pointer
)	O
{	O
PMCVAR	pointer
pMCVar	pointer
=	O
(	O
PMCVAR	pointer
)	O
pData	pointer
;	O
PLEVEL	pointer
plevel	pointer
=	O
(	O
PLEVEL	pointer
)	O
pUser1	pointer
;	O
long	O
*	O
pnMCVars	pointer
=	O
(	O
long	O
*	O
)	O
pUser2	pointer
;	O
long	O
i	long
;	O
PLEVEL	pointer
pLower	pointer
;	O
PMCVAR	pointer
pClone	pointer
;	O
++	O
pMCVar	pointer
->	O
iDepth	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
plevel	pointer
->	O
iInstances	int
;	O
i	long
++	O
)	O
{	O
pLower	pointer
=	O
plevel	pointer
->	O
pLevels	array
[	O
i	long
]	O
;	O
if	O
(	O
!	O
(	O
pClone	pointer
=	O
(	O
PMCVAR	pointer
)	O
malloc	function
(	O
sizeof	O
(	O
MCVAR	struct
)	O
)	O
)	O
)	O
ReportError	function
(	O
NULL	O
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"CloneMCVarsL"	pointer
,	O
NULL	O
)	O
;	O
memcpy	function
(	O
pClone	pointer
,	O
pMCVar	pointer
,	O
sizeof	O
(	O
MCVAR	struct
)	O
)	O
;	O
pClone	pointer
->	O
plistDependents	pointer
=	O
InitList	function
(	O
)	O
;	O
pLower	pointer
->	O
rgpMCVars	pointer
[	O
*	O
pnMCVars	pointer
]	O
=	O
pClone	pointer
;	O
}	O
++	O
(	O
*	O
pnMCVars	pointer
)	O
;	O
}	O
void	O
CloseMarkovFiles	function
(	O
PGIBBSDATA	pointer
pgd	pointer
)	O
{	O
if	O
(	O
(	O
pgd	pointer
->	O
nSimTypeFlag	long
==	O
3	int
)	O
||	O
(	O
pgd	pointer
->	O
nSimTypeFlag	long
==	O
4	int
)	O
)	O
{	O
char	O
szFileName	array
[	O
MAX_FILENAMESIZE	int
+	O
6	int
]	O
;	O
sprintf	function
(	O
szFileName	array
,	O
"%s%s"	pointer
,	O
pgd	pointer
->	O
szGout	pointer
,	O
".perks"	pointer
)	O
;	O
fclose	function
(	O
pgd	pointer
->	O
pfilePerks	pointer
)	O
;	O
printf	function
(	O
"\nWrote perks to \"%s\"\n"	pointer
,	O
szFileName	array
)	O
;	O
}	O
if	O
(	O
pgd	pointer
->	O
pfileOut	pointer
)	O
{	O
fclose	function
(	O
pgd	pointer
->	O
pfileOut	pointer
)	O
;	O
printf	function
(	O
"Wrote MCMC sample to \"%s\"\n"	pointer
,	O
pgd	pointer
->	O
szGout	pointer
)	O
;	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
void	O
ConvertLists	function
(	O
PLEVEL	pointer
plevel	pointer
,	O
char	O
*	O
*	O
args	pointer
)	O
{	O
PANALYSIS	pointer
panal	pointer
=	O
(	O
PANALYSIS	pointer
)	O
args	pointer
[	O
0	int
]	O
;	O
long	O
m	long
,	O
n	int
;	O
PMCVAR	pointer
pMCVar	pointer
;	O
if	O
(	O
plevel	pointer
->	O
pexpt	pointer
==	O
NULL	O
)	O
ListToPVArray	function
(	O
panal	pointer
,	O
plevel	pointer
->	O
plistVars	pointer
,	O
&	O
plevel	pointer
->	O
nFixedVars	long
,	O
&	O
plevel	pointer
->	O
rgpFixedVars	pointer
)	O
;	O
else	O
ListToPVArray	function
(	O
panal	pointer
,	O
plevel	pointer
->	O
pexpt	pointer
->	O
plistParmMods	pointer
,	O
&	O
plevel	pointer
->	O
nFixedVars	long
,	O
&	O
plevel	pointer
->	O
rgpFixedVars	pointer
)	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	pointer
->	O
nMCVars	long
;	O
n	int
++	O
)	O
{	O
pMCVar	pointer
=	O
plevel	pointer
->	O
rgpMCVars	pointer
[	O
n	int
]	O
;	O
ListToPMCArray	function
(	O
panal	pointer
,	O
pMCVar	pointer
->	O
plistDependents	pointer
,	O
&	O
pMCVar	pointer
->	O
nDependents	long
,	O
&	O
pMCVar	pointer
->	O
rgpDependents	pointer
)	O
;	O
if	O
(	O
pMCVar	pointer
->	O
nDependents	long
==	O
0	int
)	O
pMCVar	pointer
->	O
bExptIsDep	int
=	O
TRUE	int
;	O
else	O
{	O
m	long
=	O
0	int
;	O
while	O
(	O
(	O
m	long
<	O
pMCVar	pointer
->	O
nDependents	long
)	O
&&	O
!	O
(	O
pMCVar	pointer
->	O
bExptIsDep	int
=	O
(	O
strcmp	function
(	O
pMCVar	pointer
->	O
rgpDependents	pointer
[	O
m	long
]	O
->	O
pszName	pointer
,	O
pMCVar	pointer
->	O
pszName	pointer
)	O
?	O
TRUE	int
:	O
FALSE	int
)	O
)	O
)	O
m	long
++	O
;	O
}	O
}	O
}	O
void	O
DoMarkov	function
(	O
PANALYSIS	pointer
panal	pointer
)	O
{	O
PGIBBSDATA	pointer
pgd	pointer
=	O
&	O
panal	pointer
->	O
gd	struct
;	O
PLEVEL	pointer
pLevel0	pointer
=	O
panal	pointer
->	O
pLevels	array
[	O
0	int
]	O
;	O
long	O
nThetas	long
,	O
nUpdateAt	long
,	O
nTotal	long
;	O
long	O
i	long
,	O
iter	long
=	O
0	int
;	O
long	O
nIter	long
=	O
pgd	pointer
->	O
nMaxIter	long
;	O
double	O
*	O
pdMCVarVals	pointer
=	O
NULL	O
;	O
double	O
*	O
pdSum	pointer
=	O
NULL	O
;	O
double	O
*	O
*	O
prgdSumProd	pointer
=	O
NULL	O
;	O
double	O
dTmp	double
,	O
dLnPrior	double
=	O
0	int
,	O
dLnData	double
=	O
0	int
;	O
if	O
(	O
panal	pointer
->	O
rank	int
==	O
0	int
)	O
AnnounceMarkov	function
(	O
panal	pointer
->	O
size	int
,	O
pgd	pointer
->	O
nSimTypeFlag	long
,	O
nIter	long
)	O
;	O
OpenMarkovFiles	function
(	O
panal	pointer
)	O
;	O
ReadDataFile	function
(	O
panal	pointer
)	O
;	O
TraverseLevels	function
(	O
pLevel0	pointer
,	O
CloneMCVars	function
,	O
NULL	O
)	O
;	O
TraverseLevels	function
(	O
pLevel0	pointer
,	O
CloneLikes	function
,	O
NULL	O
)	O
;	O
TraverseLevels	function
(	O
pLevel0	pointer
,	O
FindMCParents	function
,	O
panal	pointer
,	O
NULL	O
)	O
;	O
TraverseLevels	function
(	O
pLevel0	pointer
,	O
FindMCDependents	function
,	O
panal	pointer
,	O
NULL	O
)	O
;	O
TraverseLevels	function
(	O
pLevel0	pointer
,	O
FindLikeParents	function
,	O
panal	pointer
,	O
NULL	O
)	O
;	O
TraverseLevels	function
(	O
pLevel0	pointer
,	O
ConvertLists	function
,	O
panal	pointer
,	O
NULL	O
)	O
;	O
TraverseLevels	function
(	O
pLevel0	pointer
,	O
CheckForFixed	function
,	O
NULL	O
)	O
;	O
TraverseLevels	function
(	O
pLevel0	pointer
,	O
CheckPrintStatements	function
,	O
panal	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
(	O
panal	pointer
->	O
rank	int
==	O
0	int
)	O
&&	O
(	O
panal	pointer
->	O
bDependents	int
)	O
)	O
{	O
printf	function
(	O
"Hierarchical structure:\n\n"	pointer
)	O
;	O
TraverseLevels	function
(	O
pLevel0	pointer
,	O
PrintDeps	function
,	O
NULL	O
)	O
;	O
printf	function
(	O
"\nDone.\n\n"	pointer
)	O
;	O
return	O
;	O
}	O
TraverseLevels	function
(	O
pLevel0	pointer
,	O
SetPointers	function
,	O
panal	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
pgd	pointer
->	O
szGrestart	pointer
)	O
{	O
nThetas	long
=	O
0	int
;	O
TraverseLevels	function
(	O
pLevel0	pointer
,	O
GetNumberOfMCVars	function
,	O
&	O
nThetas	long
)	O
;	O
if	O
(	O
(	O
(	O
pgd	pointer
->	O
nSimTypeFlag	long
==	O
3	int
)	O
||	O
(	O
pgd	pointer
->	O
nSimTypeFlag	long
==	O
4	int
)	O
)	O
&&	O
(	O
pgd	pointer
->	O
nPerks	int
!=	O
0	int
)	O
)	O
{	O
ReadRestartTemper	function
(	O
pgd	pointer
->	O
pfileRestart	pointer
,	O
nThetas	long
,	O
pgd	pointer
->	O
nPerks	int
,	O
&	O
pdMCVarVals	pointer
,	O
&	O
pdSum	pointer
,	O
&	O
prgdSumProd	pointer
,	O
&	O
iter	long
,	O
&	O
pgd	pointer
->	O
indexT	int
,	O
pgd	pointer
->	O
rgdlnPi	pointer
)	O
;	O
}	O
else	O
ReadRestart	function
(	O
pgd	pointer
->	O
pfileRestart	pointer
,	O
nThetas	long
,	O
&	O
pdMCVarVals	pointer
,	O
&	O
pdSum	pointer
,	O
&	O
prgdSumProd	pointer
,	O
&	O
iter	long
)	O
;	O
nThetas	long
=	O
0	int
;	O
if	O
(	O
!	O
TraverseLevels1	function
(	O
pLevel0	pointer
,	O
SetMCVars	function
,	O
pdMCVarVals	pointer
,	O
&	O
nThetas	long
,	O
NULL	O
)	O
)	O
{	O
printf	function
(	O
"\nError: some read-in parameters are out of bounds - "	pointer
"Exiting\n\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
if	O
(	O
pgd	pointer
->	O
nSimTypeFlag	long
==	O
1	int
)	O
{	O
if	O
(	O
panal	pointer
->	O
rank	int
==	O
0	int
)	O
{	O
PrintAllExpts	function
(	O
pLevel0	pointer
,	O
panal	pointer
,	O
pgd	pointer
->	O
pfileOut	pointer
)	O
;	O
CloseMarkovFiles	function
(	O
pgd	pointer
)	O
;	O
}	O
return	O
;	O
}	O
if	O
(	O
(	O
pgd	pointer
->	O
nSimTypeFlag	long
==	O
0	int
)	O
||	O
(	O
pgd	pointer
->	O
nSimTypeFlag	long
>=	O
3	int
)	O
)	O
{	O
char	O
szKernelFile	array
[	O
MAX_FILENAMESIZE	int
+	O
12	int
]	O
;	O
if	O
(	O
panal	pointer
->	O
size	int
>	O
1	int
)	O
{	O
sprintf	function
(	O
szKernelFile	array
,	O
"%04d_%s%s"	pointer
,	O
panal	pointer
->	O
rank	int
,	O
panal	pointer
->	O
gd	struct
.	O
szGrestart	pointer
,	O
".kernel"	pointer
)	O
;	O
}	O
else	O
{	O
sprintf	function
(	O
szKernelFile	array
,	O
"%s%s"	pointer
,	O
panal	pointer
->	O
gd	struct
.	O
szGrestart	pointer
,	O
".kernel"	pointer
)	O
;	O
}	O
FILE	struct
*	O
pfile	pointer
=	O
fopen	function
(	O
szKernelFile	array
,	O
"r"	pointer
)	O
;	O
if	O
(	O
pfile	pointer
)	O
{	O
printf	function
(	O
"Reading kernel file %s\n"	pointer
,	O
szKernelFile	array
)	O
;	O
TraverseLevels	function
(	O
pLevel0	pointer
,	O
ReadKernel	function
,	O
pfile	pointer
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
TraverseLevels	function
(	O
pLevel0	pointer
,	O
SetKernel	function
,	O
1	int
,	O
pdMCVarVals	pointer
,	O
NULL	O
)	O
;	O
free	function
(	O
pdMCVarVals	pointer
)	O
;	O
}	O
}	O
else	O
{	O
TraverseLevels	function
(	O
pLevel0	pointer
,	O
CalculateTotals	function
,	O
panal	pointer
,	O
&	O
dLnPrior	double
,	O
NULL	O
)	O
;	O
}	O
if	O
(	O
!	O
RunAllExpts	function
(	O
panal	pointer
,	O
&	O
dLnData	double
)	O
)	O
{	O
printf	function
(	O
"\nError: cannot compute at the starting point - Exiting\n\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
TraverseLevels1	function
(	O
pLevel0	pointer
,	O
SaveLikelihoods	function
,	O
NULL	O
)	O
;	O
InitPerks	function
(	O
panal	pointer
)	O
;	O
WriteHeader	function
(	O
panal	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
pgd	pointer
->	O
nSimTypeFlag	long
==	O
1	int
)	O
{	O
printf	function
(	O
"\nError: a restart file must be given to print data and"	pointer
"         predictions - Exiting.\n\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
TraverseLevels	function
(	O
pLevel0	pointer
,	O
SetKernel	function
,	O
2	int
,	O
pdMCVarVals	pointer
,	O
NULL	O
)	O
;	O
TraverseLevels	function
(	O
pLevel0	pointer
,	O
InitMCVars	function
,	O
NULL	O
)	O
;	O
TraverseLevels	function
(	O
pLevel0	pointer
,	O
CalculateTotals	function
,	O
panal	pointer
,	O
&	O
dLnPrior	double
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
RunAllExpts	function
(	O
panal	pointer
,	O
&	O
dLnData	double
)	O
)	O
{	O
printf	function
(	O
"\nError: cannot compute at the starting point - Exiting\n\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
TraverseLevels1	function
(	O
pLevel0	pointer
,	O
SaveLikelihoods	function
,	O
NULL	O
)	O
;	O
InitPerks	function
(	O
panal	pointer
)	O
;	O
WriteHeader	function
(	O
panal	pointer
)	O
;	O
fprintf	function
(	O
pgd	pointer
->	O
pfileOut	pointer
,	O
"0\t"	pointer
)	O
;	O
TraverseLevels	function
(	O
pLevel0	pointer
,	O
WriteMCVars	function
,	O
pgd	pointer
->	O
pfileOut	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
(	O
pgd	pointer
->	O
nSimTypeFlag	long
==	O
3	int
)	O
||	O
(	O
pgd	pointer
->	O
nSimTypeFlag	long
==	O
4	int
)	O
)	O
{	O
fprintf	function
(	O
pgd	pointer
->	O
pfileOut	pointer
,	O
"%d\t"	pointer
,	O
pgd	pointer
->	O
indexT	int
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
pgd	pointer
->	O
nPerks	int
;	O
i	long
++	O
)	O
fprintf	function
(	O
pgd	pointer
->	O
pfileOut	pointer
,	O
"%e\t"	pointer
,	O
pgd	pointer
->	O
rgdlnPi	pointer
[	O
i	long
]	O
)	O
;	O
}	O
fprintf	function
(	O
pgd	pointer
->	O
pfileOut	pointer
,	O
"%e\t%e\t%e\n"	pointer
,	O
dLnPrior	double
,	O
dLnData	double
,	O
dLnPrior	double
+	O
dLnData	double
)	O
;	O
fflush	function
(	O
pgd	pointer
->	O
pfileOut	pointer
)	O
;	O
}	O
nTotal	long
=	O
UPDATE_BASE	int
;	O
nUpdateAt	long
=	O
iter	long
+	O
nTotal	long
;	O
while	O
(	O
iter	long
<	O
nIter	long
)	O
{	O
if	O
(	O
panal	pointer
->	O
bOutputIter	int
&&	O
(	O
(	O
iter	long
+	O
1	int
)	O
%	O
panal	pointer
->	O
nOutputFreq	int
==	O
0	int
)	O
)	O
{	O
if	O
(	O
panal	pointer
->	O
size	int
>	O
1	int
)	O
printf	function
(	O
"Processor %d, Iteration %ld\n"	pointer
,	O
panal	pointer
->	O
rank	int
,	O
iter	long
+	O
1	int
)	O
;	O
else	O
printf	function
(	O
"Iteration %ld\n"	pointer
,	O
iter	long
+	O
1	int
)	O
;	O
if	O
(	O
iter	long
==	O
nIter	long
-	O
1	int
)	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
if	O
(	O
(	O
(	O
iter	long
+	O
1	int
)	O
%	O
pgd	pointer
->	O
nPrintFreq	long
==	O
0	int
)	O
&&	O
(	O
iter	long
>=	O
pgd	pointer
->	O
nMaxIter	long
-	O
pgd	pointer
->	O
nPrintIter	long
)	O
)	O
fprintf	function
(	O
pgd	pointer
->	O
pfileOut	pointer
,	O
"%ld\t"	pointer
,	O
iter	long
+	O
1	int
)	O
;	O
if	O
(	O
(	O
pgd	pointer
->	O
nSimTypeFlag	long
==	O
0	int
)	O
||	O
(	O
pgd	pointer
->	O
nSimTypeFlag	long
==	O
5	int
)	O
)	O
{	O
TraverseLevels	function
(	O
pLevel0	pointer
,	O
SampleThetas	function
,	O
panal	pointer
,	O
pgd	pointer
,	O
&	O
iter	long
,	O
&	O
nUpdateAt	long
,	O
&	O
nTotal	long
,	O
NULL	O
)	O
;	O
if	O
(	O
(	O
(	O
iter	long
+	O
1	int
)	O
%	O
pgd	pointer
->	O
nPrintFreq	long
==	O
0	int
)	O
&&	O
(	O
iter	long
>=	O
pgd	pointer
->	O
nMaxIter	long
-	O
pgd	pointer
->	O
nPrintIter	long
)	O
)	O
{	O
dLnPrior	double
=	O
0.0	int
;	O
TraverseLevels	function
(	O
pLevel0	pointer
,	O
CalculateTotals	function
,	O
panal	pointer
,	O
&	O
dLnPrior	double
,	O
NULL	O
)	O
;	O
dLnData	double
=	O
0.0	int
;	O
TraverseLevels1	function
(	O
pLevel0	pointer
,	O
SumAllExpts	function
,	O
&	O
dLnData	double
,	O
NULL	O
)	O
;	O
fprintf	function
(	O
pgd	pointer
->	O
pfileOut	pointer
,	O
"%e\t%e\t%e\n"	pointer
,	O
dLnPrior	double
,	O
dLnData	double
,	O
dLnPrior	double
+	O
dLnData	double
)	O
;	O
fflush	function
(	O
pgd	pointer
->	O
pfileOut	pointer
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
(	O
pgd	pointer
->	O
nSimTypeFlag	long
==	O
3	int
)	O
||	O
(	O
pgd	pointer
->	O
nSimTypeFlag	long
==	O
4	int
)	O
)	O
{	O
TraverseLevels	function
(	O
pLevel0	pointer
,	O
SampleThetasTempered	function
,	O
panal	pointer
,	O
pgd	pointer
,	O
&	O
iter	long
,	O
&	O
nUpdateAt	long
,	O
&	O
nTotal	long
,	O
&	O
pgd	pointer
->	O
indexT	int
,	O
NULL	O
)	O
;	O
dLnPrior	double
=	O
0.0	int
;	O
TraverseLevels	function
(	O
pLevel0	pointer
,	O
CalculateTotals	function
,	O
panal	pointer
,	O
&	O
dLnPrior	double
,	O
NULL	O
)	O
;	O
dLnData	double
=	O
0.0	int
;	O
TraverseLevels1	function
(	O
pLevel0	pointer
,	O
SumAllExpts	function
,	O
&	O
dLnData	double
,	O
NULL	O
)	O
;	O
dTmp	double
=	O
pgd	pointer
->	O
dCZero	double
/	O
(	O
iter	long
+	O
pgd	pointer
->	O
dNZero	double
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
pgd	pointer
->	O
nPerks	int
;	O
i	long
++	O
)	O
{	O
if	O
(	O
i	long
==	O
pgd	pointer
->	O
indexT	int
)	O
pgd	pointer
->	O
rgdlnPi	pointer
[	O
i	long
]	O
-=	O
dTmp	double
;	O
else	O
pgd	pointer
->	O
rgdlnPi	pointer
[	O
i	long
]	O
+=	O
dTmp	double
/	O
pgd	pointer
->	O
nPerks	int
;	O
}	O
if	O
(	O
(	O
(	O
iter	long
+	O
1	int
)	O
%	O
pgd	pointer
->	O
nPrintFreq	long
==	O
0	int
)	O
&&	O
(	O
iter	long
>=	O
pgd	pointer
->	O
nMaxIter	long
-	O
pgd	pointer
->	O
nPrintIter	long
)	O
)	O
{	O
fprintf	function
(	O
pgd	pointer
->	O
pfileOut	pointer
,	O
"%d\t"	pointer
,	O
pgd	pointer
->	O
indexT	int
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
pgd	pointer
->	O
nPerks	int
;	O
i	long
++	O
)	O
fprintf	function
(	O
pgd	pointer
->	O
pfileOut	pointer
,	O
"%e\t"	pointer
,	O
pgd	pointer
->	O
rgdlnPi	pointer
[	O
i	long
]	O
)	O
;	O
fprintf	function
(	O
pgd	pointer
->	O
pfileOut	pointer
,	O
"%e\t%e\t%e\n"	pointer
,	O
dLnPrior	double
,	O
dLnData	double
,	O
dLnPrior	double
+	O
dLnData	double
)	O
;	O
fflush	function
(	O
pgd	pointer
->	O
pfileOut	pointer
)	O
;	O
}	O
pgd	pointer
->	O
rglCount	pointer
[	O
pgd	pointer
->	O
indexT	int
]	O
=	O
pgd	pointer
->	O
rglCount	pointer
[	O
pgd	pointer
->	O
indexT	int
]	O
+	O
1	int
;	O
pgd	pointer
->	O
indexT	int
=	O
SampleTemperature2	function
(	O
pgd	pointer
,	O
dLnPrior	double
,	O
dLnData	double
)	O
;	O
}	O
else	O
{	O
SampleThetaVector	function
(	O
pLevel0	pointer
,	O
panal	pointer
,	O
nThetas	long
,	O
pdMCVarVals	pointer
,	O
pdSum	pointer
,	O
prgdSumProd	pointer
,	O
iter	long
,	O
nUpdateAt	long
,	O
nTotal	long
,	O
&	O
dLnPrior	double
,	O
&	O
dLnData	double
)	O
;	O
if	O
(	O
(	O
(	O
iter	long
+	O
1	int
)	O
%	O
pgd	pointer
->	O
nPrintFreq	long
==	O
0	int
)	O
&&	O
(	O
iter	long
>=	O
pgd	pointer
->	O
nMaxIter	long
-	O
pgd	pointer
->	O
nPrintIter	long
)	O
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nThetas	long
;	O
i	long
++	O
)	O
fprintf	function
(	O
pgd	pointer
->	O
pfileOut	pointer
,	O
"%5g\t"	pointer
,	O
pdMCVarVals	pointer
[	O
i	long
]	O
)	O
;	O
fprintf	function
(	O
pgd	pointer
->	O
pfileOut	pointer
,	O
"%e\t%e\t%e\n"	pointer
,	O
dLnPrior	double
,	O
dLnData	double
,	O
dLnPrior	double
+	O
dLnData	double
)	O
;	O
fflush	function
(	O
pgd	pointer
->	O
pfileOut	pointer
)	O
;	O
}	O
}	O
}	O
if	O
(	O
iter	long
==	O
nUpdateAt	long
)	O
{	O
nTotal	long
=	O
nTotal	long
*	O
3	int
/	O
2	int
;	O
nUpdateAt	long
=	O
iter	long
+	O
nTotal	long
;	O
}	O
iter	long
=	O
iter	long
+	O
1	int
;	O
}	O
if	O
(	O
(	O
pgd	pointer
->	O
nSimTypeFlag	long
==	O
3	int
)	O
||	O
(	O
pgd	pointer
->	O
nSimTypeFlag	long
==	O
4	int
)	O
)	O
{	O
PrintTemperatureDiagnostics	function
(	O
pgd	pointer
->	O
pfilePerks	pointer
,	O
pgd	pointer
)	O
;	O
}	O
if	O
(	O
(	O
pgd	pointer
->	O
nSimTypeFlag	long
==	O
0	int
)	O
||	O
(	O
pgd	pointer
->	O
nSimTypeFlag	long
>=	O
3	int
)	O
)	O
{	O
char	O
szKernelFile	array
[	O
MAX_FILENAMESIZE	int
+	O
7	int
]	O
;	O
sprintf	function
(	O
szKernelFile	array
,	O
"%s%s"	pointer
,	O
panal	pointer
->	O
gd	struct
.	O
szGout	pointer
,	O
".kernel"	pointer
)	O
;	O
FILE	struct
*	O
pfile	pointer
=	O
fopen	function
(	O
szKernelFile	array
,	O
"w"	pointer
)	O
;	O
if	O
(	O
!	O
pfile	pointer
)	O
{	O
printf	function
(	O
"Cannot create kernel saving file '%s'\n"	pointer
,	O
panal	pointer
->	O
gd	struct
.	O
szGdata	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
TraverseLevels	function
(	O
pLevel0	pointer
,	O
WriteKernel	function
,	O
pfile	pointer
,	O
NULL	O
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"\n"	pointer
)	O
;	O
fclose	function
(	O
pfile	pointer
)	O
;	O
printf	function
(	O
"Wrote kernel SDs to \"%s\"\n"	pointer
,	O
szKernelFile	array
)	O
;	O
}	O
CloseMarkovFiles	function
(	O
pgd	pointer
)	O
;	O
}	O
BOOL	int
EqualSlopes	function
(	O
PDOUBLE	pointer
x	pointer
,	O
PDOUBLE	pointer
y	pointer
,	O
int	O
i	long
)	O
{	O
double	O
s1	double
,	O
s2	double
;	O
s1	double
=	O
(	O
y	pointer
[	O
i	long
+	O
1	int
]	O
-	O
y	pointer
[	O
i	long
]	O
)	O
/	O
(	O
x	pointer
[	O
i	long
+	O
1	int
]	O
-	O
x	pointer
[	O
i	long
]	O
)	O
;	O
s2	double
=	O
(	O
y	pointer
[	O
i	long
+	O
2	int
]	O
-	O
y	pointer
[	O
i	long
]	O
)	O
/	O
(	O
x	pointer
[	O
i	long
+	O
2	int
]	O
-	O
x	pointer
[	O
i	long
]	O
)	O
;	O
return	O
(	O
fabs	function
(	O
s2	double
/	O
s1	double
-	O
1	int
)	O
<	O
SL_EPSILON	int
)	O
;	O
}	O
double	O
Extrapolate	function
(	O
PGIBBSDATA	pointer
pgd	pointer
,	O
double	O
dTargetX	double
,	O
int	O
i1	int
,	O
int	O
i2	int
)	O
{	O
return	O
(	O
pgd	pointer
->	O
rgdlnPi	pointer
[	O
i1	int
]	O
-	O
(	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
i1	int
]	O
-	O
dTargetX	double
)	O
*	O
(	O
pgd	pointer
->	O
rgdlnPi	pointer
[	O
i2	int
]	O
-	O
pgd	pointer
->	O
rgdlnPi	pointer
[	O
i1	int
]	O
)	O
/	O
(	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
i2	int
]	O
-	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
i1	int
]	O
)	O
)	O
;	O
}	O
void	O
FindLikeParents	function
(	O
PLEVEL	pointer
plevel	pointer
,	O
char	O
*	O
*	O
args	pointer
)	O
{	O
PANALYSIS	pointer
panal	pointer
=	O
(	O
PANALYSIS	pointer
)	O
args	pointer
[	O
0	int
]	O
;	O
long	O
k	pointer
,	O
l	pointer
,	O
m	long
,	O
n	int
;	O
PLEVEL	pointer
pPrevLev	pointer
;	O
PMCVAR	pointer
pMCVar1	pointer
,	O
pMCVar2	pointer
;	O
BOOL	int
bFound	int
;	O
panal	pointer
->	O
pCurrentLevel	array
[	O
plevel	pointer
->	O
iDepth	int
]	O
=	O
plevel	pointer
;	O
for	O
(	O
k	pointer
=	O
0	int
;	O
k	pointer
<	O
plevel	pointer
->	O
nLikes	long
;	O
k	pointer
++	O
)	O
{	O
pMCVar1	pointer
=	O
plevel	pointer
->	O
rgpLikes	pointer
[	O
k	pointer
]	O
;	O
for	O
(	O
l	pointer
=	O
0	int
;	O
l	pointer
<	O
4	int
;	O
l	pointer
++	O
)	O
{	O
if	O
(	O
pMCVar1	pointer
->	O
iParmType	array
[	O
l	pointer
]	O
==	O
MCVP_PARM	int
)	O
{	O
bFound	int
=	O
FALSE	int
;	O
for	O
(	O
m	long
=	O
0	int
;	O
m	long
<	O
plevel	pointer
->	O
nMCVars	long
;	O
m	long
++	O
)	O
{	O
pMCVar2	pointer
=	O
plevel	pointer
->	O
rgpMCVars	pointer
[	O
m	long
]	O
;	O
if	O
(	O
pMCVar1	pointer
->	O
hParm	array
[	O
l	pointer
]	O
==	O
pMCVar2	pointer
->	O
hvar	long
)	O
{	O
pMCVar1	pointer
->	O
pMCVParent	array
[	O
l	pointer
]	O
=	O
pMCVar2	pointer
;	O
bFound	int
=	O
TRUE	int
;	O
}	O
}	O
if	O
(	O
!	O
bFound	int
)	O
{	O
for	O
(	O
n	int
=	O
plevel	pointer
->	O
iDepth	int
-	O
1	int
;	O
n	int
>=	O
0	int
;	O
n	int
--	O
)	O
{	O
pPrevLev	pointer
=	O
panal	pointer
->	O
pCurrentLevel	array
[	O
n	int
]	O
;	O
for	O
(	O
m	long
=	O
0	int
;	O
m	long
<	O
pPrevLev	pointer
->	O
nMCVars	long
;	O
m	long
++	O
)	O
{	O
pMCVar2	pointer
=	O
pPrevLev	pointer
->	O
rgpMCVars	pointer
[	O
m	long
]	O
;	O
if	O
(	O
pMCVar1	pointer
->	O
hParm	array
[	O
l	pointer
]	O
==	O
pMCVar2	pointer
->	O
hvar	long
)	O
{	O
pMCVar1	pointer
->	O
pMCVParent	array
[	O
l	pointer
]	O
=	O
pMCVar2	pointer
;	O
bFound	int
=	O
TRUE	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
!	O
bFound	int
)	O
{	O
printf	function
(	O
"\n"	pointer
"Error: parent in position %ld of %s must be\n"	pointer
"       declared before it when creating\n"	pointer
"       sampling dependencies - Exiting.\n\n"	pointer
,	O
l	pointer
,	O
pMCVar1	pointer
->	O
pszName	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
}	O
}	O
}	O
}	O
void	O
FindMCDependents	function
(	O
PLEVEL	pointer
plevel	pointer
,	O
char	O
*	O
*	O
args	pointer
)	O
{	O
long	O
i	long
,	O
j	long
;	O
PMCVAR	pointer
pMCVar	pointer
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
plevel	pointer
->	O
nMCVars	long
;	O
i	long
++	O
)	O
{	O
pMCVar	pointer
=	O
plevel	pointer
->	O
rgpMCVars	pointer
[	O
i	long
]	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
4	int
;	O
j	long
++	O
)	O
if	O
(	O
(	O
pMCVar	pointer
->	O
pMCVParent	array
[	O
j	long
]	O
!=	O
NULL	O
)	O
&&	O
(	O
pMCVar	pointer
->	O
pMCVParent	array
[	O
j	long
]	O
->	O
hvar	long
==	O
pMCVar	pointer
->	O
hParm	array
[	O
j	long
]	O
)	O
)	O
QueueListItem	function
(	O
pMCVar	pointer
->	O
pMCVParent	array
[	O
j	long
]	O
->	O
plistDependents	pointer
,	O
pMCVar	pointer
)	O
;	O
}	O
}	O
void	O
FindMCParents	function
(	O
PLEVEL	pointer
plevel	pointer
,	O
char	O
*	O
*	O
args	pointer
)	O
{	O
PANALYSIS	pointer
panal	pointer
=	O
(	O
PANALYSIS	pointer
)	O
args	pointer
[	O
0	int
]	O
;	O
long	O
k	pointer
,	O
l	pointer
,	O
m	long
,	O
n	int
;	O
PLEVEL	pointer
pPrevLev	pointer
;	O
PMCVAR	pointer
pMCVar1	pointer
,	O
pMCVar2	pointer
;	O
BOOL	int
bFound	int
;	O
panal	pointer
->	O
pCurrentLevel	array
[	O
plevel	pointer
->	O
iDepth	int
]	O
=	O
plevel	pointer
;	O
for	O
(	O
k	pointer
=	O
0	int
;	O
k	pointer
<	O
plevel	pointer
->	O
nMCVars	long
;	O
k	pointer
++	O
)	O
{	O
pMCVar1	pointer
=	O
plevel	pointer
->	O
rgpMCVars	pointer
[	O
k	pointer
]	O
;	O
for	O
(	O
l	pointer
=	O
0	int
;	O
l	pointer
<	O
4	int
;	O
l	pointer
++	O
)	O
{	O
if	O
(	O
pMCVar1	pointer
->	O
iParmType	array
[	O
l	pointer
]	O
==	O
MCVP_PARM	int
)	O
{	O
bFound	int
=	O
FALSE	int
;	O
for	O
(	O
m	long
=	O
0	int
;	O
m	long
<	O
k	pointer
;	O
m	long
++	O
)	O
{	O
pMCVar2	pointer
=	O
plevel	pointer
->	O
rgpMCVars	pointer
[	O
m	long
]	O
;	O
if	O
(	O
pMCVar1	pointer
->	O
hParm	array
[	O
l	pointer
]	O
==	O
pMCVar2	pointer
->	O
hvar	long
)	O
{	O
pMCVar1	pointer
->	O
pMCVParent	array
[	O
l	pointer
]	O
=	O
pMCVar2	pointer
;	O
bFound	int
=	O
TRUE	int
;	O
}	O
}	O
if	O
(	O
!	O
bFound	int
)	O
{	O
for	O
(	O
n	int
=	O
plevel	pointer
->	O
iDepth	int
-	O
1	int
;	O
n	int
>=	O
0	int
;	O
n	int
--	O
)	O
{	O
pPrevLev	pointer
=	O
panal	pointer
->	O
pCurrentLevel	array
[	O
n	int
]	O
;	O
for	O
(	O
m	long
=	O
0	int
;	O
m	long
<	O
pPrevLev	pointer
->	O
nMCVars	long
;	O
m	long
++	O
)	O
{	O
pMCVar2	pointer
=	O
pPrevLev	pointer
->	O
rgpMCVars	pointer
[	O
m	long
]	O
;	O
if	O
(	O
pMCVar1	pointer
->	O
hParm	array
[	O
l	pointer
]	O
==	O
pMCVar2	pointer
->	O
hvar	long
)	O
{	O
pMCVar1	pointer
->	O
pMCVParent	array
[	O
l	pointer
]	O
=	O
pMCVar2	pointer
;	O
bFound	int
=	O
TRUE	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
!	O
bFound	int
)	O
{	O
printf	function
(	O
"\n"	pointer
"Error: parent in position %ld of %s must be\n"	pointer
"       declared before it when creating\n"	pointer
"       sampling dependencies - Exiting.\n\n"	pointer
,	O
l	pointer
,	O
pMCVar1	pointer
->	O
pszName	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
}	O
}	O
}	O
}	O
void	O
GetNumberOfMCVars	function
(	O
PLEVEL	pointer
plevel	pointer
,	O
char	O
*	O
*	O
args	pointer
)	O
{	O
long	O
*	O
pnThetas	pointer
=	O
(	O
long	O
*	O
)	O
args	pointer
[	O
0	int
]	O
;	O
*	O
pnThetas	pointer
+=	O
plevel	pointer
->	O
nMCVars	long
;	O
}	O
void	O
InitMCVars	function
(	O
PLEVEL	pointer
plevel	pointer
,	O
char	O
*	O
*	O
args	pointer
)	O
{	O
long	O
n	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	pointer
->	O
nMCVars	long
;	O
n	int
++	O
)	O
if	O
(	O
!	O
(	O
plevel	pointer
->	O
rgpMCVars	pointer
[	O
n	int
]	O
->	O
bIsFixed	int
)	O
)	O
CalculateOneMCParm	function
(	O
plevel	pointer
->	O
rgpMCVars	pointer
[	O
n	int
]	O
)	O
;	O
}	O
void	O
ListToPMCArray	function
(	O
PANALYSIS	pointer
panal	pointer
,	O
PLIST	pointer
plist	pointer
,	O
long	O
*	O
pnMCVars	pointer
,	O
PMCVAR	pointer
*	O
*	O
rgpMCVars	pointer
)	O
{	O
if	O
(	O
(	O
*	O
pnMCVars	pointer
=	O
ListLength	O
(	O
plist	pointer
)	O
)	O
==	O
0	int
)	O
return	O
;	O
if	O
(	O
!	O
(	O
*	O
rgpMCVars	pointer
=	O
(	O
PMCVAR	pointer
*	O
)	O
malloc	function
(	O
*	O
pnMCVars	pointer
*	O
sizeof	O
(	O
PMCVAR	pointer
)	O
)	O
)	O
)	O
ReportRunTimeError	function
(	O
panal	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"ListToPMCArray"	pointer
)	O
;	O
*	O
pnMCVars	pointer
=	O
0	int
;	O
ForAllList3	function
(	O
plist	pointer
,	O
&	O
ListToPMCArrayL	function
,	O
pnMCVars	pointer
,	O
*	O
rgpMCVars	pointer
,	O
NULL	O
)	O
;	O
}	O
void	O
ListToPMCArrayL	function
(	O
PVOID	pointer
pData	pointer
,	O
PVOID	pointer
pUser1	pointer
,	O
PVOID	pointer
pUser2	pointer
,	O
PVOID	pointer
pUser3	pointer
)	O
{	O
PMCVAR	pointer
pMCVar	pointer
=	O
(	O
PMCVAR	pointer
)	O
pData	pointer
;	O
long	O
*	O
pnMCVars	pointer
=	O
(	O
long	O
*	O
)	O
pUser1	pointer
;	O
PMCVAR	pointer
*	O
rgpMCVars	pointer
=	O
(	O
PMCVAR	pointer
*	O
)	O
pUser2	pointer
;	O
rgpMCVars	pointer
[	O
(	O
*	O
pnMCVars	pointer
)	O
++	O
]	O
=	O
pMCVar	pointer
;	O
}	O
void	O
ListToPVArray	function
(	O
PANALYSIS	pointer
panal	pointer
,	O
PLIST	pointer
plist	pointer
,	O
long	O
*	O
pnFixedVars	pointer
,	O
PVARMOD	pointer
*	O
*	O
rgpFixedVars	pointer
)	O
{	O
if	O
(	O
(	O
*	O
pnFixedVars	pointer
=	O
ListLength	O
(	O
plist	pointer
)	O
)	O
==	O
0	int
)	O
return	O
;	O
if	O
(	O
!	O
(	O
*	O
rgpFixedVars	pointer
=	O
(	O
PVARMOD	pointer
*	O
)	O
malloc	function
(	O
*	O
pnFixedVars	pointer
*	O
sizeof	O
(	O
PVARMOD	pointer
)	O
)	O
)	O
)	O
ReportRunTimeError	function
(	O
panal	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"ListToPVArray"	pointer
)	O
;	O
*	O
pnFixedVars	pointer
=	O
0	int
;	O
ForAllList3	function
(	O
plist	pointer
,	O
&	O
ListToPVArrayL	function
,	O
pnFixedVars	pointer
,	O
*	O
rgpFixedVars	pointer
,	O
NULL	O
)	O
;	O
}	O
void	O
ListToPVArrayL	function
(	O
PVOID	pointer
pData	pointer
,	O
PVOID	pointer
pUser1	pointer
,	O
PVOID	pointer
pUser2	pointer
,	O
PVOID	pointer
pUser3	pointer
)	O
{	O
PVARMOD	pointer
pVar	pointer
=	O
(	O
PVARMOD	pointer
)	O
pData	pointer
;	O
long	O
*	O
pnFixedVars	pointer
=	O
(	O
long	O
*	O
)	O
pUser1	pointer
;	O
PVARMOD	pointer
*	O
rgpFixedVars	pointer
=	O
(	O
PVARMOD	pointer
*	O
)	O
pUser2	pointer
;	O
rgpFixedVars	pointer
[	O
(	O
*	O
pnFixedVars	pointer
)	O
++	O
]	O
=	O
pVar	pointer
;	O
}	O
double	O
LnDensity	function
(	O
PMCVAR	pointer
pMCVar	pointer
,	O
PANALYSIS	pointer
panal	pointer
)	O
{	O
double	O
dTmp	double
=	O
0	int
,	O
density	double
;	O
double	O
dTmp2	double
,	O
dTmp3	double
,	O
dTmp4	double
;	O
double	O
dParm1	double
=	O
*	O
(	O
pMCVar	pointer
->	O
pdParm	array
[	O
0	int
]	O
)	O
;	O
double	O
dParm2	double
=	O
*	O
(	O
pMCVar	pointer
->	O
pdParm	array
[	O
1	int
]	O
)	O
;	O
double	O
dMin	double
=	O
*	O
(	O
pMCVar	pointer
->	O
pdParm	array
[	O
2	int
]	O
)	O
;	O
double	O
dMax	double
=	O
*	O
(	O
pMCVar	pointer
->	O
pdParm	array
[	O
3	int
]	O
)	O
;	O
double	O
dTheta	double
=	O
pMCVar	pointer
->	O
dVal	double
;	O
char	O
str	array
[	O
10	int
]	O
;	O
if	O
(	O
pMCVar	pointer
->	O
iType	int
==	O
MCV_BINOMIALBETA	int
)	O
{	O
if	O
(	O
dTheta	double
<	O
0	int
)	O
{	O
printf	function
(	O
"Error: variate out of bounds in LnDensity\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
pMCVar	pointer
->	O
iType	int
==	O
MCV_GENLOGNORMAL	int
||	O
pMCVar	pointer
->	O
iType	int
==	O
MCV_STUDENTT	int
)	O
{	O
if	O
(	O
dParm1	double
<	O
0	int
)	O
{	O
printf	function
(	O
"Error: parameter %g out of bounds in LnDensity\n"	pointer
,	O
dParm1	double
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
dTheta	double
>	O
dMax	double
||	O
dTheta	double
<	O
dMin	double
)	O
{	O
return	O
(	O
NULL_SUPPORT	O
)	O
;	O
}	O
}	O
switch	O
(	O
pMCVar	pointer
->	O
iType	int
)	O
{	O
case	O
MCV_UNIFORM	int
:	O
if	O
(	O
dTheta	double
>	O
dParm2	double
||	O
dTheta	double
<	O
dParm1	double
)	O
return	O
(	O
NULL_SUPPORT	O
)	O
;	O
if	O
(	O
dParm2	double
<=	O
dParm1	double
)	O
ReportRunTimeError	function
(	O
panal	pointer
,	O
RE_BADUNIFORMDIST	int
|	O
RE_FATAL	int
,	O
pMCVar	pointer
->	O
pszName	pointer
,	O
"LnDensity"	pointer
)	O
;	O
return	O
-	O
log	function
(	O
dParm2	double
-	O
dParm1	double
)	O
;	O
case	O
MCV_LOGUNIFORM	int
:	O
if	O
(	O
dTheta	double
>	O
dParm2	double
||	O
dTheta	double
<	O
dParm1	double
)	O
return	O
(	O
NULL_SUPPORT	O
)	O
;	O
if	O
(	O
dParm2	double
<=	O
dParm1	double
)	O
ReportRunTimeError	function
(	O
panal	pointer
,	O
RE_BADUNIFORMDIST	int
|	O
RE_FATAL	int
,	O
pMCVar	pointer
->	O
pszName	pointer
,	O
"LnDensity"	pointer
)	O
;	O
return	O
-	O
log	function
(	O
dTheta	double
*	O
(	O
dParm2	double
-	O
dParm1	double
)	O
)	O
;	O
case	O
MCV_NORMALV	int
:	O
dParm2	double
=	O
sqrt	function
(	O
dParm2	double
)	O
;	O
return	O
lnDFNormal	function
(	O
dTheta	double
,	O
dParm1	double
,	O
dParm2	double
)	O
;	O
case	O
MCV_NORMALCV	int
:	O
dParm2	double
=	O
fabs	function
(	O
dParm1	double
*	O
dParm2	double
)	O
;	O
return	O
lnDFNormal	function
(	O
dTheta	double
,	O
dParm1	double
,	O
dParm2	double
)	O
;	O
case	O
MCV_NORMAL	int
:	O
case	O
MCV_HALFNORMAL	int
:	O
return	O
lnDFNormal	function
(	O
dTheta	double
,	O
dParm1	double
,	O
dParm2	double
)	O
;	O
case	O
MCV_LOGNORMALV	int
:	O
dParm2	double
=	O
exp	function
(	O
sqrt	function
(	O
dParm2	double
)	O
)	O
;	O
case	O
MCV_LOGNORMAL	int
:	O
if	O
(	O
dParm1	double
<=	O
0.0	int
)	O
{	O
sprintf	function
(	O
str	array
,	O
"%5.2e"	pointer
,	O
dParm1	double
)	O
;	O
ReportRunTimeError	function
(	O
panal	pointer
,	O
RE_BADLOGNORMALMEAN	int
|	O
RE_FATAL	int
,	O
pMCVar	pointer
->	O
pszName	pointer
,	O
str	array
,	O
"LnDensity"	pointer
)	O
;	O
}	O
return	O
(	O
lnDFNormal	function
(	O
log	function
(	O
dTheta	double
)	O
,	O
log	function
(	O
dParm1	double
)	O
,	O
log	function
(	O
dParm2	double
)	O
)	O
-	O
log	function
(	O
dTheta	double
)	O
)	O
;	O
case	O
MCV_TRUNCNORMALV	int
:	O
dParm2	double
=	O
sqrt	function
(	O
dParm2	double
)	O
;	O
return	O
lnDFNormal	function
(	O
dTheta	double
,	O
dParm1	double
,	O
dParm2	double
)	O
-	O
log	function
(	O
CDFNormal	function
(	O
(	O
dMax	double
-	O
dParm1	double
)	O
/	O
dParm2	double
)	O
-	O
CDFNormal	function
(	O
(	O
dMin	double
-	O
dParm1	double
)	O
/	O
dParm2	double
)	O
)	O
;	O
case	O
MCV_TRUNCNORMALCV	int
:	O
dParm2	double
=	O
fabs	function
(	O
dParm1	double
*	O
dParm2	double
)	O
;	O
return	O
lnDFNormal	function
(	O
dTheta	double
,	O
dParm1	double
,	O
dParm2	double
)	O
-	O
log	function
(	O
CDFNormal	function
(	O
(	O
dMax	double
-	O
dParm1	double
)	O
/	O
dParm2	double
)	O
-	O
CDFNormal	function
(	O
(	O
dMin	double
-	O
dParm1	double
)	O
/	O
dParm2	double
)	O
)	O
;	O
case	O
MCV_TRUNCNORMAL	int
:	O
if	O
(	O
dParm2	double
<=	O
0.0	int
)	O
{	O
sprintf	function
(	O
str	array
,	O
"%5.2e"	pointer
,	O
dParm2	double
)	O
;	O
ReportRunTimeError	function
(	O
panal	pointer
,	O
RE_BADNORMALSD	int
|	O
RE_FATAL	int
,	O
pMCVar	pointer
->	O
pszName	pointer
,	O
str	array
,	O
"LnDensity"	pointer
)	O
;	O
}	O
return	O
lnDFNormal	function
(	O
dTheta	double
,	O
dParm1	double
,	O
dParm2	double
)	O
-	O
log	function
(	O
CDFNormal	function
(	O
(	O
dMax	double
-	O
dParm1	double
)	O
/	O
dParm2	double
)	O
-	O
CDFNormal	function
(	O
(	O
dMin	double
-	O
dParm1	double
)	O
/	O
dParm2	double
)	O
)	O
;	O
case	O
MCV_TRUNCLOGNORMALV	int
:	O
dParm2	double
=	O
exp	function
(	O
sqrt	function
(	O
dParm2	double
)	O
)	O
;	O
case	O
MCV_TRUNCLOGNORMAL	int
:	O
if	O
(	O
dParm1	double
<=	O
0.0	int
)	O
{	O
sprintf	function
(	O
str	array
,	O
"%5.2e"	pointer
,	O
dParm1	double
)	O
;	O
ReportRunTimeError	function
(	O
panal	pointer
,	O
RE_BADLOGNORMALMEAN	int
|	O
RE_FATAL	int
,	O
pMCVar	pointer
->	O
pszName	pointer
,	O
str	array
,	O
"LnDensity"	pointer
)	O
;	O
}	O
if	O
(	O
dParm2	double
<=	O
1.0	int
)	O
{	O
sprintf	function
(	O
str	array
,	O
"%5.2e"	pointer
,	O
dParm2	double
)	O
;	O
ReportRunTimeError	function
(	O
panal	pointer
,	O
RE_BADLOGNORMALSD	int
|	O
RE_FATAL	int
,	O
pMCVar	pointer
->	O
pszName	pointer
,	O
str	array
,	O
"LnDensity"	pointer
)	O
;	O
}	O
dTmp	double
=	O
log	function
(	O
dParm2	double
)	O
;	O
return	O
lnDFNormal	function
(	O
log	function
(	O
dTheta	double
)	O
,	O
log	function
(	O
dParm1	double
)	O
,	O
dTmp	double
)	O
-	O
log	function
(	O
dTheta	double
)	O
-	O
log	function
(	O
CDFNormal	function
(	O
log	function
(	O
dMax	double
/	O
dParm1	double
)	O
/	O
dTmp	double
)	O
-	O
CDFNormal	function
(	O
log	function
(	O
dMin	double
/	O
dParm1	double
)	O
/	O
dTmp	double
)	O
)	O
;	O
case	O
MCV_BETA	int
:	O
return	O
lnDFBeta	function
(	O
dTheta	double
,	O
dParm1	double
,	O
dParm2	double
,	O
dMin	double
,	O
dMax	double
)	O
;	O
case	O
MCV_CHI2	int
:	O
dTmp	double
=	O
0.5	int
*	O
dParm1	double
;	O
return	O
(	O
dTmp	double
-	O
1	int
)	O
*	O
log	function
(	O
dTheta	double
)	O
-	O
0.5	int
*	O
dTheta	double
+	O
dTmp	double
*	O
(	O
-	O
6.9314718056E-01	int
)	O
-	O
lnGamma	function
(	O
dTmp	double
)	O
;	O
case	O
MCV_BINOMIAL	int
:	O
if	O
(	O
(	O
dParm1	double
<	O
0	int
)	O
||	O
(	O
dParm1	double
>	O
1	int
)	O
)	O
{	O
printf	function
(	O
"Error: bad p for binomial variate in LnDensity\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
if	O
(	O
dTheta	double
>	O
dParm2	double
)	O
{	O
return	O
(	O
NULL_SUPPORT	O
)	O
;	O
}	O
dTmp	double
=	O
lnGamma	function
(	O
dParm2	double
+	O
1	int
)	O
-	O
lnGamma	function
(	O
dTheta	double
+	O
1	int
)	O
-	O
lnGamma	function
(	O
dParm2	double
-	O
dTheta	double
+	O
1	int
)	O
;	O
if	O
(	O
dParm1	double
==	O
0	int
)	O
{	O
if	O
(	O
dTheta	double
!=	O
0	int
)	O
return	O
(	O
NULL_SUPPORT	O
)	O
;	O
}	O
else	O
dTmp	double
=	O
dTmp	double
+	O
dTheta	double
*	O
log	function
(	O
dParm1	double
)	O
;	O
if	O
(	O
dParm1	double
==	O
1	int
)	O
{	O
if	O
(	O
(	O
dParm2	double
-	O
dTheta	double
)	O
==	O
0	int
)	O
return	O
dTmp	double
;	O
else	O
return	O
(	O
NULL_SUPPORT	O
)	O
;	O
}	O
else	O
return	O
dTmp	double
+	O
(	O
dParm2	double
-	O
dTheta	double
)	O
*	O
log	function
(	O
1	int
-	O
dParm1	double
)	O
;	O
case	O
MCV_PIECEWISE	int
:	O
density	double
=	O
2	int
/	O
(	O
dMax	double
+	O
dParm2	double
-	O
dParm1	double
-	O
dMin	double
)	O
;	O
if	O
(	O
dTheta	double
<=	O
dParm1	double
)	O
return	O
log	function
(	O
density	double
*	O
(	O
dTheta	double
-	O
dMin	double
)	O
/	O
(	O
dParm1	double
-	O
dMin	double
)	O
)	O
;	O
else	O
if	O
(	O
dTheta	double
<=	O
dParm2	double
)	O
return	O
log	function
(	O
density	double
)	O
;	O
else	O
return	O
log	function
(	O
density	double
*	O
(	O
dMax	double
-	O
dTheta	double
)	O
/	O
(	O
dMax	double
-	O
dParm2	double
)	O
)	O
;	O
case	O
MCV_EXPONENTIAL	int
:	O
if	O
(	O
dParm1	double
<=	O
0	int
)	O
{	O
printf	function
(	O
"Error: negative or null inverse scale (%g) for exponential "	pointer
"variate in LnDensity\n"	pointer
,	O
dParm1	double
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
return	O
-	O
dTheta	double
*	O
dParm1	double
+	O
log	function
(	O
dParm1	double
)	O
;	O
case	O
MCV_GGAMMA	int
:	O
if	O
(	O
dParm2	double
<=	O
0	int
)	O
{	O
printf	function
(	O
"Error: bad inv. scale for gamma variate in LnDensity\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
return	O
(	O
dParm1	double
-	O
1	int
)	O
*	O
log	function
(	O
dTheta	double
)	O
-	O
dParm2	double
*	O
dTheta	double
+	O
dParm1	double
*	O
log	function
(	O
dParm2	double
)	O
-	O
lnGamma	function
(	O
dParm1	double
)	O
;	O
case	O
MCV_TRUNCINVGGAMMA	int
:	O
printf	function
(	O
"Error: Truncated inverse gamma density cannot be evaluated\n"	pointer
)	O
;	O
printf	function
(	O
"       if the GNU Scientific Library is not installed\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
case	O
MCV_INVGGAMMA	int
:	O
if	O
(	O
dParm2	double
<=	O
0	int
)	O
{	O
printf	function
(	O
"Error: bad scale for inv. gamma variate in LnDensity\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
return	O
(	O
-	O
dParm1	double
-	O
1	int
)	O
*	O
log	function
(	O
dTheta	double
)	O
-	O
dParm2	double
/	O
dTheta	double
+	O
dParm1	double
*	O
log	function
(	O
dParm2	double
)	O
-	O
lnGamma	function
(	O
dParm1	double
)	O
-	O
dTmp	double
;	O
case	O
MCV_POISSON	int
:	O
if	O
(	O
dParm1	double
<=	O
0	int
)	O
{	O
printf	function
(	O
"Error: bad rate for Poisson variate in LnDensity\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
return	O
dTheta	double
*	O
log	function
(	O
dParm1	double
)	O
-	O
dParm1	double
-	O
lnGamma	function
(	O
dTheta	double
+	O
1	int
)	O
;	O
case	O
MCV_BINOMIALBETA	int
:	O
if	O
(	O
dParm1	double
<	O
0	int
)	O
{	O
printf	function
(	O
"Error: bad expectation for BinomialBeta variate "	pointer
"in LnDensity\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
if	O
(	O
dParm2	double
<=	O
0	int
)	O
{	O
printf	function
(	O
"Error: bad alpha for BinomialBeta variate in LnDensity\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
if	O
(	O
dMin	double
<=	O
0	int
)	O
{	O
printf	function
(	O
"Error: bad beta for BinomialBeta variate in LnDensity\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
dTmp	double
=	O
floor	function
(	O
0.5	int
+	O
dParm1	double
+	O
dParm1	double
*	O
dMin	double
/	O
dParm2	double
)	O
;	O
if	O
(	O
dTheta	double
>	O
dTmp	double
)	O
return	O
(	O
NULL_SUPPORT	O
)	O
;	O
else	O
{	O
if	O
(	O
(	O
dParm2	double
==	O
0.5	int
)	O
&&	O
(	O
dMin	double
==	O
0.5	int
)	O
)	O
dTmp	double
=	O
lnGamma	function
(	O
0.5	int
+	O
dTheta	double
)	O
+	O
lnGamma	function
(	O
0.5	int
+	O
dTmp	double
-	O
dTheta	double
)	O
-	O
lnGamma	function
(	O
dTheta	double
+	O
1	int
)	O
-	O
lnGamma	function
(	O
dTmp	double
-	O
dTheta	double
+	O
1	int
)	O
;	O
else	O
dTmp	double
=	O
lnGamma	function
(	O
dParm2	double
+	O
dMin	double
)	O
+	O
lnGamma	function
(	O
dTmp	double
+	O
1	int
)	O
+	O
lnGamma	function
(	O
dParm2	double
+	O
dTheta	double
)	O
+	O
lnGamma	function
(	O
dMin	double
+	O
dTmp	double
-	O
dTheta	double
)	O
-	O
lnGamma	function
(	O
dTheta	double
+	O
1	int
)	O
-	O
lnGamma	function
(	O
dTmp	double
-	O
dTheta	double
+	O
1	int
)	O
-	O
lnGamma	function
(	O
dParm2	double
)	O
-	O
lnGamma	function
(	O
dMin	double
)	O
-	O
lnGamma	function
(	O
dParm2	double
+	O
dMin	double
+	O
dTmp	double
)	O
;	O
return	O
dTmp	double
;	O
}	O
case	O
MCV_GENLOGNORMAL	int
:	O
if	O
(	O
dParm1	double
<	O
0	int
)	O
{	O
printf	function
(	O
"Error: bad expectation for GenLogNormal variate "	pointer
"in LnDensity\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
dTmp	double
=	O
sqrt	function
(	O
exp	function
(	O
pow	function
(	O
dMin	double
,	O
2	int
)	O
)	O
*	O
(	O
exp	function
(	O
pow	function
(	O
dMin	double
,	O
2	int
)	O
)	O
-	O
1	int
)	O
)	O
;	O
dTmp2	double
=	O
pow	function
(	O
dParm2	double
/	O
dTmp	double
,	O
2	int
)	O
;	O
dTmp3	double
=	O
log	function
(	O
dParm1	double
+	O
sqrt	function
(	O
pow	function
(	O
dParm1	double
,	O
2	int
)	O
+	O
dTmp2	double
)	O
)	O
;	O
if	O
(	O
(	O
dTheta	double
<	O
0	int
)	O
&&	O
(	O
dTmp2	double
<	O
(	O
0.01	int
*	O
dTheta	double
*	O
dTheta	double
)	O
)	O
)	O
dTmp4	double
=	O
log	function
(	O
dTmp2	double
/	O
(	O
-	O
2	int
*	O
dTheta	double
)	O
*	O
(	O
1	int
+	O
0.25	int
*	O
dTmp2	double
/	O
pow	function
(	O
dTheta	double
,	O
2	int
)	O
)	O
)	O
;	O
else	O
dTmp4	double
=	O
log	function
(	O
dTheta	double
+	O
sqrt	function
(	O
pow	function
(	O
dTheta	double
,	O
2	int
)	O
+	O
dTmp2	double
)	O
)	O
;	O
return	O
lnDFNormal	function
(	O
dTmp4	double
,	O
dTmp3	double
,	O
dTmp	double
)	O
-	O
0.5	int
*	O
log	function
(	O
pow	function
(	O
dTmp4	double
,	O
2	int
)	O
+	O
dTmp2	double
)	O
;	O
case	O
MCV_STUDENTT	int
:	O
if	O
(	O
dParm1	double
<=	O
0	int
)	O
{	O
printf	function
(	O
"Error: bad dof for Student-T variate"	pointer
"in LnDensity\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
dTmp	double
=	O
(	O
dParm1	double
+	O
1	int
)	O
/	O
2	int
;	O
return	O
(	O
lnGamma	function
(	O
dTmp	double
)	O
-	O
lnGamma	function
(	O
dParm1	double
/	O
2	int
)	O
-	O
0.5	int
*	O
log	function
(	O
dParm1	double
*	O
PI	int
*	O
dMin	double
*	O
dMin	double
)	O
-	O
dTmp	double
*	O
log	function
(	O
1	int
+	O
pow	function
(	O
(	O
dTheta	double
-	O
dParm2	double
)	O
/	O
dMin	double
,	O
2	int
)	O
/	O
dParm1	double
)	O
)	O
;	O
case	O
MCV_CAUCHY	int
:	O
return	O
(	O
LNINVERPI	O
-	O
log	function
(	O
dParm1	double
+	O
dTheta	double
*	O
dTheta	double
/	O
dParm1	double
)	O
)	O
;	O
case	O
MCV_HALFCAUCHY	int
:	O
return	O
(	O
LN2OVERPI	O
-	O
log	function
(	O
dParm1	double
+	O
dTheta	double
*	O
dTheta	double
/	O
dParm1	double
)	O
)	O
;	O
case	O
MCV_USERLL	int
:	O
return	O
(	O
dParm1	double
)	O
;	O
default	O
:	O
ReportRunTimeError	function
(	O
panal	pointer
,	O
RE_UNKNOWNDIST	int
|	O
RE_FATAL	int
,	O
"LnDensity"	pointer
)	O
;	O
}	O
return	O
0.0	int
;	O
}	O
double	O
LnLike	function
(	O
PMCVAR	pointer
pMCVar	pointer
,	O
PANALYSIS	pointer
panal	pointer
)	O
{	O
long	O
n	int
;	O
double	O
dDensity	double
,	O
dLnLike	double
=	O
0.0	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
pMCVar	pointer
->	O
nDependents	long
;	O
n	int
++	O
)	O
{	O
dDensity	double
=	O
LnDensity	function
(	O
pMCVar	pointer
->	O
rgpDependents	pointer
[	O
n	int
]	O
,	O
panal	pointer
)	O
;	O
if	O
(	O
dDensity	double
==	O
NULL_SUPPORT	O
)	O
return	O
NULL_SUPPORT	O
;	O
else	O
dLnLike	double
+=	O
dDensity	double
;	O
}	O
return	O
dLnLike	double
;	O
}	O
double	O
LnLikeData	function
(	O
PLEVEL	pointer
plevel	pointer
,	O
PANALYSIS	pointer
panal	pointer
)	O
{	O
PMCVAR	pointer
pMCVar	pointer
;	O
long	O
i	long
,	O
j	long
,	O
k	pointer
;	O
double	O
dLnLike	double
=	O
0.0	int
;	O
double	O
dTmp	double
;	O
BOOL	int
bMissData	int
,	O
bMissOutp	int
;	O
static	O
PDOUBLE	pointer
pdBase	array
[	O
4	int
]	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
plevel	pointer
->	O
nLikes	long
;	O
i	long
++	O
)	O
{	O
pMCVar	pointer
=	O
plevel	pointer
->	O
rgpLikes	pointer
[	O
i	long
]	O
;	O
for	O
(	O
k	pointer
=	O
0	int
;	O
k	pointer
<	O
4	int
;	O
k	pointer
++	O
)	O
pdBase	array
[	O
k	pointer
]	O
=	O
pMCVar	pointer
->	O
pdParm	array
[	O
k	pointer
]	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
pMCVar	pointer
->	O
lCount	long
;	O
j	long
++	O
)	O
{	O
pMCVar	pointer
->	O
dVal	double
=	O
pMCVar	pointer
->	O
pdVal	pointer
[	O
j	long
]	O
;	O
if	O
(	O
pMCVar	pointer
->	O
dVal	double
!=	O
INPUT_MISSING_VALUE	O
)	O
{	O
bMissData	int
=	O
FALSE	int
;	O
bMissOutp	int
=	O
FALSE	int
;	O
for	O
(	O
k	pointer
=	O
0	int
;	O
k	pointer
<	O
4	int
;	O
k	pointer
++	O
)	O
{	O
if	O
(	O
pMCVar	pointer
->	O
iParmType	array
[	O
k	pointer
]	O
==	O
MCVP_PRED	int
)	O
{	O
pMCVar	pointer
->	O
pdParm	array
[	O
k	pointer
]	O
=	O
pdBase	array
[	O
k	pointer
]	O
+	O
j	long
;	O
bMissOutp	int
=	O
bMissOutp	int
+	O
(	O
*	O
(	O
pMCVar	pointer
->	O
pdParm	array
[	O
k	pointer
]	O
)	O
==	O
MISSING_VALUE	O
)	O
;	O
}	O
else	O
if	O
(	O
pMCVar	pointer
->	O
iParmType	array
[	O
k	pointer
]	O
==	O
MCVP_DATA	int
)	O
{	O
pMCVar	pointer
->	O
pdParm	array
[	O
k	pointer
]	O
=	O
pdBase	array
[	O
k	pointer
]	O
+	O
j	long
;	O
bMissData	int
=	O
bMissData	int
+	O
(	O
*	O
(	O
pMCVar	pointer
->	O
pdParm	array
[	O
k	pointer
]	O
)	O
==	O
INPUT_MISSING_VALUE	O
)	O
;	O
}	O
}	O
if	O
(	O
bMissData	int
==	O
FALSE	int
)	O
{	O
if	O
(	O
bMissOutp	int
==	O
FALSE	int
)	O
{	O
dTmp	double
=	O
LnDensity	function
(	O
pMCVar	pointer
,	O
panal	pointer
)	O
;	O
if	O
(	O
dTmp	double
==	O
NULL_SUPPORT	O
)	O
{	O
for	O
(	O
k	pointer
=	O
0	int
;	O
k	pointer
<	O
4	int
;	O
k	pointer
++	O
)	O
pMCVar	pointer
->	O
pdParm	array
[	O
k	pointer
]	O
=	O
pdBase	array
[	O
k	pointer
]	O
;	O
return	O
(	O
NULL_SUPPORT	O
)	O
;	O
}	O
else	O
dLnLike	double
=	O
dLnLike	double
+	O
dTmp	double
;	O
}	O
else	O
ReportRunTimeError	function
(	O
panal	pointer
,	O
RE_BADMODEL	int
|	O
RE_FATAL	int
,	O
"LnLikeData"	pointer
)	O
;	O
}	O
}	O
}	O
for	O
(	O
k	pointer
=	O
0	int
;	O
k	pointer
<	O
4	int
;	O
k	pointer
++	O
)	O
pMCVar	pointer
->	O
pdParm	array
[	O
k	pointer
]	O
=	O
pdBase	array
[	O
k	pointer
]	O
;	O
}	O
return	O
(	O
dLnLike	double
)	O
;	O
}	O
double	O
MaxMCVar	function
(	O
PMCVAR	pointer
pMCVar	pointer
)	O
{	O
if	O
(	O
pMCVar	pointer
->	O
iType	int
==	O
MCV_BINOMIAL	int
||	O
pMCVar	pointer
->	O
iType	int
==	O
MCV_POISSON	int
)	O
{	O
return	O
(	O
*	O
(	O
pMCVar	pointer
->	O
pdParm	array
[	O
3	int
]	O
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
pMCVar	pointer
->	O
iType	int
==	O
MCV_UNIFORM	int
||	O
pMCVar	pointer
->	O
iType	int
==	O
MCV_LOGUNIFORM	int
)	O
{	O
return	O
(	O
*	O
(	O
pMCVar	pointer
->	O
pdParm	array
[	O
1	int
]	O
)	O
)	O
;	O
}	O
else	O
{	O
return	O
(	O
*	O
(	O
pMCVar	pointer
->	O
pdParm	array
[	O
3	int
]	O
)	O
)	O
;	O
}	O
}	O
}	O
double	O
MinMCVar	function
(	O
PMCVAR	pointer
pMCVar	pointer
)	O
{	O
if	O
(	O
pMCVar	pointer
->	O
iType	int
==	O
MCV_BINOMIAL	int
||	O
pMCVar	pointer
->	O
iType	int
==	O
MCV_POISSON	int
)	O
{	O
return	O
(	O
*	O
(	O
pMCVar	pointer
->	O
pdParm	array
[	O
2	int
]	O
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
pMCVar	pointer
->	O
iType	int
==	O
MCV_UNIFORM	int
||	O
pMCVar	pointer
->	O
iType	int
==	O
MCV_LOGUNIFORM	int
)	O
{	O
return	O
(	O
*	O
(	O
pMCVar	pointer
->	O
pdParm	array
[	O
0	int
]	O
)	O
)	O
;	O
}	O
else	O
{	O
return	O
(	O
*	O
(	O
pMCVar	pointer
->	O
pdParm	array
[	O
2	int
]	O
)	O
)	O
;	O
}	O
}	O
}	O
void	O
RunTemperingBlock	function
(	O
PANALYSIS	pointer
panal	pointer
,	O
long	O
lRunLength	long
,	O
PLONG	pointer
iter	long
)	O
{	O
PGIBBSDATA	pointer
pgd	pointer
=	O
&	O
panal	pointer
->	O
gd	struct
;	O
PLEVEL	pointer
pLevel0	pointer
=	O
panal	pointer
->	O
pLevels	array
[	O
0	int
]	O
;	O
double	O
dTmp	double
,	O
dLnPrior	double
=	O
0	int
,	O
dLnData	double
=	O
0	int
;	O
long	O
i	long
,	O
j	long
;	O
long	O
nUpdateAt	long
,	O
nTotal	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
lRunLength	long
;	O
i	long
++	O
)	O
{	O
nTotal	long
=	O
UPDATE_BASE	int
;	O
nUpdateAt	long
=	O
*	O
iter	long
+	O
nTotal	long
;	O
TraverseLevels	function
(	O
pLevel0	pointer
,	O
SampleThetasTempered	function
,	O
panal	pointer
,	O
pgd	pointer
,	O
&	O
i	long
,	O
&	O
nUpdateAt	long
,	O
&	O
nTotal	long
,	O
&	O
pgd	pointer
->	O
indexT	int
,	O
NULL	O
)	O
;	O
dLnPrior	double
=	O
0.0	int
;	O
TraverseLevels	function
(	O
pLevel0	pointer
,	O
CalculateTotals	function
,	O
panal	pointer
,	O
&	O
dLnPrior	double
,	O
NULL	O
)	O
;	O
dLnData	double
=	O
0.0	int
;	O
TraverseLevels1	function
(	O
pLevel0	pointer
,	O
SumAllExpts	function
,	O
&	O
dLnData	double
,	O
NULL	O
)	O
;	O
dTmp	double
=	O
pgd	pointer
->	O
dCZero	double
/	O
(	O
double	O
)	O
(	O
i	long
+	O
pgd	pointer
->	O
dNZero	double
)	O
;	O
for	O
(	O
j	long
=	O
pgd	pointer
->	O
startT	int
;	O
j	long
<=	O
pgd	pointer
->	O
endT	int
;	O
j	long
++	O
)	O
{	O
if	O
(	O
j	long
==	O
pgd	pointer
->	O
indexT	int
)	O
pgd	pointer
->	O
rgdlnPi	pointer
[	O
j	long
]	O
-=	O
dTmp	double
;	O
else	O
pgd	pointer
->	O
rgdlnPi	pointer
[	O
j	long
]	O
+=	O
dTmp	double
/	O
(	O
double	O
)	O
pgd	pointer
->	O
nPerks	int
;	O
}	O
pgd	pointer
->	O
rglCount	pointer
[	O
pgd	pointer
->	O
indexT	int
]	O
=	O
pgd	pointer
->	O
rglCount	pointer
[	O
pgd	pointer
->	O
indexT	int
]	O
+	O
1	int
;	O
pgd	pointer
->	O
indexT	int
=	O
SampleTemperature2	function
(	O
pgd	pointer
,	O
dLnPrior	double
,	O
dLnData	double
)	O
;	O
if	O
(	O
i	long
==	O
nUpdateAt	long
)	O
{	O
nTotal	long
=	O
nTotal	long
*	O
3	int
/	O
2	int
;	O
nUpdateAt	long
=	O
i	long
+	O
nTotal	long
;	O
}	O
(	O
*	O
iter	long
)	O
++	O
;	O
}	O
}	O
double	O
NextDown	function
(	O
double	O
Perk	double
)	O
{	O
int	O
i	long
;	O
static	O
double	O
PTable	array
[	O
21	int
]	O
=	O
{	O
0	int
,	O
1E-6	int
,	O
1E-5	int
,	O
1E-4	int
,	O
1E-3	int
,	O
1E-2	int
,	O
0.1	int
,	O
0.2	int
,	O
0.3	int
,	O
0.5	int
,	O
0.6	int
,	O
0.7	int
,	O
0.8	int
,	O
0.9	int
,	O
0.95	int
,	O
0.97	int
,	O
0.99	int
,	O
0.999	int
,	O
0.9999	int
,	O
0.99999	int
,	O
1	int
}	O
;	O
i	long
=	O
0	int
;	O
while	O
(	O
Perk	double
>	O
PTable	array
[	O
i	long
]	O
)	O
{	O
i	long
++	O
;	O
}	O
return	O
(	O
i	long
==	O
0	int
?	O
PTable	array
[	O
i	long
]	O
:	O
PTable	array
[	O
i	long
-	O
1	int
]	O
)	O
;	O
}	O
void	O
InitPerks	function
(	O
PANALYSIS	pointer
panal	pointer
)	O
{	O
PGIBBSDATA	pointer
pgd	pointer
=	O
&	O
panal	pointer
->	O
gd	struct
;	O
long	O
i	long
,	O
j	long
,	O
k	pointer
,	O
iter	long
=	O
0	int
;	O
double	O
dTmp	double
;	O
int	O
bTrans	int
;	O
BOOL	int
bHappy	int
,	O
bTooManyTrials	int
;	O
if	O
(	O
(	O
pgd	pointer
->	O
nSimTypeFlag	long
==	O
3	int
)	O
||	O
(	O
pgd	pointer
->	O
nSimTypeFlag	long
==	O
4	int
)	O
)	O
{	O
if	O
(	O
!	O
(	O
pgd	pointer
->	O
rglTransAttempts	pointer
=	O
InitlVector	function
(	O
NTEMP	int
)	O
)	O
||	O
!	O
(	O
pgd	pointer
->	O
rglTransAccepts	pointer
=	O
InitlVector	function
(	O
NTEMP	int
)	O
)	O
)	O
ReportError	function
(	O
NULL	O
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"InitPerks"	pointer
,	O
NULL	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
NTEMP	int
;	O
i	long
++	O
)	O
pgd	pointer
->	O
rglTransAttempts	pointer
[	O
i	long
]	O
=	O
pgd	pointer
->	O
rglTransAccepts	pointer
[	O
i	long
]	O
=	O
0	int
;	O
if	O
(	O
pgd	pointer
->	O
nPerks	int
==	O
0	int
)	O
{	O
printf	function
(	O
"Setting perks (inverse temperatures).\n"	pointer
)	O
;	O
pgd	pointer
->	O
nPerks	int
=	O
NTEMP	int
;	O
if	O
(	O
!	O
(	O
pgd	pointer
->	O
rgdPerks	pointer
=	O
InitdVector	function
(	O
NTEMP	int
)	O
)	O
||	O
!	O
(	O
pgd	pointer
->	O
rgdlnPi	pointer
=	O
InitdVector	function
(	O
NTEMP	int
)	O
)	O
||	O
!	O
(	O
pgd	pointer
->	O
rglCount	pointer
=	O
InitlVector	function
(	O
NTEMP	int
)	O
)	O
)	O
ReportError	function
(	O
NULL	O
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"InitPerks"	pointer
,	O
NULL	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
NTEMP	int
;	O
i	long
++	O
)	O
{	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
i	long
]	O
=	O
pgd	pointer
->	O
rgdlnPi	pointer
[	O
i	long
]	O
=	O
pgd	pointer
->	O
rglCount	pointer
[	O
i	long
]	O
=	O
0	int
;	O
}	O
pgd	pointer
->	O
endT	int
=	O
NTEMP	int
-	O
1	int
;	O
pgd	pointer
->	O
startT	int
=	O
NTEMP	int
-	O
2	int
;	O
pgd	pointer
->	O
indexT	int
=	O
pgd	pointer
->	O
startT	int
;	O
double	O
dEPSILON	double
=	O
0.99	int
;	O
double	O
dUP	double
=	O
2.0	int
;	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
pgd	pointer
->	O
startT	int
]	O
=	O
dEPSILON	double
;	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
pgd	pointer
->	O
endT	int
]	O
=	O
1.00	int
;	O
long	O
nOldPrintIter	long
=	O
pgd	pointer
->	O
nPrintIter	long
;	O
pgd	pointer
->	O
nPrintIter	long
=	O
-	O
pgd	pointer
->	O
nMaxPerkSetIter	long
;	O
int	O
lRunLength	long
=	O
100	int
;	O
double	O
dBoundary	double
=	O
0.0	int
;	O
do	O
{	O
pgd	pointer
->	O
indexT	int
=	O
pgd	pointer
->	O
startT	int
;	O
RunTemperingBlock	function
(	O
panal	pointer
,	O
lRunLength	long
,	O
&	O
iter	long
)	O
;	O
PrintTemperatureDiagnostics	function
(	O
stdout	pointer
,	O
pgd	pointer
)	O
;	O
PrintTemperatureDiagnostics	function
(	O
pgd	pointer
->	O
pfilePerks	pointer
,	O
pgd	pointer
)	O
;	O
bTrans	int
=	O
CheckTransitions	function
(	O
pgd	pointer
)	O
;	O
if	O
(	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
pgd	pointer
->	O
startT	int
]	O
==	O
dBoundary	double
)	O
{	O
bHappy	int
=	O
(	O
bTrans	int
>	O
-	O
1	int
)	O
;	O
}	O
else	O
{	O
bHappy	int
=	O
FALSE	int
;	O
}	O
bTooManyTrials	int
=	O
(	O
iter	long
>	O
pgd	pointer
->	O
nMaxPerkSetIter	long
)	O
;	O
if	O
(	O
!	O
bHappy	int
)	O
{	O
if	O
(	O
bTrans	int
==	O
-	O
1	int
)	O
{	O
printf	function
(	O
"acceptance rate 1<->2 too low, stepping back up\n"	pointer
)	O
;	O
dTmp	double
=	O
(	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
pgd	pointer
->	O
startT	int
]	O
+	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
pgd	pointer
->	O
startT	int
+	O
1	int
]	O
)	O
/	O
dUP	double
;	O
pgd	pointer
->	O
rgdlnPi	pointer
[	O
pgd	pointer
->	O
startT	int
]	O
=	O
(	O
pgd	pointer
->	O
rgdlnPi	pointer
[	O
pgd	pointer
->	O
startT	int
]	O
+	O
Extrapolate	function
(	O
pgd	pointer
,	O
dTmp	double
,	O
pgd	pointer
->	O
startT	int
,	O
pgd	pointer
->	O
startT	int
+	O
1	int
)	O
)	O
/	O
2	int
;	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
pgd	pointer
->	O
startT	int
]	O
=	O
dTmp	double
;	O
}	O
if	O
(	O
bTrans	int
==	O
+	O
1	int
)	O
{	O
printf	function
(	O
"acceptance rate 1<->2 too high, moving down\n"	pointer
)	O
;	O
dTmp	double
=	O
NextDown	function
(	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
pgd	pointer
->	O
startT	int
]	O
)	O
;	O
pgd	pointer
->	O
rgdlnPi	pointer
[	O
pgd	pointer
->	O
startT	int
]	O
=	O
(	O
pgd	pointer
->	O
rgdlnPi	pointer
[	O
pgd	pointer
->	O
startT	int
]	O
+	O
Extrapolate	function
(	O
pgd	pointer
,	O
dTmp	double
,	O
pgd	pointer
->	O
startT	int
,	O
pgd	pointer
->	O
startT	int
+	O
1	int
)	O
)	O
/	O
2	int
;	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
pgd	pointer
->	O
startT	int
]	O
=	O
dTmp	double
;	O
}	O
if	O
(	O
bTrans	int
==	O
0	int
)	O
{	O
if	O
(	O
pgd	pointer
->	O
startT	int
>	O
0	int
)	O
{	O
printf	function
(	O
"acceptance rate 1<->2 ok, adding a new point\n"	pointer
)	O
;	O
if	O
(	O
CheckAllTransitions	function
(	O
pgd	pointer
)	O
)	O
{	O
int	O
i	long
=	O
pgd	pointer
->	O
endT	int
;	O
int	O
j	long
=	O
i	long
-	O
2	int
;	O
while	O
(	O
j	long
>=	O
pgd	pointer
->	O
startT	int
)	O
{	O
if	O
(	O
EqualSlopes	function
(	O
pgd	pointer
->	O
rgdPerks	pointer
,	O
pgd	pointer
->	O
rgdlnPi	pointer
,	O
j	long
)	O
)	O
{	O
for	O
(	O
k	pointer
=	O
j	long
;	O
k	pointer
>=	O
pgd	pointer
->	O
startT	int
;	O
k	pointer
--	O
)	O
{	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
k	pointer
+	O
1	int
]	O
=	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
k	pointer
]	O
;	O
pgd	pointer
->	O
rgdlnPi	pointer
[	O
k	pointer
+	O
1	int
]	O
=	O
pgd	pointer
->	O
rgdlnPi	pointer
[	O
k	pointer
]	O
;	O
pgd	pointer
->	O
rglCount	pointer
[	O
k	pointer
+	O
1	int
]	O
=	O
pgd	pointer
->	O
rglCount	pointer
[	O
k	pointer
]	O
;	O
}	O
pgd	pointer
->	O
startT	int
++	O
;	O
if	O
(	O
pgd	pointer
->	O
indexT	int
<=	O
j	long
)	O
pgd	pointer
->	O
indexT	int
++	O
;	O
lRunLength	long
=	O
lRunLength	long
-	O
100	int
;	O
printf	function
(	O
"Scale has been reduced.\n"	pointer
)	O
;	O
}	O
else	O
{	O
i	long
--	O
;	O
j	long
--	O
;	O
}	O
}	O
}	O
pgd	pointer
->	O
startT	int
=	O
pgd	pointer
->	O
startT	int
-	O
1	int
;	O
pgd	pointer
->	O
indexT	int
=	O
pgd	pointer
->	O
startT	int
;	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
pgd	pointer
->	O
startT	int
]	O
=	O
NextDown	function
(	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
pgd	pointer
->	O
startT	int
+	O
1	int
]	O
)	O
;	O
pgd	pointer
->	O
rgdlnPi	pointer
[	O
pgd	pointer
->	O
startT	int
]	O
=	O
(	O
pgd	pointer
->	O
rgdlnPi	pointer
[	O
pgd	pointer
->	O
startT	int
+	O
1	int
]	O
+	O
Extrapolate	function
(	O
pgd	pointer
,	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
pgd	pointer
->	O
startT	int
]	O
,	O
pgd	pointer
->	O
startT	int
+	O
1	int
,	O
pgd	pointer
->	O
startT	int
+	O
2	int
)	O
)	O
/	O
2	int
;	O
lRunLength	long
=	O
lRunLength	long
+	O
100	int
;	O
}	O
else	O
bTooManyTrials	int
=	O
TRUE	int
;	O
}	O
for	O
(	O
i	long
=	O
pgd	pointer
->	O
startT	int
;	O
i	long
<=	O
pgd	pointer
->	O
endT	int
;	O
i	long
++	O
)	O
{	O
pgd	pointer
->	O
rglCount	pointer
[	O
i	long
]	O
=	O
0	int
;	O
pgd	pointer
->	O
rglTransAttempts	pointer
[	O
i	long
]	O
=	O
pgd	pointer
->	O
rglTransAccepts	pointer
[	O
i	long
]	O
=	O
0	int
;	O
}	O
}	O
}	O
while	O
(	O
(	O
!	O
bHappy	int
)	O
&&	O
(	O
!	O
bTooManyTrials	int
)	O
)	O
;	O
if	O
(	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
pgd	pointer
->	O
startT	int
]	O
==	O
dBoundary	double
)	O
printf	function
(	O
"Perk %lg reached in %ld iterations.\n"	pointer
,	O
dBoundary	double
,	O
iter	long
)	O
;	O
else	O
printf	function
(	O
"Perk %lg not reached in %ld iterations...\n"	pointer
,	O
dBoundary	double
,	O
iter	long
)	O
;	O
pgd	pointer
->	O
nPrintIter	long
=	O
nOldPrintIter	long
;	O
int	O
iCount	int
=	O
pgd	pointer
->	O
endT	int
-	O
pgd	pointer
->	O
startT	int
+	O
1	int
;	O
if	O
(	O
iCount	int
!=	O
NTEMP	int
)	O
{	O
pgd	pointer
->	O
nPerks	int
=	O
iCount	int
;	O
pgd	pointer
->	O
indexT	int
=	O
pgd	pointer
->	O
indexT	int
-	O
pgd	pointer
->	O
startT	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
iCount	int
;	O
i	long
++	O
)	O
{	O
j	long
=	O
pgd	pointer
->	O
startT	int
+	O
i	long
;	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
i	long
]	O
=	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
j	long
]	O
;	O
pgd	pointer
->	O
rgdlnPi	pointer
[	O
i	long
]	O
=	O
pgd	pointer
->	O
rgdlnPi	pointer
[	O
j	long
]	O
;	O
pgd	pointer
->	O
rglCount	pointer
[	O
i	long
]	O
=	O
0	int
;	O
}	O
pgd	pointer
->	O
startT	int
=	O
0	int
;	O
pgd	pointer
->	O
endT	int
=	O
iCount	int
-	O
1	int
;	O
}	O
printf	function
(	O
"Done with InitPerks - Continuing.\n\n"	pointer
)	O
;	O
}	O
}	O
}	O
void	O
OpenMarkovFiles	function
(	O
PANALYSIS	pointer
panal	pointer
)	O
{	O
PGIBBSDATA	pointer
pgd	pointer
=	O
&	O
panal	pointer
->	O
gd	struct
;	O
char	O
*	O
with_rank	pointer
;	O
if	O
(	O
panal	pointer
->	O
bDependents	int
)	O
return	O
;	O
if	O
(	O
panal	pointer
->	O
bCommandLineSpec	int
)	O
{	O
free	function
(	O
pgd	pointer
->	O
szGout	pointer
)	O
;	O
panal	pointer
->	O
bAllocatedFileName	int
=	O
FALSE	int
;	O
pgd	pointer
->	O
szGout	pointer
=	O
panal	pointer
->	O
szOutfilename	pointer
;	O
}	O
else	O
if	O
(	O
!	O
(	O
pgd	pointer
->	O
szGout	pointer
)	O
)	O
pgd	pointer
->	O
szGout	pointer
=	O
"MCMC.default.out"	pointer
;	O
if	O
(	O
panal	pointer
->	O
size	int
>	O
1	int
)	O
{	O
with_rank	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
char	O
)	O
*	O
(	O
6	int
+	O
strlen	function
(	O
pgd	pointer
->	O
szGout	pointer
)	O
)	O
)	O
;	O
sprintf	function
(	O
with_rank	pointer
,	O
"%04d_%s"	pointer
,	O
panal	pointer
->	O
rank	int
,	O
pgd	pointer
->	O
szGout	pointer
)	O
;	O
pgd	pointer
->	O
szGout	pointer
=	O
with_rank	pointer
;	O
}	O
if	O
(	O
pgd	pointer
->	O
szGrestart	pointer
)	O
if	O
(	O
!	O
(	O
pgd	pointer
->	O
pfileRestart	pointer
)	O
&&	O
!	O
(	O
pgd	pointer
->	O
pfileRestart	pointer
=	O
fopen	function
(	O
pgd	pointer
->	O
szGrestart	pointer
,	O
"r"	pointer
)	O
)	O
)	O
ReportRunTimeError	function
(	O
panal	pointer
,	O
RE_FATAL	int
|	O
RE_CANNOTOPEN	int
,	O
pgd	pointer
->	O
szGrestart	pointer
,	O
"OpenMarkovFiles"	pointer
)	O
;	O
if	O
(	O
!	O
(	O
pgd	pointer
->	O
pfileOut	pointer
)	O
&&	O
!	O
(	O
pgd	pointer
->	O
pfileOut	pointer
=	O
fopen	function
(	O
pgd	pointer
->	O
szGout	pointer
,	O
"w"	pointer
)	O
)	O
)	O
ReportRunTimeError	function
(	O
panal	pointer
,	O
RE_FATAL	int
|	O
RE_CANNOTOPEN	int
,	O
pgd	pointer
->	O
szGout	pointer
,	O
"OpenMarkovFiles"	pointer
)	O
;	O
if	O
(	O
(	O
pgd	pointer
->	O
nSimTypeFlag	long
==	O
3	int
)	O
||	O
(	O
pgd	pointer
->	O
nSimTypeFlag	long
==	O
4	int
)	O
)	O
{	O
char	O
szFileName	array
[	O
MAX_FILENAMESIZE	int
+	O
6	int
]	O
;	O
sprintf	function
(	O
szFileName	array
,	O
"%s%s"	pointer
,	O
pgd	pointer
->	O
szGout	pointer
,	O
".perks"	pointer
)	O
;	O
if	O
(	O
!	O
(	O
pgd	pointer
->	O
pfilePerks	pointer
)	O
&&	O
!	O
(	O
pgd	pointer
->	O
pfilePerks	pointer
=	O
fopen	function
(	O
szFileName	array
,	O
"w"	pointer
)	O
)	O
)	O
ReportRunTimeError	function
(	O
panal	pointer
,	O
RE_FATAL	int
|	O
RE_CANNOTOPEN	int
,	O
szFileName	array
,	O
"OpenMarkovFiles"	pointer
)	O
;	O
}	O
}	O
void	O
PrintAllExpts	function
(	O
PLEVEL	pointer
plevel	pointer
,	O
PANALYSIS	pointer
panal	pointer
,	O
PFILE	pointer
pOutFile	pointer
)	O
{	O
long	O
n	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	pointer
->	O
iInstances	int
;	O
n	int
++	O
)	O
TraverseLevels1	function
(	O
plevel	pointer
->	O
pLevels	array
[	O
n	int
]	O
,	O
PrintExpt	function
,	O
panal	pointer
,	O
pOutFile	pointer
,	O
NULL	O
)	O
;	O
}	O
void	O
PrintDeps	function
(	O
PLEVEL	pointer
plevel	pointer
,	O
char	O
*	O
*	O
args	pointer
)	O
{	O
long	O
n	int
,	O
m	long
;	O
PMCVAR	pointer
pMCVar	pointer
;	O
printf	function
(	O
"Depth %d; Instance %d\n"	pointer
,	O
plevel	pointer
->	O
iDepth	int
,	O
plevel	pointer
->	O
iSequence	int
)	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	pointer
->	O
nMCVars	long
;	O
n	int
++	O
)	O
{	O
pMCVar	pointer
=	O
plevel	pointer
->	O
rgpMCVars	pointer
[	O
n	int
]	O
;	O
printf	function
(	O
"Variable %s (%d) [%"	pointer
PRIxPTR	O
"]\n"	pointer
,	O
pMCVar	pointer
->	O
pszName	pointer
,	O
pMCVar	pointer
->	O
iDepth	int
,	O
(	O
intptr_t	long
)	O
pMCVar	pointer
)	O
;	O
for	O
(	O
m	long
=	O
0	int
;	O
m	long
<	O
4	int
;	O
m	long
++	O
)	O
if	O
(	O
pMCVar	pointer
->	O
pMCVParent	array
[	O
m	long
]	O
!=	O
NULL	O
)	O
printf	function
(	O
"  Parent %ld: %s (%d) [%"	pointer
PRIxPTR	O
"]\n"	pointer
,	O
m	long
,	O
pMCVar	pointer
->	O
pMCVParent	array
[	O
m	long
]	O
->	O
pszName	pointer
,	O
pMCVar	pointer
->	O
pMCVParent	array
[	O
m	long
]	O
->	O
iDepth	int
,	O
(	O
intptr_t	long
)	O
pMCVar	pointer
->	O
pMCVParent	array
[	O
m	long
]	O
)	O
;	O
for	O
(	O
m	long
=	O
0	int
;	O
m	long
<	O
pMCVar	pointer
->	O
nDependents	long
;	O
m	long
++	O
)	O
printf	function
(	O
"  Dependent: %s (%d) [%"	pointer
PRIxPTR	O
"]\n"	pointer
,	O
pMCVar	pointer
->	O
rgpDependents	pointer
[	O
m	long
]	O
->	O
pszName	pointer
,	O
pMCVar	pointer
->	O
rgpDependents	pointer
[	O
m	long
]	O
->	O
iDepth	int
,	O
(	O
intptr_t	long
)	O
pMCVar	pointer
->	O
rgpDependents	pointer
[	O
m	long
]	O
)	O
;	O
if	O
(	O
pMCVar	pointer
->	O
bExptIsDep	int
)	O
printf	function
(	O
"  This variable influences experiments directly\n"	pointer
)	O
;	O
}	O
}	O
int	O
PrintExpt	function
(	O
PLEVEL	pointer
plevel	pointer
,	O
char	O
*	O
*	O
args	pointer
)	O
{	O
PANALYSIS	pointer
panal	pointer
=	O
(	O
PANALYSIS	pointer
)	O
args	pointer
[	O
0	int
]	O
;	O
PFILE	pointer
pOutFile	pointer
=	O
(	O
PFILE	pointer
)	O
args	pointer
[	O
1	int
]	O
;	O
long	O
k	pointer
,	O
l	pointer
,	O
m	long
,	O
n	int
;	O
PEXPERIMENT	pointer
pExpt	pointer
=	O
plevel	pointer
->	O
pexpt	pointer
;	O
POUTSPEC	pointer
pos	pointer
;	O
static	O
long	O
printed_head	long
=	O
0	int
;	O
if	O
(	O
!	O
printed_head	long
)	O
{	O
fprintf	function
(	O
pOutFile	pointer
,	O
"Level\tSimulation\tOutput_Var\tTime\tData\tPrediction\n"	pointer
)	O
;	O
printed_head	long
=	O
1	int
;	O
}	O
panal	pointer
->	O
pCurrentLevel	array
[	O
plevel	pointer
->	O
iDepth	int
]	O
=	O
plevel	pointer
;	O
panal	pointer
->	O
iInstance	array
[	O
plevel	pointer
->	O
iDepth	int
]	O
=	O
plevel	pointer
->	O
iSequence	int
;	O
if	O
(	O
pExpt	pointer
!=	O
NULL	O
)	O
{	O
InitModel	function
(	O
)	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<=	O
plevel	pointer
->	O
iDepth	int
;	O
n	int
++	O
)	O
{	O
SetModelVars	function
(	O
panal	pointer
->	O
pCurrentLevel	array
[	O
n	int
]	O
)	O
;	O
SetFixedVars	function
(	O
panal	pointer
->	O
pCurrentLevel	array
[	O
n	int
]	O
)	O
;	O
}	O
if	O
(	O
!	O
DoOneExperiment	function
(	O
pExpt	pointer
)	O
)	O
{	O
printf	function
(	O
"Warning: DoOneExperiment failed\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
pos	pointer
=	O
&	O
pExpt	pointer
->	O
os	struct
;	O
for	O
(	O
m	long
=	O
0	int
;	O
m	long
<	O
pos	pointer
->	O
nOutputs	int
;	O
m	long
++	O
)	O
{	O
for	O
(	O
k	pointer
=	O
0	int
;	O
k	pointer
<	O
pos	pointer
->	O
nData	int
;	O
k	pointer
++	O
)	O
if	O
(	O
!	O
strcmp	function
(	O
pos	pointer
->	O
pszDataNames	pointer
[	O
k	pointer
]	O
,	O
pos	pointer
->	O
pszOutputNames	pointer
[	O
m	long
]	O
)	O
)	O
break	O
;	O
for	O
(	O
l	pointer
=	O
0	int
;	O
l	pointer
<	O
pos	pointer
->	O
pcOutputTimes	pointer
[	O
m	long
]	O
;	O
l	pointer
++	O
)	O
{	O
for	O
(	O
n	int
=	O
1	int
;	O
n	int
<	O
plevel	pointer
->	O
iDepth	int
;	O
n	int
++	O
)	O
fprintf	function
(	O
pOutFile	pointer
,	O
"%d_"	pointer
,	O
panal	pointer
->	O
iInstance	array
[	O
n	int
]	O
)	O
;	O
fprintf	function
(	O
pOutFile	pointer
,	O
"%d\t"	pointer
,	O
panal	pointer
->	O
iInstance	array
[	O
plevel	pointer
->	O
iDepth	int
]	O
)	O
;	O
if	O
(	O
k	pointer
!=	O
pos	pointer
->	O
nData	int
)	O
fprintf	function
(	O
pOutFile	pointer
,	O
"%d\t%s\t%g\t%g\t%g\n"	pointer
,	O
pExpt	pointer
->	O
iExp	int
,	O
pos	pointer
->	O
pszOutputNames	pointer
[	O
m	long
]	O
,	O
pos	pointer
->	O
prgdOutputTimes	pointer
[	O
m	long
]	O
[	O
l	pointer
]	O
,	O
pos	pointer
->	O
prgdDataVals	pointer
[	O
k	pointer
]	O
[	O
l	pointer
]	O
,	O
pos	pointer
->	O
prgdOutputVals	pointer
[	O
m	long
]	O
[	O
l	pointer
]	O
)	O
;	O
else	O
fprintf	function
(	O
pOutFile	pointer
,	O
"%d\t%s\t%g\t\t%g\n"	pointer
,	O
pExpt	pointer
->	O
iExp	int
,	O
pos	pointer
->	O
pszOutputNames	pointer
[	O
m	long
]	O
,	O
pos	pointer
->	O
prgdOutputTimes	pointer
[	O
m	long
]	O
[	O
l	pointer
]	O
,	O
pos	pointer
->	O
prgdOutputVals	pointer
[	O
m	long
]	O
[	O
l	pointer
]	O
)	O
;	O
}	O
fprintf	function
(	O
pOutFile	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
fprintf	function
(	O
pOutFile	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
}	O
return	O
(	O
1	int
)	O
;	O
}	O
void	O
PrintTemperatureDiagnostics	function
(	O
PFILE	pointer
fOut	pointer
,	O
PGIBBSDATA	pointer
pgd	pointer
)	O
{	O
register	O
int	O
i	long
;	O
fprintf	function
(	O
fOut	pointer
,	O
"\nPerks:"	pointer
)	O
;	O
for	O
(	O
i	long
=	O
pgd	pointer
->	O
startT	int
;	O
i	long
<=	O
pgd	pointer
->	O
endT	int
;	O
i	long
++	O
)	O
{	O
fprintf	function
(	O
fOut	pointer
,	O
"\t%g"	pointer
,	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
i	long
]	O
)	O
;	O
}	O
fprintf	function
(	O
fOut	pointer
,	O
"\nCounts:"	pointer
)	O
;	O
for	O
(	O
i	long
=	O
pgd	pointer
->	O
startT	int
;	O
i	long
<=	O
pgd	pointer
->	O
endT	int
;	O
i	long
++	O
)	O
{	O
fprintf	function
(	O
fOut	pointer
,	O
"\t%ld"	pointer
,	O
pgd	pointer
->	O
rglCount	pointer
[	O
i	long
]	O
)	O
;	O
}	O
fprintf	function
(	O
fOut	pointer
,	O
"\nLnPi(i):"	pointer
)	O
;	O
for	O
(	O
i	long
=	O
pgd	pointer
->	O
startT	int
;	O
i	long
<=	O
pgd	pointer
->	O
endT	int
;	O
i	long
++	O
)	O
{	O
fprintf	function
(	O
fOut	pointer
,	O
"\t%g"	pointer
,	O
pgd	pointer
->	O
rgdlnPi	pointer
[	O
i	long
]	O
)	O
;	O
}	O
fprintf	function
(	O
fOut	pointer
,	O
"\nTried Jumps:\t"	pointer
)	O
;	O
for	O
(	O
i	long
=	O
pgd	pointer
->	O
startT	int
;	O
i	long
<=	O
pgd	pointer
->	O
endT	int
-	O
1	int
;	O
i	long
++	O
)	O
{	O
fprintf	function
(	O
fOut	pointer
,	O
"\t%ld"	pointer
,	O
pgd	pointer
->	O
rglTransAttempts	pointer
[	O
i	long
]	O
)	O
;	O
}	O
fprintf	function
(	O
fOut	pointer
,	O
"\nAccepted Jumps:\t"	pointer
)	O
;	O
for	O
(	O
i	long
=	O
pgd	pointer
->	O
startT	int
;	O
i	long
<=	O
pgd	pointer
->	O
endT	int
-	O
1	int
;	O
i	long
++	O
)	O
{	O
fprintf	function
(	O
fOut	pointer
,	O
"\t%ld"	pointer
,	O
pgd	pointer
->	O
rglTransAccepts	pointer
[	O
i	long
]	O
)	O
;	O
}	O
fprintf	function
(	O
fOut	pointer
,	O
"\n\n"	pointer
)	O
;	O
fflush	function
(	O
fOut	pointer
)	O
;	O
}	O
void	O
ReadData	function
(	O
PLEVEL	pointer
plevel	pointer
,	O
char	O
*	O
*	O
args	pointer
)	O
{	O
FILE	struct
*	O
pfileData	pointer
=	O
(	O
FILE	struct
*	O
)	O
args	pointer
[	O
0	int
]	O
;	O
POUTSPEC	pointer
pos	pointer
;	O
int	O
cDat	int
,	O
i	long
,	O
j	long
;	O
if	O
(	O
plevel	pointer
->	O
pexpt	pointer
==	O
NULL	O
)	O
return	O
;	O
pos	pointer
=	O
&	O
(	O
plevel	pointer
->	O
pexpt	pointer
->	O
os	struct
)	O
;	O
cDat	int
=	O
pos	pointer
->	O
nOutputs	int
;	O
pos	pointer
->	O
prgdDataVals	pointer
=	O
InitpdVector	function
(	O
cDat	int
)	O
;	O
pos	pointer
->	O
pcData	pointer
=	O
InitiVector	function
(	O
cDat	int
)	O
;	O
pos	pointer
->	O
pszDataNames	pointer
=	O
(	O
PSTR	pointer
*	O
)	O
malloc	function
(	O
cDat	int
*	O
sizeof	O
(	O
PSTR	pointer
)	O
)	O
;	O
pos	pointer
->	O
phvar_dat	pointer
=	O
(	O
HVAR	long
*	O
)	O
malloc	function
(	O
cDat	int
*	O
sizeof	O
(	O
HVAR	long
)	O
)	O
;	O
if	O
(	O
pos	pointer
->	O
prgdDataVals	pointer
==	O
NULL	O
||	O
pos	pointer
->	O
phvar_dat	pointer
==	O
NULL	O
||	O
pos	pointer
->	O
pszDataNames	pointer
==	O
NULL	O
||	O
pos	pointer
->	O
pcData	pointer
==	O
NULL	O
)	O
ReportError	function
(	O
NULL	O
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"ReadData()"	pointer
,	O
NULL	O
)	O
;	O
else	O
{	O
pos	pointer
->	O
nData	int
=	O
cDat	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
cDat	int
;	O
i	long
++	O
)	O
{	O
if	O
(	O
!	O
(	O
pos	pointer
->	O
prgdDataVals	pointer
[	O
i	long
]	O
=	O
InitdVector	function
(	O
pos	pointer
->	O
pcOutputTimes	pointer
[	O
i	long
]	O
)	O
)	O
)	O
ReportError	function
(	O
NULL	O
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"ReadData()"	pointer
,	O
NULL	O
)	O
;	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
pos	pointer
->	O
pcOutputTimes	pointer
[	O
i	long
]	O
;	O
j	long
++	O
)	O
if	O
(	O
fscanf	function
(	O
pfileData	pointer
,	O
"%lg"	pointer
,	O
&	O
(	O
pos	pointer
->	O
prgdDataVals	pointer
[	O
i	long
]	O
[	O
j	long
]	O
)	O
)	O
==	O
EOF	O
)	O
{	O
printf	function
(	O
"Error: incorrect length for data file - Exiting\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
pos	pointer
->	O
pcData	pointer
[	O
i	long
]	O
=	O
j	long
;	O
pos	pointer
->	O
phvar_dat	pointer
[	O
i	long
]	O
=	O
pos	pointer
->	O
phvar_out	pointer
[	O
i	long
]	O
;	O
pos	pointer
->	O
pszDataNames	pointer
[	O
i	long
]	O
=	O
pos	pointer
->	O
pszOutputNames	pointer
[	O
i	long
]	O
;	O
}	O
}	O
}	O
void	O
ReadDataFile	function
(	O
PANALYSIS	pointer
panal	pointer
)	O
{	O
if	O
(	O
panal	pointer
->	O
gd	struct
.	O
szGdata	pointer
)	O
{	O
char	O
c	pointer
;	O
FILE	struct
*	O
pfile	pointer
=	O
fopen	function
(	O
panal	pointer
->	O
gd	struct
.	O
szGdata	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
!	O
pfile	pointer
)	O
{	O
printf	function
(	O
"Cannot open data file '%s'\n"	pointer
,	O
panal	pointer
->	O
gd	struct
.	O
szGdata	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
do	O
{	O
c	pointer
=	O
getc	function
(	O
pfile	pointer
)	O
;	O
}	O
while	O
(	O
c	pointer
!=	O
'\n'	O
)	O
;	O
TraverseLevels	function
(	O
panal	pointer
->	O
pLevels	array
[	O
0	int
]	O
,	O
ReadData	function
,	O
pfile	pointer
,	O
NULL	O
)	O
;	O
fclose	function
(	O
pfile	pointer
)	O
;	O
}	O
}	O
void	O
ReadRestart	function
(	O
FILE	struct
*	O
pfileRestart	pointer
,	O
long	O
nThetas	long
,	O
PDOUBLE	pointer
*	O
pdTheta	pointer
,	O
PDOUBLE	pointer
*	O
pdSum	pointer
,	O
PDOUBLE	pointer
*	O
*	O
prgdSumProd	pointer
,	O
long	O
*	O
pIter	pointer
)	O
{	O
register	O
char	O
c	pointer
;	O
register	O
long	O
i	long
,	O
j	long
;	O
if	O
(	O
*	O
pdTheta	pointer
==	O
NULL	O
)	O
if	O
(	O
!	O
(	O
*	O
pdTheta	pointer
=	O
InitdVector	function
(	O
nThetas	long
)	O
)	O
)	O
ReportRunTimeError	function
(	O
NULL	O
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"ReadRestart"	pointer
)	O
;	O
if	O
(	O
*	O
pdSum	pointer
==	O
NULL	O
)	O
if	O
(	O
!	O
(	O
*	O
pdSum	pointer
=	O
InitdVector	function
(	O
nThetas	long
)	O
)	O
)	O
ReportRunTimeError	function
(	O
NULL	O
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"ReadRestart"	pointer
)	O
;	O
if	O
(	O
*	O
prgdSumProd	pointer
==	O
NULL	O
)	O
if	O
(	O
!	O
(	O
*	O
prgdSumProd	pointer
=	O
InitdMatrix	function
(	O
nThetas	long
,	O
nThetas	long
)	O
)	O
)	O
ReportRunTimeError	function
(	O
NULL	O
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"ReadRestart"	pointer
)	O
;	O
*	O
pIter	pointer
=	O
-	O
1	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nThetas	long
;	O
i	long
++	O
)	O
{	O
(	O
*	O
pdSum	pointer
)	O
[	O
i	long
]	O
=	O
0.0	int
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
nThetas	long
;	O
j	long
++	O
)	O
(	O
*	O
prgdSumProd	pointer
)	O
[	O
i	long
]	O
[	O
j	long
]	O
=	O
0.0	int
;	O
}	O
do	O
{	O
c	pointer
=	O
getc	function
(	O
pfileRestart	pointer
)	O
;	O
}	O
while	O
(	O
c	pointer
!=	O
'\n'	O
)	O
;	O
while	O
(	O
!	O
(	O
feof	function
(	O
pfileRestart	pointer
)	O
||	O
(	O
fscanf	function
(	O
pfileRestart	pointer
,	O
"%*s"	pointer
)	O
==	O
EOF	O
)	O
)	O
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nThetas	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
fscanf	function
(	O
pfileRestart	pointer
,	O
"%lg"	pointer
,	O
&	O
(	O
(	O
*	O
pdTheta	pointer
)	O
[	O
i	long
]	O
)	O
)	O
==	O
EOF	O
)	O
{	O
printf	function
(	O
"Error: incorrect length for restart file - Exiting\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
else	O
{	O
(	O
*	O
pdSum	pointer
)	O
[	O
i	long
]	O
+=	O
(	O
*	O
pdTheta	pointer
)	O
[	O
i	long
]	O
;	O
}	O
}	O
do	O
{	O
c	pointer
=	O
getc	function
(	O
pfileRestart	pointer
)	O
;	O
}	O
while	O
(	O
c	pointer
!=	O
'\n'	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nThetas	long
;	O
i	long
++	O
)	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
nThetas	long
;	O
j	long
++	O
)	O
(	O
*	O
prgdSumProd	pointer
)	O
[	O
i	long
]	O
[	O
j	long
]	O
+=	O
(	O
*	O
pdTheta	pointer
)	O
[	O
i	long
]	O
*	O
(	O
*	O
pdTheta	pointer
)	O
[	O
j	long
]	O
;	O
*	O
pIter	pointer
=	O
*	O
pIter	pointer
+	O
1	int
;	O
}	O
fclose	function
(	O
pfileRestart	pointer
)	O
;	O
}	O
void	O
ReadRestartTemper	function
(	O
FILE	struct
*	O
pfileRestart	pointer
,	O
long	O
nThetas	long
,	O
int	O
nPerks	int
,	O
PDOUBLE	pointer
*	O
pdTheta	pointer
,	O
PDOUBLE	pointer
*	O
pdSum	pointer
,	O
PDOUBLE	pointer
*	O
*	O
prgdSumProd	pointer
,	O
long	O
*	O
pIter	pointer
,	O
int	O
*	O
pindexT	pointer
,	O
double	O
*	O
pdlnPi	pointer
)	O
{	O
register	O
char	O
c	pointer
;	O
register	O
long	O
i	long
,	O
j	long
;	O
if	O
(	O
*	O
pdTheta	pointer
==	O
NULL	O
)	O
if	O
(	O
!	O
(	O
*	O
pdTheta	pointer
=	O
InitdVector	function
(	O
nThetas	long
)	O
)	O
)	O
ReportRunTimeError	function
(	O
NULL	O
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"ReadRestart"	pointer
)	O
;	O
if	O
(	O
*	O
pdSum	pointer
==	O
NULL	O
)	O
if	O
(	O
!	O
(	O
*	O
pdSum	pointer
=	O
InitdVector	function
(	O
nThetas	long
)	O
)	O
)	O
ReportRunTimeError	function
(	O
NULL	O
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"ReadRestart"	pointer
)	O
;	O
if	O
(	O
*	O
prgdSumProd	pointer
==	O
NULL	O
)	O
if	O
(	O
!	O
(	O
*	O
prgdSumProd	pointer
=	O
InitdMatrix	function
(	O
nThetas	long
,	O
nThetas	long
)	O
)	O
)	O
ReportRunTimeError	function
(	O
NULL	O
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"ReadRestart"	pointer
)	O
;	O
*	O
pIter	pointer
=	O
-	O
1	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nThetas	long
;	O
i	long
++	O
)	O
{	O
(	O
*	O
pdSum	pointer
)	O
[	O
i	long
]	O
=	O
0.0	int
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
nThetas	long
;	O
j	long
++	O
)	O
(	O
*	O
prgdSumProd	pointer
)	O
[	O
i	long
]	O
[	O
j	long
]	O
=	O
0.0	int
;	O
}	O
do	O
{	O
c	pointer
=	O
getc	function
(	O
pfileRestart	pointer
)	O
;	O
}	O
while	O
(	O
c	pointer
!=	O
'\n'	O
)	O
;	O
while	O
(	O
!	O
(	O
feof	function
(	O
pfileRestart	pointer
)	O
||	O
(	O
fscanf	function
(	O
pfileRestart	pointer
,	O
"%*s"	pointer
)	O
==	O
EOF	O
)	O
)	O
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nThetas	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
fscanf	function
(	O
pfileRestart	pointer
,	O
"%lg"	pointer
,	O
&	O
(	O
(	O
*	O
pdTheta	pointer
)	O
[	O
i	long
]	O
)	O
)	O
==	O
EOF	O
)	O
{	O
printf	function
(	O
"Error: incorrect length for restart file - Exiting\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
else	O
{	O
(	O
*	O
pdSum	pointer
)	O
[	O
i	long
]	O
+=	O
(	O
*	O
pdTheta	pointer
)	O
[	O
i	long
]	O
;	O
}	O
}	O
if	O
(	O
fscanf	function
(	O
pfileRestart	pointer
,	O
"%d"	pointer
,	O
pindexT	pointer
)	O
==	O
EOF	O
)	O
{	O
printf	function
(	O
"Error: incorrect length for restart file - Exiting\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nPerks	int
;	O
i	long
++	O
)	O
{	O
if	O
(	O
fscanf	function
(	O
pfileRestart	pointer
,	O
"%lg"	pointer
,	O
&	O
(	O
pdlnPi	pointer
[	O
i	long
]	O
)	O
)	O
==	O
EOF	O
)	O
{	O
printf	function
(	O
"Error: incorrect length for restart file - Exiting\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
}	O
do	O
{	O
c	pointer
=	O
getc	function
(	O
pfileRestart	pointer
)	O
;	O
}	O
while	O
(	O
c	pointer
!=	O
'\n'	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nThetas	long
;	O
i	long
++	O
)	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
nThetas	long
;	O
j	long
++	O
)	O
(	O
*	O
prgdSumProd	pointer
)	O
[	O
i	long
]	O
[	O
j	long
]	O
+=	O
(	O
*	O
pdTheta	pointer
)	O
[	O
i	long
]	O
*	O
(	O
*	O
pdTheta	pointer
)	O
[	O
j	long
]	O
;	O
*	O
pIter	pointer
=	O
*	O
pIter	pointer
+	O
1	int
;	O
}	O
fclose	function
(	O
pfileRestart	pointer
)	O
;	O
}	O
int	O
RestoreLikelihoods	function
(	O
PLEVEL	pointer
plevel	pointer
,	O
char	O
*	O
*	O
args	pointer
)	O
{	O
PEXPERIMENT	pointer
pExpt	pointer
=	O
plevel	pointer
->	O
pexpt	pointer
;	O
if	O
(	O
pExpt	pointer
!=	O
NULL	O
)	O
{	O
pExpt	pointer
->	O
dLnLike	double
=	O
pExpt	pointer
->	O
dLnLikeSave	double
;	O
}	O
return	O
(	O
1	int
)	O
;	O
}	O
int	O
RunAllExpts	function
(	O
PANALYSIS	pointer
panal	pointer
,	O
PDOUBLE	pointer
pdLnData	pointer
)	O
{	O
PLEVEL	pointer
plevel0	pointer
=	O
panal	pointer
->	O
pLevels	array
[	O
0	int
]	O
;	O
long	O
n	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel0	pointer
->	O
iInstances	int
;	O
n	int
++	O
)	O
{	O
if	O
(	O
!	O
TraverseLevels1	function
(	O
plevel0	pointer
->	O
pLevels	array
[	O
n	int
]	O
,	O
RunExpt	function
,	O
panal	pointer
,	O
pdLnData	pointer
,	O
NULL	O
)	O
)	O
{	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
return	O
(	O
1	int
)	O
;	O
}	O
int	O
RunExpt	function
(	O
PLEVEL	pointer
plevel	pointer
,	O
char	O
*	O
*	O
args	pointer
)	O
{	O
PANALYSIS	pointer
panal	pointer
=	O
(	O
PANALYSIS	pointer
)	O
args	pointer
[	O
0	int
]	O
;	O
double	O
*	O
pdLnData	pointer
=	O
(	O
double	O
*	O
)	O
args	pointer
[	O
1	int
]	O
;	O
long	O
i	long
;	O
PEXPERIMENT	pointer
pExpt	pointer
=	O
plevel	pointer
->	O
pexpt	pointer
;	O
panal	pointer
->	O
pCurrentLevel	array
[	O
plevel	pointer
->	O
iDepth	int
]	O
=	O
plevel	pointer
;	O
if	O
(	O
pExpt	pointer
!=	O
NULL	O
)	O
{	O
InitModel	function
(	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<=	O
plevel	pointer
->	O
iDepth	int
;	O
i	long
++	O
)	O
{	O
SetModelVars	function
(	O
panal	pointer
->	O
pCurrentLevel	array
[	O
i	long
]	O
)	O
;	O
SetFixedVars	function
(	O
panal	pointer
->	O
pCurrentLevel	array
[	O
i	long
]	O
)	O
;	O
}	O
if	O
(	O
!	O
DoOneExperiment	function
(	O
pExpt	pointer
)	O
)	O
{	O
printf	function
(	O
"Warning: DoOneExperiment failed\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
pExpt	pointer
->	O
dLnLike	double
=	O
LnLikeData	function
(	O
plevel	pointer
,	O
panal	pointer
)	O
;	O
*	O
pdLnData	pointer
=	O
(	O
*	O
pdLnData	pointer
)	O
+	O
pExpt	pointer
->	O
dLnLike	double
;	O
}	O
}	O
return	O
(	O
1	int
)	O
;	O
}	O
long	O
SampleTemperature	function
(	O
PGIBBSDATA	pointer
pgd	pointer
,	O
double	O
dLnPrior	double
,	O
double	O
dLnData	double
)	O
{	O
int	O
indexT	int
=	O
pgd	pointer
->	O
indexT	int
;	O
int	O
indexT_new	long
;	O
if	O
(	O
indexT	int
==	O
0	int
)	O
indexT_new	long
=	O
1	int
;	O
else	O
{	O
if	O
(	O
indexT	int
==	O
pgd	pointer
->	O
nPerks	int
-	O
1	int
)	O
indexT_new	long
=	O
indexT	int
-	O
1	int
;	O
else	O
{	O
if	O
(	O
Randoms	function
(	O
)	O
>	O
0.5	int
)	O
indexT_new	long
=	O
indexT	int
+	O
1	int
;	O
else	O
indexT_new	long
=	O
indexT	int
-	O
1	int
;	O
}	O
}	O
if	O
(	O
TestTemper	function
(	O
pgd	pointer
,	O
indexT	int
,	O
indexT_new	long
,	O
dLnPrior	double
,	O
dLnData	double
,	O
pgd	pointer
->	O
rgdlnPi	pointer
[	O
indexT	int
]	O
,	O
pgd	pointer
->	O
rgdlnPi	pointer
[	O
indexT_new	long
]	O
)	O
)	O
{	O
return	O
(	O
indexT_new	long
)	O
;	O
}	O
else	O
return	O
(	O
indexT	int
)	O
;	O
}	O
long	O
SampleTemperature2	function
(	O
PGIBBSDATA	pointer
pgd	pointer
,	O
double	O
dLnPrior	double
,	O
double	O
dLnData	double
)	O
{	O
int	O
indexT	int
=	O
pgd	pointer
->	O
indexT	int
;	O
int	O
indexT_new	long
;	O
if	O
(	O
indexT	int
==	O
pgd	pointer
->	O
startT	int
)	O
indexT_new	long
=	O
indexT	int
+	O
1	int
;	O
else	O
{	O
if	O
(	O
indexT	int
==	O
pgd	pointer
->	O
endT	int
)	O
indexT_new	long
=	O
indexT	int
-	O
1	int
;	O
else	O
{	O
if	O
(	O
Randoms	function
(	O
)	O
>	O
0.5	int
)	O
indexT_new	long
=	O
indexT	int
+	O
1	int
;	O
else	O
indexT_new	long
=	O
indexT	int
-	O
1	int
;	O
}	O
}	O
int	O
minI	int
=	O
(	O
indexT	int
<	O
indexT_new	long
?	O
indexT	int
:	O
indexT_new	long
)	O
;	O
pgd	pointer
->	O
rglTransAttempts	pointer
[	O
minI	int
]	O
++	O
;	O
if	O
(	O
TestTemper	function
(	O
pgd	pointer
,	O
indexT	int
,	O
indexT_new	long
,	O
dLnPrior	double
,	O
dLnData	double
,	O
pgd	pointer
->	O
rgdlnPi	pointer
[	O
indexT	int
]	O
,	O
pgd	pointer
->	O
rgdlnPi	pointer
[	O
indexT_new	long
]	O
)	O
)	O
{	O
pgd	pointer
->	O
rglTransAccepts	pointer
[	O
minI	int
]	O
++	O
;	O
return	O
(	O
indexT_new	long
)	O
;	O
}	O
else	O
return	O
(	O
indexT	int
)	O
;	O
}	O
double	O
SampleTheta	function
(	O
PMCVAR	pointer
pMCVar	pointer
)	O
{	O
if	O
(	O
pMCVar	pointer
->	O
iType	int
==	O
MCV_BINOMIAL	int
||	O
pMCVar	pointer
->	O
iType	int
==	O
MCV_POISSON	int
)	O
{	O
return	O
floor	function
(	O
0.5	int
+	O
TruncNormalRandom	function
(	O
pMCVar	pointer
->	O
dVal	double
,	O
pMCVar	pointer
->	O
dKernelSD	double
,	O
MinMCVar	function
(	O
pMCVar	pointer
)	O
,	O
MaxMCVar	function
(	O
pMCVar	pointer
)	O
)	O
)	O
;	O
}	O
else	O
{	O
return	O
TruncNormalRandom	function
(	O
pMCVar	pointer
->	O
dVal	double
,	O
pMCVar	pointer
->	O
dKernelSD	double
,	O
MinMCVar	function
(	O
pMCVar	pointer
)	O
,	O
MaxMCVar	function
(	O
pMCVar	pointer
)	O
)	O
;	O
}	O
}	O
double	O
SampleThetaUnif	function
(	O
PMCVAR	pointer
pMCVar	pointer
)	O
{	O
if	O
(	O
pMCVar	pointer
->	O
iType	int
==	O
MCV_BINOMIAL	int
||	O
pMCVar	pointer
->	O
iType	int
==	O
MCV_POISSON	int
)	O
return	O
floor	function
(	O
0.5	int
+	O
UniformRandom	function
(	O
MinMCVar	function
(	O
pMCVar	pointer
)	O
,	O
MaxMCVar	function
(	O
pMCVar	pointer
)	O
)	O
)	O
;	O
else	O
return	O
UniformRandom	function
(	O
MinMCVar	function
(	O
pMCVar	pointer
)	O
,	O
MaxMCVar	function
(	O
pMCVar	pointer
)	O
)	O
;	O
}	O
void	O
SampleThetas	function
(	O
PLEVEL	pointer
plevel	pointer
,	O
char	O
*	O
*	O
args	pointer
)	O
{	O
PANALYSIS	pointer
panal	pointer
=	O
(	O
PANALYSIS	pointer
)	O
args	pointer
[	O
0	int
]	O
;	O
PGIBBSDATA	pointer
pgd	pointer
=	O
(	O
PGIBBSDATA	pointer
)	O
args	pointer
[	O
1	int
]	O
;	O
long	O
*	O
pnIter	pointer
=	O
(	O
long	O
*	O
)	O
args	pointer
[	O
2	int
]	O
;	O
long	O
*	O
pnUpdateAt	pointer
=	O
(	O
long	O
*	O
)	O
args	pointer
[	O
3	int
]	O
;	O
long	O
*	O
pnTotal	pointer
=	O
(	O
long	O
*	O
)	O
args	pointer
[	O
4	int
]	O
;	O
double	O
dLnPrior	double
,	O
dLnLike	double
,	O
dLnData	double
,	O
dLnKern	double
;	O
double	O
dLnPriorNew	double
,	O
dLnLikeNew	double
,	O
dLnDataNew	double
,	O
dLnKernNew	double
;	O
double	O
dTheta	double
,	O
dJumps	double
;	O
PMCVAR	pointer
pMCVar	pointer
;	O
long	O
n	int
;	O
panal	pointer
->	O
pCurrentLevel	array
[	O
plevel	pointer
->	O
iDepth	int
]	O
=	O
plevel	pointer
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	pointer
->	O
nMCVars	long
;	O
n	int
++	O
)	O
{	O
pMCVar	pointer
=	O
plevel	pointer
->	O
rgpMCVars	pointer
[	O
n	int
]	O
;	O
if	O
(	O
pMCVar	pointer
->	O
bIsFixed	int
)	O
goto	O
WriteIt	O
;	O
dLnPrior	double
=	O
LnDensity	function
(	O
pMCVar	pointer
,	O
panal	pointer
)	O
;	O
dLnLike	double
=	O
LnLike	function
(	O
pMCVar	pointer
,	O
panal	pointer
)	O
;	O
dLnData	double
=	O
0.0	int
;	O
if	O
(	O
pMCVar	pointer
->	O
bExptIsDep	int
)	O
{	O
TraverseLevels1	function
(	O
plevel	pointer
,	O
SumAllExpts	function
,	O
&	O
dLnData	double
,	O
NULL	O
)	O
;	O
}	O
dTheta	double
=	O
pMCVar	pointer
->	O
dVal	double
;	O
if	O
(	O
*	O
pnIter	pointer
==	O
*	O
pnUpdateAt	pointer
)	O
{	O
dJumps	double
=	O
(	O
double	O
)	O
pMCVar	pointer
->	O
lJumps	long
/	O
(	O
double	O
)	O
(	O
*	O
pnTotal	pointer
)	O
;	O
if	O
(	O
dJumps	double
>	O
0.3	int
)	O
{	O
if	O
(	O
dJumps	double
==	O
1	int
)	O
{	O
if	O
(	O
pMCVar	pointer
->	O
dKernelSD	double
<	O
sqrt	function
(	O
DBL_MAX	O
)	O
)	O
{	O
if	O
(	O
pMCVar	pointer
->	O
dKernelSD	double
>	O
2	int
)	O
pMCVar	pointer
->	O
dKernelSD	double
=	O
pMCVar	pointer
->	O
dKernelSD	double
*	O
pMCVar	pointer
->	O
dKernelSD	double
;	O
else	O
pMCVar	pointer
->	O
dKernelSD	double
=	O
pMCVar	pointer
->	O
dKernelSD	double
*	O
20	int
;	O
}	O
else	O
pMCVar	pointer
->	O
dKernelSD	double
=	O
DBL_MAX	O
;	O
}	O
else	O
{	O
if	O
(	O
pMCVar	pointer
->	O
dKernelSD	double
<	O
DBL_MAX	O
/	O
2	int
)	O
pMCVar	pointer
->	O
dKernelSD	double
=	O
pMCVar	pointer
->	O
dKernelSD	double
*	O
2	int
;	O
else	O
pMCVar	pointer
->	O
dKernelSD	double
=	O
DBL_MAX	O
;	O
}	O
if	O
(	O
pMCVar	pointer
->	O
dKernelSD	double
>	O
pMCVar	pointer
->	O
dMaxKernelSD	double
)	O
pMCVar	pointer
->	O
dKernelSD	double
=	O
pMCVar	pointer
->	O
dMaxKernelSD	double
;	O
}	O
else	O
{	O
if	O
(	O
dJumps	double
==	O
0	int
)	O
{	O
if	O
(	O
pMCVar	pointer
->	O
dKernelSD	double
>	O
pow	function
(	O
DBL_MIN	O
,	O
0.45	int
)	O
)	O
{	O
if	O
(	O
pMCVar	pointer
->	O
dKernelSD	double
>	O
2	int
)	O
{	O
pMCVar	pointer
->	O
dKernelSD	double
=	O
pow	function
(	O
pMCVar	pointer
->	O
dKernelSD	double
,	O
0.45	int
)	O
;	O
}	O
else	O
{	O
pMCVar	pointer
->	O
dKernelSD	double
=	O
pMCVar	pointer
->	O
dKernelSD	double
*	O
0.04	int
;	O
}	O
}	O
else	O
pMCVar	pointer
->	O
dKernelSD	double
=	O
DBL_MIN	O
;	O
}	O
else	O
{	O
if	O
(	O
pMCVar	pointer
->	O
dKernelSD	double
>	O
DBL_MIN	O
/	O
0.4	int
)	O
pMCVar	pointer
->	O
dKernelSD	double
=	O
pMCVar	pointer
->	O
dKernelSD	double
*	O
0.4	int
;	O
else	O
pMCVar	pointer
->	O
dKernelSD	double
=	O
DBL_MIN	O
;	O
}	O
}	O
pMCVar	pointer
->	O
lJumps	long
=	O
0	int
;	O
}	O
dLnKern	double
=	O
log	function
(	O
CDFNormal	function
(	O
(	O
MaxMCVar	function
(	O
pMCVar	pointer
)	O
-	O
pMCVar	pointer
->	O
dVal	double
)	O
/	O
pMCVar	pointer
->	O
dKernelSD	double
)	O
-	O
CDFNormal	function
(	O
(	O
MinMCVar	function
(	O
pMCVar	pointer
)	O
-	O
pMCVar	pointer
->	O
dVal	double
)	O
/	O
pMCVar	pointer
->	O
dKernelSD	double
)	O
)	O
;	O
pMCVar	pointer
->	O
dVal	double
=	O
SampleTheta	function
(	O
pMCVar	pointer
)	O
;	O
dLnKernNew	double
=	O
log	function
(	O
CDFNormal	function
(	O
(	O
MaxMCVar	function
(	O
pMCVar	pointer
)	O
-	O
pMCVar	pointer
->	O
dVal	double
)	O
/	O
pMCVar	pointer
->	O
dKernelSD	double
)	O
-	O
CDFNormal	function
(	O
(	O
MinMCVar	function
(	O
pMCVar	pointer
)	O
-	O
pMCVar	pointer
->	O
dVal	double
)	O
/	O
pMCVar	pointer
->	O
dKernelSD	double
)	O
)	O
;	O
dLnPriorNew	double
=	O
LnDensity	function
(	O
pMCVar	pointer
,	O
panal	pointer
)	O
;	O
dLnLikeNew	double
=	O
LnLike	function
(	O
pMCVar	pointer
,	O
panal	pointer
)	O
;	O
dLnDataNew	double
=	O
0.0	int
;	O
if	O
(	O
pMCVar	pointer
->	O
bExptIsDep	int
)	O
{	O
if	O
(	O
!	O
TraverseLevels1	function
(	O
plevel	pointer
,	O
RunExpt	function
,	O
panal	pointer
,	O
&	O
dLnDataNew	double
,	O
NULL	O
)	O
)	O
{	O
pMCVar	pointer
->	O
dVal	double
=	O
dTheta	double
;	O
TraverseLevels1	function
(	O
plevel	pointer
,	O
RestoreLikelihoods	function
,	O
NULL	O
)	O
;	O
goto	O
WriteIt	O
;	O
}	O
}	O
if	O
(	O
!	O
TestImpRatio	function
(	O
pgd	pointer
,	O
pMCVar	pointer
->	O
bExptIsDep	int
,	O
dLnKern	double
,	O
dLnKernNew	double
,	O
dLnPrior	double
,	O
dLnPriorNew	double
,	O
dLnLike	double
,	O
dLnLikeNew	double
,	O
dLnData	double
,	O
dLnDataNew	double
)	O
)	O
{	O
pMCVar	pointer
->	O
dVal	double
=	O
dTheta	double
;	O
if	O
(	O
pMCVar	pointer
->	O
bExptIsDep	int
)	O
TraverseLevels1	function
(	O
plevel	pointer
,	O
RestoreLikelihoods	function
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
pMCVar	pointer
->	O
lJumps	long
=	O
pMCVar	pointer
->	O
lJumps	long
+	O
1	int
;	O
if	O
(	O
pMCVar	pointer
->	O
bExptIsDep	int
)	O
TraverseLevels1	function
(	O
plevel	pointer
,	O
SaveLikelihoods	function
,	O
NULL	O
)	O
;	O
}	O
CalculateMeanAndVariance	function
(	O
(	O
*	O
pnIter	pointer
+	O
1	int
)	O
,	O
pMCVar	pointer
->	O
dVal	double
,	O
&	O
pMCVar	pointer
->	O
dVal_mean	double
,	O
&	O
pMCVar	pointer
->	O
dVal_var	double
)	O
;	O
WriteIt	O
:	O
if	O
(	O
(	O
(	O
*	O
pnIter	pointer
+	O
1	int
)	O
%	O
pgd	pointer
->	O
nPrintFreq	long
==	O
0	int
)	O
&&	O
(	O
*	O
pnIter	pointer
>=	O
pgd	pointer
->	O
nMaxIter	long
-	O
pgd	pointer
->	O
nPrintIter	long
)	O
)	O
{	O
fprintf	function
(	O
pgd	pointer
->	O
pfileOut	pointer
,	O
"%5g\t"	pointer
,	O
pMCVar	pointer
->	O
dVal	double
)	O
;	O
}	O
}	O
}	O
void	O
SampleThetasTempered	function
(	O
PLEVEL	pointer
plevel	pointer
,	O
char	O
*	O
*	O
args	pointer
)	O
{	O
PANALYSIS	pointer
panal	pointer
=	O
(	O
PANALYSIS	pointer
)	O
args	pointer
[	O
0	int
]	O
;	O
PGIBBSDATA	pointer
pgd	pointer
=	O
(	O
PGIBBSDATA	pointer
)	O
args	pointer
[	O
1	int
]	O
;	O
long	O
*	O
pnIter	pointer
=	O
(	O
long	O
*	O
)	O
args	pointer
[	O
2	int
]	O
;	O
long	O
*	O
pnUpdateAt	pointer
=	O
(	O
long	O
*	O
)	O
args	pointer
[	O
3	int
]	O
;	O
long	O
*	O
pnTotal	pointer
=	O
(	O
long	O
*	O
)	O
args	pointer
[	O
4	int
]	O
;	O
long	O
*	O
pindexT	pointer
=	O
(	O
long	O
*	O
)	O
args	pointer
[	O
5	int
]	O
;	O
double	O
dLnPrior	double
,	O
dLnLike	double
,	O
dLnData	double
,	O
dLnKern	double
;	O
double	O
dLnPriorNew	double
,	O
dLnLikeNew	double
,	O
dLnDataNew	double
,	O
dLnKernNew	double
;	O
double	O
dTheta	double
,	O
dJumps	double
,	O
old_dKernelSD	double
;	O
PMCVAR	pointer
pMCVar	pointer
;	O
long	O
n	int
;	O
panal	pointer
->	O
pCurrentLevel	array
[	O
plevel	pointer
->	O
iDepth	int
]	O
=	O
plevel	pointer
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	pointer
->	O
nMCVars	long
;	O
n	int
++	O
)	O
{	O
pMCVar	pointer
=	O
plevel	pointer
->	O
rgpMCVars	pointer
[	O
n	int
]	O
;	O
if	O
(	O
pMCVar	pointer
->	O
bIsFixed	int
)	O
goto	O
WriteIt	O
;	O
dLnPrior	double
=	O
LnDensity	function
(	O
pMCVar	pointer
,	O
panal	pointer
)	O
;	O
dLnLike	double
=	O
LnLike	function
(	O
pMCVar	pointer
,	O
panal	pointer
)	O
;	O
dLnData	double
=	O
0.0	int
;	O
if	O
(	O
pMCVar	pointer
->	O
bExptIsDep	int
)	O
{	O
TraverseLevels1	function
(	O
plevel	pointer
,	O
SumAllExpts	function
,	O
&	O
dLnData	double
,	O
NULL	O
)	O
;	O
}	O
dTheta	double
=	O
pMCVar	pointer
->	O
dVal	double
;	O
if	O
(	O
*	O
pnIter	pointer
==	O
*	O
pnUpdateAt	pointer
)	O
{	O
dJumps	double
=	O
(	O
double	O
)	O
pMCVar	pointer
->	O
lJumps	long
/	O
(	O
double	O
)	O
(	O
*	O
pnTotal	pointer
)	O
;	O
if	O
(	O
dJumps	double
>	O
0.3	int
)	O
{	O
if	O
(	O
dJumps	double
==	O
1	int
)	O
{	O
if	O
(	O
pMCVar	pointer
->	O
dKernelSD	double
<	O
sqrt	function
(	O
DBL_MAX	O
)	O
)	O
{	O
if	O
(	O
pMCVar	pointer
->	O
dKernelSD	double
>	O
2	int
)	O
pMCVar	pointer
->	O
dKernelSD	double
=	O
pMCVar	pointer
->	O
dKernelSD	double
*	O
pMCVar	pointer
->	O
dKernelSD	double
;	O
else	O
pMCVar	pointer
->	O
dKernelSD	double
=	O
pMCVar	pointer
->	O
dKernelSD	double
*	O
20	int
;	O
}	O
else	O
pMCVar	pointer
->	O
dKernelSD	double
=	O
DBL_MAX	O
;	O
}	O
else	O
{	O
if	O
(	O
pMCVar	pointer
->	O
dKernelSD	double
<	O
DBL_MAX	O
/	O
2	int
)	O
pMCVar	pointer
->	O
dKernelSD	double
=	O
pMCVar	pointer
->	O
dKernelSD	double
*	O
2	int
;	O
else	O
pMCVar	pointer
->	O
dKernelSD	double
=	O
DBL_MAX	O
;	O
}	O
if	O
(	O
pMCVar	pointer
->	O
dKernelSD	double
>	O
pMCVar	pointer
->	O
dMaxKernelSD	double
)	O
pMCVar	pointer
->	O
dKernelSD	double
=	O
pMCVar	pointer
->	O
dMaxKernelSD	double
;	O
}	O
else	O
{	O
if	O
(	O
dJumps	double
==	O
0	int
)	O
{	O
if	O
(	O
pMCVar	pointer
->	O
dKernelSD	double
>	O
pow	function
(	O
DBL_MIN	O
,	O
0.45	int
)	O
)	O
{	O
if	O
(	O
pMCVar	pointer
->	O
dKernelSD	double
>	O
2	int
)	O
{	O
pMCVar	pointer
->	O
dKernelSD	double
=	O
pow	function
(	O
pMCVar	pointer
->	O
dKernelSD	double
,	O
0.45	int
)	O
;	O
}	O
else	O
{	O
pMCVar	pointer
->	O
dKernelSD	double
=	O
pMCVar	pointer
->	O
dKernelSD	double
*	O
0.04	int
;	O
}	O
}	O
else	O
pMCVar	pointer
->	O
dKernelSD	double
=	O
DBL_MIN	O
;	O
}	O
else	O
{	O
if	O
(	O
pMCVar	pointer
->	O
dKernelSD	double
>	O
DBL_MIN	O
/	O
0.4	int
)	O
pMCVar	pointer
->	O
dKernelSD	double
=	O
pMCVar	pointer
->	O
dKernelSD	double
*	O
0.4	int
;	O
else	O
pMCVar	pointer
->	O
dKernelSD	double
=	O
DBL_MIN	O
;	O
}	O
}	O
pMCVar	pointer
->	O
lJumps	long
=	O
0	int
;	O
}	O
if	O
(	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
*	O
pindexT	pointer
]	O
>	O
0	int
)	O
{	O
old_dKernelSD	double
=	O
pMCVar	pointer
->	O
dKernelSD	double
;	O
pMCVar	pointer
->	O
dKernelSD	double
=	O
pMCVar	pointer
->	O
dKernelSD	double
*	O
exp	function
(	O
(	O
1	int
-	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
*	O
pindexT	pointer
]	O
)	O
*	O
LN2PI	int
*	O
0.25	int
-	O
0.75	int
*	O
log	function
(	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
*	O
pindexT	pointer
]	O
)	O
)	O
;	O
if	O
(	O
pMCVar	pointer
->	O
dKernelSD	double
>	O
pMCVar	pointer
->	O
dMaxKernelSD	double
)	O
pMCVar	pointer
->	O
dKernelSD	double
=	O
pMCVar	pointer
->	O
dMaxKernelSD	double
;	O
dLnKern	double
=	O
log	function
(	O
CDFNormal	function
(	O
(	O
MaxMCVar	function
(	O
pMCVar	pointer
)	O
-	O
pMCVar	pointer
->	O
dVal	double
)	O
/	O
pMCVar	pointer
->	O
dKernelSD	double
)	O
-	O
CDFNormal	function
(	O
(	O
MinMCVar	function
(	O
pMCVar	pointer
)	O
-	O
pMCVar	pointer
->	O
dVal	double
)	O
/	O
pMCVar	pointer
->	O
dKernelSD	double
)	O
)	O
;	O
pMCVar	pointer
->	O
dVal	double
=	O
SampleTheta	function
(	O
pMCVar	pointer
)	O
;	O
dLnKernNew	double
=	O
log	function
(	O
CDFNormal	function
(	O
(	O
MaxMCVar	function
(	O
pMCVar	pointer
)	O
-	O
pMCVar	pointer
->	O
dVal	double
)	O
/	O
pMCVar	pointer
->	O
dKernelSD	double
)	O
-	O
CDFNormal	function
(	O
(	O
MinMCVar	function
(	O
pMCVar	pointer
)	O
-	O
pMCVar	pointer
->	O
dVal	double
)	O
/	O
pMCVar	pointer
->	O
dKernelSD	double
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
pgd	pointer
->	O
nSimTypeFlag	long
==	O
3	int
)	O
{	O
pMCVar	pointer
->	O
dVal	double
=	O
SampleThetaUnif	function
(	O
pMCVar	pointer
)	O
;	O
}	O
else	O
{	O
CalculateOneMCParm	function
(	O
pMCVar	pointer
)	O
;	O
}	O
}	O
dLnPriorNew	double
=	O
LnDensity	function
(	O
pMCVar	pointer
,	O
panal	pointer
)	O
;	O
dLnLikeNew	double
=	O
LnLike	function
(	O
pMCVar	pointer
,	O
panal	pointer
)	O
;	O
dLnDataNew	double
=	O
0.0	int
;	O
if	O
(	O
pMCVar	pointer
->	O
bExptIsDep	int
)	O
{	O
if	O
(	O
!	O
TraverseLevels1	function
(	O
plevel	pointer
,	O
RunExpt	function
,	O
panal	pointer
,	O
&	O
dLnDataNew	double
,	O
NULL	O
)	O
)	O
{	O
pMCVar	pointer
->	O
dVal	double
=	O
dTheta	double
;	O
TraverseLevels1	function
(	O
plevel	pointer
,	O
RestoreLikelihoods	function
,	O
NULL	O
)	O
;	O
goto	O
WriteIt	O
;	O
}	O
}	O
if	O
(	O
!	O
TestImpRatioTemper	function
(	O
pgd	pointer
,	O
pMCVar	pointer
->	O
bExptIsDep	int
,	O
dLnKern	double
,	O
dLnKernNew	double
,	O
dLnPrior	double
,	O
dLnPriorNew	double
,	O
dLnLike	double
,	O
dLnLikeNew	double
,	O
dLnData	double
,	O
dLnDataNew	double
,	O
*	O
pindexT	pointer
)	O
)	O
{	O
pMCVar	pointer
->	O
dVal	double
=	O
dTheta	double
;	O
if	O
(	O
pMCVar	pointer
->	O
bExptIsDep	int
)	O
TraverseLevels1	function
(	O
plevel	pointer
,	O
RestoreLikelihoods	function
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
pMCVar	pointer
->	O
lJumps	long
=	O
pMCVar	pointer
->	O
lJumps	long
+	O
1	int
;	O
if	O
(	O
pMCVar	pointer
->	O
bExptIsDep	int
)	O
TraverseLevels1	function
(	O
plevel	pointer
,	O
SaveLikelihoods	function
,	O
NULL	O
)	O
;	O
}	O
if	O
(	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
*	O
pindexT	pointer
]	O
>	O
0	int
)	O
pMCVar	pointer
->	O
dKernelSD	double
=	O
old_dKernelSD	double
;	O
WriteIt	O
:	O
if	O
(	O
(	O
(	O
*	O
pnIter	pointer
+	O
1	int
)	O
%	O
pgd	pointer
->	O
nPrintFreq	long
==	O
0	int
)	O
&&	O
(	O
*	O
pnIter	pointer
>=	O
pgd	pointer
->	O
nMaxIter	long
-	O
pgd	pointer
->	O
nPrintIter	long
)	O
)	O
{	O
fprintf	function
(	O
pgd	pointer
->	O
pfileOut	pointer
,	O
"%5g\t"	pointer
,	O
pMCVar	pointer
->	O
dVal	double
)	O
;	O
}	O
}	O
}	O
void	O
SampleThetaVector	function
(	O
PLEVEL	pointer
pLevel	pointer
,	O
PANALYSIS	pointer
panal	pointer
,	O
long	O
nThetas	long
,	O
double	O
*	O
pdTheta	pointer
,	O
double	O
*	O
pdSum	pointer
,	O
double	O
*	O
*	O
prgdSumProd	pointer
,	O
long	O
iter	long
,	O
long	O
nUpdateAt	long
,	O
long	O
nTotal	long
,	O
PDOUBLE	pointer
pdLnPrior	pointer
,	O
PDOUBLE	pointer
pdLnData	pointer
)	O
{	O
register	O
long	O
i	long
,	O
j	long
;	O
double	O
dTmp	double
,	O
dAccept	double
,	O
dLnPrior_old	double
,	O
dLnData_old	double
;	O
BOOL	int
bInBounds	int
;	O
static	O
long	O
lAccepted	long
=	O
0	int
;	O
static	O
double	O
dJumpSpread	double
;	O
static	O
PDOUBLE	pointer
pdTheta_old	pointer
=	O
NULL	O
;	O
static	O
PDOUBLE	pointer
*	O
prgdComponent	pointer
;	O
static	O
PDOUBLE	pointer
*	O
prgdVariance	pointer
;	O
static	O
PDOUBLE	pointer
dNormVar	pointer
;	O
if	O
(	O
(	O
pdTheta_old	pointer
==	O
NULL	O
)	O
||	O
(	O
iter	long
==	O
nUpdateAt	long
)	O
)	O
{	O
if	O
(	O
pdTheta_old	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
!	O
(	O
pdTheta_old	pointer
=	O
InitdVector	function
(	O
nThetas	long
)	O
)	O
||	O
!	O
(	O
dNormVar	pointer
=	O
InitdVector	function
(	O
nThetas	long
)	O
)	O
||	O
!	O
(	O
prgdVariance	pointer
=	O
InitdMatrix	function
(	O
nThetas	long
,	O
nThetas	long
)	O
)	O
||	O
!	O
(	O
prgdComponent	pointer
=	O
InitdMatrix	function
(	O
nThetas	long
,	O
nThetas	long
)	O
)	O
)	O
ReportRunTimeError	function
(	O
panal	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"SampleThetaVector"	pointer
)	O
;	O
dJumpSpread	double
=	O
2.4	int
/	O
sqrt	function
(	O
nThetas	long
)	O
;	O
}	O
else	O
{	O
dAccept	double
=	O
(	O
(	O
double	O
)	O
lAccepted	long
)	O
/	O
(	O
double	O
)	O
(	O
nTotal	long
)	O
;	O
if	O
(	O
dAccept	double
>	O
0.3	int
)	O
dJumpSpread	double
=	O
dJumpSpread	double
*	O
1.5	int
;	O
else	O
if	O
(	O
dAccept	double
<	O
0.15	int
)	O
dJumpSpread	double
=	O
dJumpSpread	double
*	O
0.7	int
;	O
printf	function
(	O
"Monitoring: iter\t%ld\t"	pointer
,	O
iter	long
)	O
;	O
printf	function
(	O
"success rate\t%g\tspread\t%g\n"	pointer
,	O
dAccept	double
,	O
dJumpSpread	double
)	O
;	O
lAccepted	long
=	O
0	int
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nThetas	long
;	O
i	long
++	O
)	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
nThetas	long
;	O
j	long
++	O
)	O
prgdVariance	pointer
[	O
i	long
]	O
[	O
j	long
]	O
=	O
(	O
prgdSumProd	pointer
[	O
i	long
]	O
[	O
j	long
]	O
-	O
pdSum	pointer
[	O
i	long
]	O
*	O
pdSum	pointer
[	O
j	long
]	O
/	O
(	O
double	O
)	O
(	O
iter	long
+	O
1	int
)	O
)	O
/	O
(	O
double	O
)	O
iter	long
;	O
if	O
(	O
!	O
Cholesky	function
(	O
prgdVariance	pointer
,	O
prgdComponent	pointer
,	O
nThetas	long
)	O
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nThetas	long
;	O
i	long
++	O
)	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
nThetas	long
;	O
j	long
++	O
)	O
{	O
if	O
(	O
i	long
==	O
j	long
)	O
prgdVariance	pointer
[	O
i	long
]	O
[	O
j	long
]	O
=	O
prgdSumProd	pointer
[	O
i	long
]	O
[	O
j	long
]	O
/	O
(	O
double	O
)	O
(	O
iter	long
)	O
;	O
else	O
prgdVariance	pointer
[	O
i	long
]	O
[	O
j	long
]	O
=	O
0.0	int
;	O
}	O
if	O
(	O
!	O
Cholesky	function
(	O
prgdVariance	pointer
,	O
prgdComponent	pointer
,	O
nThetas	long
)	O
)	O
{	O
printf	function
(	O
"Error: impossible to compute a jumping kernel - Exiting."	pointer
"(You should check or change the restart file).\n\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
}	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nThetas	long
;	O
i	long
++	O
)	O
pdTheta_old	pointer
[	O
i	long
]	O
=	O
pdTheta	pointer
[	O
i	long
]	O
;	O
dLnPrior_old	double
=	O
*	O
pdLnPrior	pointer
;	O
dLnData_old	double
=	O
*	O
pdLnData	pointer
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nThetas	long
;	O
i	long
++	O
)	O
dNormVar	pointer
[	O
i	long
]	O
=	O
NormalRandom	function
(	O
0.0	int
,	O
1.0	int
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nThetas	long
;	O
i	long
++	O
)	O
{	O
dTmp	double
=	O
0	int
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<=	O
i	long
;	O
j	long
++	O
)	O
dTmp	double
=	O
dTmp	double
+	O
dNormVar	pointer
[	O
j	long
]	O
*	O
prgdComponent	pointer
[	O
i	long
]	O
[	O
j	long
]	O
;	O
pdTheta	pointer
[	O
i	long
]	O
=	O
pdTheta_old	pointer
[	O
i	long
]	O
+	O
dJumpSpread	double
*	O
dTmp	double
;	O
}	O
long	O
iTmp	long
=	O
0	int
;	O
bInBounds	int
=	O
TraverseLevels1	function
(	O
pLevel	pointer
,	O
SetMCVars	function
,	O
pdTheta	pointer
,	O
&	O
iTmp	long
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
bInBounds	int
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nThetas	long
;	O
i	long
++	O
)	O
pdTheta	pointer
[	O
i	long
]	O
=	O
pdTheta_old	pointer
[	O
i	long
]	O
;	O
goto	O
DontJump	O
;	O
}	O
*	O
pdLnPrior	pointer
=	O
0.0	int
;	O
TraverseLevels	function
(	O
pLevel	pointer
,	O
CalculateTotals	function
,	O
panal	pointer
,	O
pdLnPrior	pointer
,	O
NULL	O
)	O
;	O
*	O
pdLnData	pointer
=	O
0.0	int
;	O
if	O
(	O
!	O
RunAllExpts	function
(	O
panal	pointer
,	O
pdLnData	pointer
)	O
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nThetas	long
;	O
i	long
++	O
)	O
pdTheta	pointer
[	O
i	long
]	O
=	O
pdTheta_old	pointer
[	O
i	long
]	O
;	O
*	O
pdLnPrior	pointer
=	O
dLnPrior_old	double
;	O
*	O
pdLnData	pointer
=	O
dLnData_old	double
;	O
}	O
else	O
{	O
if	O
(	O
log	function
(	O
Randoms	function
(	O
)	O
)	O
>	O
(	O
(	O
*	O
pdLnPrior	pointer
)	O
+	O
(	O
*	O
pdLnData	pointer
)	O
-	O
dLnPrior_old	double
-	O
dLnData_old	double
)	O
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nThetas	long
;	O
i	long
++	O
)	O
pdTheta	pointer
[	O
i	long
]	O
=	O
pdTheta_old	pointer
[	O
i	long
]	O
;	O
*	O
pdLnPrior	pointer
=	O
dLnPrior_old	double
;	O
*	O
pdLnData	pointer
=	O
dLnData_old	double
;	O
}	O
else	O
{	O
lAccepted	long
++	O
;	O
}	O
}	O
DontJump	O
:	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nThetas	long
;	O
i	long
++	O
)	O
{	O
pdSum	pointer
[	O
i	long
]	O
+=	O
pdTheta	pointer
[	O
i	long
]	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
nThetas	long
;	O
j	long
++	O
)	O
prgdSumProd	pointer
[	O
i	long
]	O
[	O
j	long
]	O
+=	O
pdTheta	pointer
[	O
i	long
]	O
*	O
pdTheta	pointer
[	O
j	long
]	O
;	O
}	O
}	O
int	O
SaveLikelihoods	function
(	O
PLEVEL	pointer
plevel	pointer
,	O
char	O
*	O
*	O
args	pointer
)	O
{	O
PEXPERIMENT	pointer
pExpt	pointer
=	O
plevel	pointer
->	O
pexpt	pointer
;	O
if	O
(	O
pExpt	pointer
!=	O
NULL	O
)	O
{	O
pExpt	pointer
->	O
dLnLikeSave	double
=	O
pExpt	pointer
->	O
dLnLike	double
;	O
}	O
return	O
(	O
1	int
)	O
;	O
}	O
void	O
SetFixedVars	function
(	O
PLEVEL	pointer
plevel	pointer
)	O
{	O
long	O
n	int
;	O
PVARMOD	pointer
pFVar	pointer
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	pointer
->	O
nFixedVars	long
;	O
n	int
++	O
)	O
{	O
pFVar	pointer
=	O
plevel	pointer
->	O
rgpFixedVars	pointer
[	O
n	int
]	O
;	O
if	O
(	O
IsInput	function
(	O
pFVar	pointer
->	O
hvar	long
)	O
)	O
SetInput	function
(	O
pFVar	pointer
->	O
hvar	long
,	O
pFVar	pointer
->	O
uvar	union
.	O
pifn	pointer
)	O
;	O
else	O
SetVar	function
(	O
pFVar	pointer
->	O
hvar	long
,	O
pFVar	pointer
->	O
uvar	union
.	O
dVal	double
)	O
;	O
}	O
}	O
void	O
SetKernel	function
(	O
PLEVEL	pointer
plevel	pointer
,	O
char	O
*	O
*	O
args	pointer
)	O
{	O
intptr_t	long
useMCVarVals	long
=	O
(	O
intptr_t	long
)	O
args	pointer
[	O
0	int
]	O
;	O
double	O
*	O
pdMCVarVals	pointer
=	O
(	O
double	O
*	O
)	O
args	pointer
[	O
1	int
]	O
;	O
double	O
dMin	double
,	O
dMax	double
,	O
dTmp	double
;	O
long	O
n	int
,	O
m	long
;	O
static	O
long	O
nThetas	long
;	O
PMCVAR	pointer
pMCVar	pointer
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	pointer
->	O
nMCVars	long
;	O
n	int
++	O
)	O
{	O
if	O
(	O
!	O
(	O
plevel	pointer
->	O
rgpMCVars	pointer
[	O
n	int
]	O
->	O
bIsFixed	int
)	O
)	O
{	O
pMCVar	pointer
=	O
plevel	pointer
->	O
rgpMCVars	pointer
[	O
n	int
]	O
;	O
CalculateOneMCParm	function
(	O
pMCVar	pointer
)	O
;	O
if	O
(	O
pMCVar	pointer
->	O
iType	int
==	O
MCV_UNIFORM	int
||	O
pMCVar	pointer
->	O
iType	int
==	O
MCV_LOGUNIFORM	int
)	O
pMCVar	pointer
->	O
dMaxKernelSD	double
=	O
(	O
*	O
(	O
pMCVar	pointer
->	O
pdParm	array
[	O
1	int
]	O
)	O
-	O
*	O
(	O
pMCVar	pointer
->	O
pdParm	array
[	O
0	int
]	O
)	O
)	O
/	O
6.0	int
;	O
else	O
pMCVar	pointer
->	O
dMaxKernelSD	double
=	O
(	O
*	O
(	O
pMCVar	pointer
->	O
pdParm	array
[	O
3	int
]	O
)	O
-	O
*	O
(	O
pMCVar	pointer
->	O
pdParm	array
[	O
2	int
]	O
)	O
)	O
/	O
6.0	int
;	O
dMin	double
=	O
dMax	double
=	O
pMCVar	pointer
->	O
dVal	double
;	O
for	O
(	O
m	long
=	O
0	int
;	O
m	long
<	O
3	int
;	O
m	long
++	O
)	O
{	O
CalculateOneMCParm	function
(	O
pMCVar	pointer
)	O
;	O
dTmp	double
=	O
pMCVar	pointer
->	O
dVal	double
;	O
if	O
(	O
dMin	double
>=	O
dTmp	double
)	O
dMin	double
=	O
dTmp	double
;	O
else	O
if	O
(	O
dMax	double
<	O
dTmp	double
)	O
dMax	double
=	O
dTmp	double
;	O
}	O
if	O
(	O
(	O
*	O
(	O
pMCVar	pointer
->	O
pdParm	array
[	O
2	int
]	O
)	O
==	O
-	O
DBL_MAX	O
)	O
||	O
(	O
*	O
(	O
pMCVar	pointer
->	O
pdParm	array
[	O
3	int
]	O
)	O
==	O
DBL_MAX	O
)	O
)	O
pMCVar	pointer
->	O
dKernelSD	double
=	O
(	O
0.5	int
*	O
dMax	double
)	O
-	O
(	O
0.5	int
*	O
dMin	double
)	O
;	O
else	O
pMCVar	pointer
->	O
dKernelSD	double
=	O
dMax	double
-	O
dMin	double
;	O
if	O
(	O
pMCVar	pointer
->	O
dKernelSD	double
==	O
0	int
)	O
{	O
pMCVar	pointer
->	O
dKernelSD	double
=	O
pMCVar	pointer
->	O
dMaxKernelSD	double
;	O
}	O
}	O
if	O
(	O
useMCVarVals	long
==	O
1	int
)	O
plevel	pointer
->	O
rgpMCVars	pointer
[	O
n	int
]	O
->	O
dVal	double
=	O
pdMCVarVals	pointer
[	O
nThetas	long
++	O
]	O
;	O
}	O
}	O
void	O
WriteKernel	function
(	O
PLEVEL	pointer
plevel	pointer
,	O
char	O
*	O
*	O
args	pointer
)	O
{	O
FILE	struct
*	O
pfile	pointer
=	O
(	O
FILE	struct
*	O
)	O
args	pointer
[	O
0	int
]	O
;	O
long	O
n	int
;	O
PMCVAR	pointer
pMCVar	pointer
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	pointer
->	O
nMCVars	long
;	O
n	int
++	O
)	O
{	O
if	O
(	O
!	O
(	O
plevel	pointer
->	O
rgpMCVars	pointer
[	O
n	int
]	O
->	O
bIsFixed	int
)	O
)	O
{	O
pMCVar	pointer
=	O
plevel	pointer
->	O
rgpMCVars	pointer
[	O
n	int
]	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"%lg\t"	pointer
,	O
pMCVar	pointer
->	O
dKernelSD	double
)	O
;	O
}	O
}	O
}	O
void	O
ReadKernel	function
(	O
PLEVEL	pointer
plevel	pointer
,	O
char	O
*	O
*	O
args	pointer
)	O
{	O
FILE	struct
*	O
pfile	pointer
=	O
(	O
FILE	struct
*	O
)	O
args	pointer
[	O
0	int
]	O
;	O
long	O
n	int
;	O
PMCVAR	pointer
pMCVar	pointer
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	pointer
->	O
nMCVars	long
;	O
n	int
++	O
)	O
{	O
if	O
(	O
!	O
(	O
plevel	pointer
->	O
rgpMCVars	pointer
[	O
n	int
]	O
->	O
bIsFixed	int
)	O
)	O
{	O
pMCVar	pointer
=	O
plevel	pointer
->	O
rgpMCVars	pointer
[	O
n	int
]	O
;	O
pMCVar	pointer
->	O
dMaxKernelSD	double
=	O
(	O
MaxMCVar	function
(	O
pMCVar	pointer
)	O
-	O
MinMCVar	function
(	O
pMCVar	pointer
)	O
)	O
/	O
6.0	int
;	O
if	O
(	O
!	O
fscanf	function
(	O
pfile	pointer
,	O
"%lg"	pointer
,	O
&	O
(	O
pMCVar	pointer
->	O
dKernelSD	double
)	O
)	O
)	O
{	O
ReportError	function
(	O
NULL	O
,	O
RE_READERROR	int
|	O
RE_FATAL	int
,	O
"kernel file"	pointer
,	O
NULL	O
)	O
;	O
}	O
}	O
}	O
}	O
void	O
SetModelVars	function
(	O
PLEVEL	pointer
plevel	pointer
)	O
{	O
long	O
n	int
;	O
PMCVAR	pointer
pMCVar	pointer
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	pointer
->	O
nMCVars	long
;	O
n	int
++	O
)	O
{	O
pMCVar	pointer
=	O
plevel	pointer
->	O
rgpMCVars	pointer
[	O
n	int
]	O
;	O
if	O
(	O
!	O
(	O
pMCVar	pointer
->	O
bIsFixed	int
)	O
&&	O
(	O
IsParm	function
(	O
pMCVar	pointer
->	O
hvar	long
)	O
)	O
)	O
SetVar	function
(	O
pMCVar	pointer
->	O
hvar	long
,	O
pMCVar	pointer
->	O
dVal	double
)	O
;	O
}	O
}	O
int	O
SetMCVars	function
(	O
PLEVEL	pointer
plevel	pointer
,	O
char	O
*	O
*	O
args	pointer
)	O
{	O
double	O
*	O
pdMCVarVals	pointer
=	O
(	O
double	O
*	O
)	O
args	pointer
[	O
0	int
]	O
;	O
long	O
*	O
nThetas	long
=	O
(	O
long	O
*	O
)	O
args	pointer
[	O
1	int
]	O
;	O
PMCVAR	pointer
pMCVar	pointer
;	O
double	O
dVar	double
;	O
long	O
n	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	pointer
->	O
nMCVars	long
;	O
n	int
++	O
)	O
{	O
dVar	double
=	O
pdMCVarVals	pointer
[	O
(	O
*	O
nThetas	long
)	O
++	O
]	O
;	O
pMCVar	pointer
=	O
plevel	pointer
->	O
rgpMCVars	pointer
[	O
n	int
]	O
;	O
if	O
(	O
(	O
pMCVar	pointer
->	O
iType	int
==	O
MCV_UNIFORM	int
)	O
||	O
(	O
pMCVar	pointer
->	O
iType	int
==	O
MCV_LOGUNIFORM	int
)	O
)	O
{	O
if	O
(	O
(	O
dVar	double
<	O
*	O
(	O
pMCVar	pointer
->	O
pdParm	array
[	O
0	int
]	O
)	O
)	O
||	O
(	O
dVar	double
>	O
*	O
(	O
pMCVar	pointer
->	O
pdParm	array
[	O
1	int
]	O
)	O
)	O
)	O
{	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
(	O
dVar	double
<	O
*	O
(	O
pMCVar	pointer
->	O
pdParm	array
[	O
2	int
]	O
)	O
)	O
||	O
(	O
dVar	double
>	O
*	O
(	O
pMCVar	pointer
->	O
pdParm	array
[	O
3	int
]	O
)	O
)	O
)	O
{	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
pMCVar	pointer
->	O
dVal	double
=	O
dVar	double
;	O
}	O
return	O
(	O
1	int
)	O
;	O
}	O
void	O
SetPointers	function
(	O
PLEVEL	pointer
plevel	pointer
,	O
char	O
*	O
*	O
args	pointer
)	O
{	O
long	O
i	long
,	O
j	long
,	O
k	pointer
;	O
PMCVAR	pointer
pMCVar	pointer
;	O
POUTSPEC	pointer
pos	pointer
;	O
BOOL	int
bFound	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
plevel	pointer
->	O
nMCVars	long
;	O
i	long
++	O
)	O
{	O
pMCVar	pointer
=	O
plevel	pointer
->	O
rgpMCVars	pointer
[	O
i	long
]	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
4	int
;	O
j	long
++	O
)	O
{	O
if	O
(	O
pMCVar	pointer
->	O
pMCVParent	array
[	O
j	long
]	O
==	O
NULL	O
)	O
pMCVar	pointer
->	O
pdParm	array
[	O
j	long
]	O
=	O
&	O
(	O
pMCVar	pointer
->	O
dParm	array
[	O
j	long
]	O
)	O
;	O
else	O
pMCVar	pointer
->	O
pdParm	array
[	O
j	long
]	O
=	O
&	O
(	O
pMCVar	pointer
->	O
pMCVParent	array
[	O
j	long
]	O
->	O
dVal	double
)	O
;	O
}	O
}	O
if	O
(	O
plevel	pointer
->	O
pexpt	pointer
!=	O
NULL	O
)	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
plevel	pointer
->	O
nLikes	long
;	O
i	long
++	O
)	O
{	O
pMCVar	pointer
=	O
plevel	pointer
->	O
rgpLikes	pointer
[	O
i	long
]	O
;	O
pos	pointer
=	O
&	O
(	O
plevel	pointer
->	O
pexpt	pointer
->	O
os	struct
)	O
;	O
bFound	int
=	O
FALSE	int
;	O
j	long
=	O
0	int
;	O
while	O
(	O
(	O
j	long
<	O
pos	pointer
->	O
nData	int
)	O
&&	O
(	O
!	O
bFound	int
)	O
)	O
{	O
bFound	int
=	O
(	O
pMCVar	pointer
->	O
hvar	long
==	O
pos	pointer
->	O
phvar_dat	pointer
[	O
j	long
]	O
)	O
;	O
if	O
(	O
!	O
bFound	int
)	O
j	long
++	O
;	O
}	O
if	O
(	O
bFound	int
)	O
{	O
pMCVar	pointer
->	O
pdVal	pointer
=	O
pos	pointer
->	O
prgdDataVals	pointer
[	O
j	long
]	O
;	O
pMCVar	pointer
->	O
lCount	long
=	O
pos	pointer
->	O
pcData	pointer
[	O
j	long
]	O
;	O
}	O
else	O
{	O
printf	function
(	O
"Error: no Data for %s in Simulation %d - Exiting.\n\n"	pointer
,	O
pMCVar	pointer
->	O
pszName	pointer
,	O
plevel	pointer
->	O
pexpt	pointer
->	O
iExp	int
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
4	int
;	O
j	long
++	O
)	O
{	O
if	O
(	O
pMCVar	pointer
->	O
iParmType	array
[	O
j	long
]	O
==	O
MCVP_PRED	int
)	O
{	O
bFound	int
=	O
FALSE	int
;	O
k	pointer
=	O
0	int
;	O
while	O
(	O
(	O
k	pointer
<	O
pos	pointer
->	O
nOutputs	int
)	O
&&	O
(	O
!	O
bFound	int
)	O
)	O
{	O
bFound	int
=	O
(	O
pMCVar	pointer
->	O
hParm	array
[	O
j	long
]	O
==	O
pos	pointer
->	O
phvar_out	pointer
[	O
k	pointer
]	O
)	O
;	O
if	O
(	O
!	O
bFound	int
)	O
k	pointer
++	O
;	O
}	O
if	O
(	O
bFound	int
)	O
{	O
pMCVar	pointer
->	O
pdParm	array
[	O
j	long
]	O
=	O
&	O
(	O
pos	pointer
->	O
prgdOutputVals	pointer
[	O
k	pointer
]	O
[	O
0	int
]	O
)	O
;	O
}	O
else	O
{	O
printf	function
(	O
"Error: missing Print statement for parameter number %ld\n"	pointer
"of %s distribution - Exiting.\n\n"	pointer
,	O
j	long
,	O
pMCVar	pointer
->	O
pszName	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
pMCVar	pointer
->	O
iParmType	array
[	O
j	long
]	O
==	O
MCVP_DATA	int
)	O
{	O
bFound	int
=	O
FALSE	int
;	O
k	pointer
=	O
0	int
;	O
while	O
(	O
(	O
k	pointer
<	O
pos	pointer
->	O
nData	int
)	O
&&	O
(	O
!	O
bFound	int
)	O
)	O
{	O
bFound	int
=	O
(	O
pMCVar	pointer
->	O
hParm	array
[	O
j	long
]	O
==	O
pos	pointer
->	O
phvar_dat	pointer
[	O
k	pointer
]	O
)	O
;	O
if	O
(	O
!	O
bFound	int
)	O
k	pointer
++	O
;	O
}	O
if	O
(	O
bFound	int
)	O
{	O
pMCVar	pointer
->	O
pdParm	array
[	O
j	long
]	O
=	O
&	O
(	O
pos	pointer
->	O
prgdDataVals	pointer
[	O
k	pointer
]	O
[	O
0	int
]	O
)	O
;	O
}	O
else	O
{	O
printf	function
(	O
"Error: no Data for %s in Simulation %d - Exiting.\n\n"	pointer
,	O
pMCVar	pointer
->	O
pszName	pointer
,	O
plevel	pointer
->	O
pexpt	pointer
->	O
iExp	int
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
pMCVar	pointer
->	O
pMCVParent	array
[	O
j	long
]	O
==	O
NULL	O
)	O
pMCVar	pointer
->	O
pdParm	array
[	O
j	long
]	O
=	O
&	O
(	O
pMCVar	pointer
->	O
dParm	array
[	O
j	long
]	O
)	O
;	O
else	O
pMCVar	pointer
->	O
pdParm	array
[	O
j	long
]	O
=	O
&	O
(	O
pMCVar	pointer
->	O
pMCVParent	array
[	O
j	long
]	O
->	O
dVal	double
)	O
;	O
}	O
}	O
}	O
}	O
int	O
SumAllExpts	function
(	O
PLEVEL	pointer
plevel	pointer
,	O
char	O
*	O
*	O
args	pointer
)	O
{	O
double	O
*	O
pdLnData	pointer
=	O
(	O
double	O
*	O
)	O
args	pointer
[	O
0	int
]	O
;	O
PEXPERIMENT	pointer
pExpt	pointer
=	O
plevel	pointer
->	O
pexpt	pointer
;	O
if	O
(	O
pExpt	pointer
!=	O
NULL	O
)	O
{	O
*	O
pdLnData	pointer
+=	O
pExpt	pointer
->	O
dLnLike	double
;	O
}	O
return	O
(	O
1	int
)	O
;	O
}	O
BOOL	int
TestImpRatio	function
(	O
PGIBBSDATA	pointer
pgd	pointer
,	O
BOOL	int
bExptIsDep	int
,	O
double	O
dLnKern	double
,	O
double	O
dLnKernNew	double
,	O
double	O
dLnPrior	double
,	O
double	O
dLnPriorNew	double
,	O
double	O
dLnLike	double
,	O
double	O
dLnLikeNew	double
,	O
double	O
dLnData	double
,	O
double	O
dLnDataNew	double
)	O
{	O
double	O
dPjump	double
;	O
if	O
(	O
dLnKernNew	double
==	O
NULL_SUPPORT	O
||	O
dLnPriorNew	double
==	O
NULL_SUPPORT	O
||	O
dLnLikeNew	double
==	O
NULL_SUPPORT	O
||	O
dLnDataNew	double
==	O
NULL_SUPPORT	O
)	O
return	O
FALSE	int
;	O
dPjump	double
=	O
dLnPriorNew	double
-	O
dLnPrior	double
+	O
dLnLikeNew	double
-	O
dLnLike	double
+	O
dLnKern	double
-	O
dLnKernNew	double
;	O
if	O
(	O
bExptIsDep	int
)	O
dPjump	double
+=	O
dLnDataNew	double
-	O
dLnData	double
;	O
if	O
(	O
pgd	pointer
->	O
nSimTypeFlag	long
==	O
0	int
)	O
return	O
(	O
(	O
BOOL	int
)	O
(	O
log	function
(	O
Randoms	function
(	O
)	O
)	O
<=	O
dPjump	double
)	O
)	O
;	O
else	O
{	O
if	O
(	O
pgd	pointer
->	O
nSimTypeFlag	long
==	O
5	int
)	O
return	O
(	O
(	O
BOOL	int
)	O
(	O
0	int
<=	O
dPjump	double
)	O
)	O
;	O
else	O
{	O
printf	function
(	O
"Error: simTypeFlag should be 0 or 5 in TestImpRatio "	pointer
"- Exiting.\n\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
}	O
}	O
BOOL	int
TestImpRatioTemper	function
(	O
PGIBBSDATA	pointer
pgd	pointer
,	O
BOOL	int
bExptIsDep	int
,	O
double	O
dLnKern	double
,	O
double	O
dLnKernNew	double
,	O
double	O
dLnPrior	double
,	O
double	O
dLnPriorNew	double
,	O
double	O
dLnLike	double
,	O
double	O
dLnLikeNew	double
,	O
double	O
dLnData	double
,	O
double	O
dLnDataNew	double
,	O
long	O
indexT	int
)	O
{	O
double	O
dPjump	double
;	O
if	O
(	O
dLnPriorNew	double
==	O
NULL_SUPPORT	O
||	O
dLnLikeNew	double
==	O
NULL_SUPPORT	O
||	O
dLnDataNew	double
==	O
NULL_SUPPORT	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
indexT	int
]	O
==	O
0	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
pgd	pointer
->	O
nSimTypeFlag	long
==	O
3	int
)	O
{	O
dPjump	double
=	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
indexT	int
]	O
*	O
(	O
dLnPriorNew	double
-	O
dLnPrior	double
+	O
dLnLikeNew	double
-	O
dLnLike	double
)	O
+	O
dLnKern	double
-	O
dLnKernNew	double
;	O
}	O
else	O
{	O
dPjump	double
=	O
dLnPriorNew	double
-	O
dLnPrior	double
+	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
indexT	int
]	O
*	O
(	O
dLnLikeNew	double
-	O
dLnLike	double
)	O
+	O
dLnKern	double
-	O
dLnKernNew	double
;	O
}	O
if	O
(	O
bExptIsDep	int
)	O
dPjump	double
+=	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
indexT	int
]	O
*	O
(	O
dLnDataNew	double
-	O
dLnData	double
)	O
;	O
return	O
(	O
(	O
BOOL	int
)	O
(	O
log	function
(	O
Randoms	function
(	O
)	O
)	O
<=	O
dPjump	double
)	O
)	O
;	O
}	O
BOOL	int
TestTemper	function
(	O
PGIBBSDATA	pointer
pgd	pointer
,	O
long	O
indexT	int
,	O
long	O
indexT_new	long
,	O
double	O
dLnPrior	double
,	O
double	O
dLnData	double
,	O
double	O
pseudo	double
,	O
double	O
pseudonew	double
)	O
{	O
double	O
dPjump	double
=	O
0	int
;	O
if	O
(	O
dLnPrior	double
+	O
dLnData	double
==	O
NULL_SUPPORT	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
pgd	pointer
->	O
nSimTypeFlag	long
==	O
3	int
)	O
{	O
dPjump	double
=	O
(	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
indexT_new	long
]	O
-	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
indexT	int
]	O
)	O
*	O
(	O
dLnPrior	double
+	O
dLnData	double
)	O
+	O
pseudonew	double
-	O
pseudo	double
+	O
(	O
(	O
indexT_new	long
==	O
0	int
)	O
||	O
(	O
indexT_new	long
==	O
pgd	pointer
->	O
nPerks	int
-	O
1	int
)	O
?	O
0	int
:	O
MINUSLN2	O
)	O
-	O
(	O
(	O
indexT	int
==	O
0	int
)	O
||	O
(	O
indexT	int
==	O
pgd	pointer
->	O
nPerks	int
-	O
1	int
)	O
?	O
0	int
:	O
MINUSLN2	O
)	O
;	O
}	O
else	O
{	O
dPjump	double
=	O
(	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
indexT_new	long
]	O
-	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
indexT	int
]	O
)	O
*	O
dLnData	double
+	O
pseudonew	double
-	O
pseudo	double
+	O
(	O
(	O
indexT_new	long
==	O
0	int
)	O
||	O
(	O
indexT_new	long
==	O
pgd	pointer
->	O
nPerks	int
-	O
1	int
)	O
?	O
0	int
:	O
MINUSLN2	O
)	O
-	O
(	O
(	O
indexT	int
==	O
0	int
)	O
||	O
(	O
indexT	int
==	O
pgd	pointer
->	O
nPerks	int
-	O
1	int
)	O
?	O
0	int
:	O
MINUSLN2	O
)	O
;	O
}	O
return	O
(	O
(	O
BOOL	int
)	O
(	O
log	function
(	O
Randoms	function
(	O
)	O
)	O
<=	O
dPjump	double
)	O
)	O
;	O
}	O
void	O
TraverseLevels	function
(	O
PLEVEL	pointer
plevel	pointer
,	O
void	O
(	O
*	O
routinePtr	pointer
)	O
(	O
PLEVEL	pointer
plevel	pointer
,	O
char	O
*	O
*	O
args	pointer
)	O
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
static	O
char	O
*	O
arg	array
[	O
MAX_ARGS	int
]	O
,	O
*	O
*	O
args	pointer
=	O
arg	array
;	O
char	O
*	O
arg1	pointer
;	O
long	O
n	int
,	O
nargs	long
=	O
0	int
;	O
va_start	O
(	O
ap	array
,	O
routinePtr	pointer
)	O
;	O
if	O
(	O
(	O
arg1	pointer
=	O
va_arg	O
(	O
ap	array
,	O
char	O
*	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
arg	array
[	O
0	int
]	O
=	O
arg1	pointer
;	O
while	O
(	O
(	O
arg	array
[	O
++	O
nargs	long
]	O
=	O
va_arg	O
(	O
ap	array
,	O
char	O
*	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
}	O
;	O
}	O
va_end	O
(	O
ap	array
)	O
;	O
routinePtr	pointer
(	O
plevel	pointer
,	O
args	pointer
)	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	pointer
->	O
iInstances	int
;	O
n	int
++	O
)	O
TraverseLevels	function
(	O
plevel	pointer
->	O
pLevels	array
[	O
n	int
]	O
,	O
routinePtr	pointer
,	O
NULL	O
)	O
;	O
}	O
int	O
TraverseLevels1	function
(	O
PLEVEL	pointer
plevel	pointer
,	O
int	O
(	O
*	O
routinePtr	pointer
)	O
(	O
PLEVEL	pointer
plevel	pointer
,	O
char	O
*	O
*	O
args	pointer
)	O
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
static	O
char	O
*	O
arg	array
[	O
MAX_ARGS	int
]	O
,	O
*	O
*	O
args	pointer
=	O
arg	array
;	O
char	O
*	O
arg1	pointer
;	O
long	O
n	int
,	O
nargs	long
=	O
0	int
;	O
va_start	O
(	O
ap	array
,	O
routinePtr	pointer
)	O
;	O
if	O
(	O
(	O
arg1	pointer
=	O
va_arg	O
(	O
ap	array
,	O
char	O
*	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
arg	array
[	O
0	int
]	O
=	O
arg1	pointer
;	O
while	O
(	O
(	O
arg	array
[	O
++	O
nargs	long
]	O
=	O
va_arg	O
(	O
ap	array
,	O
char	O
*	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
}	O
;	O
}	O
va_end	O
(	O
ap	array
)	O
;	O
if	O
(	O
routinePtr	pointer
(	O
plevel	pointer
,	O
args	pointer
)	O
)	O
{	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	pointer
->	O
iInstances	int
;	O
n	int
++	O
)	O
{	O
if	O
(	O
!	O
TraverseLevels1	function
(	O
plevel	pointer
->	O
pLevels	array
[	O
n	int
]	O
,	O
routinePtr	pointer
,	O
NULL	O
)	O
)	O
{	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
}	O
else	O
return	O
(	O
0	int
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
void	O
WriteHeader	function
(	O
PANALYSIS	pointer
panal	pointer
)	O
{	O
PGIBBSDATA	pointer
pgd	pointer
=	O
&	O
panal	pointer
->	O
gd	struct
;	O
long	O
i	long
;	O
fprintf	function
(	O
pgd	pointer
->	O
pfileOut	pointer
,	O
"iter\t"	pointer
)	O
;	O
TraverseLevels	function
(	O
panal	pointer
->	O
pLevels	array
[	O
0	int
]	O
,	O
WriteParameterNames	function
,	O
panal	pointer
,	O
pgd	pointer
->	O
pfileOut	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
(	O
pgd	pointer
->	O
nSimTypeFlag	long
==	O
3	int
)	O
||	O
(	O
pgd	pointer
->	O
nSimTypeFlag	long
==	O
4	int
)	O
)	O
{	O
fprintf	function
(	O
pgd	pointer
->	O
pfileOut	pointer
,	O
"IndexT\t"	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
pgd	pointer
->	O
nPerks	int
;	O
i	long
++	O
)	O
fprintf	function
(	O
pgd	pointer
->	O
pfileOut	pointer
,	O
"LnPseudoPrior(%ld)\t"	pointer
,	O
i	long
+	O
1	int
)	O
;	O
}	O
fprintf	function
(	O
pgd	pointer
->	O
pfileOut	pointer
,	O
"LnPrior\tLnData\tLnPosterior\n"	pointer
)	O
;	O
fflush	function
(	O
pgd	pointer
->	O
pfileOut	pointer
)	O
;	O
}	O
void	O
WriteParameterNames	function
(	O
PLEVEL	pointer
plevel	pointer
,	O
char	O
*	O
*	O
args	pointer
)	O
{	O
PANALYSIS	pointer
panal	pointer
=	O
(	O
PANALYSIS	pointer
)	O
args	pointer
[	O
0	int
]	O
;	O
PFILE	pointer
outFile	pointer
=	O
(	O
FILE	struct
*	O
)	O
args	pointer
[	O
1	int
]	O
;	O
long	O
n	int
,	O
m	long
;	O
panal	pointer
->	O
iInstance	array
[	O
plevel	pointer
->	O
iDepth	int
]	O
=	O
plevel	pointer
->	O
iSequence	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	pointer
->	O
nMCVars	long
;	O
n	int
++	O
)	O
{	O
fprintf	function
(	O
outFile	pointer
,	O
"%s("	pointer
,	O
plevel	pointer
->	O
rgpMCVars	pointer
[	O
n	int
]	O
->	O
pszName	pointer
)	O
;	O
for	O
(	O
m	long
=	O
1	int
;	O
m	long
<	O
plevel	pointer
->	O
iDepth	int
;	O
m	long
++	O
)	O
fprintf	function
(	O
outFile	pointer
,	O
"%d."	pointer
,	O
panal	pointer
->	O
iInstance	array
[	O
m	long
]	O
)	O
;	O
fprintf	function
(	O
outFile	pointer
,	O
"%d)\t"	pointer
,	O
panal	pointer
->	O
iInstance	array
[	O
plevel	pointer
->	O
iDepth	int
]	O
)	O
;	O
}	O
}	O
void	O
WriteMCVars	function
(	O
PLEVEL	pointer
plevel	pointer
,	O
char	O
*	O
*	O
args	pointer
)	O
{	O
PFILE	pointer
pOutFile	pointer
=	O
(	O
PFILE	pointer
)	O
args	pointer
[	O
0	int
]	O
;	O
long	O
n	int
;	O
PMCVAR	pointer
pMCVar	pointer
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	pointer
->	O
nMCVars	long
;	O
n	int
++	O
)	O
{	O
pMCVar	pointer
=	O
plevel	pointer
->	O
rgpMCVars	pointer
[	O
n	int
]	O
;	O
fprintf	function
(	O
pOutFile	pointer
,	O
"%5g\t"	pointer
,	O
pMCVar	pointer
->	O
dVal	double
)	O
;	O
}	O
}	O
