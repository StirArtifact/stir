typedef	O
int	O
charclass	array
[	O
CHARCLASS_INTS	O
]	O
;	O
typedef	O
enum	O
{	O
END	int
=	O
-	O
1	int
,	O
EMPTY	int
=	O
NOTCHAR	O
,	O
BACKREF	int
,	O
BEGLINE	int
,	O
ENDLINE	int
,	O
BEGWORD	int
,	O
ENDWORD	int
,	O
LIMWORD	int
,	O
NOTLIMWORD	int
,	O
QMARK	int
,	O
STAR	int
,	O
PLUS	int
,	O
REPMN	int
,	O
CAT	int
,	O
OR	int
,	O
LPAREN	int
,	O
RPAREN	int
,	O
ANYCHAR	int
,	O
MBCSET	int
,	O
WCHAR	int
,	O
CSET	int
}	O
token	enum
;	O
typedef	O
struct	O
{	O
unsigned	O
int	O
index	function
;	O
unsigned	O
int	O
constraint	int
;	O
}	O
position	struct
;	O
typedef	O
struct	O
{	O
position	struct
*	O
elems	pointer
;	O
int	O
nelem	int
;	O
}	O
position_set	struct
;	O
typedef	O
struct	O
{	O
int	O
hash	int
;	O
position_set	struct
elems	pointer
;	O
char	O
newline	int
;	O
char	O
letter	char
;	O
char	O
backref	pointer
;	O
unsigned	O
char	O
constraint	int
;	O
int	O
first_end	int
;	O
position_set	struct
mbps	struct
;	O
}	O
dfa_state	struct
;	O
struct	O
mb_char_classes	struct
{	O
int	O
cset	int
;	O
int	O
invert	int
;	O
wchar_t	int
*	O
chars	pointer
;	O
int	O
nchars	int
;	O
wctype_t	long
*	O
ch_classes	pointer
;	O
int	O
nch_classes	int
;	O
wchar_t	int
*	O
range_sts	pointer
;	O
wchar_t	int
*	O
range_ends	pointer
;	O
int	O
nranges	int
;	O
char	O
*	O
*	O
equivs	pointer
;	O
int	O
nequivs	int
;	O
char	O
*	O
*	O
coll_elems	pointer
;	O
int	O
ncoll_elems	int
;	O
}	O
;	O
struct	O
dfa	struct
{	O
charclass	array
*	O
charclasses	pointer
;	O
int	O
cindex	int
;	O
int	O
calloc	function
;	O
token	enum
*	O
tokens	pointer
;	O
int	O
tindex	int
;	O
int	O
talloc	int
;	O
int	O
depth	int
;	O
int	O
nleaves	int
;	O
int	O
nregexps	int
;	O
unsigned	O
int	O
mb_cur_max	int
;	O
int	O
utf8_anychar_classes	array
[	O
5	int
]	O
;	O
int	O
nmultibyte_prop	int
;	O
int	O
*	O
multibyte_prop	pointer
;	O
struct	O
mb_char_classes	struct
*	O
mbcsets	pointer
;	O
int	O
nmbcsets	int
;	O
int	O
mbcsets_alloc	int
;	O
dfa_state	struct
*	O
states	pointer
;	O
int	O
sindex	int
;	O
int	O
salloc	int
;	O
position_set	struct
*	O
follows	pointer
;	O
int	O
searchflag	int
;	O
int	O
tralloc	int
;	O
int	O
trcount	int
;	O
int	O
*	O
*	O
trans	pointer
;	O
int	O
*	O
*	O
realtrans	pointer
;	O
int	O
*	O
*	O
fails	pointer
;	O
int	O
*	O
success	pointer
;	O
int	O
*	O
newlines	pointer
;	O
struct	O
dfamust	struct
*	O
musts	pointer
;	O
}	O
;	O
static	O
void	O
dfamust	struct
(	O
struct	O
dfa	struct
*	O
dfa	struct
)	O
;	O
static	O
void	O
regexp	function
(	O
void	O
)	O
;	O
static	O
int	O
tstbit	function
(	O
unsigned	O
int	O
b	int
,	O
charclass	array
const	O
c	array
)	O
{	O
return	O
c	array
[	O
b	int
/	O
INTBITS	O
]	O
&	O
1	int
<<	O
b	int
%	O
INTBITS	O
;	O
}	O
static	O
void	O
setbit	function
(	O
unsigned	O
int	O
b	int
,	O
charclass	array
c	array
)	O
{	O
c	array
[	O
b	int
/	O
INTBITS	O
]	O
|=	O
1	int
<<	O
b	int
%	O
INTBITS	O
;	O
}	O
static	O
void	O
clrbit	function
(	O
unsigned	O
int	O
b	int
,	O
charclass	array
c	array
)	O
{	O
c	array
[	O
b	int
/	O
INTBITS	O
]	O
&=	O
~	O
(	O
1	int
<<	O
b	int
%	O
INTBITS	O
)	O
;	O
}	O
static	O
void	O
copyset	function
(	O
charclass	array
const	O
src	array
,	O
charclass	array
dst	array
)	O
{	O
memcpy	function
(	O
dst	array
,	O
src	array
,	O
sizeof	O
(	O
charclass	array
)	O
)	O
;	O
}	O
static	O
void	O
zeroset	function
(	O
charclass	array
s	long
)	O
{	O
memset	function
(	O
s	long
,	O
0	int
,	O
sizeof	O
(	O
charclass	array
)	O
)	O
;	O
}	O
static	O
void	O
notset	function
(	O
charclass	array
s	long
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
CHARCLASS_INTS	O
;	O
++	O
i	int
)	O
s	long
[	O
i	int
]	O
=	O
~	O
s	long
[	O
i	int
]	O
;	O
}	O
static	O
int	O
equal	function
(	O
charclass	array
const	O
s1	pointer
,	O
charclass	array
const	O
s2	pointer
)	O
{	O
return	O
memcmp	function
(	O
s1	pointer
,	O
s2	pointer
,	O
sizeof	O
(	O
charclass	array
)	O
)	O
==	O
0	int
;	O
}	O
static	O
struct	O
dfa	struct
*	O
dfa	struct
;	O
static	O
int	O
charclass_index	function
(	O
charclass	array
const	O
s	long
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dfa	struct
->	O
cindex	int
;	O
++	O
i	int
)	O
if	O
(	O
equal	function
(	O
s	long
,	O
dfa	struct
->	O
charclasses	pointer
[	O
i	int
]	O
)	O
)	O
return	O
i	int
;	O
REALLOC_IF_NECESSARY	O
(	O
dfa	struct
->	O
charclasses	pointer
,	O
charclass	array
,	O
dfa	struct
->	O
calloc	function
,	O
dfa	struct
->	O
cindex	int
)	O
;	O
++	O
dfa	struct
->	O
cindex	int
;	O
copyset	function
(	O
s	long
,	O
dfa	struct
->	O
charclasses	pointer
[	O
i	int
]	O
)	O
;	O
return	O
i	int
;	O
}	O
static	O
reg_syntax_t	long
syntax_bits	long
,	O
syntax_bits_set	long
;	O
static	O
int	O
case_fold	int
;	O
static	O
unsigned	O
char	O
eolbyte	char
;	O
void	O
dfasyntax	function
(	O
reg_syntax_t	long
bits	long
,	O
int	O
fold	int
,	O
unsigned	O
char	O
eol	char
)	O
{	O
syntax_bits_set	long
=	O
1	int
;	O
syntax_bits	long
=	O
bits	long
;	O
case_fold	int
=	O
fold	int
;	O
eolbyte	char
=	O
eol	char
;	O
}	O
static	O
bool	bool
setbit_wc	function
(	O
wint_t	int
wc	int
,	O
charclass	array
c	array
)	O
{	O
int	O
b	int
=	O
wctob	function
(	O
wc	int
)	O
;	O
if	O
(	O
b	int
==	O
EOF	O
)	O
return	O
false	int
;	O
setbit	function
(	O
b	int
,	O
c	array
)	O
;	O
return	O
true	int
;	O
}	O
static	O
void	O
setbit_c	function
(	O
int	O
b	int
,	O
charclass	array
c	array
)	O
{	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
btowc	function
(	O
b	int
)	O
==	O
WEOF	O
)	O
return	O
;	O
setbit	function
(	O
b	int
,	O
c	array
)	O
;	O
}	O
static	O
void	O
setbit_case_fold_c	function
(	O
int	O
b	int
,	O
charclass	array
c	array
)	O
{	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
)	O
{	O
wint_t	int
wc	int
=	O
btowc	function
(	O
b	int
)	O
;	O
if	O
(	O
wc	int
==	O
WEOF	O
)	O
return	O
;	O
setbit	function
(	O
b	int
,	O
c	array
)	O
;	O
if	O
(	O
case_fold	int
&&	O
iswalpha	function
(	O
wc	int
)	O
)	O
setbit_wc	function
(	O
iswupper	function
(	O
wc	int
)	O
?	O
towlower	function
(	O
wc	int
)	O
:	O
towupper	function
(	O
wc	int
)	O
,	O
c	array
)	O
;	O
}	O
else	O
{	O
setbit	function
(	O
b	int
,	O
c	array
)	O
;	O
if	O
(	O
case_fold	int
&&	O
isalpha	function
(	O
b	int
)	O
)	O
setbit_c	function
(	O
isupper	function
(	O
b	int
)	O
?	O
tolower	function
(	O
b	int
)	O
:	O
toupper	function
(	O
b	int
)	O
,	O
c	array
)	O
;	O
}	O
}	O
static	O
inline	O
int	O
using_utf8	function
(	O
void	O
)	O
{	O
static	O
int	O
utf8	int
=	O
-	O
1	int
;	O
if	O
(	O
utf8	int
==	O
-	O
1	int
)	O
{	O
utf8	int
=	O
(	O
STREQ	O
(	O
nl_langinfo	function
(	O
CODESET	int
)	O
,	O
"UTF-8"	pointer
)	O
)	O
;	O
}	O
return	O
utf8	int
;	O
}	O
static	O
char	O
const	O
*	O
lexptr	pointer
;	O
static	O
int	O
lexleft	int
;	O
static	O
token	enum
lasttok	enum
;	O
static	O
int	O
laststart	int
;	O
static	O
int	O
parens	int
;	O
static	O
int	O
minrep	int
,	O
maxrep	int
;	O
static	O
int	O
hard_LC_COLLATE	int
;	O
static	O
int	O
cur_mb_len	int
=	O
1	int
;	O
static	O
mbstate_t	struct
mbs	struct
;	O
static	O
wchar_t	int
wctok	int
;	O
static	O
unsigned	O
char	O
*	O
mblen_buf	pointer
;	O
static	O
wchar_t	int
*	O
inputwcs	pointer
;	O
static	O
unsigned	O
char	O
const	O
*	O
buf_begin	pointer
;	O
static	O
unsigned	O
char	O
const	O
*	O
buf_end	pointer
;	O
typedef	O
int	O
predicate	function
(	O
int	O
)	O
;	O
struct	O
dfa_ctype	struct
{	O
const	O
char	O
*	O
name	pointer
;	O
predicate	function
*	O
func	pointer
;	O
bool	bool
single_byte_only	bool
;	O
}	O
;	O
static	O
const	O
struct	O
dfa_ctype	struct
prednames	array
[	O
]	O
=	O
{	O
{	O
"alpha"	pointer
,	O
isalpha	function
,	O
false	int
}	O
,	O
{	O
"upper"	pointer
,	O
isupper	function
,	O
false	int
}	O
,	O
{	O
"lower"	pointer
,	O
islower	function
,	O
false	int
}	O
,	O
{	O
"digit"	pointer
,	O
isdigit	function
,	O
true	int
}	O
,	O
{	O
"xdigit"	pointer
,	O
isxdigit	function
,	O
true	int
}	O
,	O
{	O
"space"	pointer
,	O
isspace	function
,	O
false	int
}	O
,	O
{	O
"punct"	pointer
,	O
ispunct	function
,	O
false	int
}	O
,	O
{	O
"alnum"	pointer
,	O
isalnum	function
,	O
false	int
}	O
,	O
{	O
"print"	pointer
,	O
isprint	function
,	O
false	int
}	O
,	O
{	O
"graph"	pointer
,	O
isgraph	function
,	O
false	int
}	O
,	O
{	O
"cntrl"	pointer
,	O
iscntrl	function
,	O
false	int
}	O
,	O
{	O
"blank"	pointer
,	O
isblank	function
,	O
false	int
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
false	int
}	O
}	O
;	O
static	O
const	O
struct	O
dfa_ctype	struct
*	O
find_pred	function
(	O
const	O
char	O
*	O
str	pointer
)	O
{	O
unsigned	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
prednames	array
[	O
i	int
]	O
.	O
name	pointer
;	O
++	O
i	int
)	O
if	O
(	O
STREQ	O
(	O
str	pointer
,	O
prednames	array
[	O
i	int
]	O
.	O
name	pointer
)	O
)	O
break	O
;	O
return	O
&	O
prednames	array
[	O
i	int
]	O
;	O
}	O
static	O
token	enum
parse_bracket_exp	function
(	O
void	O
)	O
{	O
int	O
invert	int
;	O
int	O
c	array
,	O
c1	int
,	O
c2	int
;	O
charclass	array
ccl	array
;	O
int	O
colon_warning_state	int
;	O
wint_t	int
wc	int
,	O
wc1	int
,	O
wc2	int
;	O
struct	O
mb_char_classes	struct
*	O
work_mbc	pointer
;	O
int	O
chars_al	int
,	O
range_sts_al	int
,	O
range_ends_al	int
,	O
ch_classes_al	int
,	O
equivs_al	int
,	O
coll_elems_al	int
;	O
chars_al	int
=	O
1	int
;	O
range_sts_al	int
=	O
range_ends_al	int
=	O
0	int
;	O
ch_classes_al	int
=	O
equivs_al	int
=	O
coll_elems_al	int
=	O
0	int
;	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
)	O
{	O
REALLOC_IF_NECESSARY	O
(	O
dfa	struct
->	O
mbcsets	pointer
,	O
struct	O
mb_char_classes	struct
,	O
dfa	struct
->	O
mbcsets_alloc	int
,	O
dfa	struct
->	O
nmbcsets	int
+	O
1	int
)	O
;	O
work_mbc	pointer
=	O
&	O
(	O
dfa	struct
->	O
mbcsets	pointer
[	O
dfa	struct
->	O
nmbcsets	int
++	O
]	O
)	O
;	O
memset	function
(	O
work_mbc	pointer
,	O
0	int
,	O
sizeof	O
*	O
work_mbc	pointer
)	O
;	O
}	O
else	O
work_mbc	pointer
=	O
NULL	O
;	O
memset	function
(	O
ccl	array
,	O
0	int
,	O
sizeof	O
ccl	array
)	O
;	O
FETCH_WC	O
(	O
c	array
,	O
wc	int
,	O
_	O
(	O
"unbalanced ["	pointer
)	O
)	O
;	O
if	O
(	O
c	array
==	O
'^'	O
)	O
{	O
FETCH_WC	O
(	O
c	array
,	O
wc	int
,	O
_	O
(	O
"unbalanced ["	pointer
)	O
)	O
;	O
invert	int
=	O
1	int
;	O
}	O
else	O
invert	int
=	O
0	int
;	O
colon_warning_state	int
=	O
(	O
c	array
==	O
':'	O
)	O
;	O
do	O
{	O
c1	int
=	O
EOF	O
;	O
colon_warning_state	int
&=	O
~	O
2	int
;	O
if	O
(	O
c	array
==	O
'['	O
&&	O
(	O
syntax_bits	long
&	O
RE_CHAR_CLASSES	O
)	O
)	O
{	O
char	O
str	pointer
[	O
BRACKET_BUFFER_SIZE	int
]	O
;	O
FETCH_WC	O
(	O
c1	int
,	O
wc1	int
,	O
_	O
(	O
"unbalanced ["	pointer
)	O
)	O
;	O
if	O
(	O
c1	int
==	O
':'	O
||	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
(	O
c1	int
==	O
'.'	O
||	O
c1	int
==	O
'='	O
)	O
)	O
)	O
{	O
size_t	long
len	long
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
FETCH_WC	O
(	O
c	array
,	O
wc	int
,	O
_	O
(	O
"unbalanced ["	pointer
)	O
)	O
;	O
if	O
(	O
(	O
c	array
==	O
c1	int
&&	O
*	O
lexptr	pointer
==	O
']'	O
)	O
||	O
lexleft	int
==	O
0	int
)	O
break	O
;	O
if	O
(	O
len	long
<	O
BRACKET_BUFFER_SIZE	int
)	O
str	pointer
[	O
len	long
++	O
]	O
=	O
c	array
;	O
else	O
str	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
}	O
str	pointer
[	O
len	long
]	O
=	O
'\0'	O
;	O
FETCH_WC	O
(	O
c	array
,	O
wc	int
,	O
_	O
(	O
"unbalanced ["	pointer
)	O
)	O
;	O
if	O
(	O
c1	int
==	O
':'	O
)	O
{	O
char	O
const	O
*	O
class	pointer
=	O
(	O
case_fold	int
&&	O
(	O
STREQ	O
(	O
str	pointer
,	O
"upper"	pointer
)	O
||	O
STREQ	O
(	O
str	pointer
,	O
"lower"	pointer
)	O
)	O
?	O
"alpha"	pointer
:	O
str	pointer
)	O
;	O
const	O
struct	O
dfa_ctype	struct
*	O
pred	pointer
=	O
find_pred	function
(	O
class	pointer
)	O
;	O
if	O
(	O
!	O
pred	pointer
)	O
dfaerror	function
(	O
_	O
(	O
"invalid character class"	pointer
)	O
)	O
;	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
!	O
pred	pointer
->	O
single_byte_only	bool
)	O
{	O
wctype_t	long
wt	long
=	O
wctype	function
(	O
class	pointer
)	O
;	O
if	O
(	O
ch_classes_al	int
==	O
0	int
)	O
MALLOC	O
(	O
work_mbc	pointer
->	O
ch_classes	pointer
,	O
wctype_t	long
,	O
++	O
ch_classes_al	int
)	O
;	O
REALLOC_IF_NECESSARY	O
(	O
work_mbc	pointer
->	O
ch_classes	pointer
,	O
wctype_t	long
,	O
ch_classes_al	int
,	O
work_mbc	pointer
->	O
nch_classes	int
+	O
1	int
)	O
;	O
work_mbc	pointer
->	O
ch_classes	pointer
[	O
work_mbc	pointer
->	O
nch_classes	int
++	O
]	O
=	O
wt	long
;	O
}	O
for	O
(	O
c2	int
=	O
0	int
;	O
c2	int
<	O
NOTCHAR	O
;	O
++	O
c2	int
)	O
if	O
(	O
pred	pointer
->	O
func	pointer
(	O
c2	int
)	O
)	O
setbit_case_fold_c	function
(	O
c2	int
,	O
ccl	array
)	O
;	O
}	O
else	O
if	O
(	O
c1	int
==	O
'='	O
||	O
c1	int
==	O
'.'	O
)	O
{	O
char	O
*	O
elem	pointer
;	O
MALLOC	O
(	O
elem	pointer
,	O
char	O
,	O
len	long
+	O
1	int
)	O
;	O
strncpy	function
(	O
elem	pointer
,	O
str	pointer
,	O
len	long
+	O
1	int
)	O
;	O
if	O
(	O
c1	int
==	O
'='	O
)	O
{	O
if	O
(	O
equivs_al	int
==	O
0	int
)	O
MALLOC	O
(	O
work_mbc	pointer
->	O
equivs	pointer
,	O
char	O
*	O
,	O
++	O
equivs_al	int
)	O
;	O
REALLOC_IF_NECESSARY	O
(	O
work_mbc	pointer
->	O
equivs	pointer
,	O
char	O
*	O
,	O
equivs_al	int
,	O
work_mbc	pointer
->	O
nequivs	int
+	O
1	int
)	O
;	O
work_mbc	pointer
->	O
equivs	pointer
[	O
work_mbc	pointer
->	O
nequivs	int
++	O
]	O
=	O
elem	pointer
;	O
}	O
if	O
(	O
c1	int
==	O
'.'	O
)	O
{	O
if	O
(	O
coll_elems_al	int
==	O
0	int
)	O
MALLOC	O
(	O
work_mbc	pointer
->	O
coll_elems	pointer
,	O
char	O
*	O
,	O
++	O
coll_elems_al	int
)	O
;	O
REALLOC_IF_NECESSARY	O
(	O
work_mbc	pointer
->	O
coll_elems	pointer
,	O
char	O
*	O
,	O
coll_elems_al	int
,	O
work_mbc	pointer
->	O
ncoll_elems	int
+	O
1	int
)	O
;	O
work_mbc	pointer
->	O
coll_elems	pointer
[	O
work_mbc	pointer
->	O
ncoll_elems	int
++	O
]	O
=	O
elem	pointer
;	O
}	O
}	O
colon_warning_state	int
|=	O
8	int
;	O
FETCH_WC	O
(	O
c1	int
,	O
wc1	int
,	O
_	O
(	O
"unbalanced ["	pointer
)	O
)	O
;	O
continue	O
;	O
}	O
}	O
if	O
(	O
c	array
==	O
'\\'	O
&&	O
(	O
syntax_bits	long
&	O
RE_BACKSLASH_ESCAPE_IN_LISTS	O
)	O
)	O
FETCH_WC	O
(	O
c	array
,	O
wc	int
,	O
_	O
(	O
"unbalanced ["	pointer
)	O
)	O
;	O
if	O
(	O
c1	int
==	O
EOF	O
)	O
FETCH_WC	O
(	O
c1	int
,	O
wc1	int
,	O
_	O
(	O
"unbalanced ["	pointer
)	O
)	O
;	O
if	O
(	O
c1	int
==	O
'-'	O
)	O
{	O
FETCH_WC	O
(	O
c2	int
,	O
wc2	int
,	O
_	O
(	O
"unbalanced ["	pointer
)	O
)	O
;	O
if	O
(	O
c2	int
==	O
']'	O
)	O
{	O
lexptr	pointer
-=	O
cur_mb_len	int
;	O
lexleft	int
+=	O
cur_mb_len	int
;	O
}	O
}	O
if	O
(	O
c1	int
==	O
'-'	O
&&	O
c2	int
!=	O
']'	O
)	O
{	O
if	O
(	O
c2	int
==	O
'\\'	O
&&	O
(	O
syntax_bits	long
&	O
RE_BACKSLASH_ESCAPE_IN_LISTS	O
)	O
)	O
FETCH_WC	O
(	O
c2	int
,	O
wc2	int
,	O
_	O
(	O
"unbalanced ["	pointer
)	O
)	O
;	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
)	O
{	O
if	O
(	O
range_sts_al	int
==	O
0	int
)	O
{	O
MALLOC	O
(	O
work_mbc	pointer
->	O
range_sts	pointer
,	O
wchar_t	int
,	O
++	O
range_sts_al	int
)	O
;	O
MALLOC	O
(	O
work_mbc	pointer
->	O
range_ends	pointer
,	O
wchar_t	int
,	O
++	O
range_ends_al	int
)	O
;	O
}	O
REALLOC_IF_NECESSARY	O
(	O
work_mbc	pointer
->	O
range_sts	pointer
,	O
wchar_t	int
,	O
range_sts_al	int
,	O
work_mbc	pointer
->	O
nranges	int
+	O
1	int
)	O
;	O
REALLOC_IF_NECESSARY	O
(	O
work_mbc	pointer
->	O
range_ends	pointer
,	O
wchar_t	int
,	O
range_ends_al	int
,	O
work_mbc	pointer
->	O
nranges	int
+	O
1	int
)	O
;	O
work_mbc	pointer
->	O
range_sts	pointer
[	O
work_mbc	pointer
->	O
nranges	int
]	O
=	O
case_fold	int
?	O
towlower	function
(	O
wc	int
)	O
:	O
(	O
wchar_t	int
)	O
wc	int
;	O
work_mbc	pointer
->	O
range_ends	pointer
[	O
work_mbc	pointer
->	O
nranges	int
++	O
]	O
=	O
case_fold	int
?	O
towlower	function
(	O
wc2	int
)	O
:	O
(	O
wchar_t	int
)	O
wc2	int
;	O
}	O
else	O
{	O
c1	int
=	O
c	array
;	O
if	O
(	O
case_fold	int
)	O
{	O
c1	int
=	O
tolower	function
(	O
c1	int
)	O
;	O
c2	int
=	O
tolower	function
(	O
c2	int
)	O
;	O
}	O
if	O
(	O
!	O
hard_LC_COLLATE	int
)	O
for	O
(	O
c	array
=	O
c1	int
;	O
c	array
<=	O
c2	int
;	O
c	array
++	O
)	O
setbit_case_fold_c	function
(	O
c	array
,	O
ccl	array
)	O
;	O
else	O
{	O
regex_t	struct
re	struct
;	O
char	O
pattern	array
[	O
6	int
]	O
=	O
{	O
'['	O
,	O
c1	int
,	O
'-'	O
,	O
c2	int
,	O
']'	O
,	O
0	int
}	O
;	O
char	O
subject	array
[	O
2	int
]	O
=	O
{	O
0	int
,	O
0	int
}	O
;	O
regcomp	function
(	O
&	O
re	struct
,	O
pattern	array
,	O
REG_NOSUB	O
)	O
;	O
for	O
(	O
c	array
=	O
0	int
;	O
c	array
<	O
NOTCHAR	O
;	O
++	O
c	array
)	O
{	O
subject	array
[	O
0	int
]	O
=	O
c	array
;	O
if	O
(	O
!	O
(	O
case_fold	int
&&	O
isupper	function
(	O
c	array
)	O
)	O
&&	O
regexec	function
(	O
&	O
re	struct
,	O
subject	array
,	O
0	int
,	O
NULL	O
,	O
0	int
)	O
!=	O
REG_NOMATCH	O
)	O
setbit_case_fold_c	function
(	O
c	array
,	O
ccl	array
)	O
;	O
}	O
regfree	function
(	O
&	O
re	struct
)	O
;	O
}	O
}	O
colon_warning_state	int
|=	O
8	int
;	O
FETCH_WC	O
(	O
c1	int
,	O
wc1	int
,	O
_	O
(	O
"unbalanced ["	pointer
)	O
)	O
;	O
continue	O
;	O
}	O
colon_warning_state	int
|=	O
(	O
c	array
==	O
':'	O
)	O
?	O
2	int
:	O
4	int
;	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
)	O
{	O
if	O
(	O
case_fold	int
&&	O
iswalpha	function
(	O
wc	int
)	O
)	O
{	O
wc	int
=	O
towlower	function
(	O
wc	int
)	O
;	O
if	O
(	O
!	O
setbit_wc	function
(	O
wc	int
,	O
ccl	array
)	O
)	O
{	O
REALLOC_IF_NECESSARY	O
(	O
work_mbc	pointer
->	O
chars	pointer
,	O
wchar_t	int
,	O
chars_al	int
,	O
work_mbc	pointer
->	O
nchars	int
+	O
1	int
)	O
;	O
work_mbc	pointer
->	O
chars	pointer
[	O
work_mbc	pointer
->	O
nchars	int
++	O
]	O
=	O
wc	int
;	O
}	O
continue	O
;	O
}	O
if	O
(	O
!	O
setbit_wc	function
(	O
wc	int
,	O
ccl	array
)	O
)	O
{	O
REALLOC_IF_NECESSARY	O
(	O
work_mbc	pointer
->	O
chars	pointer
,	O
wchar_t	int
,	O
chars_al	int
,	O
work_mbc	pointer
->	O
nchars	int
+	O
1	int
)	O
;	O
work_mbc	pointer
->	O
chars	pointer
[	O
work_mbc	pointer
->	O
nchars	int
++	O
]	O
=	O
wc	int
;	O
}	O
}	O
else	O
setbit_case_fold_c	function
(	O
c	array
,	O
ccl	array
)	O
;	O
}	O
while	O
(	O
(	O
wc	int
=	O
wc1	int
,	O
(	O
c	array
=	O
c1	int
)	O
!=	O
']'	O
)	O
)	O
;	O
if	O
(	O
colon_warning_state	int
==	O
7	int
)	O
dfawarn	function
(	O
_	O
(	O
"character class syntax is [[:space:]], not [:space:]"	pointer
)	O
)	O
;	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
)	O
{	O
static	O
charclass	array
zeroclass	array
;	O
work_mbc	pointer
->	O
invert	int
=	O
invert	int
;	O
work_mbc	pointer
->	O
cset	int
=	O
equal	function
(	O
ccl	array
,	O
zeroclass	array
)	O
?	O
-	O
1	int
:	O
charclass_index	function
(	O
ccl	array
)	O
;	O
return	O
MBCSET	int
;	O
}	O
if	O
(	O
invert	int
)	O
{	O
assert	O
(	O
MB_CUR_MAX	O
==	O
1	int
)	O
;	O
notset	function
(	O
ccl	array
)	O
;	O
if	O
(	O
syntax_bits	long
&	O
RE_HAT_LISTS_NOT_NEWLINE	O
)	O
clrbit	function
(	O
eolbyte	char
,	O
ccl	array
)	O
;	O
}	O
return	O
CSET	int
+	O
charclass_index	function
(	O
ccl	array
)	O
;	O
}	O
static	O
token	enum
lex	function
(	O
void	O
)	O
{	O
unsigned	O
int	O
c	array
,	O
c2	int
;	O
int	O
backslash	int
=	O
0	int
;	O
charclass	array
ccl	array
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
2	int
;	O
++	O
i	int
)	O
{	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
)	O
{	O
FETCH_WC	O
(	O
c	array
,	O
wctok	int
,	O
NULL	O
)	O
;	O
if	O
(	O
(	O
int	O
)	O
c	array
==	O
EOF	O
)	O
goto	O
normal_char	O
;	O
}	O
else	O
FETCH	O
(	O
c	array
,	O
NULL	O
)	O
;	O
switch	O
(	O
c	array
)	O
{	O
case	O
'\\'	O
:	O
if	O
(	O
backslash	int
)	O
goto	O
normal_char	O
;	O
if	O
(	O
lexleft	int
==	O
0	int
)	O
dfaerror	function
(	O
_	O
(	O
"unfinished \\ escape"	pointer
)	O
)	O
;	O
backslash	int
=	O
1	int
;	O
break	O
;	O
case	O
'^'	O
:	O
if	O
(	O
backslash	int
)	O
goto	O
normal_char	O
;	O
if	O
(	O
syntax_bits	long
&	O
RE_CONTEXT_INDEP_ANCHORS	O
||	O
lasttok	enum
==	O
END	int
||	O
lasttok	enum
==	O
LPAREN	int
||	O
lasttok	enum
==	O
OR	int
)	O
return	O
lasttok	enum
=	O
BEGLINE	int
;	O
goto	O
normal_char	O
;	O
case	O
'$'	O
:	O
if	O
(	O
backslash	int
)	O
goto	O
normal_char	O
;	O
if	O
(	O
syntax_bits	long
&	O
RE_CONTEXT_INDEP_ANCHORS	O
||	O
lexleft	int
==	O
0	int
||	O
(	O
syntax_bits	long
&	O
RE_NO_BK_PARENS	O
?	O
lexleft	int
>	O
0	int
&&	O
*	O
lexptr	pointer
==	O
')'	O
:	O
lexleft	int
>	O
1	int
&&	O
lexptr	pointer
[	O
0	int
]	O
==	O
'\\'	O
&&	O
lexptr	pointer
[	O
1	int
]	O
==	O
')'	O
)	O
||	O
(	O
syntax_bits	long
&	O
RE_NO_BK_VBAR	O
?	O
lexleft	int
>	O
0	int
&&	O
*	O
lexptr	pointer
==	O
'|'	O
:	O
lexleft	int
>	O
1	int
&&	O
lexptr	pointer
[	O
0	int
]	O
==	O
'\\'	O
&&	O
lexptr	pointer
[	O
1	int
]	O
==	O
'|'	O
)	O
||	O
(	O
(	O
syntax_bits	long
&	O
RE_NEWLINE_ALT	O
)	O
&&	O
lexleft	int
>	O
0	int
&&	O
*	O
lexptr	pointer
==	O
'\n'	O
)	O
)	O
return	O
lasttok	enum
=	O
ENDLINE	int
;	O
goto	O
normal_char	O
;	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
if	O
(	O
backslash	int
&&	O
!	O
(	O
syntax_bits	long
&	O
RE_NO_BK_REFS	O
)	O
)	O
{	O
laststart	int
=	O
0	int
;	O
return	O
lasttok	enum
=	O
BACKREF	int
;	O
}	O
goto	O
normal_char	O
;	O
case	O
'`'	O
:	O
if	O
(	O
backslash	int
&&	O
!	O
(	O
syntax_bits	long
&	O
RE_NO_GNU_OPS	O
)	O
)	O
return	O
lasttok	enum
=	O
BEGLINE	int
;	O
goto	O
normal_char	O
;	O
case	O
'\''	O
:	O
if	O
(	O
backslash	int
&&	O
!	O
(	O
syntax_bits	long
&	O
RE_NO_GNU_OPS	O
)	O
)	O
return	O
lasttok	enum
=	O
ENDLINE	int
;	O
goto	O
normal_char	O
;	O
case	O
'<'	O
:	O
if	O
(	O
backslash	int
&&	O
!	O
(	O
syntax_bits	long
&	O
RE_NO_GNU_OPS	O
)	O
)	O
return	O
lasttok	enum
=	O
BEGWORD	int
;	O
goto	O
normal_char	O
;	O
case	O
'>'	O
:	O
if	O
(	O
backslash	int
&&	O
!	O
(	O
syntax_bits	long
&	O
RE_NO_GNU_OPS	O
)	O
)	O
return	O
lasttok	enum
=	O
ENDWORD	int
;	O
goto	O
normal_char	O
;	O
case	O
'b'	O
:	O
if	O
(	O
backslash	int
&&	O
!	O
(	O
syntax_bits	long
&	O
RE_NO_GNU_OPS	O
)	O
)	O
return	O
lasttok	enum
=	O
LIMWORD	int
;	O
goto	O
normal_char	O
;	O
case	O
'B'	O
:	O
if	O
(	O
backslash	int
&&	O
!	O
(	O
syntax_bits	long
&	O
RE_NO_GNU_OPS	O
)	O
)	O
return	O
lasttok	enum
=	O
NOTLIMWORD	int
;	O
goto	O
normal_char	O
;	O
case	O
'?'	O
:	O
if	O
(	O
syntax_bits	long
&	O
RE_LIMITED_OPS	O
)	O
goto	O
normal_char	O
;	O
if	O
(	O
backslash	int
!=	O
(	O
(	O
syntax_bits	long
&	O
RE_BK_PLUS_QM	O
)	O
!=	O
0	int
)	O
)	O
goto	O
normal_char	O
;	O
if	O
(	O
!	O
(	O
syntax_bits	long
&	O
RE_CONTEXT_INDEP_OPS	O
)	O
&&	O
laststart	int
)	O
goto	O
normal_char	O
;	O
return	O
lasttok	enum
=	O
QMARK	int
;	O
case	O
'*'	O
:	O
if	O
(	O
backslash	int
)	O
goto	O
normal_char	O
;	O
if	O
(	O
!	O
(	O
syntax_bits	long
&	O
RE_CONTEXT_INDEP_OPS	O
)	O
&&	O
laststart	int
)	O
goto	O
normal_char	O
;	O
return	O
lasttok	enum
=	O
STAR	int
;	O
case	O
'+'	O
:	O
if	O
(	O
syntax_bits	long
&	O
RE_LIMITED_OPS	O
)	O
goto	O
normal_char	O
;	O
if	O
(	O
backslash	int
!=	O
(	O
(	O
syntax_bits	long
&	O
RE_BK_PLUS_QM	O
)	O
!=	O
0	int
)	O
)	O
goto	O
normal_char	O
;	O
if	O
(	O
!	O
(	O
syntax_bits	long
&	O
RE_CONTEXT_INDEP_OPS	O
)	O
&&	O
laststart	int
)	O
goto	O
normal_char	O
;	O
return	O
lasttok	enum
=	O
PLUS	int
;	O
case	O
'{'	O
:	O
if	O
(	O
!	O
(	O
syntax_bits	long
&	O
RE_INTERVALS	O
)	O
)	O
goto	O
normal_char	O
;	O
if	O
(	O
backslash	int
!=	O
(	O
(	O
syntax_bits	long
&	O
RE_NO_BK_BRACES	O
)	O
==	O
0	int
)	O
)	O
goto	O
normal_char	O
;	O
if	O
(	O
!	O
(	O
syntax_bits	long
&	O
RE_CONTEXT_INDEP_OPS	O
)	O
&&	O
laststart	int
)	O
goto	O
normal_char	O
;	O
if	O
(	O
syntax_bits	long
&	O
RE_NO_BK_BRACES	O
)	O
{	O
int	O
lo	int
=	O
-	O
1	int
,	O
hi	int
=	O
-	O
1	int
;	O
char	O
const	O
*	O
p	pointer
=	O
lexptr	pointer
;	O
char	O
const	O
*	O
lim	pointer
=	O
p	pointer
+	O
lexleft	int
;	O
for	O
(	O
;	O
p	pointer
!=	O
lim	pointer
&&	O
ISASCIIDIGIT	O
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
)	O
lo	int
=	O
(	O
lo	int
<	O
0	int
?	O
0	int
:	O
lo	int
*	O
10	int
)	O
+	O
*	O
p	pointer
-	O
'0'	O
;	O
if	O
(	O
p	pointer
!=	O
lim	pointer
&&	O
*	O
p	pointer
==	O
','	O
)	O
while	O
(	O
++	O
p	pointer
!=	O
lim	pointer
&&	O
ISASCIIDIGIT	O
(	O
*	O
p	pointer
)	O
)	O
hi	int
=	O
(	O
hi	int
<	O
0	int
?	O
0	int
:	O
hi	int
*	O
10	int
)	O
+	O
*	O
p	pointer
-	O
'0'	O
;	O
else	O
hi	int
=	O
lo	int
;	O
if	O
(	O
p	pointer
==	O
lim	pointer
||	O
*	O
p	pointer
!=	O
'}'	O
||	O
lo	int
<	O
0	int
||	O
RE_DUP_MAX	O
<	O
hi	int
||	O
(	O
0	int
<=	O
hi	int
&&	O
hi	int
<	O
lo	int
)	O
)	O
goto	O
normal_char	O
;	O
}	O
minrep	int
=	O
0	int
;	O
FETCH	O
(	O
c	array
,	O
_	O
(	O
"unfinished repeat count"	pointer
)	O
)	O
;	O
if	O
(	O
ISASCIIDIGIT	O
(	O
c	array
)	O
)	O
{	O
minrep	int
=	O
c	array
-	O
'0'	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
FETCH	O
(	O
c	array
,	O
_	O
(	O
"unfinished repeat count"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
ISASCIIDIGIT	O
(	O
c	array
)	O
)	O
break	O
;	O
minrep	int
=	O
10	int
*	O
minrep	int
+	O
c	array
-	O
'0'	O
;	O
}	O
}	O
else	O
dfaerror	function
(	O
_	O
(	O
"malformed repeat count"	pointer
)	O
)	O
;	O
if	O
(	O
c	array
==	O
','	O
)	O
{	O
FETCH	O
(	O
c	array
,	O
_	O
(	O
"unfinished repeat count"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
ISASCIIDIGIT	O
(	O
c	array
)	O
)	O
maxrep	int
=	O
-	O
1	int
;	O
else	O
{	O
maxrep	int
=	O
c	array
-	O
'0'	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
FETCH	O
(	O
c	array
,	O
_	O
(	O
"unfinished repeat count"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
ISASCIIDIGIT	O
(	O
c	array
)	O
)	O
break	O
;	O
maxrep	int
=	O
10	int
*	O
maxrep	int
+	O
c	array
-	O
'0'	O
;	O
}	O
if	O
(	O
0	int
<=	O
maxrep	int
&&	O
maxrep	int
<	O
minrep	int
)	O
dfaerror	function
(	O
_	O
(	O
"malformed repeat count"	pointer
)	O
)	O
;	O
}	O
}	O
else	O
maxrep	int
=	O
minrep	int
;	O
if	O
(	O
!	O
(	O
syntax_bits	long
&	O
RE_NO_BK_BRACES	O
)	O
)	O
{	O
if	O
(	O
c	array
!=	O
'\\'	O
)	O
dfaerror	function
(	O
_	O
(	O
"malformed repeat count"	pointer
)	O
)	O
;	O
FETCH	O
(	O
c	array
,	O
_	O
(	O
"unfinished repeat count"	pointer
)	O
)	O
;	O
}	O
if	O
(	O
c	array
!=	O
'}'	O
)	O
dfaerror	function
(	O
_	O
(	O
"malformed repeat count"	pointer
)	O
)	O
;	O
laststart	int
=	O
0	int
;	O
return	O
lasttok	enum
=	O
REPMN	int
;	O
case	O
'|'	O
:	O
if	O
(	O
syntax_bits	long
&	O
RE_LIMITED_OPS	O
)	O
goto	O
normal_char	O
;	O
if	O
(	O
backslash	int
!=	O
(	O
(	O
syntax_bits	long
&	O
RE_NO_BK_VBAR	O
)	O
==	O
0	int
)	O
)	O
goto	O
normal_char	O
;	O
laststart	int
=	O
1	int
;	O
return	O
lasttok	enum
=	O
OR	int
;	O
case	O
'\n'	O
:	O
if	O
(	O
syntax_bits	long
&	O
RE_LIMITED_OPS	O
||	O
backslash	int
||	O
!	O
(	O
syntax_bits	long
&	O
RE_NEWLINE_ALT	O
)	O
)	O
goto	O
normal_char	O
;	O
laststart	int
=	O
1	int
;	O
return	O
lasttok	enum
=	O
OR	int
;	O
case	O
'('	O
:	O
if	O
(	O
backslash	int
!=	O
(	O
(	O
syntax_bits	long
&	O
RE_NO_BK_PARENS	O
)	O
==	O
0	int
)	O
)	O
goto	O
normal_char	O
;	O
++	O
parens	int
;	O
laststart	int
=	O
1	int
;	O
return	O
lasttok	enum
=	O
LPAREN	int
;	O
case	O
')'	O
:	O
if	O
(	O
backslash	int
!=	O
(	O
(	O
syntax_bits	long
&	O
RE_NO_BK_PARENS	O
)	O
==	O
0	int
)	O
)	O
goto	O
normal_char	O
;	O
if	O
(	O
parens	int
==	O
0	int
&&	O
syntax_bits	long
&	O
RE_UNMATCHED_RIGHT_PAREN_ORD	O
)	O
goto	O
normal_char	O
;	O
--	O
parens	int
;	O
laststart	int
=	O
0	int
;	O
return	O
lasttok	enum
=	O
RPAREN	int
;	O
case	O
'.'	O
:	O
if	O
(	O
backslash	int
)	O
goto	O
normal_char	O
;	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
)	O
{	O
laststart	int
=	O
0	int
;	O
return	O
lasttok	enum
=	O
ANYCHAR	int
;	O
}	O
zeroset	function
(	O
ccl	array
)	O
;	O
notset	function
(	O
ccl	array
)	O
;	O
if	O
(	O
!	O
(	O
syntax_bits	long
&	O
RE_DOT_NEWLINE	O
)	O
)	O
clrbit	function
(	O
eolbyte	char
,	O
ccl	array
)	O
;	O
if	O
(	O
syntax_bits	long
&	O
RE_DOT_NOT_NULL	O
)	O
clrbit	function
(	O
'\0'	O
,	O
ccl	array
)	O
;	O
laststart	int
=	O
0	int
;	O
return	O
lasttok	enum
=	O
CSET	int
+	O
charclass_index	function
(	O
ccl	array
)	O
;	O
case	O
's'	O
:	O
case	O
'S'	O
:	O
if	O
(	O
!	O
backslash	int
||	O
(	O
syntax_bits	long
&	O
RE_NO_GNU_OPS	O
)	O
)	O
goto	O
normal_char	O
;	O
zeroset	function
(	O
ccl	array
)	O
;	O
for	O
(	O
c2	int
=	O
0	int
;	O
c2	int
<	O
NOTCHAR	O
;	O
++	O
c2	int
)	O
if	O
(	O
isspace	function
(	O
c2	int
)	O
)	O
setbit	function
(	O
c2	int
,	O
ccl	array
)	O
;	O
if	O
(	O
c	array
==	O
'S'	O
)	O
notset	function
(	O
ccl	array
)	O
;	O
laststart	int
=	O
0	int
;	O
return	O
lasttok	enum
=	O
CSET	int
+	O
charclass_index	function
(	O
ccl	array
)	O
;	O
case	O
'w'	O
:	O
case	O
'W'	O
:	O
if	O
(	O
!	O
backslash	int
||	O
(	O
syntax_bits	long
&	O
RE_NO_GNU_OPS	O
)	O
)	O
goto	O
normal_char	O
;	O
zeroset	function
(	O
ccl	array
)	O
;	O
for	O
(	O
c2	int
=	O
0	int
;	O
c2	int
<	O
NOTCHAR	O
;	O
++	O
c2	int
)	O
if	O
(	O
IS_WORD_CONSTITUENT	O
(	O
c2	int
)	O
)	O
setbit	function
(	O
c2	int
,	O
ccl	array
)	O
;	O
if	O
(	O
c	array
==	O
'W'	O
)	O
notset	function
(	O
ccl	array
)	O
;	O
laststart	int
=	O
0	int
;	O
return	O
lasttok	enum
=	O
CSET	int
+	O
charclass_index	function
(	O
ccl	array
)	O
;	O
case	O
'['	O
:	O
if	O
(	O
backslash	int
)	O
goto	O
normal_char	O
;	O
laststart	int
=	O
0	int
;	O
return	O
lasttok	enum
=	O
parse_bracket_exp	function
(	O
)	O
;	O
default	O
:	O
normal_char	O
:	O
laststart	int
=	O
0	int
;	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
)	O
return	O
lasttok	enum
=	O
WCHAR	int
;	O
if	O
(	O
case_fold	int
&&	O
isalpha	function
(	O
c	array
)	O
)	O
{	O
zeroset	function
(	O
ccl	array
)	O
;	O
setbit_case_fold_c	function
(	O
c	array
,	O
ccl	array
)	O
;	O
return	O
lasttok	enum
=	O
CSET	int
+	O
charclass_index	function
(	O
ccl	array
)	O
;	O
}	O
return	O
lasttok	enum
=	O
c	array
;	O
}	O
}	O
abort	function
(	O
)	O
;	O
return	O
END	int
;	O
}	O
static	O
token	enum
tok	enum
;	O
static	O
int	O
depth	int
;	O
static	O
void	O
addtok_mb	function
(	O
token	enum
t	enum
,	O
int	O
mbprop	int
)	O
{	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
)	O
{	O
REALLOC_IF_NECESSARY	O
(	O
dfa	struct
->	O
multibyte_prop	pointer
,	O
int	O
,	O
dfa	struct
->	O
nmultibyte_prop	int
,	O
dfa	struct
->	O
tindex	int
)	O
;	O
dfa	struct
->	O
multibyte_prop	pointer
[	O
dfa	struct
->	O
tindex	int
]	O
=	O
mbprop	int
;	O
}	O
REALLOC_IF_NECESSARY	O
(	O
dfa	struct
->	O
tokens	pointer
,	O
token	enum
,	O
dfa	struct
->	O
talloc	int
,	O
dfa	struct
->	O
tindex	int
)	O
;	O
dfa	struct
->	O
tokens	pointer
[	O
dfa	struct
->	O
tindex	int
++	O
]	O
=	O
t	enum
;	O
switch	O
(	O
t	enum
)	O
{	O
case	O
QMARK	int
:	O
case	O
STAR	int
:	O
case	O
PLUS	int
:	O
break	O
;	O
case	O
CAT	int
:	O
case	O
OR	int
:	O
--	O
depth	int
;	O
break	O
;	O
default	O
:	O
++	O
dfa	struct
->	O
nleaves	int
;	O
case	O
EMPTY	int
:	O
++	O
depth	int
;	O
break	O
;	O
}	O
if	O
(	O
depth	int
>	O
dfa	struct
->	O
depth	int
)	O
dfa	struct
->	O
depth	int
=	O
depth	int
;	O
}	O
static	O
void	O
addtok_wc	function
(	O
wint_t	int
wc	int
)	O
;	O
static	O
void	O
addtok	function
(	O
token	enum
t	enum
)	O
{	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
t	enum
==	O
MBCSET	int
)	O
{	O
bool	bool
need_or	bool
=	O
false	int
;	O
struct	O
mb_char_classes	struct
*	O
work_mbc	pointer
=	O
&	O
dfa	struct
->	O
mbcsets	pointer
[	O
dfa	struct
->	O
nmbcsets	int
-	O
1	int
]	O
;	O
if	O
(	O
!	O
work_mbc	pointer
->	O
invert	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
work_mbc	pointer
->	O
nchars	int
;	O
i	int
++	O
)	O
{	O
addtok_wc	function
(	O
work_mbc	pointer
->	O
chars	pointer
[	O
i	int
]	O
)	O
;	O
if	O
(	O
need_or	bool
)	O
addtok	function
(	O
OR	int
)	O
;	O
need_or	bool
=	O
true	int
;	O
}	O
work_mbc	pointer
->	O
nchars	int
=	O
0	int
;	O
}	O
if	O
(	O
work_mbc	pointer
->	O
invert	int
||	O
(	O
!	O
using_utf8	function
(	O
)	O
&&	O
work_mbc	pointer
->	O
cset	int
!=	O
-	O
1	int
)	O
||	O
work_mbc	pointer
->	O
nchars	int
!=	O
0	int
||	O
work_mbc	pointer
->	O
nch_classes	int
!=	O
0	int
||	O
work_mbc	pointer
->	O
nranges	int
!=	O
0	int
||	O
work_mbc	pointer
->	O
nequivs	int
!=	O
0	int
||	O
work_mbc	pointer
->	O
ncoll_elems	int
!=	O
0	int
)	O
{	O
addtok_mb	function
(	O
MBCSET	int
,	O
(	O
(	O
dfa	struct
->	O
nmbcsets	int
-	O
1	int
)	O
<<	O
2	int
)	O
+	O
3	int
)	O
;	O
if	O
(	O
need_or	bool
)	O
addtok	function
(	O
OR	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
work_mbc	pointer
->	O
cset	int
!=	O
-	O
1	int
)	O
{	O
assert	O
(	O
using_utf8	function
(	O
)	O
)	O
;	O
addtok	function
(	O
CSET	int
+	O
work_mbc	pointer
->	O
cset	int
)	O
;	O
if	O
(	O
need_or	bool
)	O
addtok	function
(	O
OR	int
)	O
;	O
}	O
}	O
}	O
else	O
addtok_mb	function
(	O
t	enum
,	O
3	int
)	O
;	O
}	O
static	O
void	O
addtok_wc	function
(	O
wint_t	int
wc	int
)	O
{	O
unsigned	O
char	O
buf	array
[	O
MB_LEN_MAX	int
]	O
;	O
mbstate_t	struct
s	long
;	O
int	O
i	int
;	O
memset	function
(	O
&	O
s	long
,	O
0	int
,	O
sizeof	O
s	long
)	O
;	O
cur_mb_len	int
=	O
wcrtomb	function
(	O
(	O
char	O
*	O
)	O
buf	array
,	O
wc	int
,	O
&	O
s	long
)	O
;	O
if	O
(	O
cur_mb_len	int
<=	O
0	int
)	O
buf	array
[	O
0	int
]	O
=	O
0	int
;	O
addtok_mb	function
(	O
buf	array
[	O
0	int
]	O
,	O
cur_mb_len	int
==	O
1	int
?	O
3	int
:	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
cur_mb_len	int
;	O
i	int
++	O
)	O
{	O
addtok_mb	function
(	O
buf	array
[	O
i	int
]	O
,	O
i	int
==	O
cur_mb_len	int
-	O
1	int
?	O
2	int
:	O
0	int
)	O
;	O
addtok	function
(	O
CAT	int
)	O
;	O
}	O
}	O
static	O
void	O
add_utf8_anychar	function
(	O
void	O
)	O
{	O
static	O
const	O
charclass	array
utf8_classes	array
[	O
5	int
]	O
=	O
{	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
~	O
0	int
,	O
~	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
~	O
0	int
,	O
~	O
0	int
,	O
~	O
0	int
,	O
~	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0xfffffffcU	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0xffff	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0xff0000	int
}	O
}	O
;	O
const	O
unsigned	O
int	O
n	long
=	O
sizeof	O
(	O
utf8_classes	array
)	O
/	O
sizeof	O
(	O
utf8_classes	array
[	O
0	int
]	O
)	O
;	O
unsigned	O
int	O
i	int
;	O
if	O
(	O
dfa	struct
->	O
utf8_anychar_classes	array
[	O
0	int
]	O
==	O
0	int
)	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	long
;	O
i	int
++	O
)	O
{	O
charclass	array
c	array
;	O
memcpy	function
(	O
c	array
,	O
utf8_classes	array
[	O
i	int
]	O
,	O
sizeof	O
c	array
)	O
;	O
if	O
(	O
i	int
==	O
1	int
)	O
{	O
if	O
(	O
!	O
(	O
syntax_bits	long
&	O
RE_DOT_NEWLINE	O
)	O
)	O
clrbit	function
(	O
eolbyte	char
,	O
c	array
)	O
;	O
if	O
(	O
syntax_bits	long
&	O
RE_DOT_NOT_NULL	O
)	O
clrbit	function
(	O
'\0'	O
,	O
c	array
)	O
;	O
}	O
dfa	struct
->	O
utf8_anychar_classes	array
[	O
i	int
]	O
=	O
CSET	int
+	O
charclass_index	function
(	O
c	array
)	O
;	O
}	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
n	long
;	O
i	int
++	O
)	O
addtok	function
(	O
dfa	struct
->	O
utf8_anychar_classes	array
[	O
i	int
]	O
)	O
;	O
while	O
(	O
--	O
i	int
>	O
1	int
)	O
{	O
addtok	function
(	O
dfa	struct
->	O
utf8_anychar_classes	array
[	O
0	int
]	O
)	O
;	O
addtok	function
(	O
CAT	int
)	O
;	O
addtok	function
(	O
OR	int
)	O
;	O
}	O
}	O
static	O
void	O
atom	function
(	O
void	O
)	O
{	O
if	O
(	O
0	int
)	O
{	O
}	O
else	O
if	O
(	O
tok	enum
==	O
WCHAR	int
)	O
{	O
addtok_wc	function
(	O
case_fold	int
?	O
towlower	function
(	O
wctok	int
)	O
:	O
wctok	int
)	O
;	O
tok	enum
=	O
lex	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
tok	enum
==	O
ANYCHAR	int
&&	O
using_utf8	function
(	O
)	O
)	O
{	O
add_utf8_anychar	function
(	O
)	O
;	O
tok	enum
=	O
lex	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
(	O
tok	enum
>=	O
0	int
&&	O
tok	enum
<	O
NOTCHAR	O
)	O
||	O
tok	enum
>=	O
CSET	int
||	O
tok	enum
==	O
BACKREF	int
||	O
tok	enum
==	O
BEGLINE	int
||	O
tok	enum
==	O
ENDLINE	int
||	O
tok	enum
==	O
BEGWORD	int
||	O
tok	enum
==	O
ANYCHAR	int
||	O
tok	enum
==	O
MBCSET	int
||	O
tok	enum
==	O
ENDWORD	int
||	O
tok	enum
==	O
LIMWORD	int
||	O
tok	enum
==	O
NOTLIMWORD	int
)	O
{	O
addtok	function
(	O
tok	enum
)	O
;	O
tok	enum
=	O
lex	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
tok	enum
==	O
LPAREN	int
)	O
{	O
tok	enum
=	O
lex	function
(	O
)	O
;	O
regexp	function
(	O
)	O
;	O
if	O
(	O
tok	enum
!=	O
RPAREN	int
)	O
dfaerror	function
(	O
_	O
(	O
"unbalanced ("	pointer
)	O
)	O
;	O
tok	enum
=	O
lex	function
(	O
)	O
;	O
}	O
else	O
addtok	function
(	O
EMPTY	int
)	O
;	O
}	O
static	O
int	O
nsubtoks	function
(	O
int	O
tindex	int
)	O
{	O
int	O
ntoks1	int
;	O
switch	O
(	O
dfa	struct
->	O
tokens	pointer
[	O
tindex	int
-	O
1	int
]	O
)	O
{	O
default	O
:	O
return	O
1	int
;	O
case	O
QMARK	int
:	O
case	O
STAR	int
:	O
case	O
PLUS	int
:	O
return	O
1	int
+	O
nsubtoks	function
(	O
tindex	int
-	O
1	int
)	O
;	O
case	O
CAT	int
:	O
case	O
OR	int
:	O
ntoks1	int
=	O
nsubtoks	function
(	O
tindex	int
-	O
1	int
)	O
;	O
return	O
1	int
+	O
ntoks1	int
+	O
nsubtoks	function
(	O
tindex	int
-	O
1	int
-	O
ntoks1	int
)	O
;	O
}	O
}	O
static	O
void	O
copytoks	function
(	O
int	O
tindex	int
,	O
int	O
ntokens	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ntokens	int
;	O
++	O
i	int
)	O
{	O
addtok	function
(	O
dfa	struct
->	O
tokens	pointer
[	O
tindex	int
+	O
i	int
]	O
)	O
;	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
dfa	struct
->	O
tokens	pointer
[	O
tindex	int
+	O
i	int
]	O
==	O
MBCSET	int
)	O
dfa	struct
->	O
multibyte_prop	pointer
[	O
dfa	struct
->	O
tindex	int
-	O
1	int
]	O
=	O
dfa	struct
->	O
multibyte_prop	pointer
[	O
tindex	int
+	O
i	int
]	O
;	O
}	O
}	O
static	O
void	O
closure	function
(	O
void	O
)	O
{	O
int	O
tindex	int
,	O
ntokens	int
,	O
i	int
;	O
atom	function
(	O
)	O
;	O
while	O
(	O
tok	enum
==	O
QMARK	int
||	O
tok	enum
==	O
STAR	int
||	O
tok	enum
==	O
PLUS	int
||	O
tok	enum
==	O
REPMN	int
)	O
if	O
(	O
tok	enum
==	O
REPMN	int
&&	O
(	O
minrep	int
||	O
maxrep	int
)	O
)	O
{	O
ntokens	int
=	O
nsubtoks	function
(	O
dfa	struct
->	O
tindex	int
)	O
;	O
tindex	int
=	O
dfa	struct
->	O
tindex	int
-	O
ntokens	int
;	O
if	O
(	O
maxrep	int
<	O
0	int
)	O
addtok	function
(	O
PLUS	int
)	O
;	O
if	O
(	O
minrep	int
==	O
0	int
)	O
addtok	function
(	O
QMARK	int
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
minrep	int
;	O
++	O
i	int
)	O
{	O
copytoks	function
(	O
tindex	int
,	O
ntokens	int
)	O
;	O
addtok	function
(	O
CAT	int
)	O
;	O
}	O
for	O
(	O
;	O
i	int
<	O
maxrep	int
;	O
++	O
i	int
)	O
{	O
copytoks	function
(	O
tindex	int
,	O
ntokens	int
)	O
;	O
addtok	function
(	O
QMARK	int
)	O
;	O
addtok	function
(	O
CAT	int
)	O
;	O
}	O
tok	enum
=	O
lex	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
tok	enum
==	O
REPMN	int
)	O
{	O
dfa	struct
->	O
tindex	int
-=	O
nsubtoks	function
(	O
dfa	struct
->	O
tindex	int
)	O
;	O
tok	enum
=	O
lex	function
(	O
)	O
;	O
closure	function
(	O
)	O
;	O
}	O
else	O
{	O
addtok	function
(	O
tok	enum
)	O
;	O
tok	enum
=	O
lex	function
(	O
)	O
;	O
}	O
}	O
static	O
void	O
branch	function
(	O
void	O
)	O
{	O
closure	function
(	O
)	O
;	O
while	O
(	O
tok	enum
!=	O
RPAREN	int
&&	O
tok	enum
!=	O
OR	int
&&	O
tok	enum
>=	O
0	int
)	O
{	O
closure	function
(	O
)	O
;	O
addtok	function
(	O
CAT	int
)	O
;	O
}	O
}	O
static	O
void	O
regexp	function
(	O
void	O
)	O
{	O
branch	function
(	O
)	O
;	O
while	O
(	O
tok	enum
==	O
OR	int
)	O
{	O
tok	enum
=	O
lex	function
(	O
)	O
;	O
branch	function
(	O
)	O
;	O
addtok	function
(	O
OR	int
)	O
;	O
}	O
}	O
void	O
dfaparse	function
(	O
char	O
const	O
*	O
s	long
,	O
size_t	long
len	long
,	O
struct	O
dfa	struct
*	O
d	pointer
)	O
{	O
dfa	struct
=	O
d	pointer
;	O
lexptr	pointer
=	O
s	long
;	O
lexleft	int
=	O
len	long
;	O
lasttok	enum
=	O
END	int
;	O
laststart	int
=	O
1	int
;	O
parens	int
=	O
0	int
;	O
hard_LC_COLLATE	int
=	O
hard_locale	function
(	O
LC_COLLATE	O
)	O
;	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
)	O
{	O
cur_mb_len	int
=	O
0	int
;	O
memset	function
(	O
&	O
mbs	struct
,	O
0	int
,	O
sizeof	O
mbs	struct
)	O
;	O
}	O
if	O
(	O
!	O
syntax_bits_set	long
)	O
dfaerror	function
(	O
_	O
(	O
"no syntax specified"	pointer
)	O
)	O
;	O
tok	enum
=	O
lex	function
(	O
)	O
;	O
depth	int
=	O
d	pointer
->	O
depth	int
;	O
regexp	function
(	O
)	O
;	O
if	O
(	O
tok	enum
!=	O
END	int
)	O
dfaerror	function
(	O
_	O
(	O
"unbalanced )"	pointer
)	O
)	O
;	O
addtok	function
(	O
END	int
-	O
d	pointer
->	O
nregexps	int
)	O
;	O
addtok	function
(	O
CAT	int
)	O
;	O
if	O
(	O
d	pointer
->	O
nregexps	int
)	O
addtok	function
(	O
OR	int
)	O
;	O
++	O
d	pointer
->	O
nregexps	int
;	O
}	O
static	O
void	O
copy	function
(	O
position_set	struct
const	O
*	O
src	array
,	O
position_set	struct
*	O
dst	array
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
src	array
->	O
nelem	int
;	O
++	O
i	int
)	O
dst	array
->	O
elems	pointer
[	O
i	int
]	O
=	O
src	array
->	O
elems	pointer
[	O
i	int
]	O
;	O
dst	array
->	O
nelem	int
=	O
src	array
->	O
nelem	int
;	O
}	O
static	O
void	O
insert	function
(	O
position	struct
p	pointer
,	O
position_set	struct
*	O
s	long
)	O
{	O
int	O
count	pointer
=	O
s	long
->	O
nelem	int
;	O
int	O
lo	int
=	O
0	int
,	O
hi	int
=	O
count	pointer
;	O
while	O
(	O
lo	int
<	O
hi	int
)	O
{	O
int	O
mid	int
=	O
(	O
(	O
unsigned	O
)	O
lo	int
+	O
(	O
unsigned	O
)	O
hi	int
)	O
>>	O
1	int
;	O
if	O
(	O
s	long
->	O
elems	pointer
[	O
mid	int
]	O
.	O
index	function
<	O
p	pointer
.	O
index	function
)	O
lo	int
=	O
mid	int
+	O
1	int
;	O
else	O
hi	int
=	O
mid	int
;	O
}	O
if	O
(	O
lo	int
<	O
count	pointer
&&	O
p	pointer
.	O
index	function
==	O
s	long
->	O
elems	pointer
[	O
lo	int
]	O
.	O
index	function
)	O
s	long
->	O
elems	pointer
[	O
lo	int
]	O
.	O
constraint	int
|=	O
p	pointer
.	O
constraint	int
;	O
else	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
count	pointer
;	O
i	int
>	O
lo	int
;	O
i	int
--	O
)	O
s	long
->	O
elems	pointer
[	O
i	int
]	O
=	O
s	long
->	O
elems	pointer
[	O
i	int
-	O
1	int
]	O
;	O
s	long
->	O
elems	pointer
[	O
lo	int
]	O
=	O
p	pointer
;	O
++	O
s	long
->	O
nelem	int
;	O
}	O
}	O
static	O
void	O
merge	function
(	O
position_set	struct
const	O
*	O
s1	pointer
,	O
position_set	struct
const	O
*	O
s2	pointer
,	O
position_set	struct
*	O
m	pointer
)	O
{	O
int	O
i	int
=	O
0	int
,	O
j	int
=	O
0	int
;	O
m	pointer
->	O
nelem	int
=	O
0	int
;	O
while	O
(	O
i	int
<	O
s1	pointer
->	O
nelem	int
&&	O
j	int
<	O
s2	pointer
->	O
nelem	int
)	O
if	O
(	O
s1	pointer
->	O
elems	pointer
[	O
i	int
]	O
.	O
index	function
>	O
s2	pointer
->	O
elems	pointer
[	O
j	int
]	O
.	O
index	function
)	O
m	pointer
->	O
elems	pointer
[	O
m	pointer
->	O
nelem	int
++	O
]	O
=	O
s1	pointer
->	O
elems	pointer
[	O
i	int
++	O
]	O
;	O
else	O
if	O
(	O
s1	pointer
->	O
elems	pointer
[	O
i	int
]	O
.	O
index	function
<	O
s2	pointer
->	O
elems	pointer
[	O
j	int
]	O
.	O
index	function
)	O
m	pointer
->	O
elems	pointer
[	O
m	pointer
->	O
nelem	int
++	O
]	O
=	O
s2	pointer
->	O
elems	pointer
[	O
j	int
++	O
]	O
;	O
else	O
{	O
m	pointer
->	O
elems	pointer
[	O
m	pointer
->	O
nelem	int
]	O
=	O
s1	pointer
->	O
elems	pointer
[	O
i	int
++	O
]	O
;	O
m	pointer
->	O
elems	pointer
[	O
m	pointer
->	O
nelem	int
++	O
]	O
.	O
constraint	int
|=	O
s2	pointer
->	O
elems	pointer
[	O
j	int
++	O
]	O
.	O
constraint	int
;	O
}	O
while	O
(	O
i	int
<	O
s1	pointer
->	O
nelem	int
)	O
m	pointer
->	O
elems	pointer
[	O
m	pointer
->	O
nelem	int
++	O
]	O
=	O
s1	pointer
->	O
elems	pointer
[	O
i	int
++	O
]	O
;	O
while	O
(	O
j	int
<	O
s2	pointer
->	O
nelem	int
)	O
m	pointer
->	O
elems	pointer
[	O
m	pointer
->	O
nelem	int
++	O
]	O
=	O
s2	pointer
->	O
elems	pointer
[	O
j	int
++	O
]	O
;	O
}	O
static	O
void	O
delete	function
(	O
position	struct
p	pointer
,	O
position_set	struct
*	O
s	long
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
s	long
->	O
nelem	int
;	O
++	O
i	int
)	O
if	O
(	O
p	pointer
.	O
index	function
==	O
s	long
->	O
elems	pointer
[	O
i	int
]	O
.	O
index	function
)	O
break	O
;	O
if	O
(	O
i	int
<	O
s	long
->	O
nelem	int
)	O
for	O
(	O
--	O
s	long
->	O
nelem	int
;	O
i	int
<	O
s	long
->	O
nelem	int
;	O
++	O
i	int
)	O
s	long
->	O
elems	pointer
[	O
i	int
]	O
=	O
s	long
->	O
elems	pointer
[	O
i	int
+	O
1	int
]	O
;	O
}	O
static	O
int	O
state_index	function
(	O
struct	O
dfa	struct
*	O
d	pointer
,	O
position_set	struct
const	O
*	O
s	long
,	O
int	O
newline	int
,	O
int	O
letter	char
)	O
{	O
int	O
hash	int
=	O
0	int
;	O
int	O
constraint	int
;	O
int	O
i	int
,	O
j	int
;	O
newline	int
=	O
newline	int
?	O
1	int
:	O
0	int
;	O
letter	char
=	O
letter	char
?	O
1	int
:	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
s	long
->	O
nelem	int
;	O
++	O
i	int
)	O
hash	int
^=	O
s	long
->	O
elems	pointer
[	O
i	int
]	O
.	O
index	function
+	O
s	long
->	O
elems	pointer
[	O
i	int
]	O
.	O
constraint	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
d	pointer
->	O
sindex	int
;	O
++	O
i	int
)	O
{	O
if	O
(	O
hash	int
!=	O
d	pointer
->	O
states	pointer
[	O
i	int
]	O
.	O
hash	int
||	O
s	long
->	O
nelem	int
!=	O
d	pointer
->	O
states	pointer
[	O
i	int
]	O
.	O
elems	pointer
.	O
nelem	int
||	O
newline	int
!=	O
d	pointer
->	O
states	pointer
[	O
i	int
]	O
.	O
newline	int
||	O
letter	char
!=	O
d	pointer
->	O
states	pointer
[	O
i	int
]	O
.	O
letter	char
)	O
continue	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
s	long
->	O
nelem	int
;	O
++	O
j	int
)	O
if	O
(	O
s	long
->	O
elems	pointer
[	O
j	int
]	O
.	O
constraint	int
!=	O
d	pointer
->	O
states	pointer
[	O
i	int
]	O
.	O
elems	pointer
.	O
elems	pointer
[	O
j	int
]	O
.	O
constraint	int
||	O
s	long
->	O
elems	pointer
[	O
j	int
]	O
.	O
index	function
!=	O
d	pointer
->	O
states	pointer
[	O
i	int
]	O
.	O
elems	pointer
.	O
elems	pointer
[	O
j	int
]	O
.	O
index	function
)	O
break	O
;	O
if	O
(	O
j	int
==	O
s	long
->	O
nelem	int
)	O
return	O
i	int
;	O
}	O
REALLOC_IF_NECESSARY	O
(	O
d	pointer
->	O
states	pointer
,	O
dfa_state	struct
,	O
d	pointer
->	O
salloc	int
,	O
d	pointer
->	O
sindex	int
)	O
;	O
d	pointer
->	O
states	pointer
[	O
i	int
]	O
.	O
hash	int
=	O
hash	int
;	O
MALLOC	O
(	O
d	pointer
->	O
states	pointer
[	O
i	int
]	O
.	O
elems	pointer
.	O
elems	pointer
,	O
position	struct
,	O
s	long
->	O
nelem	int
)	O
;	O
copy	function
(	O
s	long
,	O
&	O
d	pointer
->	O
states	pointer
[	O
i	int
]	O
.	O
elems	pointer
)	O
;	O
d	pointer
->	O
states	pointer
[	O
i	int
]	O
.	O
newline	int
=	O
newline	int
;	O
d	pointer
->	O
states	pointer
[	O
i	int
]	O
.	O
letter	char
=	O
letter	char
;	O
d	pointer
->	O
states	pointer
[	O
i	int
]	O
.	O
backref	pointer
=	O
0	int
;	O
d	pointer
->	O
states	pointer
[	O
i	int
]	O
.	O
constraint	int
=	O
0	int
;	O
d	pointer
->	O
states	pointer
[	O
i	int
]	O
.	O
first_end	int
=	O
0	int
;	O
d	pointer
->	O
states	pointer
[	O
i	int
]	O
.	O
mbps	struct
.	O
nelem	int
=	O
0	int
;	O
d	pointer
->	O
states	pointer
[	O
i	int
]	O
.	O
mbps	struct
.	O
elems	pointer
=	O
NULL	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
s	long
->	O
nelem	int
;	O
++	O
j	int
)	O
if	O
(	O
d	pointer
->	O
tokens	pointer
[	O
s	long
->	O
elems	pointer
[	O
j	int
]	O
.	O
index	function
]	O
<	O
0	int
)	O
{	O
constraint	int
=	O
s	long
->	O
elems	pointer
[	O
j	int
]	O
.	O
constraint	int
;	O
if	O
(	O
SUCCEEDS_IN_CONTEXT	O
(	O
constraint	int
,	O
newline	int
,	O
0	int
,	O
letter	char
,	O
0	int
)	O
||	O
SUCCEEDS_IN_CONTEXT	O
(	O
constraint	int
,	O
newline	int
,	O
0	int
,	O
letter	char
,	O
1	int
)	O
||	O
SUCCEEDS_IN_CONTEXT	O
(	O
constraint	int
,	O
newline	int
,	O
1	int
,	O
letter	char
,	O
0	int
)	O
||	O
SUCCEEDS_IN_CONTEXT	O
(	O
constraint	int
,	O
newline	int
,	O
1	int
,	O
letter	char
,	O
1	int
)	O
)	O
d	pointer
->	O
states	pointer
[	O
i	int
]	O
.	O
constraint	int
|=	O
constraint	int
;	O
if	O
(	O
!	O
d	pointer
->	O
states	pointer
[	O
i	int
]	O
.	O
first_end	int
)	O
d	pointer
->	O
states	pointer
[	O
i	int
]	O
.	O
first_end	int
=	O
d	pointer
->	O
tokens	pointer
[	O
s	long
->	O
elems	pointer
[	O
j	int
]	O
.	O
index	function
]	O
;	O
}	O
else	O
if	O
(	O
d	pointer
->	O
tokens	pointer
[	O
s	long
->	O
elems	pointer
[	O
j	int
]	O
.	O
index	function
]	O
==	O
BACKREF	int
)	O
{	O
d	pointer
->	O
states	pointer
[	O
i	int
]	O
.	O
constraint	int
=	O
NO_CONSTRAINT	int
;	O
d	pointer
->	O
states	pointer
[	O
i	int
]	O
.	O
backref	pointer
=	O
1	int
;	O
}	O
++	O
d	pointer
->	O
sindex	int
;	O
return	O
i	int
;	O
}	O
static	O
void	O
epsclosure	function
(	O
position_set	struct
*	O
s	long
,	O
struct	O
dfa	struct
const	O
*	O
d	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
char	O
*	O
visited	pointer
;	O
position	struct
p	pointer
,	O
old	struct
;	O
CALLOC	O
(	O
visited	pointer
,	O
char	O
,	O
d	pointer
->	O
tindex	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
s	long
->	O
nelem	int
;	O
++	O
i	int
)	O
if	O
(	O
d	pointer
->	O
tokens	pointer
[	O
s	long
->	O
elems	pointer
[	O
i	int
]	O
.	O
index	function
]	O
>=	O
NOTCHAR	O
&&	O
d	pointer
->	O
tokens	pointer
[	O
s	long
->	O
elems	pointer
[	O
i	int
]	O
.	O
index	function
]	O
!=	O
BACKREF	int
&&	O
d	pointer
->	O
tokens	pointer
[	O
s	long
->	O
elems	pointer
[	O
i	int
]	O
.	O
index	function
]	O
!=	O
ANYCHAR	int
&&	O
d	pointer
->	O
tokens	pointer
[	O
s	long
->	O
elems	pointer
[	O
i	int
]	O
.	O
index	function
]	O
!=	O
MBCSET	int
&&	O
d	pointer
->	O
tokens	pointer
[	O
s	long
->	O
elems	pointer
[	O
i	int
]	O
.	O
index	function
]	O
<	O
CSET	int
)	O
{	O
old	struct
=	O
s	long
->	O
elems	pointer
[	O
i	int
]	O
;	O
p	pointer
.	O
constraint	int
=	O
old	struct
.	O
constraint	int
;	O
delete	function
(	O
s	long
->	O
elems	pointer
[	O
i	int
]	O
,	O
s	long
)	O
;	O
if	O
(	O
visited	pointer
[	O
old	struct
.	O
index	function
]	O
)	O
{	O
--	O
i	int
;	O
continue	O
;	O
}	O
visited	pointer
[	O
old	struct
.	O
index	function
]	O
=	O
1	int
;	O
switch	O
(	O
d	pointer
->	O
tokens	pointer
[	O
old	struct
.	O
index	function
]	O
)	O
{	O
case	O
BEGLINE	int
:	O
p	pointer
.	O
constraint	int
&=	O
BEGLINE_CONSTRAINT	int
;	O
break	O
;	O
case	O
ENDLINE	int
:	O
p	pointer
.	O
constraint	int
&=	O
ENDLINE_CONSTRAINT	int
;	O
break	O
;	O
case	O
BEGWORD	int
:	O
p	pointer
.	O
constraint	int
&=	O
BEGWORD_CONSTRAINT	int
;	O
break	O
;	O
case	O
ENDWORD	int
:	O
p	pointer
.	O
constraint	int
&=	O
ENDWORD_CONSTRAINT	int
;	O
break	O
;	O
case	O
LIMWORD	int
:	O
p	pointer
.	O
constraint	int
&=	O
LIMWORD_CONSTRAINT	int
;	O
break	O
;	O
case	O
NOTLIMWORD	int
:	O
p	pointer
.	O
constraint	int
&=	O
NOTLIMWORD_CONSTRAINT	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
d	pointer
->	O
follows	pointer
[	O
old	struct
.	O
index	function
]	O
.	O
nelem	int
;	O
++	O
j	int
)	O
{	O
p	pointer
.	O
index	function
=	O
d	pointer
->	O
follows	pointer
[	O
old	struct
.	O
index	function
]	O
.	O
elems	pointer
[	O
j	int
]	O
.	O
index	function
;	O
insert	function
(	O
p	pointer
,	O
s	long
)	O
;	O
}	O
i	int
=	O
-	O
1	int
;	O
}	O
free	function
(	O
visited	pointer
)	O
;	O
}	O
void	O
dfaanalyze	function
(	O
struct	O
dfa	struct
*	O
d	pointer
,	O
int	O
searchflag	int
)	O
{	O
int	O
*	O
nullable	pointer
;	O
int	O
*	O
nfirstpos	pointer
;	O
position	struct
*	O
firstpos	pointer
;	O
int	O
*	O
nlastpos	pointer
;	O
position	struct
*	O
lastpos	pointer
;	O
int	O
*	O
nalloc	pointer
;	O
position_set	struct
tmp	struct
;	O
position_set	struct
merged	struct
;	O
int	O
wants_newline	int
;	O
int	O
*	O
o_nullable	pointer
;	O
int	O
*	O
o_nfirst	pointer
,	O
*	O
o_nlast	pointer
;	O
position	struct
*	O
o_firstpos	pointer
,	O
*	O
o_lastpos	pointer
;	O
int	O
i	int
,	O
j	int
;	O
position	struct
*	O
pos	pointer
;	O
d	pointer
->	O
searchflag	int
=	O
searchflag	int
;	O
MALLOC	O
(	O
nullable	pointer
,	O
int	O
,	O
d	pointer
->	O
depth	int
)	O
;	O
o_nullable	pointer
=	O
nullable	pointer
;	O
MALLOC	O
(	O
nfirstpos	pointer
,	O
int	O
,	O
d	pointer
->	O
depth	int
)	O
;	O
o_nfirst	pointer
=	O
nfirstpos	pointer
;	O
MALLOC	O
(	O
firstpos	pointer
,	O
position	struct
,	O
d	pointer
->	O
nleaves	int
)	O
;	O
o_firstpos	pointer
=	O
firstpos	pointer
,	O
firstpos	pointer
+=	O
d	pointer
->	O
nleaves	int
;	O
MALLOC	O
(	O
nlastpos	pointer
,	O
int	O
,	O
d	pointer
->	O
depth	int
)	O
;	O
o_nlast	pointer
=	O
nlastpos	pointer
;	O
MALLOC	O
(	O
lastpos	pointer
,	O
position	struct
,	O
d	pointer
->	O
nleaves	int
)	O
;	O
o_lastpos	pointer
=	O
lastpos	pointer
,	O
lastpos	pointer
+=	O
d	pointer
->	O
nleaves	int
;	O
CALLOC	O
(	O
nalloc	pointer
,	O
int	O
,	O
d	pointer
->	O
tindex	int
)	O
;	O
MALLOC	O
(	O
merged	struct
.	O
elems	pointer
,	O
position	struct
,	O
2	int
*	O
d	pointer
->	O
nleaves	int
)	O
;	O
CALLOC	O
(	O
d	pointer
->	O
follows	pointer
,	O
position_set	struct
,	O
d	pointer
->	O
tindex	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
d	pointer
->	O
tindex	int
;	O
++	O
i	int
)	O
switch	O
(	O
d	pointer
->	O
tokens	pointer
[	O
i	int
]	O
)	O
{	O
case	O
EMPTY	int
:	O
*	O
nullable	pointer
++	O
=	O
1	int
;	O
*	O
nfirstpos	pointer
++	O
=	O
*	O
nlastpos	pointer
++	O
=	O
0	int
;	O
break	O
;	O
case	O
STAR	int
:	O
case	O
PLUS	int
:	O
tmp	struct
.	O
nelem	int
=	O
nfirstpos	pointer
[	O
-	O
1	int
]	O
;	O
tmp	struct
.	O
elems	pointer
=	O
firstpos	pointer
;	O
pos	pointer
=	O
lastpos	pointer
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
nlastpos	pointer
[	O
-	O
1	int
]	O
;	O
++	O
j	int
)	O
{	O
merge	function
(	O
&	O
tmp	struct
,	O
&	O
d	pointer
->	O
follows	pointer
[	O
pos	pointer
[	O
j	int
]	O
.	O
index	function
]	O
,	O
&	O
merged	struct
)	O
;	O
REALLOC_IF_NECESSARY	O
(	O
d	pointer
->	O
follows	pointer
[	O
pos	pointer
[	O
j	int
]	O
.	O
index	function
]	O
.	O
elems	pointer
,	O
position	struct
,	O
nalloc	pointer
[	O
pos	pointer
[	O
j	int
]	O
.	O
index	function
]	O
,	O
merged	struct
.	O
nelem	int
-	O
1	int
)	O
;	O
copy	function
(	O
&	O
merged	struct
,	O
&	O
d	pointer
->	O
follows	pointer
[	O
pos	pointer
[	O
j	int
]	O
.	O
index	function
]	O
)	O
;	O
}	O
case	O
QMARK	int
:	O
if	O
(	O
d	pointer
->	O
tokens	pointer
[	O
i	int
]	O
!=	O
PLUS	int
)	O
nullable	pointer
[	O
-	O
1	int
]	O
=	O
1	int
;	O
break	O
;	O
case	O
CAT	int
:	O
tmp	struct
.	O
nelem	int
=	O
nfirstpos	pointer
[	O
-	O
1	int
]	O
;	O
tmp	struct
.	O
elems	pointer
=	O
firstpos	pointer
;	O
pos	pointer
=	O
lastpos	pointer
+	O
nlastpos	pointer
[	O
-	O
1	int
]	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
nlastpos	pointer
[	O
-	O
2	int
]	O
;	O
++	O
j	int
)	O
{	O
merge	function
(	O
&	O
tmp	struct
,	O
&	O
d	pointer
->	O
follows	pointer
[	O
pos	pointer
[	O
j	int
]	O
.	O
index	function
]	O
,	O
&	O
merged	struct
)	O
;	O
REALLOC_IF_NECESSARY	O
(	O
d	pointer
->	O
follows	pointer
[	O
pos	pointer
[	O
j	int
]	O
.	O
index	function
]	O
.	O
elems	pointer
,	O
position	struct
,	O
nalloc	pointer
[	O
pos	pointer
[	O
j	int
]	O
.	O
index	function
]	O
,	O
merged	struct
.	O
nelem	int
-	O
1	int
)	O
;	O
copy	function
(	O
&	O
merged	struct
,	O
&	O
d	pointer
->	O
follows	pointer
[	O
pos	pointer
[	O
j	int
]	O
.	O
index	function
]	O
)	O
;	O
}	O
if	O
(	O
nullable	pointer
[	O
-	O
2	int
]	O
)	O
nfirstpos	pointer
[	O
-	O
2	int
]	O
+=	O
nfirstpos	pointer
[	O
-	O
1	int
]	O
;	O
else	O
firstpos	pointer
+=	O
nfirstpos	pointer
[	O
-	O
1	int
]	O
;	O
--	O
nfirstpos	pointer
;	O
if	O
(	O
nullable	pointer
[	O
-	O
1	int
]	O
)	O
nlastpos	pointer
[	O
-	O
2	int
]	O
+=	O
nlastpos	pointer
[	O
-	O
1	int
]	O
;	O
else	O
{	O
pos	pointer
=	O
lastpos	pointer
+	O
nlastpos	pointer
[	O
-	O
2	int
]	O
;	O
for	O
(	O
j	int
=	O
nlastpos	pointer
[	O
-	O
1	int
]	O
-	O
1	int
;	O
j	int
>=	O
0	int
;	O
--	O
j	int
)	O
pos	pointer
[	O
j	int
]	O
=	O
lastpos	pointer
[	O
j	int
]	O
;	O
lastpos	pointer
+=	O
nlastpos	pointer
[	O
-	O
2	int
]	O
;	O
nlastpos	pointer
[	O
-	O
2	int
]	O
=	O
nlastpos	pointer
[	O
-	O
1	int
]	O
;	O
}	O
--	O
nlastpos	pointer
;	O
nullable	pointer
[	O
-	O
2	int
]	O
=	O
nullable	pointer
[	O
-	O
1	int
]	O
&&	O
nullable	pointer
[	O
-	O
2	int
]	O
;	O
--	O
nullable	pointer
;	O
break	O
;	O
case	O
OR	int
:	O
nfirstpos	pointer
[	O
-	O
2	int
]	O
+=	O
nfirstpos	pointer
[	O
-	O
1	int
]	O
;	O
--	O
nfirstpos	pointer
;	O
nlastpos	pointer
[	O
-	O
2	int
]	O
+=	O
nlastpos	pointer
[	O
-	O
1	int
]	O
;	O
--	O
nlastpos	pointer
;	O
nullable	pointer
[	O
-	O
2	int
]	O
=	O
nullable	pointer
[	O
-	O
1	int
]	O
||	O
nullable	pointer
[	O
-	O
2	int
]	O
;	O
--	O
nullable	pointer
;	O
break	O
;	O
default	O
:	O
*	O
nullable	pointer
++	O
=	O
d	pointer
->	O
tokens	pointer
[	O
i	int
]	O
==	O
BACKREF	int
;	O
*	O
nfirstpos	pointer
++	O
=	O
*	O
nlastpos	pointer
++	O
=	O
1	int
;	O
--	O
firstpos	pointer
,	O
--	O
lastpos	pointer
;	O
firstpos	pointer
->	O
index	function
=	O
lastpos	pointer
->	O
index	function
=	O
i	int
;	O
firstpos	pointer
->	O
constraint	int
=	O
lastpos	pointer
->	O
constraint	int
=	O
NO_CONSTRAINT	int
;	O
nalloc	pointer
[	O
i	int
]	O
=	O
1	int
;	O
MALLOC	O
(	O
d	pointer
->	O
follows	pointer
[	O
i	int
]	O
.	O
elems	pointer
,	O
position	struct
,	O
nalloc	pointer
[	O
i	int
]	O
)	O
;	O
break	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
d	pointer
->	O
tindex	int
;	O
++	O
i	int
)	O
if	O
(	O
d	pointer
->	O
tokens	pointer
[	O
i	int
]	O
<	O
NOTCHAR	O
||	O
d	pointer
->	O
tokens	pointer
[	O
i	int
]	O
==	O
BACKREF	int
||	O
d	pointer
->	O
tokens	pointer
[	O
i	int
]	O
==	O
ANYCHAR	int
||	O
d	pointer
->	O
tokens	pointer
[	O
i	int
]	O
==	O
MBCSET	int
||	O
d	pointer
->	O
tokens	pointer
[	O
i	int
]	O
>=	O
CSET	int
)	O
{	O
copy	function
(	O
&	O
d	pointer
->	O
follows	pointer
[	O
i	int
]	O
,	O
&	O
merged	struct
)	O
;	O
epsclosure	function
(	O
&	O
merged	struct
,	O
d	pointer
)	O
;	O
if	O
(	O
d	pointer
->	O
follows	pointer
[	O
i	int
]	O
.	O
nelem	int
<	O
merged	struct
.	O
nelem	int
)	O
REALLOC	O
(	O
d	pointer
->	O
follows	pointer
[	O
i	int
]	O
.	O
elems	pointer
,	O
position	struct
,	O
merged	struct
.	O
nelem	int
)	O
;	O
copy	function
(	O
&	O
merged	struct
,	O
&	O
d	pointer
->	O
follows	pointer
[	O
i	int
]	O
)	O
;	O
}	O
merged	struct
.	O
nelem	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nfirstpos	pointer
[	O
-	O
1	int
]	O
;	O
++	O
i	int
)	O
insert	function
(	O
firstpos	pointer
[	O
i	int
]	O
,	O
&	O
merged	struct
)	O
;	O
epsclosure	function
(	O
&	O
merged	struct
,	O
d	pointer
)	O
;	O
wants_newline	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
merged	struct
.	O
nelem	int
;	O
++	O
i	int
)	O
if	O
(	O
PREV_NEWLINE_DEPENDENT	O
(	O
merged	struct
.	O
elems	pointer
[	O
i	int
]	O
.	O
constraint	int
)	O
)	O
wants_newline	int
=	O
1	int
;	O
d	pointer
->	O
salloc	int
=	O
1	int
;	O
d	pointer
->	O
sindex	int
=	O
0	int
;	O
MALLOC	O
(	O
d	pointer
->	O
states	pointer
,	O
dfa_state	struct
,	O
d	pointer
->	O
salloc	int
)	O
;	O
state_index	function
(	O
d	pointer
,	O
&	O
merged	struct
,	O
wants_newline	int
,	O
0	int
)	O
;	O
free	function
(	O
o_nullable	pointer
)	O
;	O
free	function
(	O
o_nfirst	pointer
)	O
;	O
free	function
(	O
o_firstpos	pointer
)	O
;	O
free	function
(	O
o_nlast	pointer
)	O
;	O
free	function
(	O
o_lastpos	pointer
)	O
;	O
free	function
(	O
nalloc	pointer
)	O
;	O
free	function
(	O
merged	struct
.	O
elems	pointer
)	O
;	O
}	O
void	O
dfastate	function
(	O
int	O
s	long
,	O
struct	O
dfa	struct
*	O
d	pointer
,	O
int	O
trans	pointer
[	O
]	O
)	O
{	O
position_set	struct
*	O
grps	pointer
;	O
charclass	array
*	O
labels	pointer
;	O
int	O
ngrps	int
=	O
0	int
;	O
position	struct
pos	pointer
;	O
charclass	array
matches	array
;	O
int	O
matchesf	int
;	O
charclass	array
intersect	array
;	O
int	O
intersectf	int
;	O
charclass	array
leftovers	array
;	O
int	O
leftoversf	int
;	O
static	O
charclass	array
letters	array
;	O
static	O
charclass	array
newline	int
;	O
position_set	struct
follows	pointer
;	O
position_set	struct
tmp	struct
;	O
int	O
state	pointer
;	O
int	O
wants_newline	int
;	O
int	O
state_newline	int
;	O
int	O
wants_letter	int
;	O
int	O
state_letter	int
;	O
static	O
int	O
initialized	int
;	O
int	O
next_isnt_1st_byte	int
=	O
0	int
;	O
int	O
i	int
,	O
j	int
,	O
k	int
;	O
grps	pointer
=	O
xnmalloc	function
(	O
NOTCHAR	O
,	O
sizeof	O
*	O
grps	pointer
)	O
;	O
labels	pointer
=	O
xnmalloc	function
(	O
NOTCHAR	O
,	O
sizeof	O
*	O
labels	pointer
)	O
;	O
if	O
(	O
!	O
initialized	int
)	O
{	O
initialized	int
=	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NOTCHAR	O
;	O
++	O
i	int
)	O
if	O
(	O
IS_WORD_CONSTITUENT	O
(	O
i	int
)	O
)	O
setbit	function
(	O
i	int
,	O
letters	array
)	O
;	O
setbit	function
(	O
eolbyte	char
,	O
newline	int
)	O
;	O
}	O
zeroset	function
(	O
matches	array
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
d	pointer
->	O
states	pointer
[	O
s	long
]	O
.	O
elems	pointer
.	O
nelem	int
;	O
++	O
i	int
)	O
{	O
pos	pointer
=	O
d	pointer
->	O
states	pointer
[	O
s	long
]	O
.	O
elems	pointer
.	O
elems	pointer
[	O
i	int
]	O
;	O
if	O
(	O
d	pointer
->	O
tokens	pointer
[	O
pos	pointer
.	O
index	function
]	O
>=	O
0	int
&&	O
d	pointer
->	O
tokens	pointer
[	O
pos	pointer
.	O
index	function
]	O
<	O
NOTCHAR	O
)	O
setbit	function
(	O
d	pointer
->	O
tokens	pointer
[	O
pos	pointer
.	O
index	function
]	O
,	O
matches	array
)	O
;	O
else	O
if	O
(	O
d	pointer
->	O
tokens	pointer
[	O
pos	pointer
.	O
index	function
]	O
>=	O
CSET	int
)	O
copyset	function
(	O
d	pointer
->	O
charclasses	pointer
[	O
d	pointer
->	O
tokens	pointer
[	O
pos	pointer
.	O
index	function
]	O
-	O
CSET	int
]	O
,	O
matches	array
)	O
;	O
else	O
if	O
(	O
d	pointer
->	O
tokens	pointer
[	O
pos	pointer
.	O
index	function
]	O
==	O
ANYCHAR	int
||	O
d	pointer
->	O
tokens	pointer
[	O
pos	pointer
.	O
index	function
]	O
==	O
MBCSET	int
)	O
{	O
if	O
(	O
d	pointer
->	O
states	pointer
[	O
s	long
]	O
.	O
mbps	struct
.	O
nelem	int
==	O
0	int
)	O
{	O
MALLOC	O
(	O
d	pointer
->	O
states	pointer
[	O
s	long
]	O
.	O
mbps	struct
.	O
elems	pointer
,	O
position	struct
,	O
d	pointer
->	O
states	pointer
[	O
s	long
]	O
.	O
elems	pointer
.	O
nelem	int
)	O
;	O
}	O
insert	function
(	O
pos	pointer
,	O
&	O
(	O
d	pointer
->	O
states	pointer
[	O
s	long
]	O
.	O
mbps	struct
)	O
)	O
;	O
continue	O
;	O
}	O
else	O
continue	O
;	O
if	O
(	O
pos	pointer
.	O
constraint	int
!=	O
0xFF	int
)	O
{	O
if	O
(	O
!	O
MATCHES_NEWLINE_CONTEXT	O
(	O
pos	pointer
.	O
constraint	int
,	O
d	pointer
->	O
states	pointer
[	O
s	long
]	O
.	O
newline	int
,	O
1	int
)	O
)	O
clrbit	function
(	O
eolbyte	char
,	O
matches	array
)	O
;	O
if	O
(	O
!	O
MATCHES_NEWLINE_CONTEXT	O
(	O
pos	pointer
.	O
constraint	int
,	O
d	pointer
->	O
states	pointer
[	O
s	long
]	O
.	O
newline	int
,	O
0	int
)	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
CHARCLASS_INTS	O
;	O
++	O
j	int
)	O
matches	array
[	O
j	int
]	O
&=	O
newline	int
[	O
j	int
]	O
;	O
if	O
(	O
!	O
MATCHES_LETTER_CONTEXT	O
(	O
pos	pointer
.	O
constraint	int
,	O
d	pointer
->	O
states	pointer
[	O
s	long
]	O
.	O
letter	char
,	O
1	int
)	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
CHARCLASS_INTS	O
;	O
++	O
j	int
)	O
matches	array
[	O
j	int
]	O
&=	O
~	O
letters	array
[	O
j	int
]	O
;	O
if	O
(	O
!	O
MATCHES_LETTER_CONTEXT	O
(	O
pos	pointer
.	O
constraint	int
,	O
d	pointer
->	O
states	pointer
[	O
s	long
]	O
.	O
letter	char
,	O
0	int
)	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
CHARCLASS_INTS	O
;	O
++	O
j	int
)	O
matches	array
[	O
j	int
]	O
&=	O
letters	array
[	O
j	int
]	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
CHARCLASS_INTS	O
&&	O
!	O
matches	array
[	O
j	int
]	O
;	O
++	O
j	int
)	O
continue	O
;	O
if	O
(	O
j	int
==	O
CHARCLASS_INTS	O
)	O
continue	O
;	O
}	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
ngrps	int
;	O
++	O
j	int
)	O
{	O
if	O
(	O
d	pointer
->	O
tokens	pointer
[	O
pos	pointer
.	O
index	function
]	O
>=	O
0	int
&&	O
d	pointer
->	O
tokens	pointer
[	O
pos	pointer
.	O
index	function
]	O
<	O
NOTCHAR	O
&&	O
!	O
tstbit	function
(	O
d	pointer
->	O
tokens	pointer
[	O
pos	pointer
.	O
index	function
]	O
,	O
labels	pointer
[	O
j	int
]	O
)	O
)	O
continue	O
;	O
intersectf	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
CHARCLASS_INTS	O
;	O
++	O
k	int
)	O
(	O
intersect	array
[	O
k	int
]	O
=	O
matches	array
[	O
k	int
]	O
&	O
labels	pointer
[	O
j	int
]	O
[	O
k	int
]	O
)	O
?	O
(	O
intersectf	int
=	O
1	int
)	O
:	O
0	int
;	O
if	O
(	O
!	O
intersectf	int
)	O
continue	O
;	O
leftoversf	int
=	O
matchesf	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
CHARCLASS_INTS	O
;	O
++	O
k	int
)	O
{	O
int	O
match	int
=	O
matches	array
[	O
k	int
]	O
,	O
label	int
=	O
labels	pointer
[	O
j	int
]	O
[	O
k	int
]	O
;	O
(	O
leftovers	array
[	O
k	int
]	O
=	O
~	O
match	int
&	O
label	int
)	O
?	O
(	O
leftoversf	int
=	O
1	int
)	O
:	O
0	int
;	O
(	O
matches	array
[	O
k	int
]	O
=	O
match	int
&	O
~	O
label	int
)	O
?	O
(	O
matchesf	int
=	O
1	int
)	O
:	O
0	int
;	O
}	O
if	O
(	O
leftoversf	int
)	O
{	O
copyset	function
(	O
leftovers	array
,	O
labels	pointer
[	O
ngrps	int
]	O
)	O
;	O
copyset	function
(	O
intersect	array
,	O
labels	pointer
[	O
j	int
]	O
)	O
;	O
MALLOC	O
(	O
grps	pointer
[	O
ngrps	int
]	O
.	O
elems	pointer
,	O
position	struct
,	O
d	pointer
->	O
nleaves	int
)	O
;	O
copy	function
(	O
&	O
grps	pointer
[	O
j	int
]	O
,	O
&	O
grps	pointer
[	O
ngrps	int
]	O
)	O
;	O
++	O
ngrps	int
;	O
}	O
grps	pointer
[	O
j	int
]	O
.	O
elems	pointer
[	O
grps	pointer
[	O
j	int
]	O
.	O
nelem	int
++	O
]	O
=	O
pos	pointer
;	O
if	O
(	O
!	O
matchesf	int
)	O
break	O
;	O
}	O
if	O
(	O
j	int
==	O
ngrps	int
)	O
{	O
copyset	function
(	O
matches	array
,	O
labels	pointer
[	O
ngrps	int
]	O
)	O
;	O
zeroset	function
(	O
matches	array
)	O
;	O
MALLOC	O
(	O
grps	pointer
[	O
ngrps	int
]	O
.	O
elems	pointer
,	O
position	struct
,	O
d	pointer
->	O
nleaves	int
)	O
;	O
grps	pointer
[	O
ngrps	int
]	O
.	O
nelem	int
=	O
1	int
;	O
grps	pointer
[	O
ngrps	int
]	O
.	O
elems	pointer
[	O
0	int
]	O
=	O
pos	pointer
;	O
++	O
ngrps	int
;	O
}	O
}	O
MALLOC	O
(	O
follows	pointer
.	O
elems	pointer
,	O
position	struct
,	O
d	pointer
->	O
nleaves	int
)	O
;	O
MALLOC	O
(	O
tmp	struct
.	O
elems	pointer
,	O
position	struct
,	O
d	pointer
->	O
nleaves	int
)	O
;	O
if	O
(	O
d	pointer
->	O
searchflag	int
)	O
{	O
wants_newline	int
=	O
0	int
;	O
wants_letter	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
d	pointer
->	O
states	pointer
[	O
0	int
]	O
.	O
elems	pointer
.	O
nelem	int
;	O
++	O
i	int
)	O
{	O
if	O
(	O
PREV_NEWLINE_DEPENDENT	O
(	O
d	pointer
->	O
states	pointer
[	O
0	int
]	O
.	O
elems	pointer
.	O
elems	pointer
[	O
i	int
]	O
.	O
constraint	int
)	O
)	O
wants_newline	int
=	O
1	int
;	O
if	O
(	O
PREV_LETTER_DEPENDENT	O
(	O
d	pointer
->	O
states	pointer
[	O
0	int
]	O
.	O
elems	pointer
.	O
elems	pointer
[	O
i	int
]	O
.	O
constraint	int
)	O
)	O
wants_letter	int
=	O
1	int
;	O
}	O
copy	function
(	O
&	O
d	pointer
->	O
states	pointer
[	O
0	int
]	O
.	O
elems	pointer
,	O
&	O
follows	pointer
)	O
;	O
state	pointer
=	O
state_index	function
(	O
d	pointer
,	O
&	O
follows	pointer
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
wants_newline	int
)	O
state_newline	int
=	O
state_index	function
(	O
d	pointer
,	O
&	O
follows	pointer
,	O
1	int
,	O
0	int
)	O
;	O
else	O
state_newline	int
=	O
state	pointer
;	O
if	O
(	O
wants_letter	int
)	O
state_letter	int
=	O
state_index	function
(	O
d	pointer
,	O
&	O
follows	pointer
,	O
0	int
,	O
1	int
)	O
;	O
else	O
state_letter	int
=	O
state	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NOTCHAR	O
;	O
++	O
i	int
)	O
trans	pointer
[	O
i	int
]	O
=	O
(	O
IS_WORD_CONSTITUENT	O
(	O
i	int
)	O
)	O
?	O
state_letter	int
:	O
state	pointer
;	O
trans	pointer
[	O
eolbyte	char
]	O
=	O
state_newline	int
;	O
}	O
else	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NOTCHAR	O
;	O
++	O
i	int
)	O
trans	pointer
[	O
i	int
]	O
=	O
-	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ngrps	int
;	O
++	O
i	int
)	O
{	O
follows	pointer
.	O
nelem	int
=	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
grps	pointer
[	O
i	int
]	O
.	O
nelem	int
;	O
++	O
j	int
)	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
d	pointer
->	O
follows	pointer
[	O
grps	pointer
[	O
i	int
]	O
.	O
elems	pointer
[	O
j	int
]	O
.	O
index	function
]	O
.	O
nelem	int
;	O
++	O
k	int
)	O
insert	function
(	O
d	pointer
->	O
follows	pointer
[	O
grps	pointer
[	O
i	int
]	O
.	O
elems	pointer
[	O
j	int
]	O
.	O
index	function
]	O
.	O
elems	pointer
[	O
k	int
]	O
,	O
&	O
follows	pointer
)	O
;	O
if	O
(	O
d	pointer
->	O
mb_cur_max	int
>	O
1	int
)	O
{	O
next_isnt_1st_byte	int
=	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
follows	pointer
.	O
nelem	int
;	O
++	O
j	int
)	O
{	O
if	O
(	O
!	O
(	O
d	pointer
->	O
multibyte_prop	pointer
[	O
follows	pointer
.	O
elems	pointer
[	O
j	int
]	O
.	O
index	function
]	O
&	O
1	int
)	O
)	O
{	O
next_isnt_1st_byte	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
d	pointer
->	O
searchflag	int
&&	O
(	O
d	pointer
->	O
mb_cur_max	int
==	O
1	int
||	O
!	O
next_isnt_1st_byte	int
)	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
d	pointer
->	O
states	pointer
[	O
0	int
]	O
.	O
elems	pointer
.	O
nelem	int
;	O
++	O
j	int
)	O
insert	function
(	O
d	pointer
->	O
states	pointer
[	O
0	int
]	O
.	O
elems	pointer
.	O
elems	pointer
[	O
j	int
]	O
,	O
&	O
follows	pointer
)	O
;	O
wants_newline	int
=	O
0	int
;	O
if	O
(	O
tstbit	function
(	O
eolbyte	char
,	O
labels	pointer
[	O
i	int
]	O
)	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
follows	pointer
.	O
nelem	int
;	O
++	O
j	int
)	O
if	O
(	O
PREV_NEWLINE_DEPENDENT	O
(	O
follows	pointer
.	O
elems	pointer
[	O
j	int
]	O
.	O
constraint	int
)	O
)	O
wants_newline	int
=	O
1	int
;	O
wants_letter	int
=	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
CHARCLASS_INTS	O
;	O
++	O
j	int
)	O
if	O
(	O
labels	pointer
[	O
i	int
]	O
[	O
j	int
]	O
&	O
letters	array
[	O
j	int
]	O
)	O
break	O
;	O
if	O
(	O
j	int
<	O
CHARCLASS_INTS	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
follows	pointer
.	O
nelem	int
;	O
++	O
j	int
)	O
if	O
(	O
PREV_LETTER_DEPENDENT	O
(	O
follows	pointer
.	O
elems	pointer
[	O
j	int
]	O
.	O
constraint	int
)	O
)	O
wants_letter	int
=	O
1	int
;	O
state	pointer
=	O
state_index	function
(	O
d	pointer
,	O
&	O
follows	pointer
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
wants_newline	int
)	O
state_newline	int
=	O
state_index	function
(	O
d	pointer
,	O
&	O
follows	pointer
,	O
1	int
,	O
0	int
)	O
;	O
else	O
state_newline	int
=	O
state	pointer
;	O
if	O
(	O
wants_letter	int
)	O
state_letter	int
=	O
state_index	function
(	O
d	pointer
,	O
&	O
follows	pointer
,	O
0	int
,	O
1	int
)	O
;	O
else	O
state_letter	int
=	O
state	pointer
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
CHARCLASS_INTS	O
;	O
++	O
j	int
)	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
INTBITS	O
;	O
++	O
k	int
)	O
if	O
(	O
labels	pointer
[	O
i	int
]	O
[	O
j	int
]	O
&	O
1	int
<<	O
k	int
)	O
{	O
int	O
c	array
=	O
j	int
*	O
INTBITS	O
+	O
k	int
;	O
if	O
(	O
c	array
==	O
eolbyte	char
)	O
trans	pointer
[	O
c	array
]	O
=	O
state_newline	int
;	O
else	O
if	O
(	O
IS_WORD_CONSTITUENT	O
(	O
c	array
)	O
)	O
trans	pointer
[	O
c	array
]	O
=	O
state_letter	int
;	O
else	O
if	O
(	O
c	array
<	O
NOTCHAR	O
)	O
trans	pointer
[	O
c	array
]	O
=	O
state	pointer
;	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ngrps	int
;	O
++	O
i	int
)	O
free	function
(	O
grps	pointer
[	O
i	int
]	O
.	O
elems	pointer
)	O
;	O
free	function
(	O
follows	pointer
.	O
elems	pointer
)	O
;	O
free	function
(	O
tmp	struct
.	O
elems	pointer
)	O
;	O
free	function
(	O
grps	pointer
)	O
;	O
free	function
(	O
labels	pointer
)	O
;	O
}	O
static	O
void	O
build_state	function
(	O
int	O
s	long
,	O
struct	O
dfa	struct
*	O
d	pointer
)	O
{	O
int	O
*	O
trans	pointer
;	O
int	O
i	int
;	O
if	O
(	O
d	pointer
->	O
trcount	int
>=	O
1024	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
d	pointer
->	O
tralloc	int
;	O
++	O
i	int
)	O
{	O
free	function
(	O
d	pointer
->	O
trans	pointer
[	O
i	int
]	O
)	O
;	O
free	function
(	O
d	pointer
->	O
fails	pointer
[	O
i	int
]	O
)	O
;	O
d	pointer
->	O
trans	pointer
[	O
i	int
]	O
=	O
d	pointer
->	O
fails	pointer
[	O
i	int
]	O
=	O
NULL	O
;	O
}	O
d	pointer
->	O
trcount	int
=	O
0	int
;	O
}	O
++	O
d	pointer
->	O
trcount	int
;	O
d	pointer
->	O
success	pointer
[	O
s	long
]	O
=	O
0	int
;	O
if	O
(	O
ACCEPTS_IN_CONTEXT	O
(	O
d	pointer
->	O
states	pointer
[	O
s	long
]	O
.	O
newline	int
,	O
1	int
,	O
d	pointer
->	O
states	pointer
[	O
s	long
]	O
.	O
letter	char
,	O
0	int
,	O
s	long
,	O
*	O
d	pointer
)	O
)	O
d	pointer
->	O
success	pointer
[	O
s	long
]	O
|=	O
4	int
;	O
if	O
(	O
ACCEPTS_IN_CONTEXT	O
(	O
d	pointer
->	O
states	pointer
[	O
s	long
]	O
.	O
newline	int
,	O
0	int
,	O
d	pointer
->	O
states	pointer
[	O
s	long
]	O
.	O
letter	char
,	O
1	int
,	O
s	long
,	O
*	O
d	pointer
)	O
)	O
d	pointer
->	O
success	pointer
[	O
s	long
]	O
|=	O
2	int
;	O
if	O
(	O
ACCEPTS_IN_CONTEXT	O
(	O
d	pointer
->	O
states	pointer
[	O
s	long
]	O
.	O
newline	int
,	O
0	int
,	O
d	pointer
->	O
states	pointer
[	O
s	long
]	O
.	O
letter	char
,	O
0	int
,	O
s	long
,	O
*	O
d	pointer
)	O
)	O
d	pointer
->	O
success	pointer
[	O
s	long
]	O
|=	O
1	int
;	O
MALLOC	O
(	O
trans	pointer
,	O
int	O
,	O
NOTCHAR	O
)	O
;	O
dfastate	function
(	O
s	long
,	O
d	pointer
,	O
trans	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NOTCHAR	O
;	O
++	O
i	int
)	O
if	O
(	O
trans	pointer
[	O
i	int
]	O
>=	O
d	pointer
->	O
tralloc	int
)	O
{	O
int	O
oldalloc	int
=	O
d	pointer
->	O
tralloc	int
;	O
while	O
(	O
trans	pointer
[	O
i	int
]	O
>=	O
d	pointer
->	O
tralloc	int
)	O
d	pointer
->	O
tralloc	int
*=	O
2	int
;	O
REALLOC	O
(	O
d	pointer
->	O
realtrans	pointer
,	O
int	O
*	O
,	O
d	pointer
->	O
tralloc	int
+	O
1	int
)	O
;	O
d	pointer
->	O
trans	pointer
=	O
d	pointer
->	O
realtrans	pointer
+	O
1	int
;	O
REALLOC	O
(	O
d	pointer
->	O
fails	pointer
,	O
int	O
*	O
,	O
d	pointer
->	O
tralloc	int
)	O
;	O
REALLOC	O
(	O
d	pointer
->	O
success	pointer
,	O
int	O
,	O
d	pointer
->	O
tralloc	int
)	O
;	O
REALLOC	O
(	O
d	pointer
->	O
newlines	pointer
,	O
int	O
,	O
d	pointer
->	O
tralloc	int
)	O
;	O
while	O
(	O
oldalloc	int
<	O
d	pointer
->	O
tralloc	int
)	O
{	O
d	pointer
->	O
trans	pointer
[	O
oldalloc	int
]	O
=	O
NULL	O
;	O
d	pointer
->	O
fails	pointer
[	O
oldalloc	int
++	O
]	O
=	O
NULL	O
;	O
}	O
}	O
d	pointer
->	O
newlines	pointer
[	O
s	long
]	O
=	O
trans	pointer
[	O
eolbyte	char
]	O
;	O
trans	pointer
[	O
eolbyte	char
]	O
=	O
-	O
1	int
;	O
if	O
(	O
ACCEPTING	O
(	O
s	long
,	O
*	O
d	pointer
)	O
)	O
d	pointer
->	O
fails	pointer
[	O
s	long
]	O
=	O
trans	pointer
;	O
else	O
d	pointer
->	O
trans	pointer
[	O
s	long
]	O
=	O
trans	pointer
;	O
}	O
static	O
void	O
build_state_zero	function
(	O
struct	O
dfa	struct
*	O
d	pointer
)	O
{	O
d	pointer
->	O
tralloc	int
=	O
1	int
;	O
d	pointer
->	O
trcount	int
=	O
0	int
;	O
CALLOC	O
(	O
d	pointer
->	O
realtrans	pointer
,	O
int	O
*	O
,	O
d	pointer
->	O
tralloc	int
+	O
1	int
)	O
;	O
d	pointer
->	O
trans	pointer
=	O
d	pointer
->	O
realtrans	pointer
+	O
1	int
;	O
CALLOC	O
(	O
d	pointer
->	O
fails	pointer
,	O
int	O
*	O
,	O
d	pointer
->	O
tralloc	int
)	O
;	O
MALLOC	O
(	O
d	pointer
->	O
success	pointer
,	O
int	O
,	O
d	pointer
->	O
tralloc	int
)	O
;	O
MALLOC	O
(	O
d	pointer
->	O
newlines	pointer
,	O
int	O
,	O
d	pointer
->	O
tralloc	int
)	O
;	O
build_state	function
(	O
0	int
,	O
d	pointer
)	O
;	O
}	O
static	O
void	O
realloc_trans_if_necessary	function
(	O
struct	O
dfa	struct
*	O
d	pointer
,	O
int	O
new_state	int
)	O
{	O
if	O
(	O
new_state	int
>=	O
d	pointer
->	O
tralloc	int
)	O
{	O
int	O
oldalloc	int
=	O
d	pointer
->	O
tralloc	int
;	O
while	O
(	O
new_state	int
>=	O
d	pointer
->	O
tralloc	int
)	O
d	pointer
->	O
tralloc	int
*=	O
2	int
;	O
REALLOC	O
(	O
d	pointer
->	O
realtrans	pointer
,	O
int	O
*	O
,	O
d	pointer
->	O
tralloc	int
+	O
1	int
)	O
;	O
d	pointer
->	O
trans	pointer
=	O
d	pointer
->	O
realtrans	pointer
+	O
1	int
;	O
REALLOC	O
(	O
d	pointer
->	O
fails	pointer
,	O
int	O
*	O
,	O
d	pointer
->	O
tralloc	int
)	O
;	O
REALLOC	O
(	O
d	pointer
->	O
success	pointer
,	O
int	O
,	O
d	pointer
->	O
tralloc	int
)	O
;	O
REALLOC	O
(	O
d	pointer
->	O
newlines	pointer
,	O
int	O
,	O
d	pointer
->	O
tralloc	int
)	O
;	O
while	O
(	O
oldalloc	int
<	O
d	pointer
->	O
tralloc	int
)	O
{	O
d	pointer
->	O
trans	pointer
[	O
oldalloc	int
]	O
=	O
NULL	O
;	O
d	pointer
->	O
fails	pointer
[	O
oldalloc	int
++	O
]	O
=	O
NULL	O
;	O
}	O
}	O
}	O
typedef	O
enum	O
{	O
TRANSIT_STATE_IN_PROGRESS	int
,	O
TRANSIT_STATE_DONE	int
,	O
TRANSIT_STATE_END_BUFFER	int
}	O
status_transit_state	enum
;	O
static	O
status_transit_state	enum
transit_state_singlebyte	function
(	O
struct	O
dfa	struct
*	O
d	pointer
,	O
int	O
s	long
,	O
unsigned	O
char	O
const	O
*	O
p	pointer
,	O
int	O
*	O
next_state	pointer
)	O
{	O
int	O
*	O
t	enum
;	O
int	O
works	int
=	O
s	long
;	O
status_transit_state	enum
rval	enum
=	O
TRANSIT_STATE_IN_PROGRESS	int
;	O
while	O
(	O
rval	enum
==	O
TRANSIT_STATE_IN_PROGRESS	int
)	O
{	O
if	O
(	O
(	O
t	enum
=	O
d	pointer
->	O
trans	pointer
[	O
works	int
]	O
)	O
!=	O
NULL	O
)	O
{	O
works	int
=	O
t	enum
[	O
*	O
p	pointer
]	O
;	O
rval	enum
=	O
TRANSIT_STATE_DONE	int
;	O
if	O
(	O
works	int
<	O
0	int
)	O
works	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
works	int
<	O
0	int
)	O
{	O
if	O
(	O
p	pointer
==	O
buf_end	pointer
)	O
{	O
abort	function
(	O
)	O
;	O
}	O
works	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
d	pointer
->	O
fails	pointer
[	O
works	int
]	O
)	O
{	O
works	int
=	O
d	pointer
->	O
fails	pointer
[	O
works	int
]	O
[	O
*	O
p	pointer
]	O
;	O
rval	enum
=	O
TRANSIT_STATE_DONE	int
;	O
}	O
else	O
{	O
build_state	function
(	O
works	int
,	O
d	pointer
)	O
;	O
}	O
}	O
*	O
next_state	pointer
=	O
works	int
;	O
return	O
rval	enum
;	O
}	O
static	O
int	O
match_anychar	function
(	O
struct	O
dfa	struct
*	O
d	pointer
,	O
int	O
s	long
,	O
position	struct
pos	pointer
,	O
int	O
idx	int
)	O
{	O
int	O
newline	int
=	O
0	int
;	O
int	O
letter	char
=	O
0	int
;	O
wchar_t	int
wc	int
;	O
int	O
mbclen	int
;	O
wc	int
=	O
inputwcs	pointer
[	O
idx	int
]	O
;	O
mbclen	int
=	O
(	O
mblen_buf	pointer
[	O
idx	int
]	O
==	O
0	int
)	O
?	O
1	int
:	O
mblen_buf	pointer
[	O
idx	int
]	O
;	O
if	O
(	O
wc	int
==	O
(	O
wchar_t	int
)	O
eolbyte	char
)	O
{	O
if	O
(	O
!	O
(	O
syntax_bits	long
&	O
RE_DOT_NEWLINE	O
)	O
)	O
return	O
0	int
;	O
newline	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
wc	int
==	O
(	O
wchar_t	int
)	O
'\0'	O
)	O
{	O
if	O
(	O
syntax_bits	long
&	O
RE_DOT_NOT_NULL	O
)	O
return	O
0	int
;	O
newline	int
=	O
1	int
;	O
}	O
if	O
(	O
iswalnum	function
(	O
wc	int
)	O
||	O
wc	int
==	O
L'_'	O
)	O
letter	char
=	O
1	int
;	O
if	O
(	O
!	O
SUCCEEDS_IN_CONTEXT	O
(	O
pos	pointer
.	O
constraint	int
,	O
d	pointer
->	O
states	pointer
[	O
s	long
]	O
.	O
newline	int
,	O
newline	int
,	O
d	pointer
->	O
states	pointer
[	O
s	long
]	O
.	O
letter	char
,	O
letter	char
)	O
)	O
return	O
0	int
;	O
return	O
mbclen	int
;	O
}	O
static	O
int	O
match_mb_charset	function
(	O
struct	O
dfa	struct
*	O
d	pointer
,	O
int	O
s	long
,	O
position	struct
pos	pointer
,	O
int	O
idx	int
)	O
{	O
int	O
i	int
;	O
int	O
match	int
;	O
int	O
match_len	int
;	O
int	O
op_len	int
;	O
char	O
buffer	pointer
[	O
128	int
]	O
;	O
wchar_t	int
wcbuf	array
[	O
6	int
]	O
;	O
struct	O
mb_char_classes	struct
*	O
work_mbc	pointer
;	O
int	O
newline	int
=	O
0	int
;	O
int	O
letter	char
=	O
0	int
;	O
wchar_t	int
wc	int
;	O
wc	int
=	O
inputwcs	pointer
[	O
idx	int
]	O
;	O
if	O
(	O
wc	int
==	O
(	O
wchar_t	int
)	O
eolbyte	char
)	O
{	O
if	O
(	O
!	O
(	O
syntax_bits	long
&	O
RE_DOT_NEWLINE	O
)	O
)	O
return	O
0	int
;	O
newline	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
wc	int
==	O
(	O
wchar_t	int
)	O
'\0'	O
)	O
{	O
if	O
(	O
syntax_bits	long
&	O
RE_DOT_NOT_NULL	O
)	O
return	O
0	int
;	O
newline	int
=	O
1	int
;	O
}	O
if	O
(	O
iswalnum	function
(	O
wc	int
)	O
||	O
wc	int
==	O
L'_'	O
)	O
letter	char
=	O
1	int
;	O
if	O
(	O
!	O
SUCCEEDS_IN_CONTEXT	O
(	O
pos	pointer
.	O
constraint	int
,	O
d	pointer
->	O
states	pointer
[	O
s	long
]	O
.	O
newline	int
,	O
newline	int
,	O
d	pointer
->	O
states	pointer
[	O
s	long
]	O
.	O
letter	char
,	O
letter	char
)	O
)	O
return	O
0	int
;	O
work_mbc	pointer
=	O
&	O
(	O
d	pointer
->	O
mbcsets	pointer
[	O
(	O
d	pointer
->	O
multibyte_prop	pointer
[	O
pos	pointer
.	O
index	function
]	O
)	O
>>	O
2	int
]	O
)	O
;	O
match	int
=	O
!	O
work_mbc	pointer
->	O
invert	int
;	O
match_len	int
=	O
(	O
mblen_buf	pointer
[	O
idx	int
]	O
==	O
0	int
)	O
?	O
1	int
:	O
mblen_buf	pointer
[	O
idx	int
]	O
;	O
if	O
(	O
wc	int
<	O
NOTCHAR	O
&&	O
work_mbc	pointer
->	O
cset	int
!=	O
-	O
1	int
&&	O
tstbit	function
(	O
(	O
unsigned	O
char	O
)	O
wc	int
,	O
d	pointer
->	O
charclasses	pointer
[	O
work_mbc	pointer
->	O
cset	int
]	O
)	O
)	O
goto	O
charset_matched	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
work_mbc	pointer
->	O
nch_classes	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
iswctype	function
(	O
(	O
wint_t	int
)	O
wc	int
,	O
work_mbc	pointer
->	O
ch_classes	pointer
[	O
i	int
]	O
)	O
)	O
goto	O
charset_matched	O
;	O
}	O
strncpy	function
(	O
buffer	pointer
,	O
(	O
char	O
const	O
*	O
)	O
buf_begin	pointer
+	O
idx	int
,	O
match_len	int
)	O
;	O
buffer	pointer
[	O
match_len	int
]	O
=	O
'\0'	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
work_mbc	pointer
->	O
nequivs	int
;	O
i	int
++	O
)	O
{	O
op_len	int
=	O
strlen	function
(	O
work_mbc	pointer
->	O
equivs	pointer
[	O
i	int
]	O
)	O
;	O
strncpy	function
(	O
buffer	pointer
,	O
(	O
char	O
const	O
*	O
)	O
buf_begin	pointer
+	O
idx	int
,	O
op_len	int
)	O
;	O
buffer	pointer
[	O
op_len	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
strcoll	function
(	O
work_mbc	pointer
->	O
equivs	pointer
[	O
i	int
]	O
,	O
buffer	pointer
)	O
==	O
0	int
)	O
{	O
match_len	int
=	O
op_len	int
;	O
goto	O
charset_matched	O
;	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
work_mbc	pointer
->	O
ncoll_elems	int
;	O
i	int
++	O
)	O
{	O
op_len	int
=	O
strlen	function
(	O
work_mbc	pointer
->	O
coll_elems	pointer
[	O
i	int
]	O
)	O
;	O
strncpy	function
(	O
buffer	pointer
,	O
(	O
char	O
const	O
*	O
)	O
buf_begin	pointer
+	O
idx	int
,	O
op_len	int
)	O
;	O
buffer	pointer
[	O
op_len	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
strcoll	function
(	O
work_mbc	pointer
->	O
coll_elems	pointer
[	O
i	int
]	O
,	O
buffer	pointer
)	O
==	O
0	int
)	O
{	O
match_len	int
=	O
op_len	int
;	O
goto	O
charset_matched	O
;	O
}	O
}	O
wcbuf	array
[	O
0	int
]	O
=	O
wc	int
;	O
wcbuf	array
[	O
1	int
]	O
=	O
wcbuf	array
[	O
3	int
]	O
=	O
wcbuf	array
[	O
5	int
]	O
=	O
'\0'	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
work_mbc	pointer
->	O
nranges	int
;	O
i	int
++	O
)	O
{	O
wcbuf	array
[	O
2	int
]	O
=	O
work_mbc	pointer
->	O
range_sts	pointer
[	O
i	int
]	O
;	O
wcbuf	array
[	O
4	int
]	O
=	O
work_mbc	pointer
->	O
range_ends	pointer
[	O
i	int
]	O
;	O
if	O
(	O
wcscoll	function
(	O
wcbuf	array
,	O
wcbuf	array
+	O
2	int
)	O
>=	O
0	int
&&	O
wcscoll	function
(	O
wcbuf	array
+	O
4	int
,	O
wcbuf	array
)	O
>=	O
0	int
)	O
goto	O
charset_matched	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
work_mbc	pointer
->	O
nchars	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
wc	int
==	O
work_mbc	pointer
->	O
chars	pointer
[	O
i	int
]	O
)	O
goto	O
charset_matched	O
;	O
}	O
match	int
=	O
!	O
match	int
;	O
charset_matched	O
:	O
return	O
match	int
?	O
match_len	int
:	O
0	int
;	O
}	O
static	O
int	O
*	O
check_matching_with_multibyte_ops	function
(	O
struct	O
dfa	struct
*	O
d	pointer
,	O
int	O
s	long
,	O
int	O
idx	int
)	O
{	O
int	O
i	int
;	O
int	O
*	O
rarray	pointer
;	O
MALLOC	O
(	O
rarray	pointer
,	O
int	O
,	O
d	pointer
->	O
states	pointer
[	O
s	long
]	O
.	O
mbps	struct
.	O
nelem	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
d	pointer
->	O
states	pointer
[	O
s	long
]	O
.	O
mbps	struct
.	O
nelem	int
;	O
++	O
i	int
)	O
{	O
position	struct
pos	pointer
=	O
d	pointer
->	O
states	pointer
[	O
s	long
]	O
.	O
mbps	struct
.	O
elems	pointer
[	O
i	int
]	O
;	O
switch	O
(	O
d	pointer
->	O
tokens	pointer
[	O
pos	pointer
.	O
index	function
]	O
)	O
{	O
case	O
ANYCHAR	int
:	O
rarray	pointer
[	O
i	int
]	O
=	O
match_anychar	function
(	O
d	pointer
,	O
s	long
,	O
pos	pointer
,	O
idx	int
)	O
;	O
break	O
;	O
case	O
MBCSET	int
:	O
rarray	pointer
[	O
i	int
]	O
=	O
match_mb_charset	function
(	O
d	pointer
,	O
s	long
,	O
pos	pointer
,	O
idx	int
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
return	O
rarray	pointer
;	O
}	O
static	O
status_transit_state	enum
transit_state_consume_1char	function
(	O
struct	O
dfa	struct
*	O
d	pointer
,	O
int	O
s	long
,	O
unsigned	O
char	O
const	O
*	O
*	O
pp	pointer
,	O
int	O
*	O
match_lens	pointer
,	O
int	O
*	O
mbclen	int
,	O
position_set	struct
*	O
pps	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
s1	pointer
,	O
s2	pointer
;	O
int	O
*	O
work_mbls	pointer
;	O
status_transit_state	enum
rs	enum
=	O
TRANSIT_STATE_DONE	int
;	O
*	O
mbclen	int
=	O
(	O
mblen_buf	pointer
[	O
*	O
pp	pointer
-	O
buf_begin	pointer
]	O
==	O
0	int
)	O
?	O
1	int
:	O
mblen_buf	pointer
[	O
*	O
pp	pointer
-	O
buf_begin	pointer
]	O
;	O
s1	pointer
=	O
s	long
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
*	O
mbclen	int
;	O
i	int
++	O
)	O
{	O
s2	pointer
=	O
s1	pointer
;	O
rs	enum
=	O
transit_state_singlebyte	function
(	O
d	pointer
,	O
s2	pointer
,	O
(	O
*	O
pp	pointer
)	O
++	O
,	O
&	O
s1	pointer
)	O
;	O
}	O
copy	function
(	O
&	O
(	O
d	pointer
->	O
states	pointer
[	O
s1	pointer
]	O
.	O
elems	pointer
)	O
,	O
pps	pointer
)	O
;	O
if	O
(	O
match_lens	pointer
==	O
NULL	O
&&	O
d	pointer
->	O
states	pointer
[	O
s	long
]	O
.	O
mbps	struct
.	O
nelem	int
!=	O
0	int
)	O
work_mbls	pointer
=	O
check_matching_with_multibyte_ops	function
(	O
d	pointer
,	O
s	long
,	O
*	O
pp	pointer
-	O
buf_begin	pointer
)	O
;	O
else	O
work_mbls	pointer
=	O
match_lens	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
d	pointer
->	O
states	pointer
[	O
s	long
]	O
.	O
mbps	struct
.	O
nelem	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
work_mbls	pointer
[	O
i	int
]	O
==	O
*	O
mbclen	int
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
d	pointer
->	O
follows	pointer
[	O
d	pointer
->	O
states	pointer
[	O
s	long
]	O
.	O
mbps	struct
.	O
elems	pointer
[	O
i	int
]	O
.	O
index	function
]	O
.	O
nelem	int
;	O
j	int
++	O
)	O
insert	function
(	O
d	pointer
->	O
follows	pointer
[	O
d	pointer
->	O
states	pointer
[	O
s	long
]	O
.	O
mbps	struct
.	O
elems	pointer
[	O
i	int
]	O
.	O
index	function
]	O
.	O
elems	pointer
[	O
j	int
]	O
,	O
pps	pointer
)	O
;	O
}	O
if	O
(	O
match_lens	pointer
==	O
NULL	O
&&	O
work_mbls	pointer
!=	O
NULL	O
)	O
free	function
(	O
work_mbls	pointer
)	O
;	O
return	O
rs	enum
;	O
}	O
static	O
int	O
transit_state	function
(	O
struct	O
dfa	struct
*	O
d	pointer
,	O
int	O
s	long
,	O
unsigned	O
char	O
const	O
*	O
*	O
pp	pointer
)	O
{	O
int	O
s1	pointer
;	O
int	O
mbclen	int
;	O
int	O
maxlen	int
=	O
0	int
;	O
int	O
i	int
,	O
j	int
;	O
int	O
*	O
match_lens	pointer
=	O
NULL	O
;	O
int	O
nelem	int
=	O
d	pointer
->	O
states	pointer
[	O
s	long
]	O
.	O
mbps	struct
.	O
nelem	int
;	O
position_set	struct
follows	pointer
;	O
unsigned	O
char	O
const	O
*	O
p1	pointer
=	O
*	O
pp	pointer
;	O
wchar_t	int
wc	int
;	O
if	O
(	O
nelem	int
>	O
0	int
)	O
{	O
match_lens	pointer
=	O
check_matching_with_multibyte_ops	function
(	O
d	pointer
,	O
s	long
,	O
*	O
pp	pointer
-	O
buf_begin	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nelem	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
match_lens	pointer
[	O
i	int
]	O
>	O
maxlen	int
)	O
maxlen	int
=	O
match_lens	pointer
[	O
i	int
]	O
;	O
}	O
}	O
if	O
(	O
nelem	int
==	O
0	int
||	O
maxlen	int
==	O
0	int
)	O
{	O
status_transit_state	enum
rs	enum
;	O
rs	enum
=	O
transit_state_singlebyte	function
(	O
d	pointer
,	O
s	long
,	O
*	O
pp	pointer
,	O
&	O
s1	pointer
)	O
;	O
if	O
(	O
rs	enum
==	O
TRANSIT_STATE_DONE	int
)	O
++	O
*	O
pp	pointer
;	O
free	function
(	O
match_lens	pointer
)	O
;	O
return	O
s1	pointer
;	O
}	O
follows	pointer
.	O
nelem	int
=	O
0	int
;	O
MALLOC	O
(	O
follows	pointer
.	O
elems	pointer
,	O
position	struct
,	O
d	pointer
->	O
nleaves	int
)	O
;	O
transit_state_consume_1char	function
(	O
d	pointer
,	O
s	long
,	O
pp	pointer
,	O
match_lens	pointer
,	O
&	O
mbclen	int
,	O
&	O
follows	pointer
)	O
;	O
wc	int
=	O
inputwcs	pointer
[	O
*	O
pp	pointer
-	O
mbclen	int
-	O
buf_begin	pointer
]	O
;	O
s1	pointer
=	O
state_index	function
(	O
d	pointer
,	O
&	O
follows	pointer
,	O
wc	int
==	O
L'\n'	O
,	O
iswalnum	function
(	O
wc	int
)	O
)	O
;	O
realloc_trans_if_necessary	function
(	O
d	pointer
,	O
s1	pointer
)	O
;	O
while	O
(	O
*	O
pp	pointer
-	O
p1	pointer
<	O
maxlen	int
)	O
{	O
follows	pointer
.	O
nelem	int
=	O
0	int
;	O
transit_state_consume_1char	function
(	O
d	pointer
,	O
s1	pointer
,	O
pp	pointer
,	O
NULL	O
,	O
&	O
mbclen	int
,	O
&	O
follows	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nelem	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
match_lens	pointer
[	O
i	int
]	O
==	O
*	O
pp	pointer
-	O
p1	pointer
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
d	pointer
->	O
follows	pointer
[	O
d	pointer
->	O
states	pointer
[	O
s1	pointer
]	O
.	O
mbps	struct
.	O
elems	pointer
[	O
i	int
]	O
.	O
index	function
]	O
.	O
nelem	int
;	O
j	int
++	O
)	O
insert	function
(	O
d	pointer
->	O
follows	pointer
[	O
d	pointer
->	O
states	pointer
[	O
s1	pointer
]	O
.	O
mbps	struct
.	O
elems	pointer
[	O
i	int
]	O
.	O
index	function
]	O
.	O
elems	pointer
[	O
j	int
]	O
,	O
&	O
follows	pointer
)	O
;	O
}	O
wc	int
=	O
inputwcs	pointer
[	O
*	O
pp	pointer
-	O
mbclen	int
-	O
buf_begin	pointer
]	O
;	O
s1	pointer
=	O
state_index	function
(	O
d	pointer
,	O
&	O
follows	pointer
,	O
wc	int
==	O
L'\n'	O
,	O
iswalnum	function
(	O
wc	int
)	O
)	O
;	O
realloc_trans_if_necessary	function
(	O
d	pointer
,	O
s1	pointer
)	O
;	O
}	O
free	function
(	O
match_lens	pointer
)	O
;	O
free	function
(	O
follows	pointer
.	O
elems	pointer
)	O
;	O
return	O
s1	pointer
;	O
}	O
static	O
void	O
prepare_wc_buf	function
(	O
const	O
char	O
*	O
begin	pointer
,	O
const	O
char	O
*	O
end	pointer
)	O
{	O
unsigned	O
char	O
eol	char
=	O
eolbyte	char
;	O
size_t	long
remain_bytes	long
,	O
i	int
;	O
buf_begin	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
begin	pointer
;	O
remain_bytes	long
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
end	pointer
-	O
begin	pointer
+	O
1	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
remain_bytes	long
==	O
0	int
)	O
{	O
remain_bytes	long
=	O
mbrtowc	function
(	O
inputwcs	pointer
+	O
i	int
,	O
begin	pointer
+	O
i	int
,	O
end	pointer
-	O
begin	pointer
-	O
i	int
+	O
1	int
,	O
&	O
mbs	struct
)	O
;	O
if	O
(	O
remain_bytes	long
<	O
1	int
||	O
remain_bytes	long
==	O
(	O
size_t	long
)	O
-	O
1	int
||	O
remain_bytes	long
==	O
(	O
size_t	long
)	O
-	O
2	int
||	O
(	O
remain_bytes	long
==	O
1	int
&&	O
inputwcs	pointer
[	O
i	int
]	O
==	O
(	O
wchar_t	int
)	O
begin	pointer
[	O
i	int
]	O
)	O
)	O
{	O
remain_bytes	long
=	O
0	int
;	O
inputwcs	pointer
[	O
i	int
]	O
=	O
(	O
wchar_t	int
)	O
begin	pointer
[	O
i	int
]	O
;	O
mblen_buf	pointer
[	O
i	int
]	O
=	O
0	int
;	O
if	O
(	O
begin	pointer
[	O
i	int
]	O
==	O
eol	char
)	O
break	O
;	O
}	O
else	O
{	O
mblen_buf	pointer
[	O
i	int
]	O
=	O
remain_bytes	long
;	O
remain_bytes	long
--	O
;	O
}	O
}	O
else	O
{	O
mblen_buf	pointer
[	O
i	int
]	O
=	O
remain_bytes	long
;	O
inputwcs	pointer
[	O
i	int
]	O
=	O
0	int
;	O
remain_bytes	long
--	O
;	O
}	O
}	O
buf_end	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
begin	pointer
+	O
i	int
)	O
;	O
mblen_buf	pointer
[	O
i	int
]	O
=	O
0	int
;	O
inputwcs	pointer
[	O
i	int
]	O
=	O
0	int
;	O
}	O
char	O
*	O
dfaexec	function
(	O
struct	O
dfa	struct
*	O
d	pointer
,	O
char	O
const	O
*	O
begin	pointer
,	O
char	O
*	O
end	pointer
,	O
int	O
newline	int
,	O
int	O
*	O
count	pointer
,	O
int	O
*	O
backref	pointer
)	O
{	O
int	O
s	long
,	O
s1	pointer
,	O
tmp	struct
;	O
unsigned	O
char	O
const	O
*	O
p	pointer
;	O
int	O
*	O
*	O
trans	pointer
,	O
*	O
t	enum
;	O
unsigned	O
char	O
eol	char
=	O
eolbyte	char
;	O
unsigned	O
char	O
saved_end	char
;	O
static	O
int	O
sbit	array
[	O
NOTCHAR	O
]	O
;	O
static	O
int	O
sbit_init	int
;	O
if	O
(	O
!	O
sbit_init	int
)	O
{	O
unsigned	O
int	O
i	int
;	O
sbit_init	int
=	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NOTCHAR	O
;	O
++	O
i	int
)	O
sbit	array
[	O
i	int
]	O
=	O
(	O
IS_WORD_CONSTITUENT	O
(	O
i	int
)	O
)	O
?	O
2	int
:	O
1	int
;	O
sbit	array
[	O
eol	char
]	O
=	O
4	int
;	O
}	O
if	O
(	O
!	O
d	pointer
->	O
tralloc	int
)	O
build_state_zero	function
(	O
d	pointer
)	O
;	O
s	long
=	O
s1	pointer
=	O
0	int
;	O
p	pointer
=	O
(	O
unsigned	O
char	O
const	O
*	O
)	O
begin	pointer
;	O
trans	pointer
=	O
d	pointer
->	O
trans	pointer
;	O
saved_end	char
=	O
*	O
(	O
unsigned	O
char	O
*	O
)	O
end	pointer
;	O
*	O
end	pointer
=	O
eol	char
;	O
if	O
(	O
d	pointer
->	O
mb_cur_max	int
>	O
1	int
)	O
{	O
MALLOC	O
(	O
mblen_buf	pointer
,	O
unsigned	O
char	O
,	O
end	pointer
-	O
begin	pointer
+	O
2	int
)	O
;	O
MALLOC	O
(	O
inputwcs	pointer
,	O
wchar_t	int
,	O
end	pointer
-	O
begin	pointer
+	O
2	int
)	O
;	O
memset	function
(	O
&	O
mbs	struct
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct
)	O
)	O
;	O
prepare_wc_buf	function
(	O
(	O
const	O
char	O
*	O
)	O
p	pointer
,	O
end	pointer
)	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
d	pointer
->	O
mb_cur_max	int
>	O
1	int
)	O
while	O
(	O
(	O
t	enum
=	O
trans	pointer
[	O
s	long
]	O
)	O
)	O
{	O
if	O
(	O
p	pointer
>	O
buf_end	pointer
)	O
break	O
;	O
s1	pointer
=	O
s	long
;	O
SKIP_REMAINS_MB_IF_INITIAL_STATE	O
(	O
s	long
,	O
p	pointer
)	O
;	O
if	O
(	O
d	pointer
->	O
states	pointer
[	O
s	long
]	O
.	O
mbps	struct
.	O
nelem	int
==	O
0	int
)	O
{	O
s	long
=	O
t	enum
[	O
*	O
p	pointer
++	O
]	O
;	O
continue	O
;	O
}	O
if	O
(	O
backref	pointer
)	O
{	O
*	O
backref	pointer
=	O
1	int
;	O
free	function
(	O
mblen_buf	pointer
)	O
;	O
free	function
(	O
inputwcs	pointer
)	O
;	O
*	O
end	pointer
=	O
saved_end	char
;	O
return	O
(	O
char	O
*	O
)	O
p	pointer
;	O
}	O
s	long
=	O
transit_state	function
(	O
d	pointer
,	O
s	long
,	O
&	O
p	pointer
)	O
;	O
trans	pointer
=	O
d	pointer
->	O
trans	pointer
;	O
}	O
else	O
while	O
(	O
(	O
t	enum
=	O
trans	pointer
[	O
s	long
]	O
)	O
!=	O
0	int
)	O
{	O
s1	pointer
=	O
t	enum
[	O
*	O
p	pointer
++	O
]	O
;	O
if	O
(	O
(	O
t	enum
=	O
trans	pointer
[	O
s1	pointer
]	O
)	O
==	O
0	int
)	O
{	O
tmp	struct
=	O
s	long
;	O
s	long
=	O
s1	pointer
;	O
s1	pointer
=	O
tmp	struct
;	O
break	O
;	O
}	O
s	long
=	O
t	enum
[	O
*	O
p	pointer
++	O
]	O
;	O
}	O
if	O
(	O
s	long
>=	O
0	int
&&	O
(	O
char	O
*	O
)	O
p	pointer
<=	O
end	pointer
&&	O
d	pointer
->	O
fails	pointer
[	O
s	long
]	O
)	O
{	O
if	O
(	O
d	pointer
->	O
success	pointer
[	O
s	long
]	O
&	O
sbit	array
[	O
*	O
p	pointer
]	O
)	O
{	O
if	O
(	O
backref	pointer
)	O
*	O
backref	pointer
=	O
(	O
d	pointer
->	O
states	pointer
[	O
s	long
]	O
.	O
backref	pointer
!=	O
0	int
)	O
;	O
if	O
(	O
d	pointer
->	O
mb_cur_max	int
>	O
1	int
)	O
{	O
free	function
(	O
mblen_buf	pointer
)	O
;	O
free	function
(	O
inputwcs	pointer
)	O
;	O
}	O
*	O
end	pointer
=	O
saved_end	char
;	O
return	O
(	O
char	O
*	O
)	O
p	pointer
;	O
}	O
s1	pointer
=	O
s	long
;	O
if	O
(	O
d	pointer
->	O
mb_cur_max	int
>	O
1	int
)	O
{	O
s	long
=	O
transit_state	function
(	O
d	pointer
,	O
s	long
,	O
&	O
p	pointer
)	O
;	O
trans	pointer
=	O
d	pointer
->	O
trans	pointer
;	O
}	O
else	O
s	long
=	O
d	pointer
->	O
fails	pointer
[	O
s	long
]	O
[	O
*	O
p	pointer
++	O
]	O
;	O
continue	O
;	O
}	O
if	O
(	O
(	O
char	O
*	O
)	O
p	pointer
<=	O
end	pointer
&&	O
p	pointer
[	O
-	O
1	int
]	O
==	O
eol	char
)	O
{	O
if	O
(	O
count	pointer
)	O
++	O
*	O
count	pointer
;	O
if	O
(	O
d	pointer
->	O
mb_cur_max	int
>	O
1	int
)	O
prepare_wc_buf	function
(	O
(	O
const	O
char	O
*	O
)	O
p	pointer
,	O
end	pointer
)	O
;	O
}	O
if	O
(	O
(	O
char	O
*	O
)	O
p	pointer
>	O
end	pointer
)	O
{	O
if	O
(	O
d	pointer
->	O
mb_cur_max	int
>	O
1	int
)	O
{	O
free	function
(	O
mblen_buf	pointer
)	O
;	O
free	function
(	O
inputwcs	pointer
)	O
;	O
}	O
*	O
end	pointer
=	O
saved_end	char
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
s	long
>=	O
0	int
)	O
{	O
build_state	function
(	O
s	long
,	O
d	pointer
)	O
;	O
trans	pointer
=	O
d	pointer
->	O
trans	pointer
;	O
continue	O
;	O
}	O
if	O
(	O
p	pointer
[	O
-	O
1	int
]	O
==	O
eol	char
&&	O
newline	int
)	O
{	O
s	long
=	O
d	pointer
->	O
newlines	pointer
[	O
s1	pointer
]	O
;	O
continue	O
;	O
}	O
s	long
=	O
0	int
;	O
}	O
}	O
static	O
void	O
free_mbdata	function
(	O
struct	O
dfa	struct
*	O
d	pointer
)	O
{	O
unsigned	O
int	O
i	int
;	O
free	function
(	O
d	pointer
->	O
multibyte_prop	pointer
)	O
;	O
d	pointer
->	O
multibyte_prop	pointer
=	O
NULL	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
d	pointer
->	O
nmbcsets	int
;	O
++	O
i	int
)	O
{	O
unsigned	O
int	O
j	int
;	O
struct	O
mb_char_classes	struct
*	O
p	pointer
=	O
&	O
(	O
d	pointer
->	O
mbcsets	pointer
[	O
i	int
]	O
)	O
;	O
free	function
(	O
p	pointer
->	O
chars	pointer
)	O
;	O
free	function
(	O
p	pointer
->	O
ch_classes	pointer
)	O
;	O
free	function
(	O
p	pointer
->	O
range_sts	pointer
)	O
;	O
free	function
(	O
p	pointer
->	O
range_ends	pointer
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
p	pointer
->	O
nequivs	int
;	O
++	O
j	int
)	O
free	function
(	O
p	pointer
->	O
equivs	pointer
[	O
j	int
]	O
)	O
;	O
free	function
(	O
p	pointer
->	O
equivs	pointer
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
p	pointer
->	O
ncoll_elems	int
;	O
++	O
j	int
)	O
free	function
(	O
p	pointer
->	O
coll_elems	pointer
[	O
j	int
]	O
)	O
;	O
free	function
(	O
p	pointer
->	O
coll_elems	pointer
)	O
;	O
}	O
free	function
(	O
d	pointer
->	O
mbcsets	pointer
)	O
;	O
d	pointer
->	O
mbcsets	pointer
=	O
NULL	O
;	O
d	pointer
->	O
nmbcsets	int
=	O
0	int
;	O
}	O
void	O
dfainit	function
(	O
struct	O
dfa	struct
*	O
d	pointer
)	O
{	O
memset	function
(	O
d	pointer
,	O
0	int
,	O
sizeof	O
*	O
d	pointer
)	O
;	O
d	pointer
->	O
calloc	function
=	O
1	int
;	O
MALLOC	O
(	O
d	pointer
->	O
charclasses	pointer
,	O
charclass	array
,	O
d	pointer
->	O
calloc	function
)	O
;	O
d	pointer
->	O
talloc	int
=	O
1	int
;	O
MALLOC	O
(	O
d	pointer
->	O
tokens	pointer
,	O
token	enum
,	O
d	pointer
->	O
talloc	int
)	O
;	O
d	pointer
->	O
mb_cur_max	int
=	O
MB_CUR_MAX	O
;	O
if	O
(	O
d	pointer
->	O
mb_cur_max	int
>	O
1	int
)	O
{	O
d	pointer
->	O
nmultibyte_prop	int
=	O
1	int
;	O
MALLOC	O
(	O
d	pointer
->	O
multibyte_prop	pointer
,	O
int	O
,	O
d	pointer
->	O
nmultibyte_prop	int
)	O
;	O
d	pointer
->	O
mbcsets_alloc	int
=	O
1	int
;	O
MALLOC	O
(	O
d	pointer
->	O
mbcsets	pointer
,	O
struct	O
mb_char_classes	struct
,	O
d	pointer
->	O
mbcsets_alloc	int
)	O
;	O
}	O
}	O
static	O
void	O
dfaoptimize	function
(	O
struct	O
dfa	struct
*	O
d	pointer
)	O
{	O
unsigned	O
int	O
i	int
;	O
if	O
(	O
!	O
using_utf8	function
(	O
)	O
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
d	pointer
->	O
tindex	int
;	O
++	O
i	int
)	O
{	O
switch	O
(	O
d	pointer
->	O
tokens	pointer
[	O
i	int
]	O
)	O
{	O
case	O
ANYCHAR	int
:	O
abort	function
(	O
)	O
;	O
case	O
MBCSET	int
:	O
return	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
free_mbdata	function
(	O
d	pointer
)	O
;	O
d	pointer
->	O
mb_cur_max	int
=	O
1	int
;	O
}	O
void	O
dfacomp	function
(	O
char	O
const	O
*	O
s	long
,	O
size_t	long
len	long
,	O
struct	O
dfa	struct
*	O
d	pointer
,	O
int	O
searchflag	int
)	O
{	O
dfainit	function
(	O
d	pointer
)	O
;	O
dfaparse	function
(	O
s	long
,	O
len	long
,	O
d	pointer
)	O
;	O
dfamust	struct
(	O
d	pointer
)	O
;	O
dfaoptimize	function
(	O
d	pointer
)	O
;	O
dfaanalyze	function
(	O
d	pointer
,	O
searchflag	int
)	O
;	O
}	O
void	O
dfafree	function
(	O
struct	O
dfa	struct
*	O
d	pointer
)	O
{	O
int	O
i	int
;	O
struct	O
dfamust	struct
*	O
dm	pointer
,	O
*	O
ndm	pointer
;	O
free	function
(	O
d	pointer
->	O
charclasses	pointer
)	O
;	O
free	function
(	O
d	pointer
->	O
tokens	pointer
)	O
;	O
if	O
(	O
d	pointer
->	O
mb_cur_max	int
>	O
1	int
)	O
free_mbdata	function
(	O
d	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
d	pointer
->	O
sindex	int
;	O
++	O
i	int
)	O
{	O
free	function
(	O
d	pointer
->	O
states	pointer
[	O
i	int
]	O
.	O
elems	pointer
.	O
elems	pointer
)	O
;	O
free	function
(	O
d	pointer
->	O
states	pointer
[	O
i	int
]	O
.	O
mbps	struct
.	O
elems	pointer
)	O
;	O
}	O
free	function
(	O
d	pointer
->	O
states	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
d	pointer
->	O
tindex	int
;	O
++	O
i	int
)	O
free	function
(	O
d	pointer
->	O
follows	pointer
[	O
i	int
]	O
.	O
elems	pointer
)	O
;	O
free	function
(	O
d	pointer
->	O
follows	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
d	pointer
->	O
tralloc	int
;	O
++	O
i	int
)	O
{	O
free	function
(	O
d	pointer
->	O
trans	pointer
[	O
i	int
]	O
)	O
;	O
free	function
(	O
d	pointer
->	O
fails	pointer
[	O
i	int
]	O
)	O
;	O
}	O
free	function
(	O
d	pointer
->	O
realtrans	pointer
)	O
;	O
free	function
(	O
d	pointer
->	O
fails	pointer
)	O
;	O
free	function
(	O
d	pointer
->	O
newlines	pointer
)	O
;	O
free	function
(	O
d	pointer
->	O
success	pointer
)	O
;	O
for	O
(	O
dm	pointer
=	O
d	pointer
->	O
musts	pointer
;	O
dm	pointer
;	O
dm	pointer
=	O
ndm	pointer
)	O
{	O
ndm	pointer
=	O
dm	pointer
->	O
next	pointer
;	O
free	function
(	O
dm	pointer
->	O
must	pointer
)	O
;	O
free	function
(	O
dm	pointer
)	O
;	O
}	O
}	O
static	O
char	O
*	O
icatalloc	function
(	O
char	O
*	O
old	struct
,	O
char	O
const	O
*	O
new	pointer
)	O
{	O
char	O
*	O
result	pointer
;	O
size_t	long
oldsize	long
,	O
newsize	long
;	O
newsize	long
=	O
(	O
new	pointer
==	O
NULL	O
)	O
?	O
0	int
:	O
strlen	function
(	O
new	pointer
)	O
;	O
if	O
(	O
old	struct
==	O
NULL	O
)	O
oldsize	long
=	O
0	int
;	O
else	O
if	O
(	O
newsize	long
==	O
0	int
)	O
return	O
old	struct
;	O
else	O
oldsize	long
=	O
strlen	function
(	O
old	struct
)	O
;	O
if	O
(	O
old	struct
==	O
NULL	O
)	O
result	pointer
=	O
malloc	function
(	O
newsize	long
+	O
1	int
)	O
;	O
else	O
result	pointer
=	O
realloc	function
(	O
old	struct
,	O
oldsize	long
+	O
newsize	long
+	O
1	int
)	O
;	O
if	O
(	O
result	pointer
!=	O
NULL	O
&&	O
new	pointer
!=	O
NULL	O
)	O
strcpy	function
(	O
result	pointer
+	O
oldsize	long
,	O
new	pointer
)	O
;	O
return	O
result	pointer
;	O
}	O
static	O
char	O
*	O
icpyalloc	function
(	O
char	O
const	O
*	O
string	pointer
)	O
{	O
return	O
icatalloc	function
(	O
NULL	O
,	O
string	pointer
)	O
;	O
}	O
static	O
char	O
*	O
istrstr	function
(	O
char	O
const	O
*	O
lookin	pointer
,	O
char	O
const	O
*	O
lookfor	pointer
)	O
{	O
char	O
const	O
*	O
cp	pointer
;	O
size_t	long
len	long
;	O
len	long
=	O
strlen	function
(	O
lookfor	pointer
)	O
;	O
for	O
(	O
cp	pointer
=	O
lookin	pointer
;	O
*	O
cp	pointer
!=	O
'\0'	O
;	O
++	O
cp	pointer
)	O
if	O
(	O
strncmp	function
(	O
cp	pointer
,	O
lookfor	pointer
,	O
len	long
)	O
==	O
0	int
)	O
return	O
(	O
char	O
*	O
)	O
cp	pointer
;	O
return	O
NULL	O
;	O
}	O
static	O
void	O
freelist	function
(	O
char	O
*	O
*	O
cpp	pointer
)	O
{	O
int	O
i	int
;	O
if	O
(	O
cpp	pointer
==	O
NULL	O
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
cpp	pointer
[	O
i	int
]	O
!=	O
NULL	O
;	O
++	O
i	int
)	O
{	O
free	function
(	O
cpp	pointer
[	O
i	int
]	O
)	O
;	O
cpp	pointer
[	O
i	int
]	O
=	O
NULL	O
;	O
}	O
}	O
static	O
char	O
*	O
*	O
enlist	function
(	O
char	O
*	O
*	O
cpp	pointer
,	O
char	O
*	O
new	pointer
,	O
size_t	long
len	long
)	O
{	O
int	O
i	int
,	O
j	int
;	O
if	O
(	O
cpp	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
(	O
new	pointer
=	O
icpyalloc	function
(	O
new	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
freelist	function
(	O
cpp	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
new	pointer
[	O
len	long
]	O
=	O
'\0'	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
cpp	pointer
[	O
i	int
]	O
!=	O
NULL	O
;	O
++	O
i	int
)	O
if	O
(	O
istrstr	function
(	O
cpp	pointer
[	O
i	int
]	O
,	O
new	pointer
)	O
!=	O
NULL	O
)	O
{	O
free	function
(	O
new	pointer
)	O
;	O
return	O
cpp	pointer
;	O
}	O
j	int
=	O
0	int
;	O
while	O
(	O
cpp	pointer
[	O
j	int
]	O
!=	O
NULL	O
)	O
if	O
(	O
istrstr	function
(	O
new	pointer
,	O
cpp	pointer
[	O
j	int
]	O
)	O
==	O
NULL	O
)	O
++	O
j	int
;	O
else	O
{	O
free	function
(	O
cpp	pointer
[	O
j	int
]	O
)	O
;	O
if	O
(	O
--	O
i	int
==	O
j	int
)	O
break	O
;	O
cpp	pointer
[	O
j	int
]	O
=	O
cpp	pointer
[	O
i	int
]	O
;	O
cpp	pointer
[	O
i	int
]	O
=	O
NULL	O
;	O
}	O
cpp	pointer
=	O
xnrealloc	function
(	O
cpp	pointer
,	O
i	int
+	O
2	int
,	O
sizeof	O
*	O
cpp	pointer
)	O
;	O
cpp	pointer
[	O
i	int
]	O
=	O
new	pointer
;	O
cpp	pointer
[	O
i	int
+	O
1	int
]	O
=	O
NULL	O
;	O
return	O
cpp	pointer
;	O
}	O
static	O
char	O
*	O
*	O
comsubs	function
(	O
char	O
*	O
left	pointer
,	O
char	O
const	O
*	O
right	pointer
)	O
{	O
char	O
*	O
*	O
cpp	pointer
;	O
char	O
*	O
lcp	pointer
;	O
char	O
*	O
rcp	pointer
;	O
size_t	long
i	int
,	O
len	long
;	O
if	O
(	O
left	pointer
==	O
NULL	O
||	O
right	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
cpp	pointer
=	O
malloc	function
(	O
sizeof	O
*	O
cpp	pointer
)	O
;	O
if	O
(	O
cpp	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
cpp	pointer
[	O
0	int
]	O
=	O
NULL	O
;	O
for	O
(	O
lcp	pointer
=	O
left	pointer
;	O
*	O
lcp	pointer
!=	O
'\0'	O
;	O
++	O
lcp	pointer
)	O
{	O
len	long
=	O
0	int
;	O
rcp	pointer
=	O
strchr	function
(	O
right	pointer
,	O
*	O
lcp	pointer
)	O
;	O
while	O
(	O
rcp	pointer
!=	O
NULL	O
)	O
{	O
for	O
(	O
i	int
=	O
1	int
;	O
lcp	pointer
[	O
i	int
]	O
!=	O
'\0'	O
&&	O
lcp	pointer
[	O
i	int
]	O
==	O
rcp	pointer
[	O
i	int
]	O
;	O
++	O
i	int
)	O
continue	O
;	O
if	O
(	O
i	int
>	O
len	long
)	O
len	long
=	O
i	int
;	O
rcp	pointer
=	O
strchr	function
(	O
rcp	pointer
+	O
1	int
,	O
*	O
lcp	pointer
)	O
;	O
}	O
if	O
(	O
len	long
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
(	O
cpp	pointer
=	O
enlist	function
(	O
cpp	pointer
,	O
lcp	pointer
,	O
len	long
)	O
)	O
==	O
NULL	O
)	O
break	O
;	O
}	O
return	O
cpp	pointer
;	O
}	O
static	O
char	O
*	O
*	O
addlists	function
(	O
char	O
*	O
*	O
old	struct
,	O
char	O
*	O
*	O
new	pointer
)	O
{	O
int	O
i	int
;	O
if	O
(	O
old	struct
==	O
NULL	O
||	O
new	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
new	pointer
[	O
i	int
]	O
!=	O
NULL	O
;	O
++	O
i	int
)	O
{	O
old	struct
=	O
enlist	function
(	O
old	struct
,	O
new	pointer
[	O
i	int
]	O
,	O
strlen	function
(	O
new	pointer
[	O
i	int
]	O
)	O
)	O
;	O
if	O
(	O
old	struct
==	O
NULL	O
)	O
break	O
;	O
}	O
return	O
old	struct
;	O
}	O
static	O
char	O
*	O
*	O
inboth	function
(	O
char	O
*	O
*	O
left	pointer
,	O
char	O
*	O
*	O
right	pointer
)	O
{	O
char	O
*	O
*	O
both	pointer
;	O
char	O
*	O
*	O
temp	pointer
;	O
int	O
lnum	int
,	O
rnum	int
;	O
if	O
(	O
left	pointer
==	O
NULL	O
||	O
right	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
both	pointer
=	O
malloc	function
(	O
sizeof	O
*	O
both	pointer
)	O
;	O
if	O
(	O
both	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
both	pointer
[	O
0	int
]	O
=	O
NULL	O
;	O
for	O
(	O
lnum	int
=	O
0	int
;	O
left	pointer
[	O
lnum	int
]	O
!=	O
NULL	O
;	O
++	O
lnum	int
)	O
{	O
for	O
(	O
rnum	int
=	O
0	int
;	O
right	pointer
[	O
rnum	int
]	O
!=	O
NULL	O
;	O
++	O
rnum	int
)	O
{	O
temp	pointer
=	O
comsubs	function
(	O
left	pointer
[	O
lnum	int
]	O
,	O
right	pointer
[	O
rnum	int
]	O
)	O
;	O
if	O
(	O
temp	pointer
==	O
NULL	O
)	O
{	O
freelist	function
(	O
both	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
both	pointer
=	O
addlists	function
(	O
both	pointer
,	O
temp	pointer
)	O
;	O
freelist	function
(	O
temp	pointer
)	O
;	O
free	function
(	O
temp	pointer
)	O
;	O
if	O
(	O
both	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
}	O
}	O
return	O
both	pointer
;	O
}	O
typedef	O
struct	O
{	O
char	O
*	O
*	O
in	pointer
;	O
char	O
*	O
left	pointer
;	O
char	O
*	O
right	pointer
;	O
char	O
*	O
is	pointer
;	O
}	O
must	pointer
;	O
static	O
void	O
resetmust	function
(	O
must	pointer
*	O
mp	pointer
)	O
{	O
mp	pointer
->	O
left	pointer
[	O
0	int
]	O
=	O
mp	pointer
->	O
right	pointer
[	O
0	int
]	O
=	O
mp	pointer
->	O
is	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
freelist	function
(	O
mp	pointer
->	O
in	pointer
)	O
;	O
}	O
static	O
void	O
dfamust	struct
(	O
struct	O
dfa	struct
*	O
d	pointer
)	O
{	O
must	pointer
*	O
musts	pointer
;	O
must	pointer
*	O
mp	pointer
;	O
char	O
*	O
result	pointer
;	O
int	O
ri	int
;	O
int	O
i	int
;	O
int	O
exact	int
;	O
token	enum
t	enum
;	O
static	O
must	pointer
must0	struct
;	O
struct	O
dfamust	struct
*	O
dm	pointer
;	O
static	O
char	O
empty_string	array
[	O
]	O
=	O
""	pointer
;	O
result	pointer
=	O
empty_string	array
;	O
exact	int
=	O
0	int
;	O
musts	pointer
=	O
xnmalloc	function
(	O
d	pointer
->	O
tindex	int
+	O
1	int
,	O
sizeof	O
*	O
musts	pointer
)	O
;	O
mp	pointer
=	O
musts	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
d	pointer
->	O
tindex	int
;	O
++	O
i	int
)	O
mp	pointer
[	O
i	int
]	O
=	O
must0	struct
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
d	pointer
->	O
tindex	int
;	O
++	O
i	int
)	O
{	O
mp	pointer
[	O
i	int
]	O
.	O
in	pointer
=	O
malloc	function
(	O
sizeof	O
*	O
mp	pointer
[	O
i	int
]	O
.	O
in	pointer
)	O
;	O
mp	pointer
[	O
i	int
]	O
.	O
left	pointer
=	O
malloc	function
(	O
2	int
)	O
;	O
mp	pointer
[	O
i	int
]	O
.	O
right	pointer
=	O
malloc	function
(	O
2	int
)	O
;	O
mp	pointer
[	O
i	int
]	O
.	O
is	pointer
=	O
malloc	function
(	O
2	int
)	O
;	O
if	O
(	O
mp	pointer
[	O
i	int
]	O
.	O
in	pointer
==	O
NULL	O
||	O
mp	pointer
[	O
i	int
]	O
.	O
left	pointer
==	O
NULL	O
||	O
mp	pointer
[	O
i	int
]	O
.	O
right	pointer
==	O
NULL	O
||	O
mp	pointer
[	O
i	int
]	O
.	O
is	pointer
==	O
NULL	O
)	O
goto	O
done	O
;	O
mp	pointer
[	O
i	int
]	O
.	O
left	pointer
[	O
0	int
]	O
=	O
mp	pointer
[	O
i	int
]	O
.	O
right	pointer
[	O
0	int
]	O
=	O
mp	pointer
[	O
i	int
]	O
.	O
is	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
mp	pointer
[	O
i	int
]	O
.	O
in	pointer
[	O
0	int
]	O
=	O
NULL	O
;	O
}	O
for	O
(	O
ri	int
=	O
0	int
;	O
ri	int
<	O
d	pointer
->	O
tindex	int
;	O
++	O
ri	int
)	O
{	O
switch	O
(	O
t	enum
=	O
d	pointer
->	O
tokens	pointer
[	O
ri	int
]	O
)	O
{	O
case	O
LPAREN	int
:	O
case	O
RPAREN	int
:	O
assert	O
(	O
!	O
"neither LPAREN nor RPAREN may appear here"	pointer
)	O
;	O
case	O
EMPTY	int
:	O
case	O
BEGLINE	int
:	O
case	O
ENDLINE	int
:	O
case	O
BEGWORD	int
:	O
case	O
ENDWORD	int
:	O
case	O
LIMWORD	int
:	O
case	O
NOTLIMWORD	int
:	O
case	O
BACKREF	int
:	O
resetmust	function
(	O
mp	pointer
)	O
;	O
break	O
;	O
case	O
STAR	int
:	O
case	O
QMARK	int
:	O
assert	O
(	O
musts	pointer
<	O
mp	pointer
)	O
;	O
--	O
mp	pointer
;	O
resetmust	function
(	O
mp	pointer
)	O
;	O
break	O
;	O
case	O
OR	int
:	O
assert	O
(	O
&	O
musts	pointer
[	O
2	int
]	O
<=	O
mp	pointer
)	O
;	O
{	O
char	O
*	O
*	O
new	pointer
;	O
must	pointer
*	O
lmp	pointer
;	O
must	pointer
*	O
rmp	pointer
;	O
int	O
j	int
,	O
ln	int
,	O
rn	int
,	O
n	long
;	O
rmp	pointer
=	O
--	O
mp	pointer
;	O
lmp	pointer
=	O
--	O
mp	pointer
;	O
if	O
(	O
!	O
STREQ	O
(	O
lmp	pointer
->	O
is	pointer
,	O
rmp	pointer
->	O
is	pointer
)	O
)	O
lmp	pointer
->	O
is	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
i	int
=	O
0	int
;	O
while	O
(	O
lmp	pointer
->	O
left	pointer
[	O
i	int
]	O
!=	O
'\0'	O
&&	O
lmp	pointer
->	O
left	pointer
[	O
i	int
]	O
==	O
rmp	pointer
->	O
left	pointer
[	O
i	int
]	O
)	O
++	O
i	int
;	O
lmp	pointer
->	O
left	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
ln	int
=	O
strlen	function
(	O
lmp	pointer
->	O
right	pointer
)	O
;	O
rn	int
=	O
strlen	function
(	O
rmp	pointer
->	O
right	pointer
)	O
;	O
n	long
=	O
ln	int
;	O
if	O
(	O
n	long
>	O
rn	int
)	O
n	long
=	O
rn	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	long
;	O
++	O
i	int
)	O
if	O
(	O
lmp	pointer
->	O
right	pointer
[	O
ln	int
-	O
i	int
-	O
1	int
]	O
!=	O
rmp	pointer
->	O
right	pointer
[	O
rn	int
-	O
i	int
-	O
1	int
]	O
)	O
break	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
i	int
;	O
++	O
j	int
)	O
lmp	pointer
->	O
right	pointer
[	O
j	int
]	O
=	O
lmp	pointer
->	O
right	pointer
[	O
(	O
ln	int
-	O
i	int
)	O
+	O
j	int
]	O
;	O
lmp	pointer
->	O
right	pointer
[	O
j	int
]	O
=	O
'\0'	O
;	O
new	pointer
=	O
inboth	function
(	O
lmp	pointer
->	O
in	pointer
,	O
rmp	pointer
->	O
in	pointer
)	O
;	O
if	O
(	O
new	pointer
==	O
NULL	O
)	O
goto	O
done	O
;	O
freelist	function
(	O
lmp	pointer
->	O
in	pointer
)	O
;	O
free	function
(	O
lmp	pointer
->	O
in	pointer
)	O
;	O
lmp	pointer
->	O
in	pointer
=	O
new	pointer
;	O
}	O
break	O
;	O
case	O
PLUS	int
:	O
assert	O
(	O
musts	pointer
<	O
mp	pointer
)	O
;	O
--	O
mp	pointer
;	O
mp	pointer
->	O
is	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
break	O
;	O
case	O
END	int
:	O
assert	O
(	O
mp	pointer
==	O
&	O
musts	pointer
[	O
1	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
musts	pointer
[	O
0	int
]	O
.	O
in	pointer
[	O
i	int
]	O
!=	O
NULL	O
;	O
++	O
i	int
)	O
if	O
(	O
strlen	function
(	O
musts	pointer
[	O
0	int
]	O
.	O
in	pointer
[	O
i	int
]	O
)	O
>	O
strlen	function
(	O
result	pointer
)	O
)	O
result	pointer
=	O
musts	pointer
[	O
0	int
]	O
.	O
in	pointer
[	O
i	int
]	O
;	O
if	O
(	O
STREQ	O
(	O
result	pointer
,	O
musts	pointer
[	O
0	int
]	O
.	O
is	pointer
)	O
)	O
exact	int
=	O
1	int
;	O
goto	O
done	O
;	O
case	O
CAT	int
:	O
assert	O
(	O
&	O
musts	pointer
[	O
2	int
]	O
<=	O
mp	pointer
)	O
;	O
{	O
must	pointer
*	O
lmp	pointer
;	O
must	pointer
*	O
rmp	pointer
;	O
rmp	pointer
=	O
--	O
mp	pointer
;	O
lmp	pointer
=	O
--	O
mp	pointer
;	O
lmp	pointer
->	O
in	pointer
=	O
addlists	function
(	O
lmp	pointer
->	O
in	pointer
,	O
rmp	pointer
->	O
in	pointer
)	O
;	O
if	O
(	O
lmp	pointer
->	O
in	pointer
==	O
NULL	O
)	O
goto	O
done	O
;	O
if	O
(	O
lmp	pointer
->	O
right	pointer
[	O
0	int
]	O
!=	O
'\0'	O
&&	O
rmp	pointer
->	O
left	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
char	O
*	O
tp	pointer
;	O
tp	pointer
=	O
icpyalloc	function
(	O
lmp	pointer
->	O
right	pointer
)	O
;	O
if	O
(	O
tp	pointer
==	O
NULL	O
)	O
goto	O
done	O
;	O
tp	pointer
=	O
icatalloc	function
(	O
tp	pointer
,	O
rmp	pointer
->	O
left	pointer
)	O
;	O
if	O
(	O
tp	pointer
==	O
NULL	O
)	O
goto	O
done	O
;	O
lmp	pointer
->	O
in	pointer
=	O
enlist	function
(	O
lmp	pointer
->	O
in	pointer
,	O
tp	pointer
,	O
strlen	function
(	O
tp	pointer
)	O
)	O
;	O
free	function
(	O
tp	pointer
)	O
;	O
if	O
(	O
lmp	pointer
->	O
in	pointer
==	O
NULL	O
)	O
goto	O
done	O
;	O
}	O
if	O
(	O
lmp	pointer
->	O
is	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
lmp	pointer
->	O
left	pointer
=	O
icatalloc	function
(	O
lmp	pointer
->	O
left	pointer
,	O
rmp	pointer
->	O
left	pointer
)	O
;	O
if	O
(	O
lmp	pointer
->	O
left	pointer
==	O
NULL	O
)	O
goto	O
done	O
;	O
}	O
if	O
(	O
rmp	pointer
->	O
is	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
lmp	pointer
->	O
right	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
lmp	pointer
->	O
right	pointer
=	O
icatalloc	function
(	O
lmp	pointer
->	O
right	pointer
,	O
rmp	pointer
->	O
right	pointer
)	O
;	O
if	O
(	O
lmp	pointer
->	O
right	pointer
==	O
NULL	O
)	O
goto	O
done	O
;	O
if	O
(	O
lmp	pointer
->	O
is	pointer
[	O
0	int
]	O
!=	O
'\0'	O
&&	O
rmp	pointer
->	O
is	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
lmp	pointer
->	O
is	pointer
=	O
icatalloc	function
(	O
lmp	pointer
->	O
is	pointer
,	O
rmp	pointer
->	O
is	pointer
)	O
;	O
if	O
(	O
lmp	pointer
->	O
is	pointer
==	O
NULL	O
)	O
goto	O
done	O
;	O
}	O
else	O
lmp	pointer
->	O
is	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
}	O
break	O
;	O
default	O
:	O
if	O
(	O
t	enum
<	O
END	int
)	O
{	O
assert	O
(	O
!	O
"oops! t >= END"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
t	enum
==	O
'\0'	O
)	O
{	O
goto	O
done	O
;	O
}	O
else	O
if	O
(	O
t	enum
>=	O
CSET	int
||	O
t	enum
==	O
ANYCHAR	int
||	O
t	enum
==	O
MBCSET	int
)	O
{	O
resetmust	function
(	O
mp	pointer
)	O
;	O
}	O
else	O
{	O
resetmust	function
(	O
mp	pointer
)	O
;	O
mp	pointer
->	O
is	pointer
[	O
0	int
]	O
=	O
mp	pointer
->	O
left	pointer
[	O
0	int
]	O
=	O
mp	pointer
->	O
right	pointer
[	O
0	int
]	O
=	O
t	enum
;	O
mp	pointer
->	O
is	pointer
[	O
1	int
]	O
=	O
mp	pointer
->	O
left	pointer
[	O
1	int
]	O
=	O
mp	pointer
->	O
right	pointer
[	O
1	int
]	O
=	O
'\0'	O
;	O
mp	pointer
->	O
in	pointer
=	O
enlist	function
(	O
mp	pointer
->	O
in	pointer
,	O
mp	pointer
->	O
is	pointer
,	O
(	O
size_t	long
)	O
1	int
)	O
;	O
if	O
(	O
mp	pointer
->	O
in	pointer
==	O
NULL	O
)	O
goto	O
done	O
;	O
}	O
break	O
;	O
}	O
++	O
mp	pointer
;	O
}	O
done	O
:	O
if	O
(	O
strlen	function
(	O
result	pointer
)	O
)	O
{	O
MALLOC	O
(	O
dm	pointer
,	O
struct	O
dfamust	struct
,	O
1	int
)	O
;	O
dm	pointer
->	O
exact	int
=	O
exact	int
;	O
MALLOC	O
(	O
dm	pointer
->	O
must	pointer
,	O
char	O
,	O
strlen	function
(	O
result	pointer
)	O
+	O
1	int
)	O
;	O
strcpy	function
(	O
dm	pointer
->	O
must	pointer
,	O
result	pointer
)	O
;	O
dm	pointer
->	O
next	pointer
=	O
d	pointer
->	O
musts	pointer
;	O
d	pointer
->	O
musts	pointer
=	O
dm	pointer
;	O
}	O
mp	pointer
=	O
musts	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
d	pointer
->	O
tindex	int
;	O
++	O
i	int
)	O
{	O
freelist	function
(	O
mp	pointer
[	O
i	int
]	O
.	O
in	pointer
)	O
;	O
free	function
(	O
mp	pointer
[	O
i	int
]	O
.	O
in	pointer
)	O
;	O
free	function
(	O
mp	pointer
[	O
i	int
]	O
.	O
left	pointer
)	O
;	O
free	function
(	O
mp	pointer
[	O
i	int
]	O
.	O
right	pointer
)	O
;	O
free	function
(	O
mp	pointer
[	O
i	int
]	O
.	O
is	pointer
)	O
;	O
}	O
free	function
(	O
mp	pointer
)	O
;	O
}	O
struct	O
dfa	struct
*	O
dfaalloc	function
(	O
void	O
)	O
{	O
return	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
dfa	struct
)	O
)	O
;	O
}	O
struct	O
dfamust	struct
*	O
dfamusts	function
(	O
struct	O
dfa	struct
const	O
*	O
d	pointer
)	O
{	O
return	O
d	pointer
->	O
musts	pointer
;	O
}	O
