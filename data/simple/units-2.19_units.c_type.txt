char	O
*	O
exit_commands	array
[	O
]	O
=	O
{	O
"quit"	pointer
,	O
"exit"	pointer
,	O
0	int
}	O
;	O
char	O
*	O
all_commands	array
[	O
]	O
=	O
{	O
"quit"	pointer
,	O
"exit"	pointer
,	O
HELPCOMMAND	pointer
,	O
SEARCHCOMMAND	pointer
,	O
UNITMATCH	pointer
,	O
0	int
}	O
;	O
struct	O
{	O
char	O
*	O
word	pointer
;	O
char	O
delimit	char
;	O
int	O
checkopen	int
;	O
}	O
fnkeywords	array
[	O
]	O
=	O
{	O
{	O
"units="	pointer
,	O
FUNCSEPCHAR	char
,	O
0	int
}	O
,	O
{	O
"domain="	pointer
,	O
','	O
,	O
1	int
}	O
,	O
{	O
"range="	pointer
,	O
','	O
,	O
1	int
}	O
,	O
{	O
NOERROR_KEYWORD	pointer
,	O
' '	O
,	O
CO_NOARG	O
}	O
,	O
{	O
0	int
,	O
0	int
}	O
}	O
;	O
char	O
*	O
builtins	array
[	O
]	O
=	O
{	O
"sin"	pointer
,	O
"cos"	pointer
,	O
"tan"	pointer
,	O
"ln"	pointer
,	O
"log"	pointer
,	O
"exp"	pointer
,	O
"acos"	pointer
,	O
"atan"	pointer
,	O
"asin"	pointer
,	O
"sqrt"	pointer
,	O
"cuberoot"	pointer
,	O
"per"	pointer
,	O
"sinh"	pointer
,	O
"cosh"	pointer
,	O
"tanh"	pointer
,	O
"asinh"	pointer
,	O
"atanh"	pointer
,	O
"acosh"	pointer
,	O
0	int
}	O
;	O
struct	O
{	O
char	O
*	O
format	pointer
;	O
int	O
width	int
;	O
int	O
precision	int
;	O
char	O
type	char
;	O
}	O
num_format	struct
;	O
struct	O
{	O
int	O
unitlists	int
,	O
oneline	int
,	O
quiet	int
,	O
round	int
,	O
showfactor	int
,	O
strictconvert	int
,	O
unitcheck	int
,	O
verbose	int
,	O
readline	int
;	O
}	O
flags	struct
;	O
struct	O
parseflag	O
parserflags	struct
;	O
char	O
*	O
homeunitsfile	pointer
=	O
".units"	pointer
;	O
char	O
*	O
pager	pointer
;	O
char	O
*	O
mylocale	pointer
;	O
int	O
utf8mode	int
;	O
char	O
*	O
powerstring	pointer
=	O
"^"	pointer
;	O
char	O
*	O
unitsfiles	array
[	O
MAXFILES	int
+	O
1	int
]	O
;	O
char	O
*	O
logfilename	pointer
=	O
0	int
;	O
FILE	O
*	O
logfile	pointer
=	O
0	int
;	O
char	O
*	O
promptprefix	pointer
=	O
0	int
;	O
char	O
*	O
progname	pointer
;	O
char	O
*	O
fullprogname	pointer
;	O
char	O
*	O
progdir	pointer
;	O
char	O
*	O
datadir	pointer
;	O
char	O
*	O
deftext	pointer
=	O
"        Definition: "	pointer
;	O
char	O
*	O
digits	pointer
=	O
"0123456789.,"	pointer
;	O
char	O
*	O
errormsg	array
[	O
]	O
=	O
{	O
"Successful completion"	pointer
,	O
"Parse error"	pointer
,	O
"Product overflow"	pointer
,	O
"Unit reduction error (bad unit definition)"	pointer
,	O
"Invalid sum or difference of non-conformable units"	pointer
,	O
"Unit not dimensionless"	pointer
,	O
"Unit not a root"	pointer
,	O
"Unknown unit"	pointer
,	O
"Bad argument"	pointer
,	O
"Weird nonlinear unit type (bug in program)"	pointer
,	O
"Function argument has wrong dimension"	pointer
,	O
"Argument of function outside domain"	pointer
,	O
"Nonlinear unit definition has unit error"	pointer
,	O
"No inverse defined"	pointer
,	O
"Parser memory overflow (recursive function definition?)"	pointer
,	O
"Argument wrong dimension or bad nonlinear unit definition"	pointer
,	O
"Cannot open units file"	pointer
,	O
"Units file contains errors"	pointer
,	O
"Memory allocation error"	pointer
,	O
"Malformed number"	pointer
,	O
"Unit name ends with nonzero digit without preceding '_'"	pointer
,	O
"No previous result; '_' not set"	pointer
,	O
"Base unit not dimensionless; rational exponent required"	pointer
,	O
"Base unit not a root"	pointer
,	O
"Exponent not dimensionless"	pointer
,	O
"Unknown function name"	pointer
,	O
}	O
;	O
char	O
*	O
invalid_utf8	pointer
=	O
"invalid/nonprinting UTF-8"	pointer
;	O
char	O
*	O
irreducible	pointer
=	O
0	int
;	O
struct	O
unitlist	struct
{	O
char	O
*	O
name	pointer
;	O
char	O
*	O
value	pointer
;	O
int	O
linenumber	int
;	O
char	O
*	O
file	pointer
;	O
struct	O
unitlist	struct
*	O
next	pointer
;	O
}	O
*	O
utab	array
[	O
HASHSIZE	int
]	O
;	O
struct	O
prefixlist	struct
{	O
int	O
len	int
;	O
char	O
*	O
name	pointer
;	O
char	O
*	O
value	pointer
;	O
int	O
linenumber	int
;	O
char	O
*	O
file	pointer
;	O
struct	O
prefixlist	struct
*	O
next	pointer
;	O
}	O
*	O
ptab	array
[	O
SIMPLEHASHSIZE	int
]	O
;	O
struct	O
wantalias	struct
{	O
char	O
*	O
name	pointer
;	O
char	O
*	O
definition	pointer
;	O
struct	O
wantalias	struct
*	O
next	pointer
;	O
int	O
linenumber	int
;	O
char	O
*	O
file	pointer
;	O
}	O
;	O
struct	O
wantalias	struct
*	O
firstalias	pointer
=	O
0	int
;	O
struct	O
wantalias	struct
*	O
*	O
aliaslistend	pointer
=	O
&	O
firstalias	pointer
;	O
struct	O
func	pointer
*	O
ftab	array
[	O
SIMPLEHASHSIZE	int
]	O
;	O
char	O
*	O
function_parameter	pointer
=	O
0	int
;	O
struct	O
unittype	O
*	O
parameter_value	pointer
=	O
0	int
;	O
int	O
lastunitset	int
=	O
0	int
;	O
struct	O
unittype	O
lastunit	struct
;	O
char	O
*	O
NULLUNIT	pointer
=	O
""	pointer
;	O
void	O
growbuffer	function
(	O
char	O
*	O
*	O
buf	pointer
,	O
int	O
*	O
bufsize	pointer
)	O
{	O
int	O
usemalloc	int
;	O
usemalloc	int
=	O
!	O
*	O
buf	pointer
||	O
!	O
*	O
bufsize	pointer
;	O
*	O
bufsize	pointer
+=	O
BUFGROW	int
;	O
if	O
(	O
usemalloc	int
)	O
*	O
buf	pointer
=	O
malloc	O
(	O
*	O
bufsize	pointer
)	O
;	O
else	O
*	O
buf	pointer
=	O
realloc	O
(	O
*	O
buf	pointer
,	O
*	O
bufsize	pointer
)	O
;	O
if	O
(	O
!	O
*	O
buf	pointer
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"%s: memory allocation error (growbuffer)\n"	pointer
,	O
progname	pointer
)	O
;	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
}	O
}	O
void	O
logprintf	function
(	O
const	O
char	O
*	O
format	pointer
,	O
...	O
)	O
{	O
va_list	O
args	O
;	O
va_start	O
(	O
args	O
,	O
format	pointer
)	O
;	O
vprintf	O
(	O
format	pointer
,	O
args	O
)	O
;	O
va_end	O
(	O
args	O
)	O
;	O
if	O
(	O
logfile	pointer
)	O
{	O
va_start	O
(	O
args	O
,	O
format	pointer
)	O
;	O
vfprintf	function
(	O
logfile	pointer
,	O
format	pointer
,	O
args	O
)	O
;	O
va_end	O
(	O
args	O
)	O
;	O
}	O
}	O
void	O
logputchar	function
(	O
char	O
c	char
)	O
{	O
putchar	function
(	O
c	char
)	O
;	O
if	O
(	O
logfile	pointer
)	O
fputc	function
(	O
c	char
,	O
logfile	pointer
)	O
;	O
}	O
void	O
logputs	function
(	O
const	O
char	O
*	O
s	pointer
)	O
{	O
fputs	function
(	O
s	pointer
,	O
stdout	O
)	O
;	O
if	O
(	O
logfile	pointer
)	O
fputs	function
(	O
s	pointer
,	O
logfile	pointer
)	O
;	O
}	O
int	O
hassubscript	function
(	O
const	O
char	O
*	O
str	pointer
)	O
{	O
const	O
char	O
*	O
ptr	pointer
=	O
&	O
lastchar	O
(	O
str	pointer
)	O
;	O
while	O
(	O
ptr	pointer
>	O
str	pointer
)	O
{	O
if	O
(	O
!	O
strchr	O
(	O
digits	pointer
,	O
*	O
ptr	pointer
)	O
)	O
return	O
0	int
;	O
ptr	pointer
--	O
;	O
if	O
(	O
*	O
ptr	pointer
==	O
'_'	O
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
replace_minus	function
(	O
char	O
*	O
input	pointer
)	O
{	O
char	O
*	O
unicode_minus	array
[	O
]	O
=	O
{	O
"\xE2\x80\x92"	pointer
,	O
"\xE2\x80\x93"	pointer
,	O
"\xE2\x88\x92"	pointer
,	O
0	int
}	O
;	O
char	O
*	O
inptr	pointer
,	O
*	O
outptr	pointer
,	O
*	O
ptr	pointer
,	O
*	O
*	O
minus	pointer
;	O
for	O
(	O
minus	pointer
=	O
unicode_minus	array
;	O
*	O
minus	pointer
;	O
minus	pointer
++	O
)	O
{	O
inptr	pointer
=	O
outptr	pointer
=	O
input	pointer
;	O
do	O
{	O
ptr	pointer
=	O
strstr	O
(	O
inptr	pointer
,	O
*	O
minus	pointer
)	O
;	O
if	O
(	O
ptr	pointer
)	O
{	O
while	O
(	O
inptr	pointer
<	O
ptr	pointer
)	O
*	O
outptr	pointer
++	O
=	O
*	O
inptr	pointer
++	O
;	O
*	O
outptr	pointer
++	O
=	O
'-'	O
;	O
inptr	pointer
=	O
ptr	pointer
+	O
strlen	O
(	O
*	O
minus	pointer
)	O
;	O
}	O
}	O
while	O
(	O
ptr	pointer
)	O
;	O
if	O
(	O
inptr	pointer
>	O
input	pointer
)	O
{	O
while	O
(	O
*	O
inptr	pointer
)	O
*	O
outptr	pointer
++	O
=	O
*	O
inptr	pointer
++	O
;	O
*	O
outptr	pointer
=	O
'\0'	O
;	O
}	O
}	O
}	O
void	O
replacectrlchars	function
(	O
char	O
*	O
string	pointer
)	O
{	O
for	O
(	O
;	O
*	O
string	pointer
;	O
string	pointer
++	O
)	O
if	O
(	O
iscntrl	O
(	O
*	O
string	pointer
)	O
)	O
*	O
string	pointer
=	O
' '	O
;	O
}	O
char	O
*	O
fgetscont	function
(	O
char	O
*	O
buf	pointer
,	O
int	O
size	int
,	O
FILE	O
*	O
file	pointer
,	O
int	O
*	O
count	pointer
)	O
{	O
if	O
(	O
!	O
fgets	function
(	O
buf	pointer
,	O
size	int
,	O
file	pointer
)	O
)	O
return	O
0	int
;	O
(	O
*	O
count	pointer
)	O
++	O
;	O
while	O
(	O
strlen	O
(	O
buf	pointer
)	O
>=	O
2	int
&&	O
0	int
==	O
strcmp	O
(	O
buf	pointer
+	O
strlen	O
(	O
buf	pointer
)	O
-	O
2	int
,	O
"\\\n"	pointer
)	O
)	O
{	O
(	O
*	O
count	pointer
)	O
++	O
;	O
buf	pointer
[	O
strlen	O
(	O
buf	pointer
)	O
-	O
2	int
]	O
=	O
0	int
;	O
if	O
(	O
strlen	O
(	O
buf	pointer
)	O
>=	O
size	int
-	O
1	int
)	O
return	O
buf	pointer
;	O
if	O
(	O
!	O
fgets	function
(	O
buf	pointer
+	O
strlen	O
(	O
buf	pointer
)	O
,	O
size	int
-	O
strlen	O
(	O
buf	pointer
)	O
,	O
file	pointer
)	O
)	O
return	O
buf	pointer
;	O
}	O
if	O
(	O
lastchar	O
(	O
buf	pointer
)	O
==	O
'\\'	O
)	O
{	O
ungetc	function
(	O
'\\'	O
,	O
file	pointer
)	O
;	O
lastchar	O
(	O
buf	pointer
)	O
=	O
0	int
;	O
}	O
return	O
buf	pointer
;	O
}	O
char	O
*	O
fgetslong	function
(	O
char	O
*	O
*	O
buf	pointer
,	O
int	O
*	O
bufsize	pointer
,	O
FILE	O
*	O
file	pointer
,	O
int	O
*	O
count	pointer
)	O
{	O
int	O
dummy	int
;	O
if	O
(	O
!	O
count	pointer
)	O
count	pointer
=	O
&	O
dummy	int
;	O
if	O
(	O
!	O
*	O
bufsize	pointer
)	O
growbuffer	function
(	O
buf	pointer
,	O
bufsize	pointer
)	O
;	O
if	O
(	O
!	O
fgetscont	function
(	O
*	O
buf	pointer
,	O
*	O
bufsize	pointer
,	O
file	pointer
,	O
count	pointer
)	O
)	O
return	O
0	int
;	O
while	O
(	O
lastchar	O
(	O
*	O
buf	pointer
)	O
!=	O
'\n'	O
&&	O
!	O
feof	function
(	O
file	pointer
)	O
)	O
{	O
growbuffer	function
(	O
buf	pointer
,	O
bufsize	pointer
)	O
;	O
fgetscont	function
(	O
*	O
buf	pointer
+	O
strlen	O
(	O
*	O
buf	pointer
)	O
,	O
*	O
bufsize	pointer
-	O
strlen	O
(	O
*	O
buf	pointer
)	O
,	O
file	pointer
,	O
count	pointer
)	O
;	O
(	O
*	O
count	pointer
)	O
--	O
;	O
}	O
replacectrlchars	function
(	O
*	O
buf	pointer
)	O
;	O
return	O
*	O
buf	pointer
;	O
}	O
void	O
*	O
mymalloc	function
(	O
int	O
bytes	int
,	O
const	O
char	O
*	O
mesg	pointer
)	O
{	O
void	O
*	O
pointer	pointer
;	O
pointer	pointer
=	O
malloc	O
(	O
bytes	int
)	O
;	O
if	O
(	O
!	O
pointer	pointer
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"%s: memory allocation error %s\n"	pointer
,	O
progname	pointer
,	O
mesg	pointer
)	O
;	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
}	O
return	O
pointer	pointer
;	O
}	O
char	O
*	O
dupstr	function
(	O
const	O
char	O
*	O
str	pointer
)	O
{	O
char	O
*	O
ret	pointer
;	O
ret	pointer
=	O
mymalloc	function
(	O
strlen	O
(	O
str	pointer
)	O
+	O
1	int
,	O
"(dupstr)"	pointer
)	O
;	O
strcpy	O
(	O
ret	pointer
,	O
str	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
char	O
*	O
dupnstr	function
(	O
const	O
char	O
*	O
string	pointer
,	O
int	O
length	int
)	O
{	O
char	O
*	O
newstr	pointer
;	O
newstr	pointer
=	O
mymalloc	function
(	O
length	int
+	O
1	int
,	O
"(dupnstr)"	pointer
)	O
;	O
strncpy	O
(	O
newstr	pointer
,	O
string	pointer
,	O
length	int
)	O
;	O
newstr	pointer
[	O
length	int
]	O
=	O
0	int
;	O
return	O
newstr	pointer
;	O
}	O
int	O
strwidth	function
(	O
const	O
char	O
*	O
str	pointer
)	O
{	O
wchar_t	O
*	O
widestr	O
;	O
int	O
len	int
;	O
if	O
(	O
!	O
utf8mode	int
)	O
return	O
strlen	O
(	O
str	pointer
)	O
;	O
len	int
=	O
strlen	O
(	O
str	pointer
)	O
+	O
1	int
;	O
widestr	O
=	O
mymalloc	function
(	O
sizeof	O
(	O
wchar_t	O
)	O
*	O
len	int
,	O
"(strwidth)"	pointer
)	O
;	O
len	int
=	O
mbsrtowcs	function
(	O
widestr	O
,	O
&	O
str	pointer
,	O
len	int
,	O
NULL	O
)	O
;	O
if	O
(	O
len	int
==	O
-	O
1	int
)	O
{	O
free	function
(	O
widestr	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
len	int
=	O
wcswidth	function
(	O
widestr	O
,	O
len	int
)	O
;	O
free	function
(	O
widestr	O
)	O
;	O
return	O
len	int
;	O
}	O
unsigned	O
uhash	function
(	O
const	O
char	O
*	O
str	pointer
)	O
{	O
unsigned	O
hashval	int
;	O
for	O
(	O
hashval	int
=	O
0	int
;	O
*	O
str	pointer
;	O
str	pointer
++	O
)	O
hashval	int
=	O
*	O
str	pointer
+	O
HASHNUMBER	int
*	O
hashval	int
;	O
return	O
(	O
hashval	int
%	O
HASHSIZE	int
)	O
;	O
}	O
struct	O
unitlist	struct
*	O
ulookup	function
(	O
const	O
char	O
*	O
str	pointer
)	O
{	O
struct	O
unitlist	struct
*	O
uptr	pointer
;	O
for	O
(	O
uptr	pointer
=	O
utab	array
[	O
uhash	function
(	O
str	pointer
)	O
]	O
;	O
uptr	pointer
;	O
uptr	pointer
=	O
uptr	pointer
->	O
next	pointer
)	O
if	O
(	O
strcmp	O
(	O
str	pointer
,	O
uptr	pointer
->	O
name	pointer
)	O
==	O
0	int
)	O
return	O
uptr	pointer
;	O
return	O
NULL	O
;	O
}	O
struct	O
prefixlist	struct
*	O
plookup	function
(	O
const	O
char	O
*	O
str	pointer
)	O
{	O
struct	O
prefixlist	struct
*	O
prefix	pointer
;	O
struct	O
prefixlist	struct
*	O
bestprefix	pointer
=	O
NULL	O
;	O
int	O
bestlength	int
=	O
0	int
;	O
for	O
(	O
prefix	pointer
=	O
ptab	array
[	O
simplehash	O
(	O
str	pointer
)	O
]	O
;	O
prefix	pointer
;	O
prefix	pointer
=	O
prefix	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
prefix	pointer
->	O
len	int
>	O
bestlength	int
&&	O
!	O
strncmp	O
(	O
str	pointer
,	O
prefix	pointer
->	O
name	pointer
,	O
prefix	pointer
->	O
len	int
)	O
)	O
{	O
bestlength	int
=	O
prefix	pointer
->	O
len	int
;	O
bestprefix	pointer
=	O
prefix	pointer
;	O
}	O
}	O
return	O
bestprefix	pointer
;	O
}	O
struct	O
func	pointer
*	O
fnlookup	function
(	O
const	O
char	O
*	O
str	pointer
)	O
{	O
struct	O
func	pointer
*	O
funcptr	pointer
;	O
for	O
(	O
funcptr	pointer
=	O
ftab	array
[	O
simplehash	O
(	O
str	pointer
)	O
]	O
;	O
funcptr	pointer
;	O
funcptr	pointer
=	O
funcptr	pointer
->	O
next	pointer
)	O
if	O
(	O
!	O
strcmp	O
(	O
funcptr	pointer
->	O
name	pointer
,	O
str	pointer
)	O
)	O
return	O
funcptr	pointer
;	O
return	O
0	int
;	O
}	O
struct	O
wantalias	struct
*	O
aliaslookup	function
(	O
const	O
char	O
*	O
str	pointer
)	O
{	O
struct	O
wantalias	struct
*	O
aliasptr	pointer
;	O
for	O
(	O
aliasptr	pointer
=	O
firstalias	pointer
;	O
aliasptr	pointer
;	O
aliasptr	pointer
=	O
aliasptr	pointer
->	O
next	pointer
)	O
if	O
(	O
!	O
strcmp	O
(	O
aliasptr	pointer
->	O
name	pointer
,	O
str	pointer
)	O
)	O
return	O
aliasptr	pointer
;	O
return	O
0	int
;	O
}	O
void	O
addfunction	function
(	O
struct	O
func	pointer
*	O
newfunc	pointer
)	O
{	O
int	O
val	int
;	O
val	int
=	O
simplehash	O
(	O
newfunc	pointer
->	O
name	pointer
)	O
;	O
newfunc	pointer
->	O
next	pointer
=	O
ftab	array
[	O
val	int
]	O
;	O
ftab	array
[	O
val	int
]	O
=	O
newfunc	pointer
;	O
}	O
void	O
freefunction	function
(	O
struct	O
func	pointer
*	O
funcentry	pointer
)	O
{	O
if	O
(	O
funcentry	pointer
->	O
table	O
)	O
{	O
free	function
(	O
funcentry	pointer
->	O
table	O
)	O
;	O
free	function
(	O
funcentry	pointer
->	O
tableunit	pointer
)	O
;	O
}	O
else	O
{	O
free	function
(	O
funcentry	pointer
->	O
forward	O
.	O
param	O
)	O
;	O
free	function
(	O
funcentry	pointer
->	O
forward	O
.	O
def	pointer
)	O
;	O
if	O
(	O
funcentry	pointer
->	O
forward	O
.	O
domain_min	pointer
)	O
free	function
(	O
funcentry	pointer
->	O
forward	O
.	O
domain_min	pointer
)	O
;	O
if	O
(	O
funcentry	pointer
->	O
forward	O
.	O
domain_max	pointer
)	O
free	function
(	O
funcentry	pointer
->	O
forward	O
.	O
domain_max	pointer
)	O
;	O
if	O
(	O
funcentry	pointer
->	O
inverse	int
.	O
domain_min	pointer
)	O
free	function
(	O
funcentry	pointer
->	O
inverse	int
.	O
domain_min	pointer
)	O
;	O
if	O
(	O
funcentry	pointer
->	O
inverse	int
.	O
domain_max	pointer
)	O
free	function
(	O
funcentry	pointer
->	O
inverse	int
.	O
domain_max	pointer
)	O
;	O
if	O
(	O
funcentry	pointer
->	O
forward	O
.	O
dimen	pointer
)	O
free	function
(	O
funcentry	pointer
->	O
forward	O
.	O
dimen	pointer
)	O
;	O
if	O
(	O
funcentry	pointer
->	O
inverse	int
.	O
dimen	pointer
)	O
free	function
(	O
funcentry	pointer
->	O
inverse	int
.	O
dimen	pointer
)	O
;	O
if	O
(	O
funcentry	pointer
->	O
inverse	int
.	O
def	pointer
)	O
free	function
(	O
funcentry	pointer
->	O
inverse	int
.	O
def	pointer
)	O
;	O
if	O
(	O
funcentry	pointer
->	O
inverse	int
.	O
param	O
)	O
free	function
(	O
funcentry	pointer
->	O
inverse	int
.	O
param	O
)	O
;	O
}	O
}	O
void	O
removespaces	function
(	O
char	O
*	O
in	pointer
)	O
{	O
char	O
*	O
ptr	pointer
;	O
if	O
(	O
*	O
in	pointer
)	O
{	O
for	O
(	O
ptr	pointer
=	O
&	O
lastchar	O
(	O
in	pointer
)	O
;	O
*	O
ptr	pointer
==	O
' '	O
;	O
ptr	pointer
--	O
)	O
;	O
*	O
(	O
ptr	pointer
+	O
1	int
)	O
=	O
0	int
;	O
if	O
(	O
*	O
in	pointer
==	O
' '	O
)	O
{	O
ptr	pointer
=	O
in	pointer
+	O
strspn	O
(	O
in	pointer
,	O
" "	pointer
)	O
;	O
memmove	O
(	O
in	pointer
,	O
ptr	pointer
,	O
strlen	O
(	O
ptr	pointer
)	O
+	O
1	int
)	O
;	O
}	O
}	O
}	O
struct	O
func	pointer
*	O
invfnlookup	function
(	O
char	O
*	O
str	pointer
)	O
{	O
if	O
(	O
*	O
str	pointer
!=	O
'~'	O
)	O
return	O
0	int
;	O
removespaces	function
(	O
str	pointer
+	O
1	int
)	O
;	O
return	O
fnlookup	function
(	O
str	pointer
+	O
1	int
)	O
;	O
}	O
char	O
*	O
strip_comment	function
(	O
char	O
*	O
line	pointer
)	O
{	O
char	O
*	O
comment	pointer
=	O
0	int
;	O
if	O
(	O
(	O
line	pointer
=	O
strchr	O
(	O
line	pointer
,	O
COMMENTCHAR	char
)	O
)	O
)	O
{	O
comment	pointer
=	O
line	pointer
+	O
1	int
;	O
*	O
line	pointer
=	O
0	int
;	O
}	O
return	O
comment	pointer
;	O
}	O
void	O
tightprint	function
(	O
FILE	O
*	O
outfile	pointer
,	O
char	O
*	O
string	pointer
)	O
{	O
while	O
(	O
*	O
string	pointer
)	O
{	O
fputc	function
(	O
*	O
string	pointer
,	O
outfile	pointer
)	O
;	O
if	O
(	O
*	O
string	pointer
!=	O
' '	O
)	O
string	pointer
++	O
;	O
else	O
while	O
(	O
*	O
string	pointer
==	O
' '	O
)	O
string	pointer
++	O
;	O
}	O
}	O
void	O
splitline	function
(	O
char	O
*	O
line	pointer
,	O
char	O
*	O
*	O
first	pointer
,	O
char	O
*	O
*	O
second	pointer
)	O
{	O
*	O
second	pointer
=	O
0	int
;	O
*	O
first	pointer
=	O
strtok	O
(	O
line	pointer
,	O
" "	pointer
)	O
;	O
if	O
(	O
*	O
first	pointer
)	O
{	O
*	O
second	pointer
=	O
strtok	O
(	O
0	int
,	O
"\n"	pointer
)	O
;	O
if	O
(	O
*	O
second	pointer
)	O
{	O
removespaces	function
(	O
*	O
second	pointer
)	O
;	O
if	O
(	O
emptystr	O
(	O
*	O
second	pointer
)	O
)	O
*	O
second	pointer
=	O
0	int
;	O
}	O
}	O
}	O
int	O
isdecimal	function
(	O
char	O
c	char
)	O
{	O
return	O
strchr	O
(	O
digits	pointer
,	O
c	char
)	O
!=	O
NULL	O
;	O
}	O
int	O
checkunitname	function
(	O
char	O
*	O
name	pointer
,	O
int	O
linenum	int
,	O
char	O
*	O
file	pointer
,	O
FILE	O
*	O
errfile	pointer
)	O
{	O
char	O
nonunitchars	array
[	O
]	O
=	O
"~;+-*/|^)"	pointer
;	O
char	O
*	O
*	O
ptr	pointer
;	O
char	O
*	O
cptr	pointer
;	O
if	O
(	O
(	O
cptr	pointer
=	O
strpbrk	O
(	O
name	pointer
,	O
nonunitchars	array
)	O
)	O
)	O
{	O
if	O
(	O
errfile	pointer
)	O
fprintf	function
(	O
errfile	pointer
,	O
"%s: unit '%s' in units file '%s' on line %d ignored.  It contains invalid character '%c'\n"	pointer
,	O
progname	pointer
,	O
name	pointer
,	O
file	pointer
,	O
linenum	int
,	O
*	O
cptr	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
strchr	O
(	O
digits	pointer
,	O
name	pointer
[	O
0	int
]	O
)	O
)	O
{	O
if	O
(	O
errfile	pointer
)	O
fprintf	function
(	O
errfile	pointer
,	O
"%s: unit '%s' in units file '%s' on line %d ignored.  It starts with a digit\n"	pointer
,	O
progname	pointer
,	O
name	pointer
,	O
file	pointer
,	O
linenum	int
)	O
;	O
return	O
1	int
;	O
}	O
for	O
(	O
ptr	pointer
=	O
builtins	array
;	O
*	O
ptr	pointer
;	O
ptr	pointer
++	O
)	O
if	O
(	O
!	O
strcmp	O
(	O
name	pointer
,	O
*	O
ptr	pointer
)	O
)	O
{	O
if	O
(	O
errfile	pointer
)	O
fprintf	function
(	O
errfile	pointer
,	O
"%s: redefinition of built-in function '%s' in file '%s' on line %d ignored.\n"	pointer
,	O
progname	pointer
,	O
name	pointer
,	O
file	pointer
,	O
linenum	int
)	O
;	O
return	O
1	int
;	O
}	O
for	O
(	O
ptr	pointer
=	O
all_commands	array
;	O
*	O
ptr	pointer
;	O
ptr	pointer
++	O
)	O
if	O
(	O
!	O
strcmp	O
(	O
name	pointer
,	O
*	O
ptr	pointer
)	O
)	O
{	O
if	O
(	O
errfile	pointer
)	O
fprintf	function
(	O
errfile	pointer
,	O
"%s: unit name '%s' in file '%s' on line %d may be hidden by command with the same name.\n"	pointer
,	O
progname	pointer
,	O
name	pointer
,	O
file	pointer
,	O
linenum	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
newunit	function
(	O
char	O
*	O
unitname	pointer
,	O
char	O
*	O
unitdef	pointer
,	O
int	O
*	O
count	pointer
,	O
int	O
linenum	int
,	O
char	O
*	O
file	pointer
,	O
FILE	O
*	O
errfile	pointer
,	O
int	O
redefine	int
)	O
{	O
struct	O
unitlist	struct
*	O
uptr	pointer
;	O
unsigned	O
hashval	int
;	O
if	O
(	O
unitname	pointer
[	O
0	int
]	O
==	O
'_'	O
||	O
lastchar	O
(	O
unitname	pointer
)	O
==	O
'_'	O
)	O
{	O
if	O
(	O
errfile	pointer
)	O
fprintf	function
(	O
errfile	pointer
,	O
"%s: unit '%s' on line %d of '%s' ignored.  It starts or ends with '_'\n"	pointer
,	O
progname	pointer
,	O
unitname	pointer
,	O
linenum	int
,	O
file	pointer
)	O
;	O
return	O
E_BADFILE	O
;	O
}	O
if	O
(	O
strchr	O
(	O
".,23456789"	pointer
,	O
lastchar	O
(	O
unitname	pointer
)	O
)	O
&&	O
!	O
hassubscript	function
(	O
unitname	pointer
)	O
)	O
{	O
if	O
(	O
errfile	pointer
)	O
fprintf	function
(	O
errfile	pointer
,	O
"%s: unit '%s' on line %d of '%s' ignored.  %s\n"	pointer
,	O
progname	pointer
,	O
unitname	pointer
,	O
linenum	int
,	O
file	pointer
,	O
errormsg	array
[	O
E_UNITEND	O
]	O
)	O
;	O
return	O
E_BADFILE	O
;	O
}	O
if	O
(	O
checkunitname	function
(	O
unitname	pointer
,	O
linenum	int
,	O
file	pointer
,	O
errfile	pointer
)	O
)	O
return	O
E_BADFILE	O
;	O
if	O
(	O
(	O
uptr	pointer
=	O
ulookup	function
(	O
unitname	pointer
)	O
)	O
)	O
{	O
if	O
(	O
flags	struct
.	O
unitcheck	int
&&	O
errfile	pointer
&&	O
!	O
redefine	int
)	O
fprintf	function
(	O
errfile	pointer
,	O
"%s: unit '%s' defined on line %d of '%s' is redefined on line %d of '%s'.\n"	pointer
,	O
progname	pointer
,	O
unitname	pointer
,	O
uptr	pointer
->	O
linenumber	int
,	O
uptr	pointer
->	O
file	pointer
,	O
linenum	int
,	O
file	pointer
)	O
;	O
free	function
(	O
uptr	pointer
->	O
value	pointer
)	O
;	O
}	O
else	O
{	O
uptr	pointer
=	O
(	O
struct	O
unitlist	struct
*	O
)	O
mymalloc	function
(	O
sizeof	O
(	O
*	O
uptr	pointer
)	O
,	O
"(newunit)"	pointer
)	O
;	O
uptr	pointer
->	O
name	pointer
=	O
dupstr	function
(	O
unitname	pointer
)	O
;	O
hashval	int
=	O
uhash	function
(	O
uptr	pointer
->	O
name	pointer
)	O
;	O
uptr	pointer
->	O
next	pointer
=	O
utab	array
[	O
hashval	int
]	O
;	O
utab	array
[	O
hashval	int
]	O
=	O
uptr	pointer
;	O
(	O
*	O
count	pointer
)	O
++	O
;	O
}	O
uptr	pointer
->	O
value	pointer
=	O
dupstr	function
(	O
unitdef	pointer
)	O
;	O
uptr	pointer
->	O
linenumber	int
=	O
linenum	int
;	O
uptr	pointer
->	O
file	pointer
=	O
file	pointer
;	O
return	O
0	int
;	O
}	O
int	O
newprefix	function
(	O
char	O
*	O
unitname	pointer
,	O
char	O
*	O
unitdef	pointer
,	O
int	O
*	O
count	pointer
,	O
int	O
linenum	int
,	O
char	O
*	O
file	pointer
,	O
FILE	O
*	O
errfile	pointer
,	O
int	O
redefine	int
)	O
{	O
struct	O
prefixlist	struct
*	O
pfxptr	pointer
;	O
unsigned	O
pval	int
;	O
lastchar	O
(	O
unitname	pointer
)	O
=	O
0	int
;	O
if	O
(	O
checkunitname	function
(	O
unitname	pointer
,	O
linenum	int
,	O
file	pointer
,	O
errfile	pointer
)	O
)	O
return	O
E_BADFILE	O
;	O
if	O
(	O
(	O
pfxptr	pointer
=	O
plookup	function
(	O
unitname	pointer
)	O
)	O
&&	O
!	O
strcmp	O
(	O
pfxptr	pointer
->	O
name	pointer
,	O
unitname	pointer
)	O
)	O
{	O
if	O
(	O
flags	struct
.	O
unitcheck	int
&&	O
errfile	pointer
&&	O
!	O
redefine	int
)	O
fprintf	function
(	O
errfile	pointer
,	O
"%s: prefix '%s-' defined on line %d of '%s' is redefined on line %d of '%s'.\n"	pointer
,	O
progname	pointer
,	O
unitname	pointer
,	O
pfxptr	pointer
->	O
linenumber	int
,	O
pfxptr	pointer
->	O
file	pointer
,	O
linenum	int
,	O
file	pointer
)	O
;	O
free	function
(	O
pfxptr	pointer
->	O
value	pointer
)	O
;	O
}	O
else	O
{	O
pfxptr	pointer
=	O
(	O
struct	O
prefixlist	struct
*	O
)	O
mymalloc	function
(	O
sizeof	O
(	O
*	O
pfxptr	pointer
)	O
,	O
"(newprefix)"	pointer
)	O
;	O
pfxptr	pointer
->	O
name	pointer
=	O
dupstr	function
(	O
unitname	pointer
)	O
;	O
pfxptr	pointer
->	O
len	int
=	O
strlen	O
(	O
unitname	pointer
)	O
;	O
pval	int
=	O
simplehash	O
(	O
unitname	pointer
)	O
;	O
pfxptr	pointer
->	O
next	pointer
=	O
ptab	array
[	O
pval	int
]	O
;	O
ptab	array
[	O
pval	int
]	O
=	O
pfxptr	pointer
;	O
(	O
*	O
count	pointer
)	O
++	O
;	O
}	O
pfxptr	pointer
->	O
value	pointer
=	O
dupstr	function
(	O
unitdef	pointer
)	O
;	O
pfxptr	pointer
->	O
linenumber	int
=	O
linenum	int
;	O
pfxptr	pointer
->	O
file	pointer
=	O
file	pointer
;	O
return	O
0	int
;	O
}	O
char	O
*	O
parsepair	function
(	O
char	O
*	O
input	pointer
,	O
char	O
*	O
*	O
first	pointer
,	O
char	O
*	O
*	O
second	pointer
,	O
int	O
*	O
firstopen	pointer
,	O
int	O
*	O
secondopen	pointer
,	O
char	O
delimiter	char
,	O
int	O
checkopen	int
,	O
char	O
*	O
unitname	pointer
,	O
int	O
linenum	int
,	O
char	O
*	O
file	pointer
,	O
FILE	O
*	O
errfile	pointer
)	O
{	O
char	O
*	O
start	pointer
,	O
*	O
end	pointer
,	O
*	O
middle	pointer
;	O
start	pointer
=	O
strpbrk	O
(	O
input	pointer
,	O
checkopen	int
?	O
"[("	pointer
:	O
"["	pointer
)	O
;	O
if	O
(	O
!	O
start	pointer
)	O
{	O
if	O
(	O
errfile	pointer
)	O
fprintf	function
(	O
errfile	pointer
,	O
"%s: expecting '[' %s in definition of '%s' in '%s' line %d\n"	pointer
,	O
progname	pointer
,	O
checkopen	int
?	O
"or '('"	pointer
:	O
""	pointer
,	O
unitname	pointer
,	O
file	pointer
,	O
linenum	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
*	O
start	pointer
==	O
'('	O
)	O
*	O
firstopen	pointer
=	O
1	int
;	O
else	O
*	O
firstopen	pointer
=	O
0	int
;	O
*	O
start	pointer
++	O
=	O
0	int
;	O
removespaces	function
(	O
input	pointer
)	O
;	O
if	O
(	O
!	O
emptystr	O
(	O
input	pointer
)	O
)	O
{	O
if	O
(	O
errfile	pointer
)	O
fprintf	function
(	O
errfile	pointer
,	O
"%s: unexpected characters before '%c' in definition of '%s' in '%s' line %d\n"	pointer
,	O
progname	pointer
,	O
*	O
firstopen	pointer
?	O
'('	O
:	O
'['	O
,	O
unitname	pointer
,	O
file	pointer
,	O
linenum	int
)	O
;	O
return	O
0	int
;	O
}	O
end	pointer
=	O
strpbrk	O
(	O
start	pointer
,	O
checkopen	int
?	O
"])"	pointer
:	O
"]"	pointer
)	O
;	O
if	O
(	O
!	O
end	pointer
)	O
{	O
if	O
(	O
errfile	pointer
)	O
fprintf	function
(	O
errfile	pointer
,	O
"%s: expecting ']' %s in definition of '%s' in '%s' line %d\n"	pointer
,	O
progname	pointer
,	O
checkopen	int
?	O
"or ')'"	pointer
:	O
""	pointer
,	O
unitname	pointer
,	O
file	pointer
,	O
linenum	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
*	O
end	pointer
==	O
')'	O
)	O
*	O
secondopen	pointer
=	O
1	int
;	O
else	O
*	O
secondopen	pointer
=	O
0	int
;	O
*	O
end	pointer
++	O
=	O
0	int
;	O
middle	pointer
=	O
strchr	O
(	O
start	pointer
,	O
delimiter	char
)	O
;	O
if	O
(	O
middle	pointer
)	O
{	O
*	O
middle	pointer
++	O
=	O
0	int
;	O
removespaces	function
(	O
middle	pointer
)	O
;	O
*	O
second	pointer
=	O
middle	pointer
;	O
}	O
else	O
*	O
second	pointer
=	O
0	int
;	O
removespaces	function
(	O
start	pointer
)	O
;	O
*	O
first	pointer
=	O
start	pointer
;	O
return	O
end	pointer
;	O
}	O
int	O
extract_interval	function
(	O
char	O
*	O
first	pointer
,	O
char	O
*	O
second	pointer
,	O
double	O
*	O
*	O
firstout	pointer
,	O
double	O
*	O
*	O
secondout	pointer
)	O
{	O
double	O
val	int
;	O
char	O
*	O
end	pointer
;	O
if	O
(	O
!	O
emptystr	O
(	O
first	pointer
)	O
)	O
{	O
val	int
=	O
strtod	O
(	O
first	pointer
,	O
&	O
end	pointer
)	O
;	O
if	O
(	O
*	O
end	pointer
)	O
return	O
EI_ERR_MALF	int
;	O
else	O
{	O
*	O
firstout	pointer
=	O
(	O
double	O
*	O
)	O
mymalloc	function
(	O
sizeof	O
(	O
double	O
)	O
,	O
"(extract_interval)"	pointer
)	O
;	O
*	O
*	O
firstout	pointer
=	O
val	int
;	O
}	O
}	O
if	O
(	O
second	pointer
&&	O
!	O
emptystr	O
(	O
second	pointer
)	O
)	O
{	O
val	int
=	O
strtod	O
(	O
second	pointer
,	O
&	O
end	pointer
)	O
;	O
if	O
(	O
*	O
end	pointer
)	O
return	O
EI_ERR_MALF	int
;	O
else	O
if	O
(	O
*	O
firstout	pointer
&&	O
*	O
*	O
firstout	pointer
>=	O
val	int
)	O
return	O
EI_ERR_DEC	int
;	O
else	O
{	O
*	O
secondout	pointer
=	O
(	O
double	O
*	O
)	O
mymalloc	function
(	O
sizeof	O
(	O
double	O
)	O
,	O
"(extract_interval)"	pointer
)	O
;	O
*	O
*	O
secondout	pointer
=	O
val	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
void	O
copyfunctype	function
(	O
struct	O
functype	O
*	O
dest	pointer
,	O
struct	O
functype	O
*	O
src	pointer
)	O
{	O
dest	pointer
->	O
domain_min_open	int
=	O
src	pointer
->	O
domain_min_open	int
;	O
dest	pointer
->	O
domain_max_open	int
=	O
src	pointer
->	O
domain_max_open	int
;	O
dest	pointer
->	O
param	O
=	O
dest	pointer
->	O
def	pointer
=	O
dest	pointer
->	O
dimen	pointer
=	O
NULL	O
;	O
dest	pointer
->	O
domain_min	pointer
=	O
dest	pointer
->	O
domain_max	pointer
=	O
NULL	O
;	O
if	O
(	O
src	pointer
->	O
param	O
)	O
dest	pointer
->	O
param	O
=	O
dupstr	function
(	O
src	pointer
->	O
param	O
)	O
;	O
if	O
(	O
src	pointer
->	O
def	pointer
)	O
dest	pointer
->	O
def	pointer
=	O
dupstr	function
(	O
src	pointer
->	O
def	pointer
)	O
;	O
if	O
(	O
src	pointer
->	O
dimen	pointer
)	O
dest	pointer
->	O
dimen	pointer
=	O
dupstr	function
(	O
src	pointer
->	O
dimen	pointer
)	O
;	O
if	O
(	O
src	pointer
->	O
domain_min	pointer
)	O
{	O
dest	pointer
->	O
domain_min	pointer
=	O
(	O
double	O
*	O
)	O
mymalloc	function
(	O
sizeof	O
(	O
double	O
)	O
,	O
"(copyfunctype)"	pointer
)	O
;	O
*	O
dest	pointer
->	O
domain_min	pointer
=	O
*	O
src	pointer
->	O
domain_min	pointer
;	O
}	O
if	O
(	O
src	pointer
->	O
domain_max	pointer
)	O
{	O
dest	pointer
->	O
domain_max	pointer
=	O
(	O
double	O
*	O
)	O
mymalloc	function
(	O
sizeof	O
(	O
double	O
)	O
,	O
"(copyfunctype)"	pointer
)	O
;	O
*	O
dest	pointer
->	O
domain_max	pointer
=	O
*	O
src	pointer
->	O
domain_max	pointer
;	O
}	O
}	O
int	O
copyfunction	function
(	O
char	O
*	O
unitname	pointer
,	O
char	O
*	O
funcname	pointer
,	O
int	O
*	O
count	pointer
,	O
int	O
linenum	int
,	O
char	O
*	O
file	pointer
,	O
FILE	O
*	O
errfile	pointer
)	O
{	O
struct	O
func	pointer
*	O
source	pointer
,	O
*	O
funcentry	pointer
;	O
int	O
i	int
;	O
if	O
(	O
checkunitname	function
(	O
unitname	pointer
,	O
linenum	int
,	O
file	pointer
,	O
errfile	pointer
)	O
)	O
return	O
E_BADFILE	O
;	O
removespaces	function
(	O
funcname	pointer
)	O
;	O
i	int
=	O
strlen	O
(	O
funcname	pointer
)	O
-	O
2	int
;	O
if	O
(	O
i	int
>	O
0	int
&&	O
!	O
strcmp	O
(	O
funcname	pointer
+	O
i	int
,	O
"()"	pointer
)	O
)	O
funcname	pointer
[	O
i	int
]	O
=	O
0	int
;	O
source	pointer
=	O
fnlookup	function
(	O
funcname	pointer
)	O
;	O
if	O
(	O
!	O
source	pointer
)	O
{	O
if	O
(	O
errfile	pointer
)	O
{	O
if	O
(	O
!	O
strpbrk	O
(	O
funcname	pointer
,	O
" ;][()+*/-^"	pointer
)	O
)	O
fprintf	function
(	O
errfile	pointer
,	O
"%s: bad definition for '%s' in '%s' line %d, function '%s' not defined\n"	pointer
,	O
progname	pointer
,	O
unitname	pointer
,	O
file	pointer
,	O
linenum	int
,	O
funcname	pointer
)	O
;	O
else	O
fprintf	function
(	O
errfile	pointer
,	O
"%s: bad function definition of '%s' in '%s' line %d\n"	pointer
,	O
progname	pointer
,	O
unitname	pointer
,	O
file	pointer
,	O
linenum	int
)	O
;	O
}	O
return	O
E_BADFILE	O
;	O
}	O
if	O
(	O
(	O
funcentry	pointer
=	O
fnlookup	function
(	O
unitname	pointer
)	O
)	O
)	O
{	O
if	O
(	O
flags	struct
.	O
unitcheck	int
&&	O
errfile	pointer
)	O
fprintf	function
(	O
errfile	pointer
,	O
"%s: function '%s' defined on line %d of '%s' is redefined on line %d of '%s'.\n"	pointer
,	O
progname	pointer
,	O
unitname	pointer
,	O
funcentry	pointer
->	O
linenumber	int
,	O
funcentry	pointer
->	O
file	pointer
,	O
linenum	int
,	O
file	pointer
)	O
;	O
freefunction	function
(	O
funcentry	pointer
)	O
;	O
}	O
else	O
{	O
funcentry	pointer
=	O
(	O
struct	O
func	pointer
*	O
)	O
mymalloc	function
(	O
sizeof	O
(	O
struct	O
func	pointer
)	O
,	O
"(newfunction)"	pointer
)	O
;	O
funcentry	pointer
->	O
name	pointer
=	O
dupstr	function
(	O
unitname	pointer
)	O
;	O
addfunction	function
(	O
funcentry	pointer
)	O
;	O
(	O
*	O
count	pointer
)	O
++	O
;	O
}	O
funcentry	pointer
->	O
linenumber	int
=	O
linenum	int
;	O
funcentry	pointer
->	O
file	pointer
=	O
file	pointer
;	O
funcentry	pointer
->	O
skip_error_check	O
=	O
source	pointer
->	O
skip_error_check	O
;	O
if	O
(	O
source	pointer
->	O
table	O
)	O
{	O
funcentry	pointer
->	O
tablelen	O
=	O
source	pointer
->	O
tablelen	O
;	O
funcentry	pointer
->	O
tableunit	pointer
=	O
dupstr	function
(	O
source	pointer
->	O
tableunit	pointer
)	O
;	O
funcentry	pointer
->	O
table	O
=	O
(	O
struct	O
pair	O
*	O
)	O
mymalloc	function
(	O
sizeof	O
(	O
struct	O
pair	O
)	O
*	O
funcentry	pointer
->	O
tablelen	O
,	O
"(copyfunction)"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
funcentry	pointer
->	O
tablelen	O
;	O
i	int
++	O
)	O
{	O
funcentry	pointer
->	O
table	O
[	O
i	int
]	O
.	O
location	O
=	O
source	pointer
->	O
table	O
[	O
i	int
]	O
.	O
location	O
;	O
funcentry	pointer
->	O
table	O
[	O
i	int
]	O
.	O
value	pointer
=	O
source	pointer
->	O
table	O
[	O
i	int
]	O
.	O
value	pointer
;	O
}	O
}	O
else	O
{	O
funcentry	pointer
->	O
table	O
=	O
0	int
;	O
copyfunctype	function
(	O
&	O
funcentry	pointer
->	O
forward	O
,	O
&	O
source	pointer
->	O
forward	O
)	O
;	O
copyfunctype	function
(	O
&	O
funcentry	pointer
->	O
inverse	int
,	O
&	O
source	pointer
->	O
inverse	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
newfunction	function
(	O
char	O
*	O
unitname	pointer
,	O
char	O
*	O
unitdef	pointer
,	O
int	O
*	O
count	pointer
,	O
int	O
linenum	int
,	O
char	O
*	O
file	pointer
,	O
FILE	O
*	O
errfile	pointer
,	O
int	O
redefine	int
)	O
{	O
char	O
*	O
start	pointer
,	O
*	O
end	pointer
,	O
*	O
inv	pointer
,	O
*	O
forward_dim	pointer
,	O
*	O
inverse_dim	pointer
,	O
*	O
first	pointer
,	O
*	O
second	pointer
;	O
double	O
*	O
domain_min	pointer
,	O
*	O
domain_max	pointer
,	O
*	O
range_min	pointer
,	O
*	O
range_max	pointer
;	O
struct	O
func	pointer
*	O
funcentry	pointer
;	O
int	O
looking_for_keywords	int
,	O
i	int
,	O
firstopen	pointer
,	O
secondopen	pointer
;	O
int	O
domain_min_open	int
,	O
domain_max_open	int
,	O
range_min_open	int
,	O
range_max_open	int
;	O
int	O
noerror	int
=	O
0	int
;	O
if	O
(	O
*	O
unitname	pointer
==	O
'('	O
)	O
{	O
if	O
(	O
errfile	pointer
)	O
fprintf	function
(	O
errfile	pointer
,	O
"%s: unit '%s' on line %d of '%s' ignored.  It starts with a '('\n"	pointer
,	O
progname	pointer
,	O
unitname	pointer
,	O
linenum	int
,	O
file	pointer
)	O
;	O
return	O
E_BADFILE	O
;	O
}	O
start	pointer
=	O
strchr	O
(	O
unitname	pointer
,	O
'('	O
)	O
;	O
end	pointer
=	O
strchr	O
(	O
unitname	pointer
,	O
')'	O
)	O
;	O
*	O
start	pointer
++	O
=	O
0	int
;	O
if	O
(	O
checkunitname	function
(	O
unitname	pointer
,	O
linenum	int
,	O
file	pointer
,	O
errfile	pointer
)	O
)	O
return	O
E_BADFILE	O
;	O
if	O
(	O
start	pointer
==	O
end	pointer
)	O
return	O
copyfunction	function
(	O
unitname	pointer
,	O
unitdef	pointer
,	O
count	pointer
,	O
linenum	int
,	O
file	pointer
,	O
errfile	pointer
)	O
;	O
if	O
(	O
!	O
end	pointer
||	O
strlen	O
(	O
end	pointer
)	O
>	O
1	int
)	O
{	O
if	O
(	O
errfile	pointer
)	O
fprintf	function
(	O
errfile	pointer
,	O
"%s: bad function definition of '%s' in '%s' line %d\n"	pointer
,	O
progname	pointer
,	O
unitname	pointer
,	O
file	pointer
,	O
linenum	int
)	O
;	O
return	O
E_BADFILE	O
;	O
}	O
*	O
end	pointer
=	O
0	int
;	O
forward_dim	pointer
=	O
NULL	O
;	O
inverse_dim	pointer
=	O
NULL	O
;	O
domain_min	pointer
=	O
NULL	O
;	O
domain_max	pointer
=	O
NULL	O
;	O
range_min	pointer
=	O
NULL	O
;	O
range_max	pointer
=	O
NULL	O
;	O
domain_min_open	int
=	O
0	int
;	O
domain_max_open	int
=	O
0	int
;	O
range_min_open	int
=	O
0	int
;	O
range_max_open	int
=	O
0	int
;	O
looking_for_keywords	int
=	O
1	int
;	O
while	O
(	O
looking_for_keywords	int
)	O
{	O
looking_for_keywords	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
fnkeywords	array
[	O
i	int
]	O
.	O
word	pointer
;	O
i	int
++	O
)	O
{	O
if	O
(	O
startswith	O
(	O
unitdef	pointer
,	O
fnkeywords	array
[	O
i	int
]	O
.	O
word	pointer
)	O
)	O
{	O
looking_for_keywords	int
=	O
1	int
;	O
unitdef	pointer
+=	O
strlen	O
(	O
fnkeywords	array
[	O
i	int
]	O
.	O
word	pointer
)	O
;	O
if	O
(	O
fnkeywords	array
[	O
i	int
]	O
.	O
checkopen	int
!=	O
CO_NOARG	O
)	O
{	O
unitdef	pointer
=	O
parsepair	function
(	O
unitdef	pointer
,	O
&	O
first	pointer
,	O
&	O
second	pointer
,	O
&	O
firstopen	pointer
,	O
&	O
secondopen	pointer
,	O
fnkeywords	array
[	O
i	int
]	O
.	O
delimit	char
,	O
fnkeywords	array
[	O
i	int
]	O
.	O
checkopen	int
,	O
unitname	pointer
,	O
linenum	int
,	O
file	pointer
,	O
errfile	pointer
)	O
;	O
if	O
(	O
!	O
unitdef	pointer
)	O
{	O
FREE_STUFF	O
;	O
return	O
E_BADFILE	O
;	O
}	O
removespaces	function
(	O
unitdef	pointer
)	O
;	O
}	O
if	O
(	O
i	int
==	O
FN_NOERROR	int
)	O
noerror	int
=	O
1	int
;	O
if	O
(	O
i	int
==	O
FN_UNITS	int
)	O
{	O
if	O
(	O
forward_dim	pointer
||	O
inverse_dim	pointer
)	O
{	O
REPEAT_ERR	O
;	O
return	O
E_BADFILE	O
;	O
}	O
forward_dim	pointer
=	O
dupstr	function
(	O
first	pointer
)	O
;	O
if	O
(	O
second	pointer
)	O
inverse_dim	pointer
=	O
dupstr	function
(	O
second	pointer
)	O
;	O
}	O
if	O
(	O
i	int
==	O
FN_DOMAIN	int
)	O
{	O
int	O
err	int
=	O
0	int
;	O
if	O
(	O
domain_min	pointer
||	O
domain_max	pointer
)	O
{	O
REPEAT_ERR	O
;	O
return	O
E_BADFILE	O
;	O
}	O
err	int
=	O
extract_interval	function
(	O
first	pointer
,	O
second	pointer
,	O
&	O
domain_min	pointer
,	O
&	O
domain_max	pointer
)	O
;	O
domain_min_open	int
=	O
firstopen	pointer
;	O
domain_max_open	int
=	O
secondopen	pointer
;	O
if	O
(	O
err	int
)	O
FREE_STUFF	O
;	O
if	O
(	O
err	int
==	O
EI_ERR_DEC	int
)	O
{	O
if	O
(	O
errfile	pointer
)	O
fprintf	function
(	O
errfile	pointer
,	O
"%s: second endpoint for domain must be greater than the first\n       in definition of '%s' in '%s' line %d\n"	pointer
,	O
progname	pointer
,	O
unitname	pointer
,	O
file	pointer
,	O
linenum	int
)	O
;	O
return	O
E_BADFILE	O
;	O
}	O
if	O
(	O
err	int
==	O
EI_ERR_MALF	int
)	O
{	O
if	O
(	O
errfile	pointer
)	O
fprintf	function
(	O
errfile	pointer
,	O
"%s: malformed domain in definition of '%s' in '%s' line %d\n"	pointer
,	O
progname	pointer
,	O
unitname	pointer
,	O
file	pointer
,	O
linenum	int
)	O
;	O
return	O
E_BADFILE	O
;	O
}	O
}	O
if	O
(	O
i	int
==	O
FN_RANGE	int
)	O
{	O
int	O
err	int
=	O
0	int
;	O
if	O
(	O
range_min	pointer
||	O
range_max	pointer
)	O
{	O
REPEAT_ERR	O
;	O
FREE_STUFF	O
;	O
return	O
E_BADFILE	O
;	O
}	O
err	int
=	O
extract_interval	function
(	O
first	pointer
,	O
second	pointer
,	O
&	O
range_min	pointer
,	O
&	O
range_max	pointer
)	O
;	O
range_min_open	int
=	O
firstopen	pointer
;	O
range_max_open	int
=	O
secondopen	pointer
;	O
if	O
(	O
err	int
)	O
FREE_STUFF	O
;	O
if	O
(	O
err	int
==	O
EI_ERR_DEC	int
)	O
{	O
if	O
(	O
errfile	pointer
)	O
fprintf	function
(	O
errfile	pointer
,	O
"%s: second endpoint for range must be greater than the first\n       in definition of '%s' in '%s' line %d\n"	pointer
,	O
progname	pointer
,	O
unitname	pointer
,	O
file	pointer
,	O
linenum	int
)	O
;	O
return	O
E_BADFILE	O
;	O
}	O
if	O
(	O
err	int
==	O
EI_ERR_MALF	int
)	O
{	O
if	O
(	O
errfile	pointer
)	O
fprintf	function
(	O
errfile	pointer
,	O
"%s: malformed range in definition of '%s' in '%s' line %d\n"	pointer
,	O
progname	pointer
,	O
unitname	pointer
,	O
file	pointer
,	O
linenum	int
)	O
;	O
return	O
E_BADFILE	O
;	O
}	O
}	O
}	O
}	O
}	O
if	O
(	O
emptystr	O
(	O
unitdef	pointer
)	O
)	O
{	O
if	O
(	O
errfile	pointer
)	O
fprintf	function
(	O
errfile	pointer
,	O
"%s: function '%s' lacks a definition at line %d of '%s'\n"	pointer
,	O
progname	pointer
,	O
unitname	pointer
,	O
linenum	int
,	O
file	pointer
)	O
;	O
FREE_STUFF	O
;	O
return	O
E_BADFILE	O
;	O
}	O
if	O
(	O
*	O
unitdef	pointer
==	O
'['	O
)	O
{	O
if	O
(	O
errfile	pointer
)	O
fprintf	function
(	O
errfile	pointer
,	O
"%s: function '%s' missing keyword before '[' on line %d of '%s'\n"	pointer
,	O
progname	pointer
,	O
unitname	pointer
,	O
linenum	int
,	O
file	pointer
)	O
;	O
FREE_STUFF	O
;	O
return	O
E_BADFILE	O
;	O
}	O
if	O
(	O
!	O
forward_dim	pointer
&&	O
(	O
(	O
domain_min	pointer
&&	O
*	O
domain_min	pointer
)	O
||	O
(	O
domain_max	pointer
&&	O
*	O
domain_max	pointer
)	O
)	O
)	O
{	O
if	O
(	O
errfile	pointer
)	O
fprintf	function
(	O
errfile	pointer
,	O
"%s: function '%s' defined on line %d of '%s' has domain with no units.\n"	pointer
,	O
progname	pointer
,	O
unitname	pointer
,	O
linenum	int
,	O
file	pointer
)	O
;	O
FREE_STUFF	O
;	O
return	O
E_BADFILE	O
;	O
}	O
if	O
(	O
!	O
inverse_dim	pointer
&&	O
(	O
(	O
range_min	pointer
&&	O
*	O
range_min	pointer
)	O
||	O
(	O
range_max	pointer
&&	O
*	O
range_max	pointer
)	O
)	O
)	O
{	O
if	O
(	O
errfile	pointer
)	O
fprintf	function
(	O
errfile	pointer
,	O
"%s: function '%s' defined on line %d of '%s' has range with no units.\n"	pointer
,	O
progname	pointer
,	O
unitname	pointer
,	O
linenum	int
,	O
file	pointer
)	O
;	O
FREE_STUFF	O
;	O
return	O
E_BADFILE	O
;	O
}	O
if	O
(	O
(	O
funcentry	pointer
=	O
fnlookup	function
(	O
unitname	pointer
)	O
)	O
)	O
{	O
if	O
(	O
flags	struct
.	O
unitcheck	int
&&	O
errfile	pointer
&&	O
!	O
redefine	int
)	O
fprintf	function
(	O
errfile	pointer
,	O
"%s: function '%s' defined on line %d of '%s' is redefined on line %d of '%s'.\n"	pointer
,	O
progname	pointer
,	O
unitname	pointer
,	O
funcentry	pointer
->	O
linenumber	int
,	O
funcentry	pointer
->	O
file	pointer
,	O
linenum	int
,	O
file	pointer
)	O
;	O
freefunction	function
(	O
funcentry	pointer
)	O
;	O
}	O
else	O
{	O
funcentry	pointer
=	O
(	O
struct	O
func	pointer
*	O
)	O
mymalloc	function
(	O
sizeof	O
(	O
struct	O
func	pointer
)	O
,	O
"(newfunction)"	pointer
)	O
;	O
funcentry	pointer
->	O
name	pointer
=	O
dupstr	function
(	O
unitname	pointer
)	O
;	O
addfunction	function
(	O
funcentry	pointer
)	O
;	O
(	O
*	O
count	pointer
)	O
++	O
;	O
}	O
funcentry	pointer
->	O
table	O
=	O
0	int
;	O
funcentry	pointer
->	O
skip_error_check	O
=	O
noerror	int
;	O
funcentry	pointer
->	O
forward	O
.	O
dimen	pointer
=	O
forward_dim	pointer
;	O
funcentry	pointer
->	O
inverse	int
.	O
dimen	pointer
=	O
inverse_dim	pointer
;	O
funcentry	pointer
->	O
forward	O
.	O
domain_min	pointer
=	O
domain_min	pointer
;	O
funcentry	pointer
->	O
forward	O
.	O
domain_max	pointer
=	O
domain_max	pointer
;	O
funcentry	pointer
->	O
inverse	int
.	O
domain_min	pointer
=	O
range_min	pointer
;	O
funcentry	pointer
->	O
inverse	int
.	O
domain_max	pointer
=	O
range_max	pointer
;	O
funcentry	pointer
->	O
forward	O
.	O
domain_min_open	int
=	O
domain_min_open	int
;	O
funcentry	pointer
->	O
forward	O
.	O
domain_max_open	int
=	O
domain_max_open	int
;	O
funcentry	pointer
->	O
inverse	int
.	O
domain_min_open	int
=	O
range_min_open	int
;	O
funcentry	pointer
->	O
inverse	int
.	O
domain_max_open	int
=	O
range_max_open	int
;	O
inv	pointer
=	O
strchr	O
(	O
unitdef	pointer
,	O
FUNCSEPCHAR	char
)	O
;	O
if	O
(	O
inv	pointer
)	O
*	O
inv	pointer
++	O
=	O
0	int
;	O
funcentry	pointer
->	O
forward	O
.	O
param	O
=	O
dupstr	function
(	O
start	pointer
)	O
;	O
removespaces	function
(	O
unitdef	pointer
)	O
;	O
funcentry	pointer
->	O
forward	O
.	O
def	pointer
=	O
dupstr	function
(	O
unitdef	pointer
)	O
;	O
if	O
(	O
inv	pointer
)	O
{	O
removespaces	function
(	O
inv	pointer
)	O
;	O
funcentry	pointer
->	O
inverse	int
.	O
def	pointer
=	O
dupstr	function
(	O
inv	pointer
)	O
;	O
funcentry	pointer
->	O
inverse	int
.	O
param	O
=	O
dupstr	function
(	O
unitname	pointer
)	O
;	O
}	O
else	O
{	O
funcentry	pointer
->	O
inverse	int
.	O
def	pointer
=	O
0	int
;	O
funcentry	pointer
->	O
inverse	int
.	O
param	O
=	O
0	int
;	O
}	O
funcentry	pointer
->	O
linenumber	int
=	O
linenum	int
;	O
funcentry	pointer
->	O
file	pointer
=	O
file	pointer
;	O
return	O
0	int
;	O
}	O
int	O
newtable	function
(	O
char	O
*	O
unitname	pointer
,	O
char	O
*	O
unitdef	pointer
,	O
int	O
*	O
count	pointer
,	O
int	O
linenum	int
,	O
char	O
*	O
file	pointer
,	O
FILE	O
*	O
errfile	pointer
,	O
int	O
redefine	int
)	O
{	O
char	O
*	O
start	pointer
,	O
*	O
end	pointer
;	O
char	O
*	O
tableunit	pointer
;	O
int	O
tablealloc	int
,	O
tabpt	int
;	O
struct	O
pair	O
*	O
tab	pointer
;	O
struct	O
func	pointer
*	O
funcentry	pointer
;	O
int	O
noerror	int
=	O
0	int
;	O
tableunit	pointer
=	O
strchr	O
(	O
unitname	pointer
,	O
'['	O
)	O
;	O
end	pointer
=	O
strchr	O
(	O
unitname	pointer
,	O
']'	O
)	O
;	O
*	O
tableunit	pointer
++	O
=	O
0	int
;	O
if	O
(	O
checkunitname	function
(	O
unitname	pointer
,	O
linenum	int
,	O
file	pointer
,	O
errfile	pointer
)	O
)	O
return	O
E_BADFILE	O
;	O
if	O
(	O
!	O
end	pointer
)	O
{	O
if	O
(	O
errfile	pointer
)	O
fprintf	function
(	O
errfile	pointer
,	O
"%s: missing ']' in units file '%s' line %d\n"	pointer
,	O
progname	pointer
,	O
file	pointer
,	O
linenum	int
)	O
;	O
return	O
E_BADFILE	O
;	O
}	O
if	O
(	O
strlen	O
(	O
end	pointer
)	O
>	O
1	int
)	O
{	O
if	O
(	O
errfile	pointer
)	O
fprintf	function
(	O
errfile	pointer
,	O
"%s: unexpected characters after ']' in units file '%s' line %d\n"	pointer
,	O
progname	pointer
,	O
file	pointer
,	O
linenum	int
)	O
;	O
return	O
E_BADFILE	O
;	O
}	O
*	O
end	pointer
=	O
0	int
;	O
tab	pointer
=	O
(	O
struct	O
pair	O
*	O
)	O
mymalloc	function
(	O
sizeof	O
(	O
struct	O
pair	O
)	O
*	O
20	int
,	O
"(newtable)"	pointer
)	O
;	O
tablealloc	int
=	O
20	int
;	O
tabpt	int
=	O
0	int
;	O
start	pointer
=	O
unitdef	pointer
;	O
if	O
(	O
startswith	O
(	O
start	pointer
,	O
NOERROR_KEYWORD	pointer
)	O
)	O
{	O
noerror	int
=	O
1	int
;	O
start	pointer
+=	O
strlen	O
(	O
NOERROR_KEYWORD	pointer
)	O
;	O
removespaces	function
(	O
start	pointer
)	O
;	O
}	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
tabpt	int
>=	O
tablealloc	int
)	O
{	O
tablealloc	int
+=	O
20	int
;	O
tab	pointer
=	O
(	O
struct	O
pair	O
*	O
)	O
realloc	O
(	O
tab	pointer
,	O
sizeof	O
(	O
struct	O
pair	O
)	O
*	O
tablealloc	int
)	O
;	O
if	O
(	O
!	O
tab	pointer
)	O
{	O
if	O
(	O
errfile	pointer
)	O
fprintf	function
(	O
errfile	pointer
,	O
"%s: memory allocation error (newtable)\n"	pointer
,	O
progname	pointer
)	O
;	O
return	O
E_MEMORY	O
;	O
}	O
}	O
tab	pointer
[	O
tabpt	int
]	O
.	O
location	O
=	O
strtod	O
(	O
start	pointer
,	O
&	O
end	pointer
)	O
;	O
if	O
(	O
start	pointer
==	O
end	pointer
||	O
(	O
!	O
emptystr	O
(	O
end	pointer
)	O
&&	O
*	O
end	pointer
!=	O
' '	O
)	O
)	O
{	O
if	O
(	O
!	O
emptystr	O
(	O
start	pointer
)	O
)	O
{	O
if	O
(	O
strlen	O
(	O
start	pointer
)	O
>	O
15	int
)	O
start	pointer
[	O
15	int
]	O
=	O
0	int
;	O
if	O
(	O
errfile	pointer
)	O
fprintf	function
(	O
errfile	pointer
,	O
"%s: cannot parse table definition %s at '%s' on line %d of '%s'\n"	pointer
,	O
progname	pointer
,	O
unitname	pointer
,	O
start	pointer
,	O
linenum	int
,	O
file	pointer
)	O
;	O
free	function
(	O
tab	pointer
)	O
;	O
return	O
E_BADFILE	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
tabpt	int
>	O
0	int
&&	O
tab	pointer
[	O
tabpt	int
]	O
.	O
location	O
<=	O
tab	pointer
[	O
tabpt	int
-	O
1	int
]	O
.	O
location	O
)	O
{	O
if	O
(	O
errfile	pointer
)	O
fprintf	function
(	O
errfile	pointer
,	O
"%s: points don't increase (%.8g to %.8g) in units file '%s' line %d\n"	pointer
,	O
progname	pointer
,	O
tab	pointer
[	O
tabpt	int
-	O
1	int
]	O
.	O
location	O
,	O
tab	pointer
[	O
tabpt	int
]	O
.	O
location	O
,	O
file	pointer
,	O
linenum	int
)	O
;	O
free	function
(	O
tab	pointer
)	O
;	O
return	O
E_BADFILE	O
;	O
}	O
start	pointer
=	O
end	pointer
+	O
strspn	O
(	O
end	pointer
,	O
" "	pointer
)	O
;	O
tab	pointer
[	O
tabpt	int
]	O
.	O
value	pointer
=	O
strtod	O
(	O
start	pointer
,	O
&	O
end	pointer
)	O
;	O
if	O
(	O
start	pointer
==	O
end	pointer
)	O
{	O
if	O
(	O
errfile	pointer
)	O
fprintf	function
(	O
errfile	pointer
,	O
"%s: missing value after %.8g in units file '%s' line %d\n"	pointer
,	O
progname	pointer
,	O
tab	pointer
[	O
tabpt	int
]	O
.	O
location	O
,	O
file	pointer
,	O
linenum	int
)	O
;	O
free	function
(	O
tab	pointer
)	O
;	O
return	O
E_BADFILE	O
;	O
}	O
tabpt	int
++	O
;	O
start	pointer
=	O
end	pointer
+	O
strspn	O
(	O
end	pointer
,	O
" ,"	pointer
)	O
;	O
}	O
if	O
(	O
(	O
funcentry	pointer
=	O
fnlookup	function
(	O
unitname	pointer
)	O
)	O
)	O
{	O
if	O
(	O
flags	struct
.	O
unitcheck	int
&&	O
errfile	pointer
&&	O
!	O
redefine	int
)	O
fprintf	function
(	O
errfile	pointer
,	O
"%s: unit '%s' defined on line %d of '%s' is redefined on line %d of '%s'.\n"	pointer
,	O
progname	pointer
,	O
unitname	pointer
,	O
funcentry	pointer
->	O
linenumber	int
,	O
funcentry	pointer
->	O
file	pointer
,	O
linenum	int
,	O
file	pointer
)	O
;	O
freefunction	function
(	O
funcentry	pointer
)	O
;	O
}	O
else	O
{	O
funcentry	pointer
=	O
(	O
struct	O
func	pointer
*	O
)	O
mymalloc	function
(	O
sizeof	O
(	O
struct	O
func	pointer
)	O
,	O
"(newtable)"	pointer
)	O
;	O
funcentry	pointer
->	O
name	pointer
=	O
dupstr	function
(	O
unitname	pointer
)	O
;	O
addfunction	function
(	O
funcentry	pointer
)	O
;	O
(	O
*	O
count	pointer
)	O
++	O
;	O
}	O
funcentry	pointer
->	O
tableunit	pointer
=	O
dupstr	function
(	O
tableunit	pointer
)	O
;	O
funcentry	pointer
->	O
tablelen	O
=	O
tabpt	int
;	O
funcentry	pointer
->	O
table	O
=	O
tab	pointer
;	O
funcentry	pointer
->	O
skip_error_check	O
=	O
noerror	int
;	O
funcentry	pointer
->	O
linenumber	int
=	O
linenum	int
;	O
funcentry	pointer
->	O
file	pointer
=	O
file	pointer
;	O
return	O
0	int
;	O
}	O
int	O
newalias	function
(	O
char	O
*	O
unitname	pointer
,	O
char	O
*	O
unitdef	pointer
,	O
int	O
linenum	int
,	O
char	O
*	O
file	pointer
,	O
FILE	O
*	O
errfile	pointer
)	O
{	O
struct	O
wantalias	struct
*	O
aliasentry	pointer
;	O
if	O
(	O
!	O
strchr	O
(	O
unitdef	pointer
,	O
UNITSEPCHAR	char
)	O
)	O
{	O
if	O
(	O
errfile	pointer
)	O
fprintf	function
(	O
errfile	pointer
,	O
"%s: unit list missing '%c' on line %d of '%s'\n"	pointer
,	O
progname	pointer
,	O
UNITSEPCHAR	char
,	O
linenum	int
,	O
file	pointer
)	O
;	O
return	O
E_BADFILE	O
;	O
}	O
if	O
(	O
(	O
aliasentry	pointer
=	O
aliaslookup	function
(	O
unitname	pointer
)	O
)	O
)	O
{	O
if	O
(	O
flags	struct
.	O
unitcheck	int
&&	O
errfile	pointer
)	O
fprintf	function
(	O
errfile	pointer
,	O
"%s: unit list '%s' defined on line %d of '%s' is redefined on line %d of '%s'.\n"	pointer
,	O
progname	pointer
,	O
unitname	pointer
,	O
aliasentry	pointer
->	O
linenumber	int
,	O
aliasentry	pointer
->	O
file	pointer
,	O
linenum	int
,	O
file	pointer
)	O
;	O
free	function
(	O
aliasentry	pointer
->	O
definition	pointer
)	O
;	O
}	O
else	O
{	O
aliasentry	pointer
=	O
(	O
struct	O
wantalias	struct
*	O
)	O
mymalloc	function
(	O
sizeof	O
(	O
struct	O
wantalias	struct
)	O
,	O
"(newalias)"	pointer
)	O
;	O
aliasentry	pointer
->	O
name	pointer
=	O
dupstr	function
(	O
unitname	pointer
)	O
;	O
aliasentry	pointer
->	O
next	pointer
=	O
0	int
;	O
*	O
aliaslistend	pointer
=	O
aliasentry	pointer
;	O
aliaslistend	pointer
=	O
&	O
aliasentry	pointer
->	O
next	pointer
;	O
}	O
aliasentry	pointer
->	O
definition	pointer
=	O
dupstr	function
(	O
unitdef	pointer
)	O
;	O
aliasentry	pointer
->	O
linenumber	int
=	O
linenum	int
;	O
aliasentry	pointer
->	O
file	pointer
=	O
file	pointer
;	O
return	O
0	int
;	O
}	O
int	O
checkvar	function
(	O
char	O
*	O
name	pointer
,	O
char	O
*	O
list	pointer
)	O
{	O
char	O
*	O
listitem	pointer
;	O
name	pointer
=	O
getenv	function
(	O
name	pointer
)	O
;	O
if	O
(	O
!	O
name	pointer
)	O
return	O
2	int
;	O
listitem	pointer
=	O
strtok	O
(	O
list	pointer
,	O
" "	pointer
)	O
;	O
while	O
(	O
listitem	pointer
)	O
{	O
if	O
(	O
!	O
strcmp	O
(	O
name	pointer
,	O
listitem	pointer
)	O
)	O
return	O
1	int
;	O
listitem	pointer
=	O
strtok	O
(	O
0	int
,	O
" "	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
char	O
*	O
pathend	function
(	O
char	O
*	O
filename	pointer
)	O
{	O
char	O
*	O
pointer	pointer
;	O
for	O
(	O
pointer	pointer
=	O
filename	pointer
+	O
strlen	O
(	O
filename	pointer
)	O
;	O
pointer	pointer
>	O
filename	pointer
;	O
pointer	pointer
--	O
)	O
{	O
if	O
(	O
isdirsep	O
(	O
*	O
pointer	pointer
)	O
)	O
{	O
pointer	pointer
++	O
;	O
break	O
;	O
}	O
}	O
return	O
pointer	pointer
;	O
}	O
int	O
isfullpath	function
(	O
char	O
*	O
path	pointer
)	O
{	O
return	O
isdirsep	O
(	O
*	O
path	pointer
)	O
;	O
}	O
int	O
readunits	function
(	O
char	O
*	O
file	pointer
,	O
FILE	O
*	O
errfile	pointer
,	O
int	O
*	O
unitcount	pointer
,	O
int	O
*	O
prefixcount	pointer
,	O
int	O
*	O
funccount	pointer
,	O
int	O
depth	int
)	O
{	O
FILE	O
*	O
unitfile	O
;	O
char	O
*	O
line	pointer
=	O
0	int
,	O
*	O
lineptr	pointer
,	O
*	O
unitdef	pointer
,	O
*	O
unitname	pointer
,	O
*	O
permfile	pointer
;	O
int	O
linenum	int
,	O
linebufsize	int
,	O
goterr	int
,	O
retcode	int
;	O
int	O
locunitcount	int
,	O
locprefixcount	int
,	O
locfunccount	int
,	O
redefinition	int
;	O
int	O
wronglocale	int
=	O
0	int
;	O
int	O
inlocale	int
=	O
0	int
;	O
int	O
in_utf8	int
=	O
0	int
;	O
int	O
invar	int
=	O
0	int
;	O
int	O
wrongvar	int
=	O
0	int
;	O
locunitcount	int
=	O
0	int
;	O
locprefixcount	int
=	O
0	int
;	O
locfunccount	int
=	O
0	int
;	O
linenum	int
=	O
0	int
;	O
linebufsize	int
=	O
0	int
;	O
goterr	int
=	O
0	int
;	O
unitfile	O
=	O
fopen	function
(	O
file	pointer
,	O
"rt"	pointer
)	O
;	O
if	O
(	O
!	O
unitfile	O
)	O
return	O
E_FILE	O
;	O
growbuffer	function
(	O
&	O
line	pointer
,	O
&	O
linebufsize	int
)	O
;	O
permfile	pointer
=	O
dupstr	function
(	O
file	pointer
)	O
;	O
while	O
(	O
!	O
feof	function
(	O
unitfile	O
)	O
)	O
{	O
if	O
(	O
!	O
fgetslong	function
(	O
&	O
line	pointer
,	O
&	O
linebufsize	int
,	O
unitfile	O
,	O
&	O
linenum	int
)	O
)	O
break	O
;	O
if	O
(	O
linenum	int
==	O
1	int
&&	O
startswith	O
(	O
line	pointer
,	O
UTF8MARKER	pointer
)	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
lineptr	pointer
=	O
line	pointer
,	O
i	int
=	O
0	int
;	O
i	int
<	O
strlen	O
(	O
UTF8MARKER	pointer
)	O
;	O
i	int
++	O
,	O
lineptr	pointer
++	O
)	O
*	O
lineptr	pointer
=	O
' '	O
;	O
}	O
strip_comment	function
(	O
line	pointer
)	O
;	O
if	O
(	O
-	O
1	int
==	O
strwidth	function
(	O
line	pointer
)	O
)	O
{	O
readerror	O
(	O
errfile	pointer
,	O
"%s: %s on line %d of '%s'\n"	pointer
,	O
progname	pointer
,	O
invalid_utf8	pointer
,	O
linenum	int
,	O
file	pointer
)	O
;	O
continue	O
;	O
}	O
replace_minus	function
(	O
line	pointer
)	O
;	O
if	O
(	O
*	O
line	pointer
==	O
COMMANDCHAR	char
)	O
{	O
unitname	pointer
=	O
strtok	O
(	O
line	pointer
+	O
1	int
,	O
" "	pointer
)	O
;	O
if	O
(	O
!	O
unitname	pointer
)	O
{	O
readerror	O
(	O
errfile	pointer
,	O
VAGUE_ERR	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
strcmp	O
(	O
unitname	pointer
,	O
"var"	pointer
)	O
||	O
!	O
strcmp	O
(	O
unitname	pointer
,	O
"varnot"	pointer
)	O
)	O
{	O
int	O
not	int
=	O
0	int
;	O
if	O
(	O
unitname	pointer
[	O
3	int
]	O
==	O
'n'	O
)	O
not	int
=	O
1	int
;	O
unitname	pointer
=	O
strtok	O
(	O
0	int
,	O
" "	pointer
)	O
;	O
unitdef	pointer
=	O
strtok	O
(	O
0	int
,	O
""	pointer
)	O
;	O
if	O
(	O
!	O
unitname	pointer
)	O
readerror	O
(	O
errfile	pointer
,	O
"%s: no variable name specified on line %d of '%s'\n"	pointer
,	O
progname	pointer
,	O
linenum	int
,	O
file	pointer
)	O
;	O
else	O
if	O
(	O
!	O
unitdef	pointer
)	O
readerror	O
(	O
errfile	pointer
,	O
"%s: no value specified on line %d of '%s'\n"	pointer
,	O
progname	pointer
,	O
linenum	int
,	O
file	pointer
)	O
;	O
else	O
if	O
(	O
invar	int
)	O
readerror	O
(	O
errfile	pointer
,	O
"%s: nested var statements not allowed, line %d of '%s'\n"	pointer
,	O
progname	pointer
,	O
linenum	int
,	O
file	pointer
)	O
;	O
else	O
{	O
int	O
check	int
;	O
invar	int
=	O
1	int
;	O
check	int
=	O
checkvar	function
(	O
unitname	pointer
,	O
unitdef	pointer
)	O
;	O
if	O
(	O
check	int
==	O
2	int
)	O
{	O
readerror	O
(	O
errfile	pointer
,	O
"%s: environment variable %s not set at line %d of '%s'\n"	pointer
,	O
progname	pointer
,	O
unitname	pointer
,	O
linenum	int
,	O
file	pointer
)	O
;	O
wrongvar	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
!	O
(	O
not	int
^	O
check	int
)	O
)	O
wrongvar	int
=	O
1	int
;	O
}	O
continue	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	O
(	O
unitname	pointer
,	O
"endvar"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
invar	int
)	O
readerror	O
(	O
errfile	pointer
,	O
"%s: unmatched !endvar on line %d of '%s'\n"	pointer
,	O
progname	pointer
,	O
linenum	int
,	O
file	pointer
)	O
;	O
wrongvar	int
=	O
0	int
;	O
invar	int
=	O
0	int
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	O
(	O
unitname	pointer
,	O
"locale"	pointer
)	O
)	O
{	O
unitname	pointer
=	O
strtok	O
(	O
0	int
,	O
" "	pointer
)	O
;	O
if	O
(	O
!	O
unitname	pointer
)	O
readerror	O
(	O
errfile	pointer
,	O
"%s: no locale specified on line %d of '%s'\n"	pointer
,	O
progname	pointer
,	O
linenum	int
,	O
file	pointer
)	O
;	O
else	O
if	O
(	O
inlocale	int
)	O
readerror	O
(	O
errfile	pointer
,	O
"%s: nested locales not allowed, line %d of '%s'\n"	pointer
,	O
progname	pointer
,	O
linenum	int
,	O
file	pointer
)	O
;	O
else	O
{	O
inlocale	int
=	O
1	int
;	O
if	O
(	O
strcmp	O
(	O
unitname	pointer
,	O
mylocale	pointer
)	O
)	O
wronglocale	int
=	O
1	int
;	O
}	O
continue	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	O
(	O
unitname	pointer
,	O
"endlocale"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
inlocale	int
)	O
readerror	O
(	O
errfile	pointer
,	O
"%s: unmatched !endlocale on line %d of '%s'\n"	pointer
,	O
progname	pointer
,	O
linenum	int
,	O
file	pointer
)	O
;	O
wronglocale	int
=	O
0	int
;	O
inlocale	int
=	O
0	int
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	O
(	O
unitname	pointer
,	O
"utf8"	pointer
)	O
)	O
{	O
if	O
(	O
in_utf8	int
)	O
readerror	O
(	O
errfile	pointer
,	O
"%s: nested utf8 not allowed, line %d of '%s'\n"	pointer
,	O
progname	pointer
,	O
linenum	int
,	O
file	pointer
)	O
;	O
else	O
in_utf8	int
=	O
1	int
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	O
(	O
unitname	pointer
,	O
"endutf8"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
in_utf8	int
)	O
readerror	O
(	O
errfile	pointer
,	O
"%s: unmatched !endutf8 on line %d of '%s'\n"	pointer
,	O
progname	pointer
,	O
linenum	int
,	O
file	pointer
)	O
;	O
in_utf8	int
=	O
0	int
;	O
continue	O
;	O
}	O
if	O
(	O
in_utf8	int
&&	O
!	O
utf8mode	int
)	O
continue	O
;	O
if	O
(	O
wronglocale	int
||	O
wrongvar	int
)	O
continue	O
;	O
if	O
(	O
!	O
strcmp	O
(	O
unitname	pointer
,	O
"prompt"	pointer
)	O
)	O
{	O
unitname	pointer
=	O
strtok	O
(	O
0	int
,	O
""	pointer
)	O
;	O
if	O
(	O
promptprefix	pointer
)	O
free	function
(	O
promptprefix	pointer
)	O
;	O
if	O
(	O
!	O
unitname	pointer
)	O
promptprefix	pointer
=	O
0	int
;	O
else	O
promptprefix	pointer
=	O
dupstr	function
(	O
unitname	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
strcmp	O
(	O
unitname	pointer
,	O
"message"	pointer
)	O
)	O
{	O
unitname	pointer
=	O
strtok	O
(	O
0	int
,	O
""	pointer
)	O
;	O
if	O
(	O
!	O
flags	struct
.	O
quiet	int
)	O
{	O
if	O
(	O
unitname	pointer
)	O
logputs	function
(	O
unitname	pointer
)	O
;	O
logputchar	function
(	O
'\n'	O
)	O
;	O
}	O
continue	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	O
(	O
unitname	pointer
,	O
"set"	pointer
)	O
)	O
{	O
unitname	pointer
=	O
strtok	O
(	O
0	int
,	O
" "	pointer
)	O
;	O
unitdef	pointer
=	O
strtok	O
(	O
0	int
,	O
" "	pointer
)	O
;	O
if	O
(	O
!	O
unitname	pointer
)	O
readerror	O
(	O
errfile	pointer
,	O
"%s: no variable name specified on line %d of '%s'\n"	pointer
,	O
progname	pointer
,	O
linenum	int
,	O
file	pointer
)	O
;	O
else	O
if	O
(	O
!	O
unitdef	pointer
)	O
readerror	O
(	O
errfile	pointer
,	O
"%s: no value specified on line %d of '%s'\n"	pointer
,	O
progname	pointer
,	O
linenum	int
,	O
file	pointer
)	O
;	O
else	O
setenv	function
(	O
unitname	pointer
,	O
unitdef	pointer
,	O
0	int
)	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	O
(	O
unitname	pointer
,	O
"unitlist"	pointer
)	O
)	O
{	O
splitline	function
(	O
0	int
,	O
&	O
unitname	pointer
,	O
&	O
unitdef	pointer
)	O
;	O
if	O
(	O
!	O
unitname	pointer
||	O
!	O
unitdef	pointer
)	O
readerror	O
(	O
errfile	pointer
,	O
VAGUE_ERR	O
)	O
;	O
else	O
{	O
if	O
(	O
newalias	function
(	O
unitname	pointer
,	O
unitdef	pointer
,	O
linenum	int
,	O
permfile	pointer
,	O
errfile	pointer
)	O
)	O
goterr	int
=	O
1	int
;	O
}	O
continue	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	O
(	O
unitname	pointer
,	O
"include"	pointer
)	O
)	O
{	O
if	O
(	O
depth	int
>	O
MAXINCLUDE	int
)	O
{	O
readerror	O
(	O
errfile	pointer
,	O
"%s: max include depth of %d exceeded in file '%s' line %d\n"	pointer
,	O
progname	pointer
,	O
MAXINCLUDE	int
,	O
file	pointer
,	O
linenum	int
)	O
;	O
}	O
else	O
{	O
int	O
readerr	int
;	O
char	O
*	O
includefile	pointer
;	O
unitname	pointer
=	O
strtok	O
(	O
0	int
,	O
" "	pointer
)	O
;	O
if	O
(	O
!	O
unitname	pointer
)	O
{	O
readerror	O
(	O
errfile	pointer
,	O
"%s: missing include filename on line %d of '%s'\n"	pointer
,	O
progname	pointer
,	O
linenum	int
,	O
file	pointer
)	O
;	O
continue	O
;	O
}	O
includefile	pointer
=	O
mymalloc	function
(	O
strlen	O
(	O
file	pointer
)	O
+	O
strlen	O
(	O
unitname	pointer
)	O
+	O
1	int
,	O
"(readunits)"	pointer
)	O
;	O
if	O
(	O
isfullpath	function
(	O
unitname	pointer
)	O
)	O
strcpy	O
(	O
includefile	pointer
,	O
unitname	pointer
)	O
;	O
else	O
{	O
strcpy	O
(	O
includefile	pointer
,	O
file	pointer
)	O
;	O
strcpy	O
(	O
pathend	function
(	O
includefile	pointer
)	O
,	O
unitname	pointer
)	O
;	O
}	O
readerr	int
=	O
readunits	function
(	O
includefile	pointer
,	O
errfile	pointer
,	O
unitcount	pointer
,	O
prefixcount	pointer
,	O
funccount	pointer
,	O
depth	int
+	O
1	int
)	O
;	O
if	O
(	O
readerr	int
==	O
E_MEMORY	O
)	O
{	O
fclose	function
(	O
unitfile	O
)	O
;	O
free	function
(	O
line	pointer
)	O
;	O
free	function
(	O
includefile	pointer
)	O
;	O
return	O
readerr	int
;	O
}	O
if	O
(	O
readerr	int
==	O
E_FILE	O
)	O
{	O
readerror	O
(	O
errfile	pointer
,	O
"%s: cannot open included file '%s' at line %d of file '%s\n"	pointer
,	O
progname	pointer
,	O
includefile	pointer
,	O
linenum	int
,	O
file	pointer
)	O
;	O
}	O
if	O
(	O
readerr	int
)	O
goterr	int
=	O
1	int
;	O
free	function
(	O
includefile	pointer
)	O
;	O
}	O
}	O
else	O
readerror	O
(	O
errfile	pointer
,	O
VAGUE_ERR	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
in_utf8	int
&&	O
!	O
utf8mode	int
)	O
continue	O
;	O
if	O
(	O
wronglocale	int
||	O
wrongvar	int
)	O
continue	O
;	O
splitline	function
(	O
line	pointer
,	O
&	O
unitname	pointer
,	O
&	O
unitdef	pointer
)	O
;	O
if	O
(	O
!	O
unitname	pointer
)	O
continue	O
;	O
if	O
(	O
!	O
unitdef	pointer
)	O
{	O
readerror	O
(	O
errfile	pointer
,	O
"%s: unit '%s' lacks a definition at line %d of '%s'\n"	pointer
,	O
progname	pointer
,	O
unitname	pointer
,	O
linenum	int
,	O
file	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
*	O
unitname	pointer
==	O
REDEFCHAR	char
)	O
{	O
unitname	pointer
++	O
;	O
redefinition	int
=	O
1	int
;	O
}	O
else	O
redefinition	int
=	O
0	int
;	O
if	O
(	O
lastchar	O
(	O
unitname	pointer
)	O
==	O
'-'	O
)	O
{	O
if	O
(	O
newprefix	function
(	O
unitname	pointer
,	O
unitdef	pointer
,	O
&	O
locprefixcount	int
,	O
linenum	int
,	O
permfile	pointer
,	O
errfile	pointer
,	O
redefinition	int
)	O
)	O
goterr	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
strchr	O
(	O
unitname	pointer
,	O
'['	O
)	O
)	O
{	O
retcode	int
=	O
newtable	function
(	O
unitname	pointer
,	O
unitdef	pointer
,	O
&	O
locfunccount	int
,	O
linenum	int
,	O
permfile	pointer
,	O
errfile	pointer
,	O
redefinition	int
)	O
;	O
if	O
(	O
retcode	int
)	O
{	O
if	O
(	O
retcode	int
!=	O
E_BADFILE	O
)	O
{	O
fclose	function
(	O
unitfile	O
)	O
;	O
free	function
(	O
line	pointer
)	O
;	O
return	O
retcode	int
;	O
}	O
goterr	int
=	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
strchr	O
(	O
unitname	pointer
,	O
'('	O
)	O
)	O
{	O
if	O
(	O
newfunction	function
(	O
unitname	pointer
,	O
unitdef	pointer
,	O
&	O
locfunccount	int
,	O
linenum	int
,	O
permfile	pointer
,	O
errfile	pointer
,	O
redefinition	int
)	O
)	O
goterr	int
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
newunit	function
(	O
unitname	pointer
,	O
unitdef	pointer
,	O
&	O
locunitcount	int
,	O
linenum	int
,	O
permfile	pointer
,	O
errfile	pointer
,	O
redefinition	int
)	O
)	O
goterr	int
=	O
1	int
;	O
}	O
}	O
fclose	function
(	O
unitfile	O
)	O
;	O
free	function
(	O
line	pointer
)	O
;	O
if	O
(	O
unitcount	pointer
)	O
*	O
unitcount	pointer
+=	O
locunitcount	int
;	O
if	O
(	O
prefixcount	pointer
)	O
*	O
prefixcount	pointer
+=	O
locprefixcount	int
;	O
if	O
(	O
funccount	pointer
)	O
*	O
funccount	pointer
+=	O
locfunccount	int
;	O
if	O
(	O
goterr	int
)	O
return	O
E_BADFILE	O
;	O
else	O
return	O
0	int
;	O
}	O
void	O
initializeunit	function
(	O
struct	O
unittype	O
*	O
theunit	pointer
)	O
{	O
theunit	pointer
->	O
factor	double
=	O
1.0	int
;	O
theunit	pointer
->	O
numerator	O
[	O
0	int
]	O
=	O
theunit	pointer
->	O
denominator	O
[	O
0	int
]	O
=	O
NULL	O
;	O
}	O
void	O
freeunit	function
(	O
struct	O
unittype	O
*	O
theunit	pointer
)	O
{	O
char	O
*	O
*	O
ptr	pointer
;	O
for	O
(	O
ptr	pointer
=	O
theunit	pointer
->	O
numerator	O
;	O
*	O
ptr	pointer
;	O
ptr	pointer
++	O
)	O
if	O
(	O
*	O
ptr	pointer
!=	O
NULLUNIT	pointer
)	O
free	function
(	O
*	O
ptr	pointer
)	O
;	O
for	O
(	O
ptr	pointer
=	O
theunit	pointer
->	O
denominator	O
;	O
*	O
ptr	pointer
;	O
ptr	pointer
++	O
)	O
if	O
(	O
*	O
ptr	pointer
!=	O
NULLUNIT	pointer
)	O
free	function
(	O
*	O
ptr	pointer
)	O
;	O
theunit	pointer
->	O
numerator	O
[	O
0	int
]	O
=	O
0	int
;	O
theunit	pointer
->	O
denominator	O
[	O
0	int
]	O
=	O
0	int
;	O
}	O
void	O
showunit	function
(	O
struct	O
unittype	O
*	O
theunit	pointer
)	O
{	O
char	O
*	O
*	O
ptr	pointer
;	O
int	O
printedslash	int
;	O
int	O
counter	int
=	O
1	int
;	O
logprintf	function
(	O
num_format	struct
.	O
format	pointer
,	O
theunit	pointer
->	O
factor	double
)	O
;	O
for	O
(	O
ptr	pointer
=	O
theunit	pointer
->	O
numerator	O
;	O
*	O
ptr	pointer
;	O
ptr	pointer
++	O
)	O
{	O
if	O
(	O
ptr	pointer
>	O
theunit	pointer
->	O
numerator	O
&&	O
*	O
*	O
ptr	pointer
&&	O
!	O
strcmp	O
(	O
*	O
ptr	pointer
,	O
*	O
(	O
ptr	pointer
-	O
1	int
)	O
)	O
)	O
counter	int
++	O
;	O
else	O
{	O
if	O
(	O
counter	int
>	O
1	int
)	O
logprintf	function
(	O
"%s%d"	pointer
,	O
powerstring	pointer
,	O
counter	int
)	O
;	O
if	O
(	O
*	O
*	O
ptr	pointer
)	O
logprintf	function
(	O
" %s"	pointer
,	O
*	O
ptr	pointer
)	O
;	O
counter	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
counter	int
>	O
1	int
)	O
logprintf	function
(	O
"%s%d"	pointer
,	O
powerstring	pointer
,	O
counter	int
)	O
;	O
counter	int
=	O
1	int
;	O
printedslash	int
=	O
0	int
;	O
for	O
(	O
ptr	pointer
=	O
theunit	pointer
->	O
denominator	O
;	O
*	O
ptr	pointer
;	O
ptr	pointer
++	O
)	O
{	O
if	O
(	O
ptr	pointer
>	O
theunit	pointer
->	O
denominator	O
&&	O
*	O
*	O
ptr	pointer
&&	O
!	O
strcmp	O
(	O
*	O
ptr	pointer
,	O
*	O
(	O
ptr	pointer
-	O
1	int
)	O
)	O
)	O
counter	int
++	O
;	O
else	O
{	O
if	O
(	O
counter	int
>	O
1	int
)	O
logprintf	function
(	O
"%s%d"	pointer
,	O
powerstring	pointer
,	O
counter	int
)	O
;	O
if	O
(	O
*	O
*	O
ptr	pointer
)	O
{	O
if	O
(	O
!	O
printedslash	int
)	O
logprintf	function
(	O
" /"	pointer
)	O
;	O
printedslash	int
=	O
1	int
;	O
logprintf	function
(	O
" %s"	pointer
,	O
*	O
ptr	pointer
)	O
;	O
}	O
counter	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
counter	int
>	O
1	int
)	O
logprintf	function
(	O
"%s%d"	pointer
,	O
powerstring	pointer
,	O
counter	int
)	O
;	O
}	O
int	O
compare	function
(	O
const	O
void	O
*	O
item1	pointer
,	O
const	O
void	O
*	O
item2	pointer
)	O
{	O
return	O
strcmp	O
(	O
*	O
(	O
char	O
*	O
*	O
)	O
item1	pointer
,	O
*	O
(	O
char	O
*	O
*	O
)	O
item2	pointer
)	O
;	O
}	O
void	O
sortunit	function
(	O
struct	O
unittype	O
*	O
theunit	pointer
)	O
{	O
char	O
*	O
*	O
ptr	pointer
;	O
int	O
count	pointer
;	O
for	O
(	O
count	pointer
=	O
0	int
,	O
ptr	pointer
=	O
theunit	pointer
->	O
numerator	O
;	O
*	O
ptr	pointer
;	O
ptr	pointer
++	O
,	O
count	pointer
++	O
)	O
;	O
qsort	function
(	O
theunit	pointer
->	O
numerator	O
,	O
count	pointer
,	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
compare	function
)	O
;	O
for	O
(	O
count	pointer
=	O
0	int
,	O
ptr	pointer
=	O
theunit	pointer
->	O
denominator	O
;	O
*	O
ptr	pointer
;	O
ptr	pointer
++	O
,	O
count	pointer
++	O
)	O
;	O
qsort	function
(	O
theunit	pointer
->	O
denominator	O
,	O
count	pointer
,	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
compare	function
)	O
;	O
}	O
void	O
cancelunit	function
(	O
struct	O
unittype	O
*	O
theunit	pointer
)	O
{	O
char	O
*	O
*	O
den	pointer
,	O
*	O
*	O
num	pointer
;	O
int	O
comp	int
;	O
den	pointer
=	O
theunit	pointer
->	O
denominator	O
;	O
num	pointer
=	O
theunit	pointer
->	O
numerator	O
;	O
while	O
(	O
*	O
num	pointer
&&	O
*	O
den	pointer
)	O
{	O
comp	int
=	O
strcmp	O
(	O
*	O
den	pointer
,	O
*	O
num	pointer
)	O
;	O
if	O
(	O
!	O
comp	int
)	O
{	O
if	O
(	O
*	O
den	pointer
!=	O
NULLUNIT	pointer
)	O
free	function
(	O
*	O
den	pointer
)	O
;	O
if	O
(	O
*	O
num	pointer
!=	O
NULLUNIT	pointer
)	O
free	function
(	O
*	O
num	pointer
)	O
;	O
*	O
den	pointer
++	O
=	O
NULLUNIT	pointer
;	O
*	O
num	pointer
++	O
=	O
NULLUNIT	pointer
;	O
}	O
else	O
if	O
(	O
comp	int
<	O
0	int
)	O
den	pointer
++	O
;	O
else	O
num	pointer
++	O
;	O
}	O
}	O
static	O
int	O
bufsize	pointer
=	O
0	int
;	O
static	O
char	O
*	O
buffer	pointer
;	O
char	O
*	O
lookupunit	function
(	O
char	O
*	O
unit	pointer
,	O
int	O
prefixok	int
)	O
{	O
char	O
*	O
copy	pointer
;	O
struct	O
prefixlist	struct
*	O
pfxptr	pointer
;	O
struct	O
unitlist	struct
*	O
uptr	pointer
;	O
if	O
(	O
(	O
uptr	pointer
=	O
ulookup	function
(	O
unit	pointer
)	O
)	O
)	O
return	O
uptr	pointer
->	O
value	pointer
;	O
if	O
(	O
strwidth	function
(	O
unit	pointer
)	O
>	O
2	int
&&	O
lastchar	O
(	O
unit	pointer
)	O
==	O
's'	O
)	O
{	O
copy	pointer
=	O
dupstr	function
(	O
unit	pointer
)	O
;	O
lastchar	O
(	O
copy	pointer
)	O
=	O
0	int
;	O
if	O
(	O
lookupunit	function
(	O
copy	pointer
,	O
prefixok	int
)	O
)	O
{	O
while	O
(	O
strlen	O
(	O
copy	pointer
)	O
+	O
1	int
>	O
bufsize	pointer
)	O
{	O
growbuffer	function
(	O
&	O
buffer	pointer
,	O
&	O
bufsize	pointer
)	O
;	O
}	O
strcpy	O
(	O
buffer	pointer
,	O
copy	pointer
)	O
;	O
free	function
(	O
copy	pointer
)	O
;	O
return	O
buffer	pointer
;	O
}	O
if	O
(	O
strlen	O
(	O
copy	pointer
)	O
>	O
2	int
&&	O
lastchar	O
(	O
copy	pointer
)	O
==	O
'e'	O
)	O
{	O
lastchar	O
(	O
copy	pointer
)	O
=	O
0	int
;	O
if	O
(	O
lookupunit	function
(	O
copy	pointer
,	O
prefixok	int
)	O
)	O
{	O
while	O
(	O
strlen	O
(	O
copy	pointer
)	O
+	O
1	int
>	O
bufsize	pointer
)	O
{	O
growbuffer	function
(	O
&	O
buffer	pointer
,	O
&	O
bufsize	pointer
)	O
;	O
}	O
strcpy	O
(	O
buffer	pointer
,	O
copy	pointer
)	O
;	O
free	function
(	O
copy	pointer
)	O
;	O
return	O
buffer	pointer
;	O
}	O
}	O
if	O
(	O
strlen	O
(	O
copy	pointer
)	O
>	O
2	int
&&	O
lastchar	O
(	O
copy	pointer
)	O
==	O
'i'	O
)	O
{	O
lastchar	O
(	O
copy	pointer
)	O
=	O
'y'	O
;	O
if	O
(	O
lookupunit	function
(	O
copy	pointer
,	O
prefixok	int
)	O
)	O
{	O
while	O
(	O
strlen	O
(	O
copy	pointer
)	O
+	O
1	int
>	O
bufsize	pointer
)	O
{	O
growbuffer	function
(	O
&	O
buffer	pointer
,	O
&	O
bufsize	pointer
)	O
;	O
}	O
strcpy	O
(	O
buffer	pointer
,	O
copy	pointer
)	O
;	O
free	function
(	O
copy	pointer
)	O
;	O
return	O
buffer	pointer
;	O
}	O
}	O
free	function
(	O
copy	pointer
)	O
;	O
}	O
if	O
(	O
prefixok	int
&&	O
(	O
pfxptr	pointer
=	O
plookup	function
(	O
unit	pointer
)	O
)	O
)	O
{	O
copy	pointer
=	O
unit	pointer
+	O
pfxptr	pointer
->	O
len	int
;	O
if	O
(	O
emptystr	O
(	O
copy	pointer
)	O
||	O
lookupunit	function
(	O
copy	pointer
,	O
0	int
)	O
)	O
{	O
char	O
*	O
tempbuf	pointer
;	O
while	O
(	O
strlen	O
(	O
pfxptr	pointer
->	O
value	pointer
)	O
+	O
strlen	O
(	O
copy	pointer
)	O
+	O
2	int
>	O
bufsize	pointer
)	O
{	O
growbuffer	function
(	O
&	O
buffer	pointer
,	O
&	O
bufsize	pointer
)	O
;	O
}	O
tempbuf	pointer
=	O
dupstr	function
(	O
copy	pointer
)	O
;	O
strcpy	O
(	O
buffer	pointer
,	O
pfxptr	pointer
->	O
value	pointer
)	O
;	O
strcat	O
(	O
buffer	pointer
,	O
" "	pointer
)	O
;	O
strcat	O
(	O
buffer	pointer
,	O
tempbuf	pointer
)	O
;	O
free	function
(	O
tempbuf	pointer
)	O
;	O
return	O
buffer	pointer
;	O
}	O
}	O
return	O
0	int
;	O
}	O
int	O
moveproduct	function
(	O
char	O
*	O
product	array
[	O
]	O
,	O
char	O
*	O
tomove	array
[	O
]	O
)	O
{	O
char	O
*	O
*	O
dest	pointer
,	O
*	O
*	O
src	pointer
;	O
dest	pointer
=	O
product	array
;	O
for	O
(	O
src	pointer
=	O
tomove	array
;	O
*	O
src	pointer
;	O
src	pointer
++	O
)	O
{	O
if	O
(	O
*	O
src	pointer
==	O
NULLUNIT	pointer
)	O
continue	O
;	O
for	O
(	O
;	O
*	O
dest	pointer
&&	O
*	O
dest	pointer
!=	O
NULLUNIT	pointer
;	O
dest	pointer
++	O
)	O
;	O
if	O
(	O
dest	pointer
-	O
product	array
>=	O
MAXSUBUNITS	O
-	O
1	int
)	O
{	O
return	O
E_PRODOVERFLOW	O
;	O
}	O
if	O
(	O
!	O
*	O
dest	pointer
)	O
*	O
(	O
dest	pointer
+	O
1	int
)	O
=	O
0	int
;	O
*	O
dest	pointer
=	O
*	O
src	pointer
;	O
*	O
src	pointer
=	O
NULLUNIT	pointer
;	O
}	O
return	O
0	int
;	O
}	O
void	O
copyproduct	function
(	O
char	O
*	O
*	O
dest	pointer
,	O
char	O
*	O
*	O
source	pointer
)	O
{	O
for	O
(	O
;	O
*	O
source	pointer
;	O
source	pointer
++	O
,	O
dest	pointer
++	O
)	O
{	O
if	O
(	O
*	O
source	pointer
==	O
NULLUNIT	pointer
)	O
*	O
dest	pointer
=	O
NULLUNIT	pointer
;	O
else	O
*	O
dest	pointer
=	O
dupstr	function
(	O
*	O
source	pointer
)	O
;	O
}	O
*	O
dest	pointer
=	O
0	int
;	O
}	O
void	O
unitcopy	function
(	O
struct	O
unittype	O
*	O
dest	pointer
,	O
struct	O
unittype	O
*	O
source	pointer
)	O
{	O
dest	pointer
->	O
factor	double
=	O
source	pointer
->	O
factor	double
;	O
copyproduct	function
(	O
dest	pointer
->	O
numerator	O
,	O
source	pointer
->	O
numerator	O
)	O
;	O
copyproduct	function
(	O
dest	pointer
->	O
denominator	O
,	O
source	pointer
->	O
denominator	O
)	O
;	O
}	O
int	O
multunit	function
(	O
struct	O
unittype	O
*	O
left	pointer
,	O
struct	O
unittype	O
*	O
right	pointer
)	O
{	O
int	O
myerr	int
;	O
left	pointer
->	O
factor	double
*=	O
right	pointer
->	O
factor	double
;	O
myerr	int
=	O
moveproduct	function
(	O
left	pointer
->	O
numerator	O
,	O
right	pointer
->	O
numerator	O
)	O
;	O
if	O
(	O
!	O
myerr	int
)	O
myerr	int
=	O
moveproduct	function
(	O
left	pointer
->	O
denominator	O
,	O
right	pointer
->	O
denominator	O
)	O
;	O
return	O
myerr	int
;	O
}	O
int	O
divunit	function
(	O
struct	O
unittype	O
*	O
left	pointer
,	O
struct	O
unittype	O
*	O
right	pointer
)	O
{	O
int	O
myerr	int
;	O
left	pointer
->	O
factor	double
/=	O
right	pointer
->	O
factor	double
;	O
myerr	int
=	O
moveproduct	function
(	O
left	pointer
->	O
numerator	O
,	O
right	pointer
->	O
denominator	O
)	O
;	O
if	O
(	O
!	O
myerr	int
)	O
myerr	int
=	O
moveproduct	function
(	O
left	pointer
->	O
denominator	O
,	O
right	pointer
->	O
numerator	O
)	O
;	O
return	O
myerr	int
;	O
}	O
int	O
reduceproduct	function
(	O
struct	O
unittype	O
*	O
theunit	pointer
,	O
int	O
flip	int
)	O
{	O
char	O
*	O
toadd	pointer
;	O
char	O
*	O
*	O
product	array
;	O
int	O
didsomething	int
=	O
NOREDUCTION	O
;	O
struct	O
unittype	O
newunit	function
;	O
int	O
ret	pointer
;	O
if	O
(	O
flip	int
)	O
product	array
=	O
theunit	pointer
->	O
denominator	O
;	O
else	O
product	array
=	O
theunit	pointer
->	O
numerator	O
;	O
for	O
(	O
;	O
*	O
product	array
;	O
product	array
++	O
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
!	O
strlen	O
(	O
*	O
product	array
)	O
)	O
break	O
;	O
toadd	pointer
=	O
lookupunit	function
(	O
*	O
product	array
,	O
1	int
)	O
;	O
if	O
(	O
!	O
toadd	pointer
)	O
{	O
if	O
(	O
!	O
irreducible	pointer
)	O
irreducible	pointer
=	O
dupstr	function
(	O
*	O
product	array
)	O
;	O
return	O
REDUCTIONERROR	O
;	O
}	O
if	O
(	O
strchr	O
(	O
toadd	pointer
,	O
PRIMITIVECHAR	char
)	O
)	O
break	O
;	O
didsomething	int
=	O
DIDREDUCTION	O
;	O
if	O
(	O
*	O
product	array
!=	O
NULLUNIT	pointer
)	O
{	O
free	function
(	O
*	O
product	array
)	O
;	O
*	O
product	array
=	O
NULLUNIT	pointer
;	O
}	O
if	O
(	O
parseunit	function
(	O
&	O
newunit	function
,	O
toadd	pointer
,	O
0	int
,	O
0	int
)	O
)	O
return	O
REDUCTIONERROR	O
;	O
if	O
(	O
flip	int
)	O
ret	pointer
=	O
divunit	function
(	O
theunit	pointer
,	O
&	O
newunit	function
)	O
;	O
else	O
ret	pointer
=	O
multunit	function
(	O
theunit	pointer
,	O
&	O
newunit	function
)	O
;	O
freeunit	function
(	O
&	O
newunit	function
)	O
;	O
if	O
(	O
ret	pointer
)	O
return	O
REDUCTIONERROR	O
;	O
}	O
}	O
return	O
didsomething	int
;	O
}	O
int	O
reduceunit	function
(	O
struct	O
unittype	O
*	O
theunit	pointer
)	O
{	O
int	O
ret	pointer
;	O
if	O
(	O
irreducible	pointer
)	O
free	function
(	O
irreducible	pointer
)	O
;	O
irreducible	pointer
=	O
0	int
;	O
ret	pointer
=	O
DIDREDUCTION	O
;	O
while	O
(	O
ret	pointer
&	O
DIDREDUCTION	O
)	O
{	O
ret	pointer
=	O
reduceproduct	function
(	O
theunit	pointer
,	O
0	int
)	O
;	O
if	O
(	O
!	O
(	O
ret	pointer
&	O
REDUCTIONERROR	O
)	O
)	O
ret	pointer
|=	O
reduceproduct	function
(	O
theunit	pointer
,	O
1	int
)	O
;	O
if	O
(	O
ret	pointer
&	O
REDUCTIONERROR	O
)	O
{	O
if	O
(	O
irreducible	pointer
)	O
return	O
E_UNKNOWNUNIT	O
;	O
else	O
return	O
E_REDUCE	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
int	O
ignore_dimless	function
(	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
unitlist	struct
*	O
ul	pointer
;	O
if	O
(	O
!	O
name	pointer
)	O
return	O
0	int
;	O
ul	pointer
=	O
ulookup	function
(	O
name	pointer
)	O
;	O
if	O
(	O
ul	pointer
&&	O
!	O
strcmp	O
(	O
ul	pointer
->	O
value	pointer
,	O
NODIM	pointer
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
ignore_nothing	function
(	O
char	O
*	O
name	pointer
)	O
{	O
return	O
0	int
;	O
}	O
int	O
ignore_primitive	function
(	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
unitlist	struct
*	O
ul	pointer
;	O
if	O
(	O
!	O
name	pointer
)	O
return	O
0	int
;	O
ul	pointer
=	O
ulookup	function
(	O
name	pointer
)	O
;	O
if	O
(	O
ul	pointer
&&	O
strchr	O
(	O
ul	pointer
->	O
value	pointer
,	O
PRIMITIVECHAR	char
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
compareproducts	function
(	O
char	O
*	O
*	O
one	pointer
,	O
char	O
*	O
*	O
two	pointer
,	O
int	O
(	O
*	O
isdimless	pointer
)	O
(	O
char	O
*	O
name	pointer
)	O
)	O
{	O
int	O
oneblank	int
,	O
twoblank	int
;	O
while	O
(	O
*	O
one	pointer
||	O
*	O
two	pointer
)	O
{	O
oneblank	int
=	O
(	O
*	O
one	pointer
==	O
NULLUNIT	pointer
)	O
||	O
isdimless	pointer
(	O
*	O
one	pointer
)	O
;	O
twoblank	int
=	O
(	O
*	O
two	pointer
==	O
NULLUNIT	pointer
)	O
||	O
isdimless	pointer
(	O
*	O
two	pointer
)	O
;	O
if	O
(	O
!	O
*	O
one	pointer
&&	O
!	O
twoblank	int
)	O
return	O
1	int
;	O
if	O
(	O
!	O
*	O
two	pointer
&&	O
!	O
oneblank	int
)	O
return	O
1	int
;	O
if	O
(	O
oneblank	int
)	O
one	pointer
++	O
;	O
else	O
if	O
(	O
twoblank	int
)	O
two	pointer
++	O
;	O
else	O
if	O
(	O
strcmp	O
(	O
*	O
one	pointer
,	O
*	O
two	pointer
)	O
)	O
return	O
1	int
;	O
else	O
one	pointer
++	O
,	O
two	pointer
++	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
compareunits	function
(	O
struct	O
unittype	O
*	O
first	pointer
,	O
struct	O
unittype	O
*	O
second	pointer
,	O
int	O
(	O
*	O
isdimless	pointer
)	O
(	O
char	O
*	O
name	pointer
)	O
)	O
{	O
return	O
compareproducts	function
(	O
first	pointer
->	O
numerator	O
,	O
second	pointer
->	O
numerator	O
,	O
isdimless	pointer
)	O
||	O
compareproducts	function
(	O
first	pointer
->	O
denominator	O
,	O
second	pointer
->	O
denominator	O
,	O
isdimless	pointer
)	O
;	O
}	O
int	O
completereduce	function
(	O
struct	O
unittype	O
*	O
unit	pointer
)	O
{	O
int	O
err	int
;	O
if	O
(	O
(	O
err	int
=	O
reduceunit	function
(	O
unit	pointer
)	O
)	O
)	O
return	O
err	int
;	O
sortunit	function
(	O
unit	pointer
)	O
;	O
cancelunit	function
(	O
unit	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
expunit	function
(	O
struct	O
unittype	O
*	O
theunit	pointer
,	O
int	O
power	int
)	O
{	O
char	O
*	O
*	O
numptr	pointer
,	O
*	O
*	O
denptr	pointer
;	O
double	O
thefactor	double
;	O
int	O
i	int
,	O
uind	int
,	O
denlen	int
,	O
numlen	int
;	O
if	O
(	O
power	int
==	O
0	int
)	O
{	O
freeunit	function
(	O
theunit	pointer
)	O
;	O
initializeunit	function
(	O
theunit	pointer
)	O
;	O
return	O
0	int
;	O
}	O
numlen	int
=	O
0	int
;	O
for	O
(	O
numptr	pointer
=	O
theunit	pointer
->	O
numerator	O
;	O
*	O
numptr	pointer
;	O
numptr	pointer
++	O
)	O
numlen	int
++	O
;	O
denlen	int
=	O
0	int
;	O
for	O
(	O
denptr	pointer
=	O
theunit	pointer
->	O
denominator	O
;	O
*	O
denptr	pointer
;	O
denptr	pointer
++	O
)	O
denlen	int
++	O
;	O
thefactor	double
=	O
theunit	pointer
->	O
factor	double
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
power	int
;	O
i	int
++	O
)	O
{	O
theunit	pointer
->	O
factor	double
*=	O
thefactor	double
;	O
for	O
(	O
uind	int
=	O
0	int
;	O
uind	int
<	O
numlen	int
;	O
uind	int
++	O
)	O
{	O
if	O
(	O
theunit	pointer
->	O
numerator	O
[	O
uind	int
]	O
!=	O
NULLUNIT	pointer
)	O
{	O
if	O
(	O
numptr	pointer
-	O
theunit	pointer
->	O
numerator	O
>=	O
MAXSUBUNITS	O
-	O
1	int
)	O
{	O
*	O
numptr	pointer
=	O
*	O
denptr	pointer
=	O
0	int
;	O
return	O
E_PRODOVERFLOW	O
;	O
}	O
*	O
numptr	pointer
++	O
=	O
dupstr	function
(	O
theunit	pointer
->	O
numerator	O
[	O
uind	int
]	O
)	O
;	O
}	O
}	O
for	O
(	O
uind	int
=	O
0	int
;	O
uind	int
<	O
denlen	int
;	O
uind	int
++	O
)	O
{	O
if	O
(	O
theunit	pointer
->	O
denominator	O
[	O
uind	int
]	O
!=	O
NULLUNIT	pointer
)	O
{	O
*	O
denptr	pointer
++	O
=	O
dupstr	function
(	O
theunit	pointer
->	O
denominator	O
[	O
uind	int
]	O
)	O
;	O
if	O
(	O
denptr	pointer
-	O
theunit	pointer
->	O
denominator	O
>=	O
MAXSUBUNITS	O
-	O
1	int
)	O
{	O
*	O
numptr	pointer
=	O
*	O
denptr	pointer
=	O
0	int
;	O
return	O
E_PRODOVERFLOW	O
;	O
}	O
}	O
}	O
}	O
*	O
numptr	pointer
=	O
0	int
;	O
*	O
denptr	pointer
=	O
0	int
;	O
return	O
0	int
;	O
}	O
int	O
unit2num	function
(	O
struct	O
unittype	O
*	O
input	pointer
)	O
{	O
struct	O
unittype	O
one	pointer
;	O
int	O
err	int
;	O
initializeunit	function
(	O
&	O
one	pointer
)	O
;	O
if	O
(	O
(	O
err	int
=	O
completereduce	function
(	O
input	pointer
)	O
)	O
)	O
return	O
err	int
;	O
if	O
(	O
compareunits	function
(	O
input	pointer
,	O
&	O
one	pointer
,	O
ignore_nothing	function
)	O
)	O
return	O
E_NOTANUMBER	O
;	O
freeunit	function
(	O
input	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
unitdimless	function
(	O
struct	O
unittype	O
*	O
input	pointer
)	O
{	O
struct	O
unittype	O
one	pointer
;	O
initializeunit	function
(	O
&	O
one	pointer
)	O
;	O
if	O
(	O
compareunits	function
(	O
input	pointer
,	O
&	O
one	pointer
,	O
ignore_dimless	function
)	O
)	O
return	O
0	int
;	O
freeunit	function
(	O
input	pointer
)	O
;	O
return	O
1	int
;	O
}	O
int	O
subunitroot	function
(	O
int	O
n	int
,	O
char	O
*	O
current	array
[	O
]	O
,	O
char	O
*	O
out	array
[	O
]	O
)	O
{	O
char	O
*	O
*	O
ptr	pointer
;	O
int	O
count	pointer
=	O
0	int
;	O
while	O
(	O
*	O
current	array
==	O
NULLUNIT	pointer
)	O
current	array
++	O
;	O
ptr	pointer
=	O
current	array
;	O
while	O
(	O
*	O
ptr	pointer
)	O
{	O
while	O
(	O
*	O
ptr	pointer
)	O
{	O
if	O
(	O
*	O
ptr	pointer
!=	O
NULLUNIT	pointer
)	O
{	O
if	O
(	O
strcmp	O
(	O
*	O
current	array
,	O
*	O
ptr	pointer
)	O
)	O
break	O
;	O
count	pointer
++	O
;	O
}	O
ptr	pointer
++	O
;	O
}	O
if	O
(	O
count	pointer
%	O
n	int
!=	O
0	int
)	O
{	O
if	O
(	O
!	O
ignore_dimless	function
(	O
*	O
current	array
)	O
)	O
return	O
E_NOTROOT	O
;	O
}	O
else	O
{	O
for	O
(	O
count	pointer
/=	O
n	int
;	O
count	pointer
>	O
0	int
;	O
count	pointer
--	O
)	O
*	O
(	O
out	array
++	O
)	O
=	O
dupstr	function
(	O
*	O
current	array
)	O
;	O
}	O
current	array
=	O
ptr	pointer
;	O
}	O
*	O
out	array
=	O
0	int
;	O
return	O
0	int
;	O
}	O
int	O
rootunit	function
(	O
struct	O
unittype	O
*	O
inunit	pointer
,	O
int	O
n	int
)	O
{	O
struct	O
unittype	O
outunit	struct
;	O
int	O
err	int
;	O
initializeunit	function
(	O
&	O
outunit	struct
)	O
;	O
if	O
(	O
(	O
err	int
=	O
completereduce	function
(	O
inunit	pointer
)	O
)	O
)	O
return	O
err	int
;	O
if	O
(	O
inunit	pointer
->	O
factor	double
<	O
0	int
)	O
return	O
E_NOTROOT	O
;	O
outunit	struct
.	O
factor	double
=	O
pow	O
(	O
inunit	pointer
->	O
factor	double
,	O
1.0	int
/	O
(	O
double	O
)	O
n	int
)	O
;	O
if	O
(	O
(	O
err	int
=	O
subunitroot	function
(	O
n	int
,	O
inunit	pointer
->	O
numerator	O
,	O
outunit	struct
.	O
numerator	O
)	O
)	O
)	O
return	O
err	int
;	O
if	O
(	O
(	O
err	int
=	O
subunitroot	function
(	O
n	int
,	O
inunit	pointer
->	O
denominator	O
,	O
outunit	struct
.	O
denominator	O
)	O
)	O
)	O
return	O
err	int
;	O
freeunit	function
(	O
inunit	pointer
)	O
;	O
initializeunit	function
(	O
inunit	pointer
)	O
;	O
return	O
multunit	function
(	O
inunit	pointer
,	O
&	O
outunit	struct
)	O
;	O
}	O
void	O
invertunit	function
(	O
struct	O
unittype	O
*	O
theunit	pointer
)	O
{	O
char	O
*	O
*	O
ptr	pointer
,	O
*	O
swap	pointer
;	O
int	O
numlen	int
,	O
length	int
,	O
ind	int
;	O
theunit	pointer
->	O
factor	double
=	O
1.0	int
/	O
theunit	pointer
->	O
factor	double
;	O
length	int
=	O
numlen	int
=	O
0	int
;	O
for	O
(	O
ptr	pointer
=	O
theunit	pointer
->	O
denominator	O
;	O
*	O
ptr	pointer
;	O
ptr	pointer
++	O
,	O
length	int
++	O
)	O
;	O
for	O
(	O
ptr	pointer
=	O
theunit	pointer
->	O
numerator	O
;	O
*	O
ptr	pointer
;	O
ptr	pointer
++	O
,	O
numlen	int
++	O
)	O
;	O
if	O
(	O
numlen	int
>	O
length	int
)	O
length	int
=	O
numlen	int
;	O
for	O
(	O
ind	int
=	O
0	int
;	O
ind	int
<=	O
length	int
;	O
ind	int
++	O
)	O
{	O
swap	pointer
=	O
theunit	pointer
->	O
numerator	O
[	O
ind	int
]	O
;	O
theunit	pointer
->	O
numerator	O
[	O
ind	int
]	O
=	O
theunit	pointer
->	O
denominator	O
[	O
ind	int
]	O
;	O
theunit	pointer
->	O
denominator	O
[	O
ind	int
]	O
=	O
swap	pointer
;	O
}	O
}	O
int	O
float2rat	function
(	O
double	O
y	double
,	O
int	O
*	O
p	int
,	O
int	O
*	O
q	pointer
)	O
{	O
int	O
coef	array
[	O
20	int
]	O
;	O
int	O
i	int
,	O
termcount	int
,	O
saveq	int
;	O
double	O
fracpart	double
,	O
x	double
;	O
x	double
=	O
y	double
;	O
termcount	int
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
coef	array
[	O
termcount	int
]	O
=	O
(	O
int	O
)	O
floor	O
(	O
x	double
)	O
;	O
fracpart	double
=	O
x	double
-	O
coef	array
[	O
termcount	int
]	O
;	O
if	O
(	O
fracpart	double
<	O
.001	int
||	O
termcount	int
==	O
19	int
)	O
break	O
;	O
x	double
=	O
1	int
/	O
fracpart	double
;	O
termcount	int
++	O
;	O
}	O
*	O
p	int
=	O
0	int
;	O
*	O
q	pointer
=	O
1	int
;	O
for	O
(	O
i	int
=	O
termcount	int
;	O
i	int
>=	O
1	int
;	O
i	int
--	O
)	O
{	O
saveq	int
=	O
*	O
q	pointer
;	O
*	O
q	pointer
=	O
coef	array
[	O
i	int
]	O
*	O
*	O
q	pointer
+	O
*	O
p	int
;	O
*	O
p	int
=	O
saveq	int
;	O
}	O
*	O
p	int
+=	O
*	O
q	pointer
*	O
coef	array
[	O
0	int
]	O
;	O
return	O
*	O
q	pointer
<	O
MAXSUBUNITS	O
&&	O
fabs	O
(	O
(	O
double	O
)	O
*	O
p	int
/	O
(	O
double	O
)	O
*	O
q	pointer
-	O
y	double
)	O
<	O
DBL_EPSILON	O
;	O
}	O
int	O
unitpower	function
(	O
struct	O
unittype	O
*	O
base	pointer
,	O
struct	O
unittype	O
*	O
exponent	pointer
)	O
{	O
int	O
errcode	int
,	O
p	int
,	O
q	pointer
;	O
errcode	int
=	O
unit2num	function
(	O
exponent	pointer
)	O
;	O
if	O
(	O
errcode	int
==	O
E_NOTANUMBER	O
)	O
return	O
E_DIMEXPONENT	O
;	O
if	O
(	O
errcode	int
)	O
return	O
errcode	int
;	O
errcode	int
=	O
unit2num	function
(	O
base	pointer
)	O
;	O
if	O
(	O
!	O
errcode	int
)	O
{	O
base	pointer
->	O
factor	double
=	O
pow	O
(	O
base	pointer
->	O
factor	double
,	O
exponent	pointer
->	O
factor	double
)	O
;	O
if	O
(	O
errno	O
)	O
return	O
E_FUNC	O
;	O
}	O
else	O
if	O
(	O
errcode	int
==	O
E_NOTANUMBER	O
)	O
{	O
if	O
(	O
!	O
float2rat	function
(	O
exponent	pointer
->	O
factor	double
,	O
&	O
p	int
,	O
&	O
q	pointer
)	O
)	O
{	O
if	O
(	O
unitdimless	function
(	O
base	pointer
)	O
)	O
{	O
base	pointer
->	O
factor	double
=	O
pow	O
(	O
base	pointer
->	O
factor	double
,	O
exponent	pointer
->	O
factor	double
)	O
;	O
if	O
(	O
errno	O
)	O
return	O
E_FUNC	O
;	O
}	O
else	O
return	O
E_IRRATIONAL_EXPONENT	O
;	O
}	O
else	O
{	O
if	O
(	O
q	pointer
!=	O
1	int
)	O
{	O
errcode	int
=	O
rootunit	function
(	O
base	pointer
,	O
q	pointer
)	O
;	O
if	O
(	O
errcode	int
==	O
E_NOTROOT	O
)	O
return	O
E_BASE_NOTROOT	O
;	O
if	O
(	O
errcode	int
)	O
return	O
errcode	int
;	O
}	O
errcode	int
=	O
expunit	function
(	O
base	pointer
,	O
abs	O
(	O
p	int
)	O
)	O
;	O
if	O
(	O
errcode	int
)	O
return	O
errcode	int
;	O
if	O
(	O
p	int
<	O
0	int
)	O
invertunit	function
(	O
base	pointer
)	O
;	O
}	O
}	O
else	O
return	O
errcode	int
;	O
return	O
0	int
;	O
}	O
int	O
addunit	function
(	O
struct	O
unittype	O
*	O
unita	pointer
,	O
struct	O
unittype	O
*	O
unitb	pointer
)	O
{	O
int	O
err	int
;	O
if	O
(	O
(	O
err	int
=	O
completereduce	function
(	O
unita	pointer
)	O
)	O
)	O
return	O
err	int
;	O
if	O
(	O
(	O
err	int
=	O
completereduce	function
(	O
unitb	pointer
)	O
)	O
)	O
return	O
err	int
;	O
if	O
(	O
compareunits	function
(	O
unita	pointer
,	O
unitb	pointer
,	O
ignore_nothing	function
)	O
)	O
return	O
E_BADSUM	O
;	O
unita	pointer
->	O
factor	double
+=	O
unitb	pointer
->	O
factor	double
;	O
freeunit	function
(	O
unitb	pointer
)	O
;	O
return	O
0	int
;	O
}	O
double	O
linearinterp	function
(	O
double	O
a	double
,	O
double	O
b	double
,	O
double	O
aval	double
,	O
double	O
bval	double
,	O
double	O
c	char
)	O
{	O
double	O
lambda	double
;	O
lambda	double
=	O
(	O
b	double
-	O
c	char
)	O
/	O
(	O
b	double
-	O
a	double
)	O
;	O
return	O
lambda	double
*	O
aval	double
+	O
(	O
1	int
-	O
lambda	double
)	O
*	O
bval	double
;	O
}	O
int	O
evalfunc	function
(	O
struct	O
unittype	O
*	O
theunit	pointer
,	O
struct	O
func	pointer
*	O
infunc	pointer
,	O
int	O
inverse	int
,	O
int	O
allerrors	int
)	O
{	O
struct	O
unittype	O
result	struct
;	O
struct	O
functype	O
*	O
thefunc	pointer
;	O
int	O
err	int
;	O
double	O
value	pointer
;	O
int	O
foundit	int
,	O
count	pointer
;	O
struct	O
unittype	O
*	O
save_value	pointer
;	O
char	O
*	O
save_function	pointer
;	O
if	O
(	O
infunc	pointer
->	O
table	O
)	O
{	O
err	int
=	O
parseunit	function
(	O
&	O
result	struct
,	O
infunc	pointer
->	O
tableunit	pointer
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
err	int
)	O
return	O
E_BADFUNCDIMEN	O
;	O
if	O
(	O
inverse	int
)	O
{	O
err	int
=	O
divunit	function
(	O
theunit	pointer
,	O
&	O
result	struct
)	O
;	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
err	int
=	O
unit2num	function
(	O
theunit	pointer
)	O
;	O
if	O
(	O
err	int
==	O
E_NOTANUMBER	O
)	O
return	O
E_BADFUNCARG	O
;	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
value	pointer
=	O
theunit	pointer
->	O
factor	double
;	O
foundit	int
=	O
0	int
;	O
for	O
(	O
count	pointer
=	O
0	int
;	O
count	pointer
<	O
infunc	pointer
->	O
tablelen	O
-	O
1	int
;	O
count	pointer
++	O
)	O
if	O
(	O
(	O
infunc	pointer
->	O
table	O
[	O
count	pointer
]	O
.	O
value	pointer
<=	O
value	pointer
&&	O
value	pointer
<=	O
infunc	pointer
->	O
table	O
[	O
count	pointer
+	O
1	int
]	O
.	O
value	pointer
)	O
||	O
(	O
infunc	pointer
->	O
table	O
[	O
count	pointer
+	O
1	int
]	O
.	O
value	pointer
<=	O
value	pointer
&&	O
value	pointer
<=	O
infunc	pointer
->	O
table	O
[	O
count	pointer
]	O
.	O
value	pointer
)	O
)	O
{	O
foundit	int
=	O
1	int
;	O
value	pointer
=	O
linearinterp	function
(	O
infunc	pointer
->	O
table	O
[	O
count	pointer
]	O
.	O
value	pointer
,	O
infunc	pointer
->	O
table	O
[	O
count	pointer
+	O
1	int
]	O
.	O
value	pointer
,	O
infunc	pointer
->	O
table	O
[	O
count	pointer
]	O
.	O
location	O
,	O
infunc	pointer
->	O
table	O
[	O
count	pointer
+	O
1	int
]	O
.	O
location	O
,	O
value	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
foundit	int
)	O
return	O
E_NOTINDOMAIN	O
;	O
freeunit	function
(	O
&	O
result	struct
)	O
;	O
freeunit	function
(	O
theunit	pointer
)	O
;	O
theunit	pointer
->	O
factor	double
=	O
value	pointer
;	O
return	O
0	int
;	O
}	O
else	O
{	O
err	int
=	O
unit2num	function
(	O
theunit	pointer
)	O
;	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
value	pointer
=	O
theunit	pointer
->	O
factor	double
;	O
foundit	int
=	O
0	int
;	O
for	O
(	O
count	pointer
=	O
0	int
;	O
count	pointer
<	O
infunc	pointer
->	O
tablelen	O
-	O
1	int
;	O
count	pointer
++	O
)	O
if	O
(	O
infunc	pointer
->	O
table	O
[	O
count	pointer
]	O
.	O
location	O
<=	O
value	pointer
&&	O
value	pointer
<=	O
infunc	pointer
->	O
table	O
[	O
count	pointer
+	O
1	int
]	O
.	O
location	O
)	O
{	O
foundit	int
=	O
1	int
;	O
value	pointer
=	O
linearinterp	function
(	O
infunc	pointer
->	O
table	O
[	O
count	pointer
]	O
.	O
location	O
,	O
infunc	pointer
->	O
table	O
[	O
count	pointer
+	O
1	int
]	O
.	O
location	O
,	O
infunc	pointer
->	O
table	O
[	O
count	pointer
]	O
.	O
value	pointer
,	O
infunc	pointer
->	O
table	O
[	O
count	pointer
+	O
1	int
]	O
.	O
value	pointer
,	O
value	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
foundit	int
)	O
return	O
E_NOTINDOMAIN	O
;	O
result	struct
.	O
factor	double
*=	O
value	pointer
;	O
}	O
}	O
else	O
{	O
if	O
(	O
inverse	int
)	O
{	O
thefunc	pointer
=	O
&	O
(	O
infunc	pointer
->	O
inverse	int
)	O
;	O
if	O
(	O
!	O
thefunc	pointer
->	O
def	pointer
)	O
return	O
E_NOINVERSE	O
;	O
}	O
else	O
thefunc	pointer
=	O
&	O
(	O
infunc	pointer
->	O
forward	O
)	O
;	O
err	int
=	O
completereduce	function
(	O
theunit	pointer
)	O
;	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
if	O
(	O
thefunc	pointer
->	O
dimen	pointer
)	O
{	O
err	int
=	O
parseunit	function
(	O
&	O
result	struct
,	O
thefunc	pointer
->	O
dimen	pointer
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
err	int
)	O
return	O
E_BADFUNCDIMEN	O
;	O
err	int
=	O
completereduce	function
(	O
&	O
result	struct
)	O
;	O
if	O
(	O
err	int
)	O
return	O
E_BADFUNCDIMEN	O
;	O
if	O
(	O
compareunits	function
(	O
&	O
result	struct
,	O
theunit	pointer
,	O
ignore_nothing	function
)	O
)	O
return	O
E_BADFUNCARG	O
;	O
value	pointer
=	O
theunit	pointer
->	O
factor	double
/	O
result	struct
.	O
factor	double
;	O
}	O
else	O
value	pointer
=	O
theunit	pointer
->	O
factor	double
;	O
if	O
(	O
thefunc	pointer
->	O
domain_max	pointer
&&	O
(	O
value	pointer
>	O
*	O
thefunc	pointer
->	O
domain_max	pointer
||	O
(	O
thefunc	pointer
->	O
domain_max_open	int
&&	O
value	pointer
==	O
*	O
thefunc	pointer
->	O
domain_max	pointer
)	O
)	O
)	O
return	O
E_NOTINDOMAIN	O
;	O
if	O
(	O
thefunc	pointer
->	O
domain_min	pointer
&&	O
(	O
value	pointer
<	O
*	O
thefunc	pointer
->	O
domain_min	pointer
||	O
(	O
thefunc	pointer
->	O
domain_min_open	int
&&	O
value	pointer
==	O
*	O
thefunc	pointer
->	O
domain_min	pointer
)	O
)	O
)	O
return	O
E_NOTINDOMAIN	O
;	O
save_value	pointer
=	O
parameter_value	pointer
;	O
save_function	pointer
=	O
function_parameter	pointer
;	O
parameter_value	pointer
=	O
theunit	pointer
;	O
function_parameter	pointer
=	O
thefunc	pointer
->	O
param	O
;	O
err	int
=	O
parseunit	function
(	O
&	O
result	struct
,	O
thefunc	pointer
->	O
def	pointer
,	O
0	int
,	O
0	int
)	O
;	O
function_parameter	pointer
=	O
save_function	pointer
;	O
parameter_value	pointer
=	O
save_value	pointer
;	O
if	O
(	O
err	int
&&	O
(	O
allerrors	int
==	O
ALLERR	int
||	O
err	int
==	O
E_PARSEMEM	O
||	O
err	int
==	O
E_PRODOVERFLOW	O
||	O
err	int
==	O
E_NOTROOT	O
||	O
err	int
==	O
E_BADFUNCTYPE	O
)	O
)	O
return	O
err	int
;	O
if	O
(	O
err	int
)	O
return	O
E_FUNARGDEF	O
;	O
}	O
freeunit	function
(	O
theunit	pointer
)	O
;	O
initializeunit	function
(	O
theunit	pointer
)	O
;	O
multunit	function
(	O
theunit	pointer
,	O
&	O
result	struct
)	O
;	O
return	O
0	int
;	O
}	O
void	O
showdefinition	function
(	O
char	O
*	O
unitstr	pointer
,	O
struct	O
unittype	O
*	O
theunit	pointer
)	O
{	O
logputs	function
(	O
deftext	pointer
)	O
;	O
while	O
(	O
(	O
unitstr	pointer
=	O
lookupunit	function
(	O
unitstr	pointer
,	O
1	int
)	O
)	O
&&	O
strspn	O
(	O
unitstr	pointer
,	O
digits	pointer
)	O
!=	O
strlen	O
(	O
unitstr	pointer
)	O
&&	O
!	O
strchr	O
(	O
unitstr	pointer
,	O
PRIMITIVECHAR	char
)	O
)	O
{	O
tightprint	function
(	O
stdout	O
,	O
unitstr	pointer
)	O
;	O
if	O
(	O
logfile	pointer
)	O
tightprint	function
(	O
logfile	pointer
,	O
unitstr	pointer
)	O
;	O
logputs	function
(	O
" = "	pointer
)	O
;	O
}	O
showunit	function
(	O
theunit	pointer
)	O
;	O
logputchar	function
(	O
'\n'	O
)	O
;	O
}	O
void	O
showfunction	function
(	O
struct	O
functype	O
*	O
func	pointer
)	O
{	O
struct	O
unittype	O
unit	pointer
;	O
int	O
not_dimensionless	int
,	O
i	int
;	O
if	O
(	O
!	O
func	pointer
->	O
def	pointer
)	O
{	O
logputs	function
(	O
" is undefined"	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
func	pointer
->	O
dimen	pointer
)	O
{	O
parseunit	function
(	O
&	O
unit	pointer
,	O
func	pointer
->	O
dimen	pointer
,	O
0	int
,	O
0	int
)	O
;	O
not_dimensionless	int
=	O
unit2num	function
(	O
&	O
unit	pointer
)	O
;	O
}	O
logprintf	function
(	O
"(%s) = %s"	pointer
,	O
func	pointer
->	O
param	O
,	O
func	pointer
->	O
def	pointer
)	O
;	O
if	O
(	O
func	pointer
->	O
domain_min	pointer
||	O
func	pointer
->	O
domain_max	pointer
)	O
{	O
logputchar	function
(	O
'\n'	O
)	O
;	O
for	O
(	O
i	int
=	O
strwidth	function
(	O
deftext	pointer
)	O
;	O
i	int
;	O
i	int
--	O
)	O
logputchar	function
(	O
' '	O
)	O
;	O
logputs	function
(	O
"defined for "	pointer
)	O
;	O
if	O
(	O
func	pointer
->	O
domain_min	pointer
&&	O
func	pointer
->	O
domain_max	pointer
)	O
{	O
logprintf	function
(	O
num_format	struct
.	O
format	pointer
,	O
*	O
func	pointer
->	O
domain_min	pointer
)	O
;	O
if	O
(	O
func	pointer
->	O
dimen	pointer
&&	O
(	O
not_dimensionless	int
||	O
unit	pointer
.	O
factor	double
!=	O
1	int
)	O
)	O
{	O
if	O
(	O
isdecimal	function
(	O
*	O
func	pointer
->	O
dimen	pointer
)	O
)	O
logputs	function
(	O
" *"	pointer
)	O
;	O
logprintf	function
(	O
" %s"	pointer
,	O
func	pointer
->	O
dimen	pointer
)	O
;	O
}	O
logputs	function
(	O
func	pointer
->	O
domain_min_open	int
?	O
" < "	pointer
:	O
" <= "	pointer
)	O
;	O
}	O
logputs	function
(	O
func	pointer
->	O
param	O
)	O
;	O
if	O
(	O
func	pointer
->	O
domain_max	pointer
)	O
{	O
logputs	function
(	O
func	pointer
->	O
domain_max_open	int
?	O
" < "	pointer
:	O
" <= "	pointer
)	O
;	O
logprintf	function
(	O
num_format	struct
.	O
format	pointer
,	O
*	O
func	pointer
->	O
domain_max	pointer
)	O
;	O
}	O
else	O
{	O
logputs	function
(	O
func	pointer
->	O
domain_min_open	int
?	O
" > "	pointer
:	O
" >= "	pointer
)	O
;	O
logprintf	function
(	O
num_format	struct
.	O
format	pointer
,	O
*	O
func	pointer
->	O
domain_min	pointer
)	O
;	O
}	O
if	O
(	O
func	pointer
->	O
dimen	pointer
&&	O
(	O
not_dimensionless	int
||	O
unit	pointer
.	O
factor	double
!=	O
1	int
)	O
)	O
{	O
if	O
(	O
isdecimal	function
(	O
*	O
func	pointer
->	O
dimen	pointer
)	O
)	O
logputs	function
(	O
" *"	pointer
)	O
;	O
logprintf	function
(	O
" %s"	pointer
,	O
func	pointer
->	O
dimen	pointer
)	O
;	O
}	O
if	O
(	O
!	O
func	pointer
->	O
dimen	pointer
)	O
logputs	function
(	O
" (any units)"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
func	pointer
->	O
dimen	pointer
)	O
{	O
logputchar	function
(	O
'\n'	O
)	O
;	O
for	O
(	O
i	int
=	O
strwidth	function
(	O
deftext	pointer
)	O
;	O
i	int
;	O
i	int
--	O
)	O
logputchar	function
(	O
' '	O
)	O
;	O
if	O
(	O
not_dimensionless	int
)	O
logprintf	function
(	O
"%s has units %s"	pointer
,	O
func	pointer
->	O
param	O
,	O
func	pointer
->	O
dimen	pointer
)	O
;	O
else	O
logprintf	function
(	O
"%s is dimensionless"	pointer
,	O
func	pointer
->	O
param	O
)	O
;	O
}	O
logputchar	function
(	O
'\n'	O
)	O
;	O
}	O
void	O
showtable	function
(	O
struct	O
func	pointer
*	O
fun	pointer
,	O
int	O
inverse	int
)	O
{	O
int	O
i	int
;	O
logprintf	function
(	O
"%sinterpolated table with points\n"	pointer
,	O
deftext	pointer
)	O
;	O
if	O
(	O
inverse	int
)	O
{	O
int	O
reverse	int
,	O
j	int
;	O
reverse	int
=	O
(	O
fun	pointer
->	O
table	O
[	O
0	int
]	O
.	O
value	pointer
>	O
fun	pointer
->	O
table	O
[	O
fun	pointer
->	O
tablelen	O
-	O
1	int
]	O
.	O
value	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
fun	pointer
->	O
tablelen	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
reverse	int
)	O
j	int
=	O
fun	pointer
->	O
tablelen	O
-	O
i	int
-	O
1	int
;	O
else	O
j	int
=	O
i	int
;	O
if	O
(	O
flags	struct
.	O
verbose	int
>	O
0	int
)	O
logputs	function
(	O
"\t\t    "	pointer
)	O
;	O
logprintf	function
(	O
"~%s("	pointer
,	O
fun	pointer
->	O
name	pointer
)	O
;	O
logprintf	function
(	O
num_format	struct
.	O
format	pointer
,	O
fun	pointer
->	O
table	O
[	O
j	int
]	O
.	O
value	pointer
)	O
;	O
if	O
(	O
isdecimal	function
(	O
fun	pointer
->	O
tableunit	pointer
[	O
0	int
]	O
)	O
)	O
logputs	function
(	O
" *"	pointer
)	O
;	O
logprintf	function
(	O
" %s"	pointer
,	O
fun	pointer
->	O
tableunit	pointer
)	O
;	O
logputs	function
(	O
") = "	pointer
)	O
;	O
logprintf	function
(	O
num_format	struct
.	O
format	pointer
,	O
fun	pointer
->	O
table	O
[	O
j	int
]	O
.	O
location	O
)	O
;	O
logputchar	function
(	O
'\n'	O
)	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
fun	pointer
->	O
tablelen	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
flags	struct
.	O
verbose	int
>	O
0	int
)	O
logputs	function
(	O
"\t\t    "	pointer
)	O
;	O
logprintf	function
(	O
"%s("	pointer
,	O
fun	pointer
->	O
name	pointer
)	O
;	O
logprintf	function
(	O
num_format	struct
.	O
format	pointer
,	O
fun	pointer
->	O
table	O
[	O
i	int
]	O
.	O
location	O
)	O
;	O
logputs	function
(	O
") = "	pointer
)	O
;	O
logprintf	function
(	O
num_format	struct
.	O
format	pointer
,	O
fun	pointer
->	O
table	O
[	O
i	int
]	O
.	O
value	pointer
)	O
;	O
if	O
(	O
isdecimal	function
(	O
fun	pointer
->	O
tableunit	pointer
[	O
0	int
]	O
)	O
)	O
logputs	function
(	O
" *"	pointer
)	O
;	O
logprintf	function
(	O
" %s\n"	pointer
,	O
fun	pointer
->	O
tableunit	pointer
)	O
;	O
}	O
}	O
}	O
void	O
showfuncdefinition	function
(	O
struct	O
func	pointer
*	O
fun	pointer
,	O
int	O
inverse	int
)	O
{	O
if	O
(	O
fun	pointer
->	O
table	O
)	O
showtable	function
(	O
fun	pointer
,	O
inverse	int
)	O
;	O
else	O
{	O
logprintf	function
(	O
"%s%s%s"	pointer
,	O
deftext	pointer
,	O
inverse	int
?	O
"~"	pointer
:	O
""	pointer
,	O
fun	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
inverse	int
)	O
showfunction	function
(	O
&	O
fun	pointer
->	O
inverse	int
)	O
;	O
else	O
showfunction	function
(	O
&	O
fun	pointer
->	O
forward	O
)	O
;	O
}	O
}	O
void	O
showunitlistdef	function
(	O
struct	O
wantalias	struct
*	O
alias	pointer
)	O
{	O
logprintf	function
(	O
"%sunit list, "	pointer
,	O
deftext	pointer
)	O
;	O
tightprint	function
(	O
stdout	O
,	O
alias	pointer
->	O
definition	pointer
)	O
;	O
if	O
(	O
logfile	pointer
)	O
tightprint	function
(	O
logfile	pointer
,	O
alias	pointer
->	O
definition	pointer
)	O
;	O
logputchar	function
(	O
'\n'	O
)	O
;	O
}	O
int	O
showfunc	function
(	O
char	O
*	O
havestr	pointer
,	O
struct	O
unittype	O
*	O
have	pointer
,	O
struct	O
func	pointer
*	O
fun	pointer
)	O
{	O
int	O
err	int
;	O
char	O
*	O
dimen	pointer
;	O
err	int
=	O
evalfunc	function
(	O
have	pointer
,	O
fun	pointer
,	O
INVERSE	int
,	O
NORMALERR	int
)	O
;	O
if	O
(	O
!	O
err	int
)	O
err	int
=	O
completereduce	function
(	O
have	pointer
)	O
;	O
if	O
(	O
err	int
)	O
{	O
if	O
(	O
err	int
==	O
E_BADFUNCARG	O
)	O
{	O
logputs	function
(	O
"conformability error"	pointer
)	O
;	O
if	O
(	O
fun	pointer
->	O
table	O
)	O
dimen	pointer
=	O
fun	pointer
->	O
tableunit	pointer
;	O
else	O
if	O
(	O
fun	pointer
->	O
inverse	int
.	O
dimen	pointer
)	O
dimen	pointer
=	O
fun	pointer
->	O
inverse	int
.	O
dimen	pointer
;	O
else	O
dimen	pointer
=	O
0	int
;	O
if	O
(	O
!	O
dimen	pointer
)	O
logputchar	function
(	O
'\n'	O
)	O
;	O
else	O
{	O
struct	O
unittype	O
want	struct
;	O
if	O
(	O
emptystr	O
(	O
dimen	pointer
)	O
)	O
dimen	pointer
=	O
"1"	pointer
;	O
logprintf	function
(	O
": conversion requires dimensions of '%s'\n"	pointer
,	O
dimen	pointer
)	O
;	O
if	O
(	O
flags	struct
.	O
verbose	int
==	O
2	int
)	O
logprintf	function
(	O
"\t%s = "	pointer
,	O
havestr	pointer
)	O
;	O
else	O
if	O
(	O
flags	struct
.	O
verbose	int
==	O
1	int
)	O
logputchar	function
(	O
'\t'	O
)	O
;	O
showunit	function
(	O
have	pointer
)	O
;	O
if	O
(	O
flags	struct
.	O
verbose	int
==	O
2	int
)	O
logprintf	function
(	O
"\n\t%s = "	pointer
,	O
dimen	pointer
)	O
;	O
else	O
if	O
(	O
flags	struct
.	O
verbose	int
==	O
1	int
)	O
logprintf	function
(	O
"\n\t"	pointer
)	O
;	O
else	O
logputchar	function
(	O
'\n'	O
)	O
;	O
parseunit	function
(	O
&	O
want	struct
,	O
dimen	pointer
,	O
0	int
,	O
0	int
)	O
;	O
completereduce	function
(	O
&	O
want	struct
)	O
;	O
showunit	function
(	O
&	O
want	struct
)	O
;	O
logputchar	function
(	O
'\n'	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
err	int
==	O
E_NOTINDOMAIN	O
)	O
logprintf	function
(	O
"Value '%s' is not in the function's range\n"	pointer
,	O
havestr	pointer
)	O
;	O
else	O
logputs	function
(	O
"Function evaluation error (bad function definition)\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
flags	struct
.	O
verbose	int
==	O
2	int
)	O
logprintf	function
(	O
"\t%s = %s("	pointer
,	O
havestr	pointer
,	O
fun	pointer
->	O
inverse	int
.	O
param	O
)	O
;	O
else	O
if	O
(	O
flags	struct
.	O
verbose	int
==	O
1	int
)	O
logputchar	function
(	O
'\t'	O
)	O
;	O
showunit	function
(	O
have	pointer
)	O
;	O
if	O
(	O
flags	struct
.	O
verbose	int
==	O
2	int
)	O
logputchar	function
(	O
')'	O
)	O
;	O
logputchar	function
(	O
'\n'	O
)	O
;	O
return	O
0	int
;	O
}	O
void	O
showconformabilityerr	function
(	O
char	O
*	O
havestr	pointer
,	O
struct	O
unittype	O
*	O
have	pointer
,	O
char	O
*	O
wantstr	pointer
,	O
struct	O
unittype	O
*	O
want	struct
)	O
{	O
logputs	function
(	O
"conformability error\n"	pointer
)	O
;	O
if	O
(	O
flags	struct
.	O
verbose	int
==	O
2	int
)	O
logprintf	function
(	O
"\t%s = "	pointer
,	O
havestr	pointer
)	O
;	O
else	O
if	O
(	O
flags	struct
.	O
verbose	int
==	O
1	int
)	O
logputchar	function
(	O
'\t'	O
)	O
;	O
showunit	function
(	O
have	pointer
)	O
;	O
if	O
(	O
flags	struct
.	O
verbose	int
==	O
2	int
)	O
logprintf	function
(	O
"\n\t%s = "	pointer
,	O
wantstr	pointer
)	O
;	O
else	O
if	O
(	O
flags	struct
.	O
verbose	int
==	O
1	int
)	O
logputs	function
(	O
"\n\t"	pointer
)	O
;	O
else	O
logputchar	function
(	O
'\n'	O
)	O
;	O
showunit	function
(	O
want	struct
)	O
;	O
logputchar	function
(	O
'\n'	O
)	O
;	O
}	O
int	O
isfract	function
(	O
const	O
char	O
*	O
unitstr	pointer
)	O
{	O
char	O
*	O
enddouble	pointer
=	O
0	int
,	O
*	O
endlong	pointer
=	O
0	int
;	O
while	O
(	O
isdigit	O
(	O
*	O
unitstr	pointer
)	O
)	O
unitstr	pointer
++	O
;	O
if	O
(	O
*	O
unitstr	pointer
++	O
==	O
'|'	O
)	O
{	O
(	O
void	O
)	O
strtod	O
(	O
unitstr	pointer
,	O
&	O
enddouble	pointer
)	O
;	O
(	O
void	O
)	O
strtol	O
(	O
unitstr	pointer
,	O
&	O
endlong	pointer
,	O
10	int
)	O
;	O
if	O
(	O
enddouble	pointer
==	O
endlong	pointer
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
checksigdigits	function
(	O
char	O
*	O
arg	pointer
)	O
{	O
int	O
errors	int
,	O
ival	int
;	O
char	O
*	O
nonum	pointer
;	O
errors	int
=	O
0	int
;	O
if	O
(	O
!	O
strcmp	O
(	O
arg	pointer
,	O
"max"	pointer
)	O
)	O
num_format	struct
.	O
precision	int
=	O
MAXPRECISION	O
;	O
else	O
{	O
ival	int
=	O
(	O
int	O
)	O
strtol	O
(	O
arg	pointer
,	O
&	O
nonum	pointer
,	O
10	int
)	O
;	O
if	O
(	O
!	O
emptystr	O
(	O
nonum	pointer
)	O
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"%s: invalid significant digits (%s)--integer value or 'max' required\n"	pointer
,	O
progname	pointer
,	O
arg	pointer
)	O
;	O
errors	int
++	O
;	O
}	O
else	O
if	O
(	O
ival	int
<=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"%s: number of significant digits must be positive\n"	pointer
,	O
progname	pointer
)	O
;	O
errors	int
++	O
;	O
}	O
else	O
if	O
(	O
ival	int
>	O
MAXPRECISION	O
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"%s: too many significant digits (%d)--using maximum value (%d)\n"	pointer
,	O
progname	pointer
,	O
ival	int
,	O
MAXPRECISION	O
)	O
;	O
num_format	struct
.	O
precision	int
=	O
MAXPRECISION	O
;	O
}	O
else	O
num_format	struct
.	O
precision	int
=	O
ival	int
;	O
}	O
if	O
(	O
errors	int
)	O
return	O
-	O
1	int
;	O
else	O
return	O
0	int
;	O
}	O
int	O
setnumformat	function
(	O
)	O
{	O
size_t	O
len	int
;	O
if	O
(	O
strchr	O
(	O
"Ee"	pointer
,	O
num_format	struct
.	O
type	char
)	O
)	O
num_format	struct
.	O
precision	int
--	O
;	O
len	int
=	O
4	int
;	O
if	O
(	O
num_format	struct
.	O
precision	int
>	O
0	int
)	O
len	int
+=	O
(	O
size_t	O
)	O
floor	O
(	O
log10	O
(	O
(	O
double	O
)	O
num_format	struct
.	O
precision	int
)	O
)	O
+	O
1	int
;	O
num_format	struct
.	O
format	pointer
=	O
(	O
char	O
*	O
)	O
mymalloc	function
(	O
len	int
,	O
"(setnumformat)"	pointer
)	O
;	O
sprintf	O
(	O
num_format	struct
.	O
format	pointer
,	O
"%%.%d%c"	pointer
,	O
num_format	struct
.	O
precision	int
,	O
num_format	struct
.	O
type	char
)	O
;	O
return	O
0	int
;	O
}	O
int	O
parsenumformat	function
(	O
)	O
{	O
static	O
char	O
*	O
format_types	pointer
=	O
NULL	O
;	O
static	O
char	O
*	O
format_flags	pointer
=	O
"+-# 0'"	pointer
;	O
static	O
char	O
badflag	char
;	O
char	O
*	O
two	pointer
=	O
"0x1p+1"	pointer
;	O
char	O
*	O
valid	pointer
=	O
"ABCDEFGHIJKLMNOPQRSTUVWXYXabcdefghijklmnopqrstuvwxyx.01234567890"	pointer
;	O
char	O
*	O
dotptr	pointer
,	O
*	O
lptr	pointer
,	O
*	O
nonum	pointer
,	O
*	O
p	int
;	O
char	O
testbuf	array
[	O
80	int
]	O
;	O
int	O
errors	int
,	O
ndx	int
;	O
if	O
(	O
format_types	pointer
==	O
NULL	O
)	O
{	O
format_types	pointer
=	O
(	O
char	O
*	O
)	O
mymalloc	function
(	O
strlen	O
(	O
BASE_FORMATS	pointer
)	O
+	O
4	int
,	O
"(parsenumformat)"	pointer
)	O
;	O
strcpy	O
(	O
format_types	pointer
,	O
BASE_FORMATS	pointer
)	O
;	O
sprintf	O
(	O
testbuf	array
,	O
"%.1F"	pointer
,	O
1.2	int
)	O
;	O
if	O
(	O
strlen	O
(	O
testbuf	array
)	O
==	O
3	int
&&	O
testbuf	array
[	O
0	int
]	O
==	O
'1'	O
&&	O
testbuf	array
[	O
2	int
]	O
==	O
'2'	O
)	O
strcat	O
(	O
format_types	pointer
,	O
"F"	pointer
)	O
;	O
sprintf	O
(	O
testbuf	array
,	O
"%.0a"	pointer
,	O
2.0	int
)	O
;	O
if	O
(	O
!	O
strcmp	O
(	O
testbuf	array
,	O
two	pointer
)	O
)	O
strcat	O
(	O
format_types	pointer
,	O
"aA"	pointer
)	O
;	O
sprintf	O
(	O
testbuf	array
,	O
"%'.0f"	pointer
,	O
1234.0	int
)	O
;	O
if	O
(	O
strlen	O
(	O
testbuf	array
)	O
>	O
2	int
&&	O
testbuf	array
[	O
0	int
]	O
==	O
'1'	O
&&	O
testbuf	array
[	O
2	int
]	O
==	O
'2'	O
)	O
badflag	char
=	O
'\0'	O
;	O
else	O
badflag	char
=	O
'\''	O
;	O
}	O
errors	int
=	O
0	int
;	O
p	int
=	O
num_format	struct
.	O
format	pointer
;	O
if	O
(	O
*	O
p	int
!=	O
'%'	O
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"%s: number format specification must start with '%%'\n"	pointer
,	O
progname	pointer
)	O
;	O
errors	int
++	O
;	O
}	O
else	O
if	O
(	O
strrchr	O
(	O
num_format	struct
.	O
format	pointer
,	O
'%'	O
)	O
!=	O
num_format	struct
.	O
format	pointer
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"%s: only one '%%' allowed in number format specification\n"	pointer
,	O
progname	pointer
)	O
;	O
errors	int
++	O
;	O
p	int
++	O
;	O
}	O
else	O
p	int
++	O
;	O
dotptr	pointer
=	O
strchr	O
(	O
num_format	struct
.	O
format	pointer
,	O
'.'	O
)	O
;	O
if	O
(	O
dotptr	pointer
&&	O
strrchr	O
(	O
num_format	struct
.	O
format	pointer
,	O
'.'	O
)	O
!=	O
dotptr	pointer
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"%s: only one '.' allowed in number format specification\n"	pointer
,	O
progname	pointer
)	O
;	O
errors	int
++	O
;	O
}	O
while	O
(	O
*	O
p	int
&&	O
strchr	O
(	O
format_flags	pointer
,	O
*	O
p	int
)	O
)	O
{	O
if	O
(	O
*	O
p	int
==	O
badflag	char
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"%s: digit-grouping flag (') not supported\n"	pointer
,	O
progname	pointer
)	O
;	O
errors	int
++	O
;	O
}	O
p	int
++	O
;	O
}	O
if	O
(	O
(	O
lptr	pointer
=	O
strstr	O
(	O
num_format	struct
.	O
format	pointer
,	O
"hh"	pointer
)	O
)	O
||	O
(	O
lptr	pointer
=	O
strstr	O
(	O
num_format	struct
.	O
format	pointer
,	O
"ll"	pointer
)	O
)	O
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"%s: type length modifier (%.2s) not supported\n"	pointer
,	O
progname	pointer
,	O
lptr	pointer
)	O
;	O
errors	int
++	O
;	O
}	O
else	O
if	O
(	O
(	O
lptr	pointer
=	O
strpbrk	O
(	O
num_format	struct
.	O
format	pointer
,	O
"hjLltz"	pointer
)	O
)	O
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"%s: type length modifier (%c) not supported\n"	pointer
,	O
progname	pointer
,	O
lptr	pointer
[	O
0	int
]	O
)	O
;	O
errors	int
++	O
;	O
}	O
ndx	int
=	O
strspn	O
(	O
p	int
,	O
valid	pointer
)	O
;	O
if	O
(	O
ndx	int
<	O
strlen	O
(	O
p	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"%s: invalid character (%c) in width, precision, or type\n"	pointer
,	O
progname	pointer
,	O
p	int
[	O
ndx	int
]	O
)	O
;	O
errors	int
++	O
;	O
}	O
if	O
(	O
errors	int
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"%s: invalid number format specification (%s)\n"	pointer
,	O
progname	pointer
,	O
num_format	struct
.	O
format	pointer
)	O
;	O
fprintf	function
(	O
stderr	O
,	O
"%s: valid specification is %%[flags][width][.precision]type\n"	pointer
,	O
progname	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
num_format	struct
.	O
width	int
=	O
(	O
int	O
)	O
strtol	O
(	O
p	int
,	O
&	O
nonum	pointer
,	O
10	int
)	O
;	O
if	O
(	O
*	O
nonum	pointer
==	O
'.'	O
)	O
{	O
if	O
(	O
isdigit	O
(	O
nonum	pointer
[	O
1	int
]	O
)	O
)	O
num_format	struct
.	O
precision	int
=	O
(	O
int	O
)	O
strtol	O
(	O
nonum	pointer
+	O
1	int
,	O
&	O
nonum	pointer
,	O
10	int
)	O
;	O
else	O
{	O
num_format	struct
.	O
precision	int
=	O
0	int
;	O
nonum	pointer
++	O
;	O
}	O
}	O
else	O
num_format	struct
.	O
precision	int
=	O
6	int
;	O
if	O
(	O
emptystr	O
(	O
nonum	pointer
)	O
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"%s: missing format type\n"	pointer
,	O
progname	pointer
)	O
;	O
errors	int
++	O
;	O
}	O
else	O
{	O
if	O
(	O
strchr	O
(	O
format_types	pointer
,	O
*	O
nonum	pointer
)	O
)	O
{	O
if	O
(	O
nonum	pointer
[	O
1	int
]	O
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"%s: invalid character(s) (%s) after format type\n"	pointer
,	O
progname	pointer
,	O
nonum	pointer
+	O
1	int
)	O
;	O
errors	int
++	O
;	O
}	O
else	O
num_format	struct
.	O
type	char
=	O
*	O
nonum	pointer
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	O
,	O
"%s: invalid format type (%c)--valid types are [%s]\n"	pointer
,	O
progname	pointer
,	O
*	O
nonum	pointer
,	O
format_types	pointer
)	O
;	O
errors	int
++	O
;	O
}	O
}	O
if	O
(	O
num_format	struct
.	O
precision	int
==	O
0	int
&&	O
(	O
num_format	struct
.	O
type	char
==	O
'G'	O
||	O
num_format	struct
.	O
type	char
==	O
'g'	O
)	O
)	O
num_format	struct
.	O
precision	int
=	O
1	int
;	O
if	O
(	O
errors	int
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"%s: invalid number format specification (%s)\n"	pointer
,	O
progname	pointer
,	O
num_format	struct
.	O
format	pointer
)	O
;	O
fprintf	function
(	O
stderr	O
,	O
"%s: valid specification is %%[flags][width][.precision]type\n"	pointer
,	O
progname	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
return	O
0	int
;	O
}	O
double	O
round_to_displayed	function
(	O
double	O
value	pointer
,	O
int	O
*	O
hasnondigits	pointer
)	O
{	O
int	O
buflen	int
;	O
char	O
*	O
buf	pointer
;	O
double	O
rounded	double
;	O
if	O
(	O
!	O
isfinite	function
(	O
value	pointer
)	O
)	O
{	O
if	O
(	O
hasnondigits	pointer
)	O
*	O
hasnondigits	pointer
=	O
1	int
;	O
return	O
value	pointer
;	O
}	O
buflen	int
=	O
num_format	struct
.	O
precision	int
+	O
9	int
;	O
if	O
(	O
num_format	struct
.	O
width	int
>	O
buflen	int
)	O
buflen	int
=	O
num_format	struct
.	O
width	int
;	O
if	O
(	O
strchr	O
(	O
"Ff"	pointer
,	O
num_format	struct
.	O
type	char
)	O
)	O
{	O
int	O
len	int
=	O
num_format	struct
.	O
precision	int
+	O
2	int
;	O
if	O
(	O
fabs	O
(	O
value	pointer
)	O
>	O
1.0	int
)	O
len	int
+=	O
(	O
int	O
)	O
floor	O
(	O
log10	O
(	O
fabs	O
(	O
value	pointer
)	O
)	O
)	O
+	O
1	int
;	O
if	O
(	O
len	int
>	O
buflen	int
)	O
buflen	int
=	O
len	int
;	O
}	O
if	O
(	O
strchr	O
(	O
num_format	struct
.	O
format	pointer
,	O
'\''	O
)	O
&&	O
strchr	O
(	O
"FfGg"	pointer
,	O
num_format	struct
.	O
type	char
)	O
)	O
buflen	int
=	O
buflen	int
*	O
3	int
/	O
2	int
;	O
buf	pointer
=	O
(	O
char	O
*	O
)	O
mymalloc	function
(	O
buflen	int
,	O
"(round_to_displayed)"	pointer
)	O
;	O
sprintf	O
(	O
buf	pointer
,	O
num_format	struct
.	O
format	pointer
,	O
value	pointer
)	O
;	O
if	O
(	O
hasnondigits	pointer
)	O
{	O
if	O
(	O
strspn	O
(	O
buf	pointer
,	O
"1234567890"	pointer
)	O
!=	O
strlen	O
(	O
buf	pointer
)	O
)	O
*	O
hasnondigits	pointer
=	O
1	int
;	O
else	O
*	O
hasnondigits	pointer
=	O
0	int
;	O
}	O
rounded	double
=	O
strtod	O
(	O
buf	pointer
,	O
NULL	O
)	O
;	O
free	function
(	O
buf	pointer
)	O
;	O
return	O
rounded	double
;	O
}	O
void	O
showunitname	function
(	O
double	O
value	pointer
,	O
char	O
*	O
unitstr	pointer
,	O
int	O
printnum	int
)	O
{	O
int	O
hasnondigits	pointer
;	O
double	O
rnd_value	double
;	O
rnd_value	double
=	O
round_to_displayed	function
(	O
value	pointer
,	O
&	O
hasnondigits	pointer
)	O
;	O
if	O
(	O
printnum	int
&&	O
!	O
(	O
rnd_value	double
==	O
1	int
&&	O
isdecimal	function
(	O
*	O
unitstr	pointer
)	O
)	O
)	O
logprintf	function
(	O
num_format	struct
.	O
format	pointer
,	O
value	pointer
)	O
;	O
if	O
(	O
strpbrk	O
(	O
unitstr	pointer
,	O
"+-"	pointer
)	O
)	O
logprintf	function
(	O
" (%s)"	pointer
,	O
unitstr	pointer
)	O
;	O
else	O
if	O
(	O
printnum	int
&&	O
!	O
flags	struct
.	O
showfactor	int
&&	O
startswith	O
(	O
unitstr	pointer
,	O
"1|"	pointer
)	O
&&	O
isfract	function
(	O
unitstr	pointer
)	O
&&	O
rnd_value	double
!=	O
1	int
&&	O
!	O
hasnondigits	pointer
)	O
logputs	function
(	O
unitstr	pointer
+	O
1	int
)	O
;	O
else	O
if	O
(	O
rnd_value	double
==	O
1	int
&&	O
isdecimal	function
(	O
*	O
unitstr	pointer
)	O
)	O
logputs	function
(	O
unitstr	pointer
)	O
;	O
else	O
if	O
(	O
isdecimal	function
(	O
unitstr	pointer
[	O
0	int
]	O
)	O
)	O
logprintf	function
(	O
" * %s"	pointer
,	O
unitstr	pointer
)	O
;	O
else	O
logprintf	function
(	O
" %s"	pointer
,	O
unitstr	pointer
)	O
;	O
}	O
int	O
showanswer	function
(	O
char	O
*	O
havestr	pointer
,	O
struct	O
unittype	O
*	O
have	pointer
,	O
char	O
*	O
wantstr	pointer
,	O
struct	O
unittype	O
*	O
want	struct
)	O
{	O
struct	O
unittype	O
invhave	struct
;	O
int	O
doingrec	int
;	O
char	O
*	O
right	pointer
=	O
NULL	O
,	O
*	O
left	pointer
=	O
NULL	O
;	O
doingrec	int
=	O
0	int
;	O
if	O
(	O
compareunits	function
(	O
have	pointer
,	O
want	struct
,	O
ignore_dimless	function
)	O
)	O
{	O
char	O
*	O
*	O
src	pointer
,	O
*	O
*	O
dest	pointer
;	O
invhave	struct
.	O
factor	double
=	O
1	int
/	O
have	pointer
->	O
factor	double
;	O
for	O
(	O
src	pointer
=	O
have	pointer
->	O
numerator	O
,	O
dest	pointer
=	O
invhave	struct
.	O
denominator	O
;	O
*	O
src	pointer
;	O
src	pointer
++	O
,	O
dest	pointer
++	O
)	O
*	O
dest	pointer
=	O
*	O
src	pointer
;	O
*	O
dest	pointer
=	O
0	int
;	O
for	O
(	O
src	pointer
=	O
have	pointer
->	O
denominator	O
,	O
dest	pointer
=	O
invhave	struct
.	O
numerator	O
;	O
*	O
src	pointer
;	O
src	pointer
++	O
,	O
dest	pointer
++	O
)	O
*	O
dest	pointer
=	O
*	O
src	pointer
;	O
*	O
dest	pointer
=	O
0	int
;	O
if	O
(	O
flags	struct
.	O
strictconvert	int
||	O
compareunits	function
(	O
&	O
invhave	struct
,	O
want	struct
,	O
ignore_dimless	function
)	O
)	O
{	O
showconformabilityerr	function
(	O
havestr	pointer
,	O
have	pointer
,	O
wantstr	pointer
,	O
want	struct
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
flags	struct
.	O
verbose	int
>	O
0	int
)	O
logputchar	function
(	O
'\t'	O
)	O
;	O
logputs	function
(	O
"reciprocal conversion\n"	pointer
)	O
;	O
have	pointer
=	O
&	O
invhave	struct
;	O
doingrec	int
=	O
1	int
;	O
}	O
if	O
(	O
flags	struct
.	O
verbose	int
==	O
2	int
)	O
{	O
if	O
(	O
!	O
doingrec	int
)	O
left	pointer
=	O
right	pointer
=	O
""	pointer
;	O
else	O
if	O
(	O
strchr	O
(	O
havestr	pointer
,	O
'/'	O
)	O
)	O
{	O
left	pointer
=	O
"1 / ("	pointer
;	O
right	pointer
=	O
")"	pointer
;	O
}	O
else	O
{	O
left	pointer
=	O
"1 / "	pointer
;	O
right	pointer
=	O
""	pointer
;	O
}	O
}	O
if	O
(	O
flags	struct
.	O
verbose	int
==	O
2	int
)	O
logprintf	function
(	O
"\t%s%s%s = "	pointer
,	O
left	pointer
,	O
havestr	pointer
,	O
right	pointer
)	O
;	O
else	O
if	O
(	O
flags	struct
.	O
verbose	int
==	O
1	int
)	O
logputs	function
(	O
"\t* "	pointer
)	O
;	O
if	O
(	O
flags	struct
.	O
verbose	int
==	O
2	int
)	O
showunitname	function
(	O
have	pointer
->	O
factor	double
/	O
want	struct
->	O
factor	double
,	O
wantstr	pointer
,	O
PRINTNUM	int
)	O
;	O
else	O
logprintf	function
(	O
num_format	struct
.	O
format	pointer
,	O
have	pointer
->	O
factor	double
/	O
want	struct
->	O
factor	double
)	O
;	O
if	O
(	O
!	O
flags	struct
.	O
oneline	int
)	O
{	O
if	O
(	O
flags	struct
.	O
verbose	int
==	O
2	int
)	O
logprintf	function
(	O
"\n\t%s%s%s = (1 / "	pointer
,	O
left	pointer
,	O
havestr	pointer
,	O
right	pointer
)	O
;	O
else	O
if	O
(	O
flags	struct
.	O
verbose	int
==	O
1	int
)	O
logputs	function
(	O
"\n\t/ "	pointer
)	O
;	O
else	O
logputchar	function
(	O
'\n'	O
)	O
;	O
logprintf	function
(	O
num_format	struct
.	O
format	pointer
,	O
want	struct
->	O
factor	double
/	O
have	pointer
->	O
factor	double
)	O
;	O
if	O
(	O
flags	struct
.	O
verbose	int
==	O
2	int
)	O
{	O
logputchar	function
(	O
')'	O
)	O
;	O
showunitname	function
(	O
0	int
,	O
wantstr	pointer
,	O
NOPRINTNUM	int
)	O
;	O
}	O
}	O
logputchar	function
(	O
'\n'	O
)	O
;	O
return	O
0	int
;	O
}	O
void	O
checkfunc	function
(	O
struct	O
func	pointer
*	O
infunc	pointer
,	O
int	O
verbose	int
)	O
{	O
struct	O
unittype	O
theunit	pointer
,	O
saveunit	struct
;	O
struct	O
prefixlist	struct
*	O
prefix	pointer
;	O
int	O
err	int
,	O
i	int
;	O
double	O
direction	double
;	O
if	O
(	O
infunc	pointer
->	O
skip_error_check	O
)	O
{	O
if	O
(	O
verbose	int
)	O
printf	O
(	O
"skipped function '%s'\n"	pointer
,	O
infunc	pointer
->	O
name	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
verbose	int
)	O
printf	O
(	O
"doing function '%s'\n"	pointer
,	O
infunc	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
(	O
prefix	pointer
=	O
plookup	function
(	O
infunc	pointer
->	O
name	pointer
)	O
)	O
&&	O
strlen	O
(	O
prefix	pointer
->	O
name	pointer
)	O
==	O
strlen	O
(	O
infunc	pointer
->	O
name	pointer
)	O
)	O
printf	O
(	O
"Warning: '%s' defined as prefix and function\n"	pointer
,	O
infunc	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
infunc	pointer
->	O
table	O
)	O
{	O
if	O
(	O
parseunit	function
(	O
&	O
theunit	pointer
,	O
infunc	pointer
->	O
tableunit	pointer
,	O
0	int
,	O
0	int
)	O
||	O
completereduce	function
(	O
&	O
theunit	pointer
)	O
)	O
printf	O
(	O
"Table '%s' has invalid units '%s'\n"	pointer
,	O
infunc	pointer
->	O
name	pointer
,	O
infunc	pointer
->	O
tableunit	pointer
)	O
;	O
freeunit	function
(	O
&	O
theunit	pointer
)	O
;	O
if	O
(	O
infunc	pointer
->	O
tablelen	O
<=	O
1	int
)	O
{	O
printf	O
(	O
"Table '%s' has only one data point\n"	pointer
,	O
infunc	pointer
->	O
name	pointer
)	O
;	O
return	O
;	O
}	O
direction	double
=	O
SIGN	O
(	O
infunc	pointer
->	O
table	O
[	O
1	int
]	O
.	O
value	pointer
-	O
infunc	pointer
->	O
table	O
[	O
0	int
]	O
.	O
value	pointer
)	O
;	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<	O
infunc	pointer
->	O
tablelen	O
;	O
i	int
++	O
)	O
if	O
(	O
SIGN	O
(	O
infunc	pointer
->	O
table	O
[	O
i	int
]	O
.	O
value	pointer
-	O
infunc	pointer
->	O
table	O
[	O
i	int
-	O
1	int
]	O
.	O
value	pointer
)	O
!=	O
direction	double
)	O
{	O
printf	O
(	O
"Table '%s' lacks unique inverse around entry %.8g\n"	pointer
,	O
infunc	pointer
->	O
name	pointer
,	O
infunc	pointer
->	O
table	O
[	O
i	int
]	O
.	O
location	O
)	O
;	O
return	O
;	O
}	O
return	O
;	O
}	O
if	O
(	O
infunc	pointer
->	O
forward	O
.	O
dimen	pointer
)	O
{	O
if	O
(	O
parseunit	function
(	O
&	O
theunit	pointer
,	O
infunc	pointer
->	O
forward	O
.	O
dimen	pointer
,	O
0	int
,	O
0	int
)	O
||	O
completereduce	function
(	O
&	O
theunit	pointer
)	O
)	O
{	O
printf	O
(	O
"Function '%s' has invalid units '%s'\n"	pointer
,	O
infunc	pointer
->	O
name	pointer
,	O
infunc	pointer
->	O
forward	O
.	O
dimen	pointer
)	O
;	O
freeunit	function
(	O
&	O
theunit	pointer
)	O
;	O
return	O
;	O
}	O
}	O
else	O
initializeunit	function
(	O
&	O
theunit	pointer
)	O
;	O
if	O
(	O
infunc	pointer
->	O
forward	O
.	O
domain_max	pointer
&&	O
infunc	pointer
->	O
forward	O
.	O
domain_min	pointer
)	O
theunit	pointer
.	O
factor	double
*=	O
(	O
*	O
infunc	pointer
->	O
forward	O
.	O
domain_max	pointer
+	O
*	O
infunc	pointer
->	O
forward	O
.	O
domain_min	pointer
)	O
/	O
2	int
;	O
else	O
if	O
(	O
infunc	pointer
->	O
forward	O
.	O
domain_max	pointer
)	O
theunit	pointer
.	O
factor	double
=	O
theunit	pointer
.	O
factor	double
*	O
*	O
infunc	pointer
->	O
forward	O
.	O
domain_max	pointer
-	O
1	int
;	O
else	O
if	O
(	O
infunc	pointer
->	O
forward	O
.	O
domain_min	pointer
)	O
theunit	pointer
.	O
factor	double
=	O
theunit	pointer
.	O
factor	double
*	O
*	O
infunc	pointer
->	O
forward	O
.	O
domain_min	pointer
+	O
1	int
;	O
else	O
theunit	pointer
.	O
factor	double
*=	O
7	int
;	O
if	O
(	O
infunc	pointer
->	O
forward	O
.	O
dimen	pointer
)	O
{	O
unitcopy	function
(	O
&	O
saveunit	struct
,	O
&	O
theunit	pointer
)	O
;	O
err	int
=	O
evalfunc	function
(	O
&	O
theunit	pointer
,	O
infunc	pointer
,	O
FUNCTION	int
,	O
ALLERR	int
)	O
;	O
if	O
(	O
err	int
)	O
{	O
printf	O
(	O
"Error in definition %s(%s) as '%s':\n"	pointer
,	O
infunc	pointer
->	O
name	pointer
,	O
infunc	pointer
->	O
forward	O
.	O
param	O
,	O
infunc	pointer
->	O
forward	O
.	O
def	pointer
)	O
;	O
printf	O
(	O
"      %s\n"	pointer
,	O
errormsg	array
[	O
err	int
]	O
)	O
;	O
freeunit	function
(	O
&	O
theunit	pointer
)	O
;	O
freeunit	function
(	O
&	O
saveunit	struct
)	O
;	O
return	O
;	O
}	O
}	O
else	O
{	O
struct	O
unittype	O
resultunit	struct
,	O
arbunit	struct
;	O
char	O
unittext	array
[	O
9	int
]	O
;	O
double	O
factor	double
;	O
int	O
errors	int
[	O
MAXPOWERTOCHECK	int
]	O
,	O
errcount	int
=	O
0	int
;	O
char	O
*	O
indent	pointer
;	O
strcpy	O
(	O
unittext	array
,	O
"(kg K)^ "	pointer
)	O
;	O
factor	double
=	O
theunit	pointer
.	O
factor	double
;	O
initializeunit	function
(	O
&	O
saveunit	struct
)	O
;	O
initializeunit	function
(	O
&	O
resultunit	struct
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
MAXPOWERTOCHECK	int
;	O
i	int
++	O
)	O
{	O
lastchar	O
(	O
unittext	array
)	O
=	O
'0'	O
+	O
i	int
;	O
err	int
=	O
parseunit	function
(	O
&	O
arbunit	struct
,	O
unittext	array
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
err	int
)	O
initializeunit	function
(	O
&	O
arbunit	struct
)	O
;	O
arbunit	struct
.	O
factor	double
=	O
factor	double
;	O
unitcopy	function
(	O
&	O
resultunit	struct
,	O
&	O
arbunit	struct
)	O
;	O
errors	int
[	O
i	int
]	O
=	O
evalfunc	function
(	O
&	O
resultunit	struct
,	O
infunc	pointer
,	O
FUNCTION	int
,	O
ALLERR	int
)	O
;	O
if	O
(	O
errors	int
[	O
i	int
]	O
)	O
errcount	int
++	O
;	O
else	O
{	O
freeunit	function
(	O
&	O
saveunit	struct
)	O
;	O
freeunit	function
(	O
&	O
theunit	pointer
)	O
;	O
unitcopy	function
(	O
&	O
saveunit	struct
,	O
&	O
arbunit	struct
)	O
;	O
unitcopy	function
(	O
&	O
theunit	pointer
,	O
&	O
resultunit	struct
)	O
;	O
}	O
freeunit	function
(	O
&	O
resultunit	struct
)	O
;	O
freeunit	function
(	O
&	O
arbunit	struct
)	O
;	O
}	O
if	O
(	O
!	O
errors	int
[	O
0	int
]	O
&&	O
errcount	int
==	O
3	int
)	O
{	O
printf	O
(	O
"Warning: function '%s(%s)' defined as '%s'\n"	pointer
,	O
infunc	pointer
->	O
name	pointer
,	O
infunc	pointer
->	O
forward	O
.	O
param	O
,	O
infunc	pointer
->	O
forward	O
.	O
def	pointer
)	O
;	O
printf	O
(	O
"         appears to require a dimensionless argument, 'units' keyword not given\n"	pointer
)	O
;	O
indent	pointer
=	O
"         "	pointer
;	O
}	O
else	O
if	O
(	O
errcount	int
==	O
MAXPOWERTOCHECK	int
)	O
{	O
printf	O
(	O
"Error or missing 'units' keyword in definion %s(%s) as '%s'\n"	pointer
,	O
infunc	pointer
->	O
name	pointer
,	O
infunc	pointer
->	O
forward	O
.	O
param	O
,	O
infunc	pointer
->	O
forward	O
.	O
def	pointer
)	O
;	O
indent	pointer
=	O
"      "	pointer
;	O
}	O
else	O
if	O
(	O
errcount	int
)	O
{	O
printf	O
(	O
"Warning: function '%s(%s)' defined as '%s'\n"	pointer
,	O
infunc	pointer
->	O
name	pointer
,	O
infunc	pointer
->	O
forward	O
.	O
param	O
,	O
infunc	pointer
->	O
forward	O
.	O
def	pointer
)	O
;	O
printf	O
(	O
"         failed for some test inputs:\n"	pointer
)	O
;	O
indent	pointer
=	O
"         "	pointer
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
MAXPOWERTOCHECK	int
;	O
i	int
++	O
)	O
if	O
(	O
errors	int
[	O
i	int
]	O
)	O
{	O
lastchar	O
(	O
unittext	array
)	O
=	O
'0'	O
+	O
i	int
;	O
printf	O
(	O
"%s%s("	pointer
,	O
indent	pointer
,	O
infunc	pointer
->	O
name	pointer
)	O
;	O
printf	O
(	O
num_format	struct
.	O
format	pointer
,	O
factor	double
)	O
;	O
printf	O
(	O
"%s): %s\n"	pointer
,	O
unittext	array
,	O
errormsg	array
[	O
errors	int
[	O
i	int
]	O
]	O
)	O
;	O
}	O
}	O
if	O
(	O
completereduce	function
(	O
&	O
theunit	pointer
)	O
)	O
{	O
printf	O
(	O
"Definition %s(%s) as '%s' is irreducible\n"	pointer
,	O
infunc	pointer
->	O
name	pointer
,	O
infunc	pointer
->	O
forward	O
.	O
param	O
,	O
infunc	pointer
->	O
forward	O
.	O
def	pointer
)	O
;	O
freeunit	function
(	O
&	O
theunit	pointer
)	O
;	O
freeunit	function
(	O
&	O
saveunit	struct
)	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
(	O
infunc	pointer
->	O
inverse	int
.	O
def	pointer
)	O
)	O
{	O
printf	O
(	O
"Warning: no inverse for function '%s'\n"	pointer
,	O
infunc	pointer
->	O
name	pointer
)	O
;	O
freeunit	function
(	O
&	O
theunit	pointer
)	O
;	O
freeunit	function
(	O
&	O
saveunit	struct
)	O
;	O
return	O
;	O
}	O
err	int
=	O
evalfunc	function
(	O
&	O
theunit	pointer
,	O
infunc	pointer
,	O
INVERSE	int
,	O
ALLERR	int
)	O
;	O
if	O
(	O
err	int
)	O
{	O
printf	O
(	O
"Error in inverse ~%s(%s) as '%s':\n"	pointer
,	O
infunc	pointer
->	O
name	pointer
,	O
infunc	pointer
->	O
inverse	int
.	O
param	O
,	O
infunc	pointer
->	O
inverse	int
.	O
def	pointer
)	O
;	O
printf	O
(	O
"      %s\n"	pointer
,	O
errormsg	array
[	O
err	int
]	O
)	O
;	O
freeunit	function
(	O
&	O
theunit	pointer
)	O
;	O
freeunit	function
(	O
&	O
saveunit	struct
)	O
;	O
return	O
;	O
}	O
divunit	function
(	O
&	O
theunit	pointer
,	O
&	O
saveunit	struct
)	O
;	O
if	O
(	O
unit2num	function
(	O
&	O
theunit	pointer
)	O
||	O
fabs	O
(	O
theunit	pointer
.	O
factor	double
-	O
1	int
)	O
>	O
1e-12	int
)	O
printf	O
(	O
"Inverse is not the inverse for function '%s'\n"	pointer
,	O
infunc	pointer
->	O
name	pointer
)	O
;	O
freeunit	function
(	O
&	O
theunit	pointer
)	O
;	O
}	O
struct	O
namedef	struct
{	O
char	O
*	O
name	pointer
;	O
char	O
*	O
def	pointer
;	O
}	O
;	O
void	O
addtolist	function
(	O
struct	O
unittype	O
*	O
have	pointer
,	O
char	O
*	O
searchstring	pointer
,	O
char	O
*	O
rname	pointer
,	O
char	O
*	O
name	pointer
,	O
char	O
*	O
def	pointer
,	O
struct	O
namedef	struct
*	O
*	O
list	pointer
,	O
int	O
*	O
listsize	pointer
,	O
int	O
*	O
maxnamelen	pointer
,	O
int	O
*	O
count	pointer
,	O
int	O
searchtype	int
)	O
{	O
struct	O
unittype	O
want	struct
;	O
int	O
len	int
=	O
0	int
;	O
int	O
keepit	int
=	O
0	int
;	O
if	O
(	O
!	O
name	pointer
)	O
return	O
;	O
if	O
(	O
searchtype	int
==	O
CONFORMABLE	int
)	O
{	O
initializeunit	function
(	O
&	O
want	struct
)	O
;	O
if	O
(	O
!	O
parseunit	function
(	O
&	O
want	struct
,	O
name	pointer
,	O
0	int
,	O
0	int
)	O
&&	O
!	O
completereduce	function
(	O
&	O
want	struct
)	O
)	O
keepit	int
=	O
!	O
compareunits	function
(	O
have	pointer
,	O
&	O
want	struct
,	O
ignore_dimless	function
)	O
;	O
}	O
else	O
if	O
(	O
searchtype	int
==	O
TEXTMATCH	int
)	O
{	O
keepit	int
=	O
(	O
strstr	O
(	O
rname	pointer
,	O
searchstring	pointer
)	O
!=	O
NULL	O
)	O
;	O
}	O
if	O
(	O
keepit	int
)	O
{	O
if	O
(	O
*	O
count	pointer
==	O
*	O
listsize	pointer
)	O
{	O
*	O
listsize	pointer
+=	O
100	int
;	O
*	O
list	pointer
=	O
(	O
struct	O
namedef	struct
*	O
)	O
realloc	O
(	O
*	O
list	pointer
,	O
*	O
listsize	pointer
*	O
sizeof	O
(	O
struct	O
namedef	struct
)	O
)	O
;	O
if	O
(	O
!	O
*	O
list	pointer
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"%s: memory allocation error (addtolist)\n"	pointer
,	O
progname	pointer
)	O
;	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
}	O
}	O
(	O
*	O
list	pointer
)	O
[	O
*	O
count	pointer
]	O
.	O
name	pointer
=	O
rname	pointer
;	O
if	O
(	O
strchr	O
(	O
def	pointer
,	O
PRIMITIVECHAR	char
)	O
)	O
(	O
*	O
list	pointer
)	O
[	O
*	O
count	pointer
]	O
.	O
def	pointer
=	O
"<primitive unit>"	pointer
;	O
else	O
(	O
*	O
list	pointer
)	O
[	O
*	O
count	pointer
]	O
.	O
def	pointer
=	O
def	pointer
;	O
(	O
*	O
count	pointer
)	O
++	O
;	O
len	int
=	O
strwidth	function
(	O
name	pointer
)	O
;	O
if	O
(	O
len	int
>	O
*	O
maxnamelen	pointer
)	O
*	O
maxnamelen	pointer
=	O
len	int
;	O
}	O
if	O
(	O
searchtype	int
==	O
CONFORMABLE	int
)	O
freeunit	function
(	O
&	O
want	struct
)	O
;	O
}	O
int	O
compnd	function
(	O
const	O
void	O
*	O
a	double
,	O
const	O
void	O
*	O
b	double
)	O
{	O
return	O
strcmp	O
(	O
(	O
(	O
struct	O
namedef	struct
*	O
)	O
a	double
)	O
->	O
name	pointer
,	O
(	O
(	O
struct	O
namedef	struct
*	O
)	O
b	double
)	O
->	O
name	pointer
)	O
;	O
}	O
int	O
screensize	function
(	O
)	O
{	O
return	O
20	int
;	O
}	O
void	O
tryallunits	function
(	O
struct	O
unittype	O
*	O
have	pointer
,	O
char	O
*	O
searchstring	pointer
)	O
{	O
struct	O
unitlist	struct
*	O
uptr	pointer
;	O
struct	O
namedef	struct
*	O
list	pointer
;	O
int	O
listsize	pointer
,	O
maxnamelen	pointer
,	O
count	pointer
;	O
struct	O
func	pointer
*	O
funcptr	pointer
;	O
struct	O
wantalias	struct
*	O
aliasptr	pointer
;	O
int	O
i	int
,	O
j	int
,	O
searchtype	int
;	O
FILE	O
*	O
outfile	pointer
;	O
char	O
*	O
seploc	pointer
,	O
*	O
firstunit	pointer
;	O
list	pointer
=	O
(	O
struct	O
namedef	struct
*	O
)	O
mymalloc	function
(	O
100	int
*	O
sizeof	O
(	O
struct	O
namedef	struct
)	O
,	O
"(tryallunits)"	pointer
)	O
;	O
listsize	pointer
=	O
100	int
;	O
maxnamelen	pointer
=	O
0	int
;	O
count	pointer
=	O
0	int
;	O
if	O
(	O
have	pointer
)	O
searchtype	int
=	O
CONFORMABLE	int
;	O
else	O
{	O
if	O
(	O
!	O
searchstring	pointer
)	O
searchstring	pointer
=	O
""	pointer
;	O
searchtype	int
=	O
TEXTMATCH	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
HASHSIZE	int
;	O
i	int
++	O
)	O
for	O
(	O
uptr	pointer
=	O
utab	array
[	O
i	int
]	O
;	O
uptr	pointer
;	O
uptr	pointer
=	O
uptr	pointer
->	O
next	pointer
)	O
addtolist	function
(	O
have	pointer
,	O
searchstring	pointer
,	O
uptr	pointer
->	O
name	pointer
,	O
uptr	pointer
->	O
name	pointer
,	O
uptr	pointer
->	O
value	pointer
,	O
&	O
list	pointer
,	O
&	O
listsize	pointer
,	O
&	O
maxnamelen	pointer
,	O
&	O
count	pointer
,	O
searchtype	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
SIMPLEHASHSIZE	int
;	O
i	int
++	O
)	O
for	O
(	O
funcptr	pointer
=	O
ftab	array
[	O
i	int
]	O
;	O
funcptr	pointer
;	O
funcptr	pointer
=	O
funcptr	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
funcptr	pointer
->	O
table	O
)	O
addtolist	function
(	O
have	pointer
,	O
searchstring	pointer
,	O
funcptr	pointer
->	O
name	pointer
,	O
funcptr	pointer
->	O
tableunit	pointer
,	O
"<piecewise linear>"	pointer
,	O
&	O
list	pointer
,	O
&	O
listsize	pointer
,	O
&	O
maxnamelen	pointer
,	O
&	O
count	pointer
,	O
searchtype	int
)	O
;	O
else	O
addtolist	function
(	O
have	pointer
,	O
searchstring	pointer
,	O
funcptr	pointer
->	O
name	pointer
,	O
funcptr	pointer
->	O
inverse	int
.	O
dimen	pointer
,	O
"<nonlinear>"	pointer
,	O
&	O
list	pointer
,	O
&	O
listsize	pointer
,	O
&	O
maxnamelen	pointer
,	O
&	O
count	pointer
,	O
searchtype	int
)	O
;	O
}	O
for	O
(	O
aliasptr	pointer
=	O
firstalias	pointer
;	O
aliasptr	pointer
;	O
aliasptr	pointer
=	O
aliasptr	pointer
->	O
next	pointer
)	O
{	O
firstunit	pointer
=	O
dupstr	function
(	O
aliasptr	pointer
->	O
definition	pointer
)	O
;	O
seploc	pointer
=	O
strchr	O
(	O
firstunit	pointer
,	O
UNITSEPCHAR	char
)	O
;	O
*	O
seploc	pointer
=	O
0	int
;	O
addtolist	function
(	O
have	pointer
,	O
searchstring	pointer
,	O
aliasptr	pointer
->	O
name	pointer
,	O
firstunit	pointer
,	O
aliasptr	pointer
->	O
definition	pointer
,	O
&	O
list	pointer
,	O
&	O
listsize	pointer
,	O
&	O
maxnamelen	pointer
,	O
&	O
count	pointer
,	O
searchtype	int
)	O
;	O
free	function
(	O
firstunit	pointer
)	O
;	O
}	O
qsort	function
(	O
list	pointer
,	O
count	pointer
,	O
sizeof	O
(	O
struct	O
namedef	struct
)	O
,	O
compnd	function
)	O
;	O
outfile	pointer
=	O
0	int
;	O
if	O
(	O
count	pointer
==	O
0	int
)	O
puts	function
(	O
"No matching units found."	pointer
)	O
;	O
signal	function
(	O
SIGPIPE	O
,	O
SIG_IGN	O
)	O
;	O
if	O
(	O
count	pointer
>	O
screensize	function
(	O
)	O
)	O
{	O
outfile	pointer
=	O
popen	function
(	O
pager	pointer
,	O
"w"	pointer
)	O
;	O
}	O
if	O
(	O
!	O
outfile	pointer
)	O
outfile	pointer
=	O
stdout	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
count	pointer
;	O
i	int
++	O
)	O
{	O
fputs	function
(	O
list	pointer
[	O
i	int
]	O
.	O
name	pointer
,	O
outfile	pointer
)	O
;	O
for	O
(	O
j	int
=	O
strwidth	function
(	O
list	pointer
[	O
i	int
]	O
.	O
name	pointer
)	O
;	O
j	int
<=	O
maxnamelen	pointer
;	O
j	int
++	O
)	O
putc	function
(	O
' '	O
,	O
outfile	pointer
)	O
;	O
tightprint	function
(	O
outfile	pointer
,	O
list	pointer
[	O
i	int
]	O
.	O
def	pointer
)	O
;	O
fputc	function
(	O
'\n'	O
,	O
outfile	pointer
)	O
;	O
}	O
if	O
(	O
outfile	pointer
!=	O
stdout	O
)	O
pclose	function
(	O
outfile	pointer
)	O
;	O
signal	function
(	O
SIGPIPE	O
,	O
SIG_DFL	O
)	O
;	O
}	O
void	O
getuser_noreadline	function
(	O
char	O
*	O
*	O
buffer	pointer
,	O
int	O
*	O
bufsize	pointer
,	O
const	O
char	O
*	O
query	pointer
)	O
{	O
int	O
valid	pointer
=	O
0	int
;	O
while	O
(	O
!	O
valid	pointer
)	O
{	O
fputs	function
(	O
query	pointer
,	O
stdout	O
)	O
;	O
if	O
(	O
!	O
fgetslong	function
(	O
buffer	pointer
,	O
bufsize	pointer
,	O
stdin	O
,	O
0	int
)	O
)	O
{	O
if	O
(	O
!	O
flags	struct
.	O
quiet	int
)	O
putchar	function
(	O
'\n'	O
)	O
;	O
exit	O
(	O
EXIT_SUCCESS	O
)	O
;	O
}	O
replacectrlchars	function
(	O
*	O
buffer	pointer
)	O
;	O
valid	pointer
=	O
strwidth	function
(	O
*	O
buffer	pointer
)	O
>=	O
0	int
;	O
if	O
(	O
!	O
valid	pointer
)	O
printf	O
(	O
"Error: %s\n"	pointer
,	O
invalid_utf8	pointer
)	O
;	O
}	O
}	O
int	O
checkcwd	function
(	O
char	O
*	O
file	pointer
)	O
{	O
FILE	O
*	O
fp	O
;	O
char	O
*	O
p	int
;	O
fp	O
=	O
fopen	function
(	O
file	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
fp	O
)	O
{	O
fclose	function
(	O
fp	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
char	O
*	O
getprogramname	function
(	O
char	O
*	O
path	pointer
)	O
{	O
size_t	O
proglen	O
;	O
char	O
*	O
p	int
;	O
path	pointer
=	O
pathend	function
(	O
path	pointer
)	O
;	O
proglen	O
=	O
strlen	O
(	O
path	pointer
)	O
;	O
if	O
(	O
(	O
p	int
=	O
strrchr	O
(	O
path	pointer
,	O
'.'	O
)	O
)	O
&&	O
isexe	O
(	O
p	int
)	O
)	O
proglen	O
-=	O
4	int
;	O
return	O
dupnstr	function
(	O
path	pointer
,	O
proglen	O
)	O
;	O
}	O
char	O
*	O
getprogdir	function
(	O
char	O
*	O
progname	pointer
,	O
char	O
*	O
*	O
fullprogname	pointer
)	O
{	O
char	O
*	O
progdir	pointer
=	O
NULL	O
;	O
char	O
*	O
p	int
;	O
if	O
(	O
!	O
progdir	pointer
&&	O
(	O
isfullpath	function
(	O
progname	pointer
)	O
||	O
hasdirsep	O
(	O
progname	pointer
)	O
)	O
)	O
progdir	pointer
=	O
dupstr	function
(	O
progname	pointer
)	O
;	O
if	O
(	O
!	O
progdir	pointer
)	O
{	O
char	O
*	O
env	pointer
;	O
env	pointer
=	O
getenv	function
(	O
"PATH"	pointer
)	O
;	O
if	O
(	O
env	pointer
)	O
{	O
char	O
*	O
direc	pointer
,	O
*	O
direc_end	pointer
,	O
*	O
pathname	pointer
;	O
int	O
len	int
;	O
FILE	O
*	O
fp	O
;	O
pathname	pointer
=	O
mymalloc	function
(	O
strlen	O
(	O
env	pointer
)	O
+	O
strlen	O
(	O
progname	pointer
)	O
+	O
strlen	O
(	O
EXE_EXT	pointer
)	O
+	O
2	int
,	O
"(getprogdir)"	pointer
)	O
;	O
direc	pointer
=	O
env	pointer
;	O
while	O
(	O
direc	pointer
)	O
{	O
direc_end	pointer
=	O
strchr	O
(	O
direc	pointer
,	O
PATHSEP	char
)	O
;	O
if	O
(	O
!	O
direc_end	pointer
)	O
len	int
=	O
strlen	O
(	O
direc	pointer
)	O
;	O
else	O
len	int
=	O
direc_end	pointer
-	O
direc	pointer
;	O
strncpy	O
(	O
pathname	pointer
,	O
direc	pointer
,	O
len	int
)	O
;	O
if	O
(	O
len	int
>	O
0	int
)	O
pathname	pointer
[	O
len	int
++	O
]	O
=	O
'/'	O
;	O
strcpy	O
(	O
pathname	pointer
+	O
len	int
,	O
progname	pointer
)	O
;	O
fp	O
=	O
fopen	function
(	O
pathname	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
fp	O
)	O
{	O
progdir	pointer
=	O
dupstr	function
(	O
pathname	pointer
)	O
;	O
break	O
;	O
}	O
direc	pointer
=	O
direc_end	pointer
;	O
if	O
(	O
direc	pointer
)	O
direc	pointer
++	O
;	O
}	O
free	function
(	O
pathname	pointer
)	O
;	O
if	O
(	O
fp	O
)	O
fclose	function
(	O
fp	O
)	O
;	O
}	O
}	O
if	O
(	O
!	O
progdir	pointer
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"%s: cannot find program directory\n"	pointer
,	O
progname	pointer
)	O
;	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
}	O
*	O
fullprogname	pointer
=	O
dupstr	function
(	O
progdir	pointer
)	O
;	O
p	int
=	O
pathend	function
(	O
progdir	pointer
)	O
;	O
*	O
p	int
=	O
'\0'	O
;	O
return	O
progdir	pointer
;	O
}	O
char	O
*	O
getdatadir	function
(	O
)	O
{	O
int	O
progdirlen	int
;	O
char	O
*	O
p	int
;	O
progdirlen	int
=	O
strlen	O
(	O
progdir	pointer
)	O
;	O
datadir	pointer
=	O
(	O
char	O
*	O
)	O
mymalloc	function
(	O
progdirlen	int
+	O
strlen	O
(	O
DATADIR	pointer
)	O
+	O
2	int
,	O
"(getdatadir)"	pointer
)	O
;	O
strcpy	O
(	O
datadir	pointer
,	O
progdir	pointer
)	O
;	O
if	O
(	O
isdirsep	O
(	O
progdir	pointer
[	O
progdirlen	int
-	O
1	int
]	O
)	O
)	O
datadir	pointer
[	O
progdirlen	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
p	int
=	O
pathend	function
(	O
datadir	pointer
)	O
;	O
if	O
(	O
(	O
strlen	O
(	O
p	int
)	O
==	O
3	int
)	O
&&	O
(	O
tolower	O
(	O
p	int
[	O
0	int
]	O
)	O
==	O
'b'	O
)	O
&&	O
(	O
tolower	O
(	O
p	int
[	O
1	int
]	O
)	O
==	O
'i'	O
)	O
&&	O
(	O
tolower	O
(	O
p	int
[	O
2	int
]	O
)	O
==	O
'n'	O
)	O
)	O
{	O
p	int
=	O
DATADIR	pointer
;	O
while	O
(	O
*	O
p	int
==	O
'.'	O
)	O
p	int
++	O
;	O
if	O
(	O
isdirsep	O
(	O
*	O
p	int
)	O
)	O
p	int
++	O
;	O
strcpy	O
(	O
pathend	function
(	O
datadir	pointer
)	O
,	O
p	int
)	O
;	O
return	O
datadir	pointer
;	O
}	O
else	O
return	O
NULL	O
;	O
}	O
char	O
*	O
findlocalemap	function
(	O
int	O
checkonly	int
)	O
{	O
FILE	O
*	O
map	O
=	O
NULL	O
;	O
char	O
*	O
filename	pointer
=	O
NULL	O
;	O
char	O
*	O
file	pointer
;	O
file	pointer
=	O
getenv	function
(	O
"UNITSLOCALEMAP"	pointer
)	O
;	O
if	O
(	O
file	pointer
&&	O
*	O
file	pointer
)	O
{	O
map	O
=	O
fopen	function
(	O
file	pointer
,	O
"rt"	pointer
)	O
;	O
if	O
(	O
!	O
map	O
)	O
{	O
if	O
(	O
!	O
checkonly	int
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"%s: cannot open locale map '%s'\n  specified in UNITSLOCALEMAP environment variable. "	pointer
,	O
progname	pointer
,	O
file	pointer
)	O
;	O
perror	function
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
else	O
filename	pointer
=	O
dupstr	function
(	O
file	pointer
)	O
;	O
}	O
if	O
(	O
!	O
map	O
)	O
{	O
file	pointer
=	O
LOCALEMAP	O
;	O
map	O
=	O
fopen	function
(	O
file	pointer
,	O
"rt"	pointer
)	O
;	O
if	O
(	O
map	O
)	O
filename	pointer
=	O
dupstr	function
(	O
file	pointer
)	O
;	O
}	O
if	O
(	O
!	O
map	O
&&	O
!	O
progdir	pointer
)	O
{	O
if	O
(	O
!	O
checkonly	int
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"%s: cannot find locale map--program directory not set\n"	pointer
,	O
progname	pointer
)	O
;	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
}	O
else	O
return	O
NULL	O
;	O
}	O
if	O
(	O
!	O
map	O
)	O
{	O
filename	pointer
=	O
(	O
char	O
*	O
)	O
mymalloc	function
(	O
strlen	O
(	O
progdir	pointer
)	O
+	O
strlen	O
(	O
file	pointer
)	O
+	O
2	int
,	O
"(findlocalemap)"	pointer
)	O
;	O
strcpy	O
(	O
filename	pointer
,	O
progdir	pointer
)	O
;	O
strcat	O
(	O
filename	pointer
,	O
file	pointer
)	O
;	O
map	O
=	O
fopen	function
(	O
filename	pointer
,	O
"rt"	pointer
)	O
;	O
}	O
if	O
(	O
!	O
map	O
&&	O
!	O
emptystr	O
(	O
DATADIR	pointer
)	O
)	O
{	O
if	O
(	O
!	O
datadir	pointer
)	O
datadir	pointer
=	O
getdatadir	function
(	O
)	O
;	O
if	O
(	O
datadir	pointer
)	O
{	O
if	O
(	O
filename	pointer
)	O
free	function
(	O
filename	pointer
)	O
;	O
filename	pointer
=	O
(	O
char	O
*	O
)	O
mymalloc	function
(	O
strlen	O
(	O
datadir	pointer
)	O
+	O
strlen	O
(	O
DATADIR	pointer
)	O
+	O
strlen	O
(	O
file	pointer
)	O
+	O
2	int
,	O
"(findlocalemap)"	pointer
)	O
;	O
strcpy	O
(	O
filename	pointer
,	O
datadir	pointer
)	O
;	O
strcat	O
(	O
filename	pointer
,	O
"/"	pointer
)	O
;	O
strcat	O
(	O
filename	pointer
,	O
file	pointer
)	O
;	O
map	O
=	O
fopen	function
(	O
filename	pointer
,	O
"rt"	pointer
)	O
;	O
}	O
}	O
if	O
(	O
!	O
map	O
)	O
{	O
if	O
(	O
filename	pointer
)	O
free	function
(	O
filename	pointer
)	O
;	O
filename	pointer
=	O
(	O
char	O
*	O
)	O
mymalloc	function
(	O
strlen	O
(	O
unitsfiles	array
[	O
0	int
]	O
)	O
+	O
strlen	O
(	O
file	pointer
)	O
+	O
2	int
,	O
"(findlocalemap)"	pointer
)	O
;	O
strcpy	O
(	O
filename	pointer
,	O
unitsfiles	array
[	O
0	int
]	O
)	O
;	O
strcpy	O
(	O
pathend	function
(	O
filename	pointer
)	O
,	O
file	pointer
)	O
;	O
map	O
=	O
fopen	function
(	O
filename	pointer
,	O
"rt"	pointer
)	O
;	O
}	O
if	O
(	O
map	O
)	O
{	O
fclose	function
(	O
map	O
)	O
;	O
return	O
filename	pointer
;	O
}	O
else	O
{	O
if	O
(	O
filename	pointer
)	O
free	function
(	O
filename	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
char	O
*	O
findunitsfile	function
(	O
int	O
noerrmsg	int
)	O
{	O
FILE	O
*	O
testfile	O
=	O
0	int
;	O
char	O
*	O
file	pointer
;	O
file	pointer
=	O
getenv	function
(	O
"UNITSFILE"	pointer
)	O
;	O
if	O
(	O
file	pointer
&&	O
*	O
file	pointer
)	O
{	O
testfile	O
=	O
fopen	function
(	O
file	pointer
,	O
"rt"	pointer
)	O
;	O
if	O
(	O
!	O
testfile	O
)	O
{	O
if	O
(	O
!	O
noerrmsg	int
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"%s: cannot open units file '%s' in environment variable UNITSFILE.  "	pointer
,	O
progname	pointer
,	O
file	pointer
)	O
;	O
perror	function
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
}	O
if	O
(	O
!	O
testfile	O
&&	O
isfullpath	function
(	O
UNITSFILE	O
)	O
)	O
{	O
file	pointer
=	O
UNITSFILE	O
;	O
testfile	O
=	O
fopen	function
(	O
file	pointer
,	O
"rt"	pointer
)	O
;	O
if	O
(	O
!	O
testfile	O
)	O
{	O
if	O
(	O
!	O
noerrmsg	int
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"%s: cannot open units data file '%s'.  "	pointer
,	O
progname	pointer
,	O
UNITSFILE	O
)	O
;	O
perror	function
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
}	O
if	O
(	O
!	O
testfile	O
&&	O
!	O
progdir	pointer
)	O
{	O
if	O
(	O
!	O
noerrmsg	int
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"%s: cannot open units file '%s' and cannot find program directory.\n"	pointer
,	O
progname	pointer
,	O
UNITSFILE	O
)	O
;	O
perror	function
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
if	O
(	O
!	O
testfile	O
)	O
{	O
file	pointer
=	O
(	O
char	O
*	O
)	O
mymalloc	function
(	O
strlen	O
(	O
progdir	pointer
)	O
+	O
strlen	O
(	O
UNITSFILE	O
)	O
+	O
1	int
,	O
"(findunitsfile)"	pointer
)	O
;	O
strcpy	O
(	O
file	pointer
,	O
progdir	pointer
)	O
;	O
strcat	O
(	O
file	pointer
,	O
UNITSFILE	O
)	O
;	O
testfile	O
=	O
fopen	function
(	O
file	pointer
,	O
"rt"	pointer
)	O
;	O
if	O
(	O
!	O
testfile	O
)	O
free	function
(	O
file	pointer
)	O
;	O
}	O
if	O
(	O
!	O
testfile	O
&&	O
!	O
emptystr	O
(	O
DATADIR	pointer
)	O
)	O
{	O
if	O
(	O
!	O
datadir	pointer
)	O
datadir	pointer
=	O
getdatadir	function
(	O
)	O
;	O
if	O
(	O
datadir	pointer
)	O
{	O
file	pointer
=	O
(	O
char	O
*	O
)	O
mymalloc	function
(	O
strlen	O
(	O
datadir	pointer
)	O
+	O
strlen	O
(	O
UNITSFILE	O
)	O
+	O
2	int
,	O
"(findunitsfile)"	pointer
)	O
;	O
strcpy	O
(	O
file	pointer
,	O
datadir	pointer
)	O
;	O
strcat	O
(	O
file	pointer
,	O
"/"	pointer
)	O
;	O
strcat	O
(	O
file	pointer
,	O
UNITSFILE	O
)	O
;	O
testfile	O
=	O
fopen	function
(	O
file	pointer
,	O
"rt"	pointer
)	O
;	O
if	O
(	O
!	O
testfile	O
)	O
free	function
(	O
file	pointer
)	O
;	O
}	O
}	O
if	O
(	O
!	O
testfile	O
)	O
{	O
if	O
(	O
!	O
noerrmsg	int
)	O
fprintf	function
(	O
stderr	O
,	O
"%s: cannot find units file '%s'\n"	pointer
,	O
progname	pointer
,	O
UNITSFILE	O
)	O
;	O
return	O
NULL	O
;	O
}	O
else	O
{	O
fclose	function
(	O
testfile	O
)	O
;	O
return	O
file	pointer
;	O
}	O
}	O
char	O
*	O
personalfile	function
(	O
const	O
char	O
*	O
envname	pointer
,	O
const	O
char	O
*	O
basename	pointer
,	O
int	O
checkonly	int
,	O
int	O
*	O
exists	pointer
)	O
{	O
FILE	O
*	O
testfile	O
=	O
0	int
;	O
char	O
*	O
homedir	pointer
,	O
*	O
filename	pointer
=	O
0	int
;	O
*	O
exists	pointer
=	O
0	int
;	O
if	O
(	O
envname	pointer
)	O
filename	pointer
=	O
getenv	function
(	O
envname	pointer
)	O
;	O
if	O
(	O
filename	pointer
&&	O
*	O
filename	pointer
)	O
{	O
testfile	O
=	O
fopen	function
(	O
filename	pointer
,	O
"rt"	pointer
)	O
;	O
if	O
(	O
testfile	O
)	O
{	O
fclose	function
(	O
testfile	O
)	O
;	O
*	O
exists	pointer
=	O
1	int
;	O
return	O
filename	pointer
;	O
}	O
if	O
(	O
checkonly	int
)	O
return	O
filename	pointer
;	O
else	O
{	O
fprintf	function
(	O
stderr	O
,	O
"%s: cannot open file '%s' specified in %s environment variable. "	pointer
,	O
progname	pointer
,	O
filename	pointer
,	O
envname	pointer
)	O
;	O
perror	function
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
homedir	pointer
=	O
getenv	function
(	O
"HOME"	pointer
)	O
;	O
if	O
(	O
homedir	pointer
)	O
{	O
filename	pointer
=	O
mymalloc	function
(	O
strlen	O
(	O
homedir	pointer
)	O
+	O
strlen	O
(	O
basename	pointer
)	O
+	O
2	int
,	O
"(personalfile)"	pointer
)	O
;	O
strcpy	O
(	O
filename	pointer
,	O
homedir	pointer
)	O
;	O
}	O
else	O
{	O
return	O
0	int
;	O
}	O
strcat	O
(	O
filename	pointer
,	O
"/"	pointer
)	O
;	O
strcat	O
(	O
filename	pointer
,	O
basename	pointer
)	O
;	O
testfile	O
=	O
fopen	function
(	O
filename	pointer
,	O
"rt"	pointer
)	O
;	O
if	O
(	O
testfile	O
)	O
{	O
fclose	function
(	O
testfile	O
)	O
;	O
*	O
exists	pointer
=	O
1	int
;	O
return	O
filename	pointer
;	O
}	O
if	O
(	O
checkonly	int
)	O
return	O
filename	pointer
;	O
else	O
{	O
if	O
(	O
errno	O
==	O
EACCES	O
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"%s: cannot read file '%s'.  "	pointer
,	O
progname	pointer
,	O
filename	pointer
)	O
;	O
perror	function
(	O
0	int
)	O
;	O
}	O
free	function
(	O
filename	pointer
)	O
;	O
return	O
0	int
;	O
}	O
}	O
void	O
usage	function
(	O
)	O
{	O
char	O
*	O
unitsfile	pointer
;	O
unitsfile	pointer
=	O
findunitsfile	function
(	O
1	int
)	O
;	O
printf	O
(	O
"\nUsage: %s [options] ['from-unit' 'to-unit']\n"	pointer
,	O
progname	pointer
)	O
;	O
printf	O
(	O
"\nOptions:\n    -h, --help           show this help and exit\n    -c, --check          check that all units reduce to primitive units\n        --check-verbose  like --check, but lists units as they are checked\n        --verbose-check    so you can find units that cause endless loops\n    -d, --digits         show output to specified number of digits (default: %d)\n    -e, --exponential    exponential format output\n    -f, --file           specify a units data file (-f '' loads default file)\n"	pointer
,	O
DEFAULTPRECISION	int
)	O
;	O
printf	O
(	O
"    -L, --log            specify a file to log conversions\n    -l, --locale         specify a desired locale\n    -m, --minus          make - into a subtraction operator (default)\n        --oldstar        use old '*' precedence, higher than '/'\n        --newstar        use new '*' precedence, equal to '/'\n    -n, --nolists        disable conversion to unit lists\n    -S, --show-factor    show non-unity factor before 1|x in multi-unit output\n    -o, --output-format  specify printf numeric output format (default: %%.%d%c)\n    -p, --product        make '-' into a product operator\n    -q, --quiet          suppress prompting\n        --silent         same as --quiet\n    -s, --strict         suppress reciprocal unit conversion (e.g. Hz<->s)\n    -v, --verbose        show slightly more verbose output\n        --compact        suppress printing of tab, '*', and '/' character\n    -1, --one-line       suppress the second line of output\n    -t, --terse          terse output (--strict --compact --quiet --one-line)\n    -r, --round          round last element of unit list output to an integer\n    -U, --unitsfile      show units data filename and exit\n    -u, --units          specify a CGS unit system (gauss[ian]|esu|emu)\n    -V, --version        show version, data filenames (with -t: version only)\n    -I, --info           show version, files, and program properties\n"	pointer
,	O
DEFAULTTYPE	char
,	O
DEFAULTPRECISION	int
)	O
;	O
if	O
(	O
!	O
unitsfile	pointer
)	O
printf	O
(	O
"Units data file '%s' not found.\n\n"	pointer
,	O
UNITSFILE	O
)	O
;	O
else	O
printf	O
(	O
"To learn about the available units look in '%s'\n\n"	pointer
,	O
unitsfile	pointer
)	O
;	O
puts	function
(	O
"Report bugs to adrianm@gnu.org.\n\n"	pointer
)	O
;	O
}	O
void	O
helpmsg	function
(	O
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"\nTry '%s --help' for more information.\n"	pointer
,	O
progname	pointer
)	O
;	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
}	O
void	O
printversion	function
(	O
)	O
{	O
int	O
exists	pointer
;	O
char	O
*	O
unitsfile	pointer
,	O
*	O
localemap	pointer
;	O
if	O
(	O
flags	struct
.	O
verbose	int
==	O
0	int
)	O
{	O
printf	O
(	O
"GNU Units version %s\n"	pointer
,	O
VERSION	pointer
)	O
;	O
return	O
;	O
}	O
printf	O
(	O
"GNU Units version %s\n%s, %s, locale %s\n"	pointer
,	O
VERSION	pointer
,	O
RVERSTR	pointer
,	O
UTF8VERSTR	pointer
,	O
mylocale	pointer
)	O
;	O
if	O
(	O
flags	struct
.	O
verbose	int
==	O
2	int
)	O
{	O
if	O
(	O
!	O
fullprogname	pointer
)	O
getprogdir	function
(	O
progname	pointer
,	O
&	O
fullprogname	pointer
)	O
;	O
if	O
(	O
fullprogname	pointer
)	O
printf	O
(	O
"\n%s program is %s\n"	pointer
,	O
progname	pointer
,	O
fullprogname	pointer
)	O
;	O
}	O
if	O
(	O
flags	struct
.	O
verbose	int
==	O
2	int
)	O
{	O
putchar	function
(	O
'\n'	O
)	O
;	O
unitsfile	pointer
=	O
getenv	function
(	O
"UNITSFILE"	pointer
)	O
;	O
if	O
(	O
unitsfile	pointer
)	O
printf	O
(	O
"Environment variable UNITSFILE set to '%s'\n"	pointer
,	O
unitsfile	pointer
)	O
;	O
else	O
puts	function
(	O
"Environment variable UNITSFILE not set"	pointer
)	O
;	O
if	O
(	O
isfullpath	function
(	O
UNITSFILE	O
)	O
)	O
printf	O
(	O
"Default units data file is '%s'\n"	pointer
,	O
UNITSFILE	O
)	O
;	O
else	O
printf	O
(	O
"Default units data file is '%s';\n  %s will search for this file\n"	pointer
,	O
UNITSFILE	O
,	O
progname	pointer
)	O
;	O
}	O
unitsfile	pointer
=	O
findunitsfile	function
(	O
1	int
)	O
;	O
if	O
(	O
unitsfile	pointer
&&	O
flags	struct
.	O
verbose	int
==	O
2	int
&&	O
!	O
isfullpath	function
(	O
UNITSFILE	O
)	O
)	O
printf	O
(	O
"Found data file '%s'\n"	pointer
,	O
unitsfile	pointer
)	O
;	O
else	O
if	O
(	O
unitsfile	pointer
)	O
printf	O
(	O
"Units data file is '%s'\n"	pointer
,	O
unitsfile	pointer
)	O
;	O
else	O
puts	function
(	O
"*** Units data file not found ***"	pointer
)	O
;	O
if	O
(	O
flags	struct
.	O
verbose	int
==	O
2	int
)	O
{	O
putchar	function
(	O
'\n'	O
)	O
;	O
unitsfile	pointer
=	O
getenv	function
(	O
HOME_UNITS_ENV	pointer
)	O
;	O
if	O
(	O
unitsfile	pointer
)	O
printf	O
(	O
"Environment variable %s set to '%s'\n"	pointer
,	O
HOME_UNITS_ENV	pointer
,	O
unitsfile	pointer
)	O
;	O
else	O
printf	O
(	O
"Environment variable %s not set\n"	pointer
,	O
HOME_UNITS_ENV	pointer
)	O
;	O
}	O
unitsfile	pointer
=	O
personalfile	function
(	O
HOME_UNITS_ENV	pointer
,	O
homeunitsfile	pointer
,	O
1	int
,	O
&	O
exists	pointer
)	O
;	O
if	O
(	O
unitsfile	pointer
)	O
{	O
printf	O
(	O
"Personal units data file is '%s'"	pointer
,	O
unitsfile	pointer
)	O
;	O
if	O
(	O
!	O
exists	pointer
)	O
puts	function
(	O
"\n  (file does not exist)"	pointer
)	O
;	O
else	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
else	O
puts	function
(	O
"Personal units data file not found: no home directory"	pointer
)	O
;	O
printf	O
(	O
"\n\n%s\n\n"	pointer
,	O
LICENSE	pointer
)	O
;	O
}	O
void	O
showunitsfile	function
(	O
)	O
{	O
char	O
*	O
unitsfile	pointer
;	O
unitsfile	pointer
=	O
findunitsfile	function
(	O
1	int
)	O
;	O
if	O
(	O
unitsfile	pointer
)	O
printf	O
(	O
"%s\n"	pointer
,	O
unitsfile	pointer
)	O
;	O
else	O
puts	function
(	O
"Units data file not found"	pointer
)	O
;	O
}	O
char	O
*	O
shortoptions	pointer
=	O
"VIUu:vqechSstf:o:d:mnpr1l:L:"	pointer
;	O
struct	O
option	O
longoptions	int
[	O
]	O
=	O
{	O
{	O
"check"	pointer
,	O
no_argument	O
,	O
&	O
flags	struct
.	O
unitcheck	int
,	O
1	int
}	O
,	O
{	O
"check-verbose"	pointer
,	O
no_argument	O
,	O
&	O
flags	struct
.	O
unitcheck	int
,	O
2	int
}	O
,	O
{	O
"compact"	pointer
,	O
no_argument	O
,	O
&	O
flags	struct
.	O
verbose	int
,	O
0	int
}	O
,	O
{	O
"digits"	pointer
,	O
required_argument	O
,	O
0	int
,	O
'd'	O
}	O
,	O
{	O
"exponential"	pointer
,	O
no_argument	O
,	O
0	int
,	O
'e'	O
}	O
,	O
{	O
"file"	pointer
,	O
required_argument	O
,	O
0	int
,	O
'f'	O
}	O
,	O
{	O
"help"	pointer
,	O
no_argument	O
,	O
0	int
,	O
'h'	O
}	O
,	O
{	O
"info"	pointer
,	O
no_argument	O
,	O
0	int
,	O
'I'	O
}	O
,	O
{	O
"locale"	pointer
,	O
required_argument	O
,	O
0	int
,	O
'l'	O
}	O
,	O
{	O
"log"	pointer
,	O
required_argument	O
,	O
0	int
,	O
'L'	O
}	O
,	O
{	O
"minus"	pointer
,	O
no_argument	O
,	O
&	O
parserflags	struct
.	O
minusminus	O
,	O
1	int
}	O
,	O
{	O
"newstar"	pointer
,	O
no_argument	O
,	O
&	O
parserflags	struct
.	O
oldstar	O
,	O
0	int
}	O
,	O
{	O
"nolists"	pointer
,	O
no_argument	O
,	O
0	int
,	O
'n'	O
}	O
,	O
{	O
"oldstar"	pointer
,	O
no_argument	O
,	O
&	O
parserflags	struct
.	O
oldstar	O
,	O
1	int
}	O
,	O
{	O
"one-line"	pointer
,	O
no_argument	O
,	O
&	O
flags	struct
.	O
oneline	int
,	O
1	int
}	O
,	O
{	O
"output-format"	pointer
,	O
required_argument	O
,	O
0	int
,	O
'o'	O
}	O
,	O
{	O
"product"	pointer
,	O
no_argument	O
,	O
&	O
parserflags	struct
.	O
minusminus	O
,	O
0	int
}	O
,	O
{	O
"quiet"	pointer
,	O
no_argument	O
,	O
&	O
flags	struct
.	O
quiet	int
,	O
1	int
}	O
,	O
{	O
"round"	pointer
,	O
no_argument	O
,	O
0	int
,	O
'r'	O
}	O
,	O
{	O
"show-factor"	pointer
,	O
no_argument	O
,	O
0	int
,	O
'S'	O
}	O
,	O
{	O
"silent"	pointer
,	O
no_argument	O
,	O
&	O
flags	struct
.	O
quiet	int
,	O
1	int
}	O
,	O
{	O
"strict"	pointer
,	O
no_argument	O
,	O
&	O
flags	struct
.	O
strictconvert	int
,	O
1	int
}	O
,	O
{	O
"terse"	pointer
,	O
no_argument	O
,	O
0	int
,	O
't'	O
}	O
,	O
{	O
"unitsfile"	pointer
,	O
no_argument	O
,	O
0	int
,	O
'U'	O
}	O
,	O
{	O
"units"	pointer
,	O
required_argument	O
,	O
0	int
,	O
'u'	O
}	O
,	O
{	O
"verbose"	pointer
,	O
no_argument	O
,	O
&	O
flags	struct
.	O
verbose	int
,	O
2	int
}	O
,	O
{	O
"verbose-check"	pointer
,	O
no_argument	O
,	O
&	O
flags	struct
.	O
unitcheck	int
,	O
2	int
}	O
,	O
{	O
"version"	pointer
,	O
no_argument	O
,	O
0	int
,	O
'V'	O
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
int	O
processargs	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
char	O
*	O
*	O
from	pointer
,	O
char	O
*	O
*	O
to	pointer
)	O
{	O
extern	O
char	O
*	O
optarg	pointer
;	O
extern	O
int	O
optind	int
;	O
int	O
optchar	int
,	O
optindex	int
;	O
int	O
ind	int
;	O
int	O
doprintversion	int
=	O
0	int
;	O
char	O
*	O
unitsys	pointer
=	O
0	int
;	O
while	O
(	O
-	O
1	int
!=	O
(	O
optchar	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
shortoptions	pointer
,	O
longoptions	int
,	O
&	O
optindex	int
)	O
)	O
)	O
{	O
switch	O
(	O
optchar	int
)	O
{	O
case	O
'm'	O
:	O
parserflags	struct
.	O
minusminus	O
=	O
1	int
;	O
break	O
;	O
case	O
'p'	O
:	O
parserflags	struct
.	O
minusminus	O
=	O
0	int
;	O
break	O
;	O
case	O
't'	O
:	O
flags	struct
.	O
oneline	int
=	O
1	int
;	O
flags	struct
.	O
quiet	int
=	O
1	int
;	O
flags	struct
.	O
strictconvert	int
=	O
1	int
;	O
flags	struct
.	O
verbose	int
=	O
0	int
;	O
break	O
;	O
case	O
'd'	O
:	O
if	O
(	O
checksigdigits	function
(	O
optarg	pointer
)	O
<	O
0	int
)	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
else	O
num_format	struct
.	O
format	pointer
=	O
NULL	O
;	O
break	O
;	O
case	O
'e'	O
:	O
num_format	struct
.	O
format	pointer
=	O
NULL	O
;	O
num_format	struct
.	O
type	char
=	O
'e'	O
;	O
break	O
;	O
case	O
'o'	O
:	O
num_format	struct
.	O
format	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'c'	O
:	O
flags	struct
.	O
unitcheck	int
=	O
1	int
;	O
break	O
;	O
case	O
'f'	O
:	O
for	O
(	O
ind	int
=	O
0	int
;	O
unitsfiles	array
[	O
ind	int
]	O
;	O
ind	int
++	O
)	O
;	O
if	O
(	O
ind	int
==	O
MAXFILES	int
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"At most %d -f specifications are allowed\n"	pointer
,	O
MAXFILES	int
)	O
;	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
}	O
if	O
(	O
optarg	pointer
&&	O
*	O
optarg	pointer
)	O
unitsfiles	array
[	O
ind	int
]	O
=	O
optarg	pointer
;	O
else	O
{	O
unitsfiles	array
[	O
ind	int
]	O
=	O
findunitsfile	function
(	O
0	int
)	O
;	O
if	O
(	O
!	O
unitsfiles	array
[	O
ind	int
]	O
)	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
}	O
unitsfiles	array
[	O
ind	int
+	O
1	int
]	O
=	O
0	int
;	O
break	O
;	O
case	O
'L'	O
:	O
logfilename	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'l'	O
:	O
mylocale	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'n'	O
:	O
flags	struct
.	O
unitlists	int
=	O
0	int
;	O
break	O
;	O
case	O
'q'	O
:	O
flags	struct
.	O
quiet	int
=	O
1	int
;	O
break	O
;	O
case	O
'r'	O
:	O
flags	struct
.	O
round	int
=	O
1	int
;	O
break	O
;	O
case	O
'S'	O
:	O
flags	struct
.	O
showfactor	int
=	O
1	int
;	O
break	O
;	O
case	O
's'	O
:	O
flags	struct
.	O
strictconvert	int
=	O
1	int
;	O
break	O
;	O
case	O
'v'	O
:	O
flags	struct
.	O
verbose	int
=	O
2	int
;	O
break	O
;	O
case	O
'1'	O
:	O
flags	struct
.	O
oneline	int
=	O
1	int
;	O
break	O
;	O
case	O
'I'	O
:	O
flags	struct
.	O
verbose	int
=	O
2	int
;	O
case	O
'V'	O
:	O
doprintversion	int
=	O
1	int
;	O
break	O
;	O
case	O
'U'	O
:	O
showunitsfile	function
(	O
)	O
;	O
exit	O
(	O
EXIT_SUCCESS	O
)	O
;	O
break	O
;	O
case	O
'u'	O
:	O
unitsys	pointer
=	O
optarg	pointer
;	O
for	O
(	O
ind	int
=	O
0	int
;	O
unitsys	pointer
[	O
ind	int
]	O
;	O
ind	int
++	O
)	O
unitsys	pointer
[	O
ind	int
]	O
=	O
tolower	O
(	O
unitsys	pointer
[	O
ind	int
]	O
)	O
;	O
break	O
;	O
case	O
'h'	O
:	O
usage	function
(	O
)	O
;	O
exit	O
(	O
EXIT_SUCCESS	O
)	O
;	O
case	O
0	int
:	O
break	O
;	O
case	O
'?'	O
:	O
default	O
:	O
helpmsg	function
(	O
)	O
;	O
}	O
}	O
if	O
(	O
doprintversion	int
)	O
{	O
printversion	function
(	O
)	O
;	O
exit	O
(	O
EXIT_SUCCESS	O
)	O
;	O
}	O
if	O
(	O
unitsys	pointer
)	O
setenv	function
(	O
"UNITS_SYSTEM"	pointer
,	O
unitsys	pointer
,	O
1	int
)	O
;	O
if	O
(	O
flags	struct
.	O
unitcheck	int
)	O
{	O
if	O
(	O
optind	int
!=	O
argc	int
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"Too many arguments (arguments are not allowed with -c).\n"	pointer
)	O
;	O
helpmsg	function
(	O
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
optind	int
==	O
argc	int
-	O
2	int
)	O
{	O
flags	struct
.	O
quiet	int
=	O
1	int
;	O
*	O
from	pointer
=	O
argv	pointer
[	O
optind	int
]	O
;	O
*	O
to	pointer
=	O
dupstr	function
(	O
argv	pointer
[	O
optind	int
+	O
1	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
optind	int
==	O
argc	int
-	O
1	int
)	O
{	O
flags	struct
.	O
quiet	int
=	O
1	int
;	O
*	O
from	pointer
=	O
argv	pointer
[	O
optind	int
]	O
;	O
*	O
to	pointer
=	O
0	int
;	O
return	O
0	int
;	O
}	O
if	O
(	O
optind	int
<	O
argc	int
-	O
2	int
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"Too many arguments (maybe you need quotes).\n"	pointer
)	O
;	O
helpmsg	function
(	O
)	O
;	O
}	O
}	O
return	O
1	int
;	O
}	O
void	O
showpointer	function
(	O
int	O
position	int
)	O
{	O
if	O
(	O
position	int
>=	O
0	int
)	O
{	O
while	O
(	O
position	int
--	O
)	O
putchar	function
(	O
' '	O
)	O
;	O
puts	function
(	O
"^"	pointer
)	O
;	O
}	O
}	O
int	O
processunit	function
(	O
struct	O
unittype	O
*	O
theunit	pointer
,	O
char	O
*	O
unitstr	pointer
,	O
int	O
promptlen	int
)	O
{	O
char	O
*	O
errmsg	pointer
;	O
int	O
errloc	int
,	O
err	int
;	O
char	O
savechar	char
;	O
if	O
(	O
flags	struct
.	O
unitlists	int
&&	O
strchr	O
(	O
unitstr	pointer
,	O
UNITSEPCHAR	char
)	O
)	O
{	O
puts	function
(	O
"Unit list not allowed"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
(	O
err	int
=	O
parseunit	function
(	O
theunit	pointer
,	O
unitstr	pointer
,	O
&	O
errmsg	pointer
,	O
&	O
errloc	int
)	O
)	O
)	O
{	O
if	O
(	O
promptlen	int
>=	O
0	int
)	O
{	O
if	O
(	O
err	int
!=	O
E_UNKNOWNUNIT	O
||	O
!	O
irreducible	pointer
)	O
{	O
if	O
(	O
errloc	int
>	O
0	int
)	O
{	O
savechar	char
=	O
unitstr	pointer
[	O
errloc	int
]	O
;	O
unitstr	pointer
[	O
errloc	int
]	O
=	O
0	int
;	O
showpointer	function
(	O
promptlen	int
+	O
strwidth	function
(	O
unitstr	pointer
)	O
-	O
1	int
)	O
;	O
unitstr	pointer
[	O
errloc	int
]	O
=	O
savechar	char
;	O
}	O
else	O
showpointer	function
(	O
promptlen	int
)	O
;	O
}	O
}	O
else	O
printf	O
(	O
"Error in '%s': "	pointer
,	O
unitstr	pointer
)	O
;	O
fputs	function
(	O
errmsg	pointer
,	O
stdout	O
)	O
;	O
if	O
(	O
err	int
==	O
E_UNKNOWNUNIT	O
&&	O
irreducible	pointer
)	O
printf	O
(	O
" '%s'"	pointer
,	O
irreducible	pointer
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
(	O
err	int
=	O
completereduce	function
(	O
theunit	pointer
)	O
)	O
)	O
{	O
fputs	function
(	O
errormsg	array
[	O
err	int
]	O
,	O
stdout	O
)	O
;	O
if	O
(	O
err	int
==	O
E_UNKNOWNUNIT	O
)	O
printf	O
(	O
" '%s'"	pointer
,	O
irreducible	pointer
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
checkunitlist	function
(	O
char	O
*	O
unitstr	pointer
,	O
int	O
promptlen	int
)	O
{	O
struct	O
unittype	O
unit	pointer
[	O
2	int
]	O
,	O
one	pointer
;	O
char	O
*	O
firstunitstr	pointer
,	O
*	O
nextunitstr	pointer
;	O
int	O
unitidx	int
=	O
0	int
;	O
int	O
printerror	int
=	O
promptlen	int
!=	O
NOERRMSG	O
;	O
initializeunit	function
(	O
&	O
one	pointer
)	O
;	O
firstunitstr	pointer
=	O
unitstr	pointer
;	O
initializeunit	function
(	O
unit	pointer
)	O
;	O
initializeunit	function
(	O
unit	pointer
+	O
1	int
)	O
;	O
while	O
(	O
unitstr	pointer
)	O
{	O
if	O
(	O
(	O
nextunitstr	pointer
=	O
strchr	O
(	O
unitstr	pointer
,	O
UNITSEPCHAR	char
)	O
)	O
!=	O
0	int
)	O
*	O
nextunitstr	pointer
=	O
'\0'	O
;	O
if	O
(	O
!	O
unitstr	pointer
[	O
strspn	O
(	O
unitstr	pointer
,	O
" "	pointer
)	O
]	O
)	O
{	O
if	O
(	O
!	O
nextunitstr	pointer
)	O
{	O
freeunit	function
(	O
unit	pointer
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
printerror	int
)	O
{	O
showpointer	function
(	O
promptlen	int
)	O
;	O
puts	function
(	O
"Error: blank unit not allowed"	pointer
)	O
;	O
}	O
freeunit	function
(	O
unit	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
if	O
(	O
(	O
printerror	int
&&	O
processunit	function
(	O
unit	pointer
+	O
unitidx	int
,	O
unitstr	pointer
,	O
promptlen	int
)	O
)	O
||	O
(	O
!	O
printerror	int
&&	O
(	O
parseunit	function
(	O
unit	pointer
+	O
unitidx	int
,	O
unitstr	pointer
,	O
0	int
,	O
0	int
)	O
||	O
completereduce	function
(	O
unit	pointer
+	O
unitidx	int
)	O
||	O
compareunits	function
(	O
unit	pointer
+	O
unitidx	int
,	O
&	O
one	pointer
,	O
ignore_primitive	function
)	O
)	O
)	O
)	O
{	O
if	O
(	O
printerror	int
)	O
printf	O
(	O
"Error in unit list entry: %s\n"	pointer
,	O
unitstr	pointer
)	O
;	O
freeunit	function
(	O
unit	pointer
)	O
;	O
freeunit	function
(	O
unit	pointer
+	O
1	int
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
unitidx	int
==	O
0	int
)	O
unitidx	int
=	O
1	int
;	O
else	O
{	O
if	O
(	O
compareunits	function
(	O
unit	pointer
,	O
unit	pointer
+	O
1	int
,	O
ignore_dimless	function
)	O
)	O
{	O
if	O
(	O
printerror	int
)	O
{	O
int	O
wasverbose	int
=	O
flags	struct
.	O
verbose	int
;	O
FILE	O
*	O
savelog	O
=	O
logfile	pointer
;	O
logfile	pointer
=	O
0	int
;	O
flags	struct
.	O
verbose	int
=	O
2	int
;	O
*	O
(	O
strchr	O
(	O
firstunitstr	pointer
,	O
UNITSEPCHAR	char
)	O
)	O
=	O
'\0'	O
;	O
removespaces	function
(	O
firstunitstr	pointer
)	O
;	O
removespaces	function
(	O
unitstr	pointer
)	O
;	O
showpointer	function
(	O
promptlen	int
)	O
;	O
showconformabilityerr	function
(	O
firstunitstr	pointer
,	O
unit	pointer
,	O
unitstr	pointer
,	O
unit	pointer
+	O
1	int
)	O
;	O
flags	struct
.	O
verbose	int
=	O
wasverbose	int
;	O
logfile	pointer
=	O
savelog	O
;	O
}	O
freeunit	function
(	O
unit	pointer
)	O
;	O
freeunit	function
(	O
unit	pointer
+	O
1	int
)	O
;	O
return	O
1	int
;	O
}	O
freeunit	function
(	O
unit	pointer
+	O
1	int
)	O
;	O
}	O
if	O
(	O
nextunitstr	pointer
)	O
{	O
if	O
(	O
promptlen	int
>=	O
0	int
)	O
promptlen	int
+=	O
strwidth	function
(	O
unitstr	pointer
)	O
+	O
1	int
;	O
*	O
(	O
nextunitstr	pointer
++	O
)	O
=	O
UNITSEPCHAR	char
;	O
}	O
unitstr	pointer
=	O
nextunitstr	pointer
;	O
}	O
freeunit	function
(	O
unit	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
processwant	function
(	O
struct	O
unittype	O
*	O
theunit	pointer
,	O
char	O
*	O
unitstr	pointer
,	O
int	O
promptlen	int
)	O
{	O
if	O
(	O
flags	struct
.	O
unitlists	int
&&	O
strchr	O
(	O
unitstr	pointer
,	O
UNITSEPCHAR	char
)	O
)	O
return	O
checkunitlist	function
(	O
unitstr	pointer
,	O
promptlen	int
)	O
;	O
else	O
return	O
processunit	function
(	O
theunit	pointer
,	O
unitstr	pointer
,	O
promptlen	int
)	O
;	O
}	O
void	O
checkallaliases	function
(	O
int	O
verbose	int
)	O
{	O
struct	O
wantalias	struct
*	O
aliasptr	pointer
;	O
for	O
(	O
aliasptr	pointer
=	O
firstalias	pointer
;	O
aliasptr	pointer
;	O
aliasptr	pointer
=	O
aliasptr	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
verbose	int
)	O
printf	O
(	O
"doing unit list '%s'\n"	pointer
,	O
aliasptr	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
checkunitlist	function
(	O
aliasptr	pointer
->	O
definition	pointer
,	O
NOERRMSG	O
)	O
)	O
printf	O
(	O
"Unit list '%s' contains errors\n"	pointer
,	O
aliasptr	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
ulookup	function
(	O
aliasptr	pointer
->	O
name	pointer
)	O
)	O
printf	O
(	O
"Unit list '%s' hides a unit definition.\n"	pointer
,	O
aliasptr	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
fnlookup	function
(	O
aliasptr	pointer
->	O
name	pointer
)	O
)	O
printf	O
(	O
"Unit list '%s' hides a function definition.\n"	pointer
,	O
aliasptr	pointer
->	O
name	pointer
)	O
;	O
}	O
}	O
void	O
checkunits	function
(	O
int	O
verbosecheck	int
)	O
{	O
struct	O
unittype	O
have	pointer
,	O
second	pointer
,	O
one	pointer
;	O
struct	O
unitlist	struct
*	O
uptr	pointer
;	O
struct	O
prefixlist	struct
*	O
pptr	pointer
;	O
struct	O
func	pointer
*	O
funcptr	pointer
;	O
char	O
*	O
prefixbuf	pointer
,	O
*	O
testunit	pointer
;	O
int	O
i	int
;	O
initializeunit	function
(	O
&	O
one	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
SIMPLEHASHSIZE	int
;	O
i	int
++	O
)	O
for	O
(	O
funcptr	pointer
=	O
ftab	array
[	O
i	int
]	O
;	O
funcptr	pointer
;	O
funcptr	pointer
=	O
funcptr	pointer
->	O
next	pointer
)	O
checkfunc	function
(	O
funcptr	pointer
,	O
verbosecheck	int
)	O
;	O
checkallaliases	function
(	O
verbosecheck	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
HASHSIZE	int
;	O
i	int
++	O
)	O
for	O
(	O
uptr	pointer
=	O
utab	array
[	O
i	int
]	O
;	O
uptr	pointer
;	O
uptr	pointer
=	O
uptr	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
verbosecheck	int
)	O
printf	O
(	O
"doing '%s'\n"	pointer
,	O
uptr	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
parseunit	function
(	O
&	O
have	pointer
,	O
uptr	pointer
->	O
name	pointer
,	O
0	int
,	O
0	int
)	O
||	O
completereduce	function
(	O
&	O
have	pointer
)	O
||	O
compareunits	function
(	O
&	O
have	pointer
,	O
&	O
one	pointer
,	O
ignore_primitive	function
)	O
)	O
{	O
if	O
(	O
fnlookup	function
(	O
uptr	pointer
->	O
name	pointer
)	O
)	O
printf	O
(	O
"Unit '%s' hidden by function '%s'\n"	pointer
,	O
uptr	pointer
->	O
name	pointer
,	O
uptr	pointer
->	O
name	pointer
)	O
;	O
else	O
printf	O
(	O
"'%s' defined as '%s' irreducible\n"	pointer
,	O
uptr	pointer
->	O
name	pointer
,	O
uptr	pointer
->	O
value	pointer
)	O
;	O
}	O
else	O
{	O
parserflags	struct
.	O
minusminus	O
=	O
!	O
parserflags	struct
.	O
minusminus	O
;	O
parseunit	function
(	O
&	O
second	pointer
,	O
uptr	pointer
->	O
name	pointer
,	O
0	int
,	O
0	int
)	O
;	O
completereduce	function
(	O
&	O
second	pointer
)	O
;	O
if	O
(	O
compareunits	function
(	O
&	O
have	pointer
,	O
&	O
second	pointer
,	O
ignore_nothing	function
)	O
)	O
{	O
printf	O
(	O
"'%s': replace '-' with '+-' for subtraction or '*' to multiply\n"	pointer
,	O
uptr	pointer
->	O
name	pointer
)	O
;	O
}	O
freeunit	function
(	O
&	O
second	pointer
)	O
;	O
parserflags	struct
.	O
minusminus	O
=	O
!	O
parserflags	struct
.	O
minusminus	O
;	O
}	O
freeunit	function
(	O
&	O
have	pointer
)	O
;	O
}	O
testunit	pointer
=	O
"meter"	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
SIMPLEHASHSIZE	int
;	O
i	int
++	O
)	O
for	O
(	O
pptr	pointer
=	O
ptab	array
[	O
i	int
]	O
;	O
pptr	pointer
;	O
pptr	pointer
=	O
pptr	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
verbosecheck	int
)	O
printf	O
(	O
"doing '%s-'\n"	pointer
,	O
pptr	pointer
->	O
name	pointer
)	O
;	O
prefixbuf	pointer
=	O
mymalloc	function
(	O
strlen	O
(	O
pptr	pointer
->	O
name	pointer
)	O
+	O
strlen	O
(	O
testunit	pointer
)	O
+	O
1	int
,	O
"(checkunits)"	pointer
)	O
;	O
strcpy	O
(	O
prefixbuf	pointer
,	O
pptr	pointer
->	O
name	pointer
)	O
;	O
strcat	O
(	O
prefixbuf	pointer
,	O
testunit	pointer
)	O
;	O
if	O
(	O
parseunit	function
(	O
&	O
have	pointer
,	O
prefixbuf	pointer
,	O
0	int
,	O
0	int
)	O
||	O
completereduce	function
(	O
&	O
have	pointer
)	O
||	O
compareunits	function
(	O
&	O
have	pointer
,	O
&	O
one	pointer
,	O
ignore_primitive	function
)	O
)	O
printf	O
(	O
"'%s-' defined as '%s' irreducible\n"	pointer
,	O
pptr	pointer
->	O
name	pointer
,	O
pptr	pointer
->	O
value	pointer
)	O
;	O
else	O
{	O
int	O
plevel	int
;	O
char	O
*	O
ch	pointer
;	O
plevel	int
=	O
0	int
;	O
for	O
(	O
ch	pointer
=	O
pptr	pointer
->	O
value	pointer
;	O
*	O
ch	pointer
;	O
ch	pointer
++	O
)	O
{	O
if	O
(	O
*	O
ch	pointer
==	O
')'	O
)	O
plevel	int
--	O
;	O
else	O
if	O
(	O
*	O
ch	pointer
==	O
'('	O
)	O
plevel	int
++	O
;	O
else	O
if	O
(	O
plevel	int
==	O
0	int
&&	O
*	O
ch	pointer
==	O
'/'	O
)	O
{	O
printf	O
(	O
"'%s-' defined as '%s' contains a bad '/'. (Add parentheses.)\n"	pointer
,	O
pptr	pointer
->	O
name	pointer
,	O
pptr	pointer
->	O
value	pointer
)	O
;	O
break	O
;	O
}	O
}	O
}	O
freeunit	function
(	O
&	O
have	pointer
)	O
;	O
free	function
(	O
prefixbuf	pointer
)	O
;	O
}	O
}	O
int	O
showunitlist	function
(	O
char	O
*	O
havestr	pointer
,	O
struct	O
unittype	O
*	O
have	pointer
,	O
char	O
*	O
wantstr	pointer
)	O
{	O
struct	O
unittype	O
want	struct
,	O
lastwant	struct
;	O
char	O
*	O
lastunitstr	pointer
,	O
*	O
nextunitstr	pointer
,	O
*	O
lastwantstr	pointer
=	O
0	int
;	O
double	O
remainder	double
;	O
double	O
round_dir	double
;	O
double	O
value	pointer
;	O
int	O
firstunit	pointer
=	O
1	int
;	O
int	O
value_shown	int
=	O
0	int
;	O
initializeunit	function
(	O
&	O
want	struct
)	O
;	O
remainder	double
=	O
have	pointer
->	O
factor	double
;	O
lastunitstr	pointer
=	O
0	int
;	O
nextunitstr	pointer
=	O
0	int
;	O
round_dir	double
=	O
0	int
;	O
if	O
(	O
flags	struct
.	O
round	int
)	O
{	O
if	O
(	O
lastchar	O
(	O
wantstr	pointer
)	O
==	O
UNITSEPCHAR	char
)	O
lastchar	O
(	O
wantstr	pointer
)	O
=	O
0	int
;	O
if	O
(	O
(	O
lastwantstr	pointer
=	O
strrchr	O
(	O
wantstr	pointer
,	O
UNITSEPCHAR	char
)	O
)	O
)	O
lastwantstr	pointer
++	O
;	O
}	O
while	O
(	O
wantstr	pointer
)	O
{	O
if	O
(	O
(	O
nextunitstr	pointer
=	O
strchr	O
(	O
wantstr	pointer
,	O
UNITSEPCHAR	char
)	O
)	O
)	O
*	O
(	O
nextunitstr	pointer
++	O
)	O
=	O
'\0'	O
;	O
removespaces	function
(	O
wantstr	pointer
)	O
;	O
if	O
(	O
emptystr	O
(	O
wantstr	pointer
)	O
)	O
wantstr	pointer
=	O
lastunitstr	pointer
;	O
if	O
(	O
processunit	function
(	O
&	O
want	struct
,	O
wantstr	pointer
,	O
NOPOINT	O
)	O
)	O
{	O
freeunit	function
(	O
&	O
want	struct
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
firstunit	pointer
)	O
{	O
if	O
(	O
compareunits	function
(	O
have	pointer
,	O
&	O
want	struct
,	O
ignore_dimless	function
)	O
)	O
{	O
showconformabilityerr	function
(	O
havestr	pointer
,	O
have	pointer
,	O
wantstr	pointer
,	O
&	O
want	struct
)	O
;	O
freeunit	function
(	O
&	O
want	struct
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
flags	struct
.	O
round	int
)	O
{	O
value	pointer
=	O
remainder	double
;	O
if	O
(	O
lastwantstr	pointer
&&	O
*	O
lastwantstr	pointer
)	O
{	O
removespaces	function
(	O
lastwantstr	pointer
)	O
;	O
initializeunit	function
(	O
&	O
lastwant	struct
)	O
;	O
if	O
(	O
processunit	function
(	O
&	O
lastwant	struct
,	O
lastwantstr	pointer
,	O
NOPOINT	O
)	O
)	O
{	O
freeunit	function
(	O
&	O
lastwant	struct
)	O
;	O
return	O
1	int
;	O
}	O
remainder	double
=	O
floor	O
(	O
remainder	double
/	O
lastwant	struct
.	O
factor	double
+	O
0.5	int
)	O
*	O
lastwant	struct
.	O
factor	double
;	O
}	O
else	O
remainder	double
=	O
floor	O
(	O
remainder	double
/	O
want	struct
.	O
factor	double
+	O
0.5	int
)	O
*	O
want	struct
.	O
factor	double
;	O
round_dir	double
=	O
remainder	double
-	O
value	pointer
;	O
}	O
if	O
(	O
flags	struct
.	O
verbose	int
==	O
2	int
)	O
{	O
removespaces	function
(	O
havestr	pointer
)	O
;	O
logprintf	function
(	O
"\t%s = "	pointer
,	O
havestr	pointer
)	O
;	O
}	O
else	O
if	O
(	O
flags	struct
.	O
verbose	int
==	O
1	int
)	O
logputchar	function
(	O
'\t'	O
)	O
;	O
}	O
if	O
(	O
nextunitstr	pointer
)	O
{	O
remainder	double
=	O
want	struct
.	O
factor	double
*	O
modf	O
(	O
remainder	double
/	O
want	struct
.	O
factor	double
,	O
&	O
value	pointer
)	O
;	O
if	O
(	O
round_to_displayed	function
(	O
remainder	double
/	O
want	struct
.	O
factor	double
,	O
NULL	O
)	O
==	O
1	int
)	O
{	O
value	pointer
++	O
;	O
remainder	double
=	O
0	int
;	O
}	O
else	O
if	O
(	O
fabs	O
(	O
remainder	double
/	O
have	pointer
->	O
factor	double
)	O
<	O
DBL_EPSILON	O
)	O
remainder	double
=	O
0	int
;	O
}	O
else	O
{	O
value	pointer
=	O
remainder	double
/	O
want	struct
.	O
factor	double
;	O
if	O
(	O
!	O
flags	struct
.	O
round	int
)	O
{	O
value	pointer
=	O
round_to_displayed	function
(	O
value	pointer
,	O
NULL	O
)	O
;	O
}	O
}	O
if	O
(	O
!	O
flags	struct
.	O
verbose	int
)	O
{	O
if	O
(	O
!	O
firstunit	pointer
)	O
logputchar	function
(	O
UNITSEPCHAR	char
)	O
;	O
logprintf	function
(	O
num_format	struct
.	O
format	pointer
,	O
value	pointer
)	O
;	O
value_shown	int
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
value	pointer
!=	O
0	int
)	O
{	O
if	O
(	O
value_shown	int
)	O
logputs	function
(	O
" + "	pointer
)	O
;	O
showunitname	function
(	O
value	pointer
,	O
wantstr	pointer
,	O
PRINTNUM	int
)	O
;	O
value_shown	int
=	O
1	int
;	O
}	O
}	O
freeunit	function
(	O
&	O
want	struct
)	O
;	O
lastunitstr	pointer
=	O
wantstr	pointer
;	O
wantstr	pointer
=	O
nextunitstr	pointer
;	O
firstunit	pointer
=	O
0	int
;	O
}	O
if	O
(	O
!	O
value_shown	int
)	O
{	O
logputs	function
(	O
"0 "	pointer
)	O
;	O
if	O
(	O
isdecimal	function
(	O
*	O
lastunitstr	pointer
)	O
)	O
logputs	function
(	O
"* "	pointer
)	O
;	O
logputs	function
(	O
lastunitstr	pointer
)	O
;	O
}	O
if	O
(	O
round_dir	double
!=	O
0	int
)	O
{	O
if	O
(	O
flags	struct
.	O
verbose	int
)	O
{	O
if	O
(	O
round_dir	double
>	O
0	int
)	O
logprintf	function
(	O
" (rounded up to nearest %s) "	pointer
,	O
lastunitstr	pointer
)	O
;	O
else	O
logprintf	function
(	O
" (rounded down to nearest %s) "	pointer
,	O
lastunitstr	pointer
)	O
;	O
}	O
else	O
logprintf	function
(	O
"%c%c"	pointer
,	O
UNITSEPCHAR	char
,	O
round_dir	double
>	O
0	int
?	O
'-'	O
:	O
'+'	O
)	O
;	O
}	O
logputchar	function
(	O
'\n'	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
ishelpquery	function
(	O
char	O
*	O
str	pointer
,	O
struct	O
unittype	O
*	O
have	pointer
)	O
{	O
struct	O
unitlist	struct
*	O
unit	pointer
;	O
struct	O
func	pointer
*	O
function	pointer
;	O
struct	O
wantalias	struct
*	O
alias	pointer
;	O
struct	O
prefixlist	struct
*	O
prefix	pointer
;	O
char	O
commandbuf	array
[	O
1000	int
]	O
;	O
int	O
unitline	int
;	O
char	O
*	O
file	pointer
;	O
char	O
*	O
*	O
exitptr	pointer
;	O
if	O
(	O
have	pointer
&&	O
!	O
strcmp	O
(	O
str	pointer
,	O
UNITMATCH	pointer
)	O
)	O
{	O
tryallunits	function
(	O
have	pointer
,	O
0	int
)	O
;	O
return	O
1	int
;	O
}	O
for	O
(	O
exitptr	pointer
=	O
exit_commands	array
;	O
*	O
exitptr	pointer
;	O
exitptr	pointer
++	O
)	O
if	O
(	O
!	O
strcmp	O
(	O
str	pointer
,	O
*	O
exitptr	pointer
)	O
)	O
exit	O
(	O
EXIT_SUCCESS	O
)	O
;	O
if	O
(	O
startswith	O
(	O
str	pointer
,	O
SEARCHCOMMAND	pointer
)	O
)	O
{	O
str	pointer
+=	O
strlen	O
(	O
SEARCHCOMMAND	pointer
)	O
;	O
if	O
(	O
!	O
emptystr	O
(	O
str	pointer
)	O
&&	O
*	O
str	pointer
!=	O
' '	O
)	O
return	O
0	int
;	O
removespaces	function
(	O
str	pointer
)	O
;	O
if	O
(	O
emptystr	O
(	O
str	pointer
)	O
)	O
{	O
printf	O
(	O
"\nType 'search text' to see a list of all unit names \ncontaining 'text' as a substring\n\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
tryallunits	function
(	O
0	int
,	O
str	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
startswith	O
(	O
str	pointer
,	O
HELPCOMMAND	pointer
)	O
)	O
{	O
str	pointer
+=	O
strlen	O
(	O
HELPCOMMAND	pointer
)	O
;	O
if	O
(	O
!	O
emptystr	O
(	O
str	pointer
)	O
&&	O
*	O
str	pointer
!=	O
' '	O
)	O
return	O
0	int
;	O
removespaces	function
(	O
str	pointer
)	O
;	O
if	O
(	O
emptystr	O
(	O
str	pointer
)	O
)	O
{	O
printf	O
(	O
"\nUnits converts between different measuring systems and    %s6 inches\nacts as a units-aware calculator.  At the '%s'    %scm\nprompt, type in the units you want to convert from or             * 15.24\nan expression to evaluate.  At the '%s' prompt,           / 0.065\nenter the units to convert to or press return to see\nthe reduced form or definition.                           %stempF(75)\n                                                          %stempC\nThe first example shows that 6 inches is about 15 cm              23.889\nor (1/0.065) cm.  The second example shows how to\nconvert 75 degrees Fahrenheit to Celsius.  The third      %sbu^(1/3)\nexample converts the cube root of a bushel to a list      %sft;in\nof semicolon-separated units.                                     1 ft + 0.9 in\n\nTo quit from units type 'quit' or 'exit'.       %s2 btu + 450 ft lbf\n                                                %s(kg^2/s)/(day lb/m^2)\nAt the '%s' prompt type '%s' to get a            * 1.0660684e+08\nlist of conformable units.  At either prompt you        / 9.3802611e-09\ntype 'help myunit' to browse the units database\nand read the comments relating to myunit or see         %s6 tbsp sugar\nother units related to myunit.  Typing 'search          %sg\ntext' will show units whose names contain 'text'.               * 75\n                                                                / 0.013333333\n"	pointer
,	O
QUERYHAVE	pointer
,	O
QUERYHAVE	pointer
,	O
QUERYWANT	pointer
,	O
QUERYWANT	pointer
,	O
QUERYHAVE	pointer
,	O
QUERYWANT	pointer
,	O
QUERYHAVE	pointer
,	O
QUERYWANT	pointer
,	O
QUERYHAVE	pointer
,	O
QUERYWANT	pointer
,	O
QUERYWANT	pointer
,	O
UNITMATCH	pointer
,	O
QUERYHAVE	pointer
,	O
QUERYWANT	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
(	O
function	pointer
=	O
fnlookup	function
(	O
str	pointer
)	O
)	O
)	O
{	O
file	pointer
=	O
function	pointer
->	O
file	pointer
;	O
unitline	int
=	O
function	pointer
->	O
linenumber	int
;	O
}	O
else	O
if	O
(	O
(	O
unit	pointer
=	O
ulookup	function
(	O
str	pointer
)	O
)	O
)	O
{	O
unitline	int
=	O
unit	pointer
->	O
linenumber	int
;	O
file	pointer
=	O
unit	pointer
->	O
file	pointer
;	O
}	O
else	O
if	O
(	O
(	O
prefix	pointer
=	O
plookup	function
(	O
str	pointer
)	O
)	O
&&	O
strlen	O
(	O
str	pointer
)	O
==	O
prefix	pointer
->	O
len	int
)	O
{	O
unitline	int
=	O
prefix	pointer
->	O
linenumber	int
;	O
file	pointer
=	O
prefix	pointer
->	O
file	pointer
;	O
}	O
else	O
if	O
(	O
(	O
alias	pointer
=	O
aliaslookup	function
(	O
str	pointer
)	O
)	O
)	O
{	O
unitline	int
=	O
alias	pointer
->	O
linenumber	int
;	O
file	pointer
=	O
alias	pointer
->	O
file	pointer
;	O
}	O
else	O
{	O
printf	O
(	O
"Unknown unit '%s'\n"	pointer
,	O
str	pointer
)	O
;	O
return	O
1	int
;	O
}	O
sprintf	O
(	O
commandbuf	array
,	O
"%s +%d %s"	pointer
,	O
pager	pointer
,	O
unitline	int
,	O
file	pointer
)	O
;	O
if	O
(	O
system	function
(	O
commandbuf	array
)	O
)	O
fprintf	function
(	O
stderr	O
,	O
"%s: cannot invoke pager '%s' to display help\n"	pointer
,	O
progname	pointer
,	O
pager	pointer
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
checklocale	function
(	O
)	O
{	O
char	O
*	O
temp	pointer
;	O
temp	pointer
=	O
setlocale	function
(	O
LC_CTYPE	O
,	O
""	pointer
)	O
;	O
utf8mode	int
=	O
(	O
strcmp	O
(	O
nl_langinfo	function
(	O
CODESET	O
)	O
,	O
"UTF-8"	pointer
)	O
==	O
0	int
)	O
;	O
if	O
(	O
temp	pointer
)	O
{	O
mylocale	pointer
=	O
dupstr	function
(	O
temp	pointer
)	O
;	O
temp	pointer
=	O
strchr	O
(	O
mylocale	pointer
,	O
'.'	O
)	O
;	O
if	O
(	O
temp	pointer
)	O
*	O
temp	pointer
=	O
0	int
;	O
}	O
else	O
mylocale	pointer
=	O
DEFAULTLOCALE	pointer
;	O
}	O
int	O
replacealias	function
(	O
char	O
*	O
*	O
string	pointer
,	O
int	O
*	O
buflen	int
)	O
{	O
int	O
usefree	int
=	O
1	int
;	O
struct	O
wantalias	struct
*	O
aliasptr	pointer
;	O
char	O
*	O
input	pointer
;	O
if	O
(	O
!	O
flags	struct
.	O
readline	int
&&	O
buflen	int
)	O
usefree	int
=	O
0	int
;	O
if	O
(	O
*	O
string	pointer
&&	O
*	O
*	O
string	pointer
)	O
{	O
input	pointer
=	O
*	O
string	pointer
;	O
removespaces	function
(	O
input	pointer
)	O
;	O
if	O
(	O
(	O
aliasptr	pointer
=	O
aliaslookup	function
(	O
input	pointer
)	O
)	O
)	O
{	O
if	O
(	O
checkunitlist	function
(	O
aliasptr	pointer
->	O
definition	pointer
,	O
NOERRMSG	O
)	O
)	O
{	O
puts	function
(	O
"Unit list definition contains errors."	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
usefree	int
)	O
{	O
free	function
(	O
*	O
string	pointer
)	O
;	O
*	O
string	pointer
=	O
dupstr	function
(	O
aliasptr	pointer
->	O
definition	pointer
)	O
;	O
}	O
else	O
{	O
while	O
(	O
strlen	O
(	O
aliasptr	pointer
->	O
definition	pointer
)	O
>	O
*	O
buflen	int
)	O
growbuffer	function
(	O
string	pointer
,	O
buflen	int
)	O
;	O
strcpy	O
(	O
*	O
string	pointer
,	O
aliasptr	pointer
->	O
definition	pointer
)	O
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
void	O
remaplocale	function
(	O
char	O
*	O
filename	pointer
)	O
{	O
FILE	O
*	O
map	O
;	O
char	O
*	O
value	pointer
;	O
char	O
name	pointer
[	O
80	int
]	O
;	O
map	O
=	O
fopen	function
(	O
filename	pointer
,	O
"rt"	pointer
)	O
;	O
if	O
(	O
!	O
map	O
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"%s: cannot open locale map '%s'. "	pointer
,	O
progname	pointer
,	O
filename	pointer
)	O
;	O
perror	function
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
else	O
{	O
while	O
(	O
!	O
feof	function
(	O
map	O
)	O
)	O
{	O
if	O
(	O
!	O
fgets	function
(	O
name	pointer
,	O
80	int
,	O
map	O
)	O
)	O
break	O
;	O
lastchar	O
(	O
name	pointer
)	O
=	O
0	int
;	O
value	pointer
=	O
strchr	O
(	O
name	pointer
,	O
'#'	O
)	O
;	O
if	O
(	O
value	pointer
)	O
*	O
value	pointer
=	O
0	int
;	O
value	pointer
=	O
strchr	O
(	O
name	pointer
,	O
'\t'	O
)	O
;	O
if	O
(	O
!	O
value	pointer
)	O
continue	O
;	O
*	O
value	pointer
++	O
=	O
0	int
;	O
removespaces	function
(	O
value	pointer
)	O
;	O
removespaces	function
(	O
name	pointer
)	O
;	O
if	O
(	O
!	O
strcmp	O
(	O
name	pointer
,	O
mylocale	pointer
)	O
)	O
mylocale	pointer
=	O
dupstr	function
(	O
value	pointer
)	O
;	O
}	O
fclose	function
(	O
map	O
)	O
;	O
}	O
}	O
void	O
close_logfile	function
(	O
void	O
)	O
{	O
if	O
(	O
logfile	pointer
)	O
{	O
fputc	function
(	O
'\n'	O
,	O
logfile	pointer
)	O
;	O
fclose	function
(	O
logfile	pointer
)	O
;	O
}	O
}	O
void	O
open_logfile	function
(	O
void	O
)	O
{	O
time_t	O
logtime	O
;	O
char	O
*	O
timestr	pointer
;	O
logfile	pointer
=	O
fopen	function
(	O
logfilename	pointer
,	O
"at"	pointer
)	O
;	O
if	O
(	O
!	O
logfile	pointer
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"%s: cannot write to log file '%s'.  "	pointer
,	O
progname	pointer
,	O
logfilename	pointer
)	O
;	O
perror	function
(	O
0	int
)	O
;	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
}	O
time	function
(	O
&	O
logtime	O
)	O
;	O
timestr	pointer
=	O
ctime	function
(	O
&	O
logtime	O
)	O
;	O
fprintf	function
(	O
logfile	pointer
,	O
"### Log started %s \n"	pointer
,	O
timestr	pointer
)	O
;	O
atexit	function
(	O
close_logfile	function
)	O
;	O
}	O
void	O
write_files_sig	function
(	O
int	O
sig	int
)	O
{	O
close_logfile	function
(	O
)	O
;	O
signal	function
(	O
sig	int
,	O
SIG_DFL	O
)	O
;	O
raise	function
(	O
sig	int
)	O
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
static	O
struct	O
unittype	O
have	pointer
,	O
want	struct
;	O
char	O
*	O
havestr	pointer
=	O
0	int
,	O
*	O
wantstr	pointer
=	O
0	int
;	O
struct	O
func	pointer
*	O
funcval	pointer
;	O
struct	O
wantalias	struct
*	O
alias	pointer
;	O
int	O
havestrsize	int
=	O
0	int
;	O
int	O
wantstrsize	int
=	O
0	int
;	O
int	O
interactive	int
;	O
int	O
readerr	int
;	O
char	O
*	O
*	O
unitfileptr	pointer
;	O
int	O
unitcount	pointer
=	O
0	int
,	O
prefixcount	pointer
=	O
0	int
,	O
funccount	pointer
=	O
0	int
;	O
char	O
*	O
queryhave	pointer
,	O
*	O
querywant	pointer
,	O
*	O
comment	pointer
;	O
int	O
queryhavewidth	int
,	O
querywantwidth	int
;	O
num_format	struct
.	O
format	pointer
=	O
NULL	O
;	O
num_format	struct
.	O
precision	int
=	O
DEFAULTPRECISION	int
;	O
num_format	struct
.	O
type	char
=	O
DEFAULTTYPE	char
;	O
flags	struct
.	O
quiet	int
=	O
0	int
;	O
flags	struct
.	O
unitcheck	int
=	O
0	int
;	O
flags	struct
.	O
verbose	int
=	O
1	int
;	O
flags	struct
.	O
round	int
=	O
0	int
;	O
flags	struct
.	O
strictconvert	int
=	O
0	int
;	O
flags	struct
.	O
unitlists	int
=	O
1	int
;	O
flags	struct
.	O
oneline	int
=	O
0	int
;	O
flags	struct
.	O
showfactor	int
=	O
0	int
;	O
parserflags	struct
.	O
minusminus	O
=	O
1	int
;	O
parserflags	struct
.	O
oldstar	O
=	O
0	int
;	O
progname	pointer
=	O
getprogramname	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
if	O
(	O
!	O
(	O
isfullpath	function
(	O
UNITSFILE	O
)	O
&&	O
isfullpath	function
(	O
LOCALEMAP	O
)	O
)	O
)	O
progdir	pointer
=	O
getprogdir	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
&	O
fullprogname	pointer
)	O
;	O
else	O
{	O
progdir	pointer
=	O
NULL	O
;	O
fullprogname	pointer
=	O
NULL	O
;	O
}	O
datadir	pointer
=	O
NULL	O
;	O
checklocale	function
(	O
)	O
;	O
flags	struct
.	O
readline	int
=	O
0	int
;	O
unitsfiles	array
[	O
0	int
]	O
=	O
0	int
;	O
interactive	int
=	O
processargs	function
(	O
argc	int
,	O
argv	pointer
,	O
&	O
havestr	pointer
,	O
&	O
wantstr	pointer
)	O
;	O
signal	function
(	O
SIGINT	O
,	O
write_files_sig	function
)	O
;	O
signal	function
(	O
SIGTERM	O
,	O
write_files_sig	function
)	O
;	O
if	O
(	O
logfilename	pointer
)	O
{	O
if	O
(	O
!	O
interactive	int
)	O
fprintf	function
(	O
stderr	O
,	O
"Log file '%s' ignored in non-interactive mode.\n"	pointer
,	O
logfilename	pointer
)	O
;	O
else	O
open_logfile	function
(	O
)	O
;	O
}	O
if	O
(	O
num_format	struct
.	O
format	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
parsenumformat	function
(	O
)	O
)	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
}	O
else	O
setnumformat	function
(	O
)	O
;	O
if	O
(	O
flags	struct
.	O
verbose	int
==	O
0	int
)	O
deftext	pointer
=	O
""	pointer
;	O
if	O
(	O
!	O
unitsfiles	array
[	O
0	int
]	O
)	O
{	O
char	O
*	O
unitsfile	pointer
;	O
unitsfile	pointer
=	O
findunitsfile	function
(	O
0	int
)	O
;	O
if	O
(	O
!	O
unitsfile	pointer
)	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
else	O
{	O
int	O
file_exists	int
;	O
unitsfiles	array
[	O
0	int
]	O
=	O
unitsfile	pointer
;	O
unitsfiles	array
[	O
1	int
]	O
=	O
personalfile	function
(	O
HOME_UNITS_ENV	pointer
,	O
homeunitsfile	pointer
,	O
0	int
,	O
&	O
file_exists	int
)	O
;	O
unitsfiles	array
[	O
2	int
]	O
=	O
0	int
;	O
}	O
}	O
for	O
(	O
unitfileptr	pointer
=	O
unitsfiles	array
;	O
*	O
unitfileptr	pointer
;	O
unitfileptr	pointer
++	O
)	O
{	O
readerr	int
=	O
readunits	function
(	O
*	O
unitfileptr	pointer
,	O
stderr	O
,	O
&	O
unitcount	pointer
,	O
&	O
prefixcount	pointer
,	O
&	O
funccount	pointer
,	O
0	int
)	O
;	O
if	O
(	O
readerr	int
==	O
E_MEMORY	O
)	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
if	O
(	O
readerr	int
==	O
E_FILE	O
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"%s: cannot open units file '%s'.  "	pointer
,	O
progname	pointer
,	O
*	O
unitfileptr	pointer
)	O
;	O
perror	function
(	O
0	int
)	O
;	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
}	O
}	O
if	O
(	O
flags	struct
.	O
quiet	int
)	O
queryhave	pointer
=	O
querywant	pointer
=	O
""	pointer
;	O
else	O
{	O
if	O
(	O
!	O
promptprefix	pointer
)	O
{	O
queryhave	pointer
=	O
QUERYHAVE	pointer
;	O
querywant	pointer
=	O
QUERYWANT	pointer
;	O
}	O
else	O
{	O
queryhave	pointer
=	O
(	O
char	O
*	O
)	O
mymalloc	function
(	O
strlen	O
(	O
promptprefix	pointer
)	O
+	O
strlen	O
(	O
QUERYHAVE	pointer
)	O
+	O
1	int
,	O
"(main)"	pointer
)	O
;	O
querywant	pointer
=	O
(	O
char	O
*	O
)	O
mymalloc	function
(	O
strlen	O
(	O
promptprefix	pointer
)	O
+	O
strlen	O
(	O
QUERYWANT	pointer
)	O
+	O
1	int
,	O
"(main)"	pointer
)	O
;	O
strcpy	O
(	O
queryhave	pointer
,	O
promptprefix	pointer
)	O
;	O
strcat	O
(	O
queryhave	pointer
,	O
QUERYHAVE	pointer
)	O
;	O
memset	O
(	O
querywant	pointer
,	O
' '	O
,	O
strlen	O
(	O
promptprefix	pointer
)	O
)	O
;	O
strcpy	O
(	O
querywant	pointer
+	O
strlen	O
(	O
promptprefix	pointer
)	O
,	O
QUERYWANT	pointer
)	O
;	O
}	O
printf	O
(	O
"%d units, %d prefixes, %d nonlinear units\n\n"	pointer
,	O
unitcount	pointer
,	O
prefixcount	pointer
,	O
funccount	pointer
)	O
;	O
}	O
queryhavewidth	int
=	O
strwidth	function
(	O
queryhave	pointer
)	O
;	O
querywantwidth	int
=	O
strwidth	function
(	O
querywant	pointer
)	O
;	O
if	O
(	O
flags	struct
.	O
unitcheck	int
)	O
{	O
checkunits	function
(	O
flags	struct
.	O
unitcheck	int
==	O
2	int
||	O
flags	struct
.	O
verbose	int
==	O
2	int
)	O
;	O
exit	O
(	O
EXIT_SUCCESS	O
)	O
;	O
}	O
if	O
(	O
!	O
interactive	int
)	O
{	O
replacectrlchars	function
(	O
havestr	pointer
)	O
;	O
if	O
(	O
wantstr	pointer
)	O
replacectrlchars	function
(	O
wantstr	pointer
)	O
;	O
if	O
(	O
strwidth	function
(	O
havestr	pointer
)	O
<	O
0	int
)	O
{	O
printf	O
(	O
"Error: %s on input\n"	pointer
,	O
invalid_utf8	pointer
)	O
;	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
}	O
if	O
(	O
wantstr	pointer
&&	O
strwidth	function
(	O
wantstr	pointer
)	O
<	O
0	int
)	O
{	O
printf	O
(	O
"Error: %s on input\n"	pointer
,	O
invalid_utf8	pointer
)	O
;	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
}	O
replace_minus	function
(	O
havestr	pointer
)	O
;	O
removespaces	function
(	O
havestr	pointer
)	O
;	O
if	O
(	O
wantstr	pointer
)	O
{	O
replace_minus	function
(	O
wantstr	pointer
)	O
;	O
removespaces	function
(	O
wantstr	pointer
)	O
;	O
}	O
if	O
(	O
(	O
funcval	pointer
=	O
fnlookup	function
(	O
havestr	pointer
)	O
)	O
)	O
{	O
showfuncdefinition	function
(	O
funcval	pointer
,	O
FUNCTION	int
)	O
;	O
exit	O
(	O
EXIT_SUCCESS	O
)	O
;	O
}	O
if	O
(	O
(	O
funcval	pointer
=	O
invfnlookup	function
(	O
havestr	pointer
)	O
)	O
)	O
{	O
showfuncdefinition	function
(	O
funcval	pointer
,	O
INVERSE	int
)	O
;	O
exit	O
(	O
EXIT_SUCCESS	O
)	O
;	O
}	O
if	O
(	O
(	O
alias	pointer
=	O
aliaslookup	function
(	O
havestr	pointer
)	O
)	O
)	O
{	O
showunitlistdef	function
(	O
alias	pointer
)	O
;	O
exit	O
(	O
EXIT_SUCCESS	O
)	O
;	O
}	O
if	O
(	O
processunit	function
(	O
&	O
have	pointer
,	O
havestr	pointer
,	O
NOPOINT	O
)	O
)	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
if	O
(	O
!	O
wantstr	pointer
)	O
{	O
showdefinition	function
(	O
havestr	pointer
,	O
&	O
have	pointer
)	O
;	O
exit	O
(	O
EXIT_SUCCESS	O
)	O
;	O
}	O
if	O
(	O
replacealias	function
(	O
&	O
wantstr	pointer
,	O
0	int
)	O
)	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
if	O
(	O
(	O
funcval	pointer
=	O
fnlookup	function
(	O
wantstr	pointer
)	O
)	O
)	O
{	O
if	O
(	O
showfunc	function
(	O
havestr	pointer
,	O
&	O
have	pointer
,	O
funcval	pointer
)	O
)	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
else	O
exit	O
(	O
EXIT_SUCCESS	O
)	O
;	O
}	O
if	O
(	O
processwant	function
(	O
&	O
want	struct
,	O
wantstr	pointer
,	O
NOPOINT	O
)	O
)	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
if	O
(	O
strchr	O
(	O
wantstr	pointer
,	O
UNITSEPCHAR	char
)	O
)	O
{	O
if	O
(	O
showunitlist	function
(	O
havestr	pointer
,	O
&	O
have	pointer
,	O
wantstr	pointer
)	O
)	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
else	O
exit	O
(	O
EXIT_SUCCESS	O
)	O
;	O
}	O
if	O
(	O
showanswer	function
(	O
havestr	pointer
,	O
&	O
have	pointer
,	O
wantstr	pointer
,	O
&	O
want	struct
)	O
)	O
exit	O
(	O
EXIT_FAILURE	O
)	O
;	O
else	O
exit	O
(	O
EXIT_SUCCESS	O
)	O
;	O
}	O
else	O
{	O
pager	pointer
=	O
getenv	function
(	O
"PAGER"	pointer
)	O
;	O
if	O
(	O
!	O
pager	pointer
)	O
pager	pointer
=	O
DEFAULTPAGER	pointer
;	O
for	O
(	O
;	O
;	O
)	O
{	O
do	O
{	O
fflush	function
(	O
stdout	O
)	O
;	O
getuser	O
(	O
&	O
havestr	pointer
,	O
&	O
havestrsize	int
,	O
queryhave	pointer
)	O
;	O
replace_minus	function
(	O
havestr	pointer
)	O
;	O
comment	pointer
=	O
strip_comment	function
(	O
havestr	pointer
)	O
;	O
removespaces	function
(	O
havestr	pointer
)	O
;	O
if	O
(	O
logfile	pointer
&&	O
comment	pointer
&&	O
emptystr	O
(	O
havestr	pointer
)	O
)	O
fprintf	function
(	O
logfile	pointer
,	O
"#%s\n"	pointer
,	O
comment	pointer
)	O
;	O
}	O
while	O
(	O
emptystr	O
(	O
havestr	pointer
)	O
||	O
ishelpquery	function
(	O
havestr	pointer
,	O
0	int
)	O
||	O
(	O
!	O
fnlookup	function
(	O
havestr	pointer
)	O
&&	O
!	O
invfnlookup	function
(	O
havestr	pointer
)	O
&&	O
!	O
aliaslookup	function
(	O
havestr	pointer
)	O
&&	O
processunit	function
(	O
&	O
have	pointer
,	O
havestr	pointer
,	O
queryhavewidth	int
)	O
)	O
)	O
;	O
if	O
(	O
logfile	pointer
)	O
{	O
if	O
(	O
comment	pointer
)	O
fprintf	function
(	O
logfile	pointer
,	O
"%s%s\t#%s\n"	pointer
,	O
LOGFROM	pointer
,	O
havestr	pointer
,	O
comment	pointer
)	O
;	O
else	O
fprintf	function
(	O
logfile	pointer
,	O
"%s%s\n"	pointer
,	O
LOGFROM	pointer
,	O
havestr	pointer
)	O
;	O
}	O
if	O
(	O
(	O
alias	pointer
=	O
aliaslookup	function
(	O
havestr	pointer
)	O
)	O
)	O
{	O
showunitlistdef	function
(	O
alias	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
(	O
funcval	pointer
=	O
fnlookup	function
(	O
havestr	pointer
)	O
)	O
)	O
{	O
showfuncdefinition	function
(	O
funcval	pointer
,	O
FUNCTION	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
(	O
funcval	pointer
=	O
invfnlookup	function
(	O
havestr	pointer
)	O
)	O
)	O
{	O
showfuncdefinition	function
(	O
funcval	pointer
,	O
INVERSE	int
)	O
;	O
continue	O
;	O
}	O
do	O
{	O
int	O
repeat	int
;	O
do	O
{	O
repeat	int
=	O
0	int
;	O
fflush	function
(	O
stdout	O
)	O
;	O
getuser	O
(	O
&	O
wantstr	pointer
,	O
&	O
wantstrsize	int
,	O
querywant	pointer
)	O
;	O
replace_minus	function
(	O
wantstr	pointer
)	O
;	O
comment	pointer
=	O
strip_comment	function
(	O
wantstr	pointer
)	O
;	O
removespaces	function
(	O
wantstr	pointer
)	O
;	O
if	O
(	O
logfile	pointer
&&	O
comment	pointer
&&	O
emptystr	O
(	O
wantstr	pointer
)	O
)	O
{	O
fprintf	function
(	O
logfile	pointer
,	O
"#%s\n"	pointer
,	O
comment	pointer
)	O
;	O
repeat	int
=	O
1	int
;	O
}	O
if	O
(	O
ishelpquery	function
(	O
wantstr	pointer
,	O
&	O
have	pointer
)	O
)	O
{	O
repeat	int
=	O
1	int
;	O
printf	O
(	O
"%s%s\n"	pointer
,	O
queryhave	pointer
,	O
havestr	pointer
)	O
;	O
}	O
}	O
while	O
(	O
repeat	int
)	O
;	O
}	O
while	O
(	O
replacealias	function
(	O
&	O
wantstr	pointer
,	O
&	O
wantstrsize	int
)	O
||	O
(	O
!	O
fnlookup	function
(	O
wantstr	pointer
)	O
&&	O
processwant	function
(	O
&	O
want	struct
,	O
wantstr	pointer
,	O
querywantwidth	int
)	O
)	O
)	O
;	O
if	O
(	O
logfile	pointer
)	O
{	O
fprintf	function
(	O
logfile	pointer
,	O
"%s"	pointer
,	O
LOGTO	pointer
)	O
;	O
tightprint	function
(	O
logfile	pointer
,	O
wantstr	pointer
)	O
;	O
if	O
(	O
comment	pointer
)	O
fprintf	function
(	O
logfile	pointer
,	O
"\t#%s"	pointer
,	O
comment	pointer
)	O
;	O
putc	function
(	O
'\n'	O
,	O
logfile	pointer
)	O
;	O
}	O
if	O
(	O
emptystr	O
(	O
wantstr	pointer
)	O
)	O
showdefinition	function
(	O
havestr	pointer
,	O
&	O
have	pointer
)	O
;	O
else	O
if	O
(	O
strchr	O
(	O
wantstr	pointer
,	O
UNITSEPCHAR	char
)	O
)	O
showunitlist	function
(	O
havestr	pointer
,	O
&	O
have	pointer
,	O
wantstr	pointer
)	O
;	O
else	O
if	O
(	O
(	O
funcval	pointer
=	O
fnlookup	function
(	O
wantstr	pointer
)	O
)	O
)	O
showfunc	function
(	O
havestr	pointer
,	O
&	O
have	pointer
,	O
funcval	pointer
)	O
;	O
else	O
{	O
showanswer	function
(	O
havestr	pointer
,	O
&	O
have	pointer
,	O
wantstr	pointer
,	O
&	O
want	struct
)	O
;	O
freeunit	function
(	O
&	O
want	struct
)	O
;	O
}	O
unitcopy	function
(	O
&	O
lastunit	struct
,	O
&	O
have	pointer
)	O
;	O
lastunitset	int
=	O
1	int
;	O
freeunit	function
(	O
&	O
have	pointer
)	O
;	O
}	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
