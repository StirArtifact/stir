RCSTAG_CC	O
(	O
"$Id$"	pointer
)	O
;	O
static	O
FILE	struct
*	O
output	pointer
=	O
NULL	O
;	O
static	O
BOOLEAN	char
inhibited	char
=	O
0	int
;	O
static	O
buf_break_st_ty	struct
*	O
buf_break_list	pointer
=	O
NULL	O
;	O
buf_break_st_ty	struct
*	O
buf_break	pointer
=	O
NULL	O
;	O
int	O
out_lines	int
=	O
0	int
;	O
int	O
com_lines	int
=	O
0	int
;	O
int	O
prev_target_col_break	int
=	O
0	int
;	O
int	O
buf_break_used	int
=	O
0	int
;	O
int	O
preproc_indent	int
=	O
0	int
;	O
static	O
BOOLEAN	char
better_break	function
(	O
buf_break_st_ty	struct
*	O
b1	pointer
,	O
const	O
buf_break_st_ty	struct
*	O
b2	pointer
)	O
{	O
static	O
int	O
first_level	int
;	O
BOOLEAN	char
is_better	char
;	O
if	O
(	O
!	O
b2	pointer
)	O
{	O
first_level	int
=	O
b1	pointer
->	O
level	int
;	O
b1	pointer
->	O
first_level	int
=	O
first_level	int
;	O
is_better	char
=	O
true	int
;	O
}	O
else	O
{	O
if	O
(	O
b2	pointer
->	O
target_col	int
>=	O
b2	pointer
->	O
col	int
+	O
1	int
)	O
{	O
is_better	char
=	O
true	int
;	O
}	O
else	O
if	O
(	O
settings	struct
.	O
honour_newlines	int
&&	O
b2	pointer
->	O
priority_newline	int
)	O
{	O
is_better	char
=	O
false	int
;	O
}	O
else	O
if	O
(	O
settings	struct
.	O
honour_newlines	int
&&	O
b1	pointer
->	O
priority_newline	int
)	O
{	O
is_better	char
=	O
true	int
;	O
}	O
else	O
{	O
int	O
only_parens_till_b2	int
=	O
0	int
;	O
is_better	char
=	O
(	O
b1	pointer
->	O
priority	int
>	O
b2	pointer
->	O
priority	int
)	O
;	O
if	O
(	O
is_better	char
)	O
{	O
char	O
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
&	O
s_code	pointer
[	O
b2	pointer
->	O
offset	int
]	O
;	O
p	pointer
>=	O
s_code	pointer
;	O
--	O
p	pointer
)	O
{	O
if	O
(	O
*	O
p	pointer
==	O
'!'	O
)	O
{	O
--	O
p	pointer
;	O
}	O
if	O
(	O
*	O
p	pointer
!=	O
'('	O
)	O
{	O
break	O
;	O
}	O
}	O
if	O
(	O
p	pointer
<	O
s_code	pointer
)	O
{	O
only_parens_till_b2	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
settings	struct
.	O
lineup_to_parens	int
&&	O
(	O
b1	pointer
->	O
level	int
>	O
(	O
first_level	int
+	O
1	int
)	O
)	O
&&	O
!	O
(	O
only_parens_till_b2	int
&&	O
(	O
b1	pointer
->	O
target_col	int
<=	O
(	O
b2	pointer
->	O
col	int
+	O
(	O
1	int
+	O
2	int
*	O
b1	pointer
->	O
level	int
)	O
)	O
)	O
)	O
&&	O
(	O
b1	pointer
->	O
level	int
>	O
b2	pointer
->	O
level	int
)	O
)	O
{	O
is_better	char
=	O
false	int
;	O
}	O
}	O
if	O
(	O
is_better	char
)	O
{	O
b1	pointer
->	O
first_level	int
=	O
first_level	int
;	O
}	O
}	O
return	O
is_better	char
;	O
}	O
static	O
void	O
set_priority	function
(	O
buf_break_st_ty	struct
*	O
bb	pointer
)	O
{	O
bb	pointer
->	O
priority	int
=	O
bb	pointer
->	O
priority_code_length	int
;	O
switch	O
(	O
bb	pointer
->	O
priority_code	enum
)	O
{	O
case	O
bb_semicolon	int
:	O
bb	pointer
->	O
priority	int
+=	O
6000	int
;	O
break	O
;	O
case	O
bb_before_boolean_binary_op	int
:	O
bb	pointer
->	O
priority	int
+=	O
5000	int
;	O
break	O
;	O
case	O
bb_after_boolean_binary_op	int
:	O
if	O
(	O
bb	pointer
->	O
priority_code_length	int
>	O
2	int
)	O
{	O
bb	pointer
->	O
priority	int
+=	O
5000	int
;	O
}	O
if	O
(	O
settings	struct
.	O
break_before_boolean_operator	int
)	O
{	O
bb	pointer
->	O
priority	int
-=	O
3	int
;	O
}	O
break	O
;	O
case	O
bb_after_equal_sign	int
:	O
bb	pointer
->	O
priority	int
+=	O
4000	int
;	O
break	O
;	O
case	O
bb_attribute	int
:	O
bb	pointer
->	O
priority	int
+=	O
3000	int
;	O
break	O
;	O
case	O
bb_comma	int
:	O
bb	pointer
->	O
priority	int
+=	O
2000	int
;	O
break	O
;	O
case	O
bb_comparisation	int
:	O
bb	pointer
->	O
priority	int
+=	O
1000	int
;	O
break	O
;	O
case	O
bb_proc_call	int
:	O
bb	pointer
->	O
priority	int
-=	O
1000	int
;	O
break	O
;	O
case	O
bb_operator6	int
:	O
bb	pointer
->	O
priority	int
+=	O
600	int
;	O
break	O
;	O
case	O
bb_operator5	int
:	O
bb	pointer
->	O
priority	int
+=	O
500	int
;	O
break	O
;	O
case	O
bb_operator4	int
:	O
bb	pointer
->	O
priority	int
+=	O
400	int
;	O
break	O
;	O
case	O
bb_operator2	int
:	O
bb	pointer
->	O
priority	int
+=	O
200	int
;	O
break	O
;	O
case	O
bb_doublecolon	int
:	O
bb	pointer
->	O
priority	int
+=	O
100	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
void	O
set_buf_break	function
(	O
bb_code_ty	enum
code	int
,	O
int	O
paren_targ	int
)	O
{	O
int	O
target_col	int
,	O
level	int
;	O
int	O
code_target	int
=	O
compute_code_target	function
(	O
paren_targ	int
)	O
;	O
buf_break_st_ty	struct
*	O
bb	pointer
;	O
target_col	int
=	O
parser_state_tos	pointer
->	O
i_l_follow	int
+	O
1	int
;	O
if	O
(	O
*	O
token	pointer
==	O
'{'	O
)	O
{	O
target_col	int
-=	O
settings	struct
.	O
ind_size	int
;	O
}	O
level	int
=	O
parser_state_tos	pointer
->	O
p_l_follow	int
;	O
if	O
(	O
(	O
*	O
token	pointer
==	O
'('	O
)	O
||	O
(	O
*	O
token	pointer
==	O
'['	O
)	O
)	O
{	O
--	O
level	int
;	O
}	O
if	O
(	O
parser_state_tos	pointer
->	O
procname	pointer
[	O
0	int
]	O
&&	O
(	O
token	pointer
==	O
parser_state_tos	pointer
->	O
procname	pointer
)	O
)	O
{	O
target_col	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
level	int
==	O
0	int
)	O
{	O
if	O
(	O
parser_state_tos	pointer
->	O
in_stmt	int
)	O
{	O
target_col	int
+=	O
settings	struct
.	O
continuation_indent	int
;	O
}	O
}	O
else	O
if	O
(	O
!	O
settings	struct
.	O
lineup_to_parens	int
)	O
{	O
target_col	int
+=	O
settings	struct
.	O
continuation_indent	int
+	O
(	O
settings	struct
.	O
paren_indent	int
*	O
(	O
level	int
-	O
1	int
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
parser_state_tos	pointer
->	O
paren_indents	pointer
[	O
level	int
-	O
1	int
]	O
<	O
0	int
)	O
{	O
target_col	int
=	O
-	O
parser_state_tos	pointer
->	O
paren_indents	pointer
[	O
level	int
-	O
1	int
]	O
;	O
}	O
else	O
{	O
target_col	int
=	O
code_target	int
+	O
parser_state_tos	pointer
->	O
paren_indents	pointer
[	O
level	int
-	O
1	int
]	O
;	O
}	O
}	O
bb	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
buf_break_st_ty	struct
)	O
)	O
;	O
bb	pointer
->	O
offset	int
=	O
e_code	pointer
-	O
s_code	pointer
;	O
bb	pointer
->	O
level	int
=	O
level	int
;	O
bb	pointer
->	O
target_col	int
=	O
target_col	int
;	O
bb	pointer
->	O
corresponds_to	pointer
=	O
token	pointer
;	O
*	O
e_code	pointer
=	O
0	int
;	O
bb	pointer
->	O
col	int
=	O
count_columns	function
(	O
code_target	int
,	O
s_code	pointer
,	O
NULL_CHAR	char
)	O
-	O
1	int
;	O
bb	pointer
->	O
priority_code_length	int
=	O
(	O
e_code	pointer
-	O
s_code	pointer
)	O
;	O
bb	pointer
->	O
priority_newline	int
=	O
(	O
parser_state_tos	pointer
->	O
last_saw_nl	int
&&	O
!	O
parser_state_tos	pointer
->	O
broken_at_non_nl	int
)	O
;	O
if	O
(	O
buf_break	pointer
)	O
{	O
bb	pointer
->	O
first_level	int
=	O
buf_break	pointer
->	O
first_level	int
;	O
}	O
switch	O
(	O
parser_state_tos	pointer
->	O
last_token	enum
)	O
{	O
case	O
binary_op	int
:	O
if	O
(	O
(	O
(	O
e_code	pointer
-	O
s_code	pointer
)	O
>=	O
3	int
)	O
&&	O
(	O
e_code	pointer
[	O
-	O
3	int
]	O
==	O
' '	O
)	O
&&	O
(	O
(	O
(	O
e_code	pointer
[	O
-	O
1	int
]	O
==	O
'&'	O
)	O
&&	O
(	O
e_code	pointer
[	O
-	O
2	int
]	O
==	O
'&'	O
)	O
)	O
||	O
(	O
(	O
e_code	pointer
[	O
-	O
1	int
]	O
==	O
'|'	O
)	O
&&	O
(	O
e_code	pointer
[	O
-	O
2	int
]	O
==	O
'|'	O
)	O
)	O
)	O
)	O
{	O
bb	pointer
->	O
priority_code	enum
=	O
bb_after_boolean_binary_op	int
;	O
}	O
else	O
if	O
(	O
(	O
e_code	pointer
-	O
s_code	pointer
>=	O
2	int
)	O
&&	O
(	O
e_code	pointer
[	O
-	O
1	int
]	O
==	O
'='	O
)	O
&&	O
(	O
(	O
e_code	pointer
[	O
-	O
2	int
]	O
==	O
' '	O
)	O
||	O
(	O
(	O
e_code	pointer
-	O
s_code	pointer
>=	O
3	int
)	O
&&	O
(	O
e_code	pointer
[	O
-	O
3	int
]	O
==	O
' '	O
)	O
&&	O
(	O
(	O
e_code	pointer
[	O
-	O
2	int
]	O
==	O
'%'	O
)	O
||	O
(	O
e_code	pointer
[	O
-	O
2	int
]	O
==	O
'^'	O
)	O
||	O
(	O
e_code	pointer
[	O
-	O
2	int
]	O
==	O
'&'	O
)	O
||	O
(	O
e_code	pointer
[	O
-	O
2	int
]	O
==	O
'*'	O
)	O
||	O
(	O
e_code	pointer
[	O
-	O
2	int
]	O
==	O
'-'	O
)	O
||	O
(	O
e_code	pointer
[	O
-	O
2	int
]	O
==	O
'+'	O
)	O
||	O
(	O
e_code	pointer
[	O
-	O
2	int
]	O
==	O
'|'	O
)	O
)	O
)	O
)	O
)	O
{	O
bb	pointer
->	O
priority_code	enum
=	O
bb_after_equal_sign	int
;	O
}	O
else	O
if	O
(	O
(	O
(	O
(	O
e_code	pointer
-	O
s_code	pointer
)	O
>=	O
2	int
)	O
&&	O
(	O
e_code	pointer
[	O
-	O
2	int
]	O
==	O
' '	O
)	O
&&	O
(	O
(	O
e_code	pointer
[	O
-	O
1	int
]	O
==	O
'<'	O
)	O
||	O
(	O
e_code	pointer
[	O
-	O
1	int
]	O
==	O
'>'	O
)	O
)	O
)	O
||	O
(	O
(	O
(	O
e_code	pointer
-	O
s_code	pointer
)	O
>=	O
3	int
)	O
&&	O
(	O
e_code	pointer
[	O
-	O
3	int
]	O
==	O
' '	O
)	O
&&	O
(	O
e_code	pointer
[	O
-	O
1	int
]	O
==	O
'='	O
)	O
&&	O
(	O
(	O
e_code	pointer
[	O
-	O
2	int
]	O
==	O
'='	O
)	O
||	O
(	O
e_code	pointer
[	O
-	O
2	int
]	O
==	O
'!'	O
)	O
||	O
(	O
e_code	pointer
[	O
-	O
2	int
]	O
==	O
'<'	O
)	O
||	O
(	O
e_code	pointer
[	O
-	O
2	int
]	O
==	O
'>'	O
)	O
)	O
)	O
)	O
{	O
bb	pointer
->	O
priority_code	enum
=	O
bb_comparisation	int
;	O
}	O
else	O
if	O
(	O
(	O
e_code	pointer
[	O
-	O
1	int
]	O
==	O
'+'	O
)	O
||	O
(	O
e_code	pointer
[	O
-	O
1	int
]	O
==	O
'-'	O
)	O
)	O
{	O
bb	pointer
->	O
priority_code	enum
=	O
bb_operator6	int
;	O
}	O
else	O
if	O
(	O
(	O
e_code	pointer
[	O
-	O
1	int
]	O
==	O
'*'	O
)	O
||	O
(	O
e_code	pointer
[	O
-	O
1	int
]	O
==	O
'/'	O
)	O
||	O
(	O
e_code	pointer
[	O
-	O
1	int
]	O
==	O
'%'	O
)	O
)	O
{	O
bb	pointer
->	O
priority_code	enum
=	O
bb_operator5	int
;	O
}	O
else	O
{	O
bb	pointer
->	O
priority_code	enum
=	O
bb_binary_op	int
;	O
}	O
break	O
;	O
case	O
comma	int
:	O
bb	pointer
->	O
priority_code	enum
=	O
bb_comma	int
;	O
break	O
;	O
default	O
:	O
if	O
(	O
(	O
code	int
==	O
bb_binary_op	int
)	O
&&	O
(	O
(	O
*	O
token	pointer
==	O
'&'	O
)	O
||	O
(	O
*	O
token	pointer
==	O
'|'	O
)	O
)	O
&&	O
(	O
*	O
token	pointer
==	O
token	pointer
[	O
1	int
]	O
)	O
)	O
{	O
bb	pointer
->	O
priority_code	enum
=	O
bb_before_boolean_binary_op	int
;	O
}	O
else	O
if	O
(	O
e_code	pointer
[	O
-	O
1	int
]	O
==	O
';'	O
)	O
{	O
bb	pointer
->	O
priority_code	enum
=	O
bb_semicolon	int
;	O
}	O
else	O
{	O
bb	pointer
->	O
priority_code	enum
=	O
code	int
;	O
if	O
(	O
code	int
==	O
bb_struct_delim	int
)	O
{	O
if	O
(	O
e_code	pointer
[	O
-	O
1	int
]	O
==	O
'*'	O
)	O
{	O
bb	pointer
->	O
priority_code	enum
=	O
bb_operator4	int
;	O
}	O
else	O
{	O
bb	pointer
->	O
priority_code	enum
=	O
bb_operator2	int
;	O
}	O
}	O
}	O
}	O
set_priority	function
(	O
bb	pointer
)	O
;	O
if	O
(	O
buf_break_list	pointer
)	O
{	O
buf_break_list	pointer
->	O
next	pointer
=	O
bb	pointer
;	O
}	O
bb	pointer
->	O
prev	pointer
=	O
buf_break_list	pointer
;	O
bb	pointer
->	O
next	pointer
=	O
NULL	O
;	O
buf_break_list	pointer
=	O
bb	pointer
;	O
if	O
(	O
!	O
buf_break	pointer
||	O
(	O
bb	pointer
->	O
col	int
<=	O
settings	struct
.	O
max_col	int
)	O
)	O
{	O
if	O
(	O
better_break	function
(	O
bb	pointer
,	O
buf_break	pointer
)	O
)	O
{	O
buf_break	pointer
=	O
bb	pointer
;	O
for	O
(	O
bb	pointer
=	O
bb	pointer
->	O
prev	pointer
;	O
bb	pointer
;	O
)	O
{	O
buf_break_st_ty	struct
*	O
obb	pointer
=	O
bb	pointer
;	O
bb	pointer
=	O
bb	pointer
->	O
prev	pointer
;	O
xfree	function
(	O
obb	pointer
)	O
;	O
}	O
buf_break	pointer
->	O
prev	pointer
=	O
NULL	O
;	O
}	O
}	O
}	O
void	O
clear_buf_break_list	function
(	O
BOOLEAN	char
*	O
pbreak_line	pointer
)	O
{	O
buf_break_st_ty	struct
*	O
bb	pointer
;	O
for	O
(	O
bb	pointer
=	O
buf_break_list	pointer
;	O
bb	pointer
;	O
)	O
{	O
buf_break_st_ty	struct
*	O
obb	pointer
=	O
bb	pointer
;	O
bb	pointer
=	O
bb	pointer
->	O
prev	pointer
;	O
xfree	function
(	O
obb	pointer
)	O
;	O
}	O
buf_break	pointer
=	O
buf_break_list	pointer
=	O
NULL	O
;	O
*	O
pbreak_line	pointer
=	O
false	int
;	O
}	O
static	O
void	O
set_next_buf_break	function
(	O
int	O
prev_code_target	int
,	O
int	O
new_code_target	int
,	O
int	O
offset	int
,	O
BOOLEAN	char
*	O
pbreak_line	pointer
)	O
{	O
buf_break_st_ty	struct
*	O
bb	pointer
;	O
better_break	function
(	O
buf_break	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
buf_break_list	pointer
==	O
buf_break	pointer
)	O
{	O
clear_buf_break_list	function
(	O
pbreak_line	pointer
)	O
;	O
}	O
else	O
{	O
for	O
(	O
bb	pointer
=	O
buf_break_list	pointer
;	O
bb	pointer
;	O
bb	pointer
=	O
bb	pointer
->	O
prev	pointer
)	O
{	O
if	O
(	O
bb	pointer
->	O
target_col	int
>	O
buf_break	pointer
->	O
target_col	int
&&	O
settings	struct
.	O
lineup_to_parens	int
)	O
{	O
bb	pointer
->	O
target_col	int
-=	O
(	O
(	O
prev_code_target	int
+	O
offset	int
)	O
-	O
new_code_target	int
)	O
;	O
}	O
bb	pointer
->	O
col	int
-=	O
(	O
(	O
prev_code_target	int
+	O
offset	int
)	O
-	O
new_code_target	int
)	O
;	O
bb	pointer
->	O
offset	int
-=	O
offset	int
;	O
bb	pointer
->	O
priority_code_length	int
-=	O
offset	int
;	O
bb	pointer
->	O
first_level	int
=	O
buf_break	pointer
->	O
first_level	int
;	O
if	O
(	O
!	O
buf_break	pointer
->	O
priority_newline	int
)	O
{	O
bb	pointer
->	O
priority_newline	int
=	O
false	int
;	O
}	O
set_priority	function
(	O
bb	pointer
)	O
;	O
if	O
(	O
bb	pointer
->	O
prev	pointer
==	O
buf_break	pointer
)	O
{	O
break	O
;	O
}	O
}	O
xfree	function
(	O
buf_break	pointer
)	O
;	O
if	O
(	O
!	O
bb	pointer
)	O
goto	O
ret	O
;	O
buf_break	pointer
=	O
bb	pointer
;	O
buf_break	pointer
->	O
prev	pointer
=	O
NULL	O
;	O
for	O
(	O
bb	pointer
=	O
buf_break	pointer
;	O
bb	pointer
;	O
bb	pointer
=	O
bb	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
bb	pointer
->	O
col	int
>	O
settings	struct
.	O
max_col	int
)	O
{	O
continue	O
;	O
}	O
if	O
(	O
better_break	function
(	O
bb	pointer
,	O
buf_break	pointer
)	O
)	O
{	O
buf_break	pointer
=	O
bb	pointer
;	O
for	O
(	O
bb	pointer
=	O
bb	pointer
->	O
prev	pointer
;	O
bb	pointer
;	O
)	O
{	O
buf_break_st_ty	struct
*	O
obb	pointer
=	O
bb	pointer
;	O
bb	pointer
=	O
bb	pointer
->	O
prev	pointer
;	O
xfree	function
(	O
obb	pointer
)	O
;	O
}	O
bb	pointer
=	O
buf_break	pointer
;	O
buf_break	pointer
->	O
prev	pointer
=	O
NULL	O
;	O
}	O
}	O
}	O
ret	O
:	O
return	O
;	O
}	O
static	O
int	O
pad_output	function
(	O
int	O
cur_col	int
,	O
int	O
target_column	int
)	O
{	O
int	O
offset	int
=	O
0	int
;	O
int	O
align_target	int
=	O
target_column	int
;	O
int	O
tos	int
=	O
parser_state_tos	pointer
->	O
tos	int
;	O
if	O
(	O
cur_col	int
<	O
target_column	int
)	O
{	O
if	O
(	O
settings	struct
.	O
use_tabs	int
&&	O
(	O
settings	struct
.	O
tabsize	int
>	O
1	int
)	O
)	O
{	O
if	O
(	O
settings	struct
.	O
align_with_spaces	int
)	O
{	O
if	O
(	O
align_target	int
>=	O
parser_state_tos	pointer
->	O
ind_level	int
)	O
align_target	int
=	O
parser_state_tos	pointer
->	O
ind_level	int
;	O
if	O
(	O
parser_state_tos	pointer
->	O
last_rw	enum
==	O
rw_sp_paren	int
&&	O
parser_state_tos	pointer
->	O
p_stack	pointer
[	O
tos	int
]	O
==	O
stmt	int
&&	O
*	O
s_code	pointer
&&	O
tos	int
>	O
0	int
)	O
{	O
do	O
{	O
if	O
(	O
parser_state_tos	pointer
->	O
p_stack	pointer
[	O
tos	int
]	O
==	O
ifstmt	int
||	O
parser_state_tos	pointer
->	O
p_stack	pointer
[	O
tos	int
]	O
==	O
forstmt	int
||	O
parser_state_tos	pointer
->	O
p_stack	pointer
[	O
tos	int
]	O
==	O
whilestmt	int
)	O
break	O
;	O
}	O
while	O
(	O
--	O
tos	int
)	O
;	O
if	O
(	O
tos	int
)	O
align_target	int
=	O
parser_state_tos	pointer
->	O
il	pointer
[	O
tos	int
]	O
;	O
}	O
else	O
if	O
(	O
parser_state_tos	pointer
->	O
p_stack	pointer
[	O
tos	int
]	O
==	O
ifstmt	int
||	O
parser_state_tos	pointer
->	O
p_stack	pointer
[	O
tos	int
]	O
==	O
forstmt	int
||	O
parser_state_tos	pointer
->	O
p_stack	pointer
[	O
tos	int
]	O
==	O
whilestmt	int
)	O
align_target	int
=	O
parser_state_tos	pointer
->	O
il	pointer
[	O
tos	int
]	O
;	O
offset	int
=	O
(	O
align_target	int
-	O
cur_col	int
+	O
1	int
)	O
/	O
settings	struct
.	O
tabsize	int
;	O
align_target	int
=	O
cur_col	int
+	O
(	O
offset	int
*	O
settings	struct
.	O
tabsize	int
)	O
;	O
}	O
offset	int
=	O
settings	struct
.	O
tabsize	int
-	O
(	O
cur_col	int
-	O
1	int
)	O
%	O
settings	struct
.	O
tabsize	int
;	O
while	O
(	O
cur_col	int
+	O
offset	int
<=	O
align_target	int
)	O
{	O
putc	function
(	O
TAB	char
,	O
output	pointer
)	O
;	O
cur_col	int
+=	O
offset	int
;	O
offset	int
=	O
settings	struct
.	O
tabsize	int
;	O
}	O
}	O
while	O
(	O
cur_col	int
<	O
target_column	int
)	O
{	O
putc	function
(	O
' '	O
,	O
output	pointer
)	O
;	O
cur_col	int
++	O
;	O
}	O
}	O
return	O
cur_col	int
;	O
}	O
static	O
void	O
output_substring	function
(	O
FILE	struct
*	O
file	pointer
,	O
const	O
char	O
*	O
begin	pointer
,	O
const	O
char	O
*	O
end	pointer
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
begin	pointer
;	O
p	pointer
<	O
end	pointer
;	O
p	pointer
++	O
)	O
{	O
putc	function
(	O
*	O
p	pointer
,	O
file	pointer
)	O
;	O
}	O
}	O
static	O
int	O
dump_line_label	function
(	O
void	O
)	O
{	O
int	O
cur_col	int
;	O
while	O
(	O
(	O
e_lab	pointer
>	O
s_lab	pointer
)	O
&&	O
(	O
(	O
e_lab	pointer
[	O
-	O
1	int
]	O
==	O
' '	O
)	O
||	O
(	O
e_lab	pointer
[	O
-	O
1	int
]	O
==	O
TAB	char
)	O
)	O
)	O
{	O
e_lab	pointer
--	O
;	O
}	O
cur_col	int
=	O
pad_output	function
(	O
1	int
,	O
compute_label_target	function
(	O
)	O
)	O
;	O
if	O
(	O
(	O
settings	struct
.	O
force_preproc_width	int
>	O
0	int
)	O
&&	O
(	O
s_lab	pointer
[	O
0	int
]	O
==	O
'#'	O
)	O
)	O
{	O
int	O
preproc_postcrement	int
;	O
char	O
*	O
p	pointer
=	O
&	O
s_lab	pointer
[	O
1	int
]	O
;	O
while	O
(	O
*	O
p	pointer
==	O
' '	O
)	O
{	O
p	pointer
++	O
;	O
}	O
preproc_postcrement	int
=	O
settings	struct
.	O
force_preproc_width	int
;	O
if	O
(	O
strncmp	function
(	O
p	pointer
,	O
"else"	pointer
,	O
4	int
)	O
==	O
0	int
)	O
{	O
preproc_indent	int
-=	O
settings	struct
.	O
force_preproc_width	int
;	O
}	O
else	O
if	O
(	O
(	O
strncmp	function
(	O
p	pointer
,	O
"if"	pointer
,	O
2	int
)	O
==	O
0	int
)	O
||	O
(	O
strncmp	function
(	O
p	pointer
,	O
"ifdef"	pointer
,	O
5	int
)	O
==	O
0	int
)	O
)	O
{	O
}	O
else	O
if	O
(	O
strncmp	function
(	O
p	pointer
,	O
"elif"	pointer
,	O
4	int
)	O
==	O
0	int
)	O
{	O
preproc_indent	int
-=	O
settings	struct
.	O
force_preproc_width	int
;	O
}	O
else	O
if	O
(	O
strncmp	function
(	O
p	pointer
,	O
"endif"	pointer
,	O
5	int
)	O
==	O
0	int
)	O
{	O
preproc_indent	int
-=	O
settings	struct
.	O
force_preproc_width	int
;	O
preproc_postcrement	int
=	O
0	int
;	O
}	O
else	O
{	O
preproc_postcrement	int
=	O
0	int
;	O
}	O
if	O
(	O
preproc_indent	int
==	O
0	int
)	O
{	O
fprintf	function
(	O
output	pointer
,	O
"#"	pointer
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
output	pointer
,	O
"#%*s"	pointer
,	O
preproc_indent	int
,	O
" "	pointer
)	O
;	O
}	O
fprintf	function
(	O
output	pointer
,	O
"%.*s"	pointer
,	O
(	O
int	O
)	O
(	O
e_lab	pointer
-	O
p	pointer
)	O
,	O
p	pointer
)	O
;	O
cur_col	int
=	O
count_columns	function
(	O
cur_col	int
+	O
preproc_indent	int
+	O
1	int
,	O
p	pointer
,	O
NULL_CHAR	char
)	O
;	O
preproc_indent	int
+=	O
preproc_postcrement	int
;	O
}	O
else	O
if	O
(	O
(	O
s_lab	pointer
[	O
0	int
]	O
==	O
'#'	O
)	O
&&	O
(	O
(	O
strncmp	function
(	O
&	O
s_lab	pointer
[	O
1	int
]	O
,	O
"else"	pointer
,	O
4	int
)	O
==	O
0	int
)	O
||	O
(	O
strncmp	function
(	O
&	O
s_lab	pointer
[	O
1	int
]	O
,	O
"endif"	pointer
,	O
5	int
)	O
==	O
0	int
)	O
)	O
)	O
{	O
char	O
*	O
s	pointer
=	O
s_lab	pointer
;	O
if	O
(	O
e_lab	pointer
[	O
-	O
1	int
]	O
==	O
EOL	char
)	O
{	O
e_lab	pointer
--	O
;	O
}	O
do	O
{	O
putc	function
(	O
*	O
s	pointer
++	O
,	O
output	pointer
)	O
;	O
++	O
cur_col	int
;	O
}	O
while	O
(	O
(	O
s	pointer
<	O
e_lab	pointer
)	O
&&	O
(	O
'a'	O
<=	O
*	O
s	pointer
)	O
&&	O
(	O
*	O
s	pointer
<=	O
'z'	O
)	O
)	O
;	O
while	O
(	O
(	O
(	O
*	O
s	pointer
==	O
' '	O
)	O
||	O
(	O
*	O
s	pointer
==	O
TAB	char
)	O
)	O
&&	O
(	O
s	pointer
<	O
e_lab	pointer
)	O
)	O
{	O
s	pointer
++	O
;	O
}	O
if	O
(	O
s	pointer
<	O
e_lab	pointer
)	O
{	O
if	O
(	O
settings	struct
.	O
tabsize	int
>	O
1	int
)	O
{	O
cur_col	int
=	O
pad_output	function
(	O
cur_col	int
,	O
cur_col	int
+	O
settings	struct
.	O
tabsize	int
-	O
(	O
cur_col	int
-	O
1	int
)	O
%	O
settings	struct
.	O
tabsize	int
)	O
;	O
}	O
else	O
{	O
cur_col	int
=	O
pad_output	function
(	O
cur_col	int
,	O
cur_col	int
+	O
2	int
)	O
;	O
}	O
if	O
(	O
s	pointer
[	O
0	int
]	O
==	O
'/'	O
&&	O
(	O
s	pointer
[	O
1	int
]	O
==	O
'*'	O
||	O
s	pointer
[	O
1	int
]	O
==	O
'/'	O
)	O
)	O
{	O
fprintf	function
(	O
output	pointer
,	O
"%.*s"	pointer
,	O
(	O
int	O
)	O
(	O
e_lab	pointer
-	O
s	pointer
)	O
,	O
s	pointer
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
output	pointer
,	O
"/* %.*s */"	pointer
,	O
(	O
int	O
)	O
(	O
e_lab	pointer
-	O
s	pointer
)	O
,	O
s	pointer
)	O
;	O
}	O
}	O
}	O
else	O
{	O
fprintf	function
(	O
output	pointer
,	O
"%.*s"	pointer
,	O
(	O
int	O
)	O
(	O
e_lab	pointer
-	O
s_lab	pointer
)	O
,	O
s_lab	pointer
)	O
;	O
cur_col	int
=	O
count_columns	function
(	O
cur_col	int
,	O
s_lab	pointer
,	O
NULL_CHAR	char
)	O
;	O
}	O
return	O
cur_col	int
;	O
}	O
static	O
int	O
count_parens	function
(	O
const	O
char	O
*	O
string	pointer
)	O
{	O
int	O
paren_level	int
=	O
0	int
;	O
while	O
(	O
*	O
string	pointer
)	O
{	O
switch	O
(	O
*	O
string	pointer
)	O
{	O
case	O
'('	O
:	O
case	O
'['	O
:	O
paren_level	int
++	O
;	O
break	O
;	O
case	O
')'	O
:	O
case	O
']'	O
:	O
paren_level	int
--	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
string	pointer
++	O
;	O
}	O
return	O
paren_level	int
;	O
}	O
static	O
void	O
dump_line_code	function
(	O
int	O
*	O
pcur_col	pointer
,	O
int	O
*	O
pnot_truncated	pointer
,	O
int	O
paren_targ	int
,	O
BOOLEAN	char
*	O
pbreak_line	pointer
,	O
int	O
target_col_break	int
)	O
{	O
int	O
paren_level	int
=	O
0	int
;	O
if	O
(	O
s_code	pointer
!=	O
e_code	pointer
)	O
{	O
int	O
i	int
;	O
int	O
target_col	int
=	O
0	int
;	O
if	O
(	O
embedded_comment_on_line	int
==	O
1	int
)	O
{	O
target_col	int
=	O
parser_state_tos	pointer
->	O
com_col	int
;	O
}	O
else	O
if	O
(	O
target_col_break	int
!=	O
-	O
1	int
)	O
{	O
target_col	int
=	O
target_col_break	int
;	O
}	O
else	O
{	O
target_col	int
=	O
compute_code_target	function
(	O
paren_targ	int
)	O
;	O
}	O
if	O
(	O
parser_state_tos	pointer
->	O
last_token	enum
==	O
lparen	int
)	O
{	O
parser_state_tos	pointer
->	O
paren_indents	pointer
[	O
parser_state_tos	pointer
->	O
p_l_follow	int
-	O
1	int
]	O
+=	O
settings	struct
.	O
ind_size	int
-	O
1	int
;	O
}	O
*	O
pcur_col	pointer
=	O
pad_output	function
(	O
*	O
pcur_col	pointer
,	O
target_col	int
)	O
;	O
if	O
(	O
*	O
pbreak_line	pointer
&&	O
(	O
s_com	pointer
==	O
e_com	pointer
)	O
&&	O
(	O
buf_break	pointer
->	O
target_col	int
<=	O
buf_break	pointer
->	O
col	int
)	O
)	O
{	O
int	O
offset	int
;	O
int	O
len	int
;	O
char	O
c	char
;	O
char	O
*	O
ptr	pointer
=	O
&	O
s_code	pointer
[	O
buf_break	pointer
->	O
offset	int
]	O
;	O
if	O
(	O
*	O
ptr	pointer
!=	O
' '	O
)	O
{	O
--	O
ptr	pointer
;	O
}	O
offset	int
=	O
ptr	pointer
-	O
s_code	pointer
+	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
parser_state_tos	pointer
->	O
p_l_follow	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
parser_state_tos	pointer
->	O
paren_indents	pointer
[	O
i	int
]	O
>=	O
0	int
)	O
{	O
if	O
(	O
parser_state_tos	pointer
->	O
paren_indents	pointer
[	O
i	int
]	O
<	O
ptr	pointer
-	O
s_code	pointer
)	O
{	O
parser_state_tos	pointer
->	O
paren_indents	pointer
[	O
i	int
]	O
=	O
-	O
(	O
parser_state_tos	pointer
->	O
paren_indents	pointer
[	O
i	int
]	O
+	O
target_col	int
)	O
;	O
}	O
else	O
{	O
parser_state_tos	pointer
->	O
paren_indents	pointer
[	O
i	int
]	O
-=	O
offset	int
;	O
}	O
}	O
}	O
for	O
(	O
i	int
=	O
parser_state_tos	pointer
->	O
p_l_follow	int
;	O
i	int
<	O
parser_state_tos	pointer
->	O
paren_indents_size	int
;	O
++	O
i	int
)	O
{	O
if	O
(	O
parser_state_tos	pointer
->	O
paren_indents	pointer
[	O
i	int
]	O
>=	O
(	O
ptr	pointer
-	O
s_code	pointer
)	O
)	O
{	O
parser_state_tos	pointer
->	O
paren_indents	pointer
[	O
i	int
]	O
-=	O
offset	int
;	O
}	O
}	O
output_substring	function
(	O
output	pointer
,	O
s_code	pointer
,	O
s_code	pointer
+	O
buf_break	pointer
->	O
offset	int
)	O
;	O
c	char
=	O
s_code	pointer
[	O
buf_break	pointer
->	O
offset	int
]	O
;	O
s_code	pointer
[	O
buf_break	pointer
->	O
offset	int
]	O
=	O
'\0'	O
;	O
*	O
pcur_col	pointer
=	O
count_columns	function
(	O
*	O
pcur_col	pointer
,	O
s_code	pointer
,	O
NULL_CHAR	char
)	O
;	O
paren_level	int
+=	O
count_parens	function
(	O
s_code	pointer
)	O
;	O
s_code	pointer
[	O
buf_break	pointer
->	O
offset	int
]	O
=	O
c	char
;	O
*	O
pnot_truncated	pointer
=	O
0	int
;	O
len	int
=	O
(	O
e_code	pointer
-	O
ptr	pointer
-	O
1	int
)	O
;	O
memmove	function
(	O
s_code	pointer
,	O
ptr	pointer
+	O
1	int
,	O
len	int
)	O
;	O
e_code	pointer
=	O
s_code	pointer
+	O
len	int
;	O
*	O
e_code	pointer
=	O
'\0'	O
;	O
s_code_corresponds_to	pointer
=	O
buf_break	pointer
->	O
corresponds_to	pointer
;	O
prev_target_col_break	int
=	O
buf_break	pointer
->	O
target_col	int
;	O
if	O
(	O
!	O
buf_break	pointer
->	O
priority_newline	int
)	O
{	O
parser_state_tos	pointer
->	O
broken_at_non_nl	int
=	O
true	int
;	O
}	O
set_next_buf_break	function
(	O
target_col	int
,	O
buf_break	pointer
->	O
target_col	int
,	O
offset	int
,	O
pbreak_line	pointer
)	O
;	O
buf_break_used	int
=	O
1	int
;	O
*	O
pbreak_line	pointer
=	O
(	O
buf_break	pointer
!=	O
NULL	O
)	O
&&	O
(	O
output_line_length	function
(	O
)	O
>	O
settings	struct
.	O
max_col	int
)	O
;	O
}	O
else	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
parser_state_tos	pointer
->	O
p_l_follow	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
parser_state_tos	pointer
->	O
paren_indents	pointer
[	O
i	int
]	O
>=	O
0	int
)	O
{	O
parser_state_tos	pointer
->	O
paren_indents	pointer
[	O
i	int
]	O
=	O
-	O
(	O
parser_state_tos	pointer
->	O
paren_indents	pointer
[	O
i	int
]	O
+	O
target_col	int
)	O
;	O
}	O
}	O
output_substring	function
(	O
output	pointer
,	O
s_code	pointer
,	O
e_code	pointer
)	O
;	O
*	O
pcur_col	pointer
=	O
count_columns	function
(	O
*	O
pcur_col	pointer
,	O
s_code	pointer
,	O
NULL_CHAR	char
)	O
;	O
clear_buf_break_list	function
(	O
pbreak_line	pointer
)	O
;	O
}	O
}	O
}	O
extern	O
void	O
dump_line	function
(	O
int	O
force_nl	int
,	O
int	O
*	O
paren_targ	int
,	O
BOOLEAN	char
*	O
pbreak_line	pointer
)	O
{	O
int	O
cur_col	int
;	O
int	O
not_truncated	int
=	O
1	int
;	O
int	O
target_col_break	int
=	O
-	O
1	int
;	O
if	O
(	O
buf_break_used	int
)	O
{	O
buf_break_used	int
=	O
0	int
;	O
target_col_break	int
=	O
prev_target_col_break	int
;	O
}	O
else	O
if	O
(	O
force_nl	int
)	O
{	O
parser_state_tos	pointer
->	O
broken_at_non_nl	int
=	O
false	int
;	O
}	O
if	O
(	O
parser_state_tos	pointer
->	O
procname	pointer
[	O
0	int
]	O
&&	O
!	O
parser_state_tos	pointer
->	O
classname	pointer
[	O
0	int
]	O
&&	O
(	O
s_code_corresponds_to	pointer
==	O
parser_state_tos	pointer
->	O
procname	pointer
)	O
)	O
{	O
parser_state_tos	pointer
->	O
procname	pointer
=	O
"\0"	pointer
;	O
}	O
else	O
if	O
(	O
parser_state_tos	pointer
->	O
procname	pointer
[	O
0	int
]	O
&&	O
parser_state_tos	pointer
->	O
classname	pointer
[	O
0	int
]	O
&&	O
(	O
s_code_corresponds_to	pointer
==	O
parser_state_tos	pointer
->	O
classname	pointer
)	O
)	O
{	O
parser_state_tos	pointer
->	O
procname	pointer
=	O
"\0"	pointer
;	O
parser_state_tos	pointer
->	O
classname	pointer
=	O
"\0"	pointer
;	O
}	O
if	O
(	O
(	O
s_code	pointer
==	O
e_code	pointer
)	O
&&	O
(	O
s_lab	pointer
==	O
e_lab	pointer
)	O
&&	O
(	O
s_com	pointer
==	O
e_com	pointer
)	O
)	O
{	O
if	O
(	O
parser_state_tos	pointer
->	O
use_ff	int
)	O
{	O
putc	function
(	O
'\014'	O
,	O
output	pointer
)	O
;	O
parser_state_tos	pointer
->	O
use_ff	int
=	O
false	int
;	O
}	O
else	O
{	O
n_real_blanklines	int
++	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
prefix_blankline_requested	int
&&	O
(	O
n_real_blanklines	int
==	O
0	int
)	O
)	O
{	O
if	O
(	O
(	O
prefix_blankline_requested_code	enum
!=	O
decl	int
)	O
||	O
!	O
parser_state_tos	pointer
->	O
decl_on_line	int
)	O
{	O
n_real_blanklines	int
=	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
settings	struct
.	O
swallow_optional_blanklines	int
&&	O
(	O
n_real_blanklines	int
>	O
1	int
)	O
)	O
{	O
n_real_blanklines	int
=	O
1	int
;	O
}	O
while	O
(	O
--	O
n_real_blanklines	int
>=	O
0	int
)	O
{	O
putc	function
(	O
EOL	char
,	O
output	pointer
)	O
;	O
}	O
n_real_blanklines	int
=	O
0	int
;	O
if	O
(	O
(	O
e_lab	pointer
!=	O
s_lab	pointer
)	O
||	O
(	O
e_code	pointer
!=	O
s_code	pointer
)	O
)	O
{	O
++	O
code_lines	int
;	O
}	O
if	O
(	O
e_lab	pointer
!=	O
s_lab	pointer
)	O
{	O
cur_col	int
=	O
dump_line_label	function
(	O
)	O
;	O
}	O
else	O
{	O
cur_col	int
=	O
1	int
;	O
}	O
parser_state_tos	pointer
->	O
pcase	int
=	O
false	int
;	O
while	O
(	O
(	O
*	O
(	O
e_code	pointer
-	O
1	int
)	O
==	O
' '	O
)	O
&&	O
(	O
e_code	pointer
>	O
s_code	pointer
)	O
)	O
{	O
*	O
(	O
--	O
e_code	pointer
)	O
=	O
NULL_CHAR	char
;	O
}	O
dump_line_code	function
(	O
&	O
cur_col	int
,	O
&	O
not_truncated	int
,	O
*	O
paren_targ	int
,	O
pbreak_line	pointer
,	O
target_col_break	int
)	O
;	O
if	O
(	O
s_com	pointer
!=	O
e_com	pointer
)	O
{	O
{	O
int	O
target	int
=	O
parser_state_tos	pointer
->	O
com_col	int
;	O
char	O
*	O
com_st	pointer
=	O
s_com	pointer
;	O
if	O
(	O
cur_col	int
>	O
target	int
)	O
{	O
putc	function
(	O
EOL	char
,	O
output	pointer
)	O
;	O
cur_col	int
=	O
1	int
;	O
++	O
out_lines	int
;	O
}	O
cur_col	int
=	O
pad_output	function
(	O
cur_col	int
,	O
target	int
)	O
;	O
fwrite	function
(	O
com_st	pointer
,	O
e_com	pointer
-	O
com_st	pointer
,	O
1	int
,	O
output	pointer
)	O
;	O
cur_col	int
+=	O
e_com	pointer
-	O
com_st	pointer
;	O
com_lines	int
++	O
;	O
}	O
}	O
else	O
if	O
(	O
embedded_comment_on_line	int
)	O
{	O
com_lines	int
++	O
;	O
}	O
embedded_comment_on_line	int
=	O
0	int
;	O
if	O
(	O
parser_state_tos	pointer
->	O
use_ff	int
)	O
{	O
putc	function
(	O
'\014'	O
,	O
output	pointer
)	O
;	O
parser_state_tos	pointer
->	O
use_ff	int
=	O
false	int
;	O
}	O
else	O
{	O
putc	function
(	O
EOL	char
,	O
output	pointer
)	O
;	O
}	O
++	O
out_lines	int
;	O
if	O
(	O
(	O
parser_state_tos	pointer
->	O
just_saw_decl	int
==	O
1	int
)	O
&&	O
settings	struct
.	O
blanklines_after_declarations	int
)	O
{	O
prefix_blankline_requested	int
=	O
1	int
;	O
prefix_blankline_requested_code	enum
=	O
decl	int
;	O
parser_state_tos	pointer
->	O
just_saw_decl	int
=	O
0	int
;	O
}	O
else	O
{	O
prefix_blankline_requested	int
=	O
postfix_blankline_requested	int
;	O
prefix_blankline_requested_code	enum
=	O
postfix_blankline_requested_code	enum
;	O
}	O
postfix_blankline_requested	int
=	O
0	int
;	O
}	O
parser_state_tos	pointer
->	O
decl_on_line	int
=	O
parser_state_tos	pointer
->	O
in_decl	char
;	O
parser_state_tos	pointer
->	O
ind_stmt	int
=	O
parser_state_tos	pointer
->	O
in_stmt	int
;	O
e_lab	pointer
=	O
s_lab	pointer
;	O
*	O
s_lab	pointer
=	O
'\0'	O
;	O
if	O
(	O
not_truncated	int
)	O
{	O
e_code	pointer
=	O
s_code	pointer
;	O
*	O
s_code	pointer
=	O
'\0'	O
;	O
s_code_corresponds_to	pointer
=	O
NULL	O
;	O
}	O
e_com	pointer
=	O
s_com	pointer
;	O
*	O
s_com	pointer
=	O
'\0'	O
;	O
parser_state_tos	pointer
->	O
ind_level	int
=	O
parser_state_tos	pointer
->	O
i_l_follow	int
;	O
parser_state_tos	pointer
->	O
paren_level	int
=	O
parser_state_tos	pointer
->	O
p_l_follow	int
;	O
if	O
(	O
parser_state_tos	pointer
->	O
paren_level	int
>	O
0	int
)	O
{	O
if	O
(	O
!	O
not_truncated	int
&&	O
(	O
(	O
*	O
s_code	pointer
==	O
'('	O
)	O
||	O
(	O
*	O
s_code	pointer
==	O
'['	O
)	O
)	O
&&	O
(	O
parser_state_tos	pointer
->	O
paren_level	int
>=	O
2	int
)	O
)	O
{	O
*	O
paren_targ	int
=	O
-	O
parser_state_tos	pointer
->	O
paren_indents	pointer
[	O
parser_state_tos	pointer
->	O
paren_level	int
-	O
2	int
]	O
;	O
}	O
else	O
{	O
*	O
paren_targ	int
=	O
-	O
parser_state_tos	pointer
->	O
paren_indents	pointer
[	O
parser_state_tos	pointer
->	O
paren_level	int
-	O
1	int
]	O
;	O
}	O
}	O
else	O
{	O
*	O
paren_targ	int
=	O
0	int
;	O
}	O
if	O
(	O
inhibited	char
)	O
{	O
char	O
*	O
p	pointer
=	O
cur_line	pointer
;	O
while	O
(	O
--	O
n_real_blanklines	int
>=	O
0	int
)	O
{	O
putc	function
(	O
EOL	char
,	O
output	pointer
)	O
;	O
}	O
n_real_blanklines	int
=	O
0	int
;	O
do	O
{	O
while	O
(	O
(	O
*	O
p	pointer
!=	O
'\0'	O
)	O
&&	O
(	O
*	O
p	pointer
!=	O
EOL	char
)	O
)	O
{	O
putc	function
(	O
*	O
p	pointer
++	O
,	O
output	pointer
)	O
;	O
}	O
if	O
(	O
(	O
*	O
p	pointer
==	O
'\0'	O
)	O
&&	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
p	pointer
-	O
current_input	pointer
->	O
data	pointer
)	O
==	O
current_input	pointer
->	O
size	long
)	O
)	O
{	O
in_prog_pos	pointer
=	O
p	pointer
;	O
buf_end	pointer
=	O
p	pointer
;	O
buf_ptr	pointer
=	O
p	pointer
;	O
had_eof	char
=	O
true	int
;	O
return	O
;	O
}	O
if	O
(	O
*	O
p	pointer
==	O
EOL	char
)	O
{	O
cur_line	pointer
=	O
p	pointer
+	O
1	int
;	O
line_no	int
++	O
;	O
}	O
putc	function
(	O
*	O
p	pointer
++	O
,	O
output	pointer
)	O
;	O
while	O
(	O
(	O
*	O
p	pointer
==	O
' '	O
)	O
||	O
(	O
*	O
p	pointer
==	O
TAB	char
)	O
)	O
{	O
putc	function
(	O
*	O
p	pointer
,	O
output	pointer
)	O
;	O
p	pointer
++	O
;	O
}	O
if	O
(	O
(	O
*	O
p	pointer
==	O
'/'	O
)	O
&&	O
(	O
(	O
*	O
(	O
p	pointer
+	O
1	int
)	O
==	O
'*'	O
)	O
||	O
(	O
*	O
(	O
p	pointer
+	O
1	int
)	O
==	O
'/'	O
)	O
)	O
)	O
{	O
putc	function
(	O
*	O
p	pointer
++	O
,	O
output	pointer
)	O
;	O
putc	function
(	O
*	O
p	pointer
++	O
,	O
output	pointer
)	O
;	O
while	O
(	O
(	O
*	O
p	pointer
==	O
' '	O
)	O
||	O
(	O
*	O
p	pointer
==	O
TAB	char
)	O
)	O
{	O
putc	function
(	O
*	O
p	pointer
,	O
output	pointer
)	O
;	O
p	pointer
++	O
;	O
}	O
if	O
(	O
!	O
strncmp	function
(	O
p	pointer
,	O
"*INDENT-ON*"	pointer
,	O
11	int
)	O
)	O
{	O
do	O
{	O
while	O
(	O
(	O
*	O
p	pointer
!=	O
'\0'	O
)	O
&&	O
(	O
*	O
p	pointer
!=	O
EOL	char
)	O
)	O
{	O
putc	function
(	O
*	O
p	pointer
++	O
,	O
output	pointer
)	O
;	O
}	O
if	O
(	O
(	O
*	O
p	pointer
==	O
'\0'	O
)	O
&&	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
p	pointer
-	O
current_input	pointer
->	O
data	pointer
)	O
==	O
current_input	pointer
->	O
size	long
)	O
)	O
)	O
{	O
in_prog_pos	pointer
=	O
p	pointer
;	O
buf_end	pointer
=	O
p	pointer
;	O
buf_ptr	pointer
=	O
p	pointer
;	O
had_eof	char
=	O
true	int
;	O
return	O
;	O
}	O
else	O
{	O
if	O
(	O
*	O
p	pointer
==	O
EOL	char
)	O
{	O
inhibited	char
=	O
false	int
;	O
cur_line	pointer
=	O
p	pointer
+	O
1	int
;	O
line_no	int
++	O
;	O
}	O
putc	function
(	O
*	O
p	pointer
++	O
,	O
output	pointer
)	O
;	O
}	O
}	O
while	O
(	O
inhibited	char
)	O
;	O
}	O
}	O
}	O
while	O
(	O
inhibited	char
)	O
;	O
in_prog_pos	pointer
=	O
cur_line	pointer
;	O
buf_end	pointer
=	O
cur_line	pointer
;	O
buf_ptr	pointer
=	O
cur_line	pointer
;	O
fill_buffer	function
(	O
)	O
;	O
}	O
if	O
(	O
buf_break_used	int
&&	O
(	O
s_code	pointer
!=	O
e_code	pointer
)	O
&&	O
force_nl	int
)	O
{	O
prefix_blankline_requested	int
=	O
0	int
;	O
dump_line	function
(	O
true	int
,	O
paren_targ	int
,	O
pbreak_line	pointer
)	O
;	O
}	O
return	O
;	O
}	O
extern	O
void	O
flush_output	function
(	O
void	O
)	O
{	O
fflush	function
(	O
output	pointer
)	O
;	O
}	O
void	O
open_output	function
(	O
const	O
char	O
*	O
filename	pointer
,	O
const	O
char	O
*	O
mode	pointer
)	O
{	O
if	O
(	O
filename	pointer
==	O
NULL	O
)	O
{	O
output	pointer
=	O
stdout	pointer
;	O
}	O
else	O
{	O
output	pointer
=	O
fopen	function
(	O
filename	pointer
,	O
mode	pointer
)	O
;	O
if	O
(	O
output	pointer
==	O
NULL	O
)	O
{	O
fatal	function
(	O
_	O
(	O
"indent: can't create %s\n"	pointer
)	O
,	O
filename	pointer
)	O
;	O
}	O
}	O
}	O
extern	O
void	O
reopen_output_trunc	function
(	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
output	pointer
=	O
freopen	function
(	O
filename	pointer
,	O
"w"	pointer
,	O
output	pointer
)	O
;	O
}	O
extern	O
void	O
close_output	function
(	O
struct	O
stat	struct
*	O
file_stats	pointer
,	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
if	O
(	O
output	pointer
!=	O
stdout	pointer
)	O
{	O
if	O
(	O
fclose	function
(	O
output	pointer
)	O
!=	O
0	int
)	O
{	O
fatal	function
(	O
_	O
(	O
"Can't close output file %s"	pointer
)	O
,	O
filename	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
file_stats	pointer
!=	O
NULL	O
&&	O
filename	pointer
)	O
{	O
struct	O
utimbuf	struct
buf	struct
;	O
buf	struct
.	O
actime	long
=	O
time	function
(	O
NULL	O
)	O
;	O
buf	struct
.	O
modtime	long
=	O
file_stats	pointer
->	O
st_mtime	O
;	O
if	O
(	O
utime	function
(	O
filename	pointer
,	O
&	O
buf	struct
)	O
!=	O
0	int
)	O
{	O
WARNING	O
(	O
_	O
(	O
"Can't preserve modification time on output file %s"	pointer
)	O
,	O
filename	pointer
,	O
0	int
)	O
;	O
}	O
}	O
}	O
}	O
}	O
extern	O
void	O
inhibit_indenting	function
(	O
BOOLEAN	char
flag	char
)	O
{	O
inhibited	char
=	O
flag	char
;	O
}	O
int	O
compute_code_target	function
(	O
int	O
paren_targ	int
)	O
{	O
int	O
target_col	int
;	O
if	O
(	O
buf_break_used	int
)	O
{	O
return	O
prev_target_col_break	int
;	O
}	O
if	O
(	O
parser_state_tos	pointer
->	O
procname	pointer
[	O
0	int
]	O
&&	O
(	O
s_code_corresponds_to	pointer
==	O
parser_state_tos	pointer
->	O
procname	pointer
)	O
)	O
{	O
target_col	int
=	O
1	int
;	O
if	O
(	O
!	O
parser_state_tos	pointer
->	O
paren_level	int
)	O
{	O
return	O
target_col	int
;	O
}	O
}	O
else	O
{	O
target_col	int
=	O
parser_state_tos	pointer
->	O
ind_level	int
+	O
1	int
;	O
}	O
if	O
(	O
!	O
parser_state_tos	pointer
->	O
paren_level	int
)	O
{	O
if	O
(	O
parser_state_tos	pointer
->	O
ind_stmt	int
)	O
{	O
target_col	int
+=	O
settings	struct
.	O
continuation_indent	int
;	O
}	O
return	O
target_col	int
;	O
}	O
if	O
(	O
!	O
settings	struct
.	O
lineup_to_parens	int
)	O
{	O
return	O
target_col	int
+	O
settings	struct
.	O
continuation_indent	int
+	O
(	O
settings	struct
.	O
paren_indent	int
*	O
(	O
parser_state_tos	pointer
->	O
paren_level	int
-	O
1	int
)	O
)	O
;	O
}	O
return	O
paren_targ	int
;	O
}	O
int	O
count_columns	function
(	O
int	O
column	int
,	O
char	O
*	O
bp	pointer
,	O
int	O
stop_char	int
)	O
{	O
while	O
(	O
*	O
bp	pointer
!=	O
stop_char	int
&&	O
*	O
bp	pointer
!=	O
NULL_CHAR	char
)	O
{	O
switch	O
(	O
*	O
bp	pointer
++	O
)	O
{	O
case	O
EOL	char
:	O
case	O
'\f'	O
:	O
column	int
=	O
1	int
;	O
break	O
;	O
case	O
TAB	char
:	O
column	int
+=	O
settings	struct
.	O
tabsize	int
-	O
(	O
column	int
-	O
1	int
)	O
%	O
settings	struct
.	O
tabsize	int
;	O
break	O
;	O
case	O
010	int
:	O
--	O
column	int
;	O
break	O
;	O
default	O
:	O
++	O
column	int
;	O
break	O
;	O
}	O
}	O
return	O
column	int
;	O
}	O
int	O
compute_label_target	function
(	O
void	O
)	O
{	O
if	O
(	O
*	O
s_lab	pointer
==	O
'#'	O
)	O
{	O
return	O
1	int
;	O
}	O
if	O
(	O
parser_state_tos	pointer
->	O
pcase	int
)	O
{	O
return	O
parser_state_tos	pointer
->	O
cstk	pointer
[	O
parser_state_tos	pointer
->	O
tos	int
]	O
+	O
1	int
;	O
}	O
if	O
(	O
settings	struct
.	O
c_plus_plus	int
&&	O
parser_state_tos	pointer
->	O
in_decl	char
)	O
{	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
settings	struct
.	O
label_offset	int
<	O
0	int
)	O
{	O
return	O
parser_state_tos	pointer
->	O
ind_level	int
+	O
settings	struct
.	O
label_offset	int
+	O
1	int
;	O
}	O
else	O
{	O
return	O
settings	struct
.	O
label_offset	int
+	O
1	int
;	O
}	O
}	O
int	O
output_line_length	function
(	O
void	O
)	O
{	O
int	O
code_length	int
=	O
0	int
;	O
int	O
com_length	int
=	O
0	int
;	O
int	O
length	int
;	O
if	O
(	O
s_lab	pointer
==	O
e_lab	pointer
)	O
{	O
length	int
=	O
0	int
;	O
}	O
else	O
{	O
length	int
=	O
count_columns	function
(	O
compute_label_target	function
(	O
)	O
,	O
s_lab	pointer
,	O
EOL	char
)	O
-	O
1	int
;	O
}	O
if	O
(	O
s_code	pointer
!=	O
e_code	pointer
)	O
{	O
int	O
code_col	int
=	O
compute_code_target	function
(	O
paren_target	int
)	O
;	O
code_length	int
=	O
count_columns	function
(	O
code_col	int
,	O
s_code	pointer
,	O
EOL	char
)	O
-	O
code_col	int
;	O
}	O
if	O
(	O
s_com	pointer
!=	O
e_com	pointer
)	O
{	O
int	O
com_col	int
=	O
parser_state_tos	pointer
->	O
com_col	int
;	O
com_length	int
=	O
count_columns	function
(	O
com_col	int
,	O
s_com	pointer
,	O
EOL	char
)	O
-	O
com_col	int
;	O
}	O
if	O
(	O
code_length	int
!=	O
0	int
)	O
{	O
length	int
+=	O
compute_code_target	function
(	O
paren_target	int
)	O
-	O
1	int
+	O
code_length	int
;	O
if	O
(	O
embedded_comment_on_line	int
)	O
{	O
length	int
+=	O
com_length	int
;	O
}	O
}	O
return	O
length	int
;	O
}	O
