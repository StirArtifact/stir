static	O
char	O
*	O
vszModelFilename	pointer
=	O
NULL	O
;	O
static	O
char	O
*	O
vszModGenName	pointer
=	O
NULL	O
;	O
static	O
char	O
vszModelArrayName	array
[	O
]	O
=	O
"vrgModelVars"	pointer
;	O
static	O
char	O
vszInputArrayName	array
[	O
]	O
=	O
"vrgInputs"	pointer
;	O
extern	O
char	O
vszHasInitializer	array
[	O
]	O
;	O
PVMMAPSTRCT	pointer
vpvmGloVarList	pointer
;	O
char	O
*	O
vszIFNTypes	array
[	O
]	O
=	O
{	O
"IFN_NULL /* ?? */"	pointer
,	O
"IFN_CONSTANT"	pointer
,	O
"IFN_PERDOSE"	pointer
,	O
"IFN_PERRATE"	pointer
,	O
"IFN_PEREXP"	pointer
,	O
"IFN_NDOSES"	pointer
}	O
;	O
int	O
vnStates	int
,	O
vnOutputs	int
,	O
vnInputs	int
,	O
vnParms	int
,	O
vnModelVars	int
;	O
BOOL	int
bForR	int
=	O
FALSE	int
;	O
BOOL	int
bForInits	int
=	O
FALSE	int
;	O
BOOL	int
bDelay	int
=	O
TRUE	int
;	O
int	O
ForAllVar	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvm	pointer
,	O
PFI_CALLBACK	pointer
pfiFunc	pointer
,	O
HANDLE	long
hType	long
,	O
PVOID	pointer
pinfo	pointer
)	O
{	O
int	O
iTotal	int
=	O
0	int
;	O
while	O
(	O
pvm	pointer
)	O
{	O
if	O
(	O
hType	long
==	O
ALL_VARS	O
||	O
TYPE	O
(	O
pvm	pointer
)	O
==	O
hType	long
)	O
{	O
if	O
(	O
pfiFunc	pointer
)	O
iTotal	int
+=	O
(	O
*	O
pfiFunc	pointer
)	O
(	O
pfile	pointer
,	O
pvm	pointer
,	O
pinfo	pointer
)	O
;	O
else	O
iTotal	int
++	O
;	O
}	O
pvm	pointer
=	O
pvm	pointer
->	O
pvmNextVar	pointer
;	O
}	O
return	O
(	O
iTotal	int
)	O
;	O
}	O
int	O
CountOneDecl	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvm	pointer
,	O
PVOID	pointer
pInfo	pointer
)	O
{	O
if	O
(	O
pvm	pointer
->	O
szEqn	pointer
!=	O
vszHasInitializer	array
)	O
{	O
return	O
(	O
1	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
void	O
WritebDelays	function
(	O
PFILE	pointer
pfile	pointer
,	O
BOOL	int
bDelays	int
)	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
"\nBOOL bDelays = %d;\n"	pointer
,	O
bDelays	int
)	O
;	O
}	O
int	O
WriteOneName	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvm	pointer
,	O
PVOID	pointer
pInfo	pointer
)	O
{	O
if	O
(	O
pvm	pointer
->	O
szEqn	pointer
!=	O
vszHasInitializer	array
)	O
{	O
if	O
(	O
bForR	int
)	O
{	O
if	O
(	O
TYPE	O
(	O
pvm	pointer
)	O
==	O
ID_OUTPUT	int
)	O
fprintf	function
(	O
pfile	pointer
,	O
"    \"%s"	pointer
,	O
pvm	pointer
->	O
szName	pointer
)	O
;	O
else	O
fprintf	function
(	O
pfile	pointer
,	O
"     %s"	pointer
,	O
pvm	pointer
->	O
szName	pointer
)	O
;	O
if	O
(	O
TYPE	O
(	O
pvm	pointer
)	O
!=	O
ID_INPUT	int
)	O
{	O
if	O
(	O
TYPE	O
(	O
pvm	pointer
)	O
==	O
ID_OUTPUT	int
)	O
fprintf	function
(	O
pfile	pointer
,	O
"\",\n"	pointer
)	O
;	O
else	O
fprintf	function
(	O
pfile	pointer
,	O
" = %s,\n"	pointer
,	O
(	O
pvm	pointer
->	O
szEqn	pointer
?	O
pvm	pointer
->	O
szEqn	pointer
:	O
"0.0"	pointer
)	O
)	O
;	O
}	O
else	O
fprintf	function
(	O
pfile	pointer
,	O
" (forcing function)\n"	pointer
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
"     %s"	pointer
,	O
pvm	pointer
->	O
szName	pointer
)	O
;	O
if	O
(	O
TYPE	O
(	O
pvm	pointer
)	O
!=	O
ID_INPUT	int
)	O
fprintf	function
(	O
pfile	pointer
,	O
" %s %s;\n"	pointer
,	O
(	O
pvm	pointer
->	O
szEqn	pointer
?	O
"="	pointer
:	O
"->"	pointer
)	O
,	O
(	O
pvm	pointer
->	O
szEqn	pointer
?	O
pvm	pointer
->	O
szEqn	pointer
:	O
"0.0"	pointer
)	O
)	O
;	O
else	O
fprintf	function
(	O
pfile	pointer
,	O
" (is a function)\n"	pointer
)	O
;	O
}	O
return	O
(	O
1	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
void	O
WriteHeader	function
(	O
PFILE	pointer
pfile	pointer
,	O
PSTR	pointer
szName	pointer
,	O
PVMMAPSTRCT	pointer
pvmGlo	pointer
)	O
{	O
time_t	long
ttTime	long
;	O
time	function
(	O
&	O
ttTime	long
)	O
;	O
if	O
(	O
fprintf	function
(	O
pfile	pointer
,	O
"/* %s\n"	pointer
,	O
szName	pointer
)	O
<	O
0	int
)	O
ReportError	function
(	O
NULL	O
,	O
RE_CANNOTOPEN	int
|	O
RE_FATAL	int
,	O
szName	pointer
,	O
"...in WriteHeader ()"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"   ___________________________________________________\n\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"   Model File:  %s\n\n"	pointer
,	O
vszModelFilename	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"   Date:  %s\n"	pointer
,	O
ctime	function
(	O
&	O
ttTime	long
)	O
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"   Created by:  \"%s %s\"\n"	pointer
,	O
vszModGenName	pointer
,	O
VSZ_VERSION	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"    -- a model preprocessor by Don Maszle\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"   ___________________________________________________\n\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"   "	pointer
VSZ_COPYRIGHT	pointer
"\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"\n   Model calculations for compartmental model:\n\n"	pointer
)	O
;	O
if	O
(	O
vnStates	int
==	O
1	int
)	O
fprintf	function
(	O
pfile	pointer
,	O
"   1 State:\n"	pointer
)	O
;	O
else	O
fprintf	function
(	O
pfile	pointer
,	O
"   %d States:\n"	pointer
,	O
vnStates	int
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmGlo	pointer
,	O
&	O
WriteOneName	function
,	O
ID_STATE	int
,	O
NULL	O
)	O
;	O
if	O
(	O
vnOutputs	int
==	O
1	int
)	O
fprintf	function
(	O
pfile	pointer
,	O
"\n   1 Output:\n"	pointer
)	O
;	O
else	O
fprintf	function
(	O
pfile	pointer
,	O
"\n   %d Outputs:\n"	pointer
,	O
vnOutputs	int
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmGlo	pointer
,	O
&	O
WriteOneName	function
,	O
ID_OUTPUT	int
,	O
NULL	O
)	O
;	O
if	O
(	O
vnInputs	int
==	O
1	int
)	O
fprintf	function
(	O
pfile	pointer
,	O
"\n   1 Input:\n"	pointer
)	O
;	O
else	O
fprintf	function
(	O
pfile	pointer
,	O
"\n   %d Inputs:\n"	pointer
,	O
vnInputs	int
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmGlo	pointer
,	O
&	O
WriteOneName	function
,	O
ID_INPUT	int
,	O
NULL	O
)	O
;	O
if	O
(	O
vnParms	int
==	O
1	int
)	O
fprintf	function
(	O
pfile	pointer
,	O
"\n   1 Parameter:\n"	pointer
)	O
;	O
else	O
fprintf	function
(	O
pfile	pointer
,	O
"\n   %d Parameters:\n"	pointer
,	O
vnParms	int
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmGlo	pointer
,	O
&	O
WriteOneName	function
,	O
ID_PARM	int
,	O
NULL	O
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"*/\n\n"	pointer
)	O
;	O
}	O
void	O
WriteIncludes	function
(	O
PFILE	pointer
pfile	pointer
)	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
"\n#include <stdlib.h>\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"#include <stdio.h>\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"#include <math.h>\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"#include <string.h>\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"#include <float.h>\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"#include \"modelu.h\"\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"#include \"random.h\"\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"#include \"yourcode.h\"\n"	pointer
)	O
;	O
}	O
int	O
WriteOneDecl	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvm	pointer
,	O
PVOID	pointer
pInfo	pointer
)	O
{	O
assert	O
(	O
TYPE	O
(	O
pvm	pointer
)	O
!=	O
ID_INPUT	int
)	O
;	O
assert	O
(	O
TYPE	O
(	O
pvm	pointer
)	O
!=	O
ID_OUTPUT	int
)	O
;	O
assert	O
(	O
TYPE	O
(	O
pvm	pointer
)	O
!=	O
ID_STATE	int
)	O
;	O
if	O
(	O
TYPE	O
(	O
pvm	pointer
)	O
>	O
ID_PARM	int
)	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
"  /* local */ "	pointer
)	O
;	O
}	O
fprintf	function
(	O
pfile	pointer
,	O
"double %s;\n"	pointer
,	O
pvm	pointer
->	O
szName	pointer
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
int	O
WriteOneIndexDefine	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvm	pointer
,	O
PVOID	pointer
pInfo	pointer
)	O
{	O
if	O
(	O
pvm	pointer
->	O
szEqn	pointer
!=	O
vszHasInitializer	array
)	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
"#define "	pointer
)	O
;	O
WriteIndexName	O
(	O
pfile	pointer
,	O
pvm	pointer
)	O
;	O
if	O
(	O
INDEX	O
(	O
pvm	pointer
)	O
)	O
fprintf	function
(	O
pfile	pointer
,	O
" 0x%05lx\n"	pointer
,	O
INDEX	O
(	O
pvm	pointer
)	O
)	O
;	O
else	O
fprintf	function
(	O
pfile	pointer
,	O
" 0x00000\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
WriteDecls	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvmGlo	pointer
)	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
"\n\n/*----- Indices to Global Variables */\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"\n/* Model variables: States and other outputs */\n"	pointer
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmGlo	pointer
,	O
&	O
WriteOneIndexDefine	function
,	O
ID_STATE	int
,	O
NULL	O
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmGlo	pointer
,	O
&	O
WriteOneIndexDefine	function
,	O
ID_OUTPUT	int
,	O
NULL	O
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"\n/* Inputs */\n"	pointer
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmGlo	pointer
,	O
&	O
WriteOneIndexDefine	function
,	O
ID_INPUT	int
,	O
NULL	O
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"\n/* Parameters */\n"	pointer
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmGlo	pointer
,	O
&	O
WriteOneIndexDefine	function
,	O
ID_PARM	int
,	O
NULL	O
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"\n\n/*----- Global Variables */\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"\n/* For export. Keep track of who we are. */\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"char szModelDescFilename[] = \"%s\";\n"	pointer
,	O
vszModelFilename	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"char szModelSourceFilename[] = __FILE__;\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"char szModelGenAndVersion[] = \"%s %s\";\n"	pointer
,	O
vszModGenName	pointer
,	O
VSZ_VERSION	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"\n/* Externs */\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"extern BOOL vbModelReinitd;\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"\n/* Model Dimensions */\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"int vnStates = %d;\n"	pointer
,	O
vnStates	int
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"int vnOutputs = %d;\n"	pointer
,	O
vnOutputs	int
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"int vnModelVars = %d;\n"	pointer
,	O
vnModelVars	int
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"int vnInputs = %d;\n"	pointer
,	O
vnInputs	int
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"int vnParms = %d;\n"	pointer
,	O
vnParms	int
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"\n/* States and Outputs*/\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"double %s[%d];\n"	pointer
,	O
vszModelArrayName	array
,	O
vnModelVars	int
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"\n/* Inputs */\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"IFN %s[%d];\n"	pointer
,	O
vszInputArrayName	array
,	O
(	O
vnInputs	int
>	O
0	int
?	O
vnInputs	int
:	O
1	int
)	O
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"\n/* Parameters */\n"	pointer
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmGlo	pointer
,	O
&	O
WriteOneDecl	function
,	O
ID_PARM	int
,	O
NULL	O
)	O
;	O
}	O
PSTR	pointer
GetName	function
(	O
PVMMAPSTRCT	pointer
pvm	pointer
,	O
PSTR	pointer
szModelVarName	pointer
,	O
PSTR	pointer
szDerivName	pointer
,	O
HANDLE	long
hType	long
)	O
{	O
static	O
PSTRLEX	array
vszVarName	array
;	O
HANDLE	long
hTypeToUse	long
=	O
(	O
hType	long
?	O
hType	long
:	O
TYPE	O
(	O
pvm	pointer
)	O
)	O
;	O
switch	O
(	O
hTypeToUse	long
)	O
{	O
case	O
ID_INPUT	int
:	O
if	O
(	O
bForR	int
)	O
sprintf	function
(	O
vszVarName	array
,	O
"%s"	pointer
,	O
pvm	pointer
->	O
szName	pointer
)	O
;	O
else	O
sprintf	function
(	O
vszVarName	array
,	O
"vrgInputs[ID_%s]"	pointer
,	O
pvm	pointer
->	O
szName	pointer
)	O
;	O
break	O
;	O
case	O
ID_STATE	int
:	O
if	O
(	O
bForR	int
)	O
{	O
if	O
(	O
bForInits	int
)	O
sprintf	function
(	O
vszVarName	array
,	O
"%s"	pointer
,	O
pvm	pointer
->	O
szName	pointer
)	O
;	O
else	O
sprintf	function
(	O
vszVarName	array
,	O
"y[ID_%s]"	pointer
,	O
pvm	pointer
->	O
szName	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
szModelVarName	pointer
)	O
sprintf	function
(	O
vszVarName	array
,	O
"%s[ID_%s]"	pointer
,	O
szModelVarName	pointer
,	O
pvm	pointer
->	O
szName	pointer
)	O
;	O
else	O
sprintf	function
(	O
vszVarName	array
,	O
"vrgModelVars[ID_%s]"	pointer
,	O
pvm	pointer
->	O
szName	pointer
)	O
;	O
}	O
break	O
;	O
case	O
ID_OUTPUT	int
:	O
if	O
(	O
bForR	int
)	O
sprintf	function
(	O
vszVarName	array
,	O
"yout[ID_%s]"	pointer
,	O
pvm	pointer
->	O
szName	pointer
)	O
;	O
else	O
{	O
if	O
(	O
szModelVarName	pointer
)	O
sprintf	function
(	O
vszVarName	array
,	O
"%s[ID_%s]"	pointer
,	O
szModelVarName	pointer
,	O
pvm	pointer
->	O
szName	pointer
)	O
;	O
else	O
sprintf	function
(	O
vszVarName	array
,	O
"vrgModelVars[ID_%s]"	pointer
,	O
pvm	pointer
->	O
szName	pointer
)	O
;	O
}	O
break	O
;	O
case	O
ID_DERIV	int
:	O
assert	O
(	O
szDerivName	pointer
)	O
;	O
if	O
(	O
bForR	int
)	O
sprintf	function
(	O
vszVarName	array
,	O
"ydot[ID_%s]"	pointer
,	O
pvm	pointer
->	O
szName	pointer
)	O
;	O
else	O
sprintf	function
(	O
vszVarName	array
,	O
"%s[ID_%s]"	pointer
,	O
szDerivName	pointer
,	O
pvm	pointer
->	O
szName	pointer
)	O
;	O
break	O
;	O
default	O
:	O
sprintf	function
(	O
vszVarName	array
,	O
"%s"	pointer
,	O
pvm	pointer
->	O
szName	pointer
)	O
;	O
break	O
;	O
}	O
return	O
(	O
vszVarName	array
)	O
;	O
}	O
int	O
WriteOneVMEntry	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvm	pointer
,	O
PVOID	pointer
pInfo	pointer
)	O
{	O
int	O
iType	int
=	O
TYPE	O
(	O
pvm	pointer
)	O
;	O
if	O
(	O
!	O
pvm	pointer
)	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
"  {\"\", NULL, 0} /* End flag */\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
assert	O
(	O
iType	int
&&	O
iType	int
!=	O
ID_LOCALDYN	int
&&	O
iType	int
!=	O
ID_LOCALSCALE	int
&&	O
iType	int
!=	O
ID_LOCALJACOB	int
)	O
;	O
if	O
(	O
pvm	pointer
->	O
szEqn	pointer
!=	O
vszHasInitializer	array
)	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
"  {\"%s\", (PVOID) &%s"	pointer
,	O
pvm	pointer
->	O
szName	pointer
,	O
GetName	function
(	O
pvm	pointer
,	O
vszModelArrayName	array
,	O
NULL	O
,	O
ID_NULL	int
)	O
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
", ID_%s | ID_%s},\n"	pointer
,	O
(	O
iType	int
==	O
ID_PARM	int
?	O
"PARM"	pointer
:	O
(	O
iType	int
==	O
ID_INPUT	int
?	O
"INPUT"	pointer
:	O
(	O
iType	int
==	O
ID_OUTPUT	int
?	O
"OUTPUT"	pointer
:	O
"STATE"	pointer
)	O
)	O
)	O
,	O
pvm	pointer
->	O
szName	pointer
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
void	O
WriteVarMap	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvmGlo	pointer
)	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
"\n\n/*----- Global Variable Map */\n\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"VMMAPSTRCT vrgvmGlo[] = {\n"	pointer
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmGlo	pointer
,	O
&	O
WriteOneVMEntry	function
,	O
ID_STATE	int
,	O
NULL	O
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmGlo	pointer
,	O
&	O
WriteOneVMEntry	function
,	O
ID_OUTPUT	int
,	O
NULL	O
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmGlo	pointer
,	O
&	O
WriteOneVMEntry	function
,	O
ID_INPUT	int
,	O
NULL	O
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmGlo	pointer
,	O
&	O
WriteOneVMEntry	function
,	O
ID_PARM	int
,	O
NULL	O
)	O
;	O
WriteOneVMEntry	function
(	O
pfile	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"};  /* vrgpvmGlo[] */\n"	pointer
)	O
;	O
}	O
int	O
WriteOneInit	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvm	pointer
,	O
PVOID	pointer
pInfo	pointer
)	O
{	O
IFN	struct
ifnNull	struct
=	O
{	O
IFN_CONSTANT	int
}	O
;	O
PSTR	pointer
szVarName	pointer
=	O
GetName	function
(	O
pvm	pointer
,	O
NULL	O
,	O
NULL	O
,	O
ID_NULL	int
)	O
;	O
if	O
(	O
(	O
pvm	pointer
->	O
szEqn	pointer
!=	O
vszHasInitializer	array
&&	O
TYPE	O
(	O
pvm	pointer
)	O
<=	O
ID_PARM	int
)	O
||	O
(	O
TYPE	O
(	O
pvm	pointer
)	O
==	O
ID_INLINE	int
)	O
)	O
{	O
if	O
(	O
TYPE	O
(	O
pvm	pointer
)	O
==	O
ID_INPUT	int
)	O
{	O
PIFN	pointer
pifn	pointer
=	O
(	O
PIFN	pointer
)	O
pvm	pointer
->	O
szEqn	pointer
;	O
if	O
(	O
!	O
pifn	pointer
)	O
pifn	pointer
=	O
&	O
ifnNull	struct
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  %s.iType = %s;\n"	pointer
,	O
szVarName	pointer
,	O
vszIFNTypes	array
[	O
pifn	pointer
->	O
iType	int
]	O
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  %s.dTStartPeriod = 0;\n"	pointer
,	O
szVarName	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  %s.bOn = FALSE;\n"	pointer
,	O
szVarName	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  %s.dMag = %f;\n"	pointer
,	O
szVarName	pointer
,	O
pifn	pointer
->	O
dMag	double
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  %s.dT0 = %f;\n"	pointer
,	O
szVarName	pointer
,	O
pifn	pointer
->	O
dT0	double
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  %s.dTexp = %f;\n"	pointer
,	O
szVarName	pointer
,	O
pifn	pointer
->	O
dTexp	double
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  %s.dDecay = %f;\n"	pointer
,	O
szVarName	pointer
,	O
pifn	pointer
->	O
dDecay	double
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  %s.dTper = %f;\n"	pointer
,	O
szVarName	pointer
,	O
pifn	pointer
->	O
dTper	double
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  %s.hMag = %#lx;\n"	pointer
,	O
szVarName	pointer
,	O
pifn	pointer
->	O
hMag	long
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  %s.hT0 = %#lx;\n"	pointer
,	O
szVarName	pointer
,	O
pifn	pointer
->	O
hT0	long
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  %s.hTexp = %#lx;\n"	pointer
,	O
szVarName	pointer
,	O
pifn	pointer
->	O
hTexp	long
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  %s.hDecay = %#lx;\n"	pointer
,	O
szVarName	pointer
,	O
pifn	pointer
->	O
hDecay	long
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  %s.hTper = %#lx;\n"	pointer
,	O
szVarName	pointer
,	O
pifn	pointer
->	O
hTper	long
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  %s.dVal = 0.0;\n"	pointer
,	O
szVarName	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  %s.nDoses = 0;\n"	pointer
,	O
szVarName	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
TYPE	O
(	O
pvm	pointer
)	O
==	O
ID_INLINE	int
)	O
fprintf	function
(	O
pfile	pointer
,	O
"\n%s\n"	pointer
,	O
pvm	pointer
->	O
szEqn	pointer
)	O
;	O
else	O
fprintf	function
(	O
pfile	pointer
,	O
"  %s = %s;\n"	pointer
,	O
szVarName	pointer
,	O
(	O
pvm	pointer
->	O
szEqn	pointer
?	O
pvm	pointer
->	O
szEqn	pointer
:	O
"0.0"	pointer
)	O
)	O
;	O
}	O
return	O
(	O
1	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
void	O
WriteInitModel	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvmGlo	pointer
)	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
"\n\n/*----- InitModel\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"   Should be called to initialize model variables at\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"   the beginning of experiment before reading\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"   variants from the simulation spec file.\n*/\n\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"void InitModel(void)\n{\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  /* Initialize things in the order that they appear in\n"	pointer
"     model definition file so that dependencies are\n"	pointer
"     handled correctly. */\n\n"	pointer
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmGlo	pointer
,	O
&	O
WriteOneInit	function
,	O
ALL_VARS	O
,	O
NULL	O
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"\n  vbModelReinitd = TRUE;\n\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"} /* InitModel */\n\n\n"	pointer
)	O
;	O
}	O
void	O
TranslateID	function
(	O
PINPUTBUF	pointer
pibDum	pointer
,	O
PFILE	pointer
pfile	pointer
,	O
PSTR	pointer
szLex	pointer
,	O
int	O
iEqType	long
)	O
{	O
int	O
iKWCode	int
,	O
fContext	int
;	O
long	O
iLowerB	long
,	O
iUpperB	long
;	O
iKWCode	int
=	O
GetKeywordCode	function
(	O
szLex	pointer
,	O
&	O
fContext	int
)	O
;	O
switch	O
(	O
iKWCode	int
)	O
{	O
case	O
KM_DXDT	int
:	O
{	O
int	O
iArg	int
=	O
LX_IDENTIFIER	int
;	O
PVMMAPSTRCT	pointer
pvm	pointer
=	O
NULL	O
;	O
if	O
(	O
GetFuncArgs	function
(	O
pibDum	pointer
,	O
1	int
,	O
&	O
iArg	int
,	O
szLex	pointer
,	O
&	O
iLowerB	long
,	O
&	O
iUpperB	long
)	O
&&	O
(	O
pvm	pointer
=	O
GetVarPTR	function
(	O
vpvmGloVarList	pointer
,	O
szLex	pointer
)	O
)	O
&&	O
TYPE	O
(	O
pvm	pointer
)	O
==	O
ID_STATE	int
)	O
fprintf	function
(	O
pfile	pointer
,	O
"%s"	pointer
,	O
GetName	function
(	O
pvm	pointer
,	O
NULL	O
,	O
"rgDerivs"	pointer
,	O
ID_DERIV	int
)	O
)	O
;	O
else	O
ReportError	function
(	O
pibDum	pointer
,	O
RE_BADSTATE	O
|	O
RE_FATAL	int
,	O
(	O
pvm	pointer
?	O
szLex	pointer
:	O
NULL	O
)	O
,	O
NULL	O
)	O
;	O
}	O
break	O
;	O
case	O
KM_NULL	int
:	O
{	O
PVMMAPSTRCT	pointer
pvm	pointer
=	O
GetVarPTR	function
(	O
vpvmGloVarList	pointer
,	O
szLex	pointer
)	O
;	O
if	O
(	O
!	O
pvm	pointer
)	O
{	O
if	O
(	O
(	O
iEqType	long
==	O
KM_DYNAMICS	int
||	O
iEqType	long
==	O
KM_SCALE	int
||	O
iEqType	long
==	O
KM_CALCOUTPUTS	int
)	O
&&	O
!	O
(	O
strcmp	function
(	O
szLex	pointer
,	O
VSZ_TIME	pointer
)	O
&&	O
strcmp	function
(	O
szLex	pointer
,	O
VSZ_TIME_SBML	pointer
)	O
)	O
)	O
fprintf	function
(	O
pfile	pointer
,	O
"(*pdTime)"	pointer
)	O
;	O
else	O
fprintf	function
(	O
pfile	pointer
,	O
"%s"	pointer
,	O
szLex	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
iEqType	long
==	O
KM_SCALE	int
)	O
fprintf	function
(	O
pfile	pointer
,	O
"%s"	pointer
,	O
GetName	function
(	O
pvm	pointer
,	O
NULL	O
,	O
NULL	O
,	O
ID_NULL	int
)	O
)	O
;	O
else	O
fprintf	function
(	O
pfile	pointer
,	O
"%s"	pointer
,	O
GetName	function
(	O
pvm	pointer
,	O
"rgModelVars"	pointer
,	O
NULL	O
,	O
ID_NULL	int
)	O
)	O
;	O
if	O
(	O
(	O
TYPE	O
(	O
pvm	pointer
)	O
==	O
ID_INPUT	int
)	O
&&	O
(	O
!	O
bForR	int
)	O
)	O
fprintf	function
(	O
pfile	pointer
,	O
".dVal"	pointer
)	O
;	O
}	O
}	O
break	O
;	O
default	O
:	O
ReportError	function
(	O
pibDum	pointer
,	O
RE_BADCONTEXT	O
|	O
RE_FATAL	int
,	O
szLex	pointer
,	O
NULL	O
)	O
;	O
break	O
;	O
}	O
}	O
void	O
TranslateEquation	function
(	O
PFILE	pointer
pfile	pointer
,	O
PSTR	pointer
szEqn	pointer
,	O
long	O
iEqType	long
)	O
{	O
INPUTBUF	struct
ibDum	struct
;	O
PINPUTBUF	pointer
pibDum	pointer
=	O
&	O
ibDum	struct
;	O
PSTRLEX	array
szLex	pointer
;	O
PVMMAPSTRCT	pointer
pvm	pointer
=	O
NULL	O
;	O
int	O
iType	int
;	O
BOOL	int
bDelayCall	int
=	O
FALSE	int
;	O
MakeStringBuffer	function
(	O
NULL	O
,	O
pibDum	pointer
,	O
szEqn	pointer
)	O
;	O
NextLex	function
(	O
pibDum	pointer
,	O
szLex	pointer
,	O
&	O
iType	int
)	O
;	O
if	O
(	O
!	O
iType	int
)	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
"0.0;  /* NULL EQN!?? */"	pointer
)	O
;	O
return	O
;	O
}	O
do	O
{	O
if	O
(	O
iType	int
==	O
LX_IDENTIFIER	int
)	O
{	O
if	O
(	O
bDelayCall	int
)	O
{	O
pvm	pointer
=	O
GetVarPTR	function
(	O
vpvmGloVarList	pointer
,	O
szLex	pointer
)	O
;	O
if	O
(	O
(	O
bForR	int
&&	O
(	O
(	O
pvm	pointer
&&	O
(	O
TYPE	O
(	O
pvm	pointer
)	O
==	O
ID_STATE	int
)	O
)	O
)	O
)	O
||	O
(	O
!	O
bForR	int
&&	O
(	O
(	O
pvm	pointer
&&	O
(	O
TYPE	O
(	O
pvm	pointer
)	O
==	O
ID_STATE	int
)	O
)	O
||	O
(	O
TYPE	O
(	O
pvm	pointer
)	O
==	O
ID_OUTPUT	int
)	O
)	O
)	O
)	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
"ID_%s"	pointer
,	O
szLex	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
", (*pdTime)"	pointer
)	O
;	O
bDelayCall	int
=	O
FALSE	int
;	O
}	O
else	O
ReportError	function
(	O
pibDum	pointer
,	O
RE_LEXEXPECTED	int
|	O
RE_FATAL	int
,	O
(	O
bForR	int
?	O
"state"	pointer
:	O
"state or output"	pointer
)	O
,	O
NULL	O
)	O
;	O
}	O
else	O
TranslateID	function
(	O
pibDum	pointer
,	O
pfile	pointer
,	O
szLex	pointer
,	O
iEqType	long
)	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
iType	int
==	O
LX_EQNPUNCT	int
||	O
iType	int
==	O
LX_PUNCT	int
)	O
&&	O
(	O
*	O
(	O
szLex	pointer
)	O
==	O
CH_COMMENT	O
)	O
)	O
{	O
while	O
(	O
*	O
pibDum	pointer
->	O
pbufCur	pointer
&&	O
*	O
pibDum	pointer
->	O
pbufCur	pointer
!=	O
CH_EOLN	O
)	O
pibDum	pointer
->	O
pbufCur	pointer
++	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
else	O
fprintf	function
(	O
pfile	pointer
,	O
"%s"	pointer
,	O
szLex	pointer
)	O
;	O
}	O
if	O
(	O
!	O
bDelayCall	int
)	O
{	O
bDelayCall	int
=	O
(	O
!	O
strcmp	function
(	O
"CalcDelay"	pointer
,	O
szLex	pointer
)	O
)	O
;	O
bDelay	int
=	O
bDelay	int
||	O
bDelayCall	int
;	O
}	O
fprintf	function
(	O
pfile	pointer
,	O
" "	pointer
)	O
;	O
NextLex	function
(	O
pibDum	pointer
,	O
szLex	pointer
,	O
&	O
iType	int
)	O
;	O
}	O
while	O
(	O
iType	int
)	O
;	O
if	O
(	O
bForR	int
&&	O
bForInits	int
)	O
fprintf	function
(	O
pfile	pointer
,	O
"\n"	pointer
)	O
;	O
else	O
fprintf	function
(	O
pfile	pointer
,	O
";\n"	pointer
)	O
;	O
}	O
int	O
WriteOneEquation	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvm	pointer
,	O
PVOID	pointer
pInfo	pointer
)	O
{	O
long	O
iType	int
=	O
(	O
long	O
)	O
pInfo	pointer
;	O
if	O
(	O
pvm	pointer
->	O
hType	long
&	O
ID_SPACEFLAG	int
)	O
fprintf	function
(	O
pfile	pointer
,	O
"\n"	pointer
)	O
;	O
switch	O
(	O
iType	int
)	O
{	O
default	O
:	O
case	O
KM_SCALE	int
:	O
if	O
(	O
TYPE	O
(	O
pvm	pointer
)	O
==	O
ID_INPUT	int
)	O
{	O
printf	function
(	O
"Error: input '%s' used in Scale context.\n"	pointer
,	O
pvm	pointer
->	O
szName	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
if	O
(	O
TYPE	O
(	O
pvm	pointer
)	O
!=	O
ID_INLINE	int
)	O
{	O
if	O
(	O
bForR	int
&&	O
bForInits	int
&&	O
TYPE	O
(	O
pvm	pointer
)	O
==	O
ID_STATE	int
)	O
fprintf	function
(	O
pfile	pointer
,	O
"    Y[\"%s\"] <- "	pointer
,	O
GetName	function
(	O
pvm	pointer
,	O
NULL	O
,	O
NULL	O
,	O
ID_NULL	int
)	O
)	O
;	O
else	O
fprintf	function
(	O
pfile	pointer
,	O
"  %s = "	pointer
,	O
GetName	function
(	O
pvm	pointer
,	O
NULL	O
,	O
NULL	O
,	O
ID_NULL	int
)	O
)	O
;	O
}	O
break	O
;	O
case	O
KM_CALCOUTPUTS	int
:	O
case	O
KM_DYNAMICS	int
:	O
case	O
KM_JACOB	int
:	O
case	O
KM_EVENTS	int
:	O
case	O
KM_ROOTS	int
:	O
if	O
(	O
TYPE	O
(	O
pvm	pointer
)	O
!=	O
ID_INLINE	int
)	O
fprintf	function
(	O
pfile	pointer
,	O
"  %s = "	pointer
,	O
GetName	function
(	O
pvm	pointer
,	O
"rgModelVars"	pointer
,	O
"rgDerivs"	pointer
,	O
ID_NULL	int
)	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
TYPE	O
(	O
pvm	pointer
)	O
==	O
ID_INLINE	int
)	O
fprintf	function
(	O
pfile	pointer
,	O
"\n%s\n"	pointer
,	O
pvm	pointer
->	O
szEqn	pointer
)	O
;	O
else	O
TranslateEquation	function
(	O
pfile	pointer
,	O
pvm	pointer
->	O
szEqn	pointer
,	O
iType	int
)	O
;	O
return	O
1	int
;	O
}	O
void	O
WriteCalcDeriv	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvmGlo	pointer
,	O
PVMMAPSTRCT	pointer
pvmDyn	pointer
)	O
{	O
if	O
(	O
!	O
pvmDyn	pointer
)	O
printf	function
(	O
"No Dynamics{} equations.\n\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"/*----- Dynamics section */\n\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"void CalcDeriv (double  rgModelVars[], "	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"double  rgDerivs[], PDOUBLE pdTime)\n{\n"	pointer
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmGlo	pointer
,	O
&	O
WriteOneDecl	function
,	O
ID_LOCALDYN	int
,	O
NULL	O
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"\n  CalcInputs (pdTime); /* Get new input vals */\n\n"	pointer
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmDyn	pointer
,	O
&	O
WriteOneEquation	function
,	O
ALL_VARS	O
,	O
(	O
PVOID	pointer
)	O
KM_DYNAMICS	int
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"\n} /* CalcDeriv */\n\n\n"	pointer
)	O
;	O
}	O
void	O
WriteScale	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvmGlo	pointer
,	O
PVMMAPSTRCT	pointer
pvmScale	pointer
)	O
{	O
if	O
(	O
!	O
pvmScale	pointer
)	O
printf	function
(	O
"No Scale{} equations. Null function defined.\n\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"/*----- Model scaling */\n\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"void ScaleModel (PDOUBLE pdTime)\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"{\n"	pointer
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmGlo	pointer
,	O
&	O
WriteOneDecl	function
,	O
ID_LOCALSCALE	int
,	O
NULL	O
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmScale	pointer
,	O
&	O
WriteOneEquation	function
,	O
ALL_VARS	O
,	O
(	O
PVOID	pointer
)	O
KM_SCALE	int
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"\n} /* ScaleModel */\n\n\n"	pointer
)	O
;	O
}	O
void	O
WriteCalcJacob	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvmGlo	pointer
,	O
PVMMAPSTRCT	pointer
pvmJacob	pointer
)	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
"/*----- Jacobian calculations */\n\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"void CalcJacob (PDOUBLE pdTime, double rgModelVars[],\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"                long column, double rgdJac[])\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"{\n"	pointer
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmGlo	pointer
,	O
&	O
WriteOneDecl	function
,	O
ID_LOCALJACOB	int
,	O
NULL	O
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmJacob	pointer
,	O
&	O
WriteOneEquation	function
,	O
ALL_VARS	O
,	O
(	O
PVOID	pointer
)	O
KM_JACOB	int
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"\n} /* CalcJacob */\n\n\n"	pointer
)	O
;	O
}	O
void	O
WriteCalcOutputs	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvmGlo	pointer
,	O
PVMMAPSTRCT	pointer
pvmCalcOut	pointer
)	O
{	O
if	O
(	O
!	O
pvmCalcOut	pointer
)	O
printf	function
(	O
"No CalcOutputs{} equations. Null function defined.\n\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"/*----- Outputs calculations */\n\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"void CalcOutputs (double  rgModelVars[], "	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"double  rgDerivs[], PDOUBLE pdTime)\n{\n"	pointer
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmGlo	pointer
,	O
&	O
WriteOneDecl	function
,	O
ID_LOCALCALCOUT	int
,	O
NULL	O
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmCalcOut	pointer
,	O
&	O
WriteOneEquation	function
,	O
ALL_VARS	O
,	O
(	O
PVOID	pointer
)	O
KM_CALCOUTPUTS	int
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"\n}  /* CalcOutputs */\n\n\n"	pointer
)	O
;	O
}	O
int	O
IndexOneVar	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvm	pointer
,	O
PVOID	pointer
pInfo	pointer
)	O
{	O
if	O
(	O
pvm	pointer
->	O
szEqn	pointer
!=	O
vszHasInitializer	array
)	O
{	O
pvm	pointer
->	O
hType	long
|=	O
(	O
*	O
(	O
(	O
PINT	pointer
)	O
pInfo	pointer
)	O
)	O
++	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
IndexVariables	function
(	O
PVMMAPSTRCT	pointer
pvmGlo	pointer
)	O
{	O
int	O
iIndex	int
,	O
iMax	int
=	O
MAX_VARS	O
;	O
vnStates	int
=	O
ForAllVar	function
(	O
NULL	O
,	O
pvmGlo	pointer
,	O
&	O
CountOneDecl	function
,	O
ID_STATE	int
,	O
NULL	O
)	O
;	O
vnOutputs	int
=	O
ForAllVar	function
(	O
NULL	O
,	O
pvmGlo	pointer
,	O
&	O
CountOneDecl	function
,	O
ID_OUTPUT	int
,	O
NULL	O
)	O
;	O
vnInputs	int
=	O
ForAllVar	function
(	O
NULL	O
,	O
pvmGlo	pointer
,	O
&	O
CountOneDecl	function
,	O
ID_INPUT	int
,	O
NULL	O
)	O
;	O
vnParms	int
=	O
ForAllVar	function
(	O
NULL	O
,	O
pvmGlo	pointer
,	O
&	O
CountOneDecl	function
,	O
ID_PARM	int
,	O
NULL	O
)	O
;	O
vnModelVars	int
=	O
vnStates	int
+	O
vnOutputs	int
;	O
if	O
(	O
vnStates	int
>	O
MAX_VARS	O
)	O
ReportError	function
(	O
NULL	O
,	O
RE_TOOMANYVARS	O
,	O
"state"	pointer
,	O
(	O
PSTR	pointer
)	O
&	O
iMax	int
)	O
;	O
if	O
(	O
vnOutputs	int
>	O
MAX_VARS	O
)	O
ReportError	function
(	O
NULL	O
,	O
RE_TOOMANYVARS	O
,	O
"input"	pointer
,	O
(	O
PSTR	pointer
)	O
&	O
iMax	int
)	O
;	O
if	O
(	O
vnInputs	int
>	O
MAX_VARS	O
)	O
ReportError	function
(	O
NULL	O
,	O
RE_TOOMANYVARS	O
,	O
"output"	pointer
,	O
(	O
PSTR	pointer
)	O
&	O
iMax	int
)	O
;	O
if	O
(	O
vnParms	int
>	O
(	O
iMax	int
=	O
MAX_VARS	O
-	O
vnModelVars	int
)	O
)	O
ReportError	function
(	O
NULL	O
,	O
RE_TOOMANYVARS	O
,	O
"parameter"	pointer
,	O
(	O
PSTR	pointer
)	O
&	O
iMax	int
)	O
;	O
if	O
(	O
vnStates	int
>	O
MAX_VARS	O
||	O
vnInputs	int
>	O
MAX_VARS	O
||	O
vnOutputs	int
>	O
MAX_VARS	O
||	O
vnParms	int
>	O
iMax	int
)	O
ReportError	function
(	O
NULL	O
,	O
RE_FATAL	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
iIndex	int
=	O
0	int
;	O
ForAllVar	function
(	O
NULL	O
,	O
pvmGlo	pointer
,	O
&	O
IndexOneVar	function
,	O
ID_STATE	int
,	O
(	O
PVOID	pointer
)	O
&	O
iIndex	int
)	O
;	O
ForAllVar	function
(	O
NULL	O
,	O
pvmGlo	pointer
,	O
&	O
IndexOneVar	function
,	O
ID_OUTPUT	int
,	O
(	O
PVOID	pointer
)	O
&	O
iIndex	int
)	O
;	O
iIndex	int
=	O
0	int
;	O
ForAllVar	function
(	O
NULL	O
,	O
pvmGlo	pointer
,	O
&	O
IndexOneVar	function
,	O
ID_INPUT	int
,	O
(	O
PVOID	pointer
)	O
&	O
iIndex	int
)	O
;	O
iIndex	int
=	O
vnStates	int
+	O
vnOutputs	int
+	O
vnInputs	int
;	O
ForAllVar	function
(	O
NULL	O
,	O
pvmGlo	pointer
,	O
&	O
IndexOneVar	function
,	O
ID_PARM	int
,	O
(	O
PVOID	pointer
)	O
&	O
iIndex	int
)	O
;	O
}	O
int	O
AdjustOneVar	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvm	pointer
,	O
PVOID	pointer
pInfo	pointer
)	O
{	O
PIFN	pointer
pifn	pointer
=	O
(	O
PIFN	pointer
)	O
pvm	pointer
->	O
szEqn	pointer
;	O
WORD	int
wOffset	int
=	O
*	O
(	O
PWORD	pointer
)	O
pInfo	pointer
;	O
if	O
(	O
!	O
pifn	pointer
)	O
return	O
1	int
;	O
if	O
(	O
pifn	pointer
->	O
hMag	long
)	O
pifn	pointer
->	O
hMag	long
+=	O
wOffset	int
;	O
if	O
(	O
pifn	pointer
->	O
hTper	long
)	O
pifn	pointer
->	O
hTper	long
+=	O
wOffset	int
;	O
if	O
(	O
pifn	pointer
->	O
hT0	long
)	O
pifn	pointer
->	O
hT0	long
+=	O
wOffset	int
;	O
if	O
(	O
pifn	pointer
->	O
hTexp	long
)	O
pifn	pointer
->	O
hTexp	long
+=	O
wOffset	int
;	O
if	O
(	O
pifn	pointer
->	O
hDecay	long
)	O
pifn	pointer
->	O
hDecay	long
+=	O
wOffset	int
;	O
return	O
1	int
;	O
}	O
void	O
AdjustVarHandles	function
(	O
PVMMAPSTRCT	pointer
pvmGlo	pointer
)	O
{	O
WORD	int
wOffset	int
=	O
(	O
WORD	int
)	O
vnInputs	int
+	O
vnStates	int
+	O
vnOutputs	int
;	O
ForAllVar	function
(	O
NULL	O
,	O
pvmGlo	pointer
,	O
&	O
AdjustOneVar	function
,	O
ID_INPUT	int
,	O
(	O
PVOID	pointer
)	O
&	O
wOffset	int
)	O
;	O
}	O
void	O
ReversePointers	function
(	O
PVMMAPSTRCT	pointer
*	O
ppvm	pointer
)	O
{	O
PVMMAPSTRCT	pointer
pvmPrev	pointer
,	O
pvmNext	pointer
;	O
if	O
(	O
!	O
ppvm	pointer
||	O
!	O
(	O
*	O
ppvm	pointer
)	O
||	O
!	O
(	O
*	O
ppvm	pointer
)	O
->	O
pvmNextVar	pointer
)	O
return	O
;	O
pvmPrev	pointer
=	O
NULL	O
;	O
while	O
(	O
(	O
pvmNext	pointer
=	O
(	O
*	O
ppvm	pointer
)	O
->	O
pvmNextVar	pointer
)	O
)	O
{	O
(	O
*	O
ppvm	pointer
)	O
->	O
pvmNextVar	pointer
=	O
pvmPrev	pointer
;	O
pvmPrev	pointer
=	O
(	O
*	O
ppvm	pointer
)	O
;	O
*	O
ppvm	pointer
=	O
pvmNext	pointer
;	O
}	O
(	O
*	O
ppvm	pointer
)	O
->	O
pvmNextVar	pointer
=	O
pvmPrev	pointer
;	O
}	O
int	O
AssertExistsEqn	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvm	pointer
,	O
PVOID	pointer
pInfo	pointer
)	O
{	O
int	O
iReturn	int
=	O
0	int
;	O
PVMMAPSTRCT	pointer
pvmDyn	pointer
=	O
(	O
PVMMAPSTRCT	pointer
)	O
pInfo	pointer
;	O
if	O
(	O
pvm	pointer
->	O
szEqn	pointer
!=	O
vszHasInitializer	array
)	O
{	O
if	O
(	O
pvmDyn	pointer
)	O
{	O
if	O
(	O
!	O
(	O
iReturn	int
=	O
(	O
GetVarPTR	function
(	O
pvmDyn	pointer
,	O
pvm	pointer
->	O
szName	pointer
)	O
!=	O
NULL	O
)	O
)	O
)	O
ReportError	function
(	O
NULL	O
,	O
RE_NODYNEQN	O
,	O
pvm	pointer
->	O
szName	pointer
,	O
NULL	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
(	O
iReturn	int
=	O
(	O
pvm	pointer
->	O
szEqn	pointer
!=	O
NULL	O
)	O
)	O
)	O
ReportError	function
(	O
NULL	O
,	O
RE_NOINPDEF	O
,	O
pvm	pointer
->	O
szName	pointer
,	O
NULL	O
)	O
;	O
}	O
return	O
(	O
iReturn	int
?	O
1	int
:	O
0	int
)	O
;	O
}	O
void	O
VerifyEqns	function
(	O
PVMMAPSTRCT	pointer
pvmGlo	pointer
,	O
PVMMAPSTRCT	pointer
pvmDyn	pointer
)	O
{	O
BOOL	int
bStatesOK	int
;	O
bStatesOK	int
=	O
(	O
vnStates	int
==	O
ForAllVar	function
(	O
NULL	O
,	O
pvmGlo	pointer
,	O
&	O
AssertExistsEqn	function
,	O
ID_STATE	int
,	O
(	O
PVOID	pointer
)	O
pvmDyn	pointer
)	O
)	O
;	O
if	O
(	O
!	O
bStatesOK	int
)	O
ReportError	function
(	O
NULL	O
,	O
RE_FATAL	int
,	O
NULL	O
,	O
"State equations missing.\n"	pointer
)	O
;	O
}	O
int	O
AssertExistsOutputEqn	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvm	pointer
,	O
PVOID	pointer
pInfo	pointer
)	O
{	O
int	O
iReturn	int
=	O
0	int
;	O
PINPUTINFO	pointer
pinfo	pointer
=	O
(	O
PINPUTINFO	pointer
)	O
pInfo	pointer
;	O
PVMMAPSTRCT	pointer
pvmDyn	pointer
=	O
(	O
PVMMAPSTRCT	pointer
)	O
pinfo	pointer
->	O
pvmDynEqns	pointer
;	O
PVMMAPSTRCT	pointer
pvmOut	pointer
=	O
(	O
PVMMAPSTRCT	pointer
)	O
pinfo	pointer
->	O
pvmCalcOutEqns	pointer
;	O
if	O
(	O
pvm	pointer
->	O
szEqn	pointer
!=	O
vszHasInitializer	array
)	O
{	O
if	O
(	O
(	O
GetVarPTR	function
(	O
pvmDyn	pointer
,	O
pvm	pointer
->	O
szName	pointer
)	O
==	O
NULL	O
)	O
&&	O
(	O
GetVarPTR	function
(	O
pvmOut	pointer
,	O
pvm	pointer
->	O
szName	pointer
)	O
==	O
NULL	O
)	O
)	O
{	O
ReportError	function
(	O
NULL	O
,	O
RE_NOOUTPUTEQN	O
,	O
pvm	pointer
->	O
szName	pointer
,	O
NULL	O
)	O
;	O
iReturn	int
=	O
0	int
;	O
}	O
else	O
iReturn	int
=	O
1	int
;	O
}	O
return	O
(	O
iReturn	int
?	O
1	int
:	O
0	int
)	O
;	O
}	O
void	O
VerifyOutputEqns	function
(	O
PINPUTINFO	pointer
pInfo	pointer
)	O
{	O
BOOL	int
bOutputsOK	int
;	O
bOutputsOK	int
=	O
(	O
vnOutputs	int
==	O
ForAllVar	function
(	O
NULL	O
,	O
pInfo	pointer
->	O
pvmGloVars	pointer
,	O
&	O
AssertExistsOutputEqn	function
,	O
ID_OUTPUT	int
,	O
(	O
PVOID	pointer
)	O
pInfo	pointer
)	O
)	O
;	O
if	O
(	O
!	O
bOutputsOK	int
)	O
ReportError	function
(	O
NULL	O
,	O
RE_FATAL	int
,	O
NULL	O
,	O
"Output equations missing.\n"	pointer
)	O
;	O
}	O
void	O
WriteModel	function
(	O
PINPUTINFO	pointer
pinfo	pointer
,	O
PSTR	pointer
szFileOut	pointer
)	O
{	O
PFILE	pointer
pfile	pointer
;	O
if	O
(	O
!	O
pinfo	pointer
->	O
pvmGloVars	pointer
||	O
(	O
!	O
pinfo	pointer
->	O
pvmDynEqns	pointer
&&	O
!	O
pinfo	pointer
->	O
pvmCalcOutEqns	pointer
)	O
)	O
{	O
printf	function
(	O
"Error: No Dynamics, no outputs or no global variables defined\n"	pointer
)	O
;	O
return	O
;	O
}	O
ReversePointers	function
(	O
&	O
pinfo	pointer
->	O
pvmGloVars	pointer
)	O
;	O
ReversePointers	function
(	O
&	O
pinfo	pointer
->	O
pvmDynEqns	pointer
)	O
;	O
ReversePointers	function
(	O
&	O
pinfo	pointer
->	O
pvmScaleEqns	pointer
)	O
;	O
ReversePointers	function
(	O
&	O
pinfo	pointer
->	O
pvmCalcOutEqns	pointer
)	O
;	O
ReversePointers	function
(	O
&	O
pinfo	pointer
->	O
pvmJacobEqns	pointer
)	O
;	O
vpvmGloVarList	pointer
=	O
pinfo	pointer
->	O
pvmGloVars	pointer
;	O
IndexVariables	function
(	O
pinfo	pointer
->	O
pvmGloVars	pointer
)	O
;	O
AdjustVarHandles	function
(	O
pinfo	pointer
->	O
pvmGloVars	pointer
)	O
;	O
VerifyEqns	function
(	O
pinfo	pointer
->	O
pvmGloVars	pointer
,	O
pinfo	pointer
->	O
pvmDynEqns	pointer
)	O
;	O
VerifyOutputEqns	function
(	O
pinfo	pointer
)	O
;	O
pfile	pointer
=	O
fopen	function
(	O
szFileOut	pointer
,	O
"w"	pointer
)	O
;	O
if	O
(	O
pfile	pointer
)	O
{	O
vszModelFilename	pointer
=	O
pinfo	pointer
->	O
szInputFilename	pointer
;	O
vszModGenName	pointer
=	O
pinfo	pointer
->	O
szModGenName	pointer
;	O
WriteHeader	function
(	O
pfile	pointer
,	O
szFileOut	pointer
,	O
pinfo	pointer
->	O
pvmGloVars	pointer
)	O
;	O
WriteIncludes	function
(	O
pfile	pointer
)	O
;	O
WriteDecls	function
(	O
pfile	pointer
,	O
pinfo	pointer
->	O
pvmGloVars	pointer
)	O
;	O
WritebDelays	function
(	O
pfile	pointer
,	O
pinfo	pointer
->	O
bDelays	int
)	O
;	O
WriteVarMap	function
(	O
pfile	pointer
,	O
pinfo	pointer
->	O
pvmGloVars	pointer
)	O
;	O
WriteInitModel	function
(	O
pfile	pointer
,	O
pinfo	pointer
->	O
pvmGloVars	pointer
)	O
;	O
WriteCalcDeriv	function
(	O
pfile	pointer
,	O
pinfo	pointer
->	O
pvmGloVars	pointer
,	O
pinfo	pointer
->	O
pvmDynEqns	pointer
)	O
;	O
WriteScale	function
(	O
pfile	pointer
,	O
pinfo	pointer
->	O
pvmGloVars	pointer
,	O
pinfo	pointer
->	O
pvmScaleEqns	pointer
)	O
;	O
WriteCalcJacob	function
(	O
pfile	pointer
,	O
pinfo	pointer
->	O
pvmGloVars	pointer
,	O
pinfo	pointer
->	O
pvmJacobEqns	pointer
)	O
;	O
WriteCalcOutputs	function
(	O
pfile	pointer
,	O
pinfo	pointer
->	O
pvmGloVars	pointer
,	O
pinfo	pointer
->	O
pvmCalcOutEqns	pointer
)	O
;	O
fclose	function
(	O
pfile	pointer
)	O
;	O
printf	function
(	O
"\n* Created model file '%s'.\n\n"	pointer
,	O
szFileOut	pointer
)	O
;	O
}	O
else	O
ReportError	function
(	O
NULL	O
,	O
RE_CANNOTOPEN	int
|	O
RE_FATAL	int
,	O
szFileOut	pointer
,	O
"...in WriteModel ()"	pointer
)	O
;	O
}	O
int	O
WriteOne_R_SODefine	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvm	pointer
,	O
PVOID	pointer
pInfo	pointer
)	O
{	O
static	O
long	O
iStates	long
=	O
0	int
;	O
static	O
long	O
iOutputs	long
=	O
0	int
;	O
if	O
(	O
pvm	pointer
->	O
szEqn	pointer
!=	O
vszHasInitializer	array
)	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
"#define "	pointer
)	O
;	O
WriteIndexName	O
(	O
pfile	pointer
,	O
pvm	pointer
)	O
;	O
if	O
(	O
TYPE	O
(	O
pvm	pointer
)	O
==	O
ID_STATE	int
)	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
" 0x%05lx\n"	pointer
,	O
iStates	long
)	O
;	O
iStates	long
=	O
iStates	long
+	O
1	int
;	O
}	O
else	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
" 0x%05lx\n"	pointer
,	O
iOutputs	long
)	O
;	O
iOutputs	long
=	O
iOutputs	long
+	O
1	int
;	O
}	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
Write_R_Scale	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvmGlo	pointer
,	O
PVMMAPSTRCT	pointer
pvmScale	pointer
)	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
"void getParms (double *inParms, double *out, int *nout) {\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"/*----- Model scaling */\n\n"	pointer
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmGlo	pointer
,	O
&	O
WriteOneDecl	function
,	O
ID_LOCALSCALE	int
,	O
NULL	O
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  int i;\n\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  for (i = 0; i < *nout; i++) {\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"    parms[i] = inParms[i];\n  }\n\n"	pointer
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmScale	pointer
,	O
&	O
WriteOneEquation	function
,	O
ID_PARM	int
,	O
(	O
PVOID	pointer
)	O
KM_SCALE	int
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"\n  for (i = 0; i < *nout; i++) {\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"    out[i] = parms[i];\n  }\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  }\n"	pointer
)	O
;	O
}	O
void	O
Write_R_State_Scale	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvmScale	pointer
)	O
{	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmScale	pointer
,	O
&	O
WriteOneEquation	function
,	O
ID_STATE	int
,	O
(	O
PVOID	pointer
)	O
KM_SCALE	int
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmScale	pointer
,	O
&	O
WriteOneEquation	function
,	O
ID_INLINE	int
,	O
(	O
PVOID	pointer
)	O
KM_SCALE	int
)	O
;	O
}	O
void	O
Write_R_CalcDeriv	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvmGlo	pointer
,	O
PVMMAPSTRCT	pointer
pvmDyn	pointer
,	O
PVMMAPSTRCT	pointer
pvmCalcOut	pointer
)	O
{	O
if	O
(	O
!	O
pvmDyn	pointer
)	O
printf	function
(	O
"No Dynamics{} equations.\n\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"/*----- Dynamics section */\n\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"void derivs (int *neq, double *pdTime, double *y, "	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"double *ydot, double *yout, int *ip)\n{\n"	pointer
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmGlo	pointer
,	O
&	O
WriteOneDecl	function
,	O
ID_LOCALDYN	int
,	O
NULL	O
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmGlo	pointer
,	O
&	O
WriteOneDecl	function
,	O
ID_LOCALCALCOUT	int
,	O
NULL	O
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmDyn	pointer
,	O
&	O
WriteOneEquation	function
,	O
ALL_VARS	O
,	O
(	O
PVOID	pointer
)	O
KM_DYNAMICS	int
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmCalcOut	pointer
,	O
&	O
WriteOneEquation	function
,	O
ALL_VARS	O
,	O
(	O
PVOID	pointer
)	O
KM_CALCOUTPUTS	int
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"\n} /* derivs */\n\n\n"	pointer
)	O
;	O
}	O
void	O
Write_R_InitModel	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvmGlo	pointer
)	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
"/*----- Initializers */\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"void initmod (void (* odeparms)(int *, double *))\n{\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  int N=%d;\n"	pointer
,	O
vnParms	int
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  odeparms(&N, parms);\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"}\n\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"void initforc (void (* odeforcs)(int *, double *))\n{\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  int N=%d;\n"	pointer
,	O
vnInputs	int
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  odeforcs(&N, forc);\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"}\n\n\n"	pointer
)	O
;	O
if	O
(	O
bDelay	int
)	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
"/* Calling R code will ensure that input y has same\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"   dimension as yini */\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"void initState (double *y)\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"{\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  int i;\n\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  for (i = 0; i < sizeof(yini) / sizeof(yini[0]); i++)\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  {\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"    yini[i] = y[i];\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  }\n}\n\n"	pointer
)	O
;	O
}	O
}	O
void	O
Write_R_CalcJacob	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvmGlo	pointer
,	O
PVMMAPSTRCT	pointer
pvmJacob	pointer
)	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
"/*----- Jacobian calculations: */\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"void jac (int *neq, double *t, double *y, int *ml, "	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"int *mu, "	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"double *pd, int *nrowpd, double *yout, int *ip)\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"{\n"	pointer
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmGlo	pointer
,	O
&	O
WriteOneDecl	function
,	O
ID_LOCALJACOB	int
,	O
NULL	O
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmJacob	pointer
,	O
&	O
WriteOneEquation	function
,	O
ALL_VARS	O
,	O
(	O
PVOID	pointer
)	O
KM_JACOB	int
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"\n} /* jac */\n\n\n"	pointer
)	O
;	O
}	O
void	O
Write_R_Events	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvmGlo	pointer
,	O
PVMMAPSTRCT	pointer
pvmEvents	pointer
)	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
"/*----- Events calculations: */\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"void event (int *n, double *t, double *y)\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"{\n"	pointer
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmGlo	pointer
,	O
&	O
WriteOneDecl	function
,	O
ID_LOCALEVENT	int
,	O
NULL	O
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmEvents	pointer
,	O
&	O
WriteOneEquation	function
,	O
ALL_VARS	O
,	O
(	O
PVOID	pointer
)	O
KM_EVENTS	int
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"\n} /* event */\n\n"	pointer
)	O
;	O
}	O
void	O
Write_R_Roots	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvmGlo	pointer
,	O
PVMMAPSTRCT	pointer
pvmRoots	pointer
)	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
"/*----- Roots calculations: */\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"void root (int *neq, double *t, double *y, "	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"int *ng, double *gout, double *out, int *ip)\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"{\n"	pointer
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmGlo	pointer
,	O
&	O
WriteOneDecl	function
,	O
ID_LOCALROOT	int
,	O
NULL	O
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmRoots	pointer
,	O
&	O
WriteOneEquation	function
,	O
ALL_VARS	O
,	O
(	O
PVOID	pointer
)	O
KM_ROOTS	int
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"\n} /* root */\n\n"	pointer
)	O
;	O
}	O
int	O
WriteOne_R_PIDefine	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvm	pointer
,	O
PVOID	pointer
pInfo	pointer
)	O
{	O
static	O
long	O
iParms	long
=	O
0	int
;	O
static	O
long	O
iForcs	long
=	O
0	int
;	O
assert	O
(	O
TYPE	O
(	O
pvm	pointer
)	O
!=	O
ID_OUTPUT	int
)	O
;	O
assert	O
(	O
TYPE	O
(	O
pvm	pointer
)	O
!=	O
ID_STATE	int
)	O
;	O
if	O
(	O
TYPE	O
(	O
pvm	pointer
)	O
==	O
ID_PARM	int
)	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
"#define %s parms[%ld]\n"	pointer
,	O
pvm	pointer
->	O
szName	pointer
,	O
iParms	long
)	O
;	O
iParms	long
=	O
iParms	long
+	O
1	int
;	O
}	O
else	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
"#define %s forc[%ld]\n"	pointer
,	O
pvm	pointer
->	O
szName	pointer
,	O
iForcs	long
)	O
;	O
iForcs	long
=	O
iForcs	long
+	O
1	int
;	O
}	O
return	O
(	O
1	int
)	O
;	O
}	O
int	O
ForAllVarwSep	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvm	pointer
,	O
PFI_CALLBACK	pointer
pfiFunc	pointer
,	O
HANDLE	long
hType	long
,	O
PVOID	pointer
pinfo	pointer
)	O
{	O
int	O
iTotal	int
=	O
0	int
;	O
long	O
End	long
=	O
-	O
1	int
;	O
int	O
iCount	int
=	O
0	int
;	O
while	O
(	O
pvm	pointer
)	O
{	O
if	O
(	O
hType	long
==	O
ALL_VARS	O
||	O
TYPE	O
(	O
pvm	pointer
)	O
==	O
hType	long
)	O
{	O
if	O
(	O
pvm	pointer
->	O
szEqn	pointer
!=	O
vszHasInitializer	array
)	O
{	O
if	O
(	O
pfiFunc	pointer
)	O
{	O
if	O
(	O
iCount	int
>	O
0	int
)	O
End	long
=	O
0	int
;	O
iTotal	int
+=	O
(	O
*	O
pfiFunc	pointer
)	O
(	O
pfile	pointer
,	O
pvm	pointer
,	O
(	O
PVOID	pointer
)	O
End	long
)	O
;	O
iCount	int
++	O
;	O
}	O
else	O
iTotal	int
++	O
;	O
}	O
}	O
pvm	pointer
=	O
pvm	pointer
->	O
pvmNextVar	pointer
;	O
}	O
End	long
=	O
1	int
;	O
(	O
*	O
pfiFunc	pointer
)	O
(	O
pfile	pointer
,	O
pvm	pointer
,	O
(	O
PVOID	pointer
)	O
End	long
)	O
;	O
return	O
(	O
iTotal	int
)	O
;	O
}	O
int	O
Is_numeric	function
(	O
PSTR	pointer
str	pointer
)	O
{	O
double	O
val	double
;	O
char	O
*	O
ptr	pointer
;	O
if	O
(	O
str	pointer
)	O
{	O
val	double
=	O
strtod	function
(	O
(	O
char	O
*	O
)	O
str	pointer
,	O
&	O
ptr	pointer
)	O
;	O
if	O
(	O
strlen	function
(	O
ptr	pointer
)	O
>	O
0	int
)	O
return	O
(	O
0	int
)	O
;	O
else	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
{	O
return	O
(	O
2	int
)	O
;	O
}	O
}	O
int	O
WriteOne_R_PSDecl	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvm	pointer
,	O
PVOID	pointer
pInfo	pointer
)	O
{	O
PSTR	pointer
szVarName	pointer
;	O
PSTR	pointer
szZero	pointer
=	O
"0.0"	pointer
;	O
long	O
End	long
=	O
(	O
long	O
)	O
pInfo	pointer
;	O
PSTR	pointer
RHS	pointer
;	O
int	O
iOut	int
;	O
if	O
(	O
End	long
<	O
1	int
)	O
{	O
szVarName	pointer
=	O
GetName	function
(	O
pvm	pointer
,	O
NULL	O
,	O
NULL	O
,	O
ID_NULL	int
)	O
;	O
iOut	int
=	O
Is_numeric	function
(	O
pvm	pointer
->	O
szEqn	pointer
)	O
;	O
switch	O
(	O
iOut	int
)	O
{	O
case	O
0	int
:	O
RHS	pointer
=	O
szZero	pointer
;	O
break	O
;	O
case	O
1	int
:	O
RHS	pointer
=	O
pvm	pointer
->	O
szEqn	pointer
;	O
break	O
;	O
case	O
2	int
:	O
RHS	pointer
=	O
szZero	pointer
;	O
}	O
}	O
switch	O
(	O
End	long
)	O
{	O
case	O
-	O
1	int
:	O
fprintf	function
(	O
pfile	pointer
,	O
"    %s = %s"	pointer
,	O
szVarName	pointer
,	O
RHS	pointer
)	O
;	O
break	O
;	O
case	O
0	int
:	O
fprintf	function
(	O
pfile	pointer
,	O
",\n    %s = %s"	pointer
,	O
szVarName	pointer
,	O
RHS	pointer
)	O
;	O
break	O
;	O
case	O
1	int
:	O
fprintf	function
(	O
pfile	pointer
,	O
"\n"	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
return	O
(	O
1	int
)	O
;	O
}	O
int	O
WriteOne_R_ParmInit	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvm	pointer
,	O
PVOID	pointer
pInfo	pointer
)	O
{	O
PSTR	pointer
szVarName	pointer
;	O
int	O
iOut	int
;	O
if	O
(	O
(	O
(	O
long	O
)	O
pInfo	pointer
)	O
<	O
1	int
)	O
{	O
szVarName	pointer
=	O
GetName	function
(	O
pvm	pointer
,	O
NULL	O
,	O
NULL	O
,	O
ID_NULL	int
)	O
;	O
iOut	int
=	O
Is_numeric	function
(	O
pvm	pointer
->	O
szEqn	pointer
)	O
;	O
if	O
(	O
iOut	int
==	O
0	int
)	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
"    %s = %s;\n"	pointer
,	O
szVarName	pointer
,	O
pvm	pointer
->	O
szEqn	pointer
)	O
;	O
}	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
WriteOne_R_StateInit	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvm	pointer
,	O
PVOID	pointer
pInfo	pointer
)	O
{	O
PSTR	pointer
szVarName	pointer
;	O
long	O
End	long
=	O
(	O
long	O
)	O
pInfo	pointer
;	O
if	O
(	O
End	long
<	O
1	int
)	O
szVarName	pointer
=	O
GetName	function
(	O
pvm	pointer
,	O
NULL	O
,	O
NULL	O
,	O
ID_NULL	int
)	O
;	O
switch	O
(	O
End	long
)	O
{	O
case	O
-	O
1	int
:	O
fprintf	function
(	O
pfile	pointer
,	O
"    %s = %s"	pointer
,	O
szVarName	pointer
,	O
(	O
pvm	pointer
->	O
szEqn	pointer
?	O
pvm	pointer
->	O
szEqn	pointer
:	O
"0.0"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
0	int
:	O
fprintf	function
(	O
pfile	pointer
,	O
",\n    %s = %s"	pointer
,	O
szVarName	pointer
,	O
(	O
pvm	pointer
->	O
szEqn	pointer
?	O
pvm	pointer
->	O
szEqn	pointer
:	O
"0.0"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
fprintf	function
(	O
pfile	pointer
,	O
"\n"	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
return	O
(	O
1	int
)	O
;	O
}	O
int	O
WriteOneOutputName	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvm	pointer
,	O
PVOID	pointer
pInfo	pointer
)	O
{	O
long	O
END	long
=	O
(	O
long	O
)	O
pInfo	pointer
;	O
switch	O
(	O
END	long
)	O
{	O
case	O
-	O
1	int
:	O
fprintf	function
(	O
pfile	pointer
,	O
"    \"%s\""	pointer
,	O
pvm	pointer
->	O
szName	pointer
)	O
;	O
break	O
;	O
case	O
0	int
:	O
fprintf	function
(	O
pfile	pointer
,	O
",\n    \"%s\""	pointer
,	O
pvm	pointer
->	O
szName	pointer
)	O
;	O
break	O
;	O
case	O
1	int
:	O
fprintf	function
(	O
pfile	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
return	O
(	O
1	int
)	O
;	O
}	O
void	O
Write_R_InitPOS	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvmGlo	pointer
,	O
PVMMAPSTRCT	pointer
pvmScale	pointer
)	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
"initParms <- function(newParms = NULL) {\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  parms <- c(\n"	pointer
)	O
;	O
ForAllVarwSep	function
(	O
pfile	pointer
,	O
pvmGlo	pointer
,	O
&	O
WriteOne_R_PSDecl	function
,	O
ID_PARM	int
,	O
NULL	O
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  )\n\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  if (!is.null(newParms)) {\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"    if (!all(names(newParms) %%in%% c(names(parms)))) {\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"      stop(\"illegal parameter name\")\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"    }\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"    parms[names(newParms)] <- newParms\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  }\n\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  parms <- within(as.list(parms), {\n"	pointer
)	O
;	O
ForAllVarwSep	function
(	O
pfile	pointer
,	O
pvmGlo	pointer
,	O
&	O
WriteOne_R_ParmInit	function
,	O
ID_PARM	int
,	O
NULL	O
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  })\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  out <- .C(\"getParms\",  as.double(parms),\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"            out=double(length(parms)),\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"            as.integer(length(parms)))$out\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  names(out) <- names(parms)\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  out\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"}\n\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"Outputs <- c(\n"	pointer
)	O
;	O
ForAllVarwSep	function
(	O
pfile	pointer
,	O
pvmGlo	pointer
,	O
&	O
WriteOneOutputName	function
,	O
ID_OUTPUT	int
,	O
NULL	O
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
")\n\n"	pointer
)	O
;	O
bForInits	int
=	O
TRUE	int
;	O
fprintf	function
(	O
pfile	pointer
,	O
"initStates <- function(parms, newStates = NULL)"	pointer
" {\n  Y <- c(\n"	pointer
)	O
;	O
ForAllVarwSep	function
(	O
pfile	pointer
,	O
pvmGlo	pointer
,	O
&	O
WriteOne_R_PSDecl	function
,	O
ID_STATE	int
,	O
NULL	O
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  )\n\n"	pointer
)	O
;	O
if	O
(	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmScale	pointer
,	O
NULL	O
,	O
ID_STATE	int
,	O
NULL	O
)	O
||	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmScale	pointer
,	O
NULL	O
,	O
ID_INLINE	int
,	O
NULL	O
)	O
)	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
"  Y <- within(c(as.list(parms),as.list(Y)), {"	pointer
)	O
;	O
Write_R_State_Scale	function
(	O
pfile	pointer
,	O
pvmScale	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"\n  })$Y\n\n"	pointer
)	O
;	O
}	O
fprintf	function
(	O
pfile	pointer
,	O
"  if (!is.null(newStates)) {\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"    if (!all(names(newStates) %%in%% c(names(Y)))) {\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"      stop(\"illegal state variable name in newStates\")\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"    }\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"    Y[names(newStates)] <- newStates\n  }\n\n"	pointer
)	O
;	O
if	O
(	O
bDelay	int
)	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
".C(\"initState\", as.double(Y));\n"	pointer
)	O
;	O
}	O
fprintf	function
(	O
pfile	pointer
,	O
"Y\n}\n"	pointer
)	O
;	O
bForInits	int
=	O
FALSE	int
;	O
}	O
void	O
Write_R_Decls	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvmGlo	pointer
)	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
"\n/* Model variables: States */\n"	pointer
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmGlo	pointer
,	O
&	O
WriteOne_R_SODefine	function
,	O
ID_STATE	int
,	O
NULL	O
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"\n/* Model variables: Outputs */\n"	pointer
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmGlo	pointer
,	O
&	O
WriteOne_R_SODefine	function
,	O
ID_OUTPUT	int
,	O
NULL	O
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"\n/* Parameters */\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"static double parms[%d];\n\n"	pointer
,	O
vnParms	int
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmGlo	pointer
,	O
&	O
WriteOne_R_PIDefine	function
,	O
ID_PARM	int
,	O
NULL	O
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"\n/* Forcing (Input) functions */\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"static double forc[%d];\n\n"	pointer
,	O
vnInputs	int
)	O
;	O
ForAllVar	function
(	O
pfile	pointer
,	O
pvmGlo	pointer
,	O
&	O
WriteOne_R_PIDefine	function
,	O
ID_INPUT	int
,	O
NULL	O
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"\n"	pointer
)	O
;	O
if	O
(	O
bDelay	int
)	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
"/* Function definitions for delay differential "	pointer
"equations */\n\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"int Nout=1;\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"int nr[1]={0};\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"double ytau[1] = {0.0};\n\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"static double yini[%d] = {"	pointer
,	O
vnStates	int
)	O
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
vnStates	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
==	O
vnStates	int
)	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
"0.0"	pointer
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
"0.0, "	pointer
)	O
;	O
}	O
}	O
fprintf	function
(	O
pfile	pointer
,	O
"}; /*Array of initial state variables*/\n\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"void lagvalue(double T, int *nr, int N, double *ytau) "	pointer
"{\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  static void(*fun)(double, int*, int, double*) = NULL;"	pointer
"\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  if (fun == NULL)\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"    fun = (void(*)(double, int*, int, double*))"	pointer
"R_GetCCallable(\"deSolve\", \"lagvalue\");\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  return fun(T, nr, N, ytau);\n}\n\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"double CalcDelay(int hvar, double dTime, double delay) {"	pointer
"\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  double T = dTime-delay;\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  if (dTime > delay){\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"    nr[0] = hvar;\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"    lagvalue( T, nr, Nout, ytau );\n}\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  else{\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"    ytau[0] = yini[hvar];\n}\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"  return(ytau[0]);\n}\n\n"	pointer
)	O
;	O
}	O
}	O
void	O
Write_R_Includes	function
(	O
PFILE	pointer
pfile	pointer
)	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
"#include <R.h>\n"	pointer
)	O
;	O
if	O
(	O
bDelay	int
)	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
"#include <Rinternals.h>\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"#include <Rdefines.h>\n"	pointer
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"#include <R_ext/Rdynload.h>\n"	pointer
)	O
;	O
}	O
}	O
void	O
Write_R_Model	function
(	O
PINPUTINFO	pointer
pinfo	pointer
,	O
PSTR	pointer
szFileOut	pointer
)	O
{	O
static	O
PSTRLEX	array
vszModified_Title	array
;	O
PFILE	pointer
pfile	pointer
;	O
PSTR	pointer
Rfile	pointer
;	O
PSTR	pointer
Rappend	pointer
=	O
"_inits.R"	pointer
;	O
size_t	long
nRout	long
,	O
nbase	long
;	O
char	O
*	O
lastdot	pointer
;	O
bForR	int
=	O
TRUE	int
;	O
if	O
(	O
!	O
pinfo	pointer
->	O
pvmGloVars	pointer
||	O
(	O
!	O
pinfo	pointer
->	O
pvmDynEqns	pointer
&&	O
!	O
pinfo	pointer
->	O
pvmCalcOutEqns	pointer
)	O
)	O
{	O
printf	function
(	O
"Error: No Dynamics, outputs or global variables defined\n"	pointer
)	O
;	O
return	O
;	O
}	O
ReversePointers	function
(	O
&	O
pinfo	pointer
->	O
pvmGloVars	pointer
)	O
;	O
ReversePointers	function
(	O
&	O
pinfo	pointer
->	O
pvmDynEqns	pointer
)	O
;	O
ReversePointers	function
(	O
&	O
pinfo	pointer
->	O
pvmScaleEqns	pointer
)	O
;	O
ReversePointers	function
(	O
&	O
pinfo	pointer
->	O
pvmCalcOutEqns	pointer
)	O
;	O
ReversePointers	function
(	O
&	O
pinfo	pointer
->	O
pvmJacobEqns	pointer
)	O
;	O
ReversePointers	function
(	O
&	O
pinfo	pointer
->	O
pvmEventEqns	pointer
)	O
;	O
ReversePointers	function
(	O
&	O
pinfo	pointer
->	O
pvmRootEqns	pointer
)	O
;	O
vpvmGloVarList	pointer
=	O
pinfo	pointer
->	O
pvmGloVars	pointer
;	O
IndexVariables	function
(	O
pinfo	pointer
->	O
pvmGloVars	pointer
)	O
;	O
AdjustVarHandles	function
(	O
pinfo	pointer
->	O
pvmGloVars	pointer
)	O
;	O
VerifyEqns	function
(	O
pinfo	pointer
->	O
pvmGloVars	pointer
,	O
pinfo	pointer
->	O
pvmDynEqns	pointer
)	O
;	O
VerifyOutputEqns	function
(	O
pinfo	pointer
)	O
;	O
pfile	pointer
=	O
fopen	function
(	O
szFileOut	pointer
,	O
"w"	pointer
)	O
;	O
if	O
(	O
pfile	pointer
)	O
{	O
vszModelFilename	pointer
=	O
pinfo	pointer
->	O
szInputFilename	pointer
;	O
vszModGenName	pointer
=	O
pinfo	pointer
->	O
szModGenName	pointer
;	O
sprintf	function
(	O
vszModified_Title	array
,	O
"%s %s"	pointer
,	O
szFileOut	pointer
,	O
"for R deSolve package"	pointer
)	O
;	O
WriteHeader	function
(	O
pfile	pointer
,	O
vszModified_Title	array
,	O
pinfo	pointer
->	O
pvmGloVars	pointer
)	O
;	O
Write_R_Includes	function
(	O
pfile	pointer
)	O
;	O
Write_R_Decls	function
(	O
pfile	pointer
,	O
pinfo	pointer
->	O
pvmGloVars	pointer
)	O
;	O
Write_R_InitModel	function
(	O
pfile	pointer
,	O
pinfo	pointer
->	O
pvmGloVars	pointer
)	O
;	O
Write_R_Scale	function
(	O
pfile	pointer
,	O
pinfo	pointer
->	O
pvmGloVars	pointer
,	O
pinfo	pointer
->	O
pvmScaleEqns	pointer
)	O
;	O
Write_R_CalcDeriv	function
(	O
pfile	pointer
,	O
pinfo	pointer
->	O
pvmGloVars	pointer
,	O
pinfo	pointer
->	O
pvmDynEqns	pointer
,	O
pinfo	pointer
->	O
pvmCalcOutEqns	pointer
)	O
;	O
Write_R_CalcJacob	function
(	O
pfile	pointer
,	O
pinfo	pointer
->	O
pvmGloVars	pointer
,	O
pinfo	pointer
->	O
pvmJacobEqns	pointer
)	O
;	O
Write_R_Events	function
(	O
pfile	pointer
,	O
pinfo	pointer
->	O
pvmGloVars	pointer
,	O
pinfo	pointer
->	O
pvmEventEqns	pointer
)	O
;	O
Write_R_Roots	function
(	O
pfile	pointer
,	O
pinfo	pointer
->	O
pvmGloVars	pointer
,	O
pinfo	pointer
->	O
pvmRootEqns	pointer
)	O
;	O
fclose	function
(	O
pfile	pointer
)	O
;	O
printf	function
(	O
"\n* Created C model file '%s'.\n\n"	pointer
,	O
szFileOut	pointer
)	O
;	O
}	O
else	O
ReportError	function
(	O
NULL	O
,	O
RE_CANNOTOPEN	int
|	O
RE_FATAL	int
,	O
szFileOut	pointer
,	O
"in Write_R_Model ()"	pointer
)	O
;	O
lastdot	pointer
=	O
strrchr	function
(	O
szFileOut	pointer
,	O
'.'	O
)	O
;	O
if	O
(	O
lastdot	pointer
!=	O
NULL	O
)	O
*	O
lastdot	pointer
=	O
'\0'	O
;	O
nbase	long
=	O
strlen	function
(	O
szFileOut	pointer
)	O
;	O
nRout	long
=	O
nbase	long
+	O
strlen	function
(	O
Rappend	pointer
)	O
+	O
1	int
;	O
Rfile	pointer
=	O
(	O
PSTR	pointer
)	O
malloc	function
(	O
nRout	long
)	O
;	O
Rfile	pointer
=	O
strncpy	function
(	O
Rfile	pointer
,	O
szFileOut	pointer
,	O
nbase	long
)	O
;	O
Rfile	pointer
[	O
nbase	long
]	O
=	O
'\0'	O
;	O
Rfile	pointer
=	O
strcat	function
(	O
Rfile	pointer
,	O
Rappend	pointer
)	O
;	O
pfile	pointer
=	O
fopen	function
(	O
Rfile	pointer
,	O
"w"	pointer
)	O
;	O
if	O
(	O
pfile	pointer
)	O
{	O
Write_R_InitPOS	function
(	O
pfile	pointer
,	O
pinfo	pointer
->	O
pvmGloVars	pointer
,	O
pinfo	pointer
->	O
pvmScaleEqns	pointer
)	O
;	O
fclose	function
(	O
pfile	pointer
)	O
;	O
printf	function
(	O
"\n* Created R parameter initialization file '%s'.\n\n"	pointer
,	O
Rfile	pointer
)	O
;	O
}	O
else	O
ReportError	function
(	O
NULL	O
,	O
RE_CANNOTOPEN	int
|	O
RE_FATAL	int
,	O
Rfile	pointer
,	O
"in Write_R_Model ()"	pointer
)	O
;	O
free	function
(	O
Rfile	pointer
)	O
;	O
}	O
