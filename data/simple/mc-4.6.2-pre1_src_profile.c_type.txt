enum	O
{	O
FirstBrace	int
,	O
OnSecHeader	int
,	O
IgnoreToEOL	int
,	O
KeyDef	int
,	O
KeyDefOnKey	int
,	O
KeyValue	int
}	O
;	O
typedef	O
struct	O
TKeys	struct
{	O
char	O
*	O
KeyName	pointer
;	O
char	O
*	O
Value	pointer
;	O
struct	O
TKeys	struct
*	O
link	function
;	O
}	O
TKeys	struct
;	O
typedef	O
struct	O
TSecHeader	struct
{	O
char	O
*	O
AppName	pointer
;	O
TKeys	struct
*	O
Keys	pointer
;	O
struct	O
TSecHeader	struct
*	O
link	function
;	O
}	O
TSecHeader	struct
;	O
typedef	O
struct	O
TProfile	struct
{	O
char	O
*	O
FileName	pointer
;	O
TSecHeader	struct
*	O
Section	pointer
;	O
struct	O
TProfile	struct
*	O
link	function
;	O
}	O
TProfile	struct
;	O
static	O
TProfile	struct
*	O
Base	pointer
=	O
0	int
;	O
static	O
TProfile	struct
*	O
find_loaded	function
(	O
const	O
char	O
*	O
FileName	pointer
,	O
TSecHeader	struct
*	O
*	O
section	pointer
)	O
{	O
TProfile	struct
*	O
p	pointer
=	O
Base	pointer
;	O
while	O
(	O
p	pointer
)	O
{	O
if	O
(	O
!	O
g_strcasecmp	function
(	O
FileName	pointer
,	O
p	pointer
->	O
FileName	pointer
)	O
)	O
{	O
*	O
section	pointer
=	O
p	pointer
->	O
Section	pointer
;	O
return	O
p	pointer
;	O
}	O
p	pointer
=	O
p	pointer
->	O
link	function
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
char	O
*	O
str_untranslate_newline_dup	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
l	int
=	O
0	int
;	O
char	O
*	O
p	pointer
=	O
s	pointer
,	O
*	O
q	pointer
;	O
g_return_val_if_fail	O
(	O
s	pointer
,	O
NULL	O
)	O
;	O
while	O
(	O
*	O
p	pointer
)	O
{	O
l	int
++	O
;	O
l	int
+=	O
(	O
*	O
p	pointer
==	O
'\n'	O
||	O
*	O
p	pointer
==	O
TRANSLATION_CHAR	char
)	O
;	O
p	pointer
++	O
;	O
}	O
q	pointer
=	O
p	pointer
=	O
g_malloc	function
(	O
l	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
q	pointer
)	O
return	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
switch	O
(	O
*	O
s	pointer
)	O
{	O
case	O
'\n'	O
:	O
*	O
p	pointer
++	O
=	O
TRANSLATION_CHAR	char
;	O
*	O
p	pointer
++	O
=	O
'n'	O
;	O
break	O
;	O
case	O
TRANSLATION_CHAR	char
:	O
if	O
(	O
s	pointer
[	O
1	int
]	O
==	O
'n'	O
||	O
s	pointer
[	O
1	int
]	O
==	O
TRANSLATION_CHAR	char
)	O
*	O
p	pointer
++	O
=	O
TRANSLATION_CHAR	char
;	O
*	O
p	pointer
++	O
=	O
TRANSLATION_CHAR	char
;	O
break	O
;	O
case	O
'\0'	O
:	O
*	O
p	pointer
=	O
'\0'	O
;	O
return	O
q	pointer
;	O
break	O
;	O
default	O
:	O
*	O
p	pointer
++	O
=	O
*	O
s	pointer
;	O
}	O
s	pointer
++	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
str_translate_newline_dup	function
(	O
char	O
*	O
s	pointer
)	O
{	O
char	O
*	O
p	pointer
,	O
*	O
q	pointer
;	O
g_return_val_if_fail	O
(	O
s	pointer
,	O
NULL	O
)	O
;	O
q	pointer
=	O
p	pointer
=	O
g_malloc	function
(	O
strlen	function
(	O
s	pointer
)	O
+	O
1	int
)	O
;	O
if	O
(	O
!	O
q	pointer
)	O
return	O
0	int
;	O
while	O
(	O
*	O
s	pointer
)	O
{	O
if	O
(	O
*	O
s	pointer
==	O
TRANSLATION_CHAR	char
)	O
{	O
switch	O
(	O
*	O
(	O
++	O
s	pointer
)	O
)	O
{	O
case	O
'n'	O
:	O
*	O
p	pointer
++	O
=	O
'\n'	O
;	O
break	O
;	O
case	O
TRANSLATION_CHAR	char
:	O
*	O
p	pointer
++	O
=	O
TRANSLATION_CHAR	char
;	O
break	O
;	O
case	O
'\0'	O
:	O
*	O
p	pointer
++	O
=	O
TRANSLATION_CHAR	char
;	O
*	O
p	pointer
++	O
=	O
'\0'	O
;	O
return	O
q	pointer
;	O
default	O
:	O
*	O
p	pointer
++	O
=	O
TRANSLATION_CHAR	char
;	O
*	O
p	pointer
++	O
=	O
*	O
s	pointer
;	O
}	O
}	O
else	O
{	O
*	O
p	pointer
++	O
=	O
*	O
s	pointer
;	O
}	O
s	pointer
++	O
;	O
}	O
*	O
p	pointer
=	O
'\0'	O
;	O
return	O
q	pointer
;	O
}	O
static	O
TSecHeader	struct
*	O
load	function
(	O
const	O
char	O
*	O
file	pointer
)	O
{	O
FILE	struct
*	O
f	pointer
;	O
int	O
state	pointer
;	O
TSecHeader	struct
*	O
SecHeader	pointer
=	O
0	int
;	O
char	O
CharBuffer	array
[	O
STRSIZE	int
]	O
;	O
char	O
*	O
next	pointer
=	O
NULL	O
;	O
int	O
c	int
;	O
if	O
(	O
(	O
f	pointer
=	O
fopen	function
(	O
file	pointer
,	O
"r"	pointer
)	O
)	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
state	pointer
=	O
FirstBrace	int
;	O
while	O
(	O
(	O
c	int
=	O
getc	function
(	O
f	pointer
)	O
)	O
!=	O
EOF	O
)	O
{	O
if	O
(	O
c	int
==	O
'\r'	O
)	O
continue	O
;	O
switch	O
(	O
state	pointer
)	O
{	O
case	O
OnSecHeader	int
:	O
if	O
(	O
c	int
==	O
']'	O
||	O
overflow	O
)	O
{	O
*	O
next	pointer
=	O
'\0'	O
;	O
next	pointer
=	O
CharBuffer	array
;	O
SecHeader	pointer
->	O
AppName	pointer
=	O
g_strdup	function
(	O
CharBuffer	array
)	O
;	O
state	pointer
=	O
IgnoreToEOL	int
;	O
}	O
else	O
*	O
next	pointer
++	O
=	O
c	int
;	O
break	O
;	O
case	O
IgnoreToEOL	int
:	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
{	O
state	pointer
=	O
KeyDef	int
;	O
next	pointer
=	O
CharBuffer	array
;	O
}	O
break	O
;	O
case	O
FirstBrace	int
:	O
case	O
KeyDef	int
:	O
case	O
KeyDefOnKey	int
:	O
if	O
(	O
c	int
==	O
'['	O
)	O
{	O
TSecHeader	struct
*	O
temp	pointer
;	O
temp	pointer
=	O
SecHeader	pointer
;	O
SecHeader	pointer
=	O
g_new	O
(	O
TSecHeader	struct
,	O
1	int
)	O
;	O
SecHeader	pointer
->	O
link	function
=	O
temp	pointer
;	O
SecHeader	pointer
->	O
Keys	pointer
=	O
0	int
;	O
state	pointer
=	O
OnSecHeader	int
;	O
next	pointer
=	O
CharBuffer	array
;	O
break	O
;	O
}	O
if	O
(	O
state	pointer
==	O
FirstBrace	int
)	O
break	O
;	O
if	O
(	O
(	O
c	int
==	O
' '	O
&&	O
state	pointer
!=	O
KeyDefOnKey	int
)	O
||	O
c	int
==	O
'\t'	O
)	O
break	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
||	O
overflow	O
)	O
{	O
next	pointer
=	O
CharBuffer	array
;	O
break	O
;	O
}	O
if	O
(	O
c	int
==	O
'='	O
||	O
overflow	O
)	O
{	O
TKeys	struct
*	O
temp	pointer
;	O
temp	pointer
=	O
SecHeader	pointer
->	O
Keys	pointer
;	O
*	O
next	pointer
=	O
'\0'	O
;	O
SecHeader	pointer
->	O
Keys	pointer
=	O
g_new	O
(	O
TKeys	struct
,	O
1	int
)	O
;	O
SecHeader	pointer
->	O
Keys	pointer
->	O
link	function
=	O
temp	pointer
;	O
SecHeader	pointer
->	O
Keys	pointer
->	O
KeyName	pointer
=	O
g_strdup	function
(	O
CharBuffer	array
)	O
;	O
state	pointer
=	O
KeyValue	int
;	O
next	pointer
=	O
CharBuffer	array
;	O
}	O
else	O
{	O
*	O
next	pointer
++	O
=	O
c	int
;	O
state	pointer
=	O
KeyDefOnKey	int
;	O
}	O
break	O
;	O
case	O
KeyValue	int
:	O
if	O
(	O
overflow	O
||	O
c	int
==	O
'\n'	O
)	O
{	O
*	O
next	pointer
=	O
'\0'	O
;	O
SecHeader	pointer
->	O
Keys	pointer
->	O
Value	pointer
=	O
str_translate_newline_dup	function
(	O
CharBuffer	array
)	O
;	O
state	pointer
=	O
c	int
==	O
'\n'	O
?	O
KeyDef	int
:	O
IgnoreToEOL	int
;	O
next	pointer
=	O
CharBuffer	array
;	O
}	O
else	O
*	O
next	pointer
++	O
=	O
c	int
;	O
break	O
;	O
}	O
}	O
switch	O
(	O
state	pointer
)	O
{	O
case	O
KeyValue	int
:	O
*	O
next	pointer
=	O
'\0'	O
;	O
SecHeader	pointer
->	O
Keys	pointer
->	O
Value	pointer
=	O
str_translate_newline_dup	function
(	O
CharBuffer	array
)	O
;	O
break	O
;	O
case	O
OnSecHeader	int
:	O
{	O
TSecHeader	struct
*	O
link	function
=	O
SecHeader	pointer
->	O
link	function
;	O
g_free	function
(	O
SecHeader	pointer
)	O
;	O
SecHeader	pointer
=	O
link	function
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Warning: Corrupted initialization file `%s'\n"	pointer
,	O
file	pointer
)	O
;	O
break	O
;	O
}	O
}	O
fclose	function
(	O
f	pointer
)	O
;	O
return	O
SecHeader	pointer
;	O
}	O
static	O
void	O
new_key	function
(	O
TSecHeader	struct
*	O
section	pointer
,	O
const	O
char	O
*	O
KeyName	pointer
,	O
const	O
char	O
*	O
Value	pointer
)	O
{	O
TKeys	struct
*	O
key	pointer
;	O
key	pointer
=	O
g_new	O
(	O
TKeys	struct
,	O
1	int
)	O
;	O
key	pointer
->	O
KeyName	pointer
=	O
g_strdup	function
(	O
KeyName	pointer
)	O
;	O
key	pointer
->	O
Value	pointer
=	O
g_strdup	function
(	O
Value	pointer
)	O
;	O
key	pointer
->	O
link	function
=	O
section	pointer
->	O
Keys	pointer
;	O
section	pointer
->	O
Keys	pointer
=	O
key	pointer
;	O
}	O
static	O
const	O
char	O
*	O
GetSetProfileChar	function
(	O
int	O
set	int
,	O
const	O
char	O
*	O
AppName	pointer
,	O
const	O
char	O
*	O
KeyName	pointer
,	O
const	O
char	O
*	O
Default	pointer
,	O
const	O
char	O
*	O
FileName	pointer
)	O
{	O
TProfile	struct
*	O
Current	pointer
;	O
TSecHeader	struct
*	O
section	pointer
;	O
TKeys	struct
*	O
key	pointer
;	O
Current	pointer
=	O
find_loaded	function
(	O
FileName	pointer
,	O
&	O
section	pointer
)	O
;	O
if	O
(	O
!	O
Current	pointer
)	O
{	O
Current	pointer
=	O
g_new	O
(	O
TProfile	struct
,	O
1	int
)	O
;	O
Current	pointer
->	O
link	function
=	O
Base	pointer
;	O
Current	pointer
->	O
FileName	pointer
=	O
g_strdup	function
(	O
FileName	pointer
)	O
;	O
Current	pointer
->	O
Section	pointer
=	O
load	function
(	O
FileName	pointer
)	O
;	O
Base	pointer
=	O
Current	pointer
;	O
section	pointer
=	O
Current	pointer
->	O
Section	pointer
;	O
}	O
for	O
(	O
;	O
section	pointer
;	O
section	pointer
=	O
section	pointer
->	O
link	function
)	O
{	O
if	O
(	O
section	pointer
->	O
AppName	pointer
==	O
0	int
||	O
g_strcasecmp	function
(	O
section	pointer
->	O
AppName	pointer
,	O
AppName	pointer
)	O
)	O
continue	O
;	O
for	O
(	O
key	pointer
=	O
section	pointer
->	O
Keys	pointer
;	O
key	pointer
;	O
key	pointer
=	O
key	pointer
->	O
link	function
)	O
{	O
if	O
(	O
g_strcasecmp	function
(	O
key	pointer
->	O
KeyName	pointer
,	O
KeyName	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
set	int
)	O
{	O
g_free	function
(	O
key	pointer
->	O
Value	pointer
)	O
;	O
key	pointer
->	O
Value	pointer
=	O
g_strdup	function
(	O
Default	pointer
)	O
;	O
}	O
return	O
key	pointer
->	O
Value	pointer
;	O
}	O
if	O
(	O
set	int
)	O
{	O
new_key	function
(	O
section	pointer
,	O
KeyName	pointer
,	O
Default	pointer
)	O
;	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
set	int
&&	O
Default	pointer
)	O
{	O
section	pointer
=	O
g_new	O
(	O
TSecHeader	struct
,	O
1	int
)	O
;	O
section	pointer
->	O
AppName	pointer
=	O
g_strdup	function
(	O
AppName	pointer
)	O
;	O
section	pointer
->	O
Keys	pointer
=	O
0	int
;	O
new_key	function
(	O
section	pointer
,	O
KeyName	pointer
,	O
Default	pointer
)	O
;	O
section	pointer
->	O
link	function
=	O
Current	pointer
->	O
Section	pointer
;	O
Current	pointer
->	O
Section	pointer
=	O
section	pointer
;	O
}	O
return	O
Default	pointer
;	O
}	O
static	O
short	O
GetSetProfile	function
(	O
int	O
set	int
,	O
const	O
char	O
*	O
AppName	pointer
,	O
const	O
char	O
*	O
KeyName	pointer
,	O
const	O
char	O
*	O
Default	pointer
,	O
char	O
*	O
ReturnedString	pointer
,	O
short	O
Size	short
,	O
const	O
char	O
*	O
FileName	pointer
)	O
{	O
const	O
char	O
*	O
s	pointer
;	O
s	pointer
=	O
GetSetProfileChar	function
(	O
set	int
,	O
AppName	pointer
,	O
KeyName	pointer
,	O
Default	pointer
,	O
FileName	pointer
)	O
;	O
if	O
(	O
!	O
set	int
)	O
g_strlcpy	function
(	O
ReturnedString	pointer
,	O
s	pointer
,	O
Size	short
)	O
;	O
return	O
1	int
;	O
}	O
short	O
GetPrivateProfileString	function
(	O
const	O
char	O
*	O
AppName	pointer
,	O
const	O
char	O
*	O
KeyName	pointer
,	O
const	O
char	O
*	O
Default	pointer
,	O
char	O
*	O
ReturnedString	pointer
,	O
short	O
Size	short
,	O
const	O
char	O
*	O
FileName	pointer
)	O
{	O
return	O
(	O
GetSetProfile	function
(	O
0	int
,	O
AppName	pointer
,	O
KeyName	pointer
,	O
Default	pointer
,	O
ReturnedString	pointer
,	O
Size	short
,	O
FileName	pointer
)	O
)	O
;	O
}	O
const	O
char	O
*	O
get_profile_string	function
(	O
const	O
char	O
*	O
AppName	pointer
,	O
const	O
char	O
*	O
KeyName	pointer
,	O
const	O
char	O
*	O
Default	pointer
,	O
const	O
char	O
*	O
FileName	pointer
)	O
{	O
return	O
GetSetProfileChar	function
(	O
0	int
,	O
AppName	pointer
,	O
KeyName	pointer
,	O
Default	pointer
,	O
FileName	pointer
)	O
;	O
}	O
int	O
GetPrivateProfileInt	function
(	O
const	O
char	O
*	O
AppName	pointer
,	O
const	O
char	O
*	O
KeyName	pointer
,	O
int	O
Default	pointer
,	O
const	O
char	O
*	O
File	pointer
)	O
{	O
char	O
IntBuf	array
[	O
BUF_TINY	int
]	O
;	O
char	O
buf	pointer
[	O
BUF_TINY	int
]	O
;	O
g_snprintf	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
"%d"	pointer
,	O
Default	pointer
)	O
;	O
GetPrivateProfileString	function
(	O
AppName	pointer
,	O
KeyName	pointer
,	O
buf	pointer
,	O
IntBuf	array
,	O
BUF_TINY	int
,	O
File	pointer
)	O
;	O
if	O
(	O
!	O
g_strcasecmp	function
(	O
IntBuf	array
,	O
"true"	pointer
)	O
)	O
return	O
1	int
;	O
if	O
(	O
!	O
g_strcasecmp	function
(	O
IntBuf	array
,	O
"yes"	pointer
)	O
)	O
return	O
1	int
;	O
return	O
(	O
int	O
)	O
atol	function
(	O
IntBuf	array
)	O
;	O
}	O
int	O
WritePrivateProfileString	function
(	O
const	O
char	O
*	O
AppName	pointer
,	O
const	O
char	O
*	O
KeyName	pointer
,	O
const	O
char	O
*	O
String	pointer
,	O
const	O
char	O
*	O
FileName	pointer
)	O
{	O
return	O
GetSetProfile	function
(	O
1	int
,	O
AppName	pointer
,	O
KeyName	pointer
,	O
String	pointer
,	O
NULL	O
,	O
0	int
,	O
FileName	pointer
)	O
;	O
}	O
static	O
void	O
dump_keys	function
(	O
FILE	struct
*	O
profile	pointer
,	O
TKeys	struct
*	O
p	pointer
)	O
{	O
char	O
*	O
t	long
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
;	O
dump_keys	function
(	O
profile	pointer
,	O
p	pointer
->	O
link	function
)	O
;	O
t	long
=	O
str_untranslate_newline_dup	function
(	O
p	pointer
->	O
Value	pointer
)	O
;	O
fprintf	function
(	O
profile	pointer
,	O
"%s=%s\n"	pointer
,	O
p	pointer
->	O
KeyName	pointer
,	O
t	long
)	O
;	O
g_free	function
(	O
t	long
)	O
;	O
}	O
static	O
void	O
dump_sections	function
(	O
FILE	struct
*	O
profile	pointer
,	O
TSecHeader	struct
*	O
p	pointer
)	O
{	O
if	O
(	O
!	O
p	pointer
)	O
return	O
;	O
dump_sections	function
(	O
profile	pointer
,	O
p	pointer
->	O
link	function
)	O
;	O
if	O
(	O
p	pointer
->	O
AppName	pointer
[	O
0	int
]	O
)	O
{	O
fprintf	function
(	O
profile	pointer
,	O
"\n[%s]\n"	pointer
,	O
p	pointer
->	O
AppName	pointer
)	O
;	O
dump_keys	function
(	O
profile	pointer
,	O
p	pointer
->	O
Keys	pointer
)	O
;	O
}	O
}	O
static	O
void	O
dump_profile	function
(	O
TProfile	struct
*	O
p	pointer
)	O
{	O
FILE	struct
*	O
profile	pointer
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
;	O
dump_profile	function
(	O
p	pointer
->	O
link	function
)	O
;	O
if	O
(	O
p	pointer
->	O
FileName	pointer
[	O
0	int
]	O
!=	O
(	O
char	O
)	O
0	int
)	O
if	O
(	O
(	O
profile	pointer
=	O
fopen	function
(	O
p	pointer
->	O
FileName	pointer
,	O
"w"	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
dump_sections	function
(	O
profile	pointer
,	O
p	pointer
->	O
Section	pointer
)	O
;	O
fclose	function
(	O
profile	pointer
)	O
;	O
}	O
}	O
void	O
sync_profiles	function
(	O
void	O
)	O
{	O
dump_profile	function
(	O
Base	pointer
)	O
;	O
}	O
static	O
void	O
free_keys	function
(	O
TKeys	struct
*	O
p	pointer
)	O
{	O
if	O
(	O
!	O
p	pointer
)	O
return	O
;	O
free_keys	function
(	O
p	pointer
->	O
link	function
)	O
;	O
g_free	function
(	O
p	pointer
->	O
KeyName	pointer
)	O
;	O
g_free	function
(	O
p	pointer
->	O
Value	pointer
)	O
;	O
g_free	function
(	O
p	pointer
)	O
;	O
}	O
static	O
void	O
free_sections	function
(	O
TSecHeader	struct
*	O
p	pointer
)	O
{	O
if	O
(	O
!	O
p	pointer
)	O
return	O
;	O
free_sections	function
(	O
p	pointer
->	O
link	function
)	O
;	O
free_keys	function
(	O
p	pointer
->	O
Keys	pointer
)	O
;	O
g_free	function
(	O
p	pointer
->	O
AppName	pointer
)	O
;	O
p	pointer
->	O
link	function
=	O
0	int
;	O
p	pointer
->	O
Keys	pointer
=	O
0	int
;	O
g_free	function
(	O
p	pointer
)	O
;	O
}	O
static	O
void	O
free_profile	function
(	O
TProfile	struct
*	O
p	pointer
)	O
{	O
if	O
(	O
!	O
p	pointer
)	O
return	O
;	O
free_profile	function
(	O
p	pointer
->	O
link	function
)	O
;	O
free_sections	function
(	O
p	pointer
->	O
Section	pointer
)	O
;	O
g_free	function
(	O
p	pointer
->	O
FileName	pointer
)	O
;	O
g_free	function
(	O
p	pointer
)	O
;	O
}	O
void	O
free_profile_name	function
(	O
const	O
char	O
*	O
s	pointer
)	O
{	O
TProfile	struct
*	O
p	pointer
;	O
if	O
(	O
!	O
s	pointer
)	O
return	O
;	O
for	O
(	O
p	pointer
=	O
Base	pointer
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
link	function
)	O
{	O
if	O
(	O
strcmp	function
(	O
s	pointer
,	O
p	pointer
->	O
FileName	pointer
)	O
==	O
0	int
)	O
{	O
free_sections	function
(	O
p	pointer
->	O
Section	pointer
)	O
;	O
p	pointer
->	O
Section	pointer
=	O
0	int
;	O
p	pointer
->	O
FileName	pointer
[	O
0	int
]	O
=	O
0	int
;	O
return	O
;	O
}	O
}	O
}	O
void	O
free_profiles	function
(	O
void	O
)	O
{	O
free_profile	function
(	O
Base	pointer
)	O
;	O
}	O
void	O
*	O
profile_init_iterator	function
(	O
const	O
char	O
*	O
appname	pointer
,	O
const	O
char	O
*	O
file	pointer
)	O
{	O
TProfile	struct
*	O
Current	pointer
;	O
TSecHeader	struct
*	O
section	pointer
;	O
Current	pointer
=	O
find_loaded	function
(	O
file	pointer
,	O
&	O
section	pointer
)	O
;	O
if	O
(	O
!	O
Current	pointer
)	O
{	O
Current	pointer
=	O
g_new	O
(	O
TProfile	struct
,	O
1	int
)	O
;	O
Current	pointer
->	O
link	function
=	O
Base	pointer
;	O
Current	pointer
->	O
FileName	pointer
=	O
g_strdup	function
(	O
file	pointer
)	O
;	O
Current	pointer
->	O
Section	pointer
=	O
load	function
(	O
file	pointer
)	O
;	O
Base	pointer
=	O
Current	pointer
;	O
section	pointer
=	O
Current	pointer
->	O
Section	pointer
;	O
}	O
for	O
(	O
;	O
section	pointer
;	O
section	pointer
=	O
section	pointer
->	O
link	function
)	O
{	O
if	O
(	O
g_strcasecmp	function
(	O
section	pointer
->	O
AppName	pointer
,	O
appname	pointer
)	O
)	O
continue	O
;	O
return	O
section	pointer
->	O
Keys	pointer
;	O
}	O
return	O
0	int
;	O
}	O
void	O
*	O
profile_iterator_next	function
(	O
void	O
*	O
s	pointer
,	O
char	O
*	O
*	O
key	pointer
,	O
char	O
*	O
*	O
value	pointer
)	O
{	O
TKeys	struct
*	O
keys	pointer
=	O
(	O
TKeys	struct
*	O
)	O
s	pointer
;	O
if	O
(	O
keys	pointer
)	O
{	O
*	O
key	pointer
=	O
keys	pointer
->	O
KeyName	pointer
;	O
*	O
value	pointer
=	O
keys	pointer
->	O
Value	pointer
;	O
keys	pointer
=	O
keys	pointer
->	O
link	function
;	O
}	O
return	O
keys	pointer
;	O
}	O
void	O
profile_clean_section	function
(	O
const	O
char	O
*	O
appname	pointer
,	O
const	O
char	O
*	O
file	pointer
)	O
{	O
TSecHeader	struct
*	O
section	pointer
;	O
if	O
(	O
!	O
find_loaded	function
(	O
file	pointer
,	O
&	O
section	pointer
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Warning: profile_clean_section called before init\n"	pointer
)	O
;	O
return	O
;	O
}	O
for	O
(	O
;	O
section	pointer
;	O
section	pointer
=	O
section	pointer
->	O
link	function
)	O
{	O
if	O
(	O
g_strcasecmp	function
(	O
section	pointer
->	O
AppName	pointer
,	O
appname	pointer
)	O
)	O
continue	O
;	O
section	pointer
->	O
AppName	pointer
[	O
0	int
]	O
=	O
0	int
;	O
}	O
}	O
int	O
profile_has_section	function
(	O
const	O
char	O
*	O
section_name	pointer
,	O
const	O
char	O
*	O
profile	pointer
)	O
{	O
TSecHeader	struct
*	O
section	pointer
;	O
if	O
(	O
!	O
find_loaded	function
(	O
profile	pointer
,	O
&	O
section	pointer
)	O
)	O
{	O
return	O
0	int
;	O
}	O
for	O
(	O
;	O
section	pointer
;	O
section	pointer
=	O
section	pointer
->	O
link	function
)	O
{	O
if	O
(	O
g_strcasecmp	function
(	O
section	pointer
->	O
AppName	pointer
,	O
section_name	pointer
)	O
)	O
continue	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
profile_forget_profile	function
(	O
const	O
char	O
*	O
file	pointer
)	O
{	O
TProfile	struct
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
Base	pointer
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
link	function
)	O
{	O
if	O
(	O
g_strcasecmp	function
(	O
file	pointer
,	O
p	pointer
->	O
FileName	pointer
)	O
)	O
continue	O
;	O
p	pointer
->	O
FileName	pointer
[	O
0	int
]	O
=	O
0	int
;	O
}	O
}	O
