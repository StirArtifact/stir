static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: db_cam.c,v 1.3 2014/04/17 20:27:26 sebdiaz Exp $"	pointer
;	O
static	O
int	O
__db_c_cleanup	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
DBC	struct
*	O
,	O
int	O
)	O
)	O
;	O
static	O
int	O
__db_c_idup	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
DBC	struct
*	O
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
int	O
__db_wrlock_err	function
__P	O
(	O
(	O
DB_ENV	struct
*	O
)	O
)	O
;	O
int	O
CDB___db_c_close	function
(	O
dbc	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
DBC	struct
*	O
opd	pointer
;	O
DBC_INTERNAL	struct
*	O
cp	pointer
;	O
int	O
ret	int
,	O
t_ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
ret	int
=	O
0	int
;	O
PANIC_CHECK	O
(	O
dbp	pointer
->	O
dbenv	pointer
)	O
;	O
if	O
(	O
!	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_ACTIVE	int
)	O
)	O
{	O
if	O
(	O
dbp	pointer
&&	O
dbp	pointer
->	O
dbenv	pointer
)	O
CDB___db_err	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Closing closed cursor"	pointer
)	O
;	O
DB_ASSERT	O
(	O
0	int
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
cp	pointer
=	O
dbc	pointer
->	O
internal	pointer
;	O
opd	pointer
=	O
cp	pointer
->	O
opd	pointer
;	O
MUTEX_THREAD_LOCK	O
(	O
dbp	pointer
->	O
mutexp	pointer
)	O
;	O
if	O
(	O
opd	pointer
!=	O
NULL	O
)	O
{	O
F_CLR	O
(	O
opd	pointer
,	O
DBC_ACTIVE	int
)	O
;	O
TAILQ_REMOVE	O
(	O
&	O
dbp	pointer
->	O
active_queue	struct
,	O
opd	pointer
,	O
links	struct
)	O
;	O
}	O
F_CLR	O
(	O
dbc	pointer
,	O
DBC_ACTIVE	int
)	O
;	O
TAILQ_REMOVE	O
(	O
&	O
dbp	pointer
->	O
active_queue	struct
,	O
dbc	pointer
,	O
links	struct
)	O
;	O
MUTEX_THREAD_UNLOCK	O
(	O
dbp	pointer
->	O
mutexp	pointer
)	O
;	O
if	O
(	O
(	O
t_ret	int
=	O
dbc	pointer
->	O
c_am_close	pointer
(	O
dbc	pointer
,	O
PGNO_INVALID	int
,	O
NULL	O
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
LOCKING	O
(	O
dbc	pointer
->	O
dbp	pointer
->	O
dbenv	pointer
)	O
)	O
{	O
if	O
(	O
!	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_WRITEDUP	int
)	O
&&	O
dbc	pointer
->	O
mylock	struct
.	O
off	long
!=	O
LOCK_INVALID	O
)	O
{	O
if	O
(	O
(	O
t_ret	int
=	O
CDB_lock_put	function
(	O
dbc	pointer
->	O
dbp	pointer
->	O
dbenv	pointer
,	O
&	O
dbc	pointer
->	O
mylock	struct
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
dbc	pointer
->	O
mylock	struct
.	O
off	long
=	O
LOCK_INVALID	O
;	O
}	O
memset	function
(	O
&	O
dbc	pointer
->	O
mylock	struct
,	O
0	int
,	O
sizeof	O
(	O
dbc	pointer
->	O
mylock	struct
)	O
)	O
;	O
F_CLR	O
(	O
dbc	pointer
,	O
DBC_WRITEDUP	int
)	O
;	O
}	O
MUTEX_THREAD_LOCK	O
(	O
dbp	pointer
->	O
mutexp	pointer
)	O
;	O
if	O
(	O
opd	pointer
!=	O
NULL	O
)	O
{	O
TAILQ_INSERT_TAIL	O
(	O
&	O
dbp	pointer
->	O
free_queue	struct
,	O
opd	pointer
,	O
links	struct
)	O
;	O
opd	pointer
=	O
NULL	O
;	O
}	O
TAILQ_INSERT_TAIL	O
(	O
&	O
dbp	pointer
->	O
free_queue	struct
,	O
dbc	pointer
,	O
links	struct
)	O
;	O
MUTEX_THREAD_UNLOCK	O
(	O
dbp	pointer
->	O
mutexp	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___db_c_destroy	function
(	O
dbc	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
int	O
ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
MUTEX_THREAD_LOCK	O
(	O
dbp	pointer
->	O
mutexp	pointer
)	O
;	O
TAILQ_REMOVE	O
(	O
&	O
dbp	pointer
->	O
free_queue	struct
,	O
dbc	pointer
,	O
links	struct
)	O
;	O
MUTEX_THREAD_UNLOCK	O
(	O
dbp	pointer
->	O
mutexp	pointer
)	O
;	O
if	O
(	O
dbc	pointer
->	O
rkey	struct
.	O
data	pointer
!=	O
NULL	O
)	O
CDB___os_free	function
(	O
dbc	pointer
->	O
rkey	struct
.	O
data	pointer
,	O
dbc	pointer
->	O
rkey	struct
.	O
ulen	int
)	O
;	O
if	O
(	O
dbc	pointer
->	O
rdata	struct
.	O
data	pointer
!=	O
NULL	O
)	O
CDB___os_free	function
(	O
dbc	pointer
->	O
rdata	struct
.	O
data	pointer
,	O
dbc	pointer
->	O
rdata	struct
.	O
ulen	int
)	O
;	O
ret	int
=	O
dbc	pointer
->	O
c_am_destroy	pointer
==	O
NULL	O
?	O
0	int
:	O
dbc	pointer
->	O
c_am_destroy	pointer
(	O
dbc	pointer
)	O
;	O
CDB___os_free	function
(	O
dbc	pointer
,	O
sizeof	O
(	O
*	O
dbc	pointer
)	O
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___db_c_count	function
(	O
dbc	pointer
,	O
recnop	pointer
,	O
flags	int
)	O
DBC	struct
*	O
dbc	pointer
;	O
db_recno_t	int
*	O
recnop	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
int	O
ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
PANIC_CHECK	O
(	O
dbp	pointer
->	O
dbenv	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_ccountchk	function
(	O
dbp	pointer
,	O
flags	int
,	O
IS_INITIALIZED	O
(	O
dbc	pointer
)	O
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
switch	O
(	O
dbc	pointer
->	O
dbtype	enum
)	O
{	O
case	O
DB_QUEUE	int
:	O
case	O
DB_RECNO	int
:	O
*	O
recnop	pointer
=	O
1	int
;	O
break	O
;	O
case	O
DB_HASH	int
:	O
if	O
(	O
dbc	pointer
->	O
internal	pointer
->	O
opd	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_c_count	function
(	O
dbc	pointer
,	O
recnop	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
break	O
;	O
}	O
case	O
DB_BTREE	int
:	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_c_count	function
(	O
dbc	pointer
,	O
recnop	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
break	O
;	O
default	O
:	O
return	O
(	O
CDB___db_unknown_type	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"CDB___db_c_count"	pointer
,	O
dbp	pointer
->	O
type	enum
)	O
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___db_c_del	function
(	O
dbc	pointer
,	O
flags	int
)	O
DBC	struct
*	O
dbc	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
DBC	struct
*	O
opd	pointer
;	O
int	O
ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
PANIC_CHECK	O
(	O
dbp	pointer
->	O
dbenv	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_cdelchk	function
(	O
dbp	pointer
,	O
flags	int
,	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_RDONLY	int
)	O
,	O
IS_INITIALIZED	O
(	O
dbc	pointer
)	O
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
DEBUG_LWRITE	O
(	O
dbc	pointer
,	O
dbc	pointer
->	O
txn	pointer
,	O
"db_c_del"	pointer
,	O
NULL	O
,	O
NULL	O
,	O
flags	int
)	O
;	O
LOCKING_INIT	O
(	O
dbp	pointer
,	O
dbc	pointer
)	O
;	O
opd	pointer
=	O
dbc	pointer
->	O
internal	pointer
->	O
opd	pointer
;	O
if	O
(	O
opd	pointer
==	O
NULL	O
)	O
ret	int
=	O
dbc	pointer
->	O
c_am_del	pointer
(	O
dbc	pointer
)	O
;	O
else	O
if	O
(	O
(	O
ret	int
=	O
dbc	pointer
->	O
c_am_writelock	pointer
(	O
dbc	pointer
)	O
)	O
==	O
0	int
)	O
ret	int
=	O
opd	pointer
->	O
c_am_del	pointer
(	O
opd	pointer
)	O
;	O
LOCKING_DONE	O
(	O
dbp	pointer
,	O
dbc	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___db_c_dup	function
(	O
dbc_orig	pointer
,	O
dbcp	pointer
,	O
flags	int
)	O
DBC	struct
*	O
dbc_orig	pointer
;	O
DBC	struct
*	O
*	O
dbcp	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
DBC	struct
*	O
dbc_n	pointer
,	O
*	O
dbc_nopd	pointer
;	O
int	O
ret	int
;	O
dbp	pointer
=	O
dbc_orig	pointer
->	O
dbp	pointer
;	O
dbenv	pointer
=	O
dbp	pointer
->	O
dbenv	pointer
;	O
dbc_n	pointer
=	O
dbc_nopd	pointer
=	O
NULL	O
;	O
PANIC_CHECK	O
(	O
dbp	pointer
->	O
dbenv	pointer
)	O
;	O
if	O
(	O
flags	int
!=	O
DB_POSITIONI	int
&&	O
F_ISSET	O
(	O
dbc_orig	pointer
,	O
DBC_WRITER	int
|	O
DBC_WRITECURSOR	int
)	O
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"Cannot duplicate writeable cursor"	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
__db_c_idup	function
(	O
dbc_orig	pointer
,	O
&	O
dbc_n	pointer
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
*	O
dbcp	pointer
=	O
dbc_n	pointer
;	O
if	O
(	O
LOCKING	O
(	O
dbenv	pointer
)	O
&&	O
flags	int
!=	O
DB_POSITIONI	int
)	O
{	O
DB_ASSERT	O
(	O
!	O
F_ISSET	O
(	O
dbc_orig	pointer
,	O
DBC_WRITER	int
|	O
DBC_WRITECURSOR	int
)	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_lock_get	function
(	O
dbenv	pointer
,	O
dbc_n	pointer
->	O
locker	int
,	O
0	int
,	O
&	O
dbc_n	pointer
->	O
lock_dbt	struct
,	O
DB_LOCK_READ	int
,	O
&	O
dbc_n	pointer
->	O
mylock	struct
)	O
)	O
!=	O
0	int
)	O
{	O
(	O
void	O
)	O
CDB___db_c_close	function
(	O
dbc_n	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
}	O
if	O
(	O
dbc_orig	pointer
->	O
internal	pointer
->	O
opd	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
__db_c_idup	function
(	O
dbc_orig	pointer
->	O
internal	pointer
->	O
opd	pointer
,	O
&	O
dbc_nopd	pointer
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
dbc_n	pointer
->	O
internal	pointer
->	O
opd	pointer
=	O
dbc_nopd	pointer
;	O
}	O
return	O
(	O
0	int
)	O
;	O
err	pointer
:	O
if	O
(	O
dbc_n	pointer
!=	O
NULL	O
)	O
(	O
void	O
)	O
dbc_n	pointer
->	O
c_close	pointer
(	O
dbc_n	pointer
)	O
;	O
if	O
(	O
dbc_nopd	pointer
!=	O
NULL	O
)	O
(	O
void	O
)	O
dbc_nopd	pointer
->	O
c_close	pointer
(	O
dbc_nopd	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__db_c_idup	function
(	O
dbc_orig	pointer
,	O
dbcp	pointer
,	O
flags	int
)	O
DBC	struct
*	O
dbc_orig	pointer
,	O
*	O
*	O
dbcp	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
DBC	struct
*	O
dbc_n	pointer
;	O
DBC_INTERNAL	struct
*	O
int_n	pointer
,	O
*	O
int_orig	pointer
;	O
int	O
ret	int
;	O
dbp	pointer
=	O
dbc_orig	pointer
->	O
dbp	pointer
;	O
dbc_n	pointer
=	O
*	O
dbcp	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_icursor	function
(	O
dbp	pointer
,	O
dbc_orig	pointer
->	O
txn	pointer
,	O
dbc_orig	pointer
->	O
dbtype	enum
,	O
dbc_orig	pointer
->	O
internal	pointer
->	O
root	int
,	O
F_ISSET	O
(	O
dbc_orig	pointer
,	O
DBC_OPD	int
)	O
,	O
&	O
dbc_n	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
dbc_n	pointer
->	O
locker	int
=	O
dbc_orig	pointer
->	O
locker	int
;	O
if	O
(	O
flags	int
==	O
DB_POSITION	int
||	O
flags	int
==	O
DB_POSITIONI	int
)	O
{	O
int_n	pointer
=	O
dbc_n	pointer
->	O
internal	pointer
;	O
int_orig	pointer
=	O
dbc_orig	pointer
->	O
internal	pointer
;	O
dbc_n	pointer
->	O
flags	int
=	O
dbc_orig	pointer
->	O
flags	int
;	O
int_n	pointer
->	O
indx	short
=	O
int_orig	pointer
->	O
indx	short
;	O
int_n	pointer
->	O
pgno	int
=	O
int_orig	pointer
->	O
pgno	int
;	O
int_n	pointer
->	O
root	int
=	O
int_orig	pointer
->	O
root	int
;	O
switch	O
(	O
dbc_orig	pointer
->	O
dbtype	enum
)	O
{	O
case	O
DB_QUEUE	int
:	O
if	O
(	O
(	O
ret	int
=	O
CDB___qam_c_dup	function
(	O
dbc_orig	pointer
,	O
dbc_n	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
break	O
;	O
case	O
DB_BTREE	int
:	O
case	O
DB_RECNO	int
:	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_c_dup	function
(	O
dbc_orig	pointer
,	O
dbc_n	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
break	O
;	O
case	O
DB_HASH	int
:	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_c_dup	function
(	O
dbc_orig	pointer
,	O
dbc_n	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
break	O
;	O
default	O
:	O
ret	int
=	O
CDB___db_unknown_type	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"__db_c_idup"	pointer
,	O
dbc_orig	pointer
->	O
dbtype	enum
)	O
;	O
goto	O
err	pointer
;	O
}	O
}	O
*	O
dbcp	pointer
=	O
dbc_n	pointer
;	O
return	O
(	O
0	int
)	O
;	O
err	pointer
:	O
(	O
void	O
)	O
dbc_n	pointer
->	O
c_close	pointer
(	O
dbc_n	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___db_c_get	function
(	O
dbc_arg	pointer
,	O
key	struct
,	O
data	pointer
,	O
flags	int
)	O
DBC	struct
*	O
dbc_arg	pointer
;	O
DBT	struct
*	O
key	struct
,	O
*	O
data	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
DBC	struct
*	O
dbc	pointer
,	O
*	O
dbc_n	pointer
,	O
*	O
opd	pointer
;	O
DBC_INTERNAL	struct
*	O
cp	pointer
,	O
*	O
cp_n	pointer
;	O
db_pgno_t	int
pgno	int
;	O
u_int32_t	int
tmp_flags	int
,	O
tmp_rmw	int
;	O
u_int8_t	char
type	enum
;	O
int	O
ret	int
,	O
t_ret	int
;	O
dbp	pointer
=	O
dbc_arg	pointer
->	O
dbp	pointer
;	O
dbc_n	pointer
=	O
NULL	O
;	O
opd	pointer
=	O
NULL	O
;	O
PANIC_CHECK	O
(	O
dbp	pointer
->	O
dbenv	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_cgetchk	function
(	O
dbp	pointer
,	O
key	struct
,	O
data	pointer
,	O
flags	int
,	O
IS_INITIALIZED	O
(	O
dbc_arg	pointer
)	O
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
tmp_rmw	int
=	O
LF_ISSET	O
(	O
DB_RMW	int
)	O
;	O
LF_CLR	O
(	O
DB_RMW	int
)	O
;	O
DEBUG_LREAD	O
(	O
dbc_arg	pointer
,	O
dbc_arg	pointer
->	O
txn	pointer
,	O
"db_c_get"	pointer
,	O
flags	int
==	O
DB_SET	int
||	O
flags	int
==	O
DB_SET_RANGE	int
?	O
key	struct
:	O
NULL	O
,	O
NULL	O
,	O
flags	int
)	O
;	O
if	O
(	O
flags	int
==	O
DB_GET_RECNO	int
)	O
return	O
(	O
CDB___bam_c_rget	function
(	O
dbc_arg	pointer
,	O
data	pointer
,	O
flags	int
|	O
tmp_rmw	int
)	O
)	O
;	O
cp	pointer
=	O
dbc_arg	pointer
->	O
internal	pointer
;	O
if	O
(	O
cp	pointer
->	O
opd	pointer
!=	O
NULL	O
&&	O
(	O
flags	int
==	O
DB_CURRENT	int
||	O
flags	int
==	O
DB_GET_BOTHC	int
||	O
flags	int
==	O
DB_NEXT	int
||	O
flags	int
==	O
DB_NEXT_DUP	int
||	O
flags	int
==	O
DB_PREV	int
)	O
)	O
{	O
if	O
(	O
tmp_rmw	int
&&	O
(	O
ret	int
=	O
dbc_arg	pointer
->	O
c_am_writelock	pointer
(	O
dbc_arg	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
__db_c_idup	function
(	O
cp	pointer
->	O
opd	pointer
,	O
&	O
opd	pointer
,	O
DB_POSITIONI	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
LOCKING	O
(	O
dbp	pointer
->	O
dbenv	pointer
)	O
)	O
(	O
void	O
)	O
CDB___db_cdb_cdup	function
(	O
dbc_arg	pointer
,	O
opd	pointer
)	O
;	O
switch	O
(	O
ret	int
=	O
opd	pointer
->	O
c_am_get	pointer
(	O
opd	pointer
,	O
key	struct
,	O
data	pointer
,	O
flags	int
,	O
NULL	O
)	O
)	O
{	O
case	O
0	int
:	O
goto	O
done	O
;	O
case	O
DB_NOTFOUND	O
:	O
if	O
(	O
flags	int
==	O
DB_NEXT	int
||	O
flags	int
==	O
DB_PREV	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
opd	pointer
->	O
c_close	pointer
(	O
opd	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
opd	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
goto	O
err	pointer
;	O
default	O
:	O
goto	O
err	pointer
;	O
}	O
}	O
switch	O
(	O
flags	int
)	O
{	O
case	O
DB_CURRENT	int
:	O
case	O
DB_GET_BOTHC	int
:	O
case	O
DB_NEXT	int
:	O
case	O
DB_NEXT_DUP	int
:	O
case	O
DB_NEXT_NODUP	int
:	O
case	O
DB_PREV	int
:	O
case	O
DB_PREV_NODUP	int
:	O
tmp_flags	int
=	O
DB_POSITIONI	int
;	O
break	O
;	O
default	O
:	O
tmp_flags	int
=	O
0	int
;	O
break	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
__db_c_idup	function
(	O
dbc_arg	pointer
,	O
&	O
dbc_n	pointer
,	O
tmp_flags	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
LOCKING	O
(	O
dbp	pointer
->	O
dbenv	pointer
)	O
)	O
(	O
void	O
)	O
CDB___db_cdb_cdup	function
(	O
dbc_arg	pointer
,	O
dbc_n	pointer
)	O
;	O
if	O
(	O
tmp_rmw	int
)	O
F_SET	O
(	O
dbc_n	pointer
,	O
DBC_RMW	int
)	O
;	O
pgno	int
=	O
PGNO_INVALID	int
;	O
ret	int
=	O
dbc_n	pointer
->	O
c_am_get	pointer
(	O
dbc_n	pointer
,	O
key	struct
,	O
data	pointer
,	O
flags	int
,	O
&	O
pgno	int
)	O
;	O
if	O
(	O
tmp_rmw	int
)	O
F_CLR	O
(	O
dbc_n	pointer
,	O
DBC_RMW	int
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
goto	O
err	pointer
;	O
cp_n	pointer
=	O
dbc_n	pointer
->	O
internal	pointer
;	O
if	O
(	O
pgno	int
!=	O
PGNO_INVALID	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_icursor	function
(	O
dbp	pointer
,	O
dbc_arg	pointer
->	O
txn	pointer
,	O
dbp	pointer
->	O
dup_compare	pointer
==	O
NULL	O
?	O
DB_RECNO	int
:	O
DB_BTREE	int
,	O
pgno	int
,	O
1	int
,	O
&	O
cp_n	pointer
->	O
opd	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
switch	O
(	O
flags	int
)	O
{	O
case	O
DB_FIRST	int
:	O
case	O
DB_NEXT	int
:	O
case	O
DB_NEXT_NODUP	int
:	O
case	O
DB_SET	int
:	O
case	O
DB_SET_RECNO	int
:	O
case	O
DB_SET_RANGE	int
:	O
tmp_flags	int
=	O
DB_FIRST	int
;	O
break	O
;	O
case	O
DB_LAST	int
:	O
case	O
DB_PREV	int
:	O
case	O
DB_PREV_NODUP	int
:	O
tmp_flags	int
=	O
DB_LAST	int
;	O
break	O
;	O
case	O
DB_GET_BOTH	int
:	O
tmp_flags	int
=	O
DB_GET_BOTH	int
;	O
break	O
;	O
case	O
DB_GET_BOTHC	int
:	O
tmp_flags	int
=	O
DB_GET_BOTHC	int
;	O
break	O
;	O
default	O
:	O
ret	int
=	O
CDB___db_unknown_flag	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"CDB___db_c_get"	pointer
,	O
flags	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
cp_n	pointer
->	O
opd	pointer
->	O
c_am_get	pointer
(	O
cp_n	pointer
->	O
opd	pointer
,	O
key	struct
,	O
data	pointer
,	O
tmp_flags	int
,	O
NULL	O
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
done	O
:	O
cp_n	pointer
=	O
dbc_n	pointer
==	O
NULL	O
?	O
dbc_arg	pointer
->	O
internal	pointer
:	O
dbc_n	pointer
->	O
internal	pointer
;	O
if	O
(	O
!	O
F_ISSET	O
(	O
key	struct
,	O
DB_DBT_ISSET	int
)	O
)	O
{	O
if	O
(	O
cp_n	pointer
->	O
page	pointer
==	O
NULL	O
&&	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
cp_n	pointer
->	O
pgno	int
,	O
0	int
,	O
&	O
cp_n	pointer
->	O
page	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_ret	function
(	O
dbp	pointer
,	O
cp_n	pointer
->	O
page	pointer
,	O
cp_n	pointer
->	O
indx	short
,	O
key	struct
,	O
&	O
dbc_arg	pointer
->	O
rkey	struct
.	O
data	pointer
,	O
&	O
dbc_arg	pointer
->	O
rkey	struct
.	O
ulen	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
dbc	pointer
=	O
opd	pointer
!=	O
NULL	O
?	O
opd	pointer
:	O
cp_n	pointer
->	O
opd	pointer
!=	O
NULL	O
?	O
cp_n	pointer
->	O
opd	pointer
:	O
dbc_n	pointer
;	O
if	O
(	O
!	O
F_ISSET	O
(	O
data	pointer
,	O
DB_DBT_ISSET	int
)	O
)	O
{	O
type	enum
=	O
TYPE	O
(	O
dbc	pointer
->	O
internal	pointer
->	O
page	pointer
)	O
;	O
ret	int
=	O
CDB___db_ret	function
(	O
dbp	pointer
,	O
dbc	pointer
->	O
internal	pointer
->	O
page	pointer
,	O
dbc	pointer
->	O
internal	pointer
->	O
indx	short
+	O
(	O
type	enum
==	O
P_LBTREE	int
||	O
type	enum
==	O
P_HASH	int
?	O
O_INDX	int
:	O
0	int
)	O
,	O
data	pointer
,	O
&	O
dbc_arg	pointer
->	O
rdata	struct
.	O
data	pointer
,	O
&	O
dbc_arg	pointer
->	O
rdata	struct
.	O
ulen	int
)	O
;	O
}	O
err	pointer
:	O
F_CLR	O
(	O
key	struct
,	O
DB_DBT_ISSET	int
)	O
;	O
F_CLR	O
(	O
data	pointer
,	O
DB_DBT_ISSET	int
)	O
;	O
if	O
(	O
opd	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
t_ret	int
=	O
__db_c_cleanup	function
(	O
dbc_arg	pointer
->	O
internal	pointer
->	O
opd	pointer
,	O
opd	pointer
,	O
ret	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
}	O
if	O
(	O
(	O
t_ret	int
=	O
__db_c_cleanup	function
(	O
dbc_arg	pointer
,	O
dbc_n	pointer
,	O
ret	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___db_c_put	function
(	O
dbc_arg	pointer
,	O
key	struct
,	O
data	pointer
,	O
flags	int
)	O
DBC	struct
*	O
dbc_arg	pointer
;	O
DBT	struct
*	O
key	struct
,	O
*	O
data	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
DBC	struct
*	O
dbc_n	pointer
,	O
*	O
opd	pointer
;	O
db_pgno_t	int
pgno	int
;	O
u_int32_t	int
tmp_flags	int
;	O
int	O
ret	int
,	O
t_ret	int
;	O
dbp	pointer
=	O
dbc_arg	pointer
->	O
dbp	pointer
;	O
dbc_n	pointer
=	O
NULL	O
;	O
PANIC_CHECK	O
(	O
dbp	pointer
->	O
dbenv	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_cputchk	function
(	O
dbp	pointer
,	O
key	struct
,	O
data	pointer
,	O
flags	int
,	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_RDONLY	int
)	O
,	O
IS_INITIALIZED	O
(	O
dbc_arg	pointer
)	O
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
DEBUG_LWRITE	O
(	O
dbc_arg	pointer
,	O
dbc_arg	pointer
->	O
txn	pointer
,	O
"db_c_put"	pointer
,	O
flags	int
==	O
DB_KEYFIRST	O
||	O
flags	int
==	O
DB_KEYLAST	O
||	O
flags	int
==	O
DB_NODUPDATA	int
?	O
key	struct
:	O
NULL	O
,	O
data	pointer
,	O
flags	int
)	O
;	O
LOCKING_INIT	O
(	O
dbp	pointer
,	O
dbc_arg	pointer
)	O
;	O
if	O
(	O
dbc_arg	pointer
->	O
internal	pointer
->	O
opd	pointer
!=	O
NULL	O
&&	O
(	O
flags	int
==	O
DB_AFTER	int
||	O
flags	int
==	O
DB_BEFORE	int
||	O
flags	int
==	O
DB_CURRENT	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
dbc_arg	pointer
->	O
c_am_writelock	pointer
(	O
dbc_arg	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_c_dup	function
(	O
dbc_arg	pointer
,	O
&	O
dbc_n	pointer
,	O
DB_POSITIONI	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
opd	pointer
=	O
dbc_n	pointer
->	O
internal	pointer
->	O
opd	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
opd	pointer
->	O
c_am_put	pointer
(	O
opd	pointer
,	O
key	struct
,	O
data	pointer
,	O
flags	int
,	O
NULL	O
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
goto	O
done	O
;	O
}	O
tmp_flags	int
=	O
DB_POSITIONI	int
;	O
if	O
(	O
(	O
ret	int
=	O
__db_c_idup	function
(	O
dbc_arg	pointer
,	O
&	O
dbc_n	pointer
,	O
tmp_flags	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
pgno	int
=	O
PGNO_INVALID	int
;	O
if	O
(	O
(	O
ret	int
=	O
dbc_n	pointer
->	O
c_am_put	pointer
(	O
dbc_n	pointer
,	O
key	struct
,	O
data	pointer
,	O
flags	int
,	O
&	O
pgno	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
pgno	int
!=	O
PGNO_INVALID	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_icursor	function
(	O
dbp	pointer
,	O
dbc_arg	pointer
->	O
txn	pointer
,	O
dbp	pointer
->	O
dup_compare	pointer
==	O
NULL	O
?	O
DB_RECNO	int
:	O
DB_BTREE	int
,	O
pgno	int
,	O
1	int
,	O
&	O
dbc_n	pointer
->	O
internal	pointer
->	O
opd	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
opd	pointer
=	O
dbc_n	pointer
->	O
internal	pointer
->	O
opd	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
opd	pointer
->	O
c_am_put	pointer
(	O
opd	pointer
,	O
key	struct
,	O
data	pointer
,	O
flags	int
,	O
NULL	O
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
done	O
:	O
err	pointer
:	O
if	O
(	O
(	O
t_ret	int
=	O
__db_c_cleanup	function
(	O
dbc_arg	pointer
,	O
dbc_n	pointer
,	O
ret	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
LOCKING_DONE	O
(	O
dbp	pointer
,	O
dbc_arg	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___db_duperr	function
(	O
dbp	pointer
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
if	O
(	O
flags	int
!=	O
DB_NODUPDATA	int
)	O
CDB___db_err	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Duplicate data items are not supported with sorted data"	pointer
)	O
;	O
return	O
(	O
DB_KEYEXIST	O
)	O
;	O
}	O
static	O
int	O
__db_c_cleanup	function
(	O
dbc	pointer
,	O
dbc_n	pointer
,	O
failed	int
)	O
DBC	struct
*	O
dbc	pointer
,	O
*	O
dbc_n	pointer
;	O
int	O
failed	int
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
DBC	struct
*	O
opd	pointer
;	O
DBC_INTERNAL	struct
*	O
internal	pointer
;	O
int	O
ret	int
,	O
t_ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
internal	pointer
=	O
dbc	pointer
->	O
internal	pointer
;	O
ret	int
=	O
0	int
;	O
if	O
(	O
internal	pointer
->	O
page	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
t_ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
internal	pointer
->	O
page	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
internal	pointer
->	O
page	pointer
=	O
NULL	O
;	O
}	O
opd	pointer
=	O
internal	pointer
->	O
opd	pointer
;	O
if	O
(	O
opd	pointer
!=	O
NULL	O
&&	O
opd	pointer
->	O
internal	pointer
->	O
page	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
t_ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
opd	pointer
->	O
internal	pointer
->	O
page	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
opd	pointer
->	O
internal	pointer
->	O
page	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
dbc_n	pointer
==	O
NULL	O
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
dbc_n	pointer
->	O
internal	pointer
->	O
page	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
t_ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
dbc_n	pointer
->	O
internal	pointer
->	O
page	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
dbc_n	pointer
->	O
internal	pointer
->	O
page	pointer
=	O
NULL	O
;	O
}	O
opd	pointer
=	O
dbc_n	pointer
->	O
internal	pointer
->	O
opd	pointer
;	O
if	O
(	O
opd	pointer
!=	O
NULL	O
&&	O
opd	pointer
->	O
internal	pointer
->	O
page	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
t_ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
opd	pointer
->	O
internal	pointer
->	O
page	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
opd	pointer
->	O
internal	pointer
->	O
page	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
!	O
failed	int
&&	O
ret	int
==	O
0	int
)	O
{	O
dbc	pointer
->	O
internal	pointer
=	O
dbc_n	pointer
->	O
internal	pointer
;	O
dbc_n	pointer
->	O
internal	pointer
=	O
internal	pointer
;	O
}	O
if	O
(	O
(	O
t_ret	int
=	O
dbc_n	pointer
->	O
c_close	pointer
(	O
dbc_n	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___db_cdb_cdup	function
(	O
dbc_orig	pointer
,	O
dbc_n	pointer
)	O
DBC	struct
*	O
dbc_orig	pointer
,	O
*	O
dbc_n	pointer
;	O
{	O
if	O
(	O
F_ISSET	O
(	O
dbc_orig	pointer
,	O
DBC_WRITECURSOR	int
|	O
DBC_WRITEDUP	int
)	O
)	O
{	O
memcpy	function
(	O
&	O
dbc_n	pointer
->	O
mylock	struct
,	O
&	O
dbc_orig	pointer
->	O
mylock	struct
,	O
sizeof	O
(	O
dbc_orig	pointer
->	O
mylock	struct
)	O
)	O
;	O
dbc_n	pointer
->	O
locker	int
=	O
dbc_orig	pointer
->	O
locker	int
;	O
F_SET	O
(	O
dbc_n	pointer
,	O
DBC_WRITEDUP	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__db_wrlock_err	function
(	O
dbenv	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"Write attempted on read-only cursor"	pointer
)	O
;	O
return	O
(	O
EPERM	int
)	O
;	O
}	O
