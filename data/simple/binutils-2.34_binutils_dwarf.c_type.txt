static	O
const	O
char	O
*	O
regname	function
(	O
unsigned	O
int	O
regno	int
,	O
int	O
row	int
)	O
;	O
static	O
const	O
char	O
*	O
regname_internal_by_table_only	function
(	O
unsigned	O
int	O
regno	int
)	O
;	O
static	O
int	O
have_frame_base	pointer
;	O
static	O
int	O
need_base_address	int
;	O
static	O
unsigned	O
int	O
num_debug_info_entries	int
=	O
0	int
;	O
static	O
unsigned	O
int	O
alloc_num_debug_info_entries	int
=	O
0	int
;	O
static	O
debug_info	struct
*	O
debug_information	pointer
=	O
NULL	O
;	O
typedef	O
enum	O
dwo_type	enum
{	O
DWO_NAME	int
,	O
DWO_DIR	int
,	O
DWO_ID	int
}	O
dwo_type	enum
;	O
typedef	O
struct	O
dwo_info	struct
{	O
dwo_type	enum
type	enum
;	O
const	O
char	O
*	O
value	long
;	O
struct	O
dwo_info	struct
*	O
next	pointer
;	O
}	O
dwo_info	struct
;	O
static	O
dwo_info	struct
*	O
first_dwo_info	pointer
=	O
NULL	O
;	O
static	O
bfd_boolean	int
need_dwo_info	int
;	O
separate_info	struct
*	O
first_separate_info	pointer
=	O
NULL	O
;	O
unsigned	O
int	O
eh_addr_size	int
;	O
int	O
do_debug_info	int
;	O
int	O
do_debug_abbrevs	int
;	O
int	O
do_debug_lines	int
;	O
int	O
do_debug_pubnames	int
;	O
int	O
do_debug_pubtypes	int
;	O
int	O
do_debug_aranges	int
;	O
int	O
do_debug_ranges	int
;	O
int	O
do_debug_frames	int
;	O
int	O
do_debug_frames_interp	int
;	O
int	O
do_debug_macinfo	int
;	O
int	O
do_debug_str	int
;	O
int	O
do_debug_loc	int
;	O
int	O
do_gdb_index	int
;	O
int	O
do_trace_info	int
;	O
int	O
do_trace_abbrevs	int
;	O
int	O
do_trace_aranges	int
;	O
int	O
do_debug_addr	int
;	O
int	O
do_debug_cu_index	int
;	O
int	O
do_wide	int
;	O
int	O
do_debug_links	int
;	O
int	O
do_follow_links	int
;	O
int	O
dwarf_cutoff_level	int
=	O
-	O
1	int
;	O
unsigned	O
long	O
dwarf_start_die	long
;	O
int	O
dwarf_check	int
=	O
0	int
;	O
static	O
const	O
dwarf_vma	long
vm1	long
=	O
-	O
1	int
;	O
static	O
unsigned	O
int	O
*	O
shndx_pool	pointer
=	O
NULL	O
;	O
static	O
unsigned	O
int	O
shndx_pool_size	int
=	O
0	int
;	O
static	O
unsigned	O
int	O
shndx_pool_used	int
=	O
0	int
;	O
struct	O
cu_tu_set	struct
{	O
uint64_t	long
signature	long
;	O
dwarf_vma	long
section_offsets	array
[	O
DW_SECT_MAX	int
]	O
;	O
size_t	long
section_sizes	array
[	O
DW_SECT_MAX	int
]	O
;	O
}	O
;	O
static	O
int	O
cu_count	int
=	O
0	int
;	O
static	O
int	O
tu_count	int
=	O
0	int
;	O
static	O
struct	O
cu_tu_set	struct
*	O
cu_sets	pointer
=	O
NULL	O
;	O
static	O
struct	O
cu_tu_set	struct
*	O
tu_sets	pointer
=	O
NULL	O
;	O
static	O
bfd_boolean	int
load_cu_tu_indexes	function
(	O
void	O
*	O
)	O
;	O
static	O
bfd_boolean	int
level_type_signed	array
[	O
MAX_CU_NESTING	O
]	O
;	O
static	O
unsigned	O
int	O
size_of_encoded_value	function
(	O
int	O
encoding	int
)	O
{	O
switch	O
(	O
encoding	int
&	O
0x7	int
)	O
{	O
default	O
:	O
case	O
0	int
:	O
return	O
eh_addr_size	int
;	O
case	O
2	int
:	O
return	O
2	int
;	O
case	O
3	int
:	O
return	O
4	int
;	O
case	O
4	int
:	O
return	O
8	int
;	O
}	O
}	O
static	O
dwarf_vma	long
get_encoded_value	function
(	O
unsigned	O
char	O
*	O
*	O
pdata	pointer
,	O
int	O
encoding	int
,	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
unsigned	O
char	O
*	O
end	pointer
)	O
{	O
unsigned	O
char	O
*	O
data	pointer
=	O
*	O
pdata	pointer
;	O
unsigned	O
int	O
size	int
=	O
size_of_encoded_value	function
(	O
encoding	int
)	O
;	O
dwarf_vma	long
val	array
;	O
if	O
(	O
data	pointer
+	O
size	int
>=	O
end	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"Encoded value extends past end of section\n"	pointer
)	O
)	O
;	O
*	O
pdata	pointer
=	O
end	pointer
;	O
return	O
0	int
;	O
}	O
if	O
(	O
size	int
>	O
8	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Encoded size of %d is too large to read\n"	pointer
)	O
,	O
size	int
)	O
;	O
*	O
pdata	pointer
=	O
end	pointer
;	O
return	O
0	int
;	O
}	O
if	O
(	O
size	int
==	O
0	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Encoded size of 0 is too small to read\n"	pointer
)	O
)	O
;	O
*	O
pdata	pointer
=	O
end	pointer
;	O
return	O
0	int
;	O
}	O
if	O
(	O
encoding	int
&	O
DW_EH_PE_signed	int
)	O
val	array
=	O
byte_get_signed	function
(	O
data	pointer
,	O
size	int
)	O
;	O
else	O
val	array
=	O
byte_get	pointer
(	O
data	pointer
,	O
size	int
)	O
;	O
if	O
(	O
(	O
encoding	int
&	O
0x70	int
)	O
==	O
DW_EH_PE_pcrel	int
)	O
val	array
+=	O
section	pointer
->	O
address	long
+	O
(	O
data	pointer
-	O
section	pointer
->	O
start	pointer
)	O
;	O
*	O
pdata	pointer
=	O
data	pointer
+	O
size	int
;	O
return	O
val	array
;	O
}	O
static	O
const	O
char	O
*	O
dwarf_vmatoa_1	function
(	O
const	O
char	O
*	O
fmtch	pointer
,	O
dwarf_vma	long
value	long
,	O
unsigned	O
num_bytes	int
)	O
{	O
static	O
int	O
buf_pos	int
=	O
0	int
;	O
static	O
struct	O
dwarf_vmatoa_buf	struct
{	O
char	O
place	array
[	O
64	int
]	O
;	O
}	O
buf	pointer
[	O
16	int
]	O
;	O
char	O
*	O
ret	pointer
;	O
ret	pointer
=	O
buf	pointer
[	O
buf_pos	int
++	O
]	O
.	O
place	array
;	O
buf_pos	int
%=	O
ARRAY_SIZE	O
(	O
buf	pointer
)	O
;	O
if	O
(	O
num_bytes	int
)	O
{	O
snprintf	function
(	O
ret	pointer
,	O
sizeof	O
(	O
buf	pointer
[	O
0	int
]	O
.	O
place	array
)	O
,	O
DWARF_VMA_FMT_LONG	pointer
,	O
value	long
)	O
;	O
if	O
(	O
num_bytes	int
>	O
8	int
)	O
num_bytes	int
=	O
8	int
;	O
return	O
ret	pointer
+	O
(	O
16	int
-	O
2	int
*	O
num_bytes	int
)	O
;	O
}	O
else	O
{	O
char	O
fmt	pointer
[	O
32	int
]	O
;	O
if	O
(	O
fmtch	pointer
)	O
sprintf	function
(	O
fmt	pointer
,	O
"%%%s%s"	pointer
,	O
DWARF_VMA_FMT	pointer
,	O
fmtch	pointer
)	O
;	O
else	O
sprintf	function
(	O
fmt	pointer
,	O
"%%%s"	pointer
,	O
DWARF_VMA_FMT	pointer
)	O
;	O
snprintf	function
(	O
ret	pointer
,	O
sizeof	O
(	O
buf	pointer
[	O
0	int
]	O
.	O
place	array
)	O
,	O
fmt	pointer
,	O
value	long
)	O
;	O
return	O
ret	pointer
;	O
}	O
}	O
static	O
inline	O
const	O
char	O
*	O
dwarf_vmatoa	function
(	O
const	O
char	O
*	O
fmtch	pointer
,	O
dwarf_vma	long
value	long
)	O
{	O
return	O
dwarf_vmatoa_1	function
(	O
fmtch	pointer
,	O
value	long
,	O
0	int
)	O
;	O
}	O
static	O
void	O
print_dwarf_vma	function
(	O
dwarf_vma	long
value	long
,	O
unsigned	O
num_bytes	int
)	O
{	O
printf	function
(	O
"%s "	pointer
,	O
dwarf_vmatoa_1	function
(	O
NULL	O
,	O
value	long
,	O
num_bytes	int
)	O
)	O
;	O
}	O
static	O
void	O
print_dwarf_view	function
(	O
dwarf_vma	long
value	long
,	O
unsigned	O
num_bytes	int
,	O
int	O
force	int
)	O
{	O
int	O
len	long
;	O
if	O
(	O
!	O
num_bytes	int
)	O
len	long
=	O
4	int
;	O
else	O
len	long
=	O
num_bytes	int
*	O
2	int
;	O
assert	O
(	O
value	long
==	O
(	O
unsigned	O
long	O
)	O
value	long
)	O
;	O
if	O
(	O
value	long
||	O
force	int
)	O
printf	function
(	O
"v%0*lx "	pointer
,	O
len	long
-	O
1	int
,	O
(	O
unsigned	O
long	O
)	O
value	long
)	O
;	O
else	O
printf	function
(	O
"%*s"	pointer
,	O
len	long
+	O
1	int
,	O
""	pointer
)	O
;	O
}	O
static	O
const	O
char	O
*	O
dwarf_vmatoa64	function
(	O
dwarf_vma	long
hvalue	long
,	O
dwarf_vma	long
lvalue	long
,	O
char	O
*	O
buf	pointer
,	O
unsigned	O
int	O
buf_len	int
)	O
{	O
int	O
len	long
=	O
0	int
;	O
if	O
(	O
hvalue	long
==	O
0	int
)	O
snprintf	function
(	O
buf	pointer
,	O
buf_len	int
,	O
"%"	pointer
DWARF_VMA_FMT	pointer
"x"	pointer
,	O
lvalue	long
)	O
;	O
else	O
{	O
len	long
=	O
snprintf	function
(	O
buf	pointer
,	O
buf_len	int
,	O
"%"	pointer
DWARF_VMA_FMT	pointer
"x"	pointer
,	O
hvalue	long
)	O
;	O
snprintf	function
(	O
buf	pointer
+	O
len	long
,	O
buf_len	int
-	O
len	long
,	O
"%08"	pointer
DWARF_VMA_FMT	pointer
"x"	pointer
,	O
lvalue	long
)	O
;	O
}	O
return	O
buf	pointer
;	O
}	O
dwarf_vma	long
read_leb128	function
(	O
unsigned	O
char	O
*	O
data	pointer
,	O
const	O
unsigned	O
char	O
*	O
const	O
end	pointer
,	O
bfd_boolean	int
sign	int
,	O
unsigned	O
int	O
*	O
length_return	pointer
,	O
int	O
*	O
status_return	pointer
)	O
{	O
dwarf_vma	long
result	long
=	O
0	int
;	O
unsigned	O
int	O
num_read	int
=	O
0	int
;	O
unsigned	O
int	O
shift	int
=	O
0	int
;	O
int	O
status	int
=	O
1	int
;	O
while	O
(	O
data	pointer
<	O
end	pointer
)	O
{	O
unsigned	O
char	O
byte	char
=	O
*	O
data	pointer
++	O
;	O
num_read	int
++	O
;	O
if	O
(	O
shift	int
<	O
sizeof	O
(	O
result	long
)	O
*	O
8	int
)	O
{	O
result	long
|=	O
(	O
(	O
dwarf_vma	long
)	O
(	O
byte	char
&	O
0x7f	int
)	O
)	O
<<	O
shift	int
;	O
if	O
(	O
(	O
result	long
>>	O
shift	int
)	O
!=	O
(	O
byte	char
&	O
0x7f	int
)	O
)	O
status	int
|=	O
2	int
;	O
shift	int
+=	O
7	int
;	O
}	O
else	O
if	O
(	O
(	O
byte	char
&	O
0x7f	int
)	O
!=	O
0	int
)	O
status	int
|=	O
2	int
;	O
if	O
(	O
(	O
byte	char
&	O
0x80	int
)	O
==	O
0	int
)	O
{	O
status	int
&=	O
~	O
1	int
;	O
if	O
(	O
sign	int
&&	O
(	O
shift	int
<	O
8	int
*	O
sizeof	O
(	O
result	long
)	O
)	O
&&	O
(	O
byte	char
&	O
0x40	int
)	O
)	O
result	long
|=	O
-	O
(	O
(	O
dwarf_vma	long
)	O
1	int
<<	O
shift	int
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
length_return	pointer
!=	O
NULL	O
)	O
*	O
length_return	pointer
=	O
num_read	int
;	O
if	O
(	O
status_return	pointer
!=	O
NULL	O
)	O
*	O
status_return	pointer
=	O
status	int
;	O
return	O
result	long
;	O
}	O
typedef	O
struct	O
State_Machine_Registers	struct
{	O
dwarf_vma	long
address	long
;	O
unsigned	O
int	O
view	int
;	O
unsigned	O
int	O
file	pointer
;	O
unsigned	O
int	O
line	int
;	O
unsigned	O
int	O
column	int
;	O
int	O
is_stmt	int
;	O
int	O
basic_block	int
;	O
unsigned	O
char	O
op_index	char
;	O
unsigned	O
char	O
end_sequence	char
;	O
unsigned	O
int	O
last_file_entry	int
;	O
}	O
SMR	struct
;	O
static	O
SMR	struct
state_machine_regs	struct
;	O
static	O
void	O
reset_state_machine	function
(	O
int	O
is_stmt	int
)	O
{	O
state_machine_regs	struct
.	O
address	long
=	O
0	int
;	O
state_machine_regs	struct
.	O
view	int
=	O
0	int
;	O
state_machine_regs	struct
.	O
op_index	char
=	O
0	int
;	O
state_machine_regs	struct
.	O
file	pointer
=	O
1	int
;	O
state_machine_regs	struct
.	O
line	int
=	O
1	int
;	O
state_machine_regs	struct
.	O
column	int
=	O
0	int
;	O
state_machine_regs	struct
.	O
is_stmt	int
=	O
is_stmt	int
;	O
state_machine_regs	struct
.	O
basic_block	int
=	O
0	int
;	O
state_machine_regs	struct
.	O
end_sequence	char
=	O
0	int
;	O
state_machine_regs	struct
.	O
last_file_entry	int
=	O
0	int
;	O
}	O
static	O
size_t	long
process_extended_line_op	function
(	O
unsigned	O
char	O
*	O
data	pointer
,	O
int	O
is_stmt	int
,	O
unsigned	O
char	O
*	O
end	pointer
)	O
{	O
unsigned	O
char	O
op_code	char
;	O
size_t	long
len	long
,	O
header_len	long
;	O
unsigned	O
char	O
*	O
name	pointer
;	O
unsigned	O
char	O
*	O
orig_data	pointer
=	O
data	pointer
;	O
dwarf_vma	long
adr	long
,	O
val	array
;	O
READ_ULEB	O
(	O
len	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
header_len	long
=	O
data	pointer
-	O
orig_data	pointer
;	O
if	O
(	O
len	long
==	O
0	int
||	O
data	pointer
==	O
end	pointer
||	O
len	long
>	O
(	O
size_t	long
)	O
(	O
end	pointer
-	O
data	pointer
)	O
)	O
{	O
warn	function
(	O
_	O
(	O
"Badly formed extended line op encountered!\n"	pointer
)	O
)	O
;	O
return	O
header_len	long
;	O
}	O
op_code	char
=	O
*	O
data	pointer
++	O
;	O
printf	function
(	O
_	O
(	O
"  Extended opcode %d: "	pointer
)	O
,	O
op_code	char
)	O
;	O
switch	O
(	O
op_code	char
)	O
{	O
case	O
DW_LNE_end_sequence	int
:	O
printf	function
(	O
_	O
(	O
"End of Sequence\n\n"	pointer
)	O
)	O
;	O
reset_state_machine	function
(	O
is_stmt	int
)	O
;	O
break	O
;	O
case	O
DW_LNE_set_address	int
:	O
if	O
(	O
len	long
-	O
1	int
>	O
8	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Length (%lu) of DW_LNE_set_address op is too long\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
len	long
-	O
1	int
)	O
;	O
adr	long
=	O
0	int
;	O
}	O
else	O
SAFE_BYTE_GET	O
(	O
adr	long
,	O
data	pointer
,	O
len	long
-	O
1	int
,	O
end	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"set Address to 0x%s\n"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
adr	long
)	O
)	O
;	O
state_machine_regs	struct
.	O
address	long
=	O
adr	long
;	O
state_machine_regs	struct
.	O
view	int
=	O
0	int
;	O
state_machine_regs	struct
.	O
op_index	char
=	O
0	int
;	O
break	O
;	O
case	O
DW_LNE_define_file	int
:	O
printf	function
(	O
_	O
(	O
"define new File Table entry\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  Entry\tDir\tTime\tSize\tName\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"   %d\t"	pointer
,	O
++	O
state_machine_regs	struct
.	O
last_file_entry	int
)	O
;	O
{	O
size_t	long
l	long
;	O
name	pointer
=	O
data	pointer
;	O
l	long
=	O
strnlen	function
(	O
(	O
char	O
*	O
)	O
data	pointer
,	O
end	pointer
-	O
data	pointer
)	O
;	O
data	pointer
+=	O
l	long
+	O
1	int
;	O
READ_ULEB	O
(	O
val	array
,	O
data	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"%s\t"	pointer
,	O
dwarf_vmatoa	function
(	O
"u"	pointer
,	O
val	array
)	O
)	O
;	O
READ_ULEB	O
(	O
val	array
,	O
data	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"%s\t"	pointer
,	O
dwarf_vmatoa	function
(	O
"u"	pointer
,	O
val	array
)	O
)	O
;	O
READ_ULEB	O
(	O
val	array
,	O
data	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"%s\t"	pointer
,	O
dwarf_vmatoa	function
(	O
"u"	pointer
,	O
val	array
)	O
)	O
;	O
printf	function
(	O
"%.*s\n\n"	pointer
,	O
(	O
int	O
)	O
l	long
,	O
name	pointer
)	O
;	O
}	O
if	O
(	O
(	O
(	O
size_t	long
)	O
(	O
data	pointer
-	O
orig_data	pointer
)	O
!=	O
len	long
+	O
header_len	long
)	O
||	O
data	pointer
==	O
end	pointer
)	O
warn	function
(	O
_	O
(	O
"DW_LNE_define_file: Bad opcode length\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
DW_LNE_set_discriminator	int
:	O
READ_ULEB	O
(	O
val	array
,	O
data	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"set Discriminator to %s\n"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"u"	pointer
,	O
val	array
)	O
)	O
;	O
break	O
;	O
case	O
DW_LNE_HP_negate_is_UV_update	int
:	O
printf	function
(	O
"DW_LNE_HP_negate_is_UV_update\n"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LNE_HP_push_context	int
:	O
printf	function
(	O
"DW_LNE_HP_push_context\n"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LNE_HP_pop_context	int
:	O
printf	function
(	O
"DW_LNE_HP_pop_context\n"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LNE_HP_set_file_line_column	int
:	O
printf	function
(	O
"DW_LNE_HP_set_file_line_column\n"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LNE_HP_set_routine_name	int
:	O
printf	function
(	O
"DW_LNE_HP_set_routine_name\n"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LNE_HP_set_sequence	int
:	O
printf	function
(	O
"DW_LNE_HP_set_sequence\n"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LNE_HP_negate_post_semantics	int
:	O
printf	function
(	O
"DW_LNE_HP_negate_post_semantics\n"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LNE_HP_negate_function_exit	int
:	O
printf	function
(	O
"DW_LNE_HP_negate_function_exit\n"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LNE_HP_negate_front_end_logical	int
:	O
printf	function
(	O
"DW_LNE_HP_negate_front_end_logical\n"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LNE_HP_define_proc	int
:	O
printf	function
(	O
"DW_LNE_HP_define_proc\n"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LNE_HP_source_file_correlation	int
:	O
{	O
unsigned	O
char	O
*	O
edata	pointer
=	O
data	pointer
+	O
len	long
-	O
1	int
;	O
printf	function
(	O
"DW_LNE_HP_source_file_correlation\n"	pointer
)	O
;	O
while	O
(	O
data	pointer
<	O
edata	pointer
)	O
{	O
unsigned	O
int	O
opc	int
;	O
READ_ULEB	O
(	O
opc	int
,	O
data	pointer
,	O
edata	pointer
)	O
;	O
switch	O
(	O
opc	int
)	O
{	O
case	O
DW_LNE_HP_SFC_formfeed	int
:	O
printf	function
(	O
"    DW_LNE_HP_SFC_formfeed\n"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LNE_HP_SFC_set_listing_line	int
:	O
READ_ULEB	O
(	O
val	array
,	O
data	pointer
,	O
edata	pointer
)	O
;	O
printf	function
(	O
"    DW_LNE_HP_SFC_set_listing_line (%s)\n"	pointer
,	O
dwarf_vmatoa	function
(	O
"u"	pointer
,	O
val	array
)	O
)	O
;	O
break	O
;	O
case	O
DW_LNE_HP_SFC_associate	int
:	O
printf	function
(	O
"    DW_LNE_HP_SFC_associate "	pointer
)	O
;	O
READ_ULEB	O
(	O
val	array
,	O
data	pointer
,	O
edata	pointer
)	O
;	O
printf	function
(	O
"(%s"	pointer
,	O
dwarf_vmatoa	function
(	O
"u"	pointer
,	O
val	array
)	O
)	O
;	O
READ_ULEB	O
(	O
val	array
,	O
data	pointer
,	O
edata	pointer
)	O
;	O
printf	function
(	O
",%s"	pointer
,	O
dwarf_vmatoa	function
(	O
"u"	pointer
,	O
val	array
)	O
)	O
;	O
READ_ULEB	O
(	O
val	array
,	O
data	pointer
,	O
edata	pointer
)	O
;	O
printf	function
(	O
",%s)\n"	pointer
,	O
dwarf_vmatoa	function
(	O
"u"	pointer
,	O
val	array
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
_	O
(	O
"    UNKNOWN DW_LNE_HP_SFC opcode (%u)\n"	pointer
)	O
,	O
opc	int
)	O
;	O
data	pointer
=	O
edata	pointer
;	O
break	O
;	O
}	O
}	O
}	O
break	O
;	O
default	O
:	O
{	O
unsigned	O
int	O
rlen	int
=	O
len	long
-	O
1	int
;	O
if	O
(	O
op_code	char
>=	O
DW_LNE_lo_user	int
)	O
printf	function
(	O
_	O
(	O
"user defined: "	pointer
)	O
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"UNKNOWN: "	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"length %d ["	pointer
)	O
,	O
rlen	int
)	O
;	O
for	O
(	O
;	O
rlen	int
;	O
rlen	int
--	O
)	O
printf	function
(	O
" %02x"	pointer
,	O
*	O
data	pointer
++	O
)	O
;	O
printf	function
(	O
"]\n"	pointer
)	O
;	O
}	O
break	O
;	O
}	O
return	O
len	long
+	O
header_len	long
;	O
}	O
static	O
const	O
unsigned	O
char	O
*	O
fetch_indirect_string	function
(	O
dwarf_vma	long
offset	long
)	O
{	O
struct	O
dwarf_section	struct
*	O
section	pointer
=	O
&	O
debug_displays	array
[	O
str	int
]	O
.	O
section	pointer
;	O
const	O
unsigned	O
char	O
*	O
ret	pointer
;	O
if	O
(	O
section	pointer
->	O
start	pointer
==	O
NULL	O
)	O
return	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
_	O
(	O
"<no .debug_str section>"	pointer
)	O
;	O
if	O
(	O
offset	long
>=	O
section	pointer
->	O
size	int
)	O
{	O
warn	function
(	O
_	O
(	O
"DW_FORM_strp offset too big: %s\n"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
offset	long
)	O
)	O
;	O
return	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
_	O
(	O
"<offset is too big>"	pointer
)	O
;	O
}	O
ret	pointer
=	O
section	pointer
->	O
start	pointer
+	O
offset	long
;	O
if	O
(	O
strnlen	function
(	O
(	O
const	O
char	O
*	O
)	O
ret	pointer
,	O
section	pointer
->	O
size	int
-	O
offset	long
)	O
==	O
section	pointer
->	O
size	int
-	O
offset	long
)	O
ret	pointer
=	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
_	O
(	O
"<no NUL byte at end of .debug_str section>"	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
static	O
const	O
unsigned	O
char	O
*	O
fetch_indirect_line_string	function
(	O
dwarf_vma	long
offset	long
)	O
{	O
struct	O
dwarf_section	struct
*	O
section	pointer
=	O
&	O
debug_displays	array
[	O
line_str	int
]	O
.	O
section	pointer
;	O
const	O
unsigned	O
char	O
*	O
ret	pointer
;	O
if	O
(	O
section	pointer
->	O
start	pointer
==	O
NULL	O
)	O
return	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
_	O
(	O
"<no .debug_line_str section>"	pointer
)	O
;	O
if	O
(	O
offset	long
>=	O
section	pointer
->	O
size	int
)	O
{	O
warn	function
(	O
_	O
(	O
"DW_FORM_line_strp offset too big: %s\n"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
offset	long
)	O
)	O
;	O
return	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
_	O
(	O
"<offset is too big>"	pointer
)	O
;	O
}	O
ret	pointer
=	O
section	pointer
->	O
start	pointer
+	O
offset	long
;	O
if	O
(	O
strnlen	function
(	O
(	O
const	O
char	O
*	O
)	O
ret	pointer
,	O
section	pointer
->	O
size	int
-	O
offset	long
)	O
==	O
section	pointer
->	O
size	int
-	O
offset	long
)	O
ret	pointer
=	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
_	O
(	O
"<no NUL byte at end of .debug_line_str section>"	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
static	O
const	O
char	O
*	O
fetch_indexed_string	function
(	O
dwarf_vma	long
idx	int
,	O
struct	O
cu_tu_set	struct
*	O
this_set	pointer
,	O
dwarf_vma	long
offset_size	int
,	O
bfd_boolean	int
dwo	int
)	O
{	O
enum	O
dwarf_section_display_enum	enum
str_sec_idx	enum
=	O
dwo	int
?	O
str_dwo	int
:	O
str	int
;	O
enum	O
dwarf_section_display_enum	enum
idx_sec_idx	enum
=	O
dwo	int
?	O
str_index_dwo	int
:	O
str_index	int
;	O
struct	O
dwarf_section	struct
*	O
index_section	pointer
=	O
&	O
debug_displays	array
[	O
idx_sec_idx	enum
]	O
.	O
section	pointer
;	O
struct	O
dwarf_section	struct
*	O
str_section	pointer
=	O
&	O
debug_displays	array
[	O
str_sec_idx	enum
]	O
.	O
section	pointer
;	O
dwarf_vma	long
index_offset	long
=	O
idx	int
*	O
offset_size	int
;	O
dwarf_vma	long
str_offset	long
;	O
const	O
char	O
*	O
ret	pointer
;	O
if	O
(	O
index_section	pointer
->	O
start	pointer
==	O
NULL	O
)	O
return	O
(	O
dwo	int
?	O
_	O
(	O
"<no .debug_str_offsets.dwo section>"	pointer
)	O
:	O
_	O
(	O
"<no .debug_str_offsets section>"	pointer
)	O
)	O
;	O
if	O
(	O
this_set	pointer
!=	O
NULL	O
)	O
index_offset	long
+=	O
this_set	pointer
->	O
section_offsets	array
[	O
DW_SECT_STR_OFFSETS	int
]	O
;	O
if	O
(	O
index_offset	long
>=	O
index_section	pointer
->	O
size	int
)	O
{	O
warn	function
(	O
_	O
(	O
"DW_FORM_GNU_str_index offset too big: %s\n"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
index_offset	long
)	O
)	O
;	O
return	O
_	O
(	O
"<index offset is too big>"	pointer
)	O
;	O
}	O
if	O
(	O
str_section	pointer
->	O
start	pointer
==	O
NULL	O
)	O
return	O
(	O
dwo	int
?	O
_	O
(	O
"<no .debug_str.dwo section>"	pointer
)	O
:	O
_	O
(	O
"<no .debug_str section>"	pointer
)	O
)	O
;	O
str_offset	long
=	O
byte_get	pointer
(	O
index_section	pointer
->	O
start	pointer
+	O
index_offset	long
,	O
offset_size	int
)	O
;	O
str_offset	long
-=	O
str_section	pointer
->	O
address	long
;	O
if	O
(	O
str_offset	long
>=	O
str_section	pointer
->	O
size	int
)	O
{	O
warn	function
(	O
_	O
(	O
"DW_FORM_GNU_str_index indirect offset too big: %s\n"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
str_offset	long
)	O
)	O
;	O
return	O
_	O
(	O
"<indirect index offset is too big>"	pointer
)	O
;	O
}	O
ret	pointer
=	O
(	O
const	O
char	O
*	O
)	O
str_section	pointer
->	O
start	pointer
+	O
str_offset	long
;	O
if	O
(	O
strnlen	function
(	O
ret	pointer
,	O
str_section	pointer
->	O
size	int
-	O
str_offset	long
)	O
==	O
str_section	pointer
->	O
size	int
-	O
str_offset	long
)	O
ret	pointer
=	O
(	O
const	O
char	O
*	O
)	O
_	O
(	O
"<no NUL byte at end of section>"	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
static	O
const	O
char	O
*	O
fetch_indexed_value	function
(	O
dwarf_vma	long
offset	long
,	O
dwarf_vma	long
bytes	long
)	O
{	O
struct	O
dwarf_section	struct
*	O
section	pointer
=	O
&	O
debug_displays	array
[	O
debug_addr	int
]	O
.	O
section	pointer
;	O
if	O
(	O
section	pointer
->	O
start	pointer
==	O
NULL	O
)	O
return	O
(	O
_	O
(	O
"<no .debug_addr section>"	pointer
)	O
)	O
;	O
if	O
(	O
offset	long
+	O
bytes	long
>	O
section	pointer
->	O
size	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Offset into section %s too big: %s\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
offset	long
)	O
)	O
;	O
return	O
"<offset too big>"	pointer
;	O
}	O
return	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
byte_get	pointer
(	O
section	pointer
->	O
start	pointer
+	O
offset	long
,	O
bytes	long
)	O
)	O
;	O
}	O
typedef	O
struct	O
abbrev_attr	struct
{	O
unsigned	O
long	O
attribute	long
;	O
unsigned	O
long	O
form	int
;	O
bfd_signed_vma	long
implicit_const	long
;	O
struct	O
abbrev_attr	struct
*	O
next	pointer
;	O
}	O
abbrev_attr	struct
;	O
typedef	O
struct	O
abbrev_entry	struct
{	O
unsigned	O
long	O
entry	long
;	O
unsigned	O
long	O
tag	int
;	O
int	O
children	int
;	O
struct	O
abbrev_attr	struct
*	O
first_attr	pointer
;	O
struct	O
abbrev_attr	struct
*	O
last_attr	pointer
;	O
struct	O
abbrev_entry	struct
*	O
next	pointer
;	O
}	O
abbrev_entry	struct
;	O
static	O
abbrev_entry	struct
*	O
first_abbrev	pointer
=	O
NULL	O
;	O
static	O
abbrev_entry	struct
*	O
last_abbrev	pointer
=	O
NULL	O
;	O
static	O
void	O
free_abbrevs	function
(	O
void	O
)	O
{	O
abbrev_entry	struct
*	O
abbrv	pointer
;	O
for	O
(	O
abbrv	pointer
=	O
first_abbrev	pointer
;	O
abbrv	pointer
;	O
)	O
{	O
abbrev_entry	struct
*	O
next_abbrev	pointer
=	O
abbrv	pointer
->	O
next	pointer
;	O
abbrev_attr	struct
*	O
attr	int
;	O
for	O
(	O
attr	int
=	O
abbrv	pointer
->	O
first_attr	pointer
;	O
attr	int
;	O
)	O
{	O
abbrev_attr	struct
*	O
next_attr	pointer
=	O
attr	int
->	O
next	pointer
;	O
free	function
(	O
attr	int
)	O
;	O
attr	int
=	O
next_attr	pointer
;	O
}	O
free	function
(	O
abbrv	pointer
)	O
;	O
abbrv	pointer
=	O
next_abbrev	pointer
;	O
}	O
last_abbrev	pointer
=	O
first_abbrev	pointer
=	O
NULL	O
;	O
}	O
static	O
void	O
add_abbrev	function
(	O
unsigned	O
long	O
number	long
,	O
unsigned	O
long	O
tag	int
,	O
int	O
children	int
)	O
{	O
abbrev_entry	struct
*	O
entry	long
;	O
entry	long
=	O
(	O
abbrev_entry	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
*	O
entry	long
)	O
)	O
;	O
if	O
(	O
entry	long
==	O
NULL	O
)	O
return	O
;	O
entry	long
->	O
entry	long
=	O
number	long
;	O
entry	long
->	O
tag	int
=	O
tag	int
;	O
entry	long
->	O
children	int
=	O
children	int
;	O
entry	long
->	O
first_attr	pointer
=	O
NULL	O
;	O
entry	long
->	O
last_attr	pointer
=	O
NULL	O
;	O
entry	long
->	O
next	pointer
=	O
NULL	O
;	O
if	O
(	O
first_abbrev	pointer
==	O
NULL	O
)	O
first_abbrev	pointer
=	O
entry	long
;	O
else	O
last_abbrev	pointer
->	O
next	pointer
=	O
entry	long
;	O
last_abbrev	pointer
=	O
entry	long
;	O
}	O
static	O
void	O
add_abbrev_attr	function
(	O
unsigned	O
long	O
attribute	long
,	O
unsigned	O
long	O
form	int
,	O
bfd_signed_vma	long
implicit_const	long
)	O
{	O
abbrev_attr	struct
*	O
attr	int
;	O
attr	int
=	O
(	O
abbrev_attr	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
*	O
attr	int
)	O
)	O
;	O
if	O
(	O
attr	int
==	O
NULL	O
)	O
return	O
;	O
attr	int
->	O
attribute	long
=	O
attribute	long
;	O
attr	int
->	O
form	int
=	O
form	int
;	O
attr	int
->	O
implicit_const	long
=	O
implicit_const	long
;	O
attr	int
->	O
next	pointer
=	O
NULL	O
;	O
if	O
(	O
last_abbrev	pointer
->	O
first_attr	pointer
==	O
NULL	O
)	O
last_abbrev	pointer
->	O
first_attr	pointer
=	O
attr	int
;	O
else	O
last_abbrev	pointer
->	O
last_attr	pointer
->	O
next	pointer
=	O
attr	int
;	O
last_abbrev	pointer
->	O
last_attr	pointer
=	O
attr	int
;	O
}	O
static	O
unsigned	O
char	O
*	O
process_abbrev_section	function
(	O
unsigned	O
char	O
*	O
start	pointer
,	O
unsigned	O
char	O
*	O
end	pointer
)	O
{	O
if	O
(	O
first_abbrev	pointer
!=	O
NULL	O
)	O
return	O
NULL	O
;	O
while	O
(	O
start	pointer
<	O
end	pointer
)	O
{	O
unsigned	O
long	O
entry	long
;	O
unsigned	O
long	O
tag	int
;	O
unsigned	O
long	O
attribute	long
;	O
int	O
children	int
;	O
READ_ULEB	O
(	O
entry	long
,	O
start	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
start	pointer
==	O
end	pointer
)	O
return	O
NULL	O
;	O
if	O
(	O
entry	long
==	O
0	int
)	O
return	O
start	pointer
;	O
READ_ULEB	O
(	O
tag	int
,	O
start	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
start	pointer
==	O
end	pointer
)	O
return	O
NULL	O
;	O
children	int
=	O
*	O
start	pointer
++	O
;	O
add_abbrev	function
(	O
entry	long
,	O
tag	int
,	O
children	int
)	O
;	O
do	O
{	O
unsigned	O
long	O
form	int
;	O
bfd_signed_vma	long
implicit_const	long
=	O
-	O
1	int
;	O
READ_ULEB	O
(	O
attribute	long
,	O
start	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
start	pointer
==	O
end	pointer
)	O
break	O
;	O
READ_ULEB	O
(	O
form	int
,	O
start	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
start	pointer
==	O
end	pointer
)	O
break	O
;	O
if	O
(	O
form	int
==	O
DW_FORM_implicit_const	int
)	O
{	O
READ_SLEB	O
(	O
implicit_const	long
,	O
start	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
start	pointer
==	O
end	pointer
)	O
break	O
;	O
}	O
add_abbrev_attr	function
(	O
attribute	long
,	O
form	int
,	O
implicit_const	long
)	O
;	O
}	O
while	O
(	O
attribute	long
!=	O
0	int
)	O
;	O
}	O
error	function
(	O
_	O
(	O
".debug_abbrev section not zero terminated\n"	pointer
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
static	O
const	O
char	O
*	O
get_TAG_name	function
(	O
unsigned	O
long	O
tag	int
)	O
{	O
const	O
char	O
*	O
name	pointer
=	O
get_DW_TAG_name	function
(	O
(	O
unsigned	O
int	O
)	O
tag	int
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
{	O
static	O
char	O
buffer	array
[	O
100	int
]	O
;	O
if	O
(	O
tag	int
>=	O
DW_TAG_lo_user	int
&&	O
tag	int
<=	O
DW_TAG_hi_user	int
)	O
snprintf	function
(	O
buffer	array
,	O
sizeof	O
(	O
buffer	array
)	O
,	O
_	O
(	O
"User TAG value: %#lx"	pointer
)	O
,	O
tag	int
)	O
;	O
else	O
snprintf	function
(	O
buffer	array
,	O
sizeof	O
(	O
buffer	array
)	O
,	O
_	O
(	O
"Unknown TAG value: %#lx"	pointer
)	O
,	O
tag	int
)	O
;	O
return	O
buffer	array
;	O
}	O
return	O
name	pointer
;	O
}	O
static	O
const	O
char	O
*	O
get_FORM_name	function
(	O
unsigned	O
long	O
form	int
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
if	O
(	O
form	int
==	O
0	int
)	O
return	O
"DW_FORM value: 0"	pointer
;	O
name	pointer
=	O
get_DW_FORM_name	function
(	O
form	int
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
{	O
static	O
char	O
buffer	array
[	O
100	int
]	O
;	O
snprintf	function
(	O
buffer	array
,	O
sizeof	O
(	O
buffer	array
)	O
,	O
_	O
(	O
"Unknown FORM value: %lx"	pointer
)	O
,	O
form	int
)	O
;	O
return	O
buffer	array
;	O
}	O
return	O
name	pointer
;	O
}	O
static	O
const	O
char	O
*	O
get_IDX_name	function
(	O
unsigned	O
long	O
idx	int
)	O
{	O
const	O
char	O
*	O
name	pointer
=	O
get_DW_IDX_name	function
(	O
(	O
unsigned	O
int	O
)	O
idx	int
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
{	O
static	O
char	O
buffer	array
[	O
100	int
]	O
;	O
snprintf	function
(	O
buffer	array
,	O
sizeof	O
(	O
buffer	array
)	O
,	O
_	O
(	O
"Unknown IDX value: %lx"	pointer
)	O
,	O
idx	int
)	O
;	O
return	O
buffer	array
;	O
}	O
return	O
name	pointer
;	O
}	O
static	O
unsigned	O
char	O
*	O
display_block	function
(	O
unsigned	O
char	O
*	O
data	pointer
,	O
dwarf_vma	long
length	long
,	O
const	O
unsigned	O
char	O
*	O
const	O
end	pointer
,	O
char	O
delimiter	char
)	O
{	O
dwarf_vma	long
maxlen	long
;	O
printf	function
(	O
_	O
(	O
"%c%s byte block: "	pointer
)	O
,	O
delimiter	char
,	O
dwarf_vmatoa	function
(	O
"u"	pointer
,	O
length	long
)	O
)	O
;	O
if	O
(	O
data	pointer
>	O
end	pointer
)	O
return	O
(	O
unsigned	O
char	O
*	O
)	O
end	pointer
;	O
maxlen	long
=	O
(	O
dwarf_vma	long
)	O
(	O
end	pointer
-	O
data	pointer
)	O
;	O
length	long
=	O
length	long
>	O
maxlen	long
?	O
maxlen	long
:	O
length	long
;	O
while	O
(	O
length	long
--	O
)	O
printf	function
(	O
"%lx "	pointer
,	O
(	O
unsigned	O
long	O
)	O
byte_get	pointer
(	O
data	pointer
++	O
,	O
1	int
)	O
)	O
;	O
return	O
data	pointer
;	O
}	O
static	O
int	O
decode_location_expression	function
(	O
unsigned	O
char	O
*	O
data	pointer
,	O
unsigned	O
int	O
pointer_size	int
,	O
unsigned	O
int	O
offset_size	int
,	O
int	O
dwarf_version	int
,	O
dwarf_vma	long
length	long
,	O
dwarf_vma	long
cu_offset	long
,	O
struct	O
dwarf_section	struct
*	O
section	pointer
)	O
{	O
unsigned	O
op	int
;	O
dwarf_vma	long
uvalue	long
;	O
dwarf_signed_vma	long
svalue	long
;	O
unsigned	O
char	O
*	O
end	pointer
=	O
data	pointer
+	O
length	long
;	O
int	O
need_frame_base	int
=	O
0	int
;	O
while	O
(	O
data	pointer
<	O
end	pointer
)	O
{	O
op	int
=	O
*	O
data	pointer
++	O
;	O
switch	O
(	O
op	int
)	O
{	O
case	O
DW_OP_addr	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
uvalue	long
,	O
data	pointer
,	O
pointer_size	int
,	O
end	pointer
)	O
;	O
printf	function
(	O
"DW_OP_addr: %s"	pointer
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
uvalue	long
)	O
)	O
;	O
break	O
;	O
case	O
DW_OP_deref	int
:	O
printf	function
(	O
"DW_OP_deref"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_const1u	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
uvalue	long
,	O
data	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
printf	function
(	O
"DW_OP_const1u: %lu"	pointer
,	O
(	O
unsigned	O
long	O
)	O
uvalue	long
)	O
;	O
break	O
;	O
case	O
DW_OP_const1s	int
:	O
SAFE_SIGNED_BYTE_GET_AND_INC	O
(	O
svalue	long
,	O
data	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
printf	function
(	O
"DW_OP_const1s: %ld"	pointer
,	O
(	O
long	O
)	O
svalue	long
)	O
;	O
break	O
;	O
case	O
DW_OP_const2u	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
uvalue	long
,	O
data	pointer
,	O
2	int
,	O
end	pointer
)	O
;	O
printf	function
(	O
"DW_OP_const2u: %lu"	pointer
,	O
(	O
unsigned	O
long	O
)	O
uvalue	long
)	O
;	O
break	O
;	O
case	O
DW_OP_const2s	int
:	O
SAFE_SIGNED_BYTE_GET_AND_INC	O
(	O
svalue	long
,	O
data	pointer
,	O
2	int
,	O
end	pointer
)	O
;	O
printf	function
(	O
"DW_OP_const2s: %ld"	pointer
,	O
(	O
long	O
)	O
svalue	long
)	O
;	O
break	O
;	O
case	O
DW_OP_const4u	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
uvalue	long
,	O
data	pointer
,	O
4	int
,	O
end	pointer
)	O
;	O
printf	function
(	O
"DW_OP_const4u: %lu"	pointer
,	O
(	O
unsigned	O
long	O
)	O
uvalue	long
)	O
;	O
break	O
;	O
case	O
DW_OP_const4s	int
:	O
SAFE_SIGNED_BYTE_GET_AND_INC	O
(	O
svalue	long
,	O
data	pointer
,	O
4	int
,	O
end	pointer
)	O
;	O
printf	function
(	O
"DW_OP_const4s: %ld"	pointer
,	O
(	O
long	O
)	O
svalue	long
)	O
;	O
break	O
;	O
case	O
DW_OP_const8u	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
uvalue	long
,	O
data	pointer
,	O
4	int
,	O
end	pointer
)	O
;	O
printf	function
(	O
"DW_OP_const8u: %lu "	pointer
,	O
(	O
unsigned	O
long	O
)	O
uvalue	long
)	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
uvalue	long
,	O
data	pointer
,	O
4	int
,	O
end	pointer
)	O
;	O
printf	function
(	O
"%lu"	pointer
,	O
(	O
unsigned	O
long	O
)	O
uvalue	long
)	O
;	O
break	O
;	O
case	O
DW_OP_const8s	int
:	O
SAFE_SIGNED_BYTE_GET_AND_INC	O
(	O
svalue	long
,	O
data	pointer
,	O
4	int
,	O
end	pointer
)	O
;	O
printf	function
(	O
"DW_OP_const8s: %ld "	pointer
,	O
(	O
long	O
)	O
svalue	long
)	O
;	O
SAFE_SIGNED_BYTE_GET_AND_INC	O
(	O
svalue	long
,	O
data	pointer
,	O
4	int
,	O
end	pointer
)	O
;	O
printf	function
(	O
"%ld"	pointer
,	O
(	O
long	O
)	O
svalue	long
)	O
;	O
break	O
;	O
case	O
DW_OP_constu	int
:	O
READ_ULEB	O
(	O
uvalue	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"DW_OP_constu: %s"	pointer
,	O
dwarf_vmatoa	function
(	O
"u"	pointer
,	O
uvalue	long
)	O
)	O
;	O
break	O
;	O
case	O
DW_OP_consts	int
:	O
READ_SLEB	O
(	O
svalue	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"DW_OP_consts: %s"	pointer
,	O
dwarf_vmatoa	function
(	O
"d"	pointer
,	O
svalue	long
)	O
)	O
;	O
break	O
;	O
case	O
DW_OP_dup	int
:	O
printf	function
(	O
"DW_OP_dup"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_drop	int
:	O
printf	function
(	O
"DW_OP_drop"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_over	int
:	O
printf	function
(	O
"DW_OP_over"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_pick	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
uvalue	long
,	O
data	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
printf	function
(	O
"DW_OP_pick: %ld"	pointer
,	O
(	O
unsigned	O
long	O
)	O
uvalue	long
)	O
;	O
break	O
;	O
case	O
DW_OP_swap	int
:	O
printf	function
(	O
"DW_OP_swap"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_rot	int
:	O
printf	function
(	O
"DW_OP_rot"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_xderef	int
:	O
printf	function
(	O
"DW_OP_xderef"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_abs	int
:	O
printf	function
(	O
"DW_OP_abs"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_and	int
:	O
printf	function
(	O
"DW_OP_and"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_div	int
:	O
printf	function
(	O
"DW_OP_div"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_minus	int
:	O
printf	function
(	O
"DW_OP_minus"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_mod	int
:	O
printf	function
(	O
"DW_OP_mod"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_mul	int
:	O
printf	function
(	O
"DW_OP_mul"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_neg	int
:	O
printf	function
(	O
"DW_OP_neg"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_not	int
:	O
printf	function
(	O
"DW_OP_not"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_or	int
:	O
printf	function
(	O
"DW_OP_or"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_plus	int
:	O
printf	function
(	O
"DW_OP_plus"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_plus_uconst	int
:	O
READ_ULEB	O
(	O
uvalue	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"DW_OP_plus_uconst: %s"	pointer
,	O
dwarf_vmatoa	function
(	O
"u"	pointer
,	O
uvalue	long
)	O
)	O
;	O
break	O
;	O
case	O
DW_OP_shl	int
:	O
printf	function
(	O
"DW_OP_shl"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_shr	int
:	O
printf	function
(	O
"DW_OP_shr"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_shra	int
:	O
printf	function
(	O
"DW_OP_shra"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_xor	int
:	O
printf	function
(	O
"DW_OP_xor"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_bra	int
:	O
SAFE_SIGNED_BYTE_GET_AND_INC	O
(	O
svalue	long
,	O
data	pointer
,	O
2	int
,	O
end	pointer
)	O
;	O
printf	function
(	O
"DW_OP_bra: %ld"	pointer
,	O
(	O
long	O
)	O
svalue	long
)	O
;	O
break	O
;	O
case	O
DW_OP_eq	int
:	O
printf	function
(	O
"DW_OP_eq"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_ge	int
:	O
printf	function
(	O
"DW_OP_ge"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_gt	int
:	O
printf	function
(	O
"DW_OP_gt"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_le	int
:	O
printf	function
(	O
"DW_OP_le"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_lt	int
:	O
printf	function
(	O
"DW_OP_lt"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_ne	int
:	O
printf	function
(	O
"DW_OP_ne"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_skip	int
:	O
SAFE_SIGNED_BYTE_GET_AND_INC	O
(	O
svalue	long
,	O
data	pointer
,	O
2	int
,	O
end	pointer
)	O
;	O
printf	function
(	O
"DW_OP_skip: %ld"	pointer
,	O
(	O
long	O
)	O
svalue	long
)	O
;	O
break	O
;	O
case	O
DW_OP_lit0	int
:	O
case	O
DW_OP_lit1	int
:	O
case	O
DW_OP_lit2	int
:	O
case	O
DW_OP_lit3	int
:	O
case	O
DW_OP_lit4	int
:	O
case	O
DW_OP_lit5	int
:	O
case	O
DW_OP_lit6	int
:	O
case	O
DW_OP_lit7	int
:	O
case	O
DW_OP_lit8	int
:	O
case	O
DW_OP_lit9	int
:	O
case	O
DW_OP_lit10	int
:	O
case	O
DW_OP_lit11	int
:	O
case	O
DW_OP_lit12	int
:	O
case	O
DW_OP_lit13	int
:	O
case	O
DW_OP_lit14	int
:	O
case	O
DW_OP_lit15	int
:	O
case	O
DW_OP_lit16	int
:	O
case	O
DW_OP_lit17	int
:	O
case	O
DW_OP_lit18	int
:	O
case	O
DW_OP_lit19	int
:	O
case	O
DW_OP_lit20	int
:	O
case	O
DW_OP_lit21	int
:	O
case	O
DW_OP_lit22	int
:	O
case	O
DW_OP_lit23	int
:	O
case	O
DW_OP_lit24	int
:	O
case	O
DW_OP_lit25	int
:	O
case	O
DW_OP_lit26	int
:	O
case	O
DW_OP_lit27	int
:	O
case	O
DW_OP_lit28	int
:	O
case	O
DW_OP_lit29	int
:	O
case	O
DW_OP_lit30	int
:	O
case	O
DW_OP_lit31	int
:	O
printf	function
(	O
"DW_OP_lit%d"	pointer
,	O
op	int
-	O
DW_OP_lit0	int
)	O
;	O
break	O
;	O
case	O
DW_OP_reg0	int
:	O
case	O
DW_OP_reg1	int
:	O
case	O
DW_OP_reg2	int
:	O
case	O
DW_OP_reg3	int
:	O
case	O
DW_OP_reg4	int
:	O
case	O
DW_OP_reg5	int
:	O
case	O
DW_OP_reg6	int
:	O
case	O
DW_OP_reg7	int
:	O
case	O
DW_OP_reg8	int
:	O
case	O
DW_OP_reg9	int
:	O
case	O
DW_OP_reg10	int
:	O
case	O
DW_OP_reg11	int
:	O
case	O
DW_OP_reg12	int
:	O
case	O
DW_OP_reg13	int
:	O
case	O
DW_OP_reg14	int
:	O
case	O
DW_OP_reg15	int
:	O
case	O
DW_OP_reg16	int
:	O
case	O
DW_OP_reg17	int
:	O
case	O
DW_OP_reg18	int
:	O
case	O
DW_OP_reg19	int
:	O
case	O
DW_OP_reg20	int
:	O
case	O
DW_OP_reg21	int
:	O
case	O
DW_OP_reg22	int
:	O
case	O
DW_OP_reg23	int
:	O
case	O
DW_OP_reg24	int
:	O
case	O
DW_OP_reg25	int
:	O
case	O
DW_OP_reg26	int
:	O
case	O
DW_OP_reg27	int
:	O
case	O
DW_OP_reg28	int
:	O
case	O
DW_OP_reg29	int
:	O
case	O
DW_OP_reg30	int
:	O
case	O
DW_OP_reg31	int
:	O
printf	function
(	O
"DW_OP_reg%d (%s)"	pointer
,	O
op	int
-	O
DW_OP_reg0	int
,	O
regname	function
(	O
op	int
-	O
DW_OP_reg0	int
,	O
1	int
)	O
)	O
;	O
break	O
;	O
case	O
DW_OP_breg0	int
:	O
case	O
DW_OP_breg1	int
:	O
case	O
DW_OP_breg2	int
:	O
case	O
DW_OP_breg3	int
:	O
case	O
DW_OP_breg4	int
:	O
case	O
DW_OP_breg5	int
:	O
case	O
DW_OP_breg6	int
:	O
case	O
DW_OP_breg7	int
:	O
case	O
DW_OP_breg8	int
:	O
case	O
DW_OP_breg9	int
:	O
case	O
DW_OP_breg10	int
:	O
case	O
DW_OP_breg11	int
:	O
case	O
DW_OP_breg12	int
:	O
case	O
DW_OP_breg13	int
:	O
case	O
DW_OP_breg14	int
:	O
case	O
DW_OP_breg15	int
:	O
case	O
DW_OP_breg16	int
:	O
case	O
DW_OP_breg17	int
:	O
case	O
DW_OP_breg18	int
:	O
case	O
DW_OP_breg19	int
:	O
case	O
DW_OP_breg20	int
:	O
case	O
DW_OP_breg21	int
:	O
case	O
DW_OP_breg22	int
:	O
case	O
DW_OP_breg23	int
:	O
case	O
DW_OP_breg24	int
:	O
case	O
DW_OP_breg25	int
:	O
case	O
DW_OP_breg26	int
:	O
case	O
DW_OP_breg27	int
:	O
case	O
DW_OP_breg28	int
:	O
case	O
DW_OP_breg29	int
:	O
case	O
DW_OP_breg30	int
:	O
case	O
DW_OP_breg31	int
:	O
READ_SLEB	O
(	O
svalue	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"DW_OP_breg%d (%s): %s"	pointer
,	O
op	int
-	O
DW_OP_breg0	int
,	O
regname	function
(	O
op	int
-	O
DW_OP_breg0	int
,	O
1	int
)	O
,	O
dwarf_vmatoa	function
(	O
"d"	pointer
,	O
svalue	long
)	O
)	O
;	O
break	O
;	O
case	O
DW_OP_regx	int
:	O
READ_ULEB	O
(	O
uvalue	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"DW_OP_regx: %s (%s)"	pointer
,	O
dwarf_vmatoa	function
(	O
"u"	pointer
,	O
uvalue	long
)	O
,	O
regname	function
(	O
uvalue	long
,	O
1	int
)	O
)	O
;	O
break	O
;	O
case	O
DW_OP_fbreg	int
:	O
need_frame_base	int
=	O
1	int
;	O
READ_SLEB	O
(	O
svalue	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"DW_OP_fbreg: %s"	pointer
,	O
dwarf_vmatoa	function
(	O
"d"	pointer
,	O
svalue	long
)	O
)	O
;	O
break	O
;	O
case	O
DW_OP_bregx	int
:	O
READ_ULEB	O
(	O
uvalue	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
READ_SLEB	O
(	O
svalue	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"DW_OP_bregx: %s (%s) %s"	pointer
,	O
dwarf_vmatoa	function
(	O
"u"	pointer
,	O
uvalue	long
)	O
,	O
regname	function
(	O
uvalue	long
,	O
1	int
)	O
,	O
dwarf_vmatoa	function
(	O
"d"	pointer
,	O
svalue	long
)	O
)	O
;	O
break	O
;	O
case	O
DW_OP_piece	int
:	O
READ_ULEB	O
(	O
uvalue	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"DW_OP_piece: %s"	pointer
,	O
dwarf_vmatoa	function
(	O
"u"	pointer
,	O
uvalue	long
)	O
)	O
;	O
break	O
;	O
case	O
DW_OP_deref_size	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
uvalue	long
,	O
data	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
printf	function
(	O
"DW_OP_deref_size: %ld"	pointer
,	O
(	O
long	O
)	O
uvalue	long
)	O
;	O
break	O
;	O
case	O
DW_OP_xderef_size	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
uvalue	long
,	O
data	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
printf	function
(	O
"DW_OP_xderef_size: %ld"	pointer
,	O
(	O
long	O
)	O
uvalue	long
)	O
;	O
break	O
;	O
case	O
DW_OP_nop	int
:	O
printf	function
(	O
"DW_OP_nop"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_push_object_address	int
:	O
printf	function
(	O
"DW_OP_push_object_address"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_call2	int
:	O
SAFE_SIGNED_BYTE_GET_AND_INC	O
(	O
svalue	long
,	O
data	pointer
,	O
2	int
,	O
end	pointer
)	O
;	O
printf	function
(	O
"DW_OP_call2: <0x%s>"	pointer
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
svalue	long
+	O
cu_offset	long
)	O
)	O
;	O
break	O
;	O
case	O
DW_OP_call4	int
:	O
SAFE_SIGNED_BYTE_GET_AND_INC	O
(	O
svalue	long
,	O
data	pointer
,	O
4	int
,	O
end	pointer
)	O
;	O
printf	function
(	O
"DW_OP_call4: <0x%s>"	pointer
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
svalue	long
+	O
cu_offset	long
)	O
)	O
;	O
break	O
;	O
case	O
DW_OP_call_ref	int
:	O
if	O
(	O
dwarf_version	int
==	O
-	O
1	int
)	O
{	O
printf	function
(	O
_	O
(	O
"(DW_OP_call_ref in frame info)"	pointer
)	O
)	O
;	O
return	O
need_frame_base	int
;	O
}	O
if	O
(	O
dwarf_version	int
==	O
2	int
)	O
{	O
SAFE_BYTE_GET_AND_INC	O
(	O
uvalue	long
,	O
data	pointer
,	O
pointer_size	int
,	O
end	pointer
)	O
;	O
}	O
else	O
{	O
SAFE_BYTE_GET_AND_INC	O
(	O
uvalue	long
,	O
data	pointer
,	O
offset_size	int
,	O
end	pointer
)	O
;	O
}	O
printf	function
(	O
"DW_OP_call_ref: <0x%s>"	pointer
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
uvalue	long
)	O
)	O
;	O
break	O
;	O
case	O
DW_OP_form_tls_address	int
:	O
printf	function
(	O
"DW_OP_form_tls_address"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_call_frame_cfa	int
:	O
printf	function
(	O
"DW_OP_call_frame_cfa"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_bit_piece	int
:	O
printf	function
(	O
"DW_OP_bit_piece: "	pointer
)	O
;	O
READ_ULEB	O
(	O
uvalue	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"size: %s "	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"u"	pointer
,	O
uvalue	long
)	O
)	O
;	O
READ_ULEB	O
(	O
uvalue	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"offset: %s "	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"u"	pointer
,	O
uvalue	long
)	O
)	O
;	O
break	O
;	O
case	O
DW_OP_stack_value	int
:	O
printf	function
(	O
"DW_OP_stack_value"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_implicit_value	int
:	O
printf	function
(	O
"DW_OP_implicit_value"	pointer
)	O
;	O
READ_ULEB	O
(	O
uvalue	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
data	pointer
=	O
display_block	function
(	O
data	pointer
,	O
uvalue	long
,	O
end	pointer
,	O
' '	O
)	O
;	O
break	O
;	O
case	O
DW_OP_GNU_push_tls_address	int
:	O
printf	function
(	O
_	O
(	O
"DW_OP_GNU_push_tls_address or DW_OP_HP_unknown"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
DW_OP_GNU_uninit	int
:	O
printf	function
(	O
"DW_OP_GNU_uninit"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_GNU_encoded_addr	int
:	O
{	O
int	O
encoding	int
=	O
0	int
;	O
dwarf_vma	long
addr	pointer
;	O
if	O
(	O
data	pointer
<	O
end	pointer
)	O
encoding	int
=	O
*	O
data	pointer
++	O
;	O
addr	pointer
=	O
get_encoded_value	function
(	O
&	O
data	pointer
,	O
encoding	int
,	O
section	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"DW_OP_GNU_encoded_addr: fmt:%02x addr:"	pointer
,	O
encoding	int
)	O
;	O
print_dwarf_vma	function
(	O
addr	pointer
,	O
pointer_size	int
)	O
;	O
}	O
break	O
;	O
case	O
DW_OP_implicit_pointer	int
:	O
case	O
DW_OP_GNU_implicit_pointer	int
:	O
if	O
(	O
dwarf_version	int
==	O
-	O
1	int
)	O
{	O
printf	function
(	O
_	O
(	O
"(%s in frame info)"	pointer
)	O
,	O
(	O
op	int
==	O
DW_OP_implicit_pointer	int
?	O
"DW_OP_implicit_pointer"	pointer
:	O
"DW_OP_GNU_implicit_pointer"	pointer
)	O
)	O
;	O
return	O
need_frame_base	int
;	O
}	O
if	O
(	O
dwarf_version	int
==	O
2	int
)	O
{	O
SAFE_BYTE_GET_AND_INC	O
(	O
uvalue	long
,	O
data	pointer
,	O
pointer_size	int
,	O
end	pointer
)	O
;	O
}	O
else	O
{	O
SAFE_BYTE_GET_AND_INC	O
(	O
uvalue	long
,	O
data	pointer
,	O
offset_size	int
,	O
end	pointer
)	O
;	O
}	O
READ_SLEB	O
(	O
svalue	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"%s: <0x%s> %s"	pointer
,	O
(	O
op	int
==	O
DW_OP_implicit_pointer	int
?	O
"DW_OP_implicit_pointer"	pointer
:	O
"DW_OP_GNU_implicit_pointer"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
uvalue	long
)	O
,	O
dwarf_vmatoa	function
(	O
"d"	pointer
,	O
svalue	long
)	O
)	O
;	O
break	O
;	O
case	O
DW_OP_entry_value	int
:	O
case	O
DW_OP_GNU_entry_value	int
:	O
READ_ULEB	O
(	O
uvalue	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
uvalue	long
>	O
(	O
dwarf_vma	long
)	O
(	O
end	pointer
-	O
data	pointer
)	O
)	O
uvalue	long
=	O
end	pointer
-	O
data	pointer
;	O
printf	function
(	O
"%s: ("	pointer
,	O
(	O
op	int
==	O
DW_OP_entry_value	int
?	O
"DW_OP_entry_value"	pointer
:	O
"DW_OP_GNU_entry_value"	pointer
)	O
)	O
;	O
if	O
(	O
decode_location_expression	function
(	O
data	pointer
,	O
pointer_size	int
,	O
offset_size	int
,	O
dwarf_version	int
,	O
uvalue	long
,	O
cu_offset	long
,	O
section	pointer
)	O
)	O
need_frame_base	int
=	O
1	int
;	O
putchar	function
(	O
')'	O
)	O
;	O
data	pointer
+=	O
uvalue	long
;	O
if	O
(	O
data	pointer
>	O
end	pointer
)	O
data	pointer
=	O
end	pointer
;	O
break	O
;	O
case	O
DW_OP_const_type	int
:	O
case	O
DW_OP_GNU_const_type	int
:	O
READ_ULEB	O
(	O
uvalue	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"%s: <0x%s> "	pointer
,	O
(	O
op	int
==	O
DW_OP_const_type	int
?	O
"DW_OP_const_type"	pointer
:	O
"DW_OP_GNU_const_type"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
cu_offset	long
+	O
uvalue	long
)	O
)	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
uvalue	long
,	O
data	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
data	pointer
=	O
display_block	function
(	O
data	pointer
,	O
uvalue	long
,	O
end	pointer
,	O
' '	O
)	O
;	O
break	O
;	O
case	O
DW_OP_regval_type	int
:	O
case	O
DW_OP_GNU_regval_type	int
:	O
READ_ULEB	O
(	O
uvalue	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"%s: %s (%s)"	pointer
,	O
(	O
op	int
==	O
DW_OP_regval_type	int
?	O
"DW_OP_regval_type"	pointer
:	O
"DW_OP_GNU_regval_type"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"u"	pointer
,	O
uvalue	long
)	O
,	O
regname	function
(	O
uvalue	long
,	O
1	int
)	O
)	O
;	O
READ_ULEB	O
(	O
uvalue	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
" <0x%s>"	pointer
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
cu_offset	long
+	O
uvalue	long
)	O
)	O
;	O
break	O
;	O
case	O
DW_OP_deref_type	int
:	O
case	O
DW_OP_GNU_deref_type	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
uvalue	long
,	O
data	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
printf	function
(	O
"%s: %ld"	pointer
,	O
(	O
op	int
==	O
DW_OP_deref_type	int
?	O
"DW_OP_deref_type"	pointer
:	O
"DW_OP_GNU_deref_type"	pointer
)	O
,	O
(	O
long	O
)	O
uvalue	long
)	O
;	O
READ_ULEB	O
(	O
uvalue	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
" <0x%s>"	pointer
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
cu_offset	long
+	O
uvalue	long
)	O
)	O
;	O
break	O
;	O
case	O
DW_OP_convert	int
:	O
case	O
DW_OP_GNU_convert	int
:	O
READ_ULEB	O
(	O
uvalue	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"%s <0x%s>"	pointer
,	O
(	O
op	int
==	O
DW_OP_convert	int
?	O
"DW_OP_convert"	pointer
:	O
"DW_OP_GNU_convert"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
uvalue	long
?	O
cu_offset	long
+	O
uvalue	long
:	O
0	int
)	O
)	O
;	O
break	O
;	O
case	O
DW_OP_reinterpret	int
:	O
case	O
DW_OP_GNU_reinterpret	int
:	O
READ_ULEB	O
(	O
uvalue	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"%s <0x%s>"	pointer
,	O
(	O
op	int
==	O
DW_OP_reinterpret	int
?	O
"DW_OP_reinterpret"	pointer
:	O
"DW_OP_GNU_reinterpret"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
uvalue	long
?	O
cu_offset	long
+	O
uvalue	long
:	O
0	int
)	O
)	O
;	O
break	O
;	O
case	O
DW_OP_GNU_parameter_ref	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
uvalue	long
,	O
data	pointer
,	O
4	int
,	O
end	pointer
)	O
;	O
printf	function
(	O
"DW_OP_GNU_parameter_ref: <0x%s>"	pointer
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
cu_offset	long
+	O
uvalue	long
)	O
)	O
;	O
break	O
;	O
case	O
DW_OP_GNU_addr_index	int
:	O
READ_ULEB	O
(	O
uvalue	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"DW_OP_GNU_addr_index <0x%s>"	pointer
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
uvalue	long
)	O
)	O
;	O
break	O
;	O
case	O
DW_OP_GNU_const_index	int
:	O
READ_ULEB	O
(	O
uvalue	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"DW_OP_GNU_const_index <0x%s>"	pointer
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
uvalue	long
)	O
)	O
;	O
break	O
;	O
case	O
DW_OP_GNU_variable_value	int
:	O
if	O
(	O
dwarf_version	int
==	O
-	O
1	int
)	O
{	O
printf	function
(	O
_	O
(	O
"(DW_OP_GNU_variable_value in frame info)"	pointer
)	O
)	O
;	O
return	O
need_frame_base	int
;	O
}	O
if	O
(	O
dwarf_version	int
==	O
2	int
)	O
{	O
SAFE_BYTE_GET_AND_INC	O
(	O
uvalue	long
,	O
data	pointer
,	O
pointer_size	int
,	O
end	pointer
)	O
;	O
}	O
else	O
{	O
SAFE_BYTE_GET_AND_INC	O
(	O
uvalue	long
,	O
data	pointer
,	O
offset_size	int
,	O
end	pointer
)	O
;	O
}	O
printf	function
(	O
"DW_OP_GNU_variable_value: <0x%s>"	pointer
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
uvalue	long
)	O
)	O
;	O
break	O
;	O
case	O
DW_OP_HP_is_value	int
:	O
printf	function
(	O
"DW_OP_HP_is_value"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_HP_fltconst4	int
:	O
printf	function
(	O
"DW_OP_HP_fltconst4"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_HP_fltconst8	int
:	O
printf	function
(	O
"DW_OP_HP_fltconst8"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_HP_mod_range	int
:	O
printf	function
(	O
"DW_OP_HP_mod_range"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_HP_unmod_range	int
:	O
printf	function
(	O
"DW_OP_HP_unmod_range"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_HP_tls	int
:	O
printf	function
(	O
"DW_OP_HP_tls"	pointer
)	O
;	O
break	O
;	O
case	O
DW_OP_PGI_omp_thread_num	int
:	O
printf	function
(	O
"DW_OP_PGI_omp_thread_num"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
op	int
>=	O
DW_OP_lo_user	int
&&	O
op	int
<=	O
DW_OP_hi_user	int
)	O
printf	function
(	O
_	O
(	O
"(User defined location op 0x%x)"	pointer
)	O
,	O
op	int
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"(Unknown location op 0x%x)"	pointer
)	O
,	O
op	int
)	O
;	O
return	O
need_frame_base	int
;	O
}	O
if	O
(	O
data	pointer
<	O
end	pointer
)	O
printf	function
(	O
"; "	pointer
)	O
;	O
}	O
return	O
need_frame_base	int
;	O
}	O
static	O
struct	O
cu_tu_set	struct
*	O
find_cu_tu_set_v2	function
(	O
dwarf_vma	long
cu_offset	long
,	O
int	O
do_types	int
)	O
{	O
struct	O
cu_tu_set	struct
*	O
p	pointer
;	O
unsigned	O
int	O
nsets	int
;	O
unsigned	O
int	O
dw_sect	int
;	O
if	O
(	O
do_types	int
)	O
{	O
p	pointer
=	O
tu_sets	pointer
;	O
nsets	int
=	O
tu_count	int
;	O
dw_sect	int
=	O
DW_SECT_TYPES	int
;	O
}	O
else	O
{	O
p	pointer
=	O
cu_sets	pointer
;	O
nsets	int
=	O
cu_count	int
;	O
dw_sect	int
=	O
DW_SECT_INFO	int
;	O
}	O
while	O
(	O
nsets	int
>	O
0	int
)	O
{	O
if	O
(	O
p	pointer
->	O
section_offsets	array
[	O
dw_sect	int
]	O
==	O
cu_offset	long
)	O
return	O
p	pointer
;	O
p	pointer
++	O
;	O
nsets	int
--	O
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
void	O
add64	function
(	O
dwarf_vma	long
*	O
high_bits	pointer
,	O
dwarf_vma	long
*	O
low_bits	pointer
,	O
dwarf_vma	long
inc	long
)	O
{	O
dwarf_vma	long
tmp	long
=	O
*	O
low_bits	pointer
;	O
tmp	long
+=	O
inc	long
;	O
if	O
(	O
tmp	long
<	O
*	O
low_bits	pointer
)	O
{	O
++	O
*	O
high_bits	pointer
;	O
}	O
else	O
if	O
(	O
sizeof	O
(	O
tmp	long
)	O
>	O
8	int
&&	O
(	O
tmp	long
>>	O
31	int
)	O
>	O
1	int
)	O
{	O
++	O
*	O
high_bits	pointer
;	O
tmp	long
&=	O
0xFFFFFFFF	int
;	O
}	O
*	O
low_bits	pointer
=	O
tmp	long
;	O
}	O
static	O
const	O
char	O
*	O
fetch_alt_indirect_string	function
(	O
dwarf_vma	long
offset	long
)	O
{	O
separate_info	struct
*	O
i	pointer
;	O
if	O
(	O
!	O
do_follow_links	int
)	O
return	O
""	pointer
;	O
if	O
(	O
first_separate_info	pointer
==	O
NULL	O
)	O
return	O
_	O
(	O
"<no links available>"	pointer
)	O
;	O
for	O
(	O
i	pointer
=	O
first_separate_info	pointer
;	O
i	pointer
!=	O
NULL	O
;	O
i	pointer
=	O
i	pointer
->	O
next	pointer
)	O
{	O
struct	O
dwarf_section	struct
*	O
section	pointer
;	O
const	O
char	O
*	O
ret	pointer
;	O
if	O
(	O
!	O
load_debug_section	function
(	O
separate_debug_str	int
,	O
i	pointer
->	O
handle	pointer
)	O
)	O
continue	O
;	O
section	pointer
=	O
&	O
debug_displays	array
[	O
separate_debug_str	int
]	O
.	O
section	pointer
;	O
if	O
(	O
section	pointer
->	O
start	pointer
==	O
NULL	O
)	O
continue	O
;	O
if	O
(	O
offset	long
>=	O
section	pointer
->	O
size	int
)	O
continue	O
;	O
ret	pointer
=	O
(	O
const	O
char	O
*	O
)	O
(	O
section	pointer
->	O
start	pointer
+	O
offset	long
)	O
;	O
if	O
(	O
strnlen	function
(	O
(	O
const	O
char	O
*	O
)	O
ret	pointer
,	O
section	pointer
->	O
size	int
-	O
offset	long
)	O
==	O
section	pointer
->	O
size	int
-	O
offset	long
)	O
return	O
_	O
(	O
"<no NUL byte at end of alt .debug_str section>"	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
warn	function
(	O
_	O
(	O
"DW_FORM_GNU_strp_alt offset (%s) too big or no string sections available\n"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
offset	long
)	O
)	O
;	O
return	O
_	O
(	O
"<offset is too big>"	pointer
)	O
;	O
}	O
static	O
const	O
char	O
*	O
get_AT_name	function
(	O
unsigned	O
long	O
attribute	long
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
if	O
(	O
attribute	long
==	O
0	int
)	O
return	O
"DW_AT value: 0"	pointer
;	O
if	O
(	O
attribute	long
==	O
DW_AT_MIPS_fde	int
)	O
return	O
"DW_AT_MIPS_fde or DW_AT_HP_unmodifiable"	pointer
;	O
name	pointer
=	O
get_DW_AT_name	function
(	O
attribute	long
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
{	O
static	O
char	O
buffer	array
[	O
100	int
]	O
;	O
snprintf	function
(	O
buffer	array
,	O
sizeof	O
(	O
buffer	array
)	O
,	O
_	O
(	O
"Unknown AT value: %lx"	pointer
)	O
,	O
attribute	long
)	O
;	O
return	O
buffer	array
;	O
}	O
return	O
name	pointer
;	O
}	O
static	O
void	O
add_dwo_info	function
(	O
const	O
char	O
*	O
field	pointer
,	O
dwo_type	enum
type	enum
)	O
{	O
dwo_info	struct
*	O
dwinfo	pointer
=	O
xmalloc	function
(	O
sizeof	O
*	O
dwinfo	pointer
)	O
;	O
dwinfo	pointer
->	O
type	enum
=	O
type	enum
;	O
dwinfo	pointer
->	O
value	long
=	O
field	pointer
;	O
dwinfo	pointer
->	O
next	pointer
=	O
first_dwo_info	pointer
;	O
first_dwo_info	pointer
=	O
dwinfo	pointer
;	O
}	O
static	O
void	O
add_dwo_name	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
add_dwo_info	function
(	O
name	pointer
,	O
DWO_NAME	int
)	O
;	O
}	O
static	O
void	O
add_dwo_dir	function
(	O
const	O
char	O
*	O
dir	pointer
)	O
{	O
add_dwo_info	function
(	O
dir	pointer
,	O
DWO_DIR	int
)	O
;	O
}	O
static	O
void	O
add_dwo_id	function
(	O
const	O
char	O
*	O
id	int
)	O
{	O
add_dwo_info	function
(	O
id	int
,	O
DWO_ID	int
)	O
;	O
}	O
static	O
void	O
free_dwo_info	function
(	O
void	O
)	O
{	O
dwo_info	struct
*	O
dwinfo	pointer
;	O
dwo_info	struct
*	O
next	pointer
;	O
for	O
(	O
dwinfo	pointer
=	O
first_dwo_info	pointer
;	O
dwinfo	pointer
!=	O
NULL	O
;	O
dwinfo	pointer
=	O
next	pointer
)	O
{	O
next	pointer
=	O
dwinfo	pointer
->	O
next	pointer
;	O
free	function
(	O
dwinfo	pointer
)	O
;	O
}	O
first_dwo_info	pointer
=	O
NULL	O
;	O
}	O
static	O
inline	O
dwarf_vma	long
check_uvalue	function
(	O
const	O
unsigned	O
char	O
*	O
start	pointer
,	O
dwarf_vma	long
uvalue	long
,	O
const	O
unsigned	O
char	O
*	O
end	pointer
)	O
{	O
dwarf_vma	long
max_uvalue	long
=	O
end	pointer
-	O
start	pointer
;	O
if	O
(	O
uvalue	long
>	O
max_uvalue	long
)	O
{	O
warn	function
(	O
_	O
(	O
"Corrupt attribute block length: %lx\n"	pointer
)	O
,	O
(	O
long	O
)	O
uvalue	long
)	O
;	O
uvalue	long
=	O
max_uvalue	long
;	O
}	O
return	O
uvalue	long
;	O
}	O
static	O
unsigned	O
char	O
*	O
skip_attr_bytes	function
(	O
unsigned	O
long	O
form	int
,	O
unsigned	O
char	O
*	O
data	pointer
,	O
unsigned	O
const	O
char	O
*	O
end	pointer
,	O
dwarf_vma	long
pointer_size	int
,	O
dwarf_vma	long
offset_size	int
,	O
int	O
dwarf_version	int
,	O
dwarf_vma	long
*	O
value_return	pointer
)	O
{	O
dwarf_signed_vma	long
svalue	long
;	O
dwarf_vma	long
uvalue	long
=	O
0	int
;	O
*	O
value_return	pointer
=	O
0	int
;	O
switch	O
(	O
form	int
)	O
{	O
case	O
DW_FORM_ref_addr	int
:	O
if	O
(	O
dwarf_version	int
==	O
2	int
)	O
SAFE_BYTE_GET_AND_INC	O
(	O
uvalue	long
,	O
data	pointer
,	O
pointer_size	int
,	O
end	pointer
)	O
;	O
else	O
if	O
(	O
dwarf_version	int
==	O
3	int
||	O
dwarf_version	int
==	O
4	int
)	O
SAFE_BYTE_GET_AND_INC	O
(	O
uvalue	long
,	O
data	pointer
,	O
offset_size	int
,	O
end	pointer
)	O
;	O
else	O
return	O
NULL	O
;	O
break	O
;	O
case	O
DW_FORM_addr	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
uvalue	long
,	O
data	pointer
,	O
pointer_size	int
,	O
end	pointer
)	O
;	O
break	O
;	O
case	O
DW_FORM_strp	int
:	O
case	O
DW_FORM_line_strp	int
:	O
case	O
DW_FORM_sec_offset	int
:	O
case	O
DW_FORM_GNU_ref_alt	int
:	O
case	O
DW_FORM_GNU_strp_alt	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
uvalue	long
,	O
data	pointer
,	O
offset_size	int
,	O
end	pointer
)	O
;	O
break	O
;	O
case	O
DW_FORM_flag_present	int
:	O
uvalue	long
=	O
1	int
;	O
break	O
;	O
case	O
DW_FORM_ref1	int
:	O
case	O
DW_FORM_flag	int
:	O
case	O
DW_FORM_data1	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
uvalue	long
,	O
data	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
break	O
;	O
case	O
DW_FORM_ref2	int
:	O
case	O
DW_FORM_data2	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
uvalue	long
,	O
data	pointer
,	O
2	int
,	O
end	pointer
)	O
;	O
break	O
;	O
case	O
DW_FORM_ref4	int
:	O
case	O
DW_FORM_data4	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
uvalue	long
,	O
data	pointer
,	O
4	int
,	O
end	pointer
)	O
;	O
break	O
;	O
case	O
DW_FORM_sdata	int
:	O
READ_SLEB	O
(	O
svalue	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
uvalue	long
=	O
svalue	long
;	O
break	O
;	O
case	O
DW_FORM_ref_udata	int
:	O
case	O
DW_FORM_udata	int
:	O
case	O
DW_FORM_GNU_str_index	int
:	O
case	O
DW_FORM_GNU_addr_index	int
:	O
READ_ULEB	O
(	O
uvalue	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
break	O
;	O
case	O
DW_FORM_ref8	int
:	O
case	O
DW_FORM_data8	int
:	O
data	pointer
+=	O
8	int
;	O
break	O
;	O
case	O
DW_FORM_data16	int
:	O
data	pointer
+=	O
16	int
;	O
break	O
;	O
case	O
DW_FORM_string	int
:	O
data	pointer
+=	O
strnlen	function
(	O
(	O
char	O
*	O
)	O
data	pointer
,	O
end	pointer
-	O
data	pointer
)	O
+	O
1	int
;	O
break	O
;	O
case	O
DW_FORM_block	int
:	O
case	O
DW_FORM_exprloc	int
:	O
READ_ULEB	O
(	O
uvalue	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
break	O
;	O
case	O
DW_FORM_block1	int
:	O
SAFE_BYTE_GET	O
(	O
uvalue	long
,	O
data	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
data	pointer
+=	O
1	int
+	O
uvalue	long
;	O
break	O
;	O
case	O
DW_FORM_block2	int
:	O
SAFE_BYTE_GET	O
(	O
uvalue	long
,	O
data	pointer
,	O
2	int
,	O
end	pointer
)	O
;	O
data	pointer
+=	O
2	int
+	O
uvalue	long
;	O
break	O
;	O
case	O
DW_FORM_block4	int
:	O
SAFE_BYTE_GET	O
(	O
uvalue	long
,	O
data	pointer
,	O
4	int
,	O
end	pointer
)	O
;	O
data	pointer
+=	O
4	int
+	O
uvalue	long
;	O
break	O
;	O
case	O
DW_FORM_ref_sig8	int
:	O
data	pointer
+=	O
8	int
;	O
break	O
;	O
case	O
DW_FORM_indirect	int
:	O
default	O
:	O
return	O
NULL	O
;	O
}	O
*	O
value_return	pointer
=	O
uvalue	long
;	O
if	O
(	O
data	pointer
>	O
end	pointer
)	O
data	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
end	pointer
;	O
return	O
data	pointer
;	O
}	O
static	O
void	O
get_type_signedness	function
(	O
unsigned	O
char	O
*	O
start	pointer
,	O
unsigned	O
char	O
*	O
data	pointer
,	O
unsigned	O
const	O
char	O
*	O
end	pointer
,	O
dwarf_vma	long
pointer_size	int
,	O
dwarf_vma	long
offset_size	int
,	O
int	O
dwarf_version	int
,	O
bfd_boolean	int
*	O
is_signed	pointer
,	O
bfd_boolean	int
is_nested	int
)	O
{	O
unsigned	O
long	O
abbrev_number	long
;	O
abbrev_entry	struct
*	O
entry	long
;	O
abbrev_attr	struct
*	O
attr	int
;	O
*	O
is_signed	pointer
=	O
FALSE	int
;	O
READ_ULEB	O
(	O
abbrev_number	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
for	O
(	O
entry	long
=	O
first_abbrev	pointer
;	O
entry	long
!=	O
NULL	O
&&	O
entry	long
->	O
entry	long
!=	O
abbrev_number	long
;	O
entry	long
=	O
entry	long
->	O
next	pointer
)	O
continue	O
;	O
if	O
(	O
entry	long
==	O
NULL	O
)	O
return	O
;	O
for	O
(	O
attr	int
=	O
entry	long
->	O
first_attr	pointer
;	O
attr	int
!=	O
NULL	O
&&	O
attr	int
->	O
attribute	long
;	O
attr	int
=	O
attr	int
->	O
next	pointer
)	O
{	O
dwarf_vma	long
uvalue	long
=	O
0	int
;	O
data	pointer
=	O
skip_attr_bytes	function
(	O
attr	int
->	O
form	int
,	O
data	pointer
,	O
end	pointer
,	O
pointer_size	int
,	O
offset_size	int
,	O
dwarf_version	int
,	O
&	O
uvalue	long
)	O
;	O
if	O
(	O
data	pointer
==	O
NULL	O
)	O
return	O
;	O
switch	O
(	O
attr	int
->	O
attribute	long
)	O
{	O
case	O
DW_AT_type	int
:	O
if	O
(	O
is_nested	int
)	O
{	O
return	O
;	O
}	O
if	O
(	O
uvalue	long
>=	O
(	O
size_t	long
)	O
(	O
end	pointer
-	O
start	pointer
)	O
)	O
return	O
;	O
get_type_signedness	function
(	O
start	pointer
,	O
start	pointer
+	O
uvalue	long
,	O
end	pointer
,	O
pointer_size	int
,	O
offset_size	int
,	O
dwarf_version	int
,	O
is_signed	pointer
,	O
TRUE	int
)	O
;	O
break	O
;	O
case	O
DW_AT_encoding	int
:	O
switch	O
(	O
uvalue	long
)	O
{	O
case	O
DW_ATE_address	int
:	O
case	O
DW_ATE_boolean	int
:	O
case	O
DW_ATE_unsigned	int
:	O
case	O
DW_ATE_unsigned_char	int
:	O
case	O
DW_ATE_unsigned_fixed	int
:	O
*	O
is_signed	pointer
=	O
FALSE	int
;	O
break	O
;	O
default	O
:	O
case	O
DW_ATE_complex_float	int
:	O
case	O
DW_ATE_float	int
:	O
case	O
DW_ATE_signed	int
:	O
case	O
DW_ATE_signed_char	int
:	O
case	O
DW_ATE_imaginary_float	int
:	O
case	O
DW_ATE_decimal_float	int
:	O
case	O
DW_ATE_signed_fixed	int
:	O
*	O
is_signed	pointer
=	O
TRUE	int
;	O
break	O
;	O
}	O
break	O
;	O
}	O
}	O
}	O
static	O
void	O
read_and_print_leb128	function
(	O
unsigned	O
char	O
*	O
data	pointer
,	O
unsigned	O
int	O
*	O
bytes_read	pointer
,	O
unsigned	O
const	O
char	O
*	O
end	pointer
,	O
bfd_boolean	int
is_signed	pointer
)	O
{	O
int	O
status	int
;	O
dwarf_vma	long
val	array
=	O
read_leb128	function
(	O
data	pointer
,	O
end	pointer
,	O
is_signed	pointer
,	O
bytes_read	pointer
,	O
&	O
status	int
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
report_leb_status	function
(	O
status	int
)	O
;	O
else	O
printf	function
(	O
"%s"	pointer
,	O
dwarf_vmatoa	function
(	O
is_signed	pointer
?	O
"d"	pointer
:	O
"u"	pointer
,	O
val	array
)	O
)	O
;	O
}	O
static	O
void	O
display_discr_list	function
(	O
unsigned	O
long	O
form	int
,	O
dwarf_vma	long
uvalue	long
,	O
unsigned	O
char	O
*	O
data	pointer
,	O
unsigned	O
const	O
char	O
*	O
end	pointer
,	O
int	O
level	int
)	O
{	O
if	O
(	O
uvalue	long
==	O
0	int
)	O
{	O
printf	function
(	O
"[default]"	pointer
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
form	int
)	O
{	O
case	O
DW_FORM_block	int
:	O
case	O
DW_FORM_block1	int
:	O
case	O
DW_FORM_block2	int
:	O
case	O
DW_FORM_block4	int
:	O
data	pointer
-=	O
uvalue	long
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
"<corrupt>\n"	pointer
)	O
;	O
warn	function
(	O
_	O
(	O
"corrupt discr_list - not using a block form\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
uvalue	long
<	O
2	int
)	O
{	O
printf	function
(	O
"<corrupt>\n"	pointer
)	O
;	O
warn	function
(	O
_	O
(	O
"corrupt discr_list - block not long enough\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
bfd_boolean	int
is_signed	pointer
=	O
(	O
level	int
>	O
0	int
&&	O
level	int
<=	O
MAX_CU_NESTING	O
)	O
?	O
level_type_signed	array
[	O
level	int
-	O
1	int
]	O
:	O
FALSE	int
;	O
printf	function
(	O
"("	pointer
)	O
;	O
while	O
(	O
uvalue	long
)	O
{	O
unsigned	O
char	O
discriminant	char
;	O
unsigned	O
int	O
bytes_read	pointer
;	O
SAFE_BYTE_GET	O
(	O
discriminant	char
,	O
data	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
--	O
uvalue	long
;	O
data	pointer
++	O
;	O
assert	O
(	O
uvalue	long
>	O
0	int
)	O
;	O
switch	O
(	O
discriminant	char
)	O
{	O
case	O
DW_DSC_label	int
:	O
printf	function
(	O
"label "	pointer
)	O
;	O
read_and_print_leb128	function
(	O
data	pointer
,	O
&	O
bytes_read	pointer
,	O
end	pointer
,	O
is_signed	pointer
)	O
;	O
assert	O
(	O
bytes_read	pointer
<=	O
uvalue	long
&&	O
bytes_read	pointer
>	O
0	int
)	O
;	O
uvalue	long
-=	O
bytes_read	pointer
;	O
data	pointer
+=	O
bytes_read	pointer
;	O
break	O
;	O
case	O
DW_DSC_range	int
:	O
printf	function
(	O
"range "	pointer
)	O
;	O
read_and_print_leb128	function
(	O
data	pointer
,	O
&	O
bytes_read	pointer
,	O
end	pointer
,	O
is_signed	pointer
)	O
;	O
assert	O
(	O
bytes_read	pointer
<=	O
uvalue	long
&&	O
bytes_read	pointer
>	O
0	int
)	O
;	O
uvalue	long
-=	O
bytes_read	pointer
;	O
data	pointer
+=	O
bytes_read	pointer
;	O
printf	function
(	O
".."	pointer
)	O
;	O
read_and_print_leb128	function
(	O
data	pointer
,	O
&	O
bytes_read	pointer
,	O
end	pointer
,	O
is_signed	pointer
)	O
;	O
assert	O
(	O
bytes_read	pointer
<=	O
uvalue	long
&&	O
bytes_read	pointer
>	O
0	int
)	O
;	O
uvalue	long
-=	O
bytes_read	pointer
;	O
data	pointer
+=	O
bytes_read	pointer
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
"<corrupt>\n"	pointer
)	O
;	O
warn	function
(	O
_	O
(	O
"corrupt discr_list - unrecognised discriminant byte %#x\n"	pointer
)	O
,	O
discriminant	char
)	O
;	O
return	O
;	O
}	O
if	O
(	O
uvalue	long
)	O
printf	function
(	O
", "	pointer
)	O
;	O
}	O
if	O
(	O
is_signed	pointer
)	O
printf	function
(	O
")(signed)"	pointer
)	O
;	O
else	O
printf	function
(	O
")(unsigned)"	pointer
)	O
;	O
}	O
static	O
unsigned	O
char	O
*	O
read_and_display_attr_value	function
(	O
unsigned	O
long	O
attribute	long
,	O
unsigned	O
long	O
form	int
,	O
dwarf_signed_vma	long
implicit_const	long
,	O
unsigned	O
char	O
*	O
start	pointer
,	O
unsigned	O
char	O
*	O
data	pointer
,	O
unsigned	O
char	O
*	O
end	pointer
,	O
dwarf_vma	long
cu_offset	long
,	O
dwarf_vma	long
pointer_size	int
,	O
dwarf_vma	long
offset_size	int
,	O
int	O
dwarf_version	int
,	O
debug_info	struct
*	O
debug_info_p	pointer
,	O
int	O
do_loc	int
,	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
struct	O
cu_tu_set	struct
*	O
this_set	pointer
,	O
char	O
delimiter	char
,	O
int	O
level	int
)	O
{	O
dwarf_signed_vma	long
svalue	long
;	O
dwarf_vma	long
uvalue	long
=	O
0	int
;	O
unsigned	O
char	O
*	O
block_start	pointer
=	O
NULL	O
;	O
unsigned	O
char	O
*	O
orig_data	pointer
=	O
data	pointer
;	O
if	O
(	O
data	pointer
>	O
end	pointer
||	O
(	O
data	pointer
==	O
end	pointer
&&	O
form	int
!=	O
DW_FORM_flag_present	int
)	O
)	O
{	O
warn	function
(	O
_	O
(	O
"Corrupt attribute\n"	pointer
)	O
)	O
;	O
return	O
data	pointer
;	O
}	O
switch	O
(	O
form	int
)	O
{	O
default	O
:	O
break	O
;	O
case	O
DW_FORM_ref_addr	int
:	O
if	O
(	O
dwarf_version	int
==	O
2	int
)	O
SAFE_BYTE_GET_AND_INC	O
(	O
uvalue	long
,	O
data	pointer
,	O
pointer_size	int
,	O
end	pointer
)	O
;	O
else	O
if	O
(	O
dwarf_version	int
==	O
3	int
||	O
dwarf_version	int
==	O
4	int
)	O
SAFE_BYTE_GET_AND_INC	O
(	O
uvalue	long
,	O
data	pointer
,	O
offset_size	int
,	O
end	pointer
)	O
;	O
else	O
error	function
(	O
_	O
(	O
"Internal error: DWARF version is not 2, 3 or 4.\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
DW_FORM_addr	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
uvalue	long
,	O
data	pointer
,	O
pointer_size	int
,	O
end	pointer
)	O
;	O
break	O
;	O
case	O
DW_FORM_strp	int
:	O
case	O
DW_FORM_line_strp	int
:	O
case	O
DW_FORM_sec_offset	int
:	O
case	O
DW_FORM_GNU_ref_alt	int
:	O
case	O
DW_FORM_GNU_strp_alt	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
uvalue	long
,	O
data	pointer
,	O
offset_size	int
,	O
end	pointer
)	O
;	O
break	O
;	O
case	O
DW_FORM_flag_present	int
:	O
uvalue	long
=	O
1	int
;	O
break	O
;	O
case	O
DW_FORM_ref1	int
:	O
case	O
DW_FORM_flag	int
:	O
case	O
DW_FORM_data1	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
uvalue	long
,	O
data	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
break	O
;	O
case	O
DW_FORM_ref2	int
:	O
case	O
DW_FORM_data2	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
uvalue	long
,	O
data	pointer
,	O
2	int
,	O
end	pointer
)	O
;	O
break	O
;	O
case	O
DW_FORM_ref4	int
:	O
case	O
DW_FORM_data4	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
uvalue	long
,	O
data	pointer
,	O
4	int
,	O
end	pointer
)	O
;	O
break	O
;	O
case	O
DW_FORM_sdata	int
:	O
READ_SLEB	O
(	O
svalue	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
uvalue	long
=	O
svalue	long
;	O
break	O
;	O
case	O
DW_FORM_GNU_str_index	int
:	O
case	O
DW_FORM_ref_udata	int
:	O
case	O
DW_FORM_udata	int
:	O
case	O
DW_FORM_GNU_addr_index	int
:	O
READ_ULEB	O
(	O
uvalue	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
break	O
;	O
case	O
DW_FORM_indirect	int
:	O
READ_ULEB	O
(	O
form	int
,	O
data	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
!	O
do_loc	int
)	O
printf	function
(	O
"%c%s"	pointer
,	O
delimiter	char
,	O
get_FORM_name	function
(	O
form	int
)	O
)	O
;	O
if	O
(	O
form	int
==	O
DW_FORM_implicit_const	int
)	O
READ_SLEB	O
(	O
implicit_const	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
return	O
read_and_display_attr_value	function
(	O
attribute	long
,	O
form	int
,	O
implicit_const	long
,	O
start	pointer
,	O
data	pointer
,	O
end	pointer
,	O
cu_offset	long
,	O
pointer_size	int
,	O
offset_size	int
,	O
dwarf_version	int
,	O
debug_info_p	pointer
,	O
do_loc	int
,	O
section	pointer
,	O
this_set	pointer
,	O
delimiter	char
,	O
level	int
)	O
;	O
}	O
switch	O
(	O
form	int
)	O
{	O
case	O
DW_FORM_ref_addr	int
:	O
if	O
(	O
!	O
do_loc	int
)	O
printf	function
(	O
"%c<0x%s>"	pointer
,	O
delimiter	char
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
uvalue	long
)	O
)	O
;	O
break	O
;	O
case	O
DW_FORM_GNU_ref_alt	int
:	O
if	O
(	O
!	O
do_loc	int
)	O
printf	function
(	O
"%c<alt 0x%s>"	pointer
,	O
delimiter	char
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
uvalue	long
)	O
)	O
;	O
break	O
;	O
case	O
DW_FORM_ref1	int
:	O
case	O
DW_FORM_ref2	int
:	O
case	O
DW_FORM_ref4	int
:	O
case	O
DW_FORM_ref_udata	int
:	O
if	O
(	O
!	O
do_loc	int
)	O
printf	function
(	O
"%c<0x%s>"	pointer
,	O
delimiter	char
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
uvalue	long
+	O
cu_offset	long
)	O
)	O
;	O
break	O
;	O
case	O
DW_FORM_data4	int
:	O
case	O
DW_FORM_addr	int
:	O
case	O
DW_FORM_sec_offset	int
:	O
if	O
(	O
!	O
do_loc	int
)	O
printf	function
(	O
"%c0x%s"	pointer
,	O
delimiter	char
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
uvalue	long
)	O
)	O
;	O
break	O
;	O
case	O
DW_FORM_flag_present	int
:	O
case	O
DW_FORM_flag	int
:	O
case	O
DW_FORM_data1	int
:	O
case	O
DW_FORM_data2	int
:	O
case	O
DW_FORM_sdata	int
:	O
case	O
DW_FORM_udata	int
:	O
if	O
(	O
!	O
do_loc	int
)	O
printf	function
(	O
"%c%s"	pointer
,	O
delimiter	char
,	O
dwarf_vmatoa	function
(	O
"d"	pointer
,	O
uvalue	long
)	O
)	O
;	O
break	O
;	O
case	O
DW_FORM_implicit_const	int
:	O
if	O
(	O
!	O
do_loc	int
)	O
printf	function
(	O
"%c%s"	pointer
,	O
delimiter	char
,	O
dwarf_vmatoa	function
(	O
"d"	pointer
,	O
implicit_const	long
)	O
)	O
;	O
break	O
;	O
case	O
DW_FORM_ref8	int
:	O
case	O
DW_FORM_data8	int
:	O
if	O
(	O
!	O
do_loc	int
)	O
{	O
dwarf_vma	long
high_bits	pointer
;	O
dwarf_vma	long
utmp	long
;	O
char	O
buf	pointer
[	O
64	int
]	O
;	O
SAFE_BYTE_GET64	O
(	O
data	pointer
,	O
&	O
high_bits	pointer
,	O
&	O
uvalue	long
,	O
end	pointer
)	O
;	O
utmp	long
=	O
uvalue	long
;	O
if	O
(	O
form	int
==	O
DW_FORM_ref8	int
)	O
add64	function
(	O
&	O
high_bits	pointer
,	O
&	O
utmp	long
,	O
cu_offset	long
)	O
;	O
printf	function
(	O
"%c0x%s"	pointer
,	O
delimiter	char
,	O
dwarf_vmatoa64	function
(	O
high_bits	pointer
,	O
utmp	long
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
)	O
;	O
}	O
if	O
(	O
(	O
do_loc	int
||	O
do_debug_loc	int
||	O
do_debug_ranges	int
)	O
&&	O
num_debug_info_entries	int
==	O
0	int
)	O
{	O
if	O
(	O
sizeof	O
(	O
uvalue	long
)	O
==	O
8	int
)	O
SAFE_BYTE_GET	O
(	O
uvalue	long
,	O
data	pointer
,	O
8	int
,	O
end	pointer
)	O
;	O
else	O
error	function
(	O
_	O
(	O
"DW_FORM_data8 is unsupported when sizeof (dwarf_vma) != 8\n"	pointer
)	O
)	O
;	O
}	O
data	pointer
+=	O
8	int
;	O
break	O
;	O
case	O
DW_FORM_data16	int
:	O
if	O
(	O
!	O
do_loc	int
)	O
{	O
dwarf_vma	long
left_high_bits	long
,	O
left_low_bits	long
;	O
dwarf_vma	long
right_high_bits	long
,	O
right_low_bits	long
;	O
SAFE_BYTE_GET64	O
(	O
data	pointer
,	O
&	O
left_high_bits	long
,	O
&	O
left_low_bits	long
,	O
end	pointer
)	O
;	O
SAFE_BYTE_GET64	O
(	O
data	pointer
+	O
8	int
,	O
&	O
right_high_bits	long
,	O
&	O
right_low_bits	long
,	O
end	pointer
)	O
;	O
if	O
(	O
byte_get	pointer
==	O
byte_get_little_endian	function
)	O
{	O
left_high_bits	long
^=	O
right_high_bits	long
;	O
right_high_bits	long
^=	O
left_high_bits	long
;	O
left_high_bits	long
^=	O
right_high_bits	long
;	O
left_low_bits	long
^=	O
right_low_bits	long
;	O
right_low_bits	long
^=	O
left_low_bits	long
;	O
left_low_bits	long
^=	O
right_low_bits	long
;	O
}	O
printf	function
(	O
" 0x%08"	pointer
DWARF_VMA_FMT	pointer
"x%08"	pointer
DWARF_VMA_FMT	pointer
"x"	pointer
"%08"	pointer
DWARF_VMA_FMT	pointer
"x%08"	pointer
DWARF_VMA_FMT	pointer
"x"	pointer
,	O
left_high_bits	long
,	O
left_low_bits	long
,	O
right_high_bits	long
,	O
right_low_bits	long
)	O
;	O
}	O
data	pointer
+=	O
16	int
;	O
break	O
;	O
case	O
DW_FORM_string	int
:	O
if	O
(	O
!	O
do_loc	int
)	O
printf	function
(	O
"%c%.*s"	pointer
,	O
delimiter	char
,	O
(	O
int	O
)	O
(	O
end	pointer
-	O
data	pointer
)	O
,	O
data	pointer
)	O
;	O
data	pointer
+=	O
strnlen	function
(	O
(	O
char	O
*	O
)	O
data	pointer
,	O
end	pointer
-	O
data	pointer
)	O
+	O
1	int
;	O
break	O
;	O
case	O
DW_FORM_block	int
:	O
case	O
DW_FORM_exprloc	int
:	O
READ_ULEB	O
(	O
uvalue	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
do_block	O
:	O
block_start	pointer
=	O
data	pointer
;	O
if	O
(	O
block_start	pointer
>=	O
end	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"Block ends prematurely\n"	pointer
)	O
)	O
;	O
uvalue	long
=	O
0	int
;	O
block_start	pointer
=	O
end	pointer
;	O
}	O
uvalue	long
=	O
check_uvalue	function
(	O
block_start	pointer
,	O
uvalue	long
,	O
end	pointer
)	O
;	O
if	O
(	O
do_loc	int
)	O
data	pointer
=	O
block_start	pointer
+	O
uvalue	long
;	O
else	O
data	pointer
=	O
display_block	function
(	O
block_start	pointer
,	O
uvalue	long
,	O
end	pointer
,	O
delimiter	char
)	O
;	O
break	O
;	O
case	O
DW_FORM_block1	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
uvalue	long
,	O
data	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
goto	O
do_block	O
;	O
case	O
DW_FORM_block2	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
uvalue	long
,	O
data	pointer
,	O
2	int
,	O
end	pointer
)	O
;	O
goto	O
do_block	O
;	O
case	O
DW_FORM_block4	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
uvalue	long
,	O
data	pointer
,	O
4	int
,	O
end	pointer
)	O
;	O
goto	O
do_block	O
;	O
case	O
DW_FORM_strp	int
:	O
if	O
(	O
!	O
do_loc	int
)	O
printf	function
(	O
_	O
(	O
"%c(indirect string, offset: 0x%s): %s"	pointer
)	O
,	O
delimiter	char
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
uvalue	long
)	O
,	O
fetch_indirect_string	function
(	O
uvalue	long
)	O
)	O
;	O
break	O
;	O
case	O
DW_FORM_line_strp	int
:	O
if	O
(	O
!	O
do_loc	int
)	O
printf	function
(	O
_	O
(	O
"%c(indirect line string, offset: 0x%s): %s"	pointer
)	O
,	O
delimiter	char
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
uvalue	long
)	O
,	O
fetch_indirect_line_string	function
(	O
uvalue	long
)	O
)	O
;	O
break	O
;	O
case	O
DW_FORM_GNU_str_index	int
:	O
if	O
(	O
!	O
do_loc	int
)	O
{	O
const	O
char	O
*	O
suffix	pointer
=	O
strrchr	function
(	O
section	pointer
->	O
name	pointer
,	O
'.'	O
)	O
;	O
bfd_boolean	int
dwo	int
=	O
(	O
suffix	pointer
&&	O
strcmp	function
(	O
suffix	pointer
,	O
".dwo"	pointer
)	O
==	O
0	int
)	O
?	O
TRUE	int
:	O
FALSE	int
;	O
printf	function
(	O
_	O
(	O
"%c(indexed string: 0x%s): %s"	pointer
)	O
,	O
delimiter	char
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
uvalue	long
)	O
,	O
fetch_indexed_string	function
(	O
uvalue	long
,	O
this_set	pointer
,	O
offset_size	int
,	O
dwo	int
)	O
)	O
;	O
}	O
break	O
;	O
case	O
DW_FORM_GNU_strp_alt	int
:	O
if	O
(	O
!	O
do_loc	int
)	O
{	O
printf	function
(	O
_	O
(	O
"%c(alt indirect string, offset: 0x%s) %s"	pointer
)	O
,	O
delimiter	char
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
uvalue	long
)	O
,	O
fetch_alt_indirect_string	function
(	O
uvalue	long
)	O
)	O
;	O
}	O
break	O
;	O
case	O
DW_FORM_indirect	int
:	O
break	O
;	O
case	O
DW_FORM_ref_sig8	int
:	O
if	O
(	O
!	O
do_loc	int
)	O
{	O
dwarf_vma	long
high_bits	pointer
;	O
char	O
buf	pointer
[	O
64	int
]	O
;	O
SAFE_BYTE_GET64	O
(	O
data	pointer
,	O
&	O
high_bits	pointer
,	O
&	O
uvalue	long
,	O
end	pointer
)	O
;	O
printf	function
(	O
"%csignature: 0x%s"	pointer
,	O
delimiter	char
,	O
dwarf_vmatoa64	function
(	O
high_bits	pointer
,	O
uvalue	long
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
)	O
;	O
}	O
data	pointer
+=	O
8	int
;	O
break	O
;	O
case	O
DW_FORM_GNU_addr_index	int
:	O
if	O
(	O
!	O
do_loc	int
)	O
printf	function
(	O
_	O
(	O
"%c(addr_index: 0x%s): %s"	pointer
)	O
,	O
delimiter	char
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
uvalue	long
)	O
,	O
fetch_indexed_value	function
(	O
uvalue	long
*	O
pointer_size	int
,	O
pointer_size	int
)	O
)	O
;	O
break	O
;	O
default	O
:	O
warn	function
(	O
_	O
(	O
"Unrecognized form: %lu\n"	pointer
)	O
,	O
form	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
(	O
do_loc	int
||	O
do_debug_loc	int
||	O
do_debug_ranges	int
)	O
&&	O
num_debug_info_entries	int
==	O
0	int
&&	O
debug_info_p	pointer
!=	O
NULL	O
)	O
{	O
switch	O
(	O
attribute	long
)	O
{	O
case	O
DW_AT_frame_base	int
:	O
have_frame_base	pointer
=	O
1	int
;	O
case	O
DW_AT_location	int
:	O
case	O
DW_AT_GNU_locviews	int
:	O
case	O
DW_AT_string_length	int
:	O
case	O
DW_AT_return_addr	int
:	O
case	O
DW_AT_data_member_location	int
:	O
case	O
DW_AT_vtable_elem_location	int
:	O
case	O
DW_AT_segment	int
:	O
case	O
DW_AT_static_link	int
:	O
case	O
DW_AT_use_location	int
:	O
case	O
DW_AT_call_value	int
:	O
case	O
DW_AT_GNU_call_site_value	int
:	O
case	O
DW_AT_call_data_value	int
:	O
case	O
DW_AT_GNU_call_site_data_value	int
:	O
case	O
DW_AT_call_target	int
:	O
case	O
DW_AT_GNU_call_site_target	int
:	O
case	O
DW_AT_call_target_clobbered	int
:	O
case	O
DW_AT_GNU_call_site_target_clobbered	int
:	O
if	O
(	O
(	O
dwarf_version	int
<	O
4	int
&&	O
(	O
form	int
==	O
DW_FORM_data4	int
||	O
form	int
==	O
DW_FORM_data8	int
)	O
)	O
||	O
form	int
==	O
DW_FORM_sec_offset	int
)	O
{	O
unsigned	O
int	O
lmax	int
=	O
debug_info_p	pointer
->	O
max_loc_offsets	int
;	O
unsigned	O
int	O
num	int
=	O
debug_info_p	pointer
->	O
num_loc_offsets	int
;	O
if	O
(	O
lmax	int
==	O
0	int
||	O
num	int
>=	O
lmax	int
)	O
{	O
lmax	int
+=	O
1024	int
;	O
debug_info_p	pointer
->	O
loc_offsets	pointer
=	O
(	O
dwarf_vma	long
*	O
)	O
xcrealloc	function
(	O
debug_info_p	pointer
->	O
loc_offsets	pointer
,	O
lmax	int
,	O
sizeof	O
(	O
*	O
debug_info_p	pointer
->	O
loc_offsets	pointer
)	O
)	O
;	O
debug_info_p	pointer
->	O
loc_views	pointer
=	O
(	O
dwarf_vma	long
*	O
)	O
xcrealloc	function
(	O
debug_info_p	pointer
->	O
loc_views	pointer
,	O
lmax	int
,	O
sizeof	O
(	O
*	O
debug_info_p	pointer
->	O
loc_views	pointer
)	O
)	O
;	O
debug_info_p	pointer
->	O
have_frame_base	pointer
=	O
(	O
int	O
*	O
)	O
xcrealloc	function
(	O
debug_info_p	pointer
->	O
have_frame_base	pointer
,	O
lmax	int
,	O
sizeof	O
(	O
*	O
debug_info_p	pointer
->	O
have_frame_base	pointer
)	O
)	O
;	O
debug_info_p	pointer
->	O
max_loc_offsets	int
=	O
lmax	int
;	O
}	O
if	O
(	O
this_set	pointer
!=	O
NULL	O
)	O
uvalue	long
+=	O
this_set	pointer
->	O
section_offsets	array
[	O
DW_SECT_LOC	int
]	O
;	O
debug_info_p	pointer
->	O
have_frame_base	pointer
[	O
num	int
]	O
=	O
have_frame_base	pointer
;	O
if	O
(	O
attribute	long
!=	O
DW_AT_GNU_locviews	int
)	O
{	O
if	O
(	O
debug_info_p	pointer
->	O
num_loc_offsets	int
>	O
debug_info_p	pointer
->	O
num_loc_views	int
)	O
warn	function
(	O
_	O
(	O
"More location offset attributes than DW_AT_GNU_locview attributes\n"	pointer
)	O
)	O
;	O
else	O
{	O
debug_info_p	pointer
->	O
loc_offsets	pointer
[	O
num	int
]	O
=	O
uvalue	long
;	O
debug_info_p	pointer
->	O
num_loc_offsets	int
++	O
;	O
}	O
}	O
else	O
{	O
assert	O
(	O
debug_info_p	pointer
->	O
num_loc_views	int
<=	O
num	int
)	O
;	O
num	int
=	O
debug_info_p	pointer
->	O
num_loc_views	int
;	O
if	O
(	O
num	int
>	O
debug_info_p	pointer
->	O
num_loc_offsets	int
)	O
warn	function
(	O
_	O
(	O
"More DW_AT_GNU_locview attributes than location offset attributes\n"	pointer
)	O
)	O
;	O
else	O
{	O
debug_info_p	pointer
->	O
loc_views	pointer
[	O
num	int
]	O
=	O
uvalue	long
;	O
debug_info_p	pointer
->	O
num_loc_views	int
++	O
;	O
}	O
}	O
}	O
break	O
;	O
case	O
DW_AT_low_pc	int
:	O
if	O
(	O
need_base_address	int
)	O
debug_info_p	pointer
->	O
base_address	long
=	O
uvalue	long
;	O
break	O
;	O
case	O
DW_AT_GNU_addr_base	int
:	O
debug_info_p	pointer
->	O
addr_base	long
=	O
uvalue	long
;	O
break	O
;	O
case	O
DW_AT_GNU_ranges_base	int
:	O
debug_info_p	pointer
->	O
ranges_base	long
=	O
uvalue	long
;	O
break	O
;	O
case	O
DW_AT_ranges	int
:	O
if	O
(	O
(	O
dwarf_version	int
<	O
4	int
&&	O
(	O
form	int
==	O
DW_FORM_data4	int
||	O
form	int
==	O
DW_FORM_data8	int
)	O
)	O
||	O
form	int
==	O
DW_FORM_sec_offset	int
)	O
{	O
unsigned	O
int	O
lmax	int
=	O
debug_info_p	pointer
->	O
max_range_lists	int
;	O
unsigned	O
int	O
num	int
=	O
debug_info_p	pointer
->	O
num_range_lists	int
;	O
if	O
(	O
lmax	int
==	O
0	int
||	O
num	int
>=	O
lmax	int
)	O
{	O
lmax	int
+=	O
1024	int
;	O
debug_info_p	pointer
->	O
range_lists	pointer
=	O
(	O
dwarf_vma	long
*	O
)	O
xcrealloc	function
(	O
debug_info_p	pointer
->	O
range_lists	pointer
,	O
lmax	int
,	O
sizeof	O
(	O
*	O
debug_info_p	pointer
->	O
range_lists	pointer
)	O
)	O
;	O
debug_info_p	pointer
->	O
max_range_lists	int
=	O
lmax	int
;	O
}	O
debug_info_p	pointer
->	O
range_lists	pointer
[	O
num	int
]	O
=	O
uvalue	long
;	O
debug_info_p	pointer
->	O
num_range_lists	int
++	O
;	O
}	O
break	O
;	O
case	O
DW_AT_GNU_dwo_name	int
:	O
case	O
DW_AT_dwo_name	int
:	O
if	O
(	O
need_dwo_info	int
)	O
switch	O
(	O
form	int
)	O
{	O
case	O
DW_FORM_strp	int
:	O
add_dwo_name	function
(	O
(	O
const	O
char	O
*	O
)	O
fetch_indirect_string	function
(	O
uvalue	long
)	O
)	O
;	O
break	O
;	O
case	O
DW_FORM_GNU_str_index	int
:	O
add_dwo_name	function
(	O
fetch_indexed_string	function
(	O
uvalue	long
,	O
this_set	pointer
,	O
offset_size	int
,	O
FALSE	int
)	O
)	O
;	O
break	O
;	O
case	O
DW_FORM_string	int
:	O
add_dwo_name	function
(	O
(	O
const	O
char	O
*	O
)	O
orig_data	pointer
)	O
;	O
break	O
;	O
default	O
:	O
warn	function
(	O
_	O
(	O
"Unsupported form (%s) for attribute %s\n"	pointer
)	O
,	O
get_FORM_name	function
(	O
form	int
)	O
,	O
get_AT_name	function
(	O
attribute	long
)	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
DW_AT_comp_dir	int
:	O
if	O
(	O
need_dwo_info	int
)	O
switch	O
(	O
form	int
)	O
{	O
case	O
DW_FORM_strp	int
:	O
add_dwo_dir	function
(	O
(	O
const	O
char	O
*	O
)	O
fetch_indirect_string	function
(	O
uvalue	long
)	O
)	O
;	O
break	O
;	O
case	O
DW_FORM_line_strp	int
:	O
add_dwo_dir	function
(	O
(	O
const	O
char	O
*	O
)	O
fetch_indirect_line_string	function
(	O
uvalue	long
)	O
)	O
;	O
break	O
;	O
case	O
DW_FORM_GNU_str_index	int
:	O
add_dwo_dir	function
(	O
fetch_indexed_string	function
(	O
uvalue	long
,	O
this_set	pointer
,	O
offset_size	int
,	O
FALSE	int
)	O
)	O
;	O
break	O
;	O
case	O
DW_FORM_string	int
:	O
add_dwo_dir	function
(	O
(	O
const	O
char	O
*	O
)	O
orig_data	pointer
)	O
;	O
break	O
;	O
default	O
:	O
warn	function
(	O
_	O
(	O
"Unsupported form (%s) for attribute %s\n"	pointer
)	O
,	O
get_FORM_name	function
(	O
form	int
)	O
,	O
get_AT_name	function
(	O
attribute	long
)	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
DW_AT_GNU_dwo_id	int
:	O
if	O
(	O
need_dwo_info	int
)	O
switch	O
(	O
form	int
)	O
{	O
case	O
DW_FORM_data8	int
:	O
add_dwo_id	function
(	O
(	O
const	O
char	O
*	O
)	O
(	O
data	pointer
-	O
8	int
)	O
)	O
;	O
break	O
;	O
default	O
:	O
warn	function
(	O
_	O
(	O
"Unsupported form (%s) for attribute %s\n"	pointer
)	O
,	O
get_FORM_name	function
(	O
form	int
)	O
,	O
get_AT_name	function
(	O
attribute	long
)	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
if	O
(	O
do_loc	int
||	O
attribute	long
==	O
0	int
)	O
return	O
data	pointer
;	O
switch	O
(	O
attribute	long
)	O
{	O
case	O
DW_AT_type	int
:	O
if	O
(	O
level	int
>=	O
0	int
&&	O
level	int
<	O
MAX_CU_NESTING	O
&&	O
uvalue	long
<	O
(	O
size_t	long
)	O
(	O
end	pointer
-	O
start	pointer
)	O
)	O
{	O
bfd_boolean	int
is_signed	pointer
=	O
FALSE	int
;	O
get_type_signedness	function
(	O
start	pointer
,	O
start	pointer
+	O
uvalue	long
,	O
end	pointer
,	O
pointer_size	int
,	O
offset_size	int
,	O
dwarf_version	int
,	O
&	O
is_signed	pointer
,	O
FALSE	int
)	O
;	O
level_type_signed	array
[	O
level	int
]	O
=	O
is_signed	pointer
;	O
}	O
break	O
;	O
case	O
DW_AT_inline	int
:	O
printf	function
(	O
"\t"	pointer
)	O
;	O
switch	O
(	O
uvalue	long
)	O
{	O
case	O
DW_INL_not_inlined	int
:	O
printf	function
(	O
_	O
(	O
"(not inlined)"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
DW_INL_inlined	int
:	O
printf	function
(	O
_	O
(	O
"(inlined)"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
DW_INL_declared_not_inlined	int
:	O
printf	function
(	O
_	O
(	O
"(declared as inline but ignored)"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
DW_INL_declared_inlined	int
:	O
printf	function
(	O
_	O
(	O
"(declared as inline and inlined)"	pointer
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
_	O
(	O
"  (Unknown inline attribute value: %s)"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
uvalue	long
)	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
DW_AT_language	int
:	O
printf	function
(	O
"\t"	pointer
)	O
;	O
switch	O
(	O
uvalue	long
)	O
{	O
case	O
DW_LANG_C89	int
:	O
printf	function
(	O
"(ANSI C)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_C	int
:	O
printf	function
(	O
"(non-ANSI C)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_Ada83	int
:	O
printf	function
(	O
"(Ada)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_C_plus_plus	int
:	O
printf	function
(	O
"(C++)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_Cobol74	int
:	O
printf	function
(	O
"(Cobol 74)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_Cobol85	int
:	O
printf	function
(	O
"(Cobol 85)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_Fortran77	int
:	O
printf	function
(	O
"(FORTRAN 77)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_Fortran90	int
:	O
printf	function
(	O
"(Fortran 90)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_Pascal83	int
:	O
printf	function
(	O
"(ANSI Pascal)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_Modula2	int
:	O
printf	function
(	O
"(Modula 2)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_Java	int
:	O
printf	function
(	O
"(Java)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_C99	int
:	O
printf	function
(	O
"(ANSI C99)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_Ada95	int
:	O
printf	function
(	O
"(ADA 95)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_Fortran95	int
:	O
printf	function
(	O
"(Fortran 95)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_PLI	int
:	O
printf	function
(	O
"(PLI)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_ObjC	int
:	O
printf	function
(	O
"(Objective C)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_ObjC_plus_plus	int
:	O
printf	function
(	O
"(Objective C++)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_UPC	int
:	O
printf	function
(	O
"(Unified Parallel C)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_D	int
:	O
printf	function
(	O
"(D)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_Python	int
:	O
printf	function
(	O
"(Python)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_OpenCL	int
:	O
printf	function
(	O
"(OpenCL)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_Go	int
:	O
printf	function
(	O
"(Go)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_Modula3	int
:	O
printf	function
(	O
"(Modula 3)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_Haskell	int
:	O
printf	function
(	O
"(Haskell)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_C_plus_plus_03	int
:	O
printf	function
(	O
"(C++03)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_C_plus_plus_11	int
:	O
printf	function
(	O
"(C++11)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_OCaml	int
:	O
printf	function
(	O
"(OCaml)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_Rust	int
:	O
printf	function
(	O
"(Rust)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_C11	int
:	O
printf	function
(	O
"(C11)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_Swift	int
:	O
printf	function
(	O
"(Swift)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_Julia	int
:	O
printf	function
(	O
"(Julia)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_Dylan	int
:	O
printf	function
(	O
"(Dylan)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_C_plus_plus_14	int
:	O
printf	function
(	O
"(C++14)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_Fortran03	int
:	O
printf	function
(	O
"(Fortran 03)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_Fortran08	int
:	O
printf	function
(	O
"(Fortran 08)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_RenderScript	int
:	O
printf	function
(	O
"(RenderScript)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_Mips_Assembler	int
:	O
printf	function
(	O
"(MIPS assembler)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_LANG_Upc	int
:	O
printf	function
(	O
"(Unified Parallel C)"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
uvalue	long
>=	O
DW_LANG_lo_user	int
&&	O
uvalue	long
<=	O
DW_LANG_hi_user	int
)	O
printf	function
(	O
_	O
(	O
"(implementation defined: %s)"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
uvalue	long
)	O
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"(Unknown: %s)"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
uvalue	long
)	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
DW_AT_encoding	int
:	O
printf	function
(	O
"\t"	pointer
)	O
;	O
switch	O
(	O
uvalue	long
)	O
{	O
case	O
DW_ATE_void	int
:	O
printf	function
(	O
"(void)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_ATE_address	int
:	O
printf	function
(	O
"(machine address)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_ATE_boolean	int
:	O
printf	function
(	O
"(boolean)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_ATE_complex_float	int
:	O
printf	function
(	O
"(complex float)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_ATE_float	int
:	O
printf	function
(	O
"(float)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_ATE_signed	int
:	O
printf	function
(	O
"(signed)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_ATE_signed_char	int
:	O
printf	function
(	O
"(signed char)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_ATE_unsigned	int
:	O
printf	function
(	O
"(unsigned)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_ATE_unsigned_char	int
:	O
printf	function
(	O
"(unsigned char)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_ATE_imaginary_float	int
:	O
printf	function
(	O
"(imaginary float)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_ATE_decimal_float	int
:	O
printf	function
(	O
"(decimal float)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_ATE_packed_decimal	int
:	O
printf	function
(	O
"(packed_decimal)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_ATE_numeric_string	int
:	O
printf	function
(	O
"(numeric_string)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_ATE_edited	int
:	O
printf	function
(	O
"(edited)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_ATE_signed_fixed	int
:	O
printf	function
(	O
"(signed_fixed)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_ATE_unsigned_fixed	int
:	O
printf	function
(	O
"(unsigned_fixed)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_ATE_UTF	int
:	O
printf	function
(	O
"(unicode string)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_ATE_UCS	int
:	O
printf	function
(	O
"(UCS)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_ATE_ASCII	int
:	O
printf	function
(	O
"(ASCII)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_ATE_HP_float80	int
:	O
printf	function
(	O
"(HP_float80)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_ATE_HP_complex_float80	int
:	O
printf	function
(	O
"(HP_complex_float80)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_ATE_HP_float128	int
:	O
printf	function
(	O
"(HP_float128)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_ATE_HP_complex_float128	int
:	O
printf	function
(	O
"(HP_complex_float128)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_ATE_HP_floathpintel	int
:	O
printf	function
(	O
"(HP_floathpintel)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_ATE_HP_imaginary_float80	int
:	O
printf	function
(	O
"(HP_imaginary_float80)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_ATE_HP_imaginary_float128	int
:	O
printf	function
(	O
"(HP_imaginary_float128)"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
uvalue	long
>=	O
DW_ATE_lo_user	int
&&	O
uvalue	long
<=	O
DW_ATE_hi_user	int
)	O
printf	function
(	O
_	O
(	O
"(user defined type)"	pointer
)	O
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"(unknown type)"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
DW_AT_accessibility	int
:	O
printf	function
(	O
"\t"	pointer
)	O
;	O
switch	O
(	O
uvalue	long
)	O
{	O
case	O
DW_ACCESS_public	int
:	O
printf	function
(	O
"(public)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_ACCESS_protected	int
:	O
printf	function
(	O
"(protected)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_ACCESS_private	int
:	O
printf	function
(	O
"(private)"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
_	O
(	O
"(unknown accessibility)"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
DW_AT_visibility	int
:	O
printf	function
(	O
"\t"	pointer
)	O
;	O
switch	O
(	O
uvalue	long
)	O
{	O
case	O
DW_VIS_local	int
:	O
printf	function
(	O
"(local)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_VIS_exported	int
:	O
printf	function
(	O
"(exported)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_VIS_qualified	int
:	O
printf	function
(	O
"(qualified)"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
_	O
(	O
"(unknown visibility)"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
DW_AT_endianity	int
:	O
printf	function
(	O
"\t"	pointer
)	O
;	O
switch	O
(	O
uvalue	long
)	O
{	O
case	O
DW_END_default	int
:	O
printf	function
(	O
"(default)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_END_big	int
:	O
printf	function
(	O
"(big)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_END_little	int
:	O
printf	function
(	O
"(little)"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
uvalue	long
>=	O
DW_END_lo_user	int
&&	O
uvalue	long
<=	O
DW_END_hi_user	int
)	O
printf	function
(	O
_	O
(	O
"(user specified)"	pointer
)	O
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"(unknown endianity)"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
DW_AT_virtuality	int
:	O
printf	function
(	O
"\t"	pointer
)	O
;	O
switch	O
(	O
uvalue	long
)	O
{	O
case	O
DW_VIRTUALITY_none	int
:	O
printf	function
(	O
"(none)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_VIRTUALITY_virtual	int
:	O
printf	function
(	O
"(virtual)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_VIRTUALITY_pure_virtual	int
:	O
printf	function
(	O
"(pure_virtual)"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
_	O
(	O
"(unknown virtuality)"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
DW_AT_identifier_case	int
:	O
printf	function
(	O
"\t"	pointer
)	O
;	O
switch	O
(	O
uvalue	long
)	O
{	O
case	O
DW_ID_case_sensitive	int
:	O
printf	function
(	O
"(case_sensitive)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_ID_up_case	int
:	O
printf	function
(	O
"(up_case)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_ID_down_case	int
:	O
printf	function
(	O
"(down_case)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_ID_case_insensitive	int
:	O
printf	function
(	O
"(case_insensitive)"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
_	O
(	O
"(unknown case)"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
DW_AT_calling_convention	int
:	O
printf	function
(	O
"\t"	pointer
)	O
;	O
switch	O
(	O
uvalue	long
)	O
{	O
case	O
DW_CC_normal	int
:	O
printf	function
(	O
"(normal)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_CC_program	int
:	O
printf	function
(	O
"(program)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_CC_nocall	int
:	O
printf	function
(	O
"(nocall)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_CC_pass_by_reference	int
:	O
printf	function
(	O
"(pass by ref)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_CC_pass_by_value	int
:	O
printf	function
(	O
"(pass by value)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_CC_GNU_renesas_sh	int
:	O
printf	function
(	O
"(Rensas SH)"	pointer
)	O
;	O
break	O
;	O
case	O
DW_CC_GNU_borland_fastcall_i386	int
:	O
printf	function
(	O
"(Borland fastcall i386)"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
uvalue	long
>=	O
DW_CC_lo_user	int
&&	O
uvalue	long
<=	O
DW_CC_hi_user	int
)	O
printf	function
(	O
_	O
(	O
"(user defined)"	pointer
)	O
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"(unknown convention)"	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
DW_AT_ordering	int
:	O
printf	function
(	O
"\t"	pointer
)	O
;	O
switch	O
(	O
uvalue	long
)	O
{	O
case	O
255	int
:	O
case	O
-	O
1	int
:	O
printf	function
(	O
_	O
(	O
"(undefined)"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
0	int
:	O
printf	function
(	O
"(row major)"	pointer
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	function
(	O
"(column major)"	pointer
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
DW_AT_decimal_sign	int
:	O
printf	function
(	O
"\t"	pointer
)	O
;	O
switch	O
(	O
uvalue	long
)	O
{	O
case	O
DW_DS_unsigned	int
:	O
printf	function
(	O
_	O
(	O
"(unsigned)"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
DW_DS_leading_overpunch	int
:	O
printf	function
(	O
_	O
(	O
"(leading overpunch)"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
DW_DS_trailing_overpunch	int
:	O
printf	function
(	O
_	O
(	O
"(trailing overpunch)"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
DW_DS_leading_separate	int
:	O
printf	function
(	O
_	O
(	O
"(leading separate)"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
DW_DS_trailing_separate	int
:	O
printf	function
(	O
_	O
(	O
"(trailing separate)"	pointer
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
_	O
(	O
"(unrecognised)"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
DW_AT_defaulted	int
:	O
printf	function
(	O
"\t"	pointer
)	O
;	O
switch	O
(	O
uvalue	long
)	O
{	O
case	O
DW_DEFAULTED_no	int
:	O
printf	function
(	O
_	O
(	O
"(no)"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
DW_DEFAULTED_in_class	int
:	O
printf	function
(	O
_	O
(	O
"(in class)"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
DW_DEFAULTED_out_of_class	int
:	O
printf	function
(	O
_	O
(	O
"(out of class)"	pointer
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
_	O
(	O
"(unrecognised)"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
DW_AT_discr_list	int
:	O
printf	function
(	O
"\t"	pointer
)	O
;	O
display_discr_list	function
(	O
form	int
,	O
uvalue	long
,	O
data	pointer
,	O
end	pointer
,	O
level	int
)	O
;	O
break	O
;	O
case	O
DW_AT_frame_base	int
:	O
have_frame_base	pointer
=	O
1	int
;	O
case	O
DW_AT_location	int
:	O
case	O
DW_AT_string_length	int
:	O
case	O
DW_AT_return_addr	int
:	O
case	O
DW_AT_data_member_location	int
:	O
case	O
DW_AT_vtable_elem_location	int
:	O
case	O
DW_AT_segment	int
:	O
case	O
DW_AT_static_link	int
:	O
case	O
DW_AT_use_location	int
:	O
case	O
DW_AT_call_value	int
:	O
case	O
DW_AT_GNU_call_site_value	int
:	O
case	O
DW_AT_call_data_value	int
:	O
case	O
DW_AT_GNU_call_site_data_value	int
:	O
case	O
DW_AT_call_target	int
:	O
case	O
DW_AT_GNU_call_site_target	int
:	O
case	O
DW_AT_call_target_clobbered	int
:	O
case	O
DW_AT_GNU_call_site_target_clobbered	int
:	O
if	O
(	O
(	O
dwarf_version	int
<	O
4	int
&&	O
(	O
form	int
==	O
DW_FORM_data4	int
||	O
form	int
==	O
DW_FORM_data8	int
)	O
)	O
||	O
form	int
==	O
DW_FORM_sec_offset	int
)	O
printf	function
(	O
_	O
(	O
" (location list)"	pointer
)	O
)	O
;	O
case	O
DW_AT_allocated	int
:	O
case	O
DW_AT_associated	int
:	O
case	O
DW_AT_data_location	int
:	O
case	O
DW_AT_stride	O
:	O
case	O
DW_AT_upper_bound	int
:	O
case	O
DW_AT_lower_bound	int
:	O
if	O
(	O
block_start	pointer
)	O
{	O
int	O
need_frame_base	int
;	O
printf	function
(	O
"\t("	pointer
)	O
;	O
need_frame_base	int
=	O
decode_location_expression	function
(	O
block_start	pointer
,	O
pointer_size	int
,	O
offset_size	int
,	O
dwarf_version	int
,	O
uvalue	long
,	O
cu_offset	long
,	O
section	pointer
)	O
;	O
printf	function
(	O
")"	pointer
)	O
;	O
if	O
(	O
need_frame_base	int
&&	O
!	O
have_frame_base	pointer
)	O
printf	function
(	O
_	O
(	O
" [without DW_AT_frame_base]"	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
DW_AT_data_bit_offset	int
:	O
case	O
DW_AT_byte_size	int
:	O
case	O
DW_AT_bit_size	int
:	O
case	O
DW_AT_string_length_byte_size	int
:	O
case	O
DW_AT_string_length_bit_size	int
:	O
case	O
DW_AT_bit_stride	int
:	O
if	O
(	O
form	int
==	O
DW_FORM_exprloc	int
)	O
{	O
printf	function
(	O
"\t("	pointer
)	O
;	O
(	O
void	O
)	O
decode_location_expression	function
(	O
block_start	pointer
,	O
pointer_size	int
,	O
offset_size	int
,	O
dwarf_version	int
,	O
uvalue	long
,	O
cu_offset	long
,	O
section	pointer
)	O
;	O
printf	function
(	O
")"	pointer
)	O
;	O
}	O
break	O
;	O
case	O
DW_AT_import	int
:	O
{	O
if	O
(	O
form	int
==	O
DW_FORM_ref_sig8	int
||	O
form	int
==	O
DW_FORM_GNU_ref_alt	int
)	O
break	O
;	O
if	O
(	O
form	int
==	O
DW_FORM_ref1	int
||	O
form	int
==	O
DW_FORM_ref2	int
||	O
form	int
==	O
DW_FORM_ref4	int
||	O
form	int
==	O
DW_FORM_ref_udata	int
)	O
uvalue	long
+=	O
cu_offset	long
;	O
if	O
(	O
uvalue	long
>=	O
section	pointer
->	O
size	int
)	O
warn	function
(	O
_	O
(	O
"Offset %s used as value for DW_AT_import attribute of DIE at offset 0x%lx is too big.\n"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
uvalue	long
)	O
,	O
(	O
unsigned	O
long	O
)	O
(	O
orig_data	pointer
-	O
section	pointer
->	O
start	pointer
)	O
)	O
;	O
else	O
{	O
unsigned	O
long	O
abbrev_number	long
;	O
abbrev_entry	struct
*	O
entry	long
;	O
unsigned	O
char	O
*	O
p	pointer
=	O
section	pointer
->	O
start	pointer
+	O
uvalue	long
;	O
READ_ULEB	O
(	O
abbrev_number	long
,	O
p	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"\t[Abbrev Number: %ld"	pointer
)	O
,	O
abbrev_number	long
)	O
;	O
if	O
(	O
form	int
!=	O
DW_FORM_ref_addr	int
)	O
{	O
for	O
(	O
entry	long
=	O
first_abbrev	pointer
;	O
entry	long
!=	O
NULL	O
;	O
entry	long
=	O
entry	long
->	O
next	pointer
)	O
if	O
(	O
entry	long
->	O
entry	long
==	O
abbrev_number	long
)	O
break	O
;	O
if	O
(	O
entry	long
!=	O
NULL	O
)	O
printf	function
(	O
" (%s)"	pointer
,	O
get_TAG_name	function
(	O
entry	long
->	O
tag	int
)	O
)	O
;	O
}	O
printf	function
(	O
"]"	pointer
)	O
;	O
}	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
return	O
data	pointer
;	O
}	O
static	O
unsigned	O
char	O
*	O
read_and_display_attr	function
(	O
unsigned	O
long	O
attribute	long
,	O
unsigned	O
long	O
form	int
,	O
dwarf_signed_vma	long
implicit_const	long
,	O
unsigned	O
char	O
*	O
start	pointer
,	O
unsigned	O
char	O
*	O
data	pointer
,	O
unsigned	O
char	O
*	O
end	pointer
,	O
dwarf_vma	long
cu_offset	long
,	O
dwarf_vma	long
pointer_size	int
,	O
dwarf_vma	long
offset_size	int
,	O
int	O
dwarf_version	int
,	O
debug_info	struct
*	O
debug_info_p	pointer
,	O
int	O
do_loc	int
,	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
struct	O
cu_tu_set	struct
*	O
this_set	pointer
,	O
int	O
level	int
)	O
{	O
if	O
(	O
!	O
do_loc	int
)	O
printf	function
(	O
"   %-18s:"	pointer
,	O
get_AT_name	function
(	O
attribute	long
)	O
)	O
;	O
data	pointer
=	O
read_and_display_attr_value	function
(	O
attribute	long
,	O
form	int
,	O
implicit_const	long
,	O
start	pointer
,	O
data	pointer
,	O
end	pointer
,	O
cu_offset	long
,	O
pointer_size	int
,	O
offset_size	int
,	O
dwarf_version	int
,	O
debug_info_p	pointer
,	O
do_loc	int
,	O
section	pointer
,	O
this_set	pointer
,	O
' '	O
,	O
level	int
)	O
;	O
if	O
(	O
!	O
do_loc	int
)	O
printf	function
(	O
"\n"	pointer
)	O
;	O
return	O
data	pointer
;	O
}	O
static	O
bfd_boolean	int
load_debug_section_with_follow	function
(	O
enum	O
dwarf_section_display_enum	enum
sec_enum	enum
,	O
void	O
*	O
handle	pointer
)	O
{	O
if	O
(	O
load_debug_section	function
(	O
sec_enum	enum
,	O
handle	pointer
)	O
)	O
{	O
if	O
(	O
debug_displays	array
[	O
sec_enum	enum
]	O
.	O
section	pointer
.	O
filename	pointer
==	O
NULL	O
)	O
{	O
separate_info	struct
*	O
i	pointer
;	O
for	O
(	O
i	pointer
=	O
first_separate_info	pointer
;	O
i	pointer
!=	O
NULL	O
;	O
i	pointer
=	O
i	pointer
->	O
next	pointer
)	O
if	O
(	O
i	pointer
->	O
handle	pointer
==	O
handle	pointer
)	O
{	O
debug_displays	array
[	O
sec_enum	enum
]	O
.	O
section	pointer
.	O
filename	pointer
=	O
i	pointer
->	O
filename	pointer
;	O
break	O
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
do_follow_links	int
)	O
{	O
separate_info	struct
*	O
i	pointer
;	O
for	O
(	O
i	pointer
=	O
first_separate_info	pointer
;	O
i	pointer
!=	O
NULL	O
;	O
i	pointer
=	O
i	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
load_debug_section	function
(	O
sec_enum	enum
,	O
i	pointer
->	O
handle	pointer
)	O
)	O
{	O
debug_displays	array
[	O
sec_enum	enum
]	O
.	O
section	pointer
.	O
filename	pointer
=	O
i	pointer
->	O
filename	pointer
;	O
return	O
TRUE	int
;	O
}	O
}	O
}	O
return	O
FALSE	int
;	O
}	O
static	O
void	O
introduce	function
(	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
bfd_boolean	int
raw	int
)	O
{	O
if	O
(	O
raw	int
)	O
{	O
if	O
(	O
do_follow_links	int
&&	O
section	pointer
->	O
filename	pointer
)	O
printf	function
(	O
_	O
(	O
"Raw dump of debug contents of section %s (loaded from %s):\n\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
,	O
section	pointer
->	O
filename	pointer
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"Raw dump of debug contents of section %s:\n\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
do_follow_links	int
&&	O
section	pointer
->	O
filename	pointer
)	O
printf	function
(	O
_	O
(	O
"Contents of the %s section (loaded from %s):\n\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
,	O
section	pointer
->	O
filename	pointer
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"Contents of the %s section:\n\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
)	O
;	O
}	O
}	O
static	O
bfd_boolean	int
process_debug_info	function
(	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
void	O
*	O
file	pointer
,	O
enum	O
dwarf_section_display_enum	enum
abbrev_sec	enum
,	O
bfd_boolean	int
do_loc	int
,	O
bfd_boolean	int
do_types	int
)	O
{	O
unsigned	O
char	O
*	O
start	pointer
=	O
section	pointer
->	O
start	pointer
;	O
unsigned	O
char	O
*	O
end	pointer
=	O
start	pointer
+	O
section	pointer
->	O
size	int
;	O
unsigned	O
char	O
*	O
section_begin	pointer
;	O
unsigned	O
int	O
unit	int
;	O
unsigned	O
int	O
num_units	int
=	O
0	int
;	O
if	O
(	O
(	O
do_loc	int
||	O
do_debug_loc	int
||	O
do_debug_ranges	int
)	O
&&	O
num_debug_info_entries	int
==	O
0	int
&&	O
!	O
do_types	int
)	O
{	O
dwarf_vma	long
length	long
;	O
for	O
(	O
section_begin	pointer
=	O
start	pointer
,	O
num_units	int
=	O
0	int
;	O
section_begin	pointer
<	O
end	pointer
;	O
num_units	int
++	O
)	O
{	O
SAFE_BYTE_GET	O
(	O
length	long
,	O
section_begin	pointer
,	O
4	int
,	O
end	pointer
)	O
;	O
if	O
(	O
length	long
==	O
0xffffffff	int
)	O
{	O
SAFE_BYTE_GET	O
(	O
length	long
,	O
section_begin	pointer
+	O
4	int
,	O
8	int
,	O
end	pointer
)	O
;	O
section_begin	pointer
+=	O
length	long
+	O
12	int
;	O
}	O
else	O
if	O
(	O
length	long
>=	O
0xfffffff0	int
&&	O
length	long
<	O
0xffffffff	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Reserved length value (0x%s) found in section %s\n"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
length	long
)	O
,	O
section	pointer
->	O
name	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
else	O
section_begin	pointer
+=	O
length	long
+	O
4	int
;	O
if	O
(	O
(	O
signed	O
long	O
)	O
length	long
<=	O
0	int
||	O
section_begin	pointer
<	O
start	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"Corrupt unit length (0x%s) found in section %s\n"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
length	long
)	O
,	O
section	pointer
->	O
name	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
if	O
(	O
num_units	int
==	O
0	int
)	O
{	O
error	function
(	O
_	O
(	O
"No comp units in %s section ?\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
debug_information	pointer
=	O
(	O
debug_info	struct
*	O
)	O
cmalloc	function
(	O
num_units	int
,	O
sizeof	O
(	O
*	O
debug_information	pointer
)	O
)	O
;	O
if	O
(	O
debug_information	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Not enough memory for a debug info array of %u entries\n"	pointer
)	O
,	O
num_units	int
)	O
;	O
alloc_num_debug_info_entries	int
=	O
num_debug_info_entries	int
=	O
0	int
;	O
return	O
FALSE	int
;	O
}	O
memset	function
(	O
debug_information	pointer
,	O
0	int
,	O
num_units	int
*	O
sizeof	O
(	O
*	O
debug_information	pointer
)	O
)	O
;	O
alloc_num_debug_info_entries	int
=	O
num_units	int
;	O
}	O
if	O
(	O
!	O
do_loc	int
)	O
{	O
load_debug_section_with_follow	function
(	O
str	int
,	O
file	pointer
)	O
;	O
load_debug_section_with_follow	function
(	O
line_str	int
,	O
file	pointer
)	O
;	O
load_debug_section_with_follow	function
(	O
str_dwo	int
,	O
file	pointer
)	O
;	O
load_debug_section_with_follow	function
(	O
str_index	int
,	O
file	pointer
)	O
;	O
load_debug_section_with_follow	function
(	O
str_index_dwo	int
,	O
file	pointer
)	O
;	O
load_debug_section_with_follow	function
(	O
debug_addr	int
,	O
file	pointer
)	O
;	O
}	O
load_debug_section_with_follow	function
(	O
abbrev_sec	enum
,	O
file	pointer
)	O
;	O
if	O
(	O
debug_displays	array
[	O
abbrev_sec	enum
]	O
.	O
section	pointer
.	O
start	pointer
==	O
NULL	O
)	O
{	O
warn	function
(	O
_	O
(	O
"Unable to locate %s section!\n"	pointer
)	O
,	O
debug_displays	array
[	O
abbrev_sec	enum
]	O
.	O
section	pointer
.	O
uncompressed_name	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
!	O
do_loc	int
&&	O
dwarf_start_die	long
==	O
0	int
)	O
introduce	function
(	O
section	pointer
,	O
FALSE	int
)	O
;	O
for	O
(	O
section_begin	pointer
=	O
start	pointer
,	O
unit	int
=	O
0	int
;	O
start	pointer
<	O
end	pointer
;	O
unit	int
++	O
)	O
{	O
DWARF2_Internal_CompUnit	struct
compunit	struct
;	O
unsigned	O
char	O
*	O
hdrptr	pointer
;	O
unsigned	O
char	O
*	O
tags	pointer
;	O
int	O
level	int
,	O
last_level	int
,	O
saved_level	int
;	O
dwarf_vma	long
cu_offset	long
;	O
unsigned	O
long	O
sec_off	long
;	O
unsigned	O
int	O
offset_size	int
;	O
unsigned	O
int	O
initial_length_size	int
;	O
dwarf_vma	long
signature_high	long
=	O
0	int
;	O
dwarf_vma	long
signature_low	long
=	O
0	int
;	O
dwarf_vma	long
type_offset	long
=	O
0	int
;	O
struct	O
cu_tu_set	struct
*	O
this_set	pointer
;	O
dwarf_vma	long
abbrev_base	long
;	O
size_t	long
abbrev_size	long
;	O
hdrptr	pointer
=	O
start	pointer
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
compunit	struct
.	O
cu_length	long
,	O
hdrptr	pointer
,	O
4	int
,	O
end	pointer
)	O
;	O
if	O
(	O
compunit	struct
.	O
cu_length	long
==	O
0xffffffff	int
)	O
{	O
SAFE_BYTE_GET_AND_INC	O
(	O
compunit	struct
.	O
cu_length	long
,	O
hdrptr	pointer
,	O
8	int
,	O
end	pointer
)	O
;	O
offset_size	int
=	O
8	int
;	O
initial_length_size	int
=	O
12	int
;	O
}	O
else	O
{	O
offset_size	int
=	O
4	int
;	O
initial_length_size	int
=	O
4	int
;	O
}	O
SAFE_BYTE_GET_AND_INC	O
(	O
compunit	struct
.	O
cu_version	short
,	O
hdrptr	pointer
,	O
2	int
,	O
end	pointer
)	O
;	O
cu_offset	long
=	O
start	pointer
-	O
section_begin	pointer
;	O
this_set	pointer
=	O
find_cu_tu_set_v2	function
(	O
cu_offset	long
,	O
do_types	int
)	O
;	O
if	O
(	O
compunit	struct
.	O
cu_version	short
<	O
5	int
)	O
{	O
compunit	struct
.	O
cu_unit_type	enum
=	O
DW_UT_compile	int
;	O
compunit	struct
.	O
cu_pointer_size	char
=	O
-	O
1	int
;	O
}	O
else	O
{	O
SAFE_BYTE_GET_AND_INC	O
(	O
compunit	struct
.	O
cu_unit_type	enum
,	O
hdrptr	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
do_types	int
=	O
(	O
compunit	struct
.	O
cu_unit_type	enum
==	O
DW_UT_type	int
)	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
compunit	struct
.	O
cu_pointer_size	char
,	O
hdrptr	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
}	O
SAFE_BYTE_GET_AND_INC	O
(	O
compunit	struct
.	O
cu_abbrev_offset	long
,	O
hdrptr	pointer
,	O
offset_size	int
,	O
end	pointer
)	O
;	O
if	O
(	O
this_set	pointer
==	O
NULL	O
)	O
{	O
abbrev_base	long
=	O
0	int
;	O
abbrev_size	long
=	O
debug_displays	array
[	O
abbrev_sec	enum
]	O
.	O
section	pointer
.	O
size	int
;	O
}	O
else	O
{	O
abbrev_base	long
=	O
this_set	pointer
->	O
section_offsets	array
[	O
DW_SECT_ABBREV	int
]	O
;	O
abbrev_size	long
=	O
this_set	pointer
->	O
section_sizes	array
[	O
DW_SECT_ABBREV	int
]	O
;	O
}	O
if	O
(	O
compunit	struct
.	O
cu_version	short
<	O
5	int
)	O
SAFE_BYTE_GET_AND_INC	O
(	O
compunit	struct
.	O
cu_pointer_size	char
,	O
hdrptr	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
if	O
(	O
compunit	struct
.	O
cu_pointer_size	char
<	O
2	int
||	O
compunit	struct
.	O
cu_pointer_size	char
>	O
8	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Invalid pointer size (%d) in compunit header, using %d instead\n"	pointer
)	O
,	O
compunit	struct
.	O
cu_pointer_size	char
,	O
offset_size	int
)	O
;	O
compunit	struct
.	O
cu_pointer_size	char
=	O
offset_size	int
;	O
}	O
if	O
(	O
do_types	int
)	O
{	O
SAFE_BYTE_GET64	O
(	O
hdrptr	pointer
,	O
&	O
signature_high	long
,	O
&	O
signature_low	long
,	O
end	pointer
)	O
;	O
hdrptr	pointer
+=	O
8	int
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
type_offset	long
,	O
hdrptr	pointer
,	O
offset_size	int
,	O
end	pointer
)	O
;	O
}	O
if	O
(	O
dwarf_start_die	long
>	O
(	O
cu_offset	long
+	O
compunit	struct
.	O
cu_length	long
+	O
initial_length_size	int
)	O
)	O
{	O
start	pointer
=	O
section_begin	pointer
+	O
cu_offset	long
+	O
compunit	struct
.	O
cu_length	long
+	O
initial_length_size	int
;	O
continue	O
;	O
}	O
if	O
(	O
(	O
do_loc	int
||	O
do_debug_loc	int
||	O
do_debug_ranges	int
)	O
&&	O
num_debug_info_entries	int
==	O
0	int
&&	O
!	O
do_types	int
)	O
{	O
debug_information	pointer
[	O
unit	int
]	O
.	O
cu_offset	long
=	O
cu_offset	long
;	O
debug_information	pointer
[	O
unit	int
]	O
.	O
pointer_size	int
=	O
compunit	struct
.	O
cu_pointer_size	char
;	O
debug_information	pointer
[	O
unit	int
]	O
.	O
offset_size	int
=	O
offset_size	int
;	O
debug_information	pointer
[	O
unit	int
]	O
.	O
dwarf_version	int
=	O
compunit	struct
.	O
cu_version	short
;	O
debug_information	pointer
[	O
unit	int
]	O
.	O
base_address	long
=	O
0	int
;	O
debug_information	pointer
[	O
unit	int
]	O
.	O
addr_base	long
=	O
DEBUG_INFO_UNAVAILABLE	O
;	O
debug_information	pointer
[	O
unit	int
]	O
.	O
ranges_base	long
=	O
DEBUG_INFO_UNAVAILABLE	O
;	O
debug_information	pointer
[	O
unit	int
]	O
.	O
loc_offsets	pointer
=	O
NULL	O
;	O
debug_information	pointer
[	O
unit	int
]	O
.	O
have_frame_base	pointer
=	O
NULL	O
;	O
debug_information	pointer
[	O
unit	int
]	O
.	O
max_loc_offsets	int
=	O
0	int
;	O
debug_information	pointer
[	O
unit	int
]	O
.	O
num_loc_offsets	int
=	O
0	int
;	O
debug_information	pointer
[	O
unit	int
]	O
.	O
range_lists	pointer
=	O
NULL	O
;	O
debug_information	pointer
[	O
unit	int
]	O
.	O
max_range_lists	int
=	O
0	int
;	O
debug_information	pointer
[	O
unit	int
]	O
.	O
num_range_lists	int
=	O
0	int
;	O
}	O
if	O
(	O
!	O
do_loc	int
&&	O
dwarf_start_die	long
==	O
0	int
)	O
{	O
printf	function
(	O
_	O
(	O
"  Compilation Unit @ offset 0x%s:\n"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
cu_offset	long
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"   Length:        0x%s (%s)\n"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
compunit	struct
.	O
cu_length	long
)	O
,	O
offset_size	int
==	O
8	int
?	O
"64-bit"	pointer
:	O
"32-bit"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"   Version:       %d\n"	pointer
)	O
,	O
compunit	struct
.	O
cu_version	short
)	O
;	O
printf	function
(	O
_	O
(	O
"   Abbrev Offset: 0x%s\n"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
compunit	struct
.	O
cu_abbrev_offset	long
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"   Pointer Size:  %d\n"	pointer
)	O
,	O
compunit	struct
.	O
cu_pointer_size	char
)	O
;	O
if	O
(	O
do_types	int
)	O
{	O
char	O
buf	pointer
[	O
64	int
]	O
;	O
printf	function
(	O
_	O
(	O
"   Signature:     0x%s\n"	pointer
)	O
,	O
dwarf_vmatoa64	function
(	O
signature_high	long
,	O
signature_low	long
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"   Type Offset:   0x%s\n"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
type_offset	long
)	O
)	O
;	O
}	O
if	O
(	O
this_set	pointer
!=	O
NULL	O
)	O
{	O
dwarf_vma	long
*	O
offsets	pointer
=	O
this_set	pointer
->	O
section_offsets	array
;	O
size_t	long
*	O
sizes	pointer
=	O
this_set	pointer
->	O
section_sizes	array
;	O
printf	function
(	O
_	O
(	O
"   Section contributions:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"    .debug_abbrev.dwo:       0x%s  0x%s\n"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
offsets	pointer
[	O
DW_SECT_ABBREV	int
]	O
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
sizes	pointer
[	O
DW_SECT_ABBREV	int
]	O
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"    .debug_line.dwo:         0x%s  0x%s\n"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
offsets	pointer
[	O
DW_SECT_LINE	int
]	O
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
sizes	pointer
[	O
DW_SECT_LINE	int
]	O
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"    .debug_loc.dwo:          0x%s  0x%s\n"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
offsets	pointer
[	O
DW_SECT_LOC	int
]	O
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
sizes	pointer
[	O
DW_SECT_LOC	int
]	O
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"    .debug_str_offsets.dwo:  0x%s  0x%s\n"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
offsets	pointer
[	O
DW_SECT_STR_OFFSETS	int
]	O
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
sizes	pointer
[	O
DW_SECT_STR_OFFSETS	int
]	O
)	O
)	O
;	O
}	O
}	O
sec_off	long
=	O
cu_offset	long
+	O
initial_length_size	int
;	O
if	O
(	O
sec_off	long
+	O
compunit	struct
.	O
cu_length	long
<	O
sec_off	long
||	O
sec_off	long
+	O
compunit	struct
.	O
cu_length	long
>	O
section	pointer
->	O
size	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Debug info is corrupted, %s header at %#lx has length %s\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
,	O
(	O
unsigned	O
long	O
)	O
cu_offset	long
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
compunit	struct
.	O
cu_length	long
)	O
)	O
;	O
num_units	int
=	O
unit	int
;	O
break	O
;	O
}	O
tags	pointer
=	O
hdrptr	pointer
;	O
start	pointer
+=	O
compunit	struct
.	O
cu_length	long
+	O
initial_length_size	int
;	O
if	O
(	O
compunit	struct
.	O
cu_version	short
<	O
2	int
||	O
compunit	struct
.	O
cu_version	short
>	O
5	int
)	O
{	O
warn	function
(	O
_	O
(	O
"CU at offset %s contains corrupt or "	pointer
"unsupported version number: %d.\n"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
cu_offset	long
)	O
,	O
compunit	struct
.	O
cu_version	short
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
compunit	struct
.	O
cu_unit_type	enum
!=	O
DW_UT_compile	int
&&	O
compunit	struct
.	O
cu_unit_type	enum
!=	O
DW_UT_type	int
)	O
{	O
warn	function
(	O
_	O
(	O
"CU at offset %s contains corrupt or "	pointer
"unsupported unit type: %d.\n"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
cu_offset	long
)	O
,	O
compunit	struct
.	O
cu_unit_type	enum
)	O
;	O
continue	O
;	O
}	O
free_abbrevs	function
(	O
)	O
;	O
if	O
(	O
compunit	struct
.	O
cu_abbrev_offset	long
>=	O
abbrev_size	long
)	O
warn	function
(	O
_	O
(	O
"Debug info is corrupted, abbrev offset (%lx) is larger than abbrev section size (%lx)\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
compunit	struct
.	O
cu_abbrev_offset	long
,	O
(	O
unsigned	O
long	O
)	O
abbrev_size	long
)	O
;	O
else	O
if	O
(	O
(	O
abbrev_base	long
+	O
abbrev_size	long
)	O
>	O
debug_displays	array
[	O
abbrev_sec	enum
]	O
.	O
section	pointer
.	O
size	int
)	O
warn	function
(	O
_	O
(	O
"Debug info is corrupted, abbrev size (%lx) is larger than abbrev section size (%lx)\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
abbrev_base	long
+	O
abbrev_size	long
,	O
(	O
unsigned	O
long	O
)	O
debug_displays	array
[	O
abbrev_sec	enum
]	O
.	O
section	pointer
.	O
size	int
)	O
;	O
else	O
process_abbrev_section	function
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
debug_displays	array
[	O
abbrev_sec	enum
]	O
.	O
section	pointer
.	O
start	pointer
+	O
abbrev_base	long
+	O
compunit	struct
.	O
cu_abbrev_offset	long
)	O
,	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
debug_displays	array
[	O
abbrev_sec	enum
]	O
.	O
section	pointer
.	O
start	pointer
+	O
abbrev_base	long
+	O
abbrev_size	long
)	O
)	O
;	O
level	int
=	O
0	int
;	O
last_level	int
=	O
level	int
;	O
saved_level	int
=	O
-	O
1	int
;	O
while	O
(	O
tags	pointer
<	O
start	pointer
)	O
{	O
unsigned	O
long	O
abbrev_number	long
;	O
unsigned	O
long	O
die_offset	long
;	O
abbrev_entry	struct
*	O
entry	long
;	O
abbrev_attr	struct
*	O
attr	int
;	O
int	O
do_printing	int
=	O
1	int
;	O
die_offset	long
=	O
tags	pointer
-	O
section_begin	pointer
;	O
READ_ULEB	O
(	O
abbrev_number	long
,	O
tags	pointer
,	O
start	pointer
)	O
;	O
if	O
(	O
abbrev_number	long
==	O
0	int
)	O
{	O
if	O
(	O
level	int
==	O
0	int
&&	O
start	pointer
==	O
end	pointer
)	O
{	O
unsigned	O
char	O
*	O
chk	pointer
;	O
for	O
(	O
chk	pointer
=	O
tags	pointer
;	O
chk	pointer
<	O
start	pointer
;	O
chk	pointer
++	O
)	O
if	O
(	O
*	O
chk	pointer
!=	O
0	int
)	O
break	O
;	O
if	O
(	O
chk	pointer
==	O
start	pointer
)	O
break	O
;	O
}	O
if	O
(	O
!	O
do_loc	int
&&	O
die_offset	long
>=	O
dwarf_start_die	long
&&	O
(	O
dwarf_cutoff_level	int
==	O
-	O
1	int
||	O
level	int
<	O
dwarf_cutoff_level	int
)	O
)	O
printf	function
(	O
_	O
(	O
" <%d><%lx>: Abbrev Number: 0\n"	pointer
)	O
,	O
level	int
,	O
die_offset	long
)	O
;	O
--	O
level	int
;	O
if	O
(	O
level	int
<	O
0	int
)	O
{	O
static	O
unsigned	O
num_bogus_warns	int
=	O
0	int
;	O
if	O
(	O
num_bogus_warns	int
<	O
3	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Bogus end-of-siblings marker detected at offset %lx in %s section\n"	pointer
)	O
,	O
die_offset	long
,	O
section	pointer
->	O
name	pointer
)	O
;	O
num_bogus_warns	int
++	O
;	O
if	O
(	O
num_bogus_warns	int
==	O
3	int
)	O
warn	function
(	O
_	O
(	O
"Further warnings about bogus end-of-sibling markers suppressed\n"	pointer
)	O
)	O
;	O
}	O
}	O
if	O
(	O
dwarf_start_die	long
!=	O
0	int
&&	O
level	int
<	O
saved_level	int
)	O
return	O
TRUE	int
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
do_loc	int
)	O
{	O
if	O
(	O
dwarf_start_die	long
!=	O
0	int
&&	O
die_offset	long
<	O
dwarf_start_die	long
)	O
do_printing	int
=	O
0	int
;	O
else	O
{	O
if	O
(	O
dwarf_start_die	long
!=	O
0	int
&&	O
die_offset	long
==	O
dwarf_start_die	long
)	O
saved_level	int
=	O
level	int
;	O
do_printing	int
=	O
(	O
dwarf_cutoff_level	int
==	O
-	O
1	int
||	O
level	int
<	O
dwarf_cutoff_level	int
)	O
;	O
if	O
(	O
do_printing	int
)	O
printf	function
(	O
_	O
(	O
" <%d><%lx>: Abbrev Number: %lu"	pointer
)	O
,	O
level	int
,	O
die_offset	long
,	O
abbrev_number	long
)	O
;	O
else	O
if	O
(	O
dwarf_cutoff_level	int
==	O
-	O
1	int
||	O
last_level	int
<	O
dwarf_cutoff_level	int
)	O
printf	function
(	O
_	O
(	O
" <%d><%lx>: ...\n"	pointer
)	O
,	O
level	int
,	O
die_offset	long
)	O
;	O
last_level	int
=	O
level	int
;	O
}	O
}	O
for	O
(	O
entry	long
=	O
first_abbrev	pointer
;	O
entry	long
&&	O
entry	long
->	O
entry	long
!=	O
abbrev_number	long
;	O
entry	long
=	O
entry	long
->	O
next	pointer
)	O
continue	O
;	O
if	O
(	O
entry	long
==	O
NULL	O
)	O
{	O
if	O
(	O
!	O
do_loc	int
&&	O
do_printing	int
)	O
{	O
printf	function
(	O
"\n"	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
}	O
warn	function
(	O
_	O
(	O
"DIE at offset 0x%lx refers to abbreviation number %lu which does not exist\n"	pointer
)	O
,	O
die_offset	long
,	O
abbrev_number	long
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
!	O
do_loc	int
&&	O
do_printing	int
)	O
printf	function
(	O
" (%s)\n"	pointer
,	O
get_TAG_name	function
(	O
entry	long
->	O
tag	int
)	O
)	O
;	O
switch	O
(	O
entry	long
->	O
tag	int
)	O
{	O
default	O
:	O
need_base_address	int
=	O
0	int
;	O
break	O
;	O
case	O
DW_TAG_compile_unit	int
:	O
need_base_address	int
=	O
1	int
;	O
need_dwo_info	int
=	O
do_loc	int
;	O
break	O
;	O
case	O
DW_TAG_entry_point	int
:	O
case	O
DW_TAG_subprogram	int
:	O
need_base_address	int
=	O
0	int
;	O
have_frame_base	pointer
=	O
0	int
;	O
break	O
;	O
}	O
debug_info	struct
*	O
debug_info_p	pointer
=	O
(	O
debug_information	pointer
&&	O
unit	int
<	O
alloc_num_debug_info_entries	int
)	O
?	O
debug_information	pointer
+	O
unit	int
:	O
NULL	O
;	O
assert	O
(	O
!	O
debug_info_p	pointer
||	O
(	O
debug_info_p	pointer
->	O
num_loc_offsets	int
==	O
debug_info_p	pointer
->	O
num_loc_views	int
)	O
)	O
;	O
for	O
(	O
attr	int
=	O
entry	long
->	O
first_attr	pointer
;	O
attr	int
&&	O
attr	int
->	O
attribute	long
;	O
attr	int
=	O
attr	int
->	O
next	pointer
)	O
{	O
if	O
(	O
!	O
do_loc	int
&&	O
do_printing	int
)	O
printf	function
(	O
"    <%lx>"	pointer
,	O
(	O
unsigned	O
long	O
)	O
(	O
tags	pointer
-	O
section_begin	pointer
)	O
)	O
;	O
tags	pointer
=	O
read_and_display_attr	function
(	O
attr	int
->	O
attribute	long
,	O
attr	int
->	O
form	int
,	O
attr	int
->	O
implicit_const	long
,	O
section_begin	pointer
,	O
tags	pointer
,	O
end	pointer
,	O
cu_offset	long
,	O
compunit	struct
.	O
cu_pointer_size	char
,	O
offset_size	int
,	O
compunit	struct
.	O
cu_version	short
,	O
debug_info_p	pointer
,	O
do_loc	int
||	O
!	O
do_printing	int
,	O
section	pointer
,	O
this_set	pointer
,	O
level	int
)	O
;	O
}	O
if	O
(	O
debug_info_p	pointer
)	O
switch	O
(	O
debug_info_p	pointer
->	O
num_loc_offsets	int
-	O
debug_info_p	pointer
->	O
num_loc_views	int
)	O
{	O
case	O
1	int
:	O
debug_info_p	pointer
->	O
loc_views	pointer
[	O
debug_info_p	pointer
->	O
num_loc_views	int
]	O
=	O
vm1	long
;	O
debug_info_p	pointer
->	O
num_loc_views	int
++	O
;	O
assert	O
(	O
debug_info_p	pointer
->	O
num_loc_views	int
==	O
debug_info_p	pointer
->	O
num_loc_offsets	int
)	O
;	O
break	O
;	O
case	O
0	int
:	O
break	O
;	O
case	O
-	O
1	int
:	O
warn	function
(	O
_	O
(	O
"DIE has locviews without loclist\n"	pointer
)	O
)	O
;	O
debug_info_p	pointer
->	O
num_loc_views	int
--	O
;	O
break	O
;	O
default	O
:	O
assert	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
entry	long
->	O
children	int
)	O
++	O
level	int
;	O
}	O
}	O
if	O
(	O
(	O
do_loc	int
||	O
do_debug_loc	int
||	O
do_debug_ranges	int
)	O
&&	O
num_debug_info_entries	int
==	O
0	int
&&	O
!	O
do_types	int
)	O
{	O
if	O
(	O
num_units	int
>	O
alloc_num_debug_info_entries	int
)	O
num_debug_info_entries	int
=	O
alloc_num_debug_info_entries	int
;	O
else	O
num_debug_info_entries	int
=	O
num_units	int
;	O
}	O
if	O
(	O
!	O
do_loc	int
)	O
printf	function
(	O
"\n"	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
unsigned	O
int	O
load_debug_info	function
(	O
void	O
*	O
file	pointer
)	O
{	O
if	O
(	O
num_debug_info_entries	int
==	O
DEBUG_INFO_UNAVAILABLE	O
)	O
return	O
0	int
;	O
if	O
(	O
num_debug_info_entries	int
>	O
0	int
)	O
return	O
num_debug_info_entries	int
;	O
(	O
void	O
)	O
load_cu_tu_indexes	function
(	O
file	pointer
)	O
;	O
if	O
(	O
load_debug_section_with_follow	function
(	O
info	pointer
,	O
file	pointer
)	O
&&	O
process_debug_info	function
(	O
&	O
debug_displays	array
[	O
info	pointer
]	O
.	O
section	pointer
,	O
file	pointer
,	O
abbrev	int
,	O
TRUE	int
,	O
FALSE	int
)	O
)	O
return	O
num_debug_info_entries	int
;	O
if	O
(	O
load_debug_section_with_follow	function
(	O
info_dwo	int
,	O
file	pointer
)	O
&&	O
process_debug_info	function
(	O
&	O
debug_displays	array
[	O
info_dwo	int
]	O
.	O
section	pointer
,	O
file	pointer
,	O
abbrev_dwo	int
,	O
TRUE	int
,	O
FALSE	int
)	O
)	O
return	O
num_debug_info_entries	int
;	O
num_debug_info_entries	int
=	O
DEBUG_INFO_UNAVAILABLE	O
;	O
return	O
0	int
;	O
}	O
static	O
unsigned	O
char	O
*	O
read_debug_line_header	function
(	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
unsigned	O
char	O
*	O
data	pointer
,	O
unsigned	O
char	O
*	O
end	pointer
,	O
DWARF2_Internal_LineInfo	struct
*	O
linfo	pointer
,	O
unsigned	O
char	O
*	O
*	O
end_of_sequence	pointer
)	O
{	O
unsigned	O
char	O
*	O
hdrptr	pointer
;	O
unsigned	O
int	O
initial_length_size	int
;	O
unsigned	O
char	O
address_size	char
,	O
segment_selector_size	char
;	O
hdrptr	pointer
=	O
data	pointer
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
linfo	pointer
->	O
li_length	long
,	O
hdrptr	pointer
,	O
4	int
,	O
end	pointer
)	O
;	O
if	O
(	O
linfo	pointer
->	O
li_length	long
==	O
0xffffffff	int
)	O
{	O
SAFE_BYTE_GET_AND_INC	O
(	O
linfo	pointer
->	O
li_length	long
,	O
hdrptr	pointer
,	O
8	int
,	O
end	pointer
)	O
;	O
linfo	pointer
->	O
li_offset_size	int
=	O
8	int
;	O
initial_length_size	int
=	O
12	int
;	O
}	O
else	O
{	O
linfo	pointer
->	O
li_offset_size	int
=	O
4	int
;	O
initial_length_size	int
=	O
4	int
;	O
}	O
if	O
(	O
linfo	pointer
->	O
li_length	long
+	O
initial_length_size	int
>	O
section	pointer
->	O
size	int
)	O
{	O
if	O
(	O
reloc_at	function
(	O
section	pointer
,	O
(	O
hdrptr	pointer
-	O
section	pointer
->	O
start	pointer
)	O
-	O
linfo	pointer
->	O
li_offset_size	int
)	O
)	O
{	O
linfo	pointer
->	O
li_length	long
=	O
(	O
end	pointer
-	O
data	pointer
)	O
-	O
initial_length_size	int
;	O
}	O
else	O
{	O
warn	function
(	O
_	O
(	O
"The length field (0x%lx) in the debug_line header is wrong - the section is too small\n"	pointer
)	O
,	O
(	O
long	O
)	O
linfo	pointer
->	O
li_length	long
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
SAFE_BYTE_GET_AND_INC	O
(	O
linfo	pointer
->	O
li_version	short
,	O
hdrptr	pointer
,	O
2	int
,	O
end	pointer
)	O
;	O
if	O
(	O
linfo	pointer
->	O
li_version	short
!=	O
2	int
&&	O
linfo	pointer
->	O
li_version	short
!=	O
3	int
&&	O
linfo	pointer
->	O
li_version	short
!=	O
4	int
&&	O
linfo	pointer
->	O
li_version	short
!=	O
5	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Only DWARF version 2, 3, 4 and 5 line info "	pointer
"is currently supported.\n"	pointer
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
linfo	pointer
->	O
li_version	short
>=	O
5	int
)	O
{	O
SAFE_BYTE_GET_AND_INC	O
(	O
address_size	char
,	O
hdrptr	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
segment_selector_size	char
,	O
hdrptr	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
if	O
(	O
segment_selector_size	char
!=	O
0	int
)	O
{	O
warn	function
(	O
_	O
(	O
"The %s section contains "	pointer
"unsupported segment selector size: %d.\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
,	O
segment_selector_size	char
)	O
;	O
return	O
0	int
;	O
}	O
}	O
SAFE_BYTE_GET_AND_INC	O
(	O
linfo	pointer
->	O
li_prologue_length	long
,	O
hdrptr	pointer
,	O
linfo	pointer
->	O
li_offset_size	int
,	O
end	pointer
)	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
linfo	pointer
->	O
li_min_insn_length	char
,	O
hdrptr	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
if	O
(	O
linfo	pointer
->	O
li_version	short
>=	O
4	int
)	O
{	O
SAFE_BYTE_GET_AND_INC	O
(	O
linfo	pointer
->	O
li_max_ops_per_insn	char
,	O
hdrptr	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
if	O
(	O
linfo	pointer
->	O
li_max_ops_per_insn	char
==	O
0	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Invalid maximum operations per insn.\n"	pointer
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
else	O
linfo	pointer
->	O
li_max_ops_per_insn	char
=	O
1	int
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
linfo	pointer
->	O
li_default_is_stmt	char
,	O
hdrptr	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
SAFE_SIGNED_BYTE_GET_AND_INC	O
(	O
linfo	pointer
->	O
li_line_base	int
,	O
hdrptr	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
linfo	pointer
->	O
li_line_range	char
,	O
hdrptr	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
linfo	pointer
->	O
li_opcode_base	char
,	O
hdrptr	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
*	O
end_of_sequence	pointer
=	O
data	pointer
+	O
linfo	pointer
->	O
li_length	long
+	O
initial_length_size	int
;	O
if	O
(	O
*	O
end_of_sequence	pointer
>	O
end	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"Line length %s extends beyond end of section\n"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"u"	pointer
,	O
linfo	pointer
->	O
li_length	long
)	O
)	O
;	O
*	O
end_of_sequence	pointer
=	O
end	pointer
;	O
return	O
NULL	O
;	O
}	O
return	O
hdrptr	pointer
;	O
}	O
static	O
unsigned	O
char	O
*	O
display_formatted_table	function
(	O
unsigned	O
char	O
*	O
data	pointer
,	O
unsigned	O
char	O
*	O
start	pointer
,	O
unsigned	O
char	O
*	O
end	pointer
,	O
const	O
DWARF2_Internal_LineInfo	struct
*	O
linfo	pointer
,	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
bfd_boolean	int
is_dir	int
)	O
{	O
unsigned	O
char	O
*	O
format_start	pointer
,	O
format_count	char
,	O
*	O
format	enum
,	O
formati	char
;	O
dwarf_vma	long
data_count	long
,	O
datai	long
;	O
unsigned	O
int	O
namepass	int
,	O
last_entry	int
=	O
0	int
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
format_count	char
,	O
data	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
format_start	pointer
=	O
data	pointer
;	O
for	O
(	O
formati	char
=	O
0	int
;	O
formati	char
<	O
format_count	char
;	O
formati	char
++	O
)	O
{	O
SKIP_ULEB	O
(	O
data	pointer
,	O
end	pointer
)	O
;	O
SKIP_ULEB	O
(	O
data	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
data	pointer
==	O
end	pointer
)	O
{	O
if	O
(	O
is_dir	int
)	O
warn	function
(	O
_	O
(	O
"Corrupt directory format table entry\n"	pointer
)	O
)	O
;	O
else	O
warn	function
(	O
_	O
(	O
"Corrupt file name format table entry\n"	pointer
)	O
)	O
;	O
return	O
data	pointer
;	O
}	O
}	O
READ_ULEB	O
(	O
data_count	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
data	pointer
==	O
end	pointer
)	O
{	O
if	O
(	O
is_dir	int
)	O
warn	function
(	O
_	O
(	O
"Corrupt directory list\n"	pointer
)	O
)	O
;	O
else	O
warn	function
(	O
_	O
(	O
"Corrupt file name list\n"	pointer
)	O
)	O
;	O
return	O
data	pointer
;	O
}	O
if	O
(	O
data_count	long
==	O
0	int
)	O
{	O
if	O
(	O
is_dir	int
)	O
printf	function
(	O
_	O
(	O
"\n The Directory Table is empty.\n"	pointer
)	O
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"\n The File Name Table is empty.\n"	pointer
)	O
)	O
;	O
return	O
data	pointer
;	O
}	O
if	O
(	O
is_dir	int
)	O
printf	function
(	O
_	O
(	O
"\n The Directory Table (offset 0x%lx):\n"	pointer
)	O
,	O
(	O
long	O
)	O
(	O
data	pointer
-	O
start	pointer
)	O
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"\n The File Name Table (offset 0x%lx):\n"	pointer
)	O
,	O
(	O
long	O
)	O
(	O
data	pointer
-	O
start	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  Entry"	pointer
)	O
)	O
;	O
for	O
(	O
namepass	int
=	O
0	int
;	O
namepass	int
<	O
2	int
;	O
namepass	int
++	O
)	O
{	O
format	enum
=	O
format_start	pointer
;	O
for	O
(	O
formati	char
=	O
0	int
;	O
formati	char
<	O
format_count	char
;	O
formati	char
++	O
)	O
{	O
dwarf_vma	long
content_type	long
;	O
READ_ULEB	O
(	O
content_type	long
,	O
format	enum
,	O
end	pointer
)	O
;	O
if	O
(	O
(	O
content_type	long
==	O
DW_LNCT_path	int
)	O
==	O
(	O
namepass	int
==	O
1	int
)	O
)	O
switch	O
(	O
content_type	long
)	O
{	O
case	O
DW_LNCT_path	int
:	O
printf	function
(	O
_	O
(	O
"\tName"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
DW_LNCT_directory_index	int
:	O
printf	function
(	O
_	O
(	O
"\tDir"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
DW_LNCT_timestamp	int
:	O
printf	function
(	O
_	O
(	O
"\tTime"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
DW_LNCT_size	int
:	O
printf	function
(	O
_	O
(	O
"\tSize"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
DW_LNCT_MD5	int
:	O
printf	function
(	O
_	O
(	O
"\tMD5"	pointer
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
_	O
(	O
"\t(Unknown format content type %s)"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"u"	pointer
,	O
content_type	long
)	O
)	O
;	O
}	O
SKIP_ULEB	O
(	O
format	enum
,	O
end	pointer
)	O
;	O
}	O
}	O
putchar	function
(	O
'\n'	O
)	O
;	O
for	O
(	O
datai	long
=	O
0	int
;	O
datai	long
<	O
data_count	long
;	O
datai	long
++	O
)	O
{	O
unsigned	O
char	O
*	O
datapass	pointer
=	O
data	pointer
;	O
printf	function
(	O
"  %d"	pointer
,	O
last_entry	int
++	O
)	O
;	O
for	O
(	O
namepass	int
=	O
0	int
;	O
namepass	int
<	O
2	int
;	O
namepass	int
++	O
)	O
{	O
format	enum
=	O
format_start	pointer
;	O
data	pointer
=	O
datapass	pointer
;	O
for	O
(	O
formati	char
=	O
0	int
;	O
formati	char
<	O
format_count	char
;	O
formati	char
++	O
)	O
{	O
dwarf_vma	long
content_type	long
,	O
form	int
;	O
READ_ULEB	O
(	O
content_type	long
,	O
format	enum
,	O
end	pointer
)	O
;	O
READ_ULEB	O
(	O
form	int
,	O
format	enum
,	O
end	pointer
)	O
;	O
data	pointer
=	O
read_and_display_attr_value	function
(	O
0	int
,	O
form	int
,	O
0	int
,	O
start	pointer
,	O
data	pointer
,	O
end	pointer
,	O
0	int
,	O
0	int
,	O
linfo	pointer
->	O
li_offset_size	int
,	O
linfo	pointer
->	O
li_version	short
,	O
NULL	O
,	O
(	O
(	O
content_type	long
==	O
DW_LNCT_path	int
)	O
!=	O
(	O
namepass	int
==	O
1	int
)	O
)	O
,	O
section	pointer
,	O
NULL	O
,	O
'\t'	O
,	O
-	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
data	pointer
==	O
end	pointer
)	O
{	O
if	O
(	O
is_dir	int
)	O
warn	function
(	O
_	O
(	O
"Corrupt directory entries list\n"	pointer
)	O
)	O
;	O
else	O
warn	function
(	O
_	O
(	O
"Corrupt file name entries list\n"	pointer
)	O
)	O
;	O
return	O
data	pointer
;	O
}	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
return	O
data	pointer
;	O
}	O
static	O
int	O
display_debug_lines_raw	function
(	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
unsigned	O
char	O
*	O
data	pointer
,	O
unsigned	O
char	O
*	O
end	pointer
,	O
void	O
*	O
file	pointer
)	O
{	O
unsigned	O
char	O
*	O
start	pointer
=	O
section	pointer
->	O
start	pointer
;	O
int	O
verbose_view	int
=	O
0	int
;	O
introduce	function
(	O
section	pointer
,	O
TRUE	int
)	O
;	O
while	O
(	O
data	pointer
<	O
end	pointer
)	O
{	O
static	O
DWARF2_Internal_LineInfo	struct
saved_linfo	struct
;	O
DWARF2_Internal_LineInfo	struct
linfo	pointer
;	O
unsigned	O
char	O
*	O
standard_opcodes	pointer
;	O
unsigned	O
char	O
*	O
end_of_sequence	pointer
;	O
int	O
i	pointer
;	O
if	O
(	O
const_strneq	O
(	O
section	pointer
->	O
name	pointer
,	O
".debug_line."	pointer
)	O
&&	O
strcmp	function
(	O
section	pointer
->	O
name	pointer
,	O
".debug_line.dwo"	pointer
)	O
!=	O
0	int
)	O
{	O
end_of_sequence	pointer
=	O
end	pointer
;	O
standard_opcodes	pointer
=	O
NULL	O
;	O
linfo	pointer
=	O
saved_linfo	struct
;	O
if	O
(	O
linfo	pointer
.	O
li_line_range	char
==	O
0	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Partial .debug_line. section encountered without a prior full .debug_line section\n"	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
reset_state_machine	function
(	O
linfo	pointer
.	O
li_default_is_stmt	char
)	O
;	O
}	O
else	O
{	O
unsigned	O
char	O
*	O
hdrptr	pointer
;	O
if	O
(	O
(	O
hdrptr	pointer
=	O
read_debug_line_header	function
(	O
section	pointer
,	O
data	pointer
,	O
end	pointer
,	O
&	O
linfo	pointer
,	O
&	O
end_of_sequence	pointer
)	O
)	O
==	O
NULL	O
)	O
return	O
0	int
;	O
printf	function
(	O
_	O
(	O
"  Offset:                      0x%lx\n"	pointer
)	O
,	O
(	O
long	O
)	O
(	O
data	pointer
-	O
start	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  Length:                      %ld\n"	pointer
)	O
,	O
(	O
long	O
)	O
linfo	pointer
.	O
li_length	long
)	O
;	O
printf	function
(	O
_	O
(	O
"  DWARF Version:               %d\n"	pointer
)	O
,	O
linfo	pointer
.	O
li_version	short
)	O
;	O
printf	function
(	O
_	O
(	O
"  Prologue Length:             %d\n"	pointer
)	O
,	O
(	O
int	O
)	O
linfo	pointer
.	O
li_prologue_length	long
)	O
;	O
printf	function
(	O
_	O
(	O
"  Minimum Instruction Length:  %d\n"	pointer
)	O
,	O
linfo	pointer
.	O
li_min_insn_length	char
)	O
;	O
if	O
(	O
linfo	pointer
.	O
li_version	short
>=	O
4	int
)	O
printf	function
(	O
_	O
(	O
"  Maximum Ops per Instruction: %d\n"	pointer
)	O
,	O
linfo	pointer
.	O
li_max_ops_per_insn	char
)	O
;	O
printf	function
(	O
_	O
(	O
"  Initial value of 'is_stmt':  %d\n"	pointer
)	O
,	O
linfo	pointer
.	O
li_default_is_stmt	char
)	O
;	O
printf	function
(	O
_	O
(	O
"  Line Base:                   %d\n"	pointer
)	O
,	O
linfo	pointer
.	O
li_line_base	int
)	O
;	O
printf	function
(	O
_	O
(	O
"  Line Range:                  %d\n"	pointer
)	O
,	O
linfo	pointer
.	O
li_line_range	char
)	O
;	O
printf	function
(	O
_	O
(	O
"  Opcode Base:                 %d\n"	pointer
)	O
,	O
linfo	pointer
.	O
li_opcode_base	char
)	O
;	O
if	O
(	O
linfo	pointer
.	O
li_line_range	char
==	O
0	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Line range of 0 is invalid, using 1 instead\n"	pointer
)	O
)	O
;	O
linfo	pointer
.	O
li_line_range	char
=	O
1	int
;	O
}	O
reset_state_machine	function
(	O
linfo	pointer
.	O
li_default_is_stmt	char
)	O
;	O
standard_opcodes	pointer
=	O
hdrptr	pointer
;	O
if	O
(	O
standard_opcodes	pointer
+	O
linfo	pointer
.	O
li_opcode_base	char
>=	O
end	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"Line Base extends beyond end of section\n"	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
printf	function
(	O
_	O
(	O
"\n Opcodes:\n"	pointer
)	O
)	O
;	O
for	O
(	O
i	pointer
=	O
1	int
;	O
i	pointer
<	O
linfo	pointer
.	O
li_opcode_base	char
;	O
i	pointer
++	O
)	O
printf	function
(	O
ngettext	function
(	O
"  Opcode %d has %d arg\n"	pointer
,	O
"  Opcode %d has %d args\n"	pointer
,	O
standard_opcodes	pointer
[	O
i	pointer
-	O
1	int
]	O
)	O
,	O
i	pointer
,	O
standard_opcodes	pointer
[	O
i	pointer
-	O
1	int
]	O
)	O
;	O
data	pointer
=	O
standard_opcodes	pointer
+	O
linfo	pointer
.	O
li_opcode_base	char
-	O
1	int
;	O
if	O
(	O
linfo	pointer
.	O
li_version	short
>=	O
5	int
)	O
{	O
load_debug_section_with_follow	function
(	O
line_str	int
,	O
file	pointer
)	O
;	O
data	pointer
=	O
display_formatted_table	function
(	O
data	pointer
,	O
start	pointer
,	O
end	pointer
,	O
&	O
linfo	pointer
,	O
section	pointer
,	O
TRUE	int
)	O
;	O
data	pointer
=	O
display_formatted_table	function
(	O
data	pointer
,	O
start	pointer
,	O
end	pointer
,	O
&	O
linfo	pointer
,	O
section	pointer
,	O
FALSE	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
*	O
data	pointer
==	O
0	int
)	O
printf	function
(	O
_	O
(	O
"\n The Directory Table is empty.\n"	pointer
)	O
)	O
;	O
else	O
{	O
unsigned	O
int	O
last_dir_entry	int
=	O
0	int
;	O
printf	function
(	O
_	O
(	O
"\n The Directory Table (offset 0x%lx):\n"	pointer
)	O
,	O
(	O
long	O
)	O
(	O
data	pointer
-	O
start	pointer
)	O
)	O
;	O
while	O
(	O
data	pointer
<	O
end	pointer
&&	O
*	O
data	pointer
!=	O
0	int
)	O
{	O
printf	function
(	O
"  %d\t%.*s\n"	pointer
,	O
++	O
last_dir_entry	int
,	O
(	O
int	O
)	O
(	O
end	pointer
-	O
data	pointer
)	O
,	O
data	pointer
)	O
;	O
data	pointer
+=	O
strnlen	function
(	O
(	O
char	O
*	O
)	O
data	pointer
,	O
end	pointer
-	O
data	pointer
)	O
+	O
1	int
;	O
}	O
if	O
(	O
data	pointer
>=	O
end	pointer
-	O
1	int
)	O
break	O
;	O
}	O
data	pointer
++	O
;	O
if	O
(	O
*	O
data	pointer
==	O
0	int
)	O
printf	function
(	O
_	O
(	O
"\n The File Name Table is empty.\n"	pointer
)	O
)	O
;	O
else	O
{	O
printf	function
(	O
_	O
(	O
"\n The File Name Table (offset 0x%lx):\n"	pointer
)	O
,	O
(	O
long	O
)	O
(	O
data	pointer
-	O
start	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  Entry\tDir\tTime\tSize\tName\n"	pointer
)	O
)	O
;	O
while	O
(	O
data	pointer
<	O
end	pointer
&&	O
*	O
data	pointer
!=	O
0	int
)	O
{	O
unsigned	O
char	O
*	O
name	pointer
;	O
dwarf_vma	long
val	array
;	O
printf	function
(	O
"  %d\t"	pointer
,	O
++	O
state_machine_regs	struct
.	O
last_file_entry	int
)	O
;	O
name	pointer
=	O
data	pointer
;	O
data	pointer
+=	O
strnlen	function
(	O
(	O
char	O
*	O
)	O
data	pointer
,	O
end	pointer
-	O
data	pointer
)	O
+	O
1	int
;	O
READ_ULEB	O
(	O
val	array
,	O
data	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"%s\t"	pointer
,	O
dwarf_vmatoa	function
(	O
"u"	pointer
,	O
val	array
)	O
)	O
;	O
READ_ULEB	O
(	O
val	array
,	O
data	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"%s\t"	pointer
,	O
dwarf_vmatoa	function
(	O
"u"	pointer
,	O
val	array
)	O
)	O
;	O
READ_ULEB	O
(	O
val	array
,	O
data	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"%s\t"	pointer
,	O
dwarf_vmatoa	function
(	O
"u"	pointer
,	O
val	array
)	O
)	O
;	O
printf	function
(	O
"%.*s\n"	pointer
,	O
(	O
int	O
)	O
(	O
end	pointer
-	O
name	pointer
)	O
,	O
name	pointer
)	O
;	O
if	O
(	O
data	pointer
==	O
end	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"Corrupt file name table entry\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
}	O
}	O
data	pointer
++	O
;	O
}	O
putchar	function
(	O
'\n'	O
)	O
;	O
saved_linfo	struct
=	O
linfo	pointer
;	O
}	O
if	O
(	O
data	pointer
>=	O
end_of_sequence	pointer
)	O
printf	function
(	O
_	O
(	O
" No Line Number Statements.\n"	pointer
)	O
)	O
;	O
else	O
{	O
printf	function
(	O
_	O
(	O
" Line Number Statements:\n"	pointer
)	O
)	O
;	O
while	O
(	O
data	pointer
<	O
end_of_sequence	pointer
)	O
{	O
unsigned	O
char	O
op_code	char
;	O
dwarf_signed_vma	long
adv	long
;	O
dwarf_vma	long
uladv	long
;	O
printf	function
(	O
"  [0x%08lx]"	pointer
,	O
(	O
long	O
)	O
(	O
data	pointer
-	O
start	pointer
)	O
)	O
;	O
op_code	char
=	O
*	O
data	pointer
++	O
;	O
if	O
(	O
op_code	char
>=	O
linfo	pointer
.	O
li_opcode_base	char
)	O
{	O
op_code	char
-=	O
linfo	pointer
.	O
li_opcode_base	char
;	O
uladv	long
=	O
(	O
op_code	char
/	O
linfo	pointer
.	O
li_line_range	char
)	O
;	O
if	O
(	O
linfo	pointer
.	O
li_max_ops_per_insn	char
==	O
1	int
)	O
{	O
uladv	long
*=	O
linfo	pointer
.	O
li_min_insn_length	char
;	O
state_machine_regs	struct
.	O
address	long
+=	O
uladv	long
;	O
if	O
(	O
uladv	long
)	O
state_machine_regs	struct
.	O
view	int
=	O
0	int
;	O
printf	function
(	O
_	O
(	O
"  Special opcode %d: "	pointer
"advance Address by %s to 0x%s%s"	pointer
)	O
,	O
op_code	char
,	O
dwarf_vmatoa	function
(	O
"u"	pointer
,	O
uladv	long
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
state_machine_regs	struct
.	O
address	long
)	O
,	O
verbose_view	int
&&	O
uladv	long
?	O
_	O
(	O
" (reset view)"	pointer
)	O
:	O
""	pointer
)	O
;	O
}	O
else	O
{	O
unsigned	O
addrdelta	int
=	O
(	O
(	O
state_machine_regs	struct
.	O
op_index	char
+	O
uladv	long
)	O
/	O
linfo	pointer
.	O
li_max_ops_per_insn	char
)	O
*	O
linfo	pointer
.	O
li_min_insn_length	char
;	O
state_machine_regs	struct
.	O
address	long
+=	O
addrdelta	int
;	O
state_machine_regs	struct
.	O
op_index	char
=	O
(	O
state_machine_regs	struct
.	O
op_index	char
+	O
uladv	long
)	O
%	O
linfo	pointer
.	O
li_max_ops_per_insn	char
;	O
if	O
(	O
addrdelta	int
)	O
state_machine_regs	struct
.	O
view	int
=	O
0	int
;	O
printf	function
(	O
_	O
(	O
"  Special opcode %d: "	pointer
"advance Address by %s to 0x%s[%d]%s"	pointer
)	O
,	O
op_code	char
,	O
dwarf_vmatoa	function
(	O
"u"	pointer
,	O
uladv	long
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
state_machine_regs	struct
.	O
address	long
)	O
,	O
state_machine_regs	struct
.	O
op_index	char
,	O
verbose_view	int
&&	O
addrdelta	int
?	O
_	O
(	O
" (reset view)"	pointer
)	O
:	O
""	pointer
)	O
;	O
}	O
adv	long
=	O
(	O
op_code	char
%	O
linfo	pointer
.	O
li_line_range	char
)	O
+	O
linfo	pointer
.	O
li_line_base	int
;	O
state_machine_regs	struct
.	O
line	int
+=	O
adv	long
;	O
printf	function
(	O
_	O
(	O
" and Line by %s to %d"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"d"	pointer
,	O
adv	long
)	O
,	O
state_machine_regs	struct
.	O
line	int
)	O
;	O
if	O
(	O
verbose_view	int
||	O
state_machine_regs	struct
.	O
view	int
)	O
printf	function
(	O
_	O
(	O
" (view %u)\n"	pointer
)	O
,	O
state_machine_regs	struct
.	O
view	int
)	O
;	O
else	O
putchar	function
(	O
'\n'	O
)	O
;	O
state_machine_regs	struct
.	O
view	int
++	O
;	O
}	O
else	O
switch	O
(	O
op_code	char
)	O
{	O
case	O
DW_LNS_extended_op	int
:	O
data	pointer
+=	O
process_extended_line_op	function
(	O
data	pointer
,	O
linfo	pointer
.	O
li_default_is_stmt	char
,	O
end	pointer
)	O
;	O
break	O
;	O
case	O
DW_LNS_copy	int
:	O
printf	function
(	O
_	O
(	O
"  Copy"	pointer
)	O
)	O
;	O
if	O
(	O
verbose_view	int
||	O
state_machine_regs	struct
.	O
view	int
)	O
printf	function
(	O
_	O
(	O
" (view %u)\n"	pointer
)	O
,	O
state_machine_regs	struct
.	O
view	int
)	O
;	O
else	O
putchar	function
(	O
'\n'	O
)	O
;	O
state_machine_regs	struct
.	O
view	int
++	O
;	O
break	O
;	O
case	O
DW_LNS_advance_pc	int
:	O
READ_ULEB	O
(	O
uladv	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
linfo	pointer
.	O
li_max_ops_per_insn	char
==	O
1	int
)	O
{	O
uladv	long
*=	O
linfo	pointer
.	O
li_min_insn_length	char
;	O
state_machine_regs	struct
.	O
address	long
+=	O
uladv	long
;	O
if	O
(	O
uladv	long
)	O
state_machine_regs	struct
.	O
view	int
=	O
0	int
;	O
printf	function
(	O
_	O
(	O
"  Advance PC by %s to 0x%s%s\n"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"u"	pointer
,	O
uladv	long
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
state_machine_regs	struct
.	O
address	long
)	O
,	O
verbose_view	int
&&	O
uladv	long
?	O
_	O
(	O
" (reset view)"	pointer
)	O
:	O
""	pointer
)	O
;	O
}	O
else	O
{	O
unsigned	O
addrdelta	int
=	O
(	O
(	O
state_machine_regs	struct
.	O
op_index	char
+	O
uladv	long
)	O
/	O
linfo	pointer
.	O
li_max_ops_per_insn	char
)	O
*	O
linfo	pointer
.	O
li_min_insn_length	char
;	O
state_machine_regs	struct
.	O
address	long
+=	O
addrdelta	int
;	O
state_machine_regs	struct
.	O
op_index	char
=	O
(	O
state_machine_regs	struct
.	O
op_index	char
+	O
uladv	long
)	O
%	O
linfo	pointer
.	O
li_max_ops_per_insn	char
;	O
if	O
(	O
addrdelta	int
)	O
state_machine_regs	struct
.	O
view	int
=	O
0	int
;	O
printf	function
(	O
_	O
(	O
"  Advance PC by %s to 0x%s[%d]%s\n"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"u"	pointer
,	O
uladv	long
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
state_machine_regs	struct
.	O
address	long
)	O
,	O
state_machine_regs	struct
.	O
op_index	char
,	O
verbose_view	int
&&	O
addrdelta	int
?	O
_	O
(	O
" (reset view)"	pointer
)	O
:	O
""	pointer
)	O
;	O
}	O
break	O
;	O
case	O
DW_LNS_advance_line	int
:	O
READ_SLEB	O
(	O
adv	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
state_machine_regs	struct
.	O
line	int
+=	O
adv	long
;	O
printf	function
(	O
_	O
(	O
"  Advance Line by %s to %d\n"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"d"	pointer
,	O
adv	long
)	O
,	O
state_machine_regs	struct
.	O
line	int
)	O
;	O
break	O
;	O
case	O
DW_LNS_set_file	int
:	O
READ_ULEB	O
(	O
uladv	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"  Set File Name to entry %s in the File Name Table\n"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"u"	pointer
,	O
uladv	long
)	O
)	O
;	O
state_machine_regs	struct
.	O
file	pointer
=	O
uladv	long
;	O
break	O
;	O
case	O
DW_LNS_set_column	int
:	O
READ_ULEB	O
(	O
uladv	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"  Set column to %s\n"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"u"	pointer
,	O
uladv	long
)	O
)	O
;	O
state_machine_regs	struct
.	O
column	int
=	O
uladv	long
;	O
break	O
;	O
case	O
DW_LNS_negate_stmt	int
:	O
adv	long
=	O
state_machine_regs	struct
.	O
is_stmt	int
;	O
adv	long
=	O
!	O
adv	long
;	O
printf	function
(	O
_	O
(	O
"  Set is_stmt to %s\n"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"d"	pointer
,	O
adv	long
)	O
)	O
;	O
state_machine_regs	struct
.	O
is_stmt	int
=	O
adv	long
;	O
break	O
;	O
case	O
DW_LNS_set_basic_block	int
:	O
printf	function
(	O
_	O
(	O
"  Set basic block\n"	pointer
)	O
)	O
;	O
state_machine_regs	struct
.	O
basic_block	int
=	O
1	int
;	O
break	O
;	O
case	O
DW_LNS_const_add_pc	int
:	O
uladv	long
=	O
(	O
(	O
255	int
-	O
linfo	pointer
.	O
li_opcode_base	char
)	O
/	O
linfo	pointer
.	O
li_line_range	char
)	O
;	O
if	O
(	O
linfo	pointer
.	O
li_max_ops_per_insn	char
)	O
{	O
uladv	long
*=	O
linfo	pointer
.	O
li_min_insn_length	char
;	O
state_machine_regs	struct
.	O
address	long
+=	O
uladv	long
;	O
if	O
(	O
uladv	long
)	O
state_machine_regs	struct
.	O
view	int
=	O
0	int
;	O
printf	function
(	O
_	O
(	O
"  Advance PC by constant %s to 0x%s%s\n"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"u"	pointer
,	O
uladv	long
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
state_machine_regs	struct
.	O
address	long
)	O
,	O
verbose_view	int
&&	O
uladv	long
?	O
_	O
(	O
" (reset view)"	pointer
)	O
:	O
""	pointer
)	O
;	O
}	O
else	O
{	O
unsigned	O
addrdelta	int
=	O
(	O
(	O
state_machine_regs	struct
.	O
op_index	char
+	O
uladv	long
)	O
/	O
linfo	pointer
.	O
li_max_ops_per_insn	char
)	O
*	O
linfo	pointer
.	O
li_min_insn_length	char
;	O
state_machine_regs	struct
.	O
address	long
+=	O
addrdelta	int
;	O
state_machine_regs	struct
.	O
op_index	char
=	O
(	O
state_machine_regs	struct
.	O
op_index	char
+	O
uladv	long
)	O
%	O
linfo	pointer
.	O
li_max_ops_per_insn	char
;	O
if	O
(	O
addrdelta	int
)	O
state_machine_regs	struct
.	O
view	int
=	O
0	int
;	O
printf	function
(	O
_	O
(	O
"  Advance PC by constant %s to 0x%s[%d]%s\n"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"u"	pointer
,	O
uladv	long
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
state_machine_regs	struct
.	O
address	long
)	O
,	O
state_machine_regs	struct
.	O
op_index	char
,	O
verbose_view	int
&&	O
addrdelta	int
?	O
_	O
(	O
" (reset view)"	pointer
)	O
:	O
""	pointer
)	O
;	O
}	O
break	O
;	O
case	O
DW_LNS_fixed_advance_pc	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
uladv	long
,	O
data	pointer
,	O
2	int
,	O
end	pointer
)	O
;	O
state_machine_regs	struct
.	O
address	long
+=	O
uladv	long
;	O
state_machine_regs	struct
.	O
op_index	char
=	O
0	int
;	O
printf	function
(	O
_	O
(	O
"  Advance PC by fixed size amount %s to 0x%s\n"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"u"	pointer
,	O
uladv	long
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
state_machine_regs	struct
.	O
address	long
)	O
)	O
;	O
break	O
;	O
case	O
DW_LNS_set_prologue_end	int
:	O
printf	function
(	O
_	O
(	O
"  Set prologue_end to true\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
DW_LNS_set_epilogue_begin	int
:	O
printf	function
(	O
_	O
(	O
"  Set epilogue_begin to true\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
DW_LNS_set_isa	int
:	O
READ_ULEB	O
(	O
uladv	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"  Set ISA to %s\n"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"u"	pointer
,	O
uladv	long
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
_	O
(	O
"  Unknown opcode %d with operands: "	pointer
)	O
,	O
op_code	char
)	O
;	O
if	O
(	O
standard_opcodes	pointer
!=	O
NULL	O
)	O
for	O
(	O
i	pointer
=	O
standard_opcodes	pointer
[	O
op_code	char
-	O
1	int
]	O
;	O
i	pointer
>	O
0	int
;	O
--	O
i	pointer
)	O
{	O
READ_ULEB	O
(	O
uladv	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"0x%s%s"	pointer
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
uladv	long
)	O
,	O
i	pointer
==	O
1	int
?	O
""	pointer
:	O
", "	pointer
)	O
;	O
}	O
putchar	function
(	O
'\n'	O
)	O
;	O
break	O
;	O
}	O
}	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
}	O
return	O
1	int
;	O
}	O
typedef	O
struct	O
{	O
unsigned	O
char	O
*	O
name	pointer
;	O
unsigned	O
int	O
directory_index	int
;	O
unsigned	O
int	O
modification_date	int
;	O
unsigned	O
int	O
length	long
;	O
}	O
File_Entry	struct
;	O
static	O
int	O
display_debug_lines_decoded	function
(	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
unsigned	O
char	O
*	O
start	pointer
,	O
unsigned	O
char	O
*	O
data	pointer
,	O
unsigned	O
char	O
*	O
end	pointer
,	O
void	O
*	O
fileptr	pointer
)	O
{	O
static	O
DWARF2_Internal_LineInfo	struct
saved_linfo	struct
;	O
introduce	function
(	O
section	pointer
,	O
FALSE	int
)	O
;	O
while	O
(	O
data	pointer
<	O
end	pointer
)	O
{	O
DWARF2_Internal_LineInfo	struct
linfo	pointer
;	O
unsigned	O
char	O
*	O
standard_opcodes	pointer
;	O
unsigned	O
char	O
*	O
end_of_sequence	pointer
;	O
int	O
i	pointer
;	O
File_Entry	struct
*	O
file_table	pointer
=	O
NULL	O
;	O
unsigned	O
int	O
n_files	int
=	O
0	int
;	O
unsigned	O
char	O
*	O
*	O
directory_table	pointer
=	O
NULL	O
;	O
dwarf_vma	long
n_directories	long
=	O
0	int
;	O
if	O
(	O
const_strneq	O
(	O
section	pointer
->	O
name	pointer
,	O
".debug_line."	pointer
)	O
&&	O
strcmp	function
(	O
section	pointer
->	O
name	pointer
,	O
".debug_line.dwo"	pointer
)	O
!=	O
0	int
)	O
{	O
end_of_sequence	pointer
=	O
end	pointer
;	O
standard_opcodes	pointer
=	O
NULL	O
;	O
linfo	pointer
=	O
saved_linfo	struct
;	O
if	O
(	O
linfo	pointer
.	O
li_line_range	char
==	O
0	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Partial .debug_line. section encountered without a prior full .debug_line section\n"	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
reset_state_machine	function
(	O
linfo	pointer
.	O
li_default_is_stmt	char
)	O
;	O
}	O
else	O
{	O
unsigned	O
char	O
*	O
hdrptr	pointer
;	O
if	O
(	O
(	O
hdrptr	pointer
=	O
read_debug_line_header	function
(	O
section	pointer
,	O
data	pointer
,	O
end	pointer
,	O
&	O
linfo	pointer
,	O
&	O
end_of_sequence	pointer
)	O
)	O
==	O
NULL	O
)	O
return	O
0	int
;	O
if	O
(	O
linfo	pointer
.	O
li_line_range	char
==	O
0	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Line range of 0 is invalid, using 1 instead\n"	pointer
)	O
)	O
;	O
linfo	pointer
.	O
li_line_range	char
=	O
1	int
;	O
}	O
reset_state_machine	function
(	O
linfo	pointer
.	O
li_default_is_stmt	char
)	O
;	O
standard_opcodes	pointer
=	O
hdrptr	pointer
;	O
data	pointer
=	O
standard_opcodes	pointer
+	O
linfo	pointer
.	O
li_opcode_base	char
-	O
1	int
;	O
if	O
(	O
data	pointer
>=	O
end	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"opcode base of %d extends beyond end of section\n"	pointer
)	O
,	O
linfo	pointer
.	O
li_opcode_base	char
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
linfo	pointer
.	O
li_version	short
>=	O
5	int
)	O
{	O
unsigned	O
char	O
*	O
format_start	pointer
,	O
format_count	char
,	O
*	O
format	enum
;	O
dwarf_vma	long
formati	char
,	O
entryi	long
;	O
load_debug_section_with_follow	function
(	O
line_str	int
,	O
fileptr	pointer
)	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
format_count	char
,	O
data	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
format_start	pointer
=	O
data	pointer
;	O
for	O
(	O
formati	char
=	O
0	int
;	O
formati	char
<	O
format_count	char
;	O
formati	char
++	O
)	O
{	O
SKIP_ULEB	O
(	O
data	pointer
,	O
end	pointer
)	O
;	O
SKIP_ULEB	O
(	O
data	pointer
,	O
end	pointer
)	O
;	O
}	O
READ_ULEB	O
(	O
n_directories	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
data	pointer
==	O
end	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"Corrupt directories list\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
directory_table	pointer
=	O
(	O
unsigned	O
char	O
*	O
*	O
)	O
xmalloc	function
(	O
n_directories	long
*	O
sizeof	O
(	O
unsigned	O
char	O
*	O
)	O
)	O
;	O
for	O
(	O
entryi	long
=	O
0	int
;	O
entryi	long
<	O
n_directories	long
;	O
entryi	long
++	O
)	O
{	O
unsigned	O
char	O
*	O
*	O
pathp	pointer
=	O
&	O
directory_table	pointer
[	O
entryi	long
]	O
;	O
format	enum
=	O
format_start	pointer
;	O
for	O
(	O
formati	char
=	O
0	int
;	O
formati	char
<	O
format_count	char
;	O
formati	char
++	O
)	O
{	O
dwarf_vma	long
content_type	long
,	O
form	int
;	O
dwarf_vma	long
uvalue	long
;	O
READ_ULEB	O
(	O
content_type	long
,	O
format	enum
,	O
end	pointer
)	O
;	O
READ_ULEB	O
(	O
form	int
,	O
format	enum
,	O
end	pointer
)	O
;	O
if	O
(	O
data	pointer
==	O
end	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"Corrupt directories list\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
switch	O
(	O
content_type	long
)	O
{	O
case	O
DW_LNCT_path	int
:	O
switch	O
(	O
form	int
)	O
{	O
case	O
DW_FORM_string	int
:	O
*	O
pathp	pointer
=	O
data	pointer
;	O
break	O
;	O
case	O
DW_FORM_line_strp	int
:	O
SAFE_BYTE_GET	O
(	O
uvalue	long
,	O
data	pointer
,	O
linfo	pointer
.	O
li_offset_size	int
,	O
end	pointer
)	O
;	O
*	O
pathp	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
fetch_indirect_line_string	function
(	O
uvalue	long
)	O
;	O
break	O
;	O
}	O
break	O
;	O
}	O
data	pointer
=	O
read_and_display_attr_value	function
(	O
0	int
,	O
form	int
,	O
0	int
,	O
start	pointer
,	O
data	pointer
,	O
end	pointer
,	O
0	int
,	O
0	int
,	O
linfo	pointer
.	O
li_offset_size	int
,	O
linfo	pointer
.	O
li_version	short
,	O
NULL	O
,	O
1	int
,	O
section	pointer
,	O
NULL	O
,	O
'\t'	O
,	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
data	pointer
==	O
end	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"Corrupt directories list\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
}	O
SAFE_BYTE_GET_AND_INC	O
(	O
format_count	char
,	O
data	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
format_start	pointer
=	O
data	pointer
;	O
for	O
(	O
formati	char
=	O
0	int
;	O
formati	char
<	O
format_count	char
;	O
formati	char
++	O
)	O
{	O
SKIP_ULEB	O
(	O
data	pointer
,	O
end	pointer
)	O
;	O
SKIP_ULEB	O
(	O
data	pointer
,	O
end	pointer
)	O
;	O
}	O
READ_ULEB	O
(	O
n_files	int
,	O
data	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
data	pointer
==	O
end	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"Corrupt file name list\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
file_table	pointer
=	O
(	O
File_Entry	struct
*	O
)	O
xcalloc	function
(	O
1	int
,	O
n_files	int
*	O
sizeof	O
(	O
File_Entry	struct
)	O
)	O
;	O
for	O
(	O
entryi	long
=	O
0	int
;	O
entryi	long
<	O
n_files	int
;	O
entryi	long
++	O
)	O
{	O
File_Entry	struct
*	O
file	pointer
=	O
&	O
file_table	pointer
[	O
entryi	long
]	O
;	O
format	enum
=	O
format_start	pointer
;	O
for	O
(	O
formati	char
=	O
0	int
;	O
formati	char
<	O
format_count	char
;	O
formati	char
++	O
)	O
{	O
dwarf_vma	long
content_type	long
,	O
form	int
;	O
dwarf_vma	long
uvalue	long
;	O
unsigned	O
char	O
*	O
tmp	long
;	O
READ_ULEB	O
(	O
content_type	long
,	O
format	enum
,	O
end	pointer
)	O
;	O
READ_ULEB	O
(	O
form	int
,	O
format	enum
,	O
end	pointer
)	O
;	O
if	O
(	O
data	pointer
==	O
end	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"Corrupt file name list\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
switch	O
(	O
content_type	long
)	O
{	O
case	O
DW_LNCT_path	int
:	O
switch	O
(	O
form	int
)	O
{	O
case	O
DW_FORM_string	int
:	O
file	pointer
->	O
name	pointer
=	O
data	pointer
;	O
break	O
;	O
case	O
DW_FORM_line_strp	int
:	O
SAFE_BYTE_GET	O
(	O
uvalue	long
,	O
data	pointer
,	O
linfo	pointer
.	O
li_offset_size	int
,	O
end	pointer
)	O
;	O
file	pointer
->	O
name	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
fetch_indirect_line_string	function
(	O
uvalue	long
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
DW_LNCT_directory_index	int
:	O
switch	O
(	O
form	int
)	O
{	O
case	O
DW_FORM_data1	int
:	O
SAFE_BYTE_GET	O
(	O
file	pointer
->	O
directory_index	int
,	O
data	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
break	O
;	O
case	O
DW_FORM_data2	int
:	O
SAFE_BYTE_GET	O
(	O
file	pointer
->	O
directory_index	int
,	O
data	pointer
,	O
2	int
,	O
end	pointer
)	O
;	O
break	O
;	O
case	O
DW_FORM_udata	int
:	O
tmp	long
=	O
data	pointer
;	O
READ_ULEB	O
(	O
file	pointer
->	O
directory_index	int
,	O
tmp	long
,	O
end	pointer
)	O
;	O
break	O
;	O
}	O
break	O
;	O
}	O
data	pointer
=	O
read_and_display_attr_value	function
(	O
0	int
,	O
form	int
,	O
0	int
,	O
start	pointer
,	O
data	pointer
,	O
end	pointer
,	O
0	int
,	O
0	int
,	O
linfo	pointer
.	O
li_offset_size	int
,	O
linfo	pointer
.	O
li_version	short
,	O
NULL	O
,	O
1	int
,	O
section	pointer
,	O
NULL	O
,	O
'\t'	O
,	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
data	pointer
==	O
end	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"Corrupt file name list\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
*	O
data	pointer
!=	O
0	int
)	O
{	O
unsigned	O
char	O
*	O
ptr_directory_table	pointer
=	O
data	pointer
;	O
while	O
(	O
data	pointer
<	O
end	pointer
&&	O
*	O
data	pointer
!=	O
0	int
)	O
{	O
data	pointer
+=	O
strnlen	function
(	O
(	O
char	O
*	O
)	O
data	pointer
,	O
end	pointer
-	O
data	pointer
)	O
+	O
1	int
;	O
n_directories	long
++	O
;	O
}	O
if	O
(	O
data	pointer
>=	O
end	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"directory table ends unexpectedly\n"	pointer
)	O
)	O
;	O
n_directories	long
=	O
0	int
;	O
break	O
;	O
}	O
directory_table	pointer
=	O
(	O
unsigned	O
char	O
*	O
*	O
)	O
xmalloc	function
(	O
n_directories	long
*	O
sizeof	O
(	O
unsigned	O
char	O
*	O
)	O
)	O
;	O
i	pointer
=	O
0	int
;	O
while	O
(	O
*	O
ptr_directory_table	pointer
!=	O
0	int
)	O
{	O
directory_table	pointer
[	O
i	pointer
]	O
=	O
ptr_directory_table	pointer
;	O
ptr_directory_table	pointer
+=	O
strnlen	function
(	O
(	O
char	O
*	O
)	O
ptr_directory_table	pointer
,	O
ptr_directory_table	pointer
-	O
end	pointer
)	O
+	O
1	int
;	O
i	pointer
++	O
;	O
}	O
}	O
data	pointer
++	O
;	O
if	O
(	O
data	pointer
<	O
end	pointer
&&	O
*	O
data	pointer
!=	O
0	int
)	O
{	O
unsigned	O
char	O
*	O
ptr_file_name_table	pointer
=	O
data	pointer
;	O
while	O
(	O
data	pointer
<	O
end	pointer
&&	O
*	O
data	pointer
!=	O
0	int
)	O
{	O
data	pointer
+=	O
strnlen	function
(	O
(	O
char	O
*	O
)	O
data	pointer
,	O
end	pointer
-	O
data	pointer
)	O
+	O
1	int
;	O
SKIP_ULEB	O
(	O
data	pointer
,	O
end	pointer
)	O
;	O
SKIP_ULEB	O
(	O
data	pointer
,	O
end	pointer
)	O
;	O
SKIP_ULEB	O
(	O
data	pointer
,	O
end	pointer
)	O
;	O
n_files	int
++	O
;	O
}	O
if	O
(	O
data	pointer
>=	O
end	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"file table ends unexpectedly\n"	pointer
)	O
)	O
;	O
n_files	int
=	O
0	int
;	O
break	O
;	O
}	O
file_table	pointer
=	O
(	O
File_Entry	struct
*	O
)	O
xmalloc	function
(	O
n_files	int
*	O
sizeof	O
(	O
File_Entry	struct
)	O
)	O
;	O
i	pointer
=	O
0	int
;	O
while	O
(	O
*	O
ptr_file_name_table	pointer
!=	O
0	int
)	O
{	O
file_table	pointer
[	O
i	pointer
]	O
.	O
name	pointer
=	O
ptr_file_name_table	pointer
;	O
ptr_file_name_table	pointer
+=	O
strnlen	function
(	O
(	O
char	O
*	O
)	O
ptr_file_name_table	pointer
,	O
end	pointer
-	O
ptr_file_name_table	pointer
)	O
+	O
1	int
;	O
READ_ULEB	O
(	O
file_table	pointer
[	O
i	pointer
]	O
.	O
directory_index	int
,	O
ptr_file_name_table	pointer
,	O
end	pointer
)	O
;	O
READ_ULEB	O
(	O
file_table	pointer
[	O
i	pointer
]	O
.	O
modification_date	int
,	O
ptr_file_name_table	pointer
,	O
end	pointer
)	O
;	O
READ_ULEB	O
(	O
file_table	pointer
[	O
i	pointer
]	O
.	O
length	long
,	O
ptr_file_name_table	pointer
,	O
end	pointer
)	O
;	O
i	pointer
++	O
;	O
}	O
i	pointer
=	O
0	int
;	O
}	O
data	pointer
++	O
;	O
}	O
if	O
(	O
file_table	pointer
==	O
NULL	O
)	O
;	O
else	O
if	O
(	O
directory_table	pointer
==	O
NULL	O
)	O
printf	function
(	O
_	O
(	O
"CU: %s:\n"	pointer
)	O
,	O
file_table	pointer
[	O
0	int
]	O
.	O
name	pointer
)	O
;	O
else	O
{	O
unsigned	O
int	O
ix	int
=	O
file_table	pointer
[	O
0	int
]	O
.	O
directory_index	int
;	O
const	O
char	O
*	O
directory	pointer
;	O
if	O
(	O
ix	int
==	O
0	int
)	O
directory	pointer
=	O
"."	pointer
;	O
else	O
if	O
(	O
n_directories	long
==	O
0	int
)	O
directory	pointer
=	O
_	O
(	O
"<unknown>"	pointer
)	O
;	O
else	O
if	O
(	O
ix	int
>	O
n_directories	long
)	O
{	O
warn	function
(	O
_	O
(	O
"directory index %u > number of directories %s\n"	pointer
)	O
,	O
ix	int
,	O
dwarf_vmatoa	function
(	O
"u"	pointer
,	O
n_directories	long
)	O
)	O
;	O
directory	pointer
=	O
_	O
(	O
"<corrupt>"	pointer
)	O
;	O
}	O
else	O
directory	pointer
=	O
(	O
char	O
*	O
)	O
directory_table	pointer
[	O
ix	int
-	O
1	int
]	O
;	O
if	O
(	O
do_wide	int
||	O
strlen	function
(	O
directory	pointer
)	O
<	O
76	int
)	O
printf	function
(	O
_	O
(	O
"CU: %s/%s:\n"	pointer
)	O
,	O
directory	pointer
,	O
file_table	pointer
[	O
0	int
]	O
.	O
name	pointer
)	O
;	O
else	O
printf	function
(	O
"%s:\n"	pointer
,	O
file_table	pointer
[	O
0	int
]	O
.	O
name	pointer
)	O
;	O
}	O
printf	function
(	O
_	O
(	O
"File name                            Line number    Starting address    View    Stmt\n"	pointer
)	O
)	O
;	O
saved_linfo	struct
=	O
linfo	pointer
;	O
}	O
while	O
(	O
data	pointer
<	O
end_of_sequence	pointer
)	O
{	O
unsigned	O
char	O
op_code	char
;	O
int	O
xop	int
;	O
int	O
adv	long
;	O
unsigned	O
long	O
int	O
uladv	long
;	O
int	O
is_special_opcode	int
=	O
0	int
;	O
op_code	char
=	O
*	O
data	pointer
++	O
;	O
xop	int
=	O
op_code	char
;	O
if	O
(	O
op_code	char
>=	O
linfo	pointer
.	O
li_opcode_base	char
)	O
{	O
op_code	char
-=	O
linfo	pointer
.	O
li_opcode_base	char
;	O
uladv	long
=	O
(	O
op_code	char
/	O
linfo	pointer
.	O
li_line_range	char
)	O
;	O
if	O
(	O
linfo	pointer
.	O
li_max_ops_per_insn	char
==	O
1	int
)	O
{	O
uladv	long
*=	O
linfo	pointer
.	O
li_min_insn_length	char
;	O
state_machine_regs	struct
.	O
address	long
+=	O
uladv	long
;	O
if	O
(	O
uladv	long
)	O
state_machine_regs	struct
.	O
view	int
=	O
0	int
;	O
}	O
else	O
{	O
unsigned	O
addrdelta	int
=	O
(	O
(	O
state_machine_regs	struct
.	O
op_index	char
+	O
uladv	long
)	O
/	O
linfo	pointer
.	O
li_max_ops_per_insn	char
)	O
*	O
linfo	pointer
.	O
li_min_insn_length	char
;	O
state_machine_regs	struct
.	O
address	long
+=	O
addrdelta	int
;	O
state_machine_regs	struct
.	O
op_index	char
=	O
(	O
state_machine_regs	struct
.	O
op_index	char
+	O
uladv	long
)	O
%	O
linfo	pointer
.	O
li_max_ops_per_insn	char
;	O
if	O
(	O
addrdelta	int
)	O
state_machine_regs	struct
.	O
view	int
=	O
0	int
;	O
}	O
adv	long
=	O
(	O
op_code	char
%	O
linfo	pointer
.	O
li_line_range	char
)	O
+	O
linfo	pointer
.	O
li_line_base	int
;	O
state_machine_regs	struct
.	O
line	int
+=	O
adv	long
;	O
is_special_opcode	int
=	O
1	int
;	O
}	O
else	O
switch	O
(	O
op_code	char
)	O
{	O
case	O
DW_LNS_extended_op	int
:	O
{	O
unsigned	O
int	O
ext_op_code_len	int
;	O
unsigned	O
char	O
ext_op_code	char
;	O
unsigned	O
char	O
*	O
op_code_end	pointer
;	O
unsigned	O
char	O
*	O
op_code_data	pointer
=	O
data	pointer
;	O
READ_ULEB	O
(	O
ext_op_code_len	int
,	O
op_code_data	pointer
,	O
end_of_sequence	pointer
)	O
;	O
op_code_end	pointer
=	O
op_code_data	pointer
+	O
ext_op_code_len	int
;	O
if	O
(	O
ext_op_code_len	int
==	O
0	int
||	O
op_code_end	pointer
>	O
end_of_sequence	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"Badly formed extended line op encountered!\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
ext_op_code	char
=	O
*	O
op_code_data	pointer
++	O
;	O
xop	int
=	O
ext_op_code	char
;	O
xop	int
=	O
-	O
xop	int
;	O
switch	O
(	O
ext_op_code	char
)	O
{	O
case	O
DW_LNE_end_sequence	int
:	O
break	O
;	O
case	O
DW_LNE_set_address	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
state_machine_regs	struct
.	O
address	long
,	O
op_code_data	pointer
,	O
op_code_end	pointer
-	O
op_code_data	pointer
,	O
op_code_end	pointer
)	O
;	O
state_machine_regs	struct
.	O
op_index	char
=	O
0	int
;	O
state_machine_regs	struct
.	O
view	int
=	O
0	int
;	O
break	O
;	O
case	O
DW_LNE_define_file	int
:	O
file_table	pointer
=	O
(	O
File_Entry	struct
*	O
)	O
xrealloc	function
(	O
file_table	pointer
,	O
(	O
n_files	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
File_Entry	struct
)	O
)	O
;	O
++	O
state_machine_regs	struct
.	O
last_file_entry	int
;	O
file_table	pointer
[	O
n_files	int
]	O
.	O
name	pointer
=	O
op_code_data	pointer
;	O
op_code_data	pointer
+=	O
strlen	function
(	O
(	O
char	O
*	O
)	O
op_code_data	pointer
)	O
+	O
1	int
;	O
READ_ULEB	O
(	O
file_table	pointer
[	O
n_files	int
]	O
.	O
directory_index	int
,	O
op_code_data	pointer
,	O
op_code_end	pointer
)	O
;	O
READ_ULEB	O
(	O
file_table	pointer
[	O
n_files	int
]	O
.	O
modification_date	int
,	O
op_code_data	pointer
,	O
op_code_end	pointer
)	O
;	O
READ_ULEB	O
(	O
file_table	pointer
[	O
n_files	int
]	O
.	O
length	long
,	O
op_code_data	pointer
,	O
op_code_end	pointer
)	O
;	O
n_files	int
++	O
;	O
break	O
;	O
case	O
DW_LNE_set_discriminator	int
:	O
case	O
DW_LNE_HP_set_sequence	int
:	O
break	O
;	O
default	O
:	O
printf	function
(	O
_	O
(	O
"UNKNOWN (%u): length %ld\n"	pointer
)	O
,	O
ext_op_code	char
,	O
(	O
long	O
int	O
)	O
(	O
op_code_data	pointer
-	O
data	pointer
)	O
)	O
;	O
break	O
;	O
}	O
data	pointer
=	O
op_code_end	pointer
;	O
break	O
;	O
}	O
case	O
DW_LNS_copy	int
:	O
break	O
;	O
case	O
DW_LNS_advance_pc	int
:	O
READ_ULEB	O
(	O
uladv	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
linfo	pointer
.	O
li_max_ops_per_insn	char
==	O
1	int
)	O
{	O
uladv	long
*=	O
linfo	pointer
.	O
li_min_insn_length	char
;	O
state_machine_regs	struct
.	O
address	long
+=	O
uladv	long
;	O
if	O
(	O
uladv	long
)	O
state_machine_regs	struct
.	O
view	int
=	O
0	int
;	O
}	O
else	O
{	O
unsigned	O
addrdelta	int
=	O
(	O
(	O
state_machine_regs	struct
.	O
op_index	char
+	O
uladv	long
)	O
/	O
linfo	pointer
.	O
li_max_ops_per_insn	char
)	O
*	O
linfo	pointer
.	O
li_min_insn_length	char
;	O
state_machine_regs	struct
.	O
address	long
+=	O
addrdelta	int
;	O
state_machine_regs	struct
.	O
op_index	char
=	O
(	O
state_machine_regs	struct
.	O
op_index	char
+	O
uladv	long
)	O
%	O
linfo	pointer
.	O
li_max_ops_per_insn	char
;	O
if	O
(	O
addrdelta	int
)	O
state_machine_regs	struct
.	O
view	int
=	O
0	int
;	O
}	O
break	O
;	O
case	O
DW_LNS_advance_line	int
:	O
READ_SLEB	O
(	O
adv	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
state_machine_regs	struct
.	O
line	int
+=	O
adv	long
;	O
break	O
;	O
case	O
DW_LNS_set_file	int
:	O
READ_ULEB	O
(	O
uladv	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
state_machine_regs	struct
.	O
file	pointer
=	O
uladv	long
;	O
{	O
unsigned	O
file	pointer
=	O
state_machine_regs	struct
.	O
file	pointer
-	O
1	int
;	O
unsigned	O
dir	pointer
;	O
if	O
(	O
file_table	pointer
==	O
NULL	O
||	O
n_files	int
==	O
0	int
)	O
printf	function
(	O
_	O
(	O
"\n [Use file table entry %d]\n"	pointer
)	O
,	O
file	pointer
)	O
;	O
else	O
if	O
(	O
file	pointer
>=	O
n_files	int
)	O
{	O
warn	function
(	O
_	O
(	O
"file index %u > number of files %u\n"	pointer
)	O
,	O
file	pointer
+	O
1	int
,	O
n_files	int
)	O
;	O
printf	function
(	O
_	O
(	O
"\n <over large file table index %u>"	pointer
)	O
,	O
file	pointer
)	O
;	O
}	O
else	O
if	O
(	O
(	O
dir	pointer
=	O
file_table	pointer
[	O
file	pointer
]	O
.	O
directory_index	int
)	O
==	O
0	int
)	O
printf	function
(	O
"\n./%s:[++]\n"	pointer
,	O
file_table	pointer
[	O
file	pointer
]	O
.	O
name	pointer
)	O
;	O
else	O
if	O
(	O
directory_table	pointer
==	O
NULL	O
||	O
n_directories	long
==	O
0	int
)	O
printf	function
(	O
_	O
(	O
"\n [Use file %s in directory table entry %d]\n"	pointer
)	O
,	O
file_table	pointer
[	O
file	pointer
]	O
.	O
name	pointer
,	O
dir	pointer
)	O
;	O
else	O
if	O
(	O
dir	pointer
>	O
n_directories	long
)	O
{	O
warn	function
(	O
_	O
(	O
"directory index %u > number of directories %s\n"	pointer
)	O
,	O
dir	pointer
,	O
dwarf_vmatoa	function
(	O
"u"	pointer
,	O
n_directories	long
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"\n <over large directory table entry %u>\n"	pointer
)	O
,	O
dir	pointer
)	O
;	O
}	O
else	O
printf	function
(	O
"\n%s/%s:\n"	pointer
,	O
directory_table	pointer
[	O
dir	pointer
-	O
1	int
]	O
,	O
file_table	pointer
[	O
file	pointer
]	O
.	O
name	pointer
)	O
;	O
}	O
break	O
;	O
case	O
DW_LNS_set_column	int
:	O
READ_ULEB	O
(	O
uladv	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
state_machine_regs	struct
.	O
column	int
=	O
uladv	long
;	O
break	O
;	O
case	O
DW_LNS_negate_stmt	int
:	O
adv	long
=	O
state_machine_regs	struct
.	O
is_stmt	int
;	O
adv	long
=	O
!	O
adv	long
;	O
state_machine_regs	struct
.	O
is_stmt	int
=	O
adv	long
;	O
break	O
;	O
case	O
DW_LNS_set_basic_block	int
:	O
state_machine_regs	struct
.	O
basic_block	int
=	O
1	int
;	O
break	O
;	O
case	O
DW_LNS_const_add_pc	int
:	O
uladv	long
=	O
(	O
(	O
255	int
-	O
linfo	pointer
.	O
li_opcode_base	char
)	O
/	O
linfo	pointer
.	O
li_line_range	char
)	O
;	O
if	O
(	O
linfo	pointer
.	O
li_max_ops_per_insn	char
==	O
1	int
)	O
{	O
uladv	long
*=	O
linfo	pointer
.	O
li_min_insn_length	char
;	O
state_machine_regs	struct
.	O
address	long
+=	O
uladv	long
;	O
if	O
(	O
uladv	long
)	O
state_machine_regs	struct
.	O
view	int
=	O
0	int
;	O
}	O
else	O
{	O
unsigned	O
addrdelta	int
=	O
(	O
(	O
state_machine_regs	struct
.	O
op_index	char
+	O
uladv	long
)	O
/	O
linfo	pointer
.	O
li_max_ops_per_insn	char
)	O
*	O
linfo	pointer
.	O
li_min_insn_length	char
;	O
state_machine_regs	struct
.	O
address	long
+=	O
addrdelta	int
;	O
state_machine_regs	struct
.	O
op_index	char
=	O
(	O
state_machine_regs	struct
.	O
op_index	char
+	O
uladv	long
)	O
%	O
linfo	pointer
.	O
li_max_ops_per_insn	char
;	O
if	O
(	O
addrdelta	int
)	O
state_machine_regs	struct
.	O
view	int
=	O
0	int
;	O
}	O
break	O
;	O
case	O
DW_LNS_fixed_advance_pc	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
uladv	long
,	O
data	pointer
,	O
2	int
,	O
end	pointer
)	O
;	O
state_machine_regs	struct
.	O
address	long
+=	O
uladv	long
;	O
state_machine_regs	struct
.	O
op_index	char
=	O
0	int
;	O
break	O
;	O
case	O
DW_LNS_set_prologue_end	int
:	O
break	O
;	O
case	O
DW_LNS_set_epilogue_begin	int
:	O
break	O
;	O
case	O
DW_LNS_set_isa	int
:	O
READ_ULEB	O
(	O
uladv	long
,	O
data	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"  Set ISA to %lu\n"	pointer
)	O
,	O
uladv	long
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
_	O
(	O
"  Unknown opcode %d with operands: "	pointer
)	O
,	O
op_code	char
)	O
;	O
if	O
(	O
standard_opcodes	pointer
!=	O
NULL	O
)	O
for	O
(	O
i	pointer
=	O
standard_opcodes	pointer
[	O
op_code	char
-	O
1	int
]	O
;	O
i	pointer
>	O
0	int
;	O
--	O
i	pointer
)	O
{	O
dwarf_vma	long
val	array
;	O
READ_ULEB	O
(	O
val	array
,	O
data	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"0x%s%s"	pointer
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
val	array
)	O
,	O
i	pointer
==	O
1	int
?	O
""	pointer
:	O
", "	pointer
)	O
;	O
}	O
putchar	function
(	O
'\n'	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
(	O
is_special_opcode	int
)	O
||	O
(	O
xop	int
==	O
-	O
DW_LNE_end_sequence	int
)	O
||	O
(	O
xop	int
==	O
DW_LNS_copy	int
)	O
)	O
{	O
const	O
unsigned	O
int	O
MAX_FILENAME_LENGTH	int
=	O
35	int
;	O
char	O
*	O
fileName	pointer
;	O
char	O
*	O
newFileName	pointer
=	O
NULL	O
;	O
size_t	long
fileNameLength	long
;	O
if	O
(	O
file_table	pointer
)	O
{	O
unsigned	O
indx	int
=	O
state_machine_regs	struct
.	O
file	pointer
-	O
1	int
;	O
if	O
(	O
indx	int
>=	O
n_files	int
)	O
{	O
warn	function
(	O
_	O
(	O
"corrupt file index %u encountered\n"	pointer
)	O
,	O
indx	int
)	O
;	O
fileName	pointer
=	O
_	O
(	O
"<corrupt>"	pointer
)	O
;	O
}	O
else	O
fileName	pointer
=	O
(	O
char	O
*	O
)	O
file_table	pointer
[	O
indx	int
]	O
.	O
name	pointer
;	O
}	O
else	O
fileName	pointer
=	O
_	O
(	O
"<unknown>"	pointer
)	O
;	O
fileNameLength	long
=	O
strlen	function
(	O
fileName	pointer
)	O
;	O
if	O
(	O
(	O
fileNameLength	long
>	O
MAX_FILENAME_LENGTH	int
)	O
&&	O
(	O
!	O
do_wide	int
)	O
)	O
{	O
newFileName	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
MAX_FILENAME_LENGTH	int
+	O
1	int
)	O
;	O
strncpy	function
(	O
newFileName	pointer
,	O
fileName	pointer
+	O
fileNameLength	long
-	O
MAX_FILENAME_LENGTH	int
,	O
MAX_FILENAME_LENGTH	int
+	O
1	int
)	O
;	O
}	O
else	O
{	O
newFileName	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
fileNameLength	long
+	O
1	int
)	O
;	O
strncpy	function
(	O
newFileName	pointer
,	O
fileName	pointer
,	O
fileNameLength	long
+	O
1	int
)	O
;	O
}	O
if	O
(	O
!	O
do_wide	int
||	O
(	O
fileNameLength	long
<=	O
MAX_FILENAME_LENGTH	int
)	O
)	O
{	O
if	O
(	O
linfo	pointer
.	O
li_max_ops_per_insn	char
==	O
1	int
)	O
printf	function
(	O
"%-35s  %11d  %#18"	pointer
DWARF_VMA_FMT	pointer
"x"	pointer
,	O
newFileName	pointer
,	O
state_machine_regs	struct
.	O
line	int
,	O
state_machine_regs	struct
.	O
address	long
)	O
;	O
else	O
printf	function
(	O
"%-35s  %11d  %#18"	pointer
DWARF_VMA_FMT	pointer
"x[%d]"	pointer
,	O
newFileName	pointer
,	O
state_machine_regs	struct
.	O
line	int
,	O
state_machine_regs	struct
.	O
address	long
,	O
state_machine_regs	struct
.	O
op_index	char
)	O
;	O
}	O
else	O
{	O
if	O
(	O
linfo	pointer
.	O
li_max_ops_per_insn	char
==	O
1	int
)	O
printf	function
(	O
"%s  %11d  %#18"	pointer
DWARF_VMA_FMT	pointer
"x"	pointer
,	O
newFileName	pointer
,	O
state_machine_regs	struct
.	O
line	int
,	O
state_machine_regs	struct
.	O
address	long
)	O
;	O
else	O
printf	function
(	O
"%s  %11d  %#18"	pointer
DWARF_VMA_FMT	pointer
"x[%d]"	pointer
,	O
newFileName	pointer
,	O
state_machine_regs	struct
.	O
line	int
,	O
state_machine_regs	struct
.	O
address	long
,	O
state_machine_regs	struct
.	O
op_index	char
)	O
;	O
}	O
if	O
(	O
state_machine_regs	struct
.	O
view	int
)	O
printf	function
(	O
"  %6u"	pointer
,	O
state_machine_regs	struct
.	O
view	int
)	O
;	O
else	O
printf	function
(	O
"        "	pointer
)	O
;	O
if	O
(	O
state_machine_regs	struct
.	O
is_stmt	int
)	O
printf	function
(	O
"       x"	pointer
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
state_machine_regs	struct
.	O
view	int
++	O
;	O
if	O
(	O
xop	int
==	O
-	O
DW_LNE_end_sequence	int
)	O
{	O
reset_state_machine	function
(	O
linfo	pointer
.	O
li_default_is_stmt	char
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
free	function
(	O
newFileName	pointer
)	O
;	O
}	O
}	O
if	O
(	O
file_table	pointer
)	O
{	O
free	function
(	O
file_table	pointer
)	O
;	O
file_table	pointer
=	O
NULL	O
;	O
n_files	int
=	O
0	int
;	O
}	O
if	O
(	O
directory_table	pointer
)	O
{	O
free	function
(	O
directory_table	pointer
)	O
;	O
directory_table	pointer
=	O
NULL	O
;	O
n_directories	long
=	O
0	int
;	O
}	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
display_debug_lines	function
(	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
void	O
*	O
file	pointer
)	O
{	O
unsigned	O
char	O
*	O
data	pointer
=	O
section	pointer
->	O
start	pointer
;	O
unsigned	O
char	O
*	O
end	pointer
=	O
data	pointer
+	O
section	pointer
->	O
size	int
;	O
int	O
retValRaw	int
=	O
1	int
;	O
int	O
retValDecoded	int
=	O
1	int
;	O
if	O
(	O
do_debug_lines	int
==	O
0	int
)	O
do_debug_lines	int
|=	O
FLAG_DEBUG_LINES_RAW	int
;	O
if	O
(	O
do_debug_lines	int
&	O
FLAG_DEBUG_LINES_RAW	int
)	O
retValRaw	int
=	O
display_debug_lines_raw	function
(	O
section	pointer
,	O
data	pointer
,	O
end	pointer
,	O
file	pointer
)	O
;	O
if	O
(	O
do_debug_lines	int
&	O
FLAG_DEBUG_LINES_DECODED	int
)	O
retValDecoded	int
=	O
display_debug_lines_decoded	function
(	O
section	pointer
,	O
data	pointer
,	O
data	pointer
,	O
end	pointer
,	O
file	pointer
)	O
;	O
if	O
(	O
!	O
retValRaw	int
||	O
!	O
retValDecoded	int
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
debug_info	struct
*	O
find_debug_info_for_offset	function
(	O
unsigned	O
long	O
offset	long
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
if	O
(	O
num_debug_info_entries	int
==	O
DEBUG_INFO_UNAVAILABLE	O
)	O
return	O
NULL	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
num_debug_info_entries	int
;	O
i	pointer
++	O
)	O
if	O
(	O
debug_information	pointer
[	O
i	pointer
]	O
.	O
cu_offset	long
==	O
offset	long
)	O
return	O
debug_information	pointer
+	O
i	pointer
;	O
return	O
NULL	O
;	O
}	O
static	O
const	O
char	O
*	O
get_gdb_index_symbol_kind_name	function
(	O
gdb_index_symbol_kind	enum
kind	enum
)	O
{	O
static	O
const	O
char	O
*	O
const	O
kinds	array
[	O
]	O
=	O
{	O
N_	O
(	O
"no info"	pointer
)	O
,	O
N_	O
(	O
"type"	pointer
)	O
,	O
N_	O
(	O
"variable"	pointer
)	O
,	O
N_	O
(	O
"function"	pointer
)	O
,	O
N_	O
(	O
"other"	pointer
)	O
,	O
N_	O
(	O
"unused5"	pointer
)	O
,	O
N_	O
(	O
"unused6"	pointer
)	O
,	O
N_	O
(	O
"unused7"	pointer
)	O
}	O
;	O
return	O
_	O
(	O
kinds	array
[	O
kind	enum
]	O
)	O
;	O
}	O
static	O
int	O
display_debug_pubnames_worker	function
(	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
void	O
*	O
file	pointer
ATTRIBUTE_UNUSED	O
,	O
int	O
is_gnu	int
)	O
{	O
DWARF2_Internal_PubNames	struct
names	struct
;	O
unsigned	O
char	O
*	O
start	pointer
=	O
section	pointer
->	O
start	pointer
;	O
unsigned	O
char	O
*	O
end	pointer
=	O
start	pointer
+	O
section	pointer
->	O
size	int
;	O
load_debug_info	function
(	O
file	pointer
)	O
;	O
introduce	function
(	O
section	pointer
,	O
FALSE	int
)	O
;	O
while	O
(	O
start	pointer
<	O
end	pointer
)	O
{	O
unsigned	O
char	O
*	O
data	pointer
;	O
unsigned	O
long	O
sec_off	long
;	O
unsigned	O
int	O
offset_size	int
,	O
initial_length_size	int
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
names	struct
.	O
pn_length	long
,	O
start	pointer
,	O
4	int
,	O
end	pointer
)	O
;	O
if	O
(	O
names	struct
.	O
pn_length	long
==	O
0xffffffff	int
)	O
{	O
SAFE_BYTE_GET_AND_INC	O
(	O
names	struct
.	O
pn_length	long
,	O
start	pointer
,	O
8	int
,	O
end	pointer
)	O
;	O
offset_size	int
=	O
8	int
;	O
initial_length_size	int
=	O
12	int
;	O
}	O
else	O
{	O
offset_size	int
=	O
4	int
;	O
initial_length_size	int
=	O
4	int
;	O
}	O
sec_off	long
=	O
start	pointer
-	O
section	pointer
->	O
start	pointer
;	O
if	O
(	O
sec_off	long
+	O
names	struct
.	O
pn_length	long
<	O
sec_off	long
||	O
sec_off	long
+	O
names	struct
.	O
pn_length	long
>	O
section	pointer
->	O
size	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Debug info is corrupted, %s header at %#lx has length %s\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
,	O
sec_off	long
-	O
initial_length_size	int
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
names	struct
.	O
pn_length	long
)	O
)	O
;	O
break	O
;	O
}	O
data	pointer
=	O
start	pointer
;	O
start	pointer
+=	O
names	struct
.	O
pn_length	long
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
names	struct
.	O
pn_version	short
,	O
data	pointer
,	O
2	int
,	O
end	pointer
)	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
names	struct
.	O
pn_offset	long
,	O
data	pointer
,	O
offset_size	int
,	O
end	pointer
)	O
;	O
if	O
(	O
num_debug_info_entries	int
!=	O
DEBUG_INFO_UNAVAILABLE	O
&&	O
num_debug_info_entries	int
>	O
0	int
&&	O
find_debug_info_for_offset	function
(	O
names	struct
.	O
pn_offset	long
)	O
==	O
NULL	O
)	O
warn	function
(	O
_	O
(	O
".debug_info offset of 0x%lx in %s section does not point to a CU header.\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
names	struct
.	O
pn_offset	long
,	O
section	pointer
->	O
name	pointer
)	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
names	struct
.	O
pn_size	long
,	O
data	pointer
,	O
offset_size	int
,	O
end	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"  Length:                              %ld\n"	pointer
)	O
,	O
(	O
long	O
)	O
names	struct
.	O
pn_length	long
)	O
;	O
printf	function
(	O
_	O
(	O
"  Version:                             %d\n"	pointer
)	O
,	O
names	struct
.	O
pn_version	short
)	O
;	O
printf	function
(	O
_	O
(	O
"  Offset into .debug_info section:     0x%lx\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
names	struct
.	O
pn_offset	long
)	O
;	O
printf	function
(	O
_	O
(	O
"  Size of area in .debug_info section: %ld\n"	pointer
)	O
,	O
(	O
long	O
)	O
names	struct
.	O
pn_size	long
)	O
;	O
if	O
(	O
names	struct
.	O
pn_version	short
!=	O
2	int
&&	O
names	struct
.	O
pn_version	short
!=	O
3	int
)	O
{	O
static	O
int	O
warned	int
=	O
0	int
;	O
if	O
(	O
!	O
warned	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Only DWARF 2 and 3 pubnames are currently supported\n"	pointer
)	O
)	O
;	O
warned	int
=	O
1	int
;	O
}	O
continue	O
;	O
}	O
if	O
(	O
is_gnu	int
)	O
printf	function
(	O
_	O
(	O
"\n    Offset  Kind          Name\n"	pointer
)	O
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"\n    Offset\tName\n"	pointer
)	O
)	O
;	O
while	O
(	O
1	int
)	O
{	O
bfd_size_type	long
maxprint	long
;	O
dwarf_vma	long
offset	long
;	O
SAFE_BYTE_GET	O
(	O
offset	long
,	O
data	pointer
,	O
offset_size	int
,	O
end	pointer
)	O
;	O
if	O
(	O
offset	long
==	O
0	int
)	O
break	O
;	O
data	pointer
+=	O
offset_size	int
;	O
if	O
(	O
data	pointer
>=	O
end	pointer
)	O
break	O
;	O
maxprint	long
=	O
(	O
end	pointer
-	O
data	pointer
)	O
-	O
1	int
;	O
if	O
(	O
is_gnu	int
)	O
{	O
unsigned	O
int	O
kind_data	int
;	O
gdb_index_symbol_kind	enum
kind	enum
;	O
const	O
char	O
*	O
kind_name	pointer
;	O
int	O
is_static	int
;	O
SAFE_BYTE_GET	O
(	O
kind_data	int
,	O
data	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
data	pointer
++	O
;	O
maxprint	long
--	O
;	O
kind_data	int
<<=	O
GDB_INDEX_CU_BITSIZE	int
;	O
kind	enum
=	O
GDB_INDEX_SYMBOL_KIND_VALUE	O
(	O
kind_data	int
)	O
;	O
kind_name	pointer
=	O
get_gdb_index_symbol_kind_name	function
(	O
kind	enum
)	O
;	O
is_static	int
=	O
GDB_INDEX_SYMBOL_STATIC_VALUE	O
(	O
kind_data	int
)	O
;	O
printf	function
(	O
"    %-6lx  %s,%-10s  %.*s\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
offset	long
,	O
is_static	int
?	O
_	O
(	O
"s"	pointer
)	O
:	O
_	O
(	O
"g"	pointer
)	O
,	O
kind_name	pointer
,	O
(	O
int	O
)	O
maxprint	long
,	O
data	pointer
)	O
;	O
}	O
else	O
printf	function
(	O
"    %-6lx\t%.*s\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
offset	long
,	O
(	O
int	O
)	O
maxprint	long
,	O
data	pointer
)	O
;	O
data	pointer
+=	O
strnlen	function
(	O
(	O
char	O
*	O
)	O
data	pointer
,	O
maxprint	long
)	O
+	O
1	int
;	O
if	O
(	O
data	pointer
>=	O
end	pointer
)	O
break	O
;	O
}	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
display_debug_pubnames	function
(	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
void	O
*	O
file	pointer
)	O
{	O
return	O
display_debug_pubnames_worker	function
(	O
section	pointer
,	O
file	pointer
,	O
0	int
)	O
;	O
}	O
static	O
int	O
display_debug_gnu_pubnames	function
(	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
void	O
*	O
file	pointer
)	O
{	O
return	O
display_debug_pubnames_worker	function
(	O
section	pointer
,	O
file	pointer
,	O
1	int
)	O
;	O
}	O
static	O
int	O
display_debug_macinfo	function
(	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
void	O
*	O
file	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
unsigned	O
char	O
*	O
start	pointer
=	O
section	pointer
->	O
start	pointer
;	O
unsigned	O
char	O
*	O
end	pointer
=	O
start	pointer
+	O
section	pointer
->	O
size	int
;	O
unsigned	O
char	O
*	O
curr	pointer
=	O
start	pointer
;	O
enum	O
dwarf_macinfo_record_type	enum
op	int
;	O
introduce	function
(	O
section	pointer
,	O
FALSE	int
)	O
;	O
while	O
(	O
curr	pointer
<	O
end	pointer
)	O
{	O
unsigned	O
int	O
lineno	pointer
;	O
const	O
unsigned	O
char	O
*	O
string	pointer
;	O
op	int
=	O
(	O
enum	O
dwarf_macinfo_record_type	enum
)	O
*	O
curr	pointer
;	O
curr	pointer
++	O
;	O
switch	O
(	O
op	int
)	O
{	O
case	O
DW_MACINFO_start_file	int
:	O
{	O
unsigned	O
int	O
filenum	int
;	O
READ_ULEB	O
(	O
lineno	pointer
,	O
curr	pointer
,	O
end	pointer
)	O
;	O
READ_ULEB	O
(	O
filenum	int
,	O
curr	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
" DW_MACINFO_start_file - lineno: %d filenum: %d\n"	pointer
)	O
,	O
lineno	pointer
,	O
filenum	int
)	O
;	O
}	O
break	O
;	O
case	O
DW_MACINFO_end_file	int
:	O
printf	function
(	O
_	O
(	O
" DW_MACINFO_end_file\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
DW_MACINFO_define	int
:	O
READ_ULEB	O
(	O
lineno	pointer
,	O
curr	pointer
,	O
end	pointer
)	O
;	O
string	pointer
=	O
curr	pointer
;	O
curr	pointer
+=	O
strnlen	function
(	O
(	O
char	O
*	O
)	O
string	pointer
,	O
end	pointer
-	O
string	pointer
)	O
+	O
1	int
;	O
printf	function
(	O
_	O
(	O
" DW_MACINFO_define - lineno : %d macro : %s\n"	pointer
)	O
,	O
lineno	pointer
,	O
string	pointer
)	O
;	O
break	O
;	O
case	O
DW_MACINFO_undef	int
:	O
READ_ULEB	O
(	O
lineno	pointer
,	O
curr	pointer
,	O
end	pointer
)	O
;	O
string	pointer
=	O
curr	pointer
;	O
curr	pointer
+=	O
strnlen	function
(	O
(	O
char	O
*	O
)	O
string	pointer
,	O
end	pointer
-	O
string	pointer
)	O
+	O
1	int
;	O
printf	function
(	O
_	O
(	O
" DW_MACINFO_undef - lineno : %d macro : %s\n"	pointer
)	O
,	O
lineno	pointer
,	O
string	pointer
)	O
;	O
break	O
;	O
case	O
DW_MACINFO_vendor_ext	int
:	O
{	O
unsigned	O
int	O
constant	int
;	O
READ_ULEB	O
(	O
constant	int
,	O
curr	pointer
,	O
end	pointer
)	O
;	O
string	pointer
=	O
curr	pointer
;	O
curr	pointer
+=	O
strnlen	function
(	O
(	O
char	O
*	O
)	O
string	pointer
,	O
end	pointer
-	O
string	pointer
)	O
+	O
1	int
;	O
printf	function
(	O
_	O
(	O
" DW_MACINFO_vendor_ext - constant : %d string : %s\n"	pointer
)	O
,	O
constant	int
,	O
string	pointer
)	O
;	O
}	O
break	O
;	O
}	O
}	O
return	O
1	int
;	O
}	O
static	O
unsigned	O
char	O
*	O
get_line_filename_and_dirname	function
(	O
dwarf_vma	long
line_offset	long
,	O
dwarf_vma	long
fileidx	long
,	O
unsigned	O
char	O
*	O
*	O
dir_name	pointer
)	O
{	O
struct	O
dwarf_section	struct
*	O
section	pointer
=	O
&	O
debug_displays	array
[	O
line	int
]	O
.	O
section	pointer
;	O
unsigned	O
char	O
*	O
hdrptr	pointer
,	O
*	O
dirtable	pointer
,	O
*	O
file_name	pointer
;	O
unsigned	O
int	O
offset_size	int
,	O
initial_length_size	int
;	O
unsigned	O
int	O
version	int
,	O
opcode_base	int
;	O
dwarf_vma	long
length	long
,	O
diridx	long
;	O
const	O
unsigned	O
char	O
*	O
end	pointer
;	O
*	O
dir_name	pointer
=	O
NULL	O
;	O
if	O
(	O
section	pointer
->	O
start	pointer
==	O
NULL	O
||	O
line_offset	long
>=	O
section	pointer
->	O
size	int
||	O
fileidx	long
==	O
0	int
)	O
return	O
NULL	O
;	O
hdrptr	pointer
=	O
section	pointer
->	O
start	pointer
+	O
line_offset	long
;	O
end	pointer
=	O
section	pointer
->	O
start	pointer
+	O
section	pointer
->	O
size	int
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
length	long
,	O
hdrptr	pointer
,	O
4	int
,	O
end	pointer
)	O
;	O
if	O
(	O
length	long
==	O
0xffffffff	int
)	O
{	O
SAFE_BYTE_GET_AND_INC	O
(	O
length	long
,	O
hdrptr	pointer
,	O
8	int
,	O
end	pointer
)	O
;	O
offset_size	int
=	O
8	int
;	O
initial_length_size	int
=	O
12	int
;	O
}	O
else	O
{	O
offset_size	int
=	O
4	int
;	O
initial_length_size	int
=	O
4	int
;	O
}	O
if	O
(	O
length	long
+	O
initial_length_size	int
<	O
length	long
||	O
length	long
+	O
initial_length_size	int
>	O
section	pointer
->	O
size	int
)	O
return	O
NULL	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
version	int
,	O
hdrptr	pointer
,	O
2	int
,	O
end	pointer
)	O
;	O
if	O
(	O
version	int
!=	O
2	int
&&	O
version	int
!=	O
3	int
&&	O
version	int
!=	O
4	int
)	O
return	O
NULL	O
;	O
hdrptr	pointer
+=	O
offset_size	int
+	O
1	int
;	O
if	O
(	O
version	int
>=	O
4	int
)	O
hdrptr	pointer
++	O
;	O
hdrptr	pointer
+=	O
3	int
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
opcode_base	int
,	O
hdrptr	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
if	O
(	O
opcode_base	int
==	O
0	int
)	O
return	O
NULL	O
;	O
hdrptr	pointer
+=	O
opcode_base	int
-	O
1	int
;	O
if	O
(	O
hdrptr	pointer
>=	O
end	pointer
)	O
return	O
NULL	O
;	O
dirtable	pointer
=	O
hdrptr	pointer
;	O
while	O
(	O
*	O
hdrptr	pointer
!=	O
'\0'	O
)	O
{	O
hdrptr	pointer
+=	O
strnlen	function
(	O
(	O
char	O
*	O
)	O
hdrptr	pointer
,	O
end	pointer
-	O
hdrptr	pointer
)	O
+	O
1	int
;	O
if	O
(	O
hdrptr	pointer
>=	O
end	pointer
)	O
return	O
NULL	O
;	O
}	O
hdrptr	pointer
++	O
;	O
for	O
(	O
;	O
hdrptr	pointer
<	O
end	pointer
&&	O
*	O
hdrptr	pointer
!=	O
'\0'	O
&&	O
fileidx	long
>	O
1	int
;	O
fileidx	long
--	O
)	O
{	O
hdrptr	pointer
+=	O
strnlen	function
(	O
(	O
char	O
*	O
)	O
hdrptr	pointer
,	O
end	pointer
-	O
hdrptr	pointer
)	O
+	O
1	int
;	O
SKIP_ULEB	O
(	O
hdrptr	pointer
,	O
end	pointer
)	O
;	O
SKIP_ULEB	O
(	O
hdrptr	pointer
,	O
end	pointer
)	O
;	O
SKIP_ULEB	O
(	O
hdrptr	pointer
,	O
end	pointer
)	O
;	O
}	O
if	O
(	O
hdrptr	pointer
>=	O
end	pointer
||	O
*	O
hdrptr	pointer
==	O
'\0'	O
)	O
return	O
NULL	O
;	O
file_name	pointer
=	O
hdrptr	pointer
;	O
hdrptr	pointer
+=	O
strnlen	function
(	O
(	O
char	O
*	O
)	O
hdrptr	pointer
,	O
end	pointer
-	O
hdrptr	pointer
)	O
+	O
1	int
;	O
if	O
(	O
hdrptr	pointer
>=	O
end	pointer
)	O
return	O
NULL	O
;	O
READ_ULEB	O
(	O
diridx	long
,	O
hdrptr	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
diridx	long
==	O
0	int
)	O
return	O
file_name	pointer
;	O
for	O
(	O
;	O
dirtable	pointer
<	O
end	pointer
&&	O
*	O
dirtable	pointer
!=	O
'\0'	O
&&	O
diridx	long
>	O
1	int
;	O
diridx	long
--	O
)	O
dirtable	pointer
+=	O
strnlen	function
(	O
(	O
char	O
*	O
)	O
dirtable	pointer
,	O
end	pointer
-	O
dirtable	pointer
)	O
+	O
1	int
;	O
if	O
(	O
dirtable	pointer
>=	O
end	pointer
||	O
*	O
dirtable	pointer
==	O
'\0'	O
)	O
return	O
NULL	O
;	O
*	O
dir_name	pointer
=	O
dirtable	pointer
;	O
return	O
file_name	pointer
;	O
}	O
static	O
int	O
display_debug_macro	function
(	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
void	O
*	O
file	pointer
)	O
{	O
unsigned	O
char	O
*	O
start	pointer
=	O
section	pointer
->	O
start	pointer
;	O
unsigned	O
char	O
*	O
end	pointer
=	O
start	pointer
+	O
section	pointer
->	O
size	int
;	O
unsigned	O
char	O
*	O
curr	pointer
=	O
start	pointer
;	O
unsigned	O
char	O
*	O
extended_op_buf	array
[	O
256	int
]	O
;	O
load_debug_section_with_follow	function
(	O
str	int
,	O
file	pointer
)	O
;	O
load_debug_section_with_follow	function
(	O
line	int
,	O
file	pointer
)	O
;	O
introduce	function
(	O
section	pointer
,	O
FALSE	int
)	O
;	O
while	O
(	O
curr	pointer
<	O
end	pointer
)	O
{	O
unsigned	O
int	O
lineno	pointer
,	O
version	int
,	O
flags	int
;	O
unsigned	O
int	O
offset_size	int
=	O
4	int
;	O
const	O
unsigned	O
char	O
*	O
string	pointer
;	O
dwarf_vma	long
line_offset	long
=	O
0	int
,	O
sec_offset	long
=	O
curr	pointer
-	O
start	pointer
,	O
offset	long
;	O
unsigned	O
char	O
*	O
*	O
extended_ops	pointer
=	O
NULL	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
version	int
,	O
curr	pointer
,	O
2	int
,	O
end	pointer
)	O
;	O
if	O
(	O
version	int
!=	O
4	int
&&	O
version	int
!=	O
5	int
)	O
{	O
error	function
(	O
_	O
(	O
"Only GNU extension to DWARF 4 or 5 of %s is currently supported.\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
SAFE_BYTE_GET_AND_INC	O
(	O
flags	int
,	O
curr	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
if	O
(	O
flags	int
&	O
1	int
)	O
offset_size	int
=	O
8	int
;	O
printf	function
(	O
_	O
(	O
"  Offset:                      0x%lx\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
sec_offset	long
)	O
;	O
printf	function
(	O
_	O
(	O
"  Version:                     %d\n"	pointer
)	O
,	O
version	int
)	O
;	O
printf	function
(	O
_	O
(	O
"  Offset size:                 %d\n"	pointer
)	O
,	O
offset_size	int
)	O
;	O
if	O
(	O
flags	int
&	O
2	int
)	O
{	O
SAFE_BYTE_GET_AND_INC	O
(	O
line_offset	long
,	O
curr	pointer
,	O
offset_size	int
,	O
end	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"  Offset into .debug_line:     0x%lx\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
line_offset	long
)	O
;	O
}	O
if	O
(	O
flags	int
&	O
4	int
)	O
{	O
unsigned	O
int	O
i	pointer
,	O
count	int
,	O
op	int
;	O
dwarf_vma	long
nargs	long
,	O
n	long
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
count	int
,	O
curr	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
memset	function
(	O
extended_op_buf	array
,	O
0	int
,	O
sizeof	O
(	O
extended_op_buf	array
)	O
)	O
;	O
extended_ops	pointer
=	O
extended_op_buf	array
;	O
if	O
(	O
count	int
)	O
{	O
printf	function
(	O
_	O
(	O
"  Extension opcode arguments:\n"	pointer
)	O
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
count	int
;	O
i	pointer
++	O
)	O
{	O
SAFE_BYTE_GET_AND_INC	O
(	O
op	int
,	O
curr	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
extended_ops	pointer
[	O
op	int
]	O
=	O
curr	pointer
;	O
READ_ULEB	O
(	O
nargs	long
,	O
curr	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
nargs	long
==	O
0	int
)	O
printf	function
(	O
_	O
(	O
"    DW_MACRO_%02x has no arguments\n"	pointer
)	O
,	O
op	int
)	O
;	O
else	O
{	O
printf	function
(	O
_	O
(	O
"    DW_MACRO_%02x arguments: "	pointer
)	O
,	O
op	int
)	O
;	O
for	O
(	O
n	long
=	O
0	int
;	O
n	long
<	O
nargs	long
;	O
n	long
++	O
)	O
{	O
unsigned	O
int	O
form	int
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
form	int
,	O
curr	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
printf	function
(	O
"%s%s"	pointer
,	O
get_FORM_name	function
(	O
form	int
)	O
,	O
n	long
==	O
nargs	long
-	O
1	int
?	O
"\n"	pointer
:	O
", "	pointer
)	O
;	O
switch	O
(	O
form	int
)	O
{	O
case	O
DW_FORM_data1	int
:	O
case	O
DW_FORM_data2	int
:	O
case	O
DW_FORM_data4	int
:	O
case	O
DW_FORM_data8	int
:	O
case	O
DW_FORM_sdata	int
:	O
case	O
DW_FORM_udata	int
:	O
case	O
DW_FORM_block	int
:	O
case	O
DW_FORM_block1	int
:	O
case	O
DW_FORM_block2	int
:	O
case	O
DW_FORM_block4	int
:	O
case	O
DW_FORM_flag	int
:	O
case	O
DW_FORM_string	int
:	O
case	O
DW_FORM_strp	int
:	O
case	O
DW_FORM_sec_offset	int
:	O
break	O
;	O
default	O
:	O
error	function
(	O
_	O
(	O
"Invalid extension opcode form %s\n"	pointer
)	O
,	O
get_FORM_name	function
(	O
form	int
)	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
}	O
}	O
}	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
while	O
(	O
1	int
)	O
{	O
unsigned	O
int	O
op	int
;	O
if	O
(	O
curr	pointer
>=	O
end	pointer
)	O
{	O
error	function
(	O
_	O
(	O
".debug_macro section not zero terminated\n"	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
SAFE_BYTE_GET_AND_INC	O
(	O
op	int
,	O
curr	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
if	O
(	O
op	int
==	O
0	int
)	O
break	O
;	O
switch	O
(	O
op	int
)	O
{	O
case	O
DW_MACRO_start_file	int
:	O
{	O
unsigned	O
int	O
filenum	int
;	O
unsigned	O
char	O
*	O
file_name	pointer
=	O
NULL	O
,	O
*	O
dir_name	pointer
=	O
NULL	O
;	O
READ_ULEB	O
(	O
lineno	pointer
,	O
curr	pointer
,	O
end	pointer
)	O
;	O
READ_ULEB	O
(	O
filenum	int
,	O
curr	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
(	O
flags	int
&	O
2	int
)	O
==	O
0	int
)	O
error	function
(	O
_	O
(	O
"DW_MACRO_start_file used, but no .debug_line offset provided.\n"	pointer
)	O
)	O
;	O
else	O
file_name	pointer
=	O
get_line_filename_and_dirname	function
(	O
line_offset	long
,	O
filenum	int
,	O
&	O
dir_name	pointer
)	O
;	O
if	O
(	O
file_name	pointer
==	O
NULL	O
)	O
printf	function
(	O
_	O
(	O
" DW_MACRO_start_file - lineno: %d filenum: %d\n"	pointer
)	O
,	O
lineno	pointer
,	O
filenum	int
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
" DW_MACRO_start_file - lineno: %d filenum: %d filename: %s%s%s\n"	pointer
)	O
,	O
lineno	pointer
,	O
filenum	int
,	O
dir_name	pointer
!=	O
NULL	O
?	O
(	O
const	O
char	O
*	O
)	O
dir_name	pointer
:	O
""	pointer
,	O
dir_name	pointer
!=	O
NULL	O
?	O
"/"	pointer
:	O
""	pointer
,	O
file_name	pointer
)	O
;	O
}	O
break	O
;	O
case	O
DW_MACRO_end_file	int
:	O
printf	function
(	O
_	O
(	O
" DW_MACRO_end_file\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
DW_MACRO_define	int
:	O
READ_ULEB	O
(	O
lineno	pointer
,	O
curr	pointer
,	O
end	pointer
)	O
;	O
string	pointer
=	O
curr	pointer
;	O
curr	pointer
+=	O
strnlen	function
(	O
(	O
char	O
*	O
)	O
string	pointer
,	O
end	pointer
-	O
string	pointer
)	O
+	O
1	int
;	O
printf	function
(	O
_	O
(	O
" DW_MACRO_define - lineno : %d macro : %s\n"	pointer
)	O
,	O
lineno	pointer
,	O
string	pointer
)	O
;	O
break	O
;	O
case	O
DW_MACRO_undef	int
:	O
READ_ULEB	O
(	O
lineno	pointer
,	O
curr	pointer
,	O
end	pointer
)	O
;	O
string	pointer
=	O
curr	pointer
;	O
curr	pointer
+=	O
strnlen	function
(	O
(	O
char	O
*	O
)	O
string	pointer
,	O
end	pointer
-	O
string	pointer
)	O
+	O
1	int
;	O
printf	function
(	O
_	O
(	O
" DW_MACRO_undef - lineno : %d macro : %s\n"	pointer
)	O
,	O
lineno	pointer
,	O
string	pointer
)	O
;	O
break	O
;	O
case	O
DW_MACRO_define_strp	int
:	O
READ_ULEB	O
(	O
lineno	pointer
,	O
curr	pointer
,	O
end	pointer
)	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
offset	long
,	O
curr	pointer
,	O
offset_size	int
,	O
end	pointer
)	O
;	O
string	pointer
=	O
fetch_indirect_string	function
(	O
offset	long
)	O
;	O
printf	function
(	O
_	O
(	O
" DW_MACRO_define_strp - lineno : %d macro : %s\n"	pointer
)	O
,	O
lineno	pointer
,	O
string	pointer
)	O
;	O
break	O
;	O
case	O
DW_MACRO_undef_strp	int
:	O
READ_ULEB	O
(	O
lineno	pointer
,	O
curr	pointer
,	O
end	pointer
)	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
offset	long
,	O
curr	pointer
,	O
offset_size	int
,	O
end	pointer
)	O
;	O
string	pointer
=	O
fetch_indirect_string	function
(	O
offset	long
)	O
;	O
printf	function
(	O
_	O
(	O
" DW_MACRO_undef_strp - lineno : %d macro : %s\n"	pointer
)	O
,	O
lineno	pointer
,	O
string	pointer
)	O
;	O
break	O
;	O
case	O
DW_MACRO_import	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
offset	long
,	O
curr	pointer
,	O
offset_size	int
,	O
end	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
" DW_MACRO_import - offset : 0x%lx\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
offset	long
)	O
;	O
break	O
;	O
case	O
DW_MACRO_define_sup	int
:	O
READ_ULEB	O
(	O
lineno	pointer
,	O
curr	pointer
,	O
end	pointer
)	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
offset	long
,	O
curr	pointer
,	O
offset_size	int
,	O
end	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
" DW_MACRO_define_sup - lineno : %d macro offset : 0x%lx\n"	pointer
)	O
,	O
lineno	pointer
,	O
(	O
unsigned	O
long	O
)	O
offset	long
)	O
;	O
break	O
;	O
case	O
DW_MACRO_undef_sup	int
:	O
READ_ULEB	O
(	O
lineno	pointer
,	O
curr	pointer
,	O
end	pointer
)	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
offset	long
,	O
curr	pointer
,	O
offset_size	int
,	O
end	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
" DW_MACRO_undef_sup - lineno : %d macro offset : 0x%lx\n"	pointer
)	O
,	O
lineno	pointer
,	O
(	O
unsigned	O
long	O
)	O
offset	long
)	O
;	O
break	O
;	O
case	O
DW_MACRO_import_sup	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
offset	long
,	O
curr	pointer
,	O
offset_size	int
,	O
end	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
" DW_MACRO_import_sup - offset : 0x%lx\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
offset	long
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
extended_ops	pointer
==	O
NULL	O
||	O
extended_ops	pointer
[	O
op	int
]	O
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
" Unknown macro opcode %02x seen\n"	pointer
)	O
,	O
op	int
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
dwarf_vma	long
nargs	long
,	O
n	long
;	O
unsigned	O
char	O
*	O
desc	pointer
=	O
extended_ops	pointer
[	O
op	int
]	O
;	O
READ_ULEB	O
(	O
nargs	long
,	O
desc	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
nargs	long
==	O
0	int
)	O
{	O
printf	function
(	O
_	O
(	O
" DW_MACRO_%02x\n"	pointer
)	O
,	O
op	int
)	O
;	O
break	O
;	O
}	O
printf	function
(	O
_	O
(	O
" DW_MACRO_%02x -"	pointer
)	O
,	O
op	int
)	O
;	O
for	O
(	O
n	long
=	O
0	int
;	O
n	long
<	O
nargs	long
;	O
n	long
++	O
)	O
{	O
int	O
val	array
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
val	array
,	O
desc	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
curr	pointer
=	O
read_and_display_attr_value	function
(	O
0	int
,	O
val	array
,	O
0	int
,	O
start	pointer
,	O
curr	pointer
,	O
end	pointer
,	O
0	int
,	O
0	int
,	O
offset_size	int
,	O
version	int
,	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
NULL	O
,	O
' '	O
,	O
-	O
1	int
)	O
;	O
if	O
(	O
n	long
!=	O
nargs	long
-	O
1	int
)	O
printf	function
(	O
","	pointer
)	O
;	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
break	O
;	O
}	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
display_debug_abbrev	function
(	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
void	O
*	O
file	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
abbrev_entry	struct
*	O
entry	long
;	O
unsigned	O
char	O
*	O
start	pointer
=	O
section	pointer
->	O
start	pointer
;	O
unsigned	O
char	O
*	O
end	pointer
=	O
start	pointer
+	O
section	pointer
->	O
size	int
;	O
introduce	function
(	O
section	pointer
,	O
FALSE	int
)	O
;	O
do	O
{	O
unsigned	O
char	O
*	O
last	pointer
;	O
free_abbrevs	function
(	O
)	O
;	O
last	pointer
=	O
start	pointer
;	O
start	pointer
=	O
process_abbrev_section	function
(	O
start	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
first_abbrev	pointer
==	O
NULL	O
)	O
continue	O
;	O
printf	function
(	O
_	O
(	O
"  Number TAG (0x%lx)\n"	pointer
)	O
,	O
(	O
long	O
)	O
(	O
last	pointer
-	O
section	pointer
->	O
start	pointer
)	O
)	O
;	O
for	O
(	O
entry	long
=	O
first_abbrev	pointer
;	O
entry	long
;	O
entry	long
=	O
entry	long
->	O
next	pointer
)	O
{	O
abbrev_attr	struct
*	O
attr	int
;	O
printf	function
(	O
"   %ld      %s    [%s]\n"	pointer
,	O
entry	long
->	O
entry	long
,	O
get_TAG_name	function
(	O
entry	long
->	O
tag	int
)	O
,	O
entry	long
->	O
children	int
?	O
_	O
(	O
"has children"	pointer
)	O
:	O
_	O
(	O
"no children"	pointer
)	O
)	O
;	O
for	O
(	O
attr	int
=	O
entry	long
->	O
first_attr	pointer
;	O
attr	int
;	O
attr	int
=	O
attr	int
->	O
next	pointer
)	O
{	O
printf	function
(	O
"    %-18s %s"	pointer
,	O
get_AT_name	function
(	O
attr	int
->	O
attribute	long
)	O
,	O
get_FORM_name	function
(	O
attr	int
->	O
form	int
)	O
)	O
;	O
if	O
(	O
attr	int
->	O
form	int
==	O
DW_FORM_implicit_const	int
)	O
printf	function
(	O
": %"	pointer
BFD_VMA_FMT	pointer
"d"	pointer
,	O
attr	int
->	O
implicit_const	long
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
}	O
}	O
while	O
(	O
start	pointer
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
static	O
bfd_boolean	int
is_max_address	function
(	O
dwarf_vma	long
addr	pointer
,	O
unsigned	O
int	O
pointer_size	int
)	O
{	O
dwarf_vma	long
mask	long
=	O
~	O
(	O
~	O
(	O
dwarf_vma	long
)	O
1	int
<<	O
(	O
pointer_size	int
*	O
8	int
-	O
1	int
)	O
)	O
;	O
return	O
(	O
(	O
addr	pointer
&	O
mask	long
)	O
==	O
mask	long
)	O
;	O
}	O
static	O
void	O
display_view_pair_list	function
(	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
unsigned	O
char	O
*	O
*	O
vstart_ptr	pointer
,	O
unsigned	O
int	O
debug_info_entry	int
,	O
unsigned	O
char	O
*	O
vlistend	pointer
)	O
{	O
unsigned	O
char	O
*	O
vstart	pointer
=	O
*	O
vstart_ptr	pointer
;	O
unsigned	O
char	O
*	O
section_end	pointer
=	O
section	pointer
->	O
start	pointer
+	O
section	pointer
->	O
size	int
;	O
unsigned	O
int	O
pointer_size	int
=	O
debug_information	pointer
[	O
debug_info_entry	int
]	O
.	O
pointer_size	int
;	O
if	O
(	O
vlistend	pointer
<	O
section_end	pointer
)	O
section_end	pointer
=	O
vlistend	pointer
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
while	O
(	O
vstart	pointer
<	O
section_end	pointer
)	O
{	O
dwarf_vma	long
off	long
=	O
vstart	pointer
-	O
section	pointer
->	O
start	pointer
;	O
dwarf_vma	long
vbegin	long
,	O
vend	long
;	O
READ_ULEB	O
(	O
vbegin	long
,	O
vstart	pointer
,	O
section_end	pointer
)	O
;	O
if	O
(	O
vstart	pointer
==	O
section_end	pointer
)	O
break	O
;	O
READ_ULEB	O
(	O
vend	long
,	O
vstart	pointer
,	O
section_end	pointer
)	O
;	O
printf	function
(	O
"    %8.8lx "	pointer
,	O
(	O
unsigned	O
long	O
)	O
off	long
)	O
;	O
print_dwarf_view	function
(	O
vbegin	long
,	O
pointer_size	int
,	O
1	int
)	O
;	O
print_dwarf_view	function
(	O
vend	long
,	O
pointer_size	int
,	O
1	int
)	O
;	O
printf	function
(	O
_	O
(	O
"location view pair\n"	pointer
)	O
)	O
;	O
}	O
putchar	function
(	O
'\n'	O
)	O
;	O
*	O
vstart_ptr	pointer
=	O
vstart	pointer
;	O
}	O
static	O
void	O
display_loc_list	function
(	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
unsigned	O
char	O
*	O
*	O
start_ptr	pointer
,	O
unsigned	O
int	O
debug_info_entry	int
,	O
dwarf_vma	long
offset	long
,	O
dwarf_vma	long
base_address	long
,	O
unsigned	O
char	O
*	O
*	O
vstart_ptr	pointer
,	O
int	O
has_frame_base	int
)	O
{	O
unsigned	O
char	O
*	O
start	pointer
=	O
*	O
start_ptr	pointer
,	O
*	O
vstart	pointer
=	O
*	O
vstart_ptr	pointer
;	O
unsigned	O
char	O
*	O
section_end	pointer
=	O
section	pointer
->	O
start	pointer
+	O
section	pointer
->	O
size	int
;	O
unsigned	O
long	O
cu_offset	long
;	O
unsigned	O
int	O
pointer_size	int
;	O
unsigned	O
int	O
offset_size	int
;	O
int	O
dwarf_version	int
;	O
dwarf_vma	long
begin	long
;	O
dwarf_vma	long
end	pointer
;	O
unsigned	O
short	O
length	long
;	O
int	O
need_frame_base	int
;	O
if	O
(	O
debug_info_entry	int
>=	O
num_debug_info_entries	int
)	O
{	O
warn	function
(	O
_	O
(	O
"No debug information available for loc lists of entry: %u\n"	pointer
)	O
,	O
debug_info_entry	int
)	O
;	O
return	O
;	O
}	O
cu_offset	long
=	O
debug_information	pointer
[	O
debug_info_entry	int
]	O
.	O
cu_offset	long
;	O
pointer_size	int
=	O
debug_information	pointer
[	O
debug_info_entry	int
]	O
.	O
pointer_size	int
;	O
offset_size	int
=	O
debug_information	pointer
[	O
debug_info_entry	int
]	O
.	O
offset_size	int
;	O
dwarf_version	int
=	O
debug_information	pointer
[	O
debug_info_entry	int
]	O
.	O
dwarf_version	int
;	O
if	O
(	O
pointer_size	int
<	O
2	int
||	O
pointer_size	int
>	O
8	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Invalid pointer size (%d) in debug info for entry %d\n"	pointer
)	O
,	O
pointer_size	int
,	O
debug_info_entry	int
)	O
;	O
return	O
;	O
}	O
while	O
(	O
1	int
)	O
{	O
dwarf_vma	long
off	long
=	O
offset	long
+	O
(	O
start	pointer
-	O
*	O
start_ptr	pointer
)	O
;	O
dwarf_vma	long
vbegin	long
=	O
vm1	long
,	O
vend	long
=	O
vm1	long
;	O
if	O
(	O
start	pointer
+	O
2	int
*	O
pointer_size	int
>	O
section_end	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"Location list starting at offset 0x%lx is not terminated.\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
offset	long
)	O
;	O
break	O
;	O
}	O
printf	function
(	O
"    %8.8lx "	pointer
,	O
(	O
unsigned	O
long	O
)	O
off	long
)	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
begin	long
,	O
start	pointer
,	O
pointer_size	int
,	O
section_end	pointer
)	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
end	pointer
,	O
start	pointer
,	O
pointer_size	int
,	O
section_end	pointer
)	O
;	O
if	O
(	O
begin	long
==	O
0	int
&&	O
end	pointer
==	O
0	int
)	O
{	O
if	O
(	O
!	O
reloc_at	function
(	O
section	pointer
,	O
off	long
)	O
&&	O
!	O
reloc_at	function
(	O
section	pointer
,	O
off	long
+	O
pointer_size	int
)	O
)	O
{	O
printf	function
(	O
_	O
(	O
"<End of list>\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
is_max_address	function
(	O
begin	long
,	O
pointer_size	int
)	O
&&	O
!	O
is_max_address	function
(	O
end	pointer
,	O
pointer_size	int
)	O
)	O
{	O
base_address	long
=	O
end	pointer
;	O
print_dwarf_vma	function
(	O
begin	long
,	O
pointer_size	int
)	O
;	O
print_dwarf_vma	function
(	O
end	pointer
,	O
pointer_size	int
)	O
;	O
printf	function
(	O
_	O
(	O
"(base address)\n"	pointer
)	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
vstart	pointer
)	O
{	O
off	long
=	O
offset	long
+	O
(	O
vstart	pointer
-	O
*	O
start_ptr	pointer
)	O
;	O
READ_ULEB	O
(	O
vbegin	long
,	O
vstart	pointer
,	O
section_end	pointer
)	O
;	O
print_dwarf_view	function
(	O
vbegin	long
,	O
pointer_size	int
,	O
1	int
)	O
;	O
READ_ULEB	O
(	O
vend	long
,	O
vstart	pointer
,	O
section_end	pointer
)	O
;	O
print_dwarf_view	function
(	O
vend	long
,	O
pointer_size	int
,	O
1	int
)	O
;	O
printf	function
(	O
_	O
(	O
"views at %8.8lx for:\n    %*s "	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
off	long
,	O
8	int
,	O
""	pointer
)	O
;	O
}	O
if	O
(	O
start	pointer
+	O
2	int
>	O
section_end	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"Location list starting at offset 0x%lx is not terminated.\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
offset	long
)	O
;	O
break	O
;	O
}	O
SAFE_BYTE_GET_AND_INC	O
(	O
length	long
,	O
start	pointer
,	O
2	int
,	O
section_end	pointer
)	O
;	O
if	O
(	O
start	pointer
+	O
length	long
>	O
section_end	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"Location list starting at offset 0x%lx is not terminated.\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
offset	long
)	O
;	O
break	O
;	O
}	O
print_dwarf_vma	function
(	O
begin	long
+	O
base_address	long
,	O
pointer_size	int
)	O
;	O
print_dwarf_vma	function
(	O
end	pointer
+	O
base_address	long
,	O
pointer_size	int
)	O
;	O
putchar	function
(	O
'('	O
)	O
;	O
need_frame_base	int
=	O
decode_location_expression	function
(	O
start	pointer
,	O
pointer_size	int
,	O
offset_size	int
,	O
dwarf_version	int
,	O
length	long
,	O
cu_offset	long
,	O
section	pointer
)	O
;	O
putchar	function
(	O
')'	O
)	O
;	O
if	O
(	O
need_frame_base	int
&&	O
!	O
has_frame_base	int
)	O
printf	function
(	O
_	O
(	O
" [without DW_AT_frame_base]"	pointer
)	O
)	O
;	O
if	O
(	O
begin	long
==	O
end	pointer
&&	O
vbegin	long
==	O
vend	long
)	O
fputs	function
(	O
_	O
(	O
" (start == end)"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
else	O
if	O
(	O
begin	long
>	O
end	pointer
||	O
(	O
begin	long
==	O
end	pointer
&&	O
vbegin	long
>	O
vend	long
)	O
)	O
fputs	function
(	O
_	O
(	O
" (start > end)"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
start	pointer
+=	O
length	long
;	O
}	O
*	O
start_ptr	pointer
=	O
start	pointer
;	O
*	O
vstart_ptr	pointer
=	O
vstart	pointer
;	O
}	O
static	O
void	O
display_loclists_list	function
(	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
unsigned	O
char	O
*	O
*	O
start_ptr	pointer
,	O
unsigned	O
int	O
debug_info_entry	int
,	O
dwarf_vma	long
offset	long
,	O
dwarf_vma	long
base_address	long
,	O
unsigned	O
char	O
*	O
*	O
vstart_ptr	pointer
,	O
int	O
has_frame_base	int
)	O
{	O
unsigned	O
char	O
*	O
start	pointer
=	O
*	O
start_ptr	pointer
,	O
*	O
vstart	pointer
=	O
*	O
vstart_ptr	pointer
;	O
unsigned	O
char	O
*	O
section_end	pointer
=	O
section	pointer
->	O
start	pointer
+	O
section	pointer
->	O
size	int
;	O
unsigned	O
long	O
cu_offset	long
;	O
unsigned	O
int	O
pointer_size	int
;	O
unsigned	O
int	O
offset_size	int
;	O
int	O
dwarf_version	int
;	O
dwarf_vma	long
begin	long
=	O
-	O
1	int
,	O
vbegin	long
=	O
-	O
1	int
;	O
dwarf_vma	long
end	pointer
=	O
-	O
1	int
,	O
vend	long
=	O
-	O
1	int
;	O
dwarf_vma	long
length	long
;	O
int	O
need_frame_base	int
;	O
if	O
(	O
debug_info_entry	int
>=	O
num_debug_info_entries	int
)	O
{	O
warn	function
(	O
_	O
(	O
"No debug information available for "	pointer
"loclists lists of entry: %u\n"	pointer
)	O
,	O
debug_info_entry	int
)	O
;	O
return	O
;	O
}	O
cu_offset	long
=	O
debug_information	pointer
[	O
debug_info_entry	int
]	O
.	O
cu_offset	long
;	O
pointer_size	int
=	O
debug_information	pointer
[	O
debug_info_entry	int
]	O
.	O
pointer_size	int
;	O
offset_size	int
=	O
debug_information	pointer
[	O
debug_info_entry	int
]	O
.	O
offset_size	int
;	O
dwarf_version	int
=	O
debug_information	pointer
[	O
debug_info_entry	int
]	O
.	O
dwarf_version	int
;	O
if	O
(	O
pointer_size	int
<	O
2	int
||	O
pointer_size	int
>	O
8	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Invalid pointer size (%d) in debug info for entry %d\n"	pointer
)	O
,	O
pointer_size	int
,	O
debug_info_entry	int
)	O
;	O
return	O
;	O
}	O
while	O
(	O
1	int
)	O
{	O
dwarf_vma	long
off	long
=	O
offset	long
+	O
(	O
start	pointer
-	O
*	O
start_ptr	pointer
)	O
;	O
enum	O
dwarf_location_list_entry_type	enum
llet	enum
;	O
if	O
(	O
start	pointer
+	O
1	int
>	O
section_end	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"Location list starting at offset 0x%lx is not terminated.\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
offset	long
)	O
;	O
break	O
;	O
}	O
printf	function
(	O
"    %8.8lx "	pointer
,	O
(	O
unsigned	O
long	O
)	O
off	long
)	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
llet	enum
,	O
start	pointer
,	O
1	int
,	O
section_end	pointer
)	O
;	O
if	O
(	O
vstart	pointer
&&	O
llet	enum
==	O
DW_LLE_offset_pair	int
)	O
{	O
off	long
=	O
offset	long
+	O
(	O
vstart	pointer
-	O
*	O
start_ptr	pointer
)	O
;	O
READ_ULEB	O
(	O
vbegin	long
,	O
vstart	pointer
,	O
section_end	pointer
)	O
;	O
print_dwarf_view	function
(	O
vbegin	long
,	O
pointer_size	int
,	O
1	int
)	O
;	O
READ_ULEB	O
(	O
vend	long
,	O
vstart	pointer
,	O
section_end	pointer
)	O
;	O
print_dwarf_view	function
(	O
vend	long
,	O
pointer_size	int
,	O
1	int
)	O
;	O
printf	function
(	O
_	O
(	O
"views at %8.8lx for:\n    %*s "	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
off	long
,	O
8	int
,	O
""	pointer
)	O
;	O
}	O
switch	O
(	O
llet	enum
)	O
{	O
case	O
DW_LLE_end_of_list	int
:	O
printf	function
(	O
_	O
(	O
"<End of list>\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
DW_LLE_offset_pair	int
:	O
READ_ULEB	O
(	O
begin	long
,	O
start	pointer
,	O
section_end	pointer
)	O
;	O
READ_ULEB	O
(	O
end	pointer
,	O
start	pointer
,	O
section_end	pointer
)	O
;	O
break	O
;	O
case	O
DW_LLE_base_address	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
base_address	long
,	O
start	pointer
,	O
pointer_size	int
,	O
section_end	pointer
)	O
;	O
print_dwarf_vma	function
(	O
base_address	long
,	O
pointer_size	int
)	O
;	O
printf	function
(	O
_	O
(	O
"(base address)\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
DW_LLE_view_pair	O
:	O
if	O
(	O
vstart	pointer
)	O
printf	function
(	O
_	O
(	O
"View pair entry in loclist with locviews attribute\n"	pointer
)	O
)	O
;	O
READ_ULEB	O
(	O
vbegin	long
,	O
start	pointer
,	O
section_end	pointer
)	O
;	O
print_dwarf_view	function
(	O
vbegin	long
,	O
pointer_size	int
,	O
1	int
)	O
;	O
READ_ULEB	O
(	O
vend	long
,	O
start	pointer
,	O
section_end	pointer
)	O
;	O
print_dwarf_view	function
(	O
vend	long
,	O
pointer_size	int
,	O
1	int
)	O
;	O
printf	function
(	O
_	O
(	O
"views for:\n"	pointer
)	O
)	O
;	O
continue	O
;	O
default	O
:	O
error	function
(	O
_	O
(	O
"Invalid location list entry type %d\n"	pointer
)	O
,	O
llet	enum
)	O
;	O
return	O
;	O
}	O
if	O
(	O
llet	enum
==	O
DW_LLE_end_of_list	int
)	O
break	O
;	O
if	O
(	O
llet	enum
!=	O
DW_LLE_offset_pair	int
)	O
continue	O
;	O
if	O
(	O
start	pointer
+	O
2	int
>	O
section_end	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"Location list starting at offset 0x%lx is not terminated.\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
offset	long
)	O
;	O
break	O
;	O
}	O
READ_ULEB	O
(	O
length	long
,	O
start	pointer
,	O
section_end	pointer
)	O
;	O
print_dwarf_vma	function
(	O
begin	long
+	O
base_address	long
,	O
pointer_size	int
)	O
;	O
print_dwarf_vma	function
(	O
end	pointer
+	O
base_address	long
,	O
pointer_size	int
)	O
;	O
putchar	function
(	O
'('	O
)	O
;	O
need_frame_base	int
=	O
decode_location_expression	function
(	O
start	pointer
,	O
pointer_size	int
,	O
offset_size	int
,	O
dwarf_version	int
,	O
length	long
,	O
cu_offset	long
,	O
section	pointer
)	O
;	O
putchar	function
(	O
')'	O
)	O
;	O
if	O
(	O
need_frame_base	int
&&	O
!	O
has_frame_base	int
)	O
printf	function
(	O
_	O
(	O
" [without DW_AT_frame_base]"	pointer
)	O
)	O
;	O
if	O
(	O
begin	long
==	O
end	pointer
&&	O
vbegin	long
==	O
vend	long
)	O
fputs	function
(	O
_	O
(	O
" (start == end)"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
else	O
if	O
(	O
begin	long
>	O
end	pointer
||	O
(	O
begin	long
==	O
end	pointer
&&	O
vbegin	long
>	O
vend	long
)	O
)	O
fputs	function
(	O
_	O
(	O
" (start > end)"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
start	pointer
+=	O
length	long
;	O
vbegin	long
=	O
vend	long
=	O
-	O
1	int
;	O
}	O
if	O
(	O
vbegin	long
!=	O
vm1	long
||	O
vend	long
!=	O
vm1	long
)	O
printf	function
(	O
_	O
(	O
"Trailing view pair not used in a range"	pointer
)	O
)	O
;	O
*	O
start_ptr	pointer
=	O
start	pointer
;	O
*	O
vstart_ptr	pointer
=	O
vstart	pointer
;	O
}	O
static	O
void	O
print_addr_index	function
(	O
unsigned	O
int	O
idx	int
,	O
unsigned	O
int	O
len	long
)	O
{	O
static	O
char	O
buf	pointer
[	O
15	int
]	O
;	O
snprintf	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
"[%d]"	pointer
,	O
idx	int
)	O
;	O
printf	function
(	O
"%*s "	pointer
,	O
len	long
,	O
buf	pointer
)	O
;	O
}	O
static	O
void	O
display_loc_list_dwo	function
(	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
unsigned	O
char	O
*	O
*	O
start_ptr	pointer
,	O
unsigned	O
int	O
debug_info_entry	int
,	O
dwarf_vma	long
offset	long
,	O
unsigned	O
char	O
*	O
*	O
vstart_ptr	pointer
,	O
int	O
has_frame_base	int
)	O
{	O
unsigned	O
char	O
*	O
start	pointer
=	O
*	O
start_ptr	pointer
,	O
*	O
vstart	pointer
=	O
*	O
vstart_ptr	pointer
;	O
unsigned	O
char	O
*	O
section_end	pointer
=	O
section	pointer
->	O
start	pointer
+	O
section	pointer
->	O
size	int
;	O
unsigned	O
long	O
cu_offset	long
;	O
unsigned	O
int	O
pointer_size	int
;	O
unsigned	O
int	O
offset_size	int
;	O
int	O
dwarf_version	int
;	O
int	O
entry_type	int
;	O
unsigned	O
short	O
length	long
;	O
int	O
need_frame_base	int
;	O
unsigned	O
int	O
idx	int
;	O
if	O
(	O
debug_info_entry	int
>=	O
num_debug_info_entries	int
)	O
{	O
warn	function
(	O
_	O
(	O
"No debug information for loc lists of entry: %u\n"	pointer
)	O
,	O
debug_info_entry	int
)	O
;	O
return	O
;	O
}	O
cu_offset	long
=	O
debug_information	pointer
[	O
debug_info_entry	int
]	O
.	O
cu_offset	long
;	O
pointer_size	int
=	O
debug_information	pointer
[	O
debug_info_entry	int
]	O
.	O
pointer_size	int
;	O
offset_size	int
=	O
debug_information	pointer
[	O
debug_info_entry	int
]	O
.	O
offset_size	int
;	O
dwarf_version	int
=	O
debug_information	pointer
[	O
debug_info_entry	int
]	O
.	O
dwarf_version	int
;	O
if	O
(	O
pointer_size	int
<	O
2	int
||	O
pointer_size	int
>	O
8	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Invalid pointer size (%d) in debug info for entry %d\n"	pointer
)	O
,	O
pointer_size	int
,	O
debug_info_entry	int
)	O
;	O
return	O
;	O
}	O
while	O
(	O
1	int
)	O
{	O
printf	function
(	O
"    %8.8lx "	pointer
,	O
(	O
unsigned	O
long	O
)	O
(	O
offset	long
+	O
(	O
start	pointer
-	O
*	O
start_ptr	pointer
)	O
)	O
)	O
;	O
if	O
(	O
start	pointer
>=	O
section_end	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"Location list starting at offset 0x%lx is not terminated.\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
offset	long
)	O
;	O
break	O
;	O
}	O
SAFE_BYTE_GET_AND_INC	O
(	O
entry_type	int
,	O
start	pointer
,	O
1	int
,	O
section_end	pointer
)	O
;	O
if	O
(	O
vstart	pointer
)	O
switch	O
(	O
entry_type	int
)	O
{	O
default	O
:	O
break	O
;	O
case	O
2	int
:	O
case	O
3	int
:	O
case	O
4	int
:	O
{	O
dwarf_vma	long
view	int
;	O
dwarf_vma	long
off	long
=	O
offset	long
+	O
(	O
vstart	pointer
-	O
*	O
start_ptr	pointer
)	O
;	O
READ_ULEB	O
(	O
view	int
,	O
vstart	pointer
,	O
section_end	pointer
)	O
;	O
print_dwarf_view	function
(	O
view	int
,	O
8	int
,	O
1	int
)	O
;	O
READ_ULEB	O
(	O
view	int
,	O
vstart	pointer
,	O
section_end	pointer
)	O
;	O
print_dwarf_view	function
(	O
view	int
,	O
8	int
,	O
1	int
)	O
;	O
printf	function
(	O
_	O
(	O
"views at %8.8lx for:\n    %*s "	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
off	long
,	O
8	int
,	O
""	pointer
)	O
;	O
}	O
break	O
;	O
}	O
switch	O
(	O
entry_type	int
)	O
{	O
case	O
0	int
:	O
*	O
start_ptr	pointer
=	O
start	pointer
;	O
*	O
vstart_ptr	pointer
=	O
vstart	pointer
;	O
printf	function
(	O
_	O
(	O
"<End of list>\n"	pointer
)	O
)	O
;	O
return	O
;	O
case	O
1	int
:	O
READ_ULEB	O
(	O
idx	int
,	O
start	pointer
,	O
section_end	pointer
)	O
;	O
print_addr_index	function
(	O
idx	int
,	O
8	int
)	O
;	O
printf	function
(	O
"%*s"	pointer
,	O
9	int
+	O
(	O
vstart	pointer
?	O
2	int
*	O
6	int
:	O
0	int
)	O
,	O
""	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"(base address selection entry)\n"	pointer
)	O
)	O
;	O
continue	O
;	O
case	O
2	int
:	O
READ_ULEB	O
(	O
idx	int
,	O
start	pointer
,	O
section_end	pointer
)	O
;	O
print_addr_index	function
(	O
idx	int
,	O
8	int
)	O
;	O
READ_ULEB	O
(	O
idx	int
,	O
start	pointer
,	O
section_end	pointer
)	O
;	O
print_addr_index	function
(	O
idx	int
,	O
8	int
)	O
;	O
break	O
;	O
case	O
3	int
:	O
READ_ULEB	O
(	O
idx	int
,	O
start	pointer
,	O
section_end	pointer
)	O
;	O
print_addr_index	function
(	O
idx	int
,	O
8	int
)	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
idx	int
,	O
start	pointer
,	O
4	int
,	O
section_end	pointer
)	O
;	O
printf	function
(	O
"%08x "	pointer
,	O
idx	int
)	O
;	O
break	O
;	O
case	O
4	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
idx	int
,	O
start	pointer
,	O
4	int
,	O
section_end	pointer
)	O
;	O
printf	function
(	O
"%08x "	pointer
,	O
idx	int
)	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
idx	int
,	O
start	pointer
,	O
4	int
,	O
section_end	pointer
)	O
;	O
printf	function
(	O
"%08x "	pointer
,	O
idx	int
)	O
;	O
break	O
;	O
default	O
:	O
warn	function
(	O
_	O
(	O
"Unknown location list entry type 0x%x.\n"	pointer
)	O
,	O
entry_type	int
)	O
;	O
*	O
start_ptr	pointer
=	O
start	pointer
;	O
*	O
vstart_ptr	pointer
=	O
vstart	pointer
;	O
return	O
;	O
}	O
if	O
(	O
start	pointer
+	O
2	int
>	O
section_end	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"Location list starting at offset 0x%lx is not terminated.\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
offset	long
)	O
;	O
break	O
;	O
}	O
SAFE_BYTE_GET_AND_INC	O
(	O
length	long
,	O
start	pointer
,	O
2	int
,	O
section_end	pointer
)	O
;	O
if	O
(	O
start	pointer
+	O
length	long
>	O
section_end	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"Location list starting at offset 0x%lx is not terminated.\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
offset	long
)	O
;	O
break	O
;	O
}	O
putchar	function
(	O
'('	O
)	O
;	O
need_frame_base	int
=	O
decode_location_expression	function
(	O
start	pointer
,	O
pointer_size	int
,	O
offset_size	int
,	O
dwarf_version	int
,	O
length	long
,	O
cu_offset	long
,	O
section	pointer
)	O
;	O
putchar	function
(	O
')'	O
)	O
;	O
if	O
(	O
need_frame_base	int
&&	O
!	O
has_frame_base	int
)	O
printf	function
(	O
_	O
(	O
" [without DW_AT_frame_base]"	pointer
)	O
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
start	pointer
+=	O
length	long
;	O
}	O
*	O
start_ptr	pointer
=	O
start	pointer
;	O
*	O
vstart_ptr	pointer
=	O
vstart	pointer
;	O
}	O
static	O
dwarf_vma	long
*	O
loc_offsets	pointer
,	O
*	O
loc_views	pointer
;	O
static	O
int	O
loc_offsets_compar	function
(	O
const	O
void	O
*	O
ap	pointer
,	O
const	O
void	O
*	O
bp	pointer
)	O
{	O
dwarf_vma	long
a	pointer
=	O
loc_offsets	pointer
[	O
*	O
(	O
const	O
unsigned	O
int	O
*	O
)	O
ap	pointer
]	O
;	O
dwarf_vma	long
b	pointer
=	O
loc_offsets	pointer
[	O
*	O
(	O
const	O
unsigned	O
int	O
*	O
)	O
bp	pointer
]	O
;	O
int	O
ret	pointer
=	O
(	O
a	pointer
>	O
b	pointer
)	O
-	O
(	O
b	pointer
>	O
a	pointer
)	O
;	O
if	O
(	O
ret	pointer
)	O
return	O
ret	pointer
;	O
a	pointer
=	O
loc_views	pointer
[	O
*	O
(	O
const	O
unsigned	O
int	O
*	O
)	O
ap	pointer
]	O
;	O
b	pointer
=	O
loc_views	pointer
[	O
*	O
(	O
const	O
unsigned	O
int	O
*	O
)	O
bp	pointer
]	O
;	O
ret	pointer
=	O
(	O
a	pointer
>	O
b	pointer
)	O
-	O
(	O
b	pointer
>	O
a	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
static	O
int	O
display_debug_loc	function
(	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
void	O
*	O
file	pointer
)	O
{	O
unsigned	O
char	O
*	O
start	pointer
=	O
section	pointer
->	O
start	pointer
,	O
*	O
vstart	pointer
=	O
NULL	O
;	O
unsigned	O
long	O
bytes	long
;	O
unsigned	O
char	O
*	O
section_begin	pointer
=	O
start	pointer
;	O
unsigned	O
int	O
num_loc_list	int
=	O
0	int
;	O
unsigned	O
long	O
last_offset	long
=	O
0	int
;	O
unsigned	O
long	O
last_view	long
=	O
0	int
;	O
unsigned	O
int	O
first	int
=	O
0	int
;	O
unsigned	O
int	O
i	pointer
;	O
unsigned	O
int	O
j	int
;	O
int	O
seen_first_offset	int
=	O
0	int
;	O
int	O
locs_sorted	int
=	O
1	int
;	O
unsigned	O
char	O
*	O
next	pointer
=	O
start	pointer
,	O
*	O
vnext	pointer
=	O
vstart	pointer
;	O
unsigned	O
int	O
*	O
array	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
suffix	pointer
=	O
strrchr	function
(	O
section	pointer
->	O
name	pointer
,	O
'.'	O
)	O
;	O
bfd_boolean	int
is_dwo	int
=	O
FALSE	int
;	O
int	O
is_loclists	int
=	O
strstr	function
(	O
section	pointer
->	O
name	pointer
,	O
"debug_loclists"	pointer
)	O
!=	O
NULL	O
;	O
dwarf_vma	long
expected_start	long
=	O
0	int
;	O
if	O
(	O
suffix	pointer
&&	O
strcmp	function
(	O
suffix	pointer
,	O
".dwo"	pointer
)	O
==	O
0	int
)	O
is_dwo	int
=	O
TRUE	int
;	O
bytes	long
=	O
section	pointer
->	O
size	int
;	O
if	O
(	O
bytes	long
==	O
0	int
)	O
{	O
printf	function
(	O
_	O
(	O
"\nThe %s section is empty.\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
is_loclists	int
)	O
{	O
unsigned	O
char	O
*	O
hdrptr	pointer
=	O
section_begin	pointer
;	O
dwarf_vma	long
ll_length	long
;	O
unsigned	O
short	O
ll_version	short
;	O
unsigned	O
char	O
*	O
end	pointer
=	O
section_begin	pointer
+	O
section	pointer
->	O
size	int
;	O
unsigned	O
char	O
address_size	char
,	O
segment_selector_size	char
;	O
uint32_t	int
offset_entry_count	int
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
ll_length	long
,	O
hdrptr	pointer
,	O
4	int
,	O
end	pointer
)	O
;	O
if	O
(	O
ll_length	long
==	O
0xffffffff	int
)	O
SAFE_BYTE_GET_AND_INC	O
(	O
ll_length	long
,	O
hdrptr	pointer
,	O
8	int
,	O
end	pointer
)	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
ll_version	short
,	O
hdrptr	pointer
,	O
2	int
,	O
end	pointer
)	O
;	O
if	O
(	O
ll_version	short
!=	O
5	int
)	O
{	O
warn	function
(	O
_	O
(	O
"The %s section contains corrupt or "	pointer
"unsupported version number: %d.\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
,	O
ll_version	short
)	O
;	O
return	O
0	int
;	O
}	O
SAFE_BYTE_GET_AND_INC	O
(	O
address_size	char
,	O
hdrptr	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
segment_selector_size	char
,	O
hdrptr	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
if	O
(	O
segment_selector_size	char
!=	O
0	int
)	O
{	O
warn	function
(	O
_	O
(	O
"The %s section contains "	pointer
"unsupported segment selector size: %d.\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
,	O
segment_selector_size	char
)	O
;	O
return	O
0	int
;	O
}	O
SAFE_BYTE_GET_AND_INC	O
(	O
offset_entry_count	int
,	O
hdrptr	pointer
,	O
4	int
,	O
end	pointer
)	O
;	O
if	O
(	O
offset_entry_count	int
!=	O
0	int
)	O
{	O
warn	function
(	O
_	O
(	O
"The %s section contains "	pointer
"unsupported offset entry count: %d.\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
,	O
offset_entry_count	int
)	O
;	O
return	O
0	int
;	O
}	O
expected_start	long
=	O
hdrptr	pointer
-	O
section_begin	pointer
;	O
}	O
if	O
(	O
load_debug_info	function
(	O
file	pointer
)	O
==	O
0	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Unable to load/parse the .debug_info section, so cannot interpret the %s section.\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
num_debug_info_entries	int
;	O
i	pointer
++	O
)	O
{	O
unsigned	O
int	O
num	int
;	O
num	int
=	O
debug_information	pointer
[	O
i	pointer
]	O
.	O
num_loc_offsets	int
;	O
if	O
(	O
num	int
>	O
num_loc_list	int
)	O
num_loc_list	int
=	O
num	int
;	O
if	O
(	O
locs_sorted	int
&&	O
num	int
!=	O
0	int
)	O
{	O
if	O
(	O
!	O
seen_first_offset	int
)	O
{	O
last_offset	long
=	O
debug_information	pointer
[	O
i	pointer
]	O
.	O
loc_offsets	pointer
[	O
0	int
]	O
;	O
last_view	long
=	O
debug_information	pointer
[	O
i	pointer
]	O
.	O
loc_views	pointer
[	O
0	int
]	O
;	O
first	int
=	O
i	pointer
;	O
seen_first_offset	int
=	O
1	int
;	O
j	int
=	O
1	int
;	O
}	O
else	O
j	int
=	O
0	int
;	O
for	O
(	O
;	O
j	int
<	O
num	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
last_offset	long
>	O
debug_information	pointer
[	O
i	pointer
]	O
.	O
loc_offsets	pointer
[	O
j	int
]	O
||	O
(	O
last_offset	long
==	O
debug_information	pointer
[	O
i	pointer
]	O
.	O
loc_offsets	pointer
[	O
j	int
]	O
&&	O
last_view	long
>	O
debug_information	pointer
[	O
i	pointer
]	O
.	O
loc_views	pointer
[	O
j	int
]	O
)	O
)	O
{	O
locs_sorted	int
=	O
0	int
;	O
break	O
;	O
}	O
last_offset	long
=	O
debug_information	pointer
[	O
i	pointer
]	O
.	O
loc_offsets	pointer
[	O
j	int
]	O
;	O
last_view	long
=	O
debug_information	pointer
[	O
i	pointer
]	O
.	O
loc_views	pointer
[	O
j	int
]	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
seen_first_offset	int
)	O
error	function
(	O
_	O
(	O
"No location lists in .debug_info section!\n"	pointer
)	O
)	O
;	O
if	O
(	O
debug_information	pointer
[	O
first	int
]	O
.	O
num_loc_offsets	int
>	O
0	int
&&	O
debug_information	pointer
[	O
first	int
]	O
.	O
loc_offsets	pointer
[	O
0	int
]	O
!=	O
expected_start	long
&&	O
debug_information	pointer
[	O
first	int
]	O
.	O
loc_views	pointer
[	O
0	int
]	O
!=	O
expected_start	long
)	O
warn	function
(	O
_	O
(	O
"Location lists in %s section start at 0x%s\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
debug_information	pointer
[	O
first	int
]	O
.	O
loc_offsets	pointer
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
locs_sorted	int
)	O
array	pointer
=	O
(	O
unsigned	O
int	O
*	O
)	O
xcmalloc	function
(	O
num_loc_list	int
,	O
sizeof	O
(	O
unsigned	O
int	O
)	O
)	O
;	O
introduce	function
(	O
section	pointer
,	O
FALSE	int
)	O
;	O
if	O
(	O
reloc_at	function
(	O
section	pointer
,	O
0	int
)	O
)	O
printf	function
(	O
_	O
(	O
" Warning: This section has relocations - addresses seen here may not be accurate.\n\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"    Offset   Begin            End              Expression\n"	pointer
)	O
)	O
;	O
seen_first_offset	int
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
first	int
;	O
i	pointer
<	O
num_debug_info_entries	int
;	O
i	pointer
++	O
)	O
{	O
dwarf_vma	long
offset	long
,	O
voffset	long
;	O
dwarf_vma	long
base_address	long
;	O
unsigned	O
int	O
k	int
;	O
int	O
has_frame_base	int
;	O
if	O
(	O
!	O
locs_sorted	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
debug_information	pointer
[	O
i	pointer
]	O
.	O
num_loc_offsets	int
;	O
k	int
++	O
)	O
array	pointer
[	O
k	int
]	O
=	O
k	int
;	O
loc_offsets	pointer
=	O
debug_information	pointer
[	O
i	pointer
]	O
.	O
loc_offsets	pointer
;	O
loc_views	pointer
=	O
debug_information	pointer
[	O
i	pointer
]	O
.	O
loc_views	pointer
;	O
qsort	function
(	O
array	pointer
,	O
debug_information	pointer
[	O
i	pointer
]	O
.	O
num_loc_offsets	int
,	O
sizeof	O
(	O
*	O
array	pointer
)	O
,	O
loc_offsets_compar	function
)	O
;	O
}	O
int	O
adjacent_view_loclists	int
=	O
1	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
debug_information	pointer
[	O
i	pointer
]	O
.	O
num_loc_offsets	int
;	O
k	int
++	O
)	O
{	O
j	int
=	O
locs_sorted	int
?	O
k	int
:	O
array	pointer
[	O
k	int
]	O
;	O
if	O
(	O
k	int
&&	O
(	O
debug_information	pointer
[	O
i	pointer
]	O
.	O
loc_offsets	pointer
[	O
locs_sorted	int
?	O
k	int
-	O
1	int
:	O
array	pointer
[	O
k	int
-	O
1	int
]	O
]	O
==	O
debug_information	pointer
[	O
i	pointer
]	O
.	O
loc_offsets	pointer
[	O
j	int
]	O
)	O
&&	O
(	O
debug_information	pointer
[	O
i	pointer
]	O
.	O
loc_views	pointer
[	O
locs_sorted	int
?	O
k	int
-	O
1	int
:	O
array	pointer
[	O
k	int
-	O
1	int
]	O
]	O
==	O
debug_information	pointer
[	O
i	pointer
]	O
.	O
loc_views	pointer
[	O
j	int
]	O
)	O
)	O
continue	O
;	O
has_frame_base	int
=	O
debug_information	pointer
[	O
i	pointer
]	O
.	O
have_frame_base	pointer
[	O
j	int
]	O
;	O
offset	long
=	O
debug_information	pointer
[	O
i	pointer
]	O
.	O
loc_offsets	pointer
[	O
j	int
]	O
;	O
next	pointer
=	O
section_begin	pointer
+	O
offset	long
;	O
voffset	long
=	O
debug_information	pointer
[	O
i	pointer
]	O
.	O
loc_views	pointer
[	O
j	int
]	O
;	O
if	O
(	O
voffset	long
!=	O
vm1	long
)	O
vnext	pointer
=	O
section_begin	pointer
+	O
voffset	long
;	O
else	O
vnext	pointer
=	O
NULL	O
;	O
base_address	long
=	O
debug_information	pointer
[	O
i	pointer
]	O
.	O
base_address	long
;	O
if	O
(	O
vnext	pointer
&&	O
vnext	pointer
<	O
next	pointer
)	O
{	O
vstart	pointer
=	O
vnext	pointer
;	O
display_view_pair_list	function
(	O
section	pointer
,	O
&	O
vstart	pointer
,	O
i	pointer
,	O
next	pointer
)	O
;	O
if	O
(	O
start	pointer
==	O
vnext	pointer
)	O
start	pointer
=	O
vstart	pointer
;	O
}	O
if	O
(	O
!	O
seen_first_offset	int
||	O
!	O
adjacent_view_loclists	int
)	O
seen_first_offset	int
=	O
1	int
;	O
else	O
{	O
if	O
(	O
start	pointer
<	O
next	pointer
)	O
warn	function
(	O
_	O
(	O
"There is a hole [0x%lx - 0x%lx] in .debug_loc section.\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
(	O
start	pointer
-	O
section_begin	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
offset	long
)	O
;	O
else	O
if	O
(	O
start	pointer
>	O
next	pointer
)	O
warn	function
(	O
_	O
(	O
"There is an overlap [0x%lx - 0x%lx] in .debug_loc section.\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
(	O
start	pointer
-	O
section_begin	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
offset	long
)	O
;	O
}	O
start	pointer
=	O
next	pointer
;	O
vstart	pointer
=	O
vnext	pointer
;	O
if	O
(	O
offset	long
>=	O
bytes	long
)	O
{	O
warn	function
(	O
_	O
(	O
"Offset 0x%lx is bigger than .debug_loc section size.\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
offset	long
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
vnext	pointer
&&	O
voffset	long
>=	O
bytes	long
)	O
{	O
warn	function
(	O
_	O
(	O
"View Offset 0x%lx is bigger than .debug_loc section size.\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
voffset	long
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
is_loclists	int
)	O
{	O
if	O
(	O
is_dwo	int
)	O
display_loc_list_dwo	function
(	O
section	pointer
,	O
&	O
start	pointer
,	O
i	pointer
,	O
offset	long
,	O
&	O
vstart	pointer
,	O
has_frame_base	int
)	O
;	O
else	O
display_loc_list	function
(	O
section	pointer
,	O
&	O
start	pointer
,	O
i	pointer
,	O
offset	long
,	O
base_address	long
,	O
&	O
vstart	pointer
,	O
has_frame_base	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
is_dwo	int
)	O
warn	function
(	O
_	O
(	O
"DWO is not yet supported.\n"	pointer
)	O
)	O
;	O
else	O
display_loclists_list	function
(	O
section	pointer
,	O
&	O
start	pointer
,	O
i	pointer
,	O
offset	long
,	O
base_address	long
,	O
&	O
vstart	pointer
,	O
has_frame_base	int
)	O
;	O
}	O
if	O
(	O
adjacent_view_loclists	int
&&	O
vnext	pointer
&&	O
vnext	pointer
!=	O
start	pointer
&&	O
vstart	pointer
!=	O
next	pointer
)	O
{	O
adjacent_view_loclists	int
=	O
0	int
;	O
warn	function
(	O
_	O
(	O
"Hole and overlap detection requires adjacent view lists and loclists.\n"	pointer
)	O
)	O
;	O
}	O
if	O
(	O
vnext	pointer
&&	O
vnext	pointer
==	O
start	pointer
)	O
display_view_pair_list	function
(	O
section	pointer
,	O
&	O
start	pointer
,	O
i	pointer
,	O
vstart	pointer
)	O
;	O
}	O
}	O
if	O
(	O
start	pointer
<	O
section	pointer
->	O
start	pointer
+	O
section	pointer
->	O
size	int
)	O
warn	function
(	O
ngettext	function
(	O
"There is %ld unused byte at the end of section %s\n"	pointer
,	O
"There are %ld unused bytes at the end of section %s\n"	pointer
,	O
(	O
long	O
)	O
(	O
section	pointer
->	O
start	pointer
+	O
section	pointer
->	O
size	int
-	O
start	pointer
)	O
)	O
,	O
(	O
long	O
)	O
(	O
section	pointer
->	O
start	pointer
+	O
section	pointer
->	O
size	int
-	O
start	pointer
)	O
,	O
section	pointer
->	O
name	pointer
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
free	function
(	O
array	pointer
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
display_debug_str	function
(	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
void	O
*	O
file	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
unsigned	O
char	O
*	O
start	pointer
=	O
section	pointer
->	O
start	pointer
;	O
unsigned	O
long	O
bytes	long
=	O
section	pointer
->	O
size	int
;	O
dwarf_vma	long
addr	pointer
=	O
section	pointer
->	O
address	long
;	O
if	O
(	O
bytes	long
==	O
0	int
)	O
{	O
printf	function
(	O
_	O
(	O
"\nThe %s section is empty.\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
introduce	function
(	O
section	pointer
,	O
FALSE	int
)	O
;	O
while	O
(	O
bytes	long
)	O
{	O
int	O
j	int
;	O
int	O
k	int
;	O
int	O
lbytes	int
;	O
lbytes	int
=	O
(	O
bytes	long
>	O
16	int
?	O
16	int
:	O
bytes	long
)	O
;	O
printf	function
(	O
"  0x%8.8lx "	pointer
,	O
(	O
unsigned	O
long	O
)	O
addr	pointer
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
16	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
j	int
<	O
lbytes	int
)	O
printf	function
(	O
"%2.2x"	pointer
,	O
start	pointer
[	O
j	int
]	O
)	O
;	O
else	O
printf	function
(	O
"  "	pointer
)	O
;	O
if	O
(	O
(	O
j	int
&	O
3	int
)	O
==	O
3	int
)	O
printf	function
(	O
" "	pointer
)	O
;	O
}	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
lbytes	int
;	O
j	int
++	O
)	O
{	O
k	int
=	O
start	pointer
[	O
j	int
]	O
;	O
if	O
(	O
k	int
>=	O
' '	O
&&	O
k	int
<	O
0x80	int
)	O
printf	function
(	O
"%c"	pointer
,	O
k	int
)	O
;	O
else	O
printf	function
(	O
"."	pointer
)	O
;	O
}	O
putchar	function
(	O
'\n'	O
)	O
;	O
start	pointer
+=	O
lbytes	int
;	O
addr	pointer
+=	O
lbytes	int
;	O
bytes	long
-=	O
lbytes	int
;	O
}	O
putchar	function
(	O
'\n'	O
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
display_debug_info	function
(	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
void	O
*	O
file	pointer
)	O
{	O
return	O
process_debug_info	function
(	O
section	pointer
,	O
file	pointer
,	O
section	pointer
->	O
abbrev_sec	enum
,	O
FALSE	int
,	O
FALSE	int
)	O
;	O
}	O
static	O
int	O
display_debug_types	function
(	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
void	O
*	O
file	pointer
)	O
{	O
return	O
process_debug_info	function
(	O
section	pointer
,	O
file	pointer
,	O
section	pointer
->	O
abbrev_sec	enum
,	O
FALSE	int
,	O
TRUE	int
)	O
;	O
}	O
static	O
int	O
display_trace_info	function
(	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
void	O
*	O
file	pointer
)	O
{	O
return	O
process_debug_info	function
(	O
section	pointer
,	O
file	pointer
,	O
section	pointer
->	O
abbrev_sec	enum
,	O
FALSE	int
,	O
TRUE	int
)	O
;	O
}	O
static	O
int	O
display_debug_aranges	function
(	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
void	O
*	O
file	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
unsigned	O
char	O
*	O
start	pointer
=	O
section	pointer
->	O
start	pointer
;	O
unsigned	O
char	O
*	O
end	pointer
=	O
start	pointer
+	O
section	pointer
->	O
size	int
;	O
introduce	function
(	O
section	pointer
,	O
FALSE	int
)	O
;	O
load_debug_info	function
(	O
file	pointer
)	O
;	O
while	O
(	O
start	pointer
<	O
end	pointer
)	O
{	O
unsigned	O
char	O
*	O
hdrptr	pointer
;	O
DWARF2_Internal_ARange	struct
arange	struct
;	O
unsigned	O
char	O
*	O
addr_ranges	pointer
;	O
dwarf_vma	long
length	long
;	O
dwarf_vma	long
address	long
;	O
unsigned	O
long	O
sec_off	long
;	O
unsigned	O
char	O
address_size	char
;	O
int	O
excess	int
;	O
unsigned	O
int	O
offset_size	int
;	O
unsigned	O
int	O
initial_length_size	int
;	O
hdrptr	pointer
=	O
start	pointer
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
arange	struct
.	O
ar_length	long
,	O
hdrptr	pointer
,	O
4	int
,	O
end	pointer
)	O
;	O
if	O
(	O
arange	struct
.	O
ar_length	long
==	O
0xffffffff	int
)	O
{	O
SAFE_BYTE_GET_AND_INC	O
(	O
arange	struct
.	O
ar_length	long
,	O
hdrptr	pointer
,	O
8	int
,	O
end	pointer
)	O
;	O
offset_size	int
=	O
8	int
;	O
initial_length_size	int
=	O
12	int
;	O
}	O
else	O
{	O
offset_size	int
=	O
4	int
;	O
initial_length_size	int
=	O
4	int
;	O
}	O
sec_off	long
=	O
hdrptr	pointer
-	O
section	pointer
->	O
start	pointer
;	O
if	O
(	O
sec_off	long
+	O
arange	struct
.	O
ar_length	long
<	O
sec_off	long
||	O
sec_off	long
+	O
arange	struct
.	O
ar_length	long
>	O
section	pointer
->	O
size	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Debug info is corrupted, %s header at %#lx has length %s\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
,	O
sec_off	long
-	O
initial_length_size	int
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
arange	struct
.	O
ar_length	long
)	O
)	O
;	O
break	O
;	O
}	O
SAFE_BYTE_GET_AND_INC	O
(	O
arange	struct
.	O
ar_version	short
,	O
hdrptr	pointer
,	O
2	int
,	O
end	pointer
)	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
arange	struct
.	O
ar_info_offset	long
,	O
hdrptr	pointer
,	O
offset_size	int
,	O
end	pointer
)	O
;	O
if	O
(	O
num_debug_info_entries	int
!=	O
DEBUG_INFO_UNAVAILABLE	O
&&	O
num_debug_info_entries	int
>	O
0	int
&&	O
find_debug_info_for_offset	function
(	O
arange	struct
.	O
ar_info_offset	long
)	O
==	O
NULL	O
)	O
warn	function
(	O
_	O
(	O
".debug_info offset of 0x%lx in %s section does not point to a CU header.\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
arange	struct
.	O
ar_info_offset	long
,	O
section	pointer
->	O
name	pointer
)	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
arange	struct
.	O
ar_pointer_size	char
,	O
hdrptr	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
arange	struct
.	O
ar_segment_size	char
,	O
hdrptr	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
if	O
(	O
arange	struct
.	O
ar_version	short
!=	O
2	int
&&	O
arange	struct
.	O
ar_version	short
!=	O
3	int
)	O
{	O
if	O
(	O
arange	struct
.	O
ar_version	short
)	O
warn	function
(	O
_	O
(	O
"Only DWARF 2 and 3 aranges are currently supported.\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
printf	function
(	O
_	O
(	O
"  Length:                   %ld\n"	pointer
)	O
,	O
(	O
long	O
)	O
arange	struct
.	O
ar_length	long
)	O
;	O
printf	function
(	O
_	O
(	O
"  Version:                  %d\n"	pointer
)	O
,	O
arange	struct
.	O
ar_version	short
)	O
;	O
printf	function
(	O
_	O
(	O
"  Offset into .debug_info:  0x%lx\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
arange	struct
.	O
ar_info_offset	long
)	O
;	O
printf	function
(	O
_	O
(	O
"  Pointer Size:             %d\n"	pointer
)	O
,	O
arange	struct
.	O
ar_pointer_size	char
)	O
;	O
printf	function
(	O
_	O
(	O
"  Segment Size:             %d\n"	pointer
)	O
,	O
arange	struct
.	O
ar_segment_size	char
)	O
;	O
address_size	char
=	O
arange	struct
.	O
ar_pointer_size	char
+	O
arange	struct
.	O
ar_segment_size	char
;	O
if	O
(	O
address_size	char
==	O
0	int
||	O
address_size	char
>	O
8	int
)	O
{	O
error	function
(	O
_	O
(	O
"Invalid address size in %s section!\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
(	O
address_size	char
&	O
(	O
address_size	char
-	O
1	int
)	O
)	O
!=	O
0	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Pointer size + Segment size is not a power of two.\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
address_size	char
>	O
4	int
)	O
printf	function
(	O
_	O
(	O
"\n    Address            Length\n"	pointer
)	O
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"\n    Address    Length\n"	pointer
)	O
)	O
;	O
addr_ranges	pointer
=	O
hdrptr	pointer
;	O
excess	int
=	O
(	O
hdrptr	pointer
-	O
start	pointer
)	O
%	O
(	O
2	int
*	O
address_size	char
)	O
;	O
if	O
(	O
excess	int
)	O
addr_ranges	pointer
+=	O
(	O
2	int
*	O
address_size	char
)	O
-	O
excess	int
;	O
start	pointer
+=	O
arange	struct
.	O
ar_length	long
+	O
initial_length_size	int
;	O
while	O
(	O
addr_ranges	pointer
+	O
2	int
*	O
address_size	char
<=	O
start	pointer
)	O
{	O
SAFE_BYTE_GET_AND_INC	O
(	O
address	long
,	O
addr_ranges	pointer
,	O
address_size	char
,	O
end	pointer
)	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
length	long
,	O
addr_ranges	pointer
,	O
address_size	char
,	O
end	pointer
)	O
;	O
printf	function
(	O
"    "	pointer
)	O
;	O
print_dwarf_vma	function
(	O
address	long
,	O
address_size	char
)	O
;	O
print_dwarf_vma	function
(	O
length	long
,	O
address_size	char
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
comp_addr_base	function
(	O
const	O
void	O
*	O
v0	pointer
,	O
const	O
void	O
*	O
v1	pointer
)	O
{	O
debug_info	struct
*	O
info0	pointer
=	O
*	O
(	O
debug_info	struct
*	O
*	O
)	O
v0	pointer
;	O
debug_info	struct
*	O
info1	pointer
=	O
*	O
(	O
debug_info	struct
*	O
*	O
)	O
v1	pointer
;	O
return	O
info0	pointer
->	O
addr_base	long
-	O
info1	pointer
->	O
addr_base	long
;	O
}	O
static	O
int	O
display_debug_addr	function
(	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
void	O
*	O
file	pointer
)	O
{	O
debug_info	struct
*	O
*	O
debug_addr_info	pointer
;	O
unsigned	O
char	O
*	O
entry	long
;	O
unsigned	O
char	O
*	O
end	pointer
;	O
unsigned	O
int	O
i	pointer
;	O
unsigned	O
int	O
count	int
;	O
if	O
(	O
section	pointer
->	O
size	int
==	O
0	int
)	O
{	O
printf	function
(	O
_	O
(	O
"\nThe %s section is empty.\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
load_debug_info	function
(	O
file	pointer
)	O
==	O
0	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Unable to load/parse the .debug_info section, so cannot interpret the %s section.\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
introduce	function
(	O
section	pointer
,	O
FALSE	int
)	O
;	O
debug_addr_info	pointer
=	O
(	O
debug_info	struct
*	O
*	O
)	O
xcalloc	function
(	O
(	O
num_debug_info_entries	int
+	O
1	int
)	O
,	O
sizeof	O
(	O
debug_info	struct
*	O
)	O
)	O
;	O
count	int
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
num_debug_info_entries	int
;	O
i	pointer
++	O
)	O
if	O
(	O
debug_information	pointer
[	O
i	pointer
]	O
.	O
addr_base	long
!=	O
DEBUG_INFO_UNAVAILABLE	O
)	O
{	O
if	O
(	O
debug_information	pointer
[	O
i	pointer
]	O
.	O
addr_base	long
>=	O
section	pointer
->	O
size	int
)	O
warn	function
(	O
_	O
(	O
"Corrupt address base (%lx) found in debug section %u\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
debug_information	pointer
[	O
i	pointer
]	O
.	O
addr_base	long
,	O
i	pointer
)	O
;	O
else	O
debug_addr_info	pointer
[	O
count	int
++	O
]	O
=	O
debug_information	pointer
+	O
i	pointer
;	O
}	O
debug_addr_info	pointer
[	O
count	int
]	O
=	O
(	O
debug_info	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
debug_info	struct
)	O
)	O
;	O
debug_addr_info	pointer
[	O
count	int
]	O
->	O
addr_base	long
=	O
section	pointer
->	O
size	int
;	O
qsort	function
(	O
debug_addr_info	pointer
,	O
count	int
,	O
sizeof	O
(	O
debug_info	struct
*	O
)	O
,	O
comp_addr_base	function
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
count	int
;	O
i	pointer
++	O
)	O
{	O
unsigned	O
int	O
idx	int
;	O
unsigned	O
int	O
address_size	char
=	O
debug_addr_info	pointer
[	O
i	pointer
]	O
->	O
pointer_size	int
;	O
printf	function
(	O
_	O
(	O
"  For compilation unit at offset 0x%s:\n"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
debug_addr_info	pointer
[	O
i	pointer
]	O
->	O
cu_offset	long
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"\tIndex\tAddress\n"	pointer
)	O
)	O
;	O
entry	long
=	O
section	pointer
->	O
start	pointer
+	O
debug_addr_info	pointer
[	O
i	pointer
]	O
->	O
addr_base	long
;	O
end	pointer
=	O
section	pointer
->	O
start	pointer
+	O
debug_addr_info	pointer
[	O
i	pointer
+	O
1	int
]	O
->	O
addr_base	long
;	O
idx	int
=	O
0	int
;	O
while	O
(	O
entry	long
<	O
end	pointer
)	O
{	O
dwarf_vma	long
base	int
=	O
byte_get	pointer
(	O
entry	long
,	O
address_size	char
)	O
;	O
printf	function
(	O
_	O
(	O
"\t%d:\t"	pointer
)	O
,	O
idx	int
)	O
;	O
print_dwarf_vma	function
(	O
base	int
,	O
address_size	char
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
entry	long
+=	O
address_size	char
;	O
idx	int
++	O
;	O
}	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
free	function
(	O
debug_addr_info	pointer
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
display_debug_str_offsets	function
(	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
void	O
*	O
file	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
if	O
(	O
section	pointer
->	O
size	int
==	O
0	int
)	O
{	O
printf	function
(	O
_	O
(	O
"\nThe %s section is empty.\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
struct	O
range_entry	struct
{	O
dwarf_vma	long
ranges_offset	long
;	O
debug_info	struct
*	O
debug_info_p	pointer
;	O
}	O
;	O
static	O
int	O
range_entry_compar	function
(	O
const	O
void	O
*	O
ap	pointer
,	O
const	O
void	O
*	O
bp	pointer
)	O
{	O
const	O
struct	O
range_entry	struct
*	O
a_re	pointer
=	O
(	O
const	O
struct	O
range_entry	struct
*	O
)	O
ap	pointer
;	O
const	O
struct	O
range_entry	struct
*	O
b_re	pointer
=	O
(	O
const	O
struct	O
range_entry	struct
*	O
)	O
bp	pointer
;	O
const	O
dwarf_vma	long
a	pointer
=	O
a_re	pointer
->	O
ranges_offset	long
;	O
const	O
dwarf_vma	long
b	pointer
=	O
b_re	pointer
->	O
ranges_offset	long
;	O
return	O
(	O
a	pointer
>	O
b	pointer
)	O
-	O
(	O
b	pointer
>	O
a	pointer
)	O
;	O
}	O
static	O
void	O
display_debug_ranges_list	function
(	O
unsigned	O
char	O
*	O
start	pointer
,	O
unsigned	O
char	O
*	O
finish	pointer
,	O
unsigned	O
int	O
pointer_size	int
,	O
unsigned	O
long	O
offset	long
,	O
unsigned	O
long	O
base_address	long
)	O
{	O
while	O
(	O
start	pointer
<	O
finish	pointer
)	O
{	O
dwarf_vma	long
begin	long
;	O
dwarf_vma	long
end	pointer
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
begin	long
,	O
start	pointer
,	O
pointer_size	int
,	O
finish	pointer
)	O
;	O
if	O
(	O
start	pointer
>=	O
finish	pointer
)	O
break	O
;	O
SAFE_SIGNED_BYTE_GET_AND_INC	O
(	O
end	pointer
,	O
start	pointer
,	O
pointer_size	int
,	O
finish	pointer
)	O
;	O
printf	function
(	O
"    %8.8lx "	pointer
,	O
offset	long
)	O
;	O
if	O
(	O
begin	long
==	O
0	int
&&	O
end	pointer
==	O
0	int
)	O
{	O
printf	function
(	O
_	O
(	O
"<End of list>\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
is_max_address	function
(	O
begin	long
,	O
pointer_size	int
)	O
&&	O
!	O
is_max_address	function
(	O
end	pointer
,	O
pointer_size	int
)	O
)	O
{	O
base_address	long
=	O
end	pointer
;	O
print_dwarf_vma	function
(	O
begin	long
,	O
pointer_size	int
)	O
;	O
print_dwarf_vma	function
(	O
end	pointer
,	O
pointer_size	int
)	O
;	O
printf	function
(	O
"(base address)\n"	pointer
)	O
;	O
continue	O
;	O
}	O
print_dwarf_vma	function
(	O
begin	long
+	O
base_address	long
,	O
pointer_size	int
)	O
;	O
print_dwarf_vma	function
(	O
end	pointer
+	O
base_address	long
,	O
pointer_size	int
)	O
;	O
if	O
(	O
begin	long
==	O
end	pointer
)	O
fputs	function
(	O
_	O
(	O
"(start == end)"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
else	O
if	O
(	O
begin	long
>	O
end	pointer
)	O
fputs	function
(	O
_	O
(	O
"(start > end)"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
}	O
static	O
void	O
display_debug_rnglists_list	function
(	O
unsigned	O
char	O
*	O
start	pointer
,	O
unsigned	O
char	O
*	O
finish	pointer
,	O
unsigned	O
int	O
pointer_size	int
,	O
unsigned	O
long	O
offset	long
,	O
unsigned	O
long	O
base_address	long
)	O
{	O
unsigned	O
char	O
*	O
next	pointer
=	O
start	pointer
;	O
while	O
(	O
1	int
)	O
{	O
unsigned	O
long	O
off	long
=	O
offset	long
+	O
(	O
start	pointer
-	O
next	pointer
)	O
;	O
enum	O
dwarf_range_list_entry	enum
rlet	enum
;	O
dwarf_vma	long
begin	long
=	O
-	O
1	int
,	O
length	long
,	O
end	pointer
=	O
-	O
1	int
;	O
if	O
(	O
start	pointer
+	O
1	int
>	O
finish	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"Range list starting at offset 0x%lx is not terminated.\n"	pointer
)	O
,	O
offset	long
)	O
;	O
break	O
;	O
}	O
printf	function
(	O
"    %8.8lx "	pointer
,	O
off	long
)	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
rlet	enum
,	O
start	pointer
,	O
1	int
,	O
finish	pointer
)	O
;	O
switch	O
(	O
rlet	enum
)	O
{	O
case	O
DW_RLE_end_of_list	int
:	O
printf	function
(	O
_	O
(	O
"<End of list>\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
DW_RLE_base_address	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
base_address	long
,	O
start	pointer
,	O
pointer_size	int
,	O
finish	pointer
)	O
;	O
print_dwarf_vma	function
(	O
base_address	long
,	O
pointer_size	int
)	O
;	O
printf	function
(	O
_	O
(	O
"(base address)\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
DW_RLE_start_length	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
begin	long
,	O
start	pointer
,	O
pointer_size	int
,	O
finish	pointer
)	O
;	O
READ_ULEB	O
(	O
length	long
,	O
start	pointer
,	O
finish	pointer
)	O
;	O
end	pointer
=	O
begin	long
+	O
length	long
;	O
break	O
;	O
case	O
DW_RLE_offset_pair	int
:	O
READ_ULEB	O
(	O
begin	long
,	O
start	pointer
,	O
finish	pointer
)	O
;	O
READ_ULEB	O
(	O
end	pointer
,	O
start	pointer
,	O
finish	pointer
)	O
;	O
break	O
;	O
case	O
DW_RLE_start_end	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
begin	long
,	O
start	pointer
,	O
pointer_size	int
,	O
finish	pointer
)	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
end	pointer
,	O
start	pointer
,	O
pointer_size	int
,	O
finish	pointer
)	O
;	O
break	O
;	O
default	O
:	O
error	function
(	O
_	O
(	O
"Invalid range list entry type %d\n"	pointer
)	O
,	O
rlet	enum
)	O
;	O
rlet	enum
=	O
DW_RLE_end_of_list	int
;	O
break	O
;	O
}	O
if	O
(	O
rlet	enum
==	O
DW_RLE_end_of_list	int
)	O
break	O
;	O
if	O
(	O
rlet	enum
==	O
DW_RLE_base_address	int
)	O
continue	O
;	O
print_dwarf_vma	function
(	O
begin	long
+	O
base_address	long
,	O
pointer_size	int
)	O
;	O
print_dwarf_vma	function
(	O
end	pointer
+	O
base_address	long
,	O
pointer_size	int
)	O
;	O
if	O
(	O
begin	long
==	O
end	pointer
)	O
fputs	function
(	O
_	O
(	O
"(start == end)"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
else	O
if	O
(	O
begin	long
>	O
end	pointer
)	O
fputs	function
(	O
_	O
(	O
"(start > end)"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
}	O
static	O
int	O
display_debug_ranges	function
(	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
void	O
*	O
file	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
unsigned	O
char	O
*	O
start	pointer
=	O
section	pointer
->	O
start	pointer
;	O
unsigned	O
char	O
*	O
last_start	pointer
=	O
start	pointer
;	O
unsigned	O
long	O
bytes	long
=	O
section	pointer
->	O
size	int
;	O
unsigned	O
char	O
*	O
section_begin	pointer
=	O
start	pointer
;	O
unsigned	O
char	O
*	O
finish	pointer
=	O
start	pointer
+	O
bytes	long
;	O
unsigned	O
int	O
num_range_list	int
,	O
i	pointer
;	O
struct	O
range_entry	struct
*	O
range_entries	pointer
,	O
*	O
range_entry_fill	pointer
;	O
int	O
is_rnglists	int
=	O
strstr	function
(	O
section	pointer
->	O
name	pointer
,	O
"debug_rnglists"	pointer
)	O
!=	O
NULL	O
;	O
unsigned	O
char	O
address_size	char
=	O
0	int
;	O
if	O
(	O
bytes	long
==	O
0	int
)	O
{	O
printf	function
(	O
_	O
(	O
"\nThe %s section is empty.\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
is_rnglists	int
)	O
{	O
dwarf_vma	long
initial_length	long
;	O
unsigned	O
int	O
initial_length_size	int
;	O
unsigned	O
char	O
segment_selector_size	char
;	O
unsigned	O
int	O
offset_size	int
,	O
offset_entry_count	int
;	O
unsigned	O
short	O
version	int
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
initial_length	long
,	O
start	pointer
,	O
4	int
,	O
finish	pointer
)	O
;	O
if	O
(	O
initial_length	long
==	O
0xffffffff	int
)	O
{	O
SAFE_BYTE_GET_AND_INC	O
(	O
initial_length	long
,	O
start	pointer
,	O
8	int
,	O
finish	pointer
)	O
;	O
offset_size	int
=	O
8	int
;	O
initial_length_size	int
=	O
12	int
;	O
}	O
else	O
{	O
offset_size	int
=	O
4	int
;	O
initial_length_size	int
=	O
4	int
;	O
}	O
if	O
(	O
initial_length	long
+	O
initial_length_size	int
>	O
section	pointer
->	O
size	int
)	O
{	O
if	O
(	O
reloc_at	function
(	O
section	pointer
,	O
(	O
start	pointer
-	O
section	pointer
->	O
start	pointer
)	O
-	O
offset_size	int
)	O
)	O
{	O
initial_length	long
=	O
(	O
finish	pointer
-	O
start	pointer
)	O
-	O
initial_length_size	int
;	O
}	O
else	O
{	O
warn	function
(	O
_	O
(	O
"The length field (0x%lx) in the debug_rnglists header is wrong - the section is too small\n"	pointer
)	O
,	O
(	O
long	O
)	O
initial_length	long
)	O
;	O
return	O
0	int
;	O
}	O
}	O
SAFE_BYTE_GET_AND_INC	O
(	O
version	int
,	O
start	pointer
,	O
2	int
,	O
finish	pointer
)	O
;	O
if	O
(	O
version	int
!=	O
5	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Only DWARF version 5 debug_rnglists info "	pointer
"is currently supported.\n"	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
SAFE_BYTE_GET_AND_INC	O
(	O
address_size	char
,	O
start	pointer
,	O
1	int
,	O
finish	pointer
)	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
segment_selector_size	char
,	O
start	pointer
,	O
1	int
,	O
finish	pointer
)	O
;	O
if	O
(	O
segment_selector_size	char
!=	O
0	int
)	O
{	O
warn	function
(	O
_	O
(	O
"The %s section contains "	pointer
"unsupported segment selector size: %d.\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
,	O
segment_selector_size	char
)	O
;	O
return	O
0	int
;	O
}	O
SAFE_BYTE_GET_AND_INC	O
(	O
offset_entry_count	int
,	O
start	pointer
,	O
4	int
,	O
finish	pointer
)	O
;	O
if	O
(	O
offset_entry_count	int
!=	O
0	int
)	O
{	O
warn	function
(	O
_	O
(	O
"The %s section contains "	pointer
"unsupported offset entry count: %u.\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
,	O
offset_entry_count	int
)	O
;	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
load_debug_info	function
(	O
file	pointer
)	O
==	O
0	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Unable to load/parse the .debug_info section, so cannot interpret the %s section.\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
num_range_list	int
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
num_debug_info_entries	int
;	O
i	pointer
++	O
)	O
num_range_list	int
+=	O
debug_information	pointer
[	O
i	pointer
]	O
.	O
num_range_lists	int
;	O
if	O
(	O
num_range_list	int
==	O
0	int
)	O
{	O
printf	function
(	O
_	O
(	O
"No range lists in .debug_info section.\n"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
range_entries	pointer
=	O
(	O
struct	O
range_entry	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
*	O
range_entries	pointer
)	O
*	O
num_range_list	int
)	O
;	O
range_entry_fill	pointer
=	O
range_entries	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
num_debug_info_entries	int
;	O
i	pointer
++	O
)	O
{	O
debug_info	struct
*	O
debug_info_p	pointer
=	O
&	O
debug_information	pointer
[	O
i	pointer
]	O
;	O
unsigned	O
int	O
j	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
debug_info_p	pointer
->	O
num_range_lists	int
;	O
j	int
++	O
)	O
{	O
range_entry_fill	pointer
->	O
ranges_offset	long
=	O
debug_info_p	pointer
->	O
range_lists	pointer
[	O
j	int
]	O
;	O
range_entry_fill	pointer
->	O
debug_info_p	pointer
=	O
debug_info_p	pointer
;	O
range_entry_fill	pointer
++	O
;	O
}	O
}	O
qsort	function
(	O
range_entries	pointer
,	O
num_range_list	int
,	O
sizeof	O
(	O
*	O
range_entries	pointer
)	O
,	O
range_entry_compar	function
)	O
;	O
if	O
(	O
dwarf_check	int
!=	O
0	int
&&	O
range_entries	pointer
[	O
0	int
]	O
.	O
ranges_offset	long
!=	O
0	int
)	O
warn	function
(	O
_	O
(	O
"Range lists in %s section start at 0x%lx\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
,	O
(	O
unsigned	O
long	O
)	O
range_entries	pointer
[	O
0	int
]	O
.	O
ranges_offset	long
)	O
;	O
introduce	function
(	O
section	pointer
,	O
FALSE	int
)	O
;	O
printf	function
(	O
_	O
(	O
"    Offset   Begin    End\n"	pointer
)	O
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
num_range_list	int
;	O
i	pointer
++	O
)	O
{	O
struct	O
range_entry	struct
*	O
range_entry	struct
=	O
&	O
range_entries	pointer
[	O
i	pointer
]	O
;	O
debug_info	struct
*	O
debug_info_p	pointer
=	O
range_entry	struct
->	O
debug_info_p	pointer
;	O
unsigned	O
int	O
pointer_size	int
;	O
dwarf_vma	long
offset	long
;	O
unsigned	O
char	O
*	O
next	pointer
;	O
dwarf_vma	long
base_address	long
;	O
pointer_size	int
=	O
(	O
is_rnglists	int
?	O
address_size	char
:	O
debug_info_p	pointer
->	O
pointer_size	int
)	O
;	O
offset	long
=	O
range_entry	struct
->	O
ranges_offset	long
;	O
next	pointer
=	O
section_begin	pointer
+	O
offset	long
;	O
base_address	long
=	O
debug_info_p	pointer
->	O
base_address	long
;	O
if	O
(	O
pointer_size	int
<	O
2	int
||	O
pointer_size	int
>	O
8	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Corrupt pointer size (%d) in debug entry at offset %8.8lx\n"	pointer
)	O
,	O
pointer_size	int
,	O
(	O
unsigned	O
long	O
)	O
offset	long
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
next	pointer
<	O
section_begin	pointer
||	O
next	pointer
>=	O
finish	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"Corrupt offset (%#8.8lx) in range entry %u\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
offset	long
,	O
i	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
dwarf_check	int
!=	O
0	int
&&	O
i	pointer
>	O
0	int
)	O
{	O
if	O
(	O
start	pointer
<	O
next	pointer
)	O
warn	function
(	O
_	O
(	O
"There is a hole [0x%lx - 0x%lx] in %s section.\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
(	O
start	pointer
-	O
section_begin	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
(	O
next	pointer
-	O
section_begin	pointer
)	O
,	O
section	pointer
->	O
name	pointer
)	O
;	O
else	O
if	O
(	O
start	pointer
>	O
next	pointer
)	O
{	O
if	O
(	O
next	pointer
==	O
last_start	pointer
)	O
continue	O
;	O
warn	function
(	O
_	O
(	O
"There is an overlap [0x%lx - 0x%lx] in %s section.\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
(	O
start	pointer
-	O
section_begin	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
(	O
next	pointer
-	O
section_begin	pointer
)	O
,	O
section	pointer
->	O
name	pointer
)	O
;	O
}	O
}	O
start	pointer
=	O
next	pointer
;	O
last_start	pointer
=	O
next	pointer
;	O
(	O
is_rnglists	int
?	O
display_debug_rnglists_list	function
:	O
display_debug_ranges_list	function
)	O
(	O
start	pointer
,	O
finish	pointer
,	O
pointer_size	int
,	O
offset	long
,	O
base_address	long
)	O
;	O
}	O
putchar	function
(	O
'\n'	O
)	O
;	O
free	function
(	O
range_entries	pointer
)	O
;	O
return	O
1	int
;	O
}	O
typedef	O
struct	O
Frame_Chunk	struct
{	O
struct	O
Frame_Chunk	struct
*	O
next	pointer
;	O
unsigned	O
char	O
*	O
chunk_start	pointer
;	O
unsigned	O
int	O
ncols	int
;	O
short	O
int	O
*	O
col_type	pointer
;	O
int	O
*	O
col_offset	pointer
;	O
char	O
*	O
augmentation	pointer
;	O
unsigned	O
int	O
code_factor	int
;	O
int	O
data_factor	int
;	O
dwarf_vma	long
pc_begin	long
;	O
dwarf_vma	long
pc_range	long
;	O
unsigned	O
int	O
cfa_reg	int
;	O
dwarf_vma	long
cfa_offset	long
;	O
unsigned	O
int	O
ra	int
;	O
unsigned	O
char	O
fde_encoding	char
;	O
unsigned	O
char	O
cfa_exp	char
;	O
unsigned	O
char	O
ptr_size	pointer
;	O
unsigned	O
char	O
segment_size	char
;	O
}	O
Frame_Chunk	struct
;	O
typedef	O
const	O
char	O
*	O
(	O
*	O
dwarf_regname_lookup_ftype	pointer
)	O
(	O
unsigned	O
int	O
)	O
;	O
static	O
dwarf_regname_lookup_ftype	pointer
dwarf_regnames_lookup_func	pointer
;	O
static	O
const	O
char	O
*	O
const	O
*	O
dwarf_regnames	pointer
;	O
static	O
unsigned	O
int	O
dwarf_regnames_count	int
;	O
static	O
int	O
frame_need_space	function
(	O
Frame_Chunk	struct
*	O
fc	pointer
,	O
unsigned	O
int	O
reg	int
)	O
{	O
unsigned	O
int	O
prev	pointer
=	O
fc	pointer
->	O
ncols	int
;	O
if	O
(	O
reg	int
<	O
(	O
unsigned	O
int	O
)	O
fc	pointer
->	O
ncols	int
)	O
return	O
0	int
;	O
if	O
(	O
dwarf_regnames_count	int
>	O
0	int
&&	O
reg	int
>	O
dwarf_regnames_count	int
)	O
return	O
-	O
1	int
;	O
fc	pointer
->	O
ncols	int
=	O
reg	int
+	O
1	int
;	O
if	O
(	O
fc	pointer
->	O
ncols	int
==	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
fc	pointer
->	O
ncols	int
>	O
1024	int
&&	O
dwarf_regnames_count	int
==	O
0	int
)	O
{	O
error	function
(	O
_	O
(	O
"Unfeasibly large register number: %u\n"	pointer
)	O
,	O
reg	int
)	O
;	O
fc	pointer
->	O
ncols	int
=	O
0	int
;	O
return	O
-	O
1	int
;	O
}	O
fc	pointer
->	O
col_type	pointer
=	O
(	O
short	O
int	O
*	O
)	O
xcrealloc	function
(	O
fc	pointer
->	O
col_type	pointer
,	O
fc	pointer
->	O
ncols	int
,	O
sizeof	O
(	O
short	O
int	O
)	O
)	O
;	O
fc	pointer
->	O
col_offset	pointer
=	O
(	O
int	O
*	O
)	O
xcrealloc	function
(	O
fc	pointer
->	O
col_offset	pointer
,	O
fc	pointer
->	O
ncols	int
,	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
if	O
(	O
fc	pointer
->	O
col_type	pointer
==	O
NULL	O
||	O
fc	pointer
->	O
col_offset	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Out of memory allocating %u columns in dwarf frame arrays\n"	pointer
)	O
,	O
fc	pointer
->	O
ncols	int
)	O
;	O
fc	pointer
->	O
ncols	int
=	O
0	int
;	O
return	O
-	O
1	int
;	O
}	O
while	O
(	O
prev	pointer
<	O
fc	pointer
->	O
ncols	int
)	O
{	O
fc	pointer
->	O
col_type	pointer
[	O
prev	pointer
]	O
=	O
DW_CFA_unreferenced	O
;	O
fc	pointer
->	O
col_offset	pointer
[	O
prev	pointer
]	O
=	O
0	int
;	O
prev	pointer
++	O
;	O
}	O
return	O
1	int
;	O
}	O
static	O
const	O
char	O
*	O
const	O
dwarf_regnames_i386	array
[	O
]	O
=	O
{	O
"eax"	pointer
,	O
"ecx"	pointer
,	O
"edx"	pointer
,	O
"ebx"	pointer
,	O
"esp"	pointer
,	O
"ebp"	pointer
,	O
"esi"	pointer
,	O
"edi"	pointer
,	O
"eip"	pointer
,	O
"eflags"	pointer
,	O
NULL	O
,	O
"st0"	pointer
,	O
"st1"	pointer
,	O
"st2"	pointer
,	O
"st3"	pointer
,	O
"st4"	pointer
,	O
"st5"	pointer
,	O
"st6"	pointer
,	O
"st7"	pointer
,	O
NULL	O
,	O
NULL	O
,	O
"xmm0"	pointer
,	O
"xmm1"	pointer
,	O
"xmm2"	pointer
,	O
"xmm3"	pointer
,	O
"xmm4"	pointer
,	O
"xmm5"	pointer
,	O
"xmm6"	pointer
,	O
"xmm7"	pointer
,	O
"mm0"	pointer
,	O
"mm1"	pointer
,	O
"mm2"	pointer
,	O
"mm3"	pointer
,	O
"mm4"	pointer
,	O
"mm5"	pointer
,	O
"mm6"	pointer
,	O
"mm7"	pointer
,	O
"fcw"	pointer
,	O
"fsw"	pointer
,	O
"mxcsr"	pointer
,	O
"es"	pointer
,	O
"cs"	pointer
,	O
"ss"	pointer
,	O
"ds"	pointer
,	O
"fs"	pointer
,	O
"gs"	pointer
,	O
NULL	O
,	O
NULL	O
,	O
"tr"	pointer
,	O
"ldtr"	pointer
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
"k0"	pointer
,	O
"k1"	pointer
,	O
"k2"	pointer
,	O
"k3"	pointer
,	O
"k4"	pointer
,	O
"k5"	pointer
,	O
"k6"	pointer
,	O
"k7"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
const	O
dwarf_regnames_iamcu	array
[	O
]	O
=	O
{	O
"eax"	pointer
,	O
"ecx"	pointer
,	O
"edx"	pointer
,	O
"ebx"	pointer
,	O
"esp"	pointer
,	O
"ebp"	pointer
,	O
"esi"	pointer
,	O
"edi"	pointer
,	O
"eip"	pointer
,	O
"eflags"	pointer
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
"es"	pointer
,	O
"cs"	pointer
,	O
"ss"	pointer
,	O
"ds"	pointer
,	O
"fs"	pointer
,	O
"gs"	pointer
,	O
NULL	O
,	O
NULL	O
,	O
"tr"	pointer
,	O
"ldtr"	pointer
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
;	O
static	O
void	O
init_dwarf_regnames_i386	function
(	O
void	O
)	O
{	O
dwarf_regnames	pointer
=	O
dwarf_regnames_i386	array
;	O
dwarf_regnames_count	int
=	O
ARRAY_SIZE	O
(	O
dwarf_regnames_i386	array
)	O
;	O
dwarf_regnames_lookup_func	pointer
=	O
regname_internal_by_table_only	function
;	O
}	O
static	O
void	O
init_dwarf_regnames_iamcu	function
(	O
void	O
)	O
{	O
dwarf_regnames	pointer
=	O
dwarf_regnames_iamcu	array
;	O
dwarf_regnames_count	int
=	O
ARRAY_SIZE	O
(	O
dwarf_regnames_iamcu	array
)	O
;	O
dwarf_regnames_lookup_func	pointer
=	O
regname_internal_by_table_only	function
;	O
}	O
static	O
const	O
char	O
*	O
const	O
dwarf_regnames_x86_64	array
[	O
]	O
=	O
{	O
"rax"	pointer
,	O
"rdx"	pointer
,	O
"rcx"	pointer
,	O
"rbx"	pointer
,	O
"rsi"	pointer
,	O
"rdi"	pointer
,	O
"rbp"	pointer
,	O
"rsp"	pointer
,	O
"r8"	pointer
,	O
"r9"	pointer
,	O
"r10"	pointer
,	O
"r11"	pointer
,	O
"r12"	pointer
,	O
"r13"	pointer
,	O
"r14"	pointer
,	O
"r15"	pointer
,	O
"rip"	pointer
,	O
"xmm0"	pointer
,	O
"xmm1"	pointer
,	O
"xmm2"	pointer
,	O
"xmm3"	pointer
,	O
"xmm4"	pointer
,	O
"xmm5"	pointer
,	O
"xmm6"	pointer
,	O
"xmm7"	pointer
,	O
"xmm8"	pointer
,	O
"xmm9"	pointer
,	O
"xmm10"	pointer
,	O
"xmm11"	pointer
,	O
"xmm12"	pointer
,	O
"xmm13"	pointer
,	O
"xmm14"	pointer
,	O
"xmm15"	pointer
,	O
"st0"	pointer
,	O
"st1"	pointer
,	O
"st2"	pointer
,	O
"st3"	pointer
,	O
"st4"	pointer
,	O
"st5"	pointer
,	O
"st6"	pointer
,	O
"st7"	pointer
,	O
"mm0"	pointer
,	O
"mm1"	pointer
,	O
"mm2"	pointer
,	O
"mm3"	pointer
,	O
"mm4"	pointer
,	O
"mm5"	pointer
,	O
"mm6"	pointer
,	O
"mm7"	pointer
,	O
"rflags"	pointer
,	O
"es"	pointer
,	O
"cs"	pointer
,	O
"ss"	pointer
,	O
"ds"	pointer
,	O
"fs"	pointer
,	O
"gs"	pointer
,	O
NULL	O
,	O
NULL	O
,	O
"fs.base"	pointer
,	O
"gs.base"	pointer
,	O
NULL	O
,	O
NULL	O
,	O
"tr"	pointer
,	O
"ldtr"	pointer
,	O
"mxcsr"	pointer
,	O
"fcw"	pointer
,	O
"fsw"	pointer
,	O
"xmm16"	pointer
,	O
"xmm17"	pointer
,	O
"xmm18"	pointer
,	O
"xmm19"	pointer
,	O
"xmm20"	pointer
,	O
"xmm21"	pointer
,	O
"xmm22"	pointer
,	O
"xmm23"	pointer
,	O
"xmm24"	pointer
,	O
"xmm25"	pointer
,	O
"xmm26"	pointer
,	O
"xmm27"	pointer
,	O
"xmm28"	pointer
,	O
"xmm29"	pointer
,	O
"xmm30"	pointer
,	O
"xmm31"	pointer
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
"k0"	pointer
,	O
"k1"	pointer
,	O
"k2"	pointer
,	O
"k3"	pointer
,	O
"k4"	pointer
,	O
"k5"	pointer
,	O
"k6"	pointer
,	O
"k7"	pointer
}	O
;	O
static	O
void	O
init_dwarf_regnames_x86_64	function
(	O
void	O
)	O
{	O
dwarf_regnames	pointer
=	O
dwarf_regnames_x86_64	array
;	O
dwarf_regnames_count	int
=	O
ARRAY_SIZE	O
(	O
dwarf_regnames_x86_64	array
)	O
;	O
dwarf_regnames_lookup_func	pointer
=	O
regname_internal_by_table_only	function
;	O
}	O
static	O
const	O
char	O
*	O
const	O
dwarf_regnames_aarch64	array
[	O
]	O
=	O
{	O
"x0"	pointer
,	O
"x1"	pointer
,	O
"x2"	pointer
,	O
"x3"	pointer
,	O
"x4"	pointer
,	O
"x5"	pointer
,	O
"x6"	pointer
,	O
"x7"	pointer
,	O
"x8"	pointer
,	O
"x9"	pointer
,	O
"x10"	pointer
,	O
"x11"	pointer
,	O
"x12"	pointer
,	O
"x13"	pointer
,	O
"x14"	pointer
,	O
"x15"	pointer
,	O
"x16"	pointer
,	O
"x17"	pointer
,	O
"x18"	pointer
,	O
"x19"	pointer
,	O
"x20"	pointer
,	O
"x21"	pointer
,	O
"x22"	pointer
,	O
"x23"	pointer
,	O
"x24"	pointer
,	O
"x25"	pointer
,	O
"x26"	pointer
,	O
"x27"	pointer
,	O
"x28"	pointer
,	O
"x29"	pointer
,	O
"x30"	pointer
,	O
"sp"	pointer
,	O
NULL	O
,	O
"elr"	pointer
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
"vg"	pointer
,	O
"ffr"	pointer
,	O
"p0"	pointer
,	O
"p1"	pointer
,	O
"p2"	pointer
,	O
"p3"	pointer
,	O
"p4"	pointer
,	O
"p5"	pointer
,	O
"p6"	pointer
,	O
"p7"	pointer
,	O
"p8"	pointer
,	O
"p9"	pointer
,	O
"p10"	pointer
,	O
"p11"	pointer
,	O
"p12"	pointer
,	O
"p13"	pointer
,	O
"p14"	pointer
,	O
"p15"	pointer
,	O
"v0"	pointer
,	O
"v1"	pointer
,	O
"v2"	pointer
,	O
"v3"	pointer
,	O
"v4"	pointer
,	O
"v5"	pointer
,	O
"v6"	pointer
,	O
"v7"	pointer
,	O
"v8"	pointer
,	O
"v9"	pointer
,	O
"v10"	pointer
,	O
"v11"	pointer
,	O
"v12"	pointer
,	O
"v13"	pointer
,	O
"v14"	pointer
,	O
"v15"	pointer
,	O
"v16"	pointer
,	O
"v17"	pointer
,	O
"v18"	pointer
,	O
"v19"	pointer
,	O
"v20"	pointer
,	O
"v21"	pointer
,	O
"v22"	pointer
,	O
"v23"	pointer
,	O
"v24"	pointer
,	O
"v25"	pointer
,	O
"v26"	pointer
,	O
"v27"	pointer
,	O
"v28"	pointer
,	O
"v29"	pointer
,	O
"v30"	pointer
,	O
"v31"	pointer
,	O
"z0"	pointer
,	O
"z1"	pointer
,	O
"z2"	pointer
,	O
"z3"	pointer
,	O
"z4"	pointer
,	O
"z5"	pointer
,	O
"z6"	pointer
,	O
"z7"	pointer
,	O
"z8"	pointer
,	O
"z9"	pointer
,	O
"z10"	pointer
,	O
"z11"	pointer
,	O
"z12"	pointer
,	O
"z13"	pointer
,	O
"z14"	pointer
,	O
"z15"	pointer
,	O
"z16"	pointer
,	O
"z17"	pointer
,	O
"z18"	pointer
,	O
"z19"	pointer
,	O
"z20"	pointer
,	O
"z21"	pointer
,	O
"z22"	pointer
,	O
"z23"	pointer
,	O
"z24"	pointer
,	O
"z25"	pointer
,	O
"z26"	pointer
,	O
"z27"	pointer
,	O
"z28"	pointer
,	O
"z29"	pointer
,	O
"z30"	pointer
,	O
"z31"	pointer
,	O
}	O
;	O
static	O
void	O
init_dwarf_regnames_aarch64	function
(	O
void	O
)	O
{	O
dwarf_regnames	pointer
=	O
dwarf_regnames_aarch64	array
;	O
dwarf_regnames_count	int
=	O
ARRAY_SIZE	O
(	O
dwarf_regnames_aarch64	array
)	O
;	O
dwarf_regnames_lookup_func	pointer
=	O
regname_internal_by_table_only	function
;	O
}	O
static	O
const	O
char	O
*	O
const	O
dwarf_regnames_s390	array
[	O
]	O
=	O
{	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
"f0"	pointer
,	O
"f2"	pointer
,	O
"f4"	pointer
,	O
"f6"	pointer
,	O
"f1"	pointer
,	O
"f3"	pointer
,	O
"f5"	pointer
,	O
"f7"	pointer
,	O
"f8"	pointer
,	O
"f10"	pointer
,	O
"f12"	pointer
,	O
"f14"	pointer
,	O
"f9"	pointer
,	O
"f11"	pointer
,	O
"f13"	pointer
,	O
"f15"	pointer
,	O
"cr0"	pointer
,	O
"cr1"	pointer
,	O
"cr2"	pointer
,	O
"cr3"	pointer
,	O
"cr4"	pointer
,	O
"cr5"	pointer
,	O
"cr6"	pointer
,	O
"cr7"	pointer
,	O
"cr8"	pointer
,	O
"cr9"	pointer
,	O
"cr10"	pointer
,	O
"cr11"	pointer
,	O
"cr12"	pointer
,	O
"cr13"	pointer
,	O
"cr14"	pointer
,	O
"cr15"	pointer
,	O
"a0"	pointer
,	O
"a1"	pointer
,	O
"a2"	pointer
,	O
"a3"	pointer
,	O
"a4"	pointer
,	O
"a5"	pointer
,	O
"a6"	pointer
,	O
"a7"	pointer
,	O
"a8"	pointer
,	O
"a9"	pointer
,	O
"a10"	pointer
,	O
"a11"	pointer
,	O
"a12"	pointer
,	O
"a13"	pointer
,	O
"a14"	pointer
,	O
"a15"	pointer
,	O
"pswm"	pointer
,	O
"pswa"	pointer
,	O
NULL	O
,	O
NULL	O
,	O
"v16"	pointer
,	O
"v18"	pointer
,	O
"v20"	pointer
,	O
"v22"	pointer
,	O
"v17"	pointer
,	O
"v19"	pointer
,	O
"v21"	pointer
,	O
"v23"	pointer
,	O
"v24"	pointer
,	O
"v26"	pointer
,	O
"v28"	pointer
,	O
"v30"	pointer
,	O
"v25"	pointer
,	O
"v27"	pointer
,	O
"v29"	pointer
,	O
"v31"	pointer
,	O
}	O
;	O
static	O
void	O
init_dwarf_regnames_s390	function
(	O
void	O
)	O
{	O
dwarf_regnames	pointer
=	O
dwarf_regnames_s390	array
;	O
dwarf_regnames_count	int
=	O
ARRAY_SIZE	O
(	O
dwarf_regnames_s390	array
)	O
;	O
dwarf_regnames_lookup_func	pointer
=	O
regname_internal_by_table_only	function
;	O
}	O
static	O
const	O
char	O
*	O
const	O
dwarf_regnames_riscv	array
[	O
]	O
=	O
{	O
"zero"	pointer
,	O
"ra"	pointer
,	O
"sp"	pointer
,	O
"gp"	pointer
,	O
"tp"	pointer
,	O
"t0"	pointer
,	O
"t1"	pointer
,	O
"t2"	pointer
,	O
"s0"	pointer
,	O
"s1"	pointer
,	O
"a0"	pointer
,	O
"a1"	pointer
,	O
"a2"	pointer
,	O
"a3"	pointer
,	O
"a4"	pointer
,	O
"a5"	pointer
,	O
"a6"	pointer
,	O
"a7"	pointer
,	O
"s2"	pointer
,	O
"s3"	pointer
,	O
"s4"	pointer
,	O
"s5"	pointer
,	O
"s6"	pointer
,	O
"s7"	pointer
,	O
"s8"	pointer
,	O
"s9"	pointer
,	O
"s10"	pointer
,	O
"s11"	pointer
,	O
"t3"	pointer
,	O
"t4"	pointer
,	O
"t5"	pointer
,	O
"t6"	pointer
,	O
"ft0"	pointer
,	O
"ft1"	pointer
,	O
"ft2"	pointer
,	O
"ft3"	pointer
,	O
"ft4"	pointer
,	O
"ft5"	pointer
,	O
"ft6"	pointer
,	O
"ft7"	pointer
,	O
"fs0"	pointer
,	O
"fs1"	pointer
,	O
"fa0"	pointer
,	O
"fa1"	pointer
,	O
"fa2"	pointer
,	O
"fa3"	pointer
,	O
"fa4"	pointer
,	O
"fa5"	pointer
,	O
"fa6"	pointer
,	O
"fa7"	pointer
,	O
"fs2"	pointer
,	O
"fs3"	pointer
,	O
"fs4"	pointer
,	O
"fs5"	pointer
,	O
"fs6"	pointer
,	O
"fs7"	pointer
,	O
"fs8"	pointer
,	O
"fs9"	pointer
,	O
"fs10"	pointer
,	O
"fs11"	pointer
,	O
"ft8"	pointer
,	O
"ft9"	pointer
,	O
"ft10"	pointer
,	O
"ft11"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
regname_internal_riscv	function
(	O
unsigned	O
int	O
regno	int
)	O
{	O
const	O
char	O
*	O
name	pointer
=	O
NULL	O
;	O
if	O
(	O
regno	int
<	O
ARRAY_SIZE	O
(	O
dwarf_regnames_riscv	array
)	O
)	O
name	pointer
=	O
dwarf_regnames_riscv	array
[	O
regno	int
]	O
;	O
else	O
if	O
(	O
regno	int
>=	O
4096	int
&&	O
regno	int
<=	O
8191	int
)	O
{	O
switch	O
(	O
regno	int
)	O
{	O
default	O
:	O
{	O
static	O
char	O
csr_name	array
[	O
10	int
]	O
;	O
snprintf	function
(	O
csr_name	array
,	O
sizeof	O
(	O
csr_name	array
)	O
,	O
"csr%d"	pointer
,	O
(	O
regno	int
-	O
4096	int
)	O
)	O
;	O
name	pointer
=	O
csr_name	array
;	O
}	O
break	O
;	O
}	O
}	O
return	O
name	pointer
;	O
}	O
static	O
void	O
init_dwarf_regnames_riscv	function
(	O
void	O
)	O
{	O
dwarf_regnames	pointer
=	O
NULL	O
;	O
dwarf_regnames_count	int
=	O
8192	int
;	O
dwarf_regnames_lookup_func	pointer
=	O
regname_internal_riscv	function
;	O
}	O
void	O
init_dwarf_regnames_by_elf_machine_code	function
(	O
unsigned	O
int	O
e_machine	int
)	O
{	O
dwarf_regnames_lookup_func	pointer
=	O
NULL	O
;	O
switch	O
(	O
e_machine	int
)	O
{	O
case	O
EM_386	int
:	O
init_dwarf_regnames_i386	function
(	O
)	O
;	O
break	O
;	O
case	O
EM_IAMCU	int
:	O
init_dwarf_regnames_iamcu	function
(	O
)	O
;	O
break	O
;	O
case	O
EM_X86_64	int
:	O
case	O
EM_L1OM	int
:	O
case	O
EM_K1OM	int
:	O
init_dwarf_regnames_x86_64	function
(	O
)	O
;	O
break	O
;	O
case	O
EM_AARCH64	int
:	O
init_dwarf_regnames_aarch64	function
(	O
)	O
;	O
break	O
;	O
case	O
EM_S390	int
:	O
init_dwarf_regnames_s390	function
(	O
)	O
;	O
break	O
;	O
case	O
EM_RISCV	int
:	O
init_dwarf_regnames_riscv	function
(	O
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
void	O
init_dwarf_regnames_by_bfd_arch_and_mach	function
(	O
enum	O
bfd_architecture	enum
arch	enum
,	O
unsigned	O
long	O
mach	long
)	O
{	O
dwarf_regnames_lookup_func	pointer
=	O
NULL	O
;	O
switch	O
(	O
arch	enum
)	O
{	O
case	O
bfd_arch_i386	int
:	O
switch	O
(	O
mach	long
)	O
{	O
case	O
bfd_mach_x86_64	O
:	O
case	O
bfd_mach_x86_64_intel_syntax	O
:	O
case	O
bfd_mach_x86_64_nacl	O
:	O
case	O
bfd_mach_x64_32	O
:	O
case	O
bfd_mach_x64_32_intel_syntax	O
:	O
case	O
bfd_mach_x64_32_nacl	O
:	O
init_dwarf_regnames_x86_64	function
(	O
)	O
;	O
break	O
;	O
default	O
:	O
init_dwarf_regnames_i386	function
(	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
bfd_arch_iamcu	int
:	O
init_dwarf_regnames_iamcu	function
(	O
)	O
;	O
break	O
;	O
case	O
bfd_arch_aarch64	int
:	O
init_dwarf_regnames_aarch64	function
(	O
)	O
;	O
break	O
;	O
case	O
bfd_arch_s390	int
:	O
init_dwarf_regnames_s390	function
(	O
)	O
;	O
break	O
;	O
case	O
bfd_arch_riscv	int
:	O
init_dwarf_regnames_riscv	function
(	O
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
regname_internal_by_table_only	function
(	O
unsigned	O
int	O
regno	int
)	O
{	O
if	O
(	O
dwarf_regnames	pointer
!=	O
NULL	O
&&	O
regno	int
<	O
dwarf_regnames_count	int
&&	O
dwarf_regnames	pointer
[	O
regno	int
]	O
!=	O
NULL	O
)	O
return	O
dwarf_regnames	pointer
[	O
regno	int
]	O
;	O
return	O
NULL	O
;	O
}	O
static	O
const	O
char	O
*	O
regname	function
(	O
unsigned	O
int	O
regno	int
,	O
int	O
name_only_p	int
)	O
{	O
static	O
char	O
reg	int
[	O
64	int
]	O
;	O
const	O
char	O
*	O
name	pointer
=	O
NULL	O
;	O
if	O
(	O
dwarf_regnames_lookup_func	pointer
!=	O
NULL	O
)	O
name	pointer
=	O
dwarf_regnames_lookup_func	pointer
(	O
regno	int
)	O
;	O
if	O
(	O
name	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
name_only_p	int
)	O
return	O
name	pointer
;	O
snprintf	function
(	O
reg	int
,	O
sizeof	O
(	O
reg	int
)	O
,	O
"r%d (%s)"	pointer
,	O
regno	int
,	O
name	pointer
)	O
;	O
}	O
else	O
snprintf	function
(	O
reg	int
,	O
sizeof	O
(	O
reg	int
)	O
,	O
"r%d"	pointer
,	O
regno	int
)	O
;	O
return	O
reg	int
;	O
}	O
static	O
void	O
frame_display_row	function
(	O
Frame_Chunk	struct
*	O
fc	pointer
,	O
int	O
*	O
need_col_headers	pointer
,	O
unsigned	O
int	O
*	O
max_regs	pointer
)	O
{	O
unsigned	O
int	O
r	int
;	O
char	O
tmp	long
[	O
100	int
]	O
;	O
if	O
(	O
*	O
max_regs	pointer
!=	O
fc	pointer
->	O
ncols	int
)	O
*	O
max_regs	pointer
=	O
fc	pointer
->	O
ncols	int
;	O
if	O
(	O
*	O
need_col_headers	pointer
)	O
{	O
static	O
const	O
char	O
*	O
sloc	pointer
=	O
"   LOC"	pointer
;	O
*	O
need_col_headers	pointer
=	O
0	int
;	O
printf	function
(	O
"%-*s CFA      "	pointer
,	O
eh_addr_size	int
*	O
2	int
,	O
sloc	pointer
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
*	O
max_regs	pointer
;	O
r	int
++	O
)	O
if	O
(	O
fc	pointer
->	O
col_type	pointer
[	O
r	int
]	O
!=	O
DW_CFA_unreferenced	O
)	O
{	O
if	O
(	O
r	int
==	O
fc	pointer
->	O
ra	int
)	O
printf	function
(	O
"ra    "	pointer
)	O
;	O
else	O
printf	function
(	O
"%-5s "	pointer
,	O
regname	function
(	O
r	int
,	O
1	int
)	O
)	O
;	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
print_dwarf_vma	function
(	O
fc	pointer
->	O
pc_begin	long
,	O
eh_addr_size	int
)	O
;	O
if	O
(	O
fc	pointer
->	O
cfa_exp	char
)	O
strcpy	function
(	O
tmp	long
,	O
"exp"	pointer
)	O
;	O
else	O
sprintf	function
(	O
tmp	long
,	O
"%s%+d"	pointer
,	O
regname	function
(	O
fc	pointer
->	O
cfa_reg	int
,	O
1	int
)	O
,	O
(	O
int	O
)	O
fc	pointer
->	O
cfa_offset	long
)	O
;	O
printf	function
(	O
"%-8s "	pointer
,	O
tmp	long
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
fc	pointer
->	O
ncols	int
;	O
r	int
++	O
)	O
{	O
if	O
(	O
fc	pointer
->	O
col_type	pointer
[	O
r	int
]	O
!=	O
DW_CFA_unreferenced	O
)	O
{	O
switch	O
(	O
fc	pointer
->	O
col_type	pointer
[	O
r	int
]	O
)	O
{	O
case	O
DW_CFA_undefined	int
:	O
strcpy	function
(	O
tmp	long
,	O
"u"	pointer
)	O
;	O
break	O
;	O
case	O
DW_CFA_same_value	int
:	O
strcpy	function
(	O
tmp	long
,	O
"s"	pointer
)	O
;	O
break	O
;	O
case	O
DW_CFA_offset	int
:	O
sprintf	function
(	O
tmp	long
,	O
"c%+d"	pointer
,	O
fc	pointer
->	O
col_offset	pointer
[	O
r	int
]	O
)	O
;	O
break	O
;	O
case	O
DW_CFA_val_offset	int
:	O
sprintf	function
(	O
tmp	long
,	O
"v%+d"	pointer
,	O
fc	pointer
->	O
col_offset	pointer
[	O
r	int
]	O
)	O
;	O
break	O
;	O
case	O
DW_CFA_register	int
:	O
sprintf	function
(	O
tmp	long
,	O
"%s"	pointer
,	O
regname	function
(	O
fc	pointer
->	O
col_offset	pointer
[	O
r	int
]	O
,	O
0	int
)	O
)	O
;	O
break	O
;	O
case	O
DW_CFA_expression	int
:	O
strcpy	function
(	O
tmp	long
,	O
"exp"	pointer
)	O
;	O
break	O
;	O
case	O
DW_CFA_val_expression	int
:	O
strcpy	function
(	O
tmp	long
,	O
"vexp"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
strcpy	function
(	O
tmp	long
,	O
"n/a"	pointer
)	O
;	O
break	O
;	O
}	O
printf	function
(	O
"%-5s "	pointer
,	O
tmp	long
)	O
;	O
}	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
static	O
unsigned	O
char	O
*	O
read_cie	function
(	O
unsigned	O
char	O
*	O
start	pointer
,	O
unsigned	O
char	O
*	O
end	pointer
,	O
Frame_Chunk	struct
*	O
*	O
p_cie	pointer
,	O
int	O
*	O
p_version	pointer
,	O
bfd_size_type	long
*	O
p_aug_len	pointer
,	O
unsigned	O
char	O
*	O
*	O
p_aug	pointer
)	O
{	O
int	O
version	int
;	O
Frame_Chunk	struct
*	O
fc	pointer
;	O
unsigned	O
char	O
*	O
augmentation_data	pointer
=	O
NULL	O
;	O
bfd_size_type	long
augmentation_data_len	long
=	O
0	int
;	O
*	O
p_cie	pointer
=	O
NULL	O
;	O
if	O
(	O
start	pointer
>=	O
end	pointer
)	O
return	O
end	pointer
;	O
fc	pointer
=	O
(	O
Frame_Chunk	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
Frame_Chunk	struct
)	O
)	O
;	O
memset	function
(	O
fc	pointer
,	O
0	int
,	O
sizeof	O
(	O
Frame_Chunk	struct
)	O
)	O
;	O
fc	pointer
->	O
col_type	pointer
=	O
(	O
short	O
int	O
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
short	O
int	O
)	O
)	O
;	O
fc	pointer
->	O
col_offset	pointer
=	O
(	O
int	O
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
version	int
=	O
*	O
start	pointer
++	O
;	O
fc	pointer
->	O
augmentation	pointer
=	O
(	O
char	O
*	O
)	O
start	pointer
;	O
while	O
(	O
start	pointer
<	O
end	pointer
)	O
if	O
(	O
*	O
start	pointer
++	O
==	O
'\0'	O
)	O
break	O
;	O
if	O
(	O
start	pointer
==	O
end	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"No terminator for augmentation name\n"	pointer
)	O
)	O
;	O
goto	O
fail	O
;	O
}	O
if	O
(	O
strcmp	function
(	O
fc	pointer
->	O
augmentation	pointer
,	O
"eh"	pointer
)	O
==	O
0	int
)	O
start	pointer
+=	O
eh_addr_size	int
;	O
if	O
(	O
version	int
>=	O
4	int
)	O
{	O
GET	O
(	O
fc	pointer
->	O
ptr_size	pointer
,	O
1	int
)	O
;	O
if	O
(	O
fc	pointer
->	O
ptr_size	pointer
<	O
1	int
||	O
fc	pointer
->	O
ptr_size	pointer
>	O
8	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Invalid pointer size (%d) in CIE data\n"	pointer
)	O
,	O
fc	pointer
->	O
ptr_size	pointer
)	O
;	O
goto	O
fail	O
;	O
}	O
GET	O
(	O
fc	pointer
->	O
segment_size	char
,	O
1	int
)	O
;	O
if	O
(	O
fc	pointer
->	O
segment_size	char
>	O
8	int
||	O
fc	pointer
->	O
segment_size	char
+	O
fc	pointer
->	O
ptr_size	pointer
>	O
8	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Invalid segment size (%d) in CIE data\n"	pointer
)	O
,	O
fc	pointer
->	O
segment_size	char
)	O
;	O
goto	O
fail	O
;	O
}	O
eh_addr_size	int
=	O
fc	pointer
->	O
ptr_size	pointer
;	O
}	O
else	O
{	O
fc	pointer
->	O
ptr_size	pointer
=	O
eh_addr_size	int
;	O
fc	pointer
->	O
segment_size	char
=	O
0	int
;	O
}	O
READ_ULEB	O
(	O
fc	pointer
->	O
code_factor	int
,	O
start	pointer
,	O
end	pointer
)	O
;	O
READ_SLEB	O
(	O
fc	pointer
->	O
data_factor	int
,	O
start	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
version	int
==	O
1	int
)	O
{	O
GET	O
(	O
fc	pointer
->	O
ra	int
,	O
1	int
)	O
;	O
}	O
else	O
{	O
READ_ULEB	O
(	O
fc	pointer
->	O
ra	int
,	O
start	pointer
,	O
end	pointer
)	O
;	O
}	O
if	O
(	O
fc	pointer
->	O
augmentation	pointer
[	O
0	int
]	O
==	O
'z'	O
)	O
{	O
READ_ULEB	O
(	O
augmentation_data_len	long
,	O
start	pointer
,	O
end	pointer
)	O
;	O
augmentation_data	pointer
=	O
start	pointer
;	O
if	O
(	O
augmentation_data_len	long
>	O
(	O
bfd_size_type	long
)	O
(	O
end	pointer
-	O
start	pointer
)	O
)	O
{	O
warn	function
(	O
_	O
(	O
"Augmentation data too long: 0x%s, expected at most %#lx\n"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
augmentation_data_len	long
)	O
,	O
(	O
unsigned	O
long	O
)	O
(	O
end	pointer
-	O
start	pointer
)	O
)	O
;	O
goto	O
fail	O
;	O
}	O
start	pointer
+=	O
augmentation_data_len	long
;	O
}	O
if	O
(	O
augmentation_data_len	long
)	O
{	O
unsigned	O
char	O
*	O
p	pointer
;	O
unsigned	O
char	O
*	O
q	pointer
;	O
unsigned	O
char	O
*	O
qend	pointer
;	O
p	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
fc	pointer
->	O
augmentation	pointer
+	O
1	int
;	O
q	pointer
=	O
augmentation_data	pointer
;	O
qend	pointer
=	O
q	pointer
+	O
augmentation_data_len	long
;	O
while	O
(	O
p	pointer
<	O
end	pointer
&&	O
q	pointer
<	O
qend	pointer
)	O
{	O
if	O
(	O
*	O
p	pointer
==	O
'L'	O
)	O
q	pointer
++	O
;	O
else	O
if	O
(	O
*	O
p	pointer
==	O
'P'	O
)	O
q	pointer
+=	O
1	int
+	O
size_of_encoded_value	function
(	O
*	O
q	pointer
)	O
;	O
else	O
if	O
(	O
*	O
p	pointer
==	O
'R'	O
)	O
fc	pointer
->	O
fde_encoding	char
=	O
*	O
q	pointer
++	O
;	O
else	O
if	O
(	O
*	O
p	pointer
==	O
'S'	O
)	O
;	O
else	O
if	O
(	O
*	O
p	pointer
==	O
'B'	O
)	O
;	O
else	O
break	O
;	O
p	pointer
++	O
;	O
}	O
}	O
*	O
p_cie	pointer
=	O
fc	pointer
;	O
if	O
(	O
p_version	pointer
)	O
*	O
p_version	pointer
=	O
version	int
;	O
if	O
(	O
p_aug_len	pointer
)	O
{	O
*	O
p_aug_len	pointer
=	O
augmentation_data_len	long
;	O
*	O
p_aug	pointer
=	O
augmentation_data	pointer
;	O
}	O
return	O
start	pointer
;	O
fail	O
:	O
free	function
(	O
fc	pointer
->	O
col_offset	pointer
)	O
;	O
free	function
(	O
fc	pointer
->	O
col_type	pointer
)	O
;	O
free	function
(	O
fc	pointer
)	O
;	O
return	O
end	pointer
;	O
}	O
static	O
void	O
display_data	function
(	O
bfd_size_type	long
printed	long
,	O
const	O
unsigned	O
char	O
*	O
data	pointer
,	O
const	O
bfd_size_type	long
len	long
)	O
{	O
if	O
(	O
do_wide	int
||	O
len	long
<	O
(	O
(	O
80	int
-	O
printed	long
)	O
/	O
3	int
)	O
)	O
for	O
(	O
printed	long
=	O
0	int
;	O
printed	long
<	O
len	long
;	O
++	O
printed	long
)	O
printf	function
(	O
" %02x"	pointer
,	O
data	pointer
[	O
printed	long
]	O
)	O
;	O
else	O
{	O
for	O
(	O
printed	long
=	O
0	int
;	O
printed	long
<	O
len	long
;	O
++	O
printed	long
)	O
{	O
if	O
(	O
printed	long
%	O
(	O
80	int
/	O
3	int
)	O
==	O
0	int
)	O
putchar	function
(	O
'\n'	O
)	O
;	O
printf	function
(	O
" %02x"	pointer
,	O
data	pointer
[	O
printed	long
]	O
)	O
;	O
}	O
}	O
}	O
static	O
void	O
display_augmentation_data	function
(	O
const	O
unsigned	O
char	O
*	O
data	pointer
,	O
const	O
bfd_size_type	long
len	long
)	O
{	O
bfd_size_type	long
i	pointer
;	O
i	pointer
=	O
printf	function
(	O
_	O
(	O
"  Augmentation data:    "	pointer
)	O
)	O
;	O
display_data	function
(	O
i	pointer
,	O
data	pointer
,	O
len	long
)	O
;	O
}	O
static	O
int	O
display_debug_frames	function
(	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
void	O
*	O
file	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
unsigned	O
char	O
*	O
start	pointer
=	O
section	pointer
->	O
start	pointer
;	O
unsigned	O
char	O
*	O
end	pointer
=	O
start	pointer
+	O
section	pointer
->	O
size	int
;	O
unsigned	O
char	O
*	O
section_start	pointer
=	O
start	pointer
;	O
Frame_Chunk	struct
*	O
chunks	pointer
=	O
NULL	O
,	O
*	O
forward_refs	pointer
=	O
NULL	O
;	O
Frame_Chunk	struct
*	O
remembered_state	pointer
=	O
NULL	O
;	O
Frame_Chunk	struct
*	O
rs	pointer
;	O
bfd_boolean	int
is_eh	int
=	O
strcmp	function
(	O
section	pointer
->	O
name	pointer
,	O
".eh_frame"	pointer
)	O
==	O
0	int
;	O
unsigned	O
int	O
max_regs	pointer
=	O
0	int
;	O
const	O
char	O
*	O
bad_reg	pointer
=	O
_	O
(	O
"bad register: "	pointer
)	O
;	O
unsigned	O
int	O
saved_eh_addr_size	int
=	O
eh_addr_size	int
;	O
introduce	function
(	O
section	pointer
,	O
FALSE	int
)	O
;	O
while	O
(	O
start	pointer
<	O
end	pointer
)	O
{	O
unsigned	O
char	O
*	O
saved_start	pointer
;	O
unsigned	O
char	O
*	O
block_end	pointer
;	O
dwarf_vma	long
length	long
;	O
dwarf_vma	long
cie_id	long
;	O
Frame_Chunk	struct
*	O
fc	pointer
;	O
Frame_Chunk	struct
*	O
cie	pointer
;	O
int	O
need_col_headers	pointer
=	O
1	int
;	O
unsigned	O
char	O
*	O
augmentation_data	pointer
=	O
NULL	O
;	O
bfd_size_type	long
augmentation_data_len	long
=	O
0	int
;	O
unsigned	O
int	O
encoded_ptr_size	int
=	O
saved_eh_addr_size	int
;	O
unsigned	O
int	O
offset_size	int
;	O
unsigned	O
int	O
initial_length_size	int
;	O
bfd_boolean	int
all_nops	int
;	O
static	O
Frame_Chunk	struct
fde_fc	struct
;	O
saved_start	pointer
=	O
start	pointer
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
length	long
,	O
start	pointer
,	O
4	int
,	O
end	pointer
)	O
;	O
if	O
(	O
length	long
==	O
0	int
)	O
{	O
printf	function
(	O
"\n%08lx ZERO terminator\n\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
(	O
saved_start	pointer
-	O
section_start	pointer
)	O
)	O
;	O
while	O
(	O
start	pointer
<	O
end	pointer
&&	O
*	O
start	pointer
==	O
0	int
)	O
++	O
start	pointer
;	O
continue	O
;	O
}	O
if	O
(	O
length	long
==	O
0xffffffff	int
)	O
{	O
SAFE_BYTE_GET_AND_INC	O
(	O
length	long
,	O
start	pointer
,	O
8	int
,	O
end	pointer
)	O
;	O
offset_size	int
=	O
8	int
;	O
initial_length_size	int
=	O
12	int
;	O
}	O
else	O
{	O
offset_size	int
=	O
4	int
;	O
initial_length_size	int
=	O
4	int
;	O
}	O
block_end	pointer
=	O
saved_start	pointer
+	O
length	long
+	O
initial_length_size	int
;	O
if	O
(	O
block_end	pointer
>	O
end	pointer
||	O
block_end	pointer
<	O
start	pointer
)	O
{	O
warn	function
(	O
"Invalid length 0x%s in FDE at %#08lx\n"	pointer
,	O
dwarf_vmatoa_1	function
(	O
NULL	O
,	O
length	long
,	O
offset_size	int
)	O
,	O
(	O
unsigned	O
long	O
)	O
(	O
saved_start	pointer
-	O
section_start	pointer
)	O
)	O
;	O
block_end	pointer
=	O
end	pointer
;	O
}	O
SAFE_BYTE_GET_AND_INC	O
(	O
cie_id	long
,	O
start	pointer
,	O
offset_size	int
,	O
end	pointer
)	O
;	O
if	O
(	O
is_eh	int
?	O
(	O
cie_id	long
==	O
0	int
)	O
:	O
(	O
(	O
offset_size	int
==	O
4	int
&&	O
cie_id	long
==	O
DW_CIE_ID	int
)	O
||	O
(	O
offset_size	int
==	O
8	int
&&	O
cie_id	long
==	O
DW64_CIE_ID	int
)	O
)	O
)	O
{	O
int	O
version	int
;	O
unsigned	O
int	O
mreg	int
;	O
start	pointer
=	O
read_cie	function
(	O
start	pointer
,	O
end	pointer
,	O
&	O
cie	pointer
,	O
&	O
version	int
,	O
&	O
augmentation_data_len	long
,	O
&	O
augmentation_data	pointer
)	O
;	O
if	O
(	O
cie	pointer
==	O
NULL	O
)	O
break	O
;	O
fc	pointer
=	O
cie	pointer
;	O
fc	pointer
->	O
next	pointer
=	O
chunks	pointer
;	O
chunks	pointer
=	O
fc	pointer
;	O
fc	pointer
->	O
chunk_start	pointer
=	O
saved_start	pointer
;	O
mreg	int
=	O
max_regs	pointer
>	O
0	int
?	O
max_regs	pointer
-	O
1	int
:	O
0	int
;	O
if	O
(	O
mreg	int
<	O
fc	pointer
->	O
ra	int
)	O
mreg	int
=	O
fc	pointer
->	O
ra	int
;	O
if	O
(	O
frame_need_space	function
(	O
fc	pointer
,	O
mreg	int
)	O
<	O
0	int
)	O
break	O
;	O
if	O
(	O
fc	pointer
->	O
fde_encoding	char
)	O
encoded_ptr_size	int
=	O
size_of_encoded_value	function
(	O
fc	pointer
->	O
fde_encoding	char
)	O
;	O
printf	function
(	O
"\n%08lx "	pointer
,	O
(	O
unsigned	O
long	O
)	O
(	O
saved_start	pointer
-	O
section_start	pointer
)	O
)	O
;	O
print_dwarf_vma	function
(	O
length	long
,	O
fc	pointer
->	O
ptr_size	pointer
)	O
;	O
print_dwarf_vma	function
(	O
cie_id	long
,	O
offset_size	int
)	O
;	O
if	O
(	O
do_debug_frames_interp	int
)	O
{	O
printf	function
(	O
"CIE \"%s\" cf=%d df=%d ra=%d\n"	pointer
,	O
fc	pointer
->	O
augmentation	pointer
,	O
fc	pointer
->	O
code_factor	int
,	O
fc	pointer
->	O
data_factor	int
,	O
fc	pointer
->	O
ra	int
)	O
;	O
}	O
else	O
{	O
printf	function
(	O
"CIE\n"	pointer
)	O
;	O
printf	function
(	O
"  Version:               %d\n"	pointer
,	O
version	int
)	O
;	O
printf	function
(	O
"  Augmentation:          \"%s\"\n"	pointer
,	O
fc	pointer
->	O
augmentation	pointer
)	O
;	O
if	O
(	O
version	int
>=	O
4	int
)	O
{	O
printf	function
(	O
"  Pointer Size:          %u\n"	pointer
,	O
fc	pointer
->	O
ptr_size	pointer
)	O
;	O
printf	function
(	O
"  Segment Size:          %u\n"	pointer
,	O
fc	pointer
->	O
segment_size	char
)	O
;	O
}	O
printf	function
(	O
"  Code alignment factor: %u\n"	pointer
,	O
fc	pointer
->	O
code_factor	int
)	O
;	O
printf	function
(	O
"  Data alignment factor: %d\n"	pointer
,	O
fc	pointer
->	O
data_factor	int
)	O
;	O
printf	function
(	O
"  Return address column: %d\n"	pointer
,	O
fc	pointer
->	O
ra	int
)	O
;	O
if	O
(	O
augmentation_data_len	long
)	O
display_augmentation_data	function
(	O
augmentation_data	pointer
,	O
augmentation_data_len	long
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
}	O
else	O
{	O
unsigned	O
char	O
*	O
look_for	pointer
;	O
unsigned	O
long	O
segment_selector	long
;	O
if	O
(	O
is_eh	int
)	O
{	O
dwarf_vma	long
sign	int
=	O
(	O
dwarf_vma	long
)	O
1	int
<<	O
(	O
offset_size	int
*	O
8	int
-	O
1	int
)	O
;	O
look_for	pointer
=	O
start	pointer
-	O
4	int
-	O
(	O
(	O
cie_id	long
^	O
sign	int
)	O
-	O
sign	int
)	O
;	O
}	O
else	O
look_for	pointer
=	O
section_start	pointer
+	O
cie_id	long
;	O
if	O
(	O
look_for	pointer
<=	O
saved_start	pointer
)	O
{	O
for	O
(	O
cie	pointer
=	O
chunks	pointer
;	O
cie	pointer
;	O
cie	pointer
=	O
cie	pointer
->	O
next	pointer
)	O
if	O
(	O
cie	pointer
->	O
chunk_start	pointer
==	O
look_for	pointer
)	O
break	O
;	O
}	O
else	O
{	O
for	O
(	O
cie	pointer
=	O
forward_refs	pointer
;	O
cie	pointer
;	O
cie	pointer
=	O
cie	pointer
->	O
next	pointer
)	O
if	O
(	O
cie	pointer
->	O
chunk_start	pointer
==	O
look_for	pointer
)	O
break	O
;	O
if	O
(	O
!	O
cie	pointer
)	O
{	O
unsigned	O
int	O
off_size	int
;	O
unsigned	O
char	O
*	O
cie_scan	pointer
;	O
cie_scan	pointer
=	O
look_for	pointer
;	O
off_size	int
=	O
4	int
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
length	long
,	O
cie_scan	pointer
,	O
4	int
,	O
end	pointer
)	O
;	O
if	O
(	O
length	long
==	O
0xffffffff	int
)	O
{	O
SAFE_BYTE_GET_AND_INC	O
(	O
length	long
,	O
cie_scan	pointer
,	O
8	int
,	O
end	pointer
)	O
;	O
off_size	int
=	O
8	int
;	O
}	O
if	O
(	O
length	long
!=	O
0	int
)	O
{	O
dwarf_vma	long
c_id	long
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
c_id	long
,	O
cie_scan	pointer
,	O
off_size	int
,	O
end	pointer
)	O
;	O
if	O
(	O
is_eh	int
?	O
c_id	long
==	O
0	int
:	O
(	O
(	O
off_size	int
==	O
4	int
&&	O
c_id	long
==	O
DW_CIE_ID	int
)	O
||	O
(	O
off_size	int
==	O
8	int
&&	O
c_id	long
==	O
DW64_CIE_ID	int
)	O
)	O
)	O
{	O
int	O
version	int
;	O
unsigned	O
int	O
mreg	int
;	O
read_cie	function
(	O
cie_scan	pointer
,	O
end	pointer
,	O
&	O
cie	pointer
,	O
&	O
version	int
,	O
&	O
augmentation_data_len	long
,	O
&	O
augmentation_data	pointer
)	O
;	O
if	O
(	O
cie	pointer
==	O
NULL	O
)	O
{	O
warn	function
(	O
_	O
(	O
"Failed to read CIE information\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
cie	pointer
->	O
next	pointer
=	O
forward_refs	pointer
;	O
forward_refs	pointer
=	O
cie	pointer
;	O
cie	pointer
->	O
chunk_start	pointer
=	O
look_for	pointer
;	O
mreg	int
=	O
max_regs	pointer
>	O
0	int
?	O
max_regs	pointer
-	O
1	int
:	O
0	int
;	O
if	O
(	O
mreg	int
<	O
cie	pointer
->	O
ra	int
)	O
mreg	int
=	O
cie	pointer
->	O
ra	int
;	O
if	O
(	O
frame_need_space	function
(	O
cie	pointer
,	O
mreg	int
)	O
<	O
0	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Invalid max register\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
cie	pointer
->	O
fde_encoding	char
)	O
encoded_ptr_size	int
=	O
size_of_encoded_value	function
(	O
cie	pointer
->	O
fde_encoding	char
)	O
;	O
}	O
}	O
}	O
}	O
fc	pointer
=	O
&	O
fde_fc	struct
;	O
memset	function
(	O
fc	pointer
,	O
0	int
,	O
sizeof	O
(	O
Frame_Chunk	struct
)	O
)	O
;	O
if	O
(	O
!	O
cie	pointer
)	O
{	O
warn	function
(	O
"Invalid CIE pointer 0x%s in FDE at %#08lx\n"	pointer
,	O
dwarf_vmatoa_1	function
(	O
NULL	O
,	O
cie_id	long
,	O
offset_size	int
)	O
,	O
(	O
unsigned	O
long	O
)	O
(	O
saved_start	pointer
-	O
section_start	pointer
)	O
)	O
;	O
fc	pointer
->	O
ncols	int
=	O
0	int
;	O
fc	pointer
->	O
col_type	pointer
=	O
(	O
short	O
int	O
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
short	O
int	O
)	O
)	O
;	O
fc	pointer
->	O
col_offset	pointer
=	O
(	O
int	O
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
if	O
(	O
frame_need_space	function
(	O
fc	pointer
,	O
max_regs	pointer
>	O
0	int
?	O
max_regs	pointer
-	O
1	int
:	O
0	int
)	O
<	O
0	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Invalid max register\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
cie	pointer
=	O
fc	pointer
;	O
fc	pointer
->	O
augmentation	pointer
=	O
""	pointer
;	O
fc	pointer
->	O
fde_encoding	char
=	O
0	int
;	O
fc	pointer
->	O
ptr_size	pointer
=	O
eh_addr_size	int
;	O
fc	pointer
->	O
segment_size	char
=	O
0	int
;	O
}	O
else	O
{	O
fc	pointer
->	O
ncols	int
=	O
cie	pointer
->	O
ncols	int
;	O
fc	pointer
->	O
col_type	pointer
=	O
(	O
short	O
int	O
*	O
)	O
xcmalloc	function
(	O
fc	pointer
->	O
ncols	int
,	O
sizeof	O
(	O
short	O
int	O
)	O
)	O
;	O
fc	pointer
->	O
col_offset	pointer
=	O
(	O
int	O
*	O
)	O
xcmalloc	function
(	O
fc	pointer
->	O
ncols	int
,	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
memcpy	function
(	O
fc	pointer
->	O
col_type	pointer
,	O
cie	pointer
->	O
col_type	pointer
,	O
fc	pointer
->	O
ncols	int
*	O
sizeof	O
(	O
short	O
int	O
)	O
)	O
;	O
memcpy	function
(	O
fc	pointer
->	O
col_offset	pointer
,	O
cie	pointer
->	O
col_offset	pointer
,	O
fc	pointer
->	O
ncols	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
fc	pointer
->	O
augmentation	pointer
=	O
cie	pointer
->	O
augmentation	pointer
;	O
fc	pointer
->	O
ptr_size	pointer
=	O
cie	pointer
->	O
ptr_size	pointer
;	O
eh_addr_size	int
=	O
cie	pointer
->	O
ptr_size	pointer
;	O
fc	pointer
->	O
segment_size	char
=	O
cie	pointer
->	O
segment_size	char
;	O
fc	pointer
->	O
code_factor	int
=	O
cie	pointer
->	O
code_factor	int
;	O
fc	pointer
->	O
data_factor	int
=	O
cie	pointer
->	O
data_factor	int
;	O
fc	pointer
->	O
cfa_reg	int
=	O
cie	pointer
->	O
cfa_reg	int
;	O
fc	pointer
->	O
cfa_offset	long
=	O
cie	pointer
->	O
cfa_offset	long
;	O
fc	pointer
->	O
ra	int
=	O
cie	pointer
->	O
ra	int
;	O
if	O
(	O
frame_need_space	function
(	O
fc	pointer
,	O
max_regs	pointer
>	O
0	int
?	O
max_regs	pointer
-	O
1	int
:	O
0	int
)	O
<	O
0	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Invalid max register\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
fc	pointer
->	O
fde_encoding	char
=	O
cie	pointer
->	O
fde_encoding	char
;	O
}	O
if	O
(	O
fc	pointer
->	O
fde_encoding	char
)	O
encoded_ptr_size	int
=	O
size_of_encoded_value	function
(	O
fc	pointer
->	O
fde_encoding	char
)	O
;	O
segment_selector	long
=	O
0	int
;	O
if	O
(	O
fc	pointer
->	O
segment_size	char
)	O
{	O
if	O
(	O
fc	pointer
->	O
segment_size	char
>	O
sizeof	O
(	O
segment_selector	long
)	O
)	O
{	O
warn	function
(	O
_	O
(	O
"Probably corrupt segment size: %d - using 4 instead\n"	pointer
)	O
,	O
fc	pointer
->	O
segment_size	char
)	O
;	O
fc	pointer
->	O
segment_size	char
=	O
4	int
;	O
}	O
SAFE_BYTE_GET_AND_INC	O
(	O
segment_selector	long
,	O
start	pointer
,	O
fc	pointer
->	O
segment_size	char
,	O
end	pointer
)	O
;	O
}	O
fc	pointer
->	O
pc_begin	long
=	O
get_encoded_value	function
(	O
&	O
start	pointer
,	O
fc	pointer
->	O
fde_encoding	char
,	O
section	pointer
,	O
end	pointer
)	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
fc	pointer
->	O
pc_range	long
,	O
start	pointer
,	O
encoded_ptr_size	int
,	O
end	pointer
)	O
;	O
if	O
(	O
cie	pointer
->	O
augmentation	pointer
[	O
0	int
]	O
==	O
'z'	O
)	O
{	O
READ_ULEB	O
(	O
augmentation_data_len	long
,	O
start	pointer
,	O
end	pointer
)	O
;	O
augmentation_data	pointer
=	O
start	pointer
;	O
if	O
(	O
augmentation_data_len	long
>	O
(	O
bfd_size_type	long
)	O
(	O
end	pointer
-	O
start	pointer
)	O
)	O
{	O
warn	function
(	O
_	O
(	O
"Augmentation data too long: 0x%s, "	pointer
"expected at most %#lx\n"	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
augmentation_data_len	long
)	O
,	O
(	O
unsigned	O
long	O
)	O
(	O
end	pointer
-	O
start	pointer
)	O
)	O
;	O
start	pointer
=	O
end	pointer
;	O
augmentation_data	pointer
=	O
NULL	O
;	O
augmentation_data_len	long
=	O
0	int
;	O
}	O
start	pointer
+=	O
augmentation_data_len	long
;	O
}	O
printf	function
(	O
"\n%08lx %s %s FDE cie=%08lx pc="	pointer
,	O
(	O
unsigned	O
long	O
)	O
(	O
saved_start	pointer
-	O
section_start	pointer
)	O
,	O
dwarf_vmatoa_1	function
(	O
NULL	O
,	O
length	long
,	O
fc	pointer
->	O
ptr_size	pointer
)	O
,	O
dwarf_vmatoa_1	function
(	O
NULL	O
,	O
cie_id	long
,	O
offset_size	int
)	O
,	O
(	O
unsigned	O
long	O
)	O
(	O
cie	pointer
->	O
chunk_start	pointer
-	O
section_start	pointer
)	O
)	O
;	O
if	O
(	O
fc	pointer
->	O
segment_size	char
)	O
printf	function
(	O
"%04lx:"	pointer
,	O
segment_selector	long
)	O
;	O
printf	function
(	O
"%s..%s\n"	pointer
,	O
dwarf_vmatoa_1	function
(	O
NULL	O
,	O
fc	pointer
->	O
pc_begin	long
,	O
fc	pointer
->	O
ptr_size	pointer
)	O
,	O
dwarf_vmatoa_1	function
(	O
NULL	O
,	O
fc	pointer
->	O
pc_begin	long
+	O
fc	pointer
->	O
pc_range	long
,	O
fc	pointer
->	O
ptr_size	pointer
)	O
)	O
;	O
if	O
(	O
!	O
do_debug_frames_interp	int
&&	O
augmentation_data_len	long
)	O
{	O
display_augmentation_data	function
(	O
augmentation_data	pointer
,	O
augmentation_data_len	long
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
}	O
if	O
(	O
1	int
||	O
do_debug_frames_interp	int
)	O
{	O
unsigned	O
char	O
*	O
tmp	long
=	O
start	pointer
;	O
while	O
(	O
start	pointer
<	O
block_end	pointer
)	O
{	O
unsigned	O
int	O
reg	int
,	O
op	int
,	O
opa	int
;	O
unsigned	O
long	O
temp	long
;	O
unsigned	O
char	O
*	O
new_start	pointer
;	O
op	int
=	O
*	O
start	pointer
++	O
;	O
opa	int
=	O
op	int
&	O
0x3f	int
;	O
if	O
(	O
op	int
&	O
0xc0	int
)	O
op	int
&=	O
0xc0	int
;	O
switch	O
(	O
op	int
)	O
{	O
case	O
DW_CFA_advance_loc	int
:	O
break	O
;	O
case	O
DW_CFA_offset	int
:	O
SKIP_ULEB	O
(	O
start	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
frame_need_space	function
(	O
fc	pointer
,	O
opa	int
)	O
>=	O
0	int
)	O
fc	pointer
->	O
col_type	pointer
[	O
opa	int
]	O
=	O
DW_CFA_undefined	int
;	O
break	O
;	O
case	O
DW_CFA_restore	int
:	O
if	O
(	O
frame_need_space	function
(	O
fc	pointer
,	O
opa	int
)	O
>=	O
0	int
)	O
fc	pointer
->	O
col_type	pointer
[	O
opa	int
]	O
=	O
DW_CFA_undefined	int
;	O
break	O
;	O
case	O
DW_CFA_set_loc	int
:	O
start	pointer
+=	O
encoded_ptr_size	int
;	O
break	O
;	O
case	O
DW_CFA_advance_loc1	int
:	O
start	pointer
+=	O
1	int
;	O
break	O
;	O
case	O
DW_CFA_advance_loc2	int
:	O
start	pointer
+=	O
2	int
;	O
break	O
;	O
case	O
DW_CFA_advance_loc4	int
:	O
start	pointer
+=	O
4	int
;	O
break	O
;	O
case	O
DW_CFA_offset_extended	int
:	O
case	O
DW_CFA_val_offset	int
:	O
READ_ULEB	O
(	O
reg	int
,	O
start	pointer
,	O
end	pointer
)	O
;	O
SKIP_ULEB	O
(	O
start	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
frame_need_space	function
(	O
fc	pointer
,	O
reg	int
)	O
>=	O
0	int
)	O
fc	pointer
->	O
col_type	pointer
[	O
reg	int
]	O
=	O
DW_CFA_undefined	int
;	O
break	O
;	O
case	O
DW_CFA_restore_extended	int
:	O
READ_ULEB	O
(	O
reg	int
,	O
start	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
frame_need_space	function
(	O
fc	pointer
,	O
reg	int
)	O
>=	O
0	int
)	O
fc	pointer
->	O
col_type	pointer
[	O
reg	int
]	O
=	O
DW_CFA_undefined	int
;	O
break	O
;	O
case	O
DW_CFA_undefined	int
:	O
READ_ULEB	O
(	O
reg	int
,	O
start	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
frame_need_space	function
(	O
fc	pointer
,	O
reg	int
)	O
>=	O
0	int
)	O
fc	pointer
->	O
col_type	pointer
[	O
reg	int
]	O
=	O
DW_CFA_undefined	int
;	O
break	O
;	O
case	O
DW_CFA_same_value	int
:	O
READ_ULEB	O
(	O
reg	int
,	O
start	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
frame_need_space	function
(	O
fc	pointer
,	O
reg	int
)	O
>=	O
0	int
)	O
fc	pointer
->	O
col_type	pointer
[	O
reg	int
]	O
=	O
DW_CFA_undefined	int
;	O
break	O
;	O
case	O
DW_CFA_register	int
:	O
READ_ULEB	O
(	O
reg	int
,	O
start	pointer
,	O
end	pointer
)	O
;	O
SKIP_ULEB	O
(	O
start	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
frame_need_space	function
(	O
fc	pointer
,	O
reg	int
)	O
>=	O
0	int
)	O
fc	pointer
->	O
col_type	pointer
[	O
reg	int
]	O
=	O
DW_CFA_undefined	int
;	O
break	O
;	O
case	O
DW_CFA_def_cfa	int
:	O
SKIP_ULEB	O
(	O
start	pointer
,	O
end	pointer
)	O
;	O
SKIP_ULEB	O
(	O
start	pointer
,	O
end	pointer
)	O
;	O
break	O
;	O
case	O
DW_CFA_def_cfa_register	int
:	O
SKIP_ULEB	O
(	O
start	pointer
,	O
end	pointer
)	O
;	O
break	O
;	O
case	O
DW_CFA_def_cfa_offset	int
:	O
SKIP_ULEB	O
(	O
start	pointer
,	O
end	pointer
)	O
;	O
break	O
;	O
case	O
DW_CFA_def_cfa_expression	int
:	O
READ_ULEB	O
(	O
temp	long
,	O
start	pointer
,	O
end	pointer
)	O
;	O
new_start	pointer
=	O
start	pointer
+	O
temp	long
;	O
if	O
(	O
new_start	pointer
<	O
start	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"Corrupt CFA_def expression value: %lu\n"	pointer
)	O
,	O
temp	long
)	O
;	O
start	pointer
=	O
block_end	pointer
;	O
}	O
else	O
start	pointer
=	O
new_start	pointer
;	O
break	O
;	O
case	O
DW_CFA_expression	int
:	O
case	O
DW_CFA_val_expression	int
:	O
READ_ULEB	O
(	O
reg	int
,	O
start	pointer
,	O
end	pointer
)	O
;	O
READ_ULEB	O
(	O
temp	long
,	O
start	pointer
,	O
end	pointer
)	O
;	O
new_start	pointer
=	O
start	pointer
+	O
temp	long
;	O
if	O
(	O
new_start	pointer
<	O
start	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"Corrupt CFA expression value: %lu\n"	pointer
)	O
,	O
temp	long
)	O
;	O
start	pointer
=	O
block_end	pointer
;	O
}	O
else	O
start	pointer
=	O
new_start	pointer
;	O
if	O
(	O
frame_need_space	function
(	O
fc	pointer
,	O
reg	int
)	O
>=	O
0	int
)	O
fc	pointer
->	O
col_type	pointer
[	O
reg	int
]	O
=	O
DW_CFA_undefined	int
;	O
break	O
;	O
case	O
DW_CFA_offset_extended_sf	int
:	O
case	O
DW_CFA_val_offset_sf	int
:	O
READ_ULEB	O
(	O
reg	int
,	O
start	pointer
,	O
end	pointer
)	O
;	O
SKIP_SLEB	O
(	O
start	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
frame_need_space	function
(	O
fc	pointer
,	O
reg	int
)	O
>=	O
0	int
)	O
fc	pointer
->	O
col_type	pointer
[	O
reg	int
]	O
=	O
DW_CFA_undefined	int
;	O
break	O
;	O
case	O
DW_CFA_def_cfa_sf	int
:	O
SKIP_ULEB	O
(	O
start	pointer
,	O
end	pointer
)	O
;	O
SKIP_SLEB	O
(	O
start	pointer
,	O
end	pointer
)	O
;	O
break	O
;	O
case	O
DW_CFA_def_cfa_offset_sf	int
:	O
SKIP_SLEB	O
(	O
start	pointer
,	O
end	pointer
)	O
;	O
break	O
;	O
case	O
DW_CFA_MIPS_advance_loc8	int
:	O
start	pointer
+=	O
8	int
;	O
break	O
;	O
case	O
DW_CFA_GNU_args_size	int
:	O
SKIP_ULEB	O
(	O
start	pointer
,	O
end	pointer
)	O
;	O
break	O
;	O
case	O
DW_CFA_GNU_negative_offset_extended	int
:	O
READ_ULEB	O
(	O
reg	int
,	O
start	pointer
,	O
end	pointer
)	O
;	O
SKIP_ULEB	O
(	O
start	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
frame_need_space	function
(	O
fc	pointer
,	O
reg	int
)	O
>=	O
0	int
)	O
fc	pointer
->	O
col_type	pointer
[	O
reg	int
]	O
=	O
DW_CFA_undefined	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
start	pointer
=	O
tmp	long
;	O
}	O
all_nops	int
=	O
TRUE	int
;	O
while	O
(	O
start	pointer
<	O
block_end	pointer
)	O
{	O
unsigned	O
char	O
*	O
tmp	long
;	O
unsigned	O
op	int
,	O
opa	int
;	O
unsigned	O
long	O
ul	long
,	O
roffs	long
;	O
unsigned	O
int	O
reg	int
;	O
dwarf_signed_vma	long
l	long
;	O
dwarf_vma	long
ofs	long
;	O
dwarf_vma	long
vma	long
;	O
const	O
char	O
*	O
reg_prefix	pointer
=	O
""	pointer
;	O
op	int
=	O
*	O
start	pointer
++	O
;	O
opa	int
=	O
op	int
&	O
0x3f	int
;	O
if	O
(	O
op	int
&	O
0xc0	int
)	O
op	int
&=	O
0xc0	int
;	O
if	O
(	O
op	int
!=	O
DW_CFA_nop	int
)	O
all_nops	int
=	O
FALSE	int
;	O
switch	O
(	O
op	int
)	O
{	O
case	O
DW_CFA_advance_loc	int
:	O
if	O
(	O
do_debug_frames_interp	int
)	O
frame_display_row	function
(	O
fc	pointer
,	O
&	O
need_col_headers	pointer
,	O
&	O
max_regs	pointer
)	O
;	O
else	O
printf	function
(	O
"  DW_CFA_advance_loc: %d to %s\n"	pointer
,	O
opa	int
*	O
fc	pointer
->	O
code_factor	int
,	O
dwarf_vmatoa_1	function
(	O
NULL	O
,	O
fc	pointer
->	O
pc_begin	long
+	O
opa	int
*	O
fc	pointer
->	O
code_factor	int
,	O
fc	pointer
->	O
ptr_size	pointer
)	O
)	O
;	O
fc	pointer
->	O
pc_begin	long
+=	O
opa	int
*	O
fc	pointer
->	O
code_factor	int
;	O
break	O
;	O
case	O
DW_CFA_offset	int
:	O
READ_ULEB	O
(	O
roffs	long
,	O
start	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
opa	int
>=	O
(	O
unsigned	O
int	O
)	O
fc	pointer
->	O
ncols	int
)	O
reg_prefix	pointer
=	O
bad_reg	pointer
;	O
if	O
(	O
!	O
do_debug_frames_interp	int
||	O
*	O
reg_prefix	pointer
!=	O
'\0'	O
)	O
printf	function
(	O
"  DW_CFA_offset: %s%s at cfa%+ld\n"	pointer
,	O
reg_prefix	pointer
,	O
regname	function
(	O
opa	int
,	O
0	int
)	O
,	O
roffs	long
*	O
fc	pointer
->	O
data_factor	int
)	O
;	O
if	O
(	O
*	O
reg_prefix	pointer
==	O
'\0'	O
)	O
{	O
fc	pointer
->	O
col_type	pointer
[	O
opa	int
]	O
=	O
DW_CFA_offset	int
;	O
fc	pointer
->	O
col_offset	pointer
[	O
opa	int
]	O
=	O
roffs	long
*	O
fc	pointer
->	O
data_factor	int
;	O
}	O
break	O
;	O
case	O
DW_CFA_restore	int
:	O
if	O
(	O
opa	int
>=	O
(	O
unsigned	O
int	O
)	O
fc	pointer
->	O
ncols	int
)	O
reg_prefix	pointer
=	O
bad_reg	pointer
;	O
if	O
(	O
!	O
do_debug_frames_interp	int
||	O
*	O
reg_prefix	pointer
!=	O
'\0'	O
)	O
printf	function
(	O
"  DW_CFA_restore: %s%s\n"	pointer
,	O
reg_prefix	pointer
,	O
regname	function
(	O
opa	int
,	O
0	int
)	O
)	O
;	O
if	O
(	O
*	O
reg_prefix	pointer
!=	O
'\0'	O
)	O
break	O
;	O
if	O
(	O
opa	int
>=	O
(	O
unsigned	O
int	O
)	O
cie	pointer
->	O
ncols	int
||	O
(	O
do_debug_frames_interp	int
&&	O
cie	pointer
->	O
col_type	pointer
[	O
opa	int
]	O
==	O
DW_CFA_unreferenced	O
)	O
)	O
{	O
fc	pointer
->	O
col_type	pointer
[	O
opa	int
]	O
=	O
DW_CFA_undefined	int
;	O
fc	pointer
->	O
col_offset	pointer
[	O
opa	int
]	O
=	O
0	int
;	O
}	O
else	O
{	O
fc	pointer
->	O
col_type	pointer
[	O
opa	int
]	O
=	O
cie	pointer
->	O
col_type	pointer
[	O
opa	int
]	O
;	O
fc	pointer
->	O
col_offset	pointer
[	O
opa	int
]	O
=	O
cie	pointer
->	O
col_offset	pointer
[	O
opa	int
]	O
;	O
}	O
break	O
;	O
case	O
DW_CFA_set_loc	int
:	O
vma	long
=	O
get_encoded_value	function
(	O
&	O
start	pointer
,	O
fc	pointer
->	O
fde_encoding	char
,	O
section	pointer
,	O
block_end	pointer
)	O
;	O
if	O
(	O
do_debug_frames_interp	int
)	O
frame_display_row	function
(	O
fc	pointer
,	O
&	O
need_col_headers	pointer
,	O
&	O
max_regs	pointer
)	O
;	O
else	O
printf	function
(	O
"  DW_CFA_set_loc: %s\n"	pointer
,	O
dwarf_vmatoa_1	function
(	O
NULL	O
,	O
vma	long
,	O
fc	pointer
->	O
ptr_size	pointer
)	O
)	O
;	O
fc	pointer
->	O
pc_begin	long
=	O
vma	long
;	O
break	O
;	O
case	O
DW_CFA_advance_loc1	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
ofs	long
,	O
start	pointer
,	O
1	int
,	O
end	pointer
)	O
;	O
if	O
(	O
do_debug_frames_interp	int
)	O
frame_display_row	function
(	O
fc	pointer
,	O
&	O
need_col_headers	pointer
,	O
&	O
max_regs	pointer
)	O
;	O
else	O
printf	function
(	O
"  DW_CFA_advance_loc1: %ld to %s\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
(	O
ofs	long
*	O
fc	pointer
->	O
code_factor	int
)	O
,	O
dwarf_vmatoa_1	function
(	O
NULL	O
,	O
fc	pointer
->	O
pc_begin	long
+	O
ofs	long
*	O
fc	pointer
->	O
code_factor	int
,	O
fc	pointer
->	O
ptr_size	pointer
)	O
)	O
;	O
fc	pointer
->	O
pc_begin	long
+=	O
ofs	long
*	O
fc	pointer
->	O
code_factor	int
;	O
break	O
;	O
case	O
DW_CFA_advance_loc2	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
ofs	long
,	O
start	pointer
,	O
2	int
,	O
block_end	pointer
)	O
;	O
if	O
(	O
do_debug_frames_interp	int
)	O
frame_display_row	function
(	O
fc	pointer
,	O
&	O
need_col_headers	pointer
,	O
&	O
max_regs	pointer
)	O
;	O
else	O
printf	function
(	O
"  DW_CFA_advance_loc2: %ld to %s\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
(	O
ofs	long
*	O
fc	pointer
->	O
code_factor	int
)	O
,	O
dwarf_vmatoa_1	function
(	O
NULL	O
,	O
fc	pointer
->	O
pc_begin	long
+	O
ofs	long
*	O
fc	pointer
->	O
code_factor	int
,	O
fc	pointer
->	O
ptr_size	pointer
)	O
)	O
;	O
fc	pointer
->	O
pc_begin	long
+=	O
ofs	long
*	O
fc	pointer
->	O
code_factor	int
;	O
break	O
;	O
case	O
DW_CFA_advance_loc4	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
ofs	long
,	O
start	pointer
,	O
4	int
,	O
block_end	pointer
)	O
;	O
if	O
(	O
do_debug_frames_interp	int
)	O
frame_display_row	function
(	O
fc	pointer
,	O
&	O
need_col_headers	pointer
,	O
&	O
max_regs	pointer
)	O
;	O
else	O
printf	function
(	O
"  DW_CFA_advance_loc4: %ld to %s\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
(	O
ofs	long
*	O
fc	pointer
->	O
code_factor	int
)	O
,	O
dwarf_vmatoa_1	function
(	O
NULL	O
,	O
fc	pointer
->	O
pc_begin	long
+	O
ofs	long
*	O
fc	pointer
->	O
code_factor	int
,	O
fc	pointer
->	O
ptr_size	pointer
)	O
)	O
;	O
fc	pointer
->	O
pc_begin	long
+=	O
ofs	long
*	O
fc	pointer
->	O
code_factor	int
;	O
break	O
;	O
case	O
DW_CFA_offset_extended	int
:	O
READ_ULEB	O
(	O
reg	int
,	O
start	pointer
,	O
end	pointer
)	O
;	O
READ_ULEB	O
(	O
roffs	long
,	O
start	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
reg	int
>=	O
(	O
unsigned	O
int	O
)	O
fc	pointer
->	O
ncols	int
)	O
reg_prefix	pointer
=	O
bad_reg	pointer
;	O
if	O
(	O
!	O
do_debug_frames_interp	int
||	O
*	O
reg_prefix	pointer
!=	O
'\0'	O
)	O
printf	function
(	O
"  DW_CFA_offset_extended: %s%s at cfa%+ld\n"	pointer
,	O
reg_prefix	pointer
,	O
regname	function
(	O
reg	int
,	O
0	int
)	O
,	O
roffs	long
*	O
fc	pointer
->	O
data_factor	int
)	O
;	O
if	O
(	O
*	O
reg_prefix	pointer
==	O
'\0'	O
)	O
{	O
fc	pointer
->	O
col_type	pointer
[	O
reg	int
]	O
=	O
DW_CFA_offset	int
;	O
fc	pointer
->	O
col_offset	pointer
[	O
reg	int
]	O
=	O
roffs	long
*	O
fc	pointer
->	O
data_factor	int
;	O
}	O
break	O
;	O
case	O
DW_CFA_val_offset	int
:	O
READ_ULEB	O
(	O
reg	int
,	O
start	pointer
,	O
end	pointer
)	O
;	O
READ_ULEB	O
(	O
roffs	long
,	O
start	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
reg	int
>=	O
(	O
unsigned	O
int	O
)	O
fc	pointer
->	O
ncols	int
)	O
reg_prefix	pointer
=	O
bad_reg	pointer
;	O
if	O
(	O
!	O
do_debug_frames_interp	int
||	O
*	O
reg_prefix	pointer
!=	O
'\0'	O
)	O
printf	function
(	O
"  DW_CFA_val_offset: %s%s is cfa%+ld\n"	pointer
,	O
reg_prefix	pointer
,	O
regname	function
(	O
reg	int
,	O
0	int
)	O
,	O
roffs	long
*	O
fc	pointer
->	O
data_factor	int
)	O
;	O
if	O
(	O
*	O
reg_prefix	pointer
==	O
'\0'	O
)	O
{	O
fc	pointer
->	O
col_type	pointer
[	O
reg	int
]	O
=	O
DW_CFA_val_offset	int
;	O
fc	pointer
->	O
col_offset	pointer
[	O
reg	int
]	O
=	O
roffs	long
*	O
fc	pointer
->	O
data_factor	int
;	O
}	O
break	O
;	O
case	O
DW_CFA_restore_extended	int
:	O
READ_ULEB	O
(	O
reg	int
,	O
start	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
reg	int
>=	O
(	O
unsigned	O
int	O
)	O
fc	pointer
->	O
ncols	int
)	O
reg_prefix	pointer
=	O
bad_reg	pointer
;	O
if	O
(	O
!	O
do_debug_frames_interp	int
||	O
*	O
reg_prefix	pointer
!=	O
'\0'	O
)	O
printf	function
(	O
"  DW_CFA_restore_extended: %s%s\n"	pointer
,	O
reg_prefix	pointer
,	O
regname	function
(	O
reg	int
,	O
0	int
)	O
)	O
;	O
if	O
(	O
*	O
reg_prefix	pointer
!=	O
'\0'	O
)	O
break	O
;	O
if	O
(	O
reg	int
>=	O
(	O
unsigned	O
int	O
)	O
cie	pointer
->	O
ncols	int
)	O
{	O
fc	pointer
->	O
col_type	pointer
[	O
reg	int
]	O
=	O
DW_CFA_undefined	int
;	O
fc	pointer
->	O
col_offset	pointer
[	O
reg	int
]	O
=	O
0	int
;	O
}	O
else	O
{	O
fc	pointer
->	O
col_type	pointer
[	O
reg	int
]	O
=	O
cie	pointer
->	O
col_type	pointer
[	O
reg	int
]	O
;	O
fc	pointer
->	O
col_offset	pointer
[	O
reg	int
]	O
=	O
cie	pointer
->	O
col_offset	pointer
[	O
reg	int
]	O
;	O
}	O
break	O
;	O
case	O
DW_CFA_undefined	int
:	O
READ_ULEB	O
(	O
reg	int
,	O
start	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
reg	int
>=	O
(	O
unsigned	O
int	O
)	O
fc	pointer
->	O
ncols	int
)	O
reg_prefix	pointer
=	O
bad_reg	pointer
;	O
if	O
(	O
!	O
do_debug_frames_interp	int
||	O
*	O
reg_prefix	pointer
!=	O
'\0'	O
)	O
printf	function
(	O
"  DW_CFA_undefined: %s%s\n"	pointer
,	O
reg_prefix	pointer
,	O
regname	function
(	O
reg	int
,	O
0	int
)	O
)	O
;	O
if	O
(	O
*	O
reg_prefix	pointer
==	O
'\0'	O
)	O
{	O
fc	pointer
->	O
col_type	pointer
[	O
reg	int
]	O
=	O
DW_CFA_undefined	int
;	O
fc	pointer
->	O
col_offset	pointer
[	O
reg	int
]	O
=	O
0	int
;	O
}	O
break	O
;	O
case	O
DW_CFA_same_value	int
:	O
READ_ULEB	O
(	O
reg	int
,	O
start	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
reg	int
>=	O
(	O
unsigned	O
int	O
)	O
fc	pointer
->	O
ncols	int
)	O
reg_prefix	pointer
=	O
bad_reg	pointer
;	O
if	O
(	O
!	O
do_debug_frames_interp	int
||	O
*	O
reg_prefix	pointer
!=	O
'\0'	O
)	O
printf	function
(	O
"  DW_CFA_same_value: %s%s\n"	pointer
,	O
reg_prefix	pointer
,	O
regname	function
(	O
reg	int
,	O
0	int
)	O
)	O
;	O
if	O
(	O
*	O
reg_prefix	pointer
==	O
'\0'	O
)	O
{	O
fc	pointer
->	O
col_type	pointer
[	O
reg	int
]	O
=	O
DW_CFA_same_value	int
;	O
fc	pointer
->	O
col_offset	pointer
[	O
reg	int
]	O
=	O
0	int
;	O
}	O
break	O
;	O
case	O
DW_CFA_register	int
:	O
READ_ULEB	O
(	O
reg	int
,	O
start	pointer
,	O
end	pointer
)	O
;	O
READ_ULEB	O
(	O
roffs	long
,	O
start	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
reg	int
>=	O
(	O
unsigned	O
int	O
)	O
fc	pointer
->	O
ncols	int
)	O
reg_prefix	pointer
=	O
bad_reg	pointer
;	O
if	O
(	O
!	O
do_debug_frames_interp	int
||	O
*	O
reg_prefix	pointer
!=	O
'\0'	O
)	O
{	O
printf	function
(	O
"  DW_CFA_register: %s%s in "	pointer
,	O
reg_prefix	pointer
,	O
regname	function
(	O
reg	int
,	O
0	int
)	O
)	O
;	O
puts	function
(	O
regname	function
(	O
roffs	long
,	O
0	int
)	O
)	O
;	O
}	O
if	O
(	O
*	O
reg_prefix	pointer
==	O
'\0'	O
)	O
{	O
fc	pointer
->	O
col_type	pointer
[	O
reg	int
]	O
=	O
DW_CFA_register	int
;	O
fc	pointer
->	O
col_offset	pointer
[	O
reg	int
]	O
=	O
roffs	long
;	O
}	O
break	O
;	O
case	O
DW_CFA_remember_state	int
:	O
if	O
(	O
!	O
do_debug_frames_interp	int
)	O
printf	function
(	O
"  DW_CFA_remember_state\n"	pointer
)	O
;	O
rs	pointer
=	O
(	O
Frame_Chunk	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
Frame_Chunk	struct
)	O
)	O
;	O
rs	pointer
->	O
cfa_offset	long
=	O
fc	pointer
->	O
cfa_offset	long
;	O
rs	pointer
->	O
cfa_reg	int
=	O
fc	pointer
->	O
cfa_reg	int
;	O
rs	pointer
->	O
ra	int
=	O
fc	pointer
->	O
ra	int
;	O
rs	pointer
->	O
cfa_exp	char
=	O
fc	pointer
->	O
cfa_exp	char
;	O
rs	pointer
->	O
ncols	int
=	O
fc	pointer
->	O
ncols	int
;	O
rs	pointer
->	O
col_type	pointer
=	O
(	O
short	O
int	O
*	O
)	O
xcmalloc	function
(	O
rs	pointer
->	O
ncols	int
,	O
sizeof	O
(	O
*	O
rs	pointer
->	O
col_type	pointer
)	O
)	O
;	O
rs	pointer
->	O
col_offset	pointer
=	O
(	O
int	O
*	O
)	O
xcmalloc	function
(	O
rs	pointer
->	O
ncols	int
,	O
sizeof	O
(	O
*	O
rs	pointer
->	O
col_offset	pointer
)	O
)	O
;	O
memcpy	function
(	O
rs	pointer
->	O
col_type	pointer
,	O
fc	pointer
->	O
col_type	pointer
,	O
rs	pointer
->	O
ncols	int
*	O
sizeof	O
(	O
*	O
fc	pointer
->	O
col_type	pointer
)	O
)	O
;	O
memcpy	function
(	O
rs	pointer
->	O
col_offset	pointer
,	O
fc	pointer
->	O
col_offset	pointer
,	O
rs	pointer
->	O
ncols	int
*	O
sizeof	O
(	O
*	O
fc	pointer
->	O
col_offset	pointer
)	O
)	O
;	O
rs	pointer
->	O
next	pointer
=	O
remembered_state	pointer
;	O
remembered_state	pointer
=	O
rs	pointer
;	O
break	O
;	O
case	O
DW_CFA_restore_state	int
:	O
if	O
(	O
!	O
do_debug_frames_interp	int
)	O
printf	function
(	O
"  DW_CFA_restore_state\n"	pointer
)	O
;	O
rs	pointer
=	O
remembered_state	pointer
;	O
if	O
(	O
rs	pointer
)	O
{	O
remembered_state	pointer
=	O
rs	pointer
->	O
next	pointer
;	O
fc	pointer
->	O
cfa_offset	long
=	O
rs	pointer
->	O
cfa_offset	long
;	O
fc	pointer
->	O
cfa_reg	int
=	O
rs	pointer
->	O
cfa_reg	int
;	O
fc	pointer
->	O
ra	int
=	O
rs	pointer
->	O
ra	int
;	O
fc	pointer
->	O
cfa_exp	char
=	O
rs	pointer
->	O
cfa_exp	char
;	O
if	O
(	O
frame_need_space	function
(	O
fc	pointer
,	O
rs	pointer
->	O
ncols	int
-	O
1	int
)	O
<	O
0	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Invalid column number in saved frame state\n"	pointer
)	O
)	O
;	O
fc	pointer
->	O
ncols	int
=	O
0	int
;	O
break	O
;	O
}	O
memcpy	function
(	O
fc	pointer
->	O
col_type	pointer
,	O
rs	pointer
->	O
col_type	pointer
,	O
rs	pointer
->	O
ncols	int
*	O
sizeof	O
(	O
*	O
rs	pointer
->	O
col_type	pointer
)	O
)	O
;	O
memcpy	function
(	O
fc	pointer
->	O
col_offset	pointer
,	O
rs	pointer
->	O
col_offset	pointer
,	O
rs	pointer
->	O
ncols	int
*	O
sizeof	O
(	O
*	O
rs	pointer
->	O
col_offset	pointer
)	O
)	O
;	O
free	function
(	O
rs	pointer
->	O
col_type	pointer
)	O
;	O
free	function
(	O
rs	pointer
->	O
col_offset	pointer
)	O
;	O
free	function
(	O
rs	pointer
)	O
;	O
}	O
else	O
if	O
(	O
do_debug_frames_interp	int
)	O
printf	function
(	O
"Mismatched DW_CFA_restore_state\n"	pointer
)	O
;	O
break	O
;	O
case	O
DW_CFA_def_cfa	int
:	O
READ_ULEB	O
(	O
fc	pointer
->	O
cfa_reg	int
,	O
start	pointer
,	O
end	pointer
)	O
;	O
READ_ULEB	O
(	O
fc	pointer
->	O
cfa_offset	long
,	O
start	pointer
,	O
end	pointer
)	O
;	O
fc	pointer
->	O
cfa_exp	char
=	O
0	int
;	O
if	O
(	O
!	O
do_debug_frames_interp	int
)	O
printf	function
(	O
"  DW_CFA_def_cfa: %s ofs %d\n"	pointer
,	O
regname	function
(	O
fc	pointer
->	O
cfa_reg	int
,	O
0	int
)	O
,	O
(	O
int	O
)	O
fc	pointer
->	O
cfa_offset	long
)	O
;	O
break	O
;	O
case	O
DW_CFA_def_cfa_register	int
:	O
READ_ULEB	O
(	O
fc	pointer
->	O
cfa_reg	int
,	O
start	pointer
,	O
end	pointer
)	O
;	O
fc	pointer
->	O
cfa_exp	char
=	O
0	int
;	O
if	O
(	O
!	O
do_debug_frames_interp	int
)	O
printf	function
(	O
"  DW_CFA_def_cfa_register: %s\n"	pointer
,	O
regname	function
(	O
fc	pointer
->	O
cfa_reg	int
,	O
0	int
)	O
)	O
;	O
break	O
;	O
case	O
DW_CFA_def_cfa_offset	int
:	O
READ_ULEB	O
(	O
fc	pointer
->	O
cfa_offset	long
,	O
start	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
!	O
do_debug_frames_interp	int
)	O
printf	function
(	O
"  DW_CFA_def_cfa_offset: %d\n"	pointer
,	O
(	O
int	O
)	O
fc	pointer
->	O
cfa_offset	long
)	O
;	O
break	O
;	O
case	O
DW_CFA_nop	int
:	O
if	O
(	O
!	O
do_debug_frames_interp	int
)	O
printf	function
(	O
"  DW_CFA_nop\n"	pointer
)	O
;	O
break	O
;	O
case	O
DW_CFA_def_cfa_expression	int
:	O
READ_ULEB	O
(	O
ul	long
,	O
start	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
start	pointer
>=	O
block_end	pointer
||	O
ul	long
>	O
(	O
unsigned	O
long	O
)	O
(	O
block_end	pointer
-	O
start	pointer
)	O
)	O
{	O
printf	function
(	O
_	O
(	O
"  DW_CFA_def_cfa_expression: <corrupt len %lu>\n"	pointer
)	O
,	O
ul	long
)	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
do_debug_frames_interp	int
)	O
{	O
printf	function
(	O
"  DW_CFA_def_cfa_expression ("	pointer
)	O
;	O
decode_location_expression	function
(	O
start	pointer
,	O
eh_addr_size	int
,	O
0	int
,	O
-	O
1	int
,	O
ul	long
,	O
0	int
,	O
section	pointer
)	O
;	O
printf	function
(	O
")\n"	pointer
)	O
;	O
}	O
fc	pointer
->	O
cfa_exp	char
=	O
1	int
;	O
start	pointer
+=	O
ul	long
;	O
break	O
;	O
case	O
DW_CFA_expression	int
:	O
READ_ULEB	O
(	O
reg	int
,	O
start	pointer
,	O
end	pointer
)	O
;	O
READ_ULEB	O
(	O
ul	long
,	O
start	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
reg	int
>=	O
(	O
unsigned	O
int	O
)	O
fc	pointer
->	O
ncols	int
)	O
reg_prefix	pointer
=	O
bad_reg	pointer
;	O
tmp	long
=	O
start	pointer
+	O
ul	long
;	O
if	O
(	O
start	pointer
>=	O
block_end	pointer
||	O
tmp	long
>	O
block_end	pointer
||	O
tmp	long
<	O
start	pointer
)	O
{	O
printf	function
(	O
_	O
(	O
"  DW_CFA_expression: <corrupt len %lu>\n"	pointer
)	O
,	O
ul	long
)	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
do_debug_frames_interp	int
||	O
*	O
reg_prefix	pointer
!=	O
'\0'	O
)	O
{	O
printf	function
(	O
"  DW_CFA_expression: %s%s ("	pointer
,	O
reg_prefix	pointer
,	O
regname	function
(	O
reg	int
,	O
0	int
)	O
)	O
;	O
decode_location_expression	function
(	O
start	pointer
,	O
eh_addr_size	int
,	O
0	int
,	O
-	O
1	int
,	O
ul	long
,	O
0	int
,	O
section	pointer
)	O
;	O
printf	function
(	O
")\n"	pointer
)	O
;	O
}	O
if	O
(	O
*	O
reg_prefix	pointer
==	O
'\0'	O
)	O
fc	pointer
->	O
col_type	pointer
[	O
reg	int
]	O
=	O
DW_CFA_expression	int
;	O
start	pointer
=	O
tmp	long
;	O
break	O
;	O
case	O
DW_CFA_val_expression	int
:	O
READ_ULEB	O
(	O
reg	int
,	O
start	pointer
,	O
end	pointer
)	O
;	O
READ_ULEB	O
(	O
ul	long
,	O
start	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
reg	int
>=	O
(	O
unsigned	O
int	O
)	O
fc	pointer
->	O
ncols	int
)	O
reg_prefix	pointer
=	O
bad_reg	pointer
;	O
tmp	long
=	O
start	pointer
+	O
ul	long
;	O
if	O
(	O
start	pointer
>=	O
block_end	pointer
||	O
tmp	long
>	O
block_end	pointer
||	O
tmp	long
<	O
start	pointer
)	O
{	O
printf	function
(	O
"  DW_CFA_val_expression: <corrupt len %lu>\n"	pointer
,	O
ul	long
)	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
do_debug_frames_interp	int
||	O
*	O
reg_prefix	pointer
!=	O
'\0'	O
)	O
{	O
printf	function
(	O
"  DW_CFA_val_expression: %s%s ("	pointer
,	O
reg_prefix	pointer
,	O
regname	function
(	O
reg	int
,	O
0	int
)	O
)	O
;	O
decode_location_expression	function
(	O
start	pointer
,	O
eh_addr_size	int
,	O
0	int
,	O
-	O
1	int
,	O
ul	long
,	O
0	int
,	O
section	pointer
)	O
;	O
printf	function
(	O
")\n"	pointer
)	O
;	O
}	O
if	O
(	O
*	O
reg_prefix	pointer
==	O
'\0'	O
)	O
fc	pointer
->	O
col_type	pointer
[	O
reg	int
]	O
=	O
DW_CFA_val_expression	int
;	O
start	pointer
=	O
tmp	long
;	O
break	O
;	O
case	O
DW_CFA_offset_extended_sf	int
:	O
READ_ULEB	O
(	O
reg	int
,	O
start	pointer
,	O
end	pointer
)	O
;	O
READ_SLEB	O
(	O
l	long
,	O
start	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
frame_need_space	function
(	O
fc	pointer
,	O
reg	int
)	O
<	O
0	int
)	O
reg_prefix	pointer
=	O
bad_reg	pointer
;	O
if	O
(	O
!	O
do_debug_frames_interp	int
||	O
*	O
reg_prefix	pointer
!=	O
'\0'	O
)	O
printf	function
(	O
"  DW_CFA_offset_extended_sf: %s%s at cfa%+ld\n"	pointer
,	O
reg_prefix	pointer
,	O
regname	function
(	O
reg	int
,	O
0	int
)	O
,	O
(	O
long	O
)	O
(	O
l	long
*	O
fc	pointer
->	O
data_factor	int
)	O
)	O
;	O
if	O
(	O
*	O
reg_prefix	pointer
==	O
'\0'	O
)	O
{	O
fc	pointer
->	O
col_type	pointer
[	O
reg	int
]	O
=	O
DW_CFA_offset	int
;	O
fc	pointer
->	O
col_offset	pointer
[	O
reg	int
]	O
=	O
l	long
*	O
fc	pointer
->	O
data_factor	int
;	O
}	O
break	O
;	O
case	O
DW_CFA_val_offset_sf	int
:	O
READ_ULEB	O
(	O
reg	int
,	O
start	pointer
,	O
end	pointer
)	O
;	O
READ_SLEB	O
(	O
l	long
,	O
start	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
frame_need_space	function
(	O
fc	pointer
,	O
reg	int
)	O
<	O
0	int
)	O
reg_prefix	pointer
=	O
bad_reg	pointer
;	O
if	O
(	O
!	O
do_debug_frames_interp	int
||	O
*	O
reg_prefix	pointer
!=	O
'\0'	O
)	O
printf	function
(	O
"  DW_CFA_val_offset_sf: %s%s is cfa%+ld\n"	pointer
,	O
reg_prefix	pointer
,	O
regname	function
(	O
reg	int
,	O
0	int
)	O
,	O
(	O
long	O
)	O
(	O
l	long
*	O
fc	pointer
->	O
data_factor	int
)	O
)	O
;	O
if	O
(	O
*	O
reg_prefix	pointer
==	O
'\0'	O
)	O
{	O
fc	pointer
->	O
col_type	pointer
[	O
reg	int
]	O
=	O
DW_CFA_val_offset	int
;	O
fc	pointer
->	O
col_offset	pointer
[	O
reg	int
]	O
=	O
l	long
*	O
fc	pointer
->	O
data_factor	int
;	O
}	O
break	O
;	O
case	O
DW_CFA_def_cfa_sf	int
:	O
READ_ULEB	O
(	O
fc	pointer
->	O
cfa_reg	int
,	O
start	pointer
,	O
end	pointer
)	O
;	O
READ_ULEB	O
(	O
fc	pointer
->	O
cfa_offset	long
,	O
start	pointer
,	O
end	pointer
)	O
;	O
fc	pointer
->	O
cfa_offset	long
=	O
fc	pointer
->	O
cfa_offset	long
*	O
fc	pointer
->	O
data_factor	int
;	O
fc	pointer
->	O
cfa_exp	char
=	O
0	int
;	O
if	O
(	O
!	O
do_debug_frames_interp	int
)	O
printf	function
(	O
"  DW_CFA_def_cfa_sf: %s ofs %d\n"	pointer
,	O
regname	function
(	O
fc	pointer
->	O
cfa_reg	int
,	O
0	int
)	O
,	O
(	O
int	O
)	O
fc	pointer
->	O
cfa_offset	long
)	O
;	O
break	O
;	O
case	O
DW_CFA_def_cfa_offset_sf	int
:	O
READ_ULEB	O
(	O
fc	pointer
->	O
cfa_offset	long
,	O
start	pointer
,	O
end	pointer
)	O
;	O
fc	pointer
->	O
cfa_offset	long
*=	O
fc	pointer
->	O
data_factor	int
;	O
if	O
(	O
!	O
do_debug_frames_interp	int
)	O
printf	function
(	O
"  DW_CFA_def_cfa_offset_sf: %d\n"	pointer
,	O
(	O
int	O
)	O
fc	pointer
->	O
cfa_offset	long
)	O
;	O
break	O
;	O
case	O
DW_CFA_MIPS_advance_loc8	int
:	O
SAFE_BYTE_GET_AND_INC	O
(	O
ofs	long
,	O
start	pointer
,	O
8	int
,	O
block_end	pointer
)	O
;	O
if	O
(	O
do_debug_frames_interp	int
)	O
frame_display_row	function
(	O
fc	pointer
,	O
&	O
need_col_headers	pointer
,	O
&	O
max_regs	pointer
)	O
;	O
else	O
printf	function
(	O
"  DW_CFA_MIPS_advance_loc8: %ld to %s\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
(	O
ofs	long
*	O
fc	pointer
->	O
code_factor	int
)	O
,	O
dwarf_vmatoa_1	function
(	O
NULL	O
,	O
fc	pointer
->	O
pc_begin	long
+	O
ofs	long
*	O
fc	pointer
->	O
code_factor	int
,	O
fc	pointer
->	O
ptr_size	pointer
)	O
)	O
;	O
fc	pointer
->	O
pc_begin	long
+=	O
ofs	long
*	O
fc	pointer
->	O
code_factor	int
;	O
break	O
;	O
case	O
DW_CFA_GNU_window_save	int
:	O
if	O
(	O
!	O
do_debug_frames_interp	int
)	O
printf	function
(	O
"  DW_CFA_GNU_window_save\n"	pointer
)	O
;	O
break	O
;	O
case	O
DW_CFA_GNU_args_size	int
:	O
READ_ULEB	O
(	O
ul	long
,	O
start	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
!	O
do_debug_frames_interp	int
)	O
printf	function
(	O
"  DW_CFA_GNU_args_size: %ld\n"	pointer
,	O
ul	long
)	O
;	O
break	O
;	O
case	O
DW_CFA_GNU_negative_offset_extended	int
:	O
READ_ULEB	O
(	O
reg	int
,	O
start	pointer
,	O
end	pointer
)	O
;	O
READ_SLEB	O
(	O
l	long
,	O
start	pointer
,	O
end	pointer
)	O
;	O
l	long
=	O
-	O
l	long
;	O
if	O
(	O
frame_need_space	function
(	O
fc	pointer
,	O
reg	int
)	O
<	O
0	int
)	O
reg_prefix	pointer
=	O
bad_reg	pointer
;	O
if	O
(	O
!	O
do_debug_frames_interp	int
||	O
*	O
reg_prefix	pointer
!=	O
'\0'	O
)	O
printf	function
(	O
"  DW_CFA_GNU_negative_offset_extended: %s%s at cfa%+ld\n"	pointer
,	O
reg_prefix	pointer
,	O
regname	function
(	O
reg	int
,	O
0	int
)	O
,	O
(	O
long	O
)	O
(	O
l	long
*	O
fc	pointer
->	O
data_factor	int
)	O
)	O
;	O
if	O
(	O
*	O
reg_prefix	pointer
==	O
'\0'	O
)	O
{	O
fc	pointer
->	O
col_type	pointer
[	O
reg	int
]	O
=	O
DW_CFA_offset	int
;	O
fc	pointer
->	O
col_offset	pointer
[	O
reg	int
]	O
=	O
l	long
*	O
fc	pointer
->	O
data_factor	int
;	O
}	O
break	O
;	O
default	O
:	O
if	O
(	O
op	int
>=	O
DW_CFA_lo_user	int
&&	O
op	int
<=	O
DW_CFA_hi_user	int
)	O
printf	function
(	O
_	O
(	O
"  DW_CFA_??? (User defined call frame op: %#x)\n"	pointer
)	O
,	O
op	int
)	O
;	O
else	O
warn	function
(	O
_	O
(	O
"Unsupported or unknown Dwarf Call Frame Instruction number: %#x\n"	pointer
)	O
,	O
op	int
)	O
;	O
start	pointer
=	O
block_end	pointer
;	O
}	O
}	O
if	O
(	O
do_debug_frames_interp	int
&&	O
!	O
all_nops	int
)	O
frame_display_row	function
(	O
fc	pointer
,	O
&	O
need_col_headers	pointer
,	O
&	O
max_regs	pointer
)	O
;	O
if	O
(	O
fde_fc	struct
.	O
col_type	pointer
!=	O
NULL	O
)	O
{	O
free	function
(	O
fde_fc	struct
.	O
col_type	pointer
)	O
;	O
fde_fc	struct
.	O
col_type	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
fde_fc	struct
.	O
col_offset	pointer
!=	O
NULL	O
)	O
{	O
free	function
(	O
fde_fc	struct
.	O
col_offset	pointer
)	O
;	O
fde_fc	struct
.	O
col_offset	pointer
=	O
NULL	O
;	O
}	O
start	pointer
=	O
block_end	pointer
;	O
eh_addr_size	int
=	O
saved_eh_addr_size	int
;	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
while	O
(	O
remembered_state	pointer
!=	O
NULL	O
)	O
{	O
rs	pointer
=	O
remembered_state	pointer
;	O
remembered_state	pointer
=	O
rs	pointer
->	O
next	pointer
;	O
free	function
(	O
rs	pointer
->	O
col_type	pointer
)	O
;	O
free	function
(	O
rs	pointer
->	O
col_offset	pointer
)	O
;	O
rs	pointer
->	O
next	pointer
=	O
NULL	O
;	O
free	function
(	O
rs	pointer
)	O
;	O
}	O
while	O
(	O
chunks	pointer
!=	O
NULL	O
)	O
{	O
rs	pointer
=	O
chunks	pointer
;	O
chunks	pointer
=	O
rs	pointer
->	O
next	pointer
;	O
free	function
(	O
rs	pointer
->	O
col_type	pointer
)	O
;	O
free	function
(	O
rs	pointer
->	O
col_offset	pointer
)	O
;	O
rs	pointer
->	O
next	pointer
=	O
NULL	O
;	O
free	function
(	O
rs	pointer
)	O
;	O
}	O
while	O
(	O
forward_refs	pointer
!=	O
NULL	O
)	O
{	O
rs	pointer
=	O
forward_refs	pointer
;	O
forward_refs	pointer
=	O
rs	pointer
->	O
next	pointer
;	O
free	function
(	O
rs	pointer
->	O
col_type	pointer
)	O
;	O
free	function
(	O
rs	pointer
->	O
col_offset	pointer
)	O
;	O
rs	pointer
->	O
next	pointer
=	O
NULL	O
;	O
free	function
(	O
rs	pointer
)	O
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
display_debug_names	function
(	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
void	O
*	O
file	pointer
)	O
{	O
unsigned	O
char	O
*	O
hdrptr	pointer
=	O
section	pointer
->	O
start	pointer
;	O
dwarf_vma	long
unit_length	long
;	O
unsigned	O
char	O
*	O
unit_start	pointer
;	O
const	O
unsigned	O
char	O
*	O
const	O
section_end	pointer
=	O
section	pointer
->	O
start	pointer
+	O
section	pointer
->	O
size	int
;	O
unsigned	O
char	O
*	O
unit_end	pointer
;	O
introduce	function
(	O
section	pointer
,	O
FALSE	int
)	O
;	O
load_debug_section_with_follow	function
(	O
str	int
,	O
file	pointer
)	O
;	O
for	O
(	O
;	O
hdrptr	pointer
<	O
section_end	pointer
;	O
hdrptr	pointer
=	O
unit_end	pointer
)	O
{	O
unsigned	O
int	O
offset_size	int
;	O
uint16_t	short
dwarf_version	int
,	O
padding	short
;	O
uint32_t	int
comp_unit_count	int
,	O
local_type_unit_count	int
,	O
foreign_type_unit_count	int
;	O
uint32_t	int
bucket_count	int
,	O
name_count	int
,	O
abbrev_table_size	int
;	O
uint32_t	int
augmentation_string_size	int
;	O
unsigned	O
int	O
i	pointer
;	O
unsigned	O
long	O
sec_off	long
;	O
bfd_boolean	int
augmentation_printable	int
;	O
const	O
char	O
*	O
augmentation_string	pointer
;	O
unit_start	pointer
=	O
hdrptr	pointer
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
unit_length	long
,	O
hdrptr	pointer
,	O
4	int
,	O
section_end	pointer
)	O
;	O
if	O
(	O
unit_length	long
==	O
0xffffffff	int
)	O
{	O
SAFE_BYTE_GET_AND_INC	O
(	O
unit_length	long
,	O
hdrptr	pointer
,	O
8	int
,	O
section_end	pointer
)	O
;	O
offset_size	int
=	O
8	int
;	O
}	O
else	O
offset_size	int
=	O
4	int
;	O
unit_end	pointer
=	O
hdrptr	pointer
+	O
unit_length	long
;	O
sec_off	long
=	O
hdrptr	pointer
-	O
section	pointer
->	O
start	pointer
;	O
if	O
(	O
sec_off	long
+	O
unit_length	long
<	O
sec_off	long
||	O
sec_off	long
+	O
unit_length	long
>	O
section	pointer
->	O
size	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Debug info is corrupted, %s header at %#lx has length %s\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
,	O
(	O
unsigned	O
long	O
)	O
(	O
unit_start	pointer
-	O
section	pointer
->	O
start	pointer
)	O
,	O
dwarf_vmatoa	function
(	O
"x"	pointer
,	O
unit_length	long
)	O
)	O
;	O
return	O
0	int
;	O
}	O
SAFE_BYTE_GET_AND_INC	O
(	O
dwarf_version	int
,	O
hdrptr	pointer
,	O
2	int
,	O
unit_end	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Version %ld\n"	pointer
)	O
,	O
(	O
long	O
)	O
dwarf_version	int
)	O
;	O
if	O
(	O
dwarf_version	int
!=	O
5	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Only DWARF version 5 .debug_names "	pointer
"is currently supported.\n"	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
SAFE_BYTE_GET_AND_INC	O
(	O
padding	short
,	O
hdrptr	pointer
,	O
2	int
,	O
unit_end	pointer
)	O
;	O
if	O
(	O
padding	short
!=	O
0	int
)	O
warn	function
(	O
_	O
(	O
"Padding field of .debug_names must be 0 (found 0x%x)\n"	pointer
)	O
,	O
padding	short
)	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
comp_unit_count	int
,	O
hdrptr	pointer
,	O
4	int
,	O
unit_end	pointer
)	O
;	O
if	O
(	O
comp_unit_count	int
==	O
0	int
)	O
warn	function
(	O
_	O
(	O
"Compilation unit count must be >= 1 in .debug_names\n"	pointer
)	O
)	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
local_type_unit_count	int
,	O
hdrptr	pointer
,	O
4	int
,	O
unit_end	pointer
)	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
foreign_type_unit_count	int
,	O
hdrptr	pointer
,	O
4	int
,	O
unit_end	pointer
)	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
bucket_count	int
,	O
hdrptr	pointer
,	O
4	int
,	O
unit_end	pointer
)	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
name_count	int
,	O
hdrptr	pointer
,	O
4	int
,	O
unit_end	pointer
)	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
abbrev_table_size	int
,	O
hdrptr	pointer
,	O
4	int
,	O
unit_end	pointer
)	O
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
augmentation_string_size	int
,	O
hdrptr	pointer
,	O
4	int
,	O
unit_end	pointer
)	O
;	O
if	O
(	O
augmentation_string_size	int
%	O
4	int
!=	O
0	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Augmentation string length %u must be rounded up "	pointer
"to a multiple of 4 in .debug_names.\n"	pointer
)	O
,	O
augmentation_string_size	int
)	O
;	O
augmentation_string_size	int
+=	O
(	O
-	O
augmentation_string_size	int
)	O
&	O
3	int
;	O
}	O
printf	function
(	O
_	O
(	O
"Augmentation string:"	pointer
)	O
)	O
;	O
augmentation_printable	int
=	O
TRUE	int
;	O
augmentation_string	pointer
=	O
(	O
const	O
char	O
*	O
)	O
hdrptr	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
augmentation_string_size	int
;	O
i	pointer
++	O
)	O
{	O
unsigned	O
char	O
uc	char
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
uc	char
,	O
hdrptr	pointer
,	O
1	int
,	O
unit_end	pointer
)	O
;	O
printf	function
(	O
" %02x"	pointer
,	O
uc	char
)	O
;	O
if	O
(	O
uc	char
!=	O
0	int
&&	O
!	O
ISPRINT	O
(	O
uc	char
)	O
)	O
augmentation_printable	int
=	O
FALSE	int
;	O
}	O
if	O
(	O
augmentation_printable	int
)	O
{	O
printf	function
(	O
"  (\""	pointer
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
augmentation_string_size	int
&&	O
augmentation_string	pointer
[	O
i	pointer
]	O
;	O
++	O
i	pointer
)	O
putchar	function
(	O
augmentation_string	pointer
[	O
i	pointer
]	O
)	O
;	O
printf	function
(	O
"\")"	pointer
)	O
;	O
}	O
putchar	function
(	O
'\n'	O
)	O
;	O
printf	function
(	O
_	O
(	O
"CU table:\n"	pointer
)	O
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
comp_unit_count	int
;	O
i	pointer
++	O
)	O
{	O
uint64_t	long
cu_offset	long
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
cu_offset	long
,	O
hdrptr	pointer
,	O
offset_size	int
,	O
unit_end	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"[%3u] 0x%lx\n"	pointer
)	O
,	O
i	pointer
,	O
(	O
unsigned	O
long	O
)	O
cu_offset	long
)	O
;	O
}	O
putchar	function
(	O
'\n'	O
)	O
;	O
printf	function
(	O
_	O
(	O
"TU table:\n"	pointer
)	O
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
local_type_unit_count	int
;	O
i	pointer
++	O
)	O
{	O
uint64_t	long
tu_offset	long
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
tu_offset	long
,	O
hdrptr	pointer
,	O
offset_size	int
,	O
unit_end	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"[%3u] 0x%lx\n"	pointer
)	O
,	O
i	pointer
,	O
(	O
unsigned	O
long	O
)	O
tu_offset	long
)	O
;	O
}	O
putchar	function
(	O
'\n'	O
)	O
;	O
printf	function
(	O
_	O
(	O
"Foreign TU table:\n"	pointer
)	O
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
foreign_type_unit_count	int
;	O
i	pointer
++	O
)	O
{	O
uint64_t	long
signature	long
;	O
SAFE_BYTE_GET_AND_INC	O
(	O
signature	long
,	O
hdrptr	pointer
,	O
8	int
,	O
unit_end	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"[%3u] "	pointer
)	O
,	O
i	pointer
)	O
;	O
print_dwarf_vma	function
(	O
signature	long
,	O
8	int
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
putchar	function
(	O
'\n'	O
)	O
;	O
const	O
uint32_t	int
*	O
const	O
hash_table_buckets	pointer
=	O
(	O
uint32_t	int
*	O
)	O
hdrptr	pointer
;	O
hdrptr	pointer
+=	O
bucket_count	int
*	O
sizeof	O
(	O
uint32_t	int
)	O
;	O
const	O
uint32_t	int
*	O
const	O
hash_table_hashes	pointer
=	O
(	O
uint32_t	int
*	O
)	O
hdrptr	pointer
;	O
hdrptr	pointer
+=	O
name_count	int
*	O
sizeof	O
(	O
uint32_t	int
)	O
;	O
unsigned	O
char	O
*	O
const	O
name_table_string_offsets	pointer
=	O
hdrptr	pointer
;	O
hdrptr	pointer
+=	O
name_count	int
*	O
offset_size	int
;	O
unsigned	O
char	O
*	O
const	O
name_table_entry_offsets	pointer
=	O
hdrptr	pointer
;	O
hdrptr	pointer
+=	O
name_count	int
*	O
offset_size	int
;	O
unsigned	O
char	O
*	O
const	O
abbrev_table	pointer
=	O
hdrptr	pointer
;	O
hdrptr	pointer
+=	O
abbrev_table_size	int
;	O
const	O
unsigned	O
char	O
*	O
const	O
abbrev_table_end	pointer
=	O
hdrptr	pointer
;	O
unsigned	O
char	O
*	O
const	O
entry_pool	pointer
=	O
hdrptr	pointer
;	O
if	O
(	O
hdrptr	pointer
>	O
unit_end	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"Entry pool offset (0x%lx) exceeds unit size 0x%lx "	pointer
"for unit 0x%lx in the debug_names\n"	pointer
)	O
,	O
(	O
long	O
)	O
(	O
hdrptr	pointer
-	O
section	pointer
->	O
start	pointer
)	O
,	O
(	O
long	O
)	O
(	O
unit_end	pointer
-	O
section	pointer
->	O
start	pointer
)	O
,	O
(	O
long	O
)	O
(	O
unit_start	pointer
-	O
section	pointer
->	O
start	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
size_t	long
buckets_filled	long
=	O
0	int
;	O
size_t	long
bucketi	long
;	O
for	O
(	O
bucketi	long
=	O
0	int
;	O
bucketi	long
<	O
bucket_count	int
;	O
bucketi	long
++	O
)	O
{	O
const	O
uint32_t	int
bucket	int
=	O
hash_table_buckets	pointer
[	O
bucketi	long
]	O
;	O
if	O
(	O
bucket	int
!=	O
0	int
)	O
++	O
buckets_filled	long
;	O
}	O
printf	function
(	O
ngettext	function
(	O
"Used %zu of %lu bucket.\n"	pointer
,	O
"Used %zu of %lu buckets.\n"	pointer
,	O
bucket_count	int
)	O
,	O
buckets_filled	long
,	O
(	O
unsigned	O
long	O
)	O
bucket_count	int
)	O
;	O
uint32_t	int
hash_prev	int
=	O
0	int
;	O
size_t	long
hash_clash_count	long
=	O
0	int
;	O
size_t	long
longest_clash	long
=	O
0	int
;	O
size_t	long
this_length	long
=	O
0	int
;	O
size_t	long
hashi	long
;	O
for	O
(	O
hashi	long
=	O
0	int
;	O
hashi	long
<	O
name_count	int
;	O
hashi	long
++	O
)	O
{	O
const	O
uint32_t	int
hash_this	int
=	O
hash_table_hashes	pointer
[	O
hashi	long
]	O
;	O
if	O
(	O
hashi	long
>	O
0	int
)	O
{	O
if	O
(	O
hash_prev	int
%	O
bucket_count	int
==	O
hash_this	int
%	O
bucket_count	int
)	O
{	O
++	O
hash_clash_count	long
;	O
++	O
this_length	long
;	O
longest_clash	long
=	O
MAX	O
(	O
longest_clash	long
,	O
this_length	long
)	O
;	O
}	O
else	O
this_length	long
=	O
0	int
;	O
}	O
hash_prev	int
=	O
hash_this	int
;	O
}	O
printf	function
(	O
_	O
(	O
"Out of %lu items there are %zu bucket clashes"	pointer
" (longest of %zu entries).\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
name_count	int
,	O
hash_clash_count	long
,	O
longest_clash	long
)	O
;	O
assert	O
(	O
name_count	int
==	O
buckets_filled	long
+	O
hash_clash_count	long
)	O
;	O
struct	O
abbrev_lookup_entry	struct
{	O
dwarf_vma	long
abbrev_tag	long
;	O
unsigned	O
char	O
*	O
abbrev_lookup_ptr	pointer
;	O
}	O
;	O
struct	O
abbrev_lookup_entry	struct
*	O
abbrev_lookup	pointer
=	O
NULL	O
;	O
size_t	long
abbrev_lookup_used	long
=	O
0	int
;	O
size_t	long
abbrev_lookup_allocated	long
=	O
0	int
;	O
unsigned	O
char	O
*	O
abbrevptr	pointer
=	O
abbrev_table	pointer
;	O
for	O
(	O
;	O
;	O
)	O
{	O
dwarf_vma	long
abbrev_tag	long
;	O
READ_ULEB	O
(	O
abbrev_tag	long
,	O
abbrevptr	pointer
,	O
abbrev_table_end	pointer
)	O
;	O
if	O
(	O
abbrev_tag	long
==	O
0	int
)	O
break	O
;	O
if	O
(	O
abbrev_lookup_used	long
==	O
abbrev_lookup_allocated	long
)	O
{	O
abbrev_lookup_allocated	long
=	O
MAX	O
(	O
0x100	int
,	O
abbrev_lookup_allocated	long
*	O
2	int
)	O
;	O
abbrev_lookup	pointer
=	O
xrealloc	function
(	O
abbrev_lookup	pointer
,	O
(	O
abbrev_lookup_allocated	long
*	O
sizeof	O
(	O
*	O
abbrev_lookup	pointer
)	O
)	O
)	O
;	O
}	O
assert	O
(	O
abbrev_lookup_used	long
<	O
abbrev_lookup_allocated	long
)	O
;	O
struct	O
abbrev_lookup_entry	struct
*	O
entry	long
;	O
for	O
(	O
entry	long
=	O
abbrev_lookup	pointer
;	O
entry	long
<	O
abbrev_lookup	pointer
+	O
abbrev_lookup_used	long
;	O
entry	long
++	O
)	O
if	O
(	O
entry	long
->	O
abbrev_tag	long
==	O
abbrev_tag	long
)	O
{	O
warn	function
(	O
_	O
(	O
"Duplicate abbreviation tag %lu "	pointer
"in unit 0x%lx in the debug_names\n"	pointer
)	O
,	O
(	O
long	O
)	O
abbrev_tag	long
,	O
(	O
long	O
)	O
(	O
unit_start	pointer
-	O
section	pointer
->	O
start	pointer
)	O
)	O
;	O
break	O
;	O
}	O
entry	long
=	O
&	O
abbrev_lookup	pointer
[	O
abbrev_lookup_used	long
++	O
]	O
;	O
entry	long
->	O
abbrev_tag	long
=	O
abbrev_tag	long
;	O
entry	long
->	O
abbrev_lookup_ptr	pointer
=	O
abbrevptr	pointer
;	O
SKIP_ULEB	O
(	O
abbrevptr	pointer
,	O
abbrev_table_end	pointer
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
dwarf_vma	long
xindex	long
,	O
form	int
;	O
READ_ULEB	O
(	O
xindex	long
,	O
abbrevptr	pointer
,	O
abbrev_table_end	pointer
)	O
;	O
READ_ULEB	O
(	O
form	int
,	O
abbrevptr	pointer
,	O
abbrev_table_end	pointer
)	O
;	O
if	O
(	O
xindex	long
==	O
0	int
&&	O
form	int
==	O
0	int
)	O
break	O
;	O
}	O
}	O
printf	function
(	O
_	O
(	O
"\nSymbol table:\n"	pointer
)	O
)	O
;	O
uint32_t	int
namei	int
;	O
for	O
(	O
namei	int
=	O
0	int
;	O
namei	int
<	O
name_count	int
;	O
++	O
namei	int
)	O
{	O
uint64_t	long
string_offset	long
,	O
entry_offset	long
;	O
SAFE_BYTE_GET	O
(	O
string_offset	long
,	O
name_table_string_offsets	pointer
+	O
namei	int
*	O
offset_size	int
,	O
offset_size	int
,	O
unit_end	pointer
)	O
;	O
SAFE_BYTE_GET	O
(	O
entry_offset	long
,	O
name_table_entry_offsets	pointer
+	O
namei	int
*	O
offset_size	int
,	O
offset_size	int
,	O
unit_end	pointer
)	O
;	O
printf	function
(	O
"[%3u] #%08x %s:"	pointer
,	O
namei	int
,	O
hash_table_hashes	pointer
[	O
namei	int
]	O
,	O
fetch_indirect_string	function
(	O
string_offset	long
)	O
)	O
;	O
unsigned	O
char	O
*	O
entryptr	pointer
=	O
entry_pool	pointer
+	O
entry_offset	long
;	O
int	O
tagno	int
=	O
-	O
2	int
;	O
dwarf_vma	long
second_abbrev_tag	long
=	O
-	O
1	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
dwarf_vma	long
abbrev_tag	long
;	O
dwarf_vma	long
dwarf_tag	enum
;	O
const	O
struct	O
abbrev_lookup_entry	struct
*	O
entry	long
;	O
READ_ULEB	O
(	O
abbrev_tag	long
,	O
entryptr	pointer
,	O
unit_end	pointer
)	O
;	O
if	O
(	O
tagno	int
==	O
-	O
1	int
)	O
{	O
second_abbrev_tag	long
=	O
abbrev_tag	long
;	O
tagno	int
=	O
0	int
;	O
entryptr	pointer
=	O
entry_pool	pointer
+	O
entry_offset	long
;	O
continue	O
;	O
}	O
if	O
(	O
abbrev_tag	long
==	O
0	int
)	O
break	O
;	O
if	O
(	O
tagno	int
>=	O
0	int
)	O
printf	function
(	O
"%s<%lu>"	pointer
,	O
(	O
tagno	int
==	O
0	int
&&	O
second_abbrev_tag	long
==	O
0	int
?	O
" "	pointer
:	O
"\n\t"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
abbrev_tag	long
)	O
;	O
for	O
(	O
entry	long
=	O
abbrev_lookup	pointer
;	O
entry	long
<	O
abbrev_lookup	pointer
+	O
abbrev_lookup_used	long
;	O
entry	long
++	O
)	O
if	O
(	O
entry	long
->	O
abbrev_tag	long
==	O
abbrev_tag	long
)	O
break	O
;	O
if	O
(	O
entry	long
>=	O
abbrev_lookup	pointer
+	O
abbrev_lookup_used	long
)	O
{	O
warn	function
(	O
_	O
(	O
"Undefined abbreviation tag %lu "	pointer
"in unit 0x%lx in the debug_names\n"	pointer
)	O
,	O
(	O
long	O
)	O
abbrev_tag	long
,	O
(	O
long	O
)	O
(	O
unit_start	pointer
-	O
section	pointer
->	O
start	pointer
)	O
)	O
;	O
break	O
;	O
}	O
abbrevptr	pointer
=	O
entry	long
->	O
abbrev_lookup_ptr	pointer
;	O
READ_ULEB	O
(	O
dwarf_tag	enum
,	O
abbrevptr	pointer
,	O
abbrev_table_end	pointer
)	O
;	O
if	O
(	O
tagno	int
>=	O
0	int
)	O
printf	function
(	O
" %s"	pointer
,	O
get_TAG_name	function
(	O
dwarf_tag	enum
)	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
dwarf_vma	long
xindex	long
,	O
form	int
;	O
READ_ULEB	O
(	O
xindex	long
,	O
abbrevptr	pointer
,	O
abbrev_table_end	pointer
)	O
;	O
READ_ULEB	O
(	O
form	int
,	O
abbrevptr	pointer
,	O
abbrev_table_end	pointer
)	O
;	O
if	O
(	O
xindex	long
==	O
0	int
&&	O
form	int
==	O
0	int
)	O
break	O
;	O
if	O
(	O
tagno	int
>=	O
0	int
)	O
printf	function
(	O
" %s"	pointer
,	O
get_IDX_name	function
(	O
xindex	long
)	O
)	O
;	O
entryptr	pointer
=	O
read_and_display_attr_value	function
(	O
0	int
,	O
form	int
,	O
0	int
,	O
unit_start	pointer
,	O
entryptr	pointer
,	O
unit_end	pointer
,	O
0	int
,	O
0	int
,	O
offset_size	int
,	O
dwarf_version	int
,	O
NULL	O
,	O
(	O
tagno	int
<	O
0	int
)	O
,	O
NULL	O
,	O
NULL	O
,	O
'='	O
,	O
-	O
1	int
)	O
;	O
}	O
++	O
tagno	int
;	O
}	O
if	O
(	O
tagno	int
<=	O
0	int
)	O
printf	function
(	O
_	O
(	O
" <no entries>"	pointer
)	O
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
free	function
(	O
abbrev_lookup	pointer
)	O
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
display_debug_links	function
(	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
void	O
*	O
file	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
const	O
unsigned	O
char	O
*	O
filename	pointer
;	O
unsigned	O
int	O
filelen	int
;	O
introduce	function
(	O
section	pointer
,	O
FALSE	int
)	O
;	O
filename	pointer
=	O
section	pointer
->	O
start	pointer
;	O
filelen	int
=	O
strnlen	function
(	O
(	O
const	O
char	O
*	O
)	O
filename	pointer
,	O
section	pointer
->	O
size	int
)	O
;	O
if	O
(	O
filelen	int
==	O
section	pointer
->	O
size	int
)	O
{	O
warn	function
(	O
_	O
(	O
"The debuglink filename is corrupt/missing\n"	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
printf	function
(	O
_	O
(	O
"  Separate debug info file: %s\n"	pointer
)	O
,	O
filename	pointer
)	O
;	O
if	O
(	O
const_strneq	O
(	O
section	pointer
->	O
name	pointer
,	O
".gnu_debuglink"	pointer
)	O
)	O
{	O
unsigned	O
int	O
crc32	int
;	O
unsigned	O
int	O
crc_offset	int
;	O
crc_offset	int
=	O
filelen	int
+	O
1	int
;	O
crc_offset	int
=	O
(	O
crc_offset	int
+	O
3	int
)	O
&	O
~	O
3	int
;	O
if	O
(	O
crc_offset	int
+	O
4	int
>	O
section	pointer
->	O
size	int
)	O
{	O
warn	function
(	O
_	O
(	O
"CRC offset missing/truncated\n"	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
crc32	int
=	O
byte_get	pointer
(	O
filename	pointer
+	O
crc_offset	int
,	O
4	int
)	O
;	O
printf	function
(	O
_	O
(	O
"  CRC value: %#x\n"	pointer
)	O
,	O
crc32	int
)	O
;	O
if	O
(	O
crc_offset	int
+	O
4	int
<	O
section	pointer
->	O
size	int
)	O
{	O
warn	function
(	O
_	O
(	O
"There are %#lx extraneous bytes at the end of the section\n"	pointer
)	O
,	O
(	O
long	O
)	O
(	O
section	pointer
->	O
size	int
-	O
(	O
crc_offset	int
+	O
4	int
)	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
else	O
{	O
const	O
unsigned	O
char	O
*	O
build_id	pointer
=	O
section	pointer
->	O
start	pointer
+	O
filelen	int
+	O
1	int
;	O
bfd_size_type	long
build_id_len	long
=	O
section	pointer
->	O
size	int
-	O
(	O
filelen	int
+	O
1	int
)	O
;	O
bfd_size_type	long
printed	long
;	O
if	O
(	O
build_id_len	long
<	O
0x14	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Build-ID is too short (%#lx bytes)\n"	pointer
)	O
,	O
(	O
long	O
)	O
build_id_len	long
)	O
;	O
return	O
0	int
;	O
}	O
printed	long
=	O
printf	function
(	O
_	O
(	O
"  Build-ID (%#lx bytes):"	pointer
)	O
,	O
(	O
long	O
)	O
build_id_len	long
)	O
;	O
display_data	function
(	O
printed	long
,	O
build_id	pointer
,	O
build_id_len	long
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
putchar	function
(	O
'\n'	O
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
display_gdb_index	function
(	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
void	O
*	O
file	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
unsigned	O
char	O
*	O
start	pointer
=	O
section	pointer
->	O
start	pointer
;	O
uint32_t	int
version	int
;	O
uint32_t	int
cu_list_offset	int
,	O
tu_list_offset	int
;	O
uint32_t	int
address_table_offset	int
,	O
symbol_table_offset	int
,	O
constant_pool_offset	int
;	O
unsigned	O
int	O
cu_list_elements	int
,	O
tu_list_elements	int
;	O
unsigned	O
int	O
address_table_size	int
,	O
symbol_table_slots	int
;	O
unsigned	O
char	O
*	O
cu_list	pointer
,	O
*	O
tu_list	pointer
;	O
unsigned	O
char	O
*	O
address_table	pointer
,	O
*	O
symbol_table	pointer
,	O
*	O
constant_pool	pointer
;	O
unsigned	O
int	O
i	pointer
;	O
introduce	function
(	O
section	pointer
,	O
FALSE	int
)	O
;	O
if	O
(	O
section	pointer
->	O
size	int
<	O
6	int
*	O
sizeof	O
(	O
uint32_t	int
)	O
)	O
{	O
warn	function
(	O
_	O
(	O
"Truncated header in the %s section.\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
version	int
=	O
byte_get_little_endian	function
(	O
start	pointer
,	O
4	int
)	O
;	O
printf	function
(	O
_	O
(	O
"Version %ld\n"	pointer
)	O
,	O
(	O
long	O
)	O
version	int
)	O
;	O
if	O
(	O
version	int
<	O
3	int
||	O
version	int
>	O
8	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Unsupported version %lu.\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
version	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
version	int
<	O
4	int
)	O
warn	function
(	O
_	O
(	O
"The address table data in version 3 may be wrong.\n"	pointer
)	O
)	O
;	O
if	O
(	O
version	int
<	O
5	int
)	O
warn	function
(	O
_	O
(	O
"Version 4 does not support case insensitive lookups.\n"	pointer
)	O
)	O
;	O
if	O
(	O
version	int
<	O
6	int
)	O
warn	function
(	O
_	O
(	O
"Version 5 does not include inlined functions.\n"	pointer
)	O
)	O
;	O
if	O
(	O
version	int
<	O
7	int
)	O
warn	function
(	O
_	O
(	O
"Version 6 does not include symbol attributes.\n"	pointer
)	O
)	O
;	O
cu_list_offset	int
=	O
byte_get_little_endian	function
(	O
start	pointer
+	O
4	int
,	O
4	int
)	O
;	O
tu_list_offset	int
=	O
byte_get_little_endian	function
(	O
start	pointer
+	O
8	int
,	O
4	int
)	O
;	O
address_table_offset	int
=	O
byte_get_little_endian	function
(	O
start	pointer
+	O
12	int
,	O
4	int
)	O
;	O
symbol_table_offset	int
=	O
byte_get_little_endian	function
(	O
start	pointer
+	O
16	int
,	O
4	int
)	O
;	O
constant_pool_offset	int
=	O
byte_get_little_endian	function
(	O
start	pointer
+	O
20	int
,	O
4	int
)	O
;	O
if	O
(	O
cu_list_offset	int
>	O
section	pointer
->	O
size	int
||	O
tu_list_offset	int
>	O
section	pointer
->	O
size	int
||	O
address_table_offset	int
>	O
section	pointer
->	O
size	int
||	O
symbol_table_offset	int
>	O
section	pointer
->	O
size	int
||	O
constant_pool_offset	int
>	O
section	pointer
->	O
size	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Corrupt header in the %s section.\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
tu_list_offset	int
<	O
cu_list_offset	int
)	O
{	O
warn	function
(	O
_	O
(	O
"TU offset (%x) is less than CU offset (%x)\n"	pointer
)	O
,	O
tu_list_offset	int
,	O
cu_list_offset	int
)	O
;	O
return	O
0	int
;	O
}	O
cu_list_elements	int
=	O
(	O
tu_list_offset	int
-	O
cu_list_offset	int
)	O
/	O
8	int
;	O
if	O
(	O
address_table_offset	int
<	O
tu_list_offset	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Address table offset (%x) is less than TU offset (%x)\n"	pointer
)	O
,	O
address_table_offset	int
,	O
tu_list_offset	int
)	O
;	O
return	O
0	int
;	O
}	O
tu_list_elements	int
=	O
(	O
address_table_offset	int
-	O
tu_list_offset	int
)	O
/	O
8	int
;	O
if	O
(	O
symbol_table_offset	int
<	O
address_table_offset	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Symbol table offset (%x) is less then Address table offset (%x)\n"	pointer
)	O
,	O
symbol_table_offset	int
,	O
address_table_offset	int
)	O
;	O
return	O
0	int
;	O
}	O
address_table_size	int
=	O
symbol_table_offset	int
-	O
address_table_offset	int
;	O
if	O
(	O
constant_pool_offset	int
<	O
symbol_table_offset	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Constant pool offset (%x) is less than symbol table offset (%x)\n"	pointer
)	O
,	O
constant_pool_offset	int
,	O
symbol_table_offset	int
)	O
;	O
return	O
0	int
;	O
}	O
symbol_table_slots	int
=	O
(	O
constant_pool_offset	int
-	O
symbol_table_offset	int
)	O
/	O
8	int
;	O
cu_list	pointer
=	O
start	pointer
+	O
cu_list_offset	int
;	O
tu_list	pointer
=	O
start	pointer
+	O
tu_list_offset	int
;	O
address_table	pointer
=	O
start	pointer
+	O
address_table_offset	int
;	O
symbol_table	pointer
=	O
start	pointer
+	O
symbol_table_offset	int
;	O
constant_pool	pointer
=	O
start	pointer
+	O
constant_pool_offset	int
;	O
if	O
(	O
address_table	pointer
+	O
address_table_size	int
>	O
section	pointer
->	O
start	pointer
+	O
section	pointer
->	O
size	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Address table extends beyond end of section.\n"	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
printf	function
(	O
_	O
(	O
"\nCU table:\n"	pointer
)	O
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
cu_list_elements	int
;	O
i	pointer
+=	O
2	int
)	O
{	O
uint64_t	long
cu_offset	long
=	O
byte_get_little_endian	function
(	O
cu_list	pointer
+	O
i	pointer
*	O
8	int
,	O
8	int
)	O
;	O
uint64_t	long
cu_length	long
=	O
byte_get_little_endian	function
(	O
cu_list	pointer
+	O
i	pointer
*	O
8	int
+	O
8	int
,	O
8	int
)	O
;	O
printf	function
(	O
_	O
(	O
"[%3u] 0x%lx - 0x%lx\n"	pointer
)	O
,	O
i	pointer
/	O
2	int
,	O
(	O
unsigned	O
long	O
)	O
cu_offset	long
,	O
(	O
unsigned	O
long	O
)	O
(	O
cu_offset	long
+	O
cu_length	long
-	O
1	int
)	O
)	O
;	O
}	O
printf	function
(	O
_	O
(	O
"\nTU table:\n"	pointer
)	O
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
tu_list_elements	int
;	O
i	pointer
+=	O
3	int
)	O
{	O
uint64_t	long
tu_offset	long
=	O
byte_get_little_endian	function
(	O
tu_list	pointer
+	O
i	pointer
*	O
8	int
,	O
8	int
)	O
;	O
uint64_t	long
type_offset	long
=	O
byte_get_little_endian	function
(	O
tu_list	pointer
+	O
i	pointer
*	O
8	int
+	O
8	int
,	O
8	int
)	O
;	O
uint64_t	long
signature	long
=	O
byte_get_little_endian	function
(	O
tu_list	pointer
+	O
i	pointer
*	O
8	int
+	O
16	int
,	O
8	int
)	O
;	O
printf	function
(	O
_	O
(	O
"[%3u] 0x%lx 0x%lx "	pointer
)	O
,	O
i	pointer
/	O
3	int
,	O
(	O
unsigned	O
long	O
)	O
tu_offset	long
,	O
(	O
unsigned	O
long	O
)	O
type_offset	long
)	O
;	O
print_dwarf_vma	function
(	O
signature	long
,	O
8	int
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
printf	function
(	O
_	O
(	O
"\nAddress table:\n"	pointer
)	O
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
address_table_size	int
&&	O
i	pointer
<=	O
address_table_size	int
-	O
(	O
2	int
*	O
8	int
+	O
4	int
)	O
;	O
i	pointer
+=	O
2	int
*	O
8	int
+	O
4	int
)	O
{	O
uint64_t	long
low	long
=	O
byte_get_little_endian	function
(	O
address_table	pointer
+	O
i	pointer
,	O
8	int
)	O
;	O
uint64_t	long
high	long
=	O
byte_get_little_endian	function
(	O
address_table	pointer
+	O
i	pointer
+	O
8	int
,	O
8	int
)	O
;	O
uint32_t	int
cu_index	int
=	O
byte_get_little_endian	function
(	O
address_table	pointer
+	O
i	pointer
+	O
16	int
,	O
4	int
)	O
;	O
print_dwarf_vma	function
(	O
low	long
,	O
8	int
)	O
;	O
print_dwarf_vma	function
(	O
high	long
,	O
8	int
)	O
;	O
printf	function
(	O
_	O
(	O
"%lu\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
cu_index	int
)	O
;	O
}	O
printf	function
(	O
_	O
(	O
"\nSymbol table:\n"	pointer
)	O
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
symbol_table_slots	int
;	O
++	O
i	pointer
)	O
{	O
uint32_t	int
name_offset	int
=	O
byte_get_little_endian	function
(	O
symbol_table	pointer
+	O
i	pointer
*	O
8	int
,	O
4	int
)	O
;	O
uint32_t	int
cu_vector_offset	int
=	O
byte_get_little_endian	function
(	O
symbol_table	pointer
+	O
i	pointer
*	O
8	int
+	O
4	int
,	O
4	int
)	O
;	O
uint32_t	int
num_cus	int
,	O
cu	int
;	O
if	O
(	O
name_offset	int
!=	O
0	int
||	O
cu_vector_offset	int
!=	O
0	int
)	O
{	O
unsigned	O
int	O
j	int
;	O
unsigned	O
char	O
*	O
adr	long
;	O
adr	long
=	O
constant_pool	pointer
+	O
name_offset	int
;	O
if	O
(	O
adr	long
<	O
constant_pool	pointer
||	O
adr	long
>=	O
section	pointer
->	O
start	pointer
+	O
section	pointer
->	O
size	int
)	O
{	O
printf	function
(	O
_	O
(	O
"[%3u] <corrupt offset: %x>"	pointer
)	O
,	O
i	pointer
,	O
name_offset	int
)	O
;	O
warn	function
(	O
_	O
(	O
"Corrupt name offset of 0x%x found for symbol table slot %d\n"	pointer
)	O
,	O
name_offset	int
,	O
i	pointer
)	O
;	O
}	O
else	O
printf	function
(	O
"[%3u] %.*s:"	pointer
,	O
i	pointer
,	O
(	O
int	O
)	O
(	O
section	pointer
->	O
size	int
-	O
(	O
constant_pool_offset	int
+	O
name_offset	int
)	O
)	O
,	O
constant_pool	pointer
+	O
name_offset	int
)	O
;	O
adr	long
=	O
constant_pool	pointer
+	O
cu_vector_offset	int
;	O
if	O
(	O
adr	long
<	O
constant_pool	pointer
||	O
adr	long
>=	O
section	pointer
->	O
start	pointer
+	O
section	pointer
->	O
size	int
-	O
3	int
)	O
{	O
printf	function
(	O
_	O
(	O
"<invalid CU vector offset: %x>\n"	pointer
)	O
,	O
cu_vector_offset	int
)	O
;	O
warn	function
(	O
_	O
(	O
"Corrupt CU vector offset of 0x%x found for symbol table slot %d\n"	pointer
)	O
,	O
cu_vector_offset	int
,	O
i	pointer
)	O
;	O
continue	O
;	O
}	O
num_cus	int
=	O
byte_get_little_endian	function
(	O
adr	long
,	O
4	int
)	O
;	O
adr	long
=	O
constant_pool	pointer
+	O
cu_vector_offset	int
+	O
4	int
+	O
num_cus	int
*	O
4	int
;	O
if	O
(	O
num_cus	int
*	O
4	int
<	O
num_cus	int
||	O
adr	long
>=	O
section	pointer
->	O
start	pointer
+	O
section	pointer
->	O
size	int
||	O
adr	long
<	O
constant_pool	pointer
)	O
{	O
printf	function
(	O
"<invalid number of CUs: %d>\n"	pointer
,	O
num_cus	int
)	O
;	O
warn	function
(	O
_	O
(	O
"Invalid number of CUs (0x%x) for symbol table slot %d\n"	pointer
)	O
,	O
num_cus	int
,	O
i	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
num_cus	int
>	O
1	int
)	O
printf	function
(	O
"\n"	pointer
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
num_cus	int
;	O
++	O
j	int
)	O
{	O
int	O
is_static	int
;	O
gdb_index_symbol_kind	enum
kind	enum
;	O
cu	int
=	O
byte_get_little_endian	function
(	O
constant_pool	pointer
+	O
cu_vector_offset	int
+	O
4	int
+	O
j	int
*	O
4	int
,	O
4	int
)	O
;	O
is_static	int
=	O
GDB_INDEX_SYMBOL_STATIC_VALUE	O
(	O
cu	int
)	O
;	O
kind	enum
=	O
GDB_INDEX_SYMBOL_KIND_VALUE	O
(	O
cu	int
)	O
;	O
cu	int
=	O
GDB_INDEX_CU_VALUE	O
(	O
cu	int
)	O
;	O
if	O
(	O
cu	int
>=	O
cu_list_elements	int
/	O
2	int
)	O
printf	function
(	O
"%cT%lu"	pointer
,	O
num_cus	int
>	O
1	int
?	O
'\t'	O
:	O
' '	O
,	O
(	O
unsigned	O
long	O
)	O
(	O
cu	int
-	O
cu_list_elements	int
/	O
2	int
)	O
)	O
;	O
else	O
printf	function
(	O
"%c%lu"	pointer
,	O
num_cus	int
>	O
1	int
?	O
'\t'	O
:	O
' '	O
,	O
(	O
unsigned	O
long	O
)	O
cu	int
)	O
;	O
printf	function
(	O
" [%s, %s]"	pointer
,	O
is_static	int
?	O
_	O
(	O
"static"	pointer
)	O
:	O
_	O
(	O
"global"	pointer
)	O
,	O
get_gdb_index_symbol_kind_name	function
(	O
kind	enum
)	O
)	O
;	O
if	O
(	O
num_cus	int
>	O
1	int
)	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
if	O
(	O
num_cus	int
<=	O
1	int
)	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
}	O
return	O
1	int
;	O
}	O
static	O
void	O
prealloc_cu_tu_list	function
(	O
unsigned	O
int	O
nshndx	int
)	O
{	O
if	O
(	O
shndx_pool	pointer
==	O
NULL	O
)	O
{	O
shndx_pool_size	int
=	O
nshndx	int
;	O
shndx_pool_used	int
=	O
0	int
;	O
shndx_pool	pointer
=	O
(	O
unsigned	O
int	O
*	O
)	O
xcmalloc	function
(	O
shndx_pool_size	int
,	O
sizeof	O
(	O
unsigned	O
int	O
)	O
)	O
;	O
}	O
else	O
{	O
shndx_pool_size	int
=	O
shndx_pool_used	int
+	O
nshndx	int
;	O
shndx_pool	pointer
=	O
(	O
unsigned	O
int	O
*	O
)	O
xcrealloc	function
(	O
shndx_pool	pointer
,	O
shndx_pool_size	int
,	O
sizeof	O
(	O
unsigned	O
int	O
)	O
)	O
;	O
}	O
}	O
static	O
void	O
add_shndx_to_cu_tu_entry	function
(	O
unsigned	O
int	O
shndx	int
)	O
{	O
if	O
(	O
shndx_pool_used	int
>=	O
shndx_pool_size	int
)	O
{	O
error	function
(	O
_	O
(	O
"Internal error: out of space in the shndx pool.\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
shndx_pool	pointer
[	O
shndx_pool_used	int
++	O
]	O
=	O
shndx	int
;	O
}	O
static	O
void	O
end_cu_tu_entry	function
(	O
void	O
)	O
{	O
if	O
(	O
shndx_pool_used	int
>=	O
shndx_pool_size	int
)	O
{	O
error	function
(	O
_	O
(	O
"Internal error: out of space in the shndx pool.\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
shndx_pool	pointer
[	O
shndx_pool_used	int
++	O
]	O
=	O
0	int
;	O
}	O
static	O
const	O
char	O
*	O
get_DW_SECT_short_name	function
(	O
unsigned	O
int	O
dw_sect	int
)	O
{	O
static	O
char	O
buf	pointer
[	O
16	int
]	O
;	O
switch	O
(	O
dw_sect	int
)	O
{	O
case	O
DW_SECT_INFO	int
:	O
return	O
"info"	pointer
;	O
case	O
DW_SECT_TYPES	int
:	O
return	O
"types"	pointer
;	O
case	O
DW_SECT_ABBREV	int
:	O
return	O
"abbrev"	pointer
;	O
case	O
DW_SECT_LINE	int
:	O
return	O
"line"	pointer
;	O
case	O
DW_SECT_LOC	int
:	O
return	O
"loc"	pointer
;	O
case	O
DW_SECT_STR_OFFSETS	int
:	O
return	O
"str_off"	pointer
;	O
case	O
DW_SECT_MACINFO	int
:	O
return	O
"macinfo"	pointer
;	O
case	O
DW_SECT_MACRO	int
:	O
return	O
"macro"	pointer
;	O
default	O
:	O
break	O
;	O
}	O
snprintf	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
"%d"	pointer
,	O
dw_sect	int
)	O
;	O
return	O
buf	pointer
;	O
}	O
static	O
int	O
process_cu_tu_index	function
(	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
int	O
do_display	int
)	O
{	O
unsigned	O
char	O
*	O
phdr	pointer
=	O
section	pointer
->	O
start	pointer
;	O
unsigned	O
char	O
*	O
limit	pointer
=	O
phdr	pointer
+	O
section	pointer
->	O
size	int
;	O
unsigned	O
char	O
*	O
phash	pointer
;	O
unsigned	O
char	O
*	O
pindex	pointer
;	O
unsigned	O
char	O
*	O
ppool	pointer
;	O
unsigned	O
int	O
version	int
;	O
unsigned	O
int	O
ncols	int
=	O
0	int
;	O
unsigned	O
int	O
nused	int
;	O
unsigned	O
int	O
nslots	int
;	O
unsigned	O
int	O
i	pointer
;	O
unsigned	O
int	O
j	int
;	O
dwarf_vma	long
signature_high	long
;	O
dwarf_vma	long
signature_low	long
;	O
char	O
buf	pointer
[	O
64	int
]	O
;	O
if	O
(	O
phdr	pointer
==	O
NULL	O
)	O
{	O
warn	function
(	O
_	O
(	O
"Section %s is empty\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
section	pointer
->	O
size	int
<	O
24	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Section %s is too small to contain a CU/TU header\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
SAFE_BYTE_GET	O
(	O
version	int
,	O
phdr	pointer
,	O
4	int
,	O
limit	pointer
)	O
;	O
if	O
(	O
version	int
>=	O
2	int
)	O
SAFE_BYTE_GET	O
(	O
ncols	int
,	O
phdr	pointer
+	O
4	int
,	O
4	int
,	O
limit	pointer
)	O
;	O
SAFE_BYTE_GET	O
(	O
nused	int
,	O
phdr	pointer
+	O
8	int
,	O
4	int
,	O
limit	pointer
)	O
;	O
SAFE_BYTE_GET	O
(	O
nslots	int
,	O
phdr	pointer
+	O
12	int
,	O
4	int
,	O
limit	pointer
)	O
;	O
phash	pointer
=	O
phdr	pointer
+	O
16	int
;	O
pindex	pointer
=	O
phash	pointer
+	O
(	O
size_t	long
)	O
nslots	int
*	O
8	int
;	O
ppool	pointer
=	O
pindex	pointer
+	O
(	O
size_t	long
)	O
nslots	int
*	O
4	int
;	O
if	O
(	O
do_display	int
)	O
{	O
introduce	function
(	O
section	pointer
,	O
FALSE	int
)	O
;	O
printf	function
(	O
_	O
(	O
"  Version:                 %u\n"	pointer
)	O
,	O
version	int
)	O
;	O
if	O
(	O
version	int
>=	O
2	int
)	O
printf	function
(	O
_	O
(	O
"  Number of columns:       %u\n"	pointer
)	O
,	O
ncols	int
)	O
;	O
printf	function
(	O
_	O
(	O
"  Number of used entries:  %u\n"	pointer
)	O
,	O
nused	int
)	O
;	O
printf	function
(	O
_	O
(	O
"  Number of slots:         %u\n\n"	pointer
)	O
,	O
nslots	int
)	O
;	O
}	O
if	O
(	O
(	O
size_t	long
)	O
nslots	int
*	O
8	int
/	O
8	int
!=	O
nslots	int
||	O
phash	pointer
<	O
phdr	pointer
||	O
phash	pointer
>	O
limit	pointer
||	O
pindex	pointer
<	O
phash	pointer
||	O
pindex	pointer
>	O
limit	pointer
||	O
ppool	pointer
<	O
pindex	pointer
||	O
ppool	pointer
>	O
limit	pointer
)	O
{	O
warn	function
(	O
ngettext	function
(	O
"Section %s is too small for %u slot\n"	pointer
,	O
"Section %s is too small for %u slots\n"	pointer
,	O
nslots	int
)	O
,	O
section	pointer
->	O
name	pointer
,	O
nslots	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
version	int
==	O
1	int
)	O
{	O
if	O
(	O
!	O
do_display	int
)	O
prealloc_cu_tu_list	function
(	O
(	O
limit	pointer
-	O
ppool	pointer
)	O
/	O
4	int
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
nslots	int
;	O
i	pointer
++	O
)	O
{	O
unsigned	O
char	O
*	O
shndx_list	pointer
;	O
unsigned	O
int	O
shndx	int
;	O
SAFE_BYTE_GET64	O
(	O
phash	pointer
,	O
&	O
signature_high	long
,	O
&	O
signature_low	long
,	O
limit	pointer
)	O
;	O
if	O
(	O
signature_high	long
!=	O
0	int
||	O
signature_low	long
!=	O
0	int
)	O
{	O
SAFE_BYTE_GET	O
(	O
j	int
,	O
pindex	pointer
,	O
4	int
,	O
limit	pointer
)	O
;	O
shndx_list	pointer
=	O
ppool	pointer
+	O
j	int
*	O
4	int
;	O
if	O
(	O
shndx_list	pointer
<	O
ppool	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"Section index pool located before start of section\n"	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
do_display	int
)	O
printf	function
(	O
_	O
(	O
"  [%3d] Signature:  0x%s  Sections: "	pointer
)	O
,	O
i	pointer
,	O
dwarf_vmatoa64	function
(	O
signature_high	long
,	O
signature_low	long
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
shndx_list	pointer
>=	O
limit	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"Section %s too small for shndx pool\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
SAFE_BYTE_GET	O
(	O
shndx	int
,	O
shndx_list	pointer
,	O
4	int
,	O
limit	pointer
)	O
;	O
if	O
(	O
shndx	int
==	O
0	int
)	O
break	O
;	O
if	O
(	O
do_display	int
)	O
printf	function
(	O
" %d"	pointer
,	O
shndx	int
)	O
;	O
else	O
add_shndx_to_cu_tu_entry	function
(	O
shndx	int
)	O
;	O
shndx_list	pointer
+=	O
4	int
;	O
}	O
if	O
(	O
do_display	int
)	O
printf	function
(	O
"\n"	pointer
)	O
;	O
else	O
end_cu_tu_entry	function
(	O
)	O
;	O
}	O
phash	pointer
+=	O
8	int
;	O
pindex	pointer
+=	O
4	int
;	O
}	O
}	O
else	O
if	O
(	O
version	int
==	O
2	int
)	O
{	O
unsigned	O
int	O
val	array
;	O
unsigned	O
int	O
dw_sect	int
;	O
unsigned	O
char	O
*	O
ph	pointer
=	O
phash	pointer
;	O
unsigned	O
char	O
*	O
pi	pointer
=	O
pindex	pointer
;	O
unsigned	O
char	O
*	O
poffsets	pointer
=	O
ppool	pointer
+	O
(	O
size_t	long
)	O
ncols	int
*	O
4	int
;	O
unsigned	O
char	O
*	O
psizes	pointer
=	O
poffsets	pointer
+	O
(	O
size_t	long
)	O
nused	int
*	O
ncols	int
*	O
4	int
;	O
unsigned	O
char	O
*	O
pend	pointer
=	O
psizes	pointer
+	O
(	O
size_t	long
)	O
nused	int
*	O
ncols	int
*	O
4	int
;	O
bfd_boolean	int
is_tu_index	int
;	O
struct	O
cu_tu_set	struct
*	O
this_set	pointer
=	O
NULL	O
;	O
unsigned	O
int	O
row	int
;	O
unsigned	O
char	O
*	O
prow	pointer
;	O
is_tu_index	int
=	O
strcmp	function
(	O
section	pointer
->	O
name	pointer
,	O
".debug_tu_index"	pointer
)	O
==	O
0	int
;	O
if	O
(	O
ncols	int
>	O
0	int
&&	O
(	O
(	O
size_t	long
)	O
ncols	int
*	O
4	int
/	O
4	int
!=	O
ncols	int
||	O
(	O
size_t	long
)	O
nused	int
*	O
ncols	int
*	O
4	int
/	O
(	O
(	O
size_t	long
)	O
ncols	int
*	O
4	int
)	O
!=	O
nused	int
||	O
poffsets	pointer
<	O
ppool	pointer
||	O
poffsets	pointer
>	O
limit	pointer
||	O
psizes	pointer
<	O
poffsets	pointer
||	O
psizes	pointer
>	O
limit	pointer
||	O
pend	pointer
<	O
psizes	pointer
||	O
pend	pointer
>	O
limit	pointer
)	O
)	O
{	O
warn	function
(	O
_	O
(	O
"Section %s too small for offset and size tables\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
do_display	int
)	O
{	O
printf	function
(	O
_	O
(	O
"  Offset table\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"  slot  %-16s  "	pointer
,	O
is_tu_index	int
?	O
_	O
(	O
"signature"	pointer
)	O
:	O
_	O
(	O
"dwo_id"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
is_tu_index	int
)	O
{	O
tu_count	int
=	O
nused	int
;	O
tu_sets	pointer
=	O
xcalloc2	function
(	O
nused	int
,	O
sizeof	O
(	O
struct	O
cu_tu_set	struct
)	O
)	O
;	O
this_set	pointer
=	O
tu_sets	pointer
;	O
}	O
else	O
{	O
cu_count	int
=	O
nused	int
;	O
cu_sets	pointer
=	O
xcalloc2	function
(	O
nused	int
,	O
sizeof	O
(	O
struct	O
cu_tu_set	struct
)	O
)	O
;	O
this_set	pointer
=	O
cu_sets	pointer
;	O
}	O
}	O
if	O
(	O
do_display	int
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
ncols	int
;	O
j	int
++	O
)	O
{	O
SAFE_BYTE_GET	O
(	O
dw_sect	int
,	O
ppool	pointer
+	O
j	int
*	O
4	int
,	O
4	int
,	O
limit	pointer
)	O
;	O
printf	function
(	O
" %8s"	pointer
,	O
get_DW_SECT_short_name	function
(	O
dw_sect	int
)	O
)	O
;	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
nslots	int
;	O
i	pointer
++	O
)	O
{	O
SAFE_BYTE_GET64	O
(	O
ph	pointer
,	O
&	O
signature_high	long
,	O
&	O
signature_low	long
,	O
limit	pointer
)	O
;	O
SAFE_BYTE_GET	O
(	O
row	int
,	O
pi	pointer
,	O
4	int
,	O
limit	pointer
)	O
;	O
if	O
(	O
row	int
!=	O
0	int
)	O
{	O
if	O
(	O
row	int
>	O
nused	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Row index (%u) is larger than number of used entries (%u)\n"	pointer
)	O
,	O
row	int
,	O
nused	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
do_display	int
)	O
{	O
size_t	long
num_copy	long
=	O
sizeof	O
(	O
uint64_t	long
)	O
;	O
if	O
(	O
ph	pointer
+	O
num_copy	long
<	O
limit	pointer
)	O
memcpy	function
(	O
&	O
this_set	pointer
[	O
row	int
-	O
1	int
]	O
.	O
signature	long
,	O
ph	pointer
,	O
num_copy	long
)	O
;	O
else	O
{	O
warn	function
(	O
_	O
(	O
"Signature (%p) extends beyond end of space in section\n"	pointer
)	O
,	O
ph	pointer
)	O
;	O
return	O
0	int
;	O
}	O
}	O
prow	pointer
=	O
poffsets	pointer
+	O
(	O
row	int
-	O
1	int
)	O
*	O
ncols	int
*	O
4	int
;	O
if	O
(	O
prow	pointer
<	O
poffsets	pointer
||	O
prow	pointer
>	O
limit	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"Row index (%u) * num columns (%u) > space remaining in section\n"	pointer
)	O
,	O
row	int
,	O
ncols	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
do_display	int
)	O
printf	function
(	O
_	O
(	O
"  [%3d] 0x%s"	pointer
)	O
,	O
i	pointer
,	O
dwarf_vmatoa64	function
(	O
signature_high	long
,	O
signature_low	long
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
ncols	int
;	O
j	int
++	O
)	O
{	O
SAFE_BYTE_GET	O
(	O
val	array
,	O
prow	pointer
+	O
j	int
*	O
4	int
,	O
4	int
,	O
limit	pointer
)	O
;	O
if	O
(	O
do_display	int
)	O
printf	function
(	O
" %8d"	pointer
,	O
val	array
)	O
;	O
else	O
{	O
SAFE_BYTE_GET	O
(	O
dw_sect	int
,	O
ppool	pointer
+	O
j	int
*	O
4	int
,	O
4	int
,	O
limit	pointer
)	O
;	O
if	O
(	O
dw_sect	int
>=	O
DW_SECT_MAX	int
)	O
warn	function
(	O
_	O
(	O
"Overlarge Dwarf section index detected: %u\n"	pointer
)	O
,	O
dw_sect	int
)	O
;	O
else	O
this_set	pointer
[	O
row	int
-	O
1	int
]	O
.	O
section_offsets	array
[	O
dw_sect	int
]	O
=	O
val	array
;	O
}	O
}	O
if	O
(	O
do_display	int
)	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
ph	pointer
+=	O
8	int
;	O
pi	pointer
+=	O
4	int
;	O
}	O
ph	pointer
=	O
phash	pointer
;	O
pi	pointer
=	O
pindex	pointer
;	O
if	O
(	O
do_display	int
)	O
{	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"  Size table\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"  slot  %-16s  "	pointer
,	O
is_tu_index	int
?	O
_	O
(	O
"signature"	pointer
)	O
:	O
_	O
(	O
"dwo_id"	pointer
)	O
)	O
;	O
}	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
ncols	int
;	O
j	int
++	O
)	O
{	O
SAFE_BYTE_GET	O
(	O
val	array
,	O
ppool	pointer
+	O
j	int
*	O
4	int
,	O
4	int
,	O
limit	pointer
)	O
;	O
if	O
(	O
do_display	int
)	O
printf	function
(	O
" %8s"	pointer
,	O
get_DW_SECT_short_name	function
(	O
val	array
)	O
)	O
;	O
}	O
if	O
(	O
do_display	int
)	O
printf	function
(	O
"\n"	pointer
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
nslots	int
;	O
i	pointer
++	O
)	O
{	O
SAFE_BYTE_GET64	O
(	O
ph	pointer
,	O
&	O
signature_high	long
,	O
&	O
signature_low	long
,	O
limit	pointer
)	O
;	O
SAFE_BYTE_GET	O
(	O
row	int
,	O
pi	pointer
,	O
4	int
,	O
limit	pointer
)	O
;	O
if	O
(	O
row	int
!=	O
0	int
)	O
{	O
prow	pointer
=	O
psizes	pointer
+	O
(	O
row	int
-	O
1	int
)	O
*	O
ncols	int
*	O
4	int
;	O
if	O
(	O
do_display	int
)	O
printf	function
(	O
_	O
(	O
"  [%3d] 0x%s"	pointer
)	O
,	O
i	pointer
,	O
dwarf_vmatoa64	function
(	O
signature_high	long
,	O
signature_low	long
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
ncols	int
;	O
j	int
++	O
)	O
{	O
SAFE_BYTE_GET	O
(	O
val	array
,	O
prow	pointer
+	O
j	int
*	O
4	int
,	O
4	int
,	O
limit	pointer
)	O
;	O
if	O
(	O
do_display	int
)	O
printf	function
(	O
" %8d"	pointer
,	O
val	array
)	O
;	O
else	O
{	O
SAFE_BYTE_GET	O
(	O
dw_sect	int
,	O
ppool	pointer
+	O
j	int
*	O
4	int
,	O
4	int
,	O
limit	pointer
)	O
;	O
if	O
(	O
dw_sect	int
>=	O
DW_SECT_MAX	int
)	O
warn	function
(	O
_	O
(	O
"Overlarge Dwarf section index detected: %u\n"	pointer
)	O
,	O
dw_sect	int
)	O
;	O
else	O
this_set	pointer
[	O
row	int
-	O
1	int
]	O
.	O
section_sizes	array
[	O
dw_sect	int
]	O
=	O
val	array
;	O
}	O
}	O
if	O
(	O
do_display	int
)	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
ph	pointer
+=	O
8	int
;	O
pi	pointer
+=	O
4	int
;	O
}	O
}	O
else	O
if	O
(	O
do_display	int
)	O
printf	function
(	O
_	O
(	O
"  Unsupported version (%d)\n"	pointer
)	O
,	O
version	int
)	O
;	O
if	O
(	O
do_display	int
)	O
printf	function
(	O
"\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
static	O
bfd_boolean	int
load_cu_tu_indexes	function
(	O
void	O
*	O
file	pointer
)	O
{	O
static	O
int	O
cu_tu_indexes_read	int
=	O
-	O
1	int
;	O
if	O
(	O
cu_tu_indexes_read	int
==	O
-	O
1	int
)	O
{	O
cu_tu_indexes_read	int
=	O
TRUE	int
;	O
if	O
(	O
load_debug_section_with_follow	function
(	O
dwp_cu_index	int
,	O
file	pointer
)	O
)	O
if	O
(	O
!	O
process_cu_tu_index	function
(	O
&	O
debug_displays	array
[	O
dwp_cu_index	int
]	O
.	O
section	pointer
,	O
0	int
)	O
)	O
cu_tu_indexes_read	int
=	O
FALSE	int
;	O
if	O
(	O
load_debug_section_with_follow	function
(	O
dwp_tu_index	int
,	O
file	pointer
)	O
)	O
if	O
(	O
!	O
process_cu_tu_index	function
(	O
&	O
debug_displays	array
[	O
dwp_tu_index	int
]	O
.	O
section	pointer
,	O
0	int
)	O
)	O
cu_tu_indexes_read	int
=	O
FALSE	int
;	O
}	O
return	O
(	O
bfd_boolean	int
)	O
cu_tu_indexes_read	int
;	O
}	O
unsigned	O
int	O
*	O
find_cu_tu_set	function
(	O
void	O
*	O
file	pointer
,	O
unsigned	O
int	O
shndx	int
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
if	O
(	O
!	O
load_cu_tu_indexes	function
(	O
file	pointer
)	O
)	O
return	O
NULL	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
shndx_pool_used	int
;	O
i	pointer
++	O
)	O
if	O
(	O
shndx_pool	pointer
[	O
i	pointer
]	O
==	O
shndx	int
)	O
break	O
;	O
if	O
(	O
i	pointer
>=	O
shndx_pool_used	int
)	O
return	O
NULL	O
;	O
while	O
(	O
i	pointer
>	O
0	int
&&	O
shndx_pool	pointer
[	O
i	pointer
-	O
1	int
]	O
!=	O
0	int
)	O
i	pointer
--	O
;	O
return	O
shndx_pool	pointer
+	O
i	pointer
;	O
}	O
static	O
int	O
display_cu_index	function
(	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
void	O
*	O
file	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
process_cu_tu_index	function
(	O
section	pointer
,	O
1	int
)	O
;	O
}	O
static	O
int	O
display_debug_not_supported	function
(	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
void	O
*	O
file	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
printf	function
(	O
_	O
(	O
"Displaying the debug contents of section %s is not yet supported.\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
)	O
;	O
return	O
1	int
;	O
}	O
void	O
*	O
cmalloc	function
(	O
size_t	long
nmemb	long
,	O
size_t	long
size	int
)	O
{	O
if	O
(	O
nmemb	long
>=	O
~	O
(	O
size_t	long
)	O
0	int
/	O
size	int
)	O
return	O
NULL	O
;	O
return	O
xmalloc	function
(	O
nmemb	long
*	O
size	int
)	O
;	O
}	O
void	O
*	O
xcmalloc	function
(	O
size_t	long
nmemb	long
,	O
size_t	long
size	int
)	O
{	O
if	O
(	O
nmemb	long
>=	O
~	O
(	O
size_t	long
)	O
0	int
/	O
size	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Attempt to allocate an array with an excessive number of elements: 0x%lx\n"	pointer
)	O
,	O
(	O
long	O
)	O
nmemb	long
)	O
;	O
xexit	function
(	O
1	int
)	O
;	O
}	O
return	O
xmalloc	function
(	O
nmemb	long
*	O
size	int
)	O
;	O
}	O
void	O
*	O
xcrealloc	function
(	O
void	O
*	O
ptr	pointer
,	O
size_t	long
nmemb	long
,	O
size_t	long
size	int
)	O
{	O
if	O
(	O
nmemb	long
>=	O
~	O
(	O
size_t	long
)	O
0	int
/	O
size	int
)	O
{	O
error	function
(	O
_	O
(	O
"Attempt to re-allocate an array with an excessive number of elements: 0x%lx\n"	pointer
)	O
,	O
(	O
long	O
)	O
nmemb	long
)	O
;	O
xexit	function
(	O
1	int
)	O
;	O
}	O
return	O
xrealloc	function
(	O
ptr	pointer
,	O
nmemb	long
*	O
size	int
)	O
;	O
}	O
void	O
*	O
xcalloc2	function
(	O
size_t	long
nmemb	long
,	O
size_t	long
size	int
)	O
{	O
if	O
(	O
nmemb	long
>=	O
~	O
(	O
size_t	long
)	O
0	int
/	O
size	int
)	O
{	O
error	function
(	O
_	O
(	O
"Attempt to allocate a zero'ed array with an excessive number of elements: 0x%lx\n"	pointer
)	O
,	O
(	O
long	O
)	O
nmemb	long
)	O
;	O
xexit	function
(	O
1	int
)	O
;	O
}	O
return	O
xcalloc	function
(	O
nmemb	long
,	O
size	int
)	O
;	O
}	O
static	O
unsigned	O
long	O
calc_gnu_debuglink_crc32	function
(	O
unsigned	O
long	O
crc	long
,	O
const	O
unsigned	O
char	O
*	O
buf	pointer
,	O
bfd_size_type	long
len	long
)	O
{	O
static	O
const	O
unsigned	O
long	O
crc32_table	array
[	O
256	int
]	O
=	O
{	O
0x00000000	int
,	O
0x77073096	int
,	O
0xee0e612c	int
,	O
0x990951ba	int
,	O
0x076dc419	int
,	O
0x706af48f	int
,	O
0xe963a535	int
,	O
0x9e6495a3	int
,	O
0x0edb8832	int
,	O
0x79dcb8a4	int
,	O
0xe0d5e91e	int
,	O
0x97d2d988	int
,	O
0x09b64c2b	int
,	O
0x7eb17cbd	int
,	O
0xe7b82d07	int
,	O
0x90bf1d91	int
,	O
0x1db71064	int
,	O
0x6ab020f2	int
,	O
0xf3b97148	int
,	O
0x84be41de	int
,	O
0x1adad47d	int
,	O
0x6ddde4eb	int
,	O
0xf4d4b551	int
,	O
0x83d385c7	int
,	O
0x136c9856	int
,	O
0x646ba8c0	int
,	O
0xfd62f97a	int
,	O
0x8a65c9ec	int
,	O
0x14015c4f	int
,	O
0x63066cd9	int
,	O
0xfa0f3d63	int
,	O
0x8d080df5	int
,	O
0x3b6e20c8	int
,	O
0x4c69105e	int
,	O
0xd56041e4	int
,	O
0xa2677172	int
,	O
0x3c03e4d1	int
,	O
0x4b04d447	int
,	O
0xd20d85fd	int
,	O
0xa50ab56b	int
,	O
0x35b5a8fa	int
,	O
0x42b2986c	int
,	O
0xdbbbc9d6	int
,	O
0xacbcf940	int
,	O
0x32d86ce3	int
,	O
0x45df5c75	int
,	O
0xdcd60dcf	int
,	O
0xabd13d59	int
,	O
0x26d930ac	int
,	O
0x51de003a	int
,	O
0xc8d75180	int
,	O
0xbfd06116	int
,	O
0x21b4f4b5	int
,	O
0x56b3c423	int
,	O
0xcfba9599	int
,	O
0xb8bda50f	int
,	O
0x2802b89e	int
,	O
0x5f058808	int
,	O
0xc60cd9b2	int
,	O
0xb10be924	int
,	O
0x2f6f7c87	int
,	O
0x58684c11	int
,	O
0xc1611dab	int
,	O
0xb6662d3d	int
,	O
0x76dc4190	int
,	O
0x01db7106	int
,	O
0x98d220bc	int
,	O
0xefd5102a	int
,	O
0x71b18589	int
,	O
0x06b6b51f	int
,	O
0x9fbfe4a5	int
,	O
0xe8b8d433	int
,	O
0x7807c9a2	int
,	O
0x0f00f934	int
,	O
0x9609a88e	int
,	O
0xe10e9818	int
,	O
0x7f6a0dbb	int
,	O
0x086d3d2d	int
,	O
0x91646c97	int
,	O
0xe6635c01	int
,	O
0x6b6b51f4	int
,	O
0x1c6c6162	int
,	O
0x856530d8	int
,	O
0xf262004e	int
,	O
0x6c0695ed	int
,	O
0x1b01a57b	int
,	O
0x8208f4c1	int
,	O
0xf50fc457	int
,	O
0x65b0d9c6	int
,	O
0x12b7e950	int
,	O
0x8bbeb8ea	int
,	O
0xfcb9887c	int
,	O
0x62dd1ddf	int
,	O
0x15da2d49	int
,	O
0x8cd37cf3	int
,	O
0xfbd44c65	int
,	O
0x4db26158	int
,	O
0x3ab551ce	int
,	O
0xa3bc0074	int
,	O
0xd4bb30e2	int
,	O
0x4adfa541	int
,	O
0x3dd895d7	int
,	O
0xa4d1c46d	int
,	O
0xd3d6f4fb	int
,	O
0x4369e96a	int
,	O
0x346ed9fc	int
,	O
0xad678846	int
,	O
0xda60b8d0	int
,	O
0x44042d73	int
,	O
0x33031de5	int
,	O
0xaa0a4c5f	int
,	O
0xdd0d7cc9	int
,	O
0x5005713c	int
,	O
0x270241aa	int
,	O
0xbe0b1010	int
,	O
0xc90c2086	int
,	O
0x5768b525	int
,	O
0x206f85b3	int
,	O
0xb966d409	int
,	O
0xce61e49f	int
,	O
0x5edef90e	int
,	O
0x29d9c998	int
,	O
0xb0d09822	int
,	O
0xc7d7a8b4	int
,	O
0x59b33d17	int
,	O
0x2eb40d81	int
,	O
0xb7bd5c3b	int
,	O
0xc0ba6cad	int
,	O
0xedb88320	int
,	O
0x9abfb3b6	int
,	O
0x03b6e20c	int
,	O
0x74b1d29a	int
,	O
0xead54739	int
,	O
0x9dd277af	int
,	O
0x04db2615	int
,	O
0x73dc1683	int
,	O
0xe3630b12	int
,	O
0x94643b84	int
,	O
0x0d6d6a3e	int
,	O
0x7a6a5aa8	int
,	O
0xe40ecf0b	int
,	O
0x9309ff9d	int
,	O
0x0a00ae27	int
,	O
0x7d079eb1	int
,	O
0xf00f9344	int
,	O
0x8708a3d2	int
,	O
0x1e01f268	int
,	O
0x6906c2fe	int
,	O
0xf762575d	int
,	O
0x806567cb	int
,	O
0x196c3671	int
,	O
0x6e6b06e7	int
,	O
0xfed41b76	int
,	O
0x89d32be0	int
,	O
0x10da7a5a	int
,	O
0x67dd4acc	int
,	O
0xf9b9df6f	int
,	O
0x8ebeeff9	int
,	O
0x17b7be43	int
,	O
0x60b08ed5	int
,	O
0xd6d6a3e8	int
,	O
0xa1d1937e	int
,	O
0x38d8c2c4	int
,	O
0x4fdff252	int
,	O
0xd1bb67f1	int
,	O
0xa6bc5767	int
,	O
0x3fb506dd	int
,	O
0x48b2364b	int
,	O
0xd80d2bda	int
,	O
0xaf0a1b4c	int
,	O
0x36034af6	int
,	O
0x41047a60	int
,	O
0xdf60efc3	int
,	O
0xa867df55	int
,	O
0x316e8eef	int
,	O
0x4669be79	int
,	O
0xcb61b38c	int
,	O
0xbc66831a	int
,	O
0x256fd2a0	int
,	O
0x5268e236	int
,	O
0xcc0c7795	int
,	O
0xbb0b4703	int
,	O
0x220216b9	int
,	O
0x5505262f	int
,	O
0xc5ba3bbe	int
,	O
0xb2bd0b28	int
,	O
0x2bb45a92	int
,	O
0x5cb36a04	int
,	O
0xc2d7ffa7	int
,	O
0xb5d0cf31	int
,	O
0x2cd99e8b	int
,	O
0x5bdeae1d	int
,	O
0x9b64c2b0	int
,	O
0xec63f226	int
,	O
0x756aa39c	int
,	O
0x026d930a	int
,	O
0x9c0906a9	int
,	O
0xeb0e363f	int
,	O
0x72076785	int
,	O
0x05005713	int
,	O
0x95bf4a82	int
,	O
0xe2b87a14	int
,	O
0x7bb12bae	int
,	O
0x0cb61b38	int
,	O
0x92d28e9b	int
,	O
0xe5d5be0d	int
,	O
0x7cdcefb7	int
,	O
0x0bdbdf21	int
,	O
0x86d3d2d4	int
,	O
0xf1d4e242	int
,	O
0x68ddb3f8	int
,	O
0x1fda836e	int
,	O
0x81be16cd	int
,	O
0xf6b9265b	int
,	O
0x6fb077e1	int
,	O
0x18b74777	int
,	O
0x88085ae6	int
,	O
0xff0f6a70	int
,	O
0x66063bca	int
,	O
0x11010b5c	int
,	O
0x8f659eff	int
,	O
0xf862ae69	int
,	O
0x616bffd3	int
,	O
0x166ccf45	int
,	O
0xa00ae278	int
,	O
0xd70dd2ee	int
,	O
0x4e048354	int
,	O
0x3903b3c2	int
,	O
0xa7672661	int
,	O
0xd06016f7	int
,	O
0x4969474d	int
,	O
0x3e6e77db	int
,	O
0xaed16a4a	int
,	O
0xd9d65adc	int
,	O
0x40df0b66	int
,	O
0x37d83bf0	int
,	O
0xa9bcae53	int
,	O
0xdebb9ec5	int
,	O
0x47b2cf7f	int
,	O
0x30b5ffe9	int
,	O
0xbdbdf21c	int
,	O
0xcabac28a	int
,	O
0x53b39330	int
,	O
0x24b4a3a6	int
,	O
0xbad03605	int
,	O
0xcdd70693	int
,	O
0x54de5729	int
,	O
0x23d967bf	int
,	O
0xb3667a2e	int
,	O
0xc4614ab8	int
,	O
0x5d681b02	int
,	O
0x2a6f2b94	int
,	O
0xb40bbe37	int
,	O
0xc30c8ea1	int
,	O
0x5a05df1b	int
,	O
0x2d02ef8d	int
}	O
;	O
const	O
unsigned	O
char	O
*	O
end	pointer
;	O
crc	long
=	O
~	O
crc	long
&	O
0xffffffff	int
;	O
for	O
(	O
end	pointer
=	O
buf	pointer
+	O
len	long
;	O
buf	pointer
<	O
end	pointer
;	O
++	O
buf	pointer
)	O
crc	long
=	O
crc32_table	array
[	O
(	O
crc	long
^	O
*	O
buf	pointer
)	O
&	O
0xff	int
]	O
^	O
(	O
crc	long
>>	O
8	int
)	O
;	O
return	O
~	O
crc	long
&	O
0xffffffff	int
;	O
}	O
typedef	O
bfd_boolean	int
(	O
*	O
check_func_type	pointer
)	O
(	O
const	O
char	O
*	O
,	O
void	O
*	O
)	O
;	O
typedef	O
const	O
char	O
*	O
(	O
*	O
parse_func_type	pointer
)	O
(	O
struct	O
dwarf_section	struct
*	O
,	O
void	O
*	O
)	O
;	O
static	O
bfd_boolean	int
check_gnu_debuglink	function
(	O
const	O
char	O
*	O
pathname	pointer
,	O
void	O
*	O
crc_pointer	pointer
)	O
{	O
static	O
unsigned	O
char	O
buffer	array
[	O
8	int
*	O
1024	int
]	O
;	O
FILE	struct
*	O
f	pointer
;	O
bfd_size_type	long
count	int
;	O
unsigned	O
long	O
crc	long
=	O
0	int
;	O
void	O
*	O
sep_data	pointer
;	O
sep_data	pointer
=	O
open_debug_file	function
(	O
pathname	pointer
)	O
;	O
if	O
(	O
sep_data	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
f	pointer
=	O
fopen	function
(	O
pathname	pointer
,	O
"rb"	pointer
)	O
;	O
if	O
(	O
f	pointer
==	O
NULL	O
)	O
{	O
close_debug_file	function
(	O
sep_data	pointer
)	O
;	O
warn	function
(	O
_	O
(	O
"Unable to reopen separate debug info file: %s\n"	pointer
)	O
,	O
pathname	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
while	O
(	O
(	O
count	int
=	O
fread	function
(	O
buffer	array
,	O
1	int
,	O
sizeof	O
(	O
buffer	array
)	O
,	O
f	pointer
)	O
)	O
>	O
0	int
)	O
crc	long
=	O
calc_gnu_debuglink_crc32	function
(	O
crc	long
,	O
buffer	array
,	O
count	int
)	O
;	O
fclose	function
(	O
f	pointer
)	O
;	O
if	O
(	O
crc	long
!=	O
*	O
(	O
unsigned	O
long	O
*	O
)	O
crc_pointer	pointer
)	O
{	O
close_debug_file	function
(	O
sep_data	pointer
)	O
;	O
warn	function
(	O
_	O
(	O
"Separate debug info file %s found, but CRC does not match - ignoring\n"	pointer
)	O
,	O
pathname	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
const	O
char	O
*	O
parse_gnu_debuglink	function
(	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
unsigned	O
int	O
crc_offset	int
;	O
unsigned	O
long	O
*	O
crc32	int
=	O
(	O
unsigned	O
long	O
*	O
)	O
data	pointer
;	O
name	pointer
=	O
(	O
const	O
char	O
*	O
)	O
section	pointer
->	O
start	pointer
;	O
crc_offset	int
=	O
strnlen	function
(	O
name	pointer
,	O
section	pointer
->	O
size	int
)	O
+	O
1	int
;	O
crc_offset	int
=	O
(	O
crc_offset	int
+	O
3	int
)	O
&	O
~	O
3	int
;	O
if	O
(	O
crc_offset	int
+	O
4	int
>	O
section	pointer
->	O
size	int
)	O
return	O
NULL	O
;	O
*	O
crc32	int
=	O
byte_get	pointer
(	O
section	pointer
->	O
start	pointer
+	O
crc_offset	int
,	O
4	int
)	O
;	O
return	O
name	pointer
;	O
}	O
static	O
bfd_boolean	int
check_gnu_debugaltlink	function
(	O
const	O
char	O
*	O
filename	pointer
,	O
void	O
*	O
data	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
void	O
*	O
sep_data	pointer
=	O
open_debug_file	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
sep_data	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
return	O
TRUE	int
;	O
}	O
typedef	O
struct	O
build_id_data	struct
{	O
bfd_size_type	long
len	long
;	O
const	O
unsigned	O
char	O
*	O
data	pointer
;	O
}	O
Build_id_data	struct
;	O
static	O
const	O
char	O
*	O
parse_gnu_debugaltlink	function
(	O
struct	O
dwarf_section	struct
*	O
section	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
bfd_size_type	long
namelen	long
;	O
bfd_size_type	long
id_len	long
;	O
Build_id_data	struct
*	O
build_id_data	struct
;	O
name	pointer
=	O
(	O
const	O
char	O
*	O
)	O
section	pointer
->	O
start	pointer
;	O
namelen	long
=	O
strnlen	function
(	O
name	pointer
,	O
section	pointer
->	O
size	int
)	O
+	O
1	int
;	O
if	O
(	O
namelen	long
>=	O
section	pointer
->	O
size	int
)	O
return	O
NULL	O
;	O
id_len	long
=	O
section	pointer
->	O
size	int
-	O
namelen	long
;	O
if	O
(	O
id_len	long
<	O
0x14	int
)	O
return	O
NULL	O
;	O
build_id_data	struct
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
*	O
build_id_data	struct
)	O
;	O
if	O
(	O
build_id_data	struct
==	O
NULL	O
)	O
return	O
NULL	O
;	O
build_id_data	struct
->	O
len	long
=	O
id_len	long
;	O
build_id_data	struct
->	O
data	pointer
=	O
section	pointer
->	O
start	pointer
+	O
namelen	long
;	O
*	O
(	O
Build_id_data	struct
*	O
*	O
)	O
data	pointer
=	O
build_id_data	struct
;	O
return	O
name	pointer
;	O
}	O
static	O
void	O
add_separate_debug_file	function
(	O
const	O
char	O
*	O
filename	pointer
,	O
void	O
*	O
handle	pointer
)	O
{	O
separate_info	struct
*	O
i	pointer
=	O
xmalloc	function
(	O
sizeof	O
*	O
i	pointer
)	O
;	O
i	pointer
->	O
filename	pointer
=	O
filename	pointer
;	O
i	pointer
->	O
handle	pointer
=	O
handle	pointer
;	O
i	pointer
->	O
next	pointer
=	O
first_separate_info	pointer
;	O
first_separate_info	pointer
=	O
i	pointer
;	O
}	O
static	O
void	O
*	O
load_separate_debug_info	function
(	O
const	O
char	O
*	O
main_filename	pointer
,	O
struct	O
dwarf_section	struct
*	O
xlink	pointer
,	O
parse_func_type	pointer
parse_func	pointer
,	O
check_func_type	pointer
check_func	pointer
,	O
void	O
*	O
func_data	pointer
,	O
void	O
*	O
file	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
const	O
char	O
*	O
separate_filename	pointer
;	O
char	O
*	O
debug_filename	pointer
;	O
char	O
*	O
canon_dir	pointer
;	O
size_t	long
canon_dirlen	long
;	O
size_t	long
dirlen	long
;	O
if	O
(	O
(	O
separate_filename	pointer
=	O
parse_func	pointer
(	O
xlink	pointer
,	O
func_data	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
warn	function
(	O
_	O
(	O
"Corrupt debuglink section: %s\n"	pointer
)	O
,	O
xlink	pointer
->	O
name	pointer
?	O
xlink	pointer
->	O
name	pointer
:	O
xlink	pointer
->	O
uncompressed_name	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
canon_dir	pointer
=	O
lrealpath	function
(	O
main_filename	pointer
)	O
;	O
for	O
(	O
canon_dirlen	long
=	O
strlen	function
(	O
canon_dir	pointer
)	O
;	O
canon_dirlen	long
>	O
0	int
;	O
canon_dirlen	long
--	O
)	O
if	O
(	O
IS_DIR_SEPARATOR	O
(	O
canon_dir	pointer
[	O
canon_dirlen	long
-	O
1	int
]	O
)	O
)	O
break	O
;	O
canon_dir	pointer
[	O
canon_dirlen	long
]	O
=	O
'\0'	O
;	O
debug_filename	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
strlen	function
(	O
DEBUGDIR	pointer
)	O
+	O
1	int
+	O
canon_dirlen	long
+	O
strlen	function
(	O
".debug/"	pointer
)	O
+	O
strlen	function
(	O
EXTRA_DEBUG_ROOT1	pointer
)	O
+	O
strlen	function
(	O
EXTRA_DEBUG_ROOT2	pointer
)	O
+	O
strlen	function
(	O
separate_filename	pointer
)	O
+	O
1	int
)	O
;	O
if	O
(	O
debug_filename	pointer
==	O
NULL	O
)	O
{	O
warn	function
(	O
_	O
(	O
"Out of memory"	pointer
)	O
)	O
;	O
free	function
(	O
canon_dir	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
sprintf	function
(	O
debug_filename	pointer
,	O
"%s"	pointer
,	O
separate_filename	pointer
)	O
;	O
if	O
(	O
check_func	pointer
(	O
debug_filename	pointer
,	O
func_data	pointer
)	O
)	O
goto	O
found	O
;	O
sprintf	function
(	O
debug_filename	pointer
,	O
".debug/%s"	pointer
,	O
separate_filename	pointer
)	O
;	O
if	O
(	O
check_func	pointer
(	O
debug_filename	pointer
,	O
func_data	pointer
)	O
)	O
goto	O
found	O
;	O
sprintf	function
(	O
debug_filename	pointer
,	O
"%s%s"	pointer
,	O
canon_dir	pointer
,	O
separate_filename	pointer
)	O
;	O
if	O
(	O
check_func	pointer
(	O
debug_filename	pointer
,	O
func_data	pointer
)	O
)	O
goto	O
found	O
;	O
sprintf	function
(	O
debug_filename	pointer
,	O
"%s.debug/%s"	pointer
,	O
canon_dir	pointer
,	O
separate_filename	pointer
)	O
;	O
if	O
(	O
check_func	pointer
(	O
debug_filename	pointer
,	O
func_data	pointer
)	O
)	O
goto	O
found	O
;	O
sprintf	function
(	O
debug_filename	pointer
,	O
"%s/%s"	pointer
,	O
EXTRA_DEBUG_ROOT1	pointer
,	O
separate_filename	pointer
)	O
;	O
if	O
(	O
check_func	pointer
(	O
debug_filename	pointer
,	O
func_data	pointer
)	O
)	O
goto	O
found	O
;	O
sprintf	function
(	O
debug_filename	pointer
,	O
"%s/%s/%s"	pointer
,	O
EXTRA_DEBUG_ROOT1	pointer
,	O
canon_dir	pointer
,	O
separate_filename	pointer
)	O
;	O
if	O
(	O
check_func	pointer
(	O
debug_filename	pointer
,	O
func_data	pointer
)	O
)	O
goto	O
found	O
;	O
sprintf	function
(	O
debug_filename	pointer
,	O
"%s/%s"	pointer
,	O
EXTRA_DEBUG_ROOT2	pointer
,	O
separate_filename	pointer
)	O
;	O
if	O
(	O
check_func	pointer
(	O
debug_filename	pointer
,	O
func_data	pointer
)	O
)	O
goto	O
found	O
;	O
strcpy	function
(	O
debug_filename	pointer
,	O
DEBUGDIR	pointer
)	O
;	O
dirlen	long
=	O
strlen	function
(	O
DEBUGDIR	pointer
)	O
-	O
1	int
;	O
if	O
(	O
dirlen	long
>	O
0	int
&&	O
DEBUGDIR	pointer
[	O
dirlen	long
]	O
!=	O
'/'	O
)	O
strcat	function
(	O
debug_filename	pointer
,	O
"/"	pointer
)	O
;	O
strcat	function
(	O
debug_filename	pointer
,	O
(	O
const	O
char	O
*	O
)	O
separate_filename	pointer
)	O
;	O
if	O
(	O
check_func	pointer
(	O
debug_filename	pointer
,	O
func_data	pointer
)	O
)	O
goto	O
found	O
;	O
warn	function
(	O
_	O
(	O
"could not find separate debug file '%s'\n"	pointer
)	O
,	O
separate_filename	pointer
)	O
;	O
warn	function
(	O
_	O
(	O
"tried: %s\n"	pointer
)	O
,	O
debug_filename	pointer
)	O
;	O
sprintf	function
(	O
debug_filename	pointer
,	O
"%s/%s"	pointer
,	O
EXTRA_DEBUG_ROOT2	pointer
,	O
separate_filename	pointer
)	O
;	O
warn	function
(	O
_	O
(	O
"tried: %s\n"	pointer
)	O
,	O
debug_filename	pointer
)	O
;	O
sprintf	function
(	O
debug_filename	pointer
,	O
"%s/%s/%s"	pointer
,	O
EXTRA_DEBUG_ROOT1	pointer
,	O
canon_dir	pointer
,	O
separate_filename	pointer
)	O
;	O
warn	function
(	O
_	O
(	O
"tried: %s\n"	pointer
)	O
,	O
debug_filename	pointer
)	O
;	O
sprintf	function
(	O
debug_filename	pointer
,	O
"%s/%s"	pointer
,	O
EXTRA_DEBUG_ROOT1	pointer
,	O
separate_filename	pointer
)	O
;	O
warn	function
(	O
_	O
(	O
"tried: %s\n"	pointer
)	O
,	O
debug_filename	pointer
)	O
;	O
sprintf	function
(	O
debug_filename	pointer
,	O
"%s.debug/%s"	pointer
,	O
canon_dir	pointer
,	O
separate_filename	pointer
)	O
;	O
warn	function
(	O
_	O
(	O
"tried: %s\n"	pointer
)	O
,	O
debug_filename	pointer
)	O
;	O
sprintf	function
(	O
debug_filename	pointer
,	O
"%s%s"	pointer
,	O
canon_dir	pointer
,	O
separate_filename	pointer
)	O
;	O
warn	function
(	O
_	O
(	O
"tried: %s\n"	pointer
)	O
,	O
debug_filename	pointer
)	O
;	O
sprintf	function
(	O
debug_filename	pointer
,	O
".debug/%s"	pointer
,	O
separate_filename	pointer
)	O
;	O
warn	function
(	O
_	O
(	O
"tried: %s\n"	pointer
)	O
,	O
debug_filename	pointer
)	O
;	O
sprintf	function
(	O
debug_filename	pointer
,	O
"%s"	pointer
,	O
separate_filename	pointer
)	O
;	O
warn	function
(	O
_	O
(	O
"tried: %s\n"	pointer
)	O
,	O
debug_filename	pointer
)	O
;	O
free	function
(	O
canon_dir	pointer
)	O
;	O
free	function
(	O
debug_filename	pointer
)	O
;	O
return	O
NULL	O
;	O
found	O
:	O
free	function
(	O
canon_dir	pointer
)	O
;	O
void	O
*	O
debug_handle	pointer
;	O
if	O
(	O
(	O
debug_handle	pointer
=	O
open_debug_file	function
(	O
debug_filename	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
warn	function
(	O
_	O
(	O
"failed to open separate debug file: %s\n"	pointer
)	O
,	O
debug_filename	pointer
)	O
;	O
free	function
(	O
debug_filename	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
printf	function
(	O
_	O
(	O
"%s: Found separate debug info file: %s\n\n"	pointer
)	O
,	O
main_filename	pointer
,	O
debug_filename	pointer
)	O
;	O
add_separate_debug_file	function
(	O
debug_filename	pointer
,	O
debug_handle	pointer
)	O
;	O
return	O
debug_handle	pointer
;	O
}	O
static	O
void	O
*	O
load_dwo_file	function
(	O
const	O
char	O
*	O
main_filename	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
const	O
char	O
*	O
dir	pointer
,	O
const	O
char	O
*	O
id	int
ATTRIBUTE_UNUSED	O
)	O
{	O
char	O
*	O
separate_filename	pointer
;	O
void	O
*	O
separate_handle	pointer
;	O
separate_filename	pointer
=	O
concat	function
(	O
dir	pointer
,	O
"/"	pointer
,	O
name	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
separate_filename	pointer
==	O
NULL	O
)	O
{	O
warn	function
(	O
_	O
(	O
"Out of memory allocating dwo filename\n"	pointer
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
(	O
separate_handle	pointer
=	O
open_debug_file	function
(	O
separate_filename	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
warn	function
(	O
_	O
(	O
"Unable to load dwo file: %s\n"	pointer
)	O
,	O
separate_filename	pointer
)	O
;	O
free	function
(	O
separate_filename	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
printf	function
(	O
_	O
(	O
"%s: Found separate debug object file: %s\n\n"	pointer
)	O
,	O
main_filename	pointer
,	O
separate_filename	pointer
)	O
;	O
add_separate_debug_file	function
(	O
separate_filename	pointer
,	O
separate_handle	pointer
)	O
;	O
return	O
separate_handle	pointer
;	O
}	O
bfd_boolean	int
load_separate_debug_files	function
(	O
void	O
*	O
file	pointer
,	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
if	O
(	O
!	O
do_follow_links	int
&&	O
!	O
do_debug_links	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
load_debug_section	function
(	O
str	int
,	O
file	pointer
)	O
&&	O
load_debug_section	function
(	O
abbrev	int
,	O
file	pointer
)	O
&&	O
load_debug_section	function
(	O
info	pointer
,	O
file	pointer
)	O
)	O
{	O
free_dwo_info	function
(	O
)	O
;	O
if	O
(	O
process_debug_info	function
(	O
&	O
debug_displays	array
[	O
info	pointer
]	O
.	O
section	pointer
,	O
file	pointer
,	O
abbrev	int
,	O
TRUE	int
,	O
FALSE	int
)	O
)	O
{	O
bfd_boolean	int
introduced	int
=	O
FALSE	int
;	O
dwo_info	struct
*	O
dwinfo	pointer
;	O
const	O
char	O
*	O
dir	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
id	int
=	O
NULL	O
;	O
for	O
(	O
dwinfo	pointer
=	O
first_dwo_info	pointer
;	O
dwinfo	pointer
!=	O
NULL	O
;	O
dwinfo	pointer
=	O
dwinfo	pointer
->	O
next	pointer
)	O
{	O
switch	O
(	O
dwinfo	pointer
->	O
type	enum
)	O
{	O
case	O
DWO_NAME	int
:	O
if	O
(	O
do_debug_links	int
)	O
{	O
if	O
(	O
!	O
introduced	int
)	O
{	O
printf	function
(	O
_	O
(	O
"The %s section contains link(s) to dwo file(s):\n\n"	pointer
)	O
,	O
debug_displays	array
[	O
info	pointer
]	O
.	O
section	pointer
.	O
uncompressed_name	pointer
)	O
;	O
introduced	int
=	O
TRUE	int
;	O
}	O
printf	function
(	O
_	O
(	O
"  Name:      %s\n"	pointer
)	O
,	O
dwinfo	pointer
->	O
value	long
)	O
;	O
printf	function
(	O
_	O
(	O
"  Directory: %s\n"	pointer
)	O
,	O
dir	pointer
?	O
dir	pointer
:	O
_	O
(	O
"<not-found>"	pointer
)	O
)	O
;	O
if	O
(	O
id	int
!=	O
NULL	O
)	O
display_data	function
(	O
printf	function
(	O
_	O
(	O
"  ID:       "	pointer
)	O
)	O
,	O
(	O
unsigned	O
char	O
*	O
)	O
id	int
,	O
8	int
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"  ID: <unknown>\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n\n"	pointer
)	O
;	O
}	O
if	O
(	O
do_follow_links	int
)	O
load_dwo_file	function
(	O
filename	pointer
,	O
dwinfo	pointer
->	O
value	long
,	O
dir	pointer
,	O
id	int
)	O
;	O
break	O
;	O
case	O
DWO_DIR	int
:	O
dir	pointer
=	O
dwinfo	pointer
->	O
value	long
;	O
break	O
;	O
case	O
DWO_ID	int
:	O
id	int
=	O
dwinfo	pointer
->	O
value	long
;	O
break	O
;	O
default	O
:	O
error	function
(	O
_	O
(	O
"Unexpected DWO INFO type"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
!	O
do_follow_links	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
load_debug_section	function
(	O
gnu_debugaltlink	int
,	O
file	pointer
)	O
)	O
{	O
Build_id_data	struct
*	O
build_id_data	struct
;	O
load_separate_debug_info	function
(	O
filename	pointer
,	O
&	O
debug_displays	array
[	O
gnu_debugaltlink	int
]	O
.	O
section	pointer
,	O
parse_gnu_debugaltlink	function
,	O
check_gnu_debugaltlink	function
,	O
&	O
build_id_data	struct
,	O
file	pointer
)	O
;	O
}	O
if	O
(	O
load_debug_section	function
(	O
gnu_debuglink	int
,	O
file	pointer
)	O
)	O
{	O
unsigned	O
long	O
crc32	int
;	O
load_separate_debug_info	function
(	O
filename	pointer
,	O
&	O
debug_displays	array
[	O
gnu_debuglink	int
]	O
.	O
section	pointer
,	O
parse_gnu_debuglink	function
,	O
check_gnu_debuglink	function
,	O
&	O
crc32	int
,	O
file	pointer
)	O
;	O
}	O
if	O
(	O
first_separate_info	pointer
!=	O
NULL	O
)	O
return	O
TRUE	int
;	O
do_follow_links	int
=	O
0	int
;	O
return	O
FALSE	int
;	O
}	O
void	O
free_debug_memory	function
(	O
void	O
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
free_abbrevs	function
(	O
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
max	int
;	O
i	pointer
++	O
)	O
free_debug_section	function
(	O
(	O
enum	O
dwarf_section_display_enum	enum
)	O
i	pointer
)	O
;	O
if	O
(	O
debug_information	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
num_debug_info_entries	int
!=	O
DEBUG_INFO_UNAVAILABLE	O
)	O
{	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
num_debug_info_entries	int
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
!	O
debug_information	pointer
[	O
i	pointer
]	O
.	O
max_loc_offsets	int
)	O
{	O
free	function
(	O
debug_information	pointer
[	O
i	pointer
]	O
.	O
loc_offsets	pointer
)	O
;	O
free	function
(	O
debug_information	pointer
[	O
i	pointer
]	O
.	O
have_frame_base	pointer
)	O
;	O
}	O
if	O
(	O
!	O
debug_information	pointer
[	O
i	pointer
]	O
.	O
max_range_lists	int
)	O
free	function
(	O
debug_information	pointer
[	O
i	pointer
]	O
.	O
range_lists	pointer
)	O
;	O
}	O
}	O
free	function
(	O
debug_information	pointer
)	O
;	O
debug_information	pointer
=	O
NULL	O
;	O
alloc_num_debug_info_entries	int
=	O
num_debug_info_entries	int
=	O
0	int
;	O
}	O
separate_info	struct
*	O
d	pointer
;	O
separate_info	struct
*	O
next	pointer
;	O
for	O
(	O
d	pointer
=	O
first_separate_info	pointer
;	O
d	pointer
!=	O
NULL	O
;	O
d	pointer
=	O
next	pointer
)	O
{	O
close_debug_file	function
(	O
d	pointer
->	O
handle	pointer
)	O
;	O
free	function
(	O
(	O
void	O
*	O
)	O
d	pointer
->	O
filename	pointer
)	O
;	O
next	pointer
=	O
d	pointer
->	O
next	pointer
;	O
free	function
(	O
(	O
void	O
*	O
)	O
d	pointer
)	O
;	O
}	O
first_separate_info	pointer
=	O
NULL	O
;	O
free_dwo_info	function
(	O
)	O
;	O
}	O
void	O
dwarf_select_sections_by_names	function
(	O
const	O
char	O
*	O
names	struct
)	O
{	O
typedef	O
struct	O
{	O
const	O
char	O
*	O
option	pointer
;	O
int	O
*	O
variable	pointer
;	O
int	O
val	array
;	O
}	O
debug_dump_long_opts	struct
;	O
static	O
const	O
debug_dump_long_opts	struct
opts_table	array
[	O
]	O
=	O
{	O
{	O
"Ranges"	pointer
,	O
&	O
do_debug_ranges	int
,	O
1	int
}	O
,	O
{	O
"abbrev"	pointer
,	O
&	O
do_debug_abbrevs	int
,	O
1	int
}	O
,	O
{	O
"addr"	pointer
,	O
&	O
do_debug_addr	int
,	O
1	int
}	O
,	O
{	O
"aranges"	pointer
,	O
&	O
do_debug_aranges	int
,	O
1	int
}	O
,	O
{	O
"cu_index"	pointer
,	O
&	O
do_debug_cu_index	int
,	O
1	int
}	O
,	O
{	O
"decodedline"	pointer
,	O
&	O
do_debug_lines	int
,	O
FLAG_DEBUG_LINES_DECODED	int
}	O
,	O
{	O
"follow-links"	pointer
,	O
&	O
do_follow_links	int
,	O
1	int
}	O
,	O
{	O
"frames"	pointer
,	O
&	O
do_debug_frames	int
,	O
1	int
}	O
,	O
{	O
"frames-interp"	pointer
,	O
&	O
do_debug_frames_interp	int
,	O
1	int
}	O
,	O
{	O
"gdb_index"	pointer
,	O
&	O
do_gdb_index	int
,	O
1	int
}	O
,	O
{	O
"info"	pointer
,	O
&	O
do_debug_info	int
,	O
1	int
}	O
,	O
{	O
"line"	pointer
,	O
&	O
do_debug_lines	int
,	O
FLAG_DEBUG_LINES_RAW	int
}	O
,	O
{	O
"links"	pointer
,	O
&	O
do_debug_links	int
,	O
1	int
}	O
,	O
{	O
"loc"	pointer
,	O
&	O
do_debug_loc	int
,	O
1	int
}	O
,	O
{	O
"macro"	pointer
,	O
&	O
do_debug_macinfo	int
,	O
1	int
}	O
,	O
{	O
"pubnames"	pointer
,	O
&	O
do_debug_pubnames	int
,	O
1	int
}	O
,	O
{	O
"pubtypes"	pointer
,	O
&	O
do_debug_pubtypes	int
,	O
1	int
}	O
,	O
{	O
"ranges"	pointer
,	O
&	O
do_debug_aranges	int
,	O
1	int
}	O
,	O
{	O
"rawline"	pointer
,	O
&	O
do_debug_lines	int
,	O
FLAG_DEBUG_LINES_RAW	int
}	O
,	O
{	O
"str"	pointer
,	O
&	O
do_debug_str	int
,	O
1	int
}	O
,	O
{	O
"trace_abbrev"	pointer
,	O
&	O
do_trace_abbrevs	int
,	O
1	int
}	O
,	O
{	O
"trace_aranges"	pointer
,	O
&	O
do_trace_aranges	int
,	O
1	int
}	O
,	O
{	O
"trace_info"	pointer
,	O
&	O
do_trace_info	int
,	O
1	int
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
const	O
char	O
*	O
p	pointer
;	O
p	pointer
=	O
names	struct
;	O
while	O
(	O
*	O
p	pointer
)	O
{	O
const	O
debug_dump_long_opts	struct
*	O
entry	long
;	O
for	O
(	O
entry	long
=	O
opts_table	array
;	O
entry	long
->	O
option	pointer
;	O
entry	long
++	O
)	O
{	O
size_t	long
len	long
=	O
strlen	function
(	O
entry	long
->	O
option	pointer
)	O
;	O
if	O
(	O
strncmp	function
(	O
p	pointer
,	O
entry	long
->	O
option	pointer
,	O
len	long
)	O
==	O
0	int
&&	O
(	O
p	pointer
[	O
len	long
]	O
==	O
','	O
||	O
p	pointer
[	O
len	long
]	O
==	O
'\0'	O
)	O
)	O
{	O
*	O
entry	long
->	O
variable	pointer
|=	O
entry	long
->	O
val	array
;	O
if	O
(	O
do_debug_frames_interp	int
)	O
do_debug_frames	int
=	O
1	int
;	O
p	pointer
+=	O
len	long
;	O
break	O
;	O
}	O
}	O
if	O
(	O
entry	long
->	O
option	pointer
==	O
NULL	O
)	O
{	O
warn	function
(	O
_	O
(	O
"Unrecognized debug option '%s'\n"	pointer
)	O
,	O
p	pointer
)	O
;	O
p	pointer
=	O
strchr	function
(	O
p	pointer
,	O
','	O
)	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
break	O
;	O
}	O
if	O
(	O
*	O
p	pointer
==	O
','	O
)	O
p	pointer
++	O
;	O
}	O
}	O
void	O
dwarf_select_sections_by_letters	function
(	O
const	O
char	O
*	O
letters	pointer
)	O
{	O
unsigned	O
int	O
lindex	int
=	O
0	int
;	O
while	O
(	O
letters	pointer
[	O
lindex	int
]	O
)	O
switch	O
(	O
letters	pointer
[	O
lindex	int
++	O
]	O
)	O
{	O
case	O
'A'	O
:	O
do_debug_addr	int
=	O
1	int
;	O
break	O
;	O
case	O
'a'	O
:	O
do_debug_abbrevs	int
=	O
1	int
;	O
break	O
;	O
case	O
'c'	O
:	O
do_debug_cu_index	int
=	O
1	int
;	O
break	O
;	O
case	O
'F'	O
:	O
do_debug_frames_interp	int
=	O
1	int
;	O
case	O
'f'	O
:	O
do_debug_frames	int
=	O
1	int
;	O
break	O
;	O
case	O
'g'	O
:	O
do_gdb_index	int
=	O
1	int
;	O
break	O
;	O
case	O
'i'	O
:	O
do_debug_info	int
=	O
1	int
;	O
break	O
;	O
case	O
'K'	O
:	O
do_follow_links	int
=	O
1	int
;	O
break	O
;	O
case	O
'k'	O
:	O
do_debug_links	int
=	O
1	int
;	O
break	O
;	O
case	O
'l'	O
:	O
do_debug_lines	int
|=	O
FLAG_DEBUG_LINES_RAW	int
;	O
break	O
;	O
case	O
'L'	O
:	O
do_debug_lines	int
|=	O
FLAG_DEBUG_LINES_DECODED	int
;	O
break	O
;	O
case	O
'm'	O
:	O
do_debug_macinfo	int
=	O
1	int
;	O
break	O
;	O
case	O
'o'	O
:	O
do_debug_loc	int
=	O
1	int
;	O
break	O
;	O
case	O
'p'	O
:	O
do_debug_pubnames	int
=	O
1	int
;	O
break	O
;	O
case	O
'R'	O
:	O
do_debug_ranges	int
=	O
1	int
;	O
break	O
;	O
case	O
'r'	O
:	O
do_debug_aranges	int
=	O
1	int
;	O
break	O
;	O
case	O
's'	O
:	O
do_debug_str	int
=	O
1	int
;	O
break	O
;	O
case	O
'T'	O
:	O
do_trace_aranges	int
=	O
1	int
;	O
break	O
;	O
case	O
't'	O
:	O
do_debug_pubtypes	int
=	O
1	int
;	O
break	O
;	O
case	O
'U'	O
:	O
do_trace_info	int
=	O
1	int
;	O
break	O
;	O
case	O
'u'	O
:	O
do_trace_abbrevs	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
warn	function
(	O
_	O
(	O
"Unrecognized debug option '%s'\n"	pointer
)	O
,	O
letters	pointer
)	O
;	O
break	O
;	O
}	O
}	O
void	O
dwarf_select_sections_all	function
(	O
void	O
)	O
{	O
do_debug_info	int
=	O
1	int
;	O
do_debug_abbrevs	int
=	O
1	int
;	O
do_debug_lines	int
=	O
FLAG_DEBUG_LINES_RAW	int
;	O
do_debug_pubnames	int
=	O
1	int
;	O
do_debug_pubtypes	int
=	O
1	int
;	O
do_debug_aranges	int
=	O
1	int
;	O
do_debug_ranges	int
=	O
1	int
;	O
do_debug_frames	int
=	O
1	int
;	O
do_debug_macinfo	int
=	O
1	int
;	O
do_debug_str	int
=	O
1	int
;	O
do_debug_loc	int
=	O
1	int
;	O
do_gdb_index	int
=	O
1	int
;	O
do_trace_info	int
=	O
1	int
;	O
do_trace_abbrevs	int
=	O
1	int
;	O
do_trace_aranges	int
=	O
1	int
;	O
do_debug_addr	int
=	O
1	int
;	O
do_debug_cu_index	int
=	O
1	int
;	O
do_follow_links	int
=	O
1	int
;	O
do_debug_links	int
=	O
1	int
;	O
}	O
struct	O
dwarf_section_display	struct
debug_displays	array
[	O
]	O
=	O
{	O
{	O
{	O
".debug_abbrev"	pointer
,	O
".zdebug_abbrev"	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_debug_abbrev	function
,	O
&	O
do_debug_abbrevs	int
,	O
FALSE	int
}	O
,	O
{	O
{	O
".debug_aranges"	pointer
,	O
".zdebug_aranges"	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_debug_aranges	function
,	O
&	O
do_debug_aranges	int
,	O
TRUE	int
}	O
,	O
{	O
{	O
".debug_frame"	pointer
,	O
".zdebug_frame"	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_debug_frames	function
,	O
&	O
do_debug_frames	int
,	O
TRUE	int
}	O
,	O
{	O
{	O
".debug_info"	pointer
,	O
".zdebug_info"	pointer
,	O
ABBREV	O
(	O
abbrev	int
)	O
}	O
,	O
display_debug_info	function
,	O
&	O
do_debug_info	int
,	O
TRUE	int
}	O
,	O
{	O
{	O
".debug_line"	pointer
,	O
".zdebug_line"	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_debug_lines	function
,	O
&	O
do_debug_lines	int
,	O
TRUE	int
}	O
,	O
{	O
{	O
".debug_pubnames"	pointer
,	O
".zdebug_pubnames"	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_debug_pubnames	function
,	O
&	O
do_debug_pubnames	int
,	O
FALSE	int
}	O
,	O
{	O
{	O
".debug_gnu_pubnames"	pointer
,	O
".zdebug_gnu_pubnames"	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_debug_gnu_pubnames	function
,	O
&	O
do_debug_pubnames	int
,	O
FALSE	int
}	O
,	O
{	O
{	O
".eh_frame"	pointer
,	O
""	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_debug_frames	function
,	O
&	O
do_debug_frames	int
,	O
TRUE	int
}	O
,	O
{	O
{	O
".debug_macinfo"	pointer
,	O
".zdebug_macinfo"	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_debug_macinfo	function
,	O
&	O
do_debug_macinfo	int
,	O
FALSE	int
}	O
,	O
{	O
{	O
".debug_macro"	pointer
,	O
".zdebug_macro"	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_debug_macro	function
,	O
&	O
do_debug_macinfo	int
,	O
TRUE	int
}	O
,	O
{	O
{	O
".debug_str"	pointer
,	O
".zdebug_str"	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_debug_str	function
,	O
&	O
do_debug_str	int
,	O
FALSE	int
}	O
,	O
{	O
{	O
".debug_line_str"	pointer
,	O
".zdebug_line_str"	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_debug_str	function
,	O
&	O
do_debug_str	int
,	O
FALSE	int
}	O
,	O
{	O
{	O
".debug_loc"	pointer
,	O
".zdebug_loc"	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_debug_loc	function
,	O
&	O
do_debug_loc	int
,	O
TRUE	int
}	O
,	O
{	O
{	O
".debug_loclists"	pointer
,	O
".zdebug_loclists"	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_debug_loc	function
,	O
&	O
do_debug_loc	int
,	O
TRUE	int
}	O
,	O
{	O
{	O
".debug_pubtypes"	pointer
,	O
".zdebug_pubtypes"	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_debug_pubnames	function
,	O
&	O
do_debug_pubtypes	int
,	O
FALSE	int
}	O
,	O
{	O
{	O
".debug_gnu_pubtypes"	pointer
,	O
".zdebug_gnu_pubtypes"	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_debug_gnu_pubnames	function
,	O
&	O
do_debug_pubtypes	int
,	O
FALSE	int
}	O
,	O
{	O
{	O
".debug_ranges"	pointer
,	O
".zdebug_ranges"	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_debug_ranges	function
,	O
&	O
do_debug_ranges	int
,	O
TRUE	int
}	O
,	O
{	O
{	O
".debug_rnglists"	pointer
,	O
".zdebug_rnglists"	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_debug_ranges	function
,	O
&	O
do_debug_ranges	int
,	O
TRUE	int
}	O
,	O
{	O
{	O
".debug_static_func"	pointer
,	O
".zdebug_static_func"	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_debug_not_supported	function
,	O
NULL	O
,	O
FALSE	int
}	O
,	O
{	O
{	O
".debug_static_vars"	pointer
,	O
".zdebug_static_vars"	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_debug_not_supported	function
,	O
NULL	O
,	O
FALSE	int
}	O
,	O
{	O
{	O
".debug_types"	pointer
,	O
".zdebug_types"	pointer
,	O
ABBREV	O
(	O
abbrev	int
)	O
}	O
,	O
display_debug_types	function
,	O
&	O
do_debug_info	int
,	O
TRUE	int
}	O
,	O
{	O
{	O
".debug_weaknames"	pointer
,	O
".zdebug_weaknames"	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_debug_not_supported	function
,	O
NULL	O
,	O
FALSE	int
}	O
,	O
{	O
{	O
".gdb_index"	pointer
,	O
""	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_gdb_index	function
,	O
&	O
do_gdb_index	int
,	O
FALSE	int
}	O
,	O
{	O
{	O
".debug_names"	pointer
,	O
""	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_debug_names	function
,	O
&	O
do_gdb_index	int
,	O
FALSE	int
}	O
,	O
{	O
{	O
".trace_info"	pointer
,	O
""	pointer
,	O
ABBREV	O
(	O
trace_abbrev	int
)	O
}	O
,	O
display_trace_info	function
,	O
&	O
do_trace_info	int
,	O
TRUE	int
}	O
,	O
{	O
{	O
".trace_abbrev"	pointer
,	O
""	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_debug_abbrev	function
,	O
&	O
do_trace_abbrevs	int
,	O
FALSE	int
}	O
,	O
{	O
{	O
".trace_aranges"	pointer
,	O
""	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_debug_aranges	function
,	O
&	O
do_trace_aranges	int
,	O
FALSE	int
}	O
,	O
{	O
{	O
".debug_info.dwo"	pointer
,	O
".zdebug_info.dwo"	pointer
,	O
ABBREV	O
(	O
abbrev_dwo	int
)	O
}	O
,	O
display_debug_info	function
,	O
&	O
do_debug_info	int
,	O
TRUE	int
}	O
,	O
{	O
{	O
".debug_abbrev.dwo"	pointer
,	O
".zdebug_abbrev.dwo"	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_debug_abbrev	function
,	O
&	O
do_debug_abbrevs	int
,	O
FALSE	int
}	O
,	O
{	O
{	O
".debug_types.dwo"	pointer
,	O
".zdebug_types.dwo"	pointer
,	O
ABBREV	O
(	O
abbrev_dwo	int
)	O
}	O
,	O
display_debug_types	function
,	O
&	O
do_debug_info	int
,	O
TRUE	int
}	O
,	O
{	O
{	O
".debug_line.dwo"	pointer
,	O
".zdebug_line.dwo"	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_debug_lines	function
,	O
&	O
do_debug_lines	int
,	O
TRUE	int
}	O
,	O
{	O
{	O
".debug_loc.dwo"	pointer
,	O
".zdebug_loc.dwo"	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_debug_loc	function
,	O
&	O
do_debug_loc	int
,	O
TRUE	int
}	O
,	O
{	O
{	O
".debug_macro.dwo"	pointer
,	O
".zdebug_macro.dwo"	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_debug_macro	function
,	O
&	O
do_debug_macinfo	int
,	O
TRUE	int
}	O
,	O
{	O
{	O
".debug_macinfo.dwo"	pointer
,	O
".zdebug_macinfo.dwo"	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_debug_macinfo	function
,	O
&	O
do_debug_macinfo	int
,	O
FALSE	int
}	O
,	O
{	O
{	O
".debug_str.dwo"	pointer
,	O
".zdebug_str.dwo"	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_debug_str	function
,	O
&	O
do_debug_str	int
,	O
TRUE	int
}	O
,	O
{	O
{	O
".debug_str_offsets"	pointer
,	O
".zdebug_str_offsets"	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_debug_str_offsets	function
,	O
NULL	O
,	O
FALSE	int
}	O
,	O
{	O
{	O
".debug_str_offsets.dwo"	pointer
,	O
".zdebug_str_offsets.dwo"	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_debug_str_offsets	function
,	O
NULL	O
,	O
FALSE	int
}	O
,	O
{	O
{	O
".debug_addr"	pointer
,	O
".zdebug_addr"	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_debug_addr	function
,	O
&	O
do_debug_addr	int
,	O
TRUE	int
}	O
,	O
{	O
{	O
".debug_cu_index"	pointer
,	O
""	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_cu_index	function
,	O
&	O
do_debug_cu_index	int
,	O
FALSE	int
}	O
,	O
{	O
{	O
".debug_tu_index"	pointer
,	O
""	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_cu_index	function
,	O
&	O
do_debug_cu_index	int
,	O
FALSE	int
}	O
,	O
{	O
{	O
".gnu_debuglink"	pointer
,	O
""	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_debug_links	function
,	O
&	O
do_debug_links	int
,	O
FALSE	int
}	O
,	O
{	O
{	O
".gnu_debugaltlink"	pointer
,	O
""	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_debug_links	function
,	O
&	O
do_debug_links	int
,	O
FALSE	int
}	O
,	O
{	O
{	O
".debug_str"	pointer
,	O
".zdebug_str"	pointer
,	O
NO_ABBREVS	O
}	O
,	O
display_debug_str	function
,	O
&	O
do_debug_str	int
,	O
FALSE	int
}	O
,	O
}	O
;	O
extern	O
int	O
debug_displays_assert	array
[	O
ARRAY_SIZE	O
(	O
debug_displays	array
)	O
==	O
max	int
?	O
1	int
:	O
-	O
1	int
]	O
;	O
