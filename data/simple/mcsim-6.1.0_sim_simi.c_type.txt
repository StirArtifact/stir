PSTRLEX	array
vrgszlexArgs	array
[	O
ARGS_MAX	int
]	O
;	O
typedef	O
struct	O
tagKM	struct
{	O
PSTR	pointer
szKeyword	pointer
;	O
int	O
iKWCode	int
;	O
WORD	int
fContext	int
;	O
}	O
KM	struct
,	O
*	O
PKM	pointer
;	O
KM	struct
vrgkmKeywordMap	array
[	O
]	O
=	O
{	O
{	O
"Level"	pointer
,	O
KM_LEVEL	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"Experiment"	pointer
,	O
KM_EXPERIMENT	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"Simulation"	pointer
,	O
KM_EXPERIMENT	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"OutputFile"	pointer
,	O
KM_OUTPUTFILE	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"MCMC"	pointer
,	O
KM_MCMC	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"OptimalDesign"	pointer
,	O
KM_OPTDESIGN	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"MonteCarlo"	pointer
,	O
KM_MONTECARLO	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"Distrib"	pointer
,	O
KM_MCVARY	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"Likelihood"	pointer
,	O
KM_MCVARY	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"Density"	pointer
,	O
KM_MCVARY	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"MCVary"	pointer
,	O
KM_MCVARY	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"InvTemperature"	pointer
,	O
KM_TEMPERATURE	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"Perks"	pointer
,	O
KM_TEMPERATURE	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"SetPoints"	pointer
,	O
KM_SETPOINTS	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"Integrate"	pointer
,	O
KM_INTEGRATE	int
,	O
CN_GLOBAL	int
|	O
CN_EXPERIMENT	int
}	O
,	O
{	O
"Simulate"	pointer
,	O
KM_SIMULATE	int
,	O
CN_GLOBAL	int
|	O
CN_EXPERIMENT	int
}	O
,	O
{	O
"StartTime"	pointer
,	O
KM_STARTTIME	int
,	O
CN_GLOBAL	int
|	O
CN_EXPERIMENT	int
}	O
,	O
{	O
"Print"	pointer
,	O
KM_PRINT	int
,	O
CN_EXPERIMENT	int
}	O
,	O
{	O
"Prediction"	pointer
,	O
KM_PRINT	int
,	O
CN_EXPERIMENT	int
}	O
,	O
{	O
"PrintStep"	pointer
,	O
KM_PRINTSTEP	int
,	O
CN_EXPERIMENT	int
}	O
,	O
{	O
"Data"	pointer
,	O
KM_DATA	int
,	O
CN_EXPERIMENT	int
}	O
,	O
{	O
"SimType"	pointer
,	O
KM_SIMTYPE	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"End"	pointer
,	O
KM_END	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"END"	pointer
,	O
KM_END	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"DefaultSim"	pointer
,	O
KM_DEFAULTSIM	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"No"	pointer
,	O
KM_NO	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"Yes"	pointer
,	O
KM_YES	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"Beta"	pointer
,	O
KM_BETA	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"Binomial"	pointer
,	O
KM_BINOMIAL	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"BinomialBeta"	pointer
,	O
KM_BINOMIALBETA	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"Cauchy"	pointer
,	O
KM_CAUCHY	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"Chi2"	pointer
,	O
KM_CHI2	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"Exponential"	pointer
,	O
KM_EXPONENTIAL	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"Gamma"	pointer
,	O
KM_GGAMMA	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"GenLogNormal"	pointer
,	O
KM_GENLOGNORMAL	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"HalfCauchy"	pointer
,	O
KM_HALFCAUCHY	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"HalfNormal"	pointer
,	O
KM_HALFNORMAL	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"InvGamma"	pointer
,	O
KM_INVGGAMMA	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"LogNormal"	pointer
,	O
KM_LOGNORMAL	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"LogNormal_v"	pointer
,	O
KM_LOGNORMALV	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"LogUniform"	pointer
,	O
KM_LOGUNIFORM	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"Normal"	pointer
,	O
KM_NORMAL	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"Normal_cv"	pointer
,	O
KM_NORMALCV	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"Normal_v"	pointer
,	O
KM_NORMALV	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"Piecewise"	pointer
,	O
KM_PIECEWISE	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"Poisson"	pointer
,	O
KM_POISSON	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"StudentT"	pointer
,	O
KM_STUDENTT	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"TruncInvGamma"	pointer
,	O
KM_TRUNCINVGGAMMA	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"TruncLogNormal"	pointer
,	O
KM_TRUNCLOGNORMAL	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"TruncLogNormal_v"	pointer
,	O
KM_TRUNCLOGNORMALV	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"TruncNormal"	pointer
,	O
KM_TRUNCNORMAL	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"TruncNormal_cv"	pointer
,	O
KM_TRUNCNORMALCV	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"TruncNormal_v"	pointer
,	O
KM_TRUNCNORMALV	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"Uniform"	pointer
,	O
KM_UNIFORM	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"UserSpecifiedLL"	pointer
,	O
KM_USERLL	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"Prediction"	pointer
,	O
KM_PREDICTION	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"Data"	pointer
,	O
KM_DATA	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"Euler"	pointer
,	O
KM_EULER	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"Lsodes"	pointer
,	O
KM_LSODES	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"LSODES"	pointer
,	O
KM_LSODES	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"Cvodes"	pointer
,	O
KM_CVODES	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"CVODES"	pointer
,	O
KM_CVODES	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"Forward"	pointer
,	O
KM_FORWARD	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"Backward"	pointer
,	O
KM_BACKWARD	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"Replace"	pointer
,	O
KM_REPLACE	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"Add"	pointer
,	O
KM_ADD	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
"Multiply"	pointer
,	O
KM_MULTIPLY	int
,	O
CN_FUNCARG	int
}	O
,	O
{	O
""	pointer
,	O
0	int
,	O
CN_ALL	int
}	O
}	O
;	O
int	O
GetKeywordCode	function
(	O
PSTR	pointer
szKeyword	pointer
,	O
PINT	pointer
pfContext	pointer
)	O
{	O
PKM	pointer
pkm	pointer
=	O
&	O
vrgkmKeywordMap	array
[	O
0	int
]	O
;	O
while	O
(	O
*	O
pkm	pointer
->	O
szKeyword	pointer
&&	O
MyStrcmp	function
(	O
szKeyword	pointer
,	O
pkm	pointer
->	O
szKeyword	pointer
)	O
)	O
pkm	pointer
++	O
;	O
if	O
(	O
pfContext	pointer
)	O
*	O
pfContext	pointer
=	O
pkm	pointer
->	O
fContext	int
;	O
return	O
(	O
pkm	pointer
->	O
iKWCode	int
)	O
;	O
}	O
int	O
GetKeywordCode_in_context	function
(	O
PSTR	pointer
szKeyword	pointer
,	O
WORD	int
fContext	int
)	O
{	O
PKM	pointer
pkm	pointer
=	O
&	O
vrgkmKeywordMap	array
[	O
0	int
]	O
;	O
while	O
(	O
*	O
pkm	pointer
->	O
szKeyword	pointer
&&	O
!	O
(	O
(	O
pkm	pointer
->	O
fContext	int
==	O
fContext	int
)	O
&&	O
!	O
MyStrcmp	function
(	O
szKeyword	pointer
,	O
pkm	pointer
->	O
szKeyword	pointer
)	O
)	O
)	O
pkm	pointer
++	O
;	O
return	O
(	O
pkm	pointer
->	O
iKWCode	int
)	O
;	O
}	O
PSTR	pointer
GetKeyword	function
(	O
int	O
iKWCode	int
)	O
{	O
PKM	pointer
pkm	pointer
=	O
&	O
vrgkmKeywordMap	array
[	O
0	int
]	O
;	O
while	O
(	O
*	O
pkm	pointer
->	O
szKeyword	pointer
&&	O
iKWCode	int
!=	O
pkm	pointer
->	O
iKWCode	int
)	O
pkm	pointer
++	O
;	O
return	O
(	O
pkm	pointer
->	O
szKeyword	pointer
)	O
;	O
}	O
BOOL	int
YesNoFromLex	function
(	O
PSTR	pointer
szLex	pointer
)	O
{	O
int	O
ikwcode	int
=	O
GetKeywordCode	function
(	O
szLex	pointer
,	O
NULL	O
)	O
;	O
BOOL	int
bReturn	int
;	O
bReturn	int
=	O
(	O
!	O
isalpha	function
(	O
szLex	pointer
[	O
0	int
]	O
)	O
?	O
atoi	function
(	O
szLex	pointer
)	O
:	O
ikwcode	int
==	O
KM_YES	int
?	O
TRUE	int
:	O
ikwcode	int
==	O
KM_NO	int
?	O
FALSE	int
:	O
FALSE	int
)	O
;	O
return	O
bReturn	int
;	O
}	O
long	O
ImFromLex	function
(	O
PSTR	pointer
szLex	pointer
)	O
{	O
int	O
ikwcode	int
=	O
GetKeywordCode	function
(	O
szLex	pointer
,	O
NULL	O
)	O
;	O
long	O
lReturn	long
;	O
lReturn	long
=	O
(	O
!	O
isalpha	function
(	O
szLex	pointer
[	O
0	int
]	O
)	O
?	O
atoi	function
(	O
szLex	pointer
)	O
:	O
ikwcode	int
==	O
KM_LSODES	int
?	O
IAL_LSODES	int
:	O
ikwcode	int
==	O
KM_CVODES	int
?	O
IAL_CVODES	int
:	O
ikwcode	int
==	O
KM_EULER	int
?	O
IAL_EULER	int
:	O
0	int
)	O
;	O
if	O
(	O
!	O
lReturn	long
)	O
{	O
printf	function
(	O
"Warning: Unknown integrator specification (%s) -\n"	pointer
"         Switching to Lsodes with default options\n\n"	pointer
,	O
szLex	pointer
)	O
;	O
lReturn	long
=	O
IAL_DEFAULT	O
;	O
}	O
if	O
(	O
ikwcode	int
==	O
KM_CVODES	int
)	O
{	O
printf	function
(	O
"Warning: Cvodes libraries are not available -\n"	pointer
"         Switching to Lsodes with default options\n\n"	pointer
)	O
;	O
lReturn	long
=	O
IAL_DEFAULT	O
;	O
}	O
return	O
(	O
lReturn	long
)	O
;	O
}	O
int	O
McvFromLex	function
(	O
PSTR	pointer
szLex	pointer
)	O
{	O
int	O
ikwcode	int
=	O
GetKeywordCode	function
(	O
szLex	pointer
,	O
NULL	O
)	O
;	O
int	O
iReturn	int
;	O
iReturn	int
=	O
(	O
ikwcode	int
==	O
KM_UNIFORM	int
?	O
MCV_UNIFORM	int
:	O
ikwcode	int
==	O
KM_LOGUNIFORM	int
?	O
MCV_LOGUNIFORM	int
:	O
ikwcode	int
==	O
KM_BETA	int
?	O
MCV_BETA	int
:	O
ikwcode	int
==	O
KM_NORMAL	int
?	O
MCV_NORMAL	int
:	O
ikwcode	int
==	O
KM_HALFNORMAL	int
?	O
MCV_HALFNORMAL	int
:	O
ikwcode	int
==	O
KM_LOGNORMAL	int
?	O
MCV_LOGNORMAL	int
:	O
ikwcode	int
==	O
KM_TRUNCNORMAL	int
?	O
MCV_TRUNCNORMAL	int
:	O
ikwcode	int
==	O
KM_TRUNCLOGNORMAL	int
?	O
MCV_TRUNCLOGNORMAL	int
:	O
ikwcode	int
==	O
KM_CHI2	int
?	O
MCV_CHI2	int
:	O
ikwcode	int
==	O
KM_BINOMIAL	int
?	O
MCV_BINOMIAL	int
:	O
ikwcode	int
==	O
KM_PIECEWISE	int
?	O
MCV_PIECEWISE	int
:	O
ikwcode	int
==	O
KM_EXPONENTIAL	int
?	O
MCV_EXPONENTIAL	int
:	O
ikwcode	int
==	O
KM_GGAMMA	int
?	O
MCV_GGAMMA	int
:	O
ikwcode	int
==	O
KM_POISSON	int
?	O
MCV_POISSON	int
:	O
ikwcode	int
==	O
KM_INVGGAMMA	int
?	O
MCV_INVGGAMMA	int
:	O
ikwcode	int
==	O
KM_TRUNCINVGGAMMA	int
?	O
MCV_TRUNCINVGGAMMA	int
:	O
ikwcode	int
==	O
KM_NORMALV	int
?	O
MCV_NORMALV	int
:	O
ikwcode	int
==	O
KM_NORMALCV	int
?	O
MCV_NORMALCV	int
:	O
ikwcode	int
==	O
KM_LOGNORMALV	int
?	O
MCV_LOGNORMALV	int
:	O
ikwcode	int
==	O
KM_TRUNCNORMALV	int
?	O
MCV_TRUNCNORMALV	int
:	O
ikwcode	int
==	O
KM_TRUNCNORMALCV	int
?	O
MCV_TRUNCNORMALCV	int
:	O
ikwcode	int
==	O
KM_TRUNCLOGNORMALV	int
?	O
MCV_TRUNCLOGNORMALV	int
:	O
ikwcode	int
==	O
KM_BINOMIALBETA	int
?	O
MCV_BINOMIALBETA	int
:	O
ikwcode	int
==	O
KM_GENLOGNORMAL	int
?	O
MCV_GENLOGNORMAL	int
:	O
ikwcode	int
==	O
KM_STUDENTT	int
?	O
MCV_STUDENTT	int
:	O
ikwcode	int
==	O
KM_CAUCHY	int
?	O
MCV_CAUCHY	int
:	O
ikwcode	int
==	O
KM_HALFCAUCHY	int
?	O
MCV_HALFCAUCHY	int
:	O
ikwcode	int
==	O
KM_USERLL	int
?	O
MCV_USERLL	int
:	O
(	O
-	O
1	int
)	O
)	O
;	O
return	O
iReturn	int
;	O
}	O
int	O
GetTerminator	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PSTR	pointer
szLex	pointer
)	O
{	O
int	O
iErr	int
;	O
if	O
(	O
(	O
iErr	int
=	O
!	O
GetPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
CH_STMTTERM	O
)	O
)	O
)	O
{	O
szLex	pointer
[	O
1	int
]	O
=	O
CH_STMTTERM	O
;	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_EXPECTED	int
,	O
szLex	pointer
,	O
NULL	O
)	O
;	O
}	O
return	O
(	O
iErr	int
)	O
;	O
}	O
BOOL	int
GetSimType	function
(	O
PINPUTBUF	pointer
pibIn	pointer
)	O
{	O
static	O
int	O
vrgiAtArgTypes	array
[	O
NAT_ARGS	int
]	O
=	O
{	O
LX_IDENTIFIER	int
}	O
;	O
PANALYSIS	pointer
panal	pointer
=	O
(	O
PANALYSIS	pointer
)	O
pibIn	pointer
->	O
pInfo	pointer
;	O
int	O
iAT	int
=	O
AT_DEFAULTSIM	int
;	O
int	O
iKwCode	int
=	O
0	int
;	O
BOOL	int
bErr	int
=	O
!	O
GetFuncArgs	function
(	O
pibIn	pointer
,	O
NAT_ARGS	int
,	O
vrgiAtArgTypes	array
,	O
vrgszlexArgs	array
[	O
0	int
]	O
)	O
;	O
if	O
(	O
!	O
bErr	int
)	O
{	O
iKwCode	int
=	O
GetKeywordCode	function
(	O
vrgszlexArgs	array
[	O
0	int
]	O
,	O
NULL	O
)	O
;	O
switch	O
(	O
iKwCode	int
)	O
{	O
case	O
KM_MONTECARLO	int
:	O
iAT	int
=	O
AT_MONTECARLO	int
;	O
break	O
;	O
case	O
KM_SETPOINTS	int
:	O
iAT	int
=	O
AT_SETPOINTS	int
;	O
break	O
;	O
case	O
KM_MCMC	int
:	O
iAT	int
=	O
AT_MCMC	int
;	O
break	O
;	O
case	O
KM_OPTDESIGN	int
:	O
iAT	int
=	O
AT_OPTDESIGN	int
;	O
break	O
;	O
case	O
KM_DEFAULTSIM	int
:	O
iAT	int
=	O
AT_DEFAULTSIM	int
;	O
break	O
;	O
default	O
:	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_SPECERR	int
|	O
RE_FATAL	int
,	O
"Unknown SimType "	pointer
,	O
vrgszlexArgs	array
[	O
0	int
]	O
)	O
;	O
break	O
;	O
}	O
}	O
else	O
printf	function
(	O
"Syntax: %s (Normal | MonteCarlo | SetPoints | MCMC)\n"	pointer
"  -- if not specified, the first spec section will be used.\n\n"	pointer
,	O
GetKeyword	function
(	O
KM_SIMTYPE	int
)	O
)	O
;	O
if	O
(	O
!	O
bErr	int
)	O
panal	pointer
->	O
iType	int
=	O
iAT	int
;	O
return	O
(	O
bErr	int
)	O
;	O
}	O
BOOL	int
GetPerks	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PSTR	pointer
szLex	pointer
,	O
PGIBBSDATA	pointer
pgd	pointer
)	O
{	O
int	O
iType	int
;	O
int	O
i	int
;	O
BOOL	int
bOK	int
=	O
TRUE	int
;	O
BOOL	int
bErr	int
=	O
FALSE	int
;	O
if	O
(	O
(	O
bErr	int
=	O
EGetPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
CH_LPAREN	O
)	O
)	O
)	O
goto	O
Exit_GetPerks	O
;	O
if	O
(	O
(	O
bErr	int
=	O
ENextLex	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
LX_INTEGER	int
)	O
)	O
)	O
goto	O
Exit_GetPerks	O
;	O
pgd	pointer
->	O
nPerks	int
=	O
atoi	function
(	O
szLex	pointer
)	O
;	O
if	O
(	O
(	O
bErr	int
=	O
(	O
pgd	pointer
->	O
nPerks	int
<=	O
0	int
)	O
)	O
)	O
{	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
|	O
RE_FATAL	int
,	O
"positive-integer"	pointer
,	O
szLex	pointer
)	O
;	O
goto	O
Exit_GetPerks	O
;	O
}	O
pgd	pointer
->	O
endT	int
=	O
pgd	pointer
->	O
nPerks	int
-	O
1	int
;	O
if	O
(	O
!	O
(	O
pgd	pointer
->	O
rgdPerks	pointer
=	O
InitdVector	function
(	O
pgd	pointer
->	O
nPerks	int
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetPerks"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
(	O
pgd	pointer
->	O
rgdlnPi	pointer
=	O
InitdVector	function
(	O
pgd	pointer
->	O
nPerks	int
)	O
)	O
||	O
!	O
(	O
pgd	pointer
->	O
rglCount	pointer
=	O
InitlVector	function
(	O
pgd	pointer
->	O
nPerks	int
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetPerks"	pointer
,	O
NULL	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
pgd	pointer
->	O
nPerks	int
&&	O
bOK	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
!	O
(	O
bOK	int
=	O
GetOptPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
','	O
)	O
)	O
)	O
{	O
szLex	pointer
[	O
0	int
]	O
=	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
;	O
szLex	pointer
[	O
1	int
]	O
=	O
'\0'	O
;	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
|	O
RE_FATAL	int
,	O
","	pointer
,	O
szLex	pointer
)	O
;	O
}	O
NextLex	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
&	O
iType	int
)	O
;	O
if	O
(	O
!	O
(	O
bOK	int
&=	O
(	O
iType	int
&	O
LX_NUMBER	O
)	O
>	O
0	int
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
|	O
RE_FATAL	int
,	O
"number"	pointer
,	O
szLex	pointer
)	O
;	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
i	int
]	O
=	O
atof	function
(	O
szLex	pointer
)	O
;	O
pgd	pointer
->	O
rgdlnPi	pointer
[	O
i	int
]	O
=	O
0	int
;	O
pgd	pointer
->	O
rglCount	pointer
[	O
i	int
]	O
=	O
0	int
;	O
if	O
(	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
i	int
]	O
<	O
0	int
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
|	O
RE_FATAL	int
,	O
"positive inverse temperature"	pointer
,	O
szLex	pointer
)	O
;	O
if	O
(	O
(	O
i	int
>	O
0	int
)	O
&&	O
(	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
i	int
]	O
<=	O
pgd	pointer
->	O
rgdPerks	pointer
[	O
i	int
-	O
1	int
]	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_SPECERR	int
|	O
RE_FATAL	int
,	O
"Inverse temperatures out of order"	pointer
,	O
NULL	O
)	O
;	O
}	O
bErr	int
=	O
EGetPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
CH_RPAREN	O
)	O
;	O
Exit_GetPerks	O
:	O
if	O
(	O
bErr	int
)	O
printf	function
(	O
"Syntax: Inverse temperatures (nPerks, "	pointer
"<n increasing inverse temperature values >= 0>)\n\n"	pointer
)	O
;	O
return	O
(	O
!	O
bErr	int
)	O
;	O
}	O
BOOL	int
GetIntegrate	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PINTSPEC	pointer
pis	pointer
)	O
{	O
static	O
int	O
vrgiIntArgTypes	array
[	O
NINT_ARGS	int
]	O
=	O
{	O
LX_IDENTIFIER	int
,	O
LX_NUMBER	O
,	O
LX_NUMBER	O
,	O
LX_INTEGER	int
}	O
;	O
BOOL	int
bErr	int
=	O
!	O
GetFuncArgs	function
(	O
pibIn	pointer
,	O
NINT_ARGS	int
,	O
vrgiIntArgTypes	array
,	O
vrgszlexArgs	array
[	O
0	int
]	O
)	O
;	O
if	O
(	O
!	O
bErr	int
)	O
{	O
pis	pointer
->	O
iAlgo	int
=	O
ImFromLex	function
(	O
vrgszlexArgs	array
[	O
0	int
]	O
)	O
;	O
if	O
(	O
pis	pointer
->	O
iAlgo	int
==	O
IAL_LSODES	int
)	O
{	O
pis	pointer
->	O
dRtol	double
=	O
atof	function
(	O
vrgszlexArgs	array
[	O
1	int
]	O
)	O
;	O
pis	pointer
->	O
dAtol	double
=	O
atof	function
(	O
vrgszlexArgs	array
[	O
2	int
]	O
)	O
;	O
pis	pointer
->	O
iMf	long
=	O
atoi	function
(	O
vrgszlexArgs	array
[	O
3	int
]	O
)	O
;	O
switch	O
(	O
pis	pointer
->	O
iMf	long
)	O
{	O
case	O
0	int
:	O
pis	pointer
->	O
iMf	long
=	O
10	int
;	O
break	O
;	O
case	O
1	int
:	O
pis	pointer
->	O
iMf	long
=	O
222	int
;	O
break	O
;	O
case	O
2	int
:	O
pis	pointer
->	O
iMf	long
=	O
121	int
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
"Error: method flag must be 0, 1 or 2 for Lsodes - "	pointer
)	O
;	O
printf	function
(	O
"Exiting\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
break	O
;	O
}	O
pis	pointer
->	O
iDSFlag	long
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
pis	pointer
->	O
iAlgo	int
==	O
IAL_CVODES	int
)	O
{	O
pis	pointer
->	O
dRtol	double
=	O
atof	function
(	O
vrgszlexArgs	array
[	O
1	int
]	O
)	O
;	O
pis	pointer
->	O
dAtol	double
=	O
atof	function
(	O
vrgszlexArgs	array
[	O
2	int
]	O
)	O
;	O
pis	pointer
->	O
iMf	long
=	O
atoi	function
(	O
vrgszlexArgs	array
[	O
3	int
]	O
)	O
;	O
if	O
(	O
pis	pointer
->	O
iMf	long
==	O
0	int
)	O
printf	function
(	O
"Using CVODES serial\n\n"	pointer
)	O
;	O
else	O
{	O
printf	function
(	O
"Warning: last flag for Cvodes is currently ignored.\n\n"	pointer
)	O
;	O
pis	pointer
->	O
iMf	long
=	O
0	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
pis	pointer
->	O
iAlgo	int
==	O
IAL_EULER	int
)	O
{	O
pis	pointer
->	O
dTStep	double
=	O
atof	function
(	O
vrgszlexArgs	array
[	O
1	int
]	O
)	O
;	O
if	O
(	O
pis	pointer
->	O
dTStep	double
<=	O
0	int
)	O
printf	function
(	O
"Warning: Time step specified is null or negative -\n"	pointer
"         Resetting to 1\n\n"	pointer
)	O
;	O
}	O
else	O
{	O
printf	function
(	O
"Error: Unknown integration method: %s - Exiting\n\n"	pointer
,	O
vrgszlexArgs	array
[	O
0	int
]	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
}	O
}	O
}	O
else	O
{	O
printf	function
(	O
"Syntax: %s (Lsodes, Relative tolerance, Absolute tolerance, "	pointer
"Method)\n"	pointer
"        or %s (CVODES, Relative tolerance, Absolute tolerance, "	pointer
"0)\n"	pointer
"        or %s (Euler, Time step, 0, 0)\n\n"	pointer
,	O
GetKeyword	function
(	O
KM_INTEGRATE	int
)	O
,	O
GetKeyword	function
(	O
KM_INTEGRATE	int
)	O
,	O
GetKeyword	function
(	O
KM_INTEGRATE	int
)	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
return	O
(	O
bErr	int
)	O
;	O
}	O
int	O
OneDToArray	function
(	O
PVOID	pointer
pData	pointer
,	O
PVOID	pointer
pInfo	pointer
)	O
{	O
PDOUBLE	pointer
*	O
ppdArrayVal	pointer
=	O
(	O
PDOUBLE	pointer
*	O
)	O
pInfo	pointer
;	O
*	O
(	O
*	O
ppdArrayVal	pointer
)	O
++	O
=	O
*	O
(	O
PDOUBLE	pointer
)	O
pData	pointer
;	O
return	O
0	int
;	O
}	O
void	O
DListToArray	function
(	O
PLIST	pointer
plist	pointer
,	O
PLONG	pointer
pcDouble	pointer
,	O
PDOUBLE	pointer
*	O
ppDouble	pointer
)	O
{	O
PDOUBLE	pointer
pdTmp	pointer
;	O
*	O
pcDouble	pointer
=	O
ListLength	O
(	O
plist	pointer
)	O
;	O
if	O
(	O
!	O
(	O
pdTmp	pointer
=	O
*	O
ppDouble	pointer
=	O
InitdVector	function
(	O
*	O
pcDouble	pointer
)	O
)	O
)	O
ReportError	function
(	O
NULL	O
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"DListToArray"	pointer
,	O
NULL	O
)	O
;	O
ForAllList	function
(	O
plist	pointer
,	O
&	O
OneDToArray	function
,	O
(	O
PVOID	pointer
)	O
&	O
pdTmp	pointer
)	O
;	O
}	O
BOOL	int
GetListOfTimes	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
int	O
nRecs	int
,	O
PPRINTREC	pointer
*	O
ppr	pointer
,	O
PSTR	pointer
szLex	pointer
)	O
{	O
PLIST	pointer
plistTimes	pointer
=	O
InitList	function
(	O
)	O
;	O
PDOUBLE	pointer
pdTmp	pointer
;	O
int	O
iNLI	int
,	O
i	int
,	O
j	int
;	O
BOOL	int
bErr	int
;	O
do	O
{	O
if	O
(	O
!	O
(	O
pdTmp	pointer
=	O
InitdVector	function
(	O
1	int
)	O
)	O
)	O
ReportError	function
(	O
NULL	O
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetListOfTimes"	pointer
,	O
NULL	O
)	O
;	O
*	O
pdTmp	pointer
=	O
atof	function
(	O
szLex	pointer
)	O
;	O
QueueListItem	function
(	O
plistTimes	pointer
,	O
(	O
PVOID	pointer
)	O
pdTmp	pointer
)	O
;	O
}	O
while	O
(	O
(	O
iNLI	int
=	O
NextListItem	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
LX_NUMBER	O
,	O
1	int
,	O
CH_RPAREN	O
)	O
)	O
>	O
0	int
)	O
;	O
if	O
(	O
!	O
iNLI	int
)	O
bErr	int
=	O
EGetPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
CH_RPAREN	O
)	O
||	O
!	O
ListLength	O
(	O
plistTimes	pointer
)	O
;	O
else	O
{	O
bErr	int
=	O
TRUE	int
;	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
,	O
"number"	pointer
,	O
szLex	pointer
)	O
;	O
}	O
if	O
(	O
!	O
bErr	int
)	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nRecs	int
;	O
++	O
i	int
)	O
DListToArray	function
(	O
plistTimes	pointer
,	O
&	O
ppr	pointer
[	O
i	int
]	O
->	O
cTimes	long
,	O
&	O
ppr	pointer
[	O
i	int
]	O
->	O
pdTimes	pointer
)	O
;	O
FreeList	function
(	O
&	O
plistTimes	pointer
,	O
NULL	O
,	O
TRUE	int
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
ppr	pointer
[	O
0	int
]	O
->	O
cTimes	long
&&	O
!	O
bErr	int
;	O
i	int
++	O
)	O
if	O
(	O
(	O
bErr	int
=	O
(	O
*	O
(	O
ppr	pointer
[	O
0	int
]	O
->	O
pdTimes	pointer
+	O
i	int
)	O
<=	O
*	O
(	O
ppr	pointer
[	O
0	int
]	O
->	O
pdTimes	pointer
+	O
i	int
-	O
1	int
)	O
)	O
)	O
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
nRecs	int
;	O
++	O
j	int
)	O
free	function
(	O
ppr	pointer
[	O
j	int
]	O
->	O
pdTimes	pointer
)	O
;	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_SPECERR	int
|	O
RE_FATAL	int
,	O
"Times out of order"	pointer
,	O
NULL	O
)	O
;	O
}	O
return	O
(	O
bErr	int
)	O
;	O
}	O
BOOL	int
GetListOfData	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PDATAREC	pointer
pda	pointer
,	O
PSTR	pointer
szLex	pointer
)	O
{	O
PLIST	pointer
plistData	pointer
=	O
InitList	function
(	O
)	O
;	O
PDOUBLE	pointer
pdTmp	pointer
;	O
int	O
iNLI	int
;	O
BOOL	int
bErr	int
;	O
while	O
(	O
(	O
iNLI	int
=	O
NextListItem	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
LX_NUMBER	O
,	O
1	int
,	O
CH_RPAREN	O
)	O
)	O
>	O
0	int
)	O
{	O
if	O
(	O
!	O
(	O
pdTmp	pointer
=	O
InitdVector	function
(	O
1	int
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetListOfData"	pointer
,	O
NULL	O
)	O
;	O
*	O
pdTmp	pointer
=	O
atof	function
(	O
szLex	pointer
)	O
;	O
QueueListItem	function
(	O
plistData	pointer
,	O
(	O
PVOID	pointer
)	O
pdTmp	pointer
)	O
;	O
}	O
if	O
(	O
!	O
iNLI	int
)	O
bErr	int
=	O
EGetPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
CH_RPAREN	O
)	O
||	O
!	O
ListLength	O
(	O
plistData	pointer
)	O
;	O
else	O
{	O
bErr	int
=	O
TRUE	int
;	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
,	O
"number"	pointer
,	O
szLex	pointer
)	O
;	O
}	O
if	O
(	O
!	O
bErr	int
)	O
DListToArray	function
(	O
plistData	pointer
,	O
&	O
pda	pointer
->	O
cData	long
,	O
&	O
pda	pointer
->	O
pdData	pointer
)	O
;	O
FreeList	function
(	O
&	O
plistData	pointer
,	O
NULL	O
,	O
TRUE	int
)	O
;	O
return	O
(	O
bErr	int
)	O
;	O
}	O
BOOL	int
bGavePrintUsage	int
=	O
FALSE	int
;	O
BOOL	int
GetPrint	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PSTR	pointer
szLex	pointer
,	O
POUTSPEC	pointer
pos	pointer
)	O
{	O
PPRINTREC	pointer
pprintrec	array
[	O
MAX_PRINT_VARS	int
]	O
;	O
BOOL	int
bErr	int
=	O
FALSE	int
;	O
HVAR	long
hvar	long
;	O
int	O
nVars	int
=	O
0	int
,	O
n	int
,	O
iLex	int
;	O
long	O
i	int
,	O
iLB	long
,	O
iUB	long
;	O
PSTRLEX	array
szTmp	array
;	O
if	O
(	O
!	O
(	O
bErr	int
=	O
EGetPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
CH_LPAREN	O
)	O
)	O
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
NextLex	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
&	O
iLex	int
)	O
;	O
if	O
(	O
iLex	int
!=	O
LX_IDENTIFIER	int
)	O
break	O
;	O
iLB	long
=	O
iUB	long
=	O
-	O
1	int
;	O
if	O
(	O
GetPunct	function
(	O
pibIn	pointer
,	O
szTmp	array
,	O
'['	O
)	O
)	O
GetArrayBounds	function
(	O
pibIn	pointer
,	O
&	O
iLB	long
,	O
&	O
iUB	long
)	O
;	O
if	O
(	O
iUB	long
==	O
-	O
1	int
)	O
{	O
if	O
(	O
nVars	int
==	O
MAX_PRINT_VARS	int
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_TOOMANYPVARS	int
|	O
RE_FATAL	int
,	O
"GetPrint"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
(	O
bErr	int
=	O
!	O
(	O
hvar	long
=	O
GetVarHandle	function
(	O
szLex	pointer
)	O
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_UNDEFINED	int
|	O
RE_FATAL	int
,	O
szLex	pointer
,	O
NULL	O
)	O
;	O
else	O
{	O
if	O
(	O
!	O
(	O
pprintrec	array
[	O
nVars	int
]	O
=	O
(	O
PPRINTREC	pointer
)	O
malloc	function
(	O
sizeof	O
(	O
PRINTREC	struct
)	O
)	O
)	O
||	O
!	O
(	O
pprintrec	array
[	O
nVars	int
]	O
->	O
szOutputName	pointer
=	O
(	O
PSTR	pointer
)	O
malloc	function
(	O
MyStrlen	O
(	O
szLex	pointer
)	O
+	O
1	int
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetPrint"	pointer
,	O
NULL	O
)	O
;	O
MyStrcpy	O
(	O
pprintrec	array
[	O
nVars	int
]	O
->	O
szOutputName	pointer
,	O
szLex	pointer
)	O
;	O
pprintrec	array
[	O
nVars	int
]	O
->	O
hvar	long
=	O
hvar	long
;	O
assert	O
(	O
pprintrec	array
[	O
nVars	int
]	O
)	O
;	O
++	O
nVars	int
;	O
}	O
GetOptPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
','	O
)	O
;	O
}	O
else	O
{	O
for	O
(	O
i	int
=	O
iLB	long
;	O
i	int
<	O
iUB	long
;	O
i	int
++	O
)	O
{	O
sprintf	function
(	O
szTmp	array
,	O
"%s_%ld"	pointer
,	O
szLex	pointer
,	O
i	int
)	O
;	O
if	O
(	O
nVars	int
==	O
MAX_PRINT_VARS	int
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_TOOMANYPVARS	int
|	O
RE_FATAL	int
,	O
"GetPrint"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
(	O
bErr	int
=	O
!	O
(	O
hvar	long
=	O
GetVarHandle	function
(	O
szTmp	array
)	O
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_UNDEFINED	int
|	O
RE_FATAL	int
,	O
szTmp	array
,	O
NULL	O
)	O
;	O
else	O
{	O
if	O
(	O
!	O
(	O
pprintrec	array
[	O
nVars	int
]	O
=	O
(	O
PPRINTREC	pointer
)	O
malloc	function
(	O
sizeof	O
(	O
PRINTREC	struct
)	O
)	O
)	O
||	O
!	O
(	O
pprintrec	array
[	O
nVars	int
]	O
->	O
szOutputName	pointer
=	O
(	O
PSTR	pointer
)	O
malloc	function
(	O
strlen	function
(	O
szTmp	array
)	O
+	O
1	int
)	O
)	O
)	O
{	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetPrint"	pointer
,	O
NULL	O
)	O
;	O
}	O
strcpy	function
(	O
pprintrec	array
[	O
nVars	int
]	O
->	O
szOutputName	pointer
,	O
szTmp	array
)	O
;	O
pprintrec	array
[	O
nVars	int
]	O
->	O
hvar	long
=	O
hvar	long
;	O
assert	O
(	O
pprintrec	array
[	O
nVars	int
]	O
)	O
;	O
++	O
nVars	int
;	O
}	O
if	O
(	O
i	int
==	O
(	O
iUB	long
-	O
1	int
)	O
)	O
GetOptPunct	function
(	O
pibIn	pointer
,	O
szTmp	array
,	O
','	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
nVars	int
<	O
1	int
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
,	O
"identifier"	pointer
,	O
szLex	pointer
)	O
;	O
bErr	int
=	O
GetListOfTimes	function
(	O
pibIn	pointer
,	O
nVars	int
,	O
pprintrec	array
,	O
szLex	pointer
)	O
;	O
if	O
(	O
bErr	int
)	O
{	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
nVars	int
;	O
++	O
n	int
)	O
{	O
free	function
(	O
pprintrec	array
[	O
n	int
]	O
->	O
szOutputName	pointer
)	O
;	O
free	function
(	O
pprintrec	array
[	O
n	int
]	O
)	O
;	O
}	O
}	O
else	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
nVars	int
;	O
++	O
n	int
)	O
QueueListItem	function
(	O
pos	pointer
->	O
plistPrintRecs	pointer
,	O
(	O
PVOID	pointer
)	O
pprintrec	array
[	O
n	int
]	O
)	O
;	O
}	O
if	O
(	O
!	O
bErr	int
)	O
bErr	int
=	O
GetTerminator	function
(	O
pibIn	pointer
,	O
szLex	pointer
)	O
;	O
else	O
{	O
if	O
(	O
!	O
bGavePrintUsage	int
)	O
{	O
printf	function
(	O
"Syntax: %s (<Identifiers>, Time1, Time2, ...)\n\n"	pointer
,	O
GetKeyword	function
(	O
KM_PRINT	int
)	O
)	O
;	O
bGavePrintUsage	int
=	O
TRUE	int
;	O
}	O
}	O
return	O
(	O
bErr	int
)	O
;	O
}	O
BOOL	int
bGavePrintStepUsage	int
=	O
FALSE	int
;	O
BOOL	int
GetPrintStep	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PSTR	pointer
szLex	pointer
,	O
POUTSPEC	pointer
pos	pointer
)	O
{	O
PPRINTREC	pointer
pprintrec	array
[	O
MAX_PRINT_VARS	int
]	O
;	O
BOOL	int
bErr	int
=	O
FALSE	int
,	O
bOK	int
=	O
TRUE	int
;	O
HVAR	long
hvar	long
=	O
0	int
;	O
int	O
nVars	int
=	O
0	int
,	O
n	int
,	O
iLex	int
;	O
long	O
i	int
,	O
iLB	long
,	O
iUB	long
;	O
double	O
dStart	double
=	O
0	int
,	O
dEnd	double
=	O
0	int
,	O
dStep	double
=	O
0	int
,	O
dTmp	double
;	O
PSTRLEX	array
szTmp	array
;	O
bErr	int
=	O
EGetPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
CH_LPAREN	O
)	O
;	O
if	O
(	O
bErr	int
)	O
goto	O
Exit_GetPrintStep	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
NextLex	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
&	O
iLex	int
)	O
;	O
if	O
(	O
iLex	int
!=	O
LX_IDENTIFIER	int
)	O
break	O
;	O
iLB	long
=	O
iUB	long
=	O
-	O
1	int
;	O
if	O
(	O
GetPunct	function
(	O
pibIn	pointer
,	O
szTmp	array
,	O
'['	O
)	O
)	O
GetArrayBounds	function
(	O
pibIn	pointer
,	O
&	O
iLB	long
,	O
&	O
iUB	long
)	O
;	O
if	O
(	O
iUB	long
==	O
-	O
1	int
)	O
{	O
if	O
(	O
nVars	int
==	O
MAX_PRINT_VARS	int
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_TOOMANYPVARS	int
|	O
RE_FATAL	int
,	O
"GetPrint"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
(	O
bErr	int
=	O
!	O
(	O
hvar	long
=	O
GetVarHandle	function
(	O
szLex	pointer
)	O
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_UNDEFINED	int
|	O
RE_FATAL	int
,	O
szLex	pointer
,	O
NULL	O
)	O
;	O
else	O
{	O
if	O
(	O
!	O
(	O
pprintrec	array
[	O
nVars	int
]	O
=	O
(	O
PPRINTREC	pointer
)	O
malloc	function
(	O
sizeof	O
(	O
PRINTREC	struct
)	O
)	O
)	O
||	O
!	O
(	O
pprintrec	array
[	O
nVars	int
]	O
->	O
szOutputName	pointer
=	O
(	O
PSTR	pointer
)	O
malloc	function
(	O
MyStrlen	O
(	O
szLex	pointer
)	O
+	O
1	int
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetPrint"	pointer
,	O
NULL	O
)	O
;	O
MyStrcpy	O
(	O
pprintrec	array
[	O
nVars	int
]	O
->	O
szOutputName	pointer
,	O
szLex	pointer
)	O
;	O
pprintrec	array
[	O
nVars	int
]	O
->	O
hvar	long
=	O
hvar	long
;	O
assert	O
(	O
pprintrec	array
[	O
nVars	int
]	O
)	O
;	O
++	O
nVars	int
;	O
}	O
GetOptPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
','	O
)	O
;	O
}	O
else	O
{	O
for	O
(	O
i	int
=	O
iLB	long
;	O
i	int
<	O
iUB	long
;	O
i	int
++	O
)	O
{	O
sprintf	function
(	O
szTmp	array
,	O
"%s_%ld"	pointer
,	O
szLex	pointer
,	O
i	int
)	O
;	O
if	O
(	O
nVars	int
==	O
MAX_PRINT_VARS	int
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_TOOMANYPVARS	int
|	O
RE_FATAL	int
,	O
"GetPrint"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
(	O
bErr	int
=	O
!	O
(	O
hvar	long
=	O
GetVarHandle	function
(	O
szTmp	array
)	O
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_UNDEFINED	int
|	O
RE_FATAL	int
,	O
szTmp	array
,	O
NULL	O
)	O
;	O
else	O
{	O
if	O
(	O
!	O
(	O
pprintrec	array
[	O
nVars	int
]	O
=	O
(	O
PPRINTREC	pointer
)	O
malloc	function
(	O
sizeof	O
(	O
PRINTREC	struct
)	O
)	O
)	O
||	O
!	O
(	O
pprintrec	array
[	O
nVars	int
]	O
->	O
szOutputName	pointer
=	O
(	O
PSTR	pointer
)	O
malloc	function
(	O
strlen	function
(	O
szTmp	array
)	O
+	O
1	int
)	O
)	O
)	O
{	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetPrint"	pointer
,	O
NULL	O
)	O
;	O
}	O
strcpy	function
(	O
pprintrec	array
[	O
nVars	int
]	O
->	O
szOutputName	pointer
,	O
szTmp	array
)	O
;	O
pprintrec	array
[	O
nVars	int
]	O
->	O
hvar	long
=	O
hvar	long
;	O
assert	O
(	O
pprintrec	array
[	O
nVars	int
]	O
)	O
;	O
++	O
nVars	int
;	O
}	O
if	O
(	O
i	int
==	O
(	O
iUB	long
-	O
1	int
)	O
)	O
GetOptPunct	function
(	O
pibIn	pointer
,	O
szTmp	array
,	O
','	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
nVars	int
<	O
1	int
)	O
{	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
,	O
"identifier"	pointer
,	O
szLex	pointer
)	O
;	O
bErr	int
=	O
TRUE	int
;	O
goto	O
Exit_GetPrintStep	O
;	O
}	O
dStart	double
=	O
atof	function
(	O
szLex	pointer
)	O
;	O
if	O
(	O
!	O
(	O
bOK	int
=	O
GetPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
','	O
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
|	O
RE_FATAL	int
,	O
","	pointer
,	O
szLex	pointer
)	O
;	O
if	O
(	O
(	O
bErr	int
=	O
ENextLex	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
LX_NUMBER	O
)	O
)	O
)	O
goto	O
Exit_GetPrintStep	O
;	O
dEnd	double
=	O
atof	function
(	O
szLex	pointer
)	O
;	O
if	O
(	O
!	O
(	O
bOK	int
=	O
GetPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
','	O
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
|	O
RE_FATAL	int
,	O
","	pointer
,	O
szLex	pointer
)	O
;	O
if	O
(	O
(	O
bErr	int
=	O
ENextLex	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
LX_NUMBER	O
)	O
)	O
)	O
goto	O
Exit_GetPrintStep	O
;	O
dStep	double
=	O
atof	function
(	O
szLex	pointer
)	O
;	O
if	O
(	O
!	O
(	O
bOK	int
=	O
GetPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
CH_RPAREN	O
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
|	O
RE_FATAL	int
,	O
")"	pointer
,	O
szLex	pointer
)	O
;	O
if	O
(	O
(	O
bErr	int
=	O
(	O
dEnd	double
<=	O
dStart	double
)	O
)	O
)	O
{	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_SPECERR	int
,	O
"End_time must be > Start_time"	pointer
,	O
NULL	O
)	O
;	O
goto	O
Exit_GetPrintStep	O
;	O
}	O
else	O
if	O
(	O
(	O
bErr	int
=	O
(	O
dStep	double
>	O
(	O
dEnd	double
-	O
dStart	double
)	O
)	O
)	O
)	O
{	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_SPECERR	int
,	O
"Time_step too large"	pointer
,	O
NULL	O
)	O
;	O
goto	O
Exit_GetPrintStep	O
;	O
}	O
dTmp	double
=	O
1	int
+	O
ceil	function
(	O
(	O
dEnd	double
-	O
dStart	double
)	O
/	O
dStep	double
)	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
nVars	int
;	O
++	O
n	int
)	O
{	O
if	O
(	O
dTmp	double
<	O
LONG_MAX	O
)	O
pprintrec	array
[	O
n	int
]	O
->	O
cTimes	long
=	O
(	O
long	O
)	O
dTmp	double
;	O
else	O
pprintrec	array
[	O
n	int
]	O
->	O
cTimes	long
=	O
LONG_MAX	O
;	O
}	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
nVars	int
;	O
++	O
n	int
)	O
{	O
if	O
(	O
!	O
(	O
pprintrec	array
[	O
n	int
]	O
->	O
pdTimes	pointer
=	O
InitdVector	function
(	O
pprintrec	array
[	O
n	int
]	O
->	O
cTimes	long
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetPrintStep"	pointer
,	O
NULL	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
pprintrec	array
[	O
n	int
]	O
->	O
cTimes	long
-	O
1	int
;	O
i	int
++	O
)	O
pprintrec	array
[	O
n	int
]	O
->	O
pdTimes	pointer
[	O
i	int
]	O
=	O
dStart	double
+	O
(	O
i	int
*	O
dStep	double
)	O
;	O
pprintrec	array
[	O
n	int
]	O
->	O
pdTimes	pointer
[	O
pprintrec	array
[	O
n	int
]	O
->	O
cTimes	long
-	O
1	int
]	O
=	O
dEnd	double
;	O
QueueListItem	function
(	O
pos	pointer
->	O
plistPrintRecs	pointer
,	O
(	O
PVOID	pointer
)	O
pprintrec	array
[	O
n	int
]	O
)	O
;	O
}	O
Exit_GetPrintStep	O
:	O
if	O
(	O
bErr	int
)	O
if	O
(	O
!	O
bGavePrintStepUsage	int
)	O
{	O
printf	function
(	O
"Syntax: %s (<Identifiers>, Start_time, End_time, Time_step)\n\n"	pointer
,	O
GetKeyword	function
(	O
KM_PRINTSTEP	int
)	O
)	O
;	O
bGavePrintStepUsage	int
=	O
TRUE	int
;	O
}	O
return	O
(	O
bErr	int
)	O
;	O
}	O
BOOL	int
bGaveDataUsage	int
=	O
FALSE	int
;	O
BOOL	int
GetData	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PSTR	pointer
szLex	pointer
,	O
POUTSPEC	pointer
pos	pointer
)	O
{	O
PDATAREC	pointer
pdatarec	pointer
;	O
BOOL	int
bErr	int
=	O
FALSE	int
;	O
HVAR	long
hvar	long
;	O
if	O
(	O
!	O
(	O
bErr	int
=	O
EGetPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
CH_LPAREN	O
)	O
)	O
)	O
{	O
if	O
(	O
!	O
(	O
bErr	int
=	O
ENextLex	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
LX_IDENTIFIER	int
)	O
)	O
)	O
{	O
if	O
(	O
(	O
bErr	int
=	O
!	O
(	O
hvar	long
=	O
GetVarHandle	function
(	O
szLex	pointer
)	O
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_UNDEFINED	int
,	O
szLex	pointer
,	O
NULL	O
)	O
;	O
else	O
{	O
if	O
(	O
!	O
(	O
pdatarec	pointer
=	O
(	O
PDATAREC	pointer
)	O
malloc	function
(	O
sizeof	O
(	O
DATAREC	struct
)	O
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetData"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
(	O
pdatarec	pointer
->	O
szDataName	pointer
=	O
(	O
PSTR	pointer
)	O
malloc	function
(	O
MyStrlen	O
(	O
szLex	pointer
)	O
+	O
1	int
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetData"	pointer
,	O
NULL	O
)	O
;	O
MyStrcpy	O
(	O
pdatarec	pointer
->	O
szDataName	pointer
,	O
szLex	pointer
)	O
;	O
assert	O
(	O
pdatarec	pointer
)	O
;	O
pdatarec	pointer
->	O
hvar	long
=	O
hvar	long
;	O
bErr	int
=	O
GetListOfData	function
(	O
pibIn	pointer
,	O
pdatarec	pointer
,	O
szLex	pointer
)	O
;	O
if	O
(	O
bErr	int
)	O
{	O
free	function
(	O
pdatarec	pointer
->	O
szDataName	pointer
)	O
;	O
free	function
(	O
pdatarec	pointer
)	O
;	O
}	O
else	O
QueueListItem	function
(	O
pos	pointer
->	O
plistDataRecs	pointer
,	O
(	O
PVOID	pointer
)	O
pdatarec	pointer
)	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
bErr	int
)	O
bErr	int
=	O
GetTerminator	function
(	O
pibIn	pointer
,	O
szLex	pointer
)	O
;	O
else	O
{	O
if	O
(	O
!	O
bGaveDataUsage	int
)	O
{	O
printf	function
(	O
"Syntax: %s (identifier, Time1, Time2, ...)\n\n"	pointer
,	O
GetKeyword	function
(	O
KM_DATA	int
)	O
)	O
;	O
bGaveDataUsage	int
=	O
TRUE	int
;	O
}	O
}	O
return	O
(	O
bErr	int
)	O
;	O
}	O
BOOL	int
GetStringArg	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PSTR	pointer
*	O
pszArg	pointer
,	O
PSTR	pointer
szLex	pointer
,	O
BOOL	int
bDelim	int
)	O
{	O
BOOL	int
bErr	int
;	O
assert	O
(	O
szLex	pointer
)	O
;	O
if	O
(	O
bDelim	int
)	O
GetOptPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
','	O
)	O
;	O
bErr	int
=	O
ENextLex	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
LX_STRING	int
)	O
;	O
if	O
(	O
!	O
bErr	int
)	O
{	O
if	O
(	O
szLex	pointer
[	O
0	int
]	O
)	O
{	O
if	O
(	O
!	O
(	O
*	O
pszArg	pointer
=	O
(	O
PSTR	pointer
)	O
malloc	function
(	O
MyStrlen	O
(	O
szLex	pointer
)	O
+	O
1	int
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetStringArg"	pointer
,	O
NULL	O
)	O
;	O
MyStrcpy	O
(	O
*	O
pszArg	pointer
,	O
szLex	pointer
)	O
;	O
}	O
else	O
*	O
pszArg	pointer
=	O
NULL	O
;	O
}	O
return	O
(	O
bErr	int
)	O
;	O
}	O
BOOL	int
GetOutputFile	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PSTR	pointer
szLex	pointer
,	O
PANALYSIS	pointer
panal	pointer
)	O
{	O
BOOL	int
bErr	int
=	O
FALSE	int
;	O
bErr	int
=	O
EGetPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
CH_LPAREN	O
)	O
||	O
GetStringArg	function
(	O
pibIn	pointer
,	O
&	O
panal	pointer
->	O
szOutfilename	pointer
,	O
szLex	pointer
,	O
FALSE	int
)	O
;	O
if	O
(	O
!	O
bErr	int
)	O
{	O
panal	pointer
->	O
bAllocatedFileName	int
=	O
TRUE	int
;	O
bErr	int
=	O
EGetPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
CH_RPAREN	O
)	O
;	O
}	O
if	O
(	O
!	O
bErr	int
)	O
bErr	int
=	O
GetTerminator	function
(	O
pibIn	pointer
,	O
szLex	pointer
)	O
;	O
else	O
printf	function
(	O
"Syntax: %s (szOutputFilename)\n\n"	pointer
,	O
GetKeyword	function
(	O
KM_OUTPUTFILE	int
)	O
)	O
;	O
return	O
(	O
bErr	int
)	O
;	O
}	O
BOOL	int
bGaveSimulateUsage	int
=	O
FALSE	int
;	O
BOOL	int
GetSimulate	function
(	O
)	O
{	O
if	O
(	O
!	O
bGaveSimulateUsage	int
)	O
{	O
printf	function
(	O
"Warning: %s statements are obsolete and ignored.\n\n"	pointer
,	O
GetKeyword	function
(	O
KM_SIMULATE	int
)	O
)	O
;	O
bGaveSimulateUsage	int
=	O
TRUE	int
;	O
}	O
return	O
(	O
1	int
)	O
;	O
}	O
BOOL	int
bGaveSrtTUsage	int
=	O
FALSE	int
;	O
BOOL	int
GetStartTime	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PEXPERIMENT	pointer
pexp	pointer
)	O
{	O
static	O
int	O
vrgiSimArgTypes	array
[	O
1	int
]	O
=	O
{	O
LX_NUMBER	O
|	O
LX_IDENTIFIER	int
}	O
;	O
BOOL	int
bErr	int
=	O
!	O
GetFuncArgs	function
(	O
pibIn	pointer
,	O
1	int
,	O
vrgiSimArgTypes	array
,	O
vrgszlexArgs	array
[	O
0	int
]	O
)	O
;	O
if	O
(	O
!	O
bErr	int
)	O
{	O
if	O
(	O
!	O
DefDepParm	function
(	O
vrgszlexArgs	array
[	O
0	int
]	O
,	O
&	O
pexp	pointer
->	O
dT0	double
,	O
&	O
pexp	pointer
->	O
hT0	long
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_EXPECTED	int
,	O
"StartTime spec"	pointer
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
bGaveSrtTUsage	int
)	O
{	O
printf	function
(	O
"Syntax: %s (InitialTime)\n\n"	pointer
,	O
GetKeyword	function
(	O
KM_STARTTIME	int
)	O
)	O
;	O
bGaveSrtTUsage	int
=	O
TRUE	int
;	O
}	O
}	O
return	O
(	O
bErr	int
)	O
;	O
}	O
BOOL	int
GetMCMCSpec	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PEXPERIMENT	pointer
pexp	pointer
)	O
{	O
static	O
int	O
vrgiGibbsArgTypes	array
[	O
NMCMC_ARGS	int
]	O
=	O
{	O
LX_STRING	int
,	O
LX_STRING	int
,	O
LX_STRING	int
,	O
LX_INTEGER	int
,	O
LX_INTEGER	int
,	O
LX_INTEGER	int
,	O
LX_INTEGER	int
,	O
LX_NUMBER	O
}	O
;	O
PANALYSIS	pointer
panal	pointer
=	O
(	O
PANALYSIS	pointer
)	O
pibIn	pointer
->	O
pInfo	pointer
;	O
BOOL	int
bErr	int
=	O
!	O
GetFuncArgs	function
(	O
pibIn	pointer
,	O
NMCMC_ARGS	int
,	O
vrgiGibbsArgTypes	array
,	O
vrgszlexArgs	array
[	O
0	int
]	O
)	O
;	O
static	O
char	O
vszGibbsOutDefault	array
[	O
]	O
=	O
"MCMC.default.out"	pointer
;	O
if	O
(	O
!	O
bErr	int
)	O
{	O
if	O
(	O
*	O
vrgszlexArgs	array
[	O
0	int
]	O
)	O
{	O
if	O
(	O
!	O
(	O
panal	pointer
->	O
gd	struct
.	O
szGout	pointer
=	O
(	O
PSTR	pointer
)	O
malloc	function
(	O
MyStrlen	O
(	O
vrgszlexArgs	array
[	O
0	int
]	O
)	O
+	O
1	int
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetMCMCSpec"	pointer
,	O
NULL	O
)	O
;	O
MyStrcpy	O
(	O
panal	pointer
->	O
gd	struct
.	O
szGout	pointer
,	O
vrgszlexArgs	array
[	O
0	int
]	O
)	O
;	O
panal	pointer
->	O
bAllocatedFileName	int
=	O
TRUE	int
;	O
}	O
else	O
panal	pointer
->	O
gd	struct
.	O
szGout	pointer
=	O
vszGibbsOutDefault	array
;	O
if	O
(	O
*	O
vrgszlexArgs	array
[	O
1	int
]	O
)	O
{	O
if	O
(	O
!	O
(	O
panal	pointer
->	O
gd	struct
.	O
szGrestart	pointer
=	O
(	O
PSTR	pointer
)	O
malloc	function
(	O
MyStrlen	O
(	O
vrgszlexArgs	array
[	O
1	int
]	O
)	O
+	O
1	int
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetMCMCSpec"	pointer
,	O
NULL	O
)	O
;	O
MyStrcpy	O
(	O
panal	pointer
->	O
gd	struct
.	O
szGrestart	pointer
,	O
vrgszlexArgs	array
[	O
1	int
]	O
)	O
;	O
}	O
if	O
(	O
panal	pointer
->	O
gd	struct
.	O
szGrestart	pointer
!=	O
NULL	O
&&	O
!	O
strcmp	function
(	O
panal	pointer
->	O
gd	struct
.	O
szGout	pointer
,	O
panal	pointer
->	O
gd	struct
.	O
szGrestart	pointer
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTISRESTART	int
|	O
RE_FATAL	int
,	O
"GetMCMCSpec"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
*	O
vrgszlexArgs	array
[	O
2	int
]	O
)	O
{	O
if	O
(	O
!	O
(	O
panal	pointer
->	O
gd	struct
.	O
szGdata	pointer
=	O
(	O
PSTR	pointer
)	O
malloc	function
(	O
MyStrlen	O
(	O
vrgszlexArgs	array
[	O
2	int
]	O
)	O
+	O
1	int
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetMCMCSpec"	pointer
,	O
NULL	O
)	O
;	O
MyStrcpy	O
(	O
panal	pointer
->	O
gd	struct
.	O
szGdata	pointer
,	O
vrgszlexArgs	array
[	O
2	int
]	O
)	O
;	O
}	O
panal	pointer
->	O
gd	struct
.	O
nMaxIter	long
=	O
atol	function
(	O
vrgszlexArgs	array
[	O
3	int
]	O
)	O
;	O
panal	pointer
->	O
gd	struct
.	O
nSimTypeFlag	long
=	O
atol	function
(	O
vrgszlexArgs	array
[	O
4	int
]	O
)	O
;	O
panal	pointer
->	O
gd	struct
.	O
nPrintFreq	long
=	O
atol	function
(	O
vrgszlexArgs	array
[	O
5	int
]	O
)	O
;	O
panal	pointer
->	O
gd	struct
.	O
nPrintIter	long
=	O
atol	function
(	O
vrgszlexArgs	array
[	O
6	int
]	O
)	O
;	O
panal	pointer
->	O
dSeed	double
=	O
atof	function
(	O
vrgszlexArgs	array
[	O
7	int
]	O
)	O
;	O
if	O
(	O
(	O
(	O
panal	pointer
->	O
gd	struct
.	O
nSimTypeFlag	long
==	O
1	int
)	O
&&	O
(	O
panal	pointer
->	O
gd	struct
.	O
szGrestart	pointer
==	O
NULL	O
)	O
)	O
||	O
(	O
(	O
panal	pointer
->	O
gd	struct
.	O
nSimTypeFlag	long
==	O
2	int
)	O
&&	O
(	O
panal	pointer
->	O
gd	struct
.	O
szGrestart	pointer
==	O
NULL	O
)	O
)	O
)	O
{	O
printf	function
(	O
"Error: if simTypeFlag is one or two a restart file must be "	pointer
"given - Exiting\n\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
}	O
else	O
{	O
printf	function
(	O
"Syntax:\n%s (szOut, szRestart, szData, "	pointer
"nMaxIters, simTypeFlag, nPrintFreq,\n"	pointer
"      nIterToPrint, dSeed)\nExiting.\n\n"	pointer
,	O
GetKeyword	function
(	O
KM_MCMC	int
)	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
if	O
(	O
!	O
bErr	int
)	O
panal	pointer
->	O
iType	int
=	O
AT_MCMC	int
;	O
return	O
(	O
!	O
bErr	int
)	O
;	O
}	O
BOOL	int
GetOptDSpec	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PANALYSIS	pointer
panal	pointer
,	O
PSTR	pointer
szLex	pointer
)	O
{	O
PMCVAR	pointer
pMCVar	pointer
;	O
HVAR	long
hvar	long
;	O
int	O
iErr	int
=	O
0	int
;	O
int	O
iNLI	int
;	O
int	O
ikwcode	int
;	O
if	O
(	O
(	O
iErr	int
=	O
EGetPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
CH_LPAREN	O
)	O
||	O
GetStringArg	function
(	O
pibIn	pointer
,	O
&	O
panal	pointer
->	O
gd	struct
.	O
szGout	pointer
,	O
szLex	pointer
,	O
FALSE	int
)	O
||	O
GetStringArg	function
(	O
pibIn	pointer
,	O
&	O
panal	pointer
->	O
gd	struct
.	O
szGrestart	pointer
,	O
szLex	pointer
,	O
TRUE	int
)	O
)	O
)	O
{	O
goto	O
Exit_GetOptDSpec	O
;	O
}	O
else	O
{	O
panal	pointer
->	O
bAllocatedFileName	int
=	O
TRUE	int
;	O
}	O
if	O
(	O
!	O
panal	pointer
->	O
gd	struct
.	O
szGrestart	pointer
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_SPECERR	int
|	O
RE_FATAL	int
,	O
"Missing restart file"	pointer
,	O
NULL	O
)	O
;	O
GetOptPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
','	O
)	O
;	O
if	O
(	O
(	O
iErr	int
=	O
ENextLex	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
LX_INTEGER	int
)	O
)	O
)	O
goto	O
Exit_GetOptDSpec	O
;	O
panal	pointer
->	O
mc	struct
.	O
nRuns	long
=	O
atol	function
(	O
szLex	pointer
)	O
;	O
GetOptPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
','	O
)	O
;	O
if	O
(	O
(	O
iErr	int
=	O
ENextLex	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
LX_NUMBER	O
)	O
)	O
)	O
goto	O
Exit_GetOptDSpec	O
;	O
panal	pointer
->	O
dSeed	double
=	O
atof	function
(	O
szLex	pointer
)	O
;	O
GetOptPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
','	O
)	O
;	O
if	O
(	O
(	O
iErr	int
=	O
ENextLex	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
LX_IDENTIFIER	int
)	O
)	O
)	O
goto	O
Exit_GetOptDSpec	O
;	O
ikwcode	int
=	O
GetKeywordCode	function
(	O
szLex	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
ikwcode	int
==	O
KM_FORWARD	int
)	O
panal	pointer
->	O
mc	struct
.	O
style	int
=	O
forward	int
;	O
else	O
if	O
(	O
ikwcode	int
==	O
KM_BACKWARD	int
)	O
panal	pointer
->	O
mc	struct
.	O
style	int
=	O
backward	int
;	O
else	O
{	O
iErr	int
=	O
TRUE	int
;	O
goto	O
Exit_GetOptDSpec	O
;	O
}	O
while	O
(	O
(	O
iNLI	int
=	O
NextListItem	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
LX_IDENTIFIER	int
,	O
1	int
,	O
CH_RPAREN	O
)	O
)	O
>	O
0	int
)	O
{	O
hvar	long
=	O
GetVarHandle	function
(	O
szLex	pointer
)	O
;	O
if	O
(	O
(	O
iErr	int
=	O
(	O
!	O
hvar	long
||	O
IsInput	function
(	O
hvar	long
)	O
)	O
)	O
)	O
break	O
;	O
if	O
(	O
!	O
(	O
pMCVar	pointer
=	O
(	O
PMCVAR	pointer
)	O
malloc	function
(	O
sizeof	O
(	O
MCVAR	struct
)	O
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetOptDSpec"	pointer
,	O
NULL	O
)	O
;	O
pMCVar	pointer
->	O
hvar	long
=	O
hvar	long
;	O
pMCVar	pointer
->	O
iType	int
=	O
MCV_SETPOINTS	O
;	O
pMCVar	pointer
->	O
dParm	array
[	O
2	int
]	O
=	O
pMCVar	pointer
->	O
dParm	array
[	O
3	int
]	O
=	O
0.0	int
;	O
QueueListItem	function
(	O
panal	pointer
->	O
mc	struct
.	O
plistMCVars	pointer
,	O
pMCVar	pointer
)	O
;	O
}	O
panal	pointer
->	O
mc	struct
.	O
nSetParms	long
=	O
ListLength	O
(	O
panal	pointer
->	O
mc	struct
.	O
plistMCVars	pointer
)	O
;	O
if	O
(	O
panal	pointer
->	O
mc	struct
.	O
nSetParms	long
==	O
0	int
)	O
{	O
iErr	int
=	O
TRUE	int
;	O
printf	function
(	O
"\nError: you must specify a list of parameters to read.\n\n"	pointer
)	O
;	O
goto	O
Exit_GetOptDSpec	O
;	O
}	O
if	O
(	O
!	O
iNLI	int
)	O
iErr	int
=	O
EGetPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
CH_RPAREN	O
)	O
;	O
else	O
{	O
iErr	int
=	O
TRUE	int
;	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
,	O
"identifier"	pointer
,	O
szLex	pointer
)	O
;	O
}	O
Exit_GetOptDSpec	O
:	O
;	O
if	O
(	O
iErr	int
)	O
{	O
printf	function
(	O
"Syntax:\n"	pointer
"%s (\"Output_File\", \"Param_Sample_File\", nSamples, "	pointer
"random_seed, <Forward or Backward>, "	pointer
"<param-id-list...>)\n\n"	pointer
,	O
GetKeyword	function
(	O
KM_OPTDESIGN	int
)	O
)	O
;	O
printf	function
(	O
"Exiting...\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
else	O
panal	pointer
->	O
iType	int
=	O
AT_OPTDESIGN	int
;	O
return	O
(	O
iErr	int
)	O
;	O
}	O
BOOL	int
bGaveMCVaryUsage	int
=	O
FALSE	int
;	O
int	O
GetDistribSpec	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PANALYSIS	pointer
panal	pointer
,	O
PSTR	pointer
szLex	pointer
)	O
{	O
PLIST	pointer
plist	pointer
;	O
PMCVAR	pointer
pMCVar	pointer
=	O
NULL	O
;	O
HVAR	long
hvar	long
;	O
int	O
n	int
,	O
iErr	int
=	O
0	int
;	O
PSTRLEX	array
szDummy	array
;	O
if	O
(	O
panal	pointer
->	O
iType	int
&&	O
!	O
(	O
(	O
panal	pointer
->	O
iType	int
==	O
AT_MONTECARLO	int
)	O
||	O
(	O
panal	pointer
->	O
iType	int
==	O
AT_SETPOINTS	int
)	O
||	O
(	O
panal	pointer
->	O
iType	int
==	O
AT_OPTDESIGN	int
)	O
||	O
(	O
panal	pointer
->	O
iType	int
==	O
AT_MCMC	int
)	O
)	O
)	O
{	O
EatStatement	function
(	O
pibIn	pointer
)	O
;	O
goto	O
Exit_MCVarySpec	O
;	O
}	O
if	O
(	O
(	O
iErr	int
=	O
(	O
EGetPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
CH_LPAREN	O
)	O
||	O
ENextLex	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
LX_IDENTIFIER	int
)	O
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
if	O
(	O
GetKeywordCode	function
(	O
szLex	pointer
,	O
NULL	O
)	O
==	O
KM_DATA	int
)	O
{	O
if	O
(	O
EGetPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
CH_LPAREN	O
)	O
)	O
exit	function
(	O
0	int
)	O
;	O
ENextLex	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
LX_IDENTIFIER	int
)	O
;	O
if	O
(	O
!	O
(	O
hvar	long
=	O
GetVarHandle	function
(	O
szLex	pointer
)	O
)	O
||	O
IsParm	function
(	O
hvar	long
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
|	O
RE_FATAL	int
,	O
"input, output or state variable"	pointer
,	O
szLex	pointer
)	O
;	O
if	O
(	O
EGetPunct	function
(	O
pibIn	pointer
,	O
szDummy	array
,	O
CH_RPAREN	O
)	O
)	O
exit	function
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
(	O
iErr	int
=	O
(	O
!	O
(	O
hvar	long
=	O
GetVarHandle	function
(	O
szLex	pointer
)	O
)	O
||	O
IsInput	function
(	O
hvar	long
)	O
)	O
)	O
)	O
{	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
,	O
"state, output or parameter"	pointer
,	O
szLex	pointer
)	O
;	O
goto	O
Done_GetMCVary	O
;	O
}	O
if	O
(	O
panal	pointer
->	O
iCurrentDepth	int
==	O
0	int
)	O
plist	pointer
=	O
panal	pointer
->	O
mc	struct
.	O
plistMCVars	pointer
;	O
else	O
{	O
if	O
(	O
!	O
IsParm	function
(	O
hvar	long
)	O
)	O
plist	pointer
=	O
panal	pointer
->	O
pCurrentLevel	array
[	O
panal	pointer
->	O
iCurrentDepth	int
-	O
1	int
]	O
->	O
plistLikes	pointer
;	O
else	O
plist	pointer
=	O
panal	pointer
->	O
pCurrentLevel	array
[	O
panal	pointer
->	O
iCurrentDepth	int
-	O
1	int
]	O
->	O
plistMCVars	pointer
;	O
}	O
if	O
(	O
!	O
(	O
pMCVar	pointer
=	O
(	O
PMCVAR	pointer
)	O
malloc	function
(	O
sizeof	O
(	O
MCVAR	struct
)	O
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetDistribSpec"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
(	O
pMCVar	pointer
->	O
pszName	pointer
=	O
(	O
PSTR	pointer
)	O
malloc	function
(	O
strlen	function
(	O
szLex	pointer
)	O
+	O
1	int
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetDistribSpec"	pointer
,	O
NULL	O
)	O
;	O
strcpy	function
(	O
pMCVar	pointer
->	O
pszName	pointer
,	O
szLex	pointer
)	O
;	O
pMCVar	pointer
->	O
hvar	long
=	O
hvar	long
;	O
pMCVar	pointer
->	O
pdVal	pointer
=	O
&	O
(	O
pMCVar	pointer
->	O
dVal	double
)	O
;	O
pMCVar	pointer
->	O
iDepth	int
=	O
panal	pointer
->	O
iCurrentDepth	int
-	O
1	int
;	O
pMCVar	pointer
->	O
plistDependents	pointer
=	O
InitList	function
(	O
)	O
;	O
pMCVar	pointer
->	O
bExptIsDep	int
=	O
pMCVar	pointer
->	O
bIsFixed	int
=	O
FALSE	int
;	O
pMCVar	pointer
->	O
lJumps	long
=	O
pMCVar	pointer
->	O
lCount	long
=	O
0	int
;	O
pMCVar	pointer
->	O
dKernelSD	double
=	O
INIT_KERNELSD	int
;	O
pMCVar	pointer
->	O
bGibbs	int
=	O
FALSE	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
4	int
;	O
n	int
++	O
)	O
{	O
pMCVar	pointer
->	O
hParm	array
[	O
n	int
]	O
=	O
0	int
;	O
pMCVar	pointer
->	O
pMCVParent	array
[	O
n	int
]	O
=	O
NULL	O
;	O
pMCVar	pointer
->	O
pdParm	array
[	O
n	int
]	O
=	O
&	O
(	O
pMCVar	pointer
->	O
dParm	array
[	O
n	int
]	O
)	O
;	O
pMCVar	pointer
->	O
iParmType	array
[	O
n	int
]	O
=	O
0	int
;	O
}	O
GetOptPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
','	O
)	O
;	O
iErr	int
|=	O
ENextLex	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
LX_IDENTIFIER	int
)	O
;	O
pMCVar	pointer
->	O
iType	int
=	O
McvFromLex	function
(	O
szLex	pointer
)	O
;	O
if	O
(	O
iErr	int
|=	O
pMCVar	pointer
->	O
iType	int
<	O
0	int
)	O
{	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
,	O
"distribution-type"	pointer
,	O
szLex	pointer
)	O
;	O
goto	O
Done_GetMCVary	O
;	O
}	O
switch	O
(	O
pMCVar	pointer
->	O
iType	int
)	O
{	O
case	O
MCV_UNIFORM	int
:	O
case	O
MCV_LOGUNIFORM	int
:	O
if	O
(	O
(	O
iErr	int
=	O
GetDistribParam	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
plist	pointer
,	O
0	int
,	O
pMCVar	pointer
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
if	O
(	O
(	O
iErr	int
=	O
GetDistribParam	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
plist	pointer
,	O
1	int
,	O
pMCVar	pointer
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
pMCVar	pointer
->	O
dParm	array
[	O
2	int
]	O
=	O
-	O
DBL_MAX	O
*	O
0.5	int
;	O
pMCVar	pointer
->	O
dParm	array
[	O
3	int
]	O
=	O
DBL_MAX	O
*	O
0.5	int
;	O
break	O
;	O
case	O
MCV_NORMAL	int
:	O
case	O
MCV_LOGNORMAL	int
:	O
case	O
MCV_NORMALCV	int
:	O
case	O
MCV_NORMALV	int
:	O
case	O
MCV_LOGNORMALV	int
:	O
if	O
(	O
(	O
iErr	int
=	O
GetDistribParam	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
plist	pointer
,	O
0	int
,	O
pMCVar	pointer
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
if	O
(	O
(	O
iErr	int
=	O
GetDistribParam	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
plist	pointer
,	O
1	int
,	O
pMCVar	pointer
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
if	O
(	O
(	O
pMCVar	pointer
->	O
iType	int
==	O
MCV_NORMAL	int
)	O
||	O
(	O
pMCVar	pointer
->	O
iType	int
==	O
MCV_NORMALCV	int
)	O
||	O
(	O
pMCVar	pointer
->	O
iType	int
==	O
MCV_NORMALV	int
)	O
)	O
{	O
pMCVar	pointer
->	O
dParm	array
[	O
2	int
]	O
=	O
-	O
DBL_MAX	O
*	O
0.5	int
;	O
pMCVar	pointer
->	O
dParm	array
[	O
3	int
]	O
=	O
DBL_MAX	O
*	O
0.5	int
;	O
}	O
else	O
{	O
pMCVar	pointer
->	O
dParm	array
[	O
2	int
]	O
=	O
0.0	int
;	O
pMCVar	pointer
->	O
dParm	array
[	O
3	int
]	O
=	O
DBL_MAX	O
;	O
}	O
break	O
;	O
case	O
MCV_HALFNORMAL	int
:	O
if	O
(	O
(	O
iErr	int
=	O
GetDistribParam	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
plist	pointer
,	O
1	int
,	O
pMCVar	pointer
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
pMCVar	pointer
->	O
dParm	array
[	O
0	int
]	O
=	O
0.0	int
;	O
pMCVar	pointer
->	O
dParm	array
[	O
2	int
]	O
=	O
0.0	int
;	O
pMCVar	pointer
->	O
dParm	array
[	O
3	int
]	O
=	O
DBL_MAX	O
;	O
break	O
;	O
case	O
MCV_BETA	int
:	O
case	O
MCV_TRUNCNORMAL	int
:	O
case	O
MCV_TRUNCLOGNORMAL	int
:	O
case	O
MCV_TRUNCNORMALCV	int
:	O
case	O
MCV_TRUNCNORMALV	int
:	O
case	O
MCV_TRUNCLOGNORMALV	int
:	O
if	O
(	O
(	O
iErr	int
=	O
GetDistribParam	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
plist	pointer
,	O
0	int
,	O
pMCVar	pointer
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
if	O
(	O
(	O
iErr	int
=	O
GetDistribParam	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
plist	pointer
,	O
1	int
,	O
pMCVar	pointer
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
pMCVar	pointer
->	O
dParm	array
[	O
2	int
]	O
=	O
0.0	int
;	O
pMCVar	pointer
->	O
dParm	array
[	O
3	int
]	O
=	O
1.0	int
;	O
if	O
(	O
(	O
pMCVar	pointer
->	O
iType	int
==	O
MCV_TRUNCNORMAL	int
)	O
||	O
(	O
pMCVar	pointer
->	O
iType	int
==	O
MCV_TRUNCNORMALCV	int
)	O
||	O
(	O
pMCVar	pointer
->	O
iType	int
==	O
MCV_TRUNCNORMALV	int
)	O
)	O
{	O
pMCVar	pointer
->	O
dParm	array
[	O
2	int
]	O
=	O
-	O
DBL_MAX	O
*	O
0.5	int
;	O
pMCVar	pointer
->	O
dParm	array
[	O
3	int
]	O
=	O
DBL_MAX	O
*	O
0.5	int
;	O
}	O
else	O
if	O
(	O
(	O
pMCVar	pointer
->	O
iType	int
==	O
MCV_TRUNCLOGNORMAL	int
)	O
||	O
(	O
pMCVar	pointer
->	O
iType	int
==	O
MCV_TRUNCLOGNORMALV	int
)	O
)	O
pMCVar	pointer
->	O
dParm	array
[	O
3	int
]	O
=	O
DBL_MAX	O
;	O
SkipWhitespace	function
(	O
pibIn	pointer
)	O
;	O
if	O
(	O
(	O
pMCVar	pointer
->	O
iType	int
==	O
MCV_BETA	int
)	O
&&	O
NextChar	function
(	O
pibIn	pointer
)	O
==	O
CH_RPAREN	O
)	O
break	O
;	O
if	O
(	O
(	O
iErr	int
=	O
GetDistribParam	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
plist	pointer
,	O
2	int
,	O
pMCVar	pointer
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
if	O
(	O
(	O
iErr	int
=	O
GetDistribParam	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
plist	pointer
,	O
3	int
,	O
pMCVar	pointer
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
break	O
;	O
case	O
MCV_CHI2	int
:	O
if	O
(	O
(	O
iErr	int
=	O
GetDistribParam	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
plist	pointer
,	O
0	int
,	O
pMCVar	pointer
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
pMCVar	pointer
->	O
dParm	array
[	O
2	int
]	O
=	O
0.0	int
;	O
pMCVar	pointer
->	O
dParm	array
[	O
3	int
]	O
=	O
DBL_MAX	O
;	O
break	O
;	O
case	O
MCV_BINOMIAL	int
:	O
if	O
(	O
(	O
iErr	int
=	O
GetDistribParam	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
plist	pointer
,	O
0	int
,	O
pMCVar	pointer
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
if	O
(	O
(	O
iErr	int
=	O
GetDistribParam	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
plist	pointer
,	O
1	int
,	O
pMCVar	pointer
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
pMCVar	pointer
->	O
dParm	array
[	O
2	int
]	O
=	O
0.0	int
;	O
if	O
(	O
pMCVar	pointer
->	O
iParmType	array
[	O
1	int
]	O
!=	O
MCVP_FIXD	int
)	O
pMCVar	pointer
->	O
dParm	array
[	O
3	int
]	O
=	O
DBL_MAX	O
;	O
else	O
pMCVar	pointer
->	O
dParm	array
[	O
3	int
]	O
=	O
pMCVar	pointer
->	O
dParm	array
[	O
1	int
]	O
;	O
break	O
;	O
case	O
MCV_PIECEWISE	int
:	O
if	O
(	O
(	O
iErr	int
=	O
GetDistribParam	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
plist	pointer
,	O
2	int
,	O
pMCVar	pointer
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
if	O
(	O
(	O
iErr	int
=	O
GetDistribParam	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
plist	pointer
,	O
0	int
,	O
pMCVar	pointer
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
if	O
(	O
(	O
iErr	int
=	O
GetDistribParam	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
plist	pointer
,	O
1	int
,	O
pMCVar	pointer
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
if	O
(	O
(	O
iErr	int
=	O
GetDistribParam	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
plist	pointer
,	O
3	int
,	O
pMCVar	pointer
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
break	O
;	O
case	O
MCV_EXPONENTIAL	int
:	O
if	O
(	O
(	O
iErr	int
=	O
GetDistribParam	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
plist	pointer
,	O
0	int
,	O
pMCVar	pointer
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
pMCVar	pointer
->	O
dParm	array
[	O
2	int
]	O
=	O
0.0	int
;	O
pMCVar	pointer
->	O
dParm	array
[	O
3	int
]	O
=	O
DBL_MAX	O
;	O
break	O
;	O
case	O
MCV_GGAMMA	int
:	O
case	O
MCV_INVGGAMMA	int
:	O
if	O
(	O
(	O
iErr	int
=	O
GetDistribParam	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
plist	pointer
,	O
0	int
,	O
pMCVar	pointer
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
if	O
(	O
(	O
iErr	int
=	O
GetDistribParam	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
plist	pointer
,	O
1	int
,	O
pMCVar	pointer
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
pMCVar	pointer
->	O
dParm	array
[	O
2	int
]	O
=	O
0.0	int
;	O
pMCVar	pointer
->	O
dParm	array
[	O
3	int
]	O
=	O
DBL_MAX	O
;	O
break	O
;	O
case	O
MCV_TRUNCINVGGAMMA	int
:	O
printf	function
(	O
"Warning: The truncated inverse gamma density cannot be\n"	pointer
)	O
;	O
printf	function
(	O
"         used in MCMC simulations if the GNU Scientific\n"	pointer
)	O
;	O
printf	function
(	O
"         Library is not installed.\n"	pointer
)	O
;	O
if	O
(	O
(	O
iErr	int
=	O
GetDistribParam	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
plist	pointer
,	O
0	int
,	O
pMCVar	pointer
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
if	O
(	O
(	O
iErr	int
=	O
GetDistribParam	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
plist	pointer
,	O
1	int
,	O
pMCVar	pointer
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
if	O
(	O
(	O
iErr	int
=	O
GetDistribParam	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
plist	pointer
,	O
2	int
,	O
pMCVar	pointer
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
if	O
(	O
(	O
iErr	int
=	O
GetDistribParam	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
plist	pointer
,	O
3	int
,	O
pMCVar	pointer
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
break	O
;	O
case	O
MCV_POISSON	int
:	O
if	O
(	O
(	O
iErr	int
=	O
GetDistribParam	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
plist	pointer
,	O
0	int
,	O
pMCVar	pointer
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
pMCVar	pointer
->	O
dParm	array
[	O
2	int
]	O
=	O
0.0	int
;	O
pMCVar	pointer
->	O
dParm	array
[	O
3	int
]	O
=	O
DBL_MAX	O
;	O
break	O
;	O
case	O
MCV_BINOMIALBETA	int
:	O
case	O
MCV_GENLOGNORMAL	int
:	O
case	O
MCV_STUDENTT	int
:	O
if	O
(	O
(	O
iErr	int
=	O
GetDistribParam	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
plist	pointer
,	O
0	int
,	O
pMCVar	pointer
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
if	O
(	O
(	O
iErr	int
=	O
GetDistribParam	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
plist	pointer
,	O
1	int
,	O
pMCVar	pointer
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
if	O
(	O
(	O
iErr	int
=	O
GetDistribParam	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
plist	pointer
,	O
2	int
,	O
pMCVar	pointer
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
pMCVar	pointer
->	O
dParm	array
[	O
3	int
]	O
=	O
DBL_MAX	O
;	O
break	O
;	O
case	O
MCV_CAUCHY	int
:	O
if	O
(	O
(	O
iErr	int
=	O
GetDistribParam	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
plist	pointer
,	O
0	int
,	O
pMCVar	pointer
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
pMCVar	pointer
->	O
dParm	array
[	O
1	int
]	O
=	O
DBL_MAX	O
;	O
pMCVar	pointer
->	O
dParm	array
[	O
2	int
]	O
=	O
-	O
DBL_MAX	O
*	O
0.5	int
;	O
pMCVar	pointer
->	O
dParm	array
[	O
3	int
]	O
=	O
DBL_MAX	O
*	O
0.5	int
;	O
break	O
;	O
case	O
MCV_HALFCAUCHY	int
:	O
if	O
(	O
(	O
iErr	int
=	O
GetDistribParam	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
plist	pointer
,	O
0	int
,	O
pMCVar	pointer
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
pMCVar	pointer
->	O
dParm	array
[	O
1	int
]	O
=	O
DBL_MAX	O
*	O
0.5	int
;	O
pMCVar	pointer
->	O
dParm	array
[	O
2	int
]	O
=	O
0	int
;	O
pMCVar	pointer
->	O
dParm	array
[	O
3	int
]	O
=	O
DBL_MAX	O
;	O
break	O
;	O
case	O
MCV_USERLL	int
:	O
if	O
(	O
!	O
panal	pointer
->	O
pCurrentLevel	array
[	O
panal	pointer
->	O
iCurrentDepth	int
-	O
1	int
]	O
||	O
(	O
plist	pointer
!=	O
panal	pointer
->	O
pCurrentLevel	array
[	O
panal	pointer
->	O
iCurrentDepth	int
-	O
1	int
]	O
->	O
plistLikes	pointer
)	O
)	O
{	O
printf	function
(	O
"UserSpecifiefLL can only be used in Likelihood()."	pointer
)	O
;	O
iErr	int
=	O
1	int
;	O
goto	O
Done_GetMCVary	O
;	O
}	O
if	O
(	O
(	O
iErr	int
=	O
GetDistribParam	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
plist	pointer
,	O
0	int
,	O
pMCVar	pointer
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
pMCVar	pointer
->	O
dParm	array
[	O
1	int
]	O
=	O
DBL_MAX	O
*	O
0.5	int
;	O
pMCVar	pointer
->	O
dParm	array
[	O
2	int
]	O
=	O
0	int
;	O
pMCVar	pointer
->	O
dParm	array
[	O
3	int
]	O
=	O
DBL_MAX	O
;	O
break	O
;	O
default	O
:	O
ReportRunTimeError	function
(	O
panal	pointer
,	O
RE_UNKNOWNDIST	int
|	O
RE_FATAL	int
,	O
"GetDistribSpec"	pointer
)	O
;	O
break	O
;	O
}	O
EGetPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
CH_RPAREN	O
)	O
;	O
if	O
(	O
(	O
pMCVar	pointer
->	O
iParmType	array
[	O
2	int
]	O
==	O
MCVP_FIXD	int
)	O
&&	O
(	O
pMCVar	pointer
->	O
iParmType	array
[	O
3	int
]	O
==	O
MCVP_FIXD	int
)	O
&&	O
(	O
pMCVar	pointer
->	O
dParm	array
[	O
3	int
]	O
<	O
pMCVar	pointer
->	O
dParm	array
[	O
2	int
]	O
)	O
)	O
{	O
double	O
dTmp	double
=	O
pMCVar	pointer
->	O
dParm	array
[	O
3	int
]	O
;	O
pMCVar	pointer
->	O
dParm	array
[	O
3	int
]	O
=	O
pMCVar	pointer
->	O
dParm	array
[	O
2	int
]	O
;	O
pMCVar	pointer
->	O
dParm	array
[	O
2	int
]	O
=	O
dTmp	double
;	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_MAXMIN_RANGE	int
|	O
RE_WARNING	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
if	O
(	O
!	O
iErr	int
)	O
{	O
QueueListItem	function
(	O
plist	pointer
,	O
pMCVar	pointer
)	O
;	O
}	O
Done_GetMCVary	O
:	O
;	O
if	O
(	O
iErr	int
)	O
{	O
if	O
(	O
pMCVar	pointer
)	O
free	function
(	O
pMCVar	pointer
)	O
;	O
if	O
(	O
!	O
bGaveMCVaryUsage	int
)	O
{	O
printf	function
(	O
"\nSyntax: Check the syntax of %s.\n"	pointer
,	O
GetKeyword	function
(	O
KM_MCVARY	int
)	O
)	O
;	O
bGaveMCVaryUsage	int
=	O
TRUE	int
;	O
}	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_SYNTAXERR	int
|	O
RE_FATAL	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
Exit_MCVarySpec	O
:	O
;	O
return	O
(	O
iErr	int
)	O
;	O
}	O
BOOL	int
CheckDistribParam	function
(	O
PLIST	pointer
plist	pointer
,	O
HVAR	long
hvar1	long
,	O
HVAR	long
hvar2	long
)	O
{	O
int	O
n	int
;	O
PLISTELEM	pointer
p	double
=	O
plist	pointer
->	O
pleHead	pointer
;	O
PMCVAR	pointer
pMCVar	pointer
;	O
if	O
(	O
plist	pointer
==	O
NULL	O
)	O
return	O
TRUE	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plist	pointer
->	O
iSize	int
;	O
++	O
n	int
)	O
{	O
pMCVar	pointer
=	O
(	O
PMCVAR	pointer
)	O
p	double
->	O
pData	pointer
;	O
if	O
(	O
hvar2	long
==	O
pMCVar	pointer
->	O
hvar	long
)	O
{	O
if	O
(	O
(	O
pMCVar	pointer
->	O
iParmType	array
[	O
0	int
]	O
==	O
MCVP_PARM	int
)	O
&&	O
(	O
hvar1	long
==	O
pMCVar	pointer
->	O
hParm	array
[	O
0	int
]	O
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
(	O
pMCVar	pointer
->	O
iParmType	array
[	O
1	int
]	O
==	O
MCVP_PARM	int
)	O
&&	O
(	O
hvar1	long
==	O
pMCVar	pointer
->	O
hParm	array
[	O
1	int
]	O
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
(	O
pMCVar	pointer
->	O
iParmType	array
[	O
2	int
]	O
==	O
MCVP_PARM	int
)	O
&&	O
(	O
hvar1	long
==	O
pMCVar	pointer
->	O
hParm	array
[	O
2	int
]	O
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
(	O
pMCVar	pointer
->	O
iParmType	array
[	O
3	int
]	O
==	O
MCVP_PARM	int
)	O
&&	O
(	O
hvar1	long
==	O
pMCVar	pointer
->	O
hParm	array
[	O
3	int
]	O
)	O
)	O
return	O
FALSE	int
;	O
}	O
p	double
=	O
p	double
->	O
pleNext	pointer
;	O
}	O
return	O
TRUE	int
;	O
}	O
int	O
GetDistribParam	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PSTR	pointer
szLex	pointer
,	O
PLIST	pointer
plist	pointer
,	O
int	O
n	int
,	O
PMCVAR	pointer
pMCVar	pointer
)	O
{	O
PANALYSIS	pointer
panal	pointer
=	O
(	O
PANALYSIS	pointer
)	O
pibIn	pointer
->	O
pInfo	pointer
;	O
int	O
iLex	int
,	O
iCode	int
;	O
HVAR	long
hvar	long
;	O
GetOptPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
','	O
)	O
;	O
if	O
(	O
n	int
!=	O
3	int
)	O
NextLex	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
&	O
iLex	int
)	O
;	O
else	O
{	O
SkipWhitespace	function
(	O
pibIn	pointer
)	O
;	O
iLex	int
=	O
LX_NULL	int
;	O
if	O
(	O
NextChar	function
(	O
pibIn	pointer
)	O
!=	O
CH_RPAREN	O
)	O
NextLex	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
&	O
iLex	int
)	O
;	O
}	O
if	O
(	O
iLex	int
==	O
LX_IDENTIFIER	int
)	O
{	O
iCode	int
=	O
GetKeywordCode_in_context	function
(	O
szLex	pointer
,	O
CN_FUNCARG	int
)	O
;	O
if	O
(	O
(	O
iCode	int
==	O
KM_PREDICTION	int
)	O
||	O
(	O
iCode	int
==	O
KM_DATA	int
)	O
)	O
{	O
if	O
(	O
IsParm	function
(	O
pMCVar	pointer
->	O
hvar	long
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_BADCONTEXT	int
|	O
RE_FATAL	int
,	O
szLex	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
EGetPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
CH_LPAREN	O
)	O
)	O
return	O
1	int
;	O
NextLex	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
&	O
iLex	int
)	O
;	O
if	O
(	O
!	O
(	O
hvar	long
=	O
GetVarHandle	function
(	O
szLex	pointer
)	O
)	O
||	O
IsParm	function
(	O
hvar	long
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
|	O
RE_FATAL	int
,	O
"input, output or state variable"	pointer
,	O
szLex	pointer
)	O
;	O
if	O
(	O
EGetPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
CH_RPAREN	O
)	O
)	O
return	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
(	O
hvar	long
=	O
GetVarHandle	function
(	O
szLex	pointer
)	O
)	O
||	O
!	O
IsParm	function
(	O
hvar	long
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
|	O
RE_FATAL	int
,	O
"parameter"	pointer
,	O
szLex	pointer
)	O
;	O
}	O
if	O
(	O
!	O
(	O
panal	pointer
->	O
iType	int
==	O
AT_OPTDESIGN	int
)	O
&&	O
(	O
(	O
panal	pointer
->	O
iCurrentDepth	int
==	O
0	int
&&	O
hvar	long
==	O
pMCVar	pointer
->	O
hvar	long
)	O
||	O
!	O
CheckDistribParam	function
(	O
plist	pointer
,	O
pMCVar	pointer
->	O
hvar	long
,	O
hvar	long
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
|	O
RE_FATAL	int
,	O
"valid parameter"	pointer
,	O
szLex	pointer
)	O
;	O
if	O
(	O
iCode	int
==	O
KM_PREDICTION	int
)	O
pMCVar	pointer
->	O
iParmType	array
[	O
n	int
]	O
=	O
MCVP_PRED	int
;	O
else	O
if	O
(	O
iCode	int
==	O
KM_DATA	int
)	O
pMCVar	pointer
->	O
iParmType	array
[	O
n	int
]	O
=	O
MCVP_DATA	int
;	O
else	O
pMCVar	pointer
->	O
iParmType	array
[	O
n	int
]	O
=	O
MCVP_PARM	int
;	O
pMCVar	pointer
->	O
hParm	array
[	O
n	int
]	O
=	O
hvar	long
;	O
}	O
else	O
if	O
(	O
iLex	int
==	O
LX_FLOAT	int
||	O
iLex	int
==	O
LX_INTEGER	int
)	O
{	O
pMCVar	pointer
->	O
iParmType	array
[	O
n	int
]	O
=	O
MCVP_FIXD	int
;	O
pMCVar	pointer
->	O
dParm	array
[	O
n	int
]	O
=	O
atof	function
(	O
szLex	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
n	int
==	O
3	int
)	O
{	O
pMCVar	pointer
->	O
iParmType	array
[	O
n	int
]	O
=	O
MCVP_FIXD	int
;	O
pMCVar	pointer
->	O
dParm	array
[	O
n	int
]	O
=	O
DBL_MAX	O
;	O
}	O
else	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
GetSetPointsSpec	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PANALYSIS	pointer
panal	pointer
,	O
PSTR	pointer
szLex	pointer
)	O
{	O
PMCVAR	pointer
pMCVar	pointer
;	O
PSTRLEX	array
szTmp	array
;	O
HVAR	long
hvar	long
;	O
int	O
iErr	int
=	O
0	int
;	O
int	O
iNLI	int
;	O
long	O
j	int
,	O
iLB	long
,	O
iUB	long
;	O
if	O
(	O
ListLength	O
(	O
panal	pointer
->	O
mc	struct
.	O
plistMCVars	pointer
)	O
>	O
0	int
)	O
{	O
printf	function
(	O
"Error: Distrib() statements can only appear after the SetPoints()"	pointer
"specification, not before - Exiting\n\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
if	O
(	O
(	O
iErr	int
=	O
EGetPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
CH_LPAREN	O
)	O
||	O
GetStringArg	function
(	O
pibIn	pointer
,	O
&	O
panal	pointer
->	O
mc	struct
.	O
szMCOutfilename	pointer
,	O
szLex	pointer
,	O
FALSE	int
)	O
||	O
GetStringArg	function
(	O
pibIn	pointer
,	O
&	O
panal	pointer
->	O
mc	struct
.	O
szSetPointsFilename	pointer
,	O
szLex	pointer
,	O
TRUE	int
)	O
)	O
)	O
{	O
goto	O
Exit_GetSetPointsSpec	O
;	O
}	O
else	O
{	O
panal	pointer
->	O
bAllocatedFileName	int
=	O
TRUE	int
;	O
}	O
if	O
(	O
!	O
panal	pointer
->	O
mc	struct
.	O
szSetPointsFilename	pointer
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_SPECERR	int
|	O
RE_FATAL	int
,	O
"Missing setpoints file"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
MyStrcmp	function
(	O
panal	pointer
->	O
mc	struct
.	O
szMCOutfilename	pointer
,	O
panal	pointer
->	O
mc	struct
.	O
szSetPointsFilename	pointer
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_SPECERR	int
|	O
RE_FATAL	int
,	O
"Same name for 2 files"	pointer
,	O
NULL	O
)	O
;	O
GetOptPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
','	O
)	O
;	O
if	O
(	O
(	O
iErr	int
=	O
ENextLex	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
LX_INTEGER	int
)	O
)	O
)	O
goto	O
Exit_GetSetPointsSpec	O
;	O
panal	pointer
->	O
mc	struct
.	O
nRuns	long
=	O
atol	function
(	O
szLex	pointer
)	O
;	O
while	O
(	O
(	O
iNLI	int
=	O
NextListItem	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
LX_IDENTIFIER	int
,	O
1	int
,	O
CH_RPAREN	O
)	O
)	O
>	O
0	int
)	O
{	O
iLB	long
=	O
iUB	long
=	O
-	O
1	int
;	O
if	O
(	O
GetPunct	function
(	O
pibIn	pointer
,	O
szTmp	array
,	O
'['	O
)	O
)	O
GetArrayBounds	function
(	O
pibIn	pointer
,	O
&	O
iLB	long
,	O
&	O
iUB	long
)	O
;	O
if	O
(	O
iUB	long
==	O
-	O
1	int
)	O
{	O
hvar	long
=	O
GetVarHandle	function
(	O
szLex	pointer
)	O
;	O
if	O
(	O
(	O
iErr	int
=	O
(	O
!	O
hvar	long
||	O
IsInput	function
(	O
hvar	long
)	O
)	O
)	O
)	O
break	O
;	O
if	O
(	O
!	O
(	O
pMCVar	pointer
=	O
(	O
PMCVAR	pointer
)	O
malloc	function
(	O
sizeof	O
(	O
MCVAR	struct
)	O
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetSetPointsSpec"	pointer
,	O
NULL	O
)	O
;	O
pMCVar	pointer
->	O
hvar	long
=	O
hvar	long
;	O
pMCVar	pointer
->	O
iType	int
=	O
MCV_SETPOINTS	O
;	O
pMCVar	pointer
->	O
dParm	array
[	O
2	int
]	O
=	O
pMCVar	pointer
->	O
dParm	array
[	O
3	int
]	O
=	O
0.0	int
;	O
QueueListItem	function
(	O
panal	pointer
->	O
mc	struct
.	O
plistMCVars	pointer
,	O
pMCVar	pointer
)	O
;	O
}	O
else	O
{	O
for	O
(	O
j	int
=	O
iLB	long
;	O
j	int
<	O
iUB	long
;	O
j	int
++	O
)	O
{	O
sprintf	function
(	O
szTmp	array
,	O
"%s_%ld"	pointer
,	O
szLex	pointer
,	O
j	int
)	O
;	O
hvar	long
=	O
GetVarHandle	function
(	O
szTmp	array
)	O
;	O
if	O
(	O
(	O
iErr	int
=	O
(	O
!	O
hvar	long
||	O
IsInput	function
(	O
hvar	long
)	O
)	O
)	O
)	O
break	O
;	O
if	O
(	O
!	O
(	O
pMCVar	pointer
=	O
(	O
PMCVAR	pointer
)	O
malloc	function
(	O
sizeof	O
(	O
MCVAR	struct
)	O
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetSetPointsSpec"	pointer
,	O
NULL	O
)	O
;	O
pMCVar	pointer
->	O
hvar	long
=	O
hvar	long
;	O
pMCVar	pointer
->	O
iType	int
=	O
MCV_SETPOINTS	O
;	O
pMCVar	pointer
->	O
dParm	array
[	O
2	int
]	O
=	O
pMCVar	pointer
->	O
dParm	array
[	O
3	int
]	O
=	O
0.0	int
;	O
QueueListItem	function
(	O
panal	pointer
->	O
mc	struct
.	O
plistMCVars	pointer
,	O
pMCVar	pointer
)	O
;	O
}	O
}	O
}	O
panal	pointer
->	O
mc	struct
.	O
nSetParms	long
=	O
ListLength	O
(	O
panal	pointer
->	O
mc	struct
.	O
plistMCVars	pointer
)	O
;	O
if	O
(	O
panal	pointer
->	O
mc	struct
.	O
nSetParms	long
==	O
0	int
)	O
{	O
iErr	int
=	O
TRUE	int
;	O
printf	function
(	O
"\nError: you must specify a list of parameters to read.\n\n"	pointer
)	O
;	O
goto	O
Exit_GetSetPointsSpec	O
;	O
}	O
if	O
(	O
!	O
iNLI	int
)	O
iErr	int
=	O
(	O
(	O
szTmp	array
[	O
0	int
]	O
!=	O
CH_RPAREN	O
)	O
&&	O
(	O
EGetPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
CH_RPAREN	O
)	O
)	O
)	O
||	O
InitSetPoints	function
(	O
&	O
panal	pointer
->	O
mc	struct
)	O
;	O
else	O
{	O
iErr	int
=	O
TRUE	int
;	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
,	O
"identifier"	pointer
,	O
szLex	pointer
)	O
;	O
}	O
Exit_GetSetPointsSpec	O
:	O
;	O
if	O
(	O
iErr	int
)	O
{	O
printf	function
(	O
"Syntax:\n"	pointer
"%s (\"OutputFile\", \"SetPtsFile\", nRuns, "	pointer
"<param-id-list...>)\n\n"	pointer
,	O
GetKeyword	function
(	O
KM_SETPOINTS	int
)	O
)	O
;	O
printf	function
(	O
"Exiting...\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
else	O
panal	pointer
->	O
iType	int
=	O
AT_SETPOINTS	int
;	O
return	O
(	O
iErr	int
)	O
;	O
}	O
int	O
GetMonteCarloSpec	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PANALYSIS	pointer
panal	pointer
,	O
PSTR	pointer
szLex	pointer
)	O
{	O
static	O
int	O
vrgiMCArgTypes	array
[	O
NMC_ARGS	int
]	O
=	O
{	O
LX_STRING	int
,	O
LX_INTEGER	int
,	O
LX_NUMBER	O
}	O
;	O
int	O
iErr	int
=	O
0	int
;	O
iErr	int
=	O
!	O
GetFuncArgs	function
(	O
pibIn	pointer
,	O
NMC_ARGS	int
,	O
vrgiMCArgTypes	array
,	O
vrgszlexArgs	array
[	O
0	int
]	O
)	O
;	O
if	O
(	O
!	O
iErr	int
)	O
{	O
if	O
(	O
*	O
vrgszlexArgs	array
[	O
0	int
]	O
)	O
{	O
if	O
(	O
!	O
(	O
panal	pointer
->	O
mc	struct
.	O
szMCOutfilename	pointer
=	O
(	O
PSTR	pointer
)	O
malloc	function
(	O
MyStrlen	O
(	O
vrgszlexArgs	array
[	O
0	int
]	O
)	O
+	O
1	int
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetMonteCarloSpec"	pointer
,	O
NULL	O
)	O
;	O
MyStrcpy	O
(	O
panal	pointer
->	O
mc	struct
.	O
szMCOutfilename	pointer
,	O
vrgszlexArgs	array
[	O
0	int
]	O
)	O
;	O
panal	pointer
->	O
bAllocatedFileName	int
=	O
TRUE	int
;	O
}	O
panal	pointer
->	O
mc	struct
.	O
nRuns	long
=	O
atol	function
(	O
vrgszlexArgs	array
[	O
1	int
]	O
)	O
;	O
panal	pointer
->	O
dSeed	double
=	O
atof	function
(	O
vrgszlexArgs	array
[	O
2	int
]	O
)	O
;	O
}	O
else	O
printf	function
(	O
"Syntax: %s (szOutfilename, nRuns, dSeed)\n\n"	pointer
,	O
GetKeyword	function
(	O
KM_MONTECARLO	int
)	O
)	O
;	O
if	O
(	O
!	O
iErr	int
)	O
panal	pointer
->	O
iType	int
=	O
AT_MONTECARLO	int
;	O
return	O
(	O
iErr	int
)	O
;	O
}	O
BOOL	int
GetParmMod	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PSTRLEX	array
szLex	pointer
)	O
{	O
HVAR	long
hvar	long
=	O
GetVarHandle	function
(	O
szLex	pointer
)	O
;	O
PANALYSIS	pointer
panal	pointer
=	O
(	O
PANALYSIS	pointer
)	O
pibIn	pointer
->	O
pInfo	pointer
;	O
PEXPERIMENT	pointer
pexp	pointer
=	O
panal	pointer
->	O
pexpCurrent	pointer
;	O
PSTRLEX	array
szPunct	array
;	O
int	O
iErr	int
;	O
PVARMOD	pointer
pvarmod	pointer
;	O
if	O
(	O
(	O
iErr	int
=	O
!	O
hvar	long
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
,	O
"model-variable"	pointer
,	O
szLex	pointer
)	O
;	O
else	O
{	O
if	O
(	O
!	O
(	O
pvarmod	pointer
=	O
(	O
PVARMOD	pointer
)	O
malloc	function
(	O
sizeof	O
(	O
VARMODIFICATION	struct
)	O
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetParmMod"	pointer
,	O
NULL	O
)	O
;	O
pvarmod	pointer
->	O
hvar	long
=	O
hvar	long
;	O
if	O
(	O
!	O
GetOptPunct	function
(	O
pibIn	pointer
,	O
szPunct	array
,	O
'='	O
)	O
)	O
{	O
iErr	int
=	O
szPunct	array
[	O
1	int
]	O
=	O
'='	O
;	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_EXPECTED	int
,	O
szPunct	array
,	O
NULL	O
)	O
;	O
}	O
else	O
if	O
(	O
IsInput	function
(	O
hvar	long
)	O
)	O
{	O
if	O
(	O
!	O
(	O
pvarmod	pointer
->	O
uvar	union
.	O
pifn	pointer
=	O
(	O
PIFN	pointer
)	O
malloc	function
(	O
sizeof	O
(	O
IFN	struct
)	O
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetParmMod"	pointer
,	O
NULL	O
)	O
;	O
iErr	int
=	O
!	O
pvarmod	pointer
->	O
uvar	union
.	O
pifn	pointer
||	O
!	O
GetInputFn	function
(	O
pibIn	pointer
,	O
NULL	O
,	O
pvarmod	pointer
->	O
uvar	union
.	O
pifn	pointer
)	O
;	O
if	O
(	O
iErr	int
)	O
{	O
free	function
(	O
pvarmod	pointer
->	O
uvar	union
.	O
pifn	pointer
)	O
;	O
pvarmod	pointer
->	O
uvar	union
.	O
pifn	pointer
=	O
NULL	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
(	O
iErr	int
=	O
ENextLex	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
LX_NUMBER	O
)	O
)	O
)	O
pvarmod	pointer
->	O
uvar	union
.	O
dVal	double
=	O
atof	function
(	O
szLex	pointer
)	O
;	O
}	O
if	O
(	O
!	O
iErr	int
)	O
{	O
if	O
(	O
panal	pointer
->	O
iCurrentDepth	int
==	O
0	int
||	O
panal	pointer
->	O
wContext	int
==	O
CN_EXPERIMENT	int
)	O
QueueListItem	function
(	O
pexp	pointer
->	O
plistParmMods	pointer
,	O
pvarmod	pointer
)	O
;	O
else	O
QueueListItem	function
(	O
panal	pointer
->	O
pCurrentLevel	array
[	O
panal	pointer
->	O
iCurrentDepth	int
-	O
1	int
]	O
->	O
plistVars	pointer
,	O
pvarmod	pointer
)	O
;	O
iErr	int
=	O
GetTerminator	function
(	O
pibIn	pointer
,	O
szLex	pointer
)	O
;	O
}	O
else	O
free	function
(	O
pvarmod	pointer
)	O
;	O
}	O
return	O
(	O
(	O
BOOL	int
)	O
iErr	int
)	O
;	O
}	O
BOOL	int
GetParmMod2	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PSTRLEX	array
szLex	pointer
,	O
PSTREQN	array
szEqn	pointer
)	O
{	O
int	O
iErr	int
;	O
PVARMOD	pointer
pvarmod	pointer
;	O
HVAR	long
hvar	long
=	O
GetVarHandle	function
(	O
szLex	pointer
)	O
;	O
PANALYSIS	pointer
panal	pointer
=	O
(	O
PANALYSIS	pointer
)	O
pibIn	pointer
->	O
pInfo	pointer
;	O
PEXPERIMENT	pointer
pexp	pointer
=	O
panal	pointer
->	O
pexpCurrent	pointer
;	O
if	O
(	O
(	O
iErr	int
=	O
!	O
hvar	long
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
,	O
"model-variable"	pointer
,	O
szLex	pointer
)	O
;	O
else	O
{	O
if	O
(	O
!	O
(	O
pvarmod	pointer
=	O
(	O
PVARMOD	pointer
)	O
malloc	function
(	O
sizeof	O
(	O
VARMODIFICATION	struct
)	O
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetParmMod"	pointer
,	O
NULL	O
)	O
;	O
pvarmod	pointer
->	O
hvar	long
=	O
hvar	long
;	O
if	O
(	O
IsInput	function
(	O
hvar	long
)	O
)	O
{	O
if	O
(	O
!	O
(	O
pvarmod	pointer
->	O
uvar	union
.	O
pifn	pointer
=	O
(	O
PIFN	pointer
)	O
malloc	function
(	O
sizeof	O
(	O
IFN	struct
)	O
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetParmMod"	pointer
,	O
NULL	O
)	O
;	O
iErr	int
=	O
!	O
pvarmod	pointer
->	O
uvar	union
.	O
pifn	pointer
||	O
!	O
GetInputFn	function
(	O
pibIn	pointer
,	O
NULL	O
,	O
pvarmod	pointer
->	O
uvar	union
.	O
pifn	pointer
)	O
;	O
if	O
(	O
iErr	int
)	O
{	O
free	function
(	O
pvarmod	pointer
->	O
uvar	union
.	O
pifn	pointer
)	O
;	O
pvarmod	pointer
->	O
uvar	union
.	O
pifn	pointer
=	O
NULL	O
;	O
}	O
}	O
else	O
{	O
pvarmod	pointer
->	O
uvar	union
.	O
dVal	double
=	O
atof	function
(	O
szEqn	pointer
)	O
;	O
}	O
if	O
(	O
!	O
iErr	int
)	O
{	O
if	O
(	O
panal	pointer
->	O
iCurrentDepth	int
==	O
0	int
||	O
panal	pointer
->	O
wContext	int
==	O
CN_EXPERIMENT	int
)	O
QueueListItem	function
(	O
pexp	pointer
->	O
plistParmMods	pointer
,	O
pvarmod	pointer
)	O
;	O
else	O
QueueListItem	function
(	O
panal	pointer
->	O
pCurrentLevel	array
[	O
panal	pointer
->	O
iCurrentDepth	int
-	O
1	int
]	O
->	O
plistVars	pointer
,	O
pvarmod	pointer
)	O
;	O
}	O
else	O
free	function
(	O
pvarmod	pointer
)	O
;	O
}	O
return	O
(	O
(	O
BOOL	int
)	O
iErr	int
)	O
;	O
}	O
void	O
NewExperiment	function
(	O
PINPUTBUF	pointer
pibIn	pointer
)	O
{	O
PANALYSIS	pointer
panal	pointer
=	O
(	O
PANALYSIS	pointer
)	O
pibIn	pointer
->	O
pInfo	pointer
;	O
PLEVEL	pointer
plevel	pointer
;	O
int	O
n	int
;	O
if	O
(	O
panal	pointer
->	O
iCurrentDepth	int
<	O
0	int
)	O
{	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
|	O
RE_FATAL	int
,	O
"Level statement"	pointer
,	O
"Simulation"	pointer
)	O
;	O
}	O
if	O
(	O
panal	pointer
->	O
iCurrentDepth	int
==	O
0	int
)	O
{	O
panal	pointer
->	O
expGlobal	struct
.	O
iExp	int
++	O
;	O
panal	pointer
->	O
pexpCurrent	pointer
=	O
panal	pointer
->	O
rgpExps	array
[	O
panal	pointer
->	O
expGlobal	struct
.	O
iExp	int
-	O
1	int
]	O
=	O
(	O
PEXPERIMENT	pointer
)	O
malloc	function
(	O
sizeof	O
(	O
EXPERIMENT	struct
)	O
)	O
;	O
if	O
(	O
!	O
panal	pointer
->	O
pexpCurrent	pointer
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"NewExperiment()"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
panal	pointer
->	O
rank	int
==	O
0	int
)	O
printf	function
(	O
"Reading experiment %d.\n"	pointer
,	O
panal	pointer
->	O
expGlobal	struct
.	O
iExp	int
)	O
;	O
}	O
else	O
{	O
plevel	pointer
=	O
panal	pointer
->	O
pLevels	array
[	O
panal	pointer
->	O
iInstances	int
-	O
1	int
]	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
panal	pointer
->	O
iCurrentDepth	int
-	O
1	int
;	O
++	O
n	int
)	O
{	O
plevel	pointer
=	O
plevel	pointer
->	O
pLevels	array
[	O
plevel	pointer
->	O
iInstances	int
-	O
1	int
]	O
;	O
}	O
if	O
(	O
plevel	pointer
->	O
iInstances	int
==	O
MAX_INSTANCES	int
-	O
1	int
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_TOOMANYINST	int
|	O
RE_FATAL	int
,	O
"NewExperiment"	pointer
,	O
NULL	O
)	O
;	O
n	int
=	O
panal	pointer
->	O
pCurrentLevel	array
[	O
panal	pointer
->	O
iCurrentDepth	int
-	O
1	int
]	O
->	O
iInstances	int
++	O
;	O
if	O
(	O
!	O
(	O
plevel	pointer
=	O
plevel	pointer
->	O
pLevels	array
[	O
n	int
]	O
=	O
(	O
PLEVEL	pointer
)	O
malloc	function
(	O
sizeof	O
(	O
LEVEL	struct
)	O
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"NewExperiment"	pointer
,	O
NULL	O
)	O
;	O
plevel	pointer
->	O
iInstances	int
=	O
0	int
;	O
plevel	pointer
->	O
iSequence	int
=	O
n	int
+	O
1	int
;	O
plevel	pointer
->	O
iDepth	int
=	O
panal	pointer
->	O
iCurrentDepth	int
;	O
panal	pointer
->	O
pCurrentLevel	array
[	O
panal	pointer
->	O
iCurrentDepth	int
++	O
]	O
=	O
plevel	pointer
;	O
if	O
(	O
panal	pointer
->	O
iDepth	int
<	O
panal	pointer
->	O
iCurrentDepth	int
)	O
panal	pointer
->	O
iDepth	int
=	O
panal	pointer
->	O
iCurrentDepth	int
;	O
plevel	pointer
->	O
nMCVars	long
=	O
plevel	pointer
->	O
nFixedVars	long
=	O
plevel	pointer
->	O
nLikes	long
=	O
0	int
;	O
plevel	pointer
->	O
plistVars	pointer
=	O
InitList	function
(	O
)	O
;	O
plevel	pointer
->	O
plistMCVars	pointer
=	O
InitList	function
(	O
)	O
;	O
plevel	pointer
->	O
plistLikes	pointer
=	O
InitList	function
(	O
)	O
;	O
if	O
(	O
!	O
(	O
plevel	pointer
->	O
pexpt	pointer
=	O
(	O
PEXPERIMENT	pointer
)	O
malloc	function
(	O
sizeof	O
(	O
EXPERIMENT	struct
)	O
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"NewExperiment"	pointer
,	O
NULL	O
)	O
;	O
panal	pointer
->	O
pexpCurrent	pointer
=	O
plevel	pointer
->	O
pexpt	pointer
;	O
panal	pointer
->	O
pexpCurrent	pointer
->	O
iExp	int
=	O
panal	pointer
->	O
expGlobal	struct
.	O
iExp	int
=	O
++	O
panal	pointer
->	O
iExpts	int
;	O
panal	pointer
->	O
wContext	int
=	O
CN_EXPERIMENT	int
;	O
if	O
(	O
panal	pointer
->	O
rank	int
==	O
0	int
)	O
printf	function
(	O
"Simulation %d - depth %d, instance %d\n"	pointer
,	O
panal	pointer
->	O
iExpts	int
,	O
panal	pointer
->	O
iCurrentDepth	int
,	O
panal	pointer
->	O
pCurrentLevel	array
[	O
panal	pointer
->	O
iCurrentDepth	int
-	O
2	int
]	O
->	O
iInstances	int
)	O
;	O
}	O
memcpy	function
(	O
panal	pointer
->	O
pexpCurrent	pointer
,	O
&	O
panal	pointer
->	O
expGlobal	struct
,	O
sizeof	O
(	O
EXPERIMENT	struct
)	O
)	O
;	O
panal	pointer
->	O
wContext	int
=	O
CN_EXPERIMENT	int
;	O
panal	pointer
->	O
pexpCurrent	pointer
->	O
plistParmMods	pointer
=	O
InitList	function
(	O
)	O
;	O
panal	pointer
->	O
pexpCurrent	pointer
->	O
os	struct
.	O
plistPrintRecs	pointer
=	O
InitList	function
(	O
)	O
;	O
panal	pointer
->	O
pexpCurrent	pointer
->	O
os	struct
.	O
plistDataRecs	pointer
=	O
InitList	function
(	O
)	O
;	O
}	O
BOOL	int
EndExperiment	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PANALYSIS	pointer
panal	pointer
)	O
{	O
BOOL	int
bReturn	int
;	O
bReturn	int
=	O
!	O
ErrorsReported	O
(	O
pibIn	pointer
)	O
;	O
if	O
(	O
!	O
bReturn	int
)	O
{	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_ERRORSINEXP	int
|	O
RE_FATAL	int
,	O
(	O
PSTR	pointer
)	O
&	O
panal	pointer
->	O
pexpCurrent	pointer
->	O
iExp	int
,	O
NULL	O
)	O
;	O
ClearErrors	O
(	O
pibIn	pointer
)	O
;	O
panal	pointer
->	O
rgpExps	array
[	O
--	O
panal	pointer
->	O
expGlobal	struct
.	O
iExp	int
]	O
=	O
NULL	O
;	O
free	function
(	O
panal	pointer
->	O
pexpCurrent	pointer
)	O
;	O
}	O
else	O
{	O
PrepareOutSpec	function
(	O
panal	pointer
->	O
pexpCurrent	pointer
)	O
;	O
}	O
panal	pointer
->	O
pexpCurrent	pointer
=	O
&	O
panal	pointer
->	O
expGlobal	struct
;	O
panal	pointer
->	O
wContext	int
=	O
CN_GLOBAL	int
;	O
if	O
(	O
panal	pointer
->	O
iType	int
==	O
AT_MCMC	int
&&	O
panal	pointer
->	O
iCurrentDepth	int
--	O
==	O
0	int
)	O
return	O
FALSE	int
;	O
return	O
(	O
bReturn	int
)	O
;	O
}	O
int	O
SetLevel	function
(	O
PINPUTBUF	pointer
pibIn	pointer
)	O
{	O
PSTRLEX	array
szPunct	array
;	O
PANALYSIS	pointer
panal	pointer
=	O
(	O
PANALYSIS	pointer
)	O
pibIn	pointer
->	O
pInfo	pointer
;	O
PLEVEL	pointer
plevel	pointer
;	O
BYTE	char
n	int
;	O
if	O
(	O
panal	pointer
->	O
iType	int
!=	O
AT_MCMC	int
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_TYPENOTMCMC	int
|	O
RE_FATAL	int
,	O
"SetLevel"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
panal	pointer
->	O
iCurrentDepth	int
==	O
MAX_LEVELS	int
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_TOOMANYLEVELS	int
|	O
RE_FATAL	int
,	O
"SetLevel"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
panal	pointer
->	O
wContext	int
==	O
CN_EXPERIMENT	int
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEVINEXPT	int
|	O
RE_FATAL	int
,	O
"SetLevel"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
EGetPunct	function
(	O
pibIn	pointer
,	O
szPunct	array
,	O
CH_LBRACE	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
panal	pointer
->	O
iCurrentDepth	int
==	O
0	int
)	O
{	O
plevel	pointer
=	O
panal	pointer
->	O
pLevels	array
[	O
panal	pointer
->	O
iInstances	int
++	O
]	O
=	O
(	O
PLEVEL	pointer
)	O
malloc	function
(	O
sizeof	O
(	O
LEVEL	struct
)	O
)	O
;	O
if	O
(	O
plevel	pointer
==	O
NULL	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"SetLevel"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
panal	pointer
->	O
iInstances	int
>	O
1	int
)	O
{	O
printf	function
(	O
"Error: only one top level is allowed - Exiting.\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
plevel	pointer
->	O
iSequence	int
=	O
panal	pointer
->	O
iInstances	int
;	O
if	O
(	O
panal	pointer
->	O
rank	int
==	O
0	int
)	O
printf	function
(	O
"New level - depth 1, instance %d\n"	pointer
,	O
panal	pointer
->	O
iInstances	int
)	O
;	O
}	O
else	O
{	O
plevel	pointer
=	O
panal	pointer
->	O
pLevels	array
[	O
panal	pointer
->	O
iInstances	int
-	O
1	int
]	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
panal	pointer
->	O
iCurrentDepth	int
-	O
1	int
;	O
++	O
n	int
)	O
plevel	pointer
=	O
plevel	pointer
->	O
pLevels	array
[	O
plevel	pointer
->	O
iInstances	int
-	O
1	int
]	O
;	O
if	O
(	O
plevel	pointer
->	O
iInstances	int
==	O
MAX_INSTANCES	int
-	O
1	int
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_TOOMANYINST	int
|	O
RE_FATAL	int
,	O
"SetLevel"	pointer
,	O
NULL	O
)	O
;	O
n	int
=	O
panal	pointer
->	O
pCurrentLevel	array
[	O
panal	pointer
->	O
iCurrentDepth	int
-	O
1	int
]	O
->	O
iInstances	int
++	O
;	O
plevel	pointer
=	O
plevel	pointer
->	O
pLevels	array
[	O
n	int
]	O
=	O
(	O
PLEVEL	pointer
)	O
malloc	function
(	O
sizeof	O
(	O
LEVEL	struct
)	O
)	O
;	O
if	O
(	O
plevel	pointer
==	O
NULL	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"SetLevel"	pointer
,	O
NULL	O
)	O
;	O
plevel	pointer
->	O
iSequence	int
=	O
n	int
+	O
1	int
;	O
if	O
(	O
panal	pointer
->	O
rank	int
==	O
0	int
)	O
printf	function
(	O
"New level - depth %d, instance %d\n"	pointer
,	O
panal	pointer
->	O
iCurrentDepth	int
+	O
1	int
,	O
panal	pointer
->	O
pCurrentLevel	array
[	O
panal	pointer
->	O
iCurrentDepth	int
-	O
1	int
]	O
->	O
iInstances	int
)	O
;	O
}	O
plevel	pointer
->	O
iInstances	int
=	O
0	int
;	O
plevel	pointer
->	O
iDepth	int
=	O
panal	pointer
->	O
iCurrentDepth	int
;	O
panal	pointer
->	O
pCurrentLevel	array
[	O
panal	pointer
->	O
iCurrentDepth	int
++	O
]	O
=	O
plevel	pointer
;	O
if	O
(	O
panal	pointer
->	O
iDepth	int
<	O
panal	pointer
->	O
iCurrentDepth	int
)	O
panal	pointer
->	O
iDepth	int
=	O
panal	pointer
->	O
iCurrentDepth	int
;	O
plevel	pointer
->	O
nMCVars	long
=	O
plevel	pointer
->	O
nFixedVars	long
=	O
plevel	pointer
->	O
nLikes	long
=	O
0	int
;	O
plevel	pointer
->	O
plistVars	pointer
=	O
InitList	function
(	O
)	O
;	O
plevel	pointer
->	O
plistMCVars	pointer
=	O
InitList	function
(	O
)	O
;	O
plevel	pointer
->	O
plistLikes	pointer
=	O
InitList	function
(	O
)	O
;	O
plevel	pointer
->	O
pexpt	pointer
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
BOOL	int
EndLevel	function
(	O
PANALYSIS	pointer
panal	pointer
)	O
{	O
if	O
(	O
panal	pointer
->	O
iCurrentDepth	int
--	O
==	O
0	int
)	O
return	O
FALSE	int
;	O
return	O
TRUE	int
;	O
}	O
void	O
FreeLevels	function
(	O
PANALYSIS	pointer
panal	pointer
)	O
{	O
int	O
n	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
panal	pointer
->	O
iInstances	int
;	O
n	int
++	O
)	O
if	O
(	O
panal	pointer
->	O
pLevels	array
[	O
n	int
]	O
!=	O
NULL	O
)	O
FreeOneLevel	function
(	O
panal	pointer
->	O
pLevels	array
[	O
n	int
]	O
)	O
;	O
if	O
(	O
panal	pointer
->	O
bAllocatedFileName	int
)	O
free	function
(	O
panal	pointer
->	O
gd	struct
.	O
szGout	pointer
)	O
;	O
FreeList	function
(	O
&	O
panal	pointer
->	O
mc	struct
.	O
plistMCVars	pointer
,	O
NULL	O
,	O
TRUE	int
)	O
;	O
FreeList	function
(	O
&	O
panal	pointer
->	O
expGlobal	struct
.	O
plistParmMods	pointer
,	O
NULL	O
,	O
TRUE	int
)	O
;	O
free	function
(	O
panal	pointer
->	O
expGlobal	struct
.	O
is	struct
.	O
iwork	pointer
)	O
;	O
free	function
(	O
panal	pointer
->	O
expGlobal	struct
.	O
is	struct
.	O
rwork	pointer
)	O
;	O
free	function
(	O
panal	pointer
->	O
modelinfo	struct
.	O
pStateHvar	pointer
)	O
;	O
free	function
(	O
panal	pointer
)	O
;	O
}	O
int	O
FreeMCVar	function
(	O
PVOID	pointer
pData	pointer
,	O
PVOID	pointer
pUserInfo	pointer
)	O
{	O
PMCVAR	pointer
pMCVar	pointer
=	O
(	O
PMCVAR	pointer
)	O
pData	pointer
;	O
FreeList	function
(	O
&	O
pMCVar	pointer
->	O
plistDependents	pointer
,	O
NULL	O
,	O
TRUE	int
)	O
;	O
free	function
(	O
pMCVar	pointer
->	O
pszName	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
FreeDataRec	function
(	O
PVOID	pointer
pData	pointer
,	O
PVOID	pointer
pUserInfo	pointer
)	O
{	O
PDATAREC	pointer
pDataRecord	pointer
=	O
(	O
PDATAREC	pointer
)	O
pData	pointer
;	O
free	function
(	O
pDataRecord	pointer
->	O
szDataName	pointer
)	O
;	O
free	function
(	O
pDataRecord	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
FreePrintRec	function
(	O
PVOID	pointer
pData	pointer
,	O
PVOID	pointer
pUserInfo	pointer
)	O
{	O
PPRINTREC	pointer
pPrintRecord	pointer
=	O
(	O
PPRINTREC	pointer
)	O
pData	pointer
;	O
free	function
(	O
pPrintRecord	pointer
->	O
pdTimes	pointer
)	O
;	O
free	function
(	O
pPrintRecord	pointer
->	O
szOutputName	pointer
)	O
;	O
free	function
(	O
pPrintRecord	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
FreeOneLevel	function
(	O
PLEVEL	pointer
plevel	pointer
)	O
{	O
int	O
n	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	pointer
->	O
iInstances	int
;	O
n	int
++	O
)	O
if	O
(	O
plevel	pointer
->	O
pLevels	array
[	O
n	int
]	O
!=	O
NULL	O
)	O
FreeOneLevel	function
(	O
plevel	pointer
->	O
pLevels	array
[	O
n	int
]	O
)	O
;	O
FreeList	function
(	O
&	O
plevel	pointer
->	O
plistVars	pointer
,	O
NULL	O
,	O
TRUE	int
)	O
;	O
ForAllList	function
(	O
plevel	pointer
->	O
plistMCVars	pointer
,	O
&	O
FreeMCVar	function
,	O
NULL	O
)	O
;	O
FreeList	function
(	O
&	O
plevel	pointer
->	O
plistMCVars	pointer
,	O
NULL	O
,	O
TRUE	int
)	O
;	O
ForAllList	function
(	O
plevel	pointer
->	O
plistLikes	pointer
,	O
&	O
FreeMCVar	function
,	O
NULL	O
)	O
;	O
FreeList	function
(	O
&	O
plevel	pointer
->	O
plistLikes	pointer
,	O
NULL	O
,	O
TRUE	int
)	O
;	O
if	O
(	O
plevel	pointer
->	O
pexpt	pointer
!=	O
NULL	O
)	O
{	O
FreeList	function
(	O
&	O
plevel	pointer
->	O
pexpt	pointer
->	O
plistParmMods	pointer
,	O
&	O
FreeVarMod	function
,	O
FALSE	int
)	O
;	O
POUTSPEC	pointer
pos	pointer
=	O
&	O
plevel	pointer
->	O
pexpt	pointer
->	O
os	struct
;	O
free	function
(	O
pos	pointer
->	O
pszOutputNames	pointer
)	O
;	O
free	function
(	O
pos	pointer
->	O
phvar_out	pointer
)	O
;	O
free	function
(	O
pos	pointer
->	O
pcOutputTimes	pointer
)	O
;	O
free	function
(	O
pos	pointer
->	O
piCurrentOut	pointer
)	O
;	O
free	function
(	O
pos	pointer
->	O
prgdOutputTimes	pointer
)	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
pos	pointer
->	O
nOutputs	int
;	O
n	int
++	O
)	O
free	function
(	O
pos	pointer
->	O
prgdOutputVals	pointer
[	O
n	int
]	O
)	O
;	O
free	function
(	O
pos	pointer
->	O
prgdOutputVals	pointer
)	O
;	O
free	function
(	O
pos	pointer
->	O
rgdDistinctTimes	pointer
)	O
;	O
ForAllList	function
(	O
pos	pointer
->	O
plistPrintRecs	pointer
,	O
&	O
FreePrintRec	function
,	O
NULL	O
)	O
;	O
FreeList	function
(	O
&	O
pos	pointer
->	O
plistPrintRecs	pointer
,	O
NULL	O
,	O
FALSE	int
)	O
;	O
free	function
(	O
pos	pointer
->	O
plistPrintRecs	pointer
)	O
;	O
free	function
(	O
pos	pointer
->	O
pcData	pointer
)	O
;	O
free	function
(	O
pos	pointer
->	O
phvar_dat	pointer
)	O
;	O
free	function
(	O
pos	pointer
->	O
pszDataNames	pointer
)	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
pos	pointer
->	O
nData	int
;	O
n	int
++	O
)	O
free	function
(	O
pos	pointer
->	O
prgdDataVals	pointer
[	O
n	int
]	O
)	O
;	O
free	function
(	O
pos	pointer
->	O
prgdDataVals	pointer
)	O
;	O
free	function
(	O
plevel	pointer
->	O
pexpt	pointer
)	O
;	O
}	O
if	O
(	O
plevel	pointer
->	O
nFixedVars	long
>	O
0	int
)	O
free	function
(	O
plevel	pointer
->	O
rgpFixedVars	pointer
)	O
;	O
if	O
(	O
plevel	pointer
->	O
nMCVars	long
>	O
0	int
)	O
free	function
(	O
plevel	pointer
->	O
rgpMCVars	pointer
)	O
;	O
free	function
(	O
plevel	pointer
->	O
rgpLikes	pointer
)	O
;	O
free	function
(	O
plevel	pointer
)	O
;	O
}	O
void	O
ProcessWord	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PSTR	pointer
szLex	pointer
,	O
PSTR	pointer
szEqn	pointer
)	O
{	O
int	O
iErr	int
=	O
0	int
;	O
int	O
iKWCode	int
,	O
fContext	int
;	O
long	O
i	int
,	O
iLB	long
,	O
iUB	long
;	O
PSTREQN	array
szEqnU	pointer
;	O
PSTRLEX	array
szTmp	array
;	O
PANALYSIS	pointer
panal	pointer
;	O
if	O
(	O
!	O
pibIn	pointer
||	O
!	O
szLex	pointer
||	O
!	O
szLex	pointer
[	O
0	int
]	O
||	O
!	O
szEqn	pointer
)	O
return	O
;	O
panal	pointer
=	O
(	O
PANALYSIS	pointer
)	O
pibIn	pointer
->	O
pInfo	pointer
;	O
iKWCode	int
=	O
GetKeywordCode	function
(	O
szLex	pointer
,	O
&	O
fContext	int
)	O
;	O
assert	O
(	O
panal	pointer
->	O
wContext	int
!=	O
CN_END	int
)	O
;	O
if	O
(	O
(	O
iErr	int
=	O
(	O
iKWCode	int
&&	O
!	O
(	O
fContext	int
&	O
panal	pointer
->	O
wContext	int
)	O
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_BADCONTEXT	int
,	O
szLex	pointer
,	O
NULL	O
)	O
;	O
else	O
{	O
switch	O
(	O
iKWCode	int
)	O
{	O
default	O
:	O
iLB	long
=	O
iUB	long
=	O
-	O
1	int
;	O
if	O
(	O
GetPunct	function
(	O
pibIn	pointer
,	O
szTmp	array
,	O
'['	O
)	O
)	O
GetArrayBounds	function
(	O
pibIn	pointer
,	O
&	O
iLB	long
,	O
&	O
iUB	long
)	O
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
szTmp	array
,	O
"="	pointer
)	O
)	O
pibIn	pointer
->	O
pbufCur	pointer
--	O
;	O
if	O
(	O
iUB	long
==	O
-	O
1	int
)	O
{	O
iErr	int
=	O
GetParmMod	function
(	O
pibIn	pointer
,	O
szLex	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
GetPunct	function
(	O
pibIn	pointer
,	O
szTmp	array
,	O
'='	O
)	O
)	O
{	O
GetStatement	function
(	O
pibIn	pointer
,	O
szEqn	pointer
)	O
;	O
for	O
(	O
i	int
=	O
iLB	long
;	O
i	int
<	O
iUB	long
;	O
i	int
++	O
)	O
{	O
sprintf	function
(	O
szTmp	array
,	O
"%s_%ld"	pointer
,	O
szLex	pointer
,	O
i	int
)	O
;	O
UnrollEquation	function
(	O
pibIn	pointer
,	O
i	int
,	O
szEqn	pointer
,	O
szEqnU	pointer
)	O
;	O
iErr	int
=	O
GetParmMod2	function
(	O
pibIn	pointer
,	O
szTmp	array
,	O
szEqnU	pointer
)	O
;	O
if	O
(	O
iErr	int
)	O
break	O
;	O
}	O
}	O
else	O
{	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
|	O
RE_FATAL	int
,	O
"= or ["	pointer
,	O
NULL	O
)	O
;	O
}	O
}	O
break	O
;	O
case	O
KM_PRINT	int
:	O
iErr	int
=	O
GetPrint	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
&	O
panal	pointer
->	O
pexpCurrent	pointer
->	O
os	struct
)	O
;	O
break	O
;	O
case	O
KM_PRINTSTEP	int
:	O
iErr	int
=	O
GetPrintStep	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
&	O
panal	pointer
->	O
pexpCurrent	pointer
->	O
os	struct
)	O
;	O
break	O
;	O
case	O
KM_EXPERIMENT	int
:	O
if	O
(	O
!	O
(	O
iErr	int
=	O
EGetPunct	function
(	O
pibIn	pointer
,	O
szTmp	array
,	O
CH_LBRACE	O
)	O
)	O
)	O
NewExperiment	function
(	O
pibIn	pointer
)	O
;	O
break	O
;	O
case	O
KM_LEVEL	int
:	O
iErr	int
=	O
SetLevel	function
(	O
pibIn	pointer
)	O
;	O
break	O
;	O
case	O
KM_MCVARY	int
:	O
iErr	int
=	O
GetDistribSpec	function
(	O
pibIn	pointer
,	O
panal	pointer
,	O
szLex	pointer
)	O
;	O
break	O
;	O
case	O
KM_OUTPUTFILE	int
:	O
if	O
(	O
panal	pointer
->	O
szOutfilename	pointer
)	O
EatStatement	function
(	O
pibIn	pointer
)	O
;	O
else	O
iErr	int
=	O
GetOutputFile	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
panal	pointer
)	O
;	O
break	O
;	O
case	O
KM_DATA	int
:	O
iErr	int
=	O
GetData	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
&	O
panal	pointer
->	O
pexpCurrent	pointer
->	O
os	struct
)	O
;	O
break	O
;	O
case	O
KM_INTEGRATE	int
:	O
iErr	int
=	O
GetIntegrate	function
(	O
pibIn	pointer
,	O
&	O
panal	pointer
->	O
pexpCurrent	pointer
->	O
is	struct
)	O
;	O
break	O
;	O
case	O
KM_MCMC	int
:	O
iErr	int
=	O
GetMCMCSpec	function
(	O
pibIn	pointer
,	O
panal	pointer
->	O
pexpCurrent	pointer
)	O
;	O
break	O
;	O
case	O
KM_OPTDESIGN	int
:	O
iErr	int
=	O
GetOptDSpec	function
(	O
pibIn	pointer
,	O
panal	pointer
,	O
szLex	pointer
)	O
;	O
break	O
;	O
case	O
KM_MONTECARLO	int
:	O
iErr	int
=	O
GetMonteCarloSpec	function
(	O
pibIn	pointer
,	O
panal	pointer
,	O
szLex	pointer
)	O
;	O
break	O
;	O
case	O
KM_SETPOINTS	int
:	O
iErr	int
=	O
GetSetPointsSpec	function
(	O
pibIn	pointer
,	O
panal	pointer
,	O
szLex	pointer
)	O
;	O
break	O
;	O
case	O
KM_SIMULATE	int
:	O
iErr	int
=	O
GetSimulate	function
(	O
)	O
;	O
break	O
;	O
case	O
KM_STARTTIME	int
:	O
iErr	int
=	O
GetStartTime	function
(	O
pibIn	pointer
,	O
panal	pointer
->	O
pexpCurrent	pointer
)	O
;	O
break	O
;	O
case	O
KM_SIMTYPE	int
:	O
iErr	int
=	O
GetSimType	function
(	O
pibIn	pointer
)	O
;	O
break	O
;	O
case	O
KM_TEMPERATURE	int
:	O
iErr	int
=	O
GetPerks	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
&	O
panal	pointer
->	O
gd	struct
)	O
;	O
break	O
;	O
case	O
KM_END	int
:	O
panal	pointer
->	O
wContext	int
=	O
CN_END	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
iErr	int
)	O
EatStatement	function
(	O
pibIn	pointer
)	O
;	O
}	O
BOOL	int
ReadAnalysis	function
(	O
PINPUTBUF	pointer
pibIn	pointer
)	O
{	O
PSTRLEX	array
szLex	pointer
;	O
PSTREQN	array
szEqn	pointer
;	O
int	O
iLexType	int
;	O
BOOL	int
bReturn	int
=	O
TRUE	int
;	O
PANALYSIS	pointer
panal	pointer
;	O
if	O
(	O
!	O
pibIn	pointer
)	O
return	O
(	O
FALSE	int
)	O
;	O
panal	pointer
=	O
(	O
PANALYSIS	pointer
)	O
pibIn	pointer
->	O
pInfo	pointer
;	O
panal	pointer
->	O
iDepth	int
=	O
panal	pointer
->	O
iCurrentDepth	int
=	O
panal	pointer
->	O
iInstances	int
=	O
0	int
;	O
panal	pointer
->	O
mc	struct
.	O
plistMCVars	pointer
=	O
InitList	function
(	O
)	O
;	O
do	O
{	O
NextLex	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
&	O
iLexType	int
)	O
;	O
switch	O
(	O
iLexType	int
)	O
{	O
case	O
LX_NULL	int
:	O
if	O
(	O
panal	pointer
->	O
wContext	int
!=	O
CN_GLOBAL	int
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_WARNING	int
,	O
NULL	O
,	O
"Unexpected end of file"	pointer
)	O
;	O
if	O
(	O
panal	pointer
->	O
wContext	int
==	O
CN_EXPERIMENT	int
)	O
bReturn	int
&=	O
EndExperiment	function
(	O
pibIn	pointer
,	O
panal	pointer
)	O
;	O
panal	pointer
->	O
wContext	int
=	O
CN_END	int
;	O
break	O
;	O
case	O
LX_IDENTIFIER	int
:	O
ProcessWord	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
szEqn	pointer
)	O
;	O
break	O
;	O
case	O
LX_PUNCT	int
:	O
if	O
(	O
szLex	pointer
[	O
0	int
]	O
==	O
CH_STMTTERM	O
)	O
break	O
;	O
else	O
if	O
(	O
szLex	pointer
[	O
0	int
]	O
==	O
CH_RBRACE	O
)	O
{	O
if	O
(	O
panal	pointer
->	O
wContext	int
&	O
CN_EXPERIMENT	int
)	O
{	O
bReturn	int
&=	O
EndExperiment	function
(	O
pibIn	pointer
,	O
panal	pointer
)	O
;	O
break	O
;	O
}	O
else	O
{	O
bReturn	int
&=	O
EndLevel	function
(	O
panal	pointer
)	O
;	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
szLex	pointer
[	O
0	int
]	O
==	O
CH_COMMENT	O
)	O
{	O
SkipComment	function
(	O
pibIn	pointer
)	O
;	O
break	O
;	O
}	O
default	O
:	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_UNEXPECTED	int
,	O
szLex	pointer
,	O
"* Ignoring"	pointer
)	O
;	O
break	O
;	O
case	O
LX_INTEGER	int
:	O
case	O
LX_FLOAT	int
:	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_UNEXPNUMBER	int
,	O
szLex	pointer
,	O
"* Ignoring"	pointer
)	O
;	O
break	O
;	O
}	O
}	O
while	O
(	O
panal	pointer
->	O
wContext	int
!=	O
CN_END	int
&&	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
||	O
FillBuffer	function
(	O
pibIn	pointer
)	O
!=	O
EOF	O
)	O
)	O
;	O
if	O
(	O
panal	pointer
->	O
iCurrentDepth	int
!=	O
0	int
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OPENLEVEL	int
|	O
RE_FATAL	int
,	O
"ReadAnalysis"	pointer
,	O
NULL	O
)	O
;	O
return	O
(	O
bReturn	int
)	O
;	O
}	O
