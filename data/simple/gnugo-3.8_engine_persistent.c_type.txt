struct	O
persistent_cache_entry	struct
{	O
int	O
boardsize	int
;	O
int	O
movenum	int
;	O
Intersection	char
board	pointer
[	O
BOARDMAX	O
]	O
;	O
int	O
stack	array
[	O
MAX_CACHE_DEPTH	int
]	O
;	O
int	O
move_color	array
[	O
MAX_CACHE_DEPTH	int
]	O
;	O
enum	O
routine_id	enum
routine	enum
;	O
int	O
apos	int
;	O
int	O
bpos	int
;	O
int	O
cpos	int
;	O
int	O
color	int
;	O
Hash_data	struct
goal_hash	pointer
;	O
int	O
result	int
;	O
int	O
result2	int
;	O
int	O
result_certain	int
;	O
int	O
remaining_depth	int
;	O
int	O
node_limit	int
;	O
int	O
move	pointer
;	O
int	O
move2	pointer
;	O
int	O
cost	int
;	O
int	O
score	float
;	O
}	O
;	O
typedef	O
void	O
(	O
*	O
compute_active_area_fn	pointer
)	O
(	O
struct	O
persistent_cache_entry	struct
*	O
entry	pointer
,	O
const	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
,	O
int	O
goal_color	int
)	O
;	O
struct	O
persistent_cache	struct
{	O
const	O
int	O
max_size	int
;	O
const	O
int	O
max_stackp	int
;	O
const	O
float	O
age_factor	float
;	O
const	O
char	O
*	O
name	short
;	O
const	O
compute_active_area_fn	pointer
compute_active_area	pointer
;	O
struct	O
persistent_cache_entry	struct
*	O
table	pointer
;	O
int	O
current_size	int
;	O
int	O
last_purge_position_number	int
;	O
}	O
;	O
static	O
void	O
compute_active_owl_area	function
(	O
struct	O
persistent_cache_entry	struct
*	O
entry	pointer
,	O
const	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
,	O
int	O
goal_color	int
)	O
;	O
static	O
void	O
compute_active_semeai_area	function
(	O
struct	O
persistent_cache_entry	struct
*	O
entry	pointer
,	O
const	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
,	O
int	O
dummy	int
)	O
;	O
static	O
void	O
compute_active_reading_area	function
(	O
struct	O
persistent_cache_entry	struct
*	O
entry	pointer
,	O
const	O
signed	O
char	O
reading_shadow	array
[	O
BOARDMAX	O
]	O
,	O
int	O
dummy	int
)	O
;	O
static	O
void	O
compute_active_connection_area	function
(	O
struct	O
persistent_cache_entry	struct
*	O
entry	pointer
,	O
const	O
signed	O
char	O
connection_shadow	array
[	O
BOARDMAX	O
]	O
,	O
int	O
goal_color	int
)	O
;	O
static	O
void	O
compute_active_breakin_area	function
(	O
struct	O
persistent_cache_entry	struct
*	O
entry	pointer
,	O
const	O
signed	O
char	O
breakin_shadow	array
[	O
BOARDMAX	O
]	O
,	O
int	O
dummy	int
)	O
;	O
static	O
struct	O
persistent_cache	struct
reading_cache	struct
=	O
{	O
MAX_READING_CACHE_SIZE	int
,	O
MAX_READING_CACHE_DEPTH	int
,	O
1.0	int
,	O
"reading cache"	pointer
,	O
compute_active_reading_area	function
,	O
NULL	O
,	O
0	int
,	O
-	O
1	int
}	O
;	O
static	O
struct	O
persistent_cache	struct
connection_cache	struct
=	O
{	O
MAX_CONNECTION_CACHE_SIZE	int
,	O
MAX_CONNECTION_CACHE_DEPTH	int
,	O
1.0	int
,	O
"connection cache"	pointer
,	O
compute_active_connection_area	function
,	O
NULL	O
,	O
0	int
,	O
-	O
1	int
}	O
;	O
static	O
struct	O
persistent_cache	struct
breakin_cache	struct
=	O
{	O
MAX_BREAKIN_CACHE_SIZE	int
,	O
MAX_BREAKIN_CACHE_DEPTH	int
,	O
0.75	int
,	O
"breakin cache"	pointer
,	O
compute_active_breakin_area	function
,	O
NULL	O
,	O
0	int
,	O
-	O
1	int
}	O
;	O
static	O
struct	O
persistent_cache	struct
owl_cache	struct
=	O
{	O
MAX_OWL_CACHE_SIZE	int
,	O
MAX_OWL_CACHE_DEPTH	int
,	O
1.0	int
,	O
"owl cache"	pointer
,	O
compute_active_owl_area	function
,	O
NULL	O
,	O
0	int
,	O
-	O
1	int
}	O
;	O
static	O
struct	O
persistent_cache	struct
semeai_cache	struct
=	O
{	O
MAX_SEMEAI_CACHE_SIZE	int
,	O
MAX_SEMEAI_CACHE_DEPTH	int
,	O
0.75	int
,	O
"semeai cache"	pointer
,	O
compute_active_semeai_area	function
,	O
NULL	O
,	O
0	int
,	O
-	O
1	int
}	O
;	O
static	O
void	O
draw_active_area	function
(	O
Intersection	char
board	pointer
[	O
BOARDMAX	O
]	O
,	O
int	O
apos	int
)	O
{	O
int	O
i	int
,	O
j	int
,	O
ii	int
;	O
int	O
c	char
=	O
' '	O
;	O
int	O
cw	int
=	O
(	O
apos	int
==	O
NO_MOVE	O
)	O
?	O
'O'	O
:	O
'o'	O
;	O
int	O
cb	int
=	O
(	O
apos	int
==	O
NO_MOVE	O
)	O
?	O
'X'	O
:	O
'x'	O
;	O
start_draw_board	function
(	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
board_size	int
;	O
i	int
++	O
)	O
{	O
ii	int
=	O
board_size	int
-	O
i	int
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n%2d"	pointer
,	O
ii	int
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
board_size	int
;	O
j	int
++	O
)	O
{	O
int	O
pos	int
=	O
POS	O
(	O
i	int
,	O
j	int
)	O
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
c	char
=	O
'.'	O
;	O
else	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
WHITE	int
)	O
c	char
=	O
cw	int
;	O
else	O
if	O
(	O
(	O
board	pointer
[	O
pos	int
]	O
&	O
3	int
)	O
==	O
WHITE	int
)	O
c	char
=	O
'O'	O
;	O
else	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
BLACK	int
)	O
c	char
=	O
cb	int
;	O
else	O
if	O
(	O
(	O
board	pointer
[	O
pos	int
]	O
&	O
3	int
)	O
==	O
BLACK	int
)	O
c	char
=	O
'X'	O
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
GRAY	int
)	O
c	char
=	O
'?'	O
;	O
if	O
(	O
pos	int
==	O
apos	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"[%c"	pointer
,	O
c	char
)	O
;	O
else	O
if	O
(	O
j	int
>	O
0	int
&&	O
POS	O
(	O
i	int
,	O
j	int
-	O
1	int
)	O
==	O
apos	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"]%c"	pointer
,	O
c	char
)	O
;	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
" %c"	pointer
,	O
c	char
)	O
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
" %d"	pointer
,	O
ii	int
)	O
;	O
}	O
end_draw_board	function
(	O
)	O
;	O
}	O
static	O
int	O
verify_stored_board	function
(	O
Intersection	char
p	array
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
pos	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
else	O
if	O
(	O
p	array
[	O
pos	int
]	O
==	O
GRAY	int
)	O
continue	O
;	O
else	O
if	O
(	O
(	O
p	array
[	O
pos	int
]	O
&	O
3	int
)	O
!=	O
board	pointer
[	O
pos	int
]	O
)	O
return	O
0	int
;	O
else	O
if	O
(	O
!	O
(	O
p	array
[	O
pos	int
]	O
&	O
(	O
HIGH_LIBERTY_BIT	int
|	O
HIGH_LIBERTY_BIT2	int
)	O
)	O
)	O
continue	O
;	O
else	O
if	O
(	O
(	O
(	O
p	array
[	O
pos	int
]	O
&	O
HIGH_LIBERTY_BIT	int
)	O
&&	O
countlib	function
(	O
pos	int
)	O
<=	O
4	int
)	O
||	O
(	O
p	array
[	O
pos	int
]	O
&	O
HIGH_LIBERTY_BIT2	int
&&	O
countlib	function
(	O
pos	int
)	O
<=	O
3	int
)	O
)	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
void	O
print_persistent_cache_entry	function
(	O
struct	O
persistent_cache_entry	struct
*	O
entry	pointer
)	O
{	O
int	O
r	int
;	O
gprintf	function
(	O
"%omovenum         = %d\n"	pointer
,	O
entry	pointer
->	O
movenum	int
)	O
;	O
gprintf	function
(	O
"%oscore	     = %d\n"	pointer
,	O
entry	pointer
->	O
score	float
)	O
;	O
gprintf	function
(	O
"%ocost	     = %d\n"	pointer
,	O
entry	pointer
->	O
cost	int
)	O
;	O
gprintf	function
(	O
"%oroutine         = %s\n"	pointer
,	O
routine_id_to_string	function
(	O
entry	pointer
->	O
routine	enum
)	O
)	O
;	O
gprintf	function
(	O
"%oapos            = %1m\n"	pointer
,	O
entry	pointer
->	O
apos	int
)	O
;	O
if	O
(	O
entry	pointer
->	O
bpos	int
!=	O
NO_MOVE	O
)	O
gprintf	function
(	O
"%obpos          = %1m\n"	pointer
,	O
entry	pointer
->	O
bpos	int
)	O
;	O
if	O
(	O
entry	pointer
->	O
cpos	int
!=	O
NO_MOVE	O
)	O
gprintf	function
(	O
"%ocpos            = %1m\n"	pointer
,	O
entry	pointer
->	O
cpos	int
)	O
;	O
gprintf	function
(	O
"%oresult          = %s\n"	pointer
,	O
result_to_string	function
(	O
entry	pointer
->	O
result	int
)	O
)	O
;	O
if	O
(	O
entry	pointer
->	O
result2	int
!=	O
0	int
)	O
gprintf	function
(	O
"%oresult2         = %s\n"	pointer
,	O
result_to_string	function
(	O
entry	pointer
->	O
result2	int
)	O
)	O
;	O
if	O
(	O
entry	pointer
->	O
result_certain	int
!=	O
-	O
1	int
)	O
gprintf	function
(	O
"%oresult_certain  = %d\n"	pointer
,	O
entry	pointer
->	O
result_certain	int
)	O
;	O
if	O
(	O
entry	pointer
->	O
node_limit	int
!=	O
-	O
1	int
)	O
gprintf	function
(	O
"%onode_limit      = %d\n"	pointer
,	O
entry	pointer
->	O
node_limit	int
)	O
;	O
if	O
(	O
entry	pointer
->	O
move	pointer
!=	O
NO_MOVE	O
)	O
gprintf	function
(	O
"%omove            = %1m\n"	pointer
,	O
entry	pointer
->	O
move	pointer
)	O
;	O
if	O
(	O
entry	pointer
->	O
move2	pointer
!=	O
NO_MOVE	O
)	O
gprintf	function
(	O
"%omove2           = %1m\n"	pointer
,	O
entry	pointer
->	O
move2	pointer
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
MAX_CACHE_DEPTH	int
;	O
r	int
++	O
)	O
{	O
if	O
(	O
entry	pointer
->	O
stack	array
[	O
r	int
]	O
==	O
0	int
)	O
break	O
;	O
gprintf	function
(	O
"%ostack[%d]      = %C %1m\n"	pointer
,	O
r	int
,	O
entry	pointer
->	O
move_color	array
[	O
r	int
]	O
,	O
entry	pointer
->	O
stack	array
[	O
r	int
]	O
)	O
;	O
}	O
draw_active_area	function
(	O
entry	pointer
->	O
board	pointer
,	O
entry	pointer
->	O
apos	int
)	O
;	O
}	O
void	O
print_persistent_cache	function
(	O
struct	O
persistent_cache	struct
*	O
cache	pointer
)	O
;	O
void	O
print_persistent_cache	function
(	O
struct	O
persistent_cache	struct
*	O
cache	pointer
)	O
{	O
int	O
k	int
;	O
gprintf	function
(	O
"Entire content of %s:\n"	pointer
,	O
cache	pointer
->	O
name	short
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
cache	pointer
->	O
current_size	int
;	O
k	int
++	O
)	O
print_persistent_cache_entry	function
(	O
cache	pointer
->	O
table	pointer
+	O
k	int
)	O
;	O
}	O
static	O
void	O
purge_persistent_cache	function
(	O
struct	O
persistent_cache	struct
*	O
cache	pointer
)	O
{	O
int	O
k	int
;	O
int	O
r	int
;	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
if	O
(	O
cache	pointer
->	O
last_purge_position_number	int
==	O
position_number	int
)	O
return	O
;	O
else	O
cache	pointer
->	O
last_purge_position_number	int
=	O
position_number	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
cache	pointer
->	O
current_size	int
;	O
k	int
++	O
)	O
{	O
int	O
played_moves	int
=	O
0	int
;	O
int	O
entry_ok	int
=	O
1	int
;	O
struct	O
persistent_cache_entry	struct
*	O
entry	pointer
=	O
&	O
(	O
cache	pointer
->	O
table	pointer
[	O
k	int
]	O
)	O
;	O
if	O
(	O
entry	pointer
->	O
boardsize	int
!=	O
board_size	int
)	O
entry_ok	int
=	O
0	int
;	O
else	O
{	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
MAX_CACHE_DEPTH	int
;	O
r	int
++	O
)	O
{	O
int	O
apos	int
=	O
entry	pointer
->	O
stack	array
[	O
r	int
]	O
;	O
int	O
color	int
=	O
entry	pointer
->	O
move_color	array
[	O
r	int
]	O
;	O
if	O
(	O
apos	int
==	O
0	int
)	O
break	O
;	O
if	O
(	O
board	pointer
[	O
apos	int
]	O
==	O
EMPTY	int
&&	O
trymove	function
(	O
apos	int
,	O
color	int
,	O
"purge_persistent_cache"	pointer
,	O
0	int
)	O
)	O
played_moves	int
++	O
;	O
else	O
{	O
entry_ok	int
=	O
0	int
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
entry_ok	int
||	O
!	O
verify_stored_board	function
(	O
entry	pointer
->	O
board	pointer
)	O
)	O
{	O
if	O
(	O
0	int
)	O
gprintf	function
(	O
"Purging entry %d from cache.\n"	pointer
,	O
k	int
)	O
;	O
if	O
(	O
k	int
<	O
cache	pointer
->	O
current_size	int
-	O
1	int
)	O
*	O
entry	pointer
=	O
cache	pointer
->	O
table	pointer
[	O
cache	pointer
->	O
current_size	int
-	O
1	int
]	O
;	O
k	int
--	O
;	O
cache	pointer
->	O
current_size	int
--	O
;	O
}	O
else	O
{	O
entry	pointer
->	O
score	float
*=	O
cache	pointer
->	O
age_factor	float
;	O
}	O
while	O
(	O
played_moves	int
>	O
0	int
)	O
{	O
popgo	function
(	O
)	O
;	O
played_moves	int
--	O
;	O
}	O
}	O
}	O
static	O
struct	O
persistent_cache_entry	struct
*	O
find_persistent_cache_entry	function
(	O
struct	O
persistent_cache	struct
*	O
cache	pointer
,	O
enum	O
routine_id	enum
routine	enum
,	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
int	O
cpos	int
,	O
int	O
color	int
,	O
Hash_data	struct
*	O
goal_hash	pointer
,	O
int	O
node_limit	int
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
cache	pointer
->	O
current_size	int
;	O
k	int
++	O
)	O
{	O
struct	O
persistent_cache_entry	struct
*	O
entry	pointer
=	O
cache	pointer
->	O
table	pointer
+	O
k	int
;	O
if	O
(	O
entry	pointer
->	O
routine	enum
==	O
routine	enum
&&	O
entry	pointer
->	O
apos	int
==	O
apos	int
&&	O
entry	pointer
->	O
bpos	int
==	O
bpos	int
&&	O
entry	pointer
->	O
cpos	int
==	O
cpos	int
&&	O
entry	pointer
->	O
color	int
==	O
color	int
&&	O
depth	int
-	O
stackp	int
<=	O
entry	pointer
->	O
remaining_depth	int
&&	O
(	O
entry	pointer
->	O
node_limit	int
>=	O
node_limit	int
||	O
entry	pointer
->	O
result_certain	int
)	O
&&	O
(	O
goal_hash	pointer
==	O
NULL	O
||	O
hashdata_is_equal	O
(	O
entry	pointer
->	O
goal_hash	pointer
,	O
*	O
goal_hash	pointer
)	O
)	O
&&	O
verify_stored_board	function
(	O
entry	pointer
->	O
board	pointer
)	O
)	O
return	O
entry	pointer
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
int	O
search_persistent_cache	function
(	O
struct	O
persistent_cache	struct
*	O
cache	pointer
,	O
enum	O
routine_id	enum
routine	enum
,	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
int	O
cpos	int
,	O
int	O
color	int
,	O
Hash_data	struct
*	O
goal_hash	pointer
,	O
int	O
node_limit	int
,	O
int	O
*	O
result	int
,	O
int	O
*	O
result2	int
,	O
int	O
*	O
move	pointer
,	O
int	O
*	O
move2	pointer
,	O
int	O
*	O
certain	pointer
)	O
{	O
struct	O
persistent_cache_entry	struct
*	O
entry	pointer
;	O
entry	pointer
=	O
find_persistent_cache_entry	function
(	O
cache	pointer
,	O
routine	enum
,	O
apos	int
,	O
bpos	int
,	O
cpos	int
,	O
color	int
,	O
goal_hash	pointer
,	O
node_limit	int
)	O
;	O
if	O
(	O
entry	pointer
==	O
NULL	O
)	O
return	O
0	int
;	O
*	O
result	int
=	O
entry	pointer
->	O
result	int
;	O
if	O
(	O
result2	int
)	O
*	O
result2	int
=	O
entry	pointer
->	O
result2	int
;	O
if	O
(	O
move	pointer
)	O
*	O
move	pointer
=	O
entry	pointer
->	O
move	pointer
;	O
if	O
(	O
move2	pointer
)	O
*	O
move2	pointer
=	O
entry	pointer
->	O
move2	pointer
;	O
if	O
(	O
certain	pointer
)	O
*	O
certain	pointer
=	O
entry	pointer
->	O
result_certain	int
;	O
entry	pointer
->	O
score	float
+=	O
entry	pointer
->	O
cost	int
;	O
if	O
(	O
debug	int
&	O
DEBUG_PERSISTENT_CACHE	int
)	O
{	O
gprintf	function
(	O
"%oRetrieved position from %s:\n"	pointer
,	O
cache	pointer
->	O
name	short
)	O
;	O
print_persistent_cache_entry	function
(	O
entry	pointer
)	O
;	O
}	O
if	O
(	O
strcmp	function
(	O
cache	pointer
->	O
name	short
,	O
"reading cache"	pointer
)	O
==	O
0	int
&&	O
(	O
debug	int
&	O
DEBUG_READING_PERFORMANCE	int
)	O
&&	O
entry	pointer
->	O
cost	int
>=	O
MIN_READING_NODES_TO_REPORT	int
)	O
{	O
if	O
(	O
entry	pointer
->	O
result	int
!=	O
0	int
)	O
gprintf	function
(	O
"%o%s %1m = %d %1m, cached (%d nodes) "	pointer
,	O
routine	enum
==	O
ATTACK	int
?	O
"attack"	pointer
:	O
"defend"	pointer
,	O
apos	int
,	O
entry	pointer
->	O
result	int
,	O
entry	pointer
->	O
move	pointer
,	O
entry	pointer
->	O
cost	int
)	O
;	O
else	O
gprintf	function
(	O
"%o%s %1m = %d, cached (%d nodes) "	pointer
,	O
routine	enum
==	O
ATTACK	int
?	O
"attack"	pointer
:	O
"defend"	pointer
,	O
apos	int
,	O
entry	pointer
->	O
result	int
,	O
entry	pointer
->	O
cost	int
)	O
;	O
dump_stack	function
(	O
)	O
;	O
}	O
return	O
1	int
;	O
}	O
static	O
void	O
store_persistent_cache	function
(	O
struct	O
persistent_cache	struct
*	O
cache	pointer
,	O
enum	O
routine_id	enum
routine	enum
,	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
int	O
cpos	int
,	O
int	O
color	int
,	O
Hash_data	struct
*	O
goal_hash	pointer
,	O
int	O
result	int
,	O
int	O
result2	int
,	O
int	O
move	pointer
,	O
int	O
move2	pointer
,	O
int	O
certain	pointer
,	O
int	O
node_limit	int
,	O
int	O
cost	int
,	O
const	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
,	O
int	O
goal_color	int
)	O
{	O
int	O
r	int
;	O
struct	O
persistent_cache_entry	struct
*	O
entry	pointer
;	O
if	O
(	O
stackp	int
>	O
cache	pointer
->	O
max_stackp	int
)	O
return	O
;	O
if	O
(	O
cache	pointer
->	O
current_size	int
==	O
cache	pointer
->	O
max_size	int
)	O
{	O
int	O
worst_entry	int
=	O
-	O
1	int
;	O
int	O
worst_score	int
=	O
cost	int
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
cache	pointer
->	O
current_size	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
cache	pointer
->	O
table	pointer
[	O
k	int
]	O
.	O
score	float
<	O
worst_score	int
)	O
{	O
worst_score	int
=	O
cache	pointer
->	O
table	pointer
[	O
k	int
]	O
.	O
score	float
;	O
worst_entry	int
=	O
k	int
;	O
}	O
}	O
if	O
(	O
worst_entry	int
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
worst_entry	int
<	O
cache	pointer
->	O
current_size	int
-	O
1	int
)	O
cache	pointer
->	O
table	pointer
[	O
worst_entry	int
]	O
=	O
cache	pointer
->	O
table	pointer
[	O
cache	pointer
->	O
current_size	int
-	O
1	int
]	O
;	O
cache	pointer
->	O
current_size	int
--	O
;	O
}	O
else	O
return	O
;	O
}	O
entry	pointer
=	O
&	O
(	O
cache	pointer
->	O
table	pointer
[	O
cache	pointer
->	O
current_size	int
]	O
)	O
;	O
entry	pointer
->	O
boardsize	int
=	O
board_size	int
;	O
entry	pointer
->	O
routine	enum
=	O
routine	enum
;	O
entry	pointer
->	O
apos	int
=	O
apos	int
;	O
entry	pointer
->	O
bpos	int
=	O
bpos	int
;	O
entry	pointer
->	O
cpos	int
=	O
cpos	int
;	O
entry	pointer
->	O
color	int
=	O
color	int
;	O
if	O
(	O
goal_hash	pointer
)	O
entry	pointer
->	O
goal_hash	pointer
=	O
*	O
goal_hash	pointer
;	O
entry	pointer
->	O
result	int
=	O
result	int
;	O
entry	pointer
->	O
result2	int
=	O
result2	int
;	O
entry	pointer
->	O
result_certain	int
=	O
certain	pointer
;	O
entry	pointer
->	O
node_limit	int
=	O
node_limit	int
;	O
entry	pointer
->	O
remaining_depth	int
=	O
depth	int
-	O
stackp	int
;	O
entry	pointer
->	O
move	pointer
=	O
move	pointer
;	O
entry	pointer
->	O
move2	pointer
=	O
move2	pointer
;	O
entry	pointer
->	O
score	float
=	O
cost	int
;	O
entry	pointer
->	O
cost	int
=	O
cost	int
;	O
entry	pointer
->	O
movenum	int
=	O
movenum	int
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
MAX_CACHE_DEPTH	int
;	O
r	int
++	O
)	O
{	O
if	O
(	O
r	int
<	O
stackp	int
)	O
get_move_from_stack	function
(	O
r	int
,	O
&	O
(	O
entry	pointer
->	O
stack	array
[	O
r	int
]	O
)	O
,	O
&	O
(	O
entry	pointer
->	O
move_color	array
[	O
r	int
]	O
)	O
)	O
;	O
else	O
{	O
entry	pointer
->	O
stack	array
[	O
r	int
]	O
=	O
0	int
;	O
entry	pointer
->	O
move_color	array
[	O
r	int
]	O
=	O
EMPTY	int
;	O
}	O
}	O
cache	pointer
->	O
compute_active_area	pointer
(	O
&	O
(	O
cache	pointer
->	O
table	pointer
[	O
cache	pointer
->	O
current_size	int
]	O
)	O
,	O
goal	pointer
,	O
goal_color	int
)	O
;	O
cache	pointer
->	O
current_size	int
++	O
;	O
if	O
(	O
debug	int
&	O
DEBUG_PERSISTENT_CACHE	int
)	O
{	O
gprintf	function
(	O
"%oEntered position in %s:\n"	pointer
,	O
cache	pointer
->	O
name	short
)	O
;	O
print_persistent_cache_entry	function
(	O
entry	pointer
)	O
;	O
gprintf	function
(	O
"%oCurrent size: %d\n"	pointer
,	O
cache	pointer
->	O
current_size	int
)	O
;	O
}	O
}	O
static	O
void	O
init_cache	function
(	O
struct	O
persistent_cache	struct
*	O
cache	pointer
)	O
{	O
cache	pointer
->	O
table	pointer
=	O
malloc	function
(	O
cache	pointer
->	O
max_size	int
*	O
sizeof	O
(	O
struct	O
persistent_cache_entry	struct
)	O
)	O
;	O
gg_assert	O
(	O
cache	pointer
->	O
table	pointer
)	O
;	O
}	O
void	O
persistent_cache_init	function
(	O
)	O
{	O
init_cache	function
(	O
&	O
reading_cache	struct
)	O
;	O
init_cache	function
(	O
&	O
breakin_cache	struct
)	O
;	O
init_cache	function
(	O
&	O
connection_cache	struct
)	O
;	O
init_cache	function
(	O
&	O
owl_cache	struct
)	O
;	O
init_cache	function
(	O
&	O
semeai_cache	struct
)	O
;	O
}	O
void	O
clear_persistent_caches	function
(	O
)	O
{	O
reading_cache	struct
.	O
current_size	int
=	O
0	int
;	O
connection_cache	struct
.	O
current_size	int
=	O
0	int
;	O
breakin_cache	struct
.	O
current_size	int
=	O
0	int
;	O
owl_cache	struct
.	O
current_size	int
=	O
0	int
;	O
semeai_cache	struct
.	O
current_size	int
=	O
0	int
;	O
}	O
void	O
purge_persistent_caches	function
(	O
)	O
{	O
purge_persistent_cache	function
(	O
&	O
reading_cache	struct
)	O
;	O
purge_persistent_cache	function
(	O
&	O
connection_cache	struct
)	O
;	O
purge_persistent_cache	function
(	O
&	O
breakin_cache	struct
)	O
;	O
purge_persistent_cache	function
(	O
&	O
owl_cache	struct
)	O
;	O
purge_persistent_cache	function
(	O
&	O
semeai_cache	struct
)	O
;	O
}	O
int	O
search_persistent_reading_cache	function
(	O
enum	O
routine_id	enum
routine	enum
,	O
int	O
str	int
,	O
int	O
*	O
result	int
,	O
int	O
*	O
move	pointer
)	O
{	O
return	O
search_persistent_cache	function
(	O
&	O
reading_cache	struct
,	O
routine	enum
,	O
str	int
,	O
NO_MOVE	O
,	O
NO_MOVE	O
,	O
EMPTY	int
,	O
NULL	O
,	O
-	O
1	int
,	O
result	int
,	O
NULL	O
,	O
move	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
void	O
store_persistent_reading_cache	function
(	O
enum	O
routine_id	enum
routine	enum
,	O
int	O
str	int
,	O
int	O
result	int
,	O
int	O
move	pointer
,	O
int	O
nodes	int
)	O
{	O
store_persistent_cache	function
(	O
&	O
reading_cache	struct
,	O
routine	enum
,	O
str	int
,	O
NO_MOVE	O
,	O
NO_MOVE	O
,	O
EMPTY	int
,	O
NULL	O
,	O
result	int
,	O
NO_MOVE	O
,	O
move	pointer
,	O
NO_MOVE	O
,	O
-	O
1	int
,	O
-	O
1	int
,	O
nodes	int
,	O
shadow	array
,	O
EMPTY	int
)	O
;	O
}	O
static	O
void	O
compute_active_reading_area	function
(	O
struct	O
persistent_cache_entry	struct
*	O
entry	pointer
,	O
const	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
,	O
int	O
dummy	int
)	O
{	O
signed	O
char	O
active	array
[	O
BOARDMAX	O
]	O
;	O
int	O
pos	int
,	O
r	int
;	O
UNUSED	O
(	O
dummy	int
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
active	array
[	O
pos	int
]	O
=	O
goal	pointer
[	O
pos	int
]	O
;	O
mark_string	function
(	O
entry	pointer
->	O
apos	int
,	O
active	array
,	O
1	int
)	O
;	O
if	O
(	O
entry	pointer
->	O
result	int
!=	O
0	int
&&	O
entry	pointer
->	O
move	pointer
!=	O
0	int
)	O
active	array
[	O
entry	pointer
->	O
move	pointer
]	O
=	O
1	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
if	O
(	O
active	array
[	O
pos	int
]	O
!=	O
0	int
)	O
continue	O
;	O
if	O
(	O
(	O
ON_BOARD	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
&&	O
active	array
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
==	O
1	int
)	O
||	O
(	O
ON_BOARD	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
&&	O
active	array
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
1	int
)	O
||	O
(	O
ON_BOARD	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
&&	O
active	array
[	O
NORTH	O
(	O
pos	int
)	O
]	O
==	O
1	int
)	O
||	O
(	O
ON_BOARD	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
&&	O
active	array
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
1	int
)	O
)	O
{	O
if	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
pos	int
]	O
)	O
)	O
mark_string	function
(	O
pos	int
,	O
active	array
,	O
2	int
)	O
;	O
else	O
active	array
[	O
pos	int
]	O
=	O
2	int
;	O
}	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
if	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
pos	int
]	O
)	O
&&	O
worm	array
[	O
pos	int
]	O
.	O
invincible	int
)	O
active	array
[	O
pos	int
]	O
=	O
0	int
;	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
pos	int
]	O
)	O
||	O
active	array
[	O
pos	int
]	O
!=	O
0	int
)	O
continue	O
;	O
if	O
(	O
(	O
board	pointer
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
==	O
EMPTY	int
&&	O
active	array
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
==	O
2	int
)	O
||	O
(	O
board	pointer
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
EMPTY	int
&&	O
active	array
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
2	int
)	O
||	O
(	O
board	pointer
[	O
NORTH	O
(	O
pos	int
)	O
]	O
==	O
EMPTY	int
&&	O
active	array
[	O
NORTH	O
(	O
pos	int
)	O
]	O
==	O
2	int
)	O
||	O
(	O
board	pointer
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
EMPTY	int
&&	O
active	array
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
2	int
)	O
)	O
active	array
[	O
pos	int
]	O
=	O
3	int
;	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
if	O
(	O
active	array
[	O
pos	int
]	O
!=	O
0	int
)	O
continue	O
;	O
if	O
(	O
(	O
ON_BOARD	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
&&	O
active	array
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
>	O
0	int
&&	O
active	array
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
<	O
4	int
)	O
||	O
(	O
ON_BOARD	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
&&	O
active	array
[	O
WEST	O
(	O
pos	int
)	O
]	O
>	O
0	int
&&	O
active	array
[	O
WEST	O
(	O
pos	int
)	O
]	O
<	O
4	int
)	O
||	O
(	O
ON_BOARD	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
&&	O
active	array
[	O
NORTH	O
(	O
pos	int
)	O
]	O
>	O
0	int
&&	O
active	array
[	O
NORTH	O
(	O
pos	int
)	O
]	O
<	O
4	int
)	O
||	O
(	O
ON_BOARD	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
&&	O
active	array
[	O
EAST	O
(	O
pos	int
)	O
]	O
>	O
0	int
&&	O
active	array
[	O
EAST	O
(	O
pos	int
)	O
]	O
<	O
4	int
)	O
)	O
active	array
[	O
pos	int
]	O
=	O
4	int
;	O
}	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
stackp	int
;	O
r	int
++	O
)	O
active	array
[	O
entry	pointer
->	O
stack	array
[	O
r	int
]	O
]	O
=	O
5	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
entry	pointer
->	O
board	pointer
[	O
pos	int
]	O
=	O
active	array
[	O
pos	int
]	O
!=	O
0	int
?	O
board	pointer
[	O
pos	int
]	O
:	O
GRAY	int
;	O
}	O
}	O
static	O
void	O
mark_string_hotspot_values	function
(	O
float	O
values	array
[	O
BOARDMAX	O
]	O
,	O
int	O
m	int
,	O
int	O
n	int
,	O
float	O
contribution	float
)	O
{	O
int	O
i	int
,	O
j	int
,	O
k	int
;	O
if	O
(	O
BOARD	O
(	O
m	int
,	O
n	int
)	O
==	O
EMPTY	int
)	O
{	O
for	O
(	O
i	int
=	O
-	O
1	int
;	O
i	int
<=	O
1	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
-	O
1	int
;	O
j	int
<=	O
1	int
;	O
j	int
++	O
)	O
if	O
(	O
BOARD	O
(	O
m	int
+	O
i	int
,	O
n	int
+	O
j	int
)	O
==	O
EMPTY	int
)	O
values	array
[	O
POS	O
(	O
m	int
+	O
i	int
,	O
n	int
+	O
j	int
)	O
]	O
+=	O
contribution	float
;	O
return	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
board_size	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
board_size	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
!=	O
EMPTY	int
)	O
continue	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
{	O
int	O
di	int
=	O
deltai	array
[	O
k	int
]	O
;	O
int	O
dj	int
=	O
deltaj	array
[	O
k	int
]	O
;	O
if	O
(	O
IS_STONE	O
(	O
BOARD	O
(	O
i	int
+	O
di	int
,	O
j	int
+	O
dj	int
)	O
)	O
&&	O
same_string	function
(	O
POS	O
(	O
i	int
+	O
di	int
,	O
j	int
+	O
dj	int
)	O
,	O
POS	O
(	O
m	int
,	O
n	int
)	O
)	O
)	O
{	O
if	O
(	O
k	int
<	O
4	int
)	O
{	O
values	array
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
+=	O
contribution	float
;	O
break	O
;	O
}	O
else	O
{	O
if	O
(	O
BOARD	O
(	O
i	int
+	O
di	int
,	O
j	int
)	O
==	O
EMPTY	int
||	O
countlib	function
(	O
POS	O
(	O
i	int
+	O
di	int
,	O
j	int
)	O
)	O
<=	O
2	int
||	O
BOARD	O
(	O
i	int
,	O
j	int
+	O
dj	int
)	O
==	O
EMPTY	int
||	O
countlib	function
(	O
POS	O
(	O
i	int
,	O
j	int
+	O
dj	int
)	O
)	O
<=	O
2	int
)	O
values	array
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
+=	O
contribution	float
;	O
break	O
;	O
}	O
}	O
}	O
}	O
}	O
void	O
reading_hotspots	function
(	O
float	O
values	array
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
pos	int
;	O
int	O
k	int
;	O
int	O
sum_nodes	int
=	O
0	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
values	array
[	O
pos	int
]	O
=	O
0.0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
reading_cache	struct
.	O
current_size	int
;	O
k	int
++	O
)	O
sum_nodes	int
+=	O
reading_cache	struct
.	O
table	pointer
[	O
k	int
]	O
.	O
cost	int
;	O
if	O
(	O
sum_nodes	int
<=	O
100	int
)	O
return	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
reading_cache	struct
.	O
current_size	int
;	O
k	int
++	O
)	O
{	O
struct	O
persistent_cache_entry	struct
*	O
entry	pointer
=	O
&	O
(	O
reading_cache	struct
.	O
table	pointer
[	O
k	int
]	O
)	O
;	O
float	O
contribution	float
=	O
entry	pointer
->	O
cost	int
/	O
(	O
float	O
)	O
sum_nodes	int
;	O
if	O
(	O
0	int
)	O
{	O
gprintf	function
(	O
"Reading hotspots: %d %1m %f\n"	pointer
,	O
entry	pointer
->	O
routine	enum
,	O
entry	pointer
->	O
apos	int
,	O
contribution	float
)	O
;	O
}	O
switch	O
(	O
entry	pointer
->	O
routine	enum
)	O
{	O
case	O
ATTACK	int
:	O
case	O
FIND_DEFENSE	int
:	O
mark_string_hotspot_values	function
(	O
values	array
,	O
I	O
(	O
entry	pointer
->	O
apos	int
)	O
,	O
J	O
(	O
entry	pointer
->	O
apos	int
)	O
,	O
contribution	float
)	O
;	O
break	O
;	O
default	O
:	O
gg_assert	O
(	O
0	int
)	O
;	O
break	O
;	O
}	O
}	O
}	O
int	O
search_persistent_connection_cache	function
(	O
enum	O
routine_id	enum
routine	enum
,	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
*	O
result	int
,	O
int	O
*	O
move	pointer
)	O
{	O
return	O
search_persistent_cache	function
(	O
&	O
connection_cache	struct
,	O
routine	enum
,	O
str1	int
,	O
str2	int
,	O
NO_MOVE	O
,	O
EMPTY	int
,	O
NULL	O
,	O
connection_node_limit	int
,	O
result	int
,	O
NULL	O
,	O
move	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
void	O
store_persistent_connection_cache	function
(	O
enum	O
routine_id	enum
routine	enum
,	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
result	int
,	O
int	O
move	pointer
,	O
int	O
tactical_nodes	int
,	O
signed	O
char	O
connection_shadow	array
[	O
BOARDMAX	O
]	O
)	O
{	O
store_persistent_cache	function
(	O
&	O
connection_cache	struct
,	O
routine	enum
,	O
str1	int
,	O
str2	int
,	O
NO_MOVE	O
,	O
EMPTY	int
,	O
NULL	O
,	O
result	int
,	O
NO_MOVE	O
,	O
move	pointer
,	O
NO_MOVE	O
,	O
-	O
1	int
,	O
connection_node_limit	int
,	O
tactical_nodes	int
,	O
connection_shadow	array
,	O
EMPTY	int
)	O
;	O
}	O
static	O
void	O
compute_active_connection_area	function
(	O
struct	O
persistent_cache_entry	struct
*	O
entry	pointer
,	O
const	O
signed	O
char	O
connection_shadow	array
[	O
BOARDMAX	O
]	O
,	O
int	O
dummy	int
)	O
{	O
int	O
pos	int
;	O
int	O
k	int
,	O
r	int
;	O
signed	O
char	O
active	array
[	O
BOARDMAX	O
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
board	pointer
[	O
entry	pointer
->	O
apos	int
]	O
)	O
;	O
UNUSED	O
(	O
dummy	int
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
active	array
[	O
pos	int
]	O
=	O
connection_shadow	array
[	O
pos	int
]	O
;	O
mark_string	function
(	O
entry	pointer
->	O
apos	int
,	O
active	array
,	O
1	int
)	O
;	O
mark_string	function
(	O
entry	pointer
->	O
bpos	int
,	O
active	array
,	O
1	int
)	O
;	O
if	O
(	O
entry	pointer
->	O
result	int
!=	O
0	int
&&	O
entry	pointer
->	O
move	pointer
!=	O
0	int
)	O
active	array
[	O
entry	pointer
->	O
move	pointer
]	O
=	O
1	int
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<	O
3	int
;	O
k	int
++	O
)	O
{	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
||	O
board	pointer
[	O
pos	int
]	O
==	O
other	int
||	O
active	array
[	O
pos	int
]	O
!=	O
0	int
)	O
continue	O
;	O
if	O
(	O
(	O
ON_BOARD	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
&&	O
active	array
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
==	O
k	int
)	O
||	O
(	O
ON_BOARD	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
&&	O
active	array
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
k	int
)	O
||	O
(	O
ON_BOARD	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
&&	O
active	array
[	O
NORTH	O
(	O
pos	int
)	O
]	O
==	O
k	int
)	O
||	O
(	O
ON_BOARD	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
&&	O
active	array
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
k	int
)	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
active	array
[	O
pos	int
]	O
=	O
k	int
+	O
1	int
;	O
else	O
mark_string	function
(	O
pos	int
,	O
active	array
,	O
(	O
signed	O
char	O
)	O
(	O
k	int
+	O
1	int
)	O
)	O
;	O
}	O
}	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
!=	O
other	int
||	O
active	array
[	O
pos	int
]	O
!=	O
0	int
)	O
continue	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
4	int
;	O
r	int
++	O
)	O
{	O
int	O
pos2	int
=	O
pos	int
+	O
delta	array
[	O
r	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
pos2	int
)	O
&&	O
board	pointer
[	O
pos2	int
]	O
!=	O
other	int
&&	O
active	array
[	O
pos2	int
]	O
!=	O
0	int
)	O
{	O
mark_string	function
(	O
pos	int
,	O
active	array
,	O
1	int
)	O
;	O
break	O
;	O
}	O
}	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
other	int
&&	O
active	array
[	O
pos	int
]	O
>	O
0	int
&&	O
countlib	function
(	O
pos	int
)	O
<	O
5	int
)	O
{	O
int	O
libs	pointer
[	O
4	int
]	O
;	O
int	O
liberties	pointer
=	O
findlib	function
(	O
pos	int
,	O
4	int
,	O
libs	pointer
)	O
;	O
int	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
adj	array
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
liberties	pointer
;	O
r	int
++	O
)	O
active	array
[	O
libs	pointer
[	O
r	int
]	O
]	O
=	O
1	int
;	O
adj	array
=	O
chainlinks	function
(	O
pos	int
,	O
adjs	array
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array
;	O
r	int
++	O
)	O
{	O
mark_string	function
(	O
adjs	array
[	O
r	int
]	O
,	O
active	array
,	O
-	O
1	int
)	O
;	O
if	O
(	O
countlib	function
(	O
adjs	array
[	O
r	int
]	O
)	O
<=	O
3	int
)	O
{	O
int	O
s	int
;	O
int	O
adjs2	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
adj2	int
;	O
liberties	pointer
=	O
findlib	function
(	O
adjs	array
[	O
r	int
]	O
,	O
3	int
,	O
libs	pointer
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
liberties	pointer
;	O
s	int
++	O
)	O
active	array
[	O
libs	pointer
[	O
s	int
]	O
]	O
=	O
1	int
;	O
adj2	int
=	O
chainlinks	function
(	O
pos	int
,	O
adjs2	array
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
adj2	int
;	O
s	int
++	O
)	O
mark_string	function
(	O
adjs2	array
[	O
s	int
]	O
,	O
active	array
,	O
-	O
1	int
)	O
;	O
}	O
}	O
}	O
}	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
stackp	int
;	O
r	int
++	O
)	O
active	array
[	O
entry	pointer
->	O
stack	array
[	O
r	int
]	O
]	O
=	O
1	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
int	O
value	pointer
=	O
board	pointer
[	O
pos	int
]	O
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
if	O
(	O
!	O
active	array
[	O
pos	int
]	O
)	O
value	pointer
=	O
GRAY	int
;	O
else	O
if	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
pos	int
]	O
)	O
&&	O
countlib	function
(	O
pos	int
)	O
>	O
4	int
&&	O
active	array
[	O
pos	int
]	O
>	O
0	int
)	O
value	pointer
|=	O
HIGH_LIBERTY_BIT	int
;	O
entry	pointer
->	O
board	pointer
[	O
pos	int
]	O
=	O
value	pointer
;	O
}	O
}	O
int	O
search_persistent_breakin_cache	function
(	O
enum	O
routine_id	enum
routine	enum
,	O
int	O
str	int
,	O
Hash_data	struct
*	O
goal_hash	pointer
,	O
int	O
node_limit	int
,	O
int	O
*	O
result	int
,	O
int	O
*	O
move	pointer
)	O
{	O
return	O
search_persistent_cache	function
(	O
&	O
breakin_cache	struct
,	O
routine	enum
,	O
str	int
,	O
NO_MOVE	O
,	O
NO_MOVE	O
,	O
EMPTY	int
,	O
goal_hash	pointer
,	O
node_limit	int
,	O
result	int
,	O
NULL	O
,	O
move	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
void	O
store_persistent_breakin_cache	function
(	O
enum	O
routine_id	enum
routine	enum
,	O
int	O
str	int
,	O
Hash_data	struct
*	O
goal_hash	pointer
,	O
int	O
result	int
,	O
int	O
move	pointer
,	O
int	O
tactical_nodes	int
,	O
int	O
breakin_node_limit	int
,	O
signed	O
char	O
breakin_shadow	array
[	O
BOARDMAX	O
]	O
)	O
{	O
store_persistent_cache	function
(	O
&	O
breakin_cache	struct
,	O
routine	enum
,	O
str	int
,	O
NO_MOVE	O
,	O
NO_MOVE	O
,	O
EMPTY	int
,	O
goal_hash	pointer
,	O
result	int
,	O
NO_MOVE	O
,	O
move	pointer
,	O
NO_MOVE	O
,	O
-	O
1	int
,	O
breakin_node_limit	int
,	O
tactical_nodes	int
,	O
breakin_shadow	array
,	O
EMPTY	int
)	O
;	O
}	O
static	O
void	O
compute_active_breakin_area	function
(	O
struct	O
persistent_cache_entry	struct
*	O
entry	pointer
,	O
const	O
signed	O
char	O
breakin_shadow	array
[	O
BOARDMAX	O
]	O
,	O
int	O
dummy	int
)	O
{	O
int	O
pos	int
;	O
int	O
k	int
,	O
r	int
;	O
signed	O
char	O
active	array
[	O
BOARDMAX	O
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
board	pointer
[	O
entry	pointer
->	O
apos	int
]	O
)	O
;	O
UNUSED	O
(	O
dummy	int
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
active	array
[	O
pos	int
]	O
=	O
breakin_shadow	array
[	O
pos	int
]	O
;	O
mark_string	function
(	O
entry	pointer
->	O
apos	int
,	O
active	array
,	O
1	int
)	O
;	O
if	O
(	O
entry	pointer
->	O
result	int
!=	O
0	int
&&	O
entry	pointer
->	O
move	pointer
!=	O
0	int
)	O
active	array
[	O
entry	pointer
->	O
move	pointer
]	O
=	O
1	int
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<	O
3	int
;	O
k	int
++	O
)	O
{	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
||	O
board	pointer
[	O
pos	int
]	O
==	O
other	int
||	O
active	array
[	O
pos	int
]	O
!=	O
0	int
)	O
continue	O
;	O
if	O
(	O
(	O
ON_BOARD	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
&&	O
active	array
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
==	O
k	int
)	O
||	O
(	O
ON_BOARD	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
&&	O
active	array
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
k	int
)	O
||	O
(	O
ON_BOARD	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
&&	O
active	array
[	O
NORTH	O
(	O
pos	int
)	O
]	O
==	O
k	int
)	O
||	O
(	O
ON_BOARD	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
&&	O
active	array
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
k	int
)	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
active	array
[	O
pos	int
]	O
=	O
k	int
+	O
1	int
;	O
else	O
mark_string	function
(	O
pos	int
,	O
active	array
,	O
(	O
signed	O
char	O
)	O
(	O
k	int
+	O
1	int
)	O
)	O
;	O
}	O
}	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
!=	O
other	int
||	O
active	array
[	O
pos	int
]	O
!=	O
0	int
)	O
continue	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
4	int
;	O
r	int
++	O
)	O
{	O
int	O
pos2	int
=	O
pos	int
+	O
delta	array
[	O
r	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
pos2	int
)	O
&&	O
board	pointer
[	O
pos2	int
]	O
!=	O
other	int
&&	O
active	array
[	O
pos2	int
]	O
&&	O
active	array
[	O
pos2	int
]	O
<=	O
2	int
)	O
{	O
mark_string	function
(	O
pos	int
,	O
active	array
,	O
1	int
)	O
;	O
break	O
;	O
}	O
}	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
other	int
&&	O
active	array
[	O
pos	int
]	O
>	O
0	int
&&	O
countlib	function
(	O
pos	int
)	O
<	O
4	int
)	O
{	O
int	O
libs	pointer
[	O
4	int
]	O
;	O
int	O
liberties	pointer
=	O
findlib	function
(	O
pos	int
,	O
3	int
,	O
libs	pointer
)	O
;	O
int	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
adj	array
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
liberties	pointer
;	O
r	int
++	O
)	O
active	array
[	O
libs	pointer
[	O
r	int
]	O
]	O
=	O
1	int
;	O
adj	array
=	O
chainlinks	function
(	O
pos	int
,	O
adjs	array
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array
;	O
r	int
++	O
)	O
{	O
mark_string	function
(	O
adjs	array
[	O
r	int
]	O
,	O
active	array
,	O
-	O
1	int
)	O
;	O
if	O
(	O
countlib	function
(	O
adjs	array
[	O
r	int
]	O
)	O
<=	O
3	int
)	O
{	O
int	O
s	int
;	O
int	O
adjs2	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
adj2	int
;	O
liberties	pointer
=	O
findlib	function
(	O
adjs	array
[	O
r	int
]	O
,	O
3	int
,	O
libs	pointer
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
liberties	pointer
;	O
s	int
++	O
)	O
active	array
[	O
libs	pointer
[	O
s	int
]	O
]	O
=	O
1	int
;	O
adj2	int
=	O
chainlinks	function
(	O
pos	int
,	O
adjs2	array
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
adj2	int
;	O
s	int
++	O
)	O
mark_string	function
(	O
adjs2	array
[	O
s	int
]	O
,	O
active	array
,	O
-	O
1	int
)	O
;	O
}	O
}	O
}	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
Intersection	char
value	pointer
=	O
board	pointer
[	O
pos	int
]	O
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
if	O
(	O
!	O
active	array
[	O
pos	int
]	O
)	O
value	pointer
=	O
GRAY	int
;	O
else	O
if	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
pos	int
]	O
)	O
&&	O
countlib	function
(	O
pos	int
)	O
>	O
3	int
&&	O
active	array
[	O
pos	int
]	O
>	O
0	int
)	O
value	pointer
|=	O
HIGH_LIBERTY_BIT2	int
;	O
entry	pointer
->	O
board	pointer
[	O
pos	int
]	O
=	O
value	pointer
;	O
}	O
}	O
int	O
search_persistent_owl_cache	function
(	O
enum	O
routine_id	enum
routine	enum
,	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
int	O
cpos	int
,	O
int	O
*	O
result	int
,	O
int	O
*	O
move	pointer
,	O
int	O
*	O
move2	pointer
,	O
int	O
*	O
certain	pointer
)	O
{	O
return	O
search_persistent_cache	function
(	O
&	O
owl_cache	struct
,	O
routine	enum
,	O
apos	int
,	O
bpos	int
,	O
cpos	int
,	O
EMPTY	int
,	O
NULL	O
,	O
owl_node_limit	int
,	O
result	int
,	O
NULL	O
,	O
move	pointer
,	O
move2	pointer
,	O
certain	pointer
)	O
;	O
}	O
void	O
store_persistent_owl_cache	function
(	O
enum	O
routine_id	enum
routine	enum
,	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
int	O
cpos	int
,	O
int	O
result	int
,	O
int	O
move	pointer
,	O
int	O
move2	pointer
,	O
int	O
certain	pointer
,	O
int	O
tactical_nodes	int
,	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
,	O
int	O
goal_color	int
)	O
{	O
store_persistent_cache	function
(	O
&	O
owl_cache	struct
,	O
routine	enum
,	O
apos	int
,	O
bpos	int
,	O
cpos	int
,	O
EMPTY	int
,	O
NULL	O
,	O
result	int
,	O
NO_MOVE	O
,	O
move	pointer
,	O
move2	pointer
,	O
certain	pointer
,	O
owl_node_limit	int
,	O
tactical_nodes	int
,	O
goal	pointer
,	O
goal_color	int
)	O
;	O
}	O
static	O
void	O
compute_active_owl_type_area	function
(	O
const	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
,	O
int	O
goal_color	int
,	O
signed	O
char	O
active	array
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
k	int
,	O
r	int
;	O
int	O
pos	int
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
goal_color	int
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
goal	pointer
[	O
pos	int
]	O
)	O
active	array
[	O
pos	int
]	O
=	O
1	int
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<	O
5	int
;	O
k	int
++	O
)	O
{	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
||	O
board	pointer
[	O
pos	int
]	O
==	O
other	int
||	O
active	array
[	O
pos	int
]	O
>	O
0	int
)	O
continue	O
;	O
if	O
(	O
(	O
ON_BOARD	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
&&	O
active	array
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
==	O
k	int
)	O
||	O
(	O
ON_BOARD	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
&&	O
active	array
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
k	int
)	O
||	O
(	O
ON_BOARD	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
&&	O
active	array
[	O
NORTH	O
(	O
pos	int
)	O
]	O
==	O
k	int
)	O
||	O
(	O
ON_BOARD	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
&&	O
active	array
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
k	int
)	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
active	array
[	O
pos	int
]	O
=	O
k	int
+	O
1	int
;	O
else	O
mark_string	function
(	O
pos	int
,	O
active	array
,	O
(	O
signed	O
char	O
)	O
(	O
k	int
+	O
1	int
)	O
)	O
;	O
}	O
}	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
!=	O
other	int
||	O
active	array
[	O
pos	int
]	O
!=	O
0	int
)	O
continue	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
4	int
;	O
r	int
++	O
)	O
{	O
int	O
pos2	int
=	O
pos	int
+	O
delta	array
[	O
r	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
pos2	int
)	O
&&	O
board	pointer
[	O
pos2	int
]	O
!=	O
other	int
&&	O
active	array
[	O
pos2	int
]	O
!=	O
0	int
)	O
{	O
mark_string	function
(	O
pos	int
,	O
active	array
,	O
1	int
)	O
;	O
break	O
;	O
}	O
}	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
other	int
&&	O
active	array
[	O
pos	int
]	O
>	O
0	int
&&	O
countlib	function
(	O
pos	int
)	O
<	O
5	int
)	O
{	O
int	O
libs	pointer
[	O
4	int
]	O
;	O
int	O
liberties	pointer
=	O
findlib	function
(	O
pos	int
,	O
4	int
,	O
libs	pointer
)	O
;	O
int	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
adj	array
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
liberties	pointer
;	O
r	int
++	O
)	O
active	array
[	O
libs	pointer
[	O
r	int
]	O
]	O
=	O
1	int
;	O
adj	array
=	O
chainlinks	function
(	O
pos	int
,	O
adjs	array
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array
;	O
r	int
++	O
)	O
{	O
mark_string	function
(	O
adjs	array
[	O
r	int
]	O
,	O
active	array
,	O
-	O
1	int
)	O
;	O
if	O
(	O
countlib	function
(	O
adjs	array
[	O
r	int
]	O
)	O
<=	O
3	int
)	O
{	O
int	O
s	int
;	O
int	O
adjs2	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
adj2	int
;	O
liberties	pointer
=	O
findlib	function
(	O
adjs	array
[	O
r	int
]	O
,	O
3	int
,	O
libs	pointer
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
liberties	pointer
;	O
s	int
++	O
)	O
active	array
[	O
libs	pointer
[	O
s	int
]	O
]	O
=	O
1	int
;	O
adj2	int
=	O
chainlinks	function
(	O
pos	int
,	O
adjs2	array
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
adj2	int
;	O
s	int
++	O
)	O
mark_string	function
(	O
adjs2	array
[	O
s	int
]	O
,	O
active	array
,	O
-	O
1	int
)	O
;	O
}	O
}	O
}	O
}	O
}	O
static	O
void	O
compute_active_owl_area	function
(	O
struct	O
persistent_cache_entry	struct
*	O
entry	pointer
,	O
const	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
,	O
int	O
goal_color	int
)	O
{	O
int	O
pos	int
;	O
signed	O
char	O
active	array
[	O
BOARDMAX	O
]	O
;	O
memset	function
(	O
active	array
,	O
0	int
,	O
BOARDMAX	O
)	O
;	O
if	O
(	O
ON_BOARD1	O
(	O
entry	pointer
->	O
move	pointer
)	O
)	O
active	array
[	O
entry	pointer
->	O
move	pointer
]	O
=	O
1	int
;	O
if	O
(	O
ON_BOARD1	O
(	O
entry	pointer
->	O
move2	pointer
)	O
)	O
active	array
[	O
entry	pointer
->	O
move2	pointer
]	O
=	O
1	int
;	O
compute_active_owl_type_area	function
(	O
goal	pointer
,	O
goal_color	int
,	O
active	array
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
int	O
value	pointer
=	O
board	pointer
[	O
pos	int
]	O
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
if	O
(	O
!	O
active	array
[	O
pos	int
]	O
)	O
value	pointer
=	O
GRAY	int
;	O
else	O
if	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
pos	int
]	O
)	O
&&	O
countlib	function
(	O
pos	int
)	O
>	O
4	int
&&	O
active	array
[	O
pos	int
]	O
>	O
0	int
)	O
value	pointer
|=	O
HIGH_LIBERTY_BIT	int
;	O
entry	pointer
->	O
board	pointer
[	O
pos	int
]	O
=	O
value	pointer
;	O
}	O
}	O
int	O
search_persistent_semeai_cache	function
(	O
enum	O
routine_id	enum
routine	enum
,	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
int	O
cpos	int
,	O
int	O
color	int
,	O
Hash_data	struct
*	O
goal_hash	pointer
,	O
int	O
*	O
resulta	pointer
,	O
int	O
*	O
resultb	pointer
,	O
int	O
*	O
move	pointer
,	O
int	O
*	O
certain	pointer
)	O
{	O
return	O
search_persistent_cache	function
(	O
&	O
semeai_cache	struct
,	O
routine	enum
,	O
apos	int
,	O
bpos	int
,	O
cpos	int
,	O
color	int
,	O
goal_hash	pointer
,	O
semeai_node_limit	int
,	O
resulta	pointer
,	O
resultb	pointer
,	O
move	pointer
,	O
NULL	O
,	O
certain	pointer
)	O
;	O
}	O
void	O
store_persistent_semeai_cache	function
(	O
enum	O
routine_id	enum
routine	enum
,	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
int	O
cpos	int
,	O
int	O
color	int
,	O
Hash_data	struct
*	O
goal_hash	pointer
,	O
int	O
resulta	pointer
,	O
int	O
resultb	pointer
,	O
int	O
move	pointer
,	O
int	O
certain	pointer
,	O
int	O
tactical_nodes	int
,	O
signed	O
char	O
goala	array
[	O
BOARDMAX	O
]	O
,	O
signed	O
char	O
goalb	array
[	O
BOARDMAX	O
]	O
)	O
{	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
;	O
int	O
pos	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
goal	pointer
[	O
pos	int
]	O
=	O
goala	array
[	O
pos	int
]	O
||	O
goalb	array
[	O
pos	int
]	O
;	O
store_persistent_cache	function
(	O
&	O
semeai_cache	struct
,	O
routine	enum
,	O
apos	int
,	O
bpos	int
,	O
cpos	int
,	O
color	int
,	O
goal_hash	pointer
,	O
resulta	pointer
,	O
resultb	pointer
,	O
move	pointer
,	O
NO_MOVE	O
,	O
certain	pointer
,	O
semeai_node_limit	int
,	O
tactical_nodes	int
,	O
goal	pointer
,	O
EMPTY	int
)	O
;	O
}	O
static	O
void	O
compute_active_semeai_area	function
(	O
struct	O
persistent_cache_entry	struct
*	O
entry	pointer
,	O
const	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
,	O
int	O
dummy	int
)	O
{	O
int	O
pos	int
;	O
signed	O
char	O
active_b	array
[	O
BOARDMAX	O
]	O
;	O
signed	O
char	O
active_w	array
[	O
BOARDMAX	O
]	O
;	O
UNUSED	O
(	O
dummy	int
)	O
;	O
memset	function
(	O
active_b	array
,	O
0	int
,	O
BOARDMAX	O
)	O
;	O
memset	function
(	O
active_w	array
,	O
0	int
,	O
BOARDMAX	O
)	O
;	O
if	O
(	O
ON_BOARD1	O
(	O
entry	pointer
->	O
move	pointer
)	O
)	O
{	O
active_b	array
[	O
entry	pointer
->	O
move	pointer
]	O
=	O
1	int
;	O
active_w	array
[	O
entry	pointer
->	O
move	pointer
]	O
=	O
1	int
;	O
}	O
if	O
(	O
ON_BOARD1	O
(	O
entry	pointer
->	O
cpos	int
)	O
)	O
{	O
active_b	array
[	O
entry	pointer
->	O
cpos	int
]	O
=	O
1	int
;	O
active_w	array
[	O
entry	pointer
->	O
cpos	int
]	O
=	O
1	int
;	O
}	O
compute_active_owl_type_area	function
(	O
goal	pointer
,	O
BLACK	int
,	O
active_b	array
)	O
;	O
compute_active_owl_type_area	function
(	O
goal	pointer
,	O
WHITE	int
,	O
active_w	array
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
int	O
value	pointer
=	O
board	pointer
[	O
pos	int
]	O
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
if	O
(	O
!	O
active_b	array
[	O
pos	int
]	O
&&	O
!	O
active_w	array
[	O
pos	int
]	O
)	O
value	pointer
=	O
GRAY	int
;	O
else	O
if	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
pos	int
]	O
)	O
&&	O
countlib	function
(	O
pos	int
)	O
>	O
4	int
&&	O
(	O
active_b	array
[	O
pos	int
]	O
>	O
0	int
||	O
active_w	array
[	O
pos	int
]	O
>	O
0	int
)	O
)	O
value	pointer
|=	O
HIGH_LIBERTY_BIT	int
;	O
entry	pointer
->	O
board	pointer
[	O
pos	int
]	O
=	O
value	pointer
;	O
}	O
}	O
static	O
void	O
mark_dragon_hotspot_values	function
(	O
float	O
values	array
[	O
BOARDMAX	O
]	O
,	O
int	O
dr	int
,	O
float	O
contribution	float
,	O
Intersection	char
active_board	array
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
pos	int
;	O
int	O
k	int
;	O
if	O
(	O
!	O
IS_STONE	O
(	O
board	pointer
[	O
dr	int
]	O
)	O
)	O
return	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
!=	O
EMPTY	int
)	O
continue	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
{	O
int	O
pos2	int
=	O
pos	int
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
pos2	int
]	O
)	O
&&	O
(	O
is_same_dragon	function
(	O
pos2	int
,	O
dr	int
)	O
||	O
(	O
are_neighbor_dragons	function
(	O
pos2	int
,	O
dr	int
)	O
&&	O
board	pointer
[	O
pos2	int
]	O
==	O
board	pointer
[	O
dr	int
]	O
)	O
)	O
&&	O
(	O
countlib	function
(	O
pos2	int
)	O
<=	O
4	int
||	O
is_edge_vertex	function
(	O
pos	int
)	O
)	O
)	O
{	O
if	O
(	O
k	int
<	O
4	int
)	O
{	O
if	O
(	O
is_same_dragon	function
(	O
pos2	int
,	O
dr	int
)	O
)	O
values	array
[	O
pos	int
]	O
+=	O
contribution	float
;	O
else	O
values	array
[	O
pos	int
]	O
+=	O
0.5	int
*	O
contribution	float
;	O
break	O
;	O
}	O
else	O
{	O
int	O
pos3	int
=	O
pos	int
+	O
delta	array
[	O
k	int
%	O
4	int
]	O
;	O
int	O
pos4	int
=	O
pos	int
+	O
delta	array
[	O
(	O
k	int
+	O
1	int
)	O
%	O
4	int
]	O
;	O
if	O
(	O
board	pointer
[	O
pos3	int
]	O
==	O
EMPTY	int
||	O
countlib	function
(	O
pos3	int
)	O
<=	O
2	int
||	O
board	pointer
[	O
pos4	int
]	O
==	O
EMPTY	int
||	O
countlib	function
(	O
pos4	int
)	O
<=	O
2	int
)	O
values	array
[	O
pos	int
]	O
+=	O
0.5	int
*	O
contribution	float
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
k	int
==	O
8	int
&&	O
active_board	array
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
{	O
values	array
[	O
pos	int
]	O
-=	O
0.5	int
*	O
contribution	float
;	O
}	O
}	O
}	O
void	O
owl_hotspots	function
(	O
float	O
values	array
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
pos	int
;	O
int	O
k	int
,	O
r	int
;	O
int	O
libs	pointer
[	O
MAXLIBS	O
]	O
;	O
int	O
liberties	pointer
;	O
int	O
sum_tactical_nodes	int
=	O
0	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
values	array
[	O
pos	int
]	O
=	O
0.0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
owl_cache	struct
.	O
current_size	int
;	O
k	int
++	O
)	O
sum_tactical_nodes	int
+=	O
owl_cache	struct
.	O
table	pointer
[	O
k	int
]	O
.	O
score	float
;	O
if	O
(	O
sum_tactical_nodes	int
<=	O
100	int
)	O
return	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
owl_cache	struct
.	O
current_size	int
;	O
k	int
++	O
)	O
{	O
struct	O
persistent_cache_entry	struct
*	O
entry	pointer
=	O
&	O
(	O
owl_cache	struct
.	O
table	pointer
[	O
k	int
]	O
)	O
;	O
float	O
contribution	float
=	O
entry	pointer
->	O
score	float
/	O
(	O
float	O
)	O
sum_tactical_nodes	int
;	O
if	O
(	O
debug	int
&	O
DEBUG_PERSISTENT_CACHE	int
)	O
{	O
gprintf	function
(	O
"Owl hotspots: %d %1m %f\n"	pointer
,	O
entry	pointer
->	O
routine	enum
,	O
entry	pointer
->	O
apos	int
,	O
contribution	float
)	O
;	O
}	O
switch	O
(	O
entry	pointer
->	O
routine	enum
)	O
{	O
case	O
OWL_ATTACK	int
:	O
case	O
OWL_THREATEN_ATTACK	int
:	O
case	O
OWL_DEFEND	int
:	O
case	O
OWL_THREATEN_DEFENSE	int
:	O
mark_dragon_hotspot_values	function
(	O
values	array
,	O
entry	pointer
->	O
apos	int
,	O
contribution	float
,	O
entry	pointer
->	O
board	pointer
)	O
;	O
break	O
;	O
case	O
OWL_DOES_DEFEND	int
:	O
case	O
OWL_DOES_ATTACK	int
:	O
case	O
OWL_CONFIRM_SAFETY	int
:	O
mark_dragon_hotspot_values	function
(	O
values	array
,	O
entry	pointer
->	O
bpos	int
,	O
contribution	float
,	O
entry	pointer
->	O
board	pointer
)	O
;	O
break	O
;	O
case	O
OWL_CONNECTION_DEFENDS	int
:	O
mark_dragon_hotspot_values	function
(	O
values	array
,	O
entry	pointer
->	O
bpos	int
,	O
contribution	float
,	O
entry	pointer
->	O
board	pointer
)	O
;	O
mark_dragon_hotspot_values	function
(	O
values	array
,	O
entry	pointer
->	O
cpos	int
,	O
contribution	float
,	O
entry	pointer
->	O
board	pointer
)	O
;	O
break	O
;	O
case	O
OWL_SUBSTANTIAL	int
:	O
if	O
(	O
!	O
IS_STONE	O
(	O
board	pointer
[	O
entry	pointer
->	O
apos	int
]	O
)	O
)	O
continue	O
;	O
liberties	pointer
=	O
findlib	function
(	O
entry	pointer
->	O
apos	int
,	O
MAXLIBS	O
,	O
libs	pointer
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
liberties	pointer
;	O
r	int
++	O
)	O
values	array
[	O
libs	pointer
[	O
r	int
]	O
]	O
+=	O
contribution	float
;	O
break	O
;	O
default	O
:	O
gg_assert	O
(	O
0	int
)	O
;	O
break	O
;	O
}	O
}	O
}	O
