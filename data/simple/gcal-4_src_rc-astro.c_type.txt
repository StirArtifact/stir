__BEGIN_DECLARATIONS	O
static	O
double	O
atmospheric_refraction	function
__P_	O
(	O
(	O
const	O
double	O
altitude	double
,	O
double	O
pressure	double
,	O
const	O
double	O
temperature	double
)	O
)	O
;	O
static	O
int	O
moon_charpos	function
__P_	O
(	O
(	O
const	O
double	O
x	double
,	O
const	O
int	O
lines	int
)	O
)	O
;	O
static	O
double	O
internal_moon_rise_set	function
__P_	O
(	O
(	O
const	O
Aevent_enum	enum
event	enum
,	O
int	O
day	int
,	O
int	O
month	int
,	O
int	O
year	int
,	O
Coor_struct	struct
*	O
coordinates	pointer
)	O
)	O
;	O
__END_DECLARATIONS	O
static	O
double	O
atmospheric_refraction	function
(	O
altitude	double
,	O
pressure	double
,	O
temperature	double
)	O
const	O
double	O
altitude	double
;	O
double	O
pressure	double
;	O
const	O
double	O
temperature	double
;	O
{	O
auto	O
double	O
degrees_altitude	double
=	O
TODEG	O
(	O
altitude	double
)	O
;	O
pressure	double
/=	O
100.0	int
;	O
if	O
(	O
pressure	double
<=	O
0.0	int
||	O
degrees_altitude	double
<	O
-	O
2.0	int
||	O
degrees_altitude	double
>=	O
DEGS_PER_06_HOURS	int
)	O
return	O
(	O
0.0	int
)	O
;	O
if	O
(	O
degrees_altitude	double
<	O
DEGS_PER_HOUR	int
)	O
{	O
auto	O
double	O
old_altitude	double
=	O
degrees_altitude	double
;	O
auto	O
double	O
old_degrees	double
=	O
0.0	int
;	O
auto	O
double	O
new_altitude	double
=	O
degrees_altitude	double
;	O
auto	O
double	O
new_degrees	double
=	O
0.0	int
;	O
auto	O
double	O
new_pressure	double
=	O
(	O
pressure	double
-	O
80.0	int
)	O
/	O
930.0	int
;	O
auto	O
double	O
new_temperature	double
=	O
0.0048	int
*	O
(	O
temperature	double
-	O
10.0	int
)	O
;	O
auto	O
double	O
n	long
;	O
register	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
;	O
i	int
++	O
)	O
{	O
n	long
=	O
1.0	int
/	O
tan	function
(	O
TORAD	O
(	O
new_altitude	double
+	O
(	O
7.31	int
/	O
(	O
new_altitude	double
+	O
4.4	int
)	O
)	O
)	O
)	O
;	O
new_degrees	double
=	O
n	long
*	O
new_pressure	double
/	O
(	O
60.0	int
+	O
new_temperature	double
*	O
(	O
n	long
+	O
39.0	int
)	O
)	O
;	O
n	long
=	O
new_altitude	double
-	O
old_altitude	double
;	O
old_altitude	double
=	O
new_degrees	double
-	O
old_degrees	double
-	O
n	long
;	O
if	O
(	O
(	O
n	long
!=	O
0.0	int
)	O
&&	O
(	O
old_altitude	double
!=	O
0.0	int
)	O
)	O
n	long
=	O
new_altitude	double
-	O
n	long
*	O
(	O
degrees_altitude	double
+	O
new_degrees	double
-	O
new_altitude	double
)	O
/	O
old_altitude	double
;	O
else	O
n	long
=	O
degrees_altitude	double
+	O
new_degrees	double
;	O
old_altitude	double
=	O
new_altitude	double
;	O
old_degrees	double
=	O
new_degrees	double
;	O
new_altitude	double
=	O
n	long
;	O
}	O
return	O
(	O
TORAD	O
(	O
new_degrees	double
)	O
)	O
;	O
}	O
return	O
(	O
0.00007888888	int
*	O
pressure	double
/	O
(	O
(	O
273.0	int
+	O
temperature	double
)	O
*	O
tan	function
(	O
altitude	double
)	O
)	O
)	O
;	O
}	O
static	O
int	O
moon_charpos	function
(	O
x	double
,	O
lines	int
)	O
const	O
double	O
x	double
;	O
const	O
int	O
lines	int
;	O
{	O
register	O
int	O
i	int
;	O
i	int
=	O
(	O
int	O
)	O
(	O
x	double
*	O
(	O
double	O
)	O
lines	int
-	O
0.5	int
)	O
;	O
if	O
(	O
i	int
+	O
lines	int
<	O
1	int
)	O
i	int
=	O
0	int
;	O
else	O
i	int
+=	O
lines	int
;	O
return	O
(	O
i	int
)	O
;	O
}	O
double	O
gd_latitude2gc_latitude	function
(	O
gd_latitude	double
,	O
meters_above_sea_level	int
,	O
gc_latitude	pointer
)	O
const	O
double	O
gd_latitude	double
;	O
const	O
int	O
meters_above_sea_level	int
;	O
double	O
*	O
gc_latitude	pointer
;	O
{	O
auto	O
double	O
x1	double
;	O
auto	O
double	O
x2	double
;	O
auto	O
double	O
x3	double
;	O
auto	O
double	O
cos_gd_latitude	double
=	O
cos	function
(	O
gd_latitude	double
)	O
;	O
auto	O
double	O
cos2_gd_latitude	double
;	O
auto	O
double	O
sin2_gd_latitude	double
;	O
sin2_gd_latitude	double
=	O
sin	function
(	O
gd_latitude	double
)	O
;	O
sin2_gd_latitude	double
*=	O
sin2_gd_latitude	double
;	O
cos2_gd_latitude	double
=	O
cos_gd_latitude	double
*	O
cos_gd_latitude	double
;	O
x1	double
=	O
(	O
1.0	int
/	O
sqrt	function
(	O
cos2_gd_latitude	double
+	O
FLATTENING_OF_EARTH	int
*	O
sin2_gd_latitude	double
)	O
)	O
*	O
EQUATOR_EARTH_RADIUS	int
;	O
x2	double
=	O
x1	double
+	O
meters_above_sea_level	int
;	O
x3	double
=	O
x1	double
*	O
FLATTENING_OF_EARTH	int
+	O
meters_above_sea_level	int
;	O
x1	double
=	O
sqrt	function
(	O
x2	double
*	O
x2	double
*	O
cos2_gd_latitude	double
+	O
x3	double
*	O
x3	double
*	O
sin2_gd_latitude	double
)	O
;	O
x3	double
=	O
acos	function
(	O
x2	double
*	O
cos_gd_latitude	double
/	O
x1	double
)	O
;	O
if	O
(	O
SGN	O
(	O
gd_latitude	double
)	O
<	O
0	int
)	O
x3	double
=	O
-	O
x3	double
;	O
if	O
(	O
gc_latitude	pointer
!=	O
(	O
double	O
*	O
)	O
NULL	O
)	O
*	O
gc_latitude	pointer
=	O
x3	double
;	O
return	O
(	O
x1	double
)	O
;	O
}	O
double	O
sun_rise_set	function
(	O
event	enum
,	O
is_limited	int
,	O
day	int
,	O
month	int
,	O
year	int
,	O
coordinates	pointer
)	O
const	O
Aevent_enum	enum
event	enum
;	O
const	O
Bool	int
is_limited	int
;	O
const	O
int	O
day	int
;	O
const	O
int	O
month	int
;	O
const	O
int	O
year	int
;	O
Coor_struct	struct
*	O
coordinates	pointer
;	O
{	O
auto	O
double	O
x1	double
=	O
0.0	int
;	O
auto	O
double	O
x2	double
;	O
auto	O
double	O
x3	double
;	O
auto	O
double	O
x4	double
;	O
auto	O
double	O
longitude	double
;	O
auto	O
double	O
latitude	double
;	O
auto	O
double	O
sin_latitude	double
;	O
auto	O
double	O
cos_latitude	double
;	O
auto	O
double	O
mjd	double
;	O
auto	O
double	O
mjd_0ut	double
;	O
auto	O
double	O
jc	double
;	O
auto	O
double	O
local_sidereal_time	double
;	O
auto	O
double	O
obliquity_of_ecliptic	double
;	O
auto	O
double	O
sin_obliquity_of_ecliptic	double
;	O
auto	O
double	O
cos_obliquity_of_ecliptic	double
;	O
auto	O
double	O
argument_of_perihelion	double
;	O
auto	O
double	O
mean_anomaly	double
;	O
auto	O
double	O
eccentricity	double
;	O
auto	O
double	O
anomaly_of_eccentric	double
;	O
auto	O
double	O
divisor_term	double
;	O
auto	O
double	O
true_anomaly	double
;	O
auto	O
double	O
distance	double
;	O
auto	O
double	O
ecliptic_longitude	double
;	O
auto	O
double	O
xe	double
;	O
auto	O
double	O
ye	double
;	O
auto	O
double	O
ze	double
;	O
auto	O
double	O
right_ascension	double
;	O
auto	O
double	O
declination	double
;	O
auto	O
double	O
meridian_transit_time	double
=	O
SECS_PER_DAY	int
;	O
auto	O
double	O
the_time	double
=	O
SECS_PER_DAY	int
;	O
auto	O
double	O
geodetic_height	double
=	O
0.0	int
;	O
register	O
int	O
n	long
=	O
0	int
;	O
register	O
int	O
tz_offset	int
;	O
register	O
int	O
save_the_mode	int
;	O
auto	O
Bool	int
iter_mt	int
=	O
FALSE	O
;	O
tz_offset	int
=	O
(	O
int	O
)	O
(	O
SGN	O
(	O
coordinates	pointer
->	O
time_zone_in_mins	int
)	O
*	O
(	O
abs	function
(	O
coordinates	pointer
->	O
time_zone_in_mins	int
)	O
%	O
MINS_PER_DAY	int
)	O
)	O
;	O
x2	double
=	O
DAY2HH	O
(	O
time_offset	double
)	O
;	O
x4	double
=	O
(	O
(	O
int	O
)	O
DAY2MM	O
(	O
time_offset	double
)	O
)	O
%	O
MINS_PER_HOUR	int
;	O
switch	O
(	O
coordinates	pointer
->	O
the_mode	int
)	O
{	O
case	O
27	int
:	O
return	O
(	O
delta_t	function
(	O
day	int
,	O
month	int
,	O
year	int
,	O
(	O
int	O
)	O
x2	double
,	O
(	O
int	O
)	O
x4	double
)	O
)	O
;	O
case	O
29	int
:	O
return	O
(	O
DAY2HH	O
(	O
time_offset	double
)	O
)	O
;	O
case	O
31	int
:	O
x1	double
=	O
SS2DAY	O
(	O
delta_t	function
(	O
day	int
,	O
month	int
,	O
year	int
,	O
(	O
int	O
)	O
x2	double
,	O
(	O
int	O
)	O
x4	double
)	O
)	O
;	O
case	O
30	int
:	O
return	O
(	O
date2num	function
(	O
day	int
,	O
month	int
,	O
year	int
)	O
+	O
(	O
MIN_BCE_TO_1_CE	int
-	O
1.5	int
)	O
+	O
x1	double
+	O
time_offset	double
)	O
;	O
case	O
32	int
:	O
longitude	double
=	O
0.0	int
;	O
break	O
;	O
case	O
33	int
:	O
case	O
34	int
:	O
case	O
35	int
:	O
case	O
36	int
:	O
save_the_mode	int
=	O
coordinates	pointer
->	O
the_mode	int
;	O
switch	O
(	O
save_the_mode	int
)	O
{	O
case	O
33	int
:	O
coordinates	pointer
->	O
the_mode	int
=	O
10	int
;	O
break	O
;	O
case	O
34	int
:	O
coordinates	pointer
->	O
the_mode	int
=	O
11	int
;	O
break	O
;	O
case	O
35	int
:	O
coordinates	pointer
->	O
the_mode	int
=	O
19	int
;	O
break	O
;	O
default	O
:	O
coordinates	pointer
->	O
the_mode	int
=	O
20	int
;	O
break	O
;	O
}	O
the_time	double
=	O
sun_rise_set	function
(	O
event	enum
,	O
is_limited	int
,	O
day	int
,	O
month	int
,	O
year	int
,	O
coordinates	pointer
)	O
;	O
switch	O
(	O
save_the_mode	int
)	O
{	O
case	O
33	int
:	O
case	O
35	int
:	O
if	O
(	O
save_the_mode	int
==	O
33	int
)	O
coordinates	pointer
->	O
the_mode	int
=	O
10	int
;	O
else	O
coordinates	pointer
->	O
the_mode	int
=	O
23	int
;	O
the_time	double
-=	O
internal_moon_rise_set	function
(	O
event	enum
,	O
day	int
,	O
month	int
,	O
year	int
,	O
coordinates	pointer
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
save_the_mode	int
==	O
34	int
)	O
coordinates	pointer
->	O
the_mode	int
=	O
11	int
;	O
else	O
coordinates	pointer
->	O
the_mode	int
=	O
24	int
;	O
x4	double
=	O
the_time	double
-	O
internal_moon_rise_set	function
(	O
event	enum
,	O
day	int
,	O
month	int
,	O
year	int
,	O
coordinates	pointer
)	O
;	O
if	O
(	O
abs	function
(	O
x4	double
)	O
<=	O
DEGS_PER_12_HOURS	int
)	O
the_time	double
=	O
x4	double
;	O
else	O
if	O
(	O
x4	double
>	O
DEGS_PER_12_HOURS	int
)	O
the_time	double
=	O
-	O
DEGS_PER_24_HOURS	int
+	O
x4	double
;	O
else	O
the_time	double
=	O
DEGS_PER_24_HOURS	int
+	O
x4	double
;	O
}	O
coordinates	pointer
->	O
the_mode	int
=	O
save_the_mode	int
;	O
return	O
(	O
the_time	double
)	O
;	O
case	O
41	int
:	O
case	O
42	int
:	O
case	O
43	int
:	O
case	O
44	int
:	O
case	O
45	int
:	O
case	O
48	int
:	O
case	O
49	int
:	O
x1	double
=	O
time_offset	double
;	O
save_the_mode	int
=	O
coordinates	pointer
->	O
the_mode	int
;	O
switch	O
(	O
save_the_mode	int
)	O
{	O
case	O
43	int
:	O
coordinates	pointer
->	O
the_mode	int
=	O
5	int
;	O
break	O
;	O
case	O
41	int
:	O
case	O
44	int
:	O
case	O
48	int
:	O
coordinates	pointer
->	O
the_mode	int
=	O
0	int
;	O
break	O
;	O
default	O
:	O
coordinates	pointer
->	O
the_mode	int
=	O
1	int
;	O
}	O
time_offset	double
=	O
sun_rise_set	function
(	O
event	enum
,	O
is_limited	int
,	O
day	int
,	O
month	int
,	O
year	int
,	O
coordinates	pointer
)	O
;	O
if	O
(	O
time_offset	double
>	O
SPECIAL_VALUE	O
)	O
{	O
time_offset	double
=	O
HH2DAY	O
(	O
time_offset	double
)	O
;	O
if	O
(	O
save_the_mode	int
<=	O
42	int
)	O
{	O
if	O
(	O
save_the_mode	int
==	O
41	int
)	O
coordinates	pointer
->	O
the_mode	int
=	O
0	int
;	O
else	O
coordinates	pointer
->	O
the_mode	int
=	O
1	int
;	O
the_time	double
=	O
moon_rise_set	function
(	O
event	enum
,	O
day	int
,	O
month	int
,	O
year	int
,	O
coordinates	pointer
)	O
;	O
if	O
(	O
the_time	double
>	O
SPECIAL_VALUE	O
)	O
the_time	double
=	O
DAY2HH	O
(	O
time_offset	double
)	O
-	O
the_time	double
;	O
else	O
the_time	double
=	O
HH2SS	O
(	O
the_time	double
)	O
;	O
}	O
else	O
if	O
(	O
save_the_mode	int
==	O
43	int
)	O
{	O
coordinates	pointer
->	O
the_mode	int
=	O
5	int
;	O
the_time	double
=	O
moon_rise_set	function
(	O
event	enum
,	O
day	int
,	O
month	int
,	O
year	int
,	O
coordinates	pointer
)	O
;	O
if	O
(	O
the_time	double
>	O
SPECIAL_VALUE	O
)	O
the_time	double
=	O
DAY2HH	O
(	O
time_offset	double
)	O
-	O
the_time	double
;	O
else	O
the_time	double
=	O
HH2SS	O
(	O
the_time	double
)	O
;	O
}	O
else	O
{	O
switch	O
(	O
save_the_mode	int
)	O
{	O
case	O
44	int
:	O
case	O
45	int
:	O
coordinates	pointer
->	O
the_mode	int
=	O
10	int
;	O
break	O
;	O
default	O
:	O
coordinates	pointer
->	O
the_mode	int
=	O
19	int
;	O
}	O
the_time	double
=	O
sun_rise_set	function
(	O
event	enum
,	O
is_limited	int
,	O
day	int
,	O
month	int
,	O
year	int
,	O
coordinates	pointer
)	O
;	O
}	O
}	O
else	O
the_time	double
=	O
HH2SS	O
(	O
time_offset	double
)	O
;	O
coordinates	pointer
->	O
the_mode	int
=	O
save_the_mode	int
;	O
time_offset	double
=	O
x1	double
;	O
return	O
(	O
the_time	double
)	O
;	O
case	O
37	int
:	O
case	O
38	int
:	O
case	O
39	int
:	O
case	O
40	int
:	O
case	O
46	int
:	O
case	O
47	int
:	O
case	O
50	int
:	O
case	O
51	int
:	O
x1	double
=	O
time_offset	double
;	O
save_the_mode	int
=	O
coordinates	pointer
->	O
the_mode	int
;	O
coordinates	pointer
->	O
the_mode	int
=	O
5	int
;	O
time_offset	double
=	O
sun_rise_set	function
(	O
event	enum
,	O
is_limited	int
,	O
day	int
,	O
month	int
,	O
year	int
,	O
coordinates	pointer
)	O
;	O
if	O
(	O
time_offset	double
>	O
SPECIAL_VALUE	O
)	O
{	O
time_offset	double
=	O
HH2DAY	O
(	O
time_offset	double
)	O
;	O
switch	O
(	O
save_the_mode	int
)	O
{	O
case	O
37	int
:	O
case	O
46	int
:	O
coordinates	pointer
->	O
the_mode	int
=	O
10	int
;	O
break	O
;	O
case	O
38	int
:	O
case	O
47	int
:	O
coordinates	pointer
->	O
the_mode	int
=	O
11	int
;	O
break	O
;	O
case	O
39	int
:	O
case	O
50	int
:	O
coordinates	pointer
->	O
the_mode	int
=	O
19	int
;	O
break	O
;	O
default	O
:	O
coordinates	pointer
->	O
the_mode	int
=	O
20	int
;	O
}	O
the_time	double
=	O
sun_rise_set	function
(	O
event	enum
,	O
is_limited	int
,	O
day	int
,	O
month	int
,	O
year	int
,	O
coordinates	pointer
)	O
;	O
if	O
(	O
(	O
save_the_mode	int
>=	O
37	int
)	O
&&	O
(	O
save_the_mode	int
<=	O
40	int
)	O
)	O
switch	O
(	O
save_the_mode	int
)	O
{	O
case	O
37	int
:	O
case	O
39	int
:	O
if	O
(	O
save_the_mode	int
==	O
37	int
)	O
coordinates	pointer
->	O
the_mode	int
=	O
10	int
;	O
else	O
coordinates	pointer
->	O
the_mode	int
=	O
23	int
;	O
the_time	double
-=	O
internal_moon_rise_set	function
(	O
event	enum
,	O
day	int
,	O
month	int
,	O
year	int
,	O
coordinates	pointer
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
save_the_mode	int
==	O
38	int
)	O
coordinates	pointer
->	O
the_mode	int
=	O
11	int
;	O
else	O
coordinates	pointer
->	O
the_mode	int
=	O
24	int
;	O
x4	double
=	O
the_time	double
-	O
internal_moon_rise_set	function
(	O
event	enum
,	O
day	int
,	O
month	int
,	O
year	int
,	O
coordinates	pointer
)	O
;	O
if	O
(	O
abs	function
(	O
x4	double
)	O
<=	O
DEGS_PER_12_HOURS	int
)	O
the_time	double
=	O
x4	double
;	O
else	O
if	O
(	O
x4	double
>	O
DEGS_PER_12_HOURS	int
)	O
the_time	double
=	O
-	O
DEGS_PER_24_HOURS	int
+	O
x4	double
;	O
else	O
the_time	double
=	O
DEGS_PER_24_HOURS	int
+	O
x4	double
;	O
}	O
}	O
else	O
the_time	double
=	O
HH2SS	O
(	O
time_offset	double
)	O
;	O
coordinates	pointer
->	O
the_mode	int
=	O
save_the_mode	int
;	O
time_offset	double
=	O
x1	double
;	O
return	O
(	O
the_time	double
)	O
;	O
case	O
0	int
:	O
case	O
1	int
:	O
iter_mt	int
=	O
TRUE	O
;	O
default	O
:	O
longitude	double
=	O
coordinates	pointer
->	O
lon_deg	int
+	O
MM2DEG	O
(	O
coordinates	pointer
->	O
lon_min	int
)	O
+	O
SS2DEG	O
(	O
coordinates	pointer
->	O
lon_sec	int
)	O
;	O
}	O
latitude	double
=	O
TORAD	O
(	O
coordinates	pointer
->	O
lat_deg	int
+	O
MM2DEG	O
(	O
coordinates	pointer
->	O
lat_min	int
)	O
+	O
SS2DEG	O
(	O
coordinates	pointer
->	O
lat_sec	int
)	O
)	O
;	O
if	O
(	O
coordinates	pointer
->	O
meters_above_sea_level	int
>	O
0	int
)	O
geodetic_height	double
=	O
TORAD	O
(	O
0.0347	int
*	O
sqrt	function
(	O
coordinates	pointer
->	O
meters_above_sea_level	int
)	O
)	O
;	O
x1	double
=	O
SS2DAY	O
(	O
delta_t	function
(	O
day	int
,	O
month	int
,	O
year	int
,	O
0	int
,	O
0	int
)	O
)	O
;	O
mjd	double
=	O
mjd_0ut	double
=	O
date2num	function
(	O
day	int
,	O
month	int
,	O
year	int
)	O
+	O
x1	double
-	O
730122.5	int
;	O
if	O
(	O
(	O
coordinates	pointer
->	O
the_mode	int
>=	O
10	int
)	O
&&	O
(	O
coordinates	pointer
->	O
the_mode	int
<=	O
36	int
)	O
)	O
mjd	double
+=	O
(	O
time_offset	double
-	O
MM2DAY	O
(	O
tz_offset	int
)	O
+	O
SS2DAY	O
(	O
delta_t	function
(	O
day	int
,	O
month	int
,	O
year	int
,	O
(	O
int	O
)	O
x2	double
,	O
(	O
int	O
)	O
x4	double
)	O
)	O
-	O
x1	double
)	O
;	O
do	O
{	O
LABEL_sun_iter_mt	O
:	O
local_sidereal_time	double
=	O
FIXANGLE	O
(	O
100.46061837	int
+	O
0.9856472275	int
*	O
mjd	double
+	O
longitude	double
)	O
;	O
jc	double
=	O
mjd	double
/	O
36525.0	int
;	O
obliquity_of_ecliptic	double
=	O
TORAD	O
(	O
FIXANGLE	O
(	O
23.43929111	int
-	O
(	O
0.013004167	int
+	O
(	O
0.00000016389	int
-	O
0.0000005036	int
*	O
jc	double
)	O
*	O
jc	double
)	O
*	O
jc	double
)	O
)	O
;	O
argument_of_perihelion	double
=	O
TORAD	O
(	O
FIXANGLE	O
(	O
282.93735	int
+	O
(	O
0.71953	int
+	O
(	O
0.00046	int
*	O
jc	double
)	O
)	O
*	O
jc	double
)	O
)	O
;	O
mean_anomaly	double
=	O
TORAD	O
(	O
FIXANGLE	O
(	O
357.52910	int
+	O
(	O
35999.05030	int
-	O
(	O
0.0001559	int
+	O
0.00000048	int
*	O
jc	double
)	O
*	O
jc	double
)	O
*	O
jc	double
)	O
)	O
;	O
eccentricity	double
=	O
0.016708617	int
-	O
(	O
0.000042037	int
+	O
(	O
0.0000001236	int
*	O
jc	double
)	O
)	O
*	O
jc	double
;	O
x2	double
=	O
mean_anomaly	double
+	O
eccentricity	double
*	O
sin	function
(	O
mean_anomaly	double
)	O
*	O
(	O
1.0	int
+	O
eccentricity	double
*	O
cos	function
(	O
mean_anomaly	double
)	O
)	O
;	O
do	O
{	O
x1	double
=	O
x2	double
;	O
x2	double
=	O
x1	double
-	O
(	O
x1	double
-	O
eccentricity	double
*	O
sin	function
(	O
x1	double
)	O
-	O
mean_anomaly	double
)	O
/	O
(	O
1.0	int
-	O
eccentricity	double
*	O
cos	function
(	O
x1	double
)	O
)	O
;	O
}	O
while	O
(	O
abs	function
(	O
abs	function
(	O
x1	double
)	O
-	O
abs	function
(	O
x2	double
)	O
)	O
>	O
0.000001	int
)	O
;	O
anomaly_of_eccentric	double
=	O
x2	double
;	O
divisor_term	double
=	O
cos	function
(	O
anomaly_of_eccentric	double
)	O
-	O
eccentricity	double
;	O
true_anomaly	double
=	O
sqrt	function
(	O
1.0	int
-	O
eccentricity	double
*	O
eccentricity	double
)	O
*	O
sin	function
(	O
anomaly_of_eccentric	double
)	O
;	O
distance	double
=	O
sqrt	function
(	O
divisor_term	double
*	O
divisor_term	double
+	O
true_anomaly	double
*	O
true_anomaly	double
)	O
;	O
switch	O
(	O
coordinates	pointer
->	O
the_mode	int
)	O
{	O
case	O
24	int
:	O
return	O
(	O
distance	double
)	O
;	O
case	O
25	int
:	O
return	O
(	O
SS2DEG	O
(	O
8.794	int
)	O
*	O
distance	double
)	O
;	O
case	O
26	int
:	O
return	O
(	O
SS2DEG	O
(	O
959.63	int
)	O
*	O
distance	double
)	O
;	O
default	O
:	O
;	O
}	O
true_anomaly	double
=	O
atan	function
(	O
true_anomaly	double
/	O
divisor_term	double
)	O
;	O
if	O
(	O
divisor_term	double
<	O
0.0	int
)	O
true_anomaly	double
+=	O
MY_PI	int
;	O
ecliptic_longitude	double
=	O
TORAD	O
(	O
FIXANGLE	O
(	O
TODEG	O
(	O
true_anomaly	double
+	O
argument_of_perihelion	double
)	O
+	O
jc	double
-	O
0.00569	int
-	O
0.00479	int
*	O
sin	function
(	O
TORAD	O
(	O
124.90	int
-	O
(	O
1934.134	int
-	O
(	O
0.002063	int
*	O
jc	double
)	O
)	O
*	O
jc	double
)	O
)	O
)	O
)	O
;	O
if	O
(	O
coordinates	pointer
->	O
the_mode	int
==	O
22	int
)	O
return	O
(	O
TODEG	O
(	O
ecliptic_longitude	double
)	O
)	O
;	O
cos_obliquity_of_ecliptic	double
=	O
cos	function
(	O
obliquity_of_ecliptic	double
)	O
;	O
x1	double
=	O
sin	function
(	O
ecliptic_longitude	double
)	O
*	O
distance	double
;	O
xe	double
=	O
cos	function
(	O
ecliptic_longitude	double
)	O
*	O
distance	double
;	O
ye	double
=	O
cos_obliquity_of_ecliptic	double
*	O
x1	double
;	O
right_ascension	double
=	O
FIXANGLE	O
(	O
TODEG	O
(	O
my_atan2	function
(	O
ye	double
,	O
xe	double
)	O
)	O
)	O
;	O
if	O
(	O
coordinates	pointer
->	O
the_mode	int
==	O
23	int
)	O
return	O
(	O
DEG2HH	O
(	O
right_ascension	double
)	O
)	O
;	O
x4	double
=	O
meridian_transit_time	double
;	O
meridian_transit_time	double
=	O
FIXANGLE	O
(	O
right_ascension	double
-	O
local_sidereal_time	double
)	O
;	O
if	O
(	O
coordinates	pointer
->	O
the_mode	int
==	O
32	int
)	O
return	O
(	O
DEG2HH	O
(	O
DEGS_PER_12_HOURS	int
-	O
meridian_transit_time	double
)	O
)	O
;	O
if	O
(	O
iter_mt	int
)	O
{	O
mjd	double
=	O
mjd_0ut	double
+	O
DEG2DAY	O
(	O
meridian_transit_time	double
)	O
;	O
if	O
(	O
abs	function
(	O
abs	function
(	O
meridian_transit_time	double
)	O
-	O
abs	function
(	O
x4	double
)	O
)	O
>	O
0.015	int
)	O
goto	O
LABEL_sun_iter_mt	O
;	O
the_time	double
=	O
meridian_transit_time	double
;	O
break	O
;	O
}	O
sin_obliquity_of_ecliptic	double
=	O
sin	function
(	O
obliquity_of_ecliptic	double
)	O
;	O
ze	double
=	O
sin_obliquity_of_ecliptic	double
*	O
x1	double
;	O
declination	double
=	O
asin	function
(	O
ze	double
/	O
distance	double
)	O
;	O
if	O
(	O
coordinates	pointer
->	O
the_mode	int
==	O
21	int
)	O
return	O
(	O
TODEG	O
(	O
declination	double
)	O
)	O
;	O
sin_latitude	double
=	O
sin	function
(	O
latitude	double
)	O
;	O
cos_latitude	double
=	O
cos	function
(	O
latitude	double
)	O
;	O
if	O
(	O
(	O
coordinates	pointer
->	O
the_mode	int
>=	O
10	int
)	O
&&	O
(	O
coordinates	pointer
->	O
the_mode	int
<=	O
28	int
)	O
)	O
{	O
local_sidereal_time	double
=	O
FIXANGLE	O
(	O
local_sidereal_time	double
+	O
DAY2DEG	O
(	O
time_offset	double
-	O
MM2DAY	O
(	O
tz_offset	int
)	O
)	O
)	O
;	O
switch	O
(	O
coordinates	pointer
->	O
the_mode	int
)	O
{	O
case	O
19	int
:	O
case	O
20	int
:	O
x1	double
=	O
TORAD	O
(	O
FIXANGLE	O
(	O
local_sidereal_time	double
-	O
right_ascension	double
)	O
)	O
;	O
if	O
(	O
coordinates	pointer
->	O
the_mode	int
==	O
19	int
)	O
return	O
(	O
TODEG	O
(	O
asin	function
(	O
sin_latitude	double
*	O
sin	function
(	O
declination	double
)	O
+	O
cos_latitude	double
*	O
cos	function
(	O
declination	double
)	O
*	O
cos	function
(	O
x1	double
)	O
)	O
)	O
)	O
;	O
return	O
(	O
FIXANGLE	O
(	O
TODEG	O
(	O
my_atan2	function
(	O
sin	function
(	O
x1	double
)	O
,	O
sin_latitude	double
*	O
cos	function
(	O
x1	double
)	O
-	O
cos_latitude	double
*	O
tan	function
(	O
declination	double
)	O
)	O
+	O
MY_PI	int
)	O
)	O
)	O
;	O
case	O
28	int
:	O
return	O
(	O
DEG2HH	O
(	O
local_sidereal_time	double
)	O
)	O
;	O
default	O
:	O
x4	double
=	O
gd_latitude2gc_latitude	function
(	O
latitude	double
,	O
(	O
coordinates	pointer
->	O
meters_above_sea_level	int
>	O
0	int
)	O
?	O
coordinates	pointer
->	O
meters_above_sea_level	int
:	O
0	int
,	O
&	O
x3	double
)	O
/	O
EQUATOR_EARTH_RADIUS	int
;	O
x4	double
/=	O
(	O
distance	double
*	O
EARTH_RADII_PER_AU	int
)	O
;	O
x1	double
=	O
cos	function
(	O
x3	double
)	O
*	O
x4	double
;	O
x2	double
=	O
TORAD	O
(	O
local_sidereal_time	double
)	O
;	O
xe	double
-=	O
(	O
cos	function
(	O
x2	double
)	O
*	O
x1	double
)	O
;	O
ye	double
-=	O
(	O
sin	function
(	O
x2	double
)	O
*	O
x1	double
)	O
;	O
ze	double
-=	O
(	O
sin	function
(	O
x3	double
)	O
*	O
x4	double
)	O
;	O
}	O
distance	double
=	O
sqrt	function
(	O
xe	double
*	O
xe	double
+	O
ye	double
*	O
ye	double
+	O
ze	double
*	O
ze	double
)	O
;	O
switch	O
(	O
coordinates	pointer
->	O
the_mode	int
)	O
{	O
case	O
15	int
:	O
return	O
(	O
distance	double
)	O
;	O
case	O
16	int
:	O
return	O
(	O
SS2DEG	O
(	O
8.794	int
)	O
*	O
distance	double
)	O
;	O
case	O
17	int
:	O
return	O
(	O
SS2DEG	O
(	O
959.63	int
)	O
*	O
distance	double
)	O
;	O
default	O
:	O
;	O
}	O
right_ascension	double
=	O
FIXANGLE	O
(	O
TODEG	O
(	O
my_atan2	function
(	O
ye	double
,	O
xe	double
)	O
)	O
)	O
;	O
declination	double
=	O
asin	function
(	O
ze	double
/	O
distance	double
)	O
;	O
if	O
(	O
coordinates	pointer
->	O
the_mode	int
==	O
13	int
)	O
return	O
(	O
FIXANGLE	O
(	O
TODEG	O
(	O
my_atan2	function
(	O
cos_obliquity_of_ecliptic	double
*	O
sin	function
(	O
TORAD	O
(	O
right_ascension	double
)	O
)	O
+	O
sin_obliquity_of_ecliptic	double
*	O
tan	function
(	O
declination	double
)	O
,	O
cos	function
(	O
TORAD	O
(	O
right_ascension	double
)	O
)	O
)	O
)	O
)	O
)	O
;	O
x1	double
=	O
TORAD	O
(	O
FIXANGLE	O
(	O
local_sidereal_time	double
-	O
right_ascension	double
)	O
)	O
;	O
x3	double
=	O
cos	function
(	O
x1	double
)	O
;	O
x2	double
=	O
asin	function
(	O
sin_latitude	double
*	O
sin	function
(	O
declination	double
)	O
+	O
cos_latitude	double
*	O
cos	function
(	O
declination	double
)	O
*	O
x3	double
)	O
;	O
x4	double
=	O
atmospheric_refraction	function
(	O
x2	double
,	O
atm_pressure	double
,	O
atm_temperature	double
)	O
;	O
if	O
(	O
coordinates	pointer
->	O
the_mode	int
==	O
18	int
)	O
return	O
(	O
TODEG	O
(	O
x4	double
)	O
)	O
;	O
x2	double
+=	O
x4	double
;	O
if	O
(	O
x2	double
>	O
MY_HALF_PI	int
)	O
x2	double
=	O
MY_PI	int
-	O
x2	double
;	O
if	O
(	O
coordinates	pointer
->	O
the_mode	int
==	O
10	int
)	O
return	O
(	O
TODEG	O
(	O
x2	double
)	O
)	O
;	O
x3	double
=	O
FIXANGLE	O
(	O
TODEG	O
(	O
my_atan2	function
(	O
sin	function
(	O
x1	double
)	O
,	O
sin_latitude	double
*	O
x3	double
-	O
cos_latitude	double
*	O
tan	function
(	O
declination	double
)	O
)	O
+	O
MY_PI	int
)	O
)	O
;	O
if	O
(	O
coordinates	pointer
->	O
the_mode	int
==	O
11	int
)	O
return	O
(	O
x3	double
)	O
;	O
x3	double
=	O
TORAD	O
(	O
x3	double
)	O
;	O
xe	double
=	O
cos	function
(	O
x2	double
)	O
;	O
ye	double
=	O
sin	function
(	O
x2	double
)	O
;	O
ze	double
=	O
cos	function
(	O
x3	double
)	O
;	O
x1	double
=	O
xe	double
*	O
ze	double
;	O
x2	double
=	O
-	O
xe	double
*	O
sin	function
(	O
x3	double
)	O
;	O
x3	double
=	O
cos_latitude	double
*	O
ye	double
-	O
sin_latitude	double
*	O
x1	double
;	O
if	O
(	O
coordinates	pointer
->	O
the_mode	int
==	O
12	int
)	O
return	O
(	O
TODEG	O
(	O
asin	function
(	O
sin_latitude	double
*	O
ye	double
+	O
cos_latitude	double
*	O
x1	double
)	O
)	O
)	O
;	O
return	O
(	O
DEG2HH	O
(	O
FIXANGLE	O
(	O
local_sidereal_time	double
-	O
TODEG	O
(	O
my_atan2	function
(	O
x2	double
,	O
x3	double
)	O
)	O
)	O
)	O
)	O
;	O
}	O
if	O
(	O
adjust_value	double
!=	O
DEGS_PER_24_HOURS	int
)	O
switch	O
(	O
coordinates	pointer
->	O
the_mode	int
)	O
{	O
case	O
52	int
:	O
case	O
53	int
:	O
x1	double
=	O
adjust_value	double
;	O
break	O
;	O
case	O
3	int
:	O
case	O
5	int
:	O
x1	double
=	O
TORAD	O
(	O
adjust_value	double
-	O
(	O
SS2DEG	O
(	O
959.63	int
)	O
*	O
distance	double
)	O
)	O
;	O
break	O
;	O
default	O
:	O
x1	double
=	O
TORAD	O
(	O
adjust_value	double
)	O
;	O
}	O
else	O
switch	O
(	O
coordinates	pointer
->	O
the_mode	int
)	O
{	O
case	O
2	int
:	O
case	O
4	int
:	O
x1	double
=	O
0.0	int
;	O
break	O
;	O
case	O
3	int
:	O
case	O
5	int
:	O
x1	double
=	O
TORAD	O
(	O
SS2DEG	O
(	O
-	O
959.63	int
)	O
*	O
distance	double
)	O
;	O
break	O
;	O
case	O
6	int
:	O
x1	double
=	O
-	O
0.104719755119659771	int
;	O
break	O
;	O
case	O
7	int
:	O
x1	double
=	O
-	O
0.209439510239319541	int
;	O
break	O
;	O
case	O
8	int
:	O
x1	double
=	O
-	O
0.261799387799149426	int
;	O
break	O
;	O
case	O
9	int
:	O
x1	double
=	O
-	O
0.314159265358979312	int
;	O
break	O
;	O
case	O
52	int
:	O
x1	double
=	O
2.0	int
;	O
break	O
;	O
case	O
53	int
:	O
x1	double
=	O
1.0	int
;	O
}	O
switch	O
(	O
coordinates	pointer
->	O
the_mode	int
)	O
{	O
case	O
52	int
:	O
case	O
53	int
:	O
x2	double
=	O
latitude	double
-	O
declination	double
;	O
if	O
(	O
SGN	O
(	O
latitude	double
)	O
<	O
0	int
)	O
{	O
declination	double
=	O
-	O
declination	double
;	O
if	O
(	O
SGN	O
(	O
x2	double
)	O
<	O
0	int
)	O
x2	double
=	O
-	O
x2	double
;	O
}	O
x2	double
=	O
(	O
sin	function
(	O
my_acot	function
(	O
x1	double
+	O
tan	function
(	O
x2	double
)	O
)	O
-	O
geodetic_height	double
)	O
-	O
abs	function
(	O
sin_latitude	double
)	O
*	O
sin	function
(	O
declination	double
)	O
)	O
/	O
(	O
abs	function
(	O
cos_latitude	double
)	O
*	O
cos	function
(	O
declination	double
)	O
)	O
;	O
break	O
;	O
case	O
4	int
:	O
case	O
5	int
:	O
if	O
(	O
adjust_value	double
!=	O
DEGS_PER_24_HOURS	int
||	O
atm_pressure	double
!=	O
DEFAULT_PRESSURE	int
||	O
atm_temperature	double
!=	O
DEFAULT_TEMPERATURE	int
)	O
x2	double
=	O
atmospheric_refraction	function
(	O
x1	double
,	O
atm_pressure	double
,	O
atm_temperature	double
)	O
;	O
else	O
x2	double
=	O
0.00989019909463453388	int
;	O
x1	double
-=	O
x2	double
;	O
default	O
:	O
x2	double
=	O
(	O
sin	function
(	O
x1	double
-	O
geodetic_height	double
)	O
-	O
sin_latitude	double
*	O
sin	function
(	O
declination	double
)	O
)	O
/	O
(	O
cos_latitude	double
*	O
cos	function
(	O
declination	double
)	O
)	O
;	O
}	O
if	O
(	O
abs	function
(	O
x2	double
)	O
>	O
1.0	int
)	O
{	O
if	O
(	O
n	long
)	O
{	O
if	O
(	O
x2	double
>	O
0.0	int
)	O
return	O
(	O
2	int
*	O
SPECIAL_VALUE	O
)	O
;	O
return	O
(	O
3	int
*	O
SPECIAL_VALUE	O
)	O
;	O
}	O
mjd	double
=	O
mjd_0ut	double
+	O
DEG2DAY	O
(	O
meridian_transit_time	double
)	O
;	O
n	long
++	O
;	O
continue	O
;	O
}	O
x2	double
=	O
TODEG	O
(	O
acos	function
(	O
x2	double
)	O
)	O
;	O
x1	double
=	O
the_time	double
;	O
if	O
(	O
event	enum
==	O
RIse	int
)	O
the_time	double
=	O
meridian_transit_time	double
-	O
x2	double
;	O
else	O
the_time	double
=	O
meridian_transit_time	double
+	O
x2	double
;	O
mjd	double
=	O
mjd_0ut	double
+	O
DEG2DAY	O
(	O
the_time	double
)	O
;	O
}	O
while	O
(	O
abs	function
(	O
abs	function
(	O
the_time	double
)	O
-	O
abs	function
(	O
x1	double
)	O
)	O
>	O
0.015	int
)	O
;	O
the_time	double
+=	O
HH2DEG	O
(	O
MM2HH	O
(	O
tz_offset	int
)	O
)	O
;	O
if	O
(	O
!	O
coordinates	pointer
->	O
the_mode	int
)	O
{	O
x1	double
=	O
time_offset	double
;	O
coordinates	pointer
->	O
the_mode	int
=	O
32	int
;	O
time_offset	double
=	O
DEG2DAY	O
(	O
the_time	double
)	O
;	O
x2	double
=	O
sun_rise_set	function
(	O
event	enum
,	O
is_limited	int
,	O
day	int
,	O
month	int
,	O
year	int
,	O
coordinates	pointer
)	O
;	O
if	O
(	O
the_time	double
>=	O
DEGS_PER_12_HOURS	int
)	O
the_time	double
-=	O
DEGS_PER_12_HOURS	int
;	O
else	O
the_time	double
+=	O
DEGS_PER_12_HOURS	int
;	O
time_offset	double
=	O
DEG2DAY	O
(	O
the_time	double
)	O
;	O
x3	double
=	O
sun_rise_set	function
(	O
event	enum
,	O
is_limited	int
,	O
day	int
,	O
month	int
,	O
year	int
,	O
coordinates	pointer
)	O
;	O
the_time	double
+=	O
HH2DEG	O
(	O
x2	double
-	O
x3	double
)	O
;	O
coordinates	pointer
->	O
the_mode	int
=	O
0	int
;	O
time_offset	double
=	O
x1	double
;	O
}	O
if	O
(	O
is_limited	int
&&	O
(	O
the_time	double
<	O
0.0	int
||	O
the_time	double
>=	O
DEGS_PER_24_HOURS	int
)	O
)	O
return	O
(	O
SPECIAL_VALUE	O
)	O
;	O
while	O
(	O
the_time	double
>=	O
DEGS_PER_24_HOURS	int
)	O
the_time	double
-=	O
DEGS_PER_24_HOURS	int
;	O
while	O
(	O
the_time	double
<	O
0.0	int
)	O
the_time	double
+=	O
DEGS_PER_24_HOURS	int
;	O
return	O
(	O
DEG2HH	O
(	O
the_time	double
)	O
)	O
;	O
}	O
double	O
moon_rise_set	function
(	O
event	enum
,	O
day	int
,	O
month	int
,	O
year	int
,	O
coordinates	pointer
)	O
const	O
Aevent_enum	enum
event	enum
;	O
int	O
day	int
;	O
int	O
month	int
;	O
int	O
year	int
;	O
Coor_struct	struct
*	O
coordinates	pointer
;	O
{	O
auto	O
double	O
the_time	double
;	O
register	O
int	O
tz_offset	int
;	O
tz_offset	int
=	O
SGN	O
(	O
coordinates	pointer
->	O
time_zone_in_mins	int
)	O
*	O
(	O
abs	function
(	O
coordinates	pointer
->	O
time_zone_in_mins	int
)	O
%	O
MINS_PER_DAY	int
)	O
;	O
the_time	double
=	O
internal_moon_rise_set	function
(	O
event	enum
,	O
day	int
,	O
month	int
,	O
year	int
,	O
coordinates	pointer
)	O
;	O
if	O
(	O
tz_offset	int
&&	O
(	O
coordinates	pointer
->	O
the_mode	int
<	O
6	int
)	O
)	O
{	O
if	O
(	O
the_time	double
>	O
SPECIAL_VALUE	O
)	O
{	O
the_time	double
+=	O
MM2HH	O
(	O
tz_offset	int
)	O
;	O
if	O
(	O
the_time	double
<	O
0.0	int
||	O
the_time	double
>=	O
HOURS_PER_DAY	int
)	O
{	O
if	O
(	O
coordinates	pointer
->	O
time_zone_in_mins	int
<	O
0	int
)	O
(	O
void	O
)	O
next_date	function
(	O
&	O
day	int
,	O
&	O
month	int
,	O
&	O
year	int
)	O
;	O
else	O
(	O
void	O
)	O
prev_date	function
(	O
&	O
day	int
,	O
&	O
month	int
,	O
&	O
year	int
)	O
;	O
the_time	double
=	O
internal_moon_rise_set	function
(	O
event	enum
,	O
day	int
,	O
month	int
,	O
year	int
,	O
coordinates	pointer
)	O
;	O
if	O
(	O
the_time	double
<=	O
SPECIAL_VALUE	O
)	O
return	O
(	O
the_time	double
)	O
;	O
the_time	double
+=	O
MM2HH	O
(	O
tz_offset	int
)	O
;	O
if	O
(	O
(	O
the_time	double
>=	O
0.0	int
)	O
&&	O
(	O
the_time	double
<	O
HOURS_PER_DAY	int
)	O
)	O
return	O
(	O
SPECIAL_VALUE	O
)	O
;	O
while	O
(	O
the_time	double
>=	O
HOURS_PER_DAY	int
)	O
the_time	double
-=	O
HOURS_PER_DAY	int
;	O
while	O
(	O
the_time	double
<	O
0.0	int
)	O
the_time	double
+=	O
HOURS_PER_DAY	int
;	O
}	O
}	O
else	O
if	O
(	O
the_time	double
==	O
SPECIAL_VALUE	O
)	O
{	O
if	O
(	O
coordinates	pointer
->	O
time_zone_in_mins	int
<	O
0	int
)	O
(	O
void	O
)	O
next_date	function
(	O
&	O
day	int
,	O
&	O
month	int
,	O
&	O
year	int
)	O
;	O
else	O
(	O
void	O
)	O
prev_date	function
(	O
&	O
day	int
,	O
&	O
month	int
,	O
&	O
year	int
)	O
;	O
the_time	double
=	O
internal_moon_rise_set	function
(	O
event	enum
,	O
day	int
,	O
month	int
,	O
year	int
,	O
coordinates	pointer
)	O
;	O
if	O
(	O
the_time	double
>	O
SPECIAL_VALUE	O
)	O
{	O
the_time	double
+=	O
MM2HH	O
(	O
tz_offset	int
)	O
;	O
if	O
(	O
(	O
the_time	double
>	O
0.0	int
)	O
&&	O
(	O
the_time	double
<=	O
HOURS_PER_DAY	int
)	O
)	O
return	O
(	O
SPECIAL_VALUE	O
)	O
;	O
while	O
(	O
the_time	double
>=	O
HOURS_PER_DAY	int
)	O
the_time	double
-=	O
HOURS_PER_DAY	int
;	O
while	O
(	O
the_time	double
<	O
0.0	int
)	O
the_time	double
+=	O
HOURS_PER_DAY	int
;	O
}	O
}	O
}	O
return	O
(	O
the_time	double
)	O
;	O
}	O
static	O
double	O
internal_moon_rise_set	function
(	O
event	enum
,	O
day	int
,	O
month	int
,	O
year	int
,	O
coordinates	pointer
)	O
const	O
Aevent_enum	enum
event	enum
;	O
int	O
day	int
;	O
int	O
month	int
;	O
int	O
year	int
;	O
Coor_struct	struct
*	O
coordinates	pointer
;	O
{	O
auto	O
double	O
x1	double
=	O
0.0	int
;	O
auto	O
double	O
x2	double
;	O
auto	O
double	O
x3	double
=	O
0.0	int
;	O
auto	O
double	O
x4	double
;	O
auto	O
double	O
longitude	double
;	O
auto	O
double	O
latitude	double
;	O
auto	O
double	O
sin_latitude	double
;	O
auto	O
double	O
cos_latitude	double
;	O
auto	O
double	O
jc	double
;	O
auto	O
double	O
mjd1	double
;	O
auto	O
double	O
mjd1_0ut	double
;	O
auto	O
double	O
mjd2	double
;	O
auto	O
double	O
mjd2_0ut	double
;	O
auto	O
double	O
local_sidereal_time	double
;	O
auto	O
double	O
obliquity_of_ecliptic	double
;	O
auto	O
double	O
sin_obliquity_of_ecliptic	double
;	O
auto	O
double	O
cos_obliquity_of_ecliptic	double
;	O
auto	O
double	O
argument_of_perihelion	double
;	O
auto	O
double	O
sma_sun_mean_anomaly	double
;	O
auto	O
double	O
sma_2	double
;	O
auto	O
double	O
e_eccentricity	double
;	O
auto	O
double	O
e_e	double
;	O
auto	O
double	O
anomaly_of_eccentric	double
;	O
auto	O
double	O
divisor_term	double
;	O
auto	O
double	O
true_anomaly	double
;	O
auto	O
double	O
s_distance	double
;	O
auto	O
double	O
s_longitude	double
;	O
auto	O
double	O
m_longitude	double
;	O
auto	O
double	O
m_mean_longitude	double
;	O
auto	O
double	O
mma_moon_mean_anomaly	double
;	O
auto	O
double	O
mma_2	double
;	O
auto	O
double	O
mma_3	double
;	O
auto	O
double	O
mme_moon_mean_elongation	double
;	O
auto	O
double	O
mme_2	double
;	O
auto	O
double	O
mme_4	double
;	O
auto	O
double	O
m_latitude	double
;	O
auto	O
double	O
m_2_latitude	double
;	O
auto	O
double	O
m_3_latitude	double
;	O
auto	O
double	O
m_parallax	double
;	O
auto	O
double	O
m_semidiameter	double
;	O
auto	O
double	O
m_distance	double
;	O
auto	O
double	O
xg	double
;	O
auto	O
double	O
yg	double
;	O
auto	O
double	O
zg	double
;	O
auto	O
double	O
xe	double
;	O
auto	O
double	O
ye	double
;	O
auto	O
double	O
ze	double
;	O
auto	O
double	O
right_ascension	double
;	O
auto	O
double	O
declination	double
;	O
auto	O
double	O
meridian_transit_time	double
=	O
SECS_PER_DAY	int
;	O
auto	O
double	O
the_time	double
=	O
SECS_PER_DAY	int
;	O
auto	O
double	O
tt	double
=	O
SECS_PER_DAY	int
;	O
auto	O
double	O
geodetic_height	double
=	O
0.0	int
;	O
register	O
int	O
i	int
=	O
0	int
;	O
register	O
int	O
j	int
=	O
0	int
;	O
register	O
int	O
n	long
=	O
0	int
;	O
register	O
int	O
tz_offset	int
;	O
register	O
int	O
save_the_mode	int
;	O
auto	O
Bool	int
ok	int
=	O
FALSE	O
;	O
auto	O
Bool	int
is_adjusted	int
=	O
FALSE	O
;	O
auto	O
Bool	int
iter_mt	int
=	O
FALSE	O
;	O
tz_offset	int
=	O
(	O
int	O
)	O
(	O
SGN	O
(	O
coordinates	pointer
->	O
time_zone_in_mins	int
)	O
*	O
(	O
abs	function
(	O
coordinates	pointer
->	O
time_zone_in_mins	int
)	O
%	O
MINS_PER_DAY	int
)	O
)	O
;	O
x2	double
=	O
DAY2HH	O
(	O
time_offset	double
)	O
;	O
x4	double
=	O
(	O
(	O
int	O
)	O
DAY2MM	O
(	O
time_offset	double
)	O
)	O
%	O
MINS_PER_HOUR	int
;	O
switch	O
(	O
coordinates	pointer
->	O
the_mode	int
)	O
{	O
case	O
0	int
:	O
coordinates	pointer
->	O
the_mode	int
=	O
1	int
;	O
x1	double
=	O
internal_moon_rise_set	function
(	O
event	enum
,	O
day	int
,	O
month	int
,	O
year	int
,	O
coordinates	pointer
)	O
;	O
(	O
void	O
)	O
next_date	function
(	O
&	O
day	int
,	O
&	O
month	int
,	O
&	O
year	int
)	O
;	O
x2	double
=	O
internal_moon_rise_set	function
(	O
event	enum
,	O
day	int
,	O
month	int
,	O
year	int
,	O
coordinates	pointer
)	O
;	O
the_time	double
=	O
x1	double
+	O
(	O
(	O
x2	double
-	O
x1	double
)	O
+	O
HOURS_PER_DAY	int
)	O
*	O
0.5	int
;	O
(	O
void	O
)	O
prev_date	function
(	O
&	O
day	int
,	O
&	O
month	int
,	O
&	O
year	int
)	O
;	O
if	O
(	O
the_time	double
>=	O
HOURS_PER_DAY	int
||	O
x1	double
==	O
SPECIAL_VALUE	O
||	O
x2	double
==	O
SPECIAL_VALUE	O
)	O
{	O
if	O
(	O
x1	double
==	O
SPECIAL_VALUE	O
)	O
x1	double
=	O
x2	double
+	O
HOURS_PER_DAY	int
;	O
(	O
void	O
)	O
prev_date	function
(	O
&	O
day	int
,	O
&	O
month	int
,	O
&	O
year	int
)	O
;	O
x2	double
=	O
internal_moon_rise_set	function
(	O
event	enum
,	O
day	int
,	O
month	int
,	O
year	int
,	O
coordinates	pointer
)	O
;	O
the_time	double
=	O
x2	double
+	O
(	O
(	O
x1	double
-	O
x2	double
)	O
+	O
HOURS_PER_DAY	int
)	O
*	O
0.5	int
;	O
if	O
(	O
the_time	double
<	O
HOURS_PER_DAY	int
)	O
the_time	double
=	O
SPECIAL_VALUE	O
;	O
else	O
{	O
the_time	double
-=	O
HOURS_PER_DAY	int
;	O
(	O
void	O
)	O
next_date	function
(	O
&	O
day	int
,	O
&	O
month	int
,	O
&	O
year	int
)	O
;	O
}	O
}	O
if	O
(	O
the_time	double
!=	O
SPECIAL_VALUE	O
)	O
{	O
x1	double
=	O
time_offset	double
;	O
coordinates	pointer
->	O
the_mode	int
=	O
24	int
;	O
n	long
=	O
0	int
;	O
e_e	double
=	O
MM2DAY	O
(	O
tz_offset	int
)	O
;	O
x3	double
=	O
HH2DAY	O
(	O
the_time	double
)	O
;	O
x4	double
=	O
HHMM2DAY	O
(	O
0	int
,	O
2	int
)	O
;	O
x2	double
=	O
x3	double
-	O
x4	double
;	O
x3	double
+=	O
x4	double
;	O
x4	double
=	O
(	O
x3	double
+	O
x2	double
)	O
*	O
0.5	int
;	O
LOOP	O
{	O
time_offset	double
=	O
x4	double
+	O
e_e	double
;	O
the_time	double
=	O
internal_moon_rise_set	function
(	O
event	enum
,	O
day	int
,	O
month	int
,	O
year	int
,	O
coordinates	pointer
)	O
;	O
the_time	double
=	O
FIXANGLE	O
(	O
the_time	double
+	O
DEGS_PER_06_HOURS	int
)	O
;	O
if	O
(	O
the_time	double
>	O
DEGS_PER_12_HOURS	int
)	O
the_time	double
=	O
-	O
(	O
the_time	double
-	O
DEGS_PER_24_HOURS	int
)	O
;	O
if	O
(	O
abs	function
(	O
DEGS_PER_06_HOURS	int
-	O
the_time	double
)	O
>	O
0.0001	int
)	O
{	O
if	O
(	O
the_time	double
>	O
DEGS_PER_06_HOURS	int
)	O
x3	double
=	O
x4	double
;	O
else	O
x2	double
=	O
x4	double
;	O
x4	double
=	O
(	O
x3	double
+	O
x2	double
)	O
*	O
0.5	int
;	O
}	O
else	O
break	O
;	O
if	O
(	O
++	O
n	long
>=	O
100	int
)	O
my_error	function
(	O
ERR_INTERNAL_C_FUNC_FAILURE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
1L	int
,	O
"internal_moon_rise_set():interpolation<"	pointer
,	O
n	long
)	O
;	O
}	O
the_time	double
=	O
DAY2HH	O
(	O
x4	double
)	O
;	O
time_offset	double
=	O
x1	double
;	O
}	O
coordinates	pointer
->	O
the_mode	int
=	O
0	int
;	O
return	O
(	O
the_time	double
)	O
;	O
case	O
31	int
:	O
return	O
(	O
delta_t	function
(	O
day	int
,	O
month	int
,	O
year	int
,	O
(	O
int	O
)	O
x2	double
,	O
(	O
int	O
)	O
x4	double
)	O
)	O
;	O
case	O
33	int
:	O
return	O
(	O
DAY2HH	O
(	O
time_offset	double
)	O
)	O
;	O
case	O
35	int
:	O
x1	double
=	O
SS2DAY	O
(	O
delta_t	function
(	O
day	int
,	O
month	int
,	O
year	int
,	O
(	O
int	O
)	O
x2	double
,	O
(	O
int	O
)	O
x4	double
)	O
)	O
;	O
case	O
34	int
:	O
return	O
(	O
date2num	function
(	O
day	int
,	O
month	int
,	O
year	int
)	O
+	O
(	O
MIN_BCE_TO_1_CE	int
-	O
1.5	int
)	O
+	O
x1	double
+	O
time_offset	double
)	O
;	O
case	O
36	int
:	O
case	O
37	int
:	O
case	O
38	int
:	O
case	O
39	int
:	O
save_the_mode	int
=	O
coordinates	pointer
->	O
the_mode	int
;	O
switch	O
(	O
save_the_mode	int
)	O
{	O
case	O
36	int
:	O
coordinates	pointer
->	O
the_mode	int
=	O
10	int
;	O
break	O
;	O
case	O
37	int
:	O
coordinates	pointer
->	O
the_mode	int
=	O
11	int
;	O
break	O
;	O
case	O
38	int
:	O
coordinates	pointer
->	O
the_mode	int
=	O
23	int
;	O
break	O
;	O
default	O
:	O
coordinates	pointer
->	O
the_mode	int
=	O
24	int
;	O
break	O
;	O
}	O
the_time	double
=	O
internal_moon_rise_set	function
(	O
event	enum
,	O
day	int
,	O
month	int
,	O
year	int
,	O
coordinates	pointer
)	O
;	O
switch	O
(	O
save_the_mode	int
)	O
{	O
case	O
36	int
:	O
case	O
38	int
:	O
if	O
(	O
save_the_mode	int
==	O
36	int
)	O
coordinates	pointer
->	O
the_mode	int
=	O
10	int
;	O
else	O
coordinates	pointer
->	O
the_mode	int
=	O
19	int
;	O
the_time	double
-=	O
sun_rise_set	function
(	O
event	enum
,	O
FALSE	O
,	O
day	int
,	O
month	int
,	O
year	int
,	O
coordinates	pointer
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
save_the_mode	int
==	O
37	int
)	O
coordinates	pointer
->	O
the_mode	int
=	O
11	int
;	O
else	O
coordinates	pointer
->	O
the_mode	int
=	O
20	int
;	O
x4	double
=	O
the_time	double
-	O
sun_rise_set	function
(	O
event	enum
,	O
FALSE	O
,	O
day	int
,	O
month	int
,	O
year	int
,	O
coordinates	pointer
)	O
;	O
if	O
(	O
abs	function
(	O
x4	double
)	O
<=	O
DEGS_PER_12_HOURS	int
)	O
the_time	double
=	O
x4	double
;	O
else	O
if	O
(	O
x4	double
>	O
DEGS_PER_12_HOURS	int
)	O
the_time	double
=	O
-	O
DEGS_PER_24_HOURS	int
+	O
x4	double
;	O
else	O
the_time	double
=	O
DEGS_PER_24_HOURS	int
+	O
x4	double
;	O
}	O
coordinates	pointer
->	O
the_mode	int
=	O
save_the_mode	int
;	O
return	O
(	O
the_time	double
)	O
;	O
case	O
44	int
:	O
case	O
45	int
:	O
case	O
46	int
:	O
case	O
47	int
:	O
case	O
48	int
:	O
case	O
49	int
:	O
case	O
50	int
:	O
case	O
54	int
:	O
case	O
55	int
:	O
case	O
56	int
:	O
case	O
57	int
:	O
x1	double
=	O
time_offset	double
;	O
save_the_mode	int
=	O
coordinates	pointer
->	O
the_mode	int
;	O
switch	O
(	O
save_the_mode	int
)	O
{	O
case	O
46	int
:	O
coordinates	pointer
->	O
the_mode	int
=	O
5	int
;	O
break	O
;	O
case	O
44	int
:	O
case	O
47	int
:	O
case	O
48	int
:	O
case	O
54	int
:	O
case	O
55	int
:	O
coordinates	pointer
->	O
the_mode	int
=	O
0	int
;	O
break	O
;	O
default	O
:	O
coordinates	pointer
->	O
the_mode	int
=	O
1	int
;	O
}	O
time_offset	double
=	O
moon_rise_set	function
(	O
event	enum
,	O
day	int
,	O
month	int
,	O
year	int
,	O
coordinates	pointer
)	O
;	O
if	O
(	O
time_offset	double
>	O
SPECIAL_VALUE	O
)	O
{	O
time_offset	double
=	O
HH2DAY	O
(	O
time_offset	double
)	O
;	O
if	O
(	O
save_the_mode	int
<=	O
45	int
)	O
{	O
if	O
(	O
save_the_mode	int
==	O
44	int
)	O
coordinates	pointer
->	O
the_mode	int
=	O
0	int
;	O
else	O
coordinates	pointer
->	O
the_mode	int
=	O
1	int
;	O
the_time	double
=	O
sun_rise_set	function
(	O
event	enum
,	O
FALSE	O
,	O
day	int
,	O
month	int
,	O
year	int
,	O
coordinates	pointer
)	O
;	O
if	O
(	O
the_time	double
>	O
SPECIAL_VALUE	O
)	O
the_time	double
=	O
DAY2HH	O
(	O
time_offset	double
)	O
-	O
the_time	double
;	O
else	O
the_time	double
=	O
HH2SS	O
(	O
the_time	double
)	O
;	O
}	O
else	O
if	O
(	O
save_the_mode	int
==	O
46	int
)	O
{	O
coordinates	pointer
->	O
the_mode	int
=	O
5	int
;	O
the_time	double
=	O
sun_rise_set	function
(	O
event	enum
,	O
FALSE	O
,	O
day	int
,	O
month	int
,	O
year	int
,	O
coordinates	pointer
)	O
;	O
if	O
(	O
the_time	double
>	O
SPECIAL_VALUE	O
)	O
the_time	double
=	O
DAY2HH	O
(	O
time_offset	double
)	O
-	O
the_time	double
;	O
else	O
the_time	double
=	O
HH2SS	O
(	O
the_time	double
)	O
;	O
}	O
else	O
{	O
switch	O
(	O
save_the_mode	int
)	O
{	O
case	O
47	int
:	O
case	O
49	int
:	O
coordinates	pointer
->	O
the_mode	int
=	O
10	int
;	O
break	O
;	O
case	O
48	int
:	O
case	O
50	int
:	O
coordinates	pointer
->	O
the_mode	int
=	O
9	int
;	O
break	O
;	O
case	O
54	int
:	O
case	O
56	int
:	O
coordinates	pointer
->	O
the_mode	int
=	O
23	int
;	O
break	O
;	O
default	O
:	O
coordinates	pointer
->	O
the_mode	int
=	O
22	int
;	O
}	O
the_time	double
=	O
moon_rise_set	function
(	O
event	enum
,	O
day	int
,	O
month	int
,	O
year	int
,	O
coordinates	pointer
)	O
;	O
}	O
}	O
else	O
the_time	double
=	O
HH2SS	O
(	O
time_offset	double
)	O
;	O
coordinates	pointer
->	O
the_mode	int
=	O
save_the_mode	int
;	O
time_offset	double
=	O
x1	double
;	O
return	O
(	O
the_time	double
)	O
;	O
case	O
40	int
:	O
case	O
41	int
:	O
case	O
42	int
:	O
case	O
43	int
:	O
case	O
51	int
:	O
case	O
52	int
:	O
case	O
53	int
:	O
case	O
58	int
:	O
case	O
59	int
:	O
case	O
60	int
:	O
x1	double
=	O
time_offset	double
;	O
save_the_mode	int
=	O
coordinates	pointer
->	O
the_mode	int
;	O
coordinates	pointer
->	O
the_mode	int
=	O
5	int
;	O
time_offset	double
=	O
moon_rise_set	function
(	O
event	enum
,	O
day	int
,	O
month	int
,	O
year	int
,	O
coordinates	pointer
)	O
;	O
if	O
(	O
time_offset	double
>	O
SPECIAL_VALUE	O
)	O
{	O
time_offset	double
=	O
HH2DAY	O
(	O
time_offset	double
)	O
;	O
switch	O
(	O
save_the_mode	int
)	O
{	O
case	O
40	int
:	O
case	O
51	int
:	O
coordinates	pointer
->	O
the_mode	int
=	O
10	int
;	O
break	O
;	O
case	O
41	int
:	O
case	O
52	int
:	O
coordinates	pointer
->	O
the_mode	int
=	O
11	int
;	O
break	O
;	O
case	O
53	int
:	O
coordinates	pointer
->	O
the_mode	int
=	O
9	int
;	O
break	O
;	O
case	O
42	int
:	O
case	O
58	int
:	O
coordinates	pointer
->	O
the_mode	int
=	O
23	int
;	O
break	O
;	O
case	O
43	int
:	O
case	O
59	int
:	O
coordinates	pointer
->	O
the_mode	int
=	O
24	int
;	O
break	O
;	O
default	O
:	O
coordinates	pointer
->	O
the_mode	int
=	O
22	int
;	O
}	O
the_time	double
=	O
moon_rise_set	function
(	O
event	enum
,	O
day	int
,	O
month	int
,	O
year	int
,	O
coordinates	pointer
)	O
;	O
if	O
(	O
(	O
save_the_mode	int
>=	O
40	int
)	O
&&	O
(	O
save_the_mode	int
<=	O
43	int
)	O
)	O
switch	O
(	O
save_the_mode	int
)	O
{	O
case	O
40	int
:	O
case	O
42	int
:	O
if	O
(	O
save_the_mode	int
==	O
40	int
)	O
coordinates	pointer
->	O
the_mode	int
=	O
10	int
;	O
else	O
coordinates	pointer
->	O
the_mode	int
=	O
19	int
;	O
the_time	double
-=	O
sun_rise_set	function
(	O
event	enum
,	O
FALSE	O
,	O
day	int
,	O
month	int
,	O
year	int
,	O
coordinates	pointer
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
save_the_mode	int
==	O
41	int
)	O
coordinates	pointer
->	O
the_mode	int
=	O
11	int
;	O
else	O
coordinates	pointer
->	O
the_mode	int
=	O
20	int
;	O
x4	double
=	O
the_time	double
-	O
sun_rise_set	function
(	O
event	enum
,	O
FALSE	O
,	O
day	int
,	O
month	int
,	O
year	int
,	O
coordinates	pointer
)	O
;	O
if	O
(	O
abs	function
(	O
x4	double
)	O
<=	O
DEGS_PER_12_HOURS	int
)	O
the_time	double
=	O
x4	double
;	O
else	O
if	O
(	O
x4	double
>	O
DEGS_PER_12_HOURS	int
)	O
the_time	double
=	O
-	O
DEGS_PER_24_HOURS	int
+	O
x4	double
;	O
else	O
the_time	double
=	O
DEGS_PER_24_HOURS	int
+	O
x4	double
;	O
}	O
}	O
else	O
the_time	double
=	O
HH2SS	O
(	O
time_offset	double
)	O
;	O
coordinates	pointer
->	O
the_mode	int
=	O
save_the_mode	int
;	O
time_offset	double
=	O
x1	double
;	O
return	O
(	O
the_time	double
)	O
;	O
case	O
1	int
:	O
iter_mt	int
=	O
TRUE	O
;	O
default	O
:	O
longitude	double
=	O
coordinates	pointer
->	O
lon_deg	int
+	O
MM2DEG	O
(	O
coordinates	pointer
->	O
lon_min	int
)	O
+	O
SS2DEG	O
(	O
coordinates	pointer
->	O
lon_sec	int
)	O
;	O
}	O
latitude	double
=	O
TORAD	O
(	O
coordinates	pointer
->	O
lat_deg	int
+	O
MM2DEG	O
(	O
coordinates	pointer
->	O
lat_min	int
)	O
+	O
SS2DEG	O
(	O
coordinates	pointer
->	O
lat_sec	int
)	O
)	O
;	O
if	O
(	O
coordinates	pointer
->	O
meters_above_sea_level	int
>	O
0	int
)	O
geodetic_height	double
=	O
TORAD	O
(	O
0.0347	int
*	O
sqrt	function
(	O
coordinates	pointer
->	O
meters_above_sea_level	int
)	O
)	O
;	O
e_e	double
=	O
SS2DAY	O
(	O
delta_t	function
(	O
day	int
,	O
month	int
,	O
year	int
,	O
0	int
,	O
0	int
)	O
)	O
;	O
x1	double
=	O
date2num	function
(	O
day	int
,	O
month	int
,	O
year	int
)	O
+	O
e_e	double
;	O
mjd1	double
=	O
mjd1_0ut	double
=	O
x1	double
-	O
730122.5	int
;	O
mjd2	double
=	O
mjd2_0ut	double
=	O
x1	double
-	O
693597.5	int
;	O
if	O
(	O
(	O
coordinates	pointer
->	O
the_mode	int
>=	O
6	int
)	O
&&	O
(	O
coordinates	pointer
->	O
the_mode	int
<=	O
39	int
)	O
)	O
{	O
x1	double
=	O
time_offset	double
-	O
MM2DAY	O
(	O
tz_offset	int
)	O
+	O
SS2DAY	O
(	O
delta_t	function
(	O
day	int
,	O
month	int
,	O
year	int
,	O
(	O
int	O
)	O
x2	double
,	O
(	O
int	O
)	O
x4	double
)	O
)	O
-	O
e_e	double
;	O
mjd1	double
+=	O
x1	double
;	O
mjd2	double
+=	O
x1	double
;	O
}	O
while	O
(	O
!	O
ok	int
)	O
{	O
do	O
{	O
LABEL_moon_iter_mt	O
:	O
local_sidereal_time	double
=	O
FIXANGLE	O
(	O
100.46061837	int
+	O
0.9856472275	int
*	O
mjd1	double
+	O
longitude	double
)	O
;	O
jc	double
=	O
mjd1	double
/	O
36525.0	int
;	O
obliquity_of_ecliptic	double
=	O
TORAD	O
(	O
FIXANGLE	O
(	O
23.43929111	int
-	O
(	O
0.013004167	int
+	O
(	O
0.00000016389	int
-	O
0.0000005036	int
*	O
jc	double
)	O
*	O
jc	double
)	O
*	O
jc	double
)	O
)	O
;	O
argument_of_perihelion	double
=	O
TORAD	O
(	O
FIXANGLE	O
(	O
282.93735	int
+	O
(	O
0.71953	int
+	O
(	O
0.00046	int
*	O
jc	double
)	O
)	O
*	O
jc	double
)	O
)	O
;	O
sma_sun_mean_anomaly	double
=	O
TORAD	O
(	O
FIXANGLE	O
(	O
357.52910	int
+	O
(	O
35999.05030	int
-	O
(	O
0.0001559	int
+	O
0.00000048	int
*	O
jc	double
)	O
*	O
jc	double
)	O
*	O
jc	double
)	O
)	O
;	O
e_eccentricity	double
=	O
0.016708617	int
-	O
(	O
0.000042037	int
+	O
(	O
0.0000001236	int
*	O
jc	double
)	O
)	O
*	O
jc	double
;	O
x2	double
=	O
sma_sun_mean_anomaly	double
+	O
e_eccentricity	double
*	O
sin	function
(	O
sma_sun_mean_anomaly	double
)	O
*	O
(	O
1.0	int
+	O
e_eccentricity	double
*	O
cos	function
(	O
sma_sun_mean_anomaly	double
)	O
)	O
;	O
do	O
{	O
x1	double
=	O
x2	double
;	O
x2	double
=	O
x1	double
-	O
(	O
x1	double
-	O
e_eccentricity	double
*	O
sin	function
(	O
x1	double
)	O
-	O
sma_sun_mean_anomaly	double
)	O
/	O
(	O
1.0	int
-	O
e_eccentricity	double
*	O
cos	function
(	O
x1	double
)	O
)	O
;	O
}	O
while	O
(	O
abs	function
(	O
abs	function
(	O
x1	double
)	O
-	O
abs	function
(	O
x2	double
)	O
)	O
>	O
0.000001	int
)	O
;	O
anomaly_of_eccentric	double
=	O
x2	double
;	O
divisor_term	double
=	O
cos	function
(	O
anomaly_of_eccentric	double
)	O
-	O
e_eccentricity	double
;	O
s_distance	double
=	O
sqrt	function
(	O
1.0	int
-	O
e_eccentricity	double
*	O
e_eccentricity	double
)	O
*	O
sin	function
(	O
anomaly_of_eccentric	double
)	O
;	O
true_anomaly	double
=	O
atan	function
(	O
s_distance	double
/	O
divisor_term	double
)	O
;	O
if	O
(	O
divisor_term	double
<	O
0.0	int
)	O
true_anomaly	double
+=	O
MY_PI	int
;	O
s_longitude	double
=	O
TORAD	O
(	O
FIXANGLE	O
(	O
TODEG	O
(	O
true_anomaly	double
+	O
argument_of_perihelion	double
)	O
+	O
jc	double
-	O
0.00569	int
-	O
0.00479	int
*	O
sin	function
(	O
TORAD	O
(	O
124.90	int
-	O
(	O
1934.134	int
-	O
(	O
0.002063	int
*	O
jc	double
)	O
)	O
*	O
jc	double
)	O
)	O
)	O
)	O
;	O
jc	double
=	O
mjd2	double
/	O
36525.0	int
;	O
x1	double
=	O
sin	function
(	O
TORAD	O
(	O
FIXANGLE	O
(	O
51.2	int
+	O
20.2	int
*	O
jc	double
)	O
)	O
)	O
;	O
x2	double
=	O
0.0039640	int
*	O
sin	function
(	O
TORAD	O
(	O
FIXANGLE	O
(	O
346.560	int
+	O
(	O
132.870	int
-	O
(	O
0.0091731	int
*	O
jc	double
)	O
)	O
*	O
jc	double
)	O
)	O
)	O
;	O
m_longitude	double
=	O
TORAD	O
(	O
FIXANGLE	O
(	O
259.183275	int
-	O
(	O
1934.142	int
-	O
(	O
0.002078	int
+	O
0.0000022	int
*	O
jc	double
)	O
*	O
jc	double
)	O
*	O
jc	double
)	O
)	O
;	O
x3	double
=	O
sin	function
(	O
m_longitude	double
)	O
;	O
x4	double
=	O
TORAD	O
(	O
275.05	int
-	O
2.30	int
*	O
jc	double
)	O
;	O
m_mean_longitude	double
=	O
FIXANGLE	O
(	O
270.434164	int
+	O
(	O
481267.8831	int
-	O
(	O
0.001133	int
-	O
0.0000019	int
*	O
jc	double
)	O
*	O
jc	double
)	O
*	O
jc	double
+	O
0.000233	int
*	O
x1	double
+	O
x2	double
+	O
0.001964	int
*	O
x3	double
)	O
;	O
mma_moon_mean_anomaly	double
=	O
TORAD	O
(	O
FIXANGLE	O
(	O
296.104608	int
+	O
(	O
477198.8491	int
+	O
(	O
0.009192	int
+	O
0.0000144	int
*	O
jc	double
)	O
*	O
jc	double
)	O
*	O
jc	double
+	O
0.000817	int
*	O
x1	double
+	O
x2	double
+	O
0.002541	int
*	O
x3	double
)	O
)	O
;	O
mme_moon_mean_elongation	double
=	O
TORAD	O
(	O
FIXANGLE	O
(	O
350.737486	int
+	O
(	O
445267.1142	int
-	O
(	O
0.001436	int
-	O
0.0000019	int
*	O
jc	double
)	O
*	O
jc	double
)	O
*	O
jc	double
+	O
0.002011	int
*	O
x1	double
+	O
x2	double
+	O
0.001964	int
*	O
x3	double
)	O
)	O
;	O
m_latitude	double
=	O
TORAD	O
(	O
FIXANGLE	O
(	O
11.250889	int
+	O
(	O
483202.0251	int
-	O
(	O
0.003211	int
+	O
0.0000003	int
*	O
jc	double
)	O
*	O
jc	double
)	O
*	O
jc	double
+	O
x2	double
-	O
0.024691	int
*	O
x3	double
-	O
0.004328	int
*	O
sin	function
(	O
m_longitude	double
+	O
x4	double
)	O
)	O
)	O
;	O
e_eccentricity	double
=	O
1.0	int
-	O
(	O
0.002495	int
+	O
(	O
0.00000752	int
*	O
jc	double
)	O
)	O
*	O
jc	double
;	O
mme_2	double
=	O
2.0	int
*	O
mme_moon_mean_elongation	double
;	O
mme_4	double
=	O
4.0	int
*	O
mme_moon_mean_elongation	double
;	O
sma_2	double
=	O
2.0	int
*	O
sma_sun_mean_anomaly	double
;	O
mma_2	double
=	O
2.0	int
*	O
mma_moon_mean_anomaly	double
;	O
mma_3	double
=	O
3.0	int
*	O
mma_moon_mean_anomaly	double
;	O
m_2_latitude	double
=	O
2.0	int
*	O
m_latitude	double
;	O
m_3_latitude	double
=	O
3.0	int
*	O
m_latitude	double
;	O
e_e	double
=	O
e_eccentricity	double
*	O
e_eccentricity	double
;	O
zg	double
=	O
m_latitude	double
+	O
mme_4	double
;	O
yg	double
=	O
mme_4	double
-	O
m_latitude	double
;	O
xg	double
=	O
mme_2	double
-	O
m_latitude	double
;	O
ze	double
=	O
mme_2	double
+	O
m_latitude	double
;	O
ye	double
=	O
mme_4	double
-	O
mma_moon_mean_anomaly	double
;	O
xe	double
=	O
mme_4	double
-	O
sma_sun_mean_anomaly	double
;	O
x1	double
=	O
mme_2	double
-	O
sma_sun_mean_anomaly	double
;	O
x2	double
=	O
mme_2	double
-	O
mma_moon_mean_anomaly	double
;	O
m_parallax	double
=	O
0.950724	int
+	O
0.051818	int
*	O
cos	function
(	O
mma_moon_mean_anomaly	double
)	O
+	O
0.009531	int
*	O
cos	function
(	O
x2	double
)	O
+	O
0.007843	int
*	O
cos	function
(	O
mme_2	double
)	O
+	O
0.002824	int
*	O
cos	function
(	O
mma_2	double
)	O
+	O
0.000857	int
*	O
cos	function
(	O
mme_2	double
+	O
mma_moon_mean_anomaly	double
)	O
+	O
0.000533	int
*	O
cos	function
(	O
x1	double
)	O
*	O
e_eccentricity	double
+	O
0.000401	int
*	O
cos	function
(	O
x1	double
-	O
mma_moon_mean_anomaly	double
)	O
*	O
e_eccentricity	double
+	O
0.000320	int
*	O
cos	function
(	O
mma_moon_mean_anomaly	double
-	O
sma_sun_mean_anomaly	double
)	O
*	O
e_eccentricity	double
-	O
0.000271	int
*	O
cos	function
(	O
mme_moon_mean_elongation	double
)	O
-	O
0.000264	int
*	O
cos	function
(	O
sma_sun_mean_anomaly	double
+	O
mma_moon_mean_anomaly	double
)	O
*	O
e_eccentricity	double
-	O
0.000198	int
*	O
cos	function
(	O
m_2_latitude	double
-	O
mma_moon_mean_anomaly	double
)	O
+	O
0.000173	int
*	O
cos	function
(	O
mma_3	double
)	O
+	O
0.000167	int
*	O
cos	function
(	O
ye	double
)	O
-	O
0.000111	int
*	O
cos	function
(	O
sma_sun_mean_anomaly	double
)	O
*	O
e_eccentricity	double
+	O
0.000103	int
*	O
cos	function
(	O
mme_4	double
-	O
mma_2	double
)	O
-	O
0.000084	int
*	O
cos	function
(	O
mma_2	double
-	O
mme_2	double
)	O
-	O
0.000083	int
*	O
cos	function
(	O
mme_2	double
+	O
sma_sun_mean_anomaly	double
)	O
*	O
e_eccentricity	double
+	O
0.000079	int
*	O
cos	function
(	O
mme_2	double
+	O
mma_2	double
)	O
+	O
0.000072	int
*	O
cos	function
(	O
mme_4	double
)	O
+	O
0.000064	int
*	O
cos	function
(	O
x1	double
+	O
mma_moon_mean_anomaly	double
)	O
*	O
e_eccentricity	double
-	O
0.000063	int
*	O
cos	function
(	O
mme_2	double
+	O
sma_sun_mean_anomaly	double
-	O
mma_moon_mean_anomaly	double
)	O
*	O
e_eccentricity	double
+	O
0.000041	int
*	O
cos	function
(	O
sma_sun_mean_anomaly	double
+	O
mme_moon_mean_elongation	double
)	O
*	O
e_eccentricity	double
+	O
0.000035	int
*	O
cos	function
(	O
mma_2	double
-	O
sma_sun_mean_anomaly	double
)	O
*	O
e_eccentricity	double
-	O
0.000033	int
*	O
cos	function
(	O
mma_3	double
-	O
mme_2	double
)	O
-	O
0.000030	int
*	O
cos	function
(	O
mma_moon_mean_anomaly	double
+	O
mme_moon_mean_elongation	double
)	O
-	O
0.000029	int
*	O
cos	function
(	O
m_2_latitude	double
-	O
mme_2	double
)	O
-	O
0.000029	int
*	O
cos	function
(	O
mma_2	double
+	O
sma_sun_mean_anomaly	double
)	O
*	O
e_eccentricity	double
+	O
0.000026	int
*	O
cos	function
(	O
mme_2	double
-	O
sma_2	double
)	O
*	O
e_e	double
-	O
0.000023	int
*	O
cos	function
(	O
m_2_latitude	double
-	O
mme_2	double
+	O
mma_moon_mean_anomaly	double
)	O
+	O
0.000019	int
*	O
cos	function
(	O
xe	double
-	O
mma_moon_mean_anomaly	double
)	O
*	O
e_eccentricity	double
;	O
if	O
(	O
coordinates	pointer
->	O
the_mode	int
==	O
19	int
)	O
return	O
(	O
m_parallax	double
)	O
;	O
m_parallax	double
=	O
TORAD	O
(	O
m_parallax	double
)	O
;	O
m_distance	double
=	O
1.0	int
/	O
sin	function
(	O
m_parallax	double
)	O
;	O
if	O
(	O
coordinates	pointer
->	O
the_mode	int
==	O
29	int
)	O
return	O
(	O
m_distance	double
)	O
;	O
m_semidiameter	double
=	O
SS2DEG	O
(	O
936.85	int
*	O
60.0	int
/	O
m_distance	double
)	O
;	O
if	O
(	O
coordinates	pointer
->	O
the_mode	int
==	O
20	int
)	O
return	O
(	O
m_semidiameter	double
)	O
;	O
m_latitude	double
=	O
5.128189	int
*	O
sin	function
(	O
m_latitude	double
)	O
+	O
0.280606	int
*	O
sin	function
(	O
mma_moon_mean_anomaly	double
+	O
m_latitude	double
)	O
+	O
0.277693	int
*	O
sin	function
(	O
mma_moon_mean_anomaly	double
-	O
m_latitude	double
)	O
+	O
0.173238	int
*	O
sin	function
(	O
xg	double
)	O
+	O
0.055413	int
*	O
sin	function
(	O
ze	double
-	O
mma_moon_mean_anomaly	double
)	O
+	O
0.046272	int
*	O
sin	function
(	O
xg	double
-	O
mma_moon_mean_anomaly	double
)	O
+	O
0.032573	int
*	O
sin	function
(	O
ze	double
)	O
+	O
0.017198	int
*	O
sin	function
(	O
mma_2	double
+	O
m_latitude	double
)	O
+	O
0.009267	int
*	O
sin	function
(	O
mme_2	double
+	O
mma_moon_mean_anomaly	double
-	O
m_latitude	double
)	O
+	O
0.008823	int
*	O
sin	function
(	O
mma_2	double
-	O
m_latitude	double
)	O
+	O
0.008247	int
*	O
sin	function
(	O
x1	double
-	O
m_latitude	double
)	O
*	O
e_eccentricity	double
+	O
0.004323	int
*	O
sin	function
(	O
xg	double
-	O
mma_2	double
)	O
+	O
0.004200	int
*	O
sin	function
(	O
ze	double
+	O
mma_moon_mean_anomaly	double
)	O
+	O
0.003372	int
*	O
sin	function
(	O
m_latitude	double
-	O
sma_sun_mean_anomaly	double
-	O
mme_2	double
)	O
*	O
e_eccentricity	double
+	O
0.002472	int
*	O
sin	function
(	O
ze	double
-	O
sma_sun_mean_anomaly	double
-	O
mma_moon_mean_anomaly	double
)	O
*	O
e_eccentricity	double
+	O
0.002222	int
*	O
sin	function
(	O
ze	double
-	O
sma_sun_mean_anomaly	double
)	O
*	O
e_eccentricity	double
+	O
0.002072	int
*	O
sin	function
(	O
xg	double
-	O
sma_sun_mean_anomaly	double
-	O
mma_moon_mean_anomaly	double
)	O
*	O
e_eccentricity	double
+	O
0.001877	int
*	O
sin	function
(	O
m_latitude	double
-	O
sma_sun_mean_anomaly	double
+	O
mma_moon_mean_anomaly	double
)	O
*	O
e_eccentricity	double
+	O
0.001828	int
*	O
sin	function
(	O
yg	double
-	O
mma_moon_mean_anomaly	double
)	O
-	O
0.001803	int
*	O
sin	function
(	O
m_latitude	double
+	O
sma_sun_mean_anomaly	double
)	O
*	O
e_eccentricity	double
-	O
0.001750	int
*	O
sin	function
(	O
m_3_latitude	double
)	O
+	O
0.001570	int
*	O
sin	function
(	O
mma_moon_mean_anomaly	double
-	O
sma_sun_mean_anomaly	double
-	O
m_latitude	double
)	O
*	O
e_eccentricity	double
-	O
0.001487	int
*	O
sin	function
(	O
m_latitude	double
+	O
mme_moon_mean_elongation	double
)	O
-	O
0.001481	int
*	O
sin	function
(	O
m_latitude	double
+	O
sma_sun_mean_anomaly	double
+	O
mma_moon_mean_anomaly	double
)	O
*	O
e_eccentricity	double
+	O
0.001417	int
*	O
sin	function
(	O
m_latitude	double
-	O
sma_sun_mean_anomaly	double
-	O
mma_moon_mean_anomaly	double
)	O
*	O
e_eccentricity	double
+	O
0.001350	int
*	O
sin	function
(	O
m_latitude	double
-	O
sma_sun_mean_anomaly	double
)	O
*	O
e_eccentricity	double
+	O
0.001330	int
*	O
sin	function
(	O
m_latitude	double
-	O
mme_moon_mean_elongation	double
)	O
+	O
0.001106	int
*	O
sin	function
(	O
m_latitude	double
+	O
mma_3	double
)	O
+	O
0.001020	int
*	O
sin	function
(	O
yg	double
)	O
+	O
0.000833	int
*	O
sin	function
(	O
zg	double
-	O
mma_moon_mean_anomaly	double
)	O
+	O
0.000781	int
*	O
sin	function
(	O
mma_moon_mean_anomaly	double
-	O
m_3_latitude	double
)	O
+	O
0.000670	int
*	O
sin	function
(	O
zg	double
-	O
mma_2	double
)	O
+	O
0.000606	int
*	O
sin	function
(	O
mme_2	double
-	O
m_3_latitude	double
)	O
+	O
0.000597	int
*	O
sin	function
(	O
mme_2	double
+	O
mma_2	double
-	O
m_latitude	double
)	O
+	O
0.000492	int
*	O
sin	function
(	O
mme_2	double
+	O
mma_moon_mean_anomaly	double
-	O
sma_sun_mean_anomaly	double
-	O
m_latitude	double
)	O
*	O
e_eccentricity	double
+	O
0.000450	int
*	O
sin	function
(	O
mma_2	double
-	O
m_latitude	double
-	O
mme_2	double
)	O
+	O
0.000439	int
*	O
sin	function
(	O
mma_3	double
-	O
m_latitude	double
)	O
+	O
0.000423	int
*	O
sin	function
(	O
m_latitude	double
+	O
mme_2	double
+	O
mma_2	double
)	O
+	O
0.000422	int
*	O
sin	function
(	O
xg	double
-	O
mma_3	double
)	O
-	O
0.000367	int
*	O
sin	function
(	O
sma_sun_mean_anomaly	double
+	O
m_latitude	double
+	O
mme_2	double
-	O
mma_moon_mean_anomaly	double
)	O
*	O
e_eccentricity	double
-	O
0.000353	int
*	O
sin	function
(	O
sma_sun_mean_anomaly	double
+	O
m_latitude	double
+	O
mme_2	double
)	O
*	O
e_eccentricity	double
+	O
0.000331	int
*	O
sin	function
(	O
zg	double
)	O
+	O
0.000317	int
*	O
sin	function
(	O
ze	double
-	O
sma_sun_mean_anomaly	double
+	O
mma_moon_mean_anomaly	double
)	O
*	O
e_eccentricity	double
+	O
0.000306	int
*	O
sin	function
(	O
mme_2	double
-	O
sma_2	double
-	O
m_latitude	double
)	O
*	O
e_e	double
-	O
0.000283	int
*	O
sin	function
(	O
mma_moon_mean_anomaly	double
+	O
m_3_latitude	double
)	O
*	O
(	O
1.0	int
-	O
(	O
0.0004664	int
*	O
cos	function
(	O
m_longitude	double
)	O
)	O
-	O
(	O
0.0000754	int
*	O
cos	function
(	O
m_longitude	double
+	O
x4	double
)	O
)	O
)	O
;	O
m_latitude	double
=	O
TORAD	O
(	O
m_latitude	double
)	O
;	O
if	O
(	O
m_latitude	double
<	O
0.0	int
)	O
m_latitude	double
-=	O
(	O
jc	double
*	O
0.0000111	int
)	O
;	O
else	O
m_latitude	double
+=	O
(	O
jc	double
*	O
0.0000111	int
)	O
;	O
if	O
(	O
coordinates	pointer
->	O
the_mode	int
==	O
27	int
)	O
return	O
(	O
TODEG	O
(	O
m_latitude	double
)	O
)	O
;	O
m_longitude	double
=	O
m_mean_longitude	double
+	O
6.288750	int
*	O
sin	function
(	O
mma_moon_mean_anomaly	double
)	O
+	O
1.274018	int
*	O
sin	function
(	O
x2	double
)	O
+	O
0.658309	int
*	O
sin	function
(	O
mme_2	double
)	O
+	O
0.213616	int
*	O
sin	function
(	O
mma_2	double
)	O
-	O
0.185596	int
*	O
sin	function
(	O
sma_sun_mean_anomaly	double
)	O
*	O
e_eccentricity	double
-	O
0.114336	int
*	O
sin	function
(	O
m_2_latitude	double
)	O
+	O
0.058793	int
*	O
sin	function
(	O
mme_2	double
-	O
mma_2	double
)	O
+	O
0.057212	int
*	O
sin	function
(	O
x1	double
-	O
mma_moon_mean_anomaly	double
)	O
*	O
e_eccentricity	double
+	O
0.053320	int
*	O
sin	function
(	O
mme_2	double
+	O
mma_moon_mean_anomaly	double
)	O
+	O
0.045874	int
*	O
sin	function
(	O
x1	double
)	O
*	O
e_eccentricity	double
+	O
0.041024	int
*	O
sin	function
(	O
mma_moon_mean_anomaly	double
-	O
sma_sun_mean_anomaly	double
)	O
*	O
e_eccentricity	double
-	O
0.034718	int
*	O
sin	function
(	O
mme_moon_mean_elongation	double
)	O
-	O
0.030465	int
*	O
sin	function
(	O
sma_sun_mean_anomaly	double
+	O
mma_moon_mean_anomaly	double
)	O
*	O
e_eccentricity	double
+	O
0.015326	int
*	O
sin	function
(	O
mme_2	double
-	O
m_2_latitude	double
)	O
-	O
0.012528	int
*	O
sin	function
(	O
m_2_latitude	double
+	O
mma_moon_mean_anomaly	double
)	O
-	O
0.010980	int
*	O
sin	function
(	O
m_2_latitude	double
-	O
mma_moon_mean_anomaly	double
)	O
+	O
0.010674	int
*	O
sin	function
(	O
ye	double
)	O
+	O
0.010034	int
*	O
sin	function
(	O
mma_3	double
)	O
+	O
0.008548	int
*	O
sin	function
(	O
mme_4	double
-	O
mma_2	double
)	O
-	O
0.007910	int
*	O
sin	function
(	O
sma_sun_mean_anomaly	double
-	O
mma_moon_mean_anomaly	double
+	O
mme_2	double
)	O
*	O
e_eccentricity	double
-	O
0.006783	int
*	O
sin	function
(	O
mme_2	double
+	O
sma_sun_mean_anomaly	double
)	O
*	O
e_eccentricity	double
+	O
0.005162	int
*	O
sin	function
(	O
mma_moon_mean_anomaly	double
-	O
mme_moon_mean_elongation	double
)	O
+	O
0.005000	int
*	O
sin	function
(	O
sma_sun_mean_anomaly	double
+	O
mme_moon_mean_elongation	double
)	O
*	O
e_eccentricity	double
+	O
0.004049	int
*	O
sin	function
(	O
mma_moon_mean_anomaly	double
-	O
sma_sun_mean_anomaly	double
+	O
mme_2	double
)	O
*	O
e_eccentricity	double
+	O
0.003996	int
*	O
sin	function
(	O
mma_2	double
+	O
mme_2	double
)	O
+	O
0.003862	int
*	O
sin	function
(	O
mme_4	double
)	O
+	O
0.003665	int
*	O
sin	function
(	O
mme_2	double
-	O
mma_3	double
)	O
+	O
0.002695	int
*	O
sin	function
(	O
mma_2	double
-	O
sma_sun_mean_anomaly	double
)	O
*	O
e_eccentricity	double
+	O
0.002602	int
*	O
sin	function
(	O
mma_moon_mean_anomaly	double
-	O
m_2_latitude	double
-	O
mme_2	double
)	O
+	O
0.002396	int
*	O
sin	function
(	O
x1	double
-	O
mma_2	double
)	O
*	O
e_eccentricity	double
-	O
0.002349	int
*	O
sin	function
(	O
mma_moon_mean_anomaly	double
+	O
mme_moon_mean_elongation	double
)	O
+	O
0.002249	int
*	O
sin	function
(	O
mme_2	double
-	O
sma_2	double
)	O
*	O
e_e	double
-	O
0.002125	int
*	O
sin	function
(	O
mma_2	double
+	O
sma_sun_mean_anomaly	double
)	O
*	O
e_eccentricity	double
-	O
0.002079	int
*	O
sin	function
(	O
sma_2	double
)	O
*	O
e_e	double
+	O
0.002059	int
*	O
sin	function
(	O
x2	double
-	O
sma_2	double
)	O
*	O
e_e	double
-	O
0.001773	int
*	O
sin	function
(	O
mma_moon_mean_anomaly	double
+	O
mme_2	double
-	O
m_2_latitude	double
)	O
-	O
0.001595	int
*	O
sin	function
(	O
m_2_latitude	double
+	O
mme_2	double
)	O
+	O
0.001220	int
*	O
sin	function
(	O
xe	double
-	O
mma_moon_mean_anomaly	double
)	O
*	O
e_eccentricity	double
-	O
0.001110	int
*	O
sin	function
(	O
mma_2	double
+	O
m_2_latitude	double
)	O
+	O
0.000892	int
*	O
sin	function
(	O
mma_moon_mean_anomaly	double
-	O
3.0	int
*	O
mme_moon_mean_elongation	double
)	O
-	O
0.000811	int
*	O
sin	function
(	O
sma_sun_mean_anomaly	double
+	O
mma_moon_mean_anomaly	double
+	O
mme_2	double
)	O
*	O
e_eccentricity	double
+	O
0.000761	int
*	O
sin	function
(	O
xe	double
-	O
mma_2	double
)	O
*	O
e_eccentricity	double
+	O
0.000717	int
*	O
sin	function
(	O
mma_moon_mean_anomaly	double
-	O
sma_2	double
)	O
*	O
e_e	double
+	O
0.000704	int
*	O
sin	function
(	O
mma_moon_mean_anomaly	double
-	O
sma_2	double
-	O
mme_2	double
)	O
*	O
e_e	double
+	O
0.000693	int
*	O
sin	function
(	O
sma_sun_mean_anomaly	double
-	O
mma_2	double
+	O
mme_2	double
)	O
*	O
e_eccentricity	double
+	O
0.000598	int
*	O
sin	function
(	O
x1	double
-	O
m_2_latitude	double
)	O
*	O
e_eccentricity	double
+	O
0.000550	int
*	O
sin	function
(	O
mma_moon_mean_anomaly	double
+	O
mme_4	double
)	O
+	O
0.000538	int
*	O
sin	function
(	O
4.0	int
*	O
mma_moon_mean_anomaly	double
)	O
+	O
0.000521	int
*	O
sin	function
(	O
xe	double
)	O
*	O
e_eccentricity	double
+	O
0.000486	int
*	O
sin	function
(	O
mma_2	double
-	O
mme_moon_mean_elongation	double
)	O
+	O
SS2DEG	O
(	O
-	O
17.2	int
*	O
x3	double
-	O
1.3	int
*	O
sin	function
(	O
2.0	int
*	O
TORAD	O
(	O
FIXANGLE	O
(	O
279.6967	int
+	O
(	O
36000.7689	int
+	O
(	O
0.000303	int
*	O
jc	double
)	O
)	O
*	O
jc	double
)	O
)	O
)	O
)	O
-	O
0.0005915	int
*	O
jc	double
*	O
jc	double
;	O
m_longitude	double
=	O
FIXANGLE	O
(	O
m_longitude	double
)	O
;	O
if	O
(	O
coordinates	pointer
->	O
the_mode	int
==	O
26	int
)	O
return	O
(	O
m_longitude	double
)	O
;	O
m_longitude	double
=	O
TORAD	O
(	O
m_longitude	double
)	O
;	O
x4	double
=	O
acos	function
(	O
cos	function
(	O
s_longitude	double
-	O
m_longitude	double
)	O
*	O
cos	function
(	O
m_latitude	double
)	O
)	O
;	O
if	O
(	O
coordinates	pointer
->	O
the_mode	int
==	O
30	int
)	O
return	O
(	O
TODEG	O
(	O
x4	double
)	O
)	O
;	O
x1	double
=	O
cos	function
(	O
m_latitude	double
)	O
*	O
m_distance	double
;	O
xg	double
=	O
cos	function
(	O
m_longitude	double
)	O
*	O
x1	double
;	O
yg	double
=	O
sin	function
(	O
m_longitude	double
)	O
*	O
x1	double
;	O
zg	double
=	O
sin	function
(	O
m_latitude	double
)	O
*	O
m_distance	double
;	O
sin_obliquity_of_ecliptic	double
=	O
sin	function
(	O
obliquity_of_ecliptic	double
)	O
;	O
cos_obliquity_of_ecliptic	double
=	O
cos	function
(	O
obliquity_of_ecliptic	double
)	O
;	O
xe	double
=	O
xg	double
;	O
ye	double
=	O
cos_obliquity_of_ecliptic	double
*	O
yg	double
-	O
sin_obliquity_of_ecliptic	double
*	O
zg	double
;	O
ze	double
=	O
sin_obliquity_of_ecliptic	double
*	O
yg	double
+	O
cos_obliquity_of_ecliptic	double
*	O
zg	double
;	O
right_ascension	double
=	O
FIXANGLE	O
(	O
TODEG	O
(	O
my_atan2	function
(	O
ye	double
,	O
xe	double
)	O
)	O
)	O
;	O
if	O
(	O
coordinates	pointer
->	O
the_mode	int
==	O
28	int
)	O
return	O
(	O
DEG2HH	O
(	O
right_ascension	double
)	O
)	O
;	O
declination	double
=	O
asin	function
(	O
ze	double
/	O
m_distance	double
)	O
;	O
if	O
(	O
coordinates	pointer
->	O
the_mode	int
==	O
25	int
)	O
return	O
(	O
TODEG	O
(	O
declination	double
)	O
)	O
;	O
sin_latitude	double
=	O
sin	function
(	O
latitude	double
)	O
;	O
cos_latitude	double
=	O
cos	function
(	O
latitude	double
)	O
;	O
if	O
(	O
coordinates	pointer
->	O
the_mode	int
>=	O
6	int
)	O
{	O
local_sidereal_time	double
=	O
FIXANGLE	O
(	O
local_sidereal_time	double
+	O
DAY2DEG	O
(	O
time_offset	double
-	O
MM2DAY	O
(	O
tz_offset	int
)	O
)	O
)	O
;	O
switch	O
(	O
coordinates	pointer
->	O
the_mode	int
)	O
{	O
case	O
21	int
:	O
case	O
22	int
:	O
x2	double
=	O
MY_PI	int
-	O
x4	double
;	O
if	O
(	O
coordinates	pointer
->	O
the_mode	int
==	O
22	int
)	O
return	O
(	O
(	O
1.0	int
+	O
cos	function
(	O
x2	double
)	O
)	O
*	O
0.5	int
)	O
;	O
x2	double
=	O
TODEG	O
(	O
x2	double
)	O
;	O
s_distance	double
=	O
sqrt	function
(	O
divisor_term	double
*	O
divisor_term	double
+	O
s_distance	double
*	O
s_distance	double
)	O
;	O
return	O
(	O
-	O
21.62	int
+	O
5.0	int
*	O
log10	function
(	O
s_distance	double
*	O
m_distance	double
)	O
+	O
0.026	int
*	O
x2	double
+	O
0.000000004	int
*	O
x2	double
*	O
x2	double
*	O
x2	double
*	O
x2	double
)	O
;	O
case	O
23	int
:	O
case	O
24	int
:	O
x1	double
=	O
TORAD	O
(	O
FIXANGLE	O
(	O
local_sidereal_time	double
-	O
right_ascension	double
)	O
)	O
;	O
if	O
(	O
coordinates	pointer
->	O
the_mode	int
==	O
23	int
)	O
return	O
(	O
TODEG	O
(	O
asin	function
(	O
sin_latitude	double
*	O
sin	function
(	O
declination	double
)	O
+	O
cos_latitude	double
*	O
cos	function
(	O
declination	double
)	O
*	O
cos	function
(	O
x1	double
)	O
)	O
)	O
)	O
;	O
return	O
(	O
FIXANGLE	O
(	O
TODEG	O
(	O
my_atan2	function
(	O
sin	function
(	O
x1	double
)	O
,	O
sin_latitude	double
*	O
cos	function
(	O
x1	double
)	O
-	O
cos_latitude	double
*	O
tan	function
(	O
declination	double
)	O
)	O
+	O
MY_PI	int
)	O
)	O
)	O
;	O
case	O
32	int
:	O
return	O
(	O
DEG2HH	O
(	O
local_sidereal_time	double
)	O
)	O
;	O
default	O
:	O
x4	double
=	O
gd_latitude2gc_latitude	function
(	O
latitude	double
,	O
(	O
coordinates	pointer
->	O
meters_above_sea_level	int
>	O
0	int
)	O
?	O
coordinates	pointer
->	O
meters_above_sea_level	int
:	O
0	int
,	O
&	O
x3	double
)	O
/	O
EQUATOR_EARTH_RADIUS	int
;	O
x1	double
=	O
cos	function
(	O
x3	double
)	O
*	O
x4	double
;	O
x2	double
=	O
TORAD	O
(	O
local_sidereal_time	double
)	O
;	O
xe	double
-=	O
(	O
cos	function
(	O
x2	double
)	O
*	O
x1	double
)	O
;	O
ye	double
-=	O
(	O
sin	function
(	O
x2	double
)	O
*	O
x1	double
)	O
;	O
ze	double
-=	O
(	O
sin	function
(	O
x3	double
)	O
*	O
x4	double
)	O
;	O
}	O
m_distance	double
=	O
sqrt	function
(	O
xe	double
*	O
xe	double
+	O
ye	double
*	O
ye	double
+	O
ze	double
*	O
ze	double
)	O
;	O
switch	O
(	O
coordinates	pointer
->	O
the_mode	int
)	O
{	O
case	O
6	int
:	O
return	O
(	O
TODEG	O
(	O
asin	function
(	O
1.0	int
/	O
m_distance	double
)	O
)	O
)	O
;	O
case	O
7	int
:	O
return	O
(	O
SS2DEG	O
(	O
936.85	int
*	O
60.0	int
/	O
m_distance	double
)	O
)	O
;	O
case	O
16	int
:	O
return	O
(	O
m_distance	double
)	O
;	O
default	O
:	O
;	O
}	O
right_ascension	double
=	O
FIXANGLE	O
(	O
TODEG	O
(	O
my_atan2	function
(	O
ye	double
,	O
xe	double
)	O
)	O
)	O
;	O
declination	double
=	O
asin	function
(	O
ze	double
/	O
m_distance	double
)	O
;	O
switch	O
(	O
coordinates	pointer
->	O
the_mode	int
)	O
{	O
case	O
8	int
:	O
case	O
9	int
:	O
case	O
13	int
:	O
case	O
14	int
:	O
case	O
17	int
:	O
m_longitude	double
=	O
FIXANGLE	O
(	O
TODEG	O
(	O
my_atan2	function
(	O
cos_obliquity_of_ecliptic	double
*	O
sin	function
(	O
TORAD	O
(	O
right_ascension	double
)	O
)	O
+	O
sin_obliquity_of_ecliptic	double
*	O
tan	function
(	O
declination	double
)	O
,	O
cos	function
(	O
TORAD	O
(	O
right_ascension	double
)	O
)	O
)	O
)	O
)	O
;	O
if	O
(	O
coordinates	pointer
->	O
the_mode	int
==	O
13	int
)	O
return	O
(	O
m_longitude	double
)	O
;	O
m_latitude	double
=	O
asin	function
(	O
cos_obliquity_of_ecliptic	double
*	O
sin	function
(	O
declination	double
)	O
-	O
sin_obliquity_of_ecliptic	double
*	O
cos	function
(	O
declination	double
)	O
*	O
sin	function
(	O
TORAD	O
(	O
right_ascension	double
)	O
)	O
)	O
;	O
if	O
(	O
coordinates	pointer
->	O
the_mode	int
==	O
14	int
)	O
return	O
(	O
TODEG	O
(	O
m_latitude	double
)	O
)	O
;	O
save_the_mode	int
=	O
coordinates	pointer
->	O
the_mode	int
;	O
coordinates	pointer
->	O
the_mode	int
=	O
13	int
;	O
s_longitude	double
=	O
sun_rise_set	function
(	O
event	enum
,	O
FALSE	O
,	O
day	int
,	O
month	int
,	O
year	int
,	O
coordinates	pointer
)	O
;	O
coordinates	pointer
->	O
the_mode	int
=	O
save_the_mode	int
;	O
x4	double
=	O
acos	function
(	O
cos	function
(	O
TORAD	O
(	O
s_longitude	double
-	O
m_longitude	double
)	O
)	O
*	O
cos	function
(	O
m_latitude	double
)	O
)	O
;	O
if	O
(	O
coordinates	pointer
->	O
the_mode	int
==	O
17	int
)	O
return	O
(	O
TODEG	O
(	O
x4	double
)	O
)	O
;	O
x2	double
=	O
MY_PI	int
-	O
x4	double
;	O
if	O
(	O
coordinates	pointer
->	O
the_mode	int
==	O
9	int
)	O
return	O
(	O
(	O
1.0	int
+	O
cos	function
(	O
x2	double
)	O
)	O
*	O
0.5	int
)	O
;	O
x2	double
=	O
TODEG	O
(	O
x2	double
)	O
;	O
save_the_mode	int
=	O
coordinates	pointer
->	O
the_mode	int
;	O
coordinates	pointer
->	O
the_mode	int
=	O
15	int
;	O
s_distance	double
=	O
sun_rise_set	function
(	O
event	enum
,	O
FALSE	O
,	O
day	int
,	O
month	int
,	O
year	int
,	O
coordinates	pointer
)	O
;	O
coordinates	pointer
->	O
the_mode	int
=	O
save_the_mode	int
;	O
return	O
(	O
-	O
21.62	int
+	O
5.0	int
*	O
log10	function
(	O
s_distance	double
*	O
m_distance	double
)	O
+	O
0.026	int
*	O
x2	double
+	O
0.000000004	int
*	O
x2	double
*	O
x2	double
*	O
x2	double
*	O
x2	double
)	O
;	O
default	O
:	O
;	O
}	O
x1	double
=	O
TORAD	O
(	O
FIXANGLE	O
(	O
local_sidereal_time	double
-	O
right_ascension	double
)	O
)	O
;	O
x3	double
=	O
cos	function
(	O
x1	double
)	O
;	O
x2	double
=	O
asin	function
(	O
sin_latitude	double
*	O
sin	function
(	O
declination	double
)	O
+	O
cos_latitude	double
*	O
cos	function
(	O
declination	double
)	O
*	O
x3	double
)	O
;	O
x4	double
=	O
atmospheric_refraction	function
(	O
x2	double
,	O
atm_pressure	double
,	O
atm_temperature	double
)	O
;	O
if	O
(	O
coordinates	pointer
->	O
the_mode	int
==	O
18	int
)	O
return	O
(	O
TODEG	O
(	O
x4	double
)	O
)	O
;	O
x2	double
+=	O
x4	double
;	O
if	O
(	O
x2	double
>	O
MY_HALF_PI	int
)	O
x2	double
=	O
MY_PI	int
-	O
x2	double
;	O
if	O
(	O
coordinates	pointer
->	O
the_mode	int
==	O
10	int
)	O
return	O
(	O
TODEG	O
(	O
x2	double
)	O
)	O
;	O
x3	double
=	O
FIXANGLE	O
(	O
TODEG	O
(	O
my_atan2	function
(	O
sin	function
(	O
x1	double
)	O
,	O
sin_latitude	double
*	O
x3	double
-	O
cos_latitude	double
*	O
tan	function
(	O
declination	double
)	O
)	O
+	O
MY_PI	int
)	O
)	O
;	O
if	O
(	O
coordinates	pointer
->	O
the_mode	int
==	O
11	int
)	O
return	O
(	O
x3	double
)	O
;	O
x3	double
=	O
TORAD	O
(	O
x3	double
)	O
;	O
xe	double
=	O
cos	function
(	O
x2	double
)	O
;	O
ye	double
=	O
sin	function
(	O
x2	double
)	O
;	O
ze	double
=	O
cos	function
(	O
x3	double
)	O
;	O
x1	double
=	O
xe	double
*	O
ze	double
;	O
x2	double
=	O
-	O
xe	double
*	O
sin	function
(	O
x3	double
)	O
;	O
x3	double
=	O
cos_latitude	double
*	O
ye	double
-	O
sin_latitude	double
*	O
x1	double
;	O
if	O
(	O
coordinates	pointer
->	O
the_mode	int
==	O
12	int
)	O
return	O
(	O
TODEG	O
(	O
asin	function
(	O
sin_latitude	double
*	O
ye	double
+	O
cos_latitude	double
*	O
x1	double
)	O
)	O
)	O
;	O
return	O
(	O
DEG2HH	O
(	O
FIXANGLE	O
(	O
local_sidereal_time	double
-	O
TODEG	O
(	O
my_atan2	function
(	O
x2	double
,	O
x3	double
)	O
)	O
)	O
)	O
)	O
;	O
}	O
x4	double
=	O
meridian_transit_time	double
;	O
meridian_transit_time	double
=	O
FIXANGLE	O
(	O
right_ascension	double
-	O
local_sidereal_time	double
)	O
;	O
if	O
(	O
iter_mt	int
)	O
{	O
if	O
(	O
(	O
i	int
>	O
3	int
)	O
&&	O
(	O
abs	function
(	O
abs	function
(	O
meridian_transit_time	double
)	O
-	O
abs	function
(	O
x4	double
)	O
)	O
>	O
DEGS_PER_12_HOURS	int
)	O
)	O
return	O
(	O
SPECIAL_VALUE	O
)	O
;	O
i	int
++	O
;	O
mjd1	double
=	O
mjd1_0ut	double
+	O
DEG2DAY	O
(	O
meridian_transit_time	double
)	O
;	O
mjd2	double
=	O
mjd2_0ut	double
+	O
DEG2DAY	O
(	O
meridian_transit_time	double
)	O
;	O
if	O
(	O
abs	function
(	O
abs	function
(	O
meridian_transit_time	double
)	O
-	O
abs	function
(	O
x4	double
)	O
)	O
>	O
0.015	int
)	O
goto	O
LABEL_moon_iter_mt	O
;	O
return	O
(	O
DEG2HH	O
(	O
FIXANGLE	O
(	O
meridian_transit_time	double
)	O
)	O
)	O
;	O
}	O
switch	O
(	O
coordinates	pointer
->	O
the_mode	int
)	O
{	O
case	O
2	int
:	O
case	O
4	int
:	O
if	O
(	O
adjust_value	double
!=	O
DEGS_PER_24_HOURS	int
)	O
x1	double
=	O
TORAD	O
(	O
adjust_value	double
)	O
;	O
else	O
x1	double
=	O
0.0	int
;	O
break	O
;	O
case	O
3	int
:	O
case	O
5	int
:	O
if	O
(	O
adjust_value	double
!=	O
DEGS_PER_24_HOURS	int
)	O
x1	double
=	O
TORAD	O
(	O
adjust_value	double
-	O
m_semidiameter	double
)	O
;	O
else	O
x1	double
=	O
TORAD	O
(	O
-	O
m_semidiameter	double
)	O
;	O
}	O
switch	O
(	O
coordinates	pointer
->	O
the_mode	int
)	O
{	O
case	O
4	int
:	O
case	O
5	int
:	O
if	O
(	O
adjust_value	double
!=	O
DEGS_PER_24_HOURS	int
||	O
atm_pressure	double
!=	O
DEFAULT_PRESSURE	int
||	O
atm_temperature	double
!=	O
DEFAULT_TEMPERATURE	int
)	O
x2	double
=	O
atmospheric_refraction	function
(	O
x1	double
,	O
atm_pressure	double
,	O
atm_temperature	double
)	O
;	O
else	O
x2	double
=	O
0.00989019909463453388	int
;	O
x1	double
-=	O
x2	double
;	O
}	O
x3	double
=	O
(	O
sin	function
(	O
x1	double
+	O
m_parallax	double
-	O
geodetic_height	double
)	O
-	O
sin_latitude	double
*	O
sin	function
(	O
declination	double
)	O
)	O
/	O
(	O
cos_latitude	double
*	O
cos	function
(	O
declination	double
)	O
)	O
;	O
if	O
(	O
abs	function
(	O
x3	double
)	O
>	O
1.0	int
)	O
{	O
if	O
(	O
!	O
n	long
&&	O
(	O
is_adjusted	int
||	O
the_time	double
==	O
SECS_PER_DAY	int
)	O
)	O
tt	double
=	O
x3	double
;	O
if	O
(	O
n	long
>	O
2	int
)	O
{	O
if	O
(	O
the_time	double
!=	O
SECS_PER_DAY	int
)	O
break	O
;	O
if	O
(	O
x3	double
>	O
0.0	int
)	O
return	O
(	O
2	int
*	O
SPECIAL_VALUE	O
)	O
;	O
return	O
(	O
3	int
*	O
SPECIAL_VALUE	O
)	O
;	O
}	O
n	long
++	O
;	O
x2	double
=	O
DEG2DAY	O
(	O
meridian_transit_time	double
)	O
;	O
mjd1	double
=	O
mjd1_0ut	double
+	O
x2	double
;	O
mjd2	double
=	O
mjd2_0ut	double
+	O
x2	double
;	O
continue	O
;	O
}	O
x2	double
=	O
TODEG	O
(	O
acos	function
(	O
x3	double
)	O
)	O
;	O
x1	double
=	O
the_time	double
;	O
if	O
(	O
event	enum
==	O
RIse	int
)	O
the_time	double
=	O
meridian_transit_time	double
-	O
x2	double
;	O
else	O
the_time	double
=	O
meridian_transit_time	double
+	O
x2	double
;	O
if	O
(	O
x1	double
!=	O
SECS_PER_DAY	int
)	O
{	O
if	O
(	O
event	enum
==	O
RIse	int
)	O
{	O
if	O
(	O
(	O
x1	double
<	O
0.0	int
)	O
&&	O
(	O
the_time	double
>=	O
0.0	int
)	O
)	O
{	O
if	O
(	O
i	int
>	O
2	int
)	O
{	O
the_time	double
=	O
tt	double
;	O
tt	double
=	O
SECS_PER_DAY	int
;	O
break	O
;	O
}	O
tt	double
=	O
x1	double
;	O
i	int
++	O
;	O
}	O
else	O
if	O
(	O
!	O
i	int
&&	O
abs	function
(	O
abs	function
(	O
meridian_transit_time	double
)	O
-	O
abs	function
(	O
x4	double
)	O
)	O
>	O
DEGS_PER_12_HOURS	int
)	O
{	O
if	O
(	O
j	int
>	O
2	int
)	O
return	O
(	O
SPECIAL_VALUE	O
)	O
;	O
j	int
++	O
;	O
}	O
}	O
else	O
if	O
(	O
(	O
x1	double
<	O
DEGS_PER_24_HOURS	int
)	O
&&	O
(	O
the_time	double
>=	O
DEGS_PER_24_HOURS	int
)	O
)	O
{	O
if	O
(	O
i	int
>	O
2	int
)	O
{	O
the_time	double
=	O
tt	double
;	O
tt	double
=	O
SECS_PER_DAY	int
;	O
break	O
;	O
}	O
tt	double
=	O
the_time	double
;	O
i	int
++	O
;	O
}	O
else	O
if	O
(	O
!	O
i	int
&&	O
abs	function
(	O
abs	function
(	O
meridian_transit_time	double
)	O
-	O
abs	function
(	O
x4	double
)	O
)	O
>	O
DEGS_PER_12_HOURS	int
)	O
{	O
if	O
(	O
j	int
>	O
2	int
)	O
return	O
(	O
SPECIAL_VALUE	O
)	O
;	O
j	int
++	O
;	O
}	O
}	O
mjd1	double
=	O
mjd1_0ut	double
+	O
DEG2DAY	O
(	O
the_time	double
)	O
;	O
mjd2	double
=	O
mjd2_0ut	double
+	O
DEG2DAY	O
(	O
the_time	double
)	O
;	O
}	O
while	O
(	O
abs	function
(	O
abs	function
(	O
the_time	double
)	O
-	O
abs	function
(	O
x1	double
)	O
)	O
>	O
0.015	int
)	O
;	O
if	O
(	O
event	enum
==	O
RIse	int
)	O
{	O
if	O
(	O
!	O
is_adjusted	int
&&	O
(	O
the_time	double
<	O
0.0	int
)	O
)	O
{	O
mjd1_0ut	double
++	O
;	O
mjd2_0ut	double
++	O
;	O
if	O
(	O
n	long
>	O
1	int
)	O
tt	double
=	O
SECS_PER_DAY	int
;	O
}	O
else	O
ok	int
=	O
TRUE	O
;	O
}	O
else	O
if	O
(	O
!	O
is_adjusted	int
&&	O
(	O
the_time	double
>=	O
DEGS_PER_24_HOURS	int
)	O
)	O
{	O
mjd1_0ut	double
--	O
;	O
mjd2_0ut	double
--	O
;	O
if	O
(	O
n	long
>	O
1	int
)	O
tt	double
=	O
SECS_PER_DAY	int
;	O
}	O
else	O
ok	int
=	O
TRUE	O
;	O
if	O
(	O
!	O
ok	int
)	O
{	O
if	O
(	O
n	long
==	O
1	int
||	O
tt	double
==	O
SECS_PER_DAY	int
)	O
{	O
is_adjusted	int
=	O
TRUE	O
;	O
tt	double
=	O
the_time	double
=	O
SECS_PER_DAY	int
;	O
i	int
=	O
j	int
=	O
n	long
=	O
0	int
;	O
}	O
else	O
if	O
(	O
n	long
>	O
1	int
)	O
{	O
if	O
(	O
tt	double
>	O
1.0	int
)	O
return	O
(	O
2	int
*	O
SPECIAL_VALUE	O
)	O
;	O
else	O
if	O
(	O
tt	double
<	O
-	O
1.0	int
)	O
return	O
(	O
3	int
*	O
SPECIAL_VALUE	O
)	O
;	O
return	O
(	O
SPECIAL_VALUE	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
n	long
)	O
return	O
(	O
SPECIAL_VALUE	O
)	O
;	O
}	O
}	O
if	O
(	O
is_adjusted	int
&&	O
(	O
n	long
!=	O
1	int
)	O
&&	O
(	O
tt	double
!=	O
SECS_PER_DAY	int
)	O
)	O
{	O
if	O
(	O
n	long
)	O
{	O
if	O
(	O
tt	double
>	O
1.0	int
)	O
return	O
(	O
2	int
*	O
SPECIAL_VALUE	O
)	O
;	O
else	O
if	O
(	O
tt	double
<	O
-	O
1.0	int
)	O
return	O
(	O
3	int
*	O
SPECIAL_VALUE	O
)	O
;	O
}	O
return	O
(	O
SPECIAL_VALUE	O
)	O
;	O
}	O
if	O
(	O
!	O
is_adjusted	int
&&	O
(	O
n	long
>	O
1	int
)	O
)	O
{	O
if	O
(	O
x3	double
>	O
1.0	int
)	O
return	O
(	O
2	int
*	O
SPECIAL_VALUE	O
)	O
;	O
else	O
if	O
(	O
x3	double
<	O
-	O
1.0	int
)	O
return	O
(	O
3	int
*	O
SPECIAL_VALUE	O
)	O
;	O
return	O
(	O
SPECIAL_VALUE	O
)	O
;	O
}	O
while	O
(	O
the_time	double
>=	O
DEGS_PER_24_HOURS	int
)	O
the_time	double
-=	O
DEGS_PER_24_HOURS	int
;	O
while	O
(	O
the_time	double
<	O
0.0	int
)	O
the_time	double
+=	O
DEGS_PER_24_HOURS	int
;	O
return	O
(	O
DEG2HH	O
(	O
the_time	double
)	O
)	O
;	O
}	O
int	O
moondisk	function
(	O
is_full_new	pointer
,	O
day	int
,	O
month	int
,	O
year	int
,	O
hour	int
,	O
min	int
)	O
Bool	int
*	O
is_full_new	pointer
;	O
int	O
day	int
;	O
int	O
month	int
;	O
int	O
year	int
;	O
const	O
int	O
hour	int
;	O
const	O
int	O
min	int
;	O
{	O
auto	O
double	O
new_moon	double
;	O
auto	O
double	O
full_moon	double
;	O
auto	O
double	O
len_lunation_half	double
;	O
auto	O
double	O
illuminated_fraction	double
;	O
auto	O
Ulint	long
lunation	pointer
;	O
auto	O
Ulint	long
mjd	double
=	O
date2num	function
(	O
day	int
,	O
month	int
,	O
year	int
)	O
;	O
*	O
is_full_new	pointer
=	O
FALSE	O
;	O
if	O
(	O
mjd	double
<=	O
13L	int
)	O
{	O
lunation	pointer
=	O
1L	int
;	O
new_moon	double
=	O
moonphase	function
(	O
MPHASE_NEW	int
,	O
FALSE	O
,	O
NULL	O
,	O
&	O
lunation	pointer
,	O
&	O
day	int
,	O
&	O
month	int
,	O
&	O
year	int
,	O
hour	int
,	O
min	int
)	O
;	O
full_moon	double
=	O
-	O
2.3784722	int
;	O
}	O
else	O
{	O
lunation	pointer
=	O
0L	int
;	O
new_moon	double
=	O
moonphase	function
(	O
MPHASE_NEW	int
,	O
FALSE	O
,	O
NULL	O
,	O
&	O
lunation	pointer
,	O
&	O
day	int
,	O
&	O
month	int
,	O
&	O
year	int
,	O
-	O
hour	int
,	O
-	O
min	int
)	O
;	O
lunation	pointer
--	O
;	O
full_moon	double
=	O
moonphase	function
(	O
MPHASE_FUL	int
,	O
FALSE	O
,	O
NULL	O
,	O
&	O
lunation	pointer
,	O
&	O
day	int
,	O
&	O
month	int
,	O
&	O
year	int
,	O
-	O
hour	int
,	O
-	O
min	int
)	O
;	O
if	O
(	O
date2num	function
(	O
day	int
,	O
month	int
,	O
year	int
)	O
>=	O
mjd	double
)	O
new_moon	double
=	O
moonphase	function
(	O
MPHASE_NEW	int
,	O
FALSE	O
,	O
NULL	O
,	O
&	O
lunation	pointer
,	O
&	O
day	int
,	O
&	O
month	int
,	O
&	O
year	int
,	O
-	O
hour	int
,	O
-	O
min	int
)	O
;	O
}	O
len_lunation_half	double
=	O
abs	function
(	O
full_moon	double
-	O
new_moon	double
)	O
;	O
if	O
(	O
mjd	double
>	O
(	O
Ulint	long
)	O
new_moon	double
)	O
len_lunation_half	double
=	O
(	O
mjd	double
-	O
new_moon	double
)	O
/	O
len_lunation_half	double
;	O
else	O
len_lunation_half	double
=	O
(	O
-	O
len_lunation_half	double
+	O
(	O
mjd	double
-	O
full_moon	double
)	O
)	O
/	O
len_lunation_half	double
;	O
illuminated_fraction	double
=	O
sin	function
(	O
len_lunation_half	double
*	O
MY_HALF_PI	int
)	O
;	O
illuminated_fraction	double
*=	O
illuminated_fraction	double
;	O
if	O
(	O
len_lunation_half	double
<	O
0.0	int
)	O
illuminated_fraction	double
=	O
-	O
illuminated_fraction	double
;	O
if	O
(	O
mjd	double
==	O
(	O
Ulint	long
)	O
new_moon	double
||	O
mjd	double
==	O
(	O
Ulint	long
)	O
full_moon	double
)	O
*	O
is_full_new	pointer
=	O
TRUE	O
;	O
return	O
(	O
(	O
int	O
)	O
ROUND	O
(	O
illuminated_fraction	double
*	O
100.0	int
)	O
)	O
;	O
}	O
void	O
draw_moon	function
(	O
age	int
,	O
lines	int
,	O
string	pointer
)	O
const	O
int	O
age	int
;	O
const	O
int	O
lines	int
;	O
char	O
*	O
*	O
string	pointer
;	O
{	O
register	O
Uint	int
slen	int
=	O
0	int
;	O
register	O
int	O
i	int
;	O
register	O
int	O
j	int
;	O
register	O
int	O
k	int
;	O
register	O
int	O
end	int
;	O
auto	O
double	O
counter	double
=	O
(	O
double	O
)	O
age	int
;	O
auto	O
const	O
double	O
step	double
=	O
2.0	int
/	O
(	O
double	O
)	O
lines	int
;	O
auto	O
double	O
squisher	double
;	O
auto	O
double	O
horizon	double
;	O
auto	O
double	O
terminator	double
;	O
static	O
char	O
buffer	array
[	O
80	int
]	O
;	O
auto	O
char	O
*	O
ptr_buffer	pointer
;	O
*	O
*	O
string	pointer
=	O
'\0'	O
;	O
if	O
(	O
counter	double
<	O
0.0	int
)	O
counter	double
=	O
-	O
counter	double
;	O
if	O
(	O
age	int
<	O
0	int
)	O
counter	double
=	O
(	O
100.0	int
-	O
(	O
double	O
)	O
(	O
(	O
(	O
Uint	int
)	O
counter	double
>>	O
1	int
)	O
+	O
50	int
)	O
)	O
/	O
100.0	int
;	O
else	O
counter	double
/=	O
200.0	int
;	O
squisher	double
=	O
cos	function
(	O
counter	double
*	O
MY_TWO_PI	int
)	O
;	O
for	O
(	O
counter	double
=	O
0.93	int
;	O
counter	double
>	O
-	O
1.0	int
;	O
counter	double
-=	O
step	double
)	O
{	O
sprintf	function
(	O
buffer	array
,	O
"%c"	pointer
,	O
RC_NL_CHAR	char
)	O
;	O
strcat	function
(	O
*	O
string	pointer
,	O
buffer	array
)	O
;	O
slen	int
++	O
;	O
horizon	double
=	O
sqrt	function
(	O
1.0	int
-	O
counter	double
*	O
counter	double
)	O
;	O
i	int
=	O
j	int
=	O
moon_charpos	function
(	O
horizon	double
,	O
lines	int
+	O
6	int
)	O
;	O
for	O
(	O
ptr_buffer	pointer
=	O
buffer	array
;	O
i	int
--	O
;	O
)	O
*	O
ptr_buffer	pointer
++	O
=	O
' '	O
;	O
i	int
=	O
j	int
;	O
slen	int
+=	O
(	O
i	int
+	O
1	int
)	O
;	O
buffer	array
[	O
i	int
]	O
=	O
*	O
MOONIMAGE_REDGE	pointer
;	O
buffer	array
[	O
i	int
+	O
1	int
]	O
=	O
'\0'	O
;	O
j	int
=	O
moon_charpos	function
(	O
-	O
horizon	double
,	O
lines	int
+	O
6	int
)	O
;	O
buffer	array
[	O
j	int
]	O
=	O
*	O
MOONIMAGE_LEDGE	pointer
;	O
terminator	double
=	O
horizon	double
*	O
squisher	double
;	O
if	O
(	O
abs	function
(	O
age	int
)	O
>	O
6	int
)	O
{	O
k	int
=	O
moon_charpos	function
(	O
terminator	double
,	O
lines	int
+	O
6	int
)	O
;	O
if	O
(	O
age	int
>	O
0	int
)	O
{	O
end	int
=	O
i	int
;	O
i	int
=	O
k	int
;	O
}	O
else	O
{	O
i	int
=	O
j	int
;	O
end	int
=	O
k	int
;	O
}	O
while	O
(	O
i	int
<=	O
end	int
)	O
buffer	array
[	O
i	int
++	O
]	O
=	O
*	O
MOONIMAGE_BRIGHT	O
;	O
}	O
if	O
(	O
slen	int
+	O
1	int
>=	O
maxlen_max	int
)	O
resize_all_strings	function
(	O
maxlen_max	int
<<	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
strcat	function
(	O
*	O
string	pointer
,	O
buffer	array
)	O
;	O
}	O
}	O
