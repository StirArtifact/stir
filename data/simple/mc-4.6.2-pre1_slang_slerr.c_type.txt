void	O
(	O
*	O
_pSLinterpreter_Error_Hook	pointer
)	O
(	O
int	O
)	O
;	O
void	O
(	O
*	O
SLang_VMessage_Hook	pointer
)	O
(	O
char	O
*	O
,	O
va_list	array
)	O
;	O
void	O
(	O
*	O
SLang_Error_Hook	pointer
)	O
(	O
char	O
*	O
)	O
;	O
void	O
(	O
*	O
SLang_Exit_Error_Hook	pointer
)	O
(	O
char	O
*	O
,	O
va_list	array
)	O
;	O
void	O
(	O
*	O
SLang_Dump_Routine	pointer
)	O
(	O
char	O
*	O
)	O
;	O
volatile	O
int	O
_pSLang_Error	int
=	O
0	int
;	O
volatile	O
int	O
SLKeyBoard_Quit	int
=	O
0	int
;	O
typedef	O
struct	O
_Exception_Type	struct
Exception_Type	struct
;	O
struct	O
_Exception_Type	struct
{	O
int	O
error_code	int
;	O
char	O
*	O
name	pointer
;	O
char	O
*	O
description	pointer
;	O
Exception_Type	struct
*	O
subclasses	pointer
;	O
Exception_Type	struct
*	O
next	pointer
;	O
Exception_Type	struct
*	O
parent	pointer
;	O
}	O
;	O
static	O
Exception_Type	struct
*	O
Exception_Root	pointer
;	O
static	O
Exception_Type	struct
Exception_Root_Buf	struct
=	O
{	O
-	O
1	int
,	O
"AnyError"	pointer
,	O
"All Errors"	pointer
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
;	O
int	O
SL_Any_Error	int
=	O
-	O
1	int
;	O
int	O
SL_Unknown_Error	int
=	O
6	int
;	O
int	O
SL_Internal_Error	int
=	O
5	int
;	O
int	O
SL_OS_Error	int
=	O
1	int
;	O
int	O
SL_Malloc_Error	int
=	O
2	int
;	O
int	O
SL_Import_Error	int
=	O
7	int
;	O
int	O
SL_RunTime_Error	int
=	O
3	int
;	O
int	O
SL_InvalidParm_Error	int
=	O
4	int
;	O
int	O
SL_TypeMismatch_Error	int
=	O
8	int
;	O
int	O
SL_UserBreak_Error	int
=	O
9	int
;	O
int	O
SL_Stack_Error	int
=	O
10	int
;	O
int	O
SL_StackOverflow_Error	int
=	O
12	int
;	O
int	O
SL_StackUnderflow_Error	int
=	O
11	int
;	O
int	O
SL_ReadOnly_Error	int
=	O
13	int
;	O
int	O
SL_VariableUninitialized_Error	int
=	O
14	int
;	O
int	O
SL_NumArgs_Error	int
=	O
15	int
;	O
int	O
SL_Index_Error	int
=	O
16	int
;	O
int	O
SL_Usage_Error	int
=	O
17	int
;	O
int	O
SL_Application_Error	int
=	O
18	int
;	O
int	O
SL_NotImplemented_Error	int
=	O
19	int
;	O
int	O
SL_LimitExceeded_Error	int
=	O
20	int
;	O
int	O
SL_Forbidden_Error	int
=	O
21	int
;	O
int	O
SL_Math_Error	int
=	O
22	int
;	O
int	O
SL_DivideByZero_Error	int
=	O
23	int
;	O
int	O
SL_ArithOverflow_Error	int
=	O
24	int
;	O
int	O
SL_ArithUnderflow_Error	int
=	O
25	int
;	O
int	O
SL_Domain_Error	int
=	O
26	int
;	O
int	O
SL_IO_Error	int
=	O
27	int
;	O
int	O
SL_Write_Error	int
=	O
28	int
;	O
int	O
SL_Read_Error	int
=	O
29	int
;	O
int	O
SL_Open_Error	int
=	O
30	int
;	O
int	O
SL_Data_Error	int
=	O
31	int
;	O
int	O
SL_Unicode_Error	int
=	O
32	int
;	O
int	O
SL_InvalidUTF8_Error	int
=	O
33	int
;	O
int	O
SL_Namespace_Error	int
=	O
34	int
;	O
int	O
SL_Parse_Error	int
=	O
35	int
;	O
int	O
SL_Syntax_Error	int
=	O
36	int
;	O
int	O
SL_DuplicateDefinition_Error	int
=	O
37	int
;	O
int	O
SL_UndefinedName_Error	int
=	O
38	int
;	O
typedef	O
struct	O
{	O
int	O
*	O
errcode_ptr	pointer
;	O
char	O
*	O
name	pointer
;	O
char	O
*	O
description	pointer
;	O
int	O
*	O
base_class_ptr	pointer
;	O
}	O
BuiltIn_Exception_Table_Type	struct
;	O
static	O
SLCONST	O
BuiltIn_Exception_Table_Type	struct
BuiltIn_Exception_Table	array
[	O
]	O
=	O
{	O
{	O
&	O
SL_OS_Error	int
,	O
"OSError"	pointer
,	O
"OS Error"	pointer
,	O
&	O
SL_Any_Error	int
}	O
,	O
{	O
&	O
SL_Malloc_Error	int
,	O
"MallocError"	pointer
,	O
"Not enough memory"	pointer
,	O
&	O
SL_OS_Error	int
}	O
,	O
{	O
&	O
SL_RunTime_Error	int
,	O
"RunTimeError"	pointer
,	O
"Run-Time Error"	pointer
,	O
&	O
SL_Any_Error	int
}	O
,	O
{	O
&	O
SL_InvalidParm_Error	int
,	O
"InvalidParmError"	pointer
,	O
"Invalid Parameter"	pointer
,	O
&	O
SL_RunTime_Error	int
}	O
,	O
{	O
&	O
SL_Internal_Error	int
,	O
"InternalError"	pointer
,	O
"Internal Error"	pointer
,	O
&	O
SL_Any_Error	int
}	O
,	O
{	O
&	O
SL_Unknown_Error	int
,	O
"UnknownError"	pointer
,	O
"Unknown Error"	pointer
,	O
&	O
SL_Any_Error	int
}	O
,	O
{	O
&	O
SL_Import_Error	int
,	O
"ImportError"	pointer
,	O
"Import Error"	pointer
,	O
&	O
SL_OS_Error	int
}	O
,	O
{	O
&	O
SL_TypeMismatch_Error	int
,	O
"TypeMismatchError"	pointer
,	O
"Type Mismatch"	pointer
,	O
&	O
SL_RunTime_Error	int
}	O
,	O
{	O
&	O
SL_UserBreak_Error	int
,	O
"UserBreakError"	pointer
,	O
"User Break"	pointer
,	O
&	O
SL_RunTime_Error	int
}	O
,	O
{	O
&	O
SL_Stack_Error	int
,	O
"StackError"	pointer
,	O
"Stack Error"	pointer
,	O
&	O
SL_RunTime_Error	int
}	O
,	O
{	O
&	O
SL_StackUnderflow_Error	int
,	O
"StackUnderflowError"	pointer
,	O
"Stack Underflow Error"	pointer
,	O
&	O
SL_Stack_Error	int
}	O
,	O
{	O
&	O
SL_StackOverflow_Error	int
,	O
"StackOverflowError"	pointer
,	O
"Stack Overflow Error"	pointer
,	O
&	O
SL_Stack_Error	int
}	O
,	O
{	O
&	O
SL_ReadOnly_Error	int
,	O
"ReadOnlyError"	pointer
,	O
"Read-Only Error"	pointer
,	O
&	O
SL_RunTime_Error	int
}	O
,	O
{	O
&	O
SL_VariableUninitialized_Error	int
,	O
"VariableUninitializedError"	pointer
,	O
"Variable Uninitialized Error"	pointer
,	O
&	O
SL_RunTime_Error	int
}	O
,	O
{	O
&	O
SL_NumArgs_Error	int
,	O
"NumArgsError"	pointer
,	O
"Invalid Number of Arguments"	pointer
,	O
&	O
SL_RunTime_Error	int
}	O
,	O
{	O
&	O
SL_Index_Error	int
,	O
"IndexError"	pointer
,	O
"Invalid Index"	pointer
,	O
&	O
SL_RunTime_Error	int
}	O
,	O
{	O
&	O
SL_Usage_Error	int
,	O
"UsageError"	pointer
,	O
"Illegal Usage"	pointer
,	O
&	O
SL_RunTime_Error	int
}	O
,	O
{	O
&	O
SL_Application_Error	int
,	O
"ApplicationError"	pointer
,	O
"Application Error"	pointer
,	O
&	O
SL_RunTime_Error	int
}	O
,	O
{	O
&	O
SL_NotImplemented_Error	int
,	O
"NotImplementedError"	pointer
,	O
"Not Implemented"	pointer
,	O
&	O
SL_RunTime_Error	int
}	O
,	O
{	O
&	O
SL_LimitExceeded_Error	int
,	O
"LimitExceededError"	pointer
,	O
"Limit Exceeded"	pointer
,	O
&	O
SL_RunTime_Error	int
}	O
,	O
{	O
&	O
SL_Forbidden_Error	int
,	O
"ForbiddenError"	pointer
,	O
"Operation Forbidden"	pointer
,	O
&	O
SL_RunTime_Error	int
}	O
,	O
{	O
&	O
SL_Math_Error	int
,	O
"MathError"	pointer
,	O
"Math Error"	pointer
,	O
&	O
SL_RunTime_Error	int
}	O
,	O
{	O
&	O
SL_DivideByZero_Error	int
,	O
"DivideByZeroError"	pointer
,	O
"Divide by Zero"	pointer
,	O
&	O
SL_Math_Error	int
}	O
,	O
{	O
&	O
SL_ArithOverflow_Error	int
,	O
"ArithOverflowError"	pointer
,	O
"Arithmetic Overflow"	pointer
,	O
&	O
SL_Math_Error	int
}	O
,	O
{	O
&	O
SL_ArithUnderflow_Error	int
,	O
"ArithUnderflowError"	pointer
,	O
"Arithmetic Underflow"	pointer
,	O
&	O
SL_Math_Error	int
}	O
,	O
{	O
&	O
SL_Domain_Error	int
,	O
"DomainError"	pointer
,	O
"Domain Error"	pointer
,	O
&	O
SL_Math_Error	int
}	O
,	O
{	O
&	O
SL_IO_Error	int
,	O
"IOError"	pointer
,	O
"I/O Error"	pointer
,	O
&	O
SL_RunTime_Error	int
}	O
,	O
{	O
&	O
SL_Write_Error	int
,	O
"WriteError"	pointer
,	O
"Write failed"	pointer
,	O
&	O
SL_IO_Error	int
}	O
,	O
{	O
&	O
SL_Read_Error	int
,	O
"ReadError"	pointer
,	O
"Read failed"	pointer
,	O
&	O
SL_IO_Error	int
}	O
,	O
{	O
&	O
SL_Open_Error	int
,	O
"OpenError"	pointer
,	O
"Open failed"	pointer
,	O
&	O
SL_IO_Error	int
}	O
,	O
{	O
&	O
SL_Data_Error	int
,	O
"DataError"	pointer
,	O
"Data Error"	pointer
,	O
&	O
SL_RunTime_Error	int
}	O
,	O
{	O
&	O
SL_Unicode_Error	int
,	O
"UnicodeError"	pointer
,	O
"Unicode Error"	pointer
,	O
&	O
SL_RunTime_Error	int
}	O
,	O
{	O
&	O
SL_InvalidUTF8_Error	int
,	O
"UTF8Error"	pointer
,	O
"Invalid UTF8"	pointer
,	O
&	O
SL_Unicode_Error	int
}	O
,	O
{	O
&	O
SL_Namespace_Error	int
,	O
"NamespaceError"	pointer
,	O
"Namespace Error"	pointer
,	O
&	O
SL_RunTime_Error	int
}	O
,	O
{	O
&	O
SL_Parse_Error	int
,	O
"ParseError"	pointer
,	O
"Parse Error"	pointer
,	O
&	O
SL_Any_Error	int
}	O
,	O
{	O
&	O
SL_Syntax_Error	int
,	O
"SyntaxError"	pointer
,	O
"Syntax Error"	pointer
,	O
&	O
SL_Parse_Error	int
}	O
,	O
{	O
&	O
SL_DuplicateDefinition_Error	int
,	O
"DuplicateDefinitionError"	pointer
,	O
"Duplicate Definition"	pointer
,	O
&	O
SL_Parse_Error	int
}	O
,	O
{	O
&	O
SL_UndefinedName_Error	int
,	O
"UndefinedNameError"	pointer
,	O
"Undefined Name"	pointer
,	O
&	O
SL_Parse_Error	int
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
}	O
;	O
static	O
Exception_Type	struct
*	O
find_exception	function
(	O
Exception_Type	struct
*	O
root	pointer
,	O
int	O
error_code	int
)	O
{	O
Exception_Type	struct
*	O
e	pointer
;	O
while	O
(	O
root	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
error_code	int
==	O
root	pointer
->	O
error_code	int
)	O
return	O
root	pointer
;	O
if	O
(	O
root	pointer
->	O
subclasses	pointer
!=	O
NULL	O
)	O
{	O
e	pointer
=	O
find_exception	function
(	O
root	pointer
->	O
subclasses	pointer
,	O
error_code	int
)	O
;	O
if	O
(	O
e	pointer
!=	O
NULL	O
)	O
return	O
e	pointer
;	O
}	O
root	pointer
=	O
root	pointer
->	O
next	pointer
;	O
}	O
return	O
root	pointer
;	O
}	O
static	O
int	O
is_exception_ancestor	function
(	O
int	O
a	pointer
,	O
int	O
b	pointer
)	O
{	O
Exception_Type	struct
*	O
e	pointer
;	O
if	O
(	O
a	pointer
==	O
b	pointer
)	O
return	O
1	int
;	O
if	O
(	O
NULL	O
==	O
(	O
e	pointer
=	O
find_exception	function
(	O
Exception_Root	pointer
,	O
a	pointer
)	O
)	O
)	O
return	O
0	int
;	O
while	O
(	O
e	pointer
->	O
parent	pointer
!=	O
NULL	O
)	O
{	O
e	pointer
=	O
e	pointer
->	O
parent	pointer
;	O
if	O
(	O
e	pointer
->	O
error_code	int
==	O
b	pointer
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
SLerr_exception_eqs	function
(	O
int	O
a	pointer
,	O
int	O
b	pointer
)	O
{	O
if	O
(	O
is_exception_ancestor	function
(	O
a	pointer
,	O
b	pointer
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
free_this_exception	function
(	O
Exception_Type	struct
*	O
e	pointer
)	O
{	O
if	O
(	O
e	pointer
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
e	pointer
->	O
name	pointer
!=	O
NULL	O
)	O
SLang_free_slstring	function
(	O
e	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
e	pointer
->	O
description	pointer
!=	O
NULL	O
)	O
SLang_free_slstring	function
(	O
e	pointer
->	O
description	pointer
)	O
;	O
SLfree	O
(	O
(	O
char	O
*	O
)	O
e	pointer
)	O
;	O
}	O
static	O
int	O
Next_Exception_Code	int
;	O
int	O
(	O
*	O
_pSLerr_New_Exception_Hook	pointer
)	O
(	O
char	O
*	O
name	pointer
,	O
char	O
*	O
desc	pointer
,	O
int	O
error_code	int
)	O
;	O
int	O
_pSLerr_init_interp_exceptions	function
(	O
void	O
)	O
{	O
SLCONST	O
BuiltIn_Exception_Table_Type	struct
*	O
b	pointer
;	O
Exception_Type	struct
*	O
e	pointer
;	O
if	O
(	O
_pSLerr_New_Exception_Hook	pointer
==	O
NULL	O
)	O
return	O
0	int
;	O
e	pointer
=	O
&	O
Exception_Root_Buf	struct
;	O
if	O
(	O
-	O
1	int
==	O
(	O
*	O
_pSLerr_New_Exception_Hook	pointer
)	O
(	O
e	pointer
->	O
name	pointer
,	O
e	pointer
->	O
description	pointer
,	O
e	pointer
->	O
error_code	int
)	O
)	O
return	O
-	O
1	int
;	O
b	pointer
=	O
BuiltIn_Exception_Table	array
;	O
while	O
(	O
b	pointer
->	O
errcode_ptr	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
-	O
1	int
==	O
(	O
*	O
_pSLerr_New_Exception_Hook	pointer
)	O
(	O
b	pointer
->	O
name	pointer
,	O
b	pointer
->	O
description	pointer
,	O
*	O
b	pointer
->	O
errcode_ptr	pointer
)	O
)	O
return	O
-	O
1	int
;	O
b	pointer
++	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
SLerr_new_exception	function
(	O
int	O
baseclass	int
,	O
char	O
*	O
name	pointer
,	O
char	O
*	O
descript	pointer
)	O
{	O
Exception_Type	struct
*	O
base	int
;	O
Exception_Type	struct
*	O
e	pointer
;	O
if	O
(	O
-	O
1	int
==	O
_pSLerr_init	function
(	O
)	O
)	O
return	O
-	O
1	int
;	O
base	int
=	O
find_exception	function
(	O
Exception_Root	pointer
,	O
baseclass	int
)	O
;	O
if	O
(	O
base	int
==	O
NULL	O
)	O
{	O
SLang_verror	function
(	O
SL_InvalidParm_Error	int
,	O
"Base class for new exception not found"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
e	pointer
=	O
(	O
Exception_Type	struct
*	O
)	O
SLcalloc	function
(	O
1	int
,	O
sizeof	O
(	O
Exception_Type	struct
)	O
)	O
;	O
if	O
(	O
e	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
(	O
NULL	O
==	O
(	O
e	pointer
->	O
name	pointer
=	O
SLang_create_slstring	function
(	O
name	pointer
)	O
)	O
)	O
||	O
(	O
NULL	O
==	O
(	O
e	pointer
->	O
description	pointer
=	O
SLang_create_slstring	function
(	O
descript	pointer
)	O
)	O
)	O
)	O
{	O
free_this_exception	function
(	O
e	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
e	pointer
->	O
error_code	int
=	O
Next_Exception_Code	int
;	O
if	O
(	O
(	O
_pSLerr_New_Exception_Hook	pointer
!=	O
NULL	O
)	O
&&	O
(	O
-	O
1	int
==	O
(	O
*	O
_pSLerr_New_Exception_Hook	pointer
)	O
(	O
e	pointer
->	O
name	pointer
,	O
e	pointer
->	O
description	pointer
,	O
e	pointer
->	O
error_code	int
)	O
)	O
)	O
{	O
free_this_exception	function
(	O
e	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
e	pointer
->	O
parent	pointer
=	O
base	int
;	O
e	pointer
->	O
next	pointer
=	O
base	int
->	O
subclasses	pointer
;	O
base	int
->	O
subclasses	pointer
=	O
e	pointer
;	O
Next_Exception_Code	int
++	O
;	O
return	O
e	pointer
->	O
error_code	int
;	O
}	O
static	O
int	O
init_exceptions	function
(	O
void	O
)	O
{	O
SLCONST	O
BuiltIn_Exception_Table_Type	struct
*	O
b	pointer
;	O
if	O
(	O
Exception_Root	pointer
!=	O
NULL	O
)	O
return	O
0	int
;	O
Exception_Root	pointer
=	O
&	O
Exception_Root_Buf	struct
;	O
Next_Exception_Code	int
=	O
1	int
;	O
b	pointer
=	O
BuiltIn_Exception_Table	array
;	O
while	O
(	O
b	pointer
->	O
errcode_ptr	pointer
!=	O
NULL	O
)	O
{	O
int	O
err_code	int
;	O
err_code	int
=	O
SLerr_new_exception	function
(	O
*	O
b	pointer
->	O
base_class_ptr	pointer
,	O
b	pointer
->	O
name	pointer
,	O
b	pointer
->	O
description	pointer
)	O
;	O
if	O
(	O
err_code	int
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
*	O
b	pointer
->	O
errcode_ptr	pointer
=	O
err_code	int
;	O
b	pointer
++	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
free_exceptions	function
(	O
Exception_Type	struct
*	O
root	pointer
)	O
{	O
while	O
(	O
root	pointer
!=	O
NULL	O
)	O
{	O
Exception_Type	struct
*	O
next	pointer
;	O
if	O
(	O
root	pointer
->	O
subclasses	pointer
!=	O
NULL	O
)	O
free_exceptions	function
(	O
root	pointer
->	O
subclasses	pointer
)	O
;	O
next	pointer
=	O
root	pointer
->	O
next	pointer
;	O
free_this_exception	function
(	O
root	pointer
)	O
;	O
root	pointer
=	O
next	pointer
;	O
}	O
}	O
static	O
void	O
deinit_exceptions	function
(	O
void	O
)	O
{	O
Exception_Type	struct
*	O
root	pointer
=	O
Exception_Root	pointer
;	O
if	O
(	O
root	pointer
!=	O
NULL	O
)	O
free_exceptions	function
(	O
root	pointer
->	O
subclasses	pointer
)	O
;	O
Exception_Root	pointer
=	O
NULL	O
;	O
Next_Exception_Code	int
=	O
0	int
;	O
}	O
char	O
*	O
SLerr_strerror	function
(	O
int	O
err_code	int
)	O
{	O
Exception_Type	struct
*	O
e	pointer
;	O
if	O
(	O
err_code	int
==	O
0	int
)	O
err_code	int
=	O
_pSLang_Error	int
;	O
if	O
(	O
-	O
1	int
==	O
_pSLerr_init	function
(	O
)	O
)	O
return	O
"Unable to initialize SLerr module"	pointer
;	O
if	O
(	O
NULL	O
==	O
(	O
e	pointer
=	O
find_exception	function
(	O
Exception_Root	pointer
,	O
err_code	int
)	O
)	O
)	O
return	O
"Invalid/Unknown Error Code"	pointer
;	O
return	O
e	pointer
->	O
description	pointer
;	O
}	O
typedef	O
struct	O
_Error_Message_Type	struct
{	O
char	O
*	O
msg	pointer
;	O
int	O
msg_type	int
;	O
struct	O
_Error_Message_Type	struct
*	O
next	pointer
;	O
}	O
Error_Message_Type	struct
;	O
typedef	O
struct	O
{	O
Error_Message_Type	struct
*	O
head	pointer
;	O
Error_Message_Type	struct
*	O
tail	pointer
;	O
}	O
Error_Queue_Type	struct
;	O
static	O
Error_Queue_Type	struct
*	O
Default_Error_Queue	pointer
;	O
static	O
void	O
free_error_msg	function
(	O
Error_Message_Type	struct
*	O
m	pointer
)	O
{	O
if	O
(	O
m	pointer
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
m	pointer
->	O
msg	pointer
!=	O
NULL	O
)	O
SLang_free_slstring	function
(	O
m	pointer
->	O
msg	pointer
)	O
;	O
SLfree	O
(	O
(	O
char	O
*	O
)	O
m	pointer
)	O
;	O
}	O
static	O
Error_Message_Type	struct
*	O
allocate_error_msg	function
(	O
char	O
*	O
msg	pointer
,	O
int	O
msg_type	int
)	O
{	O
Error_Message_Type	struct
*	O
m	pointer
;	O
if	O
(	O
NULL	O
==	O
(	O
m	pointer
=	O
(	O
Error_Message_Type	struct
*	O
)	O
SLcalloc	function
(	O
1	int
,	O
sizeof	O
(	O
Error_Message_Type	struct
)	O
)	O
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
(	O
NULL	O
!=	O
msg	pointer
)	O
&&	O
(	O
NULL	O
==	O
(	O
m	pointer
->	O
msg	pointer
=	O
SLang_create_slstring	function
(	O
msg	pointer
)	O
)	O
)	O
)	O
{	O
free_error_msg	function
(	O
m	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
m	pointer
->	O
msg_type	int
=	O
msg_type	int
;	O
return	O
m	pointer
;	O
}	O
static	O
void	O
free_queued_messages	function
(	O
Error_Queue_Type	struct
*	O
q	pointer
)	O
{	O
Error_Message_Type	struct
*	O
m	pointer
;	O
if	O
(	O
q	pointer
==	O
NULL	O
)	O
return	O
;	O
m	pointer
=	O
q	pointer
->	O
head	pointer
;	O
while	O
(	O
m	pointer
!=	O
NULL	O
)	O
{	O
Error_Message_Type	struct
*	O
m1	pointer
=	O
m	pointer
->	O
next	pointer
;	O
free_error_msg	function
(	O
m	pointer
)	O
;	O
m	pointer
=	O
m1	pointer
;	O
}	O
q	pointer
->	O
head	pointer
=	O
NULL	O
;	O
q	pointer
->	O
tail	pointer
=	O
NULL	O
;	O
}	O
static	O
void	O
delete_msg_queue	function
(	O
Error_Queue_Type	struct
*	O
q	pointer
)	O
{	O
if	O
(	O
q	pointer
==	O
NULL	O
)	O
return	O
;	O
free_queued_messages	function
(	O
q	pointer
)	O
;	O
SLfree	O
(	O
(	O
char	O
*	O
)	O
q	pointer
)	O
;	O
}	O
static	O
Error_Queue_Type	struct
*	O
create_msg_queue	function
(	O
void	O
)	O
{	O
Error_Queue_Type	struct
*	O
q	pointer
;	O
if	O
(	O
NULL	O
==	O
(	O
q	pointer
=	O
(	O
Error_Queue_Type	struct
*	O
)	O
SLcalloc	function
(	O
1	int
,	O
sizeof	O
(	O
Error_Queue_Type	struct
)	O
)	O
)	O
)	O
return	O
NULL	O
;	O
return	O
q	pointer
;	O
}	O
static	O
int	O
queue_message	function
(	O
Error_Queue_Type	struct
*	O
q	pointer
,	O
char	O
*	O
msg	pointer
,	O
int	O
msg_type	int
)	O
{	O
Error_Message_Type	struct
*	O
m	pointer
;	O
if	O
(	O
NULL	O
==	O
(	O
m	pointer
=	O
allocate_error_msg	function
(	O
msg	pointer
,	O
msg_type	int
)	O
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
q	pointer
->	O
tail	pointer
!=	O
NULL	O
)	O
q	pointer
->	O
tail	pointer
->	O
next	pointer
=	O
m	pointer
;	O
if	O
(	O
q	pointer
->	O
head	pointer
==	O
NULL	O
)	O
q	pointer
->	O
head	pointer
=	O
m	pointer
;	O
q	pointer
->	O
tail	pointer
=	O
m	pointer
;	O
return	O
0	int
;	O
}	O
static	O
void	O
print_error	function
(	O
int	O
msg_type	int
,	O
char	O
*	O
err	pointer
)	O
{	O
unsigned	O
int	O
len	int
;	O
switch	O
(	O
msg_type	int
)	O
{	O
case	O
_SLERR_MSG_ERROR	int
:	O
if	O
(	O
SLang_Error_Hook	pointer
!=	O
NULL	O
)	O
{	O
(	O
*	O
SLang_Error_Hook	pointer
)	O
(	O
err	pointer
)	O
;	O
return	O
;	O
}	O
break	O
;	O
case	O
_SLERR_MSG_TRACEBACK	int
:	O
case	O
_SLERR_MSG_WARNING	int
:	O
if	O
(	O
SLang_Dump_Routine	pointer
!=	O
NULL	O
)	O
{	O
(	O
*	O
SLang_Dump_Routine	pointer
)	O
(	O
err	pointer
)	O
;	O
return	O
;	O
}	O
break	O
;	O
}	O
len	int
=	O
strlen	function
(	O
err	pointer
)	O
;	O
if	O
(	O
len	int
==	O
0	int
)	O
return	O
;	O
fputs	function
(	O
err	pointer
,	O
stderr	pointer
)	O
;	O
if	O
(	O
(	O
err	pointer
[	O
len	int
-	O
1	int
]	O
!=	O
'\n'	O
)	O
&&	O
(	O
msg_type	int
!=	O
_SLERR_MSG_TRACEBACK	int
)	O
)	O
fputs	function
(	O
"\n"	pointer
,	O
stderr	pointer
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
}	O
static	O
void	O
print_queue	function
(	O
void	O
)	O
{	O
if	O
(	O
-	O
1	int
==	O
_pSLerr_init	function
(	O
)	O
)	O
print_error	function
(	O
_SLERR_MSG_ERROR	int
,	O
"Unable to initialize SLerr module"	pointer
)	O
;	O
if	O
(	O
_pSLang_Error	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
Default_Error_Queue	pointer
!=	O
NULL	O
)	O
{	O
Error_Queue_Type	struct
*	O
q	pointer
=	O
Default_Error_Queue	pointer
;	O
Error_Message_Type	struct
*	O
m	pointer
=	O
q	pointer
->	O
head	pointer
;	O
while	O
(	O
m	pointer
!=	O
NULL	O
)	O
{	O
Error_Message_Type	struct
*	O
m_next	pointer
=	O
m	pointer
->	O
next	pointer
;	O
if	O
(	O
m	pointer
->	O
msg	pointer
!=	O
NULL	O
)	O
print_error	function
(	O
m	pointer
->	O
msg_type	int
,	O
m	pointer
->	O
msg	pointer
)	O
;	O
m	pointer
=	O
m_next	pointer
;	O
}	O
free_queued_messages	function
(	O
q	pointer
)	O
;	O
}	O
}	O
char	O
*	O
_pSLerr_get_error_from_queue	function
(	O
void	O
)	O
{	O
Error_Queue_Type	struct
*	O
q	pointer
;	O
Error_Message_Type	struct
*	O
m	pointer
;	O
unsigned	O
int	O
len	int
;	O
char	O
*	O
err	pointer
,	O
*	O
err1	pointer
,	O
*	O
err_max	pointer
;	O
if	O
(	O
NULL	O
==	O
(	O
q	pointer
=	O
Default_Error_Queue	pointer
)	O
)	O
return	O
NULL	O
;	O
len	int
=	O
0	int
;	O
m	pointer
=	O
q	pointer
->	O
head	pointer
;	O
while	O
(	O
m	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
m	pointer
->	O
msg_type	int
==	O
_SLERR_MSG_ERROR	int
)	O
len	int
+=	O
1	int
+	O
strlen	function
(	O
m	pointer
->	O
msg	pointer
)	O
;	O
m	pointer
=	O
m	pointer
->	O
next	pointer
;	O
}	O
if	O
(	O
len	int
)	O
len	int
--	O
;	O
if	O
(	O
NULL	O
==	O
(	O
err	pointer
=	O
_pSLallocate_slstring	function
(	O
len	int
)	O
)	O
)	O
return	O
NULL	O
;	O
err_max	pointer
=	O
err	pointer
+	O
len	int
;	O
err1	pointer
=	O
err	pointer
;	O
m	pointer
=	O
q	pointer
->	O
head	pointer
;	O
while	O
(	O
m	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
m	pointer
->	O
msg_type	int
==	O
_SLERR_MSG_ERROR	int
)	O
{	O
unsigned	O
int	O
dlen	int
=	O
strlen	function
(	O
m	pointer
->	O
msg	pointer
)	O
;	O
strcpy	function
(	O
err1	pointer
,	O
m	pointer
->	O
msg	pointer
)	O
;	O
err1	pointer
+=	O
dlen	int
;	O
if	O
(	O
err1	pointer
!=	O
err_max	pointer
)	O
*	O
err1	pointer
++	O
=	O
'\n'	O
;	O
}	O
m	pointer
=	O
m	pointer
->	O
next	pointer
;	O
}	O
*	O
err1	pointer
=	O
0	int
;	O
return	O
_pSLcreate_via_alloced_slstring	function
(	O
err	pointer
,	O
len	int
)	O
;	O
}	O
void	O
_pSLerr_print_message_queue	function
(	O
void	O
)	O
{	O
print_queue	function
(	O
)	O
;	O
}	O
static	O
volatile	O
int	O
Suspend_Error_Messages	int
=	O
0	int
;	O
int	O
_pSLerr_resume_messages	function
(	O
void	O
)	O
{	O
if	O
(	O
Suspend_Error_Messages	int
==	O
0	int
)	O
return	O
0	int
;	O
Suspend_Error_Messages	int
--	O
;	O
if	O
(	O
Suspend_Error_Messages	int
==	O
0	int
)	O
print_queue	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
_pSLerr_suspend_messages	function
(	O
void	O
)	O
{	O
Suspend_Error_Messages	int
++	O
;	O
return	O
0	int
;	O
}	O
void	O
_pSLerr_free_queued_messages	function
(	O
void	O
)	O
{	O
free_queued_messages	function
(	O
Default_Error_Queue	pointer
)	O
;	O
}	O
void	O
SLang_verror	function
(	O
int	O
err_code	int
,	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
char	O
err	pointer
[	O
4096	int
]	O
;	O
if	O
(	O
-	O
1	int
==	O
_pSLerr_init	function
(	O
)	O
)	O
{	O
print_queue	function
(	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
err_code	int
==	O
0	int
)	O
err_code	int
=	O
SL_INTRINSIC_ERROR	O
;	O
if	O
(	O
_pSLang_Error	int
==	O
0	int
)	O
SLang_set_error	function
(	O
err_code	int
)	O
;	O
if	O
(	O
fmt	pointer
==	O
NULL	O
)	O
return	O
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
(	O
void	O
)	O
SLvsnprintf	function
(	O
err	pointer
,	O
sizeof	O
(	O
err	pointer
)	O
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
if	O
(	O
Suspend_Error_Messages	int
)	O
(	O
void	O
)	O
queue_message	function
(	O
Default_Error_Queue	pointer
,	O
err	pointer
,	O
_SLERR_MSG_ERROR	int
)	O
;	O
else	O
print_error	function
(	O
_SLERR_MSG_ERROR	int
,	O
err	pointer
)	O
;	O
}	O
int	O
_pSLerr_traceback_msg	function
(	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
char	O
msg	pointer
[	O
4096	int
]	O
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
(	O
void	O
)	O
SLvsnprintf	function
(	O
msg	pointer
,	O
sizeof	O
(	O
msg	pointer
)	O
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
return	O
queue_message	function
(	O
Default_Error_Queue	pointer
,	O
msg	pointer
,	O
_SLERR_MSG_TRACEBACK	int
)	O
;	O
}	O
void	O
SLang_exit_error	function
(	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
print_queue	function
(	O
)	O
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
if	O
(	O
SLang_Exit_Error_Hook	pointer
!=	O
NULL	O
)	O
{	O
(	O
*	O
SLang_Exit_Error_Hook	pointer
)	O
(	O
fmt	pointer
,	O
ap	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
fmt	pointer
!=	O
NULL	O
)	O
{	O
vfprintf	function
(	O
stderr	pointer
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
stderr	pointer
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
}	O
va_end	O
(	O
ap	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
int	O
SLang_set_error	function
(	O
int	O
error	pointer
)	O
{	O
if	O
(	O
(	O
error	pointer
==	O
0	int
)	O
||	O
(	O
_pSLang_Error	int
==	O
0	int
)	O
)	O
_pSLang_Error	int
=	O
error	pointer
;	O
if	O
(	O
_pSLinterpreter_Error_Hook	pointer
!=	O
NULL	O
)	O
(	O
*	O
_pSLinterpreter_Error_Hook	pointer
)	O
(	O
_pSLang_Error	int
)	O
;	O
return	O
0	int
;	O
}	O
int	O
SLang_get_error	function
(	O
void	O
)	O
{	O
return	O
_pSLang_Error	int
;	O
}	O
void	O
SLang_vmessage	function
(	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
if	O
(	O
fmt	pointer
==	O
NULL	O
)	O
return	O
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
if	O
(	O
SLang_VMessage_Hook	pointer
!=	O
NULL	O
)	O
(	O
*	O
SLang_VMessage_Hook	pointer
)	O
(	O
fmt	pointer
,	O
ap	array
)	O
;	O
else	O
{	O
vfprintf	function
(	O
stdout	pointer
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
stdout	pointer
)	O
;	O
}	O
va_end	O
(	O
ap	array
)	O
;	O
}	O
void	O
_pSLerr_dump_msg	function
(	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
char	O
buf	pointer
[	O
1024	int
]	O
;	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
if	O
(	O
SLang_Dump_Routine	pointer
!=	O
NULL	O
)	O
{	O
(	O
void	O
)	O
SLvsnprintf	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
(	O
*	O
SLang_Dump_Routine	pointer
)	O
(	O
buf	pointer
)	O
;	O
}	O
else	O
{	O
vfprintf	function
(	O
stderr	pointer
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
}	O
va_end	O
(	O
ap	array
)	O
;	O
}	O
int	O
_pSLerr_init	function
(	O
void	O
)	O
{	O
if	O
(	O
Default_Error_Queue	pointer
==	O
NULL	O
)	O
{	O
Suspend_Error_Messages	int
=	O
0	int
;	O
if	O
(	O
NULL	O
==	O
(	O
Default_Error_Queue	pointer
=	O
create_msg_queue	function
(	O
)	O
)	O
)	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
-	O
1	int
==	O
init_exceptions	function
(	O
)	O
)	O
return	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
void	O
_pSLerr_deinit	function
(	O
void	O
)	O
{	O
deinit_exceptions	function
(	O
)	O
;	O
delete_msg_queue	function
(	O
Default_Error_Queue	pointer
)	O
;	O
Suspend_Error_Messages	int
=	O
0	int
;	O
Default_Error_Queue	pointer
=	O
NULL	O
;	O
}	O
