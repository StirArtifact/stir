static	O
const	O
char	O
VALID_PATTERN_CHARS	array
[	O
]	O
=	O
".XOxo,a!*?QY"	pointer
;	O
static	O
const	O
char	O
VALID_EDGE_CHARS	array
[	O
]	O
=	O
"+-|"	pointer
;	O
static	O
const	O
char	O
VALID_CONSTRAINT_LABELS	array
[	O
]	O
=	O
"abcdefghijklmnpqrstuvwyzABCDEFGHIJKLMNPRSTUVWZ"	pointer
;	O
static	O
int	O
nongoal	array
[	O
8	int
]	O
=	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
;	O
static	O
int	O
callback_unneeded	array
[	O
8	int
]	O
=	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
;	O
static	O
int	O
maxi	int
,	O
maxj	int
;	O
static	O
int	O
mini	int
,	O
minj	int
;	O
static	O
int	O
movei	int
,	O
movej	int
;	O
static	O
unsigned	O
int	O
where	int
;	O
static	O
int	O
el	int
;	O
static	O
struct	O
patval_b	struct
elements	pointer
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
static	O
int	O
num_stars	int
;	O
static	O
int	O
ci	int
=	O
-	O
1	int
,	O
cj	int
=	O
-	O
1	int
;	O
static	O
int	O
patno	int
;	O
static	O
int	O
discard_pattern	int
=	O
0	int
;	O
static	O
int	O
pats_with_constraints	int
=	O
0	int
;	O
static	O
int	O
label_coords	array
[	O
256	int
]	O
[	O
2	int
]	O
;	O
static	O
int	O
current_c_i	int
;	O
static	O
char	O
constraint	array
[	O
MAXCONSTRAINT	int
]	O
;	O
static	O
char	O
action	int
[	O
MAXCONSTRAINT	int
]	O
;	O
static	O
char	O
diagram	array
[	O
MAX_BOARD	int
+	O
2	int
]	O
[	O
MAX_BOARD	int
+	O
3	int
]	O
;	O
static	O
char	O
constraint_diagram	array
[	O
MAX_BOARD	int
+	O
2	int
]	O
[	O
MAX_BOARD	int
+	O
3	int
]	O
;	O
static	O
char	O
*	O
prefix	pointer
;	O
static	O
struct	O
pattern	pointer
pattern	pointer
[	O
MAXPATNO	int
]	O
;	O
static	O
char	O
pattern_names	array
[	O
MAXPATNO	int
]	O
[	O
MAXNAME	int
]	O
;	O
static	O
int	O
num_attributes	int
;	O
static	O
struct	O
pattern_attribute	struct
attributes	pointer
[	O
MAXPATNO	int
*	O
NUM_ATTRIBUTES	int
]	O
;	O
static	O
char	O
helper_fn_names	array
[	O
MAXPATNO	int
]	O
[	O
MAXNAME	int
]	O
;	O
static	O
char	O
autohelper_code	array
[	O
MAXPATNO	int
*	O
300	int
]	O
;	O
static	O
char	O
*	O
code_pos	pointer
;	O
struct	O
autohelper_func	struct
{	O
const	O
char	O
*	O
name	short
;	O
int	O
params	array
;	O
int	O
type	char
;	O
float	O
cost	float
;	O
const	O
char	O
*	O
code	int
;	O
}	O
;	O
static	O
const	O
char	O
*	O
current_file	pointer
=	O
NULL	O
;	O
static	O
int	O
current_line_number	int
=	O
0	int
;	O
struct	O
attribute_description	struct
{	O
const	O
char	O
*	O
input_name	pointer
;	O
enum	O
attribute_type	enum
type	char
;	O
}	O
;	O
static	O
const	O
char	O
*	O
attribute_name	array
[	O
NUM_ATTRIBUTES	int
+	O
1	int
]	O
=	O
{	O
"MIN_VALUE"	pointer
,	O
"MAX_VALUE"	pointer
,	O
"MIN_TERRITORY"	pointer
,	O
"MAX_TERRITORY"	pointer
,	O
"SHAPE"	pointer
,	O
"FOLLOWUP"	pointer
,	O
"REVERSE_FOLLOWUP"	pointer
,	O
"THREATENS_TO_CAPTURE"	pointer
,	O
"THREATENS_EYE"	pointer
,	O
"REVERSE_SENTE"	pointer
,	O
"LAST_ATTRIBUTE"	pointer
}	O
;	O
static	O
struct	O
attribute_description	struct
general_attribute_map	array
[	O
]	O
=	O
{	O
{	O
"value"	pointer
,	O
MIN_VALUE	int
}	O
,	O
{	O
"minvalue"	pointer
,	O
MIN_VALUE	int
}	O
,	O
{	O
"maxvalue"	pointer
,	O
MAX_VALUE	int
}	O
,	O
{	O
"terri"	pointer
,	O
MIN_TERRITORY	int
}	O
,	O
{	O
"minterri"	pointer
,	O
MIN_TERRITORY	int
}	O
,	O
{	O
"maxterri"	pointer
,	O
MAX_TERRITORY	int
}	O
,	O
{	O
"shape"	pointer
,	O
SHAPE	int
}	O
,	O
{	O
"followup"	pointer
,	O
FOLLOWUP	int
}	O
,	O
{	O
"followup_value"	pointer
,	O
FOLLOWUP	int
}	O
,	O
{	O
"reverse_followup"	pointer
,	O
REVERSE_FOLLOWUP	int
}	O
,	O
{	O
NULL	O
,	O
LAST_ATTRIBUTE	int
}	O
}	O
;	O
static	O
struct	O
attribute_description	struct
value_only_attribute_map	array
[	O
]	O
=	O
{	O
{	O
"value"	pointer
,	O
IN_PATTERN_VALUE	O
}	O
,	O
{	O
NULL	O
,	O
LAST_ATTRIBUTE	int
}	O
}	O
;	O
static	O
struct	O
attribute_description	struct
owl_attack_attribute_map	array
[	O
]	O
=	O
{	O
{	O
"value"	pointer
,	O
IN_PATTERN_VALUE	O
}	O
,	O
{	O
"threatens_to_capture"	pointer
,	O
THREATENS_TO_CAPTURE	int
}	O
,	O
{	O
"threatens_eye"	pointer
,	O
THREATENS_EYE	int
}	O
,	O
{	O
"reverse_sente"	pointer
,	O
REVERSE_SENTE	int
}	O
,	O
{	O
NULL	O
,	O
LAST_ATTRIBUTE	int
}	O
}	O
;	O
static	O
struct	O
attribute_description	struct
owl_defense_attribute_map	array
[	O
]	O
=	O
{	O
{	O
"value"	pointer
,	O
IN_PATTERN_VALUE	O
}	O
,	O
{	O
"threatens_to_capture"	pointer
,	O
THREATENS_TO_CAPTURE	int
}	O
,	O
{	O
"threatens_eye"	pointer
,	O
THREATENS_EYE	int
}	O
,	O
{	O
"reverse_sente"	pointer
,	O
REVERSE_SENTE	int
}	O
,	O
{	O
NULL	O
,	O
LAST_ATTRIBUTE	int
}	O
}	O
;	O
static	O
struct	O
attribute_description	struct
*	O
attribute_map	pointer
=	O
NULL	O
;	O
static	O
int	O
attributes_needed	int
=	O
0	int
;	O
static	O
struct	O
autohelper_func	struct
autohelper_functions	array
[	O
]	O
=	O
{	O
{	O
"lib2"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"worm[%s].liberties2"	pointer
}	O
,	O
{	O
"lib3"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"worm[%s].liberties3"	pointer
}	O
,	O
{	O
"lib4"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"worm[%s].liberties4"	pointer
}	O
,	O
{	O
"lib"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"countlib(%s)"	pointer
}	O
,	O
{	O
"alive"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"(dragon[%s].status == ALIVE)"	pointer
}	O
,	O
{	O
"unknown"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"(dragon[%s].status == UNKNOWN)"	pointer
}	O
,	O
{	O
"critical"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"(dragon[%s].status == CRITICAL)"	pointer
}	O
,	O
{	O
"dead"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"(dragon[%s].status == DEAD)"	pointer
}	O
,	O
{	O
"status"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"dragon[%s].status"	pointer
}	O
,	O
{	O
"ko"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"is_ko_point(%s)"	pointer
}	O
,	O
{	O
"xdefend_against"	pointer
,	O
2	int
,	O
0	int
,	O
1.00	int
,	O
"defend_against(%s, OTHER_COLOR(color), %s)"	pointer
}	O
,	O
{	O
"odefend_against"	pointer
,	O
2	int
,	O
0	int
,	O
1.00	int
,	O
"defend_against(%s, color, %s)"	pointer
}	O
,	O
{	O
"defend_against_atari"	pointer
,	O
1	int
,	O
0	int
,	O
1.00	int
,	O
"defend_against_atari_helper(move, %s)"	pointer
}	O
,	O
{	O
"does_defend"	pointer
,	O
2	int
,	O
0	int
,	O
1.00	int
,	O
"does_defend(%s, %s)"	pointer
}	O
,	O
{	O
"does_attack"	pointer
,	O
2	int
,	O
0	int
,	O
1.00	int
,	O
"does_attack(%s, %s)"	pointer
}	O
,	O
{	O
"attack"	pointer
,	O
1	int
,	O
0	int
,	O
1.00	int
,	O
"ATTACK_MACRO(%s)"	pointer
}	O
,	O
{	O
"defend"	pointer
,	O
1	int
,	O
0	int
,	O
1.00	int
,	O
"DEFEND_MACRO(%s)"	pointer
}	O
,	O
{	O
"weakness"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"dragon_weakness(%s, 0)"	pointer
}	O
,	O
{	O
"weak"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"dragon_weak(%s)"	pointer
}	O
,	O
{	O
"safe_xmove"	pointer
,	O
1	int
,	O
0	int
,	O
1.00	int
,	O
"safe_move(%s, OTHER_COLOR(color))"	pointer
}	O
,	O
{	O
"safe_omove"	pointer
,	O
1	int
,	O
0	int
,	O
1.00	int
,	O
"safe_move(%s, color)"	pointer
}	O
,	O
{	O
"legal_xmove"	pointer
,	O
1	int
,	O
0	int
,	O
0.05	int
,	O
"is_legal(%s, OTHER_COLOR(color))"	pointer
}	O
,	O
{	O
"legal_omove"	pointer
,	O
1	int
,	O
0	int
,	O
0.05	int
,	O
"is_legal(%s, color)"	pointer
}	O
,	O
{	O
"x_suicide"	pointer
,	O
1	int
,	O
0	int
,	O
0.05	int
,	O
"is_suicide(%s, OTHER_COLOR(color))"	pointer
}	O
,	O
{	O
"o_suicide"	pointer
,	O
1	int
,	O
0	int
,	O
0.05	int
,	O
"is_suicide(%s, color)"	pointer
}	O
,	O
{	O
"x_alive_somewhere"	pointer
,	O
0	int
,	O
1	int
,	O
0.01	int
,	O
"somewhere(OTHER_COLOR(color), 1, %d"	pointer
}	O
,	O
{	O
"o_alive_somewhere"	pointer
,	O
0	int
,	O
1	int
,	O
0.01	int
,	O
"somewhere(color, 1, %d"	pointer
}	O
,	O
{	O
"x_somewhere"	pointer
,	O
0	int
,	O
1	int
,	O
0.01	int
,	O
"somewhere(OTHER_COLOR(color), 0, %d"	pointer
}	O
,	O
{	O
"o_somewhere"	pointer
,	O
0	int
,	O
1	int
,	O
0.01	int
,	O
"somewhere(color, 0, %d"	pointer
}	O
,	O
{	O
"xmoyo_opposite"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"(whose_moyo(INITIAL_INFLUENCE(color), %s) == OTHER_COLOR(color))"	pointer
}	O
,	O
{	O
"omoyo_opposite"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"(whose_moyo(INITIAL_INFLUENCE(color), %s) == color)"	pointer
}	O
,	O
{	O
"xmoyo"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"(whose_moyo(OPPOSITE_INFLUENCE(color), %s) == OTHER_COLOR(color))"	pointer
}	O
,	O
{	O
"omoyo"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"(whose_moyo(OPPOSITE_INFLUENCE(color), %s) == color)"	pointer
}	O
,	O
{	O
"xarea"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"(whose_area(OPPOSITE_INFLUENCE(color), %s) == OTHER_COLOR(color))"	pointer
}	O
,	O
{	O
"oarea"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"(whose_area(OPPOSITE_INFLUENCE(color), %s) == color)"	pointer
}	O
,	O
{	O
"xterri"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"(whose_territory(OPPOSITE_INFLUENCE(color), %s) == OTHER_COLOR(color))"	pointer
}	O
,	O
{	O
"oterri"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"(whose_territory(OPPOSITE_INFLUENCE(color), %s) == color)"	pointer
}	O
,	O
{	O
"genus"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"dragon[%s].genus"	pointer
}	O
,	O
{	O
"approx_xlib"	pointer
,	O
1	int
,	O
0	int
,	O
0.03	int
,	O
"approxlib(%s, OTHER_COLOR(color), MAX_LIBERTIES, NULL)"	pointer
}	O
,	O
{	O
"approx_olib"	pointer
,	O
1	int
,	O
0	int
,	O
0.03	int
,	O
"approxlib(%s, color, MAX_LIBERTIES, NULL)"	pointer
}	O
,	O
{	O
"xlib"	pointer
,	O
1	int
,	O
0	int
,	O
0.05	int
,	O
"accuratelib(%s, OTHER_COLOR(color), MAX_LIBERTIES, NULL)"	pointer
}	O
,	O
{	O
"olib"	pointer
,	O
1	int
,	O
0	int
,	O
0.05	int
,	O
"accuratelib(%s, color, MAX_LIBERTIES, NULL)"	pointer
}	O
,	O
{	O
"xcut"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"cut_possible(%s, OTHER_COLOR(color))"	pointer
}	O
,	O
{	O
"ocut"	pointer
,	O
1	int
,	O
0	int
,	O
0.05	int
,	O
"cut_possible(%s, color)"	pointer
}	O
,	O
{	O
"edge_double_sente"	pointer
,	O
4	int
,	O
1	int
,	O
3.00	int
,	O
"edge_double_sente_helper(%s, %s, %s, %s)"	pointer
}	O
,	O
{	O
"xplay_defend_both"	pointer
,	O
2	int
,	O
1	int
,	O
3.00	int
,	O
"play_attack_defend2_n(OTHER_COLOR(color), 0, %d"	pointer
}	O
,	O
{	O
"oplay_defend_both"	pointer
,	O
2	int
,	O
1	int
,	O
3.00	int
,	O
"play_attack_defend2_n(color, 0, %d"	pointer
}	O
,	O
{	O
"xplay_attack_either"	pointer
,	O
2	int
,	O
1	int
,	O
3.00	int
,	O
"play_attack_defend2_n(OTHER_COLOR(color), 1, %d"	pointer
}	O
,	O
{	O
"oplay_attack_either"	pointer
,	O
2	int
,	O
1	int
,	O
3.00	int
,	O
"play_attack_defend2_n(color, 1, %d"	pointer
}	O
,	O
{	O
"xplay_defend"	pointer
,	O
1	int
,	O
1	int
,	O
1.00	int
,	O
"play_attack_defend_n(OTHER_COLOR(color), 0, %d"	pointer
}	O
,	O
{	O
"oplay_defend"	pointer
,	O
1	int
,	O
1	int
,	O
1.00	int
,	O
"play_attack_defend_n(color, 0, %d"	pointer
}	O
,	O
{	O
"xplay_attack"	pointer
,	O
1	int
,	O
1	int
,	O
1.00	int
,	O
"play_attack_defend_n(OTHER_COLOR(color), 1, %d"	pointer
}	O
,	O
{	O
"oplay_attack"	pointer
,	O
1	int
,	O
1	int
,	O
1.00	int
,	O
"play_attack_defend_n(color, 1, %d"	pointer
}	O
,	O
{	O
"xplay_break_through"	pointer
,	O
3	int
,	O
1	int
,	O
5.00	int
,	O
"play_break_through_n(OTHER_COLOR(color), %d"	pointer
}	O
,	O
{	O
"oplay_break_through"	pointer
,	O
3	int
,	O
1	int
,	O
5.00	int
,	O
"play_break_through_n(color, %d"	pointer
}	O
,	O
{	O
"oplay_connect"	pointer
,	O
2	int
,	O
1	int
,	O
10.00	int
,	O
"play_connect_n(color, 1, %d"	pointer
}	O
,	O
{	O
"xplay_connect"	pointer
,	O
2	int
,	O
1	int
,	O
10.00	int
,	O
"play_connect_n(OTHER_COLOR(color), 1, %d"	pointer
}	O
,	O
{	O
"oplay_disconnect"	pointer
,	O
2	int
,	O
1	int
,	O
10.00	int
,	O
"play_connect_n(color, 0, %d"	pointer
}	O
,	O
{	O
"xplay_disconnect"	pointer
,	O
2	int
,	O
1	int
,	O
10.00	int
,	O
"play_connect_n(OTHER_COLOR(color), 0, %d"	pointer
}	O
,	O
{	O
"oplay_lib"	pointer
,	O
1	int
,	O
1	int
,	O
0.06	int
,	O
"play_lib_n(color, %d"	pointer
}	O
,	O
{	O
"xplay_lib"	pointer
,	O
1	int
,	O
1	int
,	O
0.06	int
,	O
"play_lib_n(OTHER_COLOR(color), %d"	pointer
}	O
,	O
{	O
"seki_helper"	pointer
,	O
1	int
,	O
0	int
,	O
0.0	int
,	O
"seki_helper(%s)"	pointer
}	O
,	O
{	O
"threaten_to_save"	pointer
,	O
1	int
,	O
0	int
,	O
0.0	int
,	O
"threaten_to_save_helper(move,%s)"	pointer
}	O
,	O
{	O
"threaten_to_capture"	pointer
,	O
1	int
,	O
0	int
,	O
0.0	int
,	O
"threaten_to_capture_helper(move,%s)"	pointer
}	O
,	O
{	O
"prevent_attack_threat"	pointer
,	O
1	int
,	O
0	int
,	O
0.0	int
,	O
"prevent_attack_threat_helper(move, %s)"	pointer
}	O
,	O
{	O
"eye"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"is_eye_space(%s)"	pointer
}	O
,	O
{	O
"proper_eye"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"is_proper_eye_space(%s)"	pointer
}	O
,	O
{	O
"marginal_eye"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"is_marginal_eye_space(%s)"	pointer
}	O
,	O
{	O
"halfeye"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"is_halfeye(half_eye,%s)"	pointer
}	O
,	O
{	O
"max_eye_value"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"max_eye_value(%s)"	pointer
}	O
,	O
{	O
"owl_topological_eye"	pointer
,	O
2	int
,	O
0	int
,	O
0.01	int
,	O
"owl_topological_eye(%s, board[%s])"	pointer
}	O
,	O
{	O
"obvious_false_oeye"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"obvious_false_eye(%s, color)"	pointer
}	O
,	O
{	O
"obvious_false_xeye"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"obvious_false_eye(%s, OTHER_COLOR(color))"	pointer
}	O
,	O
{	O
"antisuji"	pointer
,	O
1	int
,	O
0	int
,	O
0.0	int
,	O
"add_antisuji_move(%s)"	pointer
}	O
,	O
{	O
"add_connect_move"	pointer
,	O
2	int
,	O
0	int
,	O
0.0	int
,	O
"add_connection_move(move,%s, %s)"	pointer
}	O
,	O
{	O
"add_cut_move"	pointer
,	O
2	int
,	O
0	int
,	O
0.0	int
,	O
"add_cut_move(move, %s, %s)"	pointer
}	O
,	O
{	O
"test_attack_either_move"	pointer
,	O
2	int
,	O
0	int
,	O
0.0	int
,	O
"test_attack_either_move(move, color, %s, %s)"	pointer
}	O
,	O
{	O
"add_defend_both_move"	pointer
,	O
2	int
,	O
0	int
,	O
0.0	int
,	O
"add_all_move(move, DEFEND_STRING, %s, DEFEND_STRING, %s)"	pointer
}	O
,	O
{	O
"same_dragon"	pointer
,	O
2	int
,	O
0	int
,	O
0.01	int
,	O
"is_same_dragon(%s, %s)"	pointer
}	O
,	O
{	O
"same_string"	pointer
,	O
2	int
,	O
0	int
,	O
0.01	int
,	O
"same_string(%s, %s)"	pointer
}	O
,	O
{	O
"dragonsize"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"dragon[%s].size"	pointer
}	O
,	O
{	O
"wormsize"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"countstones(%s)"	pointer
}	O
,	O
{	O
"effective_size"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"dragon[%s].effective_size"	pointer
}	O
,	O
{	O
"vital_chain"	pointer
,	O
1	int
,	O
0	int
,	O
0.05	int
,	O
"vital_chain(%s)"	pointer
}	O
,	O
{	O
"potential_cutstone"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"worm[%s].cutstone2 > 1"	pointer
}	O
,	O
{	O
"amalgamate_most_valuable_helper"	pointer
,	O
3	int
,	O
0	int
,	O
0.0	int
,	O
"amalgamate_most_valuable_helper(%s, %s, %s)"	pointer
}	O
,	O
{	O
"amalgamate"	pointer
,	O
2	int
,	O
0	int
,	O
0.0	int
,	O
"join_dragons(%s, %s)"	pointer
}	O
,	O
{	O
"owl_escape_value"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"owl_escape_value(%s)"	pointer
}	O
,	O
{	O
"owl_goal_dragon"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"owl_goal_dragon(%s)"	pointer
}	O
,	O
{	O
"owl_eyespace"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"owl_eyespace(%s)"	pointer
}	O
,	O
{	O
"owl_big_eyespace"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"owl_big_eyespace(%s)"	pointer
}	O
,	O
{	O
"owl_mineye"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"owl_mineye(%s)"	pointer
}	O
,	O
{	O
"owl_maxeye"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"owl_maxeye(%s)"	pointer
}	O
,	O
{	O
"owl_proper_eye"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"owl_proper_eye(%s)"	pointer
}	O
,	O
{	O
"owl_eye_size"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"owl_eye_size(%s)"	pointer
}	O
,	O
{	O
"owl_lunch"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"owl_lunch(%s)"	pointer
}	O
,	O
{	O
"owl_strong_dragon"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"owl_strong_dragon(%s)"	pointer
}	O
,	O
{	O
"has_aji"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"(dragon[%s].owl_threat_status == CAN_THREATEN_DEFENSE)"	pointer
}	O
,	O
{	O
"finish_ko_helper"	pointer
,	O
1	int
,	O
0	int
,	O
0.05	int
,	O
"finish_ko_helper(%s)"	pointer
}	O
,	O
{	O
"squeeze_ko_helper"	pointer
,	O
1	int
,	O
0	int
,	O
0.03	int
,	O
"squeeze_ko_helper(%s)"	pointer
}	O
,	O
{	O
"backfill_helper"	pointer
,	O
3	int
,	O
0	int
,	O
1.50	int
,	O
"backfill_helper(%s, %s, %s)"	pointer
}	O
,	O
{	O
"connect_and_cut_helper2"	pointer
,	O
3	int
,	O
0	int
,	O
3.00	int
,	O
"connect_and_cut_helper2(%s, %s, %s, color)"	pointer
}	O
,	O
{	O
"connect_and_cut_helper"	pointer
,	O
3	int
,	O
0	int
,	O
3.00	int
,	O
"connect_and_cut_helper(%s, %s, %s)"	pointer
}	O
,	O
{	O
"owl_threatens"	pointer
,	O
2	int
,	O
0	int
,	O
0.01	int
,	O
"owl_threatens_attack(%s, %s)"	pointer
}	O
,	O
{	O
"replace"	pointer
,	O
2	int
,	O
0	int
,	O
0.0	int
,	O
"add_replacement_move(%s, %s, color)"	pointer
}	O
,	O
{	O
"backfill_replace"	pointer
,	O
2	int
,	O
0	int
,	O
0.0	int
,	O
"backfill_replace(%s, %s)"	pointer
}	O
,	O
{	O
"non_oterritory"	pointer
,	O
1	int
,	O
0	int
,	O
0.0	int
,	O
"influence_mark_non_territory(%s, color)"	pointer
}	O
,	O
{	O
"non_xterritory"	pointer
,	O
1	int
,	O
0	int
,	O
0.0	int
,	O
"influence_mark_non_territory(%s, OTHER_COLOR(color))"	pointer
}	O
,	O
{	O
"remaining_handicap_stones"	pointer
,	O
0	int
,	O
0	int
,	O
0.0	int
,	O
"free_handicap_remaining_stones()"	pointer
}	O
,	O
{	O
"total_handicap_stones"	pointer
,	O
0	int
,	O
0	int
,	O
0.0	int
,	O
"free_handicap_total_stones()"	pointer
}	O
,	O
{	O
"o_captures_something"	pointer
,	O
1	int
,	O
0	int
,	O
0.02	int
,	O
"does_capture_something(%s, color)"	pointer
}	O
,	O
{	O
"x_captures_something"	pointer
,	O
1	int
,	O
0	int
,	O
0.02	int
,	O
"does_capture_something(%s, OTHER_COLOR(color))"	pointer
}	O
,	O
{	O
"false_eye_territory"	pointer
,	O
1	int
,	O
0	int
,	O
0.0	int
,	O
"false_eye_territory[%s]"	pointer
}	O
,	O
{	O
"false_eye"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"is_false_eye(half_eye, %s)"	pointer
}	O
,	O
{	O
"o_visible_along_edge"	pointer
,	O
2	int
,	O
0	int
,	O
0.05	int
,	O
"visible_along_edge(color,%s,%s)"	pointer
}	O
,	O
{	O
"x_visible_along_edge"	pointer
,	O
2	int
,	O
0	int
,	O
0.05	int
,	O
"visible_along_edge(OTHER_COLOR(color),%s,%s)"	pointer
}	O
,	O
{	O
"is_surrounded"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"is_surrounded(%s)"	pointer
}	O
,	O
{	O
"does_surround"	pointer
,	O
2	int
,	O
0	int
,	O
1.00	int
,	O
"does_surround(%s, %s)"	pointer
}	O
,	O
{	O
"surround_map"	pointer
,	O
2	int
,	O
0	int
,	O
0.01	int
,	O
"surround_map(%s, %s)"	pointer
}	O
,	O
{	O
"oracle_threatens"	pointer
,	O
2	int
,	O
0	int
,	O
0.01	int
,	O
"oracle_threatens(%s, %s)"	pointer
}	O
,	O
{	O
"value"	pointer
,	O
0	int
,	O
2	int
,	O
0.0	int
,	O
"(%s->value)"	pointer
}	O
,	O
{	O
"adjacent_to_stone_in_atari"	pointer
,	O
1	int
,	O
0	int
,	O
1.0	int
,	O
"adjacent_to_stone_in_atari(%s)"	pointer
}	O
,	O
{	O
"adjacent_to_defendable_stone_in_atari"	pointer
,	O
1	int
,	O
0	int
,	O
1.0	int
,	O
"adjacent_to_defendable_stone_in_atari(%s)"	pointer
}	O
,	O
{	O
"good_attack_threat"	pointer
,	O
2	int
,	O
0	int
,	O
0.01	int
,	O
"register_good_attack_threat(%s, %s)"	pointer
}	O
,	O
{	O
"known_safe_move"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"register_known_safe_move(%s)"	pointer
}	O
,	O
{	O
"break_mirror_helper"	pointer
,	O
1	int
,	O
0	int
,	O
0.01	int
,	O
"break_mirror_helper(%s, color)"	pointer
}	O
}	O
;	O
static	O
int	O
dummyhelper	function
(	O
int	O
transformation	array
,	O
int	O
move	pointer
,	O
int	O
color	int
,	O
int	O
action	int
)	O
{	O
UNUSED	O
(	O
transformation	array
)	O
;	O
UNUSED	O
(	O
move	pointer
)	O
;	O
UNUSED	O
(	O
color	int
)	O
;	O
UNUSED	O
(	O
action	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
fatal_errors	int
=	O
0	int
;	O
int	O
verbose	int
=	O
0	int
;	O
static	O
int	O
database_type	int
=	O
0	int
;	O
static	O
int	O
anchor	int
=	O
0	int
;	O
static	O
int	O
choose_best_anchor	int
=	O
0	int
;	O
static	O
int	O
fixed_anchor	int
=	O
0	int
;	O
static	O
dfa_t	struct
dfa	struct
;	O
static	O
dfa_patterns	struct
dfa_pats	struct
;	O
static	O
int	O
transformation_hint	int
;	O
static	O
int	O
labels_transformation	int
=	O
0	int
;	O
struct	O
hint_data	struct
{	O
char	O
name	short
[	O
MAXNAME	int
]	O
;	O
int	O
transformation_hint	int
;	O
struct	O
hint_data	struct
*	O
next	pointer
;	O
}	O
;	O
static	O
struct	O
hint_data	struct
*	O
first_hint	pointer
=	O
NULL	O
;	O
static	O
void	O
parse_transformations_file	function
(	O
FILE	struct
*	O
file	pointer
)	O
{	O
struct	O
hint_data	struct
*	O
*	O
link	pointer
=	O
&	O
first_hint	pointer
;	O
while	O
(	O
!	O
feof	function
(	O
file	pointer
)	O
)	O
{	O
int	O
n	int
;	O
struct	O
hint_data	struct
*	O
hint	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
*	O
hint	pointer
)	O
)	O
;	O
n	int
=	O
fscanf	function
(	O
file	pointer
,	O
"%s %d"	pointer
,	O
hint	pointer
->	O
name	short
,	O
&	O
hint	pointer
->	O
transformation_hint	int
)	O
;	O
if	O
(	O
n	int
==	O
2	int
)	O
{	O
hint	pointer
->	O
next	pointer
=	O
NULL	O
;	O
*	O
link	pointer
=	O
hint	pointer
;	O
link	pointer
=	O
&	O
hint	pointer
->	O
next	pointer
;	O
}	O
else	O
free	function
(	O
hint	pointer
)	O
;	O
}	O
}	O
static	O
int	O
find_transformation_hint	function
(	O
const	O
char	O
*	O
pattern_name	pointer
)	O
{	O
struct	O
hint_data	struct
*	O
hint	pointer
;	O
if	O
(	O
database_type	int
==	O
DB_DFA	O
||	O
database_type	int
==	O
OPTIMIZE_DFA	O
)	O
{	O
for	O
(	O
hint	pointer
=	O
first_hint	pointer
;	O
hint	pointer
;	O
hint	pointer
=	O
hint	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
hint	pointer
->	O
name	short
,	O
pattern_name	pointer
)	O
)	O
return	O
hint	pointer
->	O
transformation_hint	int
;	O
}	O
}	O
return	O
database_type	int
==	O
OPTIMIZE_DFA	O
?	O
-	O
1	int
:	O
0	int
;	O
}	O
static	O
void	O
check_constraint_diagram	function
(	O
void	O
)	O
{	O
int	O
i	int
,	O
j	int
,	O
ino	int
=	O
0	int
,	O
iso	int
=	O
0	int
,	O
jwo	int
=	O
0	int
;	O
int	O
have_constraint	int
=	O
(	O
pattern	pointer
[	O
patno	int
]	O
.	O
autohelper_flag	int
&	O
HAVE_CONSTRAINT	int
)	O
;	O
if	O
(	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"patno: %d\n"	pointer
,	O
patno	int
)	O
;	O
if	O
(	O
where	int
&	O
NORTH_EDGE	int
)	O
ino	int
=	O
1	int
;	O
if	O
(	O
where	int
&	O
SOUTH_EDGE	int
)	O
iso	int
=	O
1	int
;	O
if	O
(	O
where	int
&	O
WEST_EDGE	int
)	O
jwo	int
=	O
1	int
;	O
if	O
(	O
verbose	int
)	O
{	O
for	O
(	O
i	int
=	O
ino	int
;	O
i	int
<=	O
maxi	int
+	O
ino	int
+	O
iso	int
;	O
i	int
++	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%02d %s\n"	pointer
,	O
i	int
,	O
diagram	array
[	O
i	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
ino	int
;	O
i	int
<=	O
maxi	int
+	O
ino	int
+	O
iso	int
;	O
i	int
++	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%02d %s\n"	pointer
,	O
i	int
,	O
constraint_diagram	array
[	O
i	int
]	O
)	O
;	O
}	O
if	O
(	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"have_constraint: %d\n"	pointer
,	O
have_constraint	int
)	O
;	O
if	O
(	O
have_constraint	int
&&	O
el	int
)	O
{	O
for	O
(	O
i	int
=	O
ino	int
;	O
i	int
<=	O
maxi	int
+	O
ino	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
jwo	int
;	O
j	int
<=	O
maxj	int
+	O
jwo	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%2d %2d %c %c\n"	pointer
,	O
i	int
,	O
j	int
,	O
constraint_diagram	array
[	O
i	int
]	O
[	O
j	int
]	O
,	O
diagram	array
[	O
i	int
]	O
[	O
j	int
]	O
)	O
;	O
if	O
(	O
strchr	function
(	O
CHECK_CHARS	pointer
,	O
constraint_diagram	array
[	O
i	int
]	O
[	O
j	int
]	O
)	O
&&	O
constraint_diagram	array
[	O
i	int
]	O
[	O
j	int
]	O
!=	O
diagram	array
[	O
i	int
]	O
[	O
j	int
]	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : Error : "	pointer
"xXoO not matched in constraint diagram of pattern %s\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
fatal_errors	int
++	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
reset_pattern	function
(	O
void	O
)	O
{	O
int	O
i	int
,	O
j	int
;	O
maxi	int
=	O
0	int
;	O
maxj	int
=	O
0	int
;	O
ci	int
=	O
-	O
1	int
;	O
cj	int
=	O
-	O
1	int
;	O
where	int
=	O
0	int
;	O
el	int
=	O
0	int
;	O
num_stars	int
=	O
0	int
;	O
strcpy	function
(	O
helper_fn_names	array
[	O
patno	int
]	O
,	O
"NULL"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
256	int
;	O
i	int
++	O
)	O
label_coords	array
[	O
i	int
]	O
[	O
0	int
]	O
=	O
-	O
1	int
;	O
current_c_i	int
=	O
0	int
;	O
constraint	array
[	O
0	int
]	O
=	O
0	int
;	O
action	int
[	O
0	int
]	O
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
MAX_BOARD	int
+	O
2	int
;	O
i	int
++	O
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
MAX_BOARD	int
+	O
3	int
;	O
j	int
++	O
)	O
{	O
diagram	array
[	O
i	int
]	O
[	O
j	int
]	O
=	O
'\0'	O
;	O
constraint_diagram	array
[	O
i	int
]	O
[	O
j	int
]	O
=	O
'\0'	O
;	O
}	O
}	O
memset	function
(	O
&	O
pattern	pointer
[	O
patno	int
]	O
,	O
0	int
,	O
sizeof	O
(	O
struct	O
pattern	pointer
)	O
)	O
;	O
}	O
static	O
void	O
find_extents	function
(	O
void	O
)	O
{	O
--	O
maxi	int
;	O
--	O
maxj	int
;	O
if	O
(	O
where	int
&	O
(	O
NORTH_EDGE	int
|	O
SOUTH_EDGE	int
|	O
EAST_EDGE	int
|	O
WEST_EDGE	int
)	O
)	O
++	O
pats_with_constraints	int
;	O
if	O
(	O
verbose	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"Pattern %s has constraints 0x%x\n"	pointer
,	O
pattern_names	array
[	O
patno	int
]	O
,	O
where	int
)	O
;	O
pattern	pointer
[	O
patno	int
]	O
.	O
edge_constraints	int
=	O
where	int
;	O
pattern	pointer
[	O
patno	int
]	O
.	O
mini	int
=	O
mini	int
-	O
ci	int
;	O
pattern	pointer
[	O
patno	int
]	O
.	O
minj	int
=	O
minj	int
-	O
cj	int
;	O
pattern	pointer
[	O
patno	int
]	O
.	O
maxi	int
=	O
maxi	int
-	O
ci	int
;	O
pattern	pointer
[	O
patno	int
]	O
.	O
maxj	int
=	O
maxj	int
-	O
cj	int
;	O
}	O
static	O
void	O
write_to_dfa	function
(	O
int	O
index	function
)	O
{	O
char	O
str	int
[	O
DFA_MAX_ORDER	O
+	O
1	int
]	O
;	O
char	O
strrot	pointer
[	O
DFA_MAX_ORDER	O
+	O
1	int
]	O
;	O
assert	O
(	O
ci	int
!=	O
-	O
1	int
&&	O
cj	int
!=	O
-	O
1	int
)	O
;	O
pattern	pointer
[	O
index	function
]	O
.	O
name	short
=	O
&	O
(	O
pattern_names	array
[	O
index	function
]	O
[	O
0	int
]	O
)	O
;	O
pattern_2_string	function
(	O
pattern	pointer
+	O
index	function
,	O
elements	pointer
,	O
str	int
,	O
ci	int
,	O
cj	int
)	O
;	O
if	O
(	O
verbose	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"Add   :%s\n"	pointer
,	O
pattern	pointer
[	O
index	function
]	O
.	O
name	short
)	O
;	O
if	O
(	O
database_type	int
==	O
DB_DFA	O
)	O
{	O
float	O
ratio	float
;	O
dfa_rotate_string	function
(	O
strrot	pointer
,	O
str	int
,	O
transformation_hint	int
)	O
;	O
ratio	float
=	O
(	O
(	O
dfa_add_string	function
(	O
&	O
dfa	struct
,	O
strrot	pointer
,	O
index	function
,	O
transformation_hint	int
)	O
-	O
1.0	int
)	O
*	O
100	int
)	O
;	O
if	O
(	O
dfa_size	function
(	O
&	O
dfa	struct
)	O
>	O
100	int
&&	O
ratio	float
>	O
10.0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Pattern %s => %3.1f%% increase: "	pointer
,	O
pattern	pointer
[	O
index	function
]	O
.	O
name	short
,	O
ratio	float
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"another orientation may save memory.\n"	pointer
)	O
;	O
}	O
if	O
(	O
dfa_verbose	int
>	O
2	int
)	O
dump_dfa	function
(	O
stderr	pointer
,	O
&	O
dfa	struct
)	O
;	O
labels_transformation	int
=	O
transformation_hint	int
;	O
}	O
else	O
{	O
int	O
ll	int
;	O
int	O
rot_start	int
=	O
0	int
;	O
int	O
rot_stop	int
=	O
pattern	pointer
[	O
index	function
]	O
.	O
trfno	int
;	O
assert	O
(	O
database_type	int
==	O
OPTIMIZE_DFA	O
)	O
;	O
if	O
(	O
rot_stop	int
==	O
5	int
)	O
{	O
rot_start	int
=	O
2	int
;	O
rot_stop	int
=	O
6	int
;	O
}	O
for	O
(	O
ll	int
=	O
rot_start	int
;	O
ll	int
<	O
rot_stop	int
;	O
ll	int
++	O
)	O
{	O
dfa_rotate_string	function
(	O
strrot	pointer
,	O
str	int
,	O
ll	int
)	O
;	O
dfa_patterns_add_pattern	function
(	O
&	O
dfa_pats	struct
,	O
strrot	pointer
,	O
index	function
)	O
;	O
}	O
if	O
(	O
transformation_hint	int
==	O
-	O
1	int
)	O
dfa_patterns_select_shortest_variation	function
(	O
&	O
dfa_pats	struct
)	O
;	O
else	O
{	O
dfa_patterns_set_last_pattern_variation	function
(	O
&	O
dfa_pats	struct
,	O
(	O
transformation_hint	int
-	O
rot_start	int
)	O
)	O
;	O
}	O
}	O
}	O
static	O
void	O
compute_grids	function
(	O
void	O
)	O
{	O
static	O
const	O
unsigned	O
int	O
and_mask	array
[	O
]	O
=	O
{	O
3	int
,	O
3	int
,	O
3	int
,	O
1	int
,	O
2	int
,	O
3	int
,	O
3	int
,	O
3	int
}	O
;	O
static	O
const	O
unsigned	O
int	O
val_mask	array
[	O
]	O
=	O
{	O
0	int
,	O
2	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
;	O
int	O
ll	int
;	O
int	O
k	int
;	O
for	O
(	O
ll	int
=	O
0	int
;	O
ll	int
<	O
8	int
;	O
++	O
ll	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
el	int
;	O
++	O
k	int
)	O
{	O
int	O
ti	int
,	O
tj	int
;	O
int	O
di	int
,	O
dj	int
;	O
TRANSFORM2	O
(	O
elements	pointer
[	O
k	int
]	O
.	O
x	int
-	O
ci	int
,	O
elements	pointer
[	O
k	int
]	O
.	O
y	int
-	O
cj	int
,	O
&	O
ti	int
,	O
&	O
tj	int
,	O
transformation_hint	int
)	O
;	O
TRANSFORM2	O
(	O
ti	int
,	O
tj	int
,	O
&	O
di	int
,	O
&	O
dj	int
,	O
ll	int
)	O
;	O
++	O
di	int
;	O
++	O
dj	int
;	O
if	O
(	O
di	int
>=	O
0	int
&&	O
di	int
<	O
4	int
&&	O
dj	int
>=	O
0	int
&&	O
dj	int
<	O
4	int
)	O
{	O
pattern	pointer
[	O
patno	int
]	O
.	O
and_mask	array
[	O
ll	int
]	O
|=	O
and_mask	array
[	O
elements	pointer
[	O
k	int
]	O
.	O
att	char
]	O
<<	O
(	O
30	int
-	O
di	int
*	O
8	int
-	O
dj	int
*	O
2	int
)	O
;	O
pattern	pointer
[	O
patno	int
]	O
.	O
val_mask	array
[	O
ll	int
]	O
|=	O
val_mask	array
[	O
elements	pointer
[	O
k	int
]	O
.	O
att	char
]	O
<<	O
(	O
30	int
-	O
di	int
*	O
8	int
-	O
dj	int
*	O
2	int
)	O
;	O
}	O
}	O
}	O
}	O
static	O
int	O
read_pattern_line	function
(	O
char	O
*	O
p	pointer
)	O
{	O
const	O
char	O
*	O
char_offset	pointer
;	O
char	O
*	O
pcopy	pointer
=	O
p	pointer
;	O
int	O
j	int
;	O
int	O
width	int
;	O
int	O
jwo	int
=	O
0	int
,	O
jeo	int
=	O
0	int
;	O
if	O
(	O
where	int
&	O
SOUTH_EDGE	int
)	O
goto	O
fatal	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'+'	O
||	O
*	O
p	pointer
==	O
'-'	O
)	O
{	O
if	O
(	O
maxi	int
==	O
0	int
)	O
where	int
|=	O
NORTH_EDGE	int
;	O
else	O
where	int
|=	O
SOUTH_EDGE	int
;	O
if	O
(	O
*	O
p	pointer
==	O
'+'	O
)	O
{	O
if	O
(	O
maxi	int
>	O
0	int
&&	O
!	O
(	O
where	int
&	O
WEST_EDGE	int
)	O
)	O
goto	O
fatal	O
;	O
where	int
|=	O
WEST_EDGE	int
;	O
++	O
p	pointer
;	O
}	O
for	O
(	O
width	int
=	O
0	int
;	O
*	O
p	pointer
==	O
'-'	O
;	O
++	O
p	pointer
,	O
++	O
width	int
)	O
;	O
if	O
(	O
width	int
==	O
0	int
)	O
goto	O
fatal	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'+'	O
)	O
{	O
if	O
(	O
maxi	int
>	O
0	int
&&	O
!	O
(	O
where	int
&	O
EAST_EDGE	int
)	O
)	O
goto	O
fatal	O
;	O
where	int
|=	O
EAST_EDGE	int
;	O
}	O
if	O
(	O
maxi	int
>	O
0	int
&&	O
width	int
!=	O
maxj	int
)	O
goto	O
notrectangle	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
*	O
p	pointer
==	O
'|'	O
)	O
{	O
if	O
(	O
!	O
(	O
where	int
&	O
WEST_EDGE	int
)	O
&&	O
(	O
(	O
where	int
&	O
NORTH_EDGE	int
)	O
||	O
maxi	int
>	O
0	int
)	O
)	O
goto	O
fatal	O
;	O
where	int
|=	O
WEST_EDGE	int
;	O
++	O
p	pointer
;	O
}	O
else	O
if	O
(	O
where	int
&	O
WEST_EDGE	int
)	O
goto	O
fatal	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
(	O
char_offset	pointer
=	O
strchr	function
(	O
VALID_PATTERN_CHARS	array
,	O
*	O
p	pointer
)	O
)	O
!=	O
NULL	O
;	O
++	O
j	int
,	O
++	O
p	pointer
)	O
{	O
int	O
off	int
=	O
char_offset	pointer
-	O
VALID_PATTERN_CHARS	array
;	O
if	O
(	O
off	int
==	O
ATT_wild	int
)	O
continue	O
;	O
if	O
(	O
off	int
==	O
ATT_a	int
)	O
goto	O
fatal	O
;	O
if	O
(	O
off	int
==	O
ATT_star	int
)	O
{	O
movei	int
=	O
maxi	int
;	O
movej	int
=	O
j	int
;	O
++	O
num_stars	int
;	O
off	int
=	O
ATT_dot	int
;	O
}	O
if	O
(	O
off	int
==	O
ATT_Q	int
)	O
{	O
off	int
=	O
ATT_O	int
;	O
ci	int
=	O
maxi	int
;	O
cj	int
=	O
j	int
;	O
pattern	pointer
[	O
patno	int
]	O
.	O
anchored_at_X	int
=	O
(	O
off	int
==	O
ATT_X	int
)	O
?	O
3	int
:	O
0	int
;	O
}	O
if	O
(	O
off	int
==	O
ATT_Y	int
)	O
{	O
off	int
=	O
ATT_X	int
;	O
ci	int
=	O
maxi	int
;	O
cj	int
=	O
j	int
;	O
pattern	pointer
[	O
patno	int
]	O
.	O
anchored_at_X	int
=	O
(	O
off	int
==	O
ATT_X	int
)	O
?	O
3	int
:	O
0	int
;	O
}	O
assert	O
(	O
off	int
<=	O
ATT_not	int
)	O
;	O
if	O
(	O
(	O
ci	int
==	O
-	O
1	int
)	O
&&	O
(	O
off	int
<	O
3	int
)	O
&&	O
(	O
(	O
off	int
&	O
anchor	int
)	O
!=	O
0	int
)	O
&&	O
!	O
fixed_anchor	int
)	O
{	O
ci	int
=	O
maxi	int
;	O
cj	int
=	O
j	int
;	O
pattern	pointer
[	O
patno	int
]	O
.	O
anchored_at_X	int
=	O
(	O
off	int
==	O
ATT_X	int
)	O
?	O
3	int
:	O
0	int
;	O
}	O
if	O
(	O
el	int
>=	O
(	O
int	O
)	O
(	O
sizeof	O
(	O
elements	pointer
)	O
/	O
sizeof	O
(	O
elements	pointer
[	O
0	int
]	O
)	O
)	O
)	O
return	O
0	int
;	O
elements	pointer
[	O
el	int
]	O
.	O
x	int
=	O
maxi	int
;	O
elements	pointer
[	O
el	int
]	O
.	O
y	int
=	O
j	int
;	O
elements	pointer
[	O
el	int
]	O
.	O
att	char
=	O
off	int
;	O
++	O
el	int
;	O
}	O
if	O
(	O
*	O
p	pointer
==	O
'|'	O
)	O
{	O
if	O
(	O
!	O
(	O
where	int
&	O
EAST_EDGE	int
)	O
&&	O
(	O
(	O
where	int
&	O
NORTH_EDGE	int
)	O
||	O
maxi	int
>	O
0	int
)	O
)	O
goto	O
fatal	O
;	O
where	int
|=	O
EAST_EDGE	int
;	O
}	O
else	O
if	O
(	O
where	int
&	O
EAST_EDGE	int
)	O
goto	O
fatal	O
;	O
if	O
(	O
maxi	int
>	O
0	int
&&	O
j	int
!=	O
maxj	int
)	O
goto	O
notrectangle	O
;	O
if	O
(	O
j	int
>	O
maxj	int
)	O
maxj	int
=	O
j	int
;	O
if	O
(	O
where	int
&	O
WEST_EDGE	int
)	O
jwo	int
=	O
1	int
;	O
if	O
(	O
where	int
&	O
EAST_EDGE	int
)	O
jeo	int
=	O
1	int
;	O
if	O
(	O
maxi	int
<=	O
MAX_BOARD	int
)	O
strncpy	function
(	O
diagram	array
[	O
maxi	int
]	O
,	O
pcopy	pointer
,	O
maxj	int
+	O
jwo	int
+	O
jeo	int
)	O
;	O
maxi	int
++	O
;	O
return	O
maxi	int
<=	O
MAX_BOARD	int
&&	O
maxj	int
<=	O
MAX_BOARD	int
;	O
fatal	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : error : Illegal pattern %s\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
fatal_errors	int
=	O
1	int
;	O
return	O
0	int
;	O
notrectangle	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : error : Pattern %s not rectangular\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
fatal_errors	int
++	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
read_constraint_diagram_line	function
(	O
char	O
*	O
p	pointer
)	O
{	O
int	O
j	int
;	O
int	O
jwo	int
=	O
0	int
,	O
jeo	int
=	O
0	int
;	O
const	O
char	O
*	O
pcopy	pointer
=	O
p	pointer
;	O
if	O
(	O
*	O
p	pointer
==	O
'+'	O
||	O
*	O
p	pointer
==	O
'-'	O
)	O
return	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'|'	O
)	O
p	pointer
++	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
strchr	function
(	O
VALID_PATTERN_CHARS	array
,	O
*	O
p	pointer
)	O
||	O
strchr	function
(	O
VALID_CONSTRAINT_LABELS	array
,	O
*	O
p	pointer
)	O
;	O
++	O
j	int
,	O
++	O
p	pointer
)	O
{	O
if	O
(	O
strchr	function
(	O
VALID_CONSTRAINT_LABELS	array
,	O
*	O
p	pointer
)	O
&&	O
label_coords	array
[	O
(	O
int	O
)	O
*	O
p	pointer
]	O
[	O
0	int
]	O
==	O
-	O
1	int
)	O
{	O
label_coords	array
[	O
(	O
int	O
)	O
*	O
p	pointer
]	O
[	O
0	int
]	O
=	O
current_c_i	int
;	O
label_coords	array
[	O
(	O
int	O
)	O
*	O
p	pointer
]	O
[	O
1	int
]	O
=	O
j	int
;	O
}	O
}	O
if	O
(	O
j	int
!=	O
maxj	int
+	O
1	int
&&	O
!	O
discard_pattern	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : error : Mismatching width of constraint line in pattern %s\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
fatal_errors	int
++	O
;	O
return	O
;	O
}	O
if	O
(	O
where	int
&	O
WEST_EDGE	int
)	O
jwo	int
=	O
1	int
;	O
if	O
(	O
where	int
&	O
EAST_EDGE	int
)	O
jeo	int
=	O
1	int
;	O
if	O
(	O
el	int
)	O
strncpy	function
(	O
constraint_diagram	array
[	O
current_c_i	int
]	O
,	O
pcopy	pointer
,	O
maxj	int
+	O
jwo	int
+	O
jeo	int
+	O
1	int
)	O
;	O
current_c_i	int
++	O
;	O
return	O
;	O
}	O
static	O
void	O
check_constraint_diagram_size	function
(	O
void	O
)	O
{	O
if	O
(	O
current_c_i	int
!=	O
maxi	int
+	O
1	int
&&	O
!	O
discard_pattern	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : error : Mismatching height of constraint diagram in pattern %s\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
fatal_errors	int
++	O
;	O
}	O
}	O
static	O
void	O
convert_attribute_labels_to_offsets	function
(	O
void	O
)	O
{	O
struct	O
pattern_attribute	struct
*	O
attribute	pointer
;	O
if	O
(	O
patno	int
<	O
0	int
||	O
!	O
pattern	pointer
[	O
patno	int
]	O
.	O
attributes	pointer
)	O
return	O
;	O
for	O
(	O
attribute	pointer
=	O
pattern	pointer
[	O
patno	int
]	O
.	O
attributes	pointer
;	O
attribute	pointer
->	O
type	char
!=	O
LAST_ATTRIBUTE	int
;	O
attribute	pointer
++	O
)	O
{	O
if	O
(	O
attribute	pointer
->	O
type	char
>=	O
FIRST_OFFSET_ATTRIBUTE	int
)	O
{	O
int	O
label	pointer
=	O
attribute	pointer
->	O
offset	short
;	O
int	O
x	int
;	O
int	O
y	int
;	O
if	O
(	O
label_coords	array
[	O
label	pointer
]	O
[	O
0	int
]	O
==	O
-	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : error : Pattern attribute uses label '%c' that wasn't specified in the diagram\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
label	pointer
)	O
;	O
fatal_errors	int
++	O
;	O
return	O
;	O
}	O
TRANSFORM2	O
(	O
label_coords	array
[	O
label	pointer
]	O
[	O
0	int
]	O
-	O
ci	int
-	O
movei	int
,	O
label_coords	array
[	O
label	pointer
]	O
[	O
1	int
]	O
-	O
cj	int
-	O
movej	int
,	O
&	O
x	int
,	O
&	O
y	int
,	O
labels_transformation	int
)	O
;	O
attribute	pointer
->	O
offset	short
=	O
OFFSET	O
(	O
x	int
,	O
y	int
)	O
;	O
}	O
}	O
}	O
static	O
void	O
finish_pattern	function
(	O
char	O
*	O
line	int
)	O
{	O
int	O
x	int
;	O
int	O
y	int
;	O
char	O
symmetry	char
;	O
mini	int
=	O
minj	int
=	O
0	int
;	O
if	O
(	O
num_stars	int
>	O
1	int
||	O
(	O
database_type	int
!=	O
DB_CONNECTIONS	O
&&	O
num_stars	int
==	O
0	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : error : No or too many *'s in pattern %s\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
fatal_errors	int
=	O
1	int
;	O
}	O
if	O
(	O
database_type	int
==	O
DB_CORNER	O
)	O
{	O
ci	int
=	O
0	int
;	O
cj	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
choose_best_anchor	int
&&	O
!	O
discard_pattern	int
)	O
{	O
int	O
mi	int
,	O
mj	int
;	O
int	O
d	int
,	O
min_d	int
=	O
36100	int
;	O
int	O
k	int
,	O
min_k	int
=	O
-	O
1	int
;	O
mi	int
=	O
(	O
maxi	int
-	O
1	int
)	O
*	O
50	int
;	O
mj	int
=	O
(	O
maxj	int
-	O
1	int
)	O
*	O
50	int
-	O
1	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
!=	O
el	int
;	O
k	int
++	O
)	O
if	O
(	O
elements	pointer
[	O
k	int
]	O
.	O
att	char
<	O
3	int
&&	O
(	O
elements	pointer
[	O
k	int
]	O
.	O
att	char
&	O
anchor	int
)	O
!=	O
0	int
)	O
{	O
d	int
=	O
gg_abs	O
(	O
100	int
*	O
elements	pointer
[	O
k	int
]	O
.	O
x	int
-	O
mi	int
)	O
+	O
gg_abs	O
(	O
100	int
*	O
elements	pointer
[	O
k	int
]	O
.	O
y	int
-	O
mj	int
)	O
;	O
if	O
(	O
d	int
<	O
min_d	int
)	O
{	O
min_k	int
=	O
k	int
;	O
min_d	int
=	O
d	int
;	O
}	O
}	O
assert	O
(	O
min_k	int
!=	O
-	O
1	int
)	O
;	O
ci	int
=	O
elements	pointer
[	O
min_k	int
]	O
.	O
x	int
;	O
cj	int
=	O
elements	pointer
[	O
min_k	int
]	O
.	O
y	int
;	O
pattern	pointer
[	O
patno	int
]	O
.	O
anchored_at_X	int
=	O
(	O
elements	pointer
[	O
min_k	int
]	O
.	O
att	char
==	O
ATT_X	int
)	O
?	O
3	int
:	O
0	int
;	O
}	O
else	O
if	O
(	O
(	O
ci	int
==	O
-	O
1	int
||	O
cj	int
==	O
-	O
1	int
)	O
&&	O
!	O
discard_pattern	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : No origin for pattern %s\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
fatal_errors	int
=	O
1	int
;	O
ci	int
=	O
0	int
;	O
cj	int
=	O
0	int
;	O
}	O
if	O
(	O
num_stars	int
==	O
1	int
)	O
{	O
movei	int
-=	O
ci	int
;	O
movej	int
-=	O
cj	int
;	O
}	O
else	O
if	O
(	O
num_stars	int
==	O
0	int
)	O
{	O
movei	int
=	O
ci	int
;	O
movej	int
=	O
cj	int
;	O
}	O
TRANSFORM2	O
(	O
movei	int
,	O
movej	int
,	O
&	O
x	int
,	O
&	O
y	int
,	O
transformation_hint	int
)	O
;	O
pattern	pointer
[	O
patno	int
]	O
.	O
move_offset	int
=	O
OFFSET	O
(	O
x	int
,	O
y	int
)	O
;	O
find_extents	function
(	O
)	O
;	O
compute_grids	function
(	O
)	O
;	O
pattern	pointer
[	O
patno	int
]	O
.	O
patlen	int
=	O
el	int
;	O
{	O
int	O
s	int
;	O
char	O
class	int
[	O
80	int
]	O
;	O
char	O
entry	array
[	O
80	int
]	O
;	O
char	O
*	O
p	pointer
=	O
line	int
;	O
char	O
*	O
p2	pointer
;	O
int	O
n	int
;	O
class	int
[	O
0	int
]	O
=	O
0	int
;	O
s	int
=	O
sscanf	function
(	O
p	pointer
,	O
":%c,%[^,]%n"	pointer
,	O
&	O
symmetry	char
,	O
class	int
,	O
&	O
n	int
)	O
;	O
p	pointer
+=	O
n	int
;	O
if	O
(	O
s	int
<	O
2	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
": line must contain symmetry character and class\n"	pointer
)	O
;	O
fatal_errors	int
++	O
;	O
}	O
pattern	pointer
[	O
patno	int
]	O
.	O
attributes	pointer
=	O
NULL	O
;	O
while	O
(	O
sscanf	function
(	O
p	pointer
,	O
"%*[, ]%[^,]%n"	pointer
,	O
entry	array
,	O
&	O
n	int
)	O
>	O
0	int
)	O
{	O
const	O
char	O
*	O
paren	pointer
;	O
p	pointer
+=	O
n	int
;	O
paren	pointer
=	O
strchr	function
(	O
entry	array
,	O
'('	O
)	O
;	O
if	O
(	O
paren	pointer
)	O
{	O
struct	O
attribute_description	struct
*	O
description	pointer
=	O
NULL	O
;	O
if	O
(	O
attribute_map	pointer
)	O
{	O
for	O
(	O
description	pointer
=	O
attribute_map	pointer
;	O
description	pointer
->	O
input_name	pointer
;	O
description	pointer
++	O
)	O
{	O
if	O
(	O
strncmp	function
(	O
entry	array
,	O
description	pointer
->	O
input_name	pointer
,	O
paren	pointer
-	O
entry	array
)	O
==	O
0	int
)	O
{	O
if	O
(	O
description	pointer
->	O
type	char
!=	O
IN_PATTERN_VALUE	O
)	O
{	O
if	O
(	O
!	O
pattern	pointer
[	O
patno	int
]	O
.	O
attributes	pointer
)	O
pattern	pointer
[	O
patno	int
]	O
.	O
attributes	pointer
=	O
attributes	pointer
+	O
num_attributes	int
;	O
attributes	pointer
[	O
num_attributes	int
]	O
.	O
type	char
=	O
description	pointer
->	O
type	char
;	O
if	O
(	O
description	pointer
->	O
type	char
>=	O
FIRST_OFFSET_ATTRIBUTE	int
)	O
{	O
if	O
(	O
*	O
(	O
paren	pointer
+	O
1	int
)	O
!=	O
'*'	O
&&	O
!	O
strchr	function
(	O
VALID_CONSTRAINT_LABELS	array
,	O
*	O
(	O
paren	pointer
+	O
1	int
)	O
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : error : '%c' is not a valid label.\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
*	O
(	O
paren	pointer
+	O
1	int
)	O
)	O
;	O
fatal_errors	int
++	O
;	O
continue	O
;	O
}	O
attributes	pointer
[	O
num_attributes	int
]	O
.	O
offset	short
=	O
*	O
(	O
paren	pointer
+	O
1	int
)	O
;	O
}	O
else	O
sscanf	function
(	O
paren	pointer
+	O
1	int
,	O
"%f"	pointer
,	O
&	O
attributes	pointer
[	O
num_attributes	int
]	O
.	O
value	pointer
)	O
;	O
num_attributes	int
++	O
;	O
}	O
else	O
sscanf	function
(	O
paren	pointer
+	O
1	int
,	O
"%f"	pointer
,	O
&	O
pattern	pointer
[	O
patno	int
]	O
.	O
value	pointer
)	O
;	O
if	O
(	O
!	O
strchr	function
(	O
paren	pointer
+	O
1	int
,	O
')'	O
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : error : ')' missed\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
)	O
;	O
fatal_errors	int
++	O
;	O
}	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
attribute_map	pointer
==	O
NULL	O
||	O
description	pointer
->	O
input_name	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : error : Unknown value field: %s\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
entry	array
)	O
;	O
fatal_errors	int
++	O
;	O
break	O
;	O
}	O
}	O
else	O
{	O
strncpy	function
(	O
helper_fn_names	array
[	O
patno	int
]	O
,	O
entry	array
,	O
79	int
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
pattern	pointer
[	O
patno	int
]	O
.	O
attributes	pointer
!=	O
NULL	O
)	O
{	O
attributes	pointer
[	O
num_attributes	int
]	O
.	O
type	char
=	O
LAST_ATTRIBUTE	int
;	O
attributes	pointer
[	O
num_attributes	int
]	O
.	O
value	pointer
=	O
0.0	int
;	O
num_attributes	int
++	O
;	O
}	O
for	O
(	O
p2	pointer
=	O
class	int
;	O
*	O
p2	pointer
;	O
p2	pointer
++	O
)	O
{	O
switch	O
(	O
*	O
p2	pointer
)	O
{	O
case	O
's'	O
:	O
pattern	pointer
[	O
patno	int
]	O
.	O
class	int
|=	O
CLASS_s	int
;	O
break	O
;	O
case	O
'O'	O
:	O
pattern	pointer
[	O
patno	int
]	O
.	O
class	int
|=	O
CLASS_O	int
;	O
break	O
;	O
case	O
'o'	O
:	O
pattern	pointer
[	O
patno	int
]	O
.	O
class	int
|=	O
CLASS_o	int
;	O
break	O
;	O
case	O
'X'	O
:	O
pattern	pointer
[	O
patno	int
]	O
.	O
class	int
|=	O
CLASS_X	int
;	O
break	O
;	O
case	O
'x'	O
:	O
pattern	pointer
[	O
patno	int
]	O
.	O
class	int
|=	O
CLASS_x	int
;	O
break	O
;	O
case	O
'D'	O
:	O
pattern	pointer
[	O
patno	int
]	O
.	O
class	int
|=	O
CLASS_D	int
;	O
break	O
;	O
case	O
'C'	O
:	O
pattern	pointer
[	O
patno	int
]	O
.	O
class	int
|=	O
CLASS_C	int
;	O
break	O
;	O
case	O
'c'	O
:	O
pattern	pointer
[	O
patno	int
]	O
.	O
class	int
|=	O
CLASS_c	int
;	O
break	O
;	O
case	O
'n'	O
:	O
pattern	pointer
[	O
patno	int
]	O
.	O
class	int
|=	O
CLASS_n	int
;	O
break	O
;	O
case	O
'B'	O
:	O
pattern	pointer
[	O
patno	int
]	O
.	O
class	int
|=	O
CLASS_B	int
;	O
break	O
;	O
case	O
'A'	O
:	O
pattern	pointer
[	O
patno	int
]	O
.	O
class	int
|=	O
CLASS_A	int
;	O
break	O
;	O
case	O
'b'	O
:	O
pattern	pointer
[	O
patno	int
]	O
.	O
class	int
|=	O
CLASS_b	int
;	O
break	O
;	O
case	O
'e'	O
:	O
pattern	pointer
[	O
patno	int
]	O
.	O
class	int
|=	O
CLASS_e	int
;	O
break	O
;	O
case	O
'E'	O
:	O
pattern	pointer
[	O
patno	int
]	O
.	O
class	int
|=	O
CLASS_E	int
;	O
break	O
;	O
case	O
'a'	O
:	O
pattern	pointer
[	O
patno	int
]	O
.	O
class	int
|=	O
CLASS_a	int
;	O
break	O
;	O
case	O
'd'	O
:	O
pattern	pointer
[	O
patno	int
]	O
.	O
class	int
|=	O
CLASS_d	int
;	O
break	O
;	O
case	O
'I'	O
:	O
pattern	pointer
[	O
patno	int
]	O
.	O
class	int
|=	O
CLASS_I	int
;	O
break	O
;	O
case	O
'J'	O
:	O
pattern	pointer
[	O
patno	int
]	O
.	O
class	int
|=	O
CLASS_J	int
;	O
break	O
;	O
case	O
'j'	O
:	O
pattern	pointer
[	O
patno	int
]	O
.	O
class	int
|=	O
CLASS_j	int
;	O
break	O
;	O
case	O
't'	O
:	O
pattern	pointer
[	O
patno	int
]	O
.	O
class	int
|=	O
CLASS_t	int
;	O
break	O
;	O
case	O
'T'	O
:	O
pattern	pointer
[	O
patno	int
]	O
.	O
class	int
|=	O
CLASS_T	int
;	O
break	O
;	O
case	O
'U'	O
:	O
pattern	pointer
[	O
patno	int
]	O
.	O
class	int
|=	O
CLASS_U	int
;	O
break	O
;	O
case	O
'W'	O
:	O
pattern	pointer
[	O
patno	int
]	O
.	O
class	int
|=	O
CLASS_W	int
;	O
break	O
;	O
case	O
'F'	O
:	O
pattern	pointer
[	O
patno	int
]	O
.	O
class	int
|=	O
CLASS_F	int
;	O
break	O
;	O
case	O
'N'	O
:	O
pattern	pointer
[	O
patno	int
]	O
.	O
class	int
|=	O
CLASS_N	int
;	O
break	O
;	O
case	O
'Y'	O
:	O
pattern	pointer
[	O
patno	int
]	O
.	O
class	int
|=	O
CLASS_Y	int
;	O
break	O
;	O
case	O
'-'	O
:	O
break	O
;	O
default	O
:	O
if	O
(	O
!	O
isgraph	function
(	O
(	O
int	O
)	O
*	O
p2	pointer
)	O
)	O
break	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : error : Unknown classification letter %c. (pattern %s).\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
*	O
p2	pointer
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
fatal_errors	int
++	O
;	O
break	O
;	O
}	O
}	O
}	O
switch	O
(	O
symmetry	char
)	O
{	O
case	O
'+'	O
:	O
if	O
(	O
where	int
&	O
(	O
NORTH_EDGE	int
|	O
EAST_EDGE	int
|	O
SOUTH_EDGE	int
|	O
WEST_EDGE	int
)	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : Warning : symmetry inconsistent with edge constraints (pattern %s)\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
pattern	pointer
[	O
patno	int
]	O
.	O
trfno	int
=	O
2	int
;	O
break	O
;	O
case	O
'X'	O
:	O
if	O
(	O
where	int
&	O
(	O
NORTH_EDGE	int
|	O
EAST_EDGE	int
|	O
SOUTH_EDGE	int
|	O
WEST_EDGE	int
)	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : Warning : X symmetry inconsistent with edge constraints (pattern %s)\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
if	O
(	O
maxi	int
!=	O
maxj	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : Warning : X symmetry requires a square pattern (pattern %s)\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
pattern	pointer
[	O
patno	int
]	O
.	O
trfno	int
=	O
2	int
;	O
break	O
;	O
case	O
'-'	O
:	O
if	O
(	O
where	int
&	O
(	O
NORTH_EDGE	int
|	O
SOUTH_EDGE	int
)	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : Warning : symmetry inconsistent with edge constraints (pattern %s)\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
pattern	pointer
[	O
patno	int
]	O
.	O
trfno	int
=	O
4	int
;	O
break	O
;	O
case	O
'|'	O
:	O
if	O
(	O
where	int
&	O
(	O
EAST_EDGE	int
|	O
WEST_EDGE	int
)	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : Warning : symmetry inconsistent with edge constraints (pattern %s)\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
pattern	pointer
[	O
patno	int
]	O
.	O
trfno	int
=	O
4	int
;	O
break	O
;	O
case	O
'\\'	O
:	O
case	O
'/'	O
:	O
if	O
(	O
maxi	int
!=	O
maxj	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : Warning : \\ or / symmetry requires a square pattern (pattern %s)\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
pattern	pointer
[	O
patno	int
]	O
.	O
trfno	int
=	O
4	int
;	O
break	O
;	O
case	O
'O'	O
:	O
if	O
(	O
where	int
&	O
(	O
NORTH_EDGE	int
|	O
EAST_EDGE	int
|	O
SOUTH_EDGE	int
|	O
WEST_EDGE	int
)	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : Warning : symmetry inconsistent with edge constraints (pattern %s)\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
pattern	pointer
[	O
patno	int
]	O
.	O
trfno	int
=	O
5	int
;	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : Warning : symmetry character '%c' not implemented - using '8' (pattern %s)\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
symmetry	char
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
case	O
'8'	O
:	O
pattern	pointer
[	O
patno	int
]	O
.	O
trfno	int
=	O
8	int
;	O
break	O
;	O
}	O
}	O
static	O
void	O
read_constraint_line	function
(	O
char	O
*	O
line	int
)	O
{	O
assert	O
(	O
strlen	function
(	O
constraint	array
)	O
+	O
strlen	function
(	O
line	int
)	O
<	O
MAXCONSTRAINT	int
)	O
;	O
strcat	function
(	O
constraint	array
,	O
line	int
)	O
;	O
pattern	pointer
[	O
patno	int
]	O
.	O
autohelper_flag	int
|=	O
HAVE_CONSTRAINT	int
;	O
}	O
static	O
void	O
read_action_line	function
(	O
char	O
*	O
line	int
)	O
{	O
assert	O
(	O
strlen	function
(	O
action	int
)	O
+	O
strlen	function
(	O
line	int
)	O
<	O
MAXACTION	int
)	O
;	O
strcat	function
(	O
action	int
,	O
line	int
)	O
;	O
pattern	pointer
[	O
patno	int
]	O
.	O
autohelper_flag	int
|=	O
HAVE_ACTION	int
;	O
}	O
static	O
void	O
generate_autohelper_code	function
(	O
int	O
funcno	int
,	O
int	O
number_of_params	int
,	O
int	O
*	O
labels	pointer
)	O
{	O
int	O
i	int
;	O
char	O
varnames	array
[	O
MAXPARAMS	int
]	O
[	O
8	int
]	O
;	O
char	O
pattern_id	array
[	O
MAXLINE	int
]	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
number_of_params	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
labels	pointer
[	O
i	int
]	O
==	O
(	O
int	O
)	O
'*'	O
)	O
sprintf	function
(	O
varnames	array
[	O
i	int
]	O
,	O
"move"	pointer
)	O
;	O
else	O
if	O
(	O
labels	pointer
[	O
i	int
]	O
==	O
(	O
int	O
)	O
'?'	O
)	O
sprintf	function
(	O
varnames	array
[	O
i	int
]	O
,	O
"NO_MOVE"	pointer
)	O
;	O
else	O
sprintf	function
(	O
varnames	array
[	O
i	int
]	O
,	O
"%c"	pointer
,	O
labels	pointer
[	O
i	int
]	O
)	O
;	O
}	O
switch	O
(	O
autohelper_functions	array
[	O
funcno	int
]	O
.	O
type	char
)	O
{	O
case	O
0	int
:	O
switch	O
(	O
number_of_params	int
)	O
{	O
case	O
0	int
:	O
code_pos	pointer
+=	O
sprintf	function
(	O
code_pos	pointer
,	O
autohelper_functions	array
[	O
funcno	int
]	O
.	O
code	int
)	O
;	O
break	O
;	O
case	O
1	int
:	O
code_pos	pointer
+=	O
sprintf	function
(	O
code_pos	pointer
,	O
autohelper_functions	array
[	O
funcno	int
]	O
.	O
code	int
,	O
varnames	array
[	O
0	int
]	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
code_pos	pointer
+=	O
sprintf	function
(	O
code_pos	pointer
,	O
autohelper_functions	array
[	O
funcno	int
]	O
.	O
code	int
,	O
varnames	array
[	O
0	int
]	O
,	O
varnames	array
[	O
1	int
]	O
)	O
;	O
break	O
;	O
case	O
3	int
:	O
code_pos	pointer
+=	O
sprintf	function
(	O
code_pos	pointer
,	O
autohelper_functions	array
[	O
funcno	int
]	O
.	O
code	int
,	O
varnames	array
[	O
0	int
]	O
,	O
varnames	array
[	O
1	int
]	O
,	O
varnames	array
[	O
2	int
]	O
)	O
;	O
break	O
;	O
case	O
4	int
:	O
code_pos	pointer
+=	O
sprintf	function
(	O
code_pos	pointer
,	O
autohelper_functions	array
[	O
funcno	int
]	O
.	O
code	int
,	O
varnames	array
[	O
0	int
]	O
,	O
varnames	array
[	O
1	int
]	O
,	O
varnames	array
[	O
2	int
]	O
,	O
varnames	array
[	O
3	int
]	O
)	O
;	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : error : unknown number of parameters (pattern %s)"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
fatal_errors	int
++	O
;	O
}	O
break	O
;	O
case	O
1	int
:	O
if	O
(	O
number_of_params	int
<	O
autohelper_functions	array
[	O
funcno	int
]	O
.	O
params	array
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : error : too few parameters (pattern %s)"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
fatal_errors	int
++	O
;	O
return	O
;	O
}	O
code_pos	pointer
+=	O
sprintf	function
(	O
code_pos	pointer
,	O
autohelper_functions	array
[	O
funcno	int
]	O
.	O
code	int
,	O
number_of_params	int
-	O
autohelper_functions	array
[	O
funcno	int
]	O
.	O
params	array
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
number_of_params	int
;	O
i	int
++	O
)	O
code_pos	pointer
+=	O
sprintf	function
(	O
code_pos	pointer
,	O
", %s"	pointer
,	O
varnames	array
[	O
i	int
]	O
)	O
;	O
*	O
code_pos	pointer
++	O
=	O
')'	O
;	O
break	O
;	O
default	O
:	O
sprintf	function
(	O
pattern_id	array
,	O
"(%s + %d)"	pointer
,	O
prefix	pointer
,	O
patno	int
)	O
;	O
switch	O
(	O
number_of_params	int
)	O
{	O
case	O
0	int
:	O
code_pos	pointer
+=	O
sprintf	function
(	O
code_pos	pointer
,	O
autohelper_functions	array
[	O
funcno	int
]	O
.	O
code	int
,	O
pattern_id	array
)	O
;	O
break	O
;	O
case	O
1	int
:	O
code_pos	pointer
+=	O
sprintf	function
(	O
code_pos	pointer
,	O
autohelper_functions	array
[	O
funcno	int
]	O
.	O
code	int
,	O
pattern_id	array
,	O
varnames	array
[	O
0	int
]	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
code_pos	pointer
+=	O
sprintf	function
(	O
code_pos	pointer
,	O
autohelper_functions	array
[	O
funcno	int
]	O
.	O
code	int
,	O
pattern_id	array
,	O
varnames	array
[	O
0	int
]	O
,	O
varnames	array
[	O
1	int
]	O
)	O
;	O
break	O
;	O
case	O
3	int
:	O
code_pos	pointer
+=	O
sprintf	function
(	O
code_pos	pointer
,	O
autohelper_functions	array
[	O
funcno	int
]	O
.	O
code	int
,	O
pattern_id	array
,	O
varnames	array
[	O
0	int
]	O
,	O
varnames	array
[	O
1	int
]	O
,	O
varnames	array
[	O
2	int
]	O
)	O
;	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : error : unknown number of parameters (pattern %s)"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
fatal_errors	int
++	O
;	O
}	O
}	O
}	O
static	O
void	O
parse_constraint_or_action	function
(	O
char	O
*	O
line	int
,	O
float	O
*	O
cost	float
)	O
{	O
int	O
state	pointer
=	O
0	int
;	O
char	O
*	O
p	pointer
;	O
int	O
n	int
=	O
0	int
;	O
int	O
label	pointer
=	O
0	int
;	O
int	O
labels	pointer
[	O
MAXLABELS	int
]	O
;	O
int	O
N	int
=	O
sizeof	O
(	O
autohelper_functions	array
)	O
/	O
sizeof	O
(	O
struct	O
autohelper_func	struct
)	O
;	O
int	O
number_of_params	int
=	O
0	int
;	O
float	O
cost_factor	float
=	O
1.0	int
;	O
*	O
cost	float
=	O
0.0	int
;	O
for	O
(	O
p	pointer
=	O
line	int
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
{	O
switch	O
(	O
state	pointer
)	O
{	O
case	O
0	int
:	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
N	int
;	O
n	int
++	O
)	O
{	O
if	O
(	O
strncmp	function
(	O
p	pointer
,	O
autohelper_functions	array
[	O
n	int
]	O
.	O
name	short
,	O
strlen	function
(	O
autohelper_functions	array
[	O
n	int
]	O
.	O
name	short
)	O
)	O
==	O
0	int
)	O
{	O
state	pointer
=	O
1	int
;	O
p	pointer
+=	O
strlen	function
(	O
autohelper_functions	array
[	O
n	int
]	O
.	O
name	short
)	O
-	O
1	int
;	O
*	O
cost	float
+=	O
autohelper_functions	array
[	O
n	int
]	O
.	O
cost	float
*	O
cost_factor	float
;	O
cost_factor	float
*=	O
0.6	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
state	pointer
==	O
0	int
&&	O
*	O
p	pointer
!=	O
'\n'	O
)	O
*	O
(	O
code_pos	pointer
++	O
)	O
=	O
*	O
p	pointer
;	O
break	O
;	O
case	O
1	int
:	O
if	O
(	O
*	O
p	pointer
!=	O
'('	O
)	O
{	O
if	O
(	O
autohelper_functions	array
[	O
n	int
]	O
.	O
params	array
==	O
0	int
)	O
{	O
generate_autohelper_code	function
(	O
n	int
,	O
0	int
,	O
NULL	O
)	O
;	O
p	pointer
--	O
;	O
state	pointer
=	O
0	int
;	O
break	O
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : error : Syntax error in constraint or action, '(' expected (pattern %s, autohelper %s).\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
pattern_names	array
[	O
patno	int
]	O
,	O
autohelper_functions	array
[	O
n	int
]	O
.	O
name	short
)	O
;	O
fatal_errors	int
++	O
;	O
return	O
;	O
}	O
else	O
{	O
assert	O
(	O
autohelper_functions	array
[	O
n	int
]	O
.	O
params	array
<=	O
MAXPARAMS	int
)	O
;	O
number_of_params	int
=	O
0	int
;	O
if	O
(	O
autohelper_functions	array
[	O
n	int
]	O
.	O
params	array
!=	O
0	int
||	O
autohelper_functions	array
[	O
n	int
]	O
.	O
type	char
==	O
1	int
)	O
state	pointer
=	O
2	int
;	O
else	O
state	pointer
=	O
3	int
;	O
}	O
break	O
;	O
case	O
2	int
:	O
if	O
(	O
(	O
*	O
p	pointer
!=	O
'*'	O
)	O
&&	O
(	O
*	O
p	pointer
!=	O
'?'	O
)	O
&&	O
!	O
strchr	function
(	O
VALID_CONSTRAINT_LABELS	array
,	O
*	O
p	pointer
)	O
)	O
{	O
if	O
(	O
strchr	function
(	O
"XxOo"	pointer
,	O
*	O
p	pointer
)	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : error : '%c' is not allowed as a constraint label.\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
*	O
p	pointer
)	O
;	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : error : Syntax error in constraint or action, label expected, found '%c'.\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
*	O
p	pointer
)	O
;	O
fatal_errors	int
++	O
;	O
return	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
*	O
p	pointer
==	O
'?'	O
)	O
&&	O
(	O
number_of_params	int
==	O
0	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"mkpat: tenuki (?) cannot be the first label (pattern %s)\n"	pointer
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
return	O
;	O
}	O
label	pointer
=	O
(	O
int	O
)	O
*	O
p	pointer
;	O
if	O
(	O
*	O
p	pointer
!=	O
'*'	O
&&	O
*	O
p	pointer
!=	O
'?'	O
&&	O
label_coords	array
[	O
label	pointer
]	O
[	O
0	int
]	O
==	O
-	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : error : The constraint or action uses a label (%c) that wasn't specified in the diagram (pattern %s).\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
label	pointer
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
fatal_errors	int
++	O
;	O
return	O
;	O
}	O
labels	pointer
[	O
number_of_params	int
]	O
=	O
label	pointer
;	O
number_of_params	int
++	O
;	O
state	pointer
=	O
3	int
;	O
}	O
break	O
;	O
case	O
3	int
:	O
if	O
(	O
*	O
p	pointer
==	O
','	O
)	O
{	O
if	O
(	O
autohelper_functions	array
[	O
n	int
]	O
.	O
type	char
!=	O
1	int
&&	O
number_of_params	int
==	O
autohelper_functions	array
[	O
n	int
]	O
.	O
params	array
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : error : Syntax error in constraint or action, ')' expected (pattern %s).\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
number_of_params	int
==	O
MAXPARAMS	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Error in constraint or action, too many parameters. (pattern %s).\n"	pointer
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
return	O
;	O
}	O
state	pointer
=	O
2	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
*	O
p	pointer
!=	O
')'	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : error : Syntax error in constraint or action, ',' or ')' expected (pattern %s).\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
return	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
autohelper_functions	array
[	O
n	int
]	O
.	O
type	char
!=	O
1	int
)	O
&&	O
(	O
number_of_params	int
<	O
autohelper_functions	array
[	O
n	int
]	O
.	O
params	array
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : error : Syntax error in constraint or action, %s() requires %d parameters.\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
autohelper_functions	array
[	O
n	int
]	O
.	O
name	short
,	O
autohelper_functions	array
[	O
n	int
]	O
.	O
params	array
)	O
;	O
fatal_errors	int
++	O
;	O
return	O
;	O
}	O
generate_autohelper_code	function
(	O
n	int
,	O
number_of_params	int
,	O
labels	pointer
)	O
;	O
state	pointer
=	O
0	int
;	O
}	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : error : Internal error in parse_constraint_or_action(), unknown state.\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
)	O
;	O
fatal_errors	int
++	O
;	O
return	O
;	O
}	O
}	O
}	O
static	O
void	O
finish_constraint_and_action	function
(	O
void	O
)	O
{	O
unsigned	O
int	O
i	int
;	O
float	O
cost	float
;	O
int	O
have_constraint	int
=	O
(	O
pattern	pointer
[	O
patno	int
]	O
.	O
autohelper_flag	int
&	O
HAVE_CONSTRAINT	int
)	O
;	O
int	O
have_action	int
=	O
(	O
pattern	pointer
[	O
patno	int
]	O
.	O
autohelper_flag	int
&	O
HAVE_ACTION	int
)	O
;	O
int	O
no_labels	int
=	O
1	int
;	O
pattern	pointer
[	O
patno	int
]	O
.	O
autohelper	pointer
=	O
dummyhelper	function
;	O
code_pos	pointer
+=	O
sprintf	function
(	O
code_pos	pointer
,	O
"static int\nautohelper%s%d(int trans, int move, int color, int action)\n{\n  int"	pointer
,	O
prefix	pointer
,	O
patno	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
VALID_CONSTRAINT_LABELS	array
)	O
;	O
i	int
++	O
)	O
{	O
int	O
c	char
=	O
(	O
int	O
)	O
VALID_CONSTRAINT_LABELS	array
[	O
i	int
]	O
;	O
if	O
(	O
label_coords	array
[	O
c	char
]	O
[	O
0	int
]	O
!=	O
-	O
1	int
)	O
code_pos	pointer
+=	O
sprintf	function
(	O
code_pos	pointer
,	O
" %c,"	pointer
,	O
c	char
)	O
;	O
}	O
if	O
(	O
*	O
(	O
code_pos	pointer
-	O
1	int
)	O
==	O
','	O
)	O
*	O
(	O
code_pos	pointer
-	O
1	int
)	O
=	O
';'	O
;	O
else	O
{	O
code_pos	pointer
-=	O
3	int
;	O
code_pos	pointer
+=	O
sprintf	function
(	O
code_pos	pointer
,	O
"UNUSED(trans);"	pointer
)	O
;	O
}	O
code_pos	pointer
+=	O
sprintf	function
(	O
code_pos	pointer
,	O
"\n  UNUSED(color);\n"	pointer
)	O
;	O
if	O
(	O
!	O
have_constraint	int
||	O
!	O
have_action	int
)	O
code_pos	pointer
+=	O
sprintf	function
(	O
code_pos	pointer
,	O
"  UNUSED(action);\n"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
VALID_CONSTRAINT_LABELS	array
)	O
;	O
i	int
++	O
)	O
{	O
int	O
c	char
=	O
(	O
int	O
)	O
VALID_CONSTRAINT_LABELS	array
[	O
i	int
]	O
;	O
if	O
(	O
label_coords	array
[	O
c	char
]	O
[	O
0	int
]	O
!=	O
-	O
1	int
)	O
{	O
int	O
x	int
;	O
int	O
y	int
;	O
TRANSFORM2	O
(	O
label_coords	array
[	O
c	char
]	O
[	O
0	int
]	O
-	O
ci	int
-	O
movei	int
,	O
label_coords	array
[	O
c	char
]	O
[	O
1	int
]	O
-	O
cj	int
-	O
movej	int
,	O
&	O
x	int
,	O
&	O
y	int
,	O
labels_transformation	int
)	O
;	O
code_pos	pointer
+=	O
sprintf	function
(	O
code_pos	pointer
,	O
"\n  %c = AFFINE_TRANSFORM(%d, trans, move);"	pointer
,	O
c	char
,	O
OFFSET	O
(	O
x	int
,	O
y	int
)	O
)	O
;	O
no_labels	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
no_labels	int
)	O
code_pos	pointer
+=	O
sprintf	function
(	O
code_pos	pointer
,	O
"\n  UNUSED(move);"	pointer
)	O
;	O
code_pos	pointer
+=	O
sprintf	function
(	O
code_pos	pointer
,	O
"\n\n"	pointer
)	O
;	O
if	O
(	O
have_constraint	int
&&	O
have_action	int
)	O
code_pos	pointer
+=	O
sprintf	function
(	O
code_pos	pointer
,	O
"  if (!action)\n  "	pointer
)	O
;	O
if	O
(	O
have_constraint	int
)	O
{	O
code_pos	pointer
+=	O
sprintf	function
(	O
code_pos	pointer
,	O
"  return "	pointer
)	O
;	O
parse_constraint_or_action	function
(	O
constraint	array
,	O
&	O
cost	float
)	O
;	O
pattern	pointer
[	O
patno	int
]	O
.	O
constraint_cost	float
=	O
cost	float
;	O
code_pos	pointer
+=	O
sprintf	function
(	O
code_pos	pointer
,	O
";\n"	pointer
)	O
;	O
}	O
if	O
(	O
have_action	int
)	O
{	O
code_pos	pointer
+=	O
sprintf	function
(	O
code_pos	pointer
,	O
"  "	pointer
)	O
;	O
parse_constraint_or_action	function
(	O
action	int
,	O
&	O
cost	float
)	O
;	O
code_pos	pointer
+=	O
sprintf	function
(	O
code_pos	pointer
,	O
";\n"	pointer
)	O
;	O
code_pos	pointer
+=	O
sprintf	function
(	O
code_pos	pointer
,	O
"\n  return 0;\n"	pointer
)	O
;	O
}	O
code_pos	pointer
+=	O
sprintf	function
(	O
code_pos	pointer
,	O
"}\n\n"	pointer
)	O
;	O
assert	O
(	O
code_pos	pointer
<=	O
autohelper_code	array
+	O
sizeof	O
(	O
autohelper_code	array
)	O
)	O
;	O
}	O
static	O
int	O
compare_elements	function
(	O
const	O
void	O
*	O
a	char
,	O
const	O
void	O
*	O
b	char
)	O
{	O
static	O
int	O
order	array
[	O
]	O
=	O
{	O
7	int
,	O
2	int
,	O
3	int
,	O
5	int
,	O
6	int
,	O
0	int
,	O
4	int
,	O
1	int
}	O
;	O
return	O
order	array
[	O
(	O
(	O
const	O
struct	O
patval_b	struct
*	O
)	O
a	char
)	O
->	O
att	char
]	O
-	O
order	array
[	O
(	O
(	O
const	O
struct	O
patval_b	struct
*	O
)	O
b	char
)	O
->	O
att	char
]	O
;	O
}	O
struct	O
element_node	struct
{	O
struct	O
patval_b	struct
e	pointer
;	O
struct	O
element_node	struct
*	O
next	pointer
;	O
}	O
;	O
static	O
void	O
write_elements	function
(	O
FILE	struct
*	O
outfile	pointer
)	O
{	O
int	O
node	pointer
;	O
int	O
used_nodes	int
=	O
0	int
;	O
assert	O
(	O
ci	int
!=	O
-	O
1	int
&&	O
cj	int
!=	O
-	O
1	int
)	O
;	O
assert	O
(	O
database_type	int
==	O
DB_DFA	O
||	O
transformation_hint	int
==	O
0	int
)	O
;	O
gg_sort	function
(	O
elements	pointer
,	O
el	int
,	O
sizeof	O
(	O
struct	O
patval_b	struct
)	O
,	O
compare_elements	function
)	O
;	O
fprintf	function
(	O
outfile	pointer
,	O
"static struct patval %s%d[] = {"	pointer
,	O
prefix	pointer
,	O
patno	int
)	O
;	O
for	O
(	O
node	pointer
=	O
0	int
;	O
node	pointer
<	O
el	int
;	O
node	pointer
++	O
)	O
{	O
int	O
x	int
=	O
elements	pointer
[	O
node	pointer
]	O
.	O
x	int
;	O
int	O
y	int
=	O
elements	pointer
[	O
node	pointer
]	O
.	O
y	int
;	O
int	O
att	char
=	O
elements	pointer
[	O
node	pointer
]	O
.	O
att	char
;	O
int	O
dx	int
;	O
int	O
dy	int
;	O
assert	O
(	O
x	int
>=	O
mini	int
&&	O
y	int
>=	O
minj	int
)	O
;	O
if	O
(	O
!	O
(	O
x	int
<=	O
maxi	int
&&	O
y	int
<=	O
maxj	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : error : Maximum number of elements exceeded in %s.\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
prefix	pointer
)	O
;	O
fatal_errors	int
++	O
;	O
}	O
if	O
(	O
(	O
fixed_anchor	int
||	O
nongoal	array
[	O
att	char
]	O
)	O
&&	O
callback_unneeded	array
[	O
att	char
]	O
&&	O
(	O
(	O
(	O
pattern	pointer
[	O
patno	int
]	O
.	O
class	int
&	O
(	O
CLASS_X	int
|	O
CLASS_x	int
)	O
)	O
==	O
0	int
)	O
||	O
(	O
att	char
!=	O
ATT_X	int
&&	O
att	char
!=	O
ATT_x	int
)	O
)	O
&&	O
(	O
(	O
(	O
pattern	pointer
[	O
patno	int
]	O
.	O
class	int
&	O
(	O
CLASS_O	int
|	O
CLASS_o	int
)	O
)	O
==	O
0	int
)	O
||	O
(	O
att	char
!=	O
ATT_O	int
&&	O
att	char
!=	O
ATT_o	int
)	O
)	O
)	O
{	O
if	O
(	O
(	O
database_type	int
==	O
DB_GENERAL	O
||	O
database_type	int
==	O
DB_CONNECTIONS	O
)	O
&&	O
ci	int
-	O
1	int
<=	O
x	int
&&	O
x	int
<=	O
ci	int
+	O
1	int
&&	O
cj	int
-	O
1	int
<=	O
y	int
&&	O
y	int
<=	O
cj	int
+	O
1	int
)	O
continue	O
;	O
if	O
(	O
database_type	int
==	O
DB_DFA	O
)	O
continue	O
;	O
}	O
if	O
(	O
used_nodes	int
)	O
fprintf	function
(	O
outfile	pointer
,	O
","	pointer
)	O
;	O
fprintf	function
(	O
outfile	pointer
,	O
used_nodes	int
%	O
4	int
?	O
"\t"	pointer
:	O
"\n  "	pointer
)	O
;	O
used_nodes	int
++	O
;	O
TRANSFORM2	O
(	O
x	int
-	O
ci	int
,	O
y	int
-	O
cj	int
,	O
&	O
dx	int
,	O
&	O
dy	int
,	O
transformation_hint	int
)	O
;	O
fprintf	function
(	O
outfile	pointer
,	O
"{%d,%d}"	pointer
,	O
OFFSET	O
(	O
dx	int
,	O
dy	int
)	O
,	O
att	char
)	O
;	O
}	O
if	O
(	O
!	O
used_nodes	int
)	O
fprintf	function
(	O
outfile	pointer
,	O
"{0,-1}}; /* Dummy element, not used. */\n\n"	pointer
)	O
;	O
else	O
fprintf	function
(	O
outfile	pointer
,	O
"\n};\n\n"	pointer
)	O
;	O
pattern	pointer
[	O
patno	int
]	O
.	O
patlen	int
=	O
used_nodes	int
;	O
}	O
static	O
struct	O
corner_variation_b	struct
corner_root	struct
;	O
static	O
int	O
second_corner_offset	int
[	O
MAXPATNO	int
]	O
;	O
static	O
int	O
total_variations	int
=	O
0	int
;	O
static	O
int	O
variations_written	int
=	O
0	int
;	O
static	O
int	O
corner_max_width	int
=	O
0	int
;	O
static	O
int	O
corner_max_height	int
=	O
0	int
;	O
struct	O
corner_element	struct
{	O
int	O
x	int
;	O
int	O
y	int
;	O
int	O
color	int
;	O
}	O
;	O
static	O
void	O
corner_init	function
(	O
void	O
)	O
{	O
corner_root	struct
.	O
num_variations	char
=	O
0	int
;	O
corner_root	struct
.	O
child	pointer
=	O
NULL	O
;	O
}	O
static	O
int	O
corner_best_element	function
(	O
struct	O
corner_element	struct
*	O
el	int
,	O
int	O
n	int
,	O
struct	O
corner_variation_b	struct
*	O
variations	pointer
,	O
int	O
color	int
)	O
{	O
int	O
k	int
;	O
int	O
i	int
;	O
int	O
best	int
=	O
0	int
;	O
int	O
best_value	int
=	O
0	int
;	O
int	O
candidate	array
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
candidates	int
=	O
0	int
;	O
int	O
existing_variation	array
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
have_existing_variation	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
n	int
;	O
k	int
++	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
==	O
k	int
)	O
continue	O
;	O
if	O
(	O
el	int
[	O
k	int
]	O
.	O
x	int
>=	O
el	int
[	O
i	int
]	O
.	O
x	int
&&	O
el	int
[	O
k	int
]	O
.	O
y	int
>=	O
el	int
[	O
i	int
]	O
.	O
y	int
)	O
break	O
;	O
}	O
if	O
(	O
i	int
==	O
n	int
)	O
{	O
struct	O
corner_variation_b	struct
*	O
v	pointer
;	O
int	O
move_offset	int
=	O
OFFSET	O
(	O
el	int
[	O
k	int
]	O
.	O
x	int
,	O
el	int
[	O
k	int
]	O
.	O
y	int
)	O
;	O
int	O
xor_att	char
=	O
(	O
el	int
[	O
k	int
]	O
.	O
color	int
==	O
color	int
?	O
ATT_O	int
^	O
ATT_O	int
:	O
ATT_O	int
^	O
ATT_X	int
)	O
;	O
candidate	array
[	O
candidates	int
]	O
=	O
k	int
;	O
existing_variation	array
[	O
candidates	int
]	O
=	O
0	int
;	O
for	O
(	O
v	pointer
=	O
variations	pointer
;	O
v	pointer
!=	O
NULL	O
;	O
v	pointer
=	O
v	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
v	pointer
->	O
move_offset	int
==	O
move_offset	int
&&	O
(	O
v	pointer
->	O
xor_att	char
==	O
xor_att	char
||	O
color	int
==	O
0	int
)	O
)	O
{	O
existing_variation	array
[	O
candidates	int
]	O
=	O
1	int
;	O
have_existing_variation	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
candidates	int
++	O
;	O
}	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
candidates	int
;	O
k	int
++	O
)	O
{	O
int	O
m	int
=	O
candidate	array
[	O
k	int
]	O
;	O
int	O
value	pointer
=	O
2	int
*	O
MAX_BOARD	int
*	O
(	O
el	int
[	O
m	int
]	O
.	O
x	int
+	O
1	int
)	O
*	O
(	O
el	int
[	O
m	int
]	O
.	O
y	int
+	O
1	int
)	O
-	O
2	int
*	O
gg_abs	O
(	O
el	int
[	O
m	int
]	O
.	O
x	int
-	O
el	int
[	O
m	int
]	O
.	O
y	int
)	O
+	O
(	O
el	int
[	O
m	int
]	O
.	O
x	int
<	O
el	int
[	O
m	int
]	O
.	O
y	int
?	O
1	int
:	O
0	int
)	O
;	O
if	O
(	O
existing_variation	array
[	O
k	int
]	O
==	O
have_existing_variation	int
&&	O
value	pointer
>	O
best_value	int
)	O
{	O
best	int
=	O
k	int
;	O
best_value	int
=	O
value	pointer
;	O
}	O
}	O
return	O
candidate	array
[	O
best	int
]	O
;	O
}	O
static	O
struct	O
corner_variation_b	struct
*	O
corner_variation_new	function
(	O
int	O
move_offset	int
,	O
signed	O
char	O
xor_att	char
,	O
unsigned	O
char	O
num_stones	int
)	O
{	O
struct	O
corner_variation_b	struct
*	O
variation	array
;	O
variation	array
=	O
malloc	function
(	O
sizeof	O
(	O
*	O
variation	array
)	O
)	O
;	O
variation	array
->	O
move_offset	int
=	O
move_offset	int
;	O
variation	array
->	O
xor_att	char
=	O
xor_att	char
;	O
variation	array
->	O
num_stones	int
=	O
num_stones	int
;	O
variation	array
->	O
num_variations	char
=	O
0	int
;	O
variation	array
->	O
next	pointer
=	O
NULL	O
;	O
variation	array
->	O
child	pointer
=	O
NULL	O
;	O
variation	array
->	O
child_num	int
=	O
-	O
1	int
;	O
variation	array
->	O
pattern_num	int
=	O
-	O
1	int
;	O
total_variations	int
++	O
;	O
return	O
variation	array
;	O
}	O
static	O
struct	O
corner_variation_b	struct
*	O
corner_follow_variation	function
(	O
struct	O
corner_variation_b	struct
*	O
variation	array
,	O
int	O
offset	short
,	O
int	O
color	int
,	O
unsigned	O
char	O
num_stones	int
)	O
{	O
signed	O
char	O
xor_att	char
=	O
color	int
?	O
ATT_O	int
^	O
ATT_O	int
:	O
ATT_O	int
^	O
ATT_X	int
;	O
struct	O
corner_variation_b	struct
*	O
subvariation	pointer
=	O
variation	array
->	O
child	pointer
;	O
struct	O
corner_variation_b	struct
*	O
*	O
link	pointer
=	O
&	O
(	O
variation	array
->	O
child	pointer
)	O
;	O
while	O
(	O
subvariation	pointer
)	O
{	O
if	O
(	O
subvariation	pointer
->	O
move_offset	int
==	O
offset	short
&&	O
subvariation	pointer
->	O
xor_att	char
==	O
xor_att	char
)	O
{	O
assert	O
(	O
subvariation	pointer
->	O
num_stones	int
==	O
num_stones	int
)	O
;	O
return	O
subvariation	pointer
;	O
}	O
link	pointer
=	O
&	O
(	O
subvariation	pointer
->	O
next	pointer
)	O
;	O
subvariation	pointer
=	O
subvariation	pointer
->	O
next	pointer
;	O
}	O
variation	array
->	O
num_variations	char
++	O
;	O
*	O
link	pointer
=	O
corner_variation_new	function
(	O
offset	short
,	O
xor_att	char
,	O
num_stones	int
)	O
;	O
return	O
*	O
link	pointer
;	O
}	O
static	O
void	O
corner_add_pattern	function
(	O
void	O
)	O
{	O
int	O
k	int
;	O
struct	O
corner_element	struct
stone	array
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
stones	pointer
=	O
0	int
;	O
int	O
trans	int
;	O
int	O
corner_x	int
=	O
0	int
;	O
int	O
corner_y	int
=	O
0	int
;	O
int	O
color	int
=	O
0	int
;	O
int	O
move_pos	int
;	O
int	O
move_x	int
;	O
int	O
move_y	int
;	O
unsigned	O
char	O
num_stones	int
;	O
struct	O
corner_variation_b	struct
*	O
variation	array
=	O
&	O
corner_root	struct
;	O
switch	O
(	O
where	int
)	O
{	O
case	O
SOUTH_EDGE	int
|	O
WEST_EDGE	int
:	O
trans	int
=	O
5	int
;	O
corner_x	int
=	O
maxi	int
;	O
break	O
;	O
case	O
WEST_EDGE	int
|	O
NORTH_EDGE	int
:	O
trans	int
=	O
0	int
;	O
break	O
;	O
case	O
NORTH_EDGE	int
|	O
EAST_EDGE	int
:	O
trans	int
=	O
7	int
;	O
corner_y	int
=	O
maxj	int
;	O
break	O
;	O
case	O
EAST_EDGE	int
|	O
SOUTH_EDGE	int
:	O
trans	int
=	O
2	int
;	O
corner_x	int
=	O
maxi	int
;	O
corner_y	int
=	O
maxj	int
;	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : error : Illegal edge constraint in pattern %s\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
return	O
;	O
}	O
move_pos	int
=	O
AFFINE_TRANSFORM	O
(	O
pattern	pointer
[	O
patno	int
]	O
.	O
move_offset	int
-	O
OFFSET_DELTA	O
(	O
corner_x	int
,	O
corner_y	int
)	O
,	O
trans	int
,	O
POS	O
(	O
0	int
,	O
0	int
)	O
)	O
;	O
move_x	int
=	O
I	O
(	O
move_pos	int
)	O
;	O
move_y	int
=	O
J	O
(	O
move_pos	int
)	O
;	O
labels_transformation	int
=	O
trans	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
el	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
elements	pointer
[	O
k	int
]	O
.	O
att	char
==	O
ATT_X	int
||	O
elements	pointer
[	O
k	int
]	O
.	O
att	char
==	O
ATT_O	int
)	O
{	O
TRANSFORM2	O
(	O
elements	pointer
[	O
k	int
]	O
.	O
x	int
,	O
elements	pointer
[	O
k	int
]	O
.	O
y	int
,	O
&	O
stone	array
[	O
stones	pointer
]	O
.	O
x	int
,	O
&	O
stone	array
[	O
stones	pointer
]	O
.	O
y	int
,	O
trans	int
)	O
;	O
stone	array
[	O
stones	pointer
]	O
.	O
x	int
+=	O
corner_x	int
;	O
stone	array
[	O
stones	pointer
]	O
.	O
y	int
+=	O
corner_y	int
;	O
stone	array
[	O
stones	pointer
]	O
.	O
color	int
=	O
elements	pointer
[	O
k	int
]	O
.	O
att	char
;	O
stones	pointer
++	O
;	O
}	O
else	O
if	O
(	O
elements	pointer
[	O
k	int
]	O
.	O
att	char
!=	O
ATT_dot	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : error : Illegal element in pattern %s\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
return	O
;	O
}	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
stones	pointer
;	O
k	int
++	O
)	O
{	O
int	O
i	int
;	O
int	O
best	int
;	O
struct	O
corner_element	struct
stone_t	struct
;	O
if	O
(	O
k	int
>	O
0	int
)	O
{	O
best	int
=	O
k	int
+	O
corner_best_element	function
(	O
stone	array
+	O
k	int
,	O
stones	pointer
-	O
k	int
,	O
variation	array
->	O
child	pointer
,	O
color	int
)	O
;	O
stone_t	struct
=	O
stone	array
[	O
k	int
]	O
;	O
stone	array
[	O
k	int
]	O
=	O
stone	array
[	O
best	int
]	O
;	O
stone	array
[	O
best	int
]	O
=	O
stone_t	struct
;	O
}	O
else	O
{	O
best	int
=	O
corner_best_element	function
(	O
stone	array
,	O
stones	pointer
,	O
variation	array
->	O
child	pointer
,	O
color	int
)	O
;	O
stone_t	struct
=	O
stone	array
[	O
0	int
]	O
;	O
stone	array
[	O
0	int
]	O
=	O
stone	array
[	O
best	int
]	O
;	O
stone	array
[	O
best	int
]	O
=	O
stone_t	struct
;	O
color	int
=	O
stone	array
[	O
0	int
]	O
.	O
color	int
;	O
if	O
(	O
stone	array
[	O
0	int
]	O
.	O
x	int
>	O
stone	array
[	O
0	int
]	O
.	O
y	int
)	O
{	O
int	O
t	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
k	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
stone	array
[	O
i	int
]	O
.	O
x	int
==	O
stone	array
[	O
0	int
]	O
.	O
y	int
&&	O
stone	array
[	O
i	int
]	O
.	O
y	int
==	O
stone	array
[	O
0	int
]	O
.	O
x	int
)	O
break	O
;	O
}	O
if	O
(	O
i	int
==	O
k	int
)	O
{	O
t	int
=	O
maxi	int
;	O
maxi	int
=	O
maxj	int
;	O
maxj	int
=	O
t	int
;	O
t	int
=	O
move_x	int
;	O
move_x	int
=	O
move_y	int
;	O
move_y	int
=	O
t	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
stones	pointer
;	O
i	int
++	O
)	O
{	O
t	int
=	O
stone	array
[	O
i	int
]	O
.	O
x	int
;	O
stone	array
[	O
i	int
]	O
.	O
x	int
=	O
stone	array
[	O
i	int
]	O
.	O
y	int
;	O
stone	array
[	O
i	int
]	O
.	O
y	int
=	O
t	int
;	O
}	O
}	O
}	O
}	O
num_stones	int
=	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
k	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
stone	array
[	O
i	int
]	O
.	O
x	int
<=	O
stone	array
[	O
k	int
]	O
.	O
x	int
&&	O
stone	array
[	O
i	int
]	O
.	O
y	int
<=	O
stone	array
[	O
k	int
]	O
.	O
y	int
)	O
num_stones	int
++	O
;	O
}	O
variation	array
=	O
corner_follow_variation	function
(	O
variation	array
,	O
OFFSET	O
(	O
stone	array
[	O
k	int
]	O
.	O
x	int
,	O
stone	array
[	O
k	int
]	O
.	O
y	int
)	O
,	O
stone	array
[	O
k	int
]	O
.	O
color	int
==	O
color	int
,	O
num_stones	int
)	O
;	O
}	O
num_stones	int
=	O
1	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
stones	pointer
;	O
k	int
++	O
)	O
{	O
if	O
(	O
stone	array
[	O
k	int
]	O
.	O
x	int
<=	O
move_x	int
&&	O
stone	array
[	O
k	int
]	O
.	O
y	int
<=	O
move_y	int
)	O
num_stones	int
++	O
;	O
}	O
variation	array
=	O
corner_follow_variation	function
(	O
variation	array
,	O
OFFSET	O
(	O
move_x	int
,	O
move_y	int
)	O
,	O
ATT_O	int
==	O
color	int
,	O
num_stones	int
)	O
;	O
if	O
(	O
variation	array
->	O
pattern_num	int
==	O
-	O
1	int
)	O
{	O
variation	array
->	O
pattern_num	int
=	O
patno	int
;	O
second_corner_offset	int
[	O
patno	int
]	O
=	O
OFFSET	O
(	O
maxi	int
,	O
maxj	int
)	O
;	O
if	O
(	O
maxi	int
>	O
corner_max_height	int
)	O
corner_max_height	int
=	O
maxi	int
;	O
if	O
(	O
maxj	int
>	O
corner_max_width	int
)	O
corner_max_width	int
=	O
maxj	int
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : warning : duplicated patterns encountered (%s and %s)\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
pattern_names	array
[	O
variation	array
->	O
pattern_num	int
]	O
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
discard_pattern	int
=	O
1	int
;	O
}	O
}	O
static	O
int	O
corner_pack_variations	function
(	O
struct	O
corner_variation_b	struct
*	O
variation	array
,	O
int	O
counter	int
)	O
{	O
counter	int
++	O
;	O
if	O
(	O
variation	array
->	O
next	pointer
)	O
counter	int
=	O
corner_pack_variations	function
(	O
variation	array
->	O
next	pointer
,	O
counter	int
)	O
;	O
if	O
(	O
variation	array
->	O
child	pointer
)	O
{	O
variation	array
->	O
child_num	int
=	O
counter	int
;	O
counter	int
=	O
corner_pack_variations	function
(	O
variation	array
->	O
child	pointer
,	O
counter	int
)	O
;	O
}	O
return	O
counter	int
;	O
}	O
static	O
void	O
corner_write_variations	function
(	O
struct	O
corner_variation_b	struct
*	O
variation	array
,	O
FILE	struct
*	O
outfile	pointer
)	O
{	O
fprintf	function
(	O
outfile	pointer
,	O
"  {%d,%d,%d,%d,"	pointer
,	O
variation	array
->	O
move_offset	int
,	O
variation	array
->	O
xor_att	char
,	O
variation	array
->	O
num_stones	int
,	O
variation	array
->	O
num_variations	char
)	O
;	O
if	O
(	O
variation	array
->	O
child	pointer
)	O
fprintf	function
(	O
outfile	pointer
,	O
"&%s_variations[%d],"	pointer
,	O
prefix	pointer
,	O
variation	array
->	O
child_num	int
)	O
;	O
else	O
fprintf	function
(	O
outfile	pointer
,	O
"NULL,"	pointer
)	O
;	O
if	O
(	O
variation	array
->	O
pattern_num	int
!=	O
-	O
1	int
)	O
fprintf	function
(	O
outfile	pointer
,	O
"&%s[%d]"	pointer
,	O
prefix	pointer
,	O
variation	array
->	O
pattern_num	int
)	O
;	O
else	O
fprintf	function
(	O
outfile	pointer
,	O
"NULL"	pointer
)	O
;	O
variations_written	int
++	O
;	O
if	O
(	O
variations_written	int
!=	O
total_variations	int
)	O
fprintf	function
(	O
outfile	pointer
,	O
"},\n"	pointer
)	O
;	O
else	O
fprintf	function
(	O
outfile	pointer
,	O
"}\n};\n\n\n"	pointer
)	O
;	O
if	O
(	O
variation	array
->	O
next	pointer
)	O
corner_write_variations	function
(	O
variation	array
->	O
next	pointer
,	O
outfile	pointer
)	O
;	O
if	O
(	O
variation	array
->	O
child	pointer
)	O
corner_write_variations	function
(	O
variation	array
->	O
child	pointer
,	O
outfile	pointer
)	O
;	O
}	O
static	O
void	O
write_attributes	function
(	O
FILE	struct
*	O
outfile	pointer
)	O
{	O
int	O
k	int
;	O
fprintf	function
(	O
outfile	pointer
,	O
"static struct pattern_attribute attributes[] = {\n"	pointer
)	O
;	O
fprintf	function
(	O
outfile	pointer
,	O
"#ifdef HAVE_TRANSPARENT_UNIONS\n"	pointer
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_attributes	int
;	O
k	int
++	O
)	O
{	O
fprintf	function
(	O
outfile	pointer
,	O
"  {%s,"	pointer
,	O
attribute_name	array
[	O
attributes	pointer
[	O
k	int
]	O
.	O
type	char
]	O
)	O
;	O
if	O
(	O
attributes	pointer
[	O
k	int
]	O
.	O
type	char
>=	O
FIRST_OFFSET_ATTRIBUTE	int
)	O
fprintf	function
(	O
outfile	pointer
,	O
"{.offset=%d}}"	pointer
,	O
attributes	pointer
[	O
k	int
]	O
.	O
offset	short
)	O
;	O
else	O
fprintf	function
(	O
outfile	pointer
,	O
"{.value=%f}}"	pointer
,	O
attributes	pointer
[	O
k	int
]	O
.	O
value	pointer
)	O
;	O
if	O
(	O
k	int
!=	O
num_attributes	int
-	O
1	int
)	O
fprintf	function
(	O
outfile	pointer
,	O
",\n"	pointer
)	O
;	O
}	O
fprintf	function
(	O
outfile	pointer
,	O
"\n#else\n"	pointer
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_attributes	int
;	O
k	int
++	O
)	O
{	O
fprintf	function
(	O
outfile	pointer
,	O
"  {%s,"	pointer
,	O
attribute_name	array
[	O
attributes	pointer
[	O
k	int
]	O
.	O
type	char
]	O
)	O
;	O
if	O
(	O
attributes	pointer
[	O
k	int
]	O
.	O
type	char
>=	O
FIRST_OFFSET_ATTRIBUTE	int
)	O
fprintf	function
(	O
outfile	pointer
,	O
"0.0,%d}"	pointer
,	O
attributes	pointer
[	O
k	int
]	O
.	O
offset	short
)	O
;	O
else	O
fprintf	function
(	O
outfile	pointer
,	O
"%f,0}"	pointer
,	O
attributes	pointer
[	O
k	int
]	O
.	O
value	pointer
)	O
;	O
if	O
(	O
k	int
!=	O
num_attributes	int
-	O
1	int
)	O
fprintf	function
(	O
outfile	pointer
,	O
",\n"	pointer
)	O
;	O
}	O
fprintf	function
(	O
outfile	pointer
,	O
"\n#endif\n};\n\n"	pointer
)	O
;	O
}	O
static	O
void	O
write_patterns	function
(	O
FILE	struct
*	O
outfile	pointer
)	O
{	O
int	O
j	int
;	O
if	O
(	O
database_type	int
==	O
DB_CORNER	O
)	O
fprintf	function
(	O
outfile	pointer
,	O
"static struct corner_pattern %s[] = {\n"	pointer
,	O
prefix	pointer
)	O
;	O
else	O
fprintf	function
(	O
outfile	pointer
,	O
"static struct pattern %s[] = {\n"	pointer
,	O
prefix	pointer
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
patno	int
;	O
++	O
j	int
)	O
{	O
struct	O
pattern	pointer
*	O
p	pointer
=	O
pattern	pointer
+	O
j	int
;	O
if	O
(	O
database_type	int
==	O
DB_CORNER	O
)	O
{	O
fprintf	function
(	O
outfile	pointer
,	O
"  {%d,%d,0x%x,\"%s\","	pointer
,	O
second_corner_offset	int
[	O
j	int
]	O
,	O
(	O
p	pointer
->	O
trfno	int
==	O
4	int
)	O
,	O
p	pointer
->	O
class	int
,	O
pattern_names	array
[	O
j	int
]	O
)	O
;	O
if	O
(	O
attributes_needed	int
)	O
{	O
fprintf	function
(	O
outfile	pointer
,	O
"attributes+%d,"	pointer
,	O
(	O
int	O
)	O
(	O
p	pointer
->	O
attributes	pointer
?	O
p	pointer
->	O
attributes	pointer
-	O
attributes	pointer
:	O
0	int
)	O
)	O
;	O
}	O
else	O
fprintf	function
(	O
outfile	pointer
,	O
"NULL,"	pointer
)	O
;	O
fprintf	function
(	O
outfile	pointer
,	O
"%d,"	pointer
,	O
p	pointer
->	O
autohelper_flag	int
)	O
;	O
if	O
(	O
p	pointer
->	O
autohelper	pointer
)	O
fprintf	function
(	O
outfile	pointer
,	O
"autohelper%s%d}"	pointer
,	O
prefix	pointer
,	O
j	int
)	O
;	O
else	O
fprintf	function
(	O
outfile	pointer
,	O
"NULL}"	pointer
)	O
;	O
if	O
(	O
j	int
!=	O
patno	int
-	O
1	int
)	O
fprintf	function
(	O
outfile	pointer
,	O
",\n"	pointer
)	O
;	O
else	O
fprintf	function
(	O
outfile	pointer
,	O
"\n};\n\n\n"	pointer
)	O
;	O
continue	O
;	O
}	O
fprintf	function
(	O
outfile	pointer
,	O
"  {%s%d,%d,%d, \"%s\",%d,%d,%d,%d,%d,%d,0x%x,%d"	pointer
,	O
prefix	pointer
,	O
j	int
,	O
p	pointer
->	O
patlen	int
,	O
p	pointer
->	O
trfno	int
,	O
pattern_names	array
[	O
j	int
]	O
,	O
p	pointer
->	O
mini	int
,	O
p	pointer
->	O
minj	int
,	O
p	pointer
->	O
maxi	int
,	O
p	pointer
->	O
maxj	int
,	O
p	pointer
->	O
maxi	int
-	O
p	pointer
->	O
mini	int
,	O
p	pointer
->	O
maxj	int
-	O
p	pointer
->	O
minj	int
,	O
p	pointer
->	O
edge_constraints	int
,	O
p	pointer
->	O
move_offset	int
)	O
;	O
fprintf	function
(	O
outfile	pointer
,	O
",\n    {"	pointer
)	O
;	O
{	O
int	O
ll	int
;	O
for	O
(	O
ll	int
=	O
0	int
;	O
ll	int
<	O
8	int
;	O
++	O
ll	int
)	O
fprintf	function
(	O
outfile	pointer
,	O
" 0x%08x%s"	pointer
,	O
p	pointer
->	O
and_mask	array
[	O
ll	int
]	O
,	O
ll	int
<	O
7	int
?	O
","	pointer
:	O
""	pointer
)	O
;	O
fprintf	function
(	O
outfile	pointer
,	O
"},\n    {"	pointer
)	O
;	O
for	O
(	O
ll	int
=	O
0	int
;	O
ll	int
<	O
8	int
;	O
++	O
ll	int
)	O
fprintf	function
(	O
outfile	pointer
,	O
" 0x%08x%s"	pointer
,	O
p	pointer
->	O
val_mask	array
[	O
ll	int
]	O
,	O
ll	int
<	O
7	int
?	O
","	pointer
:	O
""	pointer
)	O
;	O
}	O
fprintf	function
(	O
outfile	pointer
,	O
"}\n   "	pointer
)	O
;	O
fprintf	function
(	O
outfile	pointer
,	O
", 0x%x,%f,"	pointer
,	O
p	pointer
->	O
class	int
,	O
p	pointer
->	O
value	pointer
)	O
;	O
if	O
(	O
attributes_needed	int
)	O
{	O
fprintf	function
(	O
outfile	pointer
,	O
"attributes+%d,"	pointer
,	O
(	O
int	O
)	O
(	O
p	pointer
->	O
attributes	pointer
?	O
p	pointer
->	O
attributes	pointer
-	O
attributes	pointer
:	O
0	int
)	O
)	O
;	O
}	O
else	O
fprintf	function
(	O
outfile	pointer
,	O
"NULL,"	pointer
)	O
;	O
fprintf	function
(	O
outfile	pointer
,	O
"%d,%s,"	pointer
,	O
p	pointer
->	O
autohelper_flag	int
,	O
helper_fn_names	array
[	O
j	int
]	O
)	O
;	O
if	O
(	O
p	pointer
->	O
autohelper	pointer
)	O
fprintf	function
(	O
outfile	pointer
,	O
"autohelper%s%d"	pointer
,	O
prefix	pointer
,	O
j	int
)	O
;	O
else	O
fprintf	function
(	O
outfile	pointer
,	O
"NULL"	pointer
)	O
;	O
fprintf	function
(	O
outfile	pointer
,	O
",%d"	pointer
,	O
p	pointer
->	O
anchored_at_X	int
)	O
;	O
fprintf	function
(	O
outfile	pointer
,	O
",%f"	pointer
,	O
p	pointer
->	O
constraint_cost	float
)	O
;	O
fprintf	function
(	O
outfile	pointer
,	O
"},\n"	pointer
)	O
;	O
}	O
if	O
(	O
database_type	int
==	O
DB_CORNER	O
)	O
return	O
;	O
fprintf	function
(	O
outfile	pointer
,	O
"  {NULL, 0,0,NULL,0,0,0,0,0,0,0,0"	pointer
)	O
;	O
fprintf	function
(	O
outfile	pointer
,	O
",{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0}"	pointer
)	O
;	O
fprintf	function
(	O
outfile	pointer
,	O
",0,0.0,NULL,0,NULL,NULL,0,0.0"	pointer
)	O
;	O
fprintf	function
(	O
outfile	pointer
,	O
"}\n};\n"	pointer
)	O
;	O
}	O
static	O
void	O
write_pattern_db	function
(	O
FILE	struct
*	O
outfile	pointer
)	O
{	O
if	O
(	O
database_type	int
==	O
DB_CORNER	O
)	O
{	O
fprintf	function
(	O
outfile	pointer
,	O
"struct corner_db %s_db = {\n"	pointer
,	O
prefix	pointer
)	O
;	O
fprintf	function
(	O
outfile	pointer
,	O
"  %d,\n"	pointer
,	O
corner_max_width	int
+	O
1	int
)	O
;	O
fprintf	function
(	O
outfile	pointer
,	O
"  %d,\n"	pointer
,	O
corner_max_height	int
+	O
1	int
)	O
;	O
fprintf	function
(	O
outfile	pointer
,	O
"  %d,\n"	pointer
,	O
corner_root	struct
.	O
num_variations	char
)	O
;	O
fprintf	function
(	O
outfile	pointer
,	O
"  %s_variations\n"	pointer
,	O
prefix	pointer
)	O
;	O
fprintf	function
(	O
outfile	pointer
,	O
"};\n"	pointer
)	O
;	O
return	O
;	O
}	O
fprintf	function
(	O
outfile	pointer
,	O
"\n"	pointer
)	O
;	O
fprintf	function
(	O
outfile	pointer
,	O
"struct pattern_db %s_db = {\n"	pointer
,	O
prefix	pointer
)	O
;	O
fprintf	function
(	O
outfile	pointer
,	O
"  -1,\n"	pointer
)	O
;	O
fprintf	function
(	O
outfile	pointer
,	O
"  %d,\n"	pointer
,	O
fixed_anchor	int
)	O
;	O
fprintf	function
(	O
outfile	pointer
,	O
"  %s\n"	pointer
,	O
prefix	pointer
)	O
;	O
if	O
(	O
database_type	int
==	O
DB_DFA	O
)	O
fprintf	function
(	O
outfile	pointer
,	O
" ,& dfa_%s\n"	pointer
,	O
prefix	pointer
)	O
;	O
else	O
fprintf	function
(	O
outfile	pointer
,	O
" , NULL\n"	pointer
)	O
;	O
fprintf	function
(	O
outfile	pointer
,	O
"};\n"	pointer
)	O
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
static	O
char	O
stdin_name	array
[	O
]	O
=	O
"<stdin>"	pointer
;	O
int	O
input_files	int
=	O
0	int
;	O
int	O
ifc	int
;	O
char	O
*	O
input_file_names	array
[	O
MAX_INPUT_FILE_NAMES	int
]	O
;	O
char	O
*	O
output_file_name	pointer
=	O
NULL	O
;	O
char	O
*	O
transformations_file_name	pointer
=	O
NULL	O
;	O
FILE	struct
*	O
input_FILE	pointer
=	O
stdin	pointer
;	O
FILE	struct
*	O
output_FILE	pointer
=	O
stdout	pointer
;	O
FILE	struct
*	O
transformations_FILE	pointer
=	O
NULL	O
;	O
int	O
state	pointer
=	O
0	int
;	O
char	O
*	O
save_code_pos	pointer
=	O
autohelper_code	array
;	O
int	O
iterations	int
=	O
0	int
;	O
transformation_init	function
(	O
)	O
;	O
{	O
int	O
i	int
;	O
int	O
multiple_anchor_options	int
=	O
0	int
;	O
while	O
(	O
(	O
i	int
=	O
gg_getopt	function
(	O
argc	int
,	O
argv	pointer
,	O
"i:o:t:vV:pcfCDd:A:OXbma"	pointer
)	O
)	O
!=	O
EOF	O
)	O
{	O
switch	O
(	O
i	int
)	O
{	O
case	O
'i'	O
:	O
if	O
(	O
input_files	int
==	O
MAX_INPUT_FILE_NAMES	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Error : Too many input files (maximum %d supported)\n"	pointer
,	O
MAX_INPUT_FILE_NAMES	int
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
input_file_names	array
[	O
input_files	int
++	O
]	O
=	O
gg_optarg	pointer
;	O
break	O
;	O
case	O
'o'	O
:	O
output_file_name	pointer
=	O
gg_optarg	pointer
;	O
break	O
;	O
case	O
't'	O
:	O
transformations_file_name	pointer
=	O
gg_optarg	pointer
;	O
break	O
;	O
case	O
'v'	O
:	O
verbose	int
=	O
1	int
;	O
break	O
;	O
case	O
'V'	O
:	O
dfa_verbose	int
=	O
strtol	function
(	O
gg_optarg	pointer
,	O
NULL	O
,	O
10	int
)	O
;	O
break	O
;	O
case	O
'p'	O
:	O
case	O
'c'	O
:	O
case	O
'f'	O
:	O
case	O
'C'	O
:	O
case	O
'D'	O
:	O
case	O
'd'	O
:	O
if	O
(	O
database_type	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Error : More than one database type specified (-%c and -%c)\n"	pointer
,	O
database_type	int
,	O
i	int
)	O
;	O
return	O
1	int
;	O
}	O
database_type	int
=	O
i	int
;	O
if	O
(	O
i	int
==	O
'd'	O
)	O
{	O
iterations	int
=	O
strtol	function
(	O
gg_optarg	pointer
,	O
NULL	O
,	O
10	int
)	O
;	O
if	O
(	O
iterations	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Error : Expected a non-negative number of iterations\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
break	O
;	O
case	O
'O'	O
:	O
if	O
(	O
anchor	int
)	O
multiple_anchor_options	int
=	O
1	int
;	O
anchor	int
=	O
ANCHOR_O	O
;	O
break	O
;	O
case	O
'X'	O
:	O
if	O
(	O
anchor	int
)	O
multiple_anchor_options	int
=	O
1	int
;	O
anchor	int
=	O
ANCHOR_X	O
;	O
break	O
;	O
case	O
'b'	O
:	O
if	O
(	O
anchor	int
)	O
multiple_anchor_options	int
=	O
1	int
;	O
anchor	int
=	O
ANCHOR_BOTH	O
;	O
break	O
;	O
case	O
'm'	O
:	O
choose_best_anchor	int
=	O
1	int
;	O
if	O
(	O
fixed_anchor	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"Warning : -m and -a are mutually exclusive.\n"	pointer
)	O
;	O
break	O
;	O
case	O
'a'	O
:	O
fixed_anchor	int
=	O
1	int
;	O
if	O
(	O
choose_best_anchor	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"Warning : -m and -a are mutually exclusive.\n"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
"\b ; ignored\n"	pointer
)	O
;	O
}	O
}	O
if	O
(	O
!	O
database_type	int
)	O
database_type	int
=	O
DB_GENERAL	O
;	O
if	O
(	O
!	O
anchor	int
)	O
anchor	int
=	O
ANCHOR_O	O
;	O
if	O
(	O
!	O
input_files	int
)	O
input_file_names	array
[	O
input_files	int
++	O
]	O
=	O
stdin_name	array
;	O
if	O
(	O
output_file_name	pointer
&&	O
database_type	int
!=	O
OPTIMIZE_DFA	O
)	O
{	O
output_FILE	pointer
=	O
fopen	function
(	O
output_file_name	pointer
,	O
"wb"	pointer
)	O
;	O
if	O
(	O
output_FILE	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Error : Cannot write to file %s\n"	pointer
,	O
output_file_name	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
if	O
(	O
transformations_file_name	pointer
&&	O
(	O
database_type	int
==	O
DB_DFA	O
||	O
database_type	int
==	O
OPTIMIZE_DFA	O
)	O
)	O
{	O
transformations_FILE	pointer
=	O
fopen	function
(	O
transformations_file_name	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
transformations_FILE	pointer
)	O
{	O
parse_transformations_file	function
(	O
transformations_FILE	pointer
)	O
;	O
fclose	function
(	O
transformations_FILE	pointer
)	O
;	O
}	O
else	O
if	O
(	O
database_type	int
==	O
DB_DFA	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Error : Cannot read file %s\n"	pointer
,	O
transformations_file_name	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
if	O
(	O
multiple_anchor_options	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"Warning : Multiple anchor options encountered. The last took precedence\n"	pointer
)	O
;	O
}	O
if	O
(	O
gg_optind	int
>=	O
argc	int
)	O
{	O
fputs	function
(	O
USAGE	pointer
,	O
stderr	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
prefix	pointer
=	O
argv	pointer
[	O
gg_optind	int
]	O
;	O
if	O
(	O
database_type	int
==	O
DB_DFA	O
)	O
{	O
dfa_init	function
(	O
)	O
;	O
new_dfa	function
(	O
&	O
dfa	struct
,	O
"mkpat's dfa"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
database_type	int
==	O
DB_CORNER	O
)	O
corner_init	function
(	O
)	O
;	O
if	O
(	O
database_type	int
==	O
OPTIMIZE_DFA	O
)	O
{	O
if	O
(	O
transformations_file_name	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"error : transformation file required (use -t option)\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
dfa_patterns_reset	function
(	O
&	O
dfa_pats	struct
)	O
;	O
dfa_init	function
(	O
)	O
;	O
}	O
else	O
fprintf	function
(	O
output_FILE	pointer
,	O
PREAMBLE	pointer
)	O
;	O
patno	int
=	O
-	O
1	int
;	O
autohelper_code	array
[	O
0	int
]	O
=	O
0	int
;	O
code_pos	pointer
=	O
autohelper_code	array
;	O
num_attributes	int
=	O
1	int
;	O
attributes	pointer
[	O
0	int
]	O
.	O
type	char
=	O
LAST_ATTRIBUTE	int
;	O
for	O
(	O
ifc	int
=	O
0	int
;	O
ifc	int
<	O
input_files	int
&&	O
!	O
fatal_errors	int
;	O
ifc	int
++	O
)	O
{	O
char	O
line	int
[	O
MAXLINE	int
]	O
;	O
if	O
(	O
input_file_names	array
[	O
ifc	int
]	O
!=	O
stdin_name	array
)	O
{	O
input_FILE	pointer
=	O
fopen	function
(	O
input_file_names	array
[	O
ifc	int
]	O
,	O
"r"	pointer
)	O
;	O
if	O
(	O
input_FILE	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Error: Cannot open file %s\n"	pointer
,	O
input_file_names	array
[	O
ifc	int
]	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
current_file	pointer
=	O
input_file_names	array
[	O
ifc	int
]	O
;	O
current_line_number	int
=	O
0	int
;	O
while	O
(	O
fgets	function
(	O
line	int
,	O
MAXLINE	int
,	O
input_FILE	pointer
)	O
)	O
{	O
int	O
command	int
=	O
0	int
;	O
char	O
command_data	array
[	O
MAXLINE	int
]	O
;	O
current_line_number	int
++	O
;	O
if	O
(	O
line	int
[	O
strlen	function
(	O
line	int
)	O
-	O
1	int
]	O
!=	O
'\n'	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : Error : line truncated (longer than %d characters)\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
MAXLINE	int
-	O
1	int
)	O
;	O
fatal_errors	int
++	O
;	O
}	O
{	O
int	O
i	int
=	O
strlen	function
(	O
line	int
)	O
-	O
2	int
;	O
while	O
(	O
i	int
>=	O
0	int
&&	O
isspace	function
(	O
(	O
int	O
)	O
line	int
[	O
i	int
]	O
)	O
)	O
i	int
--	O
;	O
line	int
[	O
i	int
+	O
1	int
]	O
=	O
'\n'	O
;	O
line	int
[	O
i	int
+	O
2	int
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
sscanf	function
(	O
line	int
,	O
"Pattern %s"	pointer
,	O
command_data	array
)	O
==	O
1	int
)	O
command	int
=	O
1	int
;	O
else	O
if	O
(	O
sscanf	function
(	O
line	int
,	O
"goal_elements %s"	pointer
,	O
command_data	array
)	O
==	O
1	int
)	O
command	int
=	O
2	int
;	O
else	O
if	O
(	O
sscanf	function
(	O
line	int
,	O
"callback_data %s"	pointer
,	O
command_data	array
)	O
==	O
1	int
)	O
command	int
=	O
3	int
;	O
else	O
if	O
(	O
sscanf	function
(	O
line	int
,	O
"attribute_map %s"	pointer
,	O
command_data	array
)	O
==	O
1	int
)	O
command	int
=	O
4	int
;	O
if	O
(	O
command	int
)	O
{	O
char	O
*	O
p	pointer
=	O
strpbrk	function
(	O
command_data	array
,	O
" \t"	pointer
)	O
;	O
if	O
(	O
p	pointer
)	O
*	O
p	pointer
=	O
0	int
;	O
if	O
(	O
patno	int
>=	O
0	int
)	O
{	O
switch	O
(	O
state	pointer
)	O
{	O
case	O
1	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : Warning: empty pattern %s\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
case	O
3	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : Error : No entry line for pattern %s\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
fatal_errors	int
++	O
;	O
break	O
;	O
case	O
5	int
:	O
case	O
6	int
:	O
{	O
struct	O
pattern_attribute	struct
*	O
attribute	pointer
=	O
NULL	O
;	O
if	O
(	O
pattern	pointer
[	O
patno	int
]	O
.	O
attributes	pointer
)	O
{	O
for	O
(	O
attribute	pointer
=	O
pattern	pointer
[	O
patno	int
]	O
.	O
attributes	pointer
;	O
attribute	pointer
->	O
type	char
!=	O
LAST_ATTRIBUTE	int
;	O
attribute	pointer
++	O
)	O
{	O
if	O
(	O
attribute	pointer
->	O
type	char
>=	O
FIRST_OFFSET_ATTRIBUTE	int
)	O
break	O
;	O
}	O
}	O
if	O
(	O
attribute	pointer
==	O
NULL	O
||	O
attribute	pointer
->	O
type	char
==	O
LAST_ATTRIBUTE	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : Warning: constraint diagram but no constraint line or offset attributes for pattern %s\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
}	O
}	O
break	O
;	O
case	O
7	int
:	O
case	O
8	int
:	O
finish_constraint_and_action	function
(	O
)	O
;	O
case	O
0	int
:	O
case	O
4	int
:	O
check_constraint_diagram	function
(	O
)	O
;	O
}	O
}	O
state	pointer
=	O
0	int
;	O
if	O
(	O
command	int
==	O
1	int
)	O
{	O
int	O
k	int
;	O
if	O
(	O
!	O
discard_pattern	int
)	O
{	O
convert_attribute_labels_to_offsets	function
(	O
)	O
;	O
patno	int
++	O
;	O
}	O
else	O
code_pos	pointer
=	O
save_code_pos	pointer
;	O
reset_pattern	function
(	O
)	O
;	O
if	O
(	O
strlen	function
(	O
command_data	array
)	O
>	O
MAXNAME	int
-	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : Warning : pattern name is too long, truncated\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
)	O
;	O
command_data	array
[	O
MAXNAME	int
-	O
1	int
]	O
=	O
0	int
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
patno	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
pattern_names	array
[	O
k	int
]	O
,	O
command_data	array
)	O
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : Warning : duplicate pattern name `%s'\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
command_data	array
)	O
;	O
break	O
;	O
}	O
}	O
strcpy	function
(	O
pattern_names	array
[	O
patno	int
]	O
,	O
command_data	array
)	O
;	O
transformation_hint	int
=	O
find_transformation_hint	function
(	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
state	pointer
=	O
1	int
;	O
discard_pattern	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
command	int
==	O
2	int
||	O
command	int
==	O
3	int
)	O
{	O
int	O
*	O
sort_out	pointer
=	O
(	O
command	int
==	O
2	int
?	O
nongoal	array
:	O
callback_unneeded	array
)	O
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
sort_out	pointer
[	O
k	int
]	O
=	O
1	int
;	O
if	O
(	O
strcmp	function
(	O
command_data	array
,	O
"none"	pointer
)	O
)	O
{	O
char	O
*	O
c	char
;	O
for	O
(	O
c	char
=	O
command_data	array
;	O
*	O
c	char
;	O
c	char
++	O
)	O
{	O
switch	O
(	O
*	O
c	char
)	O
{	O
case	O
'.'	O
:	O
sort_out	pointer
[	O
ATT_dot	int
]	O
=	O
0	int
;	O
if	O
(	O
command	int
==	O
2	int
)	O
{	O
sort_out	pointer
[	O
ATT_comma	int
]	O
=	O
0	int
;	O
sort_out	pointer
[	O
ATT_not	int
]	O
=	O
0	int
;	O
}	O
break	O
;	O
case	O
'X'	O
:	O
sort_out	pointer
[	O
ATT_X	int
]	O
=	O
0	int
;	O
break	O
;	O
case	O
'O'	O
:	O
sort_out	pointer
[	O
ATT_O	int
]	O
=	O
0	int
;	O
break	O
;	O
case	O
'x'	O
:	O
sort_out	pointer
[	O
ATT_x	int
]	O
=	O
0	int
;	O
break	O
;	O
case	O
'o'	O
:	O
sort_out	pointer
[	O
ATT_o	int
]	O
=	O
0	int
;	O
break	O
;	O
case	O
','	O
:	O
sort_out	pointer
[	O
ATT_comma	int
]	O
=	O
0	int
;	O
if	O
(	O
command	int
!=	O
2	int
)	O
break	O
;	O
case	O
'!'	O
:	O
sort_out	pointer
[	O
ATT_not	int
]	O
=	O
0	int
;	O
if	O
(	O
command	int
!=	O
2	int
)	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : Error : illegal character `%c'\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
*	O
c	char
)	O
;	O
fatal_errors	int
++	O
;	O
}	O
}	O
}	O
}	O
else	O
{	O
struct	O
attribute_description	struct
*	O
old_map	pointer
=	O
attribute_map	pointer
;	O
if	O
(	O
strcmp	function
(	O
command_data	array
,	O
"general"	pointer
)	O
==	O
0	int
)	O
{	O
attribute_map	pointer
=	O
general_attribute_map	array
;	O
attributes_needed	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
command_data	array
,	O
"value_only"	pointer
)	O
==	O
0	int
)	O
{	O
attribute_map	pointer
=	O
value_only_attribute_map	array
;	O
attributes_needed	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
command_data	array
,	O
"owl_attack"	pointer
)	O
==	O
0	int
)	O
{	O
attribute_map	pointer
=	O
owl_attack_attribute_map	array
;	O
attributes_needed	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
command_data	array
,	O
"owl_defense"	pointer
)	O
==	O
0	int
)	O
{	O
attribute_map	pointer
=	O
owl_defense_attribute_map	array
;	O
attributes_needed	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
command_data	array
,	O
"none"	pointer
)	O
==	O
0	int
)	O
{	O
attribute_map	pointer
=	O
NULL	O
;	O
attributes_needed	int
=	O
0	int
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : Error : unknown attribute map `%s'"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
command_data	array
)	O
;	O
fatal_errors	int
++	O
;	O
}	O
if	O
(	O
patno	int
!=	O
-	O
1	int
&&	O
attribute_map	pointer
!=	O
old_map	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : Error : attribute map can only be set before the first pattern\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
)	O
;	O
fatal_errors	int
++	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
line	int
[	O
0	int
]	O
==	O
'\n'	O
||	O
line	int
[	O
0	int
]	O
==	O
'#'	O
)	O
{	O
if	O
(	O
state	pointer
==	O
2	int
||	O
state	pointer
==	O
5	int
)	O
{	O
if	O
(	O
state	pointer
==	O
5	int
)	O
check_constraint_diagram_size	function
(	O
)	O
;	O
state	pointer
++	O
;	O
}	O
}	O
else	O
if	O
(	O
strchr	function
(	O
VALID_PATTERN_CHARS	array
,	O
line	int
[	O
0	int
]	O
)	O
||	O
strchr	function
(	O
VALID_EDGE_CHARS	array
,	O
line	int
[	O
0	int
]	O
)	O
||	O
strchr	function
(	O
VALID_CONSTRAINT_LABELS	array
,	O
line	int
[	O
0	int
]	O
)	O
)	O
{	O
switch	O
(	O
state	pointer
)	O
{	O
case	O
0	int
:	O
case	O
3	int
:	O
case	O
6	int
:	O
case	O
7	int
:	O
case	O
8	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : error : What, another diagram here? (pattern %s)\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
fatal_errors	int
++	O
;	O
break	O
;	O
case	O
1	int
:	O
state	pointer
++	O
;	O
case	O
2	int
:	O
if	O
(	O
!	O
read_pattern_line	function
(	O
line	int
)	O
)	O
{	O
discard_pattern	int
=	O
1	int
;	O
el	int
=	O
0	int
;	O
}	O
break	O
;	O
case	O
4	int
:	O
state	pointer
++	O
;	O
case	O
5	int
:	O
read_constraint_diagram_line	function
(	O
line	int
)	O
;	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
line	int
[	O
0	int
]	O
==	O
':'	O
)	O
{	O
if	O
(	O
state	pointer
==	O
2	int
||	O
state	pointer
==	O
3	int
)	O
{	O
finish_pattern	function
(	O
line	int
)	O
;	O
if	O
(	O
!	O
discard_pattern	int
)	O
{	O
if	O
(	O
database_type	int
==	O
DB_DFA	O
||	O
database_type	int
==	O
OPTIMIZE_DFA	O
)	O
write_to_dfa	function
(	O
patno	int
)	O
;	O
if	O
(	O
database_type	int
==	O
DB_CORNER	O
)	O
corner_add_pattern	function
(	O
)	O
;	O
else	O
if	O
(	O
database_type	int
!=	O
OPTIMIZE_DFA	O
)	O
write_elements	function
(	O
output_FILE	pointer
)	O
;	O
}	O
state	pointer
=	O
4	int
;	O
save_code_pos	pointer
=	O
code_pos	pointer
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : warning : Unexpected entry line in pattern %s\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
line	int
[	O
0	int
]	O
==	O
';'	O
)	O
{	O
if	O
(	O
state	pointer
==	O
5	int
)	O
check_constraint_diagram_size	function
(	O
)	O
;	O
if	O
(	O
state	pointer
==	O
5	int
||	O
state	pointer
==	O
6	int
||	O
state	pointer
==	O
7	int
)	O
{	O
read_constraint_line	function
(	O
line	int
+	O
1	int
)	O
;	O
state	pointer
=	O
7	int
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : Warning: unexpected constraint line in pattern %s\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
line	int
[	O
0	int
]	O
==	O
'>'	O
)	O
{	O
if	O
(	O
state	pointer
==	O
4	int
||	O
state	pointer
==	O
5	int
||	O
state	pointer
==	O
6	int
||	O
state	pointer
==	O
7	int
||	O
state	pointer
==	O
8	int
)	O
{	O
if	O
(	O
state	pointer
==	O
5	int
)	O
check_constraint_diagram_size	function
(	O
)	O
;	O
read_action_line	function
(	O
line	int
+	O
1	int
)	O
;	O
state	pointer
=	O
8	int
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Warning: unexpected action line in pattern %s\n"	pointer
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
}	O
}	O
else	O
{	O
int	O
i	int
=	O
strlen	function
(	O
line	int
)	O
;	O
char	O
c	char
=	O
line	int
[	O
i	int
-	O
1	int
]	O
;	O
line	int
[	O
i	int
-	O
1	int
]	O
=	O
0	int
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : error : Malformed line \"%s\" in pattern %s\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
line	int
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
line	int
[	O
i	int
-	O
1	int
]	O
=	O
c	char
;	O
fatal_errors	int
++	O
;	O
}	O
}	O
}	O
convert_attribute_labels_to_offsets	function
(	O
)	O
;	O
if	O
(	O
patno	int
>=	O
0	int
)	O
{	O
switch	O
(	O
state	pointer
)	O
{	O
case	O
1	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"Warning: empty pattern %s\n"	pointer
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
case	O
3	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"%s(%d) : Error : no entry line for pattern %s\n"	pointer
,	O
current_file	pointer
,	O
current_line_number	int
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
fatal_errors	int
++	O
;	O
break	O
;	O
case	O
5	int
:	O
case	O
6	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"Warning: constraint diagram but no constraint line for pattern %s\n"	pointer
,	O
pattern_names	array
[	O
patno	int
]	O
)	O
;	O
break	O
;	O
case	O
7	int
:	O
case	O
8	int
:	O
finish_constraint_and_action	function
(	O
)	O
;	O
case	O
0	int
:	O
case	O
4	int
:	O
check_constraint_diagram	function
(	O
)	O
;	O
patno	int
++	O
;	O
reset_pattern	function
(	O
)	O
;	O
}	O
}	O
if	O
(	O
discard_pattern	int
)	O
{	O
patno	int
--	O
;	O
code_pos	pointer
=	O
save_code_pos	pointer
;	O
}	O
*	O
code_pos	pointer
=	O
0	int
;	O
if	O
(	O
verbose	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%d / %d patterns have edge-constraints\n"	pointer
,	O
pats_with_constraints	int
,	O
patno	int
)	O
;	O
if	O
(	O
database_type	int
!=	O
OPTIMIZE_DFA	O
)	O
{	O
if	O
(	O
database_type	int
!=	O
DB_CORNER	O
)	O
fprintf	function
(	O
output_FILE	pointer
,	O
"static struct pattern %s[%d];\n\n"	pointer
,	O
prefix	pointer
,	O
patno	int
+	O
1	int
)	O
;	O
else	O
fprintf	function
(	O
output_FILE	pointer
,	O
"static struct corner_pattern %s[%d];\n\n"	pointer
,	O
prefix	pointer
,	O
patno	int
+	O
1	int
)	O
;	O
fprintf	function
(	O
output_FILE	pointer
,	O
"%s"	pointer
,	O
autohelper_code	array
)	O
;	O
if	O
(	O
attributes_needed	int
)	O
write_attributes	function
(	O
output_FILE	pointer
)	O
;	O
else	O
assert	O
(	O
num_attributes	int
==	O
1	int
)	O
;	O
write_patterns	function
(	O
output_FILE	pointer
)	O
;	O
if	O
(	O
database_type	int
==	O
DB_DFA	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"---------------------------\n"	pointer
)	O
;	O
dfa_finalize	function
(	O
&	O
dfa	struct
)	O
;	O
dfa_shuffle	function
(	O
&	O
dfa	struct
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"DFA for %s\n"	pointer
,	O
prefix	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"size: %d kB for "	pointer
,	O
dfa_size	function
(	O
&	O
dfa	struct
)	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%d patterns"	pointer
,	O
patno	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
" (%d states)\n"	pointer
,	O
dfa	struct
.	O
last_state	int
)	O
;	O
strcpy	function
(	O
dfa	struct
.	O
name	short
,	O
prefix	pointer
)	O
;	O
print_c_dfa	function
(	O
output_FILE	pointer
,	O
prefix	pointer
,	O
&	O
dfa	struct
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"---------------------------\n"	pointer
)	O
;	O
if	O
(	O
DFA_MAX_MATCHED	O
/	O
8	int
<	O
dfa_calculate_max_matched_patterns	function
(	O
&	O
dfa	struct
)	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
"Warning: Increase DFA_MAX_MATCHED in 'dfa.h'.\n"	pointer
)	O
;	O
kill_dfa	function
(	O
&	O
dfa	struct
)	O
;	O
dfa_end	function
(	O
)	O
;	O
}	O
if	O
(	O
database_type	int
==	O
DB_CORNER	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"---------------------------\n"	pointer
)	O
;	O
corner_pack_variations	function
(	O
corner_root	struct
.	O
child	pointer
,	O
0	int
)	O
;	O
fprintf	function
(	O
output_FILE	pointer
,	O
"static struct corner_variation %s_variations[] = {\n"	pointer
,	O
prefix	pointer
)	O
;	O
corner_write_variations	function
(	O
corner_root	struct
.	O
child	pointer
,	O
output_FILE	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"corner database for %s\n"	pointer
,	O
prefix	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"size: %d kB for %d patterns (%d variations)\n"	pointer
,	O
CORNER_DB_SIZE	O
(	O
patno	int
,	O
total_variations	int
)	O
,	O
patno	int
,	O
total_variations	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"---------------------------\n"	pointer
)	O
;	O
}	O
write_pattern_db	function
(	O
output_FILE	pointer
)	O
;	O
if	O
(	O
fatal_errors	int
)	O
{	O
fprintf	function
(	O
output_FILE	pointer
,	O
"\n#error: One or more fatal errors compiling %s\n"	pointer
,	O
current_file	pointer
)	O
;	O
}	O
}	O
else	O
{	O
int	O
k	int
;	O
int	O
*	O
optimized_variations	pointer
;	O
transformations_FILE	pointer
=	O
fopen	function
(	O
transformations_file_name	pointer
,	O
"wb"	pointer
)	O
;	O
if	O
(	O
transformations_FILE	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"error : cannot write to file %s\n"	pointer
,	O
transformations_file_name	pointer
)	O
;	O
}	O
optimized_variations	pointer
=	O
dfa_patterns_optimize_variations	function
(	O
&	O
dfa_pats	struct
,	O
iterations	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
patno	int
;	O
k	int
++	O
)	O
{	O
fprintf	function
(	O
transformations_FILE	pointer
,	O
"%s\t%d\n"	pointer
,	O
pattern_names	array
[	O
k	int
]	O
,	O
optimized_variations	pointer
[	O
k	int
]	O
)	O
;	O
}	O
free	function
(	O
optimized_variations	pointer
)	O
;	O
dfa_end	function
(	O
)	O
;	O
}	O
return	O
fatal_errors	int
?	O
1	int
:	O
0	int
;	O
}	O
