static	O
void	O
exp_fold_tree_1	function
(	O
etree_type	union
*	O
)	O
;	O
static	O
bfd_vma	long
align_n	function
(	O
bfd_vma	long
,	O
bfd_vma	long
)	O
;	O
segment_type	struct
*	O
segments	pointer
;	O
struct	O
ldexp_control	struct
expld	struct
;	O
struct	O
definedness_hash_entry	struct
{	O
struct	O
bfd_hash_entry	struct
root	struct
;	O
asection	struct
*	O
final_sec	pointer
;	O
unsigned	O
int	O
iteration	int
:	O
8	int
;	O
unsigned	O
int	O
by_object	int
:	O
1	int
;	O
}	O
;	O
static	O
struct	O
bfd_hash_table	struct
definedness_table	struct
;	O
static	O
void	O
exp_print_token	function
(	O
token_code_type	int
code	int
,	O
int	O
infix_p	int
)	O
{	O
static	O
const	O
struct	O
{	O
token_code_type	int
code	int
;	O
const	O
char	O
*	O
name	pointer
;	O
}	O
table	pointer
[	O
]	O
=	O
{	O
{	O
INT	int
,	O
"int"	pointer
}	O
,	O
{	O
NAME	int
,	O
"NAME"	pointer
}	O
,	O
{	O
PLUSEQ	int
,	O
"+="	pointer
}	O
,	O
{	O
MINUSEQ	int
,	O
"-="	pointer
}	O
,	O
{	O
MULTEQ	int
,	O
"*="	pointer
}	O
,	O
{	O
DIVEQ	int
,	O
"/="	pointer
}	O
,	O
{	O
LSHIFTEQ	int
,	O
"<<="	pointer
}	O
,	O
{	O
RSHIFTEQ	int
,	O
">>="	pointer
}	O
,	O
{	O
ANDEQ	int
,	O
"&="	pointer
}	O
,	O
{	O
OREQ	int
,	O
"|="	pointer
}	O
,	O
{	O
OROR	int
,	O
"||"	pointer
}	O
,	O
{	O
ANDAND	int
,	O
"&&"	pointer
}	O
,	O
{	O
EQ	int
,	O
"=="	pointer
}	O
,	O
{	O
NE	int
,	O
"!="	pointer
}	O
,	O
{	O
LE	int
,	O
"<="	pointer
}	O
,	O
{	O
GE	int
,	O
">="	pointer
}	O
,	O
{	O
LSHIFT	int
,	O
"<<"	pointer
}	O
,	O
{	O
RSHIFT	int
,	O
">>"	pointer
}	O
,	O
{	O
LOG2CEIL	int
,	O
"LOG2CEIL"	pointer
}	O
,	O
{	O
ALIGN_K	int
,	O
"ALIGN"	pointer
}	O
,	O
{	O
BLOCK	int
,	O
"BLOCK"	pointer
}	O
,	O
{	O
QUAD	int
,	O
"QUAD"	pointer
}	O
,	O
{	O
SQUAD	int
,	O
"SQUAD"	pointer
}	O
,	O
{	O
LONG	int
,	O
"LONG"	pointer
}	O
,	O
{	O
SHORT	int
,	O
"SHORT"	pointer
}	O
,	O
{	O
BYTE	int
,	O
"BYTE"	pointer
}	O
,	O
{	O
SECTIONS	int
,	O
"SECTIONS"	pointer
}	O
,	O
{	O
SIZEOF_HEADERS	int
,	O
"SIZEOF_HEADERS"	pointer
}	O
,	O
{	O
MEMORY	int
,	O
"MEMORY"	pointer
}	O
,	O
{	O
DEFINED	int
,	O
"DEFINED"	pointer
}	O
,	O
{	O
TARGET_K	int
,	O
"TARGET"	pointer
}	O
,	O
{	O
SEARCH_DIR	int
,	O
"SEARCH_DIR"	pointer
}	O
,	O
{	O
MAP	int
,	O
"MAP"	pointer
}	O
,	O
{	O
ENTRY	int
,	O
"ENTRY"	pointer
}	O
,	O
{	O
NEXT	int
,	O
"NEXT"	pointer
}	O
,	O
{	O
ALIGNOF	int
,	O
"ALIGNOF"	pointer
}	O
,	O
{	O
SIZEOF	int
,	O
"SIZEOF"	pointer
}	O
,	O
{	O
ADDR	int
,	O
"ADDR"	pointer
}	O
,	O
{	O
LOADADDR	int
,	O
"LOADADDR"	pointer
}	O
,	O
{	O
CONSTANT	int
,	O
"CONSTANT"	pointer
}	O
,	O
{	O
ABSOLUTE	int
,	O
"ABSOLUTE"	pointer
}	O
,	O
{	O
MAX_K	int
,	O
"MAX"	pointer
}	O
,	O
{	O
MIN_K	int
,	O
"MIN"	pointer
}	O
,	O
{	O
ASSERT_K	int
,	O
"ASSERT"	pointer
}	O
,	O
{	O
REL	int
,	O
"relocatable"	pointer
}	O
,	O
{	O
DATA_SEGMENT_ALIGN	int
,	O
"DATA_SEGMENT_ALIGN"	pointer
}	O
,	O
{	O
DATA_SEGMENT_RELRO_END	int
,	O
"DATA_SEGMENT_RELRO_END"	pointer
}	O
,	O
{	O
DATA_SEGMENT_END	int
,	O
"DATA_SEGMENT_END"	pointer
}	O
,	O
{	O
ORIGIN	int
,	O
"ORIGIN"	pointer
}	O
,	O
{	O
LENGTH	int
,	O
"LENGTH"	pointer
}	O
,	O
{	O
SEGMENT_START	int
,	O
"SEGMENT_START"	pointer
}	O
}	O
;	O
unsigned	O
int	O
idx	int
;	O
for	O
(	O
idx	int
=	O
0	int
;	O
idx	int
<	O
ARRAY_SIZE	O
(	O
table	pointer
)	O
;	O
idx	int
++	O
)	O
if	O
(	O
table	pointer
[	O
idx	int
]	O
.	O
code	int
==	O
code	int
)	O
break	O
;	O
if	O
(	O
infix_p	int
)	O
fputc	function
(	O
' '	O
,	O
config	struct
.	O
map_file	pointer
)	O
;	O
if	O
(	O
idx	int
<	O
ARRAY_SIZE	O
(	O
table	pointer
)	O
)	O
fputs	function
(	O
table	pointer
[	O
idx	int
]	O
.	O
name	pointer
,	O
config	struct
.	O
map_file	pointer
)	O
;	O
else	O
if	O
(	O
code	int
<	O
127	int
)	O
fputc	function
(	O
code	int
,	O
config	struct
.	O
map_file	pointer
)	O
;	O
else	O
fprintf	function
(	O
config	struct
.	O
map_file	pointer
,	O
"<code %d>"	pointer
,	O
code	int
)	O
;	O
if	O
(	O
infix_p	int
)	O
fputc	function
(	O
' '	O
,	O
config	struct
.	O
map_file	pointer
)	O
;	O
}	O
static	O
void	O
make_log2ceil	function
(	O
void	O
)	O
{	O
bfd_vma	long
value	long
=	O
expld	struct
.	O
result	struct
.	O
value	long
;	O
bfd_vma	long
result	struct
=	O
-	O
1	int
;	O
bfd_boolean	int
round_up	int
=	O
FALSE	int
;	O
do	O
{	O
result	struct
++	O
;	O
if	O
(	O
(	O
value	long
>	O
1	int
)	O
&&	O
(	O
value	long
&	O
1	int
)	O
)	O
round_up	int
=	O
TRUE	int
;	O
}	O
while	O
(	O
value	long
>>=	O
1	int
)	O
;	O
if	O
(	O
round_up	int
)	O
result	struct
+=	O
1	int
;	O
expld	struct
.	O
result	struct
.	O
section	pointer
=	O
NULL	O
;	O
expld	struct
.	O
result	struct
.	O
value	long
=	O
result	struct
;	O
}	O
static	O
void	O
make_abs	function
(	O
void	O
)	O
{	O
if	O
(	O
expld	struct
.	O
result	struct
.	O
section	pointer
!=	O
NULL	O
)	O
expld	struct
.	O
result	struct
.	O
value	long
+=	O
expld	struct
.	O
result	struct
.	O
section	pointer
->	O
vma	long
;	O
expld	struct
.	O
result	struct
.	O
section	pointer
=	O
bfd_abs_section_ptr	O
;	O
expld	struct
.	O
rel_from_abs	int
=	O
FALSE	int
;	O
}	O
static	O
void	O
new_abs	function
(	O
bfd_vma	long
value	long
)	O
{	O
expld	struct
.	O
result	struct
.	O
valid_p	int
=	O
TRUE	int
;	O
expld	struct
.	O
result	struct
.	O
section	pointer
=	O
bfd_abs_section_ptr	O
;	O
expld	struct
.	O
result	struct
.	O
value	long
=	O
value	long
;	O
expld	struct
.	O
result	struct
.	O
str	pointer
=	O
NULL	O
;	O
}	O
etree_type	union
*	O
exp_intop	function
(	O
bfd_vma	long
value	long
)	O
{	O
etree_type	union
*	O
new_e	pointer
=	O
stat_alloc	function
(	O
sizeof	O
(	O
new_e	pointer
->	O
value	long
)	O
)	O
;	O
new_e	pointer
->	O
type	enum
.	O
node_code	int
=	O
INT	int
;	O
new_e	pointer
->	O
type	enum
.	O
filename	pointer
=	O
ldlex_filename	function
(	O
)	O
;	O
new_e	pointer
->	O
type	enum
.	O
lineno	pointer
=	O
lineno	pointer
;	O
new_e	pointer
->	O
value	long
.	O
value	long
=	O
value	long
;	O
new_e	pointer
->	O
value	long
.	O
str	pointer
=	O
NULL	O
;	O
new_e	pointer
->	O
type	enum
.	O
node_class	enum
=	O
etree_value	int
;	O
return	O
new_e	pointer
;	O
}	O
etree_type	union
*	O
exp_bigintop	function
(	O
bfd_vma	long
value	long
,	O
char	O
*	O
str	pointer
)	O
{	O
etree_type	union
*	O
new_e	pointer
=	O
stat_alloc	function
(	O
sizeof	O
(	O
new_e	pointer
->	O
value	long
)	O
)	O
;	O
new_e	pointer
->	O
type	enum
.	O
node_code	int
=	O
INT	int
;	O
new_e	pointer
->	O
type	enum
.	O
filename	pointer
=	O
ldlex_filename	function
(	O
)	O
;	O
new_e	pointer
->	O
type	enum
.	O
lineno	pointer
=	O
lineno	pointer
;	O
new_e	pointer
->	O
value	long
.	O
value	long
=	O
value	long
;	O
new_e	pointer
->	O
value	long
.	O
str	pointer
=	O
str	pointer
;	O
new_e	pointer
->	O
type	enum
.	O
node_class	enum
=	O
etree_value	int
;	O
return	O
new_e	pointer
;	O
}	O
etree_type	union
*	O
exp_relop	function
(	O
asection	struct
*	O
section	pointer
,	O
bfd_vma	long
value	long
)	O
{	O
etree_type	union
*	O
new_e	pointer
=	O
stat_alloc	function
(	O
sizeof	O
(	O
new_e	pointer
->	O
rel	pointer
)	O
)	O
;	O
new_e	pointer
->	O
type	enum
.	O
node_code	int
=	O
REL	int
;	O
new_e	pointer
->	O
type	enum
.	O
filename	pointer
=	O
ldlex_filename	function
(	O
)	O
;	O
new_e	pointer
->	O
type	enum
.	O
lineno	pointer
=	O
lineno	pointer
;	O
new_e	pointer
->	O
type	enum
.	O
node_class	enum
=	O
etree_rel	int
;	O
new_e	pointer
->	O
rel	pointer
.	O
section	pointer
=	O
section	pointer
;	O
new_e	pointer
->	O
rel	pointer
.	O
value	long
=	O
value	long
;	O
return	O
new_e	pointer
;	O
}	O
static	O
void	O
new_number	function
(	O
bfd_vma	long
value	long
)	O
{	O
expld	struct
.	O
result	struct
.	O
valid_p	int
=	O
TRUE	int
;	O
expld	struct
.	O
result	struct
.	O
value	long
=	O
value	long
;	O
expld	struct
.	O
result	struct
.	O
str	pointer
=	O
NULL	O
;	O
expld	struct
.	O
result	struct
.	O
section	pointer
=	O
NULL	O
;	O
}	O
static	O
void	O
new_rel	function
(	O
bfd_vma	long
value	long
,	O
asection	struct
*	O
section	pointer
)	O
{	O
expld	struct
.	O
result	struct
.	O
valid_p	int
=	O
TRUE	int
;	O
expld	struct
.	O
result	struct
.	O
value	long
=	O
value	long
;	O
expld	struct
.	O
result	struct
.	O
str	pointer
=	O
NULL	O
;	O
expld	struct
.	O
result	struct
.	O
section	pointer
=	O
section	pointer
;	O
}	O
static	O
void	O
new_rel_from_abs	function
(	O
bfd_vma	long
value	long
)	O
{	O
asection	struct
*	O
s	pointer
=	O
expld	struct
.	O
section	pointer
;	O
expld	struct
.	O
rel_from_abs	int
=	O
TRUE	int
;	O
expld	struct
.	O
result	struct
.	O
valid_p	int
=	O
TRUE	int
;	O
expld	struct
.	O
result	struct
.	O
value	long
=	O
value	long
-	O
s	pointer
->	O
vma	long
;	O
expld	struct
.	O
result	struct
.	O
str	pointer
=	O
NULL	O
;	O
expld	struct
.	O
result	struct
.	O
section	pointer
=	O
s	pointer
;	O
}	O
static	O
struct	O
bfd_hash_entry	struct
*	O
definedness_newfunc	function
(	O
struct	O
bfd_hash_entry	struct
*	O
entry	pointer
,	O
struct	O
bfd_hash_table	struct
*	O
table	pointer
ATTRIBUTE_UNUSED	O
,	O
const	O
char	O
*	O
name	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
struct	O
definedness_hash_entry	struct
*	O
ret	pointer
=	O
(	O
struct	O
definedness_hash_entry	struct
*	O
)	O
entry	pointer
;	O
if	O
(	O
ret	pointer
==	O
NULL	O
)	O
ret	pointer
=	O
(	O
struct	O
definedness_hash_entry	struct
*	O
)	O
bfd_hash_allocate	function
(	O
table	pointer
,	O
sizeof	O
(	O
struct	O
definedness_hash_entry	struct
)	O
)	O
;	O
if	O
(	O
ret	pointer
==	O
NULL	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: bfd_hash_allocate failed creating symbol %s\n"	pointer
)	O
,	O
name	pointer
)	O
;	O
ret	pointer
->	O
by_object	int
=	O
0	int
;	O
ret	pointer
->	O
iteration	int
=	O
0	int
;	O
return	O
&	O
ret	pointer
->	O
root	struct
;	O
}	O
static	O
struct	O
definedness_hash_entry	struct
*	O
symbol_defined	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
return	O
(	O
(	O
struct	O
definedness_hash_entry	struct
*	O
)	O
bfd_hash_lookup	function
(	O
&	O
definedness_table	struct
,	O
name	pointer
,	O
FALSE	int
,	O
FALSE	int
)	O
)	O
;	O
}	O
static	O
bfd_boolean	int
update_definedness	function
(	O
const	O
char	O
*	O
name	pointer
,	O
struct	O
bfd_link_hash_entry	struct
*	O
h	pointer
)	O
{	O
bfd_boolean	int
ret	pointer
;	O
struct	O
definedness_hash_entry	struct
*	O
defentry	pointer
=	O
(	O
struct	O
definedness_hash_entry	struct
*	O
)	O
bfd_hash_lookup	function
(	O
&	O
definedness_table	struct
,	O
name	pointer
,	O
TRUE	int
,	O
FALSE	int
)	O
;	O
if	O
(	O
defentry	pointer
==	O
NULL	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: bfd_hash_lookup failed creating symbol %s\n"	pointer
)	O
,	O
name	pointer
)	O
;	O
ret	pointer
=	O
TRUE	int
;	O
if	O
(	O
!	O
h	pointer
->	O
ldscript_def	int
&&	O
(	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_defweak	int
||	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_common	int
)	O
)	O
{	O
defentry	pointer
->	O
by_object	int
=	O
1	int
;	O
if	O
(	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_defined	int
&&	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
!=	O
NULL	O
&&	O
!	O
h	pointer
->	O
linker_def	int
)	O
ret	pointer
=	O
FALSE	int
;	O
}	O
defentry	pointer
->	O
iteration	int
=	O
lang_statement_iteration	int
;	O
defentry	pointer
->	O
final_sec	pointer
=	O
bfd_abs_section_ptr	O
;	O
if	O
(	O
expld	struct
.	O
phase	enum
==	O
lang_final_phase_enum	int
&&	O
expld	struct
.	O
rel_from_abs	int
&&	O
expld	struct
.	O
result	struct
.	O
section	pointer
==	O
bfd_abs_section_ptr	O
)	O
defentry	pointer
->	O
final_sec	pointer
=	O
section_for_dot	function
(	O
)	O
;	O
return	O
ret	pointer
;	O
}	O
static	O
void	O
fold_segment_end	function
(	O
seg_align_type	struct
*	O
seg	pointer
)	O
{	O
if	O
(	O
expld	struct
.	O
phase	enum
==	O
lang_first_phase_enum	int
||	O
expld	struct
.	O
section	pointer
!=	O
bfd_abs_section_ptr	O
)	O
{	O
expld	struct
.	O
result	struct
.	O
valid_p	int
=	O
FALSE	int
;	O
}	O
else	O
if	O
(	O
seg	pointer
->	O
phase	enum
==	O
exp_seg_align_seen	int
||	O
seg	pointer
->	O
phase	enum
==	O
exp_seg_relro_seen	int
)	O
{	O
seg	pointer
->	O
phase	enum
=	O
exp_seg_end_seen	int
;	O
seg	pointer
->	O
end	pointer
=	O
expld	struct
.	O
result	struct
.	O
value	long
;	O
}	O
else	O
if	O
(	O
seg	pointer
->	O
phase	enum
==	O
exp_seg_done	int
||	O
seg	pointer
->	O
phase	enum
==	O
exp_seg_adjust	int
||	O
seg	pointer
->	O
phase	enum
==	O
exp_seg_relro_adjust	int
)	O
{	O
}	O
else	O
expld	struct
.	O
result	struct
.	O
valid_p	int
=	O
FALSE	int
;	O
}	O
static	O
void	O
fold_unary	function
(	O
etree_type	union
*	O
tree	pointer
)	O
{	O
exp_fold_tree_1	function
(	O
tree	pointer
->	O
unary	struct
.	O
child	pointer
)	O
;	O
if	O
(	O
expld	struct
.	O
result	struct
.	O
valid_p	int
)	O
{	O
switch	O
(	O
tree	pointer
->	O
type	enum
.	O
node_code	int
)	O
{	O
case	O
ALIGN_K	int
:	O
if	O
(	O
expld	struct
.	O
phase	enum
!=	O
lang_first_phase_enum	int
)	O
new_rel_from_abs	function
(	O
align_n	function
(	O
expld	struct
.	O
dot	long
,	O
expld	struct
.	O
result	struct
.	O
value	long
)	O
)	O
;	O
else	O
expld	struct
.	O
result	struct
.	O
valid_p	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
ABSOLUTE	int
:	O
make_abs	function
(	O
)	O
;	O
break	O
;	O
case	O
LOG2CEIL	int
:	O
make_log2ceil	function
(	O
)	O
;	O
break	O
;	O
case	O
'~'	O
:	O
expld	struct
.	O
result	struct
.	O
value	long
=	O
~	O
expld	struct
.	O
result	struct
.	O
value	long
;	O
break	O
;	O
case	O
'!'	O
:	O
expld	struct
.	O
result	struct
.	O
value	long
=	O
!	O
expld	struct
.	O
result	struct
.	O
value	long
;	O
break	O
;	O
case	O
'-'	O
:	O
expld	struct
.	O
result	struct
.	O
value	long
=	O
-	O
expld	struct
.	O
result	struct
.	O
value	long
;	O
break	O
;	O
case	O
NEXT	int
:	O
if	O
(	O
expld	struct
.	O
phase	enum
!=	O
lang_first_phase_enum	int
)	O
{	O
make_abs	function
(	O
)	O
;	O
expld	struct
.	O
result	struct
.	O
value	long
=	O
align_n	function
(	O
expld	struct
.	O
dot	long
,	O
expld	struct
.	O
result	struct
.	O
value	long
)	O
;	O
}	O
else	O
expld	struct
.	O
result	struct
.	O
valid_p	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
DATA_SEGMENT_END	int
:	O
fold_segment_end	function
(	O
&	O
expld	struct
.	O
dataseg	struct
)	O
;	O
break	O
;	O
default	O
:	O
FAIL	O
(	O
)	O
;	O
break	O
;	O
}	O
}	O
}	O
static	O
void	O
arith_result_section	function
(	O
const	O
etree_value_type	struct
*	O
lhs	pointer
)	O
{	O
if	O
(	O
expld	struct
.	O
result	struct
.	O
section	pointer
==	O
lhs	pointer
->	O
section	pointer
)	O
{	O
if	O
(	O
expld	struct
.	O
section	pointer
==	O
bfd_abs_section_ptr	O
&&	O
!	O
config	struct
.	O
sane_expr	int
)	O
expld	struct
.	O
result	struct
.	O
section	pointer
=	O
bfd_abs_section_ptr	O
;	O
else	O
expld	struct
.	O
result	struct
.	O
section	pointer
=	O
NULL	O
;	O
}	O
}	O
static	O
void	O
fold_segment_align	function
(	O
seg_align_type	struct
*	O
seg	pointer
,	O
etree_value_type	struct
*	O
lhs	pointer
)	O
{	O
seg	pointer
->	O
relro	int
=	O
exp_seg_relro_start	int
;	O
if	O
(	O
expld	struct
.	O
phase	enum
==	O
lang_first_phase_enum	int
||	O
expld	struct
.	O
section	pointer
!=	O
bfd_abs_section_ptr	O
)	O
expld	struct
.	O
result	struct
.	O
valid_p	int
=	O
FALSE	int
;	O
else	O
{	O
bfd_vma	long
maxpage	long
=	O
lhs	pointer
->	O
value	long
;	O
bfd_vma	long
commonpage	long
=	O
expld	struct
.	O
result	struct
.	O
value	long
;	O
expld	struct
.	O
result	struct
.	O
value	long
=	O
align_n	function
(	O
expld	struct
.	O
dot	long
,	O
maxpage	long
)	O
;	O
if	O
(	O
seg	pointer
->	O
phase	enum
==	O
exp_seg_relro_adjust	int
)	O
expld	struct
.	O
result	struct
.	O
value	long
=	O
seg	pointer
->	O
base	int
;	O
else	O
if	O
(	O
seg	pointer
->	O
phase	enum
==	O
exp_seg_adjust	int
)	O
{	O
if	O
(	O
commonpage	long
<	O
maxpage	long
)	O
expld	struct
.	O
result	struct
.	O
value	long
+=	O
(	O
(	O
expld	struct
.	O
dot	long
+	O
commonpage	long
-	O
1	int
)	O
&	O
(	O
maxpage	long
-	O
commonpage	long
)	O
)	O
;	O
}	O
else	O
{	O
expld	struct
.	O
result	struct
.	O
value	long
+=	O
expld	struct
.	O
dot	long
&	O
(	O
maxpage	long
-	O
1	int
)	O
;	O
if	O
(	O
seg	pointer
->	O
phase	enum
==	O
exp_seg_done	int
)	O
{	O
}	O
else	O
if	O
(	O
seg	pointer
->	O
phase	enum
==	O
exp_seg_none	int
)	O
{	O
seg	pointer
->	O
phase	enum
=	O
exp_seg_align_seen	int
;	O
seg	pointer
->	O
base	int
=	O
expld	struct
.	O
result	struct
.	O
value	long
;	O
seg	pointer
->	O
pagesize	long
=	O
commonpage	long
;	O
seg	pointer
->	O
maxpagesize	long
=	O
maxpage	long
;	O
seg	pointer
->	O
relro_end	long
=	O
0	int
;	O
}	O
else	O
expld	struct
.	O
result	struct
.	O
valid_p	int
=	O
FALSE	int
;	O
}	O
}	O
}	O
static	O
void	O
fold_segment_relro_end	function
(	O
seg_align_type	struct
*	O
seg	pointer
,	O
etree_value_type	struct
*	O
lhs	pointer
)	O
{	O
seg	pointer
->	O
relro	int
=	O
exp_seg_relro_end	int
;	O
seg	pointer
->	O
relro_offset	long
=	O
expld	struct
.	O
result	struct
.	O
value	long
;	O
if	O
(	O
expld	struct
.	O
phase	enum
==	O
lang_first_phase_enum	int
||	O
expld	struct
.	O
section	pointer
!=	O
bfd_abs_section_ptr	O
)	O
expld	struct
.	O
result	struct
.	O
valid_p	int
=	O
FALSE	int
;	O
else	O
if	O
(	O
seg	pointer
->	O
phase	enum
==	O
exp_seg_align_seen	int
||	O
seg	pointer
->	O
phase	enum
==	O
exp_seg_adjust	int
||	O
seg	pointer
->	O
phase	enum
==	O
exp_seg_relro_adjust	int
||	O
seg	pointer
->	O
phase	enum
==	O
exp_seg_done	int
)	O
{	O
if	O
(	O
seg	pointer
->	O
phase	enum
==	O
exp_seg_align_seen	int
||	O
seg	pointer
->	O
phase	enum
==	O
exp_seg_relro_adjust	int
)	O
seg	pointer
->	O
relro_end	long
=	O
lhs	pointer
->	O
value	long
+	O
expld	struct
.	O
result	struct
.	O
value	long
;	O
if	O
(	O
seg	pointer
->	O
phase	enum
==	O
exp_seg_relro_adjust	int
&&	O
(	O
seg	pointer
->	O
relro_end	long
&	O
(	O
seg	pointer
->	O
pagesize	long
-	O
1	int
)	O
)	O
)	O
{	O
seg	pointer
->	O
relro_end	long
+=	O
seg	pointer
->	O
pagesize	long
-	O
1	int
;	O
seg	pointer
->	O
relro_end	long
&=	O
~	O
(	O
seg	pointer
->	O
pagesize	long
-	O
1	int
)	O
;	O
expld	struct
.	O
result	struct
.	O
value	long
=	O
seg	pointer
->	O
relro_end	long
-	O
expld	struct
.	O
result	struct
.	O
value	long
;	O
}	O
else	O
expld	struct
.	O
result	struct
.	O
value	long
=	O
lhs	pointer
->	O
value	long
;	O
if	O
(	O
seg	pointer
->	O
phase	enum
==	O
exp_seg_align_seen	int
)	O
seg	pointer
->	O
phase	enum
=	O
exp_seg_relro_seen	int
;	O
}	O
else	O
expld	struct
.	O
result	struct
.	O
valid_p	int
=	O
FALSE	int
;	O
}	O
static	O
void	O
fold_binary	function
(	O
etree_type	union
*	O
tree	pointer
)	O
{	O
etree_value_type	struct
lhs	pointer
;	O
exp_fold_tree_1	function
(	O
tree	pointer
->	O
binary	struct
.	O
lhs	pointer
)	O
;	O
if	O
(	O
expld	struct
.	O
result	struct
.	O
valid_p	int
&&	O
tree	pointer
->	O
type	enum
.	O
node_code	int
==	O
SEGMENT_START	int
)	O
{	O
bfd_vma	long
value	long
=	O
expld	struct
.	O
result	struct
.	O
value	long
;	O
const	O
char	O
*	O
segment_name	pointer
;	O
segment_type	struct
*	O
seg	pointer
;	O
segment_name	pointer
=	O
tree	pointer
->	O
binary	struct
.	O
rhs	pointer
->	O
name	pointer
.	O
name	pointer
;	O
for	O
(	O
seg	pointer
=	O
segments	pointer
;	O
seg	pointer
;	O
seg	pointer
=	O
seg	pointer
->	O
next	pointer
)	O
if	O
(	O
strcmp	function
(	O
seg	pointer
->	O
name	pointer
,	O
segment_name	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
!	O
seg	pointer
->	O
used	int
&&	O
config	struct
.	O
magic_demand_paged	int
&&	O
config	struct
.	O
maxpagesize	long
!=	O
0	int
&&	O
(	O
seg	pointer
->	O
value	long
%	O
config	struct
.	O
maxpagesize	long
)	O
!=	O
0	int
)	O
einfo	pointer
(	O
_	O
(	O
"%P: warning: address of `%s' "	pointer
"isn't multiple of maximum page size\n"	pointer
)	O
,	O
segment_name	pointer
)	O
;	O
seg	pointer
->	O
used	int
=	O
TRUE	int
;	O
value	long
=	O
seg	pointer
->	O
value	long
;	O
break	O
;	O
}	O
new_rel_from_abs	function
(	O
value	long
)	O
;	O
return	O
;	O
}	O
lhs	pointer
=	O
expld	struct
.	O
result	struct
;	O
exp_fold_tree_1	function
(	O
tree	pointer
->	O
binary	struct
.	O
rhs	pointer
)	O
;	O
expld	struct
.	O
result	struct
.	O
valid_p	int
&=	O
lhs	pointer
.	O
valid_p	int
;	O
if	O
(	O
expld	struct
.	O
result	struct
.	O
valid_p	int
)	O
{	O
if	O
(	O
lhs	pointer
.	O
section	pointer
!=	O
expld	struct
.	O
result	struct
.	O
section	pointer
)	O
{	O
if	O
(	O
expld	struct
.	O
result	struct
.	O
section	pointer
!=	O
NULL	O
&&	O
lhs	pointer
.	O
section	pointer
!=	O
NULL	O
)	O
{	O
make_abs	function
(	O
)	O
;	O
lhs	pointer
.	O
value	long
+=	O
lhs	pointer
.	O
section	pointer
->	O
vma	long
;	O
lhs	pointer
.	O
section	pointer
=	O
bfd_abs_section_ptr	O
;	O
}	O
else	O
if	O
(	O
expld	struct
.	O
result	struct
.	O
section	pointer
==	O
NULL	O
)	O
{	O
expld	struct
.	O
result	struct
.	O
section	pointer
=	O
lhs	pointer
.	O
section	pointer
;	O
lhs	pointer
.	O
section	pointer
=	O
NULL	O
;	O
}	O
}	O
switch	O
(	O
tree	pointer
->	O
type	enum
.	O
node_code	int
)	O
{	O
BOP	O
(	O
'+'	O
,	O
+	O
)	O
;	O
BOP	O
(	O
'*'	O
,	O
*	O
)	O
;	O
BOP	O
(	O
'-'	O
,	O
-	O
)	O
;	O
BOP	O
(	O
LSHIFT	int
,	O
<<	O
)	O
;	O
BOP	O
(	O
RSHIFT	int
,	O
>>	O
)	O
;	O
BOP	O
(	O
'&'	O
,	O
&	O
)	O
;	O
BOP	O
(	O
'^'	O
,	O
^	O
)	O
;	O
BOP	O
(	O
'|'	O
,	O
|	O
)	O
;	O
BOPN	O
(	O
EQ	int
,	O
==	O
)	O
;	O
BOPN	O
(	O
NE	int
,	O
!=	O
)	O
;	O
BOPN	O
(	O
'<'	O
,	O
<	O
)	O
;	O
BOPN	O
(	O
'>'	O
,	O
>	O
)	O
;	O
BOPN	O
(	O
LE	int
,	O
<=	O
)	O
;	O
BOPN	O
(	O
GE	int
,	O
>=	O
)	O
;	O
BOPN	O
(	O
ANDAND	int
,	O
&&	O
)	O
;	O
BOPN	O
(	O
OROR	int
,	O
||	O
)	O
;	O
case	O
'%'	O
:	O
if	O
(	O
expld	struct
.	O
result	struct
.	O
value	long
!=	O
0	int
)	O
expld	struct
.	O
result	struct
.	O
value	long
=	O
(	O
(	O
bfd_signed_vma	long
)	O
lhs	pointer
.	O
value	long
%	O
(	O
bfd_signed_vma	long
)	O
expld	struct
.	O
result	struct
.	O
value	long
)	O
;	O
else	O
if	O
(	O
expld	struct
.	O
phase	enum
!=	O
lang_mark_phase_enum	int
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P:%pS %% by zero\n"	pointer
)	O
,	O
tree	pointer
->	O
binary	struct
.	O
rhs	pointer
)	O
;	O
arith_result_section	function
(	O
&	O
lhs	pointer
)	O
;	O
break	O
;	O
case	O
'/'	O
:	O
if	O
(	O
expld	struct
.	O
result	struct
.	O
value	long
!=	O
0	int
)	O
expld	struct
.	O
result	struct
.	O
value	long
=	O
(	O
(	O
bfd_signed_vma	long
)	O
lhs	pointer
.	O
value	long
/	O
(	O
bfd_signed_vma	long
)	O
expld	struct
.	O
result	struct
.	O
value	long
)	O
;	O
else	O
if	O
(	O
expld	struct
.	O
phase	enum
!=	O
lang_mark_phase_enum	int
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P:%pS / by zero\n"	pointer
)	O
,	O
tree	pointer
->	O
binary	struct
.	O
rhs	pointer
)	O
;	O
arith_result_section	function
(	O
&	O
lhs	pointer
)	O
;	O
break	O
;	O
case	O
MAX_K	int
:	O
if	O
(	O
lhs	pointer
.	O
value	long
>	O
expld	struct
.	O
result	struct
.	O
value	long
)	O
expld	struct
.	O
result	struct
.	O
value	long
=	O
lhs	pointer
.	O
value	long
;	O
break	O
;	O
case	O
MIN_K	int
:	O
if	O
(	O
lhs	pointer
.	O
value	long
<	O
expld	struct
.	O
result	struct
.	O
value	long
)	O
expld	struct
.	O
result	struct
.	O
value	long
=	O
lhs	pointer
.	O
value	long
;	O
break	O
;	O
case	O
ALIGN_K	int
:	O
expld	struct
.	O
result	struct
.	O
value	long
=	O
align_n	function
(	O
lhs	pointer
.	O
value	long
,	O
expld	struct
.	O
result	struct
.	O
value	long
)	O
;	O
break	O
;	O
case	O
DATA_SEGMENT_ALIGN	int
:	O
fold_segment_align	function
(	O
&	O
expld	struct
.	O
dataseg	struct
,	O
&	O
lhs	pointer
)	O
;	O
break	O
;	O
case	O
DATA_SEGMENT_RELRO_END	int
:	O
fold_segment_relro_end	function
(	O
&	O
expld	struct
.	O
dataseg	struct
,	O
&	O
lhs	pointer
)	O
;	O
break	O
;	O
default	O
:	O
FAIL	O
(	O
)	O
;	O
}	O
}	O
}	O
static	O
void	O
fold_trinary	function
(	O
etree_type	union
*	O
tree	pointer
)	O
{	O
struct	O
bfd_link_hash_entry	struct
*	O
save	pointer
=	O
expld	struct
.	O
assign_src	pointer
;	O
exp_fold_tree_1	function
(	O
tree	pointer
->	O
trinary	struct
.	O
cond	pointer
)	O
;	O
expld	struct
.	O
assign_src	pointer
=	O
save	pointer
;	O
if	O
(	O
expld	struct
.	O
result	struct
.	O
valid_p	int
)	O
exp_fold_tree_1	function
(	O
expld	struct
.	O
result	struct
.	O
value	long
?	O
tree	pointer
->	O
trinary	struct
.	O
lhs	pointer
:	O
tree	pointer
->	O
trinary	struct
.	O
rhs	pointer
)	O
;	O
}	O
static	O
void	O
fold_name	function
(	O
etree_type	union
*	O
tree	pointer
)	O
{	O
struct	O
bfd_link_hash_entry	struct
*	O
h	pointer
;	O
struct	O
definedness_hash_entry	struct
*	O
def	struct
;	O
memset	function
(	O
&	O
expld	struct
.	O
result	struct
,	O
0	int
,	O
sizeof	O
(	O
expld	struct
.	O
result	struct
)	O
)	O
;	O
switch	O
(	O
tree	pointer
->	O
type	enum
.	O
node_code	int
)	O
{	O
case	O
SIZEOF_HEADERS	int
:	O
link_info	struct
.	O
load_phdrs	int
=	O
1	int
;	O
if	O
(	O
expld	struct
.	O
phase	enum
!=	O
lang_first_phase_enum	int
)	O
{	O
bfd_vma	long
hdr_size	long
=	O
0	int
;	O
if	O
(	O
expld	struct
.	O
phase	enum
!=	O
lang_mark_phase_enum	int
)	O
hdr_size	long
=	O
bfd_sizeof_headers	O
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
&	O
link_info	struct
)	O
;	O
new_number	function
(	O
hdr_size	long
)	O
;	O
}	O
break	O
;	O
case	O
DEFINED	int
:	O
h	pointer
=	O
bfd_wrapped_link_hash_lookup	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
&	O
link_info	struct
,	O
tree	pointer
->	O
name	pointer
.	O
name	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
;	O
new_number	function
(	O
h	pointer
!=	O
NULL	O
&&	O
(	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_defweak	int
||	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_common	int
)	O
&&	O
(	O
!	O
h	pointer
->	O
ldscript_def	int
||	O
(	O
def	struct
=	O
symbol_defined	function
(	O
tree	pointer
->	O
name	pointer
.	O
name	pointer
)	O
)	O
==	O
NULL	O
||	O
def	struct
->	O
by_object	int
||	O
def	struct
->	O
iteration	int
==	O
(	O
lang_statement_iteration	int
&	O
255	int
)	O
)	O
)	O
;	O
break	O
;	O
case	O
NAME	int
:	O
if	O
(	O
tree	pointer
->	O
name	pointer
.	O
name	pointer
[	O
0	int
]	O
==	O
'.'	O
&&	O
tree	pointer
->	O
name	pointer
.	O
name	pointer
[	O
1	int
]	O
==	O
0	int
)	O
new_rel_from_abs	function
(	O
expld	struct
.	O
dot	long
)	O
;	O
else	O
{	O
h	pointer
=	O
bfd_wrapped_link_hash_lookup	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
&	O
link_info	struct
,	O
tree	pointer
->	O
name	pointer
.	O
name	pointer
,	O
TRUE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
;	O
if	O
(	O
!	O
h	pointer
)	O
{	O
if	O
(	O
expld	struct
.	O
phase	enum
!=	O
lang_first_phase_enum	int
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: bfd_link_hash_lookup failed: %E\n"	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
{	O
asection	struct
*	O
output_section	pointer
;	O
output_section	pointer
=	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
;	O
if	O
(	O
output_section	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
expld	struct
.	O
phase	enum
<=	O
lang_mark_phase_enum	int
)	O
new_rel	function
(	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
value	long
,	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
)	O
;	O
else	O
einfo	pointer
(	O
_	O
(	O
"%X%P:%pS: unresolvable symbol `%s'"	pointer
" referenced in expression\n"	pointer
)	O
,	O
tree	pointer
,	O
tree	pointer
->	O
name	pointer
.	O
name	pointer
)	O
;	O
}	O
else	O
if	O
(	O
output_section	pointer
==	O
bfd_abs_section_ptr	O
&&	O
(	O
expld	struct
.	O
section	pointer
!=	O
bfd_abs_section_ptr	O
||	O
config	struct
.	O
sane_expr	int
)	O
)	O
new_number	function
(	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
value	long
+	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_offset	long
)	O
;	O
else	O
new_rel	function
(	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
value	long
+	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_offset	long
,	O
output_section	pointer
)	O
;	O
}	O
else	O
if	O
(	O
expld	struct
.	O
phase	enum
==	O
lang_final_phase_enum	int
||	O
(	O
expld	struct
.	O
phase	enum
!=	O
lang_mark_phase_enum	int
&&	O
expld	struct
.	O
assigning_to_dot	int
)	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P:%pS: undefined symbol `%s'"	pointer
" referenced in expression\n"	pointer
)	O
,	O
tree	pointer
,	O
tree	pointer
->	O
name	pointer
.	O
name	pointer
)	O
;	O
else	O
if	O
(	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_new	int
)	O
{	O
h	pointer
->	O
type	enum
=	O
bfd_link_hash_undefined	int
;	O
h	pointer
->	O
u	union
.	O
undef	struct
.	O
abfd	pointer
=	O
NULL	O
;	O
if	O
(	O
h	pointer
->	O
u	union
.	O
undef	struct
.	O
next	pointer
==	O
NULL	O
&&	O
h	pointer
!=	O
link_info	struct
.	O
hash	long
->	O
undefs_tail	pointer
)	O
bfd_link_add_undef	function
(	O
link_info	struct
.	O
hash	long
,	O
h	pointer
)	O
;	O
}	O
if	O
(	O
expld	struct
.	O
assign_src	pointer
==	O
NULL	O
)	O
expld	struct
.	O
assign_src	pointer
=	O
h	pointer
;	O
else	O
expld	struct
.	O
assign_src	pointer
=	O
(	O
struct	O
bfd_link_hash_entry	struct
*	O
)	O
-	O
1	int
;	O
if	O
(	O
expld	struct
.	O
assign_name	pointer
!=	O
NULL	O
&&	O
strcmp	function
(	O
expld	struct
.	O
assign_name	pointer
,	O
tree	pointer
->	O
name	pointer
.	O
name	pointer
)	O
==	O
0	int
&&	O
!	O
(	O
h	pointer
!=	O
NULL	O
&&	O
(	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
&&	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
==	O
bfd_abs_section_ptr	O
&&	O
(	O
def	struct
=	O
symbol_defined	function
(	O
tree	pointer
->	O
name	pointer
.	O
name	pointer
)	O
)	O
!=	O
NULL	O
&&	O
def	struct
->	O
iteration	int
==	O
(	O
lang_statement_iteration	int
&	O
255	int
)	O
)	O
)	O
expld	struct
.	O
assign_name	pointer
=	O
NULL	O
;	O
}	O
break	O
;	O
case	O
ADDR	int
:	O
if	O
(	O
expld	struct
.	O
phase	enum
!=	O
lang_first_phase_enum	int
)	O
{	O
lang_output_section_statement_type	struct
*	O
os	int
;	O
os	int
=	O
lang_output_section_find	O
(	O
tree	pointer
->	O
name	pointer
.	O
name	pointer
)	O
;	O
if	O
(	O
os	int
==	O
NULL	O
)	O
{	O
if	O
(	O
expld	struct
.	O
phase	enum
==	O
lang_final_phase_enum	int
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P:%pS: undefined section `%s'"	pointer
" referenced in expression\n"	pointer
)	O
,	O
tree	pointer
,	O
tree	pointer
->	O
name	pointer
.	O
name	pointer
)	O
;	O
}	O
else	O
if	O
(	O
os	int
->	O
processed_vma	int
)	O
new_rel	function
(	O
0	int
,	O
os	int
->	O
bfd_section	struct
)	O
;	O
}	O
break	O
;	O
case	O
LOADADDR	int
:	O
if	O
(	O
expld	struct
.	O
phase	enum
!=	O
lang_first_phase_enum	int
)	O
{	O
lang_output_section_statement_type	struct
*	O
os	int
;	O
os	int
=	O
lang_output_section_find	O
(	O
tree	pointer
->	O
name	pointer
.	O
name	pointer
)	O
;	O
if	O
(	O
os	int
==	O
NULL	O
)	O
{	O
if	O
(	O
expld	struct
.	O
phase	enum
==	O
lang_final_phase_enum	int
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P:%pS: undefined section `%s'"	pointer
" referenced in expression\n"	pointer
)	O
,	O
tree	pointer
,	O
tree	pointer
->	O
name	pointer
.	O
name	pointer
)	O
;	O
}	O
else	O
if	O
(	O
os	int
->	O
processed_lma	int
)	O
{	O
if	O
(	O
os	int
->	O
load_base	pointer
==	O
NULL	O
)	O
new_abs	function
(	O
os	int
->	O
bfd_section	struct
->	O
lma	long
)	O
;	O
else	O
{	O
exp_fold_tree_1	function
(	O
os	int
->	O
load_base	pointer
)	O
;	O
if	O
(	O
expld	struct
.	O
result	struct
.	O
valid_p	int
)	O
make_abs	function
(	O
)	O
;	O
}	O
}	O
}	O
break	O
;	O
case	O
SIZEOF	int
:	O
case	O
ALIGNOF	int
:	O
if	O
(	O
expld	struct
.	O
phase	enum
!=	O
lang_first_phase_enum	int
)	O
{	O
lang_output_section_statement_type	struct
*	O
os	int
;	O
os	int
=	O
lang_output_section_find	O
(	O
tree	pointer
->	O
name	pointer
.	O
name	pointer
)	O
;	O
if	O
(	O
os	int
==	O
NULL	O
)	O
{	O
if	O
(	O
expld	struct
.	O
phase	enum
==	O
lang_final_phase_enum	int
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P:%pS: undefined section `%s'"	pointer
" referenced in expression\n"	pointer
)	O
,	O
tree	pointer
,	O
tree	pointer
->	O
name	pointer
.	O
name	pointer
)	O
;	O
new_number	function
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
os	int
->	O
bfd_section	struct
!=	O
NULL	O
)	O
{	O
bfd_vma	long
val	array
;	O
if	O
(	O
tree	pointer
->	O
type	enum
.	O
node_code	int
==	O
SIZEOF	int
)	O
val	array
=	O
(	O
os	int
->	O
bfd_section	struct
->	O
size	int
/	O
bfd_octets_per_byte	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
os	int
->	O
bfd_section	struct
)	O
)	O
;	O
else	O
val	array
=	O
(	O
bfd_vma	long
)	O
1	int
<<	O
os	int
->	O
bfd_section	struct
->	O
alignment_power	int
;	O
new_number	function
(	O
val	array
)	O
;	O
}	O
else	O
new_number	function
(	O
0	int
)	O
;	O
}	O
break	O
;	O
case	O
LENGTH	int
:	O
{	O
lang_memory_region_type	struct
*	O
mem	pointer
;	O
mem	pointer
=	O
lang_memory_region_lookup	function
(	O
tree	pointer
->	O
name	pointer
.	O
name	pointer
,	O
FALSE	int
)	O
;	O
if	O
(	O
mem	pointer
!=	O
NULL	O
)	O
new_number	function
(	O
mem	pointer
->	O
length	long
)	O
;	O
else	O
einfo	pointer
(	O
_	O
(	O
"%F%P:%pS: undefined MEMORY region `%s'"	pointer
" referenced in expression\n"	pointer
)	O
,	O
tree	pointer
,	O
tree	pointer
->	O
name	pointer
.	O
name	pointer
)	O
;	O
}	O
break	O
;	O
case	O
ORIGIN	int
:	O
{	O
lang_memory_region_type	struct
*	O
mem	pointer
;	O
mem	pointer
=	O
lang_memory_region_lookup	function
(	O
tree	pointer
->	O
name	pointer
.	O
name	pointer
,	O
FALSE	int
)	O
;	O
if	O
(	O
mem	pointer
!=	O
NULL	O
)	O
new_rel_from_abs	function
(	O
mem	pointer
->	O
origin	long
)	O
;	O
else	O
einfo	pointer
(	O
_	O
(	O
"%F%P:%pS: undefined MEMORY region `%s'"	pointer
" referenced in expression\n"	pointer
)	O
,	O
tree	pointer
,	O
tree	pointer
->	O
name	pointer
.	O
name	pointer
)	O
;	O
}	O
break	O
;	O
case	O
CONSTANT	int
:	O
if	O
(	O
strcmp	function
(	O
tree	pointer
->	O
name	pointer
.	O
name	pointer
,	O
"MAXPAGESIZE"	pointer
)	O
==	O
0	int
)	O
new_number	function
(	O
config	struct
.	O
maxpagesize	long
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
tree	pointer
->	O
name	pointer
.	O
name	pointer
,	O
"COMMONPAGESIZE"	pointer
)	O
==	O
0	int
)	O
new_number	function
(	O
config	struct
.	O
commonpagesize	long
)	O
;	O
else	O
einfo	pointer
(	O
_	O
(	O
"%F%P:%pS: unknown constant `%s' referenced in expression\n"	pointer
)	O
,	O
tree	pointer
,	O
tree	pointer
->	O
name	pointer
.	O
name	pointer
)	O
;	O
break	O
;	O
default	O
:	O
FAIL	O
(	O
)	O
;	O
break	O
;	O
}	O
}	O
static	O
bfd_boolean	int
is_dot	function
(	O
const	O
etree_type	union
*	O
tree	pointer
)	O
{	O
return	O
(	O
tree	pointer
->	O
type	enum
.	O
node_class	enum
==	O
etree_name	int
&&	O
tree	pointer
->	O
type	enum
.	O
node_code	int
==	O
NAME	int
&&	O
tree	pointer
->	O
name	pointer
.	O
name	pointer
[	O
0	int
]	O
==	O
'.'	O
&&	O
tree	pointer
->	O
name	pointer
.	O
name	pointer
[	O
1	int
]	O
==	O
0	int
)	O
;	O
}	O
static	O
bfd_boolean	int
is_value	function
(	O
const	O
etree_type	union
*	O
tree	pointer
,	O
bfd_vma	long
val	array
)	O
{	O
return	O
(	O
tree	pointer
->	O
type	enum
.	O
node_class	enum
==	O
etree_value	int
&&	O
tree	pointer
->	O
value	long
.	O
value	long
==	O
val	array
)	O
;	O
}	O
static	O
bfd_boolean	int
is_sym_value	function
(	O
const	O
etree_type	union
*	O
tree	pointer
,	O
bfd_vma	long
val	array
)	O
{	O
struct	O
bfd_link_hash_entry	struct
*	O
h	pointer
;	O
struct	O
definedness_hash_entry	struct
*	O
def	struct
;	O
return	O
(	O
tree	pointer
->	O
type	enum
.	O
node_class	enum
==	O
etree_name	int
&&	O
tree	pointer
->	O
type	enum
.	O
node_code	int
==	O
NAME	int
&&	O
(	O
def	struct
=	O
symbol_defined	function
(	O
tree	pointer
->	O
name	pointer
.	O
name	pointer
)	O
)	O
!=	O
NULL	O
&&	O
def	struct
->	O
iteration	int
==	O
(	O
lang_statement_iteration	int
&	O
255	int
)	O
&&	O
(	O
h	pointer
=	O
bfd_wrapped_link_hash_lookup	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
&	O
link_info	struct
,	O
tree	pointer
->	O
name	pointer
.	O
name	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
)	O
!=	O
NULL	O
&&	O
h	pointer
->	O
ldscript_def	int
&&	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_defined	int
&&	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
==	O
bfd_abs_section_ptr	O
&&	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
value	long
==	O
val	array
)	O
;	O
}	O
static	O
bfd_boolean	int
is_dot_ne_0	function
(	O
const	O
etree_type	union
*	O
tree	pointer
)	O
{	O
return	O
(	O
tree	pointer
->	O
type	enum
.	O
node_class	enum
==	O
etree_binary	int
&&	O
tree	pointer
->	O
type	enum
.	O
node_code	int
==	O
NE	int
&&	O
is_dot	function
(	O
tree	pointer
->	O
binary	struct
.	O
lhs	pointer
)	O
&&	O
is_value	function
(	O
tree	pointer
->	O
binary	struct
.	O
rhs	pointer
,	O
0	int
)	O
)	O
;	O
}	O
static	O
bfd_boolean	int
is_dot_plus_0	function
(	O
const	O
etree_type	union
*	O
tree	pointer
)	O
{	O
return	O
(	O
tree	pointer
->	O
type	enum
.	O
node_class	enum
==	O
etree_binary	int
&&	O
tree	pointer
->	O
type	enum
.	O
node_code	int
==	O
'+'	O
&&	O
is_dot	function
(	O
tree	pointer
->	O
binary	struct
.	O
lhs	pointer
)	O
&&	O
(	O
is_value	function
(	O
tree	pointer
->	O
binary	struct
.	O
rhs	pointer
,	O
0	int
)	O
||	O
is_sym_value	function
(	O
tree	pointer
->	O
binary	struct
.	O
rhs	pointer
,	O
0	int
)	O
)	O
)	O
;	O
}	O
static	O
bfd_boolean	int
is_align_conditional	function
(	O
const	O
etree_type	union
*	O
tree	pointer
)	O
{	O
if	O
(	O
tree	pointer
->	O
type	enum
.	O
node_class	enum
==	O
etree_unary	int
&&	O
tree	pointer
->	O
type	enum
.	O
node_code	int
==	O
ALIGN_K	int
)	O
{	O
tree	pointer
=	O
tree	pointer
->	O
unary	struct
.	O
child	pointer
;	O
return	O
(	O
tree	pointer
->	O
type	enum
.	O
node_class	enum
==	O
etree_trinary	int
&&	O
is_dot_ne_0	function
(	O
tree	pointer
->	O
trinary	struct
.	O
cond	pointer
)	O
&&	O
is_value	function
(	O
tree	pointer
->	O
trinary	struct
.	O
rhs	pointer
,	O
1	int
)	O
)	O
;	O
}	O
return	O
FALSE	int
;	O
}	O
static	O
void	O
exp_fold_tree_1	function
(	O
etree_type	union
*	O
tree	pointer
)	O
{	O
if	O
(	O
tree	pointer
==	O
NULL	O
)	O
{	O
memset	function
(	O
&	O
expld	struct
.	O
result	struct
,	O
0	int
,	O
sizeof	O
(	O
expld	struct
.	O
result	struct
)	O
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
tree	pointer
->	O
type	enum
.	O
node_class	enum
)	O
{	O
case	O
etree_value	int
:	O
if	O
(	O
expld	struct
.	O
section	pointer
==	O
bfd_abs_section_ptr	O
&&	O
!	O
config	struct
.	O
sane_expr	int
)	O
new_abs	function
(	O
tree	pointer
->	O
value	long
.	O
value	long
)	O
;	O
else	O
new_number	function
(	O
tree	pointer
->	O
value	long
.	O
value	long
)	O
;	O
expld	struct
.	O
result	struct
.	O
str	pointer
=	O
tree	pointer
->	O
value	long
.	O
str	pointer
;	O
break	O
;	O
case	O
etree_rel	int
:	O
if	O
(	O
expld	struct
.	O
phase	enum
!=	O
lang_first_phase_enum	int
)	O
{	O
asection	struct
*	O
output_section	pointer
=	O
tree	pointer
->	O
rel	pointer
.	O
section	pointer
->	O
output_section	pointer
;	O
new_rel	function
(	O
tree	pointer
->	O
rel	pointer
.	O
value	long
+	O
tree	pointer
->	O
rel	pointer
.	O
section	pointer
->	O
output_offset	long
,	O
output_section	pointer
)	O
;	O
}	O
else	O
memset	function
(	O
&	O
expld	struct
.	O
result	struct
,	O
0	int
,	O
sizeof	O
(	O
expld	struct
.	O
result	struct
)	O
)	O
;	O
break	O
;	O
case	O
etree_assert	int
:	O
exp_fold_tree_1	function
(	O
tree	pointer
->	O
assert_s	struct
.	O
child	pointer
)	O
;	O
if	O
(	O
expld	struct
.	O
phase	enum
==	O
lang_final_phase_enum	int
&&	O
!	O
expld	struct
.	O
result	struct
.	O
value	long
)	O
einfo	pointer
(	O
"%X%P: %s\n"	pointer
,	O
tree	pointer
->	O
assert_s	struct
.	O
message	pointer
)	O
;	O
break	O
;	O
case	O
etree_unary	int
:	O
fold_unary	function
(	O
tree	pointer
)	O
;	O
break	O
;	O
case	O
etree_binary	int
:	O
fold_binary	function
(	O
tree	pointer
)	O
;	O
break	O
;	O
case	O
etree_trinary	int
:	O
fold_trinary	function
(	O
tree	pointer
)	O
;	O
break	O
;	O
case	O
etree_assign	int
:	O
case	O
etree_provide	int
:	O
case	O
etree_provided	int
:	O
if	O
(	O
tree	pointer
->	O
assign	struct
.	O
dst	pointer
[	O
0	int
]	O
==	O
'.'	O
&&	O
tree	pointer
->	O
assign	struct
.	O
dst	pointer
[	O
1	int
]	O
==	O
0	int
)	O
{	O
if	O
(	O
tree	pointer
->	O
type	enum
.	O
node_class	enum
!=	O
etree_assign	int
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P:%pS can not PROVIDE assignment to"	pointer
" location counter\n"	pointer
)	O
,	O
tree	pointer
)	O
;	O
if	O
(	O
expld	struct
.	O
phase	enum
!=	O
lang_first_phase_enum	int
)	O
{	O
expld	struct
.	O
assigning_to_dot	int
=	O
TRUE	int
;	O
exp_fold_tree_1	function
(	O
tree	pointer
->	O
assign	struct
.	O
src	pointer
)	O
;	O
expld	struct
.	O
assigning_to_dot	int
=	O
FALSE	int
;	O
if	O
(	O
expld	struct
.	O
phase	enum
==	O
lang_mark_phase_enum	int
&&	O
expld	struct
.	O
section	pointer
!=	O
bfd_abs_section_ptr	O
&&	O
expld	struct
.	O
section	pointer
!=	O
bfd_und_section_ptr	O
&&	O
!	O
(	O
expld	struct
.	O
result	struct
.	O
valid_p	int
&&	O
expld	struct
.	O
result	struct
.	O
value	long
==	O
0	int
&&	O
(	O
is_value	function
(	O
tree	pointer
->	O
assign	struct
.	O
src	pointer
,	O
0	int
)	O
||	O
is_sym_value	function
(	O
tree	pointer
->	O
assign	struct
.	O
src	pointer
,	O
0	int
)	O
||	O
is_dot_plus_0	function
(	O
tree	pointer
->	O
assign	struct
.	O
src	pointer
)	O
||	O
is_align_conditional	function
(	O
tree	pointer
->	O
assign	struct
.	O
src	pointer
)	O
)	O
)	O
)	O
expld	struct
.	O
section	pointer
->	O
flags	int
|=	O
SEC_KEEP	int
;	O
if	O
(	O
!	O
expld	struct
.	O
result	struct
.	O
valid_p	int
||	O
expld	struct
.	O
section	pointer
==	O
bfd_und_section_ptr	O
)	O
{	O
if	O
(	O
expld	struct
.	O
phase	enum
!=	O
lang_mark_phase_enum	int
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P:%pS invalid assignment to"	pointer
" location counter\n"	pointer
)	O
,	O
tree	pointer
)	O
;	O
}	O
else	O
if	O
(	O
expld	struct
.	O
dotp	pointer
==	O
NULL	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P:%pS assignment to location counter"	pointer
" invalid outside of SECTIONS\n"	pointer
)	O
,	O
tree	pointer
)	O
;	O
else	O
if	O
(	O
expld	struct
.	O
phase	enum
<=	O
lang_allocating_phase_enum	int
||	O
expld	struct
.	O
section	pointer
==	O
bfd_abs_section_ptr	O
)	O
{	O
bfd_vma	long
nextdot	long
;	O
nextdot	long
=	O
expld	struct
.	O
result	struct
.	O
value	long
;	O
if	O
(	O
expld	struct
.	O
result	struct
.	O
section	pointer
!=	O
NULL	O
)	O
nextdot	long
+=	O
expld	struct
.	O
result	struct
.	O
section	pointer
->	O
vma	long
;	O
else	O
nextdot	long
+=	O
expld	struct
.	O
section	pointer
->	O
vma	long
;	O
if	O
(	O
nextdot	long
<	O
expld	struct
.	O
dot	long
&&	O
expld	struct
.	O
section	pointer
!=	O
bfd_abs_section_ptr	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P:%pS cannot move location counter backwards"	pointer
" (from %V to %V)\n"	pointer
)	O
,	O
tree	pointer
,	O
expld	struct
.	O
dot	long
,	O
nextdot	long
)	O
;	O
else	O
{	O
expld	struct
.	O
dot	long
=	O
nextdot	long
;	O
*	O
expld	struct
.	O
dotp	pointer
=	O
nextdot	long
;	O
}	O
}	O
}	O
else	O
memset	function
(	O
&	O
expld	struct
.	O
result	struct
,	O
0	int
,	O
sizeof	O
(	O
expld	struct
.	O
result	struct
)	O
)	O
;	O
}	O
else	O
{	O
struct	O
bfd_link_hash_entry	struct
*	O
h	pointer
=	O
NULL	O
;	O
if	O
(	O
tree	pointer
->	O
type	enum
.	O
node_class	enum
==	O
etree_provide	int
)	O
{	O
h	pointer
=	O
bfd_link_hash_lookup	function
(	O
link_info	struct
.	O
hash	long
,	O
tree	pointer
->	O
assign	struct
.	O
dst	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
;	O
if	O
(	O
h	pointer
==	O
NULL	O
||	O
!	O
(	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_new	int
||	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_undefined	int
||	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_undefweak	int
||	O
h	pointer
->	O
linker_def	int
)	O
)	O
{	O
break	O
;	O
}	O
}	O
expld	struct
.	O
assign_name	pointer
=	O
tree	pointer
->	O
assign	struct
.	O
dst	pointer
;	O
expld	struct
.	O
assign_src	pointer
=	O
NULL	O
;	O
exp_fold_tree_1	function
(	O
tree	pointer
->	O
assign	struct
.	O
src	pointer
)	O
;	O
if	O
(	O
expld	struct
.	O
phase	enum
==	O
lang_final_phase_enum	int
||	O
expld	struct
.	O
phase	enum
==	O
lang_fixed_phase_enum	int
||	O
expld	struct
.	O
assign_name	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
tree	pointer
->	O
type	enum
.	O
node_class	enum
==	O
etree_provide	int
)	O
tree	pointer
->	O
type	enum
.	O
node_class	enum
=	O
etree_provided	int
;	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
{	O
h	pointer
=	O
bfd_link_hash_lookup	function
(	O
link_info	struct
.	O
hash	long
,	O
tree	pointer
->	O
assign	struct
.	O
dst	pointer
,	O
TRUE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
;	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P:%s: hash creation failed\n"	pointer
)	O
,	O
tree	pointer
->	O
assign	struct
.	O
dst	pointer
)	O
;	O
}	O
if	O
(	O
!	O
expld	struct
.	O
result	struct
.	O
valid_p	int
&&	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_new	int
)	O
{	O
expld	struct
.	O
result	struct
.	O
value	long
=	O
0	int
;	O
expld	struct
.	O
result	struct
.	O
section	pointer
=	O
NULL	O
;	O
expld	struct
.	O
result	struct
.	O
valid_p	int
=	O
TRUE	int
;	O
}	O
if	O
(	O
expld	struct
.	O
result	struct
.	O
valid_p	int
)	O
{	O
if	O
(	O
expld	struct
.	O
result	struct
.	O
section	pointer
==	O
NULL	O
)	O
expld	struct
.	O
result	struct
.	O
section	pointer
=	O
expld	struct
.	O
section	pointer
;	O
if	O
(	O
!	O
update_definedness	function
(	O
tree	pointer
->	O
assign	struct
.	O
dst	pointer
,	O
h	pointer
)	O
&&	O
0	int
)	O
{	O
(	O
*	O
link_info	struct
.	O
callbacks	pointer
->	O
multiple_definition	pointer
)	O
(	O
&	O
link_info	struct
,	O
h	pointer
,	O
link_info	struct
.	O
output_bfd	pointer
,	O
expld	struct
.	O
result	struct
.	O
section	pointer
,	O
expld	struct
.	O
result	struct
.	O
value	long
)	O
;	O
}	O
if	O
(	O
expld	struct
.	O
phase	enum
==	O
lang_fixed_phase_enum	int
)	O
{	O
if	O
(	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_defined	int
)	O
{	O
expld	struct
.	O
result	struct
.	O
value	long
=	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
value	long
;	O
expld	struct
.	O
result	struct
.	O
section	pointer
=	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
;	O
}	O
}	O
else	O
{	O
h	pointer
->	O
type	enum
=	O
bfd_link_hash_defined	int
;	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
value	long
=	O
expld	struct
.	O
result	struct
.	O
value	long
;	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
=	O
expld	struct
.	O
result	struct
.	O
section	pointer
;	O
h	pointer
->	O
linker_def	int
=	O
!	O
tree	pointer
->	O
assign	struct
.	O
type	enum
.	O
lineno	pointer
;	O
h	pointer
->	O
ldscript_def	int
=	O
1	int
;	O
h	pointer
->	O
rel_from_abs	int
=	O
expld	struct
.	O
rel_from_abs	int
;	O
if	O
(	O
tree	pointer
->	O
assign	struct
.	O
hidden	int
)	O
bfd_link_hide_symbol	O
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
&	O
link_info	struct
,	O
h	pointer
)	O
;	O
if	O
(	O
expld	struct
.	O
assign_src	pointer
!=	O
NULL	O
&&	O
(	O
expld	struct
.	O
assign_src	pointer
!=	O
(	O
struct	O
bfd_link_hash_entry	struct
*	O
)	O
-	O
1	int
)	O
)	O
bfd_copy_link_hash_symbol_type	O
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
h	pointer
,	O
expld	struct
.	O
assign_src	pointer
)	O
;	O
}	O
}	O
}	O
if	O
(	O
expld	struct
.	O
phase	enum
!=	O
lang_fixed_phase_enum	int
)	O
expld	struct
.	O
assign_name	pointer
=	O
NULL	O
;	O
}	O
break	O
;	O
case	O
etree_name	int
:	O
fold_name	function
(	O
tree	pointer
)	O
;	O
break	O
;	O
default	O
:	O
FAIL	O
(	O
)	O
;	O
memset	function
(	O
&	O
expld	struct
.	O
result	struct
,	O
0	int
,	O
sizeof	O
(	O
expld	struct
.	O
result	struct
)	O
)	O
;	O
break	O
;	O
}	O
}	O
void	O
exp_fold_tree	function
(	O
etree_type	union
*	O
tree	pointer
,	O
asection	struct
*	O
current_section	pointer
,	O
bfd_vma	long
*	O
dotp	pointer
)	O
{	O
expld	struct
.	O
rel_from_abs	int
=	O
FALSE	int
;	O
expld	struct
.	O
dot	long
=	O
*	O
dotp	pointer
;	O
expld	struct
.	O
dotp	pointer
=	O
dotp	pointer
;	O
expld	struct
.	O
section	pointer
=	O
current_section	pointer
;	O
exp_fold_tree_1	function
(	O
tree	pointer
)	O
;	O
}	O
void	O
exp_fold_tree_no_dot	function
(	O
etree_type	union
*	O
tree	pointer
)	O
{	O
expld	struct
.	O
rel_from_abs	int
=	O
FALSE	int
;	O
expld	struct
.	O
dot	long
=	O
0	int
;	O
expld	struct
.	O
dotp	pointer
=	O
NULL	O
;	O
expld	struct
.	O
section	pointer
=	O
bfd_abs_section_ptr	O
;	O
exp_fold_tree_1	function
(	O
tree	pointer
)	O
;	O
}	O
static	O
void	O
exp_value_fold	function
(	O
etree_type	union
*	O
tree	pointer
)	O
{	O
exp_fold_tree_no_dot	function
(	O
tree	pointer
)	O
;	O
if	O
(	O
expld	struct
.	O
result	struct
.	O
valid_p	int
)	O
{	O
tree	pointer
->	O
type	enum
.	O
node_code	int
=	O
INT	int
;	O
tree	pointer
->	O
value	long
.	O
value	long
=	O
expld	struct
.	O
result	struct
.	O
value	long
;	O
tree	pointer
->	O
value	long
.	O
str	pointer
=	O
NULL	O
;	O
tree	pointer
->	O
type	enum
.	O
node_class	enum
=	O
etree_value	int
;	O
}	O
}	O
etree_type	union
*	O
exp_binop	function
(	O
int	O
code	int
,	O
etree_type	union
*	O
lhs	pointer
,	O
etree_type	union
*	O
rhs	pointer
)	O
{	O
etree_type	union
*	O
new_e	pointer
=	O
stat_alloc	function
(	O
MAX	O
(	O
sizeof	O
(	O
new_e	pointer
->	O
binary	struct
)	O
,	O
sizeof	O
(	O
new_e	pointer
->	O
value	long
)	O
)	O
)	O
;	O
new_e	pointer
->	O
type	enum
.	O
node_code	int
=	O
code	int
;	O
new_e	pointer
->	O
type	enum
.	O
filename	pointer
=	O
lhs	pointer
->	O
type	enum
.	O
filename	pointer
;	O
new_e	pointer
->	O
type	enum
.	O
lineno	pointer
=	O
lhs	pointer
->	O
type	enum
.	O
lineno	pointer
;	O
new_e	pointer
->	O
binary	struct
.	O
lhs	pointer
=	O
lhs	pointer
;	O
new_e	pointer
->	O
binary	struct
.	O
rhs	pointer
=	O
rhs	pointer
;	O
new_e	pointer
->	O
type	enum
.	O
node_class	enum
=	O
etree_binary	int
;	O
if	O
(	O
lhs	pointer
->	O
type	enum
.	O
node_class	enum
==	O
etree_value	int
&&	O
rhs	pointer
->	O
type	enum
.	O
node_class	enum
==	O
etree_value	int
&&	O
code	int
!=	O
ALIGN_K	int
&&	O
code	int
!=	O
DATA_SEGMENT_ALIGN	int
&&	O
code	int
!=	O
DATA_SEGMENT_RELRO_END	int
)	O
exp_value_fold	function
(	O
new_e	pointer
)	O
;	O
return	O
new_e	pointer
;	O
}	O
etree_type	union
*	O
exp_trinop	function
(	O
int	O
code	int
,	O
etree_type	union
*	O
cond	pointer
,	O
etree_type	union
*	O
lhs	pointer
,	O
etree_type	union
*	O
rhs	pointer
)	O
{	O
etree_type	union
*	O
new_e	pointer
=	O
stat_alloc	function
(	O
MAX	O
(	O
sizeof	O
(	O
new_e	pointer
->	O
trinary	struct
)	O
,	O
sizeof	O
(	O
new_e	pointer
->	O
value	long
)	O
)	O
)	O
;	O
new_e	pointer
->	O
type	enum
.	O
node_code	int
=	O
code	int
;	O
new_e	pointer
->	O
type	enum
.	O
filename	pointer
=	O
cond	pointer
->	O
type	enum
.	O
filename	pointer
;	O
new_e	pointer
->	O
type	enum
.	O
lineno	pointer
=	O
cond	pointer
->	O
type	enum
.	O
lineno	pointer
;	O
new_e	pointer
->	O
trinary	struct
.	O
lhs	pointer
=	O
lhs	pointer
;	O
new_e	pointer
->	O
trinary	struct
.	O
cond	pointer
=	O
cond	pointer
;	O
new_e	pointer
->	O
trinary	struct
.	O
rhs	pointer
=	O
rhs	pointer
;	O
new_e	pointer
->	O
type	enum
.	O
node_class	enum
=	O
etree_trinary	int
;	O
if	O
(	O
cond	pointer
->	O
type	enum
.	O
node_class	enum
==	O
etree_value	int
&&	O
lhs	pointer
->	O
type	enum
.	O
node_class	enum
==	O
etree_value	int
&&	O
rhs	pointer
->	O
type	enum
.	O
node_class	enum
==	O
etree_value	int
)	O
exp_value_fold	function
(	O
new_e	pointer
)	O
;	O
return	O
new_e	pointer
;	O
}	O
etree_type	union
*	O
exp_unop	function
(	O
int	O
code	int
,	O
etree_type	union
*	O
child	pointer
)	O
{	O
etree_type	union
*	O
new_e	pointer
=	O
stat_alloc	function
(	O
MAX	O
(	O
sizeof	O
(	O
new_e	pointer
->	O
unary	struct
)	O
,	O
sizeof	O
(	O
new_e	pointer
->	O
value	long
)	O
)	O
)	O
;	O
new_e	pointer
->	O
unary	struct
.	O
type	enum
.	O
node_code	int
=	O
code	int
;	O
new_e	pointer
->	O
unary	struct
.	O
type	enum
.	O
filename	pointer
=	O
child	pointer
->	O
type	enum
.	O
filename	pointer
;	O
new_e	pointer
->	O
unary	struct
.	O
type	enum
.	O
lineno	pointer
=	O
child	pointer
->	O
type	enum
.	O
lineno	pointer
;	O
new_e	pointer
->	O
unary	struct
.	O
child	pointer
=	O
child	pointer
;	O
new_e	pointer
->	O
unary	struct
.	O
type	enum
.	O
node_class	enum
=	O
etree_unary	int
;	O
if	O
(	O
child	pointer
->	O
type	enum
.	O
node_class	enum
==	O
etree_value	int
&&	O
code	int
!=	O
ALIGN_K	int
&&	O
code	int
!=	O
ABSOLUTE	int
&&	O
code	int
!=	O
NEXT	int
&&	O
code	int
!=	O
DATA_SEGMENT_END	int
)	O
exp_value_fold	function
(	O
new_e	pointer
)	O
;	O
return	O
new_e	pointer
;	O
}	O
etree_type	union
*	O
exp_nameop	function
(	O
int	O
code	int
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
etree_type	union
*	O
new_e	pointer
=	O
stat_alloc	function
(	O
sizeof	O
(	O
new_e	pointer
->	O
name	pointer
)	O
)	O
;	O
new_e	pointer
->	O
name	pointer
.	O
type	enum
.	O
node_code	int
=	O
code	int
;	O
new_e	pointer
->	O
name	pointer
.	O
type	enum
.	O
filename	pointer
=	O
ldlex_filename	function
(	O
)	O
;	O
new_e	pointer
->	O
name	pointer
.	O
type	enum
.	O
lineno	pointer
=	O
lineno	pointer
;	O
new_e	pointer
->	O
name	pointer
.	O
name	pointer
=	O
name	pointer
;	O
new_e	pointer
->	O
name	pointer
.	O
type	enum
.	O
node_class	enum
=	O
etree_name	int
;	O
return	O
new_e	pointer
;	O
}	O
static	O
etree_type	union
*	O
exp_assop	function
(	O
const	O
char	O
*	O
dst	pointer
,	O
etree_type	union
*	O
src	pointer
,	O
enum	O
node_tree_enum	enum
class	enum
,	O
bfd_boolean	int
hidden	int
)	O
{	O
etree_type	union
*	O
n	pointer
;	O
n	pointer
=	O
stat_alloc	function
(	O
sizeof	O
(	O
n	pointer
->	O
assign	struct
)	O
)	O
;	O
n	pointer
->	O
assign	struct
.	O
type	enum
.	O
node_code	int
=	O
'='	O
;	O
n	pointer
->	O
assign	struct
.	O
type	enum
.	O
filename	pointer
=	O
src	pointer
->	O
type	enum
.	O
filename	pointer
;	O
n	pointer
->	O
assign	struct
.	O
type	enum
.	O
lineno	pointer
=	O
src	pointer
->	O
type	enum
.	O
lineno	pointer
;	O
n	pointer
->	O
assign	struct
.	O
type	enum
.	O
node_class	enum
=	O
class	enum
;	O
n	pointer
->	O
assign	struct
.	O
src	pointer
=	O
src	pointer
;	O
n	pointer
->	O
assign	struct
.	O
dst	pointer
=	O
dst	pointer
;	O
n	pointer
->	O
assign	struct
.	O
hidden	int
=	O
hidden	int
;	O
return	O
n	pointer
;	O
}	O
etree_type	union
*	O
exp_assign	function
(	O
const	O
char	O
*	O
dst	pointer
,	O
etree_type	union
*	O
src	pointer
,	O
bfd_boolean	int
hidden	int
)	O
{	O
return	O
exp_assop	function
(	O
dst	pointer
,	O
src	pointer
,	O
etree_assign	int
,	O
hidden	int
)	O
;	O
}	O
etree_type	union
*	O
exp_defsym	function
(	O
const	O
char	O
*	O
dst	pointer
,	O
etree_type	union
*	O
src	pointer
)	O
{	O
return	O
exp_assop	function
(	O
dst	pointer
,	O
src	pointer
,	O
etree_assign	int
,	O
FALSE	int
)	O
;	O
}	O
etree_type	union
*	O
exp_provide	function
(	O
const	O
char	O
*	O
dst	pointer
,	O
etree_type	union
*	O
src	pointer
,	O
bfd_boolean	int
hidden	int
)	O
{	O
return	O
exp_assop	function
(	O
dst	pointer
,	O
src	pointer
,	O
etree_provide	int
,	O
hidden	int
)	O
;	O
}	O
etree_type	union
*	O
exp_assert	function
(	O
etree_type	union
*	O
exp	pointer
,	O
const	O
char	O
*	O
message	pointer
)	O
{	O
etree_type	union
*	O
n	pointer
;	O
n	pointer
=	O
stat_alloc	function
(	O
sizeof	O
(	O
n	pointer
->	O
assert_s	struct
)	O
)	O
;	O
n	pointer
->	O
assert_s	struct
.	O
type	enum
.	O
node_code	int
=	O
'!'	O
;	O
n	pointer
->	O
assert_s	struct
.	O
type	enum
.	O
filename	pointer
=	O
exp	pointer
->	O
type	enum
.	O
filename	pointer
;	O
n	pointer
->	O
assert_s	struct
.	O
type	enum
.	O
lineno	pointer
=	O
exp	pointer
->	O
type	enum
.	O
lineno	pointer
;	O
n	pointer
->	O
assert_s	struct
.	O
type	enum
.	O
node_class	enum
=	O
etree_assert	int
;	O
n	pointer
->	O
assert_s	struct
.	O
child	pointer
=	O
exp	pointer
;	O
n	pointer
->	O
assert_s	struct
.	O
message	pointer
=	O
message	pointer
;	O
return	O
n	pointer
;	O
}	O
void	O
exp_print_tree	function
(	O
etree_type	union
*	O
tree	pointer
)	O
{	O
bfd_boolean	int
function_like	int
;	O
if	O
(	O
config	struct
.	O
map_file	pointer
==	O
NULL	O
)	O
config	struct
.	O
map_file	pointer
=	O
stderr	pointer
;	O
if	O
(	O
tree	pointer
==	O
NULL	O
)	O
{	O
minfo	pointer
(	O
"NULL TREE\n"	pointer
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
tree	pointer
->	O
type	enum
.	O
node_class	enum
)	O
{	O
case	O
etree_value	int
:	O
minfo	pointer
(	O
"0x%v"	pointer
,	O
tree	pointer
->	O
value	long
.	O
value	long
)	O
;	O
return	O
;	O
case	O
etree_rel	int
:	O
if	O
(	O
tree	pointer
->	O
rel	pointer
.	O
section	pointer
->	O
owner	pointer
!=	O
NULL	O
)	O
minfo	pointer
(	O
"%pB:"	pointer
,	O
tree	pointer
->	O
rel	pointer
.	O
section	pointer
->	O
owner	pointer
)	O
;	O
minfo	pointer
(	O
"%s+0x%v"	pointer
,	O
tree	pointer
->	O
rel	pointer
.	O
section	pointer
->	O
name	pointer
,	O
tree	pointer
->	O
rel	pointer
.	O
value	long
)	O
;	O
return	O
;	O
case	O
etree_assign	int
:	O
fputs	function
(	O
tree	pointer
->	O
assign	struct
.	O
dst	pointer
,	O
config	struct
.	O
map_file	pointer
)	O
;	O
exp_print_token	function
(	O
tree	pointer
->	O
type	enum
.	O
node_code	int
,	O
TRUE	int
)	O
;	O
exp_print_tree	function
(	O
tree	pointer
->	O
assign	struct
.	O
src	pointer
)	O
;	O
break	O
;	O
case	O
etree_provide	int
:	O
case	O
etree_provided	int
:	O
fprintf	function
(	O
config	struct
.	O
map_file	pointer
,	O
"PROVIDE (%s = "	pointer
,	O
tree	pointer
->	O
assign	struct
.	O
dst	pointer
)	O
;	O
exp_print_tree	function
(	O
tree	pointer
->	O
assign	struct
.	O
src	pointer
)	O
;	O
fputc	function
(	O
')'	O
,	O
config	struct
.	O
map_file	pointer
)	O
;	O
break	O
;	O
case	O
etree_binary	int
:	O
function_like	int
=	O
FALSE	int
;	O
switch	O
(	O
tree	pointer
->	O
type	enum
.	O
node_code	int
)	O
{	O
case	O
MAX_K	int
:	O
case	O
MIN_K	int
:	O
case	O
ALIGN_K	int
:	O
case	O
DATA_SEGMENT_ALIGN	int
:	O
case	O
DATA_SEGMENT_RELRO_END	int
:	O
function_like	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
SEGMENT_START	int
:	O
exp_print_token	function
(	O
tree	pointer
->	O
type	enum
.	O
node_code	int
,	O
FALSE	int
)	O
;	O
fputs	function
(	O
" (\""	pointer
,	O
config	struct
.	O
map_file	pointer
)	O
;	O
exp_print_tree	function
(	O
tree	pointer
->	O
binary	struct
.	O
rhs	pointer
)	O
;	O
fputs	function
(	O
"\", "	pointer
,	O
config	struct
.	O
map_file	pointer
)	O
;	O
exp_print_tree	function
(	O
tree	pointer
->	O
binary	struct
.	O
lhs	pointer
)	O
;	O
fputc	function
(	O
')'	O
,	O
config	struct
.	O
map_file	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
function_like	int
)	O
{	O
exp_print_token	function
(	O
tree	pointer
->	O
type	enum
.	O
node_code	int
,	O
FALSE	int
)	O
;	O
fputc	function
(	O
' '	O
,	O
config	struct
.	O
map_file	pointer
)	O
;	O
}	O
fputc	function
(	O
'('	O
,	O
config	struct
.	O
map_file	pointer
)	O
;	O
exp_print_tree	function
(	O
tree	pointer
->	O
binary	struct
.	O
lhs	pointer
)	O
;	O
if	O
(	O
function_like	int
)	O
fprintf	function
(	O
config	struct
.	O
map_file	pointer
,	O
", "	pointer
)	O
;	O
else	O
exp_print_token	function
(	O
tree	pointer
->	O
type	enum
.	O
node_code	int
,	O
TRUE	int
)	O
;	O
exp_print_tree	function
(	O
tree	pointer
->	O
binary	struct
.	O
rhs	pointer
)	O
;	O
fputc	function
(	O
')'	O
,	O
config	struct
.	O
map_file	pointer
)	O
;	O
break	O
;	O
case	O
etree_trinary	int
:	O
exp_print_tree	function
(	O
tree	pointer
->	O
trinary	struct
.	O
cond	pointer
)	O
;	O
fputc	function
(	O
'?'	O
,	O
config	struct
.	O
map_file	pointer
)	O
;	O
exp_print_tree	function
(	O
tree	pointer
->	O
trinary	struct
.	O
lhs	pointer
)	O
;	O
fputc	function
(	O
':'	O
,	O
config	struct
.	O
map_file	pointer
)	O
;	O
exp_print_tree	function
(	O
tree	pointer
->	O
trinary	struct
.	O
rhs	pointer
)	O
;	O
break	O
;	O
case	O
etree_unary	int
:	O
exp_print_token	function
(	O
tree	pointer
->	O
unary	struct
.	O
type	enum
.	O
node_code	int
,	O
FALSE	int
)	O
;	O
if	O
(	O
tree	pointer
->	O
unary	struct
.	O
child	pointer
)	O
{	O
fprintf	function
(	O
config	struct
.	O
map_file	pointer
,	O
" ("	pointer
)	O
;	O
exp_print_tree	function
(	O
tree	pointer
->	O
unary	struct
.	O
child	pointer
)	O
;	O
fputc	function
(	O
')'	O
,	O
config	struct
.	O
map_file	pointer
)	O
;	O
}	O
break	O
;	O
case	O
etree_assert	int
:	O
fprintf	function
(	O
config	struct
.	O
map_file	pointer
,	O
"ASSERT ("	pointer
)	O
;	O
exp_print_tree	function
(	O
tree	pointer
->	O
assert_s	struct
.	O
child	pointer
)	O
;	O
fprintf	function
(	O
config	struct
.	O
map_file	pointer
,	O
", %s)"	pointer
,	O
tree	pointer
->	O
assert_s	struct
.	O
message	pointer
)	O
;	O
break	O
;	O
case	O
etree_name	int
:	O
if	O
(	O
tree	pointer
->	O
type	enum
.	O
node_code	int
==	O
NAME	int
)	O
fputs	function
(	O
tree	pointer
->	O
name	pointer
.	O
name	pointer
,	O
config	struct
.	O
map_file	pointer
)	O
;	O
else	O
{	O
exp_print_token	function
(	O
tree	pointer
->	O
type	enum
.	O
node_code	int
,	O
FALSE	int
)	O
;	O
if	O
(	O
tree	pointer
->	O
name	pointer
.	O
name	pointer
)	O
fprintf	function
(	O
config	struct
.	O
map_file	pointer
,	O
" (%s)"	pointer
,	O
tree	pointer
->	O
name	pointer
.	O
name	pointer
)	O
;	O
}	O
break	O
;	O
default	O
:	O
FAIL	O
(	O
)	O
;	O
break	O
;	O
}	O
}	O
bfd_vma	long
exp_get_vma	function
(	O
etree_type	union
*	O
tree	pointer
,	O
bfd_vma	long
def	struct
,	O
char	O
*	O
name	pointer
)	O
{	O
if	O
(	O
tree	pointer
!=	O
NULL	O
)	O
{	O
exp_fold_tree_no_dot	function
(	O
tree	pointer
)	O
;	O
if	O
(	O
expld	struct
.	O
result	struct
.	O
valid_p	int
)	O
return	O
expld	struct
.	O
result	struct
.	O
value	long
;	O
else	O
if	O
(	O
name	pointer
!=	O
NULL	O
&&	O
expld	struct
.	O
phase	enum
!=	O
lang_mark_phase_enum	int
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P:%pS: nonconstant expression for %s\n"	pointer
)	O
,	O
tree	pointer
,	O
name	pointer
)	O
;	O
}	O
return	O
def	struct
;	O
}	O
int	O
exp_get_power	function
(	O
etree_type	union
*	O
tree	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
bfd_vma	long
x	long
=	O
exp_get_vma	function
(	O
tree	pointer
,	O
-	O
1	int
,	O
name	pointer
)	O
;	O
bfd_vma	long
p2	long
;	O
int	O
n	pointer
;	O
if	O
(	O
x	long
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
for	O
(	O
n	pointer
=	O
0	int
,	O
p2	long
=	O
1	int
;	O
p2	long
<	O
x	long
;	O
++	O
n	pointer
,	O
p2	long
<<=	O
1	int
)	O
if	O
(	O
p2	long
==	O
0	int
)	O
break	O
;	O
return	O
n	pointer
;	O
}	O
fill_type	struct
*	O
exp_get_fill	function
(	O
etree_type	union
*	O
tree	pointer
,	O
fill_type	struct
*	O
def	struct
,	O
char	O
*	O
name	pointer
)	O
{	O
fill_type	struct
*	O
fill	pointer
;	O
size_t	long
len	long
;	O
unsigned	O
int	O
val	array
;	O
if	O
(	O
tree	pointer
==	O
NULL	O
)	O
return	O
def	struct
;	O
exp_fold_tree_no_dot	function
(	O
tree	pointer
)	O
;	O
if	O
(	O
!	O
expld	struct
.	O
result	struct
.	O
valid_p	int
)	O
{	O
if	O
(	O
name	pointer
!=	O
NULL	O
&&	O
expld	struct
.	O
phase	enum
!=	O
lang_mark_phase_enum	int
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P:%pS: nonconstant expression for %s\n"	pointer
)	O
,	O
tree	pointer
,	O
name	pointer
)	O
;	O
return	O
def	struct
;	O
}	O
if	O
(	O
expld	struct
.	O
result	struct
.	O
str	pointer
!=	O
NULL	O
&&	O
(	O
len	long
=	O
strlen	function
(	O
expld	struct
.	O
result	struct
.	O
str	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
unsigned	O
char	O
*	O
dst	pointer
;	O
unsigned	O
char	O
*	O
s	pointer
;	O
fill	pointer
=	O
(	O
fill_type	struct
*	O
)	O
xmalloc	function
(	O
(	O
len	long
+	O
1	int
)	O
/	O
2	int
+	O
sizeof	O
(	O
*	O
fill	pointer
)	O
-	O
1	int
)	O
;	O
fill	pointer
->	O
size	int
=	O
(	O
len	long
+	O
1	int
)	O
/	O
2	int
;	O
dst	pointer
=	O
fill	pointer
->	O
data	pointer
;	O
s	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
expld	struct
.	O
result	struct
.	O
str	pointer
;	O
val	array
=	O
0	int
;	O
do	O
{	O
unsigned	O
int	O
digit	int
;	O
digit	int
=	O
*	O
s	pointer
++	O
-	O
'0'	O
;	O
if	O
(	O
digit	int
>	O
9	int
)	O
digit	int
=	O
(	O
digit	int
-	O
'A'	O
+	O
'0'	O
+	O
10	int
)	O
&	O
0xf	int
;	O
val	array
<<=	O
4	int
;	O
val	array
+=	O
digit	int
;	O
--	O
len	long
;	O
if	O
(	O
(	O
len	long
&	O
1	int
)	O
==	O
0	int
)	O
{	O
*	O
dst	pointer
++	O
=	O
val	array
;	O
val	array
=	O
0	int
;	O
}	O
}	O
while	O
(	O
len	long
!=	O
0	int
)	O
;	O
}	O
else	O
{	O
fill	pointer
=	O
(	O
fill_type	struct
*	O
)	O
xmalloc	function
(	O
4	int
+	O
sizeof	O
(	O
*	O
fill	pointer
)	O
-	O
1	int
)	O
;	O
val	array
=	O
expld	struct
.	O
result	struct
.	O
value	long
;	O
fill	pointer
->	O
data	pointer
[	O
0	int
]	O
=	O
(	O
val	array
>>	O
24	int
)	O
&	O
0xff	int
;	O
fill	pointer
->	O
data	pointer
[	O
1	int
]	O
=	O
(	O
val	array
>>	O
16	int
)	O
&	O
0xff	int
;	O
fill	pointer
->	O
data	pointer
[	O
2	int
]	O
=	O
(	O
val	array
>>	O
8	int
)	O
&	O
0xff	int
;	O
fill	pointer
->	O
data	pointer
[	O
3	int
]	O
=	O
(	O
val	array
>>	O
0	int
)	O
&	O
0xff	int
;	O
fill	pointer
->	O
size	int
=	O
4	int
;	O
}	O
return	O
fill	pointer
;	O
}	O
bfd_vma	long
exp_get_abs_int	function
(	O
etree_type	union
*	O
tree	pointer
,	O
int	O
def	struct
,	O
char	O
*	O
name	pointer
)	O
{	O
if	O
(	O
tree	pointer
!=	O
NULL	O
)	O
{	O
exp_fold_tree_no_dot	function
(	O
tree	pointer
)	O
;	O
if	O
(	O
expld	struct
.	O
result	struct
.	O
valid_p	int
)	O
{	O
if	O
(	O
expld	struct
.	O
result	struct
.	O
section	pointer
!=	O
NULL	O
)	O
expld	struct
.	O
result	struct
.	O
value	long
+=	O
expld	struct
.	O
result	struct
.	O
section	pointer
->	O
vma	long
;	O
return	O
expld	struct
.	O
result	struct
.	O
value	long
;	O
}	O
else	O
if	O
(	O
name	pointer
!=	O
NULL	O
&&	O
expld	struct
.	O
phase	enum
!=	O
lang_mark_phase_enum	int
)	O
{	O
einfo	pointer
(	O
_	O
(	O
"%F%P:%pS: nonconstant expression for %s\n"	pointer
)	O
,	O
tree	pointer
,	O
name	pointer
)	O
;	O
}	O
}	O
return	O
def	struct
;	O
}	O
static	O
bfd_vma	long
align_n	function
(	O
bfd_vma	long
value	long
,	O
bfd_vma	long
align	long
)	O
{	O
if	O
(	O
align	long
<=	O
1	int
)	O
return	O
value	long
;	O
value	long
=	O
(	O
value	long
+	O
align	long
-	O
1	int
)	O
/	O
align	long
;	O
return	O
value	long
*	O
align	long
;	O
}	O
void	O
ldexp_init	function
(	O
void	O
)	O
{	O
if	O
(	O
!	O
bfd_hash_table_init_n	function
(	O
&	O
definedness_table	struct
,	O
definedness_newfunc	function
,	O
sizeof	O
(	O
struct	O
definedness_hash_entry	struct
)	O
,	O
13	int
)	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: can not create hash table: %E\n"	pointer
)	O
)	O
;	O
}	O
static	O
bfd_boolean	int
set_sym_sections	function
(	O
struct	O
bfd_hash_entry	struct
*	O
bh	pointer
,	O
void	O
*	O
inf	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
struct	O
definedness_hash_entry	struct
*	O
def	struct
=	O
(	O
struct	O
definedness_hash_entry	struct
*	O
)	O
bh	pointer
;	O
if	O
(	O
def	struct
->	O
final_sec	pointer
!=	O
bfd_abs_section_ptr	O
)	O
{	O
struct	O
bfd_link_hash_entry	struct
*	O
h	pointer
;	O
h	pointer
=	O
bfd_link_hash_lookup	function
(	O
link_info	struct
.	O
hash	long
,	O
bh	pointer
->	O
string	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
&&	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_defined	int
&&	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
==	O
bfd_abs_section_ptr	O
)	O
{	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
value	long
-=	O
def	struct
->	O
final_sec	pointer
->	O
vma	long
;	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
=	O
def	struct
->	O
final_sec	pointer
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
void	O
ldexp_finalize_syms	function
(	O
void	O
)	O
{	O
bfd_hash_traverse	function
(	O
&	O
definedness_table	struct
,	O
set_sym_sections	function
,	O
NULL	O
)	O
;	O
}	O
void	O
ldexp_finish	function
(	O
void	O
)	O
{	O
bfd_hash_table_free	function
(	O
&	O
definedness_table	struct
)	O
;	O
}	O
