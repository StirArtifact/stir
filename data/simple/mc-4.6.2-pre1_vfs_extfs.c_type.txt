struct	O
inode	struct
{	O
nlink_t	long
nlink	long
;	O
struct	O
entry	struct
*	O
first_in_subdir	pointer
;	O
struct	O
entry	struct
*	O
last_in_subdir	pointer
;	O
ino_t	long
inode	struct
;	O
dev_t	long
dev	int
;	O
struct	O
archive	pointer
*	O
archive	pointer
;	O
dev_t	long
rdev	long
;	O
mode_t	int
mode	int
;	O
uid_t	int
uid	int
;	O
gid_t	int
gid	int
;	O
off_t	long
size	long
;	O
time_t	long
mtime	long
;	O
char	O
*	O
linkname	pointer
;	O
time_t	long
atime	long
;	O
time_t	long
ctime	function
;	O
char	O
*	O
local_filename	pointer
;	O
}	O
;	O
struct	O
entry	struct
{	O
struct	O
entry	struct
*	O
next_in_dir	pointer
;	O
struct	O
entry	struct
*	O
dir	pointer
;	O
char	O
*	O
name	pointer
;	O
struct	O
inode	struct
*	O
inode	struct
;	O
}	O
;	O
struct	O
pseudofile	struct
{	O
struct	O
archive	pointer
*	O
archive	pointer
;	O
unsigned	O
int	O
has_changed	int
:	O
1	int
;	O
int	O
local_handle	int
;	O
struct	O
entry	struct
*	O
entry	struct
;	O
}	O
;	O
struct	O
archive	pointer
{	O
int	O
fstype	int
;	O
char	O
*	O
name	pointer
;	O
char	O
*	O
local_name	pointer
;	O
struct	O
stat	struct
local_stat	struct
;	O
dev_t	long
rdev	long
;	O
int	O
fd_usage	int
;	O
ino_t	long
inode_counter	long
;	O
struct	O
entry	struct
*	O
root_entry	pointer
;	O
struct	O
archive	pointer
*	O
next	pointer
;	O
}	O
;	O
static	O
struct	O
entry	struct
*	O
extfs_find_entry	function
(	O
struct	O
entry	struct
*	O
dir	pointer
,	O
char	O
*	O
name	pointer
,	O
int	O
make_dirs	int
,	O
int	O
make_file	int
)	O
;	O
static	O
int	O
extfs_which	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
const	O
char	O
*	O
path	pointer
)	O
;	O
static	O
void	O
extfs_remove_entry	function
(	O
struct	O
entry	struct
*	O
e	pointer
)	O
;	O
static	O
void	O
extfs_free	function
(	O
vfsid	pointer
id	int
)	O
;	O
static	O
void	O
extfs_free_entry	function
(	O
struct	O
entry	struct
*	O
e	pointer
)	O
;	O
static	O
struct	O
vfs_class	struct
vfs_extfs_ops	struct
;	O
static	O
struct	O
archive	pointer
*	O
first_archive	pointer
=	O
NULL	O
;	O
static	O
int	O
my_errno	int
=	O
0	int
;	O
static	O
char	O
*	O
extfs_prefixes	array
[	O
MAXEXTFS	int
]	O
;	O
static	O
char	O
extfs_need_archive	array
[	O
MAXEXTFS	int
]	O
;	O
static	O
int	O
extfs_no	int
=	O
0	int
;	O
static	O
void	O
extfs_fill_names	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
fill_names_f	pointer
func	pointer
)	O
{	O
struct	O
archive	pointer
*	O
a	pointer
=	O
first_archive	pointer
;	O
char	O
*	O
name	pointer
;	O
(	O
void	O
)	O
me	pointer
;	O
while	O
(	O
a	pointer
)	O
{	O
name	pointer
=	O
g_strconcat	function
(	O
a	pointer
->	O
name	pointer
?	O
a	pointer
->	O
name	pointer
:	O
""	pointer
,	O
"#"	pointer
,	O
extfs_prefixes	array
[	O
a	pointer
->	O
fstype	int
]	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
(	O
*	O
func	pointer
)	O
(	O
name	pointer
)	O
;	O
g_free	function
(	O
name	pointer
)	O
;	O
a	pointer
=	O
a	pointer
->	O
next	pointer
;	O
}	O
}	O
static	O
void	O
extfs_make_dots	function
(	O
struct	O
entry	struct
*	O
ent	pointer
)	O
{	O
struct	O
entry	struct
*	O
entry	struct
=	O
g_new	O
(	O
struct	O
entry	struct
,	O
1	int
)	O
;	O
struct	O
entry	struct
*	O
parentry	pointer
=	O
ent	pointer
->	O
dir	pointer
;	O
struct	O
inode	struct
*	O
inode	struct
=	O
ent	pointer
->	O
inode	struct
,	O
*	O
parent	pointer
;	O
parent	pointer
=	O
(	O
parentry	pointer
!=	O
NULL	O
)	O
?	O
parentry	pointer
->	O
inode	struct
:	O
NULL	O
;	O
entry	struct
->	O
name	pointer
=	O
g_strdup	function
(	O
"."	pointer
)	O
;	O
entry	struct
->	O
inode	struct
=	O
inode	struct
;	O
entry	struct
->	O
dir	pointer
=	O
ent	pointer
;	O
inode	struct
->	O
local_filename	pointer
=	O
NULL	O
;	O
inode	struct
->	O
first_in_subdir	pointer
=	O
entry	struct
;	O
inode	struct
->	O
nlink	long
++	O
;	O
entry	struct
->	O
next_in_dir	pointer
=	O
g_new	O
(	O
struct	O
entry	struct
,	O
1	int
)	O
;	O
entry	struct
=	O
entry	struct
->	O
next_in_dir	pointer
;	O
entry	struct
->	O
name	pointer
=	O
g_strdup	function
(	O
".."	pointer
)	O
;	O
inode	struct
->	O
last_in_subdir	pointer
=	O
entry	struct
;	O
entry	struct
->	O
next_in_dir	pointer
=	O
NULL	O
;	O
if	O
(	O
parent	pointer
!=	O
NULL	O
)	O
{	O
entry	struct
->	O
inode	struct
=	O
parent	pointer
;	O
entry	struct
->	O
dir	pointer
=	O
parentry	pointer
;	O
parent	pointer
->	O
nlink	long
++	O
;	O
}	O
else	O
{	O
entry	struct
->	O
inode	struct
=	O
inode	struct
;	O
entry	struct
->	O
dir	pointer
=	O
ent	pointer
;	O
inode	struct
->	O
nlink	long
++	O
;	O
}	O
}	O
static	O
struct	O
entry	struct
*	O
extfs_generate_entry	function
(	O
struct	O
archive	pointer
*	O
archive	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
struct	O
entry	struct
*	O
parentry	pointer
,	O
mode_t	int
mode	int
)	O
{	O
mode_t	int
myumask	int
;	O
struct	O
inode	struct
*	O
inode	struct
,	O
*	O
parent	pointer
;	O
struct	O
entry	struct
*	O
entry	struct
;	O
parent	pointer
=	O
(	O
parentry	pointer
!=	O
NULL	O
)	O
?	O
parentry	pointer
->	O
inode	struct
:	O
NULL	O
;	O
entry	struct
=	O
g_new	O
(	O
struct	O
entry	struct
,	O
1	int
)	O
;	O
entry	struct
->	O
name	pointer
=	O
g_strdup	function
(	O
name	pointer
)	O
;	O
entry	struct
->	O
next_in_dir	pointer
=	O
NULL	O
;	O
entry	struct
->	O
dir	pointer
=	O
parentry	pointer
;	O
if	O
(	O
parent	pointer
!=	O
NULL	O
)	O
{	O
parent	pointer
->	O
last_in_subdir	pointer
->	O
next_in_dir	pointer
=	O
entry	struct
;	O
parent	pointer
->	O
last_in_subdir	pointer
=	O
entry	struct
;	O
}	O
inode	struct
=	O
g_new	O
(	O
struct	O
inode	struct
,	O
1	int
)	O
;	O
entry	struct
->	O
inode	struct
=	O
inode	struct
;	O
inode	struct
->	O
local_filename	pointer
=	O
NULL	O
;	O
inode	struct
->	O
linkname	pointer
=	O
NULL	O
;	O
inode	struct
->	O
last_in_subdir	pointer
=	O
NULL	O
;	O
inode	struct
->	O
inode	struct
=	O
(	O
archive	pointer
->	O
inode_counter	long
)	O
++	O
;	O
inode	struct
->	O
dev	int
=	O
archive	pointer
->	O
rdev	long
;	O
inode	struct
->	O
archive	pointer
=	O
archive	pointer
;	O
myumask	int
=	O
umask	function
(	O
022	int
)	O
;	O
umask	function
(	O
myumask	int
)	O
;	O
inode	struct
->	O
mode	int
=	O
mode	int
&	O
~	O
myumask	int
;	O
mode	int
=	O
inode	struct
->	O
mode	int
;	O
inode	struct
->	O
rdev	long
=	O
0	int
;	O
inode	struct
->	O
uid	int
=	O
getuid	function
(	O
)	O
;	O
inode	struct
->	O
gid	int
=	O
getgid	function
(	O
)	O
;	O
inode	struct
->	O
size	long
=	O
0	int
;	O
inode	struct
->	O
mtime	long
=	O
time	long
(	O
NULL	O
)	O
;	O
inode	struct
->	O
atime	long
=	O
inode	struct
->	O
mtime	long
;	O
inode	struct
->	O
ctime	function
=	O
inode	struct
->	O
mtime	long
;	O
inode	struct
->	O
nlink	long
=	O
1	int
;	O
if	O
(	O
S_ISDIR	O
(	O
mode	int
)	O
)	O
extfs_make_dots	function
(	O
entry	struct
)	O
;	O
return	O
entry	struct
;	O
}	O
static	O
void	O
extfs_free_archive	function
(	O
struct	O
archive	pointer
*	O
archive	pointer
)	O
{	O
extfs_free_entry	function
(	O
archive	pointer
->	O
root_entry	pointer
)	O
;	O
if	O
(	O
archive	pointer
->	O
local_name	pointer
!=	O
NULL	O
)	O
{	O
struct	O
stat	struct
my	struct
;	O
mc_stat	function
(	O
archive	pointer
->	O
local_name	pointer
,	O
&	O
my	struct
)	O
;	O
mc_ungetlocalcopy	function
(	O
archive	pointer
->	O
name	pointer
,	O
archive	pointer
->	O
local_name	pointer
,	O
archive	pointer
->	O
local_stat	struct
.	O
st_mtime	O
!=	O
my	struct
.	O
st_mtime	O
)	O
;	O
g_free	function
(	O
archive	pointer
->	O
local_name	pointer
)	O
;	O
}	O
g_free	function
(	O
archive	pointer
->	O
name	pointer
)	O
;	O
g_free	function
(	O
archive	pointer
)	O
;	O
}	O
static	O
FILE	struct
*	O
extfs_open_archive	function
(	O
int	O
fstype	int
,	O
const	O
char	O
*	O
name	pointer
,	O
struct	O
archive	pointer
*	O
*	O
pparc	pointer
)	O
{	O
static	O
dev_t	long
archive_counter	long
=	O
0	int
;	O
FILE	struct
*	O
result	long
;	O
mode_t	int
mode	int
;	O
char	O
*	O
cmd	pointer
;	O
char	O
*	O
mc_extfsdir	pointer
;	O
struct	O
stat	struct
mystat	struct
;	O
struct	O
archive	pointer
*	O
current_archive	pointer
;	O
struct	O
entry	struct
*	O
root_entry	pointer
;	O
char	O
*	O
local_name	pointer
=	O
NULL	O
,	O
*	O
tmp	pointer
=	O
0	int
;	O
int	O
uses_archive	int
=	O
extfs_need_archive	array
[	O
fstype	int
]	O
;	O
if	O
(	O
uses_archive	int
)	O
{	O
if	O
(	O
mc_stat	function
(	O
name	pointer
,	O
&	O
mystat	struct
)	O
==	O
-	O
1	int
)	O
return	O
NULL	O
;	O
if	O
(	O
!	O
vfs_file_is_local	function
(	O
name	pointer
)	O
)	O
{	O
local_name	pointer
=	O
mc_getlocalcopy	function
(	O
name	pointer
)	O
;	O
if	O
(	O
local_name	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
}	O
tmp	pointer
=	O
name_quote	function
(	O
name	pointer
,	O
0	int
)	O
;	O
}	O
mc_extfsdir	pointer
=	O
concat_dir_and_file	function
(	O
mc_home	pointer
,	O
"extfs"	pointer
PATH_SEP_STR	pointer
)	O
;	O
cmd	pointer
=	O
g_strconcat	function
(	O
mc_extfsdir	pointer
,	O
extfs_prefixes	array
[	O
fstype	int
]	O
,	O
" list "	pointer
,	O
local_name	pointer
?	O
local_name	pointer
:	O
tmp	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
g_free	function
(	O
tmp	pointer
)	O
;	O
g_free	function
(	O
mc_extfsdir	pointer
)	O
;	O
open_error_pipe	function
(	O
)	O
;	O
result	long
=	O
popen	function
(	O
cmd	pointer
,	O
"r"	pointer
)	O
;	O
g_free	function
(	O
cmd	pointer
)	O
;	O
if	O
(	O
result	long
==	O
NULL	O
)	O
{	O
close_error_pipe	function
(	O
1	int
,	O
NULL	O
)	O
;	O
if	O
(	O
local_name	pointer
)	O
{	O
mc_ungetlocalcopy	function
(	O
name	pointer
,	O
local_name	pointer
,	O
0	int
)	O
;	O
g_free	function
(	O
local_name	pointer
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
current_archive	pointer
=	O
g_new	O
(	O
struct	O
archive	pointer
,	O
1	int
)	O
;	O
current_archive	pointer
->	O
fstype	int
=	O
fstype	int
;	O
current_archive	pointer
->	O
name	pointer
=	O
name	pointer
?	O
g_strdup	function
(	O
name	pointer
)	O
:	O
NULL	O
;	O
current_archive	pointer
->	O
local_name	pointer
=	O
local_name	pointer
;	O
if	O
(	O
local_name	pointer
!=	O
NULL	O
)	O
mc_stat	function
(	O
local_name	pointer
,	O
&	O
current_archive	pointer
->	O
local_stat	struct
)	O
;	O
current_archive	pointer
->	O
inode_counter	long
=	O
0	int
;	O
current_archive	pointer
->	O
fd_usage	int
=	O
0	int
;	O
current_archive	pointer
->	O
rdev	long
=	O
archive_counter	long
++	O
;	O
current_archive	pointer
->	O
next	pointer
=	O
first_archive	pointer
;	O
first_archive	pointer
=	O
current_archive	pointer
;	O
mode	int
=	O
mystat	struct
.	O
st_mode	int
&	O
07777	int
;	O
if	O
(	O
mode	int
&	O
0400	int
)	O
mode	int
|=	O
0100	int
;	O
if	O
(	O
mode	int
&	O
0040	int
)	O
mode	int
|=	O
0010	int
;	O
if	O
(	O
mode	int
&	O
0004	int
)	O
mode	int
|=	O
0001	int
;	O
mode	int
|=	O
S_IFDIR	O
;	O
root_entry	pointer
=	O
extfs_generate_entry	function
(	O
current_archive	pointer
,	O
"/"	pointer
,	O
NULL	O
,	O
mode	int
)	O
;	O
root_entry	pointer
->	O
inode	struct
->	O
uid	int
=	O
mystat	struct
.	O
st_uid	int
;	O
root_entry	pointer
->	O
inode	struct
->	O
gid	int
=	O
mystat	struct
.	O
st_gid	int
;	O
root_entry	pointer
->	O
inode	struct
->	O
atime	long
=	O
mystat	struct
.	O
st_atime	O
;	O
root_entry	pointer
->	O
inode	struct
->	O
ctime	function
=	O
mystat	struct
.	O
st_ctime	O
;	O
root_entry	pointer
->	O
inode	struct
->	O
mtime	long
=	O
mystat	struct
.	O
st_mtime	O
;	O
current_archive	pointer
->	O
root_entry	pointer
=	O
root_entry	pointer
;	O
*	O
pparc	pointer
=	O
current_archive	pointer
;	O
return	O
result	long
;	O
}	O
static	O
int	O
extfs_read_archive	function
(	O
int	O
fstype	int
,	O
const	O
char	O
*	O
name	pointer
,	O
struct	O
archive	pointer
*	O
*	O
pparc	pointer
)	O
{	O
FILE	struct
*	O
extfsd	pointer
;	O
char	O
*	O
buffer	pointer
;	O
struct	O
archive	pointer
*	O
current_archive	pointer
;	O
char	O
*	O
current_file_name	pointer
,	O
*	O
current_link_name	pointer
;	O
if	O
(	O
(	O
extfsd	pointer
=	O
extfs_open_archive	function
(	O
fstype	int
,	O
name	pointer
,	O
&	O
current_archive	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
"Cannot open %s archive\n%s"	pointer
)	O
,	O
extfs_prefixes	array
[	O
fstype	int
]	O
,	O
name	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
buffer	pointer
=	O
g_malloc	function
(	O
4096	int
)	O
;	O
while	O
(	O
fgets	function
(	O
buffer	pointer
,	O
4096	int
,	O
extfsd	pointer
)	O
!=	O
NULL	O
)	O
{	O
struct	O
stat	struct
hstat	struct
;	O
current_link_name	pointer
=	O
NULL	O
;	O
if	O
(	O
vfs_parse_ls_lga	function
(	O
buffer	pointer
,	O
&	O
hstat	struct
,	O
&	O
current_file_name	pointer
,	O
&	O
current_link_name	pointer
)	O
)	O
{	O
struct	O
entry	struct
*	O
entry	struct
,	O
*	O
pent	pointer
;	O
struct	O
inode	struct
*	O
inode	struct
;	O
char	O
*	O
p	pointer
,	O
*	O
q	pointer
,	O
*	O
cfn	pointer
=	O
current_file_name	pointer
;	O
if	O
(	O
*	O
cfn	pointer
)	O
{	O
if	O
(	O
*	O
cfn	pointer
==	O
'/'	O
)	O
cfn	pointer
++	O
;	O
p	pointer
=	O
strchr	function
(	O
cfn	pointer
,	O
0	int
)	O
;	O
if	O
(	O
p	pointer
!=	O
cfn	pointer
&&	O
*	O
(	O
p	pointer
-	O
1	int
)	O
==	O
'/'	O
)	O
*	O
(	O
p	pointer
-	O
1	int
)	O
=	O
0	int
;	O
p	pointer
=	O
strrchr	function
(	O
cfn	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
{	O
p	pointer
=	O
cfn	pointer
;	O
q	pointer
=	O
strchr	function
(	O
cfn	pointer
,	O
0	int
)	O
;	O
}	O
else	O
{	O
*	O
(	O
p	pointer
++	O
)	O
=	O
0	int
;	O
q	pointer
=	O
cfn	pointer
;	O
}	O
if	O
(	O
S_ISDIR	O
(	O
hstat	struct
.	O
st_mode	int
)	O
&&	O
(	O
!	O
strcmp	function
(	O
p	pointer
,	O
"."	pointer
)	O
||	O
!	O
strcmp	function
(	O
p	pointer
,	O
".."	pointer
)	O
)	O
)	O
goto	O
read_extfs_continue	O
;	O
pent	pointer
=	O
extfs_find_entry	function
(	O
current_archive	pointer
->	O
root_entry	pointer
,	O
q	pointer
,	O
1	int
,	O
0	int
)	O
;	O
if	O
(	O
pent	pointer
==	O
NULL	O
)	O
{	O
g_free	function
(	O
buffer	pointer
)	O
;	O
pclose	function
(	O
extfsd	pointer
)	O
;	O
close_error_pipe	function
(	O
1	int
,	O
_	O
(	O
"Inconsistent extfs archive"	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
entry	struct
=	O
g_new	O
(	O
struct	O
entry	struct
,	O
1	int
)	O
;	O
entry	struct
->	O
name	pointer
=	O
g_strdup	function
(	O
p	pointer
)	O
;	O
entry	struct
->	O
next_in_dir	pointer
=	O
NULL	O
;	O
entry	struct
->	O
dir	pointer
=	O
pent	pointer
;	O
if	O
(	O
pent	pointer
->	O
inode	struct
->	O
last_in_subdir	pointer
)	O
{	O
pent	pointer
->	O
inode	struct
->	O
last_in_subdir	pointer
->	O
next_in_dir	pointer
=	O
entry	struct
;	O
pent	pointer
->	O
inode	struct
->	O
last_in_subdir	pointer
=	O
entry	struct
;	O
}	O
if	O
(	O
!	O
S_ISLNK	O
(	O
hstat	struct
.	O
st_mode	int
)	O
&&	O
current_link_name	pointer
!=	O
NULL	O
)	O
{	O
pent	pointer
=	O
extfs_find_entry	function
(	O
current_archive	pointer
->	O
root_entry	pointer
,	O
current_link_name	pointer
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
pent	pointer
==	O
NULL	O
)	O
{	O
g_free	function
(	O
buffer	pointer
)	O
;	O
pclose	function
(	O
extfsd	pointer
)	O
;	O
close_error_pipe	function
(	O
1	int
,	O
_	O
(	O
"Inconsistent extfs archive"	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
entry	struct
->	O
inode	struct
=	O
pent	pointer
->	O
inode	struct
;	O
pent	pointer
->	O
inode	struct
->	O
nlink	long
++	O
;	O
}	O
}	O
else	O
{	O
inode	struct
=	O
g_new	O
(	O
struct	O
inode	struct
,	O
1	int
)	O
;	O
entry	struct
->	O
inode	struct
=	O
inode	struct
;	O
inode	struct
->	O
local_filename	pointer
=	O
NULL	O
;	O
inode	struct
->	O
inode	struct
=	O
(	O
current_archive	pointer
->	O
inode_counter	long
)	O
++	O
;	O
inode	struct
->	O
nlink	long
=	O
1	int
;	O
inode	struct
->	O
dev	int
=	O
current_archive	pointer
->	O
rdev	long
;	O
inode	struct
->	O
archive	pointer
=	O
current_archive	pointer
;	O
inode	struct
->	O
mode	int
=	O
hstat	struct
.	O
st_mode	int
;	O
inode	struct
->	O
rdev	long
=	O
hstat	struct
.	O
st_rdev	long
;	O
inode	struct
->	O
uid	int
=	O
hstat	struct
.	O
st_uid	int
;	O
inode	struct
->	O
gid	int
=	O
hstat	struct
.	O
st_gid	int
;	O
inode	struct
->	O
size	long
=	O
hstat	struct
.	O
st_size	long
;	O
inode	struct
->	O
mtime	long
=	O
hstat	struct
.	O
st_mtime	O
;	O
inode	struct
->	O
atime	long
=	O
hstat	struct
.	O
st_atime	O
;	O
inode	struct
->	O
ctime	function
=	O
hstat	struct
.	O
st_ctime	O
;	O
inode	struct
->	O
first_in_subdir	pointer
=	O
NULL	O
;	O
inode	struct
->	O
last_in_subdir	pointer
=	O
NULL	O
;	O
if	O
(	O
current_link_name	pointer
!=	O
NULL	O
&&	O
S_ISLNK	O
(	O
hstat	struct
.	O
st_mode	int
)	O
)	O
{	O
inode	struct
->	O
linkname	pointer
=	O
current_link_name	pointer
;	O
current_link_name	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
if	O
(	O
S_ISLNK	O
(	O
hstat	struct
.	O
st_mode	int
)	O
)	O
inode	struct
->	O
mode	int
&=	O
~	O
S_IFLNK	O
;	O
inode	struct
->	O
linkname	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
S_ISDIR	O
(	O
hstat	struct
.	O
st_mode	int
)	O
)	O
extfs_make_dots	function
(	O
entry	struct
)	O
;	O
}	O
}	O
read_extfs_continue	O
:	O
g_free	function
(	O
current_file_name	pointer
)	O
;	O
g_free	function
(	O
current_link_name	pointer
)	O
;	O
}	O
}	O
g_free	function
(	O
buffer	pointer
)	O
;	O
if	O
(	O
pclose	function
(	O
extfsd	pointer
)	O
!=	O
0	int
)	O
{	O
extfs_free	function
(	O
current_archive	pointer
)	O
;	O
close_error_pipe	function
(	O
1	int
,	O
_	O
(	O
"Inconsistent extfs archive"	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
close_error_pipe	function
(	O
1	int
,	O
NULL	O
)	O
;	O
*	O
pparc	pointer
=	O
current_archive	pointer
;	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
extfs_get_path_mangle	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
char	O
*	O
inname	pointer
,	O
struct	O
archive	pointer
*	O
*	O
archive	pointer
,	O
int	O
do_not_open	int
)	O
{	O
char	O
*	O
local	pointer
,	O
*	O
op	pointer
;	O
const	O
char	O
*	O
archive_name	pointer
;	O
int	O
result	long
=	O
-	O
1	int
;	O
struct	O
archive	pointer
*	O
parc	pointer
;	O
int	O
fstype	int
;	O
archive_name	pointer
=	O
inname	pointer
;	O
vfs_split	function
(	O
inname	pointer
,	O
&	O
local	pointer
,	O
&	O
op	pointer
)	O
;	O
fstype	int
=	O
extfs_which	function
(	O
me	pointer
,	O
op	pointer
)	O
;	O
if	O
(	O
fstype	int
==	O
-	O
1	int
)	O
return	O
NULL	O
;	O
if	O
(	O
!	O
local	pointer
)	O
local	pointer
=	O
inname	pointer
+	O
strlen	function
(	O
inname	pointer
)	O
;	O
for	O
(	O
parc	pointer
=	O
first_archive	pointer
;	O
parc	pointer
!=	O
NULL	O
;	O
parc	pointer
=	O
parc	pointer
->	O
next	pointer
)	O
if	O
(	O
parc	pointer
->	O
name	pointer
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
parc	pointer
->	O
name	pointer
,	O
archive_name	pointer
)	O
)	O
{	O
vfs_stamp	function
(	O
&	O
vfs_extfs_ops	struct
,	O
(	O
vfsid	pointer
)	O
parc	pointer
)	O
;	O
goto	O
return_success	O
;	O
}	O
}	O
result	long
=	O
do_not_open	int
?	O
-	O
1	int
:	O
extfs_read_archive	function
(	O
fstype	int
,	O
archive_name	pointer
,	O
&	O
parc	pointer
)	O
;	O
if	O
(	O
result	long
==	O
-	O
1	int
)	O
ERRNOR	O
(	O
EIO	int
,	O
NULL	O
)	O
;	O
return_success	O
:	O
*	O
archive	pointer
=	O
parc	pointer
;	O
return	O
local	pointer
;	O
}	O
static	O
char	O
*	O
extfs_get_path	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
const	O
char	O
*	O
inname	pointer
,	O
struct	O
archive	pointer
*	O
*	O
archive	pointer
,	O
int	O
do_not_open	int
)	O
{	O
char	O
*	O
buf	pointer
=	O
g_strdup	function
(	O
inname	pointer
)	O
;	O
char	O
*	O
res	pointer
=	O
extfs_get_path_mangle	function
(	O
me	pointer
,	O
buf	pointer
,	O
archive	pointer
,	O
do_not_open	int
)	O
;	O
char	O
*	O
res2	pointer
=	O
NULL	O
;	O
if	O
(	O
res	pointer
)	O
res2	pointer
=	O
g_strdup	function
(	O
res	pointer
)	O
;	O
g_free	function
(	O
buf	pointer
)	O
;	O
return	O
res2	pointer
;	O
}	O
static	O
char	O
*	O
extfs_get_path_from_entry	function
(	O
struct	O
entry	struct
*	O
entry	struct
)	O
{	O
struct	O
list	pointer
{	O
struct	O
list	pointer
*	O
next	pointer
;	O
char	O
*	O
name	pointer
;	O
}	O
*	O
head	pointer
,	O
*	O
p	pointer
;	O
char	O
*	O
localpath	pointer
;	O
size_t	long
len	int
;	O
for	O
(	O
len	int
=	O
0	int
,	O
head	pointer
=	O
0	int
;	O
entry	struct
->	O
dir	pointer
;	O
entry	struct
=	O
entry	struct
->	O
dir	pointer
)	O
{	O
p	pointer
=	O
g_new	O
(	O
struct	O
list	pointer
,	O
1	int
)	O
;	O
p	pointer
->	O
next	pointer
=	O
head	pointer
;	O
p	pointer
->	O
name	pointer
=	O
entry	struct
->	O
name	pointer
;	O
head	pointer
=	O
p	pointer
;	O
len	int
+=	O
strlen	function
(	O
entry	struct
->	O
name	pointer
)	O
+	O
1	int
;	O
}	O
if	O
(	O
len	int
==	O
0	int
)	O
return	O
g_strdup	function
(	O
""	pointer
)	O
;	O
localpath	pointer
=	O
g_malloc	function
(	O
len	int
)	O
;	O
*	O
localpath	pointer
=	O
'\0'	O
;	O
while	O
(	O
head	pointer
)	O
{	O
strcat	function
(	O
localpath	pointer
,	O
head	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
head	pointer
->	O
next	pointer
)	O
strcat	function
(	O
localpath	pointer
,	O
"/"	pointer
)	O
;	O
p	pointer
=	O
head	pointer
;	O
head	pointer
=	O
head	pointer
->	O
next	pointer
;	O
g_free	function
(	O
p	pointer
)	O
;	O
}	O
return	O
(	O
localpath	pointer
)	O
;	O
}	O
struct	O
loop_protect	struct
{	O
struct	O
entry	struct
*	O
entry	struct
;	O
struct	O
loop_protect	struct
*	O
next	pointer
;	O
}	O
;	O
static	O
int	O
errloop	int
;	O
static	O
int	O
notadir	int
;	O
static	O
struct	O
entry	struct
*	O
extfs_find_entry_int	function
(	O
struct	O
entry	struct
*	O
dir	pointer
,	O
char	O
*	O
name	pointer
,	O
struct	O
loop_protect	struct
*	O
list	pointer
,	O
int	O
make_dirs	int
,	O
int	O
make_file	int
)	O
;	O
static	O
struct	O
entry	struct
*	O
extfs_resolve_symlinks_int	function
(	O
struct	O
entry	struct
*	O
entry	struct
,	O
struct	O
loop_protect	struct
*	O
list	pointer
)	O
{	O
struct	O
entry	struct
*	O
pent	pointer
;	O
struct	O
loop_protect	struct
*	O
looping	pointer
;	O
if	O
(	O
!	O
S_ISLNK	O
(	O
entry	struct
->	O
inode	struct
->	O
mode	int
)	O
)	O
return	O
entry	struct
;	O
for	O
(	O
looping	pointer
=	O
list	pointer
;	O
looping	pointer
!=	O
NULL	O
;	O
looping	pointer
=	O
looping	pointer
->	O
next	pointer
)	O
if	O
(	O
entry	struct
==	O
looping	pointer
->	O
entry	struct
)	O
{	O
errloop	int
=	O
1	int
;	O
return	O
NULL	O
;	O
}	O
looping	pointer
=	O
g_new	O
(	O
struct	O
loop_protect	struct
,	O
1	int
)	O
;	O
looping	pointer
->	O
entry	struct
=	O
entry	struct
;	O
looping	pointer
->	O
next	pointer
=	O
list	pointer
;	O
pent	pointer
=	O
extfs_find_entry_int	function
(	O
entry	struct
->	O
dir	pointer
,	O
entry	struct
->	O
inode	struct
->	O
linkname	pointer
,	O
looping	pointer
,	O
0	int
,	O
0	int
)	O
;	O
g_free	function
(	O
looping	pointer
)	O
;	O
if	O
(	O
pent	pointer
==	O
NULL	O
)	O
my_errno	int
=	O
ENOENT	int
;	O
return	O
pent	pointer
;	O
}	O
static	O
struct	O
entry	struct
*	O
extfs_resolve_symlinks	function
(	O
struct	O
entry	struct
*	O
entry	struct
)	O
{	O
struct	O
entry	struct
*	O
res	pointer
;	O
errloop	int
=	O
0	int
;	O
notadir	int
=	O
0	int
;	O
res	pointer
=	O
extfs_resolve_symlinks_int	function
(	O
entry	struct
,	O
NULL	O
)	O
;	O
if	O
(	O
res	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
errloop	int
)	O
my_errno	int
=	O
ELOOP	int
;	O
else	O
if	O
(	O
notadir	int
)	O
my_errno	int
=	O
ENOTDIR	int
;	O
}	O
return	O
res	pointer
;	O
}	O
static	O
const	O
char	O
*	O
extfs_get_archive_name	function
(	O
struct	O
archive	pointer
*	O
archive	pointer
)	O
{	O
const	O
char	O
*	O
archive_name	pointer
;	O
if	O
(	O
archive	pointer
->	O
local_name	pointer
)	O
archive_name	pointer
=	O
archive	pointer
->	O
local_name	pointer
;	O
else	O
archive_name	pointer
=	O
archive	pointer
->	O
name	pointer
;	O
if	O
(	O
!	O
archive_name	pointer
||	O
!	O
*	O
archive_name	pointer
)	O
return	O
"no_archive_name"	pointer
;	O
else	O
return	O
archive_name	pointer
;	O
}	O
static	O
int	O
extfs_cmd	pointer
(	O
const	O
char	O
*	O
extfs_cmd	pointer
,	O
struct	O
archive	pointer
*	O
archive	pointer
,	O
struct	O
entry	struct
*	O
entry	struct
,	O
const	O
char	O
*	O
localname	pointer
)	O
{	O
char	O
*	O
file	pointer
;	O
char	O
*	O
quoted_file	pointer
;	O
char	O
*	O
quoted_localname	pointer
;	O
char	O
*	O
archive_name	pointer
;	O
char	O
*	O
mc_extfsdir	pointer
;	O
char	O
*	O
cmd	pointer
;	O
int	O
retval	pointer
;	O
file	pointer
=	O
extfs_get_path_from_entry	function
(	O
entry	struct
)	O
;	O
quoted_file	pointer
=	O
name_quote	function
(	O
file	pointer
,	O
0	int
)	O
;	O
g_free	function
(	O
file	pointer
)	O
;	O
archive_name	pointer
=	O
name_quote	function
(	O
extfs_get_archive_name	function
(	O
archive	pointer
)	O
,	O
0	int
)	O
;	O
quoted_localname	pointer
=	O
name_quote	function
(	O
localname	pointer
,	O
0	int
)	O
;	O
mc_extfsdir	pointer
=	O
concat_dir_and_file	function
(	O
mc_home	pointer
,	O
"extfs"	pointer
PATH_SEP_STR	pointer
)	O
;	O
cmd	pointer
=	O
g_strconcat	function
(	O
mc_extfsdir	pointer
,	O
extfs_prefixes	array
[	O
archive	pointer
->	O
fstype	int
]	O
,	O
extfs_cmd	pointer
,	O
archive_name	pointer
,	O
" "	pointer
,	O
quoted_file	pointer
,	O
" "	pointer
,	O
quoted_localname	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
g_free	function
(	O
quoted_file	pointer
)	O
;	O
g_free	function
(	O
quoted_localname	pointer
)	O
;	O
g_free	function
(	O
mc_extfsdir	pointer
)	O
;	O
g_free	function
(	O
archive_name	pointer
)	O
;	O
open_error_pipe	function
(	O
)	O
;	O
retval	pointer
=	O
my_system	function
(	O
EXECUTE_AS_SHELL	O
,	O
shell	pointer
,	O
cmd	pointer
)	O
;	O
g_free	function
(	O
cmd	pointer
)	O
;	O
close_error_pipe	function
(	O
1	int
,	O
NULL	O
)	O
;	O
return	O
retval	pointer
;	O
}	O
static	O
void	O
extfs_run	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
const	O
char	O
*	O
file	pointer
)	O
{	O
struct	O
archive	pointer
*	O
archive	pointer
=	O
NULL	O
;	O
char	O
*	O
p	pointer
,	O
*	O
q	pointer
,	O
*	O
archive_name	pointer
,	O
*	O
mc_extfsdir	pointer
;	O
char	O
*	O
cmd	pointer
;	O
if	O
(	O
(	O
p	pointer
=	O
extfs_get_path	function
(	O
me	pointer
,	O
file	pointer
,	O
&	O
archive	pointer
,	O
0	int
)	O
)	O
==	O
NULL	O
)	O
return	O
;	O
q	pointer
=	O
name_quote	function
(	O
p	pointer
,	O
0	int
)	O
;	O
g_free	function
(	O
p	pointer
)	O
;	O
archive_name	pointer
=	O
name_quote	function
(	O
extfs_get_archive_name	function
(	O
archive	pointer
)	O
,	O
0	int
)	O
;	O
mc_extfsdir	pointer
=	O
concat_dir_and_file	function
(	O
mc_home	pointer
,	O
"extfs"	pointer
PATH_SEP_STR	pointer
)	O
;	O
cmd	pointer
=	O
g_strconcat	function
(	O
mc_extfsdir	pointer
,	O
extfs_prefixes	array
[	O
archive	pointer
->	O
fstype	int
]	O
,	O
" run "	pointer
,	O
archive_name	pointer
,	O
" "	pointer
,	O
q	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
g_free	function
(	O
mc_extfsdir	pointer
)	O
;	O
g_free	function
(	O
archive_name	pointer
)	O
;	O
g_free	function
(	O
q	pointer
)	O
;	O
shell_execute	function
(	O
cmd	pointer
,	O
0	int
)	O
;	O
g_free	function
(	O
cmd	pointer
)	O
;	O
}	O
static	O
void	O
*	O
extfs_open	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
const	O
char	O
*	O
file	pointer
,	O
int	O
flags	enum
,	O
int	O
mode	int
)	O
{	O
struct	O
pseudofile	struct
*	O
extfs_info	pointer
;	O
struct	O
archive	pointer
*	O
archive	pointer
=	O
NULL	O
;	O
char	O
*	O
q	pointer
;	O
struct	O
entry	struct
*	O
entry	struct
;	O
int	O
local_handle	int
;	O
int	O
created	int
=	O
0	int
;	O
if	O
(	O
(	O
q	pointer
=	O
extfs_get_path	function
(	O
me	pointer
,	O
file	pointer
,	O
&	O
archive	pointer
,	O
0	int
)	O
)	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
entry	struct
=	O
extfs_find_entry	function
(	O
archive	pointer
->	O
root_entry	pointer
,	O
q	pointer
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
entry	struct
==	O
NULL	O
&&	O
(	O
flags	enum
&	O
O_CREAT	int
)	O
)	O
{	O
entry	struct
=	O
extfs_find_entry	function
(	O
archive	pointer
->	O
root_entry	pointer
,	O
q	pointer
,	O
0	int
,	O
1	int
)	O
;	O
created	int
=	O
(	O
entry	struct
!=	O
NULL	O
)	O
;	O
}	O
g_free	function
(	O
q	pointer
)	O
;	O
if	O
(	O
entry	struct
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
(	O
entry	struct
=	O
extfs_resolve_symlinks	function
(	O
entry	struct
)	O
)	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
S_ISDIR	O
(	O
entry	struct
->	O
inode	struct
->	O
mode	int
)	O
)	O
ERRNOR	O
(	O
EISDIR	int
,	O
NULL	O
)	O
;	O
if	O
(	O
entry	struct
->	O
inode	struct
->	O
local_filename	pointer
==	O
NULL	O
)	O
{	O
char	O
*	O
local_filename	pointer
;	O
local_handle	int
=	O
vfs_mkstemps	function
(	O
&	O
local_filename	pointer
,	O
"extfs"	pointer
,	O
entry	struct
->	O
name	pointer
)	O
;	O
if	O
(	O
local_handle	int
==	O
-	O
1	int
)	O
return	O
NULL	O
;	O
close	pointer
(	O
local_handle	int
)	O
;	O
if	O
(	O
!	O
created	int
&&	O
!	O
(	O
flags	enum
&	O
O_TRUNC	int
)	O
&&	O
extfs_cmd	pointer
(	O
" copyout "	pointer
,	O
archive	pointer
,	O
entry	struct
,	O
local_filename	pointer
)	O
)	O
{	O
unlink	function
(	O
local_filename	pointer
)	O
;	O
free	function
(	O
local_filename	pointer
)	O
;	O
my_errno	int
=	O
EIO	int
;	O
return	O
NULL	O
;	O
}	O
entry	struct
->	O
inode	struct
->	O
local_filename	pointer
=	O
local_filename	pointer
;	O
}	O
local_handle	int
=	O
open	function
(	O
entry	struct
->	O
inode	struct
->	O
local_filename	pointer
,	O
NO_LINEAR	O
(	O
flags	enum
)	O
,	O
mode	int
)	O
;	O
if	O
(	O
local_handle	int
==	O
-	O
1	int
)	O
ERRNOR	O
(	O
EIO	int
,	O
NULL	O
)	O
;	O
extfs_info	pointer
=	O
g_new	O
(	O
struct	O
pseudofile	struct
,	O
1	int
)	O
;	O
extfs_info	pointer
->	O
archive	pointer
=	O
archive	pointer
;	O
extfs_info	pointer
->	O
entry	struct
=	O
entry	struct
;	O
extfs_info	pointer
->	O
has_changed	int
=	O
created	int
;	O
extfs_info	pointer
->	O
local_handle	int
=	O
local_handle	int
;	O
vfs_rmstamp	function
(	O
&	O
vfs_extfs_ops	struct
,	O
(	O
vfsid	pointer
)	O
archive	pointer
)	O
;	O
archive	pointer
->	O
fd_usage	int
++	O
;	O
return	O
extfs_info	pointer
;	O
}	O
static	O
int	O
extfs_read	function
(	O
void	O
*	O
data	pointer
,	O
char	O
*	O
buffer	pointer
,	O
int	O
count	int
)	O
{	O
struct	O
pseudofile	struct
*	O
file	pointer
=	O
(	O
struct	O
pseudofile	struct
*	O
)	O
data	pointer
;	O
return	O
read	pointer
(	O
file	pointer
->	O
local_handle	int
,	O
buffer	pointer
,	O
count	int
)	O
;	O
}	O
static	O
int	O
extfs_close	function
(	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
pseudofile	struct
*	O
file	pointer
;	O
int	O
errno_code	int
=	O
0	int
;	O
file	pointer
=	O
(	O
struct	O
pseudofile	struct
*	O
)	O
data	pointer
;	O
close	pointer
(	O
file	pointer
->	O
local_handle	int
)	O
;	O
if	O
(	O
file	pointer
->	O
has_changed	int
)	O
{	O
if	O
(	O
extfs_cmd	pointer
(	O
" copyin "	pointer
,	O
file	pointer
->	O
archive	pointer
,	O
file	pointer
->	O
entry	struct
,	O
file	pointer
->	O
entry	struct
->	O
inode	struct
->	O
local_filename	pointer
)	O
)	O
errno_code	int
=	O
EIO	int
;	O
{	O
struct	O
stat	struct
file_status	struct
;	O
if	O
(	O
stat	struct
(	O
file	pointer
->	O
entry	struct
->	O
inode	struct
->	O
local_filename	pointer
,	O
&	O
file_status	struct
)	O
!=	O
0	int
)	O
errno_code	int
=	O
EIO	int
;	O
else	O
file	pointer
->	O
entry	struct
->	O
inode	struct
->	O
size	long
=	O
file_status	struct
.	O
st_size	long
;	O
}	O
file	pointer
->	O
entry	struct
->	O
inode	struct
->	O
mtime	long
=	O
time	long
(	O
NULL	O
)	O
;	O
}	O
file	pointer
->	O
archive	pointer
->	O
fd_usage	int
--	O
;	O
if	O
(	O
!	O
file	pointer
->	O
archive	pointer
->	O
fd_usage	int
)	O
vfs_stamp_create	function
(	O
&	O
vfs_extfs_ops	struct
,	O
file	pointer
->	O
archive	pointer
)	O
;	O
g_free	function
(	O
data	pointer
)	O
;	O
if	O
(	O
errno_code	int
)	O
ERRNOR	O
(	O
EIO	int
,	O
-	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
struct	O
entry	struct
*	O
extfs_find_entry_int	function
(	O
struct	O
entry	struct
*	O
dir	pointer
,	O
char	O
*	O
name	pointer
,	O
struct	O
loop_protect	struct
*	O
list	pointer
,	O
int	O
make_dirs	int
,	O
int	O
make_file	int
)	O
{	O
struct	O
entry	struct
*	O
pent	pointer
,	O
*	O
pdir	pointer
;	O
char	O
*	O
p	pointer
,	O
*	O
q	pointer
,	O
*	O
name_end	pointer
;	O
char	O
c	int
;	O
if	O
(	O
*	O
name	pointer
==	O
'/'	O
)	O
{	O
name	pointer
++	O
;	O
dir	pointer
=	O
dir	pointer
->	O
inode	struct
->	O
archive	pointer
->	O
root_entry	pointer
;	O
}	O
pent	pointer
=	O
dir	pointer
;	O
p	pointer
=	O
name	pointer
;	O
name_end	pointer
=	O
name	pointer
+	O
strlen	function
(	O
name	pointer
)	O
;	O
q	pointer
=	O
strchr	function
(	O
p	pointer
,	O
'/'	O
)	O
;	O
c	int
=	O
'/'	O
;	O
if	O
(	O
!	O
q	pointer
)	O
q	pointer
=	O
strchr	function
(	O
p	pointer
,	O
0	int
)	O
;	O
for	O
(	O
;	O
pent	pointer
!=	O
NULL	O
&&	O
c	int
&&	O
*	O
p	pointer
;	O
)	O
{	O
c	int
=	O
*	O
q	pointer
;	O
*	O
q	pointer
=	O
0	int
;	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"."	pointer
)	O
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
p	pointer
,	O
".."	pointer
)	O
)	O
pent	pointer
=	O
pent	pointer
->	O
dir	pointer
;	O
else	O
{	O
if	O
(	O
(	O
pent	pointer
=	O
extfs_resolve_symlinks_int	function
(	O
pent	pointer
,	O
list	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
*	O
q	pointer
=	O
c	int
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
!	O
S_ISDIR	O
(	O
pent	pointer
->	O
inode	struct
->	O
mode	int
)	O
)	O
{	O
*	O
q	pointer
=	O
c	int
;	O
notadir	int
=	O
1	int
;	O
return	O
NULL	O
;	O
}	O
pdir	pointer
=	O
pent	pointer
;	O
for	O
(	O
pent	pointer
=	O
pent	pointer
->	O
inode	struct
->	O
first_in_subdir	pointer
;	O
pent	pointer
;	O
pent	pointer
=	O
pent	pointer
->	O
next_in_dir	pointer
)	O
if	O
(	O
!	O
strcmp	function
(	O
pent	pointer
->	O
name	pointer
,	O
p	pointer
)	O
)	O
{	O
if	O
(	O
q	pointer
+	O
1	int
>	O
name_end	pointer
)	O
{	O
*	O
q	pointer
=	O
c	int
;	O
notadir	int
=	O
!	O
S_ISDIR	O
(	O
pent	pointer
->	O
inode	struct
->	O
mode	int
)	O
;	O
return	O
pent	pointer
;	O
}	O
break	O
;	O
}	O
if	O
(	O
pent	pointer
==	O
NULL	O
&&	O
make_dirs	int
)	O
{	O
pent	pointer
=	O
extfs_generate_entry	function
(	O
dir	pointer
->	O
inode	struct
->	O
archive	pointer
,	O
p	pointer
,	O
pdir	pointer
,	O
S_IFDIR	O
|	O
0777	int
)	O
;	O
}	O
if	O
(	O
pent	pointer
==	O
NULL	O
&&	O
make_file	int
)	O
{	O
pent	pointer
=	O
extfs_generate_entry	function
(	O
dir	pointer
->	O
inode	struct
->	O
archive	pointer
,	O
p	pointer
,	O
pdir	pointer
,	O
S_IFREG	O
|	O
0666	int
)	O
;	O
}	O
}	O
}	O
*	O
q	pointer
=	O
c	int
;	O
p	pointer
=	O
q	pointer
+	O
1	int
;	O
q	pointer
=	O
strchr	function
(	O
p	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
!	O
q	pointer
)	O
q	pointer
=	O
strchr	function
(	O
p	pointer
,	O
0	int
)	O
;	O
}	O
if	O
(	O
pent	pointer
==	O
NULL	O
)	O
my_errno	int
=	O
ENOENT	int
;	O
return	O
pent	pointer
;	O
}	O
static	O
struct	O
entry	struct
*	O
extfs_find_entry	function
(	O
struct	O
entry	struct
*	O
dir	pointer
,	O
char	O
*	O
name	pointer
,	O
int	O
make_dirs	int
,	O
int	O
make_file	int
)	O
{	O
struct	O
entry	struct
*	O
res	pointer
;	O
errloop	int
=	O
0	int
;	O
notadir	int
=	O
0	int
;	O
res	pointer
=	O
extfs_find_entry_int	function
(	O
dir	pointer
,	O
name	pointer
,	O
NULL	O
,	O
make_dirs	int
,	O
make_file	int
)	O
;	O
if	O
(	O
res	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
errloop	int
)	O
my_errno	int
=	O
ELOOP	int
;	O
else	O
if	O
(	O
notadir	int
)	O
my_errno	int
=	O
ENOTDIR	int
;	O
}	O
return	O
res	pointer
;	O
}	O
static	O
int	O
extfs_errno	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
)	O
{	O
(	O
void	O
)	O
me	pointer
;	O
return	O
my_errno	int
;	O
}	O
static	O
void	O
*	O
extfs_opendir	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
const	O
char	O
*	O
dirname	pointer
)	O
{	O
struct	O
archive	pointer
*	O
archive	pointer
=	O
NULL	O
;	O
char	O
*	O
q	pointer
;	O
struct	O
entry	struct
*	O
entry	struct
;	O
struct	O
entry	struct
*	O
*	O
info	pointer
;	O
if	O
(	O
(	O
q	pointer
=	O
extfs_get_path	function
(	O
me	pointer
,	O
dirname	pointer
,	O
&	O
archive	pointer
,	O
0	int
)	O
)	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
entry	struct
=	O
extfs_find_entry	function
(	O
archive	pointer
->	O
root_entry	pointer
,	O
q	pointer
,	O
0	int
,	O
0	int
)	O
;	O
g_free	function
(	O
q	pointer
)	O
;	O
if	O
(	O
entry	struct
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
(	O
entry	struct
=	O
extfs_resolve_symlinks	function
(	O
entry	struct
)	O
)	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
!	O
S_ISDIR	O
(	O
entry	struct
->	O
inode	struct
->	O
mode	int
)	O
)	O
ERRNOR	O
(	O
ENOTDIR	int
,	O
NULL	O
)	O
;	O
info	pointer
=	O
g_new	O
(	O
struct	O
entry	struct
*	O
,	O
2	int
)	O
;	O
info	pointer
[	O
0	int
]	O
=	O
entry	struct
->	O
inode	struct
->	O
first_in_subdir	pointer
;	O
info	pointer
[	O
1	int
]	O
=	O
entry	struct
->	O
inode	struct
->	O
first_in_subdir	pointer
;	O
return	O
info	pointer
;	O
}	O
static	O
void	O
*	O
extfs_readdir	function
(	O
void	O
*	O
data	pointer
)	O
{	O
static	O
union	O
vfs_dirent	union
dir	pointer
;	O
struct	O
entry	struct
*	O
*	O
info	pointer
=	O
(	O
struct	O
entry	struct
*	O
*	O
)	O
data	pointer
;	O
if	O
(	O
!	O
*	O
info	pointer
)	O
return	O
NULL	O
;	O
g_strlcpy	function
(	O
dir	pointer
.	O
dent	pointer
.	O
d_name	array
,	O
(	O
*	O
info	pointer
)	O
->	O
name	pointer
,	O
MC_MAXPATHLEN	O
)	O
;	O
compute_namelen	function
(	O
&	O
dir	pointer
.	O
dent	pointer
)	O
;	O
*	O
info	pointer
=	O
(	O
*	O
info	pointer
)	O
->	O
next_in_dir	pointer
;	O
return	O
(	O
void	O
*	O
)	O
&	O
dir	pointer
;	O
}	O
static	O
int	O
extfs_closedir	function
(	O
void	O
*	O
data	pointer
)	O
{	O
g_free	function
(	O
data	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
extfs_stat_move	function
(	O
struct	O
stat	struct
*	O
buf	pointer
,	O
const	O
struct	O
inode	struct
*	O
inode	struct
)	O
{	O
buf	pointer
->	O
st_dev	long
=	O
inode	struct
->	O
dev	int
;	O
buf	pointer
->	O
st_ino	long
=	O
inode	struct
->	O
inode	struct
;	O
buf	pointer
->	O
st_mode	int
=	O
inode	struct
->	O
mode	int
;	O
buf	pointer
->	O
st_nlink	long
=	O
inode	struct
->	O
nlink	long
;	O
buf	pointer
->	O
st_uid	int
=	O
inode	struct
->	O
uid	int
;	O
buf	pointer
->	O
st_gid	int
=	O
inode	struct
->	O
gid	int
;	O
buf	pointer
->	O
st_rdev	long
=	O
inode	struct
->	O
rdev	long
;	O
buf	pointer
->	O
st_size	long
=	O
inode	struct
->	O
size	long
;	O
buf	pointer
->	O
st_blksize	long
=	O
RECORDSIZE	int
;	O
buf	pointer
->	O
st_blocks	long
=	O
(	O
inode	struct
->	O
size	long
+	O
RECORDSIZE	int
-	O
1	int
)	O
/	O
RECORDSIZE	int
;	O
buf	pointer
->	O
st_atime	O
=	O
inode	struct
->	O
atime	long
;	O
buf	pointer
->	O
st_mtime	O
=	O
inode	struct
->	O
mtime	long
;	O
buf	pointer
->	O
st_ctime	O
=	O
inode	struct
->	O
ctime	function
;	O
}	O
static	O
int	O
extfs_internal_stat	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
const	O
char	O
*	O
path	pointer
,	O
struct	O
stat	struct
*	O
buf	pointer
,	O
int	O
resolve	int
)	O
{	O
struct	O
archive	pointer
*	O
archive	pointer
;	O
char	O
*	O
q	pointer
;	O
struct	O
entry	struct
*	O
entry	struct
;	O
char	O
*	O
path2	pointer
=	O
g_strdup	function
(	O
path	pointer
)	O
;	O
int	O
result	long
=	O
-	O
1	int
;	O
if	O
(	O
(	O
q	pointer
=	O
extfs_get_path_mangle	function
(	O
me	pointer
,	O
path2	pointer
,	O
&	O
archive	pointer
,	O
0	int
)	O
)	O
==	O
NULL	O
)	O
goto	O
cleanup	O
;	O
entry	struct
=	O
extfs_find_entry	function
(	O
archive	pointer
->	O
root_entry	pointer
,	O
q	pointer
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
entry	struct
==	O
NULL	O
)	O
goto	O
cleanup	O
;	O
if	O
(	O
resolve	int
&&	O
(	O
entry	struct
=	O
extfs_resolve_symlinks	function
(	O
entry	struct
)	O
)	O
==	O
NULL	O
)	O
goto	O
cleanup	O
;	O
extfs_stat_move	function
(	O
buf	pointer
,	O
entry	struct
->	O
inode	struct
)	O
;	O
result	long
=	O
0	int
;	O
cleanup	O
:	O
g_free	function
(	O
path2	pointer
)	O
;	O
return	O
result	long
;	O
}	O
static	O
int	O
extfs_stat	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
const	O
char	O
*	O
path	pointer
,	O
struct	O
stat	struct
*	O
buf	pointer
)	O
{	O
return	O
extfs_internal_stat	function
(	O
me	pointer
,	O
path	pointer
,	O
buf	pointer
,	O
1	int
)	O
;	O
}	O
static	O
int	O
extfs_lstat	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
const	O
char	O
*	O
path	pointer
,	O
struct	O
stat	struct
*	O
buf	pointer
)	O
{	O
return	O
extfs_internal_stat	function
(	O
me	pointer
,	O
path	pointer
,	O
buf	pointer
,	O
0	int
)	O
;	O
}	O
static	O
int	O
extfs_fstat	function
(	O
void	O
*	O
data	pointer
,	O
struct	O
stat	struct
*	O
buf	pointer
)	O
{	O
struct	O
pseudofile	struct
*	O
file	pointer
=	O
(	O
struct	O
pseudofile	struct
*	O
)	O
data	pointer
;	O
extfs_stat_move	function
(	O
buf	pointer
,	O
file	pointer
->	O
entry	struct
->	O
inode	struct
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
extfs_readlink	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
const	O
char	O
*	O
path	pointer
,	O
char	O
*	O
buf	pointer
,	O
size_t	long
size	long
)	O
{	O
struct	O
archive	pointer
*	O
archive	pointer
;	O
char	O
*	O
q	pointer
;	O
size_t	long
len	int
;	O
struct	O
entry	struct
*	O
entry	struct
;	O
char	O
*	O
mpath	pointer
=	O
g_strdup	function
(	O
path	pointer
)	O
;	O
int	O
result	long
=	O
-	O
1	int
;	O
if	O
(	O
(	O
q	pointer
=	O
extfs_get_path_mangle	function
(	O
me	pointer
,	O
mpath	pointer
,	O
&	O
archive	pointer
,	O
0	int
)	O
)	O
==	O
NULL	O
)	O
goto	O
cleanup	O
;	O
entry	struct
=	O
extfs_find_entry	function
(	O
archive	pointer
->	O
root_entry	pointer
,	O
q	pointer
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
entry	struct
==	O
NULL	O
)	O
goto	O
cleanup	O
;	O
if	O
(	O
!	O
S_ISLNK	O
(	O
entry	struct
->	O
inode	struct
->	O
mode	int
)	O
)	O
{	O
me	pointer
->	O
verrno	int
=	O
EINVAL	int
;	O
goto	O
cleanup	O
;	O
}	O
len	int
=	O
strlen	function
(	O
entry	struct
->	O
inode	struct
->	O
linkname	pointer
)	O
;	O
if	O
(	O
size	long
<	O
len	int
)	O
len	int
=	O
size	long
;	O
memcpy	function
(	O
buf	pointer
,	O
entry	struct
->	O
inode	struct
->	O
linkname	pointer
,	O
result	long
=	O
len	int
)	O
;	O
cleanup	O
:	O
g_free	function
(	O
mpath	pointer
)	O
;	O
return	O
result	long
;	O
}	O
static	O
int	O
extfs_chmod	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
const	O
char	O
*	O
path	pointer
,	O
int	O
mode	int
)	O
{	O
(	O
void	O
)	O
me	pointer
;	O
(	O
void	O
)	O
path	pointer
;	O
(	O
void	O
)	O
mode	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
extfs_write	function
(	O
void	O
*	O
data	pointer
,	O
const	O
char	O
*	O
buf	pointer
,	O
int	O
nbyte	int
)	O
{	O
struct	O
pseudofile	struct
*	O
file	pointer
=	O
(	O
struct	O
pseudofile	struct
*	O
)	O
data	pointer
;	O
file	pointer
->	O
has_changed	int
=	O
1	int
;	O
return	O
write	pointer
(	O
file	pointer
->	O
local_handle	int
,	O
buf	pointer
,	O
nbyte	int
)	O
;	O
}	O
static	O
int	O
extfs_unlink	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
const	O
char	O
*	O
file	pointer
)	O
{	O
struct	O
archive	pointer
*	O
archive	pointer
;	O
char	O
*	O
q	pointer
,	O
*	O
mpath	pointer
=	O
g_strdup	function
(	O
file	pointer
)	O
;	O
struct	O
entry	struct
*	O
entry	struct
;	O
int	O
result	long
=	O
-	O
1	int
;	O
if	O
(	O
(	O
q	pointer
=	O
extfs_get_path_mangle	function
(	O
me	pointer
,	O
mpath	pointer
,	O
&	O
archive	pointer
,	O
0	int
)	O
)	O
==	O
NULL	O
)	O
goto	O
cleanup	O
;	O
entry	struct
=	O
extfs_find_entry	function
(	O
archive	pointer
->	O
root_entry	pointer
,	O
q	pointer
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
entry	struct
==	O
NULL	O
)	O
goto	O
cleanup	O
;	O
if	O
(	O
(	O
entry	struct
=	O
extfs_resolve_symlinks	function
(	O
entry	struct
)	O
)	O
==	O
NULL	O
)	O
goto	O
cleanup	O
;	O
if	O
(	O
S_ISDIR	O
(	O
entry	struct
->	O
inode	struct
->	O
mode	int
)	O
)	O
{	O
me	pointer
->	O
verrno	int
=	O
EISDIR	int
;	O
goto	O
cleanup	O
;	O
}	O
if	O
(	O
extfs_cmd	pointer
(	O
" rm "	pointer
,	O
archive	pointer
,	O
entry	struct
,	O
""	pointer
)	O
)	O
{	O
my_errno	int
=	O
EIO	int
;	O
goto	O
cleanup	O
;	O
}	O
extfs_remove_entry	function
(	O
entry	struct
)	O
;	O
result	long
=	O
0	int
;	O
cleanup	O
:	O
g_free	function
(	O
mpath	pointer
)	O
;	O
return	O
result	long
;	O
}	O
static	O
int	O
extfs_mkdir	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
const	O
char	O
*	O
path	pointer
,	O
mode_t	int
mode	int
)	O
{	O
struct	O
archive	pointer
*	O
archive	pointer
;	O
char	O
*	O
q	pointer
,	O
*	O
mpath	pointer
=	O
g_strdup	function
(	O
path	pointer
)	O
;	O
struct	O
entry	struct
*	O
entry	struct
;	O
int	O
result	long
=	O
-	O
1	int
;	O
(	O
void	O
)	O
mode	int
;	O
if	O
(	O
(	O
q	pointer
=	O
extfs_get_path_mangle	function
(	O
me	pointer
,	O
mpath	pointer
,	O
&	O
archive	pointer
,	O
0	int
)	O
)	O
==	O
NULL	O
)	O
goto	O
cleanup	O
;	O
entry	struct
=	O
extfs_find_entry	function
(	O
archive	pointer
->	O
root_entry	pointer
,	O
q	pointer
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
entry	struct
!=	O
NULL	O
)	O
{	O
me	pointer
->	O
verrno	int
=	O
EEXIST	int
;	O
goto	O
cleanup	O
;	O
}	O
entry	struct
=	O
extfs_find_entry	function
(	O
archive	pointer
->	O
root_entry	pointer
,	O
q	pointer
,	O
1	int
,	O
0	int
)	O
;	O
if	O
(	O
entry	struct
==	O
NULL	O
)	O
goto	O
cleanup	O
;	O
if	O
(	O
(	O
entry	struct
=	O
extfs_resolve_symlinks	function
(	O
entry	struct
)	O
)	O
==	O
NULL	O
)	O
goto	O
cleanup	O
;	O
if	O
(	O
!	O
S_ISDIR	O
(	O
entry	struct
->	O
inode	struct
->	O
mode	int
)	O
)	O
{	O
me	pointer
->	O
verrno	int
=	O
ENOTDIR	int
;	O
goto	O
cleanup	O
;	O
}	O
if	O
(	O
extfs_cmd	pointer
(	O
" mkdir "	pointer
,	O
archive	pointer
,	O
entry	struct
,	O
""	pointer
)	O
)	O
{	O
my_errno	int
=	O
EIO	int
;	O
extfs_remove_entry	function
(	O
entry	struct
)	O
;	O
goto	O
cleanup	O
;	O
}	O
result	long
=	O
0	int
;	O
cleanup	O
:	O
g_free	function
(	O
mpath	pointer
)	O
;	O
return	O
result	long
;	O
}	O
static	O
int	O
extfs_rmdir	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
const	O
char	O
*	O
path	pointer
)	O
{	O
struct	O
archive	pointer
*	O
archive	pointer
;	O
char	O
*	O
q	pointer
,	O
*	O
mpath	pointer
=	O
g_strdup	function
(	O
path	pointer
)	O
;	O
struct	O
entry	struct
*	O
entry	struct
;	O
int	O
result	long
=	O
-	O
1	int
;	O
if	O
(	O
(	O
q	pointer
=	O
extfs_get_path_mangle	function
(	O
me	pointer
,	O
mpath	pointer
,	O
&	O
archive	pointer
,	O
0	int
)	O
)	O
==	O
NULL	O
)	O
goto	O
cleanup	O
;	O
entry	struct
=	O
extfs_find_entry	function
(	O
archive	pointer
->	O
root_entry	pointer
,	O
q	pointer
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
entry	struct
==	O
NULL	O
)	O
goto	O
cleanup	O
;	O
if	O
(	O
(	O
entry	struct
=	O
extfs_resolve_symlinks	function
(	O
entry	struct
)	O
)	O
==	O
NULL	O
)	O
goto	O
cleanup	O
;	O
if	O
(	O
!	O
S_ISDIR	O
(	O
entry	struct
->	O
inode	struct
->	O
mode	int
)	O
)	O
{	O
me	pointer
->	O
verrno	int
=	O
ENOTDIR	int
;	O
goto	O
cleanup	O
;	O
}	O
if	O
(	O
extfs_cmd	pointer
(	O
" rmdir "	pointer
,	O
archive	pointer
,	O
entry	struct
,	O
""	pointer
)	O
)	O
{	O
my_errno	int
=	O
EIO	int
;	O
goto	O
cleanup	O
;	O
}	O
extfs_remove_entry	function
(	O
entry	struct
)	O
;	O
result	long
=	O
0	int
;	O
cleanup	O
:	O
g_free	function
(	O
mpath	pointer
)	O
;	O
return	O
result	long
;	O
}	O
static	O
int	O
extfs_chdir	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
const	O
char	O
*	O
path	pointer
)	O
{	O
struct	O
archive	pointer
*	O
archive	pointer
=	O
NULL	O
;	O
char	O
*	O
q	pointer
;	O
struct	O
entry	struct
*	O
entry	struct
;	O
my_errno	int
=	O
ENOTDIR	int
;	O
if	O
(	O
(	O
q	pointer
=	O
extfs_get_path	function
(	O
me	pointer
,	O
path	pointer
,	O
&	O
archive	pointer
,	O
0	int
)	O
)	O
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
entry	struct
=	O
extfs_find_entry	function
(	O
archive	pointer
->	O
root_entry	pointer
,	O
q	pointer
,	O
0	int
,	O
0	int
)	O
;	O
g_free	function
(	O
q	pointer
)	O
;	O
if	O
(	O
!	O
entry	struct
)	O
return	O
-	O
1	int
;	O
entry	struct
=	O
extfs_resolve_symlinks	function
(	O
entry	struct
)	O
;	O
if	O
(	O
(	O
!	O
entry	struct
)	O
||	O
(	O
!	O
S_ISDIR	O
(	O
entry	struct
->	O
inode	struct
->	O
mode	int
)	O
)	O
)	O
return	O
-	O
1	int
;	O
my_errno	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
extfs_lseek	function
(	O
void	O
*	O
data	pointer
,	O
off_t	long
offset	long
,	O
int	O
whence	int
)	O
{	O
struct	O
pseudofile	struct
*	O
file	pointer
=	O
(	O
struct	O
pseudofile	struct
*	O
)	O
data	pointer
;	O
return	O
lseek	function
(	O
file	pointer
->	O
local_handle	int
,	O
offset	long
,	O
whence	int
)	O
;	O
}	O
static	O
vfsid	pointer
extfs_getid	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
const	O
char	O
*	O
path	pointer
)	O
{	O
struct	O
archive	pointer
*	O
archive	pointer
=	O
NULL	O
;	O
char	O
*	O
p	pointer
;	O
if	O
(	O
!	O
(	O
p	pointer
=	O
extfs_get_path	function
(	O
me	pointer
,	O
path	pointer
,	O
&	O
archive	pointer
,	O
1	int
)	O
)	O
)	O
return	O
NULL	O
;	O
g_free	function
(	O
p	pointer
)	O
;	O
return	O
(	O
vfsid	pointer
)	O
archive	pointer
;	O
}	O
static	O
int	O
extfs_nothingisopen	function
(	O
vfsid	pointer
id	int
)	O
{	O
if	O
(	O
(	O
(	O
struct	O
archive	pointer
*	O
)	O
id	int
)	O
->	O
fd_usage	int
<=	O
0	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
extfs_remove_entry	function
(	O
struct	O
entry	struct
*	O
e	pointer
)	O
{	O
int	O
i	array
=	O
--	O
(	O
e	pointer
->	O
inode	struct
->	O
nlink	long
)	O
;	O
struct	O
entry	struct
*	O
pe	pointer
,	O
*	O
ent	pointer
,	O
*	O
prev	pointer
;	O
if	O
(	O
S_ISDIR	O
(	O
e	pointer
->	O
inode	struct
->	O
mode	int
)	O
&&	O
e	pointer
->	O
inode	struct
->	O
first_in_subdir	pointer
!=	O
NULL	O
)	O
{	O
struct	O
entry	struct
*	O
f	float
=	O
e	pointer
->	O
inode	struct
->	O
first_in_subdir	pointer
;	O
e	pointer
->	O
inode	struct
->	O
first_in_subdir	pointer
=	O
NULL	O
;	O
extfs_remove_entry	function
(	O
f	float
)	O
;	O
}	O
pe	pointer
=	O
e	pointer
->	O
dir	pointer
;	O
if	O
(	O
e	pointer
==	O
pe	pointer
->	O
inode	struct
->	O
first_in_subdir	pointer
)	O
pe	pointer
->	O
inode	struct
->	O
first_in_subdir	pointer
=	O
e	pointer
->	O
next_in_dir	pointer
;	O
prev	pointer
=	O
NULL	O
;	O
for	O
(	O
ent	pointer
=	O
pe	pointer
->	O
inode	struct
->	O
first_in_subdir	pointer
;	O
ent	pointer
&&	O
ent	pointer
->	O
next_in_dir	pointer
;	O
ent	pointer
=	O
ent	pointer
->	O
next_in_dir	pointer
)	O
if	O
(	O
e	pointer
==	O
ent	pointer
->	O
next_in_dir	pointer
)	O
{	O
prev	pointer
=	O
ent	pointer
;	O
break	O
;	O
}	O
if	O
(	O
prev	pointer
)	O
prev	pointer
->	O
next_in_dir	pointer
=	O
e	pointer
->	O
next_in_dir	pointer
;	O
if	O
(	O
e	pointer
==	O
pe	pointer
->	O
inode	struct
->	O
last_in_subdir	pointer
)	O
pe	pointer
->	O
inode	struct
->	O
last_in_subdir	pointer
=	O
prev	pointer
;	O
if	O
(	O
i	array
<=	O
0	int
)	O
{	O
if	O
(	O
e	pointer
->	O
inode	struct
->	O
local_filename	pointer
!=	O
NULL	O
)	O
{	O
unlink	function
(	O
e	pointer
->	O
inode	struct
->	O
local_filename	pointer
)	O
;	O
free	function
(	O
e	pointer
->	O
inode	struct
->	O
local_filename	pointer
)	O
;	O
}	O
g_free	function
(	O
e	pointer
->	O
inode	struct
->	O
linkname	pointer
)	O
;	O
g_free	function
(	O
e	pointer
->	O
inode	struct
)	O
;	O
}	O
g_free	function
(	O
e	pointer
->	O
name	pointer
)	O
;	O
g_free	function
(	O
e	pointer
)	O
;	O
}	O
static	O
void	O
extfs_free_entry	function
(	O
struct	O
entry	struct
*	O
e	pointer
)	O
{	O
int	O
i	array
=	O
--	O
(	O
e	pointer
->	O
inode	struct
->	O
nlink	long
)	O
;	O
if	O
(	O
S_ISDIR	O
(	O
e	pointer
->	O
inode	struct
->	O
mode	int
)	O
&&	O
e	pointer
->	O
inode	struct
->	O
first_in_subdir	pointer
!=	O
NULL	O
)	O
{	O
struct	O
entry	struct
*	O
f	float
=	O
e	pointer
->	O
inode	struct
->	O
first_in_subdir	pointer
;	O
e	pointer
->	O
inode	struct
->	O
first_in_subdir	pointer
=	O
NULL	O
;	O
extfs_free_entry	function
(	O
f	float
)	O
;	O
}	O
if	O
(	O
i	array
<=	O
0	int
)	O
{	O
if	O
(	O
e	pointer
->	O
inode	struct
->	O
local_filename	pointer
!=	O
NULL	O
)	O
{	O
unlink	function
(	O
e	pointer
->	O
inode	struct
->	O
local_filename	pointer
)	O
;	O
free	function
(	O
e	pointer
->	O
inode	struct
->	O
local_filename	pointer
)	O
;	O
}	O
g_free	function
(	O
e	pointer
->	O
inode	struct
->	O
linkname	pointer
)	O
;	O
g_free	function
(	O
e	pointer
->	O
inode	struct
)	O
;	O
}	O
if	O
(	O
e	pointer
->	O
next_in_dir	pointer
!=	O
NULL	O
)	O
extfs_free_entry	function
(	O
e	pointer
->	O
next_in_dir	pointer
)	O
;	O
g_free	function
(	O
e	pointer
->	O
name	pointer
)	O
;	O
g_free	function
(	O
e	pointer
)	O
;	O
}	O
static	O
void	O
extfs_free	function
(	O
vfsid	pointer
id	int
)	O
{	O
struct	O
archive	pointer
*	O
parc	pointer
;	O
struct	O
archive	pointer
*	O
archive	pointer
=	O
(	O
struct	O
archive	pointer
*	O
)	O
id	int
;	O
if	O
(	O
archive	pointer
==	O
first_archive	pointer
)	O
{	O
first_archive	pointer
=	O
archive	pointer
->	O
next	pointer
;	O
}	O
else	O
{	O
for	O
(	O
parc	pointer
=	O
first_archive	pointer
;	O
parc	pointer
!=	O
NULL	O
;	O
parc	pointer
=	O
parc	pointer
->	O
next	pointer
)	O
if	O
(	O
parc	pointer
->	O
next	pointer
==	O
archive	pointer
)	O
{	O
parc	pointer
->	O
next	pointer
=	O
archive	pointer
->	O
next	pointer
;	O
break	O
;	O
}	O
}	O
extfs_free_archive	function
(	O
archive	pointer
)	O
;	O
}	O
static	O
char	O
*	O
extfs_getlocalcopy	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
const	O
char	O
*	O
path	pointer
)	O
{	O
struct	O
pseudofile	struct
*	O
fp	pointer
=	O
(	O
struct	O
pseudofile	struct
*	O
)	O
extfs_open	function
(	O
me	pointer
,	O
path	pointer
,	O
O_RDONLY	int
,	O
0	int
)	O
;	O
char	O
*	O
p	pointer
;	O
if	O
(	O
fp	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
fp	pointer
->	O
entry	struct
->	O
inode	struct
->	O
local_filename	pointer
==	O
NULL	O
)	O
{	O
extfs_close	function
(	O
(	O
void	O
*	O
)	O
fp	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
p	pointer
=	O
g_strdup	function
(	O
fp	pointer
->	O
entry	struct
->	O
inode	struct
->	O
local_filename	pointer
)	O
;	O
fp	pointer
->	O
archive	pointer
->	O
fd_usage	int
++	O
;	O
extfs_close	function
(	O
(	O
void	O
*	O
)	O
fp	pointer
)	O
;	O
return	O
p	pointer
;	O
}	O
static	O
int	O
extfs_ungetlocalcopy	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
const	O
char	O
*	O
path	pointer
,	O
const	O
char	O
*	O
local	pointer
,	O
int	O
has_changed	int
)	O
{	O
struct	O
pseudofile	struct
*	O
fp	pointer
=	O
(	O
struct	O
pseudofile	struct
*	O
)	O
extfs_open	function
(	O
me	pointer
,	O
path	pointer
,	O
O_RDONLY	int
,	O
0	int
)	O
;	O
if	O
(	O
fp	pointer
==	O
NULL	O
)	O
return	O
0	int
;	O
if	O
(	O
!	O
strcmp	function
(	O
fp	pointer
->	O
entry	struct
->	O
inode	struct
->	O
local_filename	pointer
,	O
local	pointer
)	O
)	O
{	O
fp	pointer
->	O
archive	pointer
->	O
fd_usage	int
--	O
;	O
fp	pointer
->	O
has_changed	int
|=	O
has_changed	int
;	O
extfs_close	function
(	O
(	O
void	O
*	O
)	O
fp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
extfs_close	function
(	O
(	O
void	O
*	O
)	O
fp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
}	O
static	O
int	O
extfs_init	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
)	O
{	O
FILE	struct
*	O
cfg	pointer
;	O
char	O
*	O
mc_extfsini	pointer
;	O
char	O
key	pointer
[	O
256	int
]	O
;	O
(	O
void	O
)	O
me	pointer
;	O
mc_extfsini	pointer
=	O
concat_dir_and_file	function
(	O
mc_home	pointer
,	O
"extfs"	pointer
PATH_SEP_STR	pointer
"extfs.ini"	pointer
)	O
;	O
cfg	pointer
=	O
fopen	function
(	O
mc_extfsini	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
!	O
cfg	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Warning: file %s not found\n"	pointer
)	O
,	O
mc_extfsini	pointer
)	O
;	O
g_free	function
(	O
mc_extfsini	pointer
)	O
;	O
return	O
0	int
;	O
}	O
extfs_no	int
=	O
0	int
;	O
while	O
(	O
extfs_no	int
<	O
MAXEXTFS	int
&&	O
fgets	function
(	O
key	pointer
,	O
sizeof	O
(	O
key	pointer
)	O
,	O
cfg	pointer
)	O
)	O
{	O
char	O
*	O
c	int
;	O
if	O
(	O
*	O
key	pointer
==	O
'['	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Warning: You need to update your %s file.\n"	pointer
,	O
mc_extfsini	pointer
)	O
;	O
fclose	function
(	O
cfg	pointer
)	O
;	O
g_free	function
(	O
mc_extfsini	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
*	O
key	pointer
==	O
'#'	O
||	O
*	O
key	pointer
==	O
'\n'	O
)	O
continue	O
;	O
if	O
(	O
(	O
c	int
=	O
strchr	function
(	O
key	pointer
,	O
'\n'	O
)	O
)	O
)	O
{	O
*	O
c	int
--	O
=	O
0	int
;	O
}	O
else	O
{	O
c	int
=	O
&	O
key	pointer
[	O
strlen	function
(	O
key	pointer
)	O
-	O
1	int
]	O
;	O
}	O
extfs_need_archive	array
[	O
extfs_no	int
]	O
=	O
!	O
(	O
*	O
c	int
==	O
':'	O
)	O
;	O
if	O
(	O
*	O
c	int
==	O
':'	O
)	O
*	O
c	int
=	O
0	int
;	O
if	O
(	O
!	O
(	O
*	O
key	pointer
)	O
)	O
continue	O
;	O
extfs_prefixes	array
[	O
extfs_no	int
++	O
]	O
=	O
g_strdup	function
(	O
key	pointer
)	O
;	O
}	O
fclose	function
(	O
cfg	pointer
)	O
;	O
g_free	function
(	O
mc_extfsini	pointer
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
extfs_which	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
const	O
char	O
*	O
path	pointer
)	O
{	O
int	O
i	array
;	O
(	O
void	O
)	O
me	pointer
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
extfs_no	int
;	O
i	array
++	O
)	O
if	O
(	O
!	O
strcmp	function
(	O
path	pointer
,	O
extfs_prefixes	array
[	O
i	array
]	O
)	O
)	O
return	O
i	array
;	O
return	O
-	O
1	int
;	O
}	O
static	O
void	O
extfs_done	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
)	O
{	O
int	O
i	array
;	O
struct	O
archive	pointer
*	O
ar	pointer
;	O
(	O
void	O
)	O
me	pointer
;	O
for	O
(	O
ar	pointer
=	O
first_archive	pointer
;	O
ar	pointer
!=	O
NULL	O
;	O
)	O
{	O
extfs_free	function
(	O
(	O
vfsid	pointer
)	O
ar	pointer
)	O
;	O
ar	pointer
=	O
first_archive	pointer
;	O
}	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
extfs_no	int
;	O
i	array
++	O
)	O
g_free	function
(	O
extfs_prefixes	array
[	O
i	array
]	O
)	O
;	O
extfs_no	int
=	O
0	int
;	O
}	O
static	O
int	O
extfs_setctl	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
const	O
char	O
*	O
path	pointer
,	O
int	O
ctlop	int
,	O
void	O
*	O
arg	pointer
)	O
{	O
(	O
void	O
)	O
arg	pointer
;	O
if	O
(	O
ctlop	int
==	O
VFS_SETCTL_RUN	int
)	O
{	O
extfs_run	function
(	O
me	pointer
,	O
path	pointer
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
init_extfs	function
(	O
void	O
)	O
{	O
vfs_extfs_ops	struct
.	O
name	pointer
=	O
"extfs"	pointer
;	O
vfs_extfs_ops	struct
.	O
init	pointer
=	O
extfs_init	function
;	O
vfs_extfs_ops	struct
.	O
done	pointer
=	O
extfs_done	function
;	O
vfs_extfs_ops	struct
.	O
fill_names	pointer
=	O
extfs_fill_names	function
;	O
vfs_extfs_ops	struct
.	O
which	pointer
=	O
extfs_which	function
;	O
vfs_extfs_ops	struct
.	O
open	function
=	O
extfs_open	function
;	O
vfs_extfs_ops	struct
.	O
close	pointer
=	O
extfs_close	function
;	O
vfs_extfs_ops	struct
.	O
read	pointer
=	O
extfs_read	function
;	O
vfs_extfs_ops	struct
.	O
write	pointer
=	O
extfs_write	function
;	O
vfs_extfs_ops	struct
.	O
opendir	function
=	O
extfs_opendir	function
;	O
vfs_extfs_ops	struct
.	O
readdir	function
=	O
extfs_readdir	function
;	O
vfs_extfs_ops	struct
.	O
closedir	function
=	O
extfs_closedir	function
;	O
vfs_extfs_ops	struct
.	O
stat	struct
=	O
extfs_stat	function
;	O
vfs_extfs_ops	struct
.	O
lstat	function
=	O
extfs_lstat	function
;	O
vfs_extfs_ops	struct
.	O
fstat	function
=	O
extfs_fstat	function
;	O
vfs_extfs_ops	struct
.	O
chmod	function
=	O
extfs_chmod	function
;	O
vfs_extfs_ops	struct
.	O
readlink	function
=	O
extfs_readlink	function
;	O
vfs_extfs_ops	struct
.	O
unlink	function
=	O
extfs_unlink	function
;	O
vfs_extfs_ops	struct
.	O
chdir	function
=	O
extfs_chdir	function
;	O
vfs_extfs_ops	struct
.	O
ferrno	pointer
=	O
extfs_errno	function
;	O
vfs_extfs_ops	struct
.	O
lseek	function
=	O
extfs_lseek	function
;	O
vfs_extfs_ops	struct
.	O
getid	pointer
=	O
extfs_getid	function
;	O
vfs_extfs_ops	struct
.	O
nothingisopen	pointer
=	O
extfs_nothingisopen	function
;	O
vfs_extfs_ops	struct
.	O
free	function
=	O
extfs_free	function
;	O
vfs_extfs_ops	struct
.	O
getlocalcopy	pointer
=	O
extfs_getlocalcopy	function
;	O
vfs_extfs_ops	struct
.	O
ungetlocalcopy	pointer
=	O
extfs_ungetlocalcopy	function
;	O
vfs_extfs_ops	struct
.	O
mkdir	function
=	O
extfs_mkdir	function
;	O
vfs_extfs_ops	struct
.	O
rmdir	function
=	O
extfs_rmdir	function
;	O
vfs_extfs_ops	struct
.	O
setctl	pointer
=	O
extfs_setctl	function
;	O
vfs_register_class	function
(	O
&	O
vfs_extfs_ops	struct
)	O
;	O
}	O
