static	O
void	O
miFillPolyHelper	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
miPixel	struct
pixel	struct
,	O
int	O
y	double
,	O
unsigned	O
int	O
overall_height	int
,	O
PolyEdge	struct
*	O
left	pointer
,	O
PolyEdge	struct
*	O
right	pointer
,	O
int	O
left_count	int
,	O
int	O
right_count	int
)	O
;	O
static	O
void	O
miFillRectPolyHelper	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
miPixel	struct
pixel	struct
,	O
int	O
x	double
,	O
int	O
y	double
,	O
unsigned	O
int	O
w	int
,	O
unsigned	O
int	O
h	int
)	O
;	O
static	O
void	O
miLineArc	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
miPixel	struct
pixel	struct
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
LineFace	struct
*	O
leftFace	pointer
,	O
LineFace	struct
*	O
rightFace	pointer
,	O
double	O
xorg	double
,	O
double	O
yorg	double
,	O
bool	enum
isInt	enum
)	O
;	O
static	O
void	O
miLineJoin	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
miPixel	struct
pixel	struct
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
LineFace	struct
*	O
pLeft	pointer
,	O
LineFace	struct
*	O
pRight	pointer
)	O
;	O
static	O
void	O
miLineProjectingCap	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
miPixel	struct
pixel	struct
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
const	O
LineFace	struct
*	O
face	pointer
,	O
bool	enum
isLeft	enum
,	O
bool	enum
isInt	enum
)	O
;	O
static	O
void	O
miWideDashSegment	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
int	O
*	O
pDashNum	pointer
,	O
int	O
*	O
pDashIndex	pointer
,	O
int	O
*	O
pDashOffset	pointer
,	O
int	O
x1	double
,	O
int	O
y1	function
,	O
int	O
x2	double
,	O
int	O
y2	double
,	O
bool	enum
projectLeft	enum
,	O
bool	enum
projectRight	enum
,	O
LineFace	struct
*	O
leftFace	pointer
,	O
LineFace	struct
*	O
rightFace	pointer
)	O
;	O
static	O
void	O
miWideSegment	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
miPixel	struct
pixel	struct
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
int	O
x1	double
,	O
int	O
y1	function
,	O
int	O
x2	double
,	O
int	O
y2	double
,	O
bool	enum
projectLeft	enum
,	O
bool	enum
projectRight	enum
,	O
LineFace	struct
*	O
leftFace	pointer
,	O
LineFace	struct
*	O
rightFace	pointer
)	O
;	O
static	O
int	O
miLineArcD	function
(	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
double	O
xorg	double
,	O
double	O
yorg	double
,	O
miPoint	struct
*	O
points	pointer
,	O
unsigned	O
int	O
*	O
widths	pointer
,	O
PolyEdge	struct
*	O
edge1	pointer
,	O
int	O
edgey1	int
,	O
bool	enum
edgeleft1	enum
,	O
PolyEdge	struct
*	O
edge2	pointer
,	O
int	O
edgey2	int
,	O
bool	enum
edgeleft2	enum
)	O
;	O
static	O
int	O
miLineArcI	function
(	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
int	O
xorg	double
,	O
int	O
yorg	double
,	O
miPoint	struct
*	O
points	pointer
,	O
unsigned	O
int	O
*	O
widths	pointer
)	O
;	O
static	O
int	O
miPolyBuildEdge	function
(	O
double	O
x0	double
,	O
double	O
y0	function
,	O
double	O
k	double
,	O
int	O
dx	int
,	O
int	O
dy	int
,	O
int	O
xi	int
,	O
int	O
yi	int
,	O
bool	enum
left	pointer
,	O
PolyEdge	struct
*	O
edge	pointer
)	O
;	O
static	O
int	O
miPolyBuildPoly	function
(	O
const	O
PolyVertex	struct
*	O
vertices	pointer
,	O
const	O
PolySlope	struct
*	O
slopes	pointer
,	O
int	O
count	int
,	O
int	O
xi	int
,	O
int	O
yi	int
,	O
PolyEdge	struct
*	O
left	pointer
,	O
PolyEdge	struct
*	O
right	pointer
,	O
int	O
*	O
pnleft	pointer
,	O
int	O
*	O
pnright	pointer
,	O
unsigned	O
int	O
*	O
h	int
)	O
;	O
static	O
int	O
miRoundCapClip	function
(	O
const	O
LineFace	struct
*	O
face	pointer
,	O
bool	enum
isInt	enum
,	O
PolyEdge	struct
*	O
edge	pointer
,	O
bool	enum
*	O
leftEdge	pointer
)	O
;	O
static	O
int	O
miRoundJoinFace	function
(	O
const	O
LineFace	struct
*	O
face	pointer
,	O
PolyEdge	struct
*	O
edge	pointer
,	O
bool	enum
*	O
leftEdge	pointer
)	O
;	O
static	O
void	O
miRoundJoinClip	function
(	O
LineFace	struct
*	O
pLeft	pointer
,	O
LineFace	struct
*	O
pRight	pointer
,	O
PolyEdge	struct
*	O
edge1	pointer
,	O
PolyEdge	struct
*	O
edge2	pointer
,	O
int	O
*	O
y1	function
,	O
int	O
*	O
y2	double
,	O
bool	enum
*	O
left1	pointer
,	O
bool	enum
*	O
left2	pointer
)	O
;	O
static	O
void	O
miFillPolyHelper	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
miPixel	struct
pixel	struct
,	O
int	O
y	double
,	O
unsigned	O
int	O
overall_height	int
,	O
PolyEdge	struct
*	O
left	pointer
,	O
PolyEdge	struct
*	O
right	pointer
,	O
int	O
left_count	int
,	O
int	O
right_count	int
)	O
{	O
int	O
left_x	int
=	O
0	int
,	O
left_e	int
=	O
0	int
;	O
int	O
left_stepx	int
=	O
0	int
;	O
int	O
left_signdx	int
=	O
0	int
;	O
int	O
left_dy	int
=	O
0	int
,	O
left_dx	int
=	O
0	int
;	O
int	O
right_x	int
=	O
0	int
,	O
right_e	int
=	O
0	int
;	O
int	O
right_stepx	int
=	O
0	int
;	O
int	O
right_signdx	int
=	O
0	int
;	O
int	O
right_dy	int
=	O
0	int
,	O
right_dx	int
=	O
0	int
;	O
unsigned	O
int	O
left_height	int
=	O
0	int
,	O
right_height	int
=	O
0	int
;	O
miPoint	struct
*	O
ppt	pointer
;	O
miPoint	struct
*	O
pptInit	pointer
=	O
(	O
miPoint	struct
*	O
)	O
NULL	O
;	O
unsigned	O
int	O
*	O
pwidth	pointer
;	O
unsigned	O
int	O
*	O
pwidthInit	pointer
=	O
(	O
unsigned	O
int	O
*	O
)	O
NULL	O
;	O
pptInit	pointer
=	O
(	O
miPoint	struct
*	O
)	O
mi_xmalloc	O
(	O
overall_height	int
*	O
sizeof	O
(	O
miPoint	struct
)	O
)	O
;	O
pwidthInit	pointer
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
overall_height	int
*	O
sizeof	O
(	O
unsigned	O
int	O
)	O
)	O
;	O
ppt	pointer
=	O
pptInit	pointer
;	O
pwidth	pointer
=	O
pwidthInit	pointer
;	O
while	O
(	O
(	O
left_count	int
||	O
left_height	int
)	O
&&	O
(	O
right_count	int
||	O
right_height	int
)	O
)	O
{	O
unsigned	O
int	O
height	int
;	O
MIPOLYRELOADLEFT	O
MIPOLYRELOADRIGHT	O
height	int
=	O
UMIN	O
(	O
left_height	int
,	O
right_height	int
)	O
;	O
left_height	int
-=	O
height	int
;	O
right_height	int
-=	O
height	int
;	O
while	O
(	O
height	int
--	O
)	O
{	O
if	O
(	O
right_x	int
>=	O
left_x	int
)	O
{	O
ppt	pointer
->	O
x	double
=	O
left_x	int
;	O
ppt	pointer
->	O
y	double
=	O
y	double
;	O
ppt	pointer
++	O
;	O
*	O
pwidth	pointer
++	O
=	O
(	O
unsigned	O
int	O
)	O
(	O
right_x	int
-	O
left_x	int
+	O
1	int
)	O
;	O
}	O
y	double
++	O
;	O
MIPOLYSTEPLEFT	O
MIPOLYSTEPRIGHT	O
}	O
}	O
MI_PAINT_SPANS	O
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
ppt	pointer
-	O
pptInit	pointer
,	O
pptInit	pointer
,	O
pwidthInit	pointer
)	O
}	O
static	O
void	O
miFillRectPolyHelper	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
miPixel	struct
pixel	struct
,	O
int	O
x	double
,	O
int	O
y	double
,	O
unsigned	O
int	O
w	int
,	O
unsigned	O
int	O
h	int
)	O
{	O
miPoint	struct
*	O
ppt	pointer
,	O
*	O
pptInit	pointer
;	O
unsigned	O
int	O
*	O
pwidth	pointer
,	O
*	O
pwidthInit	pointer
;	O
pptInit	pointer
=	O
(	O
miPoint	struct
*	O
)	O
mi_xmalloc	O
(	O
h	int
*	O
sizeof	O
(	O
miPoint	struct
)	O
)	O
;	O
pwidthInit	pointer
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
h	int
*	O
sizeof	O
(	O
unsigned	O
int	O
)	O
)	O
;	O
ppt	pointer
=	O
pptInit	pointer
;	O
pwidth	pointer
=	O
pwidthInit	pointer
;	O
while	O
(	O
h	int
--	O
)	O
{	O
*	O
pwidth	pointer
++	O
=	O
w	int
;	O
ppt	pointer
->	O
x	double
=	O
x	double
;	O
ppt	pointer
->	O
y	double
=	O
y	double
;	O
ppt	pointer
++	O
;	O
y	double
++	O
;	O
}	O
MI_PAINT_SPANS	O
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
ppt	pointer
-	O
pptInit	pointer
,	O
pptInit	pointer
,	O
pwidthInit	pointer
)	O
}	O
static	O
int	O
miPolyBuildEdge	function
(	O
double	O
x0	double
,	O
double	O
y0	function
,	O
double	O
k	double
,	O
int	O
dx	int
,	O
int	O
dy	int
,	O
int	O
xi	int
,	O
int	O
yi	int
,	O
bool	enum
left	pointer
,	O
PolyEdge	struct
*	O
edge	pointer
)	O
{	O
int	O
x	double
,	O
y	double
,	O
e	int
;	O
int	O
xady	int
;	O
if	O
(	O
dy	int
<	O
0	int
)	O
{	O
dy	int
=	O
-	O
dy	int
;	O
dx	int
=	O
-	O
dx	int
;	O
k	double
=	O
-	O
k	double
;	O
}	O
y	double
=	O
ICEIL	O
(	O
y0	function
)	O
;	O
xady	int
=	O
ICEIL	O
(	O
k	double
)	O
+	O
y	double
*	O
dx	int
;	O
if	O
(	O
xady	int
<=	O
0	int
)	O
x	double
=	O
-	O
(	O
-	O
xady	int
/	O
dy	int
)	O
-	O
1	int
;	O
else	O
x	double
=	O
(	O
xady	int
-	O
1	int
)	O
/	O
dy	int
;	O
e	int
=	O
xady	int
-	O
x	double
*	O
dy	int
;	O
if	O
(	O
dx	int
>=	O
0	int
)	O
{	O
edge	pointer
->	O
signdx	int
=	O
1	int
;	O
edge	pointer
->	O
stepx	int
=	O
dx	int
/	O
dy	int
;	O
edge	pointer
->	O
dx	int
=	O
dx	int
%	O
dy	int
;	O
}	O
else	O
{	O
edge	pointer
->	O
signdx	int
=	O
-	O
1	int
;	O
edge	pointer
->	O
stepx	int
=	O
-	O
(	O
-	O
dx	int
/	O
dy	int
)	O
;	O
edge	pointer
->	O
dx	int
=	O
-	O
dx	int
%	O
dy	int
;	O
e	int
=	O
dy	int
-	O
e	int
+	O
1	int
;	O
}	O
edge	pointer
->	O
dy	int
=	O
dy	int
;	O
edge	pointer
->	O
x	double
=	O
x	double
+	O
(	O
left	pointer
==	O
true	int
?	O
1	int
:	O
0	int
)	O
+	O
xi	int
;	O
edge	pointer
->	O
e	int
=	O
e	int
-	O
dy	int
;	O
return	O
y	double
+	O
yi	int
;	O
}	O
static	O
int	O
miPolyBuildPoly	function
(	O
const	O
PolyVertex	struct
*	O
vertices	pointer
,	O
const	O
PolySlope	struct
*	O
slopes	pointer
,	O
int	O
count	int
,	O
int	O
xi	int
,	O
int	O
yi	int
,	O
PolyEdge	struct
*	O
left	pointer
,	O
PolyEdge	struct
*	O
right	pointer
,	O
int	O
*	O
pnleft	pointer
,	O
int	O
*	O
pnright	pointer
,	O
unsigned	O
int	O
*	O
h	int
)	O
{	O
int	O
top	int
,	O
bottom	int
;	O
double	O
miny	double
,	O
maxy	double
;	O
int	O
i	int
;	O
int	O
j	int
;	O
int	O
clockwise	enum
;	O
int	O
slopeoff	int
;	O
int	O
s	pointer
;	O
int	O
nright	int
,	O
nleft	int
;	O
int	O
y	double
,	O
lasty	int
=	O
0	int
,	O
bottomy	int
,	O
topy	int
=	O
0	int
;	O
maxy	double
=	O
miny	double
=	O
vertices	pointer
[	O
0	int
]	O
.	O
y	double
;	O
bottom	int
=	O
top	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
count	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
vertices	pointer
[	O
i	int
]	O
.	O
y	double
<	O
miny	double
)	O
{	O
top	int
=	O
i	int
;	O
miny	double
=	O
vertices	pointer
[	O
i	int
]	O
.	O
y	double
;	O
}	O
if	O
(	O
vertices	pointer
[	O
i	int
]	O
.	O
y	double
>=	O
maxy	double
)	O
{	O
bottom	int
=	O
i	int
;	O
maxy	double
=	O
vertices	pointer
[	O
i	int
]	O
.	O
y	double
;	O
}	O
}	O
bottomy	int
=	O
ICEIL	O
(	O
maxy	double
)	O
+	O
yi	int
;	O
i	int
=	O
top	int
;	O
j	int
=	O
StepAround	O
(	O
top	int
,	O
-	O
1	int
,	O
count	int
)	O
;	O
clockwise	enum
=	O
1	int
;	O
slopeoff	int
=	O
0	int
;	O
if	O
(	O
slopes	pointer
[	O
j	int
]	O
.	O
dy	int
*	O
slopes	pointer
[	O
i	int
]	O
.	O
dx	int
>	O
slopes	pointer
[	O
i	int
]	O
.	O
dy	int
*	O
slopes	pointer
[	O
j	int
]	O
.	O
dx	int
)	O
{	O
clockwise	enum
=	O
-	O
1	int
;	O
slopeoff	int
=	O
-	O
1	int
;	O
}	O
i	int
=	O
top	int
;	O
s	pointer
=	O
StepAround	O
(	O
top	int
,	O
slopeoff	int
,	O
count	int
)	O
;	O
nright	int
=	O
0	int
;	O
while	O
(	O
i	int
!=	O
bottom	int
)	O
{	O
if	O
(	O
slopes	pointer
[	O
s	pointer
]	O
.	O
dy	int
!=	O
0	int
)	O
{	O
y	double
=	O
miPolyBuildEdge	function
(	O
vertices	pointer
[	O
i	int
]	O
.	O
x	double
,	O
vertices	pointer
[	O
i	int
]	O
.	O
y	double
,	O
slopes	pointer
[	O
s	pointer
]	O
.	O
k	double
,	O
slopes	pointer
[	O
s	pointer
]	O
.	O
dx	int
,	O
slopes	pointer
[	O
s	pointer
]	O
.	O
dy	int
,	O
xi	int
,	O
yi	int
,	O
false	int
,	O
&	O
right	pointer
[	O
nright	int
]	O
)	O
;	O
if	O
(	O
nright	int
!=	O
0	int
)	O
right	pointer
[	O
nright	int
-	O
1	int
]	O
.	O
height	int
=	O
y	double
-	O
lasty	int
;	O
else	O
topy	int
=	O
y	double
;	O
nright	int
++	O
;	O
lasty	int
=	O
y	double
;	O
}	O
i	int
=	O
StepAround	O
(	O
i	int
,	O
clockwise	enum
,	O
count	int
)	O
;	O
s	pointer
=	O
StepAround	O
(	O
s	pointer
,	O
clockwise	enum
,	O
count	int
)	O
;	O
}	O
if	O
(	O
nright	int
!=	O
0	int
)	O
right	pointer
[	O
nright	int
-	O
1	int
]	O
.	O
height	int
=	O
bottomy	int
-	O
lasty	int
;	O
if	O
(	O
slopeoff	int
==	O
0	int
)	O
slopeoff	int
=	O
-	O
1	int
;	O
else	O
slopeoff	int
=	O
0	int
;	O
i	int
=	O
top	int
;	O
s	pointer
=	O
StepAround	O
(	O
top	int
,	O
slopeoff	int
,	O
count	int
)	O
;	O
nleft	int
=	O
0	int
;	O
while	O
(	O
i	int
!=	O
bottom	int
)	O
{	O
if	O
(	O
slopes	pointer
[	O
s	pointer
]	O
.	O
dy	int
!=	O
0	int
)	O
{	O
y	double
=	O
miPolyBuildEdge	function
(	O
vertices	pointer
[	O
i	int
]	O
.	O
x	double
,	O
vertices	pointer
[	O
i	int
]	O
.	O
y	double
,	O
slopes	pointer
[	O
s	pointer
]	O
.	O
k	double
,	O
slopes	pointer
[	O
s	pointer
]	O
.	O
dx	int
,	O
slopes	pointer
[	O
s	pointer
]	O
.	O
dy	int
,	O
xi	int
,	O
yi	int
,	O
true	int
,	O
&	O
left	pointer
[	O
nleft	int
]	O
)	O
;	O
if	O
(	O
nleft	int
!=	O
0	int
)	O
left	pointer
[	O
nleft	int
-	O
1	int
]	O
.	O
height	int
=	O
y	double
-	O
lasty	int
;	O
nleft	int
++	O
;	O
lasty	int
=	O
y	double
;	O
}	O
i	int
=	O
StepAround	O
(	O
i	int
,	O
-	O
clockwise	enum
,	O
count	int
)	O
;	O
s	pointer
=	O
StepAround	O
(	O
s	pointer
,	O
-	O
clockwise	enum
,	O
count	int
)	O
;	O
}	O
if	O
(	O
nleft	int
!=	O
0	int
)	O
left	pointer
[	O
nleft	int
-	O
1	int
]	O
.	O
height	int
=	O
bottomy	int
-	O
lasty	int
;	O
*	O
pnleft	pointer
=	O
nleft	int
;	O
*	O
pnright	pointer
=	O
nright	int
;	O
*	O
h	int
=	O
bottomy	int
-	O
topy	int
;	O
return	O
topy	int
;	O
}	O
static	O
void	O
miLineJoin	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
miPixel	struct
pixel	struct
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
LineFace	struct
*	O
pLeft	pointer
,	O
LineFace	struct
*	O
pRight	pointer
)	O
{	O
double	O
mx	double
=	O
0.0	int
,	O
my	double
=	O
0.0	int
;	O
int	O
denom	int
=	O
0	int
;	O
PolyVertex	struct
vertices	pointer
[	O
4	int
]	O
;	O
PolySlope	struct
slopes	pointer
[	O
4	int
]	O
;	O
int	O
edgecount	int
;	O
PolyEdge	struct
left	pointer
[	O
4	int
]	O
,	O
right	pointer
[	O
4	int
]	O
;	O
int	O
nleft	int
,	O
nright	int
;	O
int	O
y	double
;	O
unsigned	O
int	O
height	int
;	O
bool	enum
swapslopes	enum
;	O
int	O
joinStyle	int
=	O
(	O
int	O
)	O
pGC	pointer
->	O
joinStyle	int
;	O
int	O
lw	int
=	O
(	O
int	O
)	O
(	O
pGC	pointer
->	O
lineWidth	int
)	O
;	O
if	O
(	O
joinStyle	int
==	O
(	O
int	O
)	O
MI_JOIN_ROUND	int
)	O
{	O
miLineArc	function
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
pGC	pointer
,	O
pLeft	pointer
,	O
pRight	pointer
,	O
(	O
double	O
)	O
0.0	int
,	O
(	O
double	O
)	O
0.0	int
,	O
true	int
)	O
;	O
return	O
;	O
}	O
denom	int
=	O
-	O
pLeft	pointer
->	O
dx	int
*	O
pRight	pointer
->	O
dy	int
+	O
pRight	pointer
->	O
dx	int
*	O
pLeft	pointer
->	O
dy	int
;	O
if	O
(	O
denom	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
denom	int
>	O
0	int
)	O
{	O
swapslopes	enum
=	O
false	int
;	O
pLeft	pointer
->	O
xa	double
=	O
-	O
pLeft	pointer
->	O
xa	double
;	O
pLeft	pointer
->	O
ya	double
=	O
-	O
pLeft	pointer
->	O
ya	double
;	O
pLeft	pointer
->	O
dx	int
=	O
-	O
pLeft	pointer
->	O
dx	int
;	O
pLeft	pointer
->	O
dy	int
=	O
-	O
pLeft	pointer
->	O
dy	int
;	O
}	O
else	O
{	O
swapslopes	enum
=	O
true	int
;	O
pRight	pointer
->	O
xa	double
=	O
-	O
pRight	pointer
->	O
xa	double
;	O
pRight	pointer
->	O
ya	double
=	O
-	O
pRight	pointer
->	O
ya	double
;	O
pRight	pointer
->	O
dx	int
=	O
-	O
pRight	pointer
->	O
dx	int
;	O
pRight	pointer
->	O
dy	int
=	O
-	O
pRight	pointer
->	O
dy	int
;	O
}	O
vertices	pointer
[	O
0	int
]	O
.	O
x	double
=	O
pRight	pointer
->	O
xa	double
;	O
vertices	pointer
[	O
0	int
]	O
.	O
y	double
=	O
pRight	pointer
->	O
ya	double
;	O
slopes	pointer
[	O
0	int
]	O
.	O
dx	int
=	O
-	O
pRight	pointer
->	O
dy	int
;	O
slopes	pointer
[	O
0	int
]	O
.	O
dy	int
=	O
pRight	pointer
->	O
dx	int
;	O
slopes	pointer
[	O
0	int
]	O
.	O
k	double
=	O
0	int
;	O
vertices	pointer
[	O
1	int
]	O
.	O
x	double
=	O
0	int
;	O
vertices	pointer
[	O
1	int
]	O
.	O
y	double
=	O
0	int
;	O
slopes	pointer
[	O
1	int
]	O
.	O
dx	int
=	O
pLeft	pointer
->	O
dy	int
;	O
slopes	pointer
[	O
1	int
]	O
.	O
dy	int
=	O
-	O
pLeft	pointer
->	O
dx	int
;	O
slopes	pointer
[	O
1	int
]	O
.	O
k	double
=	O
0	int
;	O
vertices	pointer
[	O
2	int
]	O
.	O
x	double
=	O
pLeft	pointer
->	O
xa	double
;	O
vertices	pointer
[	O
2	int
]	O
.	O
y	double
=	O
pLeft	pointer
->	O
ya	double
;	O
if	O
(	O
joinStyle	int
==	O
(	O
int	O
)	O
MI_JOIN_MITER	int
)	O
{	O
double	O
miterlimit	double
=	O
pGC	pointer
->	O
miterLimit	double
;	O
my	double
=	O
(	O
pLeft	pointer
->	O
dy	int
*	O
(	O
pRight	pointer
->	O
xa	double
*	O
pRight	pointer
->	O
dy	int
-	O
pRight	pointer
->	O
ya	double
*	O
pRight	pointer
->	O
dx	int
)	O
-	O
pRight	pointer
->	O
dy	int
*	O
(	O
pLeft	pointer
->	O
xa	double
*	O
pLeft	pointer
->	O
dy	int
-	O
pLeft	pointer
->	O
ya	double
*	O
pLeft	pointer
->	O
dx	int
)	O
)	O
/	O
(	O
double	O
)	O
denom	int
;	O
if	O
(	O
pLeft	pointer
->	O
dy	int
!=	O
0	int
)	O
mx	double
=	O
pLeft	pointer
->	O
xa	double
+	O
(	O
my	double
-	O
pLeft	pointer
->	O
ya	double
)	O
*	O
(	O
double	O
)	O
pLeft	pointer
->	O
dx	int
/	O
(	O
double	O
)	O
pLeft	pointer
->	O
dy	int
;	O
else	O
mx	double
=	O
pRight	pointer
->	O
xa	double
+	O
(	O
my	double
-	O
pRight	pointer
->	O
ya	double
)	O
*	O
(	O
double	O
)	O
pRight	pointer
->	O
dx	int
/	O
(	O
double	O
)	O
pRight	pointer
->	O
dy	int
;	O
if	O
(	O
(	O
mx	double
*	O
mx	double
+	O
my	double
*	O
my	double
)	O
*	O
4	int
>	O
miterlimit	double
*	O
miterlimit	double
*	O
lw	int
*	O
lw	int
)	O
joinStyle	int
=	O
(	O
int	O
)	O
MI_JOIN_BEVEL	int
;	O
}	O
switch	O
(	O
(	O
int	O
)	O
joinStyle	int
)	O
{	O
double	O
scale	double
,	O
dx	int
,	O
dy	int
,	O
adx	double
,	O
ady	double
;	O
case	O
(	O
int	O
)	O
MI_JOIN_MITER	int
:	O
default	O
:	O
edgecount	int
=	O
4	int
;	O
slopes	pointer
[	O
2	int
]	O
.	O
dx	int
=	O
pLeft	pointer
->	O
dx	int
;	O
slopes	pointer
[	O
2	int
]	O
.	O
dy	int
=	O
pLeft	pointer
->	O
dy	int
;	O
slopes	pointer
[	O
2	int
]	O
.	O
k	double
=	O
pLeft	pointer
->	O
k	double
;	O
if	O
(	O
swapslopes	enum
)	O
{	O
slopes	pointer
[	O
2	int
]	O
.	O
dx	int
=	O
-	O
slopes	pointer
[	O
2	int
]	O
.	O
dx	int
;	O
slopes	pointer
[	O
2	int
]	O
.	O
dy	int
=	O
-	O
slopes	pointer
[	O
2	int
]	O
.	O
dy	int
;	O
slopes	pointer
[	O
2	int
]	O
.	O
k	double
=	O
-	O
slopes	pointer
[	O
2	int
]	O
.	O
k	double
;	O
}	O
vertices	pointer
[	O
3	int
]	O
.	O
x	double
=	O
mx	double
;	O
vertices	pointer
[	O
3	int
]	O
.	O
y	double
=	O
my	double
;	O
slopes	pointer
[	O
3	int
]	O
.	O
dx	int
=	O
pRight	pointer
->	O
dx	int
;	O
slopes	pointer
[	O
3	int
]	O
.	O
dy	int
=	O
pRight	pointer
->	O
dy	int
;	O
slopes	pointer
[	O
3	int
]	O
.	O
k	double
=	O
pRight	pointer
->	O
k	double
;	O
if	O
(	O
swapslopes	enum
)	O
{	O
slopes	pointer
[	O
3	int
]	O
.	O
dx	int
=	O
-	O
slopes	pointer
[	O
3	int
]	O
.	O
dx	int
;	O
slopes	pointer
[	O
3	int
]	O
.	O
dy	int
=	O
-	O
slopes	pointer
[	O
3	int
]	O
.	O
dy	int
;	O
slopes	pointer
[	O
3	int
]	O
.	O
k	double
=	O
-	O
slopes	pointer
[	O
3	int
]	O
.	O
k	double
;	O
}	O
break	O
;	O
case	O
(	O
int	O
)	O
MI_JOIN_BEVEL	int
:	O
{	O
PolyVertex	struct
midpoint	struct
;	O
edgecount	int
=	O
3	int
;	O
midpoint	struct
.	O
x	double
=	O
0.5	int
*	O
(	O
pLeft	pointer
->	O
xa	double
+	O
pRight	pointer
->	O
xa	double
)	O
;	O
midpoint	struct
.	O
y	double
=	O
0.5	int
*	O
(	O
pLeft	pointer
->	O
ya	double
+	O
pRight	pointer
->	O
ya	double
)	O
;	O
dx	int
=	O
pRight	pointer
->	O
xa	double
-	O
pLeft	pointer
->	O
xa	double
;	O
dy	int
=	O
pRight	pointer
->	O
ya	double
-	O
pLeft	pointer
->	O
ya	double
;	O
adx	double
=	O
dx	int
;	O
ady	double
=	O
dy	int
;	O
if	O
(	O
adx	double
<	O
0	int
)	O
adx	double
=	O
-	O
adx	double
;	O
if	O
(	O
ady	double
<	O
0	int
)	O
ady	double
=	O
-	O
ady	double
;	O
scale	double
=	O
ady	double
;	O
if	O
(	O
adx	double
>	O
ady	double
)	O
scale	double
=	O
adx	double
;	O
slopes	pointer
[	O
2	int
]	O
.	O
dx	int
=	O
(	O
int	O
)	O
(	O
(	O
dx	int
*	O
65536	int
)	O
/	O
scale	double
)	O
;	O
slopes	pointer
[	O
2	int
]	O
.	O
dy	int
=	O
(	O
int	O
)	O
(	O
(	O
dy	int
*	O
65536	int
)	O
/	O
scale	double
)	O
;	O
slopes	pointer
[	O
2	int
]	O
.	O
k	double
=	O
midpoint	struct
.	O
x	double
*	O
slopes	pointer
[	O
2	int
]	O
.	O
dy	int
-	O
midpoint	struct
.	O
y	double
*	O
slopes	pointer
[	O
2	int
]	O
.	O
dx	int
;	O
}	O
break	O
;	O
case	O
(	O
int	O
)	O
MI_JOIN_TRIANGULAR	int
:	O
{	O
PolyVertex	struct
midpoint	struct
,	O
newpoint	struct
;	O
double	O
mid2	double
,	O
mid	double
,	O
dx2	int
,	O
dy2	int
,	O
dx3	int
,	O
dy3	int
;	O
edgecount	int
=	O
4	int
;	O
midpoint	struct
.	O
x	double
=	O
0.5	int
*	O
(	O
pLeft	pointer
->	O
xa	double
+	O
pRight	pointer
->	O
xa	double
)	O
;	O
midpoint	struct
.	O
y	double
=	O
0.5	int
*	O
(	O
pLeft	pointer
->	O
ya	double
+	O
pRight	pointer
->	O
ya	double
)	O
;	O
mid2	double
=	O
midpoint	struct
.	O
x	double
*	O
midpoint	struct
.	O
x	double
+	O
midpoint	struct
.	O
y	double
*	O
midpoint	struct
.	O
y	double
;	O
mid	double
=	O
sqrt	function
(	O
mid2	double
)	O
;	O
newpoint	struct
.	O
x	double
=	O
0.5	int
*	O
lw	int
*	O
midpoint	struct
.	O
x	double
/	O
mid	double
;	O
newpoint	struct
.	O
y	double
=	O
0.5	int
*	O
lw	int
*	O
midpoint	struct
.	O
y	double
/	O
mid	double
;	O
vertices	pointer
[	O
3	int
]	O
=	O
newpoint	struct
;	O
dx2	int
=	O
vertices	pointer
[	O
3	int
]	O
.	O
x	double
-	O
vertices	pointer
[	O
2	int
]	O
.	O
x	double
;	O
dy2	int
=	O
vertices	pointer
[	O
3	int
]	O
.	O
y	double
-	O
vertices	pointer
[	O
2	int
]	O
.	O
y	double
;	O
dx3	int
=	O
vertices	pointer
[	O
0	int
]	O
.	O
x	double
-	O
vertices	pointer
[	O
3	int
]	O
.	O
x	double
;	O
dy3	int
=	O
vertices	pointer
[	O
0	int
]	O
.	O
y	double
-	O
vertices	pointer
[	O
3	int
]	O
.	O
y	double
;	O
dx	int
=	O
pRight	pointer
->	O
xa	double
-	O
pLeft	pointer
->	O
xa	double
;	O
dy	int
=	O
pRight	pointer
->	O
ya	double
-	O
pLeft	pointer
->	O
ya	double
;	O
adx	double
=	O
dx	int
;	O
ady	double
=	O
dy	int
;	O
if	O
(	O
adx	double
<	O
0	int
)	O
adx	double
=	O
-	O
adx	double
;	O
if	O
(	O
ady	double
<	O
0	int
)	O
ady	double
=	O
-	O
ady	double
;	O
scale	double
=	O
ady	double
;	O
if	O
(	O
adx	double
>	O
ady	double
)	O
scale	double
=	O
adx	double
;	O
slopes	pointer
[	O
2	int
]	O
.	O
dx	int
=	O
(	O
int	O
)	O
(	O
(	O
dx2	int
*	O
65536	int
)	O
/	O
scale	double
)	O
;	O
slopes	pointer
[	O
2	int
]	O
.	O
dy	int
=	O
(	O
int	O
)	O
(	O
(	O
dy2	int
*	O
65536	int
)	O
/	O
scale	double
)	O
;	O
slopes	pointer
[	O
2	int
]	O
.	O
k	double
=	O
newpoint	struct
.	O
x	double
*	O
slopes	pointer
[	O
2	int
]	O
.	O
dy	int
-	O
newpoint	struct
.	O
y	double
*	O
slopes	pointer
[	O
2	int
]	O
.	O
dx	int
;	O
slopes	pointer
[	O
3	int
]	O
.	O
dx	int
=	O
(	O
int	O
)	O
(	O
(	O
dx3	int
*	O
65536	int
)	O
/	O
scale	double
)	O
;	O
slopes	pointer
[	O
3	int
]	O
.	O
dy	int
=	O
(	O
int	O
)	O
(	O
(	O
dy3	int
*	O
65536	int
)	O
/	O
scale	double
)	O
;	O
slopes	pointer
[	O
3	int
]	O
.	O
k	double
=	O
newpoint	struct
.	O
x	double
*	O
slopes	pointer
[	O
3	int
]	O
.	O
dy	int
-	O
newpoint	struct
.	O
y	double
*	O
slopes	pointer
[	O
3	int
]	O
.	O
dx	int
;	O
}	O
break	O
;	O
}	O
y	double
=	O
miPolyBuildPoly	function
(	O
vertices	pointer
,	O
slopes	pointer
,	O
edgecount	int
,	O
pLeft	pointer
->	O
x	double
,	O
pLeft	pointer
->	O
y	double
,	O
left	pointer
,	O
right	pointer
,	O
&	O
nleft	int
,	O
&	O
nright	int
,	O
&	O
height	int
)	O
;	O
miFillPolyHelper	function
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
y	double
,	O
height	int
,	O
left	pointer
,	O
right	pointer
,	O
nleft	int
,	O
nright	int
)	O
;	O
}	O
static	O
void	O
miLineArc	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
miPixel	struct
pixel	struct
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
LineFace	struct
*	O
leftFace	pointer
,	O
LineFace	struct
*	O
rightFace	pointer
,	O
double	O
xorg	double
,	O
double	O
yorg	double
,	O
bool	enum
isInt	enum
)	O
{	O
miPoint	struct
*	O
points	pointer
;	O
unsigned	O
int	O
*	O
widths	pointer
;	O
int	O
xorgi	int
=	O
0	int
,	O
yorgi	int
=	O
0	int
;	O
int	O
n	array
;	O
PolyEdge	struct
edge1	pointer
,	O
edge2	pointer
;	O
int	O
edgey1	int
,	O
edgey2	int
;	O
bool	enum
edgeleft1	enum
,	O
edgeleft2	enum
;	O
if	O
(	O
isInt	enum
)	O
{	O
xorgi	int
=	O
leftFace	pointer
?	O
leftFace	pointer
->	O
x	double
:	O
rightFace	pointer
->	O
x	double
;	O
yorgi	int
=	O
leftFace	pointer
?	O
leftFace	pointer
->	O
y	double
:	O
rightFace	pointer
->	O
y	double
;	O
}	O
edgey1	int
=	O
INT_MAX	O
;	O
edgey2	int
=	O
INT_MAX	O
;	O
edge1	pointer
.	O
x	double
=	O
0	int
;	O
edge1	pointer
.	O
dy	int
=	O
-	O
1	int
;	O
edge2	pointer
.	O
x	double
=	O
0	int
;	O
edge2	pointer
.	O
dy	int
=	O
-	O
1	int
;	O
edgeleft1	enum
=	O
false	int
;	O
edgeleft2	enum
=	O
false	int
;	O
if	O
(	O
(	O
pGC	pointer
->	O
lineStyle	int
!=	O
(	O
int	O
)	O
MI_LINE_SOLID	int
||	O
pGC	pointer
->	O
lineWidth	int
>	O
2	int
)	O
&&	O
(	O
(	O
pGC	pointer
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_ROUND	int
&&	O
pGC	pointer
->	O
joinStyle	int
!=	O
(	O
int	O
)	O
MI_JOIN_ROUND	int
)	O
||	O
(	O
pGC	pointer
->	O
joinStyle	int
==	O
(	O
int	O
)	O
MI_JOIN_ROUND	int
&&	O
pGC	pointer
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_BUTT	int
)	O
)	O
)	O
{	O
if	O
(	O
isInt	enum
)	O
{	O
xorg	double
=	O
(	O
double	O
)	O
xorgi	int
;	O
yorg	double
=	O
(	O
double	O
)	O
yorgi	int
;	O
}	O
if	O
(	O
leftFace	pointer
&&	O
rightFace	pointer
)	O
miRoundJoinClip	function
(	O
leftFace	pointer
,	O
rightFace	pointer
,	O
&	O
edge1	pointer
,	O
&	O
edge2	pointer
,	O
&	O
edgey1	int
,	O
&	O
edgey2	int
,	O
&	O
edgeleft1	enum
,	O
&	O
edgeleft2	enum
)	O
;	O
else	O
if	O
(	O
leftFace	pointer
)	O
edgey1	int
=	O
miRoundCapClip	function
(	O
leftFace	pointer
,	O
isInt	enum
,	O
&	O
edge1	pointer
,	O
&	O
edgeleft1	enum
)	O
;	O
else	O
if	O
(	O
rightFace	pointer
)	O
edgey2	int
=	O
miRoundCapClip	function
(	O
rightFace	pointer
,	O
isInt	enum
,	O
&	O
edge2	pointer
,	O
&	O
edgeleft2	enum
)	O
;	O
isInt	enum
=	O
false	int
;	O
}	O
points	pointer
=	O
(	O
miPoint	struct
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
miPoint	struct
)	O
*	O
pGC	pointer
->	O
lineWidth	int
)	O
;	O
widths	pointer
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
unsigned	O
int	O
)	O
*	O
pGC	pointer
->	O
lineWidth	int
)	O
;	O
if	O
(	O
isInt	enum
)	O
n	array
=	O
miLineArcI	function
(	O
pGC	pointer
,	O
xorgi	int
,	O
yorgi	int
,	O
points	pointer
,	O
widths	pointer
)	O
;	O
else	O
n	array
=	O
miLineArcD	function
(	O
pGC	pointer
,	O
xorg	double
,	O
yorg	double
,	O
points	pointer
,	O
widths	pointer
,	O
&	O
edge1	pointer
,	O
edgey1	int
,	O
edgeleft1	enum
,	O
&	O
edge2	pointer
,	O
edgey2	int
,	O
edgeleft2	enum
)	O
;	O
MI_PAINT_SPANS	O
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
n	array
,	O
points	pointer
,	O
widths	pointer
)	O
}	O
static	O
int	O
miLineArcI	function
(	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
int	O
xorg	double
,	O
int	O
yorg	double
,	O
miPoint	struct
*	O
points	pointer
,	O
unsigned	O
int	O
*	O
widths	pointer
)	O
{	O
miPoint	struct
*	O
tpts	pointer
,	O
*	O
bpts	pointer
;	O
unsigned	O
int	O
*	O
twids	pointer
,	O
*	O
bwids	pointer
;	O
int	O
x	double
,	O
y	double
,	O
e	int
,	O
ex	int
;	O
int	O
slw	int
;	O
tpts	pointer
=	O
points	pointer
;	O
twids	pointer
=	O
widths	pointer
;	O
slw	int
=	O
(	O
int	O
)	O
(	O
pGC	pointer
->	O
lineWidth	int
)	O
;	O
if	O
(	O
slw	int
==	O
1	int
)	O
{	O
tpts	pointer
->	O
x	double
=	O
xorg	double
;	O
tpts	pointer
->	O
y	double
=	O
yorg	double
;	O
*	O
twids	pointer
=	O
1	int
;	O
return	O
1	int
;	O
}	O
bpts	pointer
=	O
tpts	pointer
+	O
slw	int
;	O
bwids	pointer
=	O
twids	pointer
+	O
slw	int
;	O
y	double
=	O
(	O
slw	int
>>	O
1	int
)	O
+	O
1	int
;	O
if	O
(	O
slw	int
&	O
1	int
)	O
e	int
=	O
-	O
(	O
(	O
y	double
<<	O
2	int
)	O
+	O
3	int
)	O
;	O
else	O
e	int
=	O
-	O
(	O
y	double
<<	O
3	int
)	O
;	O
ex	int
=	O
-	O
4	int
;	O
x	double
=	O
0	int
;	O
while	O
(	O
y	double
)	O
{	O
e	int
+=	O
(	O
y	double
<<	O
3	int
)	O
-	O
4	int
;	O
while	O
(	O
e	int
>=	O
0	int
)	O
{	O
x	double
++	O
;	O
e	int
+=	O
(	O
ex	int
=	O
-	O
(	O
(	O
x	double
<<	O
3	int
)	O
+	O
4	int
)	O
)	O
;	O
}	O
y	double
--	O
;	O
slw	int
=	O
(	O
x	double
<<	O
1	int
)	O
+	O
1	int
;	O
if	O
(	O
(	O
e	int
==	O
ex	int
)	O
&&	O
(	O
slw	int
>	O
1	int
)	O
)	O
slw	int
--	O
;	O
tpts	pointer
->	O
x	double
=	O
xorg	double
-	O
x	double
;	O
tpts	pointer
->	O
y	double
=	O
yorg	double
-	O
y	double
;	O
tpts	pointer
++	O
;	O
*	O
twids	pointer
++	O
=	O
slw	int
;	O
if	O
(	O
(	O
y	double
!=	O
0	int
)	O
&&	O
(	O
(	O
slw	int
>	O
1	int
)	O
||	O
(	O
e	int
!=	O
ex	int
)	O
)	O
)	O
{	O
bpts	pointer
--	O
;	O
bpts	pointer
->	O
x	double
=	O
xorg	double
-	O
x	double
;	O
bpts	pointer
->	O
y	double
=	O
yorg	double
+	O
y	double
;	O
*	O
--	O
bwids	pointer
=	O
slw	int
;	O
}	O
}	O
return	O
(	O
int	O
)	O
(	O
pGC	pointer
->	O
lineWidth	int
)	O
;	O
}	O
static	O
int	O
miLineArcD	function
(	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
double	O
xorg	double
,	O
double	O
yorg	double
,	O
miPoint	struct
*	O
points	pointer
,	O
unsigned	O
int	O
*	O
widths	pointer
,	O
PolyEdge	struct
*	O
edge1	pointer
,	O
int	O
edgey1	int
,	O
bool	enum
edgeleft1	enum
,	O
PolyEdge	struct
*	O
edge2	pointer
,	O
int	O
edgey2	int
,	O
bool	enum
edgeleft2	enum
)	O
{	O
miPoint	struct
*	O
pts	array
;	O
unsigned	O
int	O
*	O
wids	pointer
;	O
double	O
radius	double
,	O
x0	double
,	O
y0	function
,	O
el	double
,	O
er	double
,	O
yk	double
,	O
xlk	double
,	O
xrk	double
,	O
k	double
;	O
int	O
xbase	int
,	O
ybase	int
,	O
y	double
,	O
boty	int
,	O
xl	int
,	O
xr	int
,	O
xcl	int
,	O
xcr	int
;	O
int	O
ymin	double
,	O
ymax	double
;	O
bool	enum
edge1IsMin	enum
,	O
edge2IsMin	enum
;	O
int	O
ymin1	int
,	O
ymin2	int
;	O
pts	array
=	O
points	pointer
;	O
wids	pointer
=	O
widths	pointer
;	O
xbase	int
=	O
(	O
int	O
)	O
(	O
floor	function
(	O
xorg	double
)	O
)	O
;	O
x0	double
=	O
xorg	double
-	O
xbase	int
;	O
ybase	int
=	O
ICEIL	O
(	O
yorg	double
)	O
;	O
y0	function
=	O
yorg	double
-	O
ybase	int
;	O
xlk	double
=	O
x0	double
+	O
x0	double
+	O
1.0	int
;	O
xrk	double
=	O
x0	double
+	O
x0	double
-	O
1.0	int
;	O
yk	double
=	O
y0	function
+	O
y0	function
-	O
1.0	int
;	O
radius	double
=	O
0.5	int
*	O
(	O
(	O
double	O
)	O
pGC	pointer
->	O
lineWidth	int
)	O
;	O
y	double
=	O
(	O
int	O
)	O
(	O
floor	function
(	O
radius	double
-	O
y0	function
+	O
1.0	int
)	O
)	O
;	O
ybase	int
-=	O
y	double
;	O
ymin	double
=	O
ybase	int
;	O
ymax	double
=	O
INT_MAX	O
;	O
edge1IsMin	enum
=	O
false	int
;	O
ymin1	int
=	O
edgey1	int
;	O
if	O
(	O
edge1	pointer
->	O
dy	int
>=	O
0	int
)	O
{	O
if	O
(	O
!	O
edge1	pointer
->	O
dy	int
)	O
{	O
if	O
(	O
edgeleft1	enum
)	O
edge1IsMin	enum
=	O
true	int
;	O
else	O
ymax	double
=	O
edgey1	int
;	O
edgey1	int
=	O
INT_MAX	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
edge1	pointer
->	O
signdx	int
<	O
0	int
)	O
==	O
edgeleft1	enum
)	O
edge1IsMin	enum
=	O
true	int
;	O
}	O
}	O
edge2IsMin	enum
=	O
false	int
;	O
ymin2	int
=	O
edgey2	int
;	O
if	O
(	O
edge2	pointer
->	O
dy	int
>=	O
0	int
)	O
{	O
if	O
(	O
!	O
edge2	pointer
->	O
dy	int
)	O
{	O
if	O
(	O
edgeleft2	enum
)	O
edge2IsMin	enum
=	O
true	int
;	O
else	O
ymax	double
=	O
edgey2	int
;	O
edgey2	int
=	O
INT_MAX	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
edge2	pointer
->	O
signdx	int
<	O
0	int
)	O
==	O
edgeleft2	enum
)	O
edge2IsMin	enum
=	O
true	int
;	O
}	O
}	O
if	O
(	O
edge1IsMin	enum
)	O
{	O
ymin	double
=	O
ymin1	int
;	O
if	O
(	O
edge2IsMin	enum
&&	O
ymin1	int
>	O
ymin2	int
)	O
ymin	double
=	O
ymin2	int
;	O
}	O
else	O
if	O
(	O
edge2IsMin	enum
)	O
ymin	double
=	O
ymin2	int
;	O
el	double
=	O
radius	double
*	O
radius	double
-	O
(	O
(	O
y	double
+	O
y0	function
)	O
*	O
(	O
y	double
+	O
y0	function
)	O
)	O
-	O
(	O
x0	double
*	O
x0	double
)	O
;	O
er	double
=	O
el	double
+	O
xrk	double
;	O
xl	int
=	O
1	int
;	O
xr	int
=	O
0	int
;	O
if	O
(	O
x0	double
<	O
0.5	int
)	O
{	O
xl	int
=	O
0	int
;	O
el	double
-=	O
xlk	double
;	O
}	O
boty	int
=	O
(	O
y0	function
<	O
-	O
0.5	int
)	O
?	O
1	int
:	O
0	int
;	O
if	O
(	O
ybase	int
+	O
y	double
-	O
boty	int
>	O
ymax	double
)	O
boty	int
=	O
ymax	double
-	O
ybase	int
-	O
y	double
;	O
while	O
(	O
y	double
>	O
boty	int
)	O
{	O
k	double
=	O
(	O
y	double
<<	O
1	int
)	O
+	O
yk	double
;	O
er	double
+=	O
k	double
;	O
while	O
(	O
er	double
>	O
0.0	int
)	O
{	O
xr	int
++	O
;	O
er	double
+=	O
xrk	double
-	O
(	O
xr	int
<<	O
1	int
)	O
;	O
}	O
el	double
+=	O
k	double
;	O
while	O
(	O
el	double
>=	O
0.0	int
)	O
{	O
xl	int
--	O
;	O
el	double
+=	O
(	O
xl	int
<<	O
1	int
)	O
-	O
xlk	double
;	O
}	O
y	double
--	O
;	O
ybase	int
++	O
;	O
if	O
(	O
ybase	int
<	O
ymin	double
)	O
continue	O
;	O
xcl	int
=	O
xl	int
+	O
xbase	int
;	O
xcr	int
=	O
xr	int
+	O
xbase	int
;	O
CLIPSTEPEDGE	O
(	O
edgey1	int
,	O
edge1	pointer
,	O
edgeleft1	enum
)	O
;	O
CLIPSTEPEDGE	O
(	O
edgey2	int
,	O
edge2	pointer
,	O
edgeleft2	enum
)	O
;	O
if	O
(	O
xcr	int
>=	O
xcl	int
)	O
{	O
pts	array
->	O
x	double
=	O
xcl	int
;	O
pts	array
->	O
y	double
=	O
ybase	int
;	O
pts	array
++	O
;	O
*	O
wids	pointer
++	O
=	O
(	O
unsigned	O
int	O
)	O
(	O
xcr	int
-	O
xcl	int
+	O
1	int
)	O
;	O
}	O
}	O
er	double
=	O
xrk	double
-	O
(	O
xr	int
<<	O
1	int
)	O
-	O
er	double
;	O
el	double
=	O
(	O
xl	int
<<	O
1	int
)	O
-	O
xlk	double
-	O
el	double
;	O
boty	int
=	O
(	O
int	O
)	O
(	O
floor	function
(	O
-	O
y0	function
-	O
radius	double
+	O
1.0	int
)	O
)	O
;	O
if	O
(	O
ybase	int
+	O
y	double
-	O
boty	int
>	O
ymax	double
)	O
boty	int
=	O
ymax	double
-	O
ybase	int
-	O
y	double
;	O
while	O
(	O
y	double
>	O
boty	int
)	O
{	O
k	double
=	O
(	O
y	double
<<	O
1	int
)	O
+	O
yk	double
;	O
er	double
-=	O
k	double
;	O
while	O
(	O
(	O
er	double
>=	O
0.0	int
)	O
&&	O
(	O
xr	int
>=	O
0	int
)	O
)	O
{	O
xr	int
--	O
;	O
er	double
+=	O
xrk	double
-	O
(	O
xr	int
<<	O
1	int
)	O
;	O
}	O
el	double
-=	O
k	double
;	O
while	O
(	O
(	O
el	double
>	O
0.0	int
)	O
&&	O
(	O
xl	int
<=	O
0	int
)	O
)	O
{	O
xl	int
++	O
;	O
el	double
+=	O
(	O
xl	int
<<	O
1	int
)	O
-	O
xlk	double
;	O
}	O
y	double
--	O
;	O
ybase	int
++	O
;	O
if	O
(	O
ybase	int
<	O
ymin	double
)	O
continue	O
;	O
xcl	int
=	O
xl	int
+	O
xbase	int
;	O
xcr	int
=	O
xr	int
+	O
xbase	int
;	O
CLIPSTEPEDGE	O
(	O
edgey1	int
,	O
edge1	pointer
,	O
edgeleft1	enum
)	O
;	O
CLIPSTEPEDGE	O
(	O
edgey2	int
,	O
edge2	pointer
,	O
edgeleft2	enum
)	O
;	O
if	O
(	O
xcr	int
>=	O
xcl	int
)	O
{	O
pts	array
->	O
x	double
=	O
xcl	int
;	O
pts	array
->	O
y	double
=	O
ybase	int
;	O
pts	array
++	O
;	O
*	O
wids	pointer
++	O
=	O
(	O
unsigned	O
int	O
)	O
(	O
xcr	int
-	O
xcl	int
+	O
1	int
)	O
;	O
}	O
}	O
return	O
(	O
pts	array
-	O
points	pointer
)	O
;	O
}	O
static	O
void	O
miRoundJoinClip	function
(	O
LineFace	struct
*	O
pLeft	pointer
,	O
LineFace	struct
*	O
pRight	pointer
,	O
PolyEdge	struct
*	O
edge1	pointer
,	O
PolyEdge	struct
*	O
edge2	pointer
,	O
int	O
*	O
y1	function
,	O
int	O
*	O
y2	double
,	O
bool	enum
*	O
left1	pointer
,	O
bool	enum
*	O
left2	pointer
)	O
{	O
int	O
denom	int
;	O
denom	int
=	O
-	O
pLeft	pointer
->	O
dx	int
*	O
pRight	pointer
->	O
dy	int
+	O
pRight	pointer
->	O
dx	int
*	O
pLeft	pointer
->	O
dy	int
;	O
if	O
(	O
denom	int
>=	O
0	int
)	O
{	O
pLeft	pointer
->	O
xa	double
=	O
-	O
pLeft	pointer
->	O
xa	double
;	O
pLeft	pointer
->	O
ya	double
=	O
-	O
pLeft	pointer
->	O
ya	double
;	O
}	O
else	O
{	O
pRight	pointer
->	O
xa	double
=	O
-	O
pRight	pointer
->	O
xa	double
;	O
pRight	pointer
->	O
ya	double
=	O
-	O
pRight	pointer
->	O
ya	double
;	O
}	O
*	O
y1	function
=	O
miRoundJoinFace	function
(	O
pLeft	pointer
,	O
edge1	pointer
,	O
left1	pointer
)	O
;	O
*	O
y2	double
=	O
miRoundJoinFace	function
(	O
pRight	pointer
,	O
edge2	pointer
,	O
left2	pointer
)	O
;	O
}	O
static	O
int	O
miRoundJoinFace	function
(	O
const	O
LineFace	struct
*	O
face	pointer
,	O
PolyEdge	struct
*	O
edge	pointer
,	O
bool	enum
*	O
leftEdge	pointer
)	O
{	O
int	O
y	double
;	O
int	O
dx	int
,	O
dy	int
;	O
double	O
xa	double
,	O
ya	double
;	O
bool	enum
left	pointer
;	O
dx	int
=	O
-	O
face	pointer
->	O
dy	int
;	O
dy	int
=	O
face	pointer
->	O
dx	int
;	O
xa	double
=	O
face	pointer
->	O
xa	double
;	O
ya	double
=	O
face	pointer
->	O
ya	double
;	O
left	pointer
=	O
true	int
;	O
if	O
(	O
ya	double
>	O
0	int
)	O
{	O
ya	double
=	O
0.0	int
;	O
xa	double
=	O
0.0	int
;	O
}	O
if	O
(	O
dy	int
<	O
0	int
||	O
(	O
dy	int
==	O
0	int
&&	O
dx	int
>	O
0	int
)	O
)	O
{	O
dx	int
=	O
-	O
dx	int
;	O
dy	int
=	O
-	O
dy	int
;	O
left	pointer
=	O
(	O
left	pointer
?	O
false	int
:	O
true	int
)	O
;	O
}	O
if	O
(	O
dx	int
==	O
0	int
&&	O
dy	int
==	O
0	int
)	O
dy	int
=	O
1	int
;	O
if	O
(	O
dy	int
==	O
0	int
)	O
{	O
y	double
=	O
ICEIL	O
(	O
face	pointer
->	O
ya	double
)	O
+	O
face	pointer
->	O
y	double
;	O
edge	pointer
->	O
x	double
=	O
INT_MIN	O
;	O
edge	pointer
->	O
stepx	int
=	O
0	int
;	O
edge	pointer
->	O
signdx	int
=	O
0	int
;	O
edge	pointer
->	O
e	int
=	O
-	O
1	int
;	O
edge	pointer
->	O
dy	int
=	O
0	int
;	O
edge	pointer
->	O
dx	int
=	O
0	int
;	O
edge	pointer
->	O
height	int
=	O
0	int
;	O
}	O
else	O
{	O
y	double
=	O
miPolyBuildEdge	function
(	O
xa	double
,	O
ya	double
,	O
0.0	int
,	O
dx	int
,	O
dy	int
,	O
face	pointer
->	O
x	double
,	O
face	pointer
->	O
y	double
,	O
(	O
left	pointer
?	O
false	int
:	O
true	int
)	O
,	O
edge	pointer
)	O
;	O
edge	pointer
->	O
height	int
=	O
UINT_MAX	O
;	O
}	O
*	O
leftEdge	pointer
=	O
(	O
left	pointer
?	O
false	int
:	O
true	int
)	O
;	O
return	O
y	double
;	O
}	O
static	O
int	O
miRoundCapClip	function
(	O
const	O
LineFace	struct
*	O
face	pointer
,	O
bool	enum
isInt	enum
,	O
PolyEdge	struct
*	O
edge	pointer
,	O
bool	enum
*	O
leftEdge	pointer
)	O
{	O
int	O
y	double
;	O
int	O
dx	int
,	O
dy	int
;	O
double	O
xa	double
,	O
ya	double
,	O
k	double
;	O
bool	enum
left	pointer
;	O
dx	int
=	O
-	O
face	pointer
->	O
dy	int
;	O
dy	int
=	O
face	pointer
->	O
dx	int
;	O
xa	double
=	O
face	pointer
->	O
xa	double
;	O
ya	double
=	O
face	pointer
->	O
ya	double
;	O
k	double
=	O
0.0	int
;	O
if	O
(	O
!	O
isInt	enum
)	O
k	double
=	O
face	pointer
->	O
k	double
;	O
left	pointer
=	O
true	int
;	O
if	O
(	O
dy	int
<	O
0	int
||	O
(	O
dy	int
==	O
0	int
&&	O
dx	int
>	O
0	int
)	O
)	O
{	O
dx	int
=	O
-	O
dx	int
;	O
dy	int
=	O
-	O
dy	int
;	O
xa	double
=	O
-	O
xa	double
;	O
ya	double
=	O
-	O
ya	double
;	O
left	pointer
=	O
(	O
left	pointer
?	O
false	int
:	O
true	int
)	O
;	O
}	O
if	O
(	O
dx	int
==	O
0	int
&&	O
dy	int
==	O
0	int
)	O
dy	int
=	O
1	int
;	O
if	O
(	O
dy	int
==	O
0	int
)	O
{	O
y	double
=	O
ICEIL	O
(	O
face	pointer
->	O
ya	double
)	O
+	O
face	pointer
->	O
y	double
;	O
edge	pointer
->	O
x	double
=	O
INT_MIN	O
;	O
edge	pointer
->	O
stepx	int
=	O
0	int
;	O
edge	pointer
->	O
signdx	int
=	O
0	int
;	O
edge	pointer
->	O
e	int
=	O
-	O
1	int
;	O
edge	pointer
->	O
dy	int
=	O
0	int
;	O
edge	pointer
->	O
dx	int
=	O
0	int
;	O
edge	pointer
->	O
height	int
=	O
0	int
;	O
}	O
else	O
{	O
y	double
=	O
miPolyBuildEdge	function
(	O
xa	double
,	O
ya	double
,	O
k	double
,	O
dx	int
,	O
dy	int
,	O
face	pointer
->	O
x	double
,	O
face	pointer
->	O
y	double
,	O
(	O
left	pointer
?	O
false	int
:	O
true	int
)	O
,	O
edge	pointer
)	O
;	O
edge	pointer
->	O
height	int
=	O
UINT_MAX	O
;	O
}	O
*	O
leftEdge	pointer
=	O
(	O
left	pointer
?	O
false	int
:	O
true	int
)	O
;	O
return	O
y	double
;	O
}	O
static	O
void	O
miLineProjectingCap	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
miPixel	struct
pixel	struct
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
const	O
LineFace	struct
*	O
face	pointer
,	O
bool	enum
isLeft	enum
,	O
bool	enum
isInt	enum
)	O
{	O
int	O
dx	int
,	O
dy	int
;	O
int	O
topy	int
,	O
bottomy	int
;	O
int	O
xorgi	int
=	O
0	int
,	O
yorgi	int
=	O
0	int
;	O
int	O
lw	int
=	O
(	O
int	O
)	O
(	O
pGC	pointer
->	O
lineWidth	int
)	O
;	O
PolyEdge	struct
lefts	array
[	O
2	int
]	O
,	O
rights	array
[	O
2	int
]	O
;	O
if	O
(	O
isInt	enum
)	O
{	O
xorgi	int
=	O
face	pointer
->	O
x	double
;	O
yorgi	int
=	O
face	pointer
->	O
y	double
;	O
}	O
dx	int
=	O
face	pointer
->	O
dx	int
;	O
dy	int
=	O
face	pointer
->	O
dy	int
;	O
if	O
(	O
dy	int
==	O
0	int
)	O
{	O
lefts	array
[	O
0	int
]	O
.	O
height	int
=	O
(	O
unsigned	O
int	O
)	O
lw	int
;	O
lefts	array
[	O
0	int
]	O
.	O
x	double
=	O
xorgi	int
;	O
if	O
(	O
isLeft	enum
)	O
lefts	array
[	O
0	int
]	O
.	O
x	double
-=	O
(	O
lw	int
>>	O
1	int
)	O
;	O
lefts	array
[	O
0	int
]	O
.	O
stepx	int
=	O
0	int
;	O
lefts	array
[	O
0	int
]	O
.	O
signdx	int
=	O
1	int
;	O
lefts	array
[	O
0	int
]	O
.	O
e	int
=	O
-	O
lw	int
;	O
lefts	array
[	O
0	int
]	O
.	O
dx	int
=	O
0	int
;	O
lefts	array
[	O
0	int
]	O
.	O
dy	int
=	O
lw	int
;	O
rights	array
[	O
0	int
]	O
.	O
height	int
=	O
(	O
unsigned	O
int	O
)	O
lw	int
;	O
rights	array
[	O
0	int
]	O
.	O
x	double
=	O
xorgi	int
;	O
if	O
(	O
!	O
isLeft	enum
)	O
rights	array
[	O
0	int
]	O
.	O
x	double
+=	O
(	O
(	O
lw	int
+	O
1	int
)	O
>>	O
1	int
)	O
;	O
rights	array
[	O
0	int
]	O
.	O
stepx	int
=	O
0	int
;	O
rights	array
[	O
0	int
]	O
.	O
signdx	int
=	O
1	int
;	O
rights	array
[	O
0	int
]	O
.	O
e	int
=	O
-	O
lw	int
;	O
rights	array
[	O
0	int
]	O
.	O
dx	int
=	O
0	int
;	O
rights	array
[	O
0	int
]	O
.	O
dy	int
=	O
lw	int
;	O
miFillPolyHelper	function
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
yorgi	int
-	O
(	O
lw	int
>>	O
1	int
)	O
,	O
(	O
unsigned	O
int	O
)	O
lw	int
,	O
lefts	array
,	O
rights	array
,	O
1	int
,	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
dx	int
==	O
0	int
)	O
{	O
topy	int
=	O
yorgi	int
;	O
bottomy	int
=	O
yorgi	int
+	O
dy	int
;	O
if	O
(	O
isLeft	enum
)	O
topy	int
-=	O
(	O
lw	int
>>	O
1	int
)	O
;	O
else	O
bottomy	int
+=	O
(	O
lw	int
>>	O
1	int
)	O
;	O
lefts	array
[	O
0	int
]	O
.	O
height	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
bottomy	int
-	O
topy	int
)	O
;	O
lefts	array
[	O
0	int
]	O
.	O
x	double
=	O
xorgi	int
-	O
(	O
lw	int
>>	O
1	int
)	O
;	O
lefts	array
[	O
0	int
]	O
.	O
stepx	int
=	O
0	int
;	O
lefts	array
[	O
0	int
]	O
.	O
signdx	int
=	O
1	int
;	O
lefts	array
[	O
0	int
]	O
.	O
e	int
=	O
-	O
dy	int
;	O
lefts	array
[	O
0	int
]	O
.	O
dx	int
=	O
dx	int
;	O
lefts	array
[	O
0	int
]	O
.	O
dy	int
=	O
dy	int
;	O
rights	array
[	O
0	int
]	O
.	O
height	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
bottomy	int
-	O
topy	int
)	O
;	O
rights	array
[	O
0	int
]	O
.	O
x	double
=	O
lefts	array
[	O
0	int
]	O
.	O
x	double
+	O
(	O
lw	int
-	O
1	int
)	O
;	O
rights	array
[	O
0	int
]	O
.	O
stepx	int
=	O
0	int
;	O
rights	array
[	O
0	int
]	O
.	O
signdx	int
=	O
1	int
;	O
rights	array
[	O
0	int
]	O
.	O
e	int
=	O
-	O
dy	int
;	O
rights	array
[	O
0	int
]	O
.	O
dx	int
=	O
dx	int
;	O
rights	array
[	O
0	int
]	O
.	O
dy	int
=	O
dy	int
;	O
miFillPolyHelper	function
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
topy	int
,	O
(	O
unsigned	O
int	O
)	O
(	O
bottomy	int
-	O
topy	int
)	O
,	O
lefts	array
,	O
rights	array
,	O
1	int
,	O
1	int
)	O
;	O
}	O
else	O
{	O
int	O
lefty	int
,	O
righty	int
;	O
int	O
finaly	int
;	O
double	O
xa	double
,	O
ya	double
;	O
double	O
xap	double
,	O
yap	double
;	O
double	O
maxy	double
;	O
double	O
projectXoff	double
,	O
projectYoff	double
;	O
double	O
k	double
;	O
PolyEdge	struct
*	O
left	pointer
,	O
*	O
right	pointer
;	O
PolyEdge	struct
*	O
top	int
,	O
*	O
bottom	int
;	O
k	double
=	O
face	pointer
->	O
k	double
;	O
xa	double
=	O
face	pointer
->	O
xa	double
;	O
ya	double
=	O
face	pointer
->	O
ya	double
;	O
projectXoff	double
=	O
-	O
ya	double
;	O
projectYoff	double
=	O
xa	double
;	O
if	O
(	O
dx	int
<	O
0	int
)	O
{	O
right	pointer
=	O
&	O
rights	array
[	O
1	int
]	O
;	O
left	pointer
=	O
&	O
lefts	array
[	O
0	int
]	O
;	O
top	int
=	O
&	O
rights	array
[	O
0	int
]	O
;	O
bottom	int
=	O
&	O
lefts	array
[	O
1	int
]	O
;	O
}	O
else	O
{	O
right	pointer
=	O
&	O
rights	array
[	O
0	int
]	O
;	O
left	pointer
=	O
&	O
lefts	array
[	O
1	int
]	O
;	O
top	int
=	O
&	O
lefts	array
[	O
0	int
]	O
;	O
bottom	int
=	O
&	O
rights	array
[	O
1	int
]	O
;	O
}	O
if	O
(	O
isLeft	enum
)	O
{	O
righty	int
=	O
miPolyBuildEdge	function
(	O
xa	double
,	O
ya	double
,	O
k	double
,	O
dx	int
,	O
dy	int
,	O
xorgi	int
,	O
yorgi	int
,	O
false	int
,	O
right	pointer
)	O
;	O
xa	double
=	O
-	O
xa	double
;	O
ya	double
=	O
-	O
ya	double
;	O
k	double
=	O
-	O
k	double
;	O
lefty	int
=	O
miPolyBuildEdge	function
(	O
xa	double
-	O
projectXoff	double
,	O
ya	double
-	O
projectYoff	double
,	O
k	double
,	O
dx	int
,	O
dy	int
,	O
xorgi	int
,	O
yorgi	int
,	O
true	int
,	O
left	pointer
)	O
;	O
if	O
(	O
dx	int
>	O
0	int
)	O
{	O
ya	double
=	O
-	O
ya	double
;	O
xa	double
=	O
-	O
xa	double
;	O
}	O
xap	double
=	O
xa	double
-	O
projectXoff	double
;	O
yap	double
=	O
ya	double
-	O
projectYoff	double
;	O
topy	int
=	O
miPolyBuildEdge	function
(	O
xap	double
,	O
yap	double
,	O
xap	double
*	O
dx	int
+	O
yap	double
*	O
dy	int
,	O
-	O
dy	int
,	O
dx	int
,	O
xorgi	int
,	O
yorgi	int
,	O
(	O
dx	int
>	O
0	int
?	O
true	int
:	O
false	int
)	O
,	O
top	int
)	O
;	O
bottomy	int
=	O
miPolyBuildEdge	function
(	O
xa	double
,	O
ya	double
,	O
0.0	int
,	O
-	O
dy	int
,	O
dx	int
,	O
xorgi	int
,	O
yorgi	int
,	O
(	O
dx	int
<	O
0	int
?	O
true	int
:	O
false	int
)	O
,	O
bottom	int
)	O
;	O
maxy	double
=	O
-	O
ya	double
;	O
}	O
else	O
{	O
righty	int
=	O
miPolyBuildEdge	function
(	O
xa	double
-	O
projectXoff	double
,	O
ya	double
-	O
projectYoff	double
,	O
k	double
,	O
dx	int
,	O
dy	int
,	O
xorgi	int
,	O
yorgi	int
,	O
false	int
,	O
right	pointer
)	O
;	O
xa	double
=	O
-	O
xa	double
;	O
ya	double
=	O
-	O
ya	double
;	O
k	double
=	O
-	O
k	double
;	O
lefty	int
=	O
miPolyBuildEdge	function
(	O
xa	double
,	O
ya	double
,	O
k	double
,	O
dx	int
,	O
dy	int
,	O
xorgi	int
,	O
yorgi	int
,	O
true	int
,	O
left	pointer
)	O
;	O
if	O
(	O
dx	int
>	O
0	int
)	O
{	O
ya	double
=	O
-	O
ya	double
;	O
xa	double
=	O
-	O
xa	double
;	O
}	O
xap	double
=	O
xa	double
-	O
projectXoff	double
;	O
yap	double
=	O
ya	double
-	O
projectYoff	double
;	O
topy	int
=	O
miPolyBuildEdge	function
(	O
xa	double
,	O
ya	double
,	O
0.0	int
,	O
-	O
dy	int
,	O
dx	int
,	O
xorgi	int
,	O
xorgi	int
,	O
(	O
dx	int
>	O
0	int
?	O
true	int
:	O
false	int
)	O
,	O
top	int
)	O
;	O
bottomy	int
=	O
miPolyBuildEdge	function
(	O
xap	double
,	O
yap	double
,	O
xap	double
*	O
dx	int
+	O
yap	double
*	O
dy	int
,	O
-	O
dy	int
,	O
dx	int
,	O
xorgi	int
,	O
xorgi	int
,	O
(	O
dx	int
<	O
0	int
?	O
true	int
:	O
false	int
)	O
,	O
bottom	int
)	O
;	O
maxy	double
=	O
-	O
ya	double
+	O
projectYoff	double
;	O
}	O
finaly	int
=	O
ICEIL	O
(	O
maxy	double
)	O
+	O
yorgi	int
;	O
if	O
(	O
dx	int
<	O
0	int
)	O
{	O
left	pointer
->	O
height	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
bottomy	int
-	O
lefty	int
)	O
;	O
right	pointer
->	O
height	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
finaly	int
-	O
righty	int
)	O
;	O
top	int
->	O
height	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
righty	int
-	O
topy	int
)	O
;	O
}	O
else	O
{	O
right	pointer
->	O
height	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
bottomy	int
-	O
righty	int
)	O
;	O
left	pointer
->	O
height	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
finaly	int
-	O
lefty	int
)	O
;	O
top	int
->	O
height	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
lefty	int
-	O
topy	int
)	O
;	O
}	O
bottom	int
->	O
height	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
finaly	int
-	O
bottomy	int
)	O
;	O
miFillPolyHelper	function
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
topy	int
,	O
(	O
unsigned	O
int	O
)	O
(	O
bottom	int
->	O
height	int
+	O
bottomy	int
-	O
topy	int
)	O
,	O
lefts	array
,	O
rights	array
,	O
2	int
,	O
2	int
)	O
;	O
}	O
}	O
void	O
miWideDash	O
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
miCoordMode	enum
mode	enum
,	O
int	O
npt	int
,	O
const	O
miPoint	struct
*	O
pPts	pointer
)	O
{	O
int	O
x1	double
,	O
y1	function
,	O
x2	double
,	O
y2	double
;	O
int	O
dashNum	int
;	O
int	O
dashIndex	int
;	O
int	O
dashOffset	int
;	O
int	O
startPaintType	int
,	O
endPaintType	int
=	O
0	int
,	O
prevEndPaintType	int
=	O
0	int
;	O
int	O
firstPaintType	int
=	O
0	int
;	O
int	O
numPixels	int
;	O
bool	enum
selfJoin	enum
;	O
bool	enum
first	enum
;	O
bool	enum
somethingDrawn	enum
=	O
false	int
;	O
bool	enum
projectLeft	enum
,	O
projectRight	enum
;	O
LineFace	struct
leftFace	pointer
,	O
rightFace	pointer
,	O
prevRightFace	struct
;	O
LineFace	struct
firstFace	struct
;	O
miPixel	struct
pixel	struct
;	O
if	O
(	O
npt	int
<=	O
0	int
)	O
return	O
;	O
if	O
(	O
pGC	pointer
->	O
lineWidth	int
==	O
0	int
)	O
{	O
miZeroDash	O
(	O
paintedSet	pointer
,	O
pGC	pointer
,	O
mode	enum
,	O
npt	int
,	O
pPts	pointer
)	O
;	O
return	O
;	O
}	O
x2	double
=	O
pPts	pointer
->	O
x	double
;	O
y2	double
=	O
pPts	pointer
->	O
y	double
;	O
first	enum
=	O
true	int
;	O
selfJoin	enum
=	O
false	int
;	O
if	O
(	O
mode	enum
==	O
MI_COORD_MODE_PREVIOUS	int
)	O
{	O
int	O
nptTmp	int
;	O
const	O
miPoint	struct
*	O
pPtsTmp	pointer
;	O
x1	double
=	O
x2	double
;	O
y1	function
=	O
y2	double
;	O
nptTmp	int
=	O
npt	int
;	O
pPtsTmp	pointer
=	O
pPts	pointer
+	O
1	int
;	O
while	O
(	O
--	O
nptTmp	int
)	O
{	O
x1	double
+=	O
pPtsTmp	pointer
->	O
x	double
;	O
y1	function
+=	O
pPtsTmp	pointer
->	O
y	double
;	O
++	O
pPtsTmp	pointer
;	O
}	O
if	O
(	O
x2	double
==	O
x1	double
&&	O
y2	double
==	O
y1	function
)	O
selfJoin	enum
=	O
true	int
;	O
}	O
else	O
if	O
(	O
x2	double
==	O
pPts	pointer
[	O
npt	int
-	O
1	int
]	O
.	O
x	double
&&	O
y2	double
==	O
pPts	pointer
[	O
npt	int
-	O
1	int
]	O
.	O
y	double
)	O
selfJoin	enum
=	O
true	int
;	O
projectLeft	enum
=	O
(	O
pGC	pointer
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_PROJECTING	int
&&	O
!	O
selfJoin	enum
)	O
?	O
true	int
:	O
false	int
;	O
projectRight	enum
=	O
false	int
;	O
dashNum	int
=	O
0	int
;	O
dashIndex	int
=	O
0	int
;	O
dashOffset	int
=	O
0	int
;	O
miStepDash	O
(	O
pGC	pointer
->	O
dashOffset	int
,	O
&	O
dashNum	int
,	O
&	O
dashIndex	int
,	O
pGC	pointer
->	O
dash	pointer
,	O
pGC	pointer
->	O
numInDashList	int
,	O
&	O
dashOffset	int
)	O
;	O
numPixels	int
=	O
pGC	pointer
->	O
numPixels	int
;	O
while	O
(	O
--	O
npt	int
)	O
{	O
x1	double
=	O
x2	double
;	O
y1	function
=	O
y2	double
;	O
++	O
pPts	pointer
;	O
x2	double
=	O
pPts	pointer
->	O
x	double
;	O
y2	double
=	O
pPts	pointer
->	O
y	double
;	O
if	O
(	O
mode	enum
==	O
MI_COORD_MODE_PREVIOUS	int
)	O
{	O
x2	double
+=	O
x1	double
;	O
y2	double
+=	O
y1	function
;	O
}	O
if	O
(	O
x1	double
!=	O
x2	double
||	O
y1	function
!=	O
y2	double
)	O
{	O
int	O
prevDashNum	int
,	O
lastPaintedDashNum	int
;	O
if	O
(	O
npt	int
==	O
1	int
&&	O
pGC	pointer
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_PROJECTING	int
&&	O
(	O
!	O
selfJoin	enum
||	O
(	O
firstPaintType	int
==	O
0	int
)	O
)	O
)	O
projectRight	enum
=	O
true	int
;	O
prevDashNum	int
=	O
dashNum	int
;	O
miWideDashSegment	function
(	O
paintedSet	pointer
,	O
pGC	pointer
,	O
&	O
dashNum	int
,	O
&	O
dashIndex	int
,	O
&	O
dashOffset	int
,	O
x1	double
,	O
y1	function
,	O
x2	double
,	O
y2	double
,	O
projectLeft	enum
,	O
projectRight	enum
,	O
&	O
leftFace	pointer
,	O
&	O
rightFace	pointer
)	O
;	O
startPaintType	int
=	O
(	O
(	O
dashNum	int
&	O
1	int
)	O
?	O
0	int
:	O
1	int
+	O
(	O
(	O
dashNum	int
/	O
2	int
)	O
%	O
(	O
numPixels	int
-	O
1	int
)	O
)	O
)	O
;	O
lastPaintedDashNum	int
=	O
(	O
dashOffset	int
!=	O
0	int
?	O
dashNum	int
:	O
dashNum	int
-	O
1	int
)	O
;	O
endPaintType	int
=	O
(	O
(	O
lastPaintedDashNum	int
&	O
1	int
)	O
?	O
0	int
:	O
1	int
+	O
(	O
(	O
dashNum	int
/	O
2	int
)	O
%	O
(	O
numPixels	int
-	O
1	int
)	O
)	O
)	O
;	O
if	O
(	O
pGC	pointer
->	O
lineStyle	int
==	O
(	O
int	O
)	O
MI_LINE_DOUBLE_DASH	int
||	O
(	O
startPaintType	int
!=	O
0	int
)	O
)	O
{	O
pixel	struct
=	O
pGC	pointer
->	O
pixels	pointer
[	O
startPaintType	int
]	O
;	O
if	O
(	O
first	enum
||	O
(	O
pGC	pointer
->	O
lineStyle	int
==	O
(	O
int	O
)	O
MI_LINE_ON_OFF_DASH	int
&&	O
prevEndPaintType	int
==	O
0	int
)	O
)	O
{	O
if	O
(	O
first	enum
&&	O
selfJoin	enum
)	O
{	O
firstFace	struct
=	O
leftFace	pointer
;	O
firstPaintType	int
=	O
startPaintType	int
;	O
}	O
else	O
if	O
(	O
pGC	pointer
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_ROUND	int
||	O
pGC	pointer
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_TRIANGULAR	int
)	O
miLineArc	function
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
pGC	pointer
,	O
&	O
leftFace	pointer
,	O
(	O
LineFace	struct
*	O
)	O
NULL	O
,	O
(	O
double	O
)	O
0.0	int
,	O
(	O
double	O
)	O
0.0	int
,	O
true	int
)	O
;	O
}	O
else	O
miLineJoin	function
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
pGC	pointer
,	O
&	O
leftFace	pointer
,	O
&	O
prevRightFace	struct
)	O
;	O
}	O
somethingDrawn	enum
=	O
true	int
;	O
first	enum
=	O
false	int
;	O
prevRightFace	struct
=	O
rightFace	pointer
;	O
prevEndPaintType	int
=	O
endPaintType	int
;	O
projectLeft	enum
=	O
false	int
;	O
}	O
if	O
(	O
npt	int
==	O
1	int
&&	O
somethingDrawn	enum
)	O
{	O
if	O
(	O
pGC	pointer
->	O
lineStyle	int
==	O
(	O
int	O
)	O
MI_LINE_DOUBLE_DASH	int
||	O
(	O
endPaintType	int
!=	O
0	int
)	O
)	O
{	O
pixel	struct
=	O
pGC	pointer
->	O
pixels	pointer
[	O
endPaintType	int
]	O
;	O
if	O
(	O
selfJoin	enum
&&	O
(	O
pGC	pointer
->	O
lineStyle	int
==	O
(	O
int	O
)	O
MI_LINE_DOUBLE_DASH	int
||	O
(	O
firstPaintType	int
!=	O
0	int
)	O
)	O
)	O
miLineJoin	function
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
pGC	pointer
,	O
&	O
firstFace	struct
,	O
&	O
rightFace	pointer
)	O
;	O
else	O
{	O
if	O
(	O
pGC	pointer
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_ROUND	int
||	O
pGC	pointer
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_TRIANGULAR	int
)	O
miLineArc	function
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
pGC	pointer
,	O
(	O
LineFace	struct
*	O
)	O
NULL	O
,	O
&	O
rightFace	pointer
,	O
(	O
double	O
)	O
0.0	int
,	O
(	O
double	O
)	O
0.0	int
,	O
true	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
selfJoin	enum
&&	O
(	O
firstPaintType	int
!=	O
0	int
)	O
)	O
{	O
pixel	struct
=	O
pGC	pointer
->	O
pixels	pointer
[	O
firstPaintType	int
]	O
;	O
if	O
(	O
pGC	pointer
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_PROJECTING	int
)	O
miLineProjectingCap	function
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
pGC	pointer
,	O
&	O
firstFace	struct
,	O
true	int
,	O
true	int
)	O
;	O
else	O
if	O
(	O
pGC	pointer
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_ROUND	int
||	O
pGC	pointer
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_TRIANGULAR	int
)	O
miLineArc	function
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
pGC	pointer
,	O
&	O
firstFace	struct
,	O
(	O
LineFace	struct
*	O
)	O
NULL	O
,	O
(	O
double	O
)	O
0.0	int
,	O
(	O
double	O
)	O
0.0	int
,	O
true	int
)	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
!	O
somethingDrawn	enum
&&	O
(	O
pGC	pointer
->	O
lineStyle	int
==	O
(	O
int	O
)	O
MI_LINE_DOUBLE_DASH	int
||	O
!	O
(	O
dashNum	int
&	O
1	int
)	O
)	O
)	O
{	O
unsigned	O
int	O
w1	int
;	O
pixel	struct
=	O
(	O
dashNum	int
&	O
1	int
)	O
?	O
pGC	pointer
->	O
pixels	pointer
[	O
0	int
]	O
:	O
pGC	pointer
->	O
pixels	pointer
[	O
1	int
]	O
;	O
switch	O
(	O
(	O
int	O
)	O
pGC	pointer
->	O
capStyle	int
)	O
{	O
case	O
(	O
int	O
)	O
MI_CAP_ROUND	int
:	O
case	O
(	O
int	O
)	O
MI_CAP_TRIANGULAR	int
:	O
miLineArc	function
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
pGC	pointer
,	O
(	O
LineFace	struct
*	O
)	O
NULL	O
,	O
(	O
LineFace	struct
*	O
)	O
NULL	O
,	O
(	O
double	O
)	O
x2	double
,	O
(	O
double	O
)	O
y2	double
,	O
false	int
)	O
;	O
break	O
;	O
case	O
(	O
int	O
)	O
MI_CAP_PROJECTING	int
:	O
w1	int
=	O
pGC	pointer
->	O
lineWidth	int
;	O
miFillRectPolyHelper	function
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
(	O
int	O
)	O
(	O
x2	double
-	O
(	O
w1	int
>>	O
1	int
)	O
)	O
,	O
(	O
int	O
)	O
(	O
y2	double
-	O
(	O
w1	int
>>	O
1	int
)	O
)	O
,	O
w1	int
,	O
w1	int
)	O
;	O
break	O
;	O
case	O
(	O
int	O
)	O
MI_CAP_BUTT	int
:	O
default	O
:	O
break	O
;	O
}	O
}	O
}	O
static	O
void	O
miWideDashSegment	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
int	O
*	O
pDashNum	pointer
,	O
int	O
*	O
pDashIndex	pointer
,	O
int	O
*	O
pDashOffset	pointer
,	O
int	O
x1	double
,	O
int	O
y1	function
,	O
int	O
x2	double
,	O
int	O
y2	double
,	O
bool	enum
projectLeft	enum
,	O
bool	enum
projectRight	enum
,	O
LineFace	struct
*	O
leftFace	pointer
,	O
LineFace	struct
*	O
rightFace	pointer
)	O
{	O
int	O
dashNum	int
,	O
dashIndex	int
,	O
dashRemain	int
;	O
unsigned	O
int	O
*	O
pDash	pointer
;	O
double	O
L	double
,	O
l	double
;	O
double	O
k	double
;	O
PolyVertex	struct
vertices	pointer
[	O
4	int
]	O
;	O
PolyVertex	struct
saveRight	struct
,	O
saveBottom	struct
;	O
PolySlope	struct
slopes	pointer
[	O
4	int
]	O
;	O
PolyEdge	struct
left	pointer
[	O
2	int
]	O
,	O
right	pointer
[	O
2	int
]	O
;	O
LineFace	struct
lcapFace	struct
,	O
rcapFace	struct
;	O
int	O
nleft	int
,	O
nright	int
;	O
unsigned	O
int	O
h	int
;	O
int	O
y	double
;	O
int	O
dy	int
,	O
dx	int
;	O
double	O
LRemain	double
;	O
double	O
r	int
;	O
double	O
rdx	double
,	O
rdy	double
;	O
double	O
dashDx	double
,	O
dashDy	double
;	O
double	O
saveK	double
=	O
0.0	int
;	O
bool	enum
first	enum
=	O
true	int
;	O
double	O
lcenterx	double
,	O
lcentery	double
,	O
rcenterx	double
=	O
0.0	int
,	O
rcentery	double
=	O
0.0	int
;	O
miPixel	struct
pixel	struct
;	O
int	O
numPixels	int
,	O
paintType	int
;	O
dx	int
=	O
x2	double
-	O
x1	double
;	O
dy	int
=	O
y2	double
-	O
y1	function
;	O
dashNum	int
=	O
*	O
pDashNum	pointer
;	O
dashIndex	int
=	O
*	O
pDashIndex	pointer
;	O
pDash	pointer
=	O
pGC	pointer
->	O
dash	pointer
;	O
dashRemain	int
=	O
(	O
int	O
)	O
(	O
pDash	pointer
[	O
dashIndex	int
]	O
)	O
-	O
*	O
pDashOffset	pointer
;	O
numPixels	int
=	O
pGC	pointer
->	O
numPixels	int
;	O
paintType	int
=	O
(	O
dashNum	int
&	O
1	int
)	O
?	O
0	int
:	O
1	int
+	O
(	O
(	O
dashNum	int
/	O
2	int
)	O
%	O
(	O
numPixels	int
-	O
1	int
)	O
)	O
;	O
pixel	struct
=	O
pGC	pointer
->	O
pixels	pointer
[	O
paintType	int
]	O
;	O
l	double
=	O
0.5	int
*	O
(	O
(	O
double	O
)	O
pGC	pointer
->	O
lineWidth	int
)	O
;	O
if	O
(	O
dx	int
==	O
0	int
)	O
{	O
L	double
=	O
dy	int
;	O
rdx	double
=	O
0	int
;	O
rdy	double
=	O
l	double
;	O
if	O
(	O
dy	int
<	O
0	int
)	O
{	O
L	double
=	O
-	O
dy	int
;	O
rdy	double
=	O
-	O
l	double
;	O
}	O
}	O
else	O
if	O
(	O
dy	int
==	O
0	int
)	O
{	O
L	double
=	O
dx	int
;	O
rdx	double
=	O
l	double
;	O
rdy	double
=	O
0	int
;	O
if	O
(	O
dx	int
<	O
0	int
)	O
{	O
L	double
=	O
-	O
dx	int
;	O
rdx	double
=	O
-	O
l	double
;	O
}	O
}	O
else	O
{	O
L	double
=	O
hypot	function
(	O
(	O
double	O
)	O
dx	int
,	O
(	O
double	O
)	O
dy	int
)	O
;	O
r	int
=	O
l	double
/	O
L	double
;	O
rdx	double
=	O
r	int
*	O
dx	int
;	O
rdy	double
=	O
r	int
*	O
dy	int
;	O
}	O
k	double
=	O
l	double
*	O
L	double
;	O
slopes	pointer
[	O
V_TOP	int
]	O
.	O
dx	int
=	O
dx	int
;	O
slopes	pointer
[	O
V_TOP	int
]	O
.	O
dy	int
=	O
dy	int
;	O
slopes	pointer
[	O
V_TOP	int
]	O
.	O
k	double
=	O
k	double
;	O
slopes	pointer
[	O
V_RIGHT	int
]	O
.	O
dx	int
=	O
-	O
dy	int
;	O
slopes	pointer
[	O
V_RIGHT	int
]	O
.	O
dy	int
=	O
dx	int
;	O
slopes	pointer
[	O
V_RIGHT	int
]	O
.	O
k	double
=	O
0	int
;	O
slopes	pointer
[	O
V_BOTTOM	int
]	O
.	O
dx	int
=	O
-	O
dx	int
;	O
slopes	pointer
[	O
V_BOTTOM	int
]	O
.	O
dy	int
=	O
-	O
dy	int
;	O
slopes	pointer
[	O
V_BOTTOM	int
]	O
.	O
k	double
=	O
k	double
;	O
slopes	pointer
[	O
V_LEFT	int
]	O
.	O
dx	int
=	O
dy	int
;	O
slopes	pointer
[	O
V_LEFT	int
]	O
.	O
dy	int
=	O
-	O
dx	int
;	O
slopes	pointer
[	O
V_LEFT	int
]	O
.	O
k	double
=	O
0	int
;	O
vertices	pointer
[	O
V_RIGHT	int
]	O
.	O
x	double
=	O
vertices	pointer
[	O
V_TOP	int
]	O
.	O
x	double
=	O
rdy	double
;	O
vertices	pointer
[	O
V_RIGHT	int
]	O
.	O
y	double
=	O
vertices	pointer
[	O
V_TOP	int
]	O
.	O
y	double
=	O
-	O
rdx	double
;	O
vertices	pointer
[	O
V_BOTTOM	int
]	O
.	O
x	double
=	O
vertices	pointer
[	O
V_LEFT	int
]	O
.	O
x	double
=	O
-	O
rdy	double
;	O
vertices	pointer
[	O
V_BOTTOM	int
]	O
.	O
y	double
=	O
vertices	pointer
[	O
V_LEFT	int
]	O
.	O
y	double
=	O
rdx	double
;	O
if	O
(	O
projectLeft	enum
)	O
{	O
vertices	pointer
[	O
V_TOP	int
]	O
.	O
x	double
-=	O
rdx	double
;	O
vertices	pointer
[	O
V_TOP	int
]	O
.	O
y	double
-=	O
rdy	double
;	O
vertices	pointer
[	O
V_LEFT	int
]	O
.	O
x	double
-=	O
rdx	double
;	O
vertices	pointer
[	O
V_LEFT	int
]	O
.	O
y	double
-=	O
rdy	double
;	O
slopes	pointer
[	O
V_LEFT	int
]	O
.	O
k	double
=	O
rdx	double
*	O
dx	int
+	O
rdy	double
*	O
dy	int
;	O
}	O
lcenterx	double
=	O
x1	double
;	O
lcentery	double
=	O
y1	function
;	O
if	O
(	O
pGC	pointer
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_ROUND	int
||	O
pGC	pointer
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_TRIANGULAR	int
)	O
{	O
lcapFace	struct
.	O
dx	int
=	O
dx	int
;	O
lcapFace	struct
.	O
dy	int
=	O
dy	int
;	O
lcapFace	struct
.	O
x	double
=	O
x1	double
;	O
lcapFace	struct
.	O
y	double
=	O
y1	function
;	O
rcapFace	struct
.	O
dx	int
=	O
-	O
dx	int
;	O
rcapFace	struct
.	O
dy	int
=	O
-	O
dy	int
;	O
rcapFace	struct
.	O
x	double
=	O
x1	double
;	O
rcapFace	struct
.	O
y	double
=	O
y1	function
;	O
}	O
LRemain	double
=	O
L	double
;	O
while	O
(	O
LRemain	double
>	O
dashRemain	int
)	O
{	O
dashDx	double
=	O
(	O
dashRemain	int
*	O
dx	int
)	O
/	O
L	double
;	O
dashDy	double
=	O
(	O
dashRemain	int
*	O
dy	int
)	O
/	O
L	double
;	O
rcenterx	double
=	O
lcenterx	double
+	O
dashDx	double
;	O
rcentery	double
=	O
lcentery	double
+	O
dashDy	double
;	O
vertices	pointer
[	O
V_RIGHT	int
]	O
.	O
x	double
+=	O
dashDx	double
;	O
vertices	pointer
[	O
V_RIGHT	int
]	O
.	O
y	double
+=	O
dashDy	double
;	O
vertices	pointer
[	O
V_BOTTOM	int
]	O
.	O
x	double
+=	O
dashDx	double
;	O
vertices	pointer
[	O
V_BOTTOM	int
]	O
.	O
y	double
+=	O
dashDy	double
;	O
slopes	pointer
[	O
V_RIGHT	int
]	O
.	O
k	double
=	O
vertices	pointer
[	O
V_RIGHT	int
]	O
.	O
x	double
*	O
dx	int
+	O
vertices	pointer
[	O
V_RIGHT	int
]	O
.	O
y	double
*	O
dy	int
;	O
if	O
(	O
pGC	pointer
->	O
lineStyle	int
==	O
(	O
int	O
)	O
MI_LINE_DOUBLE_DASH	int
||	O
!	O
(	O
paintType	int
==	O
0	int
)	O
)	O
{	O
if	O
(	O
pGC	pointer
->	O
lineStyle	int
==	O
(	O
int	O
)	O
MI_LINE_ON_OFF_DASH	int
&&	O
pGC	pointer
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_PROJECTING	int
)	O
{	O
saveRight	struct
=	O
vertices	pointer
[	O
V_RIGHT	int
]	O
;	O
saveBottom	struct
=	O
vertices	pointer
[	O
V_BOTTOM	int
]	O
;	O
saveK	double
=	O
slopes	pointer
[	O
V_RIGHT	int
]	O
.	O
k	double
;	O
if	O
(	O
!	O
first	enum
)	O
{	O
vertices	pointer
[	O
V_TOP	int
]	O
.	O
x	double
-=	O
rdx	double
;	O
vertices	pointer
[	O
V_TOP	int
]	O
.	O
y	double
-=	O
rdy	double
;	O
vertices	pointer
[	O
V_LEFT	int
]	O
.	O
x	double
-=	O
rdx	double
;	O
vertices	pointer
[	O
V_LEFT	int
]	O
.	O
y	double
-=	O
rdy	double
;	O
slopes	pointer
[	O
V_LEFT	int
]	O
.	O
k	double
=	O
vertices	pointer
[	O
V_LEFT	int
]	O
.	O
x	double
*	O
slopes	pointer
[	O
V_LEFT	int
]	O
.	O
dy	int
-	O
vertices	pointer
[	O
V_LEFT	int
]	O
.	O
y	double
*	O
slopes	pointer
[	O
V_LEFT	int
]	O
.	O
dx	int
;	O
}	O
vertices	pointer
[	O
V_RIGHT	int
]	O
.	O
x	double
+=	O
rdx	double
;	O
vertices	pointer
[	O
V_RIGHT	int
]	O
.	O
y	double
+=	O
rdy	double
;	O
vertices	pointer
[	O
V_BOTTOM	int
]	O
.	O
x	double
+=	O
rdx	double
;	O
vertices	pointer
[	O
V_BOTTOM	int
]	O
.	O
y	double
+=	O
rdy	double
;	O
slopes	pointer
[	O
V_RIGHT	int
]	O
.	O
k	double
=	O
vertices	pointer
[	O
V_RIGHT	int
]	O
.	O
x	double
*	O
slopes	pointer
[	O
V_RIGHT	int
]	O
.	O
dy	int
-	O
vertices	pointer
[	O
V_RIGHT	int
]	O
.	O
y	double
*	O
slopes	pointer
[	O
V_RIGHT	int
]	O
.	O
dx	int
;	O
}	O
y	double
=	O
miPolyBuildPoly	function
(	O
vertices	pointer
,	O
slopes	pointer
,	O
4	int
,	O
x1	double
,	O
y1	function
,	O
left	pointer
,	O
right	pointer
,	O
&	O
nleft	int
,	O
&	O
nright	int
,	O
&	O
h	int
)	O
;	O
miFillPolyHelper	function
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
y	double
,	O
h	int
,	O
left	pointer
,	O
right	pointer
,	O
nleft	int
,	O
nright	int
)	O
;	O
if	O
(	O
pGC	pointer
->	O
lineStyle	int
==	O
(	O
int	O
)	O
MI_LINE_ON_OFF_DASH	int
)	O
{	O
switch	O
(	O
(	O
int	O
)	O
pGC	pointer
->	O
capStyle	int
)	O
{	O
case	O
(	O
int	O
)	O
MI_CAP_BUTT	int
:	O
default	O
:	O
break	O
;	O
case	O
(	O
int	O
)	O
MI_CAP_PROJECTING	int
:	O
vertices	pointer
[	O
V_BOTTOM	int
]	O
=	O
saveBottom	struct
;	O
vertices	pointer
[	O
V_RIGHT	int
]	O
=	O
saveRight	struct
;	O
slopes	pointer
[	O
V_RIGHT	int
]	O
.	O
k	double
=	O
saveK	double
;	O
break	O
;	O
case	O
(	O
int	O
)	O
MI_CAP_ROUND	int
:	O
case	O
(	O
int	O
)	O
MI_CAP_TRIANGULAR	int
:	O
if	O
(	O
!	O
first	enum
)	O
{	O
if	O
(	O
dx	int
<	O
0	int
)	O
{	O
lcapFace	struct
.	O
xa	double
=	O
-	O
vertices	pointer
[	O
V_LEFT	int
]	O
.	O
x	double
;	O
lcapFace	struct
.	O
ya	double
=	O
-	O
vertices	pointer
[	O
V_LEFT	int
]	O
.	O
y	double
;	O
lcapFace	struct
.	O
k	double
=	O
slopes	pointer
[	O
V_LEFT	int
]	O
.	O
k	double
;	O
}	O
else	O
{	O
lcapFace	struct
.	O
xa	double
=	O
vertices	pointer
[	O
V_TOP	int
]	O
.	O
x	double
;	O
lcapFace	struct
.	O
ya	double
=	O
vertices	pointer
[	O
V_TOP	int
]	O
.	O
y	double
;	O
lcapFace	struct
.	O
k	double
=	O
-	O
slopes	pointer
[	O
V_LEFT	int
]	O
.	O
k	double
;	O
}	O
miLineArc	function
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
pGC	pointer
,	O
&	O
lcapFace	struct
,	O
(	O
LineFace	struct
*	O
)	O
NULL	O
,	O
lcenterx	double
,	O
lcentery	double
,	O
false	int
)	O
;	O
}	O
if	O
(	O
dx	int
<	O
0	int
)	O
{	O
rcapFace	struct
.	O
xa	double
=	O
vertices	pointer
[	O
V_BOTTOM	int
]	O
.	O
x	double
;	O
rcapFace	struct
.	O
ya	double
=	O
vertices	pointer
[	O
V_BOTTOM	int
]	O
.	O
y	double
;	O
rcapFace	struct
.	O
k	double
=	O
slopes	pointer
[	O
V_RIGHT	int
]	O
.	O
k	double
;	O
}	O
else	O
{	O
rcapFace	struct
.	O
xa	double
=	O
-	O
vertices	pointer
[	O
V_RIGHT	int
]	O
.	O
x	double
;	O
rcapFace	struct
.	O
ya	double
=	O
-	O
vertices	pointer
[	O
V_RIGHT	int
]	O
.	O
y	double
;	O
rcapFace	struct
.	O
k	double
=	O
-	O
slopes	pointer
[	O
V_RIGHT	int
]	O
.	O
k	double
;	O
}	O
miLineArc	function
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
pGC	pointer
,	O
(	O
LineFace	struct
*	O
)	O
NULL	O
,	O
&	O
rcapFace	struct
,	O
rcenterx	double
,	O
rcentery	double
,	O
false	int
)	O
;	O
break	O
;	O
}	O
}	O
}	O
LRemain	double
-=	O
dashRemain	int
;	O
++	O
dashNum	int
;	O
++	O
dashIndex	int
;	O
if	O
(	O
dashIndex	int
==	O
pGC	pointer
->	O
numInDashList	int
)	O
dashIndex	int
=	O
0	int
;	O
dashRemain	int
=	O
(	O
int	O
)	O
(	O
pDash	pointer
[	O
dashIndex	int
]	O
)	O
;	O
paintType	int
=	O
(	O
dashNum	int
&	O
1	int
)	O
?	O
0	int
:	O
1	int
+	O
(	O
(	O
dashNum	int
/	O
2	int
)	O
%	O
(	O
numPixels	int
-	O
1	int
)	O
)	O
;	O
pixel	struct
=	O
pGC	pointer
->	O
pixels	pointer
[	O
paintType	int
]	O
;	O
lcenterx	double
=	O
rcenterx	double
;	O
lcentery	double
=	O
rcentery	double
;	O
vertices	pointer
[	O
V_TOP	int
]	O
=	O
vertices	pointer
[	O
V_RIGHT	int
]	O
;	O
vertices	pointer
[	O
V_LEFT	int
]	O
=	O
vertices	pointer
[	O
V_BOTTOM	int
]	O
;	O
slopes	pointer
[	O
V_LEFT	int
]	O
.	O
k	double
=	O
-	O
slopes	pointer
[	O
V_RIGHT	int
]	O
.	O
k	double
;	O
first	enum
=	O
false	int
;	O
}	O
if	O
(	O
pGC	pointer
->	O
lineStyle	int
==	O
(	O
int	O
)	O
MI_LINE_DOUBLE_DASH	int
||	O
!	O
(	O
paintType	int
==	O
0	int
)	O
)	O
{	O
vertices	pointer
[	O
V_TOP	int
]	O
.	O
x	double
-=	O
dx	int
;	O
vertices	pointer
[	O
V_TOP	int
]	O
.	O
y	double
-=	O
dy	int
;	O
vertices	pointer
[	O
V_LEFT	int
]	O
.	O
x	double
-=	O
dx	int
;	O
vertices	pointer
[	O
V_LEFT	int
]	O
.	O
y	double
-=	O
dy	int
;	O
vertices	pointer
[	O
V_RIGHT	int
]	O
.	O
x	double
=	O
rdy	double
;	O
vertices	pointer
[	O
V_RIGHT	int
]	O
.	O
y	double
=	O
-	O
rdx	double
;	O
vertices	pointer
[	O
V_BOTTOM	int
]	O
.	O
x	double
=	O
-	O
rdy	double
;	O
vertices	pointer
[	O
V_BOTTOM	int
]	O
.	O
y	double
=	O
rdx	double
;	O
if	O
(	O
projectRight	enum
)	O
{	O
vertices	pointer
[	O
V_RIGHT	int
]	O
.	O
x	double
+=	O
rdx	double
;	O
vertices	pointer
[	O
V_RIGHT	int
]	O
.	O
y	double
+=	O
rdy	double
;	O
vertices	pointer
[	O
V_BOTTOM	int
]	O
.	O
x	double
+=	O
rdx	double
;	O
vertices	pointer
[	O
V_BOTTOM	int
]	O
.	O
y	double
+=	O
rdy	double
;	O
slopes	pointer
[	O
V_RIGHT	int
]	O
.	O
k	double
=	O
vertices	pointer
[	O
V_RIGHT	int
]	O
.	O
x	double
*	O
slopes	pointer
[	O
V_RIGHT	int
]	O
.	O
dy	int
-	O
vertices	pointer
[	O
V_RIGHT	int
]	O
.	O
y	double
*	O
slopes	pointer
[	O
V_RIGHT	int
]	O
.	O
dx	int
;	O
}	O
else	O
slopes	pointer
[	O
V_RIGHT	int
]	O
.	O
k	double
=	O
0	int
;	O
if	O
(	O
!	O
first	enum
&&	O
pGC	pointer
->	O
lineStyle	int
==	O
(	O
int	O
)	O
MI_LINE_ON_OFF_DASH	int
&&	O
pGC	pointer
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_PROJECTING	int
)	O
{	O
vertices	pointer
[	O
V_TOP	int
]	O
.	O
x	double
-=	O
rdx	double
;	O
vertices	pointer
[	O
V_TOP	int
]	O
.	O
y	double
-=	O
rdy	double
;	O
vertices	pointer
[	O
V_LEFT	int
]	O
.	O
x	double
-=	O
rdx	double
;	O
vertices	pointer
[	O
V_LEFT	int
]	O
.	O
y	double
-=	O
rdy	double
;	O
slopes	pointer
[	O
V_LEFT	int
]	O
.	O
k	double
=	O
vertices	pointer
[	O
V_LEFT	int
]	O
.	O
x	double
*	O
slopes	pointer
[	O
V_LEFT	int
]	O
.	O
dy	int
-	O
vertices	pointer
[	O
V_LEFT	int
]	O
.	O
y	double
*	O
slopes	pointer
[	O
V_LEFT	int
]	O
.	O
dx	int
;	O
}	O
else	O
slopes	pointer
[	O
V_LEFT	int
]	O
.	O
k	double
+=	O
dx	int
*	O
dx	int
+	O
dy	int
*	O
dy	int
;	O
y	double
=	O
miPolyBuildPoly	function
(	O
vertices	pointer
,	O
slopes	pointer
,	O
4	int
,	O
x2	double
,	O
y2	double
,	O
left	pointer
,	O
right	pointer
,	O
&	O
nleft	int
,	O
&	O
nright	int
,	O
&	O
h	int
)	O
;	O
miFillPolyHelper	function
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
y	double
,	O
h	int
,	O
left	pointer
,	O
right	pointer
,	O
nleft	int
,	O
nright	int
)	O
;	O
if	O
(	O
!	O
first	enum
&&	O
pGC	pointer
->	O
lineStyle	int
==	O
(	O
int	O
)	O
MI_LINE_ON_OFF_DASH	int
&&	O
(	O
pGC	pointer
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_ROUND	int
||	O
pGC	pointer
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_TRIANGULAR	int
)	O
)	O
{	O
lcapFace	struct
.	O
x	double
=	O
x2	double
;	O
lcapFace	struct
.	O
y	double
=	O
y2	double
;	O
if	O
(	O
dx	int
<	O
0	int
)	O
{	O
lcapFace	struct
.	O
xa	double
=	O
-	O
vertices	pointer
[	O
V_LEFT	int
]	O
.	O
x	double
;	O
lcapFace	struct
.	O
ya	double
=	O
-	O
vertices	pointer
[	O
V_LEFT	int
]	O
.	O
y	double
;	O
lcapFace	struct
.	O
k	double
=	O
slopes	pointer
[	O
V_LEFT	int
]	O
.	O
k	double
;	O
}	O
else	O
{	O
lcapFace	struct
.	O
xa	double
=	O
vertices	pointer
[	O
V_TOP	int
]	O
.	O
x	double
;	O
lcapFace	struct
.	O
ya	double
=	O
vertices	pointer
[	O
V_TOP	int
]	O
.	O
y	double
;	O
lcapFace	struct
.	O
k	double
=	O
-	O
slopes	pointer
[	O
V_LEFT	int
]	O
.	O
k	double
;	O
}	O
miLineArc	function
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
pGC	pointer
,	O
&	O
lcapFace	struct
,	O
(	O
LineFace	struct
*	O
)	O
NULL	O
,	O
rcenterx	double
,	O
rcentery	double
,	O
false	int
)	O
;	O
}	O
}	O
leftFace	pointer
->	O
x	double
=	O
x1	double
;	O
leftFace	pointer
->	O
y	double
=	O
y1	function
;	O
leftFace	pointer
->	O
dx	int
=	O
dx	int
;	O
leftFace	pointer
->	O
dy	int
=	O
dy	int
;	O
leftFace	pointer
->	O
xa	double
=	O
rdy	double
;	O
leftFace	pointer
->	O
ya	double
=	O
-	O
rdx	double
;	O
leftFace	pointer
->	O
k	double
=	O
k	double
;	O
rightFace	pointer
->	O
x	double
=	O
x2	double
;	O
rightFace	pointer
->	O
y	double
=	O
y2	double
;	O
rightFace	pointer
->	O
dx	int
=	O
-	O
dx	int
;	O
rightFace	pointer
->	O
dy	int
=	O
-	O
dy	int
;	O
rightFace	pointer
->	O
xa	double
=	O
-	O
rdy	double
;	O
rightFace	pointer
->	O
ya	double
=	O
rdx	double
;	O
rightFace	pointer
->	O
k	double
=	O
k	double
;	O
dashRemain	int
=	O
(	O
int	O
)	O
(	O
(	O
(	O
double	O
)	O
dashRemain	int
)	O
-	O
LRemain	double
)	O
;	O
if	O
(	O
dashRemain	int
==	O
0	int
)	O
{	O
dashNum	int
++	O
;	O
dashIndex	int
++	O
;	O
if	O
(	O
dashIndex	int
==	O
pGC	pointer
->	O
numInDashList	int
)	O
dashIndex	int
=	O
0	int
;	O
dashRemain	int
=	O
(	O
int	O
)	O
(	O
pDash	pointer
[	O
dashIndex	int
]	O
)	O
;	O
}	O
*	O
pDashNum	pointer
=	O
dashNum	int
;	O
*	O
pDashIndex	pointer
=	O
dashIndex	int
;	O
*	O
pDashOffset	pointer
=	O
(	O
int	O
)	O
(	O
pDash	pointer
[	O
dashIndex	int
]	O
)	O
-	O
dashRemain	int
;	O
}	O
void	O
miStepDash	O
(	O
int	O
dist	int
,	O
int	O
*	O
pDashNum	pointer
,	O
int	O
*	O
pDashIndex	pointer
,	O
const	O
unsigned	O
int	O
*	O
pDash	pointer
,	O
int	O
numInDashList	int
,	O
int	O
*	O
pDashOffset	pointer
)	O
{	O
int	O
dashNum	int
,	O
dashIndex	int
,	O
dashOffset	int
;	O
int	O
totallen	int
;	O
int	O
i	int
;	O
dashNum	int
=	O
*	O
pDashNum	pointer
;	O
dashIndex	int
=	O
*	O
pDashIndex	pointer
;	O
dashOffset	int
=	O
*	O
pDashOffset	pointer
;	O
if	O
(	O
dashOffset	int
+	O
dist	int
<	O
(	O
int	O
)	O
(	O
pDash	pointer
[	O
dashIndex	int
]	O
)	O
)	O
{	O
*	O
pDashOffset	pointer
=	O
dashOffset	int
+	O
dist	int
;	O
return	O
;	O
}	O
dist	int
-=	O
(	O
int	O
)	O
(	O
pDash	pointer
[	O
dashIndex	int
]	O
)	O
-	O
dashOffset	int
;	O
dashNum	int
++	O
;	O
dashIndex	int
++	O
;	O
if	O
(	O
dashIndex	int
==	O
numInDashList	int
)	O
dashIndex	int
=	O
0	int
;	O
totallen	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
numInDashList	int
;	O
i	int
++	O
)	O
totallen	int
+=	O
(	O
int	O
)	O
(	O
pDash	pointer
[	O
i	int
]	O
)	O
;	O
if	O
(	O
totallen	int
<=	O
dist	int
)	O
dist	int
=	O
dist	int
%	O
totallen	int
;	O
while	O
(	O
dist	int
>=	O
(	O
int	O
)	O
(	O
pDash	pointer
[	O
dashIndex	int
]	O
)	O
)	O
{	O
dist	int
-=	O
(	O
int	O
)	O
(	O
pDash	pointer
[	O
dashIndex	int
]	O
)	O
;	O
dashNum	int
++	O
;	O
dashIndex	int
++	O
;	O
if	O
(	O
dashIndex	int
==	O
numInDashList	int
)	O
dashIndex	int
=	O
0	int
;	O
}	O
*	O
pDashNum	pointer
=	O
dashNum	int
;	O
*	O
pDashIndex	pointer
=	O
dashIndex	int
;	O
*	O
pDashOffset	pointer
=	O
dist	int
;	O
}	O
void	O
miWideLine	O
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
miCoordMode	enum
mode	enum
,	O
int	O
npt	int
,	O
const	O
miPoint	struct
*	O
pPts	pointer
)	O
{	O
int	O
x1	double
,	O
y1	function
,	O
x2	double
,	O
y2	double
;	O
bool	enum
projectLeft	enum
,	O
projectRight	enum
;	O
LineFace	struct
leftFace	pointer
,	O
rightFace	pointer
,	O
prevRightFace	struct
;	O
LineFace	struct
firstFace	struct
;	O
int	O
first	enum
;	O
bool	enum
somethingDrawn	enum
=	O
false	int
;	O
bool	enum
selfJoin	enum
;	O
if	O
(	O
npt	int
<=	O
0	int
)	O
return	O
;	O
if	O
(	O
pGC	pointer
->	O
lineWidth	int
==	O
0	int
)	O
{	O
miZeroLine	O
(	O
paintedSet	pointer
,	O
pGC	pointer
,	O
mode	enum
,	O
npt	int
,	O
pPts	pointer
)	O
;	O
return	O
;	O
}	O
x2	double
=	O
pPts	pointer
->	O
x	double
;	O
y2	double
=	O
pPts	pointer
->	O
y	double
;	O
first	enum
=	O
true	int
;	O
selfJoin	enum
=	O
false	int
;	O
if	O
(	O
npt	int
>	O
1	int
)	O
{	O
if	O
(	O
mode	enum
==	O
MI_COORD_MODE_PREVIOUS	int
)	O
{	O
int	O
nptTmp	int
;	O
const	O
miPoint	struct
*	O
pPtsTmp	pointer
;	O
x1	double
=	O
x2	double
;	O
y1	function
=	O
y2	double
;	O
nptTmp	int
=	O
npt	int
;	O
pPtsTmp	pointer
=	O
pPts	pointer
+	O
1	int
;	O
while	O
(	O
--	O
nptTmp	int
)	O
{	O
x1	double
+=	O
pPtsTmp	pointer
->	O
x	double
;	O
y1	function
+=	O
pPtsTmp	pointer
->	O
y	double
;	O
++	O
pPtsTmp	pointer
;	O
}	O
if	O
(	O
x2	double
==	O
x1	double
&&	O
y2	double
==	O
y1	function
)	O
selfJoin	enum
=	O
true	int
;	O
}	O
else	O
if	O
(	O
x2	double
==	O
pPts	pointer
[	O
npt	int
-	O
1	int
]	O
.	O
x	double
&&	O
y2	double
==	O
pPts	pointer
[	O
npt	int
-	O
1	int
]	O
.	O
y	double
)	O
selfJoin	enum
=	O
true	int
;	O
}	O
projectLeft	enum
=	O
(	O
pGC	pointer
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_PROJECTING	int
&&	O
!	O
selfJoin	enum
)	O
?	O
true	int
:	O
false	int
;	O
projectRight	enum
=	O
false	int
;	O
while	O
(	O
--	O
npt	int
)	O
{	O
x1	double
=	O
x2	double
;	O
y1	function
=	O
y2	double
;	O
++	O
pPts	pointer
;	O
x2	double
=	O
pPts	pointer
->	O
x	double
;	O
y2	double
=	O
pPts	pointer
->	O
y	double
;	O
if	O
(	O
mode	enum
==	O
MI_COORD_MODE_PREVIOUS	int
)	O
{	O
x2	double
+=	O
x1	double
;	O
y2	double
+=	O
y1	function
;	O
}	O
if	O
(	O
x1	double
!=	O
x2	double
||	O
y1	function
!=	O
y2	double
)	O
{	O
somethingDrawn	enum
=	O
true	int
;	O
if	O
(	O
npt	int
==	O
1	int
&&	O
pGC	pointer
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_PROJECTING	int
&&	O
!	O
selfJoin	enum
)	O
projectRight	enum
=	O
true	int
;	O
miWideSegment	function
(	O
paintedSet	pointer
,	O
pGC	pointer
->	O
pixels	pointer
[	O
1	int
]	O
,	O
pGC	pointer
,	O
x1	double
,	O
y1	function
,	O
x2	double
,	O
y2	double
,	O
projectLeft	enum
,	O
projectRight	enum
,	O
&	O
leftFace	pointer
,	O
&	O
rightFace	pointer
)	O
;	O
if	O
(	O
first	enum
)	O
{	O
if	O
(	O
selfJoin	enum
)	O
firstFace	struct
=	O
leftFace	pointer
;	O
else	O
if	O
(	O
pGC	pointer
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_ROUND	int
||	O
pGC	pointer
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_TRIANGULAR	int
)	O
miLineArc	function
(	O
paintedSet	pointer
,	O
pGC	pointer
->	O
pixels	pointer
[	O
1	int
]	O
,	O
pGC	pointer
,	O
&	O
leftFace	pointer
,	O
(	O
LineFace	struct
*	O
)	O
NULL	O
,	O
(	O
double	O
)	O
0.0	int
,	O
(	O
double	O
)	O
0.0	int
,	O
true	int
)	O
;	O
}	O
else	O
miLineJoin	function
(	O
paintedSet	pointer
,	O
pGC	pointer
->	O
pixels	pointer
[	O
1	int
]	O
,	O
pGC	pointer
,	O
&	O
leftFace	pointer
,	O
&	O
prevRightFace	struct
)	O
;	O
prevRightFace	struct
=	O
rightFace	pointer
;	O
first	enum
=	O
false	int
;	O
projectLeft	enum
=	O
false	int
;	O
}	O
if	O
(	O
npt	int
==	O
1	int
&&	O
somethingDrawn	enum
)	O
{	O
if	O
(	O
selfJoin	enum
)	O
miLineJoin	function
(	O
paintedSet	pointer
,	O
pGC	pointer
->	O
pixels	pointer
[	O
1	int
]	O
,	O
pGC	pointer
,	O
&	O
firstFace	struct
,	O
&	O
rightFace	pointer
)	O
;	O
else	O
if	O
(	O
pGC	pointer
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_ROUND	int
||	O
pGC	pointer
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_TRIANGULAR	int
)	O
miLineArc	function
(	O
paintedSet	pointer
,	O
pGC	pointer
->	O
pixels	pointer
[	O
1	int
]	O
,	O
pGC	pointer
,	O
(	O
LineFace	struct
*	O
)	O
NULL	O
,	O
&	O
rightFace	pointer
,	O
(	O
double	O
)	O
0.0	int
,	O
(	O
double	O
)	O
0.0	int
,	O
true	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
somethingDrawn	enum
)	O
{	O
projectLeft	enum
=	O
(	O
pGC	pointer
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_PROJECTING	int
)	O
?	O
true	int
:	O
false	int
;	O
miWideSegment	function
(	O
paintedSet	pointer
,	O
pGC	pointer
->	O
pixels	pointer
[	O
1	int
]	O
,	O
pGC	pointer
,	O
x2	double
,	O
y2	double
,	O
x2	double
,	O
y2	double
,	O
projectLeft	enum
,	O
projectLeft	enum
,	O
&	O
leftFace	pointer
,	O
&	O
rightFace	pointer
)	O
;	O
if	O
(	O
pGC	pointer
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_ROUND	int
||	O
pGC	pointer
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_TRIANGULAR	int
)	O
{	O
miLineArc	function
(	O
paintedSet	pointer
,	O
pGC	pointer
->	O
pixels	pointer
[	O
1	int
]	O
,	O
pGC	pointer
,	O
&	O
leftFace	pointer
,	O
(	O
LineFace	struct
*	O
)	O
NULL	O
,	O
(	O
double	O
)	O
0.0	int
,	O
(	O
double	O
)	O
0.0	int
,	O
true	int
)	O
;	O
rightFace	pointer
.	O
dx	int
=	O
-	O
1	int
;	O
miLineArc	function
(	O
paintedSet	pointer
,	O
pGC	pointer
->	O
pixels	pointer
[	O
1	int
]	O
,	O
pGC	pointer
,	O
(	O
LineFace	struct
*	O
)	O
NULL	O
,	O
&	O
rightFace	pointer
,	O
(	O
double	O
)	O
0.0	int
,	O
(	O
double	O
)	O
0.0	int
,	O
true	int
)	O
;	O
}	O
}	O
}	O
static	O
void	O
miWideSegment	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
miPixel	struct
pixel	struct
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
int	O
x1	double
,	O
int	O
y1	function
,	O
int	O
x2	double
,	O
int	O
y2	double
,	O
bool	enum
projectLeft	enum
,	O
bool	enum
projectRight	enum
,	O
LineFace	struct
*	O
leftFace	pointer
,	O
LineFace	struct
*	O
rightFace	pointer
)	O
{	O
int	O
dx	int
,	O
dy	int
;	O
int	O
x	double
,	O
y	double
;	O
int	O
signdx	int
;	O
int	O
lw	int
=	O
(	O
int	O
)	O
(	O
pGC	pointer
->	O
lineWidth	int
)	O
;	O
if	O
(	O
y2	double
<	O
y1	function
||	O
(	O
y2	double
==	O
y1	function
&&	O
x2	double
<	O
x1	double
)	O
)	O
{	O
int	O
tx	int
,	O
ty	int
;	O
bool	enum
tbool	enum
;	O
LineFace	struct
*	O
tface	pointer
;	O
tx	int
=	O
x1	double
;	O
x1	double
=	O
x2	double
;	O
x2	double
=	O
tx	int
;	O
ty	int
=	O
y1	function
;	O
y1	function
=	O
y2	double
;	O
y2	double
=	O
ty	int
;	O
tbool	enum
=	O
projectLeft	enum
;	O
projectLeft	enum
=	O
projectRight	enum
;	O
projectRight	enum
=	O
tbool	enum
;	O
tface	pointer
=	O
leftFace	pointer
;	O
leftFace	pointer
=	O
rightFace	pointer
;	O
rightFace	pointer
=	O
tface	pointer
;	O
}	O
dy	int
=	O
y2	double
-	O
y1	function
;	O
signdx	int
=	O
1	int
;	O
dx	int
=	O
x2	double
-	O
x1	double
;	O
if	O
(	O
dx	int
<	O
0	int
)	O
signdx	int
=	O
-	O
1	int
;	O
leftFace	pointer
->	O
x	double
=	O
x1	double
;	O
leftFace	pointer
->	O
y	double
=	O
y1	function
;	O
leftFace	pointer
->	O
dx	int
=	O
dx	int
;	O
leftFace	pointer
->	O
dy	int
=	O
dy	int
;	O
rightFace	pointer
->	O
x	double
=	O
x2	double
;	O
rightFace	pointer
->	O
y	double
=	O
y2	double
;	O
rightFace	pointer
->	O
dx	int
=	O
-	O
dx	int
;	O
rightFace	pointer
->	O
dy	int
=	O
-	O
dy	int
;	O
if	O
(	O
dy	int
==	O
0	int
)	O
{	O
rightFace	pointer
->	O
xa	double
=	O
0	int
;	O
rightFace	pointer
->	O
ya	double
=	O
0.5	int
*	O
(	O
double	O
)	O
lw	int
;	O
rightFace	pointer
->	O
k	double
=	O
-	O
0.5	int
*	O
(	O
double	O
)	O
(	O
lw	int
*	O
dx	int
)	O
;	O
leftFace	pointer
->	O
xa	double
=	O
0	int
;	O
leftFace	pointer
->	O
ya	double
=	O
-	O
rightFace	pointer
->	O
ya	double
;	O
leftFace	pointer
->	O
k	double
=	O
rightFace	pointer
->	O
k	double
;	O
x	double
=	O
x1	double
;	O
if	O
(	O
projectLeft	enum
)	O
x	double
-=	O
(	O
lw	int
>>	O
1	int
)	O
;	O
y	double
=	O
y1	function
-	O
(	O
lw	int
>>	O
1	int
)	O
;	O
dx	int
=	O
x2	double
-	O
x	double
;	O
if	O
(	O
projectRight	enum
)	O
dx	int
+=	O
(	O
(	O
lw	int
+	O
1	int
)	O
>>	O
1	int
)	O
;	O
dy	int
=	O
lw	int
;	O
miFillRectPolyHelper	function
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
x	double
,	O
y	double
,	O
(	O
unsigned	O
int	O
)	O
dx	int
,	O
(	O
unsigned	O
int	O
)	O
dy	int
)	O
;	O
}	O
else	O
if	O
(	O
dx	int
==	O
0	int
)	O
{	O
leftFace	pointer
->	O
xa	double
=	O
0.5	int
*	O
(	O
double	O
)	O
lw	int
;	O
leftFace	pointer
->	O
ya	double
=	O
0	int
;	O
leftFace	pointer
->	O
k	double
=	O
0.5	int
*	O
(	O
double	O
)	O
(	O
lw	int
*	O
dy	int
)	O
;	O
rightFace	pointer
->	O
xa	double
=	O
-	O
leftFace	pointer
->	O
xa	double
;	O
rightFace	pointer
->	O
ya	double
=	O
0	int
;	O
rightFace	pointer
->	O
k	double
=	O
leftFace	pointer
->	O
k	double
;	O
y	double
=	O
y1	function
;	O
if	O
(	O
projectLeft	enum
)	O
y	double
-=	O
lw	int
>>	O
1	int
;	O
x	double
=	O
x1	double
-	O
(	O
lw	int
>>	O
1	int
)	O
;	O
dy	int
=	O
y2	double
-	O
y	double
;	O
if	O
(	O
projectRight	enum
)	O
dy	int
+=	O
(	O
(	O
lw	int
+	O
1	int
)	O
>>	O
1	int
)	O
;	O
dx	int
=	O
lw	int
;	O
miFillRectPolyHelper	function
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
x	double
,	O
y	double
,	O
(	O
unsigned	O
int	O
)	O
dx	int
,	O
(	O
unsigned	O
int	O
)	O
dy	int
)	O
;	O
}	O
else	O
{	O
double	O
l	double
,	O
L	double
,	O
r	int
;	O
double	O
xa	double
,	O
ya	double
;	O
double	O
projectXoff	double
=	O
0.0	int
,	O
projectYoff	double
=	O
0.0	int
;	O
double	O
k	double
;	O
double	O
maxy	double
;	O
int	O
finaly	int
;	O
int	O
lefty	int
,	O
righty	int
,	O
topy	int
,	O
bottomy	int
;	O
PolyEdge	struct
lefts	array
[	O
2	int
]	O
,	O
rights	array
[	O
2	int
]	O
;	O
PolyEdge	struct
*	O
left	pointer
,	O
*	O
right	pointer
;	O
PolyEdge	struct
*	O
top	int
,	O
*	O
bottom	int
;	O
l	double
=	O
0.5	int
*	O
(	O
(	O
double	O
)	O
lw	int
)	O
;	O
L	double
=	O
hypot	function
(	O
(	O
double	O
)	O
dx	int
,	O
(	O
double	O
)	O
dy	int
)	O
;	O
if	O
(	O
dx	int
<	O
0	int
)	O
{	O
right	pointer
=	O
&	O
rights	array
[	O
1	int
]	O
;	O
left	pointer
=	O
&	O
lefts	array
[	O
0	int
]	O
;	O
top	int
=	O
&	O
rights	array
[	O
0	int
]	O
;	O
bottom	int
=	O
&	O
lefts	array
[	O
1	int
]	O
;	O
}	O
else	O
{	O
right	pointer
=	O
&	O
rights	array
[	O
0	int
]	O
;	O
left	pointer
=	O
&	O
lefts	array
[	O
1	int
]	O
;	O
top	int
=	O
&	O
lefts	array
[	O
0	int
]	O
;	O
bottom	int
=	O
&	O
rights	array
[	O
1	int
]	O
;	O
}	O
r	int
=	O
l	double
/	O
L	double
;	O
ya	double
=	O
-	O
r	int
*	O
dx	int
;	O
xa	double
=	O
r	int
*	O
dy	int
;	O
if	O
(	O
projectLeft	enum
|	O
projectRight	enum
)	O
{	O
projectXoff	double
=	O
-	O
ya	double
;	O
projectYoff	double
=	O
xa	double
;	O
}	O
k	double
=	O
l	double
*	O
L	double
;	O
leftFace	pointer
->	O
xa	double
=	O
xa	double
;	O
leftFace	pointer
->	O
ya	double
=	O
ya	double
;	O
leftFace	pointer
->	O
k	double
=	O
k	double
;	O
rightFace	pointer
->	O
xa	double
=	O
-	O
xa	double
;	O
rightFace	pointer
->	O
ya	double
=	O
-	O
ya	double
;	O
rightFace	pointer
->	O
k	double
=	O
k	double
;	O
if	O
(	O
projectLeft	enum
)	O
righty	int
=	O
miPolyBuildEdge	function
(	O
xa	double
-	O
projectXoff	double
,	O
ya	double
-	O
projectYoff	double
,	O
k	double
,	O
dx	int
,	O
dy	int
,	O
x1	double
,	O
y1	function
,	O
false	int
,	O
right	pointer
)	O
;	O
else	O
righty	int
=	O
miPolyBuildEdge	function
(	O
xa	double
,	O
ya	double
,	O
k	double
,	O
dx	int
,	O
dy	int
,	O
x1	double
,	O
y1	function
,	O
false	int
,	O
right	pointer
)	O
;	O
ya	double
=	O
-	O
ya	double
;	O
xa	double
=	O
-	O
xa	double
;	O
k	double
=	O
-	O
k	double
;	O
if	O
(	O
projectLeft	enum
)	O
lefty	int
=	O
miPolyBuildEdge	function
(	O
xa	double
-	O
projectXoff	double
,	O
ya	double
-	O
projectYoff	double
,	O
k	double
,	O
dx	int
,	O
dy	int
,	O
x1	double
,	O
y1	function
,	O
true	int
,	O
left	pointer
)	O
;	O
else	O
lefty	int
=	O
miPolyBuildEdge	function
(	O
xa	double
,	O
ya	double
,	O
k	double
,	O
dx	int
,	O
dy	int
,	O
x1	double
,	O
y1	function
,	O
true	int
,	O
left	pointer
)	O
;	O
if	O
(	O
signdx	int
>	O
0	int
)	O
{	O
ya	double
=	O
-	O
ya	double
;	O
xa	double
=	O
-	O
xa	double
;	O
}	O
if	O
(	O
projectLeft	enum
)	O
{	O
double	O
xap	double
=	O
xa	double
-	O
projectXoff	double
;	O
double	O
yap	double
=	O
ya	double
-	O
projectYoff	double
;	O
topy	int
=	O
miPolyBuildEdge	function
(	O
xap	double
,	O
yap	double
,	O
xap	double
*	O
dx	int
+	O
yap	double
*	O
dy	int
,	O
-	O
dy	int
,	O
dx	int
,	O
x1	double
,	O
y1	function
,	O
(	O
dx	int
>	O
0	int
?	O
true	int
:	O
false	int
)	O
,	O
top	int
)	O
;	O
}	O
else	O
topy	int
=	O
miPolyBuildEdge	function
(	O
xa	double
,	O
ya	double
,	O
0.0	int
,	O
-	O
dy	int
,	O
dx	int
,	O
x1	double
,	O
y1	function
,	O
(	O
dx	int
>	O
0	int
?	O
true	int
:	O
false	int
)	O
,	O
top	int
)	O
;	O
if	O
(	O
projectRight	enum
)	O
{	O
double	O
xap	double
=	O
xa	double
+	O
projectXoff	double
;	O
double	O
yap	double
=	O
ya	double
+	O
projectYoff	double
;	O
bottomy	int
=	O
miPolyBuildEdge	function
(	O
xap	double
,	O
yap	double
,	O
xap	double
*	O
dx	int
+	O
yap	double
*	O
dy	int
,	O
-	O
dy	int
,	O
dx	int
,	O
x2	double
,	O
y2	double
,	O
(	O
dx	int
<	O
0	int
?	O
true	int
:	O
false	int
)	O
,	O
bottom	int
)	O
;	O
maxy	double
=	O
-	O
ya	double
+	O
projectYoff	double
;	O
}	O
else	O
{	O
bottomy	int
=	O
miPolyBuildEdge	function
(	O
xa	double
,	O
ya	double
,	O
0.0	int
,	O
-	O
dy	int
,	O
dx	int
,	O
x2	double
,	O
y2	double
,	O
(	O
dx	int
<	O
0	int
?	O
true	int
:	O
false	int
)	O
,	O
bottom	int
)	O
;	O
maxy	double
=	O
-	O
ya	double
;	O
}	O
finaly	int
=	O
ICEIL	O
(	O
maxy	double
)	O
+	O
y2	double
;	O
if	O
(	O
dx	int
<	O
0	int
)	O
{	O
left	pointer
->	O
height	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
bottomy	int
-	O
lefty	int
)	O
;	O
right	pointer
->	O
height	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
finaly	int
-	O
righty	int
)	O
;	O
top	int
->	O
height	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
righty	int
-	O
topy	int
)	O
;	O
}	O
else	O
{	O
right	pointer
->	O
height	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
bottomy	int
-	O
righty	int
)	O
;	O
left	pointer
->	O
height	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
finaly	int
-	O
lefty	int
)	O
;	O
top	int
->	O
height	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
lefty	int
-	O
topy	int
)	O
;	O
}	O
bottom	int
->	O
height	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
finaly	int
-	O
bottomy	int
)	O
;	O
miFillPolyHelper	function
(	O
paintedSet	pointer
,	O
pixel	struct
,	O
topy	int
,	O
(	O
unsigned	O
int	O
)	O
(	O
bottom	int
->	O
height	int
+	O
bottomy	int
-	O
topy	int
)	O
,	O
lefts	array
,	O
rights	array
,	O
2	int
,	O
2	int
)	O
;	O
}	O
}	O
