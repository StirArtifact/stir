static	O
void	O
_asn1_error_description_value_not_found	function
(	O
asn1_node	pointer
node	pointer
,	O
char	O
*	O
ErrorDescription	pointer
)	O
{	O
if	O
(	O
ErrorDescription	pointer
==	O
NULL	O
)	O
return	O
;	O
Estrcpy	O
(	O
ErrorDescription	pointer
,	O
":: value of element '"	pointer
)	O
;	O
_asn1_hierarchical_name	function
(	O
node	pointer
,	O
ErrorDescription	pointer
+	O
strlen	function
(	O
ErrorDescription	pointer
)	O
,	O
ASN1_MAX_ERROR_DESCRIPTION_SIZE	int
-	O
40	int
)	O
;	O
Estrcat	O
(	O
ErrorDescription	pointer
,	O
"' not found"	pointer
)	O
;	O
}	O
void	O
asn1_length_der	function
(	O
unsigned	O
long	O
int	O
len	int
,	O
unsigned	O
char	O
*	O
der	pointer
,	O
int	O
*	O
der_len	int
)	O
{	O
int	O
k	int
;	O
unsigned	O
char	O
temp	array
[	O
ASN1_MAX_LENGTH_SIZE	int
]	O
;	O
if	O
(	O
len	int
<	O
128	int
)	O
{	O
if	O
(	O
der	pointer
!=	O
NULL	O
)	O
der	pointer
[	O
0	int
]	O
=	O
(	O
unsigned	O
char	O
)	O
len	int
;	O
*	O
der_len	int
=	O
1	int
;	O
}	O
else	O
{	O
k	int
=	O
0	int
;	O
while	O
(	O
len	int
)	O
{	O
temp	array
[	O
k	int
++	O
]	O
=	O
len	int
&	O
0xFF	int
;	O
len	int
=	O
len	int
>>	O
8	int
;	O
}	O
*	O
der_len	int
=	O
k	int
+	O
1	int
;	O
if	O
(	O
der	pointer
!=	O
NULL	O
)	O
{	O
der	pointer
[	O
0	int
]	O
=	O
(	O
(	O
unsigned	O
char	O
)	O
k	int
&	O
0x7F	int
)	O
+	O
128	int
;	O
while	O
(	O
k	int
--	O
)	O
der	pointer
[	O
*	O
der_len	int
-	O
1	int
-	O
k	int
]	O
=	O
temp	array
[	O
k	int
]	O
;	O
}	O
}	O
}	O
static	O
void	O
_asn1_tag_der	function
(	O
unsigned	O
char	O
class	int
,	O
unsigned	O
int	O
tag_value	int
,	O
unsigned	O
char	O
ans	array
[	O
ASN1_MAX_TAG_SIZE	int
]	O
,	O
int	O
*	O
ans_len	pointer
)	O
{	O
int	O
k	int
;	O
unsigned	O
char	O
temp	array
[	O
ASN1_MAX_TAG_SIZE	int
]	O
;	O
if	O
(	O
tag_value	int
<	O
31	int
)	O
{	O
ans	array
[	O
0	int
]	O
=	O
(	O
class	int
&	O
0xE0	int
)	O
+	O
(	O
(	O
unsigned	O
char	O
)	O
(	O
tag_value	int
&	O
0x1F	int
)	O
)	O
;	O
*	O
ans_len	pointer
=	O
1	int
;	O
}	O
else	O
{	O
ans	array
[	O
0	int
]	O
=	O
(	O
class	int
&	O
0xE0	int
)	O
+	O
31	int
;	O
k	int
=	O
0	int
;	O
while	O
(	O
tag_value	int
!=	O
0	int
)	O
{	O
temp	array
[	O
k	int
++	O
]	O
=	O
tag_value	int
&	O
0x7F	int
;	O
tag_value	int
>>=	O
7	int
;	O
if	O
(	O
k	int
>	O
ASN1_MAX_TAG_SIZE	int
-	O
1	int
)	O
break	O
;	O
}	O
*	O
ans_len	pointer
=	O
k	int
+	O
1	int
;	O
while	O
(	O
k	int
--	O
)	O
ans	array
[	O
*	O
ans_len	pointer
-	O
1	int
-	O
k	int
]	O
=	O
temp	array
[	O
k	int
]	O
+	O
128	int
;	O
ans	array
[	O
*	O
ans_len	pointer
-	O
1	int
]	O
-=	O
128	int
;	O
}	O
}	O
void	O
asn1_octet_der	function
(	O
const	O
unsigned	O
char	O
*	O
str	pointer
,	O
int	O
str_len	pointer
,	O
unsigned	O
char	O
*	O
der	pointer
,	O
int	O
*	O
der_len	int
)	O
{	O
int	O
len_len	int
;	O
if	O
(	O
der	pointer
==	O
NULL	O
||	O
str_len	pointer
<	O
0	int
)	O
return	O
;	O
asn1_length_der	function
(	O
str_len	pointer
,	O
der	pointer
,	O
&	O
len_len	int
)	O
;	O
memcpy	function
(	O
der	pointer
+	O
len_len	int
,	O
str	pointer
,	O
str_len	pointer
)	O
;	O
*	O
der_len	int
=	O
str_len	pointer
+	O
len_len	int
;	O
}	O
int	O
asn1_encode_simple_der	function
(	O
unsigned	O
int	O
etype	pointer
,	O
const	O
unsigned	O
char	O
*	O
str	pointer
,	O
unsigned	O
int	O
str_len	pointer
,	O
unsigned	O
char	O
*	O
tl	pointer
,	O
unsigned	O
int	O
*	O
tl_len	pointer
)	O
{	O
int	O
tag_len	int
,	O
len_len	int
;	O
unsigned	O
tlen	int
;	O
unsigned	O
char	O
der_tag	array
[	O
ASN1_MAX_TAG_SIZE	int
]	O
;	O
unsigned	O
char	O
der_length	array
[	O
ASN1_MAX_LENGTH_SIZE	int
]	O
;	O
unsigned	O
char	O
*	O
p	pointer
;	O
if	O
(	O
str	pointer
==	O
NULL	O
)	O
return	O
ASN1_VALUE_NOT_VALID	int
;	O
if	O
(	O
ETYPE_OK	O
(	O
etype	pointer
)	O
==	O
0	int
)	O
return	O
ASN1_VALUE_NOT_VALID	int
;	O
if	O
(	O
ETYPE_CLASS	O
(	O
etype	pointer
)	O
!=	O
ASN1_CLASS_UNIVERSAL	int
)	O
return	O
ASN1_VALUE_NOT_VALID	int
;	O
_asn1_tag_der	function
(	O
ETYPE_CLASS	O
(	O
etype	pointer
)	O
,	O
ETYPE_TAG	O
(	O
etype	pointer
)	O
,	O
der_tag	array
,	O
&	O
tag_len	int
)	O
;	O
asn1_length_der	function
(	O
str_len	pointer
,	O
der_length	array
,	O
&	O
len_len	int
)	O
;	O
if	O
(	O
tag_len	int
<=	O
0	int
||	O
len_len	int
<=	O
0	int
)	O
return	O
ASN1_VALUE_NOT_VALID	int
;	O
tlen	int
=	O
tag_len	int
+	O
len_len	int
;	O
if	O
(	O
*	O
tl_len	pointer
<	O
tlen	int
)	O
return	O
ASN1_MEM_ERROR	int
;	O
p	pointer
=	O
tl	pointer
;	O
memcpy	function
(	O
p	pointer
,	O
der_tag	array
,	O
tag_len	int
)	O
;	O
p	pointer
+=	O
tag_len	int
;	O
memcpy	function
(	O
p	pointer
,	O
der_length	array
,	O
len_len	int
)	O
;	O
*	O
tl_len	pointer
=	O
tlen	int
;	O
return	O
ASN1_SUCCESS	int
;	O
}	O
static	O
int	O
_asn1_time_der	function
(	O
unsigned	O
char	O
*	O
str	pointer
,	O
int	O
str_len	pointer
,	O
unsigned	O
char	O
*	O
der	pointer
,	O
int	O
*	O
der_len	int
)	O
{	O
int	O
len_len	int
;	O
int	O
max_len	int
;	O
if	O
(	O
der	pointer
==	O
NULL	O
)	O
return	O
ASN1_VALUE_NOT_VALID	int
;	O
max_len	int
=	O
*	O
der_len	int
;	O
asn1_length_der	function
(	O
str_len	pointer
,	O
(	O
max_len	int
>	O
0	int
)	O
?	O
der	pointer
:	O
NULL	O
,	O
&	O
len_len	int
)	O
;	O
if	O
(	O
(	O
len_len	int
+	O
str_len	pointer
)	O
<=	O
max_len	int
)	O
memcpy	function
(	O
der	pointer
+	O
len_len	int
,	O
str	pointer
,	O
str_len	pointer
)	O
;	O
*	O
der_len	int
=	O
len_len	int
+	O
str_len	pointer
;	O
if	O
(	O
(	O
*	O
der_len	int
)	O
>	O
max_len	int
)	O
return	O
ASN1_MEM_ERROR	int
;	O
return	O
ASN1_SUCCESS	int
;	O
}	O
static	O
void	O
encode_val	function
(	O
uint64_t	long
val	long
,	O
unsigned	O
char	O
*	O
der	pointer
,	O
int	O
max_len	int
,	O
int	O
*	O
der_len	int
)	O
{	O
int	O
first	int
,	O
k	int
;	O
unsigned	O
char	O
bit7	char
;	O
first	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
sizeof	O
(	O
val	long
)	O
;	O
k	int
>=	O
0	int
;	O
k	int
--	O
)	O
{	O
bit7	char
=	O
(	O
val	long
>>	O
(	O
k	int
*	O
7	int
)	O
)	O
&	O
0x7F	int
;	O
if	O
(	O
bit7	char
||	O
first	int
||	O
!	O
k	int
)	O
{	O
if	O
(	O
k	int
)	O
bit7	char
|=	O
0x80	int
;	O
if	O
(	O
max_len	int
>	O
(	O
*	O
der_len	int
)	O
)	O
der	pointer
[	O
*	O
der_len	int
]	O
=	O
bit7	char
;	O
(	O
*	O
der_len	int
)	O
++	O
;	O
first	int
=	O
1	int
;	O
}	O
}	O
}	O
static	O
int	O
_asn1_object_id_der	function
(	O
const	O
char	O
*	O
str	pointer
,	O
unsigned	O
char	O
*	O
der	pointer
,	O
int	O
*	O
der_len	int
)	O
{	O
int	O
len_len	int
,	O
counter	int
,	O
max_len	int
;	O
char	O
*	O
temp	array
,	O
*	O
n_end	pointer
,	O
*	O
n_start	pointer
;	O
uint64_t	long
val	long
,	O
val1	long
=	O
0	int
;	O
int	O
str_len	pointer
=	O
_asn1_strlen	O
(	O
str	pointer
)	O
;	O
max_len	int
=	O
*	O
der_len	int
;	O
*	O
der_len	int
=	O
0	int
;	O
if	O
(	O
der	pointer
==	O
NULL	O
&&	O
max_len	int
>	O
0	int
)	O
return	O
ASN1_VALUE_NOT_VALID	int
;	O
temp	array
=	O
malloc	function
(	O
str_len	pointer
+	O
2	int
)	O
;	O
if	O
(	O
temp	array
==	O
NULL	O
)	O
return	O
ASN1_MEM_ALLOC_ERROR	int
;	O
memcpy	function
(	O
temp	array
,	O
str	pointer
,	O
str_len	pointer
)	O
;	O
temp	array
[	O
str_len	pointer
]	O
=	O
'.'	O
;	O
temp	array
[	O
str_len	pointer
+	O
1	int
]	O
=	O
0	int
;	O
counter	int
=	O
0	int
;	O
n_start	pointer
=	O
temp	array
;	O
while	O
(	O
(	O
n_end	pointer
=	O
strchr	function
(	O
n_start	pointer
,	O
'.'	O
)	O
)	O
)	O
{	O
*	O
n_end	pointer
=	O
0	int
;	O
val	long
=	O
_asn1_strtou64	O
(	O
n_start	pointer
,	O
NULL	O
,	O
10	int
)	O
;	O
counter	int
++	O
;	O
if	O
(	O
counter	int
==	O
1	int
)	O
{	O
val1	long
=	O
val	long
;	O
}	O
else	O
if	O
(	O
counter	int
==	O
2	int
)	O
{	O
uint64_t	long
val0	long
;	O
if	O
(	O
val1	long
>	O
2	int
)	O
{	O
free	function
(	O
temp	array
)	O
;	O
return	O
ASN1_VALUE_NOT_VALID	int
;	O
}	O
else	O
if	O
(	O
(	O
val1	long
==	O
0	int
||	O
val1	long
==	O
1	int
)	O
&&	O
val	long
>	O
39	int
)	O
{	O
free	function
(	O
temp	array
)	O
;	O
return	O
ASN1_VALUE_NOT_VALID	int
;	O
}	O
val0	long
=	O
40	int
*	O
val1	long
+	O
val	long
;	O
encode_val	function
(	O
val0	long
,	O
der	pointer
,	O
max_len	int
,	O
der_len	int
)	O
;	O
}	O
else	O
{	O
encode_val	function
(	O
val	long
,	O
der	pointer
,	O
max_len	int
,	O
der_len	int
)	O
;	O
}	O
n_start	pointer
=	O
n_end	pointer
+	O
1	int
;	O
}	O
asn1_length_der	function
(	O
*	O
der_len	int
,	O
NULL	O
,	O
&	O
len_len	int
)	O
;	O
if	O
(	O
max_len	int
>=	O
(	O
*	O
der_len	int
+	O
len_len	int
)	O
)	O
{	O
memmove	function
(	O
der	pointer
+	O
len_len	int
,	O
der	pointer
,	O
*	O
der_len	int
)	O
;	O
asn1_length_der	function
(	O
*	O
der_len	int
,	O
der	pointer
,	O
&	O
len_len	int
)	O
;	O
}	O
*	O
der_len	int
+=	O
len_len	int
;	O
free	function
(	O
temp	array
)	O
;	O
if	O
(	O
max_len	int
<	O
(	O
*	O
der_len	int
)	O
)	O
return	O
ASN1_MEM_ERROR	int
;	O
return	O
ASN1_SUCCESS	int
;	O
}	O
int	O
asn1_object_id_der	function
(	O
const	O
char	O
*	O
str	pointer
,	O
unsigned	O
char	O
*	O
der	pointer
,	O
int	O
*	O
der_len	int
,	O
unsigned	O
flags	int
)	O
{	O
unsigned	O
char	O
tag_der	array
[	O
MAX_TAG_LEN	int
]	O
;	O
int	O
tag_len	int
=	O
0	int
,	O
r	int
;	O
int	O
max_len	int
=	O
*	O
der_len	int
;	O
*	O
der_len	int
=	O
0	int
;	O
_asn1_tag_der	function
(	O
ETYPE_CLASS	O
(	O
ASN1_ETYPE_OBJECT_ID	int
)	O
,	O
ETYPE_TAG	O
(	O
ASN1_ETYPE_OBJECT_ID	int
)	O
,	O
tag_der	array
,	O
&	O
tag_len	int
)	O
;	O
if	O
(	O
max_len	int
>	O
tag_len	int
)	O
{	O
memcpy	function
(	O
der	pointer
,	O
tag_der	array
,	O
tag_len	int
)	O
;	O
}	O
max_len	int
-=	O
tag_len	int
;	O
der	pointer
+=	O
tag_len	int
;	O
r	int
=	O
_asn1_object_id_der	function
(	O
str	pointer
,	O
der	pointer
,	O
&	O
max_len	int
)	O
;	O
if	O
(	O
r	int
==	O
ASN1_MEM_ERROR	int
||	O
r	int
==	O
ASN1_SUCCESS	int
)	O
{	O
*	O
der_len	int
=	O
max_len	int
+	O
tag_len	int
;	O
}	O
return	O
r	int
;	O
}	O
static	O
const	O
unsigned	O
char	O
bit_mask	array
[	O
]	O
=	O
{	O
0xFF	int
,	O
0xFE	int
,	O
0xFC	int
,	O
0xF8	int
,	O
0xF0	int
,	O
0xE0	int
,	O
0xC0	int
,	O
0x80	int
}	O
;	O
void	O
asn1_bit_der	function
(	O
const	O
unsigned	O
char	O
*	O
str	pointer
,	O
int	O
bit_len	int
,	O
unsigned	O
char	O
*	O
der	pointer
,	O
int	O
*	O
der_len	int
)	O
{	O
int	O
len_len	int
,	O
len_byte	int
,	O
len_pad	int
;	O
if	O
(	O
der	pointer
==	O
NULL	O
)	O
return	O
;	O
len_byte	int
=	O
bit_len	int
>>	O
3	int
;	O
len_pad	int
=	O
8	int
-	O
(	O
bit_len	int
&	O
7	int
)	O
;	O
if	O
(	O
len_pad	int
==	O
8	int
)	O
len_pad	int
=	O
0	int
;	O
else	O
len_byte	int
++	O
;	O
asn1_length_der	function
(	O
len_byte	int
+	O
1	int
,	O
der	pointer
,	O
&	O
len_len	int
)	O
;	O
der	pointer
[	O
len_len	int
]	O
=	O
len_pad	int
;	O
if	O
(	O
str	pointer
)	O
memcpy	function
(	O
der	pointer
+	O
len_len	int
+	O
1	int
,	O
str	pointer
,	O
len_byte	int
)	O
;	O
der	pointer
[	O
len_len	int
+	O
len_byte	int
]	O
&=	O
bit_mask	array
[	O
len_pad	int
]	O
;	O
*	O
der_len	int
=	O
len_byte	int
+	O
len_len	int
+	O
1	int
;	O
}	O
static	O
int	O
_asn1_complete_explicit_tag	function
(	O
asn1_node	pointer
node	pointer
,	O
unsigned	O
char	O
*	O
der	pointer
,	O
int	O
*	O
counter	int
,	O
int	O
*	O
max_len	int
)	O
{	O
asn1_node	pointer
p	pointer
;	O
int	O
is_tag_implicit	int
,	O
len2	int
,	O
len3	int
;	O
unsigned	O
char	O
temp	array
[	O
SIZEOF_UNSIGNED_INT	int
]	O
;	O
if	O
(	O
der	pointer
==	O
NULL	O
&&	O
*	O
max_len	int
>	O
0	int
)	O
return	O
ASN1_VALUE_NOT_VALID	int
;	O
is_tag_implicit	int
=	O
0	int
;	O
if	O
(	O
node	pointer
->	O
type	int
&	O
CONST_TAG	O
)	O
{	O
p	pointer
=	O
node	pointer
->	O
down	pointer
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
return	O
ASN1_DER_ERROR	int
;	O
while	O
(	O
p	pointer
->	O
right	pointer
)	O
p	pointer
=	O
p	pointer
->	O
right	pointer
;	O
while	O
(	O
p	pointer
&&	O
p	pointer
!=	O
node	pointer
->	O
down	pointer
->	O
left	pointer
)	O
{	O
if	O
(	O
type_field	function
(	O
p	pointer
->	O
type	int
)	O
==	O
ASN1_ETYPE_TAG	int
)	O
{	O
if	O
(	O
p	pointer
->	O
type	int
&	O
CONST_EXPLICIT	O
)	O
{	O
len2	int
=	O
strtol	function
(	O
p	pointer
->	O
name	pointer
,	O
NULL	O
,	O
10	int
)	O
;	O
_asn1_set_name	function
(	O
p	pointer
,	O
NULL	O
)	O
;	O
asn1_length_der	function
(	O
*	O
counter	int
-	O
len2	int
,	O
temp	array
,	O
&	O
len3	int
)	O
;	O
if	O
(	O
len3	int
<=	O
(	O
*	O
max_len	int
)	O
)	O
{	O
memmove	function
(	O
der	pointer
+	O
len2	int
+	O
len3	int
,	O
der	pointer
+	O
len2	int
,	O
*	O
counter	int
-	O
len2	int
)	O
;	O
memcpy	function
(	O
der	pointer
+	O
len2	int
,	O
temp	array
,	O
len3	int
)	O
;	O
}	O
*	O
max_len	int
-=	O
len3	int
;	O
*	O
counter	int
+=	O
len3	int
;	O
is_tag_implicit	int
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
is_tag_implicit	int
)	O
{	O
is_tag_implicit	int
=	O
1	int
;	O
}	O
}	O
}	O
p	pointer
=	O
p	pointer
->	O
left	pointer
;	O
}	O
}	O
if	O
(	O
*	O
max_len	int
<	O
0	int
)	O
return	O
ASN1_MEM_ERROR	int
;	O
return	O
ASN1_SUCCESS	int
;	O
}	O
const	O
tag_and_class_st	struct
_asn1_tags	array
[	O
]	O
=	O
{	O
[	O
ASN1_ETYPE_GENERALSTRING	int
]	O
=	O
{	O
ASN1_TAG_GENERALSTRING	int
,	O
ASN1_CLASS_UNIVERSAL	int
,	O
"type:GENERALSTRING"	pointer
}	O
,	O
[	O
ASN1_ETYPE_NUMERIC_STRING	int
]	O
=	O
{	O
ASN1_TAG_NUMERIC_STRING	int
,	O
ASN1_CLASS_UNIVERSAL	int
,	O
"type:NUMERIC_STR"	pointer
}	O
,	O
[	O
ASN1_ETYPE_IA5_STRING	int
]	O
=	O
{	O
ASN1_TAG_IA5_STRING	int
,	O
ASN1_CLASS_UNIVERSAL	int
,	O
"type:IA5_STR"	pointer
}	O
,	O
[	O
ASN1_ETYPE_TELETEX_STRING	int
]	O
=	O
{	O
ASN1_TAG_TELETEX_STRING	int
,	O
ASN1_CLASS_UNIVERSAL	int
,	O
"type:TELETEX_STR"	pointer
}	O
,	O
[	O
ASN1_ETYPE_PRINTABLE_STRING	int
]	O
=	O
{	O
ASN1_TAG_PRINTABLE_STRING	int
,	O
ASN1_CLASS_UNIVERSAL	int
,	O
"type:PRINTABLE_STR"	pointer
}	O
,	O
[	O
ASN1_ETYPE_UNIVERSAL_STRING	int
]	O
=	O
{	O
ASN1_TAG_UNIVERSAL_STRING	int
,	O
ASN1_CLASS_UNIVERSAL	int
,	O
"type:UNIVERSAL_STR"	pointer
}	O
,	O
[	O
ASN1_ETYPE_BMP_STRING	int
]	O
=	O
{	O
ASN1_TAG_BMP_STRING	int
,	O
ASN1_CLASS_UNIVERSAL	int
,	O
"type:BMP_STR"	pointer
}	O
,	O
[	O
ASN1_ETYPE_UTF8_STRING	int
]	O
=	O
{	O
ASN1_TAG_UTF8_STRING	int
,	O
ASN1_CLASS_UNIVERSAL	int
,	O
"type:UTF8_STR"	pointer
}	O
,	O
[	O
ASN1_ETYPE_VISIBLE_STRING	int
]	O
=	O
{	O
ASN1_TAG_VISIBLE_STRING	int
,	O
ASN1_CLASS_UNIVERSAL	int
,	O
"type:VISIBLE_STR"	pointer
}	O
,	O
[	O
ASN1_ETYPE_OCTET_STRING	int
]	O
=	O
{	O
ASN1_TAG_OCTET_STRING	int
,	O
ASN1_CLASS_UNIVERSAL	int
,	O
"type:OCT_STR"	pointer
}	O
,	O
[	O
ASN1_ETYPE_BIT_STRING	int
]	O
=	O
{	O
ASN1_TAG_BIT_STRING	int
,	O
ASN1_CLASS_UNIVERSAL	int
,	O
"type:BIT_STR"	pointer
}	O
,	O
[	O
ASN1_ETYPE_OBJECT_ID	int
]	O
=	O
{	O
ASN1_TAG_OBJECT_ID	int
,	O
ASN1_CLASS_UNIVERSAL	int
,	O
"type:OBJ_ID"	pointer
}	O
,	O
[	O
ASN1_ETYPE_NULL	int
]	O
=	O
{	O
ASN1_TAG_NULL	int
,	O
ASN1_CLASS_UNIVERSAL	int
,	O
"type:NULL"	pointer
}	O
,	O
[	O
ASN1_ETYPE_BOOLEAN	int
]	O
=	O
{	O
ASN1_TAG_BOOLEAN	int
,	O
ASN1_CLASS_UNIVERSAL	int
,	O
"type:BOOLEAN"	pointer
}	O
,	O
[	O
ASN1_ETYPE_INTEGER	int
]	O
=	O
{	O
ASN1_TAG_INTEGER	int
,	O
ASN1_CLASS_UNIVERSAL	int
,	O
"type:INTEGER"	pointer
}	O
,	O
[	O
ASN1_ETYPE_ENUMERATED	int
]	O
=	O
{	O
ASN1_TAG_ENUMERATED	int
,	O
ASN1_CLASS_UNIVERSAL	int
,	O
"type:ENUMERATED"	pointer
}	O
,	O
[	O
ASN1_ETYPE_SEQUENCE	int
]	O
=	O
{	O
ASN1_TAG_SEQUENCE	int
,	O
ASN1_CLASS_UNIVERSAL	int
|	O
ASN1_CLASS_STRUCTURED	int
,	O
"type:SEQUENCE"	pointer
}	O
,	O
[	O
ASN1_ETYPE_SEQUENCE_OF	int
]	O
=	O
{	O
ASN1_TAG_SEQUENCE	int
,	O
ASN1_CLASS_UNIVERSAL	int
|	O
ASN1_CLASS_STRUCTURED	int
,	O
"type:SEQ_OF"	pointer
}	O
,	O
[	O
ASN1_ETYPE_SET	int
]	O
=	O
{	O
ASN1_TAG_SET	int
,	O
ASN1_CLASS_UNIVERSAL	int
|	O
ASN1_CLASS_STRUCTURED	int
,	O
"type:SET"	pointer
}	O
,	O
[	O
ASN1_ETYPE_SET_OF	int
]	O
=	O
{	O
ASN1_TAG_SET	int
,	O
ASN1_CLASS_UNIVERSAL	int
|	O
ASN1_CLASS_STRUCTURED	int
,	O
"type:SET_OF"	pointer
}	O
,	O
[	O
ASN1_ETYPE_GENERALIZED_TIME	int
]	O
=	O
{	O
ASN1_TAG_GENERALIZEDTime	int
,	O
ASN1_CLASS_UNIVERSAL	int
,	O
"type:GENERALIZED_TIME"	pointer
}	O
,	O
[	O
ASN1_ETYPE_UTC_TIME	int
]	O
=	O
{	O
ASN1_TAG_UTCTime	int
,	O
ASN1_CLASS_UNIVERSAL	int
,	O
"type:UTC_TIME"	pointer
}	O
,	O
}	O
;	O
unsigned	O
int	O
_asn1_tags_size	int
=	O
sizeof	O
(	O
_asn1_tags	array
)	O
/	O
sizeof	O
(	O
_asn1_tags	array
[	O
0	int
]	O
)	O
;	O
static	O
int	O
_asn1_insert_tag_der	function
(	O
asn1_node	pointer
node	pointer
,	O
unsigned	O
char	O
*	O
der	pointer
,	O
int	O
*	O
counter	int
,	O
int	O
*	O
max_len	int
)	O
{	O
asn1_node	pointer
p	pointer
;	O
int	O
tag_len	int
,	O
is_tag_implicit	int
;	O
unsigned	O
char	O
class	int
,	O
class_implicit	char
=	O
0	int
,	O
temp	array
[	O
MAX	O
(	O
SIZEOF_UNSIGNED_INT	int
*	O
3	int
+	O
1	int
,	O
LTOSTR_MAX_SIZE	int
)	O
]	O
;	O
unsigned	O
long	O
tag_implicit	long
=	O
0	int
;	O
unsigned	O
char	O
tag_der	array
[	O
MAX_TAG_LEN	int
]	O
;	O
is_tag_implicit	int
=	O
0	int
;	O
if	O
(	O
node	pointer
->	O
type	int
&	O
CONST_TAG	O
)	O
{	O
p	pointer
=	O
node	pointer
->	O
down	pointer
;	O
while	O
(	O
p	pointer
)	O
{	O
if	O
(	O
type_field	function
(	O
p	pointer
->	O
type	int
)	O
==	O
ASN1_ETYPE_TAG	int
)	O
{	O
if	O
(	O
p	pointer
->	O
type	int
&	O
CONST_APPLICATION	O
)	O
class	int
=	O
ASN1_CLASS_APPLICATION	int
;	O
else	O
if	O
(	O
p	pointer
->	O
type	int
&	O
CONST_UNIVERSAL	O
)	O
class	int
=	O
ASN1_CLASS_UNIVERSAL	int
;	O
else	O
if	O
(	O
p	pointer
->	O
type	int
&	O
CONST_PRIVATE	O
)	O
class	int
=	O
ASN1_CLASS_PRIVATE	int
;	O
else	O
class	int
=	O
ASN1_CLASS_CONTEXT_SPECIFIC	int
;	O
if	O
(	O
p	pointer
->	O
type	int
&	O
CONST_EXPLICIT	O
)	O
{	O
if	O
(	O
is_tag_implicit	int
)	O
_asn1_tag_der	function
(	O
class_implicit	char
,	O
tag_implicit	long
,	O
tag_der	array
,	O
&	O
tag_len	int
)	O
;	O
else	O
_asn1_tag_der	function
(	O
class	int
|	O
ASN1_CLASS_STRUCTURED	int
,	O
_asn1_strtoul	O
(	O
p	pointer
->	O
value	pointer
,	O
NULL	O
,	O
10	int
)	O
,	O
tag_der	array
,	O
&	O
tag_len	int
)	O
;	O
*	O
max_len	int
-=	O
tag_len	int
;	O
if	O
(	O
der	pointer
&&	O
*	O
max_len	int
>=	O
0	int
)	O
memcpy	function
(	O
der	pointer
+	O
*	O
counter	int
,	O
tag_der	array
,	O
tag_len	int
)	O
;	O
*	O
counter	int
+=	O
tag_len	int
;	O
_asn1_ltostr	function
(	O
*	O
counter	int
,	O
(	O
char	O
*	O
)	O
temp	array
)	O
;	O
_asn1_set_name	function
(	O
p	pointer
,	O
(	O
const	O
char	O
*	O
)	O
temp	array
)	O
;	O
is_tag_implicit	int
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
is_tag_implicit	int
)	O
{	O
if	O
(	O
(	O
type_field	function
(	O
node	pointer
->	O
type	int
)	O
==	O
ASN1_ETYPE_SEQUENCE	int
)	O
||	O
(	O
type_field	function
(	O
node	pointer
->	O
type	int
)	O
==	O
ASN1_ETYPE_SEQUENCE_OF	int
)	O
||	O
(	O
type_field	function
(	O
node	pointer
->	O
type	int
)	O
==	O
ASN1_ETYPE_SET	int
)	O
||	O
(	O
type_field	function
(	O
node	pointer
->	O
type	int
)	O
==	O
ASN1_ETYPE_SET_OF	int
)	O
)	O
class	int
|=	O
ASN1_CLASS_STRUCTURED	int
;	O
class_implicit	char
=	O
class	int
;	O
tag_implicit	long
=	O
_asn1_strtoul	O
(	O
p	pointer
->	O
value	pointer
,	O
NULL	O
,	O
10	int
)	O
;	O
is_tag_implicit	int
=	O
1	int
;	O
}	O
}	O
}	O
p	pointer
=	O
p	pointer
->	O
right	pointer
;	O
}	O
}	O
if	O
(	O
is_tag_implicit	int
)	O
{	O
_asn1_tag_der	function
(	O
class_implicit	char
,	O
tag_implicit	long
,	O
tag_der	array
,	O
&	O
tag_len	int
)	O
;	O
}	O
else	O
{	O
unsigned	O
type	int
=	O
type_field	function
(	O
node	pointer
->	O
type	int
)	O
;	O
switch	O
(	O
type	int
)	O
{	O
CASE_HANDLED_ETYPES	O
:	O
_asn1_tag_der	function
(	O
_asn1_tags	array
[	O
type	int
]	O
.	O
class	int
,	O
_asn1_tags	array
[	O
type	int
]	O
.	O
tag	pointer
,	O
tag_der	array
,	O
&	O
tag_len	int
)	O
;	O
break	O
;	O
case	O
ASN1_ETYPE_TAG	int
:	O
case	O
ASN1_ETYPE_CHOICE	int
:	O
case	O
ASN1_ETYPE_ANY	int
:	O
tag_len	int
=	O
0	int
;	O
break	O
;	O
default	O
:	O
return	O
ASN1_GENERIC_ERROR	int
;	O
}	O
}	O
*	O
max_len	int
-=	O
tag_len	int
;	O
if	O
(	O
der	pointer
&&	O
*	O
max_len	int
>=	O
0	int
)	O
memcpy	function
(	O
der	pointer
+	O
*	O
counter	int
,	O
tag_der	array
,	O
tag_len	int
)	O
;	O
*	O
counter	int
+=	O
tag_len	int
;	O
if	O
(	O
*	O
max_len	int
<	O
0	int
)	O
return	O
ASN1_MEM_ERROR	int
;	O
return	O
ASN1_SUCCESS	int
;	O
}	O
static	O
int	O
_asn1_ordering_set	function
(	O
unsigned	O
char	O
*	O
der	pointer
,	O
int	O
der_len	int
,	O
asn1_node	pointer
node	pointer
)	O
{	O
struct	O
vet	struct
{	O
int	O
end	pointer
;	O
unsigned	O
long	O
value	pointer
;	O
struct	O
vet	struct
*	O
next	pointer
,	O
*	O
prev	pointer
;	O
}	O
;	O
int	O
counter	int
,	O
len	int
,	O
len2	int
;	O
struct	O
vet	struct
*	O
first	int
,	O
*	O
last	pointer
,	O
*	O
p_vet	pointer
,	O
*	O
p2_vet	pointer
;	O
asn1_node	pointer
p	pointer
;	O
unsigned	O
char	O
class	int
,	O
*	O
temp	array
;	O
unsigned	O
long	O
tag	pointer
,	O
t	long
;	O
int	O
err	long
;	O
counter	int
=	O
0	int
;	O
if	O
(	O
type_field	function
(	O
node	pointer
->	O
type	int
)	O
!=	O
ASN1_ETYPE_SET	int
)	O
return	O
ASN1_VALUE_NOT_VALID	int
;	O
p	pointer
=	O
node	pointer
->	O
down	pointer
;	O
while	O
(	O
p	pointer
&&	O
(	O
(	O
type_field	function
(	O
p	pointer
->	O
type	int
)	O
==	O
ASN1_ETYPE_TAG	int
)	O
||	O
(	O
type_field	function
(	O
p	pointer
->	O
type	int
)	O
==	O
ASN1_ETYPE_SIZE	int
)	O
)	O
)	O
p	pointer
=	O
p	pointer
->	O
right	pointer
;	O
if	O
(	O
(	O
p	pointer
==	O
NULL	O
)	O
||	O
(	O
p	pointer
->	O
right	pointer
==	O
NULL	O
)	O
)	O
return	O
ASN1_SUCCESS	int
;	O
first	int
=	O
last	pointer
=	O
NULL	O
;	O
while	O
(	O
p	pointer
)	O
{	O
p_vet	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
struct	O
vet	struct
)	O
)	O
;	O
if	O
(	O
p_vet	pointer
==	O
NULL	O
)	O
{	O
err	long
=	O
ASN1_MEM_ALLOC_ERROR	int
;	O
goto	O
error	int
;	O
}	O
p_vet	pointer
->	O
next	pointer
=	O
NULL	O
;	O
p_vet	pointer
->	O
prev	pointer
=	O
last	pointer
;	O
if	O
(	O
first	int
==	O
NULL	O
)	O
first	int
=	O
p_vet	pointer
;	O
else	O
last	pointer
->	O
next	pointer
=	O
p_vet	pointer
;	O
last	pointer
=	O
p_vet	pointer
;	O
err	long
=	O
asn1_get_tag_der	function
(	O
der	pointer
+	O
counter	int
,	O
der_len	int
-	O
counter	int
,	O
&	O
class	int
,	O
&	O
len2	int
,	O
&	O
tag	pointer
)	O
;	O
if	O
(	O
err	long
!=	O
ASN1_SUCCESS	int
)	O
goto	O
error	int
;	O
t	long
=	O
(	O
(	O
unsigned	O
int	O
)	O
class	int
)	O
<<	O
24	int
;	O
p_vet	pointer
->	O
value	pointer
=	O
t	long
|	O
tag	pointer
;	O
counter	int
+=	O
len2	int
;	O
len2	int
=	O
asn1_get_length_der	function
(	O
der	pointer
+	O
counter	int
,	O
der_len	int
-	O
counter	int
,	O
&	O
len	int
)	O
;	O
if	O
(	O
len2	int
<	O
0	int
)	O
{	O
err	long
=	O
ASN1_DER_ERROR	int
;	O
goto	O
error	int
;	O
}	O
counter	int
+=	O
len	int
+	O
len2	int
;	O
p_vet	pointer
->	O
end	pointer
=	O
counter	int
;	O
p	pointer
=	O
p	pointer
->	O
right	pointer
;	O
}	O
p_vet	pointer
=	O
first	int
;	O
while	O
(	O
p_vet	pointer
)	O
{	O
p2_vet	pointer
=	O
p_vet	pointer
->	O
next	pointer
;	O
counter	int
=	O
0	int
;	O
while	O
(	O
p2_vet	pointer
)	O
{	O
if	O
(	O
p_vet	pointer
->	O
value	pointer
>	O
p2_vet	pointer
->	O
value	pointer
)	O
{	O
temp	array
=	O
malloc	function
(	O
p_vet	pointer
->	O
end	pointer
-	O
counter	int
)	O
;	O
if	O
(	O
temp	array
==	O
NULL	O
)	O
{	O
err	long
=	O
ASN1_MEM_ALLOC_ERROR	int
;	O
goto	O
error	int
;	O
}	O
memcpy	function
(	O
temp	array
,	O
der	pointer
+	O
counter	int
,	O
p_vet	pointer
->	O
end	pointer
-	O
counter	int
)	O
;	O
memcpy	function
(	O
der	pointer
+	O
counter	int
,	O
der	pointer
+	O
p_vet	pointer
->	O
end	pointer
,	O
p2_vet	pointer
->	O
end	pointer
-	O
p_vet	pointer
->	O
end	pointer
)	O
;	O
memcpy	function
(	O
der	pointer
+	O
counter	int
+	O
p2_vet	pointer
->	O
end	pointer
-	O
p_vet	pointer
->	O
end	pointer
,	O
temp	array
,	O
p_vet	pointer
->	O
end	pointer
-	O
counter	int
)	O
;	O
free	function
(	O
temp	array
)	O
;	O
tag	pointer
=	O
p_vet	pointer
->	O
value	pointer
;	O
p_vet	pointer
->	O
value	pointer
=	O
p2_vet	pointer
->	O
value	pointer
;	O
p2_vet	pointer
->	O
value	pointer
=	O
tag	pointer
;	O
p_vet	pointer
->	O
end	pointer
=	O
counter	int
+	O
(	O
p2_vet	pointer
->	O
end	pointer
-	O
p_vet	pointer
->	O
end	pointer
)	O
;	O
}	O
counter	int
=	O
p_vet	pointer
->	O
end	pointer
;	O
p2_vet	pointer
=	O
p2_vet	pointer
->	O
next	pointer
;	O
p_vet	pointer
=	O
p_vet	pointer
->	O
next	pointer
;	O
}	O
if	O
(	O
p_vet	pointer
!=	O
first	int
)	O
p_vet	pointer
->	O
prev	pointer
->	O
next	pointer
=	O
NULL	O
;	O
else	O
first	int
=	O
NULL	O
;	O
free	function
(	O
p_vet	pointer
)	O
;	O
p_vet	pointer
=	O
first	int
;	O
}	O
return	O
ASN1_SUCCESS	int
;	O
error	int
:	O
while	O
(	O
first	int
!=	O
NULL	O
)	O
{	O
p_vet	pointer
=	O
first	int
;	O
first	int
=	O
first	int
->	O
next	pointer
;	O
free	function
(	O
p_vet	pointer
)	O
;	O
}	O
return	O
err	long
;	O
}	O
struct	O
vet	struct
{	O
unsigned	O
char	O
*	O
ptr	pointer
;	O
int	O
size	long
;	O
}	O
;	O
static	O
int	O
setof_compar	function
(	O
const	O
void	O
*	O
_e1	pointer
,	O
const	O
void	O
*	O
_e2	pointer
)	O
{	O
unsigned	O
length	int
;	O
const	O
struct	O
vet	struct
*	O
e1	pointer
=	O
_e1	pointer
,	O
*	O
e2	pointer
=	O
_e2	pointer
;	O
int	O
rval	int
;	O
length	int
=	O
MIN	O
(	O
e1	pointer
->	O
size	long
,	O
e2	pointer
->	O
size	long
)	O
;	O
rval	int
=	O
memcmp	function
(	O
e1	pointer
->	O
ptr	pointer
,	O
e2	pointer
->	O
ptr	pointer
,	O
length	int
)	O
;	O
if	O
(	O
rval	int
==	O
0	int
&&	O
e1	pointer
->	O
size	long
!=	O
e2	pointer
->	O
size	long
)	O
{	O
if	O
(	O
e1	pointer
->	O
size	long
>	O
e2	pointer
->	O
size	long
)	O
rval	int
=	O
1	int
;	O
else	O
if	O
(	O
e2	pointer
->	O
size	long
>	O
e1	pointer
->	O
size	long
)	O
rval	int
=	O
-	O
1	int
;	O
}	O
return	O
rval	int
;	O
}	O
static	O
int	O
_asn1_ordering_set_of	function
(	O
unsigned	O
char	O
*	O
der	pointer
,	O
int	O
der_len	int
,	O
asn1_node	pointer
node	pointer
)	O
{	O
int	O
counter	int
,	O
len	int
,	O
len2	int
;	O
struct	O
vet	struct
*	O
list	pointer
=	O
NULL	O
,	O
*	O
tlist	pointer
;	O
unsigned	O
list_size	int
=	O
0	int
;	O
struct	O
vet	struct
*	O
p_vet	pointer
;	O
asn1_node	pointer
p	pointer
;	O
unsigned	O
char	O
class	int
;	O
unsigned	O
i	int
;	O
unsigned	O
char	O
*	O
out	pointer
=	O
NULL	O
;	O
int	O
err	long
;	O
if	O
(	O
der	pointer
==	O
NULL	O
)	O
return	O
ASN1_VALUE_NOT_VALID	int
;	O
counter	int
=	O
0	int
;	O
if	O
(	O
type_field	function
(	O
node	pointer
->	O
type	int
)	O
!=	O
ASN1_ETYPE_SET_OF	int
)	O
return	O
ASN1_VALUE_NOT_VALID	int
;	O
p	pointer
=	O
node	pointer
->	O
down	pointer
;	O
while	O
(	O
p	pointer
&&	O
(	O
(	O
type_field	function
(	O
p	pointer
->	O
type	int
)	O
==	O
ASN1_ETYPE_TAG	int
)	O
||	O
(	O
type_field	function
(	O
p	pointer
->	O
type	int
)	O
==	O
ASN1_ETYPE_SIZE	int
)	O
)	O
)	O
p	pointer
=	O
p	pointer
->	O
right	pointer
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
return	O
ASN1_VALUE_NOT_VALID	int
;	O
p	pointer
=	O
p	pointer
->	O
right	pointer
;	O
if	O
(	O
(	O
p	pointer
==	O
NULL	O
)	O
||	O
(	O
p	pointer
->	O
right	pointer
==	O
NULL	O
)	O
)	O
return	O
ASN1_SUCCESS	int
;	O
while	O
(	O
p	pointer
)	O
{	O
list_size	int
++	O
;	O
tlist	pointer
=	O
realloc	function
(	O
list	pointer
,	O
list_size	int
*	O
sizeof	O
(	O
struct	O
vet	struct
)	O
)	O
;	O
if	O
(	O
tlist	pointer
==	O
NULL	O
)	O
{	O
err	long
=	O
ASN1_MEM_ALLOC_ERROR	int
;	O
goto	O
error	int
;	O
}	O
list	pointer
=	O
tlist	pointer
;	O
p_vet	pointer
=	O
&	O
list	pointer
[	O
list_size	int
-	O
1	int
]	O
;	O
p_vet	pointer
->	O
ptr	pointer
=	O
der	pointer
+	O
counter	int
;	O
p_vet	pointer
->	O
size	long
=	O
0	int
;	O
if	O
(	O
der_len	int
-	O
counter	int
>	O
0	int
)	O
{	O
err	long
=	O
asn1_get_tag_der	function
(	O
der	pointer
+	O
counter	int
,	O
der_len	int
-	O
counter	int
,	O
&	O
class	int
,	O
&	O
len	int
,	O
NULL	O
)	O
;	O
if	O
(	O
err	long
!=	O
ASN1_SUCCESS	int
)	O
goto	O
error	int
;	O
counter	int
+=	O
len	int
;	O
p_vet	pointer
->	O
size	long
+=	O
len	int
;	O
len2	int
=	O
asn1_get_length_der	function
(	O
der	pointer
+	O
counter	int
,	O
der_len	int
-	O
counter	int
,	O
&	O
len	int
)	O
;	O
if	O
(	O
len2	int
<	O
0	int
)	O
{	O
err	long
=	O
ASN1_DER_ERROR	int
;	O
goto	O
error	int
;	O
}	O
counter	int
+=	O
len	int
+	O
len2	int
;	O
p_vet	pointer
->	O
size	long
+=	O
len	int
+	O
len2	int
;	O
}	O
else	O
{	O
err	long
=	O
ASN1_DER_ERROR	int
;	O
goto	O
error	int
;	O
}	O
p	pointer
=	O
p	pointer
->	O
right	pointer
;	O
}	O
if	O
(	O
counter	int
>	O
der_len	int
)	O
{	O
err	long
=	O
ASN1_DER_ERROR	int
;	O
goto	O
error	int
;	O
}	O
qsort	function
(	O
list	pointer
,	O
list_size	int
,	O
sizeof	O
(	O
struct	O
vet	struct
)	O
,	O
setof_compar	function
)	O
;	O
out	pointer
=	O
malloc	function
(	O
der_len	int
)	O
;	O
if	O
(	O
out	pointer
==	O
NULL	O
)	O
{	O
err	long
=	O
ASN1_MEM_ERROR	int
;	O
goto	O
error	int
;	O
}	O
counter	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
list_size	int
;	O
i	int
++	O
)	O
{	O
p_vet	pointer
=	O
&	O
list	pointer
[	O
i	int
]	O
;	O
memcpy	function
(	O
out	pointer
+	O
counter	int
,	O
p_vet	pointer
->	O
ptr	pointer
,	O
p_vet	pointer
->	O
size	long
)	O
;	O
counter	int
+=	O
p_vet	pointer
->	O
size	long
;	O
}	O
memcpy	function
(	O
der	pointer
,	O
out	pointer
,	O
der_len	int
)	O
;	O
free	function
(	O
out	pointer
)	O
;	O
err	long
=	O
ASN1_SUCCESS	int
;	O
error	int
:	O
free	function
(	O
list	pointer
)	O
;	O
return	O
err	long
;	O
}	O
int	O
asn1_der_coding	function
(	O
asn1_node_const	pointer
element	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
void	O
*	O
ider	pointer
,	O
int	O
*	O
len	int
,	O
char	O
*	O
ErrorDescription	pointer
)	O
{	O
asn1_node	pointer
node	pointer
,	O
p	pointer
,	O
p2	pointer
;	O
unsigned	O
char	O
temp	array
[	O
MAX	O
(	O
LTOSTR_MAX_SIZE	int
,	O
SIZEOF_UNSIGNED_LONG_INT	int
*	O
3	int
+	O
1	int
)	O
]	O
;	O
int	O
counter	int
,	O
counter_old	int
,	O
len2	int
,	O
len3	int
,	O
move	int
,	O
max_len	int
,	O
max_len_old	int
;	O
int	O
err	long
;	O
unsigned	O
char	O
*	O
der	pointer
=	O
ider	pointer
;	O
if	O
(	O
ErrorDescription	pointer
)	O
ErrorDescription	pointer
[	O
0	int
]	O
=	O
0	int
;	O
node	pointer
=	O
asn1_find_node	function
(	O
element	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
node	pointer
==	O
NULL	O
)	O
return	O
ASN1_ELEMENT_NOT_FOUND	int
;	O
node	pointer
=	O
_asn1_copy_structure3	function
(	O
node	pointer
)	O
;	O
if	O
(	O
node	pointer
==	O
NULL	O
)	O
return	O
ASN1_ELEMENT_NOT_FOUND	int
;	O
max_len	int
=	O
*	O
len	int
;	O
if	O
(	O
der	pointer
==	O
NULL	O
&&	O
max_len	int
>	O
0	int
)	O
return	O
ASN1_VALUE_NOT_VALID	int
;	O
counter	int
=	O
0	int
;	O
move	int
=	O
DOWN	int
;	O
p	pointer
=	O
node	pointer
;	O
while	O
(	O
1	int
)	O
{	O
counter_old	int
=	O
counter	int
;	O
max_len_old	int
=	O
max_len	int
;	O
if	O
(	O
move	int
!=	O
UP	int
)	O
{	O
p	pointer
->	O
start	pointer
=	O
counter	int
;	O
err	long
=	O
_asn1_insert_tag_der	function
(	O
p	pointer
,	O
der	pointer
,	O
&	O
counter	int
,	O
&	O
max_len	int
)	O
;	O
if	O
(	O
err	long
!=	O
ASN1_SUCCESS	int
&&	O
err	long
!=	O
ASN1_MEM_ERROR	int
)	O
goto	O
error	int
;	O
}	O
switch	O
(	O
type_field	function
(	O
p	pointer
->	O
type	int
)	O
)	O
{	O
case	O
ASN1_ETYPE_NULL	int
:	O
max_len	int
--	O
;	O
if	O
(	O
der	pointer
!=	O
NULL	O
&&	O
max_len	int
>=	O
0	int
)	O
der	pointer
[	O
counter	int
]	O
=	O
0	int
;	O
counter	int
++	O
;	O
move	int
=	O
RIGHT	int
;	O
break	O
;	O
case	O
ASN1_ETYPE_BOOLEAN	int
:	O
if	O
(	O
(	O
p	pointer
->	O
type	int
&	O
CONST_DEFAULT	O
)	O
&&	O
(	O
p	pointer
->	O
value	pointer
==	O
NULL	O
)	O
)	O
{	O
counter	int
=	O
counter_old	int
;	O
max_len	int
=	O
max_len_old	int
;	O
}	O
else	O
{	O
if	O
(	O
p	pointer
->	O
value	pointer
==	O
NULL	O
)	O
{	O
_asn1_error_description_value_not_found	function
(	O
p	pointer
,	O
ErrorDescription	pointer
)	O
;	O
err	long
=	O
ASN1_VALUE_NOT_FOUND	int
;	O
goto	O
error	int
;	O
}	O
max_len	int
-=	O
2	int
;	O
if	O
(	O
der	pointer
!=	O
NULL	O
&&	O
max_len	int
>=	O
0	int
)	O
{	O
der	pointer
[	O
counter	int
++	O
]	O
=	O
1	int
;	O
if	O
(	O
p	pointer
->	O
value	pointer
[	O
0	int
]	O
==	O
'F'	O
)	O
der	pointer
[	O
counter	int
++	O
]	O
=	O
0	int
;	O
else	O
der	pointer
[	O
counter	int
++	O
]	O
=	O
0xFF	int
;	O
}	O
else	O
counter	int
+=	O
2	int
;	O
}	O
move	int
=	O
RIGHT	int
;	O
break	O
;	O
case	O
ASN1_ETYPE_INTEGER	int
:	O
case	O
ASN1_ETYPE_ENUMERATED	int
:	O
if	O
(	O
(	O
p	pointer
->	O
type	int
&	O
CONST_DEFAULT	O
)	O
&&	O
(	O
p	pointer
->	O
value	pointer
==	O
NULL	O
)	O
)	O
{	O
counter	int
=	O
counter_old	int
;	O
max_len	int
=	O
max_len_old	int
;	O
}	O
else	O
{	O
if	O
(	O
p	pointer
->	O
value	pointer
==	O
NULL	O
)	O
{	O
_asn1_error_description_value_not_found	function
(	O
p	pointer
,	O
ErrorDescription	pointer
)	O
;	O
err	long
=	O
ASN1_VALUE_NOT_FOUND	int
;	O
goto	O
error	int
;	O
}	O
len2	int
=	O
asn1_get_length_der	function
(	O
p	pointer
->	O
value	pointer
,	O
p	pointer
->	O
value_len	int
,	O
&	O
len3	int
)	O
;	O
if	O
(	O
len2	int
<	O
0	int
)	O
{	O
err	long
=	O
ASN1_DER_ERROR	int
;	O
goto	O
error	int
;	O
}	O
max_len	int
-=	O
len2	int
+	O
len3	int
;	O
if	O
(	O
der	pointer
!=	O
NULL	O
&&	O
max_len	int
>=	O
0	int
)	O
memcpy	function
(	O
der	pointer
+	O
counter	int
,	O
p	pointer
->	O
value	pointer
,	O
len3	int
+	O
len2	int
)	O
;	O
counter	int
+=	O
len3	int
+	O
len2	int
;	O
}	O
move	int
=	O
RIGHT	int
;	O
break	O
;	O
case	O
ASN1_ETYPE_OBJECT_ID	int
:	O
if	O
(	O
(	O
p	pointer
->	O
type	int
&	O
CONST_DEFAULT	O
)	O
&&	O
(	O
p	pointer
->	O
value	pointer
==	O
NULL	O
)	O
)	O
{	O
counter	int
=	O
counter_old	int
;	O
max_len	int
=	O
max_len_old	int
;	O
}	O
else	O
{	O
if	O
(	O
p	pointer
->	O
value	pointer
==	O
NULL	O
)	O
{	O
_asn1_error_description_value_not_found	function
(	O
p	pointer
,	O
ErrorDescription	pointer
)	O
;	O
err	long
=	O
ASN1_VALUE_NOT_FOUND	int
;	O
goto	O
error	int
;	O
}	O
len2	int
=	O
max_len	int
;	O
err	long
=	O
_asn1_object_id_der	function
(	O
(	O
char	O
*	O
)	O
p	pointer
->	O
value	pointer
,	O
der	pointer
+	O
counter	int
,	O
&	O
len2	int
)	O
;	O
if	O
(	O
err	long
!=	O
ASN1_SUCCESS	int
&&	O
err	long
!=	O
ASN1_MEM_ERROR	int
)	O
goto	O
error	int
;	O
max_len	int
-=	O
len2	int
;	O
counter	int
+=	O
len2	int
;	O
}	O
move	int
=	O
RIGHT	int
;	O
break	O
;	O
case	O
ASN1_ETYPE_GENERALIZED_TIME	int
:	O
case	O
ASN1_ETYPE_UTC_TIME	int
:	O
if	O
(	O
p	pointer
->	O
value	pointer
==	O
NULL	O
)	O
{	O
_asn1_error_description_value_not_found	function
(	O
p	pointer
,	O
ErrorDescription	pointer
)	O
;	O
err	long
=	O
ASN1_VALUE_NOT_FOUND	int
;	O
goto	O
error	int
;	O
}	O
len2	int
=	O
max_len	int
;	O
err	long
=	O
_asn1_time_der	function
(	O
p	pointer
->	O
value	pointer
,	O
p	pointer
->	O
value_len	int
,	O
der	pointer
+	O
counter	int
,	O
&	O
len2	int
)	O
;	O
if	O
(	O
err	long
!=	O
ASN1_SUCCESS	int
&&	O
err	long
!=	O
ASN1_MEM_ERROR	int
)	O
goto	O
error	int
;	O
max_len	int
-=	O
len2	int
;	O
counter	int
+=	O
len2	int
;	O
move	int
=	O
RIGHT	int
;	O
break	O
;	O
case	O
ASN1_ETYPE_OCTET_STRING	int
:	O
case	O
ASN1_ETYPE_GENERALSTRING	int
:	O
case	O
ASN1_ETYPE_NUMERIC_STRING	int
:	O
case	O
ASN1_ETYPE_IA5_STRING	int
:	O
case	O
ASN1_ETYPE_TELETEX_STRING	int
:	O
case	O
ASN1_ETYPE_PRINTABLE_STRING	int
:	O
case	O
ASN1_ETYPE_UNIVERSAL_STRING	int
:	O
case	O
ASN1_ETYPE_BMP_STRING	int
:	O
case	O
ASN1_ETYPE_UTF8_STRING	int
:	O
case	O
ASN1_ETYPE_VISIBLE_STRING	int
:	O
case	O
ASN1_ETYPE_BIT_STRING	int
:	O
if	O
(	O
p	pointer
->	O
value	pointer
==	O
NULL	O
)	O
{	O
_asn1_error_description_value_not_found	function
(	O
p	pointer
,	O
ErrorDescription	pointer
)	O
;	O
err	long
=	O
ASN1_VALUE_NOT_FOUND	int
;	O
goto	O
error	int
;	O
}	O
len2	int
=	O
asn1_get_length_der	function
(	O
p	pointer
->	O
value	pointer
,	O
p	pointer
->	O
value_len	int
,	O
&	O
len3	int
)	O
;	O
if	O
(	O
len2	int
<	O
0	int
)	O
{	O
err	long
=	O
ASN1_DER_ERROR	int
;	O
goto	O
error	int
;	O
}	O
max_len	int
-=	O
len2	int
+	O
len3	int
;	O
if	O
(	O
der	pointer
!=	O
NULL	O
&&	O
max_len	int
>=	O
0	int
)	O
memcpy	function
(	O
der	pointer
+	O
counter	int
,	O
p	pointer
->	O
value	pointer
,	O
len3	int
+	O
len2	int
)	O
;	O
counter	int
+=	O
len3	int
+	O
len2	int
;	O
move	int
=	O
RIGHT	int
;	O
break	O
;	O
case	O
ASN1_ETYPE_SEQUENCE	int
:	O
case	O
ASN1_ETYPE_SET	int
:	O
if	O
(	O
move	int
!=	O
UP	int
)	O
{	O
p	pointer
->	O
tmp_ival	int
=	O
counter	int
;	O
if	O
(	O
p	pointer
->	O
down	pointer
==	O
NULL	O
)	O
{	O
move	int
=	O
UP	int
;	O
continue	O
;	O
}	O
else	O
{	O
p2	pointer
=	O
p	pointer
->	O
down	pointer
;	O
while	O
(	O
p2	pointer
&&	O
(	O
type_field	function
(	O
p2	pointer
->	O
type	int
)	O
==	O
ASN1_ETYPE_TAG	int
)	O
)	O
p2	pointer
=	O
p2	pointer
->	O
right	pointer
;	O
if	O
(	O
p2	pointer
)	O
{	O
p	pointer
=	O
p2	pointer
;	O
move	int
=	O
RIGHT	int
;	O
continue	O
;	O
}	O
move	int
=	O
UP	int
;	O
continue	O
;	O
}	O
}	O
else	O
{	O
len2	int
=	O
p	pointer
->	O
tmp_ival	int
;	O
p	pointer
->	O
tmp_ival	int
=	O
0	int
;	O
if	O
(	O
(	O
type_field	function
(	O
p	pointer
->	O
type	int
)	O
==	O
ASN1_ETYPE_SET	int
)	O
&&	O
(	O
max_len	int
>=	O
0	int
)	O
)	O
{	O
err	long
=	O
_asn1_ordering_set	function
(	O
der	pointer
+	O
len2	int
,	O
counter	int
-	O
len2	int
,	O
p	pointer
)	O
;	O
if	O
(	O
err	long
!=	O
ASN1_SUCCESS	int
)	O
goto	O
error	int
;	O
}	O
asn1_length_der	function
(	O
counter	int
-	O
len2	int
,	O
temp	array
,	O
&	O
len3	int
)	O
;	O
max_len	int
-=	O
len3	int
;	O
if	O
(	O
der	pointer
!=	O
NULL	O
&&	O
max_len	int
>=	O
0	int
)	O
{	O
memmove	function
(	O
der	pointer
+	O
len2	int
+	O
len3	int
,	O
der	pointer
+	O
len2	int
,	O
counter	int
-	O
len2	int
)	O
;	O
memcpy	function
(	O
der	pointer
+	O
len2	int
,	O
temp	array
,	O
len3	int
)	O
;	O
}	O
counter	int
+=	O
len3	int
;	O
move	int
=	O
RIGHT	int
;	O
}	O
break	O
;	O
case	O
ASN1_ETYPE_SEQUENCE_OF	int
:	O
case	O
ASN1_ETYPE_SET_OF	int
:	O
if	O
(	O
move	int
!=	O
UP	int
)	O
{	O
p	pointer
->	O
tmp_ival	int
=	O
counter	int
;	O
p	pointer
=	O
p	pointer
->	O
down	pointer
;	O
while	O
(	O
(	O
type_field	function
(	O
p	pointer
->	O
type	int
)	O
==	O
ASN1_ETYPE_TAG	int
)	O
||	O
(	O
type_field	function
(	O
p	pointer
->	O
type	int
)	O
==	O
ASN1_ETYPE_SIZE	int
)	O
)	O
p	pointer
=	O
p	pointer
->	O
right	pointer
;	O
if	O
(	O
p	pointer
->	O
right	pointer
)	O
{	O
p	pointer
=	O
p	pointer
->	O
right	pointer
;	O
move	int
=	O
RIGHT	int
;	O
continue	O
;	O
}	O
else	O
p	pointer
=	O
_asn1_find_up	function
(	O
p	pointer
)	O
;	O
move	int
=	O
UP	int
;	O
}	O
if	O
(	O
move	int
==	O
UP	int
)	O
{	O
len2	int
=	O
p	pointer
->	O
tmp_ival	int
;	O
p	pointer
->	O
tmp_ival	int
=	O
0	int
;	O
if	O
(	O
(	O
type_field	function
(	O
p	pointer
->	O
type	int
)	O
==	O
ASN1_ETYPE_SET_OF	int
)	O
&&	O
(	O
counter	int
-	O
len2	int
>	O
0	int
)	O
&&	O
(	O
max_len	int
>=	O
0	int
)	O
)	O
{	O
err	long
=	O
_asn1_ordering_set_of	function
(	O
der	pointer
+	O
len2	int
,	O
counter	int
-	O
len2	int
,	O
p	pointer
)	O
;	O
if	O
(	O
err	long
!=	O
ASN1_SUCCESS	int
)	O
goto	O
error	int
;	O
}	O
asn1_length_der	function
(	O
counter	int
-	O
len2	int
,	O
temp	array
,	O
&	O
len3	int
)	O
;	O
max_len	int
-=	O
len3	int
;	O
if	O
(	O
der	pointer
!=	O
NULL	O
&&	O
max_len	int
>=	O
0	int
)	O
{	O
memmove	function
(	O
der	pointer
+	O
len2	int
+	O
len3	int
,	O
der	pointer
+	O
len2	int
,	O
counter	int
-	O
len2	int
)	O
;	O
memcpy	function
(	O
der	pointer
+	O
len2	int
,	O
temp	array
,	O
len3	int
)	O
;	O
}	O
counter	int
+=	O
len3	int
;	O
move	int
=	O
RIGHT	int
;	O
}	O
break	O
;	O
case	O
ASN1_ETYPE_ANY	int
:	O
if	O
(	O
p	pointer
->	O
value	pointer
==	O
NULL	O
)	O
{	O
_asn1_error_description_value_not_found	function
(	O
p	pointer
,	O
ErrorDescription	pointer
)	O
;	O
err	long
=	O
ASN1_VALUE_NOT_FOUND	int
;	O
goto	O
error	int
;	O
}	O
len2	int
=	O
asn1_get_length_der	function
(	O
p	pointer
->	O
value	pointer
,	O
p	pointer
->	O
value_len	int
,	O
&	O
len3	int
)	O
;	O
if	O
(	O
len2	int
<	O
0	int
)	O
{	O
err	long
=	O
ASN1_DER_ERROR	int
;	O
goto	O
error	int
;	O
}	O
max_len	int
-=	O
len2	int
;	O
if	O
(	O
der	pointer
!=	O
NULL	O
&&	O
max_len	int
>=	O
0	int
)	O
memcpy	function
(	O
der	pointer
+	O
counter	int
,	O
p	pointer
->	O
value	pointer
+	O
len3	int
,	O
len2	int
)	O
;	O
counter	int
+=	O
len2	int
;	O
move	int
=	O
RIGHT	int
;	O
break	O
;	O
default	O
:	O
move	int
=	O
(	O
move	int
==	O
UP	int
)	O
?	O
RIGHT	int
:	O
DOWN	int
;	O
break	O
;	O
}	O
if	O
(	O
(	O
move	int
!=	O
DOWN	int
)	O
&&	O
(	O
counter	int
!=	O
counter_old	int
)	O
)	O
{	O
p	pointer
->	O
end	pointer
=	O
counter	int
-	O
1	int
;	O
err	long
=	O
_asn1_complete_explicit_tag	function
(	O
p	pointer
,	O
der	pointer
,	O
&	O
counter	int
,	O
&	O
max_len	int
)	O
;	O
if	O
(	O
err	long
!=	O
ASN1_SUCCESS	int
&&	O
err	long
!=	O
ASN1_MEM_ERROR	int
)	O
goto	O
error	int
;	O
}	O
if	O
(	O
p	pointer
==	O
node	pointer
&&	O
move	int
!=	O
DOWN	int
)	O
break	O
;	O
if	O
(	O
move	int
==	O
DOWN	int
)	O
{	O
if	O
(	O
p	pointer
->	O
down	pointer
)	O
p	pointer
=	O
p	pointer
->	O
down	pointer
;	O
else	O
move	int
=	O
RIGHT	int
;	O
}	O
if	O
(	O
move	int
==	O
RIGHT	int
)	O
{	O
if	O
(	O
p	pointer
->	O
right	pointer
)	O
p	pointer
=	O
p	pointer
->	O
right	pointer
;	O
else	O
move	int
=	O
UP	int
;	O
}	O
if	O
(	O
move	int
==	O
UP	int
)	O
p	pointer
=	O
_asn1_find_up	function
(	O
p	pointer
)	O
;	O
}	O
*	O
len	int
=	O
counter	int
;	O
if	O
(	O
max_len	int
<	O
0	int
)	O
{	O
err	long
=	O
ASN1_MEM_ERROR	int
;	O
goto	O
error	int
;	O
}	O
err	long
=	O
ASN1_SUCCESS	int
;	O
error	int
:	O
asn1_delete_structure	function
(	O
&	O
node	pointer
)	O
;	O
return	O
err	long
;	O
}	O
