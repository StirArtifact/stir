void	O
_gdbm_new_bucket	function
(	O
GDBM_FILE	pointer
dbf	pointer
,	O
hash_bucket	struct
*	O
bucket	pointer
,	O
int	O
bits	int
)	O
{	O
int	O
index	function
;	O
bucket	pointer
->	O
av_count	int
=	O
0	int
;	O
bucket	pointer
->	O
bucket_bits	int
=	O
bits	int
;	O
bucket	pointer
->	O
count	int
=	O
0	int
;	O
for	O
(	O
index	function
=	O
0	int
;	O
index	function
<	O
dbf	pointer
->	O
header	pointer
->	O
bucket_elems	int
;	O
index	function
++	O
)	O
bucket	pointer
->	O
h_table	array
[	O
index	function
]	O
.	O
hash_value	int
=	O
-	O
1	int
;	O
}	O
int	O
gdbm_dir_entry_valid_p	function
(	O
GDBM_FILE	pointer
dbf	pointer
,	O
int	O
dir_index	int
)	O
{	O
return	O
dir_index	int
>=	O
0	int
&&	O
dir_index	int
<	O
GDBM_DIR_COUNT	O
(	O
dbf	pointer
)	O
&&	O
dbf	pointer
->	O
dir	long
[	O
dir_index	int
]	O
>=	O
dbf	pointer
->	O
header	pointer
->	O
block_size	int
;	O
}	O
int	O
_gdbm_get_bucket	function
(	O
GDBM_FILE	pointer
dbf	pointer
,	O
int	O
dir_index	int
)	O
{	O
int	O
rc	int
;	O
off_t	long
bucket_adr	long
;	O
off_t	long
file_pos	long
;	O
int	O
index	function
;	O
if	O
(	O
!	O
gdbm_dir_entry_valid_p	function
(	O
dbf	pointer
,	O
dir_index	int
)	O
)	O
{	O
GDBM_SET_ERRNO	O
(	O
dbf	pointer
,	O
GDBM_BAD_DIR_ENTRY	int
,	O
TRUE	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
dbf	pointer
->	O
bucket_dir	int
=	O
dir_index	int
;	O
bucket_adr	long
=	O
dbf	pointer
->	O
dir	long
[	O
dir_index	int
]	O
;	O
if	O
(	O
dbf	pointer
->	O
bucket_cache	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
_gdbm_init_cache	function
(	O
dbf	pointer
,	O
DEFAULT_CACHESIZE	int
)	O
==	O
-	O
1	int
)	O
{	O
_gdbm_fatal	function
(	O
dbf	pointer
,	O
_	O
(	O
"couldn't init cache"	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
dbf	pointer
->	O
cache_entry	pointer
->	O
ca_adr	long
!=	O
bucket_adr	long
)	O
{	O
size_t	long
lru	long
;	O
hash_bucket	struct
*	O
bucket	pointer
;	O
for	O
(	O
index	function
=	O
0	int
;	O
index	function
<	O
dbf	pointer
->	O
cache_size	long
;	O
index	function
++	O
)	O
{	O
if	O
(	O
dbf	pointer
->	O
bucket_cache	pointer
[	O
index	function
]	O
.	O
ca_adr	long
==	O
bucket_adr	long
)	O
{	O
dbf	pointer
->	O
bucket	pointer
=	O
dbf	pointer
->	O
bucket_cache	pointer
[	O
index	function
]	O
.	O
ca_bucket	pointer
;	O
dbf	pointer
->	O
cache_entry	pointer
=	O
&	O
dbf	pointer
->	O
bucket_cache	pointer
[	O
index	function
]	O
;	O
return	O
0	int
;	O
}	O
}	O
file_pos	long
=	O
gdbm_file_seek	function
(	O
dbf	pointer
,	O
bucket_adr	long
,	O
SEEK_SET	int
)	O
;	O
if	O
(	O
file_pos	long
!=	O
bucket_adr	long
)	O
{	O
GDBM_SET_ERRNO	O
(	O
dbf	pointer
,	O
GDBM_FILE_SEEK_ERROR	int
,	O
TRUE	int
)	O
;	O
_gdbm_fatal	function
(	O
dbf	pointer
,	O
_	O
(	O
"lseek error"	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
lru	long
=	O
(	O
dbf	pointer
->	O
last_read	long
+	O
1	int
)	O
%	O
dbf	pointer
->	O
cache_size	long
;	O
if	O
(	O
dbf	pointer
->	O
bucket_cache	pointer
[	O
lru	long
]	O
.	O
ca_changed	char
)	O
{	O
if	O
(	O
_gdbm_write_bucket	function
(	O
dbf	pointer
,	O
&	O
dbf	pointer
->	O
bucket_cache	pointer
[	O
lru	long
]	O
)	O
)	O
return	O
-	O
1	int
;	O
}	O
_gdbm_cache_entry_invalidate	function
(	O
dbf	pointer
,	O
lru	long
)	O
;	O
rc	int
=	O
_gdbm_full_read	function
(	O
dbf	pointer
,	O
dbf	pointer
->	O
bucket_cache	pointer
[	O
lru	long
]	O
.	O
ca_bucket	pointer
,	O
dbf	pointer
->	O
header	pointer
->	O
bucket_size	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
GDBM_DEBUG	O
(	O
GDBM_DEBUG_ERR	O
,	O
"%s: error reading bucket: %s"	pointer
,	O
dbf	pointer
->	O
name	pointer
,	O
gdbm_db_strerror	function
(	O
dbf	pointer
)	O
)	O
;	O
dbf	pointer
->	O
need_recovery	int
=	O
TRUE	int
;	O
_gdbm_fatal	function
(	O
dbf	pointer
,	O
gdbm_db_strerror	function
(	O
dbf	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
bucket	pointer
=	O
dbf	pointer
->	O
bucket_cache	pointer
[	O
lru	long
]	O
.	O
ca_bucket	pointer
;	O
if	O
(	O
!	O
(	O
bucket	pointer
->	O
count	int
>=	O
0	int
&&	O
bucket	pointer
->	O
count	int
<=	O
dbf	pointer
->	O
header	pointer
->	O
bucket_elems	int
&&	O
bucket	pointer
->	O
bucket_bits	int
>=	O
0	int
&&	O
bucket	pointer
->	O
bucket_bits	int
<=	O
dbf	pointer
->	O
header	pointer
->	O
dir_bits	int
)	O
)	O
{	O
GDBM_SET_ERRNO	O
(	O
dbf	pointer
,	O
GDBM_BAD_BUCKET	int
,	O
TRUE	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
gdbm_bucket_avail_table_validate	function
(	O
dbf	pointer
,	O
bucket	pointer
)	O
)	O
return	O
-	O
1	int
;	O
dbf	pointer
->	O
last_read	long
=	O
lru	long
;	O
dbf	pointer
->	O
bucket_cache	pointer
[	O
lru	long
]	O
.	O
ca_adr	long
=	O
bucket_adr	long
;	O
dbf	pointer
->	O
bucket	pointer
=	O
dbf	pointer
->	O
bucket_cache	pointer
[	O
lru	long
]	O
.	O
ca_bucket	pointer
;	O
dbf	pointer
->	O
cache_entry	pointer
=	O
&	O
dbf	pointer
->	O
bucket_cache	pointer
[	O
lru	long
]	O
;	O
dbf	pointer
->	O
cache_entry	pointer
->	O
ca_data	struct
.	O
elem_loc	int
=	O
-	O
1	int
;	O
dbf	pointer
->	O
cache_entry	pointer
->	O
ca_changed	char
=	O
FALSE	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
_gdbm_read_bucket_at	function
(	O
GDBM_FILE	pointer
dbf	pointer
,	O
off_t	long
off	long
,	O
hash_bucket	struct
*	O
bucket	pointer
,	O
size_t	long
size	int
)	O
{	O
off_t	long
file_pos	long
;	O
int	O
i	int
;	O
if	O
(	O
dbf	pointer
->	O
cache_entry	pointer
&&	O
dbf	pointer
->	O
cache_entry	pointer
->	O
ca_adr	long
==	O
off	long
)	O
{	O
memcpy	function
(	O
bucket	pointer
,	O
dbf	pointer
->	O
bucket	pointer
,	O
size	int
)	O
;	O
return	O
0	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dbf	pointer
->	O
cache_size	long
;	O
i	int
++	O
)	O
{	O
if	O
(	O
dbf	pointer
->	O
bucket_cache	pointer
[	O
i	int
]	O
.	O
ca_adr	long
==	O
off	long
)	O
{	O
memcpy	function
(	O
bucket	pointer
,	O
dbf	pointer
->	O
bucket_cache	pointer
[	O
i	int
]	O
.	O
ca_bucket	pointer
,	O
size	int
)	O
;	O
return	O
0	int
;	O
}	O
}	O
file_pos	long
=	O
gdbm_file_seek	function
(	O
dbf	pointer
,	O
off	long
,	O
SEEK_SET	int
)	O
;	O
if	O
(	O
file_pos	long
!=	O
off	long
)	O
{	O
GDBM_SET_ERRNO	O
(	O
dbf	pointer
,	O
GDBM_FILE_SEEK_ERROR	int
,	O
TRUE	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
_gdbm_full_read	function
(	O
dbf	pointer
,	O
bucket	pointer
,	O
size	int
)	O
)	O
{	O
GDBM_DEBUG	O
(	O
GDBM_DEBUG_ERR	O
,	O
"%s: error reading bucket: %s"	pointer
,	O
dbf	pointer
->	O
name	pointer
,	O
gdbm_db_strerror	function
(	O
dbf	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
_gdbm_split_bucket	function
(	O
GDBM_FILE	pointer
dbf	pointer
,	O
int	O
next_insert	int
)	O
{	O
hash_bucket	struct
*	O
bucket	pointer
[	O
2	int
]	O
;	O
int	O
new_bits	int
;	O
int	O
cache_0	int
;	O
int	O
cache_1	int
;	O
off_t	long
adr_0	long
;	O
off_t	long
adr_1	long
;	O
avail_elem	struct
old_bucket	struct
;	O
off_t	long
dir_start0	long
;	O
off_t	long
dir_start1	long
;	O
off_t	long
dir_end	long
;	O
off_t	long
*	O
new_dir	pointer
;	O
off_t	long
dir_adr	long
;	O
int	O
dir_size	int
;	O
off_t	long
old_adr	array
[	O
GDBM_HASH_BITS	int
]	O
;	O
int	O
old_size	array
[	O
GDBM_HASH_BITS	int
]	O
;	O
int	O
old_count	int
;	O
int	O
index	function
;	O
int	O
index1	int
;	O
int	O
elem_loc	int
;	O
bucket_element	struct
*	O
old_el	pointer
;	O
int	O
select	function
;	O
old_count	int
=	O
0	int
;	O
if	O
(	O
dbf	pointer
->	O
bucket_cache	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
_gdbm_init_cache	function
(	O
dbf	pointer
,	O
DEFAULT_CACHESIZE	int
)	O
==	O
-	O
1	int
)	O
{	O
_gdbm_fatal	function
(	O
dbf	pointer
,	O
_	O
(	O
"couldn't init cache"	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
while	O
(	O
dbf	pointer
->	O
bucket	pointer
->	O
count	int
==	O
dbf	pointer
->	O
header	pointer
->	O
bucket_elems	int
)	O
{	O
do	O
{	O
dbf	pointer
->	O
last_read	long
=	O
(	O
dbf	pointer
->	O
last_read	long
+	O
1	int
)	O
%	O
dbf	pointer
->	O
cache_size	long
;	O
cache_0	int
=	O
dbf	pointer
->	O
last_read	long
;	O
}	O
while	O
(	O
dbf	pointer
->	O
bucket_cache	pointer
[	O
cache_0	int
]	O
.	O
ca_bucket	pointer
==	O
dbf	pointer
->	O
bucket	pointer
)	O
;	O
bucket	pointer
[	O
0	int
]	O
=	O
dbf	pointer
->	O
bucket_cache	pointer
[	O
cache_0	int
]	O
.	O
ca_bucket	pointer
;	O
if	O
(	O
dbf	pointer
->	O
bucket_cache	pointer
[	O
cache_0	int
]	O
.	O
ca_changed	char
)	O
{	O
if	O
(	O
_gdbm_write_bucket	function
(	O
dbf	pointer
,	O
&	O
dbf	pointer
->	O
bucket_cache	pointer
[	O
cache_0	int
]	O
)	O
)	O
return	O
-	O
1	int
;	O
}	O
do	O
{	O
dbf	pointer
->	O
last_read	long
=	O
(	O
dbf	pointer
->	O
last_read	long
+	O
1	int
)	O
%	O
dbf	pointer
->	O
cache_size	long
;	O
cache_1	int
=	O
dbf	pointer
->	O
last_read	long
;	O
}	O
while	O
(	O
dbf	pointer
->	O
bucket_cache	pointer
[	O
cache_1	int
]	O
.	O
ca_bucket	pointer
==	O
dbf	pointer
->	O
bucket	pointer
)	O
;	O
bucket	pointer
[	O
1	int
]	O
=	O
dbf	pointer
->	O
bucket_cache	pointer
[	O
cache_1	int
]	O
.	O
ca_bucket	pointer
;	O
if	O
(	O
dbf	pointer
->	O
bucket_cache	pointer
[	O
cache_1	int
]	O
.	O
ca_changed	char
)	O
{	O
if	O
(	O
_gdbm_write_bucket	function
(	O
dbf	pointer
,	O
&	O
dbf	pointer
->	O
bucket_cache	pointer
[	O
cache_1	int
]	O
)	O
)	O
return	O
-	O
1	int
;	O
}	O
new_bits	int
=	O
dbf	pointer
->	O
bucket	pointer
->	O
bucket_bits	int
+	O
1	int
;	O
_gdbm_new_bucket	function
(	O
dbf	pointer
,	O
bucket	pointer
[	O
0	int
]	O
,	O
new_bits	int
)	O
;	O
_gdbm_new_bucket	function
(	O
dbf	pointer
,	O
bucket	pointer
[	O
1	int
]	O
,	O
new_bits	int
)	O
;	O
adr_0	long
=	O
_gdbm_alloc	function
(	O
dbf	pointer
,	O
dbf	pointer
->	O
header	pointer
->	O
bucket_size	int
)	O
;	O
if	O
(	O
adr_0	long
==	O
0	int
)	O
return	O
-	O
1	int
;	O
dbf	pointer
->	O
bucket_cache	pointer
[	O
cache_0	int
]	O
.	O
ca_adr	long
=	O
adr_0	long
;	O
adr_1	long
=	O
_gdbm_alloc	function
(	O
dbf	pointer
,	O
dbf	pointer
->	O
header	pointer
->	O
bucket_size	int
)	O
;	O
if	O
(	O
adr_1	long
==	O
0	int
)	O
return	O
-	O
1	int
;	O
dbf	pointer
->	O
bucket_cache	pointer
[	O
cache_1	int
]	O
.	O
ca_adr	long
=	O
adr_1	long
;	O
if	O
(	O
dbf	pointer
->	O
header	pointer
->	O
dir_bits	int
==	O
dbf	pointer
->	O
bucket	pointer
->	O
bucket_bits	int
)	O
{	O
if	O
(	O
dbf	pointer
->	O
header	pointer
->	O
dir_size	int
>=	O
GDBM_MAX_DIR_HALF	O
)	O
{	O
GDBM_SET_ERRNO	O
(	O
dbf	pointer
,	O
GDBM_DIR_OVERFLOW	int
,	O
TRUE	int
)	O
;	O
_gdbm_fatal	function
(	O
dbf	pointer
,	O
_	O
(	O
"directory overflow"	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
dir_size	int
=	O
dbf	pointer
->	O
header	pointer
->	O
dir_size	int
*	O
2	int
;	O
dir_adr	long
=	O
_gdbm_alloc	function
(	O
dbf	pointer
,	O
dir_size	int
)	O
;	O
if	O
(	O
dir_adr	long
==	O
0	int
)	O
return	O
-	O
1	int
;	O
new_dir	pointer
=	O
malloc	function
(	O
dir_size	int
)	O
;	O
if	O
(	O
new_dir	pointer
==	O
NULL	O
)	O
{	O
GDBM_SET_ERRNO	O
(	O
dbf	pointer
,	O
GDBM_MALLOC_ERROR	int
,	O
TRUE	int
)	O
;	O
_gdbm_fatal	function
(	O
dbf	pointer
,	O
_	O
(	O
"malloc error"	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
for	O
(	O
index	function
=	O
0	int
;	O
index	function
<	O
GDBM_DIR_COUNT	O
(	O
dbf	pointer
)	O
;	O
index	function
++	O
)	O
{	O
new_dir	pointer
[	O
2	int
*	O
index	function
]	O
=	O
dbf	pointer
->	O
dir	long
[	O
index	function
]	O
;	O
new_dir	pointer
[	O
2	int
*	O
index	function
+	O
1	int
]	O
=	O
dbf	pointer
->	O
dir	long
[	O
index	function
]	O
;	O
}	O
old_adr	array
[	O
old_count	int
]	O
=	O
dbf	pointer
->	O
header	pointer
->	O
dir	long
;	O
dbf	pointer
->	O
header	pointer
->	O
dir	long
=	O
dir_adr	long
;	O
old_size	array
[	O
old_count	int
]	O
=	O
dbf	pointer
->	O
header	pointer
->	O
dir_size	int
;	O
dbf	pointer
->	O
header	pointer
->	O
dir_size	int
=	O
dir_size	int
;	O
dbf	pointer
->	O
header	pointer
->	O
dir_bits	int
=	O
new_bits	int
;	O
old_count	int
++	O
;	O
dbf	pointer
->	O
header_changed	int
=	O
TRUE	int
;	O
dbf	pointer
->	O
bucket_dir	int
*=	O
2	int
;	O
free	function
(	O
dbf	pointer
->	O
dir	long
)	O
;	O
dbf	pointer
->	O
dir	long
=	O
new_dir	pointer
;	O
}	O
for	O
(	O
index	function
=	O
0	int
;	O
index	function
<	O
dbf	pointer
->	O
header	pointer
->	O
bucket_elems	int
;	O
index	function
++	O
)	O
{	O
old_el	pointer
=	O
&	O
dbf	pointer
->	O
bucket	pointer
->	O
h_table	array
[	O
index	function
]	O
;	O
select	function
=	O
(	O
old_el	pointer
->	O
hash_value	int
>>	O
(	O
GDBM_HASH_BITS	int
-	O
new_bits	int
)	O
)	O
&	O
1	int
;	O
elem_loc	int
=	O
old_el	pointer
->	O
hash_value	int
%	O
dbf	pointer
->	O
header	pointer
->	O
bucket_elems	int
;	O
while	O
(	O
bucket	pointer
[	O
select	function
]	O
->	O
h_table	array
[	O
elem_loc	int
]	O
.	O
hash_value	int
!=	O
-	O
1	int
)	O
elem_loc	int
=	O
(	O
elem_loc	int
+	O
1	int
)	O
%	O
dbf	pointer
->	O
header	pointer
->	O
bucket_elems	int
;	O
bucket	pointer
[	O
select	function
]	O
->	O
h_table	array
[	O
elem_loc	int
]	O
=	O
*	O
old_el	pointer
;	O
bucket	pointer
[	O
select	function
]	O
->	O
count	int
++	O
;	O
}	O
bucket	pointer
[	O
1	int
]	O
->	O
bucket_avail	array
[	O
0	int
]	O
.	O
av_adr	long
=	O
_gdbm_alloc	function
(	O
dbf	pointer
,	O
dbf	pointer
->	O
header	pointer
->	O
block_size	int
)	O
;	O
if	O
(	O
bucket	pointer
[	O
1	int
]	O
->	O
bucket_avail	array
[	O
0	int
]	O
.	O
av_adr	long
==	O
0	int
)	O
return	O
-	O
1	int
;	O
bucket	pointer
[	O
1	int
]	O
->	O
bucket_avail	array
[	O
0	int
]	O
.	O
av_size	int
=	O
dbf	pointer
->	O
header	pointer
->	O
block_size	int
;	O
bucket	pointer
[	O
1	int
]	O
->	O
av_count	int
=	O
1	int
;	O
bucket	pointer
[	O
0	int
]	O
->	O
av_count	int
=	O
dbf	pointer
->	O
bucket	pointer
->	O
av_count	int
;	O
index	function
=	O
0	int
;	O
index1	int
=	O
0	int
;	O
if	O
(	O
bucket	pointer
[	O
0	int
]	O
->	O
av_count	int
==	O
BUCKET_AVAIL	int
)	O
{	O
_gdbm_put_av_elem	function
(	O
dbf	pointer
->	O
bucket	pointer
->	O
bucket_avail	array
[	O
0	int
]	O
,	O
bucket	pointer
[	O
1	int
]	O
->	O
bucket_avail	array
,	O
&	O
bucket	pointer
[	O
1	int
]	O
->	O
av_count	int
,	O
dbf	pointer
->	O
coalesce_blocks	int
)	O
;	O
index	function
=	O
1	int
;	O
bucket	pointer
[	O
0	int
]	O
->	O
av_count	int
--	O
;	O
}	O
for	O
(	O
;	O
index	function
<	O
dbf	pointer
->	O
bucket	pointer
->	O
av_count	int
;	O
index	function
++	O
)	O
{	O
bucket	pointer
[	O
0	int
]	O
->	O
bucket_avail	array
[	O
index1	int
++	O
]	O
=	O
dbf	pointer
->	O
bucket	pointer
->	O
bucket_avail	array
[	O
index	function
]	O
;	O
}	O
dir_start1	long
=	O
(	O
dbf	pointer
->	O
bucket_dir	int
>>	O
(	O
dbf	pointer
->	O
header	pointer
->	O
dir_bits	int
-	O
new_bits	int
)	O
)	O
|	O
1	int
;	O
dir_end	long
=	O
(	O
dir_start1	long
+	O
1	int
)	O
<<	O
(	O
dbf	pointer
->	O
header	pointer
->	O
dir_bits	int
-	O
new_bits	int
)	O
;	O
dir_start1	long
=	O
dir_start1	long
<<	O
(	O
dbf	pointer
->	O
header	pointer
->	O
dir_bits	int
-	O
new_bits	int
)	O
;	O
dir_start0	long
=	O
dir_start1	long
-	O
(	O
dir_end	long
-	O
dir_start1	long
)	O
;	O
for	O
(	O
index	function
=	O
dir_start0	long
;	O
index	function
<	O
dir_start1	long
;	O
index	function
++	O
)	O
dbf	pointer
->	O
dir	long
[	O
index	function
]	O
=	O
adr_0	long
;	O
for	O
(	O
index	function
=	O
dir_start1	long
;	O
index	function
<	O
dir_end	long
;	O
index	function
++	O
)	O
dbf	pointer
->	O
dir	long
[	O
index	function
]	O
=	O
adr_1	long
;	O
dbf	pointer
->	O
bucket_cache	pointer
[	O
cache_0	int
]	O
.	O
ca_changed	char
=	O
TRUE	int
;	O
dbf	pointer
->	O
bucket_cache	pointer
[	O
cache_1	int
]	O
.	O
ca_changed	char
=	O
TRUE	int
;	O
dbf	pointer
->	O
bucket_changed	int
=	O
TRUE	int
;	O
dbf	pointer
->	O
directory_changed	int
=	O
TRUE	int
;	O
dbf	pointer
->	O
second_changed	int
=	O
TRUE	int
;	O
dbf	pointer
->	O
bucket_dir	int
=	O
_gdbm_bucket_dir	function
(	O
dbf	pointer
,	O
next_insert	int
)	O
;	O
old_bucket	struct
.	O
av_adr	long
=	O
dbf	pointer
->	O
cache_entry	pointer
->	O
ca_adr	long
;	O
old_bucket	struct
.	O
av_size	int
=	O
dbf	pointer
->	O
header	pointer
->	O
bucket_size	int
;	O
dbf	pointer
->	O
cache_entry	pointer
->	O
ca_adr	long
=	O
0	int
;	O
dbf	pointer
->	O
cache_entry	pointer
->	O
ca_changed	char
=	O
FALSE	int
;	O
if	O
(	O
dbf	pointer
->	O
dir	long
[	O
dbf	pointer
->	O
bucket_dir	int
]	O
==	O
adr_0	long
)	O
{	O
dbf	pointer
->	O
bucket	pointer
=	O
bucket	pointer
[	O
0	int
]	O
;	O
dbf	pointer
->	O
cache_entry	pointer
=	O
&	O
dbf	pointer
->	O
bucket_cache	pointer
[	O
cache_0	int
]	O
;	O
_gdbm_put_av_elem	function
(	O
old_bucket	struct
,	O
bucket	pointer
[	O
1	int
]	O
->	O
bucket_avail	array
,	O
&	O
bucket	pointer
[	O
1	int
]	O
->	O
av_count	int
,	O
dbf	pointer
->	O
coalesce_blocks	int
)	O
;	O
}	O
else	O
{	O
dbf	pointer
->	O
bucket	pointer
=	O
bucket	pointer
[	O
1	int
]	O
;	O
dbf	pointer
->	O
cache_entry	pointer
=	O
&	O
dbf	pointer
->	O
bucket_cache	pointer
[	O
cache_1	int
]	O
;	O
_gdbm_put_av_elem	function
(	O
old_bucket	struct
,	O
bucket	pointer
[	O
0	int
]	O
->	O
bucket_avail	array
,	O
&	O
bucket	pointer
[	O
0	int
]	O
->	O
av_count	int
,	O
dbf	pointer
->	O
coalesce_blocks	int
)	O
;	O
}	O
}	O
for	O
(	O
index	function
=	O
0	int
;	O
index	function
<	O
old_count	int
;	O
index	function
++	O
)	O
if	O
(	O
_gdbm_free	function
(	O
dbf	pointer
,	O
old_adr	array
[	O
index	function
]	O
,	O
old_size	array
[	O
index	function
]	O
)	O
)	O
return	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
_gdbm_write_bucket	function
(	O
GDBM_FILE	pointer
dbf	pointer
,	O
cache_elem	struct
*	O
ca_entry	pointer
)	O
{	O
int	O
rc	int
;	O
off_t	long
file_pos	long
;	O
file_pos	long
=	O
gdbm_file_seek	function
(	O
dbf	pointer
,	O
ca_entry	pointer
->	O
ca_adr	long
,	O
SEEK_SET	int
)	O
;	O
if	O
(	O
file_pos	long
!=	O
ca_entry	pointer
->	O
ca_adr	long
)	O
{	O
GDBM_SET_ERRNO	O
(	O
dbf	pointer
,	O
GDBM_FILE_SEEK_ERROR	int
,	O
TRUE	int
)	O
;	O
_gdbm_fatal	function
(	O
dbf	pointer
,	O
_	O
(	O
"lseek error"	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
rc	int
=	O
_gdbm_full_write	function
(	O
dbf	pointer
,	O
ca_entry	pointer
->	O
ca_bucket	pointer
,	O
dbf	pointer
->	O
header	pointer
->	O
bucket_size	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
GDBM_DEBUG	O
(	O
GDBM_DEBUG_STORE	O
|	O
GDBM_DEBUG_ERR	O
,	O
"%s: error writing bucket: %s"	pointer
,	O
dbf	pointer
->	O
name	pointer
,	O
gdbm_db_strerror	function
(	O
dbf	pointer
)	O
)	O
;	O
_gdbm_fatal	function
(	O
dbf	pointer
,	O
gdbm_strerror	function
(	O
rc	int
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
ca_entry	pointer
->	O
ca_changed	char
=	O
FALSE	int
;	O
ca_entry	pointer
->	O
ca_data	struct
.	O
hash_val	int
=	O
-	O
1	int
;	O
ca_entry	pointer
->	O
ca_data	struct
.	O
elem_loc	int
=	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
