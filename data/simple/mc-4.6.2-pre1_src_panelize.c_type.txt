static	O
WListbox	struct
*	O
l_panelize	pointer
;	O
static	O
Dlg_head	struct
*	O
panelize_dlg	pointer
;	O
static	O
int	O
last_listitem	int
;	O
static	O
WInput	struct
*	O
pname	pointer
;	O
static	O
struct	O
{	O
int	O
ret_cmd	int
,	O
flags	enum
,	O
y	short
,	O
x	array
;	O
const	O
char	O
*	O
text	pointer
;	O
}	O
panelize_but	array
[	O
BUTTONS	int
]	O
=	O
{	O
{	O
B_CANCEL	int
,	O
NORMAL_BUTTON	int
,	O
0	int
,	O
53	int
,	O
N_	O
(	O
"&Cancel"	pointer
)	O
}	O
,	O
{	O
B_ADD	O
,	O
NORMAL_BUTTON	int
,	O
0	int
,	O
28	int
,	O
N_	O
(	O
"&Add new"	pointer
)	O
}	O
,	O
{	O
B_REMOVE	O
,	O
NORMAL_BUTTON	int
,	O
0	int
,	O
16	int
,	O
N_	O
(	O
"&Remove"	pointer
)	O
}	O
,	O
{	O
B_ENTER	int
,	O
DEFPUSH_BUTTON	int
,	O
0	int
,	O
0	int
,	O
N_	O
(	O
"Pane&lize"	pointer
)	O
}	O
,	O
}	O
;	O
static	O
const	O
char	O
*	O
panelize_section	pointer
=	O
"Panelize"	pointer
;	O
static	O
void	O
do_external_panelize	function
(	O
char	O
*	O
command	pointer
)	O
;	O
static	O
struct	O
panelize	struct
{	O
char	O
*	O
command	pointer
;	O
char	O
*	O
label	pointer
;	O
struct	O
panelize	struct
*	O
next	pointer
;	O
}	O
*	O
panelize	struct
=	O
NULL	O
;	O
static	O
void	O
update_command	function
(	O
void	O
)	O
{	O
if	O
(	O
l_panelize	pointer
->	O
pos	pointer
!=	O
last_listitem	int
)	O
{	O
last_listitem	int
=	O
l_panelize	pointer
->	O
pos	pointer
;	O
assign_text	function
(	O
pname	pointer
,	O
(	O
(	O
struct	O
panelize	struct
*	O
)	O
l_panelize	pointer
->	O
current	pointer
->	O
data	pointer
)	O
->	O
command	pointer
)	O
;	O
pname	pointer
->	O
point	int
=	O
0	int
;	O
update_input	function
(	O
pname	pointer
,	O
1	int
)	O
;	O
}	O
}	O
static	O
cb_ret_t	enum
panelize_callback	function
(	O
Dlg_head	struct
*	O
h	pointer
,	O
dlg_msg_t	enum
msg	pointer
,	O
int	O
parm	int
)	O
{	O
switch	O
(	O
msg	pointer
)	O
{	O
case	O
DLG_DRAW	int
:	O
common_dialog_repaint	function
(	O
h	pointer
)	O
;	O
attrset	function
(	O
COLOR_NORMAL	O
)	O
;	O
draw_box	function
(	O
h	pointer
,	O
UY	int
,	O
UX	int
,	O
h	pointer
->	O
lines	pointer
-	O
10	int
,	O
h	pointer
->	O
cols	int
-	O
10	int
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
DLG_POST_KEY	int
:	O
case	O
DLG_INIT	int
:	O
attrset	function
(	O
MENU_ENTRY_COLOR	O
)	O
;	O
update_command	function
(	O
)	O
;	O
return	O
MSG_HANDLED	int
;	O
default	O
:	O
return	O
default_dlg_callback	function
(	O
h	pointer
,	O
msg	pointer
,	O
parm	int
)	O
;	O
}	O
}	O
static	O
void	O
init_panelize	function
(	O
void	O
)	O
{	O
int	O
i	array
,	O
panelize_cols	int
=	O
COLS	O
-	O
6	int
;	O
struct	O
panelize	struct
*	O
current	pointer
=	O
panelize	struct
;	O
static	O
int	O
i18n_flag	int
=	O
0	int
;	O
static	O
int	O
maxlen	int
=	O
0	int
;	O
if	O
(	O
!	O
i18n_flag	int
)	O
{	O
i	array
=	O
sizeof	O
(	O
panelize_but	array
)	O
/	O
sizeof	O
(	O
panelize_but	array
[	O
0	int
]	O
)	O
;	O
while	O
(	O
i	array
--	O
)	O
{	O
panelize_but	array
[	O
i	array
]	O
.	O
text	pointer
=	O
_	O
(	O
panelize_but	array
[	O
i	array
]	O
.	O
text	pointer
)	O
;	O
maxlen	int
+=	O
strlen	function
(	O
panelize_but	array
[	O
i	array
]	O
.	O
text	pointer
)	O
+	O
5	int
;	O
}	O
maxlen	int
+=	O
10	int
;	O
i18n_flag	int
=	O
1	int
;	O
}	O
panelize_cols	int
=	O
max	long
(	O
panelize_cols	int
,	O
maxlen	int
)	O
;	O
panelize_but	array
[	O
2	int
]	O
.	O
x	array
=	O
panelize_but	array
[	O
3	int
]	O
.	O
x	array
+	O
strlen	function
(	O
panelize_but	array
[	O
3	int
]	O
.	O
text	pointer
)	O
+	O
7	int
;	O
panelize_but	array
[	O
1	int
]	O
.	O
x	array
=	O
panelize_but	array
[	O
2	int
]	O
.	O
x	array
+	O
strlen	function
(	O
panelize_but	array
[	O
2	int
]	O
.	O
text	pointer
)	O
+	O
5	int
;	O
panelize_but	array
[	O
0	int
]	O
.	O
x	array
=	O
panelize_cols	int
-	O
strlen	function
(	O
panelize_but	array
[	O
0	int
]	O
.	O
text	pointer
)	O
-	O
8	int
-	O
BX	int
;	O
last_listitem	int
=	O
0	int
;	O
do_refresh	function
(	O
)	O
;	O
panelize_dlg	pointer
=	O
create_dlg	function
(	O
0	int
,	O
0	int
,	O
22	int
,	O
panelize_cols	int
,	O
dialog_colors	array
,	O
panelize_callback	function
,	O
"[External panelize]"	pointer
,	O
_	O
(	O
"External panelize"	pointer
)	O
,	O
DLG_CENTER	O
|	O
DLG_REVERSE	O
)	O
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
BUTTONS	int
;	O
i	array
++	O
)	O
add_widget	function
(	O
panelize_dlg	pointer
,	O
button_new	function
(	O
BY	int
+	O
panelize_but	array
[	O
i	array
]	O
.	O
y	short
,	O
BX	int
+	O
panelize_but	array
[	O
i	array
]	O
.	O
x	array
,	O
panelize_but	array
[	O
i	array
]	O
.	O
ret_cmd	int
,	O
panelize_but	array
[	O
i	array
]	O
.	O
flags	enum
,	O
panelize_but	array
[	O
i	array
]	O
.	O
text	pointer
,	O
0	int
)	O
)	O
;	O
pname	pointer
=	O
input_new	function
(	O
UY	int
+	O
14	int
,	O
UX	int
,	O
INPUT_COLOR	O
,	O
panelize_dlg	pointer
->	O
cols	int
-	O
10	int
,	O
""	pointer
,	O
"in"	pointer
)	O
;	O
add_widget	function
(	O
panelize_dlg	pointer
,	O
pname	pointer
)	O
;	O
add_widget	function
(	O
panelize_dlg	pointer
,	O
label_new	function
(	O
UY	int
+	O
13	int
,	O
UX	int
,	O
_	O
(	O
"Command"	pointer
)	O
)	O
)	O
;	O
l_panelize	pointer
=	O
listbox_new	function
(	O
UY	int
+	O
1	int
,	O
UX	int
+	O
1	int
,	O
panelize_dlg	pointer
->	O
cols	int
-	O
12	int
,	O
10	int
,	O
NULL	O
)	O
;	O
while	O
(	O
current	pointer
)	O
{	O
listbox_add_item	function
(	O
l_panelize	pointer
,	O
0	int
,	O
0	int
,	O
current	pointer
->	O
label	pointer
,	O
current	pointer
)	O
;	O
current	pointer
=	O
current	pointer
->	O
next	pointer
;	O
}	O
add_widget	function
(	O
panelize_dlg	pointer
,	O
l_panelize	pointer
)	O
;	O
listbox_select_entry	function
(	O
l_panelize	pointer
,	O
listbox_search_text	function
(	O
l_panelize	pointer
,	O
_	O
(	O
"Other command"	pointer
)	O
)	O
)	O
;	O
}	O
static	O
void	O
panelize_done	function
(	O
void	O
)	O
{	O
destroy_dlg	function
(	O
panelize_dlg	pointer
)	O
;	O
repaint_screen	function
(	O
)	O
;	O
}	O
static	O
void	O
add2panelize	function
(	O
char	O
*	O
label	pointer
,	O
char	O
*	O
command	pointer
)	O
{	O
struct	O
panelize	struct
*	O
current	pointer
,	O
*	O
old	pointer
;	O
old	pointer
=	O
NULL	O
;	O
current	pointer
=	O
panelize	struct
;	O
while	O
(	O
current	pointer
&&	O
strcmp	function
(	O
current	pointer
->	O
label	pointer
,	O
label	pointer
)	O
<=	O
0	int
)	O
{	O
old	pointer
=	O
current	pointer
;	O
current	pointer
=	O
current	pointer
->	O
next	pointer
;	O
}	O
if	O
(	O
old	pointer
==	O
NULL	O
)	O
{	O
panelize	struct
=	O
g_new	O
(	O
struct	O
panelize	struct
,	O
1	int
)	O
;	O
panelize	struct
->	O
label	pointer
=	O
label	pointer
;	O
panelize	struct
->	O
command	pointer
=	O
command	pointer
;	O
panelize	struct
->	O
next	pointer
=	O
current	pointer
;	O
}	O
else	O
{	O
struct	O
panelize	struct
*	O
new	pointer
;	O
new	pointer
=	O
g_new	O
(	O
struct	O
panelize	struct
,	O
1	int
)	O
;	O
new	pointer
->	O
label	pointer
=	O
label	pointer
;	O
new	pointer
->	O
command	pointer
=	O
command	pointer
;	O
old	pointer
->	O
next	pointer
=	O
new	pointer
;	O
new	pointer
->	O
next	pointer
=	O
current	pointer
;	O
}	O
}	O
static	O
void	O
add2panelize_cmd	function
(	O
void	O
)	O
{	O
char	O
*	O
label	pointer
;	O
if	O
(	O
pname	pointer
->	O
buffer	pointer
&&	O
(	O
*	O
pname	pointer
->	O
buffer	pointer
)	O
)	O
{	O
label	pointer
=	O
input_dialog	function
(	O
_	O
(	O
" Add to external panelize "	pointer
)	O
,	O
_	O
(	O
" Enter command label: "	pointer
)	O
,	O
""	pointer
)	O
;	O
if	O
(	O
!	O
label	pointer
)	O
return	O
;	O
if	O
(	O
!	O
*	O
label	pointer
)	O
{	O
g_free	function
(	O
label	pointer
)	O
;	O
return	O
;	O
}	O
add2panelize	function
(	O
label	pointer
,	O
g_strdup	function
(	O
pname	pointer
->	O
buffer	pointer
)	O
)	O
;	O
}	O
}	O
static	O
void	O
remove_from_panelize	function
(	O
struct	O
panelize	struct
*	O
entry	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
entry	pointer
->	O
label	pointer
,	O
_	O
(	O
"Other command"	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
entry	pointer
==	O
panelize	struct
)	O
{	O
panelize	struct
=	O
panelize	struct
->	O
next	pointer
;	O
}	O
else	O
{	O
struct	O
panelize	struct
*	O
current	pointer
=	O
panelize	struct
;	O
while	O
(	O
current	pointer
&&	O
current	pointer
->	O
next	pointer
!=	O
entry	pointer
)	O
current	pointer
=	O
current	pointer
->	O
next	pointer
;	O
if	O
(	O
current	pointer
)	O
{	O
current	pointer
->	O
next	pointer
=	O
entry	pointer
->	O
next	pointer
;	O
}	O
}	O
g_free	function
(	O
entry	pointer
->	O
label	pointer
)	O
;	O
g_free	function
(	O
entry	pointer
->	O
command	pointer
)	O
;	O
g_free	function
(	O
entry	pointer
)	O
;	O
}	O
}	O
void	O
external_panelize	function
(	O
void	O
)	O
{	O
char	O
*	O
target	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
vfs_current_is_local	function
(	O
)	O
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" Cannot run external panelize in a non-local directory "	pointer
)	O
)	O
;	O
return	O
;	O
}	O
init_panelize	function
(	O
)	O
;	O
attrset	function
(	O
SELECTED_COLOR	O
)	O
;	O
run_dlg	function
(	O
panelize_dlg	pointer
)	O
;	O
switch	O
(	O
panelize_dlg	pointer
->	O
ret_value	int
)	O
{	O
case	O
B_CANCEL	int
:	O
break	O
;	O
case	O
B_ADD	O
:	O
add2panelize_cmd	function
(	O
)	O
;	O
break	O
;	O
case	O
B_REMOVE	O
:	O
remove_from_panelize	function
(	O
l_panelize	pointer
->	O
current	pointer
->	O
data	pointer
)	O
;	O
break	O
;	O
case	O
B_ENTER	int
:	O
target	pointer
=	O
pname	pointer
->	O
buffer	pointer
;	O
if	O
(	O
target	pointer
!=	O
NULL	O
&&	O
*	O
target	pointer
)	O
{	O
char	O
*	O
cmd	pointer
=	O
g_strdup	function
(	O
target	pointer
)	O
;	O
destroy_dlg	function
(	O
panelize_dlg	pointer
)	O
;	O
do_external_panelize	function
(	O
cmd	pointer
)	O
;	O
g_free	function
(	O
cmd	pointer
)	O
;	O
repaint_screen	function
(	O
)	O
;	O
return	O
;	O
}	O
break	O
;	O
}	O
panelize_done	function
(	O
)	O
;	O
}	O
void	O
load_panelize	function
(	O
void	O
)	O
{	O
void	O
*	O
profile_keys	pointer
;	O
char	O
*	O
key	pointer
,	O
*	O
value	pointer
;	O
profile_keys	pointer
=	O
profile_init_iterator	function
(	O
panelize_section	pointer
,	O
profile_name	pointer
)	O
;	O
add2panelize	function
(	O
g_strdup	function
(	O
_	O
(	O
"Other command"	pointer
)	O
)	O
,	O
g_strdup	function
(	O
""	pointer
)	O
)	O
;	O
if	O
(	O
!	O
profile_keys	pointer
)	O
{	O
add2panelize	function
(	O
g_strdup	function
(	O
_	O
(	O
"Find rejects after patching"	pointer
)	O
)	O
,	O
g_strdup	function
(	O
"find . -name \\*.rej -print"	pointer
)	O
)	O
;	O
add2panelize	function
(	O
g_strdup	function
(	O
_	O
(	O
"Find *.orig after patching"	pointer
)	O
)	O
,	O
g_strdup	function
(	O
"find . -name \\*.orig -print"	pointer
)	O
)	O
;	O
add2panelize	function
(	O
g_strdup	function
(	O
_	O
(	O
"Find SUID and SGID programs"	pointer
)	O
)	O
,	O
g_strdup	function
(	O
"find . \\( \\( -perm -04000 -a -perm +011 \\) -o \\( -perm -02000 -a -perm +01 \\) \\) -print"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
while	O
(	O
profile_keys	pointer
)	O
{	O
profile_keys	pointer
=	O
profile_iterator_next	function
(	O
profile_keys	pointer
,	O
&	O
key	pointer
,	O
&	O
value	pointer
)	O
;	O
add2panelize	function
(	O
g_strdup	function
(	O
key	pointer
)	O
,	O
g_strdup	function
(	O
value	pointer
)	O
)	O
;	O
}	O
}	O
void	O
save_panelize	function
(	O
void	O
)	O
{	O
struct	O
panelize	struct
*	O
current	pointer
=	O
panelize	struct
;	O
profile_clean_section	function
(	O
panelize_section	pointer
,	O
profile_name	pointer
)	O
;	O
for	O
(	O
;	O
current	pointer
;	O
current	pointer
=	O
current	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
current	pointer
->	O
label	pointer
,	O
_	O
(	O
"Other command"	pointer
)	O
)	O
)	O
WritePrivateProfileString	function
(	O
panelize_section	pointer
,	O
current	pointer
->	O
label	pointer
,	O
current	pointer
->	O
command	pointer
,	O
profile_name	pointer
)	O
;	O
}	O
sync_profiles	function
(	O
)	O
;	O
}	O
void	O
done_panelize	function
(	O
void	O
)	O
{	O
struct	O
panelize	struct
*	O
current	pointer
=	O
panelize	struct
;	O
struct	O
panelize	struct
*	O
next	pointer
;	O
for	O
(	O
;	O
current	pointer
;	O
current	pointer
=	O
next	pointer
)	O
{	O
next	pointer
=	O
current	pointer
->	O
next	pointer
;	O
g_free	function
(	O
current	pointer
->	O
label	pointer
)	O
;	O
g_free	function
(	O
current	pointer
->	O
command	pointer
)	O
;	O
g_free	function
(	O
current	pointer
)	O
;	O
}	O
}	O
static	O
void	O
do_external_panelize	function
(	O
char	O
*	O
command	pointer
)	O
{	O
int	O
status	int
,	O
link_to_dir	int
,	O
stale_link	int
;	O
int	O
next_free	int
=	O
0	int
;	O
struct	O
stat	struct
st	pointer
;	O
dir_list	struct
*	O
list	pointer
=	O
&	O
current_panel	pointer
->	O
dir	pointer
;	O
char	O
line	int
[	O
MC_MAXPATHLEN	O
]	O
;	O
char	O
*	O
name	pointer
;	O
FILE	struct
*	O
external	pointer
;	O
open_error_pipe	function
(	O
)	O
;	O
external	pointer
=	O
popen	function
(	O
command	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
!	O
external	pointer
)	O
{	O
close_error_pipe	function
(	O
1	int
,	O
_	O
(	O
"Cannot invoke command."	pointer
)	O
)	O
;	O
return	O
;	O
}	O
panel_clean_dir	function
(	O
current_panel	pointer
)	O
;	O
while	O
(	O
1	int
)	O
{	O
clearerr	function
(	O
external	pointer
)	O
;	O
if	O
(	O
fgets	function
(	O
line	int
,	O
MC_MAXPATHLEN	O
,	O
external	pointer
)	O
==	O
NULL	O
)	O
{	O
if	O
(	O
ferror	function
(	O
external	pointer
)	O
&&	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
else	O
break	O
;	O
}	O
if	O
(	O
line	int
[	O
strlen	function
(	O
line	int
)	O
-	O
1	int
]	O
==	O
'\n'	O
)	O
line	int
[	O
strlen	function
(	O
line	int
)	O
-	O
1	int
]	O
=	O
0	int
;	O
if	O
(	O
strlen	function
(	O
line	int
)	O
<	O
1	int
)	O
continue	O
;	O
if	O
(	O
line	int
[	O
0	int
]	O
==	O
'.'	O
&&	O
line	int
[	O
1	int
]	O
==	O
PATH_SEP	char
)	O
name	pointer
=	O
line	int
+	O
2	int
;	O
else	O
name	pointer
=	O
line	int
;	O
status	int
=	O
handle_path	function
(	O
list	pointer
,	O
name	pointer
,	O
&	O
st	pointer
,	O
next_free	int
,	O
&	O
link_to_dir	int
,	O
&	O
stale_link	int
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
status	int
==	O
-	O
1	int
)	O
break	O
;	O
list	pointer
->	O
list	pointer
[	O
next_free	int
]	O
.	O
fnamelen	int
=	O
strlen	function
(	O
name	pointer
)	O
;	O
list	pointer
->	O
list	pointer
[	O
next_free	int
]	O
.	O
fname	pointer
=	O
g_strdup	function
(	O
name	pointer
)	O
;	O
file_mark	function
(	O
current_panel	pointer
,	O
next_free	int
,	O
0	int
)	O
;	O
list	pointer
->	O
list	pointer
[	O
next_free	int
]	O
.	O
f	float
.	O
link_to_dir	int
=	O
link_to_dir	int
;	O
list	pointer
->	O
list	pointer
[	O
next_free	int
]	O
.	O
f	float
.	O
stale_link	int
=	O
stale_link	int
;	O
list	pointer
->	O
list	pointer
[	O
next_free	int
]	O
.	O
f	float
.	O
dir_size_computed	int
=	O
0	int
;	O
list	pointer
->	O
list	pointer
[	O
next_free	int
]	O
.	O
st	pointer
=	O
st	pointer
;	O
next_free	int
++	O
;	O
if	O
(	O
!	O
(	O
next_free	int
&	O
32	int
)	O
)	O
rotate_dash	function
(	O
)	O
;	O
}	O
current_panel	pointer
->	O
is_panelized	int
=	O
1	int
;	O
if	O
(	O
next_free	int
)	O
{	O
current_panel	pointer
->	O
count	int
=	O
next_free	int
;	O
if	O
(	O
list	pointer
->	O
list	pointer
[	O
0	int
]	O
.	O
fname	pointer
[	O
0	int
]	O
==	O
PATH_SEP	char
)	O
{	O
strcpy	function
(	O
current_panel	pointer
->	O
cwd	short
,	O
PATH_SEP_STR	pointer
)	O
;	O
chdir	function
(	O
PATH_SEP_STR	pointer
)	O
;	O
}	O
}	O
else	O
{	O
current_panel	pointer
->	O
count	int
=	O
set_zero_dir	function
(	O
list	pointer
)	O
;	O
}	O
if	O
(	O
pclose	function
(	O
external	pointer
)	O
<	O
0	int
)	O
message	pointer
(	O
0	int
,	O
_	O
(	O
"External panelize"	pointer
)	O
,	O
_	O
(	O
"Pipe close failed"	pointer
)	O
)	O
;	O
close_error_pipe	function
(	O
0	int
,	O
0	int
)	O
;	O
try_to_select	function
(	O
current_panel	pointer
,	O
NULL	O
)	O
;	O
panel_re_sort	function
(	O
current_panel	pointer
)	O
;	O
}	O
