DECLARE	O
(	O
m4___file__	function
)	O
;	O
DECLARE	O
(	O
m4___line__	function
)	O
;	O
DECLARE	O
(	O
m4___program__	function
)	O
;	O
DECLARE	O
(	O
m4_builtin	function
)	O
;	O
DECLARE	O
(	O
m4_changecom	function
)	O
;	O
DECLARE	O
(	O
m4_changequote	function
)	O
;	O
DECLARE	O
(	O
m4_debugmode	function
)	O
;	O
DECLARE	O
(	O
m4_debugfile	function
)	O
;	O
DECLARE	O
(	O
m4_decr	function
)	O
;	O
DECLARE	O
(	O
m4_define	function
)	O
;	O
DECLARE	O
(	O
m4_defn	function
)	O
;	O
DECLARE	O
(	O
m4_divert	function
)	O
;	O
DECLARE	O
(	O
m4_divnum	function
)	O
;	O
DECLARE	O
(	O
m4_dnl	function
)	O
;	O
DECLARE	O
(	O
m4_dumpdef	function
)	O
;	O
DECLARE	O
(	O
m4_errprint	function
)	O
;	O
DECLARE	O
(	O
m4_esyscmd	function
)	O
;	O
DECLARE	O
(	O
m4_eval	function
)	O
;	O
DECLARE	O
(	O
m4_format	function
)	O
;	O
DECLARE	O
(	O
m4_ifdef	function
)	O
;	O
DECLARE	O
(	O
m4_ifelse	function
)	O
;	O
DECLARE	O
(	O
m4_include	function
)	O
;	O
DECLARE	O
(	O
m4_incr	function
)	O
;	O
DECLARE	O
(	O
m4_index	function
)	O
;	O
DECLARE	O
(	O
m4_indir	function
)	O
;	O
DECLARE	O
(	O
m4_len	function
)	O
;	O
DECLARE	O
(	O
m4_m4exit	function
)	O
;	O
DECLARE	O
(	O
m4_m4wrap	function
)	O
;	O
DECLARE	O
(	O
m4_maketemp	function
)	O
;	O
DECLARE	O
(	O
m4_mkstemp	function
)	O
;	O
DECLARE	O
(	O
m4_patsubst	function
)	O
;	O
DECLARE	O
(	O
m4_popdef	function
)	O
;	O
DECLARE	O
(	O
m4_pushdef	function
)	O
;	O
DECLARE	O
(	O
m4_regexp	function
)	O
;	O
DECLARE	O
(	O
m4_shift	function
)	O
;	O
DECLARE	O
(	O
m4_sinclude	function
)	O
;	O
DECLARE	O
(	O
m4_substr	function
)	O
;	O
DECLARE	O
(	O
m4_syscmd	function
)	O
;	O
DECLARE	O
(	O
m4_sysval	function
)	O
;	O
DECLARE	O
(	O
m4_traceoff	function
)	O
;	O
DECLARE	O
(	O
m4_traceon	function
)	O
;	O
DECLARE	O
(	O
m4_translit	function
)	O
;	O
DECLARE	O
(	O
m4_undefine	function
)	O
;	O
DECLARE	O
(	O
m4_undivert	function
)	O
;	O
static	O
builtin	struct
const	O
builtin_tab	array
[	O
]	O
=	O
{	O
{	O
"__file__"	pointer
,	O
true	int
,	O
false	int
,	O
false	int
,	O
m4___file__	function
}	O
,	O
{	O
"__line__"	pointer
,	O
true	int
,	O
false	int
,	O
false	int
,	O
m4___line__	function
}	O
,	O
{	O
"__program__"	pointer
,	O
true	int
,	O
false	int
,	O
false	int
,	O
m4___program__	function
}	O
,	O
{	O
"builtin"	pointer
,	O
true	int
,	O
true	int
,	O
true	int
,	O
m4_builtin	function
}	O
,	O
{	O
"changecom"	pointer
,	O
false	int
,	O
false	int
,	O
false	int
,	O
m4_changecom	function
}	O
,	O
{	O
"changequote"	pointer
,	O
false	int
,	O
false	int
,	O
false	int
,	O
m4_changequote	function
}	O
,	O
{	O
"debugmode"	pointer
,	O
true	int
,	O
false	int
,	O
false	int
,	O
m4_debugmode	function
}	O
,	O
{	O
"debugfile"	pointer
,	O
true	int
,	O
false	int
,	O
false	int
,	O
m4_debugfile	function
}	O
,	O
{	O
"decr"	pointer
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_decr	function
}	O
,	O
{	O
"define"	pointer
,	O
false	int
,	O
true	int
,	O
true	int
,	O
m4_define	function
}	O
,	O
{	O
"defn"	pointer
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_defn	function
}	O
,	O
{	O
"divert"	pointer
,	O
false	int
,	O
false	int
,	O
false	int
,	O
m4_divert	function
}	O
,	O
{	O
"divnum"	pointer
,	O
false	int
,	O
false	int
,	O
false	int
,	O
m4_divnum	function
}	O
,	O
{	O
"dnl"	pointer
,	O
false	int
,	O
false	int
,	O
false	int
,	O
m4_dnl	function
}	O
,	O
{	O
"dumpdef"	pointer
,	O
false	int
,	O
false	int
,	O
false	int
,	O
m4_dumpdef	function
}	O
,	O
{	O
"errprint"	pointer
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_errprint	function
}	O
,	O
{	O
"esyscmd"	pointer
,	O
true	int
,	O
false	int
,	O
true	int
,	O
m4_esyscmd	function
}	O
,	O
{	O
"eval"	pointer
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_eval	function
}	O
,	O
{	O
"format"	pointer
,	O
true	int
,	O
false	int
,	O
true	int
,	O
m4_format	function
}	O
,	O
{	O
"ifdef"	pointer
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_ifdef	function
}	O
,	O
{	O
"ifelse"	pointer
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_ifelse	function
}	O
,	O
{	O
"include"	pointer
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_include	function
}	O
,	O
{	O
"incr"	pointer
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_incr	function
}	O
,	O
{	O
"index"	pointer
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_index	function
}	O
,	O
{	O
"indir"	pointer
,	O
true	int
,	O
true	int
,	O
true	int
,	O
m4_indir	function
}	O
,	O
{	O
"len"	pointer
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_len	function
}	O
,	O
{	O
"m4exit"	pointer
,	O
false	int
,	O
false	int
,	O
false	int
,	O
m4_m4exit	function
}	O
,	O
{	O
"m4wrap"	pointer
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_m4wrap	function
}	O
,	O
{	O
"maketemp"	pointer
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_maketemp	function
}	O
,	O
{	O
"mkstemp"	pointer
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_mkstemp	function
}	O
,	O
{	O
"patsubst"	pointer
,	O
true	int
,	O
false	int
,	O
true	int
,	O
m4_patsubst	function
}	O
,	O
{	O
"popdef"	pointer
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_popdef	function
}	O
,	O
{	O
"pushdef"	pointer
,	O
false	int
,	O
true	int
,	O
true	int
,	O
m4_pushdef	function
}	O
,	O
{	O
"regexp"	pointer
,	O
true	int
,	O
false	int
,	O
true	int
,	O
m4_regexp	function
}	O
,	O
{	O
"shift"	pointer
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_shift	function
}	O
,	O
{	O
"sinclude"	pointer
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_sinclude	function
}	O
,	O
{	O
"substr"	pointer
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_substr	function
}	O
,	O
{	O
"syscmd"	pointer
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_syscmd	function
}	O
,	O
{	O
"sysval"	pointer
,	O
false	int
,	O
false	int
,	O
false	int
,	O
m4_sysval	function
}	O
,	O
{	O
"traceoff"	pointer
,	O
false	int
,	O
false	int
,	O
false	int
,	O
m4_traceoff	function
}	O
,	O
{	O
"traceon"	pointer
,	O
false	int
,	O
false	int
,	O
false	int
,	O
m4_traceon	function
}	O
,	O
{	O
"translit"	pointer
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_translit	function
}	O
,	O
{	O
"undefine"	pointer
,	O
false	int
,	O
false	int
,	O
true	int
,	O
m4_undefine	function
}	O
,	O
{	O
"undivert"	pointer
,	O
false	int
,	O
false	int
,	O
false	int
,	O
m4_undivert	function
}	O
,	O
{	O
0	int
,	O
false	int
,	O
false	int
,	O
false	int
,	O
0	int
}	O
,	O
{	O
"placeholder"	pointer
,	O
true	int
,	O
false	int
,	O
false	int
,	O
m4_placeholder	function
}	O
,	O
}	O
;	O
static	O
predefined	struct
const	O
predefined_tab	array
[	O
]	O
=	O
{	O
{	O
"unix"	pointer
,	O
"__unix__"	pointer
,	O
""	pointer
}	O
,	O
{	O
NULL	O
,	O
"__gnu__"	pointer
,	O
""	pointer
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
}	O
;	O
const	O
builtin	struct
*	O
M4_GNUC_PURE	O
find_builtin_by_addr	function
(	O
builtin_func	function
*	O
func	pointer
)	O
{	O
const	O
builtin	struct
*	O
bp	pointer
;	O
for	O
(	O
bp	pointer
=	O
&	O
builtin_tab	array
[	O
0	int
]	O
;	O
bp	pointer
->	O
name	pointer
!=	O
NULL	O
;	O
bp	pointer
++	O
)	O
if	O
(	O
bp	pointer
->	O
func	pointer
==	O
func	pointer
)	O
return	O
bp	pointer
;	O
if	O
(	O
func	pointer
==	O
m4_placeholder	function
)	O
return	O
bp	pointer
+	O
1	int
;	O
return	O
NULL	O
;	O
}	O
const	O
builtin	struct
*	O
M4_GNUC_PURE	O
find_builtin_by_name	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
const	O
builtin	struct
*	O
bp	pointer
;	O
for	O
(	O
bp	pointer
=	O
&	O
builtin_tab	array
[	O
0	int
]	O
;	O
bp	pointer
->	O
name	pointer
!=	O
NULL	O
;	O
bp	pointer
++	O
)	O
if	O
(	O
STREQ	O
(	O
bp	pointer
->	O
name	pointer
,	O
name	pointer
)	O
)	O
return	O
bp	pointer
;	O
return	O
bp	pointer
+	O
1	int
;	O
}	O
void	O
define_builtin	function
(	O
const	O
char	O
*	O
name	pointer
,	O
const	O
builtin	struct
*	O
bp	pointer
,	O
symbol_lookup	enum
mode	int
)	O
{	O
symbol	struct
*	O
sym	pointer
;	O
sym	pointer
=	O
lookup_symbol	function
(	O
name	pointer
,	O
mode	int
)	O
;	O
SYMBOL_TYPE	O
(	O
sym	pointer
)	O
=	O
TOKEN_FUNC	int
;	O
SYMBOL_MACRO_ARGS	O
(	O
sym	pointer
)	O
=	O
bp	pointer
->	O
groks_macro_args	bool
;	O
SYMBOL_BLIND_NO_ARGS	O
(	O
sym	pointer
)	O
=	O
bp	pointer
->	O
blind_if_no_args	bool
;	O
SYMBOL_FUNC	O
(	O
sym	pointer
)	O
=	O
bp	pointer
->	O
func	pointer
;	O
}	O
static	O
struct	O
re_pattern_buffer	struct
macro_sequence_buf	struct
;	O
static	O
struct	O
re_registers	struct
macro_sequence_regs	struct
;	O
static	O
bool	bool
macro_sequence_inuse	bool
;	O
static	O
void	O
free_pattern_buffer	function
(	O
struct	O
re_pattern_buffer	struct
*	O
buf	pointer
,	O
struct	O
re_registers	struct
*	O
regs	pointer
)	O
{	O
regfree	function
(	O
buf	pointer
)	O
;	O
free	function
(	O
regs	pointer
->	O
start	pointer
)	O
;	O
free	function
(	O
regs	pointer
->	O
end	pointer
)	O
;	O
}	O
void	O
set_macro_sequence	function
(	O
const	O
char	O
*	O
regexp	pointer
)	O
{	O
const	O
char	O
*	O
msg	pointer
;	O
if	O
(	O
!	O
regexp	pointer
)	O
regexp	pointer
=	O
DEFAULT_MACRO_SEQUENCE	pointer
;	O
else	O
if	O
(	O
regexp	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
macro_sequence_inuse	bool
=	O
false	int
;	O
return	O
;	O
}	O
msg	pointer
=	O
re_compile_pattern	function
(	O
regexp	pointer
,	O
strlen	function
(	O
regexp	pointer
)	O
,	O
&	O
macro_sequence_buf	struct
)	O
;	O
if	O
(	O
msg	pointer
!=	O
NULL	O
)	O
{	O
M4ERROR	O
(	O
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"--warn-macro-sequence: bad regular expression `%s': %s"	pointer
,	O
regexp	pointer
,	O
msg	pointer
)	O
)	O
;	O
}	O
re_set_registers	function
(	O
&	O
macro_sequence_buf	struct
,	O
&	O
macro_sequence_regs	struct
,	O
macro_sequence_regs	struct
.	O
num_regs	int
,	O
macro_sequence_regs	struct
.	O
start	pointer
,	O
macro_sequence_regs	struct
.	O
end	pointer
)	O
;	O
macro_sequence_inuse	bool
=	O
true	int
;	O
}	O
void	O
free_macro_sequence	function
(	O
void	O
)	O
{	O
free_pattern_buffer	function
(	O
&	O
macro_sequence_buf	struct
,	O
&	O
macro_sequence_regs	struct
)	O
;	O
}	O
void	O
define_user_macro	function
(	O
const	O
char	O
*	O
name	pointer
,	O
const	O
char	O
*	O
text	pointer
,	O
symbol_lookup	enum
mode	int
)	O
{	O
symbol	struct
*	O
s	long
;	O
char	O
*	O
defn	pointer
=	O
xstrdup	function
(	O
text	pointer
?	O
text	pointer
:	O
""	pointer
)	O
;	O
s	long
=	O
lookup_symbol	function
(	O
name	pointer
,	O
mode	int
)	O
;	O
if	O
(	O
SYMBOL_TYPE	O
(	O
s	long
)	O
==	O
TOKEN_TEXT	int
)	O
free	function
(	O
SYMBOL_TEXT	O
(	O
s	long
)	O
)	O
;	O
SYMBOL_TYPE	O
(	O
s	long
)	O
=	O
TOKEN_TEXT	int
;	O
SYMBOL_TEXT	O
(	O
s	long
)	O
=	O
defn	pointer
;	O
if	O
(	O
macro_sequence_inuse	bool
&&	O
text	pointer
)	O
{	O
regoff_t	int
offset	long
=	O
0	int
;	O
size_t	long
len	long
=	O
strlen	function
(	O
defn	pointer
)	O
;	O
while	O
(	O
(	O
offset	long
=	O
re_search	function
(	O
&	O
macro_sequence_buf	struct
,	O
defn	pointer
,	O
len	long
,	O
offset	long
,	O
len	long
-	O
offset	long
,	O
&	O
macro_sequence_regs	struct
)	O
)	O
>=	O
0	int
)	O
{	O
if	O
(	O
macro_sequence_regs	struct
.	O
start	pointer
[	O
0	int
]	O
==	O
macro_sequence_regs	struct
.	O
end	pointer
[	O
0	int
]	O
)	O
offset	long
++	O
;	O
else	O
{	O
char	O
tmp	char
;	O
offset	long
=	O
macro_sequence_regs	struct
.	O
end	pointer
[	O
0	int
]	O
;	O
tmp	char
=	O
defn	pointer
[	O
offset	long
]	O
;	O
defn	pointer
[	O
offset	long
]	O
=	O
'\0'	O
;	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"Warning: definition of `%s' contains sequence `%s'"	pointer
,	O
name	pointer
,	O
defn	pointer
+	O
macro_sequence_regs	struct
.	O
start	pointer
[	O
0	int
]	O
)	O
)	O
;	O
defn	pointer
[	O
offset	long
]	O
=	O
tmp	char
;	O
}	O
}	O
if	O
(	O
offset	long
==	O
-	O
2	int
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"error checking --warn-macro-sequence for macro `%s'"	pointer
,	O
name	pointer
)	O
)	O
;	O
}	O
}	O
void	O
builtin_init	function
(	O
void	O
)	O
{	O
const	O
builtin	struct
*	O
bp	pointer
;	O
const	O
predefined	struct
*	O
pp	pointer
;	O
char	O
*	O
string	struct
;	O
for	O
(	O
bp	pointer
=	O
&	O
builtin_tab	array
[	O
0	int
]	O
;	O
bp	pointer
->	O
name	pointer
!=	O
NULL	O
;	O
bp	pointer
++	O
)	O
if	O
(	O
!	O
no_gnu_extensions	int
||	O
!	O
bp	pointer
->	O
gnu_extension	bool
)	O
{	O
if	O
(	O
prefix_all_builtins	int
)	O
{	O
string	struct
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
strlen	function
(	O
bp	pointer
->	O
name	pointer
)	O
+	O
4	int
)	O
;	O
strcpy	function
(	O
string	struct
,	O
"m4_"	pointer
)	O
;	O
strcat	function
(	O
string	struct
,	O
bp	pointer
->	O
name	pointer
)	O
;	O
define_builtin	function
(	O
string	struct
,	O
bp	pointer
,	O
SYMBOL_INSERT	int
)	O
;	O
free	function
(	O
string	struct
)	O
;	O
}	O
else	O
define_builtin	function
(	O
bp	pointer
->	O
name	pointer
,	O
bp	pointer
,	O
SYMBOL_INSERT	int
)	O
;	O
}	O
for	O
(	O
pp	pointer
=	O
&	O
predefined_tab	array
[	O
0	int
]	O
;	O
pp	pointer
->	O
func	pointer
!=	O
NULL	O
;	O
pp	pointer
++	O
)	O
if	O
(	O
no_gnu_extensions	int
)	O
{	O
if	O
(	O
pp	pointer
->	O
unix_name	pointer
!=	O
NULL	O
)	O
define_user_macro	function
(	O
pp	pointer
->	O
unix_name	pointer
,	O
pp	pointer
->	O
func	pointer
,	O
SYMBOL_INSERT	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
pp	pointer
->	O
gnu_name	pointer
!=	O
NULL	O
)	O
define_user_macro	function
(	O
pp	pointer
->	O
gnu_name	pointer
,	O
pp	pointer
->	O
func	pointer
,	O
SYMBOL_INSERT	int
)	O
;	O
}	O
}	O
static	O
bool	bool
bad_argc	function
(	O
token_data	struct
*	O
name	pointer
,	O
int	O
argc	int
,	O
int	O
min	int
,	O
int	O
max	int
)	O
{	O
bool	bool
isbad	bool
=	O
false	int
;	O
if	O
(	O
min	int
>	O
0	int
&&	O
argc	int
<	O
min	int
)	O
{	O
if	O
(	O
!	O
suppress_warnings	int
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"Warning: too few arguments to builtin `%s'"	pointer
,	O
TOKEN_DATA_TEXT	O
(	O
name	pointer
)	O
)	O
)	O
;	O
isbad	bool
=	O
true	int
;	O
}	O
else	O
if	O
(	O
max	int
>	O
0	int
&&	O
argc	int
>	O
max	int
&&	O
!	O
suppress_warnings	int
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"Warning: excess arguments to builtin `%s' ignored"	pointer
,	O
TOKEN_DATA_TEXT	O
(	O
name	pointer
)	O
)	O
)	O
;	O
return	O
isbad	bool
;	O
}	O
static	O
bool	bool
numeric_arg	function
(	O
token_data	struct
*	O
macro	pointer
,	O
const	O
char	O
*	O
arg	pointer
,	O
int	O
*	O
valuep	pointer
)	O
{	O
char	O
*	O
endp	pointer
;	O
if	O
(	O
*	O
arg	pointer
==	O
'\0'	O
)	O
{	O
*	O
valuep	pointer
=	O
0	int
;	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"empty string treated as 0 in builtin `%s'"	pointer
,	O
TOKEN_DATA_TEXT	O
(	O
macro	pointer
)	O
)	O
)	O
;	O
}	O
else	O
{	O
errno	O
=	O
0	int
;	O
*	O
valuep	pointer
=	O
strtol	function
(	O
arg	pointer
,	O
&	O
endp	pointer
,	O
10	int
)	O
;	O
if	O
(	O
*	O
endp	pointer
!=	O
'\0'	O
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"non-numeric argument to builtin `%s'"	pointer
,	O
TOKEN_DATA_TEXT	O
(	O
macro	pointer
)	O
)	O
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
isspace	function
(	O
to_uchar	O
(	O
*	O
arg	pointer
)	O
)	O
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"leading whitespace ignored in builtin `%s'"	pointer
,	O
TOKEN_DATA_TEXT	O
(	O
macro	pointer
)	O
)	O
)	O
;	O
else	O
if	O
(	O
errno	O
==	O
ERANGE	int
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"numeric overflow detected in builtin `%s'"	pointer
,	O
TOKEN_DATA_TEXT	O
(	O
macro	pointer
)	O
)	O
)	O
;	O
}	O
return	O
true	int
;	O
}	O
static	O
char	O
const	O
digits	array
[	O
]	O
=	O
"0123456789abcdefghijklmnopqrstuvwxyz"	pointer
;	O
const	O
char	O
*	O
ntoa	function
(	O
int32_t	int
value	bool
,	O
int	O
radix	int
)	O
{	O
bool	bool
negative	bool
;	O
uint32_t	int
uvalue	int
;	O
static	O
char	O
str	pointer
[	O
256	int
]	O
;	O
char	O
*	O
s	long
=	O
&	O
str	pointer
[	O
sizeof	O
str	pointer
]	O
;	O
*	O
--	O
s	long
=	O
'\0'	O
;	O
if	O
(	O
value	bool
<	O
0	int
)	O
{	O
negative	bool
=	O
true	int
;	O
uvalue	int
=	O
-	O
(	O
uint32_t	int
)	O
value	bool
;	O
}	O
else	O
{	O
negative	bool
=	O
false	int
;	O
uvalue	int
=	O
(	O
uint32_t	int
)	O
value	bool
;	O
}	O
do	O
{	O
*	O
--	O
s	long
=	O
digits	array
[	O
uvalue	int
%	O
radix	int
]	O
;	O
uvalue	int
/=	O
radix	int
;	O
}	O
while	O
(	O
uvalue	int
>	O
0	int
)	O
;	O
if	O
(	O
negative	bool
)	O
*	O
--	O
s	long
=	O
'-'	O
;	O
return	O
s	long
;	O
}	O
static	O
void	O
shipout_int	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
int	O
val	array
)	O
{	O
const	O
char	O
*	O
s	long
;	O
s	long
=	O
ntoa	function
(	O
(	O
int32_t	int
)	O
val	array
,	O
10	int
)	O
;	O
obstack_grow	O
(	O
obs	pointer
,	O
s	long
,	O
strlen	function
(	O
s	long
)	O
)	O
;	O
}	O
static	O
void	O
dump_args	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
,	O
const	O
char	O
*	O
sep	pointer
,	O
bool	bool
quoted	bool
)	O
{	O
int	O
i	int
;	O
size_t	long
len	long
=	O
strlen	function
(	O
sep	pointer
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
>	O
1	int
)	O
obstack_grow	O
(	O
obs	pointer
,	O
sep	pointer
,	O
len	long
)	O
;	O
if	O
(	O
quoted	bool
)	O
obstack_grow	O
(	O
obs	pointer
,	O
lquote	struct
.	O
string	struct
,	O
lquote	struct
.	O
length	long
)	O
;	O
obstack_grow	O
(	O
obs	pointer
,	O
TOKEN_DATA_TEXT	O
(	O
argv	pointer
[	O
i	int
]	O
)	O
,	O
strlen	function
(	O
TOKEN_DATA_TEXT	O
(	O
argv	pointer
[	O
i	int
]	O
)	O
)	O
)	O
;	O
if	O
(	O
quoted	bool
)	O
obstack_grow	O
(	O
obs	pointer
,	O
rquote	struct
.	O
string	struct
,	O
rquote	struct
.	O
length	long
)	O
;	O
}	O
}	O
static	O
void	O
define_macro	function
(	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
,	O
symbol_lookup	enum
mode	int
)	O
{	O
const	O
builtin	struct
*	O
bp	pointer
;	O
if	O
(	O
bad_argc	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
3	int
)	O
)	O
return	O
;	O
if	O
(	O
TOKEN_DATA_TYPE	O
(	O
argv	pointer
[	O
1	int
]	O
)	O
!=	O
TOKEN_TEXT	int
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"Warning: %s: invalid macro name ignored"	pointer
,	O
ARG	O
(	O
0	int
)	O
)	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
argc	int
==	O
2	int
)	O
{	O
define_user_macro	function
(	O
ARG	O
(	O
1	int
)	O
,	O
""	pointer
,	O
mode	int
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
TOKEN_DATA_TYPE	O
(	O
argv	pointer
[	O
2	int
]	O
)	O
)	O
{	O
case	O
TOKEN_TEXT	int
:	O
define_user_macro	function
(	O
ARG	O
(	O
1	int
)	O
,	O
ARG	O
(	O
2	int
)	O
,	O
mode	int
)	O
;	O
break	O
;	O
case	O
TOKEN_FUNC	int
:	O
bp	pointer
=	O
find_builtin_by_addr	function
(	O
TOKEN_DATA_FUNC	O
(	O
argv	pointer
[	O
2	int
]	O
)	O
)	O
;	O
if	O
(	O
bp	pointer
==	O
NULL	O
)	O
return	O
;	O
else	O
define_builtin	function
(	O
ARG	O
(	O
1	int
)	O
,	O
bp	pointer
,	O
mode	int
)	O
;	O
break	O
;	O
case	O
TOKEN_VOID	int
:	O
default	O
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: bad token data type in define_macro ()"	pointer
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
}	O
static	O
void	O
m4_define	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
M4_GNUC_UNUSED	O
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
define_macro	function
(	O
argc	int
,	O
argv	pointer
,	O
SYMBOL_INSERT	int
)	O
;	O
}	O
static	O
void	O
m4_undefine	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
M4_GNUC_UNUSED	O
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
int	O
i	int
;	O
if	O
(	O
bad_argc	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
-	O
1	int
)	O
)	O
return	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
lookup_symbol	function
(	O
ARG	O
(	O
i	int
)	O
,	O
SYMBOL_DELETE	int
)	O
;	O
}	O
static	O
void	O
m4_pushdef	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
M4_GNUC_UNUSED	O
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
define_macro	function
(	O
argc	int
,	O
argv	pointer
,	O
SYMBOL_PUSHDEF	int
)	O
;	O
}	O
static	O
void	O
m4_popdef	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
M4_GNUC_UNUSED	O
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
int	O
i	int
;	O
if	O
(	O
bad_argc	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
-	O
1	int
)	O
)	O
return	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
lookup_symbol	function
(	O
ARG	O
(	O
i	int
)	O
,	O
SYMBOL_POPDEF	int
)	O
;	O
}	O
static	O
void	O
m4_ifdef	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
symbol	struct
*	O
s	long
;	O
const	O
char	O
*	O
result	pointer
;	O
if	O
(	O
bad_argc	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
3	int
,	O
4	int
)	O
)	O
return	O
;	O
s	long
=	O
lookup_symbol	function
(	O
ARG	O
(	O
1	int
)	O
,	O
SYMBOL_LOOKUP	int
)	O
;	O
if	O
(	O
s	long
!=	O
NULL	O
&&	O
SYMBOL_TYPE	O
(	O
s	long
)	O
!=	O
TOKEN_VOID	int
)	O
result	pointer
=	O
ARG	O
(	O
2	int
)	O
;	O
else	O
if	O
(	O
argc	int
>=	O
4	int
)	O
result	pointer
=	O
ARG	O
(	O
3	int
)	O
;	O
else	O
result	pointer
=	O
NULL	O
;	O
if	O
(	O
result	pointer
!=	O
NULL	O
)	O
obstack_grow	O
(	O
obs	pointer
,	O
result	pointer
,	O
strlen	function
(	O
result	pointer
)	O
)	O
;	O
}	O
static	O
void	O
m4_ifelse	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
const	O
char	O
*	O
result	pointer
;	O
token_data	struct
*	O
me	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
if	O
(	O
argc	int
==	O
2	int
)	O
return	O
;	O
if	O
(	O
bad_argc	function
(	O
me	pointer
,	O
argc	int
,	O
4	int
,	O
-	O
1	int
)	O
)	O
return	O
;	O
else	O
bad_argc	function
(	O
me	pointer
,	O
(	O
argc	int
+	O
2	int
)	O
%	O
3	int
,	O
-	O
1	int
,	O
1	int
)	O
;	O
argv	pointer
++	O
;	O
argc	int
--	O
;	O
result	pointer
=	O
NULL	O
;	O
while	O
(	O
result	pointer
==	O
NULL	O
)	O
if	O
(	O
STREQ	O
(	O
ARG	O
(	O
0	int
)	O
,	O
ARG	O
(	O
1	int
)	O
)	O
)	O
result	pointer
=	O
ARG	O
(	O
2	int
)	O
;	O
else	O
switch	O
(	O
argc	int
)	O
{	O
case	O
3	int
:	O
return	O
;	O
case	O
4	int
:	O
case	O
5	int
:	O
result	pointer
=	O
ARG	O
(	O
3	int
)	O
;	O
break	O
;	O
default	O
:	O
argc	int
-=	O
3	int
;	O
argv	pointer
+=	O
3	int
;	O
}	O
obstack_grow	O
(	O
obs	pointer
,	O
result	pointer
,	O
strlen	function
(	O
result	pointer
)	O
)	O
;	O
}	O
struct	O
dump_symbol_data	struct
{	O
struct	O
obstack	struct
*	O
obs	pointer
;	O
symbol	struct
*	O
*	O
base	pointer
;	O
int	O
size	int
;	O
}	O
;	O
static	O
void	O
dump_symbol	function
(	O
symbol	struct
*	O
sym	pointer
,	O
void	O
*	O
arg	pointer
)	O
{	O
struct	O
dump_symbol_data	struct
*	O
data	struct
=	O
(	O
struct	O
dump_symbol_data	struct
*	O
)	O
arg	pointer
;	O
if	O
(	O
!	O
SYMBOL_SHADOWED	O
(	O
sym	pointer
)	O
&&	O
SYMBOL_TYPE	O
(	O
sym	pointer
)	O
!=	O
TOKEN_VOID	int
)	O
{	O
obstack_blank	O
(	O
data	struct
->	O
obs	pointer
,	O
sizeof	O
(	O
symbol	struct
*	O
)	O
)	O
;	O
data	struct
->	O
base	pointer
=	O
(	O
symbol	struct
*	O
*	O
)	O
obstack_base	O
(	O
data	struct
->	O
obs	pointer
)	O
;	O
data	struct
->	O
base	pointer
[	O
data	struct
->	O
size	int
++	O
]	O
=	O
sym	pointer
;	O
}	O
}	O
static	O
int	O
dumpdef_cmp	function
(	O
const	O
void	O
*	O
s1	pointer
,	O
const	O
void	O
*	O
s2	pointer
)	O
{	O
return	O
strcmp	function
(	O
SYMBOL_NAME	O
(	O
*	O
(	O
symbol	struct
*	O
const	O
*	O
)	O
s1	pointer
)	O
,	O
SYMBOL_NAME	O
(	O
*	O
(	O
symbol	struct
*	O
const	O
*	O
)	O
s2	pointer
)	O
)	O
;	O
}	O
static	O
void	O
m4_dumpdef	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
symbol	struct
*	O
s	long
;	O
int	O
i	int
;	O
struct	O
dump_symbol_data	struct
data	struct
;	O
const	O
builtin	struct
*	O
bp	pointer
;	O
data	struct
.	O
obs	pointer
=	O
obs	pointer
;	O
data	struct
.	O
base	pointer
=	O
(	O
symbol	struct
*	O
*	O
)	O
obstack_base	O
(	O
obs	pointer
)	O
;	O
data	struct
.	O
size	int
=	O
0	int
;	O
if	O
(	O
argc	int
==	O
1	int
)	O
{	O
hack_all_symbols	function
(	O
dump_symbol	function
,	O
&	O
data	struct
)	O
;	O
}	O
else	O
{	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
s	long
=	O
lookup_symbol	function
(	O
TOKEN_DATA_TEXT	O
(	O
argv	pointer
[	O
i	int
]	O
)	O
,	O
SYMBOL_LOOKUP	int
)	O
;	O
if	O
(	O
s	long
!=	O
NULL	O
&&	O
SYMBOL_TYPE	O
(	O
s	long
)	O
!=	O
TOKEN_VOID	int
)	O
dump_symbol	function
(	O
s	long
,	O
&	O
data	struct
)	O
;	O
else	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"undefined macro `%s'"	pointer
,	O
TOKEN_DATA_TEXT	O
(	O
argv	pointer
[	O
i	int
]	O
)	O
)	O
)	O
;	O
}	O
}	O
obstack_finish	O
(	O
obs	pointer
)	O
;	O
qsort	function
(	O
data	struct
.	O
base	pointer
,	O
data	struct
.	O
size	int
,	O
sizeof	O
(	O
symbol	struct
*	O
)	O
,	O
dumpdef_cmp	function
)	O
;	O
for	O
(	O
;	O
data	struct
.	O
size	int
>	O
0	int
;	O
--	O
data	struct
.	O
size	int
,	O
data	struct
.	O
base	pointer
++	O
)	O
{	O
DEBUG_PRINT1	O
(	O
"%s:\t"	pointer
,	O
SYMBOL_NAME	O
(	O
data	struct
.	O
base	pointer
[	O
0	int
]	O
)	O
)	O
;	O
switch	O
(	O
SYMBOL_TYPE	O
(	O
data	struct
.	O
base	pointer
[	O
0	int
]	O
)	O
)	O
{	O
case	O
TOKEN_TEXT	int
:	O
if	O
(	O
debug_level	int
&	O
DEBUG_TRACE_QUOTE	int
)	O
DEBUG_PRINT3	O
(	O
"%s%s%s\n"	pointer
,	O
lquote	struct
.	O
string	struct
,	O
SYMBOL_TEXT	O
(	O
data	struct
.	O
base	pointer
[	O
0	int
]	O
)	O
,	O
rquote	struct
.	O
string	struct
)	O
;	O
else	O
DEBUG_PRINT1	O
(	O
"%s\n"	pointer
,	O
SYMBOL_TEXT	O
(	O
data	struct
.	O
base	pointer
[	O
0	int
]	O
)	O
)	O
;	O
break	O
;	O
case	O
TOKEN_FUNC	int
:	O
bp	pointer
=	O
find_builtin_by_addr	function
(	O
SYMBOL_FUNC	O
(	O
data	struct
.	O
base	pointer
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
bp	pointer
==	O
NULL	O
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: builtin not found in builtin table"	pointer
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
DEBUG_PRINT1	O
(	O
"<%s>\n"	pointer
,	O
bp	pointer
->	O
name	pointer
)	O
;	O
break	O
;	O
case	O
TOKEN_VOID	int
:	O
default	O
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: bad token data type in m4_dumpdef ()"	pointer
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
break	O
;	O
}	O
}	O
}	O
static	O
void	O
m4_builtin	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
const	O
builtin	struct
*	O
bp	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
if	O
(	O
bad_argc	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
-	O
1	int
)	O
)	O
return	O
;	O
if	O
(	O
TOKEN_DATA_TYPE	O
(	O
argv	pointer
[	O
1	int
]	O
)	O
!=	O
TOKEN_TEXT	int
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"Warning: %s: invalid macro name ignored"	pointer
,	O
ARG	O
(	O
0	int
)	O
)	O
)	O
;	O
return	O
;	O
}	O
name	pointer
=	O
ARG	O
(	O
1	int
)	O
;	O
bp	pointer
=	O
find_builtin_by_name	function
(	O
name	pointer
)	O
;	O
if	O
(	O
bp	pointer
->	O
func	pointer
==	O
m4_placeholder	function
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"undefined builtin `%s'"	pointer
,	O
name	pointer
)	O
)	O
;	O
else	O
{	O
int	O
i	int
;	O
if	O
(	O
!	O
bp	pointer
->	O
groks_macro_args	bool
)	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
if	O
(	O
TOKEN_DATA_TYPE	O
(	O
argv	pointer
[	O
i	int
]	O
)	O
!=	O
TOKEN_TEXT	int
)	O
{	O
TOKEN_DATA_TYPE	O
(	O
argv	pointer
[	O
i	int
]	O
)	O
=	O
TOKEN_TEXT	int
;	O
TOKEN_DATA_TEXT	O
(	O
argv	pointer
[	O
i	int
]	O
)	O
=	O
(	O
char	O
*	O
)	O
""	pointer
;	O
}	O
bp	pointer
->	O
func	pointer
(	O
obs	pointer
,	O
argc	int
-	O
1	int
,	O
argv	pointer
+	O
1	int
)	O
;	O
}	O
}	O
static	O
void	O
m4_indir	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
symbol	struct
*	O
s	long
;	O
const	O
char	O
*	O
name	pointer
;	O
if	O
(	O
bad_argc	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
-	O
1	int
)	O
)	O
return	O
;	O
if	O
(	O
TOKEN_DATA_TYPE	O
(	O
argv	pointer
[	O
1	int
]	O
)	O
!=	O
TOKEN_TEXT	int
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"Warning: %s: invalid macro name ignored"	pointer
,	O
ARG	O
(	O
0	int
)	O
)	O
)	O
;	O
return	O
;	O
}	O
name	pointer
=	O
ARG	O
(	O
1	int
)	O
;	O
s	long
=	O
lookup_symbol	function
(	O
name	pointer
,	O
SYMBOL_LOOKUP	int
)	O
;	O
if	O
(	O
s	long
==	O
NULL	O
||	O
SYMBOL_TYPE	O
(	O
s	long
)	O
==	O
TOKEN_VOID	int
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"undefined macro `%s'"	pointer
,	O
name	pointer
)	O
)	O
;	O
else	O
{	O
int	O
i	int
;	O
if	O
(	O
!	O
SYMBOL_MACRO_ARGS	O
(	O
s	long
)	O
)	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
if	O
(	O
TOKEN_DATA_TYPE	O
(	O
argv	pointer
[	O
i	int
]	O
)	O
!=	O
TOKEN_TEXT	int
)	O
{	O
TOKEN_DATA_TYPE	O
(	O
argv	pointer
[	O
i	int
]	O
)	O
=	O
TOKEN_TEXT	int
;	O
TOKEN_DATA_TEXT	O
(	O
argv	pointer
[	O
i	int
]	O
)	O
=	O
(	O
char	O
*	O
)	O
""	pointer
;	O
}	O
call_macro	function
(	O
s	long
,	O
argc	int
-	O
1	int
,	O
argv	pointer
+	O
1	int
,	O
obs	pointer
)	O
;	O
}	O
}	O
static	O
void	O
m4_defn	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
symbol	struct
*	O
s	long
;	O
builtin_func	function
*	O
b	pointer
;	O
unsigned	O
int	O
i	int
;	O
if	O
(	O
bad_argc	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
-	O
1	int
)	O
)	O
return	O
;	O
assert	O
(	O
0	int
<	O
argc	int
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
(	O
unsigned	O
)	O
argc	int
;	O
i	int
++	O
)	O
{	O
const	O
char	O
*	O
arg	pointer
=	O
ARG	O
(	O
(	O
int	O
)	O
i	int
)	O
;	O
s	long
=	O
lookup_symbol	function
(	O
arg	pointer
,	O
SYMBOL_LOOKUP	int
)	O
;	O
if	O
(	O
s	long
==	O
NULL	O
)	O
continue	O
;	O
switch	O
(	O
SYMBOL_TYPE	O
(	O
s	long
)	O
)	O
{	O
case	O
TOKEN_TEXT	int
:	O
obstack_grow	O
(	O
obs	pointer
,	O
lquote	struct
.	O
string	struct
,	O
lquote	struct
.	O
length	long
)	O
;	O
obstack_grow	O
(	O
obs	pointer
,	O
SYMBOL_TEXT	O
(	O
s	long
)	O
,	O
strlen	function
(	O
SYMBOL_TEXT	O
(	O
s	long
)	O
)	O
)	O
;	O
obstack_grow	O
(	O
obs	pointer
,	O
rquote	struct
.	O
string	struct
,	O
rquote	struct
.	O
length	long
)	O
;	O
break	O
;	O
case	O
TOKEN_FUNC	int
:	O
b	pointer
=	O
SYMBOL_FUNC	O
(	O
s	long
)	O
;	O
if	O
(	O
b	pointer
==	O
m4_placeholder	function
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"builtin `%s' requested by frozen file is not supported"	pointer
,	O
arg	pointer
)	O
)	O
;	O
else	O
if	O
(	O
argc	int
!=	O
2	int
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"Warning: cannot concatenate builtin `%s'"	pointer
,	O
arg	pointer
)	O
)	O
;	O
else	O
push_macro	function
(	O
b	pointer
)	O
;	O
break	O
;	O
case	O
TOKEN_VOID	int
:	O
break	O
;	O
default	O
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: bad symbol type in m4_defn ()"	pointer
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
}	O
}	O
static	O
int	O
sysval	int
;	O
static	O
void	O
m4_syscmd	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
M4_GNUC_UNUSED	O
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
const	O
char	O
*	O
cmd	pointer
=	O
ARG	O
(	O
1	int
)	O
;	O
int	O
status	int
;	O
int	O
sig_status	int
;	O
const	O
char	O
*	O
prog_args	array
[	O
4	int
]	O
=	O
{	O
"sh"	pointer
,	O
"-c"	pointer
}	O
;	O
if	O
(	O
bad_argc	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
2	int
)	O
||	O
!	O
*	O
cmd	pointer
)	O
{	O
sysval	int
=	O
0	int
;	O
return	O
;	O
}	O
debug_flush_files	function
(	O
)	O
;	O
prog_args	array
[	O
2	int
]	O
=	O
cmd	pointer
;	O
errno	O
=	O
0	int
;	O
status	int
=	O
execute	function
(	O
ARG	O
(	O
0	int
)	O
,	O
SYSCMD_SHELL	pointer
,	O
(	O
char	O
*	O
*	O
)	O
prog_args	array
,	O
false	int
,	O
false	int
,	O
false	int
,	O
false	int
,	O
true	int
,	O
false	int
,	O
&	O
sig_status	int
)	O
;	O
if	O
(	O
sig_status	int
)	O
{	O
assert	O
(	O
status	int
==	O
127	int
)	O
;	O
sysval	int
=	O
sig_status	int
<<	O
8	int
;	O
}	O
else	O
{	O
if	O
(	O
status	int
==	O
127	int
&&	O
errno	O
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
errno	O
,	O
"cannot run command `%s'"	pointer
,	O
cmd	pointer
)	O
)	O
;	O
sysval	int
=	O
status	int
;	O
}	O
}	O
static	O
void	O
m4_esyscmd	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
const	O
char	O
*	O
cmd	pointer
=	O
ARG	O
(	O
1	int
)	O
;	O
const	O
char	O
*	O
prog_args	array
[	O
4	int
]	O
=	O
{	O
"sh"	pointer
,	O
"-c"	pointer
}	O
;	O
pid_t	int
child	int
;	O
int	O
fd	int
;	O
FILE	struct
*	O
pin	pointer
;	O
int	O
status	int
;	O
int	O
sig_status	int
;	O
if	O
(	O
bad_argc	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
2	int
)	O
||	O
!	O
*	O
cmd	pointer
)	O
{	O
sysval	int
=	O
0	int
;	O
return	O
;	O
}	O
debug_flush_files	function
(	O
)	O
;	O
prog_args	array
[	O
2	int
]	O
=	O
cmd	pointer
;	O
errno	O
=	O
0	int
;	O
child	int
=	O
create_pipe_in	function
(	O
ARG	O
(	O
0	int
)	O
,	O
SYSCMD_SHELL	pointer
,	O
(	O
char	O
*	O
*	O
)	O
prog_args	array
,	O
NULL	O
,	O
false	int
,	O
true	int
,	O
false	int
,	O
&	O
fd	int
)	O
;	O
if	O
(	O
child	int
==	O
-	O
1	int
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
errno	O
,	O
"cannot run command `%s'"	pointer
,	O
cmd	pointer
)	O
)	O
;	O
sysval	int
=	O
127	int
;	O
return	O
;	O
}	O
pin	pointer
=	O
fdopen	function
(	O
fd	int
,	O
"r"	pointer
)	O
;	O
if	O
(	O
pin	pointer
==	O
NULL	O
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
errno	O
,	O
"cannot run command `%s'"	pointer
,	O
cmd	pointer
)	O
)	O
;	O
sysval	int
=	O
127	int
;	O
close	pointer
(	O
fd	int
)	O
;	O
return	O
;	O
}	O
while	O
(	O
1	int
)	O
{	O
size_t	long
avail	long
=	O
obstack_room	O
(	O
obs	pointer
)	O
;	O
size_t	long
len	long
;	O
if	O
(	O
!	O
avail	long
)	O
{	O
int	O
ch	int
=	O
getc	function
(	O
pin	pointer
)	O
;	O
if	O
(	O
ch	int
==	O
EOF	O
)	O
break	O
;	O
obstack_1grow	O
(	O
obs	pointer
,	O
ch	int
)	O
;	O
continue	O
;	O
}	O
len	long
=	O
fread	function
(	O
obstack_next_free	O
(	O
obs	pointer
)	O
,	O
1	int
,	O
avail	long
,	O
pin	pointer
)	O
;	O
if	O
(	O
len	long
<=	O
0	int
)	O
break	O
;	O
obstack_blank_fast	O
(	O
obs	pointer
,	O
len	long
)	O
;	O
}	O
if	O
(	O
ferror	function
(	O
pin	pointer
)	O
||	O
fclose	function
(	O
pin	pointer
)	O
)	O
M4ERROR	O
(	O
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"cannot read pipe"	pointer
)	O
)	O
;	O
errno	O
=	O
0	int
;	O
status	int
=	O
wait_subprocess	function
(	O
child	int
,	O
ARG	O
(	O
0	int
)	O
,	O
false	int
,	O
true	int
,	O
true	int
,	O
false	int
,	O
&	O
sig_status	int
)	O
;	O
if	O
(	O
sig_status	int
)	O
{	O
assert	O
(	O
status	int
==	O
127	int
)	O
;	O
sysval	int
=	O
sig_status	int
<<	O
8	int
;	O
}	O
else	O
{	O
if	O
(	O
status	int
==	O
127	int
&&	O
errno	O
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
errno	O
,	O
"cannot run command `%s'"	pointer
,	O
cmd	pointer
)	O
)	O
;	O
sysval	int
=	O
status	int
;	O
}	O
}	O
static	O
void	O
m4_sysval	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
int	O
argc	int
M4_GNUC_UNUSED	O
,	O
token_data	struct
*	O
*	O
argv	pointer
M4_GNUC_UNUSED	O
)	O
{	O
shipout_int	function
(	O
obs	pointer
,	O
sysval	int
)	O
;	O
}	O
static	O
void	O
m4_eval	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
int32_t	int
value	bool
=	O
0	int
;	O
int	O
radix	int
=	O
10	int
;	O
int	O
min	int
=	O
1	int
;	O
const	O
char	O
*	O
s	long
;	O
if	O
(	O
bad_argc	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
4	int
)	O
)	O
return	O
;	O
if	O
(	O
*	O
ARG	O
(	O
2	int
)	O
&&	O
!	O
numeric_arg	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
ARG	O
(	O
2	int
)	O
,	O
&	O
radix	int
)	O
)	O
return	O
;	O
if	O
(	O
radix	int
<	O
1	int
||	O
radix	int
>	O
(	O
int	O
)	O
strlen	function
(	O
digits	array
)	O
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"radix %d in builtin `%s' out of range"	pointer
,	O
radix	int
,	O
ARG	O
(	O
0	int
)	O
)	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
argc	int
>=	O
4	int
&&	O
!	O
numeric_arg	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
ARG	O
(	O
3	int
)	O
,	O
&	O
min	int
)	O
)	O
return	O
;	O
if	O
(	O
min	int
<	O
0	int
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"negative width to builtin `%s'"	pointer
,	O
ARG	O
(	O
0	int
)	O
)	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
*	O
ARG	O
(	O
1	int
)	O
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"empty string treated as 0 in builtin `%s'"	pointer
,	O
ARG	O
(	O
0	int
)	O
)	O
)	O
;	O
else	O
if	O
(	O
evaluate	function
(	O
ARG	O
(	O
1	int
)	O
,	O
&	O
value	bool
)	O
)	O
return	O
;	O
if	O
(	O
radix	int
==	O
1	int
)	O
{	O
if	O
(	O
value	bool
<	O
0	int
)	O
{	O
obstack_1grow	O
(	O
obs	pointer
,	O
'-'	O
)	O
;	O
value	bool
=	O
-	O
value	bool
;	O
}	O
while	O
(	O
min	int
--	O
-	O
value	bool
>	O
0	int
)	O
obstack_1grow	O
(	O
obs	pointer
,	O
'0'	O
)	O
;	O
while	O
(	O
value	bool
--	O
!=	O
0	int
)	O
obstack_1grow	O
(	O
obs	pointer
,	O
'1'	O
)	O
;	O
obstack_1grow	O
(	O
obs	pointer
,	O
'\0'	O
)	O
;	O
return	O
;	O
}	O
s	long
=	O
ntoa	function
(	O
value	bool
,	O
radix	int
)	O
;	O
if	O
(	O
*	O
s	long
==	O
'-'	O
)	O
{	O
obstack_1grow	O
(	O
obs	pointer
,	O
'-'	O
)	O
;	O
s	long
++	O
;	O
}	O
for	O
(	O
min	int
-=	O
strlen	function
(	O
s	long
)	O
;	O
--	O
min	int
>=	O
0	int
;	O
)	O
obstack_1grow	O
(	O
obs	pointer
,	O
'0'	O
)	O
;	O
obstack_grow	O
(	O
obs	pointer
,	O
s	long
,	O
strlen	function
(	O
s	long
)	O
)	O
;	O
}	O
static	O
void	O
m4_incr	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
int	O
value	bool
;	O
if	O
(	O
bad_argc	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
2	int
)	O
)	O
return	O
;	O
if	O
(	O
!	O
numeric_arg	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
ARG	O
(	O
1	int
)	O
,	O
&	O
value	bool
)	O
)	O
return	O
;	O
shipout_int	function
(	O
obs	pointer
,	O
value	bool
+	O
1	int
)	O
;	O
}	O
static	O
void	O
m4_decr	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
int	O
value	bool
;	O
if	O
(	O
bad_argc	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
2	int
)	O
)	O
return	O
;	O
if	O
(	O
!	O
numeric_arg	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
ARG	O
(	O
1	int
)	O
,	O
&	O
value	bool
)	O
)	O
return	O
;	O
shipout_int	function
(	O
obs	pointer
,	O
value	bool
-	O
1	int
)	O
;	O
}	O
static	O
void	O
m4_divert	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
M4_GNUC_UNUSED	O
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
int	O
i	int
=	O
0	int
;	O
if	O
(	O
bad_argc	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
1	int
,	O
2	int
)	O
)	O
return	O
;	O
if	O
(	O
argc	int
>=	O
2	int
&&	O
!	O
numeric_arg	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
ARG	O
(	O
1	int
)	O
,	O
&	O
i	int
)	O
)	O
return	O
;	O
make_diversion	function
(	O
i	int
)	O
;	O
}	O
static	O
void	O
m4_divnum	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
if	O
(	O
bad_argc	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
1	int
,	O
1	int
)	O
)	O
return	O
;	O
shipout_int	function
(	O
obs	pointer
,	O
current_diversion	int
)	O
;	O
}	O
static	O
void	O
m4_undivert	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
M4_GNUC_UNUSED	O
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
int	O
i	int
,	O
file	pointer
;	O
FILE	struct
*	O
fp	pointer
;	O
char	O
*	O
endp	pointer
;	O
if	O
(	O
argc	int
==	O
1	int
)	O
undivert_all	function
(	O
)	O
;	O
else	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
file	pointer
=	O
strtol	function
(	O
ARG	O
(	O
i	int
)	O
,	O
&	O
endp	pointer
,	O
10	int
)	O
;	O
if	O
(	O
*	O
endp	pointer
==	O
'\0'	O
&&	O
!	O
isspace	function
(	O
to_uchar	O
(	O
*	O
ARG	O
(	O
i	int
)	O
)	O
)	O
)	O
insert_diversion	function
(	O
file	pointer
)	O
;	O
else	O
if	O
(	O
no_gnu_extensions	int
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"non-numeric argument to builtin `%s'"	pointer
,	O
ARG	O
(	O
0	int
)	O
)	O
)	O
;	O
else	O
{	O
fp	pointer
=	O
m4_path_search	function
(	O
ARG	O
(	O
i	int
)	O
,	O
NULL	O
)	O
;	O
if	O
(	O
fp	pointer
!=	O
NULL	O
)	O
{	O
insert_file	function
(	O
fp	pointer
)	O
;	O
if	O
(	O
fclose	function
(	O
fp	pointer
)	O
==	O
EOF	O
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
errno	O
,	O
"error undiverting `%s'"	pointer
,	O
ARG	O
(	O
i	int
)	O
)	O
)	O
;	O
}	O
else	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
errno	O
,	O
"cannot undivert `%s'"	pointer
,	O
ARG	O
(	O
i	int
)	O
)	O
)	O
;	O
}	O
}	O
}	O
static	O
void	O
m4_dnl	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
M4_GNUC_UNUSED	O
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
if	O
(	O
bad_argc	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
1	int
,	O
1	int
)	O
)	O
return	O
;	O
skip_line	function
(	O
)	O
;	O
}	O
static	O
void	O
m4_shift	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
if	O
(	O
bad_argc	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
-	O
1	int
)	O
)	O
return	O
;	O
dump_args	function
(	O
obs	pointer
,	O
argc	int
-	O
1	int
,	O
argv	pointer
+	O
1	int
,	O
","	pointer
,	O
true	int
)	O
;	O
}	O
static	O
void	O
m4_changequote	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
M4_GNUC_UNUSED	O
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
if	O
(	O
bad_argc	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
1	int
,	O
3	int
)	O
)	O
return	O
;	O
set_quotes	function
(	O
(	O
argc	int
>=	O
2	int
)	O
?	O
TOKEN_DATA_TEXT	O
(	O
argv	pointer
[	O
1	int
]	O
)	O
:	O
NULL	O
,	O
(	O
argc	int
>=	O
3	int
)	O
?	O
TOKEN_DATA_TEXT	O
(	O
argv	pointer
[	O
2	int
]	O
)	O
:	O
NULL	O
)	O
;	O
}	O
static	O
void	O
m4_changecom	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
M4_GNUC_UNUSED	O
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
if	O
(	O
bad_argc	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
1	int
,	O
3	int
)	O
)	O
return	O
;	O
set_comment	function
(	O
(	O
argc	int
>=	O
2	int
)	O
?	O
TOKEN_DATA_TEXT	O
(	O
argv	pointer
[	O
1	int
]	O
)	O
:	O
NULL	O
,	O
(	O
argc	int
>=	O
3	int
)	O
?	O
TOKEN_DATA_TEXT	O
(	O
argv	pointer
[	O
2	int
]	O
)	O
:	O
NULL	O
)	O
;	O
}	O
static	O
void	O
include	function
(	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
,	O
bool	bool
silent	bool
)	O
{	O
FILE	struct
*	O
fp	pointer
;	O
char	O
*	O
name	pointer
;	O
if	O
(	O
bad_argc	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
2	int
)	O
)	O
return	O
;	O
fp	pointer
=	O
m4_path_search	function
(	O
ARG	O
(	O
1	int
)	O
,	O
&	O
name	pointer
)	O
;	O
if	O
(	O
fp	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
!	O
silent	bool
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
errno	O
,	O
"cannot open `%s'"	pointer
,	O
ARG	O
(	O
1	int
)	O
)	O
)	O
;	O
retcode	int
=	O
EXIT_FAILURE	int
;	O
}	O
return	O
;	O
}	O
push_file	function
(	O
fp	pointer
,	O
name	pointer
,	O
true	int
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
}	O
static	O
void	O
m4_include	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
M4_GNUC_UNUSED	O
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
include	function
(	O
argc	int
,	O
argv	pointer
,	O
false	int
)	O
;	O
}	O
static	O
void	O
m4_sinclude	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
M4_GNUC_UNUSED	O
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
include	function
(	O
argc	int
,	O
argv	pointer
,	O
true	int
)	O
;	O
}	O
static	O
void	O
mkstemp_helper	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
const	O
char	O
*	O
me	pointer
,	O
const	O
char	O
*	O
pattern	pointer
,	O
size_t	long
len	long
)	O
{	O
int	O
fd	int
;	O
size_t	long
i	int
;	O
char	O
*	O
name	pointer
;	O
obstack_grow	O
(	O
obs	pointer
,	O
lquote	struct
.	O
string	struct
,	O
lquote	struct
.	O
length	long
)	O
;	O
obstack_grow	O
(	O
obs	pointer
,	O
pattern	pointer
,	O
len	long
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
len	long
>	O
0	int
&&	O
i	int
<	O
6	int
;	O
i	int
++	O
)	O
if	O
(	O
pattern	pointer
[	O
len	long
-	O
i	int
-	O
1	int
]	O
!=	O
'X'	O
)	O
break	O
;	O
obstack_grow0	O
(	O
obs	pointer
,	O
"XXXXXX"	pointer
,	O
6	int
-	O
i	int
)	O
;	O
name	pointer
=	O
(	O
char	O
*	O
)	O
obstack_base	O
(	O
obs	pointer
)	O
+	O
lquote	struct
.	O
length	long
;	O
errno	O
=	O
0	int
;	O
fd	int
=	O
mkstemp	function
(	O
name	pointer
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
{	O
M4ERROR	O
(	O
(	O
0	int
,	O
errno	O
,	O
"%s: cannot create tempfile `%s'"	pointer
,	O
me	pointer
,	O
pattern	pointer
)	O
)	O
;	O
obstack_free	function
(	O
obs	pointer
,	O
obstack_finish	O
(	O
obs	pointer
)	O
)	O
;	O
}	O
else	O
{	O
close	pointer
(	O
fd	int
)	O
;	O
obstack_blank	O
(	O
obs	pointer
,	O
-	O
1	int
)	O
;	O
obstack_grow	O
(	O
obs	pointer
,	O
rquote	struct
.	O
string	struct
,	O
rquote	struct
.	O
length	long
)	O
;	O
}	O
}	O
static	O
void	O
m4_maketemp	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
if	O
(	O
bad_argc	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
2	int
)	O
)	O
return	O
;	O
if	O
(	O
no_gnu_extensions	int
)	O
{	O
const	O
char	O
*	O
str	pointer
=	O
ARG	O
(	O
1	int
)	O
;	O
int	O
len	long
=	O
strlen	function
(	O
str	pointer
)	O
;	O
int	O
i	int
;	O
int	O
len2	int
;	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"recommend using mkstemp instead"	pointer
)	O
)	O
;	O
for	O
(	O
i	int
=	O
len	long
;	O
i	int
>	O
1	int
;	O
i	int
--	O
)	O
if	O
(	O
str	pointer
[	O
i	int
-	O
1	int
]	O
!=	O
'X'	O
)	O
break	O
;	O
obstack_grow	O
(	O
obs	pointer
,	O
str	pointer
,	O
i	int
)	O
;	O
str	pointer
=	O
ntoa	function
(	O
(	O
int32_t	int
)	O
getpid	function
(	O
)	O
,	O
10	int
)	O
;	O
len2	int
=	O
strlen	function
(	O
str	pointer
)	O
;	O
if	O
(	O
len2	int
>	O
len	long
-	O
i	int
)	O
obstack_grow0	O
(	O
obs	pointer
,	O
str	pointer
+	O
len2	int
-	O
(	O
len	long
-	O
i	int
)	O
,	O
len	long
-	O
i	int
)	O
;	O
else	O
{	O
while	O
(	O
i	int
++	O
<	O
len	long
-	O
len2	int
)	O
obstack_1grow	O
(	O
obs	pointer
,	O
'0'	O
)	O
;	O
obstack_grow0	O
(	O
obs	pointer
,	O
str	pointer
,	O
len2	int
)	O
;	O
}	O
}	O
else	O
mkstemp_helper	function
(	O
obs	pointer
,	O
ARG	O
(	O
0	int
)	O
,	O
ARG	O
(	O
1	int
)	O
,	O
strlen	function
(	O
ARG	O
(	O
1	int
)	O
)	O
)	O
;	O
}	O
static	O
void	O
m4_mkstemp	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
if	O
(	O
bad_argc	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
2	int
)	O
)	O
return	O
;	O
mkstemp_helper	function
(	O
obs	pointer
,	O
ARG	O
(	O
0	int
)	O
,	O
ARG	O
(	O
1	int
)	O
,	O
strlen	function
(	O
ARG	O
(	O
1	int
)	O
)	O
)	O
;	O
}	O
static	O
void	O
m4_errprint	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
if	O
(	O
bad_argc	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
-	O
1	int
)	O
)	O
return	O
;	O
dump_args	function
(	O
obs	pointer
,	O
argc	int
,	O
argv	pointer
,	O
" "	pointer
,	O
false	int
)	O
;	O
obstack_1grow	O
(	O
obs	pointer
,	O
'\0'	O
)	O
;	O
debug_flush_files	function
(	O
)	O
;	O
xfprintf	function
(	O
stderr	pointer
,	O
"%s"	pointer
,	O
(	O
char	O
*	O
)	O
obstack_finish	O
(	O
obs	pointer
)	O
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
}	O
static	O
void	O
m4___file__	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
if	O
(	O
bad_argc	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
1	int
,	O
1	int
)	O
)	O
return	O
;	O
obstack_grow	O
(	O
obs	pointer
,	O
lquote	struct
.	O
string	struct
,	O
lquote	struct
.	O
length	long
)	O
;	O
obstack_grow	O
(	O
obs	pointer
,	O
current_file	pointer
,	O
strlen	function
(	O
current_file	pointer
)	O
)	O
;	O
obstack_grow	O
(	O
obs	pointer
,	O
rquote	struct
.	O
string	struct
,	O
rquote	struct
.	O
length	long
)	O
;	O
}	O
static	O
void	O
m4___line__	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
if	O
(	O
bad_argc	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
1	int
,	O
1	int
)	O
)	O
return	O
;	O
shipout_int	function
(	O
obs	pointer
,	O
current_line	int
)	O
;	O
}	O
static	O
void	O
m4___program__	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
if	O
(	O
bad_argc	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
1	int
,	O
1	int
)	O
)	O
return	O
;	O
obstack_grow	O
(	O
obs	pointer
,	O
lquote	struct
.	O
string	struct
,	O
lquote	struct
.	O
length	long
)	O
;	O
obstack_grow	O
(	O
obs	pointer
,	O
program_name	pointer
,	O
strlen	function
(	O
program_name	pointer
)	O
)	O
;	O
obstack_grow	O
(	O
obs	pointer
,	O
rquote	struct
.	O
string	struct
,	O
rquote	struct
.	O
length	long
)	O
;	O
}	O
static	O
void	O
M4_GNUC_NORETURN	O
m4_m4exit	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
M4_GNUC_UNUSED	O
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
int	O
exit_code	int
=	O
EXIT_SUCCESS	int
;	O
bad_argc	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
1	int
,	O
2	int
)	O
;	O
if	O
(	O
argc	int
>=	O
2	int
&&	O
!	O
numeric_arg	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
ARG	O
(	O
1	int
)	O
,	O
&	O
exit_code	int
)	O
)	O
exit_code	int
=	O
EXIT_FAILURE	int
;	O
if	O
(	O
exit_code	int
<	O
0	int
||	O
exit_code	int
>	O
255	int
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"exit status out of range: `%d'"	pointer
,	O
exit_code	int
)	O
)	O
;	O
exit_code	int
=	O
EXIT_FAILURE	int
;	O
}	O
debug_set_output	function
(	O
NULL	O
)	O
;	O
debug_flush_files	function
(	O
)	O
;	O
if	O
(	O
exit_code	int
==	O
EXIT_SUCCESS	int
&&	O
retcode	int
!=	O
EXIT_SUCCESS	int
)	O
exit_code	int
=	O
retcode	int
;	O
if	O
(	O
exit_code	int
!=	O
EXIT_SUCCESS	int
)	O
exit_failure	int
=	O
exit_code	int
;	O
exit	function
(	O
exit_code	int
)	O
;	O
}	O
static	O
void	O
m4_m4wrap	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
if	O
(	O
bad_argc	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
-	O
1	int
)	O
)	O
return	O
;	O
if	O
(	O
no_gnu_extensions	int
)	O
obstack_grow	O
(	O
obs	pointer
,	O
ARG	O
(	O
1	int
)	O
,	O
strlen	function
(	O
ARG	O
(	O
1	int
)	O
)	O
)	O
;	O
else	O
dump_args	function
(	O
obs	pointer
,	O
argc	int
,	O
argv	pointer
,	O
" "	pointer
,	O
false	int
)	O
;	O
obstack_1grow	O
(	O
obs	pointer
,	O
'\0'	O
)	O
;	O
push_wrapup	function
(	O
(	O
char	O
*	O
)	O
obstack_finish	O
(	O
obs	pointer
)	O
)	O
;	O
}	O
static	O
void	O
set_trace	function
(	O
symbol	struct
*	O
sym	pointer
,	O
void	O
*	O
data	struct
)	O
{	O
SYMBOL_TRACED	O
(	O
sym	pointer
)	O
=	O
data	struct
!=	O
NULL	O
;	O
if	O
(	O
SYMBOL_TYPE	O
(	O
sym	pointer
)	O
==	O
TOKEN_VOID	int
&&	O
data	struct
==	O
NULL	O
)	O
lookup_symbol	function
(	O
SYMBOL_NAME	O
(	O
sym	pointer
)	O
,	O
SYMBOL_POPDEF	int
)	O
;	O
}	O
static	O
void	O
m4_traceon	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
symbol	struct
*	O
s	long
;	O
int	O
i	int
;	O
if	O
(	O
argc	int
==	O
1	int
)	O
hack_all_symbols	function
(	O
set_trace	function
,	O
obs	pointer
)	O
;	O
else	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
s	long
=	O
lookup_symbol	function
(	O
ARG	O
(	O
i	int
)	O
,	O
SYMBOL_LOOKUP	int
)	O
;	O
if	O
(	O
!	O
s	long
)	O
s	long
=	O
lookup_symbol	function
(	O
ARG	O
(	O
i	int
)	O
,	O
SYMBOL_INSERT	int
)	O
;	O
set_trace	function
(	O
s	long
,	O
obs	pointer
)	O
;	O
}	O
}	O
static	O
void	O
m4_traceoff	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
M4_GNUC_UNUSED	O
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
symbol	struct
*	O
s	long
;	O
int	O
i	int
;	O
if	O
(	O
argc	int
==	O
1	int
)	O
hack_all_symbols	function
(	O
set_trace	function
,	O
NULL	O
)	O
;	O
else	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
s	long
=	O
lookup_symbol	function
(	O
TOKEN_DATA_TEXT	O
(	O
argv	pointer
[	O
i	int
]	O
)	O
,	O
SYMBOL_LOOKUP	int
)	O
;	O
if	O
(	O
s	long
!=	O
NULL	O
)	O
set_trace	function
(	O
s	long
,	O
NULL	O
)	O
;	O
}	O
}	O
static	O
void	O
m4_debugmode	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
M4_GNUC_UNUSED	O
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
int	O
new_debug_level	int
;	O
int	O
change_flag	int
;	O
if	O
(	O
bad_argc	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
1	int
,	O
2	int
)	O
)	O
return	O
;	O
if	O
(	O
argc	int
==	O
1	int
)	O
debug_level	int
=	O
0	int
;	O
else	O
{	O
if	O
(	O
ARG	O
(	O
1	int
)	O
[	O
0	int
]	O
==	O
'+'	O
||	O
ARG	O
(	O
1	int
)	O
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
change_flag	int
=	O
ARG	O
(	O
1	int
)	O
[	O
0	int
]	O
;	O
new_debug_level	int
=	O
debug_decode	function
(	O
ARG	O
(	O
1	int
)	O
+	O
1	int
)	O
;	O
}	O
else	O
{	O
change_flag	int
=	O
0	int
;	O
new_debug_level	int
=	O
debug_decode	function
(	O
ARG	O
(	O
1	int
)	O
)	O
;	O
}	O
if	O
(	O
new_debug_level	int
<	O
0	int
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"Debugmode: bad debug flags: `%s'"	pointer
,	O
ARG	O
(	O
1	int
)	O
)	O
)	O
;	O
else	O
{	O
switch	O
(	O
change_flag	int
)	O
{	O
case	O
0	int
:	O
debug_level	int
=	O
new_debug_level	int
;	O
break	O
;	O
case	O
'+'	O
:	O
debug_level	int
|=	O
new_debug_level	int
;	O
break	O
;	O
case	O
'-'	O
:	O
debug_level	int
&=	O
~	O
new_debug_level	int
;	O
break	O
;	O
default	O
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: bad flag in m4_debugmode ()"	pointer
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
m4_debugfile	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
M4_GNUC_UNUSED	O
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
if	O
(	O
bad_argc	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
1	int
,	O
2	int
)	O
)	O
return	O
;	O
if	O
(	O
argc	int
==	O
1	int
)	O
debug_set_output	function
(	O
NULL	O
)	O
;	O
else	O
if	O
(	O
!	O
debug_set_output	function
(	O
ARG	O
(	O
1	int
)	O
)	O
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
errno	O
,	O
"cannot set debug file `%s'"	pointer
,	O
ARG	O
(	O
1	int
)	O
)	O
)	O
;	O
}	O
static	O
void	O
m4_len	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
if	O
(	O
bad_argc	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
2	int
)	O
)	O
return	O
;	O
shipout_int	function
(	O
obs	pointer
,	O
strlen	function
(	O
ARG	O
(	O
1	int
)	O
)	O
)	O
;	O
}	O
static	O
void	O
m4_index	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
const	O
char	O
*	O
haystack	pointer
;	O
const	O
char	O
*	O
result	pointer
;	O
int	O
retval	int
;	O
if	O
(	O
bad_argc	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
3	int
,	O
3	int
)	O
)	O
{	O
if	O
(	O
argc	int
==	O
2	int
)	O
shipout_int	function
(	O
obs	pointer
,	O
0	int
)	O
;	O
return	O
;	O
}	O
haystack	pointer
=	O
ARG	O
(	O
1	int
)	O
;	O
result	pointer
=	O
strstr	function
(	O
haystack	pointer
,	O
ARG	O
(	O
2	int
)	O
)	O
;	O
retval	int
=	O
result	pointer
?	O
result	pointer
-	O
haystack	pointer
:	O
-	O
1	int
;	O
shipout_int	function
(	O
obs	pointer
,	O
retval	int
)	O
;	O
}	O
static	O
void	O
m4_substr	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
int	O
start	pointer
=	O
0	int
;	O
int	O
length	long
,	O
avail	long
;	O
if	O
(	O
bad_argc	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
3	int
,	O
4	int
)	O
)	O
{	O
if	O
(	O
argc	int
==	O
2	int
)	O
obstack_grow	O
(	O
obs	pointer
,	O
ARG	O
(	O
1	int
)	O
,	O
strlen	function
(	O
ARG	O
(	O
1	int
)	O
)	O
)	O
;	O
return	O
;	O
}	O
length	long
=	O
avail	long
=	O
strlen	function
(	O
ARG	O
(	O
1	int
)	O
)	O
;	O
if	O
(	O
!	O
numeric_arg	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
ARG	O
(	O
2	int
)	O
,	O
&	O
start	pointer
)	O
)	O
return	O
;	O
if	O
(	O
argc	int
>=	O
4	int
&&	O
!	O
numeric_arg	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
ARG	O
(	O
3	int
)	O
,	O
&	O
length	long
)	O
)	O
return	O
;	O
if	O
(	O
start	pointer
<	O
0	int
||	O
length	long
<=	O
0	int
||	O
start	pointer
>=	O
avail	long
)	O
return	O
;	O
if	O
(	O
start	pointer
+	O
length	long
>	O
avail	long
)	O
length	long
=	O
avail	long
-	O
start	pointer
;	O
obstack_grow	O
(	O
obs	pointer
,	O
ARG	O
(	O
1	int
)	O
+	O
start	pointer
,	O
length	long
)	O
;	O
}	O
static	O
const	O
char	O
*	O
expand_ranges	function
(	O
const	O
char	O
*	O
s	long
,	O
struct	O
obstack	struct
*	O
obs	pointer
)	O
{	O
unsigned	O
char	O
from	char
;	O
unsigned	O
char	O
to	char
;	O
for	O
(	O
from	char
=	O
'\0'	O
;	O
*	O
s	long
!=	O
'\0'	O
;	O
from	char
=	O
to_uchar	O
(	O
*	O
s	long
++	O
)	O
)	O
{	O
if	O
(	O
*	O
s	long
==	O
'-'	O
&&	O
from	char
!=	O
'\0'	O
)	O
{	O
to	char
=	O
to_uchar	O
(	O
*	O
++	O
s	long
)	O
;	O
if	O
(	O
to	char
==	O
'\0'	O
)	O
{	O
obstack_1grow	O
(	O
obs	pointer
,	O
'-'	O
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
from	char
<=	O
to	char
)	O
{	O
while	O
(	O
from	char
++	O
<	O
to	char
)	O
obstack_1grow	O
(	O
obs	pointer
,	O
from	char
)	O
;	O
}	O
else	O
{	O
while	O
(	O
--	O
from	char
>=	O
to	char
)	O
obstack_1grow	O
(	O
obs	pointer
,	O
from	char
)	O
;	O
}	O
}	O
else	O
obstack_1grow	O
(	O
obs	pointer
,	O
*	O
s	long
)	O
;	O
}	O
obstack_1grow	O
(	O
obs	pointer
,	O
'\0'	O
)	O
;	O
return	O
(	O
char	O
*	O
)	O
obstack_finish	O
(	O
obs	pointer
)	O
;	O
}	O
static	O
void	O
m4_translit	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
const	O
char	O
*	O
data	struct
=	O
ARG	O
(	O
1	int
)	O
;	O
const	O
char	O
*	O
from	char
=	O
ARG	O
(	O
2	int
)	O
;	O
const	O
char	O
*	O
to	char
;	O
char	O
map	array
[	O
UCHAR_MAX	O
+	O
1	int
]	O
;	O
char	O
found	array
[	O
UCHAR_MAX	O
+	O
1	int
]	O
;	O
unsigned	O
char	O
ch	int
;	O
if	O
(	O
bad_argc	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
3	int
,	O
4	int
)	O
||	O
!	O
*	O
data	struct
||	O
!	O
*	O
from	char
)	O
{	O
if	O
(	O
2	int
<=	O
argc	int
)	O
obstack_grow	O
(	O
obs	pointer
,	O
data	struct
,	O
strlen	function
(	O
data	struct
)	O
)	O
;	O
return	O
;	O
}	O
to	char
=	O
ARG	O
(	O
3	int
)	O
;	O
if	O
(	O
strchr	function
(	O
to	char
,	O
'-'	O
)	O
!=	O
NULL	O
)	O
{	O
to	char
=	O
expand_ranges	function
(	O
to	char
,	O
obs	pointer
)	O
;	O
assert	O
(	O
to	char
&&	O
*	O
to	char
)	O
;	O
}	O
if	O
(	O
!	O
from	char
[	O
1	int
]	O
||	O
!	O
from	char
[	O
2	int
]	O
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
size_t	long
len	long
=	O
strlen	function
(	O
data	struct
)	O
;	O
while	O
(	O
(	O
p	pointer
=	O
(	O
char	O
*	O
)	O
memchr2	function
(	O
data	struct
,	O
from	char
[	O
0	int
]	O
,	O
from	char
[	O
1	int
]	O
,	O
len	long
)	O
)	O
)	O
{	O
obstack_grow	O
(	O
obs	pointer
,	O
data	struct
,	O
p	pointer
-	O
data	struct
)	O
;	O
len	long
-=	O
p	pointer
-	O
data	struct
;	O
if	O
(	O
!	O
len	long
)	O
return	O
;	O
data	struct
=	O
p	pointer
+	O
1	int
;	O
len	long
--	O
;	O
if	O
(	O
*	O
p	pointer
==	O
from	char
[	O
0	int
]	O
&&	O
to	char
[	O
0	int
]	O
)	O
obstack_1grow	O
(	O
obs	pointer
,	O
to	char
[	O
0	int
]	O
)	O
;	O
else	O
if	O
(	O
*	O
p	pointer
==	O
from	char
[	O
1	int
]	O
&&	O
to	char
[	O
0	int
]	O
&&	O
to	char
[	O
1	int
]	O
)	O
obstack_1grow	O
(	O
obs	pointer
,	O
to	char
[	O
1	int
]	O
)	O
;	O
}	O
obstack_grow	O
(	O
obs	pointer
,	O
data	struct
,	O
len	long
)	O
;	O
return	O
;	O
}	O
if	O
(	O
strchr	function
(	O
from	char
,	O
'-'	O
)	O
!=	O
NULL	O
)	O
{	O
from	char
=	O
expand_ranges	function
(	O
from	char
,	O
obs	pointer
)	O
;	O
assert	O
(	O
from	char
&&	O
*	O
from	char
)	O
;	O
}	O
memset	function
(	O
map	array
,	O
0	int
,	O
sizeof	O
map	array
)	O
;	O
memset	function
(	O
found	array
,	O
0	int
,	O
sizeof	O
found	array
)	O
;	O
for	O
(	O
;	O
(	O
ch	int
=	O
*	O
from	char
)	O
!=	O
'\0'	O
;	O
from	char
++	O
)	O
{	O
if	O
(	O
!	O
found	array
[	O
ch	int
]	O
)	O
{	O
found	array
[	O
ch	int
]	O
=	O
1	int
;	O
map	array
[	O
ch	int
]	O
=	O
*	O
to	char
;	O
}	O
if	O
(	O
*	O
to	char
!=	O
'\0'	O
)	O
to	char
++	O
;	O
}	O
for	O
(	O
data	struct
=	O
ARG	O
(	O
1	int
)	O
;	O
(	O
ch	int
=	O
*	O
data	struct
)	O
!=	O
'\0'	O
;	O
data	struct
++	O
)	O
{	O
if	O
(	O
!	O
found	array
[	O
ch	int
]	O
)	O
obstack_1grow	O
(	O
obs	pointer
,	O
ch	int
)	O
;	O
else	O
if	O
(	O
map	array
[	O
ch	int
]	O
)	O
obstack_1grow	O
(	O
obs	pointer
,	O
map	array
[	O
ch	int
]	O
)	O
;	O
}	O
}	O
static	O
void	O
m4_format	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
if	O
(	O
bad_argc	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
2	int
,	O
-	O
1	int
)	O
)	O
return	O
;	O
expand_format	function
(	O
obs	pointer
,	O
argc	int
-	O
1	int
,	O
argv	pointer
+	O
1	int
)	O
;	O
}	O
static	O
int	O
substitute_warned	int
=	O
0	int
;	O
static	O
void	O
substitute	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
const	O
char	O
*	O
victim	pointer
,	O
const	O
char	O
*	O
repl	pointer
,	O
struct	O
re_registers	struct
*	O
regs	pointer
)	O
{	O
int	O
ch	int
;	O
__re_size_t	int
ind	int
;	O
while	O
(	O
1	int
)	O
{	O
const	O
char	O
*	O
backslash	pointer
=	O
strchr	function
(	O
repl	pointer
,	O
'\\'	O
)	O
;	O
if	O
(	O
!	O
backslash	pointer
)	O
{	O
obstack_grow	O
(	O
obs	pointer
,	O
repl	pointer
,	O
strlen	function
(	O
repl	pointer
)	O
)	O
;	O
return	O
;	O
}	O
obstack_grow	O
(	O
obs	pointer
,	O
repl	pointer
,	O
backslash	pointer
-	O
repl	pointer
)	O
;	O
repl	pointer
=	O
backslash	pointer
;	O
ch	int
=	O
*	O
++	O
repl	pointer
;	O
switch	O
(	O
ch	int
)	O
{	O
case	O
'0'	O
:	O
if	O
(	O
!	O
substitute_warned	int
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"Warning: \\0 will disappear, use \\& instead in replacements"	pointer
)	O
)	O
;	O
substitute_warned	int
=	O
1	int
;	O
}	O
case	O
'&'	O
:	O
obstack_grow	O
(	O
obs	pointer
,	O
victim	pointer
+	O
regs	pointer
->	O
start	pointer
[	O
0	int
]	O
,	O
regs	pointer
->	O
end	pointer
[	O
0	int
]	O
-	O
regs	pointer
->	O
start	pointer
[	O
0	int
]	O
)	O
;	O
repl	pointer
++	O
;	O
break	O
;	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
ind	int
=	O
ch	int
-=	O
'0'	O
;	O
if	O
(	O
regs	pointer
->	O
num_regs	int
-	O
1	int
<=	O
ind	int
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"Warning: sub-expression %d not present"	pointer
,	O
ch	int
)	O
)	O
;	O
else	O
if	O
(	O
regs	pointer
->	O
end	pointer
[	O
ch	int
]	O
>	O
0	int
)	O
obstack_grow	O
(	O
obs	pointer
,	O
victim	pointer
+	O
regs	pointer
->	O
start	pointer
[	O
ch	int
]	O
,	O
regs	pointer
->	O
end	pointer
[	O
ch	int
]	O
-	O
regs	pointer
->	O
start	pointer
[	O
ch	int
]	O
)	O
;	O
repl	pointer
++	O
;	O
break	O
;	O
case	O
'\0'	O
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"Warning: trailing \\ ignored in replacement"	pointer
)	O
)	O
;	O
return	O
;	O
default	O
:	O
obstack_1grow	O
(	O
obs	pointer
,	O
ch	int
)	O
;	O
repl	pointer
++	O
;	O
break	O
;	O
}	O
}	O
}	O
void	O
init_pattern_buffer	function
(	O
struct	O
re_pattern_buffer	struct
*	O
buf	pointer
,	O
struct	O
re_registers	struct
*	O
regs	pointer
)	O
{	O
buf	pointer
->	O
translate	pointer
=	O
NULL	O
;	O
buf	pointer
->	O
fastmap	pointer
=	O
NULL	O
;	O
buf	pointer
->	O
buffer	pointer
=	O
NULL	O
;	O
buf	pointer
->	O
allocated	long
=	O
0	int
;	O
if	O
(	O
regs	pointer
)	O
{	O
regs	pointer
->	O
start	pointer
=	O
NULL	O
;	O
regs	pointer
->	O
end	pointer
=	O
NULL	O
;	O
}	O
}	O
static	O
void	O
m4_regexp	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
const	O
char	O
*	O
victim	pointer
;	O
const	O
char	O
*	O
regexp	pointer
;	O
const	O
char	O
*	O
repl	pointer
;	O
struct	O
re_pattern_buffer	struct
buf	pointer
;	O
struct	O
re_registers	struct
regs	pointer
;	O
const	O
char	O
*	O
msg	pointer
;	O
int	O
startpos	int
;	O
int	O
length	long
;	O
if	O
(	O
bad_argc	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
3	int
,	O
4	int
)	O
)	O
{	O
if	O
(	O
argc	int
==	O
2	int
)	O
shipout_int	function
(	O
obs	pointer
,	O
0	int
)	O
;	O
return	O
;	O
}	O
victim	pointer
=	O
TOKEN_DATA_TEXT	O
(	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
regexp	pointer
=	O
TOKEN_DATA_TEXT	O
(	O
argv	pointer
[	O
2	int
]	O
)	O
;	O
init_pattern_buffer	function
(	O
&	O
buf	pointer
,	O
&	O
regs	pointer
)	O
;	O
msg	pointer
=	O
re_compile_pattern	function
(	O
regexp	pointer
,	O
strlen	function
(	O
regexp	pointer
)	O
,	O
&	O
buf	pointer
)	O
;	O
if	O
(	O
msg	pointer
!=	O
NULL	O
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"bad regular expression: `%s': %s"	pointer
,	O
regexp	pointer
,	O
msg	pointer
)	O
)	O
;	O
free_pattern_buffer	function
(	O
&	O
buf	pointer
,	O
&	O
regs	pointer
)	O
;	O
return	O
;	O
}	O
length	long
=	O
strlen	function
(	O
victim	pointer
)	O
;	O
startpos	int
=	O
re_search	function
(	O
&	O
buf	pointer
,	O
victim	pointer
,	O
length	long
,	O
0	int
,	O
length	long
,	O
argc	int
==	O
3	int
?	O
NULL	O
:	O
&	O
regs	pointer
)	O
;	O
if	O
(	O
startpos	int
==	O
-	O
2	int
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"error matching regular expression `%s'"	pointer
,	O
regexp	pointer
)	O
)	O
;	O
else	O
if	O
(	O
argc	int
==	O
3	int
)	O
shipout_int	function
(	O
obs	pointer
,	O
startpos	int
)	O
;	O
else	O
if	O
(	O
startpos	int
>=	O
0	int
)	O
{	O
repl	pointer
=	O
TOKEN_DATA_TEXT	O
(	O
argv	pointer
[	O
3	int
]	O
)	O
;	O
substitute	function
(	O
obs	pointer
,	O
victim	pointer
,	O
repl	pointer
,	O
&	O
regs	pointer
)	O
;	O
}	O
free_pattern_buffer	function
(	O
&	O
buf	pointer
,	O
&	O
regs	pointer
)	O
;	O
}	O
static	O
void	O
m4_patsubst	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
const	O
char	O
*	O
victim	pointer
;	O
const	O
char	O
*	O
regexp	pointer
;	O
struct	O
re_pattern_buffer	struct
buf	pointer
;	O
struct	O
re_registers	struct
regs	pointer
;	O
const	O
char	O
*	O
msg	pointer
;	O
int	O
matchpos	int
;	O
int	O
offset	long
;	O
int	O
length	long
;	O
if	O
(	O
bad_argc	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argc	int
,	O
3	int
,	O
4	int
)	O
)	O
{	O
if	O
(	O
argc	int
==	O
2	int
)	O
obstack_grow	O
(	O
obs	pointer
,	O
ARG	O
(	O
1	int
)	O
,	O
strlen	function
(	O
ARG	O
(	O
1	int
)	O
)	O
)	O
;	O
return	O
;	O
}	O
regexp	pointer
=	O
TOKEN_DATA_TEXT	O
(	O
argv	pointer
[	O
2	int
]	O
)	O
;	O
init_pattern_buffer	function
(	O
&	O
buf	pointer
,	O
&	O
regs	pointer
)	O
;	O
msg	pointer
=	O
re_compile_pattern	function
(	O
regexp	pointer
,	O
strlen	function
(	O
regexp	pointer
)	O
,	O
&	O
buf	pointer
)	O
;	O
if	O
(	O
msg	pointer
!=	O
NULL	O
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"bad regular expression `%s': %s"	pointer
,	O
regexp	pointer
,	O
msg	pointer
)	O
)	O
;	O
free	function
(	O
buf	pointer
.	O
buffer	pointer
)	O
;	O
return	O
;	O
}	O
victim	pointer
=	O
TOKEN_DATA_TEXT	O
(	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
length	long
=	O
strlen	function
(	O
victim	pointer
)	O
;	O
offset	long
=	O
0	int
;	O
while	O
(	O
offset	long
<=	O
length	long
)	O
{	O
matchpos	int
=	O
re_search	function
(	O
&	O
buf	pointer
,	O
victim	pointer
,	O
length	long
,	O
offset	long
,	O
length	long
-	O
offset	long
,	O
&	O
regs	pointer
)	O
;	O
if	O
(	O
matchpos	int
<	O
0	int
)	O
{	O
if	O
(	O
matchpos	int
==	O
-	O
2	int
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"error matching regular expression `%s'"	pointer
,	O
regexp	pointer
)	O
)	O
;	O
else	O
if	O
(	O
offset	long
<	O
length	long
)	O
obstack_grow	O
(	O
obs	pointer
,	O
victim	pointer
+	O
offset	long
,	O
length	long
-	O
offset	long
)	O
;	O
break	O
;	O
}	O
if	O
(	O
matchpos	int
>	O
offset	long
)	O
obstack_grow	O
(	O
obs	pointer
,	O
victim	pointer
+	O
offset	long
,	O
matchpos	int
-	O
offset	long
)	O
;	O
substitute	function
(	O
obs	pointer
,	O
victim	pointer
,	O
ARG	O
(	O
3	int
)	O
,	O
&	O
regs	pointer
)	O
;	O
offset	long
=	O
regs	pointer
.	O
end	pointer
[	O
0	int
]	O
;	O
if	O
(	O
regs	pointer
.	O
start	pointer
[	O
0	int
]	O
==	O
regs	pointer
.	O
end	pointer
[	O
0	int
]	O
)	O
obstack_1grow	O
(	O
obs	pointer
,	O
victim	pointer
[	O
offset	long
++	O
]	O
)	O
;	O
}	O
obstack_1grow	O
(	O
obs	pointer
,	O
'\0'	O
)	O
;	O
free_pattern_buffer	function
(	O
&	O
buf	pointer
,	O
&	O
regs	pointer
)	O
;	O
}	O
void	O
m4_placeholder	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
M4_GNUC_UNUSED	O
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"builtin `%s' requested by frozen file is not supported"	pointer
,	O
ARG	O
(	O
0	int
)	O
)	O
)	O
;	O
}	O
void	O
expand_user_macro	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
symbol	struct
*	O
sym	pointer
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
const	O
char	O
*	O
text	pointer
=	O
SYMBOL_TEXT	O
(	O
sym	pointer
)	O
;	O
int	O
i	int
;	O
while	O
(	O
1	int
)	O
{	O
const	O
char	O
*	O
dollar	pointer
=	O
strchr	function
(	O
text	pointer
,	O
'$'	O
)	O
;	O
if	O
(	O
!	O
dollar	pointer
)	O
{	O
obstack_grow	O
(	O
obs	pointer
,	O
text	pointer
,	O
strlen	function
(	O
text	pointer
)	O
)	O
;	O
return	O
;	O
}	O
obstack_grow	O
(	O
obs	pointer
,	O
text	pointer
,	O
dollar	pointer
-	O
text	pointer
)	O
;	O
text	pointer
=	O
dollar	pointer
;	O
switch	O
(	O
*	O
++	O
text	pointer
)	O
{	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
if	O
(	O
no_gnu_extensions	int
)	O
{	O
i	int
=	O
*	O
text	pointer
++	O
-	O
'0'	O
;	O
}	O
else	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
isdigit	function
(	O
to_uchar	O
(	O
*	O
text	pointer
)	O
)	O
;	O
text	pointer
++	O
)	O
i	int
=	O
i	int
*	O
10	int
+	O
(	O
*	O
text	pointer
-	O
'0'	O
)	O
;	O
}	O
if	O
(	O
i	int
<	O
argc	int
)	O
obstack_grow	O
(	O
obs	pointer
,	O
TOKEN_DATA_TEXT	O
(	O
argv	pointer
[	O
i	int
]	O
)	O
,	O
strlen	function
(	O
TOKEN_DATA_TEXT	O
(	O
argv	pointer
[	O
i	int
]	O
)	O
)	O
)	O
;	O
break	O
;	O
case	O
'#'	O
:	O
shipout_int	function
(	O
obs	pointer
,	O
argc	int
-	O
1	int
)	O
;	O
text	pointer
++	O
;	O
break	O
;	O
case	O
'*'	O
:	O
case	O
'@'	O
:	O
dump_args	function
(	O
obs	pointer
,	O
argc	int
,	O
argv	pointer
,	O
","	pointer
,	O
*	O
text	pointer
==	O
'@'	O
)	O
;	O
text	pointer
++	O
;	O
break	O
;	O
default	O
:	O
obstack_1grow	O
(	O
obs	pointer
,	O
'$'	O
)	O
;	O
break	O
;	O
}	O
}	O
}	O
