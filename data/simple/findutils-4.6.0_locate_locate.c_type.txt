static	O
unsigned	O
int	O
warn_number_units	int
=	O
8	int
;	O
static	O
const	O
char	O
warn_name_units	array
[	O
]	O
=	O
N_	O
(	O
"days"	pointer
)	O
;	O
enum	O
visit_result	enum
{	O
VISIT_CONTINUE	int
=	O
1	int
,	O
VISIT_ACCEPTED	int
=	O
2	int
,	O
VISIT_REJECTED	int
=	O
4	int
,	O
VISIT_ABORT	int
=	O
8	int
}	O
;	O
enum	O
ExistenceCheckType	enum
{	O
ACCEPT_EITHER	int
,	O
ACCEPT_EXISTING	int
,	O
ACCEPT_NON_EXISTING	int
}	O
;	O
enum	O
ExistenceCheckType	enum
check_existence	enum
=	O
ACCEPT_EITHER	int
;	O
static	O
int	O
follow_symlinks	int
=	O
1	int
;	O
static	O
int	O
separator	int
=	O
'\n'	O
;	O
static	O
struct	O
quoting_options	O
*	O
quote_opts	pointer
=	O
NULL	O
;	O
static	O
bool	bool
stdout_is_a_tty	bool
;	O
static	O
bool	bool
print_quoted_filename	bool
;	O
static	O
bool	bool
results_were_filtered	bool
;	O
static	O
const	O
char	O
*	O
selected_secure_db	pointer
=	O
NULL	O
;	O
static	O
void	O
set_max_db_age	function
(	O
const	O
char	O
*	O
s	long
)	O
{	O
char	O
*	O
end	pointer
;	O
unsigned	O
long	O
int	O
val	int
;	O
if	O
(	O
0	int
==	O
*	O
s	long
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"The argument for option --max-database-age must not be empty"	pointer
)	O
)	O
;	O
}	O
errno	O
=	O
0	int
;	O
val	int
=	O
strtoul	function
(	O
s	long
,	O
&	O
end	pointer
,	O
10	int
)	O
;	O
if	O
(	O
(	O
ULONG_MAX	O
==	O
val	int
&&	O
ERANGE	int
==	O
errno	O
)	O
||	O
(	O
0	int
==	O
val	int
&&	O
EINVAL	int
==	O
errno	O
)	O
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"Invalid argument %s for option --max-database-age"	pointer
)	O
,	O
quotearg_n_style	function
(	O
0	int
,	O
locale_quoting_style	int
,	O
s	long
)	O
)	O
;	O
}	O
else	O
if	O
(	O
*	O
end	pointer
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"Invalid argument %s for option --max-database-age"	pointer
)	O
,	O
quotearg_n_style	function
(	O
0	int
,	O
locale_quoting_style	int
,	O
s	long
)	O
)	O
;	O
}	O
else	O
{	O
warn_number_units	int
=	O
val	int
;	O
}	O
}	O
static	O
short	O
get_short	function
(	O
FILE	struct
*	O
fp	pointer
)	O
{	O
register	O
short	O
x	short
;	O
x	short
=	O
(	O
signed	O
char	O
)	O
fgetc	function
(	O
fp	pointer
)	O
<<	O
8	int
;	O
x	short
|=	O
(	O
fgetc	function
(	O
fp	pointer
)	O
&	O
0xff	int
)	O
;	O
return	O
x	short
;	O
}	O
const	O
char	O
*	O
const	O
metacharacters	pointer
=	O
"*?[]\\"	pointer
;	O
static	O
int	O
contains_metacharacter	function
(	O
const	O
char	O
*	O
s	long
)	O
{	O
if	O
(	O
NULL	O
==	O
strpbrk	function
(	O
s	long
,	O
metacharacters	pointer
)	O
)	O
return	O
0	int
;	O
else	O
return	O
1	int
;	O
}	O
static	O
int	O
locate_read_str	function
(	O
char	O
*	O
*	O
buf	pointer
,	O
size_t	long
*	O
siz	pointer
,	O
FILE	struct
*	O
fp	pointer
,	O
int	O
delimiter	int
,	O
int	O
offs	int
)	O
{	O
char	O
*	O
p	pointer
=	O
NULL	O
;	O
size_t	long
sz	long
=	O
0	int
;	O
int	O
nread	int
;	O
size_t	long
needed	long
;	O
nread	int
=	O
getdelim	function
(	O
&	O
p	pointer
,	O
&	O
sz	long
,	O
delimiter	int
,	O
fp	pointer
)	O
;	O
if	O
(	O
nread	int
>=	O
0	int
)	O
{	O
assert	O
(	O
p	pointer
!=	O
NULL	O
)	O
;	O
needed	long
=	O
offs	int
+	O
nread	int
+	O
1u	int
;	O
if	O
(	O
needed	long
>	O
(	O
*	O
siz	pointer
)	O
)	O
{	O
char	O
*	O
pnew	pointer
=	O
realloc	function
(	O
*	O
buf	pointer
,	O
needed	long
)	O
;	O
if	O
(	O
NULL	O
==	O
pnew	pointer
)	O
{	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
*	O
siz	pointer
=	O
needed	long
;	O
*	O
buf	pointer
=	O
pnew	pointer
;	O
}	O
}	O
memcpy	function
(	O
(	O
*	O
buf	pointer
)	O
+	O
offs	int
,	O
p	pointer
,	O
nread	int
+	O
1	int
)	O
;	O
free	function
(	O
p	pointer
)	O
;	O
}	O
return	O
nread	int
;	O
}	O
struct	O
locate_limits	struct
{	O
uintmax_t	long
limit	long
;	O
uintmax_t	long
items_accepted	long
;	O
}	O
;	O
static	O
struct	O
locate_limits	struct
limits	struct
;	O
struct	O
locate_stats	struct
{	O
uintmax_t	long
compressed_bytes	long
;	O
uintmax_t	long
total_filename_count	long
;	O
uintmax_t	long
total_filename_length	long
;	O
uintmax_t	long
whitespace_count	long
;	O
uintmax_t	long
newline_count	long
;	O
uintmax_t	long
highbit_filename_count	long
;	O
}	O
;	O
static	O
struct	O
locate_stats	struct
statistics	struct
;	O
struct	O
regular_expression	struct
{	O
struct	O
re_pattern_buffer	struct
regex	struct
;	O
}	O
;	O
struct	O
process_data	struct
{	O
int	O
c	char
;	O
int	O
count	int
;	O
int	O
len	long
;	O
char	O
*	O
original_filename	pointer
;	O
size_t	long
pathsize	long
;	O
char	O
*	O
munged_filename	pointer
;	O
FILE	struct
*	O
fp	pointer
;	O
const	O
char	O
*	O
dbfile	pointer
;	O
GetwordEndianState	enum
endian_state	enum
;	O
char	O
bigram1	array
[	O
128	int
]	O
;	O
char	O
bigram2	array
[	O
128	int
]	O
;	O
}	O
;	O
typedef	O
int	O
(	O
*	O
visitfunc	pointer
)	O
(	O
struct	O
process_data	struct
*	O
procdata	pointer
,	O
void	O
*	O
context	pointer
)	O
;	O
struct	O
visitor	struct
{	O
visitfunc	pointer
inspector	pointer
;	O
void	O
*	O
context	pointer
;	O
struct	O
visitor	struct
*	O
next	pointer
;	O
}	O
;	O
static	O
struct	O
visitor	struct
*	O
inspectors	pointer
=	O
NULL	O
;	O
static	O
struct	O
visitor	struct
*	O
lastinspector	pointer
=	O
NULL	O
;	O
static	O
struct	O
visitor	struct
*	O
past_pat_inspector	pointer
=	O
NULL	O
;	O
static	O
inline	O
int	O
visit	function
(	O
const	O
struct	O
visitor	struct
*	O
p	pointer
,	O
int	O
accept_flags	int
,	O
struct	O
process_data	struct
*	O
procdata	pointer
,	O
const	O
struct	O
visitor	struct
*	O
const	O
stop	pointer
)	O
{	O
register	O
int	O
result	int
=	O
accept_flags	int
;	O
while	O
(	O
(	O
accept_flags	int
&	O
result	int
)	O
&&	O
(	O
stop	pointer
!=	O
p	pointer
)	O
)	O
{	O
result	int
=	O
(	O
p	pointer
->	O
inspector	pointer
)	O
(	O
procdata	pointer
,	O
p	pointer
->	O
context	pointer
)	O
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
;	O
}	O
return	O
result	int
;	O
}	O
static	O
int	O
process_simple	function
(	O
struct	O
process_data	struct
*	O
procdata	pointer
)	O
{	O
return	O
visit	function
(	O
inspectors	pointer
,	O
(	O
VISIT_CONTINUE	int
|	O
VISIT_ACCEPTED	int
)	O
,	O
procdata	pointer
,	O
NULL	O
)	O
;	O
}	O
static	O
int	O
process_or	function
(	O
struct	O
process_data	struct
*	O
procdata	pointer
)	O
{	O
int	O
result	int
;	O
result	int
=	O
visit	function
(	O
inspectors	pointer
,	O
(	O
VISIT_CONTINUE	int
|	O
VISIT_REJECTED	int
)	O
,	O
procdata	pointer
,	O
past_pat_inspector	pointer
)	O
;	O
if	O
(	O
result	int
==	O
VISIT_CONTINUE	int
)	O
result	int
=	O
VISIT_REJECTED	int
;	O
if	O
(	O
result	int
&	O
(	O
VISIT_ABORT	int
|	O
VISIT_REJECTED	int
)	O
)	O
return	O
result	int
;	O
result	int
=	O
visit	function
(	O
past_pat_inspector	pointer
,	O
VISIT_CONTINUE	int
,	O
procdata	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
VISIT_CONTINUE	int
==	O
result	int
)	O
return	O
VISIT_ACCEPTED	int
;	O
else	O
return	O
result	int
;	O
}	O
static	O
int	O
process_and	function
(	O
struct	O
process_data	struct
*	O
procdata	pointer
)	O
{	O
int	O
result	int
;	O
result	int
=	O
visit	function
(	O
inspectors	pointer
,	O
(	O
VISIT_CONTINUE	int
|	O
VISIT_ACCEPTED	int
)	O
,	O
procdata	pointer
,	O
past_pat_inspector	pointer
)	O
;	O
if	O
(	O
result	int
==	O
VISIT_CONTINUE	int
)	O
result	int
=	O
VISIT_REJECTED	int
;	O
if	O
(	O
result	int
&	O
(	O
VISIT_ABORT	int
|	O
VISIT_REJECTED	int
)	O
)	O
return	O
result	int
;	O
result	int
=	O
visit	function
(	O
past_pat_inspector	pointer
,	O
VISIT_CONTINUE	int
,	O
procdata	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
VISIT_CONTINUE	int
==	O
result	int
)	O
return	O
VISIT_ACCEPTED	int
;	O
else	O
return	O
result	int
;	O
}	O
typedef	O
int	O
(	O
*	O
processfunc	pointer
)	O
(	O
struct	O
process_data	struct
*	O
procdata	pointer
)	O
;	O
static	O
processfunc	pointer
mainprocessor	pointer
=	O
NULL	O
;	O
static	O
void	O
add_visitor	function
(	O
visitfunc	pointer
fn	pointer
,	O
void	O
*	O
context	pointer
)	O
{	O
struct	O
visitor	struct
*	O
p	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
visitor	struct
)	O
)	O
;	O
p	pointer
->	O
inspector	pointer
=	O
fn	pointer
;	O
p	pointer
->	O
context	pointer
=	O
context	pointer
;	O
p	pointer
->	O
next	pointer
=	O
NULL	O
;	O
if	O
(	O
NULL	O
==	O
lastinspector	pointer
)	O
{	O
lastinspector	pointer
=	O
inspectors	pointer
=	O
p	pointer
;	O
}	O
else	O
{	O
lastinspector	pointer
->	O
next	pointer
=	O
p	pointer
;	O
lastinspector	pointer
=	O
p	pointer
;	O
}	O
}	O
static	O
int	O
visit_justprint_quoted	function
(	O
struct	O
process_data	struct
*	O
procdata	pointer
,	O
void	O
*	O
context	pointer
)	O
{	O
(	O
void	O
)	O
context	pointer
;	O
print_quoted	function
(	O
stdout	pointer
,	O
quote_opts	pointer
,	O
stdout_is_a_tty	bool
,	O
"%s"	pointer
,	O
procdata	pointer
->	O
original_filename	pointer
)	O
;	O
putchar	function
(	O
separator	int
)	O
;	O
return	O
VISIT_CONTINUE	int
;	O
}	O
static	O
int	O
visit_justprint_unquoted	function
(	O
struct	O
process_data	struct
*	O
procdata	pointer
,	O
void	O
*	O
context	pointer
)	O
{	O
(	O
void	O
)	O
context	pointer
;	O
fputs	function
(	O
procdata	pointer
->	O
original_filename	pointer
,	O
stdout	pointer
)	O
;	O
putchar	function
(	O
separator	int
)	O
;	O
return	O
VISIT_CONTINUE	int
;	O
}	O
static	O
void	O
toolong	function
(	O
struct	O
process_data	struct
*	O
procdata	pointer
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"locate database %s contains a "	pointer
"filename longer than locate can handle"	pointer
)	O
,	O
procdata	pointer
->	O
dbfile	pointer
)	O
;	O
}	O
static	O
void	O
extend	function
(	O
struct	O
process_data	struct
*	O
procdata	pointer
,	O
size_t	long
siz1	long
,	O
size_t	long
siz2	long
)	O
{	O
if	O
(	O
SIZE_MAX	O
-	O
siz1	long
<	O
siz2	long
)	O
{	O
toolong	function
(	O
procdata	pointer
)	O
;	O
}	O
else	O
if	O
(	O
procdata	pointer
->	O
pathsize	long
<	O
(	O
siz1	long
+	O
siz2	long
)	O
)	O
{	O
procdata	pointer
->	O
pathsize	long
=	O
siz1	long
+	O
siz2	long
;	O
procdata	pointer
->	O
original_filename	pointer
=	O
x2nrealloc	function
(	O
procdata	pointer
->	O
original_filename	pointer
,	O
&	O
procdata	pointer
->	O
pathsize	long
,	O
1	int
)	O
;	O
}	O
}	O
static	O
int	O
visit_old_format	function
(	O
struct	O
process_data	struct
*	O
procdata	pointer
,	O
void	O
*	O
context	pointer
)	O
{	O
register	O
size_t	long
i	int
;	O
(	O
void	O
)	O
context	pointer
;	O
if	O
(	O
EOF	O
==	O
procdata	pointer
->	O
c	char
)	O
return	O
VISIT_ABORT	int
;	O
if	O
(	O
procdata	pointer
->	O
c	char
==	O
LOCATEDB_OLD_ESCAPE	int
)	O
{	O
int	O
minval	int
,	O
maxval	int
;	O
int	O
word	int
;	O
procdata	pointer
->	O
count	int
-=	O
LOCATEDB_OLD_OFFSET	int
;	O
minval	int
=	O
(	O
0	int
-	O
procdata	pointer
->	O
count	int
)	O
;	O
if	O
(	O
procdata	pointer
->	O
count	int
>=	O
0	int
)	O
maxval	int
=	O
(	O
procdata	pointer
->	O
len	long
-	O
procdata	pointer
->	O
count	int
)	O
;	O
else	O
maxval	int
=	O
(	O
procdata	pointer
->	O
len	long
-	O
0	int
)	O
;	O
word	int
=	O
getword	function
(	O
procdata	pointer
->	O
fp	pointer
,	O
procdata	pointer
->	O
dbfile	pointer
,	O
minval	int
,	O
maxval	int
,	O
&	O
procdata	pointer
->	O
endian_state	enum
)	O
;	O
procdata	pointer
->	O
count	int
+=	O
word	int
;	O
assert	O
(	O
procdata	pointer
->	O
count	int
>=	O
0	int
)	O
;	O
}	O
else	O
{	O
procdata	pointer
->	O
count	int
+=	O
(	O
procdata	pointer
->	O
c	char
-	O
LOCATEDB_OLD_OFFSET	int
)	O
;	O
assert	O
(	O
procdata	pointer
->	O
count	int
>=	O
0	int
)	O
;	O
}	O
for	O
(	O
i	int
=	O
procdata	pointer
->	O
count	int
;	O
(	O
procdata	pointer
->	O
c	char
=	O
getc	function
(	O
procdata	pointer
->	O
fp	pointer
)	O
)	O
>	O
LOCATEDB_OLD_ESCAPE	int
;	O
)	O
{	O
if	O
(	O
EOF	O
==	O
procdata	pointer
->	O
c	char
)	O
break	O
;	O
if	O
(	O
procdata	pointer
->	O
c	char
<	O
0200	int
)	O
{	O
extend	function
(	O
procdata	pointer
,	O
i	int
,	O
1u	int
)	O
;	O
procdata	pointer
->	O
original_filename	pointer
[	O
i	int
++	O
]	O
=	O
procdata	pointer
->	O
c	char
;	O
}	O
else	O
{	O
extend	function
(	O
procdata	pointer
,	O
i	int
,	O
2u	int
)	O
;	O
procdata	pointer
->	O
c	char
&=	O
0177	int
;	O
procdata	pointer
->	O
original_filename	pointer
[	O
i	int
++	O
]	O
=	O
procdata	pointer
->	O
bigram1	array
[	O
procdata	pointer
->	O
c	char
]	O
;	O
procdata	pointer
->	O
original_filename	pointer
[	O
i	int
++	O
]	O
=	O
procdata	pointer
->	O
bigram2	array
[	O
procdata	pointer
->	O
c	char
]	O
;	O
}	O
}	O
extend	function
(	O
procdata	pointer
,	O
i	int
,	O
1u	int
)	O
;	O
procdata	pointer
->	O
original_filename	pointer
[	O
i	int
]	O
=	O
0	int
;	O
procdata	pointer
->	O
len	long
=	O
i	int
;	O
procdata	pointer
->	O
munged_filename	pointer
=	O
procdata	pointer
->	O
original_filename	pointer
;	O
return	O
VISIT_CONTINUE	int
;	O
}	O
static	O
int	O
visit_locate02_format	function
(	O
struct	O
process_data	struct
*	O
procdata	pointer
,	O
void	O
*	O
context	pointer
)	O
{	O
register	O
char	O
*	O
s	long
;	O
int	O
nread	int
;	O
(	O
void	O
)	O
context	pointer
;	O
if	O
(	O
procdata	pointer
->	O
c	char
==	O
LOCATEDB_ESCAPE	int
)	O
procdata	pointer
->	O
count	int
+=	O
(	O
short	O
)	O
get_short	function
(	O
procdata	pointer
->	O
fp	pointer
)	O
;	O
else	O
if	O
(	O
procdata	pointer
->	O
c	char
>	O
127	int
)	O
procdata	pointer
->	O
count	int
+=	O
procdata	pointer
->	O
c	char
-	O
256	int
;	O
else	O
procdata	pointer
->	O
count	int
+=	O
procdata	pointer
->	O
c	char
;	O
if	O
(	O
procdata	pointer
->	O
count	int
>	O
procdata	pointer
->	O
len	long
||	O
procdata	pointer
->	O
count	int
<	O
0	int
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"locate database %s is corrupt or invalid"	pointer
)	O
,	O
quotearg_n_style	function
(	O
0	int
,	O
locale_quoting_style	int
,	O
procdata	pointer
->	O
dbfile	pointer
)	O
)	O
;	O
}	O
nread	int
=	O
locate_read_str	function
(	O
&	O
procdata	pointer
->	O
original_filename	pointer
,	O
&	O
procdata	pointer
->	O
pathsize	long
,	O
procdata	pointer
->	O
fp	pointer
,	O
0	int
,	O
procdata	pointer
->	O
count	int
)	O
;	O
if	O
(	O
nread	int
<	O
1	int
)	O
return	O
VISIT_ABORT	int
;	O
procdata	pointer
->	O
c	char
=	O
getc	function
(	O
procdata	pointer
->	O
fp	pointer
)	O
;	O
procdata	pointer
->	O
len	long
=	O
procdata	pointer
->	O
count	int
+	O
nread	int
-	O
1	int
;	O
if	O
(	O
procdata	pointer
->	O
len	long
<	O
1	int
)	O
{	O
error	function
(	O
1	int
,	O
0	int
,	O
_	O
(	O
"locate database %s is corrupt or invalid"	pointer
)	O
,	O
quotearg_n_style	function
(	O
0	int
,	O
locale_quoting_style	int
,	O
procdata	pointer
->	O
dbfile	pointer
)	O
)	O
;	O
}	O
s	long
=	O
procdata	pointer
->	O
original_filename	pointer
+	O
procdata	pointer
->	O
len	long
-	O
1	int
;	O
assert	O
(	O
s	long
[	O
0	int
]	O
!=	O
'\0'	O
)	O
;	O
assert	O
(	O
s	long
[	O
1	int
]	O
==	O
'\0'	O
)	O
;	O
assert	O
(	O
s	long
[	O
2	int
]	O
==	O
'\0'	O
)	O
;	O
procdata	pointer
->	O
munged_filename	pointer
=	O
procdata	pointer
->	O
original_filename	pointer
;	O
return	O
VISIT_CONTINUE	int
;	O
}	O
static	O
int	O
visit_basename	function
(	O
struct	O
process_data	struct
*	O
procdata	pointer
,	O
void	O
*	O
context	pointer
)	O
{	O
(	O
void	O
)	O
context	pointer
;	O
procdata	pointer
->	O
munged_filename	pointer
=	O
last_component	function
(	O
procdata	pointer
->	O
original_filename	pointer
)	O
;	O
return	O
VISIT_CONTINUE	int
;	O
}	O
static	O
int	O
visit_existing_follow	function
(	O
struct	O
process_data	struct
*	O
procdata	pointer
,	O
void	O
*	O
context	pointer
)	O
{	O
struct	O
stat	struct
st	pointer
;	O
(	O
void	O
)	O
context	pointer
;	O
if	O
(	O
stat	struct
(	O
procdata	pointer
->	O
original_filename	pointer
,	O
&	O
st	pointer
)	O
!=	O
0	int
)	O
{	O
return	O
VISIT_REJECTED	int
;	O
}	O
else	O
{	O
return	O
VISIT_CONTINUE	int
;	O
}	O
}	O
static	O
int	O
visit_non_existing_follow	function
(	O
struct	O
process_data	struct
*	O
procdata	pointer
,	O
void	O
*	O
context	pointer
)	O
{	O
struct	O
stat	struct
st	pointer
;	O
(	O
void	O
)	O
context	pointer
;	O
if	O
(	O
stat	struct
(	O
procdata	pointer
->	O
original_filename	pointer
,	O
&	O
st	pointer
)	O
==	O
0	int
)	O
{	O
return	O
VISIT_REJECTED	int
;	O
}	O
else	O
{	O
return	O
VISIT_CONTINUE	int
;	O
}	O
}	O
static	O
int	O
visit_existing_nofollow	function
(	O
struct	O
process_data	struct
*	O
procdata	pointer
,	O
void	O
*	O
context	pointer
)	O
{	O
struct	O
stat	struct
st	pointer
;	O
(	O
void	O
)	O
context	pointer
;	O
if	O
(	O
lstat	function
(	O
procdata	pointer
->	O
original_filename	pointer
,	O
&	O
st	pointer
)	O
!=	O
0	int
)	O
{	O
return	O
VISIT_REJECTED	int
;	O
}	O
else	O
{	O
return	O
VISIT_CONTINUE	int
;	O
}	O
}	O
static	O
int	O
visit_non_existing_nofollow	function
(	O
struct	O
process_data	struct
*	O
procdata	pointer
,	O
void	O
*	O
context	pointer
)	O
{	O
struct	O
stat	struct
st	pointer
;	O
(	O
void	O
)	O
context	pointer
;	O
if	O
(	O
lstat	function
(	O
procdata	pointer
->	O
original_filename	pointer
,	O
&	O
st	pointer
)	O
==	O
0	int
)	O
{	O
return	O
VISIT_REJECTED	int
;	O
}	O
else	O
{	O
return	O
VISIT_CONTINUE	int
;	O
}	O
}	O
static	O
int	O
visit_substring_match_nocasefold_wide	function
(	O
struct	O
process_data	struct
*	O
procdata	pointer
,	O
void	O
*	O
context	pointer
)	O
{	O
const	O
char	O
*	O
pattern	pointer
=	O
context	pointer
;	O
if	O
(	O
NULL	O
!=	O
mbsstr	function
(	O
procdata	pointer
->	O
munged_filename	pointer
,	O
pattern	pointer
)	O
)	O
return	O
VISIT_ACCEPTED	int
;	O
else	O
return	O
VISIT_REJECTED	int
;	O
}	O
static	O
int	O
visit_substring_match_nocasefold_narrow	function
(	O
struct	O
process_data	struct
*	O
procdata	pointer
,	O
void	O
*	O
context	pointer
)	O
{	O
const	O
char	O
*	O
pattern	pointer
=	O
context	pointer
;	O
assert	O
(	O
MB_CUR_MAX	O
==	O
1	int
)	O
;	O
if	O
(	O
NULL	O
!=	O
strstr	function
(	O
procdata	pointer
->	O
munged_filename	pointer
,	O
pattern	pointer
)	O
)	O
return	O
VISIT_ACCEPTED	int
;	O
else	O
return	O
VISIT_REJECTED	int
;	O
}	O
static	O
int	O
visit_substring_match_casefold_wide	function
(	O
struct	O
process_data	struct
*	O
procdata	pointer
,	O
void	O
*	O
context	pointer
)	O
{	O
const	O
char	O
*	O
pattern	pointer
=	O
context	pointer
;	O
if	O
(	O
NULL	O
!=	O
mbscasestr	function
(	O
procdata	pointer
->	O
munged_filename	pointer
,	O
pattern	pointer
)	O
)	O
return	O
VISIT_ACCEPTED	int
;	O
else	O
return	O
VISIT_REJECTED	int
;	O
}	O
static	O
int	O
visit_substring_match_casefold_narrow	function
(	O
struct	O
process_data	struct
*	O
procdata	pointer
,	O
void	O
*	O
context	pointer
)	O
{	O
const	O
char	O
*	O
pattern	pointer
=	O
context	pointer
;	O
assert	O
(	O
MB_CUR_MAX	O
==	O
1	int
)	O
;	O
if	O
(	O
NULL	O
!=	O
strcasestr	function
(	O
procdata	pointer
->	O
munged_filename	pointer
,	O
pattern	pointer
)	O
)	O
return	O
VISIT_ACCEPTED	int
;	O
else	O
return	O
VISIT_REJECTED	int
;	O
}	O
static	O
int	O
visit_globmatch_nofold	function
(	O
struct	O
process_data	struct
*	O
procdata	pointer
,	O
void	O
*	O
context	pointer
)	O
{	O
const	O
char	O
*	O
glob	pointer
=	O
context	pointer
;	O
if	O
(	O
fnmatch	function
(	O
glob	pointer
,	O
procdata	pointer
->	O
munged_filename	pointer
,	O
0	int
)	O
!=	O
0	int
)	O
return	O
VISIT_REJECTED	int
;	O
else	O
return	O
VISIT_ACCEPTED	int
;	O
}	O
static	O
int	O
visit_globmatch_casefold	function
(	O
struct	O
process_data	struct
*	O
procdata	pointer
,	O
void	O
*	O
context	pointer
)	O
{	O
const	O
char	O
*	O
glob	pointer
=	O
context	pointer
;	O
if	O
(	O
fnmatch	function
(	O
glob	pointer
,	O
procdata	pointer
->	O
munged_filename	pointer
,	O
FNM_CASEFOLD	O
)	O
!=	O
0	int
)	O
return	O
VISIT_REJECTED	int
;	O
else	O
return	O
VISIT_ACCEPTED	int
;	O
}	O
static	O
int	O
visit_regex	function
(	O
struct	O
process_data	struct
*	O
procdata	pointer
,	O
void	O
*	O
context	pointer
)	O
{	O
struct	O
regular_expression	struct
*	O
p	pointer
=	O
context	pointer
;	O
const	O
size_t	long
len	long
=	O
strlen	function
(	O
procdata	pointer
->	O
munged_filename	pointer
)	O
;	O
int	O
rv	int
=	O
re_search	function
(	O
&	O
p	pointer
->	O
regex	struct
,	O
procdata	pointer
->	O
munged_filename	pointer
,	O
len	long
,	O
0	int
,	O
len	long
,	O
(	O
struct	O
re_registers	struct
*	O
)	O
NULL	O
)	O
;	O
if	O
(	O
rv	int
<	O
0	int
)	O
{	O
return	O
VISIT_REJECTED	int
;	O
}	O
else	O
{	O
return	O
VISIT_ACCEPTED	int
;	O
}	O
}	O
static	O
int	O
visit_stats	function
(	O
struct	O
process_data	struct
*	O
procdata	pointer
,	O
void	O
*	O
context	pointer
)	O
{	O
struct	O
locate_stats	struct
*	O
p	pointer
=	O
context	pointer
;	O
size_t	long
len	long
=	O
strlen	function
(	O
procdata	pointer
->	O
original_filename	pointer
)	O
;	O
const	O
char	O
*	O
s	long
;	O
int	O
highbit	int
,	O
whitespace	int
,	O
newline	int
;	O
++	O
(	O
p	pointer
->	O
total_filename_count	long
)	O
;	O
p	pointer
->	O
total_filename_length	long
+=	O
len	long
;	O
highbit	int
=	O
whitespace	int
=	O
newline	int
=	O
0	int
;	O
for	O
(	O
s	long
=	O
procdata	pointer
->	O
original_filename	pointer
;	O
*	O
s	long
;	O
++	O
s	long
)	O
{	O
if	O
(	O
(	O
int	O
)	O
(	O
*	O
s	long
)	O
&	O
128	int
)	O
highbit	int
=	O
1	int
;	O
if	O
(	O
'\n'	O
==	O
*	O
s	long
)	O
{	O
newline	int
=	O
whitespace	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
isspace	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
s	long
)	O
)	O
{	O
whitespace	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
highbit	int
)	O
++	O
(	O
p	pointer
->	O
highbit_filename_count	long
)	O
;	O
if	O
(	O
whitespace	int
)	O
++	O
(	O
p	pointer
->	O
whitespace_count	long
)	O
;	O
if	O
(	O
newline	int
)	O
++	O
(	O
p	pointer
->	O
newline_count	long
)	O
;	O
return	O
VISIT_CONTINUE	int
;	O
}	O
static	O
int	O
visit_limit	function
(	O
struct	O
process_data	struct
*	O
procdata	pointer
,	O
void	O
*	O
context	pointer
)	O
{	O
struct	O
locate_limits	struct
*	O
p	pointer
=	O
context	pointer
;	O
(	O
void	O
)	O
procdata	pointer
;	O
if	O
(	O
++	O
p	pointer
->	O
items_accepted	long
>=	O
p	pointer
->	O
limit	long
)	O
return	O
VISIT_ABORT	int
;	O
else	O
return	O
VISIT_CONTINUE	int
;	O
}	O
static	O
int	O
visit_count	function
(	O
struct	O
process_data	struct
*	O
procdata	pointer
,	O
void	O
*	O
context	pointer
)	O
{	O
struct	O
locate_limits	struct
*	O
p	pointer
=	O
context	pointer
;	O
(	O
void	O
)	O
procdata	pointer
;	O
++	O
p	pointer
->	O
items_accepted	long
;	O
return	O
VISIT_CONTINUE	int
;	O
}	O
static	O
void	O
print_stats	function
(	O
int	O
argc	int
,	O
size_t	long
database_file_size	long
,	O
const	O
struct	O
timespec	struct
*	O
database_mtime	pointer
)	O
{	O
char	O
hbuf1	array
[	O
LONGEST_HUMAN_READABLE	O
+	O
1	int
]	O
;	O
char	O
hbuf2	array
[	O
LONGEST_HUMAN_READABLE	O
+	O
1	int
]	O
;	O
char	O
hbuf3	array
[	O
LONGEST_HUMAN_READABLE	O
+	O
1	int
]	O
;	O
char	O
hbuf4	array
[	O
LONGEST_HUMAN_READABLE	O
+	O
1	int
]	O
;	O
if	O
(	O
database_mtime	pointer
)	O
{	O
const	O
struct	O
tm	struct
*	O
ptm	pointer
=	O
localtime	function
(	O
&	O
(	O
database_mtime	pointer
->	O
tv_sec	long
)	O
)	O
;	O
if	O
(	O
ptm	pointer
)	O
{	O
enum	O
{	O
TIME_BUF_LEN	int
=	O
20	int
}	O
;	O
char	O
whenbuf	array
[	O
TIME_BUF_LEN	int
]	O
;	O
size_t	long
printed	long
=	O
strftime	function
(	O
whenbuf	array
,	O
TIME_BUF_LEN	int
,	O
"%Y:%m:%d %H:%M:%S"	pointer
,	O
ptm	pointer
)	O
;	O
assert	O
(	O
printed	long
==	O
TIME_BUF_LEN	int
-	O
1	int
)	O
;	O
assert	O
(	O
whenbuf	array
[	O
TIME_BUF_LEN	int
-	O
1	int
]	O
==	O
0	int
)	O
;	O
assert	O
(	O
whenbuf	array
[	O
TIME_BUF_LEN	int
-	O
2	int
]	O
!=	O
0	int
)	O
;	O
printf	function
(	O
_	O
(	O
"Database was last modified at %s.%09ld"	pointer
)	O
,	O
whenbuf	array
,	O
(	O
long	O
int	O
)	O
database_mtime	pointer
->	O
tv_nsec	long
)	O
;	O
printed	long
=	O
strftime	function
(	O
whenbuf	array
,	O
TIME_BUF_LEN	int
,	O
"%z"	pointer
,	O
ptm	pointer
)	O
;	O
assert	O
(	O
printed	long
==	O
5	int
)	O
;	O
printf	function
(	O
" %s\n"	pointer
,	O
whenbuf	array
)	O
;	O
}	O
}	O
printf	function
(	O
ngettext	function
(	O
"Locate database size: %s byte\n"	pointer
,	O
"Locate database size: %s bytes\n"	pointer
,	O
database_file_size	long
)	O
,	O
human_readable	function
(	O
(	O
uintmax_t	long
)	O
database_file_size	long
,	O
hbuf1	array
,	O
human_ceiling	int
,	O
1	int
,	O
1	int
)	O
)	O
;	O
printf	function
(	O
(	O
results_were_filtered	bool
?	O
_	O
(	O
"Matching Filenames: %s\n"	pointer
)	O
:	O
_	O
(	O
"All Filenames: %s\n"	pointer
)	O
)	O
,	O
human_readable	function
(	O
statistics	struct
.	O
total_filename_count	long
,	O
hbuf1	array
,	O
human_ceiling	int
,	O
1	int
,	O
1	int
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"File names have a cumulative length of %s bytes.\n"	pointer
"Of those file names,\n"	pointer
"\n\t%s contain whitespace, "	pointer
"\n\t%s contain newline characters, "	pointer
"\n\tand %s contain characters with the high bit set.\n"	pointer
)	O
,	O
human_readable	function
(	O
statistics	struct
.	O
total_filename_length	long
,	O
hbuf1	array
,	O
human_ceiling	int
,	O
1	int
,	O
1	int
)	O
,	O
human_readable	function
(	O
statistics	struct
.	O
whitespace_count	long
,	O
hbuf2	array
,	O
human_ceiling	int
,	O
1	int
,	O
1	int
)	O
,	O
human_readable	function
(	O
statistics	struct
.	O
newline_count	long
,	O
hbuf3	array
,	O
human_ceiling	int
,	O
1	int
,	O
1	int
)	O
,	O
human_readable	function
(	O
statistics	struct
.	O
highbit_filename_count	long
,	O
hbuf4	array
,	O
human_ceiling	int
,	O
1	int
,	O
1	int
)	O
)	O
;	O
if	O
(	O
!	O
argc	int
)	O
{	O
if	O
(	O
results_were_filtered	bool
)	O
{	O
printf	function
(	O
_	O
(	O
"Some filenames may have been filtered out, "	pointer
"so we cannot compute the compression ratio.\n"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
statistics	struct
.	O
total_filename_length	long
)	O
{	O
printf	function
(	O
_	O
(	O
"Compression ratio %4.2f%% (higher is better)\n"	pointer
)	O
,	O
100.0	int
*	O
(	O
(	O
double	O
)	O
statistics	struct
.	O
total_filename_length	long
-	O
(	O
double	O
)	O
database_file_size	long
)	O
/	O
(	O
double	O
)	O
statistics	struct
.	O
total_filename_length	long
)	O
;	O
}	O
else	O
{	O
printf	function
(	O
_	O
(	O
"Compression ratio is undefined\n"	pointer
)	O
)	O
;	O
}	O
}	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
static	O
int	O
looking_at_gnu_locatedb	function
(	O
const	O
char	O
*	O
data	pointer
,	O
size_t	long
len	long
)	O
{	O
if	O
(	O
len	long
<	O
sizeof	O
(	O
LOCATEDB_MAGIC	pointer
)	O
)	O
return	O
0	int
;	O
else	O
if	O
(	O
0	int
==	O
memcmp	function
(	O
data	pointer
,	O
LOCATEDB_MAGIC	pointer
,	O
sizeof	O
(	O
LOCATEDB_MAGIC	pointer
)	O
)	O
)	O
return	O
1	int
;	O
else	O
return	O
0	int
;	O
}	O
static	O
int	O
looking_at_slocate_locatedb	function
(	O
const	O
char	O
*	O
filename	pointer
,	O
const	O
char	O
*	O
data	pointer
,	O
size_t	long
len	long
,	O
int	O
*	O
seclevel	pointer
)	O
{	O
assert	O
(	O
len	long
<=	O
2	int
)	O
;	O
if	O
(	O
len	long
<	O
2	int
)	O
{	O
return	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
0	int
==	O
data	pointer
[	O
1	int
]	O
)	O
{	O
if	O
(	O
isdigit	function
(	O
(	O
unsigned	O
char	O
)	O
data	pointer
[	O
0	int
]	O
)	O
)	O
{	O
*	O
seclevel	pointer
=	O
(	O
data	pointer
[	O
0	int
]	O
-	O
'0'	O
)	O
;	O
if	O
(	O
*	O
seclevel	pointer
>	O
1	int
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"locate database %s looks like an slocate "	pointer
"database but it seems to have security level %c, "	pointer
"which GNU findutils does not currently support"	pointer
)	O
,	O
quotearg_n_style	function
(	O
0	int
,	O
locale_quoting_style	int
,	O
filename	pointer
)	O
,	O
data	pointer
[	O
1	int
]	O
)	O
;	O
return	O
1	int
;	O
}	O
else	O
{	O
return	O
1	int
;	O
}	O
}	O
else	O
{	O
return	O
0	int
;	O
}	O
}	O
else	O
{	O
return	O
0	int
;	O
}	O
}	O
}	O
static	O
int	O
i_am_little_endian	function
(	O
void	O
)	O
{	O
union	O
{	O
unsigned	O
char	O
uch	array
[	O
4	int
]	O
;	O
unsigned	O
int	O
ui	int
;	O
}	O
u	union
;	O
u	union
.	O
ui	int
=	O
0u	int
;	O
u	union
.	O
uch	array
[	O
0	int
]	O
=	O
1	int
;	O
u	union
.	O
uch	array
[	O
1	int
]	O
=	O
u	union
.	O
uch	array
[	O
2	int
]	O
=	O
u	union
.	O
uch	array
[	O
3	int
]	O
=	O
0	int
;	O
return	O
u	union
.	O
ui	int
==	O
1	int
;	O
}	O
static	O
unsigned	O
long	O
search_one_database	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
const	O
char	O
*	O
dbfile	pointer
,	O
FILE	struct
*	O
fp	pointer
,	O
off_t	long
filesize	long
,	O
const	O
struct	O
timespec	struct
*	O
database_mtime	pointer
,	O
int	O
ignore_case	int
,	O
int	O
enable_print	int
,	O
int	O
basename_only	int
,	O
int	O
use_limit	int
,	O
struct	O
locate_limits	struct
*	O
plimit	pointer
,	O
int	O
stats	int
,	O
int	O
op_and	int
,	O
int	O
regex	struct
,	O
int	O
regex_options	int
)	O
{	O
char	O
*	O
pathpart	pointer
;	O
int	O
argn	int
;	O
int	O
nread	int
;	O
struct	O
process_data	struct
procdata	pointer
;	O
int	O
slocate_seclevel	int
;	O
int	O
oldformat	int
;	O
int	O
slocatedb_format	int
;	O
struct	O
visitor	struct
*	O
pvis	pointer
;	O
const	O
char	O
*	O
format_name	pointer
;	O
enum	O
ExistenceCheckType	enum
do_check_existence	enum
;	O
do_check_existence	enum
=	O
check_existence	enum
;	O
if	O
(	O
ignore_case	int
)	O
regex_options	int
|=	O
RE_ICASE	O
;	O
oldformat	int
=	O
0	int
;	O
procdata	pointer
.	O
endian_state	enum
=	O
GetwordEndianStateInitial	int
;	O
procdata	pointer
.	O
len	long
=	O
procdata	pointer
.	O
count	int
=	O
0	int
;	O
procdata	pointer
.	O
dbfile	pointer
=	O
dbfile	pointer
;	O
procdata	pointer
.	O
fp	pointer
=	O
fp	pointer
;	O
inspectors	pointer
=	O
NULL	O
;	O
lastinspector	pointer
=	O
NULL	O
;	O
past_pat_inspector	pointer
=	O
NULL	O
;	O
results_were_filtered	bool
=	O
false	int
;	O
procdata	pointer
.	O
pathsize	long
=	O
128	int
;	O
procdata	pointer
.	O
original_filename	pointer
=	O
xmalloc	function
(	O
procdata	pointer
.	O
pathsize	long
)	O
;	O
nread	int
=	O
fread	function
(	O
procdata	pointer
.	O
original_filename	pointer
,	O
1	int
,	O
SLOCATE_DB_MAGIC_LEN	int
,	O
procdata	pointer
.	O
fp	pointer
)	O
;	O
slocate_seclevel	int
=	O
0	int
;	O
if	O
(	O
looking_at_slocate_locatedb	function
(	O
procdata	pointer
.	O
dbfile	pointer
,	O
procdata	pointer
.	O
original_filename	pointer
,	O
nread	int
,	O
&	O
slocate_seclevel	int
)	O
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s is an slocate database.  "	pointer
"Support for these is new, expect problems for now."	pointer
)	O
,	O
quotearg_n_style	function
(	O
0	int
,	O
locale_quoting_style	int
,	O
procdata	pointer
.	O
dbfile	pointer
)	O
)	O
;	O
if	O
(	O
slocate_seclevel	int
>	O
1	int
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s is an slocate database of unsupported security level %d; skipping it."	pointer
)	O
,	O
quotearg_n_style	function
(	O
0	int
,	O
locale_quoting_style	int
,	O
procdata	pointer
.	O
dbfile	pointer
)	O
,	O
slocate_seclevel	int
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
slocate_seclevel	int
>	O
0	int
)	O
{	O
if	O
(	O
ACCEPT_NON_EXISTING	int
==	O
check_existence	enum
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"You specified the -E option, but that option "	pointer
"cannot be used with slocate-format databases "	pointer
"with a non-zero security level.  No results will be "	pointer
"generated for this database.\n"	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
ACCEPT_EXISTING	int
!=	O
do_check_existence	enum
)	O
{	O
if	O
(	O
enable_print	int
||	O
stats	int
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s is an slocate database.  "	pointer
"Turning on the '-e' option."	pointer
)	O
,	O
quotearg_n_style	function
(	O
0	int
,	O
locale_quoting_style	int
,	O
procdata	pointer
.	O
dbfile	pointer
)	O
)	O
;	O
}	O
do_check_existence	enum
=	O
ACCEPT_EXISTING	int
;	O
}	O
}	O
add_visitor	function
(	O
visit_locate02_format	function
,	O
NULL	O
)	O
;	O
format_name	pointer
=	O
"slocate"	pointer
;	O
slocatedb_format	int
=	O
1	int
;	O
}	O
else	O
{	O
int	O
nread2	int
;	O
slocatedb_format	int
=	O
0	int
;	O
extend	function
(	O
&	O
procdata	pointer
,	O
sizeof	O
(	O
LOCATEDB_MAGIC	pointer
)	O
,	O
0u	int
)	O
;	O
nread2	int
=	O
fread	function
(	O
procdata	pointer
.	O
original_filename	pointer
+	O
nread	int
,	O
1	int
,	O
sizeof	O
(	O
LOCATEDB_MAGIC	pointer
)	O
-	O
nread	int
,	O
procdata	pointer
.	O
fp	pointer
)	O
;	O
if	O
(	O
looking_at_gnu_locatedb	function
(	O
procdata	pointer
.	O
original_filename	pointer
,	O
nread	int
+	O
nread2	int
)	O
)	O
{	O
add_visitor	function
(	O
visit_locate02_format	function
,	O
NULL	O
)	O
;	O
format_name	pointer
=	O
"GNU LOCATE02"	pointer
;	O
}	O
else	O
{	O
int	O
i	int
;	O
nread	int
+=	O
nread2	int
;	O
extend	function
(	O
&	O
procdata	pointer
,	O
256u	int
,	O
0u	int
)	O
;	O
if	O
(	O
nread	int
<	O
256	int
)	O
{	O
int	O
more_read	int
=	O
fread	function
(	O
procdata	pointer
.	O
original_filename	pointer
+	O
nread	int
,	O
1	int
,	O
256	int
-	O
nread	int
,	O
procdata	pointer
.	O
fp	pointer
)	O
;	O
if	O
(	O
(	O
more_read	int
+	O
nread	int
)	O
!=	O
256	int
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"Old-format locate database %s is "	pointer
"too short to be valid"	pointer
)	O
,	O
quotearg_n_style	function
(	O
0	int
,	O
locale_quoting_style	int
,	O
dbfile	pointer
)	O
)	O
;	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
128	int
;	O
i	int
++	O
)	O
{	O
procdata	pointer
.	O
bigram1	array
[	O
i	int
]	O
=	O
procdata	pointer
.	O
original_filename	pointer
[	O
i	int
<<	O
1	int
]	O
;	O
procdata	pointer
.	O
bigram2	array
[	O
i	int
]	O
=	O
procdata	pointer
.	O
original_filename	pointer
[	O
(	O
i	int
<<	O
1	int
)	O
+	O
1	int
]	O
;	O
}	O
format_name	pointer
=	O
"old"	pointer
;	O
oldformat	int
=	O
1	int
;	O
add_visitor	function
(	O
visit_old_format	function
,	O
NULL	O
)	O
;	O
}	O
}	O
if	O
(	O
basename_only	int
)	O
add_visitor	function
(	O
visit_basename	function
,	O
NULL	O
)	O
;	O
for	O
(	O
argn	int
=	O
0	int
;	O
argn	int
<	O
argc	int
;	O
argn	int
++	O
)	O
{	O
results_were_filtered	bool
=	O
true	int
;	O
pathpart	pointer
=	O
argv	pointer
[	O
argn	int
]	O
;	O
if	O
(	O
regex	struct
)	O
{	O
struct	O
regular_expression	struct
*	O
p	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
*	O
p	pointer
)	O
)	O
;	O
const	O
char	O
*	O
error_message	pointer
=	O
NULL	O
;	O
memset	function
(	O
&	O
p	pointer
->	O
regex	struct
,	O
0	int
,	O
sizeof	O
(	O
p	pointer
->	O
regex	struct
)	O
)	O
;	O
re_set_syntax	function
(	O
regex_options	int
)	O
;	O
p	pointer
->	O
regex	struct
.	O
allocated	long
=	O
100	int
;	O
p	pointer
->	O
regex	struct
.	O
buffer	pointer
=	O
xmalloc	function
(	O
p	pointer
->	O
regex	struct
.	O
allocated	long
)	O
;	O
p	pointer
->	O
regex	struct
.	O
fastmap	pointer
=	O
NULL	O
;	O
p	pointer
->	O
regex	struct
.	O
syntax	long
=	O
regex_options	int
;	O
p	pointer
->	O
regex	struct
.	O
translate	pointer
=	O
NULL	O
;	O
error_message	pointer
=	O
re_compile_pattern	function
(	O
pathpart	pointer
,	O
strlen	function
(	O
pathpart	pointer
)	O
,	O
&	O
p	pointer
->	O
regex	struct
)	O
;	O
if	O
(	O
error_message	pointer
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"%s"	pointer
,	O
error_message	pointer
)	O
;	O
}	O
else	O
{	O
add_visitor	function
(	O
visit_regex	function
,	O
p	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
contains_metacharacter	function
(	O
pathpart	pointer
)	O
)	O
{	O
if	O
(	O
ignore_case	int
)	O
add_visitor	function
(	O
visit_globmatch_casefold	function
,	O
pathpart	pointer
)	O
;	O
else	O
add_visitor	function
(	O
visit_globmatch_nofold	function
,	O
pathpart	pointer
)	O
;	O
}	O
else	O
{	O
visitfunc	pointer
matcher	pointer
;	O
if	O
(	O
1	int
==	O
MB_CUR_MAX	O
)	O
{	O
matcher	pointer
=	O
ignore_case	int
?	O
visit_substring_match_casefold_narrow	function
:	O
visit_substring_match_nocasefold_narrow	function
;	O
}	O
else	O
{	O
matcher	pointer
=	O
ignore_case	int
?	O
visit_substring_match_casefold_wide	function
:	O
visit_substring_match_nocasefold_wide	function
;	O
}	O
add_visitor	function
(	O
matcher	pointer
,	O
pathpart	pointer
)	O
;	O
}	O
}	O
pvis	pointer
=	O
lastinspector	pointer
;	O
switch	O
(	O
do_check_existence	enum
)	O
{	O
case	O
ACCEPT_EXISTING	int
:	O
results_were_filtered	bool
=	O
true	int
;	O
if	O
(	O
follow_symlinks	int
)	O
add_visitor	function
(	O
visit_existing_follow	function
,	O
NULL	O
)	O
;	O
else	O
add_visitor	function
(	O
visit_existing_nofollow	function
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
ACCEPT_NON_EXISTING	int
:	O
results_were_filtered	bool
=	O
true	int
;	O
if	O
(	O
follow_symlinks	int
)	O
add_visitor	function
(	O
visit_non_existing_follow	function
,	O
NULL	O
)	O
;	O
else	O
add_visitor	function
(	O
visit_non_existing_nofollow	function
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
ACCEPT_EITHER	int
:	O
break	O
;	O
}	O
if	O
(	O
stats	int
)	O
add_visitor	function
(	O
visit_stats	function
,	O
&	O
statistics	struct
)	O
;	O
if	O
(	O
enable_print	int
)	O
{	O
if	O
(	O
print_quoted_filename	bool
)	O
add_visitor	function
(	O
visit_justprint_quoted	function
,	O
NULL	O
)	O
;	O
else	O
add_visitor	function
(	O
visit_justprint_unquoted	function
,	O
NULL	O
)	O
;	O
}	O
if	O
(	O
use_limit	int
)	O
add_visitor	function
(	O
visit_limit	function
,	O
plimit	pointer
)	O
;	O
else	O
add_visitor	function
(	O
visit_count	function
,	O
plimit	pointer
)	O
;	O
if	O
(	O
argc	int
>	O
1	int
)	O
{	O
past_pat_inspector	pointer
=	O
pvis	pointer
->	O
next	pointer
;	O
if	O
(	O
op_and	int
)	O
mainprocessor	pointer
=	O
process_and	function
;	O
else	O
mainprocessor	pointer
=	O
process_or	function
;	O
}	O
else	O
mainprocessor	pointer
=	O
process_simple	function
;	O
if	O
(	O
stats	int
)	O
{	O
printf	function
(	O
_	O
(	O
"Database %s is in the %s format.\n"	pointer
)	O
,	O
procdata	pointer
.	O
dbfile	pointer
,	O
format_name	pointer
)	O
;	O
}	O
procdata	pointer
.	O
c	char
=	O
getc	function
(	O
procdata	pointer
.	O
fp	pointer
)	O
;	O
if	O
(	O
slocatedb_format	int
&&	O
(	O
procdata	pointer
.	O
c	char
!=	O
EOF	O
)	O
)	O
{	O
ungetc	function
(	O
procdata	pointer
.	O
c	char
,	O
procdata	pointer
.	O
fp	pointer
)	O
;	O
procdata	pointer
.	O
c	char
=	O
0	int
;	O
}	O
while	O
(	O
(	O
procdata	pointer
.	O
c	char
!=	O
EOF	O
)	O
&&	O
(	O
VISIT_ABORT	int
!=	O
(	O
mainprocessor	pointer
)	O
(	O
&	O
procdata	pointer
)	O
)	O
)	O
{	O
}	O
if	O
(	O
stats	int
)	O
{	O
if	O
(	O
oldformat	int
)	O
{	O
int	O
host_little_endian	int
=	O
i_am_little_endian	function
(	O
)	O
;	O
const	O
char	O
*	O
little	pointer
=	O
_	O
(	O
"The database has little-endian "	pointer
"machine-word encoding.\n"	pointer
)	O
;	O
const	O
char	O
*	O
big	pointer
=	O
_	O
(	O
"The database has big-endian "	pointer
"machine-word encoding.\n"	pointer
)	O
;	O
if	O
(	O
GetwordEndianStateNative	int
==	O
procdata	pointer
.	O
endian_state	enum
)	O
{	O
printf	function
(	O
"%s"	pointer
,	O
(	O
host_little_endian	int
?	O
little	pointer
:	O
big	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
GetwordEndianStateSwab	int
==	O
procdata	pointer
.	O
endian_state	enum
)	O
{	O
printf	function
(	O
"%s"	pointer
,	O
(	O
host_little_endian	int
?	O
big	pointer
:	O
little	pointer
)	O
)	O
;	O
}	O
else	O
{	O
printf	function
(	O
_	O
(	O
"The database machine-word encoding order "	pointer
"is not obvious.\n"	pointer
)	O
)	O
;	O
}	O
}	O
if	O
(	O
filesize	long
||	O
(	O
database_mtime	pointer
!=	O
NULL	O
)	O
)	O
print_stats	function
(	O
argc	int
,	O
filesize	long
,	O
database_mtime	pointer
)	O
;	O
}	O
if	O
(	O
ferror	function
(	O
procdata	pointer
.	O
fp	pointer
)	O
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
"%s"	pointer
,	O
quotearg_n_style	function
(	O
0	int
,	O
locale_quoting_style	int
,	O
procdata	pointer
.	O
dbfile	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
return	O
plimit	pointer
->	O
items_accepted	long
;	O
}	O
extern	O
char	O
*	O
version_string	pointer
;	O
static	O
void	O
usage	function
(	O
FILE	struct
*	O
stream	pointer
)	O
{	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"Usage: %s [-d path | --database=path] [-e | -E | --[non-]existing]\n      [-i | --ignore-case] [-w | --wholename] [-b | --basename] \n      [--limit=N | -l N] [-S | --statistics] [-0 | --null] [-c | --count]\n      [-P | -H | --nofollow] [-L | --follow] [-m | --mmap] [-s | --stdio]\n      [-A | --all] [-p | --print] [-r | --regex] [--regextype=TYPE]\n      [--max-database-age D] [--version] [--help]\n      pattern...\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
fputs	function
(	O
_	O
(	O
"\nReport bugs to <bug-findutils@gnu.org>.\n"	pointer
)	O
,	O
stream	pointer
)	O
;	O
}	O
enum	O
{	O
REGEXTYPE_OPTION	int
=	O
CHAR_MAX	O
+	O
1	int
,	O
MAX_DB_AGE	int
}	O
;	O
static	O
struct	O
option	struct
const	O
longopts	array
[	O
]	O
=	O
{	O
{	O
"database"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'd'	O
}	O
,	O
{	O
"existing"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'e'	O
}	O
,	O
{	O
"non-existing"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'E'	O
}	O
,	O
{	O
"ignore-case"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'i'	O
}	O
,	O
{	O
"all"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'A'	O
}	O
,	O
{	O
"help"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'h'	O
}	O
,	O
{	O
"version"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'v'	O
}	O
,	O
{	O
"null"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'0'	O
}	O
,	O
{	O
"count"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'c'	O
}	O
,	O
{	O
"wholename"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'w'	O
}	O
,	O
{	O
"wholepath"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'w'	O
}	O
,	O
{	O
"basename"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'b'	O
}	O
,	O
{	O
"print"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'p'	O
}	O
,	O
{	O
"stdio"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
's'	O
}	O
,	O
{	O
"mmap"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'm'	O
}	O
,	O
{	O
"limit"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'l'	O
}	O
,	O
{	O
"regex"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'r'	O
}	O
,	O
{	O
"regextype"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
REGEXTYPE_OPTION	int
}	O
,	O
{	O
"statistics"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'S'	O
}	O
,	O
{	O
"follow"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'L'	O
}	O
,	O
{	O
"nofollow"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'P'	O
}	O
,	O
{	O
"max-database-age"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
MAX_DB_AGE	int
}	O
,	O
{	O
NULL	O
,	O
no_argument	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
int	O
drop_privs	function
(	O
void	O
)	O
{	O
const	O
char	O
*	O
what	pointer
=	O
"failed"	pointer
;	O
const	O
uid_t	int
orig_euid	int
=	O
geteuid	function
(	O
)	O
;	O
const	O
uid_t	int
uid	int
=	O
getuid	function
(	O
)	O
;	O
const	O
gid_t	int
gid	int
=	O
getgid	function
(	O
)	O
;	O
if	O
(	O
0	int
==	O
orig_euid	int
)	O
{	O
gid_t	int
groups	array
[	O
1	int
]	O
;	O
groups	array
[	O
0	int
]	O
=	O
gid	int
;	O
if	O
(	O
0	int
!=	O
setgroups	function
(	O
1u	int
,	O
groups	array
)	O
)	O
{	O
what	pointer
=	O
_	O
(	O
"failed to drop group privileges"	pointer
)	O
;	O
goto	O
fail	O
;	O
}	O
}	O
if	O
(	O
uid	int
!=	O
orig_euid	int
)	O
{	O
if	O
(	O
0	int
==	O
uid	int
)	O
{	O
}	O
else	O
{	O
errno	O
=	O
0	int
;	O
if	O
(	O
0	int
!=	O
setuid	function
(	O
getuid	function
(	O
)	O
)	O
)	O
{	O
what	pointer
=	O
_	O
(	O
"failed to drop setuid privileges"	pointer
)	O
;	O
goto	O
fail	O
;	O
}	O
else	O
{	O
if	O
(	O
0	int
==	O
setuid	function
(	O
0	int
)	O
)	O
{	O
what	pointer
=	O
_	O
(	O
"Failed to fully drop privileges"	pointer
)	O
;	O
errno	O
=	O
0	int
;	O
goto	O
fail	O
;	O
}	O
}	O
}	O
}	O
errno	O
=	O
0	int
;	O
if	O
(	O
0	int
!=	O
setgid	function
(	O
gid	int
)	O
)	O
{	O
what	pointer
=	O
_	O
(	O
"failed to drop setgid privileges"	pointer
)	O
;	O
goto	O
fail	O
;	O
}	O
return	O
0	int
;	O
fail	O
:	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"%s"	pointer
,	O
quotearg_n_style	function
(	O
0	int
,	O
locale_quoting_style	int
,	O
what	pointer
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
kill	function
(	O
0	int
,	O
SIGKILL	int
)	O
;	O
_exit	function
(	O
1	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
}	O
}	O
static	O
int	O
opendb	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
int	O
fd	int
=	O
open	function
(	O
name	pointer
,	O
O_RDONLY	int
|	O
O_LARGEFILE	O
)	O
;	O
if	O
(	O
fd	int
>=	O
0	int
)	O
{	O
if	O
(	O
0	int
!=	O
fcntl	function
(	O
fd	int
,	O
F_SETFD	int
,	O
FD_CLOEXEC	int
)	O
)	O
{	O
close	pointer
(	O
fd	int
)	O
;	O
fd	int
=	O
-	O
1	int
;	O
}	O
}	O
return	O
fd	int
;	O
}	O
static	O
void	O
cleanup_quote_opts	function
(	O
void	O
)	O
{	O
free	function
(	O
quote_opts	pointer
)	O
;	O
}	O
int	O
dolocate	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
int	O
secure_db_fd	int
)	O
{	O
char	O
*	O
path_element	pointer
=	O
NULL	O
;	O
size_t	long
path_element_pos	long
,	O
path_element_len	long
;	O
const	O
char	O
*	O
user_selected_locate_path	pointer
;	O
const	O
char	O
*	O
db_name	pointer
;	O
const	O
char	O
*	O
path_separators	pointer
=	O
":"	pointer
;	O
unsigned	O
long	O
int	O
found	long
=	O
0uL	int
;	O
int	O
ignore_case	int
=	O
0	int
;	O
int	O
print	int
=	O
0	int
;	O
int	O
just_count	int
=	O
0	int
;	O
int	O
basename_only	int
=	O
0	int
;	O
int	O
use_limit	int
=	O
0	int
;	O
int	O
regex	struct
=	O
0	int
;	O
int	O
regex_options	int
=	O
RE_SYNTAX_EMACS	int
;	O
int	O
stats	int
=	O
0	int
;	O
int	O
op_and	int
=	O
0	int
;	O
FILE	struct
*	O
fp	pointer
;	O
bool	bool
did_stdin	bool
=	O
false	int
;	O
if	O
(	O
argv	pointer
[	O
0	int
]	O
)	O
set_program_name	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
else	O
set_program_name	function
(	O
"locate"	pointer
)	O
;	O
setlocale	function
(	O
LC_ALL	O
,	O
""	pointer
)	O
;	O
bindtextdomain	function
(	O
PACKAGE	pointer
,	O
LOCALEDIR	O
)	O
;	O
textdomain	function
(	O
PACKAGE	pointer
)	O
;	O
quote_opts	pointer
=	O
clone_quoting_options	function
(	O
NULL	O
)	O
;	O
if	O
(	O
atexit	function
(	O
close_stdout	function
)	O
||	O
atexit	function
(	O
cleanup_quote_opts	function
)	O
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"The atexit library function failed"	pointer
)	O
)	O
;	O
}	O
limits	struct
.	O
limit	long
=	O
0	int
;	O
limits	struct
.	O
items_accepted	long
=	O
0	int
;	O
print_quoted_filename	bool
=	O
true	int
;	O
user_selected_locate_path	pointer
=	O
getenv	function
(	O
"LOCATE_PATH"	pointer
)	O
;	O
check_existence	enum
=	O
ACCEPT_EITHER	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
opti	int
=	O
-	O
1	int
;	O
int	O
optc	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
"Abcd:eEil:prsm0SwHPL"	pointer
,	O
longopts	array
,	O
&	O
opti	int
)	O
;	O
if	O
(	O
optc	int
==	O
-	O
1	int
)	O
break	O
;	O
switch	O
(	O
optc	int
)	O
{	O
case	O
'0'	O
:	O
separator	int
=	O
0	int
;	O
print_quoted_filename	bool
=	O
false	int
;	O
break	O
;	O
case	O
'A'	O
:	O
op_and	int
=	O
1	int
;	O
break	O
;	O
case	O
'b'	O
:	O
basename_only	int
=	O
1	int
;	O
break	O
;	O
case	O
'c'	O
:	O
just_count	int
=	O
1	int
;	O
break	O
;	O
case	O
'd'	O
:	O
user_selected_locate_path	pointer
=	O
optarg	pointer
;	O
assert	O
(	O
optarg	pointer
!=	O
NULL	O
)	O
;	O
break	O
;	O
case	O
'e'	O
:	O
check_existence	enum
=	O
ACCEPT_EXISTING	int
;	O
break	O
;	O
case	O
'E'	O
:	O
check_existence	enum
=	O
ACCEPT_NON_EXISTING	int
;	O
break	O
;	O
case	O
'i'	O
:	O
ignore_case	int
=	O
1	int
;	O
break	O
;	O
case	O
'h'	O
:	O
usage	function
(	O
stdout	pointer
)	O
;	O
return	O
0	int
;	O
case	O
MAX_DB_AGE	int
:	O
set_max_db_age	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'p'	O
:	O
print	int
=	O
1	int
;	O
break	O
;	O
case	O
'v'	O
:	O
display_findutils_version	function
(	O
"locate"	pointer
)	O
;	O
return	O
0	int
;	O
case	O
'w'	O
:	O
basename_only	int
=	O
0	int
;	O
break	O
;	O
case	O
'r'	O
:	O
regex	struct
=	O
1	int
;	O
break	O
;	O
case	O
REGEXTYPE_OPTION	int
:	O
regex_options	int
=	O
get_regex_type	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'S'	O
:	O
stats	int
=	O
1	int
;	O
break	O
;	O
case	O
'L'	O
:	O
follow_symlinks	int
=	O
1	int
;	O
break	O
;	O
case	O
'P'	O
:	O
case	O
'H'	O
:	O
follow_symlinks	int
=	O
0	int
;	O
break	O
;	O
case	O
'l'	O
:	O
{	O
char	O
*	O
end	pointer
=	O
optarg	pointer
;	O
strtol_error	enum
err	long
=	O
xstrtoumax	function
(	O
optarg	pointer
,	O
&	O
end	pointer
,	O
10	int
,	O
&	O
limits	struct
.	O
limit	long
,	O
NULL	O
)	O
;	O
if	O
(	O
LONGINT_OK	int
!=	O
err	long
)	O
xstrtol_fatal	function
(	O
err	long
,	O
opti	int
,	O
optc	int
,	O
longopts	array
,	O
optarg	pointer
)	O
;	O
use_limit	int
=	O
1	int
;	O
}	O
break	O
;	O
case	O
's'	O
:	O
case	O
'm'	O
:	O
break	O
;	O
default	O
:	O
usage	function
(	O
stderr	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
if	O
(	O
user_selected_locate_path	pointer
)	O
{	O
if	O
(	O
secure_db_fd	int
>=	O
0	int
)	O
{	O
close	pointer
(	O
secure_db_fd	int
)	O
;	O
secure_db_fd	int
=	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
!	O
just_count	int
&&	O
!	O
stats	int
)	O
print	int
=	O
1	int
;	O
if	O
(	O
stats	int
)	O
{	O
if	O
(	O
optind	int
==	O
argc	int
)	O
use_limit	int
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
just_count	int
&&	O
optind	int
==	O
argc	int
)	O
{	O
usage	function
(	O
stderr	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
if	O
(	O
1	int
==	O
isatty	function
(	O
STDOUT_FILENO	int
)	O
)	O
stdout_is_a_tty	bool
=	O
true	int
;	O
else	O
stdout_is_a_tty	bool
=	O
false	int
;	O
if	O
(	O
user_selected_locate_path	pointer
)	O
{	O
splitstring	function
(	O
user_selected_locate_path	pointer
,	O
path_separators	pointer
,	O
true	int
,	O
&	O
path_element_pos	long
,	O
&	O
path_element_len	long
)	O
;	O
}	O
while	O
(	O
!	O
use_limit	int
||	O
limits	struct
.	O
limit	long
>	O
limits	struct
.	O
items_accepted	long
)	O
{	O
struct	O
stat	struct
st	pointer
;	O
struct	O
timespec	struct
database_mtime	pointer
;	O
int	O
have_mtime	int
;	O
int	O
fd	int
;	O
off_t	long
filesize	long
;	O
statistics	struct
.	O
compressed_bytes	long
=	O
statistics	struct
.	O
total_filename_count	long
=	O
statistics	struct
.	O
total_filename_length	long
=	O
statistics	struct
.	O
whitespace_count	long
=	O
statistics	struct
.	O
newline_count	long
=	O
statistics	struct
.	O
highbit_filename_count	long
=	O
0u	int
;	O
if	O
(	O
user_selected_locate_path	pointer
)	O
{	O
if	O
(	O
1	int
==	O
path_element_len	long
&&	O
'-'	O
==	O
user_selected_locate_path	pointer
[	O
path_element_pos	long
]	O
)	O
{	O
if	O
(	O
did_stdin	bool
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"warning: the locate database can only be read from stdin once."	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
db_name	pointer
=	O
"<stdin>"	pointer
;	O
fd	int
=	O
0	int
;	O
did_stdin	bool
=	O
true	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
0	int
==	O
path_element_len	long
||	O
(	O
1	int
==	O
path_element_len	long
&&	O
'.'	O
==	O
user_selected_locate_path	pointer
[	O
path_element_pos	long
]	O
)	O
)	O
{	O
db_name	pointer
=	O
LOCATE_DB	O
;	O
}	O
else	O
{	O
path_element	pointer
=	O
strndup	function
(	O
&	O
user_selected_locate_path	pointer
[	O
path_element_pos	long
]	O
,	O
path_element_len	long
)	O
;	O
db_name	pointer
=	O
path_element	pointer
;	O
}	O
fd	int
=	O
opendb	function
(	O
db_name	pointer
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
"%s"	pointer
,	O
quotearg_n_style	function
(	O
0	int
,	O
locale_quoting_style	int
,	O
db_name	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
-	O
1	int
==	O
secure_db_fd	int
)	O
{	O
break	O
;	O
}	O
else	O
{	O
db_name	pointer
=	O
selected_secure_db	pointer
;	O
fd	int
=	O
secure_db_fd	int
;	O
secure_db_fd	int
=	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
fstat	function
(	O
fd	int
,	O
&	O
st	pointer
)	O
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
"%s"	pointer
,	O
quotearg_n_style	function
(	O
0	int
,	O
locale_quoting_style	int
,	O
db_name	pointer
)	O
)	O
;	O
filesize	long
=	O
(	O
off_t	long
)	O
0	int
;	O
have_mtime	int
=	O
0	int
;	O
}	O
else	O
{	O
time_t	long
now	long
;	O
filesize	long
=	O
st	pointer
.	O
st_size	long
;	O
database_mtime	pointer
=	O
get_stat_mtime	function
(	O
&	O
st	pointer
)	O
;	O
have_mtime	int
=	O
1	int
;	O
if	O
(	O
(	O
time_t	long
)	O
-	O
1	int
==	O
time	struct
(	O
&	O
now	long
)	O
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"time system call failed"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
double	O
age	double
=	O
difftime	function
(	O
now	long
,	O
st	pointer
.	O
st_mtime	O
)	O
;	O
double	O
warn_seconds	double
=	O
SECONDS_PER_UNIT	O
*	O
warn_number_units	int
;	O
if	O
(	O
age	double
>	O
warn_seconds	double
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"warning: database %s is more than %d %s old (actual age is %.1f %s)"	pointer
)	O
,	O
quotearg_n_style	function
(	O
0	int
,	O
locale_quoting_style	int
,	O
db_name	pointer
)	O
,	O
warn_number_units	int
,	O
_	O
(	O
warn_name_units	array
)	O
,	O
(	O
age	double
/	O
(	O
double	O
)	O
SECONDS_PER_UNIT	O
)	O
,	O
_	O
(	O
warn_name_units	array
)	O
)	O
;	O
}	O
}	O
}	O
fp	pointer
=	O
fdopen	function
(	O
fd	int
,	O
"r"	pointer
)	O
;	O
if	O
(	O
NULL	O
==	O
fp	pointer
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
"%s"	pointer
,	O
quotearg_n_style	function
(	O
0	int
,	O
locale_quoting_style	int
,	O
db_name	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
found	long
=	O
search_one_database	function
(	O
argc	int
-	O
optind	int
,	O
&	O
argv	pointer
[	O
optind	int
]	O
,	O
db_name	pointer
,	O
fp	pointer
,	O
filesize	long
,	O
have_mtime	int
?	O
(	O
&	O
database_mtime	pointer
)	O
:	O
NULL	O
,	O
ignore_case	int
,	O
print	int
,	O
basename_only	int
,	O
use_limit	int
,	O
&	O
limits	struct
,	O
stats	int
,	O
op_and	int
,	O
regex	struct
,	O
regex_options	int
)	O
;	O
if	O
(	O
fclose	function
(	O
fp	pointer
)	O
==	O
EOF	O
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
"%s"	pointer
,	O
quotearg_n_style	function
(	O
0	int
,	O
locale_quoting_style	int
,	O
db_name	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
path_element	pointer
)	O
{	O
free	function
(	O
path_element	pointer
)	O
;	O
path_element	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
!	O
user_selected_locate_path	pointer
)	O
{	O
break	O
;	O
}	O
else	O
if	O
(	O
!	O
splitstring	function
(	O
user_selected_locate_path	pointer
,	O
path_separators	pointer
,	O
false	int
,	O
&	O
path_element_pos	long
,	O
&	O
path_element_len	long
)	O
)	O
{	O
break	O
;	O
}	O
}	O
if	O
(	O
just_count	int
)	O
{	O
printf	function
(	O
"%ld\n"	pointer
,	O
found	long
)	O
;	O
}	O
if	O
(	O
found	long
||	O
(	O
use_limit	int
&&	O
(	O
limits	struct
.	O
limit	long
==	O
0	int
)	O
)	O
||	O
stats	int
)	O
return	O
0	int
;	O
else	O
return	O
1	int
;	O
}	O
static	O
int	O
open_secure_db	function
(	O
void	O
)	O
{	O
int	O
fd	int
,	O
i	int
;	O
const	O
char	O
*	O
secure_db_list	array
[	O
]	O
=	O
{	O
LOCATE_DB	O
,	O
"/var/lib/slocate/slocate.db"	pointer
,	O
NULL	O
}	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
secure_db_list	array
[	O
i	int
]	O
;	O
++	O
i	int
)	O
{	O
fd	int
=	O
opendb	function
(	O
secure_db_list	array
[	O
i	int
]	O
)	O
;	O
if	O
(	O
fd	int
>=	O
0	int
)	O
{	O
selected_secure_db	pointer
=	O
secure_db_list	array
[	O
i	int
]	O
;	O
return	O
fd	int
;	O
}	O
}	O
return	O
-	O
1	int
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
dbfd	int
=	O
open_secure_db	function
(	O
)	O
;	O
drop_privs	function
(	O
)	O
;	O
return	O
dolocate	function
(	O
argc	int
,	O
argv	pointer
,	O
dbfd	int
)	O
;	O
}	O
