static	O
void	O
usage	function
(	O
char	O
*	O
progname	pointer
,	O
FILE	struct
*	O
)	O
;	O
static	O
int	O
G_OFD	int
;	O
YYSTYPE	union
yylval	union
;	O
int	O
yydebug	int
=	O
0	int
;	O
int	O
swlex_definition_file	int
=	O
SW_PSF	int
;	O
static	O
void	O
show_version	function
(	O
FILE	struct
*	O
fp	pointer
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"lxpsf (swbis) version "	pointer
SWBIS_RELEASE	pointer
"\n"	pointer
)	O
;	O
}	O
static	O
void	O
copyright_info	function
(	O
FILE	struct
*	O
fp	pointer
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"%s"	pointer
,	O
"Copyright (C) 2003,2004,2005,2007,2014 Jim Lowe\n"	pointer
"This software is distributed under the terms of the GNU General Public License\n"	pointer
"and comes with NO WARRANTY to the extent permitted by law.\n"	pointer
"See the file named COPYING for details.\n"	pointer
)	O
;	O
}	O
static	O
void	O
usage	function
(	O
char	O
*	O
progname	pointer
,	O
FILE	struct
*	O
fp	pointer
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"Usage: lxpsf [options] [file]\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"Read any format (RPM,DEB,slackware) package and write a tar archive\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"to stdout that is able to be converted to a POSIX package by swpackage\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"when installed in the file system.  GNU swpackage has a special\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"feature to read a tar archive in memory as a file system (See below).\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"Currently the following package formats are supported:\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"    RPM v3 (source and binary), Debian Package Format (Deb v2.0),\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"    Slackware runtime tarballs, and plain vanilla tarballs\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"   --psf-form1  default form, full control directories\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"   --psf-form2  include path name prefix in archive\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"   --psf-form3  no control directories, with path name prefix\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"   --slackware-pkg-name=NAME  Tarball filename.\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"   --deb-control   write uncompressed control.tar.gz tar file to stdout.\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"   --deb-data   write uncompressed data.tar.gz tar file to stdout.\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"   --create-time=cal_time  Use this time for archive header times\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"   --owner=NAME  package owner\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"   --group=NAME  package group\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"   --exclude=NAME  add exclude directive to the PSF\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"   --exclude-system-dirs  exclude all system directories, such as /usr, /usr/bin,...\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"   -d, --debug-level=TYPE    always use 'link'\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"   -D checkdigest  checkdigest script, applies to plain tarball translation.\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"   -x, --use-recursive-fileset Use \"file *\" instead of individual file definitions.\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"   -r, --no-leading-path   use \".\" as the leading archive path\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"   -B buffertype   mem or file  Mem is default.\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"   -H format     archive format: ustar, pax, newc, crc, odc (pax is default)\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"   -p, --psf-only   Write the PSF to stdout.\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"   -o, --info-only   Write the INFO file for the rpm archive.\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"   -r, --no-leading-path.\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"   -L, --smart-leading-path  Use leading path for srpm and not rpm.\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"   --construct-missing-files  Applies to RPM translation. Construct zero length\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"                   files for header entries that have no files in the archive.\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"   -v verbose messages about the translation.\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\n"	pointer
"Howto use with GNU swpackage:\n"	pointer
"\n"	pointer
"  cat your.rpm | lxpsf --psf-form3 -H ustar | swpackage -Wsource=- -s@PSF | tar tvf -\n"	pointer
"  cat your.deb | lxpsf | swpackage -Wsource=- -s@PSF | tar tvf -\n"	pointer
"    # Note: you may also install the ouput of lxpsf with tar into the file\n"	pointer
"    #       system, then run from that directory run swpackage normally.\n"	pointer
"\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"lxpsf is an implementation extension utility of the GNU swbis project\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"Report bugs to <bug-swbis@gnu.org>\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\n"	pointer
)	O
;	O
show_version	function
(	O
fp	pointer
)	O
;	O
copyright_info	function
(	O
fp	pointer
)	O
;	O
}	O
static	O
void	O
add_system_dirs	function
(	O
STRAR	struct
*	O
exclude_list	pointer
)	O
{	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/"	pointer
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/tmp"	pointer
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/var"	pointer
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/var/spool"	pointer
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/var/log"	pointer
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/etc"	pointer
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/etc/init.d"	pointer
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/usr"	pointer
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/bin"	pointer
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/sbin"	pointer
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/opt"	pointer
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/usr/sbin"	pointer
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/usr/bin"	pointer
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/usr/man"	pointer
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/usr/lib"	pointer
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/usr/info"	pointer
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/usr/doc"	pointer
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/usr/X11R6"	pointer
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/usr/man/man1"	pointer
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/usr/man/man2"	pointer
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/usr/man/man3"	pointer
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/usr/man/man4"	pointer
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/usr/man/man5"	pointer
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/usr/man/man6"	pointer
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/usr/man/man7"	pointer
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/usr/man/man8"	pointer
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/usr/share"	pointer
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/usr/share/man/man1"	pointer
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/usr/share/man/man2"	pointer
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/usr/share/man/man3"	pointer
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/usr/share/man/man4"	pointer
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/usr/share/man/man5"	pointer
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/usr/share/man/man6"	pointer
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/usr/share/man/man7"	pointer
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/usr/share/man/man8"	pointer
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/lib"	pointer
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
"/libexec"	pointer
)	O
;	O
}	O
static	O
int	O
write_slack	function
(	O
TOPSF	struct
*	O
topsf	pointer
)	O
{	O
int	O
ret	int
;	O
int	O
psffd	int
;	O
int	O
nfd	int
;	O
TARU	struct
*	O
taru	pointer
;	O
ETAR	struct
*	O
etar	pointer
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
psffd	int
=	O
swlib_open_memfd	function
(	O
)	O
;	O
ret	int
=	O
topsf_write_psf	function
(	O
topsf	pointer
,	O
psffd	int
,	O
1	int
)	O
;	O
uxfio_lseek	function
(	O
psffd	int
,	O
0	int
,	O
SEEK_SET	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
nfd	int
=	O
G_OFD	int
;	O
ret	int
=	O
uxfio_fcntl	function
(	O
topsf	pointer
->	O
fd_	int
,	O
UXFIO_F_ARM_AUTO_DISABLE	O
,	O
1	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
{	O
E_DEBUG	O
(	O
"error"	pointer
)	O
;	O
}	O
ret	int
=	O
uxfio_lseek	function
(	O
topsf	pointer
->	O
fd_	int
,	O
0	int
,	O
SEEK_SET	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
{	O
E_DEBUG2	O
(	O
"%s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
swlib_pump_amount	function
(	O
nfd	int
,	O
topsf	pointer
->	O
fd_	int
,	O
TARRECORDSIZE	int
)	O
;	O
taru	pointer
=	O
taru_create	function
(	O
)	O
;	O
etar	pointer
=	O
etar_open	function
(	O
taru	pointer
->	O
taru_tarheaderflagsM	int
)	O
;	O
etar_init_hdr	function
(	O
etar	pointer
)	O
;	O
etar_set_size_from_fd	function
(	O
etar	pointer
,	O
psffd	int
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
;	O
etar_set_pathname	function
(	O
etar	pointer
,	O
"PSF"	pointer
)	O
;	O
etar_set_uname	function
(	O
etar	pointer
,	O
"root"	pointer
)	O
;	O
etar_set_gname	function
(	O
etar	pointer
,	O
"root"	pointer
)	O
;	O
etar_set_typeflag	function
(	O
etar	pointer
,	O
REGTYPE	char
)	O
;	O
etar_set_mode_ul	function
(	O
etar	pointer
,	O
(	O
unsigned	O
int	O
)	O
(	O
0644	int
)	O
)	O
;	O
etar_set_chksum	function
(	O
etar	pointer
)	O
;	O
etar_emit_header	function
(	O
etar	pointer
,	O
nfd	int
)	O
;	O
etar_emit_data_from_fd	function
(	O
etar	pointer
,	O
nfd	int
,	O
psffd	int
)	O
;	O
taru_delete	function
(	O
taru	pointer
)	O
;	O
ret	int
=	O
swlib_pipe_pump	function
(	O
nfd	int
,	O
topsf	pointer
->	O
fd_	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
write_plain_source_tarball	function
(	O
TOPSF	struct
*	O
topsf	pointer
)	O
{	O
int	O
ret	int
;	O
int	O
psffd	int
;	O
int	O
digfd	int
;	O
int	O
nfd	int
;	O
STROB	struct
*	O
namebuf	pointer
;	O
TARU	struct
*	O
taru	pointer
;	O
ETAR	struct
*	O
etar	pointer
;	O
SWVARFS	struct
*	O
swvarfs	pointer
;	O
XFORMAT	struct
*	O
xformat	pointer
;	O
struct	O
stat	struct
st	pointer
;	O
char	O
*	O
name	pointer
;	O
int	O
nullfd	int
;	O
nullfd	int
=	O
open	function
(	O
"/dev/null"	pointer
,	O
O_RDWR	int
,	O
0	int
)	O
;	O
namebuf	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
psffd	int
=	O
swlib_open_memfd	function
(	O
)	O
;	O
ret	int
=	O
topsf_write_psf	function
(	O
topsf	pointer
,	O
psffd	int
,	O
1	int
)	O
;	O
uxfio_lseek	function
(	O
psffd	int
,	O
0	int
,	O
SEEK_SET	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
nfd	int
=	O
G_OFD	int
;	O
ret	int
=	O
uxfio_fcntl	function
(	O
topsf	pointer
->	O
fd_	int
,	O
UXFIO_F_ARM_AUTO_DISABLE	O
,	O
1	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
{	O
E_DEBUG	O
(	O
"error"	pointer
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	int
=	O
uxfio_lseek	function
(	O
topsf	pointer
->	O
fd_	int
,	O
0	int
,	O
SEEK_SET	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
{	O
E_DEBUG2	O
(	O
"%s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
taru	pointer
=	O
taru_create	function
(	O
)	O
;	O
etar	pointer
=	O
etar_open	function
(	O
taru	pointer
->	O
taru_tarheaderflagsM	int
)	O
;	O
etar_init_hdr	function
(	O
etar	pointer
)	O
;	O
etar_set_size_from_fd	function
(	O
etar	pointer
,	O
psffd	int
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
;	O
etar_set_pathname	function
(	O
etar	pointer
,	O
"PSF"	pointer
)	O
;	O
etar_set_uname	function
(	O
etar	pointer
,	O
"root"	pointer
)	O
;	O
etar_set_gname	function
(	O
etar	pointer
,	O
"root"	pointer
)	O
;	O
etar_set_time	function
(	O
etar	pointer
,	O
time	struct
(	O
NULL	O
)	O
)	O
;	O
etar_set_typeflag	function
(	O
etar	pointer
,	O
REGTYPE	char
)	O
;	O
etar_set_mode_ul	function
(	O
etar	pointer
,	O
(	O
unsigned	O
int	O
)	O
(	O
0644	int
)	O
)	O
;	O
etar_set_chksum	function
(	O
etar	pointer
)	O
;	O
etar_emit_header	function
(	O
etar	pointer
,	O
nfd	int
)	O
;	O
etar_emit_data_from_fd	function
(	O
etar	pointer
,	O
nfd	int
,	O
psffd	int
)	O
;	O
if	O
(	O
topsf	pointer
->	O
checkdigestnameM	pointer
)	O
{	O
digfd	int
=	O
open	function
(	O
topsf	pointer
->	O
checkdigestnameM	pointer
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
digfd	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: %s: %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
topsf	pointer
->	O
checkdigestnameM	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
etar_init_hdr	function
(	O
etar	pointer
)	O
;	O
etar_set_size_from_fd	function
(	O
etar	pointer
,	O
digfd	int
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
;	O
etar_set_pathname	function
(	O
etar	pointer
,	O
"catalog/checkdigest"	pointer
)	O
;	O
etar_set_uname	function
(	O
etar	pointer
,	O
"root"	pointer
)	O
;	O
etar_set_gname	function
(	O
etar	pointer
,	O
"root"	pointer
)	O
;	O
etar_set_typeflag	function
(	O
etar	pointer
,	O
REGTYPE	char
)	O
;	O
etar_set_mode_ul	function
(	O
etar	pointer
,	O
(	O
unsigned	O
int	O
)	O
(	O
0644	int
)	O
)	O
;	O
fstat	function
(	O
digfd	int
,	O
&	O
st	pointer
)	O
;	O
etar_set_time	function
(	O
etar	pointer
,	O
st	pointer
.	O
st_mtime	O
)	O
;	O
etar_set_chksum	function
(	O
etar	pointer
)	O
;	O
etar_emit_header	function
(	O
etar	pointer
,	O
nfd	int
)	O
;	O
etar_emit_data_from_fd	function
(	O
etar	pointer
,	O
nfd	int
,	O
digfd	int
)	O
;	O
}	O
taru_delete	function
(	O
taru	pointer
)	O
;	O
xformat	pointer
=	O
xformat_open	function
(	O
-	O
1	int
,	O
-	O
1	int
,	O
arf_ustar	int
)	O
;	O
ret	int
=	O
uxfio_lseek	function
(	O
topsf	pointer
->	O
fd_	int
,	O
0	int
,	O
SEEK_SET	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
{	O
E_DEBUG	O
(	O
"error"	pointer
)	O
;	O
return	O
-	O
2	int
;	O
}	O
ret	int
=	O
xformat_open_archive_by_fd	function
(	O
xformat	pointer
,	O
topsf	pointer
->	O
fd_	int
,	O
UINFILE_DETECT_OTARFORCE	O
|	O
UINFILE_DETECT_NATIVE	O
,	O
(	O
mode_t	int
)	O
(	O
0	int
)	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
{	O
E_DEBUG	O
(	O
"error"	pointer
)	O
;	O
return	O
-	O
3	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
xformat_set_ofd	function
(	O
xformat	pointer
,	O
G_OFD	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
while	O
(	O
xformat_read_header	function
(	O
xformat	pointer
)	O
>	O
0	int
)	O
{	O
E_DEBUG	O
(	O
"HERE: Storage"	pointer
)	O
;	O
if	O
(	O
xformat_is_end_of_archive	function
(	O
xformat	pointer
)	O
)	O
{	O
break	O
;	O
}	O
xformat_get_name	function
(	O
xformat	pointer
,	O
namebuf	pointer
)	O
;	O
name	pointer
=	O
strob_str	function
(	O
namebuf	pointer
)	O
;	O
if	O
(	O
strstr	function
(	O
name	pointer
,	O
topsf	pointer
->	O
format_desc_	pointer
->	O
pathname_prefixM	pointer
)	O
==	O
name	pointer
)	O
{	O
name	pointer
+=	O
strlen	function
(	O
topsf	pointer
->	O
format_desc_	pointer
->	O
pathname_prefixM	pointer
)	O
;	O
swlib_squash_leading_slash	function
(	O
name	pointer
)	O
;	O
}	O
if	O
(	O
strlen	function
(	O
name	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
xformat_file_has_data	function
(	O
xformat	pointer
)	O
)	O
{	O
xformat_copy_pass_by_dst	function
(	O
xformat	pointer
,	O
nullfd	int
)	O
;	O
}	O
}	O
else	O
{	O
ahsStaticSetTarFilename	function
(	O
ahs_vfile_hdr	function
(	O
xformat_ahs_object	function
(	O
xformat	pointer
)	O
)	O
,	O
name	pointer
)	O
;	O
xformat_write_header	function
(	O
xformat	pointer
)	O
;	O
if	O
(	O
xformat_file_has_data	function
(	O
xformat	pointer
)	O
)	O
{	O
xformat_copy_pass_thru	function
(	O
xformat	pointer
)	O
;	O
}	O
}	O
}	O
xformat_close	function
(	O
xformat	pointer
)	O
;	O
etar_write_trailer_blocks	function
(	O
NULL	O
,	O
G_OFD	int
,	O
2	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
close	pointer
(	O
nullfd	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
write_deb	function
(	O
TOPSF	struct
*	O
topsf	pointer
)	O
{	O
int	O
ret	int
;	O
int	O
data_fd	int
;	O
int	O
control_fd	int
;	O
int	O
psffd	int
;	O
int	O
srcfd	int
;	O
int	O
ofd	int
;	O
TARU	struct
*	O
taru	pointer
;	O
ETAR	struct
*	O
etar	pointer
;	O
DEBPSF	struct
*	O
dp	pointer
;	O
XFORMAT	struct
*	O
control_xformat	pointer
;	O
XFORMAT	struct
*	O
data_xformat	pointer
;	O
STROB	struct
*	O
tmpname	pointer
;	O
struct	O
new_cpio_header	struct
*	O
file_hdr	pointer
;	O
AHS	struct
*	O
ahs	pointer
;	O
char	O
*	O
name	pointer
;	O
ofd	int
=	O
G_OFD	int
;	O
tmpname	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
psffd	int
=	O
swlib_open_memfd	function
(	O
)	O
;	O
ret	int
=	O
topsf_write_psf	function
(	O
topsf	pointer
,	O
psffd	int
,	O
1	int
)	O
;	O
E_DEBUG2	O
(	O
"psf returned %d"	pointer
,	O
ret	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
uxfio_lseek	function
(	O
psffd	int
,	O
0	int
,	O
SEEK_SET	int
)	O
;	O
dp	pointer
=	O
topsf	pointer
->	O
debpsfM	pointer
;	O
control_fd	int
=	O
dp	pointer
->	O
control_fdM	int
;	O
data_fd	int
=	O
dp	pointer
->	O
source_data_fdM	int
;	O
control_xformat	pointer
=	O
xformat_open	function
(	O
-	O
1	int
,	O
-	O
1	int
,	O
arf_ustar	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
!	O
control_xformat	pointer
)	O
return	O
-	O
2	int
;	O
if	O
(	O
uxfio_lseek	function
(	O
control_fd	int
,	O
0	int
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
{	O
return	O
-	O
3	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	int
=	O
xformat_open_archive_by_fd	function
(	O
control_xformat	pointer
,	O
control_fd	int
,	O
UINFILE_DETECT_OTARFORCE	O
|	O
UINFILE_DETECT_DEB_CONTEXT	O
,	O
(	O
mode_t	int
)	O
(	O
0	int
)	O
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
return	O
-	O
4	int
;	O
xformat_set_ofd	function
(	O
control_xformat	pointer
,	O
ofd	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
taru	pointer
=	O
taru_create	function
(	O
)	O
;	O
etar	pointer
=	O
etar_open	function
(	O
taru	pointer
->	O
taru_tarheaderflagsM	int
)	O
;	O
etar_init_hdr	function
(	O
etar	pointer
)	O
;	O
etar_set_size_from_fd	function
(	O
etar	pointer
,	O
psffd	int
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
;	O
etar_set_pathname	function
(	O
etar	pointer
,	O
"PSF"	pointer
)	O
;	O
etar_set_uname	function
(	O
etar	pointer
,	O
"root"	pointer
)	O
;	O
etar_set_gname	function
(	O
etar	pointer
,	O
"root"	pointer
)	O
;	O
etar_set_typeflag	function
(	O
etar	pointer
,	O
REGTYPE	char
)	O
;	O
etar_set_mode_ul	function
(	O
etar	pointer
,	O
(	O
unsigned	O
int	O
)	O
(	O
0644	int
)	O
)	O
;	O
etar_set_chksum	function
(	O
etar	pointer
)	O
;	O
etar_emit_header	function
(	O
etar	pointer
,	O
ofd	int
)	O
;	O
etar_emit_data_from_fd	function
(	O
etar	pointer
,	O
ofd	int
,	O
psffd	int
)	O
;	O
taru_delete	function
(	O
taru	pointer
)	O
;	O
while	O
(	O
(	O
ret	int
=	O
xformat_read_header	function
(	O
control_xformat	pointer
)	O
)	O
>	O
0	int
)	O
{	O
E_DEBUG	O
(	O
"in loop"	pointer
)	O
;	O
if	O
(	O
xformat_is_end_of_archive	function
(	O
control_xformat	pointer
)	O
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
break	O
;	O
}	O
ahs	pointer
=	O
xformat_ahs_object	function
(	O
control_xformat	pointer
)	O
;	O
name	pointer
=	O
ahsStaticGetTarFilename	function
(	O
ahs	pointer
->	O
file_hdrM	pointer
)	O
;	O
E_DEBUG2	O
(	O
"name=[%s]"	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
xformat_get_tar_typeflag	function
(	O
control_xformat	pointer
)	O
==	O
REGTYPE	char
)	O
{	O
strob_strcpy	function
(	O
tmpname	pointer
,	O
DEBPSF_PSF_CONTROL_DIR	pointer
)	O
;	O
swlib_unix_dircat	function
(	O
tmpname	pointer
,	O
name	pointer
)	O
;	O
ahsStaticSetTarFilename	function
(	O
ahs	pointer
->	O
file_hdrM	pointer
,	O
strob_str	function
(	O
tmpname	pointer
)	O
)	O
;	O
xformat_write_header	function
(	O
control_xformat	pointer
)	O
;	O
xformat_copy_pass_thru	function
(	O
control_xformat	pointer
)	O
;	O
}	O
else	O
{	O
;	O
}	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: error reading control archive, ret=%d\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
ret	int
)	O
;	O
return	O
-	O
5	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
data_xformat	pointer
=	O
xformat_open	function
(	O
-	O
1	int
,	O
-	O
1	int
,	O
arf_ustar	int
)	O
;	O
ret	int
=	O
xformat_open_archive_by_fd	function
(	O
data_xformat	pointer
,	O
data_fd	int
,	O
UINFILE_DETECT_OTARFORCE	O
|	O
UINFILE_DETECT_DEB_CONTEXT	O
,	O
(	O
mode_t	int
)	O
(	O
0	int
)	O
)	O
;	O
xformat_set_ofd	function
(	O
data_xformat	pointer
,	O
G_OFD	int
)	O
;	O
while	O
(	O
(	O
ret	int
=	O
xformat_read_header	function
(	O
data_xformat	pointer
)	O
)	O
>	O
0	int
)	O
{	O
if	O
(	O
xformat_is_end_of_archive	function
(	O
data_xformat	pointer
)	O
)	O
{	O
break	O
;	O
}	O
ahs	pointer
=	O
xformat_ahs_object	function
(	O
data_xformat	pointer
)	O
;	O
name	pointer
=	O
ahsStaticGetTarFilename	function
(	O
ahs	pointer
->	O
file_hdrM	pointer
)	O
;	O
E_DEBUG2	O
(	O
"name=[%s]"	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
name	pointer
,	O
"./"	pointer
)	O
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
strlen	function
(	O
name	pointer
)	O
>	O
2	int
&&	O
strstr	function
(	O
name	pointer
,	O
"./"	pointer
)	O
==	O
name	pointer
)	O
{	O
name	pointer
+=	O
2	int
;	O
}	O
strob_strcpy	function
(	O
tmpname	pointer
,	O
name	pointer
)	O
;	O
ahsStaticSetTarFilename	function
(	O
ahs	pointer
->	O
file_hdrM	pointer
,	O
strob_str	function
(	O
tmpname	pointer
)	O
)	O
;	O
xformat_write_header	function
(	O
data_xformat	pointer
)	O
;	O
if	O
(	O
xformat_get_tar_typeflag	function
(	O
data_xformat	pointer
)	O
==	O
REGTYPE	char
)	O
{	O
xformat_copy_pass_thru	function
(	O
data_xformat	pointer
)	O
;	O
}	O
else	O
{	O
;	O
}	O
}	O
etar_write_trailer_blocks	function
(	O
etar	pointer
,	O
ofd	int
,	O
2	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: error reading data archive, ret=%d\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
ret	int
)	O
;	O
return	O
-	O
6	int
;	O
}	O
xformat_close	function
(	O
control_xformat	pointer
)	O
;	O
xformat_close	function
(	O
data_xformat	pointer
)	O
;	O
strob_close	function
(	O
tmpname	pointer
)	O
;	O
etar_close	function
(	O
etar	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
main	function
(	O
int	O
argc	pointer
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
nfd	int
;	O
TOPSF	struct
*	O
topsf	pointer
;	O
STRAR	struct
*	O
exclude_list	pointer
;	O
int	O
no_leading_path	int
=	O
0	int
;	O
int	O
ret	int
=	O
0	int
;	O
int	O
debfd	int
;	O
int	O
c	int
=	O
0	int
;	O
int	O
info_only	int
=	O
0	int
;	O
int	O
psf_only	int
=	O
0	int
;	O
int	O
tarpipe	array
[	O
2	int
]	O
;	O
int	O
verbose	int
;	O
char	O
*	O
owner	pointer
;	O
char	O
*	O
group	pointer
;	O
char	O
*	O
progname	pointer
;	O
char	O
*	O
checkdigestname	pointer
=	O
NULL	O
;	O
char	O
*	O
wopt_create_time	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
char	O
*	O
slack_name	pointer
=	O
NULL	O
;	O
char	O
*	O
path_prefix	pointer
;	O
char	O
format	pointer
[	O
21	int
]	O
;	O
pid_t	int
pid	int
;	O
int	O
bufferflag	int
=	O
UINFILE_UXFIO_BUFTYPE_DYNAMIC_MEM	O
;	O
int	O
use_recursive_fileset_spec	int
=	O
0	int
;	O
int	O
single_fileset_override	int
=	O
0	int
;	O
int	O
smart_path	int
=	O
0	int
;	O
int	O
rpmform	int
=	O
3	int
;	O
int	O
do_drop_priv	int
=	O
0	int
;	O
int	O
do_deb_control	int
=	O
0	int
;	O
int	O
do_deb_data	int
=	O
0	int
;	O
char	O
*	O
debug_level	pointer
=	O
NULL	O
;	O
unsigned	O
long	O
create_time	long
=	O
0	int
;	O
int	O
construct_missing_files	int
=	O
0	int
;	O
progname	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
G_OFD	int
=	O
STDOUT_FILENO	int
;	O
verbose	int
=	O
1	int
;	O
exclude_list	pointer
=	O
NULL	O
;	O
yylval	union
.	O
strb	pointer
=	O
strob_open	function
(	O
8	int
)	O
;	O
strcpy	function
(	O
swlex_filename	array
,	O
"none"	pointer
)	O
;	O
*	O
format	pointer
=	O
'\0'	O
;	O
owner	pointer
=	O
NULL	O
;	O
group	pointer
=	O
NULL	O
;	O
swlib_utilname_set	function
(	O
"lxpsf"	pointer
)	O
;	O
while	O
(	O
1	int
)	O
{	O
int	O
option_index	int
=	O
0	int
;	O
static	O
struct	O
option	struct
long_options	array
[	O
]	O
=	O
{	O
{	O
"psf-only"	pointer
,	O
0	int
,	O
0	int
,	O
'p'	O
}	O
,	O
{	O
"psf-form1"	pointer
,	O
0	int
,	O
0	int
,	O
'A'	O
}	O
,	O
{	O
"psf-form2"	pointer
,	O
0	int
,	O
0	int
,	O
'M'	O
}	O
,	O
{	O
"psf-form3"	pointer
,	O
0	int
,	O
0	int
,	O
136	int
}	O
,	O
{	O
"format"	pointer
,	O
1	int
,	O
0	int
,	O
'H'	O
}	O
,	O
{	O
"debug_level"	pointer
,	O
1	int
,	O
0	int
,	O
'd'	O
}	O
,	O
{	O
"checkdigest"	pointer
,	O
1	int
,	O
0	int
,	O
'D'	O
}	O
,	O
{	O
"no-leading-path"	pointer
,	O
0	int
,	O
0	int
,	O
'r'	O
}	O
,	O
{	O
"use-recursive-fileset"	pointer
,	O
0	int
,	O
0	int
,	O
'x'	O
}	O
,	O
{	O
"buffer-type"	pointer
,	O
1	int
,	O
0	int
,	O
'B'	O
}	O
,	O
{	O
"help"	pointer
,	O
0	int
,	O
0	int
,	O
132	int
}	O
,	O
{	O
"version"	pointer
,	O
0	int
,	O
0	int
,	O
133	int
}	O
,	O
{	O
"single-fileset"	pointer
,	O
0	int
,	O
0	int
,	O
134	int
}	O
,	O
{	O
"util-name"	pointer
,	O
1	int
,	O
0	int
,	O
135	int
}	O
,	O
{	O
"info-only"	pointer
,	O
0	int
,	O
0	int
,	O
'o'	O
}	O
,	O
{	O
"smart-leading-path"	pointer
,	O
0	int
,	O
0	int
,	O
'L'	O
}	O
,	O
{	O
"drop-privilege"	pointer
,	O
0	int
,	O
0	int
,	O
198	int
}	O
,	O
{	O
"create-time"	pointer
,	O
1	int
,	O
0	int
,	O
199	int
}	O
,	O
{	O
"deb-control"	pointer
,	O
0	int
,	O
0	int
,	O
200	int
}	O
,	O
{	O
"deb-data"	pointer
,	O
0	int
,	O
0	int
,	O
201	int
}	O
,	O
{	O
"owner"	pointer
,	O
1	int
,	O
0	int
,	O
202	int
}	O
,	O
{	O
"group"	pointer
,	O
1	int
,	O
0	int
,	O
203	int
}	O
,	O
{	O
"slackware-pkg-name"	pointer
,	O
1	int
,	O
0	int
,	O
204	int
}	O
,	O
{	O
"exclude"	pointer
,	O
1	int
,	O
0	int
,	O
205	int
}	O
,	O
{	O
"exclude-system-dirs"	pointer
,	O
0	int
,	O
0	int
,	O
206	int
}	O
,	O
{	O
"construct-missing-files"	pointer
,	O
0	int
,	O
0	int
,	O
207	int
}	O
,	O
{	O
"verbose"	pointer
,	O
0	int
,	O
0	int
,	O
'v'	O
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
c	int
=	O
ugetopt_long	function
(	O
argc	pointer
,	O
argv	pointer
,	O
"ArB:pH:xD:oLMv"	pointer
,	O
long_options	array
,	O
&	O
option_index	int
)	O
;	O
if	O
(	O
c	int
==	O
-	O
1	int
)	O
break	O
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
'A'	O
:	O
rpmform	int
=	O
0	int
;	O
break	O
;	O
case	O
136	int
:	O
rpmform	int
=	O
3	int
;	O
break	O
;	O
case	O
'M'	O
:	O
rpmform	int
=	O
2	int
;	O
break	O
;	O
case	O
'r'	O
:	O
no_leading_path	int
=	O
1	int
;	O
break	O
;	O
case	O
'v'	O
:	O
verbose	int
++	O
;	O
break	O
;	O
case	O
'x'	O
:	O
use_recursive_fileset_spec	int
=	O
1	int
;	O
break	O
;	O
case	O
'o'	O
:	O
info_only	int
=	O
1	int
;	O
break	O
;	O
case	O
'L'	O
:	O
smart_path	int
=	O
1	int
;	O
break	O
;	O
case	O
'p'	O
:	O
psf_only	int
=	O
1	int
;	O
break	O
;	O
case	O
'B'	O
:	O
if	O
(	O
!	O
optarg	pointer
)	O
usage	function
(	O
progname	pointer
,	O
stderr	pointer
)	O
;	O
if	O
(	O
strstr	function
(	O
optarg	pointer
,	O
"mem"	pointer
)	O
)	O
{	O
bufferflag	int
=	O
UINFILE_UXFIO_BUFTYPE_DYNAMIC_MEM	O
;	O
}	O
else	O
if	O
(	O
strstr	function
(	O
optarg	pointer
,	O
"file"	pointer
)	O
)	O
{	O
bufferflag	int
=	O
UINFILE_UXFIO_BUFTYPE_FILE	O
;	O
}	O
break	O
;	O
case	O
'd'	O
:	O
if	O
(	O
!	O
optarg	pointer
)	O
usage	function
(	O
progname	pointer
,	O
stderr	pointer
)	O
;	O
debug_level	pointer
=	O
strdup	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'D'	O
:	O
if	O
(	O
!	O
optarg	pointer
)	O
usage	function
(	O
progname	pointer
,	O
stderr	pointer
)	O
;	O
checkdigestname	pointer
=	O
strdup	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'H'	O
:	O
if	O
(	O
!	O
optarg	pointer
)	O
usage	function
(	O
progname	pointer
,	O
stderr	pointer
)	O
;	O
strncpy	function
(	O
format	pointer
,	O
optarg	pointer
,	O
sizeof	O
(	O
format	pointer
)	O
)	O
;	O
format	pointer
[	O
sizeof	O
(	O
format	pointer
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
break	O
;	O
case	O
133	int
:	O
show_version	function
(	O
stdout	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
case	O
134	int
:	O
single_fileset_override	int
=	O
1	int
;	O
break	O
;	O
case	O
135	int
:	O
swlib_utilname_set	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
132	int
:	O
usage	function
(	O
progname	pointer
,	O
stdout	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
break	O
;	O
case	O
198	int
:	O
do_drop_priv	int
=	O
1	int
;	O
break	O
;	O
case	O
199	int
:	O
wopt_create_time	pointer
=	O
CHARTRUE	O
;	O
sscanf	function
(	O
optarg	pointer
,	O
"%lu"	pointer
,	O
&	O
create_time	long
)	O
;	O
break	O
;	O
case	O
200	int
:	O
do_deb_control	int
=	O
1	int
;	O
{	O
UINFORMAT	struct
*	O
uinformat	pointer
;	O
if	O
(	O
optind	int
<	O
argc	pointer
)	O
{	O
debfd	int
=	O
uinfile_open	function
(	O
argv	pointer
[	O
optind	int
]	O
,	O
0	int
,	O
&	O
uinformat	pointer
,	O
bufferflag	int
)	O
;	O
}	O
else	O
{	O
debfd	int
=	O
uinfile_open	function
(	O
"-"	pointer
,	O
0	int
,	O
&	O
uinformat	pointer
,	O
bufferflag	int
)	O
;	O
}	O
if	O
(	O
uinfile_get_type	function
(	O
uinformat	pointer
)	O
!=	O
DEB_FILEFORMAT	int
)	O
exit	function
(	O
1	int
)	O
;	O
if	O
(	O
debfd	int
<	O
0	int
)	O
exit	function
(	O
1	int
)	O
;	O
ret	int
=	O
swlib_pipe_pump	function
(	O
G_OFD	int
,	O
debfd	int
)	O
;	O
uxfio_close	function
(	O
debfd	int
)	O
;	O
uinfile_close	function
(	O
uinformat	pointer
)	O
;	O
close	pointer
(	O
G_OFD	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
exit	function
(	O
1	int
)	O
;	O
else	O
exit	function
(	O
0	int
)	O
;	O
}	O
break	O
;	O
case	O
201	int
:	O
do_deb_data	int
=	O
1	int
;	O
{	O
int	O
fd	pointer
;	O
UINFORMAT	struct
*	O
uinformat	pointer
;	O
if	O
(	O
optind	int
<	O
argc	pointer
)	O
{	O
debfd	int
=	O
uinfile_open	function
(	O
argv	pointer
[	O
optind	int
]	O
,	O
0	int
,	O
&	O
uinformat	pointer
,	O
0	int
)	O
;	O
}	O
else	O
{	O
debfd	int
=	O
uinfile_open	function
(	O
"-"	pointer
,	O
0	int
,	O
&	O
uinformat	pointer
,	O
0	int
)	O
;	O
}	O
if	O
(	O
uinfile_get_type	function
(	O
uinformat	pointer
)	O
!=	O
DEB_FILEFORMAT	int
)	O
exit	function
(	O
1	int
)	O
;	O
if	O
(	O
debfd	int
<	O
0	int
)	O
exit	function
(	O
1	int
)	O
;	O
ret	int
=	O
swlib_pipe_pump	function
(	O
-	O
1	int
,	O
debfd	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
exit	function
(	O
1	int
)	O
;	O
ret	int
=	O
uinfile_opendup	function
(	O
uinformat	pointer
->	O
deb_file_fd_	int
,	O
0	int
,	O
&	O
uinformat	pointer
,	O
UINFILE_DETECT_DEB_DATA	O
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
exit	function
(	O
1	int
)	O
;	O
if	O
(	O
uinfile_get_type	function
(	O
uinformat	pointer
)	O
!=	O
DEB_FILEFORMAT	int
)	O
exit	function
(	O
1	int
)	O
;	O
fd	pointer
=	O
ret	int
;	O
ret	int
=	O
swlib_pipe_pump	function
(	O
G_OFD	int
,	O
fd	pointer
)	O
;	O
uxfio_close	function
(	O
fd	pointer
)	O
;	O
uinfile_close	function
(	O
uinformat	pointer
)	O
;	O
close	pointer
(	O
G_OFD	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
exit	function
(	O
1	int
)	O
;	O
else	O
exit	function
(	O
0	int
)	O
;	O
}	O
break	O
;	O
case	O
202	int
:	O
owner	pointer
=	O
strdup	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
203	int
:	O
group	pointer
=	O
strdup	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
204	int
:	O
slack_name	pointer
=	O
strdup	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
205	int
:	O
if	O
(	O
exclude_list	pointer
==	O
NULL	O
)	O
exclude_list	pointer
=	O
strar_open	function
(	O
)	O
;	O
strar_add	function
(	O
exclude_list	pointer
,	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
206	int
:	O
if	O
(	O
exclude_list	pointer
==	O
NULL	O
)	O
exclude_list	pointer
=	O
strar_open	function
(	O
)	O
;	O
add_system_dirs	function
(	O
exclude_list	pointer
)	O
;	O
break	O
;	O
case	O
207	int
:	O
construct_missing_files	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
usage	function
(	O
progname	pointer
,	O
stderr	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
break	O
;	O
}	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
optind	int
<	O
argc	pointer
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
topsf	pointer
=	O
topsf_open	function
(	O
argv	pointer
[	O
optind	int
]	O
,	O
bufferflag	int
,	O
NULL	O
)	O
;	O
if	O
(	O
optind	int
+	O
1	int
<	O
argc	pointer
)	O
{	O
G_OFD	int
=	O
open	function
(	O
argv	pointer
[	O
optind	int
+	O
1	int
]	O
,	O
O_RDWR	int
|	O
O_CREAT	int
|	O
O_TRUNC	int
,	O
0644	int
)	O
;	O
if	O
(	O
G_OFD	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"lxpsf: error opening %s: %s\n"	pointer
,	O
argv	pointer
[	O
optind	int
+	O
1	int
]	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
}	O
else	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
topsf	pointer
=	O
topsf_open	function
(	O
"-"	pointer
,	O
bufferflag	int
,	O
NULL	O
)	O
;	O
}	O
if	O
(	O
!	O
topsf	pointer
)	O
{	O
exit	function
(	O
1	int
)	O
;	O
}	O
topsf	pointer
->	O
verboseM	int
=	O
verbose	int
;	O
topsf	pointer
->	O
exclude_listM	pointer
=	O
exclude_list	pointer
;	O
topsf	pointer
->	O
rpm_construct_missing_filesM	int
=	O
construct_missing_files	int
;	O
if	O
(	O
owner	pointer
)	O
topsf	pointer
->	O
ownerM	pointer
=	O
strdup	function
(	O
owner	pointer
)	O
;	O
if	O
(	O
group	pointer
)	O
topsf	pointer
->	O
groupM	pointer
=	O
strdup	function
(	O
group	pointer
)	O
;	O
if	O
(	O
wopt_create_time	pointer
)	O
{	O
topsf_set_mtime	function
(	O
topsf	pointer
,	O
(	O
time_t	long
)	O
(	O
create_time	long
)	O
)	O
;	O
}	O
if	O
(	O
checkdigestname	pointer
)	O
{	O
topsf	pointer
->	O
checkdigestnameM	pointer
=	O
strdup	function
(	O
checkdigestname	pointer
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
topsf	pointer
->	O
smart_path_	int
=	O
smart_path	int
;	O
path_prefix	pointer
=	O
topsf_make_package_prefix	function
(	O
topsf	pointer
,	O
""	pointer
)	O
;	O
if	O
(	O
smart_path	int
&&	O
uinfile_get_type	function
(	O
topsf	pointer
->	O
format_desc_	pointer
)	O
==	O
RPMRHS_FILEFORMAT	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
strob_strcpy	function
(	O
topsf	pointer
->	O
control_directoryM	pointer
,	O
path_prefix	pointer
)	O
;	O
path_prefix	pointer
=	O
"."	pointer
;	O
topsf_set_cwd_prefix	function
(	O
topsf	pointer
,	O
path_prefix	pointer
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
(	O
rpmform	int
==	O
2	int
||	O
rpmform	int
==	O
3	int
)	O
&&	O
uinfile_get_type	function
(	O
topsf	pointer
->	O
format_desc_	pointer
)	O
==	O
RPMRHS_FILEFORMAT	int
)	O
{	O
strob_strcpy	function
(	O
topsf	pointer
->	O
control_directoryM	pointer
,	O
path_prefix	pointer
)	O
;	O
path_prefix	pointer
=	O
"."	pointer
;	O
topsf_set_cwd_prefix	function
(	O
topsf	pointer
,	O
path_prefix	pointer
)	O
;	O
if	O
(	O
rpmform	int
==	O
2	int
)	O
topsf	pointer
->	O
form_	int
=	O
TOPSF_PSF_FORM2	int
;	O
else	O
if	O
(	O
rpmform	int
==	O
3	int
)	O
topsf	pointer
->	O
form_	int
=	O
TOPSF_PSF_FORM3	int
;	O
else	O
topsf	pointer
->	O
form_	int
=	O
TOPSF_PSF_FORM3	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
no_leading_path	int
||	O
path_prefix	pointer
==	O
NULL	O
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
path_prefix	pointer
=	O
"."	pointer
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
topsf_set_cwd_prefix	function
(	O
topsf	pointer
,	O
path_prefix	pointer
)	O
;	O
topsf	pointer
->	O
single_fileset_	int
=	O
single_fileset_override	int
;	O
topsf	pointer
->	O
use_recursive_	int
=	O
use_recursive_fileset_spec	int
;	O
if	O
(	O
debug_level	pointer
)	O
{	O
topsf	pointer
->	O
debug_link_	int
=	O
1	int
;	O
}	O
if	O
(	O
!	O
strcmp	function
(	O
format	pointer
,	O
SWBIS_A_ustar	pointer
)	O
||	O
!	O
strcmp	function
(	O
format	pointer
,	O
SWBIS_A_pax	pointer
)	O
)	O
{	O
topsf	pointer
->	O
reverse_links_	int
=	O
1	int
;	O
}	O
if	O
(	O
do_drop_priv	int
)	O
{	O
swlib_drop_root_privilege	function
(	O
)	O
;	O
}	O
if	O
(	O
psf_only	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	int
=	O
topsf_write_psf	function
(	O
topsf	pointer
,	O
G_OFD	int
,	O
1	int
)	O
;	O
E_DEBUG2	O
(	O
"(topsf_write_psf) ret=%d"	pointer
,	O
ret	int
)	O
;	O
if	O
(	O
uinfile_get_type	function
(	O
topsf	pointer
->	O
format_desc_	pointer
)	O
==	O
SLACK_FILEFORMAT	int
)	O
{	O
nfd	int
=	O
open	function
(	O
"/dev/null"	pointer
,	O
O_RDWR	int
)	O
;	O
swlib_pipe_pump	function
(	O
nfd	int
,	O
topsf	pointer
->	O
fd_	int
)	O
;	O
close	pointer
(	O
nfd	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
info_only	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
topsf	pointer
->	O
info_only_	int
=	O
1	int
;	O
ret	int
=	O
topsf_write_info	function
(	O
topsf	pointer
,	O
G_OFD	int
,	O
1	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
uinfile_get_type	function
(	O
topsf	pointer
->	O
format_desc_	pointer
)	O
==	O
DEB_FILEFORMAT	int
)	O
{	O
ret	int
=	O
write_deb	function
(	O
topsf	pointer
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"lxpsf: write_deb() returned %d\n"	pointer
,	O
ret	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
uinfile_get_type	function
(	O
topsf	pointer
->	O
format_desc_	pointer
)	O
==	O
SLACK_FILEFORMAT	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
topsf	pointer
->	O
pkgfilenameM	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
slack_name	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: lxpsf: slackware package, specify package file as arg()\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: lxpsf: Example: swpackage --to-sw -s name-revision-arch-build.tgz\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
else	O
{	O
topsf	pointer
->	O
pkgfilenameM	pointer
=	O
strdup	function
(	O
slack_name	pointer
)	O
;	O
}	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	int
=	O
write_slack	function
(	O
topsf	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
;	O
}	O
else	O
if	O
(	O
uinfile_get_type	function
(	O
topsf	pointer
->	O
format_desc_	pointer
)	O
==	O
RPMRHS_FILEFORMAT	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
nfd	int
=	O
open	function
(	O
"/dev/null"	pointer
,	O
O_RDWR	int
)	O
;	O
topsf_write_psf	function
(	O
topsf	pointer
,	O
nfd	int
,	O
0	int
)	O
;	O
close	pointer
(	O
nfd	int
)	O
;	O
if	O
(	O
strcmp	function
(	O
format	pointer
,	O
SWBIS_A_ustar	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
format	pointer
,	O
SWBIS_A_pax	pointer
)	O
==	O
0	int
)	O
{	O
TARU	struct
*	O
taru	pointer
;	O
pipe	function
(	O
tarpipe	array
)	O
;	O
pid	int
=	O
swfork	O
(	O
(	O
sigset_t	struct
*	O
)	O
(	O
NULL	O
)	O
)	O
;	O
if	O
(	O
pid	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"lxpsf: fork failed.\n"	pointer
)	O
;	O
_exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
pid	int
==	O
0	int
)	O
{	O
close	pointer
(	O
tarpipe	array
[	O
0	int
]	O
)	O
;	O
ret	int
=	O
topsf_copypass_swacfl_list	function
(	O
topsf	pointer
,	O
tarpipe	array
[	O
1	int
]	O
)	O
;	O
topsf_close	function
(	O
topsf	pointer
)	O
;	O
_exit	function
(	O
ret	int
)	O
;	O
}	O
else	O
{	O
close	pointer
(	O
tarpipe	array
[	O
1	int
]	O
)	O
;	O
taru	pointer
=	O
taru_create	function
(	O
)	O
;	O
taru_set_tar_header_policy	function
(	O
taru	pointer
,	O
SWBIS_A_pax	pointer
,	O
NULL	O
)	O
;	O
ret	int
=	O
taru_process_copy_in	function
(	O
taru	pointer
,	O
tarpipe	array
[	O
0	int
]	O
,	O
G_OFD	int
)	O
;	O
}	O
}	O
else	O
{	O
ret	int
=	O
topsf_copypass_swacfl_list	function
(	O
topsf	pointer
,	O
G_OFD	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
uinfile_get_type	function
(	O
topsf	pointer
->	O
format_desc_	pointer
)	O
==	O
PLAIN_TARBALL_SRC_FILEFORMAT	int
)	O
{	O
ret	int
=	O
write_plain_source_tarball	function
(	O
topsf	pointer
)	O
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"lxpsf: unsupported format.\n"	pointer
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
G_OFD	int
!=	O
STDOUT_FILENO	int
)	O
close	pointer
(	O
G_OFD	int
)	O
;	O
topsf_close	function
(	O
topsf	pointer
)	O
;	O
exit	function
(	O
ret	int
?	O
1	int
:	O
0	int
)	O
;	O
}	O
