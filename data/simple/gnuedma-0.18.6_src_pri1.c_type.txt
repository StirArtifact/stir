EPVoid	pointer
EDMAPROC	O
edma_wprop1	function
(	O
OBJID	long
IdObj	long
,	O
EUint32	long
Ind	long
,	O
...	O
)	O
{	O
EUint32	long
Tipo	long
;	O
EUint32	long
Off	short
;	O
EPVoid	pointer
Punt	pointer
;	O
va_list	pointer
p	pointer
;	O
EPChar	pointer
c	pointer
,	O
c1	pointer
;	O
HMEM	long
h	long
;	O
EUint32	long
tam	long
;	O
EDMAT_BUFFER	struct
Buf	struct
;	O
CLASSID	long
cid	long
;	O
if	O
(	O
(	O
edma_check_obj_id	function
(	O
IdObj	long
,	O
"edma_wprop1"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
(	O
EPVoid	pointer
)	O
-	O
1	int
;	O
cid	long
=	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdClass	long
;	O
if	O
(	O
pClass	pointer
[	O
cid	long
]	O
->	O
Prop	pointer
[	O
Ind	long
]	O
.	O
ioTipo	char
==	O
L	int
)	O
{	O
edma_printf_err	function
(	O
"[ERROR] Property %s is read only"	pointer
,	O
pClass	pointer
[	O
cid	long
]	O
->	O
Prop	pointer
[	O
Ind	long
]	O
.	O
IdProp	array
)	O
;	O
return	O
(	O
EPVoid	pointer
)	O
-	O
1	int
;	O
}	O
Off	short
=	O
pClass	pointer
[	O
cid	long
]	O
->	O
Prop	pointer
[	O
Ind	long
]	O
.	O
Off	short
;	O
if	O
(	O
Off	short
>	O
gClass	O
[	O
cid	long
]	O
->	O
TamDatos	long
)	O
edma_printf_err	function
(	O
"(WProp1) Offset out of ranger for property %d "	pointer
"of object %d"	pointer
,	O
Ind	long
,	O
IdObj	long
)	O
;	O
Tipo	long
=	O
pClass	pointer
[	O
cid	long
]	O
->	O
Prop	pointer
[	O
Ind	long
]	O
.	O
Tipo	long
;	O
Punt	pointer
=	O
(	O
EPByte	pointer
)	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
Data	pointer
)	O
+	O
Off	short
;	O
va_start	O
(	O
p	pointer
,	O
Ind	long
)	O
;	O
if	O
(	O
Tipo	long
==	O
DT_EUSER	int
)	O
{	O
if	O
(	O
pClass	pointer
[	O
cid	long
]	O
->	O
Prop	pointer
[	O
Ind	long
]	O
.	O
UserInfo	long
!=	O
-	O
1	int
)	O
edma_met3	function
(	O
*	O
(	O
(	O
OBJID	long
*	O
)	O
Punt	pointer
)	O
,	O
"Write"	pointer
,	O
p	pointer
)	O
;	O
else	O
{	O
edma_printf_err	function
(	O
"(WProp1) User type not defined for property"	pointer
)	O
;	O
return	O
(	O
EPVoid	pointer
)	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
(	O
tam	long
=	O
pClass	pointer
[	O
cid	long
]	O
->	O
Prop	pointer
[	O
Ind	long
]	O
.	O
nElem	long
)	O
!=	O
0	int
)	O
{	O
tam	long
*=	O
tipo	array
[	O
Tipo	long
]	O
.	O
tam	long
;	O
strncpy	function
(	O
Punt	pointer
,	O
va_arg	O
(	O
p	pointer
,	O
EPVoid	pointer
)	O
,	O
tam	long
)	O
;	O
}	O
switch	O
(	O
Tipo	long
)	O
{	O
case	O
DT_EBUFFER	int
:	O
Buf	struct
=	O
va_arg	O
(	O
p	pointer
,	O
EDMAT_BUFFER	struct
)	O
;	O
memcpy	function
(	O
Punt	pointer
,	O
&	O
Buf	struct
,	O
sizeof	O
(	O
EDMAT_BUFFER	struct
)	O
)	O
;	O
break	O
;	O
case	O
DT_EPOINTER	int
:	O
case	O
DT_EOBJECT	int
:	O
case	O
DT_EUINT32	int
:	O
*	O
(	O
(	O
EPUint32	pointer
)	O
Punt	pointer
)	O
=	O
va_arg	O
(	O
p	pointer
,	O
EUint32	long
)	O
;	O
break	O
;	O
case	O
DT_ESINT32	int
:	O
*	O
(	O
(	O
EPSint32	pointer
)	O
Punt	pointer
)	O
=	O
va_arg	O
(	O
p	pointer
,	O
ESint32	long
)	O
;	O
break	O
;	O
case	O
DT_ESINT8	int
:	O
case	O
DT_ECHAR	int
:	O
*	O
(	O
(	O
EPChar	pointer
)	O
Punt	pointer
)	O
=	O
va_arg	O
(	O
p	pointer
,	O
int	O
)	O
;	O
break	O
;	O
case	O
DT_EZSTRING	int
:	O
c	pointer
=	O
va_arg	O
(	O
p	pointer
,	O
EPChar	pointer
)	O
;	O
tam	long
=	O
strlen	function
(	O
c	pointer
)	O
;	O
edma_pfree	function
(	O
*	O
(	O
(	O
HMEM	long
*	O
)	O
Punt	pointer
)	O
,	O
(	O
EPVoid	pointer
)	O
*	O
(	O
(	O
HMEM	long
*	O
)	O
Punt	pointer
)	O
)	O
;	O
h	long
=	O
edma_palloc	function
(	O
sizeof	O
(	O
EByte	char
)	O
*	O
(	O
tam	long
+	O
1	int
)	O
)	O
;	O
c1	pointer
=	O
edma_pget	function
(	O
h	long
)	O
;	O
strncpy	function
(	O
c1	pointer
,	O
c	pointer
,	O
tam	long
)	O
;	O
c1	pointer
[	O
tam	long
]	O
=	O
0	int
;	O
*	O
(	O
(	O
HMEM	long
*	O
)	O
Punt	pointer
)	O
=	O
h	long
;	O
break	O
;	O
case	O
DT_ESINT16	int
:	O
*	O
(	O
(	O
EPSint16	pointer
)	O
Punt	pointer
)	O
=	O
(	O
ESint16	short
)	O
va_arg	O
(	O
p	pointer
,	O
int	O
)	O
;	O
break	O
;	O
case	O
DT_EUINT16	int
:	O
*	O
(	O
(	O
EPUint16	pointer
)	O
Punt	pointer
)	O
=	O
va_arg	O
(	O
p	pointer
,	O
int	O
)	O
;	O
break	O
;	O
case	O
DT_EUINT8	int
:	O
case	O
DT_EBYTE	int
:	O
*	O
(	O
(	O
EPByte	pointer
)	O
Punt	pointer
)	O
=	O
va_arg	O
(	O
p	pointer
,	O
int	O
)	O
;	O
break	O
;	O
case	O
DT_EWORD	int
:	O
*	O
(	O
(	O
EPWord	pointer
)	O
Punt	pointer
)	O
=	O
va_arg	O
(	O
p	pointer
,	O
int	O
)	O
;	O
;	O
break	O
;	O
case	O
DT_EDWORD	int
:	O
*	O
(	O
(	O
EPDWord	pointer
)	O
Punt	pointer
)	O
=	O
va_arg	O
(	O
p	pointer
,	O
EDWord	long
)	O
;	O
;	O
break	O
;	O
case	O
DT_EREAL32	int
:	O
*	O
(	O
(	O
EPReal32	pointer
)	O
Punt	pointer
)	O
=	O
va_arg	O
(	O
p	pointer
,	O
double	O
)	O
;	O
;	O
break	O
;	O
case	O
DT_EREAL64	int
:	O
*	O
(	O
(	O
EPReal64	pointer
)	O
Punt	pointer
)	O
=	O
va_arg	O
(	O
p	pointer
,	O
EReal64	double
)	O
;	O
break	O
;	O
}	O
return	O
Punt	pointer
;	O
}	O
EPVoid	pointer
EDMAPROC	O
edma_rprop1	function
(	O
OBJID	long
IdObj	long
,	O
EUint32	long
Ind	long
,	O
...	O
)	O
{	O
EUint32	long
Tipo	long
;	O
EUint32	long
Off	short
;	O
EPVoid	pointer
Punt	pointer
;	O
va_list	pointer
p	pointer
;	O
EPChar	pointer
c	pointer
,	O
c1	pointer
;	O
EDMAT_BUFFER	struct
*	O
Buf	struct
;	O
if	O
(	O
(	O
edma_check_obj_id	function
(	O
IdObj	long
,	O
"edma_rprop1"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
(	O
EPVoid	pointer
)	O
-	O
1	int
;	O
if	O
(	O
pClass	pointer
[	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdClass	long
]	O
->	O
Prop	pointer
[	O
Ind	long
]	O
.	O
ioTipo	char
==	O
E	int
)	O
{	O
edma_printf_err	function
(	O
"[ERROR] Property %s is write only... "	pointer
"whatever means that!"	pointer
,	O
pClass	pointer
[	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdClass	long
]	O
->	O
Prop	pointer
[	O
Ind	long
]	O
.	O
IdProp	array
)	O
;	O
return	O
(	O
EPVoid	pointer
)	O
-	O
1	int
;	O
}	O
Off	short
=	O
pClass	pointer
[	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdClass	long
]	O
->	O
Prop	pointer
[	O
Ind	long
]	O
.	O
Off	short
;	O
Tipo	long
=	O
pClass	pointer
[	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdClass	long
]	O
->	O
Prop	pointer
[	O
Ind	long
]	O
.	O
Tipo	long
;	O
Punt	pointer
=	O
(	O
EPByte	pointer
)	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
Data	pointer
)	O
+	O
Off	short
;	O
va_start	O
(	O
p	pointer
,	O
Ind	long
)	O
;	O
if	O
(	O
Tipo	long
==	O
DT_EUSER	int
)	O
{	O
if	O
(	O
pClass	pointer
[	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdClass	long
]	O
->	O
Prop	pointer
[	O
Ind	long
]	O
.	O
UserInfo	long
!=	O
-	O
1	int
)	O
edma_met3	function
(	O
*	O
(	O
(	O
OBJID	long
*	O
)	O
Punt	pointer
)	O
,	O
"Read"	pointer
,	O
p	pointer
)	O
;	O
else	O
{	O
edma_printf_err	function
(	O
"[RProp1] User type not defined for property"	pointer
)	O
;	O
return	O
(	O
EPVoid	pointer
)	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
pClass	pointer
[	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdClass	long
]	O
->	O
Prop	pointer
[	O
Ind	long
]	O
.	O
nElem	long
!=	O
0	int
)	O
{	O
*	O
(	O
va_arg	O
(	O
p	pointer
,	O
EPByte	pointer
*	O
)	O
)	O
=	O
(	O
EPByte	pointer
)	O
Punt	pointer
;	O
return	O
Punt	pointer
;	O
}	O
switch	O
(	O
Tipo	long
)	O
{	O
case	O
DT_EBUFFER	int
:	O
Buf	struct
=	O
va_arg	O
(	O
p	pointer
,	O
EDMAT_BUFFER	struct
*	O
)	O
;	O
memcpy	function
(	O
Buf	struct
,	O
Punt	pointer
,	O
sizeof	O
(	O
EDMAT_BUFFER	struct
)	O
)	O
;	O
break	O
;	O
case	O
DT_EPOINTER	int
:	O
case	O
DT_EOBJECT	int
:	O
case	O
DT_EUINT32	int
:	O
*	O
(	O
va_arg	O
(	O
p	pointer
,	O
EPUint32	pointer
)	O
)	O
=	O
*	O
(	O
(	O
EPUint32	pointer
)	O
Punt	pointer
)	O
;	O
break	O
;	O
case	O
DT_ESINT32	int
:	O
*	O
(	O
va_arg	O
(	O
p	pointer
,	O
EPSint32	pointer
)	O
)	O
=	O
*	O
(	O
(	O
EPSint32	pointer
)	O
Punt	pointer
)	O
;	O
break	O
;	O
case	O
DT_ESINT8	int
:	O
case	O
DT_ECHAR	int
:	O
*	O
(	O
va_arg	O
(	O
p	pointer
,	O
EPChar	pointer
)	O
)	O
=	O
*	O
(	O
(	O
EPChar	pointer
)	O
Punt	pointer
)	O
;	O
break	O
;	O
case	O
DT_EZSTRING	int
:	O
c	pointer
=	O
(	O
va_arg	O
(	O
p	pointer
,	O
EPChar	pointer
)	O
)	O
;	O
c1	pointer
=	O
edma_pget	function
(	O
*	O
(	O
(	O
HMEM	long
*	O
)	O
Punt	pointer
)	O
)	O
;	O
strcpy	function
(	O
c	pointer
,	O
c1	pointer
)	O
;	O
break	O
;	O
case	O
DT_EUINT16	int
:	O
*	O
(	O
va_arg	O
(	O
p	pointer
,	O
EPUint16	pointer
)	O
)	O
=	O
*	O
(	O
(	O
EPUint16	pointer
)	O
Punt	pointer
)	O
;	O
break	O
;	O
case	O
DT_ESINT16	int
:	O
*	O
(	O
va_arg	O
(	O
p	pointer
,	O
EPSint16	pointer
)	O
)	O
=	O
*	O
(	O
(	O
EPSint16	pointer
)	O
Punt	pointer
)	O
;	O
break	O
;	O
case	O
DT_EUINT8	int
:	O
case	O
DT_EBYTE	int
:	O
*	O
(	O
va_arg	O
(	O
p	pointer
,	O
EPByte	pointer
)	O
)	O
=	O
*	O
(	O
(	O
EPByte	pointer
)	O
Punt	pointer
)	O
;	O
break	O
;	O
case	O
DT_EWORD	int
:	O
*	O
(	O
va_arg	O
(	O
p	pointer
,	O
EPWord	pointer
)	O
)	O
=	O
*	O
(	O
(	O
EPWord	pointer
)	O
Punt	pointer
)	O
;	O
break	O
;	O
case	O
DT_EDWORD	int
:	O
*	O
(	O
va_arg	O
(	O
p	pointer
,	O
EPDWord	pointer
)	O
)	O
=	O
*	O
(	O
(	O
EPDWord	pointer
)	O
Punt	pointer
)	O
;	O
break	O
;	O
case	O
DT_EREAL32	int
:	O
*	O
(	O
va_arg	O
(	O
p	pointer
,	O
EPReal32	pointer
)	O
)	O
=	O
*	O
(	O
(	O
EPReal32	pointer
)	O
Punt	pointer
)	O
;	O
break	O
;	O
case	O
DT_EREAL64	int
:	O
*	O
(	O
va_arg	O
(	O
p	pointer
,	O
EPReal64	pointer
)	O
)	O
=	O
*	O
(	O
(	O
EPReal64	pointer
)	O
Punt	pointer
)	O
;	O
break	O
;	O
}	O
return	O
Punt	pointer
;	O
}	O
EUint32	long
EDMAPROC	O
edma_met1	function
(	O
OBJID	long
IdObj	long
,	O
EUint32	long
Ind	long
,	O
EByte	char
Old	char
,	O
va_list	pointer
Val	pointer
)	O
{	O
PPROC	pointer
Func	pointer
;	O
EUint32	long
Tipo	long
,	O
i	long
;	O
POBJ	pointer
Obj	long
;	O
if	O
(	O
(	O
edma_check_obj_id	function
(	O
IdObj	long
,	O
"edma_met1"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
Obj	long
=	O
gObj	O
[	O
IdObj	long
]	O
;	O
Tipo	long
=	O
Obj	long
->	O
IdClass	long
;	O
if	O
(	O
(	O
pClass	pointer
[	O
Tipo	long
]	O
->	O
Met	pointer
[	O
Ind	long
]	O
.	O
Virtual	char
)	O
&&	O
Old	char
==	O
0	int
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
Tipo	long
]	O
->	O
nMetVir	long
;	O
i	long
++	O
)	O
if	O
(	O
Obj	long
->	O
vTable	pointer
[	O
i	long
]	O
.	O
Ind	long
==	O
Ind	long
)	O
break	O
;	O
Func	pointer
=	O
Obj	long
->	O
vTable	pointer
[	O
i	long
]	O
.	O
Func	pointer
;	O
IdObj	long
=	O
(	O
(	O
POBJ	pointer
)	O
Obj	long
->	O
vTable	pointer
[	O
i	long
]	O
.	O
Obj	long
)	O
->	O
IdObj	long
;	O
}	O
else	O
Func	pointer
=	O
(	O
PPROC	pointer
)	O
pClass	pointer
[	O
Tipo	long
]	O
->	O
met_func	pointer
[	O
Ind	long
]	O
.	O
Func	pointer
;	O
Tipo	long
=	O
Func	pointer
(	O
IdObj	long
,	O
Val	pointer
)	O
;	O
return	O
(	O
Tipo	long
)	O
;	O
}	O
EPVoid	pointer
EDMAPROC	O
_edma_wprop1_pargs	function
(	O
OBJID	long
IdObj	long
,	O
EUint32	long
Ind	long
,	O
va_list	pointer
p	pointer
)	O
{	O
EUint32	long
Tipo	long
;	O
EUint32	long
Off	short
;	O
EPVoid	pointer
Punt	pointer
;	O
EPChar	pointer
c	pointer
,	O
c1	pointer
;	O
HMEM	long
h	long
;	O
EUint32	long
tam	long
;	O
EDMAT_BUFFER	struct
Buf	struct
;	O
CLASSID	long
cid	long
;	O
if	O
(	O
(	O
edma_check_obj_id	function
(	O
IdObj	long
,	O
"_edma_wprop1_pargs"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
(	O
EPVoid	pointer
)	O
-	O
1	int
;	O
cid	long
=	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdClass	long
;	O
if	O
(	O
pClass	pointer
[	O
cid	long
]	O
->	O
Prop	pointer
[	O
Ind	long
]	O
.	O
ioTipo	char
==	O
L	int
)	O
{	O
edma_printf_err	function
(	O
"[ERROR] Property %s is read only"	pointer
,	O
pClass	pointer
[	O
cid	long
]	O
->	O
Prop	pointer
[	O
Ind	long
]	O
.	O
IdProp	array
)	O
;	O
return	O
(	O
EPVoid	pointer
)	O
-	O
1	int
;	O
}	O
Off	short
=	O
pClass	pointer
[	O
cid	long
]	O
->	O
Prop	pointer
[	O
Ind	long
]	O
.	O
Off	short
;	O
if	O
(	O
Off	short
>	O
gClass	O
[	O
cid	long
]	O
->	O
TamDatos	long
)	O
edma_printf_err	function
(	O
"[edma_wprop1_pargs] Offset out of ranger "	pointer
"for property %d of object %d"	pointer
,	O
Ind	long
,	O
IdObj	long
)	O
;	O
Tipo	long
=	O
pClass	pointer
[	O
cid	long
]	O
->	O
Prop	pointer
[	O
Ind	long
]	O
.	O
Tipo	long
;	O
Punt	pointer
=	O
(	O
EPByte	pointer
)	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
Data	pointer
)	O
+	O
Off	short
;	O
if	O
(	O
Tipo	long
==	O
DT_EUSER	int
)	O
{	O
if	O
(	O
pClass	pointer
[	O
cid	long
]	O
->	O
Prop	pointer
[	O
Ind	long
]	O
.	O
UserInfo	long
!=	O
-	O
1	int
)	O
edma_met3	function
(	O
*	O
(	O
(	O
OBJID	long
*	O
)	O
Punt	pointer
)	O
,	O
"Write"	pointer
,	O
p	pointer
)	O
;	O
else	O
{	O
edma_printf_err	function
(	O
"[edma_wprop1_pargs] User type not defined "	pointer
"for property"	pointer
)	O
;	O
return	O
(	O
EPVoid	pointer
)	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
(	O
tam	long
=	O
pClass	pointer
[	O
cid	long
]	O
->	O
Prop	pointer
[	O
Ind	long
]	O
.	O
nElem	long
)	O
!=	O
0	int
)	O
{	O
tam	long
*=	O
tipo	array
[	O
Tipo	long
]	O
.	O
tam	long
;	O
memcpy	function
(	O
Punt	pointer
,	O
va_arg	O
(	O
p	pointer
,	O
EPVoid	pointer
)	O
,	O
tam	long
)	O
;	O
return	O
p	pointer
;	O
}	O
switch	O
(	O
Tipo	long
)	O
{	O
case	O
DT_EBUFFER	int
:	O
Buf	struct
=	O
va_arg	O
(	O
p	pointer
,	O
EDMAT_BUFFER	struct
)	O
;	O
memcpy	function
(	O
Punt	pointer
,	O
&	O
Buf	struct
,	O
sizeof	O
(	O
EDMAT_BUFFER	struct
)	O
)	O
;	O
break	O
;	O
case	O
DT_EPOINTER	int
:	O
case	O
DT_EOBJECT	int
:	O
case	O
DT_EUINT32	int
:	O
*	O
(	O
(	O
EPUint32	pointer
)	O
Punt	pointer
)	O
=	O
va_arg	O
(	O
p	pointer
,	O
EUint32	long
)	O
;	O
break	O
;	O
case	O
DT_ESINT32	int
:	O
*	O
(	O
(	O
EPSint32	pointer
)	O
Punt	pointer
)	O
=	O
va_arg	O
(	O
p	pointer
,	O
ESint32	long
)	O
;	O
break	O
;	O
case	O
DT_ESINT8	int
:	O
case	O
DT_ECHAR	int
:	O
*	O
(	O
(	O
EPChar	pointer
)	O
Punt	pointer
)	O
=	O
va_arg	O
(	O
p	pointer
,	O
int	O
)	O
;	O
break	O
;	O
case	O
DT_EZSTRING	int
:	O
c	pointer
=	O
va_arg	O
(	O
p	pointer
,	O
EPChar	pointer
)	O
;	O
tam	long
=	O
strlen	function
(	O
c	pointer
)	O
;	O
edma_pfree	function
(	O
*	O
(	O
(	O
HMEM	long
*	O
)	O
Punt	pointer
)	O
,	O
(	O
EPVoid	pointer
)	O
*	O
(	O
(	O
HMEM	long
*	O
)	O
Punt	pointer
)	O
)	O
;	O
h	long
=	O
edma_palloc	function
(	O
sizeof	O
(	O
EByte	char
)	O
*	O
(	O
tam	long
+	O
1	int
)	O
)	O
;	O
c1	pointer
=	O
edma_pget	function
(	O
h	long
)	O
;	O
strncpy	function
(	O
c1	pointer
,	O
c	pointer
,	O
tam	long
)	O
;	O
c1	pointer
[	O
tam	long
]	O
=	O
0	int
;	O
*	O
(	O
(	O
HMEM	long
*	O
)	O
Punt	pointer
)	O
=	O
h	long
;	O
break	O
;	O
case	O
DT_ESINT16	int
:	O
*	O
(	O
(	O
EPSint16	pointer
)	O
Punt	pointer
)	O
=	O
va_arg	O
(	O
p	pointer
,	O
int	O
)	O
;	O
;	O
break	O
;	O
case	O
DT_EUINT16	int
:	O
*	O
(	O
(	O
EPUint16	pointer
)	O
Punt	pointer
)	O
=	O
va_arg	O
(	O
p	pointer
,	O
int	O
)	O
;	O
;	O
break	O
;	O
case	O
DT_EUINT8	int
:	O
case	O
DT_EBYTE	int
:	O
*	O
(	O
(	O
EPByte	pointer
)	O
Punt	pointer
)	O
=	O
va_arg	O
(	O
p	pointer
,	O
int	O
)	O
;	O
;	O
break	O
;	O
case	O
DT_EWORD	int
:	O
*	O
(	O
(	O
EPWord	pointer
)	O
Punt	pointer
)	O
=	O
va_arg	O
(	O
p	pointer
,	O
int	O
)	O
;	O
;	O
break	O
;	O
case	O
DT_EDWORD	int
:	O
*	O
(	O
(	O
EPDWord	pointer
)	O
Punt	pointer
)	O
=	O
va_arg	O
(	O
p	pointer
,	O
EDWord	long
)	O
;	O
;	O
break	O
;	O
case	O
DT_EREAL32	int
:	O
*	O
(	O
(	O
EPReal32	pointer
)	O
Punt	pointer
)	O
=	O
va_arg	O
(	O
p	pointer
,	O
EReal64	double
)	O
;	O
break	O
;	O
case	O
DT_EREAL64	int
:	O
*	O
(	O
(	O
EPReal64	pointer
)	O
Punt	pointer
)	O
=	O
va_arg	O
(	O
p	pointer
,	O
EReal64	double
)	O
;	O
break	O
;	O
}	O
return	O
Punt	pointer
;	O
}	O
EPVoid	pointer
EDMAPROC	O
_edma_rprop1_pargs	function
(	O
OBJID	long
IdObj	long
,	O
EUint32	long
Ind	long
,	O
va_list	pointer
p	pointer
)	O
{	O
EUint32	long
Tipo	long
;	O
EUint32	long
Off	short
;	O
EPVoid	pointer
Punt	pointer
;	O
EPChar	pointer
c1	pointer
,	O
c2	pointer
;	O
EDMAT_BUFFER	struct
*	O
Buf	struct
;	O
CLASSID	long
cid	long
;	O
if	O
(	O
(	O
edma_check_obj_id	function
(	O
IdObj	long
,	O
"_edma_rprop1_pargs"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
(	O
EPVoid	pointer
)	O
-	O
1	int
;	O
cid	long
=	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdClass	long
;	O
if	O
(	O
pClass	pointer
[	O
cid	long
]	O
->	O
Prop	pointer
[	O
Ind	long
]	O
.	O
ioTipo	char
==	O
E	int
)	O
{	O
edma_printf_err	function
(	O
"[ERROR] Property %s is write only... "	pointer
"whatever means that!"	pointer
,	O
pClass	pointer
[	O
cid	long
]	O
->	O
Prop	pointer
[	O
Ind	long
]	O
.	O
IdProp	array
)	O
;	O
return	O
(	O
EPVoid	pointer
)	O
-	O
1	int
;	O
}	O
Off	short
=	O
pClass	pointer
[	O
cid	long
]	O
->	O
Prop	pointer
[	O
Ind	long
]	O
.	O
Off	short
;	O
Tipo	long
=	O
pClass	pointer
[	O
cid	long
]	O
->	O
Prop	pointer
[	O
Ind	long
]	O
.	O
Tipo	long
;	O
Punt	pointer
=	O
(	O
EPByte	pointer
)	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
Data	pointer
)	O
+	O
Off	short
;	O
if	O
(	O
Tipo	long
==	O
DT_EUSER	int
)	O
{	O
if	O
(	O
pClass	pointer
[	O
cid	long
]	O
->	O
Prop	pointer
[	O
Ind	long
]	O
.	O
UserInfo	long
!=	O
-	O
1	int
)	O
edma_met3	function
(	O
*	O
(	O
(	O
OBJID	long
*	O
)	O
Punt	pointer
)	O
,	O
"Read"	pointer
,	O
p	pointer
)	O
;	O
else	O
{	O
edma_printf_err	function
(	O
"[_edma_rprop1_pargs] User type not defined "	pointer
"for property"	pointer
)	O
;	O
return	O
(	O
EPVoid	pointer
)	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
pClass	pointer
[	O
cid	long
]	O
->	O
Prop	pointer
[	O
Ind	long
]	O
.	O
nElem	long
!=	O
0	int
)	O
{	O
*	O
(	O
va_arg	O
(	O
p	pointer
,	O
EPByte	pointer
*	O
)	O
)	O
=	O
Punt	pointer
;	O
return	O
Punt	pointer
;	O
}	O
switch	O
(	O
Tipo	long
)	O
{	O
case	O
DT_EBUFFER	int
:	O
Buf	struct
=	O
va_arg	O
(	O
p	pointer
,	O
EDMAT_BUFFER	struct
*	O
)	O
;	O
memcpy	function
(	O
Buf	struct
,	O
Punt	pointer
,	O
sizeof	O
(	O
EDMAT_BUFFER	struct
)	O
)	O
;	O
break	O
;	O
case	O
DT_EPOINTER	int
:	O
case	O
DT_EOBJECT	int
:	O
case	O
DT_EUINT32	int
:	O
*	O
(	O
va_arg	O
(	O
p	pointer
,	O
EPUint32	pointer
)	O
)	O
=	O
*	O
(	O
(	O
EPUint32	pointer
)	O
Punt	pointer
)	O
;	O
return	O
(	O
EPVoid	pointer
)	O
(	O
*	O
(	O
(	O
EPUint32	pointer
)	O
Punt	pointer
)	O
)	O
;	O
break	O
;	O
case	O
DT_ESINT32	int
:	O
*	O
(	O
va_arg	O
(	O
p	pointer
,	O
EPSint32	pointer
)	O
)	O
=	O
*	O
(	O
(	O
EPSint32	pointer
)	O
Punt	pointer
)	O
;	O
return	O
(	O
EPVoid	pointer
)	O
(	O
*	O
(	O
(	O
EPSint32	pointer
)	O
Punt	pointer
)	O
)	O
;	O
break	O
;	O
case	O
DT_ESINT8	int
:	O
case	O
DT_ECHAR	int
:	O
*	O
(	O
va_arg	O
(	O
p	pointer
,	O
EPChar	pointer
)	O
)	O
=	O
*	O
(	O
(	O
EPChar	pointer
)	O
Punt	pointer
)	O
;	O
return	O
(	O
EPVoid	pointer
)	O
(	O
*	O
(	O
(	O
EPChar	pointer
*	O
)	O
Punt	pointer
)	O
)	O
;	O
break	O
;	O
case	O
DT_EZSTRING	int
:	O
c2	pointer
=	O
(	O
EPChar	pointer
)	O
(	O
va_arg	O
(	O
p	pointer
,	O
EPChar	pointer
)	O
)	O
;	O
c1	pointer
=	O
edma_pget	function
(	O
*	O
(	O
(	O
HMEM	long
*	O
)	O
Punt	pointer
)	O
)	O
;	O
strcpy	function
(	O
c2	pointer
,	O
c1	pointer
)	O
;	O
break	O
;	O
case	O
DT_ESINT16	int
:	O
*	O
(	O
va_arg	O
(	O
p	pointer
,	O
EPSint16	pointer
)	O
)	O
=	O
*	O
(	O
(	O
EPSint16	pointer
)	O
Punt	pointer
)	O
;	O
return	O
(	O
EPVoid	pointer
)	O
*	O
(	O
(	O
EPSint16	pointer
*	O
)	O
Punt	pointer
)	O
;	O
break	O
;	O
case	O
DT_EUINT16	int
:	O
*	O
(	O
va_arg	O
(	O
p	pointer
,	O
EPUint16	pointer
)	O
)	O
=	O
*	O
(	O
(	O
EPUint16	pointer
)	O
Punt	pointer
)	O
;	O
return	O
(	O
EPVoid	pointer
)	O
*	O
(	O
(	O
EPUint16	pointer
*	O
)	O
Punt	pointer
)	O
;	O
break	O
;	O
case	O
DT_EUINT8	int
:	O
case	O
DT_EBYTE	int
:	O
*	O
(	O
va_arg	O
(	O
p	pointer
,	O
EPByte	pointer
)	O
)	O
=	O
*	O
(	O
(	O
EPByte	pointer
)	O
Punt	pointer
)	O
;	O
return	O
(	O
EPVoid	pointer
)	O
*	O
(	O
(	O
EPByte	pointer
*	O
)	O
Punt	pointer
)	O
;	O
break	O
;	O
case	O
DT_EWORD	int
:	O
*	O
(	O
va_arg	O
(	O
p	pointer
,	O
EPWord	pointer
)	O
)	O
=	O
*	O
(	O
(	O
EPWord	pointer
)	O
Punt	pointer
)	O
;	O
return	O
(	O
EPVoid	pointer
)	O
*	O
(	O
(	O
EPWord	pointer
*	O
)	O
Punt	pointer
)	O
;	O
break	O
;	O
case	O
DT_EDWORD	int
:	O
*	O
(	O
va_arg	O
(	O
p	pointer
,	O
EPDWord	pointer
)	O
)	O
=	O
*	O
(	O
(	O
EPDWord	pointer
)	O
Punt	pointer
)	O
;	O
return	O
(	O
EPVoid	pointer
)	O
*	O
(	O
(	O
EPDWord	pointer
)	O
Punt	pointer
)	O
;	O
break	O
;	O
case	O
DT_EREAL32	int
:	O
*	O
(	O
va_arg	O
(	O
p	pointer
,	O
EPReal32	pointer
)	O
)	O
=	O
*	O
(	O
(	O
EPReal32	pointer
)	O
Punt	pointer
)	O
;	O
break	O
;	O
case	O
DT_EREAL64	int
:	O
*	O
(	O
va_arg	O
(	O
p	pointer
,	O
EPReal64	pointer
)	O
)	O
=	O
*	O
(	O
(	O
EPReal64	pointer
)	O
Punt	pointer
)	O
;	O
break	O
;	O
}	O
return	O
Punt	pointer
;	O
}	O
EUint32	long
EDMAPROC	O
_edma_met1_pargs	function
(	O
OBJID	long
IdObj	long
,	O
EUint32	long
Ind	long
,	O
EByte	char
Old	char
,	O
va_list	pointer
p	pointer
)	O
{	O
EUint32	long
Tipo	long
,	O
i	long
;	O
POBJ	pointer
Obj	long
;	O
PPROC	pointer
Func	pointer
;	O
if	O
(	O
(	O
edma_check_obj_id	function
(	O
IdObj	long
,	O
"_edma_met1_pargs"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
(	O
EUint32	long
)	O
-	O
1	int
;	O
Obj	long
=	O
gObj	O
[	O
IdObj	long
]	O
;	O
Tipo	long
=	O
Obj	long
->	O
IdClass	long
;	O
if	O
(	O
(	O
pClass	pointer
[	O
Tipo	long
]	O
->	O
Met	pointer
[	O
Ind	long
]	O
.	O
Virtual	char
)	O
&&	O
Old	char
==	O
0	int
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
Tipo	long
]	O
->	O
nMetVir	long
;	O
i	long
++	O
)	O
if	O
(	O
Obj	long
->	O
vTable	pointer
[	O
i	long
]	O
.	O
Ind	long
==	O
Ind	long
)	O
break	O
;	O
Func	pointer
=	O
(	O
PPROC	pointer
)	O
Obj	long
->	O
vTable	pointer
[	O
i	long
]	O
.	O
Func	pointer
;	O
IdObj	long
=	O
(	O
(	O
POBJ	pointer
)	O
Obj	long
->	O
vTable	pointer
[	O
i	long
]	O
.	O
Obj	long
)	O
->	O
IdObj	long
;	O
}	O
else	O
Func	pointer
=	O
(	O
PPROC	pointer
)	O
pClass	pointer
[	O
Obj	long
->	O
IdClass	long
]	O
->	O
met_func	pointer
[	O
Ind	long
]	O
.	O
Func	pointer
;	O
if	O
(	O
Func	pointer
)	O
return	O
Func	pointer
(	O
IdObj	long
,	O
va_arg	O
(	O
p	pointer
,	O
long	O
*	O
)	O
,	O
va_arg	O
(	O
p	pointer
,	O
long	O
*	O
)	O
,	O
va_arg	O
(	O
p	pointer
,	O
long	O
*	O
)	O
,	O
va_arg	O
(	O
p	pointer
,	O
long	O
*	O
)	O
,	O
va_arg	O
(	O
p	pointer
,	O
long	O
*	O
)	O
,	O
va_arg	O
(	O
p	pointer
,	O
long	O
*	O
)	O
,	O
va_arg	O
(	O
p	pointer
,	O
long	O
*	O
)	O
,	O
va_arg	O
(	O
p	pointer
,	O
long	O
*	O
)	O
,	O
va_arg	O
(	O
p	pointer
,	O
long	O
*	O
)	O
,	O
va_arg	O
(	O
p	pointer
,	O
long	O
*	O
)	O
)	O
;	O
else	O
return	O
0	int
;	O
}	O
EUint32	long
EDMAPROC	O
edma_prop1_size	function
(	O
OBJID	long
IdObj	long
,	O
EUint32	long
Ind	long
)	O
{	O
EUint32	long
Tipo	long
;	O
EUint32	long
Off	short
;	O
EPVoid	pointer
Punt	pointer
;	O
EPChar	pointer
c1	pointer
;	O
EUint32	long
size	long
;	O
CLASSID	long
cid	long
;	O
if	O
(	O
(	O
edma_check_obj_id	function
(	O
IdObj	long
,	O
"edma_prop1_size"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
(	O
EUint32	long
)	O
-	O
1	int
;	O
cid	long
=	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdClass	long
;	O
Off	short
=	O
pClass	pointer
[	O
cid	long
]	O
->	O
Prop	pointer
[	O
Ind	long
]	O
.	O
Off	short
;	O
Tipo	long
=	O
pClass	pointer
[	O
cid	long
]	O
->	O
Prop	pointer
[	O
Ind	long
]	O
.	O
Tipo	long
;	O
Punt	pointer
=	O
(	O
EPByte	pointer
)	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
Data	pointer
)	O
+	O
Off	short
;	O
if	O
(	O
pClass	pointer
[	O
cid	long
]	O
->	O
Prop	pointer
[	O
Ind	long
]	O
.	O
nElem	long
!=	O
0	int
)	O
{	O
return	O
pClass	pointer
[	O
cid	long
]	O
->	O
Prop	pointer
[	O
Ind	long
]	O
.	O
nElem	long
;	O
}	O
switch	O
(	O
Tipo	long
)	O
{	O
case	O
DT_EBUFFER	int
:	O
size	long
=	O
(	O
(	O
(	O
EDMAT_BUFFER	struct
*	O
)	O
Punt	pointer
)	O
->	O
Size	long
)	O
;	O
break	O
;	O
case	O
DT_EZSTRING	int
:	O
c1	pointer
=	O
edma_pget	function
(	O
*	O
(	O
(	O
HMEM	long
*	O
)	O
Punt	pointer
)	O
)	O
;	O
if	O
(	O
c1	pointer
)	O
size	long
=	O
strlen	function
(	O
c1	pointer
)	O
;	O
else	O
size	long
=	O
0	int
;	O
break	O
;	O
default	O
:	O
size	long
=	O
tipo	array
[	O
Tipo	long
]	O
.	O
tam	long
;	O
}	O
return	O
size	long
;	O
}	O
