RCSTAG_CC	O
(	O
"$GNU$"	pointer
)	O
;	O
extern	O
void	O
need_chars	function
(	O
buf_ty	struct
*	O
bp	pointer
,	O
size_t	long
needed	long
)	O
{	O
size_t	long
current_size	long
=	O
(	O
size_t	long
)	O
(	O
bp	pointer
->	O
end	pointer
-	O
bp	pointer
->	O
ptr	pointer
)	O
;	O
if	O
(	O
current_size	long
+	O
needed	long
>=	O
(	O
size_t	long
)	O
bp	pointer
->	O
size	long
)	O
{	O
bp	pointer
->	O
size	long
=	O
(	O
(	O
current_size	long
+	O
needed	long
)	O
&	O
(	O
size_t	long
)	O
~	O
1023	int
)	O
;	O
bp	pointer
->	O
ptr	pointer
=	O
xrealloc	function
(	O
bp	pointer
->	O
ptr	pointer
,	O
bp	pointer
->	O
size	long
)	O
;	O
if	O
(	O
bp	pointer
->	O
ptr	pointer
==	O
NULL	O
)	O
{	O
fatal	function
(	O
_	O
(	O
"Ran out of memory"	pointer
)	O
,	O
0	int
)	O
;	O
}	O
bp	pointer
->	O
end	pointer
=	O
bp	pointer
->	O
ptr	pointer
+	O
current_size	long
;	O
}	O
}	O
extern	O
void	O
check_code_size	function
(	O
void	O
)	O
{	O
if	O
(	O
e_code	pointer
>=	O
l_code	pointer
)	O
{	O
int	O
nsize	int
=	O
l_code	pointer
-	O
s_code	pointer
+	O
400	int
;	O
codebuf	pointer
=	O
xrealloc	function
(	O
codebuf	pointer
,	O
nsize	int
)	O
;	O
e_code	pointer
=	O
codebuf	pointer
+	O
(	O
e_code	pointer
-	O
s_code	pointer
)	O
+	O
1	int
;	O
l_code	pointer
=	O
codebuf	pointer
+	O
nsize	int
-	O
5	int
;	O
s_code	pointer
=	O
codebuf	pointer
+	O
1	int
;	O
}	O
}	O
static	O
void	O
check_lab_size	function
(	O
void	O
)	O
{	O
if	O
(	O
e_lab	pointer
>=	O
l_lab	pointer
)	O
{	O
int	O
nsize	int
=	O
l_lab	pointer
-	O
s_lab	pointer
+	O
400	int
;	O
labbuf	pointer
=	O
xrealloc	function
(	O
labbuf	pointer
,	O
nsize	int
)	O
;	O
e_lab	pointer
=	O
labbuf	pointer
+	O
(	O
e_lab	pointer
-	O
s_lab	pointer
)	O
+	O
1	int
;	O
l_lab	pointer
=	O
labbuf	pointer
+	O
nsize	int
-	O
5	int
;	O
s_lab	pointer
=	O
labbuf	pointer
+	O
1	int
;	O
}	O
}	O
static	O
void	O
copy_id	function
(	O
const	O
codes_ty	enum
type_code	enum
,	O
BOOLEAN	char
*	O
force_nl	int
,	O
exit_values_ty	enum
*	O
file_exit_value	pointer
,	O
const	O
bb_code_ty	enum
can_break	enum
)	O
{	O
char	O
*	O
t_ptr	pointer
;	O
if	O
(	O
parser_state_tos	pointer
->	O
want_blank	int
)	O
{	O
set_buf_break	function
(	O
bb_ident	int
,	O
paren_target	int
)	O
;	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
' '	O
;	O
}	O
else	O
if	O
(	O
can_break	enum
)	O
{	O
set_buf_break	function
(	O
can_break	enum
,	O
paren_target	int
)	O
;	O
}	O
else	O
{	O
}	O
if	O
(	O
s_code	pointer
==	O
e_code	pointer
)	O
{	O
s_code_corresponds_to	pointer
=	O
token	pointer
;	O
}	O
for	O
(	O
t_ptr	pointer
=	O
token	pointer
;	O
t_ptr	pointer
<	O
token_end	pointer
;	O
++	O
t_ptr	pointer
)	O
{	O
check_code_size	function
(	O
)	O
;	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
*	O
t_ptr	pointer
;	O
}	O
*	O
e_code	pointer
=	O
'\0'	O
;	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
true	int
;	O
if	O
(	O
(	O
type_code	enum
==	O
sp_paren	int
)	O
&&	O
(	O
(	O
!	O
settings	struct
.	O
space_after_if	int
&&	O
(	O
*	O
token	pointer
==	O
'i'	O
)	O
)	O
||	O
(	O
!	O
settings	struct
.	O
space_after_for	int
&&	O
(	O
*	O
token	pointer
==	O
'f'	O
)	O
)	O
||	O
(	O
!	O
settings	struct
.	O
space_after_while	int
&&	O
(	O
*	O
token	pointer
==	O
'w'	O
)	O
)	O
)	O
)	O
{	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
false	int
;	O
}	O
if	O
(	O
(	O
(	O
(	O
token_end	pointer
-	O
token	pointer
)	O
==	O
1	int
)	O
&&	O
(	O
*	O
token	pointer
==	O
'_'	O
)	O
)	O
||	O
(	O
(	O
(	O
token_end	pointer
-	O
token	pointer
)	O
==	O
2	int
)	O
&&	O
(	O
*	O
token	pointer
==	O
'N'	O
)	O
&&	O
(	O
token	pointer
[	O
1	int
]	O
==	O
'_'	O
)	O
)	O
)	O
{	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
false	int
;	O
}	O
if	O
(	O
(	O
(	O
token_end	pointer
-	O
token	pointer
)	O
==	O
6	int
)	O
&&	O
(	O
strncmp	function
(	O
token	pointer
,	O
"va_dcl"	pointer
,	O
6	int
)	O
==	O
0	int
)	O
)	O
{	O
parser_state_tos	pointer
->	O
in_or_st	int
=	O
0	int
;	O
parser_state_tos	pointer
->	O
just_saw_decl	int
--	O
;	O
parser_state_tos	pointer
->	O
in_decl	char
=	O
false	int
;	O
do	O
{	O
if	O
(	O
parse	function
(	O
semicolon	int
)	O
!=	O
total_success	int
)	O
{	O
*	O
file_exit_value	pointer
=	O
indent_error	int
;	O
}	O
}	O
while	O
(	O
0	int
)	O
;	O
*	O
force_nl	int
=	O
true	int
;	O
}	O
}	O
static	O
void	O
handle_token_form_feed	function
(	O
BOOLEAN	char
*	O
pbreak_line	pointer
)	O
{	O
parser_state_tos	pointer
->	O
use_ff	int
=	O
true	int
;	O
dump_line	function
(	O
true	int
,	O
&	O
paren_target	int
,	O
pbreak_line	pointer
)	O
;	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
false	int
;	O
}	O
static	O
void	O
handle_token_newline	function
(	O
BOOLEAN	char
*	O
force_nl	int
,	O
BOOLEAN	char
*	O
pbreak_line	pointer
)	O
{	O
if	O
(	O
s_lab	pointer
!=	O
e_lab	pointer
&&	O
*	O
s_lab	pointer
==	O
'#'	O
)	O
{	O
dump_line	function
(	O
true	int
,	O
&	O
paren_target	int
,	O
pbreak_line	pointer
)	O
;	O
if	O
(	O
s_code	pointer
==	O
e_code	pointer
)	O
{	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
false	int
;	O
}	O
*	O
force_nl	int
=	O
false	int
;	O
}	O
else	O
{	O
if	O
(	O
(	O
(	O
parser_state_tos	pointer
->	O
last_token	enum
!=	O
comma	int
)	O
||	O
!	O
settings	struct
.	O
leave_comma	int
||	O
!	O
break_comma	int
||	O
(	O
parser_state_tos	pointer
->	O
p_l_follow	int
>	O
0	int
)	O
||	O
parser_state_tos	pointer
->	O
block_init	int
||	O
(	O
s_com	pointer
!=	O
e_com	pointer
)	O
)	O
&&	O
(	O
(	O
(	O
parser_state_tos	pointer
->	O
last_token	enum
!=	O
rbrace	int
)	O
||	O
!	O
(	O
settings	struct
.	O
braces_on_struct_decl_line	int
&&	O
parser_state_tos	pointer
->	O
in_decl	char
)	O
)	O
)	O
)	O
{	O
if	O
(	O
!	O
settings	struct
.	O
procnames_start_line	int
&&	O
(	O
s_lab	pointer
==	O
e_lab	pointer
)	O
&&	O
(	O
parser_state_tos	pointer
->	O
last_token	enum
!=	O
lparen	int
)	O
&&	O
(	O
parser_state_tos	pointer
->	O
last_token	enum
!=	O
semicolon	int
)	O
&&	O
(	O
parser_state_tos	pointer
->	O
last_token	enum
!=	O
comma	int
)	O
&&	O
(	O
parser_state_tos	pointer
->	O
last_rw	enum
==	O
rw_decl	int
)	O
&&	O
(	O
parser_state_tos	pointer
->	O
last_rw_depth	int
==	O
0	int
)	O
&&	O
(	O
!	O
parser_state_tos	pointer
->	O
block_init	int
)	O
&&	O
(	O
parser_state_tos	pointer
->	O
in_decl	char
)	O
)	O
{	O
if	O
(	O
!	O
(	O
(	O
e_code	pointer
>	O
s_code	pointer
)	O
&&	O
(	O
e_code	pointer
[	O
-	O
1	int
]	O
==	O
'*'	O
)	O
)	O
)	O
{	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
true	int
;	O
}	O
}	O
if	O
(	O
!	O
parser_state_tos	pointer
->	O
in_stmt	int
||	O
(	O
s_com	pointer
!=	O
e_com	pointer
)	O
||	O
embedded_comment_on_line	int
)	O
{	O
dump_line	function
(	O
true	int
,	O
&	O
paren_target	int
,	O
pbreak_line	pointer
)	O
;	O
if	O
(	O
s_code	pointer
==	O
e_code	pointer
)	O
{	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
false	int
;	O
}	O
*	O
force_nl	int
=	O
false	int
;	O
}	O
}	O
}	O
else_or_endif	int
=	O
false	int
;	O
++	O
line_no	int
;	O
}	O
static	O
void	O
handle_token_lparen	function
(	O
BOOLEAN	char
*	O
force_nl	int
,	O
BOOLEAN	char
*	O
sp_sw	pointer
,	O
int	O
*	O
dec_ind	pointer
,	O
BOOLEAN	char
*	O
pbreak_line	pointer
)	O
{	O
if	O
(	O
(	O
*	O
token	pointer
==	O
'{'	O
)	O
&&	O
(	O
(	O
s_code	pointer
!=	O
e_code	pointer
)	O
||	O
(	O
s_com	pointer
!=	O
e_com	pointer
)	O
||	O
(	O
s_lab	pointer
!=	O
e_lab	pointer
)	O
)	O
)	O
{	O
dump_line	function
(	O
true	int
,	O
&	O
paren_target	int
,	O
pbreak_line	pointer
)	O
;	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
false	int
;	O
}	O
++	O
parser_state_tos	pointer
->	O
p_l_follow	int
;	O
if	O
(	O
parser_state_tos	pointer
->	O
p_l_follow	int
>=	O
parser_state_tos	pointer
->	O
paren_indents_size	int
)	O
{	O
parser_state_tos	pointer
->	O
paren_indents_size	int
*=	O
2	int
;	O
parser_state_tos	pointer
->	O
paren_indents	pointer
=	O
xrealloc	function
(	O
parser_state_tos	pointer
->	O
paren_indents	pointer
,	O
parser_state_tos	pointer
->	O
paren_indents_size	int
*	O
sizeof	O
(	O
short	O
)	O
)	O
;	O
}	O
parser_state_tos	pointer
->	O
paren_depth	int
++	O
;	O
if	O
(	O
parser_state_tos	pointer
->	O
is_func_ptr_decl	int
&&	O
!	O
settings	struct
.	O
proc_calls_space	int
)	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
(	O
*	O
(	O
token	pointer
-	O
1	int
)	O
!=	O
')'	O
&&	O
*	O
(	O
token	pointer
-	O
1	int
)	O
!=	O
' '	O
)	O
;	O
if	O
(	O
parser_state_tos	pointer
->	O
want_blank	int
&&	O
(	O
*	O
token	pointer
!=	O
'['	O
)	O
&&	O
(	O
(	O
parser_state_tos	pointer
->	O
last_token	enum
!=	O
ident	int
)	O
||	O
settings	struct
.	O
proc_calls_space	int
||	O
(	O
parser_state_tos	pointer
->	O
its_a_keyword	int
&&	O
(	O
!	O
parser_state_tos	pointer
->	O
sizeof_keyword	int
||	O
settings	struct
.	O
blank_after_sizeof	int
)	O
)	O
)	O
)	O
{	O
set_buf_break	function
(	O
bb_proc_call	int
,	O
paren_target	int
)	O
;	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
' '	O
;	O
*	O
e_code	pointer
=	O
'\0'	O
;	O
}	O
else	O
{	O
set_buf_break	function
(	O
bb_proc_call	int
,	O
paren_target	int
)	O
;	O
}	O
if	O
(	O
*	O
(	O
token	pointer
+	O
1	int
)	O
==	O
'*'	O
&&	O
parser_state_tos	pointer
->	O
last_rw	enum
==	O
rw_decl	int
&&	O
(	O
parser_state_tos	pointer
->	O
last_token	enum
==	O
decl	int
||	O
parser_state_tos	pointer
->	O
last_token	enum
==	O
unary_op	int
)	O
)	O
parser_state_tos	pointer
->	O
is_func_ptr_decl	int
=	O
true	int
;	O
if	O
(	O
parser_state_tos	pointer
->	O
in_decl	char
&&	O
!	O
parser_state_tos	pointer
->	O
block_init	int
)	O
{	O
if	O
(	O
(	O
*	O
token	pointer
!=	O
'['	O
)	O
&&	O
!	O
buf_break_used	int
)	O
{	O
while	O
(	O
(	O
e_code	pointer
-	O
s_code	pointer
)	O
<	O
*	O
dec_ind	pointer
)	O
{	O
check_code_size	function
(	O
)	O
;	O
set_buf_break	function
(	O
bb_dec_ind	int
,	O
paren_target	int
)	O
;	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
' '	O
;	O
}	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
token	pointer
[	O
0	int
]	O
;	O
parser_state_tos	pointer
->	O
ind_stmt	int
=	O
false	int
;	O
}	O
else	O
{	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
token	pointer
[	O
0	int
]	O
;	O
}	O
}	O
else	O
{	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
token	pointer
[	O
0	int
]	O
;	O
}	O
if	O
(	O
settings	struct
.	O
parentheses_space	int
&&	O
*	O
token	pointer
!=	O
'['	O
)	O
{	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
' '	O
;	O
}	O
parser_state_tos	pointer
->	O
paren_indents	pointer
[	O
parser_state_tos	pointer
->	O
p_l_follow	int
-	O
1	int
]	O
=	O
e_code	pointer
-	O
s_code	pointer
;	O
if	O
(	O
*	O
sp_sw	pointer
&&	O
(	O
parser_state_tos	pointer
->	O
p_l_follow	int
==	O
1	int
)	O
&&	O
settings	struct
.	O
extra_expression_indent	int
&&	O
(	O
parser_state_tos	pointer
->	O
paren_indents	pointer
[	O
0	int
]	O
<	O
2	int
*	O
settings	struct
.	O
ind_size	int
)	O
)	O
{	O
parser_state_tos	pointer
->	O
paren_indents	pointer
[	O
0	int
]	O
=	O
2	int
*	O
settings	struct
.	O
ind_size	int
;	O
}	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
false	int
;	O
if	O
(	O
(	O
parser_state_tos	pointer
->	O
in_or_st	int
==	O
1	int
)	O
&&	O
*	O
token	pointer
==	O
'('	O
)	O
{	O
parse_lparen_in_decl	function
(	O
)	O
;	O
parser_state_tos	pointer
->	O
in_or_st	int
=	O
0	int
;	O
}	O
if	O
(	O
(	O
*	O
token	pointer
==	O
'('	O
)	O
&&	O
settings	struct
.	O
break_function_decl_args	int
&&	O
parser_state_tos	pointer
->	O
in_stmt	int
&&	O
parser_state_tos	pointer
->	O
in_decl	char
&&	O
(	O
parser_state_tos	pointer
->	O
paren_depth	int
==	O
1	int
)	O
)	O
{	O
dump_line	function
(	O
true	int
,	O
&	O
paren_target	int
,	O
pbreak_line	pointer
)	O
;	O
*	O
force_nl	int
=	O
false	int
;	O
paren_target	int
=	O
parser_state_tos	pointer
->	O
paren_depth	int
*	O
settings	struct
.	O
ind_size	int
+	O
1	int
;	O
parser_state_tos	pointer
->	O
paren_indents	pointer
[	O
parser_state_tos	pointer
->	O
p_l_follow	int
-	O
1	int
]	O
=	O
-	O
paren_target	int
;	O
}	O
if	O
(	O
parser_state_tos	pointer
->	O
sizeof_keyword	int
)	O
{	O
parser_state_tos	pointer
->	O
sizeof_mask	int
|=	O
1	int
<<	O
parser_state_tos	pointer
->	O
p_l_follow	int
;	O
}	O
if	O
(	O
(	O
parser_state_tos	pointer
->	O
last_token	enum
==	O
decl	int
)	O
||	O
(	O
(	O
parser_state_tos	pointer
->	O
last_token	enum
==	O
ident	int
)	O
&&	O
(	O
parser_state_tos	pointer
->	O
last_rw	enum
!=	O
rw_return	int
)	O
)	O
)	O
{	O
parser_state_tos	pointer
->	O
noncast_mask	int
|=	O
1	int
<<	O
parser_state_tos	pointer
->	O
p_l_follow	int
;	O
}	O
else	O
{	O
parser_state_tos	pointer
->	O
noncast_mask	int
&=	O
~	O
(	O
1	int
<<	O
parser_state_tos	pointer
->	O
p_l_follow	int
)	O
;	O
}	O
}	O
static	O
void	O
handle_token_rparen	function
(	O
BOOLEAN	char
*	O
force_nl	int
,	O
BOOLEAN	char
*	O
sp_sw	pointer
,	O
codes_ty	enum
*	O
hd_type	pointer
,	O
BOOLEAN	char
*	O
last_token_ends_sp	pointer
,	O
exit_values_ty	enum
*	O
file_exit_value	pointer
,	O
BOOLEAN	char
*	O
pbreak_line	pointer
)	O
{	O
char	O
tmpchar	array
[	O
2	int
]	O
,	O
*	O
tmp	pointer
;	O
parser_state_tos	pointer
->	O
paren_depth	int
--	O
;	O
if	O
(	O
(	O
*	O
token	pointer
==	O
')'	O
)	O
&&	O
settings	struct
.	O
break_function_decl_args_end	int
&&	O
!	O
parser_state_tos	pointer
->	O
in_or_st	int
&&	O
parser_state_tos	pointer
->	O
in_stmt	int
&&	O
parser_state_tos	pointer
->	O
in_decl	char
&&	O
(	O
parser_state_tos	pointer
->	O
paren_depth	int
==	O
0	int
)	O
)	O
{	O
if	O
(	O
(	O
s_code	pointer
!=	O
e_code	pointer
)	O
||	O
(	O
s_lab	pointer
!=	O
e_lab	pointer
)	O
||	O
(	O
s_com	pointer
!=	O
e_com	pointer
)	O
)	O
{	O
dump_line	function
(	O
true	int
,	O
&	O
paren_target	int
,	O
pbreak_line	pointer
)	O
;	O
}	O
paren_target	int
=	O
parser_state_tos	pointer
->	O
paren_depth	int
*	O
settings	struct
.	O
ind_size	int
;	O
parser_state_tos	pointer
->	O
paren_indents	pointer
[	O
parser_state_tos	pointer
->	O
p_l_follow	int
-	O
1	int
]	O
=	O
paren_target	int
;	O
parser_state_tos	pointer
->	O
ind_stmt	int
=	O
0	int
;	O
}	O
if	O
(	O
parser_state_tos	pointer
->	O
cast_mask	int
&	O
(	O
1	int
<<	O
parser_state_tos	pointer
->	O
p_l_follow	int
)	O
&	O
~	O
parser_state_tos	pointer
->	O
sizeof_mask	int
)	O
{	O
parser_state_tos	pointer
->	O
last_u_d	int
=	O
true	int
;	O
parser_state_tos	pointer
->	O
cast_mask	int
&=	O
(	O
1	int
<<	O
parser_state_tos	pointer
->	O
p_l_follow	int
)	O
-	O
1	int
;	O
if	O
(	O
!	O
parser_state_tos	pointer
->	O
cast_mask	int
&&	O
settings	struct
.	O
cast_space	int
)	O
{	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
true	int
;	O
}	O
else	O
{	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
false	int
;	O
parser_state_tos	pointer
->	O
can_break	enum
=	O
bb_cast	int
;	O
}	O
tmp	pointer
=	O
token	pointer
+	O
1	int
;	O
while	O
(	O
isspace	function
(	O
*	O
tmp	pointer
)	O
)	O
tmp	pointer
++	O
;	O
if	O
(	O
*	O
tmp	pointer
==	O
'{'	O
)	O
parser_state_tos	pointer
->	O
block_init	int
=	O
3	int
;	O
}	O
else	O
if	O
(	O
parser_state_tos	pointer
->	O
in_decl	char
&&	O
!	O
parser_state_tos	pointer
->	O
block_init	int
&&	O
(	O
parser_state_tos	pointer
->	O
paren_depth	int
==	O
0	int
)	O
)	O
{	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
true	int
;	O
}	O
else	O
{	O
}	O
parser_state_tos	pointer
->	O
sizeof_mask	int
&=	O
(	O
1	int
<<	O
parser_state_tos	pointer
->	O
p_l_follow	int
)	O
-	O
1	int
;	O
if	O
(	O
--	O
parser_state_tos	pointer
->	O
p_l_follow	int
<	O
0	int
)	O
{	O
parser_state_tos	pointer
->	O
p_l_follow	int
=	O
0	int
;	O
tmpchar	array
[	O
0	int
]	O
=	O
*	O
token	pointer
;	O
tmpchar	array
[	O
1	int
]	O
=	O
'\0'	O
;	O
WARNING	O
(	O
_	O
(	O
"Extra %s"	pointer
)	O
,	O
tmpchar	array
,	O
NULL	O
)	O
;	O
}	O
if	O
(	O
e_code	pointer
==	O
s_code	pointer
)	O
{	O
int	O
level	int
=	O
parser_state_tos	pointer
->	O
p_l_follow	int
;	O
parser_state_tos	pointer
->	O
paren_level	int
=	O
level	int
;	O
if	O
(	O
level	int
>	O
0	int
)	O
{	O
paren_target	int
=	O
-	O
parser_state_tos	pointer
->	O
paren_indents	pointer
[	O
level	int
-	O
1	int
]	O
;	O
}	O
else	O
{	O
paren_target	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
settings	struct
.	O
parentheses_space	int
&&	O
*	O
token	pointer
!=	O
']'	O
)	O
{	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
' '	O
;	O
}	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
token	pointer
[	O
0	int
]	O
;	O
if	O
(	O
settings	struct
.	O
allow_single_line_conditionals	int
&&	O
*	O
(	O
token	pointer
-	O
1	int
)	O
==	O
')'	O
&&	O
*	O
(	O
token	pointer
+	O
2	int
)	O
!=	O
'{'	O
&&	O
!	O
parser_state_tos	pointer
->	O
paren_depth	int
)	O
{	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
true	int
;	O
}	O
if	O
(	O
*	O
sp_sw	pointer
&&	O
(	O
parser_state_tos	pointer
->	O
p_l_follow	int
==	O
0	int
)	O
)	O
{	O
if	O
(	O
parser_state_tos	pointer
->	O
p_stack	pointer
[	O
parser_state_tos	pointer
->	O
tos	int
]	O
!=	O
dohead	int
)	O
{	O
*	O
last_token_ends_sp	pointer
=	O
2	int
;	O
}	O
*	O
sp_sw	pointer
=	O
false	int
;	O
*	O
force_nl	int
=	O
!	O
settings	struct
.	O
allow_single_line_conditionals	int
;	O
parser_state_tos	pointer
->	O
last_u_d	int
=	O
true	int
;	O
parser_state_tos	pointer
->	O
in_stmt	int
=	O
false	int
;	O
if	O
(	O
parse	function
(	O
*	O
hd_type	pointer
)	O
!=	O
total_success	int
)	O
{	O
*	O
file_exit_value	pointer
=	O
indent_error	int
;	O
}	O
}	O
parser_state_tos	pointer
->	O
search_brace	int
=	O
settings	struct
.	O
btype_2	int
;	O
}	O
static	O
void	O
handle_token_unary_op	function
(	O
int	O
*	O
dec_ind	pointer
,	O
const	O
bb_code_ty	enum
can_break	enum
)	O
{	O
char	O
*	O
t_ptr	pointer
;	O
if	O
(	O
parser_state_tos	pointer
->	O
want_blank	int
&&	O
!	O
(	O
parser_state_tos	pointer
->	O
in_decl	char
&&	O
!	O
settings	struct
.	O
pointer_align_right	int
&&	O
*	O
token	pointer
==	O
'*'	O
)	O
)	O
{	O
set_buf_break	function
(	O
bb_unary_op	int
,	O
paren_target	int
)	O
;	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
' '	O
;	O
*	O
e_code	pointer
=	O
'\0'	O
;	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
false	int
;	O
}	O
else	O
if	O
(	O
can_break	enum
)	O
{	O
set_buf_break	function
(	O
can_break	enum
,	O
paren_target	int
)	O
;	O
}	O
else	O
{	O
}	O
{	O
char	O
*	O
res	pointer
=	O
token	pointer
;	O
char	O
*	O
res_end	pointer
=	O
token_end	pointer
;	O
if	O
(	O
(	O
parser_state_tos	pointer
->	O
paren_depth	int
==	O
0	int
)	O
&&	O
parser_state_tos	pointer
->	O
in_decl	char
&&	O
!	O
buf_break_used	int
&&	O
!	O
parser_state_tos	pointer
->	O
block_init	int
)	O
{	O
while	O
(	O
(	O
e_code	pointer
-	O
s_code	pointer
)	O
<	O
(	O
*	O
dec_ind	pointer
-	O
(	O
token_end	pointer
-	O
token	pointer
)	O
)	O
)	O
{	O
check_code_size	function
(	O
)	O
;	O
set_buf_break	function
(	O
bb_dec_ind	int
,	O
paren_target	int
)	O
;	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
' '	O
;	O
}	O
parser_state_tos	pointer
->	O
ind_stmt	int
=	O
false	int
;	O
}	O
else	O
{	O
if	O
(	O
(	O
parser_state_tos	pointer
->	O
last_token	enum
==	O
unary_op	int
)	O
&&	O
(	O
e_code	pointer
>	O
s_code	pointer
)	O
&&	O
*	O
res	pointer
!=	O
'!'	O
&&	O
(	O
*	O
(	O
e_code	pointer
-	O
1	int
)	O
==	O
*	O
res	pointer
)	O
)	O
{	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
' '	O
;	O
}	O
}	O
for	O
(	O
t_ptr	pointer
=	O
res	pointer
;	O
t_ptr	pointer
<	O
res_end	pointer
;	O
++	O
t_ptr	pointer
)	O
{	O
check_code_size	function
(	O
)	O
;	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
*	O
t_ptr	pointer
;	O
}	O
if	O
(	O
parser_state_tos	pointer
->	O
want_blank	int
&&	O
!	O
(	O
parser_state_tos	pointer
->	O
in_decl	char
&&	O
settings	struct
.	O
pointer_align_right	int
&&	O
*	O
token	pointer
==	O
'*'	O
)	O
)	O
{	O
set_buf_break	function
(	O
bb_unary_op	int
,	O
paren_target	int
)	O
;	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
' '	O
;	O
}	O
*	O
e_code	pointer
=	O
'\0'	O
;	O
}	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
false	int
;	O
}	O
static	O
void	O
handle_token_binary_op	function
(	O
const	O
bb_code_ty	enum
can_break	enum
)	O
{	O
char	O
*	O
t_ptr	pointer
;	O
if	O
(	O
parser_state_tos	pointer
->	O
want_blank	int
||	O
(	O
e_code	pointer
>	O
s_code	pointer
&&	O
*	O
e_code	pointer
!=	O
' '	O
)	O
)	O
{	O
set_buf_break	function
(	O
bb_binary_op	int
,	O
paren_target	int
)	O
;	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
' '	O
;	O
*	O
e_code	pointer
=	O
'\0'	O
;	O
}	O
else	O
if	O
(	O
can_break	enum
)	O
{	O
set_buf_break	function
(	O
can_break	enum
,	O
paren_target	int
)	O
;	O
}	O
else	O
{	O
}	O
{	O
char	O
*	O
res	pointer
=	O
token	pointer
;	O
char	O
*	O
res_end	pointer
=	O
token_end	pointer
;	O
for	O
(	O
t_ptr	pointer
=	O
res	pointer
;	O
t_ptr	pointer
<	O
res_end	pointer
;	O
++	O
t_ptr	pointer
)	O
{	O
check_code_size	function
(	O
)	O
;	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
*	O
t_ptr	pointer
;	O
}	O
}	O
if	O
(	O
*	O
token	pointer
==	O
'='	O
)	O
{	O
parser_state_tos	pointer
->	O
in_decl	char
=	O
false	int
;	O
}	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
true	int
;	O
}	O
static	O
void	O
handle_token_postop	function
(	O
void	O
)	O
{	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
token	pointer
[	O
0	int
]	O
;	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
token	pointer
[	O
1	int
]	O
;	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
true	int
;	O
}	O
static	O
void	O
handle_token_question	function
(	O
const	O
bb_code_ty	enum
can_break	enum
)	O
{	O
squest	int
++	O
;	O
if	O
(	O
parser_state_tos	pointer
->	O
want_blank	int
)	O
{	O
set_buf_break	function
(	O
bb_question	int
,	O
paren_target	int
)	O
;	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
' '	O
;	O
}	O
else	O
if	O
(	O
can_break	enum
)	O
{	O
set_buf_break	function
(	O
can_break	enum
,	O
paren_target	int
)	O
;	O
}	O
else	O
{	O
}	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
'?'	O
;	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
true	int
;	O
*	O
e_code	pointer
=	O
'\0'	O
;	O
}	O
static	O
void	O
handle_token_casestmt	function
(	O
BOOLEAN	char
*	O
scase	pointer
,	O
exit_values_ty	enum
*	O
file_exit_value	pointer
)	O
{	O
*	O
scase	pointer
=	O
true	int
;	O
do	O
{	O
if	O
(	O
parse	function
(	O
casestmt	int
)	O
!=	O
total_success	int
)	O
{	O
*	O
file_exit_value	pointer
=	O
indent_error	int
;	O
}	O
}	O
while	O
(	O
0	int
)	O
;	O
}	O
static	O
void	O
handle_token_colon	function
(	O
BOOLEAN	char
*	O
scase	pointer
,	O
BOOLEAN	char
*	O
force_nl	int
,	O
int	O
*	O
dec_ind	pointer
,	O
const	O
bb_code_ty	enum
can_break	enum
,	O
BOOLEAN	char
*	O
pbreak_line	pointer
)	O
{	O
char	O
*	O
t_ptr	pointer
;	O
if	O
(	O
squest	int
>	O
0	int
)	O
{	O
--	O
squest	int
;	O
if	O
(	O
parser_state_tos	pointer
->	O
want_blank	int
)	O
{	O
set_buf_break	function
(	O
bb_colon	int
,	O
paren_target	int
)	O
;	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
' '	O
;	O
}	O
else	O
if	O
(	O
can_break	enum
)	O
{	O
set_buf_break	function
(	O
can_break	enum
,	O
paren_target	int
)	O
;	O
}	O
else	O
{	O
}	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
':'	O
;	O
*	O
e_code	pointer
=	O
'\0'	O
;	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
true	int
;	O
}	O
else	O
{	O
if	O
(	O
parser_state_tos	pointer
->	O
in_decl	char
)	O
{	O
if	O
(	O
!	O
(	O
(	O
(	O
e_code	pointer
-	O
s_code	pointer
>	O
6	int
)	O
&&	O
!	O
strncmp	function
(	O
&	O
buf_ptr	pointer
[	O
-	O
8	int
]	O
,	O
"private:"	pointer
,	O
8	int
)	O
)	O
&&	O
!	O
isdigit	function
(	O
*	O
buf_ptr	pointer
)	O
)	O
&&	O
!	O
(	O
(	O
(	O
e_code	pointer
-	O
s_code	pointer
>	O
8	int
)	O
&&	O
!	O
strncmp	function
(	O
&	O
buf_ptr	pointer
[	O
-	O
10	int
]	O
,	O
"protected:"	pointer
,	O
10	int
)	O
)	O
&&	O
!	O
isdigit	function
(	O
*	O
buf_ptr	pointer
)	O
)	O
&&	O
!	O
(	O
(	O
(	O
e_code	pointer
-	O
s_code	pointer
>	O
5	int
)	O
&&	O
!	O
strncmp	function
(	O
&	O
buf_ptr	pointer
[	O
-	O
7	int
]	O
,	O
"public:"	pointer
,	O
7	int
)	O
)	O
&&	O
!	O
isdigit	function
(	O
*	O
buf_ptr	pointer
)	O
)	O
)	O
{	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
':'	O
;	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
false	int
;	O
return	O
;	O
}	O
else	O
if	O
(	O
*	O
s_code	pointer
==	O
' '	O
)	O
{	O
char	O
*	O
p1	pointer
=	O
s_code	pointer
;	O
char	O
*	O
p2	pointer
=	O
s_code	pointer
+	O
*	O
dec_ind	pointer
;	O
while	O
(	O
p2	pointer
<	O
e_code	pointer
)	O
{	O
*	O
p1	pointer
++	O
=	O
*	O
p2	pointer
++	O
;	O
}	O
e_code	pointer
-=	O
*	O
dec_ind	pointer
;	O
*	O
e_code	pointer
=	O
'\0'	O
;	O
}	O
else	O
{	O
}	O
}	O
parser_state_tos	pointer
->	O
in_stmt	int
=	O
false	int
;	O
for	O
(	O
t_ptr	pointer
=	O
s_code	pointer
;	O
*	O
t_ptr	pointer
;	O
++	O
t_ptr	pointer
)	O
{	O
check_lab_size	function
(	O
)	O
;	O
*	O
e_lab	pointer
++	O
=	O
*	O
t_ptr	pointer
;	O
}	O
e_code	pointer
=	O
s_code	pointer
;	O
clear_buf_break_list	function
(	O
pbreak_line	pointer
)	O
;	O
*	O
e_lab	pointer
++	O
=	O
':'	O
;	O
set_buf_break	function
(	O
bb_label	int
,	O
paren_target	int
)	O
;	O
*	O
e_lab	pointer
++	O
=	O
' '	O
;	O
*	O
e_lab	pointer
=	O
'\0'	O
;	O
*	O
force_nl	int
=	O
parser_state_tos	pointer
->	O
pcase	int
=	O
*	O
scase	pointer
;	O
*	O
scase	pointer
=	O
false	int
;	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
false	int
;	O
}	O
}	O
static	O
void	O
handle_token_doublecolon	function
(	O
void	O
)	O
{	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
':'	O
;	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
':'	O
;	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
false	int
;	O
parser_state_tos	pointer
->	O
can_break	enum
=	O
bb_doublecolon	int
;	O
parser_state_tos	pointer
->	O
last_u_d	int
=	O
true	int
;	O
parser_state_tos	pointer
->	O
saw_double_colon	int
=	O
true	int
;	O
}	O
static	O
void	O
handle_token_semicolon	function
(	O
BOOLEAN	char
*	O
scase	pointer
,	O
BOOLEAN	char
*	O
force_nl	int
,	O
BOOLEAN	char
*	O
sp_sw	pointer
,	O
int	O
*	O
dec_ind	pointer
,	O
BOOLEAN	char
*	O
last_token_ends_sp	pointer
,	O
exit_values_ty	enum
*	O
file_exit_value	pointer
)	O
{	O
parser_state_tos	pointer
->	O
in_or_st	int
=	O
0	int
;	O
parser_state_tos	pointer
->	O
saw_double_colon	int
=	O
false	int
;	O
*	O
scase	pointer
=	O
false	int
;	O
squest	int
=	O
0	int
;	O
parser_state_tos	pointer
->	O
cast_mask	int
=	O
0	int
;	O
parser_state_tos	pointer
->	O
sizeof_mask	int
=	O
0	int
;	O
parser_state_tos	pointer
->	O
block_init	int
=	O
0	int
;	O
parser_state_tos	pointer
->	O
block_init_level	int
=	O
0	int
;	O
parser_state_tos	pointer
->	O
just_saw_decl	int
--	O
;	O
parser_state_tos	pointer
->	O
is_func_ptr_decl	int
=	O
false	int
;	O
if	O
(	O
parser_state_tos	pointer
->	O
in_decl	char
&&	O
(	O
s_code	pointer
==	O
e_code	pointer
)	O
&&	O
!	O
buf_break_used	int
&&	O
!	O
parser_state_tos	pointer
->	O
block_init	int
)	O
{	O
while	O
(	O
(	O
e_code	pointer
-	O
s_code	pointer
)	O
<	O
(	O
*	O
dec_ind	pointer
-	O
1	int
)	O
)	O
{	O
check_code_size	function
(	O
)	O
;	O
set_buf_break	function
(	O
bb_dec_ind	int
,	O
paren_target	int
)	O
;	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
' '	O
;	O
}	O
parser_state_tos	pointer
->	O
ind_stmt	int
=	O
false	int
;	O
}	O
*	O
e_code	pointer
=	O
'\0'	O
;	O
parser_state_tos	pointer
->	O
in_decl	char
=	O
(	O
parser_state_tos	pointer
->	O
dec_nest	int
>	O
0	int
)	O
?	O
true	int
:	O
false	int
;	O
if	O
(	O
*	O
last_token_ends_sp	pointer
&&	O
settings	struct
.	O
space_sp_semicolon	int
)	O
{	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
' '	O
;	O
}	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
';'	O
;	O
*	O
e_code	pointer
=	O
'\0'	O
;	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
true	int
;	O
parser_state_tos	pointer
->	O
in_stmt	int
=	O
(	O
parser_state_tos	pointer
->	O
p_l_follow	int
>	O
0	int
)	O
;	O
if	O
(	O
!	O
*	O
sp_sw	pointer
)	O
{	O
do	O
{	O
if	O
(	O
parse	function
(	O
semicolon	int
)	O
!=	O
total_success	int
)	O
{	O
*	O
file_exit_value	pointer
=	O
indent_error	int
;	O
}	O
}	O
while	O
(	O
0	int
)	O
;	O
*	O
force_nl	int
=	O
true	int
;	O
}	O
}	O
static	O
void	O
handle_token_lbrace	function
(	O
BOOLEAN	char
*	O
force_nl	int
,	O
int	O
*	O
dec_ind	pointer
,	O
exit_values_ty	enum
*	O
file_exit_value	pointer
,	O
BOOLEAN	char
*	O
pbreak_line	pointer
)	O
{	O
parser_state_tos	pointer
->	O
saw_double_colon	int
=	O
false	int
;	O
if	O
(	O
parser_state_tos	pointer
->	O
last_token	enum
==	O
binary_op	int
)	O
parser_state_tos	pointer
->	O
block_init	int
=	O
1	int
;	O
if	O
(	O
!	O
parser_state_tos	pointer
->	O
block_init	int
)	O
{	O
*	O
force_nl	int
=	O
true	int
;	O
parser_state_tos	pointer
->	O
in_stmt	int
=	O
false	int
;	O
}	O
else	O
{	O
char	O
*	O
p	pointer
=	O
buf_ptr	pointer
;	O
for	O
(	O
;	O
;	O
)	O
{	O
p	pointer
=	O
skip_horiz_space	function
(	O
p	pointer
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
EOL	char
||	O
(	O
*	O
p	pointer
==	O
'/'	O
&&	O
p	pointer
[	O
1	int
]	O
==	O
'/'	O
)	O
)	O
{	O
parser_state_tos	pointer
->	O
in_stmt	int
=	O
false	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
*	O
p	pointer
==	O
'/'	O
&&	O
p	pointer
[	O
1	int
]	O
==	O
'*'	O
)	O
{	O
p	pointer
+=	O
2	int
;	O
while	O
(	O
*	O
p	pointer
&&	O
*	O
p	pointer
!=	O
EOL	char
&&	O
(	O
*	O
p	pointer
!=	O
'*'	O
||	O
p	pointer
[	O
1	int
]	O
!=	O
'/'	O
)	O
)	O
{	O
++	O
p	pointer
;	O
}	O
if	O
(	O
!	O
*	O
p	pointer
||	O
*	O
p	pointer
==	O
EOL	char
)	O
{	O
parser_state_tos	pointer
->	O
in_stmt	int
=	O
false	int
;	O
break	O
;	O
}	O
p	pointer
+=	O
2	int
;	O
if	O
(	O
!	O
*	O
p	pointer
)	O
{	O
break	O
;	O
}	O
}	O
else	O
{	O
break	O
;	O
}	O
}	O
if	O
(	O
parser_state_tos	pointer
->	O
block_init_level	int
<=	O
0	int
)	O
{	O
parser_state_tos	pointer
->	O
block_init_level	int
=	O
1	int
;	O
}	O
else	O
{	O
parser_state_tos	pointer
->	O
block_init_level	int
++	O
;	O
}	O
}	O
if	O
(	O
s_code	pointer
!=	O
e_code	pointer
&&	O
parser_state_tos	pointer
->	O
block_init	int
!=	O
1	int
)	O
{	O
if	O
(	O
(	O
!	O
parser_state_tos	pointer
->	O
in_decl	char
&&	O
!	O
settings	struct
.	O
btype_2	int
)	O
||	O
(	O
parser_state_tos	pointer
->	O
in_decl	char
&&	O
!	O
settings	struct
.	O
braces_on_struct_decl_line	int
&&	O
!	O
settings	struct
.	O
braces_on_func_def_line	int
)	O
)	O
{	O
dump_line	function
(	O
true	int
,	O
&	O
paren_target	int
,	O
pbreak_line	pointer
)	O
;	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
false	int
;	O
}	O
else	O
{	O
if	O
(	O
parser_state_tos	pointer
->	O
in_parameter_declaration	int
&&	O
!	O
parser_state_tos	pointer
->	O
in_or_st	int
)	O
{	O
parser_state_tos	pointer
->	O
i_l_follow	int
=	O
0	int
;	O
if	O
(	O
!	O
settings	struct
.	O
braces_on_func_def_line	int
)	O
{	O
dump_line	function
(	O
true	int
,	O
&	O
paren_target	int
,	O
pbreak_line	pointer
)	O
;	O
}	O
else	O
{	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
' '	O
;	O
}	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
false	int
;	O
}	O
else	O
{	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
true	int
;	O
}	O
}	O
}	O
if	O
(	O
parser_state_tos	pointer
->	O
in_parameter_declaration	int
)	O
{	O
prefix_blankline_requested	int
=	O
0	int
;	O
}	O
if	O
(	O
s_code	pointer
==	O
e_code	pointer
)	O
{	O
parser_state_tos	pointer
->	O
ind_stmt	int
=	O
false	int
;	O
}	O
if	O
(	O
parser_state_tos	pointer
->	O
in_decl	char
&&	O
parser_state_tos	pointer
->	O
in_or_st	int
)	O
{	O
if	O
(	O
parser_state_tos	pointer
->	O
dec_nest	int
>=	O
di_stack_alloc	int
)	O
{	O
di_stack_alloc	int
*=	O
2	int
;	O
di_stack	pointer
=	O
xrealloc	function
(	O
di_stack	pointer
,	O
di_stack_alloc	int
*	O
sizeof	O
(	O
*	O
di_stack	pointer
)	O
)	O
;	O
}	O
di_stack	pointer
[	O
parser_state_tos	pointer
->	O
dec_nest	int
++	O
]	O
=	O
*	O
dec_ind	pointer
;	O
}	O
else	O
{	O
parser_state_tos	pointer
->	O
in_decl	char
=	O
false	int
;	O
parser_state_tos	pointer
->	O
decl_on_line	int
=	O
false	int
;	O
parser_state_tos	pointer
->	O
in_parameter_declaration	int
=	O
0	int
;	O
}	O
*	O
dec_ind	pointer
=	O
0	int
;	O
parser_state_tos	pointer
->	O
in_or_st	int
=	O
0	int
;	O
do	O
{	O
if	O
(	O
parse	function
(	O
lbrace	int
)	O
!=	O
total_success	int
)	O
{	O
*	O
file_exit_value	pointer
=	O
indent_error	int
;	O
}	O
}	O
while	O
(	O
0	int
)	O
;	O
set_buf_break	function
(	O
bb_lbrace	int
,	O
paren_target	int
)	O
;	O
if	O
(	O
parser_state_tos	pointer
->	O
want_blank	int
&&	O
s_code	pointer
!=	O
e_code	pointer
)	O
{	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
' '	O
;	O
}	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
false	int
;	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
'{'	O
;	O
*	O
e_code	pointer
=	O
'\0'	O
;	O
parser_state_tos	pointer
->	O
just_saw_decl	int
=	O
0	int
;	O
if	O
(	O
parser_state_tos	pointer
->	O
block_init	int
&&	O
(	O
parser_state_tos	pointer
->	O
block_init_level	int
>=	O
2	int
)	O
)	O
{	O
if	O
(	O
++	O
parser_state_tos	pointer
->	O
p_l_follow	int
>=	O
parser_state_tos	pointer
->	O
paren_indents_size	int
)	O
{	O
parser_state_tos	pointer
->	O
paren_indents_size	int
*=	O
2	int
;	O
parser_state_tos	pointer
->	O
paren_indents	pointer
=	O
xrealloc	function
(	O
parser_state_tos	pointer
->	O
paren_indents	pointer
,	O
parser_state_tos	pointer
->	O
paren_indents_size	int
*	O
sizeof	O
(	O
short	O
)	O
)	O
;	O
}	O
++	O
parser_state_tos	pointer
->	O
paren_depth	int
;	O
parser_state_tos	pointer
->	O
paren_indents	pointer
[	O
parser_state_tos	pointer
->	O
p_l_follow	int
-	O
1	int
]	O
=	O
e_code	pointer
-	O
s_code	pointer
;	O
if	O
(	O
settings	struct
.	O
spaces_around_initializers	int
)	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
true	int
;	O
}	O
else	O
if	O
(	O
parser_state_tos	pointer
->	O
block_init	int
&&	O
(	O
parser_state_tos	pointer
->	O
block_init_level	int
==	O
1	int
)	O
)	O
{	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
true	int
;	O
}	O
else	O
{	O
}	O
}	O
static	O
void	O
handle_token_rbrace	function
(	O
BOOLEAN	char
*	O
force_nl	int
,	O
int	O
*	O
dec_ind	pointer
,	O
exit_values_ty	enum
*	O
file_exit_value	pointer
,	O
BOOLEAN	char
*	O
pbreak_line	pointer
)	O
{	O
char	O
tmpchar	array
[	O
2	int
]	O
;	O
if	O
(	O
(	O
(	O
parser_state_tos	pointer
->	O
p_stack	pointer
[	O
parser_state_tos	pointer
->	O
tos	int
]	O
==	O
decl	int
)	O
&&	O
!	O
parser_state_tos	pointer
->	O
block_init	int
)	O
||	O
(	O
parser_state_tos	pointer
->	O
p_stack	pointer
[	O
parser_state_tos	pointer
->	O
tos	int
]	O
==	O
casestmt	int
)	O
)	O
{	O
if	O
(	O
parse	function
(	O
semicolon	int
)	O
!=	O
total_success	int
)	O
{	O
*	O
file_exit_value	pointer
=	O
indent_error	int
;	O
}	O
}	O
parser_state_tos	pointer
->	O
just_saw_decl	int
=	O
0	int
;	O
parser_state_tos	pointer
->	O
ind_stmt	int
=	O
false	int
;	O
parser_state_tos	pointer
->	O
in_stmt	int
=	O
false	int
;	O
parser_state_tos	pointer
->	O
block_init_level	int
--	O
;	O
if	O
(	O
(	O
parser_state_tos	pointer
->	O
block_init_level	int
==	O
0	int
)	O
&&	O
(	O
s_code	pointer
!=	O
e_code	pointer
)	O
)	O
{	O
if	O
(	O
parser_state_tos	pointer
->	O
matching_brace_on_same_line	int
<	O
0	int
)	O
{	O
dump_line	function
(	O
true	int
,	O
&	O
paren_target	int
,	O
pbreak_line	pointer
)	O
;	O
}	O
else	O
{	O
set_buf_break	function
(	O
bb_rbrace	int
,	O
paren_target	int
)	O
;	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
' '	O
;	O
}	O
}	O
else	O
if	O
(	O
parser_state_tos	pointer
->	O
block_init_level	int
==	O
1	int
&&	O
settings	struct
.	O
spaces_around_initializers	int
)	O
{	O
set_buf_break	function
(	O
bb_rbrace	int
,	O
paren_target	int
)	O
;	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
' '	O
;	O
}	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
'}'	O
;	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
true	int
;	O
if	O
(	O
parser_state_tos	pointer
->	O
block_init	int
&&	O
(	O
parser_state_tos	pointer
->	O
block_init_level	int
>	O
0	int
)	O
)	O
{	O
--	O
parser_state_tos	pointer
->	O
paren_depth	int
;	O
if	O
(	O
--	O
parser_state_tos	pointer
->	O
p_l_follow	int
<	O
0	int
)	O
{	O
parser_state_tos	pointer
->	O
p_l_follow	int
=	O
0	int
;	O
tmpchar	array
[	O
0	int
]	O
=	O
*	O
token	pointer
;	O
tmpchar	array
[	O
1	int
]	O
=	O
'\0'	O
;	O
WARNING	O
(	O
_	O
(	O
"Extra %s"	pointer
)	O
,	O
tmpchar	array
,	O
NULL	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
parser_state_tos	pointer
->	O
dec_nest	int
>	O
0	int
)	O
{	O
*	O
dec_ind	pointer
=	O
di_stack	pointer
[	O
--	O
parser_state_tos	pointer
->	O
dec_nest	int
]	O
;	O
if	O
(	O
(	O
parser_state_tos	pointer
->	O
dec_nest	int
==	O
0	int
)	O
&&	O
!	O
parser_state_tos	pointer
->	O
in_parameter_declaration	int
)	O
{	O
parser_state_tos	pointer
->	O
just_saw_decl	int
=	O
2	int
;	O
}	O
parser_state_tos	pointer
->	O
in_decl	char
=	O
true	int
;	O
}	O
else	O
{	O
}	O
prefix_blankline_requested	int
=	O
0	int
;	O
if	O
(	O
parse	function
(	O
rbrace	int
)	O
!=	O
total_success	int
)	O
{	O
*	O
file_exit_value	pointer
=	O
indent_error	int
;	O
}	O
parser_state_tos	pointer
->	O
search_brace	int
=	O
(	O
settings	struct
.	O
cuddle_else	int
&&	O
(	O
parser_state_tos	pointer
->	O
p_stack	pointer
[	O
parser_state_tos	pointer
->	O
tos	int
]	O
==	O
ifhead	int
)	O
)	O
||	O
(	O
settings	struct
.	O
cuddle_do_while	int
&&	O
(	O
parser_state_tos	pointer
->	O
p_stack	pointer
[	O
parser_state_tos	pointer
->	O
tos	int
]	O
==	O
dohead	int
)	O
)	O
;	O
if	O
(	O
parser_state_tos	pointer
->	O
p_stack	pointer
[	O
parser_state_tos	pointer
->	O
tos	int
]	O
==	O
stmtl	int
)	O
{	O
if	O
(	O
(	O
parser_state_tos	pointer
->	O
last_rw	enum
!=	O
rw_struct_like	int
)	O
&&	O
(	O
parser_state_tos	pointer
->	O
last_rw	enum
!=	O
rw_enum	int
)	O
&&	O
(	O
parser_state_tos	pointer
->	O
last_rw	enum
!=	O
rw_decl	int
)	O
)	O
{	O
*	O
force_nl	int
=	O
true	int
;	O
}	O
}	O
if	O
(	O
(	O
parser_state_tos	pointer
->	O
p_stack	pointer
[	O
parser_state_tos	pointer
->	O
tos	int
]	O
==	O
ifhead	int
)	O
||	O
(	O
(	O
parser_state_tos	pointer
->	O
p_stack	pointer
[	O
parser_state_tos	pointer
->	O
tos	int
]	O
==	O
dohead	int
)	O
&&	O
!	O
settings	struct
.	O
cuddle_do_while	int
&&	O
!	O
settings	struct
.	O
btype_2	int
)	O
)	O
{	O
*	O
force_nl	int
=	O
true	int
;	O
}	O
if	O
(	O
!	O
parser_state_tos	pointer
->	O
in_decl	char
&&	O
(	O
parser_state_tos	pointer
->	O
tos	int
<=	O
0	int
)	O
&&	O
settings	struct
.	O
blanklines_after_procs	int
&&	O
(	O
parser_state_tos	pointer
->	O
dec_nest	int
<=	O
0	int
)	O
)	O
{	O
postfix_blankline_requested	int
=	O
1	int
;	O
postfix_blankline_requested_code	enum
=	O
parser_state_tos	pointer
->	O
in_decl	char
?	O
decl	int
:	O
rbrace	int
;	O
}	O
}	O
static	O
void	O
handle_token_swstmt	function
(	O
BOOLEAN	char
*	O
sp_sw	pointer
,	O
codes_ty	enum
*	O
hd_type	pointer
)	O
{	O
*	O
sp_sw	pointer
=	O
true	int
;	O
*	O
hd_type	pointer
=	O
swstmt	int
;	O
parser_state_tos	pointer
->	O
in_decl	char
=	O
false	int
;	O
}	O
static	O
void	O
handle_token_sp_paren	function
(	O
BOOLEAN	char
*	O
sp_sw	pointer
,	O
codes_ty	enum
*	O
hd_type	pointer
)	O
{	O
*	O
sp_sw	pointer
=	O
true	int
;	O
*	O
hd_type	pointer
=	O
(	O
*	O
token	pointer
==	O
'i'	O
?	O
ifstmt	int
:	O
(	O
*	O
token	pointer
==	O
'w'	O
?	O
whilestmt	int
:	O
forstmt	int
)	O
)	O
;	O
}	O
static	O
void	O
handle_token_nparen	function
(	O
BOOLEAN	char
*	O
force_nl	int
,	O
exit_values_ty	enum
*	O
file_exit_value	pointer
,	O
BOOLEAN	char
*	O
last_else	pointer
,	O
BOOLEAN	char
*	O
pbreak_line	pointer
)	O
{	O
parser_state_tos	pointer
->	O
in_stmt	int
=	O
false	int
;	O
if	O
(	O
*	O
token	pointer
==	O
'e'	O
)	O
{	O
if	O
(	O
e_code	pointer
!=	O
s_code	pointer
&&	O
(	O
!	O
settings	struct
.	O
cuddle_else	int
||	O
e_code	pointer
[	O
-	O
1	int
]	O
!=	O
'}'	O
)	O
)	O
{	O
if	O
(	O
settings	struct
.	O
verbose	int
)	O
{	O
WARNING	O
(	O
_	O
(	O
"Line broken"	pointer
)	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
dump_line	function
(	O
true	int
,	O
&	O
paren_target	int
,	O
pbreak_line	pointer
)	O
;	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
false	int
;	O
}	O
*	O
force_nl	int
=	O
true	int
;	O
*	O
last_else	pointer
=	O
1	int
;	O
if	O
(	O
parse	function
(	O
elselit	int
)	O
!=	O
total_success	int
)	O
{	O
*	O
file_exit_value	pointer
=	O
indent_error	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
e_code	pointer
!=	O
s_code	pointer
)	O
{	O
if	O
(	O
settings	struct
.	O
verbose	int
)	O
{	O
WARNING	O
(	O
_	O
(	O
"Line broken"	pointer
)	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
dump_line	function
(	O
true	int
,	O
&	O
paren_target	int
,	O
pbreak_line	pointer
)	O
;	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
false	int
;	O
}	O
*	O
force_nl	int
=	O
true	int
;	O
*	O
last_else	pointer
=	O
0	int
;	O
if	O
(	O
parse	function
(	O
dolit	int
)	O
!=	O
total_success	int
)	O
{	O
*	O
file_exit_value	pointer
=	O
indent_error	int
;	O
}	O
}	O
}	O
static	O
void	O
handle_token_overloaded	function
(	O
const	O
bb_code_ty	enum
can_break	enum
)	O
{	O
char	O
*	O
t_ptr	pointer
;	O
if	O
(	O
parser_state_tos	pointer
->	O
want_blank	int
)	O
{	O
set_buf_break	function
(	O
bb_overloaded	int
,	O
paren_target	int
)	O
;	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
' '	O
;	O
}	O
else	O
if	O
(	O
can_break	enum
)	O
{	O
set_buf_break	function
(	O
can_break	enum
,	O
paren_target	int
)	O
;	O
}	O
else	O
{	O
}	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
true	int
;	O
for	O
(	O
t_ptr	pointer
=	O
token	pointer
;	O
t_ptr	pointer
<	O
token_end	pointer
;	O
++	O
t_ptr	pointer
)	O
{	O
check_code_size	function
(	O
)	O
;	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
*	O
t_ptr	pointer
;	O
}	O
*	O
e_code	pointer
=	O
'\0'	O
;	O
}	O
static	O
void	O
handle_token_decl	function
(	O
int	O
*	O
dec_ind	pointer
,	O
exit_values_ty	enum
*	O
file_exit_value	pointer
,	O
BOOLEAN	char
*	O
pbreak_line	pointer
)	O
{	O
if	O
(	O
(	O
parser_state_tos	pointer
->	O
last_token	enum
==	O
rparen	int
)	O
&&	O
parser_state_tos	pointer
->	O
in_parameter_declaration	int
&&	O
parser_state_tos	pointer
->	O
saw_double_colon	int
&&	O
!	O
strncmp	function
(	O
token	pointer
,	O
"const"	pointer
,	O
5	int
)	O
)	O
{	O
set_buf_break	function
(	O
bb_const_qualifier	int
,	O
paren_target	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
parser_state_tos	pointer
->	O
sizeof_mask	int
)	O
{	O
if	O
(	O
parse	function
(	O
decl	int
)	O
!=	O
total_success	int
)	O
{	O
*	O
file_exit_value	pointer
=	O
indent_error	int
;	O
}	O
}	O
if	O
(	O
(	O
parser_state_tos	pointer
->	O
last_token	enum
==	O
rparen	int
)	O
&&	O
(	O
parser_state_tos	pointer
->	O
tos	int
<=	O
1	int
)	O
)	O
{	O
parser_state_tos	pointer
->	O
in_parameter_declaration	int
=	O
1	int
;	O
if	O
(	O
s_code	pointer
!=	O
e_code	pointer
)	O
{	O
dump_line	function
(	O
true	int
,	O
&	O
paren_target	int
,	O
pbreak_line	pointer
)	O
;	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
false	int
;	O
}	O
}	O
if	O
(	O
parser_state_tos	pointer
->	O
in_parameter_declaration	int
&&	O
(	O
parser_state_tos	pointer
->	O
dec_nest	int
==	O
0	int
)	O
&&	O
(	O
parser_state_tos	pointer
->	O
p_l_follow	int
==	O
0	int
)	O
)	O
{	O
parser_state_tos	pointer
->	O
ind_level	int
=	O
parser_state_tos	pointer
->	O
i_l_follow	int
=	O
settings	struct
.	O
indent_parameters	int
;	O
parser_state_tos	pointer
->	O
ind_stmt	int
=	O
false	int
;	O
}	O
if	O
(	O
!	O
parser_state_tos	pointer
->	O
paren_depth	int
)	O
{	O
parser_state_tos	pointer
->	O
in_or_st	int
=	O
1	int
;	O
}	O
if	O
(	O
!	O
parser_state_tos	pointer
->	O
sizeof_mask	int
)	O
{	O
parser_state_tos	pointer
->	O
in_decl	char
=	O
true	int
;	O
parser_state_tos	pointer
->	O
decl_on_line	int
=	O
true	int
;	O
if	O
(	O
parser_state_tos	pointer
->	O
dec_nest	int
<=	O
0	int
)	O
{	O
parser_state_tos	pointer
->	O
just_saw_decl	int
=	O
2	int
;	O
}	O
}	O
*	O
dec_ind	pointer
=	O
settings	struct
.	O
decl_indent	int
>	O
0	int
?	O
settings	struct
.	O
decl_indent	int
:	O
token_end	pointer
-	O
token	pointer
+	O
1	int
;	O
}	O
}	O
static	O
void	O
handle_token_ident	function
(	O
BOOLEAN	char
*	O
force_nl	int
,	O
BOOLEAN	char
*	O
sp_sw	pointer
,	O
codes_ty	enum
*	O
hd_type	pointer
,	O
int	O
*	O
dec_ind	pointer
,	O
exit_values_ty	enum
*	O
file_exit_value	pointer
,	O
const	O
bb_code_ty	enum
can_break	enum
,	O
BOOLEAN	char
is_procname_definition	char
,	O
BOOLEAN	char
*	O
pbreak_line	pointer
)	O
{	O
if	O
(	O
parser_state_tos	pointer
->	O
in_decl	char
&&	O
(	O
parser_state_tos	pointer
->	O
p_l_follow	int
==	O
0	int
)	O
&&	O
(	O
parser_state_tos	pointer
->	O
last_token	enum
!=	O
rbrace	int
)	O
)	O
{	O
if	O
(	O
parser_state_tos	pointer
->	O
want_blank	int
)	O
{	O
set_buf_break	function
(	O
bb_ident	int
,	O
paren_target	int
)	O
;	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
' '	O
;	O
*	O
e_code	pointer
=	O
'\0'	O
;	O
}	O
else	O
if	O
(	O
can_break	enum
)	O
{	O
set_buf_break	function
(	O
can_break	enum
,	O
paren_target	int
)	O
;	O
}	O
else	O
{	O
}	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
false	int
;	O
if	O
(	O
(	O
is_procname_definition	char
==	O
false	int
)	O
||	O
(	O
!	O
settings	struct
.	O
procnames_start_line	int
&&	O
(	O
s_code	pointer
!=	O
e_code	pointer
)	O
)	O
)	O
{	O
if	O
(	O
!	O
parser_state_tos	pointer
->	O
block_init	int
&&	O
!	O
buf_break_used	int
)	O
{	O
if	O
(	O
is_procname_definition	char
)	O
{	O
*	O
dec_ind	pointer
=	O
0	int
;	O
}	O
while	O
(	O
(	O
e_code	pointer
-	O
s_code	pointer
)	O
<	O
*	O
dec_ind	pointer
)	O
{	O
check_code_size	function
(	O
)	O
;	O
set_buf_break	function
(	O
bb_dec_ind	int
,	O
paren_target	int
)	O
;	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
' '	O
;	O
}	O
*	O
e_code	pointer
=	O
'\0'	O
;	O
parser_state_tos	pointer
->	O
ind_stmt	int
=	O
false	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
(	O
s_code	pointer
!=	O
e_code	pointer
)	O
&&	O
(	O
parser_state_tos	pointer
->	O
last_token	enum
!=	O
doublecolon	int
)	O
)	O
{	O
dump_line	function
(	O
true	int
,	O
&	O
paren_target	int
,	O
pbreak_line	pointer
)	O
;	O
}	O
*	O
dec_ind	pointer
=	O
0	int
;	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
false	int
;	O
}	O
}	O
else	O
if	O
(	O
*	O
sp_sw	pointer
&&	O
parser_state_tos	pointer
->	O
p_l_follow	int
==	O
0	int
)	O
{	O
*	O
sp_sw	pointer
=	O
false	int
;	O
*	O
force_nl	int
=	O
true	int
;	O
parser_state_tos	pointer
->	O
last_u_d	int
=	O
true	int
;	O
parser_state_tos	pointer
->	O
in_stmt	int
=	O
false	int
;	O
if	O
(	O
parse	function
(	O
*	O
hd_type	pointer
)	O
!=	O
total_success	int
)	O
{	O
*	O
file_exit_value	pointer
=	O
indent_error	int
;	O
}	O
}	O
else	O
{	O
}	O
}	O
static	O
void	O
handle_token_struct_delim	function
(	O
void	O
)	O
{	O
char	O
*	O
t_ptr	pointer
;	O
for	O
(	O
t_ptr	pointer
=	O
token	pointer
;	O
t_ptr	pointer
<	O
token_end	pointer
;	O
++	O
t_ptr	pointer
)	O
{	O
check_code_size	function
(	O
)	O
;	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
*	O
t_ptr	pointer
;	O
}	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
false	int
;	O
parser_state_tos	pointer
->	O
can_break	enum
=	O
bb_struct_delim	int
;	O
}	O
static	O
void	O
handle_token_comma	function
(	O
BOOLEAN	char
*	O
force_nl	int
,	O
int	O
*	O
dec_ind	pointer
,	O
BOOLEAN	char
is_procname_definition	char
)	O
{	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
true	int
;	O
if	O
(	O
(	O
parser_state_tos	pointer
->	O
paren_depth	int
==	O
0	int
)	O
&&	O
parser_state_tos	pointer
->	O
in_decl	char
&&	O
!	O
buf_break_used	int
&&	O
(	O
is_procname_definition	char
==	O
false	int
)	O
&&	O
!	O
parser_state_tos	pointer
->	O
block_init	int
)	O
{	O
while	O
(	O
(	O
e_code	pointer
-	O
s_code	pointer
)	O
<	O
(	O
*	O
dec_ind	pointer
-	O
1	int
)	O
)	O
{	O
check_code_size	function
(	O
)	O
;	O
set_buf_break	function
(	O
bb_dec_ind	int
,	O
paren_target	int
)	O
;	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
' '	O
;	O
}	O
parser_state_tos	pointer
->	O
ind_stmt	int
=	O
false	int
;	O
}	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
','	O
;	O
if	O
(	O
parser_state_tos	pointer
->	O
p_l_follow	int
==	O
0	int
)	O
{	O
if	O
(	O
parser_state_tos	pointer
->	O
block_init_level	int
<=	O
0	int
)	O
{	O
parser_state_tos	pointer
->	O
block_init	int
=	O
0	int
;	O
}	O
if	O
(	O
break_comma	int
&&	O
!	O
settings	struct
.	O
leave_comma	int
)	O
{	O
*	O
force_nl	int
=	O
true	int
;	O
}	O
}	O
if	O
(	O
parser_state_tos	pointer
->	O
block_init	int
)	O
{	O
parser_state_tos	pointer
->	O
in_stmt	int
=	O
false	int
;	O
}	O
if	O
(	O
settings	struct
.	O
break_function_decl_args	int
&&	O
(	O
!	O
parser_state_tos	pointer
->	O
in_or_st	int
&&	O
parser_state_tos	pointer
->	O
in_stmt	int
&&	O
parser_state_tos	pointer
->	O
in_decl	char
)	O
)	O
{	O
*	O
force_nl	int
=	O
true	int
;	O
}	O
}	O
static	O
void	O
handle_token_preesc	function
(	O
exit_values_ty	enum
*	O
file_exit_value	pointer
,	O
BOOLEAN	char
*	O
pbreak_line	pointer
)	O
{	O
char	O
*	O
t_ptr	pointer
;	O
char	O
*	O
p	pointer
;	O
if	O
(	O
(	O
s_com	pointer
!=	O
e_com	pointer
)	O
||	O
(	O
s_lab	pointer
!=	O
e_lab	pointer
)	O
||	O
(	O
s_code	pointer
!=	O
e_code	pointer
)	O
)	O
{	O
dump_line	function
(	O
true	int
,	O
&	O
paren_target	int
,	O
pbreak_line	pointer
)	O
;	O
}	O
{	O
int	O
in_comment	int
=	O
0	int
;	O
int	O
in_cplus_comment	int
=	O
0	int
;	O
int	O
com_start	int
=	O
0	int
;	O
char	O
quote	char
=	O
0	int
;	O
int	O
com_end	int
=	O
0	int
;	O
for	O
(	O
t_ptr	pointer
=	O
token	pointer
;	O
t_ptr	pointer
<	O
token_end	pointer
;	O
++	O
t_ptr	pointer
)	O
{	O
check_lab_size	function
(	O
)	O
;	O
*	O
e_lab	pointer
++	O
=	O
*	O
t_ptr	pointer
;	O
}	O
while	O
(	O
!	O
had_eof	char
&&	O
(	O
*	O
buf_ptr	pointer
!=	O
EOL	char
||	O
in_comment	int
)	O
)	O
{	O
check_lab_size	function
(	O
)	O
;	O
*	O
e_lab	pointer
=	O
*	O
buf_ptr	pointer
++	O
;	O
if	O
(	O
buf_ptr	pointer
>=	O
buf_end	pointer
)	O
{	O
fill_buffer	function
(	O
)	O
;	O
}	O
switch	O
(	O
*	O
e_lab	pointer
++	O
)	O
{	O
case	O
BACKSLASH	char
:	O
if	O
(	O
!	O
in_comment	int
&&	O
!	O
in_cplus_comment	int
)	O
{	O
*	O
e_lab	pointer
++	O
=	O
*	O
buf_ptr	pointer
++	O
;	O
if	O
(	O
buf_ptr	pointer
>=	O
buf_end	pointer
)	O
{	O
fill_buffer	function
(	O
)	O
;	O
}	O
}	O
break	O
;	O
case	O
'/'	O
:	O
if	O
(	O
(	O
(	O
*	O
buf_ptr	pointer
==	O
'*'	O
)	O
||	O
(	O
*	O
buf_ptr	pointer
==	O
'/'	O
)	O
)	O
&&	O
!	O
in_comment	int
&&	O
!	O
in_cplus_comment	int
&&	O
!	O
quote	char
)	O
{	O
save_com	struct
.	O
column	int
=	O
current_column	function
(	O
)	O
-	O
1	int
;	O
if	O
(	O
*	O
buf_ptr	pointer
==	O
'/'	O
)	O
{	O
in_cplus_comment	int
=	O
1	int
;	O
}	O
else	O
{	O
in_comment	int
=	O
1	int
;	O
}	O
*	O
e_lab	pointer
++	O
=	O
*	O
buf_ptr	pointer
++	O
;	O
com_start	int
=	O
e_lab	pointer
-	O
s_lab	pointer
-	O
2	int
;	O
if	O
(	O
save_com	struct
.	O
ptr	pointer
==	O
save_com	struct
.	O
end	pointer
)	O
{	O
save_com	struct
.	O
start_column	int
=	O
current_column	function
(	O
)	O
-	O
2	int
;	O
}	O
}	O
break	O
;	O
case	O
'"'	O
:	O
case	O
'\''	O
:	O
if	O
(	O
!	O
quote	char
)	O
{	O
quote	char
=	O
e_lab	pointer
[	O
-	O
1	int
]	O
;	O
}	O
else	O
if	O
(	O
e_lab	pointer
[	O
-	O
1	int
]	O
==	O
quote	char
)	O
{	O
quote	char
=	O
0	int
;	O
}	O
else	O
{	O
}	O
break	O
;	O
case	O
'*'	O
:	O
if	O
(	O
*	O
buf_ptr	pointer
==	O
'/'	O
&&	O
in_comment	int
)	O
{	O
in_comment	int
=	O
0	int
;	O
*	O
e_lab	pointer
++	O
=	O
*	O
buf_ptr	pointer
++	O
;	O
com_end	int
=	O
e_lab	pointer
-	O
s_lab	pointer
;	O
}	O
break	O
;	O
}	O
}	O
while	O
(	O
e_lab	pointer
>	O
s_lab	pointer
&&	O
(	O
e_lab	pointer
[	O
-	O
1	int
]	O
==	O
' '	O
||	O
e_lab	pointer
[	O
-	O
1	int
]	O
==	O
TAB	char
)	O
)	O
{	O
e_lab	pointer
--	O
;	O
}	O
if	O
(	O
in_cplus_comment	int
)	O
{	O
in_cplus_comment	int
=	O
0	int
;	O
*	O
e_lab	pointer
++	O
=	O
*	O
buf_ptr	pointer
++	O
;	O
com_end	int
=	O
e_lab	pointer
-	O
s_lab	pointer
;	O
}	O
if	O
(	O
e_lab	pointer
-	O
s_lab	pointer
==	O
com_end	int
&&	O
bp_save	pointer
==	O
0	int
)	O
{	O
if	O
(	O
save_com	struct
.	O
end	pointer
!=	O
save_com	struct
.	O
ptr	pointer
)	O
{	O
need_chars	function
(	O
&	O
save_com	struct
,	O
2	int
)	O
;	O
*	O
save_com	struct
.	O
end	pointer
++	O
=	O
EOL	char
;	O
*	O
save_com	struct
.	O
end	pointer
++	O
=	O
' '	O
;	O
save_com	struct
.	O
len	int
+=	O
2	int
;	O
--	O
line_no	int
;	O
}	O
need_chars	function
(	O
&	O
save_com	struct
,	O
com_end	int
-	O
com_start	int
+	O
1	int
)	O
;	O
strncpy	function
(	O
save_com	struct
.	O
end	pointer
,	O
s_lab	pointer
+	O
com_start	int
,	O
com_end	int
-	O
com_start	int
)	O
;	O
save_com	struct
.	O
end	pointer
[	O
com_end	int
-	O
com_start	int
]	O
=	O
'\0'	O
;	O
save_com	struct
.	O
end	pointer
+=	O
com_end	int
-	O
com_start	int
;	O
save_com	struct
.	O
len	int
+=	O
com_end	int
-	O
com_start	int
;	O
e_lab	pointer
=	O
s_lab	pointer
+	O
com_start	int
;	O
while	O
(	O
(	O
e_lab	pointer
>	O
s_lab	pointer
)	O
&&	O
(	O
(	O
e_lab	pointer
[	O
-	O
1	int
]	O
==	O
' '	O
)	O
||	O
(	O
e_lab	pointer
[	O
-	O
1	int
]	O
==	O
TAB	char
)	O
)	O
)	O
{	O
e_lab	pointer
--	O
;	O
}	O
bp_save	pointer
=	O
buf_ptr	pointer
;	O
be_save	pointer
=	O
buf_end	pointer
;	O
buf_ptr	pointer
=	O
save_com	struct
.	O
ptr	pointer
;	O
need_chars	function
(	O
&	O
save_com	struct
,	O
1	int
)	O
;	O
buf_end	pointer
=	O
save_com	struct
.	O
end	pointer
;	O
save_com	struct
.	O
end	pointer
=	O
save_com	struct
.	O
ptr	pointer
;	O
}	O
*	O
e_lab	pointer
=	O
'\0'	O
;	O
parser_state_tos	pointer
->	O
pcase	int
=	O
false	int
;	O
}	O
p	pointer
=	O
s_lab	pointer
+	O
1	int
;	O
p	pointer
=	O
skip_horiz_space	function
(	O
p	pointer
)	O
;	O
if	O
(	O
strncmp	function
(	O
p	pointer
,	O
"if"	pointer
,	O
2	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
settings	struct
.	O
blanklines_around_conditional_compilation	int
)	O
{	O
prefix_blankline_requested	int
++	O
;	O
prefix_blankline_requested_code	enum
=	O
preesc	int
;	O
while	O
(	O
*	O
in_prog_pos	pointer
++	O
==	O
EOL	char
)	O
{	O
}	O
in_prog_pos	pointer
--	O
;	O
}	O
{	O
parser_state_ty	struct
*	O
new	pointer
;	O
new	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
parser_state_ty	struct
)	O
)	O
;	O
memcpy	function
(	O
new	pointer
,	O
parser_state_tos	pointer
,	O
sizeof	O
(	O
parser_state_ty	struct
)	O
)	O
;	O
new	pointer
->	O
p_stack	pointer
=	O
xmalloc	function
(	O
parser_state_tos	pointer
->	O
p_stack_size	int
*	O
sizeof	O
(	O
codes_ty	enum
)	O
)	O
;	O
memcpy	function
(	O
new	pointer
->	O
p_stack	pointer
,	O
parser_state_tos	pointer
->	O
p_stack	pointer
,	O
(	O
parser_state_tos	pointer
->	O
p_stack_size	int
*	O
sizeof	O
(	O
codes_ty	enum
)	O
)	O
)	O
;	O
new	pointer
->	O
il	pointer
=	O
xmalloc	function
(	O
parser_state_tos	pointer
->	O
p_stack_size	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
memcpy	function
(	O
new	pointer
->	O
il	pointer
,	O
parser_state_tos	pointer
->	O
il	pointer
,	O
parser_state_tos	pointer
->	O
p_stack_size	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
new	pointer
->	O
cstk	pointer
=	O
xmalloc	function
(	O
parser_state_tos	pointer
->	O
p_stack_size	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
memcpy	function
(	O
new	pointer
->	O
cstk	pointer
,	O
parser_state_tos	pointer
->	O
cstk	pointer
,	O
parser_state_tos	pointer
->	O
p_stack_size	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
new	pointer
->	O
paren_indents	pointer
=	O
xmalloc	function
(	O
parser_state_tos	pointer
->	O
paren_indents_size	int
*	O
sizeof	O
(	O
short	O
)	O
)	O
;	O
memcpy	function
(	O
new	pointer
->	O
paren_indents	pointer
,	O
parser_state_tos	pointer
->	O
paren_indents	pointer
,	O
(	O
parser_state_tos	pointer
->	O
paren_indents_size	int
*	O
sizeof	O
(	O
short	O
)	O
)	O
)	O
;	O
new	pointer
->	O
next	pointer
=	O
parser_state_tos	pointer
;	O
parser_state_tos	pointer
=	O
new	pointer
;	O
}	O
}	O
else	O
if	O
(	O
(	O
strncmp	function
(	O
p	pointer
,	O
"else"	pointer
,	O
4	int
)	O
==	O
0	int
)	O
||	O
(	O
strncmp	function
(	O
p	pointer
,	O
"elif"	pointer
,	O
4	int
)	O
==	O
0	int
)	O
)	O
{	O
else_or_endif	int
=	O
(	O
strncmp	function
(	O
p	pointer
,	O
"else"	pointer
,	O
4	int
)	O
==	O
0	int
)	O
;	O
prefix_blankline_requested	int
=	O
0	int
;	O
if	O
(	O
parser_state_tos	pointer
->	O
next	pointer
)	O
{	O
codes_ty	enum
*	O
tos_p_stack	pointer
=	O
parser_state_tos	pointer
->	O
p_stack	pointer
;	O
int	O
*	O
tos_il	pointer
=	O
parser_state_tos	pointer
->	O
il	pointer
;	O
int	O
*	O
tos_cstk	pointer
=	O
parser_state_tos	pointer
->	O
cstk	pointer
;	O
short	O
*	O
tos_paren_indents	pointer
=	O
parser_state_tos	pointer
->	O
paren_indents	pointer
;	O
parser_state_ty	struct
*	O
second	pointer
=	O
parser_state_tos	pointer
->	O
next	pointer
;	O
(	O
void	O
)	O
memcpy	function
(	O
parser_state_tos	pointer
,	O
second	pointer
,	O
sizeof	O
(	O
parser_state_ty	struct
)	O
)	O
;	O
parser_state_tos	pointer
->	O
next	pointer
=	O
second	pointer
;	O
parser_state_tos	pointer
->	O
p_stack	pointer
=	O
tos_p_stack	pointer
;	O
(	O
void	O
)	O
memcpy	function
(	O
parser_state_tos	pointer
->	O
p_stack	pointer
,	O
parser_state_tos	pointer
->	O
next	pointer
->	O
p_stack	pointer
,	O
parser_state_tos	pointer
->	O
p_stack_size	int
*	O
sizeof	O
(	O
codes_ty	enum
)	O
)	O
;	O
parser_state_tos	pointer
->	O
il	pointer
=	O
tos_il	pointer
;	O
(	O
void	O
)	O
memcpy	function
(	O
parser_state_tos	pointer
->	O
il	pointer
,	O
parser_state_tos	pointer
->	O
next	pointer
->	O
il	pointer
,	O
(	O
parser_state_tos	pointer
->	O
p_stack_size	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
)	O
;	O
parser_state_tos	pointer
->	O
cstk	pointer
=	O
tos_cstk	pointer
;	O
(	O
void	O
)	O
memcpy	function
(	O
parser_state_tos	pointer
->	O
cstk	pointer
,	O
parser_state_tos	pointer
->	O
next	pointer
->	O
cstk	pointer
,	O
(	O
parser_state_tos	pointer
->	O
p_stack_size	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
)	O
;	O
parser_state_tos	pointer
->	O
paren_indents	pointer
=	O
tos_paren_indents	pointer
;	O
(	O
void	O
)	O
memcpy	function
(	O
parser_state_tos	pointer
->	O
paren_indents	pointer
,	O
parser_state_tos	pointer
->	O
next	pointer
->	O
paren_indents	pointer
,	O
(	O
parser_state_tos	pointer
->	O
paren_indents_size	int
*	O
sizeof	O
(	O
short	O
)	O
)	O
)	O
;	O
}	O
else	O
{	O
ERROR	O
(	O
else_or_endif	int
?	O
_	O
(	O
"Unmatched #else"	pointer
)	O
:	O
_	O
(	O
"Unmatched #elif"	pointer
)	O
,	O
0	int
,	O
0	int
)	O
;	O
*	O
file_exit_value	pointer
=	O
indent_error	int
;	O
}	O
}	O
else	O
if	O
(	O
strncmp	function
(	O
p	pointer
,	O
"endif"	pointer
,	O
5	int
)	O
==	O
0	int
)	O
{	O
else_or_endif	int
=	O
true	int
;	O
prefix_blankline_requested	int
=	O
0	int
;	O
if	O
(	O
parser_state_tos	pointer
->	O
next	pointer
)	O
{	O
parser_state_ty	struct
*	O
second	pointer
=	O
parser_state_tos	pointer
->	O
next	pointer
;	O
parser_state_tos	pointer
->	O
next	pointer
=	O
second	pointer
->	O
next	pointer
;	O
xfree	function
(	O
second	pointer
->	O
p_stack	pointer
)	O
;	O
xfree	function
(	O
second	pointer
->	O
il	pointer
)	O
;	O
xfree	function
(	O
second	pointer
->	O
cstk	pointer
)	O
;	O
xfree	function
(	O
second	pointer
->	O
paren_indents	pointer
)	O
;	O
xfree	function
(	O
second	pointer
)	O
;	O
}	O
else	O
{	O
ERROR	O
(	O
_	O
(	O
"Unmatched #endif"	pointer
)	O
,	O
0	int
,	O
0	int
)	O
;	O
*	O
file_exit_value	pointer
=	O
indent_error	int
;	O
}	O
if	O
(	O
settings	struct
.	O
blanklines_around_conditional_compilation	int
)	O
{	O
postfix_blankline_requested	int
++	O
;	O
postfix_blankline_requested_code	enum
=	O
preesc	int
;	O
n_real_blanklines	int
=	O
0	int
;	O
}	O
}	O
else	O
{	O
}	O
if	O
(	O
else_or_endif	int
&&	O
prefix_blankline_requested_code	enum
==	O
decl	int
)	O
{	O
prefix_blankline_requested	int
=	O
0	int
;	O
}	O
if	O
(	O
(	O
parser_state_tos	pointer
->	O
last_token	enum
==	O
comma	int
)	O
&&	O
(	O
parser_state_tos	pointer
->	O
p_l_follow	int
<=	O
0	int
)	O
&&	O
settings	struct
.	O
leave_comma	int
&&	O
!	O
parser_state_tos	pointer
->	O
block_init	int
&&	O
break_comma	int
&&	O
(	O
s_com	pointer
==	O
e_com	pointer
)	O
)	O
{	O
dump_line	function
(	O
true	int
,	O
&	O
paren_target	int
,	O
pbreak_line	pointer
)	O
;	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
false	int
;	O
}	O
}	O
static	O
void	O
handle_token_comment	function
(	O
BOOLEAN	char
*	O
force_nl	int
,	O
BOOLEAN	char
*	O
flushed_nl	pointer
,	O
BOOLEAN	char
*	O
pbreak_line	pointer
)	O
{	O
if	O
(	O
parser_state_tos	pointer
->	O
last_saw_nl	int
&&	O
(	O
s_code	pointer
!=	O
e_code	pointer
)	O
)	O
{	O
*	O
flushed_nl	pointer
=	O
false	int
;	O
dump_line	function
(	O
true	int
,	O
&	O
paren_target	int
,	O
pbreak_line	pointer
)	O
;	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
false	int
;	O
*	O
force_nl	int
=	O
false	int
;	O
}	O
print_comment	function
(	O
&	O
paren_target	int
,	O
pbreak_line	pointer
)	O
;	O
}	O
static	O
void	O
handle_token_attribute	function
(	O
void	O
)	O
{	O
char	O
*	O
t_ptr	pointer
;	O
if	O
(	O
s_code	pointer
!=	O
e_code	pointer
)	O
{	O
set_buf_break	function
(	O
bb_attribute	int
,	O
paren_target	int
)	O
;	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
' '	O
;	O
}	O
for	O
(	O
t_ptr	pointer
=	O
token	pointer
;	O
t_ptr	pointer
<	O
token_end	pointer
;	O
++	O
t_ptr	pointer
)	O
{	O
check_code_size	function
(	O
)	O
;	O
*	O
(	O
e_code	pointer
++	O
)	O
=	O
*	O
t_ptr	pointer
;	O
}	O
parser_state_tos	pointer
->	O
in_decl	char
=	O
false	int
;	O
parser_state_tos	pointer
->	O
want_blank	int
=	O
settings	struct
.	O
blank_after_sizeof	int
;	O
}	O
extern	O
void	O
handle_the_token	function
(	O
const	O
codes_ty	enum
type_code	enum
,	O
BOOLEAN	char
*	O
scase	pointer
,	O
BOOLEAN	char
*	O
force_nl	int
,	O
BOOLEAN	char
*	O
sp_sw	pointer
,	O
BOOLEAN	char
*	O
flushed_nl	pointer
,	O
codes_ty	enum
*	O
hd_type	pointer
,	O
int	O
*	O
dec_ind	pointer
,	O
BOOLEAN	char
*	O
last_token_ends_sp	pointer
,	O
exit_values_ty	enum
*	O
file_exit_value	pointer
,	O
const	O
bb_code_ty	enum
can_break	enum
,	O
BOOLEAN	char
*	O
last_else	pointer
,	O
BOOLEAN	char
is_procname_definition	char
,	O
BOOLEAN	char
*	O
pbreak_line	pointer
)	O
{	O
switch	O
(	O
type_code	enum
)	O
{	O
case	O
form_feed	int
:	O
handle_token_form_feed	function
(	O
pbreak_line	pointer
)	O
;	O
break	O
;	O
case	O
newline	int
:	O
handle_token_newline	function
(	O
force_nl	int
,	O
pbreak_line	pointer
)	O
;	O
break	O
;	O
case	O
lparen	int
:	O
handle_token_lparen	function
(	O
force_nl	int
,	O
sp_sw	pointer
,	O
dec_ind	pointer
,	O
pbreak_line	pointer
)	O
;	O
break	O
;	O
case	O
rparen	int
:	O
handle_token_rparen	function
(	O
force_nl	int
,	O
sp_sw	pointer
,	O
hd_type	pointer
,	O
last_token_ends_sp	pointer
,	O
file_exit_value	pointer
,	O
pbreak_line	pointer
)	O
;	O
break	O
;	O
case	O
unary_op	int
:	O
handle_token_unary_op	function
(	O
dec_ind	pointer
,	O
can_break	enum
)	O
;	O
break	O
;	O
case	O
binary_op	int
:	O
handle_token_binary_op	function
(	O
can_break	enum
)	O
;	O
break	O
;	O
case	O
postop	int
:	O
handle_token_postop	function
(	O
)	O
;	O
break	O
;	O
case	O
question	int
:	O
handle_token_question	function
(	O
can_break	enum
)	O
;	O
break	O
;	O
case	O
casestmt	int
:	O
handle_token_casestmt	function
(	O
scase	pointer
,	O
file_exit_value	pointer
)	O
;	O
copy_id	function
(	O
type_code	enum
,	O
force_nl	int
,	O
file_exit_value	pointer
,	O
can_break	enum
)	O
;	O
break	O
;	O
case	O
colon	int
:	O
handle_token_colon	function
(	O
scase	pointer
,	O
force_nl	int
,	O
dec_ind	pointer
,	O
can_break	enum
,	O
pbreak_line	pointer
)	O
;	O
break	O
;	O
case	O
doublecolon	int
:	O
handle_token_doublecolon	function
(	O
)	O
;	O
break	O
;	O
case	O
semicolon	int
:	O
handle_token_semicolon	function
(	O
scase	pointer
,	O
force_nl	int
,	O
sp_sw	pointer
,	O
dec_ind	pointer
,	O
last_token_ends_sp	pointer
,	O
file_exit_value	pointer
)	O
;	O
break	O
;	O
case	O
lbrace	int
:	O
handle_token_lbrace	function
(	O
force_nl	int
,	O
dec_ind	pointer
,	O
file_exit_value	pointer
,	O
pbreak_line	pointer
)	O
;	O
break	O
;	O
case	O
rbrace	int
:	O
handle_token_rbrace	function
(	O
force_nl	int
,	O
dec_ind	pointer
,	O
file_exit_value	pointer
,	O
pbreak_line	pointer
)	O
;	O
break	O
;	O
case	O
swstmt	int
:	O
handle_token_swstmt	function
(	O
sp_sw	pointer
,	O
hd_type	pointer
)	O
;	O
copy_id	function
(	O
type_code	enum
,	O
force_nl	int
,	O
file_exit_value	pointer
,	O
can_break	enum
)	O
;	O
break	O
;	O
case	O
sp_paren	int
:	O
handle_token_sp_paren	function
(	O
sp_sw	pointer
,	O
hd_type	pointer
)	O
;	O
copy_id	function
(	O
type_code	enum
,	O
force_nl	int
,	O
file_exit_value	pointer
,	O
can_break	enum
)	O
;	O
break	O
;	O
case	O
sp_else	int
:	O
case	O
sp_nparen	int
:	O
handle_token_nparen	function
(	O
force_nl	int
,	O
file_exit_value	pointer
,	O
last_else	pointer
,	O
pbreak_line	pointer
)	O
;	O
copy_id	function
(	O
type_code	enum
,	O
force_nl	int
,	O
file_exit_value	pointer
,	O
can_break	enum
)	O
;	O
break	O
;	O
case	O
overloaded	int
:	O
handle_token_overloaded	function
(	O
can_break	enum
)	O
;	O
break	O
;	O
case	O
decl	int
:	O
handle_token_decl	function
(	O
dec_ind	pointer
,	O
file_exit_value	pointer
,	O
pbreak_line	pointer
)	O
;	O
copy_id	function
(	O
type_code	enum
,	O
force_nl	int
,	O
file_exit_value	pointer
,	O
can_break	enum
)	O
;	O
break	O
;	O
case	O
cpp_operator	int
:	O
case	O
ident	int
:	O
handle_token_ident	function
(	O
force_nl	int
,	O
sp_sw	pointer
,	O
hd_type	pointer
,	O
dec_ind	pointer
,	O
file_exit_value	pointer
,	O
can_break	enum
,	O
is_procname_definition	char
,	O
pbreak_line	pointer
)	O
;	O
copy_id	function
(	O
type_code	enum
,	O
force_nl	int
,	O
file_exit_value	pointer
,	O
can_break	enum
)	O
;	O
break	O
;	O
case	O
struct_delim	int
:	O
handle_token_struct_delim	function
(	O
)	O
;	O
break	O
;	O
case	O
comma	int
:	O
handle_token_comma	function
(	O
force_nl	int
,	O
dec_ind	pointer
,	O
is_procname_definition	char
)	O
;	O
break	O
;	O
case	O
preesc	int
:	O
handle_token_preesc	function
(	O
file_exit_value	pointer
,	O
pbreak_line	pointer
)	O
;	O
break	O
;	O
case	O
comment	int
:	O
case	O
cplus_comment	int
:	O
handle_token_comment	function
(	O
force_nl	int
,	O
flushed_nl	pointer
,	O
pbreak_line	pointer
)	O
;	O
break	O
;	O
case	O
attribute	int
:	O
handle_token_attribute	function
(	O
)	O
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
}	O
