struct	O
undostruct	struct
*	O
firstUndo	pointer
,	O
*	O
lastUndo	pointer
,	O
*	O
firstRedo	pointer
;	O
char	O
undoBuf	array
[	O
4096	int
]	O
;	O
int	O
undoBufIndex	int
=	O
0	int
;	O
int	O
undoBufChars	int
=	O
0	int
;	O
char	O
undoBufRep	array
[	O
4096	int
]	O
;	O
int	O
undoBufRepIndex	int
=	O
0	int
;	O
int	O
undoBufRepChars	int
=	O
0	int
;	O
int	O
clipboardSize	int
=	O
0	int
;	O
point	struct
find_result_pos	array
[	O
1024	int
]	O
;	O
int	O
total_find_results	int
;	O
void	O
deleteUndoList	function
(	O
struct	O
undostruct	struct
*	O
first	int
)	O
{	O
while	O
(	O
first	int
)	O
{	O
struct	O
undostruct	struct
*	O
undo	pointer
=	O
first	int
->	O
prev	pointer
;	O
if	O
(	O
first	int
->	O
text	pointer
)	O
free	function
(	O
first	int
->	O
text	pointer
)	O
;	O
free	function
(	O
first	int
)	O
;	O
first	int
=	O
undo	pointer
;	O
}	O
}	O
void	O
deleteRedoList	function
(	O
struct	O
undostruct	struct
*	O
first	int
)	O
{	O
while	O
(	O
first	int
)	O
{	O
struct	O
undostruct	struct
*	O
undo	pointer
=	O
first	int
->	O
next	pointer
;	O
if	O
(	O
first	int
->	O
text	pointer
)	O
free	function
(	O
first	int
->	O
text	pointer
)	O
;	O
free	function
(	O
first	int
)	O
;	O
first	int
=	O
undo	pointer
;	O
}	O
}	O
void	O
initEdit	function
(	O
)	O
{	O
firstUndo	pointer
=	O
NULL	O
;	O
deleteUndoList	function
(	O
lastUndo	pointer
)	O
;	O
deleteRedoList	function
(	O
firstRedo	pointer
)	O
;	O
undoBufChars	int
=	O
0	int
;	O
undoBufIndex	int
=	O
0	int
;	O
undoBufRepChars	int
=	O
0	int
;	O
undoBufRepIndex	int
=	O
0	int
;	O
if	O
(	O
clipboardSize	int
==	O
0	int
)	O
{	O
clipboardSize	int
=	O
1024	int
;	O
clipboard	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
clipboardSize	int
)	O
;	O
}	O
}	O
struct	O
undostruct	struct
*	O
allocNewUndo	function
(	O
)	O
{	O
if	O
(	O
lastUndo	pointer
&&	O
lastUndo	pointer
->	O
type	enum
==	O
UNDO_ACTION_NONE	int
)	O
return	O
lastUndo	pointer
;	O
struct	O
undostruct	struct
*	O
undo	pointer
=	O
(	O
struct	O
undostruct	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
struct	O
undostruct	struct
)	O
)	O
;	O
if	O
(	O
!	O
undo	pointer
)	O
{	O
msgBox	function
(	O
"Insufficient memory"	pointer
,	O
OK	int
,	O
ERROR	int
)	O
;	O
return	O
NULL	O
;	O
}	O
undo	pointer
->	O
lineCount	int
=	O
0	int
;	O
undo	pointer
->	O
byteCount	int
=	O
0	int
;	O
undo	pointer
->	O
rbyteCount	int
=	O
0	int
;	O
undo	pointer
->	O
rlineCount	int
=	O
0	int
;	O
undo	pointer
->	O
lineStart	int
=	O
-	O
1	int
;	O
undo	pointer
->	O
charStart	int
=	O
-	O
1	int
;	O
undo	pointer
->	O
text	pointer
=	O
NULL	O
;	O
undo	pointer
->	O
rtext	pointer
=	O
NULL	O
;	O
undo	pointer
->	O
type	enum
=	O
UNDO_ACTION_NONE	int
;	O
undo	pointer
->	O
next	pointer
=	O
NULL	O
;	O
if	O
(	O
lastUndo	pointer
)	O
{	O
undo	pointer
->	O
prev	pointer
=	O
lastUndo	pointer
;	O
lastUndo	pointer
->	O
next	pointer
=	O
undo	pointer
;	O
lastUndo	pointer
=	O
undo	pointer
;	O
}	O
else	O
{	O
undo	pointer
->	O
prev	pointer
=	O
NULL	O
;	O
lastUndo	pointer
=	O
undo	pointer
;	O
firstUndo	pointer
=	O
undo	pointer
;	O
}	O
deleteRedoList	function
(	O
firstRedo	pointer
)	O
;	O
return	O
undo	pointer
;	O
}	O
struct	O
undostruct	struct
*	O
getLastUndo	function
(	O
int	O
allocIfNull	int
)	O
{	O
if	O
(	O
lastUndo	pointer
)	O
return	O
lastUndo	pointer
;	O
if	O
(	O
!	O
allocIfNull	int
)	O
return	O
NULL	O
;	O
return	O
allocNewUndo	function
(	O
)	O
;	O
}	O
void	O
initUndoAction	function
(	O
struct	O
undostruct	struct
*	O
undo	pointer
,	O
undoActionType	enum
utype	enum
,	O
int	O
lwhere	int
,	O
int	O
cwhere	int
)	O
{	O
undo	pointer
->	O
type	enum
=	O
utype	enum
;	O
undo	pointer
->	O
lineStart	int
=	O
lwhere	int
;	O
undo	pointer
->	O
charStart	int
=	O
cwhere	int
;	O
}	O
int	O
copyFromBuf	function
(	O
char	O
*	O
*	O
dest	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
bcount	int
)	O
{	O
if	O
(	O
bcount	int
==	O
0	int
)	O
return	O
1	int
;	O
*	O
dest	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
bcount	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
*	O
dest	pointer
)	O
return	O
0	int
;	O
memcpy	function
(	O
*	O
dest	pointer
,	O
buf	pointer
,	O
bcount	int
)	O
;	O
(	O
*	O
dest	pointer
)	O
[	O
bcount	int
]	O
=	O
'\0'	O
;	O
return	O
1	int
;	O
}	O
void	O
flushUndoBuffer	function
(	O
struct	O
undostruct	struct
*	O
undo	pointer
)	O
{	O
if	O
(	O
undoBufIndex	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
!	O
copyFromBuf	function
(	O
&	O
undo	pointer
->	O
text	pointer
,	O
undoBuf	array
,	O
undoBufIndex	int
)	O
)	O
goto	O
memerr	O
;	O
undo	pointer
->	O
byteCount	int
=	O
undoBufIndex	int
;	O
if	O
(	O
!	O
copyFromBuf	function
(	O
&	O
undo	pointer
->	O
rtext	pointer
,	O
undoBufRep	array
,	O
undoBufRepIndex	int
)	O
)	O
goto	O
memerr	O
;	O
undo	pointer
->	O
rbyteCount	int
=	O
undoBufRepIndex	int
;	O
undoBufIndex	int
=	O
0	int
;	O
undoBufChars	int
=	O
0	int
;	O
undoBufRepChars	int
=	O
0	int
;	O
undoBufRepIndex	int
=	O
0	int
;	O
return	O
;	O
memerr	O
:	O
msgBox	function
(	O
"Insufficient memory"	pointer
,	O
OK	int
,	O
ERROR	int
)	O
;	O
}	O
int	O
isContinuous	function
(	O
struct	O
undostruct	struct
*	O
undo	pointer
,	O
int	O
l2	int
,	O
int	O
c2	int
)	O
{	O
int	O
l1	int
=	O
undo	pointer
->	O
lineStart	int
;	O
if	O
(	O
l1	int
!=	O
l2	int
)	O
return	O
0	int
;	O
int	O
c1	int
=	O
undo	pointer
->	O
charStart	int
;	O
if	O
(	O
c1	int
==	O
c2	int
||	O
c2	int
==	O
c1	int
-	O
1	int
)	O
return	O
1	int
;	O
if	O
(	O
c2	int
==	O
c1	int
+	O
undoBufChars	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
void	O
undoAddChar	function
(	O
undoActionType	enum
utype	enum
,	O
int	O
lwhere	int
,	O
int	O
cwhere	int
,	O
char	O
what	char
)	O
{	O
struct	O
undostruct	struct
*	O
undo	pointer
=	O
getLastUndo	function
(	O
1	int
)	O
;	O
if	O
(	O
undo	pointer
==	O
NULL	O
)	O
goto	O
memerr	O
;	O
if	O
(	O
undo	pointer
->	O
type	enum
!=	O
utype	enum
||	O
!	O
isContinuous	function
(	O
undo	pointer
,	O
lwhere	int
,	O
cwhere	int
)	O
)	O
{	O
flushUndoBuffer	function
(	O
undo	pointer
)	O
;	O
if	O
(	O
undo	pointer
->	O
type	enum
!=	O
UNDO_ACTION_NONE	int
)	O
{	O
undo	pointer
=	O
allocNewUndo	function
(	O
)	O
;	O
if	O
(	O
undo	pointer
==	O
NULL	O
)	O
goto	O
memerr	O
;	O
}	O
initUndoAction	function
(	O
undo	pointer
,	O
utype	enum
,	O
lwhere	int
,	O
cwhere	int
)	O
;	O
}	O
if	O
(	O
cwhere	int
==	O
undo	pointer
->	O
charStart	int
)	O
{	O
for	O
(	O
int	O
i	int
=	O
undoBufIndex	int
;	O
i	int
>	O
0	int
;	O
i	int
--	O
)	O
undoBuf	array
[	O
undoBufIndex	int
]	O
=	O
undoBuf	array
[	O
undoBufIndex	int
-	O
1	int
]	O
;	O
undoBuf	array
[	O
0	int
]	O
=	O
what	char
;	O
}	O
else	O
undoBuf	array
[	O
undoBufIndex	int
]	O
=	O
what	char
;	O
undoBufIndex	int
++	O
;	O
if	O
(	O
(	O
what	char
&	O
0xc0	int
)	O
!=	O
0x80	int
)	O
undoBufChars	int
++	O
;	O
if	O
(	O
what	char
==	O
'\n'	O
)	O
{	O
flushUndoBuffer	function
(	O
undo	pointer
)	O
;	O
allocNewUndo	function
(	O
)	O
;	O
}	O
return	O
;	O
memerr	O
:	O
msgBox	function
(	O
"Insufficient memory"	pointer
,	O
OK	int
,	O
ERROR	int
)	O
;	O
return	O
;	O
}	O
int	O
undoAddUtfChar	function
(	O
undoActionType	enum
utype	enum
,	O
int	O
lwhere	int
,	O
int	O
cwhere	int
,	O
char	O
*	O
rwhat	pointer
)	O
{	O
int	O
save	int
=	O
cwhere	int
;	O
char	O
*	O
what	char
;	O
if	O
(	O
utype	enum
==	O
UNDO_ACTION_INSERT	int
)	O
what	char
=	O
rwhat	pointer
;	O
else	O
what	char
=	O
lines	array
[	O
lwhere	int
]	O
->	O
text	pointer
+	O
cwhere	int
;	O
undoAddChar	function
(	O
utype	enum
,	O
lwhere	int
,	O
cwhere	int
,	O
*	O
what	char
)	O
;	O
while	O
(	O
++	O
cwhere	int
,	O
(	O
*	O
(	O
++	O
what	char
)	O
&	O
0xc0	int
)	O
==	O
0x80	int
)	O
undoAddChar	function
(	O
utype	enum
,	O
lwhere	int
,	O
cwhere	int
,	O
*	O
what	char
)	O
;	O
if	O
(	O
utype	enum
==	O
UNDO_ACTION_REPLACE	int
)	O
{	O
char	O
c	char
;	O
while	O
(	O
(	O
c	char
=	O
*	O
rwhat	pointer
++	O
)	O
)	O
undoBufRep	array
[	O
undoBufRepIndex	int
++	O
]	O
=	O
c	char
;	O
}	O
return	O
cwhere	int
-	O
save	int
;	O
}	O
int	O
extendClipboardSize	function
(	O
int	O
newSize	int
)	O
{	O
if	O
(	O
newSize	int
<	O
clipboardSize	int
)	O
return	O
1	int
;	O
clipboardSize	int
=	O
newSize	int
+	O
1	int
;	O
if	O
(	O
clipboard	pointer
)	O
free	function
(	O
clipboard	pointer
)	O
;	O
clipboard	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
clipboardSize	int
)	O
;	O
if	O
(	O
!	O
clipboard	pointer
)	O
{	O
msgBox	function
(	O
"Insufficient memory"	pointer
,	O
OK	int
,	O
ERROR	int
)	O
;	O
}	O
}	O
void	O
swap_lines	function
(	O
)	O
{	O
int	O
tmp	int
;	O
tmp	int
=	O
sel_range_end	struct
.	O
nline	int
;	O
sel_range_end	struct
.	O
nline	int
=	O
sel_range_start	struct
.	O
nline	int
;	O
sel_range_start	struct
.	O
nline	int
=	O
tmp	int
;	O
tmp	int
=	O
sel_range_end	struct
.	O
nchar	int
;	O
sel_range_end	struct
.	O
nchar	int
=	O
sel_range_start	struct
.	O
nchar	int
;	O
sel_range_start	struct
.	O
nchar	int
=	O
tmp	int
;	O
}	O
void	O
swap_chars	function
(	O
)	O
{	O
int	O
tmp	int
;	O
tmp	int
=	O
sel_range_end	struct
.	O
nchar	int
;	O
sel_range_end	struct
.	O
nchar	int
=	O
sel_range_start	struct
.	O
nchar	int
;	O
sel_range_start	struct
.	O
nchar	int
=	O
tmp	int
;	O
}	O
void	O
clear_selected_range	function
(	O
)	O
{	O
}	O
void	O
editMenu_DeleteLine	function
(	O
)	O
{	O
deleteLine	function
(	O
)	O
;	O
}	O
void	O
editMenu_ToggleSelectMode	function
(	O
)	O
{	O
if	O
(	O
X_IS_RUNNING	int
)	O
{	O
SELECTING	int
=	O
!	O
SELECTING	int
;	O
refreshBottomView	function
(	O
)	O
;	O
if	O
(	O
SELECTING	int
)	O
{	O
sel_range_start	struct
.	O
nline	int
=	O
firstVisLine	int
+	O
selectedLine	int
;	O
sel_range_start	struct
.	O
nchar	int
=	O
selectedChar	int
;	O
sel_range_end	struct
.	O
nline	int
=	O
firstVisLine	int
+	O
selectedLine	int
;	O
sel_range_end	struct
.	O
nchar	int
=	O
selectedChar	int
;	O
}	O
}	O
else	O
{	O
msgBox	function
(	O
"The select mode is only available under X.\nUse SHIFT to select text."	pointer
,	O
OK	int
,	O
INFO	int
)	O
;	O
refreshView	function
(	O
)	O
;	O
}	O
}	O
void	O
editMenu_Copy	function
(	O
)	O
{	O
if	O
(	O
!	O
SELECTING	int
&&	O
!	O
SELECTED	int
)	O
return	O
;	O
int	O
i	int
,	O
j	int
,	O
k	int
,	O
l	int
;	O
if	O
(	O
!	O
clipboard	pointer
)	O
goto	O
memerr	O
;	O
clipboard	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
int	O
swap	int
=	O
0	int
;	O
if	O
(	O
sel_range_start	struct
.	O
nline	int
>	O
sel_range_end	struct
.	O
nline	int
)	O
{	O
swap	int
=	O
1	int
;	O
swap_lines	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
sel_range_start	struct
.	O
nline	int
==	O
sel_range_end	struct
.	O
nline	int
&&	O
sel_range_start	struct
.	O
nchar	int
>	O
sel_range_end	struct
.	O
nchar	int
)	O
{	O
swap	int
=	O
2	int
;	O
swap_chars	function
(	O
)	O
;	O
}	O
total_lines_in_clipboard	int
=	O
sel_range_end	struct
.	O
nline	int
-	O
sel_range_start	struct
.	O
nline	int
;	O
if	O
(	O
total_lines_in_clipboard	int
==	O
0	int
)	O
{	O
j	int
=	O
charsToBytes	function
(	O
sel_range_start	struct
.	O
nline	int
,	O
sel_range_start	struct
.	O
nchar	int
)	O
;	O
k	int
=	O
charsToBytes	function
(	O
sel_range_end	struct
.	O
nline	int
,	O
sel_range_end	struct
.	O
nchar	int
)	O
;	O
i	int
=	O
k	int
-	O
j	int
;	O
if	O
(	O
!	O
extendClipboardSize	function
(	O
i	int
)	O
)	O
goto	O
memerr	O
;	O
memcpy	function
(	O
clipboard	pointer
,	O
lines	array
[	O
sel_range_start	struct
.	O
nline	int
]	O
->	O
text	pointer
+	O
j	int
,	O
i	int
)	O
;	O
clipboard	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
{	O
l	int
=	O
0	int
;	O
j	int
=	O
charsToBytes	function
(	O
sel_range_start	struct
.	O
nline	int
,	O
sel_range_start	struct
.	O
nchar	int
)	O
;	O
l	int
+=	O
(	O
lines	array
[	O
sel_range_start	struct
.	O
nline	int
]	O
->	O
byteCount	int
-	O
j	int
)	O
;	O
k	int
=	O
charsToBytes	function
(	O
sel_range_end	struct
.	O
nline	int
,	O
sel_range_end	struct
.	O
nchar	int
)	O
;	O
l	int
+=	O
k	int
;	O
for	O
(	O
i	int
=	O
sel_range_start	struct
.	O
nline	int
+	O
1	int
;	O
i	int
<	O
sel_range_end	struct
.	O
nline	int
;	O
i	int
++	O
)	O
l	int
+=	O
lines	array
[	O
i	int
]	O
->	O
byteCount	int
;	O
if	O
(	O
!	O
extendClipboardSize	function
(	O
l	int
)	O
)	O
goto	O
memerr	O
;	O
strcpy	function
(	O
clipboard	pointer
,	O
lines	array
[	O
sel_range_start	struct
.	O
nline	int
]	O
->	O
text	pointer
+	O
j	int
)	O
;	O
for	O
(	O
i	int
=	O
sel_range_start	struct
.	O
nline	int
+	O
1	int
;	O
i	int
<	O
sel_range_end	struct
.	O
nline	int
;	O
i	int
++	O
)	O
strcat	function
(	O
clipboard	pointer
,	O
lines	array
[	O
i	int
]	O
->	O
text	pointer
)	O
;	O
strncat	function
(	O
clipboard	pointer
,	O
lines	array
[	O
sel_range_end	struct
.	O
nline	int
]	O
->	O
text	pointer
,	O
k	int
)	O
;	O
clipboard	pointer
[	O
l	int
]	O
=	O
'\0'	O
;	O
}	O
CLIPBOARD_IS_EMPTY	int
=	O
0	int
;	O
if	O
(	O
swap	int
==	O
1	int
)	O
swap_lines	function
(	O
)	O
;	O
if	O
(	O
swap	int
==	O
2	int
)	O
swap_chars	function
(	O
)	O
;	O
return	O
;	O
memerr	O
:	O
msgBox	function
(	O
"Insufficient memory"	pointer
,	O
OK	int
,	O
ERROR	int
)	O
;	O
return	O
;	O
}	O
void	O
editMenu_Cut	function
(	O
)	O
{	O
if	O
(	O
SELECTING	int
||	O
SELECTED	int
)	O
{	O
editMenu_Copy	function
(	O
)	O
;	O
remove_selected_text	function
(	O
1	int
)	O
;	O
}	O
}	O
void	O
remove_selected_text	function
(	O
int	O
recordAction	int
)	O
{	O
int	O
swap	int
=	O
0	int
;	O
if	O
(	O
sel_range_start	struct
.	O
nline	int
>	O
sel_range_end	struct
.	O
nline	int
)	O
{	O
swap	int
=	O
1	int
;	O
swap_lines	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
sel_range_start	struct
.	O
nline	int
==	O
sel_range_end	struct
.	O
nline	int
&&	O
sel_range_start	struct
.	O
nchar	int
>	O
sel_range_end	struct
.	O
nchar	int
)	O
{	O
swap	int
=	O
2	int
;	O
swap_chars	function
(	O
)	O
;	O
}	O
int	O
i	int
,	O
j	int
,	O
k	int
,	O
l	int
;	O
int	O
refreshAll	int
=	O
0	int
;	O
int	O
first	int
=	O
sel_range_start	struct
.	O
nline	int
;	O
int	O
last	int
=	O
sel_range_end	struct
.	O
nline	int
;	O
int	O
diff	int
=	O
last	int
-	O
first	int
;	O
struct	O
undostruct	struct
*	O
undo	pointer
=	O
getLastUndo	function
(	O
1	int
)	O
;	O
if	O
(	O
recordAction	int
)	O
{	O
flushUndoBuffer	function
(	O
undo	pointer
)	O
;	O
undo	pointer
=	O
allocNewUndo	function
(	O
)	O
;	O
undo	pointer
->	O
type	enum
=	O
UNDO_ACTION_DELETE	int
;	O
undo	pointer
->	O
lineStart	int
=	O
sel_range_start	struct
.	O
nline	int
;	O
undo	pointer
->	O
charStart	int
=	O
sel_range_start	struct
.	O
nchar	int
;	O
undo	pointer
->	O
lineCount	int
=	O
diff	int
;	O
}	O
if	O
(	O
diff	int
==	O
0	int
)	O
{	O
j	int
=	O
charsToBytes	function
(	O
first	int
,	O
sel_range_start	struct
.	O
nchar	int
)	O
;	O
k	int
=	O
charsToBytes	function
(	O
last	int
,	O
sel_range_end	struct
.	O
nchar	int
)	O
;	O
i	int
=	O
k	int
-	O
j	int
;	O
if	O
(	O
recordAction	int
)	O
{	O
undo	pointer
->	O
text	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
i	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
undo	pointer
->	O
text	pointer
)	O
goto	O
memerr	O
;	O
memcpy	function
(	O
undo	pointer
->	O
text	pointer
,	O
lines	array
[	O
first	int
]	O
->	O
text	pointer
+	O
j	int
,	O
i	int
)	O
;	O
undo	pointer
->	O
text	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
undo	pointer
->	O
byteCount	int
=	O
i	int
;	O
}	O
if	O
(	O
lines	array
[	O
sel_range_start	struct
.	O
nline	int
]	O
->	O
linkedToNext	int
)	O
refreshAll	int
=	O
1	int
;	O
copyInLine	function
(	O
sel_range_start	struct
.	O
nline	int
,	O
j	int
,	O
k	int
,	O
0	int
)	O
;	O
checkLineBounds	function
(	O
sel_range_start	struct
.	O
nline	int
)	O
;	O
}	O
else	O
{	O
l	int
=	O
0	int
;	O
j	int
=	O
charsToBytes	function
(	O
first	int
,	O
sel_range_start	struct
.	O
nchar	int
)	O
;	O
l	int
+=	O
(	O
lines	array
[	O
first	int
]	O
->	O
byteCount	int
-	O
j	int
)	O
;	O
k	int
=	O
charsToBytes	function
(	O
last	int
,	O
sel_range_end	struct
.	O
nchar	int
)	O
;	O
l	int
+=	O
k	int
;	O
if	O
(	O
recordAction	int
)	O
{	O
for	O
(	O
i	int
=	O
first	int
+	O
1	int
;	O
i	int
<	O
last	int
;	O
i	int
++	O
)	O
l	int
+=	O
lines	array
[	O
i	int
]	O
->	O
byteCount	int
;	O
undo	pointer
->	O
text	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
l	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
undo	pointer
->	O
text	pointer
)	O
goto	O
memerr	O
;	O
strcpy	function
(	O
undo	pointer
->	O
text	pointer
,	O
lines	array
[	O
first	int
]	O
->	O
text	pointer
+	O
j	int
)	O
;	O
for	O
(	O
i	int
=	O
first	int
+	O
1	int
;	O
i	int
<	O
last	int
;	O
i	int
++	O
)	O
strcat	function
(	O
undo	pointer
->	O
text	pointer
,	O
lines	array
[	O
i	int
]	O
->	O
text	pointer
)	O
;	O
strncat	function
(	O
undo	pointer
->	O
text	pointer
,	O
lines	array
[	O
last	int
]	O
->	O
text	pointer
,	O
k	int
)	O
;	O
undo	pointer
->	O
text	pointer
[	O
l	int
]	O
=	O
'\0'	O
;	O
undo	pointer
->	O
byteCount	int
=	O
l	int
;	O
}	O
l	int
=	O
j	int
+	O
k	int
;	O
if	O
(	O
l	int
>=	O
lines	array
[	O
first	int
]	O
->	O
byteCount	int
)	O
{	O
char	O
*	O
s	pointer
=	O
(	O
char	O
*	O
)	O
realloc	function
(	O
lines	array
[	O
first	int
]	O
->	O
text	pointer
,	O
l	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
s	pointer
)	O
goto	O
memerr	O
;	O
lines	array
[	O
first	int
]	O
->	O
text	pointer
=	O
s	pointer
;	O
}	O
strncat	function
(	O
lines	array
[	O
first	int
]	O
->	O
text	pointer
+	O
j	int
,	O
lines	array
[	O
last	int
]	O
->	O
text	pointer
,	O
k	int
)	O
;	O
lines	array
[	O
first	int
]	O
->	O
text	pointer
[	O
j	int
+	O
k	int
]	O
=	O
'\0'	O
;	O
calcTotalCharsInLine	function
(	O
first	int
)	O
;	O
lines	array
[	O
first	int
]	O
->	O
linkedToNext	int
=	O
lines	array
[	O
last	int
]	O
->	O
linkedToNext	int
;	O
move_lines_upd	function
(	O
first	int
+	O
1	int
,	O
last	int
-	O
first	int
)	O
;	O
checkLineBounds	function
(	O
first	int
)	O
;	O
refreshAll	int
=	O
1	int
;	O
}	O
SELECTING	int
=	O
0	int
;	O
SELECTED	int
=	O
0	int
;	O
FILE_STATE	enum
=	O
MODIFIED	int
;	O
selectedChar	int
=	O
sel_range_start	struct
.	O
nchar	int
;	O
refreshAll	int
=	O
fixViewPostUndo	function
(	O
first	int
)	O
;	O
if	O
(	O
refreshAll	int
)	O
refreshView	function
(	O
)	O
;	O
else	O
refreshSelectedLine	function
(	O
)	O
;	O
if	O
(	O
swap	int
==	O
1	int
)	O
swap_lines	function
(	O
)	O
;	O
if	O
(	O
swap	int
==	O
2	int
)	O
swap_chars	function
(	O
)	O
;	O
return	O
;	O
memerr	O
:	O
msgBox	function
(	O
"Insufficient memory"	pointer
,	O
OK	int
,	O
ERROR	int
)	O
;	O
return	O
;	O
}	O
void	O
_do_paste	function
(	O
char	O
*	O
src	pointer
,	O
int	O
srcLineCount	int
,	O
int	O
recordAction	int
)	O
{	O
int	O
i	int
=	O
0	int
;	O
int	O
j	int
=	O
firstVisLine	int
+	O
selectedLine	int
;	O
int	O
k	int
=	O
selectedChar	int
;	O
int	O
l	int
;	O
if	O
(	O
(	O
srcLineCount	int
+	O
totalLines	int
)	O
>=	O
MAX_LINES	int
)	O
{	O
msgBox	function
(	O
"Unable to paste text. Line count will exceed the maximum of "	pointer
tostr	O
(	O
MAX_LINES	int
)	O
"."	pointer
,	O
OK	int
,	O
ERROR	int
)	O
;	O
return	O
;	O
}	O
else	O
l	int
=	O
srcLineCount	int
;	O
if	O
(	O
recordAction	int
)	O
{	O
struct	O
undostruct	struct
*	O
undo	pointer
=	O
getLastUndo	function
(	O
1	int
)	O
;	O
flushUndoBuffer	function
(	O
undo	pointer
)	O
;	O
undo	pointer
=	O
allocNewUndo	function
(	O
)	O
;	O
undo	pointer
->	O
type	enum
=	O
UNDO_ACTION_INSERT	int
;	O
undo	pointer
->	O
lineStart	int
=	O
j	int
;	O
undo	pointer
->	O
charStart	int
=	O
k	int
;	O
undo	pointer
->	O
lineCount	int
=	O
l	int
;	O
undo	pointer
->	O
text	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
strlen	function
(	O
src	pointer
)	O
+	O
1	int
)	O
;	O
if	O
(	O
!	O
undo	pointer
->	O
text	pointer
)	O
{	O
msgBox	function
(	O
"Insufficient memory"	pointer
,	O
OK	int
,	O
ERROR	int
)	O
;	O
return	O
;	O
}	O
strcpy	function
(	O
undo	pointer
->	O
text	pointer
,	O
src	pointer
)	O
;	O
}	O
int	O
tmpLen	int
=	O
lines	array
[	O
j	int
]	O
->	O
byteCount	int
-	O
charsToBytes	function
(	O
j	int
,	O
k	int
)	O
;	O
char	O
tmp	int
[	O
tmpLen	int
+	O
1	int
]	O
;	O
if	O
(	O
tmpLen	int
)	O
strcpy	function
(	O
tmp	int
,	O
lines	array
[	O
j	int
]	O
->	O
text	pointer
+	O
k	int
)	O
;	O
else	O
tmp	int
[	O
0	int
]	O
=	O
'\0'	O
;	O
int	O
n	int
=	O
l	int
+	O
1	int
;	O
for	O
(	O
i	int
=	O
totalLines	int
+	O
l	int
;	O
i	int
>	O
j	int
+	O
l	int
;	O
i	int
--	O
)	O
copyLineStruct	function
(	O
i	int
,	O
i	int
-	O
l	int
)	O
;	O
for	O
(	O
;	O
i	int
>	O
j	int
;	O
i	int
--	O
)	O
lines	array
[	O
i	int
]	O
=	O
allocLineStructB	function
(	O
maxLen	int
)	O
;	O
i	int
=	O
0	int
;	O
l	int
+=	O
j	int
+	O
1	int
;	O
char	O
*	O
line	pointer
=	O
lines	array
[	O
j	int
]	O
->	O
text	pointer
;	O
char	O
*	O
clip	pointer
=	O
src	pointer
;	O
while	O
(	O
j	int
<=	O
l	int
)	O
{	O
if	O
(	O
k	int
>=	O
MAX_CHARS_PER_LINE	int
)	O
{	O
move_lines_down	function
(	O
totalLines	int
,	O
j	int
+	O
1	int
)	O
;	O
n	int
++	O
;	O
lines	array
[	O
j	int
]	O
->	O
linkedToNext	int
=	O
1	int
;	O
*	O
line	pointer
=	O
'\0'	O
;	O
k	int
=	O
0	int
;	O
calcTotalCharsInLine	function
(	O
j	int
)	O
;	O
line	pointer
=	O
lines	array
[	O
++	O
j	int
]	O
->	O
text	pointer
;	O
selectedLine	int
++	O
;	O
}	O
if	O
(	O
*	O
clip	pointer
==	O
'\0'	O
)	O
{	O
*	O
line	pointer
=	O
'\0'	O
;	O
calcTotalCharsInLine	function
(	O
j	int
)	O
;	O
selectedLine	int
++	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
*	O
clip	pointer
==	O
'\n'	O
)	O
{	O
lines	array
[	O
j	int
]	O
->	O
linkedToNext	int
=	O
0	int
;	O
*	O
line	pointer
++	O
=	O
'\n'	O
;	O
*	O
line	pointer
=	O
'\0'	O
;	O
k	int
=	O
0	int
;	O
calcTotalCharsInLine	function
(	O
j	int
)	O
;	O
line	pointer
=	O
lines	array
[	O
++	O
j	int
]	O
->	O
text	pointer
;	O
clip	pointer
++	O
;	O
selectedLine	int
++	O
;	O
}	O
else	O
{	O
if	O
(	O
*	O
clip	pointer
==	O
'\t'	O
)	O
{	O
i	int
=	O
TABSPACES	O
(	O
k	int
+	O
1	int
)	O
;	O
k	int
+=	O
i	int
;	O
}	O
else	O
k	int
++	O
;	O
*	O
line	pointer
++	O
=	O
*	O
clip	pointer
++	O
;	O
}	O
}	O
totalLines	int
+=	O
n	int
;	O
if	O
(	O
tmpLen	int
)	O
{	O
i	int
=	O
lines	array
[	O
j	int
]	O
->	O
byteCount	int
+	O
tmpLen	int
;	O
if	O
(	O
i	int
>=	O
maxLen	int
)	O
{	O
if	O
(	O
!	O
extendLineText	function
(	O
j	int
,	O
i	int
)	O
)	O
{	O
msgBox	function
(	O
"Insufficient memory"	pointer
,	O
OK	int
,	O
ERROR	int
)	O
;	O
return	O
;	O
}	O
}	O
strcat	function
(	O
lines	array
[	O
j	int
]	O
->	O
text	pointer
,	O
tmp	int
)	O
;	O
checkLineBounds	function
(	O
j	int
)	O
;	O
}	O
if	O
(	O
selectedLine	int
>=	O
totalVisLines	int
)	O
{	O
int	O
diff	int
=	O
selectedLine	int
-	O
totalVisLines	int
+	O
1	int
;	O
firstVisLine	int
+=	O
diff	int
;	O
selectedLine	int
-=	O
diff	int
;	O
}	O
if	O
(	O
totalLines	int
<=	O
totalVisLines	int
)	O
{	O
firstVisLine	int
=	O
0	int
;	O
selectedLine	int
=	O
totalLines	int
-	O
1	int
;	O
}	O
else	O
if	O
(	O
(	O
totalLines	int
-	O
j	int
)	O
<	O
totalVisLines	int
)	O
{	O
firstVisLine	int
=	O
totalLines	int
-	O
totalVisLines	int
;	O
selectedLine	int
=	O
totalVisLines	int
-	O
(	O
totalLines	int
-	O
j	int
)	O
-	O
1	int
;	O
}	O
selectedChar	int
=	O
k	int
;	O
}	O
void	O
editMenu_Paste	function
(	O
)	O
{	O
if	O
(	O
CLIPBOARD_IS_EMPTY	int
)	O
return	O
;	O
_do_paste	function
(	O
clipboard	pointer
,	O
total_lines_in_clipboard	int
,	O
1	int
)	O
;	O
SELECTED	int
=	O
0	int
;	O
SELECTING	int
=	O
0	int
;	O
FILE_STATE	enum
=	O
MODIFIED	int
;	O
refreshView	function
(	O
)	O
;	O
}	O
void	O
editMenu_SelectAll	function
(	O
)	O
{	O
SELECTING	int
=	O
1	int
;	O
sel_range_start	struct
.	O
nline	int
=	O
0	int
;	O
sel_range_end	struct
.	O
nline	int
=	O
totalLines	int
-	O
1	int
;	O
sel_range_start	struct
.	O
nchar	int
=	O
0	int
;	O
sel_range_end	struct
.	O
nchar	int
=	O
lines	array
[	O
totalLines	int
-	O
1	int
]	O
->	O
charCount	int
;	O
if	O
(	O
sel_range_end	struct
.	O
nchar	int
<	O
0	int
)	O
sel_range_end	struct
.	O
nchar	int
=	O
0	int
;	O
if	O
(	O
totalLines	int
<=	O
totalVisLines	int
)	O
{	O
firstVisLine	int
=	O
0	int
;	O
selectedLine	int
=	O
totalLines	int
-	O
1	int
;	O
selectedChar	int
=	O
lines	array
[	O
selectedLine	int
]	O
->	O
charCount	int
;	O
}	O
else	O
{	O
firstVisLine	int
=	O
totalLines	int
-	O
totalVisLines	int
;	O
selectedLine	int
=	O
totalVisLines	int
-	O
1	int
;	O
selectedChar	int
=	O
lines	array
[	O
firstVisLine	int
+	O
selectedLine	int
]	O
->	O
charCount	int
;	O
}	O
calcCharCarry	function
(	O
firstVisLine	int
+	O
selectedLine	int
)	O
;	O
SELECTING	int
=	O
0	int
;	O
SELECTED	int
=	O
1	int
;	O
refreshView	function
(	O
)	O
;	O
}	O
int	O
fixViewPostUndo	function
(	O
int	O
first	int
)	O
{	O
int	O
refreshAll	int
=	O
0	int
;	O
if	O
(	O
first	int
<	O
firstVisLine	int
)	O
{	O
selectedLine	int
=	O
0	int
;	O
firstVisLine	int
=	O
first	int
;	O
refreshAll	int
=	O
1	int
;	O
}	O
else	O
{	O
selectedLine	int
=	O
first	int
-	O
firstVisLine	int
;	O
if	O
(	O
selectedLine	int
>=	O
totalVisLines	int
)	O
{	O
firstVisLine	int
+=	O
(	O
selectedLine	int
-	O
totalVisLines	int
+	O
1	int
)	O
;	O
selectedLine	int
=	O
totalVisLines	int
-	O
1	int
;	O
}	O
}	O
if	O
(	O
firstVisLine	int
+	O
totalVisLines	int
>	O
totalLines	int
)	O
{	O
int	O
i	int
=	O
firstVisLine	int
;	O
firstVisLine	int
=	O
totalLines	int
-	O
totalVisLines	int
;	O
selectedLine	int
+=	O
(	O
firstVisLine	int
-	O
i	int
)	O
;	O
refreshAll	int
=	O
1	int
;	O
}	O
return	O
refreshAll	int
;	O
}	O
void	O
editMenu_Undo	function
(	O
)	O
{	O
struct	O
undostruct	struct
*	O
undo	pointer
=	O
getLastUndo	function
(	O
0	int
)	O
;	O
if	O
(	O
undo	pointer
==	O
NULL	O
)	O
return	O
;	O
flushUndoBuffer	function
(	O
undo	pointer
)	O
;	O
int	O
first	int
=	O
undo	pointer
->	O
lineStart	int
;	O
int	O
i	int
=	O
undo	pointer
->	O
byteCount	int
;	O
int	O
j	int
=	O
undo	pointer
->	O
rbyteCount	int
;	O
int	O
k	int
,	O
l	int
;	O
if	O
(	O
undo	pointer
->	O
type	enum
==	O
UNDO_ACTION_REPLACE	int
)	O
{	O
k	int
=	O
charsToBytes	function
(	O
first	int
,	O
undo	pointer
->	O
charStart	int
)	O
;	O
if	O
(	O
undo	pointer
->	O
lineCount	int
==	O
0	int
)	O
{	O
if	O
(	O
i	int
>	O
j	int
)	O
{	O
l	int
=	O
i	int
-	O
j	int
;	O
if	O
(	O
!	O
extendLineText	function
(	O
first	int
,	O
lines	array
[	O
first	int
]	O
->	O
byteCount	int
+	O
l	int
)	O
)	O
goto	O
memerr	O
;	O
copyInLine	function
(	O
first	int
,	O
k	int
+	O
i	int
,	O
k	int
+	O
j	int
,	O
0	int
)	O
;	O
memcpy	function
(	O
lines	array
[	O
first	int
]	O
->	O
text	pointer
+	O
k	int
,	O
undo	pointer
->	O
text	pointer
,	O
i	int
)	O
;	O
}	O
else	O
if	O
(	O
i	int
<	O
j	int
)	O
{	O
memcpy	function
(	O
lines	array
[	O
first	int
]	O
->	O
text	pointer
+	O
k	int
,	O
undo	pointer
->	O
text	pointer
,	O
i	int
)	O
;	O
copyInLine	function
(	O
first	int
,	O
k	int
+	O
i	int
,	O
k	int
+	O
j	int
,	O
0	int
)	O
;	O
}	O
else	O
{	O
memcpy	function
(	O
lines	array
[	O
first	int
]	O
->	O
text	pointer
+	O
k	int
,	O
undo	pointer
->	O
text	pointer
,	O
i	int
)	O
;	O
}	O
selectedChar	int
=	O
undo	pointer
->	O
charStart	int
;	O
checkLineBounds	function
(	O
first	int
)	O
;	O
calcCharCarry	function
(	O
first	int
)	O
;	O
}	O
else	O
{	O
char	O
*	O
s	pointer
=	O
strrchr	function
(	O
undo	pointer
->	O
rtext	pointer
,	O
'\n'	O
)	O
;	O
if	O
(	O
!	O
s	pointer
)	O
return	O
;	O
k	int
+=	O
strlen	function
(	O
s	pointer
)	O
;	O
if	O
(	O
!	O
extendLineText	function
(	O
first	int
,	O
k	int
+	O
1	int
)	O
)	O
goto	O
memerr	O
;	O
strcat	function
(	O
lines	array
[	O
first	int
]	O
->	O
text	pointer
,	O
s	pointer
+	O
1	int
)	O
;	O
lines	array
[	O
first	int
]	O
->	O
linkedToNext	int
=	O
lines	array
[	O
first	int
+	O
undo	pointer
->	O
lineCount	int
]	O
->	O
linkedToNext	int
;	O
move_lines_upd	function
(	O
first	int
+	O
1	int
,	O
undo	pointer
->	O
lineCount	int
)	O
;	O
checkLineBounds	function
(	O
first	int
)	O
;	O
firstVisLine	int
=	O
undo	pointer
->	O
lineStart	int
;	O
selectedLine	int
=	O
0	int
;	O
selectedChar	int
=	O
undo	pointer
->	O
charStart	int
;	O
_do_paste	function
(	O
undo	pointer
->	O
text	pointer
,	O
undo	pointer
->	O
lineCount	int
,	O
0	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
undo	pointer
->	O
type	enum
==	O
UNDO_ACTION_INSERT	int
)	O
{	O
sel_range_start	struct
.	O
nline	int
=	O
undo	pointer
->	O
lineStart	int
;	O
sel_range_end	struct
.	O
nline	int
=	O
undo	pointer
->	O
lineStart	int
+	O
undo	pointer
->	O
lineCount	int
;	O
sel_range_start	struct
.	O
nchar	int
=	O
undo	pointer
->	O
charStart	int
;	O
char	O
*	O
s	pointer
=	O
strrchr	function
(	O
undo	pointer
->	O
text	pointer
,	O
'\n'	O
)	O
;	O
if	O
(	O
!	O
s	pointer
)	O
s	pointer
=	O
undo	pointer
->	O
text	pointer
-	O
1	int
;	O
i	int
=	O
utfstrlen	function
(	O
s	pointer
+	O
1	int
)	O
;	O
sel_range_end	struct
.	O
nchar	int
=	O
i	int
;	O
if	O
(	O
sel_range_start	struct
.	O
nline	int
==	O
sel_range_end	struct
.	O
nline	int
)	O
sel_range_end	struct
.	O
nchar	int
+=	O
undo	pointer
->	O
charStart	int
;	O
remove_selected_text	function
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
undo	pointer
->	O
type	enum
==	O
UNDO_ACTION_DELETE	int
)	O
{	O
if	O
(	O
undo	pointer
->	O
lineCount	int
==	O
0	int
)	O
{	O
k	int
=	O
lines	array
[	O
first	int
]	O
->	O
byteCount	int
+	O
i	int
;	O
if	O
(	O
!	O
extendLineText	function
(	O
first	int
,	O
k	int
)	O
)	O
goto	O
memerr	O
;	O
copyInLine	function
(	O
first	int
,	O
undo	pointer
->	O
charStart	int
+	O
i	int
,	O
undo	pointer
->	O
charStart	int
,	O
0	int
)	O
;	O
memcpy	function
(	O
lines	array
[	O
first	int
]	O
->	O
text	pointer
+	O
undo	pointer
->	O
charStart	int
,	O
undo	pointer
->	O
text	pointer
,	O
i	int
)	O
;	O
selectedChar	int
=	O
undo	pointer
->	O
charStart	int
;	O
checkLineBounds	function
(	O
first	int
)	O
;	O
calcCharCarry	function
(	O
first	int
)	O
;	O
}	O
else	O
{	O
firstVisLine	int
=	O
undo	pointer
->	O
lineStart	int
;	O
selectedLine	int
=	O
0	int
;	O
selectedChar	int
=	O
undo	pointer
->	O
charStart	int
;	O
_do_paste	function
(	O
undo	pointer
->	O
text	pointer
,	O
undo	pointer
->	O
lineCount	int
,	O
0	int
)	O
;	O
}	O
}	O
fixViewPostUndo	function
(	O
undo	pointer
->	O
lineStart	int
)	O
;	O
firstRedo	pointer
=	O
undo	pointer
;	O
lastUndo	pointer
=	O
undo	pointer
->	O
prev	pointer
;	O
calcCharCarry	function
(	O
undo	pointer
->	O
lineStart	int
)	O
;	O
refreshView	function
(	O
)	O
;	O
return	O
;	O
memerr	O
:	O
msgBox	function
(	O
"Insufficient memory"	pointer
,	O
OK	int
,	O
ERROR	int
)	O
;	O
}	O
void	O
editMenu_Redo	function
(	O
)	O
{	O
struct	O
undostruct	struct
*	O
undo	pointer
=	O
firstRedo	pointer
;	O
if	O
(	O
undo	pointer
==	O
NULL	O
)	O
return	O
;	O
int	O
first	int
=	O
undo	pointer
->	O
lineStart	int
;	O
int	O
i	int
=	O
undo	pointer
->	O
rbyteCount	int
;	O
int	O
j	int
=	O
undo	pointer
->	O
byteCount	int
;	O
int	O
k	int
,	O
l	int
;	O
if	O
(	O
undo	pointer
->	O
type	enum
==	O
UNDO_ACTION_REPLACE	int
)	O
{	O
k	int
=	O
charsToBytes	function
(	O
first	int
,	O
undo	pointer
->	O
charStart	int
)	O
;	O
if	O
(	O
undo	pointer
->	O
lineCount	int
==	O
0	int
)	O
{	O
if	O
(	O
i	int
>	O
j	int
)	O
{	O
l	int
=	O
i	int
-	O
j	int
;	O
if	O
(	O
!	O
extendLineText	function
(	O
first	int
,	O
lines	array
[	O
first	int
]	O
->	O
byteCount	int
+	O
l	int
)	O
)	O
goto	O
memerr	O
;	O
copyInLine	function
(	O
first	int
,	O
k	int
+	O
i	int
,	O
k	int
+	O
j	int
,	O
0	int
)	O
;	O
memcpy	function
(	O
lines	array
[	O
first	int
]	O
->	O
text	pointer
+	O
k	int
,	O
undo	pointer
->	O
rtext	pointer
,	O
i	int
)	O
;	O
}	O
else	O
if	O
(	O
i	int
<	O
j	int
)	O
{	O
memcpy	function
(	O
lines	array
[	O
first	int
]	O
->	O
text	pointer
+	O
k	int
,	O
undo	pointer
->	O
rtext	pointer
,	O
i	int
)	O
;	O
copyInLine	function
(	O
first	int
,	O
k	int
+	O
i	int
,	O
k	int
+	O
j	int
,	O
0	int
)	O
;	O
}	O
else	O
{	O
memcpy	function
(	O
lines	array
[	O
first	int
]	O
->	O
text	pointer
+	O
k	int
,	O
undo	pointer
->	O
rtext	pointer
,	O
i	int
)	O
;	O
}	O
selectedChar	int
=	O
undo	pointer
->	O
charStart	int
;	O
checkLineBounds	function
(	O
first	int
)	O
;	O
calcCharCarry	function
(	O
first	int
)	O
;	O
}	O
else	O
{	O
char	O
*	O
s	pointer
=	O
strrchr	function
(	O
undo	pointer
->	O
text	pointer
,	O
'\n'	O
)	O
;	O
if	O
(	O
!	O
s	pointer
)	O
return	O
;	O
k	int
+=	O
strlen	function
(	O
s	pointer
)	O
;	O
if	O
(	O
!	O
extendLineText	function
(	O
first	int
,	O
k	int
+	O
1	int
)	O
)	O
goto	O
memerr	O
;	O
strcat	function
(	O
lines	array
[	O
first	int
]	O
->	O
text	pointer
,	O
s	pointer
+	O
1	int
)	O
;	O
lines	array
[	O
first	int
]	O
->	O
linkedToNext	int
=	O
lines	array
[	O
first	int
+	O
undo	pointer
->	O
lineCount	int
]	O
->	O
linkedToNext	int
;	O
move_lines_upd	function
(	O
first	int
+	O
1	int
,	O
undo	pointer
->	O
lineCount	int
)	O
;	O
checkLineBounds	function
(	O
first	int
)	O
;	O
firstVisLine	int
=	O
undo	pointer
->	O
lineStart	int
;	O
selectedLine	int
=	O
0	int
;	O
selectedChar	int
=	O
undo	pointer
->	O
charStart	int
;	O
_do_paste	function
(	O
undo	pointer
->	O
rtext	pointer
,	O
undo	pointer
->	O
lineCount	int
,	O
0	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
undo	pointer
->	O
type	enum
==	O
UNDO_ACTION_INSERT	int
)	O
{	O
if	O
(	O
undo	pointer
->	O
lineCount	int
==	O
0	int
)	O
{	O
k	int
=	O
lines	array
[	O
first	int
]	O
->	O
byteCount	int
+	O
j	int
;	O
if	O
(	O
!	O
extendLineText	function
(	O
first	int
,	O
k	int
)	O
)	O
goto	O
memerr	O
;	O
i	int
=	O
charsToBytes	function
(	O
first	int
,	O
undo	pointer
->	O
charStart	int
)	O
;	O
copyInLine	function
(	O
first	int
,	O
undo	pointer
->	O
charStart	int
+	O
j	int
,	O
undo	pointer
->	O
charStart	int
,	O
0	int
)	O
;	O
memcpy	function
(	O
lines	array
[	O
first	int
]	O
->	O
text	pointer
+	O
i	int
,	O
undo	pointer
->	O
text	pointer
,	O
j	int
)	O
;	O
selectedChar	int
=	O
undo	pointer
->	O
charStart	int
;	O
checkLineBounds	function
(	O
first	int
)	O
;	O
calcCharCarry	function
(	O
first	int
)	O
;	O
}	O
else	O
{	O
firstVisLine	int
=	O
undo	pointer
->	O
lineStart	int
;	O
selectedLine	int
=	O
0	int
;	O
selectedChar	int
=	O
undo	pointer
->	O
charStart	int
;	O
_do_paste	function
(	O
undo	pointer
->	O
rtext	pointer
,	O
undo	pointer
->	O
lineCount	int
,	O
0	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
undo	pointer
->	O
type	enum
==	O
UNDO_ACTION_DELETE	int
)	O
{	O
sel_range_start	struct
.	O
nline	int
=	O
undo	pointer
->	O
lineStart	int
;	O
sel_range_end	struct
.	O
nline	int
=	O
undo	pointer
->	O
lineStart	int
+	O
undo	pointer
->	O
lineCount	int
;	O
sel_range_start	struct
.	O
nchar	int
=	O
undo	pointer
->	O
charStart	int
;	O
char	O
*	O
s	pointer
=	O
strrchr	function
(	O
undo	pointer
->	O
text	pointer
,	O
'\n'	O
)	O
;	O
if	O
(	O
!	O
s	pointer
)	O
s	pointer
=	O
undo	pointer
->	O
text	pointer
-	O
1	int
;	O
i	int
=	O
utfstrlen	function
(	O
s	pointer
+	O
1	int
)	O
;	O
sel_range_end	struct
.	O
nchar	int
=	O
i	int
;	O
if	O
(	O
sel_range_start	struct
.	O
nline	int
==	O
sel_range_end	struct
.	O
nline	int
)	O
sel_range_end	struct
.	O
nchar	int
+=	O
undo	pointer
->	O
charStart	int
;	O
remove_selected_text	function
(	O
0	int
)	O
;	O
}	O
fixViewPostUndo	function
(	O
undo	pointer
->	O
lineStart	int
)	O
;	O
firstRedo	pointer
=	O
undo	pointer
->	O
next	pointer
;	O
lastUndo	pointer
=	O
undo	pointer
;	O
calcCharCarry	function
(	O
undo	pointer
->	O
lineStart	int
)	O
;	O
refreshView	function
(	O
)	O
;	O
return	O
;	O
memerr	O
:	O
msgBox	function
(	O
"Insufficient memory"	pointer
,	O
OK	int
,	O
ERROR	int
)	O
;	O
}	O
void	O
editMenu_Find	function
(	O
)	O
{	O
char	O
*	O
f	pointer
=	O
getUserInput	function
(	O
"Enter text to find:  "	pointer
,	O
" Find "	pointer
)	O
;	O
if	O
(	O
!	O
f	pointer
)	O
{	O
refreshView	function
(	O
)	O
;	O
return	O
;	O
}	O
int	O
i	int
;	O
_find	function
(	O
f	pointer
)	O
;	O
if	O
(	O
!	O
total_find_results	int
)	O
{	O
free	function
(	O
f	pointer
)	O
;	O
msgBox	function
(	O
"No matches were found."	pointer
,	O
OK	int
,	O
INFO	int
)	O
;	O
refreshView	function
(	O
)	O
;	O
return	O
;	O
}	O
i	int
=	O
0	int
;	O
char	O
*	O
c	char
;	O
while	O
(	O
1	int
)	O
{	O
int	O
x	int
=	O
find_result_pos	array
[	O
i	int
]	O
.	O
nline	int
-	O
firstVisLine	int
;	O
if	O
(	O
x	int
<	O
0	int
)	O
{	O
firstVisLine	int
+=	O
x	int
;	O
selectedLine	int
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
x	int
>=	O
totalVisLines	int
)	O
{	O
x	int
-=	O
totalVisLines	int
;	O
firstVisLine	int
+=	O
(	O
x	int
+	O
1	int
)	O
;	O
selectedLine	int
=	O
totalVisLines	int
-	O
1	int
;	O
}	O
else	O
selectedLine	int
=	O
x	int
;	O
}	O
selectedChar	int
=	O
find_result_pos	array
[	O
i	int
]	O
.	O
nchar	int
;	O
calcCharCarry	function
(	O
find_result_pos	array
[	O
i	int
]	O
.	O
nline	int
)	O
;	O
refreshView	function
(	O
)	O
;	O
setScreenColorsI	function
(	O
COLOR_STATUS_BAR	int
)	O
;	O
if	O
(	O
GNU_DOS_LEVEL	int
>	O
2	int
)	O
fprintf	function
(	O
stdout	pointer
,	O
"\e[%d;1HFind(%d/%d): [C-p] Prev [C-n] Next [C-g] Cancel"	pointer
,	O
SCREEN_H	int
,	O
i	int
+	O
1	int
,	O
total_find_results	int
)	O
;	O
else	O
if	O
(	O
GNU_DOS_LEVEL	int
>	O
1	int
)	O
fprintf	function
(	O
stdout	pointer
,	O
"\e[%d;1HFind(%d/%d): [C-p] Prev [C-n] Next [ESC] Cancel"	pointer
,	O
SCREEN_H	int
,	O
i	int
+	O
1	int
,	O
total_find_results	int
)	O
;	O
else	O
fprintf	function
(	O
stdout	pointer
,	O
"\e[%d;1HFind(%d/%d): [Up] Prev [Down] Next [ESC] Cancel"	pointer
,	O
SCREEN_H	int
,	O
i	int
+	O
1	int
,	O
total_find_results	int
)	O
;	O
fprintf	function
(	O
stdout	pointer
,	O
"\e[%d;%dH"	pointer
,	O
selectedLine	int
+	O
3	int
,	O
selectedChar	int
+	O
2	int
+	O
selectedCharCarry	int
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
get_key	O
:	O
c	char
=	O
getKey	function
(	O
)	O
;	O
switch	O
(	O
c	char
[	O
0	int
]	O
)	O
{	O
case	O
(	O
'p'	O
)	O
:	O
if	O
(	O
GNU_DOS_LEVEL	int
<	O
2	int
)	O
break	O
;	O
if	O
(	O
!	O
CTRL	int
)	O
break	O
;	O
goto	O
do_up	O
;	O
case	O
(	O
UP_KEY	int
)	O
:	O
if	O
(	O
GNU_DOS_LEVEL	int
>	O
1	int
)	O
break	O
;	O
do_up	O
:	O
if	O
(	O
i	int
<=	O
0	int
)	O
i	int
=	O
total_find_results	int
-	O
1	int
;	O
else	O
i	int
--	O
;	O
break	O
;	O
case	O
(	O
'n'	O
)	O
:	O
if	O
(	O
GNU_DOS_LEVEL	int
<	O
2	int
)	O
break	O
;	O
if	O
(	O
!	O
CTRL	int
)	O
break	O
;	O
goto	O
do_down	O
;	O
case	O
(	O
DOWN_KEY	int
)	O
:	O
if	O
(	O
GNU_DOS_LEVEL	int
>	O
1	int
)	O
break	O
;	O
do_down	O
:	O
case	O
(	O
ENTER_KEY	int
)	O
:	O
case	O
(	O
SPACE_KEY	int
)	O
:	O
if	O
(	O
i	int
>=	O
total_find_results	int
-	O
1	int
)	O
i	int
=	O
0	int
;	O
else	O
i	int
++	O
;	O
break	O
;	O
case	O
(	O
'g'	O
)	O
:	O
if	O
(	O
GNU_DOS_LEVEL	int
<	O
3	int
)	O
break	O
;	O
if	O
(	O
!	O
CTRL	int
)	O
break	O
;	O
goto	O
do_esc	O
;	O
case	O
(	O
ESC_KEY	int
)	O
:	O
if	O
(	O
GNU_DOS_LEVEL	int
>	O
2	int
)	O
break	O
;	O
do_esc	O
:	O
refreshView	function
(	O
)	O
;	O
free	function
(	O
f	pointer
)	O
;	O
return	O
;	O
default	O
:	O
goto	O
get_key	O
;	O
break	O
;	O
}	O
}	O
return	O
;	O
}	O
void	O
editMenu_Replace	function
(	O
)	O
{	O
char	O
*	O
f	pointer
=	O
getUserInput	function
(	O
"Enter text to find:  "	pointer
,	O
" Find "	pointer
)	O
;	O
if	O
(	O
!	O
f	pointer
)	O
{	O
refreshView	function
(	O
)	O
;	O
return	O
;	O
}	O
char	O
*	O
r	pointer
=	O
getUserInput	function
(	O
"Enter replacement text: "	pointer
,	O
" Replace "	pointer
)	O
;	O
if	O
(	O
!	O
r	pointer
)	O
{	O
free	function
(	O
f	pointer
)	O
;	O
refreshView	function
(	O
)	O
;	O
return	O
;	O
}	O
int	O
i	int
;	O
_find	function
(	O
f	pointer
)	O
;	O
if	O
(	O
!	O
total_find_results	int
)	O
{	O
free	function
(	O
f	pointer
)	O
;	O
free	function
(	O
r	pointer
)	O
;	O
msgBox	function
(	O
"No matches were found."	pointer
,	O
OK	int
,	O
INFO	int
)	O
;	O
refreshView	function
(	O
)	O
;	O
return	O
;	O
}	O
i	int
=	O
0	int
;	O
char	O
*	O
c	char
;	O
while	O
(	O
1	int
)	O
{	O
int	O
x	int
=	O
find_result_pos	array
[	O
i	int
]	O
.	O
nline	int
-	O
firstVisLine	int
;	O
if	O
(	O
x	int
<	O
0	int
)	O
{	O
firstVisLine	int
+=	O
x	int
;	O
selectedLine	int
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
x	int
>=	O
totalVisLines	int
)	O
{	O
x	int
-=	O
totalVisLines	int
;	O
firstVisLine	int
+=	O
(	O
x	int
+	O
1	int
)	O
;	O
selectedLine	int
=	O
totalVisLines	int
-	O
1	int
;	O
}	O
else	O
selectedLine	int
=	O
x	int
;	O
}	O
selectedChar	int
=	O
find_result_pos	array
[	O
i	int
]	O
.	O
nchar	int
;	O
calcCharCarry	function
(	O
find_result_pos	array
[	O
i	int
]	O
.	O
nline	int
)	O
;	O
refreshView	function
(	O
)	O
;	O
setScreenColorsI	function
(	O
COLOR_STATUS_BAR	int
)	O
;	O
if	O
(	O
GNU_DOS_LEVEL	int
>	O
2	int
)	O
fprintf	function
(	O
stdout	pointer
,	O
"\e[%d;1HFind(%d/%d): [ENTER] Replace [A] Replace All [C-g] Cancel"	pointer
,	O
SCREEN_H	int
,	O
i	int
+	O
1	int
,	O
total_find_results	int
)	O
;	O
else	O
fprintf	function
(	O
stdout	pointer
,	O
"\e[%d;1HFind(%d/%d): [ENTER] Replace [A] Replace All [ESC] Cancel"	pointer
,	O
SCREEN_H	int
,	O
i	int
+	O
1	int
,	O
total_find_results	int
)	O
;	O
fprintf	function
(	O
stdout	pointer
,	O
"\e[%d;%dH"	pointer
,	O
selectedLine	int
+	O
3	int
,	O
selectedChar	int
+	O
2	int
+	O
selectedCharCarry	int
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
get_key	O
:	O
c	char
=	O
getKey	function
(	O
)	O
;	O
switch	O
(	O
c	char
[	O
0	int
]	O
)	O
{	O
case	O
(	O
'p'	O
)	O
:	O
if	O
(	O
GNU_DOS_LEVEL	int
<	O
2	int
)	O
break	O
;	O
if	O
(	O
!	O
CTRL	int
)	O
break	O
;	O
goto	O
do_up	O
;	O
case	O
(	O
UP_KEY	int
)	O
:	O
if	O
(	O
GNU_DOS_LEVEL	int
>	O
1	int
)	O
break	O
;	O
do_up	O
:	O
if	O
(	O
i	int
<=	O
0	int
)	O
i	int
=	O
total_find_results	int
-	O
1	int
;	O
else	O
i	int
--	O
;	O
break	O
;	O
case	O
(	O
'n'	O
)	O
:	O
if	O
(	O
GNU_DOS_LEVEL	int
<	O
2	int
)	O
break	O
;	O
if	O
(	O
!	O
CTRL	int
)	O
break	O
;	O
goto	O
do_down	O
;	O
case	O
(	O
DOWN_KEY	int
)	O
:	O
if	O
(	O
GNU_DOS_LEVEL	int
>	O
1	int
)	O
break	O
;	O
do_down	O
:	O
if	O
(	O
i	int
>=	O
total_find_results	int
-	O
1	int
)	O
i	int
=	O
0	int
;	O
else	O
i	int
++	O
;	O
break	O
;	O
case	O
(	O
'g'	O
)	O
:	O
if	O
(	O
GNU_DOS_LEVEL	int
<	O
3	int
)	O
break	O
;	O
if	O
(	O
!	O
CTRL	int
)	O
break	O
;	O
goto	O
do_esc	O
;	O
case	O
(	O
ESC_KEY	int
)	O
:	O
if	O
(	O
GNU_DOS_LEVEL	int
>	O
2	int
)	O
break	O
;	O
do_esc	O
:	O
goto	O
finish	O
;	O
break	O
;	O
case	O
(	O
SPACE_KEY	int
)	O
:	O
case	O
(	O
ENTER_KEY	int
)	O
:	O
_replace	function
(	O
i	int
,	O
f	pointer
,	O
r	pointer
)	O
;	O
if	O
(	O
i	int
>=	O
total_find_results	int
)	O
i	int
--	O
;	O
if	O
(	O
total_find_results	int
<=	O
0	int
)	O
goto	O
finish	O
;	O
break	O
;	O
case	O
(	O
'a'	O
)	O
:	O
_replace	function
(	O
-	O
1	int
,	O
f	pointer
,	O
r	pointer
)	O
;	O
total_find_results	int
=	O
0	int
;	O
goto	O
finish	O
;	O
break	O
;	O
default	O
:	O
goto	O
get_key	O
;	O
break	O
;	O
}	O
}	O
finish	O
:	O
free	function
(	O
f	pointer
)	O
;	O
free	function
(	O
r	pointer
)	O
;	O
refreshView	function
(	O
)	O
;	O
return	O
;	O
}	O
void	O
_replace	function
(	O
int	O
pos	int
,	O
char	O
*	O
f	pointer
,	O
char	O
*	O
r	pointer
)	O
{	O
int	O
i	int
=	O
strlen	function
(	O
f	pointer
)	O
;	O
int	O
j	int
=	O
strlen	function
(	O
r	pointer
)	O
;	O
int	O
old_firstVisLine	int
=	O
firstVisLine	int
;	O
int	O
old_selectedLine	int
=	O
selectedLine	int
;	O
int	O
old_selectedChar	int
=	O
selectedChar	int
;	O
int	O
old_selectedCharCarry	int
=	O
selectedCharCarry	int
;	O
if	O
(	O
pos	int
>=	O
0	int
)	O
{	O
_do_replace	function
(	O
pos	int
,	O
f	pointer
,	O
r	pointer
)	O
;	O
FILE_STATE	enum
=	O
MODIFIED	int
;	O
}	O
else	O
{	O
if	O
(	O
i	int
==	O
j	int
)	O
{	O
for	O
(	O
pos	int
=	O
0	int
;	O
pos	int
<	O
total_find_results	int
;	O
pos	int
++	O
)	O
{	O
_do_replace	function
(	O
pos	int
,	O
f	pointer
,	O
r	pointer
)	O
;	O
}	O
}	O
else	O
{	O
while	O
(	O
total_find_results	int
)	O
{	O
_do_replace	function
(	O
0	int
,	O
f	pointer
,	O
r	pointer
)	O
;	O
}	O
}	O
}	O
firstVisLine	int
=	O
old_firstVisLine	int
;	O
selectedLine	int
=	O
old_selectedLine	int
;	O
selectedChar	int
=	O
old_selectedChar	int
;	O
selectedCharCarry	int
=	O
old_selectedCharCarry	int
;	O
}	O
void	O
_find	function
(	O
char	O
*	O
f	pointer
)	O
{	O
int	O
i	int
,	O
k	int
=	O
0	int
;	O
char	O
*	O
j	int
;	O
int	O
flen	int
=	O
strlen	function
(	O
f	pointer
)	O
;	O
total_find_results	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
totalLines	int
;	O
i	int
++	O
)	O
{	O
char	O
*	O
line	pointer
=	O
lines	array
[	O
i	int
]	O
->	O
text	pointer
;	O
while	O
(	O
(	O
j	int
=	O
strcasestr	function
(	O
line	pointer
,	O
f	pointer
)	O
)	O
)	O
{	O
find_result_pos	array
[	O
k	int
]	O
.	O
nline	int
=	O
i	int
;	O
find_result_pos	array
[	O
k	int
++	O
]	O
.	O
nchar	int
=	O
(	O
j	int
-	O
lines	array
[	O
i	int
]	O
->	O
text	pointer
)	O
;	O
total_find_results	int
++	O
;	O
line	pointer
=	O
j	int
+	O
flen	int
;	O
}	O
}	O
}	O
void	O
_do_replace	function
(	O
int	O
pos	int
,	O
char	O
*	O
f	pointer
,	O
char	O
*	O
r	pointer
)	O
{	O
int	O
i	int
=	O
strlen	function
(	O
f	pointer
)	O
;	O
int	O
j	int
=	O
strlen	function
(	O
r	pointer
)	O
;	O
int	O
k	int
,	O
l	int
,	O
n	int
,	O
m	int
;	O
k	int
=	O
find_result_pos	array
[	O
pos	int
]	O
.	O
nchar	int
;	O
l	int
=	O
find_result_pos	array
[	O
pos	int
]	O
.	O
nline	int
;	O
n	int
=	O
0	int
;	O
firstVisLine	int
=	O
l	int
;	O
selectedLine	int
=	O
0	int
;	O
selectedChar	int
=	O
k	int
;	O
k	int
=	O
charsToBytes	function
(	O
l	int
,	O
selectedChar	int
)	O
;	O
char	O
*	O
f2	pointer
=	O
f	pointer
;	O
while	O
(	O
*	O
f2	pointer
)	O
{	O
undoAddChar	function
(	O
UNDO_ACTION_REPLACE	int
,	O
l	int
,	O
k	int
,	O
*	O
f2	pointer
)	O
;	O
while	O
(	O
++	O
k	int
,	O
(	O
*	O
(	O
++	O
f2	pointer
)	O
&	O
0xc0	int
)	O
==	O
0x80	int
)	O
undoAddChar	function
(	O
UNDO_ACTION_REPLACE	int
,	O
l	int
,	O
k	int
,	O
*	O
f2	pointer
)	O
;	O
}	O
k	int
=	O
charsToBytes	function
(	O
l	int
,	O
selectedChar	int
)	O
;	O
f2	pointer
=	O
r	pointer
;	O
char	O
c	char
;	O
while	O
(	O
(	O
c	char
=	O
*	O
f2	pointer
++	O
)	O
)	O
undoBufRep	array
[	O
undoBufRepIndex	int
++	O
]	O
=	O
c	char
;	O
if	O
(	O
i	int
==	O
j	int
)	O
{	O
memcpy	function
(	O
lines	array
[	O
l	int
]	O
->	O
text	pointer
+	O
k	int
,	O
r	pointer
,	O
j	int
)	O
;	O
}	O
else	O
if	O
(	O
i	int
>	O
j	int
)	O
{	O
memcpy	function
(	O
lines	array
[	O
l	int
]	O
->	O
text	pointer
+	O
k	int
,	O
r	pointer
,	O
j	int
)	O
;	O
copyInLine	function
(	O
l	int
,	O
k	int
+	O
j	int
,	O
k	int
+	O
i	int
,	O
0	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
extendLineText	function
(	O
l	int
,	O
lines	array
[	O
l	int
]	O
->	O
byteCount	int
+	O
j	int
-	O
i	int
+	O
1	int
)	O
)	O
{	O
msgBox	function
(	O
"Insufficient memory!"	pointer
,	O
OK	int
,	O
ERROR	int
)	O
;	O
return	O
;	O
}	O
copyInLine	function
(	O
l	int
,	O
k	int
+	O
j	int
,	O
k	int
+	O
i	int
,	O
0	int
)	O
;	O
memcpy	function
(	O
lines	array
[	O
l	int
]	O
->	O
text	pointer
+	O
k	int
,	O
r	pointer
,	O
j	int
)	O
;	O
}	O
FILE_STATE	enum
=	O
MODIFIED	int
;	O
checkLineBounds	function
(	O
l	int
)	O
;	O
_find	function
(	O
f	pointer
)	O
;	O
}	O
void	O
calcTotalCharsInLineC	function
(	O
int	O
pos	int
,	O
int	O
*	O
carry	pointer
)	O
{	O
int	O
totalCharsInLine	int
=	O
0	int
;	O
*	O
carry	pointer
=	O
0	int
;	O
int	O
k	int
;	O
char	O
*	O
c	char
=	O
lines	array
[	O
pos	int
]	O
->	O
text	pointer
;	O
while	O
(	O
*	O
c	char
)	O
{	O
if	O
(	O
(	O
*	O
c	char
&	O
0xc0	int
)	O
==	O
0x80	int
)	O
continue	O
;	O
if	O
(	O
*	O
c	char
==	O
'\r'	O
||	O
*	O
c	char
==	O
'\n'	O
||	O
*	O
c	char
==	O
'\0'	O
)	O
break	O
;	O
if	O
(	O
*	O
c	char
==	O
'\t'	O
)	O
{	O
k	int
=	O
TABSPACES	O
(	O
totalCharsInLine	int
+	O
(	O
*	O
carry	pointer
)	O
+	O
1	int
)	O
;	O
(	O
*	O
carry	pointer
)	O
+=	O
k	int
;	O
}	O
totalCharsInLine	int
++	O
;	O
c	char
++	O
;	O
}	O
lines	array
[	O
pos	int
]	O
->	O
charCount	int
=	O
totalCharsInLine	int
;	O
lines	array
[	O
pos	int
]	O
->	O
byteCount	int
=	O
c	char
-	O
lines	array
[	O
pos	int
]	O
->	O
text	pointer
;	O
}	O
void	O
calcTotalCharsInLine	function
(	O
int	O
pos	int
)	O
{	O
int	O
carry	pointer
=	O
0	int
;	O
calcTotalCharsInLineC	function
(	O
pos	int
,	O
&	O
carry	pointer
)	O
;	O
}	O
int	O
utfstrlen	function
(	O
char	O
*	O
str	pointer
)	O
{	O
char	O
c	char
;	O
int	O
count	int
=	O
0	int
;	O
while	O
(	O
(	O
c	char
=	O
*	O
str	pointer
++	O
)	O
)	O
{	O
if	O
(	O
(	O
c	char
&	O
0xc0	int
)	O
!=	O
0x80	int
)	O
count	int
++	O
;	O
}	O
return	O
count	int
;	O
}	O
