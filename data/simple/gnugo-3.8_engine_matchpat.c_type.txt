void	O
prepare_pattern_profiling	function
(	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Warning, no support for pattern profiling in this binary.\n"	pointer
)	O
;	O
}	O
void	O
report_pattern_profiling	function
(	O
)	O
{	O
}	O
static	O
void	O
fixup_patterns_for_board_size	function
(	O
struct	O
pattern	pointer
*	O
pattern	pointer
)	O
;	O
static	O
void	O
prepare_for_match	function
(	O
int	O
color	int
)	O
;	O
static	O
void	O
do_matchpat	function
(	O
int	O
anchor	int
,	O
matchpat_callback_fn_ptr	pointer
callback	pointer
,	O
int	O
color	int
,	O
struct	O
pattern	pointer
*	O
database	pointer
,	O
void	O
*	O
callback_data	pointer
,	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
)	O
;	O
static	O
void	O
matchpat_loop	function
(	O
matchpat_callback_fn_ptr	pointer
callback	pointer
,	O
int	O
color	int
,	O
int	O
anchor	int
,	O
struct	O
pattern_db	struct
*	O
pdb	pointer
,	O
void	O
*	O
callback_data	pointer
,	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
,	O
int	O
anchor_in_goal	int
)	O
;	O
static	O
const	O
int	O
and_mask	array
[	O
2	int
]	O
[	O
8	int
]	O
=	O
{	O
{	O
3	int
,	O
3	int
,	O
3	int
,	O
WHITE	int
,	O
BLACK	int
,	O
3	int
,	O
3	int
,	O
3	int
}	O
,	O
{	O
3	int
,	O
3	int
,	O
3	int
,	O
BLACK	int
,	O
WHITE	int
,	O
3	int
,	O
3	int
,	O
3	int
}	O
}	O
;	O
static	O
const	O
int	O
val_mask	array
[	O
2	int
]	O
[	O
8	int
]	O
=	O
{	O
{	O
EMPTY	int
,	O
BLACK	int
,	O
WHITE	int
,	O
0	int
,	O
0	int
,	O
EMPTY	int
,	O
EMPTY	int
,	O
EMPTY	int
}	O
,	O
{	O
EMPTY	int
,	O
WHITE	int
,	O
BLACK	int
,	O
0	int
,	O
0	int
,	O
EMPTY	int
,	O
EMPTY	int
,	O
EMPTY	int
}	O
}	O
;	O
static	O
unsigned	O
int	O
class_mask	array
[	O
NUM_DRAGON_STATUS	int
]	O
[	O
3	int
]	O
;	O
static	O
void	O
fixup_patterns_for_board_size	function
(	O
struct	O
pattern	pointer
*	O
pattern	pointer
)	O
{	O
for	O
(	O
;	O
pattern	pointer
->	O
patn	pointer
;	O
++	O
pattern	pointer
)	O
if	O
(	O
pattern	pointer
->	O
edge_constraints	int
!=	O
0	int
)	O
{	O
if	O
(	O
pattern	pointer
->	O
edge_constraints	int
&	O
NORTH_EDGE	int
)	O
pattern	pointer
->	O
maxi	int
=	O
pattern	pointer
->	O
mini	int
+	O
pattern	pointer
->	O
height	int
;	O
if	O
(	O
pattern	pointer
->	O
edge_constraints	int
&	O
SOUTH_EDGE	int
)	O
pattern	pointer
->	O
mini	int
=	O
pattern	pointer
->	O
maxi	int
-	O
pattern	pointer
->	O
height	int
;	O
if	O
(	O
pattern	pointer
->	O
edge_constraints	int
&	O
WEST_EDGE	int
)	O
pattern	pointer
->	O
maxj	int
=	O
pattern	pointer
->	O
minj	int
+	O
pattern	pointer
->	O
width	long
;	O
if	O
(	O
pattern	pointer
->	O
edge_constraints	int
&	O
EAST_EDGE	int
)	O
pattern	pointer
->	O
minj	int
=	O
pattern	pointer
->	O
maxj	int
-	O
pattern	pointer
->	O
width	long
;	O
if	O
(	O
pattern	pointer
->	O
edge_constraints	int
&	O
NORTH_EDGE	int
)	O
if	O
(	O
pattern	pointer
->	O
maxi	int
<	O
(	O
board_size	int
-	O
1	int
)	O
+	O
pattern	pointer
->	O
mini	int
)	O
pattern	pointer
->	O
maxi	int
=	O
(	O
board_size	int
-	O
1	int
)	O
+	O
pattern	pointer
->	O
mini	int
;	O
if	O
(	O
pattern	pointer
->	O
edge_constraints	int
&	O
SOUTH_EDGE	int
)	O
if	O
(	O
pattern	pointer
->	O
mini	int
>	O
pattern	pointer
->	O
maxi	int
-	O
(	O
board_size	int
-	O
1	int
)	O
)	O
pattern	pointer
->	O
mini	int
=	O
pattern	pointer
->	O
maxi	int
-	O
(	O
board_size	int
-	O
1	int
)	O
;	O
if	O
(	O
pattern	pointer
->	O
edge_constraints	int
&	O
WEST_EDGE	int
)	O
if	O
(	O
pattern	pointer
->	O
maxj	int
<	O
(	O
board_size	int
-	O
1	int
)	O
+	O
pattern	pointer
->	O
minj	int
)	O
pattern	pointer
->	O
maxj	int
=	O
(	O
board_size	int
-	O
1	int
)	O
+	O
pattern	pointer
->	O
minj	int
;	O
if	O
(	O
pattern	pointer
->	O
edge_constraints	int
&	O
EAST_EDGE	int
)	O
if	O
(	O
pattern	pointer
->	O
minj	int
>	O
pattern	pointer
->	O
maxj	int
-	O
(	O
board_size	int
-	O
1	int
)	O
)	O
pattern	pointer
->	O
minj	int
=	O
pattern	pointer
->	O
maxj	int
-	O
(	O
board_size	int
-	O
1	int
)	O
;	O
}	O
}	O
static	O
void	O
prepare_for_match	function
(	O
int	O
color	int
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
gg_assert	O
(	O
color	int
!=	O
EMPTY	int
)	O
;	O
class_mask	array
[	O
DEAD	int
]	O
[	O
color	int
]	O
=	O
CLASS_O	int
;	O
class_mask	array
[	O
DEAD	int
]	O
[	O
other	int
]	O
=	O
CLASS_X	int
;	O
class_mask	array
[	O
CRITICAL	int
]	O
[	O
color	int
]	O
=	O
CLASS_O	int
;	O
class_mask	array
[	O
CRITICAL	int
]	O
[	O
other	int
]	O
=	O
0	int
;	O
class_mask	array
[	O
ALIVE	int
]	O
[	O
color	int
]	O
=	O
CLASS_o	int
;	O
class_mask	array
[	O
ALIVE	int
]	O
[	O
other	int
]	O
=	O
CLASS_x	int
;	O
}	O
static	O
void	O
do_matchpat	function
(	O
int	O
anchor	int
,	O
matchpat_callback_fn_ptr	pointer
callback	pointer
,	O
int	O
color	int
,	O
struct	O
pattern	pointer
*	O
pattern	pointer
,	O
void	O
*	O
callback_data	pointer
,	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
)	O
{	O
const	O
int	O
anchor_test	int
=	O
board	pointer
[	O
anchor	int
]	O
^	O
color	int
;	O
int	O
m	int
=	O
I	O
(	O
anchor	int
)	O
;	O
int	O
n	int
=	O
J	O
(	O
anchor	int
)	O
;	O
int	O
merged_val	int
;	O
ASSERT_ON_BOARD1	O
(	O
anchor	int
)	O
;	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
shift	int
=	O
30	int
;	O
merged_val	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
m	int
-	O
1	int
;	O
i	int
<=	O
m	int
+	O
2	int
;	O
++	O
i	int
)	O
for	O
(	O
j	int
=	O
n	int
-	O
1	int
;	O
j	int
<=	O
n	int
+	O
2	int
;	O
shift	int
-=	O
2	int
,	O
++	O
j	int
)	O
{	O
unsigned	O
int	O
this	int
;	O
if	O
(	O
!	O
ON_BOARD2	O
(	O
i	int
,	O
j	int
)	O
)	O
this	int
=	O
3	int
;	O
else	O
if	O
(	O
(	O
this	int
=	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
)	O
==	O
0	int
)	O
continue	O
;	O
else	O
if	O
(	O
color	int
==	O
2	int
)	O
this	int
=	O
OTHER_COLOR	O
(	O
this	int
)	O
;	O
merged_val	int
|=	O
(	O
this	int
<<	O
shift	int
)	O
;	O
}	O
}	O
gg_assert	O
(	O
pattern	pointer
->	O
patn	pointer
)	O
;	O
do	O
{	O
{	O
int	O
end_transformation	int
;	O
int	O
ll	int
;	O
int	O
k	int
;	O
int	O
found_goal	int
;	O
if	O
(	O
anchor_test	int
!=	O
pattern	pointer
->	O
anchored_at_X	int
)	O
continue	O
;	O
ll	int
=	O
0	int
;	O
end_transformation	int
=	O
pattern	pointer
->	O
trfno	int
;	O
if	O
(	O
pattern	pointer
->	O
trfno	int
==	O
5	int
)	O
{	O
ll	int
=	O
2	int
;	O
end_transformation	int
=	O
6	int
;	O
}	O
do	O
{	O
if	O
(	O
(	O
merged_val	int
&	O
pattern	pointer
->	O
and_mask	array
[	O
ll	int
]	O
)	O
!=	O
pattern	pointer
->	O
val_mask	array
[	O
ll	int
]	O
)	O
continue	O
;	O
{	O
int	O
mi	int
,	O
mj	int
,	O
xi	int
,	O
xj	int
;	O
TRANSFORM2	O
(	O
pattern	pointer
->	O
mini	int
,	O
pattern	pointer
->	O
minj	int
,	O
&	O
mi	int
,	O
&	O
mj	int
,	O
ll	int
)	O
;	O
TRANSFORM2	O
(	O
pattern	pointer
->	O
maxi	int
,	O
pattern	pointer
->	O
maxj	int
,	O
&	O
xi	int
,	O
&	O
xj	int
,	O
ll	int
)	O
;	O
DEBUG	O
(	O
DEBUG_MATCHER	int
,	O
"---\nconsidering pattern '%s', rotation %d at %1m. Range %d,%d -> %d,%d\n"	pointer
,	O
pattern	pointer
->	O
name	short
,	O
ll	int
,	O
anchor	int
,	O
mi	int
,	O
mj	int
,	O
xi	int
,	O
xj	int
)	O
;	O
if	O
(	O
!	O
ON_BOARD2	O
(	O
m	int
+	O
mi	int
,	O
n	int
+	O
mj	int
)	O
||	O
!	O
ON_BOARD2	O
(	O
m	int
+	O
xi	int
,	O
n	int
+	O
xj	int
)	O
)	O
continue	O
;	O
}	O
found_goal	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
pattern	pointer
->	O
patlen	int
;	O
++	O
k	int
)	O
{	O
int	O
pos	int
;	O
int	O
att	char
=	O
pattern	pointer
->	O
patn	pointer
[	O
k	int
]	O
.	O
att	char
;	O
pos	int
=	O
AFFINE_TRANSFORM	O
(	O
pattern	pointer
->	O
patn	pointer
[	O
k	int
]	O
.	O
offset	short
,	O
ll	int
,	O
anchor	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
(	O
board	pointer
[	O
pos	int
]	O
&	O
and_mask	array
[	O
color	int
-	O
1	int
]	O
[	O
att	char
]	O
)	O
!=	O
val_mask	array
[	O
color	int
-	O
1	int
]	O
[	O
att	char
]	O
)	O
goto	O
match_failed	O
;	O
if	O
(	O
goal	pointer
!=	O
NULL	O
&&	O
board	pointer
[	O
pos	int
]	O
!=	O
EMPTY	int
&&	O
goal	pointer
[	O
pos	int
]	O
)	O
found_goal	int
=	O
1	int
;	O
if	O
(	O
(	O
pattern	pointer
->	O
class	int
&	O
class_mask	array
[	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum
]	O
[	O
board	pointer
[	O
pos	int
]	O
]	O
)	O
!=	O
0	int
)	O
goto	O
match_failed	O
;	O
}	O
if	O
(	O
(	O
goal	pointer
!=	O
NULL	O
)	O
&&	O
!	O
found_goal	int
)	O
goto	O
match_failed	O
;	O
callback	pointer
(	O
anchor	int
,	O
color	int
,	O
pattern	pointer
,	O
ll	int
,	O
callback_data	pointer
)	O
;	O
match_failed	O
:	O
DEBUG	O
(	O
DEBUG_MATCHER	int
,	O
"end of pattern '%s', rotation %d at %1m\n---\n"	pointer
,	O
pattern	pointer
->	O
name	short
,	O
ll	int
,	O
anchor	int
)	O
;	O
}	O
while	O
(	O
++	O
ll	int
<	O
end_transformation	int
)	O
;	O
}	O
}	O
while	O
(	O
(	O
++	O
pattern	pointer
)	O
->	O
patn	pointer
)	O
;	O
}	O
static	O
void	O
matchpat_loop	function
(	O
matchpat_callback_fn_ptr	pointer
callback	pointer
,	O
int	O
color	int
,	O
int	O
anchor	int
,	O
struct	O
pattern_db	struct
*	O
pdb	pointer
,	O
void	O
*	O
callback_data	pointer
,	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
,	O
int	O
anchor_in_goal	int
)	O
{	O
int	O
pos	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
anchor	int
&&	O
(	O
!	O
anchor_in_goal	int
||	O
goal	pointer
[	O
pos	int
]	O
!=	O
0	int
)	O
)	O
do_matchpat	function
(	O
pos	int
,	O
callback	pointer
,	O
color	int
,	O
pdb	pointer
->	O
patterns	pointer
,	O
callback_data	pointer
,	O
goal	pointer
)	O
;	O
}	O
}	O
static	O
int	O
dfa_board_size	int
=	O
-	O
1	int
;	O
static	O
int	O
dfa_p	array
[	O
DFA_BASE	O
*	O
DFA_BASE	O
]	O
;	O
static	O
const	O
int	O
convert	array
[	O
3	int
]	O
[	O
4	int
]	O
=	O
{	O
{	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
}	O
,	O
{	O
EMPTY	int
,	O
WHITE	int
,	O
BLACK	int
,	O
OUT_BOARD	int
}	O
,	O
{	O
EMPTY	int
,	O
BLACK	int
,	O
WHITE	int
,	O
OUT_BOARD	int
}	O
}	O
;	O
static	O
void	O
dfa_prepare_for_match	function
(	O
int	O
color	int
)	O
;	O
static	O
int	O
scan_for_patterns	function
(	O
dfa_rt_t	struct
*	O
pdfa	pointer
,	O
int	O
l	int
,	O
int	O
*	O
dfa_pos	pointer
,	O
int	O
*	O
pat_list	pointer
)	O
;	O
static	O
void	O
do_dfa_matchpat	function
(	O
dfa_rt_t	struct
*	O
pdfa	pointer
,	O
int	O
anchor	int
,	O
matchpat_callback_fn_ptr	pointer
callback	pointer
,	O
int	O
color	int
,	O
struct	O
pattern	pointer
*	O
database	pointer
,	O
void	O
*	O
callback_data	pointer
,	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
,	O
int	O
anchor_in_goal	int
)	O
;	O
static	O
void	O
check_pattern_light	function
(	O
int	O
anchor	int
,	O
matchpat_callback_fn_ptr	pointer
callback	pointer
,	O
int	O
color	int
,	O
struct	O
pattern	pointer
*	O
pattern	pointer
,	O
int	O
ll	int
,	O
void	O
*	O
callback_data	pointer
,	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
,	O
int	O
anchor_in_goal	int
)	O
;	O
static	O
void	O
dfa_matchpat_loop	function
(	O
matchpat_callback_fn_ptr	pointer
callback	pointer
,	O
int	O
color	int
,	O
int	O
anchor	int
,	O
struct	O
pattern_db	struct
*	O
pdb	pointer
,	O
void	O
*	O
callback_data	pointer
,	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
,	O
int	O
anchor_in_goal	int
)	O
;	O
void	O
dfa_match_init	function
(	O
void	O
)	O
{	O
build_spiral_order	function
(	O
)	O
;	O
if	O
(	O
owl_vital_apat_db	struct
.	O
pdfa	pointer
!=	O
NULL	O
)	O
DEBUG	O
(	O
DEBUG_MATCHER	int
,	O
"owl_vital_apat --> using dfa\n"	pointer
)	O
;	O
if	O
(	O
owl_attackpat_db	struct
.	O
pdfa	pointer
!=	O
NULL	O
)	O
DEBUG	O
(	O
DEBUG_MATCHER	int
,	O
"owl_attackpat --> using dfa\n"	pointer
)	O
;	O
if	O
(	O
owl_defendpat_db	struct
.	O
pdfa	pointer
!=	O
NULL	O
)	O
DEBUG	O
(	O
DEBUG_MATCHER	int
,	O
"owl_defendpat --> using dfa\n"	pointer
)	O
;	O
if	O
(	O
pat_db	struct
.	O
pdfa	pointer
!=	O
NULL	O
)	O
DEBUG	O
(	O
DEBUG_MATCHER	int
,	O
"pat --> using dfa\n"	pointer
)	O
;	O
if	O
(	O
attpat_db	struct
.	O
pdfa	pointer
!=	O
NULL	O
)	O
DEBUG	O
(	O
DEBUG_MATCHER	int
,	O
"attpat --> using dfa\n"	pointer
)	O
;	O
if	O
(	O
defpat_db	struct
.	O
pdfa	pointer
!=	O
NULL	O
)	O
DEBUG	O
(	O
DEBUG_MATCHER	int
,	O
"defpat --> using dfa\n"	pointer
)	O
;	O
if	O
(	O
endpat_db	struct
.	O
pdfa	pointer
!=	O
NULL	O
)	O
DEBUG	O
(	O
DEBUG_MATCHER	int
,	O
"endpat --> using dfa\n"	pointer
)	O
;	O
if	O
(	O
conn_db	struct
.	O
pdfa	pointer
!=	O
NULL	O
)	O
DEBUG	O
(	O
DEBUG_MATCHER	int
,	O
"conn --> using dfa\n"	pointer
)	O
;	O
if	O
(	O
influencepat_db	struct
.	O
pdfa	pointer
!=	O
NULL	O
)	O
DEBUG	O
(	O
DEBUG_MATCHER	int
,	O
"influencepat --> using dfa\n"	pointer
)	O
;	O
if	O
(	O
barrierspat_db	struct
.	O
pdfa	pointer
!=	O
NULL	O
)	O
DEBUG	O
(	O
DEBUG_MATCHER	int
,	O
"barrierspat --> using dfa\n"	pointer
)	O
;	O
if	O
(	O
fusekipat_db	struct
.	O
pdfa	pointer
!=	O
NULL	O
)	O
DEBUG	O
(	O
DEBUG_MATCHER	int
,	O
"barrierspat --> using dfa\n"	pointer
)	O
;	O
dfa_board_size	int
=	O
-	O
1	int
;	O
}	O
static	O
void	O
dfa_prepare_for_match	function
(	O
int	O
color	int
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
pos	int
;	O
if	O
(	O
dfa_board_size	int
!=	O
board_size	int
)	O
{	O
dfa_board_size	int
=	O
board_size	int
;	O
for	O
(	O
pos	int
=	O
0	int
;	O
pos	int
<	O
DFA_BASE	O
*	O
DFA_BASE	O
;	O
pos	int
++	O
)	O
dfa_p	array
[	O
pos	int
]	O
=	O
OUT_BOARD	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dfa_board_size	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
dfa_board_size	int
;	O
j	int
++	O
)	O
dfa_p	array
[	O
DFA_POS	O
(	O
i	int
,	O
j	int
)	O
]	O
=	O
EXPECTED_COLOR	O
(	O
color	int
,	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
)	O
;	O
prepare_for_match	function
(	O
color	int
)	O
;	O
}	O
static	O
int	O
scan_for_patterns	function
(	O
dfa_rt_t	struct
*	O
pdfa	pointer
,	O
int	O
l	int
,	O
int	O
*	O
dfa_pos	pointer
,	O
int	O
*	O
pat_list	pointer
)	O
{	O
int	O
delta	array
;	O
int	O
state	pointer
=	O
1	int
;	O
int	O
row	int
=	O
0	int
;	O
int	O
id	int
=	O
0	int
;	O
do	O
{	O
int	O
att	char
=	O
pdfa	pointer
->	O
states	pointer
[	O
state	pointer
]	O
.	O
att	char
;	O
while	O
(	O
att	char
!=	O
0	int
)	O
{	O
pat_list	pointer
[	O
id	int
]	O
=	O
pdfa	pointer
->	O
indexes	pointer
[	O
att	char
]	O
.	O
val	long
;	O
id	int
++	O
;	O
att	char
=	O
pdfa	pointer
->	O
indexes	pointer
[	O
att	char
]	O
.	O
next	pointer
;	O
}	O
delta	array
=	O
pdfa	pointer
->	O
states	pointer
[	O
state	pointer
]	O
.	O
next	pointer
[	O
dfa_pos	pointer
[	O
spiral	array
[	O
row	int
]	O
[	O
l	int
]	O
]	O
]	O
;	O
state	pointer
+=	O
delta	array
;	O
row	int
++	O
;	O
}	O
while	O
(	O
delta	array
!=	O
0	int
)	O
;	O
return	O
id	int
;	O
}	O
static	O
void	O
do_dfa_matchpat	function
(	O
dfa_rt_t	struct
*	O
pdfa	pointer
,	O
int	O
anchor	int
,	O
matchpat_callback_fn_ptr	pointer
callback	pointer
,	O
int	O
color	int
,	O
struct	O
pattern	pointer
*	O
database	pointer
,	O
void	O
*	O
callback_data	pointer
,	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
,	O
int	O
anchor_in_goal	int
)	O
{	O
int	O
k	int
;	O
int	O
ll	int
;	O
int	O
patterns	pointer
[	O
DFA_MAX_MATCHED	O
+	O
8	int
]	O
;	O
int	O
num_matched	int
=	O
0	int
;	O
int	O
*	O
dfa_pos	pointer
=	O
dfa_p	array
+	O
DFA_POS	O
(	O
I	O
(	O
anchor	int
)	O
,	O
J	O
(	O
anchor	int
)	O
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
anchor	int
)	O
;	O
for	O
(	O
ll	int
=	O
0	int
;	O
ll	int
<	O
8	int
;	O
ll	int
++	O
)	O
{	O
num_matched	int
+=	O
scan_for_patterns	function
(	O
pdfa	pointer
,	O
ll	int
,	O
dfa_pos	pointer
,	O
patterns	pointer
+	O
num_matched	int
)	O
;	O
patterns	pointer
[	O
num_matched	int
++	O
]	O
=	O
-	O
1	int
;	O
}	O
ASSERT1	O
(	O
num_matched	int
<=	O
DFA_MAX_MATCHED	O
+	O
8	int
,	O
anchor	int
)	O
;	O
for	O
(	O
ll	int
=	O
0	int
,	O
k	int
=	O
0	int
;	O
ll	int
<	O
8	int
;	O
k	int
++	O
)	O
{	O
int	O
matched	int
;	O
if	O
(	O
patterns	pointer
[	O
k	int
]	O
==	O
-	O
1	int
)	O
{	O
ll	int
++	O
;	O
continue	O
;	O
}	O
matched	int
=	O
patterns	pointer
[	O
k	int
]	O
;	O
check_pattern_light	function
(	O
anchor	int
,	O
callback	pointer
,	O
color	int
,	O
database	pointer
+	O
matched	int
,	O
ll	int
,	O
callback_data	pointer
,	O
goal	pointer
,	O
anchor_in_goal	int
)	O
;	O
}	O
}	O
static	O
void	O
check_pattern_light	function
(	O
int	O
anchor	int
,	O
matchpat_callback_fn_ptr	pointer
callback	pointer
,	O
int	O
color	int
,	O
struct	O
pattern	pointer
*	O
pattern	pointer
,	O
int	O
ll	int
,	O
void	O
*	O
callback_data	pointer
,	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
,	O
int	O
anchor_in_goal	int
)	O
{	O
int	O
k	int
;	O
int	O
found_goal	int
=	O
0	int
;	O
if	O
(	O
0	int
)	O
gprintf	function
(	O
"check_pattern_light @ %1m rot:%d pattern: %s\n"	pointer
,	O
anchor	int
,	O
ll	int
,	O
pattern	pointer
->	O
name	short
)	O
;	O
if	O
(	O
pattern	pointer
->	O
trfno	int
==	O
5	int
)	O
{	O
if	O
(	O
ll	int
<	O
2	int
||	O
ll	int
>=	O
6	int
)	O
return	O
;	O
}	O
else	O
{	O
if	O
(	O
ll	int
>=	O
pattern	pointer
->	O
trfno	int
)	O
return	O
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
pattern	pointer
->	O
patlen	int
;	O
k	int
++	O
)	O
{	O
int	O
pos	int
;	O
pos	int
=	O
AFFINE_TRANSFORM	O
(	O
pattern	pointer
->	O
patn	pointer
[	O
k	int
]	O
.	O
offset	short
,	O
ll	int
,	O
anchor	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
!	O
anchor_in_goal	int
)	O
{	O
if	O
(	O
goal	pointer
!=	O
NULL	O
&&	O
board	pointer
[	O
pos	int
]	O
!=	O
EMPTY	int
&&	O
goal	pointer
[	O
pos	int
]	O
)	O
found_goal	int
=	O
1	int
;	O
}	O
ASSERT1	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum
<	O
4	int
,	O
anchor	int
)	O
;	O
if	O
(	O
(	O
pattern	pointer
->	O
class	int
&	O
class_mask	array
[	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum
]	O
[	O
board	pointer
[	O
pos	int
]	O
]	O
)	O
!=	O
0	int
)	O
goto	O
match_failed	O
;	O
}	O
if	O
(	O
!	O
anchor_in_goal	int
)	O
{	O
if	O
(	O
goal	pointer
!=	O
NULL	O
&&	O
!	O
found_goal	int
)	O
goto	O
match_failed	O
;	O
}	O
callback	pointer
(	O
anchor	int
,	O
color	int
,	O
pattern	pointer
,	O
ll	int
,	O
callback_data	pointer
)	O
;	O
match_failed	O
:	O
DEBUG	O
(	O
DEBUG_MATCHER	int
,	O
"end of pattern '%s', rotation %d at %1m\n---\n"	pointer
,	O
pattern	pointer
->	O
name	short
,	O
ll	int
,	O
anchor	int
)	O
;	O
}	O
static	O
void	O
dfa_matchpat_loop	function
(	O
matchpat_callback_fn_ptr	pointer
callback	pointer
,	O
int	O
color	int
,	O
int	O
anchor	int
,	O
struct	O
pattern_db	struct
*	O
pdb	pointer
,	O
void	O
*	O
callback_data	pointer
,	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
,	O
int	O
anchor_in_goal	int
)	O
{	O
int	O
pos	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
anchor	int
&&	O
(	O
!	O
anchor_in_goal	int
||	O
goal	pointer
[	O
pos	int
]	O
!=	O
0	int
)	O
)	O
do_dfa_matchpat	function
(	O
pdb	pointer
->	O
pdfa	pointer
,	O
pos	int
,	O
callback	pointer
,	O
color	int
,	O
pdb	pointer
->	O
patterns	pointer
,	O
callback_data	pointer
,	O
goal	pointer
,	O
anchor_in_goal	int
)	O
;	O
}	O
}	O
typedef	O
void	O
(	O
*	O
loop_fn_ptr_t	pointer
)	O
(	O
matchpat_callback_fn_ptr	pointer
callback	pointer
,	O
int	O
color	int
,	O
int	O
anchor	int
,	O
struct	O
pattern_db	struct
*	O
pdb	pointer
,	O
void	O
*	O
callback_data	pointer
,	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
,	O
int	O
anchor_in_goal	int
)	O
;	O
typedef	O
void	O
(	O
*	O
prepare_fn_ptr_t	pointer
)	O
(	O
int	O
color	int
)	O
;	O
void	O
matchpat	function
(	O
matchpat_callback_fn_ptr	pointer
callback	pointer
,	O
int	O
color	int
,	O
struct	O
pattern_db	struct
*	O
pdb	pointer
,	O
void	O
*	O
callback_data	pointer
,	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
)	O
{	O
matchpat_goal_anchor	function
(	O
callback	pointer
,	O
color	int
,	O
pdb	pointer
,	O
callback_data	pointer
,	O
goal	pointer
,	O
pdb	pointer
->	O
fixed_anchor	int
)	O
;	O
}	O
void	O
matchpat_goal_anchor	function
(	O
matchpat_callback_fn_ptr	pointer
callback	pointer
,	O
int	O
color	int
,	O
struct	O
pattern_db	struct
*	O
pdb	pointer
,	O
void	O
*	O
callback_data	pointer
,	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
,	O
int	O
anchor_in_goal	int
)	O
{	O
loop_fn_ptr_t	pointer
loop	pointer
=	O
matchpat_loop	function
;	O
prepare_fn_ptr_t	pointer
prepare	pointer
=	O
prepare_for_match	function
;	O
if	O
(	O
pdb	pointer
->	O
fixed_for_size	int
!=	O
board_size	int
)	O
{	O
fixup_patterns_for_board_size	function
(	O
pdb	pointer
->	O
patterns	pointer
)	O
;	O
pdb	pointer
->	O
fixed_for_size	int
=	O
board_size	int
;	O
}	O
if	O
(	O
pdb	pointer
->	O
pdfa	pointer
!=	O
NULL	O
)	O
{	O
loop	pointer
=	O
dfa_matchpat_loop	function
;	O
prepare	pointer
=	O
dfa_prepare_for_match	function
;	O
}	O
switch	O
(	O
color	int
)	O
{	O
case	O
ANCHOR_COLOR	int
:	O
{	O
prepare	pointer
(	O
WHITE	int
)	O
;	O
loop	pointer
(	O
callback	pointer
,	O
WHITE	int
,	O
WHITE	int
,	O
pdb	pointer
,	O
callback_data	pointer
,	O
goal	pointer
,	O
anchor_in_goal	int
)	O
;	O
prepare	pointer
(	O
BLACK	int
)	O
;	O
loop	pointer
(	O
callback	pointer
,	O
BLACK	int
,	O
BLACK	int
,	O
pdb	pointer
,	O
callback_data	pointer
,	O
goal	pointer
,	O
anchor_in_goal	int
)	O
;	O
}	O
break	O
;	O
case	O
ANCHOR_OTHER	int
:	O
{	O
prepare	pointer
(	O
WHITE	int
)	O
;	O
loop	pointer
(	O
callback	pointer
,	O
WHITE	int
,	O
BLACK	int
,	O
pdb	pointer
,	O
callback_data	pointer
,	O
goal	pointer
,	O
anchor_in_goal	int
)	O
;	O
prepare	pointer
(	O
BLACK	int
)	O
;	O
loop	pointer
(	O
callback	pointer
,	O
BLACK	int
,	O
WHITE	int
,	O
pdb	pointer
,	O
callback_data	pointer
,	O
goal	pointer
,	O
anchor_in_goal	int
)	O
;	O
}	O
break	O
;	O
default	O
:	O
{	O
prepare	pointer
(	O
color	int
)	O
;	O
loop	pointer
(	O
callback	pointer
,	O
color	int
,	O
WHITE	int
,	O
pdb	pointer
,	O
callback_data	pointer
,	O
goal	pointer
,	O
anchor_in_goal	int
)	O
;	O
loop	pointer
(	O
callback	pointer
,	O
color	int
,	O
BLACK	int
,	O
pdb	pointer
,	O
callback_data	pointer
,	O
goal	pointer
,	O
anchor_in_goal	int
)	O
;	O
}	O
}	O
}	O
static	O
int	O
fullboard_transform	function
(	O
int	O
pos	int
,	O
int	O
trans	int
)	O
{	O
int	O
dx	int
=	O
I	O
(	O
pos	int
)	O
-	O
(	O
board_size	int
-	O
1	int
)	O
/	O
2	int
;	O
int	O
dy	int
=	O
J	O
(	O
pos	int
)	O
-	O
(	O
board_size	int
-	O
1	int
)	O
/	O
2	int
;	O
int	O
x	int
,	O
y	int
;	O
gg_assert	O
(	O
POS	O
(	O
(	O
board_size	int
-	O
1	int
)	O
/	O
2	int
,	O
(	O
board_size	int
-	O
1	int
)	O
/	O
2	int
)	O
+	O
DELTA	O
(	O
dx	int
,	O
dy	int
)	O
==	O
pos	int
)	O
;	O
TRANSFORM2	O
(	O
dx	int
,	O
dy	int
,	O
&	O
x	int
,	O
&	O
y	int
,	O
trans	int
)	O
;	O
return	O
POS	O
(	O
x	int
+	O
(	O
board_size	int
-	O
1	int
)	O
/	O
2	int
,	O
y	int
+	O
(	O
board_size	int
-	O
1	int
)	O
/	O
2	int
)	O
;	O
}	O
void	O
fullboard_matchpat	function
(	O
fullboard_matchpat_callback_fn_ptr	pointer
callback	pointer
,	O
int	O
color	int
,	O
struct	O
fullboard_pattern	struct
*	O
pattern	pointer
)	O
{	O
int	O
ll	int
;	O
int	O
number_of_stones_on_board	int
=	O
stones_on_board	function
(	O
BLACK	int
|	O
WHITE	int
)	O
;	O
static	O
int	O
color_map	array
[	O
gg_max	O
(	O
WHITE	int
,	O
BLACK	int
)	O
+	O
1	int
]	O
;	O
Hash_data	struct
current_board_hash	array
[	O
8	int
]	O
;	O
gg_assert	O
(	O
color	int
!=	O
EMPTY	int
)	O
;	O
gg_assert	O
(	O
board_size	int
%	O
2	int
==	O
1	int
)	O
;	O
color_map	array
[	O
EMPTY	int
]	O
=	O
EMPTY	int
;	O
if	O
(	O
color	int
==	O
WHITE	int
)	O
{	O
color_map	array
[	O
WHITE	int
]	O
=	O
WHITE	int
;	O
color_map	array
[	O
BLACK	int
]	O
=	O
BLACK	int
;	O
}	O
else	O
{	O
color_map	array
[	O
WHITE	int
]	O
=	O
BLACK	int
;	O
color_map	array
[	O
BLACK	int
]	O
=	O
WHITE	int
;	O
}	O
for	O
(	O
ll	int
=	O
0	int
;	O
ll	int
<	O
8	int
;	O
ll	int
++	O
)	O
{	O
Intersection	char
p	array
[	O
BOARDSIZE	O
]	O
;	O
int	O
pos	int
;	O
for	O
(	O
pos	int
=	O
0	int
;	O
pos	int
<	O
BOARDSIZE	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
p	array
[	O
pos	int
]	O
=	O
color_map	array
[	O
board	pointer
[	O
fullboard_transform	function
(	O
pos	int
,	O
ll	int
)	O
]	O
]	O
;	O
else	O
p	array
[	O
pos	int
]	O
=	O
GRAY	int
;	O
if	O
(	O
ON_BOARD	O
(	O
board_ko_pos	int
)	O
)	O
hashdata_recalc	function
(	O
&	O
current_board_hash	array
[	O
ll	int
]	O
,	O
p	array
,	O
fullboard_transform	function
(	O
board_ko_pos	int
,	O
ll	int
)	O
)	O
;	O
else	O
hashdata_recalc	function
(	O
&	O
current_board_hash	array
[	O
ll	int
]	O
,	O
p	array
,	O
NO_MOVE	O
)	O
;	O
}	O
for	O
(	O
;	O
pattern	pointer
->	O
name	short
;	O
pattern	pointer
++	O
)	O
{	O
if	O
(	O
pattern	pointer
->	O
number_of_stones	int
!=	O
number_of_stones_on_board	int
)	O
continue	O
;	O
for	O
(	O
ll	int
=	O
0	int
;	O
ll	int
<	O
8	int
;	O
ll	int
++	O
)	O
if	O
(	O
hashdata_is_equal	O
(	O
current_board_hash	array
[	O
ll	int
]	O
,	O
pattern	pointer
->	O
fullboard_hash	struct
)	O
)	O
{	O
int	O
pos	int
=	O
AFFINE_TRANSFORM	O
(	O
pattern	pointer
->	O
move_offset	int
,	O
ll	int
,	O
POS	O
(	O
(	O
board_size	int
-	O
1	int
)	O
/	O
2	int
,	O
(	O
board_size	int
-	O
1	int
)	O
/	O
2	int
)	O
)	O
;	O
callback	pointer
(	O
pos	int
,	O
pattern	pointer
,	O
ll	int
)	O
;	O
}	O
}	O
}	O
static	O
const	O
int	O
corner_x	array
[	O
8	int
]	O
=	O
{	O
0	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
0	int
}	O
;	O
static	O
const	O
int	O
corner_y	array
[	O
8	int
]	O
=	O
{	O
0	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
1	int
}	O
;	O
static	O
int	O
num_stones	int
[	O
2	int
*	O
BOARDMAX	O
]	O
;	O
static	O
int	O
pattern_stones	array
[	O
BOARDMAX	O
]	O
;	O
static	O
void	O
do_corner_matchpat	function
(	O
int	O
num_variations	char
,	O
struct	O
corner_variation	struct
*	O
variation	pointer
,	O
int	O
match_color	int
,	O
corner_matchpat_callback_fn_ptr	pointer
callback	pointer
,	O
int	O
callback_color	int
,	O
int	O
trans	int
,	O
int	O
anchor	int
,	O
int	O
stones	pointer
)	O
{	O
for	O
(	O
;	O
--	O
num_variations	char
>=	O
0	int
;	O
variation	pointer
++	O
)	O
{	O
int	O
move	pointer
=	O
AFFINE_TRANSFORM	O
(	O
variation	pointer
->	O
move_offset	int
,	O
trans	int
,	O
anchor	int
)	O
;	O
int	O
color_check	int
=	O
match_color	int
^	O
variation	pointer
->	O
xor_att	char
;	O
struct	O
corner_pattern	struct
*	O
pattern	pointer
=	O
variation	pointer
->	O
pattern	pointer
;	O
if	O
(	O
pattern	pointer
&&	O
color_check	int
==	O
callback_color	int
)	O
{	O
int	O
second_corner	int
=	O
AFFINE_TRANSFORM	O
(	O
pattern	pointer
->	O
second_corner_offset	int
,	O
trans	int
,	O
anchor	int
)	O
;	O
if	O
(	O
NUM_STONES	O
(	O
second_corner	int
)	O
==	O
stones	pointer
&&	O
(	O
!	O
pattern	pointer
->	O
symmetric	int
||	O
trans	int
<	O
4	int
)	O
)	O
{	O
ASSERT1	O
(	O
board	pointer
[	O
move	pointer
]	O
==	O
EMPTY	int
,	O
move	pointer
)	O
;	O
callback	pointer
(	O
move	pointer
,	O
callback_color	int
,	O
pattern	pointer
,	O
trans	int
,	O
pattern_stones	array
,	O
stones	pointer
)	O
;	O
continue	O
;	O
}	O
}	O
if	O
(	O
variation	pointer
->	O
num_variations	char
&&	O
NUM_STONES	O
(	O
move	pointer
)	O
==	O
variation	pointer
->	O
num_stones	int
&&	O
board	pointer
[	O
move	pointer
]	O
==	O
color_check	int
)	O
{	O
pattern_stones	array
[	O
stones	pointer
]	O
=	O
move	pointer
;	O
do_corner_matchpat	function
(	O
variation	pointer
->	O
num_variations	char
,	O
variation	pointer
->	O
variations	pointer
,	O
match_color	int
,	O
callback	pointer
,	O
callback_color	int
,	O
trans	int
,	O
anchor	int
,	O
stones	pointer
+	O
1	int
)	O
;	O
}	O
}	O
}	O
void	O
corner_matchpat	function
(	O
corner_matchpat_callback_fn_ptr	pointer
callback	pointer
,	O
int	O
color	int
,	O
struct	O
corner_db	struct
*	O
database	pointer
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
{	O
int	O
anchor	int
=	O
POS	O
(	O
corner_x	array
[	O
k	int
]	O
*	O
(	O
board_size	int
-	O
1	int
)	O
,	O
corner_y	array
[	O
k	int
]	O
*	O
(	O
board_size	int
-	O
1	int
)	O
)	O
;	O
int	O
i	int
;	O
int	O
j	int
;	O
int	O
dx	int
=	O
TRANSFORM	O
(	O
OFFSET	O
(	O
1	int
,	O
0	int
)	O
,	O
k	int
)	O
;	O
int	O
dy	int
=	O
TRANSFORM	O
(	O
OFFSET	O
(	O
0	int
,	O
1	int
)	O
,	O
k	int
)	O
;	O
int	O
pos	int
;	O
struct	O
corner_variation	struct
*	O
variation	pointer
=	O
database	pointer
->	O
top_variations	pointer
;	O
NUM_STONES	O
(	O
anchor	int
)	O
=	O
IS_STONE	O
(	O
board	pointer
[	O
anchor	int
]	O
)	O
;	O
pos	int
=	O
anchor	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
database	pointer
->	O
max_height	int
;	O
i	int
++	O
)	O
{	O
pos	int
+=	O
dx	int
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
{	O
do	O
{	O
NUM_STONES	O
(	O
pos	int
)	O
=	O
BOARDMAX	O
;	O
pos	int
+=	O
dx	int
;	O
}	O
while	O
(	O
++	O
i	int
<	O
database	pointer
->	O
max_height	int
)	O
;	O
break	O
;	O
}	O
NUM_STONES	O
(	O
pos	int
)	O
=	O
NUM_STONES	O
(	O
pos	int
-	O
dx	int
)	O
+	O
IS_STONE	O
(	O
board	pointer
[	O
pos	int
]	O
)	O
;	O
}	O
pos	int
=	O
anchor	int
;	O
for	O
(	O
j	int
=	O
1	int
;	O
j	int
<	O
database	pointer
->	O
max_width	int
;	O
j	int
++	O
)	O
{	O
pos	int
+=	O
dy	int
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
{	O
do	O
{	O
NUM_STONES	O
(	O
pos	int
)	O
=	O
BOARDMAX	O
;	O
pos	int
+=	O
dy	int
;	O
}	O
while	O
(	O
++	O
j	int
<	O
database	pointer
->	O
max_width	int
)	O
;	O
break	O
;	O
}	O
NUM_STONES	O
(	O
pos	int
)	O
=	O
NUM_STONES	O
(	O
pos	int
-	O
dy	int
)	O
+	O
IS_STONE	O
(	O
board	pointer
[	O
pos	int
]	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
database	pointer
->	O
max_height	int
;	O
i	int
++	O
)	O
{	O
pos	int
=	O
anchor	int
+	O
i	int
*	O
dy	int
;	O
for	O
(	O
j	int
=	O
1	int
;	O
j	int
<	O
database	pointer
->	O
max_width	int
;	O
j	int
++	O
)	O
{	O
pos	int
+=	O
dx	int
;	O
NUM_STONES	O
(	O
pos	int
)	O
=	O
NUM_STONES	O
(	O
pos	int
-	O
dx	int
)	O
+	O
NUM_STONES	O
(	O
pos	int
-	O
dy	int
)	O
-	O
NUM_STONES	O
(	O
pos	int
-	O
dx	int
-	O
dy	int
)	O
;	O
if	O
(	O
ON_BOARD1	O
(	O
pos	int
)	O
&&	O
IS_STONE	O
(	O
board	pointer
[	O
pos	int
]	O
)	O
)	O
NUM_STONES	O
(	O
pos	int
)	O
++	O
;	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
database	pointer
->	O
num_top_variations	char
;	O
i	int
++	O
)	O
{	O
int	O
move	pointer
=	O
AFFINE_TRANSFORM	O
(	O
variation	pointer
->	O
move_offset	int
,	O
k	int
,	O
anchor	int
)	O
;	O
if	O
(	O
NUM_STONES	O
(	O
move	pointer
)	O
==	O
1	int
&&	O
IS_STONE	O
(	O
board	pointer
[	O
move	pointer
]	O
)	O
)	O
{	O
pattern_stones	array
[	O
0	int
]	O
=	O
move	pointer
;	O
do_corner_matchpat	function
(	O
variation	pointer
->	O
num_variations	char
,	O
variation	pointer
->	O
variations	pointer
,	O
board	pointer
[	O
move	pointer
]	O
,	O
callback	pointer
,	O
color	int
,	O
k	int
,	O
anchor	int
,	O
1	int
)	O
;	O
}	O
variation	pointer
++	O
;	O
}	O
}	O
}	O
