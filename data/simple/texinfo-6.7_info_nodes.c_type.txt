char	O
*	O
info_recent_file_error	pointer
=	O
NULL	O
;	O
FILE_BUFFER	struct
*	O
*	O
info_loaded_files	pointer
=	O
NULL	O
;	O
size_t	long
info_loaded_files_index	long
=	O
0	int
;	O
size_t	long
info_loaded_files_slots	long
=	O
0	int
;	O
static	O
void	O
build_tag_table	function
(	O
FILE_BUFFER	struct
*	O
file_buffer	pointer
)	O
;	O
static	O
void	O
get_nodes_of_tags_table	function
(	O
FILE_BUFFER	struct
*	O
file_buffer	pointer
,	O
SEARCH_BINDING	struct
*	O
buffer_binding	pointer
)	O
;	O
static	O
void	O
get_tags_of_indirect_tags_table	function
(	O
FILE_BUFFER	struct
*	O
file_buffer	pointer
,	O
SEARCH_BINDING	struct
*	O
indirect_binding	pointer
,	O
SEARCH_BINDING	struct
*	O
tags_binding	pointer
)	O
;	O
static	O
void	O
free_file_buffer_tags	function
(	O
FILE_BUFFER	struct
*	O
file_buffer	pointer
)	O
;	O
static	O
void	O
free_info_tag	function
(	O
TAG	struct
*	O
tag	pointer
)	O
;	O
void	O
build_tags_and_nodes	function
(	O
FILE_BUFFER	struct
*	O
file_buffer	pointer
)	O
{	O
SEARCH_BINDING	struct
binding	pointer
;	O
long	O
position	long
;	O
long	O
tags_table_begin	long
,	O
tags_table_end	long
;	O
free_file_buffer_tags	function
(	O
file_buffer	pointer
)	O
;	O
file_buffer	pointer
->	O
flags	int
&=	O
~	O
N_HasTagsTable	int
;	O
binding	pointer
.	O
buffer	pointer
=	O
file_buffer	pointer
->	O
contents	pointer
;	O
binding	pointer
.	O
start	int
=	O
file_buffer	pointer
->	O
filesize	long
;	O
binding	pointer
.	O
end	int
=	O
binding	pointer
.	O
start	int
-	O
1000	int
;	O
if	O
(	O
binding	pointer
.	O
end	int
<	O
0	int
)	O
binding	pointer
.	O
end	int
=	O
0	int
;	O
binding	pointer
.	O
flags	int
=	O
S_FoldCase	int
;	O
position	long
=	O
find_file_section	function
(	O
&	O
binding	pointer
,	O
TAGS_TABLE_END_LABEL	pointer
)	O
;	O
if	O
(	O
position	long
==	O
-	O
1	int
)	O
goto	O
no_tags_table	O
;	O
if	O
(	O
position	long
==	O
0	int
)	O
goto	O
no_tags_table	O
;	O
else	O
tags_table_end	long
=	O
position	long
-	O
1	int
;	O
binding	pointer
.	O
start	int
=	O
tags_table_end	long
;	O
binding	pointer
.	O
end	int
=	O
0	int
;	O
position	long
=	O
find_file_section	function
(	O
&	O
binding	pointer
,	O
TAGS_TABLE_BEG_LABEL	pointer
)	O
;	O
if	O
(	O
position	long
==	O
-	O
1	int
)	O
goto	O
no_tags_table	O
;	O
file_buffer	pointer
->	O
flags	int
|=	O
N_HasTagsTable	int
;	O
tags_table_begin	long
=	O
position	long
;	O
position	long
+=	O
skip_node_separator	function
(	O
file_buffer	pointer
->	O
contents	pointer
+	O
position	long
)	O
;	O
position	long
+=	O
strlen	function
(	O
TAGS_TABLE_BEG_LABEL	pointer
)	O
;	O
position	long
+=	O
strspn	function
(	O
file_buffer	pointer
->	O
contents	pointer
+	O
position	long
,	O
"\r\n"	pointer
)	O
;	O
if	O
(	O
!	O
looking_at_line	function
(	O
TAGS_TABLE_IS_INDIRECT_LABEL	pointer
,	O
file_buffer	pointer
->	O
contents	pointer
+	O
position	long
)	O
)	O
{	O
binding	pointer
.	O
start	int
=	O
tags_table_begin	long
;	O
binding	pointer
.	O
end	int
=	O
tags_table_end	long
;	O
get_nodes_of_tags_table	function
(	O
file_buffer	pointer
,	O
&	O
binding	pointer
)	O
;	O
}	O
else	O
{	O
SEARCH_BINDING	struct
indirect	struct
;	O
indirect	struct
.	O
start	int
=	O
tags_table_begin	long
;	O
indirect	struct
.	O
end	int
=	O
0	int
;	O
indirect	struct
.	O
buffer	pointer
=	O
file_buffer	pointer
->	O
contents	pointer
;	O
indirect	struct
.	O
flags	int
=	O
S_FoldCase	int
;	O
position	long
=	O
find_file_section	function
(	O
&	O
indirect	struct
,	O
INDIRECT_TABLE_LABEL	pointer
)	O
;	O
if	O
(	O
position	long
==	O
-	O
1	int
)	O
return	O
;	O
position	long
+=	O
skip_node_separator	function
(	O
file_buffer	pointer
->	O
contents	pointer
+	O
position	long
)	O
;	O
position	long
+=	O
strlen	function
(	O
INDIRECT_TABLE_LABEL	pointer
)	O
;	O
position	long
+=	O
strspn	function
(	O
file_buffer	pointer
->	O
contents	pointer
+	O
position	long
,	O
"\r\n"	pointer
)	O
;	O
indirect	struct
.	O
start	int
=	O
position	long
;	O
indirect	struct
.	O
end	int
=	O
tags_table_begin	long
;	O
binding	pointer
.	O
start	int
=	O
tags_table_begin	long
;	O
binding	pointer
.	O
end	int
=	O
tags_table_end	long
;	O
get_tags_of_indirect_tags_table	function
(	O
file_buffer	pointer
,	O
&	O
indirect	struct
,	O
&	O
binding	pointer
)	O
;	O
}	O
return	O
;	O
no_tags_table	O
:	O
build_tag_table	function
(	O
file_buffer	pointer
)	O
;	O
}	O
static	O
void	O
init_file_buffer_tag	function
(	O
FILE_BUFFER	struct
*	O
fb	pointer
,	O
TAG	struct
*	O
entry	pointer
)	O
{	O
if	O
(	O
fb	pointer
->	O
flags	int
&	O
N_HasTagsTable	int
)	O
{	O
entry	pointer
->	O
flags	int
|=	O
N_HasTagsTable	int
;	O
entry	pointer
->	O
filename	pointer
=	O
fb	pointer
->	O
fullpath	pointer
;	O
if	O
(	O
fb	pointer
->	O
flags	int
&	O
N_TagsIndirect	int
)	O
entry	pointer
->	O
flags	int
|=	O
N_TagsIndirect	int
;	O
}	O
}	O
static	O
void	O
build_tag_table	function
(	O
FILE_BUFFER	struct
*	O
file_buffer	pointer
)	O
{	O
long	O
nodestart	long
;	O
size_t	long
tags_index	long
=	O
0	int
;	O
SEARCH_BINDING	struct
binding	pointer
;	O
binding	pointer
.	O
buffer	pointer
=	O
file_buffer	pointer
->	O
contents	pointer
;	O
binding	pointer
.	O
start	int
=	O
0	int
;	O
binding	pointer
.	O
end	int
=	O
file_buffer	pointer
->	O
filesize	long
;	O
binding	pointer
.	O
flags	int
=	O
S_FoldCase	int
;	O
while	O
(	O
(	O
nodestart	long
=	O
find_node_separator	function
(	O
&	O
binding	pointer
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
int	O
start	int
;	O
char	O
*	O
nodeline	pointer
;	O
TAG	struct
*	O
entry	pointer
;	O
int	O
anchor	int
=	O
0	int
;	O
binding	pointer
.	O
start	int
=	O
nodestart	long
;	O
binding	pointer
.	O
start	int
+=	O
skip_node_separator	function
(	O
binding	pointer
.	O
buffer	pointer
+	O
binding	pointer
.	O
start	int
)	O
;	O
nodeline	pointer
=	O
binding	pointer
.	O
buffer	pointer
+	O
binding	pointer
.	O
start	int
;	O
start	int
=	O
string_in_line	function
(	O
INFO_NODE_LABEL	pointer
,	O
nodeline	pointer
)	O
;	O
if	O
(	O
start	int
==	O
-	O
1	int
)	O
{	O
start	int
=	O
string_in_line	function
(	O
INFO_REF_LABEL	pointer
,	O
nodeline	pointer
)	O
;	O
if	O
(	O
start	int
!=	O
-	O
1	int
)	O
anchor	int
=	O
1	int
;	O
}	O
if	O
(	O
start	int
==	O
-	O
1	int
)	O
continue	O
;	O
start	int
+=	O
skip_whitespace	function
(	O
nodeline	pointer
+	O
start	int
)	O
;	O
entry	pointer
=	O
info_create_tag	function
(	O
)	O
;	O
read_quoted_string	function
(	O
nodeline	pointer
+	O
start	int
,	O
",\n\r\t"	pointer
,	O
0	int
,	O
&	O
entry	pointer
->	O
nodename	pointer
)	O
;	O
if	O
(	O
!	O
entry	pointer
->	O
nodename	pointer
||	O
!	O
*	O
entry	pointer
->	O
nodename	pointer
)	O
{	O
free	function
(	O
entry	pointer
)	O
;	O
continue	O
;	O
}	O
entry	pointer
->	O
nodestart	long
=	O
nodestart	long
;	O
init_file_buffer_tag	function
(	O
file_buffer	pointer
,	O
entry	pointer
)	O
;	O
if	O
(	O
anchor	int
)	O
entry	pointer
->	O
cache	struct
.	O
nodelen	long
=	O
0	int
;	O
else	O
entry	pointer
->	O
cache	struct
.	O
nodelen	long
=	O
-	O
1	int
;	O
entry	pointer
->	O
filename	pointer
=	O
file_buffer	pointer
->	O
fullpath	pointer
;	O
add_pointer_to_array	O
(	O
entry	pointer
,	O
tags_index	long
,	O
file_buffer	pointer
->	O
tags	pointer
,	O
file_buffer	pointer
->	O
tags_slots	long
,	O
100	int
)	O
;	O
}	O
}	O
static	O
void	O
get_nodes_of_tags_table	function
(	O
FILE_BUFFER	struct
*	O
file_buffer	pointer
,	O
SEARCH_BINDING	struct
*	O
buffer_binding	pointer
)	O
{	O
int	O
name_offset	int
;	O
SEARCH_BINDING	struct
s	pointer
;	O
long	O
position	long
;	O
size_t	long
tags_index	long
=	O
0	int
;	O
s	pointer
=	O
*	O
buffer_binding	pointer
;	O
position	long
=	O
buffer_binding	pointer
->	O
start	int
;	O
if	O
(	O
position	long
==	O
-	O
1	int
)	O
return	O
;	O
s	pointer
.	O
start	int
=	O
position	long
;	O
s	pointer
.	O
start	int
+=	O
skip_node_separator	function
(	O
s	pointer
.	O
buffer	pointer
+	O
s	pointer
.	O
start	int
)	O
;	O
s	pointer
.	O
start	int
+=	O
strlen	function
(	O
TAGS_TABLE_BEG_LABEL	pointer
)	O
;	O
while	O
(	O
search_forward	function
(	O
"\n"	pointer
,	O
&	O
s	pointer
,	O
&	O
position	long
)	O
==	O
search_success	int
)	O
{	O
TAG	struct
*	O
entry	pointer
;	O
char	O
*	O
nodedef	pointer
;	O
unsigned	O
p	pointer
;	O
int	O
anchor	int
=	O
0	int
;	O
s	pointer
.	O
start	int
=	O
position	long
;	O
s	pointer
.	O
start	int
++	O
;	O
if	O
(	O
!	O
tags_index	long
&&	O
looking_at	function
(	O
TAGS_TABLE_IS_INDIRECT_LABEL	pointer
,	O
&	O
s	pointer
)	O
)	O
continue	O
;	O
name_offset	int
=	O
string_in_line	function
(	O
INFO_NODE_LABEL	pointer
,	O
s	pointer
.	O
buffer	pointer
+	O
s	pointer
.	O
start	int
)	O
;	O
if	O
(	O
name_offset	int
==	O
-	O
1	int
)	O
{	O
name_offset	int
=	O
string_in_line	function
(	O
INFO_REF_LABEL	pointer
,	O
s	pointer
.	O
buffer	pointer
+	O
s	pointer
.	O
start	int
)	O
;	O
if	O
(	O
name_offset	int
!=	O
-	O
1	int
)	O
anchor	int
=	O
1	int
;	O
}	O
if	O
(	O
name_offset	int
==	O
-	O
1	int
)	O
break	O
;	O
entry	pointer
=	O
info_create_tag	function
(	O
)	O
;	O
init_file_buffer_tag	function
(	O
file_buffer	pointer
,	O
entry	pointer
)	O
;	O
s	pointer
.	O
start	int
+=	O
name_offset	int
;	O
nodedef	pointer
=	O
s	pointer
.	O
buffer	pointer
+	O
s	pointer
.	O
start	int
;	O
nodedef	pointer
+=	O
skip_whitespace	function
(	O
nodedef	pointer
)	O
;	O
for	O
(	O
p	pointer
=	O
0	int
;	O
nodedef	pointer
[	O
p	pointer
]	O
&&	O
nodedef	pointer
[	O
p	pointer
]	O
!=	O
INFO_TAGSEP	char
;	O
p	pointer
++	O
)	O
;	O
if	O
(	O
nodedef	pointer
[	O
p	pointer
]	O
!=	O
INFO_TAGSEP	char
)	O
continue	O
;	O
entry	pointer
->	O
nodename	pointer
=	O
xmalloc	function
(	O
p	pointer
+	O
1	int
)	O
;	O
strncpy	function
(	O
entry	pointer
->	O
nodename	pointer
,	O
nodedef	pointer
,	O
p	pointer
)	O
;	O
entry	pointer
->	O
nodename	pointer
[	O
p	pointer
]	O
=	O
0	int
;	O
p	pointer
++	O
;	O
entry	pointer
->	O
nodestart	long
=	O
atol	function
(	O
nodedef	pointer
+	O
p	pointer
)	O
;	O
entry	pointer
->	O
cache	struct
.	O
nodelen	long
=	O
anchor	int
?	O
0	int
:	O
-	O
1	int
;	O
entry	pointer
->	O
filename	pointer
=	O
file_buffer	pointer
->	O
fullpath	pointer
;	O
add_pointer_to_array	O
(	O
entry	pointer
,	O
tags_index	long
,	O
file_buffer	pointer
->	O
tags	pointer
,	O
file_buffer	pointer
->	O
tags_slots	long
,	O
100	int
)	O
;	O
}	O
}	O
static	O
void	O
get_tags_of_indirect_tags_table	function
(	O
FILE_BUFFER	struct
*	O
file_buffer	pointer
,	O
SEARCH_BINDING	struct
*	O
indirect_binding	pointer
,	O
SEARCH_BINDING	struct
*	O
tags_binding	pointer
)	O
{	O
int	O
i	int
;	O
typedef	O
struct	O
{	O
char	O
*	O
filename	pointer
;	O
long	O
first_byte	long
;	O
}	O
SUBFILE	struct
;	O
SUBFILE	struct
*	O
*	O
subfiles	pointer
=	O
NULL	O
;	O
size_t	long
subfiles_index	long
=	O
0	int
,	O
subfiles_slots	long
=	O
0	int
;	O
TAG	struct
*	O
entry	pointer
;	O
file_buffer	pointer
->	O
flags	int
|=	O
N_TagsIndirect	int
;	O
get_nodes_of_tags_table	function
(	O
file_buffer	pointer
,	O
tags_binding	pointer
)	O
;	O
if	O
(	O
!	O
file_buffer	pointer
->	O
tags	pointer
)	O
return	O
;	O
{	O
char	O
*	O
start	int
,	O
*	O
end	int
,	O
*	O
line	pointer
;	O
SUBFILE	struct
*	O
subfile	pointer
;	O
start	int
=	O
indirect_binding	pointer
->	O
buffer	pointer
+	O
indirect_binding	pointer
->	O
start	int
;	O
end	int
=	O
indirect_binding	pointer
->	O
buffer	pointer
+	O
indirect_binding	pointer
->	O
end	int
;	O
line	pointer
=	O
start	int
;	O
while	O
(	O
line	pointer
<	O
end	int
)	O
{	O
int	O
colon	int
;	O
colon	int
=	O
string_in_line	function
(	O
":"	pointer
,	O
line	pointer
)	O
;	O
if	O
(	O
colon	int
==	O
-	O
1	int
)	O
break	O
;	O
subfile	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
SUBFILE	struct
)	O
)	O
;	O
subfile	pointer
->	O
filename	pointer
=	O
xmalloc	function
(	O
colon	int
)	O
;	O
strncpy	function
(	O
subfile	pointer
->	O
filename	pointer
,	O
line	pointer
,	O
colon	int
-	O
1	int
)	O
;	O
subfile	pointer
->	O
filename	pointer
[	O
colon	int
-	O
1	int
]	O
=	O
0	int
;	O
subfile	pointer
->	O
first_byte	long
=	O
(	O
long	O
)	O
atol	function
(	O
line	pointer
+	O
colon	int
)	O
;	O
add_pointer_to_array	O
(	O
subfile	pointer
,	O
subfiles_index	long
,	O
subfiles	pointer
,	O
subfiles_slots	long
,	O
10	int
)	O
;	O
while	O
(	O
*	O
line	pointer
++	O
!=	O
'\n'	O
)	O
;	O
}	O
}	O
if	O
(	O
!	O
subfiles	pointer
)	O
{	O
free_file_buffer_tags	function
(	O
file_buffer	pointer
)	O
;	O
return	O
;	O
}	O
else	O
{	O
int	O
tags_index	long
;	O
long	O
header_length	long
;	O
SEARCH_BINDING	struct
binding	pointer
;	O
binding	pointer
.	O
buffer	pointer
=	O
file_buffer	pointer
->	O
contents	pointer
;	O
binding	pointer
.	O
start	int
=	O
0	int
;	O
binding	pointer
.	O
end	int
=	O
file_buffer	pointer
->	O
filesize	long
;	O
binding	pointer
.	O
flags	int
=	O
S_FoldCase	int
;	O
header_length	long
=	O
find_node_separator	function
(	O
&	O
binding	pointer
)	O
;	O
if	O
(	O
header_length	long
==	O
-	O
1	int
)	O
header_length	long
=	O
0	int
;	O
{	O
char	O
*	O
containing_dir	pointer
=	O
xstrdup	function
(	O
file_buffer	pointer
->	O
fullpath	pointer
)	O
;	O
char	O
*	O
temp	pointer
=	O
filename_non_directory	function
(	O
containing_dir	pointer
)	O
;	O
int	O
len_containing_dir	int
;	O
if	O
(	O
temp	pointer
>	O
containing_dir	pointer
)	O
{	O
if	O
(	O
HAVE_DRIVE	O
(	O
file_buffer	pointer
->	O
fullpath	pointer
)	O
&&	O
temp	pointer
==	O
containing_dir	pointer
+	O
2	int
)	O
{	O
*	O
temp	pointer
=	O
'.'	O
;	O
temp	pointer
+=	O
2	int
;	O
}	O
temp	pointer
[	O
-	O
1	int
]	O
=	O
0	int
;	O
}	O
len_containing_dir	int
=	O
strlen	function
(	O
containing_dir	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
subfiles	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
;	O
file_buffer	pointer
->	O
subfiles	pointer
=	O
xmalloc	function
(	O
(	O
1	int
+	O
i	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
subfiles	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
char	O
*	O
fullpath	pointer
;	O
fullpath	pointer
=	O
xmalloc	function
(	O
2	int
+	O
strlen	function
(	O
subfiles	pointer
[	O
i	int
]	O
->	O
filename	pointer
)	O
+	O
len_containing_dir	int
)	O
;	O
sprintf	function
(	O
fullpath	pointer
,	O
"%s/%s"	pointer
,	O
containing_dir	pointer
,	O
subfiles	pointer
[	O
i	int
]	O
->	O
filename	pointer
)	O
;	O
file_buffer	pointer
->	O
subfiles	pointer
[	O
i	int
]	O
=	O
fullpath	pointer
;	O
}	O
file_buffer	pointer
->	O
subfiles	pointer
[	O
i	int
]	O
=	O
NULL	O
;	O
free	function
(	O
containing_dir	pointer
)	O
;	O
}	O
for	O
(	O
tags_index	long
=	O
0	int
;	O
(	O
entry	pointer
=	O
file_buffer	pointer
->	O
tags	pointer
[	O
tags_index	long
]	O
)	O
;	O
tags_index	long
++	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
subfiles	pointer
[	O
i	int
]	O
&&	O
entry	pointer
->	O
nodestart	long
>=	O
subfiles	pointer
[	O
i	int
]	O
->	O
first_byte	long
;	O
i	int
++	O
)	O
;	O
if	O
(	O
!	O
i	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
subfiles	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
free	function
(	O
subfiles	pointer
[	O
i	int
]	O
->	O
filename	pointer
)	O
;	O
free	function
(	O
subfiles	pointer
[	O
i	int
]	O
)	O
;	O
free	function
(	O
file_buffer	pointer
->	O
subfiles	pointer
[	O
i	int
]	O
)	O
;	O
}	O
file_buffer	pointer
->	O
subfiles	pointer
=	O
NULL	O
;	O
free_file_buffer_tags	function
(	O
file_buffer	pointer
)	O
;	O
return	O
;	O
}	O
entry	pointer
->	O
filename	pointer
=	O
file_buffer	pointer
->	O
subfiles	pointer
[	O
i	int
-	O
1	int
]	O
;	O
entry	pointer
->	O
nodestart	long
-=	O
subfiles	pointer
[	O
i	int
-	O
1	int
]	O
->	O
first_byte	long
;	O
entry	pointer
->	O
nodestart	long
+=	O
header_length	long
;	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
subfiles	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
free	function
(	O
subfiles	pointer
[	O
i	int
]	O
->	O
filename	pointer
)	O
;	O
free	function
(	O
subfiles	pointer
[	O
i	int
]	O
)	O
;	O
}	O
free	function
(	O
subfiles	pointer
)	O
;	O
}	O
static	O
void	O
free_file_buffer_tags	function
(	O
FILE_BUFFER	struct
*	O
file_buffer	pointer
)	O
{	O
int	O
i	int
;	O
if	O
(	O
file_buffer	pointer
->	O
tags	pointer
)	O
{	O
TAG	struct
*	O
tag	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
tag	pointer
=	O
file_buffer	pointer
->	O
tags	pointer
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
free_info_tag	function
(	O
tag	pointer
)	O
;	O
free	function
(	O
file_buffer	pointer
->	O
tags	pointer
)	O
;	O
file_buffer	pointer
->	O
tags	pointer
=	O
NULL	O
;	O
file_buffer	pointer
->	O
tags_slots	long
=	O
0	int
;	O
}	O
if	O
(	O
file_buffer	pointer
->	O
subfiles	pointer
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
file_buffer	pointer
->	O
subfiles	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
free	function
(	O
file_buffer	pointer
->	O
subfiles	pointer
[	O
i	int
]	O
)	O
;	O
free	function
(	O
file_buffer	pointer
->	O
subfiles	pointer
)	O
;	O
file_buffer	pointer
->	O
subfiles	pointer
=	O
NULL	O
;	O
}	O
}	O
static	O
void	O
free_info_tag	function
(	O
TAG	struct
*	O
tag	pointer
)	O
{	O
free	function
(	O
tag	pointer
->	O
nodename	pointer
)	O
;	O
free	function
(	O
tag	pointer
)	O
;	O
}	O
static	O
FILE_BUFFER	struct
*	O
info_load_file	function
(	O
char	O
*	O
fullpath	pointer
,	O
int	O
get_tags	int
)	O
;	O
static	O
void	O
get_file_character_encoding	function
(	O
FILE_BUFFER	struct
*	O
fb	pointer
)	O
;	O
static	O
void	O
forget_info_file	function
(	O
FILE_BUFFER	struct
*	O
file_buffer	pointer
)	O
;	O
static	O
void	O
info_reload_file_buffer_contents	function
(	O
FILE_BUFFER	struct
*	O
fb	pointer
)	O
;	O
FILE_BUFFER	struct
*	O
check_loaded_file	function
(	O
char	O
*	O
filename	pointer
)	O
{	O
int	O
is_fullpath	int
,	O
i	int
;	O
FILE_BUFFER	struct
*	O
file_buffer	pointer
;	O
is_fullpath	int
=	O
IS_ABSOLUTE	O
(	O
filename	pointer
)	O
||	O
filename	pointer
[	O
0	int
]	O
==	O
'.'	O
&&	O
IS_SLASH	O
(	O
filename	pointer
[	O
1	int
]	O
)	O
;	O
if	O
(	O
info_loaded_files	pointer
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
file_buffer	pointer
=	O
info_loaded_files	pointer
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
if	O
(	O
(	O
FILENAME_CMP	O
(	O
filename	pointer
,	O
file_buffer	pointer
->	O
fullpath	pointer
)	O
==	O
0	int
)	O
||	O
(	O
!	O
is_fullpath	int
&&	O
(	O
FILENAME_CMP	O
(	O
filename	pointer
,	O
file_buffer	pointer
->	O
filename	pointer
)	O
==	O
0	int
)	O
)	O
)	O
{	O
struct	O
stat	struct
new_info	struct
,	O
*	O
old_info	pointer
;	O
old_info	pointer
=	O
&	O
file_buffer	pointer
->	O
finfo	struct
;	O
if	O
(	O
stat	struct
(	O
file_buffer	pointer
->	O
fullpath	pointer
,	O
&	O
new_info	struct
)	O
==	O
-	O
1	int
||	O
new_info	struct
.	O
st_size	long
!=	O
old_info	pointer
->	O
st_size	long
||	O
new_info	struct
.	O
st_mtime	O
!=	O
old_info	pointer
->	O
st_mtime	O
)	O
{	O
forget_info_file	function
(	O
file_buffer	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
file_buffer	pointer
->	O
contents	pointer
)	O
{	O
info_reload_file_buffer_contents	function
(	O
file_buffer	pointer
)	O
;	O
if	O
(	O
!	O
file_buffer	pointer
->	O
contents	pointer
)	O
return	O
NULL	O
;	O
}	O
if	O
(	O
!	O
file_buffer	pointer
->	O
tags	pointer
)	O
build_tags_and_nodes	function
(	O
file_buffer	pointer
)	O
;	O
return	O
file_buffer	pointer
;	O
}	O
}	O
return	O
0	int
;	O
}	O
FILE_BUFFER	struct
*	O
info_find_file	function
(	O
char	O
*	O
filename	pointer
)	O
{	O
FILE_BUFFER	struct
*	O
file_buffer	pointer
;	O
char	O
*	O
fullpath	pointer
;	O
int	O
is_fullpath	int
;	O
file_buffer	pointer
=	O
check_loaded_file	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
file_buffer	pointer
)	O
return	O
file_buffer	pointer
;	O
is_fullpath	int
=	O
IS_ABSOLUTE	O
(	O
filename	pointer
)	O
||	O
filename	pointer
[	O
0	int
]	O
==	O
'.'	O
&&	O
IS_SLASH	O
(	O
filename	pointer
[	O
1	int
]	O
)	O
;	O
if	O
(	O
!	O
is_fullpath	int
)	O
fullpath	pointer
=	O
info_find_fullpath	function
(	O
filename	pointer
,	O
0	int
)	O
;	O
else	O
fullpath	pointer
=	O
xstrdup	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
!	O
fullpath	pointer
)	O
return	O
NULL	O
;	O
file_buffer	pointer
=	O
info_load_file	function
(	O
fullpath	pointer
,	O
0	int
)	O
;	O
free	function
(	O
fullpath	pointer
)	O
;	O
return	O
file_buffer	pointer
;	O
}	O
FILE_BUFFER	struct
*	O
info_find_subfile	function
(	O
char	O
*	O
fullpath	pointer
)	O
{	O
char	O
*	O
with_extension	pointer
=	O
0	int
;	O
int	O
i	int
;	O
FILE_BUFFER	struct
*	O
file_buffer	pointer
=	O
0	int
;	O
int	O
fullpath_len	int
=	O
strlen	function
(	O
fullpath	pointer
)	O
;	O
if	O
(	O
info_loaded_files	pointer
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
file_buffer	pointer
=	O
info_loaded_files	pointer
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
if	O
(	O
!	O
strncmp	function
(	O
file_buffer	pointer
->	O
fullpath	pointer
,	O
fullpath	pointer
,	O
fullpath_len	int
)	O
&&	O
(	O
file_buffer	pointer
->	O
fullpath	pointer
[	O
fullpath_len	int
]	O
==	O
'\0'	O
||	O
file_buffer	pointer
->	O
fullpath	pointer
[	O
fullpath_len	int
]	O
==	O
'.'	O
)	O
)	O
{	O
struct	O
stat	struct
new_info	struct
,	O
*	O
old_info	pointer
;	O
old_info	pointer
=	O
&	O
file_buffer	pointer
->	O
finfo	struct
;	O
if	O
(	O
stat	struct
(	O
file_buffer	pointer
->	O
fullpath	pointer
,	O
&	O
new_info	struct
)	O
==	O
-	O
1	int
||	O
new_info	struct
.	O
st_size	long
!=	O
old_info	pointer
->	O
st_size	long
||	O
new_info	struct
.	O
st_mtime	O
!=	O
old_info	pointer
->	O
st_mtime	O
)	O
{	O
forget_info_file	function
(	O
file_buffer	pointer
)	O
;	O
break	O
;	O
}	O
return	O
file_buffer	pointer
;	O
}	O
}	O
with_extension	pointer
=	O
info_find_fullpath	function
(	O
fullpath	pointer
,	O
0	int
)	O
;	O
if	O
(	O
with_extension	pointer
)	O
{	O
file_buffer	pointer
=	O
info_load_file	function
(	O
with_extension	pointer
,	O
1	int
)	O
;	O
free	function
(	O
with_extension	pointer
)	O
;	O
}	O
return	O
file_buffer	pointer
;	O
}	O
static	O
FILE_BUFFER	struct
*	O
info_load_file	function
(	O
char	O
*	O
fullpath	pointer
,	O
int	O
is_subfile	int
)	O
{	O
char	O
*	O
contents	pointer
;	O
size_t	long
filesize	long
;	O
struct	O
stat	struct
finfo	struct
;	O
int	O
compressed	int
;	O
FILE_BUFFER	struct
*	O
file_buffer	pointer
=	O
NULL	O
;	O
contents	pointer
=	O
filesys_read_info_file	function
(	O
fullpath	pointer
,	O
&	O
filesize	long
,	O
&	O
finfo	struct
,	O
&	O
compressed	int
)	O
;	O
if	O
(	O
!	O
contents	pointer
)	O
return	O
NULL	O
;	O
file_buffer	pointer
=	O
make_file_buffer	function
(	O
)	O
;	O
file_buffer	pointer
->	O
fullpath	pointer
=	O
xstrdup	function
(	O
fullpath	pointer
)	O
;	O
file_buffer	pointer
->	O
filename	pointer
=	O
filename_non_directory	function
(	O
file_buffer	pointer
->	O
fullpath	pointer
)	O
;	O
file_buffer	pointer
->	O
filename	pointer
=	O
xstrdup	function
(	O
file_buffer	pointer
->	O
filename	pointer
)	O
;	O
{	O
char	O
*	O
p	pointer
=	O
strchr	function
(	O
file_buffer	pointer
->	O
filename	pointer
,	O
'.'	O
)	O
;	O
if	O
(	O
p	pointer
)	O
*	O
p	pointer
=	O
'\0'	O
;	O
}	O
file_buffer	pointer
->	O
finfo	struct
=	O
finfo	struct
;	O
file_buffer	pointer
->	O
filesize	long
=	O
filesize	long
;	O
file_buffer	pointer
->	O
contents	pointer
=	O
contents	pointer
;	O
if	O
(	O
compressed	int
)	O
file_buffer	pointer
->	O
flags	int
|=	O
N_IsCompressed	int
;	O
get_file_character_encoding	function
(	O
file_buffer	pointer
)	O
;	O
if	O
(	O
!	O
is_subfile	int
)	O
{	O
build_tags_and_nodes	function
(	O
file_buffer	pointer
)	O
;	O
if	O
(	O
!	O
file_buffer	pointer
->	O
tags	pointer
)	O
{	O
free	function
(	O
file_buffer	pointer
->	O
fullpath	pointer
)	O
;	O
free	function
(	O
file_buffer	pointer
->	O
filename	pointer
)	O
;	O
free	function
(	O
file_buffer	pointer
->	O
contents	pointer
)	O
;	O
free	function
(	O
file_buffer	pointer
->	O
encoding	pointer
)	O
;	O
free	function
(	O
file_buffer	pointer
)	O
;	O
return	O
0	int
;	O
}	O
}	O
else	O
file_buffer	pointer
->	O
flags	int
|=	O
N_Subfile	int
;	O
if	O
(	O
file_buffer	pointer
)	O
add_pointer_to_array	O
(	O
file_buffer	pointer
,	O
info_loaded_files_index	long
,	O
info_loaded_files	pointer
,	O
info_loaded_files_slots	long
,	O
10	int
)	O
;	O
return	O
file_buffer	pointer
;	O
}	O
static	O
void	O
get_file_character_encoding	function
(	O
FILE_BUFFER	struct
*	O
fb	pointer
)	O
{	O
SEARCH_BINDING	struct
binding	pointer
;	O
long	O
position	long
;	O
long	O
int	O
enc_start	long
,	O
enc_len	long
;	O
char	O
*	O
enc_string	pointer
;	O
binding	pointer
.	O
buffer	pointer
=	O
fb	pointer
->	O
contents	pointer
;	O
binding	pointer
.	O
start	int
=	O
fb	pointer
->	O
filesize	long
;	O
binding	pointer
.	O
end	int
=	O
binding	pointer
.	O
start	int
-	O
1000	int
;	O
if	O
(	O
binding	pointer
.	O
end	int
<	O
0	int
)	O
binding	pointer
.	O
end	int
=	O
0	int
;	O
binding	pointer
.	O
flags	int
=	O
S_FoldCase	int
;	O
fb	pointer
->	O
encoding	pointer
=	O
0	int
;	O
if	O
(	O
search_backward	function
(	O
LOCAL_VARIABLES_LABEL	pointer
,	O
&	O
binding	pointer
,	O
&	O
position	long
)	O
!=	O
search_success	int
)	O
return	O
;	O
binding	pointer
.	O
start	int
=	O
position	long
;	O
binding	pointer
.	O
end	int
=	O
fb	pointer
->	O
filesize	long
;	O
if	O
(	O
search_forward	function
(	O
CHARACTER_ENCODING_LABEL	pointer
,	O
&	O
binding	pointer
,	O
&	O
enc_start	long
)	O
!=	O
search_success	int
)	O
return	O
;	O
enc_start	long
+=	O
strlen	function
(	O
CHARACTER_ENCODING_LABEL	pointer
)	O
;	O
enc_start	long
+=	O
skip_whitespace	function
(	O
fb	pointer
->	O
contents	pointer
+	O
enc_start	long
)	O
;	O
enc_len	long
=	O
strcspn	function
(	O
fb	pointer
->	O
contents	pointer
+	O
enc_start	long
,	O
"\r\n"	pointer
)	O
;	O
enc_string	pointer
=	O
xmalloc	function
(	O
enc_len	long
+	O
1	int
)	O
;	O
strncpy	function
(	O
enc_string	pointer
,	O
fb	pointer
->	O
contents	pointer
+	O
enc_start	long
,	O
enc_len	long
)	O
;	O
enc_string	pointer
[	O
enc_len	long
]	O
=	O
'\0'	O
;	O
fb	pointer
->	O
encoding	pointer
=	O
enc_string	pointer
;	O
}	O
FILE_BUFFER	struct
*	O
make_file_buffer	function
(	O
void	O
)	O
{	O
FILE_BUFFER	struct
*	O
file_buffer	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
FILE_BUFFER	struct
)	O
)	O
;	O
file_buffer	pointer
->	O
filename	pointer
=	O
file_buffer	pointer
->	O
fullpath	pointer
=	O
NULL	O
;	O
file_buffer	pointer
->	O
contents	pointer
=	O
NULL	O
;	O
file_buffer	pointer
->	O
tags	pointer
=	O
NULL	O
;	O
file_buffer	pointer
->	O
subfiles	pointer
=	O
NULL	O
;	O
file_buffer	pointer
->	O
tags_slots	long
=	O
0	int
;	O
file_buffer	pointer
->	O
flags	int
=	O
0	int
;	O
file_buffer	pointer
->	O
encoding	pointer
=	O
0	int
;	O
return	O
file_buffer	pointer
;	O
}	O
static	O
void	O
forget_info_file	function
(	O
FILE_BUFFER	struct
*	O
file_buffer	pointer
)	O
{	O
file_buffer	pointer
->	O
flags	int
|=	O
N_Gone	int
;	O
file_buffer	pointer
->	O
filename	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
file_buffer	pointer
->	O
fullpath	pointer
=	O
""	pointer
;	O
memset	function
(	O
&	O
file_buffer	pointer
->	O
finfo	struct
,	O
0	int
,	O
sizeof	O
(	O
struct	O
stat	struct
)	O
)	O
;	O
}	O
static	O
void	O
info_reload_file_buffer_contents	function
(	O
FILE_BUFFER	struct
*	O
fb	pointer
)	O
{	O
int	O
is_compressed	pointer
;	O
fb	pointer
->	O
flags	int
&=	O
~	O
N_IsCompressed	int
;	O
fb	pointer
->	O
contents	pointer
=	O
filesys_read_info_file	function
(	O
fb	pointer
->	O
fullpath	pointer
,	O
&	O
(	O
fb	pointer
->	O
filesize	long
)	O
,	O
&	O
(	O
fb	pointer
->	O
finfo	struct
)	O
,	O
&	O
is_compressed	pointer
)	O
;	O
if	O
(	O
is_compressed	pointer
)	O
fb	pointer
->	O
flags	int
|=	O
N_IsCompressed	int
;	O
}	O
static	O
long	O
get_node_length	function
(	O
SEARCH_BINDING	struct
*	O
binding	pointer
)	O
;	O
static	O
void	O
node_set_body_start	function
(	O
NODE	struct
*	O
node	pointer
)	O
;	O
static	O
int	O
adjust_nodestart	function
(	O
FILE_BUFFER	struct
*	O
file_buffer	pointer
,	O
TAG	struct
*	O
tag	pointer
)	O
;	O
TAG	struct
*	O
info_create_tag	function
(	O
void	O
)	O
{	O
TAG	struct
*	O
t	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
TAG	struct
)	O
)	O
;	O
memset	function
(	O
t	pointer
,	O
0	int
,	O
sizeof	O
(	O
TAG	struct
)	O
)	O
;	O
t	pointer
->	O
filename	pointer
=	O
0	int
;	O
t	pointer
->	O
nodename	pointer
=	O
0	int
;	O
t	pointer
->	O
nodestart	long
=	O
-	O
1	int
;	O
t	pointer
->	O
nodestart_adjusted	long
=	O
-	O
1	int
;	O
t	pointer
->	O
cache	struct
.	O
nodelen	long
=	O
-	O
1	int
;	O
return	O
t	pointer
;	O
}	O
NODE	struct
*	O
info_create_node	function
(	O
void	O
)	O
{	O
NODE	struct
*	O
n	long
=	O
xmalloc	function
(	O
sizeof	O
(	O
NODE	struct
)	O
)	O
;	O
n	long
->	O
fullpath	pointer
=	O
0	int
;	O
n	long
->	O
subfile	pointer
=	O
0	int
;	O
n	long
->	O
nodename	pointer
=	O
0	int
;	O
n	long
->	O
contents	pointer
=	O
0	int
;	O
n	long
->	O
nodelen	long
=	O
-	O
1	int
;	O
n	long
->	O
display_pos	long
=	O
0	int
;	O
n	long
->	O
body_start	long
=	O
0	int
;	O
n	long
->	O
flags	int
=	O
0	int
;	O
n	long
->	O
references	pointer
=	O
0	int
;	O
n	long
->	O
up	pointer
=	O
0	int
;	O
n	long
->	O
prev	pointer
=	O
0	int
;	O
n	long
->	O
next	pointer
=	O
0	int
;	O
return	O
n	long
;	O
}	O
static	O
long	O
get_node_length	function
(	O
SEARCH_BINDING	struct
*	O
binding	pointer
)	O
{	O
int	O
i	int
;	O
char	O
*	O
body	pointer
;	O
for	O
(	O
i	int
=	O
binding	pointer
->	O
start	int
,	O
body	pointer
=	O
binding	pointer
->	O
buffer	pointer
;	O
i	int
<	O
binding	pointer
->	O
end	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
body	pointer
[	O
i	int
]	O
==	O
INFO_FF	char
||	O
body	pointer
[	O
i	int
]	O
==	O
INFO_COOKIE	char
)	O
break	O
;	O
}	O
return	O
i	int
-	O
binding	pointer
->	O
start	int
;	O
}	O
int	O
follow_strategy	int
;	O
NODE	struct
*	O
info_get_node_with_defaults	function
(	O
char	O
*	O
filename_in	pointer
,	O
char	O
*	O
nodename_in	pointer
,	O
NODE	struct
*	O
defaults	pointer
)	O
{	O
NODE	struct
*	O
node	pointer
=	O
0	int
;	O
FILE_BUFFER	struct
*	O
file_buffer	pointer
=	O
NULL	O
;	O
char	O
*	O
filename	pointer
=	O
0	int
,	O
*	O
nodename	pointer
=	O
0	int
;	O
info_recent_file_error	pointer
=	O
NULL	O
;	O
filename	pointer
=	O
filename_in	pointer
;	O
if	O
(	O
filename_in	pointer
)	O
{	O
filename	pointer
=	O
xstrdup	function
(	O
filename_in	pointer
)	O
;	O
if	O
(	O
follow_strategy	int
==	O
FOLLOW_REMAIN	int
&&	O
defaults	pointer
&&	O
defaults	pointer
->	O
fullpath	pointer
&&	O
filename_in	pointer
)	O
{	O
char	O
*	O
file_in_same_dir	pointer
;	O
char	O
saved_char	char
,	O
*	O
p	pointer
;	O
p	pointer
=	O
defaults	pointer
->	O
fullpath	pointer
+	O
strlen	function
(	O
defaults	pointer
->	O
fullpath	pointer
)	O
;	O
while	O
(	O
p	pointer
>	O
defaults	pointer
->	O
fullpath	pointer
&&	O
!	O
IS_SLASH	O
(	O
*	O
p	pointer
)	O
)	O
p	pointer
--	O
;	O
if	O
(	O
p	pointer
>	O
defaults	pointer
->	O
fullpath	pointer
)	O
{	O
saved_char	char
=	O
*	O
p	pointer
;	O
*	O
p	pointer
=	O
0	int
;	O
file_in_same_dir	pointer
=	O
info_add_extension	function
(	O
defaults	pointer
->	O
fullpath	pointer
,	O
filename	pointer
,	O
0	int
)	O
;	O
*	O
p	pointer
=	O
saved_char	char
;	O
if	O
(	O
file_in_same_dir	pointer
)	O
file_buffer	pointer
=	O
info_find_file	function
(	O
file_in_same_dir	pointer
)	O
;	O
free	function
(	O
file_in_same_dir	pointer
)	O
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
defaults	pointer
)	O
filename	pointer
=	O
xstrdup	function
(	O
defaults	pointer
->	O
fullpath	pointer
)	O
;	O
else	O
filename	pointer
=	O
xstrdup	function
(	O
"dir"	pointer
)	O
;	O
}	O
if	O
(	O
nodename_in	pointer
&&	O
*	O
nodename_in	pointer
)	O
nodename	pointer
=	O
xstrdup	function
(	O
nodename_in	pointer
)	O
;	O
else	O
nodename	pointer
=	O
xstrdup	function
(	O
"Top"	pointer
)	O
;	O
if	O
(	O
is_dir_name	function
(	O
filename	pointer
)	O
)	O
{	O
node	pointer
=	O
get_dir_node	function
(	O
)	O
;	O
goto	O
cleanup_and_exit	O
;	O
}	O
if	O
(	O
mbscasecmp	function
(	O
filename	pointer
,	O
MANPAGE_FILE_BUFFER_NAME	pointer
)	O
==	O
0	int
)	O
{	O
node	pointer
=	O
get_manpage_node	function
(	O
nodename	pointer
)	O
;	O
goto	O
cleanup_and_exit	O
;	O
}	O
if	O
(	O
!	O
file_buffer	pointer
)	O
file_buffer	pointer
=	O
info_find_file	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
file_buffer	pointer
)	O
{	O
node	pointer
=	O
info_get_node_of_file_buffer	function
(	O
file_buffer	pointer
,	O
nodename	pointer
)	O
;	O
}	O
if	O
(	O
!	O
node	pointer
&&	O
(	O
nodename	pointer
&&	O
mbscasecmp	function
(	O
nodename	pointer
,	O
"Top"	pointer
)	O
==	O
0	int
)	O
)	O
{	O
node	pointer
=	O
info_get_node_of_file_buffer	function
(	O
file_buffer	pointer
,	O
"Top"	pointer
)	O
;	O
if	O
(	O
!	O
node	pointer
)	O
node	pointer
=	O
info_get_node_of_file_buffer	function
(	O
file_buffer	pointer
,	O
"top"	pointer
)	O
;	O
if	O
(	O
!	O
node	pointer
)	O
node	pointer
=	O
info_get_node_of_file_buffer	function
(	O
file_buffer	pointer
,	O
"TOP"	pointer
)	O
;	O
}	O
cleanup_and_exit	O
:	O
free	function
(	O
filename	pointer
)	O
;	O
free	function
(	O
nodename	pointer
)	O
;	O
return	O
node	pointer
;	O
}	O
NODE	struct
*	O
info_get_node	function
(	O
char	O
*	O
filename_in	pointer
,	O
char	O
*	O
nodename_in	pointer
)	O
{	O
return	O
info_get_node_with_defaults	function
(	O
filename_in	pointer
,	O
nodename_in	pointer
,	O
0	int
)	O
;	O
}	O
static	O
void	O
node_set_body_start	function
(	O
NODE	struct
*	O
node	pointer
)	O
{	O
int	O
n	long
=	O
skip_node_separator	function
(	O
node	pointer
->	O
contents	pointer
)	O
;	O
node	pointer
->	O
body_start	long
=	O
strcspn	function
(	O
node	pointer
->	O
contents	pointer
+	O
n	long
,	O
"\n"	pointer
)	O
;	O
node	pointer
->	O
body_start	long
+=	O
n	long
;	O
}	O
NODE	struct
*	O
info_get_node_of_file_buffer	function
(	O
FILE_BUFFER	struct
*	O
file_buffer	pointer
,	O
char	O
*	O
nodename	pointer
)	O
{	O
NODE	struct
*	O
node	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
file_buffer	pointer
)	O
return	O
NULL	O
;	O
if	O
(	O
!	O
file_buffer	pointer
->	O
contents	pointer
)	O
info_reload_file_buffer_contents	function
(	O
file_buffer	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
nodename	pointer
,	O
"*"	pointer
)	O
==	O
0	int
)	O
{	O
node	pointer
=	O
info_create_node	function
(	O
)	O
;	O
node	pointer
->	O
fullpath	pointer
=	O
file_buffer	pointer
->	O
fullpath	pointer
;	O
node	pointer
->	O
nodename	pointer
=	O
xstrdup	function
(	O
"*"	pointer
)	O
;	O
node	pointer
->	O
contents	pointer
=	O
file_buffer	pointer
->	O
contents	pointer
;	O
node	pointer
->	O
nodelen	long
=	O
file_buffer	pointer
->	O
filesize	long
;	O
node	pointer
->	O
body_start	long
=	O
0	int
;	O
}	O
else	O
{	O
TAG	struct
*	O
tag	pointer
;	O
int	O
i	int
;	O
if	O
(	O
!	O
file_buffer	pointer
->	O
tags	pointer
)	O
return	O
NULL	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
tag	pointer
=	O
file_buffer	pointer
->	O
tags	pointer
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
if	O
(	O
strcmp	function
(	O
nodename	pointer
,	O
tag	pointer
->	O
nodename	pointer
)	O
==	O
0	int
)	O
{	O
node	pointer
=	O
info_node_of_tag	function
(	O
file_buffer	pointer
,	O
&	O
file_buffer	pointer
->	O
tags	pointer
[	O
i	int
]	O
)	O
;	O
break	O
;	O
}	O
}	O
return	O
node	pointer
;	O
}	O
static	O
int	O
adjust_nodestart	function
(	O
FILE_BUFFER	struct
*	O
fb	pointer
,	O
TAG	struct
*	O
node	pointer
)	O
{	O
long	O
position	long
=	O
-	O
1	int
;	O
SEARCH_BINDING	struct
s	pointer
;	O
s	pointer
.	O
buffer	pointer
=	O
fb	pointer
->	O
contents	pointer
;	O
s	pointer
.	O
start	int
=	O
node	pointer
->	O
nodestart	long
;	O
s	pointer
.	O
end	int
=	O
s	pointer
.	O
start	int
+	O
1	int
;	O
if	O
(	O
s	pointer
.	O
start	int
>=	O
0	int
&&	O
s	pointer
.	O
start	int
<	O
fb	pointer
->	O
filesize	long
)	O
{	O
position	long
=	O
find_node_in_binding	function
(	O
node	pointer
->	O
nodename	pointer
,	O
&	O
s	pointer
)	O
;	O
}	O
if	O
(	O
position	long
==	O
-	O
1	int
)	O
{	O
if	O
(	O
strict_node_location_p	int
)	O
return	O
0	int
;	O
s	pointer
.	O
start	int
-=	O
DEFAULT_INFO_FUDGE	int
;	O
s	pointer
.	O
end	int
+=	O
DEFAULT_INFO_FUDGE	int
;	O
if	O
(	O
s	pointer
.	O
start	int
<	O
0	int
)	O
s	pointer
.	O
start	int
=	O
0	int
;	O
else	O
if	O
(	O
s	pointer
.	O
start	int
>	O
fb	pointer
->	O
filesize	long
)	O
s	pointer
.	O
start	int
=	O
fb	pointer
->	O
filesize	long
;	O
if	O
(	O
s	pointer
.	O
end	int
>	O
fb	pointer
->	O
filesize	long
)	O
s	pointer
.	O
end	int
=	O
fb	pointer
->	O
filesize	long
;	O
position	long
=	O
find_node_in_binding	function
(	O
node	pointer
->	O
nodename	pointer
,	O
&	O
s	pointer
)	O
;	O
if	O
(	O
position	long
==	O
-	O
1	int
)	O
return	O
0	int
;	O
if	O
(	O
node	pointer
->	O
flags	int
&	O
N_HasTagsTable	int
)	O
node	pointer
->	O
flags	int
|=	O
N_UpdateTags	int
;	O
}	O
node	pointer
->	O
nodestart_adjusted	long
=	O
s	pointer
.	O
buffer	pointer
+	O
position	long
-	O
fb	pointer
->	O
contents	pointer
;	O
return	O
1	int
;	O
}	O
static	O
int	O
find_node_from_tag	function
(	O
FILE_BUFFER	struct
*	O
parent	pointer
,	O
FILE_BUFFER	struct
*	O
fb	pointer
,	O
TAG	struct
*	O
tag	pointer
)	O
{	O
int	O
success	int
;	O
if	O
(	O
tag	pointer
->	O
nodestart_adjusted	long
!=	O
-	O
1	int
)	O
success	int
=	O
1	int
;	O
else	O
success	int
=	O
adjust_nodestart	function
(	O
fb	pointer
,	O
tag	pointer
)	O
;	O
if	O
(	O
success	int
)	O
return	O
success	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
set_tag_nodelen	function
(	O
FILE_BUFFER	struct
*	O
subfile	pointer
,	O
TAG	struct
*	O
tag	pointer
)	O
{	O
SEARCH_BINDING	struct
node_body	struct
;	O
node_body	struct
.	O
buffer	pointer
=	O
subfile	pointer
->	O
contents	pointer
;	O
node_body	struct
.	O
start	int
=	O
tag	pointer
->	O
nodestart_adjusted	long
;	O
node_body	struct
.	O
end	int
=	O
subfile	pointer
->	O
filesize	long
;	O
node_body	struct
.	O
flags	int
=	O
0	int
;	O
node_body	struct
.	O
start	int
+=	O
skip_node_separator	function
(	O
node_body	struct
.	O
buffer	pointer
+	O
node_body	struct
.	O
start	int
)	O
;	O
tag	pointer
->	O
cache	struct
.	O
nodelen	long
=	O
get_node_length	function
(	O
&	O
node_body	struct
)	O
;	O
}	O
static	O
NODE	struct
*	O
info_node_of_tag_ext	function
(	O
FILE_BUFFER	struct
*	O
fb	pointer
,	O
TAG	struct
*	O
*	O
tag_ptr	pointer
,	O
int	O
fast	int
)	O
{	O
TAG	struct
*	O
tag	pointer
=	O
*	O
tag_ptr	pointer
;	O
NODE	struct
*	O
node	pointer
;	O
int	O
is_anchor	int
;	O
TAG	struct
*	O
anchor_tag	pointer
;	O
int	O
node_pos	int
,	O
anchor_pos	int
;	O
FILE_BUFFER	struct
*	O
parent	pointer
;	O
FILE_BUFFER	struct
*	O
subfile	pointer
;	O
if	O
(	O
!	O
FILENAME_CMP	O
(	O
fb	pointer
->	O
fullpath	pointer
,	O
tag	pointer
->	O
filename	pointer
)	O
)	O
parent	pointer
=	O
subfile	pointer
=	O
fb	pointer
;	O
else	O
{	O
parent	pointer
=	O
fb	pointer
;	O
subfile	pointer
=	O
info_find_subfile	function
(	O
tag	pointer
->	O
filename	pointer
)	O
;	O
}	O
if	O
(	O
!	O
subfile	pointer
)	O
return	O
NULL	O
;	O
if	O
(	O
!	O
subfile	pointer
->	O
contents	pointer
)	O
{	O
info_reload_file_buffer_contents	function
(	O
subfile	pointer
)	O
;	O
if	O
(	O
!	O
subfile	pointer
->	O
contents	pointer
)	O
return	O
NULL	O
;	O
}	O
if	O
(	O
!	O
(	O
tag	pointer
->	O
nodestart	long
>=	O
0	int
&&	O
tag	pointer
->	O
nodestart	long
<	O
subfile	pointer
->	O
filesize	long
)	O
)	O
return	O
NULL	O
;	O
node	pointer
=	O
0	int
;	O
is_anchor	int
=	O
tag	pointer
->	O
cache	struct
.	O
nodelen	long
==	O
0	int
;	O
if	O
(	O
is_anchor	int
)	O
{	O
anchor_pos	int
=	O
tag_ptr	pointer
-	O
fb	pointer
->	O
tags	pointer
;	O
for	O
(	O
node_pos	int
=	O
anchor_pos	int
-	O
1	int
;	O
node_pos	int
>=	O
0	int
&&	O
fb	pointer
->	O
tags	pointer
[	O
node_pos	int
]	O
->	O
cache	struct
.	O
nodelen	long
==	O
0	int
;	O
node_pos	int
--	O
)	O
;	O
if	O
(	O
node_pos	int
<	O
0	int
)	O
return	O
NULL	O
;	O
anchor_tag	pointer
=	O
tag	pointer
;	O
tag	pointer
=	O
fb	pointer
->	O
tags	pointer
[	O
node_pos	int
]	O
;	O
tag_ptr	pointer
=	O
&	O
fb	pointer
->	O
tags	pointer
[	O
node_pos	int
]	O
;	O
}	O
if	O
(	O
tag	pointer
->	O
cache	struct
.	O
nodelen	long
==	O
-	O
1	int
)	O
{	O
if	O
(	O
!	O
find_node_from_tag	function
(	O
parent	pointer
,	O
subfile	pointer
,	O
tag	pointer
)	O
)	O
return	O
NULL	O
;	O
set_tag_nodelen	function
(	O
subfile	pointer
,	O
tag	pointer
)	O
;	O
}	O
node	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
NODE	struct
)	O
)	O
;	O
memset	function
(	O
node	pointer
,	O
0	int
,	O
sizeof	O
(	O
NODE	struct
)	O
)	O
;	O
if	O
(	O
tag	pointer
->	O
cache	struct
.	O
references	pointer
)	O
{	O
*	O
node	pointer
=	O
tag	pointer
->	O
cache	struct
;	O
if	O
(	O
!	O
node	pointer
->	O
contents	pointer
)	O
{	O
node	pointer
->	O
contents	pointer
=	O
subfile	pointer
->	O
contents	pointer
+	O
tag	pointer
->	O
nodestart_adjusted	long
;	O
node	pointer
->	O
contents	pointer
+=	O
skip_node_separator	function
(	O
node	pointer
->	O
contents	pointer
)	O
;	O
}	O
}	O
else	O
{	O
node	pointer
->	O
contents	pointer
=	O
subfile	pointer
->	O
contents	pointer
+	O
tag	pointer
->	O
nodestart_adjusted	long
;	O
node	pointer
->	O
contents	pointer
+=	O
skip_node_separator	function
(	O
node	pointer
->	O
contents	pointer
)	O
;	O
node	pointer
->	O
nodelen	long
=	O
tag	pointer
->	O
cache	struct
.	O
nodelen	long
;	O
node	pointer
->	O
nodename	pointer
=	O
tag	pointer
->	O
nodename	pointer
;	O
node	pointer
->	O
flags	int
=	O
tag	pointer
->	O
flags	int
;	O
node	pointer
->	O
fullpath	pointer
=	O
parent	pointer
->	O
fullpath	pointer
;	O
if	O
(	O
parent	pointer
!=	O
subfile	pointer
)	O
node	pointer
->	O
subfile	pointer
=	O
tag	pointer
->	O
filename	pointer
;	O
if	O
(	O
fast	int
)	O
node	pointer
->	O
flags	int
|=	O
N_Simple	int
;	O
else	O
{	O
scan_node_contents	function
(	O
node	pointer
,	O
parent	pointer
,	O
tag_ptr	pointer
)	O
;	O
node_set_body_start	function
(	O
node	pointer
)	O
;	O
tag	pointer
->	O
cache	struct
=	O
*	O
node	pointer
;	O
if	O
(	O
!	O
(	O
node	pointer
->	O
flags	int
&	O
N_WasRewritten	int
)	O
)	O
tag	pointer
->	O
cache	struct
.	O
contents	pointer
=	O
0	int
;	O
}	O
}	O
if	O
(	O
subfile	pointer
->	O
flags	int
&	O
N_IsCompressed	int
)	O
node	pointer
->	O
flags	int
|=	O
N_IsCompressed	int
;	O
if	O
(	O
is_anchor	int
)	O
{	O
node	pointer
->	O
display_pos	long
=	O
anchor_tag	pointer
->	O
nodestart_adjusted	long
-	O
(	O
tag	pointer
->	O
nodestart_adjusted	long
+	O
skip_node_separator	function
(	O
subfile	pointer
->	O
contents	pointer
+	O
tag	pointer
->	O
nodestart_adjusted	long
)	O
)	O
;	O
if	O
(	O
node	pointer
->	O
display_pos	long
>=	O
(	O
unsigned	O
long	O
)	O
node	pointer
->	O
nodelen	long
)	O
node	pointer
->	O
display_pos	long
=	O
node	pointer
->	O
nodelen	long
-	O
1	int
;	O
else	O
if	O
(	O
node	pointer
->	O
display_pos	long
<	O
0	int
)	O
node	pointer
->	O
display_pos	long
=	O
0	int
;	O
}	O
return	O
node	pointer
;	O
}	O
NODE	struct
*	O
info_node_of_tag	function
(	O
FILE_BUFFER	struct
*	O
fb	pointer
,	O
TAG	struct
*	O
*	O
tag_ptr	pointer
)	O
{	O
return	O
info_node_of_tag_ext	function
(	O
fb	pointer
,	O
tag_ptr	pointer
,	O
0	int
)	O
;	O
}	O
NODE	struct
*	O
info_node_of_tag_fast	function
(	O
FILE_BUFFER	struct
*	O
fb	pointer
,	O
TAG	struct
*	O
*	O
tag_ptr	pointer
)	O
{	O
return	O
info_node_of_tag_ext	function
(	O
fb	pointer
,	O
tag_ptr	pointer
,	O
1	int
)	O
;	O
}	O
