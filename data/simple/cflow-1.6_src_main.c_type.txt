const	O
char	O
*	O
argp_program_bug_address	pointer
=	O
"<"	pointer
PACKAGE_BUGREPORT	pointer
">"	pointer
;	O
static	O
char	O
doc	pointer
[	O
]	O
=	O
N_	O
(	O
"generate a program flowgraph"	pointer
)	O
"\v"	pointer
N_	O
(	O
"* The effect of each option marked with an asterisk is reversed if the option's long name is prefixed with `no-'. For example, --no-cpp cancels --cpp."	pointer
)	O
;	O
const	O
char	O
*	O
program_authors	array
[	O
]	O
=	O
{	O
"Sergey Poznyakoff"	pointer
,	O
NULL	O
}	O
;	O
enum	O
option_code	enum
{	O
OPT_DEFINES	int
=	O
256	int
,	O
OPT_LEVEL_INDENT	int
,	O
OPT_DEBUG	int
,	O
OPT_PREPROCESS	int
,	O
OPT_NO_PREPROCESS	int
,	O
OPT_EMACS	int
,	O
OPT_NO_USE_INDENTATION	int
,	O
OPT_NO_ANSI	int
,	O
OPT_NO_TREE	int
,	O
OPT_NO_BRIEF	int
,	O
OPT_NO_EMACS	int
,	O
OPT_NO_MAIN	int
,	O
OPT_NO_VERBOSE	int
,	O
OPT_NO_NUMBER	int
,	O
OPT_NO_PRINT_LEVEL	int
,	O
OPT_NO_REVERSE	int
,	O
OPT_OMIT_ARGUMENTS	int
,	O
OPT_NO_OMIT_ARGUMENTS	int
,	O
OPT_OMIT_SYMBOL_NAMES	int
,	O
OPT_NO_OMIT_SYMBOL_NAMES	int
}	O
;	O
static	O
struct	O
argp_option	struct
options	pointer
[	O
]	O
=	O
{	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"General options:"	pointer
)	O
,	O
GROUP_ID	int
}	O
,	O
{	O
"depth"	pointer
,	O
'd'	O
,	O
N_	O
(	O
"NUMBER"	pointer
)	O
,	O
0	int
,	O
N_	O
(	O
"Set the depth at which the flowgraph is cut off"	pointer
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"include"	pointer
,	O
'i'	O
,	O
N_	O
(	O
"CLASSES"	pointer
)	O
,	O
0	int
,	O
N_	O
(	O
"Include specified classes of symbols (see below). Prepend CLASSES with ^ or - to exclude them from the output"	pointer
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"format"	pointer
,	O
'f'	O
,	O
N_	O
(	O
"NAME"	pointer
)	O
,	O
0	int
,	O
N_	O
(	O
"Use given output format NAME. Valid names are `gnu' (default) and `posix'"	pointer
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"reverse"	pointer
,	O
'r'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"* Print reverse call tree"	pointer
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"xref"	pointer
,	O
'x'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Produce cross-reference listing only"	pointer
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"print"	pointer
,	O
'P'	O
,	O
N_	O
(	O
"OPT"	pointer
)	O
,	O
OPTION_HIDDEN	int
,	O
N_	O
(	O
"Set printing option to OPT. Valid OPT values are: xref (or cross-ref), tree. Any unambiguous abbreviation of the above is also accepted"	pointer
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"output"	pointer
,	O
'o'	O
,	O
N_	O
(	O
"FILE"	pointer
)	O
,	O
0	int
,	O
N_	O
(	O
"Set output file name (default -, meaning stdout)"	pointer
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Symbols classes for --include argument"	pointer
)	O
,	O
GROUP_ID	int
+	O
2	int
}	O
,	O
{	O
"  x"	pointer
,	O
0	int
,	O
NULL	O
,	O
OPTION_DOC	int
|	O
OPTION_NO_TRANS	int
,	O
N_	O
(	O
"all data symbols, both external and static"	pointer
)	O
,	O
GROUP_ID	int
+	O
3	int
}	O
,	O
{	O
"  _"	pointer
,	O
0	int
,	O
NULL	O
,	O
OPTION_DOC	int
|	O
OPTION_NO_TRANS	int
,	O
N_	O
(	O
"symbols whose names begin with an underscore"	pointer
)	O
,	O
GROUP_ID	int
+	O
3	int
}	O
,	O
{	O
"  s"	pointer
,	O
0	int
,	O
NULL	O
,	O
OPTION_DOC	int
|	O
OPTION_NO_TRANS	int
,	O
N_	O
(	O
"static symbols"	pointer
)	O
,	O
GROUP_ID	int
+	O
3	int
}	O
,	O
{	O
"  t"	pointer
,	O
0	int
,	O
NULL	O
,	O
OPTION_DOC	int
|	O
OPTION_NO_TRANS	int
,	O
N_	O
(	O
"typedefs (for cross-references only)"	pointer
)	O
,	O
GROUP_ID	int
+	O
3	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Parser control:"	pointer
)	O
,	O
GROUP_ID	int
}	O
,	O
{	O
"use-indentation"	pointer
,	O
'S'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"* Rely on indentation"	pointer
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"no-use-indentation"	pointer
,	O
OPT_NO_USE_INDENTATION	int
,	O
NULL	O
,	O
OPTION_HIDDEN	int
,	O
""	pointer
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"ansi"	pointer
,	O
'a'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"* Accept only sources in ANSI C"	pointer
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"no-ansi"	pointer
,	O
OPT_NO_ANSI	int
,	O
NULL	O
,	O
OPTION_HIDDEN	int
,	O
""	pointer
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"pushdown"	pointer
,	O
'p'	O
,	O
N_	O
(	O
"NUMBER"	pointer
)	O
,	O
0	int
,	O
N_	O
(	O
"Set initial token stack size to NUMBER"	pointer
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"symbol"	pointer
,	O
's'	O
,	O
N_	O
(	O
"SYMBOL:[=]TYPE"	pointer
)	O
,	O
0	int
,	O
N_	O
(	O
"Register SYMBOL with given TYPE, or define an alias (if := is used). Valid types are: keyword (or kw), modifier, qualifier, identifier, type, wrapper. Any unambiguous abbreviation of the above is also accepted"	pointer
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"main"	pointer
,	O
'm'	O
,	O
N_	O
(	O
"NAME"	pointer
)	O
,	O
0	int
,	O
N_	O
(	O
"Assume main function to be called NAME"	pointer
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"no-main"	pointer
,	O
OPT_NO_MAIN	int
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"There's no main function; print graphs for all functions in the program"	pointer
)	O
}	O
,	O
{	O
"define"	pointer
,	O
'D'	O
,	O
N_	O
(	O
"NAME[=DEFN]"	pointer
)	O
,	O
0	int
,	O
N_	O
(	O
"Predefine NAME as a macro"	pointer
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"undefine"	pointer
,	O
'U'	O
,	O
N_	O
(	O
"NAME"	pointer
)	O
,	O
0	int
,	O
N_	O
(	O
"Cancel any previous definition of NAME"	pointer
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"include-dir"	pointer
,	O
'I'	O
,	O
N_	O
(	O
"DIR"	pointer
)	O
,	O
0	int
,	O
N_	O
(	O
"Add the directory DIR to the list of directories to be searched for header files."	pointer
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"preprocess"	pointer
,	O
OPT_PREPROCESS	int
,	O
N_	O
(	O
"COMMAND"	pointer
)	O
,	O
OPTION_ARG_OPTIONAL	int
,	O
N_	O
(	O
"* Run the specified preprocessor command"	pointer
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"cpp"	pointer
,	O
0	int
,	O
NULL	O
,	O
OPTION_ALIAS	int
,	O
NULL	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"no-preprocess"	pointer
,	O
OPT_NO_PREPROCESS	int
,	O
NULL	O
,	O
OPTION_HIDDEN	int
,	O
""	pointer
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"no-cpp"	pointer
,	O
0	int
,	O
NULL	O
,	O
OPTION_ALIAS	int
|	O
OPTION_HIDDEN	int
,	O
NULL	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Output control:"	pointer
)	O
,	O
GROUP_ID	int
}	O
,	O
{	O
"all"	pointer
,	O
'A'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Show all functions, not only those reachable from main"	pointer
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"number"	pointer
,	O
'n'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"* Print line numbers"	pointer
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"no-number"	pointer
,	O
OPT_NO_NUMBER	int
,	O
NULL	O
,	O
OPTION_HIDDEN	int
,	O
""	pointer
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"print-level"	pointer
,	O
'l'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"* Print nesting level along with the call tree"	pointer
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"no-print-level"	pointer
,	O
OPT_NO_PRINT_LEVEL	int
,	O
NULL	O
,	O
OPTION_HIDDEN	int
,	O
""	pointer
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"level-indent"	pointer
,	O
OPT_LEVEL_INDENT	int
,	O
"ELEMENT"	pointer
,	O
0	int
,	O
N_	O
(	O
"Control graph appearance"	pointer
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"tree"	pointer
,	O
'T'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"* Draw ASCII art tree"	pointer
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"no-tree"	pointer
,	O
OPT_NO_TREE	int
,	O
NULL	O
,	O
OPTION_HIDDEN	int
,	O
""	pointer
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"brief"	pointer
,	O
'b'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"* Brief output"	pointer
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"no-brief"	pointer
,	O
OPT_NO_BRIEF	int
,	O
NULL	O
,	O
OPTION_HIDDEN	int
,	O
""	pointer
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"emacs"	pointer
,	O
OPT_EMACS	int
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"* Additionally format output for use with GNU Emacs"	pointer
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"no-emacs"	pointer
,	O
OPT_NO_EMACS	int
,	O
NULL	O
,	O
OPTION_HIDDEN	int
,	O
""	pointer
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"omit-arguments"	pointer
,	O
OPT_OMIT_ARGUMENTS	int
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"* Do not print argument lists in function declarations"	pointer
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"no-ignore-arguments"	pointer
,	O
OPT_NO_OMIT_ARGUMENTS	int
,	O
NULL	O
,	O
OPTION_HIDDEN	int
,	O
""	pointer
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"omit-symbol-names"	pointer
,	O
OPT_OMIT_SYMBOL_NAMES	int
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"* Do not print symbol names in declaration strings"	pointer
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"no-omit-symbol-names"	pointer
,	O
OPT_NO_OMIT_SYMBOL_NAMES	int
,	O
NULL	O
,	O
OPTION_HIDDEN	int
,	O
""	pointer
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Informational options:"	pointer
)	O
,	O
GROUP_ID	int
}	O
,	O
{	O
"verbose"	pointer
,	O
'v'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"* Verbose error diagnostics"	pointer
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"no-verbose"	pointer
,	O
OPT_NO_VERBOSE	int
,	O
NULL	O
,	O
OPTION_HIDDEN	int
,	O
""	pointer
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
"debug"	pointer
,	O
OPT_DEBUG	int
,	O
"NUMBER"	pointer
,	O
OPTION_ARG_OPTIONAL	int
,	O
N_	O
(	O
"Set debugging level"	pointer
)	O
,	O
GROUP_ID	int
+	O
1	int
}	O
,	O
{	O
0	int
,	O
}	O
}	O
;	O
struct	O
option_type	struct
{	O
char	O
*	O
str	pointer
;	O
int	O
min_match	int
;	O
int	O
type	enum
;	O
}	O
;	O
int	O
debug	int
;	O
char	O
*	O
outname	pointer
=	O
"-"	pointer
;	O
int	O
print_option	int
=	O
0	int
;	O
int	O
verbose	int
;	O
int	O
use_indentation	int
;	O
int	O
record_defines	int
;	O
int	O
strict_ansi	int
;	O
int	O
print_line_numbers	int
;	O
int	O
print_levels	int
;	O
int	O
print_as_tree	int
;	O
int	O
brief_listing	int
;	O
int	O
reverse_tree	int
;	O
int	O
max_depth	int
;	O
int	O
emacs_option	int
;	O
int	O
omit_arguments_option	int
;	O
int	O
omit_symbol_names_option	int
;	O
int	O
symbol_map	int
;	O
char	O
*	O
level_indent	array
[	O
]	O
=	O
{	O
NULL	O
,	O
NULL	O
}	O
;	O
char	O
*	O
level_end	array
[	O
]	O
=	O
{	O
""	pointer
,	O
""	pointer
}	O
;	O
char	O
*	O
level_begin	pointer
=	O
""	pointer
;	O
int	O
preprocess_option	int
=	O
0	int
;	O
char	O
*	O
start_name	pointer
=	O
"main"	pointer
;	O
int	O
all_functions	int
;	O
struct	O
linked_list	struct
*	O
arglist	pointer
;	O
static	O
int	O
find_option_type	function
(	O
struct	O
option_type	struct
*	O
optype	pointer
,	O
const	O
char	O
*	O
str	pointer
,	O
int	O
len	int
)	O
{	O
if	O
(	O
len	int
==	O
0	int
)	O
len	int
=	O
strlen	function
(	O
str	pointer
)	O
;	O
for	O
(	O
;	O
optype	pointer
->	O
str	pointer
;	O
optype	pointer
++	O
)	O
{	O
if	O
(	O
len	int
>=	O
optype	pointer
->	O
min_match	int
&&	O
memcmp	function
(	O
str	pointer
,	O
optype	pointer
->	O
str	pointer
,	O
len	int
)	O
==	O
0	int
)	O
{	O
return	O
optype	pointer
->	O
type	enum
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
option_type	struct
symbol_optype	array
[	O
]	O
=	O
{	O
{	O
"keyword"	pointer
,	O
2	int
,	O
WORD	int
}	O
,	O
{	O
"kw"	pointer
,	O
2	int
,	O
WORD	int
}	O
,	O
{	O
"modifier"	pointer
,	O
1	int
,	O
MODIFIER	int
}	O
,	O
{	O
"identifier"	pointer
,	O
1	int
,	O
IDENTIFIER	int
}	O
,	O
{	O
"type"	pointer
,	O
1	int
,	O
TYPE	int
}	O
,	O
{	O
"wrapper"	pointer
,	O
1	int
,	O
PARM_WRAPPER	int
}	O
,	O
{	O
"qualifier"	pointer
,	O
1	int
,	O
QUALIFIER	int
}	O
,	O
{	O
0	int
}	O
,	O
}	O
;	O
static	O
void	O
symbol_override	function
(	O
const	O
char	O
*	O
str	pointer
)	O
{	O
const	O
char	O
*	O
ptr	pointer
;	O
char	O
*	O
name	pointer
;	O
Symbol	struct
*	O
sp	pointer
;	O
ptr	pointer
=	O
strchr	function
(	O
str	pointer
,	O
':'	O
)	O
;	O
if	O
(	O
!	O
ptr	pointer
)	O
error	function
(	O
EX_USAGE	int
,	O
0	int
,	O
_	O
(	O
"%s: no symbol type supplied"	pointer
)	O
,	O
str	pointer
)	O
;	O
else	O
{	O
name	pointer
=	O
strndup	function
(	O
str	pointer
,	O
ptr	pointer
-	O
str	pointer
)	O
;	O
if	O
(	O
ptr	pointer
[	O
1	int
]	O
==	O
'='	O
)	O
{	O
Symbol	struct
*	O
alias	pointer
=	O
lookup	function
(	O
ptr	pointer
+	O
2	int
)	O
;	O
if	O
(	O
!	O
alias	pointer
)	O
{	O
alias	pointer
=	O
install	function
(	O
xstrdup	function
(	O
ptr	pointer
+	O
2	int
)	O
,	O
INSTALL_OVERWRITE	int
)	O
;	O
alias	pointer
->	O
type	enum
=	O
SymToken	int
;	O
alias	pointer
->	O
token_type	int
=	O
0	int
;	O
alias	pointer
->	O
source	pointer
=	O
NULL	O
;	O
alias	pointer
->	O
def_line	int
=	O
-	O
1	int
;	O
alias	pointer
->	O
ref_line	pointer
=	O
NULL	O
;	O
}	O
sp	pointer
=	O
install	function
(	O
name	pointer
,	O
INSTALL_OVERWRITE	int
)	O
;	O
sp	pointer
->	O
type	enum
=	O
SymToken	int
;	O
sp	pointer
->	O
alias	pointer
=	O
alias	pointer
;	O
sp	pointer
->	O
flag	pointer
=	O
symbol_alias	int
;	O
}	O
else	O
{	O
int	O
type	enum
=	O
find_option_type	function
(	O
symbol_optype	array
,	O
ptr	pointer
+	O
1	int
,	O
0	int
)	O
;	O
if	O
(	O
type	enum
==	O
0	int
)	O
error	function
(	O
EX_USAGE	int
,	O
0	int
,	O
_	O
(	O
"unknown symbol type: %s"	pointer
)	O
,	O
ptr	pointer
+	O
1	int
)	O
;	O
sp	pointer
=	O
install	function
(	O
name	pointer
,	O
INSTALL_OVERWRITE	int
)	O
;	O
sp	pointer
->	O
type	enum
=	O
SymToken	int
;	O
sp	pointer
->	O
token_type	int
=	O
type	enum
;	O
}	O
sp	pointer
->	O
source	pointer
=	O
NULL	O
;	O
sp	pointer
->	O
def_line	int
=	O
-	O
1	int
;	O
sp	pointer
->	O
ref_line	pointer
=	O
NULL	O
;	O
}	O
}	O
static	O
struct	O
option_type	struct
print_optype	array
[	O
]	O
=	O
{	O
{	O
"xref"	pointer
,	O
1	int
,	O
PRINT_XREF	int
}	O
,	O
{	O
"cross-ref"	pointer
,	O
1	int
,	O
PRINT_XREF	int
}	O
,	O
{	O
"tree"	pointer
,	O
1	int
,	O
PRINT_TREE	int
}	O
,	O
{	O
0	int
}	O
,	O
}	O
;	O
static	O
void	O
set_print_option	function
(	O
char	O
*	O
str	pointer
)	O
{	O
int	O
opt	int
;	O
opt	int
=	O
find_option_type	function
(	O
print_optype	array
,	O
str	pointer
,	O
0	int
)	O
;	O
if	O
(	O
opt	int
==	O
0	int
)	O
{	O
error	function
(	O
EX_USAGE	int
,	O
0	int
,	O
_	O
(	O
"unknown print option: %s"	pointer
)	O
,	O
str	pointer
)	O
;	O
return	O
;	O
}	O
print_option	int
|=	O
opt	int
;	O
}	O
static	O
int	O
number	function
(	O
const	O
char	O
*	O
*	O
str_ptr	pointer
,	O
int	O
base	int
,	O
int	O
count	long
)	O
{	O
int	O
c	int
,	O
n	long
;	O
unsigned	O
i	long
;	O
const	O
char	O
*	O
str	pointer
=	O
*	O
str_ptr	pointer
;	O
for	O
(	O
n	long
=	O
0	int
;	O
*	O
str	pointer
&&	O
count	long
;	O
count	long
--	O
)	O
{	O
c	int
=	O
*	O
str	pointer
++	O
;	O
if	O
(	O
isdigit	function
(	O
c	int
)	O
)	O
i	long
=	O
c	int
-	O
'0'	O
;	O
else	O
i	long
=	O
toupper	function
(	O
c	int
)	O
-	O
'A'	O
+	O
10	int
;	O
if	O
(	O
i	long
>	O
base	int
)	O
{	O
break	O
;	O
}	O
n	long
=	O
n	long
*	O
base	int
+	O
i	long
;	O
}	O
*	O
str_ptr	pointer
=	O
str	pointer
-	O
1	int
;	O
return	O
n	long
;	O
}	O
static	O
struct	O
option_type	struct
level_indent_optype	array
[	O
]	O
=	O
{	O
{	O
"begin"	pointer
,	O
1	int
,	O
LEVEL_BEGIN	int
}	O
,	O
{	O
"start"	pointer
,	O
1	int
,	O
LEVEL_BEGIN	int
}	O
,	O
{	O
"0"	pointer
,	O
1	int
,	O
LEVEL_INDENT0	int
}	O
,	O
{	O
"1"	pointer
,	O
1	int
,	O
LEVEL_INDENT1	int
}	O
,	O
{	O
"end0"	pointer
,	O
4	int
,	O
LEVEL_END0	int
}	O
,	O
{	O
"end1"	pointer
,	O
4	int
,	O
LEVEL_END1	int
}	O
,	O
}	O
;	O
static	O
void	O
parse_level_string	function
(	O
const	O
char	O
*	O
str	pointer
,	O
char	O
*	O
*	O
return_ptr	pointer
)	O
{	O
static	O
char	O
text	array
[	O
MAXLEVELINDENT	int
]	O
;	O
char	O
*	O
p	pointer
;	O
int	O
i	long
,	O
c	int
,	O
num	int
;	O
p	pointer
=	O
text	array
;	O
memset	function
(	O
text	array
,	O
' '	O
,	O
sizeof	O
(	O
text	array
)	O
)	O
;	O
text	array
[	O
sizeof	O
(	O
text	array
)	O
-	O
1	int
]	O
=	O
0	int
;	O
while	O
(	O
*	O
str	pointer
)	O
{	O
switch	O
(	O
*	O
str	pointer
)	O
{	O
case	O
'\\'	O
:	O
switch	O
(	O
*	O
++	O
str	pointer
)	O
{	O
case	O
'a'	O
:	O
*	O
p	pointer
++	O
=	O
'\a'	O
;	O
break	O
;	O
case	O
'b'	O
:	O
*	O
p	pointer
++	O
=	O
'\b'	O
;	O
break	O
;	O
case	O
'e'	O
:	O
*	O
p	pointer
++	O
=	O
'\033'	O
;	O
break	O
;	O
case	O
'f'	O
:	O
*	O
p	pointer
++	O
=	O
'\f'	O
;	O
break	O
;	O
case	O
'n'	O
:	O
*	O
p	pointer
++	O
=	O
'\n'	O
;	O
break	O
;	O
case	O
'r'	O
:	O
*	O
p	pointer
++	O
=	O
'\r'	O
;	O
break	O
;	O
case	O
't'	O
:	O
*	O
p	pointer
++	O
=	O
'\t'	O
;	O
break	O
;	O
case	O
'x'	O
:	O
case	O
'X'	O
:	O
++	O
str	pointer
;	O
*	O
p	pointer
++	O
=	O
number	function
(	O
&	O
str	pointer
,	O
16	int
,	O
2	int
)	O
;	O
break	O
;	O
case	O
'0'	O
:	O
++	O
str	pointer
;	O
*	O
p	pointer
++	O
=	O
number	function
(	O
&	O
str	pointer
,	O
8	int
,	O
3	int
)	O
;	O
break	O
;	O
default	O
:	O
*	O
p	pointer
++	O
=	O
*	O
str	pointer
;	O
}	O
++	O
str	pointer
;	O
break	O
;	O
case	O
'x'	O
:	O
if	O
(	O
p	pointer
==	O
text	array
)	O
{	O
goto	O
copy	O
;	O
}	O
num	int
=	O
strtol	function
(	O
str	pointer
+	O
1	int
,	O
(	O
char	O
*	O
*	O
)	O
&	O
str	pointer
,	O
10	int
)	O
;	O
c	int
=	O
p	pointer
[	O
-	O
1	int
]	O
;	O
for	O
(	O
i	long
=	O
1	int
;	O
i	long
<	O
num	int
;	O
i	long
++	O
)	O
{	O
*	O
p	pointer
++	O
=	O
c	int
;	O
if	O
(	O
*	O
p	pointer
==	O
0	int
)	O
error	function
(	O
EX_USAGE	int
,	O
0	int
,	O
_	O
(	O
"level indent string is too long"	pointer
)	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
copy	O
:	O
*	O
p	pointer
++	O
=	O
*	O
str	pointer
++	O
;	O
if	O
(	O
*	O
p	pointer
==	O
0	int
)	O
error	function
(	O
EX_USAGE	int
,	O
0	int
,	O
_	O
(	O
"level indent string is too long"	pointer
)	O
)	O
;	O
}	O
}	O
*	O
p	pointer
=	O
0	int
;	O
*	O
return_ptr	pointer
=	O
strdup	function
(	O
text	array
)	O
;	O
}	O
static	O
void	O
set_level_indent	function
(	O
const	O
char	O
*	O
str	pointer
)	O
{	O
long	O
n	long
;	O
const	O
char	O
*	O
p	pointer
;	O
char	O
*	O
q	pointer
;	O
n	long
=	O
strtol	function
(	O
str	pointer
,	O
&	O
q	pointer
,	O
0	int
)	O
;	O
if	O
(	O
*	O
q	pointer
==	O
0	int
&&	O
n	long
>	O
0	int
)	O
{	O
char	O
*	O
s	long
=	O
xmalloc	function
(	O
n	long
+	O
1	int
)	O
;	O
memset	function
(	O
s	long
,	O
' '	O
,	O
n	long
-	O
1	int
)	O
;	O
s	long
[	O
n	long
-	O
1	int
]	O
=	O
0	int
;	O
level_indent	array
[	O
0	int
]	O
=	O
level_indent	array
[	O
1	int
]	O
=	O
s	long
;	O
return	O
;	O
}	O
p	pointer
=	O
str	pointer
;	O
while	O
(	O
*	O
p	pointer
!=	O
'='	O
)	O
{	O
if	O
(	O
*	O
p	pointer
==	O
0	int
)	O
error	function
(	O
EX_USAGE	int
,	O
0	int
,	O
_	O
(	O
"level-indent syntax"	pointer
)	O
)	O
;	O
p	pointer
++	O
;	O
}	O
++	O
p	pointer
;	O
switch	O
(	O
find_option_type	function
(	O
level_indent_optype	array
,	O
str	pointer
,	O
p	pointer
-	O
str	pointer
-	O
1	int
)	O
)	O
{	O
case	O
LEVEL_BEGIN	int
:	O
parse_level_string	function
(	O
p	pointer
,	O
&	O
level_begin	pointer
)	O
;	O
break	O
;	O
case	O
LEVEL_INDENT0	int
:	O
parse_level_string	function
(	O
p	pointer
,	O
&	O
level_indent	array
[	O
0	int
]	O
)	O
;	O
break	O
;	O
case	O
LEVEL_INDENT1	int
:	O
parse_level_string	function
(	O
p	pointer
,	O
&	O
level_indent	array
[	O
1	int
]	O
)	O
;	O
break	O
;	O
case	O
LEVEL_END0	int
:	O
parse_level_string	function
(	O
p	pointer
,	O
&	O
level_end	array
[	O
0	int
]	O
)	O
;	O
break	O
;	O
case	O
LEVEL_END1	int
:	O
parse_level_string	function
(	O
p	pointer
,	O
&	O
level_end	array
[	O
1	int
]	O
)	O
;	O
break	O
;	O
default	O
:	O
error	function
(	O
EX_USAGE	int
,	O
0	int
,	O
_	O
(	O
"unknown level indent option: %s"	pointer
)	O
,	O
str	pointer
)	O
;	O
}	O
}	O
static	O
void	O
add_name	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
linked_list_append	function
(	O
&	O
arglist	pointer
,	O
(	O
void	O
*	O
)	O
name	pointer
)	O
;	O
}	O
static	O
void	O
add_preproc_option	function
(	O
int	O
key	int
,	O
const	O
char	O
*	O
arg	pointer
)	O
{	O
char	O
*	O
opt	int
=	O
xmalloc	function
(	O
3	int
+	O
strlen	function
(	O
arg	pointer
)	O
)	O
;	O
sprintf	function
(	O
opt	int
,	O
"-%c%s"	pointer
,	O
key	int
,	O
arg	pointer
)	O
;	O
add_name	function
(	O
opt	int
)	O
;	O
preprocess_option	int
=	O
1	int
;	O
}	O
static	O
error_t	int
parse_opt	function
(	O
int	O
key	int
,	O
char	O
*	O
arg	pointer
,	O
struct	O
argp_state	struct
*	O
state	pointer
)	O
{	O
int	O
num	int
;	O
switch	O
(	O
key	int
)	O
{	O
case	O
'A'	O
:	O
all_functions	int
++	O
;	O
break	O
;	O
case	O
'a'	O
:	O
strict_ansi	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NO_ANSI	int
:	O
strict_ansi	int
=	O
0	int
;	O
break	O
;	O
case	O
OPT_DEBUG	int
:	O
debug	int
=	O
arg	pointer
?	O
atoi	function
(	O
arg	pointer
)	O
:	O
1	int
;	O
break	O
;	O
case	O
'P'	O
:	O
set_print_option	function
(	O
arg	pointer
)	O
;	O
break	O
;	O
case	O
'S'	O
:	O
use_indentation	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NO_USE_INDENTATION	int
:	O
use_indentation	int
=	O
0	int
;	O
break	O
;	O
case	O
'T'	O
:	O
print_as_tree	int
=	O
1	int
;	O
set_level_indent	function
(	O
"0=  "	pointer
)	O
;	O
set_level_indent	function
(	O
"1=| "	pointer
)	O
;	O
set_level_indent	function
(	O
"end0=+-"	pointer
)	O
;	O
set_level_indent	function
(	O
"end1=\\\\-"	pointer
)	O
;	O
break	O
;	O
case	O
OPT_NO_TREE	int
:	O
print_as_tree	int
=	O
0	int
;	O
level_indent	array
[	O
0	int
]	O
=	O
level_indent	array
[	O
1	int
]	O
=	O
NULL	O
;	O
level_end	array
[	O
0	int
]	O
=	O
level_end	array
[	O
1	int
]	O
=	O
NULL	O
;	O
break	O
;	O
case	O
'b'	O
:	O
brief_listing	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NO_BRIEF	int
:	O
brief_listing	int
=	O
0	int
;	O
break	O
;	O
case	O
'd'	O
:	O
max_depth	int
=	O
atoi	function
(	O
arg	pointer
)	O
;	O
if	O
(	O
max_depth	int
<	O
0	int
)	O
max_depth	int
=	O
0	int
;	O
break	O
;	O
case	O
OPT_DEFINES	int
:	O
record_defines	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_EMACS	int
:	O
emacs_option	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NO_EMACS	int
:	O
emacs_option	int
=	O
0	int
;	O
break	O
;	O
case	O
'f'	O
:	O
if	O
(	O
select_output_driver	function
(	O
arg	pointer
)	O
)	O
error	function
(	O
EX_USAGE	int
,	O
0	int
,	O
_	O
(	O
"%s: No such output driver"	pointer
)	O
,	O
optarg	pointer
)	O
;	O
output_init	function
(	O
)	O
;	O
break	O
;	O
case	O
OPT_LEVEL_INDENT	int
:	O
set_level_indent	function
(	O
arg	pointer
)	O
;	O
break	O
;	O
case	O
'i'	O
:	O
num	int
=	O
1	int
;	O
for	O
(	O
;	O
*	O
arg	pointer
;	O
arg	pointer
++	O
)	O
switch	O
(	O
*	O
arg	pointer
)	O
{	O
case	O
'-'	O
:	O
case	O
'^'	O
:	O
num	int
=	O
0	int
;	O
break	O
;	O
case	O
'+'	O
:	O
num	int
=	O
1	int
;	O
break	O
;	O
case	O
'x'	O
:	O
case	O
'_'	O
:	O
case	O
's'	O
:	O
case	O
't'	O
:	O
case	O
'u'	O
:	O
if	O
(	O
num	int
)	O
SYMBOL_INCLUDE	O
(	O
*	O
arg	pointer
)	O
;	O
else	O
SYMBOL_EXCLUDE	O
(	O
*	O
arg	pointer
)	O
;	O
break	O
;	O
default	O
:	O
error	function
(	O
EX_USAGE	int
,	O
0	int
,	O
_	O
(	O
"Unknown symbol class: %c"	pointer
)	O
,	O
*	O
arg	pointer
)	O
;	O
}	O
break	O
;	O
case	O
OPT_OMIT_ARGUMENTS	int
:	O
omit_arguments_option	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NO_OMIT_ARGUMENTS	int
:	O
omit_arguments_option	int
=	O
0	int
;	O
break	O
;	O
case	O
OPT_OMIT_SYMBOL_NAMES	int
:	O
omit_symbol_names_option	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NO_OMIT_SYMBOL_NAMES	int
:	O
omit_symbol_names_option	int
=	O
0	int
;	O
break	O
;	O
case	O
'l'	O
:	O
print_levels	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NO_PRINT_LEVEL	int
:	O
print_levels	int
=	O
0	int
;	O
break	O
;	O
case	O
'm'	O
:	O
start_name	pointer
=	O
strdup	function
(	O
arg	pointer
)	O
;	O
break	O
;	O
case	O
OPT_NO_MAIN	int
:	O
start_name	pointer
=	O
NULL	O
;	O
break	O
;	O
case	O
'n'	O
:	O
print_line_numbers	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NO_NUMBER	int
:	O
print_line_numbers	int
=	O
0	int
;	O
break	O
;	O
case	O
'o'	O
:	O
outname	pointer
=	O
strdup	function
(	O
arg	pointer
)	O
;	O
break	O
;	O
case	O
'p'	O
:	O
num	int
=	O
atoi	function
(	O
arg	pointer
)	O
;	O
if	O
(	O
num	int
>	O
0	int
)	O
token_stack_length	int
=	O
num	int
;	O
break	O
;	O
case	O
'r'	O
:	O
reverse_tree	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NO_REVERSE	int
:	O
reverse_tree	int
=	O
0	int
;	O
break	O
;	O
case	O
's'	O
:	O
symbol_override	function
(	O
arg	pointer
)	O
;	O
break	O
;	O
case	O
'v'	O
:	O
verbose	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NO_VERBOSE	int
:	O
verbose	int
=	O
0	int
;	O
break	O
;	O
case	O
'x'	O
:	O
print_option	int
=	O
PRINT_XREF	int
;	O
SYMBOL_EXCLUDE	O
(	O
's'	O
)	O
;	O
break	O
;	O
case	O
OPT_PREPROCESS	int
:	O
preprocess_option	int
=	O
1	int
;	O
set_preprocessor	function
(	O
arg	pointer
?	O
arg	pointer
:	O
CFLOW_PREPROC	pointer
)	O
;	O
break	O
;	O
case	O
OPT_NO_PREPROCESS	int
:	O
preprocess_option	int
=	O
0	int
;	O
break	O
;	O
case	O
ARGP_KEY_ARG	int
:	O
add_name	function
(	O
arg	pointer
)	O
;	O
break	O
;	O
case	O
'I'	O
:	O
case	O
'D'	O
:	O
case	O
'U'	O
:	O
add_preproc_option	function
(	O
key	int
,	O
arg	pointer
)	O
;	O
break	O
;	O
default	O
:	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
argp	struct
argp	struct
=	O
{	O
options	pointer
,	O
parse_opt	function
,	O
N_	O
(	O
"[FILE]..."	pointer
)	O
,	O
doc	pointer
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
;	O
int	O
globals_only	function
(	O
)	O
{	O
return	O
!	O
(	O
symbol_map	int
&	O
SM_STATIC	int
)	O
;	O
}	O
int	O
include_symbol	function
(	O
Symbol	struct
*	O
sym	pointer
)	O
{	O
int	O
type	enum
=	O
0	int
;	O
if	O
(	O
!	O
sym	pointer
)	O
return	O
0	int
;	O
if	O
(	O
sym	pointer
->	O
type	enum
==	O
SymIdentifier	int
)	O
{	O
if	O
(	O
sym	pointer
->	O
name	pointer
[	O
0	int
]	O
==	O
'_'	O
&&	O
!	O
(	O
symbol_map	int
&	O
SM_UNDERSCORE	int
)	O
)	O
return	O
0	int
;	O
if	O
(	O
sym	pointer
->	O
storage	enum
==	O
StaticStorage	int
)	O
type	enum
|=	O
SM_STATIC	int
;	O
if	O
(	O
sym	pointer
->	O
arity	int
==	O
-	O
1	int
&&	O
sym	pointer
->	O
storage	enum
!=	O
AutoStorage	int
)	O
type	enum
|=	O
SM_DATA	int
;	O
else	O
if	O
(	O
sym	pointer
->	O
arity	int
>=	O
0	int
)	O
type	enum
|=	O
SM_FUNCTIONS	int
;	O
if	O
(	O
!	O
sym	pointer
->	O
source	pointer
)	O
type	enum
|=	O
SM_UNDEFINED	int
;	O
}	O
else	O
if	O
(	O
sym	pointer
->	O
type	enum
==	O
SymToken	int
)	O
{	O
if	O
(	O
sym	pointer
->	O
token_type	int
==	O
TYPE	int
&&	O
sym	pointer
->	O
source	pointer
)	O
type	enum
|=	O
SM_TYPEDEF	int
;	O
else	O
return	O
0	int
;	O
}	O
return	O
(	O
symbol_map	int
&	O
type	enum
)	O
==	O
type	enum
;	O
}	O
void	O
xalloc_die	function
(	O
void	O
)	O
{	O
error	function
(	O
EX_FATAL	int
,	O
ENOMEM	int
,	O
_	O
(	O
"Exiting"	pointer
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
void	O
init	function
(	O
)	O
{	O
if	O
(	O
level_indent	array
[	O
0	int
]	O
==	O
NULL	O
)	O
level_indent	array
[	O
0	int
]	O
=	O
"    "	pointer
;	O
if	O
(	O
level_indent	array
[	O
1	int
]	O
==	O
NULL	O
)	O
level_indent	array
[	O
1	int
]	O
=	O
level_indent	array
[	O
0	int
]	O
;	O
if	O
(	O
level_end	array
[	O
0	int
]	O
==	O
NULL	O
)	O
level_end	array
[	O
0	int
]	O
=	O
""	pointer
;	O
if	O
(	O
level_end	array
[	O
1	int
]	O
==	O
NULL	O
)	O
level_end	array
[	O
1	int
]	O
=	O
""	pointer
;	O
init_lex	function
(	O
debug	int
>	O
2	int
)	O
;	O
init_parse	function
(	O
)	O
;	O
}	O
const	O
char	O
version_etc_copyright	array
[	O
]	O
=	O
"Copyright %s 2005-%d Sergey Poznyakoff"	pointer
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
index	function
;	O
int	O
status	int
=	O
EX_OK	int
;	O
set_program_name	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
argp_version_setup	function
(	O
"cflow"	pointer
,	O
program_authors	array
)	O
;	O
setlocale	function
(	O
LC_ALL	O
,	O
""	pointer
)	O
;	O
bindtextdomain	function
(	O
PACKAGE	pointer
,	O
LOCALEDIR	O
)	O
;	O
textdomain	function
(	O
PACKAGE	pointer
)	O
;	O
register_output	function
(	O
"gnu"	pointer
,	O
gnu_output_handler	function
,	O
NULL	O
)	O
;	O
register_output	function
(	O
"posix"	pointer
,	O
posix_output_handler	function
,	O
NULL	O
)	O
;	O
symbol_map	int
=	O
SM_FUNCTIONS	int
|	O
SM_STATIC	int
|	O
SM_UNDEFINED	int
;	O
if	O
(	O
getenv	function
(	O
"POSIXLY_CORRECT"	pointer
)	O
)	O
{	O
if	O
(	O
select_output_driver	function
(	O
"posix"	pointer
)	O
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"INTERNAL ERROR: %s: No such output driver"	pointer
)	O
,	O
"posix"	pointer
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
output_init	function
(	O
)	O
;	O
}	O
sourcerc	function
(	O
&	O
argc	int
,	O
&	O
argv	pointer
)	O
;	O
if	O
(	O
argp_parse	function
(	O
&	O
argp	struct
,	O
argc	int
,	O
argv	pointer
,	O
ARGP_IN_ORDER	int
,	O
&	O
index	function
,	O
NULL	O
)	O
)	O
exit	function
(	O
EX_USAGE	int
)	O
;	O
if	O
(	O
print_option	int
==	O
0	int
)	O
print_option	int
=	O
PRINT_TREE	int
;	O
init	function
(	O
)	O
;	O
if	O
(	O
arglist	pointer
)	O
{	O
struct	O
linked_list_entry	struct
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
linked_list_head	O
(	O
arglist	pointer
)	O
;	O
p	pointer
;	O
)	O
{	O
struct	O
linked_list_entry	struct
*	O
next	pointer
=	O
p	pointer
->	O
next	pointer
;	O
char	O
*	O
s	long
=	O
(	O
char	O
*	O
)	O
p	pointer
->	O
data	pointer
;	O
if	O
(	O
s	long
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
pp_option	function
(	O
s	long
)	O
;	O
linked_list_unlink	function
(	O
arglist	pointer
,	O
p	pointer
)	O
;	O
}	O
p	pointer
=	O
next	pointer
;	O
}	O
for	O
(	O
p	pointer
=	O
linked_list_head	O
(	O
arglist	pointer
)	O
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
char	O
*	O
s	long
=	O
(	O
char	O
*	O
)	O
p	pointer
->	O
data	pointer
;	O
if	O
(	O
source	pointer
(	O
s	long
)	O
==	O
0	int
)	O
yyparse	function
(	O
)	O
;	O
}	O
}	O
argc	int
-=	O
index	function
;	O
argv	pointer
+=	O
index	function
;	O
while	O
(	O
argc	int
--	O
)	O
{	O
if	O
(	O
source	pointer
(	O
*	O
argv	pointer
++	O
)	O
==	O
0	int
)	O
yyparse	function
(	O
)	O
;	O
else	O
status	int
=	O
EX_SOFT	int
;	O
}	O
if	O
(	O
input_file_count	int
==	O
0	int
)	O
error	function
(	O
EX_USAGE	int
,	O
0	int
,	O
_	O
(	O
"no input files"	pointer
)	O
)	O
;	O
output	function
(	O
)	O
;	O
return	O
status	int
;	O
}	O
