static	O
int	O
loop_and_record	function
(	O
SWHEADER	struct
*	O
INDEX	pointer
,	O
char	O
*	O
object_keyword	pointer
,	O
STRAR	struct
*	O
list	pointer
,	O
STRAR	struct
*	O
vendor_list	pointer
,	O
STRAR	struct
*	O
revision_list	pointer
)	O
{	O
char	O
*	O
obj	pointer
;	O
char	O
*	O
value	int
=	O
NULL	O
;	O
char	O
*	O
attrline	pointer
=	O
NULL	O
;	O
int	O
count	int
=	O
0	int
;	O
int	O
retval	int
;	O
obj	pointer
=	O
swheader_get_object_by_tag	function
(	O
INDEX	pointer
,	O
object_keyword	pointer
,	O
"*"	pointer
)	O
;	O
while	O
(	O
obj	pointer
)	O
{	O
attrline	pointer
=	O
swheader_get_attribute	function
(	O
INDEX	pointer
,	O
SW_A_tag	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
attrline	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"no tag found for %s\n"	pointer
,	O
object_keyword	pointer
)	O
;	O
retval	int
=	O
20	int
;	O
return	O
retval	int
;	O
}	O
value	int
=	O
swheaderline_get_value	function
(	O
attrline	pointer
,	O
NULL	O
)	O
;	O
strar_add	function
(	O
list	pointer
,	O
value	int
)	O
;	O
attrline	pointer
=	O
swheader_get_attribute	function
(	O
INDEX	pointer
,	O
SW_A_vendor_tag	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
attrline	pointer
)	O
{	O
value	int
=	O
swheaderline_get_value	function
(	O
attrline	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
vendor_list	pointer
)	O
strar_add	function
(	O
vendor_list	pointer
,	O
value	int
)	O
;	O
}	O
attrline	pointer
=	O
swheader_get_attribute	function
(	O
INDEX	pointer
,	O
SW_A_revision	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
attrline	pointer
)	O
{	O
retval	int
=	O
23	int
;	O
return	O
retval	int
;	O
}	O
value	int
=	O
swheaderline_get_value	function
(	O
attrline	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
revision_list	pointer
)	O
strar_add	function
(	O
revision_list	pointer
,	O
value	int
)	O
;	O
swheader_get_next_object	function
(	O
INDEX	pointer
,	O
(	O
int	O
)	O
UCHAR_MAX	O
,	O
(	O
int	O
)	O
UCHAR_MAX	O
)	O
;	O
obj	pointer
=	O
swheader_get_object_by_tag	function
(	O
INDEX	pointer
,	O
object_keyword	pointer
,	O
"*"	pointer
)	O
;	O
count	int
++	O
;	O
}	O
return	O
count	int
;	O
}	O
static	O
int	O
determine_catalog_directories	function
(	O
SWI_DISTDATA	struct
*	O
part1	pointer
,	O
int	O
enforce_swinstall_policy	int
)	O
{	O
char	O
*	O
bundle_tag	pointer
;	O
char	O
*	O
product_tag	pointer
;	O
bundle_tag	pointer
=	O
strar_get	function
(	O
part1	pointer
->	O
bundle_tagsM	pointer
,	O
0	int
)	O
;	O
product_tag	pointer
=	O
strar_get	function
(	O
part1	pointer
->	O
product_tagsM	pointer
,	O
0	int
)	O
;	O
if	O
(	O
enforce_swinstall_policy	int
)	O
{	O
}	O
if	O
(	O
bundle_tag	pointer
==	O
NULL	O
)	O
bundle_tag	pointer
=	O
product_tag	pointer
;	O
if	O
(	O
product_tag	pointer
==	O
NULL	O
)	O
return	O
1	int
;	O
part1	pointer
->	O
catalog_bundle_dir1M	pointer
=	O
strdup	function
(	O
bundle_tag	pointer
)	O
;	O
return	O
0	int
;	O
}	O
SWI_DISTDATA	struct
*	O
swi_distdata_create	function
(	O
void	O
)	O
{	O
SWI_DISTDATA	struct
*	O
part1	pointer
=	O
(	O
SWI_DISTDATA	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
SWI_DISTDATA	struct
)	O
)	O
;	O
swi_distdata_initialize	function
(	O
part1	pointer
)	O
;	O
return	O
part1	pointer
;	O
}	O
void	O
swi_distdata_initialize	function
(	O
SWI_DISTDATA	struct
*	O
part1	pointer
)	O
{	O
part1	pointer
->	O
did_part1M	int
=	O
0	int
;	O
part1	pointer
->	O
dist_tagM	pointer
=	O
(	O
char	O
*	O
)	O
(	O
NULL	O
)	O
;	O
part1	pointer
->	O
dist_revisionM	pointer
=	O
(	O
char	O
*	O
)	O
(	O
NULL	O
)	O
;	O
part1	pointer
->	O
catalog_bundle_dir1M	pointer
=	O
(	O
char	O
*	O
)	O
(	O
NULL	O
)	O
;	O
part1	pointer
->	O
bundle_tagsM	pointer
=	O
strar_open	function
(	O
)	O
;	O
part1	pointer
->	O
product_tagsM	pointer
=	O
strar_open	function
(	O
)	O
;	O
part1	pointer
->	O
product_revisionsM	pointer
=	O
strar_open	function
(	O
)	O
;	O
part1	pointer
->	O
vendor_tagsM	pointer
=	O
strar_open	function
(	O
)	O
;	O
}	O
int	O
swi_distdata_resolve	function
(	O
SWI	struct
*	O
swi	pointer
,	O
SWI_DISTDATA	struct
*	O
part1	pointer
,	O
int	O
enforce_swinstall_policy	int
)	O
{	O
char	O
*	O
obj	pointer
;	O
int	O
offset	int
;	O
SWHEADER	struct
*	O
INDEX	pointer
;	O
char	O
*	O
value	int
=	O
NULL	O
;	O
char	O
*	O
attrline	pointer
=	O
NULL	O
;	O
int	O
retval	int
;	O
int	O
count	int
=	O
0	int
;	O
swi_distdata_initialize	function
(	O
part1	pointer
)	O
;	O
INDEX	pointer
=	O
SWI_get_index_header	O
(	O
swi	pointer
)	O
;	O
swheader_reset	function
(	O
INDEX	pointer
)	O
;	O
swheader_reset	function
(	O
INDEX	pointer
)	O
;	O
count	int
=	O
loop_and_record	function
(	O
INDEX	pointer
,	O
SW_A_bundle	pointer
,	O
part1	pointer
->	O
bundle_tagsM	pointer
,	O
(	O
STRAR	struct
*	O
)	O
NULL	O
,	O
(	O
STRAR	struct
*	O
)	O
NULL	O
)	O
;	O
swheader_reset	function
(	O
INDEX	pointer
)	O
;	O
count	int
=	O
loop_and_record	function
(	O
INDEX	pointer
,	O
SW_A_product	pointer
,	O
part1	pointer
->	O
product_tagsM	pointer
,	O
part1	pointer
->	O
vendor_tagsM	pointer
,	O
part1	pointer
->	O
product_revisionsM	pointer
)	O
;	O
if	O
(	O
count	int
==	O
0	int
)	O
{	O
retval	int
=	O
30	int
;	O
return	O
retval	int
;	O
}	O
swheader_reset	function
(	O
INDEX	pointer
)	O
;	O
obj	pointer
=	O
swheader_get_object_by_tag	function
(	O
INDEX	pointer
,	O
SW_A_distribution	pointer
,	O
"*"	pointer
)	O
;	O
if	O
(	O
!	O
obj	pointer
)	O
{	O
retval	int
=	O
40	int
;	O
return	O
retval	int
;	O
}	O
offset	int
=	O
swheader_get_current_offset	function
(	O
INDEX	pointer
)	O
;	O
attrline	pointer
=	O
swheader_get_attribute	function
(	O
INDEX	pointer
,	O
SW_A_tag	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
attrline	pointer
)	O
{	O
value	int
=	O
strar_get	function
(	O
part1	pointer
->	O
product_tagsM	pointer
,	O
0	int
)	O
;	O
}	O
else	O
{	O
value	int
=	O
swheaderline_get_value	function
(	O
attrline	pointer
,	O
NULL	O
)	O
;	O
}	O
part1	pointer
->	O
dist_tagM	pointer
=	O
strdup	function
(	O
value	int
)	O
;	O
swheader_reset	function
(	O
INDEX	pointer
)	O
;	O
if	O
(	O
determine_catalog_directories	function
(	O
part1	pointer
,	O
enforce_swinstall_policy	int
)	O
)	O
return	O
44	int
;	O
retval	int
=	O
0	int
;	O
return	O
retval	int
;	O
}	O
void	O
swi_distdata_delete	function
(	O
SWI_DISTDATA	struct
*	O
part1	pointer
)	O
{	O
free	function
(	O
part1	pointer
->	O
dist_tagM	pointer
)	O
;	O
strar_close	function
(	O
part1	pointer
->	O
bundle_tagsM	pointer
)	O
;	O
strar_close	function
(	O
part1	pointer
->	O
product_tagsM	pointer
)	O
;	O
strar_close	function
(	O
part1	pointer
->	O
product_revisionsM	pointer
)	O
;	O
strar_close	function
(	O
part1	pointer
->	O
vendor_tagsM	pointer
)	O
;	O
}	O
