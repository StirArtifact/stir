double	O
*	O
LogTransformArray	function
(	O
long	O
nElems	long
,	O
double	O
*	O
rgdSrc	pointer
,	O
double	O
*	O
rgdDes	pointer
)	O
{	O
register	O
long	O
l	long
;	O
for	O
(	O
l	long
=	O
0	int
;	O
l	long
<	O
nElems	long
;	O
l	long
++	O
)	O
rgdDes	pointer
[	O
l	long
]	O
=	O
log	function
(	O
rgdSrc	pointer
[	O
l	long
]	O
)	O
;	O
return	O
rgdDes	pointer
;	O
}	O
double	O
*	O
InitdVector	function
(	O
long	O
cVectors	long
)	O
{	O
if	O
(	O
cVectors	long
==	O
0	int
)	O
{	O
printf	function
(	O
"Error: zero length array allocation in InitdVector - Exiting\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
else	O
return	O
(	O
double	O
*	O
)	O
malloc	function
(	O
cVectors	long
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
}	O
int	O
*	O
InitiVector	function
(	O
long	O
cVectors	long
)	O
{	O
if	O
(	O
cVectors	long
==	O
0	int
)	O
{	O
printf	function
(	O
"Error: zero length array allocation in InitiVector - Exiting\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
else	O
return	O
(	O
int	O
*	O
)	O
malloc	function
(	O
cVectors	long
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
}	O
long	O
*	O
InitlVector	function
(	O
long	O
cVectors	long
)	O
{	O
if	O
(	O
cVectors	long
==	O
0	int
)	O
{	O
printf	function
(	O
"Error: zero length array allocation in InitlVector - Exiting\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
else	O
return	O
(	O
long	O
*	O
)	O
malloc	function
(	O
cVectors	long
*	O
sizeof	O
(	O
long	O
)	O
)	O
;	O
}	O
double	O
*	O
*	O
InitpdVector	function
(	O
long	O
cVectors	long
)	O
{	O
if	O
(	O
cVectors	long
==	O
0	int
)	O
{	O
printf	function
(	O
"Error: zero length array allocation in InitpdVector - Exiting\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
else	O
return	O
(	O
double	O
*	O
*	O
)	O
malloc	function
(	O
cVectors	long
*	O
sizeof	O
(	O
double	O
*	O
)	O
)	O
;	O
}	O
double	O
*	O
*	O
InitdMatrix	function
(	O
long	O
cVectors	long
,	O
long	O
cElemsEach	long
)	O
{	O
register	O
long	O
i	long
;	O
double	O
*	O
*	O
rgp	pointer
;	O
if	O
(	O
(	O
cVectors	long
==	O
0	int
)	O
||	O
(	O
cElemsEach	long
==	O
0	int
)	O
)	O
{	O
printf	function
(	O
"Error: zero length array allocation in InitdMatrix - Exiting\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
rgp	pointer
=	O
(	O
double	O
*	O
*	O
)	O
malloc	function
(	O
cVectors	long
*	O
sizeof	O
(	O
double	O
*	O
)	O
)	O
;	O
if	O
(	O
rgp	pointer
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
cVectors	long
;	O
i	long
++	O
)	O
{	O
rgp	pointer
[	O
i	long
]	O
=	O
(	O
double	O
*	O
)	O
malloc	function
(	O
cElemsEach	long
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
if	O
(	O
!	O
rgp	pointer
[	O
i	long
]	O
)	O
{	O
rgp	pointer
=	O
0	int
;	O
break	O
;	O
}	O
}	O
}	O
return	O
(	O
rgp	pointer
)	O
;	O
}	O
long	O
*	O
*	O
InitlMatrix	function
(	O
long	O
cVectors	long
,	O
long	O
cElemsEach	long
)	O
{	O
register	O
long	O
i	long
;	O
long	O
*	O
*	O
rgp	pointer
;	O
if	O
(	O
(	O
cVectors	long
==	O
0	int
)	O
||	O
(	O
cElemsEach	long
==	O
0	int
)	O
)	O
{	O
printf	function
(	O
"Error: zero length array allocation in InitlMatrix - Exiting\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
rgp	pointer
=	O
(	O
long	O
*	O
*	O
)	O
malloc	function
(	O
cVectors	long
*	O
sizeof	O
(	O
long	O
*	O
)	O
)	O
;	O
if	O
(	O
rgp	pointer
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
cVectors	long
;	O
i	long
++	O
)	O
{	O
rgp	pointer
[	O
i	long
]	O
=	O
(	O
long	O
*	O
)	O
malloc	function
(	O
cElemsEach	long
*	O
sizeof	O
(	O
long	O
)	O
)	O
;	O
if	O
(	O
!	O
rgp	pointer
[	O
i	long
]	O
)	O
{	O
rgp	pointer
=	O
0	int
;	O
break	O
;	O
}	O
}	O
}	O
return	O
(	O
rgp	pointer
)	O
;	O
}	O
void	O
ColumnMeans	function
(	O
long	O
cRows	long
,	O
long	O
cCols	long
,	O
double	O
*	O
*	O
x	pointer
,	O
double	O
*	O
x_bar	pointer
)	O
{	O
register	O
long	O
i	long
,	O
l	long
;	O
for	O
(	O
l	long
=	O
0	int
;	O
l	long
<	O
cCols	long
;	O
l	long
++	O
)	O
x_bar	pointer
[	O
l	long
]	O
=	O
0.0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
cRows	long
;	O
i	long
++	O
)	O
for	O
(	O
l	long
=	O
0	int
;	O
l	long
<	O
cCols	long
;	O
l	long
++	O
)	O
x_bar	pointer
[	O
l	long
]	O
+=	O
x	pointer
[	O
i	long
]	O
[	O
l	long
]	O
;	O
for	O
(	O
l	long
=	O
0	int
;	O
l	long
<	O
cCols	long
;	O
l	long
++	O
)	O
x_bar	pointer
[	O
l	long
]	O
/=	O
cRows	long
;	O
}	O
int	O
Cholesky	function
(	O
PDOUBLE	pointer
*	O
prgdVariance	pointer
,	O
PDOUBLE	pointer
*	O
prgdComponent	pointer
,	O
long	O
lNparams	long
)	O
{	O
register	O
int	O
i	long
,	O
j	int
,	O
k	int
;	O
double	O
dSum	double
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
lNparams	long
;	O
i	long
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
lNparams	long
;	O
j	int
++	O
)	O
prgdComponent	pointer
[	O
i	long
]	O
[	O
j	int
]	O
=	O
0.0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
lNparams	long
;	O
i	long
++	O
)	O
for	O
(	O
j	int
=	O
i	long
;	O
j	int
<	O
lNparams	long
;	O
j	int
++	O
)	O
{	O
dSum	double
=	O
prgdVariance	pointer
[	O
i	long
]	O
[	O
j	int
]	O
;	O
for	O
(	O
k	int
=	O
i	long
-	O
1	int
;	O
k	int
>=	O
0	int
;	O
k	int
--	O
)	O
dSum	double
=	O
dSum	double
-	O
prgdVariance	pointer
[	O
i	long
]	O
[	O
k	int
]	O
*	O
prgdVariance	pointer
[	O
j	int
]	O
[	O
k	int
]	O
;	O
if	O
(	O
i	long
==	O
j	int
)	O
{	O
if	O
(	O
dSum	double
<=	O
0.0	int
)	O
{	O
printf	function
(	O
"Warning: input matrix for Cholesky is not "	pointer
"positive definite\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
else	O
prgdComponent	pointer
[	O
i	long
]	O
[	O
i	long
]	O
=	O
sqrt	function
(	O
dSum	double
)	O
;	O
}	O
else	O
prgdVariance	pointer
[	O
j	int
]	O
[	O
i	long
]	O
=	O
dSum	double
/	O
prgdComponent	pointer
[	O
i	long
]	O
[	O
i	long
]	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
lNparams	long
;	O
i	long
++	O
)	O
for	O
(	O
j	int
=	O
i	long
+	O
1	int
;	O
j	int
<	O
lNparams	long
;	O
j	int
++	O
)	O
prgdComponent	pointer
[	O
j	int
]	O
[	O
i	long
]	O
=	O
prgdVariance	pointer
[	O
j	int
]	O
[	O
i	long
]	O
;	O
return	O
1	int
;	O
}	O
