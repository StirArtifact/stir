static	O
Display	struct
*	O
XDisplay	pointer
=	O
NULL	O
;	O
static	O
int	O
XScreen	int
;	O
static	O
Window	long
XRoot	long
;	O
static	O
Visual	struct
*	O
XVisual	pointer
=	O
NULL	O
;	O
static	O
GC	pointer
XGcWin	pointer
;	O
static	O
Window	long
XWin	long
;	O
static	O
unsigned	O
long	O
col_table	array
[	O
CMS_SIZE	int
]	O
;	O
static	O
XColor	struct
Xcol	struct
;	O
static	O
Colormap	long
def_clut	long
;	O
static	O
int	O
scr_width	int
;	O
static	O
int	O
scr_height	int
;	O
static	O
int	O
width	int
;	O
static	O
int	O
bytes	int
;	O
static	O
int	O
height	int
;	O
XEvent	union
WaitEvent	union
;	O
static	O
int	O
row_start	int
=	O
0	int
;	O
static	O
int	O
col_start	int
=	O
0	int
;	O
static	O
int	O
oversized	int
=	O
0	int
;	O
static	O
int	O
zoomed	int
=	O
0	int
;	O
static	O
int	O
win_open	function
(	O
const	O
GEN_PAR	struct
*	O
pg	pointer
,	O
char	O
*	O
title	pointer
,	O
int	O
x	int
,	O
int	O
y	int
,	O
int	O
w	int
,	O
int	O
h	int
)	O
{	O
char	O
*	O
DisplayName	pointer
=	O
NULL	O
;	O
char	O
*	O
*	O
argv	pointer
;	O
XSizeHints	struct
Hints	struct
;	O
unsigned	O
long	O
ValueMask	long
;	O
XSetWindowAttributes	struct
WinAttr	struct
;	O
XEvent	union
Event	union
;	O
char	O
colorname	array
[	O
13	int
]	O
;	O
int	O
i	int
;	O
argv	pointer
=	O
(	O
char	O
*	O
*	O
)	O
malloc	function
(	O
3	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
argv	pointer
[	O
0	int
]	O
=	O
PROG_NAME	pointer
;	O
argv	pointer
[	O
1	int
]	O
=	O
title	pointer
;	O
argv	pointer
[	O
2	int
]	O
=	O
NULL	O
;	O
if	O
(	O
(	O
XDisplay	pointer
=	O
(	O
Display	struct
*	O
)	O
XOpenDisplay	function
(	O
DisplayName	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
Eprintf	function
(	O
"No X11 server found !\n"	pointer
)	O
;	O
return	O
NO_SERVER	int
;	O
}	O
XScreen	int
=	O
DefaultScreen	O
(	O
XDisplay	pointer
)	O
;	O
XRoot	long
=	O
RootWindow	O
(	O
XDisplay	pointer
,	O
XScreen	int
)	O
;	O
XVisual	pointer
=	O
DefaultVisual	O
(	O
XDisplay	pointer
,	O
XScreen	int
)	O
;	O
XGcWin	pointer
=	O
DefaultGC	O
(	O
XDisplay	pointer
,	O
XScreen	int
)	O
;	O
scr_width	int
=	O
WidthOfScreen	O
(	O
ScreenOfDisplay	O
(	O
XDisplay	pointer
,	O
XScreen	int
)	O
)	O
;	O
scr_height	int
=	O
HeightOfScreen	O
(	O
ScreenOfDisplay	O
(	O
XDisplay	pointer
,	O
XScreen	int
)	O
)	O
;	O
if	O
(	O
x	int
+	O
w	int
>	O
scr_width	int
||	O
y	int
+	O
h	int
>	O
scr_height	int
)	O
{	O
if	O
(	O
!	O
pg	pointer
->	O
quiet	int
)	O
Eprintf	function
(	O
"Window exceeds screen limits, use mouse button 1 to pan\n"	pointer
)	O
;	O
w	int
=	O
MIN	O
(	O
w	int
,	O
scr_width	int
)	O
;	O
h	int
=	O
MIN	O
(	O
h	int
,	O
scr_height	int
)	O
;	O
oversized	int
=	O
1	int
;	O
}	O
WinAttr	struct
.	O
background_pixel	long
=	O
WhitePixel	O
(	O
XDisplay	pointer
,	O
XScreen	int
)	O
;	O
WinAttr	struct
.	O
border_pixel	long
=	O
WhitePixel	O
(	O
XDisplay	pointer
,	O
XScreen	int
)	O
;	O
WinAttr	struct
.	O
backing_store	int
=	O
Always	int
;	O
ValueMask	long
=	O
(	O
unsigned	O
long	O
)	O
(	O
CWBackPixel	O
|	O
CWBorderPixel	O
|	O
CWBackingStore	O
)	O
;	O
XWin	long
=	O
XCreateWindow	function
(	O
XDisplay	pointer
,	O
XRoot	long
,	O
x	int
,	O
y	int
,	O
(	O
unsigned	O
int	O
)	O
w	int
,	O
(	O
unsigned	O
int	O
)	O
h	int
,	O
1	int
,	O
0	int
,	O
CopyFromParent	int
,	O
(	O
Visual	struct
*	O
)	O
CopyFromParent	int
,	O
ValueMask	long
,	O
&	O
WinAttr	struct
)	O
;	O
Hints	struct
.	O
flags	char
=	O
PSize	O
|	O
PMinSize	O
|	O
PMaxSize	O
|	O
USPosition	O
;	O
Hints	struct
.	O
x	int
=	O
x	int
;	O
Hints	struct
.	O
y	int
=	O
y	int
;	O
Hints	struct
.	O
width	int
=	O
Hints	struct
.	O
min_width	int
=	O
Hints	struct
.	O
max_width	int
=	O
w	int
;	O
Hints	struct
.	O
height	int
=	O
Hints	struct
.	O
min_height	int
=	O
Hints	struct
.	O
max_height	int
=	O
h	int
;	O
XSetStandardProperties	function
(	O
XDisplay	pointer
,	O
XWin	long
,	O
title	pointer
,	O
title	pointer
,	O
0	int
,	O
argv	pointer
,	O
2	int
,	O
&	O
Hints	struct
)	O
;	O
def_clut	long
=	O
DefaultColormap	O
(	O
XDisplay	pointer
,	O
XScreen	int
)	O
;	O
if	O
(	O
DefaultDepth	O
(	O
XDisplay	pointer
,	O
XScreen	int
)	O
<	O
4	int
)	O
{	O
col_table	array
[	O
BLACK	int
]	O
=	O
WhitePixel	O
(	O
XDisplay	pointer
,	O
XScreen	int
)	O
;	O
col_table	array
[	O
WHITE	int
]	O
=	O
BlackPixel	O
(	O
XDisplay	pointer
,	O
XScreen	int
)	O
;	O
col_table	array
[	O
GRAY	int
]	O
=	O
col_table	array
[	O
WHITE	int
]	O
;	O
col_table	array
[	O
RED	int
]	O
=	O
col_table	array
[	O
WHITE	int
]	O
;	O
col_table	array
[	O
GREEN	int
]	O
=	O
col_table	array
[	O
WHITE	int
]	O
;	O
col_table	array
[	O
BLUE	int
]	O
=	O
col_table	array
[	O
WHITE	int
]	O
;	O
col_table	array
[	O
CYAN	int
]	O
=	O
col_table	array
[	O
WHITE	int
]	O
;	O
col_table	array
[	O
MAGENTA	int
]	O
=	O
col_table	array
[	O
WHITE	int
]	O
;	O
col_table	array
[	O
YELLOW	int
]	O
=	O
col_table	array
[	O
WHITE	int
]	O
;	O
col_table	array
[	O
LIGHTGRAY	int
]	O
=	O
col_table	array
[	O
WHITE	int
]	O
;	O
col_table	array
[	O
LIGHTRED	int
]	O
=	O
col_table	array
[	O
WHITE	int
]	O
;	O
col_table	array
[	O
LIGHTGREEN	int
]	O
=	O
col_table	array
[	O
WHITE	int
]	O
;	O
col_table	array
[	O
LIGHTBLUE	int
]	O
=	O
col_table	array
[	O
WHITE	int
]	O
;	O
col_table	array
[	O
LIGHTCYAN	int
]	O
=	O
col_table	array
[	O
WHITE	int
]	O
;	O
col_table	array
[	O
LIGHTMAGENTA	int
]	O
=	O
col_table	array
[	O
WHITE	int
]	O
;	O
}	O
else	O
{	O
XParseColor	function
(	O
XDisplay	pointer
,	O
def_clut	long
,	O
"gray10"	pointer
,	O
&	O
Xcol	struct
)	O
;	O
XAllocColor	function
(	O
XDisplay	pointer
,	O
def_clut	long
,	O
&	O
Xcol	struct
)	O
;	O
col_table	array
[	O
GRAY	int
]	O
=	O
Xcol	struct
.	O
pixel	long
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
pg	pointer
->	O
maxpens	int
;	O
i	int
++	O
)	O
{	O
sprintf	function
(	O
colorname	array
,	O
"#%2.2X%2.2X%2.2X"	pointer
,	O
pt	struct
.	O
clut	array
[	O
i	int
]	O
[	O
0	int
]	O
,	O
pt	struct
.	O
clut	array
[	O
i	int
]	O
[	O
1	int
]	O
,	O
pt	struct
.	O
clut	array
[	O
i	int
]	O
[	O
2	int
]	O
)	O
;	O
if	O
(	O
XParseColor	function
(	O
XDisplay	pointer
,	O
def_clut	long
,	O
colorname	array
,	O
&	O
Xcol	struct
)	O
==	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"failed tp map color for pen %d\n"	pointer
,	O
i	int
)	O
;	O
if	O
(	O
XAllocColor	function
(	O
XDisplay	pointer
,	O
def_clut	long
,	O
&	O
Xcol	struct
)	O
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"failed to alloc X color for pen %d\n"	pointer
,	O
i	int
)	O
;	O
col_table	array
[	O
i	int
]	O
=	O
col_table	array
[	O
GRAY	int
]	O
;	O
}	O
else	O
col_table	array
[	O
i	int
]	O
=	O
Xcol	struct
.	O
pixel	long
;	O
}	O
}	O
XSetState	function
(	O
XDisplay	pointer
,	O
XGcWin	pointer
,	O
col_table	array
[	O
BLACK	int
]	O
,	O
col_table	array
[	O
WHITE	int
]	O
,	O
GXcopy	int
,	O
AllPlanes	O
)	O
;	O
XSelectInput	function
(	O
XDisplay	pointer
,	O
XWin	long
,	O
ExposureMask	O
|	O
KeyPressMask	O
|	O
VisibilityChangeMask	O
|	O
ButtonPressMask	O
|	O
ButtonReleaseMask	O
)	O
;	O
XMapWindow	function
(	O
XDisplay	pointer
,	O
XWin	long
)	O
;	O
do	O
{	O
XNextEvent	function
(	O
XDisplay	pointer
,	O
&	O
Event	union
)	O
;	O
}	O
while	O
(	O
Event	union
.	O
type	pointer
!=	O
Expose	int
&&	O
Event	union
.	O
type	pointer
!=	O
VisibilityNotify	int
)	O
;	O
width	int
=	O
w	int
;	O
height	int
=	O
h	int
;	O
bytes	int
=	O
(	O
w	int
+	O
7	int
)	O
/	O
8	int
;	O
free	function
(	O
(	O
char	O
*	O
)	O
argv	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
void	O
win_close	function
(	O
)	O
{	O
XDestroyWindow	function
(	O
XDisplay	pointer
,	O
XWin	long
)	O
;	O
XCloseDisplay	function
(	O
XDisplay	pointer
)	O
;	O
}	O
int	O
PicBuf_to_X11	function
(	O
const	O
GEN_PAR	struct
*	O
pg	pointer
,	O
OUT_PAR	struct
*	O
po	pointer
)	O
{	O
int	O
row_c	int
,	O
x	int
,	O
y	int
;	O
int	O
saved_col	int
=	O
0	int
,	O
saved_row	int
=	O
0	int
;	O
int	O
xref	int
=	O
0	int
,	O
yref	int
=	O
0	int
;	O
const	O
RowBuf	struct
*	O
row	pointer
;	O
const	O
PicBuf	struct
*	O
pb	pointer
;	O
struct	O
timeval	struct
tv	struct
;	O
tv	struct
.	O
tv_usec	long
=	O
10	int
;	O
if	O
(	O
pg	pointer
==	O
NULL	O
||	O
po	pointer
==	O
NULL	O
)	O
return	O
ERROR	O
;	O
pb	pointer
=	O
po	pointer
->	O
picbuf	pointer
;	O
if	O
(	O
pb	pointer
==	O
NULL	O
)	O
return	O
ERROR	O
;	O
if	O
(	O
!	O
pg	pointer
->	O
quiet	int
)	O
{	O
Eprintf	function
(	O
"\nX11 preview follows.\n"	pointer
)	O
;	O
Eprintf	function
(	O
"Press any key to end graphics mode\n"	pointer
)	O
;	O
}	O
if	O
(	O
win_open	function
(	O
pg	pointer
,	O
po	pointer
->	O
outfile	pointer
,	O
(	O
int	O
)	O
(	O
po	pointer
->	O
xoff	double
*	O
po	pointer
->	O
dpi_x	int
/	O
25.4	int
)	O
,	O
(	O
int	O
)	O
(	O
po	pointer
->	O
yoff	double
*	O
po	pointer
->	O
dpi_y	int
/	O
25.4	int
)	O
,	O
pb	pointer
->	O
nb	int
<<	O
3	int
,	O
pb	pointer
->	O
nr	int
)	O
)	O
return	O
ERROR	O
;	O
REDRAW	O
:	O
for	O
(	O
row_c	int
=	O
row_start	int
,	O
y	int
=	O
MIN	O
(	O
height	int
-	O
row_start	int
,	O
pb	pointer
->	O
nr	int
-	O
1	int
)	O
;	O
row_c	int
<	O
pb	pointer
->	O
nr	int
;	O
row_c	int
++	O
,	O
y	int
--	O
)	O
{	O
row	pointer
=	O
NULL	O
;	O
if	O
(	O
row_c	int
>=	O
0	int
)	O
row	pointer
=	O
get_RowBuf	function
(	O
pb	pointer
,	O
row_c	int
)	O
;	O
for	O
(	O
x	int
=	O
col_start	int
;	O
x	int
<	O
pb	pointer
->	O
nc	int
;	O
x	int
++	O
)	O
{	O
if	O
(	O
row_c	int
<	O
0	int
||	O
x	int
<	O
0	int
)	O
setXcolor	O
(	O
GRAY	int
)	O
;	O
else	O
switch	O
(	O
index_from_RowBuf	function
(	O
row	pointer
,	O
x	int
,	O
pb	pointer
)	O
)	O
{	O
case	O
xxBackground	int
:	O
continue	O
;	O
default	O
:	O
setXcolor	O
(	O
index_from_RowBuf	function
(	O
row	pointer
,	O
x	int
,	O
pb	pointer
)	O
)	O
;	O
break	O
;	O
}	O
XDrawPoint	function
(	O
XDisplay	pointer
,	O
XWin	long
,	O
XGcWin	pointer
,	O
x	int
-	O
col_start	int
,	O
y	int
+	O
row_start	int
)	O
;	O
}	O
}	O
do	O
{	O
XNextEvent	function
(	O
XDisplay	pointer
,	O
&	O
WaitEvent	union
)	O
;	O
if	O
(	O
WaitEvent	union
.	O
type	pointer
==	O
ButtonPress	int
)	O
{	O
if	O
(	O
WaitEvent	union
.	O
xbutton	struct
.	O
button	int
==	O
Button1	int
)	O
{	O
xref	int
=	O
WaitEvent	union
.	O
xbutton	struct
.	O
x	int
;	O
yref	int
=	O
WaitEvent	union
.	O
xbutton	struct
.	O
y	int
;	O
}	O
if	O
(	O
WaitEvent	union
.	O
xbutton	struct
.	O
button	int
==	O
Button2	int
)	O
{	O
if	O
(	O
!	O
zoomed	int
)	O
{	O
zoomed	int
=	O
1	int
;	O
po	pointer
->	O
HP_to_xdots	double
*=	O
2	int
;	O
po	pointer
->	O
HP_to_ydots	double
*=	O
2	int
;	O
po	pointer
->	O
dpi_x	int
*=	O
2	int
;	O
po	pointer
->	O
dpi_y	int
*=	O
2	int
;	O
saved_row	int
=	O
row_start	int
;	O
saved_col	int
=	O
col_start	int
;	O
row_start	int
=	O
height	int
-	O
WaitEvent	union
.	O
xbutton	struct
.	O
y	int
+	O
2	int
*	O
saved_row	int
;	O
if	O
(	O
height	int
<	O
scr_height	int
)	O
row_start	int
=	O
height	int
-	O
WaitEvent	union
.	O
xbutton	struct
.	O
y	int
;	O
col_start	int
=	O
WaitEvent	union
.	O
xbutton	struct
.	O
x	int
+	O
col_start	int
;	O
}	O
else	O
{	O
zoomed	int
=	O
0	int
;	O
po	pointer
->	O
dpi_x	int
=	O
po	pointer
->	O
dpi_x	int
/	O
2	int
;	O
po	pointer
->	O
dpi_y	int
=	O
po	pointer
->	O
dpi_y	int
/	O
2	int
;	O
po	pointer
->	O
HP_to_xdots	double
=	O
po	pointer
->	O
HP_to_xdots	double
/	O
2	int
;	O
po	pointer
->	O
HP_to_ydots	double
=	O
po	pointer
->	O
HP_to_ydots	double
/	O
2	int
;	O
row_start	int
=	O
saved_row	int
;	O
col_start	int
=	O
saved_col	int
;	O
}	O
free_PicBuf	function
(	O
po	pointer
->	O
picbuf	pointer
)	O
;	O
po	pointer
->	O
picbuf	pointer
=	O
NULL	O
;	O
TMP_to_BUF	function
(	O
pg	pointer
,	O
po	pointer
)	O
;	O
pb	pointer
=	O
po	pointer
->	O
picbuf	pointer
;	O
}	O
if	O
(	O
WaitEvent	union
.	O
xbutton	struct
.	O
button	int
==	O
Button3	int
)	O
{	O
win_close	function
(	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
WaitEvent	union
.	O
type	pointer
==	O
ButtonRelease	int
)	O
{	O
if	O
(	O
WaitEvent	union
.	O
xbutton	struct
.	O
button	int
==	O
Button1	int
)	O
{	O
if	O
(	O
oversized	int
)	O
{	O
row_start	int
+=	O
WaitEvent	union
.	O
xbutton	struct
.	O
y	int
-	O
yref	int
;	O
col_start	int
+=	O
xref	int
-	O
WaitEvent	union
.	O
xbutton	struct
.	O
x	int
;	O
}	O
XSetForeground	function
(	O
XDisplay	pointer
,	O
XGcWin	pointer
,	O
WhitePixel	O
(	O
XDisplay	pointer
,	O
XScreen	int
)	O
)	O
;	O
XFillRectangle	function
(	O
XDisplay	pointer
,	O
XWin	long
,	O
XGcWin	pointer
,	O
0	int
,	O
0	int
,	O
(	O
unsigned	O
int	O
)	O
scr_width	int
,	O
(	O
unsigned	O
int	O
)	O
scr_height	int
)	O
;	O
goto	O
REDRAW	O
;	O
}	O
if	O
(	O
WaitEvent	union
.	O
xbutton	struct
.	O
button	int
==	O
Button2	int
)	O
{	O
XSetForeground	function
(	O
XDisplay	pointer
,	O
XGcWin	pointer
,	O
WhitePixel	O
(	O
XDisplay	pointer
,	O
XScreen	int
)	O
)	O
;	O
XFillRectangle	function
(	O
XDisplay	pointer
,	O
XWin	long
,	O
XGcWin	pointer
,	O
0	int
,	O
0	int
,	O
(	O
unsigned	O
int	O
)	O
scr_width	int
,	O
(	O
unsigned	O
int	O
)	O
scr_height	int
)	O
;	O
goto	O
REDRAW	O
;	O
}	O
break	O
;	O
}	O
}	O
while	O
(	O
WaitEvent	union
.	O
type	pointer
!=	O
KeyPress	int
)	O
;	O
win_close	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
