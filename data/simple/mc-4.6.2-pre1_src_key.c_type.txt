int	O
mou_auto_repeat	int
=	O
100	int
;	O
int	O
double_click_speed	int
=	O
250	int
;	O
int	O
old_esc_mode	int
=	O
0	int
;	O
int	O
keyboard_key_timeout	int
=	O
1000000	int
;	O
int	O
use_8th_bit_as_meta	int
=	O
0	int
;	O
typedef	O
struct	O
key_def	struct
{	O
char	O
ch	int
;	O
int	O
code	int
;	O
struct	O
key_def	struct
*	O
next	pointer
;	O
struct	O
key_def	struct
*	O
child	pointer
;	O
int	O
action	int
;	O
}	O
key_def	struct
;	O
static	O
key_def	struct
*	O
keys	pointer
=	O
NULL	O
;	O
static	O
int	O
input_fd	int
;	O
static	O
int	O
disabled_channels	int
=	O
0	int
;	O
static	O
int	O
xgetch_second	function
(	O
void	O
)	O
;	O
static	O
int	O
get_modifier	function
(	O
void	O
)	O
;	O
typedef	O
struct	O
SelectList	struct
{	O
int	O
fd	int
;	O
select_fn	pointer
callback	pointer
;	O
void	O
*	O
info	pointer
;	O
struct	O
SelectList	struct
*	O
next	pointer
;	O
}	O
SelectList	struct
;	O
static	O
SelectList	struct
*	O
select_list	pointer
=	O
NULL	O
;	O
void	O
add_select_channel	function
(	O
int	O
fd	int
,	O
select_fn	pointer
callback	pointer
,	O
void	O
*	O
info	pointer
)	O
{	O
SelectList	struct
*	O
new	pointer
;	O
new	pointer
=	O
g_new	O
(	O
SelectList	struct
,	O
1	int
)	O
;	O
new	pointer
->	O
fd	int
=	O
fd	int
;	O
new	pointer
->	O
callback	pointer
=	O
callback	pointer
;	O
new	pointer
->	O
info	pointer
=	O
info	pointer
;	O
new	pointer
->	O
next	pointer
=	O
select_list	pointer
;	O
select_list	pointer
=	O
new	pointer
;	O
}	O
void	O
delete_select_channel	function
(	O
int	O
fd	int
)	O
{	O
SelectList	struct
*	O
p	pointer
=	O
select_list	pointer
;	O
SelectList	struct
*	O
p_prev	pointer
=	O
NULL	O
;	O
SelectList	struct
*	O
p_next	pointer
;	O
while	O
(	O
p	pointer
)	O
{	O
if	O
(	O
p	pointer
->	O
fd	int
==	O
fd	int
)	O
{	O
p_next	pointer
=	O
p	pointer
->	O
next	pointer
;	O
if	O
(	O
p_prev	pointer
)	O
p_prev	pointer
->	O
next	pointer
=	O
p_next	pointer
;	O
else	O
select_list	pointer
=	O
p_next	pointer
;	O
g_free	function
(	O
p	pointer
)	O
;	O
p	pointer
=	O
p_next	pointer
;	O
continue	O
;	O
}	O
p_prev	pointer
=	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
;	O
}	O
}	O
inline	O
static	O
int	O
add_selects	function
(	O
fd_set	struct
*	O
select_set	pointer
)	O
{	O
SelectList	struct
*	O
p	pointer
;	O
int	O
top_fd	int
=	O
0	int
;	O
if	O
(	O
disabled_channels	int
)	O
return	O
0	int
;	O
for	O
(	O
p	pointer
=	O
select_list	pointer
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
FD_SET	O
(	O
p	pointer
->	O
fd	int
,	O
select_set	pointer
)	O
;	O
if	O
(	O
p	pointer
->	O
fd	int
>	O
top_fd	int
)	O
top_fd	int
=	O
p	pointer
->	O
fd	int
;	O
}	O
return	O
top_fd	int
;	O
}	O
static	O
void	O
check_selects	function
(	O
fd_set	struct
*	O
select_set	pointer
)	O
{	O
SelectList	struct
*	O
p	pointer
;	O
gboolean	int
retry	int
;	O
if	O
(	O
disabled_channels	int
)	O
return	O
;	O
do	O
{	O
retry	int
=	O
FALSE	O
;	O
for	O
(	O
p	pointer
=	O
select_list	pointer
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
if	O
(	O
FD_ISSET	O
(	O
p	pointer
->	O
fd	int
,	O
select_set	pointer
)	O
)	O
{	O
FD_CLR	O
(	O
p	pointer
->	O
fd	int
,	O
select_set	pointer
)	O
;	O
(	O
*	O
p	pointer
->	O
callback	pointer
)	O
(	O
p	pointer
->	O
fd	int
,	O
p	pointer
->	O
info	pointer
)	O
;	O
retry	int
=	O
TRUE	O
;	O
break	O
;	O
}	O
}	O
while	O
(	O
retry	int
)	O
;	O
}	O
void	O
channels_down	function
(	O
void	O
)	O
{	O
disabled_channels	int
++	O
;	O
}	O
void	O
channels_up	function
(	O
void	O
)	O
{	O
if	O
(	O
!	O
disabled_channels	int
)	O
fputs	function
(	O
"Error: channels_up called with disabled_channels = 0\n"	pointer
,	O
stderr	pointer
)	O
;	O
disabled_channels	int
--	O
;	O
}	O
typedef	O
const	O
struct	O
{	O
int	O
code	int
;	O
const	O
char	O
*	O
seq	pointer
;	O
int	O
action	int
;	O
}	O
key_define_t	struct
;	O
static	O
key_define_t	struct
xterm_key_defines	array
[	O
]	O
=	O
{	O
{	O
KEY_F	O
(	O
1	int
)	O
,	O
ESC_STR	pointer
"OP"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_F	O
(	O
2	int
)	O
,	O
ESC_STR	pointer
"OQ"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_F	O
(	O
3	int
)	O
,	O
ESC_STR	pointer
"OR"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_F	O
(	O
4	int
)	O
,	O
ESC_STR	pointer
"OS"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_F	O
(	O
1	int
)	O
,	O
ESC_STR	pointer
"[11~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_F	O
(	O
2	int
)	O
,	O
ESC_STR	pointer
"[12~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_F	O
(	O
3	int
)	O
,	O
ESC_STR	pointer
"[13~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_F	O
(	O
4	int
)	O
,	O
ESC_STR	pointer
"[14~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_F	O
(	O
5	int
)	O
,	O
ESC_STR	pointer
"[15~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_F	O
(	O
6	int
)	O
,	O
ESC_STR	pointer
"[17~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_F	O
(	O
7	int
)	O
,	O
ESC_STR	pointer
"[18~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_F	O
(	O
8	int
)	O
,	O
ESC_STR	pointer
"[19~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_F	O
(	O
9	int
)	O
,	O
ESC_STR	pointer
"[20~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_F	O
(	O
10	int
)	O
,	O
ESC_STR	pointer
"[21~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_UP	int
,	O
ESC_STR	pointer
"O2A"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_DOWN	int
,	O
ESC_STR	pointer
"O2B"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_RIGHT	int
,	O
ESC_STR	pointer
"O2C"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_LEFT	int
,	O
ESC_STR	pointer
"O2D"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_UP	int
,	O
ESC_STR	pointer
"[1;2A"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_DOWN	int
,	O
ESC_STR	pointer
"[1;2B"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_RIGHT	int
,	O
ESC_STR	pointer
"[1;2C"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_LEFT	int
,	O
ESC_STR	pointer
"[1;2D"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_PPAGE	int
,	O
ESC_STR	pointer
"[5;5~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_NPAGE	int
,	O
ESC_STR	pointer
"[6;5~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_IC	int
,	O
ESC_STR	pointer
"[2;5~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_DC	int
,	O
ESC_STR	pointer
"[3;5~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_HOME	int
,	O
ESC_STR	pointer
"[1;5H"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_END	int
,	O
ESC_STR	pointer
"[1;5F"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_HOME	int
,	O
ESC_STR	pointer
"[1;2H"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_END	int
,	O
ESC_STR	pointer
"[1;2F"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_UP	int
,	O
ESC_STR	pointer
"[1;5A"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_DOWN	int
,	O
ESC_STR	pointer
"[1;5B"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_RIGHT	int
,	O
ESC_STR	pointer
"[1;5C"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_LEFT	int
,	O
ESC_STR	pointer
"[1;5D"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_IC	int
,	O
ESC_STR	pointer
"[2;2~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_DC	int
,	O
ESC_STR	pointer
"[3;2~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_M_CTRL	int
|	O
KEY_UP	int
,	O
ESC_STR	pointer
"[1;6A"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_M_CTRL	int
|	O
KEY_DOWN	int
,	O
ESC_STR	pointer
"[1;6B"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_M_CTRL	int
|	O
KEY_RIGHT	int
,	O
ESC_STR	pointer
"[1;6C"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_M_CTRL	int
|	O
KEY_LEFT	int
,	O
ESC_STR	pointer
"[1;6D"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_UP	int
,	O
ESC_STR	pointer
"[a"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_DOWN	int
,	O
ESC_STR	pointer
"[b"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_RIGHT	int
,	O
ESC_STR	pointer
"[c"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_LEFT	int
,	O
ESC_STR	pointer
"[d"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_UP	int
,	O
ESC_STR	pointer
"Oa"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_DOWN	int
,	O
ESC_STR	pointer
"Ob"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_RIGHT	int
,	O
ESC_STR	pointer
"Oc"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_LEFT	int
,	O
ESC_STR	pointer
"Od"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_PPAGE	int
,	O
ESC_STR	pointer
"[5^"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_NPAGE	int
,	O
ESC_STR	pointer
"[6^"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_HOME	int
,	O
ESC_STR	pointer
"[7^"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_END	int
,	O
ESC_STR	pointer
"[8^"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_HOME	int
,	O
ESC_STR	pointer
"[7$"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_END	int
,	O
ESC_STR	pointer
"[8$"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_IC	int
,	O
ESC_STR	pointer
"[2^"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_DC	int
,	O
ESC_STR	pointer
"[3^"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_DC	int
,	O
ESC_STR	pointer
"[3$"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_HOME	int
,	O
ESC_STR	pointer
"O2H"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_END	int
,	O
ESC_STR	pointer
"O2F"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_UP	int
,	O
ESC_STR	pointer
"[2A"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_DOWN	int
,	O
ESC_STR	pointer
"[2B"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_RIGHT	int
,	O
ESC_STR	pointer
"[2C"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_LEFT	int
,	O
ESC_STR	pointer
"[2D"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_UP	int
,	O
ESC_STR	pointer
"[5A"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_DOWN	int
,	O
ESC_STR	pointer
"[5B"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_RIGHT	int
,	O
ESC_STR	pointer
"[5C"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_LEFT	int
,	O
ESC_STR	pointer
"[5D"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_M_CTRL	int
|	O
KEY_UP	int
,	O
ESC_STR	pointer
"[6A"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_M_CTRL	int
|	O
KEY_DOWN	int
,	O
ESC_STR	pointer
"[6B"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_M_CTRL	int
|	O
KEY_RIGHT	int
,	O
ESC_STR	pointer
"[6C"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_M_CTRL	int
|	O
KEY_LEFT	int
,	O
ESC_STR	pointer
"[6D"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_UP	int
,	O
ESC_STR	pointer
"O5A"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_DOWN	int
,	O
ESC_STR	pointer
"O5B"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_RIGHT	int
,	O
ESC_STR	pointer
"O5C"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_LEFT	int
,	O
ESC_STR	pointer
"O5D"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_M_CTRL	int
|	O
KEY_UP	int
,	O
ESC_STR	pointer
"O6A"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_M_CTRL	int
|	O
KEY_DOWN	int
,	O
ESC_STR	pointer
"O6B"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_M_CTRL	int
|	O
KEY_RIGHT	int
,	O
ESC_STR	pointer
"O6C"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_M_CTRL	int
|	O
KEY_LEFT	int
,	O
ESC_STR	pointer
"O6D"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_PPAGE	int
,	O
ESC_STR	pointer
"[5;2~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_NPAGE	int
,	O
ESC_STR	pointer
"[6;2~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_IC	int
,	O
ESC_STR	pointer
"Op"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_DC	int
,	O
ESC_STR	pointer
"On"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
'/'	O
,	O
ESC_STR	pointer
"Oo"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
'\n'	O
,	O
ESC_STR	pointer
"OM"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
MCKEY_NOACTION	int
}	O
,	O
}	O
;	O
static	O
key_define_t	struct
qansi_key_defines	array
[	O
]	O
=	O
{	O
{	O
KEY_M_CTRL	int
|	O
KEY_NPAGE	int
,	O
ESC_STR	pointer
"[u"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_PPAGE	int
,	O
ESC_STR	pointer
"[v"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_HOME	int
,	O
ESC_STR	pointer
"[h"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_END	int
,	O
ESC_STR	pointer
"[y"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_IC	int
,	O
ESC_STR	pointer
"[`"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_DC	int
,	O
ESC_STR	pointer
"[p"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_LEFT	int
,	O
ESC_STR	pointer
"[d"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_RIGHT	int
,	O
ESC_STR	pointer
"[c"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_DOWN	int
,	O
ESC_STR	pointer
"[b"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_UP	int
,	O
ESC_STR	pointer
"[a"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_KP_ADD	int
,	O
ESC_STR	pointer
"[s"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_KP_SUBTRACT	int
,	O
ESC_STR	pointer
"[t"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
'\t'	O
,	O
ESC_STR	pointer
"[z"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
'\t'	O
,	O
ESC_STR	pointer
"[Z"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_F	O
(	O
1	int
)	O
,	O
ESC_STR	pointer
"[1~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_F	O
(	O
2	int
)	O
,	O
ESC_STR	pointer
"[2~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_F	O
(	O
3	int
)	O
,	O
ESC_STR	pointer
"[3~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_F	O
(	O
4	int
)	O
,	O
ESC_STR	pointer
"[4~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_F	O
(	O
5	int
)	O
,	O
ESC_STR	pointer
"[5~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_F	O
(	O
6	int
)	O
,	O
ESC_STR	pointer
"[6~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_F	O
(	O
7	int
)	O
,	O
ESC_STR	pointer
"[7~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_F	O
(	O
8	int
)	O
,	O
ESC_STR	pointer
"[8~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_F	O
(	O
9	int
)	O
,	O
ESC_STR	pointer
"[9~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_F	O
(	O
10	int
)	O
,	O
ESC_STR	pointer
"[10~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_F	O
(	O
11	int
)	O
,	O
ESC_STR	pointer
"[11~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_F	O
(	O
12	int
)	O
,	O
ESC_STR	pointer
"[12~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
KEY_F	O
(	O
1	int
)	O
,	O
ESC_STR	pointer
"[17~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
KEY_F	O
(	O
2	int
)	O
,	O
ESC_STR	pointer
"[18~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
KEY_F	O
(	O
3	int
)	O
,	O
ESC_STR	pointer
"[19~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
KEY_F	O
(	O
4	int
)	O
,	O
ESC_STR	pointer
"[20~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
KEY_F	O
(	O
5	int
)	O
,	O
ESC_STR	pointer
"[21~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
KEY_F	O
(	O
6	int
)	O
,	O
ESC_STR	pointer
"[22~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
KEY_F	O
(	O
7	int
)	O
,	O
ESC_STR	pointer
"[23~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
KEY_F	O
(	O
8	int
)	O
,	O
ESC_STR	pointer
"[24~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
KEY_F	O
(	O
9	int
)	O
,	O
ESC_STR	pointer
"[25~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
KEY_F	O
(	O
10	int
)	O
,	O
ESC_STR	pointer
"[26~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
KEY_F	O
(	O
11	int
)	O
,	O
ESC_STR	pointer
"[27~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
KEY_F	O
(	O
12	int
)	O
,	O
ESC_STR	pointer
"[28~"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'a'	O
,	O
ESC_STR	pointer
"Na"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'b'	O
,	O
ESC_STR	pointer
"Nb"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'c'	O
,	O
ESC_STR	pointer
"Nc"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'd'	O
,	O
ESC_STR	pointer
"Nd"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'e'	O
,	O
ESC_STR	pointer
"Ne"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'f'	O
,	O
ESC_STR	pointer
"Nf"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'g'	O
,	O
ESC_STR	pointer
"Ng"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'i'	O
,	O
ESC_STR	pointer
"Ni"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'j'	O
,	O
ESC_STR	pointer
"Nj"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'k'	O
,	O
ESC_STR	pointer
"Nk"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'l'	O
,	O
ESC_STR	pointer
"Nl"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'm'	O
,	O
ESC_STR	pointer
"Nm"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'n'	O
,	O
ESC_STR	pointer
"Nn"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'o'	O
,	O
ESC_STR	pointer
"No"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'p'	O
,	O
ESC_STR	pointer
"Np"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'q'	O
,	O
ESC_STR	pointer
"Nq"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
's'	O
,	O
ESC_STR	pointer
"Ns"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
't'	O
,	O
ESC_STR	pointer
"Nt"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'u'	O
,	O
ESC_STR	pointer
"Nu"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'v'	O
,	O
ESC_STR	pointer
"Nv"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'w'	O
,	O
ESC_STR	pointer
"Nw"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'x'	O
,	O
ESC_STR	pointer
"Nx"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'y'	O
,	O
ESC_STR	pointer
"Ny"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'z'	O
,	O
ESC_STR	pointer
"Nz"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_KP_SUBTRACT	int
,	O
ESC_STR	pointer
"[S"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_KP_ADD	int
,	O
ESC_STR	pointer
"[T"	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
0	int
,	O
NULL	O
,	O
MCKEY_NOACTION	int
}	O
,	O
}	O
;	O
static	O
key_define_t	struct
mc_default_keys	array
[	O
]	O
=	O
{	O
{	O
ESC_CHAR	char
,	O
ESC_STR	pointer
,	O
MCKEY_ESCAPE	int
}	O
,	O
{	O
ESC_CHAR	char
,	O
ESC_STR	pointer
ESC_STR	pointer
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
0	int
,	O
NULL	O
,	O
MCKEY_NOACTION	int
}	O
,	O
}	O
;	O
static	O
void	O
define_sequences	function
(	O
key_define_t	struct
*	O
kd	pointer
)	O
{	O
int	O
i	array
;	O
for	O
(	O
i	array
=	O
0	int
;	O
kd	pointer
[	O
i	array
]	O
.	O
code	int
!=	O
0	int
;	O
i	array
++	O
)	O
define_sequence	function
(	O
kd	pointer
[	O
i	array
]	O
.	O
code	int
,	O
kd	pointer
[	O
i	array
]	O
.	O
seq	pointer
,	O
kd	pointer
[	O
i	array
]	O
.	O
action	int
)	O
;	O
}	O
void	O
init_key	function
(	O
void	O
)	O
{	O
const	O
char	O
*	O
term	pointer
=	O
getenv	function
(	O
"TERM"	pointer
)	O
;	O
char	O
*	O
kt	pointer
=	O
getenv	function
(	O
"KEYBOARD_KEY_TIMEOUT_US"	pointer
)	O
;	O
if	O
(	O
kt	pointer
!=	O
NULL	O
)	O
keyboard_key_timeout	int
=	O
atoi	function
(	O
kt	pointer
)	O
;	O
define_sequences	function
(	O
mc_default_keys	array
)	O
;	O
if	O
(	O
xterm_flag	int
||	O
(	O
term	pointer
!=	O
NULL	O
&&	O
(	O
strncmp	function
(	O
term	pointer
,	O
"iris-ansi"	pointer
,	O
9	int
)	O
==	O
0	int
||	O
strncmp	function
(	O
term	pointer
,	O
"xterm"	pointer
,	O
5	int
)	O
==	O
0	int
||	O
strncmp	function
(	O
term	pointer
,	O
"rxvt"	pointer
,	O
4	int
)	O
==	O
0	int
||	O
strcmp	function
(	O
term	pointer
,	O
"screen"	pointer
)	O
==	O
0	int
)	O
)	O
)	O
define_sequences	function
(	O
xterm_key_defines	array
)	O
;	O
load_xtra_key_defines	function
(	O
)	O
;	O
if	O
(	O
term	pointer
!=	O
NULL	O
&&	O
(	O
strncmp	function
(	O
term	pointer
,	O
"qansi-m"	pointer
,	O
7	int
)	O
==	O
0	int
)	O
)	O
{	O
define_sequences	function
(	O
qansi_key_defines	array
)	O
;	O
}	O
}	O
void	O
init_key_input_fd	function
(	O
void	O
)	O
{	O
input_fd	int
=	O
SLang_TT_Read_FD	int
;	O
}	O
static	O
void	O
xmouse_get_event	function
(	O
Gpm_Event	struct
*	O
ev	pointer
)	O
{	O
int	O
btn	int
;	O
static	O
struct	O
timeval	struct
tv1	struct
=	O
{	O
0	int
,	O
0	int
}	O
;	O
static	O
struct	O
timeval	struct
tv2	struct
;	O
static	O
int	O
clicks	int
;	O
static	O
int	O
last_btn	int
=	O
0	int
;	O
btn	int
=	O
getch	function
(	O
)	O
-	O
32	int
;	O
if	O
(	O
btn	int
==	O
3	int
)	O
{	O
if	O
(	O
last_btn	int
)	O
{	O
ev	pointer
->	O
type	enum
=	O
GPM_UP	int
|	O
(	O
GPM_SINGLE	int
<<	O
clicks	int
)	O
;	O
ev	pointer
->	O
buttons	int
=	O
0	int
;	O
last_btn	int
=	O
0	int
;	O
GET_TIME	O
(	O
tv1	struct
)	O
;	O
clicks	int
=	O
0	int
;	O
}	O
else	O
{	O
ev	pointer
->	O
type	enum
=	O
0	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
btn	int
>=	O
32	int
&&	O
btn	int
<=	O
34	int
)	O
{	O
btn	int
-=	O
32	int
;	O
ev	pointer
->	O
type	enum
=	O
GPM_DRAG	int
;	O
}	O
else	O
ev	pointer
->	O
type	enum
=	O
GPM_DOWN	int
;	O
GET_TIME	O
(	O
tv2	struct
)	O
;	O
if	O
(	O
tv1	struct
.	O
tv_sec	long
&&	O
(	O
DIF_TIME	O
(	O
tv1	struct
,	O
tv2	struct
)	O
<	O
double_click_speed	int
)	O
)	O
{	O
clicks	int
++	O
;	O
clicks	int
%=	O
3	int
;	O
}	O
else	O
clicks	int
=	O
0	int
;	O
switch	O
(	O
btn	int
)	O
{	O
case	O
0	int
:	O
ev	pointer
->	O
buttons	int
=	O
GPM_B_LEFT	O
;	O
break	O
;	O
case	O
1	int
:	O
ev	pointer
->	O
buttons	int
=	O
GPM_B_MIDDLE	O
;	O
break	O
;	O
case	O
2	int
:	O
ev	pointer
->	O
buttons	int
=	O
GPM_B_RIGHT	O
;	O
break	O
;	O
case	O
64	int
:	O
ev	pointer
->	O
buttons	int
=	O
GPM_B_UP	O
;	O
clicks	int
=	O
0	int
;	O
break	O
;	O
case	O
65	int
:	O
ev	pointer
->	O
buttons	int
=	O
GPM_B_DOWN	O
;	O
clicks	int
=	O
0	int
;	O
break	O
;	O
default	O
:	O
ev	pointer
->	O
type	enum
=	O
0	int
;	O
ev	pointer
->	O
buttons	int
=	O
0	int
;	O
break	O
;	O
}	O
last_btn	int
=	O
ev	pointer
->	O
buttons	int
;	O
}	O
ev	pointer
->	O
x	array
=	O
getch	function
(	O
)	O
-	O
32	int
;	O
ev	pointer
->	O
y	short
=	O
getch	function
(	O
)	O
-	O
32	int
;	O
}	O
static	O
key_def	struct
*	O
create_sequence	function
(	O
const	O
char	O
*	O
seq	pointer
,	O
int	O
code	int
,	O
int	O
action	int
)	O
{	O
key_def	struct
*	O
base	int
,	O
*	O
p	pointer
,	O
*	O
attach	pointer
;	O
for	O
(	O
base	int
=	O
attach	pointer
=	O
NULL	O
;	O
*	O
seq	pointer
;	O
seq	pointer
++	O
)	O
{	O
p	pointer
=	O
g_new	O
(	O
key_def	struct
,	O
1	int
)	O
;	O
if	O
(	O
!	O
base	int
)	O
base	int
=	O
p	pointer
;	O
if	O
(	O
attach	pointer
)	O
attach	pointer
->	O
child	pointer
=	O
p	pointer
;	O
p	pointer
->	O
ch	int
=	O
*	O
seq	pointer
;	O
p	pointer
->	O
code	int
=	O
code	int
;	O
p	pointer
->	O
child	pointer
=	O
p	pointer
->	O
next	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
seq	pointer
[	O
1	int
]	O
)	O
p	pointer
->	O
action	int
=	O
action	int
;	O
else	O
p	pointer
->	O
action	int
=	O
MCKEY_NOACTION	int
;	O
attach	pointer
=	O
p	pointer
;	O
}	O
return	O
base	int
;	O
}	O
static	O
int	O
seq_buffer	array
[	O
SEQ_BUFFER_LEN	int
]	O
;	O
static	O
int	O
*	O
seq_append	pointer
=	O
0	int
;	O
static	O
int	O
push_char	function
(	O
int	O
c	int
)	O
{	O
if	O
(	O
!	O
seq_append	pointer
)	O
seq_append	pointer
=	O
seq_buffer	array
;	O
if	O
(	O
seq_append	pointer
==	O
&	O
(	O
seq_buffer	array
[	O
SEQ_BUFFER_LEN	int
-	O
2	int
]	O
)	O
)	O
return	O
0	int
;	O
*	O
(	O
seq_append	pointer
++	O
)	O
=	O
c	int
;	O
*	O
seq_append	pointer
=	O
0	int
;	O
return	O
1	int
;	O
}	O
int	O
define_sequence	function
(	O
int	O
code	int
,	O
const	O
char	O
*	O
seq	pointer
,	O
int	O
action	int
)	O
{	O
key_def	struct
*	O
base	int
;	O
if	O
(	O
strlen	function
(	O
seq	pointer
)	O
>	O
SEQ_BUFFER_LEN	int
-	O
1	int
)	O
return	O
0	int
;	O
for	O
(	O
base	int
=	O
keys	pointer
;	O
(	O
base	int
!=	O
0	int
)	O
&&	O
*	O
seq	pointer
;	O
)	O
{	O
if	O
(	O
*	O
seq	pointer
==	O
base	int
->	O
ch	int
)	O
{	O
if	O
(	O
base	int
->	O
child	pointer
==	O
0	int
)	O
{	O
if	O
(	O
*	O
(	O
seq	pointer
+	O
1	int
)	O
)	O
{	O
base	int
->	O
child	pointer
=	O
create_sequence	function
(	O
seq	pointer
+	O
1	int
,	O
code	int
,	O
action	int
)	O
;	O
return	O
1	int
;	O
}	O
else	O
{	O
base	int
->	O
code	int
=	O
code	int
;	O
base	int
->	O
action	int
=	O
action	int
;	O
return	O
1	int
;	O
}	O
}	O
else	O
{	O
base	int
=	O
base	int
->	O
child	pointer
;	O
seq	pointer
++	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
base	int
->	O
next	pointer
)	O
base	int
=	O
base	int
->	O
next	pointer
;	O
else	O
{	O
base	int
->	O
next	pointer
=	O
create_sequence	function
(	O
seq	pointer
,	O
code	int
,	O
action	int
)	O
;	O
return	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
!	O
*	O
seq	pointer
)	O
{	O
return	O
0	int
;	O
}	O
keys	pointer
=	O
create_sequence	function
(	O
seq	pointer
,	O
code	int
,	O
action	int
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
*	O
pending_keys	pointer
;	O
static	O
int	O
correct_key_code	function
(	O
int	O
code	int
)	O
{	O
unsigned	O
int	O
c	int
=	O
code	int
&	O
~	O
KEY_M_MASK	int
;	O
unsigned	O
int	O
mod	int
=	O
code	int
&	O
KEY_M_MASK	int
;	O
if	O
(	O
c	int
<	O
32	int
||	O
c	int
>=	O
256	int
)	O
{	O
mod	int
|=	O
get_modifier	function
(	O
)	O
;	O
}	O
if	O
(	O
c	int
==	O
'\r'	O
)	O
c	int
=	O
'\n'	O
;	O
if	O
(	O
c	int
==	O
KEY_SCANCEL	int
)	O
c	int
=	O
'\t'	O
;	O
if	O
(	O
(	O
c	int
==	O
'\t'	O
)	O
&&	O
(	O
mod	int
&	O
(	O
KEY_M_SHIFT	int
|	O
KEY_M_CTRL	int
)	O
)	O
)	O
{	O
c	int
=	O
KEY_BTAB	int
;	O
mod	int
=	O
0	int
;	O
}	O
if	O
(	O
c	int
==	O
KEY_F	O
(	O
0	int
)	O
)	O
c	int
=	O
KEY_F	O
(	O
10	int
)	O
;	O
if	O
(	O
c	int
<	O
32	int
&&	O
c	int
!=	O
ESC_CHAR	char
&&	O
c	int
!=	O
'\t'	O
&&	O
c	int
!=	O
'\n'	O
)	O
{	O
mod	int
|=	O
KEY_M_CTRL	int
;	O
}	O
if	O
(	O
c	int
==	O
0177	int
)	O
{	O
c	int
=	O
KEY_BACKSPACE	int
;	O
}	O
if	O
(	O
c	int
==	O
(	O
31	int
&	O
'd'	O
)	O
)	O
{	O
c	int
=	O
KEY_DC	int
;	O
mod	int
&=	O
~	O
KEY_M_CTRL	int
;	O
}	O
if	O
(	O
c	int
==	O
(	O
31	int
&	O
'h'	O
)	O
)	O
{	O
c	int
=	O
KEY_BACKSPACE	int
;	O
mod	int
&=	O
~	O
KEY_M_CTRL	int
;	O
}	O
if	O
(	O
c	int
==	O
KEY_BACKSPACE	int
&&	O
(	O
mod	int
&	O
KEY_M_SHIFT	int
)	O
)	O
{	O
mod	int
&=	O
~	O
KEY_M_SHIFT	int
;	O
}	O
if	O
(	O
c	int
>=	O
KEY_F	O
(	O
1	int
)	O
&&	O
c	int
<=	O
KEY_F	O
(	O
10	int
)	O
&&	O
(	O
mod	int
&	O
KEY_M_SHIFT	int
)	O
)	O
{	O
c	int
+=	O
10	int
;	O
}	O
if	O
(	O
c	int
>=	O
KEY_F	O
(	O
1	int
)	O
&&	O
c	int
<=	O
KEY_F	O
(	O
20	int
)	O
)	O
{	O
mod	int
&=	O
~	O
KEY_M_SHIFT	int
;	O
}	O
if	O
(	O
!	O
alternate_plus_minus	int
)	O
switch	O
(	O
c	int
)	O
{	O
case	O
KEY_KP_ADD	int
:	O
c	int
=	O
'+'	O
;	O
break	O
;	O
case	O
KEY_KP_SUBTRACT	int
:	O
c	int
=	O
'-'	O
;	O
break	O
;	O
case	O
KEY_KP_MULTIPLY	int
:	O
c	int
=	O
'*'	O
;	O
break	O
;	O
}	O
return	O
(	O
mod	int
|	O
c	int
)	O
;	O
}	O
int	O
get_key_code	function
(	O
int	O
no_delay	int
)	O
{	O
int	O
c	int
;	O
static	O
key_def	struct
*	O
this	pointer
=	O
NULL	O
,	O
*	O
parent	pointer
;	O
static	O
struct	O
timeval	struct
esctime	struct
=	O
{	O
-	O
1	int
,	O
-	O
1	int
}	O
;	O
static	O
int	O
lastnodelay	int
=	O
-	O
1	int
;	O
if	O
(	O
no_delay	int
!=	O
lastnodelay	int
)	O
{	O
this	pointer
=	O
NULL	O
;	O
lastnodelay	int
=	O
no_delay	int
;	O
}	O
pend_send	O
:	O
if	O
(	O
pending_keys	pointer
)	O
{	O
int	O
d	double
=	O
*	O
pending_keys	pointer
++	O
;	O
check_pend	O
:	O
if	O
(	O
!	O
*	O
pending_keys	pointer
)	O
{	O
pending_keys	pointer
=	O
0	int
;	O
seq_append	pointer
=	O
0	int
;	O
}	O
if	O
(	O
d	double
==	O
ESC_CHAR	char
&&	O
pending_keys	pointer
)	O
{	O
d	double
=	O
ALT	O
(	O
*	O
pending_keys	pointer
++	O
)	O
;	O
goto	O
check_pend	O
;	O
}	O
if	O
(	O
(	O
d	double
>	O
127	int
&&	O
d	double
<	O
256	int
)	O
&&	O
use_8th_bit_as_meta	int
)	O
d	double
=	O
ALT	O
(	O
d	double
&	O
0x7f	int
)	O
;	O
this	pointer
=	O
NULL	O
;	O
return	O
correct_key_code	function
(	O
d	double
)	O
;	O
}	O
nodelay_try_again	O
:	O
if	O
(	O
no_delay	int
)	O
{	O
nodelay	int
(	O
stdscr	O
,	O
TRUE	O
)	O
;	O
}	O
c	int
=	O
getch	function
(	O
)	O
;	O
if	O
(	O
no_delay	int
)	O
{	O
nodelay	int
(	O
stdscr	O
,	O
FALSE	O
)	O
;	O
if	O
(	O
c	int
==	O
-	O
1	int
)	O
{	O
if	O
(	O
this	pointer
!=	O
NULL	O
&&	O
parent	pointer
!=	O
NULL	O
&&	O
parent	pointer
->	O
action	int
==	O
MCKEY_ESCAPE	int
&&	O
old_esc_mode	int
)	O
{	O
struct	O
timeval	struct
current	pointer
,	O
timeout	long
;	O
if	O
(	O
esctime	struct
.	O
tv_sec	long
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
GET_TIME	O
(	O
current	pointer
)	O
;	O
timeout	long
.	O
tv_sec	long
=	O
keyboard_key_timeout	int
/	O
1000000	int
+	O
esctime	struct
.	O
tv_sec	long
;	O
timeout	long
.	O
tv_usec	long
=	O
keyboard_key_timeout	int
%	O
1000000	int
+	O
esctime	struct
.	O
tv_usec	long
;	O
if	O
(	O
timeout	long
.	O
tv_usec	long
>	O
1000000	int
)	O
{	O
timeout	long
.	O
tv_usec	long
-=	O
1000000	int
;	O
timeout	long
.	O
tv_sec	long
++	O
;	O
}	O
if	O
(	O
current	pointer
.	O
tv_sec	long
<	O
timeout	long
.	O
tv_sec	long
)	O
return	O
-	O
1	int
;	O
if	O
(	O
current	pointer
.	O
tv_sec	long
==	O
timeout	long
.	O
tv_sec	long
&&	O
current	pointer
.	O
tv_usec	long
<	O
timeout	long
.	O
tv_usec	long
)	O
return	O
-	O
1	int
;	O
this	pointer
=	O
NULL	O
;	O
pending_keys	pointer
=	O
seq_append	pointer
=	O
NULL	O
;	O
return	O
ESC_CHAR	char
;	O
}	O
return	O
-	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
c	int
==	O
-	O
1	int
)	O
{	O
if	O
(	O
seq_append	pointer
)	O
{	O
pending_keys	pointer
=	O
seq_buffer	array
;	O
goto	O
pend_send	O
;	O
}	O
this	pointer
=	O
NULL	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
!	O
no_delay	int
||	O
this	pointer
==	O
NULL	O
)	O
{	O
this	pointer
=	O
keys	pointer
;	O
parent	pointer
=	O
NULL	O
;	O
if	O
(	O
(	O
c	int
>	O
127	int
&&	O
c	int
<	O
256	int
)	O
&&	O
use_8th_bit_as_meta	int
)	O
{	O
c	int
&=	O
0x7f	int
;	O
parent	pointer
=	O
keys	pointer
;	O
this	pointer
=	O
keys	pointer
->	O
child	pointer
;	O
}	O
}	O
while	O
(	O
this	pointer
)	O
{	O
if	O
(	O
c	int
==	O
this	pointer
->	O
ch	int
)	O
{	O
if	O
(	O
this	pointer
->	O
child	pointer
)	O
{	O
if	O
(	O
!	O
push_char	function
(	O
c	int
)	O
)	O
{	O
pending_keys	pointer
=	O
seq_buffer	array
;	O
goto	O
pend_send	O
;	O
}	O
parent	pointer
=	O
this	pointer
;	O
this	pointer
=	O
this	pointer
->	O
child	pointer
;	O
if	O
(	O
parent	pointer
->	O
action	int
==	O
MCKEY_ESCAPE	int
&&	O
old_esc_mode	int
)	O
{	O
if	O
(	O
no_delay	int
)	O
{	O
GET_TIME	O
(	O
esctime	struct
)	O
;	O
if	O
(	O
this	pointer
==	O
NULL	O
)	O
{	O
fputs	function
(	O
"Internal error\n"	pointer
,	O
stderr	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
goto	O
nodelay_try_again	O
;	O
}	O
esctime	struct
.	O
tv_sec	long
=	O
-	O
1	int
;	O
c	int
=	O
xgetch_second	function
(	O
)	O
;	O
if	O
(	O
c	int
==	O
-	O
1	int
)	O
{	O
pending_keys	pointer
=	O
seq_append	pointer
=	O
NULL	O
;	O
this	pointer
=	O
NULL	O
;	O
return	O
ESC_CHAR	char
;	O
}	O
}	O
else	O
{	O
if	O
(	O
no_delay	int
)	O
goto	O
nodelay_try_again	O
;	O
c	int
=	O
getch	function
(	O
)	O
;	O
}	O
}	O
else	O
{	O
int	O
code	int
;	O
pending_keys	pointer
=	O
seq_append	pointer
=	O
NULL	O
;	O
code	int
=	O
this	pointer
->	O
code	int
;	O
this	pointer
=	O
NULL	O
;	O
return	O
correct_key_code	function
(	O
code	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
this	pointer
->	O
next	pointer
)	O
this	pointer
=	O
this	pointer
->	O
next	pointer
;	O
else	O
{	O
if	O
(	O
parent	pointer
!=	O
NULL	O
&&	O
parent	pointer
->	O
action	int
==	O
MCKEY_ESCAPE	int
)	O
{	O
if	O
(	O
isdigit	function
(	O
c	int
)	O
)	O
c	int
=	O
KEY_F	O
(	O
c	int
-	O
'0'	O
)	O
;	O
else	O
if	O
(	O
c	int
==	O
' '	O
)	O
c	int
=	O
ESC_CHAR	char
;	O
else	O
c	int
=	O
ALT	O
(	O
c	int
)	O
;	O
pending_keys	pointer
=	O
seq_append	pointer
=	O
NULL	O
;	O
this	pointer
=	O
NULL	O
;	O
return	O
correct_key_code	function
(	O
c	int
)	O
;	O
}	O
push_char	function
(	O
c	int
)	O
;	O
pending_keys	pointer
=	O
seq_buffer	array
;	O
goto	O
pend_send	O
;	O
}	O
}	O
}	O
this	pointer
=	O
NULL	O
;	O
return	O
correct_key_code	function
(	O
c	int
)	O
;	O
}	O
static	O
void	O
try_channels	function
(	O
int	O
set_timeout	int
)	O
{	O
struct	O
timeval	struct
timeout	long
;	O
static	O
fd_set	struct
select_set	pointer
;	O
struct	O
timeval	struct
*	O
timeptr	pointer
;	O
int	O
v	pointer
;	O
int	O
maxfdp	int
;	O
while	O
(	O
1	int
)	O
{	O
FD_ZERO	O
(	O
&	O
select_set	pointer
)	O
;	O
FD_SET	O
(	O
input_fd	int
,	O
&	O
select_set	pointer
)	O
;	O
maxfdp	int
=	O
max	long
(	O
add_selects	function
(	O
&	O
select_set	pointer
)	O
,	O
input_fd	int
)	O
;	O
if	O
(	O
set_timeout	int
)	O
{	O
timeout	long
.	O
tv_sec	long
=	O
0	int
;	O
timeout	long
.	O
tv_usec	long
=	O
100000	int
;	O
timeptr	pointer
=	O
&	O
timeout	long
;	O
}	O
else	O
timeptr	pointer
=	O
0	int
;	O
v	pointer
=	O
select	function
(	O
maxfdp	int
+	O
1	int
,	O
&	O
select_set	pointer
,	O
NULL	O
,	O
NULL	O
,	O
timeptr	pointer
)	O
;	O
if	O
(	O
v	pointer
>	O
0	int
)	O
{	O
check_selects	function
(	O
&	O
select_set	pointer
)	O
;	O
if	O
(	O
FD_ISSET	O
(	O
input_fd	int
,	O
&	O
select_set	pointer
)	O
)	O
return	O
;	O
}	O
}	O
}	O
static	O
int	O
getch_with_delay	function
(	O
void	O
)	O
{	O
int	O
c	int
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
!	O
pending_keys	pointer
)	O
try_channels	function
(	O
0	int
)	O
;	O
c	int
=	O
get_key_code	function
(	O
0	int
)	O
;	O
if	O
(	O
c	int
!=	O
-	O
1	int
)	O
break	O
;	O
try_channels	function
(	O
1	int
)	O
;	O
}	O
return	O
c	int
;	O
}	O
int	O
get_event	function
(	O
struct	O
Gpm_Event	struct
*	O
event	pointer
,	O
int	O
redo_event	int
,	O
int	O
block	int
)	O
{	O
int	O
c	int
;	O
static	O
int	O
flag	int
;	O
struct	O
timeval	struct
timeout	long
;	O
struct	O
timeval	struct
*	O
time_addr	pointer
=	O
NULL	O
;	O
static	O
int	O
dirty	int
=	O
3	int
;	O
if	O
(	O
(	O
dirty	int
==	O
3	int
)	O
||	O
is_idle	function
(	O
)	O
)	O
{	O
mc_refresh	function
(	O
)	O
;	O
doupdate	O
(	O
)	O
;	O
dirty	int
=	O
1	int
;	O
}	O
else	O
dirty	int
++	O
;	O
vfs_timeout_handler	function
(	O
)	O
;	O
if	O
(	O
event	pointer
->	O
x	array
>	O
0	int
)	O
{	O
show_mouse_pointer	O
(	O
event	pointer
->	O
x	array
,	O
event	pointer
->	O
y	short
)	O
;	O
if	O
(	O
!	O
redo_event	int
)	O
event	pointer
->	O
x	array
=	O
-	O
1	int
;	O
}	O
while	O
(	O
mouse_enabled	int
&&	O
!	O
pending_keys	pointer
)	O
{	O
int	O
maxfdp	int
;	O
fd_set	struct
select_set	pointer
;	O
FD_ZERO	O
(	O
&	O
select_set	pointer
)	O
;	O
FD_SET	O
(	O
input_fd	int
,	O
&	O
select_set	pointer
)	O
;	O
maxfdp	int
=	O
max	long
(	O
add_selects	function
(	O
&	O
select_set	pointer
)	O
,	O
input_fd	int
)	O
;	O
if	O
(	O
redo_event	int
)	O
{	O
timeout	long
.	O
tv_usec	long
=	O
mou_auto_repeat	int
*	O
1000	int
;	O
timeout	long
.	O
tv_sec	long
=	O
0	int
;	O
time_addr	pointer
=	O
&	O
timeout	long
;	O
}	O
else	O
{	O
int	O
seconds	int
;	O
if	O
(	O
(	O
seconds	int
=	O
vfs_timeouts	function
(	O
)	O
)	O
)	O
{	O
timeout	long
.	O
tv_sec	long
=	O
seconds	int
;	O
timeout	long
.	O
tv_usec	long
=	O
0	int
;	O
time_addr	pointer
=	O
&	O
timeout	long
;	O
}	O
else	O
time_addr	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
!	O
block	int
||	O
winch_flag	int
)	O
{	O
time_addr	pointer
=	O
&	O
timeout	long
;	O
timeout	long
.	O
tv_sec	long
=	O
0	int
;	O
timeout	long
.	O
tv_usec	long
=	O
0	int
;	O
}	O
enable_interrupt_key	O
(	O
)	O
;	O
flag	int
=	O
select	function
(	O
maxfdp	int
+	O
1	int
,	O
&	O
select_set	pointer
,	O
NULL	O
,	O
NULL	O
,	O
time_addr	pointer
)	O
;	O
disable_interrupt_key	O
(	O
)	O
;	O
if	O
(	O
flag	int
==	O
0	int
)	O
{	O
if	O
(	O
redo_event	int
)	O
return	O
EV_MOUSE	O
;	O
if	O
(	O
!	O
block	int
||	O
winch_flag	int
)	O
return	O
EV_NONE	O
;	O
vfs_timeout_handler	function
(	O
)	O
;	O
}	O
if	O
(	O
flag	int
==	O
-	O
1	int
&&	O
errno	O
==	O
EINTR	int
)	O
return	O
EV_NONE	O
;	O
check_selects	function
(	O
&	O
select_set	pointer
)	O
;	O
if	O
(	O
FD_ISSET	O
(	O
input_fd	int
,	O
&	O
select_set	pointer
)	O
)	O
break	O
;	O
}	O
c	int
=	O
block	int
?	O
getch_with_delay	function
(	O
)	O
:	O
get_key_code	function
(	O
1	int
)	O
;	O
if	O
(	O
c	int
==	O
MCKEY_MOUSE	O
)	O
{	O
xmouse_get_event	function
(	O
event	pointer
)	O
;	O
if	O
(	O
event	pointer
->	O
type	enum
)	O
return	O
EV_MOUSE	O
;	O
else	O
return	O
EV_NONE	O
;	O
}	O
return	O
c	int
;	O
}	O
int	O
mi_getch	function
(	O
)	O
{	O
Gpm_Event	struct
ev	pointer
;	O
int	O
key	pointer
;	O
ev	pointer
.	O
x	array
=	O
-	O
1	int
;	O
while	O
(	O
(	O
key	pointer
=	O
get_event	function
(	O
&	O
ev	pointer
,	O
0	int
,	O
1	int
)	O
)	O
==	O
EV_NONE	O
)	O
;	O
return	O
key	pointer
;	O
}	O
static	O
int	O
xgetch_second	function
(	O
void	O
)	O
{	O
fd_set	struct
Read_FD_Set	struct
;	O
int	O
c	int
;	O
struct	O
timeval	struct
timeout	long
;	O
timeout	long
.	O
tv_sec	long
=	O
keyboard_key_timeout	int
/	O
1000000	int
;	O
timeout	long
.	O
tv_usec	long
=	O
keyboard_key_timeout	int
%	O
1000000	int
;	O
nodelay	int
(	O
stdscr	O
,	O
TRUE	O
)	O
;	O
FD_ZERO	O
(	O
&	O
Read_FD_Set	struct
)	O
;	O
FD_SET	O
(	O
input_fd	int
,	O
&	O
Read_FD_Set	struct
)	O
;	O
select	function
(	O
input_fd	int
+	O
1	int
,	O
&	O
Read_FD_Set	struct
,	O
NULL	O
,	O
NULL	O
,	O
&	O
timeout	long
)	O
;	O
c	int
=	O
getch	function
(	O
)	O
;	O
nodelay	int
(	O
stdscr	O
,	O
FALSE	O
)	O
;	O
return	O
c	int
;	O
}	O
static	O
void	O
learn_store_key	function
(	O
char	O
*	O
buffer	pointer
,	O
char	O
*	O
*	O
p	pointer
,	O
int	O
c	int
)	O
{	O
if	O
(	O
*	O
p	pointer
-	O
buffer	pointer
>	O
253	int
)	O
return	O
;	O
if	O
(	O
c	int
==	O
ESC_CHAR	char
)	O
{	O
*	O
(	O
*	O
p	pointer
)	O
++	O
=	O
'\\'	O
;	O
*	O
(	O
*	O
p	pointer
)	O
++	O
=	O
'e'	O
;	O
}	O
else	O
if	O
(	O
c	int
<	O
' '	O
)	O
{	O
*	O
(	O
*	O
p	pointer
)	O
++	O
=	O
'^'	O
;	O
*	O
(	O
*	O
p	pointer
)	O
++	O
=	O
c	int
+	O
'a'	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'^'	O
)	O
{	O
*	O
(	O
*	O
p	pointer
)	O
++	O
=	O
'^'	O
;	O
*	O
(	O
*	O
p	pointer
)	O
++	O
=	O
'^'	O
;	O
}	O
else	O
*	O
(	O
*	O
p	pointer
)	O
++	O
=	O
(	O
char	O
)	O
c	int
;	O
}	O
char	O
*	O
learn_key	function
(	O
void	O
)	O
{	O
fd_set	struct
Read_FD_Set	struct
;	O
struct	O
timeval	struct
endtime	struct
;	O
struct	O
timeval	struct
timeout	long
;	O
int	O
c	int
;	O
char	O
buffer	pointer
[	O
256	int
]	O
;	O
char	O
*	O
p	pointer
=	O
buffer	pointer
;	O
keypad	O
(	O
stdscr	O
,	O
FALSE	O
)	O
;	O
c	int
=	O
getch	function
(	O
)	O
;	O
while	O
(	O
c	int
==	O
-	O
1	int
)	O
c	int
=	O
getch	function
(	O
)	O
;	O
learn_store_key	function
(	O
buffer	pointer
,	O
&	O
p	pointer
,	O
c	int
)	O
;	O
GET_TIME	O
(	O
endtime	struct
)	O
;	O
endtime	struct
.	O
tv_usec	long
+=	O
LEARN_TIMEOUT	int
;	O
if	O
(	O
endtime	struct
.	O
tv_usec	long
>	O
1000000	int
)	O
{	O
endtime	struct
.	O
tv_usec	long
-=	O
1000000	int
;	O
endtime	struct
.	O
tv_sec	long
++	O
;	O
}	O
nodelay	int
(	O
stdscr	O
,	O
TRUE	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
while	O
(	O
(	O
c	int
=	O
getch	function
(	O
)	O
)	O
==	O
-	O
1	int
)	O
{	O
GET_TIME	O
(	O
timeout	long
)	O
;	O
timeout	long
.	O
tv_usec	long
=	O
endtime	struct
.	O
tv_usec	long
-	O
timeout	long
.	O
tv_usec	long
;	O
if	O
(	O
timeout	long
.	O
tv_usec	long
<	O
0	int
)	O
timeout	long
.	O
tv_sec	long
++	O
;	O
timeout	long
.	O
tv_sec	long
=	O
endtime	struct
.	O
tv_sec	long
-	O
timeout	long
.	O
tv_sec	long
;	O
if	O
(	O
timeout	long
.	O
tv_sec	long
>=	O
0	int
&&	O
timeout	long
.	O
tv_usec	long
>	O
0	int
)	O
{	O
FD_ZERO	O
(	O
&	O
Read_FD_Set	struct
)	O
;	O
FD_SET	O
(	O
input_fd	int
,	O
&	O
Read_FD_Set	struct
)	O
;	O
select	function
(	O
input_fd	int
+	O
1	int
,	O
&	O
Read_FD_Set	struct
,	O
NULL	O
,	O
NULL	O
,	O
&	O
timeout	long
)	O
;	O
}	O
else	O
break	O
;	O
}	O
if	O
(	O
c	int
==	O
-	O
1	int
)	O
break	O
;	O
learn_store_key	function
(	O
buffer	pointer
,	O
&	O
p	pointer
,	O
c	int
)	O
;	O
}	O
keypad	O
(	O
stdscr	O
,	O
TRUE	O
)	O
;	O
nodelay	int
(	O
stdscr	O
,	O
FALSE	O
)	O
;	O
*	O
p	pointer
=	O
0	int
;	O
return	O
g_strdup	function
(	O
buffer	pointer
)	O
;	O
}	O
void	O
numeric_keypad_mode	function
(	O
void	O
)	O
{	O
if	O
(	O
console_flag	char
||	O
xterm_flag	int
)	O
{	O
fputs	function
(	O
"\033>"	pointer
,	O
stdout	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
}	O
}	O
void	O
application_keypad_mode	function
(	O
void	O
)	O
{	O
if	O
(	O
console_flag	char
||	O
xterm_flag	int
)	O
{	O
fputs	function
(	O
"\033="	pointer
,	O
stdout	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
}	O
}	O
int	O
is_idle	function
(	O
void	O
)	O
{	O
int	O
maxfdp	int
;	O
fd_set	struct
select_set	pointer
;	O
struct	O
timeval	struct
timeout	long
;	O
FD_ZERO	O
(	O
&	O
select_set	pointer
)	O
;	O
FD_SET	O
(	O
input_fd	int
,	O
&	O
select_set	pointer
)	O
;	O
maxfdp	int
=	O
input_fd	int
;	O
timeout	long
.	O
tv_sec	long
=	O
0	int
;	O
timeout	long
.	O
tv_usec	long
=	O
0	int
;	O
return	O
(	O
select	function
(	O
maxfdp	int
+	O
1	int
,	O
&	O
select_set	pointer
,	O
0	int
,	O
0	int
,	O
&	O
timeout	long
)	O
<=	O
0	int
)	O
;	O
}	O
static	O
int	O
get_modifier	function
(	O
void	O
)	O
{	O
int	O
result	long
=	O
0	int
;	O
{	O
unsigned	O
char	O
modifiers	char
=	O
6	int
;	O
if	O
(	O
ioctl	function
(	O
0	int
,	O
TIOCLINUX	int
,	O
&	O
modifiers	char
)	O
<	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
modifiers	char
&	O
SHIFT_PRESSED	O
)	O
result	long
|=	O
KEY_M_SHIFT	int
;	O
if	O
(	O
modifiers	char
&	O
(	O
ALTL_PRESSED	O
|	O
ALTR_PRESSED	O
)	O
)	O
result	long
|=	O
KEY_M_ALT	int
;	O
if	O
(	O
modifiers	char
&	O
CONTROL_PRESSED	O
)	O
result	long
|=	O
KEY_M_CTRL	int
;	O
}	O
return	O
result	long
;	O
}	O
static	O
void	O
k_dispose	function
(	O
key_def	struct
*	O
k	pointer
)	O
{	O
if	O
(	O
!	O
k	pointer
)	O
return	O
;	O
k_dispose	function
(	O
k	pointer
->	O
child	pointer
)	O
;	O
k_dispose	function
(	O
k	pointer
->	O
next	pointer
)	O
;	O
g_free	function
(	O
k	pointer
)	O
;	O
}	O
static	O
void	O
s_dispose	function
(	O
SelectList	struct
*	O
sel	int
)	O
{	O
if	O
(	O
!	O
sel	int
)	O
return	O
;	O
s_dispose	function
(	O
sel	int
->	O
next	pointer
)	O
;	O
g_free	function
(	O
sel	int
)	O
;	O
}	O
void	O
done_key	function
(	O
)	O
{	O
k_dispose	function
(	O
keys	pointer
)	O
;	O
s_dispose	function
(	O
select_list	pointer
)	O
;	O
}	O
