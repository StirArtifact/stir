static	O
double	O
C0sq	function
(	O
double	O
eta	double
)	O
{	O
double	O
twopieta	double
=	O
2.0	int
*	O
M_PI	int
*	O
eta	double
;	O
if	O
(	O
fabs	function
(	O
eta	double
)	O
<	O
GSL_DBL_EPSILON	int
)	O
{	O
return	O
1.0	int
;	O
}	O
else	O
if	O
(	O
twopieta	double
>	O
GSL_LOG_DBL_MAX	int
)	O
{	O
return	O
0.0	int
;	O
}	O
else	O
{	O
gsl_sf_result	struct
scale	struct
;	O
gsl_sf_expm1_e	function
(	O
twopieta	double
,	O
&	O
scale	struct
)	O
;	O
return	O
twopieta	double
/	O
scale	struct
.	O
val	double
;	O
}	O
}	O
static	O
int	O
CLeta	function
(	O
double	O
L	double
,	O
double	O
eta	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
gsl_sf_result	struct
ln1	struct
;	O
gsl_sf_result	struct
ln2	struct
;	O
double	O
sgn	pointer
=	O
1.0	int
;	O
double	O
arg_val	double
,	O
arg_err	double
;	O
if	O
(	O
fabs	function
(	O
eta	double
/	O
(	O
L	double
+	O
1.0	int
)	O
)	O
<	O
GSL_DBL_EPSILON	int
)	O
{	O
gsl_sf_lngamma_e	function
(	O
L	double
+	O
1.0	int
,	O
&	O
ln1	struct
)	O
;	O
}	O
else	O
{	O
gsl_sf_result	struct
p1	struct
;	O
gsl_sf_lngamma_complex_e	function
(	O
L	double
+	O
1.0	int
,	O
eta	double
,	O
&	O
ln1	struct
,	O
&	O
p1	struct
)	O
;	O
}	O
gsl_sf_lngamma_e	function
(	O
2.0	int
*	O
(	O
L	double
+	O
1.0	int
)	O
,	O
&	O
ln2	struct
)	O
;	O
if	O
(	O
L	double
<	O
-	O
1.0	int
)	O
sgn	pointer
=	O
-	O
sgn	pointer
;	O
arg_val	double
=	O
L	double
*	O
M_LN2	int
-	O
0.5	int
*	O
eta	double
*	O
M_PI	int
+	O
ln1	struct
.	O
val	double
-	O
ln2	struct
.	O
val	double
;	O
arg_err	double
=	O
ln1	struct
.	O
err	double
+	O
ln2	struct
.	O
err	double
;	O
arg_err	double
+=	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	function
(	O
L	double
*	O
M_LN2	int
)	O
+	O
fabs	function
(	O
0.5	int
*	O
eta	double
*	O
M_PI	int
)	O
)	O
;	O
return	O
gsl_sf_exp_err_e	function
(	O
arg_val	double
,	O
arg_err	double
,	O
result	pointer
)	O
;	O
}	O
int	O
gsl_sf_coulomb_CL_e	function
(	O
double	O
lam	double
,	O
double	O
eta	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
if	O
(	O
lam	double
<=	O
-	O
1.0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
fabs	function
(	O
lam	double
)	O
<	O
GSL_DBL_EPSILON	int
)	O
{	O
result	pointer
->	O
val	double
=	O
sqrt	function
(	O
C0sq	function
(	O
eta	double
)	O
)	O
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
result	pointer
->	O
val	double
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
return	O
CLeta	function
(	O
lam	double
,	O
eta	double
,	O
result	pointer
)	O
;	O
}	O
}	O
int	O
gsl_sf_coulomb_CL_array	function
(	O
double	O
lam_min	double
,	O
int	O
kmax	int
,	O
double	O
eta	double
,	O
double	O
*	O
cl	pointer
)	O
{	O
int	O
k	int
;	O
gsl_sf_result	struct
cl_0	struct
;	O
gsl_sf_coulomb_CL_e	function
(	O
lam_min	double
,	O
eta	double
,	O
&	O
cl_0	struct
)	O
;	O
cl	pointer
[	O
0	int
]	O
=	O
cl_0	struct
.	O
val	double
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<=	O
kmax	int
;	O
k	int
++	O
)	O
{	O
double	O
L	double
=	O
lam_min	double
+	O
k	int
;	O
cl	pointer
[	O
k	int
]	O
=	O
cl	pointer
[	O
k	int
-	O
1	int
]	O
*	O
hypot	function
(	O
L	double
,	O
eta	double
)	O
/	O
(	O
L	double
*	O
(	O
2.0	int
*	O
L	double
+	O
1.0	int
)	O
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
coulomb_connection	function
(	O
const	O
double	O
lam	double
,	O
const	O
double	O
eta	double
,	O
double	O
*	O
cos_phi	pointer
,	O
double	O
*	O
sin_phi	pointer
)	O
{	O
if	O
(	O
eta	double
>	O
-	O
GSL_LOG_DBL_MIN	O
/	O
2.0	int
*	O
M_PI	int
-	O
1.0	int
)	O
{	O
*	O
cos_phi	pointer
=	O
1.0	int
;	O
*	O
sin_phi	pointer
=	O
0.0	int
;	O
GSL_ERROR	O
(	O
"error"	pointer
,	O
GSL_EUNDRFLW	int
)	O
;	O
}	O
else	O
if	O
(	O
eta	double
>	O
-	O
GSL_LOG_DBL_EPSILON	O
/	O
(	O
4.0	int
*	O
M_PI	int
)	O
)	O
{	O
const	O
double	O
eps	double
=	O
2.0	int
*	O
exp	function
(	O
-	O
2.0	int
*	O
M_PI	int
*	O
eta	double
)	O
;	O
const	O
double	O
tpl	double
=	O
tan	function
(	O
M_PI	int
*	O
lam	double
)	O
;	O
const	O
double	O
dth	double
=	O
eps	double
*	O
tpl	double
/	O
(	O
tpl	double
*	O
tpl	double
+	O
1.0	int
)	O
;	O
*	O
cos_phi	pointer
=	O
-	O
1.0	int
+	O
0.5	int
*	O
dth	double
*	O
dth	double
;	O
*	O
sin_phi	pointer
=	O
-	O
dth	double
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
double	O
X	double
=	O
tanh	function
(	O
M_PI	int
*	O
eta	double
)	O
/	O
tan	function
(	O
M_PI	int
*	O
lam	double
)	O
;	O
double	O
phi	double
=	O
-	O
atan	function
(	O
X	double
)	O
-	O
(	O
lam	double
+	O
0.5	int
)	O
*	O
M_PI	int
;	O
*	O
cos_phi	pointer
=	O
cos	function
(	O
phi	double
)	O
;	O
*	O
sin_phi	pointer
=	O
sin	function
(	O
phi	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
static	O
int	O
coulomb_FG_series	function
(	O
const	O
double	O
lam	double
,	O
const	O
double	O
eta	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
F	pointer
,	O
gsl_sf_result	struct
*	O
G	pointer
)	O
{	O
const	O
int	O
max_iter	int
=	O
800	int
;	O
gsl_sf_result	struct
ClamA	struct
;	O
gsl_sf_result	struct
ClamB	struct
;	O
int	O
stat_A	int
=	O
CLeta	function
(	O
lam	double
,	O
eta	double
,	O
&	O
ClamA	struct
)	O
;	O
int	O
stat_B	int
=	O
CLeta	function
(	O
-	O
lam	double
-	O
1.0	int
,	O
eta	double
,	O
&	O
ClamB	struct
)	O
;	O
const	O
double	O
tlp1	double
=	O
2.0	int
*	O
lam	double
+	O
1.0	int
;	O
const	O
double	O
pow_x	double
=	O
pow	function
(	O
x	double
,	O
lam	double
)	O
;	O
double	O
cos_phi_lam	double
;	O
double	O
sin_phi_lam	double
;	O
double	O
uA_mm2	double
=	O
1.0	int
;	O
double	O
uA_mm1	double
=	O
x	double
*	O
eta	double
/	O
(	O
lam	double
+	O
1.0	int
)	O
;	O
double	O
uA_m	double
;	O
double	O
uB_mm2	double
=	O
1.0	int
;	O
double	O
uB_mm1	double
=	O
-	O
x	double
*	O
eta	double
/	O
lam	double
;	O
double	O
uB_m	double
;	O
double	O
A_sum	double
=	O
uA_mm2	double
+	O
uA_mm1	double
;	O
double	O
B_sum	double
=	O
uB_mm2	double
+	O
uB_mm1	double
;	O
double	O
A_abs_del_prev	double
=	O
fabs	function
(	O
A_sum	double
)	O
;	O
double	O
B_abs_del_prev	double
=	O
fabs	function
(	O
B_sum	double
)	O
;	O
gsl_sf_result	struct
FA	struct
,	O
FB	struct
;	O
int	O
m	int
=	O
2	int
;	O
int	O
stat_conn	int
=	O
coulomb_connection	function
(	O
lam	double
,	O
eta	double
,	O
&	O
cos_phi_lam	double
,	O
&	O
sin_phi_lam	double
)	O
;	O
if	O
(	O
stat_conn	int
==	O
GSL_EUNDRFLW	int
)	O
{	O
F	pointer
->	O
val	double
=	O
0.0	int
;	O
F	pointer
->	O
err	double
=	O
0.0	int
;	O
OVERFLOW_ERROR	O
(	O
G	pointer
)	O
;	O
}	O
while	O
(	O
m	int
<	O
max_iter	int
)	O
{	O
double	O
abs_dA	double
;	O
double	O
abs_dB	double
;	O
uA_m	double
=	O
x	double
*	O
(	O
2.0	int
*	O
eta	double
*	O
uA_mm1	double
-	O
x	double
*	O
uA_mm2	double
)	O
/	O
(	O
m	int
*	O
(	O
m	int
+	O
tlp1	double
)	O
)	O
;	O
uB_m	double
=	O
x	double
*	O
(	O
2.0	int
*	O
eta	double
*	O
uB_mm1	double
-	O
x	double
*	O
uB_mm2	double
)	O
/	O
(	O
m	int
*	O
(	O
m	int
-	O
tlp1	double
)	O
)	O
;	O
A_sum	double
+=	O
uA_m	double
;	O
B_sum	double
+=	O
uB_m	double
;	O
abs_dA	double
=	O
fabs	function
(	O
uA_m	double
)	O
;	O
abs_dB	double
=	O
fabs	function
(	O
uB_m	double
)	O
;	O
if	O
(	O
m	int
>	O
15	int
)	O
{	O
double	O
max_abs_dA	double
=	O
GSL_MAX	O
(	O
abs_dA	double
,	O
A_abs_del_prev	double
)	O
;	O
double	O
max_abs_dB	double
=	O
GSL_MAX	O
(	O
abs_dB	double
,	O
B_abs_del_prev	double
)	O
;	O
double	O
abs_A	double
=	O
fabs	function
(	O
A_sum	double
)	O
;	O
double	O
abs_B	double
=	O
fabs	function
(	O
B_sum	double
)	O
;	O
if	O
(	O
max_abs_dA	double
/	O
(	O
max_abs_dA	double
+	O
abs_A	double
)	O
<	O
4.0	int
*	O
GSL_DBL_EPSILON	int
&&	O
max_abs_dB	double
/	O
(	O
max_abs_dB	double
+	O
abs_B	double
)	O
<	O
4.0	int
*	O
GSL_DBL_EPSILON	int
)	O
break	O
;	O
}	O
A_abs_del_prev	double
=	O
abs_dA	double
;	O
B_abs_del_prev	double
=	O
abs_dB	double
;	O
uA_mm2	double
=	O
uA_mm1	double
;	O
uA_mm1	double
=	O
uA_m	double
;	O
uB_mm2	double
=	O
uB_mm1	double
;	O
uB_mm1	double
=	O
uB_m	double
;	O
m	int
++	O
;	O
}	O
FA	struct
.	O
val	double
=	O
A_sum	double
*	O
ClamA	struct
.	O
val	double
*	O
pow_x	double
*	O
x	double
;	O
FA	struct
.	O
err	double
=	O
fabs	function
(	O
A_sum	double
)	O
*	O
ClamA	struct
.	O
err	double
*	O
pow_x	double
*	O
x	double
+	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
FA	struct
.	O
val	double
)	O
;	O
FB	struct
.	O
val	double
=	O
B_sum	double
*	O
ClamB	struct
.	O
val	double
/	O
pow_x	double
;	O
FB	struct
.	O
err	double
=	O
fabs	function
(	O
B_sum	double
)	O
*	O
ClamB	struct
.	O
err	double
/	O
pow_x	double
+	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
FB	struct
.	O
val	double
)	O
;	O
F	pointer
->	O
val	double
=	O
FA	struct
.	O
val	double
;	O
F	pointer
->	O
err	double
=	O
FA	struct
.	O
err	double
;	O
G	pointer
->	O
val	double
=	O
(	O
FA	struct
.	O
val	double
*	O
cos_phi_lam	double
-	O
FB	struct
.	O
val	double
)	O
/	O
sin_phi_lam	double
;	O
G	pointer
->	O
err	double
=	O
(	O
FA	struct
.	O
err	double
*	O
fabs	function
(	O
cos_phi_lam	double
)	O
+	O
FB	struct
.	O
err	double
)	O
/	O
fabs	function
(	O
sin_phi_lam	double
)	O
;	O
if	O
(	O
m	int
>=	O
max_iter	int
)	O
GSL_ERROR	O
(	O
"error"	pointer
,	O
GSL_EMAXITER	int
)	O
;	O
else	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_A	int
,	O
stat_B	int
)	O
;	O
}	O
static	O
int	O
coulomb_FG0_series	function
(	O
const	O
double	O
eta	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
F	pointer
,	O
gsl_sf_result	struct
*	O
G	pointer
)	O
{	O
const	O
int	O
max_iter	int
=	O
800	int
;	O
const	O
double	O
x2	double
=	O
x	double
*	O
x	double
;	O
const	O
double	O
tex	double
=	O
2.0	int
*	O
eta	double
*	O
x	double
;	O
gsl_sf_result	struct
C0	struct
;	O
int	O
stat_CL	int
=	O
CLeta	function
(	O
0.0	int
,	O
eta	double
,	O
&	O
C0	struct
)	O
;	O
gsl_sf_result	struct
r1pie	struct
;	O
int	O
psi_stat	int
=	O
gsl_sf_psi_1piy_e	function
(	O
eta	double
,	O
&	O
r1pie	struct
)	O
;	O
double	O
u_mm2	double
=	O
0.0	int
;	O
double	O
u_mm1	double
=	O
x	double
;	O
double	O
u_m	double
;	O
double	O
v_mm2	double
=	O
1.0	int
;	O
double	O
v_mm1	double
=	O
tex	double
*	O
(	O
2.0	int
*	O
M_EULER	int
-	O
1.0	int
+	O
r1pie	struct
.	O
val	double
)	O
;	O
double	O
v_m	double
;	O
double	O
u_sum	double
=	O
u_mm2	double
+	O
u_mm1	double
;	O
double	O
v_sum	double
=	O
v_mm2	double
+	O
v_mm1	double
;	O
double	O
u_abs_del_prev	double
=	O
fabs	function
(	O
u_sum	double
)	O
;	O
double	O
v_abs_del_prev	double
=	O
fabs	function
(	O
v_sum	double
)	O
;	O
int	O
m	int
=	O
2	int
;	O
double	O
u_sum_err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
u_sum	double
)	O
;	O
double	O
v_sum_err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
v_sum	double
)	O
;	O
double	O
ln2x	double
=	O
log	function
(	O
2.0	int
*	O
x	double
)	O
;	O
while	O
(	O
m	int
<	O
max_iter	int
)	O
{	O
double	O
abs_du	double
;	O
double	O
abs_dv	double
;	O
double	O
m_mm1	double
=	O
m	int
*	O
(	O
m	int
-	O
1.0	int
)	O
;	O
u_m	double
=	O
(	O
tex	double
*	O
u_mm1	double
-	O
x2	double
*	O
u_mm2	double
)	O
/	O
m_mm1	double
;	O
v_m	double
=	O
(	O
tex	double
*	O
v_mm1	double
-	O
x2	double
*	O
v_mm2	double
-	O
2.0	int
*	O
eta	double
*	O
(	O
2	int
*	O
m	int
-	O
1	int
)	O
*	O
u_m	double
)	O
/	O
m_mm1	double
;	O
u_sum	double
+=	O
u_m	double
;	O
v_sum	double
+=	O
v_m	double
;	O
abs_du	double
=	O
fabs	function
(	O
u_m	double
)	O
;	O
abs_dv	double
=	O
fabs	function
(	O
v_m	double
)	O
;	O
u_sum_err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
abs_du	double
;	O
v_sum_err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
abs_dv	double
;	O
if	O
(	O
m	int
>	O
15	int
)	O
{	O
double	O
max_abs_du	double
=	O
GSL_MAX	O
(	O
abs_du	double
,	O
u_abs_del_prev	double
)	O
;	O
double	O
max_abs_dv	double
=	O
GSL_MAX	O
(	O
abs_dv	double
,	O
v_abs_del_prev	double
)	O
;	O
double	O
abs_u	double
=	O
fabs	function
(	O
u_sum	double
)	O
;	O
double	O
abs_v	double
=	O
fabs	function
(	O
v_sum	double
)	O
;	O
if	O
(	O
max_abs_du	double
/	O
(	O
max_abs_du	double
+	O
abs_u	double
)	O
<	O
40.0	int
*	O
GSL_DBL_EPSILON	int
&&	O
max_abs_dv	double
/	O
(	O
max_abs_dv	double
+	O
abs_v	double
)	O
<	O
40.0	int
*	O
GSL_DBL_EPSILON	int
)	O
break	O
;	O
}	O
u_abs_del_prev	double
=	O
abs_du	double
;	O
v_abs_del_prev	double
=	O
abs_dv	double
;	O
u_mm2	double
=	O
u_mm1	double
;	O
u_mm1	double
=	O
u_m	double
;	O
v_mm2	double
=	O
v_mm1	double
;	O
v_mm1	double
=	O
v_m	double
;	O
m	int
++	O
;	O
}	O
F	pointer
->	O
val	double
=	O
C0	struct
.	O
val	double
*	O
u_sum	double
;	O
F	pointer
->	O
err	double
=	O
C0	struct
.	O
err	double
*	O
fabs	function
(	O
u_sum	double
)	O
;	O
F	pointer
->	O
err	double
+=	O
fabs	function
(	O
C0	struct
.	O
val	double
)	O
*	O
u_sum_err	double
;	O
F	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
F	pointer
->	O
val	double
)	O
;	O
G	pointer
->	O
val	double
=	O
(	O
v_sum	double
+	O
2.0	int
*	O
eta	double
*	O
u_sum	double
*	O
ln2x	double
)	O
/	O
C0	struct
.	O
val	double
;	O
G	pointer
->	O
err	double
=	O
(	O
fabs	function
(	O
v_sum	double
)	O
+	O
fabs	function
(	O
2.0	int
*	O
eta	double
*	O
u_sum	double
*	O
ln2x	double
)	O
)	O
/	O
fabs	function
(	O
C0	struct
.	O
val	double
)	O
*	O
fabs	function
(	O
C0	struct
.	O
err	double
/	O
C0	struct
.	O
val	double
)	O
;	O
G	pointer
->	O
err	double
+=	O
(	O
v_sum_err	double
+	O
fabs	function
(	O
2.0	int
*	O
eta	double
*	O
u_sum_err	double
*	O
ln2x	double
)	O
)	O
/	O
fabs	function
(	O
C0	struct
.	O
val	double
)	O
;	O
G	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
G	pointer
->	O
val	double
)	O
;	O
if	O
(	O
m	int
==	O
max_iter	int
)	O
GSL_ERROR	O
(	O
"error"	pointer
,	O
GSL_EMAXITER	int
)	O
;	O
else	O
return	O
GSL_ERROR_SELECT_2	O
(	O
psi_stat	int
,	O
stat_CL	int
)	O
;	O
}	O
static	O
int	O
coulomb_FGmhalf_series	function
(	O
const	O
double	O
eta	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
F	pointer
,	O
gsl_sf_result	struct
*	O
G	pointer
)	O
{	O
const	O
int	O
max_iter	int
=	O
800	int
;	O
const	O
double	O
rx	double
=	O
sqrt	function
(	O
x	double
)	O
;	O
const	O
double	O
x2	double
=	O
x	double
*	O
x	double
;	O
const	O
double	O
tex	double
=	O
2.0	int
*	O
eta	double
*	O
x	double
;	O
gsl_sf_result	struct
Cmhalf	struct
;	O
int	O
stat_CL	int
=	O
CLeta	function
(	O
-	O
0.5	int
,	O
eta	double
,	O
&	O
Cmhalf	struct
)	O
;	O
double	O
u_mm2	double
=	O
1.0	int
;	O
double	O
u_mm1	double
=	O
tex	double
*	O
u_mm2	double
;	O
double	O
u_m	double
;	O
double	O
v_mm2	double
,	O
v_mm1	double
,	O
v_m	double
;	O
double	O
f_sum	double
,	O
g_sum	double
;	O
double	O
tmp1	double
;	O
gsl_sf_result	struct
rpsi_1pe	struct
;	O
gsl_sf_result	struct
rpsi_1p2e	struct
;	O
int	O
m	int
=	O
2	int
;	O
gsl_sf_psi_1piy_e	function
(	O
eta	double
,	O
&	O
rpsi_1pe	struct
)	O
;	O
gsl_sf_psi_1piy_e	function
(	O
2.0	int
*	O
eta	double
,	O
&	O
rpsi_1p2e	struct
)	O
;	O
v_mm2	double
=	O
2.0	int
*	O
M_EULER	int
-	O
M_LN2	int
-	O
rpsi_1pe	struct
.	O
val	double
+	O
2.0	int
*	O
rpsi_1p2e	struct
.	O
val	double
;	O
v_mm1	double
=	O
tex	double
*	O
(	O
v_mm2	double
-	O
2.0	int
*	O
u_mm2	double
)	O
;	O
f_sum	double
=	O
u_mm2	double
+	O
u_mm1	double
;	O
g_sum	double
=	O
v_mm2	double
+	O
v_mm1	double
;	O
while	O
(	O
m	int
<	O
max_iter	int
)	O
{	O
double	O
m2	double
=	O
m	int
*	O
m	int
;	O
u_m	double
=	O
(	O
tex	double
*	O
u_mm1	double
-	O
x2	double
*	O
u_mm2	double
)	O
/	O
m2	double
;	O
v_m	double
=	O
(	O
tex	double
*	O
v_mm1	double
-	O
x2	double
*	O
v_mm2	double
-	O
2.0	int
*	O
m	int
*	O
u_m	double
)	O
/	O
m2	double
;	O
f_sum	double
+=	O
u_m	double
;	O
g_sum	double
+=	O
v_m	double
;	O
if	O
(	O
f_sum	double
!=	O
0.0	int
&&	O
g_sum	double
!=	O
0.0	int
&&	O
(	O
fabs	function
(	O
u_m	double
/	O
f_sum	double
)	O
+	O
fabs	function
(	O
v_m	double
/	O
g_sum	double
)	O
<	O
10.0	int
*	O
GSL_DBL_EPSILON	int
)	O
)	O
break	O
;	O
u_mm2	double
=	O
u_mm1	double
;	O
u_mm1	double
=	O
u_m	double
;	O
v_mm2	double
=	O
v_mm1	double
;	O
v_mm1	double
=	O
v_m	double
;	O
m	int
++	O
;	O
}	O
F	pointer
->	O
val	double
=	O
Cmhalf	struct
.	O
val	double
*	O
rx	double
*	O
f_sum	double
;	O
F	pointer
->	O
err	double
=	O
Cmhalf	struct
.	O
err	double
*	O
fabs	function
(	O
rx	double
*	O
f_sum	double
)	O
+	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
F	pointer
->	O
val	double
)	O
;	O
tmp1	double
=	O
f_sum	double
*	O
log	function
(	O
x	double
)	O
;	O
G	pointer
->	O
val	double
=	O
-	O
rx	double
*	O
(	O
tmp1	double
+	O
g_sum	double
)	O
/	O
Cmhalf	struct
.	O
val	double
;	O
G	pointer
->	O
err	double
=	O
fabs	function
(	O
rx	double
)	O
*	O
(	O
fabs	function
(	O
tmp1	double
)	O
+	O
fabs	function
(	O
g_sum	double
)	O
)	O
/	O
fabs	function
(	O
Cmhalf	struct
.	O
val	double
)	O
*	O
fabs	function
(	O
Cmhalf	struct
.	O
err	double
/	O
Cmhalf	struct
.	O
val	double
)	O
;	O
if	O
(	O
m	int
==	O
max_iter	int
)	O
GSL_ERROR	O
(	O
"error"	pointer
,	O
GSL_EMAXITER	int
)	O
;	O
else	O
return	O
stat_CL	int
;	O
}	O
static	O
int	O
coulomb_F_recur	function
(	O
double	O
lam_min	double
,	O
int	O
kmax	int
,	O
double	O
eta	double
,	O
double	O
x	double
,	O
double	O
F_lam_max	double
,	O
double	O
Fp_lam_max	double
,	O
double	O
*	O
F_lam_min	pointer
,	O
double	O
*	O
Fp_lam_min	pointer
)	O
{	O
double	O
x_inv	double
=	O
1.0	int
/	O
x	double
;	O
double	O
fcl	double
=	O
F_lam_max	double
;	O
double	O
fpl	double
=	O
Fp_lam_max	double
;	O
double	O
lam_max	double
=	O
lam_min	double
+	O
kmax	int
;	O
double	O
lam	double
=	O
lam_max	double
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
kmax	int
-	O
1	int
;	O
k	int
>=	O
0	int
;	O
k	int
--	O
)	O
{	O
double	O
el	double
=	O
eta	double
/	O
lam	double
;	O
double	O
rl	double
=	O
hypot	function
(	O
1.0	int
,	O
el	double
)	O
;	O
double	O
sl	double
=	O
el	double
+	O
lam	double
*	O
x_inv	double
;	O
double	O
fc_lm1	double
;	O
fc_lm1	double
=	O
(	O
fcl	double
*	O
sl	double
+	O
fpl	double
)	O
/	O
rl	double
;	O
fpl	double
=	O
fc_lm1	double
*	O
sl	double
-	O
fcl	double
*	O
rl	double
;	O
fcl	double
=	O
fc_lm1	double
;	O
lam	double
-=	O
1.0	int
;	O
}	O
*	O
F_lam_min	pointer
=	O
fcl	double
;	O
*	O
Fp_lam_min	pointer
=	O
fpl	double
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
coulomb_G_recur	function
(	O
const	O
double	O
lam_min	double
,	O
const	O
int	O
kmax	int
,	O
const	O
double	O
eta	double
,	O
const	O
double	O
x	double
,	O
const	O
double	O
G_lam_min	double
,	O
const	O
double	O
Gp_lam_min	double
,	O
double	O
*	O
G_lam_max	pointer
,	O
double	O
*	O
Gp_lam_max	pointer
)	O
{	O
double	O
x_inv	double
=	O
1.0	int
/	O
x	double
;	O
double	O
gcl	double
=	O
G_lam_min	double
;	O
double	O
gpl	double
=	O
Gp_lam_min	double
;	O
double	O
lam	double
=	O
lam_min	double
+	O
1.0	int
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<=	O
kmax	int
;	O
k	int
++	O
)	O
{	O
double	O
el	double
=	O
eta	double
/	O
lam	double
;	O
double	O
rl	double
=	O
hypot	function
(	O
1.0	int
,	O
el	double
)	O
;	O
double	O
sl	double
=	O
el	double
+	O
lam	double
*	O
x_inv	double
;	O
double	O
gcl1	double
=	O
(	O
sl	double
*	O
gcl	double
-	O
gpl	double
)	O
/	O
rl	double
;	O
gpl	double
=	O
rl	double
*	O
gcl	double
-	O
sl	double
*	O
gcl1	double
;	O
gcl	double
=	O
gcl1	double
;	O
lam	double
+=	O
1.0	int
;	O
}	O
*	O
G_lam_max	pointer
=	O
gcl	double
;	O
*	O
Gp_lam_max	pointer
=	O
gpl	double
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
coulomb_CF1	function
(	O
double	O
lambda	double
,	O
double	O
eta	double
,	O
double	O
x	double
,	O
double	O
*	O
fcl_sign	pointer
,	O
double	O
*	O
result	pointer
,	O
int	O
*	O
count	pointer
)	O
{	O
const	O
double	O
CF1_small	double
=	O
1.e-30	int
;	O
const	O
double	O
CF1_abort	double
=	O
1.0e+05	int
;	O
const	O
double	O
CF1_acc	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
;	O
const	O
double	O
x_inv	double
=	O
1.0	int
/	O
x	double
;	O
const	O
double	O
px	double
=	O
lambda	double
+	O
1.0	int
+	O
CF1_abort	double
;	O
double	O
pk	double
=	O
lambda	double
+	O
1.0	int
;	O
double	O
F	pointer
=	O
eta	double
/	O
pk	double
+	O
pk	double
*	O
x_inv	double
;	O
double	O
D	double
,	O
C	double
;	O
double	O
df	pointer
;	O
*	O
fcl_sign	pointer
=	O
1.0	int
;	O
*	O
count	pointer
=	O
0	int
;	O
if	O
(	O
fabs	function
(	O
F	pointer
)	O
<	O
CF1_small	double
)	O
F	pointer
=	O
CF1_small	double
;	O
D	double
=	O
0.0	int
;	O
C	double
=	O
F	pointer
;	O
do	O
{	O
double	O
pk1	double
=	O
pk	double
+	O
1.0	int
;	O
double	O
ek	double
=	O
eta	double
/	O
pk	double
;	O
double	O
rk2	double
=	O
1.0	int
+	O
ek	double
*	O
ek	double
;	O
double	O
tk	double
=	O
(	O
pk	double
+	O
pk1	double
)	O
*	O
(	O
x_inv	double
+	O
ek	double
/	O
pk1	double
)	O
;	O
D	double
=	O
tk	double
-	O
rk2	double
*	O
D	double
;	O
C	double
=	O
tk	double
-	O
rk2	double
/	O
C	double
;	O
if	O
(	O
fabs	function
(	O
C	double
)	O
<	O
CF1_small	double
)	O
C	double
=	O
CF1_small	double
;	O
if	O
(	O
fabs	function
(	O
D	double
)	O
<	O
CF1_small	double
)	O
D	double
=	O
CF1_small	double
;	O
D	double
=	O
1.0	int
/	O
D	double
;	O
df	pointer
=	O
D	double
*	O
C	double
;	O
F	pointer
=	O
F	pointer
*	O
df	pointer
;	O
if	O
(	O
D	double
<	O
0.0	int
)	O
{	O
*	O
fcl_sign	pointer
=	O
-	O
*	O
fcl_sign	pointer
;	O
}	O
pk	double
=	O
pk1	double
;	O
if	O
(	O
pk	double
>	O
px	double
)	O
{	O
*	O
result	pointer
=	O
F	pointer
;	O
GSL_ERROR	O
(	O
"error"	pointer
,	O
GSL_ERUNAWAY	int
)	O
;	O
}	O
++	O
(	O
*	O
count	pointer
)	O
;	O
}	O
while	O
(	O
fabs	function
(	O
df	pointer
-	O
1.0	int
)	O
>	O
CF1_acc	double
)	O
;	O
*	O
result	pointer
=	O
F	pointer
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
coulomb_CF2	function
(	O
const	O
double	O
lambda	double
,	O
const	O
double	O
eta	double
,	O
const	O
double	O
x	double
,	O
double	O
*	O
result_P	pointer
,	O
double	O
*	O
result_Q	pointer
,	O
int	O
*	O
count	pointer
)	O
{	O
int	O
status	int
=	O
GSL_SUCCESS	int
;	O
const	O
double	O
CF2_acc	double
=	O
4.0	int
*	O
GSL_DBL_EPSILON	int
;	O
const	O
double	O
CF2_abort	double
=	O
2.0e+05	int
;	O
const	O
double	O
wi	double
=	O
2.0	int
*	O
eta	double
;	O
const	O
double	O
x_inv	double
=	O
1.0	int
/	O
x	double
;	O
const	O
double	O
e2mm1	double
=	O
eta	double
*	O
eta	double
+	O
lambda	double
*	O
(	O
lambda	double
+	O
1.0	int
)	O
;	O
double	O
ar	double
=	O
-	O
e2mm1	double
;	O
double	O
ai	double
=	O
eta	double
;	O
double	O
br	double
=	O
2.0	int
*	O
(	O
x	double
-	O
eta	double
)	O
;	O
double	O
bi	double
=	O
2.0	int
;	O
double	O
dr	double
=	O
br	double
/	O
(	O
br	double
*	O
br	double
+	O
bi	double
*	O
bi	double
)	O
;	O
double	O
di	double
=	O
-	O
bi	double
/	O
(	O
br	double
*	O
br	double
+	O
bi	double
*	O
bi	double
)	O
;	O
double	O
dp	double
=	O
-	O
x_inv	double
*	O
(	O
ar	double
*	O
di	double
+	O
ai	double
*	O
dr	double
)	O
;	O
double	O
dq	double
=	O
x_inv	double
*	O
(	O
ar	double
*	O
dr	double
-	O
ai	double
*	O
di	double
)	O
;	O
double	O
A	double
,	O
B	double
,	O
C	double
,	O
D	double
;	O
double	O
pk	double
=	O
0.0	int
;	O
double	O
P	double
=	O
0.0	int
;	O
double	O
Q	double
=	O
1.0	int
-	O
eta	double
*	O
x_inv	double
;	O
*	O
count	pointer
=	O
0	int
;	O
do	O
{	O
P	double
+=	O
dp	double
;	O
Q	double
+=	O
dq	double
;	O
pk	double
+=	O
2.0	int
;	O
ar	double
+=	O
pk	double
;	O
ai	double
+=	O
wi	double
;	O
bi	double
+=	O
2.0	int
;	O
D	double
=	O
ar	double
*	O
dr	double
-	O
ai	double
*	O
di	double
+	O
br	double
;	O
di	double
=	O
ai	double
*	O
dr	double
+	O
ar	double
*	O
di	double
+	O
bi	double
;	O
C	double
=	O
1.0	int
/	O
(	O
D	double
*	O
D	double
+	O
di	double
*	O
di	double
)	O
;	O
dr	double
=	O
C	double
*	O
D	double
;	O
di	double
=	O
-	O
C	double
*	O
di	double
;	O
A	double
=	O
br	double
*	O
dr	double
-	O
bi	double
*	O
di	double
-	O
1.	int
;	O
B	double
=	O
bi	double
*	O
dr	double
+	O
br	double
*	O
di	double
;	O
C	double
=	O
dp	double
*	O
A	double
-	O
dq	double
*	O
B	double
;	O
dq	double
=	O
dp	double
*	O
B	double
+	O
dq	double
*	O
A	double
;	O
dp	double
=	O
C	double
;	O
if	O
(	O
pk	double
>	O
CF2_abort	double
)	O
{	O
status	int
=	O
GSL_ERUNAWAY	int
;	O
break	O
;	O
}	O
++	O
(	O
*	O
count	pointer
)	O
;	O
}	O
while	O
(	O
fabs	function
(	O
dp	double
)	O
+	O
fabs	function
(	O
dq	double
)	O
>	O
(	O
fabs	function
(	O
P	double
)	O
+	O
fabs	function
(	O
Q	double
)	O
)	O
*	O
CF2_acc	double
)	O
;	O
if	O
(	O
Q	double
<	O
CF2_abort	double
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
P	double
)	O
)	O
{	O
status	int
=	O
GSL_ELOSS	int
;	O
}	O
*	O
result_P	pointer
=	O
P	double
;	O
*	O
result_Q	pointer
=	O
Q	double
;	O
return	O
status	int
;	O
}	O
static	O
int	O
coulomb_jwkb	function
(	O
const	O
double	O
lam	double
,	O
const	O
double	O
eta	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
fjwkb	pointer
,	O
gsl_sf_result	struct
*	O
gjwkb	pointer
,	O
double	O
*	O
exponent	pointer
)	O
{	O
const	O
double	O
llp1	double
=	O
lam	double
*	O
(	O
lam	double
+	O
1.0	int
)	O
+	O
6.0	int
/	O
35.0	int
;	O
const	O
double	O
llp1_eff	double
=	O
GSL_MAX	O
(	O
llp1	double
,	O
0.0	int
)	O
;	O
const	O
double	O
rho_ghalf	double
=	O
sqrt	function
(	O
x	double
*	O
(	O
2.0	int
*	O
eta	double
-	O
x	double
)	O
+	O
llp1_eff	double
)	O
;	O
const	O
double	O
sinh_arg	double
=	O
sqrt	function
(	O
llp1_eff	double
/	O
(	O
eta	double
*	O
eta	double
+	O
llp1_eff	double
)	O
)	O
*	O
rho_ghalf	double
/	O
x	double
;	O
const	O
double	O
sinh_inv	double
=	O
log	function
(	O
sinh_arg	double
+	O
hypot	function
(	O
1.0	int
,	O
sinh_arg	double
)	O
)	O
;	O
const	O
double	O
phi	double
=	O
fabs	function
(	O
rho_ghalf	double
-	O
eta	double
*	O
atan2	function
(	O
rho_ghalf	double
,	O
x	double
-	O
eta	double
)	O
-	O
sqrt	function
(	O
llp1_eff	double
)	O
*	O
sinh_inv	double
)	O
;	O
const	O
double	O
zeta_half	double
=	O
pow	function
(	O
3.0	int
*	O
phi	double
/	O
2.0	int
,	O
1.0	int
/	O
3.0	int
)	O
;	O
const	O
double	O
prefactor	double
=	O
sqrt	function
(	O
M_PI	int
*	O
phi	double
*	O
x	double
/	O
(	O
6.0	int
*	O
rho_ghalf	double
)	O
)	O
;	O
double	O
F	pointer
=	O
prefactor	double
*	O
3.0	int
/	O
zeta_half	double
;	O
double	O
G	pointer
=	O
prefactor	double
*	O
3.0	int
/	O
zeta_half	double
;	O
double	O
F_exp	double
;	O
double	O
G_exp	double
;	O
const	O
double	O
airy_scale_exp	double
=	O
phi	double
;	O
gsl_sf_result	struct
ai	double
;	O
gsl_sf_result	struct
bi	double
;	O
gsl_sf_airy_Ai_scaled_e	function
(	O
zeta_half	double
*	O
zeta_half	double
,	O
GSL_MODE_DEFAULT	int
,	O
&	O
ai	double
)	O
;	O
gsl_sf_airy_Bi_scaled_e	function
(	O
zeta_half	double
*	O
zeta_half	double
,	O
GSL_MODE_DEFAULT	int
,	O
&	O
bi	double
)	O
;	O
F	pointer
*=	O
ai	double
.	O
val	double
;	O
G	pointer
*=	O
bi	double
.	O
val	double
;	O
F_exp	double
=	O
log	function
(	O
F	pointer
)	O
-	O
airy_scale_exp	double
;	O
G_exp	double
=	O
log	function
(	O
G	pointer
)	O
+	O
airy_scale_exp	double
;	O
if	O
(	O
G_exp	double
>=	O
GSL_LOG_DBL_MAX	int
)	O
{	O
fjwkb	pointer
->	O
val	double
=	O
F	pointer
;	O
gjwkb	pointer
->	O
val	double
=	O
G	pointer
;	O
fjwkb	pointer
->	O
err	double
=	O
1.0e-3	int
*	O
fabs	function
(	O
F	pointer
)	O
;	O
gjwkb	pointer
->	O
err	double
=	O
1.0e-3	int
*	O
fabs	function
(	O
G	pointer
)	O
;	O
*	O
exponent	pointer
=	O
airy_scale_exp	double
;	O
GSL_ERROR	O
(	O
"error"	pointer
,	O
GSL_EOVRFLW	int
)	O
;	O
}	O
else	O
{	O
fjwkb	pointer
->	O
val	double
=	O
exp	function
(	O
F_exp	double
)	O
;	O
gjwkb	pointer
->	O
val	double
=	O
exp	function
(	O
G_exp	double
)	O
;	O
fjwkb	pointer
->	O
err	double
=	O
1.0e-3	int
*	O
fabs	function
(	O
fjwkb	pointer
->	O
val	double
)	O
;	O
gjwkb	pointer
->	O
err	double
=	O
1.0e-3	int
*	O
fabs	function
(	O
gjwkb	pointer
->	O
val	double
)	O
;	O
*	O
exponent	pointer
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
int	O
gsl_sf_coulomb_wave_FG_e	function
(	O
const	O
double	O
eta	double
,	O
const	O
double	O
x	double
,	O
const	O
double	O
lam_F	double
,	O
const	O
int	O
k_lam_G	int
,	O
gsl_sf_result	struct
*	O
F	pointer
,	O
gsl_sf_result	struct
*	O
Fp	pointer
,	O
gsl_sf_result	struct
*	O
G	pointer
,	O
gsl_sf_result	struct
*	O
Gp	pointer
,	O
double	O
*	O
exp_F	pointer
,	O
double	O
*	O
exp_G	pointer
)	O
{	O
const	O
double	O
lam_G	double
=	O
lam_F	double
-	O
k_lam_G	int
;	O
if	O
(	O
x	double
<	O
0.0	int
||	O
lam_F	double
<=	O
-	O
0.5	int
||	O
lam_G	double
<=	O
-	O
0.5	int
)	O
{	O
GSL_SF_RESULT_SET	O
(	O
F	pointer
,	O
0.0	int
,	O
0.0	int
)	O
;	O
GSL_SF_RESULT_SET	O
(	O
Fp	pointer
,	O
0.0	int
,	O
0.0	int
)	O
;	O
GSL_SF_RESULT_SET	O
(	O
G	pointer
,	O
0.0	int
,	O
0.0	int
)	O
;	O
GSL_SF_RESULT_SET	O
(	O
Gp	pointer
,	O
0.0	int
,	O
0.0	int
)	O
;	O
*	O
exp_F	pointer
=	O
0.0	int
;	O
*	O
exp_G	pointer
=	O
0.0	int
;	O
GSL_ERROR	O
(	O
"domain error"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
else	O
if	O
(	O
x	double
==	O
0.0	int
)	O
{	O
gsl_sf_result	struct
C0	struct
;	O
CLeta	function
(	O
0.0	int
,	O
eta	double
,	O
&	O
C0	struct
)	O
;	O
GSL_SF_RESULT_SET	O
(	O
F	pointer
,	O
0.0	int
,	O
0.0	int
)	O
;	O
GSL_SF_RESULT_SET	O
(	O
Fp	pointer
,	O
0.0	int
,	O
0.0	int
)	O
;	O
GSL_SF_RESULT_SET	O
(	O
G	pointer
,	O
0.0	int
,	O
0.0	int
)	O
;	O
GSL_SF_RESULT_SET	O
(	O
Gp	pointer
,	O
0.0	int
,	O
0.0	int
)	O
;	O
*	O
exp_F	pointer
=	O
0.0	int
;	O
*	O
exp_G	pointer
=	O
0.0	int
;	O
if	O
(	O
lam_F	double
==	O
0.0	int
)	O
{	O
GSL_SF_RESULT_SET	O
(	O
Fp	pointer
,	O
C0	struct
.	O
val	double
,	O
C0	struct
.	O
err	double
)	O
;	O
}	O
if	O
(	O
lam_G	double
==	O
0.0	int
)	O
{	O
GSL_SF_RESULT_SET	O
(	O
Gp	pointer
,	O
1.0	int
/	O
C0	struct
.	O
val	double
,	O
fabs	function
(	O
C0	struct
.	O
err	double
/	O
C0	struct
.	O
val	double
)	O
/	O
fabs	function
(	O
C0	struct
.	O
val	double
)	O
)	O
;	O
}	O
GSL_ERROR	O
(	O
"domain error"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
else	O
if	O
(	O
x	double
<	O
1.2	int
&&	O
2.0	int
*	O
M_PI	int
*	O
eta	double
<	O
0.9	int
*	O
(	O
-	O
GSL_LOG_DBL_MIN	O
)	O
&&	O
fabs	function
(	O
eta	double
*	O
x	double
)	O
<	O
10.0	int
)	O
{	O
const	O
double	O
SMALL	double
=	O
GSL_SQRT_DBL_EPSILON	int
;	O
const	O
int	O
N	int
=	O
(	O
int	O
)	O
(	O
lam_F	double
+	O
0.5	int
)	O
;	O
const	O
int	O
span	int
=	O
GSL_MAX	O
(	O
k_lam_G	int
,	O
N	int
)	O
;	O
const	O
double	O
lam_min	double
=	O
lam_F	double
-	O
N	int
;	O
double	O
F_lam_F	double
,	O
Fp_lam_F	double
;	O
double	O
G_lam_G	double
=	O
0.0	int
,	O
Gp_lam_G	double
=	O
0.0	int
;	O
double	O
F_lam_F_err	double
,	O
Fp_lam_F_err	double
;	O
double	O
Fp_over_F_lam_F	double
;	O
double	O
F_sign_lam_F	double
;	O
double	O
F_lam_min_unnorm	double
,	O
Fp_lam_min_unnorm	double
;	O
double	O
Fp_over_F_lam_min	double
;	O
gsl_sf_result	struct
F_lam_min	pointer
;	O
gsl_sf_result	struct
G_lam_min	double
,	O
Gp_lam_min	double
;	O
double	O
F_scale	double
;	O
double	O
Gerr_frac	double
;	O
double	O
F_scale_frac_err	double
;	O
double	O
F_unnorm_frac_err	double
;	O
int	O
CF1_count	int
;	O
int	O
stat_CF1	int
=	O
coulomb_CF1	function
(	O
lam_F	double
,	O
eta	double
,	O
x	double
,	O
&	O
F_sign_lam_F	double
,	O
&	O
Fp_over_F_lam_F	double
,	O
&	O
CF1_count	int
)	O
;	O
int	O
stat_ser	int
;	O
int	O
stat_Fr	int
;	O
int	O
stat_Gr	int
;	O
F_lam_F	double
=	O
SMALL	double
;	O
Fp_lam_F	double
=	O
Fp_over_F_lam_F	double
*	O
F_lam_F	double
;	O
if	O
(	O
span	int
!=	O
0	int
)	O
{	O
stat_Fr	int
=	O
coulomb_F_recur	function
(	O
lam_min	double
,	O
span	int
,	O
eta	double
,	O
x	double
,	O
F_lam_F	double
,	O
Fp_lam_F	double
,	O
&	O
F_lam_min_unnorm	double
,	O
&	O
Fp_lam_min_unnorm	double
)	O
;	O
}	O
else	O
{	O
F_lam_min_unnorm	double
=	O
F_lam_F	double
;	O
Fp_lam_min_unnorm	double
=	O
Fp_lam_F	double
;	O
stat_Fr	int
=	O
GSL_SUCCESS	int
;	O
}	O
if	O
(	O
lam_min	double
==	O
-	O
0.5	int
)	O
{	O
stat_ser	int
=	O
coulomb_FGmhalf_series	function
(	O
eta	double
,	O
x	double
,	O
&	O
F_lam_min	pointer
,	O
&	O
G_lam_min	double
)	O
;	O
}	O
else	O
if	O
(	O
lam_min	double
==	O
0.0	int
)	O
{	O
stat_ser	int
=	O
coulomb_FG0_series	function
(	O
eta	double
,	O
x	double
,	O
&	O
F_lam_min	pointer
,	O
&	O
G_lam_min	double
)	O
;	O
}	O
else	O
if	O
(	O
lam_min	double
==	O
0.5	int
)	O
{	O
F	pointer
->	O
val	double
=	O
F_lam_F	double
;	O
F	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
F	pointer
->	O
val	double
)	O
;	O
Fp	pointer
->	O
val	double
=	O
Fp_lam_F	double
;	O
Fp	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
Fp	pointer
->	O
val	double
)	O
;	O
G	pointer
->	O
val	double
=	O
G_lam_G	double
;	O
G	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
G	pointer
->	O
val	double
)	O
;	O
Gp	pointer
->	O
val	double
=	O
Gp_lam_G	double
;	O
Gp	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
Gp	pointer
->	O
val	double
)	O
;	O
*	O
exp_F	pointer
=	O
0.0	int
;	O
*	O
exp_G	pointer
=	O
0.0	int
;	O
GSL_ERROR	O
(	O
"error"	pointer
,	O
GSL_ESANITY	int
)	O
;	O
}	O
else	O
{	O
stat_ser	int
=	O
coulomb_FG_series	function
(	O
lam_min	double
,	O
eta	double
,	O
x	double
,	O
&	O
F_lam_min	pointer
,	O
&	O
G_lam_min	double
)	O
;	O
}	O
Fp_over_F_lam_min	double
=	O
Fp_lam_min_unnorm	double
/	O
F_lam_min_unnorm	double
;	O
Gp_lam_min	double
.	O
val	double
=	O
Fp_over_F_lam_min	double
*	O
G_lam_min	double
.	O
val	double
-	O
1.0	int
/	O
F_lam_min	pointer
.	O
val	double
;	O
Gp_lam_min	double
.	O
err	double
=	O
fabs	function
(	O
Fp_over_F_lam_min	double
)	O
*	O
G_lam_min	double
.	O
err	double
;	O
Gp_lam_min	double
.	O
err	double
+=	O
fabs	function
(	O
1.0	int
/	O
F_lam_min	pointer
.	O
val	double
)	O
*	O
fabs	function
(	O
F_lam_min	pointer
.	O
err	double
/	O
F_lam_min	pointer
.	O
val	double
)	O
;	O
F_scale	double
=	O
F_lam_min	pointer
.	O
val	double
/	O
F_lam_min_unnorm	double
;	O
F_scale_frac_err	double
=	O
fabs	function
(	O
F_lam_min	pointer
.	O
err	double
/	O
F_lam_min	pointer
.	O
val	double
)	O
;	O
F_unnorm_frac_err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
CF1_count	int
+	O
span	int
+	O
1	int
)	O
;	O
F_lam_F	double
*=	O
F_scale	double
;	O
F_lam_F_err	double
=	O
fabs	function
(	O
F_lam_F	double
)	O
*	O
(	O
F_unnorm_frac_err	double
+	O
F_scale_frac_err	double
)	O
;	O
Fp_lam_F	double
*=	O
F_scale	double
;	O
Fp_lam_F_err	double
=	O
fabs	function
(	O
Fp_lam_F	double
)	O
*	O
(	O
F_unnorm_frac_err	double
+	O
F_scale_frac_err	double
)	O
;	O
stat_Gr	int
=	O
coulomb_G_recur	function
(	O
lam_min	double
,	O
GSL_MAX	O
(	O
N	int
-	O
k_lam_G	int
,	O
0	int
)	O
,	O
eta	double
,	O
x	double
,	O
G_lam_min	double
.	O
val	double
,	O
Gp_lam_min	double
.	O
val	double
,	O
&	O
G_lam_G	double
,	O
&	O
Gp_lam_G	double
)	O
;	O
F	pointer
->	O
val	double
=	O
F_lam_F	double
;	O
F	pointer
->	O
err	double
=	O
F_lam_F_err	double
;	O
F	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
F_lam_F	double
)	O
;	O
Fp	pointer
->	O
val	double
=	O
Fp_lam_F	double
;	O
Fp	pointer
->	O
err	double
=	O
Fp_lam_F_err	double
;	O
Fp	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
Fp_lam_F	double
)	O
;	O
Gerr_frac	double
=	O
fabs	function
(	O
G_lam_min	double
.	O
err	double
/	O
G_lam_min	double
.	O
val	double
)	O
+	O
fabs	function
(	O
Gp_lam_min	double
.	O
err	double
/	O
Gp_lam_min	double
.	O
val	double
)	O
;	O
G	pointer
->	O
val	double
=	O
G_lam_G	double
;	O
G	pointer
->	O
err	double
=	O
Gerr_frac	double
*	O
fabs	function
(	O
G_lam_G	double
)	O
;	O
G	pointer
->	O
err	double
+=	O
2.0	int
*	O
(	O
CF1_count	int
+	O
1	int
)	O
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
G	pointer
->	O
val	double
)	O
;	O
Gp	pointer
->	O
val	double
=	O
Gp_lam_G	double
;	O
Gp	pointer
->	O
err	double
=	O
Gerr_frac	double
*	O
fabs	function
(	O
Gp	pointer
->	O
val	double
)	O
;	O
Gp	pointer
->	O
err	double
+=	O
2.0	int
*	O
(	O
CF1_count	int
+	O
1	int
)	O
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
Gp	pointer
->	O
val	double
)	O
;	O
*	O
exp_F	pointer
=	O
0.0	int
;	O
*	O
exp_G	pointer
=	O
0.0	int
;	O
return	O
GSL_ERROR_SELECT_4	O
(	O
stat_ser	int
,	O
stat_CF1	int
,	O
stat_Fr	int
,	O
stat_Gr	int
)	O
;	O
}	O
else	O
if	O
(	O
x	double
<	O
2.0	int
*	O
eta	double
)	O
{	O
gsl_sf_result	struct
F_lam_F	double
,	O
G_lam_F	struct
;	O
gsl_sf_result	struct
F_lam_G	struct
,	O
G_lam_G	double
;	O
double	O
exp_lam_F	double
,	O
exp_lam_G	double
;	O
int	O
stat_lam_F	int
;	O
int	O
stat_lam_G	int
;	O
int	O
stat_CF1_lam_F	int
;	O
int	O
stat_CF1_lam_G	int
;	O
int	O
CF1_count	int
;	O
double	O
Fp_over_F_lam_F	double
;	O
double	O
Fp_over_F_lam_G	double
;	O
double	O
F_sign_lam_F	double
;	O
double	O
F_sign_lam_G	double
;	O
stat_lam_F	int
=	O
coulomb_jwkb	function
(	O
lam_F	double
,	O
eta	double
,	O
x	double
,	O
&	O
F_lam_F	double
,	O
&	O
G_lam_F	struct
,	O
&	O
exp_lam_F	double
)	O
;	O
if	O
(	O
k_lam_G	int
==	O
0	int
)	O
{	O
stat_lam_G	int
=	O
stat_lam_F	int
;	O
F_lam_G	struct
=	O
F_lam_F	double
;	O
G_lam_G	double
=	O
G_lam_F	struct
;	O
exp_lam_G	double
=	O
exp_lam_F	double
;	O
}	O
else	O
{	O
stat_lam_G	int
=	O
coulomb_jwkb	function
(	O
lam_G	double
,	O
eta	double
,	O
x	double
,	O
&	O
F_lam_G	struct
,	O
&	O
G_lam_G	double
,	O
&	O
exp_lam_G	double
)	O
;	O
}	O
stat_CF1_lam_F	int
=	O
coulomb_CF1	function
(	O
lam_F	double
,	O
eta	double
,	O
x	double
,	O
&	O
F_sign_lam_F	double
,	O
&	O
Fp_over_F_lam_F	double
,	O
&	O
CF1_count	int
)	O
;	O
if	O
(	O
k_lam_G	int
==	O
0	int
)	O
{	O
stat_CF1_lam_G	int
=	O
stat_CF1_lam_F	int
;	O
F_sign_lam_G	double
=	O
F_sign_lam_F	double
;	O
Fp_over_F_lam_G	double
=	O
Fp_over_F_lam_F	double
;	O
}	O
else	O
{	O
stat_CF1_lam_G	int
=	O
coulomb_CF1	function
(	O
lam_G	double
,	O
eta	double
,	O
x	double
,	O
&	O
F_sign_lam_G	double
,	O
&	O
Fp_over_F_lam_G	double
,	O
&	O
CF1_count	int
)	O
;	O
}	O
F	pointer
->	O
val	double
=	O
F_lam_F	double
.	O
val	double
;	O
F	pointer
->	O
err	double
=	O
F_lam_F	double
.	O
err	double
;	O
G	pointer
->	O
val	double
=	O
G_lam_G	double
.	O
val	double
;	O
G	pointer
->	O
err	double
=	O
G_lam_G	double
.	O
err	double
;	O
Fp	pointer
->	O
val	double
=	O
Fp_over_F_lam_F	double
*	O
F_lam_F	double
.	O
val	double
;	O
Fp	pointer
->	O
err	double
=	O
fabs	function
(	O
Fp_over_F_lam_F	double
)	O
*	O
F_lam_F	double
.	O
err	double
;	O
Fp	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
Fp	pointer
->	O
val	double
)	O
;	O
Gp	pointer
->	O
val	double
=	O
Fp_over_F_lam_G	double
*	O
G_lam_G	double
.	O
val	double
-	O
1.0	int
/	O
F_lam_G	struct
.	O
val	double
;	O
Gp	pointer
->	O
err	double
=	O
fabs	function
(	O
Fp_over_F_lam_G	double
)	O
*	O
G_lam_G	double
.	O
err	double
;	O
Gp	pointer
->	O
err	double
+=	O
fabs	function
(	O
1.0	int
/	O
F_lam_G	struct
.	O
val	double
)	O
*	O
fabs	function
(	O
F_lam_G	struct
.	O
err	double
/	O
F_lam_G	struct
.	O
val	double
)	O
;	O
*	O
exp_F	pointer
=	O
exp_lam_F	double
;	O
*	O
exp_G	pointer
=	O
exp_lam_G	double
;	O
if	O
(	O
stat_lam_F	int
==	O
GSL_EOVRFLW	int
||	O
stat_lam_G	int
==	O
GSL_EOVRFLW	int
)	O
{	O
GSL_ERROR	O
(	O
"overflow"	pointer
,	O
GSL_EOVRFLW	int
)	O
;	O
}	O
else	O
{	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_lam_F	int
,	O
stat_lam_G	int
)	O
;	O
}	O
}	O
else	O
{	O
const	O
double	O
SMALL	double
=	O
GSL_SQRT_DBL_EPSILON	int
;	O
const	O
double	O
C	double
=	O
sqrt	function
(	O
1.0	int
+	O
4.0	int
*	O
x	double
*	O
(	O
x	double
-	O
2.0	int
*	O
eta	double
)	O
)	O
;	O
const	O
int	O
N	int
=	O
ceil	function
(	O
lam_F	double
-	O
C	double
+	O
0.5	int
)	O
;	O
const	O
double	O
lam_0	double
=	O
lam_F	double
-	O
GSL_MAX	O
(	O
N	int
,	O
0	int
)	O
;	O
const	O
double	O
lam_min	double
=	O
GSL_MIN	O
(	O
lam_0	double
,	O
lam_G	double
)	O
;	O
double	O
F_lam_F	double
,	O
Fp_lam_F	double
;	O
double	O
G_lam_G	double
,	O
Gp_lam_G	double
;	O
double	O
F_lam_min_unnorm	double
,	O
Fp_lam_min_unnorm	double
;	O
double	O
F_lam_min	pointer
,	O
Fp_lam_min	pointer
;	O
double	O
G_lam_min	double
,	O
Gp_lam_min	double
;	O
double	O
Fp_over_F_lam_F	double
;	O
double	O
Fp_over_F_lam_min	double
;	O
double	O
F_sign_lam_F	double
,	O
F_sign_lam_min	double
;	O
double	O
P_lam_min	double
,	O
Q_lam_min	double
;	O
double	O
alpha	double
;	O
double	O
gamma	function
;	O
double	O
F_scale	double
;	O
int	O
CF1_count	int
;	O
int	O
CF2_count	int
;	O
int	O
stat_CF1	int
=	O
coulomb_CF1	function
(	O
lam_F	double
,	O
eta	double
,	O
x	double
,	O
&	O
F_sign_lam_F	double
,	O
&	O
Fp_over_F_lam_F	double
,	O
&	O
CF1_count	int
)	O
;	O
int	O
stat_CF2	int
;	O
int	O
stat_Fr	int
;	O
int	O
stat_Gr	int
;	O
int	O
F_recur_count	int
;	O
int	O
G_recur_count	int
;	O
double	O
err_amplify	double
;	O
F_lam_F	double
=	O
F_sign_lam_F	double
*	O
SMALL	double
;	O
Fp_lam_F	double
=	O
Fp_over_F_lam_F	double
*	O
F_lam_F	double
;	O
F_recur_count	int
=	O
GSL_MAX	O
(	O
k_lam_G	int
,	O
N	int
)	O
;	O
stat_Fr	int
=	O
coulomb_F_recur	function
(	O
lam_min	double
,	O
F_recur_count	int
,	O
eta	double
,	O
x	double
,	O
F_lam_F	double
,	O
Fp_lam_F	double
,	O
&	O
F_lam_min_unnorm	double
,	O
&	O
Fp_lam_min_unnorm	double
)	O
;	O
Fp_over_F_lam_min	double
=	O
Fp_lam_min_unnorm	double
/	O
F_lam_min_unnorm	double
;	O
stat_CF2	int
=	O
coulomb_CF2	function
(	O
lam_min	double
,	O
eta	double
,	O
x	double
,	O
&	O
P_lam_min	double
,	O
&	O
Q_lam_min	double
,	O
&	O
CF2_count	int
)	O
;	O
alpha	double
=	O
Fp_over_F_lam_min	double
-	O
P_lam_min	double
;	O
gamma	function
=	O
alpha	double
/	O
Q_lam_min	double
;	O
F_sign_lam_min	double
=	O
GSL_SIGN	O
(	O
F_lam_min_unnorm	double
)	O
;	O
F_lam_min	pointer
=	O
F_sign_lam_min	double
/	O
sqrt	function
(	O
alpha	double
*	O
alpha	double
/	O
Q_lam_min	double
+	O
Q_lam_min	double
)	O
;	O
Fp_lam_min	pointer
=	O
Fp_over_F_lam_min	double
*	O
F_lam_min	pointer
;	O
G_lam_min	double
=	O
gamma	function
*	O
F_lam_min	pointer
;	O
Gp_lam_min	double
=	O
(	O
P_lam_min	double
*	O
gamma	function
-	O
Q_lam_min	double
)	O
*	O
F_lam_min	pointer
;	O
F_scale	double
=	O
F_lam_min	pointer
/	O
F_lam_min_unnorm	double
;	O
F_lam_F	double
*=	O
F_scale	double
;	O
Fp_lam_F	double
*=	O
F_scale	double
;	O
G_recur_count	int
=	O
GSL_MAX	O
(	O
N	int
-	O
k_lam_G	int
,	O
0	int
)	O
;	O
stat_Gr	int
=	O
coulomb_G_recur	function
(	O
lam_min	double
,	O
G_recur_count	int
,	O
eta	double
,	O
x	double
,	O
G_lam_min	double
,	O
Gp_lam_min	double
,	O
&	O
G_lam_G	double
,	O
&	O
Gp_lam_G	double
)	O
;	O
err_amplify	double
=	O
CF1_count	int
+	O
CF2_count	int
+	O
F_recur_count	int
+	O
G_recur_count	int
+	O
1	int
;	O
F	pointer
->	O
val	double
=	O
F_lam_F	double
;	O
F	pointer
->	O
err	double
=	O
8.0	int
*	O
err_amplify	double
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
F	pointer
->	O
val	double
)	O
;	O
Fp	pointer
->	O
val	double
=	O
Fp_lam_F	double
;	O
Fp	pointer
->	O
err	double
=	O
8.0	int
*	O
err_amplify	double
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
Fp	pointer
->	O
val	double
)	O
;	O
G	pointer
->	O
val	double
=	O
G_lam_G	double
;	O
G	pointer
->	O
err	double
=	O
8.0	int
*	O
err_amplify	double
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
G	pointer
->	O
val	double
)	O
;	O
Gp	pointer
->	O
val	double
=	O
Gp_lam_G	double
;	O
Gp	pointer
->	O
err	double
=	O
8.0	int
*	O
err_amplify	double
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
Gp	pointer
->	O
val	double
)	O
;	O
*	O
exp_F	pointer
=	O
0.0	int
;	O
*	O
exp_G	pointer
=	O
0.0	int
;	O
return	O
GSL_ERROR_SELECT_4	O
(	O
stat_CF1	int
,	O
stat_CF2	int
,	O
stat_Fr	int
,	O
stat_Gr	int
)	O
;	O
}	O
}	O
int	O
gsl_sf_coulomb_wave_F_array	function
(	O
double	O
lam_min	double
,	O
int	O
kmax	int
,	O
double	O
eta	double
,	O
double	O
x	double
,	O
double	O
*	O
fc_array	pointer
,	O
double	O
*	O
F_exp	double
)	O
{	O
if	O
(	O
x	double
==	O
0.0	int
)	O
{	O
int	O
k	int
;	O
*	O
F_exp	double
=	O
0.0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<=	O
kmax	int
;	O
k	int
++	O
)	O
{	O
fc_array	pointer
[	O
k	int
]	O
=	O
0.0	int
;	O
}	O
if	O
(	O
lam_min	double
==	O
0.0	int
)	O
{	O
gsl_sf_result	struct
f_0	struct
;	O
CLeta	function
(	O
0.0	int
,	O
eta	double
,	O
&	O
f_0	struct
)	O
;	O
fc_array	pointer
[	O
0	int
]	O
=	O
f_0	struct
.	O
val	double
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
const	O
double	O
x_inv	double
=	O
1.0	int
/	O
x	double
;	O
const	O
double	O
lam_max	double
=	O
lam_min	double
+	O
kmax	int
;	O
gsl_sf_result	struct
F	pointer
,	O
Fp	pointer
;	O
gsl_sf_result	struct
G	pointer
,	O
Gp	pointer
;	O
double	O
G_exp	double
;	O
int	O
stat_FG	int
=	O
gsl_sf_coulomb_wave_FG_e	function
(	O
eta	double
,	O
x	double
,	O
lam_max	double
,	O
0	int
,	O
&	O
F	pointer
,	O
&	O
Fp	pointer
,	O
&	O
G	pointer
,	O
&	O
Gp	pointer
,	O
F_exp	double
,	O
&	O
G_exp	double
)	O
;	O
double	O
fcl	double
=	O
F	pointer
.	O
val	double
;	O
double	O
fpl	double
=	O
Fp	pointer
.	O
val	double
;	O
double	O
lam	double
=	O
lam_max	double
;	O
int	O
k	int
;	O
fc_array	pointer
[	O
kmax	int
]	O
=	O
F	pointer
.	O
val	double
;	O
for	O
(	O
k	int
=	O
kmax	int
-	O
1	int
;	O
k	int
>=	O
0	int
;	O
k	int
--	O
)	O
{	O
double	O
el	double
=	O
eta	double
/	O
lam	double
;	O
double	O
rl	double
=	O
hypot	function
(	O
1.0	int
,	O
el	double
)	O
;	O
double	O
sl	double
=	O
el	double
+	O
lam	double
*	O
x_inv	double
;	O
double	O
fc_lm1	double
=	O
(	O
fcl	double
*	O
sl	double
+	O
fpl	double
)	O
/	O
rl	double
;	O
fc_array	pointer
[	O
k	int
]	O
=	O
fc_lm1	double
;	O
fpl	double
=	O
fc_lm1	double
*	O
sl	double
-	O
fcl	double
*	O
rl	double
;	O
fcl	double
=	O
fc_lm1	double
;	O
lam	double
-=	O
1.0	int
;	O
}	O
return	O
stat_FG	int
;	O
}	O
}	O
int	O
gsl_sf_coulomb_wave_FG_array	function
(	O
double	O
lam_min	double
,	O
int	O
kmax	int
,	O
double	O
eta	double
,	O
double	O
x	double
,	O
double	O
*	O
fc_array	pointer
,	O
double	O
*	O
gc_array	pointer
,	O
double	O
*	O
F_exp	double
,	O
double	O
*	O
G_exp	double
)	O
{	O
const	O
double	O
x_inv	double
=	O
1.0	int
/	O
x	double
;	O
const	O
double	O
lam_max	double
=	O
lam_min	double
+	O
kmax	int
;	O
gsl_sf_result	struct
F	pointer
,	O
Fp	pointer
;	O
gsl_sf_result	struct
G	pointer
,	O
Gp	pointer
;	O
int	O
stat_FG	int
=	O
gsl_sf_coulomb_wave_FG_e	function
(	O
eta	double
,	O
x	double
,	O
lam_max	double
,	O
kmax	int
,	O
&	O
F	pointer
,	O
&	O
Fp	pointer
,	O
&	O
G	pointer
,	O
&	O
Gp	pointer
,	O
F_exp	double
,	O
G_exp	double
)	O
;	O
double	O
fcl	double
=	O
F	pointer
.	O
val	double
;	O
double	O
fpl	double
=	O
Fp	pointer
.	O
val	double
;	O
double	O
lam	double
=	O
lam_max	double
;	O
int	O
k	int
;	O
double	O
gcl	double
,	O
gpl	double
;	O
fc_array	pointer
[	O
kmax	int
]	O
=	O
F	pointer
.	O
val	double
;	O
for	O
(	O
k	int
=	O
kmax	int
-	O
1	int
;	O
k	int
>=	O
0	int
;	O
k	int
--	O
)	O
{	O
double	O
el	double
=	O
eta	double
/	O
lam	double
;	O
double	O
rl	double
=	O
hypot	function
(	O
1.0	int
,	O
el	double
)	O
;	O
double	O
sl	double
=	O
el	double
+	O
lam	double
*	O
x_inv	double
;	O
double	O
fc_lm1	double
;	O
fc_lm1	double
=	O
(	O
fcl	double
*	O
sl	double
+	O
fpl	double
)	O
/	O
rl	double
;	O
fc_array	pointer
[	O
k	int
]	O
=	O
fc_lm1	double
;	O
fpl	double
=	O
fc_lm1	double
*	O
sl	double
-	O
fcl	double
*	O
rl	double
;	O
fcl	double
=	O
fc_lm1	double
;	O
lam	double
-=	O
1.0	int
;	O
}	O
gcl	double
=	O
G	pointer
.	O
val	double
;	O
gpl	double
=	O
Gp	pointer
.	O
val	double
;	O
lam	double
=	O
lam_min	double
+	O
1.0	int
;	O
gc_array	pointer
[	O
0	int
]	O
=	O
G	pointer
.	O
val	double
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<=	O
kmax	int
;	O
k	int
++	O
)	O
{	O
double	O
el	double
=	O
eta	double
/	O
lam	double
;	O
double	O
rl	double
=	O
hypot	function
(	O
1.0	int
,	O
el	double
)	O
;	O
double	O
sl	double
=	O
el	double
+	O
lam	double
*	O
x_inv	double
;	O
double	O
gcl1	double
=	O
(	O
sl	double
*	O
gcl	double
-	O
gpl	double
)	O
/	O
rl	double
;	O
gc_array	pointer
[	O
k	int
]	O
=	O
gcl1	double
;	O
gpl	double
=	O
rl	double
*	O
gcl	double
-	O
sl	double
*	O
gcl1	double
;	O
gcl	double
=	O
gcl1	double
;	O
lam	double
+=	O
1.0	int
;	O
}	O
return	O
stat_FG	int
;	O
}	O
int	O
gsl_sf_coulomb_wave_FGp_array	function
(	O
double	O
lam_min	double
,	O
int	O
kmax	int
,	O
double	O
eta	double
,	O
double	O
x	double
,	O
double	O
*	O
fc_array	pointer
,	O
double	O
*	O
fcp_array	pointer
,	O
double	O
*	O
gc_array	pointer
,	O
double	O
*	O
gcp_array	pointer
,	O
double	O
*	O
F_exp	double
,	O
double	O
*	O
G_exp	double
)	O
{	O
const	O
double	O
x_inv	double
=	O
1.0	int
/	O
x	double
;	O
const	O
double	O
lam_max	double
=	O
lam_min	double
+	O
kmax	int
;	O
gsl_sf_result	struct
F	pointer
,	O
Fp	pointer
;	O
gsl_sf_result	struct
G	pointer
,	O
Gp	pointer
;	O
int	O
stat_FG	int
=	O
gsl_sf_coulomb_wave_FG_e	function
(	O
eta	double
,	O
x	double
,	O
lam_max	double
,	O
kmax	int
,	O
&	O
F	pointer
,	O
&	O
Fp	pointer
,	O
&	O
G	pointer
,	O
&	O
Gp	pointer
,	O
F_exp	double
,	O
G_exp	double
)	O
;	O
double	O
fcl	double
=	O
F	pointer
.	O
val	double
;	O
double	O
fpl	double
=	O
Fp	pointer
.	O
val	double
;	O
double	O
lam	double
=	O
lam_max	double
;	O
int	O
k	int
;	O
double	O
gcl	double
,	O
gpl	double
;	O
fc_array	pointer
[	O
kmax	int
]	O
=	O
F	pointer
.	O
val	double
;	O
fcp_array	pointer
[	O
kmax	int
]	O
=	O
Fp	pointer
.	O
val	double
;	O
for	O
(	O
k	int
=	O
kmax	int
-	O
1	int
;	O
k	int
>=	O
0	int
;	O
k	int
--	O
)	O
{	O
double	O
el	double
=	O
eta	double
/	O
lam	double
;	O
double	O
rl	double
=	O
hypot	function
(	O
1.0	int
,	O
el	double
)	O
;	O
double	O
sl	double
=	O
el	double
+	O
lam	double
*	O
x_inv	double
;	O
double	O
fc_lm1	double
;	O
fc_lm1	double
=	O
(	O
fcl	double
*	O
sl	double
+	O
fpl	double
)	O
/	O
rl	double
;	O
fc_array	pointer
[	O
k	int
]	O
=	O
fc_lm1	double
;	O
fpl	double
=	O
fc_lm1	double
*	O
sl	double
-	O
fcl	double
*	O
rl	double
;	O
fcp_array	pointer
[	O
k	int
]	O
=	O
fpl	double
;	O
fcl	double
=	O
fc_lm1	double
;	O
lam	double
-=	O
1.0	int
;	O
}	O
gcl	double
=	O
G	pointer
.	O
val	double
;	O
gpl	double
=	O
Gp	pointer
.	O
val	double
;	O
lam	double
=	O
lam_min	double
+	O
1.0	int
;	O
gc_array	pointer
[	O
0	int
]	O
=	O
G	pointer
.	O
val	double
;	O
gcp_array	pointer
[	O
0	int
]	O
=	O
Gp	pointer
.	O
val	double
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<=	O
kmax	int
;	O
k	int
++	O
)	O
{	O
double	O
el	double
=	O
eta	double
/	O
lam	double
;	O
double	O
rl	double
=	O
hypot	function
(	O
1.0	int
,	O
el	double
)	O
;	O
double	O
sl	double
=	O
el	double
+	O
lam	double
*	O
x_inv	double
;	O
double	O
gcl1	double
=	O
(	O
sl	double
*	O
gcl	double
-	O
gpl	double
)	O
/	O
rl	double
;	O
gc_array	pointer
[	O
k	int
]	O
=	O
gcl1	double
;	O
gpl	double
=	O
rl	double
*	O
gcl	double
-	O
sl	double
*	O
gcl1	double
;	O
gcp_array	pointer
[	O
k	int
]	O
=	O
gpl	double
;	O
gcl	double
=	O
gcl1	double
;	O
lam	double
+=	O
1.0	int
;	O
}	O
return	O
stat_FG	int
;	O
}	O
int	O
gsl_sf_coulomb_wave_sphF_array	function
(	O
double	O
lam_min	double
,	O
int	O
kmax	int
,	O
double	O
eta	double
,	O
double	O
x	double
,	O
double	O
*	O
fc_array	pointer
,	O
double	O
*	O
F_exp	double
)	O
{	O
if	O
(	O
x	double
<	O
0.0	int
||	O
lam_min	double
<	O
-	O
0.5	int
)	O
{	O
GSL_ERROR	O
(	O
"domain error"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
else	O
if	O
(	O
x	double
<	O
10.0	int
/	O
GSL_DBL_MAX	int
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<=	O
kmax	int
;	O
k	int
++	O
)	O
{	O
fc_array	pointer
[	O
k	int
]	O
=	O
0.0	int
;	O
}	O
if	O
(	O
lam_min	double
==	O
0.0	int
)	O
{	O
fc_array	pointer
[	O
0	int
]	O
=	O
sqrt	function
(	O
C0sq	function
(	O
eta	double
)	O
)	O
;	O
}	O
*	O
F_exp	double
=	O
0.0	int
;	O
if	O
(	O
x	double
==	O
0.0	int
)	O
return	O
GSL_SUCCESS	int
;	O
else	O
GSL_ERROR	O
(	O
"underflow"	pointer
,	O
GSL_EUNDRFLW	int
)	O
;	O
}	O
else	O
{	O
int	O
k	int
;	O
int	O
stat_F	int
=	O
gsl_sf_coulomb_wave_F_array	function
(	O
lam_min	double
,	O
kmax	int
,	O
eta	double
,	O
x	double
,	O
fc_array	pointer
,	O
F_exp	double
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<=	O
kmax	int
;	O
k	int
++	O
)	O
{	O
fc_array	pointer
[	O
k	int
]	O
=	O
fc_array	pointer
[	O
k	int
]	O
/	O
x	double
;	O
}	O
return	O
stat_F	int
;	O
}	O
}	O
