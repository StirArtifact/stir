enum	O
input_type	enum
{	O
INPUT_STRING	int
,	O
INPUT_FILE	int
,	O
INPUT_MACRO	int
}	O
;	O
typedef	O
enum	O
input_type	enum
input_type	enum
;	O
struct	O
input_block	struct
{	O
struct	O
input_block	struct
*	O
prev	pointer
;	O
input_type	enum
type	enum
;	O
const	O
char	O
*	O
file	pointer
;	O
int	O
line	int
;	O
union	O
{	O
struct	O
{	O
char	O
*	O
string	struct
;	O
char	O
*	O
end	pointer
;	O
}	O
u_s	struct
;	O
struct	O
{	O
FILE	struct
*	O
fp	pointer
;	O
bool_bitfield	bool
end	pointer
:	O
1	int
;	O
bool_bitfield	bool
close	pointer
:	O
1	int
;	O
bool_bitfield	bool
advance	bool
:	O
1	int
;	O
}	O
u_f	struct
;	O
builtin_func	function
*	O
func	pointer
;	O
}	O
u	union
;	O
}	O
;	O
typedef	O
struct	O
input_block	struct
input_block	struct
;	O
const	O
char	O
*	O
current_file	pointer
;	O
int	O
current_line	int
;	O
static	O
struct	O
obstack	struct
token_stack	struct
;	O
static	O
struct	O
obstack	struct
file_names	struct
;	O
static	O
struct	O
obstack	struct
*	O
wrapup_stack	pointer
;	O
static	O
struct	O
obstack	struct
*	O
current_input	pointer
;	O
static	O
void	O
*	O
token_bottom	pointer
;	O
static	O
input_block	struct
*	O
isp	pointer
;	O
static	O
input_block	struct
*	O
wsp	pointer
;	O
static	O
input_block	struct
*	O
next	pointer
;	O
static	O
bool	bool
start_of_input_line	bool
;	O
static	O
bool	bool
input_change	bool
;	O
STRING	struct
rquote	struct
;	O
STRING	struct
lquote	struct
;	O
STRING	struct
bcomm	struct
;	O
STRING	struct
ecomm	struct
;	O
void	O
push_file	function
(	O
FILE	struct
*	O
fp	pointer
,	O
const	O
char	O
*	O
title	pointer
,	O
bool	bool
close_when_done	bool
)	O
{	O
input_block	struct
*	O
i	pointer
;	O
if	O
(	O
next	pointer
!=	O
NULL	O
)	O
{	O
obstack_free	function
(	O
current_input	pointer
,	O
next	pointer
)	O
;	O
next	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
debug_level	int
&	O
DEBUG_TRACE_INPUT	int
)	O
DEBUG_MESSAGE1	O
(	O
"input read from %s"	pointer
,	O
title	pointer
)	O
;	O
i	pointer
=	O
(	O
input_block	struct
*	O
)	O
obstack_alloc	O
(	O
current_input	pointer
,	O
sizeof	O
(	O
struct	O
input_block	struct
)	O
)	O
;	O
i	pointer
->	O
type	enum
=	O
INPUT_FILE	int
;	O
i	pointer
->	O
file	pointer
=	O
(	O
char	O
*	O
)	O
obstack_copy0	O
(	O
&	O
file_names	struct
,	O
title	pointer
,	O
strlen	function
(	O
title	pointer
)	O
)	O
;	O
i	pointer
->	O
line	int
=	O
1	int
;	O
input_change	bool
=	O
true	int
;	O
i	pointer
->	O
u	union
.	O
u_f	struct
.	O
fp	pointer
=	O
fp	pointer
;	O
i	pointer
->	O
u	union
.	O
u_f	struct
.	O
end	pointer
=	O
false	int
;	O
i	pointer
->	O
u	union
.	O
u_f	struct
.	O
close	pointer
=	O
close_when_done	bool
;	O
i	pointer
->	O
u	union
.	O
u_f	struct
.	O
advance	bool
=	O
start_of_input_line	bool
;	O
output_current_line	int
=	O
-	O
1	int
;	O
i	pointer
->	O
prev	pointer
=	O
isp	pointer
;	O
isp	pointer
=	O
i	pointer
;	O
}	O
void	O
push_macro	function
(	O
builtin_func	function
*	O
func	pointer
)	O
{	O
input_block	struct
*	O
i	pointer
;	O
if	O
(	O
next	pointer
!=	O
NULL	O
)	O
{	O
obstack_free	function
(	O
current_input	pointer
,	O
next	pointer
)	O
;	O
next	pointer
=	O
NULL	O
;	O
}	O
i	pointer
=	O
(	O
input_block	struct
*	O
)	O
obstack_alloc	O
(	O
current_input	pointer
,	O
sizeof	O
(	O
struct	O
input_block	struct
)	O
)	O
;	O
i	pointer
->	O
type	enum
=	O
INPUT_MACRO	int
;	O
i	pointer
->	O
file	pointer
=	O
current_file	pointer
;	O
i	pointer
->	O
line	int
=	O
current_line	int
;	O
input_change	bool
=	O
true	int
;	O
i	pointer
->	O
u	union
.	O
func	pointer
=	O
func	pointer
;	O
i	pointer
->	O
prev	pointer
=	O
isp	pointer
;	O
isp	pointer
=	O
i	pointer
;	O
}	O
struct	O
obstack	struct
*	O
push_string_init	function
(	O
void	O
)	O
{	O
if	O
(	O
next	pointer
!=	O
NULL	O
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: recursive push_string!"	pointer
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
next	pointer
=	O
(	O
input_block	struct
*	O
)	O
obstack_alloc	O
(	O
current_input	pointer
,	O
sizeof	O
(	O
struct	O
input_block	struct
)	O
)	O
;	O
next	pointer
->	O
type	enum
=	O
INPUT_STRING	int
;	O
next	pointer
->	O
file	pointer
=	O
current_file	pointer
;	O
next	pointer
->	O
line	int
=	O
current_line	int
;	O
return	O
current_input	pointer
;	O
}	O
const	O
char	O
*	O
push_string_finish	function
(	O
void	O
)	O
{	O
const	O
char	O
*	O
ret	pointer
=	O
NULL	O
;	O
if	O
(	O
next	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
obstack_object_size	O
(	O
current_input	pointer
)	O
>	O
0	int
)	O
{	O
size_t	long
len	long
=	O
obstack_object_size	O
(	O
current_input	pointer
)	O
;	O
obstack_1grow	O
(	O
current_input	pointer
,	O
'\0'	O
)	O
;	O
next	pointer
->	O
u	union
.	O
u_s	struct
.	O
string	struct
=	O
(	O
char	O
*	O
)	O
obstack_finish	O
(	O
current_input	pointer
)	O
;	O
next	pointer
->	O
u	union
.	O
u_s	struct
.	O
end	pointer
=	O
next	pointer
->	O
u	union
.	O
u_s	struct
.	O
string	struct
+	O
len	long
;	O
next	pointer
->	O
prev	pointer
=	O
isp	pointer
;	O
isp	pointer
=	O
next	pointer
;	O
ret	pointer
=	O
isp	pointer
->	O
u	union
.	O
u_s	struct
.	O
string	struct
;	O
input_change	bool
=	O
true	int
;	O
}	O
else	O
obstack_free	function
(	O
current_input	pointer
,	O
next	pointer
)	O
;	O
next	pointer
=	O
NULL	O
;	O
return	O
ret	pointer
;	O
}	O
void	O
push_wrapup	function
(	O
const	O
char	O
*	O
s	long
)	O
{	O
size_t	long
len	long
=	O
strlen	function
(	O
s	long
)	O
;	O
input_block	struct
*	O
i	pointer
;	O
i	pointer
=	O
(	O
input_block	struct
*	O
)	O
obstack_alloc	O
(	O
wrapup_stack	pointer
,	O
sizeof	O
(	O
struct	O
input_block	struct
)	O
)	O
;	O
i	pointer
->	O
prev	pointer
=	O
wsp	pointer
;	O
i	pointer
->	O
type	enum
=	O
INPUT_STRING	int
;	O
i	pointer
->	O
file	pointer
=	O
current_file	pointer
;	O
i	pointer
->	O
line	int
=	O
current_line	int
;	O
i	pointer
->	O
u	union
.	O
u_s	struct
.	O
string	struct
=	O
(	O
char	O
*	O
)	O
obstack_copy0	O
(	O
wrapup_stack	pointer
,	O
s	long
,	O
len	long
)	O
;	O
i	pointer
->	O
u	union
.	O
u_s	struct
.	O
end	pointer
=	O
i	pointer
->	O
u	union
.	O
u_s	struct
.	O
string	struct
+	O
len	long
;	O
wsp	pointer
=	O
i	pointer
;	O
}	O
static	O
void	O
pop_input	function
(	O
void	O
)	O
{	O
input_block	struct
*	O
tmp	pointer
=	O
isp	pointer
->	O
prev	pointer
;	O
switch	O
(	O
isp	pointer
->	O
type	enum
)	O
{	O
case	O
INPUT_STRING	int
:	O
case	O
INPUT_MACRO	int
:	O
break	O
;	O
case	O
INPUT_FILE	int
:	O
if	O
(	O
debug_level	int
&	O
DEBUG_TRACE_INPUT	int
)	O
{	O
if	O
(	O
tmp	pointer
)	O
DEBUG_MESSAGE2	O
(	O
"input reverted to %s, line %d"	pointer
,	O
tmp	pointer
->	O
file	pointer
,	O
tmp	pointer
->	O
line	int
)	O
;	O
else	O
DEBUG_MESSAGE	O
(	O
"input exhausted"	pointer
)	O
;	O
}	O
if	O
(	O
ferror	function
(	O
isp	pointer
->	O
u	union
.	O
u_f	struct
.	O
fp	pointer
)	O
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"read error"	pointer
)	O
)	O
;	O
if	O
(	O
isp	pointer
->	O
u	union
.	O
u_f	struct
.	O
close	pointer
)	O
fclose	function
(	O
isp	pointer
->	O
u	union
.	O
u_f	struct
.	O
fp	pointer
)	O
;	O
retcode	int
=	O
EXIT_FAILURE	int
;	O
}	O
else	O
if	O
(	O
isp	pointer
->	O
u	union
.	O
u_f	struct
.	O
close	pointer
&&	O
fclose	function
(	O
isp	pointer
->	O
u	union
.	O
u_f	struct
.	O
fp	pointer
)	O
==	O
EOF	O
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
errno	O
,	O
"error reading file"	pointer
)	O
)	O
;	O
retcode	int
=	O
EXIT_FAILURE	int
;	O
}	O
start_of_input_line	bool
=	O
isp	pointer
->	O
u	union
.	O
u_f	struct
.	O
advance	bool
;	O
output_current_line	int
=	O
-	O
1	int
;	O
break	O
;	O
default	O
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: input stack botch in pop_input ()"	pointer
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
obstack_free	function
(	O
current_input	pointer
,	O
isp	pointer
)	O
;	O
next	pointer
=	O
NULL	O
;	O
isp	pointer
=	O
tmp	pointer
;	O
input_change	bool
=	O
true	int
;	O
}	O
bool	bool
pop_wrapup	function
(	O
void	O
)	O
{	O
next	pointer
=	O
NULL	O
;	O
obstack_free	function
(	O
current_input	pointer
,	O
NULL	O
)	O
;	O
free	function
(	O
current_input	pointer
)	O
;	O
if	O
(	O
wsp	pointer
==	O
NULL	O
)	O
{	O
obstack_free	function
(	O
&	O
token_stack	struct
,	O
NULL	O
)	O
;	O
obstack_free	function
(	O
&	O
file_names	struct
,	O
NULL	O
)	O
;	O
obstack_free	function
(	O
wrapup_stack	pointer
,	O
NULL	O
)	O
;	O
free	function
(	O
wrapup_stack	pointer
)	O
;	O
return	O
false	int
;	O
}	O
current_input	pointer
=	O
wrapup_stack	pointer
;	O
wrapup_stack	pointer
=	O
(	O
struct	O
obstack	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
obstack	struct
)	O
)	O
;	O
obstack_init	O
(	O
wrapup_stack	pointer
)	O
;	O
isp	pointer
=	O
wsp	pointer
;	O
wsp	pointer
=	O
NULL	O
;	O
input_change	bool
=	O
true	int
;	O
return	O
true	int
;	O
}	O
static	O
void	O
init_macro_token	function
(	O
token_data	struct
*	O
td	pointer
)	O
{	O
if	O
(	O
isp	pointer
->	O
type	enum
!=	O
INPUT_MACRO	int
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: bad call to init_macro_token ()"	pointer
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
TOKEN_DATA_TYPE	O
(	O
td	pointer
)	O
=	O
TOKEN_FUNC	int
;	O
TOKEN_DATA_FUNC	O
(	O
td	pointer
)	O
=	O
isp	pointer
->	O
u	union
.	O
func	pointer
;	O
}	O
static	O
int	O
peek_input	function
(	O
void	O
)	O
{	O
int	O
ch	int
;	O
input_block	struct
*	O
block	pointer
=	O
isp	pointer
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
block	pointer
==	O
NULL	O
)	O
return	O
CHAR_EOF	int
;	O
switch	O
(	O
block	pointer
->	O
type	enum
)	O
{	O
case	O
INPUT_STRING	int
:	O
ch	int
=	O
to_uchar	O
(	O
block	pointer
->	O
u	union
.	O
u_s	struct
.	O
string	struct
[	O
0	int
]	O
)	O
;	O
if	O
(	O
ch	int
!=	O
'\0'	O
)	O
return	O
ch	int
;	O
break	O
;	O
case	O
INPUT_FILE	int
:	O
ch	int
=	O
getc	function
(	O
block	pointer
->	O
u	union
.	O
u_f	struct
.	O
fp	pointer
)	O
;	O
if	O
(	O
ch	int
!=	O
EOF	O
)	O
{	O
ungetc	function
(	O
ch	int
,	O
block	pointer
->	O
u	union
.	O
u_f	struct
.	O
fp	pointer
)	O
;	O
return	O
ch	int
;	O
}	O
block	pointer
->	O
u	union
.	O
u_f	struct
.	O
end	pointer
=	O
true	int
;	O
break	O
;	O
case	O
INPUT_MACRO	int
:	O
return	O
CHAR_MACRO	int
;	O
default	O
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: input stack botch in peek_input ()"	pointer
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
block	pointer
=	O
block	pointer
->	O
prev	pointer
;	O
}	O
}	O
static	O
int	O
next_char_1	function
(	O
void	O
)	O
{	O
int	O
ch	int
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
isp	pointer
==	O
NULL	O
)	O
{	O
current_file	pointer
=	O
""	pointer
;	O
current_line	int
=	O
0	int
;	O
return	O
CHAR_EOF	int
;	O
}	O
if	O
(	O
input_change	bool
)	O
{	O
current_file	pointer
=	O
isp	pointer
->	O
file	pointer
;	O
current_line	int
=	O
isp	pointer
->	O
line	int
;	O
input_change	bool
=	O
false	int
;	O
}	O
switch	O
(	O
isp	pointer
->	O
type	enum
)	O
{	O
case	O
INPUT_STRING	int
:	O
ch	int
=	O
to_uchar	O
(	O
*	O
isp	pointer
->	O
u	union
.	O
u_s	struct
.	O
string	struct
++	O
)	O
;	O
if	O
(	O
ch	int
!=	O
'\0'	O
)	O
return	O
ch	int
;	O
break	O
;	O
case	O
INPUT_FILE	int
:	O
if	O
(	O
start_of_input_line	bool
)	O
{	O
start_of_input_line	bool
=	O
false	int
;	O
current_line	int
=	O
++	O
isp	pointer
->	O
line	int
;	O
}	O
ch	int
=	O
isp	pointer
->	O
u	union
.	O
u_f	struct
.	O
end	pointer
?	O
EOF	O
:	O
getc	function
(	O
isp	pointer
->	O
u	union
.	O
u_f	struct
.	O
fp	pointer
)	O
;	O
if	O
(	O
ch	int
!=	O
EOF	O
)	O
{	O
if	O
(	O
ch	int
==	O
'\n'	O
)	O
start_of_input_line	bool
=	O
true	int
;	O
return	O
ch	int
;	O
}	O
break	O
;	O
case	O
INPUT_MACRO	int
:	O
pop_input	function
(	O
)	O
;	O
return	O
CHAR_MACRO	int
;	O
default	O
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: input stack botch in next_char ()"	pointer
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
pop_input	function
(	O
)	O
;	O
}	O
}	O
void	O
skip_line	function
(	O
void	O
)	O
{	O
int	O
ch	int
;	O
const	O
char	O
*	O
file	pointer
=	O
current_file	pointer
;	O
int	O
line	int
=	O
current_line	int
;	O
while	O
(	O
(	O
ch	int
=	O
next_char	O
(	O
)	O
)	O
!=	O
CHAR_EOF	int
&&	O
ch	int
!=	O
'\n'	O
)	O
;	O
if	O
(	O
ch	int
==	O
CHAR_EOF	int
)	O
M4ERROR_AT_LINE	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
file	pointer
,	O
line	int
,	O
"Warning: end of file treated as newline"	pointer
)	O
)	O
;	O
if	O
(	O
file	pointer
!=	O
current_file	pointer
||	O
line	int
!=	O
current_line	int
)	O
input_change	bool
=	O
true	int
;	O
}	O
static	O
bool	bool
match_input	function
(	O
const	O
char	O
*	O
s	long
,	O
bool	bool
consume	bool
)	O
{	O
int	O
n	long
;	O
int	O
ch	int
;	O
const	O
char	O
*	O
t	pointer
;	O
bool	bool
result	pointer
=	O
false	int
;	O
ch	int
=	O
peek_input	function
(	O
)	O
;	O
if	O
(	O
ch	int
!=	O
to_uchar	O
(	O
*	O
s	long
)	O
)	O
return	O
false	int
;	O
if	O
(	O
s	long
[	O
1	int
]	O
==	O
'\0'	O
)	O
{	O
if	O
(	O
consume	bool
)	O
next_char	O
(	O
)	O
;	O
return	O
true	int
;	O
}	O
next_char	O
(	O
)	O
;	O
for	O
(	O
n	long
=	O
1	int
,	O
t	pointer
=	O
s	long
++	O
;	O
peek_input	function
(	O
)	O
==	O
to_uchar	O
(	O
*	O
s	long
++	O
)	O
;	O
)	O
{	O
next_char	O
(	O
)	O
;	O
n	long
++	O
;	O
if	O
(	O
*	O
s	long
==	O
'\0'	O
)	O
{	O
if	O
(	O
consume	bool
)	O
return	O
true	int
;	O
result	pointer
=	O
true	int
;	O
break	O
;	O
}	O
}	O
{	O
struct	O
obstack	struct
*	O
h	pointer
=	O
push_string_init	function
(	O
)	O
;	O
obstack_grow	O
(	O
h	pointer
,	O
t	pointer
,	O
n	long
)	O
;	O
}	O
push_string_finish	function
(	O
)	O
;	O
return	O
result	pointer
;	O
}	O
void	O
input_init	function
(	O
void	O
)	O
{	O
current_file	pointer
=	O
""	pointer
;	O
current_line	int
=	O
0	int
;	O
current_input	pointer
=	O
(	O
struct	O
obstack	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
obstack	struct
)	O
)	O
;	O
obstack_init	O
(	O
current_input	pointer
)	O
;	O
wrapup_stack	pointer
=	O
(	O
struct	O
obstack	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
obstack	struct
)	O
)	O
;	O
obstack_init	O
(	O
wrapup_stack	pointer
)	O
;	O
obstack_init	O
(	O
&	O
file_names	struct
)	O
;	O
obstack_init	O
(	O
&	O
token_stack	struct
)	O
;	O
obstack_alloc	O
(	O
&	O
token_stack	struct
,	O
1	int
)	O
;	O
token_bottom	pointer
=	O
obstack_base	O
(	O
&	O
token_stack	struct
)	O
;	O
isp	pointer
=	O
NULL	O
;	O
wsp	pointer
=	O
NULL	O
;	O
next	pointer
=	O
NULL	O
;	O
start_of_input_line	bool
=	O
false	int
;	O
lquote	struct
.	O
string	struct
=	O
xstrdup	function
(	O
DEF_LQUOTE	pointer
)	O
;	O
lquote	struct
.	O
length	long
=	O
strlen	function
(	O
lquote	struct
.	O
string	struct
)	O
;	O
rquote	struct
.	O
string	struct
=	O
xstrdup	function
(	O
DEF_RQUOTE	pointer
)	O
;	O
rquote	struct
.	O
length	long
=	O
strlen	function
(	O
rquote	struct
.	O
string	struct
)	O
;	O
bcomm	struct
.	O
string	struct
=	O
xstrdup	function
(	O
DEF_BCOMM	pointer
)	O
;	O
bcomm	struct
.	O
length	long
=	O
strlen	function
(	O
bcomm	struct
.	O
string	struct
)	O
;	O
ecomm	struct
.	O
string	struct
=	O
xstrdup	function
(	O
DEF_ECOMM	pointer
)	O
;	O
ecomm	struct
.	O
length	long
=	O
strlen	function
(	O
ecomm	struct
.	O
string	struct
)	O
;	O
}	O
void	O
set_quotes	function
(	O
const	O
char	O
*	O
lq	pointer
,	O
const	O
char	O
*	O
rq	pointer
)	O
{	O
free	function
(	O
lquote	struct
.	O
string	struct
)	O
;	O
free	function
(	O
rquote	struct
.	O
string	struct
)	O
;	O
if	O
(	O
!	O
lq	pointer
)	O
{	O
lq	pointer
=	O
DEF_LQUOTE	pointer
;	O
rq	pointer
=	O
DEF_RQUOTE	pointer
;	O
}	O
else	O
if	O
(	O
!	O
rq	pointer
||	O
(	O
*	O
lq	pointer
&&	O
!	O
*	O
rq	pointer
)	O
)	O
rq	pointer
=	O
DEF_RQUOTE	pointer
;	O
lquote	struct
.	O
string	struct
=	O
xstrdup	function
(	O
lq	pointer
)	O
;	O
lquote	struct
.	O
length	long
=	O
strlen	function
(	O
lquote	struct
.	O
string	struct
)	O
;	O
rquote	struct
.	O
string	struct
=	O
xstrdup	function
(	O
rq	pointer
)	O
;	O
rquote	struct
.	O
length	long
=	O
strlen	function
(	O
rquote	struct
.	O
string	struct
)	O
;	O
}	O
void	O
set_comment	function
(	O
const	O
char	O
*	O
bc	pointer
,	O
const	O
char	O
*	O
ec	pointer
)	O
{	O
free	function
(	O
bcomm	struct
.	O
string	struct
)	O
;	O
free	function
(	O
ecomm	struct
.	O
string	struct
)	O
;	O
if	O
(	O
!	O
bc	pointer
)	O
bc	pointer
=	O
ec	pointer
=	O
""	pointer
;	O
else	O
if	O
(	O
!	O
ec	pointer
||	O
(	O
*	O
bc	pointer
&&	O
!	O
*	O
ec	pointer
)	O
)	O
ec	pointer
=	O
DEF_ECOMM	pointer
;	O
bcomm	struct
.	O
string	struct
=	O
xstrdup	function
(	O
bc	pointer
)	O
;	O
bcomm	struct
.	O
length	long
=	O
strlen	function
(	O
bcomm	struct
.	O
string	struct
)	O
;	O
ecomm	struct
.	O
string	struct
=	O
xstrdup	function
(	O
ec	pointer
)	O
;	O
ecomm	struct
.	O
length	long
=	O
strlen	function
(	O
ecomm	struct
.	O
string	struct
)	O
;	O
}	O
token_type	enum
next_token	function
(	O
token_data	struct
*	O
td	pointer
,	O
int	O
*	O
line	int
)	O
{	O
int	O
ch	int
;	O
int	O
quote_level	int
;	O
token_type	enum
type	enum
;	O
const	O
char	O
*	O
file	pointer
;	O
int	O
dummy	int
;	O
obstack_free	function
(	O
&	O
token_stack	struct
,	O
token_bottom	pointer
)	O
;	O
if	O
(	O
!	O
line	int
)	O
line	int
=	O
&	O
dummy	int
;	O
ch	int
=	O
peek_input	function
(	O
)	O
;	O
if	O
(	O
ch	int
==	O
CHAR_EOF	int
)	O
{	O
next_char	O
(	O
)	O
;	O
return	O
TOKEN_EOF	int
;	O
}	O
if	O
(	O
ch	int
==	O
CHAR_MACRO	int
)	O
{	O
init_macro_token	function
(	O
td	pointer
)	O
;	O
next_char	O
(	O
)	O
;	O
return	O
TOKEN_MACDEF	int
;	O
}	O
next_char	O
(	O
)	O
;	O
file	pointer
=	O
current_file	pointer
;	O
*	O
line	int
=	O
current_line	int
;	O
if	O
(	O
MATCH	O
(	O
ch	int
,	O
bcomm	struct
.	O
string	struct
,	O
true	int
)	O
)	O
{	O
obstack_grow	O
(	O
&	O
token_stack	struct
,	O
bcomm	struct
.	O
string	struct
,	O
bcomm	struct
.	O
length	long
)	O
;	O
while	O
(	O
(	O
ch	int
=	O
next_char	O
(	O
)	O
)	O
!=	O
CHAR_EOF	int
&&	O
!	O
MATCH	O
(	O
ch	int
,	O
ecomm	struct
.	O
string	struct
,	O
true	int
)	O
)	O
obstack_1grow	O
(	O
&	O
token_stack	struct
,	O
ch	int
)	O
;	O
if	O
(	O
ch	int
!=	O
CHAR_EOF	int
)	O
obstack_grow	O
(	O
&	O
token_stack	struct
,	O
ecomm	struct
.	O
string	struct
,	O
ecomm	struct
.	O
length	long
)	O
;	O
else	O
M4ERROR_AT_LINE	O
(	O
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
file	pointer
,	O
*	O
line	int
,	O
"ERROR: end of file in comment"	pointer
)	O
)	O
;	O
type	enum
=	O
TOKEN_STRING	int
;	O
}	O
else	O
if	O
(	O
default_word_regexp	int
&&	O
(	O
isalpha	function
(	O
ch	int
)	O
||	O
ch	int
==	O
'_'	O
)	O
)	O
{	O
obstack_1grow	O
(	O
&	O
token_stack	struct
,	O
ch	int
)	O
;	O
while	O
(	O
(	O
ch	int
=	O
peek_input	function
(	O
)	O
)	O
!=	O
CHAR_EOF	int
&&	O
(	O
isalnum	function
(	O
ch	int
)	O
||	O
ch	int
==	O
'_'	O
)	O
)	O
{	O
obstack_1grow	O
(	O
&	O
token_stack	struct
,	O
ch	int
)	O
;	O
next_char	O
(	O
)	O
;	O
}	O
type	enum
=	O
TOKEN_WORD	int
;	O
}	O
else	O
if	O
(	O
!	O
MATCH	O
(	O
ch	int
,	O
lquote	struct
.	O
string	struct
,	O
true	int
)	O
)	O
{	O
switch	O
(	O
ch	int
)	O
{	O
case	O
'('	O
:	O
type	enum
=	O
TOKEN_OPEN	int
;	O
break	O
;	O
case	O
','	O
:	O
type	enum
=	O
TOKEN_COMMA	int
;	O
break	O
;	O
case	O
')'	O
:	O
type	enum
=	O
TOKEN_CLOSE	int
;	O
break	O
;	O
default	O
:	O
type	enum
=	O
TOKEN_SIMPLE	int
;	O
break	O
;	O
}	O
obstack_1grow	O
(	O
&	O
token_stack	struct
,	O
ch	int
)	O
;	O
}	O
else	O
{	O
bool	bool
fast	bool
=	O
lquote	struct
.	O
length	long
==	O
1	int
&&	O
rquote	struct
.	O
length	long
==	O
1	int
;	O
quote_level	int
=	O
1	int
;	O
while	O
(	O
1	int
)	O
{	O
const	O
char	O
*	O
buffer	pointer
=	O
(	O
isp	pointer
&&	O
isp	pointer
->	O
type	enum
==	O
INPUT_STRING	int
?	O
isp	pointer
->	O
u	union
.	O
u_s	struct
.	O
string	struct
:	O
NULL	O
)	O
;	O
if	O
(	O
buffer	pointer
&&	O
*	O
buffer	pointer
)	O
{	O
size_t	long
len	long
=	O
isp	pointer
->	O
u	union
.	O
u_s	struct
.	O
end	pointer
-	O
buffer	pointer
;	O
const	O
char	O
*	O
p	pointer
=	O
buffer	pointer
;	O
do	O
{	O
p	pointer
=	O
(	O
char	O
*	O
)	O
memchr2	function
(	O
p	pointer
,	O
*	O
lquote	struct
.	O
string	struct
,	O
*	O
rquote	struct
.	O
string	struct
,	O
buffer	pointer
+	O
len	long
-	O
p	pointer
)	O
;	O
}	O
while	O
(	O
p	pointer
&&	O
fast	bool
&&	O
(	O
*	O
p	pointer
++	O
==	O
*	O
rquote	struct
.	O
string	struct
?	O
--	O
quote_level	int
:	O
++	O
quote_level	int
)	O
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
if	O
(	O
fast	bool
)	O
{	O
assert	O
(	O
!	O
quote_level	int
)	O
;	O
obstack_grow	O
(	O
&	O
token_stack	struct
,	O
buffer	pointer
,	O
p	pointer
-	O
buffer	pointer
-	O
1	int
)	O
;	O
isp	pointer
->	O
u	union
.	O
u_s	struct
.	O
string	struct
+=	O
p	pointer
-	O
buffer	pointer
;	O
break	O
;	O
}	O
obstack_grow	O
(	O
&	O
token_stack	struct
,	O
buffer	pointer
,	O
p	pointer
-	O
buffer	pointer
)	O
;	O
ch	int
=	O
to_uchar	O
(	O
*	O
p	pointer
)	O
;	O
isp	pointer
->	O
u	union
.	O
u_s	struct
.	O
string	struct
+=	O
p	pointer
-	O
buffer	pointer
+	O
1	int
;	O
}	O
else	O
{	O
obstack_grow	O
(	O
&	O
token_stack	struct
,	O
buffer	pointer
,	O
len	long
)	O
;	O
isp	pointer
->	O
u	union
.	O
u_s	struct
.	O
string	struct
+=	O
len	long
;	O
continue	O
;	O
}	O
}	O
else	O
ch	int
=	O
next_char	O
(	O
)	O
;	O
if	O
(	O
ch	int
==	O
CHAR_EOF	int
)	O
M4ERROR_AT_LINE	O
(	O
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
file	pointer
,	O
*	O
line	int
,	O
"ERROR: end of file in string"	pointer
)	O
)	O
;	O
if	O
(	O
MATCH	O
(	O
ch	int
,	O
rquote	struct
.	O
string	struct
,	O
true	int
)	O
)	O
{	O
if	O
(	O
--	O
quote_level	int
==	O
0	int
)	O
break	O
;	O
obstack_grow	O
(	O
&	O
token_stack	struct
,	O
rquote	struct
.	O
string	struct
,	O
rquote	struct
.	O
length	long
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
ch	int
,	O
lquote	struct
.	O
string	struct
,	O
true	int
)	O
)	O
{	O
quote_level	int
++	O
;	O
obstack_grow	O
(	O
&	O
token_stack	struct
,	O
lquote	struct
.	O
string	struct
,	O
lquote	struct
.	O
length	long
)	O
;	O
}	O
else	O
obstack_1grow	O
(	O
&	O
token_stack	struct
,	O
ch	int
)	O
;	O
}	O
type	enum
=	O
TOKEN_STRING	int
;	O
}	O
obstack_1grow	O
(	O
&	O
token_stack	struct
,	O
'\0'	O
)	O
;	O
TOKEN_DATA_TYPE	O
(	O
td	pointer
)	O
=	O
TOKEN_TEXT	int
;	O
TOKEN_DATA_TEXT	O
(	O
td	pointer
)	O
=	O
(	O
char	O
*	O
)	O
obstack_finish	O
(	O
&	O
token_stack	struct
)	O
;	O
return	O
type	enum
;	O
}	O
token_type	enum
peek_token	function
(	O
void	O
)	O
{	O
token_type	enum
result	pointer
;	O
int	O
ch	int
=	O
peek_input	function
(	O
)	O
;	O
if	O
(	O
ch	int
==	O
CHAR_EOF	int
)	O
{	O
result	pointer
=	O
TOKEN_EOF	int
;	O
}	O
else	O
if	O
(	O
ch	int
==	O
CHAR_MACRO	int
)	O
{	O
result	pointer
=	O
TOKEN_MACDEF	int
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
ch	int
,	O
bcomm	struct
.	O
string	struct
,	O
false	int
)	O
)	O
{	O
result	pointer
=	O
TOKEN_STRING	int
;	O
}	O
else	O
if	O
(	O
(	O
default_word_regexp	int
&&	O
(	O
isalpha	function
(	O
ch	int
)	O
||	O
ch	int
==	O
'_'	O
)	O
)	O
)	O
{	O
result	pointer
=	O
TOKEN_WORD	int
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
ch	int
,	O
lquote	struct
.	O
string	struct
,	O
false	int
)	O
)	O
{	O
result	pointer
=	O
TOKEN_STRING	int
;	O
}	O
else	O
switch	O
(	O
ch	int
)	O
{	O
case	O
'('	O
:	O
result	pointer
=	O
TOKEN_OPEN	int
;	O
break	O
;	O
case	O
','	O
:	O
result	pointer
=	O
TOKEN_COMMA	int
;	O
break	O
;	O
case	O
')'	O
:	O
result	pointer
=	O
TOKEN_CLOSE	int
;	O
break	O
;	O
default	O
:	O
result	pointer
=	O
TOKEN_SIMPLE	int
;	O
}	O
return	O
result	pointer
;	O
}	O
