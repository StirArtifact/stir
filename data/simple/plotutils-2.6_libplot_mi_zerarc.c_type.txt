typedef	O
struct	O
{	O
bool	enum
skipStart	enum
;	O
bool	enum
haveStart	enum
;	O
miPoint	struct
startPt	struct
;	O
bool	enum
haveLast	enum
;	O
bool	enum
skipLast	enum
;	O
miPoint	struct
endPt	struct
;	O
int	O
dashNum	int
;	O
int	O
dashIndex	int
;	O
int	O
dashOffset	int
;	O
int	O
dashNumInit	int
;	O
int	O
dashIndexInit	int
;	O
int	O
dashOffsetInit	int
;	O
}	O
miDashInfo	struct
;	O
static	O
const	O
miZeroArcPt	struct
_oob_arc_pt	struct
=	O
{	O
INT_MAX	O
,	O
INT_MAX	O
,	O
0	int
}	O
;	O
static	O
bool	enum
miZeroArcSetup	function
(	O
const	O
miArc	struct
*	O
arc	pointer
,	O
miZeroArc	struct
*	O
info	pointer
,	O
bool	enum
ok360	enum
)	O
;	O
static	O
miPoint	struct
*	O
miZeroArcPts	function
(	O
const	O
miArc	struct
*	O
arc	pointer
,	O
miPoint	struct
*	O
pts	array
)	O
;	O
static	O
void	O
miZeroArcDashPts	function
(	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
const	O
miArc	struct
*	O
arc	pointer
,	O
miDashInfo	struct
*	O
dinfo	pointer
,	O
int	O
maxPts	int
,	O
miPoint	struct
*	O
*	O
pts	array
)	O
;	O
void	O
miZeroPolyArc_r	O
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
int	O
narcs	int
,	O
const	O
miArc	struct
*	O
parcs	pointer
,	O
miEllipseCache	struct
*	O
ellipseCache	pointer
)	O
{	O
const	O
miArc	struct
*	O
arc	pointer
;	O
miDashInfo	struct
dinfo	pointer
;	O
int	O
j	int
;	O
if	O
(	O
pGC	pointer
->	O
lineStyle	int
!=	O
(	O
int	O
)	O
MI_LINE_SOLID	int
)	O
{	O
dinfo	pointer
.	O
haveStart	enum
=	O
false	int
;	O
dinfo	pointer
.	O
skipStart	enum
=	O
false	int
;	O
dinfo	pointer
.	O
haveLast	enum
=	O
false	int
;	O
dinfo	pointer
.	O
dashIndexInit	int
=	O
0	int
;	O
dinfo	pointer
.	O
dashNumInit	int
=	O
0	int
;	O
dinfo	pointer
.	O
dashOffsetInit	int
=	O
0	int
;	O
miStepDash	O
(	O
pGC	pointer
->	O
dashOffset	int
,	O
&	O
dinfo	pointer
.	O
dashNumInit	int
,	O
&	O
dinfo	pointer
.	O
dashIndexInit	int
,	O
pGC	pointer
->	O
dash	pointer
,	O
pGC	pointer
->	O
numInDashList	int
,	O
&	O
dinfo	pointer
.	O
dashOffsetInit	int
)	O
;	O
}	O
for	O
(	O
arc	pointer
=	O
parcs	pointer
,	O
j	int
=	O
narcs	int
;	O
--	O
j	int
>=	O
0	int
;	O
arc	pointer
++	O
)	O
{	O
if	O
(	O
!	O
MI_CAN_ZERO_ARC	O
(	O
arc	pointer
)	O
)	O
miPolyArc_r	O
(	O
paintedSet	pointer
,	O
pGC	pointer
,	O
1	int
,	O
arc	pointer
,	O
ellipseCache	pointer
)	O
;	O
else	O
{	O
miPoint	struct
*	O
*	O
ptsInit	pointer
,	O
*	O
*	O
pts	array
;	O
int	O
maxPts	int
=	O
0	int
,	O
numPts	int
,	O
i	int
,	O
n	array
;	O
int	O
numPixels	int
=	O
pGC	pointer
->	O
numPixels	int
;	O
if	O
(	O
arc	pointer
->	O
width	array
>	O
arc	pointer
->	O
height	int
)	O
maxPts	int
=	O
arc	pointer
->	O
width	array
+	O
(	O
arc	pointer
->	O
height	int
>>	O
1	int
)	O
;	O
else	O
maxPts	int
=	O
arc	pointer
->	O
height	int
+	O
(	O
arc	pointer
->	O
width	array
>>	O
1	int
)	O
;	O
if	O
(	O
maxPts	int
==	O
0	int
)	O
continue	O
;	O
numPts	int
=	O
4	int
*	O
maxPts	int
;	O
ptsInit	pointer
=	O
(	O
miPoint	struct
*	O
*	O
)	O
mi_xmalloc	O
(	O
numPixels	int
*	O
sizeof	O
(	O
miPoint	struct
*	O
)	O
)	O
;	O
pts	array
=	O
(	O
miPoint	struct
*	O
*	O
)	O
mi_xmalloc	O
(	O
numPixels	int
*	O
sizeof	O
(	O
miPoint	struct
*	O
)	O
)	O
;	O
if	O
(	O
pGC	pointer
->	O
lineStyle	int
==	O
(	O
int	O
)	O
MI_LINE_SOLID	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
numPixels	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
==	O
1	int
)	O
ptsInit	pointer
[	O
i	int
]	O
=	O
(	O
miPoint	struct
*	O
)	O
mi_xmalloc	O
(	O
numPts	int
*	O
sizeof	O
(	O
miPoint	struct
)	O
)	O
;	O
else	O
ptsInit	pointer
[	O
i	int
]	O
=	O
(	O
miPoint	struct
*	O
)	O
NULL	O
;	O
pts	array
[	O
i	int
]	O
=	O
ptsInit	pointer
[	O
i	int
]	O
;	O
}	O
pts	array
[	O
1	int
]	O
=	O
miZeroArcPts	function
(	O
arc	pointer
,	O
ptsInit	pointer
[	O
1	int
]	O
)	O
;	O
}	O
else	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
numPixels	int
;	O
i	int
++	O
)	O
{	O
ptsInit	pointer
[	O
i	int
]	O
=	O
(	O
miPoint	struct
*	O
)	O
mi_xmalloc	O
(	O
numPts	int
*	O
sizeof	O
(	O
miPoint	struct
)	O
)	O
;	O
pts	array
[	O
i	int
]	O
=	O
ptsInit	pointer
[	O
i	int
]	O
;	O
}	O
dinfo	pointer
.	O
skipLast	enum
=	O
(	O
i	int
==	O
0	int
?	O
false	int
:	O
true	int
)	O
;	O
miZeroArcDashPts	function
(	O
pGC	pointer
,	O
arc	pointer
,	O
&	O
dinfo	pointer
,	O
maxPts	int
,	O
pts	array
)	O
;	O
dinfo	pointer
.	O
skipStart	enum
=	O
true	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
numPixels	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
ptsInit	pointer
[	O
i	int
]	O
==	O
(	O
miPoint	struct
*	O
)	O
NULL	O
)	O
continue	O
;	O
if	O
(	O
i	int
==	O
0	int
&&	O
pGC	pointer
->	O
lineStyle	int
!=	O
(	O
int	O
)	O
MI_LINE_DOUBLE_DASH	int
)	O
{	O
free	function
(	O
ptsInit	pointer
[	O
i	int
]	O
)	O
;	O
continue	O
;	O
}	O
n	array
=	O
pts	array
[	O
i	int
]	O
-	O
ptsInit	pointer
[	O
i	int
]	O
;	O
if	O
(	O
n	array
>	O
0	int
)	O
{	O
unsigned	O
int	O
*	O
widths	pointer
;	O
int	O
k	int
;	O
widths	pointer
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
n	array
*	O
sizeof	O
(	O
unsigned	O
int	O
)	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
n	array
;	O
k	int
++	O
)	O
widths	pointer
[	O
k	int
]	O
=	O
1	int
;	O
miQuickSortSpansY	O
(	O
ptsInit	pointer
[	O
i	int
]	O
,	O
widths	pointer
,	O
n	array
)	O
;	O
MI_PAINT_SPANS	O
(	O
paintedSet	pointer
,	O
pGC	pointer
->	O
pixels	pointer
[	O
i	int
]	O
,	O
n	array
,	O
ptsInit	pointer
[	O
i	int
]	O
,	O
widths	pointer
)	O
}	O
}	O
free	function
(	O
pts	array
)	O
;	O
free	function
(	O
ptsInit	pointer
)	O
;	O
}	O
}	O
}	O
static	O
miPoint	struct
*	O
miZeroArcPts	function
(	O
const	O
miArc	struct
*	O
arc	pointer
,	O
miPoint	struct
*	O
pts	array
)	O
{	O
miZeroArc	struct
info	pointer
;	O
int	O
x	double
,	O
y	double
,	O
a	int
,	O
b	int
,	O
d	int
;	O
unsigned	O
int	O
mask	int
;	O
int	O
k1	int
,	O
k3	int
,	O
dx	int
,	O
dy	int
;	O
bool	enum
do360	enum
;	O
do360	enum
=	O
miZeroArcSetup	function
(	O
arc	pointer
,	O
&	O
info	pointer
,	O
true	int
)	O
;	O
MIARCSETUP	O
(	O
info	pointer
,	O
x	double
,	O
y	double
,	O
k1	int
,	O
k3	int
,	O
a	int
,	O
b	int
,	O
d	int
,	O
dx	int
,	O
dy	int
)	O
;	O
mask	int
=	O
info	pointer
.	O
initialMask	int
;	O
if	O
(	O
!	O
(	O
arc	pointer
->	O
width	array
&	O
1	int
)	O
)	O
{	O
DoPix	O
(	O
pts	array
,	O
mask	int
,	O
1	int
,	O
info	pointer
.	O
xorgo	int
,	O
info	pointer
.	O
yorg	int
)	O
;	O
DoPix	O
(	O
pts	array
,	O
mask	int
,	O
3	int
,	O
info	pointer
.	O
xorgo	int
,	O
info	pointer
.	O
yorgo	int
)	O
;	O
}	O
if	O
(	O
!	O
info	pointer
.	O
end	struct
.	O
x	double
||	O
!	O
info	pointer
.	O
end	struct
.	O
y	double
)	O
{	O
mask	int
=	O
info	pointer
.	O
end	struct
.	O
mask	int
;	O
info	pointer
.	O
end	struct
=	O
info	pointer
.	O
altend	struct
;	O
}	O
if	O
(	O
do360	enum
&&	O
(	O
arc	pointer
->	O
width	array
==	O
arc	pointer
->	O
height	int
)	O
&&	O
!	O
(	O
arc	pointer
->	O
width	array
&	O
1	int
)	O
)	O
{	O
int	O
yorgh	int
=	O
info	pointer
.	O
yorg	int
+	O
info	pointer
.	O
h	int
;	O
int	O
xorghp	int
=	O
info	pointer
.	O
xorg	int
+	O
info	pointer
.	O
h	int
;	O
int	O
xorghn	int
=	O
info	pointer
.	O
xorg	int
-	O
info	pointer
.	O
h	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
Pixelate	O
(	O
pts	array
,	O
info	pointer
.	O
xorg	int
+	O
x	double
,	O
info	pointer
.	O
yorg	int
+	O
y	double
)	O
;	O
Pixelate	O
(	O
pts	array
,	O
info	pointer
.	O
xorg	int
-	O
x	double
,	O
info	pointer
.	O
yorg	int
+	O
y	double
)	O
;	O
Pixelate	O
(	O
pts	array
,	O
info	pointer
.	O
xorg	int
-	O
x	double
,	O
info	pointer
.	O
yorgo	int
-	O
y	double
)	O
;	O
Pixelate	O
(	O
pts	array
,	O
info	pointer
.	O
xorg	int
+	O
x	double
,	O
info	pointer
.	O
yorgo	int
-	O
y	double
)	O
;	O
if	O
(	O
a	int
<	O
0	int
)	O
break	O
;	O
Pixelate	O
(	O
pts	array
,	O
xorghp	int
-	O
y	double
,	O
yorgh	int
-	O
x	double
)	O
;	O
Pixelate	O
(	O
pts	array
,	O
xorghn	int
+	O
y	double
,	O
yorgh	int
-	O
x	double
)	O
;	O
Pixelate	O
(	O
pts	array
,	O
xorghn	int
+	O
y	double
,	O
yorgh	int
+	O
x	double
)	O
;	O
Pixelate	O
(	O
pts	array
,	O
xorghp	int
-	O
y	double
,	O
yorgh	int
+	O
x	double
)	O
;	O
MIARCCIRCLESTEP	O
(	O
x	double
,	O
y	double
,	O
a	int
,	O
b	int
,	O
d	int
,	O
k1	int
,	O
k3	int
,	O
;	O
)	O
;	O
}	O
if	O
(	O
x	double
>	O
1	int
&&	O
pts	array
[	O
-	O
1	int
]	O
.	O
x	double
==	O
pts	array
[	O
-	O
5	int
]	O
.	O
x	double
&&	O
pts	array
[	O
-	O
1	int
]	O
.	O
y	double
==	O
pts	array
[	O
-	O
5	int
]	O
.	O
y	double
)	O
pts	array
-=	O
4	int
;	O
x	double
=	O
info	pointer
.	O
w	int
;	O
y	double
=	O
info	pointer
.	O
h	int
;	O
}	O
else	O
if	O
(	O
do360	enum
)	O
{	O
while	O
(	O
y	double
<	O
(	O
int	O
)	O
info	pointer
.	O
h	int
||	O
x	double
<	O
(	O
int	O
)	O
info	pointer
.	O
w	int
)	O
{	O
MIARCOCTANTSHIFT	O
(	O
info	pointer
,	O
x	double
,	O
y	double
,	O
dx	int
,	O
dy	int
,	O
a	int
,	O
b	int
,	O
d	int
,	O
k1	int
,	O
k3	int
,	O
;	O
)	O
;	O
Pixelate	O
(	O
pts	array
,	O
info	pointer
.	O
xorg	int
+	O
x	double
,	O
info	pointer
.	O
yorg	int
+	O
y	double
)	O
;	O
Pixelate	O
(	O
pts	array
,	O
info	pointer
.	O
xorgo	int
-	O
x	double
,	O
info	pointer
.	O
yorg	int
+	O
y	double
)	O
;	O
Pixelate	O
(	O
pts	array
,	O
info	pointer
.	O
xorgo	int
-	O
x	double
,	O
info	pointer
.	O
yorgo	int
-	O
y	double
)	O
;	O
Pixelate	O
(	O
pts	array
,	O
info	pointer
.	O
xorg	int
+	O
x	double
,	O
info	pointer
.	O
yorgo	int
-	O
y	double
)	O
;	O
MIARCSTEP	O
(	O
x	double
,	O
y	double
,	O
dx	int
,	O
dy	int
,	O
a	int
,	O
b	int
,	O
d	int
,	O
k1	int
,	O
k3	int
,	O
;	O
,	O
;	O
)	O
;	O
}	O
}	O
else	O
{	O
while	O
(	O
y	double
<	O
(	O
int	O
)	O
info	pointer
.	O
h	int
||	O
x	double
<	O
(	O
int	O
)	O
info	pointer
.	O
w	int
)	O
{	O
MIARCOCTANTSHIFT	O
(	O
info	pointer
,	O
x	double
,	O
y	double
,	O
dx	int
,	O
dy	int
,	O
a	int
,	O
b	int
,	O
d	int
,	O
k1	int
,	O
k3	int
,	O
;	O
)	O
;	O
if	O
(	O
(	O
x	double
==	O
info	pointer
.	O
start	struct
.	O
x	double
)	O
||	O
(	O
y	double
==	O
info	pointer
.	O
start	struct
.	O
y	double
)	O
)	O
{	O
mask	int
=	O
info	pointer
.	O
start	struct
.	O
mask	int
;	O
info	pointer
.	O
start	struct
=	O
info	pointer
.	O
altstart	struct
;	O
}	O
DoPix	O
(	O
pts	array
,	O
mask	int
,	O
0	int
,	O
info	pointer
.	O
xorg	int
+	O
x	double
,	O
info	pointer
.	O
yorg	int
+	O
y	double
)	O
;	O
DoPix	O
(	O
pts	array
,	O
mask	int
,	O
1	int
,	O
info	pointer
.	O
xorgo	int
-	O
x	double
,	O
info	pointer
.	O
yorg	int
+	O
y	double
)	O
;	O
DoPix	O
(	O
pts	array
,	O
mask	int
,	O
2	int
,	O
info	pointer
.	O
xorgo	int
-	O
x	double
,	O
info	pointer
.	O
yorgo	int
-	O
y	double
)	O
;	O
DoPix	O
(	O
pts	array
,	O
mask	int
,	O
3	int
,	O
info	pointer
.	O
xorg	int
+	O
x	double
,	O
info	pointer
.	O
yorgo	int
-	O
y	double
)	O
;	O
if	O
(	O
(	O
x	double
==	O
info	pointer
.	O
end	struct
.	O
x	double
)	O
||	O
(	O
y	double
==	O
info	pointer
.	O
end	struct
.	O
y	double
)	O
)	O
{	O
mask	int
=	O
info	pointer
.	O
end	struct
.	O
mask	int
;	O
info	pointer
.	O
end	struct
=	O
info	pointer
.	O
altend	struct
;	O
}	O
MIARCSTEP	O
(	O
x	double
,	O
y	double
,	O
dx	int
,	O
dy	int
,	O
a	int
,	O
b	int
,	O
d	int
,	O
k1	int
,	O
k3	int
,	O
;	O
,	O
;	O
)	O
;	O
}	O
}	O
if	O
(	O
(	O
x	double
==	O
info	pointer
.	O
start	struct
.	O
x	double
)	O
||	O
(	O
y	double
==	O
info	pointer
.	O
start	struct
.	O
y	double
)	O
)	O
mask	int
=	O
info	pointer
.	O
start	struct
.	O
mask	int
;	O
DoPix	O
(	O
pts	array
,	O
mask	int
,	O
0	int
,	O
info	pointer
.	O
xorg	int
+	O
x	double
,	O
info	pointer
.	O
yorg	int
+	O
y	double
)	O
;	O
DoPix	O
(	O
pts	array
,	O
mask	int
,	O
2	int
,	O
info	pointer
.	O
xorgo	int
-	O
x	double
,	O
info	pointer
.	O
yorgo	int
-	O
y	double
)	O
;	O
if	O
(	O
arc	pointer
->	O
height	int
&	O
1	int
)	O
{	O
DoPix	O
(	O
pts	array
,	O
mask	int
,	O
1	int
,	O
info	pointer
.	O
xorgo	int
-	O
x	double
,	O
info	pointer
.	O
yorg	int
+	O
y	double
)	O
;	O
DoPix	O
(	O
pts	array
,	O
mask	int
,	O
3	int
,	O
info	pointer
.	O
xorg	int
+	O
x	double
,	O
info	pointer
.	O
yorgo	int
-	O
y	double
)	O
;	O
}	O
return	O
pts	array
;	O
}	O
static	O
void	O
miZeroArcDashPts	function
(	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
const	O
miArc	struct
*	O
arc	pointer
,	O
miDashInfo	struct
*	O
dinfo	pointer
,	O
int	O
maxPts	int
,	O
miPoint	struct
*	O
*	O
pts	array
)	O
{	O
miZeroArc	struct
info	pointer
;	O
int	O
x	double
,	O
y	double
,	O
a	int
,	O
b	int
,	O
d	int
;	O
unsigned	O
int	O
mask	int
;	O
int	O
k1	int
,	O
k3	int
,	O
dx	int
,	O
dy	int
;	O
int	O
dashRemaining	int
,	O
numPixels	int
;	O
miPoint	struct
*	O
points	pointer
,	O
*	O
arcPts	array
[	O
4	int
]	O
;	O
miPoint	struct
*	O
startPts	array
[	O
5	int
]	O
,	O
*	O
endPts	array
[	O
5	int
]	O
;	O
int	O
deltas	array
[	O
5	int
]	O
;	O
miPoint	struct
*	O
pt	pointer
,	O
*	O
startPt	struct
,	O
*	O
lastPt	pointer
;	O
int	O
i	int
,	O
j	int
,	O
seg	int
,	O
startseg	int
;	O
points	pointer
=	O
(	O
miPoint	struct
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
miPoint	struct
)	O
*	O
4	int
*	O
maxPts	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
;	O
i	int
++	O
)	O
arcPts	array
[	O
i	int
]	O
=	O
points	pointer
+	O
(	O
i	int
*	O
maxPts	int
)	O
;	O
miZeroArcSetup	function
(	O
arc	pointer
,	O
&	O
info	pointer
,	O
false	int
)	O
;	O
MIARCSETUP	O
(	O
info	pointer
,	O
x	double
,	O
y	double
,	O
k1	int
,	O
k3	int
,	O
a	int
,	O
b	int
,	O
d	int
,	O
dx	int
,	O
dy	int
)	O
;	O
mask	int
=	O
info	pointer
.	O
initialMask	int
;	O
startseg	int
=	O
info	pointer
.	O
startAngle	int
/	O
QUADRANT	O
;	O
startPt	struct
=	O
arcPts	array
[	O
startseg	int
]	O
;	O
if	O
(	O
!	O
(	O
arc	pointer
->	O
width	array
&	O
1	int
)	O
)	O
{	O
DoPix	O
(	O
arcPts	array
,	O
mask	int
,	O
1	int
,	O
info	pointer
.	O
xorgo	int
,	O
info	pointer
.	O
yorg	int
)	O
;	O
DoPix	O
(	O
arcPts	array
,	O
mask	int
,	O
3	int
,	O
info	pointer
.	O
xorgo	int
,	O
info	pointer
.	O
yorgo	int
)	O
;	O
}	O
if	O
(	O
!	O
info	pointer
.	O
end	struct
.	O
x	double
||	O
!	O
info	pointer
.	O
end	struct
.	O
y	double
)	O
{	O
mask	int
=	O
info	pointer
.	O
end	struct
.	O
mask	int
;	O
info	pointer
.	O
end	struct
=	O
info	pointer
.	O
altend	struct
;	O
}	O
while	O
(	O
y	double
<	O
(	O
int	O
)	O
info	pointer
.	O
h	int
||	O
x	double
<	O
(	O
int	O
)	O
info	pointer
.	O
w	int
)	O
{	O
MIARCOCTANTSHIFT	O
(	O
info	pointer
,	O
x	double
,	O
y	double
,	O
dx	int
,	O
dy	int
,	O
a	int
,	O
b	int
,	O
d	int
,	O
k1	int
,	O
k3	int
,	O
;	O
)	O
;	O
if	O
(	O
(	O
x	double
==	O
info	pointer
.	O
firstx	int
)	O
||	O
(	O
y	double
==	O
info	pointer
.	O
firsty	int
)	O
)	O
startPt	struct
=	O
arcPts	array
[	O
startseg	int
]	O
;	O
if	O
(	O
(	O
x	double
==	O
info	pointer
.	O
start	struct
.	O
x	double
)	O
||	O
(	O
y	double
==	O
info	pointer
.	O
start	struct
.	O
y	double
)	O
)	O
{	O
mask	int
=	O
info	pointer
.	O
start	struct
.	O
mask	int
;	O
info	pointer
.	O
start	struct
=	O
info	pointer
.	O
altstart	struct
;	O
}	O
DoPix	O
(	O
arcPts	array
,	O
mask	int
,	O
0	int
,	O
info	pointer
.	O
xorg	int
+	O
x	double
,	O
info	pointer
.	O
yorg	int
+	O
y	double
)	O
;	O
DoPix	O
(	O
arcPts	array
,	O
mask	int
,	O
1	int
,	O
info	pointer
.	O
xorgo	int
-	O
x	double
,	O
info	pointer
.	O
yorg	int
+	O
y	double
)	O
;	O
DoPix	O
(	O
arcPts	array
,	O
mask	int
,	O
2	int
,	O
info	pointer
.	O
xorgo	int
-	O
x	double
,	O
info	pointer
.	O
yorgo	int
-	O
y	double
)	O
;	O
DoPix	O
(	O
arcPts	array
,	O
mask	int
,	O
3	int
,	O
info	pointer
.	O
xorg	int
+	O
x	double
,	O
info	pointer
.	O
yorgo	int
-	O
y	double
)	O
;	O
if	O
(	O
(	O
x	double
==	O
info	pointer
.	O
end	struct
.	O
x	double
)	O
||	O
(	O
y	double
==	O
info	pointer
.	O
end	struct
.	O
y	double
)	O
)	O
{	O
mask	int
=	O
info	pointer
.	O
end	struct
.	O
mask	int
;	O
info	pointer
.	O
end	struct
=	O
info	pointer
.	O
altend	struct
;	O
}	O
MIARCSTEP	O
(	O
x	double
,	O
y	double
,	O
dx	int
,	O
dy	int
,	O
a	int
,	O
b	int
,	O
d	int
,	O
k1	int
,	O
k3	int
,	O
;	O
,	O
;	O
)	O
;	O
}	O
if	O
(	O
(	O
x	double
==	O
info	pointer
.	O
firstx	int
)	O
||	O
(	O
y	double
==	O
info	pointer
.	O
firsty	int
)	O
)	O
startPt	struct
=	O
arcPts	array
[	O
startseg	int
]	O
;	O
if	O
(	O
(	O
x	double
==	O
info	pointer
.	O
start	struct
.	O
x	double
)	O
||	O
(	O
y	double
==	O
info	pointer
.	O
start	struct
.	O
y	double
)	O
)	O
mask	int
=	O
info	pointer
.	O
start	struct
.	O
mask	int
;	O
DoPix	O
(	O
arcPts	array
,	O
mask	int
,	O
0	int
,	O
info	pointer
.	O
xorg	int
+	O
x	double
,	O
info	pointer
.	O
yorg	int
+	O
y	double
)	O
;	O
DoPix	O
(	O
arcPts	array
,	O
mask	int
,	O
2	int
,	O
info	pointer
.	O
xorgo	int
-	O
x	double
,	O
info	pointer
.	O
yorgo	int
-	O
y	double
)	O
;	O
if	O
(	O
arc	pointer
->	O
height	int
&	O
1	int
)	O
{	O
DoPix	O
(	O
arcPts	array
,	O
mask	int
,	O
1	int
,	O
info	pointer
.	O
xorgo	int
-	O
x	double
,	O
info	pointer
.	O
yorg	int
+	O
y	double
)	O
;	O
DoPix	O
(	O
arcPts	array
,	O
mask	int
,	O
3	int
,	O
info	pointer
.	O
xorg	int
+	O
x	double
,	O
info	pointer
.	O
yorgo	int
-	O
y	double
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
;	O
i	int
++	O
)	O
{	O
seg	int
=	O
(	O
startseg	int
+	O
i	int
)	O
&	O
3	int
;	O
pt	pointer
=	O
points	pointer
+	O
(	O
seg	int
*	O
maxPts	int
)	O
;	O
if	O
(	O
seg	int
&	O
1	int
)	O
{	O
startPts	array
[	O
i	int
]	O
=	O
pt	pointer
;	O
endPts	array
[	O
i	int
]	O
=	O
arcPts	array
[	O
seg	int
]	O
;	O
deltas	array
[	O
i	int
]	O
=	O
1	int
;	O
}	O
else	O
{	O
startPts	array
[	O
i	int
]	O
=	O
arcPts	array
[	O
seg	int
]	O
-	O
1	int
;	O
endPts	array
[	O
i	int
]	O
=	O
pt	pointer
-	O
1	int
;	O
deltas	array
[	O
i	int
]	O
=	O
-	O
1	int
;	O
}	O
}	O
startPts	array
[	O
4	int
]	O
=	O
startPts	array
[	O
0	int
]	O
;	O
endPts	array
[	O
4	int
]	O
=	O
startPt	struct
;	O
startPts	array
[	O
0	int
]	O
=	O
startPt	struct
;	O
if	O
(	O
startseg	int
&	O
1	int
)	O
{	O
if	O
(	O
startPts	array
[	O
4	int
]	O
!=	O
endPts	array
[	O
4	int
]	O
)	O
endPts	array
[	O
4	int
]	O
--	O
;	O
deltas	array
[	O
4	int
]	O
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
startPts	array
[	O
0	int
]	O
>	O
startPts	array
[	O
4	int
]	O
)	O
startPts	array
[	O
0	int
]	O
--	O
;	O
if	O
(	O
startPts	array
[	O
4	int
]	O
<	O
endPts	array
[	O
4	int
]	O
)	O
endPts	array
[	O
4	int
]	O
--	O
;	O
deltas	array
[	O
4	int
]	O
=	O
-	O
1	int
;	O
}	O
if	O
(	O
arc	pointer
->	O
angle2	int
<	O
0	int
)	O
{	O
miPoint	struct
*	O
tmps	pointer
,	O
*	O
tmpe	pointer
;	O
int	O
tmpd	int
;	O
tmpd	int
=	O
deltas	array
[	O
0	int
]	O
;	O
tmps	pointer
=	O
startPts	array
[	O
0	int
]	O
-	O
tmpd	int
;	O
tmpe	pointer
=	O
endPts	array
[	O
0	int
]	O
-	O
tmpd	int
;	O
startPts	array
[	O
0	int
]	O
=	O
endPts	array
[	O
4	int
]	O
-	O
deltas	array
[	O
4	int
]	O
;	O
endPts	array
[	O
0	int
]	O
=	O
startPts	array
[	O
4	int
]	O
-	O
deltas	array
[	O
4	int
]	O
;	O
deltas	array
[	O
0	int
]	O
=	O
-	O
deltas	array
[	O
4	int
]	O
;	O
startPts	array
[	O
4	int
]	O
=	O
tmpe	pointer
;	O
endPts	array
[	O
4	int
]	O
=	O
tmps	pointer
;	O
deltas	array
[	O
4	int
]	O
=	O
-	O
tmpd	int
;	O
tmpd	int
=	O
deltas	array
[	O
1	int
]	O
;	O
tmps	pointer
=	O
startPts	array
[	O
1	int
]	O
-	O
tmpd	int
;	O
tmpe	pointer
=	O
endPts	array
[	O
1	int
]	O
-	O
tmpd	int
;	O
startPts	array
[	O
1	int
]	O
=	O
endPts	array
[	O
3	int
]	O
-	O
deltas	array
[	O
3	int
]	O
;	O
endPts	array
[	O
1	int
]	O
=	O
startPts	array
[	O
3	int
]	O
-	O
deltas	array
[	O
3	int
]	O
;	O
deltas	array
[	O
1	int
]	O
=	O
-	O
deltas	array
[	O
3	int
]	O
;	O
startPts	array
[	O
3	int
]	O
=	O
tmpe	pointer
;	O
endPts	array
[	O
3	int
]	O
=	O
tmps	pointer
;	O
deltas	array
[	O
3	int
]	O
=	O
-	O
tmpd	int
;	O
tmps	pointer
=	O
startPts	array
[	O
2	int
]	O
-	O
deltas	array
[	O
2	int
]	O
;	O
startPts	array
[	O
2	int
]	O
=	O
endPts	array
[	O
2	int
]	O
-	O
deltas	array
[	O
2	int
]	O
;	O
endPts	array
[	O
2	int
]	O
=	O
tmps	pointer
;	O
deltas	array
[	O
2	int
]	O
=	O
-	O
deltas	array
[	O
2	int
]	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
5	int
&&	O
startPts	array
[	O
i	int
]	O
==	O
endPts	array
[	O
i	int
]	O
;	O
i	int
++	O
)	O
;	O
if	O
(	O
i	int
==	O
5	int
)	O
return	O
;	O
pt	pointer
=	O
startPts	array
[	O
i	int
]	O
;	O
for	O
(	O
j	int
=	O
4	int
;	O
startPts	array
[	O
j	int
]	O
==	O
endPts	array
[	O
j	int
]	O
;	O
j	int
--	O
)	O
;	O
lastPt	pointer
=	O
endPts	array
[	O
j	int
]	O
-	O
deltas	array
[	O
j	int
]	O
;	O
if	O
(	O
dinfo	pointer
->	O
haveLast	enum
&&	O
(	O
pt	pointer
->	O
x	double
==	O
dinfo	pointer
->	O
endPt	struct
.	O
x	double
)	O
&&	O
(	O
pt	pointer
->	O
y	double
==	O
dinfo	pointer
->	O
endPt	struct
.	O
y	double
)	O
)	O
startPts	array
[	O
i	int
]	O
+=	O
deltas	array
[	O
i	int
]	O
;	O
else	O
{	O
dinfo	pointer
->	O
dashNum	int
=	O
dinfo	pointer
->	O
dashNumInit	int
;	O
dinfo	pointer
->	O
dashIndex	int
=	O
dinfo	pointer
->	O
dashIndexInit	int
;	O
dinfo	pointer
->	O
dashOffset	int
=	O
dinfo	pointer
->	O
dashOffsetInit	int
;	O
}	O
if	O
(	O
!	O
dinfo	pointer
->	O
skipStart	enum
&&	O
(	O
info	pointer
.	O
startAngle	int
!=	O
info	pointer
.	O
endAngle	int
)	O
)	O
{	O
dinfo	pointer
->	O
startPt	struct
=	O
*	O
pt	pointer
;	O
dinfo	pointer
->	O
haveStart	enum
=	O
true	int
;	O
}	O
else	O
if	O
(	O
!	O
dinfo	pointer
->	O
skipLast	enum
&&	O
dinfo	pointer
->	O
haveStart	enum
&&	O
(	O
lastPt	pointer
->	O
x	double
==	O
dinfo	pointer
->	O
startPt	struct
.	O
x	double
)	O
&&	O
(	O
lastPt	pointer
->	O
y	double
==	O
dinfo	pointer
->	O
startPt	struct
.	O
y	double
)	O
&&	O
(	O
lastPt	pointer
!=	O
startPts	array
[	O
i	int
]	O
)	O
)	O
endPts	array
[	O
j	int
]	O
=	O
lastPt	pointer
;	O
if	O
(	O
info	pointer
.	O
startAngle	int
!=	O
info	pointer
.	O
endAngle	int
)	O
{	O
dinfo	pointer
->	O
haveLast	enum
=	O
true	int
;	O
dinfo	pointer
->	O
endPt	struct
=	O
*	O
lastPt	pointer
;	O
}	O
dashRemaining	int
=	O
(	O
int	O
)	O
pGC	pointer
->	O
dash	pointer
[	O
dinfo	pointer
->	O
dashIndex	int
]	O
-	O
dinfo	pointer
->	O
dashOffset	int
;	O
numPixels	int
=	O
pGC	pointer
->	O
numPixels	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
5	int
;	O
i	int
++	O
)	O
{	O
int	O
delta	int
;	O
pt	pointer
=	O
startPts	array
[	O
i	int
]	O
;	O
lastPt	pointer
=	O
endPts	array
[	O
i	int
]	O
;	O
delta	int
=	O
deltas	array
[	O
i	int
]	O
;	O
while	O
(	O
pt	pointer
!=	O
lastPt	pointer
)	O
{	O
int	O
dashNum	int
,	O
paintType	int
;	O
dashNum	int
=	O
dinfo	pointer
->	O
dashNum	int
;	O
paintType	int
=	O
(	O
dashNum	int
&	O
1	int
)	O
?	O
0	int
:	O
1	int
+	O
(	O
(	O
dashNum	int
/	O
2	int
)	O
%	O
(	O
numPixels	int
-	O
1	int
)	O
)	O
;	O
while	O
(	O
(	O
pt	pointer
!=	O
lastPt	pointer
)	O
&&	O
--	O
dashRemaining	int
>=	O
0	int
)	O
{	O
*	O
(	O
pts	array
[	O
paintType	int
]	O
++	O
)	O
=	O
*	O
pt	pointer
;	O
pt	pointer
+=	O
delta	int
;	O
}	O
if	O
(	O
dashRemaining	int
<=	O
0	int
)	O
{	O
++	O
(	O
dinfo	pointer
->	O
dashNum	int
)	O
;	O
if	O
(	O
++	O
(	O
dinfo	pointer
->	O
dashIndex	int
)	O
==	O
pGC	pointer
->	O
numInDashList	int
)	O
dinfo	pointer
->	O
dashIndex	int
=	O
0	int
;	O
dashRemaining	int
=	O
(	O
int	O
)	O
pGC	pointer
->	O
dash	pointer
[	O
dinfo	pointer
->	O
dashIndex	int
]	O
;	O
}	O
}	O
}	O
dinfo	pointer
->	O
dashOffset	int
=	O
(	O
int	O
)	O
pGC	pointer
->	O
dash	pointer
[	O
dinfo	pointer
->	O
dashIndex	int
]	O
-	O
dashRemaining	int
;	O
free	function
(	O
points	pointer
)	O
;	O
}	O
static	O
bool	enum
miZeroArcSetup	function
(	O
const	O
miArc	struct
*	O
arc	pointer
,	O
miZeroArc	struct
*	O
info	pointer
,	O
bool	enum
ok360	enum
)	O
{	O
int	O
l	int
,	O
i	int
;	O
int	O
angle1	int
,	O
angle2	int
;	O
int	O
startseg	int
,	O
endseg	int
;	O
int	O
startAngle	int
,	O
endAngle	int
;	O
miZeroArcPt	struct
start	struct
,	O
end	struct
;	O
bool	enum
overlap	enum
;	O
l	int
=	O
arc	pointer
->	O
width	array
&	O
1	int
;	O
if	O
(	O
arc	pointer
->	O
width	array
==	O
arc	pointer
->	O
height	int
)	O
{	O
info	pointer
->	O
alpha	int
=	O
4	int
;	O
info	pointer
->	O
beta	int
=	O
4	int
;	O
info	pointer
->	O
k1	int
=	O
-	O
8	int
;	O
info	pointer
->	O
k3	int
=	O
-	O
16	int
;	O
info	pointer
->	O
b	int
=	O
12	int
;	O
info	pointer
->	O
a	int
=	O
(	O
arc	pointer
->	O
width	array
<<	O
2	int
)	O
-	O
12	int
;	O
info	pointer
->	O
d	int
=	O
17	int
-	O
(	O
arc	pointer
->	O
width	array
<<	O
1	int
)	O
;	O
if	O
(	O
l	int
)	O
{	O
info	pointer
->	O
b	int
-=	O
4	int
;	O
info	pointer
->	O
a	int
+=	O
4	int
;	O
info	pointer
->	O
d	int
-=	O
7	int
;	O
}	O
}	O
else	O
if	O
(	O
arc	pointer
->	O
width	array
==	O
0	int
||	O
arc	pointer
->	O
height	int
==	O
0	int
)	O
{	O
info	pointer
->	O
alpha	int
=	O
0	int
;	O
info	pointer
->	O
beta	int
=	O
0	int
;	O
info	pointer
->	O
k1	int
=	O
0	int
;	O
info	pointer
->	O
k3	int
=	O
0	int
;	O
info	pointer
->	O
a	int
=	O
-	O
(	O
int	O
)	O
arc	pointer
->	O
height	int
;	O
info	pointer
->	O
b	int
=	O
0	int
;	O
info	pointer
->	O
d	int
=	O
-	O
1	int
;	O
}	O
else	O
{	O
info	pointer
->	O
alpha	int
=	O
(	O
arc	pointer
->	O
width	array
*	O
arc	pointer
->	O
width	array
)	O
<<	O
2	int
;	O
info	pointer
->	O
beta	int
=	O
(	O
arc	pointer
->	O
height	int
*	O
arc	pointer
->	O
height	int
)	O
<<	O
2	int
;	O
info	pointer
->	O
k1	int
=	O
info	pointer
->	O
beta	int
<<	O
1	int
;	O
info	pointer
->	O
k3	int
=	O
info	pointer
->	O
k1	int
+	O
(	O
info	pointer
->	O
alpha	int
<<	O
1	int
)	O
;	O
info	pointer
->	O
b	int
=	O
l	int
?	O
0	int
:	O
-	O
info	pointer
->	O
beta	int
;	O
info	pointer
->	O
a	int
=	O
info	pointer
->	O
alpha	int
*	O
arc	pointer
->	O
height	int
;	O
info	pointer
->	O
d	int
=	O
info	pointer
->	O
b	int
-	O
(	O
info	pointer
->	O
a	int
>>	O
1	int
)	O
-	O
(	O
info	pointer
->	O
alpha	int
>>	O
2	int
)	O
;	O
if	O
(	O
l	int
)	O
info	pointer
->	O
d	int
-=	O
info	pointer
->	O
beta	int
>>	O
2	int
;	O
info	pointer
->	O
a	int
-=	O
info	pointer
->	O
b	int
;	O
info	pointer
->	O
b	int
-=	O
info	pointer
->	O
k1	int
;	O
info	pointer
->	O
a	int
+=	O
info	pointer
->	O
k1	int
;	O
info	pointer
->	O
d	int
+=	O
info	pointer
->	O
b	int
;	O
info	pointer
->	O
k1	int
=	O
-	O
info	pointer
->	O
k1	int
;	O
info	pointer
->	O
k3	int
=	O
-	O
info	pointer
->	O
k3	int
;	O
info	pointer
->	O
b	int
=	O
-	O
info	pointer
->	O
b	int
;	O
info	pointer
->	O
d	int
=	O
info	pointer
->	O
b	int
-	O
info	pointer
->	O
a	int
-	O
info	pointer
->	O
d	int
;	O
info	pointer
->	O
a	int
=	O
info	pointer
->	O
a	int
-	O
(	O
info	pointer
->	O
b	int
<<	O
1	int
)	O
;	O
}	O
info	pointer
->	O
dx	int
=	O
1	int
;	O
info	pointer
->	O
dy	int
=	O
0	int
;	O
info	pointer
->	O
w	int
=	O
(	O
arc	pointer
->	O
width	array
+	O
1	int
)	O
>>	O
1	int
;	O
info	pointer
->	O
h	int
=	O
arc	pointer
->	O
height	int
>>	O
1	int
;	O
info	pointer
->	O
xorg	int
=	O
arc	pointer
->	O
x	double
+	O
(	O
arc	pointer
->	O
width	array
>>	O
1	int
)	O
;	O
info	pointer
->	O
yorg	int
=	O
arc	pointer
->	O
y	double
;	O
info	pointer
->	O
xorgo	int
=	O
info	pointer
->	O
xorg	int
+	O
l	int
;	O
info	pointer
->	O
yorgo	int
=	O
info	pointer
->	O
yorg	int
+	O
arc	pointer
->	O
height	int
;	O
if	O
(	O
arc	pointer
->	O
width	array
==	O
0	int
)	O
{	O
if	O
(	O
arc	pointer
->	O
height	int
==	O
0	int
)	O
{	O
info	pointer
->	O
x	double
=	O
0	int
;	O
info	pointer
->	O
y	double
=	O
0	int
;	O
info	pointer
->	O
initialMask	int
=	O
0	int
;	O
info	pointer
->	O
startAngle	int
=	O
0	int
;	O
info	pointer
->	O
endAngle	int
=	O
0	int
;	O
info	pointer
->	O
start	struct
=	O
_oob_arc_pt	struct
;	O
info	pointer
->	O
end	struct
=	O
_oob_arc_pt	struct
;	O
return	O
false	int
;	O
}	O
info	pointer
->	O
x	double
=	O
0	int
;	O
info	pointer
->	O
y	double
=	O
1	int
;	O
}	O
else	O
{	O
info	pointer
->	O
x	double
=	O
1	int
;	O
info	pointer
->	O
y	double
=	O
0	int
;	O
}	O
angle1	int
=	O
arc	pointer
->	O
angle1	int
;	O
angle2	int
=	O
arc	pointer
->	O
angle2	int
;	O
if	O
(	O
(	O
angle1	int
==	O
0	int
)	O
&&	O
(	O
angle2	int
>=	O
FULLCIRCLE	O
)	O
)	O
{	O
startAngle	int
=	O
0	int
;	O
endAngle	int
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
angle2	int
>	O
FULLCIRCLE	O
)	O
angle2	int
=	O
FULLCIRCLE	O
;	O
else	O
if	O
(	O
angle2	int
<	O
-	O
FULLCIRCLE	O
)	O
angle2	int
=	O
-	O
FULLCIRCLE	O
;	O
if	O
(	O
angle2	int
<	O
0	int
)	O
{	O
startAngle	int
=	O
angle1	int
+	O
angle2	int
;	O
endAngle	int
=	O
angle1	int
;	O
}	O
else	O
{	O
startAngle	int
=	O
angle1	int
;	O
endAngle	int
=	O
angle1	int
+	O
angle2	int
;	O
}	O
if	O
(	O
startAngle	int
<	O
0	int
)	O
startAngle	int
=	O
FULLCIRCLE	O
-	O
(	O
-	O
startAngle	int
)	O
%	O
FULLCIRCLE	O
;	O
if	O
(	O
startAngle	int
>=	O
FULLCIRCLE	O
)	O
startAngle	int
=	O
startAngle	int
%	O
FULLCIRCLE	O
;	O
if	O
(	O
endAngle	int
<	O
0	int
)	O
endAngle	int
=	O
FULLCIRCLE	O
-	O
(	O
-	O
endAngle	int
)	O
%	O
FULLCIRCLE	O
;	O
if	O
(	O
endAngle	int
>=	O
FULLCIRCLE	O
)	O
endAngle	int
=	O
endAngle	int
%	O
FULLCIRCLE	O
;	O
}	O
info	pointer
->	O
startAngle	int
=	O
startAngle	int
;	O
info	pointer
->	O
endAngle	int
=	O
endAngle	int
;	O
if	O
(	O
ok360	enum
&&	O
(	O
startAngle	int
==	O
endAngle	int
)	O
&&	O
arc	pointer
->	O
angle2	int
&&	O
arc	pointer
->	O
width	array
&&	O
arc	pointer
->	O
height	int
)	O
{	O
info	pointer
->	O
initialMask	int
=	O
0xf	int
;	O
info	pointer
->	O
start	struct
=	O
_oob_arc_pt	struct
;	O
info	pointer
->	O
end	struct
=	O
_oob_arc_pt	struct
;	O
return	O
true	int
;	O
}	O
startseg	int
=	O
startAngle	int
/	O
OCTANT	O
;	O
if	O
(	O
!	O
arc	pointer
->	O
height	int
||	O
(	O
(	O
(	O
startseg	int
+	O
1	int
)	O
&	O
2	int
)	O
&&	O
arc	pointer
->	O
width	array
)	O
)	O
{	O
start	struct
.	O
x	double
=	O
(	O
int	O
)	O
(	O
Dcos	O
(	O
startAngle	int
)	O
*	O
(	O
(	O
arc	pointer
->	O
width	array
+	O
1	int
)	O
/	O
2.0	int
)	O
)	O
;	O
if	O
(	O
start	struct
.	O
x	double
<	O
0	int
)	O
start	struct
.	O
x	double
=	O
-	O
start	struct
.	O
x	double
;	O
start	struct
.	O
y	double
=	O
-	O
1	int
;	O
}	O
else	O
{	O
start	struct
.	O
y	double
=	O
(	O
int	O
)	O
(	O
Dsin	O
(	O
startAngle	int
)	O
*	O
(	O
arc	pointer
->	O
height	int
/	O
2.0	int
)	O
)	O
;	O
if	O
(	O
start	struct
.	O
y	double
<	O
0	int
)	O
start	struct
.	O
y	double
=	O
-	O
start	struct
.	O
y	double
;	O
start	struct
.	O
y	double
=	O
info	pointer
->	O
h	int
-	O
start	struct
.	O
y	double
;	O
start	struct
.	O
x	double
=	O
INT_MAX	O
;	O
}	O
endseg	int
=	O
endAngle	int
/	O
OCTANT	O
;	O
if	O
(	O
!	O
arc	pointer
->	O
height	int
||	O
(	O
(	O
(	O
endseg	int
+	O
1	int
)	O
&	O
2	int
)	O
&&	O
arc	pointer
->	O
width	array
)	O
)	O
{	O
end	struct
.	O
x	double
=	O
(	O
int	O
)	O
(	O
Dcos	O
(	O
endAngle	int
)	O
*	O
(	O
(	O
arc	pointer
->	O
width	array
+	O
1	int
)	O
/	O
2.0	int
)	O
)	O
;	O
if	O
(	O
end	struct
.	O
x	double
<	O
0	int
)	O
end	struct
.	O
x	double
=	O
-	O
end	struct
.	O
x	double
;	O
end	struct
.	O
y	double
=	O
-	O
1	int
;	O
}	O
else	O
{	O
end	struct
.	O
y	double
=	O
(	O
int	O
)	O
(	O
Dsin	O
(	O
endAngle	int
)	O
*	O
(	O
arc	pointer
->	O
height	int
/	O
2.0	int
)	O
)	O
;	O
if	O
(	O
end	struct
.	O
y	double
<	O
0	int
)	O
end	struct
.	O
y	double
=	O
-	O
end	struct
.	O
y	double
;	O
end	struct
.	O
y	double
=	O
info	pointer
->	O
h	int
-	O
end	struct
.	O
y	double
;	O
end	struct
.	O
x	double
=	O
INT_MAX	O
;	O
}	O
info	pointer
->	O
firstx	int
=	O
start	struct
.	O
x	double
;	O
info	pointer
->	O
firsty	int
=	O
start	struct
.	O
y	double
;	O
info	pointer
->	O
initialMask	int
=	O
0	int
;	O
overlap	enum
=	O
(	O
(	O
arc	pointer
->	O
angle2	int
!=	O
0	int
)	O
&&	O
(	O
endAngle	int
<=	O
startAngle	int
)	O
)	O
?	O
true	int
:	O
false	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
overlap	enum
?	O
(	O
(	O
i	int
*	O
QUADRANT	O
<=	O
endAngle	int
)	O
||	O
(	O
(	O
i	int
+	O
1	int
)	O
*	O
QUADRANT	O
>	O
startAngle	int
)	O
)	O
:	O
(	O
(	O
i	int
*	O
QUADRANT	O
<=	O
endAngle	int
)	O
&&	O
(	O
(	O
i	int
+	O
1	int
)	O
*	O
QUADRANT	O
>	O
startAngle	int
)	O
)	O
)	O
info	pointer
->	O
initialMask	int
|=	O
(	O
1	int
<<	O
i	int
)	O
;	O
}	O
start	struct
.	O
mask	int
=	O
info	pointer
->	O
initialMask	int
;	O
end	struct
.	O
mask	int
=	O
info	pointer
->	O
initialMask	int
;	O
startseg	int
>>=	O
1	int
;	O
endseg	int
>>=	O
1	int
;	O
overlap	enum
=	O
(	O
overlap	enum
&&	O
(	O
endseg	int
==	O
startseg	int
)	O
)	O
?	O
true	int
:	O
false	int
;	O
if	O
(	O
start	struct
.	O
x	double
!=	O
end	struct
.	O
x	double
||	O
start	struct
.	O
y	double
!=	O
end	struct
.	O
y	double
||	O
!	O
overlap	enum
)	O
{	O
if	O
(	O
startseg	int
&	O
1	int
)	O
{	O
if	O
(	O
!	O
overlap	enum
)	O
info	pointer
->	O
initialMask	int
&=	O
~	O
(	O
1	int
<<	O
startseg	int
)	O
;	O
if	O
(	O
start	struct
.	O
x	double
>	O
end	struct
.	O
x	double
||	O
start	struct
.	O
y	double
>	O
end	struct
.	O
y	double
)	O
end	struct
.	O
mask	int
&=	O
~	O
(	O
1	int
<<	O
startseg	int
)	O
;	O
}	O
else	O
{	O
start	struct
.	O
mask	int
&=	O
~	O
(	O
1	int
<<	O
startseg	int
)	O
;	O
if	O
(	O
(	O
(	O
start	struct
.	O
x	double
<	O
end	struct
.	O
x	double
||	O
start	struct
.	O
y	double
<	O
end	struct
.	O
y	double
)	O
||	O
(	O
start	struct
.	O
x	double
==	O
end	struct
.	O
x	double
&&	O
start	struct
.	O
y	double
==	O
end	struct
.	O
y	double
&&	O
(	O
endseg	int
&	O
1	int
)	O
)	O
)	O
&&	O
!	O
overlap	enum
)	O
end	struct
.	O
mask	int
&=	O
~	O
(	O
1	int
<<	O
startseg	int
)	O
;	O
}	O
if	O
(	O
endseg	int
&	O
1	int
)	O
{	O
end	struct
.	O
mask	int
&=	O
~	O
(	O
1	int
<<	O
endseg	int
)	O
;	O
if	O
(	O
(	O
(	O
start	struct
.	O
x	double
>	O
end	struct
.	O
x	double
||	O
start	struct
.	O
y	double
>	O
end	struct
.	O
y	double
)	O
||	O
(	O
start	struct
.	O
x	double
==	O
end	struct
.	O
x	double
&&	O
start	struct
.	O
y	double
==	O
end	struct
.	O
y	double
&&	O
!	O
(	O
startseg	int
&	O
1	int
)	O
)	O
)	O
&&	O
!	O
overlap	enum
)	O
start	struct
.	O
mask	int
&=	O
~	O
(	O
1	int
<<	O
endseg	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
overlap	enum
)	O
info	pointer
->	O
initialMask	int
&=	O
~	O
(	O
1	int
<<	O
endseg	int
)	O
;	O
if	O
(	O
start	struct
.	O
x	double
<	O
end	struct
.	O
x	double
||	O
start	struct
.	O
y	double
<	O
end	struct
.	O
y	double
)	O
start	struct
.	O
mask	int
&=	O
~	O
(	O
1	int
<<	O
endseg	int
)	O
;	O
}	O
}	O
if	O
(	O
startAngle	int
&&	O
(	O
(	O
start	struct
.	O
y	double
<	O
0	int
&&	O
end	struct
.	O
y	double
>=	O
0	int
)	O
||	O
(	O
start	struct
.	O
y	double
>=	O
0	int
&&	O
end	struct
.	O
y	double
<	O
0	int
)	O
)	O
)	O
{	O
i	int
=	O
(	O
startAngle	int
+	O
OCTANT	O
)	O
%	O
OCTANT	O
;	O
if	O
(	O
i	int
<	O
EPSILON45	int
||	O
i	int
>	O
OCTANT	O
-	O
EPSILON45	int
)	O
{	O
i	int
=	O
(	O
endAngle	int
+	O
OCTANT	O
)	O
%	O
OCTANT	O
;	O
if	O
(	O
i	int
<	O
EPSILON45	int
||	O
i	int
>	O
OCTANT	O
-	O
EPSILON45	int
)	O
{	O
if	O
(	O
start	struct
.	O
y	double
<	O
0	int
)	O
{	O
i	int
=	O
(	O
int	O
)	O
(	O
Dsin	O
(	O
startAngle	int
)	O
*	O
(	O
arc	pointer
->	O
height	int
/	O
2.0	int
)	O
)	O
;	O
if	O
(	O
i	int
<	O
0	int
)	O
i	int
=	O
-	O
i	int
;	O
if	O
(	O
(	O
int	O
)	O
info	pointer
->	O
h	int
-	O
i	int
==	O
end	struct
.	O
y	double
)	O
start	struct
.	O
mask	int
=	O
end	struct
.	O
mask	int
;	O
}	O
else	O
{	O
i	int
=	O
(	O
int	O
)	O
(	O
Dsin	O
(	O
endAngle	int
)	O
*	O
(	O
arc	pointer
->	O
height	int
/	O
2.0	int
)	O
)	O
;	O
if	O
(	O
i	int
<	O
0	int
)	O
i	int
=	O
-	O
i	int
;	O
if	O
(	O
(	O
int	O
)	O
info	pointer
->	O
h	int
-	O
i	int
==	O
start	struct
.	O
y	double
)	O
end	struct
.	O
mask	int
=	O
start	struct
.	O
mask	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
startseg	int
&	O
1	int
)	O
{	O
info	pointer
->	O
start	struct
=	O
start	struct
;	O
info	pointer
->	O
end	struct
=	O
_oob_arc_pt	struct
;	O
}	O
else	O
{	O
info	pointer
->	O
end	struct
=	O
start	struct
;	O
info	pointer
->	O
start	struct
=	O
_oob_arc_pt	struct
;	O
}	O
if	O
(	O
endseg	int
&	O
1	int
)	O
{	O
info	pointer
->	O
altend	struct
=	O
end	struct
;	O
if	O
(	O
info	pointer
->	O
altend	struct
.	O
x	double
<	O
info	pointer
->	O
end	struct
.	O
x	double
||	O
info	pointer
->	O
altend	struct
.	O
y	double
<	O
info	pointer
->	O
end	struct
.	O
y	double
)	O
{	O
miZeroArcPt	struct
tmp	struct
;	O
tmp	struct
=	O
info	pointer
->	O
altend	struct
;	O
info	pointer
->	O
altend	struct
=	O
info	pointer
->	O
end	struct
;	O
info	pointer
->	O
end	struct
=	O
tmp	struct
;	O
}	O
info	pointer
->	O
altstart	struct
=	O
_oob_arc_pt	struct
;	O
}	O
else	O
{	O
info	pointer
->	O
altstart	struct
=	O
end	struct
;	O
if	O
(	O
info	pointer
->	O
altstart	struct
.	O
x	double
<	O
info	pointer
->	O
start	struct
.	O
x	double
||	O
info	pointer
->	O
altstart	struct
.	O
y	double
<	O
info	pointer
->	O
start	struct
.	O
y	double
)	O
{	O
miZeroArcPt	struct
tmp	struct
;	O
tmp	struct
=	O
info	pointer
->	O
altstart	struct
;	O
info	pointer
->	O
altstart	struct
=	O
info	pointer
->	O
start	struct
;	O
info	pointer
->	O
start	struct
=	O
tmp	struct
;	O
}	O
info	pointer
->	O
altend	struct
=	O
_oob_arc_pt	struct
;	O
}	O
if	O
(	O
!	O
info	pointer
->	O
start	struct
.	O
x	double
||	O
!	O
info	pointer
->	O
start	struct
.	O
y	double
)	O
{	O
info	pointer
->	O
initialMask	int
=	O
info	pointer
->	O
start	struct
.	O
mask	int
;	O
info	pointer
->	O
start	struct
=	O
info	pointer
->	O
altstart	struct
;	O
}	O
if	O
(	O
!	O
arc	pointer
->	O
width	array
&&	O
(	O
arc	pointer
->	O
height	int
==	O
1	int
)	O
)	O
{	O
info	pointer
->	O
initialMask	int
|=	O
info	pointer
->	O
end	struct
.	O
mask	int
;	O
info	pointer
->	O
initialMask	int
|=	O
info	pointer
->	O
initialMask	int
<<	O
1	int
;	O
info	pointer
->	O
end	struct
.	O
x	double
=	O
0	int
;	O
info	pointer
->	O
end	struct
.	O
mask	int
=	O
0	int
;	O
}	O
return	O
false	int
;	O
}	O
