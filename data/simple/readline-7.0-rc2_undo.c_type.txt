extern	O
void	O
_hs_replace_history_data	function
PARAMS	O
(	O
(	O
int	O
,	O
histdata_t	pointer
*	O
,	O
histdata_t	pointer
*	O
)	O
)	O
;	O
int	O
_rl_doing_an_undo	int
=	O
0	int
;	O
int	O
_rl_undo_group_level	int
=	O
0	int
;	O
UNDO_LIST	struct
*	O
rl_undo_list	pointer
=	O
(	O
UNDO_LIST	struct
*	O
)	O
NULL	O
;	O
static	O
UNDO_LIST	struct
*	O
alloc_undo_entry	function
(	O
what	enum
,	O
start	int
,	O
end	int
,	O
text	pointer
)	O
enum	O
undo_code	enum
what	enum
;	O
int	O
start	int
,	O
end	int
;	O
char	O
*	O
text	pointer
;	O
{	O
UNDO_LIST	struct
*	O
temp	pointer
;	O
temp	pointer
=	O
(	O
UNDO_LIST	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
UNDO_LIST	struct
)	O
)	O
;	O
temp	pointer
->	O
what	enum
=	O
what	enum
;	O
temp	pointer
->	O
start	int
=	O
start	int
;	O
temp	pointer
->	O
end	int
=	O
end	int
;	O
temp	pointer
->	O
text	pointer
=	O
text	pointer
;	O
temp	pointer
->	O
next	pointer
=	O
(	O
UNDO_LIST	struct
*	O
)	O
NULL	O
;	O
return	O
temp	pointer
;	O
}	O
void	O
rl_add_undo	function
(	O
what	enum
,	O
start	int
,	O
end	int
,	O
text	pointer
)	O
enum	O
undo_code	enum
what	enum
;	O
int	O
start	int
,	O
end	int
;	O
char	O
*	O
text	pointer
;	O
{	O
UNDO_LIST	struct
*	O
temp	pointer
;	O
temp	pointer
=	O
alloc_undo_entry	function
(	O
what	enum
,	O
start	int
,	O
end	int
,	O
text	pointer
)	O
;	O
temp	pointer
->	O
next	pointer
=	O
rl_undo_list	pointer
;	O
rl_undo_list	pointer
=	O
temp	pointer
;	O
}	O
void	O
_rl_free_undo_list	function
(	O
ul	pointer
)	O
UNDO_LIST	struct
*	O
ul	pointer
;	O
{	O
UNDO_LIST	struct
*	O
release	pointer
;	O
while	O
(	O
ul	pointer
)	O
{	O
release	pointer
=	O
ul	pointer
;	O
ul	pointer
=	O
ul	pointer
->	O
next	pointer
;	O
if	O
(	O
release	pointer
->	O
what	enum
==	O
UNDO_DELETE	int
)	O
xfree	function
(	O
release	pointer
->	O
text	pointer
)	O
;	O
xfree	function
(	O
release	pointer
)	O
;	O
}	O
}	O
void	O
rl_free_undo_list	function
(	O
)	O
{	O
UNDO_LIST	struct
*	O
release	pointer
,	O
*	O
orig_list	pointer
;	O
orig_list	pointer
=	O
rl_undo_list	pointer
;	O
_rl_free_undo_list	function
(	O
rl_undo_list	pointer
)	O
;	O
rl_undo_list	pointer
=	O
(	O
UNDO_LIST	struct
*	O
)	O
NULL	O
;	O
_hs_replace_history_data	function
(	O
-	O
1	int
,	O
(	O
histdata_t	pointer
*	O
)	O
orig_list	pointer
,	O
(	O
histdata_t	pointer
*	O
)	O
NULL	O
)	O
;	O
}	O
UNDO_LIST	struct
*	O
_rl_copy_undo_entry	function
(	O
entry	pointer
)	O
UNDO_LIST	struct
*	O
entry	pointer
;	O
{	O
UNDO_LIST	struct
*	O
new	pointer
;	O
new	pointer
=	O
alloc_undo_entry	function
(	O
entry	pointer
->	O
what	enum
,	O
entry	pointer
->	O
start	int
,	O
entry	pointer
->	O
end	int
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
new	pointer
->	O
text	pointer
=	O
entry	pointer
->	O
text	pointer
?	O
savestring	O
(	O
entry	pointer
->	O
text	pointer
)	O
:	O
0	int
;	O
return	O
new	pointer
;	O
}	O
UNDO_LIST	struct
*	O
_rl_copy_undo_list	function
(	O
head	pointer
)	O
UNDO_LIST	struct
*	O
head	pointer
;	O
{	O
UNDO_LIST	struct
*	O
list	pointer
,	O
*	O
new	pointer
,	O
*	O
roving	pointer
,	O
*	O
c	pointer
;	O
if	O
(	O
head	pointer
==	O
0	int
)	O
return	O
head	pointer
;	O
list	pointer
=	O
head	pointer
;	O
new	pointer
=	O
0	int
;	O
while	O
(	O
list	pointer
)	O
{	O
c	pointer
=	O
_rl_copy_undo_entry	function
(	O
list	pointer
)	O
;	O
if	O
(	O
new	pointer
==	O
0	int
)	O
roving	pointer
=	O
new	pointer
=	O
c	pointer
;	O
else	O
{	O
roving	pointer
->	O
next	pointer
=	O
c	pointer
;	O
roving	pointer
=	O
roving	pointer
->	O
next	pointer
;	O
}	O
list	pointer
=	O
list	pointer
->	O
next	pointer
;	O
}	O
roving	pointer
->	O
next	pointer
=	O
0	int
;	O
return	O
new	pointer
;	O
}	O
int	O
rl_do_undo	function
(	O
)	O
{	O
UNDO_LIST	struct
*	O
release	pointer
;	O
int	O
waiting_for_begin	int
,	O
start	int
,	O
end	int
;	O
HIST_ENTRY	struct
*	O
cur	pointer
,	O
*	O
temp	pointer
;	O
start	int
=	O
end	int
=	O
waiting_for_begin	int
=	O
0	int
;	O
do	O
{	O
if	O
(	O
rl_undo_list	pointer
==	O
0	int
)	O
return	O
(	O
0	int
)	O
;	O
_rl_doing_an_undo	int
=	O
1	int
;	O
RL_SETSTATE	O
(	O
RL_STATE_UNDOING	int
)	O
;	O
if	O
(	O
rl_undo_list	pointer
->	O
what	enum
==	O
UNDO_DELETE	int
||	O
rl_undo_list	pointer
->	O
what	enum
==	O
UNDO_INSERT	int
)	O
{	O
start	int
=	O
TRANS	O
(	O
rl_undo_list	pointer
->	O
start	int
)	O
;	O
end	int
=	O
TRANS	O
(	O
rl_undo_list	pointer
->	O
end	int
)	O
;	O
}	O
switch	O
(	O
rl_undo_list	pointer
->	O
what	enum
)	O
{	O
case	O
UNDO_DELETE	int
:	O
rl_point	int
=	O
start	int
;	O
rl_insert_text	function
(	O
rl_undo_list	pointer
->	O
text	pointer
)	O
;	O
xfree	function
(	O
rl_undo_list	pointer
->	O
text	pointer
)	O
;	O
break	O
;	O
case	O
UNDO_INSERT	int
:	O
rl_delete_text	function
(	O
start	int
,	O
end	int
)	O
;	O
rl_point	int
=	O
start	int
;	O
break	O
;	O
case	O
UNDO_END	int
:	O
waiting_for_begin	int
++	O
;	O
break	O
;	O
case	O
UNDO_BEGIN	int
:	O
if	O
(	O
waiting_for_begin	int
)	O
waiting_for_begin	int
--	O
;	O
else	O
rl_ding	function
(	O
)	O
;	O
break	O
;	O
}	O
_rl_doing_an_undo	int
=	O
0	int
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_UNDOING	int
)	O
;	O
release	pointer
=	O
rl_undo_list	pointer
;	O
rl_undo_list	pointer
=	O
rl_undo_list	pointer
->	O
next	pointer
;	O
cur	pointer
=	O
current_history	function
(	O
)	O
;	O
if	O
(	O
cur	pointer
&&	O
cur	pointer
->	O
data	pointer
&&	O
(	O
UNDO_LIST	struct
*	O
)	O
cur	pointer
->	O
data	pointer
==	O
release	pointer
)	O
{	O
temp	pointer
=	O
replace_history_entry	function
(	O
where_history	function
(	O
)	O
,	O
rl_line_buffer	pointer
,	O
(	O
histdata_t	pointer
)	O
rl_undo_list	pointer
)	O
;	O
xfree	function
(	O
temp	pointer
->	O
line	pointer
)	O
;	O
FREE	O
(	O
temp	pointer
->	O
timestamp	pointer
)	O
;	O
xfree	function
(	O
temp	pointer
)	O
;	O
}	O
_hs_replace_history_data	function
(	O
-	O
1	int
,	O
(	O
histdata_t	pointer
*	O
)	O
release	pointer
,	O
(	O
histdata_t	pointer
*	O
)	O
rl_undo_list	pointer
)	O
;	O
xfree	function
(	O
release	pointer
)	O
;	O
}	O
while	O
(	O
waiting_for_begin	int
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
int	O
_rl_fix_last_undo_of_type	function
(	O
type	char
,	O
start	int
,	O
end	int
)	O
int	O
type	char
,	O
start	int
,	O
end	int
;	O
{	O
UNDO_LIST	struct
*	O
rl	pointer
;	O
for	O
(	O
rl	pointer
=	O
rl_undo_list	pointer
;	O
rl	pointer
;	O
rl	pointer
=	O
rl	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
rl	pointer
->	O
what	enum
==	O
type	char
)	O
{	O
rl	pointer
->	O
start	int
=	O
start	int
;	O
rl	pointer
->	O
end	int
=	O
end	int
;	O
return	O
0	int
;	O
}	O
}	O
return	O
1	int
;	O
}	O
int	O
rl_begin_undo_group	function
(	O
)	O
{	O
rl_add_undo	function
(	O
UNDO_BEGIN	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
_rl_undo_group_level	int
++	O
;	O
return	O
0	int
;	O
}	O
int	O
rl_end_undo_group	function
(	O
)	O
{	O
rl_add_undo	function
(	O
UNDO_END	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
_rl_undo_group_level	int
--	O
;	O
return	O
0	int
;	O
}	O
int	O
rl_modifying	function
(	O
start	int
,	O
end	int
)	O
int	O
start	int
,	O
end	int
;	O
{	O
if	O
(	O
start	int
>	O
end	int
)	O
{	O
SWAP	O
(	O
start	int
,	O
end	int
)	O
;	O
}	O
if	O
(	O
start	int
!=	O
end	int
)	O
{	O
char	O
*	O
temp	pointer
=	O
rl_copy_text	function
(	O
start	int
,	O
end	int
)	O
;	O
rl_begin_undo_group	function
(	O
)	O
;	O
rl_add_undo	function
(	O
UNDO_DELETE	int
,	O
start	int
,	O
end	int
,	O
temp	pointer
)	O
;	O
rl_add_undo	function
(	O
UNDO_INSERT	int
,	O
start	int
,	O
end	int
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
rl_end_undo_group	function
(	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
rl_revert_line	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
rl_undo_list	pointer
==	O
0	int
)	O
rl_ding	function
(	O
)	O
;	O
else	O
{	O
while	O
(	O
rl_undo_list	pointer
)	O
rl_do_undo	function
(	O
)	O
;	O
if	O
(	O
rl_editing_mode	int
==	O
vi_mode	int
)	O
rl_point	int
=	O
rl_mark	int
=	O
0	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
rl_undo_command	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
count	int
<	O
0	int
)	O
return	O
0	int
;	O
while	O
(	O
count	int
)	O
{	O
if	O
(	O
rl_do_undo	function
(	O
)	O
)	O
count	int
--	O
;	O
else	O
{	O
rl_ding	function
(	O
)	O
;	O
break	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
