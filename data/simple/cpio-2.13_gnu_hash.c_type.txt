struct	O
hash_entry	struct
{	O
void	O
*	O
data	pointer
;	O
struct	O
hash_entry	struct
*	O
next	pointer
;	O
}	O
;	O
struct	O
hash_table	struct
{	O
struct	O
hash_entry	struct
*	O
bucket	pointer
;	O
struct	O
hash_entry	struct
const	O
*	O
bucket_limit	pointer
;	O
size_t	long
n_buckets	long
;	O
size_t	long
n_buckets_used	long
;	O
size_t	long
n_entries	long
;	O
const	O
Hash_tuning	struct
*	O
tuning	pointer
;	O
Hash_hasher	pointer
hasher	pointer
;	O
Hash_comparator	pointer
comparator	pointer
;	O
Hash_data_freer	pointer
data_freer	pointer
;	O
struct	O
hash_entry	struct
*	O
free_entry_list	pointer
;	O
}	O
;	O
static	O
const	O
Hash_tuning	struct
default_tuning	struct
=	O
{	O
DEFAULT_SHRINK_THRESHOLD	int
,	O
DEFAULT_SHRINK_FACTOR	int
,	O
DEFAULT_GROWTH_THRESHOLD	int
,	O
DEFAULT_GROWTH_FACTOR	int
,	O
false	int
}	O
;	O
size_t	long
hash_get_n_buckets	function
(	O
const	O
Hash_table	struct
*	O
table	pointer
)	O
{	O
return	O
table	pointer
->	O
n_buckets	long
;	O
}	O
size_t	long
hash_get_n_buckets_used	function
(	O
const	O
Hash_table	struct
*	O
table	pointer
)	O
{	O
return	O
table	pointer
->	O
n_buckets_used	long
;	O
}	O
size_t	long
hash_get_n_entries	function
(	O
const	O
Hash_table	struct
*	O
table	pointer
)	O
{	O
return	O
table	pointer
->	O
n_entries	long
;	O
}	O
size_t	long
hash_get_max_bucket_length	function
(	O
const	O
Hash_table	struct
*	O
table	pointer
)	O
{	O
struct	O
hash_entry	struct
const	O
*	O
bucket	pointer
;	O
size_t	long
max_bucket_length	long
=	O
0	int
;	O
for	O
(	O
bucket	pointer
=	O
table	pointer
->	O
bucket	pointer
;	O
bucket	pointer
<	O
table	pointer
->	O
bucket_limit	pointer
;	O
bucket	pointer
++	O
)	O
{	O
if	O
(	O
bucket	pointer
->	O
data	pointer
)	O
{	O
struct	O
hash_entry	struct
const	O
*	O
cursor	pointer
=	O
bucket	pointer
;	O
size_t	long
bucket_length	long
=	O
1	int
;	O
while	O
(	O
cursor	pointer
=	O
cursor	pointer
->	O
next	pointer
,	O
cursor	pointer
)	O
bucket_length	long
++	O
;	O
if	O
(	O
bucket_length	long
>	O
max_bucket_length	long
)	O
max_bucket_length	long
=	O
bucket_length	long
;	O
}	O
}	O
return	O
max_bucket_length	long
;	O
}	O
bool	bool
hash_table_ok	function
(	O
const	O
Hash_table	struct
*	O
table	pointer
)	O
{	O
struct	O
hash_entry	struct
const	O
*	O
bucket	pointer
;	O
size_t	long
n_buckets_used	long
=	O
0	int
;	O
size_t	long
n_entries	long
=	O
0	int
;	O
for	O
(	O
bucket	pointer
=	O
table	pointer
->	O
bucket	pointer
;	O
bucket	pointer
<	O
table	pointer
->	O
bucket_limit	pointer
;	O
bucket	pointer
++	O
)	O
{	O
if	O
(	O
bucket	pointer
->	O
data	pointer
)	O
{	O
struct	O
hash_entry	struct
const	O
*	O
cursor	pointer
=	O
bucket	pointer
;	O
n_buckets_used	long
++	O
;	O
n_entries	long
++	O
;	O
while	O
(	O
cursor	pointer
=	O
cursor	pointer
->	O
next	pointer
,	O
cursor	pointer
)	O
n_entries	long
++	O
;	O
}	O
}	O
if	O
(	O
n_buckets_used	long
==	O
table	pointer
->	O
n_buckets_used	long
&&	O
n_entries	long
==	O
table	pointer
->	O
n_entries	long
)	O
return	O
true	int
;	O
return	O
false	int
;	O
}	O
void	O
hash_print_statistics	function
(	O
const	O
Hash_table	struct
*	O
table	pointer
,	O
FILE	struct
*	O
stream	pointer
)	O
{	O
size_t	long
n_entries	long
=	O
hash_get_n_entries	function
(	O
table	pointer
)	O
;	O
size_t	long
n_buckets	long
=	O
hash_get_n_buckets	function
(	O
table	pointer
)	O
;	O
size_t	long
n_buckets_used	long
=	O
hash_get_n_buckets_used	function
(	O
table	pointer
)	O
;	O
size_t	long
max_bucket_length	long
=	O
hash_get_max_bucket_length	function
(	O
table	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"# entries:         %lu\n"	pointer
,	O
(	O
unsigned	O
long	O
int	O
)	O
n_entries	long
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"# buckets:         %lu\n"	pointer
,	O
(	O
unsigned	O
long	O
int	O
)	O
n_buckets	long
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"# buckets used:    %lu (%.2f%%)\n"	pointer
,	O
(	O
unsigned	O
long	O
int	O
)	O
n_buckets_used	long
,	O
(	O
100.0	int
*	O
n_buckets_used	long
)	O
/	O
n_buckets	long
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"max bucket length: %lu\n"	pointer
,	O
(	O
unsigned	O
long	O
int	O
)	O
max_bucket_length	long
)	O
;	O
}	O
static	O
struct	O
hash_entry	struct
*	O
safe_hasher	function
(	O
const	O
Hash_table	struct
*	O
table	pointer
,	O
const	O
void	O
*	O
key	pointer
)	O
{	O
size_t	long
n	int
=	O
table	pointer
->	O
hasher	pointer
(	O
key	pointer
,	O
table	pointer
->	O
n_buckets	long
)	O
;	O
if	O
(	O
!	O
(	O
n	int
<	O
table	pointer
->	O
n_buckets	long
)	O
)	O
abort	function
(	O
)	O
;	O
return	O
table	pointer
->	O
bucket	pointer
+	O
n	int
;	O
}	O
void	O
*	O
hash_lookup	function
(	O
const	O
Hash_table	struct
*	O
table	pointer
,	O
const	O
void	O
*	O
entry	pointer
)	O
{	O
struct	O
hash_entry	struct
const	O
*	O
bucket	pointer
=	O
safe_hasher	function
(	O
table	pointer
,	O
entry	pointer
)	O
;	O
struct	O
hash_entry	struct
const	O
*	O
cursor	pointer
;	O
if	O
(	O
bucket	pointer
->	O
data	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
for	O
(	O
cursor	pointer
=	O
bucket	pointer
;	O
cursor	pointer
;	O
cursor	pointer
=	O
cursor	pointer
->	O
next	pointer
)	O
if	O
(	O
entry	pointer
==	O
cursor	pointer
->	O
data	pointer
||	O
table	pointer
->	O
comparator	pointer
(	O
entry	pointer
,	O
cursor	pointer
->	O
data	pointer
)	O
)	O
return	O
cursor	pointer
->	O
data	pointer
;	O
return	O
NULL	O
;	O
}	O
void	O
*	O
hash_get_first	function
(	O
const	O
Hash_table	struct
*	O
table	pointer
)	O
{	O
struct	O
hash_entry	struct
const	O
*	O
bucket	pointer
;	O
if	O
(	O
table	pointer
->	O
n_entries	long
==	O
0	int
)	O
return	O
NULL	O
;	O
for	O
(	O
bucket	pointer
=	O
table	pointer
->	O
bucket	pointer
;	O
;	O
bucket	pointer
++	O
)	O
if	O
(	O
!	O
(	O
bucket	pointer
<	O
table	pointer
->	O
bucket_limit	pointer
)	O
)	O
abort	function
(	O
)	O
;	O
else	O
if	O
(	O
bucket	pointer
->	O
data	pointer
)	O
return	O
bucket	pointer
->	O
data	pointer
;	O
}	O
void	O
*	O
hash_get_next	function
(	O
const	O
Hash_table	struct
*	O
table	pointer
,	O
const	O
void	O
*	O
entry	pointer
)	O
{	O
struct	O
hash_entry	struct
const	O
*	O
bucket	pointer
=	O
safe_hasher	function
(	O
table	pointer
,	O
entry	pointer
)	O
;	O
struct	O
hash_entry	struct
const	O
*	O
cursor	pointer
;	O
cursor	pointer
=	O
bucket	pointer
;	O
do	O
{	O
if	O
(	O
cursor	pointer
->	O
data	pointer
==	O
entry	pointer
&&	O
cursor	pointer
->	O
next	pointer
)	O
return	O
cursor	pointer
->	O
next	pointer
->	O
data	pointer
;	O
cursor	pointer
=	O
cursor	pointer
->	O
next	pointer
;	O
}	O
while	O
(	O
cursor	pointer
!=	O
NULL	O
)	O
;	O
while	O
(	O
++	O
bucket	pointer
<	O
table	pointer
->	O
bucket_limit	pointer
)	O
if	O
(	O
bucket	pointer
->	O
data	pointer
)	O
return	O
bucket	pointer
->	O
data	pointer
;	O
return	O
NULL	O
;	O
}	O
size_t	long
hash_get_entries	function
(	O
const	O
Hash_table	struct
*	O
table	pointer
,	O
void	O
*	O
*	O
buffer	pointer
,	O
size_t	long
buffer_size	long
)	O
{	O
size_t	long
counter	long
=	O
0	int
;	O
struct	O
hash_entry	struct
const	O
*	O
bucket	pointer
;	O
struct	O
hash_entry	struct
const	O
*	O
cursor	pointer
;	O
for	O
(	O
bucket	pointer
=	O
table	pointer
->	O
bucket	pointer
;	O
bucket	pointer
<	O
table	pointer
->	O
bucket_limit	pointer
;	O
bucket	pointer
++	O
)	O
{	O
if	O
(	O
bucket	pointer
->	O
data	pointer
)	O
{	O
for	O
(	O
cursor	pointer
=	O
bucket	pointer
;	O
cursor	pointer
;	O
cursor	pointer
=	O
cursor	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
counter	long
>=	O
buffer_size	long
)	O
return	O
counter	long
;	O
buffer	pointer
[	O
counter	long
++	O
]	O
=	O
cursor	pointer
->	O
data	pointer
;	O
}	O
}	O
}	O
return	O
counter	long
;	O
}	O
size_t	long
hash_do_for_each	function
(	O
const	O
Hash_table	struct
*	O
table	pointer
,	O
Hash_processor	pointer
processor	pointer
,	O
void	O
*	O
processor_data	pointer
)	O
{	O
size_t	long
counter	long
=	O
0	int
;	O
struct	O
hash_entry	struct
const	O
*	O
bucket	pointer
;	O
struct	O
hash_entry	struct
const	O
*	O
cursor	pointer
;	O
for	O
(	O
bucket	pointer
=	O
table	pointer
->	O
bucket	pointer
;	O
bucket	pointer
<	O
table	pointer
->	O
bucket_limit	pointer
;	O
bucket	pointer
++	O
)	O
{	O
if	O
(	O
bucket	pointer
->	O
data	pointer
)	O
{	O
for	O
(	O
cursor	pointer
=	O
bucket	pointer
;	O
cursor	pointer
;	O
cursor	pointer
=	O
cursor	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
!	O
processor	pointer
(	O
cursor	pointer
->	O
data	pointer
,	O
processor_data	pointer
)	O
)	O
return	O
counter	long
;	O
counter	long
++	O
;	O
}	O
}	O
}	O
return	O
counter	long
;	O
}	O
size_t	long
hash_string	function
(	O
const	O
char	O
*	O
string	pointer
,	O
size_t	long
n_buckets	long
)	O
{	O
size_t	long
value	long
=	O
0	int
;	O
unsigned	O
char	O
ch	char
;	O
for	O
(	O
;	O
(	O
ch	char
=	O
*	O
string	pointer
)	O
;	O
string	pointer
++	O
)	O
value	long
=	O
(	O
value	long
*	O
31	int
+	O
ch	char
)	O
%	O
n_buckets	long
;	O
return	O
value	long
;	O
}	O
static	O
bool	bool
_GL_ATTRIBUTE_CONST	O
is_prime	function
(	O
size_t	long
candidate	long
)	O
{	O
size_t	long
divisor	long
=	O
3	int
;	O
size_t	long
square	long
=	O
divisor	long
*	O
divisor	long
;	O
while	O
(	O
square	long
<	O
candidate	long
&&	O
(	O
candidate	long
%	O
divisor	long
)	O
)	O
{	O
divisor	long
++	O
;	O
square	long
+=	O
4	int
*	O
divisor	long
;	O
divisor	long
++	O
;	O
}	O
return	O
(	O
candidate	long
%	O
divisor	long
?	O
true	int
:	O
false	int
)	O
;	O
}	O
static	O
size_t	long
_GL_ATTRIBUTE_CONST	O
next_prime	function
(	O
size_t	long
candidate	long
)	O
{	O
if	O
(	O
candidate	long
<	O
10	int
)	O
candidate	long
=	O
10	int
;	O
candidate	long
|=	O
1	int
;	O
while	O
(	O
SIZE_MAX	O
!=	O
candidate	long
&&	O
!	O
is_prime	function
(	O
candidate	long
)	O
)	O
candidate	long
+=	O
2	int
;	O
return	O
candidate	long
;	O
}	O
void	O
hash_reset_tuning	function
(	O
Hash_tuning	struct
*	O
tuning	pointer
)	O
{	O
*	O
tuning	pointer
=	O
default_tuning	struct
;	O
}	O
static	O
size_t	long
raw_hasher	function
(	O
const	O
void	O
*	O
data	pointer
,	O
size_t	long
n	int
)	O
{	O
size_t	long
val	long
=	O
rotr_sz	function
(	O
(	O
size_t	long
)	O
data	pointer
,	O
3	int
)	O
;	O
return	O
val	long
%	O
n	int
;	O
}	O
static	O
bool	bool
raw_comparator	function
(	O
const	O
void	O
*	O
a	pointer
,	O
const	O
void	O
*	O
b	pointer
)	O
{	O
return	O
a	pointer
==	O
b	pointer
;	O
}	O
static	O
bool	bool
check_tuning	function
(	O
Hash_table	struct
*	O
table	pointer
)	O
{	O
const	O
Hash_tuning	struct
*	O
tuning	pointer
=	O
table	pointer
->	O
tuning	pointer
;	O
float	O
epsilon	float
;	O
if	O
(	O
tuning	pointer
==	O
&	O
default_tuning	struct
)	O
return	O
true	int
;	O
epsilon	float
=	O
0.1f	int
;	O
if	O
(	O
epsilon	float
<	O
tuning	pointer
->	O
growth_threshold	float
&&	O
tuning	pointer
->	O
growth_threshold	float
<	O
1	int
-	O
epsilon	float
&&	O
1	int
+	O
epsilon	float
<	O
tuning	pointer
->	O
growth_factor	float
&&	O
0	int
<=	O
tuning	pointer
->	O
shrink_threshold	float
&&	O
tuning	pointer
->	O
shrink_threshold	float
+	O
epsilon	float
<	O
tuning	pointer
->	O
shrink_factor	float
&&	O
tuning	pointer
->	O
shrink_factor	float
<=	O
1	int
&&	O
tuning	pointer
->	O
shrink_threshold	float
+	O
epsilon	float
<	O
tuning	pointer
->	O
growth_threshold	float
)	O
return	O
true	int
;	O
table	pointer
->	O
tuning	pointer
=	O
&	O
default_tuning	struct
;	O
return	O
false	int
;	O
}	O
static	O
size_t	long
_GL_ATTRIBUTE_PURE	O
compute_bucket_size	function
(	O
size_t	long
candidate	long
,	O
const	O
Hash_tuning	struct
*	O
tuning	pointer
)	O
{	O
if	O
(	O
!	O
tuning	pointer
->	O
is_n_buckets	bool
)	O
{	O
float	O
new_candidate	float
=	O
candidate	long
/	O
tuning	pointer
->	O
growth_threshold	float
;	O
if	O
(	O
SIZE_MAX	O
<=	O
new_candidate	float
)	O
return	O
0	int
;	O
candidate	long
=	O
new_candidate	float
;	O
}	O
candidate	long
=	O
next_prime	function
(	O
candidate	long
)	O
;	O
if	O
(	O
xalloc_oversized	O
(	O
candidate	long
,	O
sizeof	O
(	O
struct	O
hash_entry	struct
*	O
)	O
)	O
)	O
return	O
0	int
;	O
return	O
candidate	long
;	O
}	O
Hash_table	struct
*	O
hash_initialize	function
(	O
size_t	long
candidate	long
,	O
const	O
Hash_tuning	struct
*	O
tuning	pointer
,	O
Hash_hasher	pointer
hasher	pointer
,	O
Hash_comparator	pointer
comparator	pointer
,	O
Hash_data_freer	pointer
data_freer	pointer
)	O
{	O
Hash_table	struct
*	O
table	pointer
;	O
if	O
(	O
hasher	pointer
==	O
NULL	O
)	O
hasher	pointer
=	O
raw_hasher	function
;	O
if	O
(	O
comparator	pointer
==	O
NULL	O
)	O
comparator	pointer
=	O
raw_comparator	function
;	O
table	pointer
=	O
malloc	function
(	O
sizeof	O
*	O
table	pointer
)	O
;	O
if	O
(	O
table	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
!	O
tuning	pointer
)	O
tuning	pointer
=	O
&	O
default_tuning	struct
;	O
table	pointer
->	O
tuning	pointer
=	O
tuning	pointer
;	O
if	O
(	O
!	O
check_tuning	function
(	O
table	pointer
)	O
)	O
{	O
goto	O
fail	O
;	O
}	O
table	pointer
->	O
n_buckets	long
=	O
compute_bucket_size	function
(	O
candidate	long
,	O
tuning	pointer
)	O
;	O
if	O
(	O
!	O
table	pointer
->	O
n_buckets	long
)	O
goto	O
fail	O
;	O
table	pointer
->	O
bucket	pointer
=	O
calloc	function
(	O
table	pointer
->	O
n_buckets	long
,	O
sizeof	O
*	O
table	pointer
->	O
bucket	pointer
)	O
;	O
if	O
(	O
table	pointer
->	O
bucket	pointer
==	O
NULL	O
)	O
goto	O
fail	O
;	O
table	pointer
->	O
bucket_limit	pointer
=	O
table	pointer
->	O
bucket	pointer
+	O
table	pointer
->	O
n_buckets	long
;	O
table	pointer
->	O
n_buckets_used	long
=	O
0	int
;	O
table	pointer
->	O
n_entries	long
=	O
0	int
;	O
table	pointer
->	O
hasher	pointer
=	O
hasher	pointer
;	O
table	pointer
->	O
comparator	pointer
=	O
comparator	pointer
;	O
table	pointer
->	O
data_freer	pointer
=	O
data_freer	pointer
;	O
table	pointer
->	O
free_entry_list	pointer
=	O
NULL	O
;	O
return	O
table	pointer
;	O
fail	O
:	O
free	function
(	O
table	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
void	O
hash_clear	function
(	O
Hash_table	struct
*	O
table	pointer
)	O
{	O
struct	O
hash_entry	struct
*	O
bucket	pointer
;	O
for	O
(	O
bucket	pointer
=	O
table	pointer
->	O
bucket	pointer
;	O
bucket	pointer
<	O
table	pointer
->	O
bucket_limit	pointer
;	O
bucket	pointer
++	O
)	O
{	O
if	O
(	O
bucket	pointer
->	O
data	pointer
)	O
{	O
struct	O
hash_entry	struct
*	O
cursor	pointer
;	O
struct	O
hash_entry	struct
*	O
next	pointer
;	O
for	O
(	O
cursor	pointer
=	O
bucket	pointer
->	O
next	pointer
;	O
cursor	pointer
;	O
cursor	pointer
=	O
next	pointer
)	O
{	O
if	O
(	O
table	pointer
->	O
data_freer	pointer
)	O
table	pointer
->	O
data_freer	pointer
(	O
cursor	pointer
->	O
data	pointer
)	O
;	O
cursor	pointer
->	O
data	pointer
=	O
NULL	O
;	O
next	pointer
=	O
cursor	pointer
->	O
next	pointer
;	O
cursor	pointer
->	O
next	pointer
=	O
table	pointer
->	O
free_entry_list	pointer
;	O
table	pointer
->	O
free_entry_list	pointer
=	O
cursor	pointer
;	O
}	O
if	O
(	O
table	pointer
->	O
data_freer	pointer
)	O
table	pointer
->	O
data_freer	pointer
(	O
bucket	pointer
->	O
data	pointer
)	O
;	O
bucket	pointer
->	O
data	pointer
=	O
NULL	O
;	O
bucket	pointer
->	O
next	pointer
=	O
NULL	O
;	O
}	O
}	O
table	pointer
->	O
n_buckets_used	long
=	O
0	int
;	O
table	pointer
->	O
n_entries	long
=	O
0	int
;	O
}	O
void	O
hash_free	function
(	O
Hash_table	struct
*	O
table	pointer
)	O
{	O
struct	O
hash_entry	struct
*	O
bucket	pointer
;	O
struct	O
hash_entry	struct
*	O
cursor	pointer
;	O
struct	O
hash_entry	struct
*	O
next	pointer
;	O
if	O
(	O
table	pointer
->	O
data_freer	pointer
&&	O
table	pointer
->	O
n_entries	long
)	O
{	O
for	O
(	O
bucket	pointer
=	O
table	pointer
->	O
bucket	pointer
;	O
bucket	pointer
<	O
table	pointer
->	O
bucket_limit	pointer
;	O
bucket	pointer
++	O
)	O
{	O
if	O
(	O
bucket	pointer
->	O
data	pointer
)	O
{	O
for	O
(	O
cursor	pointer
=	O
bucket	pointer
;	O
cursor	pointer
;	O
cursor	pointer
=	O
cursor	pointer
->	O
next	pointer
)	O
table	pointer
->	O
data_freer	pointer
(	O
cursor	pointer
->	O
data	pointer
)	O
;	O
}	O
}	O
}	O
for	O
(	O
bucket	pointer
=	O
table	pointer
->	O
bucket	pointer
;	O
bucket	pointer
<	O
table	pointer
->	O
bucket_limit	pointer
;	O
bucket	pointer
++	O
)	O
{	O
for	O
(	O
cursor	pointer
=	O
bucket	pointer
->	O
next	pointer
;	O
cursor	pointer
;	O
cursor	pointer
=	O
next	pointer
)	O
{	O
next	pointer
=	O
cursor	pointer
->	O
next	pointer
;	O
free	function
(	O
cursor	pointer
)	O
;	O
}	O
}	O
for	O
(	O
cursor	pointer
=	O
table	pointer
->	O
free_entry_list	pointer
;	O
cursor	pointer
;	O
cursor	pointer
=	O
next	pointer
)	O
{	O
next	pointer
=	O
cursor	pointer
->	O
next	pointer
;	O
free	function
(	O
cursor	pointer
)	O
;	O
}	O
free	function
(	O
table	pointer
->	O
bucket	pointer
)	O
;	O
free	function
(	O
table	pointer
)	O
;	O
}	O
static	O
struct	O
hash_entry	struct
*	O
allocate_entry	function
(	O
Hash_table	struct
*	O
table	pointer
)	O
{	O
struct	O
hash_entry	struct
*	O
new	pointer
;	O
if	O
(	O
table	pointer
->	O
free_entry_list	pointer
)	O
{	O
new	pointer
=	O
table	pointer
->	O
free_entry_list	pointer
;	O
table	pointer
->	O
free_entry_list	pointer
=	O
new	pointer
->	O
next	pointer
;	O
}	O
else	O
{	O
new	pointer
=	O
malloc	function
(	O
sizeof	O
*	O
new	pointer
)	O
;	O
}	O
return	O
new	pointer
;	O
}	O
static	O
void	O
free_entry	function
(	O
Hash_table	struct
*	O
table	pointer
,	O
struct	O
hash_entry	struct
*	O
entry	pointer
)	O
{	O
entry	pointer
->	O
data	pointer
=	O
NULL	O
;	O
entry	pointer
->	O
next	pointer
=	O
table	pointer
->	O
free_entry_list	pointer
;	O
table	pointer
->	O
free_entry_list	pointer
=	O
entry	pointer
;	O
}	O
static	O
void	O
*	O
hash_find_entry	function
(	O
Hash_table	struct
*	O
table	pointer
,	O
const	O
void	O
*	O
entry	pointer
,	O
struct	O
hash_entry	struct
*	O
*	O
bucket_head	pointer
,	O
bool	bool
delete	bool
)	O
{	O
struct	O
hash_entry	struct
*	O
bucket	pointer
=	O
safe_hasher	function
(	O
table	pointer
,	O
entry	pointer
)	O
;	O
struct	O
hash_entry	struct
*	O
cursor	pointer
;	O
*	O
bucket_head	pointer
=	O
bucket	pointer
;	O
if	O
(	O
bucket	pointer
->	O
data	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
entry	pointer
==	O
bucket	pointer
->	O
data	pointer
||	O
table	pointer
->	O
comparator	pointer
(	O
entry	pointer
,	O
bucket	pointer
->	O
data	pointer
)	O
)	O
{	O
void	O
*	O
data	pointer
=	O
bucket	pointer
->	O
data	pointer
;	O
if	O
(	O
delete	bool
)	O
{	O
if	O
(	O
bucket	pointer
->	O
next	pointer
)	O
{	O
struct	O
hash_entry	struct
*	O
next	pointer
=	O
bucket	pointer
->	O
next	pointer
;	O
*	O
bucket	pointer
=	O
*	O
next	pointer
;	O
free_entry	function
(	O
table	pointer
,	O
next	pointer
)	O
;	O
}	O
else	O
{	O
bucket	pointer
->	O
data	pointer
=	O
NULL	O
;	O
}	O
}	O
return	O
data	pointer
;	O
}	O
for	O
(	O
cursor	pointer
=	O
bucket	pointer
;	O
cursor	pointer
->	O
next	pointer
;	O
cursor	pointer
=	O
cursor	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
entry	pointer
==	O
cursor	pointer
->	O
next	pointer
->	O
data	pointer
||	O
table	pointer
->	O
comparator	pointer
(	O
entry	pointer
,	O
cursor	pointer
->	O
next	pointer
->	O
data	pointer
)	O
)	O
{	O
void	O
*	O
data	pointer
=	O
cursor	pointer
->	O
next	pointer
->	O
data	pointer
;	O
if	O
(	O
delete	bool
)	O
{	O
struct	O
hash_entry	struct
*	O
next	pointer
=	O
cursor	pointer
->	O
next	pointer
;	O
cursor	pointer
->	O
next	pointer
=	O
next	pointer
->	O
next	pointer
;	O
free_entry	function
(	O
table	pointer
,	O
next	pointer
)	O
;	O
}	O
return	O
data	pointer
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
static	O
bool	bool
transfer_entries	function
(	O
Hash_table	struct
*	O
dst	pointer
,	O
Hash_table	struct
*	O
src	pointer
,	O
bool	bool
safe	bool
)	O
{	O
struct	O
hash_entry	struct
*	O
bucket	pointer
;	O
struct	O
hash_entry	struct
*	O
cursor	pointer
;	O
struct	O
hash_entry	struct
*	O
next	pointer
;	O
for	O
(	O
bucket	pointer
=	O
src	pointer
->	O
bucket	pointer
;	O
bucket	pointer
<	O
src	pointer
->	O
bucket_limit	pointer
;	O
bucket	pointer
++	O
)	O
if	O
(	O
bucket	pointer
->	O
data	pointer
)	O
{	O
void	O
*	O
data	pointer
;	O
struct	O
hash_entry	struct
*	O
new_bucket	pointer
;	O
for	O
(	O
cursor	pointer
=	O
bucket	pointer
->	O
next	pointer
;	O
cursor	pointer
;	O
cursor	pointer
=	O
next	pointer
)	O
{	O
data	pointer
=	O
cursor	pointer
->	O
data	pointer
;	O
new_bucket	pointer
=	O
safe_hasher	function
(	O
dst	pointer
,	O
data	pointer
)	O
;	O
next	pointer
=	O
cursor	pointer
->	O
next	pointer
;	O
if	O
(	O
new_bucket	pointer
->	O
data	pointer
)	O
{	O
cursor	pointer
->	O
next	pointer
=	O
new_bucket	pointer
->	O
next	pointer
;	O
new_bucket	pointer
->	O
next	pointer
=	O
cursor	pointer
;	O
}	O
else	O
{	O
new_bucket	pointer
->	O
data	pointer
=	O
data	pointer
;	O
dst	pointer
->	O
n_buckets_used	long
++	O
;	O
free_entry	function
(	O
dst	pointer
,	O
cursor	pointer
)	O
;	O
}	O
}	O
data	pointer
=	O
bucket	pointer
->	O
data	pointer
;	O
bucket	pointer
->	O
next	pointer
=	O
NULL	O
;	O
if	O
(	O
safe	bool
)	O
continue	O
;	O
new_bucket	pointer
=	O
safe_hasher	function
(	O
dst	pointer
,	O
data	pointer
)	O
;	O
if	O
(	O
new_bucket	pointer
->	O
data	pointer
)	O
{	O
struct	O
hash_entry	struct
*	O
new_entry	pointer
=	O
allocate_entry	function
(	O
dst	pointer
)	O
;	O
if	O
(	O
new_entry	pointer
==	O
NULL	O
)	O
return	O
false	int
;	O
new_entry	pointer
->	O
data	pointer
=	O
data	pointer
;	O
new_entry	pointer
->	O
next	pointer
=	O
new_bucket	pointer
->	O
next	pointer
;	O
new_bucket	pointer
->	O
next	pointer
=	O
new_entry	pointer
;	O
}	O
else	O
{	O
new_bucket	pointer
->	O
data	pointer
=	O
data	pointer
;	O
dst	pointer
->	O
n_buckets_used	long
++	O
;	O
}	O
bucket	pointer
->	O
data	pointer
=	O
NULL	O
;	O
src	pointer
->	O
n_buckets_used	long
--	O
;	O
}	O
return	O
true	int
;	O
}	O
bool	bool
hash_rehash	function
(	O
Hash_table	struct
*	O
table	pointer
,	O
size_t	long
candidate	long
)	O
{	O
Hash_table	struct
storage	struct
;	O
Hash_table	struct
*	O
new_table	pointer
;	O
size_t	long
new_size	long
=	O
compute_bucket_size	function
(	O
candidate	long
,	O
table	pointer
->	O
tuning	pointer
)	O
;	O
if	O
(	O
!	O
new_size	long
)	O
return	O
false	int
;	O
if	O
(	O
new_size	long
==	O
table	pointer
->	O
n_buckets	long
)	O
return	O
true	int
;	O
new_table	pointer
=	O
&	O
storage	struct
;	O
new_table	pointer
->	O
bucket	pointer
=	O
calloc	function
(	O
new_size	long
,	O
sizeof	O
*	O
new_table	pointer
->	O
bucket	pointer
)	O
;	O
if	O
(	O
new_table	pointer
->	O
bucket	pointer
==	O
NULL	O
)	O
return	O
false	int
;	O
new_table	pointer
->	O
n_buckets	long
=	O
new_size	long
;	O
new_table	pointer
->	O
bucket_limit	pointer
=	O
new_table	pointer
->	O
bucket	pointer
+	O
new_size	long
;	O
new_table	pointer
->	O
n_buckets_used	long
=	O
0	int
;	O
new_table	pointer
->	O
n_entries	long
=	O
0	int
;	O
new_table	pointer
->	O
tuning	pointer
=	O
table	pointer
->	O
tuning	pointer
;	O
new_table	pointer
->	O
hasher	pointer
=	O
table	pointer
->	O
hasher	pointer
;	O
new_table	pointer
->	O
comparator	pointer
=	O
table	pointer
->	O
comparator	pointer
;	O
new_table	pointer
->	O
data_freer	pointer
=	O
table	pointer
->	O
data_freer	pointer
;	O
new_table	pointer
->	O
free_entry_list	pointer
=	O
table	pointer
->	O
free_entry_list	pointer
;	O
if	O
(	O
transfer_entries	function
(	O
new_table	pointer
,	O
table	pointer
,	O
false	int
)	O
)	O
{	O
free	function
(	O
table	pointer
->	O
bucket	pointer
)	O
;	O
table	pointer
->	O
bucket	pointer
=	O
new_table	pointer
->	O
bucket	pointer
;	O
table	pointer
->	O
bucket_limit	pointer
=	O
new_table	pointer
->	O
bucket_limit	pointer
;	O
table	pointer
->	O
n_buckets	long
=	O
new_table	pointer
->	O
n_buckets	long
;	O
table	pointer
->	O
n_buckets_used	long
=	O
new_table	pointer
->	O
n_buckets_used	long
;	O
table	pointer
->	O
free_entry_list	pointer
=	O
new_table	pointer
->	O
free_entry_list	pointer
;	O
return	O
true	int
;	O
}	O
table	pointer
->	O
free_entry_list	pointer
=	O
new_table	pointer
->	O
free_entry_list	pointer
;	O
if	O
(	O
!	O
(	O
transfer_entries	function
(	O
table	pointer
,	O
new_table	pointer
,	O
true	int
)	O
&&	O
transfer_entries	function
(	O
table	pointer
,	O
new_table	pointer
,	O
false	int
)	O
)	O
)	O
abort	function
(	O
)	O
;	O
free	function
(	O
new_table	pointer
->	O
bucket	pointer
)	O
;	O
return	O
false	int
;	O
}	O
int	O
hash_insert_if_absent	function
(	O
Hash_table	struct
*	O
table	pointer
,	O
void	O
const	O
*	O
entry	pointer
,	O
void	O
const	O
*	O
*	O
matched_ent	pointer
)	O
{	O
void	O
*	O
data	pointer
;	O
struct	O
hash_entry	struct
*	O
bucket	pointer
;	O
if	O
(	O
!	O
entry	pointer
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
(	O
data	pointer
=	O
hash_find_entry	function
(	O
table	pointer
,	O
entry	pointer
,	O
&	O
bucket	pointer
,	O
false	int
)	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
matched_ent	pointer
)	O
*	O
matched_ent	pointer
=	O
data	pointer
;	O
return	O
0	int
;	O
}	O
if	O
(	O
table	pointer
->	O
n_buckets_used	long
>	O
table	pointer
->	O
tuning	pointer
->	O
growth_threshold	float
*	O
table	pointer
->	O
n_buckets	long
)	O
{	O
check_tuning	function
(	O
table	pointer
)	O
;	O
if	O
(	O
table	pointer
->	O
n_buckets_used	long
>	O
table	pointer
->	O
tuning	pointer
->	O
growth_threshold	float
*	O
table	pointer
->	O
n_buckets	long
)	O
{	O
const	O
Hash_tuning	struct
*	O
tuning	pointer
=	O
table	pointer
->	O
tuning	pointer
;	O
float	O
candidate	long
=	O
(	O
tuning	pointer
->	O
is_n_buckets	bool
?	O
(	O
table	pointer
->	O
n_buckets	long
*	O
tuning	pointer
->	O
growth_factor	float
)	O
:	O
(	O
table	pointer
->	O
n_buckets	long
*	O
tuning	pointer
->	O
growth_factor	float
*	O
tuning	pointer
->	O
growth_threshold	float
)	O
)	O
;	O
if	O
(	O
SIZE_MAX	O
<=	O
candidate	long
)	O
return	O
-	O
1	int
;	O
if	O
(	O
!	O
hash_rehash	function
(	O
table	pointer
,	O
candidate	long
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
hash_find_entry	function
(	O
table	pointer
,	O
entry	pointer
,	O
&	O
bucket	pointer
,	O
false	int
)	O
!=	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
}	O
}	O
if	O
(	O
bucket	pointer
->	O
data	pointer
)	O
{	O
struct	O
hash_entry	struct
*	O
new_entry	pointer
=	O
allocate_entry	function
(	O
table	pointer
)	O
;	O
if	O
(	O
new_entry	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
new_entry	pointer
->	O
data	pointer
=	O
(	O
void	O
*	O
)	O
entry	pointer
;	O
new_entry	pointer
->	O
next	pointer
=	O
bucket	pointer
->	O
next	pointer
;	O
bucket	pointer
->	O
next	pointer
=	O
new_entry	pointer
;	O
table	pointer
->	O
n_entries	long
++	O
;	O
return	O
1	int
;	O
}	O
bucket	pointer
->	O
data	pointer
=	O
(	O
void	O
*	O
)	O
entry	pointer
;	O
table	pointer
->	O
n_entries	long
++	O
;	O
table	pointer
->	O
n_buckets_used	long
++	O
;	O
return	O
1	int
;	O
}	O
void	O
*	O
hash_insert	function
(	O
Hash_table	struct
*	O
table	pointer
,	O
void	O
const	O
*	O
entry	pointer
)	O
{	O
void	O
const	O
*	O
matched_ent	pointer
;	O
int	O
err	int
=	O
hash_insert_if_absent	function
(	O
table	pointer
,	O
entry	pointer
,	O
&	O
matched_ent	pointer
)	O
;	O
return	O
(	O
err	int
==	O
-	O
1	int
?	O
NULL	O
:	O
(	O
void	O
*	O
)	O
(	O
err	int
==	O
0	int
?	O
matched_ent	pointer
:	O
entry	pointer
)	O
)	O
;	O
}	O
void	O
*	O
hash_delete	function
(	O
Hash_table	struct
*	O
table	pointer
,	O
const	O
void	O
*	O
entry	pointer
)	O
{	O
void	O
*	O
data	pointer
;	O
struct	O
hash_entry	struct
*	O
bucket	pointer
;	O
data	pointer
=	O
hash_find_entry	function
(	O
table	pointer
,	O
entry	pointer
,	O
&	O
bucket	pointer
,	O
true	int
)	O
;	O
if	O
(	O
!	O
data	pointer
)	O
return	O
NULL	O
;	O
table	pointer
->	O
n_entries	long
--	O
;	O
if	O
(	O
!	O
bucket	pointer
->	O
data	pointer
)	O
{	O
table	pointer
->	O
n_buckets_used	long
--	O
;	O
if	O
(	O
table	pointer
->	O
n_buckets_used	long
<	O
table	pointer
->	O
tuning	pointer
->	O
shrink_threshold	float
*	O
table	pointer
->	O
n_buckets	long
)	O
{	O
check_tuning	function
(	O
table	pointer
)	O
;	O
if	O
(	O
table	pointer
->	O
n_buckets_used	long
<	O
table	pointer
->	O
tuning	pointer
->	O
shrink_threshold	float
*	O
table	pointer
->	O
n_buckets	long
)	O
{	O
const	O
Hash_tuning	struct
*	O
tuning	pointer
=	O
table	pointer
->	O
tuning	pointer
;	O
size_t	long
candidate	long
=	O
(	O
tuning	pointer
->	O
is_n_buckets	bool
?	O
table	pointer
->	O
n_buckets	long
*	O
tuning	pointer
->	O
shrink_factor	float
:	O
(	O
table	pointer
->	O
n_buckets	long
*	O
tuning	pointer
->	O
shrink_factor	float
*	O
tuning	pointer
->	O
growth_threshold	float
)	O
)	O
;	O
if	O
(	O
!	O
hash_rehash	function
(	O
table	pointer
,	O
candidate	long
)	O
)	O
{	O
struct	O
hash_entry	struct
*	O
cursor	pointer
=	O
table	pointer
->	O
free_entry_list	pointer
;	O
struct	O
hash_entry	struct
*	O
next	pointer
;	O
while	O
(	O
cursor	pointer
)	O
{	O
next	pointer
=	O
cursor	pointer
->	O
next	pointer
;	O
free	function
(	O
cursor	pointer
)	O
;	O
cursor	pointer
=	O
next	pointer
;	O
}	O
table	pointer
->	O
free_entry_list	pointer
=	O
NULL	O
;	O
}	O
}	O
}	O
}	O
return	O
data	pointer
;	O
}	O
