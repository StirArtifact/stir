gsl_complex	struct
gsl_complex_polar	function
(	O
double	O
r	double
,	O
double	O
theta	double
)	O
{	O
gsl_complex	struct
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
r	double
*	O
cos	function
(	O
theta	double
)	O
,	O
r	double
*	O
sin	function
(	O
theta	double
)	O
)	O
;	O
return	O
z	double
;	O
}	O
double	O
gsl_complex_arg	function
(	O
gsl_complex	struct
z	double
)	O
{	O
double	O
x	double
=	O
GSL_REAL	O
(	O
z	double
)	O
;	O
double	O
y	double
=	O
GSL_IMAG	O
(	O
z	double
)	O
;	O
if	O
(	O
x	double
==	O
0.0	int
&&	O
y	double
==	O
0.0	int
)	O
{	O
return	O
0	int
;	O
}	O
return	O
atan2	function
(	O
y	double
,	O
x	double
)	O
;	O
}	O
double	O
gsl_complex_abs	function
(	O
gsl_complex	struct
z	double
)	O
{	O
return	O
hypot	function
(	O
GSL_REAL	O
(	O
z	double
)	O
,	O
GSL_IMAG	O
(	O
z	double
)	O
)	O
;	O
}	O
double	O
gsl_complex_abs2	function
(	O
gsl_complex	struct
z	double
)	O
{	O
double	O
x	double
=	O
GSL_REAL	O
(	O
z	double
)	O
;	O
double	O
y	double
=	O
GSL_IMAG	O
(	O
z	double
)	O
;	O
return	O
(	O
x	double
*	O
x	double
+	O
y	double
*	O
y	double
)	O
;	O
}	O
double	O
gsl_complex_logabs	function
(	O
gsl_complex	struct
z	double
)	O
{	O
double	O
xabs	double
=	O
fabs	function
(	O
GSL_REAL	O
(	O
z	double
)	O
)	O
;	O
double	O
yabs	double
=	O
fabs	function
(	O
GSL_IMAG	O
(	O
z	double
)	O
)	O
;	O
double	O
max	double
,	O
u	double
;	O
if	O
(	O
xabs	double
>=	O
yabs	double
)	O
{	O
max	double
=	O
xabs	double
;	O
u	double
=	O
yabs	double
/	O
xabs	double
;	O
}	O
else	O
{	O
max	double
=	O
yabs	double
;	O
u	double
=	O
xabs	double
/	O
yabs	double
;	O
}	O
return	O
log	function
(	O
max	double
)	O
+	O
0.5	int
*	O
log1p	function
(	O
u	double
*	O
u	double
)	O
;	O
}	O
gsl_complex	struct
gsl_complex_add	function
(	O
gsl_complex	struct
a	double
,	O
gsl_complex	struct
b	double
)	O
{	O
double	O
ar	double
=	O
GSL_REAL	O
(	O
a	double
)	O
,	O
ai	double
=	O
GSL_IMAG	O
(	O
a	double
)	O
;	O
double	O
br	double
=	O
GSL_REAL	O
(	O
b	double
)	O
,	O
bi	double
=	O
GSL_IMAG	O
(	O
b	double
)	O
;	O
gsl_complex	struct
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
ar	double
+	O
br	double
,	O
ai	double
+	O
bi	double
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_add_real	function
(	O
gsl_complex	struct
a	double
,	O
double	O
x	double
)	O
{	O
gsl_complex	struct
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
GSL_REAL	O
(	O
a	double
)	O
+	O
x	double
,	O
GSL_IMAG	O
(	O
a	double
)	O
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_add_imag	function
(	O
gsl_complex	struct
a	double
,	O
double	O
y	double
)	O
{	O
gsl_complex	struct
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
GSL_REAL	O
(	O
a	double
)	O
,	O
GSL_IMAG	O
(	O
a	double
)	O
+	O
y	double
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_sub	function
(	O
gsl_complex	struct
a	double
,	O
gsl_complex	struct
b	double
)	O
{	O
double	O
ar	double
=	O
GSL_REAL	O
(	O
a	double
)	O
,	O
ai	double
=	O
GSL_IMAG	O
(	O
a	double
)	O
;	O
double	O
br	double
=	O
GSL_REAL	O
(	O
b	double
)	O
,	O
bi	double
=	O
GSL_IMAG	O
(	O
b	double
)	O
;	O
gsl_complex	struct
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
ar	double
-	O
br	double
,	O
ai	double
-	O
bi	double
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_sub_real	function
(	O
gsl_complex	struct
a	double
,	O
double	O
x	double
)	O
{	O
gsl_complex	struct
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
GSL_REAL	O
(	O
a	double
)	O
-	O
x	double
,	O
GSL_IMAG	O
(	O
a	double
)	O
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_sub_imag	function
(	O
gsl_complex	struct
a	double
,	O
double	O
y	double
)	O
{	O
gsl_complex	struct
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
GSL_REAL	O
(	O
a	double
)	O
,	O
GSL_IMAG	O
(	O
a	double
)	O
-	O
y	double
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_mul	function
(	O
gsl_complex	struct
a	double
,	O
gsl_complex	struct
b	double
)	O
{	O
double	O
ar	double
=	O
GSL_REAL	O
(	O
a	double
)	O
,	O
ai	double
=	O
GSL_IMAG	O
(	O
a	double
)	O
;	O
double	O
br	double
=	O
GSL_REAL	O
(	O
b	double
)	O
,	O
bi	double
=	O
GSL_IMAG	O
(	O
b	double
)	O
;	O
gsl_complex	struct
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
ar	double
*	O
br	double
-	O
ai	double
*	O
bi	double
,	O
ar	double
*	O
bi	double
+	O
ai	double
*	O
br	double
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_mul_real	function
(	O
gsl_complex	struct
a	double
,	O
double	O
x	double
)	O
{	O
gsl_complex	struct
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
x	double
*	O
GSL_REAL	O
(	O
a	double
)	O
,	O
x	double
*	O
GSL_IMAG	O
(	O
a	double
)	O
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_mul_imag	function
(	O
gsl_complex	struct
a	double
,	O
double	O
y	double
)	O
{	O
gsl_complex	struct
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
-	O
y	double
*	O
GSL_IMAG	O
(	O
a	double
)	O
,	O
y	double
*	O
GSL_REAL	O
(	O
a	double
)	O
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_div	function
(	O
gsl_complex	struct
a	double
,	O
gsl_complex	struct
b	double
)	O
{	O
double	O
ar	double
=	O
GSL_REAL	O
(	O
a	double
)	O
,	O
ai	double
=	O
GSL_IMAG	O
(	O
a	double
)	O
;	O
double	O
br	double
=	O
GSL_REAL	O
(	O
b	double
)	O
,	O
bi	double
=	O
GSL_IMAG	O
(	O
b	double
)	O
;	O
double	O
s	double
=	O
1.0	int
/	O
gsl_complex_abs	function
(	O
b	double
)	O
;	O
double	O
sbr	double
=	O
s	double
*	O
br	double
;	O
double	O
sbi	double
=	O
s	double
*	O
bi	double
;	O
double	O
zr	double
=	O
(	O
ar	double
*	O
sbr	double
+	O
ai	double
*	O
sbi	double
)	O
*	O
s	double
;	O
double	O
zi	double
=	O
(	O
ai	double
*	O
sbr	double
-	O
ar	double
*	O
sbi	double
)	O
*	O
s	double
;	O
gsl_complex	struct
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
zr	double
,	O
zi	double
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_div_real	function
(	O
gsl_complex	struct
a	double
,	O
double	O
x	double
)	O
{	O
gsl_complex	struct
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
GSL_REAL	O
(	O
a	double
)	O
/	O
x	double
,	O
GSL_IMAG	O
(	O
a	double
)	O
/	O
x	double
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_div_imag	function
(	O
gsl_complex	struct
a	double
,	O
double	O
y	double
)	O
{	O
gsl_complex	struct
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
GSL_IMAG	O
(	O
a	double
)	O
/	O
y	double
,	O
-	O
GSL_REAL	O
(	O
a	double
)	O
/	O
y	double
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_conjugate	function
(	O
gsl_complex	struct
a	double
)	O
{	O
gsl_complex	struct
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
GSL_REAL	O
(	O
a	double
)	O
,	O
-	O
GSL_IMAG	O
(	O
a	double
)	O
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_negative	function
(	O
gsl_complex	struct
a	double
)	O
{	O
gsl_complex	struct
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
-	O
GSL_REAL	O
(	O
a	double
)	O
,	O
-	O
GSL_IMAG	O
(	O
a	double
)	O
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_inverse	function
(	O
gsl_complex	struct
a	double
)	O
{	O
double	O
s	double
=	O
1.0	int
/	O
gsl_complex_abs	function
(	O
a	double
)	O
;	O
gsl_complex	struct
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
(	O
GSL_REAL	O
(	O
a	double
)	O
*	O
s	double
)	O
*	O
s	double
,	O
-	O
(	O
GSL_IMAG	O
(	O
a	double
)	O
*	O
s	double
)	O
*	O
s	double
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_sqrt	function
(	O
gsl_complex	struct
a	double
)	O
{	O
gsl_complex	struct
z	double
;	O
if	O
(	O
GSL_REAL	O
(	O
a	double
)	O
==	O
0.0	int
&&	O
GSL_IMAG	O
(	O
a	double
)	O
==	O
0.0	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
0	int
,	O
0	int
)	O
;	O
}	O
else	O
{	O
double	O
x	double
=	O
fabs	function
(	O
GSL_REAL	O
(	O
a	double
)	O
)	O
;	O
double	O
y	double
=	O
fabs	function
(	O
GSL_IMAG	O
(	O
a	double
)	O
)	O
;	O
double	O
w	double
;	O
if	O
(	O
x	double
>=	O
y	double
)	O
{	O
double	O
t	double
=	O
y	double
/	O
x	double
;	O
w	double
=	O
sqrt	function
(	O
x	double
)	O
*	O
sqrt	function
(	O
0.5	int
*	O
(	O
1.0	int
+	O
sqrt	function
(	O
1.0	int
+	O
t	double
*	O
t	double
)	O
)	O
)	O
;	O
}	O
else	O
{	O
double	O
t	double
=	O
x	double
/	O
y	double
;	O
w	double
=	O
sqrt	function
(	O
y	double
)	O
*	O
sqrt	function
(	O
0.5	int
*	O
(	O
t	double
+	O
sqrt	function
(	O
1.0	int
+	O
t	double
*	O
t	double
)	O
)	O
)	O
;	O
}	O
if	O
(	O
GSL_REAL	O
(	O
a	double
)	O
>=	O
0.0	int
)	O
{	O
double	O
ai	double
=	O
GSL_IMAG	O
(	O
a	double
)	O
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
w	double
,	O
ai	double
/	O
(	O
2.0	int
*	O
w	double
)	O
)	O
;	O
}	O
else	O
{	O
double	O
ai	double
=	O
GSL_IMAG	O
(	O
a	double
)	O
;	O
double	O
vi	double
=	O
(	O
ai	double
>=	O
0	int
)	O
?	O
w	double
:	O
-	O
w	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
ai	double
/	O
(	O
2.0	int
*	O
vi	double
)	O
,	O
vi	double
)	O
;	O
}	O
}	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_sqrt_real	function
(	O
double	O
x	double
)	O
{	O
gsl_complex	struct
z	double
;	O
if	O
(	O
x	double
>=	O
0	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
sqrt	function
(	O
x	double
)	O
,	O
0.0	int
)	O
;	O
}	O
else	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
0.0	int
,	O
sqrt	function
(	O
-	O
x	double
)	O
)	O
;	O
}	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_exp	function
(	O
gsl_complex	struct
a	double
)	O
{	O
double	O
rho	double
=	O
exp	function
(	O
GSL_REAL	O
(	O
a	double
)	O
)	O
;	O
double	O
theta	double
=	O
GSL_IMAG	O
(	O
a	double
)	O
;	O
gsl_complex	struct
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
rho	double
*	O
cos	function
(	O
theta	double
)	O
,	O
rho	double
*	O
sin	function
(	O
theta	double
)	O
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_pow	function
(	O
gsl_complex	struct
a	double
,	O
gsl_complex	struct
b	double
)	O
{	O
gsl_complex	struct
z	double
;	O
if	O
(	O
GSL_REAL	O
(	O
a	double
)	O
==	O
0	int
&&	O
GSL_IMAG	O
(	O
a	double
)	O
==	O
0.0	int
)	O
{	O
if	O
(	O
GSL_REAL	O
(	O
b	double
)	O
==	O
0	int
&&	O
GSL_IMAG	O
(	O
b	double
)	O
==	O
0.0	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
1.0	int
,	O
0.0	int
)	O
;	O
}	O
else	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
0.0	int
,	O
0.0	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
GSL_REAL	O
(	O
b	double
)	O
==	O
1.0	int
&&	O
GSL_IMAG	O
(	O
b	double
)	O
==	O
0.0	int
)	O
{	O
return	O
a	double
;	O
}	O
else	O
if	O
(	O
GSL_REAL	O
(	O
b	double
)	O
==	O
-	O
1.0	int
&&	O
GSL_IMAG	O
(	O
b	double
)	O
==	O
0.0	int
)	O
{	O
return	O
gsl_complex_inverse	function
(	O
a	double
)	O
;	O
}	O
else	O
{	O
double	O
logr	double
=	O
gsl_complex_logabs	function
(	O
a	double
)	O
;	O
double	O
theta	double
=	O
gsl_complex_arg	function
(	O
a	double
)	O
;	O
double	O
br	double
=	O
GSL_REAL	O
(	O
b	double
)	O
,	O
bi	double
=	O
GSL_IMAG	O
(	O
b	double
)	O
;	O
double	O
rho	double
=	O
exp	function
(	O
logr	double
*	O
br	double
-	O
bi	double
*	O
theta	double
)	O
;	O
double	O
beta	double
=	O
theta	double
*	O
br	double
+	O
bi	double
*	O
logr	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
rho	double
*	O
cos	function
(	O
beta	double
)	O
,	O
rho	double
*	O
sin	function
(	O
beta	double
)	O
)	O
;	O
}	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_pow_real	function
(	O
gsl_complex	struct
a	double
,	O
double	O
b	double
)	O
{	O
gsl_complex	struct
z	double
;	O
if	O
(	O
GSL_REAL	O
(	O
a	double
)	O
==	O
0	int
&&	O
GSL_IMAG	O
(	O
a	double
)	O
==	O
0	int
)	O
{	O
if	O
(	O
b	double
==	O
0	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
1	int
,	O
0	int
)	O
;	O
}	O
else	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
0	int
,	O
0	int
)	O
;	O
}	O
}	O
else	O
{	O
double	O
logr	double
=	O
gsl_complex_logabs	function
(	O
a	double
)	O
;	O
double	O
theta	double
=	O
gsl_complex_arg	function
(	O
a	double
)	O
;	O
double	O
rho	double
=	O
exp	function
(	O
logr	double
*	O
b	double
)	O
;	O
double	O
beta	double
=	O
theta	double
*	O
b	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
rho	double
*	O
cos	function
(	O
beta	double
)	O
,	O
rho	double
*	O
sin	function
(	O
beta	double
)	O
)	O
;	O
}	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_log	function
(	O
gsl_complex	struct
a	double
)	O
{	O
double	O
logr	double
=	O
gsl_complex_logabs	function
(	O
a	double
)	O
;	O
double	O
theta	double
=	O
gsl_complex_arg	function
(	O
a	double
)	O
;	O
gsl_complex	struct
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
logr	double
,	O
theta	double
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_log10	function
(	O
gsl_complex	struct
a	double
)	O
{	O
return	O
gsl_complex_mul_real	function
(	O
gsl_complex_log	function
(	O
a	double
)	O
,	O
1	int
/	O
log	function
(	O
10.	int
)	O
)	O
;	O
}	O
gsl_complex	struct
gsl_complex_log_b	function
(	O
gsl_complex	struct
a	double
,	O
gsl_complex	struct
b	double
)	O
{	O
return	O
gsl_complex_div	function
(	O
gsl_complex_log	function
(	O
a	double
)	O
,	O
gsl_complex_log	function
(	O
b	double
)	O
)	O
;	O
}	O
gsl_complex	struct
gsl_complex_sin	function
(	O
gsl_complex	struct
a	double
)	O
{	O
double	O
R	double
=	O
GSL_REAL	O
(	O
a	double
)	O
,	O
I	double
=	O
GSL_IMAG	O
(	O
a	double
)	O
;	O
gsl_complex	struct
z	double
;	O
if	O
(	O
I	double
==	O
0.0	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
sin	function
(	O
R	double
)	O
,	O
0.0	int
)	O
;	O
}	O
else	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
sin	function
(	O
R	double
)	O
*	O
cosh	function
(	O
I	double
)	O
,	O
cos	function
(	O
R	double
)	O
*	O
sinh	function
(	O
I	double
)	O
)	O
;	O
}	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_cos	function
(	O
gsl_complex	struct
a	double
)	O
{	O
double	O
R	double
=	O
GSL_REAL	O
(	O
a	double
)	O
,	O
I	double
=	O
GSL_IMAG	O
(	O
a	double
)	O
;	O
gsl_complex	struct
z	double
;	O
if	O
(	O
I	double
==	O
0.0	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
cos	function
(	O
R	double
)	O
,	O
0.0	int
)	O
;	O
}	O
else	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
cos	function
(	O
R	double
)	O
*	O
cosh	function
(	O
I	double
)	O
,	O
sin	function
(	O
R	double
)	O
*	O
sinh	function
(	O
-	O
I	double
)	O
)	O
;	O
}	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_tan	function
(	O
gsl_complex	struct
a	double
)	O
{	O
double	O
R	double
=	O
GSL_REAL	O
(	O
a	double
)	O
,	O
I	double
=	O
GSL_IMAG	O
(	O
a	double
)	O
;	O
gsl_complex	struct
z	double
;	O
if	O
(	O
fabs	function
(	O
I	double
)	O
<	O
1	int
)	O
{	O
double	O
D	double
=	O
pow	function
(	O
cos	function
(	O
R	double
)	O
,	O
2.0	int
)	O
+	O
pow	function
(	O
sinh	function
(	O
I	double
)	O
,	O
2.0	int
)	O
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
0.5	int
*	O
sin	function
(	O
2	int
*	O
R	double
)	O
/	O
D	double
,	O
0.5	int
*	O
sinh	function
(	O
2	int
*	O
I	double
)	O
/	O
D	double
)	O
;	O
}	O
else	O
{	O
double	O
D	double
=	O
pow	function
(	O
cos	function
(	O
R	double
)	O
,	O
2.0	int
)	O
+	O
pow	function
(	O
sinh	function
(	O
I	double
)	O
,	O
2.0	int
)	O
;	O
double	O
F	double
=	O
1	int
+	O
pow	function
(	O
cos	function
(	O
R	double
)	O
/	O
sinh	function
(	O
I	double
)	O
,	O
2.0	int
)	O
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
0.5	int
*	O
sin	function
(	O
2	int
*	O
R	double
)	O
/	O
D	double
,	O
1	int
/	O
(	O
tanh	function
(	O
I	double
)	O
*	O
F	double
)	O
)	O
;	O
}	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_sec	function
(	O
gsl_complex	struct
a	double
)	O
{	O
gsl_complex	struct
z	double
=	O
gsl_complex_cos	function
(	O
a	double
)	O
;	O
return	O
gsl_complex_inverse	function
(	O
z	double
)	O
;	O
}	O
gsl_complex	struct
gsl_complex_csc	function
(	O
gsl_complex	struct
a	double
)	O
{	O
gsl_complex	struct
z	double
=	O
gsl_complex_sin	function
(	O
a	double
)	O
;	O
return	O
gsl_complex_inverse	function
(	O
z	double
)	O
;	O
}	O
gsl_complex	struct
gsl_complex_cot	function
(	O
gsl_complex	struct
a	double
)	O
{	O
gsl_complex	struct
z	double
=	O
gsl_complex_tan	function
(	O
a	double
)	O
;	O
return	O
gsl_complex_inverse	function
(	O
z	double
)	O
;	O
}	O
gsl_complex	struct
gsl_complex_arcsin	function
(	O
gsl_complex	struct
a	double
)	O
{	O
double	O
R	double
=	O
GSL_REAL	O
(	O
a	double
)	O
,	O
I	double
=	O
GSL_IMAG	O
(	O
a	double
)	O
;	O
gsl_complex	struct
z	double
;	O
if	O
(	O
I	double
==	O
0	int
)	O
{	O
z	double
=	O
gsl_complex_arcsin_real	function
(	O
R	double
)	O
;	O
}	O
else	O
{	O
double	O
x	double
=	O
fabs	function
(	O
R	double
)	O
,	O
y	double
=	O
fabs	function
(	O
I	double
)	O
;	O
double	O
r	double
=	O
hypot	function
(	O
x	double
+	O
1	int
,	O
y	double
)	O
,	O
s	double
=	O
hypot	function
(	O
x	double
-	O
1	int
,	O
y	double
)	O
;	O
double	O
A	double
=	O
0.5	int
*	O
(	O
r	double
+	O
s	double
)	O
;	O
double	O
B	double
=	O
x	double
/	O
A	double
;	O
double	O
y2	double
=	O
y	double
*	O
y	double
;	O
double	O
real	double
,	O
imag	double
;	O
const	O
double	O
A_crossover	double
=	O
1.5	int
,	O
B_crossover	double
=	O
0.6417	int
;	O
if	O
(	O
B	double
<=	O
B_crossover	double
)	O
{	O
real	double
=	O
asin	function
(	O
B	double
)	O
;	O
}	O
else	O
{	O
if	O
(	O
x	double
<=	O
1	int
)	O
{	O
double	O
D	double
=	O
0.5	int
*	O
(	O
A	double
+	O
x	double
)	O
*	O
(	O
y2	double
/	O
(	O
r	double
+	O
x	double
+	O
1	int
)	O
+	O
(	O
s	double
+	O
(	O
1	int
-	O
x	double
)	O
)	O
)	O
;	O
real	double
=	O
atan	function
(	O
x	double
/	O
sqrt	function
(	O
D	double
)	O
)	O
;	O
}	O
else	O
{	O
double	O
Apx	double
=	O
A	double
+	O
x	double
;	O
double	O
D	double
=	O
0.5	int
*	O
(	O
Apx	double
/	O
(	O
r	double
+	O
x	double
+	O
1	int
)	O
+	O
Apx	double
/	O
(	O
s	double
+	O
(	O
x	double
-	O
1	int
)	O
)	O
)	O
;	O
real	double
=	O
atan	function
(	O
x	double
/	O
(	O
y	double
*	O
sqrt	function
(	O
D	double
)	O
)	O
)	O
;	O
}	O
}	O
if	O
(	O
A	double
<=	O
A_crossover	double
)	O
{	O
double	O
Am1	double
;	O
if	O
(	O
x	double
<	O
1	int
)	O
{	O
Am1	double
=	O
0.5	int
*	O
(	O
y2	double
/	O
(	O
r	double
+	O
(	O
x	double
+	O
1	int
)	O
)	O
+	O
y2	double
/	O
(	O
s	double
+	O
(	O
1	int
-	O
x	double
)	O
)	O
)	O
;	O
}	O
else	O
{	O
Am1	double
=	O
0.5	int
*	O
(	O
y2	double
/	O
(	O
r	double
+	O
(	O
x	double
+	O
1	int
)	O
)	O
+	O
(	O
s	double
+	O
(	O
x	double
-	O
1	int
)	O
)	O
)	O
;	O
}	O
imag	double
=	O
log1p	function
(	O
Am1	double
+	O
sqrt	function
(	O
Am1	double
*	O
(	O
A	double
+	O
1	int
)	O
)	O
)	O
;	O
}	O
else	O
{	O
imag	double
=	O
log	function
(	O
A	double
+	O
sqrt	function
(	O
A	double
*	O
A	double
-	O
1	int
)	O
)	O
;	O
}	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
(	O
R	double
>=	O
0	int
)	O
?	O
real	double
:	O
-	O
real	double
,	O
(	O
I	double
>=	O
0	int
)	O
?	O
imag	double
:	O
-	O
imag	double
)	O
;	O
}	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_arcsin_real	function
(	O
double	O
a	double
)	O
{	O
gsl_complex	struct
z	double
;	O
if	O
(	O
fabs	function
(	O
a	double
)	O
<=	O
1.0	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
asin	function
(	O
a	double
)	O
,	O
0.0	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
a	double
<	O
0.0	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
-	O
M_PI_2	int
,	O
acosh	function
(	O
-	O
a	double
)	O
)	O
;	O
}	O
else	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
M_PI_2	int
,	O
-	O
acosh	function
(	O
a	double
)	O
)	O
;	O
}	O
}	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_arccos	function
(	O
gsl_complex	struct
a	double
)	O
{	O
double	O
R	double
=	O
GSL_REAL	O
(	O
a	double
)	O
,	O
I	double
=	O
GSL_IMAG	O
(	O
a	double
)	O
;	O
gsl_complex	struct
z	double
;	O
if	O
(	O
I	double
==	O
0	int
)	O
{	O
z	double
=	O
gsl_complex_arccos_real	function
(	O
R	double
)	O
;	O
}	O
else	O
{	O
double	O
x	double
=	O
fabs	function
(	O
R	double
)	O
,	O
y	double
=	O
fabs	function
(	O
I	double
)	O
;	O
double	O
r	double
=	O
hypot	function
(	O
x	double
+	O
1	int
,	O
y	double
)	O
,	O
s	double
=	O
hypot	function
(	O
x	double
-	O
1	int
,	O
y	double
)	O
;	O
double	O
A	double
=	O
0.5	int
*	O
(	O
r	double
+	O
s	double
)	O
;	O
double	O
B	double
=	O
x	double
/	O
A	double
;	O
double	O
y2	double
=	O
y	double
*	O
y	double
;	O
double	O
real	double
,	O
imag	double
;	O
const	O
double	O
A_crossover	double
=	O
1.5	int
,	O
B_crossover	double
=	O
0.6417	int
;	O
if	O
(	O
B	double
<=	O
B_crossover	double
)	O
{	O
real	double
=	O
acos	function
(	O
B	double
)	O
;	O
}	O
else	O
{	O
if	O
(	O
x	double
<=	O
1	int
)	O
{	O
double	O
D	double
=	O
0.5	int
*	O
(	O
A	double
+	O
x	double
)	O
*	O
(	O
y2	double
/	O
(	O
r	double
+	O
x	double
+	O
1	int
)	O
+	O
(	O
s	double
+	O
(	O
1	int
-	O
x	double
)	O
)	O
)	O
;	O
real	double
=	O
atan	function
(	O
sqrt	function
(	O
D	double
)	O
/	O
x	double
)	O
;	O
}	O
else	O
{	O
double	O
Apx	double
=	O
A	double
+	O
x	double
;	O
double	O
D	double
=	O
0.5	int
*	O
(	O
Apx	double
/	O
(	O
r	double
+	O
x	double
+	O
1	int
)	O
+	O
Apx	double
/	O
(	O
s	double
+	O
(	O
x	double
-	O
1	int
)	O
)	O
)	O
;	O
real	double
=	O
atan	function
(	O
(	O
y	double
*	O
sqrt	function
(	O
D	double
)	O
)	O
/	O
x	double
)	O
;	O
}	O
}	O
if	O
(	O
A	double
<=	O
A_crossover	double
)	O
{	O
double	O
Am1	double
;	O
if	O
(	O
x	double
<	O
1	int
)	O
{	O
Am1	double
=	O
0.5	int
*	O
(	O
y2	double
/	O
(	O
r	double
+	O
(	O
x	double
+	O
1	int
)	O
)	O
+	O
y2	double
/	O
(	O
s	double
+	O
(	O
1	int
-	O
x	double
)	O
)	O
)	O
;	O
}	O
else	O
{	O
Am1	double
=	O
0.5	int
*	O
(	O
y2	double
/	O
(	O
r	double
+	O
(	O
x	double
+	O
1	int
)	O
)	O
+	O
(	O
s	double
+	O
(	O
x	double
-	O
1	int
)	O
)	O
)	O
;	O
}	O
imag	double
=	O
log1p	function
(	O
Am1	double
+	O
sqrt	function
(	O
Am1	double
*	O
(	O
A	double
+	O
1	int
)	O
)	O
)	O
;	O
}	O
else	O
{	O
imag	double
=	O
log	function
(	O
A	double
+	O
sqrt	function
(	O
A	double
*	O
A	double
-	O
1	int
)	O
)	O
;	O
}	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
(	O
R	double
>=	O
0	int
)	O
?	O
real	double
:	O
M_PI	int
-	O
real	double
,	O
(	O
I	double
>=	O
0	int
)	O
?	O
-	O
imag	double
:	O
imag	double
)	O
;	O
}	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_arccos_real	function
(	O
double	O
a	double
)	O
{	O
gsl_complex	struct
z	double
;	O
if	O
(	O
fabs	function
(	O
a	double
)	O
<=	O
1.0	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
acos	function
(	O
a	double
)	O
,	O
0	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
a	double
<	O
0.0	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
M_PI	int
,	O
-	O
acosh	function
(	O
-	O
a	double
)	O
)	O
;	O
}	O
else	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
0	int
,	O
acosh	function
(	O
a	double
)	O
)	O
;	O
}	O
}	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_arctan	function
(	O
gsl_complex	struct
a	double
)	O
{	O
double	O
R	double
=	O
GSL_REAL	O
(	O
a	double
)	O
,	O
I	double
=	O
GSL_IMAG	O
(	O
a	double
)	O
;	O
gsl_complex	struct
z	double
;	O
if	O
(	O
I	double
==	O
0	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
atan	function
(	O
R	double
)	O
,	O
0	int
)	O
;	O
}	O
else	O
{	O
double	O
r	double
=	O
hypot	function
(	O
R	double
,	O
I	double
)	O
;	O
double	O
imag	double
;	O
double	O
u	double
=	O
2	int
*	O
I	double
/	O
(	O
1	int
+	O
r	double
*	O
r	double
)	O
;	O
if	O
(	O
fabs	function
(	O
u	double
)	O
<	O
0.1	int
)	O
{	O
imag	double
=	O
0.25	int
*	O
(	O
log1p	function
(	O
u	double
)	O
-	O
log1p	function
(	O
-	O
u	double
)	O
)	O
;	O
}	O
else	O
{	O
double	O
A	double
=	O
hypot	function
(	O
R	double
,	O
I	double
+	O
1	int
)	O
;	O
double	O
B	double
=	O
hypot	function
(	O
R	double
,	O
I	double
-	O
1	int
)	O
;	O
imag	double
=	O
0.5	int
*	O
log	function
(	O
A	double
/	O
B	double
)	O
;	O
}	O
if	O
(	O
R	double
==	O
0	int
)	O
{	O
if	O
(	O
I	double
>	O
1	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
M_PI_2	int
,	O
imag	double
)	O
;	O
}	O
else	O
if	O
(	O
I	double
<	O
-	O
1	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
-	O
M_PI_2	int
,	O
imag	double
)	O
;	O
}	O
else	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
0	int
,	O
imag	double
)	O
;	O
}	O
;	O
}	O
else	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
0.5	int
*	O
atan2	function
(	O
2	int
*	O
R	double
,	O
(	O
(	O
1	int
+	O
r	double
)	O
*	O
(	O
1	int
-	O
r	double
)	O
)	O
)	O
,	O
imag	double
)	O
;	O
}	O
}	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_arcsec	function
(	O
gsl_complex	struct
a	double
)	O
{	O
gsl_complex	struct
z	double
=	O
gsl_complex_inverse	function
(	O
a	double
)	O
;	O
return	O
gsl_complex_arccos	function
(	O
z	double
)	O
;	O
}	O
gsl_complex	struct
gsl_complex_arcsec_real	function
(	O
double	O
a	double
)	O
{	O
gsl_complex	struct
z	double
;	O
if	O
(	O
a	double
<=	O
-	O
1.0	int
||	O
a	double
>=	O
1.0	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
acos	function
(	O
1	int
/	O
a	double
)	O
,	O
0.0	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
a	double
>=	O
0.0	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
0	int
,	O
acosh	function
(	O
1	int
/	O
a	double
)	O
)	O
;	O
}	O
else	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
M_PI	int
,	O
-	O
acosh	function
(	O
-	O
1	int
/	O
a	double
)	O
)	O
;	O
}	O
}	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_arccsc	function
(	O
gsl_complex	struct
a	double
)	O
{	O
gsl_complex	struct
z	double
=	O
gsl_complex_inverse	function
(	O
a	double
)	O
;	O
return	O
gsl_complex_arcsin	function
(	O
z	double
)	O
;	O
}	O
gsl_complex	struct
gsl_complex_arccsc_real	function
(	O
double	O
a	double
)	O
{	O
gsl_complex	struct
z	double
;	O
if	O
(	O
a	double
<=	O
-	O
1.0	int
||	O
a	double
>=	O
1.0	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
asin	function
(	O
1	int
/	O
a	double
)	O
,	O
0.0	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
a	double
>=	O
0.0	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
M_PI_2	int
,	O
-	O
acosh	function
(	O
1	int
/	O
a	double
)	O
)	O
;	O
}	O
else	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
-	O
M_PI_2	int
,	O
acosh	function
(	O
-	O
1	int
/	O
a	double
)	O
)	O
;	O
}	O
}	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_arccot	function
(	O
gsl_complex	struct
a	double
)	O
{	O
gsl_complex	struct
z	double
;	O
if	O
(	O
GSL_REAL	O
(	O
a	double
)	O
==	O
0.0	int
&&	O
GSL_IMAG	O
(	O
a	double
)	O
==	O
0.0	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
M_PI_2	int
,	O
0	int
)	O
;	O
}	O
else	O
{	O
z	double
=	O
gsl_complex_inverse	function
(	O
a	double
)	O
;	O
z	double
=	O
gsl_complex_arctan	function
(	O
z	double
)	O
;	O
}	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_sinh	function
(	O
gsl_complex	struct
a	double
)	O
{	O
double	O
R	double
=	O
GSL_REAL	O
(	O
a	double
)	O
,	O
I	double
=	O
GSL_IMAG	O
(	O
a	double
)	O
;	O
gsl_complex	struct
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
sinh	function
(	O
R	double
)	O
*	O
cos	function
(	O
I	double
)	O
,	O
cosh	function
(	O
R	double
)	O
*	O
sin	function
(	O
I	double
)	O
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_cosh	function
(	O
gsl_complex	struct
a	double
)	O
{	O
double	O
R	double
=	O
GSL_REAL	O
(	O
a	double
)	O
,	O
I	double
=	O
GSL_IMAG	O
(	O
a	double
)	O
;	O
gsl_complex	struct
z	double
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
cosh	function
(	O
R	double
)	O
*	O
cos	function
(	O
I	double
)	O
,	O
sinh	function
(	O
R	double
)	O
*	O
sin	function
(	O
I	double
)	O
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_tanh	function
(	O
gsl_complex	struct
a	double
)	O
{	O
double	O
R	double
=	O
GSL_REAL	O
(	O
a	double
)	O
,	O
I	double
=	O
GSL_IMAG	O
(	O
a	double
)	O
;	O
gsl_complex	struct
z	double
;	O
if	O
(	O
fabs	function
(	O
R	double
)	O
<	O
1.0	int
)	O
{	O
double	O
D	double
=	O
pow	function
(	O
cos	function
(	O
I	double
)	O
,	O
2.0	int
)	O
+	O
pow	function
(	O
sinh	function
(	O
R	double
)	O
,	O
2.0	int
)	O
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
sinh	function
(	O
R	double
)	O
*	O
cosh	function
(	O
R	double
)	O
/	O
D	double
,	O
0.5	int
*	O
sin	function
(	O
2	int
*	O
I	double
)	O
/	O
D	double
)	O
;	O
}	O
else	O
{	O
double	O
D	double
=	O
pow	function
(	O
cos	function
(	O
I	double
)	O
,	O
2.0	int
)	O
+	O
pow	function
(	O
sinh	function
(	O
R	double
)	O
,	O
2.0	int
)	O
;	O
double	O
F	double
=	O
1	int
+	O
pow	function
(	O
cos	function
(	O
I	double
)	O
/	O
sinh	function
(	O
R	double
)	O
,	O
2.0	int
)	O
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
1.0	int
/	O
(	O
tanh	function
(	O
R	double
)	O
*	O
F	double
)	O
,	O
0.5	int
*	O
sin	function
(	O
2	int
*	O
I	double
)	O
/	O
D	double
)	O
;	O
}	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_sech	function
(	O
gsl_complex	struct
a	double
)	O
{	O
gsl_complex	struct
z	double
=	O
gsl_complex_cosh	function
(	O
a	double
)	O
;	O
return	O
gsl_complex_inverse	function
(	O
z	double
)	O
;	O
}	O
gsl_complex	struct
gsl_complex_csch	function
(	O
gsl_complex	struct
a	double
)	O
{	O
gsl_complex	struct
z	double
=	O
gsl_complex_sinh	function
(	O
a	double
)	O
;	O
return	O
gsl_complex_inverse	function
(	O
z	double
)	O
;	O
}	O
gsl_complex	struct
gsl_complex_coth	function
(	O
gsl_complex	struct
a	double
)	O
{	O
gsl_complex	struct
z	double
=	O
gsl_complex_tanh	function
(	O
a	double
)	O
;	O
return	O
gsl_complex_inverse	function
(	O
z	double
)	O
;	O
}	O
gsl_complex	struct
gsl_complex_arcsinh	function
(	O
gsl_complex	struct
a	double
)	O
{	O
gsl_complex	struct
z	double
=	O
gsl_complex_mul_imag	function
(	O
a	double
,	O
1.0	int
)	O
;	O
z	double
=	O
gsl_complex_arcsin	function
(	O
z	double
)	O
;	O
z	double
=	O
gsl_complex_mul_imag	function
(	O
z	double
,	O
-	O
1.0	int
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_arccosh	function
(	O
gsl_complex	struct
a	double
)	O
{	O
gsl_complex	struct
z	double
=	O
gsl_complex_arccos	function
(	O
a	double
)	O
;	O
z	double
=	O
gsl_complex_mul_imag	function
(	O
z	double
,	O
GSL_IMAG	O
(	O
z	double
)	O
>	O
0	int
?	O
-	O
1.0	int
:	O
1.0	int
)	O
;	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_arccosh_real	function
(	O
double	O
a	double
)	O
{	O
gsl_complex	struct
z	double
;	O
if	O
(	O
a	double
>=	O
1	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
acosh	function
(	O
a	double
)	O
,	O
0	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
a	double
>=	O
-	O
1.0	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
0	int
,	O
acos	function
(	O
a	double
)	O
)	O
;	O
}	O
else	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
acosh	function
(	O
-	O
a	double
)	O
,	O
M_PI	int
)	O
;	O
}	O
}	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_arctanh	function
(	O
gsl_complex	struct
a	double
)	O
{	O
if	O
(	O
GSL_IMAG	O
(	O
a	double
)	O
==	O
0.0	int
)	O
{	O
return	O
gsl_complex_arctanh_real	function
(	O
GSL_REAL	O
(	O
a	double
)	O
)	O
;	O
}	O
else	O
{	O
gsl_complex	struct
z	double
=	O
gsl_complex_mul_imag	function
(	O
a	double
,	O
1.0	int
)	O
;	O
z	double
=	O
gsl_complex_arctan	function
(	O
z	double
)	O
;	O
z	double
=	O
gsl_complex_mul_imag	function
(	O
z	double
,	O
-	O
1.0	int
)	O
;	O
return	O
z	double
;	O
}	O
}	O
gsl_complex	struct
gsl_complex_arctanh_real	function
(	O
double	O
a	double
)	O
{	O
gsl_complex	struct
z	double
;	O
if	O
(	O
a	double
>	O
-	O
1.0	int
&&	O
a	double
<	O
1.0	int
)	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
atanh	function
(	O
a	double
)	O
,	O
0	int
)	O
;	O
}	O
else	O
{	O
GSL_SET_COMPLEX	O
(	O
&	O
z	double
,	O
atanh	function
(	O
1	int
/	O
a	double
)	O
,	O
(	O
a	double
<	O
0	int
)	O
?	O
M_PI_2	int
:	O
-	O
M_PI_2	int
)	O
;	O
}	O
return	O
z	double
;	O
}	O
gsl_complex	struct
gsl_complex_arcsech	function
(	O
gsl_complex	struct
a	double
)	O
{	O
gsl_complex	struct
t	double
=	O
gsl_complex_inverse	function
(	O
a	double
)	O
;	O
return	O
gsl_complex_arccosh	function
(	O
t	double
)	O
;	O
}	O
gsl_complex	struct
gsl_complex_arccsch	function
(	O
gsl_complex	struct
a	double
)	O
{	O
gsl_complex	struct
t	double
=	O
gsl_complex_inverse	function
(	O
a	double
)	O
;	O
return	O
gsl_complex_arcsinh	function
(	O
t	double
)	O
;	O
}	O
gsl_complex	struct
gsl_complex_arccoth	function
(	O
gsl_complex	struct
a	double
)	O
{	O
gsl_complex	struct
t	double
=	O
gsl_complex_inverse	function
(	O
a	double
)	O
;	O
return	O
gsl_complex_arctanh	function
(	O
t	double
)	O
;	O
}	O
