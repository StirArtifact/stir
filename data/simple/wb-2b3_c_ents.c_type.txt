LCK	struct
*	O
*	O
lck_tab	pointer
=	O
0	int
;	O
ENTRY	struct
*	O
*	O
buk_tab	pointer
=	O
0	int
;	O
ENTRY	struct
*	O
*	O
ent_tab	pointer
=	O
0	int
;	O
long	O
num_ents_ct	long
=	O
0x0L	int
;	O
int	O
num_buks	int
=	O
0	int
;	O
int	O
blk_size	int
=	O
0	int
;	O
int	O
cache_ent_enable_P	int
=	O
!	O
0	int
;	O
int	O
ents_ent_write	function
(	O
ENTRY	struct
*	O
ent	pointer
)	O
{	O
SEGD	struct
*	O
seg	pointer
=	O
ent_seg	O
(	O
ent	pointer
)	O
;	O
unsigned	O
char	O
*	O
blk	pointer
=	O
ent_blk	O
(	O
ent	pointer
)	O
;	O
if	O
(	O
!	O
(	O
blk_typ_P	O
(	O
blk	pointer
,	O
seq_typ	int
)	O
)	O
)	O
check_key_order	function
(	O
blk	pointer
)	O
;	O
blk_set_time	O
(	O
blk	pointer
,	O
time	function
(	O
0L	int
)	O
)	O
;	O
if	O
(	O
!	O
(	O
seg_mutable_P	O
(	O
seg	pointer
)	O
)	O
)	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< %s on read only segment %ld?\n"	pointer
,	O
"ent_write"	pointer
,	O
seg_id	O
(	O
seg	pointer
)	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
blkio_write	function
(	O
seg_port	O
(	O
seg	pointer
)	O
,	O
blk	pointer
,	O
seg_bsiz	O
(	O
seg	pointer
)	O
,	O
ent_id	O
(	O
ent	pointer
)	O
)	O
)	O
{	O
ent_set_dty	O
(	O
ent	pointer
,	O
0	int
)	O
;	O
return	O
!	O
0	int
;	O
}	O
else	O
{	O
ent_set_dty	O
(	O
ent	pointer
,	O
!	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
}	O
int	O
flush_ent_cntr	int
=	O
0	int
;	O
LCK	struct
flush_ent_lock	struct
=	O
{	O
0	int
,	O
-	O
2	int
,	O
PTHREAD_MUTEX_INITIALIZER	O
}	O
;	O
LCK	struct
*	O
flush_ent_lck	pointer
=	O
&	O
flush_ent_lock	struct
;	O
int	O
ents_flush	function
(	O
long	O
trynum	long
,	O
long	O
flushnum	long
)	O
{	O
long	O
flushednum	long
=	O
0x0L	int
;	O
if	O
(	O
(	O
flush_ent_lck	pointer
)	O
&&	O
(	O
try_lck_P	function
(	O
flush_ent_lck	pointer
)	O
)	O
)	O
{	O
long	O
i_ct	long
=	O
trynum	long
;	O
while	O
(	O
!	O
(	O
(	O
!	O
(	O
i_ct	long
)	O
)	O
||	O
(	O
(	O
flushednum	long
)	O
>=	O
(	O
flushnum	long
)	O
)	O
)	O
)	O
{	O
flush_ent_cntr	int
=	O
(	O
1	int
+	O
(	O
flush_ent_cntr	int
)	O
)	O
%	O
(	O
num_ents_ct	long
)	O
;	O
{	O
ENTRY	struct
*	O
tent	pointer
=	O
ent_tab	pointer
[	O
flush_ent_cntr	int
]	O
;	O
if	O
(	O
(	O
ent_dty_P	O
(	O
tent	pointer
)	O
)	O
&&	O
(	O
!	O
(	O
ent_acc	O
(	O
tent	pointer
)	O
)	O
)	O
&&	O
(	O
ent_flush_P	function
(	O
tent	pointer
)	O
)	O
)	O
{	O
show_buffer_1	function
(	O
tent	pointer
)	O
;	O
flushednum	long
=	O
(	O
flushednum	long
)	O
+	O
0x1L	int
;	O
}	O
}	O
{	O
i_ct	long
=	O
(	O
i_ct	long
)	O
-	O
0x1L	int
;	O
}	O
}	O
unlck	function
(	O
flush_ent_lck	pointer
)	O
;	O
return	O
flushednum	long
;	O
}	O
else	O
return	O
0	int
;	O
}	O
int	O
ent_flush_P	function
(	O
ENTRY	struct
*	O
tent	pointer
)	O
{	O
SEGD	struct
*	O
e_seg	pointer
=	O
ent_seg	O
(	O
tent	pointer
)	O
;	O
long	O
e_id	long
=	O
ent_id	O
(	O
tent	pointer
)	O
;	O
get_buk_lck_P	O
(	O
seg_id	O
(	O
e_seg	pointer
)	O
,	O
e_id	long
)	O
;	O
{	O
ENTRY	struct
*	O
ent	pointer
=	O
get_buk	O
(	O
seg_id	O
(	O
e_seg	pointer
)	O
,	O
e_id	long
)	O
;	O
L_loop	O
:	O
if	O
(	O
!	O
(	O
ent	pointer
)	O
)	O
{	O
rel_buk	O
(	O
seg_id	O
(	O
e_seg	pointer
)	O
,	O
e_id	long
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
(	O
tent	pointer
)	O
!=	O
(	O
ent	pointer
)	O
)	O
{	O
ent	pointer
=	O
ent_next	O
(	O
ent	pointer
)	O
;	O
goto	O
L_loop	O
;	O
}	O
else	O
if	O
(	O
!	O
(	O
(	O
ent_dty_P	O
(	O
ent	pointer
)	O
)	O
&&	O
(	O
(	O
accnone	O
)	O
==	O
(	O
ent_acc	O
(	O
ent	pointer
)	O
)	O
)	O
)	O
)	O
{	O
rel_buk	O
(	O
seg_id	O
(	O
e_seg	pointer
)	O
,	O
e_id	long
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
ent_set_acc	O
(	O
ent	pointer
,	O
accpend	O
)	O
;	O
rel_buk	O
(	O
seg_id	O
(	O
e_seg	pointer
)	O
,	O
e_id	long
)	O
;	O
ents_ent_write	function
(	O
ent	pointer
)	O
;	O
get_buk_wait	O
(	O
seg_id	O
(	O
e_seg	pointer
)	O
,	O
e_id	long
)	O
;	O
ent_set_acc	O
(	O
ent	pointer
,	O
accnone	O
)	O
;	O
rel_buk	O
(	O
seg_id	O
(	O
e_seg	pointer
)	O
,	O
e_id	long
)	O
;	O
flush_ct	long
=	O
(	O
flush_ct	long
)	O
+	O
0x1L	int
;	O
return	O
!	O
0	int
;	O
}	O
}	O
}	O
void	O
release_ent	function
(	O
ENTRY	struct
*	O
ent	pointer
,	O
int	O
accmode	int
)	O
{	O
long	O
blknum	long
=	O
ent_id	O
(	O
ent	pointer
)	O
;	O
SEGD	struct
*	O
seg	pointer
=	O
ent_seg	O
(	O
ent	pointer
)	O
;	O
ENTRY	struct
*	O
buk	pointer
=	O
0	int
;	O
buk	pointer
=	O
get_buk_wait	O
(	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blknum	long
)	O
;	O
if	O
(	O
(	O
(	O
accnone	O
)	O
!=	O
(	O
accmode	int
)	O
)	O
&&	O
(	O
(	O
ent_acc	O
(	O
ent	pointer
)	O
)	O
!=	O
(	O
accmode	int
)	O
)	O
)	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< %s: unexpected accmode of %ld:%ld is %d not %d\n"	pointer
,	O
"release_ent"	pointer
,	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blknum	long
,	O
ent_acc	O
(	O
ent	pointer
)	O
,	O
accmode	int
)	O
)	O
;	O
if	O
(	O
(	O
accnone	O
)	O
==	O
(	O
accmode	int
)	O
)	O
;	O
else	O
if	O
(	O
!	O
(	O
ent_dty_P	O
(	O
ent	pointer
)	O
)	O
)	O
;	O
else	O
if	O
(	O
(	O
blk_typ_P	O
(	O
ent_blk	O
(	O
ent	pointer
)	O
,	O
dir_typ	int
)	O
)	O
&&	O
(	O
leaf_P	O
(	O
ent_blk	O
(	O
ent	pointer
)	O
)	O
)	O
)	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
"WARNING: Directory block %ld:%ld dirty at RELEASE-ENT! \n"	pointer
,	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blknum	long
)	O
)	O
;	O
dir_dty_ct	long
=	O
0x1L	int
+	O
(	O
dir_dty_ct	long
)	O
;	O
}	O
else	O
if	O
(	O
blk_typ_P	O
(	O
ent_blk	O
(	O
ent	pointer
)	O
,	O
seq_typ	int
)	O
)	O
{	O
rel_buk	O
(	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blknum	long
)	O
;	O
ents_ent_write	function
(	O
ent	pointer
)	O
;	O
buk	pointer
=	O
get_buk_wait	O
(	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blknum	long
)	O
;	O
}	O
if	O
(	O
(	O
accnone	O
)	O
!=	O
(	O
accmode	int
)	O
)	O
ent_set_acc	O
(	O
ent	pointer
,	O
accnone	O
)	O
;	O
if	O
(	O
(	O
ent_ref	O
(	O
ent	pointer
)	O
)	O
<=	O
0	int
)	O
{	O
ent_set_ref	O
(	O
ent	pointer
,	O
0	int
)	O
;	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< REF count below 0 in %ld:%ld\n"	pointer
,	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blknum	long
)	O
)	O
;	O
}	O
else	O
ent_set_ref	O
(	O
ent	pointer
,	O
(	O
ent_ref	O
(	O
ent	pointer
)	O
)	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
(	O
seg	pointer
)	O
)	O
{	O
splice_out_ent	function
(	O
seg	pointer
,	O
blknum	long
,	O
buk	pointer
,	O
ent	pointer
)	O
;	O
}	O
else	O
ent_set_age	O
(	O
ent	pointer
,	O
(	O
(	O
ent_dty_P	O
(	O
ent	pointer
)	O
?	O
5	int
:	O
0	int
)	O
)	O
+	O
(	O
5	int
*	O
(	O
6	int
+	O
(	O
(	O
leaf	int
)	O
-	O
(	O
blk_level	O
(	O
ent_blk	O
(	O
ent	pointer
)	O
)	O
)	O
)	O
)	O
)	O
)	O
;	O
rel_buk	O
(	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blknum	long
)	O
;	O
return	O
;	O
}	O
int	O
ents_ent_update_access_P	function
(	O
ENTRY	struct
*	O
ent	pointer
,	O
int	O
old_accmode	int
,	O
int	O
new_accmode	int
)	O
{	O
get_buk_wait	O
(	O
seg_id	O
(	O
ent_seg	O
(	O
ent	pointer
)	O
)	O
,	O
ent_id	O
(	O
ent	pointer
)	O
)	O
;	O
if	O
(	O
(	O
ent_acc	O
(	O
ent	pointer
)	O
)	O
!=	O
(	O
old_accmode	int
)	O
)	O
{	O
rel_buk	O
(	O
seg_id	O
(	O
ent_seg	O
(	O
ent	pointer
)	O
)	O
,	O
ent_id	O
(	O
ent	pointer
)	O
)	O
;	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< unexpected accmode type on %ld:%ld %d (expected %d)\n"	pointer
,	O
seg_id	O
(	O
ent_seg	O
(	O
ent	pointer
)	O
)	O
,	O
ent_id	O
(	O
ent	pointer
)	O
,	O
ent_acc	O
(	O
ent	pointer
)	O
,	O
old_accmode	int
)	O
)	O
;	O
}	O
if	O
(	O
(	O
accnone	O
)	O
==	O
(	O
old_accmode	int
)	O
)	O
;	O
else	O
if	O
(	O
!	O
(	O
ent_dty_P	O
(	O
ent	pointer
)	O
)	O
)	O
;	O
else	O
if	O
(	O
blk_typ_P	O
(	O
ent_blk	O
(	O
ent	pointer
)	O
,	O
seq_typ	int
)	O
)	O
{	O
rel_buk	O
(	O
seg_id	O
(	O
ent_seg	O
(	O
ent	pointer
)	O
)	O
,	O
ent_id	O
(	O
ent	pointer
)	O
)	O
;	O
ents_ent_write	function
(	O
ent	pointer
)	O
;	O
get_buk_wait	O
(	O
seg_id	O
(	O
ent_seg	O
(	O
ent	pointer
)	O
)	O
,	O
ent_id	O
(	O
ent	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
(	O
blk_typ_P	O
(	O
ent_blk	O
(	O
ent	pointer
)	O
,	O
dir_typ	int
)	O
)	O
&&	O
(	O
leaf_P	O
(	O
ent_blk	O
(	O
ent	pointer
)	O
)	O
)	O
)	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
"WARNING: Directory block %ld:%ld dirty at ENT-UPD-ACCESS! \n"	pointer
,	O
seg_id	O
(	O
ent_seg	O
(	O
ent	pointer
)	O
)	O
,	O
ent_id	O
(	O
ent	pointer
)	O
)	O
)	O
;	O
dir_dty_ct	long
=	O
0x1L	int
+	O
(	O
dir_dty_ct	long
)	O
;	O
}	O
ent_set_acc	O
(	O
ent	pointer
,	O
new_accmode	int
)	O
;	O
rel_buk	O
(	O
seg_id	O
(	O
ent_seg	O
(	O
ent	pointer
)	O
)	O
,	O
ent_id	O
(	O
ent	pointer
)	O
)	O
;	O
return	O
(	O
ent	pointer
)	O
&&	O
!	O
0	int
;	O
}	O
int	O
free_buk_cntr	int
=	O
0	int
;	O
ENTRY	struct
*	O
free_ents	pointer
=	O
0	int
;	O
LCK	struct
free_ent_lock	struct
=	O
{	O
0	int
,	O
-	O
1	int
,	O
PTHREAD_MUTEX_INITIALIZER	O
}	O
;	O
LCK	struct
*	O
free_ent_lck	pointer
=	O
&	O
free_ent_lock	struct
;	O
ENTRY	struct
*	O
get_free_free_ent	function
(	O
void	O
)	O
{	O
lck	function
(	O
free_ent_lck	pointer
)	O
;	O
if	O
(	O
free_ents	pointer
)	O
{	O
ENTRY	struct
*	O
free_ent	pointer
=	O
free_ents	pointer
;	O
free_ents	pointer
=	O
ent_next	O
(	O
free_ents	pointer
)	O
;	O
unlck	function
(	O
free_ent_lck	pointer
)	O
;	O
return	O
free_ent	pointer
;	O
}	O
else	O
return	O
0	int
;	O
}	O
void	O
splice_out_ent	function
(	O
SEGD	struct
*	O
seg	pointer
,	O
long	O
blk_num	long
,	O
ENTRY	struct
*	O
buk	pointer
,	O
ENTRY	struct
*	O
ent	pointer
)	O
{	O
{	O
ENTRY	struct
*	O
bent	pointer
=	O
buk	pointer
;	O
ENTRY	struct
*	O
lastent	pointer
=	O
0	int
;	O
while	O
(	O
!	O
(	O
(	O
!	O
(	O
bent	pointer
)	O
)	O
||	O
(	O
(	O
bent	pointer
)	O
==	O
(	O
ent	pointer
)	O
)	O
)	O
)	O
{	O
{	O
ENTRY	struct
*	O
T_bent	pointer
=	O
ent_next	O
(	O
bent	pointer
)	O
;	O
lastent	pointer
=	O
bent	pointer
;	O
bent	pointer
=	O
T_bent	pointer
;	O
}	O
}	O
if	O
(	O
bent	pointer
)	O
{	O
if	O
(	O
lastent	pointer
)	O
{	O
ent_set_next	O
(	O
lastent	pointer
,	O
ent_next	O
(	O
bent	pointer
)	O
)	O
;	O
}	O
else	O
set_buk	O
(	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blk_num	long
,	O
ent_next	O
(	O
bent	pointer
)	O
)	O
;	O
recycle_ent	function
(	O
bent	pointer
)	O
;	O
return	O
;	O
}	O
else	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
"WARNING: %s couldn't %ld:%ld\n"	pointer
,	O
"splice_out_ent"	pointer
,	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blk_num	long
)	O
)	O
;	O
return	O
;	O
}	O
}	O
void	O
recycle_ent	function
(	O
ENTRY	struct
*	O
ent	pointer
)	O
{	O
ent_set_dty	O
(	O
ent	pointer
,	O
0	int
)	O
;	O
ent_set_pus	O
(	O
ent	pointer
,	O
0	int
)	O
;	O
ent_set_seg	O
(	O
ent	pointer
,	O
0	int
)	O
;	O
ent_set_id	O
(	O
ent	pointer
,	O
0	int
)	O
;	O
lck	function
(	O
free_ent_lck	pointer
)	O
;	O
ent_set_ref	O
(	O
ent	pointer
,	O
0	int
)	O
;	O
ent_set_acc	O
(	O
ent	pointer
,	O
accnone	O
)	O
;	O
ent_set_next	O
(	O
ent	pointer
,	O
free_ents	pointer
)	O
;	O
free_ents	pointer
=	O
ent	pointer
;	O
unlck	function
(	O
free_ent_lck	pointer
)	O
;	O
return	O
;	O
}	O
ENTRY	struct
*	O
select_idle_ent	function
(	O
SEGD	struct
*	O
lseg	pointer
,	O
long	O
lblk_num	long
)	O
{	O
{	O
ENTRY	struct
*	O
oldest_ent	pointer
=	O
0	int
;	O
int	O
num_scan	int
=	O
max	O
(	O
min	O
(	O
num_buks	int
,	O
0xa	int
)	O
,	O
(	O
num_buks	int
)	O
/	O
0x14	int
)	O
;	O
int	O
free_base	int
=	O
free_buk_cntr	int
;	O
free_buk_cntr	int
=	O
(	O
(	O
num_scan	int
)	O
+	O
(	O
free_buk_cntr	int
)	O
)	O
%	O
(	O
num_buks	int
)	O
;	O
unlck	function
(	O
free_ent_lck	pointer
)	O
;	O
{	O
int	O
i	int
=	O
0	int
;	O
while	O
(	O
!	O
(	O
(	O
(	O
(	O
i	int
)	O
>	O
(	O
num_scan	int
)	O
)	O
&&	O
(	O
oldest_ent	pointer
)	O
)	O
||	O
(	O
(	O
i	int
)	O
>	O
(	O
num_buks	int
)	O
)	O
)	O
)	O
{	O
{	O
long	O
free_num	long
=	O
(	O
(	O
free_base	int
)	O
+	O
(	O
i	int
)	O
)	O
%	O
(	O
num_buks	int
)	O
;	O
int	O
dont_lock_P	int
=	O
!	O
(	O
lseg	pointer
)	O
?	O
0	int
:	O
(	O
free_num	long
)	O
==	O
(	O
hash2int	O
(	O
seg_id	O
(	O
lseg	pointer
)	O
,	O
lblk_num	long
)	O
)	O
;	O
if	O
(	O
(	O
dont_lock_P	int
)	O
||	O
(	O
get_buk_lck_P	O
(	O
0	int
,	O
free_num	long
)	O
)	O
)	O
{	O
ENTRY	struct
*	O
ent	pointer
=	O
get_buk	O
(	O
0	int
,	O
free_num	long
)	O
;	O
while	O
(	O
ent	pointer
)	O
{	O
if	O
(	O
!	O
(	O
ent_ref	O
(	O
ent	pointer
)	O
)	O
)	O
{	O
ent_set_age	O
(	O
ent	pointer
,	O
(	O
(	O
ent_dty_P	O
(	O
ent	pointer
)	O
?	O
1	int
:	O
2	int
)	O
)	O
+	O
(	O
ent_age	O
(	O
ent	pointer
)	O
)	O
)	O
;	O
if	O
(	O
(	O
(	O
accnone	O
)	O
==	O
(	O
ent_acc	O
(	O
ent	pointer
)	O
)	O
)	O
&&	O
(	O
(	O
!	O
(	O
oldest_ent	pointer
)	O
)	O
||	O
(	O
(	O
ent_age	O
(	O
ent	pointer
)	O
)	O
>	O
(	O
ent_age	O
(	O
oldest_ent	pointer
)	O
)	O
)	O
)	O
)	O
oldest_ent	pointer
=	O
ent	pointer
;	O
}	O
{	O
ent	pointer
=	O
ent_next	O
(	O
ent	pointer
)	O
;	O
}	O
}	O
if	O
(	O
dont_lock_P	int
)	O
;	O
else	O
rel_buk	O
(	O
0	int
,	O
free_num	long
)	O
;	O
}	O
}	O
{	O
i	int
=	O
(	O
i	int
)	O
+	O
1	int
;	O
}	O
}	O
if	O
(	O
(	O
i	int
)	O
>	O
(	O
num_buks	int
)	O
)	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< No free ents\n"	pointer
)	O
)	O
;	O
return	O
oldest_ent	pointer
;	O
}	O
}	O
}	O
ENTRY	struct
*	O
reclaim_ent	function
(	O
ENTRY	struct
*	O
ent	pointer
,	O
SEGD	struct
*	O
lseg	pointer
,	O
long	O
lblk_num	long
)	O
{	O
{	O
SEGD	struct
*	O
seg	pointer
=	O
ent_seg	O
(	O
ent	pointer
)	O
;	O
long	O
blk_num	long
=	O
ent_id	O
(	O
ent	pointer
)	O
;	O
int	O
segs_equal_P	int
=	O
(	O
lseg	pointer
)	O
&&	O
(	O
same_buk_P	O
(	O
seg_id	O
(	O
lseg	pointer
)	O
,	O
lblk_num	long
,	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blk_num	long
)	O
)	O
;	O
ENTRY	struct
*	O
buk	pointer
=	O
segs_equal_P	int
?	O
get_buk	O
(	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blk_num	long
)	O
:	O
get_buk_wait	O
(	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blk_num	long
)	O
;	O
if	O
(	O
(	O
ent_ref	O
(	O
ent	pointer
)	O
)	O
||	O
(	O
(	O
accnone	O
)	O
!=	O
(	O
ent_acc	O
(	O
ent	pointer
)	O
)	O
)	O
)	O
{	O
rel_buk	O
(	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blk_num	long
)	O
;	O
if	O
(	O
segs_equal_P	int
)	O
;	O
else	O
if	O
(	O
!	O
(	O
lseg	pointer
)	O
)	O
;	O
else	O
rel_buk	O
(	O
seg_id	O
(	O
lseg	pointer
)	O
,	O
lblk_num	long
)	O
;	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
"WARNING: %s: couldn't splice-out-ent %ld:%ld\n"	pointer
,	O
"reclaim_ent"	pointer
,	O
seg_id	O
(	O
lseg	pointer
)	O
,	O
lblk_num	long
)	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
ENTRY	struct
*	O
bent	pointer
=	O
buk	pointer
;	O
ENTRY	struct
*	O
lastent	pointer
=	O
0	int
;	O
while	O
(	O
!	O
(	O
(	O
!	O
(	O
bent	pointer
)	O
)	O
||	O
(	O
(	O
ent	pointer
)	O
==	O
(	O
bent	pointer
)	O
)	O
)	O
)	O
{	O
{	O
ENTRY	struct
*	O
T_bent	pointer
=	O
ent_next	O
(	O
bent	pointer
)	O
;	O
lastent	pointer
=	O
bent	pointer
;	O
bent	pointer
=	O
T_bent	pointer
;	O
}	O
}	O
if	O
(	O
!	O
(	O
bent	pointer
)	O
)	O
{	O
rel_buk	O
(	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blk_num	long
)	O
;	O
if	O
(	O
segs_equal_P	int
)	O
;	O
else	O
if	O
(	O
!	O
(	O
lseg	pointer
)	O
)	O
;	O
else	O
rel_buk	O
(	O
seg_id	O
(	O
lseg	pointer
)	O
,	O
lblk_num	long
)	O
;	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< %s: couldn't find ent in bucket %ld:%ld l=%ld:%ld\n"	pointer
,	O
"reclaim_ent"	pointer
,	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blk_num	long
,	O
seg_id	O
(	O
lseg	pointer
)	O
,	O
lblk_num	long
)	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
!	O
(	O
ent_dty_P	O
(	O
ent	pointer
)	O
)	O
)	O
{	O
if	O
(	O
lastent	pointer
)	O
{	O
ent_set_next	O
(	O
lastent	pointer
,	O
ent_next	O
(	O
ent	pointer
)	O
)	O
;	O
}	O
else	O
set_buk	O
(	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blk_num	long
,	O
ent_next	O
(	O
ent	pointer
)	O
)	O
;	O
ent_set_next	O
(	O
ent	pointer
,	O
0	int
)	O
;	O
if	O
(	O
segs_equal_P	int
)	O
;	O
else	O
rel_buk	O
(	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blk_num	long
)	O
;	O
return	O
ent	pointer
;	O
}	O
else	O
{	O
ent_set_acc	O
(	O
ent	pointer
,	O
accpend	O
)	O
;	O
rel_buk	O
(	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blk_num	long
)	O
;	O
if	O
(	O
segs_equal_P	int
)	O
;	O
else	O
if	O
(	O
!	O
(	O
lseg	pointer
)	O
)	O
;	O
else	O
rel_buk	O
(	O
seg_id	O
(	O
lseg	pointer
)	O
,	O
lblk_num	long
)	O
;	O
ents_ent_write	function
(	O
ent	pointer
)	O
;	O
buk	pointer
=	O
get_buk_wait	O
(	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blk_num	long
)	O
;	O
ent_set_acc	O
(	O
ent	pointer
,	O
accnone	O
)	O
;	O
splice_out_ent	function
(	O
seg	pointer
,	O
blk_num	long
,	O
buk	pointer
,	O
ent	pointer
)	O
;	O
rel_buk	O
(	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blk_num	long
)	O
;	O
return	O
0	int
;	O
}	O
}	O
}	O
}	O
ENTRY	struct
*	O
try_get_free_ent	function
(	O
SEGD	struct
*	O
lseg	pointer
,	O
long	O
lblk_num	long
)	O
{	O
ENTRY	struct
*	O
ent	pointer
=	O
get_free_free_ent	function
(	O
)	O
;	O
if	O
(	O
!	O
(	O
ent	pointer
)	O
)	O
{	O
ent	pointer
=	O
select_idle_ent	function
(	O
lseg	pointer
,	O
lblk_num	long
)	O
;	O
if	O
(	O
ent	pointer
)	O
{	O
ent	pointer
=	O
reclaim_ent	function
(	O
ent	pointer
,	O
lseg	pointer
,	O
lblk_num	long
)	O
;	O
}	O
else	O
if	O
(	O
!	O
(	O
lseg	pointer
)	O
)	O
;	O
else	O
rel_buk	O
(	O
seg_id	O
(	O
lseg	pointer
)	O
,	O
lblk_num	long
)	O
;	O
}	O
return	O
ent	pointer
;	O
}	O
ENTRY	struct
*	O
allocate_ent	function
(	O
void	O
)	O
{	O
{	O
ENTRY	struct
*	O
ent	pointer
=	O
try_get_free_ent	function
(	O
0	int
,	O
-	O
1	int
)	O
;	O
int	O
cnt	int
=	O
0x13	int
;	O
L_loop	O
:	O
if	O
(	O
ent	pointer
)	O
{	O
ent_set_acc	O
(	O
ent	pointer
,	O
accwrite	O
)	O
;	O
ent_set_dty	O
(	O
ent	pointer
,	O
!	O
0	int
)	O
;	O
ent_set_pus	O
(	O
ent	pointer
,	O
0	int
)	O
;	O
ent_set_seg	O
(	O
ent	pointer
,	O
0	int
)	O
;	O
ent_set_id	O
(	O
ent	pointer
,	O
0	int
)	O
;	O
ent_set_ref	O
(	O
ent	pointer
,	O
1	int
)	O
;	O
ent_set_next	O
(	O
ent	pointer
,	O
0	int
)	O
;	O
return	O
ent	pointer
;	O
}	O
else	O
if	O
(	O
!	O
(	O
cnt	int
)	O
)	O
return	O
0	int
;	O
else	O
{	O
ent	pointer
=	O
try_get_free_ent	function
(	O
0	int
,	O
-	O
1	int
)	O
;	O
cnt	int
=	O
-	O
1	int
+	O
(	O
cnt	int
)	O
;	O
goto	O
L_loop	O
;	O
}	O
}	O
}	O
void	O
ent_copy	function
(	O
ENTRY	struct
*	O
to_ent	pointer
,	O
ENTRY	struct
*	O
from_ent	pointer
)	O
{	O
if	O
(	O
(	O
ent_acc	O
(	O
to_ent	pointer
)	O
)	O
!=	O
(	O
accwrite	O
)	O
)	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< %s: copying into non-ACCWRITE %ld:%ld\n"	pointer
,	O
"ent_copy"	pointer
,	O
seg_id	O
(	O
ent_seg	O
(	O
to_ent	pointer
)	O
)	O
,	O
ent_id	O
(	O
to_ent	pointer
)	O
)	O
)	O
;	O
ent_set_seg	O
(	O
to_ent	pointer
,	O
ent_seg	O
(	O
from_ent	pointer
)	O
)	O
;	O
ent_set_id	O
(	O
to_ent	pointer
,	O
ent_id	O
(	O
from_ent	pointer
)	O
)	O
;	O
subbytes_move	O
(	O
ent_blk	O
(	O
from_ent	pointer
)	O
,	O
0	int
,	O
seg_bsiz	O
(	O
ent_seg	O
(	O
from_ent	pointer
)	O
)	O
,	O
ent_blk	O
(	O
to_ent	pointer
)	O
,	O
0	int
)	O
;	O
return	O
;	O
}	O
int	O
get_ent_copy	function
(	O
ENTRY	struct
*	O
to_ent	pointer
,	O
SEGD	struct
*	O
seg	pointer
,	O
long	O
blk_num	long
)	O
{	O
ENTRY	struct
*	O
from_ent	pointer
=	O
get_ent	function
(	O
seg	pointer
,	O
blk_num	long
,	O
accread	O
)	O
;	O
if	O
(	O
from_ent	pointer
)	O
{	O
ent_copy	function
(	O
to_ent	pointer
,	O
from_ent	pointer
)	O
;	O
release_ent	function
(	O
from_ent	pointer
,	O
accread	O
)	O
;	O
return	O
!	O
0	int
;	O
}	O
else	O
return	O
0	int
;	O
}	O
void	O
flush_flc	function
(	O
SEGD	struct
*	O
seg	pointer
,	O
int	O
fullness	int
)	O
{	O
L_flush_flc	O
:	O
{	O
unsigned	O
char	O
fstr	array
[	O
4	int
]	O
;	O
unsigned	O
char	O
tstr	array
[	O
4	int
]	O
;	O
lck	function
(	O
seg_lck	O
(	O
seg	pointer
)	O
)	O
;	O
if	O
(	O
(	O
seg_flc_len	O
(	O
seg	pointer
)	O
)	O
<=	O
(	O
fullness	int
)	O
)	O
{	O
unlck	function
(	O
seg_lck	O
(	O
seg	pointer
)	O
)	O
;	O
return	O
;	O
}	O
else	O
if	O
(	O
!	O
0	int
)	O
{	O
long2str	function
(	O
fstr	array
,	O
0	int
,	O
seg_flc	O
(	O
seg	pointer
)	O
[	O
(	O
seg_flc_len	O
(	O
seg	pointer
)	O
)	O
-	O
1	int
]	O
)	O
;	O
seg_set_flc_len	O
(	O
seg	pointer
,	O
(	O
seg_flc_len	O
(	O
seg	pointer
)	O
)	O
-	O
1	int
)	O
;	O
unlck	function
(	O
seg_lck	O
(	O
seg	pointer
)	O
)	O
;	O
long2str	function
(	O
tstr	array
,	O
0	int
,	O
time	function
(	O
0L	int
)	O
)	O
;	O
bt_put	function
(	O
seg_fl_han	O
(	O
seg	pointer
)	O
,	O
fstr	array
,	O
4	int
,	O
tstr	array
,	O
4	int
)	O
;	O
goto	O
L_flush_flc	O
;	O
}	O
}	O
}	O
int	O
initload_flc_P	function
(	O
SEGD	struct
*	O
seg	pointer
)	O
{	O
switch	O
(	O
seg_flc_len	O
(	O
seg	pointer
)	O
)	O
{	O
case	O
-	O
1	int
:	O
{	O
unsigned	O
char	O
tmp_str	array
[	O
0x14	int
]	O
;	O
int	O
flc_image_len	int
=	O
bt_get	function
(	O
seg_rt_han	O
(	O
seg	pointer
)	O
,	O
flc_byts	pointer
,	O
3	int
,	O
tmp_str	array
)	O
;	O
if	O
(	O
0	int
>	O
(	O
flc_image_len	int
)	O
)	O
flc_image_len	int
=	O
0	int
;	O
bt_put	function
(	O
seg_rt_han	O
(	O
seg	pointer
)	O
,	O
flc_byts	pointer
,	O
3	int
,	O
no_byts	pointer
,	O
0	int
)	O
;	O
seg_set_flc_len	O
(	O
seg	pointer
,	O
(	O
flc_image_len	int
)	O
/	O
4	int
)	O
;	O
{	O
int	O
i	int
=	O
-	O
4	int
+	O
(	O
flc_image_len	int
)	O
;	O
while	O
(	O
!	O
(	O
0	int
>	O
(	O
i	int
)	O
)	O
)	O
{	O
seg_flc	O
(	O
seg	pointer
)	O
[	O
(	O
i	int
)	O
/	O
4	int
]	O
=	O
str2long	function
(	O
tmp_str	array
,	O
i	int
)	O
;	O
{	O
i	int
=	O
-	O
4	int
+	O
(	O
i	int
)	O
;	O
}	O
}	O
}	O
}	O
return	O
!	O
0	int
;	O
case	O
-	O
2	int
:	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< %s on read only segment %ld?\n"	pointer
,	O
"initload_flc"	pointer
,	O
seg_id	O
(	O
seg	pointer
)	O
)	O
)	O
;	O
return	O
0	int
;	O
default	O
:	O
return	O
!	O
0	int
;	O
}	O
}	O
void	O
amnesia_ent	function
(	O
ENTRY	struct
*	O
ent	pointer
)	O
{	O
int	O
segid	int
=	O
seg_id	O
(	O
ent_seg	O
(	O
ent	pointer
)	O
)	O
;	O
{	O
int	O
hash	int
=	O
hash2int	O
(	O
segid	int
,	O
ent_id	O
(	O
ent	pointer
)	O
)	O
;	O
int	O
newid	int
=	O
hash2int	O
(	O
1	int
+	O
(	O
segid	int
)	O
,	O
ent_id	O
(	O
ent	pointer
)	O
)	O
;	O
ent_set_id	O
(	O
ent	pointer
,	O
newid	int
)	O
;	O
ent_set_seg	O
(	O
ent	pointer
,	O
0	int
)	O
;	O
if	O
(	O
(	O
hash	int
)	O
!=	O
(	O
hash2int	O
(	O
-	O
1	int
,	O
newid	int
)	O
)	O
)	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
"WARNING: %s: hash mismatch %d >< %ld\n"	pointer
,	O
"amnesia_ent"	pointer
,	O
hash	int
,	O
hash2int	O
(	O
-	O
1	int
,	O
newid	int
)	O
)	O
)	O
;	O
ent_set_dty	O
(	O
ent	pointer
,	O
0	int
)	O
;	O
ent_set_pus	O
(	O
ent	pointer
,	O
0	int
)	O
;	O
if	O
(	O
ent_blk	O
(	O
ent	pointer
)	O
)	O
if	O
(	O
blk_typ_P	O
(	O
ent_blk	O
(	O
ent	pointer
)	O
,	O
dir_typ	int
)	O
)	O
blk_set_typ	O
(	O
ent_blk	O
(	O
ent	pointer
)	O
,	O
ind_typ	int
)	O
;	O
ent_set_age	O
(	O
ent	pointer
,	O
0x80	int
)	O
;	O
return	O
;	O
}	O
}	O
int	O
blk_free	function
(	O
ENTRY	struct
*	O
ent	pointer
)	O
{	O
L_blk_free	O
:	O
{	O
SEGD	struct
*	O
seg	pointer
=	O
ent_seg	O
(	O
ent	pointer
)	O
;	O
if	O
(	O
(	O
ent_acc	O
(	O
ent	pointer
)	O
)	O
!=	O
(	O
accwrite	O
)	O
)	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< %s: %ld:%ld without ACCWRITE\n"	pointer
,	O
"blk_free"	pointer
,	O
seg_id	O
(	O
seg	pointer
)	O
,	O
ent_id	O
(	O
ent	pointer
)	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
lck	function
(	O
seg_lck	O
(	O
seg	pointer
)	O
)	O
;	O
if	O
(	O
!	O
(	O
initload_flc_P	function
(	O
seg	pointer
)	O
)	O
)	O
{	O
unlck	function
(	O
seg_lck	O
(	O
seg	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
(	O
seg_flc_len	O
(	O
seg	pointer
)	O
)	O
>=	O
(	O
(	O
flc_len	int
)	O
-	O
1	int
)	O
)	O
{	O
unlck	function
(	O
seg_lck	O
(	O
seg	pointer
)	O
)	O
;	O
flush_flc	function
(	O
seg	pointer
,	O
(	O
flc_len	int
)	O
-	O
2	int
)	O
;	O
goto	O
L_blk_free	O
;	O
}	O
else	O
{	O
seg_flc	O
(	O
seg	pointer
)	O
[	O
seg_flc_len	O
(	O
seg	pointer
)	O
]	O
=	O
ent_id	O
(	O
ent	pointer
)	O
;	O
seg_set_flc_len	O
(	O
seg	pointer
,	O
(	O
seg_flc_len	O
(	O
seg	pointer
)	O
)	O
+	O
1	int
)	O
;	O
amnesia_ent	function
(	O
ent	pointer
)	O
;	O
unlck	function
(	O
seg_lck	O
(	O
seg	pointer
)	O
)	O
;	O
return	O
!	O
0	int
;	O
}	O
}	O
}	O
}	O
int	O
flc_fill	function
(	O
SEGD	struct
*	O
seg	pointer
)	O
{	O
unsigned	O
char	O
fstr	array
[	O
4	int
]	O
;	O
int	O
flen	int
=	O
0	int
;	O
int	O
status	int
;	O
lck	function
(	O
seg_lck	O
(	O
seg	pointer
)	O
)	O
;	O
if	O
(	O
(	O
seg_flc_len	O
(	O
seg	pointer
)	O
)	O
>=	O
1	int
)	O
{	O
unlck	function
(	O
seg_lck	O
(	O
seg	pointer
)	O
)	O
;	O
return	O
success	int
;	O
}	O
else	O
if	O
(	O
!	O
(	O
try_lck_P	function
(	O
seg_fck	O
(	O
seg	pointer
)	O
)	O
)	O
)	O
{	O
unlck	function
(	O
seg_lck	O
(	O
seg	pointer
)	O
)	O
;	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
"WARNING: %s failed -- branch never tried before! Segment %ld %s\n"	pointer
,	O
"flc_fill"	pointer
,	O
seg_id	O
(	O
seg	pointer
)	O
,	O
seg_str	O
(	O
seg	pointer
)	O
)	O
)	O
;	O
return	O
retryerr	O
;	O
}	O
else	O
if	O
(	O
(	O
flen	int
=	O
bt_next	function
(	O
seg_fl_han	O
(	O
seg	pointer
)	O
,	O
no_byts	pointer
,	O
0	int
,	O
fstr	array
)	O
,	O
err_P	O
(	O
flen	int
)	O
)	O
)	O
{	O
long	O
xnum	long
=	O
(	O
seg_used	O
(	O
seg	pointer
)	O
)	O
+	O
(	O
(	O
flc_len	int
)	O
/	O
0x2L	int
)	O
;	O
if	O
(	O
blkio_file_extend	function
(	O
seg_port	O
(	O
seg	pointer
)	O
,	O
seg_bsiz	O
(	O
seg	pointer
)	O
,	O
xnum	long
)	O
)	O
{	O
{	O
int	O
i	int
=	O
0	int
;	O
while	O
(	O
!	O
(	O
(	O
i	int
)	O
>	O
(	O
(	O
flc_len	int
)	O
/	O
2	int
)	O
)	O
)	O
{	O
seg_flc	O
(	O
seg	pointer
)	O
[	O
seg_flc_len	O
(	O
seg	pointer
)	O
]	O
=	O
(	O
xnum	long
)	O
-	O
(	O
i	int
)	O
;	O
seg_set_flc_len	O
(	O
seg	pointer
,	O
(	O
seg_flc_len	O
(	O
seg	pointer
)	O
)	O
+	O
1	int
)	O
;	O
seg_set_used	O
(	O
seg	pointer
,	O
(	O
seg_used	O
(	O
seg	pointer
)	O
)	O
+	O
1	int
)	O
;	O
{	O
i	int
=	O
(	O
i	int
)	O
+	O
1	int
;	O
}	O
}	O
}	O
{	O
unsigned	O
char	O
used_str	array
[	O
4	int
]	O
;	O
long2str	function
(	O
used_str	array
,	O
0	int
,	O
seg_used	O
(	O
seg	pointer
)	O
)	O
;	O
bt_put	function
(	O
seg_rt_han	O
(	O
seg	pointer
)	O
,	O
used_byts	pointer
,	O
4	int
,	O
used_str	array
,	O
4	int
)	O
;	O
}	O
{	O
status	int
=	O
success	int
;	O
goto	O
L_unlck_and_return	O
;	O
}	O
}	O
else	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< No more file space available! Segment %ld %s\n"	pointer
,	O
seg_id	O
(	O
seg	pointer
)	O
,	O
seg_str	O
(	O
seg	pointer
)	O
)	O
)	O
;	O
{	O
status	int
=	O
noroom	O
;	O
goto	O
L_unlck_and_return	O
;	O
}	O
}	O
}	O
else	O
{	O
unlck	function
(	O
seg_lck	O
(	O
seg	pointer
)	O
)	O
;	O
{	O
long	O
long_ara	pointer
[	O
(	O
flc_len	int
)	O
+	O
1	int
]	O
;	O
unsigned	O
char	O
xstr	array
[	O
0x100	int
]	O
;	O
int	O
respkt	pointer
[	O
pkt_size	int
]	O
;	O
int	O
result	int
=	O
success	int
;	O
subbytes_move	O
(	O
fstr	array
,	O
0	int
,	O
flen	int
,	O
xstr	array
,	O
0	int
)	O
;	O
long_ara	pointer
[	O
0	int
]	O
=	O
0	int
;	O
pkt_set_skey_count	O
(	O
respkt	pointer
,	O
0	int
)	O
;	O
result	int
=	O
bt_scan	function
(	O
seg_fl_han	O
(	O
seg	pointer
)	O
,	O
rem_scan	O
,	O
xstr	array
,	O
flen	int
,	O
no_byts	pointer
,	O
end_of_chain	O
,	O
flc_proc	function
,	O
long_ara	pointer
,	O
respkt	pointer
,	O
1	int
)	O
;	O
if	O
(	O
(	O
(	O
result	int
)	O
==	O
(	O
success	int
)	O
)	O
||	O
(	O
(	O
result	int
)	O
==	O
(	O
notpres	O
)	O
)	O
||	O
(	O
(	O
result	int
)	O
==	O
(	O
terminated	O
)	O
)	O
)	O
{	O
lck	function
(	O
seg_lck	O
(	O
seg	pointer
)	O
)	O
;	O
{	O
int	O
i	int
=	O
long_ara	pointer
[	O
0	int
]	O
;	O
while	O
(	O
!	O
(	O
(	O
i	int
)	O
<=	O
0	int
)	O
)	O
{	O
seg_flc	O
(	O
seg	pointer
)	O
[	O
seg_flc_len	O
(	O
seg	pointer
)	O
]	O
=	O
long_ara	pointer
[	O
i	int
]	O
;	O
seg_set_flc_len	O
(	O
seg	pointer
,	O
(	O
seg_flc_len	O
(	O
seg	pointer
)	O
)	O
+	O
1	int
)	O
;	O
{	O
i	int
=	O
(	O
i	int
)	O
-	O
1	int
;	O
}	O
}	O
}	O
{	O
status	int
=	O
success	int
;	O
goto	O
L_unlck_and_return	O
;	O
}	O
}	O
else	O
{	O
unlck	function
(	O
seg_fck	O
(	O
seg	pointer
)	O
)	O
;	O
return	O
result	int
;	O
}	O
}	O
}	O
L_unlck_and_return	O
:	O
unlck	function
(	O
seg_lck	O
(	O
seg	pointer
)	O
)	O
;	O
unlck	function
(	O
seg_fck	O
(	O
seg	pointer
)	O
)	O
;	O
return	O
status	int
;	O
}	O
int	O
flc_proc	function
(	O
unsigned	O
char	O
*	O
keystr	pointer
,	O
int	O
klen	int
,	O
unsigned	O
char	O
*	O
vstr	pointer
,	O
int	O
vlen	int
,	O
long	O
*	O
long_ara	pointer
)	O
{	O
{	O
int	O
ct	int
=	O
long_ara	pointer
[	O
0	int
]	O
;	O
if	O
(	O
(	O
ct	int
)	O
<	O
(	O
(	O
flc_len	int
)	O
/	O
2	int
)	O
)	O
{	O
long	O
num	long
=	O
str2long	function
(	O
keystr	pointer
,	O
0	int
)	O
;	O
ct	int
=	O
(	O
ct	int
)	O
+	O
1	int
;	O
long_ara	pointer
[	O
0	int
]	O
=	O
ct	int
;	O
long_ara	pointer
[	O
ct	int
]	O
=	O
num	long
;	O
return	O
success	int
;	O
}	O
else	O
return	O
terminated	O
;	O
}	O
}	O
ENTRY	struct
*	O
create_new_blk_ent	function
(	O
SEGD	struct
*	O
seg	pointer
)	O
{	O
L_create_new_blk_ent	O
:	O
lck	function
(	O
seg_lck	O
(	O
seg	pointer
)	O
)	O
;	O
if	O
(	O
!	O
(	O
initload_flc_P	function
(	O
seg	pointer
)	O
)	O
)	O
{	O
unlck	function
(	O
seg_lck	O
(	O
seg	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
(	O
seg_flc_len	O
(	O
seg	pointer
)	O
)	O
<=	O
0	int
)	O
{	O
unlck	function
(	O
seg_lck	O
(	O
seg	pointer
)	O
)	O
;	O
if	O
(	O
!	O
(	O
realerr_P	O
(	O
flc_fill	function
(	O
seg	pointer
)	O
)	O
)	O
)	O
goto	O
L_create_new_blk_ent	O
;	O
else	O
return	O
0	int
;	O
}	O
else	O
{	O
seg_set_flc_len	O
(	O
seg	pointer
,	O
(	O
seg_flc_len	O
(	O
seg	pointer
)	O
)	O
-	O
1	int
)	O
;	O
{	O
long	O
bnum	long
=	O
seg_flc	O
(	O
seg	pointer
)	O
[	O
seg_flc_len	O
(	O
seg	pointer
)	O
]	O
;	O
unlck	function
(	O
seg_lck	O
(	O
seg	pointer
)	O
)	O
;	O
{	O
ENTRY	struct
*	O
ent	pointer
=	O
get_ent	function
(	O
seg	pointer
,	O
bnum	long
,	O
accwrite	O
)	O
;	O
if	O
(	O
ent	pointer
)	O
ent_set_dty	O
(	O
ent	pointer
,	O
!	O
0	int
)	O
;	O
return	O
ent	pointer
;	O
}	O
}	O
}	O
}	O
ENTRY	struct
*	O
try_get_ent	function
(	O
SEGD	struct
*	O
seg	pointer
,	O
long	O
blk_num	long
,	O
int	O
accmode	int
)	O
{	O
{	O
ENTRY	struct
*	O
buk	pointer
=	O
get_buk_wait	O
(	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blk_num	long
)	O
;	O
{	O
ENTRY	struct
*	O
ent	pointer
=	O
buk	pointer
;	O
L_entloop	O
:	O
if	O
(	O
!	O
(	O
ent	pointer
)	O
)	O
{	O
rel_buk	O
(	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blk_num	long
)	O
;	O
tge_fct	long
=	O
0x1L	int
+	O
(	O
tge_fct	long
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
!	O
(	O
(	O
(	O
seg	pointer
)	O
==	O
(	O
ent_seg	O
(	O
ent	pointer
)	O
)	O
)	O
&&	O
(	O
(	O
blk_num	long
)	O
==	O
(	O
ent_id	O
(	O
ent	pointer
)	O
)	O
)	O
)	O
)	O
{	O
ent	pointer
=	O
ent_next	O
(	O
ent	pointer
)	O
;	O
goto	O
L_entloop	O
;	O
}	O
else	O
if	O
(	O
(	O
blk_id	O
(	O
ent_blk	O
(	O
ent	pointer
)	O
)	O
)	O
!=	O
(	O
blk_num	long
)	O
)	O
{	O
rel_buk	O
(	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blk_num	long
)	O
;	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< corrutped buffer %ld:%ld <> %ld\n"	pointer
,	O
seg_id	O
(	O
ent_seg	O
(	O
ent	pointer
)	O
)	O
,	O
blk_id	O
(	O
ent_blk	O
(	O
ent	pointer
)	O
)	O
,	O
blk_num	long
)	O
)	O
;	O
tge_fct	long
=	O
0x1L	int
+	O
(	O
tge_fct	long
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
(	O
accnone	O
)	O
==	O
(	O
accmode	int
)	O
)	O
{	O
ent_set_ref	O
(	O
ent	pointer
,	O
1	int
+	O
(	O
ent_ref	O
(	O
ent	pointer
)	O
)	O
)	O
;	O
rel_buk	O
(	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blk_num	long
)	O
;	O
tge_ct	long
=	O
0x1L	int
+	O
(	O
tge_ct	long
)	O
;	O
return	O
ent	pointer
;	O
}	O
else	O
if	O
(	O
(	O
accnone	O
)	O
==	O
(	O
ent_acc	O
(	O
ent	pointer
)	O
)	O
)	O
{	O
ent_set_acc	O
(	O
ent	pointer
,	O
accmode	int
)	O
;	O
ent_set_ref	O
(	O
ent	pointer
,	O
1	int
+	O
(	O
ent_ref	O
(	O
ent	pointer
)	O
)	O
)	O
;	O
rel_buk	O
(	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blk_num	long
)	O
;	O
tge_ct	long
=	O
0x1L	int
+	O
(	O
tge_ct	long
)	O
;	O
return	O
ent	pointer
;	O
}	O
else	O
{	O
rel_buk	O
(	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blk_num	long
)	O
;	O
tge_fct	long
=	O
0x1L	int
+	O
(	O
tge_fct	long
)	O
;	O
return	O
0	int
;	O
}	O
}	O
}	O
}	O
ENTRY	struct
*	O
chain_find_ent	function
(	O
HAND	struct
*	O
han	pointer
,	O
int	O
accmode	int
,	O
unsigned	O
char	O
*	O
key_str	pointer
,	O
int	O
k_len	int
,	O
int	O
*	O
pkt	pointer
)	O
{	O
ENTRY	struct
*	O
ent	pointer
=	O
(	O
cache_ent_enable_P	int
)	O
&&	O
(	O
han_last	O
(	O
han	pointer
)	O
)	O
?	O
try_get_ent	function
(	O
han_seg	O
(	O
han	pointer
)	O
,	O
han_last	O
(	O
han	pointer
)	O
,	O
accmode	int
)	O
:	O
0	int
;	O
if	O
(	O
(	O
ent	pointer
)	O
&&	O
(	O
leaf_P	O
(	O
ent_blk	O
(	O
ent	pointer
)	O
)	O
)	O
&&	O
(	O
(	O
blk_top_id	O
(	O
ent_blk	O
(	O
ent	pointer
)	O
)	O
)	O
==	O
(	O
han_id	O
(	O
han	pointer
)	O
)	O
)	O
&&	O
(	O
blk_find_pos	function
(	O
ent_blk	O
(	O
ent	pointer
)	O
,	O
key_str	pointer
,	O
k_len	int
,	O
pkt	pointer
)	O
)	O
&&	O
(	O
(	O
(	O
pkt_match_type	O
(	O
pkt	pointer
)	O
)	O
==	O
(	O
match	O
)	O
)	O
||	O
(	O
(	O
(	O
(	O
pkt_match_type	O
(	O
pkt	pointer
)	O
)	O
==	O
(	O
pastp	O
)	O
)	O
||	O
(	O
(	O
pkt_match_type	O
(	O
pkt	pointer
)	O
)	O
==	O
(	O
qpastp	O
)	O
)	O
)	O
&&	O
(	O
(	O
pkt_match_pos	O
(	O
pkt	pointer
)	O
)	O
>	O
(	O
blk_data_start	int
)	O
)	O
)	O
)	O
)	O
{	O
tce_ct	long
=	O
(	O
tce_ct	long
)	O
+	O
0x1L	int
;	O
return	O
ent	pointer
;	O
}	O
else	O
{	O
if	O
(	O
ent	pointer
)	O
release_ent	function
(	O
ent	pointer
,	O
accmode	int
)	O
;	O
tce_fct	long
=	O
(	O
tce_fct	long
)	O
+	O
0x1L	int
;	O
ent	pointer
=	O
get_ent	function
(	O
han_seg	O
(	O
han	pointer
)	O
,	O
han_id	O
(	O
han	pointer
)	O
,	O
accnone	O
)	O
;	O
if	O
(	O
(	O
!	O
(	O
root_P	O
(	O
ent_blk	O
(	O
ent	pointer
)	O
)	O
)	O
)	O
||	O
(	O
blk_typ_P	O
(	O
ent_blk	O
(	O
ent	pointer
)	O
,	O
seq_typ	int
)	O
)	O
)	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< %s: not a B-tree root %ld:%ld\n"	pointer
,	O
"bt_open"	pointer
,	O
seg_id	O
(	O
ent_seg	O
(	O
ent	pointer
)	O
)	O
,	O
ent_id	O
(	O
ent	pointer
)	O
)	O
)	O
;	O
release_ent	function
(	O
ent	pointer
,	O
accnone	O
)	O
;	O
ent	pointer
=	O
0	int
;	O
}	O
else	O
ent	pointer
=	O
find_ent	function
(	O
ent	pointer
,	O
leaf	int
,	O
-	O
1	int
,	O
key_str	pointer
,	O
k_len	int
)	O
;	O
if	O
(	O
!	O
(	O
ent	pointer
)	O
)	O
;	O
else	O
if	O
(	O
(	O
accread	O
)	O
==	O
(	O
accmode	int
)	O
)	O
;	O
else	O
if	O
(	O
ents_ent_update_access_P	function
(	O
ent	pointer
,	O
accread	O
,	O
accmode	int
)	O
)	O
;	O
else	O
{	O
release_ent	function
(	O
ent	pointer
,	O
accread	O
)	O
;	O
ent	pointer
=	O
0	int
;	O
}	O
if	O
(	O
ent	pointer
)	O
ent	pointer
=	O
chain_find	function
(	O
ent	pointer
,	O
accmode	int
,	O
key_str	pointer
,	O
k_len	int
,	O
pkt	pointer
)	O
;	O
if	O
(	O
ent	pointer
)	O
han_set_last	O
(	O
han	pointer
,	O
ent_id	O
(	O
ent	pointer
)	O
)	O
;	O
return	O
ent	pointer
;	O
}	O
}	O
ENTRY	struct
*	O
chain_find_prev_ent	function
(	O
HAND	struct
*	O
han	pointer
,	O
int	O
accmode	int
,	O
unsigned	O
char	O
*	O
key_str	pointer
,	O
int	O
k_len	int
,	O
int	O
*	O
pkt	pointer
)	O
{	O
ENTRY	struct
*	O
ent	pointer
=	O
(	O
cache_ent_enable_P	int
)	O
&&	O
(	O
han_last	O
(	O
han	pointer
)	O
)	O
?	O
try_get_ent	function
(	O
han_seg	O
(	O
han	pointer
)	O
,	O
han_last	O
(	O
han	pointer
)	O
,	O
accmode	int
)	O
:	O
0	int
;	O
if	O
(	O
(	O
ent	pointer
)	O
&&	O
(	O
leaf_P	O
(	O
ent_blk	O
(	O
ent	pointer
)	O
)	O
)	O
&&	O
(	O
(	O
blk_top_id	O
(	O
ent_blk	O
(	O
ent	pointer
)	O
)	O
)	O
==	O
(	O
han_id	O
(	O
han	pointer
)	O
)	O
)	O
&&	O
(	O
blk_find_pos	function
(	O
ent_blk	O
(	O
ent	pointer
)	O
,	O
key_str	pointer
,	O
k_len	int
,	O
pkt	pointer
)	O
)	O
&&	O
(	O
(	O
(	O
pkt_match_type	O
(	O
pkt	pointer
)	O
)	O
==	O
(	O
match	O
)	O
)	O
||	O
(	O
(	O
pkt_match_type	O
(	O
pkt	pointer
)	O
)	O
==	O
(	O
matchend	O
)	O
)	O
||	O
(	O
(	O
(	O
(	O
pkt_match_type	O
(	O
pkt	pointer
)	O
)	O
==	O
(	O
pastp	O
)	O
)	O
||	O
(	O
(	O
pkt_match_type	O
(	O
pkt	pointer
)	O
)	O
==	O
(	O
qpastp	O
)	O
)	O
)	O
&&	O
(	O
(	O
pkt_match_pos	O
(	O
pkt	pointer
)	O
)	O
>	O
(	O
blk_data_start	int
)	O
)	O
)	O
)	O
)	O
{	O
tce_ct	long
=	O
(	O
tce_ct	long
)	O
+	O
0x1L	int
;	O
return	O
ent	pointer
;	O
}	O
else	O
{	O
if	O
(	O
ent	pointer
)	O
release_ent	function
(	O
ent	pointer
,	O
accmode	int
)	O
;	O
tce_fct	long
=	O
(	O
tce_fct	long
)	O
+	O
0x1L	int
;	O
ent	pointer
=	O
prev_find_prev_ent	function
(	O
get_ent	function
(	O
han_seg	O
(	O
han	pointer
)	O
,	O
han_id	O
(	O
han	pointer
)	O
,	O
accnone	O
)	O
,	O
leaf	int
,	O
-	O
1	int
,	O
key_str	pointer
,	O
k_len	int
)	O
;	O
if	O
(	O
!	O
(	O
ent	pointer
)	O
)	O
;	O
else	O
if	O
(	O
(	O
accmode	int
)	O
==	O
(	O
accread	O
)	O
)	O
;	O
else	O
if	O
(	O
ents_ent_update_access_P	function
(	O
ent	pointer
,	O
accread	O
,	O
accmode	int
)	O
)	O
;	O
else	O
{	O
release_ent	function
(	O
ent	pointer
,	O
accread	O
)	O
;	O
ent	pointer
=	O
0	int
;	O
}	O
return	O
ent	pointer
;	O
}	O
}	O
ENTRY	struct
*	O
get_ent	function
(	O
SEGD	struct
*	O
seg	pointer
,	O
long	O
blk_num	long
,	O
int	O
accmode	int
)	O
{	O
if	O
(	O
0	int
>	O
(	O
blk_num	long
)	O
)	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< negative block number %ld\n"	pointer
,	O
blk_num	long
)	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
(	O
blk_num	long
)	O
>=	O
(	O
seg_used	O
(	O
seg	pointer
)	O
)	O
)	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< bad block number %ld:%ld (>= %ld)\n"	pointer
,	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blk_num	long
,	O
seg_used	O
(	O
seg	pointer
)	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
ENTRY	struct
*	O
ent	pointer
=	O
get_buk_wait	O
(	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blk_num	long
)	O
;	O
L_entloop	O
:	O
if	O
(	O
!	O
(	O
ent	pointer
)	O
)	O
{	O
ent	pointer
=	O
try_get_free_ent	function
(	O
seg	pointer
,	O
blk_num	long
)	O
;	O
if	O
(	O
ent	pointer
)	O
{	O
ent_set_next	O
(	O
ent	pointer
,	O
get_buk	O
(	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blk_num	long
)	O
)	O
;	O
set_buk	O
(	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blk_num	long
,	O
ent	pointer
)	O
;	O
ent_set_acc	O
(	O
ent	pointer
,	O
accpend	O
)	O
;	O
ent_set_seg	O
(	O
ent	pointer
,	O
seg	pointer
)	O
;	O
ent_set_id	O
(	O
ent	pointer
,	O
blk_num	long
)	O
;	O
ent_set_age	O
(	O
ent	pointer
,	O
-	O
127	int
)	O
;	O
ent_set_dty	O
(	O
ent	pointer
,	O
0	int
)	O
;	O
ent_set_pus	O
(	O
ent	pointer
,	O
0	int
)	O
;	O
ent_set_ref	O
(	O
ent	pointer
,	O
1	int
)	O
;	O
rel_buk	O
(	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blk_num	long
)	O
;	O
if	O
(	O
(	O
accmode	int
)	O
==	O
(	O
accwrite	O
)	O
)	O
{	O
ent_set_acc	O
(	O
ent	pointer
,	O
accwrite	O
)	O
;	O
ent_set_dty	O
(	O
ent	pointer
,	O
!	O
0	int
)	O
;	O
init_leaf_blk	function
(	O
ent_blk	O
(	O
ent	pointer
)	O
,	O
blk_num	long
,	O
ind_typ	int
)	O
;	O
ge_ct	long
=	O
0x1L	int
+	O
(	O
ge_ct	long
)	O
;	O
return	O
ent	pointer
;	O
}	O
else	O
if	O
(	O
blkio_read	function
(	O
seg_port	O
(	O
seg	pointer
)	O
,	O
ent_blk	O
(	O
ent	pointer
)	O
,	O
seg_bsiz	O
(	O
seg	pointer
)	O
,	O
blk_num	long
)	O
)	O
{	O
ent_set_acc	O
(	O
ent	pointer
,	O
accmode	int
)	O
;	O
if	O
(	O
(	O
blk_id	O
(	O
ent_blk	O
(	O
ent	pointer
)	O
)	O
)	O
!=	O
(	O
blk_num	long
)	O
)	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< corrupted blk %ld:%ld <> %ld\n"	pointer
,	O
seg_id	O
(	O
ent_seg	O
(	O
ent	pointer
)	O
)	O
,	O
blk_num	long
,	O
blk_id	O
(	O
ent_blk	O
(	O
ent	pointer
)	O
)	O
)	O
)	O
;	O
ge_ct	long
=	O
0x1L	int
+	O
(	O
ge_ct	long
)	O
;	O
return	O
ent	pointer
;	O
}	O
else	O
{	O
ent_set_ref	O
(	O
ent	pointer
,	O
0	int
)	O
;	O
ent_set_acc	O
(	O
ent	pointer
,	O
accnone	O
)	O
;	O
ge_fct	long
=	O
0x1L	int
+	O
(	O
ge_fct	long
)	O
;	O
return	O
0	int
;	O
}	O
}	O
else	O
{	O
ent	pointer
=	O
get_buk_wait	O
(	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blk_num	long
)	O
;	O
goto	O
L_entloop	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
(	O
(	O
(	O
seg	pointer
)	O
==	O
(	O
ent_seg	O
(	O
ent	pointer
)	O
)	O
)	O
&&	O
(	O
(	O
blk_num	long
)	O
==	O
(	O
ent_id	O
(	O
ent	pointer
)	O
)	O
)	O
)	O
)	O
{	O
ent	pointer
=	O
ent_next	O
(	O
ent	pointer
)	O
;	O
goto	O
L_entloop	O
;	O
}	O
else	O
if	O
(	O
(	O
blk_id	O
(	O
ent_blk	O
(	O
ent	pointer
)	O
)	O
)	O
!=	O
(	O
blk_num	long
)	O
)	O
{	O
rel_buk	O
(	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blk_num	long
)	O
;	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< corrupted buffer %ld:%ld <> %ld\n"	pointer
,	O
seg_id	O
(	O
ent_seg	O
(	O
ent	pointer
)	O
)	O
,	O
blk_id	O
(	O
ent_blk	O
(	O
ent	pointer
)	O
)	O
,	O
blk_num	long
)	O
)	O
;	O
ge_fct	long
=	O
0x1L	int
+	O
(	O
ge_fct	long
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
(	O
accnone	O
)	O
==	O
(	O
accmode	int
)	O
)	O
{	O
ent_set_ref	O
(	O
ent	pointer
,	O
1	int
+	O
(	O
ent_ref	O
(	O
ent	pointer
)	O
)	O
)	O
;	O
rel_buk	O
(	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blk_num	long
)	O
;	O
ge_ct	long
=	O
0x1L	int
+	O
(	O
ge_ct	long
)	O
;	O
return	O
ent	pointer
;	O
}	O
else	O
if	O
(	O
(	O
accnone	O
)	O
==	O
(	O
ent_acc	O
(	O
ent	pointer
)	O
)	O
)	O
{	O
ent_set_acc	O
(	O
ent	pointer
,	O
accmode	int
)	O
;	O
ent_set_ref	O
(	O
ent	pointer
,	O
1	int
+	O
(	O
ent_ref	O
(	O
ent	pointer
)	O
)	O
)	O
;	O
rel_buk	O
(	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blk_num	long
)	O
;	O
ge_ct	long
=	O
0x1L	int
+	O
(	O
ge_ct	long
)	O
;	O
return	O
ent	pointer
;	O
}	O
else	O
{	O
rel_buk	O
(	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blk_num	long
)	O
;	O
ge_fct	long
=	O
0x1L	int
+	O
(	O
ge_fct	long
)	O
;	O
return	O
0	int
;	O
}	O
}	O
}	O
ENTRY	struct
*	O
switch_ent	function
(	O
ENTRY	struct
*	O
old_ent	pointer
,	O
int	O
oldacc	int
,	O
long	O
new_num	long
,	O
int	O
newacc	int
)	O
{	O
{	O
ENTRY	struct
*	O
new_ent	pointer
=	O
get_ent	function
(	O
ent_seg	O
(	O
old_ent	pointer
)	O
,	O
new_num	long
,	O
accnone	O
)	O
;	O
release_ent	function
(	O
old_ent	pointer
,	O
oldacc	int
)	O
;	O
if	O
(	O
new_ent	pointer
)	O
ents_ent_update_access_P	function
(	O
new_ent	pointer
,	O
accnone	O
,	O
newacc	int
)	O
;	O
return	O
new_ent	pointer
;	O
}	O
}	O
void	O
check_blk	function
(	O
unsigned	O
char	O
*	O
blk	pointer
)	O
{	O
{	O
int	O
b_end	int
=	O
blk_end	O
(	O
blk	pointer
)	O
;	O
{	O
int	O
b_pos	int
=	O
blk_data_start	int
;	O
L_lp	O
:	O
{	O
int	O
s_pos	int
=	O
next_field	O
(	O
blk	pointer
,	O
1	int
+	O
(	O
b_pos	int
)	O
)	O
;	O
if	O
(	O
(	O
s_pos	int
)	O
==	O
(	O
b_end	int
)	O
)	O
return	O
;	O
else	O
if	O
(	O
(	O
s_pos	int
)	O
<	O
(	O
b_end	int
)	O
)	O
{	O
{	O
b_pos	int
=	O
next_cnvpair	O
(	O
blk	pointer
,	O
b_pos	int
)	O
;	O
goto	O
L_lp	O
;	O
}	O
}	O
else	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< %s: blk %ld past end %d\n"	pointer
,	O
"check_blk"	pointer
,	O
blk_id	O
(	O
blk	pointer
)	O
,	O
s_pos	int
)	O
)	O
;	O
return	O
;	O
}	O
}	O
}	O
}	O
}	O
void	O
check_key_order	function
(	O
unsigned	O
char	O
*	O
blk	pointer
)	O
{	O
unsigned	O
char	O
split_str	array
[	O
0x100	int
]	O
;	O
int	O
spos	int
=	O
split_key_pos	function
(	O
blk	pointer
)	O
;	O
if	O
(	O
0	int
<	O
(	O
spos	int
)	O
)	O
recon_this_key	function
(	O
blk	pointer
,	O
spos	int
,	O
split_str	array
,	O
0	int
,	O
0x100	int
)	O
;	O
return	O
;	O
}	O
int	O
do_seg_buffers	function
(	O
SEGD	struct
*	O
seg	pointer
,	O
int_function	pointer
func	pointer
)	O
{	O
{	O
int	O
i	int
=	O
num_buks	int
;	O
ENTRY	struct
*	O
ent	pointer
=	O
0	int
;	O
L_lp	O
:	O
if	O
(	O
!	O
(	O
ent	pointer
)	O
)	O
if	O
(	O
!	O
(	O
i	int
)	O
)	O
return	O
success	int
;	O
else	O
{	O
int	O
T_i	int
=	O
(	O
i	int
)	O
-	O
1	int
;	O
ent	pointer
=	O
buk_tab	pointer
[	O
(	O
i	int
)	O
-	O
1	int
]	O
;	O
i	int
=	O
T_i	int
;	O
goto	O
L_lp	O
;	O
}	O
else	O
if	O
(	O
(	O
!	O
(	O
seg	pointer
)	O
)	O
||	O
(	O
(	O
seg	pointer
)	O
==	O
(	O
ent_seg	O
(	O
ent	pointer
)	O
)	O
)	O
)	O
{	O
int	O
ans	int
=	O
func	pointer
(	O
ent	pointer
)	O
;	O
if	O
(	O
success_P	O
(	O
ans	int
)	O
)	O
{	O
ent	pointer
=	O
ent_next	O
(	O
ent	pointer
)	O
;	O
goto	O
L_lp	O
;	O
}	O
else	O
return	O
ans	int
;	O
}	O
else	O
{	O
ent	pointer
=	O
ent_next	O
(	O
ent	pointer
)	O
;	O
goto	O
L_lp	O
;	O
}	O
}	O
}	O
int	O
check_buffer	function
(	O
ENTRY	struct
*	O
ent	pointer
)	O
{	O
if	O
(	O
ent_ref	O
(	O
ent	pointer
)	O
)	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< Entry still referenced: %ld:%ld\n"	pointer
,	O
seg_id	O
(	O
ent_seg	O
(	O
ent	pointer
)	O
)	O
,	O
ent_id	O
(	O
ent	pointer
)	O
)	O
)	O
;	O
ent_set_ref	O
(	O
ent	pointer
,	O
0	int
)	O
;	O
}	O
if	O
(	O
(	O
accnone	O
)	O
!=	O
(	O
ent_acc	O
(	O
ent	pointer
)	O
)	O
)	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< Entry still lcked: %ld:%ld\n"	pointer
,	O
seg_id	O
(	O
ent_seg	O
(	O
ent	pointer
)	O
)	O
,	O
ent_id	O
(	O
ent	pointer
)	O
)	O
)	O
;	O
ents_ent_update_access_P	function
(	O
ent	pointer
,	O
ent_acc	O
(	O
ent	pointer
)	O
,	O
accnone	O
)	O
;	O
}	O
return	O
success	int
;	O
}	O
void	O
check_access	function
(	O
void	O
)	O
{	O
check_lcks	function
(	O
)	O
;	O
do_seg_buffers	function
(	O
0	int
,	O
check_buffer	function
)	O
;	O
return	O
;	O
}	O
int	O
flush_buffer	function
(	O
ENTRY	struct
*	O
ent	pointer
)	O
{	O
if	O
(	O
(	O
accnone	O
)	O
!=	O
(	O
ent_acc	O
(	O
ent	pointer
)	O
)	O
)	O
return	O
terminated	O
;	O
else	O
if	O
(	O
ent_dty_P	O
(	O
ent	pointer
)	O
)	O
if	O
(	O
ents_ent_write	function
(	O
ent	pointer
)	O
)	O
return	O
success	int
;	O
else	O
return	O
retryerr	O
;	O
else	O
return	O
success	int
;	O
}	O
int	O
purge_buffer	function
(	O
ENTRY	struct
*	O
ent	pointer
)	O
{	O
if	O
(	O
ent_dty_P	O
(	O
ent	pointer
)	O
)	O
{	O
if	O
(	O
(	O
(	O
ent_acc	O
(	O
ent	pointer
)	O
)	O
==	O
(	O
accwrite	O
)	O
)	O
||	O
(	O
(	O
ent_acc	O
(	O
ent	pointer
)	O
)	O
==	O
(	O
accpend	O
)	O
)	O
)	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
"  Purging %s entry: %ld:%ld\n"	pointer
,	O
(	O
(	O
ent_acc	O
(	O
ent	pointer
)	O
)	O
==	O
(	O
accwrite	O
)	O
?	O
"ACCWRITE"	pointer
:	O
"ACCPEND"	pointer
)	O
,	O
seg_id	O
(	O
ent_seg	O
(	O
ent	pointer
)	O
)	O
,	O
ent_id	O
(	O
ent	pointer
)	O
)	O
)	O
;	O
ents_ent_write	function
(	O
ent	pointer
)	O
;	O
}	O
amnesia_ent	function
(	O
ent	pointer
)	O
;	O
return	O
success	int
;	O
}	O
