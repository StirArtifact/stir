typedef	O
struct	O
_zone	struct
{	O
int	O
array	pointer
[	O
BOARDMAX	O
]	O
;	O
unsigned	O
int	O
bits	array
[	O
1	int
+	O
BOARDMAX	O
/	O
32	int
]	O
;	O
int	O
i	int
;	O
}	O
zone	struct
;	O
static	O
int	O
recursive_connect2	function
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
*	O
move	pointer
,	O
int	O
has_passed	int
)	O
;	O
static	O
int	O
recursive_disconnect2	function
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
*	O
move	pointer
,	O
int	O
has_passed	int
)	O
;	O
static	O
int	O
recursive_break	function
(	O
int	O
str	int
,	O
const	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
,	O
int	O
*	O
move	pointer
,	O
int	O
has_passed	int
,	O
Hash_data	struct
*	O
goal_hash	pointer
)	O
;	O
static	O
int	O
recursive_block	function
(	O
int	O
str	int
,	O
const	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
,	O
int	O
*	O
move	pointer
,	O
int	O
has_passed	int
,	O
Hash_data	struct
*	O
goal_hash	pointer
)	O
;	O
static	O
int	O
add_array	function
(	O
int	O
*	O
array	pointer
,	O
int	O
elt	int
)	O
;	O
static	O
int	O
element_array	function
(	O
int	O
*	O
array	pointer
,	O
int	O
elt	int
)	O
;	O
static	O
void	O
intersection_array	function
(	O
int	O
*	O
array1	pointer
,	O
int	O
*	O
array2	pointer
)	O
;	O
static	O
int	O
snapback	function
(	O
int	O
str	int
)	O
;	O
static	O
int	O
connection_one_move	function
(	O
int	O
str1	int
,	O
int	O
str2	int
)	O
;	O
static	O
int	O
prevent_connection_one_move	function
(	O
int	O
*	O
moves	array
,	O
int	O
str1	int
,	O
int	O
str2	int
)	O
;	O
static	O
int	O
connected_one_move	function
(	O
int	O
str1	int
,	O
int	O
str2	int
)	O
;	O
static	O
int	O
moves_to_connect_in_two_moves	function
(	O
int	O
*	O
moves	array
,	O
int	O
str1	int
,	O
int	O
str2	int
)	O
;	O
static	O
int	O
connection_two_moves	function
(	O
int	O
str1	int
,	O
int	O
str2	int
)	O
;	O
static	O
int	O
prevent_connection_two_moves	function
(	O
int	O
*	O
moves	array
,	O
int	O
str1	int
,	O
int	O
str2	int
)	O
;	O
static	O
int	O
moves_to_connect_in_three_moves	function
(	O
int	O
*	O
moves	array
,	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
does_connect	int
)	O
;	O
static	O
int	O
recursive_connect	function
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
*	O
move	pointer
)	O
;	O
static	O
int	O
recursive_disconnect	function
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
*	O
move	pointer
)	O
;	O
static	O
int	O
quiescence_connect	function
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
*	O
move	pointer
)	O
;	O
static	O
int	O
quiescence_capture	function
(	O
int	O
str	int
,	O
int	O
*	O
move	pointer
)	O
;	O
static	O
int	O
prevent_capture_one_move	function
(	O
int	O
*	O
moves	array
,	O
int	O
str1	int
)	O
;	O
static	O
int	O
recursive_transitivity	function
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
str3	int
,	O
int	O
*	O
move	pointer
)	O
;	O
static	O
int	O
recursive_non_transitivity	function
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
str3	int
,	O
int	O
*	O
move	pointer
)	O
;	O
static	O
void	O
order_connection_moves	function
(	O
int	O
*	O
moves	array
,	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
color_to_move	int
,	O
const	O
char	O
*	O
funcname	pointer
)	O
;	O
static	O
int	O
nodes_connect	int
=	O
0	int
;	O
static	O
signed	O
char	O
connection_shadow	array
[	O
BOARDMAX	O
]	O
;	O
static	O
signed	O
char	O
breakin_shadow	array
[	O
BOARDMAX	O
]	O
;	O
static	O
int	O
global_connection_node_counter	int
=	O
0	int
;	O
static	O
void	O
init_zone	function
(	O
zone	struct
*	O
zn	pointer
)	O
{	O
zn	pointer
->	O
array	pointer
[	O
0	int
]	O
=	O
0	int
;	O
memset	function
(	O
zn	pointer
->	O
bits	array
,	O
0	int
,	O
1	int
+	O
BOARDMAX	O
/	O
8	int
)	O
;	O
}	O
static	O
void	O
add_zone	function
(	O
zone	struct
*	O
zn	pointer
,	O
int	O
elt	int
)	O
{	O
if	O
(	O
(	O
(	O
zn	pointer
->	O
bits	array
[	O
elt	int
>>	O
5	int
]	O
>>	O
(	O
elt	int
&	O
31	int
)	O
)	O
&	O
1	int
)	O
==	O
0	int
)	O
{	O
zn	pointer
->	O
bits	array
[	O
elt	int
>>	O
5	int
]	O
|=	O
(	O
1	int
<<	O
(	O
elt	int
&	O
31	int
)	O
)	O
;	O
zn	pointer
->	O
array	pointer
[	O
0	int
]	O
++	O
;	O
zn	pointer
->	O
array	pointer
[	O
zn	pointer
->	O
array	pointer
[	O
0	int
]	O
]	O
=	O
elt	int
;	O
}	O
}	O
static	O
int	O
add_array	function
(	O
int	O
*	O
array	pointer
,	O
int	O
elt	int
)	O
{	O
int	O
r	int
;	O
for	O
(	O
r	int
=	O
1	int
;	O
r	int
<	O
array	pointer
[	O
0	int
]	O
+	O
1	int
;	O
r	int
++	O
)	O
if	O
(	O
array	pointer
[	O
r	int
]	O
==	O
elt	int
)	O
return	O
0	int
;	O
array	pointer
[	O
0	int
]	O
++	O
;	O
array	pointer
[	O
array	pointer
[	O
0	int
]	O
]	O
=	O
elt	int
;	O
return	O
1	int
;	O
}	O
static	O
int	O
element_array	function
(	O
int	O
*	O
array	pointer
,	O
int	O
elt	int
)	O
{	O
int	O
r	int
;	O
for	O
(	O
r	int
=	O
1	int
;	O
r	int
<	O
array	pointer
[	O
0	int
]	O
+	O
1	int
;	O
r	int
++	O
)	O
if	O
(	O
array	pointer
[	O
r	int
]	O
==	O
elt	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
intersection_array	function
(	O
int	O
*	O
array1	pointer
,	O
int	O
*	O
array2	pointer
)	O
{	O
int	O
r	int
,	O
s	int
;	O
for	O
(	O
r	int
=	O
1	int
;	O
r	int
<	O
array1	pointer
[	O
0	int
]	O
+	O
1	int
;	O
r	int
++	O
)	O
if	O
(	O
!	O
element_array	function
(	O
array2	pointer
,	O
array1	pointer
[	O
r	int
]	O
)	O
)	O
{	O
for	O
(	O
s	int
=	O
r	int
;	O
s	int
<	O
array1	pointer
[	O
0	int
]	O
;	O
s	int
++	O
)	O
array1	pointer
[	O
s	int
]	O
=	O
array1	pointer
[	O
s	int
+	O
1	int
]	O
;	O
array1	pointer
[	O
0	int
]	O
--	O
;	O
r	int
--	O
;	O
}	O
}	O
static	O
int	O
snapback	function
(	O
int	O
str	int
)	O
{	O
int	O
stones	pointer
,	O
liberties	pointer
,	O
lib	int
;	O
SGFTree	struct
*	O
save_sgf_dumptree	pointer
=	O
sgf_dumptree	pointer
;	O
stones	pointer
=	O
countstones	function
(	O
str	int
)	O
;	O
if	O
(	O
stones	pointer
>	O
1	int
)	O
return	O
0	int
;	O
liberties	pointer
=	O
findlib	function
(	O
str	int
,	O
1	int
,	O
&	O
lib	int
)	O
;	O
if	O
(	O
liberties	pointer
>	O
1	int
)	O
return	O
0	int
;	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
if	O
(	O
trymove	function
(	O
lib	int
,	O
OTHER_COLOR	O
(	O
board	pointer
[	O
str	int
]	O
)	O
,	O
"snapback"	pointer
,	O
str	int
)	O
)	O
{	O
liberties	pointer
=	O
0	int
;	O
if	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
lib	int
]	O
)	O
)	O
liberties	pointer
=	O
countlib	function
(	O
lib	int
)	O
;	O
popgo	function
(	O
)	O
;	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
if	O
(	O
liberties	pointer
>	O
1	int
)	O
return	O
0	int
;	O
return	O
WIN	int
;	O
}	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
return	O
0	int
;	O
}	O
static	O
int	O
ponnuki_connect	function
(	O
int	O
*	O
moves	array
,	O
int	O
str1	int
,	O
int	O
str2	int
,	O
zone	struct
*	O
zn	pointer
)	O
{	O
int	O
r	int
,	O
s	int
,	O
k	int
,	O
res	int
=	O
0	int
;	O
int	O
liberties	pointer
,	O
libs	pointer
[	O
MAXLIBS	O
]	O
;	O
int	O
adj	array
,	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
neighb	int
,	O
neighbs	array
[	O
MAXCHAIN	int
]	O
;	O
liberties	pointer
=	O
findlib	function
(	O
str1	int
,	O
MAXLIBS	O
,	O
libs	pointer
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
liberties	pointer
;	O
r	int
++	O
)	O
if	O
(	O
is_self_atari	function
(	O
libs	pointer
[	O
r	int
]	O
,	O
OTHER_COLOR	O
(	O
board	pointer
[	O
str1	int
]	O
)	O
)	O
)	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
pos	int
=	O
libs	pointer
[	O
r	int
]	O
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
board	pointer
[	O
str1	int
]	O
&&	O
!	O
same_string	function
(	O
pos	int
,	O
str1	int
)	O
&&	O
!	O
same_string	function
(	O
pos	int
,	O
str2	int
)	O
)	O
{	O
neighb	int
=	O
findlib	function
(	O
pos	int
,	O
MAXLIBS	O
,	O
neighbs	array
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
neighb	int
;	O
s	int
++	O
)	O
if	O
(	O
liberty_of_string	function
(	O
neighbs	array
[	O
s	int
]	O
,	O
str2	int
)	O
)	O
{	O
res	int
=	O
1	int
;	O
add_zone	function
(	O
zn	pointer
,	O
libs	pointer
[	O
r	int
]	O
)	O
;	O
add_zone	function
(	O
zn	pointer
,	O
neighbs	array
[	O
s	int
]	O
)	O
;	O
add_array	function
(	O
moves	array
,	O
neighbs	array
[	O
s	int
]	O
)	O
;	O
}	O
adj	array
=	O
chainlinks2	function
(	O
pos	int
,	O
adjs	array
,	O
1	int
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
adj	array
;	O
s	int
++	O
)	O
if	O
(	O
adjacent_strings	function
(	O
adjs	array
[	O
s	int
]	O
,	O
str2	int
)	O
&&	O
!	O
snapback	function
(	O
adjs	array
[	O
s	int
]	O
)	O
)	O
{	O
res	int
=	O
1	int
;	O
neighb	int
=	O
findlib	function
(	O
adjs	array
[	O
s	int
]	O
,	O
1	int
,	O
neighbs	array
)	O
;	O
add_zone	function
(	O
zn	pointer
,	O
libs	pointer
[	O
r	int
]	O
)	O
;	O
add_zone	function
(	O
zn	pointer
,	O
neighbs	array
[	O
0	int
]	O
)	O
;	O
add_array	function
(	O
moves	array
,	O
neighbs	array
[	O
0	int
]	O
)	O
;	O
}	O
}	O
}	O
return	O
res	int
;	O
}	O
static	O
int	O
moves_connection_one_move	function
(	O
int	O
*	O
moves	array
,	O
int	O
str1	int
,	O
int	O
str2	int
,	O
zone	struct
*	O
zn	pointer
)	O
{	O
int	O
r	int
;	O
int	O
adj	array
,	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
if	O
(	O
board	pointer
[	O
str1	int
]	O
==	O
EMPTY	int
||	O
board	pointer
[	O
str2	int
]	O
==	O
EMPTY	int
)	O
return	O
0	int
;	O
if	O
(	O
have_common_lib	function
(	O
str1	int
,	O
str2	int
,	O
NULL	O
)	O
)	O
return	O
WIN	int
;	O
adj	array
=	O
chainlinks2	function
(	O
str1	int
,	O
adjs	array
,	O
1	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array
;	O
r	int
++	O
)	O
if	O
(	O
adjacent_strings	function
(	O
adjs	array
[	O
r	int
]	O
,	O
str2	int
)	O
&&	O
!	O
snapback	function
(	O
adjs	array
[	O
r	int
]	O
)	O
)	O
return	O
WIN	int
;	O
if	O
(	O
ponnuki_connect	function
(	O
moves	array
,	O
str1	int
,	O
str2	int
,	O
zn	pointer
)	O
)	O
return	O
WIN	int
;	O
if	O
(	O
ponnuki_connect	function
(	O
moves	array
,	O
str2	int
,	O
str1	int
,	O
zn	pointer
)	O
)	O
return	O
WIN	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
connection_one_move	function
(	O
int	O
str1	int
,	O
int	O
str2	int
)	O
{	O
int	O
moves	array
[	O
BOARDMAX	O
]	O
;	O
zone	struct
zn	pointer
;	O
init_zone	function
(	O
&	O
zn	pointer
)	O
;	O
moves	array
[	O
0	int
]	O
=	O
0	int
;	O
return	O
moves_connection_one_move	function
(	O
moves	array
,	O
str1	int
,	O
str2	int
,	O
&	O
zn	pointer
)	O
;	O
}	O
static	O
int	O
prevent_connection_one_move	function
(	O
int	O
*	O
moves	array
,	O
int	O
str1	int
,	O
int	O
str2	int
)	O
{	O
int	O
r	int
,	O
s	int
;	O
int	O
libs	pointer
[	O
MAXLIBS	O
]	O
;	O
int	O
adj	array
,	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
adjadj	int
,	O
adjadjs	array
[	O
MAXCHAIN	int
]	O
;	O
if	O
(	O
have_common_lib	function
(	O
str1	int
,	O
str2	int
,	O
libs	pointer
)	O
)	O
{	O
add_array	function
(	O
moves	array
,	O
libs	pointer
[	O
0	int
]	O
)	O
;	O
return	O
WIN	int
;	O
}	O
adj	array
=	O
chainlinks2	function
(	O
str1	int
,	O
adjs	array
,	O
1	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array
;	O
r	int
++	O
)	O
if	O
(	O
adjacent_strings	function
(	O
adjs	array
[	O
r	int
]	O
,	O
str2	int
)	O
&&	O
!	O
snapback	function
(	O
adjs	array
[	O
r	int
]	O
)	O
)	O
{	O
findlib	function
(	O
adjs	array
[	O
r	int
]	O
,	O
MAXLIBS	O
,	O
libs	pointer
)	O
;	O
add_array	function
(	O
moves	array
,	O
libs	pointer
[	O
0	int
]	O
)	O
;	O
adjadj	int
=	O
chainlinks2	function
(	O
adjs	array
[	O
r	int
]	O
,	O
adjadjs	array
,	O
1	int
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
adjadj	int
;	O
s	int
++	O
)	O
{	O
findlib	function
(	O
adjadjs	array
[	O
s	int
]	O
,	O
MAXLIBS	O
,	O
libs	pointer
)	O
;	O
add_array	function
(	O
moves	array
,	O
libs	pointer
[	O
0	int
]	O
)	O
;	O
}	O
return	O
WIN	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
connected_one_move	function
(	O
int	O
str1	int
,	O
int	O
str2	int
)	O
{	O
int	O
r	int
,	O
res	int
=	O
0	int
;	O
int	O
moves	array
[	O
MAX_MOVES	int
]	O
;	O
SGFTree	struct
*	O
save_sgf_dumptree	pointer
=	O
sgf_dumptree	pointer
;	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
moves	array
[	O
0	int
]	O
=	O
0	int
;	O
if	O
(	O
prevent_connection_one_move	function
(	O
moves	array
,	O
str1	int
,	O
str2	int
)	O
)	O
{	O
order_connection_moves	function
(	O
moves	array
,	O
str1	int
,	O
str2	int
,	O
OTHER_COLOR	O
(	O
board	pointer
[	O
str1	int
]	O
)	O
,	O
"connected_one_move"	pointer
)	O
;	O
res	int
=	O
WIN	int
;	O
for	O
(	O
r	int
=	O
1	int
;	O
(	O
(	O
r	int
<	O
moves	array
[	O
0	int
]	O
+	O
1	int
)	O
&&	O
res	int
)	O
;	O
r	int
++	O
)	O
{	O
if	O
(	O
trymove	function
(	O
moves	array
[	O
r	int
]	O
,	O
OTHER_COLOR	O
(	O
board	pointer
[	O
str1	int
]	O
)	O
,	O
"connected_one_move"	pointer
,	O
str1	int
)	O
)	O
{	O
if	O
(	O
!	O
connection_one_move	function
(	O
str1	int
,	O
str2	int
)	O
)	O
res	int
=	O
0	int
;	O
popgo	function
(	O
)	O
;	O
}	O
}	O
}	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
return	O
res	int
;	O
}	O
static	O
int	O
moves_to_connect_in_two_moves	function
(	O
int	O
*	O
moves	array
,	O
int	O
str1	int
,	O
int	O
str2	int
)	O
{	O
int	O
r	int
,	O
s	int
,	O
common_adj_liberty	int
;	O
int	O
liberties	pointer
,	O
libs	pointer
[	O
MAXLIBS	O
]	O
;	O
int	O
adj	array
,	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
adjadj	int
,	O
adjadjs	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
k	int
;	O
int	O
color	int
=	O
board	pointer
[	O
str1	int
]	O
;	O
int	O
move	pointer
;	O
if	O
(	O
have_common_lib	function
(	O
str1	int
,	O
str2	int
,	O
libs	pointer
)	O
)	O
{	O
add_array	function
(	O
moves	array
,	O
libs	pointer
[	O
0	int
]	O
)	O
;	O
return	O
1	int
;	O
}	O
adj	array
=	O
chainlinks3	function
(	O
str1	int
,	O
adjs	array
,	O
2	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array
;	O
r	int
++	O
)	O
{	O
liberties	pointer
=	O
findlib	function
(	O
adjs	array
[	O
r	int
]	O
,	O
MAXLIBS	O
,	O
libs	pointer
)	O
;	O
common_adj_liberty	int
=	O
0	int
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
liberties	pointer
;	O
s	int
++	O
)	O
if	O
(	O
liberty_of_string	function
(	O
libs	pointer
[	O
s	int
]	O
,	O
str2	int
)	O
)	O
common_adj_liberty	int
=	O
1	int
;	O
if	O
(	O
common_adj_liberty	int
||	O
adjacent_strings	function
(	O
adjs	array
[	O
r	int
]	O
,	O
str2	int
)	O
)	O
{	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
liberties	pointer
;	O
s	int
++	O
)	O
add_array	function
(	O
moves	array
,	O
libs	pointer
[	O
s	int
]	O
)	O
;	O
adjadj	int
=	O
chainlinks2	function
(	O
adjs	array
[	O
r	int
]	O
,	O
adjadjs	array
,	O
1	int
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
adjadj	int
;	O
s	int
++	O
)	O
{	O
findlib	function
(	O
adjadjs	array
[	O
s	int
]	O
,	O
MAXLIBS	O
,	O
libs	pointer
)	O
;	O
add_array	function
(	O
moves	array
,	O
libs	pointer
[	O
0	int
]	O
)	O
;	O
}	O
}	O
}	O
adj	array
=	O
chainlinks3	function
(	O
str2	int
,	O
adjs	array
,	O
2	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array
;	O
r	int
++	O
)	O
{	O
liberties	pointer
=	O
findlib	function
(	O
adjs	array
[	O
r	int
]	O
,	O
MAXLIBS	O
,	O
libs	pointer
)	O
;	O
common_adj_liberty	int
=	O
0	int
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
liberties	pointer
;	O
s	int
++	O
)	O
if	O
(	O
liberty_of_string	function
(	O
libs	pointer
[	O
s	int
]	O
,	O
str1	int
)	O
)	O
common_adj_liberty	int
=	O
1	int
;	O
if	O
(	O
common_adj_liberty	int
||	O
adjacent_strings	function
(	O
adjs	array
[	O
r	int
]	O
,	O
str1	int
)	O
)	O
{	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
liberties	pointer
;	O
s	int
++	O
)	O
add_array	function
(	O
moves	array
,	O
libs	pointer
[	O
s	int
]	O
)	O
;	O
adjadj	int
=	O
chainlinks2	function
(	O
adjs	array
[	O
r	int
]	O
,	O
adjadjs	array
,	O
1	int
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
adjadj	int
;	O
s	int
++	O
)	O
{	O
findlib	function
(	O
adjadjs	array
[	O
s	int
]	O
,	O
MAXLIBS	O
,	O
libs	pointer
)	O
;	O
add_array	function
(	O
moves	array
,	O
libs	pointer
[	O
0	int
]	O
)	O
;	O
}	O
}	O
}	O
liberties	pointer
=	O
findlib	function
(	O
str1	int
,	O
MAXLIBS	O
,	O
libs	pointer
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
liberties	pointer
;	O
r	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
SOUTH	O
(	O
libs	pointer
[	O
r	int
]	O
)	O
]	O
==	O
EMPTY	int
)	O
{	O
if	O
(	O
liberty_of_string	function
(	O
SOUTH	O
(	O
libs	pointer
[	O
r	int
]	O
)	O
,	O
str2	int
)	O
)	O
{	O
add_array	function
(	O
moves	array
,	O
libs	pointer
[	O
r	int
]	O
)	O
;	O
add_array	function
(	O
moves	array
,	O
SOUTH	O
(	O
libs	pointer
[	O
r	int
]	O
)	O
)	O
;	O
}	O
}	O
if	O
(	O
board	pointer
[	O
WEST	O
(	O
libs	pointer
[	O
r	int
]	O
)	O
]	O
==	O
EMPTY	int
)	O
{	O
if	O
(	O
liberty_of_string	function
(	O
WEST	O
(	O
libs	pointer
[	O
r	int
]	O
)	O
,	O
str2	int
)	O
)	O
{	O
add_array	function
(	O
moves	array
,	O
libs	pointer
[	O
r	int
]	O
)	O
;	O
add_array	function
(	O
moves	array
,	O
WEST	O
(	O
libs	pointer
[	O
r	int
]	O
)	O
)	O
;	O
}	O
}	O
if	O
(	O
board	pointer
[	O
NORTH	O
(	O
libs	pointer
[	O
r	int
]	O
)	O
]	O
==	O
EMPTY	int
)	O
{	O
if	O
(	O
liberty_of_string	function
(	O
NORTH	O
(	O
libs	pointer
[	O
r	int
]	O
)	O
,	O
str2	int
)	O
)	O
{	O
add_array	function
(	O
moves	array
,	O
libs	pointer
[	O
r	int
]	O
)	O
;	O
add_array	function
(	O
moves	array
,	O
NORTH	O
(	O
libs	pointer
[	O
r	int
]	O
)	O
)	O
;	O
}	O
}	O
if	O
(	O
board	pointer
[	O
EAST	O
(	O
libs	pointer
[	O
r	int
]	O
)	O
]	O
==	O
EMPTY	int
)	O
{	O
if	O
(	O
liberty_of_string	function
(	O
EAST	O
(	O
libs	pointer
[	O
r	int
]	O
)	O
,	O
str2	int
)	O
)	O
{	O
add_array	function
(	O
moves	array
,	O
libs	pointer
[	O
r	int
]	O
)	O
;	O
add_array	function
(	O
moves	array
,	O
EAST	O
(	O
libs	pointer
[	O
r	int
]	O
)	O
)	O
;	O
}	O
}	O
}	O
liberties	pointer
=	O
findlib	function
(	O
str1	int
,	O
MAXLIBS	O
,	O
libs	pointer
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
liberties	pointer
;	O
r	int
++	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
pos	int
=	O
libs	pointer
[	O
r	int
]	O
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
color	int
&&	O
!	O
same_string	function
(	O
pos	int
,	O
str1	int
)	O
&&	O
quiescence_connect	function
(	O
pos	int
,	O
str2	int
,	O
&	O
move	pointer
)	O
)	O
{	O
add_array	function
(	O
moves	array
,	O
libs	pointer
[	O
r	int
]	O
)	O
;	O
add_array	function
(	O
moves	array
,	O
move	pointer
)	O
;	O
}	O
}	O
}	O
liberties	pointer
=	O
findlib	function
(	O
str2	int
,	O
MAXLIBS	O
,	O
libs	pointer
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
liberties	pointer
;	O
r	int
++	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
pos	int
=	O
libs	pointer
[	O
r	int
]	O
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
color	int
&&	O
!	O
same_string	function
(	O
pos	int
,	O
str2	int
)	O
&&	O
quiescence_connect	function
(	O
pos	int
,	O
str1	int
,	O
&	O
move	pointer
)	O
)	O
{	O
add_array	function
(	O
moves	array
,	O
libs	pointer
[	O
r	int
]	O
)	O
;	O
add_array	function
(	O
moves	array
,	O
move	pointer
)	O
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
connection_two_moves	function
(	O
int	O
str1	int
,	O
int	O
str2	int
)	O
{	O
int	O
r	int
,	O
res	int
=	O
0	int
,	O
moves	array
[	O
MAX_MOVES	int
]	O
;	O
SGFTree	struct
*	O
save_sgf_dumptree	pointer
=	O
sgf_dumptree	pointer
;	O
if	O
(	O
board	pointer
[	O
str1	int
]	O
==	O
EMPTY	int
||	O
board	pointer
[	O
str2	int
]	O
==	O
EMPTY	int
)	O
return	O
0	int
;	O
moves	array
[	O
0	int
]	O
=	O
0	int
;	O
if	O
(	O
moves_to_connect_in_two_moves	function
(	O
moves	array
,	O
str1	int
,	O
str2	int
)	O
)	O
return	O
WIN	int
;	O
order_connection_moves	function
(	O
moves	array
,	O
str1	int
,	O
str2	int
,	O
board	pointer
[	O
str1	int
]	O
,	O
"connection_two_moves"	pointer
)	O
;	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
for	O
(	O
r	int
=	O
1	int
;	O
(	O
(	O
r	int
<	O
moves	array
[	O
0	int
]	O
+	O
1	int
)	O
&&	O
!	O
res	int
)	O
;	O
r	int
++	O
)	O
{	O
if	O
(	O
trymove	function
(	O
moves	array
[	O
r	int
]	O
,	O
board	pointer
[	O
str1	int
]	O
,	O
"connection_two_moves"	pointer
,	O
str1	int
)	O
)	O
{	O
if	O
(	O
connected_one_move	function
(	O
str1	int
,	O
str2	int
)	O
)	O
res	int
=	O
WIN	int
;	O
popgo	function
(	O
)	O
;	O
}	O
}	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
return	O
res	int
;	O
}	O
static	O
int	O
moves_to_prevent_connection_in_two_moves	function
(	O
int	O
*	O
moves	array
,	O
int	O
str1	int
,	O
int	O
str2	int
)	O
{	O
if	O
(	O
moves_to_connect_in_two_moves	function
(	O
moves	array
,	O
str1	int
,	O
str2	int
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
prevent_connection_two_moves	function
(	O
int	O
*	O
moves	array
,	O
int	O
str1	int
,	O
int	O
str2	int
)	O
{	O
int	O
r	int
,	O
res	int
=	O
0	int
;	O
int	O
possible_moves	array
[	O
MAX_MOVES	int
]	O
;	O
SGFTree	struct
*	O
save_sgf_dumptree	pointer
=	O
sgf_dumptree	pointer
;	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
if	O
(	O
connection_two_moves	function
(	O
str1	int
,	O
str2	int
)	O
)	O
{	O
res	int
=	O
WIN	int
;	O
possible_moves	array
[	O
0	int
]	O
=	O
0	int
;	O
moves_to_prevent_connection_in_two_moves	function
(	O
possible_moves	array
,	O
str1	int
,	O
str2	int
)	O
;	O
order_connection_moves	function
(	O
possible_moves	array
,	O
str1	int
,	O
str2	int
,	O
OTHER_COLOR	O
(	O
board	pointer
[	O
str1	int
]	O
)	O
,	O
"prevent_connection_two_moves"	pointer
)	O
;	O
for	O
(	O
r	int
=	O
1	int
;	O
r	int
<	O
possible_moves	array
[	O
0	int
]	O
+	O
1	int
;	O
r	int
++	O
)	O
{	O
if	O
(	O
trymove	function
(	O
possible_moves	array
[	O
r	int
]	O
,	O
OTHER_COLOR	O
(	O
board	pointer
[	O
str1	int
]	O
)	O
,	O
"prevent_connection_two_moves"	pointer
,	O
str1	int
)	O
)	O
{	O
if	O
(	O
!	O
connection_one_move	function
(	O
str1	int
,	O
str2	int
)	O
)	O
if	O
(	O
!	O
connection_two_moves	function
(	O
str1	int
,	O
str2	int
)	O
)	O
add_array	function
(	O
moves	array
,	O
possible_moves	array
[	O
r	int
]	O
)	O
;	O
popgo	function
(	O
)	O
;	O
}	O
}	O
}	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
return	O
res	int
;	O
}	O
static	O
int	O
moves_to_connect_in_three_moves	function
(	O
int	O
*	O
moves	array
,	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
does_connect	int
)	O
{	O
int	O
r	int
,	O
s	int
;	O
int	O
liberties	pointer
,	O
libs	pointer
[	O
MAXLIBS	O
]	O
;	O
int	O
liberties2	int
,	O
libs2	array
[	O
MAXLIBS	O
]	O
;	O
int	O
adj	array
,	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
adjadj	int
,	O
adjadjs	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
move	pointer
;	O
int	O
k	int
;	O
int	O
pos	int
;	O
int	O
secondlib1	array
[	O
BOARDMAX	O
]	O
;	O
int	O
secondlib2	array
[	O
BOARDMAX	O
]	O
;	O
if	O
(	O
moves_to_connect_in_two_moves	function
(	O
moves	array
,	O
str1	int
,	O
str2	int
)	O
)	O
return	O
1	int
;	O
memset	function
(	O
secondlib1	array
,	O
0	int
,	O
sizeof	O
(	O
secondlib1	array
)	O
)	O
;	O
liberties	pointer
=	O
findlib	function
(	O
str1	int
,	O
MAXLIBS	O
,	O
libs	pointer
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
liberties	pointer
;	O
r	int
++	O
)	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
pos	int
=	O
libs	pointer
[	O
r	int
]	O
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
secondlib1	array
[	O
pos	int
]	O
=	O
1	int
;	O
else	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
board	pointer
[	O
str1	int
]	O
)	O
{	O
liberties2	int
=	O
findlib	function
(	O
pos	int
,	O
MAXLIBS	O
,	O
libs2	array
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
liberties2	int
;	O
s	int
++	O
)	O
secondlib1	array
[	O
libs2	array
[	O
s	int
]	O
]	O
=	O
1	int
;	O
}	O
}	O
memset	function
(	O
secondlib2	array
,	O
0	int
,	O
sizeof	O
(	O
secondlib2	array
)	O
)	O
;	O
liberties	pointer
=	O
findlib	function
(	O
str2	int
,	O
MAXLIBS	O
,	O
libs	pointer
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
liberties	pointer
;	O
r	int
++	O
)	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
pos	int
=	O
libs	pointer
[	O
r	int
]	O
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
secondlib2	array
[	O
pos	int
]	O
=	O
1	int
;	O
else	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
board	pointer
[	O
str2	int
]	O
)	O
{	O
liberties2	int
=	O
findlib	function
(	O
pos	int
,	O
MAXLIBS	O
,	O
libs2	array
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
liberties2	int
;	O
s	int
++	O
)	O
secondlib2	array
[	O
libs2	array
[	O
s	int
]	O
]	O
=	O
1	int
;	O
}	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
secondlib1	array
[	O
pos	int
]	O
&&	O
secondlib2	array
[	O
pos	int
]	O
)	O
add_array	function
(	O
moves	array
,	O
pos	int
)	O
;	O
}	O
adj	array
=	O
chainlinks2	function
(	O
str1	int
,	O
adjs	array
,	O
1	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array
;	O
r	int
++	O
)	O
{	O
adjadj	int
=	O
chainlinks	function
(	O
adjs	array
[	O
r	int
]	O
,	O
adjadjs	array
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
adjadj	int
;	O
s	int
++	O
)	O
{	O
if	O
(	O
!	O
same_string	function
(	O
adjadjs	array
[	O
s	int
]	O
,	O
str1	int
)	O
&&	O
quiescence_connect	function
(	O
adjadjs	array
[	O
s	int
]	O
,	O
str2	int
,	O
&	O
move	pointer
)	O
)	O
{	O
findlib	function
(	O
adjs	array
[	O
r	int
]	O
,	O
1	int
,	O
libs	pointer
)	O
;	O
add_array	function
(	O
moves	array
,	O
libs	pointer
[	O
0	int
]	O
)	O
;	O
add_array	function
(	O
moves	array
,	O
move	pointer
)	O
;	O
}	O
}	O
}	O
adj	array
=	O
chainlinks2	function
(	O
str2	int
,	O
adjs	array
,	O
1	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array
;	O
r	int
++	O
)	O
{	O
adjadj	int
=	O
chainlinks	function
(	O
adjs	array
[	O
r	int
]	O
,	O
adjadjs	array
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
adjadj	int
;	O
s	int
++	O
)	O
{	O
if	O
(	O
!	O
same_string	function
(	O
adjadjs	array
[	O
s	int
]	O
,	O
str2	int
)	O
&&	O
quiescence_connect	function
(	O
adjadjs	array
[	O
s	int
]	O
,	O
str1	int
,	O
&	O
move	pointer
)	O
)	O
{	O
findlib	function
(	O
adjs	array
[	O
r	int
]	O
,	O
1	int
,	O
libs	pointer
)	O
;	O
add_array	function
(	O
moves	array
,	O
libs	pointer
[	O
0	int
]	O
)	O
;	O
add_array	function
(	O
moves	array
,	O
move	pointer
)	O
;	O
}	O
}	O
}	O
adj	array
=	O
chainlinks3	function
(	O
str1	int
,	O
adjs	array
,	O
2	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array
;	O
r	int
++	O
)	O
{	O
liberties	pointer
=	O
findlib	function
(	O
adjs	array
[	O
r	int
]	O
,	O
2	int
,	O
libs	pointer
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
liberties	pointer
;	O
s	int
++	O
)	O
if	O
(	O
second_order_liberty_of_string	function
(	O
libs	pointer
[	O
s	int
]	O
,	O
str2	int
)	O
)	O
add_array	function
(	O
moves	array
,	O
libs	pointer
[	O
s	int
]	O
)	O
;	O
}	O
adj	array
=	O
chainlinks3	function
(	O
str2	int
,	O
adjs	array
,	O
2	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array
;	O
r	int
++	O
)	O
{	O
liberties	pointer
=	O
findlib	function
(	O
adjs	array
[	O
r	int
]	O
,	O
2	int
,	O
libs	pointer
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
liberties	pointer
;	O
s	int
++	O
)	O
if	O
(	O
second_order_liberty_of_string	function
(	O
libs	pointer
[	O
s	int
]	O
,	O
str1	int
)	O
)	O
add_array	function
(	O
moves	array
,	O
libs	pointer
[	O
s	int
]	O
)	O
;	O
}	O
adj	array
=	O
chainlinks2	function
(	O
str1	int
,	O
adjs	array
,	O
3	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array
;	O
r	int
++	O
)	O
{	O
if	O
(	O
have_common_lib	function
(	O
adjs	array
[	O
r	int
]	O
,	O
str2	int
,	O
NULL	O
)	O
)	O
{	O
liberties	pointer
=	O
findlib	function
(	O
adjs	array
[	O
r	int
]	O
,	O
3	int
,	O
libs	pointer
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
liberties	pointer
;	O
s	int
++	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
!	O
does_connect	int
||	O
(	O
ON_BOARD	O
(	O
libs	pointer
[	O
s	int
]	O
+	O
delta	array
[	O
k	int
]	O
)	O
&&	O
(	O
secondlib1	array
[	O
libs	pointer
[	O
s	int
]	O
+	O
delta	array
[	O
k	int
]	O
]	O
||	O
secondlib2	array
[	O
libs	pointer
[	O
s	int
]	O
+	O
delta	array
[	O
k	int
]	O
]	O
)	O
)	O
)	O
{	O
add_array	function
(	O
moves	array
,	O
libs	pointer
[	O
s	int
]	O
)	O
;	O
break	O
;	O
}	O
}	O
}	O
}	O
}	O
adj	array
=	O
chainlinks2	function
(	O
str2	int
,	O
adjs	array
,	O
3	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array
;	O
r	int
++	O
)	O
{	O
if	O
(	O
have_common_lib	function
(	O
adjs	array
[	O
r	int
]	O
,	O
str1	int
,	O
NULL	O
)	O
)	O
{	O
liberties	pointer
=	O
findlib	function
(	O
adjs	array
[	O
r	int
]	O
,	O
3	int
,	O
libs	pointer
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
liberties	pointer
;	O
s	int
++	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
!	O
does_connect	int
||	O
(	O
ON_BOARD	O
(	O
libs	pointer
[	O
s	int
]	O
+	O
delta	array
[	O
k	int
]	O
)	O
&&	O
(	O
secondlib1	array
[	O
libs	pointer
[	O
s	int
]	O
+	O
delta	array
[	O
k	int
]	O
]	O
||	O
secondlib2	array
[	O
libs	pointer
[	O
s	int
]	O
+	O
delta	array
[	O
k	int
]	O
]	O
)	O
)	O
)	O
{	O
add_array	function
(	O
moves	array
,	O
libs	pointer
[	O
s	int
]	O
)	O
;	O
break	O
;	O
}	O
}	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
moves_to_prevent_connection_in_three_moves	function
(	O
int	O
*	O
moves	array
,	O
int	O
str1	int
,	O
int	O
str2	int
)	O
{	O
if	O
(	O
moves_to_connect_in_three_moves	function
(	O
moves	array
,	O
str1	int
,	O
str2	int
,	O
0	int
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
simply_connected_two_moves	function
(	O
int	O
str1	int
,	O
int	O
str2	int
)	O
{	O
int	O
r	int
,	O
res	int
=	O
0	int
;	O
int	O
moves	array
[	O
MAX_MOVES	int
]	O
;	O
SGFTree	struct
*	O
save_sgf_dumptree	pointer
=	O
sgf_dumptree	pointer
;	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
if	O
(	O
board	pointer
[	O
str1	int
]	O
==	O
EMPTY	int
||	O
board	pointer
[	O
str2	int
]	O
==	O
EMPTY	int
)	O
return	O
0	int
;	O
moves	array
[	O
0	int
]	O
=	O
0	int
;	O
if	O
(	O
prevent_connection_one_move	function
(	O
moves	array
,	O
str1	int
,	O
str2	int
)	O
)	O
{	O
res	int
=	O
WIN	int
;	O
order_connection_moves	function
(	O
moves	array
,	O
str1	int
,	O
str2	int
,	O
OTHER_COLOR	O
(	O
board	pointer
[	O
str1	int
]	O
)	O
,	O
"simply_connected_two_moves"	pointer
)	O
;	O
for	O
(	O
r	int
=	O
1	int
;	O
(	O
(	O
r	int
<	O
moves	array
[	O
0	int
]	O
+	O
1	int
)	O
&&	O
res	int
)	O
;	O
r	int
++	O
)	O
{	O
if	O
(	O
trymove	function
(	O
moves	array
[	O
r	int
]	O
,	O
OTHER_COLOR	O
(	O
board	pointer
[	O
str1	int
]	O
)	O
,	O
"simply_connected_two_moves"	pointer
,	O
str1	int
)	O
)	O
{	O
if	O
(	O
!	O
connection_one_move	function
(	O
str1	int
,	O
str2	int
)	O
)	O
if	O
(	O
!	O
connection_two_moves	function
(	O
str1	int
,	O
str2	int
)	O
)	O
res	int
=	O
0	int
;	O
popgo	function
(	O
)	O
;	O
}	O
}	O
}	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
return	O
res	int
;	O
}	O
static	O
int	O
simple_connection_three_moves	function
(	O
int	O
str1	int
,	O
int	O
str2	int
)	O
{	O
int	O
r	int
,	O
res	int
=	O
0	int
,	O
moves	array
[	O
MAX_MOVES	int
]	O
;	O
SGFTree	struct
*	O
save_sgf_dumptree	pointer
=	O
sgf_dumptree	pointer
;	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
moves	array
[	O
0	int
]	O
=	O
0	int
;	O
if	O
(	O
moves_to_connect_in_two_moves	function
(	O
moves	array
,	O
str1	int
,	O
str2	int
)	O
)	O
return	O
WIN	int
;	O
order_connection_moves	function
(	O
moves	array
,	O
str1	int
,	O
str2	int
,	O
board	pointer
[	O
str1	int
]	O
,	O
"simple_connection_three_moves"	pointer
)	O
;	O
for	O
(	O
r	int
=	O
1	int
;	O
(	O
(	O
r	int
<	O
moves	array
[	O
0	int
]	O
+	O
1	int
)	O
&&	O
!	O
res	int
)	O
;	O
r	int
++	O
)	O
{	O
if	O
(	O
trymove	function
(	O
moves	array
[	O
r	int
]	O
,	O
board	pointer
[	O
str1	int
]	O
,	O
"simple_connection_three_moves"	pointer
,	O
str1	int
)	O
)	O
{	O
if	O
(	O
simply_connected_two_moves	function
(	O
str1	int
,	O
str2	int
)	O
)	O
res	int
=	O
WIN	int
;	O
popgo	function
(	O
)	O
;	O
}	O
}	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
return	O
res	int
;	O
}	O
static	O
int	O
prevent_simple_connection_three_moves	function
(	O
int	O
*	O
moves	array
,	O
int	O
str1	int
,	O
int	O
str2	int
)	O
{	O
int	O
r	int
,	O
res	int
=	O
0	int
;	O
int	O
possible_moves	array
[	O
MAX_MOVES	int
]	O
;	O
SGFTree	struct
*	O
save_sgf_dumptree	pointer
=	O
sgf_dumptree	pointer
;	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
if	O
(	O
simple_connection_three_moves	function
(	O
str1	int
,	O
str2	int
)	O
)	O
{	O
res	int
=	O
WIN	int
;	O
possible_moves	array
[	O
0	int
]	O
=	O
0	int
;	O
moves_to_prevent_connection_in_three_moves	function
(	O
possible_moves	array
,	O
str1	int
,	O
str2	int
)	O
;	O
order_connection_moves	function
(	O
moves	array
,	O
str1	int
,	O
str2	int
,	O
OTHER_COLOR	O
(	O
board	pointer
[	O
str1	int
]	O
)	O
,	O
"prevent_simple_connection_three_moves"	pointer
)	O
;	O
for	O
(	O
r	int
=	O
1	int
;	O
r	int
<	O
possible_moves	array
[	O
0	int
]	O
+	O
1	int
;	O
r	int
++	O
)	O
{	O
if	O
(	O
trymove	function
(	O
possible_moves	array
[	O
r	int
]	O
,	O
OTHER_COLOR	O
(	O
board	pointer
[	O
str1	int
]	O
)	O
,	O
"prevent_simple_connection_three_moves"	pointer
,	O
str1	int
)	O
)	O
{	O
if	O
(	O
!	O
connection_one_move	function
(	O
str1	int
,	O
str2	int
)	O
)	O
if	O
(	O
!	O
connection_two_moves	function
(	O
str1	int
,	O
str2	int
)	O
)	O
if	O
(	O
!	O
simple_connection_three_moves	function
(	O
str1	int
,	O
str2	int
)	O
)	O
add_array	function
(	O
moves	array
,	O
possible_moves	array
[	O
r	int
]	O
)	O
;	O
popgo	function
(	O
)	O
;	O
}	O
}	O
}	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
return	O
res	int
;	O
}	O
static	O
int	O
quiescence_connect	function
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
*	O
move	pointer
)	O
{	O
int	O
r	int
;	O
int	O
lib	int
;	O
int	O
adj	array
,	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
if	O
(	O
have_common_lib	function
(	O
str1	int
,	O
str2	int
,	O
&	O
lib	int
)	O
)	O
{	O
*	O
move	pointer
=	O
lib	int
;	O
return	O
WIN	int
;	O
}	O
adj	array
=	O
chainlinks2	function
(	O
str1	int
,	O
adjs	array
,	O
1	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array
;	O
r	int
++	O
)	O
if	O
(	O
adjacent_strings	function
(	O
adjs	array
[	O
r	int
]	O
,	O
str2	int
)	O
&&	O
!	O
snapback	function
(	O
adjs	array
[	O
r	int
]	O
)	O
)	O
{	O
findlib	function
(	O
adjs	array
[	O
r	int
]	O
,	O
1	int
,	O
move	pointer
)	O
;	O
return	O
WIN	int
;	O
}	O
adj	array
=	O
chainlinks2	function
(	O
str1	int
,	O
adjs	array
,	O
2	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array
;	O
r	int
++	O
)	O
if	O
(	O
adjacent_strings	function
(	O
adjs	array
[	O
r	int
]	O
,	O
str2	int
)	O
)	O
if	O
(	O
quiescence_capture	function
(	O
adjs	array
[	O
r	int
]	O
,	O
move	pointer
)	O
)	O
return	O
WIN	int
;	O
return	O
0	int
;	O
}	O
int	O
string_connect	function
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
*	O
move	pointer
)	O
{	O
int	O
dummy_move	int
;	O
int	O
save_verbose	int
;	O
int	O
result	int
;	O
if	O
(	O
move	pointer
==	O
NULL	O
)	O
move	pointer
=	O
&	O
dummy_move	int
;	O
nodes_connect	int
=	O
0	int
;	O
*	O
move	pointer
=	O
PASS_MOVE	int
;	O
if	O
(	O
alternate_connections	int
)	O
{	O
int	O
reading_nodes_when_called	int
=	O
get_reading_node_counter	function
(	O
)	O
;	O
double	O
start	double
=	O
0	int
;	O
int	O
tactical_nodes	int
;	O
int	O
save_connection_node_limit	int
=	O
connection_node_limit	int
;	O
if	O
(	O
board	pointer
[	O
str1	int
]	O
==	O
EMPTY	int
||	O
board	pointer
[	O
str2	int
]	O
==	O
EMPTY	int
)	O
return	O
0	int
;	O
str1	int
=	O
find_origin	function
(	O
str1	int
)	O
;	O
str2	int
=	O
find_origin	function
(	O
str2	int
)	O
;	O
if	O
(	O
str1	int
>	O
str2	int
)	O
{	O
int	O
tmp	int
=	O
str1	int
;	O
str1	int
=	O
str2	int
;	O
str2	int
=	O
tmp	int
;	O
}	O
connection_node_limit	int
*=	O
pow	function
(	O
1.45	int
,	O
-	O
stackp	int
+	O
get_depth_modification	function
(	O
)	O
)	O
;	O
save_verbose	int
=	O
verbose	int
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
verbose	int
--	O
;	O
start	double
=	O
gg_cputime	function
(	O
)	O
;	O
memset	function
(	O
connection_shadow	array
,	O
0	int
,	O
sizeof	O
(	O
connection_shadow	array
)	O
)	O
;	O
result	int
=	O
recursive_connect2	function
(	O
str1	int
,	O
str2	int
,	O
move	pointer
,	O
0	int
)	O
;	O
verbose	int
=	O
save_verbose	int
;	O
tactical_nodes	int
=	O
get_reading_node_counter	function
(	O
)	O
-	O
reading_nodes_when_called	int
;	O
connection_node_limit	int
=	O
save_connection_node_limit	int
;	O
if	O
(	O
0	int
)	O
{	O
gprintf	function
(	O
"%oconnect    %1M %1M, result %d %1M (%d, %d nodes, %f seconds)\n"	pointer
,	O
str1	int
,	O
str2	int
,	O
result	int
,	O
*	O
move	pointer
,	O
nodes_connect	int
,	O
tactical_nodes	int
,	O
gg_cputime	function
(	O
)	O
-	O
start	double
)	O
;	O
dump_stack	function
(	O
)	O
;	O
}	O
if	O
(	O
0	int
)	O
{	O
gprintf	function
(	O
"%oconnect %1m %1m %d %1m "	pointer
,	O
str1	int
,	O
str2	int
,	O
result	int
,	O
*	O
move	pointer
)	O
;	O
dump_stack	function
(	O
)	O
;	O
}	O
return	O
result	int
;	O
}	O
return	O
recursive_connect	function
(	O
str1	int
,	O
str2	int
,	O
move	pointer
)	O
;	O
}	O
static	O
int	O
recursive_connect	function
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
*	O
move	pointer
)	O
{	O
int	O
i	int
,	O
res	int
=	O
0	int
,	O
Moves	array
[	O
MAX_MOVES	int
]	O
,	O
ForcedMoves	array
[	O
MAX_MOVES	int
]	O
;	O
SETUP_TRACE_INFO2	O
(	O
"recursive_connect"	pointer
,	O
str1	int
,	O
str2	int
)	O
;	O
if	O
(	O
board	pointer
[	O
str1	int
]	O
==	O
EMPTY	int
||	O
board	pointer
[	O
str2	int
]	O
==	O
EMPTY	int
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	int
,	O
0	int
,	O
"one string already captured"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
same_string	function
(	O
str1	int
,	O
str2	int
)	O
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	int
,	O
WIN	int
,	O
"already connected"	pointer
)	O
;	O
return	O
WIN	int
;	O
}	O
if	O
(	O
nodes_connect	int
>	O
connection_node_limit	int
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	int
,	O
0	int
,	O
"connection node limit reached"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
stackp	int
==	O
connect_depth	int
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	int
,	O
0	int
,	O
"connection depth limit reached"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
nodes_connect	int
++	O
;	O
global_connection_node_counter	int
++	O
;	O
if	O
(	O
quiescence_connect	function
(	O
str1	int
,	O
str2	int
,	O
move	pointer
)	O
)	O
{	O
SGFTRACE2	O
(	O
*	O
move	pointer
,	O
WIN	int
,	O
"quiescence_connect"	pointer
)	O
;	O
return	O
WIN	int
;	O
}	O
ForcedMoves	array
[	O
0	int
]	O
=	O
0	int
;	O
Moves	array
[	O
0	int
]	O
=	O
0	int
;	O
if	O
(	O
!	O
prevent_capture_one_move	function
(	O
ForcedMoves	array
,	O
str1	int
)	O
)	O
prevent_capture_one_move	function
(	O
ForcedMoves	array
,	O
str2	int
)	O
;	O
moves_to_connect_in_three_moves	function
(	O
Moves	array
,	O
str1	int
,	O
str2	int
,	O
1	int
)	O
;	O
if	O
(	O
ForcedMoves	array
[	O
0	int
]	O
!=	O
0	int
&&	O
Moves	array
[	O
0	int
]	O
!=	O
0	int
)	O
intersection_array	function
(	O
Moves	array
,	O
ForcedMoves	array
)	O
;	O
order_connection_moves	function
(	O
Moves	array
,	O
str1	int
,	O
str2	int
,	O
board	pointer
[	O
str1	int
]	O
,	O
"recursive_connect"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
(	O
(	O
i	int
<	O
Moves	array
[	O
0	int
]	O
+	O
1	int
)	O
&&	O
(	O
res	int
==	O
0	int
)	O
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
trymove	function
(	O
Moves	array
[	O
i	int
]	O
,	O
board	pointer
[	O
str1	int
]	O
,	O
"recursive_connect"	pointer
,	O
str1	int
)	O
)	O
{	O
if	O
(	O
!	O
recursive_disconnect	function
(	O
str1	int
,	O
str2	int
,	O
move	pointer
)	O
)	O
{	O
*	O
move	pointer
=	O
Moves	array
[	O
i	int
]	O
;	O
res	int
=	O
WIN	int
;	O
}	O
popgo	function
(	O
)	O
;	O
}	O
}	O
if	O
(	O
res	int
==	O
WIN	int
)	O
{	O
SGFTRACE2	O
(	O
*	O
move	pointer
,	O
WIN	int
,	O
"success"	pointer
)	O
;	O
}	O
else	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	int
,	O
0	int
,	O
"failure"	pointer
)	O
;	O
}	O
return	O
res	int
;	O
}	O
int	O
disconnect	function
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
*	O
move	pointer
)	O
{	O
int	O
i	int
;	O
int	O
res	int
=	O
WIN	int
;	O
int	O
Moves	array
[	O
MAX_MOVES	int
]	O
;	O
int	O
dummy_move	int
;	O
int	O
result	int
;	O
int	O
save_verbose	int
;	O
if	O
(	O
move	pointer
==	O
NULL	O
)	O
move	pointer
=	O
&	O
dummy_move	int
;	O
nodes_connect	int
=	O
0	int
;	O
*	O
move	pointer
=	O
PASS_MOVE	int
;	O
if	O
(	O
alternate_connections	int
)	O
{	O
int	O
reading_nodes_when_called	int
=	O
get_reading_node_counter	function
(	O
)	O
;	O
int	O
save_connection_node_limit	int
=	O
connection_node_limit	int
;	O
double	O
start	double
=	O
0	int
;	O
int	O
tactical_nodes	int
;	O
if	O
(	O
board	pointer
[	O
str1	int
]	O
==	O
EMPTY	int
||	O
board	pointer
[	O
str2	int
]	O
==	O
EMPTY	int
)	O
return	O
WIN	int
;	O
str1	int
=	O
find_origin	function
(	O
str1	int
)	O
;	O
str2	int
=	O
find_origin	function
(	O
str2	int
)	O
;	O
if	O
(	O
str1	int
>	O
str2	int
)	O
{	O
int	O
tmp	int
=	O
str1	int
;	O
str1	int
=	O
str2	int
;	O
str2	int
=	O
tmp	int
;	O
}	O
connection_node_limit	int
*=	O
pow	function
(	O
1.5	int
,	O
-	O
stackp	int
+	O
get_depth_modification	function
(	O
)	O
)	O
;	O
save_verbose	int
=	O
verbose	int
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
verbose	int
--	O
;	O
start	double
=	O
gg_cputime	function
(	O
)	O
;	O
memset	function
(	O
connection_shadow	array
,	O
0	int
,	O
sizeof	O
(	O
connection_shadow	array
)	O
)	O
;	O
result	int
=	O
recursive_disconnect2	function
(	O
str1	int
,	O
str2	int
,	O
move	pointer
,	O
0	int
)	O
;	O
verbose	int
=	O
save_verbose	int
;	O
tactical_nodes	int
=	O
get_reading_node_counter	function
(	O
)	O
-	O
reading_nodes_when_called	int
;	O
connection_node_limit	int
=	O
save_connection_node_limit	int
;	O
if	O
(	O
0	int
)	O
{	O
gprintf	function
(	O
"%odisconnect %1m %1m, result %d %1m (%d, %d nodes, %f seconds)\n"	pointer
,	O
str1	int
,	O
str2	int
,	O
result	int
,	O
*	O
move	pointer
,	O
nodes_connect	int
,	O
tactical_nodes	int
,	O
gg_cputime	function
(	O
)	O
-	O
start	double
)	O
;	O
dump_stack	function
(	O
)	O
;	O
}	O
if	O
(	O
0	int
)	O
{	O
gprintf	function
(	O
"%odisconnect %1m %1m %d %1m "	pointer
,	O
str1	int
,	O
str2	int
,	O
result	int
,	O
*	O
move	pointer
)	O
;	O
dump_stack	function
(	O
)	O
;	O
}	O
return	O
result	int
;	O
}	O
Moves	array
[	O
0	int
]	O
=	O
0	int
;	O
moves_to_prevent_connection_in_three_moves	function
(	O
Moves	array
,	O
str1	int
,	O
str2	int
)	O
;	O
if	O
(	O
Moves	array
[	O
0	int
]	O
>	O
0	int
)	O
res	int
=	O
0	int
;	O
order_connection_moves	function
(	O
Moves	array
,	O
str1	int
,	O
str2	int
,	O
OTHER_COLOR	O
(	O
board	pointer
[	O
str1	int
]	O
)	O
,	O
"disconnect"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
(	O
(	O
i	int
<	O
Moves	array
[	O
0	int
]	O
+	O
1	int
)	O
&&	O
(	O
res	int
==	O
0	int
)	O
)	O
;	O
i	int
++	O
)	O
if	O
(	O
trymove	function
(	O
Moves	array
[	O
i	int
]	O
,	O
OTHER_COLOR	O
(	O
board	pointer
[	O
str1	int
]	O
)	O
,	O
"disconnect"	pointer
,	O
str1	int
)	O
)	O
{	O
if	O
(	O
!	O
recursive_connect	function
(	O
str1	int
,	O
str2	int
,	O
move	pointer
)	O
)	O
{	O
*	O
move	pointer
=	O
Moves	array
[	O
i	int
]	O
;	O
res	int
=	O
WIN	int
;	O
}	O
popgo	function
(	O
)	O
;	O
}	O
return	O
res	int
;	O
}	O
int	O
fast_disconnect	function
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
*	O
move	pointer
)	O
{	O
int	O
result	int
;	O
int	O
save_limit	int
=	O
connection_node_limit	int
;	O
int	O
save_verbose	int
=	O
verbose	int
;	O
if	O
(	O
board	pointer
[	O
str1	int
]	O
==	O
EMPTY	int
||	O
board	pointer
[	O
str2	int
]	O
==	O
EMPTY	int
)	O
return	O
WIN	int
;	O
str1	int
=	O
find_origin	function
(	O
str1	int
)	O
;	O
str2	int
=	O
find_origin	function
(	O
str2	int
)	O
;	O
if	O
(	O
str1	int
>	O
str2	int
)	O
{	O
int	O
tmp	int
=	O
str1	int
;	O
str1	int
=	O
str2	int
;	O
str2	int
=	O
tmp	int
;	O
}	O
modify_depth_values	function
(	O
-	O
3	int
)	O
;	O
connection_node_limit	int
/=	O
4	int
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
verbose	int
--	O
;	O
result	int
=	O
recursive_disconnect2	function
(	O
str1	int
,	O
str2	int
,	O
move	pointer
,	O
0	int
)	O
;	O
verbose	int
=	O
save_verbose	int
;	O
connection_node_limit	int
=	O
save_limit	int
;	O
modify_depth_values	function
(	O
3	int
)	O
;	O
return	O
result	int
;	O
}	O
static	O
int	O
recursive_disconnect	function
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
*	O
move	pointer
)	O
{	O
int	O
i	int
,	O
res	int
=	O
WIN	int
,	O
Moves	array
[	O
MAX_MOVES	int
]	O
;	O
SETUP_TRACE_INFO2	O
(	O
"recursive_disconnect"	pointer
,	O
str1	int
,	O
str2	int
)	O
;	O
if	O
(	O
board	pointer
[	O
str1	int
]	O
==	O
EMPTY	int
||	O
board	pointer
[	O
str2	int
]	O
==	O
EMPTY	int
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	int
,	O
WIN	int
,	O
"one string already captured"	pointer
)	O
;	O
return	O
WIN	int
;	O
}	O
if	O
(	O
quiescence_capture	function
(	O
str1	int
,	O
move	pointer
)	O
)	O
{	O
SGFTRACE2	O
(	O
*	O
move	pointer
,	O
WIN	int
,	O
"first string capturable"	pointer
)	O
;	O
return	O
WIN	int
;	O
}	O
if	O
(	O
quiescence_capture	function
(	O
str2	int
,	O
move	pointer
)	O
)	O
{	O
SGFTRACE2	O
(	O
*	O
move	pointer
,	O
WIN	int
,	O
"second string capturable"	pointer
)	O
;	O
return	O
WIN	int
;	O
}	O
if	O
(	O
same_string	function
(	O
str1	int
,	O
str2	int
)	O
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	int
,	O
0	int
,	O
"already connected"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
nodes_connect	int
>	O
connection_node_limit	int
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	int
,	O
WIN	int
,	O
"connection node limit reached"	pointer
)	O
;	O
return	O
WIN	int
;	O
}	O
if	O
(	O
stackp	int
==	O
connect_depth	int
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	int
,	O
WIN	int
,	O
"connection depth limit reached"	pointer
)	O
;	O
return	O
WIN	int
;	O
}	O
nodes_connect	int
++	O
;	O
global_connection_node_counter	int
++	O
;	O
Moves	array
[	O
0	int
]	O
=	O
0	int
;	O
if	O
(	O
prevent_connection_one_move	function
(	O
Moves	array
,	O
str1	int
,	O
str2	int
)	O
)	O
res	int
=	O
0	int
;	O
else	O
if	O
(	O
prevent_connection_two_moves	function
(	O
Moves	array
,	O
str1	int
,	O
str2	int
)	O
)	O
res	int
=	O
0	int
;	O
else	O
if	O
(	O
prevent_simple_connection_three_moves	function
(	O
Moves	array
,	O
str1	int
,	O
str2	int
)	O
)	O
res	int
=	O
0	int
;	O
if	O
(	O
res	int
==	O
0	int
)	O
order_connection_moves	function
(	O
Moves	array
,	O
str1	int
,	O
str2	int
,	O
OTHER_COLOR	O
(	O
board	pointer
[	O
str1	int
]	O
)	O
,	O
"recursive_disconnect"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
(	O
(	O
i	int
<	O
Moves	array
[	O
0	int
]	O
+	O
1	int
)	O
&&	O
(	O
res	int
==	O
0	int
)	O
)	O
;	O
i	int
++	O
)	O
if	O
(	O
trymove	function
(	O
Moves	array
[	O
i	int
]	O
,	O
OTHER_COLOR	O
(	O
board	pointer
[	O
str1	int
]	O
)	O
,	O
"recursive_disconnect"	pointer
,	O
str1	int
)	O
)	O
{	O
if	O
(	O
!	O
recursive_connect	function
(	O
str1	int
,	O
str2	int
,	O
move	pointer
)	O
)	O
{	O
*	O
move	pointer
=	O
Moves	array
[	O
i	int
]	O
;	O
res	int
=	O
WIN	int
;	O
}	O
popgo	function
(	O
)	O
;	O
}	O
if	O
(	O
res	int
==	O
WIN	int
)	O
{	O
SGFTRACE2	O
(	O
*	O
move	pointer
,	O
WIN	int
,	O
"success"	pointer
)	O
;	O
}	O
else	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	int
,	O
0	int
,	O
"failure"	pointer
)	O
;	O
}	O
return	O
res	int
;	O
}	O
static	O
int	O
quiescence_capture	function
(	O
int	O
str	int
,	O
int	O
*	O
move	pointer
)	O
{	O
SGFTree	struct
*	O
save_sgf_dumptree	pointer
=	O
sgf_dumptree	pointer
;	O
int	O
save_count_variations	int
=	O
count_variations	int
;	O
int	O
result	int
=	O
0	int
;	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
if	O
(	O
countlib	function
(	O
str	int
)	O
==	O
1	int
)	O
{	O
findlib	function
(	O
str	int
,	O
1	int
,	O
move	pointer
)	O
;	O
result	int
=	O
WIN	int
;	O
}	O
else	O
if	O
(	O
countlib	function
(	O
str	int
)	O
==	O
2	int
)	O
result	int
=	O
simple_ladder	function
(	O
str	int
,	O
move	pointer
)	O
;	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
count_variations	int
=	O
save_count_variations	int
;	O
return	O
result	int
;	O
}	O
static	O
int	O
prevent_capture_one_move	function
(	O
int	O
*	O
moves	array
,	O
int	O
str1	int
)	O
{	O
int	O
r	int
,	O
res	int
=	O
0	int
;	O
int	O
liberties	pointer
,	O
libs	pointer
[	O
MAXLIBS	O
]	O
;	O
int	O
adj	array
,	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
liberties	pointer
=	O
findlib	function
(	O
str1	int
,	O
MAXLIBS	O
,	O
libs	pointer
)	O
;	O
if	O
(	O
liberties	pointer
==	O
1	int
)	O
{	O
add_array	function
(	O
moves	array
,	O
libs	pointer
[	O
0	int
]	O
)	O
;	O
res	int
=	O
WIN	int
;	O
adj	array
=	O
chainlinks2	function
(	O
str1	int
,	O
adjs	array
,	O
1	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array
;	O
r	int
++	O
)	O
{	O
findlib	function
(	O
adjs	array
[	O
r	int
]	O
,	O
1	int
,	O
libs	pointer
)	O
;	O
add_array	function
(	O
moves	array
,	O
libs	pointer
[	O
0	int
]	O
)	O
;	O
}	O
}	O
return	O
res	int
;	O
}	O
static	O
int	O
recursive_transitivity	function
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
str3	int
,	O
int	O
*	O
move	pointer
)	O
{	O
int	O
i	int
,	O
res	int
=	O
0	int
,	O
Moves	array
[	O
MAX_MOVES	int
]	O
,	O
ForcedMoves	array
[	O
MAX_MOVES	int
]	O
;	O
SETUP_TRACE_INFO2	O
(	O
"recursive_transitivity"	pointer
,	O
str1	int
,	O
str3	int
)	O
;	O
if	O
(	O
board	pointer
[	O
str1	int
]	O
==	O
EMPTY	int
||	O
board	pointer
[	O
str2	int
]	O
==	O
EMPTY	int
||	O
board	pointer
[	O
str3	int
]	O
==	O
EMPTY	int
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	int
,	O
0	int
,	O
"one string already captured"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
same_string	function
(	O
str1	int
,	O
str2	int
)	O
&&	O
same_string	function
(	O
str1	int
,	O
str3	int
)	O
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	int
,	O
WIN	int
,	O
"already connected"	pointer
)	O
;	O
return	O
WIN	int
;	O
}	O
if	O
(	O
nodes_connect	int
>	O
connection_node_limit	int
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	int
,	O
0	int
,	O
"connection node limit reached"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
stackp	int
==	O
connect_depth	int
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	int
,	O
0	int
,	O
"connection depth limit reached"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
nodes_connect	int
++	O
;	O
global_connection_node_counter	int
++	O
;	O
if	O
(	O
same_string	function
(	O
str1	int
,	O
str2	int
)	O
)	O
if	O
(	O
quiescence_connect	function
(	O
str1	int
,	O
str3	int
,	O
move	pointer
)	O
)	O
{	O
SGFTRACE2	O
(	O
*	O
move	pointer
,	O
WIN	int
,	O
"quiescence_connect"	pointer
)	O
;	O
return	O
WIN	int
;	O
}	O
if	O
(	O
same_string	function
(	O
str2	int
,	O
str3	int
)	O
)	O
if	O
(	O
quiescence_connect	function
(	O
str1	int
,	O
str2	int
,	O
move	pointer
)	O
)	O
{	O
SGFTRACE2	O
(	O
*	O
move	pointer
,	O
WIN	int
,	O
"quiescence_connect"	pointer
)	O
;	O
return	O
WIN	int
;	O
}	O
ForcedMoves	array
[	O
0	int
]	O
=	O
0	int
;	O
Moves	array
[	O
0	int
]	O
=	O
0	int
;	O
if	O
(	O
!	O
prevent_capture_one_move	function
(	O
ForcedMoves	array
,	O
str1	int
)	O
)	O
if	O
(	O
!	O
prevent_capture_one_move	function
(	O
ForcedMoves	array
,	O
str2	int
)	O
)	O
prevent_capture_one_move	function
(	O
ForcedMoves	array
,	O
str3	int
)	O
;	O
moves_to_connect_in_two_moves	function
(	O
Moves	array
,	O
str1	int
,	O
str2	int
)	O
;	O
moves_to_connect_in_two_moves	function
(	O
Moves	array
,	O
str2	int
,	O
str3	int
)	O
;	O
if	O
(	O
(	O
ForcedMoves	array
[	O
0	int
]	O
!=	O
0	int
)	O
&&	O
(	O
Moves	array
[	O
0	int
]	O
!=	O
0	int
)	O
)	O
intersection_array	function
(	O
Moves	array
,	O
ForcedMoves	array
)	O
;	O
order_connection_moves	function
(	O
Moves	array
,	O
str1	int
,	O
str2	int
,	O
board	pointer
[	O
str1	int
]	O
,	O
"recursive_transitivity"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
(	O
(	O
i	int
<	O
Moves	array
[	O
0	int
]	O
+	O
1	int
)	O
&&	O
(	O
res	int
==	O
0	int
)	O
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
trymove	function
(	O
Moves	array
[	O
i	int
]	O
,	O
board	pointer
[	O
str1	int
]	O
,	O
"recursive_transitivity"	pointer
,	O
str1	int
)	O
)	O
{	O
if	O
(	O
!	O
recursive_non_transitivity	function
(	O
str1	int
,	O
str2	int
,	O
str3	int
,	O
move	pointer
)	O
)	O
{	O
*	O
move	pointer
=	O
Moves	array
[	O
i	int
]	O
;	O
res	int
=	O
WIN	int
;	O
}	O
popgo	function
(	O
)	O
;	O
}	O
}	O
if	O
(	O
res	int
==	O
WIN	int
)	O
{	O
SGFTRACE2	O
(	O
*	O
move	pointer
,	O
WIN	int
,	O
"success"	pointer
)	O
;	O
}	O
else	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	int
,	O
0	int
,	O
"failure"	pointer
)	O
;	O
}	O
return	O
res	int
;	O
}	O
int	O
non_transitivity	function
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
str3	int
,	O
int	O
*	O
move	pointer
)	O
{	O
int	O
i	int
,	O
res	int
=	O
WIN	int
,	O
Moves	array
[	O
MAX_MOVES	int
]	O
;	O
nodes_connect	int
=	O
0	int
;	O
*	O
move	pointer
=	O
PASS_MOVE	int
;	O
moves_to_prevent_connection_in_three_moves	function
(	O
Moves	array
,	O
str1	int
,	O
str3	int
)	O
;	O
if	O
(	O
Moves	array
[	O
0	int
]	O
>	O
0	int
)	O
res	int
=	O
0	int
;	O
order_connection_moves	function
(	O
Moves	array
,	O
str1	int
,	O
str2	int
,	O
OTHER_COLOR	O
(	O
board	pointer
[	O
str1	int
]	O
)	O
,	O
"non_transitivity"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
(	O
(	O
i	int
<	O
Moves	array
[	O
0	int
]	O
+	O
1	int
)	O
&&	O
(	O
res	int
==	O
0	int
)	O
)	O
;	O
i	int
++	O
)	O
if	O
(	O
trymove	function
(	O
Moves	array
[	O
i	int
]	O
,	O
OTHER_COLOR	O
(	O
board	pointer
[	O
str1	int
]	O
)	O
,	O
"non_transitivity"	pointer
,	O
str1	int
)	O
)	O
{	O
if	O
(	O
!	O
recursive_transitivity	function
(	O
str1	int
,	O
str2	int
,	O
str3	int
,	O
move	pointer
)	O
)	O
{	O
*	O
move	pointer
=	O
Moves	array
[	O
i	int
]	O
;	O
res	int
=	O
WIN	int
;	O
}	O
popgo	function
(	O
)	O
;	O
}	O
return	O
res	int
;	O
}	O
static	O
int	O
recursive_non_transitivity	function
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
str3	int
,	O
int	O
*	O
move	pointer
)	O
{	O
int	O
i	int
,	O
res	int
=	O
WIN	int
,	O
Moves	array
[	O
MAX_MOVES	int
]	O
;	O
SETUP_TRACE_INFO2	O
(	O
"recursive_non_transitivity"	pointer
,	O
str1	int
,	O
str3	int
)	O
;	O
if	O
(	O
board	pointer
[	O
str1	int
]	O
==	O
EMPTY	int
||	O
board	pointer
[	O
str2	int
]	O
==	O
EMPTY	int
||	O
board	pointer
[	O
str3	int
]	O
==	O
EMPTY	int
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	int
,	O
WIN	int
,	O
"one string already captured"	pointer
)	O
;	O
return	O
WIN	int
;	O
}	O
if	O
(	O
quiescence_capture	function
(	O
str1	int
,	O
move	pointer
)	O
)	O
{	O
SGFTRACE2	O
(	O
*	O
move	pointer
,	O
WIN	int
,	O
"first string capturable"	pointer
)	O
;	O
return	O
WIN	int
;	O
}	O
if	O
(	O
quiescence_capture	function
(	O
str2	int
,	O
move	pointer
)	O
)	O
{	O
SGFTRACE2	O
(	O
*	O
move	pointer
,	O
WIN	int
,	O
"second string capturable"	pointer
)	O
;	O
return	O
WIN	int
;	O
}	O
if	O
(	O
quiescence_capture	function
(	O
str3	int
,	O
move	pointer
)	O
)	O
{	O
SGFTRACE2	O
(	O
*	O
move	pointer
,	O
WIN	int
,	O
"third string capturable"	pointer
)	O
;	O
return	O
WIN	int
;	O
}	O
if	O
(	O
same_string	function
(	O
str1	int
,	O
str2	int
)	O
&&	O
same_string	function
(	O
str1	int
,	O
str3	int
)	O
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	int
,	O
0	int
,	O
"already connected"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
nodes_connect	int
>	O
connection_node_limit	int
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	int
,	O
WIN	int
,	O
"connection node limit reached"	pointer
)	O
;	O
return	O
WIN	int
;	O
}	O
if	O
(	O
stackp	int
==	O
connect_depth	int
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	int
,	O
WIN	int
,	O
"connection depth limit reached"	pointer
)	O
;	O
return	O
WIN	int
;	O
}	O
nodes_connect	int
++	O
;	O
global_connection_node_counter	int
++	O
;	O
Moves	array
[	O
0	int
]	O
=	O
0	int
;	O
if	O
(	O
prevent_connection_one_move	function
(	O
Moves	array
,	O
str1	int
,	O
str3	int
)	O
)	O
res	int
=	O
0	int
;	O
else	O
if	O
(	O
prevent_connection_two_moves	function
(	O
Moves	array
,	O
str1	int
,	O
str3	int
)	O
)	O
res	int
=	O
0	int
;	O
else	O
if	O
(	O
prevent_simple_connection_three_moves	function
(	O
Moves	array
,	O
str1	int
,	O
str3	int
)	O
)	O
res	int
=	O
0	int
;	O
if	O
(	O
res	int
==	O
0	int
)	O
order_connection_moves	function
(	O
Moves	array
,	O
str1	int
,	O
str2	int
,	O
OTHER_COLOR	O
(	O
board	pointer
[	O
str1	int
]	O
)	O
,	O
"recursive_non_transitivity"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
(	O
(	O
i	int
<	O
Moves	array
[	O
0	int
]	O
+	O
1	int
)	O
&&	O
(	O
res	int
==	O
0	int
)	O
)	O
;	O
i	int
++	O
)	O
if	O
(	O
trymove	function
(	O
Moves	array
[	O
i	int
]	O
,	O
OTHER_COLOR	O
(	O
board	pointer
[	O
str1	int
]	O
)	O
,	O
"recursive_non_transitivity"	pointer
,	O
str1	int
)	O
)	O
{	O
if	O
(	O
!	O
recursive_transitivity	function
(	O
str1	int
,	O
str2	int
,	O
str3	int
,	O
move	pointer
)	O
)	O
{	O
*	O
move	pointer
=	O
Moves	array
[	O
i	int
]	O
;	O
res	int
=	O
WIN	int
;	O
}	O
popgo	function
(	O
)	O
;	O
}	O
if	O
(	O
res	int
==	O
WIN	int
)	O
{	O
SGFTRACE2	O
(	O
*	O
move	pointer
,	O
WIN	int
,	O
"success"	pointer
)	O
;	O
}	O
else	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	int
,	O
0	int
,	O
"failure"	pointer
)	O
;	O
}	O
return	O
res	int
;	O
}	O
static	O
void	O
order_connection_moves	function
(	O
int	O
*	O
moves	array
,	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
color_to_move	int
,	O
const	O
char	O
*	O
funcname	pointer
)	O
{	O
int	O
scores	array
[	O
MAX_MOVES	int
]	O
;	O
int	O
r	int
;	O
int	O
i	int
,	O
j	int
;	O
UNUSED	O
(	O
str2	int
)	O
;	O
UNUSED	O
(	O
color_to_move	int
)	O
;	O
for	O
(	O
r	int
=	O
1	int
;	O
r	int
<=	O
moves	array
[	O
0	int
]	O
;	O
r	int
++	O
)	O
{	O
int	O
move	pointer
=	O
moves	array
[	O
r	int
]	O
;	O
int	O
number_edges	pointer
=	O
0	int
;	O
int	O
number_same_string	pointer
=	O
0	int
;	O
int	O
number_own	pointer
=	O
0	int
;	O
int	O
number_opponent	pointer
=	O
0	int
;	O
int	O
captured_stones	pointer
=	O
0	int
;	O
int	O
threatened_stones	pointer
=	O
0	int
;	O
int	O
saved_stones	pointer
=	O
0	int
;	O
int	O
number_open	pointer
=	O
0	int
;	O
int	O
libs	pointer
;	O
incremental_order_moves	function
(	O
move	pointer
,	O
color_to_move	int
,	O
str1	int
,	O
&	O
number_edges	pointer
,	O
&	O
number_same_string	pointer
,	O
&	O
number_own	pointer
,	O
&	O
number_opponent	pointer
,	O
&	O
captured_stones	pointer
,	O
&	O
threatened_stones	pointer
,	O
&	O
saved_stones	pointer
,	O
&	O
number_open	pointer
)	O
;	O
if	O
(	O
0	int
)	O
gprintf	function
(	O
"%o %1m values: %d %d %d %d %d %d %d %d\n"	pointer
,	O
move	pointer
,	O
number_edges	pointer
,	O
number_same_string	pointer
,	O
number_own	pointer
,	O
number_opponent	pointer
,	O
captured_stones	pointer
,	O
threatened_stones	pointer
,	O
saved_stones	pointer
,	O
number_open	pointer
)	O
;	O
scores	array
[	O
r	int
]	O
=	O
0	int
;	O
libs	pointer
=	O
approxlib	function
(	O
move	pointer
,	O
color_to_move	int
,	O
10	int
,	O
NULL	O
)	O
;	O
if	O
(	O
libs	pointer
==	O
1	int
&&	O
captured_stones	pointer
==	O
0	int
)	O
scores	array
[	O
r	int
]	O
-=	O
10	int
;	O
if	O
(	O
libs	pointer
<	O
4	int
)	O
scores	array
[	O
r	int
]	O
+=	O
libs	pointer
;	O
else	O
scores	array
[	O
r	int
]	O
+=	O
4	int
;	O
if	O
(	O
captured_stones	pointer
>	O
0	int
)	O
scores	array
[	O
r	int
]	O
+=	O
5	int
+	O
captured_stones	pointer
;	O
if	O
(	O
threatened_stones	pointer
>	O
0	int
)	O
scores	array
[	O
r	int
]	O
+=	O
3	int
;	O
if	O
(	O
saved_stones	pointer
>	O
0	int
)	O
scores	array
[	O
r	int
]	O
+=	O
10	int
+	O
saved_stones	pointer
;	O
}	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
moves	array
[	O
0	int
]	O
;	O
i	int
++	O
)	O
{	O
int	O
maxscore	int
=	O
scores	array
[	O
i	int
]	O
;	O
int	O
max_at	int
=	O
i	int
;	O
for	O
(	O
j	int
=	O
i	int
+	O
1	int
;	O
j	int
<=	O
moves	array
[	O
0	int
]	O
;	O
j	int
++	O
)	O
{	O
if	O
(	O
scores	array
[	O
j	int
]	O
>	O
maxscore	int
)	O
{	O
maxscore	int
=	O
scores	array
[	O
j	int
]	O
;	O
max_at	int
=	O
j	int
;	O
}	O
}	O
if	O
(	O
max_at	int
!=	O
i	int
)	O
{	O
int	O
temp	int
=	O
moves	array
[	O
i	int
]	O
;	O
int	O
tempmax	int
=	O
scores	array
[	O
i	int
]	O
;	O
moves	array
[	O
i	int
]	O
=	O
moves	array
[	O
max_at	int
]	O
;	O
scores	array
[	O
i	int
]	O
=	O
scores	array
[	O
max_at	int
]	O
;	O
moves	array
[	O
max_at	int
]	O
=	O
temp	int
;	O
scores	array
[	O
max_at	int
]	O
=	O
tempmax	int
;	O
}	O
}	O
if	O
(	O
0	int
)	O
{	O
gprintf	function
(	O
"%oVariation %d:\n"	pointer
,	O
count_variations	int
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
moves	array
[	O
0	int
]	O
;	O
i	int
++	O
)	O
gprintf	function
(	O
"%o  %1M %d\n"	pointer
,	O
moves	array
[	O
i	int
]	O
,	O
scores	array
[	O
i	int
]	O
)	O
;	O
}	O
if	O
(	O
sgf_dumptree	pointer
)	O
{	O
char	O
buf	pointer
[	O
500	int
]	O
;	O
char	O
*	O
pos	int
;	O
int	O
chars	int
;	O
sprintf	function
(	O
buf	pointer
,	O
"Move order for %s: %n"	pointer
,	O
funcname	pointer
,	O
&	O
chars	int
)	O
;	O
pos	int
=	O
buf	pointer
+	O
chars	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
moves	array
[	O
0	int
]	O
;	O
i	int
++	O
)	O
{	O
sprintf	function
(	O
pos	int
,	O
"%c%d (%d) %n"	pointer
,	O
J	O
(	O
moves	array
[	O
i	int
]	O
)	O
+	O
'A'	O
+	O
(	O
J	O
(	O
moves	array
[	O
i	int
]	O
)	O
>=	O
8	int
)	O
,	O
board_size	int
-	O
I	O
(	O
moves	array
[	O
i	int
]	O
)	O
,	O
scores	array
[	O
i	int
]	O
,	O
&	O
chars	int
)	O
;	O
pos	int
+=	O
chars	int
;	O
}	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
buf	pointer
)	O
;	O
}	O
}	O
void	O
reset_connection_node_counter	function
(	O
)	O
{	O
global_connection_node_counter	int
=	O
0	int
;	O
}	O
int	O
get_connection_node_counter	function
(	O
)	O
{	O
return	O
global_connection_node_counter	int
;	O
}	O
static	O
int	O
find_string_connection_moves	function
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
color_to_move	int
,	O
int	O
moves	array
[	O
MAX_MOVES	int
]	O
,	O
int	O
*	O
total_distance	pointer
)	O
;	O
static	O
void	O
clear_connection_data	function
(	O
struct	O
connection_data	struct
*	O
conn	pointer
)	O
;	O
static	O
int	O
trivial_connection	function
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
*	O
move	pointer
)	O
;	O
static	O
int	O
does_secure_through_ladder	function
(	O
int	O
color	int
,	O
int	O
move	pointer
,	O
int	O
pos	int
)	O
;	O
static	O
int	O
ladder_capture	function
(	O
int	O
str	int
,	O
int	O
*	O
move	pointer
)	O
;	O
static	O
int	O
ladder_capturable	function
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
;	O
static	O
int	O
no_escape_from_atari	function
(	O
int	O
str	int
)	O
;	O
static	O
int	O
no_escape_from_ladder	function
(	O
int	O
str	int
)	O
;	O
static	O
int	O
check_self_atari	function
(	O
int	O
pos	int
,	O
int	O
color_to_move	int
)	O
;	O
static	O
int	O
common_vulnerabilities	function
(	O
int	O
a1	int
,	O
int	O
a2	int
,	O
int	O
b1	int
,	O
int	O
b2	int
,	O
int	O
color	int
)	O
;	O
static	O
int	O
common_vulnerability	function
(	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
int	O
color	int
)	O
;	O
static	O
int	O
recursive_connect2	function
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
*	O
move	pointer
,	O
int	O
has_passed	int
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str1	int
]	O
;	O
int	O
moves	array
[	O
MAX_MOVES	int
]	O
;	O
int	O
num_moves	int
;	O
int	O
distance	int
=	O
FP	O
(	O
0.0	int
)	O
;	O
int	O
k	int
;	O
int	O
xpos	int
;	O
int	O
savemove	int
=	O
NO_MOVE	O
;	O
int	O
savecode	int
=	O
0	int
;	O
int	O
tried_moves	int
=	O
0	int
;	O
int	O
value	pointer
;	O
SETUP_TRACE_INFO2	O
(	O
"recursive_connect2"	pointer
,	O
str1	int
,	O
str2	int
)	O
;	O
if	O
(	O
move	pointer
)	O
*	O
move	pointer
=	O
NO_MOVE	O
;	O
nodes_connect	int
++	O
;	O
global_connection_node_counter	int
++	O
;	O
if	O
(	O
board	pointer
[	O
str1	int
]	O
==	O
EMPTY	int
||	O
board	pointer
[	O
str2	int
]	O
==	O
EMPTY	int
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	int
,	O
0	int
,	O
"one string already captured"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
same_string	function
(	O
str1	int
,	O
str2	int
)	O
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	int
,	O
WIN	int
,	O
"already connected"	pointer
)	O
;	O
return	O
WIN	int
;	O
}	O
if	O
(	O
nodes_connect	int
>	O
connection_node_limit	int
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	int
,	O
0	int
,	O
"connection node limit reached"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
stackp	int
>	O
connect_depth2	int
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	int
,	O
0	int
,	O
"connection depth limit reached"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
str1	int
=	O
find_origin	function
(	O
str1	int
)	O
;	O
str2	int
=	O
find_origin	function
(	O
str2	int
)	O
;	O
if	O
(	O
stackp	int
<=	O
depth	int
&&	O
!	O
has_passed	int
&&	O
tt_get	function
(	O
&	O
ttable	struct
,	O
CONNECT	int
,	O
str1	int
,	O
str2	int
,	O
depth	int
-	O
stackp	int
,	O
NULL	O
,	O
&	O
value	pointer
,	O
NULL	O
,	O
&	O
xpos	int
)	O
==	O
2	int
)	O
{	O
TRACE_CACHED_RESULT2	O
(	O
value	pointer
,	O
value	pointer
,	O
xpos	int
)	O
;	O
if	O
(	O
value	pointer
!=	O
0	int
)	O
if	O
(	O
move	pointer
)	O
*	O
move	pointer
=	O
xpos	int
;	O
SGFTRACE2	O
(	O
xpos	int
,	O
value	pointer
,	O
"cached"	pointer
)	O
;	O
return	O
value	pointer
;	O
}	O
if	O
(	O
trivial_connection	function
(	O
str1	int
,	O
str2	int
,	O
&	O
xpos	int
)	O
==	O
WIN	int
)	O
{	O
SGFTRACE2	O
(	O
xpos	int
,	O
WIN	int
,	O
"trivial connection"	pointer
)	O
;	O
READ_RETURN_CONN	O
(	O
CONNECT	int
,	O
str1	int
,	O
str2	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
xpos	int
,	O
WIN	int
)	O
;	O
}	O
num_moves	int
=	O
find_string_connection_moves	function
(	O
str1	int
,	O
str2	int
,	O
color	int
,	O
moves	array
,	O
&	O
distance	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_moves	int
;	O
k	int
++	O
)	O
{	O
int	O
ko_move	int
;	O
xpos	int
=	O
moves	array
[	O
k	int
]	O
;	O
if	O
(	O
komaster_trymove	function
(	O
xpos	int
,	O
color	int
,	O
"recursive_connect2"	pointer
,	O
str1	int
,	O
&	O
ko_move	int
,	O
stackp	int
<=	O
ko_depth	int
&&	O
savecode	int
==	O
0	int
)	O
)	O
{	O
tried_moves	int
++	O
;	O
if	O
(	O
!	O
ko_move	int
)	O
{	O
int	O
acode	int
=	O
recursive_disconnect2	function
(	O
str1	int
,	O
str2	int
,	O
NULL	O
,	O
has_passed	int
)	O
;	O
popgo	function
(	O
)	O
;	O
if	O
(	O
acode	int
==	O
0	int
)	O
{	O
SGFTRACE2	O
(	O
xpos	int
,	O
WIN	int
,	O
"connection effective"	pointer
)	O
;	O
READ_RETURN_CONN	O
(	O
CONNECT	int
,	O
str1	int
,	O
str2	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
xpos	int
,	O
WIN	int
)	O
;	O
}	O
UPDATE_SAVED_KO_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
acode	int
,	O
xpos	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
recursive_disconnect2	function
(	O
str1	int
,	O
str2	int
,	O
NULL	O
,	O
has_passed	int
)	O
!=	O
WIN	int
)	O
{	O
savemove	int
=	O
xpos	int
;	O
savecode	int
=	O
KO_B	int
;	O
}	O
popgo	function
(	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
tried_moves	int
==	O
0	int
&&	O
distance	int
<	O
FP	O
(	O
1.0	int
)	O
)	O
{	O
SGFTRACE2	O
(	O
NO_MOVE	O
,	O
WIN	int
,	O
"no move, probably connected"	pointer
)	O
;	O
READ_RETURN_CONN	O
(	O
CONNECT	int
,	O
str1	int
,	O
str2	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
NO_MOVE	O
,	O
WIN	int
)	O
;	O
}	O
if	O
(	O
savecode	int
!=	O
0	int
)	O
{	O
SGFTRACE2	O
(	O
savemove	int
,	O
savecode	int
,	O
"saved move"	pointer
)	O
;	O
READ_RETURN_CONN	O
(	O
CONNECT	int
,	O
str1	int
,	O
str2	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
savemove	int
,	O
savecode	int
)	O
;	O
}	O
SGFTRACE2	O
(	O
0	int
,	O
0	int
,	O
NULL	O
)	O
;	O
READ_RETURN_CONN	O
(	O
CONNECT	int
,	O
str1	int
,	O
str2	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
NO_MOVE	O
,	O
0	int
)	O
;	O
}	O
static	O
int	O
recursive_disconnect2	function
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
*	O
move	pointer
,	O
int	O
has_passed	int
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str1	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
moves	array
[	O
MAX_MOVES	int
]	O
;	O
int	O
num_moves	int
;	O
int	O
distance	int
=	O
FP	O
(	O
0.0	int
)	O
;	O
int	O
k	int
;	O
int	O
xpos	int
;	O
int	O
savemove	int
=	O
NO_MOVE	O
;	O
int	O
savecode	int
=	O
0	int
;	O
int	O
tried_moves	int
=	O
0	int
;	O
int	O
attack_code1	int
;	O
int	O
attack_pos1	int
;	O
int	O
attack_code2	int
;	O
int	O
attack_pos2	int
;	O
SGFTree	struct
*	O
save_sgf_dumptree	pointer
=	O
sgf_dumptree	pointer
;	O
int	O
save_count_variations	int
=	O
count_variations	int
;	O
int	O
value	pointer
;	O
SETUP_TRACE_INFO2	O
(	O
"recursive_disconnect2"	pointer
,	O
str1	int
,	O
str2	int
)	O
;	O
nodes_connect	int
++	O
;	O
global_connection_node_counter	int
++	O
;	O
if	O
(	O
move	pointer
)	O
*	O
move	pointer
=	O
NO_MOVE	O
;	O
if	O
(	O
board	pointer
[	O
str1	int
]	O
==	O
EMPTY	int
||	O
board	pointer
[	O
str2	int
]	O
==	O
EMPTY	int
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	int
,	O
WIN	int
,	O
"one string already captured"	pointer
)	O
;	O
return	O
WIN	int
;	O
}	O
if	O
(	O
same_string	function
(	O
str1	int
,	O
str2	int
)	O
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	int
,	O
0	int
,	O
"already connected"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
nodes_connect	int
>	O
connection_node_limit	int
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	int
,	O
WIN	int
,	O
"connection node limit reached"	pointer
)	O
;	O
return	O
WIN	int
;	O
}	O
if	O
(	O
stackp	int
>	O
connect_depth2	int
)	O
{	O
SGFTRACE2	O
(	O
PASS_MOVE	int
,	O
WIN	int
,	O
"connection depth limit reached"	pointer
)	O
;	O
return	O
WIN	int
;	O
}	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
str1	int
=	O
find_origin	function
(	O
str1	int
)	O
;	O
str2	int
=	O
find_origin	function
(	O
str2	int
)	O
;	O
attack_code1	int
=	O
attack	function
(	O
str1	int
,	O
&	O
attack_pos1	int
)	O
;	O
if	O
(	O
attack_code1	int
==	O
WIN	int
)	O
{	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
count_variations	int
=	O
save_count_variations	int
;	O
SGFTRACE2	O
(	O
attack_pos1	int
,	O
WIN	int
,	O
"one string is capturable"	pointer
)	O
;	O
if	O
(	O
move	pointer
)	O
*	O
move	pointer
=	O
attack_pos1	int
;	O
return	O
WIN	int
;	O
}	O
attack_code2	int
=	O
attack	function
(	O
str2	int
,	O
&	O
attack_pos2	int
)	O
;	O
if	O
(	O
attack_code2	int
==	O
WIN	int
)	O
{	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
count_variations	int
=	O
save_count_variations	int
;	O
SGFTRACE2	O
(	O
attack_pos2	int
,	O
WIN	int
,	O
"one string is capturable"	pointer
)	O
;	O
if	O
(	O
move	pointer
)	O
*	O
move	pointer
=	O
attack_pos2	int
;	O
return	O
WIN	int
;	O
}	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
count_variations	int
=	O
save_count_variations	int
;	O
if	O
(	O
stackp	int
<=	O
depth	int
&&	O
tt_get	function
(	O
&	O
ttable	struct
,	O
DISCONNECT	int
,	O
str1	int
,	O
str2	int
,	O
depth	int
-	O
stackp	int
,	O
NULL	O
,	O
&	O
value	pointer
,	O
NULL	O
,	O
&	O
xpos	int
)	O
==	O
2	int
)	O
{	O
TRACE_CACHED_RESULT2	O
(	O
value	pointer
,	O
value	pointer
,	O
xpos	int
)	O
;	O
if	O
(	O
value	pointer
!=	O
0	int
)	O
if	O
(	O
move	pointer
)	O
*	O
move	pointer
=	O
xpos	int
;	O
SGFTRACE2	O
(	O
xpos	int
,	O
value	pointer
,	O
"cached"	pointer
)	O
;	O
return	O
value	pointer
;	O
}	O
if	O
(	O
ladder_capture	function
(	O
str1	int
,	O
&	O
xpos	int
)	O
==	O
WIN	int
)	O
{	O
SGFTRACE2	O
(	O
xpos	int
,	O
WIN	int
,	O
"first string capturable"	pointer
)	O
;	O
READ_RETURN_CONN	O
(	O
DISCONNECT	int
,	O
str1	int
,	O
str2	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
xpos	int
,	O
WIN	int
)	O
;	O
}	O
if	O
(	O
ladder_capture	function
(	O
str2	int
,	O
&	O
xpos	int
)	O
==	O
WIN	int
)	O
{	O
SGFTRACE2	O
(	O
xpos	int
,	O
WIN	int
,	O
"second string capturable"	pointer
)	O
;	O
READ_RETURN_CONN	O
(	O
DISCONNECT	int
,	O
str1	int
,	O
str2	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
xpos	int
,	O
WIN	int
)	O
;	O
}	O
num_moves	int
=	O
find_string_connection_moves	function
(	O
str1	int
,	O
str2	int
,	O
other	int
,	O
moves	array
,	O
&	O
distance	int
)	O
;	O
if	O
(	O
attack_code1	int
!=	O
0	int
&&	O
num_moves	int
<	O
MAX_MOVES	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_moves	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
moves	array
[	O
k	int
]	O
==	O
attack_pos1	int
)	O
break	O
;	O
}	O
if	O
(	O
k	int
==	O
num_moves	int
)	O
moves	array
[	O
num_moves	int
++	O
]	O
=	O
attack_pos1	int
;	O
}	O
if	O
(	O
attack_code2	int
!=	O
0	int
&&	O
num_moves	int
<	O
MAX_MOVES	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_moves	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
moves	array
[	O
k	int
]	O
==	O
attack_pos2	int
)	O
break	O
;	O
}	O
if	O
(	O
k	int
==	O
num_moves	int
)	O
moves	array
[	O
num_moves	int
++	O
]	O
=	O
attack_pos2	int
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_moves	int
;	O
k	int
++	O
)	O
{	O
int	O
ko_move	int
;	O
xpos	int
=	O
moves	array
[	O
k	int
]	O
;	O
if	O
(	O
komaster_trymove	function
(	O
xpos	int
,	O
other	int
,	O
"recursive_disconnect2"	pointer
,	O
str1	int
,	O
&	O
ko_move	int
,	O
stackp	int
<=	O
ko_depth	int
&&	O
savecode	int
==	O
0	int
)	O
)	O
{	O
tried_moves	int
++	O
;	O
if	O
(	O
!	O
ko_move	int
)	O
{	O
int	O
dcode	int
=	O
recursive_connect2	function
(	O
str1	int
,	O
str2	int
,	O
NULL	O
,	O
has_passed	int
)	O
;	O
popgo	function
(	O
)	O
;	O
if	O
(	O
dcode	int
==	O
0	int
)	O
{	O
SGFTRACE2	O
(	O
xpos	int
,	O
WIN	int
,	O
"disconnection effective"	pointer
)	O
;	O
READ_RETURN_CONN	O
(	O
DISCONNECT	int
,	O
str1	int
,	O
str2	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
xpos	int
,	O
WIN	int
)	O
;	O
}	O
UPDATE_SAVED_KO_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
dcode	int
,	O
xpos	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
recursive_connect2	function
(	O
str1	int
,	O
str2	int
,	O
NULL	O
,	O
has_passed	int
)	O
!=	O
WIN	int
)	O
{	O
savemove	int
=	O
xpos	int
;	O
savecode	int
=	O
KO_B	int
;	O
}	O
popgo	function
(	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
tried_moves	int
==	O
0	int
&&	O
distance	int
>=	O
FP	O
(	O
1.0	int
)	O
&&	O
(	O
has_passed	int
||	O
!	O
recursive_connect2	function
(	O
str1	int
,	O
str2	int
,	O
NULL	O
,	O
1	int
)	O
)	O
)	O
{	O
SGFTRACE2	O
(	O
NO_MOVE	O
,	O
WIN	int
,	O
"no move, probably disconnected"	pointer
)	O
;	O
READ_RETURN_CONN	O
(	O
DISCONNECT	int
,	O
str1	int
,	O
str2	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
NO_MOVE	O
,	O
WIN	int
)	O
;	O
}	O
if	O
(	O
savecode	int
!=	O
0	int
)	O
{	O
SGFTRACE2	O
(	O
savemove	int
,	O
savecode	int
,	O
"saved move"	pointer
)	O
;	O
READ_RETURN_CONN	O
(	O
DISCONNECT	int
,	O
str1	int
,	O
str2	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
savemove	int
,	O
savecode	int
)	O
;	O
}	O
SGFTRACE2	O
(	O
0	int
,	O
0	int
,	O
NULL	O
)	O
;	O
READ_RETURN_CONN	O
(	O
DISCONNECT	int
,	O
str1	int
,	O
str2	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
NO_MOVE	O
,	O
0	int
)	O
;	O
}	O
static	O
int	O
find_connection_moves	function
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
color_to_move	int
,	O
struct	O
connection_data	struct
*	O
conn1	pointer
,	O
struct	O
connection_data	struct
*	O
conn2	pointer
,	O
int	O
max_dist1	int
,	O
int	O
max_dist2	int
,	O
int	O
moves	array
[	O
MAX_MOVES	int
]	O
,	O
int	O
total_distance	pointer
,	O
int	O
cutoff	int
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str1	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
connect_move	int
=	O
(	O
color_to_move	int
==	O
color	int
)	O
;	O
int	O
r	int
;	O
int	O
distances	array
[	O
MAX_MOVES	int
]	O
;	O
int	O
num_moves	int
=	O
0	int
;	O
int	O
acode	int
=	O
0	int
;	O
int	O
attack_move	pointer
=	O
NO_MOVE	O
;	O
int	O
dcode	int
=	O
0	int
;	O
int	O
defense_move	int
=	O
NO_MOVE	O
;	O
int	O
k	int
;	O
int	O
i	int
,	O
j	int
;	O
SGFTree	struct
*	O
save_sgf_dumptree	pointer
=	O
sgf_dumptree	pointer
;	O
int	O
save_count_variations	int
=	O
count_variations	int
;	O
int	O
distance_limit	int
;	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
conn1	pointer
->	O
queue_end	int
;	O
r	int
++	O
)	O
{	O
int	O
pos	int
=	O
conn1	pointer
->	O
queue	array
[	O
r	int
]	O
;	O
int	O
dist1	int
=	O
conn1	pointer
->	O
distances	array
[	O
pos	int
]	O
;	O
int	O
deltadist1	int
=	O
conn1	pointer
->	O
deltas	array
[	O
pos	int
]	O
;	O
int	O
dist2	int
=	O
conn2	pointer
->	O
distances	array
[	O
pos	int
]	O
;	O
int	O
deltadist2	int
=	O
conn2	pointer
->	O
deltas	array
[	O
pos	int
]	O
;	O
int	O
d1	int
;	O
int	O
d2	int
;	O
int	O
distance	int
;	O
if	O
(	O
dist1	int
-	O
deltadist1	int
+	O
dist2	int
-	O
deltadist2	int
>	O
FP	O
(	O
2.5	int
)	O
||	O
dist1	int
>	O
max_dist1	int
+	O
FP	O
(	O
0.2	int
)	O
||	O
dist2	int
>	O
max_dist2	int
+	O
FP	O
(	O
0.2	int
)	O
)	O
continue	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	function
(	O
"%oMove %1m, (%f, %f, %f, %f)\n"	pointer
,	O
pos	int
,	O
FIXED_TO_FLOAT	O
(	O
dist1	int
)	O
,	O
FIXED_TO_FLOAT	O
(	O
deltadist1	int
)	O
,	O
FIXED_TO_FLOAT	O
(	O
dist2	int
)	O
,	O
FIXED_TO_FLOAT	O
(	O
deltadist2	int
)	O
)	O
;	O
d1	int
=	O
dist1	int
-	O
deltadist1	int
;	O
d2	int
=	O
dist2	int
-	O
deltadist2	int
;	O
distance	int
=	O
d1	int
+	O
d2	int
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	function
(	O
"%o  %f, primary distance\n"	pointer
,	O
FIXED_TO_FLOAT	O
(	O
distance	int
)	O
)	O
;	O
if	O
(	O
(	O
3	int
*	O
d1	int
)	O
/	O
2	int
>	O
d2	int
&&	O
(	O
3	int
*	O
d2	int
)	O
/	O
2	int
>	O
d1	int
)	O
{	O
distance	int
-=	O
FP	O
(	O
0.1	int
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	function
(	O
"%o  -0.1, well balanced\n"	pointer
)	O
;	O
}	O
if	O
(	O
conn1	pointer
->	O
coming_from	int
[	O
pos	int
]	O
!=	O
NO_MOVE	O
&&	O
conn1	pointer
->	O
coming_from	int
[	O
pos	int
]	O
==	O
conn2	pointer
->	O
coming_from	int
[	O
pos	int
]	O
)	O
{	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	function
(	O
"%o  discarded, not between strings\n"	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
{	O
if	O
(	O
check_self_atari	function
(	O
pos	int
,	O
color_to_move	int
)	O
)	O
{	O
ADD_CANDIDATE_MOVE	O
(	O
pos	int
,	O
distance	int
,	O
moves	array
,	O
distances	array
,	O
num_moves	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	function
(	O
"%o  discarded, self atari\n"	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
other	int
)	O
{	O
attack_and_defend	function
(	O
pos	int
,	O
&	O
acode	int
,	O
&	O
attack_move	pointer
,	O
&	O
dcode	int
,	O
&	O
defense_move	int
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	function
(	O
"%o  attack with code %d at %1m, defense with code %d at %1m\n"	pointer
,	O
acode	int
,	O
attack_move	pointer
,	O
dcode	int
,	O
defense_move	int
)	O
;	O
if	O
(	O
connect_move	int
&&	O
acode	int
!=	O
0	int
)	O
{	O
if	O
(	O
dcode	int
==	O
0	int
)	O
{	O
distance	int
+=	O
FP	O
(	O
0.5	int
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	function
(	O
"%o  +0.5, no defense\n"	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
conn1	pointer
->	O
distances	array
[	O
attack_move	pointer
]	O
+	O
conn2	pointer
->	O
distances	array
[	O
attack_move	pointer
]	O
>	O
dist1	int
+	O
dist2	int
)	O
{	O
distance	int
+=	O
FP	O
(	O
0.5	int
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	function
(	O
"%o  +0.5, attack point not on shortest path\n"	pointer
)	O
;	O
}	O
}	O
ADD_CANDIDATE_MOVE	O
(	O
attack_move	pointer
,	O
distance	int
-	O
FP	O
(	O
0.15	int
)	O
,	O
moves	array
,	O
distances	array
,	O
num_moves	int
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	function
(	O
"%o  -0.15 at %1m, capturing a string\n"	pointer
,	O
attack_move	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
connect_move	int
&&	O
acode	int
!=	O
0	int
&&	O
dcode	int
!=	O
0	int
)	O
{	O
ADD_CANDIDATE_MOVE	O
(	O
defense_move	int
,	O
distance	int
-	O
FP	O
(	O
0.5	int
)	O
,	O
moves	array
,	O
distances	array
,	O
num_moves	int
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	function
(	O
"%o  -0.5 at %1m, defending a string\n"	pointer
,	O
defense_move	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
color	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
apos	int
,	O
bpos	int
;	O
if	O
(	O
k	int
&	O
1	int
)	O
apos	int
=	O
conn1	pointer
->	O
vulnerable1	array
[	O
pos	int
]	O
;	O
else	O
apos	int
=	O
conn1	pointer
->	O
vulnerable2	array
[	O
pos	int
]	O
;	O
if	O
(	O
k	int
&	O
2	int
)	O
bpos	int
=	O
conn2	pointer
->	O
vulnerable1	array
[	O
pos	int
]	O
;	O
else	O
bpos	int
=	O
conn2	pointer
->	O
vulnerable2	array
[	O
pos	int
]	O
;	O
if	O
(	O
common_vulnerability	function
(	O
apos	int
,	O
bpos	int
,	O
color	int
)	O
)	O
{	O
if	O
(	O
check_self_atari	function
(	O
apos	int
,	O
color_to_move	int
)	O
)	O
{	O
ADD_CANDIDATE_MOVE	O
(	O
apos	int
,	O
distance	int
,	O
moves	array
,	O
distances	array
,	O
num_moves	int
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	function
(	O
"%o  +0.0 at %1m, vulnerability\n"	pointer
,	O
apos	int
)	O
;	O
}	O
if	O
(	O
bpos	int
!=	O
apos	int
&&	O
check_self_atari	function
(	O
bpos	int
,	O
color_to_move	int
)	O
)	O
{	O
ADD_CANDIDATE_MOVE	O
(	O
bpos	int
,	O
distance	int
,	O
moves	array
,	O
distances	array
,	O
num_moves	int
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	function
(	O
"%o  +0.0 at %1m, vulnerability\n"	pointer
,	O
bpos	int
)	O
;	O
}	O
}	O
}	O
}	O
}	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
num_moves	int
;	O
r	int
++	O
)	O
{	O
int	O
move	pointer
=	O
moves	array
[	O
r	int
]	O
;	O
int	O
adjacent_to_attacker	int
=	O
0	int
;	O
int	O
bonus_given	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
pos	int
=	O
move	pointer
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
other	int
)	O
{	O
adjacent_to_attacker	int
=	O
1	int
;	O
distances	array
[	O
r	int
]	O
-=	O
FP	O
(	O
0.15	int
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	function
(	O
"%o%1M -0.15, adjacent to attacker string\n"	pointer
,	O
move	pointer
)	O
;	O
if	O
(	O
countlib	function
(	O
pos	int
)	O
<=	O
2	int
)	O
{	O
distances	array
[	O
r	int
]	O
-=	O
FP	O
(	O
0.2	int
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	function
(	O
"%o%1M -0.2, adjacent to attacker string with at most two liberties\n"	pointer
,	O
move	pointer
)	O
;	O
if	O
(	O
(	O
connect_move	int
||	O
!	O
bonus_given	int
)	O
&&	O
(	O
conn1	pointer
->	O
distances	array
[	O
move	pointer
]	O
-	O
conn1	pointer
->	O
deltas	array
[	O
move	pointer
]	O
<=	O
FP	O
(	O
0.5	int
)	O
||	O
conn1	pointer
->	O
distances	array
[	O
pos	int
]	O
-	O
conn1	pointer
->	O
deltas	array
[	O
pos	int
]	O
<=	O
FP	O
(	O
0.5	int
)	O
)	O
&&	O
(	O
conn2	pointer
->	O
distances	array
[	O
move	pointer
]	O
-	O
conn2	pointer
->	O
deltas	array
[	O
move	pointer
]	O
<=	O
FP	O
(	O
0.5	int
)	O
||	O
conn2	pointer
->	O
distances	array
[	O
pos	int
]	O
-	O
conn2	pointer
->	O
deltas	array
[	O
pos	int
]	O
<=	O
FP	O
(	O
0.5	int
)	O
)	O
&&	O
conn1	pointer
->	O
distances	array
[	O
pos	int
]	O
<	O
total_distance	pointer
&&	O
conn2	pointer
->	O
distances	array
[	O
pos	int
]	O
<	O
total_distance	pointer
)	O
{	O
bonus_given	int
=	O
1	int
;	O
distances	array
[	O
r	int
]	O
-=	O
FP	O
(	O
0.7	int
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	function
(	O
"%o%1M -0.7, capture or atari of immediately connecting string\n"	pointer
,	O
move	pointer
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
color	int
)	O
{	O
if	O
(	O
countlib	function
(	O
pos	int
)	O
<=	O
2	int
)	O
{	O
distances	array
[	O
r	int
]	O
-=	O
FP	O
(	O
0.2	int
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	function
(	O
"%o%1M -0.2, adjacent to defender string with at most two liberties\n"	pointer
,	O
move	pointer
)	O
;	O
}	O
if	O
(	O
!	O
connect_move	int
&&	O
countlib	function
(	O
pos	int
)	O
==	O
1	int
&&	O
accuratelib	function
(	O
move	pointer
,	O
other	int
,	O
2	int
,	O
NULL	O
)	O
>	O
1	int
)	O
{	O
int	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
bonus	int
;	O
bonus	int
=	O
FP	O
(	O
0.1	int
)	O
*	O
chainlinks2	function
(	O
pos	int
,	O
adjs	array
,	O
2	int
)	O
;	O
bonus	int
+=	O
FP	O
(	O
0.5	int
)	O
*	O
chainlinks2	function
(	O
pos	int
,	O
adjs	array
,	O
1	int
)	O
;	O
distances	array
[	O
r	int
]	O
-=	O
bonus	int
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	function
(	O
"%o%1M -%f, capture of defender string\n"	pointer
,	O
move	pointer
,	O
FIXED_TO_FLOAT	O
(	O
bonus	int
)	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
adjacent_to_attacker	int
&&	O
!	O
connect_move	int
&&	O
is_edge_vertex	function
(	O
move	pointer
)	O
)	O
{	O
distances	array
[	O
r	int
]	O
-=	O
FP	O
(	O
0.1	int
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	function
(	O
"%o%1M -0.1, disconnect move on edge\n"	pointer
,	O
move	pointer
)	O
;	O
}	O
if	O
(	O
ladder_capturable	function
(	O
move	pointer
,	O
color_to_move	int
)	O
)	O
{	O
distances	array
[	O
r	int
]	O
+=	O
FP	O
(	O
0.3	int
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	function
(	O
"%o%1M +0.3, can be captured in a ladder\n"	pointer
,	O
move	pointer
)	O
;	O
}	O
if	O
(	O
(	O
liberty_of_string	function
(	O
move	pointer
,	O
str1	int
)	O
&&	O
countlib	function
(	O
str1	int
)	O
==	O
3	int
)	O
||	O
(	O
ON_BOARD	O
(	O
str2	int
)	O
&&	O
liberty_of_string	function
(	O
move	pointer
,	O
str2	int
)	O
&&	O
countlib	function
(	O
str2	int
)	O
==	O
3	int
)	O
)	O
{	O
distances	array
[	O
r	int
]	O
-=	O
FP	O
(	O
0.1	int
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
gprintf	function
(	O
"%o%1M -0.1, liberty of endpoint string with 3 libs\n"	pointer
,	O
move	pointer
)	O
;	O
}	O
}	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
count_variations	int
=	O
save_count_variations	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_moves	int
;	O
i	int
++	O
)	O
{	O
int	O
mindistance	int
=	O
distances	array
[	O
i	int
]	O
;	O
int	O
min_at	int
=	O
i	int
;	O
for	O
(	O
j	int
=	O
i	int
+	O
1	int
;	O
j	int
<	O
num_moves	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
distances	array
[	O
j	int
]	O
<	O
mindistance	int
)	O
{	O
mindistance	int
=	O
distances	array
[	O
j	int
]	O
;	O
min_at	int
=	O
j	int
;	O
}	O
}	O
if	O
(	O
min_at	int
!=	O
i	int
)	O
{	O
int	O
temp	int
=	O
moves	array
[	O
i	int
]	O
;	O
int	O
tempmin	int
=	O
distances	array
[	O
i	int
]	O
;	O
moves	array
[	O
i	int
]	O
=	O
moves	array
[	O
min_at	int
]	O
;	O
distances	array
[	O
i	int
]	O
=	O
distances	array
[	O
min_at	int
]	O
;	O
moves	array
[	O
min_at	int
]	O
=	O
temp	int
;	O
distances	array
[	O
min_at	int
]	O
=	O
tempmin	int
;	O
}	O
}	O
if	O
(	O
verbose	int
>	O
0	int
)	O
{	O
gprintf	function
(	O
"%oSorted moves:\n"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_moves	int
;	O
i	int
++	O
)	O
gprintf	function
(	O
"%o%1M %f\n"	pointer
,	O
moves	array
[	O
i	int
]	O
,	O
FIXED_TO_FLOAT	O
(	O
distances	array
[	O
i	int
]	O
)	O
)	O
;	O
}	O
if	O
(	O
sgf_dumptree	pointer
)	O
{	O
char	O
buf	pointer
[	O
500	int
]	O
;	O
char	O
*	O
pos	int
;	O
int	O
chars	int
;	O
sprintf	function
(	O
buf	pointer
,	O
"Move order for %sconnect: %n"	pointer
,	O
connect_move	int
?	O
""	pointer
:	O
"dis"	pointer
,	O
&	O
chars	int
)	O
;	O
pos	int
=	O
buf	pointer
+	O
chars	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_moves	int
;	O
i	int
++	O
)	O
{	O
sprintf	function
(	O
pos	int
,	O
"%c%d (%4.2f) %n"	pointer
,	O
J	O
(	O
moves	array
[	O
i	int
]	O
)	O
+	O
'A'	O
+	O
(	O
J	O
(	O
moves	array
[	O
i	int
]	O
)	O
>=	O
8	int
)	O
,	O
board_size	int
-	O
I	O
(	O
moves	array
[	O
i	int
]	O
)	O
,	O
FIXED_TO_FLOAT	O
(	O
distances	array
[	O
i	int
]	O
)	O
,	O
&	O
chars	int
)	O
;	O
pos	int
+=	O
chars	int
;	O
}	O
if	O
(	O
cutoff	int
<	O
HUGE_CONNECTION_DISTANCE	O
)	O
{	O
sprintf	function
(	O
pos	int
,	O
"(cutoff %f)%n"	pointer
,	O
FIXED_TO_FLOAT	O
(	O
cutoff	int
)	O
,	O
&	O
chars	int
)	O
;	O
pos	int
+=	O
chars	int
;	O
}	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
buf	pointer
)	O
;	O
}	O
if	O
(	O
num_moves	int
==	O
0	int
)	O
return	O
num_moves	int
;	O
if	O
(	O
num_moves	int
<=	O
1	int
||	O
!	O
is_ko	function
(	O
moves	array
[	O
0	int
]	O
,	O
color_to_move	int
,	O
NULL	O
)	O
)	O
distance_limit	int
=	O
distances	array
[	O
0	int
]	O
+	O
FP	O
(	O
1.5	int
)	O
;	O
else	O
distance_limit	int
=	O
distances	array
[	O
1	int
]	O
+	O
FP	O
(	O
1.5	int
)	O
;	O
if	O
(	O
num_moves	int
>	O
1	int
&&	O
distances	array
[	O
1	int
]	O
<	O
FP	O
(	O
1.0	int
)	O
&&	O
distances	array
[	O
1	int
]	O
>	O
distance_limit	int
)	O
distance_limit	int
=	O
distances	array
[	O
1	int
]	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
num_moves	int
;	O
r	int
++	O
)	O
{	O
if	O
(	O
r	int
>	O
1	int
&&	O
distances	array
[	O
r	int
]	O
>	O
distances	array
[	O
r	int
-	O
1	int
]	O
&&	O
distances	array
[	O
r	int
]	O
-	O
distances	array
[	O
r	int
-	O
1	int
]	O
>	O
(	O
8	int
-	O
r	int
)	O
*	O
FP	O
(	O
0.2	int
)	O
)	O
break	O
;	O
if	O
(	O
distances	array
[	O
r	int
]	O
>	O
distance_limit	int
||	O
distances	array
[	O
r	int
]	O
>	O
cutoff	int
)	O
break	O
;	O
}	O
num_moves	int
=	O
r	int
;	O
return	O
num_moves	int
;	O
}	O
static	O
int	O
find_string_connection_moves	function
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
color_to_move	int
,	O
int	O
moves	array
[	O
MAX_MOVES	int
]	O
,	O
int	O
*	O
total_distance	pointer
)	O
{	O
struct	O
connection_data	struct
conn1	pointer
;	O
struct	O
connection_data	struct
conn2	pointer
;	O
int	O
max_dist1	int
;	O
int	O
max_dist2	int
;	O
int	O
num_moves	int
;	O
int	O
lib	int
;	O
SGFTree	struct
*	O
save_sgf_dumptree	pointer
=	O
sgf_dumptree	pointer
;	O
int	O
save_count_variations	int
=	O
count_variations	int
;	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
compute_connection_distances	function
(	O
str1	int
,	O
str2	int
,	O
FP	O
(	O
3.051	int
)	O
,	O
&	O
conn1	pointer
,	O
1	int
)	O
;	O
compute_connection_distances	function
(	O
str2	int
,	O
str1	int
,	O
FP	O
(	O
3.051	int
)	O
,	O
&	O
conn2	pointer
,	O
1	int
)	O
;	O
if	O
(	O
findlib	function
(	O
str1	int
,	O
1	int
,	O
&	O
lib	int
)	O
==	O
1	int
)	O
{	O
conn1	pointer
.	O
distances	array
[	O
lib	int
]	O
=	O
0	int
;	O
conn1	pointer
.	O
coming_from	int
[	O
lib	int
]	O
=	O
NO_MOVE	O
;	O
conn2	pointer
.	O
distances	array
[	O
lib	int
]	O
=	O
conn2	pointer
.	O
distances	array
[	O
str1	int
]	O
;	O
conn2	pointer
.	O
coming_from	int
[	O
lib	int
]	O
=	O
conn1	pointer
.	O
coming_from	int
[	O
str1	int
]	O
;	O
}	O
if	O
(	O
findlib	function
(	O
str2	int
,	O
1	int
,	O
&	O
lib	int
)	O
==	O
1	int
)	O
{	O
conn2	pointer
.	O
distances	array
[	O
lib	int
]	O
=	O
0	int
;	O
conn1	pointer
.	O
distances	array
[	O
lib	int
]	O
=	O
conn1	pointer
.	O
distances	array
[	O
str2	int
]	O
;	O
}	O
max_dist1	int
=	O
conn1	pointer
.	O
distances	array
[	O
str2	int
]	O
;	O
max_dist2	int
=	O
conn2	pointer
.	O
distances	array
[	O
str1	int
]	O
;	O
*	O
total_distance	pointer
=	O
gg_min	O
(	O
max_dist1	int
,	O
max_dist2	int
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
{	O
gprintf	function
(	O
"%oVariation %d\n"	pointer
,	O
save_count_variations	int
)	O
;	O
dump_stack	function
(	O
)	O
;	O
showboard	function
(	O
0	int
)	O
;	O
print_connection_distances	function
(	O
&	O
conn1	pointer
)	O
;	O
print_connection_distances	function
(	O
&	O
conn2	pointer
)	O
;	O
}	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
count_variations	int
=	O
save_count_variations	int
;	O
num_moves	int
=	O
find_connection_moves	function
(	O
str1	int
,	O
str2	int
,	O
color_to_move	int
,	O
&	O
conn1	pointer
,	O
&	O
conn2	pointer
,	O
max_dist1	int
,	O
max_dist2	int
,	O
moves	array
,	O
*	O
total_distance	pointer
,	O
HUGE_CONNECTION_DISTANCE	O
)	O
;	O
return	O
num_moves	int
;	O
}	O
static	O
void	O
add_to_start_queue	function
(	O
int	O
pos	int
,	O
int	O
dist	int
,	O
struct	O
connection_data	struct
*	O
conn	pointer
)	O
{	O
conn	pointer
->	O
queue	array
[	O
conn	pointer
->	O
queue_end	int
++	O
]	O
=	O
pos	int
;	O
conn	pointer
->	O
distances	array
[	O
pos	int
]	O
=	O
dist	int
;	O
conn	pointer
->	O
deltas	array
[	O
pos	int
]	O
=	O
dist	int
;	O
conn	pointer
->	O
coming_from	int
[	O
pos	int
]	O
=	O
NO_MOVE	O
;	O
conn	pointer
->	O
vulnerable1	array
[	O
pos	int
]	O
=	O
NO_MOVE	O
;	O
conn	pointer
->	O
vulnerable2	array
[	O
pos	int
]	O
=	O
NO_MOVE	O
;	O
}	O
void	O
init_connection_data	function
(	O
int	O
color	int
,	O
const	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
,	O
int	O
target	int
,	O
int	O
cutoff	int
,	O
struct	O
connection_data	struct
*	O
conn	pointer
,	O
int	O
speculative	int
)	O
{	O
int	O
pos	int
;	O
signed	O
char	O
mark	char
[	O
BOARDMAX	O
]	O
;	O
memset	function
(	O
mark	char
,	O
0	int
,	O
BOARDMAX	O
)	O
;	O
VALGRIND_MAKE_WRITABLE	O
(	O
conn	pointer
,	O
sizeof	O
(	O
conn	pointer
)	O
)	O
;	O
clear_connection_data	function
(	O
conn	pointer
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
goal	pointer
[	O
pos	int
]	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
color	int
)	O
{	O
int	O
origin	int
=	O
find_origin	function
(	O
pos	int
)	O
;	O
if	O
(	O
!	O
mark	char
[	O
origin	int
]	O
)	O
{	O
add_to_start_queue	function
(	O
origin	int
,	O
FP	O
(	O
0.0	int
)	O
,	O
conn	pointer
)	O
;	O
mark	char
[	O
origin	int
]	O
=	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
add_to_start_queue	function
(	O
pos	int
,	O
FP	O
(	O
1.0	int
)	O
,	O
conn	pointer
)	O
;	O
}	O
}	O
conn	pointer
->	O
target	int
=	O
target	int
;	O
conn	pointer
->	O
cutoff_distance	int
=	O
cutoff	int
;	O
conn	pointer
->	O
speculative	int
=	O
speculative	int
;	O
}	O
static	O
int	O
find_break_moves	function
(	O
int	O
str	int
,	O
const	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
,	O
int	O
color_to_move	int
,	O
int	O
moves	array
[	O
MAX_MOVES	int
]	O
,	O
int	O
*	O
total_distance	pointer
)	O
{	O
struct	O
connection_data	struct
conn1	pointer
;	O
struct	O
connection_data	struct
conn2	pointer
;	O
int	O
max_dist1	int
=	O
HUGE_CONNECTION_DISTANCE	O
;	O
int	O
max_dist2	int
;	O
int	O
num_moves	int
;	O
int	O
str2	int
=	O
NO_MOVE	O
;	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
lib	int
;	O
int	O
k	int
;	O
SGFTree	struct
*	O
save_sgf_dumptree	pointer
=	O
sgf_dumptree	pointer
;	O
int	O
save_count_variations	int
=	O
count_variations	int
;	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
compute_connection_distances	function
(	O
str	int
,	O
NO_MOVE	O
,	O
FP	O
(	O
2.501	int
)	O
,	O
&	O
conn1	pointer
,	O
1	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
conn1	pointer
.	O
queue_end	int
;	O
k	int
++	O
)	O
if	O
(	O
board	pointer
[	O
conn1	pointer
.	O
queue	array
[	O
k	int
]	O
]	O
==	O
color	int
)	O
{	O
int	O
stones	pointer
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
num_stones	int
=	O
findstones	function
(	O
conn1	pointer
.	O
queue	array
[	O
k	int
]	O
,	O
MAX_BOARD	int
*	O
MAX_BOARD	int
,	O
stones	pointer
)	O
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_stones	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
goal	pointer
[	O
stones	pointer
[	O
i	int
]	O
]	O
)	O
{	O
str2	int
=	O
find_origin	function
(	O
stones	pointer
[	O
i	int
]	O
)	O
;	O
TRACE	O
(	O
"%oUsing %1m as secondary target.\n"	pointer
,	O
str2	int
)	O
;	O
mark_string	function
(	O
str2	int
,	O
breakin_shadow	array
,	O
1	int
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
i	int
<	O
num_stones	int
)	O
break	O
;	O
}	O
init_connection_data	function
(	O
color	int
,	O
goal	pointer
,	O
str	int
,	O
FP	O
(	O
2.501	int
)	O
,	O
&	O
conn2	pointer
,	O
1	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
conn2	pointer
.	O
queue_end	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
max_dist1	int
>	O
conn1	pointer
.	O
distances	array
[	O
conn2	pointer
.	O
queue	array
[	O
k	int
]	O
]	O
)	O
max_dist1	int
=	O
conn1	pointer
.	O
distances	array
[	O
conn2	pointer
.	O
queue	array
[	O
k	int
]	O
]	O
;	O
}	O
spread_connection_distances	function
(	O
color	int
,	O
&	O
conn2	pointer
)	O
;	O
if	O
(	O
findlib	function
(	O
str	int
,	O
1	int
,	O
&	O
lib	int
)	O
==	O
1	int
)	O
{	O
conn1	pointer
.	O
distances	array
[	O
lib	int
]	O
=	O
0	int
;	O
conn1	pointer
.	O
coming_from	int
[	O
lib	int
]	O
=	O
NO_MOVE	O
;	O
conn2	pointer
.	O
distances	array
[	O
lib	int
]	O
=	O
conn2	pointer
.	O
distances	array
[	O
str	int
]	O
;	O
conn2	pointer
.	O
coming_from	int
[	O
lib	int
]	O
=	O
conn1	pointer
.	O
coming_from	int
[	O
str	int
]	O
;	O
}	O
max_dist2	int
=	O
conn2	pointer
.	O
distances	array
[	O
str	int
]	O
;	O
*	O
total_distance	pointer
=	O
gg_min	O
(	O
max_dist1	int
,	O
max_dist2	int
)	O
;	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
count_variations	int
=	O
save_count_variations	int
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
{	O
gprintf	function
(	O
"%oVariation %d\n"	pointer
,	O
save_count_variations	int
)	O
;	O
dump_stack	function
(	O
)	O
;	O
showboard	function
(	O
0	int
)	O
;	O
print_connection_distances	function
(	O
&	O
conn1	pointer
)	O
;	O
print_connection_distances	function
(	O
&	O
conn2	pointer
)	O
;	O
}	O
{	O
int	O
cutoff	int
=	O
HUGE_CONNECTION_DISTANCE	O
;	O
if	O
(	O
breakin_depth	int
-	O
stackp	int
<=	O
5	int
)	O
cutoff	int
=	O
FP	O
(	O
1.101	int
)	O
+	O
(	O
breakin_depth	int
-	O
stackp	int
)	O
*	O
FP	O
(	O
0.15	int
)	O
;	O
num_moves	int
=	O
find_connection_moves	function
(	O
str	int
,	O
str2	int
,	O
color_to_move	int
,	O
&	O
conn1	pointer
,	O
&	O
conn2	pointer
,	O
max_dist1	int
,	O
max_dist2	int
,	O
moves	array
,	O
*	O
total_distance	pointer
,	O
cutoff	int
)	O
;	O
}	O
if	O
(	O
color_to_move	int
!=	O
board	pointer
[	O
str	int
]	O
)	O
{	O
int	O
move	pointer
;	O
if	O
(	O
num_moves	int
<	O
MAX_MOVES	int
&&	O
ON_BOARD	O
(	O
str2	int
)	O
&&	O
ladder_capture	function
(	O
str2	int
,	O
&	O
move	pointer
)	O
)	O
{	O
moves	array
[	O
num_moves	int
++	O
]	O
=	O
move	pointer
;	O
}	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_moves	int
;	O
k	int
++	O
)	O
breakin_shadow	array
[	O
moves	array
[	O
k	int
]	O
]	O
=	O
1	int
;	O
return	O
num_moves	int
;	O
}	O
static	O
int	O
recursive_break	function
(	O
int	O
str	int
,	O
const	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
,	O
int	O
*	O
move	pointer
,	O
int	O
has_passed	int
,	O
Hash_data	struct
*	O
goal_hash	pointer
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
moves	array
[	O
MAX_MOVES	int
]	O
;	O
int	O
num_moves	int
;	O
int	O
distance	int
=	O
FP	O
(	O
0.0	int
)	O
;	O
int	O
k	int
;	O
int	O
xpos	int
;	O
int	O
savemove	int
=	O
NO_MOVE	O
;	O
int	O
savecode	int
=	O
0	int
;	O
int	O
tried_moves	int
=	O
0	int
;	O
int	O
retval	int
;	O
SETUP_TRACE_INFO	O
(	O
"recursive_break"	pointer
,	O
str	int
)	O
;	O
if	O
(	O
move	pointer
)	O
*	O
move	pointer
=	O
NO_MOVE	O
;	O
nodes_connect	int
++	O
;	O
global_connection_node_counter	int
++	O
;	O
if	O
(	O
board	pointer
[	O
str	int
]	O
==	O
EMPTY	int
)	O
{	O
SGFTRACE	O
(	O
PASS_MOVE	int
,	O
0	int
,	O
"one string already captured"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
nodes_connect	int
>	O
breakin_node_limit	int
)	O
{	O
SGFTRACE	O
(	O
PASS_MOVE	int
,	O
0	int
,	O
"connection node limit reached"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
stackp	int
>	O
breakin_depth	int
)	O
{	O
SGFTRACE	O
(	O
PASS_MOVE	int
,	O
0	int
,	O
"connection depth limit reached"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
str	int
=	O
find_origin	function
(	O
str	int
)	O
;	O
if	O
(	O
stackp	int
<=	O
depth	int
&&	O
!	O
has_passed	int
&&	O
tt_get	function
(	O
&	O
ttable	struct
,	O
BREAK_IN	int
,	O
str	int
,	O
NO_MOVE	O
,	O
depth	int
-	O
stackp	int
,	O
goal_hash	pointer
,	O
&	O
retval	int
,	O
NULL	O
,	O
&	O
xpos	int
)	O
==	O
2	int
)	O
{	O
TRACE_CACHED_RESULT	O
(	O
retval	int
,	O
xpos	int
)	O
;	O
SGFTRACE	O
(	O
xpos	int
,	O
retval	int
,	O
"cached"	pointer
)	O
;	O
if	O
(	O
move	pointer
)	O
*	O
move	pointer
=	O
xpos	int
;	O
return	O
retval	int
;	O
}	O
num_moves	int
=	O
find_break_moves	function
(	O
str	int
,	O
goal	pointer
,	O
color	int
,	O
moves	array
,	O
&	O
distance	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_moves	int
;	O
k	int
++	O
)	O
{	O
int	O
ko_move	int
;	O
xpos	int
=	O
moves	array
[	O
k	int
]	O
;	O
if	O
(	O
komaster_trymove	function
(	O
xpos	int
,	O
color	int
,	O
"recursive_break"	pointer
,	O
str	int
,	O
&	O
ko_move	int
,	O
stackp	int
<=	O
ko_depth	int
&&	O
savecode	int
==	O
0	int
)	O
)	O
{	O
tried_moves	int
++	O
;	O
if	O
(	O
!	O
ko_move	int
)	O
{	O
int	O
acode	int
=	O
recursive_block	function
(	O
str	int
,	O
goal	pointer
,	O
NULL	O
,	O
has_passed	int
,	O
goal_hash	pointer
)	O
;	O
popgo	function
(	O
)	O
;	O
if	O
(	O
acode	int
==	O
0	int
)	O
{	O
SGFTRACE	O
(	O
xpos	int
,	O
WIN	int
,	O
"break effective"	pointer
)	O
;	O
READ_RETURN_HASH	O
(	O
BREAK_IN	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
goal_hash	pointer
,	O
move	pointer
,	O
xpos	int
,	O
WIN	int
)	O
;	O
}	O
UPDATE_SAVED_KO_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
acode	int
,	O
xpos	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
recursive_block	function
(	O
str	int
,	O
goal	pointer
,	O
NULL	O
,	O
has_passed	int
,	O
goal_hash	pointer
)	O
!=	O
WIN	int
)	O
{	O
savemove	int
=	O
xpos	int
;	O
savecode	int
=	O
KO_B	int
;	O
}	O
popgo	function
(	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
tried_moves	int
==	O
0	int
&&	O
distance	int
<	O
FP	O
(	O
0.89	int
)	O
)	O
{	O
SGFTRACE	O
(	O
NO_MOVE	O
,	O
WIN	int
,	O
"no move, probably connected"	pointer
)	O
;	O
READ_RETURN_HASH	O
(	O
BREAK_IN	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
goal_hash	pointer
,	O
move	pointer
,	O
NO_MOVE	O
,	O
WIN	int
)	O
;	O
}	O
if	O
(	O
savecode	int
!=	O
0	int
)	O
{	O
SGFTRACE	O
(	O
savemove	int
,	O
savecode	int
,	O
"saved move"	pointer
)	O
;	O
READ_RETURN_HASH	O
(	O
BREAK_IN	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
goal_hash	pointer
,	O
move	pointer
,	O
savemove	int
,	O
savecode	int
)	O
;	O
}	O
SGFTRACE	O
(	O
0	int
,	O
0	int
,	O
NULL	O
)	O
;	O
READ_RETURN_HASH	O
(	O
BREAK_IN	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
goal_hash	pointer
,	O
move	pointer
,	O
NO_MOVE	O
,	O
0	int
)	O
;	O
}	O
static	O
int	O
recursive_block	function
(	O
int	O
str	int
,	O
const	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
,	O
int	O
*	O
move	pointer
,	O
int	O
has_passed	int
,	O
Hash_data	struct
*	O
goal_hash	pointer
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
moves	array
[	O
MAX_MOVES	int
]	O
;	O
int	O
num_moves	int
;	O
int	O
distance	int
=	O
FP	O
(	O
0.0	int
)	O
;	O
int	O
k	int
;	O
int	O
xpos	int
;	O
int	O
savemove	int
=	O
NO_MOVE	O
;	O
int	O
savecode	int
=	O
0	int
;	O
int	O
tried_moves	int
=	O
0	int
;	O
int	O
retval	int
;	O
SETUP_TRACE_INFO	O
(	O
"recursive_block"	pointer
,	O
str	int
)	O
;	O
nodes_connect	int
++	O
;	O
global_connection_node_counter	int
++	O
;	O
if	O
(	O
move	pointer
)	O
*	O
move	pointer
=	O
NO_MOVE	O
;	O
if	O
(	O
board	pointer
[	O
str	int
]	O
==	O
EMPTY	int
)	O
{	O
SGFTRACE	O
(	O
PASS_MOVE	int
,	O
WIN	int
,	O
"string already captured"	pointer
)	O
;	O
return	O
WIN	int
;	O
}	O
if	O
(	O
nodes_connect	int
>	O
breakin_node_limit	int
)	O
{	O
SGFTRACE	O
(	O
PASS_MOVE	int
,	O
WIN	int
,	O
"connection node limit reached"	pointer
)	O
;	O
return	O
WIN	int
;	O
}	O
if	O
(	O
stackp	int
>	O
breakin_depth	int
)	O
{	O
SGFTRACE	O
(	O
PASS_MOVE	int
,	O
WIN	int
,	O
"connection depth limit reached"	pointer
)	O
;	O
return	O
WIN	int
;	O
}	O
str	int
=	O
find_origin	function
(	O
str	int
)	O
;	O
if	O
(	O
stackp	int
<=	O
depth	int
&&	O
tt_get	function
(	O
&	O
ttable	struct
,	O
BLOCK_OFF	int
,	O
str	int
,	O
NO_MOVE	O
,	O
depth	int
-	O
stackp	int
,	O
goal_hash	pointer
,	O
&	O
retval	int
,	O
NULL	O
,	O
&	O
xpos	int
)	O
==	O
2	int
)	O
{	O
TRACE_CACHED_RESULT	O
(	O
retval	int
,	O
xpos	int
)	O
;	O
SGFTRACE	O
(	O
xpos	int
,	O
retval	int
,	O
"cached"	pointer
)	O
;	O
if	O
(	O
move	pointer
)	O
*	O
move	pointer
=	O
xpos	int
;	O
return	O
retval	int
;	O
}	O
if	O
(	O
ladder_capture	function
(	O
str	int
,	O
&	O
xpos	int
)	O
==	O
WIN	int
)	O
{	O
SGFTRACE	O
(	O
xpos	int
,	O
WIN	int
,	O
"string capturable"	pointer
)	O
;	O
READ_RETURN_HASH	O
(	O
BLOCK_OFF	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
goal_hash	pointer
,	O
move	pointer
,	O
xpos	int
,	O
WIN	int
)	O
;	O
}	O
num_moves	int
=	O
find_break_moves	function
(	O
str	int
,	O
goal	pointer
,	O
other	int
,	O
moves	array
,	O
&	O
distance	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_moves	int
;	O
k	int
++	O
)	O
{	O
int	O
ko_move	int
;	O
xpos	int
=	O
moves	array
[	O
k	int
]	O
;	O
if	O
(	O
komaster_trymove	function
(	O
xpos	int
,	O
other	int
,	O
"recursive_block"	pointer
,	O
str	int
,	O
&	O
ko_move	int
,	O
stackp	int
<=	O
ko_depth	int
&&	O
savecode	int
==	O
0	int
)	O
)	O
{	O
tried_moves	int
++	O
;	O
if	O
(	O
!	O
ko_move	int
)	O
{	O
int	O
dcode	int
=	O
recursive_break	function
(	O
str	int
,	O
goal	pointer
,	O
NULL	O
,	O
has_passed	int
,	O
goal_hash	pointer
)	O
;	O
popgo	function
(	O
)	O
;	O
if	O
(	O
dcode	int
==	O
0	int
)	O
{	O
SGFTRACE	O
(	O
xpos	int
,	O
WIN	int
,	O
"block effective"	pointer
)	O
;	O
READ_RETURN_HASH	O
(	O
BLOCK_OFF	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
goal_hash	pointer
,	O
move	pointer
,	O
xpos	int
,	O
WIN	int
)	O
;	O
}	O
UPDATE_SAVED_KO_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
dcode	int
,	O
xpos	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
recursive_break	function
(	O
str	int
,	O
goal	pointer
,	O
NULL	O
,	O
has_passed	int
,	O
goal_hash	pointer
)	O
!=	O
WIN	int
)	O
{	O
savemove	int
=	O
xpos	int
;	O
savecode	int
=	O
KO_B	int
;	O
}	O
popgo	function
(	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
tried_moves	int
==	O
0	int
&&	O
distance	int
>=	O
FP	O
(	O
1.0	int
)	O
&&	O
(	O
has_passed	int
||	O
!	O
recursive_break	function
(	O
str	int
,	O
goal	pointer
,	O
NULL	O
,	O
1	int
,	O
goal_hash	pointer
)	O
)	O
)	O
{	O
SGFTRACE	O
(	O
NO_MOVE	O
,	O
WIN	int
,	O
"no move, probably disconnected"	pointer
)	O
;	O
READ_RETURN_HASH	O
(	O
BLOCK_OFF	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
goal_hash	pointer
,	O
move	pointer
,	O
NO_MOVE	O
,	O
WIN	int
)	O
;	O
}	O
if	O
(	O
savecode	int
!=	O
0	int
)	O
{	O
SGFTRACE	O
(	O
savemove	int
,	O
savecode	int
,	O
"saved move"	pointer
)	O
;	O
READ_RETURN_HASH	O
(	O
BLOCK_OFF	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
goal_hash	pointer
,	O
move	pointer
,	O
savemove	int
,	O
savecode	int
)	O
;	O
}	O
SGFTRACE	O
(	O
0	int
,	O
0	int
,	O
NULL	O
)	O
;	O
READ_RETURN_HASH	O
(	O
BLOCK_OFF	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
goal_hash	pointer
,	O
move	pointer
,	O
NO_MOVE	O
,	O
0	int
)	O
;	O
}	O
int	O
break_in	function
(	O
int	O
str	int
,	O
const	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
,	O
int	O
*	O
move	pointer
)	O
{	O
int	O
dummy_move	int
;	O
int	O
save_verbose	int
;	O
int	O
result	int
;	O
int	O
reading_nodes_when_called	int
=	O
get_reading_node_counter	function
(	O
)	O
;	O
double	O
start	double
=	O
0	int
;	O
int	O
tactical_nodes	int
;	O
Hash_data	struct
goal_hash	pointer
=	O
goal_to_hashvalue	function
(	O
goal	pointer
)	O
;	O
if	O
(	O
move	pointer
==	O
NULL	O
)	O
move	pointer
=	O
&	O
dummy_move	int
;	O
nodes_connect	int
=	O
0	int
;	O
*	O
move	pointer
=	O
PASS_MOVE	int
;	O
if	O
(	O
board	pointer
[	O
str	int
]	O
==	O
EMPTY	int
)	O
return	O
0	int
;	O
str	int
=	O
find_origin	function
(	O
str	int
)	O
;	O
if	O
(	O
search_persistent_breakin_cache	function
(	O
BREAK_IN	int
,	O
str	int
,	O
&	O
goal_hash	pointer
,	O
breakin_node_limit	int
,	O
&	O
result	int
,	O
move	pointer
)	O
)	O
{	O
if	O
(	O
debug	int
&	O
DEBUG_BREAKIN	int
)	O
{	O
gprintf	function
(	O
"Break-in from %1m to:\n"	pointer
,	O
str	int
)	O
;	O
goaldump	function
(	O
goal	pointer
)	O
;	O
gprintf	function
(	O
"Result cached: %s %1m\n"	pointer
,	O
result_to_string	function
(	O
result	int
)	O
,	O
*	O
move	pointer
)	O
;	O
}	O
return	O
result	int
;	O
}	O
save_verbose	int
=	O
verbose	int
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
verbose	int
--	O
;	O
start	double
=	O
gg_cputime	function
(	O
)	O
;	O
memcpy	function
(	O
breakin_shadow	array
,	O
goal	pointer
,	O
sizeof	O
(	O
breakin_shadow	array
)	O
)	O
;	O
result	int
=	O
recursive_break	function
(	O
str	int
,	O
goal	pointer
,	O
move	pointer
,	O
0	int
,	O
&	O
goal_hash	pointer
)	O
;	O
verbose	int
=	O
save_verbose	int
;	O
tactical_nodes	int
=	O
get_reading_node_counter	function
(	O
)	O
-	O
reading_nodes_when_called	int
;	O
if	O
(	O
debug	int
&	O
DEBUG_BREAKIN	int
)	O
{	O
gprintf	function
(	O
"%obreak_in    %1M, result %s %1M (%d, %d nodes, %f seconds)\n"	pointer
,	O
str	int
,	O
result_to_string	function
(	O
result	int
)	O
,	O
*	O
move	pointer
,	O
nodes_connect	int
,	O
tactical_nodes	int
,	O
gg_cputime	function
(	O
)	O
-	O
start	double
)	O
;	O
goaldump	function
(	O
goal	pointer
)	O
;	O
dump_stack	function
(	O
)	O
;	O
}	O
if	O
(	O
0	int
)	O
{	O
gprintf	function
(	O
"%obreak_in %1m %d %1m "	pointer
,	O
str	int
,	O
result	int
,	O
*	O
move	pointer
)	O
;	O
dump_stack	function
(	O
)	O
;	O
goaldump	function
(	O
goal	pointer
)	O
;	O
}	O
store_persistent_breakin_cache	function
(	O
BREAK_IN	int
,	O
str	int
,	O
&	O
goal_hash	pointer
,	O
result	int
,	O
*	O
move	pointer
,	O
tactical_nodes	int
,	O
breakin_node_limit	int
,	O
breakin_shadow	array
)	O
;	O
return	O
result	int
;	O
}	O
int	O
block_off	function
(	O
int	O
str	int
,	O
const	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
,	O
int	O
*	O
move	pointer
)	O
{	O
int	O
dummy_move	int
;	O
int	O
result	int
;	O
int	O
save_verbose	int
;	O
int	O
reading_nodes_when_called	int
=	O
get_reading_node_counter	function
(	O
)	O
;	O
double	O
start	double
=	O
0	int
;	O
int	O
tactical_nodes	int
;	O
Hash_data	struct
goal_hash	pointer
=	O
goal_to_hashvalue	function
(	O
goal	pointer
)	O
;	O
if	O
(	O
move	pointer
==	O
NULL	O
)	O
move	pointer
=	O
&	O
dummy_move	int
;	O
nodes_connect	int
=	O
0	int
;	O
*	O
move	pointer
=	O
PASS_MOVE	int
;	O
str	int
=	O
find_origin	function
(	O
str	int
)	O
;	O
if	O
(	O
search_persistent_breakin_cache	function
(	O
BLOCK_OFF	int
,	O
str	int
,	O
&	O
goal_hash	pointer
,	O
breakin_node_limit	int
,	O
&	O
result	int
,	O
move	pointer
)	O
)	O
{	O
if	O
(	O
debug	int
&	O
DEBUG_BREAKIN	int
)	O
{	O
gprintf	function
(	O
"Blocking off %1m from:\n"	pointer
,	O
str	int
)	O
;	O
goaldump	function
(	O
goal	pointer
)	O
;	O
gprintf	function
(	O
"Result cached: %s %1m\n"	pointer
,	O
result_to_string	function
(	O
result	int
)	O
,	O
*	O
move	pointer
)	O
;	O
}	O
return	O
result	int
;	O
}	O
save_verbose	int
=	O
verbose	int
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
verbose	int
--	O
;	O
start	double
=	O
gg_cputime	function
(	O
)	O
;	O
memcpy	function
(	O
breakin_shadow	array
,	O
goal	pointer
,	O
sizeof	O
(	O
breakin_shadow	array
)	O
)	O
;	O
result	int
=	O
recursive_block	function
(	O
str	int
,	O
goal	pointer
,	O
move	pointer
,	O
0	int
,	O
&	O
goal_hash	pointer
)	O
;	O
verbose	int
=	O
save_verbose	int
;	O
tactical_nodes	int
=	O
get_reading_node_counter	function
(	O
)	O
-	O
reading_nodes_when_called	int
;	O
if	O
(	O
debug	int
&	O
DEBUG_BREAKIN	int
)	O
{	O
gprintf	function
(	O
"%oblock_off %1m, result %s %1m (%d, %d nodes, %f seconds)\n"	pointer
,	O
str	int
,	O
result_to_string	function
(	O
result	int
)	O
,	O
*	O
move	pointer
,	O
nodes_connect	int
,	O
tactical_nodes	int
,	O
gg_cputime	function
(	O
)	O
-	O
start	double
)	O
;	O
goaldump	function
(	O
goal	pointer
)	O
;	O
dump_stack	function
(	O
)	O
;	O
}	O
if	O
(	O
0	int
)	O
{	O
gprintf	function
(	O
"%oblock_off %1m %d %1m "	pointer
,	O
str	int
,	O
result	int
,	O
*	O
move	pointer
)	O
;	O
goaldump	function
(	O
goal	pointer
)	O
;	O
dump_stack	function
(	O
)	O
;	O
}	O
store_persistent_breakin_cache	function
(	O
BLOCK_OFF	int
,	O
str	int
,	O
&	O
goal_hash	pointer
,	O
result	int
,	O
*	O
move	pointer
,	O
tactical_nodes	int
,	O
breakin_node_limit	int
,	O
breakin_shadow	array
)	O
;	O
return	O
result	int
;	O
}	O
static	O
void	O
push_connection_heap_entry	function
(	O
struct	O
connection_data	struct
*	O
conn	pointer
,	O
int	O
distance	int
,	O
int	O
coming_from	int
,	O
int	O
target	int
,	O
connection_helper_fn_ptr	pointer
helper	pointer
)	O
{	O
int	O
k	int
;	O
int	O
parent	pointer
;	O
struct	O
heap_entry	struct
*	O
new_entry	pointer
=	O
&	O
conn	pointer
->	O
heap_data	array
[	O
conn	pointer
->	O
heap_data_size	int
]	O
;	O
gg_assert	O
(	O
conn	pointer
->	O
heap_data_size	int
<	O
4	int
*	O
BOARDMAX	O
)	O
;	O
gg_assert	O
(	O
conn	pointer
->	O
heap_size	int
<	O
BOARDMAX	O
)	O
;	O
new_entry	pointer
->	O
distance	int
=	O
distance	int
;	O
new_entry	pointer
->	O
coming_from	int
=	O
coming_from	int
;	O
new_entry	pointer
->	O
target	int
=	O
target	int
;	O
new_entry	pointer
->	O
helper	pointer
=	O
helper	pointer
;	O
conn	pointer
->	O
heap_data_size	int
++	O
;	O
for	O
(	O
k	int
=	O
conn	pointer
->	O
heap_size	int
++	O
;	O
k	int
>	O
0	int
;	O
k	int
=	O
parent	pointer
)	O
{	O
parent	pointer
=	O
(	O
k	int
-	O
1	int
)	O
/	O
2	int
;	O
if	O
(	O
conn	pointer
->	O
heap	array
[	O
parent	pointer
]	O
->	O
distance	int
<=	O
distance	int
)	O
break	O
;	O
conn	pointer
->	O
heap	array
[	O
k	int
]	O
=	O
conn	pointer
->	O
heap	array
[	O
parent	pointer
]	O
;	O
}	O
conn	pointer
->	O
heap	array
[	O
k	int
]	O
=	O
new_entry	pointer
;	O
}	O
static	O
void	O
pop_connection_heap_entry	function
(	O
struct	O
connection_data	struct
*	O
conn	pointer
)	O
{	O
int	O
k	int
;	O
int	O
child	pointer
;	O
conn	pointer
->	O
heap_size	int
--	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
2	int
*	O
k	int
+	O
1	int
<	O
conn	pointer
->	O
heap_size	int
;	O
k	int
=	O
child	pointer
)	O
{	O
child	pointer
=	O
2	int
*	O
k	int
+	O
1	int
;	O
if	O
(	O
conn	pointer
->	O
heap	array
[	O
child	pointer
]	O
->	O
distance	int
>	O
conn	pointer
->	O
heap	array
[	O
child	pointer
+	O
1	int
]	O
->	O
distance	int
)	O
child	pointer
++	O
;	O
if	O
(	O
conn	pointer
->	O
heap	array
[	O
child	pointer
]	O
->	O
distance	int
>=	O
conn	pointer
->	O
heap	array
[	O
conn	pointer
->	O
heap_size	int
]	O
->	O
distance	int
)	O
break	O
;	O
conn	pointer
->	O
heap	array
[	O
k	int
]	O
=	O
conn	pointer
->	O
heap	array
[	O
child	pointer
]	O
;	O
}	O
conn	pointer
->	O
heap	array
[	O
k	int
]	O
=	O
conn	pointer
->	O
heap	array
[	O
conn	pointer
->	O
heap_size	int
]	O
;	O
}	O
static	O
void	O
case_6_7_helper	function
(	O
struct	O
connection_data	struct
*	O
conn	pointer
,	O
int	O
color	int
)	O
{	O
struct	O
heap_entry	struct
*	O
data	pointer
=	O
conn	pointer
->	O
heap	array
[	O
0	int
]	O
;	O
int	O
pos	int
=	O
data	pointer
->	O
coming_from	int
;	O
int	O
apos	int
=	O
data	pointer
->	O
target	int
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
if	O
(	O
ladder_capturable	function
(	O
apos	int
,	O
other	int
)	O
)	O
ENQUEUE	O
(	O
conn	pointer
,	O
pos	int
,	O
apos	int
,	O
data	pointer
->	O
distance	int
,	O
FP	O
(	O
0.6	int
)	O
,	O
apos	int
,	O
NO_MOVE	O
)	O
;	O
else	O
{	O
int	O
this_delta	int
=	O
FP	O
(	O
0.85	int
)	O
+	O
FP	O
(	O
0.05	int
)	O
*	O
gg_min	O
(	O
approxlib	function
(	O
apos	int
,	O
other	int
,	O
5	int
,	O
NULL	O
)	O
,	O
5	int
)	O
;	O
ENQUEUE	O
(	O
conn	pointer
,	O
pos	int
,	O
apos	int
,	O
data	pointer
->	O
distance	int
+	O
this_delta	int
-	O
FP	O
(	O
0.6	int
)	O
,	O
this_delta	int
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
}	O
}	O
static	O
void	O
case_9_10_helper	function
(	O
struct	O
connection_data	struct
*	O
conn	pointer
,	O
int	O
color	int
)	O
{	O
struct	O
heap_entry	struct
*	O
data	pointer
=	O
conn	pointer
->	O
heap	array
[	O
0	int
]	O
;	O
int	O
pos	int
=	O
data	pointer
->	O
coming_from	int
;	O
int	O
apos	int
=	O
data	pointer
->	O
target	int
;	O
UNUSED	O
(	O
color	int
)	O
;	O
if	O
(	O
no_escape_from_ladder	function
(	O
apos	int
)	O
)	O
ENQUEUE_STONE	O
(	O
conn	pointer
,	O
pos	int
,	O
apos	int
,	O
data	pointer
->	O
distance	int
,	O
FP	O
(	O
0.3	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
else	O
{	O
if	O
(	O
conn	pointer
->	O
speculative	int
)	O
{	O
ENQUEUE_STONE	O
(	O
conn	pointer
,	O
pos	int
,	O
apos	int
,	O
data	pointer
->	O
distance	int
+	O
FP	O
(	O
0.7	int
)	O
,	O
FP	O
(	O
1.0	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
}	O
else	O
{	O
ENQUEUE_STONE	O
(	O
conn	pointer
,	O
pos	int
,	O
apos	int
,	O
data	pointer
->	O
distance	int
+	O
FP	O
(	O
0.8	int
)	O
,	O
FP	O
(	O
1.1	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
}	O
}	O
}	O
static	O
void	O
case_16_17_18_helper	function
(	O
struct	O
connection_data	struct
*	O
conn	pointer
,	O
int	O
color	int
)	O
{	O
struct	O
heap_entry	struct
*	O
data	pointer
=	O
conn	pointer
->	O
heap	array
[	O
0	int
]	O
;	O
int	O
pos	int
=	O
data	pointer
->	O
coming_from	int
;	O
int	O
bpos	int
=	O
data	pointer
->	O
target	int
;	O
int	O
apos	int
=	O
SOUTH	O
(	O
gg_min	O
(	O
pos	int
,	O
bpos	int
)	O
)	O
;	O
int	O
gpos	int
=	O
NORTH	O
(	O
gg_max	O
(	O
pos	int
,	O
bpos	int
)	O
)	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
if	O
(	O
board	pointer
[	O
apos	int
]	O
==	O
EMPTY	int
&&	O
does_secure_through_ladder	function
(	O
color	int
,	O
bpos	int
,	O
apos	int
)	O
)	O
ENQUEUE	O
(	O
conn	pointer
,	O
pos	int
,	O
bpos	int
,	O
data	pointer
->	O
distance	int
,	O
FP	O
(	O
1.0	int
)	O
,	O
apos	int
,	O
NO_MOVE	O
)	O
;	O
else	O
if	O
(	O
board	pointer
[	O
gpos	int
]	O
==	O
EMPTY	int
&&	O
does_secure_through_ladder	function
(	O
color	int
,	O
bpos	int
,	O
gpos	int
)	O
)	O
ENQUEUE	O
(	O
conn	pointer
,	O
pos	int
,	O
bpos	int
,	O
data	pointer
->	O
distance	int
,	O
FP	O
(	O
1.0	int
)	O
,	O
gpos	int
,	O
NO_MOVE	O
)	O
;	O
else	O
if	O
(	O
conn	pointer
->	O
distances	array
[	O
bpos	int
]	O
>	O
data	pointer
->	O
distance	int
+	O
FP	O
(	O
0.3	int
)	O
)	O
{	O
if	O
(	O
board	pointer
[	O
apos	int
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
gpos	int
]	O
==	O
other	int
&&	O
countlib	function
(	O
gpos	int
)	O
<=	O
3	int
)	O
ENQUEUE	O
(	O
conn	pointer
,	O
pos	int
,	O
bpos	int
,	O
data	pointer
->	O
distance	int
+	O
FP	O
(	O
0.3	int
)	O
,	O
FP	O
(	O
1.0	int
)	O
,	O
apos	int
,	O
NO_MOVE	O
)	O
;	O
else	O
if	O
(	O
board	pointer
[	O
gpos	int
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
apos	int
]	O
==	O
other	int
&&	O
countlib	function
(	O
apos	int
)	O
<=	O
3	int
)	O
ENQUEUE	O
(	O
conn	pointer
,	O
pos	int
,	O
bpos	int
,	O
data	pointer
->	O
distance	int
+	O
FP	O
(	O
0.3	int
)	O
,	O
FP	O
(	O
1.0	int
)	O
,	O
gpos	int
,	O
NO_MOVE	O
)	O
;	O
else	O
ENQUEUE	O
(	O
conn	pointer
,	O
pos	int
,	O
bpos	int
,	O
data	pointer
->	O
distance	int
+	O
FP	O
(	O
0.6	int
)	O
,	O
FP	O
(	O
0.9	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
}	O
}	O
void	O
spread_connection_distances	function
(	O
int	O
color	int
,	O
struct	O
connection_data	struct
*	O
conn	pointer
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
stones	pointer
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
num_stones	int
=	O
0	int
;	O
int	O
stone	int
=	O
0	int
;	O
while	O
(	O
conn	pointer
->	O
queue_start	int
<	O
conn	pointer
->	O
queue_end	int
||	O
conn	pointer
->	O
heap_size	int
>	O
0	int
)	O
{	O
int	O
k	int
;	O
int	O
pos	int
;	O
int	O
distance	int
;	O
while	O
(	O
conn	pointer
->	O
heap_size	int
>	O
0	int
&&	O
conn	pointer
->	O
heap	array
[	O
0	int
]	O
->	O
distance	int
>=	O
conn	pointer
->	O
distances	array
[	O
conn	pointer
->	O
heap	array
[	O
0	int
]	O
->	O
target	int
]	O
)	O
pop_connection_heap_entry	function
(	O
conn	pointer
)	O
;	O
if	O
(	O
stone	int
==	O
num_stones	int
)	O
{	O
int	O
best_index	int
=	O
-	O
1	int
;	O
int	O
smallest_dist	int
=	O
HUGE_CONNECTION_DISTANCE	O
;	O
if	O
(	O
conn	pointer
->	O
queue_start	int
==	O
conn	pointer
->	O
queue_end	int
)	O
{	O
if	O
(	O
conn	pointer
->	O
heap_size	int
>	O
0	int
)	O
{	O
conn	pointer
->	O
heap	array
[	O
0	int
]	O
->	O
helper	pointer
(	O
conn	pointer
,	O
color	int
)	O
;	O
pop_connection_heap_entry	function
(	O
conn	pointer
)	O
;	O
}	O
continue	O
;	O
}	O
gg_assert	O
(	O
conn	pointer
->	O
queue_end	int
<=	O
MAX_BOARD	int
*	O
MAX_BOARD	int
)	O
;	O
for	O
(	O
k	int
=	O
conn	pointer
->	O
queue_start	int
;	O
k	int
<	O
conn	pointer
->	O
queue_end	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
conn	pointer
->	O
distances	array
[	O
conn	pointer
->	O
queue	array
[	O
k	int
]	O
]	O
<	O
smallest_dist	int
)	O
{	O
smallest_dist	int
=	O
conn	pointer
->	O
distances	array
[	O
conn	pointer
->	O
queue	array
[	O
k	int
]	O
]	O
;	O
best_index	int
=	O
k	int
;	O
}	O
}	O
if	O
(	O
best_index	int
!=	O
conn	pointer
->	O
queue_start	int
)	O
{	O
int	O
temp	int
=	O
conn	pointer
->	O
queue	array
[	O
conn	pointer
->	O
queue_start	int
]	O
;	O
conn	pointer
->	O
queue	array
[	O
conn	pointer
->	O
queue_start	int
]	O
=	O
conn	pointer
->	O
queue	array
[	O
best_index	int
]	O
;	O
conn	pointer
->	O
queue	array
[	O
best_index	int
]	O
=	O
temp	int
;	O
}	O
if	O
(	O
conn	pointer
->	O
heap_size	int
>	O
0	int
&&	O
conn	pointer
->	O
heap	array
[	O
0	int
]	O
->	O
distance	int
<	O
smallest_dist	int
)	O
{	O
conn	pointer
->	O
heap	array
[	O
0	int
]	O
->	O
helper	pointer
(	O
conn	pointer
,	O
color	int
)	O
;	O
pop_connection_heap_entry	function
(	O
conn	pointer
)	O
;	O
continue	O
;	O
}	O
pos	int
=	O
conn	pointer
->	O
queue	array
[	O
conn	pointer
->	O
queue_start	int
++	O
]	O
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
!=	O
EMPTY	int
)	O
{	O
num_stones	int
=	O
findstones	function
(	O
pos	int
,	O
MAX_BOARD	int
*	O
MAX_BOARD	int
,	O
stones	pointer
)	O
;	O
pos	int
=	O
stones	pointer
[	O
0	int
]	O
;	O
stone	int
=	O
1	int
;	O
}	O
}	O
else	O
{	O
pos	int
=	O
stones	pointer
[	O
stone	int
++	O
]	O
;	O
conn	pointer
->	O
distances	array
[	O
pos	int
]	O
=	O
conn	pointer
->	O
distances	array
[	O
stones	pointer
[	O
0	int
]	O
]	O
;	O
conn	pointer
->	O
deltas	array
[	O
pos	int
]	O
=	O
conn	pointer
->	O
deltas	array
[	O
stones	pointer
[	O
0	int
]	O
]	O
;	O
conn	pointer
->	O
coming_from	int
[	O
pos	int
]	O
=	O
conn	pointer
->	O
coming_from	int
[	O
stones	pointer
[	O
0	int
]	O
]	O
;	O
conn	pointer
->	O
vulnerable1	array
[	O
pos	int
]	O
=	O
conn	pointer
->	O
vulnerable1	array
[	O
stones	pointer
[	O
0	int
]	O
]	O
;	O
conn	pointer
->	O
vulnerable2	array
[	O
pos	int
]	O
=	O
conn	pointer
->	O
vulnerable2	array
[	O
stones	pointer
[	O
0	int
]	O
]	O
;	O
}	O
distance	int
=	O
conn	pointer
->	O
distances	array
[	O
pos	int
]	O
;	O
if	O
(	O
distance	int
>	O
conn	pointer
->	O
cutoff_distance	int
)	O
break	O
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
color	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
right	int
=	O
delta	array
[	O
k	int
]	O
;	O
int	O
up	int
=	O
delta	array
[	O
(	O
k	int
+	O
1	int
)	O
%	O
4	int
]	O
;	O
int	O
apos	int
=	O
pos	int
+	O
right	int
;	O
int	O
bpos	int
=	O
pos	int
+	O
right	int
+	O
up	int
;	O
int	O
cpos	int
=	O
pos	int
+	O
2	int
*	O
right	int
;	O
int	O
epos	int
=	O
pos	int
+	O
2	int
*	O
up	int
;	O
int	O
fpos	int
=	O
pos	int
+	O
right	int
+	O
2	int
*	O
up	int
;	O
int	O
gpos	int
=	O
pos	int
+	O
up	int
;	O
int	O
hpos	int
=	O
pos	int
-	O
right	int
;	O
int	O
ipos	int
=	O
pos	int
-	O
right	int
+	O
up	int
;	O
int	O
jpos	int
=	O
pos	int
-	O
right	int
+	O
2	int
*	O
up	int
;	O
int	O
kpos	int
=	O
pos	int
-	O
2	int
*	O
right	int
;	O
if	O
(	O
board	pointer
[	O
apos	int
]	O
==	O
EMPTY	int
&&	O
is_suicide	function
(	O
apos	int
,	O
other	int
)	O
)	O
ENQUEUE	O
(	O
conn	pointer
,	O
pos	int
,	O
apos	int
,	O
distance	int
,	O
FP	O
(	O
0.0	int
)	O
,	O
apos	int
,	O
NO_MOVE	O
)	O
;	O
if	O
(	O
board	pointer
[	O
apos	int
]	O
==	O
EMPTY	int
&&	O
conn	pointer
->	O
distances	array
[	O
apos	int
]	O
>	O
distance	int
+	O
FP	O
(	O
0.1	int
)	O
&&	O
is_self_atari	function
(	O
apos	int
,	O
other	int
)	O
)	O
{	O
int	O
lib	int
;	O
int	O
vulnerable1	array
=	O
NO_MOVE	O
;	O
int	O
vulnerable2	array
=	O
NO_MOVE	O
;	O
if	O
(	O
approxlib	function
(	O
apos	int
,	O
other	int
,	O
1	int
,	O
&	O
lib	int
)	O
>=	O
1	int
)	O
{	O
if	O
(	O
approxlib	function
(	O
lib	int
,	O
other	int
,	O
2	int
,	O
NULL	O
)	O
>	O
2	int
)	O
vulnerable1	array
=	O
lib	int
;	O
if	O
(	O
countlib	function
(	O
pos	int
)	O
==	O
2	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
lib	int
+	O
delta	array
[	O
i	int
]	O
]	O
==	O
EMPTY	int
&&	O
lib	int
+	O
delta	array
[	O
i	int
]	O
!=	O
apos	int
&&	O
trymove	function
(	O
lib	int
+	O
delta	array
[	O
i	int
]	O
,	O
other	int
,	O
"compute_connection_distances"	pointer
,	O
pos	int
)	O
)	O
{	O
if	O
(	O
ladder_capture	function
(	O
pos	int
,	O
NULL	O
)	O
)	O
{	O
vulnerable2	array
=	O
lib	int
+	O
delta	array
[	O
i	int
]	O
;	O
popgo	function
(	O
)	O
;	O
break	O
;	O
}	O
popgo	function
(	O
)	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
!	O
common_vulnerabilities	function
(	O
conn	pointer
->	O
vulnerable1	array
[	O
pos	int
]	O
,	O
conn	pointer
->	O
vulnerable2	array
[	O
pos	int
]	O
,	O
vulnerable1	array
,	O
vulnerable2	array
,	O
color	int
)	O
)	O
{	O
ENQUEUE	O
(	O
conn	pointer
,	O
pos	int
,	O
apos	int
,	O
distance	int
+	O
FP	O
(	O
0.1	int
)	O
,	O
FP	O
(	O
0.1	int
)	O
,	O
vulnerable1	array
,	O
vulnerable2	array
)	O
;	O
}	O
}	O
if	O
(	O
board	pointer
[	O
apos	int
]	O
==	O
color	int
&&	O
board	pointer
[	O
bpos	int
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
fpos	int
]	O
==	O
color	int
&&	O
board	pointer
[	O
epos	int
]	O
==	O
color	int
&&	O
board	pointer
[	O
gpos	int
]	O
==	O
EMPTY	int
)	O
{	O
ENQUEUE	O
(	O
conn	pointer
,	O
pos	int
,	O
bpos	int
,	O
distance	int
+	O
FP	O
(	O
0.1	int
)	O
,	O
FP	O
(	O
0.1	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
ENQUEUE	O
(	O
conn	pointer
,	O
pos	int
,	O
gpos	int
,	O
distance	int
+	O
FP	O
(	O
0.1	int
)	O
,	O
FP	O
(	O
0.1	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
}	O
if	O
(	O
board	pointer
[	O
bpos	int
]	O
==	O
color	int
&&	O
board	pointer
[	O
apos	int
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
gpos	int
]	O
==	O
EMPTY	int
&&	O
!	O
common_vulnerabilities	function
(	O
conn	pointer
->	O
vulnerable1	array
[	O
pos	int
]	O
,	O
conn	pointer
->	O
vulnerable2	array
[	O
pos	int
]	O
,	O
apos	int
,	O
gpos	int
,	O
color	int
)	O
&&	O
conn	pointer
->	O
distances	array
[	O
bpos	int
]	O
>	O
distance	int
+	O
FP	O
(	O
0.1	int
)	O
)	O
{	O
ENQUEUE_STONE	O
(	O
conn	pointer
,	O
pos	int
,	O
bpos	int
,	O
distance	int
+	O
FP	O
(	O
0.1	int
)	O
,	O
FP	O
(	O
0.1	int
)	O
,	O
apos	int
,	O
gpos	int
)	O
;	O
}	O
if	O
(	O
board	pointer
[	O
gpos	int
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
epos	int
]	O
==	O
color	int
&&	O
conn	pointer
->	O
distances	array
[	O
epos	int
]	O
>	O
distance	int
+	O
FP	O
(	O
0.2	int
)	O
&&	O
approxlib	function
(	O
gpos	int
,	O
other	int
,	O
3	int
,	O
NULL	O
)	O
<=	O
2	int
)	O
{	O
if	O
(	O
board	pointer
[	O
bpos	int
]	O
==	O
EMPTY	int
&&	O
approxlib	function
(	O
bpos	int
,	O
color	int
,	O
3	int
,	O
NULL	O
)	O
>=	O
3	int
&&	O
(	O
board	pointer
[	O
apos	int
]	O
==	O
color	int
||	O
(	O
board	pointer
[	O
apos	int
]	O
==	O
EMPTY	int
&&	O
countlib	function
(	O
pos	int
)	O
>	O
2	int
&&	O
!	O
common_vulnerabilities	function
(	O
conn	pointer
->	O
vulnerable1	array
[	O
pos	int
]	O
,	O
conn	pointer
->	O
vulnerable2	array
[	O
pos	int
]	O
,	O
apos	int
,	O
gpos	int
,	O
color	int
)	O
&&	O
approxlib	function
(	O
apos	int
,	O
other	int
,	O
3	int
,	O
NULL	O
)	O
<=	O
2	int
)	O
)	O
&&	O
(	O
board	pointer
[	O
fpos	int
]	O
==	O
color	int
||	O
(	O
board	pointer
[	O
fpos	int
]	O
==	O
EMPTY	int
&&	O
countlib	function
(	O
epos	int
)	O
>	O
2	int
&&	O
!	O
common_vulnerabilities	function
(	O
conn	pointer
->	O
vulnerable1	array
[	O
pos	int
]	O
,	O
conn	pointer
->	O
vulnerable2	array
[	O
pos	int
]	O
,	O
fpos	int
,	O
gpos	int
,	O
color	int
)	O
&&	O
approxlib	function
(	O
fpos	int
,	O
other	int
,	O
3	int
,	O
NULL	O
)	O
<=	O
2	int
)	O
)	O
)	O
{	O
if	O
(	O
board	pointer
[	O
apos	int
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
fpos	int
]	O
==	O
EMPTY	int
)	O
{	O
ENQUEUE_STONE	O
(	O
conn	pointer
,	O
pos	int
,	O
epos	int
,	O
distance	int
+	O
FP	O
(	O
0.2	int
)	O
,	O
FP	O
(	O
0.2	int
)	O
,	O
apos	int
,	O
fpos	int
)	O
;	O
}	O
else	O
if	O
(	O
board	pointer
[	O
apos	int
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
fpos	int
]	O
!=	O
EMPTY	int
)	O
{	O
ENQUEUE_STONE	O
(	O
conn	pointer
,	O
pos	int
,	O
epos	int
,	O
distance	int
+	O
FP	O
(	O
0.2	int
)	O
,	O
FP	O
(	O
0.2	int
)	O
,	O
apos	int
,	O
NO_MOVE	O
)	O
;	O
}	O
else	O
if	O
(	O
board	pointer
[	O
apos	int
]	O
!=	O
EMPTY	int
&&	O
board	pointer
[	O
fpos	int
]	O
==	O
EMPTY	int
)	O
{	O
ENQUEUE_STONE	O
(	O
conn	pointer
,	O
pos	int
,	O
epos	int
,	O
distance	int
+	O
FP	O
(	O
0.2	int
)	O
,	O
FP	O
(	O
0.2	int
)	O
,	O
fpos	int
,	O
NO_MOVE	O
)	O
;	O
}	O
else	O
if	O
(	O
board	pointer
[	O
apos	int
]	O
!=	O
EMPTY	int
&&	O
board	pointer
[	O
fpos	int
]	O
!=	O
EMPTY	int
)	O
{	O
ENQUEUE_STONE	O
(	O
conn	pointer
,	O
pos	int
,	O
epos	int
,	O
distance	int
+	O
FP	O
(	O
0.2	int
)	O
,	O
FP	O
(	O
0.2	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
}	O
}	O
if	O
(	O
board	pointer
[	O
ipos	int
]	O
==	O
EMPTY	int
&&	O
approxlib	function
(	O
ipos	int
,	O
color	int
,	O
3	int
,	O
NULL	O
)	O
>=	O
3	int
&&	O
(	O
board	pointer
[	O
hpos	int
]	O
==	O
color	int
||	O
(	O
board	pointer
[	O
hpos	int
]	O
==	O
EMPTY	int
&&	O
countlib	function
(	O
pos	int
)	O
>	O
2	int
&&	O
!	O
common_vulnerabilities	function
(	O
conn	pointer
->	O
vulnerable1	array
[	O
pos	int
]	O
,	O
conn	pointer
->	O
vulnerable2	array
[	O
pos	int
]	O
,	O
hpos	int
,	O
gpos	int
,	O
color	int
)	O
&&	O
approxlib	function
(	O
hpos	int
,	O
other	int
,	O
3	int
,	O
NULL	O
)	O
<=	O
2	int
)	O
)	O
&&	O
(	O
board	pointer
[	O
jpos	int
]	O
==	O
color	int
||	O
(	O
board	pointer
[	O
jpos	int
]	O
==	O
EMPTY	int
&&	O
countlib	function
(	O
epos	int
)	O
>	O
2	int
&&	O
!	O
common_vulnerabilities	function
(	O
conn	pointer
->	O
vulnerable1	array
[	O
pos	int
]	O
,	O
conn	pointer
->	O
vulnerable2	array
[	O
pos	int
]	O
,	O
jpos	int
,	O
gpos	int
,	O
color	int
)	O
&&	O
approxlib	function
(	O
jpos	int
,	O
other	int
,	O
3	int
,	O
NULL	O
)	O
<=	O
2	int
)	O
)	O
)	O
{	O
if	O
(	O
board	pointer
[	O
hpos	int
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
jpos	int
]	O
==	O
EMPTY	int
)	O
{	O
ENQUEUE_STONE	O
(	O
conn	pointer
,	O
pos	int
,	O
epos	int
,	O
distance	int
+	O
FP	O
(	O
0.2	int
)	O
,	O
FP	O
(	O
0.2	int
)	O
,	O
hpos	int
,	O
jpos	int
)	O
;	O
}	O
else	O
if	O
(	O
board	pointer
[	O
hpos	int
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
jpos	int
]	O
!=	O
EMPTY	int
)	O
{	O
ENQUEUE_STONE	O
(	O
conn	pointer
,	O
pos	int
,	O
epos	int
,	O
distance	int
+	O
FP	O
(	O
0.2	int
)	O
,	O
FP	O
(	O
0.2	int
)	O
,	O
hpos	int
,	O
NO_MOVE	O
)	O
;	O
}	O
else	O
if	O
(	O
board	pointer
[	O
hpos	int
]	O
!=	O
EMPTY	int
&&	O
board	pointer
[	O
jpos	int
]	O
==	O
EMPTY	int
)	O
{	O
ENQUEUE_STONE	O
(	O
conn	pointer
,	O
pos	int
,	O
epos	int
,	O
distance	int
+	O
FP	O
(	O
0.2	int
)	O
,	O
FP	O
(	O
0.2	int
)	O
,	O
jpos	int
,	O
NO_MOVE	O
)	O
;	O
}	O
else	O
if	O
(	O
board	pointer
[	O
hpos	int
]	O
!=	O
EMPTY	int
&&	O
board	pointer
[	O
jpos	int
]	O
!=	O
EMPTY	int
)	O
{	O
ENQUEUE_STONE	O
(	O
conn	pointer
,	O
pos	int
,	O
epos	int
,	O
distance	int
+	O
FP	O
(	O
0.2	int
)	O
,	O
FP	O
(	O
0.2	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
board	pointer
[	O
apos	int
]	O
==	O
EMPTY	int
&&	O
conn	pointer
->	O
distances	array
[	O
apos	int
]	O
>	O
distance	int
+	O
FP	O
(	O
0.6	int
)	O
)	O
{	O
push_connection_heap_entry	function
(	O
conn	pointer
,	O
distance	int
+	O
FP	O
(	O
0.6	int
)	O
,	O
pos	int
,	O
apos	int
,	O
case_6_7_helper	function
)	O
;	O
}	O
if	O
(	O
board	pointer
[	O
apos	int
]	O
==	O
other	int
&&	O
conn	pointer
->	O
distances	array
[	O
apos	int
]	O
>	O
distance	int
+	O
FP	O
(	O
0.1	int
)	O
&&	O
no_escape_from_atari	function
(	O
apos	int
)	O
)	O
{	O
ENQUEUE_STONE	O
(	O
conn	pointer
,	O
pos	int
,	O
apos	int
,	O
distance	int
+	O
FP	O
(	O
0.1	int
)	O
,	O
FP	O
(	O
0.1	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
}	O
if	O
(	O
board	pointer
[	O
apos	int
]	O
==	O
other	int
&&	O
conn	pointer
->	O
distances	array
[	O
apos	int
]	O
>	O
distance	int
+	O
FP	O
(	O
0.3	int
)	O
)	O
{	O
push_connection_heap_entry	function
(	O
conn	pointer
,	O
distance	int
+	O
FP	O
(	O
0.3	int
)	O
,	O
pos	int
,	O
apos	int
,	O
case_9_10_helper	function
)	O
;	O
}	O
if	O
(	O
board	pointer
[	O
bpos	int
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
apos	int
]	O
==	O
EMPTY	int
&&	O
conn	pointer
->	O
distances	array
[	O
bpos	int
]	O
>	O
distance	int
+	O
FP	O
(	O
1.1	int
)	O
&&	O
does_secure	function
(	O
color	int
,	O
bpos	int
,	O
apos	int
)	O
)	O
{	O
ENQUEUE	O
(	O
conn	pointer
,	O
pos	int
,	O
bpos	int
,	O
distance	int
+	O
FP	O
(	O
1.1	int
)	O
,	O
FP	O
(	O
1.0	int
)	O
,	O
apos	int
,	O
NO_MOVE	O
)	O
;	O
}	O
if	O
(	O
board	pointer
[	O
bpos	int
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
gpos	int
]	O
==	O
EMPTY	int
&&	O
conn	pointer
->	O
distances	array
[	O
bpos	int
]	O
>	O
distance	int
+	O
FP	O
(	O
1.1	int
)	O
&&	O
does_secure	function
(	O
color	int
,	O
bpos	int
,	O
gpos	int
)	O
)	O
{	O
ENQUEUE	O
(	O
conn	pointer
,	O
pos	int
,	O
bpos	int
,	O
distance	int
+	O
FP	O
(	O
1.1	int
)	O
,	O
FP	O
(	O
1.0	int
)	O
,	O
gpos	int
,	O
NO_MOVE	O
)	O
;	O
}	O
if	O
(	O
board	pointer
[	O
gpos	int
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
epos	int
]	O
==	O
EMPTY	int
&&	O
conn	pointer
->	O
distances	array
[	O
epos	int
]	O
>	O
distance	int
+	O
FP	O
(	O
1.1	int
)	O
&&	O
does_secure	function
(	O
color	int
,	O
epos	int
,	O
gpos	int
)	O
)	O
{	O
ENQUEUE	O
(	O
conn	pointer
,	O
pos	int
,	O
epos	int
,	O
distance	int
+	O
FP	O
(	O
1.1	int
)	O
,	O
FP	O
(	O
1.0	int
)	O
,	O
gpos	int
,	O
NO_MOVE	O
)	O
;	O
}	O
if	O
(	O
board	pointer
[	O
gpos	int
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
epos	int
]	O
==	O
EMPTY	int
&&	O
conn	pointer
->	O
distances	array
[	O
epos	int
]	O
>	O
distance	int
+	O
FP	O
(	O
1.1	int
)	O
&&	O
(	O
(	O
board	pointer
[	O
apos	int
]	O
==	O
color	int
&&	O
board	pointer
[	O
fpos	int
]	O
==	O
color	int
&&	O
board	pointer
[	O
bpos	int
]	O
==	O
EMPTY	int
)	O
||	O
(	O
board	pointer
[	O
hpos	int
]	O
==	O
color	int
&&	O
board	pointer
[	O
jpos	int
]	O
==	O
color	int
&&	O
board	pointer
[	O
ipos	int
]	O
==	O
EMPTY	int
)	O
)	O
)	O
{	O
ENQUEUE	O
(	O
conn	pointer
,	O
pos	int
,	O
epos	int
,	O
distance	int
+	O
FP	O
(	O
1.1	int
)	O
,	O
FP	O
(	O
1.0	int
)	O
,	O
gpos	int
,	O
NO_MOVE	O
)	O
;	O
}	O
if	O
(	O
board	pointer
[	O
bpos	int
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
apos	int
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
gpos	int
]	O
==	O
EMPTY	int
&&	O
conn	pointer
->	O
distances	array
[	O
bpos	int
]	O
>	O
distance	int
+	O
FP	O
(	O
1.3	int
)	O
)	O
{	O
ENQUEUE	O
(	O
conn	pointer
,	O
pos	int
,	O
bpos	int
,	O
distance	int
+	O
FP	O
(	O
1.3	int
)	O
,	O
FP	O
(	O
1.0	int
)	O
,	O
apos	int
,	O
gpos	int
)	O
;	O
}	O
if	O
(	O
board	pointer
[	O
apos	int
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
bpos	int
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
gpos	int
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
epos	int
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
fpos	int
]	O
==	O
EMPTY	int
&&	O
(	O
conn	pointer
->	O
distances	array
[	O
fpos	int
]	O
>	O
distance	int
+	O
FP	O
(	O
1.3	int
)	O
||	O
conn	pointer
->	O
distances	array
[	O
epos	int
]	O
>	O
distance	int
+	O
FP	O
(	O
1.3	int
)	O
)	O
&&	O
countlib	function
(	O
pos	int
)	O
>=	O
3	int
&&	O
(	O
!	O
ON_BOARD	O
(	O
cpos	int
)	O
||	O
!	O
ON_BOARD	O
(	O
hpos	int
)	O
)	O
)	O
{	O
ENQUEUE	O
(	O
conn	pointer
,	O
pos	int
,	O
fpos	int
,	O
distance	int
+	O
FP	O
(	O
1.3	int
)	O
,	O
FP	O
(	O
1.0	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
ENQUEUE	O
(	O
conn	pointer
,	O
pos	int
,	O
epos	int
,	O
distance	int
+	O
FP	O
(	O
1.3	int
)	O
,	O
FP	O
(	O
1.0	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
}	O
if	O
(	O
board	pointer
[	O
hpos	int
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
ipos	int
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
gpos	int
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
epos	int
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
jpos	int
]	O
==	O
EMPTY	int
&&	O
(	O
conn	pointer
->	O
distances	array
[	O
jpos	int
]	O
>	O
distance	int
+	O
FP	O
(	O
1.3	int
)	O
||	O
conn	pointer
->	O
distances	array
[	O
epos	int
]	O
>	O
distance	int
+	O
FP	O
(	O
1.3	int
)	O
)	O
&&	O
countlib	function
(	O
pos	int
)	O
>=	O
3	int
&&	O
(	O
!	O
ON_BOARD	O
(	O
apos	int
)	O
||	O
!	O
ON_BOARD	O
(	O
kpos	int
)	O
)	O
)	O
{	O
ENQUEUE	O
(	O
conn	pointer
,	O
pos	int
,	O
jpos	int
,	O
distance	int
+	O
FP	O
(	O
1.3	int
)	O
,	O
FP	O
(	O
1.0	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
ENQUEUE	O
(	O
conn	pointer
,	O
pos	int
,	O
epos	int
,	O
distance	int
+	O
FP	O
(	O
1.3	int
)	O
,	O
FP	O
(	O
1.0	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
}	O
if	O
(	O
board	pointer
[	O
bpos	int
]	O
==	O
EMPTY	int
&&	O
(	O
board	pointer
[	O
apos	int
]	O
==	O
EMPTY	int
||	O
board	pointer
[	O
gpos	int
]	O
==	O
EMPTY	int
)	O
&&	O
conn	pointer
->	O
distances	array
[	O
bpos	int
]	O
>	O
distance	int
+	O
FP	O
(	O
1.2	int
)	O
)	O
{	O
push_connection_heap_entry	function
(	O
conn	pointer
,	O
distance	int
+	O
FP	O
(	O
1.2	int
)	O
,	O
pos	int
,	O
bpos	int
,	O
case_16_17_18_helper	function
)	O
;	O
}	O
if	O
(	O
board	pointer
[	O
gpos	int
]	O
==	O
other	int
&&	O
board	pointer
[	O
epos	int
]	O
==	O
EMPTY	int
&&	O
conn	pointer
->	O
distances	array
[	O
epos	int
]	O
>	O
distance	int
+	O
FP	O
(	O
2.0	int
)	O
&&	O
countstones	function
(	O
gpos	int
)	O
==	O
1	int
)	O
{	O
ENQUEUE	O
(	O
conn	pointer
,	O
pos	int
,	O
epos	int
,	O
distance	int
+	O
FP	O
(	O
2.0	int
)	O
,	O
FP	O
(	O
1.0	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
}	O
if	O
(	O
board	pointer
[	O
bpos	int
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
apos	int
]	O
==	O
other	int
&&	O
board	pointer
[	O
gpos	int
]	O
==	O
other	int
&&	O
conn	pointer
->	O
distances	array
[	O
bpos	int
]	O
>	O
distance	int
+	O
FP	O
(	O
2.0	int
)	O
&&	O
(	O
countlib	function
(	O
apos	int
)	O
+	O
countlib	function
(	O
gpos	int
)	O
<=	O
6	int
)	O
)	O
{	O
ENQUEUE	O
(	O
conn	pointer
,	O
pos	int
,	O
bpos	int
,	O
distance	int
+	O
FP	O
(	O
2.0	int
)	O
,	O
FP	O
(	O
1.0	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
}	O
if	O
(	O
board	pointer
[	O
bpos	int
]	O
==	O
color	int
&&	O
board	pointer
[	O
apos	int
]	O
==	O
other	int
&&	O
board	pointer
[	O
gpos	int
]	O
==	O
other	int
&&	O
conn	pointer
->	O
distances	array
[	O
bpos	int
]	O
>	O
distance	int
+	O
FP	O
(	O
2.0	int
)	O
&&	O
(	O
countlib	function
(	O
apos	int
)	O
+	O
countlib	function
(	O
gpos	int
)	O
<=	O
5	int
)	O
)	O
{	O
ENQUEUE_STONE	O
(	O
conn	pointer
,	O
pos	int
,	O
bpos	int
,	O
distance	int
+	O
FP	O
(	O
2.0	int
)	O
,	O
FP	O
(	O
1.0	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
||	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
other	int
&&	O
countlib	function
(	O
pos	int
)	O
<=	O
2	int
&&	O
no_escape_from_ladder	function
(	O
pos	int
)	O
)	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
right	int
=	O
delta	array
[	O
k	int
]	O
;	O
int	O
up	int
=	O
delta	array
[	O
(	O
k	int
+	O
1	int
)	O
%	O
4	int
]	O
;	O
int	O
apos	int
=	O
pos	int
+	O
right	int
;	O
int	O
bpos	int
=	O
pos	int
+	O
right	int
+	O
up	int
;	O
int	O
gpos	int
=	O
pos	int
+	O
up	int
;	O
if	O
(	O
board	pointer
[	O
apos	int
]	O
==	O
color	int
)	O
{	O
ENQUEUE_STONE	O
(	O
conn	pointer
,	O
pos	int
,	O
apos	int
,	O
distance	int
,	O
FP	O
(	O
0.0	int
)	O
,	O
conn	pointer
->	O
vulnerable1	array
[	O
pos	int
]	O
,	O
conn	pointer
->	O
vulnerable2	array
[	O
pos	int
]	O
)	O
;	O
}	O
else	O
if	O
(	O
board	pointer
[	O
apos	int
]	O
==	O
EMPTY	int
)	O
{	O
int	O
this_delta	int
=	O
FP	O
(	O
0.8	int
)	O
+	O
FP	O
(	O
0.05	int
)	O
*	O
gg_min	O
(	O
approxlib	function
(	O
apos	int
,	O
other	int
,	O
6	int
,	O
NULL	O
)	O
,	O
6	int
)	O
;	O
ENQUEUE	O
(	O
conn	pointer
,	O
pos	int
,	O
apos	int
,	O
distance	int
+	O
this_delta	int
,	O
this_delta	int
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
}	O
else	O
if	O
(	O
board	pointer
[	O
apos	int
]	O
==	O
other	int
)	O
{	O
ENQUEUE_STONE	O
(	O
conn	pointer
,	O
pos	int
,	O
apos	int
,	O
distance	int
+	O
FP	O
(	O
1.0	int
)	O
,	O
FP	O
(	O
1.0	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
}	O
if	O
(	O
board	pointer
[	O
bpos	int
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
apos	int
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
gpos	int
]	O
==	O
EMPTY	int
&&	O
conn	pointer
->	O
distances	array
[	O
bpos	int
]	O
>	O
distance	int
+	O
FP	O
(	O
1.5	int
)	O
)	O
{	O
ENQUEUE	O
(	O
conn	pointer
,	O
pos	int
,	O
bpos	int
,	O
distance	int
+	O
FP	O
(	O
1.5	int
)	O
,	O
FP	O
(	O
1.0	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
}	O
if	O
(	O
board	pointer
[	O
bpos	int
]	O
==	O
color	int
&&	O
board	pointer
[	O
apos	int
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
gpos	int
]	O
==	O
EMPTY	int
&&	O
conn	pointer
->	O
distances	array
[	O
bpos	int
]	O
>	O
distance	int
+	O
FP	O
(	O
1.3	int
)	O
)	O
{	O
ENQUEUE_STONE	O
(	O
conn	pointer
,	O
pos	int
,	O
bpos	int
,	O
distance	int
+	O
FP	O
(	O
1.3	int
)	O
,	O
FP	O
(	O
1.0	int
)	O
,	O
NO_MOVE	O
,	O
NO_MOVE	O
)	O
;	O
}	O
}	O
}	O
}	O
}	O
void	O
sort_connection_queue_tail	function
(	O
struct	O
connection_data	struct
*	O
conn	pointer
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
conn	pointer
->	O
queue_start	int
;	O
k	int
<	O
conn	pointer
->	O
queue_end	int
-	O
1	int
;	O
k	int
++	O
)	O
{	O
int	O
i	int
;	O
int	O
best_index	int
=	O
k	int
;	O
int	O
smallest_dist	int
=	O
conn	pointer
->	O
distances	array
[	O
conn	pointer
->	O
queue	array
[	O
k	int
]	O
]	O
;	O
for	O
(	O
i	int
=	O
k	int
+	O
1	int
;	O
i	int
<	O
conn	pointer
->	O
queue_end	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
conn	pointer
->	O
distances	array
[	O
conn	pointer
->	O
queue	array
[	O
i	int
]	O
]	O
<	O
smallest_dist	int
)	O
{	O
best_index	int
=	O
i	int
;	O
smallest_dist	int
=	O
conn	pointer
->	O
distances	array
[	O
conn	pointer
->	O
queue	array
[	O
i	int
]	O
]	O
;	O
}	O
}	O
if	O
(	O
best_index	int
!=	O
k	int
)	O
{	O
int	O
temp	int
=	O
conn	pointer
->	O
queue	array
[	O
k	int
]	O
;	O
conn	pointer
->	O
queue	array
[	O
k	int
]	O
=	O
conn	pointer
->	O
queue	array
[	O
best_index	int
]	O
;	O
conn	pointer
->	O
queue	array
[	O
best_index	int
]	O
=	O
temp	int
;	O
}	O
}	O
}	O
void	O
expand_connection_queue	function
(	O
struct	O
connection_data	struct
*	O
conn	pointer
)	O
{	O
int	O
k	int
;	O
int	O
full_queue	array
[	O
BOARDMAX	O
]	O
;	O
int	O
full_queue_position	int
=	O
0	int
;	O
int	O
full_queue_start	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
conn	pointer
->	O
queue_end	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
k	int
==	O
conn	pointer
->	O
queue_start	int
)	O
full_queue_start	int
=	O
full_queue_position	int
;	O
if	O
(	O
board	pointer
[	O
conn	pointer
->	O
queue	array
[	O
k	int
]	O
]	O
==	O
EMPTY	int
)	O
full_queue	array
[	O
full_queue_position	int
++	O
]	O
=	O
conn	pointer
->	O
queue	array
[	O
k	int
]	O
;	O
else	O
{	O
full_queue_position	int
+=	O
findstones	function
(	O
conn	pointer
->	O
queue	array
[	O
k	int
]	O
,	O
MAX_BOARD	int
*	O
MAX_BOARD	int
,	O
full_queue	array
+	O
full_queue_position	int
)	O
;	O
}	O
}	O
conn	pointer
->	O
queue_start	int
=	O
full_queue_start	int
;	O
conn	pointer
->	O
queue_end	int
=	O
full_queue_position	int
;	O
memcpy	function
(	O
conn	pointer
->	O
queue	array
,	O
full_queue	array
,	O
conn	pointer
->	O
queue_end	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
}	O
static	O
void	O
clear_connection_data	function
(	O
struct	O
connection_data	struct
*	O
conn	pointer
)	O
{	O
int	O
pos	int
;	O
conn	pointer
->	O
queue_start	int
=	O
0	int
;	O
conn	pointer
->	O
queue_end	int
=	O
0	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
conn	pointer
->	O
distances	array
[	O
pos	int
]	O
=	O
HUGE_CONNECTION_DISTANCE	O
;	O
conn	pointer
->	O
deltas	array
[	O
pos	int
]	O
=	O
FP	O
(	O
0.0	int
)	O
;	O
conn	pointer
->	O
coming_from	int
[	O
pos	int
]	O
=	O
NO_MOVE	O
;	O
conn	pointer
->	O
vulnerable1	array
[	O
pos	int
]	O
=	O
NO_MOVE	O
;	O
conn	pointer
->	O
vulnerable2	array
[	O
pos	int
]	O
=	O
NO_MOVE	O
;	O
}	O
conn	pointer
->	O
heap_data_size	int
=	O
0	int
;	O
conn	pointer
->	O
heap_size	int
=	O
0	int
;	O
}	O
void	O
compute_connection_distances	function
(	O
int	O
str	int
,	O
int	O
target	int
,	O
int	O
cutoff	int
,	O
struct	O
connection_data	struct
*	O
conn	pointer
,	O
int	O
speculative	int
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
clear_connection_data	function
(	O
conn	pointer
)	O
;	O
add_to_start_queue	function
(	O
find_origin	function
(	O
str	int
)	O
,	O
FP	O
(	O
0.0	int
)	O
,	O
conn	pointer
)	O
;	O
conn	pointer
->	O
target	int
=	O
target	int
;	O
conn	pointer
->	O
cutoff_distance	int
=	O
cutoff	int
;	O
conn	pointer
->	O
speculative	int
=	O
speculative	int
;	O
spread_connection_distances	function
(	O
color	int
,	O
conn	pointer
)	O
;	O
}	O
void	O
print_connection_distances	function
(	O
struct	O
connection_data	struct
*	O
conn	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
ch	int
;	O
int	O
pos	int
;	O
fprintf	function
(	O
stderr	pointer
,	O
"  "	pointer
)	O
;	O
for	O
(	O
j	int
=	O
0	int
,	O
ch	int
=	O
'A'	O
;	O
j	int
<	O
board_size	int
;	O
j	int
++	O
,	O
ch	int
++	O
)	O
{	O
if	O
(	O
ch	int
==	O
'I'	O
)	O
ch	int
++	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"  %c "	pointer
,	O
ch	int
)	O
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
board_size	int
;	O
i	int
++	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%2d "	pointer
,	O
board_size	int
-	O
i	int
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
board_size	int
;	O
j	int
++	O
)	O
{	O
pos	int
=	O
POS	O
(	O
i	int
,	O
j	int
)	O
;	O
if	O
(	O
conn	pointer
->	O
distances	array
[	O
pos	int
]	O
==	O
HUGE_CONNECTION_DISTANCE	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
WHITE	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
" O  "	pointer
)	O
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
BLACK	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
" X  "	pointer
)	O
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
" .  "	pointer
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%3.1f "	pointer
,	O
FIXED_TO_FLOAT	O
(	O
conn	pointer
->	O
distances	array
[	O
pos	int
]	O
)	O
)	O
;	O
}	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Vulnerable:\n"	pointer
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
conn	pointer
->	O
distances	array
[	O
pos	int
]	O
<	O
HUGE_CONNECTION_DISTANCE	O
&&	O
(	O
conn	pointer
->	O
vulnerable1	array
[	O
pos	int
]	O
!=	O
NO_MOVE	O
||	O
conn	pointer
->	O
vulnerable2	array
[	O
pos	int
]	O
!=	O
NO_MOVE	O
)	O
)	O
{	O
gprintf	function
(	O
" %1m:"	pointer
,	O
pos	int
)	O
;	O
if	O
(	O
conn	pointer
->	O
vulnerable1	array
[	O
pos	int
]	O
!=	O
NO_MOVE	O
)	O
gprintf	function
(	O
" %1m"	pointer
,	O
conn	pointer
->	O
vulnerable1	array
[	O
pos	int
]	O
)	O
;	O
if	O
(	O
conn	pointer
->	O
vulnerable2	array
[	O
pos	int
]	O
!=	O
NO_MOVE	O
)	O
gprintf	function
(	O
" %1m"	pointer
,	O
conn	pointer
->	O
vulnerable2	array
[	O
pos	int
]	O
)	O
;	O
gprintf	function
(	O
"\n"	pointer
,	O
pos	int
)	O
;	O
}	O
}	O
static	O
int	O
trivial_connection	function
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
*	O
move	pointer
)	O
{	O
SGFTree	struct
*	O
save_sgf_dumptree	pointer
=	O
sgf_dumptree	pointer
;	O
int	O
save_count_variations	int
=	O
count_variations	int
;	O
int	O
adj	array
,	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
r	int
;	O
int	O
result	int
=	O
0	int
;	O
if	O
(	O
have_common_lib	function
(	O
str1	int
,	O
str2	int
,	O
move	pointer
)	O
)	O
return	O
WIN	int
;	O
adj	array
=	O
chainlinks	function
(	O
str1	int
,	O
adjs	array
)	O
;	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array
;	O
r	int
++	O
)	O
if	O
(	O
adjacent_strings	function
(	O
adjs	array
[	O
r	int
]	O
,	O
str2	int
)	O
&&	O
attack	function
(	O
adjs	array
[	O
r	int
]	O
,	O
move	pointer
)	O
==	O
WIN	int
)	O
{	O
result	int
=	O
WIN	int
;	O
break	O
;	O
}	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
count_variations	int
=	O
save_count_variations	int
;	O
return	O
result	int
;	O
}	O
static	O
int	O
does_secure_through_ladder	function
(	O
int	O
color	int
,	O
int	O
move	pointer
,	O
int	O
pos	int
)	O
{	O
int	O
result	int
=	O
0	int
;	O
if	O
(	O
trymove	function
(	O
move	pointer
,	O
color	int
,	O
NULL	O
,	O
NO_MOVE	O
)	O
)	O
{	O
if	O
(	O
ladder_capturable	function
(	O
pos	int
,	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
)	O
result	int
=	O
1	int
;	O
popgo	function
(	O
)	O
;	O
}	O
return	O
result	int
;	O
}	O
static	O
int	O
ladder_capture	function
(	O
int	O
str	int
,	O
int	O
*	O
move	pointer
)	O
{	O
int	O
result	int
;	O
SGFTree	struct
*	O
save_sgf_dumptree	pointer
=	O
sgf_dumptree	pointer
;	O
int	O
save_count_variations	int
=	O
count_variations	int
;	O
int	O
liberties	pointer
=	O
countlib	function
(	O
str	int
)	O
;	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
if	O
(	O
liberties	pointer
==	O
1	int
)	O
result	int
=	O
attack	function
(	O
str	int
,	O
move	pointer
)	O
;	O
else	O
if	O
(	O
liberties	pointer
==	O
2	int
)	O
result	int
=	O
simple_ladder	function
(	O
str	int
,	O
move	pointer
)	O
;	O
else	O
result	int
=	O
0	int
;	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
count_variations	int
=	O
save_count_variations	int
;	O
return	O
result	int
;	O
}	O
static	O
int	O
ladder_capturable	function
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
int	O
result	int
=	O
0	int
;	O
if	O
(	O
trymove	function
(	O
pos	int
,	O
color	int
,	O
NULL	O
,	O
NO_MOVE	O
)	O
)	O
{	O
int	O
liberties	pointer
=	O
countlib	function
(	O
pos	int
)	O
;	O
if	O
(	O
liberties	pointer
==	O
1	int
&&	O
attack	function
(	O
pos	int
,	O
NULL	O
)	O
==	O
WIN	int
)	O
result	int
=	O
1	int
;	O
else	O
if	O
(	O
liberties	pointer
==	O
2	int
&&	O
simple_ladder	function
(	O
pos	int
,	O
NULL	O
)	O
==	O
WIN	int
)	O
result	int
=	O
1	int
;	O
popgo	function
(	O
)	O
;	O
}	O
else	O
result	int
=	O
1	int
;	O
return	O
result	int
;	O
}	O
static	O
int	O
no_escape_from_atari	function
(	O
int	O
str	int
)	O
{	O
int	O
lib	int
;	O
int	O
adj	array
[	O
MAXCHAIN	int
]	O
;	O
if	O
(	O
findlib	function
(	O
str	int
,	O
1	int
,	O
&	O
lib	int
)	O
>	O
1	int
)	O
return	O
0	int
;	O
if	O
(	O
accuratelib	function
(	O
lib	int
,	O
board	pointer
[	O
str	int
]	O
,	O
2	int
,	O
NULL	O
)	O
>	O
1	int
)	O
return	O
0	int
;	O
if	O
(	O
chainlinks2	function
(	O
str	int
,	O
adj	array
,	O
1	int
)	O
>	O
0	int
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
int	O
no_escape_from_ladder	function
(	O
int	O
str	int
)	O
{	O
int	O
result	int
=	O
0	int
;	O
SGFTree	struct
*	O
save_sgf_dumptree	pointer
=	O
sgf_dumptree	pointer
;	O
int	O
save_count_variations	int
=	O
count_variations	int
;	O
int	O
adj	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
libs	pointer
[	O
2	int
]	O
;	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
if	O
(	O
countlib	function
(	O
str	int
)	O
==	O
1	int
&&	O
find_defense	function
(	O
str	int
,	O
NULL	O
)	O
==	O
0	int
)	O
result	int
=	O
1	int
;	O
if	O
(	O
countlib	function
(	O
str	int
)	O
==	O
2	int
&&	O
chainlinks2	function
(	O
str	int
,	O
adj	array
,	O
1	int
)	O
==	O
0	int
&&	O
findlib	function
(	O
str	int
,	O
2	int
,	O
libs	pointer
)	O
==	O
2	int
&&	O
approxlib	function
(	O
libs	pointer
[	O
0	int
]	O
,	O
board	pointer
[	O
str	int
]	O
,	O
2	int
,	O
NULL	O
)	O
==	O
1	int
&&	O
approxlib	function
(	O
libs	pointer
[	O
1	int
]	O
,	O
board	pointer
[	O
str	int
]	O
,	O
2	int
,	O
NULL	O
)	O
==	O
1	int
&&	O
ladder_capture	function
(	O
str	int
,	O
NULL	O
)	O
&&	O
!	O
find_defense	function
(	O
str	int
,	O
NULL	O
)	O
)	O
result	int
=	O
1	int
;	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
count_variations	int
=	O
save_count_variations	int
;	O
return	O
result	int
;	O
}	O
static	O
int	O
check_self_atari	function
(	O
int	O
pos	int
,	O
int	O
color_to_move	int
)	O
{	O
int	O
lib	int
;	O
if	O
(	O
!	O
is_self_atari	function
(	O
pos	int
,	O
color_to_move	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
is_ko	function
(	O
pos	int
,	O
color_to_move	int
,	O
NULL	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
approxlib	function
(	O
pos	int
,	O
color_to_move	int
,	O
1	int
,	O
&	O
lib	int
)	O
>=	O
1	int
&&	O
approxlib	function
(	O
lib	int
,	O
OTHER_COLOR	O
(	O
color_to_move	int
)	O
,	O
3	int
,	O
NULL	O
)	O
<=	O
2	int
&&	O
ladder_capturable	function
(	O
lib	int
,	O
OTHER_COLOR	O
(	O
color_to_move	int
)	O
)	O
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
+	O
delta	array
[	O
k	int
]	O
]	O
==	O
color_to_move	int
)	O
break	O
;	O
}	O
if	O
(	O
k	int
==	O
4	int
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
common_vulnerabilities	function
(	O
int	O
a1	int
,	O
int	O
a2	int
,	O
int	O
b1	int
,	O
int	O
b2	int
,	O
int	O
color	int
)	O
{	O
return	O
(	O
common_vulnerability	function
(	O
a1	int
,	O
b1	int
,	O
color	int
)	O
||	O
common_vulnerability	function
(	O
a1	int
,	O
b2	int
,	O
color	int
)	O
||	O
common_vulnerability	function
(	O
a2	int
,	O
b1	int
,	O
color	int
)	O
||	O
common_vulnerability	function
(	O
a2	int
,	O
b2	int
,	O
color	int
)	O
)	O
;	O
}	O
static	O
int	O
common_vulnerability	function
(	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
int	O
color	int
)	O
{	O
int	O
k	int
;	O
if	O
(	O
apos	int
==	O
NO_MOVE	O
||	O
bpos	int
==	O
NO_MOVE	O
)	O
return	O
0	int
;	O
if	O
(	O
apos	int
==	O
bpos	int
)	O
return	O
1	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
if	O
(	O
board	pointer
[	O
apos	int
+	O
delta	array
[	O
k	int
]	O
]	O
==	O
color	int
&&	O
countlib	function
(	O
apos	int
+	O
delta	array
[	O
k	int
]	O
)	O
<=	O
3	int
&&	O
liberty_of_string	function
(	O
bpos	int
,	O
apos	int
+	O
delta	array
[	O
k	int
]	O
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
