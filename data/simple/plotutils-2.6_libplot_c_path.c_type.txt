void	O
_pl_c_paint_path	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pen_type	int
==	O
0	int
&&	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fill_type	int
==	O
0	int
)	O
return	O
;	O
switch	O
(	O
(	O
int	O
)	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
type	enum
)	O
{	O
case	O
(	O
int	O
)	O
PATH_SEGMENT_LIST	int
:	O
{	O
bool	enum
closed	enum
;	O
plIntPathSegment	struct
*	O
xarray	pointer
;	O
int	O
polyline_len	int
;	O
bool	enum
draw_as_cgm_compound	enum
,	O
path_is_single_polyline	enum
;	O
int	O
pass	int
;	O
plPathSegmentType	enum
first_element_type	enum
;	O
int	O
i	int
,	O
byte_count	pointer
,	O
data_byte_count	pointer
,	O
data_len	int
;	O
int	O
desired_interior_style	int
;	O
const	O
char	O
*	O
desired_interior_style_string	pointer
;	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
==	O
0	int
)	O
break	O
;	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
==	O
1	int
)	O
break	O
;	O
if	O
(	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
>=	O
3	int
)	O
&&	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
-	O
1	int
]	O
.	O
p	struct
.	O
x	double
==	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
0	int
]	O
.	O
p	struct
.	O
x	double
)	O
&&	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
-	O
1	int
]	O
.	O
p	struct
.	O
y	double
==	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
0	int
]	O
.	O
p	struct
.	O
y	double
)	O
)	O
closed	enum
=	O
true	int
;	O
else	O
closed	enum
=	O
false	int
;	O
_pl_c_set_pen_color	function
(	O
R___	O
(	O
_plotter	pointer
)	O
closed	enum
?	O
CGM_OBJECT_CLOSED	int
:	O
CGM_OBJECT_OPEN	int
)	O
;	O
_pl_c_set_fill_color	function
(	O
R___	O
(	O
_plotter	pointer
)	O
closed	enum
?	O
CGM_OBJECT_CLOSED	int
:	O
CGM_OBJECT_OPEN	int
)	O
;	O
_pl_c_set_attributes	function
(	O
R___	O
(	O
_plotter	pointer
)	O
closed	enum
?	O
CGM_OBJECT_CLOSED	int
:	O
CGM_OBJECT_OPEN	int
)	O
;	O
xarray	pointer
=	O
(	O
plIntPathSegment	struct
*	O
)	O
_pl_xmalloc	function
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
*	O
sizeof	O
(	O
plIntPathSegment	struct
)	O
)	O
;	O
xarray	pointer
[	O
0	int
]	O
.	O
p	struct
.	O
x	double
=	O
IROUND	O
(	O
XD	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
0	int
]	O
.	O
p	struct
.	O
x	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
0	int
]	O
.	O
p	struct
.	O
y	double
)	O
)	O
;	O
xarray	pointer
[	O
0	int
]	O
.	O
p	struct
.	O
y	double
=	O
IROUND	O
(	O
YD	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
0	int
]	O
.	O
p	struct
.	O
x	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
0	int
]	O
.	O
p	struct
.	O
y	double
)	O
)	O
;	O
polyline_len	int
=	O
1	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
;	O
i	int
++	O
)	O
{	O
plPathSegment	struct
datapoint	struct
;	O
double	O
xuser	double
,	O
yuser	double
,	O
xdev	double
,	O
ydev	double
;	O
int	O
device_x	int
,	O
device_y	int
;	O
datapoint	struct
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
i	int
]	O
;	O
xuser	double
=	O
datapoint	struct
.	O
p	struct
.	O
x	double
;	O
yuser	double
=	O
datapoint	struct
.	O
p	struct
.	O
y	double
;	O
xdev	double
=	O
XD	O
(	O
xuser	double
,	O
yuser	double
)	O
;	O
ydev	double
=	O
YD	O
(	O
xuser	double
,	O
yuser	double
)	O
;	O
device_x	int
=	O
IROUND	O
(	O
xdev	double
)	O
;	O
device_y	int
=	O
IROUND	O
(	O
ydev	double
)	O
;	O
{	O
plPathSegmentType	enum
element_type	enum
;	O
int	O
device_xc	int
,	O
device_yc	int
;	O
xarray	pointer
[	O
polyline_len	int
]	O
.	O
p	struct
.	O
x	double
=	O
device_x	int
;	O
xarray	pointer
[	O
polyline_len	int
]	O
.	O
p	struct
.	O
y	double
=	O
device_y	int
;	O
element_type	enum
=	O
datapoint	struct
.	O
type	enum
;	O
xarray	pointer
[	O
polyline_len	int
]	O
.	O
type	enum
=	O
element_type	enum
;	O
if	O
(	O
element_type	enum
==	O
S_ARC	int
||	O
element_type	enum
==	O
S_ELLARC	int
)	O
{	O
device_xc	int
=	O
IROUND	O
(	O
XD	O
(	O
datapoint	struct
.	O
pc	struct
.	O
x	double
,	O
datapoint	struct
.	O
pc	struct
.	O
y	double
)	O
)	O
;	O
device_yc	int
=	O
IROUND	O
(	O
YD	O
(	O
datapoint	struct
.	O
pc	struct
.	O
x	double
,	O
datapoint	struct
.	O
pc	struct
.	O
y	double
)	O
)	O
;	O
xarray	pointer
[	O
polyline_len	int
]	O
.	O
pc	struct
.	O
x	double
=	O
device_xc	int
;	O
xarray	pointer
[	O
polyline_len	int
]	O
.	O
pc	struct
.	O
y	double
=	O
device_yc	int
;	O
}	O
else	O
if	O
(	O
element_type	enum
==	O
S_CUBIC	int
)	O
{	O
xarray	pointer
[	O
polyline_len	int
]	O
.	O
pc	struct
.	O
x	double
=	O
IROUND	O
(	O
XD	O
(	O
datapoint	struct
.	O
pc	struct
.	O
x	double
,	O
datapoint	struct
.	O
pc	struct
.	O
y	double
)	O
)	O
;	O
xarray	pointer
[	O
polyline_len	int
]	O
.	O
pc	struct
.	O
y	double
=	O
IROUND	O
(	O
YD	O
(	O
datapoint	struct
.	O
pc	struct
.	O
x	double
,	O
datapoint	struct
.	O
pc	struct
.	O
y	double
)	O
)	O
;	O
xarray	pointer
[	O
polyline_len	int
]	O
.	O
pd	struct
.	O
x	double
=	O
IROUND	O
(	O
XD	O
(	O
datapoint	struct
.	O
pd	struct
.	O
x	double
,	O
datapoint	struct
.	O
pd	struct
.	O
y	double
)	O
)	O
;	O
xarray	pointer
[	O
polyline_len	int
]	O
.	O
pd	struct
.	O
y	double
=	O
IROUND	O
(	O
YD	O
(	O
datapoint	struct
.	O
pd	struct
.	O
x	double
,	O
datapoint	struct
.	O
pd	struct
.	O
y	double
)	O
)	O
;	O
}	O
polyline_len	int
++	O
;	O
}	O
}	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
polyline_len	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
xarray	pointer
[	O
i	int
]	O
.	O
type	enum
==	O
S_ARC	int
||	O
xarray	pointer
[	O
i	int
]	O
.	O
type	enum
==	O
S_ELLARC	int
)	O
if	O
(	O
(	O
xarray	pointer
[	O
i	int
-	O
1	int
]	O
.	O
p	struct
.	O
x	double
==	O
xarray	pointer
[	O
i	int
]	O
.	O
p	struct
.	O
x	double
&&	O
xarray	pointer
[	O
i	int
-	O
1	int
]	O
.	O
p	struct
.	O
y	double
==	O
xarray	pointer
[	O
i	int
]	O
.	O
p	struct
.	O
y	double
)	O
||	O
(	O
xarray	pointer
[	O
i	int
-	O
1	int
]	O
.	O
p	struct
.	O
x	double
==	O
xarray	pointer
[	O
i	int
]	O
.	O
pc	struct
.	O
x	double
&&	O
xarray	pointer
[	O
i	int
-	O
1	int
]	O
.	O
p	struct
.	O
y	double
==	O
xarray	pointer
[	O
i	int
]	O
.	O
pc	struct
.	O
y	double
)	O
||	O
(	O
xarray	pointer
[	O
i	int
]	O
.	O
p	struct
.	O
x	double
==	O
xarray	pointer
[	O
i	int
]	O
.	O
pc	struct
.	O
x	double
&&	O
xarray	pointer
[	O
i	int
]	O
.	O
p	struct
.	O
y	double
==	O
xarray	pointer
[	O
i	int
]	O
.	O
pc	struct
.	O
y	double
)	O
)	O
xarray	pointer
[	O
i	int
]	O
.	O
type	enum
=	O
S_LINE	int
;	O
}	O
if	O
(	O
closed	enum
)	O
{	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fill_type	int
==	O
0	int
)	O
{	O
desired_interior_style	int
=	O
CGM_INT_STYLE_EMPTY	int
;	O
desired_interior_style_string	pointer
=	O
"empty"	pointer
;	O
}	O
else	O
{	O
desired_interior_style	int
=	O
CGM_INT_STYLE_SOLID	int
;	O
desired_interior_style_string	pointer
=	O
"solid"	pointer
;	O
}	O
if	O
(	O
_plotter	pointer
->	O
cgm_interior_style	int
!=	O
desired_interior_style	int
)	O
{	O
data_len	int
=	O
2	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_ATTRIBUTE_ELEMENT	int
,	O
22	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"INTSTYLE"	pointer
)	O
;	O
_cgm_emit_enum	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
desired_interior_style	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
,	O
desired_interior_style_string	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
_plotter	pointer
->	O
cgm_interior_style	int
=	O
desired_interior_style	int
;	O
}	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pen_type	int
)	O
{	O
if	O
(	O
_plotter	pointer
->	O
cgm_edge_is_visible	enum
!=	O
true	int
)	O
{	O
data_len	int
=	O
2	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_ATTRIBUTE_ELEMENT	int
,	O
30	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"EDGEVIS"	pointer
)	O
;	O
_cgm_emit_enum	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
1	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
,	O
"on"	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
_plotter	pointer
->	O
cgm_edge_is_visible	enum
=	O
true	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
_plotter	pointer
->	O
cgm_edge_is_visible	enum
!=	O
false	int
)	O
{	O
data_len	int
=	O
2	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_ATTRIBUTE_ELEMENT	int
,	O
30	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"EDGEVIS"	pointer
)	O
;	O
_cgm_emit_enum	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
0	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
,	O
"off"	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
_plotter	pointer
->	O
cgm_edge_is_visible	enum
=	O
false	int
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fill_type	int
!=	O
0	int
)	O
{	O
if	O
(	O
_plotter	pointer
->	O
cgm_interior_style	int
!=	O
CGM_INT_STYLE_SOLID	int
)	O
{	O
data_len	int
=	O
2	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_ATTRIBUTE_ELEMENT	int
,	O
22	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"INTSTYLE"	pointer
)	O
;	O
_cgm_emit_enum	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_INT_STYLE_SOLID	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
,	O
"solid"	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
_plotter	pointer
->	O
cgm_interior_style	int
=	O
CGM_INT_STYLE_SOLID	int
;	O
}	O
if	O
(	O
_plotter	pointer
->	O
cgm_edge_is_visible	enum
)	O
{	O
data_len	int
=	O
2	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_ATTRIBUTE_ELEMENT	int
,	O
30	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"EDGEVIS"	pointer
)	O
;	O
_cgm_emit_enum	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
0	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
,	O
"off"	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
_plotter	pointer
->	O
cgm_edge_is_visible	enum
=	O
false	int
;	O
}	O
}	O
}	O
draw_as_cgm_compound	enum
=	O
false	int
;	O
first_element_type	enum
=	O
xarray	pointer
[	O
1	int
]	O
.	O
type	enum
;	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<	O
polyline_len	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
xarray	pointer
[	O
i	int
]	O
.	O
type	enum
==	O
S_ARC	int
||	O
xarray	pointer
[	O
i	int
]	O
.	O
type	enum
==	O
S_ELLARC	int
||	O
xarray	pointer
[	O
i	int
]	O
.	O
type	enum
!=	O
first_element_type	enum
)	O
{	O
draw_as_cgm_compound	enum
=	O
true	int
;	O
break	O
;	O
}	O
}	O
{	O
path_is_single_polyline	enum
=	O
true	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
polyline_len	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
xarray	pointer
[	O
i	int
]	O
.	O
type	enum
!=	O
S_LINE	int
)	O
{	O
path_is_single_polyline	enum
=	O
false	int
;	O
break	O
;	O
}	O
}	O
}	O
for	O
(	O
pass	int
=	O
0	int
;	O
pass	int
<	O
2	int
;	O
pass	int
++	O
)	O
{	O
int	O
primitives_emitted	int
;	O
if	O
(	O
pass	int
==	O
0	int
&&	O
!	O
(	O
closed	enum
||	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fill_type	int
!=	O
0	int
)	O
)	O
continue	O
;	O
if	O
(	O
pass	int
==	O
1	int
&&	O
(	O
closed	enum
||	O
(	O
!	O
closed	enum
&&	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pen_type	int
==	O
0	int
)	O
)	O
)	O
continue	O
;	O
primitives_emitted	int
=	O
0	int
;	O
if	O
(	O
pass	int
==	O
0	int
&&	O
!	O
path_is_single_polyline	enum
)	O
{	O
data_len	int
=	O
0	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_DELIMITER_ELEMENT	int
,	O
8	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"BEGFIGURE"	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
_plotter	pointer
->	O
cgm_page_version	int
=	O
IMAX	O
(	O
2	int
,	O
_plotter	pointer
->	O
cgm_page_version	int
)	O
;	O
}	O
if	O
(	O
pass	int
==	O
1	int
&&	O
draw_as_cgm_compound	enum
)	O
{	O
data_len	int
=	O
0	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_DELIMITER_ELEMENT	int
,	O
15	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"BEGCOMPOLINE"	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
_plotter	pointer
->	O
cgm_page_version	int
=	O
IMAX	O
(	O
3	int
,	O
_plotter	pointer
->	O
cgm_page_version	int
)	O
;	O
}	O
i	int
=	O
0	int
;	O
while	O
(	O
i	int
+	O
1	int
<	O
polyline_len	int
)	O
{	O
int	O
j	int
,	O
end_of_run	int
;	O
plPathSegmentType	enum
element_type	enum
;	O
element_type	enum
=	O
xarray	pointer
[	O
i	int
+	O
1	int
]	O
.	O
type	enum
;	O
for	O
(	O
j	int
=	O
i	int
+	O
1	int
;	O
j	int
<	O
polyline_len	int
&&	O
xarray	pointer
[	O
j	int
]	O
.	O
type	enum
==	O
element_type	enum
;	O
j	int
++	O
)	O
;	O
end_of_run	int
=	O
j	int
-	O
1	int
;	O
switch	O
(	O
(	O
int	O
)	O
element_type	enum
)	O
{	O
case	O
(	O
int	O
)	O
S_LINE	int
:	O
if	O
(	O
(	O
pass	int
==	O
0	int
&&	O
!	O
path_is_single_polyline	enum
)	O
||	O
(	O
pass	int
==	O
1	int
)	O
)	O
{	O
if	O
(	O
1	int
+	O
(	O
end_of_run	int
-	O
i	int
)	O
>	O
4096	int
)	O
_plotter	pointer
->	O
cgm_page_profile	int
=	O
IMAX	O
(	O
_plotter	pointer
->	O
cgm_page_profile	int
,	O
CGM_PROFILE_NONE	int
)	O
;	O
data_len	int
=	O
2	int
*	O
CGM_BINARY_BYTES_PER_INTEGER	int
*	O
(	O
1	int
+	O
end_of_run	int
-	O
i	int
)	O
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_GRAPHICAL_PRIMITIVE_ELEMENT	int
,	O
1	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"LINE"	pointer
)	O
;	O
for	O
(	O
;	O
i	int
<=	O
end_of_run	int
;	O
i	int
++	O
)	O
_cgm_emit_point	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
xarray	pointer
[	O
i	int
]	O
.	O
p	struct
.	O
x	double
,	O
xarray	pointer
[	O
i	int
]	O
.	O
p	struct
.	O
y	double
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
primitives_emitted	int
++	O
;	O
i	int
--	O
;	O
}	O
else	O
{	O
if	O
(	O
polyline_len	int
-	O
(	O
closed	enum
?	O
1	int
:	O
0	int
)	O
>	O
4096	int
)	O
_plotter	pointer
->	O
cgm_page_profile	int
=	O
IMAX	O
(	O
_plotter	pointer
->	O
cgm_page_profile	int
,	O
CGM_PROFILE_NONE	int
)	O
;	O
data_len	int
=	O
2	int
*	O
CGM_BINARY_BYTES_PER_INTEGER	int
*	O
(	O
polyline_len	int
-	O
(	O
closed	enum
?	O
1	int
:	O
0	int
)	O
)	O
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_GRAPHICAL_PRIMITIVE_ELEMENT	int
,	O
7	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"POLYGON"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
polyline_len	int
-	O
(	O
closed	enum
?	O
1	int
:	O
0	int
)	O
;	O
i	int
++	O
)	O
_cgm_emit_point	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
xarray	pointer
[	O
i	int
]	O
.	O
p	struct
.	O
x	double
,	O
xarray	pointer
[	O
i	int
]	O
.	O
p	struct
.	O
y	double
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
primitives_emitted	int
++	O
;	O
i	int
=	O
polyline_len	int
-	O
1	int
;	O
}	O
break	O
;	O
case	O
(	O
int	O
)	O
S_ARC	int
:	O
{	O
int	O
delta0_x	int
=	O
xarray	pointer
[	O
i	int
]	O
.	O
p	struct
.	O
x	double
-	O
xarray	pointer
[	O
i	int
+	O
1	int
]	O
.	O
pc	struct
.	O
x	double
;	O
int	O
delta0_y	int
=	O
xarray	pointer
[	O
i	int
]	O
.	O
p	struct
.	O
y	double
-	O
xarray	pointer
[	O
i	int
+	O
1	int
]	O
.	O
pc	struct
.	O
y	double
;	O
int	O
delta1_x	int
=	O
xarray	pointer
[	O
i	int
+	O
1	int
]	O
.	O
p	struct
.	O
x	double
-	O
xarray	pointer
[	O
i	int
+	O
1	int
]	O
.	O
pc	struct
.	O
x	double
;	O
int	O
delta1_y	int
=	O
xarray	pointer
[	O
i	int
+	O
1	int
]	O
.	O
p	struct
.	O
y	double
-	O
xarray	pointer
[	O
i	int
+	O
1	int
]	O
.	O
pc	struct
.	O
y	double
;	O
double	O
radius	double
=	O
sqrt	function
(	O
(	O
double	O
)	O
delta0_x	int
*	O
(	O
double	O
)	O
delta0_x	int
+	O
(	O
double	O
)	O
delta0_y	int
*	O
(	O
double	O
)	O
delta0_y	int
)	O
;	O
int	O
i_radius	int
=	O
IROUND	O
(	O
radius	double
)	O
;	O
double	O
dot	double
=	O
(	O
(	O
double	O
)	O
delta0_x	int
*	O
(	O
double	O
)	O
delta1_y	int
-	O
(	O
double	O
)	O
delta0_y	int
*	O
(	O
double	O
)	O
delta1_x	int
)	O
;	O
bool	enum
reversed	enum
=	O
(	O
dot	double
>=	O
0.0	int
?	O
false	int
:	O
true	int
)	O
;	O
data_len	int
=	O
(	O
3	int
*	O
2	int
+	O
1	int
)	O
*	O
CGM_BINARY_BYTES_PER_INTEGER	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
if	O
(	O
reversed	enum
)	O
_cgm_emit_command_header	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_GRAPHICAL_PRIMITIVE_ELEMENT	int
,	O
20	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"ARCCTRREV"	pointer
)	O
;	O
else	O
_cgm_emit_command_header	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_GRAPHICAL_PRIMITIVE_ELEMENT	int
,	O
15	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"ARCCTR"	pointer
)	O
;	O
_cgm_emit_point	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
xarray	pointer
[	O
i	int
+	O
1	int
]	O
.	O
pc	struct
.	O
x	double
,	O
xarray	pointer
[	O
i	int
+	O
1	int
]	O
.	O
pc	struct
.	O
y	double
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_point	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
delta0_x	int
,	O
delta0_y	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_point	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
delta1_x	int
,	O
delta1_y	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_integer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
i_radius	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
primitives_emitted	int
++	O
;	O
if	O
(	O
reversed	enum
)	O
_plotter	pointer
->	O
cgm_page_version	int
=	O
IMAX	O
(	O
2	int
,	O
_plotter	pointer
->	O
cgm_page_version	int
)	O
;	O
}	O
i	int
++	O
;	O
break	O
;	O
case	O
(	O
int	O
)	O
S_ELLARC	int
:	O
{	O
data_len	int
=	O
5	int
*	O
2	int
*	O
CGM_BINARY_BYTES_PER_INTEGER	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_GRAPHICAL_PRIMITIVE_ELEMENT	int
,	O
18	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"ELLIPARC"	pointer
)	O
;	O
_cgm_emit_point	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
xarray	pointer
[	O
i	int
+	O
1	int
]	O
.	O
pc	struct
.	O
x	double
,	O
xarray	pointer
[	O
i	int
+	O
1	int
]	O
.	O
pc	struct
.	O
y	double
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_point	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
xarray	pointer
[	O
i	int
]	O
.	O
p	struct
.	O
x	double
,	O
xarray	pointer
[	O
i	int
]	O
.	O
p	struct
.	O
y	double
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_point	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
xarray	pointer
[	O
i	int
+	O
1	int
]	O
.	O
p	struct
.	O
x	double
,	O
xarray	pointer
[	O
i	int
+	O
1	int
]	O
.	O
p	struct
.	O
y	double
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_point	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
xarray	pointer
[	O
i	int
]	O
.	O
p	struct
.	O
x	double
-	O
xarray	pointer
[	O
i	int
+	O
1	int
]	O
.	O
pc	struct
.	O
x	double
,	O
xarray	pointer
[	O
i	int
]	O
.	O
p	struct
.	O
y	double
-	O
xarray	pointer
[	O
i	int
+	O
1	int
]	O
.	O
pc	struct
.	O
y	double
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_point	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
xarray	pointer
[	O
i	int
+	O
1	int
]	O
.	O
p	struct
.	O
x	double
-	O
xarray	pointer
[	O
i	int
+	O
1	int
]	O
.	O
pc	struct
.	O
x	double
,	O
xarray	pointer
[	O
i	int
+	O
1	int
]	O
.	O
p	struct
.	O
y	double
-	O
xarray	pointer
[	O
i	int
+	O
1	int
]	O
.	O
pc	struct
.	O
y	double
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
primitives_emitted	int
++	O
;	O
}	O
i	int
++	O
;	O
break	O
;	O
case	O
(	O
int	O
)	O
S_CUBIC	int
:	O
{	O
if	O
(	O
1	int
+	O
3	int
*	O
(	O
end_of_run	int
-	O
i	int
)	O
>	O
4096	int
)	O
_plotter	pointer
->	O
cgm_page_profile	int
=	O
IMAX	O
(	O
_plotter	pointer
->	O
cgm_page_profile	int
,	O
CGM_PROFILE_NONE	int
)	O
;	O
data_len	int
=	O
2	int
+	O
(	O
2	int
*	O
CGM_BINARY_BYTES_PER_INTEGER	int
)	O
*	O
(	O
1	int
+	O
3	int
*	O
(	O
end_of_run	int
-	O
i	int
)	O
)	O
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_GRAPHICAL_PRIMITIVE_ELEMENT	int
,	O
26	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"POLYBEZIER"	pointer
)	O
;	O
_cgm_emit_index	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
(	O
end_of_run	int
-	O
i	int
>	O
1	int
?	O
2	int
:	O
2	int
)	O
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_point	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
xarray	pointer
[	O
i	int
]	O
.	O
p	struct
.	O
x	double
,	O
xarray	pointer
[	O
i	int
]	O
.	O
p	struct
.	O
y	double
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
i	int
++	O
;	O
for	O
(	O
;	O
i	int
<=	O
end_of_run	int
;	O
i	int
++	O
)	O
{	O
_cgm_emit_point	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
xarray	pointer
[	O
i	int
]	O
.	O
pc	struct
.	O
x	double
,	O
xarray	pointer
[	O
i	int
]	O
.	O
pc	struct
.	O
y	double
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_point	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
xarray	pointer
[	O
i	int
]	O
.	O
pd	struct
.	O
x	double
,	O
xarray	pointer
[	O
i	int
]	O
.	O
pd	struct
.	O
y	double
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_point	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
xarray	pointer
[	O
i	int
]	O
.	O
p	struct
.	O
x	double
,	O
xarray	pointer
[	O
i	int
]	O
.	O
p	struct
.	O
y	double
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
}	O
_cgm_emit_command_terminator	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
primitives_emitted	int
++	O
;	O
_plotter	pointer
->	O
cgm_page_version	int
=	O
IMAX	O
(	O
3	int
,	O
_plotter	pointer
->	O
cgm_page_version	int
)	O
;	O
i	int
--	O
;	O
}	O
break	O
;	O
default	O
:	O
i	int
++	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
pass	int
==	O
0	int
&&	O
!	O
path_is_single_polyline	enum
)	O
{	O
data_len	int
=	O
0	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_DELIMITER_ELEMENT	int
,	O
9	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"ENDFIGURE"	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
_plotter	pointer
->	O
cgm_page_version	int
=	O
IMAX	O
(	O
2	int
,	O
_plotter	pointer
->	O
cgm_page_version	int
)	O
;	O
if	O
(	O
primitives_emitted	int
>	O
128	int
)	O
_plotter	pointer
->	O
cgm_page_profile	int
=	O
IMAX	O
(	O
_plotter	pointer
->	O
cgm_page_profile	int
,	O
CGM_PROFILE_NONE	int
)	O
;	O
}	O
if	O
(	O
pass	int
==	O
1	int
&&	O
draw_as_cgm_compound	enum
)	O
{	O
data_len	int
=	O
0	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_DELIMITER_ELEMENT	int
,	O
16	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"ENDCOMPOLINE"	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
_plotter	pointer
->	O
cgm_page_version	int
=	O
IMAX	O
(	O
3	int
,	O
_plotter	pointer
->	O
cgm_page_version	int
)	O
;	O
if	O
(	O
primitives_emitted	int
>	O
128	int
)	O
_plotter	pointer
->	O
cgm_page_profile	int
=	O
IMAX	O
(	O
_plotter	pointer
->	O
cgm_page_profile	int
,	O
CGM_PROFILE_NONE	int
)	O
;	O
}	O
}	O
free	function
(	O
xarray	pointer
)	O
;	O
}	O
break	O
;	O
case	O
(	O
int	O
)	O
PATH_BOX	int
:	O
{	O
plPoint	struct
p0	struct
,	O
p1	struct
;	O
int	O
xd0	int
,	O
xd1	int
,	O
yd0	int
,	O
yd1	int
;	O
int	O
byte_count	pointer
,	O
data_byte_count	pointer
,	O
data_len	int
;	O
int	O
desired_interior_style	int
;	O
const	O
char	O
*	O
desired_interior_style_string	pointer
;	O
p0	struct
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
p0	struct
;	O
p1	struct
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
p1	struct
;	O
xd0	int
=	O
IROUND	O
(	O
XD	O
(	O
p0	struct
.	O
x	double
,	O
p0	struct
.	O
y	double
)	O
)	O
;	O
yd0	int
=	O
IROUND	O
(	O
YD	O
(	O
p0	struct
.	O
x	double
,	O
p0	struct
.	O
y	double
)	O
)	O
;	O
xd1	int
=	O
IROUND	O
(	O
XD	O
(	O
p1	struct
.	O
x	double
,	O
p1	struct
.	O
y	double
)	O
)	O
;	O
yd1	int
=	O
IROUND	O
(	O
YD	O
(	O
p1	struct
.	O
x	double
,	O
p1	struct
.	O
y	double
)	O
)	O
;	O
_pl_c_set_pen_color	function
(	O
R___	O
(	O
_plotter	pointer
)	O
CGM_OBJECT_CLOSED	int
)	O
;	O
_pl_c_set_fill_color	function
(	O
R___	O
(	O
_plotter	pointer
)	O
CGM_OBJECT_CLOSED	int
)	O
;	O
_pl_c_set_attributes	function
(	O
R___	O
(	O
_plotter	pointer
)	O
CGM_OBJECT_CLOSED	int
)	O
;	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fill_type	int
==	O
0	int
)	O
{	O
desired_interior_style	int
=	O
CGM_INT_STYLE_EMPTY	int
;	O
desired_interior_style_string	pointer
=	O
"empty"	pointer
;	O
}	O
else	O
{	O
desired_interior_style	int
=	O
CGM_INT_STYLE_SOLID	int
;	O
desired_interior_style_string	pointer
=	O
"solid"	pointer
;	O
}	O
if	O
(	O
_plotter	pointer
->	O
cgm_interior_style	int
!=	O
desired_interior_style	int
)	O
{	O
data_len	int
=	O
2	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_ATTRIBUTE_ELEMENT	int
,	O
22	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"INTSTYLE"	pointer
)	O
;	O
_cgm_emit_enum	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
desired_interior_style	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
,	O
desired_interior_style_string	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
_plotter	pointer
->	O
cgm_interior_style	int
=	O
desired_interior_style	int
;	O
}	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pen_type	int
)	O
{	O
if	O
(	O
_plotter	pointer
->	O
cgm_edge_is_visible	enum
!=	O
true	int
)	O
{	O
data_len	int
=	O
2	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_ATTRIBUTE_ELEMENT	int
,	O
30	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"EDGEVIS"	pointer
)	O
;	O
_cgm_emit_enum	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
1	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
,	O
"on"	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
_plotter	pointer
->	O
cgm_edge_is_visible	enum
=	O
true	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
_plotter	pointer
->	O
cgm_edge_is_visible	enum
!=	O
false	int
)	O
{	O
data_len	int
=	O
2	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_ATTRIBUTE_ELEMENT	int
,	O
30	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"EDGEVIS"	pointer
)	O
;	O
_cgm_emit_enum	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
0	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
,	O
"off"	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
_plotter	pointer
->	O
cgm_edge_is_visible	enum
=	O
false	int
;	O
}	O
}	O
{	O
data_len	int
=	O
2	int
*	O
2	int
*	O
CGM_BINARY_BYTES_PER_INTEGER	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_GRAPHICAL_PRIMITIVE_ELEMENT	int
,	O
11	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"RECT"	pointer
)	O
;	O
_cgm_emit_point	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
xd0	int
,	O
yd0	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_point	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
xd1	int
,	O
yd1	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
}	O
}	O
break	O
;	O
case	O
(	O
int	O
)	O
PATH_CIRCLE	int
:	O
{	O
double	O
xd	double
,	O
yd	double
,	O
radius_d	double
;	O
int	O
i_x	int
,	O
i_y	int
,	O
i_radius	int
;	O
plPoint	struct
pc	struct
;	O
double	O
radius	double
;	O
int	O
byte_count	pointer
,	O
data_byte_count	pointer
,	O
data_len	int
;	O
int	O
desired_interior_style	int
;	O
const	O
char	O
*	O
desired_interior_style_string	pointer
;	O
pc	struct
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
pc	struct
;	O
radius	double
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
radius	double
;	O
xd	double
=	O
XD	O
(	O
pc	struct
.	O
x	double
,	O
pc	struct
.	O
y	double
)	O
;	O
yd	double
=	O
YD	O
(	O
pc	struct
.	O
x	double
,	O
pc	struct
.	O
y	double
)	O
;	O
radius_d	double
=	O
sqrt	function
(	O
XDV	O
(	O
radius	double
,	O
0	int
)	O
*	O
XDV	O
(	O
radius	double
,	O
0	int
)	O
+	O
YDV	O
(	O
radius	double
,	O
0	int
)	O
*	O
YDV	O
(	O
radius	double
,	O
0	int
)	O
)	O
;	O
i_x	int
=	O
IROUND	O
(	O
xd	double
)	O
;	O
i_y	int
=	O
IROUND	O
(	O
yd	double
)	O
;	O
i_radius	int
=	O
IROUND	O
(	O
radius_d	double
)	O
;	O
_pl_c_set_pen_color	function
(	O
R___	O
(	O
_plotter	pointer
)	O
CGM_OBJECT_CLOSED	int
)	O
;	O
_pl_c_set_fill_color	function
(	O
R___	O
(	O
_plotter	pointer
)	O
CGM_OBJECT_CLOSED	int
)	O
;	O
_pl_c_set_attributes	function
(	O
R___	O
(	O
_plotter	pointer
)	O
CGM_OBJECT_CLOSED	int
)	O
;	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fill_type	int
==	O
0	int
)	O
{	O
desired_interior_style	int
=	O
CGM_INT_STYLE_EMPTY	int
;	O
desired_interior_style_string	pointer
=	O
"empty"	pointer
;	O
}	O
else	O
{	O
desired_interior_style	int
=	O
CGM_INT_STYLE_SOLID	int
;	O
desired_interior_style_string	pointer
=	O
"solid"	pointer
;	O
}	O
if	O
(	O
_plotter	pointer
->	O
cgm_interior_style	int
!=	O
desired_interior_style	int
)	O
{	O
data_len	int
=	O
2	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_ATTRIBUTE_ELEMENT	int
,	O
22	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"INTSTYLE"	pointer
)	O
;	O
_cgm_emit_enum	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
desired_interior_style	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
,	O
desired_interior_style_string	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
_plotter	pointer
->	O
cgm_interior_style	int
=	O
desired_interior_style	int
;	O
}	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pen_type	int
)	O
{	O
if	O
(	O
_plotter	pointer
->	O
cgm_edge_is_visible	enum
!=	O
true	int
)	O
{	O
data_len	int
=	O
2	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_ATTRIBUTE_ELEMENT	int
,	O
30	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"EDGEVIS"	pointer
)	O
;	O
_cgm_emit_enum	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
1	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
,	O
"on"	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
_plotter	pointer
->	O
cgm_edge_is_visible	enum
=	O
true	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
_plotter	pointer
->	O
cgm_edge_is_visible	enum
!=	O
false	int
)	O
{	O
data_len	int
=	O
2	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_ATTRIBUTE_ELEMENT	int
,	O
30	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"EDGEVIS"	pointer
)	O
;	O
_cgm_emit_enum	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
0	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
,	O
"off"	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
_plotter	pointer
->	O
cgm_edge_is_visible	enum
=	O
false	int
;	O
}	O
}	O
{	O
data_len	int
=	O
3	int
*	O
CGM_BINARY_BYTES_PER_INTEGER	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_GRAPHICAL_PRIMITIVE_ELEMENT	int
,	O
12	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"CIRCLE"	pointer
)	O
;	O
_cgm_emit_point	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
i_x	int
,	O
i_y	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_integer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
i_radius	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
}	O
}	O
break	O
;	O
case	O
(	O
int	O
)	O
PATH_ELLIPSE	int
:	O
{	O
double	O
xd	double
,	O
yd	double
;	O
int	O
i_x	int
,	O
i_y	int
;	O
double	O
theta	double
,	O
costheta	double
,	O
sintheta	double
;	O
double	O
cd1_endpoint_x	double
,	O
cd1_endpoint_y	double
;	O
double	O
cd2_endpoint_x	double
,	O
cd2_endpoint_y	double
;	O
int	O
i1_x	int
,	O
i1_y	int
,	O
i2_x	int
,	O
i2_y	int
;	O
plPoint	struct
pc	struct
;	O
double	O
rx	double
,	O
ry	double
,	O
angle	double
;	O
int	O
byte_count	pointer
,	O
data_byte_count	pointer
,	O
data_len	int
;	O
int	O
desired_interior_style	int
;	O
const	O
char	O
*	O
desired_interior_style_string	pointer
;	O
pc	struct
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
pc	struct
;	O
rx	double
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
rx	double
;	O
ry	double
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
ry	double
;	O
angle	double
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
angle	double
;	O
xd	double
=	O
XD	O
(	O
pc	struct
.	O
x	double
,	O
pc	struct
.	O
y	double
)	O
;	O
yd	double
=	O
YD	O
(	O
pc	struct
.	O
x	double
,	O
pc	struct
.	O
y	double
)	O
;	O
i_x	int
=	O
IROUND	O
(	O
xd	double
)	O
;	O
i_y	int
=	O
IROUND	O
(	O
yd	double
)	O
;	O
theta	double
=	O
M_PI	int
*	O
angle	double
/	O
180.0	int
;	O
costheta	double
=	O
cos	function
(	O
theta	double
)	O
;	O
sintheta	double
=	O
sin	function
(	O
theta	double
)	O
;	O
cd1_endpoint_x	double
=	O
XD	O
(	O
pc	struct
.	O
x	double
+	O
rx	double
*	O
costheta	double
,	O
pc	struct
.	O
y	double
+	O
rx	double
*	O
sintheta	double
)	O
;	O
cd1_endpoint_y	double
=	O
YD	O
(	O
pc	struct
.	O
x	double
+	O
rx	double
*	O
costheta	double
,	O
pc	struct
.	O
y	double
+	O
rx	double
*	O
sintheta	double
)	O
;	O
cd2_endpoint_x	double
=	O
XD	O
(	O
pc	struct
.	O
x	double
-	O
ry	double
*	O
sintheta	double
,	O
pc	struct
.	O
y	double
+	O
ry	double
*	O
costheta	double
)	O
;	O
cd2_endpoint_y	double
=	O
YD	O
(	O
pc	struct
.	O
x	double
-	O
ry	double
*	O
sintheta	double
,	O
pc	struct
.	O
y	double
+	O
ry	double
*	O
costheta	double
)	O
;	O
i1_x	int
=	O
IROUND	O
(	O
cd1_endpoint_x	double
)	O
;	O
i1_y	int
=	O
IROUND	O
(	O
cd1_endpoint_y	double
)	O
;	O
i2_x	int
=	O
IROUND	O
(	O
cd2_endpoint_x	double
)	O
;	O
i2_y	int
=	O
IROUND	O
(	O
cd2_endpoint_y	double
)	O
;	O
_pl_c_set_pen_color	function
(	O
R___	O
(	O
_plotter	pointer
)	O
CGM_OBJECT_CLOSED	int
)	O
;	O
_pl_c_set_fill_color	function
(	O
R___	O
(	O
_plotter	pointer
)	O
CGM_OBJECT_CLOSED	int
)	O
;	O
_pl_c_set_attributes	function
(	O
R___	O
(	O
_plotter	pointer
)	O
CGM_OBJECT_CLOSED	int
)	O
;	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fill_type	int
==	O
0	int
)	O
{	O
desired_interior_style	int
=	O
CGM_INT_STYLE_EMPTY	int
;	O
desired_interior_style_string	pointer
=	O
"empty"	pointer
;	O
}	O
else	O
{	O
desired_interior_style	int
=	O
CGM_INT_STYLE_SOLID	int
;	O
desired_interior_style_string	pointer
=	O
"solid"	pointer
;	O
}	O
if	O
(	O
_plotter	pointer
->	O
cgm_interior_style	int
!=	O
desired_interior_style	int
)	O
{	O
data_len	int
=	O
2	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_ATTRIBUTE_ELEMENT	int
,	O
22	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"INTSTYLE"	pointer
)	O
;	O
_cgm_emit_enum	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
desired_interior_style	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
,	O
desired_interior_style_string	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
_plotter	pointer
->	O
cgm_interior_style	int
=	O
desired_interior_style	int
;	O
}	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pen_type	int
)	O
{	O
if	O
(	O
_plotter	pointer
->	O
cgm_edge_is_visible	enum
!=	O
true	int
)	O
{	O
data_len	int
=	O
2	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_ATTRIBUTE_ELEMENT	int
,	O
30	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"EDGEVIS"	pointer
)	O
;	O
_cgm_emit_enum	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
1	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
,	O
"on"	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
_plotter	pointer
->	O
cgm_edge_is_visible	enum
=	O
true	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
_plotter	pointer
->	O
cgm_edge_is_visible	enum
!=	O
false	int
)	O
{	O
data_len	int
=	O
2	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_ATTRIBUTE_ELEMENT	int
,	O
30	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"EDGEVIS"	pointer
)	O
;	O
_cgm_emit_enum	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
0	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
,	O
"off"	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
_plotter	pointer
->	O
cgm_edge_is_visible	enum
=	O
false	int
;	O
}	O
}	O
{	O
data_len	int
=	O
3	int
*	O
2	int
*	O
CGM_BINARY_BYTES_PER_INTEGER	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_GRAPHICAL_PRIMITIVE_ELEMENT	int
,	O
17	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"ELLIPSE"	pointer
)	O
;	O
_cgm_emit_point	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
i_x	int
,	O
i_y	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_point	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
i1_x	int
,	O
i1_y	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_point	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
i2_x	int
,	O
i2_y	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
}	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
bool	enum
_pl_c_paint_paths	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
return	O
false	int
;	O
}	O
