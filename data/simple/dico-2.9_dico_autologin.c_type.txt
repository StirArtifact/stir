char	O
*	O
skipws	function
(	O
char	O
*	O
buf	pointer
)	O
{	O
while	O
(	O
*	O
buf	pointer
&&	O
isascii	function
(	O
*	O
buf	pointer
)	O
&&	O
isspace	function
(	O
*	O
buf	pointer
)	O
)	O
buf	pointer
++	O
;	O
return	O
buf	pointer
;	O
}	O
int	O
hostcmp	function
(	O
const	O
char	O
*	O
a	pointer
,	O
const	O
char	O
*	O
b	pointer
)	O
{	O
struct	O
hostent	struct
*	O
hp	pointer
=	O
gethostbyname	function
(	O
a	pointer
)	O
;	O
char	O
*	O
*	O
addrlist	pointer
;	O
char	O
*	O
dptr	pointer
;	O
char	O
*	O
*	O
addr	pointer
;	O
size_t	long
i	long
,	O
count	long
;	O
size_t	long
entry_length	long
;	O
int	O
entry_type	int
;	O
if	O
(	O
!	O
hp	pointer
)	O
return	O
1	int
;	O
for	O
(	O
count	long
=	O
1	int
,	O
addr	pointer
=	O
hp	pointer
->	O
h_addr_list	pointer
;	O
*	O
addr	pointer
;	O
addr	pointer
++	O
)	O
count	long
++	O
;	O
addrlist	pointer
=	O
xmalloc	function
(	O
count	long
*	O
(	O
sizeof	O
*	O
addrlist	pointer
+	O
hp	pointer
->	O
h_length	int
)	O
-	O
hp	pointer
->	O
h_length	int
)	O
;	O
dptr	pointer
=	O
(	O
char	O
*	O
)	O
(	O
addrlist	pointer
+	O
count	long
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
count	long
-	O
1	int
;	O
i	long
++	O
)	O
{	O
memcpy	function
(	O
dptr	pointer
,	O
hp	pointer
->	O
h_addr_list	pointer
[	O
i	long
]	O
,	O
hp	pointer
->	O
h_length	int
)	O
;	O
addrlist	pointer
[	O
i	long
]	O
=	O
dptr	pointer
;	O
dptr	pointer
+=	O
hp	pointer
->	O
h_length	int
;	O
}	O
addrlist	pointer
[	O
i	long
]	O
=	O
NULL	O
;	O
entry_length	long
=	O
hp	pointer
->	O
h_length	int
;	O
entry_type	int
=	O
hp	pointer
->	O
h_addrtype	int
;	O
hp	pointer
=	O
gethostbyname	function
(	O
b	pointer
)	O
;	O
if	O
(	O
!	O
hp	pointer
||	O
entry_length	long
!=	O
hp	pointer
->	O
h_length	int
||	O
entry_type	int
!=	O
hp	pointer
->	O
h_addrtype	int
)	O
{	O
free	function
(	O
addrlist	pointer
)	O
;	O
return	O
1	int
;	O
}	O
for	O
(	O
addr	pointer
=	O
addrlist	pointer
;	O
*	O
addr	pointer
;	O
addr	pointer
++	O
)	O
{	O
char	O
*	O
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
hp	pointer
->	O
h_addr_list	pointer
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
{	O
if	O
(	O
memcmp	function
(	O
*	O
addr	pointer
,	O
*	O
p	pointer
,	O
entry_length	long
)	O
==	O
0	int
)	O
{	O
free	function
(	O
addrlist	pointer
)	O
;	O
return	O
0	int
;	O
}	O
}	O
}	O
free	function
(	O
addrlist	pointer
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
begins_with	function
(	O
const	O
char	O
*	O
str	pointer
,	O
const	O
char	O
*	O
prefix	array
)	O
{	O
size_t	long
len	long
=	O
strlen	function
(	O
prefix	array
)	O
;	O
return	O
strlen	function
(	O
str	pointer
)	O
>=	O
len	long
&&	O
strncmp	function
(	O
str	pointer
,	O
prefix	array
,	O
len	long
)	O
==	O
0	int
&&	O
(	O
str	pointer
[	O
len	long
]	O
==	O
0	int
||	O
str	pointer
[	O
len	long
]	O
==	O
' '	O
||	O
str	pointer
[	O
len	long
]	O
==	O
'\t'	O
)	O
;	O
}	O
enum	O
kw_tok	enum
{	O
kw_login	int
,	O
kw_password	int
,	O
kw_noauth	int
,	O
kw_nosasl	int
,	O
kw_sasl	int
,	O
kw_mechanism	int
,	O
kw_realm	int
,	O
kw_service	int
,	O
kw_host	int
}	O
;	O
struct	O
keyword	struct
{	O
char	O
*	O
name	pointer
;	O
int	O
arg	pointer
;	O
enum	O
kw_tok	enum
tok	enum
;	O
}	O
;	O
static	O
struct	O
keyword	struct
kwtab	array
[	O
]	O
=	O
{	O
{	O
"login"	pointer
,	O
1	int
,	O
kw_login	int
}	O
,	O
{	O
"password"	pointer
,	O
1	int
,	O
kw_password	int
}	O
,	O
{	O
"noauth"	pointer
,	O
0	int
,	O
kw_noauth	int
}	O
,	O
{	O
"nosasl"	pointer
,	O
0	int
,	O
kw_nosasl	int
}	O
,	O
{	O
"sasl"	pointer
,	O
0	int
,	O
kw_sasl	int
}	O
,	O
{	O
"mechanism"	pointer
,	O
1	int
,	O
kw_mechanism	int
}	O
,	O
{	O
"realm"	pointer
,	O
1	int
,	O
kw_realm	int
}	O
,	O
{	O
"service"	pointer
,	O
1	int
,	O
kw_service	int
}	O
,	O
{	O
"host"	pointer
,	O
1	int
,	O
kw_host	int
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
struct	O
keyword	struct
*	O
findkw	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
keyword	struct
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
kwtab	array
;	O
p	pointer
->	O
name	pointer
;	O
p	pointer
++	O
)	O
if	O
(	O
strcmp	function
(	O
p	pointer
->	O
name	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
return	O
p	pointer
;	O
return	O
NULL	O
;	O
}	O
static	O
int	O
_cred_free	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
free	function
(	O
item	pointer
)	O
;	O
return	O
0	int
;	O
}	O
struct	O
matches	struct
{	O
const	O
char	O
*	O
host	pointer
;	O
int	O
def_line	int
;	O
int	O
def_argc	int
;	O
char	O
*	O
*	O
def_argv	pointer
;	O
int	O
host_argc	int
;	O
char	O
*	O
*	O
host_argv	pointer
;	O
}	O
;	O
static	O
int	O
match_line	function
(	O
struct	O
wordsplit	struct
*	O
ws	pointer
,	O
struct	O
matches	struct
*	O
matches	struct
,	O
int	O
line	int
)	O
{	O
int	O
rc	int
=	O
0	int
;	O
if	O
(	O
strcmp	function
(	O
ws	pointer
->	O
ws_wordv	pointer
[	O
0	int
]	O
,	O
"machine"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
hostcmp	function
(	O
ws	pointer
->	O
ws_wordv	pointer
[	O
1	int
]	O
,	O
matches	struct
->	O
host	pointer
)	O
==	O
0	int
)	O
{	O
XDICO_DEBUG_F1	O
(	O
1	int
,	O
_	O
(	O
"Found matching line %d\n"	pointer
)	O
,	O
line	int
)	O
;	O
if	O
(	O
matches	struct
->	O
host_argv	pointer
)	O
dico_argcv_free	function
(	O
matches	struct
->	O
host_argc	int
,	O
matches	struct
->	O
host_argv	pointer
)	O
;	O
matches	struct
->	O
host_argc	int
=	O
ws	pointer
->	O
ws_wordc	long
;	O
matches	struct
->	O
host_argv	pointer
=	O
ws	pointer
->	O
ws_wordv	pointer
;	O
matches	struct
->	O
def_line	int
=	O
line	int
;	O
rc	int
=	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
ws	pointer
->	O
ws_wordv	pointer
[	O
0	int
]	O
,	O
"default"	pointer
)	O
==	O
0	int
)	O
{	O
XDICO_DEBUG_F1	O
(	O
1	int
,	O
_	O
(	O
"Found default line %d\n"	pointer
)	O
,	O
line	int
)	O
;	O
if	O
(	O
matches	struct
->	O
def_argv	pointer
)	O
dico_argcv_free	function
(	O
matches	struct
->	O
def_argc	int
,	O
matches	struct
->	O
def_argv	pointer
)	O
;	O
matches	struct
->	O
def_argc	int
=	O
ws	pointer
->	O
ws_wordc	long
;	O
matches	struct
->	O
def_argv	pointer
=	O
ws	pointer
->	O
ws_wordv	pointer
;	O
matches	struct
->	O
def_line	int
=	O
line	int
;	O
}	O
ws	pointer
->	O
ws_wordc	long
=	O
0	int
;	O
ws	pointer
->	O
ws_wordv	pointer
=	O
NULL	O
;	O
return	O
rc	int
;	O
}	O
int	O
parse_autologin	function
(	O
const	O
char	O
*	O
filename	pointer
,	O
char	O
*	O
host	pointer
,	O
struct	O
auth_cred	struct
*	O
pcred	pointer
,	O
int	O
*	O
pflags	pointer
)	O
{	O
FILE	struct
*	O
fp	pointer
;	O
char	O
*	O
buf	pointer
=	O
NULL	O
;	O
size_t	long
n	long
=	O
0	int
;	O
struct	O
matches	struct
matches	struct
;	O
char	O
*	O
*	O
p_argv	pointer
=	O
NULL	O
;	O
int	O
line	int
=	O
0	int
;	O
int	O
flags	int
=	O
0	int
;	O
struct	O
wordsplit	struct
ws	pointer
;	O
int	O
wsflags	int
=	O
0	int
;	O
int	O
beg_line	int
=	O
0	int
;	O
fp	pointer
=	O
fopen	function
(	O
filename	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
!	O
fp	pointer
)	O
{	O
if	O
(	O
errno	O
!=	O
ENOENT	int
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
errno	O
,	O
_	O
(	O
"Cannot open autologin file %s"	pointer
)	O
,	O
filename	pointer
)	O
;	O
}	O
return	O
1	int
;	O
}	O
else	O
XDICO_DEBUG_F1	O
(	O
1	int
,	O
_	O
(	O
"Reading autologin file %s...\n"	pointer
)	O
,	O
filename	pointer
)	O
;	O
memset	function
(	O
&	O
matches	struct
,	O
0	int
,	O
sizeof	O
matches	struct
)	O
;	O
matches	struct
.	O
host	pointer
=	O
host	pointer
;	O
while	O
(	O
getline	function
(	O
&	O
buf	pointer
,	O
&	O
n	long
,	O
fp	pointer
)	O
>	O
0	int
&&	O
n	long
>	O
0	int
)	O
{	O
char	O
*	O
p	pointer
;	O
line	int
++	O
;	O
p	pointer
=	O
skipws	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
(	O
wsflags	int
&	O
WRDSF_APPEND	int
)	O
&&	O
(	O
begins_with	function
(	O
p	pointer
,	O
"machine"	pointer
)	O
||	O
begins_with	function
(	O
p	pointer
,	O
"default"	pointer
)	O
)	O
)	O
{	O
wsflags	int
&=	O
~	O
WRDSF_APPEND	int
;	O
if	O
(	O
match_line	function
(	O
&	O
ws	pointer
,	O
&	O
matches	struct
,	O
beg_line	int
)	O
)	O
break	O
;	O
beg_line	int
=	O
line	int
;	O
}	O
else	O
if	O
(	O
!	O
(	O
wsflags	int
&	O
WRDSF_REUSE	int
)	O
)	O
beg_line	int
=	O
line	int
;	O
ws	pointer
.	O
ws_comment	pointer
=	O
"#"	pointer
;	O
if	O
(	O
wordsplit	struct
(	O
p	pointer
,	O
&	O
ws	pointer
,	O
WRDSF_DEFFLAGS	O
|	O
WRDSF_COMMENT	int
|	O
wsflags	int
)	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"failed to parse command `%s': %s"	pointer
)	O
,	O
p	pointer
,	O
wordsplit_strerror	function
(	O
&	O
ws	pointer
)	O
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
free	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
wsflags	int
&	O
WRDSF_REUSE	int
)	O
wordsplit_free	function
(	O
&	O
ws	pointer
)	O
;	O
return	O
1	int
;	O
}	O
wsflags	int
|=	O
WRDSF_REUSE	int
|	O
WRDSF_APPEND	int
;	O
if	O
(	O
wordsplit	struct
(	O
"#"	pointer
,	O
&	O
ws	pointer
,	O
WRDSF_DEFFLAGS	O
|	O
WRDSF_NOSPLIT	int
|	O
wsflags	int
)	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"failed to add line marker: %s"	pointer
)	O
,	O
wordsplit_strerror	function
(	O
&	O
ws	pointer
)	O
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
free	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
wsflags	int
&	O
WRDSF_REUSE	int
)	O
wordsplit_free	function
(	O
&	O
ws	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
if	O
(	O
wsflags	int
&	O
WRDSF_APPEND	int
)	O
match_line	function
(	O
&	O
ws	pointer
,	O
&	O
matches	struct
,	O
line	int
)	O
;	O
if	O
(	O
wsflags	int
&	O
WRDSF_REUSE	int
)	O
wordsplit_free	function
(	O
&	O
ws	pointer
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
free	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
matches	struct
.	O
host_argv	pointer
)	O
p_argv	pointer
=	O
matches	struct
.	O
host_argv	pointer
+	O
2	int
;	O
else	O
if	O
(	O
matches	struct
.	O
def_argv	pointer
)	O
p_argv	pointer
=	O
matches	struct
.	O
def_argv	pointer
+	O
1	int
;	O
else	O
{	O
XDICO_DEBUG	O
(	O
1	int
,	O
_	O
(	O
"No matching line found\n"	pointer
)	O
)	O
;	O
p_argv	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
p_argv	pointer
)	O
{	O
line	int
=	O
matches	struct
.	O
def_line	int
;	O
pcred	pointer
->	O
sasl	int
=	O
sasl_enabled_p	function
(	O
)	O
;	O
while	O
(	O
*	O
p_argv	pointer
)	O
{	O
if	O
(	O
*	O
*	O
p_argv	pointer
==	O
'#'	O
)	O
{	O
line	int
++	O
;	O
p_argv	pointer
++	O
;	O
}	O
else	O
{	O
struct	O
keyword	struct
*	O
kw	pointer
=	O
findkw	function
(	O
*	O
p_argv	pointer
)	O
;	O
char	O
*	O
arg	pointer
;	O
if	O
(	O
!	O
kw	pointer
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"%s:%d: unknown keyword"	pointer
)	O
,	O
filename	pointer
,	O
line	int
)	O
;	O
p_argv	pointer
++	O
;	O
continue	O
;	O
}	O
if	O
(	O
kw	pointer
->	O
arg	pointer
)	O
{	O
if	O
(	O
!	O
p_argv	pointer
[	O
1	int
]	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"%s:%d: %s without argument"	pointer
)	O
,	O
filename	pointer
,	O
line	int
,	O
p_argv	pointer
[	O
0	int
]	O
)	O
;	O
break	O
;	O
}	O
arg	pointer
=	O
p_argv	pointer
[	O
1	int
]	O
;	O
p_argv	pointer
+=	O
2	int
;	O
}	O
else	O
p_argv	pointer
++	O
;	O
switch	O
(	O
kw	pointer
->	O
tok	enum
)	O
{	O
case	O
kw_login	int
:	O
pcred	pointer
->	O
user	pointer
=	O
xstrdup	function
(	O
arg	pointer
)	O
;	O
flags	int
|=	O
AUTOLOGIN_USERNAME	int
;	O
break	O
;	O
case	O
kw_password	int
:	O
pcred	pointer
->	O
pass	pointer
=	O
xstrdup	function
(	O
arg	pointer
)	O
;	O
flags	int
|=	O
AUTOLOGIN_PASSWORD	int
;	O
break	O
;	O
case	O
kw_service	int
:	O
pcred	pointer
->	O
service	pointer
=	O
xstrdup	function
(	O
arg	pointer
)	O
;	O
break	O
;	O
case	O
kw_realm	int
:	O
pcred	pointer
->	O
realm	pointer
=	O
xstrdup	function
(	O
arg	pointer
)	O
;	O
break	O
;	O
case	O
kw_host	int
:	O
pcred	pointer
->	O
hostname	pointer
=	O
xstrdup	function
(	O
arg	pointer
)	O
;	O
break	O
;	O
case	O
kw_noauth	int
:	O
flags	int
|=	O
AUTOLOGIN_NOAUTH	int
;	O
break	O
;	O
case	O
kw_nosasl	int
:	O
pcred	pointer
->	O
sasl	int
=	O
0	int
;	O
break	O
;	O
case	O
kw_sasl	int
:	O
pcred	pointer
->	O
sasl	int
=	O
1	int
;	O
break	O
;	O
case	O
kw_mechanism	int
:	O
{	O
int	O
i	long
;	O
struct	O
wordsplit	struct
mechws	struct
;	O
if	O
(	O
!	O
(	O
flags	int
&	O
AUTOLOGIN_MECH	int
)	O
)	O
{	O
pcred	pointer
->	O
mech	pointer
=	O
xdico_list_create	function
(	O
)	O
;	O
dico_list_set_free_item	function
(	O
pcred	pointer
->	O
mech	pointer
,	O
_cred_free	function
,	O
NULL	O
)	O
;	O
flags	int
|=	O
AUTOLOGIN_MECH	int
;	O
}	O
mechws	struct
.	O
ws_delim	pointer
=	O
","	pointer
;	O
if	O
(	O
wordsplit	struct
(	O
arg	pointer
,	O
&	O
mechws	struct
,	O
WRDSF_NOVAR	int
|	O
WRDSF_NOCMD	int
|	O
WRDSF_DELIM	int
|	O
WRDSF_WS	int
)	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"%s:%d: failed to parse line: %s"	pointer
)	O
,	O
filename	pointer
,	O
line	int
,	O
wordsplit_strerror	function
(	O
&	O
mechws	struct
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
mechws	struct
.	O
ws_wordc	long
;	O
i	long
++	O
)	O
xdico_list_append	function
(	O
pcred	pointer
->	O
mech	pointer
,	O
mechws	struct
.	O
ws_wordv	pointer
[	O
i	long
]	O
)	O
;	O
mechws	struct
.	O
ws_wordc	long
=	O
0	int
;	O
wordsplit_free	function
(	O
&	O
mechws	struct
)	O
;	O
break	O
;	O
}	O
}	O
}	O
}	O
}	O
dico_argcv_free	function
(	O
matches	struct
.	O
def_argc	int
,	O
matches	struct
.	O
def_argv	pointer
)	O
;	O
dico_argcv_free	function
(	O
matches	struct
.	O
host_argc	int
,	O
matches	struct
.	O
host_argv	pointer
)	O
;	O
if	O
(	O
pflags	pointer
)	O
*	O
pflags	pointer
=	O
flags	int
;	O
return	O
0	int
;	O
}	O
