static	O
void	O
miFillArcSliceD	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
const	O
miArc	struct
*	O
arc	pointer
)	O
;	O
static	O
void	O
miFillArcSliceI	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
const	O
miArc	struct
*	O
arc	pointer
)	O
;	O
static	O
void	O
miFillEllipseD	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
const	O
miArc	struct
*	O
arc	pointer
)	O
;	O
static	O
void	O
miFillEllipseI	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
const	O
miArc	struct
*	O
arc	pointer
)	O
;	O
static	O
void	O
miEllipseAngleToSlope	function
(	O
int	O
angle	double
,	O
unsigned	O
int	O
width	array
,	O
unsigned	O
int	O
height	int
,	O
int	O
*	O
dxp	pointer
,	O
int	O
*	O
dyp	pointer
,	O
double	O
*	O
d_dxp	pointer
,	O
double	O
*	O
d_dyp	pointer
)	O
;	O
static	O
void	O
miFillArcDSetup	function
(	O
const	O
miArc	struct
*	O
arc	pointer
,	O
miFillArcD	struct
*	O
info	pointer
)	O
;	O
static	O
void	O
miFillArcSetup	function
(	O
const	O
miArc	struct
*	O
arc	pointer
,	O
miFillArc	struct
*	O
info	pointer
)	O
;	O
static	O
void	O
miFillArcSliceSetup	function
(	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
const	O
miArc	struct
*	O
arc	pointer
,	O
miArcSlice	struct
*	O
slice	pointer
)	O
;	O
static	O
void	O
miGetArcEdge	function
(	O
const	O
miArc	struct
*	O
arc	pointer
,	O
miSliceEdge	struct
*	O
edge	pointer
,	O
int	O
k	int
,	O
bool	enum
top	enum
,	O
bool	enum
left	enum
)	O
;	O
static	O
void	O
miGetPieEdge	function
(	O
const	O
miArc	struct
*	O
arc	pointer
,	O
int	O
angle	double
,	O
miSliceEdge	struct
*	O
edge	pointer
,	O
bool	enum
top	enum
,	O
bool	enum
left	enum
)	O
;	O
static	O
void	O
miFillArcSetup	function
(	O
const	O
miArc	struct
*	O
arc	pointer
,	O
miFillArc	struct
*	O
info	pointer
)	O
{	O
info	pointer
->	O
y	double
=	O
arc	pointer
->	O
height	int
>>	O
1	int
;	O
info	pointer
->	O
dy	int
=	O
arc	pointer
->	O
height	int
&	O
1	int
;	O
info	pointer
->	O
yorg	int
=	O
arc	pointer
->	O
y	double
+	O
info	pointer
->	O
y	double
;	O
info	pointer
->	O
dx	int
=	O
arc	pointer
->	O
width	array
&	O
1	int
;	O
info	pointer
->	O
xorg	int
=	O
arc	pointer
->	O
x	double
+	O
(	O
int	O
)	O
(	O
arc	pointer
->	O
width	array
>>	O
1	int
)	O
+	O
info	pointer
->	O
dx	int
;	O
info	pointer
->	O
dx	int
=	O
1	int
-	O
info	pointer
->	O
dx	int
;	O
if	O
(	O
arc	pointer
->	O
width	array
==	O
arc	pointer
->	O
height	int
)	O
{	O
info	pointer
->	O
ym	int
=	O
8	int
;	O
info	pointer
->	O
xm	int
=	O
8	int
;	O
info	pointer
->	O
yk	int
=	O
info	pointer
->	O
y	double
<<	O
3	int
;	O
if	O
(	O
!	O
info	pointer
->	O
dx	int
)	O
{	O
info	pointer
->	O
xk	int
=	O
0	int
;	O
info	pointer
->	O
e	int
=	O
-	O
1	int
;	O
}	O
else	O
{	O
info	pointer
->	O
y	double
++	O
;	O
info	pointer
->	O
yk	int
+=	O
4	int
;	O
info	pointer
->	O
xk	int
=	O
-	O
4	int
;	O
info	pointer
->	O
e	int
=	O
-	O
(	O
info	pointer
->	O
y	double
<<	O
3	int
)	O
;	O
}	O
}	O
else	O
{	O
info	pointer
->	O
ym	int
=	O
(	O
arc	pointer
->	O
width	array
*	O
arc	pointer
->	O
width	array
)	O
<<	O
3	int
;	O
info	pointer
->	O
xm	int
=	O
(	O
arc	pointer
->	O
height	int
*	O
arc	pointer
->	O
height	int
)	O
<<	O
3	int
;	O
info	pointer
->	O
yk	int
=	O
info	pointer
->	O
y	double
*	O
info	pointer
->	O
ym	int
;	O
if	O
(	O
!	O
info	pointer
->	O
dy	int
)	O
info	pointer
->	O
yk	int
-=	O
info	pointer
->	O
ym	int
>>	O
1	int
;	O
if	O
(	O
!	O
info	pointer
->	O
dx	int
)	O
{	O
info	pointer
->	O
xk	int
=	O
0	int
;	O
info	pointer
->	O
e	int
=	O
-	O
(	O
info	pointer
->	O
xm	int
>>	O
3	int
)	O
;	O
}	O
else	O
{	O
info	pointer
->	O
y	double
++	O
;	O
info	pointer
->	O
yk	int
+=	O
info	pointer
->	O
ym	int
;	O
info	pointer
->	O
xk	int
=	O
-	O
(	O
info	pointer
->	O
xm	int
>>	O
1	int
)	O
;	O
info	pointer
->	O
e	int
=	O
info	pointer
->	O
xk	int
-	O
info	pointer
->	O
yk	int
;	O
}	O
}	O
}	O
static	O
void	O
miFillArcDSetup	function
(	O
const	O
miArc	struct
*	O
arc	pointer
,	O
miFillArcD	struct
*	O
info	pointer
)	O
{	O
info	pointer
->	O
y	double
=	O
arc	pointer
->	O
height	int
>>	O
1	int
;	O
info	pointer
->	O
dy	int
=	O
arc	pointer
->	O
height	int
&	O
1	int
;	O
info	pointer
->	O
yorg	int
=	O
arc	pointer
->	O
y	double
+	O
info	pointer
->	O
y	double
;	O
info	pointer
->	O
dx	int
=	O
arc	pointer
->	O
width	array
&	O
1	int
;	O
info	pointer
->	O
xorg	int
=	O
arc	pointer
->	O
x	double
+	O
(	O
int	O
)	O
(	O
arc	pointer
->	O
width	array
>>	O
1	int
)	O
+	O
info	pointer
->	O
dx	int
;	O
info	pointer
->	O
dx	int
=	O
1	int
-	O
info	pointer
->	O
dx	int
;	O
info	pointer
->	O
ym	int
=	O
(	O
(	O
double	O
)	O
arc	pointer
->	O
width	array
)	O
*	O
(	O
arc	pointer
->	O
width	array
*	O
8	int
)	O
;	O
info	pointer
->	O
xm	int
=	O
(	O
(	O
double	O
)	O
arc	pointer
->	O
height	int
)	O
*	O
(	O
arc	pointer
->	O
height	int
*	O
8	int
)	O
;	O
info	pointer
->	O
yk	int
=	O
info	pointer
->	O
y	double
*	O
info	pointer
->	O
ym	int
;	O
if	O
(	O
!	O
info	pointer
->	O
dy	int
)	O
info	pointer
->	O
yk	int
-=	O
(	O
0.5	int
*	O
info	pointer
->	O
ym	int
)	O
;	O
if	O
(	O
!	O
info	pointer
->	O
dx	int
)	O
{	O
info	pointer
->	O
xk	int
=	O
0	int
;	O
info	pointer
->	O
e	int
=	O
-	O
(	O
0.125	int
*	O
info	pointer
->	O
xm	int
)	O
;	O
}	O
else	O
{	O
info	pointer
->	O
y	double
++	O
;	O
info	pointer
->	O
yk	int
+=	O
info	pointer
->	O
ym	int
;	O
info	pointer
->	O
xk	int
=	O
-	O
0.5	int
*	O
info	pointer
->	O
xm	int
;	O
info	pointer
->	O
e	int
=	O
info	pointer
->	O
xk	int
-	O
info	pointer
->	O
yk	int
;	O
}	O
}	O
static	O
void	O
miGetArcEdge	function
(	O
const	O
miArc	struct
*	O
arc	pointer
,	O
miSliceEdge	struct
*	O
edge	pointer
,	O
int	O
k	int
,	O
bool	enum
top	enum
,	O
bool	enum
left	enum
)	O
{	O
int	O
xady	int
,	O
y	double
;	O
y	double
=	O
arc	pointer
->	O
height	int
>>	O
1	int
;	O
if	O
(	O
(	O
arc	pointer
->	O
width	array
&	O
1	int
)	O
==	O
0	int
)	O
y	double
++	O
;	O
if	O
(	O
!	O
top	enum
)	O
{	O
y	double
=	O
-	O
y	double
;	O
if	O
(	O
arc	pointer
->	O
height	int
&	O
1	int
)	O
y	double
--	O
;	O
}	O
xady	int
=	O
k	int
+	O
y	double
*	O
edge	pointer
->	O
dx	int
;	O
if	O
(	O
xady	int
<=	O
0	int
)	O
edge	pointer
->	O
x	double
=	O
-	O
(	O
(	O
-	O
xady	int
)	O
/	O
edge	pointer
->	O
dy	int
+	O
1	int
)	O
;	O
else	O
edge	pointer
->	O
x	double
=	O
(	O
xady	int
-	O
1	int
)	O
/	O
edge	pointer
->	O
dy	int
;	O
edge	pointer
->	O
e	int
=	O
xady	int
-	O
edge	pointer
->	O
x	double
*	O
edge	pointer
->	O
dy	int
;	O
if	O
(	O
(	O
top	enum
&&	O
(	O
edge	pointer
->	O
dx	int
<	O
0	int
)	O
)	O
||	O
(	O
!	O
top	enum
&&	O
(	O
edge	pointer
->	O
dx	int
>	O
0	int
)	O
)	O
)	O
edge	pointer
->	O
e	int
=	O
edge	pointer
->	O
dy	int
-	O
edge	pointer
->	O
e	int
+	O
1	int
;	O
if	O
(	O
left	enum
)	O
edge	pointer
->	O
x	double
++	O
;	O
edge	pointer
->	O
x	double
+=	O
arc	pointer
->	O
x	double
+	O
(	O
int	O
)	O
(	O
arc	pointer
->	O
width	array
>>	O
1	int
)	O
;	O
if	O
(	O
edge	pointer
->	O
dx	int
>	O
0	int
)	O
{	O
edge	pointer
->	O
deltax	double
=	O
1	int
;	O
edge	pointer
->	O
stepx	int
=	O
edge	pointer
->	O
dx	int
/	O
edge	pointer
->	O
dy	int
;	O
edge	pointer
->	O
dx	int
=	O
edge	pointer
->	O
dx	int
%	O
edge	pointer
->	O
dy	int
;	O
}	O
else	O
{	O
edge	pointer
->	O
deltax	double
=	O
-	O
1	int
;	O
edge	pointer
->	O
stepx	int
=	O
-	O
(	O
(	O
-	O
edge	pointer
->	O
dx	int
)	O
/	O
edge	pointer
->	O
dy	int
)	O
;	O
edge	pointer
->	O
dx	int
=	O
(	O
-	O
edge	pointer
->	O
dx	int
)	O
%	O
edge	pointer
->	O
dy	int
;	O
}	O
if	O
(	O
!	O
top	enum
)	O
{	O
edge	pointer
->	O
deltax	double
=	O
-	O
edge	pointer
->	O
deltax	double
;	O
edge	pointer
->	O
stepx	int
=	O
-	O
edge	pointer
->	O
stepx	int
;	O
}	O
}	O
static	O
void	O
miEllipseAngleToSlope	function
(	O
int	O
angle	double
,	O
unsigned	O
int	O
width	array
,	O
unsigned	O
int	O
height	int
,	O
int	O
*	O
dxp	pointer
,	O
int	O
*	O
dyp	pointer
,	O
double	O
*	O
d_dxp	pointer
,	O
double	O
*	O
d_dyp	pointer
)	O
{	O
int	O
dx	int
,	O
dy	int
;	O
double	O
d_dx	double
,	O
d_dy	double
,	O
scale	double
;	O
bool	enum
negative_dx	enum
,	O
negative_dy	enum
;	O
switch	O
(	O
angle	double
)	O
{	O
case	O
0	int
:	O
*	O
dxp	pointer
=	O
-	O
1	int
;	O
*	O
dyp	pointer
=	O
0	int
;	O
if	O
(	O
d_dxp	pointer
)	O
{	O
*	O
d_dxp	pointer
=	O
0.5	int
*	O
(	O
int	O
)	O
width	array
;	O
*	O
d_dyp	pointer
=	O
0	int
;	O
}	O
break	O
;	O
case	O
QUADRANT	O
:	O
*	O
dxp	pointer
=	O
0	int
;	O
*	O
dyp	pointer
=	O
1	int
;	O
if	O
(	O
d_dxp	pointer
)	O
{	O
*	O
d_dxp	pointer
=	O
0	int
;	O
*	O
d_dyp	pointer
=	O
-	O
0.5	int
*	O
(	O
int	O
)	O
height	int
;	O
}	O
break	O
;	O
case	O
HALFCIRCLE	O
:	O
*	O
dxp	pointer
=	O
1	int
;	O
*	O
dyp	pointer
=	O
0	int
;	O
if	O
(	O
d_dxp	pointer
)	O
{	O
*	O
d_dxp	pointer
=	O
-	O
0.5	int
*	O
(	O
int	O
)	O
width	array
;	O
*	O
d_dyp	pointer
=	O
0	int
;	O
}	O
break	O
;	O
case	O
QUADRANT3	O
:	O
*	O
dxp	pointer
=	O
0	int
;	O
*	O
dyp	pointer
=	O
-	O
1	int
;	O
if	O
(	O
d_dxp	pointer
)	O
{	O
*	O
d_dxp	pointer
=	O
0	int
;	O
*	O
d_dyp	pointer
=	O
0.5	int
*	O
(	O
int	O
)	O
height	int
;	O
}	O
break	O
;	O
default	O
:	O
d_dx	double
=	O
Dcos	O
(	O
angle	double
)	O
*	O
(	O
int	O
)	O
width	array
;	O
d_dy	double
=	O
Dsin	O
(	O
angle	double
)	O
*	O
(	O
int	O
)	O
height	int
;	O
if	O
(	O
d_dxp	pointer
)	O
{	O
*	O
d_dxp	pointer
=	O
0.5	int
*	O
d_dx	double
;	O
*	O
d_dyp	pointer
=	O
-	O
0.5	int
*	O
d_dy	double
;	O
}	O
negative_dx	enum
=	O
false	int
;	O
if	O
(	O
d_dx	double
<	O
0.0	int
)	O
{	O
d_dx	double
=	O
-	O
d_dx	double
;	O
negative_dx	enum
=	O
true	int
;	O
}	O
negative_dy	enum
=	O
false	int
;	O
if	O
(	O
d_dy	double
<	O
0.0	int
)	O
{	O
d_dy	double
=	O
-	O
d_dy	double
;	O
negative_dy	enum
=	O
true	int
;	O
}	O
scale	double
=	O
d_dx	double
;	O
if	O
(	O
d_dy	double
>	O
d_dx	double
)	O
scale	double
=	O
d_dy	double
;	O
dx	int
=	O
IFLOOR	O
(	O
(	O
d_dx	double
*	O
32768	int
)	O
/	O
scale	double
+	O
0.5	int
)	O
;	O
if	O
(	O
negative_dx	enum
)	O
dx	int
=	O
-	O
dx	int
;	O
*	O
dxp	pointer
=	O
dx	int
;	O
dy	int
=	O
IFLOOR	O
(	O
(	O
d_dy	double
*	O
32768	int
)	O
/	O
scale	double
+	O
0.5	int
)	O
;	O
if	O
(	O
negative_dy	enum
)	O
dy	int
=	O
-	O
dy	int
;	O
*	O
dyp	pointer
=	O
dy	int
;	O
break	O
;	O
}	O
}	O
static	O
void	O
miGetPieEdge	function
(	O
const	O
miArc	struct
*	O
arc	pointer
,	O
int	O
angle	double
,	O
miSliceEdge	struct
*	O
edge	pointer
,	O
bool	enum
top	enum
,	O
bool	enum
left	enum
)	O
{	O
int	O
k	int
;	O
int	O
dx	int
,	O
dy	int
;	O
miEllipseAngleToSlope	function
(	O
angle	double
,	O
arc	pointer
->	O
width	array
,	O
arc	pointer
->	O
height	int
,	O
&	O
dx	int
,	O
&	O
dy	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
dy	int
==	O
0	int
)	O
{	O
edge	pointer
->	O
x	double
=	O
left	enum
?	O
INT_MIN	O
:	O
INT_MAX	O
;	O
edge	pointer
->	O
stepx	int
=	O
0	int
;	O
edge	pointer
->	O
e	int
=	O
0	int
;	O
edge	pointer
->	O
dx	int
=	O
-	O
1	int
;	O
return	O
;	O
}	O
if	O
(	O
dx	int
==	O
0	int
)	O
{	O
edge	pointer
->	O
x	double
=	O
arc	pointer
->	O
x	double
+	O
(	O
int	O
)	O
(	O
arc	pointer
->	O
width	array
>>	O
1	int
)	O
;	O
if	O
(	O
left	enum
&&	O
(	O
arc	pointer
->	O
width	array
&	O
1	int
)	O
)	O
edge	pointer
->	O
x	double
++	O
;	O
else	O
if	O
(	O
!	O
left	enum
&&	O
!	O
(	O
arc	pointer
->	O
width	array
&	O
1	int
)	O
)	O
edge	pointer
->	O
x	double
--	O
;	O
edge	pointer
->	O
stepx	int
=	O
0	int
;	O
edge	pointer
->	O
e	int
=	O
0	int
;	O
edge	pointer
->	O
dx	int
=	O
-	O
1	int
;	O
return	O
;	O
}	O
if	O
(	O
dy	int
<	O
0	int
)	O
{	O
dx	int
=	O
-	O
dx	int
;	O
dy	int
=	O
-	O
dy	int
;	O
}	O
k	int
=	O
(	O
arc	pointer
->	O
height	int
&	O
1	int
)	O
?	O
dx	int
:	O
0	int
;	O
if	O
(	O
arc	pointer
->	O
width	array
&	O
1	int
)	O
k	int
+=	O
dy	int
;	O
edge	pointer
->	O
dx	int
=	O
dx	int
<<	O
1	int
;	O
edge	pointer
->	O
dy	int
=	O
dy	int
<<	O
1	int
;	O
miGetArcEdge	function
(	O
arc	pointer
,	O
edge	pointer
,	O
k	int
,	O
top	enum
,	O
left	enum
)	O
;	O
}	O
static	O
void	O
miFillArcSliceSetup	function
(	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
const	O
miArc	struct
*	O
arc	pointer
,	O
miArcSlice	struct
*	O
slice	pointer
)	O
{	O
int	O
angle1	int
,	O
angle2	int
;	O
angle1	int
=	O
arc	pointer
->	O
angle1	int
;	O
if	O
(	O
arc	pointer
->	O
angle2	int
<	O
0	int
)	O
{	O
angle2	int
=	O
angle1	int
;	O
angle1	int
+=	O
arc	pointer
->	O
angle2	int
;	O
}	O
else	O
angle2	int
=	O
angle1	int
+	O
arc	pointer
->	O
angle2	int
;	O
while	O
(	O
angle1	int
<	O
0	int
)	O
angle1	int
+=	O
FULLCIRCLE	O
;	O
while	O
(	O
angle1	int
>=	O
FULLCIRCLE	O
)	O
angle1	int
-=	O
FULLCIRCLE	O
;	O
while	O
(	O
angle2	int
<	O
0	int
)	O
angle2	int
+=	O
FULLCIRCLE	O
;	O
while	O
(	O
angle2	int
>=	O
FULLCIRCLE	O
)	O
angle2	int
-=	O
FULLCIRCLE	O
;	O
slice	pointer
->	O
min_top_y	int
=	O
0	int
;	O
slice	pointer
->	O
max_top_y	int
=	O
arc	pointer
->	O
height	int
>>	O
1	int
;	O
slice	pointer
->	O
min_bot_y	int
=	O
1	int
-	O
(	O
arc	pointer
->	O
height	int
&	O
1	int
)	O
;	O
slice	pointer
->	O
max_bot_y	int
=	O
slice	pointer
->	O
max_top_y	int
-	O
1	int
;	O
slice	pointer
->	O
flip_top	enum
=	O
false	int
;	O
slice	pointer
->	O
flip_bot	enum
=	O
false	int
;	O
switch	O
(	O
pGC	pointer
->	O
arcMode	int
)	O
{	O
case	O
MI_ARC_CHORD	int
:	O
default	O
:	O
{	O
double	O
w2	double
,	O
h2	double
,	O
x1	double
,	O
y1	function
,	O
x2	double
,	O
y2	double
,	O
dx	int
,	O
dy	int
,	O
scale	double
;	O
int	O
signdx	int
,	O
signdy	int
,	O
y	double
,	O
k	int
;	O
bool	enum
isInt1	enum
=	O
true	int
,	O
isInt2	enum
=	O
true	int
;	O
w2	double
=	O
0.5	int
*	O
(	O
double	O
)	O
arc	pointer
->	O
width	array
;	O
h2	double
=	O
0.5	int
*	O
(	O
double	O
)	O
arc	pointer
->	O
height	int
;	O
if	O
(	O
(	O
angle1	int
==	O
0	int
)	O
||	O
(	O
angle1	int
==	O
HALFCIRCLE	O
)	O
)	O
{	O
x1	double
=	O
angle1	int
?	O
-	O
w2	double
:	O
w2	double
;	O
y1	function
=	O
0.0	int
;	O
}	O
else	O
if	O
(	O
(	O
angle1	int
==	O
QUADRANT	O
)	O
||	O
(	O
angle1	int
==	O
QUADRANT3	O
)	O
)	O
{	O
x1	double
=	O
0.0	int
;	O
y1	function
=	O
(	O
angle1	int
==	O
QUADRANT	O
)	O
?	O
h2	double
:	O
-	O
h2	double
;	O
}	O
else	O
{	O
isInt1	enum
=	O
false	int
;	O
x1	double
=	O
Dcos	O
(	O
angle1	int
)	O
*	O
w2	double
;	O
y1	function
=	O
Dsin	O
(	O
angle1	int
)	O
*	O
h2	double
;	O
}	O
if	O
(	O
(	O
angle2	int
==	O
0	int
)	O
||	O
(	O
angle2	int
==	O
HALFCIRCLE	O
)	O
)	O
{	O
x2	double
=	O
angle2	int
?	O
-	O
w2	double
:	O
w2	double
;	O
y2	double
=	O
0.0	int
;	O
}	O
else	O
if	O
(	O
(	O
angle2	int
==	O
QUADRANT	O
)	O
||	O
(	O
angle2	int
==	O
QUADRANT3	O
)	O
)	O
{	O
x2	double
=	O
0.0	int
;	O
y2	double
=	O
(	O
angle2	int
==	O
QUADRANT	O
)	O
?	O
h2	double
:	O
-	O
h2	double
;	O
}	O
else	O
{	O
isInt2	enum
=	O
false	int
;	O
x2	double
=	O
Dcos	O
(	O
angle2	int
)	O
*	O
w2	double
;	O
y2	double
=	O
Dsin	O
(	O
angle2	int
)	O
*	O
h2	double
;	O
}	O
dx	int
=	O
x2	double
-	O
x1	double
;	O
dy	int
=	O
y2	double
-	O
y1	function
;	O
if	O
(	O
arc	pointer
->	O
height	int
&	O
1	int
)	O
{	O
y1	function
-=	O
0.5	int
;	O
y2	double
-=	O
0.5	int
;	O
}	O
if	O
(	O
arc	pointer
->	O
width	array
&	O
1	int
)	O
{	O
x1	double
+=	O
0.5	int
;	O
x2	double
+=	O
0.5	int
;	O
}	O
if	O
(	O
dy	int
<	O
0.0	int
)	O
{	O
dy	int
=	O
-	O
dy	int
;	O
signdy	int
=	O
-	O
1	int
;	O
}	O
else	O
signdy	int
=	O
1	int
;	O
if	O
(	O
dx	int
<	O
0.0	int
)	O
{	O
dx	int
=	O
-	O
dx	int
;	O
signdx	int
=	O
-	O
1	int
;	O
}	O
else	O
signdx	int
=	O
1	int
;	O
if	O
(	O
isInt1	enum
&&	O
isInt2	enum
)	O
{	O
slice	pointer
->	O
edge1	struct
.	O
dx	int
=	O
(	O
int	O
)	O
(	O
dx	int
*	O
2	int
)	O
;	O
slice	pointer
->	O
edge1	struct
.	O
dy	int
=	O
(	O
int	O
)	O
(	O
dy	int
*	O
2	int
)	O
;	O
}	O
else	O
{	O
scale	double
=	O
(	O
dx	int
>	O
dy	int
)	O
?	O
dx	int
:	O
dy	int
;	O
slice	pointer
->	O
edge1	struct
.	O
dx	int
=	O
IFLOOR	O
(	O
(	O
dx	int
*	O
32768	int
)	O
/	O
scale	double
+	O
.5	int
)	O
;	O
slice	pointer
->	O
edge1	struct
.	O
dy	int
=	O
IFLOOR	O
(	O
(	O
dy	int
*	O
32768	int
)	O
/	O
scale	double
+	O
.5	int
)	O
;	O
}	O
if	O
(	O
!	O
slice	pointer
->	O
edge1	struct
.	O
dy	int
)	O
{	O
if	O
(	O
signdx	int
<	O
0	int
)	O
{	O
y	double
=	O
IFLOOR	O
(	O
y1	function
+	O
1.0	int
)	O
;	O
if	O
(	O
y	double
>=	O
0	int
)	O
{	O
slice	pointer
->	O
min_top_y	int
=	O
y	double
;	O
slice	pointer
->	O
min_bot_y	int
=	O
arc	pointer
->	O
height	int
;	O
}	O
else	O
{	O
slice	pointer
->	O
max_bot_y	int
=	O
-	O
y	double
-	O
(	O
arc	pointer
->	O
height	int
&	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
y	double
=	O
IFLOOR	O
(	O
y1	function
)	O
;	O
if	O
(	O
y	double
>=	O
0	int
)	O
slice	pointer
->	O
max_top_y	int
=	O
y	double
;	O
else	O
{	O
slice	pointer
->	O
min_top_y	int
=	O
arc	pointer
->	O
height	int
;	O
slice	pointer
->	O
min_bot_y	int
=	O
-	O
y	double
-	O
(	O
arc	pointer
->	O
height	int
&	O
1	int
)	O
;	O
}	O
}	O
slice	pointer
->	O
edge1_top	enum
=	O
true	int
;	O
slice	pointer
->	O
edge1	struct
.	O
x	double
=	O
INT_MAX	O
;	O
slice	pointer
->	O
edge1	struct
.	O
stepx	int
=	O
0	int
;	O
slice	pointer
->	O
edge1	struct
.	O
e	int
=	O
0	int
;	O
slice	pointer
->	O
edge1	struct
.	O
dx	int
=	O
-	O
1	int
;	O
slice	pointer
->	O
edge2	struct
=	O
slice	pointer
->	O
edge1	struct
;	O
slice	pointer
->	O
edge2_top	enum
=	O
false	int
;	O
}	O
else	O
if	O
(	O
!	O
slice	pointer
->	O
edge1	struct
.	O
dx	int
)	O
{	O
if	O
(	O
signdy	int
<	O
0	int
)	O
x1	double
-=	O
1.0	int
;	O
slice	pointer
->	O
edge1	struct
.	O
x	double
=	O
ICEIL	O
(	O
x1	double
)	O
;	O
slice	pointer
->	O
edge1_top	enum
=	O
(	O
signdy	int
<	O
0	int
?	O
true	int
:	O
false	int
)	O
;	O
slice	pointer
->	O
edge1	struct
.	O
x	double
+=	O
arc	pointer
->	O
x	double
+	O
(	O
int	O
)	O
(	O
arc	pointer
->	O
width	array
>>	O
1	int
)	O
;	O
slice	pointer
->	O
edge1	struct
.	O
stepx	int
=	O
0	int
;	O
slice	pointer
->	O
edge1	struct
.	O
e	int
=	O
0	int
;	O
slice	pointer
->	O
edge1	struct
.	O
dx	int
=	O
-	O
1	int
;	O
slice	pointer
->	O
edge2_top	enum
=	O
(	O
slice	pointer
->	O
edge1_top	enum
?	O
false	int
:	O
true	int
)	O
;	O
slice	pointer
->	O
edge2	struct
=	O
slice	pointer
->	O
edge1	struct
;	O
}	O
else	O
{	O
if	O
(	O
signdx	int
<	O
0	int
)	O
slice	pointer
->	O
edge1	struct
.	O
dx	int
=	O
-	O
slice	pointer
->	O
edge1	struct
.	O
dx	int
;	O
if	O
(	O
signdy	int
<	O
0	int
)	O
slice	pointer
->	O
edge1	struct
.	O
dx	int
=	O
-	O
slice	pointer
->	O
edge1	struct
.	O
dx	int
;	O
k	int
=	O
ICEIL	O
(	O
(	O
(	O
x1	double
+	O
x2	double
)	O
*	O
slice	pointer
->	O
edge1	struct
.	O
dy	int
-	O
(	O
y1	function
+	O
y2	double
)	O
*	O
slice	pointer
->	O
edge1	struct
.	O
dx	int
)	O
/	O
2.0	int
)	O
;	O
slice	pointer
->	O
edge2	struct
.	O
dx	int
=	O
slice	pointer
->	O
edge1	struct
.	O
dx	int
;	O
slice	pointer
->	O
edge2	struct
.	O
dy	int
=	O
slice	pointer
->	O
edge1	struct
.	O
dy	int
;	O
slice	pointer
->	O
edge1_top	enum
=	O
(	O
signdy	int
<	O
0	int
?	O
true	int
:	O
false	int
)	O
;	O
slice	pointer
->	O
edge2_top	enum
=	O
(	O
slice	pointer
->	O
edge1_top	enum
?	O
false	int
:	O
true	int
)	O
;	O
miGetArcEdge	function
(	O
arc	pointer
,	O
&	O
slice	pointer
->	O
edge1	struct
,	O
k	int
,	O
slice	pointer
->	O
edge1_top	enum
,	O
(	O
slice	pointer
->	O
edge1_top	enum
?	O
false	int
:	O
true	int
)	O
)	O
;	O
miGetArcEdge	function
(	O
arc	pointer
,	O
&	O
slice	pointer
->	O
edge2	struct
,	O
k	int
,	O
slice	pointer
->	O
edge2_top	enum
,	O
slice	pointer
->	O
edge2_top	enum
)	O
;	O
}	O
}	O
break	O
;	O
case	O
MI_ARC_PIE_SLICE	int
:	O
slice	pointer
->	O
edge1_top	enum
=	O
(	O
angle1	int
<	O
HALFCIRCLE	O
?	O
true	int
:	O
false	int
)	O
;	O
slice	pointer
->	O
edge2_top	enum
=	O
(	O
angle2	int
<=	O
HALFCIRCLE	O
?	O
true	int
:	O
false	int
)	O
;	O
if	O
(	O
(	O
angle2	int
==	O
0	int
)	O
||	O
(	O
angle1	int
==	O
HALFCIRCLE	O
)	O
)	O
{	O
if	O
(	O
angle2	int
?	O
slice	pointer
->	O
edge2_top	enum
:	O
slice	pointer
->	O
edge1_top	enum
)	O
slice	pointer
->	O
min_top_y	int
=	O
slice	pointer
->	O
min_bot_y	int
;	O
else	O
slice	pointer
->	O
min_top_y	int
=	O
arc	pointer
->	O
height	int
;	O
slice	pointer
->	O
min_bot_y	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
(	O
angle1	int
==	O
0	int
)	O
||	O
(	O
angle2	int
==	O
HALFCIRCLE	O
)	O
)	O
{	O
slice	pointer
->	O
min_top_y	int
=	O
slice	pointer
->	O
min_bot_y	int
;	O
if	O
(	O
angle1	int
?	O
slice	pointer
->	O
edge1_top	enum
:	O
slice	pointer
->	O
edge2_top	enum
)	O
slice	pointer
->	O
min_bot_y	int
=	O
(	O
int	O
)	O
arc	pointer
->	O
height	int
;	O
else	O
slice	pointer
->	O
min_bot_y	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
slice	pointer
->	O
edge1_top	enum
==	O
slice	pointer
->	O
edge2_top	enum
)	O
{	O
if	O
(	O
angle2	int
<	O
angle1	int
)	O
{	O
slice	pointer
->	O
flip_top	enum
=	O
slice	pointer
->	O
edge1_top	enum
;	O
slice	pointer
->	O
flip_bot	enum
=	O
(	O
slice	pointer
->	O
edge1_top	enum
?	O
false	int
:	O
true	int
)	O
;	O
}	O
else	O
if	O
(	O
slice	pointer
->	O
edge1_top	enum
)	O
{	O
slice	pointer
->	O
min_top_y	int
=	O
1	int
;	O
slice	pointer
->	O
min_bot_y	int
=	O
(	O
int	O
)	O
arc	pointer
->	O
height	int
;	O
}	O
else	O
{	O
slice	pointer
->	O
min_bot_y	int
=	O
0	int
;	O
slice	pointer
->	O
min_top_y	int
=	O
(	O
int	O
)	O
arc	pointer
->	O
height	int
;	O
}	O
}	O
miGetPieEdge	function
(	O
arc	pointer
,	O
angle1	int
,	O
&	O
slice	pointer
->	O
edge1	struct
,	O
slice	pointer
->	O
edge1_top	enum
,	O
(	O
slice	pointer
->	O
edge1_top	enum
?	O
false	int
:	O
true	int
)	O
)	O
;	O
miGetPieEdge	function
(	O
arc	pointer
,	O
angle2	int
,	O
&	O
slice	pointer
->	O
edge2	struct
,	O
slice	pointer
->	O
edge2_top	enum
,	O
slice	pointer
->	O
edge2_top	enum
)	O
;	O
break	O
;	O
}	O
}	O
static	O
void	O
miFillEllipseI	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
const	O
miArc	struct
*	O
arc	pointer
)	O
{	O
int	O
x	double
,	O
y	double
,	O
e	int
;	O
int	O
yk	int
,	O
xk	int
,	O
ym	int
,	O
xm	int
,	O
dx	int
,	O
dy	int
,	O
xorg	int
,	O
yorg	int
;	O
int	O
slw	int
;	O
miFillArc	struct
info	pointer
;	O
miPoint	struct
*	O
points_upper	pointer
,	O
*	O
points_lower	pointer
,	O
*	O
pts_upper	pointer
,	O
*	O
pts_lower	pointer
;	O
unsigned	O
int	O
*	O
widths_upper	pointer
,	O
*	O
widths_lower	pointer
,	O
*	O
wids_upper	pointer
,	O
*	O
wids_lower	pointer
;	O
int	O
numUpperSpans	int
,	O
numLowerSpans	int
;	O
points_upper	pointer
=	O
(	O
miPoint	struct
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
miPoint	struct
)	O
*	O
arc	pointer
->	O
height	int
)	O
;	O
widths_upper	pointer
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
unsigned	O
int	O
)	O
*	O
arc	pointer
->	O
height	int
)	O
;	O
pts_upper	pointer
=	O
points_upper	pointer
;	O
wids_upper	pointer
=	O
widths_upper	pointer
;	O
points_lower	pointer
=	O
(	O
miPoint	struct
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
miPoint	struct
)	O
*	O
arc	pointer
->	O
height	int
)	O
;	O
widths_lower	pointer
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
unsigned	O
int	O
)	O
*	O
arc	pointer
->	O
height	int
)	O
;	O
pts_lower	pointer
=	O
points_lower	pointer
+	O
(	O
arc	pointer
->	O
height	int
-	O
1	int
)	O
;	O
wids_lower	pointer
=	O
widths_lower	pointer
+	O
(	O
arc	pointer
->	O
height	int
-	O
1	int
)	O
;	O
miFillArcSetup	function
(	O
arc	pointer
,	O
&	O
info	pointer
)	O
;	O
MIFILLARCSETUP	O
(	O
info	pointer
,	O
x	double
,	O
y	double
,	O
e	int
,	O
xk	int
,	O
xm	int
,	O
yk	int
,	O
ym	int
,	O
dx	int
,	O
dy	int
,	O
xorg	int
,	O
yorg	int
)	O
;	O
while	O
(	O
y	double
>	O
0	int
)	O
{	O
MIFILLARCSTEP	O
(	O
x	double
,	O
y	double
,	O
e	int
,	O
xk	int
,	O
xm	int
,	O
yk	int
,	O
ym	int
,	O
dx	int
,	O
slw	int
)	O
;	O
ADDSPANS	O
(	O
pts_upper	pointer
,	O
pts_lower	pointer
,	O
wids_upper	pointer
,	O
wids_lower	pointer
,	O
x	double
,	O
y	double
,	O
slw	int
,	O
e	int
,	O
xk	int
,	O
xorg	int
,	O
yorg	int
,	O
dy	int
)	O
;	O
}	O
numUpperSpans	int
=	O
pts_upper	pointer
-	O
points_upper	pointer
;	O
numLowerSpans	int
=	O
points_lower	pointer
+	O
(	O
arc	pointer
->	O
height	int
-	O
1	int
)	O
-	O
pts_lower	pointer
;	O
if	O
(	O
numUpperSpans	int
>	O
0	int
)	O
MI_PAINT_SPANS	O
(	O
paintedSet	pointer
,	O
pGC	pointer
->	O
pixels	pointer
[	O
1	int
]	O
,	O
numUpperSpans	int
,	O
points_upper	pointer
,	O
widths_upper	pointer
)	O
if	O
(	O
numLowerSpans	int
>	O
0	int
)	O
MI_COPY_AND_PAINT_SPANS	O
(	O
paintedSet	pointer
,	O
pGC	pointer
->	O
pixels	pointer
[	O
1	int
]	O
,	O
numLowerSpans	int
,	O
pts_lower	pointer
+	O
1	int
,	O
wids_lower	pointer
+	O
1	int
)	O
free	function
(	O
points_lower	pointer
)	O
;	O
free	function
(	O
widths_lower	pointer
)	O
;	O
}	O
static	O
void	O
miFillEllipseD	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
const	O
miArc	struct
*	O
arc	pointer
)	O
{	O
int	O
x	double
,	O
y	double
;	O
int	O
xorg	int
,	O
yorg	int
,	O
dx	int
,	O
dy	int
,	O
slw	int
;	O
double	O
e	int
,	O
yk	int
,	O
xk	int
,	O
ym	int
,	O
xm	int
;	O
miFillArcD	struct
info	pointer
;	O
miPoint	struct
*	O
points_upper	pointer
,	O
*	O
points_lower	pointer
,	O
*	O
pts_upper	pointer
,	O
*	O
pts_lower	pointer
;	O
unsigned	O
int	O
*	O
widths_upper	pointer
,	O
*	O
widths_lower	pointer
,	O
*	O
wids_upper	pointer
,	O
*	O
wids_lower	pointer
;	O
int	O
numUpperSpans	int
,	O
numLowerSpans	int
;	O
points_upper	pointer
=	O
(	O
miPoint	struct
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
miPoint	struct
)	O
*	O
arc	pointer
->	O
height	int
)	O
;	O
widths_upper	pointer
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
unsigned	O
int	O
)	O
*	O
arc	pointer
->	O
height	int
)	O
;	O
pts_upper	pointer
=	O
points_upper	pointer
;	O
wids_upper	pointer
=	O
widths_upper	pointer
;	O
points_lower	pointer
=	O
(	O
miPoint	struct
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
miPoint	struct
)	O
*	O
arc	pointer
->	O
height	int
)	O
;	O
widths_lower	pointer
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
unsigned	O
int	O
)	O
*	O
arc	pointer
->	O
height	int
)	O
;	O
pts_lower	pointer
=	O
points_lower	pointer
+	O
(	O
arc	pointer
->	O
height	int
-	O
1	int
)	O
;	O
wids_lower	pointer
=	O
widths_lower	pointer
+	O
(	O
arc	pointer
->	O
height	int
-	O
1	int
)	O
;	O
miFillArcDSetup	function
(	O
arc	pointer
,	O
&	O
info	pointer
)	O
;	O
MIFILLARCSETUP	O
(	O
info	pointer
,	O
x	double
,	O
y	double
,	O
e	int
,	O
xk	int
,	O
xm	int
,	O
yk	int
,	O
ym	int
,	O
dx	int
,	O
dy	int
,	O
xorg	int
,	O
yorg	int
)	O
;	O
while	O
(	O
y	double
>	O
0	int
)	O
{	O
MIFILLARCSTEP	O
(	O
x	double
,	O
y	double
,	O
e	int
,	O
xk	int
,	O
xm	int
,	O
yk	int
,	O
ym	int
,	O
dx	int
,	O
slw	int
)	O
;	O
ADDSPANS	O
(	O
pts_upper	pointer
,	O
pts_lower	pointer
,	O
wids_upper	pointer
,	O
wids_lower	pointer
,	O
x	double
,	O
y	double
,	O
slw	int
,	O
e	int
,	O
xk	int
,	O
xorg	int
,	O
yorg	int
,	O
dy	int
)	O
;	O
}	O
numUpperSpans	int
=	O
pts_upper	pointer
-	O
points_upper	pointer
;	O
numLowerSpans	int
=	O
points_lower	pointer
+	O
(	O
arc	pointer
->	O
height	int
-	O
1	int
)	O
-	O
pts_lower	pointer
;	O
if	O
(	O
numUpperSpans	int
>	O
0	int
)	O
MI_PAINT_SPANS	O
(	O
paintedSet	pointer
,	O
pGC	pointer
->	O
pixels	pointer
[	O
1	int
]	O
,	O
numUpperSpans	int
,	O
points_upper	pointer
,	O
widths_upper	pointer
)	O
if	O
(	O
numLowerSpans	int
>	O
0	int
)	O
MI_COPY_AND_PAINT_SPANS	O
(	O
paintedSet	pointer
,	O
pGC	pointer
->	O
pixels	pointer
[	O
1	int
]	O
,	O
numLowerSpans	int
,	O
pts_lower	pointer
+	O
1	int
,	O
wids_lower	pointer
+	O
1	int
)	O
free	function
(	O
points_lower	pointer
)	O
;	O
free	function
(	O
widths_lower	pointer
)	O
;	O
}	O
static	O
void	O
miFillArcSliceI	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
const	O
miArc	struct
*	O
arc	pointer
)	O
{	O
int	O
yk	int
,	O
xk	int
,	O
ym	int
,	O
xm	int
,	O
dx	int
,	O
dy	int
,	O
xorg	int
,	O
yorg	int
,	O
slw	int
,	O
orig_slw	int
;	O
int	O
x	double
,	O
y	double
,	O
e	int
;	O
miFillArc	struct
info	pointer
;	O
miArcSlice	struct
slice	pointer
;	O
int	O
ya	int
,	O
xl	int
,	O
xr	int
;	O
miPoint	struct
*	O
points_upper	pointer
,	O
*	O
points_lower	pointer
,	O
*	O
pts_upper	pointer
,	O
*	O
pts_lower	pointer
;	O
unsigned	O
int	O
*	O
widths_upper	pointer
,	O
*	O
widths_lower	pointer
,	O
*	O
wids_upper	pointer
,	O
*	O
wids_lower	pointer
;	O
int	O
numUpperSpans	int
,	O
numLowerSpans	int
;	O
miFillArcSetup	function
(	O
arc	pointer
,	O
&	O
info	pointer
)	O
;	O
miFillArcSliceSetup	function
(	O
pGC	pointer
,	O
arc	pointer
,	O
&	O
slice	pointer
)	O
;	O
MIFILLARCSETUP	O
(	O
info	pointer
,	O
x	double
,	O
y	double
,	O
e	int
,	O
xk	int
,	O
xm	int
,	O
yk	int
,	O
ym	int
,	O
dx	int
,	O
dy	int
,	O
xorg	int
,	O
yorg	int
)	O
;	O
slw	int
=	O
(	O
int	O
)	O
arc	pointer
->	O
height	int
;	O
if	O
(	O
slice	pointer
.	O
flip_top	enum
||	O
slice	pointer
.	O
flip_bot	enum
)	O
slw	int
+=	O
(	O
int	O
)	O
(	O
arc	pointer
->	O
height	int
>>	O
1	int
)	O
+	O
1	int
;	O
orig_slw	int
=	O
slw	int
;	O
points_upper	pointer
=	O
(	O
miPoint	struct
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
miPoint	struct
)	O
*	O
slw	int
)	O
;	O
widths_upper	pointer
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
unsigned	O
int	O
)	O
*	O
slw	int
)	O
;	O
pts_upper	pointer
=	O
points_upper	pointer
;	O
wids_upper	pointer
=	O
widths_upper	pointer
;	O
points_lower	pointer
=	O
(	O
miPoint	struct
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
miPoint	struct
)	O
*	O
slw	int
)	O
;	O
widths_lower	pointer
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
unsigned	O
int	O
)	O
*	O
slw	int
)	O
;	O
pts_lower	pointer
=	O
points_lower	pointer
+	O
(	O
slw	int
-	O
1	int
)	O
;	O
wids_lower	pointer
=	O
widths_lower	pointer
+	O
(	O
slw	int
-	O
1	int
)	O
;	O
while	O
(	O
y	double
>	O
0	int
)	O
{	O
MIFILLARCSTEP	O
(	O
x	double
,	O
y	double
,	O
e	int
,	O
xk	int
,	O
xm	int
,	O
yk	int
,	O
ym	int
,	O
dx	int
,	O
slw	int
)	O
;	O
MIARCSLICESTEP	O
(	O
slice	pointer
.	O
edge1	struct
)	O
;	O
MIARCSLICESTEP	O
(	O
slice	pointer
.	O
edge2	struct
)	O
;	O
if	O
(	O
MIFILLSLICEUPPER	O
(	O
y	double
,	O
slice	pointer
)	O
)	O
{	O
bool	enum
lower	enum
=	O
false	int
;	O
ya	int
=	O
yorg	int
-	O
y	double
;	O
MIARCSLICEUPPER	O
(	O
xl	int
,	O
xr	int
,	O
slice	pointer
,	O
slw	int
)	O
ADDSLICESPANS	O
(	O
pts_upper	pointer
,	O
wids_upper	pointer
,	O
lower	enum
,	O
xl	int
,	O
xr	int
,	O
xorg	int
,	O
ya	int
,	O
slice	pointer
.	O
flip_top	enum
)	O
}	O
if	O
(	O
MIFILLSLICELOWER	O
(	O
y	double
,	O
slice	pointer
)	O
)	O
{	O
bool	enum
lower	enum
=	O
true	int
;	O
ya	int
=	O
yorg	int
+	O
y	double
+	O
dy	int
;	O
MIARCSLICELOWER	O
(	O
xl	int
,	O
xr	int
,	O
slice	pointer
,	O
slw	int
)	O
ADDSLICESPANS	O
(	O
pts_lower	pointer
,	O
wids_lower	pointer
,	O
lower	enum
,	O
xl	int
,	O
xr	int
,	O
xorg	int
,	O
ya	int
,	O
slice	pointer
.	O
flip_bot	enum
)	O
}	O
}	O
numUpperSpans	int
=	O
pts_upper	pointer
-	O
points_upper	pointer
;	O
numLowerSpans	int
=	O
points_lower	pointer
+	O
(	O
orig_slw	int
-	O
1	int
)	O
-	O
pts_lower	pointer
;	O
if	O
(	O
numUpperSpans	int
>	O
0	int
)	O
MI_PAINT_SPANS	O
(	O
paintedSet	pointer
,	O
pGC	pointer
->	O
pixels	pointer
[	O
1	int
]	O
,	O
numUpperSpans	int
,	O
points_upper	pointer
,	O
widths_upper	pointer
)	O
if	O
(	O
numLowerSpans	int
>	O
0	int
)	O
MI_COPY_AND_PAINT_SPANS	O
(	O
paintedSet	pointer
,	O
pGC	pointer
->	O
pixels	pointer
[	O
1	int
]	O
,	O
numLowerSpans	int
,	O
pts_lower	pointer
+	O
1	int
,	O
wids_lower	pointer
+	O
1	int
)	O
free	function
(	O
points_lower	pointer
)	O
;	O
free	function
(	O
widths_lower	pointer
)	O
;	O
}	O
static	O
void	O
miFillArcSliceD	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
const	O
miArc	struct
*	O
arc	pointer
)	O
{	O
int	O
x	double
,	O
y	double
;	O
int	O
dx	int
,	O
dy	int
,	O
xorg	int
,	O
yorg	int
,	O
slw	int
,	O
orig_slw	int
;	O
double	O
e	int
,	O
yk	int
,	O
xk	int
,	O
ym	int
,	O
xm	int
;	O
miFillArcD	struct
info	pointer
;	O
miArcSlice	struct
slice	pointer
;	O
int	O
ya	int
,	O
xl	int
,	O
xr	int
;	O
miPoint	struct
*	O
points_upper	pointer
,	O
*	O
points_lower	pointer
,	O
*	O
pts_upper	pointer
,	O
*	O
pts_lower	pointer
;	O
unsigned	O
int	O
*	O
widths_upper	pointer
,	O
*	O
widths_lower	pointer
,	O
*	O
wids_upper	pointer
,	O
*	O
wids_lower	pointer
;	O
int	O
numUpperSpans	int
,	O
numLowerSpans	int
;	O
miFillArcDSetup	function
(	O
arc	pointer
,	O
&	O
info	pointer
)	O
;	O
miFillArcSliceSetup	function
(	O
pGC	pointer
,	O
arc	pointer
,	O
&	O
slice	pointer
)	O
;	O
MIFILLARCSETUP	O
(	O
info	pointer
,	O
x	double
,	O
y	double
,	O
e	int
,	O
xk	int
,	O
xm	int
,	O
yk	int
,	O
ym	int
,	O
dx	int
,	O
dy	int
,	O
xorg	int
,	O
yorg	int
)	O
;	O
slw	int
=	O
(	O
int	O
)	O
arc	pointer
->	O
height	int
;	O
if	O
(	O
slice	pointer
.	O
flip_top	enum
||	O
slice	pointer
.	O
flip_bot	enum
)	O
slw	int
+=	O
(	O
int	O
)	O
(	O
arc	pointer
->	O
height	int
>>	O
1	int
)	O
+	O
1	int
;	O
orig_slw	int
=	O
slw	int
;	O
points_upper	pointer
=	O
(	O
miPoint	struct
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
miPoint	struct
)	O
*	O
slw	int
)	O
;	O
widths_upper	pointer
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
unsigned	O
int	O
)	O
*	O
slw	int
)	O
;	O
pts_upper	pointer
=	O
points_upper	pointer
;	O
wids_upper	pointer
=	O
widths_upper	pointer
;	O
points_lower	pointer
=	O
(	O
miPoint	struct
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
miPoint	struct
)	O
*	O
slw	int
)	O
;	O
widths_lower	pointer
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
unsigned	O
int	O
)	O
*	O
slw	int
)	O
;	O
pts_lower	pointer
=	O
points_lower	pointer
+	O
(	O
slw	int
-	O
1	int
)	O
;	O
wids_lower	pointer
=	O
widths_lower	pointer
+	O
(	O
slw	int
-	O
1	int
)	O
;	O
while	O
(	O
y	double
>	O
0	int
)	O
{	O
MIFILLARCSTEP	O
(	O
x	double
,	O
y	double
,	O
e	int
,	O
xk	int
,	O
xm	int
,	O
yk	int
,	O
ym	int
,	O
dx	int
,	O
slw	int
)	O
;	O
MIARCSLICESTEP	O
(	O
slice	pointer
.	O
edge1	struct
)	O
;	O
MIARCSLICESTEP	O
(	O
slice	pointer
.	O
edge2	struct
)	O
;	O
if	O
(	O
MIFILLSLICEUPPER	O
(	O
y	double
,	O
slice	pointer
)	O
)	O
{	O
bool	enum
lower	enum
=	O
false	int
;	O
ya	int
=	O
yorg	int
-	O
y	double
;	O
MIARCSLICEUPPER	O
(	O
xl	int
,	O
xr	int
,	O
slice	pointer
,	O
slw	int
)	O
ADDSLICESPANS	O
(	O
pts_upper	pointer
,	O
wids_upper	pointer
,	O
lower	enum
,	O
xl	int
,	O
xr	int
,	O
xorg	int
,	O
ya	int
,	O
slice	pointer
.	O
flip_top	enum
)	O
}	O
if	O
(	O
MIFILLSLICELOWER	O
(	O
y	double
,	O
slice	pointer
)	O
)	O
{	O
bool	enum
lower	enum
=	O
true	int
;	O
ya	int
=	O
yorg	int
+	O
y	double
+	O
dy	int
;	O
MIARCSLICELOWER	O
(	O
xl	int
,	O
xr	int
,	O
slice	pointer
,	O
slw	int
)	O
ADDSLICESPANS	O
(	O
pts_lower	pointer
,	O
wids_lower	pointer
,	O
lower	enum
,	O
xl	int
,	O
xr	int
,	O
xorg	int
,	O
ya	int
,	O
slice	pointer
.	O
flip_bot	enum
)	O
}	O
}	O
numUpperSpans	int
=	O
pts_upper	pointer
-	O
points_upper	pointer
;	O
numLowerSpans	int
=	O
points_lower	pointer
+	O
(	O
orig_slw	int
-	O
1	int
)	O
-	O
pts_lower	pointer
;	O
if	O
(	O
numUpperSpans	int
>	O
0	int
)	O
MI_PAINT_SPANS	O
(	O
paintedSet	pointer
,	O
pGC	pointer
->	O
pixels	pointer
[	O
1	int
]	O
,	O
numUpperSpans	int
,	O
points_upper	pointer
,	O
widths_upper	pointer
)	O
if	O
(	O
numLowerSpans	int
>	O
0	int
)	O
MI_COPY_AND_PAINT_SPANS	O
(	O
paintedSet	pointer
,	O
pGC	pointer
->	O
pixels	pointer
[	O
1	int
]	O
,	O
numLowerSpans	int
,	O
pts_lower	pointer
+	O
1	int
,	O
wids_lower	pointer
+	O
1	int
)	O
free	function
(	O
points_lower	pointer
)	O
;	O
free	function
(	O
widths_lower	pointer
)	O
;	O
}	O
void	O
miFillArcs_internal	O
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
int	O
narcs	int
,	O
const	O
miArc	struct
*	O
parcs	pointer
)	O
{	O
int	O
i	int
;	O
const	O
miArc	struct
*	O
arc	pointer
;	O
for	O
(	O
i	int
=	O
narcs	int
,	O
arc	pointer
=	O
parcs	pointer
;	O
--	O
i	int
>=	O
0	int
;	O
arc	pointer
++	O
)	O
{	O
if	O
(	O
MI_FILLED_ARC_IS_EMPTY	O
(	O
arc	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
(	O
arc	pointer
->	O
angle2	int
>=	O
FULLCIRCLE	O
)	O
||	O
(	O
arc	pointer
->	O
angle2	int
<=	O
-	O
FULLCIRCLE	O
)	O
)	O
{	O
if	O
(	O
MI_CAN_FILL_ARC	O
(	O
arc	pointer
)	O
)	O
miFillEllipseI	function
(	O
paintedSet	pointer
,	O
pGC	pointer
,	O
arc	pointer
)	O
;	O
else	O
miFillEllipseD	function
(	O
paintedSet	pointer
,	O
pGC	pointer
,	O
arc	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
MI_CAN_FILL_ARC	O
(	O
arc	pointer
)	O
)	O
miFillArcSliceI	function
(	O
paintedSet	pointer
,	O
pGC	pointer
,	O
arc	pointer
)	O
;	O
else	O
miFillArcSliceD	function
(	O
paintedSet	pointer
,	O
pGC	pointer
,	O
arc	pointer
)	O
;	O
}	O
}	O
}	O
