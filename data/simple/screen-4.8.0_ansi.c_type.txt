extern	O
struct	O
display	struct
*	O
display	struct
,	O
*	O
displays	pointer
;	O
extern	O
struct	O
win	struct
*	O
fore	pointer
;	O
extern	O
struct	O
layer	struct
*	O
flayer	pointer
;	O
extern	O
struct	O
NewWindow	struct
nwin_default	struct
;	O
extern	O
int	O
nversion	int
;	O
extern	O
int	O
log_flush	int
,	O
logtstamp_on	int
,	O
logtstamp_after	int
;	O
extern	O
char	O
*	O
logtstamp_string	pointer
;	O
extern	O
char	O
*	O
captionstring	pointer
;	O
extern	O
char	O
*	O
hstatusstring	pointer
;	O
extern	O
char	O
*	O
wliststr	pointer
;	O
extern	O
int	O
compacthist	int
;	O
extern	O
struct	O
acluser	struct
*	O
EffectiveAclUser	pointer
;	O
const	O
int	O
Z0width	int
=	O
132	int
;	O
const	O
int	O
Z1width	int
=	O
80	int
;	O
static	O
struct	O
win	struct
*	O
curr	pointer
;	O
static	O
int	O
rows	int
,	O
cols	int
;	O
int	O
visual_bell	int
=	O
0	int
;	O
int	O
use_hardstatus	int
=	O
1	int
;	O
char	O
*	O
printcmd	pointer
=	O
0	int
;	O
int	O
use_altscreen	int
=	O
0	int
;	O
unsigned	O
char	O
*	O
blank	pointer
;	O
unsigned	O
char	O
*	O
null	pointer
;	O
struct	O
mline	struct
mline_old	struct
;	O
struct	O
mline	struct
mline_blank	struct
;	O
struct	O
mline	struct
mline_null	struct
;	O
struct	O
mchar	struct
mchar_null	struct
;	O
struct	O
mchar	struct
mchar_blank	struct
=	O
{	O
' '	O
}	O
;	O
struct	O
mchar	struct
mchar_so	struct
=	O
{	O
' '	O
,	O
A_SO	O
}	O
;	O
int	O
renditions	array
[	O
NUM_RENDS	int
]	O
=	O
{	O
65529	int
,	O
65531	int
,	O
65533	int
}	O
;	O
static	O
char	O
*	O
string_t_string	array
[	O
]	O
=	O
{	O
"NONE"	pointer
,	O
"DCS"	pointer
,	O
"OSC"	pointer
,	O
"APC"	pointer
,	O
"PM"	pointer
,	O
"AKA"	pointer
,	O
"GM"	pointer
,	O
"STATUS"	pointer
}	O
;	O
static	O
char	O
*	O
state_t_string	array
[	O
]	O
=	O
{	O
"LIT"	pointer
,	O
"ESC"	pointer
,	O
"ASTR"	pointer
,	O
"STRESC"	pointer
,	O
"CSI"	pointer
,	O
"PRIN"	pointer
,	O
"PRINESC"	pointer
,	O
"PRINCSI"	pointer
,	O
"PRIN4"	pointer
}	O
;	O
static	O
int	O
Special	function
__P	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
DoESC	function
__P	O
(	O
(	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
DoCSI	function
__P	O
(	O
(	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
StringStart	function
__P	O
(	O
(	O
enum	O
string_t	enum
)	O
)	O
;	O
static	O
void	O
StringChar	function
__P	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
int	O
StringEnd	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
PrintStart	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
PrintChar	function
__P	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
PrintFlush	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
DesignateCharset	function
__P	O
(	O
(	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
MapCharset	function
__P	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
MapCharsetR	function
__P	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
SaveCursor	function
__P	O
(	O
(	O
struct	O
cursor	struct
*	O
)	O
)	O
;	O
static	O
void	O
RestoreCursor	function
__P	O
(	O
(	O
struct	O
cursor	struct
*	O
)	O
)	O
;	O
static	O
void	O
BackSpace	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
Return	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
LineFeed	function
__P	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
ReverseLineFeed	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
InsertChar	function
__P	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
DeleteChar	function
__P	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
DeleteLine	function
__P	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
InsertLine	function
__P	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
Scroll	function
__P	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
int	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
ForwardTab	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
BackwardTab	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
ClearScreen	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
ClearFromBOS	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
ClearToEOS	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
ClearLineRegion	function
__P	O
(	O
(	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
CursorRight	function
__P	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
CursorUp	function
__P	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
CursorDown	function
__P	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
CursorLeft	function
__P	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
ASetMode	function
__P	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
SelectRendition	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
RestorePosRendition	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
FillWithEs	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
FindAKA	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
Report	function
__P	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
ScrollRegion	function
__P	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
WAddLineToHist	function
__P	O
(	O
(	O
struct	O
win	struct
*	O
,	O
struct	O
mline	struct
*	O
)	O
)	O
;	O
static	O
void	O
WLogString	function
__P	O
(	O
(	O
struct	O
win	struct
*	O
,	O
char	O
*	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
WReverseVideo	function
__P	O
(	O
(	O
struct	O
win	struct
*	O
,	O
int	O
)	O
)	O
;	O
static	O
int	O
WindowChangedCheck	function
__P	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
int	O
*	O
)	O
)	O
;	O
static	O
void	O
MFixLine	function
__P	O
(	O
(	O
struct	O
win	struct
*	O
,	O
int	O
,	O
struct	O
mchar	struct
*	O
)	O
)	O
;	O
static	O
void	O
MScrollH	function
__P	O
(	O
(	O
struct	O
win	struct
*	O
,	O
int	O
,	O
int	O
,	O
int	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
MScrollV	function
__P	O
(	O
(	O
struct	O
win	struct
*	O
,	O
int	O
,	O
int	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
MClearArea	function
__P	O
(	O
(	O
struct	O
win	struct
*	O
,	O
int	O
,	O
int	O
,	O
int	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
MInsChar	function
__P	O
(	O
(	O
struct	O
win	struct
*	O
,	O
struct	O
mchar	struct
*	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
MPutChar	function
__P	O
(	O
(	O
struct	O
win	struct
*	O
,	O
struct	O
mchar	struct
*	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
MPutStr	function
__P	O
(	O
(	O
struct	O
win	struct
*	O
,	O
char	O
*	O
,	O
int	O
,	O
struct	O
mchar	struct
*	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
MWrapChar	function
__P	O
(	O
(	O
struct	O
win	struct
*	O
,	O
struct	O
mchar	struct
*	O
,	O
int	O
,	O
int	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
MBceLine	function
__P	O
(	O
(	O
struct	O
win	struct
*	O
,	O
int	O
,	O
int	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
void	O
ResetAnsiState	function
(	O
p	pointer
)	O
struct	O
win	struct
*	O
p	pointer
;	O
{	O
p	pointer
->	O
w_state	enum
=	O
LIT	int
;	O
p	pointer
->	O
w_StringType	enum
=	O
NONE	int
;	O
}	O
void	O
ResetWindow	function
(	O
p	pointer
)	O
register	O
struct	O
win	struct
*	O
p	pointer
;	O
{	O
register	O
int	O
i	int
;	O
p	pointer
->	O
w_wrap	int
=	O
nwin_default	struct
.	O
wrap	int
;	O
p	pointer
->	O
w_origin	int
=	O
0	int
;	O
p	pointer
->	O
w_insert	int
=	O
0	int
;	O
p	pointer
->	O
w_revvid	int
=	O
0	int
;	O
p	pointer
->	O
w_mouse	int
=	O
0	int
;	O
p	pointer
->	O
w_curinv	int
=	O
0	int
;	O
p	pointer
->	O
w_curvvis	int
=	O
0	int
;	O
p	pointer
->	O
w_autolf	int
=	O
0	int
;	O
p	pointer
->	O
w_keypad	int
=	O
0	int
;	O
p	pointer
->	O
w_cursorkeys	int
=	O
0	int
;	O
p	pointer
->	O
w_top	int
=	O
0	int
;	O
p	pointer
->	O
w_bot	int
=	O
p	pointer
->	O
w_height	O
-	O
1	int
;	O
p	pointer
->	O
w_saved	struct
.	O
on	int
=	O
0	int
;	O
p	pointer
->	O
w_x	O
=	O
p	pointer
->	O
w_y	O
=	O
0	int
;	O
p	pointer
->	O
w_state	enum
=	O
LIT	int
;	O
p	pointer
->	O
w_StringType	enum
=	O
NONE	int
;	O
bzero	function
(	O
p	pointer
->	O
w_tabs	pointer
,	O
p	pointer
->	O
w_width	O
)	O
;	O
for	O
(	O
i	int
=	O
8	int
;	O
i	int
<	O
p	pointer
->	O
w_width	O
;	O
i	int
+=	O
8	int
)	O
p	pointer
->	O
w_tabs	pointer
[	O
i	int
]	O
=	O
1	int
;	O
p	pointer
->	O
w_rend	struct
=	O
mchar_null	struct
;	O
ResetCharsets	function
(	O
p	pointer
)	O
;	O
p	pointer
->	O
w_bce	int
=	O
nwin_default	struct
.	O
bce	int
;	O
}	O
int	O
GetAnsiStatus	function
(	O
w	pointer
,	O
buf	pointer
)	O
struct	O
win	struct
*	O
w	pointer
;	O
char	O
*	O
buf	pointer
;	O
{	O
char	O
*	O
p	pointer
=	O
buf	pointer
;	O
if	O
(	O
w	pointer
->	O
w_state	enum
==	O
LIT	int
)	O
return	O
0	int
;	O
strcpy	function
(	O
p	pointer
,	O
state_t_string	array
[	O
w	pointer
->	O
w_state	enum
]	O
)	O
;	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
;	O
if	O
(	O
w	pointer
->	O
w_intermediate	int
)	O
{	O
*	O
p	pointer
++	O
=	O
'-'	O
;	O
if	O
(	O
w	pointer
->	O
w_intermediate	int
>	O
0xff	int
)	O
p	pointer
+=	O
AddXChar	function
(	O
p	pointer
,	O
w	pointer
->	O
w_intermediate	int
>>	O
8	int
)	O
;	O
p	pointer
+=	O
AddXChar	function
(	O
p	pointer
,	O
w	pointer
->	O
w_intermediate	int
&	O
0xff	int
)	O
;	O
*	O
p	pointer
=	O
0	int
;	O
}	O
if	O
(	O
w	pointer
->	O
w_state	enum
==	O
ASTR	int
||	O
w	pointer
->	O
w_state	enum
==	O
STRESC	int
)	O
sprintf	function
(	O
p	pointer
,	O
"-%s"	pointer
,	O
string_t_string	array
[	O
w	pointer
->	O
w_StringType	enum
]	O
)	O
;	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
;	O
return	O
p	pointer
-	O
buf	pointer
;	O
}	O
void	O
ResetCharsets	function
(	O
p	pointer
)	O
struct	O
win	struct
*	O
p	pointer
;	O
{	O
p	pointer
->	O
w_gr	int
=	O
nwin_default	struct
.	O
gr	int
;	O
p	pointer
->	O
w_c1	int
=	O
nwin_default	struct
.	O
c1	int
;	O
SetCharsets	function
(	O
p	pointer
,	O
"BBBB02"	pointer
)	O
;	O
if	O
(	O
nwin_default	struct
.	O
charset	pointer
)	O
SetCharsets	function
(	O
p	pointer
,	O
nwin_default	struct
.	O
charset	pointer
)	O
;	O
ResetEncoding	function
(	O
p	pointer
)	O
;	O
}	O
void	O
SetCharsets	function
(	O
p	pointer
,	O
s	pointer
)	O
struct	O
win	struct
*	O
p	pointer
;	O
char	O
*	O
s	pointer
;	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
&&	O
*	O
s	pointer
;	O
i	int
++	O
,	O
s	pointer
++	O
)	O
if	O
(	O
*	O
s	pointer
!=	O
'.'	O
)	O
p	pointer
->	O
w_charsets	array
[	O
i	int
]	O
=	O
(	O
(	O
*	O
s	pointer
==	O
'B'	O
)	O
?	O
ASCII	int
:	O
*	O
s	pointer
)	O
;	O
if	O
(	O
*	O
s	pointer
&&	O
*	O
s	pointer
++	O
!=	O
'.'	O
)	O
p	pointer
->	O
w_Charset	int
=	O
s	pointer
[	O
-	O
1	int
]	O
-	O
'0'	O
;	O
if	O
(	O
*	O
s	pointer
&&	O
*	O
s	pointer
!=	O
'.'	O
)	O
p	pointer
->	O
w_CharsetR	int
=	O
*	O
s	pointer
-	O
'0'	O
;	O
p	pointer
->	O
w_ss	int
=	O
0	int
;	O
p	pointer
->	O
w_FontL	char
=	O
p	pointer
->	O
w_charsets	array
[	O
p	pointer
->	O
w_Charset	int
]	O
;	O
p	pointer
->	O
w_FontR	char
=	O
p	pointer
->	O
w_charsets	array
[	O
p	pointer
->	O
w_CharsetR	int
]	O
;	O
}	O
void	O
WriteString	function
(	O
wp	pointer
,	O
buf	pointer
,	O
len	int
)	O
struct	O
win	struct
*	O
wp	pointer
;	O
register	O
char	O
*	O
buf	pointer
;	O
register	O
int	O
len	int
;	O
{	O
register	O
int	O
c	int
;	O
register	O
int	O
font	char
;	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
if	O
(	O
!	O
len	int
)	O
return	O
;	O
if	O
(	O
wp	pointer
->	O
w_log	pointer
)	O
WLogString	function
(	O
wp	pointer
,	O
buf	pointer
,	O
len	int
)	O
;	O
curr	pointer
=	O
wp	pointer
;	O
cols	int
=	O
curr	pointer
->	O
w_width	O
;	O
rows	int
=	O
curr	pointer
->	O
w_height	O
;	O
if	O
(	O
curr	pointer
->	O
w_silence	int
)	O
SetTimeout	function
(	O
&	O
curr	pointer
->	O
w_silenceev	struct
,	O
curr	pointer
->	O
w_silencewait	int
*	O
1000	int
)	O
;	O
if	O
(	O
curr	pointer
->	O
w_monitor	int
==	O
MON_ON	int
)	O
{	O
debug2	O
(	O
"ACTIVITY %d %d\n"	pointer
,	O
curr	pointer
->	O
w_monitor	int
,	O
curr	pointer
->	O
w_bell	int
)	O
;	O
curr	pointer
->	O
w_monitor	int
=	O
MON_FOUND	int
;	O
}	O
if	O
(	O
cols	int
>	O
0	int
&&	O
rows	int
>	O
0	int
)	O
{	O
do	O
{	O
c	int
=	O
(	O
unsigned	O
char	O
)	O
*	O
buf	pointer
++	O
;	O
if	O
(	O
!	O
curr	pointer
->	O
w_mbcs	int
)	O
curr	pointer
->	O
w_rend	struct
.	O
font	char
=	O
curr	pointer
->	O
w_FontL	char
;	O
if	O
(	O
curr	pointer
->	O
w_state	enum
==	O
LIT	int
&&	O
curr	pointer
->	O
w_encoding	O
!=	O
UTF8	int
&&	O
!	O
is_dw_font	O
(	O
curr	pointer
->	O
w_rend	struct
.	O
font	char
)	O
&&	O
curr	pointer
->	O
w_rend	struct
.	O
font	char
!=	O
KANA	char
&&	O
!	O
curr	pointer
->	O
w_mbcs	int
&&	O
curr	pointer
->	O
w_rend	struct
.	O
font	char
!=	O
'<'	O
&&	O
c	int
>=	O
' '	O
&&	O
c	int
!=	O
0x7f	int
&&	O
(	O
(	O
c	int
&	O
0x80	int
)	O
==	O
0	int
||	O
(	O
(	O
c	int
>=	O
0xa0	int
||	O
!	O
curr	pointer
->	O
w_c1	int
)	O
&&	O
!	O
curr	pointer
->	O
w_gr	int
)	O
)	O
&&	O
!	O
curr	pointer
->	O
w_ss	int
&&	O
!	O
curr	pointer
->	O
w_insert	int
&&	O
curr	pointer
->	O
w_x	O
<	O
cols	int
-	O
1	int
)	O
{	O
register	O
int	O
currx	int
=	O
curr	pointer
->	O
w_x	O
;	O
char	O
*	O
imp	pointer
=	O
buf	pointer
-	O
1	int
;	O
while	O
(	O
currx	int
<	O
cols	int
-	O
1	int
)	O
{	O
currx	int
++	O
;	O
if	O
(	O
--	O
len	int
==	O
0	int
)	O
break	O
;	O
c	int
=	O
(	O
unsigned	O
char	O
)	O
*	O
buf	pointer
++	O
;	O
if	O
(	O
c	int
<	O
' '	O
||	O
c	int
==	O
0x7f	int
||	O
(	O
(	O
c	int
&	O
0x80	int
)	O
&&	O
(	O
(	O
c	int
<	O
0xa0	int
&&	O
curr	pointer
->	O
w_c1	int
)	O
||	O
curr	pointer
->	O
w_gr	int
)	O
)	O
)	O
break	O
;	O
}	O
currx	int
-=	O
curr	pointer
->	O
w_x	O
;	O
if	O
(	O
currx	int
>	O
0	int
)	O
{	O
MPutStr	function
(	O
curr	pointer
,	O
imp	pointer
,	O
currx	int
,	O
&	O
curr	pointer
->	O
w_rend	struct
,	O
curr	pointer
->	O
w_x	O
,	O
curr	pointer
->	O
w_y	O
)	O
;	O
LPutStr	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
imp	pointer
,	O
currx	int
,	O
&	O
curr	pointer
->	O
w_rend	struct
,	O
curr	pointer
->	O
w_x	O
,	O
curr	pointer
->	O
w_y	O
)	O
;	O
curr	pointer
->	O
w_x	O
+=	O
currx	int
;	O
}	O
if	O
(	O
len	int
==	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
curr	pointer
->	O
w_encoding	O
==	O
UTF8	int
)	O
{	O
c	int
=	O
FromUtf8	function
(	O
c	int
,	O
&	O
curr	pointer
->	O
w_decodestate	int
)	O
;	O
if	O
(	O
c	int
==	O
-	O
1	int
)	O
continue	O
;	O
if	O
(	O
c	int
==	O
-	O
2	int
)	O
{	O
c	int
=	O
UCS_REPL	int
;	O
buf	pointer
--	O
;	O
len	int
++	O
;	O
}	O
if	O
(	O
c	int
>	O
0xff	int
)	O
debug1	O
(	O
"read UNICODE %04x\n"	pointer
,	O
c	int
)	O
;	O
}	O
tryagain	O
:	O
switch	O
(	O
curr	pointer
->	O
w_state	enum
)	O
{	O
case	O
PRIN	int
:	O
switch	O
(	O
c	int
)	O
{	O
case	O
'\033'	O
:	O
curr	pointer
->	O
w_state	enum
=	O
PRINESC	int
;	O
break	O
;	O
default	O
:	O
PrintChar	function
(	O
c	int
)	O
;	O
}	O
break	O
;	O
case	O
PRINESC	int
:	O
switch	O
(	O
c	int
)	O
{	O
case	O
'['	O
:	O
curr	pointer
->	O
w_state	enum
=	O
PRINCSI	int
;	O
break	O
;	O
default	O
:	O
PrintChar	function
(	O
'\033'	O
)	O
;	O
PrintChar	function
(	O
c	int
)	O
;	O
curr	pointer
->	O
w_state	enum
=	O
PRIN	int
;	O
}	O
break	O
;	O
case	O
PRINCSI	int
:	O
switch	O
(	O
c	int
)	O
{	O
case	O
'4'	O
:	O
curr	pointer
->	O
w_state	enum
=	O
PRIN4	int
;	O
break	O
;	O
default	O
:	O
PrintChar	function
(	O
'\033'	O
)	O
;	O
PrintChar	function
(	O
'['	O
)	O
;	O
PrintChar	function
(	O
c	int
)	O
;	O
curr	pointer
->	O
w_state	enum
=	O
PRIN	int
;	O
}	O
break	O
;	O
case	O
PRIN4	int
:	O
switch	O
(	O
c	int
)	O
{	O
case	O
'i'	O
:	O
curr	pointer
->	O
w_state	enum
=	O
LIT	int
;	O
PrintFlush	function
(	O
)	O
;	O
if	O
(	O
curr	pointer
->	O
w_pdisplay	pointer
&&	O
curr	pointer
->	O
w_pdisplay	pointer
->	O
d_printfd	int
>=	O
0	int
)	O
{	O
close	pointer
(	O
curr	pointer
->	O
w_pdisplay	pointer
->	O
d_printfd	int
)	O
;	O
curr	pointer
->	O
w_pdisplay	pointer
->	O
d_printfd	int
=	O
-	O
1	int
;	O
}	O
curr	pointer
->	O
w_pdisplay	pointer
=	O
0	int
;	O
break	O
;	O
default	O
:	O
PrintChar	function
(	O
'\033'	O
)	O
;	O
PrintChar	function
(	O
'['	O
)	O
;	O
PrintChar	function
(	O
'4'	O
)	O
;	O
PrintChar	function
(	O
c	int
)	O
;	O
curr	pointer
->	O
w_state	enum
=	O
PRIN	int
;	O
}	O
break	O
;	O
case	O
ASTR	int
:	O
if	O
(	O
c	int
==	O
0	int
)	O
break	O
;	O
if	O
(	O
c	int
==	O
'\033'	O
)	O
{	O
curr	pointer
->	O
w_state	enum
=	O
STRESC	int
;	O
break	O
;	O
}	O
if	O
(	O
!	O
(	O
curr	pointer
->	O
w_StringType	enum
==	O
OSC	int
&&	O
c	int
<	O
' '	O
&&	O
c	int
!=	O
'\005'	O
)	O
)	O
if	O
(	O
!	O
curr	pointer
->	O
w_c1	int
||	O
c	int
!=	O
(	O
'\\'	O
^	O
0xc0	int
)	O
)	O
{	O
StringChar	function
(	O
c	int
)	O
;	O
break	O
;	O
}	O
c	int
=	O
'\\'	O
;	O
case	O
STRESC	int
:	O
switch	O
(	O
c	int
)	O
{	O
case	O
'\\'	O
:	O
if	O
(	O
StringEnd	function
(	O
)	O
==	O
0	int
||	O
len	int
<=	O
1	int
)	O
break	O
;	O
for	O
(	O
cv	pointer
=	O
curr	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_lnext	pointer
)	O
{	O
display	struct
=	O
cv	pointer
->	O
c_display	pointer
;	O
if	O
(	O
D_status	O
==	O
STATUS_ON_WIN	int
)	O
break	O
;	O
}	O
if	O
(	O
cv	pointer
)	O
{	O
if	O
(	O
len	int
>	O
IOSIZE	int
+	O
1	int
)	O
len	int
=	O
IOSIZE	int
+	O
1	int
;	O
curr	pointer
->	O
w_outlen	int
=	O
len	int
-	O
1	int
;	O
bcopy	function
(	O
buf	pointer
,	O
curr	pointer
->	O
w_outbuf	array
,	O
len	int
-	O
1	int
)	O
;	O
return	O
;	O
}	O
break	O
;	O
case	O
'\033'	O
:	O
StringChar	function
(	O
'\033'	O
)	O
;	O
break	O
;	O
default	O
:	O
curr	pointer
->	O
w_state	enum
=	O
ASTR	int
;	O
StringChar	function
(	O
'\033'	O
)	O
;	O
StringChar	function
(	O
c	int
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
ESC	int
:	O
switch	O
(	O
c	int
)	O
{	O
case	O
'['	O
:	O
curr	pointer
->	O
w_NumArgs	int
=	O
0	int
;	O
curr	pointer
->	O
w_intermediate	int
=	O
0	int
;	O
bzero	function
(	O
(	O
char	O
*	O
)	O
curr	pointer
->	O
w_args	array
,	O
MAXARGS	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
curr	pointer
->	O
w_state	enum
=	O
CSI	int
;	O
break	O
;	O
case	O
']'	O
:	O
StringStart	function
(	O
OSC	int
)	O
;	O
break	O
;	O
case	O
'_'	O
:	O
StringStart	function
(	O
APC	int
)	O
;	O
break	O
;	O
case	O
'P'	O
:	O
StringStart	function
(	O
DCS	int
)	O
;	O
break	O
;	O
case	O
'^'	O
:	O
StringStart	function
(	O
PM	int
)	O
;	O
break	O
;	O
case	O
'!'	O
:	O
StringStart	function
(	O
GM	int
)	O
;	O
break	O
;	O
case	O
'"'	O
:	O
case	O
'k'	O
:	O
StringStart	function
(	O
AKA	int
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
Special	function
(	O
c	int
)	O
)	O
{	O
curr	pointer
->	O
w_state	enum
=	O
LIT	int
;	O
break	O
;	O
}	O
debug1	O
(	O
"not special. c = %x\n"	pointer
,	O
c	int
)	O
;	O
if	O
(	O
c	int
>=	O
' '	O
&&	O
c	int
<=	O
'/'	O
)	O
{	O
if	O
(	O
curr	pointer
->	O
w_intermediate	int
)	O
{	O
if	O
(	O
curr	pointer
->	O
w_intermediate	int
==	O
'$'	O
)	O
c	int
|=	O
'$'	O
<<	O
8	int
;	O
else	O
c	int
=	O
-	O
1	int
;	O
}	O
curr	pointer
->	O
w_intermediate	int
=	O
c	int
;	O
}	O
else	O
if	O
(	O
c	int
>=	O
'0'	O
&&	O
c	int
<=	O
'~'	O
)	O
{	O
DoESC	function
(	O
c	int
,	O
curr	pointer
->	O
w_intermediate	int
)	O
;	O
curr	pointer
->	O
w_state	enum
=	O
LIT	int
;	O
}	O
else	O
{	O
curr	pointer
->	O
w_state	enum
=	O
LIT	int
;	O
goto	O
tryagain	O
;	O
}	O
}	O
break	O
;	O
case	O
CSI	int
:	O
switch	O
(	O
c	int
)	O
{	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
if	O
(	O
curr	pointer
->	O
w_NumArgs	int
>=	O
0	int
&&	O
curr	pointer
->	O
w_NumArgs	int
<	O
MAXARGS	int
)	O
{	O
if	O
(	O
curr	pointer
->	O
w_args	array
[	O
curr	pointer
->	O
w_NumArgs	int
]	O
<	O
100000000	int
)	O
curr	pointer
->	O
w_args	array
[	O
curr	pointer
->	O
w_NumArgs	int
]	O
=	O
10	int
*	O
curr	pointer
->	O
w_args	array
[	O
curr	pointer
->	O
w_NumArgs	int
]	O
+	O
(	O
c	int
-	O
'0'	O
)	O
;	O
}	O
break	O
;	O
case	O
';'	O
:	O
case	O
':'	O
:	O
if	O
(	O
curr	pointer
->	O
w_NumArgs	int
<	O
MAXARGS	int
)	O
curr	pointer
->	O
w_NumArgs	int
++	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
Special	function
(	O
c	int
)	O
)	O
break	O
;	O
if	O
(	O
c	int
>=	O
'@'	O
&&	O
c	int
<=	O
'~'	O
)	O
{	O
if	O
(	O
curr	pointer
->	O
w_NumArgs	int
<	O
MAXARGS	int
)	O
curr	pointer
->	O
w_NumArgs	int
++	O
;	O
DoCSI	function
(	O
c	int
,	O
curr	pointer
->	O
w_intermediate	int
)	O
;	O
if	O
(	O
curr	pointer
->	O
w_state	enum
!=	O
PRIN	int
)	O
curr	pointer
->	O
w_state	enum
=	O
LIT	int
;	O
}	O
else	O
if	O
(	O
(	O
c	int
>=	O
' '	O
&&	O
c	int
<=	O
'/'	O
)	O
||	O
(	O
c	int
>=	O
'<'	O
&&	O
c	int
<=	O
'?'	O
)	O
)	O
curr	pointer
->	O
w_intermediate	int
=	O
curr	pointer
->	O
w_intermediate	int
?	O
-	O
1	int
:	O
c	int
;	O
else	O
{	O
curr	pointer
->	O
w_state	enum
=	O
LIT	int
;	O
goto	O
tryagain	O
;	O
}	O
}	O
break	O
;	O
case	O
LIT	int
:	O
default	O
:	O
if	O
(	O
curr	pointer
->	O
w_mbcs	int
)	O
if	O
(	O
c	int
<=	O
' '	O
||	O
c	int
==	O
0x7f	int
||	O
(	O
c	int
>=	O
0x80	int
&&	O
c	int
<	O
0xa0	int
&&	O
curr	pointer
->	O
w_c1	int
)	O
)	O
curr	pointer
->	O
w_mbcs	int
=	O
0	int
;	O
if	O
(	O
c	int
<	O
' '	O
)	O
{	O
if	O
(	O
c	int
==	O
'\033'	O
)	O
{	O
curr	pointer
->	O
w_intermediate	int
=	O
0	int
;	O
curr	pointer
->	O
w_state	enum
=	O
ESC	int
;	O
if	O
(	O
curr	pointer
->	O
w_autoaka	int
<	O
0	int
)	O
curr	pointer
->	O
w_autoaka	int
=	O
0	int
;	O
}	O
else	O
Special	function
(	O
c	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
c	int
>=	O
0x80	int
&&	O
c	int
<	O
0xa0	int
&&	O
curr	pointer
->	O
w_c1	int
)	O
if	O
(	O
(	O
curr	pointer
->	O
w_FontR	char
&	O
0xf0	int
)	O
!=	O
0x20	int
||	O
curr	pointer
->	O
w_encoding	O
==	O
UTF8	int
)	O
{	O
switch	O
(	O
c	int
)	O
{	O
case	O
0xc0	int
^	O
'D'	O
:	O
case	O
0xc0	int
^	O
'E'	O
:	O
case	O
0xc0	int
^	O
'H'	O
:	O
case	O
0xc0	int
^	O
'M'	O
:	O
case	O
0xc0	int
^	O
'N'	O
:	O
case	O
0xc0	int
^	O
'O'	O
:	O
DoESC	function
(	O
c	int
^	O
0xc0	int
,	O
0	int
)	O
;	O
break	O
;	O
case	O
0xc0	int
^	O
'['	O
:	O
if	O
(	O
curr	pointer
->	O
w_autoaka	int
<	O
0	int
)	O
curr	pointer
->	O
w_autoaka	int
=	O
0	int
;	O
curr	pointer
->	O
w_NumArgs	int
=	O
0	int
;	O
curr	pointer
->	O
w_intermediate	int
=	O
0	int
;	O
bzero	function
(	O
(	O
char	O
*	O
)	O
curr	pointer
->	O
w_args	array
,	O
MAXARGS	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
curr	pointer
->	O
w_state	enum
=	O
CSI	int
;	O
break	O
;	O
case	O
0xc0	int
^	O
'P'	O
:	O
StringStart	function
(	O
DCS	int
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
!	O
curr	pointer
->	O
w_mbcs	int
)	O
{	O
if	O
(	O
c	int
<	O
0x80	int
||	O
curr	pointer
->	O
w_gr	int
==	O
0	int
)	O
curr	pointer
->	O
w_rend	struct
.	O
font	char
=	O
curr	pointer
->	O
w_FontL	char
;	O
else	O
if	O
(	O
curr	pointer
->	O
w_gr	int
==	O
2	int
&&	O
!	O
curr	pointer
->	O
w_ss	int
)	O
curr	pointer
->	O
w_rend	struct
.	O
font	char
=	O
curr	pointer
->	O
w_FontE	char
;	O
else	O
curr	pointer
->	O
w_rend	struct
.	O
font	char
=	O
curr	pointer
->	O
w_FontR	char
;	O
}	O
if	O
(	O
curr	pointer
->	O
w_encoding	O
==	O
UTF8	int
)	O
{	O
if	O
(	O
curr	pointer
->	O
w_rend	struct
.	O
font	char
==	O
'0'	O
)	O
{	O
struct	O
mchar	struct
mc	struct
,	O
*	O
mcp	pointer
;	O
debug1	O
(	O
"SPECIAL %x\n"	pointer
,	O
c	int
)	O
;	O
mc	struct
.	O
image	char
=	O
c	int
;	O
mc	struct
.	O
mbcs	char
=	O
0	int
;	O
mc	struct
.	O
font	char
=	O
'0'	O
;	O
mc	struct
.	O
fontx	char
=	O
0	int
;	O
mcp	pointer
=	O
recode_mchar	function
(	O
&	O
mc	struct
,	O
0	int
,	O
UTF8	int
)	O
;	O
debug2	O
(	O
"%02x %02x\n"	pointer
,	O
mcp	pointer
->	O
image	char
,	O
mcp	pointer
->	O
font	char
)	O
;	O
c	int
=	O
mcp	pointer
->	O
image	char
|	O
mcp	pointer
->	O
font	char
<<	O
8	int
;	O
}	O
curr	pointer
->	O
w_rend	struct
.	O
font	char
=	O
0	int
;	O
}	O
if	O
(	O
curr	pointer
->	O
w_encoding	O
==	O
UTF8	int
&&	O
utf8_isdouble	function
(	O
c	int
)	O
)	O
curr	pointer
->	O
w_mbcs	int
=	O
0xff	int
;	O
if	O
(	O
curr	pointer
->	O
w_encoding	O
==	O
UTF8	int
&&	O
c	int
>=	O
0x0300	int
&&	O
utf8_iscomb	function
(	O
c	int
)	O
)	O
{	O
int	O
ox	int
,	O
oy	int
;	O
struct	O
mchar	struct
omc	struct
;	O
ox	int
=	O
curr	pointer
->	O
w_x	O
-	O
1	int
;	O
oy	int
=	O
curr	pointer
->	O
w_y	O
;	O
if	O
(	O
ox	int
<	O
0	int
)	O
{	O
ox	int
=	O
curr	pointer
->	O
w_width	O
-	O
1	int
;	O
oy	int
--	O
;	O
}	O
if	O
(	O
oy	int
<	O
0	int
)	O
oy	int
=	O
0	int
;	O
copy_mline2mchar	O
(	O
&	O
omc	struct
,	O
&	O
curr	pointer
->	O
w_mlines	pointer
[	O
oy	int
]	O
,	O
ox	int
)	O
;	O
if	O
(	O
omc	struct
.	O
image	char
==	O
0xff	int
&&	O
omc	struct
.	O
font	char
==	O
0xff	int
&&	O
omc	struct
.	O
fontx	char
==	O
0	int
)	O
{	O
ox	int
--	O
;	O
if	O
(	O
ox	int
>=	O
0	int
)	O
{	O
copy_mline2mchar	O
(	O
&	O
omc	struct
,	O
&	O
curr	pointer
->	O
w_mlines	pointer
[	O
oy	int
]	O
,	O
ox	int
)	O
;	O
omc	struct
.	O
mbcs	char
=	O
0xff	int
;	O
}	O
}	O
if	O
(	O
ox	int
>=	O
0	int
)	O
{	O
utf8_handle_comb	function
(	O
c	int
,	O
&	O
omc	struct
)	O
;	O
MFixLine	function
(	O
curr	pointer
,	O
oy	int
,	O
&	O
omc	struct
)	O
;	O
copy_mchar2mline	O
(	O
&	O
omc	struct
,	O
&	O
curr	pointer
->	O
w_mlines	pointer
[	O
oy	int
]	O
,	O
ox	int
)	O
;	O
LPutChar	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
&	O
omc	struct
,	O
ox	int
,	O
oy	int
)	O
;	O
LGotoPos	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
curr	pointer
->	O
w_x	O
,	O
curr	pointer
->	O
w_y	O
)	O
;	O
}	O
break	O
;	O
}	O
font	char
=	O
curr	pointer
->	O
w_rend	struct
.	O
font	char
;	O
if	O
(	O
font	char
==	O
KANA	char
&&	O
curr	pointer
->	O
w_encoding	O
==	O
SJIS	int
&&	O
curr	pointer
->	O
w_mbcs	int
==	O
0	int
)	O
{	O
debug1	O
(	O
"%x may be first of SJIS\n"	pointer
,	O
c	int
)	O
;	O
if	O
(	O
(	O
0x81	int
<=	O
c	int
&&	O
c	int
<=	O
0x9f	int
)	O
||	O
(	O
0xe0	int
<=	O
c	int
&&	O
c	int
<=	O
0xef	int
)	O
)	O
{	O
debug	O
(	O
"YES!\n"	pointer
)	O
;	O
curr	pointer
->	O
w_mbcs	int
=	O
c	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
font	char
==	O
031	int
&&	O
c	int
==	O
0x80	int
&&	O
!	O
curr	pointer
->	O
w_mbcs	int
)	O
font	char
=	O
curr	pointer
->	O
w_rend	struct
.	O
font	char
=	O
0	int
;	O
if	O
(	O
is_dw_font	O
(	O
font	char
)	O
&&	O
c	int
==	O
' '	O
)	O
font	char
=	O
curr	pointer
->	O
w_rend	struct
.	O
font	char
=	O
0	int
;	O
if	O
(	O
is_dw_font	O
(	O
font	char
)	O
||	O
curr	pointer
->	O
w_mbcs	int
)	O
{	O
int	O
t	int
=	O
c	int
;	O
if	O
(	O
curr	pointer
->	O
w_mbcs	int
==	O
0	int
)	O
{	O
curr	pointer
->	O
w_mbcs	int
=	O
c	int
;	O
break	O
;	O
}	O
if	O
(	O
curr	pointer
->	O
w_x	O
==	O
cols	int
-	O
1	int
)	O
{	O
curr	pointer
->	O
w_x	O
+=	O
curr	pointer
->	O
w_wrap	int
?	O
1	int
:	O
-	O
1	int
;	O
debug1	O
(	O
"Patched w_x to %d\n"	pointer
,	O
curr	pointer
->	O
w_x	O
)	O
;	O
}	O
if	O
(	O
curr	pointer
->	O
w_encoding	O
!=	O
UTF8	int
)	O
{	O
c	int
=	O
curr	pointer
->	O
w_mbcs	int
;	O
if	O
(	O
font	char
==	O
KANA	char
&&	O
curr	pointer
->	O
w_encoding	O
==	O
SJIS	int
)	O
{	O
debug2	O
(	O
"SJIS !! %x %x\n"	pointer
,	O
c	int
,	O
t	int
)	O
;	O
if	O
(	O
0x40	int
<=	O
t	int
&&	O
t	int
<=	O
0xfc	int
&&	O
t	int
!=	O
0x7f	int
)	O
{	O
if	O
(	O
c	int
<=	O
0x9f	int
)	O
c	int
=	O
(	O
c	int
-	O
0x81	int
)	O
*	O
2	int
+	O
0x21	int
;	O
else	O
c	int
=	O
(	O
c	int
-	O
0xc1	int
)	O
*	O
2	int
+	O
0x21	int
;	O
if	O
(	O
t	int
<=	O
0x7e	int
)	O
t	int
-=	O
0x1f	int
;	O
else	O
if	O
(	O
t	int
<=	O
0x9e	int
)	O
t	int
-=	O
0x20	int
;	O
else	O
t	int
-=	O
0x7e	int
,	O
c	int
++	O
;	O
curr	pointer
->	O
w_rend	struct
.	O
font	char
=	O
KANJI	O
;	O
}	O
else	O
{	O
c	int
=	O
t	int
;	O
t	int
=	O
0	int
;	O
}	O
debug2	O
(	O
"SJIS after %x %x\n"	pointer
,	O
c	int
,	O
t	int
)	O
;	O
}	O
if	O
(	O
t	int
&&	O
curr	pointer
->	O
w_gr	int
&&	O
font	char
!=	O
030	int
&&	O
font	char
!=	O
031	int
)	O
{	O
t	int
&=	O
0x7f	int
;	O
if	O
(	O
t	int
<	O
' '	O
)	O
goto	O
tryagain	O
;	O
}	O
if	O
(	O
t	int
==	O
'\177'	O
)	O
break	O
;	O
curr	pointer
->	O
w_mbcs	int
=	O
t	int
;	O
}	O
}	O
if	O
(	O
font	char
==	O
'<'	O
&&	O
c	int
>=	O
' '	O
)	O
{	O
font	char
=	O
curr	pointer
->	O
w_rend	struct
.	O
font	char
=	O
0	int
;	O
c	int
|=	O
0x80	int
;	O
}	O
else	O
if	O
(	O
curr	pointer
->	O
w_gr	int
&&	O
curr	pointer
->	O
w_encoding	O
!=	O
UTF8	int
)	O
{	O
if	O
(	O
c	int
==	O
0x80	int
&&	O
font	char
==	O
0	int
&&	O
curr	pointer
->	O
w_encoding	O
==	O
GBK	int
)	O
c	int
=	O
0xa4	int
;	O
else	O
c	int
&=	O
0x7f	int
;	O
if	O
(	O
c	int
<	O
' '	O
&&	O
font	char
!=	O
031	int
)	O
goto	O
tryagain	O
;	O
}	O
if	O
(	O
c	int
==	O
'\177'	O
)	O
break	O
;	O
curr	pointer
->	O
w_rend	struct
.	O
image	char
=	O
c	int
;	O
if	O
(	O
curr	pointer
->	O
w_encoding	O
==	O
UTF8	int
)	O
{	O
curr	pointer
->	O
w_rend	struct
.	O
font	char
=	O
c	int
>>	O
8	int
;	O
curr	pointer
->	O
w_rend	struct
.	O
fontx	char
=	O
c	int
>>	O
16	int
;	O
}	O
curr	pointer
->	O
w_rend	struct
.	O
mbcs	char
=	O
curr	pointer
->	O
w_mbcs	int
;	O
if	O
(	O
curr	pointer
->	O
w_x	O
<	O
cols	int
-	O
1	int
)	O
{	O
if	O
(	O
curr	pointer
->	O
w_insert	int
)	O
{	O
save_mline	O
(	O
&	O
curr	pointer
->	O
w_mlines	pointer
[	O
curr	pointer
->	O
w_y	O
]	O
,	O
cols	int
)	O
;	O
MInsChar	function
(	O
curr	pointer
,	O
&	O
curr	pointer
->	O
w_rend	struct
,	O
curr	pointer
->	O
w_x	O
,	O
curr	pointer
->	O
w_y	O
)	O
;	O
LInsChar	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
&	O
curr	pointer
->	O
w_rend	struct
,	O
curr	pointer
->	O
w_x	O
,	O
curr	pointer
->	O
w_y	O
,	O
&	O
mline_old	struct
)	O
;	O
curr	pointer
->	O
w_x	O
++	O
;	O
}	O
else	O
{	O
MPutChar	function
(	O
curr	pointer
,	O
&	O
curr	pointer
->	O
w_rend	struct
,	O
curr	pointer
->	O
w_x	O
,	O
curr	pointer
->	O
w_y	O
)	O
;	O
LPutChar	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
&	O
curr	pointer
->	O
w_rend	struct
,	O
curr	pointer
->	O
w_x	O
,	O
curr	pointer
->	O
w_y	O
)	O
;	O
curr	pointer
->	O
w_x	O
++	O
;	O
}	O
}	O
else	O
if	O
(	O
curr	pointer
->	O
w_x	O
==	O
cols	int
-	O
1	int
)	O
{	O
MPutChar	function
(	O
curr	pointer
,	O
&	O
curr	pointer
->	O
w_rend	struct
,	O
curr	pointer
->	O
w_x	O
,	O
curr	pointer
->	O
w_y	O
)	O
;	O
LPutChar	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
&	O
curr	pointer
->	O
w_rend	struct
,	O
curr	pointer
->	O
w_x	O
,	O
curr	pointer
->	O
w_y	O
)	O
;	O
if	O
(	O
curr	pointer
->	O
w_wrap	int
)	O
curr	pointer
->	O
w_x	O
++	O
;	O
}	O
else	O
{	O
MWrapChar	function
(	O
curr	pointer
,	O
&	O
curr	pointer
->	O
w_rend	struct
,	O
curr	pointer
->	O
w_y	O
,	O
curr	pointer
->	O
w_top	int
,	O
curr	pointer
->	O
w_bot	int
,	O
curr	pointer
->	O
w_insert	int
)	O
;	O
LWrapChar	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
&	O
curr	pointer
->	O
w_rend	struct
,	O
curr	pointer
->	O
w_y	O
,	O
curr	pointer
->	O
w_top	int
,	O
curr	pointer
->	O
w_bot	int
,	O
curr	pointer
->	O
w_insert	int
)	O
;	O
if	O
(	O
curr	pointer
->	O
w_y	O
!=	O
curr	pointer
->	O
w_bot	int
&&	O
curr	pointer
->	O
w_y	O
!=	O
curr	pointer
->	O
w_height	O
-	O
1	int
)	O
curr	pointer
->	O
w_y	O
++	O
;	O
curr	pointer
->	O
w_x	O
=	O
1	int
;	O
}	O
if	O
(	O
curr	pointer
->	O
w_mbcs	int
)	O
{	O
curr	pointer
->	O
w_rend	struct
.	O
mbcs	char
=	O
curr	pointer
->	O
w_mbcs	int
=	O
0	int
;	O
curr	pointer
->	O
w_x	O
++	O
;	O
}	O
if	O
(	O
curr	pointer
->	O
w_ss	int
)	O
{	O
curr	pointer
->	O
w_FontL	char
=	O
curr	pointer
->	O
w_charsets	array
[	O
curr	pointer
->	O
w_Charset	int
]	O
;	O
curr	pointer
->	O
w_FontR	char
=	O
curr	pointer
->	O
w_charsets	array
[	O
curr	pointer
->	O
w_CharsetR	int
]	O
;	O
curr	pointer
->	O
w_rend	struct
.	O
font	char
=	O
curr	pointer
->	O
w_FontL	char
;	O
LSetRendition	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
&	O
curr	pointer
->	O
w_rend	struct
)	O
;	O
curr	pointer
->	O
w_ss	int
=	O
0	int
;	O
}	O
break	O
;	O
}	O
}	O
while	O
(	O
--	O
len	int
)	O
;	O
}	O
if	O
(	O
!	O
printcmd	pointer
&&	O
curr	pointer
->	O
w_state	enum
==	O
PRIN	int
)	O
PrintFlush	function
(	O
)	O
;	O
}	O
static	O
void	O
WLogString	function
(	O
p	pointer
,	O
buf	pointer
,	O
len	int
)	O
struct	O
win	struct
*	O
p	pointer
;	O
char	O
*	O
buf	pointer
;	O
int	O
len	int
;	O
{	O
if	O
(	O
!	O
p	pointer
->	O
w_log	pointer
)	O
return	O
;	O
if	O
(	O
logtstamp_on	int
&&	O
p	pointer
->	O
w_logsilence	int
>=	O
logtstamp_after	int
*	O
2	int
)	O
{	O
char	O
*	O
t	int
=	O
MakeWinMsg	function
(	O
logtstamp_string	pointer
,	O
p	pointer
,	O
'%'	O
)	O
;	O
logfwrite	function
(	O
p	pointer
->	O
w_log	pointer
,	O
t	int
,	O
strlen	function
(	O
t	int
)	O
)	O
;	O
}	O
p	pointer
->	O
w_logsilence	int
=	O
0	int
;	O
if	O
(	O
logfwrite	function
(	O
p	pointer
->	O
w_log	pointer
,	O
buf	pointer
,	O
len	int
)	O
<	O
1	int
)	O
{	O
WMsg	function
(	O
p	pointer
,	O
errno	O
,	O
"Error writing logfile"	pointer
)	O
;	O
logfclose	function
(	O
p	pointer
->	O
w_log	pointer
)	O
;	O
p	pointer
->	O
w_log	pointer
=	O
0	int
;	O
}	O
if	O
(	O
!	O
log_flush	int
)	O
logfflush	function
(	O
p	pointer
->	O
w_log	pointer
)	O
;	O
}	O
static	O
int	O
Special	function
(	O
c	int
)	O
register	O
int	O
c	int
;	O
{	O
switch	O
(	O
c	int
)	O
{	O
case	O
'\b'	O
:	O
BackSpace	function
(	O
)	O
;	O
return	O
1	int
;	O
case	O
'\r'	O
:	O
Return	function
(	O
)	O
;	O
return	O
1	int
;	O
case	O
'\n'	O
:	O
if	O
(	O
curr	pointer
->	O
w_autoaka	int
)	O
FindAKA	function
(	O
)	O
;	O
case	O
'\013'	O
:	O
LineFeed	function
(	O
0	int
)	O
;	O
return	O
1	int
;	O
case	O
'\007'	O
:	O
WBell	function
(	O
curr	pointer
,	O
visual_bell	int
)	O
;	O
return	O
1	int
;	O
case	O
'\t'	O
:	O
ForwardTab	function
(	O
)	O
;	O
return	O
1	int
;	O
case	O
'\017'	O
:	O
MapCharset	function
(	O
G0	int
)	O
;	O
return	O
1	int
;	O
case	O
'\016'	O
:	O
MapCharset	function
(	O
G1	int
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
DoESC	function
(	O
c	int
,	O
intermediate	int
)	O
int	O
c	int
,	O
intermediate	int
;	O
{	O
debug2	O
(	O
"DoESC: %x - inter = %x\n"	pointer
,	O
c	int
,	O
intermediate	int
)	O
;	O
switch	O
(	O
intermediate	int
)	O
{	O
case	O
0	int
:	O
switch	O
(	O
c	int
)	O
{	O
case	O
'E'	O
:	O
LineFeed	function
(	O
1	int
)	O
;	O
break	O
;	O
case	O
'D'	O
:	O
LineFeed	function
(	O
0	int
)	O
;	O
break	O
;	O
case	O
'M'	O
:	O
ReverseLineFeed	function
(	O
)	O
;	O
break	O
;	O
case	O
'H'	O
:	O
curr	pointer
->	O
w_tabs	pointer
[	O
curr	pointer
->	O
w_x	O
]	O
=	O
1	int
;	O
break	O
;	O
case	O
'Z'	O
:	O
Report	function
(	O
"\033[?%d;%dc"	pointer
,	O
1	int
,	O
2	int
)	O
;	O
break	O
;	O
case	O
'7'	O
:	O
SaveCursor	function
(	O
&	O
curr	pointer
->	O
w_saved	struct
)	O
;	O
break	O
;	O
case	O
'8'	O
:	O
RestoreCursor	function
(	O
&	O
curr	pointer
->	O
w_saved	struct
)	O
;	O
break	O
;	O
case	O
'c'	O
:	O
ClearScreen	function
(	O
)	O
;	O
ResetWindow	function
(	O
curr	pointer
)	O
;	O
LKeypadMode	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
0	int
)	O
;	O
LCursorkeysMode	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
0	int
)	O
;	O
LGotoPos	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
curr	pointer
->	O
w_x	O
,	O
curr	pointer
->	O
w_y	O
)	O
;	O
break	O
;	O
case	O
'='	O
:	O
LKeypadMode	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
curr	pointer
->	O
w_keypad	int
=	O
1	int
)	O
;	O
break	O
;	O
case	O
'>'	O
:	O
LKeypadMode	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
curr	pointer
->	O
w_keypad	int
=	O
0	int
)	O
;	O
break	O
;	O
case	O
'n'	O
:	O
MapCharset	function
(	O
G2	int
)	O
;	O
break	O
;	O
case	O
'o'	O
:	O
MapCharset	function
(	O
G3	int
)	O
;	O
break	O
;	O
case	O
'~'	O
:	O
MapCharsetR	function
(	O
G1	int
)	O
;	O
break	O
;	O
case	O
'}'	O
:	O
MapCharsetR	function
(	O
G2	int
)	O
;	O
break	O
;	O
case	O
'|'	O
:	O
MapCharsetR	function
(	O
G3	int
)	O
;	O
break	O
;	O
case	O
'N'	O
:	O
if	O
(	O
curr	pointer
->	O
w_charsets	array
[	O
curr	pointer
->	O
w_Charset	int
]	O
!=	O
curr	pointer
->	O
w_charsets	array
[	O
G2	int
]	O
||	O
curr	pointer
->	O
w_charsets	array
[	O
curr	pointer
->	O
w_CharsetR	int
]	O
!=	O
curr	pointer
->	O
w_charsets	array
[	O
G2	int
]	O
)	O
curr	pointer
->	O
w_FontR	char
=	O
curr	pointer
->	O
w_FontL	char
=	O
curr	pointer
->	O
w_charsets	array
[	O
curr	pointer
->	O
w_ss	int
=	O
G2	int
]	O
;	O
else	O
curr	pointer
->	O
w_ss	int
=	O
0	int
;	O
break	O
;	O
case	O
'O'	O
:	O
if	O
(	O
curr	pointer
->	O
w_charsets	array
[	O
curr	pointer
->	O
w_Charset	int
]	O
!=	O
curr	pointer
->	O
w_charsets	array
[	O
G3	int
]	O
||	O
curr	pointer
->	O
w_charsets	array
[	O
curr	pointer
->	O
w_CharsetR	int
]	O
!=	O
curr	pointer
->	O
w_charsets	array
[	O
G3	int
]	O
)	O
curr	pointer
->	O
w_FontR	char
=	O
curr	pointer
->	O
w_FontL	char
=	O
curr	pointer
->	O
w_charsets	array
[	O
curr	pointer
->	O
w_ss	int
=	O
G3	int
]	O
;	O
else	O
curr	pointer
->	O
w_ss	int
=	O
0	int
;	O
break	O
;	O
case	O
'g'	O
:	O
WBell	function
(	O
curr	pointer
,	O
1	int
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
'#'	O
:	O
switch	O
(	O
c	int
)	O
{	O
case	O
'8'	O
:	O
FillWithEs	function
(	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
'('	O
:	O
DesignateCharset	function
(	O
c	int
,	O
G0	int
)	O
;	O
break	O
;	O
case	O
')'	O
:	O
DesignateCharset	function
(	O
c	int
,	O
G1	int
)	O
;	O
break	O
;	O
case	O
'*'	O
:	O
DesignateCharset	function
(	O
c	int
,	O
G2	int
)	O
;	O
break	O
;	O
case	O
'+'	O
:	O
DesignateCharset	function
(	O
c	int
,	O
G3	int
)	O
;	O
break	O
;	O
case	O
'$'	O
:	O
case	O
'$'	O
<<	O
8	int
|	O
'('	O
:	O
DesignateCharset	function
(	O
c	int
&	O
037	int
,	O
G0	int
)	O
;	O
break	O
;	O
case	O
'$'	O
<<	O
8	int
|	O
')'	O
:	O
DesignateCharset	function
(	O
c	int
&	O
037	int
,	O
G1	int
)	O
;	O
break	O
;	O
case	O
'$'	O
<<	O
8	int
|	O
'*'	O
:	O
DesignateCharset	function
(	O
c	int
&	O
037	int
,	O
G2	int
)	O
;	O
break	O
;	O
case	O
'$'	O
<<	O
8	int
|	O
'+'	O
:	O
DesignateCharset	function
(	O
c	int
&	O
037	int
,	O
G3	int
)	O
;	O
break	O
;	O
}	O
}	O
static	O
void	O
DoCSI	function
(	O
c	int
,	O
intermediate	int
)	O
int	O
c	int
,	O
intermediate	int
;	O
{	O
register	O
int	O
i	int
,	O
a1	int
=	O
curr	pointer
->	O
w_args	array
[	O
0	int
]	O
,	O
a2	int
=	O
curr	pointer
->	O
w_args	array
[	O
1	int
]	O
;	O
if	O
(	O
curr	pointer
->	O
w_NumArgs	int
>	O
MAXARGS	int
)	O
curr	pointer
->	O
w_NumArgs	int
=	O
MAXARGS	int
;	O
switch	O
(	O
intermediate	int
)	O
{	O
case	O
0	int
:	O
switch	O
(	O
c	int
)	O
{	O
case	O
'H'	O
:	O
case	O
'f'	O
:	O
if	O
(	O
a1	int
<	O
1	int
)	O
a1	int
=	O
1	int
;	O
if	O
(	O
curr	pointer
->	O
w_origin	int
)	O
a1	int
+=	O
curr	pointer
->	O
w_top	int
;	O
if	O
(	O
a1	int
>	O
rows	int
)	O
a1	int
=	O
rows	int
;	O
if	O
(	O
a2	int
<	O
1	int
)	O
a2	int
=	O
1	int
;	O
if	O
(	O
a2	int
>	O
cols	int
)	O
a2	int
=	O
cols	int
;	O
LGotoPos	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
--	O
a2	int
,	O
--	O
a1	int
)	O
;	O
curr	pointer
->	O
w_x	O
=	O
a2	int
;	O
curr	pointer
->	O
w_y	O
=	O
a1	int
;	O
if	O
(	O
curr	pointer
->	O
w_autoaka	int
)	O
curr	pointer
->	O
w_autoaka	int
=	O
a1	int
+	O
1	int
;	O
break	O
;	O
case	O
'J'	O
:	O
if	O
(	O
a1	int
<	O
0	int
||	O
a1	int
>	O
2	int
)	O
a1	int
=	O
0	int
;	O
switch	O
(	O
a1	int
)	O
{	O
case	O
0	int
:	O
ClearToEOS	function
(	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
ClearFromBOS	function
(	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
ClearScreen	function
(	O
)	O
;	O
LGotoPos	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
curr	pointer
->	O
w_x	O
,	O
curr	pointer
->	O
w_y	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
'K'	O
:	O
if	O
(	O
a1	int
<	O
0	int
||	O
a1	int
>	O
2	int
)	O
a1	int
%=	O
3	int
;	O
switch	O
(	O
a1	int
)	O
{	O
case	O
0	int
:	O
ClearLineRegion	function
(	O
curr	pointer
->	O
w_x	O
,	O
cols	int
-	O
1	int
)	O
;	O
break	O
;	O
case	O
1	int
:	O
ClearLineRegion	function
(	O
0	int
,	O
curr	pointer
->	O
w_x	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
ClearLineRegion	function
(	O
0	int
,	O
cols	int
-	O
1	int
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
'X'	O
:	O
a1	int
=	O
curr	pointer
->	O
w_x	O
+	O
(	O
a1	int
?	O
a1	int
-	O
1	int
:	O
0	int
)	O
;	O
ClearLineRegion	function
(	O
curr	pointer
->	O
w_x	O
,	O
a1	int
<	O
cols	int
?	O
a1	int
:	O
cols	int
-	O
1	int
)	O
;	O
break	O
;	O
case	O
'A'	O
:	O
CursorUp	function
(	O
a1	int
?	O
a1	int
:	O
1	int
)	O
;	O
break	O
;	O
case	O
'B'	O
:	O
CursorDown	function
(	O
a1	int
?	O
a1	int
:	O
1	int
)	O
;	O
break	O
;	O
case	O
'C'	O
:	O
CursorRight	function
(	O
a1	int
?	O
a1	int
:	O
1	int
)	O
;	O
break	O
;	O
case	O
'D'	O
:	O
CursorLeft	function
(	O
a1	int
?	O
a1	int
:	O
1	int
)	O
;	O
break	O
;	O
case	O
'E'	O
:	O
curr	pointer
->	O
w_x	O
=	O
0	int
;	O
CursorDown	function
(	O
a1	int
?	O
a1	int
:	O
1	int
)	O
;	O
break	O
;	O
case	O
'F'	O
:	O
curr	pointer
->	O
w_x	O
=	O
0	int
;	O
CursorUp	function
(	O
a1	int
?	O
a1	int
:	O
1	int
)	O
;	O
break	O
;	O
case	O
'G'	O
:	O
case	O
'`'	O
:	O
curr	pointer
->	O
w_x	O
=	O
a1	int
?	O
a1	int
-	O
1	int
:	O
0	int
;	O
if	O
(	O
curr	pointer
->	O
w_x	O
>=	O
cols	int
)	O
curr	pointer
->	O
w_x	O
=	O
cols	int
-	O
1	int
;	O
LGotoPos	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
curr	pointer
->	O
w_x	O
,	O
curr	pointer
->	O
w_y	O
)	O
;	O
break	O
;	O
case	O
'd'	O
:	O
curr	pointer
->	O
w_y	O
=	O
a1	int
?	O
a1	int
-	O
1	int
:	O
0	int
;	O
if	O
(	O
curr	pointer
->	O
w_y	O
>=	O
rows	int
)	O
curr	pointer
->	O
w_y	O
=	O
rows	int
-	O
1	int
;	O
LGotoPos	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
curr	pointer
->	O
w_x	O
,	O
curr	pointer
->	O
w_y	O
)	O
;	O
break	O
;	O
case	O
'm'	O
:	O
SelectRendition	function
(	O
)	O
;	O
break	O
;	O
case	O
'g'	O
:	O
if	O
(	O
a1	int
==	O
0	int
)	O
curr	pointer
->	O
w_tabs	pointer
[	O
curr	pointer
->	O
w_x	O
]	O
=	O
0	int
;	O
else	O
if	O
(	O
a1	int
==	O
3	int
)	O
bzero	function
(	O
curr	pointer
->	O
w_tabs	pointer
,	O
cols	int
)	O
;	O
break	O
;	O
case	O
'r'	O
:	O
if	O
(	O
!	O
a1	int
)	O
a1	int
=	O
1	int
;	O
if	O
(	O
!	O
a2	int
)	O
a2	int
=	O
rows	int
;	O
if	O
(	O
a1	int
<	O
1	int
||	O
a2	int
>	O
rows	int
||	O
a1	int
>=	O
a2	int
)	O
break	O
;	O
curr	pointer
->	O
w_top	int
=	O
a1	int
-	O
1	int
;	O
curr	pointer
->	O
w_bot	int
=	O
a2	int
-	O
1	int
;	O
if	O
(	O
curr	pointer
->	O
w_origin	int
)	O
{	O
curr	pointer
->	O
w_y	O
=	O
curr	pointer
->	O
w_top	int
;	O
curr	pointer
->	O
w_x	O
=	O
0	int
;	O
}	O
else	O
curr	pointer
->	O
w_y	O
=	O
curr	pointer
->	O
w_x	O
=	O
0	int
;	O
LGotoPos	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
curr	pointer
->	O
w_x	O
,	O
curr	pointer
->	O
w_y	O
)	O
;	O
break	O
;	O
case	O
's'	O
:	O
SaveCursor	function
(	O
&	O
curr	pointer
->	O
w_saved	struct
)	O
;	O
break	O
;	O
case	O
't'	O
:	O
switch	O
(	O
a1	int
)	O
{	O
case	O
11	int
:	O
if	O
(	O
curr	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
)	O
Report	function
(	O
"\033[1t"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
else	O
Report	function
(	O
"\033[2t"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
break	O
;	O
case	O
7	int
:	O
LRefreshAll	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
0	int
)	O
;	O
break	O
;	O
case	O
21	int
:	O
a1	int
=	O
strlen	function
(	O
curr	pointer
->	O
w_title	pointer
)	O
;	O
if	O
(	O
(	O
unsigned	O
)	O
(	O
curr	pointer
->	O
w_inlen	int
+	O
5	int
+	O
a1	int
)	O
<=	O
sizeof	O
(	O
curr	pointer
->	O
w_inbuf	array
)	O
)	O
{	O
bcopy	function
(	O
"\033]l"	pointer
,	O
curr	pointer
->	O
w_inbuf	array
+	O
curr	pointer
->	O
w_inlen	int
,	O
3	int
)	O
;	O
bcopy	function
(	O
curr	pointer
->	O
w_title	pointer
,	O
curr	pointer
->	O
w_inbuf	array
+	O
curr	pointer
->	O
w_inlen	int
+	O
3	int
,	O
a1	int
)	O
;	O
bcopy	function
(	O
"\033\\"	pointer
,	O
curr	pointer
->	O
w_inbuf	array
+	O
curr	pointer
->	O
w_inlen	int
+	O
3	int
+	O
a1	int
,	O
2	int
)	O
;	O
curr	pointer
->	O
w_inlen	int
+=	O
5	int
+	O
a1	int
;	O
}	O
break	O
;	O
case	O
8	int
:	O
a1	int
=	O
curr	pointer
->	O
w_args	array
[	O
2	int
]	O
;	O
if	O
(	O
a1	int
<	O
1	int
)	O
a1	int
=	O
curr	pointer
->	O
w_width	O
;	O
if	O
(	O
a2	int
<	O
1	int
)	O
a2	int
=	O
curr	pointer
->	O
w_height	O
;	O
if	O
(	O
a1	int
>	O
10000	int
||	O
a2	int
>	O
10000	int
)	O
break	O
;	O
WChangeSize	function
(	O
curr	pointer
,	O
a1	int
,	O
a2	int
)	O
;	O
cols	int
=	O
curr	pointer
->	O
w_width	O
;	O
rows	int
=	O
curr	pointer
->	O
w_height	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
case	O
'u'	O
:	O
RestoreCursor	function
(	O
&	O
curr	pointer
->	O
w_saved	struct
)	O
;	O
break	O
;	O
case	O
'I'	O
:	O
if	O
(	O
!	O
a1	int
)	O
a1	int
=	O
1	int
;	O
while	O
(	O
a1	int
--	O
)	O
ForwardTab	function
(	O
)	O
;	O
break	O
;	O
case	O
'Z'	O
:	O
if	O
(	O
!	O
a1	int
)	O
a1	int
=	O
1	int
;	O
while	O
(	O
a1	int
--	O
)	O
BackwardTab	function
(	O
)	O
;	O
break	O
;	O
case	O
'L'	O
:	O
InsertLine	function
(	O
a1	int
?	O
a1	int
:	O
1	int
)	O
;	O
break	O
;	O
case	O
'M'	O
:	O
DeleteLine	function
(	O
a1	int
?	O
a1	int
:	O
1	int
)	O
;	O
break	O
;	O
case	O
'P'	O
:	O
DeleteChar	function
(	O
a1	int
?	O
a1	int
:	O
1	int
)	O
;	O
break	O
;	O
case	O
'@'	O
:	O
InsertChar	function
(	O
a1	int
?	O
a1	int
:	O
1	int
)	O
;	O
break	O
;	O
case	O
'h'	O
:	O
ASetMode	function
(	O
1	int
)	O
;	O
break	O
;	O
case	O
'l'	O
:	O
ASetMode	function
(	O
0	int
)	O
;	O
break	O
;	O
case	O
'i'	O
:	O
if	O
(	O
a1	int
==	O
5	int
)	O
PrintStart	function
(	O
)	O
;	O
break	O
;	O
case	O
'n'	O
:	O
if	O
(	O
a1	int
==	O
5	int
)	O
Report	function
(	O
"\033[0n"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
else	O
if	O
(	O
a1	int
==	O
6	int
)	O
Report	function
(	O
"\033[%d;%dR"	pointer
,	O
curr	pointer
->	O
w_y	O
+	O
1	int
,	O
curr	pointer
->	O
w_x	O
+	O
1	int
)	O
;	O
break	O
;	O
case	O
'c'	O
:	O
if	O
(	O
a1	int
==	O
0	int
)	O
Report	function
(	O
"\033[?%d;%dc"	pointer
,	O
1	int
,	O
2	int
)	O
;	O
break	O
;	O
case	O
'x'	O
:	O
if	O
(	O
a1	int
==	O
0	int
||	O
a1	int
==	O
1	int
)	O
Report	function
(	O
"\033[%d;1;1;112;112;1;0x"	pointer
,	O
a1	int
+	O
2	int
,	O
0	int
)	O
;	O
break	O
;	O
case	O
'p'	O
:	O
if	O
(	O
a1	int
==	O
6	int
||	O
a1	int
==	O
7	int
)	O
{	O
curr	pointer
->	O
w_curinv	int
=	O
7	int
-	O
a1	int
;	O
LCursorVisibility	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
curr	pointer
->	O
w_curinv	int
?	O
-	O
1	int
:	O
curr	pointer
->	O
w_curvvis	int
)	O
;	O
}	O
break	O
;	O
case	O
'S'	O
:	O
ScrollRegion	function
(	O
a1	int
?	O
a1	int
:	O
1	int
)	O
;	O
break	O
;	O
case	O
'T'	O
:	O
case	O
'^'	O
:	O
ScrollRegion	function
(	O
a1	int
?	O
-	O
a1	int
:	O
-	O
1	int
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
'?'	O
:	O
for	O
(	O
a2	int
=	O
0	int
;	O
a2	int
<	O
curr	pointer
->	O
w_NumArgs	int
;	O
a2	int
++	O
)	O
{	O
a1	int
=	O
curr	pointer
->	O
w_args	array
[	O
a2	int
]	O
;	O
debug2	O
(	O
"\\E[?%d%c\n"	pointer
,	O
a1	int
,	O
c	int
)	O
;	O
if	O
(	O
c	int
!=	O
'h'	O
&&	O
c	int
!=	O
'l'	O
)	O
break	O
;	O
i	int
=	O
(	O
c	int
==	O
'h'	O
)	O
;	O
switch	O
(	O
a1	int
)	O
{	O
case	O
1	int
:	O
LCursorkeysMode	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
curr	pointer
->	O
w_cursorkeys	int
=	O
i	int
)	O
;	O
break	O
;	O
case	O
2	int
:	O
if	O
(	O
i	int
)	O
{	O
if	O
(	O
curr	pointer
->	O
w_encoding	O
)	O
break	O
;	O
curr	pointer
->	O
w_charsets	array
[	O
0	int
]	O
=	O
curr	pointer
->	O
w_charsets	array
[	O
1	int
]	O
=	O
curr	pointer
->	O
w_charsets	array
[	O
2	int
]	O
=	O
curr	pointer
->	O
w_charsets	array
[	O
3	int
]	O
=	O
curr	pointer
->	O
w_FontL	char
=	O
curr	pointer
->	O
w_FontR	char
=	O
ASCII	int
;	O
curr	pointer
->	O
w_Charset	int
=	O
0	int
;	O
curr	pointer
->	O
w_CharsetR	int
=	O
2	int
;	O
curr	pointer
->	O
w_ss	int
=	O
0	int
;	O
}	O
break	O
;	O
case	O
3	int
:	O
i	int
=	O
(	O
i	int
?	O
Z0width	int
:	O
Z1width	int
)	O
;	O
ClearScreen	function
(	O
)	O
;	O
curr	pointer
->	O
w_x	O
=	O
0	int
;	O
curr	pointer
->	O
w_y	O
=	O
0	int
;	O
WChangeSize	function
(	O
curr	pointer
,	O
i	int
,	O
curr	pointer
->	O
w_height	O
)	O
;	O
cols	int
=	O
curr	pointer
->	O
w_width	O
;	O
rows	int
=	O
curr	pointer
->	O
w_height	O
;	O
break	O
;	O
case	O
5	int
:	O
if	O
(	O
i	int
!=	O
curr	pointer
->	O
w_revvid	int
)	O
WReverseVideo	function
(	O
curr	pointer
,	O
i	int
)	O
;	O
curr	pointer
->	O
w_revvid	int
=	O
i	int
;	O
break	O
;	O
case	O
6	int
:	O
if	O
(	O
(	O
curr	pointer
->	O
w_origin	int
=	O
i	int
)	O
!=	O
0	int
)	O
{	O
curr	pointer
->	O
w_y	O
=	O
curr	pointer
->	O
w_top	int
;	O
curr	pointer
->	O
w_x	O
=	O
0	int
;	O
}	O
else	O
curr	pointer
->	O
w_y	O
=	O
curr	pointer
->	O
w_x	O
=	O
0	int
;	O
LGotoPos	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
curr	pointer
->	O
w_x	O
,	O
curr	pointer
->	O
w_y	O
)	O
;	O
break	O
;	O
case	O
7	int
:	O
curr	pointer
->	O
w_wrap	int
=	O
i	int
;	O
break	O
;	O
case	O
9	int
:	O
curr	pointer
->	O
w_mouse	int
=	O
i	int
?	O
9	int
:	O
0	int
;	O
LMouseMode	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
curr	pointer
->	O
w_mouse	int
)	O
;	O
break	O
;	O
case	O
25	int
:	O
curr	pointer
->	O
w_curinv	int
=	O
!	O
i	int
;	O
LCursorVisibility	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
curr	pointer
->	O
w_curinv	int
?	O
-	O
1	int
:	O
curr	pointer
->	O
w_curvvis	int
)	O
;	O
break	O
;	O
case	O
47	int
:	O
case	O
1047	int
:	O
case	O
1049	int
:	O
if	O
(	O
use_altscreen	int
)	O
{	O
if	O
(	O
i	int
)	O
{	O
if	O
(	O
!	O
curr	pointer
->	O
w_alt	struct
.	O
on	int
)	O
{	O
SaveCursor	function
(	O
&	O
curr	pointer
->	O
w_alt	struct
.	O
cursor	struct
)	O
;	O
EnterAltScreen	function
(	O
curr	pointer
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
curr	pointer
->	O
w_alt	struct
.	O
on	int
)	O
{	O
RestoreCursor	function
(	O
&	O
curr	pointer
->	O
w_alt	struct
.	O
cursor	struct
)	O
;	O
LeaveAltScreen	function
(	O
curr	pointer
)	O
;	O
}	O
}	O
if	O
(	O
a1	int
==	O
47	int
&&	O
!	O
i	int
)	O
curr	pointer
->	O
w_saved	struct
.	O
on	int
=	O
0	int
;	O
LRefreshAll	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
0	int
)	O
;	O
LGotoPos	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
curr	pointer
->	O
w_x	O
,	O
curr	pointer
->	O
w_y	O
)	O
;	O
}	O
break	O
;	O
case	O
1048	int
:	O
if	O
(	O
i	int
)	O
SaveCursor	function
(	O
&	O
curr	pointer
->	O
w_saved	struct
)	O
;	O
else	O
RestoreCursor	function
(	O
&	O
curr	pointer
->	O
w_saved	struct
)	O
;	O
break	O
;	O
case	O
1000	int
:	O
case	O
1001	int
:	O
case	O
1002	int
:	O
case	O
1003	int
:	O
curr	pointer
->	O
w_mouse	int
=	O
i	int
?	O
a1	int
:	O
0	int
;	O
LMouseMode	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
curr	pointer
->	O
w_mouse	int
)	O
;	O
break	O
;	O
case	O
1006	int
:	O
curr	pointer
->	O
w_extmouse	int
=	O
i	int
?	O
a1	int
:	O
0	int
;	O
LExtMouseMode	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
curr	pointer
->	O
w_extmouse	int
)	O
;	O
break	O
;	O
}	O
}	O
break	O
;	O
case	O
'>'	O
:	O
switch	O
(	O
c	int
)	O
{	O
case	O
'c'	O
:	O
if	O
(	O
a1	int
==	O
0	int
)	O
Report	function
(	O
"\033[>%d;%d;0c"	pointer
,	O
83	int
,	O
nversion	int
)	O
;	O
break	O
;	O
}	O
break	O
;	O
}	O
}	O
static	O
void	O
StringStart	function
(	O
type	enum
)	O
enum	O
string_t	enum
type	enum
;	O
{	O
curr	pointer
->	O
w_StringType	enum
=	O
type	enum
;	O
curr	pointer
->	O
w_stringp	pointer
=	O
curr	pointer
->	O
w_string	array
;	O
curr	pointer
->	O
w_state	enum
=	O
ASTR	int
;	O
}	O
static	O
void	O
StringChar	function
(	O
c	int
)	O
int	O
c	int
;	O
{	O
if	O
(	O
curr	pointer
->	O
w_stringp	pointer
>=	O
curr	pointer
->	O
w_string	array
+	O
MAXSTR	int
-	O
1	int
)	O
curr	pointer
->	O
w_state	enum
=	O
LIT	int
;	O
else	O
*	O
(	O
curr	pointer
->	O
w_stringp	pointer
)	O
++	O
=	O
c	int
;	O
}	O
static	O
int	O
StringEnd	function
(	O
)	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
char	O
*	O
p	pointer
;	O
int	O
typ	int
;	O
char	O
*	O
t	int
;	O
t	int
=	O
curr	pointer
->	O
w_state	enum
==	O
STRESC	int
?	O
"\033\\"	pointer
:	O
"\a"	pointer
;	O
curr	pointer
->	O
w_state	enum
=	O
LIT	int
;	O
*	O
curr	pointer
->	O
w_stringp	pointer
=	O
'\0'	O
;	O
switch	O
(	O
curr	pointer
->	O
w_StringType	enum
)	O
{	O
case	O
OSC	int
:	O
if	O
(	O
curr	pointer
->	O
w_string	array
[	O
0	int
]	O
==	O
';'	O
||	O
(	O
p	pointer
=	O
index	function
(	O
curr	pointer
->	O
w_string	array
,	O
';'	O
)	O
)	O
==	O
0	int
)	O
break	O
;	O
typ	int
=	O
atoi	function
(	O
curr	pointer
->	O
w_string	array
)	O
;	O
p	pointer
++	O
;	O
if	O
(	O
typ	int
==	O
83	int
)	O
{	O
char	O
*	O
args	pointer
[	O
MAXARGS	int
]	O
;	O
int	O
argl	pointer
[	O
MAXARGS	int
]	O
;	O
struct	O
acluser	struct
*	O
windowuser	pointer
;	O
windowuser	pointer
=	O
*	O
FindUserPtr	function
(	O
":window:"	pointer
)	O
;	O
if	O
(	O
windowuser	pointer
&&	O
Parse	function
(	O
p	pointer
,	O
sizeof	O
(	O
curr	pointer
->	O
w_string	array
)	O
-	O
(	O
p	pointer
-	O
curr	pointer
->	O
w_string	array
)	O
,	O
args	pointer
,	O
argl	pointer
)	O
)	O
{	O
for	O
(	O
display	struct
=	O
displays	pointer
;	O
display	struct
;	O
display	struct
=	O
display	struct
->	O
d_next	pointer
)	O
if	O
(	O
D_forecv	O
->	O
c_layer	pointer
->	O
l_bottom	pointer
==	O
&	O
curr	pointer
->	O
w_layer	struct
)	O
break	O
;	O
if	O
(	O
display	struct
==	O
0	int
&&	O
curr	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
)	O
display	struct
=	O
curr	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
->	O
c_display	pointer
;	O
if	O
(	O
display	struct
==	O
0	int
)	O
display	struct
=	O
displays	pointer
;	O
EffectiveAclUser	pointer
=	O
windowuser	pointer
;	O
fore	pointer
=	O
curr	pointer
;	O
flayer	pointer
=	O
fore	pointer
->	O
w_savelayer	pointer
?	O
fore	pointer
->	O
w_savelayer	pointer
:	O
&	O
fore	pointer
->	O
w_layer	struct
;	O
DoCommand	function
(	O
args	pointer
,	O
argl	pointer
)	O
;	O
EffectiveAclUser	pointer
=	O
0	int
;	O
fore	pointer
=	O
0	int
;	O
flayer	pointer
=	O
0	int
;	O
}	O
break	O
;	O
}	O
if	O
(	O
typ	int
<	O
0	int
||	O
typ	int
>	O
2	int
)	O
break	O
;	O
curr	pointer
->	O
w_stringp	pointer
-=	O
p	pointer
-	O
curr	pointer
->	O
w_string	array
;	O
if	O
(	O
curr	pointer
->	O
w_stringp	pointer
>	O
curr	pointer
->	O
w_string	array
)	O
bcopy	function
(	O
p	pointer
,	O
curr	pointer
->	O
w_string	array
,	O
curr	pointer
->	O
w_stringp	pointer
-	O
curr	pointer
->	O
w_string	array
)	O
;	O
*	O
curr	pointer
->	O
w_stringp	pointer
=	O
'\0'	O
;	O
case	O
APC	int
:	O
if	O
(	O
curr	pointer
->	O
w_hstatus	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
curr	pointer
->	O
w_hstatus	pointer
,	O
curr	pointer
->	O
w_string	array
)	O
==	O
0	int
)	O
break	O
;	O
free	function
(	O
curr	pointer
->	O
w_hstatus	pointer
)	O
;	O
curr	pointer
->	O
w_hstatus	pointer
=	O
0	int
;	O
}	O
if	O
(	O
curr	pointer
->	O
w_string	array
!=	O
curr	pointer
->	O
w_stringp	pointer
)	O
curr	pointer
->	O
w_hstatus	pointer
=	O
SaveStr	function
(	O
curr	pointer
->	O
w_string	array
)	O
;	O
WindowChanged	function
(	O
curr	pointer
,	O
'h'	O
)	O
;	O
break	O
;	O
case	O
PM	int
:	O
case	O
GM	int
:	O
for	O
(	O
display	struct
=	O
displays	pointer
;	O
display	struct
;	O
display	struct
=	O
display	struct
->	O
d_next	pointer
)	O
{	O
for	O
(	O
cv	pointer
=	O
D_cvlist	O
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_next	pointer
)	O
if	O
(	O
cv	pointer
->	O
c_layer	pointer
->	O
l_bottom	pointer
==	O
&	O
curr	pointer
->	O
w_layer	struct
)	O
break	O
;	O
if	O
(	O
cv	pointer
||	O
curr	pointer
->	O
w_StringType	enum
==	O
GM	int
)	O
MakeStatus	function
(	O
curr	pointer
->	O
w_string	array
)	O
;	O
}	O
return	O
-	O
1	int
;	O
case	O
DCS	int
:	O
LAY_DISPLAYS	O
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
AddStr	function
(	O
curr	pointer
->	O
w_string	array
)	O
)	O
;	O
break	O
;	O
case	O
AKA	int
:	O
if	O
(	O
curr	pointer
->	O
w_title	pointer
==	O
curr	pointer
->	O
w_akabuf	array
&&	O
!	O
*	O
curr	pointer
->	O
w_string	array
)	O
break	O
;	O
if	O
(	O
curr	pointer
->	O
w_dynamicaka	int
)	O
ChangeAKA	function
(	O
curr	pointer
,	O
curr	pointer
->	O
w_string	array
,	O
strlen	function
(	O
curr	pointer
->	O
w_string	array
)	O
)	O
;	O
if	O
(	O
!	O
*	O
curr	pointer
->	O
w_string	array
)	O
curr	pointer
->	O
w_autoaka	int
=	O
curr	pointer
->	O
w_y	O
+	O
1	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
PrintStart	function
(	O
)	O
{	O
curr	pointer
->	O
w_pdisplay	pointer
=	O
0	int
;	O
display	struct
=	O
curr	pointer
->	O
w_lastdisp	pointer
;	O
if	O
(	O
!	O
(	O
display	struct
&&	O
curr	pointer
==	O
D_fore	O
&&	O
(	O
printcmd	pointer
||	O
D_PO	O
)	O
)	O
)	O
for	O
(	O
display	struct
=	O
displays	pointer
;	O
display	struct
;	O
display	struct
=	O
display	struct
->	O
d_next	pointer
)	O
if	O
(	O
curr	pointer
==	O
D_fore	O
&&	O
(	O
printcmd	pointer
||	O
D_PO	O
)	O
)	O
break	O
;	O
if	O
(	O
!	O
display	struct
)	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
for	O
(	O
cv	pointer
=	O
curr	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_lnext	pointer
)	O
{	O
display	struct
=	O
cv	pointer
->	O
c_display	pointer
;	O
if	O
(	O
printcmd	pointer
||	O
D_PO	O
)	O
break	O
;	O
}	O
if	O
(	O
!	O
cv	pointer
)	O
{	O
display	struct
=	O
displays	pointer
;	O
if	O
(	O
!	O
display	struct
||	O
display	struct
->	O
d_next	pointer
||	O
!	O
(	O
printcmd	pointer
||	O
D_PO	O
)	O
)	O
return	O
;	O
}	O
}	O
curr	pointer
->	O
w_pdisplay	pointer
=	O
display	struct
;	O
curr	pointer
->	O
w_stringp	pointer
=	O
curr	pointer
->	O
w_string	array
;	O
curr	pointer
->	O
w_state	enum
=	O
PRIN	int
;	O
if	O
(	O
printcmd	pointer
&&	O
curr	pointer
->	O
w_pdisplay	pointer
->	O
d_printfd	int
<	O
0	int
)	O
curr	pointer
->	O
w_pdisplay	pointer
->	O
d_printfd	int
=	O
printpipe	function
(	O
curr	pointer
,	O
printcmd	pointer
)	O
;	O
}	O
static	O
void	O
PrintChar	function
(	O
c	int
)	O
int	O
c	int
;	O
{	O
if	O
(	O
curr	pointer
->	O
w_stringp	pointer
>=	O
curr	pointer
->	O
w_string	array
+	O
MAXSTR	int
-	O
1	int
)	O
PrintFlush	function
(	O
)	O
;	O
*	O
(	O
curr	pointer
->	O
w_stringp	pointer
)	O
++	O
=	O
c	int
;	O
}	O
static	O
void	O
PrintFlush	function
(	O
)	O
{	O
display	struct
=	O
curr	pointer
->	O
w_pdisplay	pointer
;	O
if	O
(	O
display	struct
&&	O
printcmd	pointer
)	O
{	O
char	O
*	O
bp	pointer
=	O
curr	pointer
->	O
w_string	array
;	O
int	O
len	int
=	O
curr	pointer
->	O
w_stringp	pointer
-	O
curr	pointer
->	O
w_string	array
;	O
int	O
r	int
;	O
while	O
(	O
len	int
&&	O
display	struct
->	O
d_printfd	int
>=	O
0	int
)	O
{	O
r	int
=	O
write	pointer
(	O
display	struct
->	O
d_printfd	int
,	O
bp	pointer
,	O
len	int
)	O
;	O
if	O
(	O
r	int
<=	O
0	int
)	O
{	O
WMsg	function
(	O
curr	pointer
,	O
errno	O
,	O
"printing aborted"	pointer
)	O
;	O
close	pointer
(	O
display	struct
->	O
d_printfd	int
)	O
;	O
display	struct
->	O
d_printfd	int
=	O
-	O
1	int
;	O
break	O
;	O
}	O
bp	pointer
+=	O
r	int
;	O
len	int
-=	O
r	int
;	O
}	O
}	O
else	O
if	O
(	O
display	struct
&&	O
curr	pointer
->	O
w_stringp	pointer
>	O
curr	pointer
->	O
w_string	array
)	O
{	O
AddCStr	function
(	O
D_PO	O
)	O
;	O
AddStrn	function
(	O
curr	pointer
->	O
w_string	array
,	O
curr	pointer
->	O
w_stringp	pointer
-	O
curr	pointer
->	O
w_string	array
)	O
;	O
AddCStr	function
(	O
D_PF	O
)	O
;	O
Flush	function
(	O
3	int
)	O
;	O
}	O
curr	pointer
->	O
w_stringp	pointer
=	O
curr	pointer
->	O
w_string	array
;	O
}	O
void	O
WNewAutoFlow	function
(	O
win	struct
,	O
on	int
)	O
struct	O
win	struct
*	O
win	struct
;	O
int	O
on	int
;	O
{	O
debug1	O
(	O
"WNewAutoFlow: %d\n"	pointer
,	O
on	int
)	O
;	O
if	O
(	O
win	struct
->	O
w_flow	int
&	O
FLOW_AUTOFLAG	O
)	O
win	struct
->	O
w_flow	int
=	O
FLOW_AUTOFLAG	O
|	O
(	O
FLOW_AUTO	O
|	O
FLOW_NOW	O
)	O
*	O
on	int
;	O
else	O
win	struct
->	O
w_flow	int
=	O
(	O
win	struct
->	O
w_flow	int
&	O
~	O
FLOW_AUTO	O
)	O
|	O
FLOW_AUTO	O
*	O
on	int
;	O
LSetFlow	function
(	O
&	O
win	struct
->	O
w_layer	struct
,	O
win	struct
->	O
w_flow	int
&	O
FLOW_NOW	O
)	O
;	O
}	O
static	O
void	O
DesignateCharset	function
(	O
c	int
,	O
n	int
)	O
int	O
c	int
,	O
n	int
;	O
{	O
curr	pointer
->	O
w_ss	int
=	O
0	int
;	O
if	O
(	O
c	int
==	O
(	O
'@'	O
&	O
037	int
)	O
)	O
c	int
=	O
KANJI	O
;	O
if	O
(	O
c	int
==	O
'B'	O
)	O
c	int
=	O
ASCII	int
;	O
if	O
(	O
curr	pointer
->	O
w_charsets	array
[	O
n	int
]	O
!=	O
c	int
)	O
{	O
curr	pointer
->	O
w_charsets	array
[	O
n	int
]	O
=	O
c	int
;	O
if	O
(	O
curr	pointer
->	O
w_Charset	int
==	O
n	int
)	O
{	O
curr	pointer
->	O
w_FontL	char
=	O
c	int
;	O
curr	pointer
->	O
w_rend	struct
.	O
font	char
=	O
curr	pointer
->	O
w_FontL	char
;	O
LSetRendition	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
&	O
curr	pointer
->	O
w_rend	struct
)	O
;	O
}	O
if	O
(	O
curr	pointer
->	O
w_CharsetR	int
==	O
n	int
)	O
curr	pointer
->	O
w_FontR	char
=	O
c	int
;	O
}	O
}	O
static	O
void	O
MapCharset	function
(	O
n	int
)	O
int	O
n	int
;	O
{	O
curr	pointer
->	O
w_ss	int
=	O
0	int
;	O
if	O
(	O
curr	pointer
->	O
w_Charset	int
!=	O
n	int
)	O
{	O
curr	pointer
->	O
w_Charset	int
=	O
n	int
;	O
curr	pointer
->	O
w_FontL	char
=	O
curr	pointer
->	O
w_charsets	array
[	O
n	int
]	O
;	O
curr	pointer
->	O
w_rend	struct
.	O
font	char
=	O
curr	pointer
->	O
w_FontL	char
;	O
LSetRendition	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
&	O
curr	pointer
->	O
w_rend	struct
)	O
;	O
}	O
}	O
static	O
void	O
MapCharsetR	function
(	O
n	int
)	O
int	O
n	int
;	O
{	O
curr	pointer
->	O
w_ss	int
=	O
0	int
;	O
if	O
(	O
curr	pointer
->	O
w_CharsetR	int
!=	O
n	int
)	O
{	O
curr	pointer
->	O
w_CharsetR	int
=	O
n	int
;	O
curr	pointer
->	O
w_FontR	char
=	O
curr	pointer
->	O
w_charsets	array
[	O
n	int
]	O
;	O
}	O
curr	pointer
->	O
w_gr	int
=	O
1	int
;	O
}	O
static	O
void	O
SaveCursor	function
(	O
cursor	struct
)	O
struct	O
cursor	struct
*	O
cursor	struct
;	O
{	O
cursor	struct
->	O
on	int
=	O
1	int
;	O
cursor	struct
->	O
x	int
=	O
curr	pointer
->	O
w_x	O
;	O
cursor	struct
->	O
y	int
=	O
curr	pointer
->	O
w_y	O
;	O
cursor	struct
->	O
Rend	struct
=	O
curr	pointer
->	O
w_rend	struct
;	O
cursor	struct
->	O
Charset	int
=	O
curr	pointer
->	O
w_Charset	int
;	O
cursor	struct
->	O
CharsetR	int
=	O
curr	pointer
->	O
w_CharsetR	int
;	O
bcopy	function
(	O
(	O
char	O
*	O
)	O
curr	pointer
->	O
w_charsets	array
,	O
(	O
char	O
*	O
)	O
cursor	struct
->	O
Charsets	array
,	O
4	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
}	O
static	O
void	O
RestoreCursor	function
(	O
cursor	struct
)	O
struct	O
cursor	struct
*	O
cursor	struct
;	O
{	O
if	O
(	O
!	O
cursor	struct
->	O
on	int
)	O
return	O
;	O
LGotoPos	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
cursor	struct
->	O
x	int
,	O
cursor	struct
->	O
y	int
)	O
;	O
curr	pointer
->	O
w_x	O
=	O
cursor	struct
->	O
x	int
;	O
curr	pointer
->	O
w_y	O
=	O
cursor	struct
->	O
y	int
;	O
curr	pointer
->	O
w_rend	struct
=	O
cursor	struct
->	O
Rend	struct
;	O
bcopy	function
(	O
(	O
char	O
*	O
)	O
cursor	struct
->	O
Charsets	array
,	O
(	O
char	O
*	O
)	O
curr	pointer
->	O
w_charsets	array
,	O
4	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
curr	pointer
->	O
w_Charset	int
=	O
cursor	struct
->	O
Charset	int
;	O
curr	pointer
->	O
w_CharsetR	int
=	O
cursor	struct
->	O
CharsetR	int
;	O
curr	pointer
->	O
w_ss	int
=	O
0	int
;	O
curr	pointer
->	O
w_FontL	char
=	O
curr	pointer
->	O
w_charsets	array
[	O
curr	pointer
->	O
w_Charset	int
]	O
;	O
curr	pointer
->	O
w_FontR	char
=	O
curr	pointer
->	O
w_charsets	array
[	O
curr	pointer
->	O
w_CharsetR	int
]	O
;	O
LSetRendition	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
&	O
curr	pointer
->	O
w_rend	struct
)	O
;	O
}	O
static	O
void	O
BackSpace	function
(	O
)	O
{	O
if	O
(	O
curr	pointer
->	O
w_x	O
>	O
0	int
)	O
{	O
curr	pointer
->	O
w_x	O
--	O
;	O
}	O
else	O
if	O
(	O
curr	pointer
->	O
w_wrap	int
&&	O
curr	pointer
->	O
w_y	O
>	O
0	int
)	O
{	O
curr	pointer
->	O
w_x	O
=	O
cols	int
-	O
1	int
;	O
curr	pointer
->	O
w_y	O
--	O
;	O
}	O
LGotoPos	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
curr	pointer
->	O
w_x	O
,	O
curr	pointer
->	O
w_y	O
)	O
;	O
}	O
static	O
void	O
Return	function
(	O
)	O
{	O
if	O
(	O
curr	pointer
->	O
w_x	O
==	O
0	int
)	O
return	O
;	O
curr	pointer
->	O
w_x	O
=	O
0	int
;	O
LGotoPos	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
curr	pointer
->	O
w_x	O
,	O
curr	pointer
->	O
w_y	O
)	O
;	O
}	O
static	O
void	O
LineFeed	function
(	O
out_mode	int
)	O
int	O
out_mode	int
;	O
{	O
if	O
(	O
out_mode	int
)	O
curr	pointer
->	O
w_x	O
=	O
0	int
;	O
if	O
(	O
curr	pointer
->	O
w_y	O
!=	O
curr	pointer
->	O
w_bot	int
)	O
{	O
if	O
(	O
curr	pointer
->	O
w_y	O
<	O
rows	int
-	O
1	int
)	O
curr	pointer
->	O
w_y	O
++	O
;	O
LGotoPos	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
curr	pointer
->	O
w_x	O
,	O
curr	pointer
->	O
w_y	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
curr	pointer
->	O
w_autoaka	int
>	O
1	int
)	O
curr	pointer
->	O
w_autoaka	int
--	O
;	O
MScrollV	function
(	O
curr	pointer
,	O
1	int
,	O
curr	pointer
->	O
w_top	int
,	O
curr	pointer
->	O
w_bot	int
,	O
CURR_BCE	O
)	O
;	O
LScrollV	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
1	int
,	O
curr	pointer
->	O
w_top	int
,	O
curr	pointer
->	O
w_bot	int
,	O
CURR_BCE	O
)	O
;	O
LGotoPos	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
curr	pointer
->	O
w_x	O
,	O
curr	pointer
->	O
w_y	O
)	O
;	O
}	O
static	O
void	O
ReverseLineFeed	function
(	O
)	O
{	O
if	O
(	O
curr	pointer
->	O
w_y	O
==	O
curr	pointer
->	O
w_top	int
)	O
{	O
MScrollV	function
(	O
curr	pointer
,	O
-	O
1	int
,	O
curr	pointer
->	O
w_top	int
,	O
curr	pointer
->	O
w_bot	int
,	O
CURR_BCE	O
)	O
;	O
LScrollV	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
-	O
1	int
,	O
curr	pointer
->	O
w_top	int
,	O
curr	pointer
->	O
w_bot	int
,	O
CURR_BCE	O
)	O
;	O
LGotoPos	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
curr	pointer
->	O
w_x	O
,	O
curr	pointer
->	O
w_y	O
)	O
;	O
}	O
else	O
if	O
(	O
curr	pointer
->	O
w_y	O
>	O
0	int
)	O
CursorUp	function
(	O
1	int
)	O
;	O
}	O
static	O
void	O
InsertChar	function
(	O
n	int
)	O
int	O
n	int
;	O
{	O
register	O
int	O
y	int
=	O
curr	pointer
->	O
w_y	O
,	O
x	int
=	O
curr	pointer
->	O
w_x	O
;	O
if	O
(	O
n	int
<=	O
0	int
)	O
return	O
;	O
if	O
(	O
x	int
==	O
cols	int
)	O
x	int
--	O
;	O
save_mline	O
(	O
&	O
curr	pointer
->	O
w_mlines	pointer
[	O
y	int
]	O
,	O
cols	int
)	O
;	O
MScrollH	function
(	O
curr	pointer
,	O
-	O
n	int
,	O
y	int
,	O
x	int
,	O
curr	pointer
->	O
w_width	O
-	O
1	int
,	O
CURR_BCE	O
)	O
;	O
LScrollH	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
-	O
n	int
,	O
y	int
,	O
x	int
,	O
curr	pointer
->	O
w_width	O
-	O
1	int
,	O
CURR_BCE	O
,	O
&	O
mline_old	struct
)	O
;	O
LGotoPos	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
x	int
,	O
y	int
)	O
;	O
}	O
static	O
void	O
DeleteChar	function
(	O
n	int
)	O
int	O
n	int
;	O
{	O
register	O
int	O
y	int
=	O
curr	pointer
->	O
w_y	O
,	O
x	int
=	O
curr	pointer
->	O
w_x	O
;	O
if	O
(	O
x	int
==	O
cols	int
)	O
x	int
--	O
;	O
save_mline	O
(	O
&	O
curr	pointer
->	O
w_mlines	pointer
[	O
y	int
]	O
,	O
cols	int
)	O
;	O
MScrollH	function
(	O
curr	pointer
,	O
n	int
,	O
y	int
,	O
x	int
,	O
curr	pointer
->	O
w_width	O
-	O
1	int
,	O
CURR_BCE	O
)	O
;	O
LScrollH	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
n	int
,	O
y	int
,	O
x	int
,	O
curr	pointer
->	O
w_width	O
-	O
1	int
,	O
CURR_BCE	O
,	O
&	O
mline_old	struct
)	O
;	O
LGotoPos	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
x	int
,	O
y	int
)	O
;	O
}	O
static	O
void	O
DeleteLine	function
(	O
n	int
)	O
int	O
n	int
;	O
{	O
if	O
(	O
curr	pointer
->	O
w_y	O
<	O
curr	pointer
->	O
w_top	int
||	O
curr	pointer
->	O
w_y	O
>	O
curr	pointer
->	O
w_bot	int
)	O
return	O
;	O
if	O
(	O
n	int
>	O
curr	pointer
->	O
w_bot	int
-	O
curr	pointer
->	O
w_y	O
+	O
1	int
)	O
n	int
=	O
curr	pointer
->	O
w_bot	int
-	O
curr	pointer
->	O
w_y	O
+	O
1	int
;	O
MScrollV	function
(	O
curr	pointer
,	O
n	int
,	O
curr	pointer
->	O
w_y	O
,	O
curr	pointer
->	O
w_bot	int
,	O
CURR_BCE	O
)	O
;	O
LScrollV	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
n	int
,	O
curr	pointer
->	O
w_y	O
,	O
curr	pointer
->	O
w_bot	int
,	O
CURR_BCE	O
)	O
;	O
LGotoPos	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
curr	pointer
->	O
w_x	O
,	O
curr	pointer
->	O
w_y	O
)	O
;	O
}	O
static	O
void	O
InsertLine	function
(	O
n	int
)	O
int	O
n	int
;	O
{	O
if	O
(	O
curr	pointer
->	O
w_y	O
<	O
curr	pointer
->	O
w_top	int
||	O
curr	pointer
->	O
w_y	O
>	O
curr	pointer
->	O
w_bot	int
)	O
return	O
;	O
if	O
(	O
n	int
>	O
curr	pointer
->	O
w_bot	int
-	O
curr	pointer
->	O
w_y	O
+	O
1	int
)	O
n	int
=	O
curr	pointer
->	O
w_bot	int
-	O
curr	pointer
->	O
w_y	O
+	O
1	int
;	O
MScrollV	function
(	O
curr	pointer
,	O
-	O
n	int
,	O
curr	pointer
->	O
w_y	O
,	O
curr	pointer
->	O
w_bot	int
,	O
CURR_BCE	O
)	O
;	O
LScrollV	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
-	O
n	int
,	O
curr	pointer
->	O
w_y	O
,	O
curr	pointer
->	O
w_bot	int
,	O
CURR_BCE	O
)	O
;	O
LGotoPos	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
curr	pointer
->	O
w_x	O
,	O
curr	pointer
->	O
w_y	O
)	O
;	O
}	O
static	O
void	O
ScrollRegion	function
(	O
n	int
)	O
int	O
n	int
;	O
{	O
MScrollV	function
(	O
curr	pointer
,	O
n	int
,	O
curr	pointer
->	O
w_top	int
,	O
curr	pointer
->	O
w_bot	int
,	O
CURR_BCE	O
)	O
;	O
LScrollV	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
n	int
,	O
curr	pointer
->	O
w_top	int
,	O
curr	pointer
->	O
w_bot	int
,	O
CURR_BCE	O
)	O
;	O
LGotoPos	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
curr	pointer
->	O
w_x	O
,	O
curr	pointer
->	O
w_y	O
)	O
;	O
}	O
static	O
void	O
ForwardTab	function
(	O
)	O
{	O
register	O
int	O
x	int
=	O
curr	pointer
->	O
w_x	O
;	O
if	O
(	O
x	int
==	O
cols	int
)	O
{	O
LineFeed	function
(	O
1	int
)	O
;	O
x	int
=	O
0	int
;	O
}	O
if	O
(	O
curr	pointer
->	O
w_tabs	pointer
[	O
x	int
]	O
&&	O
x	int
<	O
cols	int
-	O
1	int
)	O
x	int
++	O
;	O
while	O
(	O
x	int
<	O
cols	int
-	O
1	int
&&	O
!	O
curr	pointer
->	O
w_tabs	pointer
[	O
x	int
]	O
)	O
x	int
++	O
;	O
curr	pointer
->	O
w_x	O
=	O
x	int
;	O
LGotoPos	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
curr	pointer
->	O
w_x	O
,	O
curr	pointer
->	O
w_y	O
)	O
;	O
}	O
static	O
void	O
BackwardTab	function
(	O
)	O
{	O
register	O
int	O
x	int
=	O
curr	pointer
->	O
w_x	O
;	O
if	O
(	O
curr	pointer
->	O
w_tabs	pointer
[	O
x	int
]	O
&&	O
x	int
>	O
0	int
)	O
x	int
--	O
;	O
while	O
(	O
x	int
>	O
0	int
&&	O
!	O
curr	pointer
->	O
w_tabs	pointer
[	O
x	int
]	O
)	O
x	int
--	O
;	O
curr	pointer
->	O
w_x	O
=	O
x	int
;	O
LGotoPos	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
curr	pointer
->	O
w_x	O
,	O
curr	pointer
->	O
w_y	O
)	O
;	O
}	O
static	O
void	O
ClearScreen	function
(	O
)	O
{	O
LClearArea	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
0	int
,	O
0	int
,	O
curr	pointer
->	O
w_width	O
-	O
1	int
,	O
curr	pointer
->	O
w_height	O
-	O
1	int
,	O
CURR_BCE	O
,	O
1	int
)	O
;	O
MScrollV	function
(	O
curr	pointer
,	O
curr	pointer
->	O
w_height	O
,	O
0	int
,	O
curr	pointer
->	O
w_height	O
-	O
1	int
,	O
CURR_BCE	O
)	O
;	O
}	O
static	O
void	O
ClearFromBOS	function
(	O
)	O
{	O
register	O
int	O
y	int
=	O
curr	pointer
->	O
w_y	O
,	O
x	int
=	O
curr	pointer
->	O
w_x	O
;	O
LClearArea	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
0	int
,	O
0	int
,	O
x	int
,	O
y	int
,	O
CURR_BCE	O
,	O
1	int
)	O
;	O
MClearArea	function
(	O
curr	pointer
,	O
0	int
,	O
0	int
,	O
x	int
,	O
y	int
,	O
CURR_BCE	O
)	O
;	O
RestorePosRendition	function
(	O
)	O
;	O
}	O
static	O
void	O
ClearToEOS	function
(	O
)	O
{	O
register	O
int	O
y	int
=	O
curr	pointer
->	O
w_y	O
,	O
x	int
=	O
curr	pointer
->	O
w_x	O
;	O
if	O
(	O
x	int
==	O
0	int
&&	O
y	int
==	O
0	int
)	O
{	O
ClearScreen	function
(	O
)	O
;	O
RestorePosRendition	function
(	O
)	O
;	O
return	O
;	O
}	O
LClearArea	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
x	int
,	O
y	int
,	O
cols	int
-	O
1	int
,	O
rows	int
-	O
1	int
,	O
CURR_BCE	O
,	O
1	int
)	O
;	O
MClearArea	function
(	O
curr	pointer
,	O
x	int
,	O
y	int
,	O
cols	int
-	O
1	int
,	O
rows	int
-	O
1	int
,	O
CURR_BCE	O
)	O
;	O
RestorePosRendition	function
(	O
)	O
;	O
}	O
static	O
void	O
ClearLineRegion	function
(	O
from	int
,	O
to	int
)	O
int	O
from	int
,	O
to	int
;	O
{	O
register	O
int	O
y	int
=	O
curr	pointer
->	O
w_y	O
;	O
LClearArea	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
from	int
,	O
y	int
,	O
to	int
,	O
y	int
,	O
CURR_BCE	O
,	O
1	int
)	O
;	O
MClearArea	function
(	O
curr	pointer
,	O
from	int
,	O
y	int
,	O
to	int
,	O
y	int
,	O
CURR_BCE	O
)	O
;	O
RestorePosRendition	function
(	O
)	O
;	O
}	O
static	O
void	O
CursorRight	function
(	O
n	int
)	O
register	O
int	O
n	int
;	O
{	O
register	O
int	O
x	int
=	O
curr	pointer
->	O
w_x	O
;	O
if	O
(	O
x	int
==	O
cols	int
)	O
{	O
LineFeed	function
(	O
1	int
)	O
;	O
x	int
=	O
0	int
;	O
}	O
if	O
(	O
(	O
curr	pointer
->	O
w_x	O
+=	O
n	int
)	O
>=	O
cols	int
)	O
curr	pointer
->	O
w_x	O
=	O
cols	int
-	O
1	int
;	O
LGotoPos	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
curr	pointer
->	O
w_x	O
,	O
curr	pointer
->	O
w_y	O
)	O
;	O
}	O
static	O
void	O
CursorUp	function
(	O
n	int
)	O
register	O
int	O
n	int
;	O
{	O
if	O
(	O
curr	pointer
->	O
w_y	O
<	O
curr	pointer
->	O
w_top	int
)	O
{	O
if	O
(	O
(	O
curr	pointer
->	O
w_y	O
-=	O
n	int
)	O
<	O
0	int
)	O
curr	pointer
->	O
w_y	O
=	O
0	int
;	O
}	O
else	O
if	O
(	O
(	O
curr	pointer
->	O
w_y	O
-=	O
n	int
)	O
<	O
curr	pointer
->	O
w_top	int
)	O
curr	pointer
->	O
w_y	O
=	O
curr	pointer
->	O
w_top	int
;	O
LGotoPos	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
curr	pointer
->	O
w_x	O
,	O
curr	pointer
->	O
w_y	O
)	O
;	O
}	O
static	O
void	O
CursorDown	function
(	O
n	int
)	O
register	O
int	O
n	int
;	O
{	O
if	O
(	O
curr	pointer
->	O
w_y	O
>	O
curr	pointer
->	O
w_bot	int
)	O
{	O
if	O
(	O
(	O
curr	pointer
->	O
w_y	O
+=	O
n	int
)	O
>	O
rows	int
-	O
1	int
)	O
curr	pointer
->	O
w_y	O
=	O
rows	int
-	O
1	int
;	O
}	O
else	O
if	O
(	O
(	O
curr	pointer
->	O
w_y	O
+=	O
n	int
)	O
>	O
curr	pointer
->	O
w_bot	int
)	O
curr	pointer
->	O
w_y	O
=	O
curr	pointer
->	O
w_bot	int
;	O
LGotoPos	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
curr	pointer
->	O
w_x	O
,	O
curr	pointer
->	O
w_y	O
)	O
;	O
}	O
static	O
void	O
CursorLeft	function
(	O
n	int
)	O
register	O
int	O
n	int
;	O
{	O
if	O
(	O
(	O
curr	pointer
->	O
w_x	O
-=	O
n	int
)	O
<	O
0	int
)	O
curr	pointer
->	O
w_x	O
=	O
0	int
;	O
LGotoPos	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
curr	pointer
->	O
w_x	O
,	O
curr	pointer
->	O
w_y	O
)	O
;	O
}	O
static	O
void	O
ASetMode	function
(	O
on	int
)	O
int	O
on	int
;	O
{	O
register	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
curr	pointer
->	O
w_NumArgs	int
;	O
++	O
i	int
)	O
{	O
switch	O
(	O
curr	pointer
->	O
w_args	array
[	O
i	int
]	O
)	O
{	O
case	O
4	int
:	O
curr	pointer
->	O
w_insert	int
=	O
on	int
;	O
LAY_DISPLAYS	O
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
InsertMode	function
(	O
on	int
)	O
)	O
;	O
break	O
;	O
case	O
20	int
:	O
curr	pointer
->	O
w_autolf	int
=	O
on	int
;	O
break	O
;	O
case	O
34	int
:	O
curr	pointer
->	O
w_curvvis	int
=	O
!	O
on	int
;	O
LCursorVisibility	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
curr	pointer
->	O
w_curinv	int
?	O
-	O
1	int
:	O
curr	pointer
->	O
w_curvvis	int
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
}	O
static	O
char	O
rendlist	array
[	O
]	O
=	O
{	O
~	O
(	O
(	O
1	int
<<	O
NATTR	int
)	O
-	O
1	int
)	O
,	O
A_BD	O
,	O
A_DI	O
,	O
A_SO	O
,	O
A_US	O
,	O
A_BL	O
,	O
0	int
,	O
A_RV	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
~	O
(	O
A_BD	O
|	O
A_SO	O
|	O
A_DI	O
)	O
,	O
~	O
A_SO	O
,	O
~	O
A_US	O
,	O
~	O
A_BL	O
,	O
0	int
,	O
~	O
A_RV	O
}	O
;	O
static	O
void	O
SelectRendition	function
(	O
)	O
{	O
register	O
int	O
j	int
,	O
i	int
=	O
0	int
,	O
a	int
=	O
curr	pointer
->	O
w_rend	struct
.	O
attr	char
,	O
c	int
=	O
curr	pointer
->	O
w_rend	struct
.	O
color	char
;	O
do	O
{	O
j	int
=	O
curr	pointer
->	O
w_args	array
[	O
i	int
]	O
;	O
if	O
(	O
(	O
j	int
==	O
38	int
||	O
j	int
==	O
48	int
)	O
&&	O
i	int
+	O
2	int
<	O
curr	pointer
->	O
w_NumArgs	int
&&	O
curr	pointer
->	O
w_args	array
[	O
i	int
+	O
1	int
]	O
==	O
5	int
)	O
{	O
int	O
jj	int
;	O
i	int
+=	O
2	int
;	O
jj	int
=	O
curr	pointer
->	O
w_args	array
[	O
i	int
]	O
;	O
if	O
(	O
jj	int
<	O
0	int
||	O
jj	int
>	O
255	int
)	O
continue	O
;	O
jj	int
=	O
color256to16	function
(	O
jj	int
)	O
+	O
30	int
;	O
if	O
(	O
jj	int
>=	O
38	int
)	O
jj	int
+=	O
60	int
-	O
8	int
;	O
j	int
=	O
j	int
==	O
38	int
?	O
jj	int
:	O
jj	int
+	O
10	int
;	O
}	O
if	O
(	O
j	int
==	O
0	int
||	O
(	O
j	int
>=	O
30	int
&&	O
j	int
<=	O
39	int
&&	O
j	int
!=	O
38	int
)	O
)	O
a	int
&=	O
0xbf	int
;	O
if	O
(	O
j	int
==	O
0	int
||	O
(	O
j	int
>=	O
40	int
&&	O
j	int
<=	O
49	int
&&	O
j	int
!=	O
48	int
)	O
)	O
a	int
&=	O
0x7f	int
;	O
if	O
(	O
j	int
>=	O
90	int
&&	O
j	int
<=	O
97	int
)	O
a	int
|=	O
0x40	int
;	O
if	O
(	O
j	int
>=	O
100	int
&&	O
j	int
<=	O
107	int
)	O
a	int
|=	O
0x80	int
;	O
if	O
(	O
j	int
>=	O
90	int
&&	O
j	int
<=	O
97	int
)	O
j	int
-=	O
60	int
;	O
if	O
(	O
j	int
>=	O
100	int
&&	O
j	int
<=	O
107	int
)	O
j	int
-=	O
60	int
;	O
if	O
(	O
j	int
>=	O
30	int
&&	O
j	int
<=	O
39	int
&&	O
j	int
!=	O
38	int
)	O
c	int
=	O
(	O
c	int
&	O
0xf0	int
)	O
|	O
(	O
(	O
j	int
-	O
30	int
)	O
^	O
9	int
)	O
;	O
else	O
if	O
(	O
j	int
>=	O
40	int
&&	O
j	int
<=	O
49	int
&&	O
j	int
!=	O
48	int
)	O
c	int
=	O
(	O
c	int
&	O
0x0f	int
)	O
|	O
(	O
(	O
(	O
j	int
-	O
40	int
)	O
^	O
9	int
)	O
<<	O
4	int
)	O
;	O
if	O
(	O
j	int
==	O
0	int
)	O
c	int
=	O
0	int
;	O
if	O
(	O
j	int
<	O
0	int
||	O
j	int
>=	O
(	O
int	O
)	O
(	O
sizeof	O
(	O
rendlist	array
)	O
/	O
sizeof	O
(	O
*	O
rendlist	array
)	O
)	O
)	O
continue	O
;	O
j	int
=	O
rendlist	array
[	O
j	int
]	O
;	O
if	O
(	O
j	int
&	O
(	O
1	int
<<	O
NATTR	int
)	O
)	O
a	int
&=	O
j	int
;	O
else	O
a	int
|=	O
j	int
;	O
}	O
while	O
(	O
++	O
i	int
<	O
curr	pointer
->	O
w_NumArgs	int
)	O
;	O
curr	pointer
->	O
w_rend	struct
.	O
attr	char
=	O
a	int
;	O
curr	pointer
->	O
w_rend	struct
.	O
color	char
=	O
c	int
;	O
LSetRendition	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
&	O
curr	pointer
->	O
w_rend	struct
)	O
;	O
}	O
static	O
void	O
FillWithEs	function
(	O
)	O
{	O
register	O
int	O
i	int
;	O
register	O
unsigned	O
char	O
*	O
p	pointer
,	O
*	O
ep	pointer
;	O
LClearAll	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
1	int
)	O
;	O
curr	pointer
->	O
w_y	O
=	O
curr	pointer
->	O
w_x	O
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
rows	int
;	O
++	O
i	int
)	O
{	O
clear_mline	O
(	O
&	O
curr	pointer
->	O
w_mlines	pointer
[	O
i	int
]	O
,	O
0	int
,	O
cols	int
+	O
1	int
)	O
;	O
p	pointer
=	O
curr	pointer
->	O
w_mlines	pointer
[	O
i	int
]	O
.	O
image	char
;	O
ep	pointer
=	O
p	pointer
+	O
cols	int
;	O
while	O
(	O
p	pointer
<	O
ep	pointer
)	O
*	O
p	pointer
++	O
=	O
'E'	O
;	O
}	O
LRefreshAll	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
1	int
)	O
;	O
}	O
void	O
ChangeAKA	function
(	O
p	pointer
,	O
s	pointer
,	O
l	int
)	O
struct	O
win	struct
*	O
p	pointer
;	O
char	O
*	O
s	pointer
;	O
int	O
l	int
;	O
{	O
int	O
i	int
,	O
c	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
l	int
>	O
0	int
;	O
l	int
--	O
)	O
{	O
if	O
(	O
p	pointer
->	O
w_akachange	pointer
+	O
i	int
==	O
p	pointer
->	O
w_akabuf	array
+	O
sizeof	O
(	O
p	pointer
->	O
w_akabuf	array
)	O
-	O
1	int
)	O
break	O
;	O
c	int
=	O
(	O
unsigned	O
char	O
)	O
*	O
s	pointer
++	O
;	O
if	O
(	O
c	int
==	O
0	int
)	O
break	O
;	O
if	O
(	O
c	int
<	O
32	int
||	O
c	int
==	O
127	int
||	O
(	O
c	int
>=	O
128	int
&&	O
c	int
<	O
160	int
&&	O
p	pointer
->	O
w_c1	int
)	O
)	O
continue	O
;	O
p	pointer
->	O
w_akachange	pointer
[	O
i	int
++	O
]	O
=	O
c	int
;	O
}	O
p	pointer
->	O
w_akachange	pointer
[	O
i	int
]	O
=	O
0	int
;	O
p	pointer
->	O
w_title	pointer
=	O
p	pointer
->	O
w_akachange	pointer
;	O
if	O
(	O
p	pointer
->	O
w_akachange	pointer
!=	O
p	pointer
->	O
w_akabuf	array
)	O
if	O
(	O
p	pointer
->	O
w_akachange	pointer
[	O
0	int
]	O
==	O
0	int
||	O
p	pointer
->	O
w_akachange	pointer
[	O
-	O
1	int
]	O
==	O
':'	O
)	O
p	pointer
->	O
w_title	pointer
=	O
p	pointer
->	O
w_akabuf	array
+	O
strlen	function
(	O
p	pointer
->	O
w_akabuf	array
)	O
+	O
1	int
;	O
WindowChanged	function
(	O
p	pointer
,	O
't'	O
)	O
;	O
WindowChanged	function
(	O
(	O
struct	O
win	struct
*	O
)	O
0	int
,	O
'w'	O
)	O
;	O
WindowChanged	function
(	O
(	O
struct	O
win	struct
*	O
)	O
0	int
,	O
'W'	O
)	O
;	O
}	O
static	O
void	O
FindAKA	function
(	O
)	O
{	O
register	O
unsigned	O
char	O
*	O
cp	pointer
,	O
*	O
line	array
;	O
register	O
struct	O
win	struct
*	O
wp	pointer
=	O
curr	pointer
;	O
register	O
int	O
len	int
=	O
strlen	function
(	O
wp	pointer
->	O
w_akabuf	array
)	O
;	O
int	O
y	int
;	O
y	int
=	O
(	O
wp	pointer
->	O
w_autoaka	int
>	O
0	int
&&	O
wp	pointer
->	O
w_autoaka	int
<=	O
wp	pointer
->	O
w_height	O
)	O
?	O
wp	pointer
->	O
w_autoaka	int
-	O
1	int
:	O
wp	pointer
->	O
w_y	O
;	O
cols	int
=	O
wp	pointer
->	O
w_width	O
;	O
try_line	O
:	O
cp	pointer
=	O
line	array
=	O
wp	pointer
->	O
w_mlines	pointer
[	O
y	int
]	O
.	O
image	char
;	O
if	O
(	O
wp	pointer
->	O
w_autoaka	int
>	O
0	int
&&	O
*	O
wp	pointer
->	O
w_akabuf	array
!=	O
'\0'	O
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
cp	pointer
-	O
line	array
>=	O
cols	int
-	O
len	int
)	O
{	O
if	O
(	O
++	O
y	int
==	O
wp	pointer
->	O
w_autoaka	int
&&	O
y	int
<	O
rows	int
)	O
goto	O
try_line	O
;	O
return	O
;	O
}	O
if	O
(	O
strncmp	function
(	O
(	O
char	O
*	O
)	O
cp	pointer
,	O
wp	pointer
->	O
w_akabuf	array
,	O
len	int
)	O
==	O
0	int
)	O
break	O
;	O
cp	pointer
++	O
;	O
}	O
cp	pointer
+=	O
len	int
;	O
}	O
for	O
(	O
len	int
=	O
cols	int
-	O
(	O
cp	pointer
-	O
line	array
)	O
;	O
len	int
&&	O
*	O
cp	pointer
==	O
' '	O
;	O
len	int
--	O
,	O
cp	pointer
++	O
)	O
;	O
if	O
(	O
len	int
)	O
{	O
if	O
(	O
wp	pointer
->	O
w_autoaka	int
>	O
0	int
&&	O
(	O
*	O
cp	pointer
==	O
'!'	O
||	O
*	O
cp	pointer
==	O
'%'	O
||	O
*	O
cp	pointer
==	O
'^'	O
)	O
)	O
wp	pointer
->	O
w_autoaka	int
=	O
-	O
1	int
;	O
else	O
wp	pointer
->	O
w_autoaka	int
=	O
0	int
;	O
line	array
=	O
cp	pointer
;	O
while	O
(	O
len	int
&&	O
*	O
cp	pointer
!=	O
' '	O
)	O
{	O
if	O
(	O
*	O
cp	pointer
++	O
==	O
'/'	O
)	O
line	array
=	O
cp	pointer
;	O
len	int
--	O
;	O
}	O
ChangeAKA	function
(	O
wp	pointer
,	O
(	O
char	O
*	O
)	O
line	array
,	O
cp	pointer
-	O
line	array
)	O
;	O
}	O
else	O
wp	pointer
->	O
w_autoaka	int
=	O
0	int
;	O
}	O
static	O
void	O
RestorePosRendition	function
(	O
)	O
{	O
LGotoPos	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
curr	pointer
->	O
w_x	O
,	O
curr	pointer
->	O
w_y	O
)	O
;	O
LSetRendition	function
(	O
&	O
curr	pointer
->	O
w_layer	struct
,	O
&	O
curr	pointer
->	O
w_rend	struct
)	O
;	O
}	O
static	O
void	O
Report	function
(	O
fmt	pointer
,	O
n1	int
,	O
n2	int
)	O
char	O
*	O
fmt	pointer
;	O
int	O
n1	int
,	O
n2	int
;	O
{	O
register	O
int	O
len	int
;	O
char	O
rbuf	array
[	O
40	int
]	O
;	O
sprintf	function
(	O
rbuf	array
,	O
fmt	pointer
,	O
n1	int
,	O
n2	int
)	O
;	O
len	int
=	O
strlen	function
(	O
rbuf	array
)	O
;	O
if	O
(	O
W_UWP	O
(	O
curr	pointer
)	O
)	O
{	O
if	O
(	O
(	O
unsigned	O
)	O
(	O
curr	pointer
->	O
w_pwin	pointer
->	O
p_inlen	int
+	O
len	int
)	O
<=	O
sizeof	O
(	O
curr	pointer
->	O
w_pwin	pointer
->	O
p_inbuf	array
)	O
)	O
{	O
bcopy	function
(	O
rbuf	array
,	O
curr	pointer
->	O
w_pwin	pointer
->	O
p_inbuf	array
+	O
curr	pointer
->	O
w_pwin	pointer
->	O
p_inlen	int
,	O
len	int
)	O
;	O
curr	pointer
->	O
w_pwin	pointer
->	O
p_inlen	int
+=	O
len	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
(	O
unsigned	O
)	O
(	O
curr	pointer
->	O
w_inlen	int
+	O
len	int
)	O
<=	O
sizeof	O
(	O
curr	pointer
->	O
w_inbuf	array
)	O
)	O
{	O
bcopy	function
(	O
rbuf	array
,	O
curr	pointer
->	O
w_inbuf	array
+	O
curr	pointer
->	O
w_inlen	int
,	O
len	int
)	O
;	O
curr	pointer
->	O
w_inlen	int
+=	O
len	int
;	O
}	O
}	O
}	O
static	O
void	O
MFixLine	function
(	O
p	pointer
,	O
y	int
,	O
mc	struct
)	O
struct	O
win	struct
*	O
p	pointer
;	O
int	O
y	int
;	O
struct	O
mchar	struct
*	O
mc	struct
;	O
{	O
struct	O
mline	struct
*	O
ml	pointer
=	O
&	O
p	pointer
->	O
w_mlines	pointer
[	O
y	int
]	O
;	O
if	O
(	O
mc	struct
->	O
attr	char
&&	O
ml	pointer
->	O
attr	char
==	O
null	pointer
)	O
{	O
if	O
(	O
(	O
ml	pointer
->	O
attr	char
=	O
(	O
unsigned	O
char	O
*	O
)	O
calloc	function
(	O
p	pointer
->	O
w_width	O
+	O
1	int
,	O
1	int
)	O
)	O
==	O
0	int
)	O
{	O
ml	pointer
->	O
attr	char
=	O
null	pointer
;	O
mc	struct
->	O
attr	char
=	O
p	pointer
->	O
w_rend	struct
.	O
attr	char
=	O
0	int
;	O
WMsg	function
(	O
p	pointer
,	O
0	int
,	O
"Warning: no space for attr - turned off"	pointer
)	O
;	O
}	O
}	O
if	O
(	O
mc	struct
->	O
font	char
&&	O
ml	pointer
->	O
font	char
==	O
null	pointer
)	O
{	O
if	O
(	O
(	O
ml	pointer
->	O
font	char
=	O
(	O
unsigned	O
char	O
*	O
)	O
calloc	function
(	O
p	pointer
->	O
w_width	O
+	O
1	int
,	O
1	int
)	O
)	O
==	O
0	int
)	O
{	O
ml	pointer
->	O
font	char
=	O
null	pointer
;	O
p	pointer
->	O
w_FontL	char
=	O
p	pointer
->	O
w_charsets	array
[	O
p	pointer
->	O
w_ss	int
?	O
p	pointer
->	O
w_ss	int
:	O
p	pointer
->	O
w_Charset	int
]	O
=	O
0	int
;	O
p	pointer
->	O
w_FontR	char
=	O
p	pointer
->	O
w_charsets	array
[	O
p	pointer
->	O
w_ss	int
?	O
p	pointer
->	O
w_ss	int
:	O
p	pointer
->	O
w_CharsetR	int
]	O
=	O
0	int
;	O
mc	struct
->	O
font	char
=	O
mc	struct
->	O
fontx	char
=	O
p	pointer
->	O
w_rend	struct
.	O
font	char
=	O
0	int
;	O
WMsg	function
(	O
p	pointer
,	O
0	int
,	O
"Warning: no space for font - turned off"	pointer
)	O
;	O
}	O
}	O
if	O
(	O
mc	struct
->	O
fontx	char
&&	O
ml	pointer
->	O
fontx	char
==	O
null	pointer
)	O
{	O
if	O
(	O
(	O
ml	pointer
->	O
fontx	char
=	O
(	O
unsigned	O
char	O
*	O
)	O
calloc	function
(	O
p	pointer
->	O
w_width	O
+	O
1	int
,	O
1	int
)	O
)	O
==	O
0	int
)	O
{	O
ml	pointer
->	O
fontx	char
=	O
null	pointer
;	O
mc	struct
->	O
fontx	char
=	O
0	int
;	O
}	O
}	O
if	O
(	O
mc	struct
->	O
color	char
&&	O
ml	pointer
->	O
color	char
==	O
null	pointer
)	O
{	O
if	O
(	O
(	O
ml	pointer
->	O
color	char
=	O
(	O
unsigned	O
char	O
*	O
)	O
calloc	function
(	O
p	pointer
->	O
w_width	O
+	O
1	int
,	O
1	int
)	O
)	O
==	O
0	int
)	O
{	O
ml	pointer
->	O
color	char
=	O
null	pointer
;	O
mc	struct
->	O
color	char
=	O
p	pointer
->	O
w_rend	struct
.	O
color	char
=	O
0	int
;	O
WMsg	function
(	O
p	pointer
,	O
0	int
,	O
"Warning: no space for color - turned off"	pointer
)	O
;	O
}	O
}	O
}	O
static	O
void	O
MScrollH	function
(	O
p	pointer
,	O
n	int
,	O
y	int
,	O
xs	int
,	O
xe	int
,	O
bce	int
)	O
struct	O
win	struct
*	O
p	pointer
;	O
int	O
n	int
,	O
y	int
,	O
xs	int
,	O
xe	int
,	O
bce	int
;	O
{	O
struct	O
mline	struct
*	O
ml	pointer
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
;	O
ml	pointer
=	O
&	O
p	pointer
->	O
w_mlines	pointer
[	O
y	int
]	O
;	O
MKillDwRight	O
(	O
p	pointer
,	O
ml	pointer
,	O
xs	int
)	O
;	O
MKillDwLeft	O
(	O
p	pointer
,	O
ml	pointer
,	O
xe	int
)	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
{	O
if	O
(	O
xe	int
-	O
xs	int
+	O
1	int
>	O
n	int
)	O
{	O
MKillDwRight	O
(	O
p	pointer
,	O
ml	pointer
,	O
xs	int
+	O
n	int
)	O
;	O
bcopy_mline	O
(	O
ml	pointer
,	O
xs	int
+	O
n	int
,	O
xs	int
,	O
xe	int
+	O
1	int
-	O
xs	int
-	O
n	int
)	O
;	O
}	O
else	O
n	int
=	O
xe	int
-	O
xs	int
+	O
1	int
;	O
clear_mline	O
(	O
ml	pointer
,	O
xe	int
+	O
1	int
-	O
n	int
,	O
n	int
)	O
;	O
if	O
(	O
bce	int
)	O
MBceLine	function
(	O
p	pointer
,	O
y	int
,	O
xe	int
+	O
1	int
-	O
n	int
,	O
n	int
,	O
bce	int
)	O
;	O
}	O
else	O
{	O
n	int
=	O
-	O
n	int
;	O
if	O
(	O
xe	int
-	O
xs	int
+	O
1	int
>	O
n	int
)	O
{	O
MKillDwLeft	O
(	O
p	pointer
,	O
ml	pointer
,	O
xe	int
-	O
n	int
)	O
;	O
bcopy_mline	O
(	O
ml	pointer
,	O
xs	int
,	O
xs	int
+	O
n	int
,	O
xe	int
+	O
1	int
-	O
xs	int
-	O
n	int
)	O
;	O
}	O
else	O
n	int
=	O
xe	int
-	O
xs	int
+	O
1	int
;	O
clear_mline	O
(	O
ml	pointer
,	O
xs	int
,	O
n	int
)	O
;	O
if	O
(	O
bce	int
)	O
MBceLine	function
(	O
p	pointer
,	O
y	int
,	O
xs	int
,	O
n	int
,	O
bce	int
)	O
;	O
}	O
}	O
static	O
void	O
MScrollV	function
(	O
p	pointer
,	O
n	int
,	O
ys	int
,	O
ye	int
,	O
bce	int
)	O
struct	O
win	struct
*	O
p	pointer
;	O
int	O
n	int
,	O
ys	int
,	O
ye	int
,	O
bce	int
;	O
{	O
int	O
i	int
,	O
cnt1	int
,	O
cnt2	int
;	O
struct	O
mline	struct
tmp	array
[	O
256	int
]	O
;	O
struct	O
mline	struct
*	O
ml	pointer
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
{	O
if	O
(	O
ye	int
-	O
ys	int
+	O
1	int
<	O
n	int
)	O
n	int
=	O
ye	int
-	O
ys	int
+	O
1	int
;	O
if	O
(	O
n	int
>	O
256	int
)	O
{	O
MScrollV	function
(	O
p	pointer
,	O
n	int
-	O
256	int
,	O
ys	int
,	O
ye	int
,	O
bce	int
)	O
;	O
n	int
=	O
256	int
;	O
}	O
if	O
(	O
compacthist	int
)	O
{	O
ye	int
=	O
MFindUsedLine	function
(	O
p	pointer
,	O
ye	int
,	O
ys	int
)	O
;	O
if	O
(	O
ye	int
-	O
ys	int
+	O
1	int
<	O
n	int
)	O
n	int
=	O
ye	int
-	O
ys	int
+	O
1	int
;	O
if	O
(	O
n	int
<=	O
0	int
)	O
return	O
;	O
}	O
ml	pointer
=	O
p	pointer
->	O
w_mlines	pointer
+	O
ys	int
;	O
for	O
(	O
i	int
=	O
ys	int
;	O
i	int
<	O
ys	int
+	O
n	int
;	O
i	int
++	O
,	O
ml	pointer
++	O
)	O
{	O
if	O
(	O
ys	int
==	O
p	pointer
->	O
w_top	int
)	O
WAddLineToHist	function
(	O
p	pointer
,	O
ml	pointer
)	O
;	O
if	O
(	O
ml	pointer
->	O
attr	char
!=	O
null	pointer
)	O
free	function
(	O
ml	pointer
->	O
attr	char
)	O
;	O
ml	pointer
->	O
attr	char
=	O
null	pointer
;	O
if	O
(	O
ml	pointer
->	O
font	char
!=	O
null	pointer
)	O
free	function
(	O
ml	pointer
->	O
font	char
)	O
;	O
ml	pointer
->	O
font	char
=	O
null	pointer
;	O
if	O
(	O
ml	pointer
->	O
fontx	char
!=	O
null	pointer
)	O
free	function
(	O
ml	pointer
->	O
fontx	char
)	O
;	O
ml	pointer
->	O
fontx	char
=	O
null	pointer
;	O
if	O
(	O
ml	pointer
->	O
color	char
!=	O
null	pointer
)	O
free	function
(	O
ml	pointer
->	O
color	char
)	O
;	O
ml	pointer
->	O
color	char
=	O
null	pointer
;	O
bclear	function
(	O
(	O
char	O
*	O
)	O
ml	pointer
->	O
image	char
,	O
p	pointer
->	O
w_width	O
+	O
1	int
)	O
;	O
if	O
(	O
bce	int
)	O
MBceLine	function
(	O
p	pointer
,	O
i	int
,	O
0	int
,	O
p	pointer
->	O
w_width	O
,	O
bce	int
)	O
;	O
}	O
cnt1	int
=	O
n	int
*	O
sizeof	O
(	O
struct	O
mline	struct
)	O
;	O
cnt2	int
=	O
(	O
ye	int
-	O
ys	int
+	O
1	int
-	O
n	int
)	O
*	O
sizeof	O
(	O
struct	O
mline	struct
)	O
;	O
if	O
(	O
cnt1	int
&&	O
cnt2	int
)	O
Scroll	function
(	O
(	O
char	O
*	O
)	O
(	O
p	pointer
->	O
w_mlines	pointer
+	O
ys	int
)	O
,	O
cnt1	int
,	O
cnt2	int
,	O
(	O
char	O
*	O
)	O
tmp	array
)	O
;	O
}	O
else	O
{	O
n	int
=	O
-	O
n	int
;	O
if	O
(	O
ye	int
-	O
ys	int
+	O
1	int
<	O
n	int
)	O
n	int
=	O
ye	int
-	O
ys	int
+	O
1	int
;	O
if	O
(	O
n	int
>	O
256	int
)	O
{	O
MScrollV	function
(	O
p	pointer
,	O
-	O
(	O
n	int
-	O
256	int
)	O
,	O
ys	int
,	O
ye	int
,	O
bce	int
)	O
;	O
n	int
=	O
256	int
;	O
}	O
ml	pointer
=	O
p	pointer
->	O
w_mlines	pointer
+	O
ye	int
;	O
for	O
(	O
i	int
=	O
ye	int
;	O
i	int
>	O
ye	int
-	O
n	int
;	O
i	int
--	O
,	O
ml	pointer
--	O
)	O
{	O
if	O
(	O
ml	pointer
->	O
attr	char
!=	O
null	pointer
)	O
free	function
(	O
ml	pointer
->	O
attr	char
)	O
;	O
ml	pointer
->	O
attr	char
=	O
null	pointer
;	O
if	O
(	O
ml	pointer
->	O
font	char
!=	O
null	pointer
)	O
free	function
(	O
ml	pointer
->	O
font	char
)	O
;	O
ml	pointer
->	O
font	char
=	O
null	pointer
;	O
if	O
(	O
ml	pointer
->	O
fontx	char
!=	O
null	pointer
)	O
free	function
(	O
ml	pointer
->	O
fontx	char
)	O
;	O
ml	pointer
->	O
fontx	char
=	O
null	pointer
;	O
if	O
(	O
ml	pointer
->	O
color	char
!=	O
null	pointer
)	O
free	function
(	O
ml	pointer
->	O
color	char
)	O
;	O
ml	pointer
->	O
color	char
=	O
null	pointer
;	O
bclear	function
(	O
(	O
char	O
*	O
)	O
ml	pointer
->	O
image	char
,	O
p	pointer
->	O
w_width	O
+	O
1	int
)	O
;	O
if	O
(	O
bce	int
)	O
MBceLine	function
(	O
p	pointer
,	O
i	int
,	O
0	int
,	O
p	pointer
->	O
w_width	O
,	O
bce	int
)	O
;	O
}	O
cnt1	int
=	O
n	int
*	O
sizeof	O
(	O
struct	O
mline	struct
)	O
;	O
cnt2	int
=	O
(	O
ye	int
-	O
ys	int
+	O
1	int
-	O
n	int
)	O
*	O
sizeof	O
(	O
struct	O
mline	struct
)	O
;	O
if	O
(	O
cnt1	int
&&	O
cnt2	int
)	O
Scroll	function
(	O
(	O
char	O
*	O
)	O
(	O
p	pointer
->	O
w_mlines	pointer
+	O
ys	int
)	O
,	O
cnt2	int
,	O
cnt1	int
,	O
(	O
char	O
*	O
)	O
tmp	array
)	O
;	O
}	O
}	O
static	O
void	O
Scroll	function
(	O
cp	pointer
,	O
cnt1	int
,	O
cnt2	int
,	O
tmp	array
)	O
char	O
*	O
cp	pointer
,	O
*	O
tmp	array
;	O
int	O
cnt1	int
,	O
cnt2	int
;	O
{	O
if	O
(	O
!	O
cnt1	int
||	O
!	O
cnt2	int
)	O
return	O
;	O
if	O
(	O
cnt1	int
<=	O
cnt2	int
)	O
{	O
bcopy	function
(	O
cp	pointer
,	O
tmp	array
,	O
cnt1	int
)	O
;	O
bcopy	function
(	O
cp	pointer
+	O
cnt1	int
,	O
cp	pointer
,	O
cnt2	int
)	O
;	O
bcopy	function
(	O
tmp	array
,	O
cp	pointer
+	O
cnt2	int
,	O
cnt1	int
)	O
;	O
}	O
else	O
{	O
bcopy	function
(	O
cp	pointer
+	O
cnt1	int
,	O
tmp	array
,	O
cnt2	int
)	O
;	O
bcopy	function
(	O
cp	pointer
,	O
cp	pointer
+	O
cnt2	int
,	O
cnt1	int
)	O
;	O
bcopy	function
(	O
tmp	array
,	O
cp	pointer
,	O
cnt2	int
)	O
;	O
}	O
}	O
static	O
void	O
MClearArea	function
(	O
p	pointer
,	O
xs	int
,	O
ys	int
,	O
xe	int
,	O
ye	int
,	O
bce	int
)	O
struct	O
win	struct
*	O
p	pointer
;	O
int	O
xs	int
,	O
ys	int
,	O
xe	int
,	O
ye	int
,	O
bce	int
;	O
{	O
int	O
n	int
,	O
y	int
;	O
int	O
xxe	int
;	O
struct	O
mline	struct
*	O
ml	pointer
;	O
if	O
(	O
ys	int
<	O
0	int
||	O
ye	int
<	O
ys	int
)	O
return	O
;	O
if	O
(	O
xs	int
>=	O
p	pointer
->	O
w_width	O
)	O
xs	int
=	O
p	pointer
->	O
w_width	O
-	O
1	int
;	O
if	O
(	O
xe	int
>=	O
p	pointer
->	O
w_width	O
)	O
xe	int
=	O
p	pointer
->	O
w_width	O
-	O
1	int
;	O
MKillDwRight	O
(	O
p	pointer
,	O
p	pointer
->	O
w_mlines	pointer
+	O
ys	int
,	O
xs	int
)	O
;	O
MKillDwLeft	O
(	O
p	pointer
,	O
p	pointer
->	O
w_mlines	pointer
+	O
ye	int
,	O
xe	int
)	O
;	O
ml	pointer
=	O
p	pointer
->	O
w_mlines	pointer
+	O
ys	int
;	O
for	O
(	O
y	int
=	O
ys	int
;	O
y	int
<=	O
ye	int
;	O
y	int
++	O
,	O
ml	pointer
++	O
)	O
{	O
xxe	int
=	O
(	O
y	int
==	O
ye	int
)	O
?	O
xe	int
:	O
p	pointer
->	O
w_width	O
-	O
1	int
;	O
n	int
=	O
xxe	int
-	O
xs	int
+	O
1	int
;	O
if	O
(	O
n	int
>	O
0	int
)	O
clear_mline	O
(	O
ml	pointer
,	O
xs	int
,	O
n	int
)	O
;	O
if	O
(	O
n	int
>	O
0	int
&&	O
bce	int
)	O
MBceLine	function
(	O
p	pointer
,	O
y	int
,	O
xs	int
,	O
xs	int
+	O
n	int
-	O
1	int
,	O
bce	int
)	O
;	O
xs	int
=	O
0	int
;	O
}	O
}	O
static	O
void	O
MInsChar	function
(	O
p	pointer
,	O
c	int
,	O
x	int
,	O
y	int
)	O
struct	O
win	struct
*	O
p	pointer
;	O
struct	O
mchar	struct
*	O
c	int
;	O
int	O
x	int
,	O
y	int
;	O
{	O
int	O
n	int
;	O
struct	O
mline	struct
*	O
ml	pointer
;	O
ASSERT	O
(	O
x	int
>=	O
0	int
&&	O
x	int
<	O
p	pointer
->	O
w_width	O
)	O
;	O
MFixLine	function
(	O
p	pointer
,	O
y	int
,	O
c	int
)	O
;	O
ml	pointer
=	O
p	pointer
->	O
w_mlines	pointer
+	O
y	int
;	O
n	int
=	O
p	pointer
->	O
w_width	O
-	O
x	int
-	O
1	int
;	O
MKillDwRight	O
(	O
p	pointer
,	O
ml	pointer
,	O
x	int
)	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
{	O
MKillDwRight	O
(	O
p	pointer
,	O
ml	pointer
,	O
p	pointer
->	O
w_width	O
-	O
1	int
)	O
;	O
bcopy_mline	O
(	O
ml	pointer
,	O
x	int
,	O
x	int
+	O
1	int
,	O
n	int
)	O
;	O
}	O
copy_mchar2mline	O
(	O
c	int
,	O
ml	pointer
,	O
x	int
)	O
;	O
if	O
(	O
c	int
->	O
mbcs	char
)	O
{	O
if	O
(	O
--	O
n	int
>	O
0	int
)	O
{	O
MKillDwRight	O
(	O
p	pointer
,	O
ml	pointer
,	O
p	pointer
->	O
w_width	O
-	O
1	int
)	O
;	O
bcopy_mline	O
(	O
ml	pointer
,	O
x	int
+	O
1	int
,	O
x	int
+	O
2	int
,	O
n	int
)	O
;	O
}	O
copy_mchar2mline	O
(	O
c	int
,	O
ml	pointer
,	O
x	int
+	O
1	int
)	O
;	O
ml	pointer
->	O
image	char
[	O
x	int
+	O
1	int
]	O
=	O
c	int
->	O
mbcs	char
;	O
if	O
(	O
p	pointer
->	O
w_encoding	O
!=	O
UTF8	int
)	O
ml	pointer
->	O
font	char
[	O
x	int
+	O
1	int
]	O
|=	O
0x80	int
;	O
else	O
if	O
(	O
p	pointer
->	O
w_encoding	O
==	O
UTF8	int
&&	O
c	int
->	O
mbcs	char
)	O
{	O
ml	pointer
->	O
font	char
[	O
x	int
+	O
1	int
]	O
=	O
c	int
->	O
mbcs	char
;	O
ml	pointer
->	O
fontx	char
[	O
x	int
+	O
1	int
]	O
=	O
0	int
;	O
}	O
}	O
}	O
static	O
void	O
MPutChar	function
(	O
p	pointer
,	O
c	int
,	O
x	int
,	O
y	int
)	O
struct	O
win	struct
*	O
p	pointer
;	O
struct	O
mchar	struct
*	O
c	int
;	O
int	O
x	int
,	O
y	int
;	O
{	O
struct	O
mline	struct
*	O
ml	pointer
;	O
MFixLine	function
(	O
p	pointer
,	O
y	int
,	O
c	int
)	O
;	O
ml	pointer
=	O
&	O
p	pointer
->	O
w_mlines	pointer
[	O
y	int
]	O
;	O
MKillDwRight	O
(	O
p	pointer
,	O
ml	pointer
,	O
x	int
)	O
;	O
MKillDwLeft	O
(	O
p	pointer
,	O
ml	pointer
,	O
x	int
)	O
;	O
copy_mchar2mline	O
(	O
c	int
,	O
ml	pointer
,	O
x	int
)	O
;	O
if	O
(	O
c	int
->	O
mbcs	char
)	O
{	O
MKillDwLeft	O
(	O
p	pointer
,	O
ml	pointer
,	O
x	int
+	O
1	int
)	O
;	O
copy_mchar2mline	O
(	O
c	int
,	O
ml	pointer
,	O
x	int
+	O
1	int
)	O
;	O
ml	pointer
->	O
image	char
[	O
x	int
+	O
1	int
]	O
=	O
c	int
->	O
mbcs	char
;	O
if	O
(	O
p	pointer
->	O
w_encoding	O
!=	O
UTF8	int
)	O
ml	pointer
->	O
font	char
[	O
x	int
+	O
1	int
]	O
|=	O
0x80	int
;	O
else	O
if	O
(	O
p	pointer
->	O
w_encoding	O
==	O
UTF8	int
&&	O
c	int
->	O
mbcs	char
)	O
{	O
ml	pointer
->	O
font	char
[	O
x	int
+	O
1	int
]	O
=	O
c	int
->	O
mbcs	char
;	O
ml	pointer
->	O
fontx	char
[	O
x	int
+	O
1	int
]	O
=	O
0	int
;	O
}	O
}	O
}	O
static	O
void	O
MWrapChar	function
(	O
p	pointer
,	O
c	int
,	O
y	int
,	O
top	int
,	O
bot	int
,	O
ins	int
)	O
struct	O
win	struct
*	O
p	pointer
;	O
struct	O
mchar	struct
*	O
c	int
;	O
int	O
y	int
,	O
top	int
,	O
bot	int
;	O
int	O
ins	int
;	O
{	O
struct	O
mline	struct
*	O
ml	pointer
;	O
int	O
bce	int
;	O
bce	int
=	O
rend_getbg	O
(	O
c	int
)	O
;	O
MFixLine	function
(	O
p	pointer
,	O
y	int
,	O
c	int
)	O
;	O
ml	pointer
=	O
&	O
p	pointer
->	O
w_mlines	pointer
[	O
y	int
]	O
;	O
copy_mchar2mline	O
(	O
&	O
mchar_null	struct
,	O
ml	pointer
,	O
p	pointer
->	O
w_width	O
)	O
;	O
if	O
(	O
y	int
==	O
bot	int
)	O
MScrollV	function
(	O
p	pointer
,	O
1	int
,	O
top	int
,	O
bot	int
,	O
bce	int
)	O
;	O
else	O
if	O
(	O
y	int
<	O
p	pointer
->	O
w_height	O
-	O
1	int
)	O
y	int
++	O
;	O
if	O
(	O
ins	int
)	O
MInsChar	function
(	O
p	pointer
,	O
c	int
,	O
0	int
,	O
y	int
)	O
;	O
else	O
MPutChar	function
(	O
p	pointer
,	O
c	int
,	O
0	int
,	O
y	int
)	O
;	O
}	O
static	O
void	O
MPutStr	function
(	O
p	pointer
,	O
s	pointer
,	O
n	int
,	O
r	int
,	O
x	int
,	O
y	int
)	O
struct	O
win	struct
*	O
p	pointer
;	O
char	O
*	O
s	pointer
;	O
int	O
n	int
;	O
struct	O
mchar	struct
*	O
r	int
;	O
int	O
x	int
,	O
y	int
;	O
{	O
struct	O
mline	struct
*	O
ml	pointer
;	O
int	O
i	int
;	O
unsigned	O
char	O
*	O
b	pointer
;	O
if	O
(	O
n	int
<=	O
0	int
)	O
return	O
;	O
MFixLine	function
(	O
p	pointer
,	O
y	int
,	O
r	int
)	O
;	O
ml	pointer
=	O
&	O
p	pointer
->	O
w_mlines	pointer
[	O
y	int
]	O
;	O
MKillDwRight	O
(	O
p	pointer
,	O
ml	pointer
,	O
x	int
)	O
;	O
MKillDwLeft	O
(	O
p	pointer
,	O
ml	pointer
,	O
x	int
+	O
n	int
-	O
1	int
)	O
;	O
bcopy	function
(	O
s	pointer
,	O
(	O
char	O
*	O
)	O
ml	pointer
->	O
image	char
+	O
x	int
,	O
n	int
)	O
;	O
if	O
(	O
ml	pointer
->	O
attr	char
!=	O
null	pointer
)	O
{	O
b	pointer
=	O
ml	pointer
->	O
attr	char
+	O
x	int
;	O
for	O
(	O
i	int
=	O
n	int
;	O
i	int
--	O
>	O
0	int
;	O
)	O
*	O
b	pointer
++	O
=	O
r	int
->	O
attr	char
;	O
}	O
if	O
(	O
ml	pointer
->	O
font	char
!=	O
null	pointer
)	O
{	O
b	pointer
=	O
ml	pointer
->	O
font	char
+	O
x	int
;	O
for	O
(	O
i	int
=	O
n	int
;	O
i	int
--	O
>	O
0	int
;	O
)	O
*	O
b	pointer
++	O
=	O
r	int
->	O
font	char
;	O
}	O
if	O
(	O
ml	pointer
->	O
fontx	char
!=	O
null	pointer
)	O
{	O
b	pointer
=	O
ml	pointer
->	O
fontx	char
+	O
x	int
;	O
for	O
(	O
i	int
=	O
n	int
;	O
i	int
--	O
>	O
0	int
;	O
)	O
*	O
b	pointer
++	O
=	O
r	int
->	O
fontx	char
;	O
}	O
if	O
(	O
ml	pointer
->	O
color	char
!=	O
null	pointer
)	O
{	O
b	pointer
=	O
ml	pointer
->	O
color	char
+	O
x	int
;	O
for	O
(	O
i	int
=	O
n	int
;	O
i	int
--	O
>	O
0	int
;	O
)	O
*	O
b	pointer
++	O
=	O
r	int
->	O
color	char
;	O
}	O
}	O
static	O
void	O
MBceLine	function
(	O
p	pointer
,	O
y	int
,	O
xs	int
,	O
xe	int
,	O
bce	int
)	O
struct	O
win	struct
*	O
p	pointer
;	O
int	O
y	int
,	O
xs	int
,	O
xe	int
,	O
bce	int
;	O
{	O
struct	O
mchar	struct
mc	struct
;	O
struct	O
mline	struct
*	O
ml	pointer
;	O
int	O
x	int
;	O
mc	struct
=	O
mchar_null	struct
;	O
rend_setbg	O
(	O
&	O
mc	struct
,	O
bce	int
)	O
;	O
MFixLine	function
(	O
p	pointer
,	O
y	int
,	O
&	O
mc	struct
)	O
;	O
ml	pointer
=	O
p	pointer
->	O
w_mlines	pointer
+	O
y	int
;	O
if	O
(	O
mc	struct
.	O
attr	char
)	O
for	O
(	O
x	int
=	O
xs	int
;	O
x	int
<=	O
xe	int
;	O
x	int
++	O
)	O
ml	pointer
->	O
attr	char
[	O
x	int
]	O
=	O
mc	struct
.	O
attr	char
;	O
if	O
(	O
mc	struct
.	O
color	char
)	O
for	O
(	O
x	int
=	O
xs	int
;	O
x	int
<=	O
xe	int
;	O
x	int
++	O
)	O
ml	pointer
->	O
color	char
[	O
x	int
]	O
=	O
mc	struct
.	O
color	char
;	O
}	O
static	O
void	O
WAddLineToHist	function
(	O
wp	pointer
,	O
ml	pointer
)	O
struct	O
win	struct
*	O
wp	pointer
;	O
struct	O
mline	struct
*	O
ml	pointer
;	O
{	O
register	O
unsigned	O
char	O
*	O
q	pointer
,	O
*	O
o	pointer
;	O
struct	O
mline	struct
*	O
hml	pointer
;	O
if	O
(	O
wp	pointer
->	O
w_histheight	int
==	O
0	int
)	O
return	O
;	O
hml	pointer
=	O
&	O
wp	pointer
->	O
w_hlines	pointer
[	O
wp	pointer
->	O
w_histidx	int
]	O
;	O
q	pointer
=	O
ml	pointer
->	O
image	char
;	O
ml	pointer
->	O
image	char
=	O
hml	pointer
->	O
image	char
;	O
hml	pointer
->	O
image	char
=	O
q	pointer
;	O
q	pointer
=	O
ml	pointer
->	O
attr	char
;	O
o	pointer
=	O
hml	pointer
->	O
attr	char
;	O
hml	pointer
->	O
attr	char
=	O
q	pointer
;	O
ml	pointer
->	O
attr	char
=	O
null	pointer
;	O
if	O
(	O
o	pointer
!=	O
null	pointer
)	O
free	function
(	O
o	pointer
)	O
;	O
q	pointer
=	O
ml	pointer
->	O
font	char
;	O
o	pointer
=	O
hml	pointer
->	O
font	char
;	O
hml	pointer
->	O
font	char
=	O
q	pointer
;	O
ml	pointer
->	O
font	char
=	O
null	pointer
;	O
if	O
(	O
o	pointer
!=	O
null	pointer
)	O
free	function
(	O
o	pointer
)	O
;	O
q	pointer
=	O
ml	pointer
->	O
fontx	char
;	O
o	pointer
=	O
hml	pointer
->	O
fontx	char
;	O
hml	pointer
->	O
fontx	char
=	O
q	pointer
;	O
ml	pointer
->	O
fontx	char
=	O
null	pointer
;	O
if	O
(	O
o	pointer
!=	O
null	pointer
)	O
free	function
(	O
o	pointer
)	O
;	O
q	pointer
=	O
ml	pointer
->	O
color	char
;	O
o	pointer
=	O
hml	pointer
->	O
color	char
;	O
hml	pointer
->	O
color	char
=	O
q	pointer
;	O
ml	pointer
->	O
color	char
=	O
null	pointer
;	O
if	O
(	O
o	pointer
!=	O
null	pointer
)	O
free	function
(	O
o	pointer
)	O
;	O
if	O
(	O
++	O
wp	pointer
->	O
w_histidx	int
>=	O
wp	pointer
->	O
w_histheight	int
)	O
wp	pointer
->	O
w_histidx	int
=	O
0	int
;	O
if	O
(	O
wp	pointer
->	O
w_scrollback_height	int
<	O
wp	pointer
->	O
w_histheight	int
)	O
++	O
wp	pointer
->	O
w_scrollback_height	int
;	O
}	O
int	O
MFindUsedLine	function
(	O
p	pointer
,	O
ye	int
,	O
ys	int
)	O
struct	O
win	struct
*	O
p	pointer
;	O
int	O
ys	int
,	O
ye	int
;	O
{	O
int	O
y	int
;	O
struct	O
mline	struct
*	O
ml	pointer
=	O
p	pointer
->	O
w_mlines	pointer
+	O
ye	int
;	O
debug2	O
(	O
"MFindUsedLine: %d %d\n"	pointer
,	O
ye	int
,	O
ys	int
)	O
;	O
for	O
(	O
y	int
=	O
ye	int
;	O
y	int
>=	O
ys	int
;	O
y	int
--	O
,	O
ml	pointer
--	O
)	O
{	O
if	O
(	O
bcmp	function
(	O
(	O
char	O
*	O
)	O
ml	pointer
->	O
image	char
,	O
blank	pointer
,	O
p	pointer
->	O
w_width	O
)	O
)	O
break	O
;	O
if	O
(	O
ml	pointer
->	O
attr	char
!=	O
null	pointer
&&	O
bcmp	function
(	O
(	O
char	O
*	O
)	O
ml	pointer
->	O
attr	char
,	O
null	pointer
,	O
p	pointer
->	O
w_width	O
)	O
)	O
break	O
;	O
if	O
(	O
ml	pointer
->	O
color	char
!=	O
null	pointer
&&	O
bcmp	function
(	O
(	O
char	O
*	O
)	O
ml	pointer
->	O
color	char
,	O
null	pointer
,	O
p	pointer
->	O
w_width	O
)	O
)	O
break	O
;	O
if	O
(	O
p	pointer
->	O
w_encoding	O
==	O
UTF8	int
)	O
{	O
if	O
(	O
ml	pointer
->	O
font	char
!=	O
null	pointer
&&	O
bcmp	function
(	O
(	O
char	O
*	O
)	O
ml	pointer
->	O
font	char
,	O
null	pointer
,	O
p	pointer
->	O
w_width	O
)	O
)	O
break	O
;	O
if	O
(	O
ml	pointer
->	O
fontx	char
!=	O
null	pointer
&&	O
bcmp	function
(	O
(	O
char	O
*	O
)	O
ml	pointer
->	O
fontx	char
,	O
null	pointer
,	O
p	pointer
->	O
w_width	O
)	O
)	O
break	O
;	O
}	O
}	O
debug1	O
(	O
"MFindUsedLine returning  %d\n"	pointer
,	O
y	int
)	O
;	O
return	O
y	int
;	O
}	O
void	O
WBell	function
(	O
p	pointer
,	O
visual	int
)	O
struct	O
win	struct
*	O
p	pointer
;	O
int	O
visual	int
;	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
if	O
(	O
displays	pointer
==	O
NULL	O
)	O
p	pointer
->	O
w_bell	int
=	O
BELL_DONE	int
;	O
for	O
(	O
display	struct
=	O
displays	pointer
;	O
display	struct
;	O
display	struct
=	O
display	struct
->	O
d_next	pointer
)	O
{	O
for	O
(	O
cv	pointer
=	O
D_cvlist	O
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_next	pointer
)	O
if	O
(	O
cv	pointer
->	O
c_layer	pointer
->	O
l_bottom	pointer
==	O
&	O
p	pointer
->	O
w_layer	struct
)	O
break	O
;	O
if	O
(	O
cv	pointer
&&	O
!	O
visual	int
)	O
AddCStr	function
(	O
D_BL	O
)	O
;	O
else	O
if	O
(	O
cv	pointer
&&	O
D_VB	O
)	O
AddCStr	function
(	O
D_VB	O
)	O
;	O
else	O
p	pointer
->	O
w_bell	int
=	O
visual	int
?	O
BELL_VISUAL	int
:	O
BELL_FOUND	int
;	O
}	O
}	O
static	O
void	O
WReverseVideo	function
(	O
p	pointer
,	O
on	int
)	O
struct	O
win	struct
*	O
p	pointer
;	O
int	O
on	int
;	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
for	O
(	O
cv	pointer
=	O
p	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_lnext	pointer
)	O
{	O
display	struct
=	O
cv	pointer
->	O
c_display	pointer
;	O
if	O
(	O
cv	pointer
!=	O
D_forecv	O
)	O
continue	O
;	O
ReverseVideo	function
(	O
on	int
)	O
;	O
if	O
(	O
!	O
on	int
&&	O
p	pointer
->	O
w_revvid	int
&&	O
!	O
D_CVR	O
)	O
{	O
if	O
(	O
D_VB	O
)	O
AddCStr	function
(	O
D_VB	O
)	O
;	O
else	O
p	pointer
->	O
w_bell	int
=	O
BELL_VISUAL	int
;	O
}	O
}	O
}	O
void	O
WMsg	function
(	O
p	pointer
,	O
err	long
,	O
str	pointer
)	O
struct	O
win	struct
*	O
p	pointer
;	O
int	O
err	long
;	O
char	O
*	O
str	pointer
;	O
{	O
extern	O
struct	O
layer	struct
*	O
flayer	pointer
;	O
struct	O
layer	struct
*	O
oldflayer	pointer
=	O
flayer	pointer
;	O
flayer	pointer
=	O
&	O
p	pointer
->	O
w_layer	struct
;	O
LMsg	function
(	O
err	long
,	O
"%s"	pointer
,	O
str	pointer
)	O
;	O
flayer	pointer
=	O
oldflayer	pointer
;	O
}	O
void	O
WChangeSize	function
(	O
p	pointer
,	O
w	pointer
,	O
h	int
)	O
struct	O
win	struct
*	O
p	pointer
;	O
int	O
w	pointer
,	O
h	int
;	O
{	O
int	O
wok	int
=	O
0	int
;	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
if	O
(	O
p	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
==	O
0	int
)	O
{	O
ChangeWindowSize	function
(	O
p	pointer
,	O
w	pointer
,	O
h	int
,	O
p	pointer
->	O
w_histheight	int
)	O
;	O
return	O
;	O
}	O
for	O
(	O
cv	pointer
=	O
p	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_lnext	pointer
)	O
{	O
display	struct
=	O
cv	pointer
->	O
c_display	pointer
;	O
if	O
(	O
p	pointer
!=	O
D_fore	O
)	O
continue	O
;	O
if	O
(	O
D_CWS	O
)	O
break	O
;	O
if	O
(	O
D_CZ0	O
&&	O
(	O
w	pointer
==	O
Z0width	int
||	O
w	pointer
==	O
Z1width	int
)	O
)	O
wok	int
=	O
1	int
;	O
}	O
if	O
(	O
cv	pointer
==	O
0	int
&&	O
wok	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
!	O
D_CWS	O
)	O
h	int
=	O
p	pointer
->	O
w_height	O
;	O
ChangeWindowSize	function
(	O
p	pointer
,	O
w	pointer
,	O
h	int
,	O
p	pointer
->	O
w_histheight	int
)	O
;	O
for	O
(	O
display	struct
=	O
displays	pointer
;	O
display	struct
;	O
display	struct
=	O
display	struct
->	O
d_next	pointer
)	O
{	O
if	O
(	O
p	pointer
==	O
D_fore	O
)	O
{	O
if	O
(	O
D_cvlist	O
&&	O
D_cvlist	O
->	O
c_next	pointer
==	O
0	int
)	O
ResizeDisplay	function
(	O
w	pointer
,	O
h	int
)	O
;	O
else	O
ResizeDisplay	function
(	O
w	pointer
,	O
D_height	O
)	O
;	O
ResizeLayersToCanvases	function
(	O
)	O
;	O
continue	O
;	O
}	O
for	O
(	O
cv	pointer
=	O
D_cvlist	O
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_next	pointer
)	O
if	O
(	O
cv	pointer
->	O
c_layer	pointer
->	O
l_bottom	pointer
==	O
&	O
p	pointer
->	O
w_layer	struct
)	O
break	O
;	O
if	O
(	O
cv	pointer
)	O
Redisplay	function
(	O
0	int
)	O
;	O
}	O
}	O
static	O
int	O
WindowChangedCheck	function
(	O
s	pointer
,	O
what	int
,	O
hp	pointer
)	O
char	O
*	O
s	pointer
;	O
int	O
what	int
;	O
int	O
*	O
hp	pointer
;	O
{	O
int	O
h	int
=	O
0	int
;	O
int	O
l	int
;	O
while	O
(	O
*	O
s	pointer
)	O
{	O
if	O
(	O
*	O
s	pointer
++	O
!=	O
(	O
hp	pointer
?	O
'%'	O
:	O
'\005'	O
)	O
)	O
continue	O
;	O
l	int
=	O
0	int
;	O
s	pointer
+=	O
(	O
*	O
s	pointer
==	O
'+'	O
)	O
;	O
s	pointer
+=	O
(	O
*	O
s	pointer
==	O
'-'	O
)	O
;	O
while	O
(	O
*	O
s	pointer
>=	O
'0'	O
&&	O
*	O
s	pointer
<=	O
'9'	O
)	O
s	pointer
++	O
;	O
if	O
(	O
*	O
s	pointer
==	O
'L'	O
)	O
{	O
s	pointer
++	O
;	O
l	int
=	O
0x100	int
;	O
}	O
if	O
(	O
*	O
s	pointer
==	O
'h'	O
)	O
h	int
=	O
1	int
;	O
if	O
(	O
*	O
s	pointer
==	O
what	int
||	O
(	O
(	O
*	O
s	pointer
|	O
l	int
)	O
==	O
what	int
)	O
||	O
what	int
==	O
'd'	O
)	O
break	O
;	O
if	O
(	O
*	O
s	pointer
)	O
s	pointer
++	O
;	O
}	O
if	O
(	O
hp	pointer
)	O
*	O
hp	pointer
=	O
h	int
;	O
return	O
*	O
s	pointer
?	O
1	int
:	O
0	int
;	O
}	O
void	O
WindowChanged	function
(	O
p	pointer
,	O
what	int
)	O
struct	O
win	struct
*	O
p	pointer
;	O
int	O
what	int
;	O
{	O
int	O
inwstr	int
,	O
inhstr	int
,	O
inlstr	int
;	O
int	O
inwstrh	int
=	O
0	int
,	O
inhstrh	int
=	O
0	int
,	O
inlstrh	int
=	O
0	int
;	O
int	O
got	int
,	O
ox	int
,	O
oy	int
;	O
struct	O
display	struct
*	O
olddisplay	pointer
=	O
display	struct
;	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
inwstr	int
=	O
inhstr	int
=	O
0	int
;	O
if	O
(	O
what	int
==	O
'f'	O
)	O
{	O
WindowChanged	function
(	O
(	O
struct	O
win	struct
*	O
)	O
0	int
,	O
'w'	O
|	O
0x100	int
)	O
;	O
WindowChanged	function
(	O
(	O
struct	O
win	struct
*	O
)	O
0	int
,	O
'W'	O
|	O
0x100	int
)	O
;	O
}	O
if	O
(	O
what	int
)	O
{	O
inwstr	int
=	O
WindowChangedCheck	function
(	O
captionstring	pointer
,	O
what	int
,	O
&	O
inwstrh	int
)	O
;	O
inhstr	int
=	O
WindowChangedCheck	function
(	O
hstatusstring	pointer
,	O
what	int
,	O
&	O
inhstrh	int
)	O
;	O
inlstr	int
=	O
WindowChangedCheck	function
(	O
wliststr	pointer
,	O
what	int
,	O
&	O
inlstrh	int
)	O
;	O
}	O
else	O
{	O
inwstr	int
=	O
inhstr	int
=	O
0	int
;	O
inlstr	int
=	O
1	int
;	O
}	O
if	O
(	O
p	pointer
==	O
0	int
)	O
{	O
for	O
(	O
display	struct
=	O
displays	pointer
;	O
display	struct
;	O
display	struct
=	O
display	struct
->	O
d_next	pointer
)	O
{	O
ox	int
=	O
D_x	O
;	O
oy	int
=	O
D_y	O
;	O
for	O
(	O
cv	pointer
=	O
D_cvlist	O
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_next	pointer
)	O
{	O
if	O
(	O
inlstr	int
||	O
(	O
inlstrh	int
&&	O
p	pointer
&&	O
p	pointer
->	O
w_hstatus	pointer
&&	O
*	O
p	pointer
->	O
w_hstatus	pointer
&&	O
WindowChangedCheck	function
(	O
p	pointer
->	O
w_hstatus	pointer
,	O
what	int
,	O
(	O
int	O
*	O
)	O
0	int
)	O
)	O
)	O
WListUpdatecv	function
(	O
cv	pointer
,	O
(	O
struct	O
win	struct
*	O
)	O
0	int
)	O
;	O
p	pointer
=	O
Layer2Window	O
(	O
cv	pointer
->	O
c_layer	pointer
)	O
;	O
if	O
(	O
inwstr	int
||	O
(	O
inwstrh	int
&&	O
p	pointer
&&	O
p	pointer
->	O
w_hstatus	pointer
&&	O
*	O
p	pointer
->	O
w_hstatus	pointer
&&	O
WindowChangedCheck	function
(	O
p	pointer
->	O
w_hstatus	pointer
,	O
what	int
,	O
(	O
int	O
*	O
)	O
0	int
)	O
)	O
)	O
if	O
(	O
cv	pointer
->	O
c_ye	int
+	O
1	int
<	O
D_height	O
)	O
RefreshLine	function
(	O
cv	pointer
->	O
c_ye	int
+	O
1	int
,	O
0	int
,	O
D_width	O
-	O
1	int
,	O
0	int
)	O
;	O
}	O
p	pointer
=	O
D_fore	O
;	O
if	O
(	O
inhstr	int
||	O
(	O
inhstrh	int
&&	O
p	pointer
&&	O
p	pointer
->	O
w_hstatus	pointer
&&	O
*	O
p	pointer
->	O
w_hstatus	pointer
&&	O
WindowChangedCheck	function
(	O
p	pointer
->	O
w_hstatus	pointer
,	O
what	int
,	O
(	O
int	O
*	O
)	O
0	int
)	O
)	O
)	O
RefreshHStatus	function
(	O
)	O
;	O
if	O
(	O
ox	int
!=	O
-	O
1	int
&&	O
oy	int
!=	O
-	O
1	int
)	O
GotoPos	function
(	O
ox	int
,	O
oy	int
)	O
;	O
}	O
display	struct
=	O
olddisplay	pointer
;	O
return	O
;	O
}	O
if	O
(	O
p	pointer
->	O
w_hstatus	pointer
&&	O
*	O
p	pointer
->	O
w_hstatus	pointer
&&	O
(	O
inwstrh	int
||	O
inhstrh	int
||	O
inlstrh	int
)	O
&&	O
WindowChangedCheck	function
(	O
p	pointer
->	O
w_hstatus	pointer
,	O
what	int
,	O
(	O
int	O
*	O
)	O
0	int
)	O
)	O
{	O
inwstr	int
|=	O
inwstrh	int
;	O
inhstr	int
|=	O
inhstrh	int
;	O
inlstr	int
|=	O
inlstrh	int
;	O
}	O
if	O
(	O
!	O
inwstr	int
&&	O
!	O
inhstr	int
&&	O
!	O
inlstr	int
)	O
return	O
;	O
for	O
(	O
display	struct
=	O
displays	pointer
;	O
display	struct
;	O
display	struct
=	O
display	struct
->	O
d_next	pointer
)	O
{	O
got	int
=	O
0	int
;	O
ox	int
=	O
D_x	O
;	O
oy	int
=	O
D_y	O
;	O
for	O
(	O
cv	pointer
=	O
D_cvlist	O
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_next	pointer
)	O
{	O
if	O
(	O
inlstr	int
)	O
WListUpdatecv	function
(	O
cv	pointer
,	O
p	pointer
)	O
;	O
if	O
(	O
Layer2Window	O
(	O
cv	pointer
->	O
c_layer	pointer
)	O
!=	O
p	pointer
)	O
continue	O
;	O
got	int
=	O
1	int
;	O
if	O
(	O
inwstr	int
&&	O
cv	pointer
->	O
c_ye	int
+	O
1	int
<	O
D_height	O
)	O
RefreshLine	function
(	O
cv	pointer
->	O
c_ye	int
+	O
1	int
,	O
0	int
,	O
D_width	O
-	O
1	int
,	O
0	int
)	O
;	O
}	O
if	O
(	O
got	int
&&	O
inhstr	int
&&	O
p	pointer
==	O
D_fore	O
)	O
RefreshHStatus	function
(	O
)	O
;	O
if	O
(	O
ox	int
!=	O
-	O
1	int
&&	O
oy	int
!=	O
-	O
1	int
)	O
GotoPos	function
(	O
ox	int
,	O
oy	int
)	O
;	O
}	O
display	struct
=	O
olddisplay	pointer
;	O
}	O
