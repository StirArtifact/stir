enum	O
{	O
GETOPT_HELP_CHAR	int
=	O
(	O
CHAR_MIN	O
-	O
2	int
)	O
,	O
GETOPT_VERSION_CHAR	int
=	O
(	O
CHAR_MIN	O
-	O
3	int
)	O
,	O
GETOPT_JOIN_HELP_CHAR	int
=	O
(	O
CHAR_MIN	O
-	O
4	int
)	O
,	O
GETOPT_CUT_HELP_CHAR	int
=	O
(	O
CHAR_MIN	O
-	O
5	int
)	O
,	O
}	O
;	O
static	O
struct	O
option	struct
const	O
long_options	array
[	O
]	O
=	O
{	O
{	O
"hierarchy-key-fields"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'a'	O
}	O
,	O
{	O
"output-record-delimiter"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'b'	O
}	O
,	O
{	O
"input-record-delimiter"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'B'	O
}	O
,	O
{	O
"output-field-delimiter"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'd'	O
}	O
,	O
{	O
"no-output-field-delimiter"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPT_NO_OUTPUT_DELIMITER	int
}	O
,	O
{	O
"input-field-delimiter"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'D'	O
}	O
,	O
{	O
"no-input-field-delimiter"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPT_NO_INPUT_DELIMITER	int
}	O
,	O
{	O
"input-field-delimiter-repeat"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPT_INPUT_DELIMITER_REPEAT	int
}	O
,	O
{	O
"emulate"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'e'	O
}	O
,	O
{	O
"flag"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'f'	O
}	O
,	O
{	O
"flatten-hierarchy"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'F'	O
}	O
,	O
{	O
"hash-size"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'h'	O
}	O
,	O
{	O
"hash-movement"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'H'	O
}	O
,	O
{	O
"key-fields"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'k'	O
}	O
,	O
{	O
"output-constant"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'K'	O
}	O
,	O
{	O
"hierarchy-leaf-only"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'l'	O
}	O
,	O
{	O
"input-record-length"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'L'	O
}	O
,	O
{	O
"data-key-fields"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'm'	O
}	O
,	O
{	O
"data-is-reference"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'M'	O
}	O
,	O
{	O
"count"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'n'	O
}	O
,	O
{	O
"match-optional"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'p'	O
}	O
,	O
{	O
"exclude-match"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'P'	O
}	O
,	O
{	O
"output-fields"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'o'	O
}	O
,	O
{	O
"field-order"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'O'	O
}	O
,	O
{	O
"reference-file"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'r'	O
}	O
,	O
{	O
"check-all-reference"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'R'	O
}	O
,	O
{	O
"no-check-all-reference"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPT_NO_CHECK_ALL_REFERENCE	int
}	O
,	O
{	O
"sum-fields"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
's'	O
}	O
,	O
{	O
"output-file"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
't'	O
}	O
,	O
{	O
"unique"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'u'	O
}	O
,	O
{	O
"up-hierarchy"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'U'	O
}	O
,	O
{	O
"verbose"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'v'	O
}	O
,	O
{	O
"write-output"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'w'	O
}	O
,	O
{	O
"extension"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'x'	O
}	O
,	O
{	O
"extension-init-file"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'X'	O
}	O
,	O
{	O
"counter-size"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'z'	O
}	O
,	O
{	O
"statistics"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPT_STATISTICS	int
}	O
,	O
{	O
"no-statistics"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPT_NO_STATISTICS	int
}	O
,	O
{	O
GETOPT_HELP_OPTION_DECL	O
}	O
,	O
{	O
GETOPT_VERSION_OPTION_DECL	O
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
}	O
;	O
static	O
struct	O
option	struct
const	O
join_long_options	array
[	O
]	O
=	O
{	O
{	O
"file-1-key"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'1'	O
}	O
,	O
{	O
"file-2-key"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'2'	O
}	O
,	O
{	O
"print-unmatched-from"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'a'	O
}	O
,	O
{	O
"empty-replacement"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'e'	O
}	O
,	O
{	O
"ignore-case"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'i'	O
}	O
,	O
{	O
"join-key"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'j'	O
}	O
,	O
{	O
"output-format"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'o'	O
}	O
,	O
{	O
"delimiter"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
't'	O
}	O
,	O
{	O
"print-only-unmatched-from"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'v'	O
}	O
,	O
{	O
GETOPT_JOIN_HELP_OPTION_DECL	O
}	O
,	O
{	O
GETOPT_VERSION_OPTION_DECL	O
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
}	O
;	O
static	O
struct	O
option	struct
const	O
cut_long_options	array
[	O
]	O
=	O
{	O
{	O
"bytes"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'b'	O
}	O
,	O
{	O
"characters"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'c'	O
}	O
,	O
{	O
"delimiter"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'd'	O
}	O
,	O
{	O
"fields"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'f'	O
}	O
,	O
{	O
"only-delimited"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
's'	O
}	O
,	O
{	O
"output-delimiter"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
CUT_OPT_OUTPUT_DELIMITER	int
}	O
,	O
{	O
GETOPT_CUT_HELP_OPTION_DECL	O
}	O
,	O
{	O
GETOPT_VERSION_OPTION_DECL	O
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
}	O
;	O
void	O
expand_delimited_ranges	function
(	O
field_range	struct
*	O
*	O
,	O
int	O
*	O
)	O
;	O
int	O
initialize_variables	function
(	O
argc	int
,	O
argv	pointer
)	O
int	O
argc	int
;	O
char	O
*	O
*	O
argv	pointer
;	O
{	O
gi_reference_file_count	int
=	O
0	int
;	O
gi_data_is_reference	int
=	O
0	int
;	O
gi_output_counter_size	int
=	O
0	int
;	O
gi_counter_ind	int
=	O
0	int
;	O
gi_flag_ind	int
=	O
0	int
;	O
gi_verbose_ind	int
=	O
0	int
;	O
gi_statistics_ind	int
=	O
1	int
;	O
gi_checkallref_ind	int
=	O
1	int
;	O
gi_hashmovement_ind	enum
=	O
hm_binary_long	int
;	O
gi_no_output_field_delimiter	int
=	O
0	int
;	O
gi_data_write_ind	int
=	O
0	int
;	O
gi_data_suppress_empty_ind	int
=	O
0	int
;	O
gi_data_optional_ind	int
=	O
0	int
;	O
gi_data_exclude_match_ind	int
=	O
0	int
;	O
gi_data_out_end_start	int
=	O
0	int
;	O
gi_data_out_range_count	int
=	O
0	int
;	O
gi_data_sum_end_start	int
=	O
0	int
;	O
gi_data_sum_range_count	int
=	O
0	int
;	O
gi_allocated_reference_info	int
=	O
0	int
;	O
gi_data_records_read	int
=	O
0	int
;	O
gi_data_records_dropped_filter	int
=	O
0	int
;	O
gi_data_records_matched	int
=	O
0	int
;	O
gi_output_records_written	int
=	O
0	int
;	O
gi_file_records_read	int
=	O
0	int
;	O
gi_file_records_dropped_filter	int
=	O
0	int
;	O
gi_file_records_matched	int
=	O
0	int
;	O
gi_file_output_records_written	int
=	O
0	int
;	O
gi_data_input_buffer_size	long
=	O
0	int
;	O
gi_data_input_buffer_pos	long
=	O
0	int
;	O
gi_data_output_buffer_size	long
=	O
0	int
;	O
gi_data_output_buffer_pos	long
=	O
0	int
;	O
input_filename	pointer
=	O
NULL	O
;	O
output_filename	pointer
=	O
NULL	O
;	O
gs_data_output_buffer	pointer
=	O
NULL	O
;	O
gs_data_input_buffer	pointer
=	O
NULL	O
;	O
gs_output_field_delimiter	pointer
=	O
NULL	O
;	O
gs_output_record_delimiter	pointer
=	O
dstrdupstr	function
(	O
"\n"	pointer
)	O
;	O
gs_data_input_field_delimiter	pointer
=	O
NULL	O
;	O
gi_data_input_field_delimiter_repeat	int
=	O
0	int
;	O
gs_data_input_record_delimiter	pointer
=	O
dstrdupstr	function
(	O
"\n"	pointer
)	O
;	O
gs_data_constant_string	pointer
=	O
NULL	O
;	O
gs_data_missing_string	pointer
=	O
NULL	O
;	O
gs_data_empty_string	pointer
=	O
NULL	O
;	O
gs_data_output_file_name	pointer
=	O
NULL	O
;	O
gra_data_output_field_order	pointer
=	O
NULL	O
;	O
gi_data_output_field_order_count	int
=	O
0	int
;	O
gs_ext_init_file	pointer
=	O
NULL	O
;	O
gs_ext_begin_command	pointer
=	O
NULL	O
;	O
gs_ext_end_command	pointer
=	O
NULL	O
;	O
gs_data_ext_file_open_command	pointer
=	O
NULL	O
;	O
gs_data_ext_record_read_command	pointer
=	O
NULL	O
;	O
gs_data_ext_file_close_command	pointer
=	O
NULL	O
;	O
gs_data_ext_start_writing_command	pointer
=	O
NULL	O
;	O
gs_data_ext_record_write_command	pointer
=	O
NULL	O
;	O
gs_data_ext_finished_writing_command	pointer
=	O
NULL	O
;	O
gs_data_ext_filter_command	pointer
=	O
NULL	O
;	O
gs_data_ext_match_command	pointer
=	O
NULL	O
;	O
gi_allocated_reference_info	int
=	O
16	int
;	O
gra_reference_file_info	pointer
=	O
malloc	function
(	O
gi_allocated_reference_info	int
*	O
(	O
sizeof	O
*	O
gra_reference_file_info	pointer
)	O
)	O
;	O
program_name	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
field_type	enum
=	O
undefined_mode	int
;	O
input_delimiter	int
=	O
'\0'	O
;	O
return	O
EXIT_SUCCESS	int
;	O
}	O
int	O
calculate_ranges	function
(	O
string	pointer
,	O
ranges	pointer
,	O
end_range_start	pointer
,	O
range_count	pointer
)	O
char	O
*	O
string	pointer
;	O
field_range	struct
*	O
*	O
ranges	pointer
;	O
int	O
*	O
end_range_start	pointer
;	O
int	O
*	O
range_count	pointer
;	O
{	O
int	O
field_found	int
;	O
unsigned	O
int	O
start_value	int
;	O
unsigned	O
int	O
end_value	int
;	O
unsigned	O
int	O
precision	int
;	O
unsigned	O
int	O
n_ranges	int
;	O
unsigned	O
int	O
n_ranges_allocated	int
;	O
char	O
*	O
string_copy	pointer
;	O
char	O
*	O
current_range	pointer
;	O
char	O
*	O
rest_of_string	pointer
;	O
char	O
*	O
current_comment	pointer
;	O
if	O
(	O
strlen	function
(	O
string	pointer
)	O
==	O
0	int
)	O
{	O
*	O
end_range_start	pointer
=	O
0	int
;	O
*	O
range_count	pointer
=	O
0	int
;	O
*	O
ranges	pointer
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
n_ranges	int
=	O
0	int
;	O
n_ranges_allocated	int
=	O
16	int
;	O
*	O
ranges	pointer
=	O
(	O
field_range	struct
*	O
)	O
malloc	function
(	O
n_ranges_allocated	int
*	O
sizeof	O
(	O
*	O
*	O
ranges	pointer
)	O
)	O
;	O
string_copy	pointer
=	O
strdup	function
(	O
string	pointer
)	O
;	O
if	O
(	O
string_copy	pointer
==	O
NULL	O
)	O
return	O
EXIT_FAILURE	int
;	O
rest_of_string	pointer
=	O
string_copy	pointer
;	O
while	O
(	O
rest_of_string	pointer
!=	O
NULL	O
)	O
{	O
current_range	pointer
=	O
strsep	function
(	O
&	O
rest_of_string	pointer
,	O
","	pointer
)	O
;	O
start_value	int
=	O
0	int
;	O
end_value	int
=	O
0	int
;	O
precision	int
=	O
0	int
;	O
current_comment	pointer
=	O
NULL	O
;	O
if	O
(	O
*	O
current_range	pointer
!=	O
'-'	O
)	O
{	O
start_value	int
=	O
strtol	function
(	O
current_range	pointer
,	O
&	O
current_range	pointer
,	O
0	int
)	O
;	O
}	O
if	O
(	O
*	O
current_range	pointer
==	O
'-'	O
)	O
{	O
current_range	pointer
++	O
;	O
end_value	int
=	O
strtol	function
(	O
current_range	pointer
,	O
&	O
current_range	pointer
,	O
0	int
)	O
;	O
}	O
else	O
end_value	int
=	O
start_value	int
;	O
if	O
(	O
*	O
current_range	pointer
==	O
'.'	O
)	O
{	O
current_range	pointer
++	O
;	O
precision	int
=	O
strtol	function
(	O
current_range	pointer
,	O
&	O
current_range	pointer
,	O
0	int
)	O
;	O
}	O
current_comment	pointer
=	O
current_range	pointer
;	O
if	O
(	O
*	O
current_comment	pointer
==	O
'\0'	O
)	O
current_comment	pointer
=	O
NULL	O
;	O
if	O
(	O
start_value	int
==	O
0	int
&&	O
end_value	int
==	O
0	int
)	O
FATAL_ERROR1	O
(	O
_	O
(	O
"invalid field specification: %s"	pointer
)	O
,	O
string	pointer
)	O
;	O
if	O
(	O
start_value	int
==	O
0	int
)	O
start_value	int
=	O
1	int
;	O
if	O
(	O
end_value	int
==	O
0	int
)	O
{	O
*	O
end_range_start	pointer
=	O
start_value	int
;	O
}	O
else	O
{	O
if	O
(	O
start_value	int
>	O
end_value	int
)	O
FATAL_ERROR2	O
(	O
_	O
(	O
"invalid field range: start %d, end %d"	pointer
)	O
,	O
start_value	int
,	O
end_value	int
)	O
;	O
ADD_RANGE_PAIR	O
(	O
(	O
*	O
ranges	pointer
)	O
,	O
start_value	int
,	O
end_value	int
,	O
precision	int
,	O
current_comment	pointer
)	O
;	O
}	O
}	O
free	function
(	O
string_copy	pointer
)	O
;	O
*	O
range_count	pointer
=	O
n_ranges	int
;	O
return	O
field_found	int
;	O
}	O
int	O
write_user_request	function
(	O
)	O
{	O
int	O
i	int
;	O
int	O
j	int
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"General options:\n"	pointer
)	O
)	O
;	O
if	O
(	O
gs_output_field_delimiter	pointer
!=	O
NULL	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  String separating fields in ouput: [%.*s]\n"	pointer
)	O
,	O
(	O
int	O
)	O
(	O
gs_output_field_delimiter	pointer
->	O
length	long
)	O
,	O
gs_output_field_delimiter	pointer
->	O
string	pointer
)	O
;	O
if	O
(	O
gi_output_counter_size	int
!=	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  Length of any counter or sum values in reference-based output: %d\n"	pointer
)	O
,	O
gi_output_counter_size	int
)	O
;	O
if	O
(	O
gi_counter_ind	int
!=	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  Writing a count of data file matches in reference-based output.\n"	pointer
)	O
)	O
;	O
if	O
(	O
gi_flag_ind	int
!=	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  Writing a flag for data file matches in reference-based output.\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Data files to process: "	pointer
)	O
)	O
;	O
if	O
(	O
filecount	int
==	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"<stdin>"	pointer
)	O
;	O
else	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
filecount	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
>	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
", "	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s"	pointer
,	O
filenames	pointer
[	O
i	int
]	O
)	O
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
if	O
(	O
gi_data_write_ind	int
!=	O
0	int
)	O
{	O
if	O
(	O
gs_data_output_file_name	pointer
!=	O
NULL	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  Writing data-file-based output to file %s\n"	pointer
)	O
,	O
gs_data_output_file_name	pointer
)	O
;	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  Writing data-file-based output to stdout\n"	pointer
)	O
)	O
;	O
if	O
(	O
gi_data_out_range_count	int
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  Data fields written to the data-based output file:\n  Start   End Precision Instructions\n  ----- ----- --------- ------------\n"	pointer
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
gi_data_out_range_count	int
;	O
i	int
++	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"  %5ld %5ld %9d %s\n"	pointer
,	O
gra_data_out_ranges	pointer
[	O
i	int
]	O
.	O
lower_bound	long
,	O
gra_data_out_ranges	pointer
[	O
i	int
]	O
.	O
upper_bound	long
,	O
gra_data_out_ranges	pointer
[	O
i	int
]	O
.	O
precision	int
,	O
gra_data_out_ranges	pointer
[	O
i	int
]	O
.	O
format	pointer
)	O
;	O
}	O
if	O
(	O
gi_data_out_end_start	int
!=	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  %5d   End %9d %s\n"	pointer
)	O
,	O
gi_data_out_end_start	int
,	O
0	int
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
}	O
if	O
(	O
gi_data_sum_range_count	int
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  Data fields to be summed in reference-based output:\n  Start   End Precision Instructions\n  ----- ----- --------- ------------\n"	pointer
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
gi_data_sum_range_count	int
;	O
i	int
++	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"  %5ld %5ld %9d %s\n"	pointer
,	O
gra_data_sum_ranges	pointer
[	O
i	int
]	O
.	O
lower_bound	long
,	O
gra_data_sum_ranges	pointer
[	O
i	int
]	O
.	O
upper_bound	long
,	O
gra_data_sum_ranges	pointer
[	O
i	int
]	O
.	O
precision	int
,	O
gra_data_sum_ranges	pointer
[	O
i	int
]	O
.	O
format	pointer
)	O
;	O
}	O
if	O
(	O
gi_data_sum_end_start	int
!=	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  %5d   End %9d %s\n"	pointer
)	O
,	O
gi_data_sum_end_start	int
,	O
0	int
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
if	O
(	O
gs_data_constant_string	pointer
!=	O
NULL	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  Constant value accompanying data fields in ouput: [%.*s]\n"	pointer
)	O
,	O
(	O
int	O
)	O
(	O
gs_data_constant_string	pointer
->	O
length	long
)	O
,	O
gs_data_constant_string	pointer
->	O
string	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
gi_reference_file_count	int
;	O
i	int
++	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Reference file number %d: %s\n"	pointer
)	O
,	O
i	int
+	O
1	int
,	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
file_name	pointer
)	O
;	O
if	O
(	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
out_range_count	int
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  Reference fields to be written in all output:\n  Start   End Precision Instructions\n  ----- ----- --------- ------------\n"	pointer
)	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
out_range_count	int
;	O
j	int
++	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"  %5ld %5ld %9d %s\n"	pointer
,	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
out_ranges	pointer
[	O
j	int
]	O
.	O
lower_bound	long
,	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
out_ranges	pointer
[	O
j	int
]	O
.	O
upper_bound	long
,	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
out_ranges	pointer
[	O
j	int
]	O
.	O
precision	int
,	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
out_ranges	pointer
[	O
j	int
]	O
.	O
format	pointer
)	O
;	O
}	O
if	O
(	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
out_end_start	int
!=	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  %5d   End %9d %s\n"	pointer
)	O
,	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
out_end_start	int
,	O
0	int
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
if	O
(	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
key_range_count	int
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  Reference fields to match data file keys:\n  Start   End Precision Instructions\n  ----- ----- --------- ------------\n"	pointer
)	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
key_range_count	int
;	O
j	int
++	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"  %5ld %5ld %9d %s\n"	pointer
,	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
key_ranges	pointer
[	O
j	int
]	O
.	O
lower_bound	long
,	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
key_ranges	pointer
[	O
j	int
]	O
.	O
upper_bound	long
,	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
key_ranges	pointer
[	O
j	int
]	O
.	O
precision	int
,	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
key_ranges	pointer
[	O
j	int
]	O
.	O
format	pointer
)	O
;	O
}	O
if	O
(	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
key_end_start	int
!=	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  %5d   End %9d %s\n"	pointer
)	O
,	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
key_end_start	int
,	O
0	int
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
if	O
(	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
data_key_range_count	int
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  Data fields to match keys in this reference file:\n  Start   End Precision Instructions\n  ----- ----- --------- ------------\n"	pointer
)	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
data_key_range_count	int
;	O
j	int
++	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"  %5ld %5ld %9d %s\n"	pointer
,	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
data_key_ranges	pointer
[	O
j	int
]	O
.	O
lower_bound	long
,	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
data_key_ranges	pointer
[	O
j	int
]	O
.	O
upper_bound	long
,	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
data_key_ranges	pointer
[	O
j	int
]	O
.	O
precision	int
,	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
data_key_ranges	pointer
[	O
j	int
]	O
.	O
format	pointer
)	O
;	O
}	O
if	O
(	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
data_key_end_start	int
!=	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  %5d   End %9d %s\n"	pointer
)	O
,	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
data_key_end_start	int
,	O
0	int
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
if	O
(	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
hrchy_key_range_count	int
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  Traversing hierarchy using these keys to connect to next record in this file:\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  Start   End Precision Instructions\n  ----- ----- --------- ------------\n"	pointer
)	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
hrchy_key_range_count	int
;	O
j	int
++	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"  %5ld %5ld %9d %s\n"	pointer
,	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
hrchy_key_ranges	pointer
[	O
j	int
]	O
.	O
lower_bound	long
,	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
hrchy_key_ranges	pointer
[	O
j	int
]	O
.	O
upper_bound	long
,	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
hrchy_key_ranges	pointer
[	O
j	int
]	O
.	O
precision	int
,	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
hrchy_key_ranges	pointer
[	O
j	int
]	O
.	O
format	pointer
)	O
;	O
}	O
if	O
(	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
hrchy_key_end_start	int
!=	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  %5d   End %9d %s\n"	pointer
)	O
,	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
hrchy_key_end_start	int
,	O
0	int
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
if	O
(	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
hrchy_flatten_levels	int
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  Reference fields from this file will be repeated %d times to report each level"	pointer
)	O
,	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
hrchy_flatten_levels	int
)	O
;	O
}	O
else	O
if	O
(	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
hrchy_leaf_only	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  Terminal nodes encountered in the hierarchy will be treated as matching reference records.\n"	pointer
)	O
)	O
;	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  Each node encountered in the hierarchy will be treated as a matching reference record.\n"	pointer
)	O
)	O
;	O
}	O
if	O
(	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
unique_ind	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  Keeping only one copy of each key value.\n"	pointer
)	O
)	O
;	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  Keeping all copies of each key value.\n"	pointer
)	O
)	O
;	O
if	O
(	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
optional_ind	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  Matches to this file optional for data output.\n"	pointer
)	O
)	O
;	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  Matches to this file required for data output.\n"	pointer
)	O
)	O
;	O
if	O
(	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
write_ind	int
)	O
{	O
if	O
(	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
output_file_name	pointer
!=	O
NULL	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  Writing output to %s\n"	pointer
)	O
,	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
output_file_name	pointer
)	O
;	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  Writing output to stdout\n"	pointer
)	O
)	O
;	O
}	O
if	O
(	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
constant_string	pointer
!=	O
NULL	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  Constant value to accompany all reference output: [%.*s]\n"	pointer
)	O
,	O
(	O
int	O
)	O
(	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
constant_string	pointer
->	O
length	long
)	O
,	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
constant_string	pointer
->	O
string	pointer
)	O
;	O
}	O
return	O
EXIT_SUCCESS	int
;	O
}	O
int	O
validate_options	function
(	O
)	O
{	O
int	O
i	int
;	O
int	O
j	int
;	O
if	O
(	O
gs_data_input_field_delimiter	pointer
!=	O
NULL	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
gi_reference_file_count	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
input_field_delimiter	pointer
==	O
NULL	O
&&	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
no_input_field_delimiter	int
==	O
0	int
)	O
gra_reference_file_info	pointer
[	O
i	int
]	O
.	O
input_field_delimiter	pointer
=	O
gs_data_input_field_delimiter	pointer
;	O
}	O
if	O
(	O
gs_output_field_delimiter	pointer
==	O
NULL	O
&&	O
gi_no_output_field_delimiter	int
==	O
0	int
)	O
gs_output_field_delimiter	pointer
=	O
gs_data_input_field_delimiter	pointer
;	O
}	O
if	O
(	O
gs_data_input_field_delimiter	pointer
!=	O
NULL	O
)	O
{	O
expand_delimited_ranges	function
(	O
&	O
gra_data_out_ranges	pointer
,	O
&	O
gi_data_out_range_count	int
)	O
;	O
expand_delimited_ranges	function
(	O
&	O
gra_data_sum_ranges	pointer
,	O
&	O
gi_data_sum_range_count	int
)	O
;	O
}	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
gi_reference_file_count	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
gs_data_input_field_delimiter	pointer
!=	O
NULL	O
)	O
expand_delimited_ranges	function
(	O
&	O
(	O
gra_reference_file_info	pointer
[	O
j	int
]	O
.	O
data_key_ranges	pointer
)	O
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
j	int
]	O
.	O
data_key_range_count	int
)	O
)	O
;	O
if	O
(	O
gra_reference_file_info	pointer
[	O
j	int
]	O
.	O
input_field_delimiter	pointer
!=	O
NULL	O
)	O
{	O
expand_delimited_ranges	function
(	O
&	O
(	O
gra_reference_file_info	pointer
[	O
j	int
]	O
.	O
key_ranges	pointer
)	O
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
j	int
]	O
.	O
key_range_count	int
)	O
)	O
;	O
expand_delimited_ranges	function
(	O
&	O
(	O
gra_reference_file_info	pointer
[	O
j	int
]	O
.	O
hrchy_key_ranges	pointer
)	O
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
j	int
]	O
.	O
hrchy_key_range_count	int
)	O
)	O
;	O
expand_delimited_ranges	function
(	O
&	O
(	O
gra_reference_file_info	pointer
[	O
j	int
]	O
.	O
out_ranges	pointer
)	O
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
j	int
]	O
.	O
out_range_count	int
)	O
)	O
;	O
}	O
}	O
if	O
(	O
gra_data_output_field_order	pointer
!=	O
NULL	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
gi_data_output_field_order_count	int
;	O
i	int
++	O
)	O
{	O
switch	O
(	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
source	char
)	O
{	O
case	O
'r'	O
:	O
if	O
(	O
gi_reference_file_count	int
<	O
1	int
||	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
source_num	int
>	O
gi_reference_file_count	int
)	O
FATAL_ERROR1	O
(	O
_	O
(	O
"requested non-existent reference file %d in data-output ordering"	pointer
)	O
,	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
source_num	int
)	O
;	O
switch	O
(	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type	char
)	O
{	O
case	O
'f'	O
:	O
case	O
'n'	O
:	O
case	O
's'	O
:	O
FATAL_ERROR	O
(	O
_	O
(	O
"requested flag, counter, or sum in data-output ordering"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
'o'	O
:	O
if	O
(	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type_num	int
==	O
0	int
||	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type_num	int
>	O
TOTAL_REF_OUT_RANGES	O
(	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
source_num	int
-	O
1	int
)	O
||	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type_num	int
<	O
-	O
1	int
*	O
TOTAL_REF_OUT_RANGES	O
(	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
source_num	int
-	O
1	int
)	O
)	O
FATAL_ERROR2	O
(	O
_	O
(	O
"requested non-existent reference field %d in refrence file %d in data-output ordering"	pointer
)	O
,	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type_num	int
,	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
source_num	int
)	O
;	O
break	O
;	O
case	O
'k'	O
:	O
if	O
(	O
gra_reference_file_info	pointer
[	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
source_num	int
]	O
.	O
constant_string	pointer
==	O
NULL	O
)	O
FATAL_ERROR1	O
(	O
_	O
(	O
"requested non-existent reference constant string from reference file %d in data-output ordering"	pointer
)	O
,	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
source_num	int
)	O
;	O
break	O
;	O
default	O
:	O
FATAL_ERROR1	O
(	O
_	O
(	O
"unknown reference field type '%c' requested in data-output ordering"	pointer
)	O
,	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type	char
)	O
;	O
}	O
break	O
;	O
case	O
'd'	O
:	O
case	O
's'	O
:	O
switch	O
(	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type	char
)	O
{	O
case	O
'f'	O
:	O
case	O
'n'	O
:	O
case	O
's'	O
:	O
FATAL_ERROR	O
(	O
_	O
(	O
"requested flag, counter, or sum from data file in data-output ordering"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
'o'	O
:	O
if	O
(	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type_num	int
==	O
0	int
||	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type_num	int
>	O
gi_data_out_range_count	int
+	O
(	O
gi_data_out_end_start	int
!=	O
0	int
?	O
1	int
:	O
0	int
)	O
||	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type_num	int
<	O
-	O
1	int
*	O
gi_data_out_range_count	int
-	O
(	O
gi_data_out_end_start	int
!=	O
0	int
?	O
1	int
:	O
0	int
)	O
)	O
FATAL_ERROR1	O
(	O
_	O
(	O
"requested non-existent data field %d in data-output ordering"	pointer
)	O
,	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type_num	int
)	O
;	O
break	O
;	O
case	O
'k'	O
:	O
if	O
(	O
gs_data_constant_string	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"requested non-existent data constant string in data-output ordering"	pointer
)	O
)	O
;	O
break	O
;	O
default	O
:	O
FATAL_ERROR1	O
(	O
_	O
(	O
"unknown data field type %c requested in data-output ordering"	pointer
)	O
,	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type	char
)	O
;	O
}	O
break	O
;	O
default	O
:	O
FATAL_ERROR1	O
(	O
_	O
(	O
"unknown field source %c requested in data-output ordering"	pointer
)	O
,	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
source	char
)	O
;	O
}	O
}	O
}	O
if	O
(	O
gi_data_is_reference	int
!=	O
0	int
)	O
{	O
if	O
(	O
gi_reference_file_count	int
!=	O
1	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"single-pass reading of one file as both reference and data requires exactly one reference file"	pointer
)	O
)	O
;	O
if	O
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
data_key_end_start	int
!=	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
key_end_start	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"single-pass reading of one file as both reference and data requires identical keys"	pointer
)	O
)	O
;	O
if	O
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
data_key_range_count	int
!=	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
key_range_count	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"single-pass reading of one file as both reference and data requires identical keys"	pointer
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
key_range_count	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
data_key_ranges	pointer
[	O
i	int
]	O
.	O
upper_bound	long
!=	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
key_ranges	pointer
[	O
i	int
]	O
.	O
upper_bound	long
)	O
||	O
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
data_key_ranges	pointer
[	O
i	int
]	O
.	O
lower_bound	long
!=	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
key_ranges	pointer
[	O
i	int
]	O
.	O
lower_bound	long
)	O
||	O
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
data_key_ranges	pointer
[	O
i	int
]	O
.	O
precision	int
!=	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
key_ranges	pointer
[	O
i	int
]	O
.	O
precision	int
)	O
||	O
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
data_key_ranges	pointer
[	O
i	int
]	O
.	O
format	pointer
!=	O
NULL	O
&&	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
key_ranges	pointer
[	O
i	int
]	O
.	O
format	pointer
!=	O
NULL	O
&&	O
strcmp	function
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
data_key_ranges	pointer
[	O
i	int
]	O
.	O
format	pointer
,	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
key_ranges	pointer
[	O
i	int
]	O
.	O
format	pointer
)	O
!=	O
0	int
)	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"single-pass reading of one file as both reference and data requires identical keys"	pointer
)	O
)	O
;	O
}	O
if	O
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
unique_ind	int
==	O
0	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"single-pass reading of one file as both reference and data requires unique keys"	pointer
)	O
)	O
;	O
if	O
(	O
gi_data_write_ind	int
!=	O
0	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"single-pass reading of one file as both reference and data makes no sense with data=file-based output"	pointer
)	O
)	O
;	O
}	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
gi_reference_file_count	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
gra_reference_file_info	pointer
[	O
j	int
]	O
.	O
output_field_order	pointer
!=	O
NULL	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
gra_reference_file_info	pointer
[	O
j	int
]	O
.	O
output_field_order_count	int
;	O
i	int
++	O
)	O
{	O
switch	O
(	O
gra_reference_file_info	pointer
[	O
j	int
]	O
.	O
output_field_order	pointer
[	O
i	int
]	O
.	O
source	char
)	O
{	O
case	O
'r'	O
:	O
if	O
(	O
(	O
gra_reference_file_info	pointer
[	O
j	int
]	O
.	O
output_field_order	pointer
[	O
i	int
]	O
.	O
source_num	int
>	O
gi_reference_file_count	int
)	O
||	O
(	O
gra_reference_file_info	pointer
[	O
j	int
]	O
.	O
output_field_order	pointer
[	O
i	int
]	O
.	O
source_num	int
<	O
-	O
1	int
*	O
gi_reference_file_count	int
)	O
||	O
(	O
gra_reference_file_info	pointer
[	O
j	int
]	O
.	O
output_field_order	pointer
[	O
i	int
]	O
.	O
source_num	int
==	O
0	int
)	O
)	O
FATAL_ERROR2	O
(	O
_	O
(	O
"requested non-existent reference file %d in output ordering for reference file %d"	pointer
)	O
,	O
gra_reference_file_info	pointer
[	O
j	int
]	O
.	O
output_field_order	pointer
[	O
i	int
]	O
.	O
source_num	int
,	O
j	int
+	O
1	int
)	O
;	O
if	O
(	O
(	O
gra_reference_file_info	pointer
[	O
j	int
]	O
.	O
output_field_order	pointer
[	O
i	int
]	O
.	O
source_num	int
!=	O
j	int
+	O
1	int
)	O
&&	O
(	O
gra_reference_file_info	pointer
[	O
j	int
]	O
.	O
output_field_order	pointer
[	O
i	int
]	O
.	O
source_num	int
!=	O
0	int
)	O
)	O
FATAL_ERROR2	O
(	O
_	O
(	O
"reference file %d order requests fields from reference file %d"	pointer
)	O
,	O
j	int
+	O
1	int
,	O
gra_reference_file_info	pointer
[	O
j	int
]	O
.	O
output_field_order	pointer
[	O
i	int
]	O
.	O
source_num	int
)	O
;	O
switch	O
(	O
gra_reference_file_info	pointer
[	O
j	int
]	O
.	O
output_field_order	pointer
[	O
i	int
]	O
.	O
type	char
)	O
{	O
case	O
'n'	O
:	O
if	O
(	O
gi_counter_ind	int
==	O
0	int
)	O
FATAL_ERROR1	O
(	O
_	O
(	O
"requested non-existent counter in output from reference file %d"	pointer
)	O
,	O
j	int
)	O
;	O
break	O
;	O
case	O
's'	O
:	O
if	O
(	O
NUM_COUNTERS	O
-	O
2	int
<	O
gra_reference_file_info	pointer
[	O
j	int
]	O
.	O
output_field_order	pointer
[	O
i	int
]	O
.	O
type_num	int
)	O
FATAL_ERROR2	O
(	O
_	O
(	O
"requested sum %d when only %d sum fields were specified"	pointer
)	O
,	O
gra_reference_file_info	pointer
[	O
j	int
]	O
.	O
output_field_order	pointer
[	O
i	int
]	O
.	O
type_num	int
,	O
NUM_COUNTERS	O
-	O
2	int
)	O
;	O
break	O
;	O
case	O
'f'	O
:	O
if	O
(	O
gi_flag_ind	int
==	O
0	int
)	O
FATAL_ERROR1	O
(	O
_	O
(	O
"requested non-existent flag in output from reference file %d"	pointer
)	O
,	O
j	int
)	O
;	O
break	O
;	O
case	O
'o'	O
:	O
if	O
(	O
gra_reference_file_info	pointer
[	O
j	int
]	O
.	O
output_field_order	pointer
[	O
i	int
]	O
.	O
type_num	int
<	O
1	int
||	O
gra_reference_file_info	pointer
[	O
j	int
]	O
.	O
output_field_order	pointer
[	O
i	int
]	O
.	O
type_num	int
>	O
gra_reference_file_info	pointer
[	O
j	int
]	O
.	O
out_range_count	int
)	O
FATAL_ERROR2	O
(	O
_	O
(	O
"requested non-existent reference field %d in reference file %d in reference-output ordering"	pointer
)	O
,	O
gra_reference_file_info	pointer
[	O
j	int
]	O
.	O
output_field_order	pointer
[	O
i	int
]	O
.	O
type_num	int
,	O
gra_reference_file_info	pointer
[	O
j	int
]	O
.	O
output_field_order	pointer
[	O
i	int
]	O
.	O
source_num	int
)	O
;	O
break	O
;	O
case	O
'k'	O
:	O
if	O
(	O
gra_reference_file_info	pointer
[	O
j	int
]	O
.	O
constant_string	pointer
==	O
NULL	O
)	O
FATAL_ERROR1	O
(	O
_	O
(	O
"requested non-existent reference constant string from reference file %d in reference-output ordering"	pointer
)	O
,	O
gra_reference_file_info	pointer
[	O
j	int
]	O
.	O
output_field_order	pointer
[	O
i	int
]	O
.	O
source_num	int
)	O
;	O
break	O
;	O
default	O
:	O
FATAL_ERROR1	O
(	O
_	O
(	O
"unknown reference field type '%c' requested in reference-output ordering"	pointer
)	O
,	O
gra_reference_file_info	pointer
[	O
j	int
]	O
.	O
output_field_order	pointer
[	O
i	int
]	O
.	O
type	char
)	O
;	O
}	O
break	O
;	O
case	O
'd'	O
:	O
case	O
's'	O
:	O
switch	O
(	O
gra_reference_file_info	pointer
[	O
j	int
]	O
.	O
output_field_order	pointer
[	O
i	int
]	O
.	O
type	char
)	O
{	O
case	O
'f'	O
:	O
case	O
'n'	O
:	O
case	O
's'	O
:	O
FATAL_ERROR	O
(	O
_	O
(	O
"requested flag, counter, or sum from data file in reference-output ordering"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
'o'	O
:	O
if	O
(	O
gra_reference_file_info	pointer
[	O
j	int
]	O
.	O
output_field_order	pointer
[	O
i	int
]	O
.	O
type_num	int
<	O
1	int
||	O
gra_reference_file_info	pointer
[	O
j	int
]	O
.	O
output_field_order	pointer
[	O
i	int
]	O
.	O
type_num	int
>	O
gi_data_out_range_count	int
)	O
FATAL_ERROR1	O
(	O
_	O
(	O
"requested non-existent data field %d in reference-output ordering"	pointer
)	O
,	O
gra_reference_file_info	pointer
[	O
j	int
]	O
.	O
output_field_order	pointer
[	O
i	int
]	O
.	O
type_num	int
)	O
;	O
break	O
;	O
case	O
'k'	O
:	O
if	O
(	O
gs_data_constant_string	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"requested non-existent data constant string in reference-output ordering"	pointer
)	O
)	O
;	O
break	O
;	O
default	O
:	O
FATAL_ERROR1	O
(	O
_	O
(	O
"unknown data field type %c requested in reference-output ordering"	pointer
)	O
,	O
gra_reference_file_info	pointer
[	O
j	int
]	O
.	O
output_field_order	pointer
[	O
i	int
]	O
.	O
type	char
)	O
;	O
}	O
break	O
;	O
default	O
:	O
FATAL_ERROR1	O
(	O
_	O
(	O
"unknown field source %c requested in reference-output ordering"	pointer
)	O
,	O
gra_reference_file_info	pointer
[	O
j	int
]	O
.	O
output_field_order	pointer
[	O
i	int
]	O
.	O
source	char
)	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
gs_ext_init_file	pointer
!=	O
NULL	O
)	O
FATAL_ERROR2	O
(	O
_	O
(	O
"specified extension processing without Guile installed: %.*s"	pointer
)	O
,	O
gs_ext_init_file	pointer
->	O
length	long
,	O
gs_ext_init_file	pointer
->	O
string	pointer
)	O
;	O
if	O
(	O
gs_ext_begin_command	pointer
!=	O
NULL	O
)	O
FATAL_ERROR2	O
(	O
_	O
(	O
"specified extension processing without Guile installed: %.*s"	pointer
)	O
,	O
gs_ext_begin_command	pointer
->	O
length	long
,	O
gs_ext_begin_command	pointer
->	O
string	pointer
)	O
;	O
if	O
(	O
gs_ext_end_command	pointer
!=	O
NULL	O
)	O
FATAL_ERROR2	O
(	O
_	O
(	O
"specified extension processing without Guile installed: %.*s"	pointer
)	O
,	O
gs_ext_end_command	pointer
->	O
length	long
,	O
gs_ext_end_command	pointer
->	O
string	pointer
)	O
;	O
if	O
(	O
gs_data_ext_file_open_command	pointer
!=	O
NULL	O
)	O
FATAL_ERROR2	O
(	O
_	O
(	O
"specified extension processing without Guile installed: %.*s"	pointer
)	O
,	O
gs_data_ext_file_open_command	pointer
->	O
length	long
,	O
gs_data_ext_file_open_command	pointer
->	O
string	pointer
)	O
;	O
if	O
(	O
gs_data_ext_record_read_command	pointer
!=	O
NULL	O
)	O
FATAL_ERROR2	O
(	O
_	O
(	O
"specified extension processing without Guile installed: %.*s"	pointer
)	O
,	O
gs_data_ext_record_read_command	pointer
->	O
length	long
,	O
gs_data_ext_record_read_command	pointer
->	O
string	pointer
)	O
;	O
if	O
(	O
gs_data_ext_file_close_command	pointer
!=	O
NULL	O
)	O
FATAL_ERROR2	O
(	O
_	O
(	O
"specified extension processing without Guile installed: %.*s"	pointer
)	O
,	O
gs_data_ext_file_close_command	pointer
->	O
length	long
,	O
gs_data_ext_file_close_command	pointer
->	O
string	pointer
)	O
;	O
if	O
(	O
gs_data_ext_start_writing_command	pointer
!=	O
NULL	O
)	O
FATAL_ERROR2	O
(	O
_	O
(	O
"specified extension processing without Guile installed: %.*s"	pointer
)	O
,	O
gs_data_ext_start_writing_command	pointer
->	O
length	long
,	O
gs_data_ext_start_writing_command	pointer
->	O
string	pointer
)	O
;	O
if	O
(	O
gs_data_ext_record_write_command	pointer
!=	O
NULL	O
)	O
FATAL_ERROR2	O
(	O
_	O
(	O
"specified extension processing without Guile installed: %.*s"	pointer
)	O
,	O
gs_data_ext_record_write_command	pointer
->	O
length	long
,	O
gs_data_ext_record_write_command	pointer
->	O
string	pointer
)	O
;	O
if	O
(	O
gs_data_ext_finished_writing_command	pointer
!=	O
NULL	O
)	O
FATAL_ERROR2	O
(	O
_	O
(	O
"specified extension processing without Guile installed: %.*s"	pointer
)	O
,	O
gs_data_ext_finished_writing_command	pointer
->	O
length	long
,	O
gs_data_ext_finished_writing_command	pointer
->	O
string	pointer
)	O
;	O
if	O
(	O
gs_data_ext_filter_command	pointer
!=	O
NULL	O
)	O
FATAL_ERROR2	O
(	O
_	O
(	O
"specified extension processing without Guile installed: %.*s"	pointer
)	O
,	O
gs_data_ext_filter_command	pointer
->	O
length	long
,	O
gs_data_ext_filter_command	pointer
->	O
string	pointer
)	O
;	O
if	O
(	O
gs_data_ext_match_command	pointer
!=	O
NULL	O
)	O
FATAL_ERROR2	O
(	O
_	O
(	O
"specified extension processing without Guile installed: %.*s"	pointer
)	O
,	O
gs_data_ext_match_command	pointer
->	O
length	long
,	O
gs_data_ext_match_command	pointer
->	O
string	pointer
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
}	O
void	O
expand_delimited_ranges	function
(	O
out_ranges	pointer
,	O
range_count	pointer
)	O
field_range	struct
*	O
*	O
out_ranges	pointer
;	O
int	O
*	O
range_count	pointer
;	O
{	O
int	O
i	int
;	O
field_range	struct
*	O
replace_ranges	pointer
;	O
int	O
replace_count	int
;	O
replace_ranges	pointer
=	O
NULL	O
;	O
replace_count	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
*	O
range_count	pointer
;	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
*	O
out_ranges	pointer
)	O
[	O
i	int
]	O
.	O
upper_bound	long
!=	O
0	int
&&	O
(	O
*	O
out_ranges	pointer
)	O
[	O
i	int
]	O
.	O
upper_bound	long
!=	O
(	O
*	O
out_ranges	pointer
)	O
[	O
i	int
]	O
.	O
lower_bound	long
)	O
{	O
int	O
j	int
;	O
if	O
(	O
replace_ranges	pointer
==	O
NULL	O
)	O
{	O
replace_ranges	pointer
=	O
malloc	function
(	O
(	O
i	int
+	O
(	O
*	O
out_ranges	pointer
)	O
[	O
i	int
]	O
.	O
upper_bound	long
-	O
(	O
*	O
out_ranges	pointer
)	O
[	O
i	int
]	O
.	O
lower_bound	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
field_range	struct
)	O
)	O
;	O
if	O
(	O
replace_ranges	pointer
==	O
NULL	O
)	O
{	O
*	O
out_ranges	pointer
=	O
NULL	O
;	O
*	O
range_count	pointer
=	O
0	int
;	O
return	O
;	O
}	O
if	O
(	O
i	int
>	O
0	int
)	O
memmove	function
(	O
replace_ranges	pointer
,	O
*	O
out_ranges	pointer
,	O
i	int
*	O
sizeof	O
(	O
field_range	struct
)	O
)	O
;	O
replace_count	int
=	O
i	int
;	O
}	O
else	O
{	O
replace_ranges	pointer
=	O
realloc	function
(	O
replace_ranges	pointer
,	O
(	O
replace_count	int
+	O
(	O
*	O
out_ranges	pointer
)	O
[	O
i	int
]	O
.	O
upper_bound	long
-	O
(	O
*	O
out_ranges	pointer
)	O
[	O
i	int
]	O
.	O
lower_bound	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
field_range	struct
)	O
)	O
;	O
if	O
(	O
replace_ranges	pointer
==	O
NULL	O
)	O
{	O
*	O
out_ranges	pointer
=	O
NULL	O
;	O
*	O
range_count	pointer
=	O
0	int
;	O
return	O
;	O
}	O
}	O
for	O
(	O
j	int
=	O
(	O
*	O
out_ranges	pointer
)	O
[	O
i	int
]	O
.	O
lower_bound	long
;	O
j	int
<=	O
(	O
*	O
out_ranges	pointer
)	O
[	O
i	int
]	O
.	O
upper_bound	long
;	O
j	int
++	O
)	O
{	O
replace_count	int
++	O
;	O
replace_ranges	pointer
[	O
replace_count	int
-	O
1	int
]	O
.	O
lower_bound	long
=	O
j	int
;	O
replace_ranges	pointer
[	O
replace_count	int
-	O
1	int
]	O
.	O
upper_bound	long
=	O
j	int
;	O
replace_ranges	pointer
[	O
replace_count	int
-	O
1	int
]	O
.	O
precision	int
=	O
(	O
*	O
out_ranges	pointer
)	O
[	O
i	int
]	O
.	O
precision	int
;	O
replace_ranges	pointer
[	O
replace_count	int
-	O
1	int
]	O
.	O
format	pointer
=	O
(	O
*	O
out_ranges	pointer
)	O
[	O
i	int
]	O
.	O
format	pointer
;	O
}	O
}	O
else	O
if	O
(	O
replace_ranges	pointer
!=	O
NULL	O
)	O
{	O
replace_ranges	pointer
=	O
realloc	function
(	O
replace_ranges	pointer
,	O
(	O
replace_count	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
field_range	struct
)	O
)	O
;	O
if	O
(	O
replace_ranges	pointer
==	O
NULL	O
)	O
{	O
*	O
out_ranges	pointer
=	O
NULL	O
;	O
*	O
range_count	pointer
=	O
0	int
;	O
return	O
;	O
}	O
replace_count	int
++	O
;	O
replace_ranges	pointer
[	O
replace_count	int
-	O
1	int
]	O
.	O
upper_bound	long
=	O
(	O
*	O
out_ranges	pointer
)	O
[	O
i	int
]	O
.	O
upper_bound	long
;	O
replace_ranges	pointer
[	O
replace_count	int
-	O
1	int
]	O
.	O
lower_bound	long
=	O
(	O
*	O
out_ranges	pointer
)	O
[	O
i	int
]	O
.	O
lower_bound	long
;	O
replace_ranges	pointer
[	O
replace_count	int
-	O
1	int
]	O
.	O
precision	int
=	O
(	O
*	O
out_ranges	pointer
)	O
[	O
i	int
]	O
.	O
precision	int
;	O
replace_ranges	pointer
[	O
replace_count	int
-	O
1	int
]	O
.	O
format	pointer
=	O
(	O
*	O
out_ranges	pointer
)	O
[	O
i	int
]	O
.	O
format	pointer
;	O
}	O
}	O
if	O
(	O
replace_ranges	pointer
!=	O
NULL	O
)	O
{	O
*	O
out_ranges	pointer
=	O
replace_ranges	pointer
;	O
*	O
range_count	pointer
=	O
replace_count	int
;	O
}	O
return	O
;	O
}	O
int	O
assert_reference_file	function
(	O
option	struct
)	O
int	O
option	struct
;	O
{	O
if	O
(	O
gi_reference_file_count	int
<=	O
0	int
)	O
FATAL_ERROR1	O
(	O
_	O
(	O
"option %c listed before any reference file was specified"	pointer
)	O
,	O
option	struct
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
}	O
int	O
set_reference_option	function
(	O
option	struct
)	O
int	O
option	struct
;	O
{	O
switch	O
(	O
option	struct
)	O
{	O
case	O
'a'	O
:	O
calculate_ranges	function
(	O
optarg	pointer
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
hrchy_key_ranges	pointer
)	O
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
hrchy_key_end_start	int
)	O
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
hrchy_key_range_count	int
)	O
)	O
;	O
break	O
;	O
case	O
'F'	O
:	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
hrchy_flatten_levels	int
=	O
strtol	function
(	O
optarg	pointer
,	O
NULL	O
,	O
0	int
)	O
;	O
break	O
;	O
case	O
'h'	O
:	O
if	O
(	O
(	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
hash_size	long
=	O
atoi	function
(	O
optarg	pointer
)	O
)	O
<=	O
0	int
)	O
FATAL_ERROR1	O
(	O
_	O
(	O
"hash table size must be a positive number (got %s)"	pointer
)	O
,	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'H'	O
:	O
if	O
(	O
strcasecmp	function
(	O
optarg	pointer
,	O
"beginning"	pointer
)	O
==	O
0	int
)	O
{	O
gi_hashmovement_ind	enum
=	O
hm_beginning	int
;	O
}	O
else	O
if	O
(	O
strcasecmp	function
(	O
optarg	pointer
,	O
"end"	pointer
)	O
==	O
0	int
)	O
{	O
gi_hashmovement_ind	enum
=	O
hm_end	int
;	O
}	O
else	O
if	O
(	O
strcasecmp	function
(	O
optarg	pointer
,	O
"number"	pointer
)	O
==	O
0	int
)	O
{	O
gi_hashmovement_ind	enum
=	O
hm_number	int
;	O
}	O
else	O
if	O
(	O
strcasecmp	function
(	O
optarg	pointer
,	O
"binary"	pointer
)	O
==	O
0	int
)	O
{	O
gi_hashmovement_ind	enum
=	O
hm_binary	int
;	O
}	O
else	O
if	O
(	O
strcasecmp	function
(	O
optarg	pointer
,	O
"binary_long"	pointer
)	O
==	O
0	int
)	O
{	O
gi_hashmovement_ind	enum
=	O
hm_binary_long	int
;	O
}	O
else	O
FATAL_ERROR	O
(	O
_	O
(	O
"hash-movement option must be `beginning' or `end'"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
'k'	O
:	O
calculate_ranges	function
(	O
optarg	pointer
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
key_ranges	pointer
)	O
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
key_end_start	int
)	O
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
key_range_count	int
)	O
)	O
;	O
break	O
;	O
case	O
'l'	O
:	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
hrchy_leaf_only	int
=	O
-	O
1	int
;	O
break	O
;	O
case	O
'm'	O
:	O
calculate_ranges	function
(	O
optarg	pointer
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
data_key_ranges	pointer
)	O
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
data_key_end_start	int
)	O
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
data_key_range_count	int
)	O
)	O
;	O
break	O
;	O
case	O
'p'	O
:	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
optional_ind	int
=	O
-	O
1	int
;	O
break	O
;	O
case	O
'P'	O
:	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
optional_ind	int
=	O
-	O
1	int
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
exclude_match_ind	int
=	O
-	O
1	int
;	O
break	O
;	O
case	O
'u'	O
:	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
unique_ind	int
=	O
-	O
1	int
;	O
break	O
;	O
case	O
'U'	O
:	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
hrchy_direction	int
=	O
-	O
1	int
;	O
break	O
;	O
}	O
}	O
int	O
set_file_option	function
(	O
option	struct
)	O
int	O
option	struct
;	O
{	O
STRINGTYPE	O
temp_dstring	struct
;	O
switch	O
(	O
option	struct
)	O
{	O
case	O
'B'	O
:	O
if	O
(	O
gi_reference_file_count	int
==	O
0	int
)	O
{	O
gs_data_input_record_delimiter	pointer
=	O
dstrdupstr	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
gs_data_input_record_delimiter	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
input_record_delimiter	pointer
=	O
dstrdupstr	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
input_record_delimiter	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
'D'	O
:	O
if	O
(	O
gi_reference_file_count	int
==	O
0	int
)	O
{	O
gs_data_input_field_delimiter	pointer
=	O
dstrdupstr	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
gs_data_input_field_delimiter	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
gi_data_no_input_field_delimiter	int
=	O
0	int
;	O
}	O
else	O
{	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
input_field_delimiter	pointer
=	O
dstrdupstr	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
input_field_delimiter	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
no_input_field_delimiter	int
=	O
0	int
;	O
}	O
break	O
;	O
case	O
OPT_NO_INPUT_DELIMITER	int
:	O
if	O
(	O
gi_reference_file_count	int
==	O
0	int
)	O
{	O
gi_data_no_input_field_delimiter	int
=	O
-	O
1	int
;	O
if	O
(	O
gs_data_input_field_delimiter	pointer
!=	O
NULL	O
)	O
{	O
dstrfree	function
(	O
gs_data_input_field_delimiter	pointer
)	O
;	O
gs_data_input_field_delimiter	pointer
=	O
NULL	O
;	O
}	O
}	O
else	O
{	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
no_input_field_delimiter	int
=	O
-	O
1	int
;	O
if	O
(	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
input_field_delimiter	pointer
!=	O
NULL	O
)	O
{	O
dstrfree	function
(	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
input_field_delimiter	pointer
)	O
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
input_field_delimiter	pointer
=	O
NULL	O
;	O
}	O
}	O
break	O
;	O
case	O
OPT_INPUT_DELIMITER_REPEAT	int
:	O
if	O
(	O
gi_reference_file_count	int
==	O
0	int
)	O
{	O
gi_data_input_field_delimiter_repeat	int
=	O
-	O
1	int
;	O
}	O
else	O
{	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
input_field_delimiter_repeat	int
=	O
-	O
1	int
;	O
}	O
break	O
;	O
case	O
'K'	O
:	O
if	O
(	O
gi_reference_file_count	int
==	O
0	int
)	O
{	O
gs_data_constant_string	pointer
=	O
dstrdupstr	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
gs_data_constant_string	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
constant_string	pointer
=	O
dstrdupstr	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
constant_string	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
'L'	O
:	O
if	O
(	O
gi_reference_file_count	int
==	O
0	int
)	O
{	O
gi_data_input_record_length	int
=	O
atol	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
gi_data_input_record_length	int
<=	O
0	int
)	O
FATAL_ERROR1	O
(	O
_	O
(	O
"record length must be postitive number (got %s)"	pointer
)	O
,	O
optarg	pointer
)	O
;	O
}	O
else	O
{	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
input_record_length	int
=	O
atol	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
input_record_length	int
==	O
0	int
)	O
FATAL_ERROR1	O
(	O
_	O
(	O
"record length must be postitive number (got %s)"	pointer
)	O
,	O
optarg	pointer
)	O
;	O
}	O
break	O
;	O
case	O
'o'	O
:	O
if	O
(	O
gi_reference_file_count	int
==	O
0	int
)	O
{	O
calculate_ranges	function
(	O
optarg	pointer
,	O
&	O
gra_data_out_ranges	pointer
,	O
&	O
gi_data_out_end_start	int
,	O
&	O
gi_data_out_range_count	int
)	O
;	O
}	O
else	O
{	O
calculate_ranges	function
(	O
optarg	pointer
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
out_ranges	pointer
)	O
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
out_end_start	int
)	O
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
out_range_count	int
)	O
)	O
;	O
}	O
break	O
;	O
case	O
'O'	O
:	O
temp_dstring	struct
.	O
string	pointer
=	O
optarg	pointer
;	O
temp_dstring	struct
.	O
length	long
=	O
strlen	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
gi_reference_file_count	int
==	O
0	int
)	O
{	O
gra_data_output_field_order	pointer
=	O
parse_field_order_string	function
(	O
&	O
temp_dstring	struct
,	O
&	O
gi_data_output_field_order_count	int
)	O
;	O
if	O
(	O
gra_data_output_field_order	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to parse data output field order"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
output_field_order	pointer
=	O
parse_field_order_string	function
(	O
&	O
temp_dstring	struct
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
output_field_order_count	int
)	O
)	O
;	O
if	O
(	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
output_field_order	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
"Unable to parse reference output field order"	pointer
)	O
;	O
}	O
break	O
;	O
case	O
'p'	O
:	O
if	O
(	O
gi_reference_file_count	int
==	O
0	int
)	O
gi_data_optional_ind	int
=	O
-	O
1	int
;	O
else	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
optional_ind	int
=	O
-	O
1	int
;	O
break	O
;	O
case	O
'P'	O
:	O
if	O
(	O
gi_reference_file_count	int
==	O
0	int
)	O
gi_data_optional_ind	int
=	O
-	O
1	int
;	O
else	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
optional_ind	int
=	O
-	O
1	int
;	O
if	O
(	O
gi_reference_file_count	int
==	O
0	int
)	O
gi_data_exclude_match_ind	int
=	O
-	O
1	int
;	O
else	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
exclude_match_ind	int
=	O
-	O
1	int
;	O
break	O
;	O
case	O
't'	O
:	O
if	O
(	O
gi_reference_file_count	int
==	O
0	int
)	O
{	O
gs_data_output_file_name	pointer
=	O
strdup	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
gs_data_output_file_name	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
output_file_name	pointer
=	O
strdup	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
output_file_name	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
'w'	O
:	O
if	O
(	O
gi_reference_file_count	int
==	O
0	int
)	O
gi_data_write_ind	int
=	O
1	int
;	O
else	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
write_ind	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
int	O
set_reference_file	function
(	O
filename	pointer
)	O
char	O
*	O
filename	pointer
;	O
{	O
if	O
(	O
++	O
gi_reference_file_count	int
>	O
gi_allocated_reference_info	int
)	O
FATAL_ERROR	O
(	O
"too many reference files."	pointer
)	O
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
file_name	pointer
=	O
strdup	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
file_name	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
input_buffer	pointer
=	O
NULL	O
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
input_buffer_size	long
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
input_buffer_pos	long
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
output_buffer	pointer
=	O
NULL	O
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
output_buffer_size	long
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
output_buffer_pos	long
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
out_ranges	pointer
=	O
NULL	O
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
out_end_start	int
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
out_range_count	int
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
key_ranges	pointer
=	O
NULL	O
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
key_end_start	int
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
key_range_count	int
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
hrchy_key_ranges	pointer
=	O
NULL	O
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
hrchy_key_end_start	int
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
hrchy_key_range_count	int
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
hrchy_flatten_levels	int
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
hrchy_leaf_only	int
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
hrchy_direction	int
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
data_key_ranges	pointer
=	O
NULL	O
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
constant_string	pointer
=	O
NULL	O
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
missing_string	pointer
=	O
NULL	O
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
empty_string	pointer
=	O
NULL	O
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
input_field_delimiter	pointer
=	O
NULL	O
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
no_input_field_delimiter	int
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
input_field_delimiter_repeat	int
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
input_record_delimiter	pointer
=	O
dstrdupstr	function
(	O
"\n"	pointer
)	O
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
input_record_length	int
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
data_key_end_start	int
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
data_key_range_count	int
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
unique_ind	int
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
optional_ind	int
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
exclude_match_ind	int
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
hrchy_path	pointer
=	O
NULL	O
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
hrchy_path_size	long
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
hrchy_curr_depth	long
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
records_read	int
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
records_dropped_filter	int
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
records_stored	int
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
records_matched_key	int
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
records_matched	int
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
data_records_matched	int
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
write_ind	int
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
suppress_empty_ind	int
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
output_file_name	pointer
=	O
NULL	O
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
ext_file_open_command	pointer
=	O
NULL	O
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
ext_record_read_command	pointer
=	O
NULL	O
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
ext_file_close_command	pointer
=	O
NULL	O
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
ext_start_writing_command	pointer
=	O
NULL	O
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
ext_record_write_command	pointer
=	O
NULL	O
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
ext_finished_writing_command	pointer
=	O
NULL	O
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
ext_filter_command	pointer
=	O
NULL	O
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
ext_match_command	pointer
=	O
NULL	O
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
ext_hrchy_match_command	pointer
=	O
NULL	O
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
output_field_order	pointer
=	O
NULL	O
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
output_field_order_count	int
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
hash_size	long
=	O
DEFAULT_HASHTABLE_SIZE	int
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
hash_table	pointer
=	O
0	int
;	O
}	O
set_general_option	function
(	O
option	struct
)	O
int	O
option	struct
;	O
{	O
switch	O
(	O
option	struct
)	O
{	O
case	O
'b'	O
:	O
gs_output_record_delimiter	pointer
=	O
dstrdupstr	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
gs_output_record_delimiter	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
'd'	O
:	O
gs_output_field_delimiter	pointer
=	O
dstrdupstr	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
gs_output_field_delimiter	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
gi_no_output_field_delimiter	int
=	O
0	int
;	O
break	O
;	O
case	O
OPT_NO_OUTPUT_DELIMITER	int
:	O
gi_no_output_field_delimiter	int
=	O
-	O
1	int
;	O
if	O
(	O
gs_output_field_delimiter	pointer
!=	O
NULL	O
)	O
{	O
dstrfree	function
(	O
gs_output_field_delimiter	pointer
)	O
;	O
gs_output_field_delimiter	pointer
=	O
NULL	O
;	O
}	O
break	O
;	O
case	O
'f'	O
:	O
gi_flag_ind	int
=	O
1	int
;	O
break	O
;	O
case	O
'M'	O
:	O
gi_data_is_reference	int
=	O
1	int
;	O
break	O
;	O
case	O
'n'	O
:	O
gi_counter_ind	int
=	O
1	int
;	O
break	O
;	O
case	O
'R'	O
:	O
gi_checkallref_ind	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NO_CHECK_ALL_REFERENCE	int
:	O
gi_checkallref_ind	int
=	O
0	int
;	O
break	O
;	O
case	O
's'	O
:	O
calculate_ranges	function
(	O
optarg	pointer
,	O
&	O
gra_data_sum_ranges	pointer
,	O
&	O
gi_data_sum_end_start	int
,	O
&	O
gi_data_sum_range_count	int
)	O
;	O
break	O
;	O
case	O
'v'	O
:	O
gi_verbose_ind	int
=	O
1	int
;	O
break	O
;	O
case	O
'x'	O
:	O
switch	O
(	O
optarg	pointer
[	O
0	int
]	O
)	O
{	O
case	O
'b'	O
:	O
gs_ext_begin_command	pointer
=	O
dstrdupstr	function
(	O
&	O
(	O
optarg	pointer
[	O
1	int
]	O
)	O
)	O
;	O
if	O
(	O
gs_ext_begin_command	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
'e'	O
:	O
gs_ext_end_command	pointer
=	O
dstrdupstr	function
(	O
&	O
(	O
optarg	pointer
[	O
1	int
]	O
)	O
)	O
;	O
if	O
(	O
gs_ext_end_command	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
'o'	O
:	O
if	O
(	O
gi_reference_file_count	int
==	O
0	int
)	O
{	O
gs_data_ext_file_open_command	pointer
=	O
dstrdupstr	function
(	O
&	O
(	O
optarg	pointer
[	O
1	int
]	O
)	O
)	O
;	O
if	O
(	O
gs_data_ext_file_open_command	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
ext_file_open_command	pointer
=	O
dstrdupstr	function
(	O
&	O
(	O
optarg	pointer
[	O
1	int
]	O
)	O
)	O
;	O
if	O
(	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
ext_file_open_command	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
'r'	O
:	O
if	O
(	O
gi_reference_file_count	int
==	O
0	int
)	O
{	O
gs_data_ext_record_read_command	pointer
=	O
dstrdupstr	function
(	O
&	O
(	O
optarg	pointer
[	O
1	int
]	O
)	O
)	O
;	O
if	O
(	O
gs_data_ext_record_read_command	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
ext_record_read_command	pointer
=	O
dstrdupstr	function
(	O
&	O
(	O
optarg	pointer
[	O
1	int
]	O
)	O
)	O
;	O
if	O
(	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
ext_record_read_command	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
'c'	O
:	O
if	O
(	O
gi_reference_file_count	int
==	O
0	int
)	O
{	O
gs_data_ext_file_close_command	pointer
=	O
dstrdupstr	function
(	O
&	O
(	O
optarg	pointer
[	O
1	int
]	O
)	O
)	O
;	O
if	O
(	O
gs_data_ext_file_close_command	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
ext_file_close_command	pointer
=	O
dstrdupstr	function
(	O
&	O
(	O
optarg	pointer
[	O
1	int
]	O
)	O
)	O
;	O
if	O
(	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
ext_file_close_command	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
's'	O
:	O
if	O
(	O
gi_reference_file_count	int
==	O
0	int
)	O
{	O
gs_data_ext_start_writing_command	pointer
=	O
dstrdupstr	function
(	O
&	O
(	O
optarg	pointer
[	O
1	int
]	O
)	O
)	O
;	O
if	O
(	O
gs_data_ext_start_writing_command	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
ext_start_writing_command	pointer
=	O
dstrdupstr	function
(	O
&	O
(	O
optarg	pointer
[	O
1	int
]	O
)	O
)	O
;	O
if	O
(	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
ext_start_writing_command	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
'w'	O
:	O
if	O
(	O
gi_reference_file_count	int
==	O
0	int
)	O
{	O
gs_data_ext_record_write_command	pointer
=	O
dstrdupstr	function
(	O
&	O
(	O
optarg	pointer
[	O
1	int
]	O
)	O
)	O
;	O
if	O
(	O
gs_data_ext_record_write_command	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
ext_record_write_command	pointer
=	O
dstrdupstr	function
(	O
&	O
(	O
optarg	pointer
[	O
1	int
]	O
)	O
)	O
;	O
if	O
(	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
ext_record_write_command	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
'f'	O
:	O
if	O
(	O
gi_reference_file_count	int
==	O
0	int
)	O
{	O
gs_data_ext_finished_writing_command	pointer
=	O
dstrdupstr	function
(	O
&	O
(	O
optarg	pointer
[	O
1	int
]	O
)	O
)	O
;	O
if	O
(	O
gs_data_ext_finished_writing_command	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
ext_finished_writing_command	pointer
=	O
dstrdupstr	function
(	O
&	O
(	O
optarg	pointer
[	O
1	int
]	O
)	O
)	O
;	O
if	O
(	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
ext_finished_writing_command	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
'l'	O
:	O
if	O
(	O
gi_reference_file_count	int
==	O
0	int
)	O
{	O
gs_data_ext_filter_command	pointer
=	O
dstrdupstr	function
(	O
&	O
(	O
optarg	pointer
[	O
1	int
]	O
)	O
)	O
;	O
if	O
(	O
gs_data_ext_filter_command	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
ext_filter_command	pointer
=	O
dstrdupstr	function
(	O
&	O
(	O
optarg	pointer
[	O
1	int
]	O
)	O
)	O
;	O
if	O
(	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
ext_filter_command	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
'm'	O
:	O
assert_reference_file	function
(	O
'm'	O
)	O
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
ext_match_command	pointer
=	O
dstrdupstr	function
(	O
&	O
(	O
optarg	pointer
[	O
1	int
]	O
)	O
)	O
;	O
if	O
(	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
ext_match_command	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
'h'	O
:	O
assert_reference_file	function
(	O
'h'	O
)	O
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
ext_hrchy_match_command	pointer
=	O
dstrdupstr	function
(	O
&	O
(	O
optarg	pointer
[	O
1	int
]	O
)	O
)	O
;	O
if	O
(	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
ext_hrchy_match_command	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
'X'	O
:	O
gs_ext_init_file	pointer
=	O
dstrdupstr	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
gs_ext_init_file	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
'z'	O
:	O
gi_output_counter_size	int
=	O
strtol	function
(	O
optarg	pointer
,	O
NULL	O
,	O
10	int
)	O
;	O
if	O
(	O
gi_output_counter_size	int
<=	O
0	int
)	O
FATAL_ERROR1	O
(	O
_	O
(	O
"counter size must be a positive number (got '%s')"	pointer
)	O
,	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPT_STATISTICS	int
:	O
gi_statistics_ind	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NO_STATISTICS	int
:	O
gi_statistics_ind	int
=	O
0	int
;	O
break	O
;	O
}	O
}	O
int	O
usage	function
(	O
status	int
)	O
int	O
status	int
;	O
{	O
fprintf	function
(	O
stdout	pointer
,	O
_	O
(	O
"combine -- flexible file joins (and more)\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
stdout	pointer
,	O
_	O
(	O
"\n"	pointer
"Reads a data file, checks for matches in any specified reference files, and \n"	pointer
"writes specified output.\n"	pointer
"\n"	pointer
"The following are the main options.  General options and options referring to \n"	pointer
"the data file should come before any reference file is specified.  Options \n"	pointer
"appearing after a reference file is specified are applied to the latest reference \n"	pointer
"file named.  \n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
stdout	pointer
,	O
_	O
(	O
"\n"	pointer
"General Options\n"	pointer
"\n"	pointer
"  -b, --output-record-delimiter=STRING  put STRING between all output records \n"	pointer
"  -d, --output-field-delimiter=STRING   put STRING between all output fields \n"	pointer
"  -f, --flag                            make 1/0 flags indicating matches\n"	pointer
"  -H, --hash-movement=OPTION            `beginning' or `end' for best variation\n"	pointer
"  -n, --count                           make counts of the matching data records\n"	pointer
"  -R, --check-all-reference             keep checking after a non-optional non-match\n"	pointer
"      --no-check-all-reference          stop checking after a non-optional non-match\n"	pointer
"  -x, --extension=COMMAND               run a guile COMMAND as specified\n"	pointer
"  -X, --extension-init-file=FILENAME    load FILENAME as initialization for guile\n"	pointer
"  -z, --counter-size=NUMBER             make all counters and sums NUMBER bytes long\n"	pointer
"      --statistics                      write record counts to stderr\n"	pointer
"      --no-statistics                   do not write record counts to stderr\n"	pointer
"      --verbose                         write detailed information to stderr\n"	pointer
)	O
)	O
;	O
fputs	function
(	O
HELP_OPTION_DESCRIPTION	O
,	O
stdout	pointer
)	O
;	O
fputs	function
(	O
VERSION_OPTION_DESCRIPTION	O
,	O
stdout	pointer
)	O
;	O
fprintf	function
(	O
stdout	pointer
,	O
_	O
(	O
"\n"	pointer
"Options for Any File\n"	pointer
"\n"	pointer
"  -B, --input-record-delimiter=STRING  use STRING to separate input records\n"	pointer
"  -L, --input-record-length=NUMBER     separate records at NUMBER byte intervals\n"	pointer
"  -D, --input-field-delimiter=STRING   use STRING to separate fields\n"	pointer
"  -K, --output-constant=STRING         write STRING in output record\n"	pointer
"  -o, --output-fields=FIELD-LIST       write FIELD-LIST in output records\n"	pointer
"  -O, --field-order=FIELD-ORDER-LIST   write output in order of FIELD-ORDER-LIST\n"	pointer
"  -t, --output-file=FILENAME           write output to FILENAME (default stdout)\n"	pointer
"  -w, --write-output                   write output based on this file\n"	pointer
""	pointer
)	O
)	O
;	O
fprintf	function
(	O
stdout	pointer
,	O
_	O
(	O
"\n"	pointer
"Data File Options\n"	pointer
"\n"	pointer
"  -s, --sum-fields=FIELD-LIST  sum the values of FIELD-LIST from data records\n"	pointer
""	pointer
)	O
)	O
;	O
fprintf	function
(	O
stdout	pointer
,	O
_	O
(	O
"\n"	pointer
"Reference File Options\n"	pointer
"\n"	pointer
"  -r, --reference-file=FILENAME     FILENAME is the (next) reference file\n"	pointer
"  -k, --key-fields=FIELD-LIST       match FIELD-LIST to the data file\n"	pointer
"  -m, --data-key-fields=FIELD-LIST  match FIELD-LIST in the data file to reference\n"	pointer
"  -p, --match-optional              do not require a match to this file\n"	pointer
"  -u, --unique                      store only one copy of each distinct set of keys\n"	pointer
"  -h, --hash-size=NUMBER            initial hash table size (in records)\n"	pointer
""	pointer
)	O
)	O
;	O
fprintf	function
(	O
stdout	pointer
,	O
_	O
(	O
"\n"	pointer
"FIELD-LIST is a comma-separated list of ranges of bytes or fields (if delimited)\n"	pointer
"FIELD-ORDER-LIST is a comma-separated list of entries like SOURCE[NUM].TYPE[NUM]\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
stdout	pointer
,	O
_	O
(	O
"\n"	pointer
"For complete documentation, see the info manual at `info combine'.\n"	pointer
"\n"	pointer
"Please report bugs to <dpv@world.std.com>\n"	pointer
)	O
)	O
;	O
exit	function
(	O
status	int
)	O
;	O
}	O
int	O
handle_cut_arguments	function
(	O
argc	int
,	O
argv	pointer
)	O
int	O
argc	int
;	O
char	O
*	O
*	O
argv	pointer
;	O
{	O
int	O
c	int
;	O
int	O
i	int
;	O
char	O
const	O
*	O
short_options	pointer
=	O
CUT_COMMON_SHORT_OPTIONS	pointer
;	O
version_etc_copyright	pointer
=	O
"Copyright (C) 2002, 2003, 2004, 2013 Daniel P. Valentine"	pointer
;	O
gi_data_write_ind	int
=	O
1	int
;	O
c	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
short_options	pointer
,	O
cut_long_options	array
,	O
NULL	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
c	int
==	O
-	O
1	int
)	O
{	O
filecount	int
=	O
argc	int
-	O
optind	int
;	O
filenames	pointer
=	O
argv	pointer
+	O
optind	int
;	O
break	O
;	O
}	O
else	O
switch	O
(	O
c	int
)	O
{	O
case	O
'b'	O
:	O
case	O
'c'	O
:	O
calculate_ranges	function
(	O
optarg	pointer
,	O
&	O
gra_data_out_ranges	pointer
,	O
&	O
gi_data_out_end_start	int
,	O
&	O
gi_data_out_range_count	int
)	O
;	O
if	O
(	O
gs_data_input_field_delimiter	pointer
!=	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"bad combination of bytes and fields in cut emulation"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
'd'	O
:	O
if	O
(	O
strlen	function
(	O
optarg	pointer
)	O
==	O
0	int
)	O
gs_data_input_field_delimiter	pointer
=	O
dstrdupstr	function
(	O
"X"	pointer
)	O
;	O
else	O
gs_data_input_field_delimiter	pointer
=	O
dstrdupstr	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
gs_data_input_field_delimiter	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
if	O
(	O
strlen	function
(	O
optarg	pointer
)	O
==	O
0	int
)	O
gs_data_input_field_delimiter	pointer
->	O
string	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
gs_output_field_delimiter	pointer
==	O
NULL	O
)	O
gs_output_field_delimiter	pointer
=	O
gs_data_input_field_delimiter	pointer
;	O
break	O
;	O
case	O
'f'	O
:	O
calculate_ranges	function
(	O
optarg	pointer
,	O
&	O
gra_data_out_ranges	pointer
,	O
&	O
gi_data_out_end_start	int
,	O
&	O
gi_data_out_range_count	int
)	O
;	O
if	O
(	O
gs_data_input_field_delimiter	pointer
==	O
NULL	O
)	O
{	O
gs_data_input_field_delimiter	pointer
=	O
dstrdupstr	function
(	O
"	"	pointer
)	O
;	O
if	O
(	O
gs_data_input_field_delimiter	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
's'	O
:	O
break	O
;	O
case	O
CUT_OPT_OUTPUT_DELIMITER	int
:	O
if	O
(	O
strlen	function
(	O
optarg	pointer
)	O
==	O
0	int
)	O
gs_output_field_delimiter	pointer
=	O
dstrdupstr	function
(	O
"X"	pointer
)	O
;	O
else	O
gs_output_field_delimiter	pointer
=	O
dstrdupstr	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
gs_output_field_delimiter	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
if	O
(	O
strlen	function
(	O
optarg	pointer
)	O
==	O
0	int
)	O
gs_output_field_delimiter	pointer
->	O
string	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
break	O
;	O
case_GETOPT_HELP_CHAR	O
;	O
case_GETOPT_VERSION_CHAR	O
(	O
PROGRAM_NAME	pointer
,	O
AUTHORS	pointer
)	O
;	O
default	O
:	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
c	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
short_options	pointer
,	O
cut_long_options	array
,	O
NULL	O
)	O
;	O
}	O
if	O
(	O
gi_data_out_end_start	int
+	O
gi_data_out_range_count	int
==	O
0	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"exactly one of -b, -c, or -f needed in cut emulation"	pointer
)	O
)	O
;	O
}	O
int	O
handle_join_arguments	function
(	O
argc	int
,	O
argv	pointer
)	O
int	O
argc	int
;	O
char	O
*	O
*	O
argv	pointer
;	O
{	O
int	O
c	int
;	O
int	O
i	int
;	O
size_t	long
max_ref_field	long
;	O
size_t	long
max_data_field	long
;	O
size_t	long
end_ref_field	long
;	O
size_t	long
end_data_field	long
;	O
char	O
temp_string	array
[	O
100	int
]	O
;	O
char	O
const	O
*	O
short_options	pointer
=	O
JOIN_COMMON_SHORT_OPTIONS	pointer
;	O
STRINGTYPE	O
temp_dstring	struct
;	O
version_etc_copyright	pointer
=	O
"Copyright (C) 2002, 2003, 2004, 2013 Daniel P. Valentine"	pointer
;	O
set_reference_file	function
(	O
"temp_reference_file"	pointer
)	O
;	O
gi_data_write_ind	int
=	O
1	int
;	O
gs_data_input_field_delimiter	pointer
=	O
dstrdupstr	function
(	O
" "	pointer
)	O
;	O
gi_data_no_input_field_delimiter	int
=	O
0	int
;	O
if	O
(	O
gs_data_input_field_delimiter	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
input_field_delimiter	pointer
=	O
dstrdupstr	function
(	O
" "	pointer
)	O
;	O
if	O
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
input_field_delimiter	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
gs_output_field_delimiter	pointer
=	O
dstrdupstr	function
(	O
" "	pointer
)	O
;	O
gi_data_input_field_delimiter_repeat	int
=	O
-	O
1	int
;	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
input_field_delimiter_repeat	int
=	O
-	O
1	int
;	O
gi_data_optional_ind	int
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
optional_ind	int
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
unique_ind	int
=	O
-	O
1	int
;	O
gs_data_empty_string	pointer
=	O
dstrdupstr	function
(	O
""	pointer
)	O
;	O
if	O
(	O
gs_data_empty_string	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
empty_string	pointer
=	O
gs_data_empty_string	pointer
;	O
gs_data_missing_string	pointer
=	O
dstrdupstr	function
(	O
""	pointer
)	O
;	O
if	O
(	O
gs_data_missing_string	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
missing_string	pointer
=	O
gs_data_missing_string	pointer
;	O
gi_data_suppress_empty_ind	int
=	O
-	O
1	int
;	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
suppress_empty_ind	int
=	O
-	O
1	int
;	O
if	O
(	O
gs_output_field_delimiter	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
c	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
short_options	pointer
,	O
join_long_options	array
,	O
NULL	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
c	int
==	O
-	O
1	int
)	O
{	O
filecount	int
=	O
argc	int
-	O
optind	int
;	O
filenames	pointer
=	O
argv	pointer
+	O
optind	int
;	O
if	O
(	O
filecount	int
!=	O
2	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"join emulation requires exactly 2 input files."	pointer
)	O
)	O
;	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
file_name	pointer
=	O
strdup	function
(	O
filenames	pointer
[	O
0	int
]	O
)	O
;	O
if	O
(	O
gra_reference_file_info	pointer
[	O
gi_reference_file_count	int
-	O
1	int
]	O
.	O
file_name	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
filecount	int
--	O
;	O
filenames	pointer
++	O
;	O
break	O
;	O
}	O
else	O
switch	O
(	O
c	int
)	O
{	O
case	O
'1'	O
:	O
calculate_ranges	function
(	O
optarg	pointer
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
key_ranges	pointer
)	O
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
key_end_start	int
)	O
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
key_range_count	int
)	O
)	O
;	O
break	O
;	O
case	O
'2'	O
:	O
calculate_ranges	function
(	O
optarg	pointer
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
data_key_ranges	pointer
)	O
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
data_key_end_start	int
)	O
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
data_key_range_count	int
)	O
)	O
;	O
break	O
;	O
case	O
'a'	O
:	O
if	O
(	O
strcmp	function
(	O
"1"	pointer
,	O
optarg	pointer
)	O
==	O
0	int
)	O
gi_data_optional_ind	int
=	O
-	O
1	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
"2"	pointer
,	O
optarg	pointer
)	O
==	O
0	int
)	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
optional_ind	int
=	O
-	O
1	int
;	O
else	O
FATAL_ERROR1	O
(	O
_	O
(	O
"file number for join -a must be 1 or 2.  Got %s"	pointer
)	O
,	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'e'	O
:	O
gs_data_empty_string	pointer
=	O
dstrdupstr	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
gs_data_empty_string	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
empty_string	pointer
=	O
gs_data_empty_string	pointer
;	O
gs_data_missing_string	pointer
=	O
gs_data_empty_string	pointer
;	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
missing_string	pointer
=	O
gs_data_empty_string	pointer
;	O
gi_data_input_field_delimiter_repeat	int
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
input_field_delimiter_repeat	int
=	O
0	int
;	O
break	O
;	O
case	O
'i'	O
:	O
break	O
;	O
case	O
'j'	O
:	O
calculate_ranges	function
(	O
optarg	pointer
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
key_ranges	pointer
)	O
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
key_end_start	int
)	O
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
key_range_count	int
)	O
)	O
;	O
calculate_ranges	function
(	O
optarg	pointer
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
data_key_ranges	pointer
)	O
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
data_key_end_start	int
)	O
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
data_key_range_count	int
)	O
)	O
;	O
break	O
;	O
case	O
'o'	O
:	O
temp_dstring	struct
.	O
string	pointer
=	O
optarg	pointer
;	O
temp_dstring	struct
.	O
length	long
=	O
strlen	function
(	O
optarg	pointer
)	O
;	O
gra_data_output_field_order	pointer
=	O
parse_join_order_string	function
(	O
&	O
temp_dstring	struct
,	O
&	O
gi_data_output_field_order_count	int
)	O
;	O
if	O
(	O
gra_data_output_field_order	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to parse data output field order"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
't'	O
:	O
gs_data_input_field_delimiter	pointer
=	O
dstrdupstr	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
gs_data_input_field_delimiter	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
input_field_delimiter	pointer
=	O
dstrdupstr	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
input_field_delimiter	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
gs_output_field_delimiter	pointer
=	O
dstrdupstr	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
gs_output_field_delimiter	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
gi_data_input_field_delimiter_repeat	int
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
input_field_delimiter_repeat	int
=	O
0	int
;	O
break	O
;	O
case	O
'v'	O
:	O
if	O
(	O
strcmp	function
(	O
"1"	pointer
,	O
optarg	pointer
)	O
==	O
0	int
)	O
{	O
gi_data_optional_ind	int
=	O
-	O
1	int
;	O
gi_data_exclude_match_ind	int
=	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
"2"	pointer
,	O
optarg	pointer
)	O
==	O
0	int
)	O
{	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
optional_ind	int
=	O
-	O
1	int
;	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
exclude_match_ind	int
=	O
-	O
1	int
;	O
}	O
else	O
FATAL_ERROR1	O
(	O
_	O
(	O
"file number for join -v must be 1 or 2.  Got %s"	pointer
)	O
,	O
optarg	pointer
)	O
;	O
break	O
;	O
case_GETOPT_HELP_CHAR	O
;	O
case_GETOPT_VERSION_CHAR	O
(	O
PROGRAM_NAME	pointer
,	O
AUTHORS	pointer
)	O
;	O
default	O
:	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
c	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
short_options	pointer
,	O
join_long_options	array
,	O
NULL	O
)	O
;	O
}	O
if	O
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
key_range_count	int
==	O
0	int
&&	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
key_end_start	int
==	O
0	int
)	O
{	O
calculate_ranges	function
(	O
"1"	pointer
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
key_ranges	pointer
)	O
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
key_end_start	int
)	O
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
key_range_count	int
)	O
)	O
;	O
}	O
if	O
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
data_key_range_count	int
==	O
0	int
&&	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
data_key_end_start	int
==	O
0	int
)	O
{	O
calculate_ranges	function
(	O
"1"	pointer
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
data_key_ranges	pointer
)	O
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
data_key_end_start	int
)	O
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
data_key_range_count	int
)	O
)	O
;	O
}	O
if	O
(	O
gra_data_output_field_order	pointer
==	O
NULL	O
)	O
{	O
temp_dstring	struct
.	O
string	pointer
=	O
"r1.o1,s0.o1,r1.o2-,d.o2-"	pointer
;	O
temp_dstring	struct
.	O
length	long
=	O
strlen	function
(	O
temp_dstring	struct
.	O
string	pointer
)	O
;	O
gra_data_output_field_order	pointer
=	O
parse_field_order_string	function
(	O
&	O
temp_dstring	struct
,	O
&	O
gi_data_output_field_order_count	int
)	O
;	O
if	O
(	O
gra_data_output_field_order	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to parse data output field order"	pointer
)	O
)	O
;	O
}	O
max_data_field	long
=	O
0	int
;	O
max_ref_field	long
=	O
0	int
;	O
end_data_field	long
=	O
0	int
;	O
end_ref_field	long
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
gi_data_output_field_order_count	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
source	char
==	O
'd'	O
&&	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type	char
==	O
'o'	O
&&	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type_num	int
>	O
0	int
&&	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type_num	int
>	O
max_data_field	long
)	O
max_data_field	long
=	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type_num	int
;	O
if	O
(	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
source	char
==	O
'r'	O
&&	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type	char
==	O
'o'	O
&&	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type_num	int
>	O
0	int
&&	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type_num	int
>	O
max_ref_field	long
)	O
max_ref_field	long
=	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type_num	int
;	O
if	O
(	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
source	char
==	O
'd'	O
&&	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type	char
==	O
'o'	O
&&	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type_num	int
<	O
0	int
)	O
end_data_field	long
=	O
-	O
1	int
*	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type_num	int
;	O
if	O
(	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
source	char
==	O
'r'	O
&&	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type	char
==	O
'o'	O
&&	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type_num	int
<	O
0	int
)	O
end_ref_field	long
=	O
-	O
1	int
*	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type_num	int
;	O
if	O
(	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
source	char
==	O
's'	O
&&	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
source_num	int
==	O
0	int
&&	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type	char
==	O
'o'	O
&&	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type_num	int
>	O
0	int
&&	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type_num	int
>	O
max_data_field	long
)	O
max_data_field	long
=	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type_num	int
;	O
if	O
(	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
source	char
==	O
's'	O
&&	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
source_num	int
==	O
1	int
&&	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type	char
==	O
'o'	O
&&	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type_num	int
>	O
0	int
&&	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type_num	int
>	O
max_ref_field	long
)	O
max_ref_field	long
=	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type_num	int
;	O
}	O
if	O
(	O
max_data_field	long
>	O
0	int
&&	O
end_data_field	long
>	O
0	int
)	O
{	O
sprintf	function
(	O
temp_string	array
,	O
"1-%ld,%ld-"	pointer
,	O
max_data_field	long
,	O
end_data_field	long
)	O
;	O
calculate_ranges	function
(	O
temp_string	array
,	O
&	O
(	O
gra_data_out_ranges	pointer
)	O
,	O
&	O
(	O
gi_data_out_end_start	int
)	O
,	O
&	O
(	O
gi_data_out_range_count	int
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
gi_data_output_field_order_count	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
source	char
==	O
'd'	O
&&	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type	char
==	O
'o'	O
&&	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type_num	int
<	O
0	int
)	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type_num	int
=	O
(	O
gi_data_out_range_count	int
+	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
max_data_field	long
>	O
0	int
)	O
{	O
sprintf	function
(	O
temp_string	array
,	O
"1-%ld"	pointer
,	O
max_data_field	long
)	O
;	O
calculate_ranges	function
(	O
temp_string	array
,	O
&	O
(	O
gra_data_out_ranges	pointer
)	O
,	O
&	O
(	O
gi_data_out_end_start	int
)	O
,	O
&	O
(	O
gi_data_out_range_count	int
)	O
)	O
;	O
}	O
else	O
{	O
gi_data_out_range_count	int
=	O
0	int
;	O
gi_data_out_end_start	int
=	O
0	int
;	O
}	O
if	O
(	O
max_ref_field	long
>	O
0	int
&&	O
end_ref_field	long
>	O
0	int
)	O
{	O
sprintf	function
(	O
temp_string	array
,	O
"1-%ld,%ld-"	pointer
,	O
max_ref_field	long
,	O
end_ref_field	long
)	O
;	O
calculate_ranges	function
(	O
temp_string	array
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
out_ranges	pointer
)	O
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
out_end_start	int
)	O
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
out_range_count	int
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
gi_data_output_field_order_count	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
source	char
==	O
'r'	O
&&	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type	char
==	O
'o'	O
&&	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type_num	int
<	O
0	int
)	O
gra_data_output_field_order	pointer
[	O
i	int
]	O
.	O
type_num	int
=	O
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
out_range_count	int
+	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
max_ref_field	long
>	O
0	int
)	O
{	O
sprintf	function
(	O
temp_string	array
,	O
"1-%ld"	pointer
,	O
max_ref_field	long
)	O
;	O
calculate_ranges	function
(	O
temp_string	array
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
out_ranges	pointer
)	O
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
out_end_start	int
)	O
,	O
&	O
(	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
out_range_count	int
)	O
)	O
;	O
}	O
else	O
{	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
out_end_start	int
=	O
0	int
;	O
gra_reference_file_info	pointer
[	O
0	int
]	O
.	O
out_range_count	int
=	O
0	int
;	O
}	O
}	O
int	O
handle_arguments	function
(	O
argc	int
,	O
argv	pointer
)	O
int	O
argc	int
;	O
char	O
*	O
*	O
argv	pointer
;	O
{	O
int	O
c	int
;	O
char	O
const	O
*	O
short_options	pointer
=	O
COMMON_SHORT_OPTIONS	pointer
;	O
version_etc_copyright	pointer
=	O
"Copyright (C) 2002, 2003, 2004, 2013 Daniel P. Valentine"	pointer
;	O
c	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
short_options	pointer
,	O
long_options	array
,	O
NULL	O
)	O
;	O
if	O
(	O
c	int
==	O
'e'	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"join"	pointer
)	O
==	O
0	int
)	O
handle_join_arguments	function
(	O
argc	int
,	O
argv	pointer
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"cut"	pointer
)	O
==	O
0	int
)	O
handle_cut_arguments	function
(	O
argc	int
,	O
argv	pointer
)	O
;	O
else	O
FATAL_ERROR1	O
(	O
"unknown emulation requested: %s"	pointer
,	O
optarg	pointer
)	O
;	O
}	O
else	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
c	int
==	O
-	O
1	int
)	O
{	O
filecount	int
=	O
argc	int
-	O
optind	int
;	O
filenames	pointer
=	O
argv	pointer
+	O
optind	int
;	O
break	O
;	O
}	O
else	O
switch	O
(	O
c	int
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
'a'	O
:	O
case	O
'F'	O
:	O
case	O
'h'	O
:	O
case	O
'H'	O
:	O
case	O
'k'	O
:	O
case	O
'l'	O
:	O
case	O
'm'	O
:	O
case	O
'u'	O
:	O
case	O
'U'	O
:	O
assert_reference_file	function
(	O
c	int
)	O
;	O
set_reference_option	function
(	O
c	int
)	O
;	O
break	O
;	O
case	O
'B'	O
:	O
case	O
'D'	O
:	O
case	O
OPT_INPUT_DELIMITER_REPEAT	int
:	O
case	O
'K'	O
:	O
case	O
'L'	O
:	O
case	O
'o'	O
:	O
case	O
'O'	O
:	O
case	O
'p'	O
:	O
case	O
'P'	O
:	O
case	O
't'	O
:	O
case	O
'w'	O
:	O
set_file_option	function
(	O
c	int
)	O
;	O
break	O
;	O
case	O
'r'	O
:	O
set_reference_file	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'b'	O
:	O
case	O
'd'	O
:	O
case	O
'f'	O
:	O
case	O
'M'	O
:	O
case	O
'n'	O
:	O
case	O
'R'	O
:	O
case	O
OPT_NO_CHECK_ALL_REFERENCE	int
:	O
case	O
's'	O
:	O
case	O
'v'	O
:	O
case	O
'x'	O
:	O
case	O
'X'	O
:	O
case	O
'z'	O
:	O
case	O
OPT_STATISTICS	int
:	O
case	O
OPT_NO_STATISTICS	int
:	O
set_general_option	function
(	O
c	int
)	O
;	O
break	O
;	O
case_GETOPT_HELP_CHAR	O
;	O
case_GETOPT_VERSION_CHAR	O
(	O
PROGRAM_NAME	pointer
,	O
AUTHORS	pointer
)	O
;	O
default	O
:	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
c	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
short_options	pointer
,	O
long_options	array
,	O
NULL	O
)	O
;	O
}	O
}	O
