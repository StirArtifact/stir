ESint32	long
EDMAPROC	O
edma_get_class_name	function
(	O
CLASSID	long
class_id	long
,	O
EPChar	pointer
class_name	pointer
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
class_id	long
,	O
"edma_get_class_name"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
class_name	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
strncpy	function
(	O
class_name	pointer
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array
,	O
EDMA_CLASS_NAME_LEN	int
)	O
;	O
return	O
0	int
;	O
}	O
SOID	long
EDMAPROC	O
edma_get_class_so_id	function
(	O
CLASSID	long
class_id	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
class_id	long
,	O
"edma_get_class_so_id"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
return	O
gClass	O
[	O
class_id	long
]	O
->	O
SOId	long
;	O
}	O
MAQID	long
EDMAPROC	O
edma_get_class_arch_id	function
(	O
CLASSID	long
class_id	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
class_id	long
,	O
"edma_get_class_arch_id"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
return	O
gClass	O
[	O
class_id	long
]	O
->	O
MaqId	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_class_module	function
(	O
CLASSID	long
class_id	long
,	O
EPChar	pointer
module_name	pointer
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
class_id	long
,	O
"edma_get_class_module"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
module_name	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
strncpy	function
(	O
module_name	pointer
,	O
gClass	O
[	O
class_id	long
]	O
->	O
SysClass	struct
.	O
ModuleName	array
,	O
EDMA_CLASS_MODULE_LEN	int
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_class_namespace	function
(	O
CLASSID	long
class_id	long
,	O
EPChar	pointer
name_space	pointer
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
class_id	long
,	O
"edma_get_class_namespace"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
name_space	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
strncpy	function
(	O
name_space	pointer
,	O
gClass	O
[	O
class_id	long
]	O
->	O
NameSpace	array
,	O
EDMA_CLASS_NAMESPACE_LEN	int
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_class_major_version	function
(	O
CLASSID	long
class_id	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
class_id	long
,	O
"edma_get_class_major_version"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
return	O
gClass	O
[	O
class_id	long
]	O
->	O
MajorVer	char
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_class_minor_version	function
(	O
CLASSID	long
class_id	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
class_id	long
,	O
"edma_get_class_minor_version"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
return	O
gClass	O
[	O
class_id	long
]	O
->	O
MinorVer	char
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_class_current_version	function
(	O
CLASSID	long
class_id	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
class_id	long
,	O
"edma_get_class_current_version"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
!	O
pClass	pointer
[	O
class_id	long
]	O
)	O
return	O
-	O
1	int
;	O
return	O
pClass	pointer
[	O
class_id	long
]	O
->	O
actual_version	long
;	O
}	O
EPChar	pointer
EDMAPROC	O
edma_get_class_repo_dir	function
(	O
CLASSID	long
cid	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
cid	long
,	O
"edma_get_class_repo_dir"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
NULL	O
;	O
return	O
edma_repo_manager_get_repo_dir	function
(	O
gClass	O
[	O
cid	long
]	O
->	O
repo_id	long
)	O
;	O
}	O
EPChar	pointer
EDMAPROC	O
edma_get_class_repo_name	function
(	O
CLASSID	long
cid	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
cid	long
,	O
"edma_get_class_repo_name"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
NULL	O
;	O
return	O
edma_repo_manager_get_repo_name	function
(	O
gClass	O
[	O
cid	long
]	O
->	O
repo_id	long
)	O
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_class_repo_type	function
(	O
CLASSID	long
cid	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
cid	long
,	O
"edma_get_class_repo_type"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
return	O
SClass	pointer
[	O
cid	long
]	O
->	O
repo_type	char
;	O
}	O
EUint32	long
EDMAPROC	O
edma_get_num_reg_classes	function
(	O
void	O
)	O
{	O
return	O
GVar	pointer
->	O
nClases	long
+	O
nLocalClasses	long
;	O
}	O
CLASSID	long
EDMAPROC	O
edma_get_real_id	function
(	O
EPChar	pointer
class_name	pointer
,	O
CLASSID	long
begin	long
)	O
{	O
EUint32	long
i	long
;	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
begin	long
,	O
"edma_get_real_id"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
class_name	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
for	O
(	O
i	long
=	O
begin	long
;	O
i	long
<	O
GVar	pointer
->	O
nClases	long
;	O
i	long
++	O
)	O
if	O
(	O
gClass	O
[	O
i	long
]	O
!=	O
0	int
)	O
if	O
(	O
ProcMapTable	pointer
[	O
i	long
]	O
!=	O
CLASS_FREE	int
)	O
if	O
(	O
(	O
strncmp	function
(	O
gClass	O
[	O
i	long
]	O
->	O
ClassName	array
,	O
class_name	pointer
,	O
EDMA_CLASS_NAME_LEN	int
)	O
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
i	long
==	O
GVar	pointer
->	O
nClases	long
)	O
return	O
-	O
1	int
;	O
else	O
return	O
i	long
;	O
}	O
CLASSID	long
EDMAPROC	O
edma_get_class_id_with_version	function
(	O
EPChar	pointer
class_name	pointer
,	O
ESint32	long
major_ver	long
,	O
ESint32	long
minor_ver	long
)	O
{	O
ESint32	long
i	long
,	O
j	long
;	O
EUint32	long
r	long
;	O
OBJID	long
idEMI	long
;	O
if	O
(	O
class_name	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
j	long
=	O
-	O
1	int
;	O
i	long
=	O
edma_dict_get_next_index	function
(	O
edma_class_dict	pointer
,	O
class_name	pointer
,	O
&	O
j	long
)	O
;	O
while	O
(	O
i	long
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
(	O
gClass	O
[	O
i	long
]	O
->	O
MajorVer	char
==	O
major_ver	long
)	O
&&	O
(	O
gClass	O
[	O
i	long
]	O
->	O
MinorVer	char
==	O
minor_ver	long
)	O
)	O
break	O
;	O
else	O
{	O
i	long
=	O
edma_dict_get_next_index	function
(	O
edma_class_dict	pointer
,	O
class_name	pointer
,	O
&	O
j	long
)	O
;	O
}	O
}	O
if	O
(	O
i	long
<	O
0	int
)	O
{	O
j	long
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
j	long
<	O
GVar	pointer
->	O
nClases	long
;	O
i	long
++	O
)	O
if	O
(	O
gClass	O
[	O
i	long
]	O
!=	O
0	int
)	O
if	O
(	O
gClass	O
[	O
i	long
]	O
->	O
Status	char
!=	O
CLASS_FREE	int
)	O
{	O
if	O
(	O
(	O
strncmp	function
(	O
gClass	O
[	O
i	long
]	O
->	O
ClassName	array
,	O
class_name	pointer
,	O
EDMA_CLASS_NAME_LEN	int
)	O
)	O
==	O
0	int
)	O
if	O
(	O
(	O
gClass	O
[	O
i	long
]	O
->	O
MajorVer	char
==	O
major_ver	long
)	O
&&	O
(	O
gClass	O
[	O
i	long
]	O
->	O
MinorVer	char
==	O
minor_ver	long
)	O
)	O
break	O
;	O
j	long
++	O
;	O
}	O
if	O
(	O
i	long
==	O
GVar	pointer
->	O
nClases	long
)	O
{	O
r	long
=	O
-	O
1	int
;	O
if	O
(	O
GVar	pointer
->	O
GetClassEMI	long
!=	O
0	int
)	O
{	O
idEMI	long
=	O
edma_new_obj	function
(	O
gClass	O
[	O
GVar	pointer
->	O
GetClassEMI	long
]	O
->	O
ClassName	array
)	O
;	O
if	O
(	O
idEMI	long
==	O
-	O
1	int
)	O
{	O
edma_printf_err	function
(	O
"[edma_get_class_id] Can't create "	pointer
"EMI handler object [%s]"	pointer
,	O
gClass	O
[	O
GVar	pointer
->	O
GetClassEMI	long
]	O
->	O
ClassName	array
)	O
;	O
return	O
-	O
1	int
;	O
}	O
r	long
=	O
(	O
CLASSID	long
)	O
edma_met3	function
(	O
idEMI	long
,	O
"GetClass"	pointer
,	O
class_name	pointer
)	O
;	O
edma_free_obj	function
(	O
idEMI	long
)	O
;	O
}	O
return	O
r	long
;	O
}	O
else	O
{	O
ProcMapTable	pointer
[	O
i	long
]	O
=	O
CLASS_DEF	int
;	O
edma_dict_add_entry	function
(	O
edma_class_dict	pointer
,	O
gClass	O
[	O
i	long
]	O
->	O
ClassName	array
,	O
i	long
)	O
;	O
return	O
i	long
;	O
}	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
(	O
gClass	O
[	O
i	long
]	O
!=	O
0	int
)	O
&&	O
(	O
ProcMapTable	pointer
[	O
i	long
]	O
!=	O
CLASS_FREE	int
)	O
)	O
return	O
i	long
;	O
else	O
return	O
-	O
1	int
;	O
}	O
edma_printf	function
(	O
"%s"	pointer
,	O
"(edma_get_class_id_with_version) Unreacheable code"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
CLASSID	long
EDMAPROC	O
edma_get_class_id	function
(	O
EPChar	pointer
class_name	pointer
)	O
{	O
ESint32	long
i	long
;	O
EUint32	long
r	long
,	O
j	long
;	O
OBJID	long
idEMI	long
;	O
if	O
(	O
class_name	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
last_checked_versions	long
<	O
GVar	pointer
->	O
time_last_version_update	long
)	O
_edma_class_update_all_versions	function
(	O
)	O
;	O
if	O
(	O
(	O
i	long
=	O
edma_dict_get_index	function
(	O
edma_class_dict	pointer
,	O
class_name	pointer
)	O
)	O
<	O
0	int
)	O
{	O
j	long
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
j	long
<	O
GVar	pointer
->	O
nClases	long
;	O
i	long
++	O
)	O
if	O
(	O
gClass	O
[	O
i	long
]	O
!=	O
0	int
)	O
if	O
(	O
gClass	O
[	O
i	long
]	O
->	O
Status	char
!=	O
CLASS_FREE	int
)	O
{	O
if	O
(	O
(	O
strncmp	function
(	O
gClass	O
[	O
i	long
]	O
->	O
ClassName	array
,	O
class_name	pointer
,	O
EDMA_CLASS_NAME_LEN	int
)	O
)	O
==	O
0	int
)	O
break	O
;	O
j	long
++	O
;	O
}	O
if	O
(	O
i	long
==	O
GVar	pointer
->	O
nClases	long
)	O
{	O
r	long
=	O
-	O
1	int
;	O
if	O
(	O
GVar	pointer
->	O
GetClassEMI	long
!=	O
0	int
)	O
{	O
idEMI	long
=	O
edma_new_obj	function
(	O
gClass	O
[	O
GVar	pointer
->	O
GetClassEMI	long
]	O
->	O
ClassName	array
)	O
;	O
if	O
(	O
idEMI	long
==	O
-	O
1	int
)	O
{	O
edma_printf_err	function
(	O
"[edma_get_class_id] Can't create "	pointer
"EMI handler object [%s]"	pointer
,	O
gClass	O
[	O
GVar	pointer
->	O
GetClassEMI	long
]	O
->	O
ClassName	array
)	O
;	O
return	O
-	O
1	int
;	O
}	O
r	long
=	O
(	O
CLASSID	long
)	O
edma_met3	function
(	O
idEMI	long
,	O
"GetClass"	pointer
,	O
class_name	pointer
)	O
;	O
edma_free_obj	function
(	O
idEMI	long
)	O
;	O
}	O
return	O
r	long
==	O
-	O
1	int
?	O
-	O
1	int
:	O
pClass	pointer
[	O
r	long
]	O
->	O
actual_version	long
;	O
}	O
else	O
{	O
ProcMapTable	pointer
[	O
i	long
]	O
=	O
CLASS_DEF	int
;	O
edma_log	function
(	O
"[%s] Registering class %i'%s'"	pointer
,	O
__FUNCTION__	O
,	O
i	long
,	O
gClass	O
[	O
i	long
]	O
->	O
ClassName	array
)	O
;	O
edma_dict_add_entry	function
(	O
edma_class_dict	pointer
,	O
gClass	O
[	O
i	long
]	O
->	O
ClassName	array
,	O
i	long
)	O
;	O
return	O
pClass	pointer
[	O
i	long
]	O
->	O
actual_version	long
;	O
}	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
CLASSID	long
sel	long
=	O
pClass	pointer
[	O
i	long
]	O
->	O
actual_version	long
;	O
edma_log	function
(	O
"Looking for class '%s' I found '%s' v%d.%d\n"	pointer
,	O
class_name	pointer
,	O
gClass	O
[	O
sel	long
]	O
->	O
ClassName	array
,	O
gClass	O
[	O
sel	long
]	O
->	O
MajorVer	char
,	O
gClass	O
[	O
sel	long
]	O
->	O
MinorVer	char
)	O
;	O
if	O
(	O
(	O
gClass	O
[	O
i	long
]	O
!=	O
0	int
)	O
&&	O
(	O
ProcMapTable	pointer
[	O
i	long
]	O
!=	O
CLASS_FREE	int
)	O
)	O
return	O
pClass	pointer
[	O
i	long
]	O
->	O
actual_version	long
;	O
else	O
return	O
-	O
1	int
;	O
}	O
edma_printf	function
(	O
"%s"	pointer
,	O
"(edma_get_class_id) Unreacheable code"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
CLASSID	long
EDMAPROC	O
edma_get_next_class	function
(	O
CLASSID	long
cid	long
)	O
{	O
int	O
i	long
,	O
base	int
;	O
base	int
=	O
cid	long
;	O
if	O
(	O
cid	long
<	O
GVar	pointer
->	O
nClases	long
)	O
{	O
edma_printf	function
(	O
"Looking in shared repository from index: %d"	pointer
,	O
cid	long
)	O
;	O
for	O
(	O
i	long
=	O
cid	long
;	O
i	long
<	O
GVar	pointer
->	O
nClases	long
;	O
i	long
++	O
)	O
if	O
(	O
gClass	O
[	O
i	long
]	O
->	O
Status	char
!=	O
CLASS_FREE	int
)	O
return	O
i	long
;	O
base	int
=	O
MAX_CLASE	int
;	O
}	O
for	O
(	O
i	long
=	O
base	int
;	O
i	long
<	O
MAX_CLASE	int
+	O
nMaxLocalClasses	long
;	O
i	long
++	O
)	O
if	O
(	O
gClass	O
[	O
i	long
]	O
->	O
Status	char
!=	O
CLASS_FREE	int
)	O
return	O
i	long
;	O
return	O
-	O
1	int
;	O
}	O
EPChar	pointer
EDMAPROC	O
edma_get_idf_file_path	function
(	O
CLASSID	long
cid	long
)	O
{	O
EPChar	pointer
aux	pointer
;	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
cid	long
,	O
"edma_get_idf_file_path"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
NULL	O
;	O
if	O
(	O
(	O
aux	pointer
=	O
malloc	function
(	O
1024	int
)	O
)	O
==	O
NULL	O
)	O
{	O
edma_printf_err	function
(	O
"Cannot alocate memory...\n"	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
edma_repo_manager_get_repo_type	function
(	O
gClass	O
[	O
cid	long
]	O
->	O
repo_id	long
)	O
==	O
EDMA_SHARED_REPO	int
)	O
{	O
if	O
(	O
(	O
gClass	O
[	O
cid	long
]	O
->	O
MajorVer	char
==	O
0	int
)	O
&&	O
(	O
gClass	O
[	O
cid	long
]	O
->	O
MinorVer	char
==	O
0	int
)	O
)	O
snprintf	function
(	O
aux	pointer
,	O
1024	int
,	O
"%s/%s/%s/%s.idf"	pointer
,	O
edma_repo_manager_get_repo_dir	function
(	O
gClass	O
[	O
cid	long
]	O
->	O
repo_id	long
)	O
,	O
IDFDIR	pointer
,	O
gClass	O
[	O
cid	long
]	O
->	O
NameSpace	array
,	O
gClass	O
[	O
cid	long
]	O
->	O
ClassName	array
)	O
;	O
else	O
snprintf	function
(	O
aux	pointer
,	O
1024	int
,	O
"%s/%s/%s/%s_%d_%d.idf"	pointer
,	O
edma_repo_manager_get_repo_dir	function
(	O
gClass	O
[	O
cid	long
]	O
->	O
repo_id	long
)	O
,	O
IDFDIR	pointer
,	O
gClass	O
[	O
cid	long
]	O
->	O
NameSpace	array
,	O
gClass	O
[	O
cid	long
]	O
->	O
ClassName	array
,	O
gClass	O
[	O
cid	long
]	O
->	O
MajorVer	char
,	O
gClass	O
[	O
cid	long
]	O
->	O
MinorVer	char
)	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
gClass	O
[	O
cid	long
]	O
->	O
MajorVer	char
==	O
0	int
)	O
&&	O
(	O
gClass	O
[	O
cid	long
]	O
->	O
MinorVer	char
==	O
0	int
)	O
)	O
snprintf	function
(	O
aux	pointer
,	O
1024	int
,	O
"%s/%s/idf/%s/%s.idf"	pointer
,	O
edma_repo_manager_get_repo_dir	function
(	O
gClass	O
[	O
cid	long
]	O
->	O
repo_id	long
)	O
,	O
edma_repo_manager_get_repo_name	function
(	O
gClass	O
[	O
cid	long
]	O
->	O
repo_id	long
)	O
,	O
gClass	O
[	O
cid	long
]	O
->	O
NameSpace	array
,	O
gClass	O
[	O
cid	long
]	O
->	O
ClassName	array
)	O
;	O
else	O
snprintf	function
(	O
aux	pointer
,	O
1024	int
,	O
"%s/%s/idf/%s/%s_%d_%d.idf"	pointer
,	O
edma_repo_manager_get_repo_dir	function
(	O
gClass	O
[	O
cid	long
]	O
->	O
repo_id	long
)	O
,	O
edma_repo_manager_get_repo_name	function
(	O
gClass	O
[	O
cid	long
]	O
->	O
repo_id	long
)	O
,	O
gClass	O
[	O
cid	long
]	O
->	O
NameSpace	array
,	O
gClass	O
[	O
cid	long
]	O
->	O
ClassName	array
,	O
gClass	O
[	O
cid	long
]	O
->	O
MajorVer	char
,	O
gClass	O
[	O
cid	long
]	O
->	O
MinorVer	char
)	O
;	O
}	O
return	O
aux	pointer
;	O
}	O
EPChar	pointer
EDMAPROC	O
edma_get_impl_file_path	function
(	O
CLASSID	long
cid	long
)	O
{	O
EPChar	pointer
aux	pointer
;	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
cid	long
,	O
"edma_is_class_IDF_parser"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
NULL	O
;	O
if	O
(	O
(	O
aux	pointer
=	O
malloc	function
(	O
1024	int
)	O
)	O
==	O
NULL	O
)	O
{	O
edma_printf_err	function
(	O
"Cannot alocate memory...\n"	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
edma_repo_manager_get_repo_type	function
(	O
gClass	O
[	O
cid	long
]	O
->	O
repo_id	long
)	O
==	O
EDMA_SHARED_REPO	int
)	O
{	O
snprintf	function
(	O
aux	pointer
,	O
1024	int
,	O
"%s/lib/edma/%s/%s.so.%d.%d.0"	pointer
,	O
edma_repo_manager_get_repo_dir	function
(	O
gClass	O
[	O
cid	long
]	O
->	O
repo_id	long
)	O
,	O
gClass	O
[	O
cid	long
]	O
->	O
NameSpace	array
,	O
gClass	O
[	O
cid	long
]	O
->	O
SysClass	struct
.	O
ModuleName	array
,	O
gClass	O
[	O
cid	long
]	O
->	O
MajorVer	char
,	O
gClass	O
[	O
cid	long
]	O
->	O
MinorVer	char
)	O
;	O
}	O
else	O
{	O
char	O
*	O
rn	pointer
=	O
edma_repo_manager_get_repo_name	function
(	O
gClass	O
[	O
cid	long
]	O
->	O
repo_id	long
)	O
;	O
snprintf	function
(	O
aux	pointer
,	O
1024	int
,	O
"%s/%s/lib/%s/%s.so.%d.%d.0"	pointer
,	O
edma_repo_manager_get_repo_dir	function
(	O
gClass	O
[	O
cid	long
]	O
->	O
repo_id	long
)	O
,	O
rn	pointer
,	O
gClass	O
[	O
cid	long
]	O
->	O
NameSpace	array
,	O
gClass	O
[	O
cid	long
]	O
->	O
SysClass	struct
.	O
ModuleName	array
,	O
gClass	O
[	O
cid	long
]	O
->	O
MajorVer	char
,	O
gClass	O
[	O
cid	long
]	O
->	O
MinorVer	char
)	O
;	O
free	function
(	O
rn	pointer
)	O
;	O
}	O
return	O
aux	pointer
;	O
}	O
ESint32	long
EDMAPROC	O
edma_is_class_IDF_parser	function
(	O
CLASSID	long
class_id	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
class_id	long
,	O
"edma_is_class_IDF_parser"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
return	O
gClass	O
[	O
class_id	long
]	O
->	O
IsIDF	char
;	O
}	O
ESint32	long
EDMAPROC	O
edma_is_class_SIU_proxy	function
(	O
CLASSID	long
class_id	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
class_id	long
,	O
"edma_is_class_SIU_proxy"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
return	O
gClass	O
[	O
class_id	long
]	O
->	O
IsSIU	char
;	O
}	O
ESint32	long
EDMAPROC	O
edma_is_class_EMI_handler	function
(	O
CLASSID	long
class_id	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
class_id	long
,	O
"edma_is_class_EMI_handler"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
return	O
gClass	O
[	O
class_id	long
]	O
->	O
IsEMI	char
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_prop_num	function
(	O
CLASSID	long
class_id	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
class_id	long
,	O
"edma_get_prop_num"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
return	O
gClass	O
[	O
class_id	long
]	O
->	O
nProp	short
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_prop_name	function
(	O
CLASSID	long
class_id	long
,	O
EUint32	long
indx	long
,	O
EPChar	pointer
prop_name	pointer
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
class_id	long
,	O
"edma_get_prop_name"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
prop_name	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
indx	long
>	O
gClass	O
[	O
class_id	long
]	O
->	O
nProp	short
)	O
{	O
edma_printf_err	function
(	O
"[edma_get_prop_name] Property %d doesn't exist "	pointer
"for class %s[%ld]"	pointer
,	O
indx	long
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
strncpy	function
(	O
prop_name	pointer
,	O
pClass	pointer
[	O
class_id	long
]	O
->	O
Prop	pointer
[	O
indx	long
]	O
.	O
IdProp	array
,	O
EDMA_PROP_NAME_LEN	O
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_class_num_superclasses	function
(	O
CLASSID	long
class_id	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
class_id	long
,	O
"edma_get_class_num_superclasses"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
return	O
gClass	O
[	O
class_id	long
]	O
->	O
Derived	long
;	O
}	O
CLASSID	long
EDMAPROC	O
edma_get_class_superclass	function
(	O
CLASSID	long
class_id	long
,	O
ESint32	long
indx	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
class_id	long
,	O
"edma_get_class_superclass"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
(	O
indx	long
<	O
0	int
)	O
||	O
(	O
indx	long
>	O
gClass	O
[	O
class_id	long
]	O
->	O
Derived	long
)	O
)	O
{	O
edma_printf_err	function
(	O
"[edma_get_class_superclass] Index %d out of range for"	pointer
"class %s [%ld]"	pointer
,	O
indx	long
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
pClass	pointer
[	O
class_id	long
]	O
->	O
SCList	pointer
[	O
indx	long
]	O
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_class_superclass_apoints	function
(	O
CLASSID	long
class_id	long
,	O
ESint32	long
indx	long
,	O
EPChar	pointer
ap1	pointer
,	O
EPChar	pointer
ap2	pointer
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
class_id	long
,	O
"edma_get_class_superclass"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
(	O
indx	long
<	O
0	int
)	O
||	O
(	O
indx	long
>	O
gClass	O
[	O
class_id	long
]	O
->	O
Derived	long
)	O
)	O
{	O
edma_printf_err	function
(	O
"[edma_get_class_superclass] Index %d out of range for"	pointer
"class %s [%ld]"	pointer
,	O
indx	long
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
ap1	pointer
==	O
NULL	O
)	O
||	O
(	O
ap2	pointer
==	O
NULL	O
)	O
)	O
return	O
-	O
1	int
;	O
strncpy	function
(	O
ap1	pointer
,	O
pClass	pointer
[	O
class_id	long
]	O
->	O
SCIdList	pointer
[	O
indx	long
]	O
,	O
EDMA_GENERAL_ID_LEN	int
)	O
;	O
strncpy	function
(	O
ap1	pointer
,	O
pClass	pointer
[	O
class_id	long
]	O
->	O
SubCIdList	pointer
[	O
indx	long
]	O
,	O
EDMA_GENERAL_ID_LEN	int
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_prop_indx	function
(	O
CLASSID	long
class_id	long
,	O
EPChar	pointer
prop_name	pointer
)	O
{	O
EUint32	long
i	long
;	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
class_id	long
,	O
"edma_get_prop_indx"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
prop_name	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
class_id	long
]	O
->	O
nProp	short
;	O
i	long
++	O
)	O
if	O
(	O
strncmp	function
(	O
pClass	pointer
[	O
class_id	long
]	O
->	O
Prop	pointer
[	O
i	long
]	O
.	O
IdProp	array
,	O
prop_name	pointer
,	O
EDMA_PROP_NAME_LEN	O
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
i	long
==	O
gClass	O
[	O
class_id	long
]	O
->	O
nProp	short
)	O
return	O
-	O
1	int
;	O
else	O
return	O
i	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_prop_type	function
(	O
CLASSID	long
class_id	long
,	O
EUint32	long
indx	long
,	O
EPChar	pointer
type_name	pointer
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
class_id	long
,	O
"edma_get_prop_type"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
type_name	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
indx	long
>	O
gClass	O
[	O
class_id	long
]	O
->	O
nProp	short
)	O
{	O
edma_printf_err	function
(	O
"[edma_get_prop_type] Property %d doesn't exist "	pointer
"for class %s[%ld]"	pointer
,	O
indx	long
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
strncpy	function
(	O
type_name	pointer
,	O
tipo	array
[	O
pClass	pointer
[	O
class_id	long
]	O
->	O
Prop	pointer
[	O
indx	long
]	O
.	O
Tipo	long
]	O
.	O
Id	long
,	O
EDMA_TYPE_NAME_LEN	O
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_met_num	function
(	O
CLASSID	long
class_id	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
class_id	long
,	O
"edma_get_met_num"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
return	O
gClass	O
[	O
class_id	long
]	O
->	O
nMet	short
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_met_name	function
(	O
CLASSID	long
class_id	long
,	O
EUint32	long
indx	long
,	O
EPChar	pointer
met_name	pointer
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
class_id	long
,	O
"edma_get_met_name"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
met_name	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
indx	long
>	O
gClass	O
[	O
class_id	long
]	O
->	O
nMet	short
)	O
{	O
edma_printf_err	function
(	O
"[edma_get_met_name] Method %d doesn't exist "	pointer
"for class %s[%ld]"	pointer
,	O
indx	long
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
strncpy	function
(	O
met_name	pointer
,	O
pClass	pointer
[	O
class_id	long
]	O
->	O
Met	pointer
[	O
indx	long
]	O
.	O
IdMet	array
,	O
EDMA_MET_NAME_LEN	O
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_met_sig	function
(	O
CLASSID	long
class_id	long
,	O
EUint32	long
indx	long
,	O
EPChar	pointer
met_sig	pointer
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
class_id	long
,	O
"edma_get_met_sig"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
met_sig	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
indx	long
>	O
gClass	O
[	O
class_id	long
]	O
->	O
nMet	short
)	O
{	O
edma_printf_err	function
(	O
"[edma_get_met_sig] Method %d doesn't exist "	pointer
"for class %s[%ld]"	pointer
,	O
indx	long
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
strncpy	function
(	O
met_sig	pointer
,	O
pClass	pointer
[	O
class_id	long
]	O
->	O
Met	pointer
[	O
indx	long
]	O
.	O
Sign	array
,	O
EDMA_MET_SIG_LEN	int
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_is_met_virtual	function
(	O
CLASSID	long
class_id	long
,	O
EUint32	long
indx	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
class_id	long
,	O
"edma_is_met_virtual"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
indx	long
>	O
gClass	O
[	O
class_id	long
]	O
->	O
nMet	short
)	O
{	O
edma_printf_err	function
(	O
"[edma_is_met_virtual] Method %d doesn't exist "	pointer
"for class %s[%ld]"	pointer
,	O
indx	long
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
pClass	pointer
[	O
class_id	long
]	O
->	O
Met	pointer
[	O
indx	long
]	O
.	O
Virtual	char
)	O
return	O
1	int
;	O
else	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_is_met_abstract	function
(	O
CLASSID	long
class_id	long
,	O
EUint32	long
indx	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
class_id	long
,	O
"edma_is_met_abstract"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
indx	long
>	O
gClass	O
[	O
class_id	long
]	O
->	O
nMet	short
)	O
{	O
edma_printf_err	function
(	O
"[edma_is_met_abstract] Method %d doesn't exist "	pointer
"for class %s[%ld]"	pointer
,	O
indx	long
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
pClass	pointer
[	O
class_id	long
]	O
->	O
Met	pointer
[	O
indx	long
]	O
.	O
Abstract	char
)	O
return	O
1	int
;	O
else	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_is_met_static	function
(	O
CLASSID	long
class_id	long
,	O
EUint32	long
indx	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
class_id	long
,	O
"edma_is_met_static"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
indx	long
>	O
gClass	O
[	O
class_id	long
]	O
->	O
nMet	short
)	O
{	O
edma_printf_err	function
(	O
"[edma_is_met_static] Method %d doesn't exist "	pointer
"for class %s[%ld]"	pointer
,	O
indx	long
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
pClass	pointer
[	O
class_id	long
]	O
->	O
Met	pointer
[	O
indx	long
]	O
.	O
Static	char
)	O
return	O
1	int
;	O
else	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_met_indx	function
(	O
CLASSID	long
class_id	long
,	O
EPChar	pointer
met_name	pointer
)	O
{	O
EUint32	long
i	long
;	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
class_id	long
,	O
"edma_get_method_indx"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
met_name	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
class_id	long
]	O
->	O
nMet	short
;	O
i	long
++	O
)	O
if	O
(	O
strncmp	function
(	O
pClass	pointer
[	O
class_id	long
]	O
->	O
Met	pointer
[	O
i	long
]	O
.	O
IdMet	array
,	O
met_name	pointer
,	O
EDMA_MET_NAME_LEN	O
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
i	long
==	O
gClass	O
[	O
class_id	long
]	O
->	O
nMet	short
)	O
return	O
-	O
1	int
;	O
else	O
return	O
i	long
;	O
}	O
PPROC	pointer
*	O
EDMAPROC	O
edma_get_met_func	function
(	O
CLASSID	long
class_id	long
,	O
EPChar	pointer
met_name	pointer
)	O
{	O
EUint32	long
i	long
;	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
class_id	long
,	O
"edma_get_method_indx"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
0	int
;	O
if	O
(	O
met_name	pointer
==	O
NULL	O
)	O
return	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
class_id	long
]	O
->	O
nMet	short
;	O
i	long
++	O
)	O
if	O
(	O
strncmp	function
(	O
pClass	pointer
[	O
class_id	long
]	O
->	O
Met	pointer
[	O
i	long
]	O
.	O
IdMet	array
,	O
met_name	pointer
,	O
EDMA_MET_NAME_LEN	O
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
i	long
==	O
gClass	O
[	O
class_id	long
]	O
->	O
nMet	short
)	O
return	O
0	int
;	O
else	O
return	O
pClass	pointer
[	O
class_id	long
]	O
->	O
met_func	pointer
[	O
i	long
]	O
.	O
Func	pointer
;	O
}	O
ESint32	long
EDMAPROC	O
edma_set_met_func	function
(	O
CLASSID	long
class_id	long
,	O
EPChar	pointer
met_name	pointer
,	O
PPROC	pointer
*	O
func	pointer
)	O
{	O
EUint32	long
i	long
;	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
class_id	long
,	O
"edma_get_method_indx"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
0	int
;	O
if	O
(	O
met_name	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
gClass	O
[	O
class_id	long
]	O
->	O
repo_type	char
!=	O
EDMA_LOCAL_REPO	int
)	O
return	O
-	O
1	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
class_id	long
]	O
->	O
nMet	short
;	O
i	long
++	O
)	O
if	O
(	O
strncmp	function
(	O
pClass	pointer
[	O
class_id	long
]	O
->	O
Met	pointer
[	O
i	long
]	O
.	O
IdMet	array
,	O
met_name	pointer
,	O
EDMA_MET_NAME_LEN	O
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
i	long
==	O
gClass	O
[	O
class_id	long
]	O
->	O
nMet	short
)	O
return	O
-	O
1	int
;	O
pClass	pointer
[	O
class_id	long
]	O
->	O
met_func	pointer
[	O
i	long
]	O
.	O
Func	pointer
=	O
func	pointer
;	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_all_met_func	function
(	O
OBJID	long
IdObj	long
,	O
PPROC	pointer
*	O
*	O
list	pointer
)	O
{	O
CLASSID	long
class_id	long
;	O
ESint32	long
i	long
,	O
n	long
;	O
if	O
(	O
(	O
edma_check_obj_id	function
(	O
IdObj	long
,	O
"edma_get_all_met_func"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
class_id	long
=	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdClass	long
;	O
n	long
=	O
gClass	O
[	O
class_id	long
]	O
->	O
nMet	short
;	O
if	O
(	O
(	O
*	O
list	pointer
=	O
(	O
PPROC	pointer
*	O
)	O
edma_palloc	function
(	O
sizeof	O
(	O
PPROC	pointer
*	O
)	O
*	O
n	long
)	O
)	O
==	O
NULL	O
)	O
{	O
edma_printf_err	function
(	O
"[edma_get_all_met_func] Can't alloc space for "	pointer
"method table from object %ld"	pointer
,	O
IdObj	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
class_id	long
]	O
->	O
nMet	short
;	O
i	long
++	O
)	O
{	O
*	O
(	O
*	O
list	pointer
+	O
i	long
)	O
=	O
(	O
PPROC	pointer
)	O
pClass	pointer
[	O
class_id	long
]	O
->	O
met_func	pointer
[	O
i	long
]	O
.	O
Func	pointer
;	O
}	O
return	O
n	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_prop_type_id	function
(	O
CLASSID	long
class_id	long
,	O
EUint32	long
indx	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
class_id	long
,	O
"edma_get_prop_type_id"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
indx	long
>	O
gClass	O
[	O
class_id	long
]	O
->	O
nProp	short
)	O
{	O
edma_printf_err	function
(	O
"[edma_get_prop_type_id] Property %d doesn't exist "	pointer
"for class %s[%ld]"	pointer
,	O
indx	long
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
pClass	pointer
[	O
class_id	long
]	O
->	O
Prop	pointer
[	O
indx	long
]	O
.	O
Tipo	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_prop_type_sig	function
(	O
CLASSID	long
class_id	long
,	O
EUint32	long
indx	long
,	O
EPChar	pointer
type_sig	pointer
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
class_id	long
,	O
"edma_get_prop_type_sig"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
type_sig	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
indx	long
>	O
gClass	O
[	O
class_id	long
]	O
->	O
nProp	short
)	O
{	O
edma_printf_err	function
(	O
"[edma_get_prop_type_sig] Property %d doesn't exist "	pointer
"for class %s[%ld]"	pointer
,	O
indx	long
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
strncpy	function
(	O
type_sig	pointer
,	O
tipo	array
[	O
pClass	pointer
[	O
class_id	long
]	O
->	O
Prop	pointer
[	O
indx	long
]	O
.	O
Tipo	long
]	O
.	O
Sig	array
,	O
EDMA_TYPE_SIG_LEN	int
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_prop_num_elements	function
(	O
CLASSID	long
class_id	long
,	O
EUint32	long
indx	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
class_id	long
,	O
"edma_get_prop_num_elements"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
indx	long
>	O
gClass	O
[	O
class_id	long
]	O
->	O
nProp	short
)	O
{	O
edma_printf_err	function
(	O
"[edma_get_prop_num_elements] Property %d doesn't exist"	pointer
" for class %s[%ld]"	pointer
,	O
indx	long
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
pClass	pointer
[	O
class_id	long
]	O
->	O
Prop	pointer
[	O
indx	long
]	O
.	O
nElem	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_prop_strlen	function
(	O
CLASSID	long
class_id	long
,	O
EUint32	long
indx	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	function
(	O
class_id	long
,	O
"edma_get_prop_num_elements"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
indx	long
>	O
gClass	O
[	O
class_id	long
]	O
->	O
nProp	short
)	O
{	O
edma_printf_err	function
(	O
"[edma_get_prop_num_elements] Property %d doesn't exist"	pointer
" for class %s[%ld]"	pointer
,	O
indx	long
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
pClass	pointer
[	O
class_id	long
]	O
->	O
Prop	pointer
[	O
indx	long
]	O
.	O
nElem	long
;	O
}	O
EUint32	long
EDMAPROC	O
edma_get_type_size	function
(	O
EUint32	long
type_id	long
)	O
{	O
if	O
(	O
(	O
type_id	long
<	O
0	int
)	O
||	O
(	O
type_id	long
>	O
MAX_TIPOS	int
)	O
)	O
{	O
edma_printf_err	function
(	O
"[edma_Get_type_size] Type identifier %d "	pointer
"isn't valid"	pointer
,	O
type_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
tipo	array
[	O
type_id	long
]	O
.	O
tam	long
;	O
}	O
EUint32	long
EDMAPROC	O
edma_get_type_sig	function
(	O
EUint32	long
type_id	long
,	O
EPChar	pointer
type_name	pointer
)	O
{	O
if	O
(	O
(	O
type_id	long
<	O
0	int
)	O
||	O
(	O
type_id	long
>	O
MAX_TIPOS	int
)	O
)	O
{	O
edma_printf_err	function
(	O
"[edma_get_type_sig] Type identifier %d isn't valid"	pointer
,	O
type_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
type_name	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
strncpy	function
(	O
type_name	pointer
,	O
tipo	array
[	O
type_id	long
]	O
.	O
Sig	array
,	O
EDMA_TYPE_SIG_LEN	int
)	O
;	O
return	O
0	int
;	O
}	O
EUint32	long
EDMAPROC	O
edma_get_type_id	function
(	O
EPChar	pointer
pType	pointer
)	O
{	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
MAX_TIPOS	int
;	O
i	long
++	O
)	O
if	O
(	O
strncasecmp	function
(	O
tipo	array
[	O
i	long
]	O
.	O
Id	long
,	O
pType	pointer
,	O
EDMA_TYPE_SIG_LEN	int
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
i	long
==	O
MAX_TIPOS	int
)	O
return	O
-	O
1	int
;	O
return	O
i	long
;	O
}	O
