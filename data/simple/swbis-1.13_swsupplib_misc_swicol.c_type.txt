static	O
char	O
*	O
subshell_marks	function
(	O
STROB	struct
*	O
subsh	pointer
,	O
char	O
*	O
type	enum
,	O
int	O
wh	int
,	O
int	O
nhops	int
,	O
int	O
verbose_level	int
,	O
char	O
*	O
group_delim	pointer
)	O
{	O
int	O
is_subshell	int
;	O
is_subshell	int
=	O
(	O
*	O
group_delim	pointer
==	O
'('	O
)	O
;	O
strob_strcpy	function
(	O
subsh	pointer
,	O
""	pointer
)	O
;	O
if	O
(	O
wh	int
==	O
(	O
int	O
)	O
'L'	O
)	O
{	O
strob_sprintf	function
(	O
subsh	pointer
,	O
STROB_DO_APPEND	int
,	O
"%s\n"	pointer
,	O
group_delim	pointer
)	O
;	O
}	O
else	O
if	O
(	O
wh	int
==	O
(	O
int	O
)	O
'R'	O
)	O
{	O
strob_sprintf	function
(	O
subsh	pointer
,	O
STROB_DO_APPEND	int
,	O
"exit $sw_retval;\n%s"	pointer
,	O
group_delim	pointer
+	O
2	int
)	O
;	O
if	O
(	O
is_subshell	int
&&	O
strcmp	function
(	O
type	enum
,	O
"source"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
nhops	int
>=	O
1	int
)	O
{	O
if	O
(	O
verbose_level	int
==	O
0	int
)	O
{	O
strob_strcat	function
(	O
subsh	pointer
,	O
"0</dev/null 2>/dev/null"	pointer
)	O
;	O
}	O
else	O
{	O
strob_strcat	function
(	O
subsh	pointer
,	O
"0</dev/null"	pointer
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
verbose_level	int
==	O
0	int
)	O
{	O
strob_strcat	function
(	O
subsh	pointer
,	O
"2>/dev/null"	pointer
)	O
;	O
}	O
else	O
{	O
strob_strcat	function
(	O
subsh	pointer
,	O
"0</dev/null"	pointer
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
is_subshell	int
&&	O
strcmp	function
(	O
type	enum
,	O
"target"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
nhops	int
>=	O
1	int
)	O
{	O
if	O
(	O
verbose_level	int
==	O
0	int
)	O
{	O
strob_strcat	function
(	O
subsh	pointer
,	O
"1>/dev/null 2>/dev/null"	pointer
)	O
;	O
}	O
else	O
{	O
strob_strcat	function
(	O
subsh	pointer
,	O
"1>/dev/null"	pointer
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
verbose_level	int
==	O
0	int
)	O
{	O
strob_strcat	function
(	O
subsh	pointer
,	O
"1>/dev/null 2>/dev/null"	pointer
)	O
;	O
}	O
else	O
{	O
strob_strcat	function
(	O
subsh	pointer
,	O
"1>/dev/null"	pointer
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
is_subshell	int
&&	O
strcmp	function
(	O
type	enum
,	O
"install_target"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
nhops	int
>=	O
1	int
)	O
{	O
if	O
(	O
verbose_level	int
==	O
0	int
)	O
{	O
strob_strcat	function
(	O
subsh	pointer
,	O
""	pointer
)	O
;	O
}	O
else	O
{	O
strob_strcat	function
(	O
subsh	pointer
,	O
""	pointer
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
verbose_level	int
==	O
0	int
)	O
{	O
strob_strcat	function
(	O
subsh	pointer
,	O
"2>/dev/null"	pointer
)	O
;	O
}	O
else	O
{	O
strob_strcat	function
(	O
subsh	pointer
,	O
""	pointer
)	O
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
is_subshell	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"internal error in swicol_task_wait at line %d\n"	pointer
,	O
__LINE__	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
is_subshell	int
)	O
{	O
strob_strcat	function
(	O
subsh	pointer
,	O
"; exit $?"	pointer
)	O
;	O
}	O
else	O
{	O
strob_strcat	function
(	O
subsh	pointer
,	O
""	pointer
)	O
;	O
}	O
}	O
else	O
{	O
;	O
}	O
return	O
strob_str	function
(	O
subsh	pointer
)	O
;	O
}	O
static	O
void	O
init_magic_header	function
(	O
SWICOL	struct
*	O
swicol	pointer
)	O
{	O
int	O
i	int
;	O
STROB	struct
*	O
tmp	pointer
;	O
tmp	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
9	int
;	O
i	int
++	O
)	O
strob_sprintf	function
(	O
tmp	pointer
,	O
1	int
,	O
"%s\n"	pointer
,	O
"# # # # # # # # # # # # # # # # # # # # # # # # # # # ##"	pointer
)	O
;	O
swicol	pointer
->	O
magic_headerM	pointer
=	O
strob_release	function
(	O
tmp	pointer
)	O
;	O
if	O
(	O
strlen	function
(	O
swicol	pointer
->	O
magic_headerM	pointer
)	O
<	O
513	int
)	O
exit	function
(	O
42	int
)	O
;	O
}	O
static	O
int	O
task_wait_for	function
(	O
SWICOL	struct
*	O
swicol	pointer
,	O
STROB	struct
*	O
retbuf	pointer
,	O
int	O
event_fd	int
,	O
int	O
timelimit	int
,	O
char	O
*	O
stop_string	pointer
)	O
{	O
int	O
retval	int
=	O
-	O
1	int
;	O
int	O
ret	int
=	O
0	int
;	O
int	O
cret	int
;	O
int	O
do_stop	int
;	O
int	O
readReturn	pointer
;	O
STROB	struct
*	O
buf	pointer
=	O
strob_open	function
(	O
180	int
)	O
;	O
char	O
*	O
s	pointer
;	O
int	O
alarm_monitor	int
;	O
time_t	long
start	int
=	O
time	struct
(	O
NULL	O
)	O
;	O
time_t	long
alarm_start	long
=	O
time	struct
(	O
NULL	O
)	O
;	O
time_t	long
now	long
=	O
start	int
;	O
struct	O
timespec	struct
req	struct
;	O
req	struct
.	O
tv_sec	long
=	O
0	int
;	O
req	struct
.	O
tv_nsec	long
=	O
297000	int
;	O
E_DEBUG2	O
(	O
"Entering: %s"	pointer
,	O
stop_string	pointer
)	O
;	O
if	O
(	O
retbuf	pointer
)	O
strob_strcpy	function
(	O
retbuf	pointer
,	O
""	pointer
)	O
;	O
alarm_start	long
=	O
(	O
time_t	long
)	O
(	O
0	int
)	O
;	O
alarm_monitor	int
=	O
0	int
;	O
cret	int
=	O
0	int
;	O
do_stop	int
=	O
0	int
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
while	O
(	O
(	O
alarm_monitor	int
==	O
0	int
)	O
&&	O
(	O
(	O
cret	int
==	O
0	int
)	O
||	O
(	O
do_stop	int
==	O
0	int
&&	O
(	O
(	O
int	O
)	O
(	O
now	long
-	O
start	int
)	O
<	O
timelimit	int
)	O
)	O
)	O
)	O
{	O
nanosleep	function
(	O
&	O
req	struct
,	O
(	O
struct	O
timespec	struct
*	O
)	O
(	O
NULL	O
)	O
)	O
;	O
now	long
=	O
time	struct
(	O
NULL	O
)	O
;	O
if	O
(	O
swicol	pointer
->	O
master_alarmM	int
)	O
{	O
E_DEBUG	O
(	O
"Got Alarm"	pointer
)	O
;	O
if	O
(	O
alarm_start	long
==	O
(	O
time_t	long
)	O
(	O
0	int
)	O
)	O
{	O
E_DEBUG	O
(	O
"Set Alarm Start"	pointer
)	O
;	O
alarm_start	long
=	O
time	struct
(	O
NULL	O
)	O
;	O
}	O
if	O
(	O
(	O
now	long
-	O
alarm_start	long
)	O
>	O
1	int
)	O
{	O
E_DEBUG	O
(	O
"Alarm Expired setting alarm_monitor"	pointer
)	O
;	O
alarm_monitor	int
=	O
1	int
;	O
}	O
}	O
ret	int
=	O
swgpReadLine	function
(	O
buf	pointer
,	O
event_fd	int
,	O
&	O
readReturn	pointer
)	O
;	O
if	O
(	O
cret	int
==	O
0	int
)	O
{	O
cret	int
=	O
ret	int
;	O
}	O
E_DEBUG2	O
(	O
"read buf: [%s]"	pointer
,	O
strob_str	function
(	O
buf	pointer
)	O
)	O
;	O
s	pointer
=	O
strstr	function
(	O
strob_str	function
(	O
buf	pointer
)	O
,	O
stop_string	pointer
)	O
;	O
if	O
(	O
s	pointer
)	O
{	O
if	O
(	O
strlen	function
(	O
s	pointer
)	O
==	O
6	int
&&	O
*	O
(	O
s	pointer
+	O
5	int
)	O
==	O
'\n'	O
)	O
{	O
E_DEBUG	O
(	O
"Normal stop"	pointer
)	O
;	O
retval	int
=	O
0	int
;	O
do_stop	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
strstr	function
(	O
s	pointer
,	O
SWICOL_START_STRING	pointer
)	O
&&	O
*	O
(	O
s	pointer
+	O
strlen	function
(	O
s	pointer
)	O
-	O
1	int
)	O
==	O
'\n'	O
)	O
{	O
E_DEBUG	O
(	O
"Got Start"	pointer
)	O
;	O
retval	int
=	O
0	int
;	O
do_stop	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
strlen	function
(	O
s	pointer
)	O
>	O
8	int
&&	O
strstr	function
(	O
s	pointer
,	O
SWICOL_STOP_STRING	pointer
)	O
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
retval	int
=	O
1	int
;	O
do_stop	int
=	O
1	int
;	O
fprintf	function
(	O
stderr	pointer
,	O
"internal error in swicol_task_wait at line %d\n"	pointer
,	O
__LINE__	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"expect string [%s]\n"	pointer
,	O
s	pointer
)	O
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
"partial read"	pointer
)	O
;	O
;	O
}	O
}	O
else	O
{	O
E_DEBUG	O
(	O
"nothing"	pointer
)	O
;	O
;	O
}	O
if	O
(	O
ret	int
&&	O
retbuf	pointer
)	O
strob_strcat	function
(	O
retbuf	pointer
,	O
strob_str	function
(	O
buf	pointer
)	O
)	O
;	O
}	O
if	O
(	O
do_stop	int
==	O
0	int
&&	O
swicol	pointer
->	O
master_alarmM	int
==	O
0	int
)	O
{	O
E_DEBUG	O
(	O
"time limit exceeded"	pointer
)	O
;	O
retval	int
=	O
2	int
;	O
swutil_doif_writef	function
(	O
swicol	pointer
->	O
verbose_levelM	int
,	O
1	int
,	O
swicol	pointer
->	O
logspecM	pointer
,	O
STDERR_FILENO	int
,	O
"SW_RESOURCE_ERROR: time limit of %d seconds exceeded\n"	pointer
,	O
timelimit	int
)	O
;	O
}	O
else	O
if	O
(	O
alarm_monitor	int
||	O
swicol	pointer
->	O
master_alarmM	int
)	O
{	O
E_DEBUG	O
(	O
"ALARM"	pointer
)	O
;	O
retval	int
=	O
2	int
;	O
swutil_doif_writef	function
(	O
swicol	pointer
->	O
verbose_levelM	int
,	O
1	int
,	O
swicol	pointer
->	O
logspecM	pointer
,	O
STDERR_FILENO	int
,	O
"SW_ABORT_SIGNAL_RECEIVED: user interrupt\n"	pointer
)	O
;	O
}	O
strob_close	function
(	O
buf	pointer
)	O
;	O
E_DEBUG2	O
(	O
"Leaving: %d"	pointer
,	O
retval	int
)	O
;	O
return	O
retval	int
;	O
}	O
static	O
void	O
form_debug_task_filename	function
(	O
char	O
*	O
buf	pointer
)	O
{	O
char	O
*	O
s	pointer
;	O
s	pointer
=	O
buf	pointer
;	O
while	O
(	O
*	O
s	pointer
)	O
{	O
if	O
(	O
*	O
s	pointer
==	O
' '	O
)	O
*	O
s	pointer
=	O
'_'	O
;	O
if	O
(	O
*	O
s	pointer
==	O
':'	O
)	O
{	O
*	O
s	pointer
=	O
'\0'	O
;	O
break	O
;	O
}	O
s	pointer
++	O
;	O
}	O
}	O
static	O
int	O
set_selected_index	function
(	O
SWICOL	struct
*	O
swicol	pointer
,	O
int	O
first_current_event	int
)	O
{	O
if	O
(	O
first_current_event	int
<	O
0	int
)	O
return	O
swicol	pointer
->	O
event_indexM	int
;	O
else	O
return	O
first_current_event	int
;	O
}	O
static	O
void	O
set_buf	function
(	O
char	O
*	O
*	O
dst	pointer
,	O
char	O
*	O
buf	pointer
)	O
{	O
if	O
(	O
*	O
dst	pointer
)	O
free	function
(	O
*	O
dst	pointer
)	O
;	O
*	O
dst	pointer
=	O
strdup	function
(	O
buf	pointer
)	O
;	O
}	O
static	O
int	O
convert_result_to_event_list	function
(	O
char	O
*	O
event_string	pointer
,	O
STRAR	struct
*	O
event_list	pointer
)	O
{	O
char	O
*	O
s	pointer
;	O
char	O
*	O
current	pointer
;	O
int	O
ret	int
;	O
E_DEBUG2	O
(	O
"event string: %s"	pointer
,	O
event_string	pointer
)	O
;	O
ret	int
=	O
strar_num_elements	function
(	O
event_list	pointer
)	O
;	O
s	pointer
=	O
strchr	function
(	O
event_string	pointer
,	O
'\n'	O
)	O
;	O
current	pointer
=	O
event_string	pointer
;	O
while	O
(	O
s	pointer
&&	O
*	O
s	pointer
)	O
{	O
*	O
s	pointer
=	O
'\0'	O
;	O
E_DEBUG2	O
(	O
"adding event to event list: %s"	pointer
,	O
current	pointer
)	O
;	O
strar_add	function
(	O
event_list	pointer
,	O
current	pointer
)	O
;	O
s	pointer
++	O
;	O
current	pointer
=	O
s	pointer
;	O
s	pointer
=	O
strchr	function
(	O
s	pointer
,	O
'\n'	O
)	O
;	O
}	O
strar_add	function
(	O
event_list	pointer
,	O
"\n"	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
static	O
int	O
print_task_script	function
(	O
SWICOL	struct
*	O
swicol	pointer
,	O
STROB	struct
*	O
command	pointer
,	O
uintmax_t	long
size	long
,	O
char	O
*	O
dir	pointer
,	O
char	O
*	O
task_script	pointer
,	O
char	O
*	O
task_desc	pointer
)	O
{	O
char	O
*	O
verbosestring	pointer
;	O
char	O
*	O
tonullstring	pointer
;	O
char	O
*	O
ablocks	pointer
;	O
STROB	struct
*	O
enddesc	pointer
;	O
STROB	struct
*	O
ubuf	pointer
;	O
STROB	struct
*	O
synct_eof_buf	pointer
;	O
STROB	struct
*	O
synct_eof_buf2	pointer
;	O
uintmax_t	long
blocks	long
;	O
ubuf	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
enddesc	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
synct_eof_buf	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
synct_eof_buf2	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
blocks	long
=	O
(	O
int	O
)	O
(	O
size	long
/	O
512	int
)	O
;	O
if	O
(	O
size	long
%	O
512	int
)	O
{	O
blocks	long
++	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Internal error: in swicol.c:print_task_script\n"	pointer
)	O
;	O
}	O
if	O
(	O
swlib_is_ascii_noaccept	function
(	O
dir	pointer
,	O
SWBIS_TAINTED_CHARS	pointer
"\a\b\n\r\t \v\\"	pointer
,	O
1	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"print_task_script: illegal dir: %s\n"	pointer
,	O
dir	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
swicol	pointer
->	O
verbose_levelM	int
>	O
SWC_VERBOSE_8	int
)	O
{	O
verbosestring	pointer
=	O
"set -vx"	pointer
;	O
}	O
else	O
{	O
verbosestring	pointer
=	O
"#set -vx"	pointer
;	O
}	O
if	O
(	O
swicol	pointer
->	O
verbose_levelM	int
>=	O
SWC_VERBOSE_5	int
)	O
{	O
tonullstring	pointer
=	O
" "	pointer
;	O
}	O
else	O
{	O
tonullstring	pointer
=	O
"2>/dev/null"	pointer
;	O
}	O
if	O
(	O
swicol	pointer
->	O
needs_synct_eoaM	int
)	O
{	O
strob_sprintf	function
(	O
synct_eof_buf	pointer
,	O
0	int
,	O
"(\n"	pointer
"(\n"	pointer
)	O
;	O
swlib_append_synct_eof	function
(	O
synct_eof_buf2	pointer
)	O
;	O
}	O
strob_sprintf	function
(	O
enddesc	pointer
,	O
0	int
,	O
"%s: "	pointer
SWEVENT_STATUS_PFX	O
"$sw_retval"	pointer
,	O
task_desc	pointer
)	O
;	O
ablocks	pointer
=	O
swlib_umaxtostr	function
(	O
blocks	long
,	O
ubuf	pointer
)	O
;	O
strob_sprintf	function
(	O
command	pointer
,	O
0	int
,	O
"{\n"	pointer
"dd bs=512 count=%s %s | (\n"	pointer
"# trap true 1 2 13 14 15\n"	pointer
CSHID	O
"%s\n"	pointer
"swxdir=\"%s\"\n"	pointer
"cd \"$swxdir\"\n"	pointer
"swret=$?; export swret\n"	pointer
"%s\n"	pointer
"	case $swret in\n"	pointer
"		0)\n"	pointer
" 			;;\n"	pointer
"		*)\n"	pointer
"			%s\n"	pointer
"			dd count=%s of=/dev/null 2>/dev/null\n"	pointer
"			%s\n"	pointer
"			%s\n"	pointer
"			exit \"$swret\"\n"	pointer
"			;;\n"	pointer
"	esac\n"	pointer
"%s"	pointer
"case \"$sw_retval\" in\n"	pointer
"	\"\") echo \"%s:\" Warning: sw_retval is not set for task script: %s 1>&2\n"	pointer
"		sw_retval=0\n"	pointer
"		;;\n"	pointer
"esac\n"	pointer
"exit \"$sw_retval\"\n"	pointer
"); sw_retval=$?\n"	pointer
"%s\n"	pointer
"exit $sw_retval\n"	pointer
"}\n"	pointer
,	O
ablocks	pointer
,	O
tonullstring	pointer
,	O
TEVENT	O
(	O
2	int
,	O
-	O
1	int
,	O
SWI_TASK_BEGINS	int
,	O
task_desc	pointer
)	O
,	O
dir	pointer
,	O
verbosestring	pointer
,	O
strob_str	function
(	O
synct_eof_buf	pointer
)	O
,	O
ablocks	pointer
,	O
strob_str	function
(	O
synct_eof_buf2	pointer
)	O
,	O
TEVENT	O
(	O
2	int
,	O
-	O
1	int
,	O
SW_INTERNAL_ERROR	int
,	O
"No such directory or no access: $swxdir"	pointer
)	O
,	O
task_script	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
task_desc	pointer
,	O
TEVENT	O
(	O
2	int
,	O
-	O
1	int
,	O
SWI_TASK_ENDS	int
,	O
strob_str	function
(	O
enddesc	pointer
)	O
)	O
)	O
;	O
strob_close	function
(	O
synct_eof_buf	pointer
)	O
;	O
strob_close	function
(	O
synct_eof_buf2	pointer
)	O
;	O
strob_close	function
(	O
ubuf	pointer
)	O
;	O
strob_close	function
(	O
enddesc	pointer
)	O
;	O
return	O
0	int
;	O
}	O
SWICOL	struct
*	O
swicol_create	function
(	O
void	O
)	O
{	O
SWICOL	struct
*	O
swicol	pointer
;	O
swicol	pointer
=	O
(	O
SWICOL	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
SWICOL	struct
)	O
)	O
;	O
if	O
(	O
swicol	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
swicol	pointer
->	O
tmpM	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
swicol	pointer
->	O
scriptM	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
swicol	pointer
->	O
logspecM	pointer
=	O
(	O
struct	O
sw_logspec	struct
*	O
)	O
(	O
NULL	O
)	O
;	O
swicol	pointer
->	O
verbose_levelM	int
=	O
0	int
;	O
swicol	pointer
->	O
event_listM	pointer
=	O
strar_open	function
(	O
)	O
;	O
swicol	pointer
->	O
umaskM	pointer
=	O
NULL	O
;	O
swicol	pointer
->	O
blocksizeM	pointer
=	O
NULL	O
;	O
swicol	pointer
->	O
setvxM	pointer
=	O
NULL	O
;	O
swicol	pointer
->	O
delaytimeM	int
=	O
0	int
;	O
swicol	pointer
->	O
targetpathM	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
swicol	pointer
->	O
nhopsM	int
=	O
1	int
;	O
swicol	pointer
->	O
event_indexM	int
=	O
1	int
;	O
swicol	pointer
->	O
id_stringM	pointer
=	O
strob_open	function
(	O
24	int
)	O
;	O
swicol	pointer
->	O
debug_task_scriptsM	int
=	O
0	int
;	O
swicol	pointer
->	O
needs_synct_eoaM	int
=	O
0	int
;	O
init_magic_header	function
(	O
swicol	pointer
)	O
;	O
swicol_clear_master_alarm	function
(	O
swicol	pointer
)	O
;	O
swicol_set_event_fd	function
(	O
swicol	pointer
,	O
-	O
1	int
)	O
;	O
return	O
swicol	pointer
;	O
}	O
void	O
swicol_delete	function
(	O
SWICOL	struct
*	O
swicol	pointer
)	O
{	O
strob_close	function
(	O
swicol	pointer
->	O
tmpM	pointer
)	O
;	O
strob_close	function
(	O
swicol	pointer
->	O
scriptM	pointer
)	O
;	O
strob_close	function
(	O
swicol	pointer
->	O
id_stringM	pointer
)	O
;	O
free	function
(	O
swicol	pointer
)	O
;	O
}	O
void	O
swicol_set_event_fd	function
(	O
SWICOL	struct
*	O
swicol	pointer
,	O
int	O
fd	int
)	O
{	O
swicol	pointer
->	O
event_fdM	int
=	O
fd	int
;	O
}	O
void	O
swicol_set_delaytime	function
(	O
SWICOL	struct
*	O
swicol	pointer
,	O
int	O
delay	int
)	O
{	O
swicol	pointer
->	O
delaytimeM	int
=	O
delay	int
;	O
}	O
void	O
swicol_set_nhops	function
(	O
SWICOL	struct
*	O
swicol	pointer
,	O
int	O
nhops	int
)	O
{	O
swicol	pointer
->	O
nhopsM	int
=	O
nhops	int
;	O
}	O
void	O
swicol_set_verbose_level	function
(	O
SWICOL	struct
*	O
swicol	pointer
,	O
int	O
level	int
)	O
{	O
swicol	pointer
->	O
verbose_levelM	int
=	O
level	int
;	O
}	O
void	O
swicol_set_umask	function
(	O
SWICOL	struct
*	O
swicol	pointer
,	O
char	O
*	O
buf	pointer
)	O
{	O
set_buf	function
(	O
&	O
(	O
swicol	pointer
->	O
umaskM	pointer
)	O
,	O
buf	pointer
)	O
;	O
}	O
void	O
swicol_set_setvx	function
(	O
SWICOL	struct
*	O
swicol	pointer
,	O
char	O
*	O
buf	pointer
)	O
{	O
set_buf	function
(	O
&	O
(	O
swicol	pointer
->	O
setvxM	pointer
)	O
,	O
buf	pointer
)	O
;	O
}	O
void	O
swicol_set_targetpath	function
(	O
SWICOL	struct
*	O
swicol	pointer
,	O
char	O
*	O
buf	pointer
)	O
{	O
set_buf	function
(	O
&	O
(	O
swicol	pointer
->	O
targetpathM	pointer
)	O
,	O
buf	pointer
)	O
;	O
}	O
char	O
*	O
swicol_get_umask	function
(	O
SWICOL	struct
*	O
swicol	pointer
)	O
{	O
return	O
swicol	pointer
->	O
umaskM	pointer
;	O
}	O
char	O
*	O
swicol_get_setvxk	function
(	O
SWICOL	struct
*	O
swicol	pointer
)	O
{	O
return	O
swicol	pointer
->	O
setvxM	pointer
;	O
}	O
char	O
*	O
swicol_get_blocksize	function
(	O
SWICOL	struct
*	O
swicol	pointer
)	O
{	O
return	O
swicol	pointer
->	O
blocksizeM	pointer
;	O
}	O
int	O
swicol_rpsh_task_send_script2	function
(	O
SWICOL	struct
*	O
swicol	pointer
,	O
int	O
fd	int
,	O
uintmax_t	long
data_size	long
,	O
char	O
*	O
dir	pointer
,	O
char	O
*	O
script	pointer
,	O
char	O
*	O
f_desc	pointer
)	O
{	O
STROB	struct
*	O
tmp	pointer
;	O
int	O
ret	int
;	O
char	O
*	O
desc	int
;	O
desc	int
=	O
f_desc	pointer
;	O
if	O
(	O
swicol_get_master_alarm_status	function
(	O
swicol	pointer
)	O
==	O
SWICOL_ABORT_STEP_2	int
)	O
{	O
return	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
swicol_get_master_alarm_status	function
(	O
swicol	pointer
)	O
==	O
SWICOL_ABORT_STEP_1	int
)	O
{	O
swicol	pointer
->	O
master_alarmM	int
=	O
SWICOL_ABORT_STEP_2	int
;	O
desc	int
=	O
SWICOL_ALARM_EVENT	pointer
;	O
}	O
tmp	pointer
=	O
swicol	pointer
->	O
scriptM	pointer
;	O
strob_strcpy	function
(	O
tmp	pointer
,	O
""	pointer
)	O
;	O
strob_sprintf	function
(	O
tmp	pointer
,	O
1	int
,	O
"%s"	pointer
,	O
swicol	pointer
->	O
magic_headerM	pointer
)	O
;	O
strob_sprintf	function
(	O
tmp	pointer
,	O
1	int
,	O
"# SWI_TASK: %s\n"	pointer
,	O
desc	int
)	O
;	O
strob_sprintf	function
(	O
tmp	pointer
,	O
1	int
,	O
"\n"	pointer
)	O
;	O
ret	int
=	O
atomicio	function
(	O
(	O
ssize_t	long
(	O
*	O
)	O
(	O
int	O
,	O
void	O
*	O
,	O
size_t	long
)	O
)	O
write	pointer
,	O
fd	int
,	O
(	O
void	O
*	O
)	O
(	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
,	O
(	O
size_t	long
)	O
(	O
strob_strlen	function
(	O
tmp	pointer
)	O
)	O
)	O
;	O
if	O
(	O
ret	int
!=	O
(	O
int	O
)	O
strob_strlen	function
(	O
tmp	pointer
)	O
)	O
{	O
return	O
-	O
1	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swicol_set_task_idstring	function
(	O
swicol	pointer
,	O
f_desc	pointer
)	O
;	O
ret	int
=	O
swicol_rpsh_task_send_script	function
(	O
swicol	pointer
,	O
fd	int
,	O
data_size	long
,	O
dir	pointer
,	O
script	pointer
,	O
desc	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
swicol	pointer
->	O
debug_task_scriptsM	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swicol_write_debug_task_script	function
(	O
swicol	pointer
,	O
strob_str	function
(	O
swicol	pointer
->	O
scriptM	pointer
)	O
)	O
;	O
}	O
if	O
(	O
swicol	pointer
->	O
event_fdM	int
>=	O
0	int
)	O
swicol_rpsh_wait_304	function
(	O
swicol	pointer
,	O
swicol	pointer
->	O
event_fdM	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
swicol_get_master_alarm_status	function
(	O
swicol	pointer
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
ret	int
==	O
0	int
)	O
return	O
-	O
1	int
;	O
}	O
return	O
ret	int
;	O
}	O
int	O
swicol_rpsh_task_send_script	function
(	O
SWICOL	struct
*	O
swicol	pointer
,	O
int	O
fd	int
,	O
uintmax_t	long
data_size	long
,	O
char	O
*	O
dir	pointer
,	O
char	O
*	O
script	pointer
,	O
char	O
*	O
desc	int
)	O
{	O
int	O
ret	int
;	O
int	O
eret	int
;	O
STROB	struct
*	O
tmp	pointer
;	O
tmp	pointer
=	O
swicol	pointer
->	O
scriptM	pointer
;	O
strob_strcpy	function
(	O
tmp	pointer
,	O
""	pointer
)	O
;	O
if	O
(	O
data_size	long
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: Error: a non-zero length data payload is required.\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
}	O
if	O
(	O
print_task_script	function
(	O
swicol	pointer
,	O
tmp	pointer
,	O
data_size	long
,	O
dir	pointer
,	O
script	pointer
,	O
desc	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"swicol_rpsh_task_send_script: error forming task script\n"	pointer
)	O
;	O
return	O
-	O
2	int
;	O
}	O
E_DEBUG2	O
(	O
"\n<AA>\n%s</AA>\n"	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
ret	int
=	O
atomicio	function
(	O
(	O
ssize_t	long
(	O
*	O
)	O
(	O
int	O
,	O
void	O
*	O
,	O
size_t	long
)	O
)	O
write	pointer
,	O
fd	int
,	O
(	O
void	O
*	O
)	O
(	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
,	O
(	O
size_t	long
)	O
(	O
strob_strlen	function
(	O
tmp	pointer
)	O
)	O
)	O
;	O
eret	int
=	O
strob_strlen	function
(	O
tmp	pointer
)	O
;	O
if	O
(	O
ret	int
==	O
eret	int
)	O
{	O
return	O
0	int
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"rpsh_task_send_script: error writing task script to fd=%d: %s\n"	pointer
,	O
fd	int
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
int	O
swicol_rpsh_wait_cts	function
(	O
SWICOL	struct
*	O
swicol	pointer
,	O
int	O
event_fd	int
)	O
{	O
int	O
ret	int
=	O
0	int
;	O
int	O
first_current_event	int
;	O
STROB	struct
*	O
buf	pointer
;	O
char	O
*	O
stop_string	pointer
=	O
SWICOL_CTS_STRING	pointer
;	O
buf	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
ret	int
=	O
task_wait_for	function
(	O
swicol	pointer
,	O
buf	pointer
,	O
event_fd	int
,	O
SWICOL_TL_20	int
,	O
stop_string	pointer
)	O
;	O
first_current_event	int
=	O
convert_result_to_event_list	function
(	O
strob_str	function
(	O
buf	pointer
)	O
,	O
swicol	pointer
->	O
event_listM	pointer
)	O
;	O
swicol	pointer
->	O
event_indexM	int
=	O
first_current_event	int
;	O
strob_close	function
(	O
buf	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
swicol_rpsh_wait_304	function
(	O
SWICOL	struct
*	O
swicol	pointer
,	O
int	O
event_fd	int
)	O
{	O
int	O
ret	int
=	O
0	int
;	O
char	O
*	O
stop_string	pointer
=	O
SWICOL_START_STRING	pointer
;	O
ret	int
=	O
task_wait_for	function
(	O
swicol	pointer
,	O
(	O
STROB	struct
*	O
)	O
NULL	O
,	O
event_fd	int
,	O
SWICOL_TL_9	int
,	O
stop_string	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
swicol_rpsh_task_wait	function
(	O
SWICOL	struct
*	O
swicol	pointer
,	O
STROB	struct
*	O
retbuf	pointer
,	O
int	O
event_fd	int
,	O
int	O
timelimit	int
)	O
{	O
int	O
ret	int
=	O
0	int
;	O
char	O
*	O
stop_string	pointer
=	O
SWICOL_STOP_STRING	pointer
;	O
ret	int
=	O
task_wait_for	function
(	O
swicol	pointer
,	O
retbuf	pointer
,	O
event_fd	int
,	O
timelimit	int
,	O
stop_string	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
swicol_rpsh_wait_for_event	function
(	O
SWICOL	struct
*	O
swicol	pointer
,	O
STROB	struct
*	O
retbuf	pointer
,	O
int	O
event_fd	int
,	O
int	O
event	int
)	O
{	O
int	O
ret	int
;	O
STROB	struct
*	O
buf	pointer
;	O
buf	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
0	int
,	O
"%d:"	pointer
,	O
event	int
)	O
;	O
ret	int
=	O
task_wait_for	function
(	O
swicol	pointer
,	O
(	O
STROB	struct
*	O
)	O
NULL	O
,	O
event_fd	int
,	O
SWICOL_TL_10	int
,	O
strob_str	function
(	O
buf	pointer
)	O
)	O
;	O
strob_close	function
(	O
buf	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
char	O
*	O
swicol_rpsh_get_event_message	function
(	O
SWICOL	struct
*	O
swicol	pointer
,	O
int	O
event_value	int
,	O
int	O
first_current_event	int
,	O
int	O
*	O
p_index	pointer
)	O
{	O
char	O
*	O
retval	int
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
STROB	struct
*	O
tmp	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
STRAR	struct
*	O
event_list	pointer
;	O
char	O
*	O
s	pointer
;	O
int	O
ix	int
;	O
ix	int
=	O
set_selected_index	function
(	O
swicol	pointer
,	O
first_current_event	int
)	O
;	O
event_list	pointer
=	O
swicol	pointer
->	O
event_listM	pointer
;	O
strob_sprintf	function
(	O
tmp	pointer
,	O
0	int
,	O
"%d:"	pointer
,	O
event_value	int
)	O
;	O
E_DEBUG2	O
(	O
"event value=[%s]"	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
s	pointer
=	O
strar_get	function
(	O
event_list	pointer
,	O
ix	int
++	O
)	O
;	O
while	O
(	O
s	pointer
)	O
{	O
if	O
(	O
strstr	function
(	O
s	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
)	O
{	O
s	pointer
=	O
strchr	function
(	O
s	pointer
,	O
':'	O
)	O
;	O
if	O
(	O
!	O
s	pointer
)	O
return	O
NULL	O
;	O
s	pointer
++	O
;	O
retval	int
=	O
s	pointer
;	O
break	O
;	O
}	O
s	pointer
=	O
strar_get	function
(	O
event_list	pointer
,	O
ix	int
++	O
)	O
;	O
}	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
if	O
(	O
p_index	pointer
)	O
*	O
p_index	pointer
=	O
--	O
ix	int
;	O
E_DEBUG2	O
(	O
"returning message: <<<<<<<< [%s]"	pointer
,	O
retval	int
)	O
;	O
return	O
retval	int
;	O
}	O
int	O
swicol_rpsh_get_event_status	function
(	O
SWICOL	struct
*	O
swicol	pointer
,	O
char	O
*	O
msg	pointer
,	O
int	O
event_value	int
,	O
int	O
first_current_event	int
,	O
int	O
*	O
p_index	pointer
)	O
{	O
int	O
retval	int
;	O
int	O
atoi_ret	int
;	O
if	O
(	O
!	O
msg	pointer
)	O
msg	pointer
=	O
swicol_rpsh_get_event_message	function
(	O
swicol	pointer
,	O
event_value	int
,	O
first_current_event	int
,	O
p_index	pointer
)	O
;	O
if	O
(	O
!	O
msg	pointer
)	O
return	O
-	O
1	int
;	O
E_DEBUG2	O
(	O
"Message [%s]"	pointer
,	O
msg	pointer
)	O
;	O
if	O
(	O
isdigit	function
(	O
(	O
int	O
)	O
(	O
*	O
msg	pointer
)	O
)	O
)	O
{	O
retval	int
=	O
swlib_atoi	function
(	O
msg	pointer
,	O
&	O
atoi_ret	int
)	O
;	O
if	O
(	O
atoi_ret	int
)	O
{	O
retval	int
=	O
SW_INTERNAL_ERROR_127	O
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
msg	pointer
,	O
SWEVENT_STATUS_PFX	O
SWEVENT_VALUE_PREVIEW	pointer
)	O
==	O
0	int
)	O
{	O
retval	int
=	O
0	int
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: event %d did not return a valid status\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
event_value	int
)	O
;	O
retval	int
=	O
SW_INTERNAL_ERROR_128	O
;	O
}	O
return	O
retval	int
;	O
}	O
int	O
swicol_rpsh_task_expect	function
(	O
SWICOL	struct
*	O
swicol	pointer
,	O
int	O
event_fd	int
,	O
int	O
timelimit	int
)	O
{	O
char	O
*	O
ev	pointer
;	O
int	O
ret	int
;	O
int	O
retval	int
=	O
0	int
;	O
STROB	struct
*	O
buf	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
STRAR	struct
*	O
event_list	pointer
=	O
swicol	pointer
->	O
event_listM	pointer
;	O
int	O
first_current_event	int
;	O
swicol	pointer
->	O
event_indexM	int
=	O
-	O
1	int
;	O
ret	int
=	O
swicol_rpsh_task_wait	function
(	O
swicol	pointer
,	O
buf	pointer
,	O
event_fd	int
,	O
timelimit	int
)	O
;	O
if	O
(	O
ret	int
)	O
retval	int
=	O
-	O
4	int
;	O
E_DEBUG2	O
(	O
"expect buffer=[%s]"	pointer
,	O
strob_str	function
(	O
buf	pointer
)	O
)	O
;	O
if	O
(	O
(	O
ev	pointer
=	O
strstr	function
(	O
strob_str	function
(	O
buf	pointer
)	O
,	O
"305:"	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: error: END event not received for task: %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
strob_str	function
(	O
swicol	pointer
->	O
id_stringM	pointer
)	O
)	O
;	O
if	O
(	O
retval	int
==	O
0	int
)	O
retval	int
=	O
-	O
1	int
;	O
}	O
else	O
{	O
ev	pointer
+=	O
4	int
;	O
if	O
(	O
isdigit	function
(	O
(	O
int	O
)	O
(	O
*	O
ev	pointer
)	O
)	O
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: error: END event has invalid status: %s status=%s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
strob_str	function
(	O
swicol	pointer
->	O
id_stringM	pointer
)	O
,	O
strob_str	function
(	O
buf	pointer
)	O
)	O
;	O
retval	int
=	O
-	O
2	int
;	O
}	O
else	O
{	O
retval	int
=	O
swlib_atoi	function
(	O
ev	pointer
,	O
NULL	O
)	O
;	O
}	O
}	O
first_current_event	int
=	O
convert_result_to_event_list	function
(	O
strob_str	function
(	O
buf	pointer
)	O
,	O
event_list	pointer
)	O
;	O
if	O
(	O
swicol	pointer
->	O
verbose_levelM	int
>=	O
SWC_VERBOSE_8	int
)	O
{	O
swicol_show_events_to_fd	function
(	O
swicol	pointer
,	O
STDERR_FILENO	int
,	O
first_current_event	int
)	O
;	O
}	O
swicol	pointer
->	O
event_indexM	int
=	O
first_current_event	int
;	O
strob_close	function
(	O
buf	pointer
)	O
;	O
return	O
retval	int
;	O
}	O
int	O
swicol_show_events_to_fd	function
(	O
SWICOL	struct
*	O
swicol	pointer
,	O
int	O
fd	int
,	O
int	O
first_current_event	int
)	O
{	O
int	O
ret	int
;	O
size_t	long
len	int
;	O
int	O
ix	int
;	O
if	O
(	O
first_current_event	int
<	O
0	int
)	O
ix	int
=	O
swicol	pointer
->	O
event_indexM	int
;	O
else	O
ix	int
=	O
first_current_event	int
;	O
swicol_print_events	function
(	O
swicol	pointer
,	O
swicol	pointer
->	O
tmpM	pointer
,	O
ix	int
)	O
;	O
len	int
=	O
strob_strlen	function
(	O
swicol	pointer
->	O
tmpM	pointer
)	O
;	O
ret	int
=	O
atomicio	function
(	O
(	O
(	O
ssize_t	long
(	O
*	O
)	O
(	O
int	O
,	O
void	O
*	O
,	O
size_t	long
)	O
)	O
write	pointer
)	O
,	O
fd	int
,	O
(	O
void	O
*	O
)	O
(	O
strob_str	function
(	O
swicol	pointer
->	O
tmpM	pointer
)	O
)	O
,	O
len	int
)	O
;	O
return	O
!	O
(	O
ret	int
==	O
(	O
int	O
)	O
len	int
)	O
;	O
}	O
void	O
swicol_print_event	function
(	O
SWICOL	struct
*	O
swicol	pointer
,	O
STROB	struct
*	O
buf	pointer
,	O
char	O
*	O
ev	pointer
)	O
{	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
"%s: swicol: %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
ev	pointer
)	O
;	O
}	O
void	O
swicol_print_events	function
(	O
SWICOL	struct
*	O
swicol	pointer
,	O
STROB	struct
*	O
buf	pointer
,	O
int	O
index	function
)	O
{	O
char	O
*	O
ev	pointer
;	O
int	O
i	int
;	O
i	int
=	O
set_selected_index	function
(	O
swicol	pointer
,	O
index	function
)	O
;	O
strob_strcpy	function
(	O
buf	pointer
,	O
""	pointer
)	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
"%s: swicol: event stack start\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
while	O
(	O
(	O
ev	pointer
=	O
strar_get	function
(	O
swicol	pointer
->	O
event_listM	pointer
,	O
i	int
++	O
)	O
)	O
&&	O
(	O
1	int
)	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
ev	pointer
,	O
"\n"	pointer
)	O
==	O
0	int
)	O
{	O
swicol_print_event	function
(	O
swicol	pointer
,	O
buf	pointer
,	O
""	pointer
)	O
;	O
}	O
else	O
{	O
swicol_print_event	function
(	O
swicol	pointer
,	O
buf	pointer
,	O
ev	pointer
)	O
;	O
}	O
if	O
(	O
strcmp	function
(	O
ev	pointer
,	O
"\n"	pointer
)	O
==	O
0	int
&&	O
index	function
<	O
0	int
)	O
{	O
break	O
;	O
}	O
}	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
"%s: swicol: event stack end\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
}	O
char	O
*	O
swicol_subshell_marks	function
(	O
STROB	struct
*	O
subsh	pointer
,	O
char	O
*	O
type	enum
,	O
int	O
wh	int
,	O
int	O
nhops	int
,	O
int	O
verbose_level	int
)	O
{	O
return	O
subshell_marks	function
(	O
subsh	pointer
,	O
type	enum
,	O
wh	int
,	O
nhops	int
,	O
verbose_level	int
,	O
"(\x00)"	pointer
)	O
;	O
}	O
char	O
*	O
swicol_brace_marks	function
(	O
STROB	struct
*	O
subsh	pointer
,	O
char	O
*	O
type	enum
,	O
int	O
wh	int
,	O
int	O
nhops	int
,	O
int	O
verbose_level	int
)	O
{	O
return	O
subshell_marks	function
(	O
subsh	pointer
,	O
type	enum
,	O
wh	int
,	O
nhops	int
,	O
verbose_level	int
,	O
"{\x00}"	pointer
)	O
;	O
}	O
int	O
swicol_initiate_fall_thru	function
(	O
SWICOL	struct
*	O
swicol	pointer
)	O
{	O
return	O
0	int
;	O
}	O
void	O
swicol_clear_task_idstring	function
(	O
SWICOL	struct
*	O
swicol	pointer
)	O
{	O
swicol_set_task_idstring	function
(	O
swicol	pointer
,	O
"__unset__"	pointer
)	O
;	O
}	O
void	O
swicol_set_task_debug	function
(	O
SWICOL	struct
*	O
swicol	pointer
,	O
int	O
do_debug	int
)	O
{	O
swicol	pointer
->	O
debug_task_scriptsM	int
=	O
do_debug	int
;	O
}	O
void	O
swicol_set_task_idstring	function
(	O
SWICOL	struct
*	O
swicol	pointer
,	O
char	O
*	O
id	pointer
)	O
{	O
strob_strcpy	function
(	O
swicol	pointer
->	O
id_stringM	pointer
,	O
id	pointer
)	O
;	O
}	O
char	O
*	O
swicol_get_task_idstring	function
(	O
SWICOL	struct
*	O
swicol	pointer
)	O
{	O
return	O
strob_str	function
(	O
swicol	pointer
->	O
id_stringM	pointer
)	O
;	O
}	O
void	O
swicol_write_debug_task_script	function
(	O
SWICOL	struct
*	O
swicol	pointer
,	O
char	O
*	O
script	pointer
)	O
{	O
int	O
ret	int
;	O
STROB	struct
*	O
name	pointer
;	O
name	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
strob_strcpy	function
(	O
name	pointer
,	O
SWICOL_DEBUG_TASK_SCRIPT_PREFIX	pointer
)	O
;	O
strob_strcat	function
(	O
name	pointer
,	O
strob_str	function
(	O
swicol	pointer
->	O
id_stringM	pointer
)	O
)	O
;	O
form_debug_task_filename	function
(	O
strob_str	function
(	O
name	pointer
)	O
)	O
;	O
ret	int
=	O
swlib_tee_to_file	function
(	O
strob_str	function
(	O
name	pointer
)	O
,	O
-	O
1	int
,	O
script	pointer
,	O
-	O
1	int
,	O
0	int
)	O
;	O
E_DEBUG3	O
(	O
"name=[%s] ret=%d"	pointer
,	O
strob_str	function
(	O
name	pointer
)	O
,	O
ret	int
)	O
;	O
strob_close	function
(	O
name	pointer
)	O
;	O
}	O
void	O
swicol_set_master_alarm	function
(	O
SWICOL	struct
*	O
swicol	pointer
)	O
{	O
swicol	pointer
->	O
master_alarmM	int
=	O
SWICOL_ABORT_STEP_1	int
;	O
}	O
void	O
swicol_clear_master_alarm	function
(	O
SWICOL	struct
*	O
swicol	pointer
)	O
{	O
swicol	pointer
->	O
master_alarmM	int
=	O
0	int
;	O
}	O
int	O
swicol_get_master_alarm_status	function
(	O
SWICOL	struct
*	O
swicol	pointer
)	O
{	O
return	O
swicol	pointer
->	O
master_alarmM	int
;	O
}	O
int	O
swicol_send_loop_trailer	function
(	O
SWICOL	struct
*	O
swicol	pointer
,	O
int	O
fd	int
)	O
{	O
int	O
ret	int
;	O
char	O
*	O
send	pointer
=	O
SWICOL_TRAILER	O
"\n"	pointer
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	int
=	O
atomicio	function
(	O
(	O
ssize_t	long
(	O
*	O
)	O
(	O
int	O
,	O
void	O
*	O
,	O
size_t	long
)	O
)	O
write	pointer
,	O
fd	int
,	O
send	pointer
,	O
strlen	function
(	O
send	pointer
)	O
)	O
;	O
if	O
(	O
ret	int
==	O
(	O
int	O
)	O
strlen	function
(	O
send	pointer
)	O
)	O
{	O
E_DEBUG	O
(	O
"OK"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
"error"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
