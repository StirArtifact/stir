typedef	O
struct	O
{	O
TEXT	struct
space	long
;	O
TEXT	struct
word	long
;	O
int	O
invisible_pending_word	int
;	O
int	O
space_counter	int
;	O
int	O
word_counter	int
;	O
int	O
end_sentence	int
;	O
int	O
max	int
;	O
int	O
indent_length	int
;	O
int	O
indent_length_next	int
;	O
int	O
counter	int
;	O
int	O
lines_counter	int
;	O
int	O
end_line_count	int
;	O
wint_t	int
last_letter	int
;	O
int	O
protect_spaces	int
;	O
int	O
ignore_columns	int
;	O
int	O
keep_end_lines	int
;	O
int	O
french_spacing	int
;	O
int	O
double_width_no_break	int
;	O
int	O
unfilled	int
;	O
int	O
no_final_newline	int
;	O
int	O
add_final_space	int
;	O
int	O
in_use	int
;	O
}	O
PARAGRAPH	struct
;	O
static	O
PARAGRAPH	struct
state	pointer
;	O
int	O
xspara_init	function
(	O
int	O
unused	int
,	O
char	O
*	O
unused2	pointer
)	O
{	O
char	O
*	O
utf8_locale	pointer
=	O
0	int
;	O
int	O
len	long
;	O
char	O
*	O
cur	long
;	O
char	O
*	O
dot	pointer
;	O
dTHX	O
;	O
switch_to_global_locale	O
(	O
)	O
;	O
if	O
(	O
setlocale	function
(	O
LC_CTYPE	O
,	O
"en_US.UTF-8"	pointer
)	O
||	O
setlocale	function
(	O
LC_CTYPE	O
,	O
"en_US.utf8"	pointer
)	O
)	O
goto	O
success	O
;	O
cur	long
=	O
setlocale	function
(	O
LC_CTYPE	O
,	O
0	int
)	O
;	O
if	O
(	O
!	O
cur	long
)	O
goto	O
failure	O
;	O
len	long
=	O
strlen	function
(	O
cur	long
)	O
;	O
if	O
(	O
len	long
>=	O
6	int
&&	O
!	O
memcmp	function
(	O
".UTF-8"	pointer
,	O
cur	long
+	O
len	long
-	O
6	int
,	O
6	int
)	O
||	O
len	long
>=	O
5	int
&&	O
!	O
memcmp	function
(	O
".utf8"	pointer
,	O
cur	long
+	O
len	long
-	O
5	int
,	O
5	int
)	O
||	O
len	long
>=	O
6	int
&&	O
!	O
memcmp	function
(	O
".utf-8"	pointer
,	O
cur	long
+	O
len	long
-	O
6	int
,	O
6	int
)	O
||	O
len	long
>=	O
5	int
&&	O
!	O
memcmp	function
(	O
".UTF8"	pointer
,	O
cur	long
+	O
len	long
-	O
5	int
,	O
5	int
)	O
)	O
{	O
setlocale	function
(	O
LC_CTYPE	O
,	O
""	pointer
)	O
;	O
goto	O
success	O
;	O
}	O
dot	pointer
=	O
strchr	function
(	O
cur	long
,	O
'.'	O
)	O
;	O
if	O
(	O
!	O
dot	pointer
)	O
dot	pointer
=	O
cur	long
+	O
len	long
;	O
utf8_locale	pointer
=	O
malloc	function
(	O
len	long
+	O
6	int
+	O
1	int
)	O
;	O
memcpy	function
(	O
utf8_locale	pointer
,	O
cur	long
,	O
dot	pointer
-	O
cur	long
)	O
;	O
dot	pointer
=	O
utf8_locale	pointer
+	O
(	O
dot	pointer
-	O
cur	long
)	O
;	O
memcpy	function
(	O
dot	pointer
,	O
".UTF-8"	pointer
,	O
7	int
)	O
;	O
if	O
(	O
setlocale	function
(	O
LC_CTYPE	O
,	O
utf8_locale	pointer
)	O
)	O
goto	O
success	O
;	O
memcpy	function
(	O
dot	pointer
,	O
".utf8"	pointer
,	O
6	int
)	O
;	O
if	O
(	O
setlocale	function
(	O
LC_CTYPE	O
,	O
utf8_locale	pointer
)	O
)	O
goto	O
success	O
;	O
{	O
FILE	struct
*	O
p	pointer
;	O
char	O
*	O
line	int
=	O
0	int
;	O
size_t	long
n	int
=	O
0	int
;	O
ssize_t	long
ret	long
;	O
p	pointer
=	O
popen	function
(	O
"locale -a"	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
goto	O
failure	O
;	O
while	O
(	O
1	int
)	O
{	O
ret	long
=	O
getline	function
(	O
&	O
line	int
,	O
&	O
n	int
,	O
p	pointer
)	O
;	O
if	O
(	O
ret	long
==	O
(	O
ssize_t	long
)	O
-	O
1	int
)	O
{	O
free	function
(	O
line	int
)	O
;	O
pclose	function
(	O
p	pointer
)	O
;	O
goto	O
failure	O
;	O
}	O
if	O
(	O
strstr	function
(	O
line	int
,	O
"UTF-8"	pointer
)	O
||	O
strstr	function
(	O
line	int
,	O
"utf8"	pointer
)	O
)	O
{	O
line	int
[	O
ret	long
-	O
1	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
setlocale	function
(	O
LC_CTYPE	O
,	O
line	int
)	O
)	O
{	O
free	function
(	O
line	int
)	O
;	O
pclose	function
(	O
p	pointer
)	O
;	O
goto	O
success	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
1	int
)	O
{	O
failure	O
:	O
return	O
0	int
;	O
}	O
else	O
{	O
success	O
:	O
;	O
free	function
(	O
utf8_locale	pointer
)	O
;	O
sync_locale	O
(	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
static	O
PARAGRAPH	struct
*	O
state_array	pointer
;	O
static	O
int	O
state_array_size	int
;	O
static	O
int	O
current_state	int
;	O
static	O
void	O
xspara__switch_state	function
(	O
int	O
id	int
)	O
{	O
if	O
(	O
current_state	int
==	O
id	int
)	O
return	O
;	O
if	O
(	O
current_state	int
!=	O
-	O
1	int
)	O
memcpy	function
(	O
&	O
state_array	pointer
[	O
current_state	int
]	O
,	O
&	O
state	pointer
,	O
sizeof	O
(	O
PARAGRAPH	struct
)	O
)	O
;	O
memcpy	function
(	O
&	O
state	pointer
,	O
&	O
state_array	pointer
[	O
id	int
]	O
,	O
sizeof	O
(	O
PARAGRAPH	struct
)	O
)	O
;	O
current_state	int
=	O
id	int
;	O
}	O
int	O
xspara_new	function
(	O
HV	struct
*	O
conf	pointer
)	O
{	O
int	O
i	int
;	O
dTHX	O
;	O
TEXT	struct
saved_space	struct
,	O
saved_word	struct
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
state_array_size	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
!	O
state_array	pointer
[	O
i	int
]	O
.	O
in_use	int
)	O
break	O
;	O
}	O
if	O
(	O
i	int
==	O
state_array_size	int
)	O
{	O
state_array	pointer
=	O
realloc	function
(	O
state_array	pointer
,	O
(	O
state_array_size	int
+=	O
10	int
)	O
*	O
sizeof	O
(	O
PARAGRAPH	struct
)	O
)	O
;	O
memset	function
(	O
state_array	pointer
+	O
i	int
,	O
0	int
,	O
10	int
*	O
sizeof	O
(	O
PARAGRAPH	struct
)	O
)	O
;	O
}	O
state_array	pointer
[	O
i	int
]	O
.	O
in_use	int
=	O
1	int
;	O
xspara__switch_state	function
(	O
i	int
)	O
;	O
saved_space	struct
=	O
state	pointer
.	O
space	long
;	O
saved_word	struct
=	O
state	pointer
.	O
word	long
;	O
memset	function
(	O
&	O
state	pointer
,	O
0	int
,	O
sizeof	O
(	O
state	pointer
)	O
)	O
;	O
state	pointer
.	O
space	long
=	O
saved_space	struct
;	O
state	pointer
.	O
word	long
=	O
saved_word	struct
;	O
state	pointer
.	O
space	long
.	O
end	long
=	O
state	pointer
.	O
word	long
.	O
end	long
=	O
0	int
;	O
state	pointer
.	O
in_use	int
=	O
1	int
;	O
state	pointer
.	O
max	int
=	O
72	int
;	O
state	pointer
.	O
indent_length_next	int
=	O
-	O
1	int
;	O
state	pointer
.	O
end_sentence	int
=	O
-	O
2	int
;	O
state	pointer
.	O
last_letter	int
=	O
L'\0'	O
;	O
if	O
(	O
conf	pointer
)	O
xspara_init_state	function
(	O
conf	pointer
)	O
;	O
return	O
i	int
;	O
}	O
void	O
xspara_set_state	function
(	O
SV	struct
*	O
sv	struct
)	O
{	O
dTHX	O
;	O
xspara__switch_state	function
(	O
SvIV	O
(	O
sv	struct
)	O
)	O
;	O
}	O
void	O
xspara_init_state	function
(	O
HV	struct
*	O
hash	int
)	O
{	O
SV	struct
*	O
*	O
val	array
;	O
dTHX	O
;	O
FETCH_INT	O
(	O
"end_sentence"	pointer
,	O
state	pointer
.	O
end_sentence	int
)	O
;	O
FETCH_INT	O
(	O
"max"	pointer
,	O
state	pointer
.	O
max	int
)	O
;	O
FETCH_INT	O
(	O
"indent_length"	pointer
,	O
state	pointer
.	O
indent_length	int
)	O
;	O
FETCH_INT	O
(	O
"indent_length_next"	pointer
,	O
state	pointer
.	O
indent_length_next	int
)	O
;	O
FETCH_INT	O
(	O
"counter"	pointer
,	O
state	pointer
.	O
counter	int
)	O
;	O
FETCH_INT	O
(	O
"word_counter"	pointer
,	O
state	pointer
.	O
word_counter	int
)	O
;	O
FETCH_INT	O
(	O
"lines_counter"	pointer
,	O
state	pointer
.	O
lines_counter	int
)	O
;	O
FETCH_INT	O
(	O
"end_line_count"	pointer
,	O
state	pointer
.	O
end_line_count	int
)	O
;	O
FETCH_INT	O
(	O
"protect_spaces"	pointer
,	O
state	pointer
.	O
protect_spaces	int
)	O
;	O
FETCH_INT	O
(	O
"ignore_columns"	pointer
,	O
state	pointer
.	O
ignore_columns	int
)	O
;	O
FETCH_INT	O
(	O
"keep_end_lines"	pointer
,	O
state	pointer
.	O
keep_end_lines	int
)	O
;	O
FETCH_INT	O
(	O
"frenchspacing"	pointer
,	O
state	pointer
.	O
french_spacing	int
)	O
;	O
FETCH_INT	O
(	O
"unfilled"	pointer
,	O
state	pointer
.	O
unfilled	int
)	O
;	O
FETCH_INT	O
(	O
"no_final_newline"	pointer
,	O
state	pointer
.	O
no_final_newline	int
)	O
;	O
FETCH_INT	O
(	O
"add_final_space"	pointer
,	O
state	pointer
.	O
add_final_space	int
)	O
;	O
val	array
=	O
FETCH	O
(	O
"word"	pointer
)	O
;	O
if	O
(	O
val	array
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Bug: setting 'word' is not supported.\n"	pointer
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
val	array
=	O
FETCH	O
(	O
"space"	pointer
)	O
;	O
if	O
(	O
val	array
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Bug: setting 'space' is not supported.\n"	pointer
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
return	O
;	O
}	O
void	O
xspara_get_state	function
(	O
HV	struct
*	O
hash	int
)	O
{	O
SV	struct
*	O
val	array
;	O
return	O
;	O
dTHX	O
;	O
val	array
=	O
newSViv	O
(	O
state	pointer
.	O
end_sentence	int
)	O
;	O
STORE	O
(	O
"end_sentence"	pointer
)	O
;	O
val	array
=	O
newSViv	O
(	O
state	pointer
.	O
counter	int
)	O
;	O
STORE	O
(	O
"counter"	pointer
)	O
;	O
val	array
=	O
newSViv	O
(	O
state	pointer
.	O
word_counter	int
)	O
;	O
STORE	O
(	O
"word_counter"	pointer
)	O
;	O
val	array
=	O
newSViv	O
(	O
state	pointer
.	O
lines_counter	int
)	O
;	O
STORE	O
(	O
"lines_counter"	pointer
)	O
;	O
return	O
;	O
}	O
void	O
xspara__cut_line	function
(	O
TEXT	struct
*	O
result	pointer
)	O
{	O
if	O
(	O
!	O
state	pointer
.	O
ignore_columns	int
)	O
{	O
xspara__end_line	function
(	O
)	O
;	O
text_append	function
(	O
result	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
}	O
int	O
xspara_end_line_count	function
(	O
void	O
)	O
{	O
return	O
state	pointer
.	O
end_line_count	int
;	O
}	O
void	O
xspara__end_line	function
(	O
void	O
)	O
{	O
state	pointer
.	O
counter	int
=	O
0	int
;	O
state	pointer
.	O
space	long
.	O
end	long
=	O
0	int
;	O
state	pointer
.	O
space_counter	int
=	O
0	int
;	O
if	O
(	O
state	pointer
.	O
indent_length_next	int
!=	O
-	O
1	int
)	O
{	O
state	pointer
.	O
indent_length	int
=	O
state	pointer
.	O
indent_length_next	int
;	O
state	pointer
.	O
indent_length_next	int
=	O
-	O
1	int
;	O
}	O
state	pointer
.	O
lines_counter	int
++	O
;	O
state	pointer
.	O
end_line_count	int
++	O
;	O
}	O
char	O
*	O
xspara_end_line	function
(	O
void	O
)	O
{	O
state	pointer
.	O
end_line_count	int
=	O
0	int
;	O
xspara__end_line	function
(	O
)	O
;	O
return	O
"\n"	pointer
;	O
}	O
char	O
*	O
xspara_get_pending	function
(	O
void	O
)	O
{	O
static	O
TEXT	struct
t	pointer
;	O
text_reset	function
(	O
&	O
t	pointer
)	O
;	O
text_append_n	function
(	O
&	O
t	pointer
,	O
state	pointer
.	O
space	long
.	O
text	pointer
,	O
state	pointer
.	O
space	long
.	O
end	long
)	O
;	O
text_append_n	function
(	O
&	O
t	pointer
,	O
state	pointer
.	O
word	long
.	O
text	pointer
,	O
state	pointer
.	O
word	long
.	O
end	long
)	O
;	O
return	O
t	pointer
.	O
text	pointer
;	O
}	O
void	O
xspara__add_pending_word	function
(	O
TEXT	struct
*	O
result	pointer
,	O
int	O
add_spaces	int
)	O
{	O
if	O
(	O
state	pointer
.	O
word	long
.	O
end	long
==	O
0	int
&&	O
!	O
state	pointer
.	O
invisible_pending_word	int
&&	O
!	O
add_spaces	int
)	O
return	O
;	O
if	O
(	O
state	pointer
.	O
indent_length	int
>	O
state	pointer
.	O
counter	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
state	pointer
.	O
indent_length	int
-	O
state	pointer
.	O
counter	int
;	O
i	int
++	O
)	O
text_append	function
(	O
result	pointer
,	O
" "	pointer
)	O
;	O
state	pointer
.	O
counter	int
=	O
state	pointer
.	O
indent_length	int
;	O
if	O
(	O
!	O
state	pointer
.	O
unfilled	int
)	O
state	pointer
.	O
space	long
.	O
end	long
=	O
0	int
;	O
}	O
if	O
(	O
state	pointer
.	O
space	long
.	O
end	long
>	O
0	int
)	O
{	O
text_append_n	function
(	O
result	pointer
,	O
state	pointer
.	O
space	long
.	O
text	pointer
,	O
state	pointer
.	O
space	long
.	O
end	long
)	O
;	O
state	pointer
.	O
counter	int
+=	O
state	pointer
.	O
space_counter	int
;	O
state	pointer
.	O
space	long
.	O
end	long
=	O
0	int
;	O
state	pointer
.	O
space_counter	int
=	O
0	int
;	O
}	O
if	O
(	O
state	pointer
.	O
word	long
.	O
end	long
>	O
0	int
||	O
state	pointer
.	O
invisible_pending_word	int
)	O
{	O
text_append_n	function
(	O
result	pointer
,	O
state	pointer
.	O
word	long
.	O
text	pointer
,	O
state	pointer
.	O
word	long
.	O
end	long
)	O
;	O
state	pointer
.	O
counter	int
+=	O
state	pointer
.	O
word_counter	int
;	O
state	pointer
.	O
word	long
.	O
end	long
=	O
0	int
;	O
state	pointer
.	O
word_counter	int
=	O
0	int
;	O
state	pointer
.	O
invisible_pending_word	int
=	O
0	int
;	O
}	O
}	O
char	O
*	O
xspara_add_pending_word	function
(	O
int	O
add_spaces	int
)	O
{	O
static	O
TEXT	struct
ret	long
;	O
text_reset	function
(	O
&	O
ret	long
)	O
;	O
state	pointer
.	O
end_line_count	int
=	O
0	int
;	O
xspara__add_pending_word	function
(	O
&	O
ret	long
,	O
add_spaces	int
)	O
;	O
if	O
(	O
ret	long
.	O
text	pointer
)	O
return	O
ret	long
.	O
text	pointer
;	O
else	O
return	O
""	pointer
;	O
}	O
char	O
*	O
xspara_end	function
(	O
void	O
)	O
{	O
static	O
TEXT	struct
ret	long
;	O
text_reset	function
(	O
&	O
ret	long
)	O
;	O
state	pointer
.	O
end_line_count	int
=	O
0	int
;	O
xspara__add_pending_word	function
(	O
&	O
ret	long
,	O
state	pointer
.	O
add_final_space	int
)	O
;	O
if	O
(	O
!	O
state	pointer
.	O
no_final_newline	int
&&	O
state	pointer
.	O
counter	int
!=	O
0	int
)	O
{	O
text_append	function
(	O
&	O
ret	long
,	O
"\n"	pointer
)	O
;	O
state	pointer
.	O
lines_counter	int
++	O
;	O
state	pointer
.	O
end_line_count	int
++	O
;	O
}	O
state_array	pointer
[	O
current_state	int
]	O
.	O
in_use	int
=	O
0	int
;	O
state	pointer
.	O
in_use	int
=	O
0	int
;	O
if	O
(	O
ret	long
.	O
text	pointer
)	O
return	O
ret	long
.	O
text	pointer
;	O
else	O
return	O
""	pointer
;	O
}	O
void	O
xspara__add_next	function
(	O
TEXT	struct
*	O
result	pointer
,	O
char	O
*	O
word	long
,	O
int	O
word_len	int
,	O
int	O
transparent	int
)	O
{	O
int	O
disinhibit	int
=	O
0	int
;	O
if	O
(	O
!	O
word	long
)	O
return	O
;	O
if	O
(	O
word_len	int
>=	O
1	int
&&	O
word	long
[	O
word_len	int
-	O
1	int
]	O
==	O
'\b'	O
)	O
{	O
word	long
[	O
--	O
word_len	int
]	O
=	O
'\0'	O
;	O
disinhibit	int
=	O
1	int
;	O
}	O
if	O
(	O
state	pointer
.	O
word	long
.	O
end	long
==	O
0	int
&&	O
!	O
state	pointer
.	O
invisible_pending_word	int
)	O
{	O
state	pointer
.	O
last_letter	int
=	O
L'\0'	O
;	O
if	O
(	O
state	pointer
.	O
counter	int
!=	O
0	int
&&	O
state	pointer
.	O
space	long
.	O
end	long
>	O
0	int
&&	O
state	pointer
.	O
end_sentence	int
==	O
1	int
&&	O
!	O
state	pointer
.	O
french_spacing	int
)	O
{	O
wchar_t	int
wc	int
;	O
size_t	long
char_len	long
;	O
char_len	long
=	O
mbrtowc	function
(	O
&	O
wc	int
,	O
word	long
,	O
word_len	int
,	O
NULL	O
)	O
;	O
if	O
(	O
(	O
long	O
)	O
char_len	long
>	O
0	int
&&	O
!	O
iswspace	function
(	O
wc	int
)	O
)	O
{	O
while	O
(	O
state	pointer
.	O
space_counter	int
<	O
2	int
)	O
{	O
text_append_n	function
(	O
&	O
state	pointer
.	O
space	long
,	O
" "	pointer
,	O
1	int
)	O
;	O
state	pointer
.	O
space_counter	int
++	O
;	O
}	O
}	O
state	pointer
.	O
end_sentence	int
=	O
-	O
2	int
;	O
}	O
}	O
text_append_n	function
(	O
&	O
state	pointer
.	O
word	long
,	O
word	long
,	O
word_len	int
)	O
;	O
if	O
(	O
word_len	int
==	O
0	int
&&	O
word	long
)	O
state	pointer
.	O
invisible_pending_word	int
=	O
1	int
;	O
if	O
(	O
!	O
transparent	int
)	O
{	O
if	O
(	O
disinhibit	int
)	O
state	pointer
.	O
last_letter	int
=	O
L'a'	O
;	O
else	O
{	O
char	O
*	O
p	pointer
=	O
word	long
+	O
word_len	int
;	O
int	O
len	long
=	O
0	int
;	O
while	O
(	O
p	pointer
>	O
word	long
)	O
{	O
p	pointer
--	O
;	O
len	long
++	O
;	O
if	O
(	O
(	O
long	O
)	O
mbrlen	function
(	O
p	pointer
,	O
len	long
,	O
NULL	O
)	O
>	O
0	int
)	O
{	O
wchar_t	int
wc	int
=	O
L'\0'	O
;	O
mbrtowc	function
(	O
&	O
wc	int
,	O
p	pointer
,	O
len	long
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
wcschr	function
(	O
L".?!\"')]"	O
,	O
wc	int
)	O
)	O
{	O
state	pointer
.	O
last_letter	int
=	O
wc	int
;	O
break	O
;	O
}	O
}	O
}	O
}	O
}	O
if	O
(	O
strchr	function
(	O
word	long
,	O
'\n'	O
)	O
)	O
{	O
xspara__add_pending_word	function
(	O
result	pointer
,	O
0	int
)	O
;	O
xspara__end_line	function
(	O
)	O
;	O
}	O
else	O
{	O
int	O
len	long
=	O
0	int
;	O
int	O
left	int
=	O
word_len	int
;	O
wchar_t	int
w	int
;	O
char	O
*	O
p	pointer
=	O
word	long
;	O
while	O
(	O
left	int
>	O
0	int
)	O
{	O
int	O
char_len	long
=	O
mbrtowc	function
(	O
&	O
w	int
,	O
p	pointer
,	O
left	int
,	O
NULL	O
)	O
;	O
left	int
-=	O
char_len	long
;	O
p	pointer
+=	O
char_len	long
;	O
len	long
++	O
;	O
}	O
state	pointer
.	O
word_counter	int
+=	O
len	long
;	O
}	O
if	O
(	O
state	pointer
.	O
counter	int
!=	O
0	int
&&	O
state	pointer
.	O
counter	int
+	O
state	pointer
.	O
word_counter	int
+	O
state	pointer
.	O
space_counter	int
>	O
state	pointer
.	O
max	int
)	O
{	O
xspara__cut_line	function
(	O
result	pointer
)	O
;	O
}	O
}	O
char	O
*	O
xspara_add_next	function
(	O
char	O
*	O
text	pointer
,	O
int	O
text_len	int
,	O
int	O
transparent	int
)	O
{	O
static	O
TEXT	struct
t	pointer
;	O
text_reset	function
(	O
&	O
t	pointer
)	O
;	O
state	pointer
.	O
end_line_count	int
=	O
0	int
;	O
xspara__add_next	function
(	O
&	O
t	pointer
,	O
text	pointer
,	O
text_len	int
,	O
transparent	int
)	O
;	O
if	O
(	O
t	pointer
.	O
space	long
>	O
0	int
)	O
return	O
t	pointer
.	O
text	pointer
;	O
else	O
return	O
""	pointer
;	O
}	O
void	O
xspara_remove_end_sentence	function
(	O
void	O
)	O
{	O
state	pointer
.	O
end_sentence	int
=	O
0	int
;	O
}	O
void	O
xspara_add_end_sentence	function
(	O
int	O
value	pointer
)	O
{	O
state	pointer
.	O
end_sentence	int
=	O
value	pointer
;	O
}	O
void	O
xspara_allow_end_sentence	function
(	O
void	O
)	O
{	O
state	pointer
.	O
last_letter	int
=	O
L'a'	O
;	O
}	O
char	O
*	O
xspara_set_space_protection	function
(	O
int	O
protect_spaces	int
,	O
int	O
ignore_columns	int
,	O
int	O
keep_end_lines	int
,	O
int	O
french_spacing	int
,	O
int	O
double_width_no_break	int
)	O
{	O
if	O
(	O
protect_spaces	int
!=	O
-	O
1	int
)	O
state	pointer
.	O
protect_spaces	int
=	O
protect_spaces	int
;	O
if	O
(	O
ignore_columns	int
!=	O
-	O
1	int
)	O
state	pointer
.	O
ignore_columns	int
=	O
ignore_columns	int
;	O
if	O
(	O
keep_end_lines	int
!=	O
-	O
1	int
)	O
state	pointer
.	O
keep_end_lines	int
=	O
keep_end_lines	int
;	O
if	O
(	O
double_width_no_break	int
!=	O
-	O
1	int
)	O
state	pointer
.	O
double_width_no_break	int
=	O
double_width_no_break	int
;	O
if	O
(	O
state	pointer
.	O
french_spacing	int
==	O
0	int
&&	O
french_spacing	int
!=	O
-	O
1	int
&&	O
french_spacing	int
!=	O
0	int
&&	O
state	pointer
.	O
end_sentence	int
!=	O
-	O
2	int
&&	O
state	pointer
.	O
end_sentence	int
!=	O
0	int
&&	O
state	pointer
.	O
counter	int
!=	O
0	int
&&	O
state	pointer
.	O
space	long
.	O
end	long
>	O
0	int
&&	O
state	pointer
.	O
word	long
.	O
end	long
==	O
0	int
&&	O
!	O
state	pointer
.	O
invisible_pending_word	int
)	O
{	O
while	O
(	O
state	pointer
.	O
space_counter	int
<	O
2	int
)	O
{	O
text_append_n	function
(	O
&	O
state	pointer
.	O
space	long
,	O
" "	pointer
,	O
1	int
)	O
;	O
state	pointer
.	O
space_counter	int
++	O
;	O
}	O
state	pointer
.	O
end_sentence	int
=	O
-	O
2	int
;	O
}	O
if	O
(	O
french_spacing	int
!=	O
-	O
1	int
)	O
{	O
state	pointer
.	O
french_spacing	int
=	O
french_spacing	int
;	O
}	O
if	O
(	O
protect_spaces	int
!=	O
-	O
1	int
&&	O
state	pointer
.	O
protect_spaces	int
)	O
{	O
if	O
(	O
state	pointer
.	O
word	long
.	O
end	long
==	O
0	int
)	O
{	O
state	pointer
.	O
invisible_pending_word	int
=	O
1	int
;	O
}	O
}	O
return	O
""	pointer
;	O
}	O
char	O
*	O
xspara_add_text	function
(	O
char	O
*	O
text	pointer
)	O
{	O
char	O
*	O
p	pointer
=	O
text	pointer
;	O
int	O
len	long
;	O
wchar_t	int
wc	int
;	O
size_t	long
char_len	long
;	O
static	O
TEXT	struct
result	pointer
;	O
dTHX	O
;	O
text_reset	function
(	O
&	O
result	pointer
)	O
;	O
len	long
=	O
strlen	function
(	O
text	pointer
)	O
;	O
state	pointer
.	O
end_line_count	int
=	O
0	int
;	O
while	O
(	O
len	long
>	O
0	int
)	O
{	O
char_len	long
=	O
mbrtowc	function
(	O
&	O
wc	int
,	O
p	pointer
,	O
len	long
,	O
NULL	O
)	O
;	O
if	O
(	O
(	O
long	O
)	O
char_len	long
==	O
0	int
)	O
break	O
;	O
else	O
if	O
(	O
(	O
long	O
)	O
char_len	long
<	O
0	int
)	O
{	O
p	pointer
++	O
;	O
len	long
--	O
;	O
continue	O
;	O
}	O
if	O
(	O
iswspace	function
(	O
wc	int
)	O
&&	O
wc	int
!=	O
L'\x00a0'	O
&&	O
wc	int
!=	O
L'\x202f'	O
)	O
{	O
state	pointer
.	O
last_letter	int
=	O
L'\0'	O
;	O
if	O
(	O
state	pointer
.	O
protect_spaces	int
)	O
{	O
text_append_n	function
(	O
&	O
state	pointer
.	O
word	long
,	O
p	pointer
,	O
char_len	long
)	O
;	O
state	pointer
.	O
word_counter	int
++	O
;	O
if	O
(	O
strchr	function
(	O
state	pointer
.	O
word	long
.	O
text	pointer
,	O
'\n'	O
)	O
)	O
{	O
char	O
*	O
ptr	pointer
=	O
state	pointer
.	O
word	long
.	O
text	pointer
;	O
while	O
(	O
*	O
ptr	pointer
)	O
{	O
if	O
(	O
*	O
ptr	pointer
==	O
'\n'	O
)	O
*	O
ptr	pointer
=	O
' '	O
;	O
ptr	pointer
++	O
;	O
}	O
}	O
if	O
(	O
state	pointer
.	O
counter	int
!=	O
0	int
&&	O
state	pointer
.	O
counter	int
+	O
state	pointer
.	O
word_counter	int
+	O
state	pointer
.	O
space_counter	int
>	O
state	pointer
.	O
max	int
)	O
{	O
xspara__cut_line	function
(	O
&	O
result	pointer
)	O
;	O
}	O
}	O
else	O
{	O
int	O
pending	int
=	O
state	pointer
.	O
invisible_pending_word	int
;	O
xspara__add_pending_word	function
(	O
&	O
result	pointer
,	O
0	int
)	O
;	O
if	O
(	O
state	pointer
.	O
counter	int
!=	O
0	int
||	O
state	pointer
.	O
unfilled	int
||	O
pending	int
)	O
{	O
if	O
(	O
state	pointer
.	O
end_sentence	int
==	O
1	int
&&	O
!	O
state	pointer
.	O
french_spacing	int
&&	O
!	O
state	pointer
.	O
unfilled	int
)	O
{	O
wchar_t	int
q_char	int
;	O
size_t	long
q_len	long
;	O
int	O
at_least_two	int
=	O
0	int
;	O
q_len	long
=	O
mbrtowc	function
(	O
&	O
q_char	int
,	O
p	pointer
+	O
char_len	long
,	O
len	long
-	O
char_len	long
,	O
NULL	O
)	O
;	O
if	O
(	O
(	O
long	O
)	O
q_len	long
>	O
0	int
)	O
{	O
if	O
(	O
iswspace	function
(	O
q_char	int
)	O
)	O
at_least_two	int
=	O
1	int
;	O
}	O
if	O
(	O
state	pointer
.	O
space_counter	int
>=	O
1	int
||	O
at_least_two	int
)	O
{	O
if	O
(	O
state	pointer
.	O
space_counter	int
>	O
0	int
)	O
{	O
static	O
TEXT	struct
new_space	struct
;	O
char	O
*	O
pspace	pointer
;	O
int	O
pspace_left	int
;	O
int	O
len	long
;	O
int	O
i	int
;	O
text_reset	function
(	O
&	O
new_space	struct
)	O
;	O
pspace	pointer
=	O
state	pointer
.	O
space	long
.	O
text	pointer
;	O
pspace_left	int
=	O
state	pointer
.	O
space	long
.	O
end	long
;	O
state	pointer
.	O
space_counter	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
2	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
!	O
*	O
pspace	pointer
)	O
break	O
;	O
len	long
=	O
mbrlen	function
(	O
pspace	pointer
,	O
pspace_left	int
,	O
NULL	O
)	O
;	O
if	O
(	O
*	O
pspace	pointer
==	O
'\n'	O
||	O
*	O
pspace	pointer
==	O
'\r'	O
)	O
text_append_n	function
(	O
&	O
new_space	struct
,	O
" "	pointer
,	O
1	int
)	O
;	O
else	O
if	O
(	O
len	long
>	O
0	int
)	O
text_append_n	function
(	O
&	O
new_space	struct
,	O
pspace	pointer
,	O
len	long
)	O
;	O
else	O
len	long
=	O
1	int
;	O
state	pointer
.	O
space_counter	int
++	O
;	O
pspace	pointer
+=	O
len	long
;	O
pspace_left	int
-=	O
len	long
;	O
}	O
state	pointer
.	O
space	long
.	O
end	long
=	O
0	int
;	O
text_append_n	function
(	O
&	O
state	pointer
.	O
space	long
,	O
new_space	struct
.	O
text	pointer
,	O
new_space	struct
.	O
end	long
)	O
;	O
text_destroy	function
(	O
&	O
new_space	struct
)	O
;	O
}	O
while	O
(	O
state	pointer
.	O
space_counter	int
<	O
2	int
)	O
{	O
if	O
(	O
*	O
p	pointer
==	O
'\n'	O
||	O
*	O
p	pointer
==	O
'\r'	O
)	O
text_append_n	function
(	O
&	O
state	pointer
.	O
space	long
,	O
" "	pointer
,	O
1	int
)	O
;	O
else	O
text_append_n	function
(	O
&	O
state	pointer
.	O
space	long
,	O
p	pointer
,	O
char_len	long
)	O
;	O
state	pointer
.	O
space_counter	int
++	O
;	O
p	pointer
+=	O
char_len	long
;	O
len	long
-=	O
char_len	long
;	O
char_len	long
=	O
mbrtowc	function
(	O
&	O
wc	int
,	O
p	pointer
,	O
len	long
,	O
NULL	O
)	O
;	O
if	O
(	O
(	O
long	O
)	O
char_len	long
<=	O
0	int
||	O
!	O
iswspace	function
(	O
wc	int
)	O
)	O
break	O
;	O
}	O
while	O
(	O
(	O
long	O
)	O
char_len	long
>	O
0	int
&&	O
iswspace	function
(	O
wc	int
)	O
)	O
{	O
p	pointer
+=	O
char_len	long
;	O
len	long
-=	O
char_len	long
;	O
char_len	long
=	O
mbrtowc	function
(	O
&	O
wc	int
,	O
p	pointer
,	O
len	long
,	O
NULL	O
)	O
;	O
}	O
while	O
(	O
state	pointer
.	O
space_counter	int
<	O
2	int
)	O
{	O
text_append_n	function
(	O
&	O
state	pointer
.	O
space	long
,	O
" "	pointer
,	O
1	int
)	O
;	O
state	pointer
.	O
space_counter	int
++	O
;	O
}	O
state	pointer
.	O
end_sentence	int
=	O
-	O
2	int
;	O
continue	O
;	O
}	O
else	O
{	O
state	pointer
.	O
space	long
.	O
end	long
=	O
0	int
;	O
state	pointer
.	O
space_counter	int
=	O
0	int
;	O
if	O
(	O
*	O
p	pointer
==	O
'\n'	O
||	O
*	O
p	pointer
==	O
'\r'	O
)	O
text_append_n	function
(	O
&	O
state	pointer
.	O
space	long
,	O
" "	pointer
,	O
1	int
)	O
;	O
else	O
text_append_n	function
(	O
&	O
state	pointer
.	O
space	long
,	O
p	pointer
,	O
char_len	long
)	O
;	O
state	pointer
.	O
space_counter	int
++	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
state	pointer
.	O
unfilled	int
||	O
state	pointer
.	O
space_counter	int
<	O
1	int
)	O
{	O
if	O
(	O
*	O
p	pointer
==	O
'\n'	O
||	O
*	O
p	pointer
==	O
'\r'	O
)	O
{	O
if	O
(	O
!	O
state	pointer
.	O
unfilled	int
)	O
{	O
text_append_n	function
(	O
&	O
state	pointer
.	O
space	long
,	O
" "	pointer
,	O
1	int
)	O
;	O
state	pointer
.	O
space_counter	int
++	O
;	O
}	O
else	O
if	O
(	O
*	O
p	pointer
==	O
'\n'	O
)	O
{	O
xspara__add_pending_word	function
(	O
&	O
result	pointer
,	O
0	int
)	O
;	O
xspara__end_line	function
(	O
)	O
;	O
text_append	function
(	O
&	O
result	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
}	O
else	O
{	O
text_append_n	function
(	O
&	O
state	pointer
.	O
space	long
,	O
p	pointer
,	O
char_len	long
)	O
;	O
state	pointer
.	O
space_counter	int
++	O
;	O
}	O
}	O
}	O
}	O
}	O
if	O
(	O
state	pointer
.	O
counter	int
+	O
state	pointer
.	O
space_counter	int
>	O
state	pointer
.	O
max	int
)	O
{	O
xspara__cut_line	function
(	O
&	O
result	pointer
)	O
;	O
}	O
if	O
(	O
!	O
state	pointer
.	O
unfilled	int
&&	O
*	O
p	pointer
==	O
'\n'	O
&&	O
state	pointer
.	O
keep_end_lines	int
)	O
{	O
xspara__end_line	function
(	O
)	O
;	O
text_append	function
(	O
&	O
result	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
}	O
else	O
{	O
int	O
width	int
=	O
wcwidth	function
(	O
wc	int
)	O
;	O
if	O
(	O
width	int
==	O
2	int
)	O
{	O
state	pointer
.	O
last_letter	int
=	O
L'\0'	O
;	O
text_append_n	function
(	O
&	O
state	pointer
.	O
word	long
,	O
p	pointer
,	O
char_len	long
)	O
;	O
state	pointer
.	O
word_counter	int
+=	O
2	int
;	O
if	O
(	O
state	pointer
.	O
counter	int
!=	O
0	int
&&	O
state	pointer
.	O
counter	int
+	O
state	pointer
.	O
word_counter	int
>	O
state	pointer
.	O
max	int
)	O
{	O
xspara__cut_line	function
(	O
&	O
result	pointer
)	O
;	O
}	O
if	O
(	O
!	O
state	pointer
.	O
protect_spaces	int
&&	O
!	O
state	pointer
.	O
double_width_no_break	int
)	O
{	O
xspara__add_pending_word	function
(	O
&	O
result	pointer
,	O
0	int
)	O
;	O
state	pointer
.	O
end_sentence	int
=	O
-	O
2	int
;	O
}	O
}	O
else	O
if	O
(	O
wc	int
==	O
L'\b'	O
)	O
{	O
xspara_allow_end_sentence	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
width	int
==	O
1	int
||	O
width	int
==	O
0	int
)	O
{	O
char	O
*	O
added_word	pointer
;	O
added_word	pointer
=	O
malloc	function
(	O
char_len	long
+	O
1	int
)	O
;	O
memcpy	function
(	O
added_word	pointer
,	O
p	pointer
,	O
char_len	long
)	O
;	O
added_word	pointer
[	O
char_len	long
]	O
=	O
'\0'	O
;	O
xspara__add_next	function
(	O
&	O
result	pointer
,	O
added_word	pointer
,	O
char_len	long
,	O
0	int
)	O
;	O
free	function
(	O
added_word	pointer
)	O
;	O
if	O
(	O
strchr	function
(	O
".?!"	pointer
,	O
*	O
p	pointer
)	O
&&	O
!	O
state	pointer
.	O
unfilled	int
)	O
{	O
if	O
(	O
!	O
iswupper	function
(	O
state	pointer
.	O
last_letter	int
)	O
)	O
{	O
if	O
(	O
state	pointer
.	O
french_spacing	int
)	O
state	pointer
.	O
end_sentence	int
=	O
-	O
1	int
;	O
else	O
state	pointer
.	O
end_sentence	int
=	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
strchr	function
(	O
"\"')]"	pointer
,	O
*	O
p	pointer
)	O
)	O
{	O
}	O
else	O
{	O
state	pointer
.	O
end_sentence	int
=	O
-	O
2	int
;	O
state	pointer
.	O
last_letter	int
=	O
wc	int
;	O
}	O
}	O
else	O
{	O
text_append_n	function
(	O
&	O
state	pointer
.	O
word	long
,	O
p	pointer
,	O
char_len	long
)	O
;	O
}	O
}	O
p	pointer
+=	O
char_len	long
;	O
len	long
-=	O
char_len	long
;	O
}	O
if	O
(	O
result	pointer
.	O
space	long
>	O
0	int
)	O
return	O
result	pointer
.	O
text	pointer
;	O
else	O
return	O
""	pointer
;	O
}	O
