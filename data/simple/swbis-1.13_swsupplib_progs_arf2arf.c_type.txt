YYSTYPE	union
yylval	union
;	O
static	O
int	O
verboseG	int
;	O
static	O
int	O
usage	function
(	O
FILE	struct
*	O
file	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
"%s"	pointer
,	O
"arf2arf : A signature and digest checking tool of the swbis project.\n"	pointer
"Usage arf2arf [options] [archive_file]\n"	pointer
"Translates an archive to stdout with specified filtering.\n"	pointer
"  -H, --format FORMAT   Output format  ustar, gnutar, newc, crc, odc\n"	pointer
"  --verbose-level=LEVEL\n"	pointer
"  -v, --verbose\n"	pointer
"  -N, --null-fd   Set stdout to  a /dev/null fd (Useful for debugging)\n"	pointer
"  -n, --sig-number=N  select Nth signature for verification; first is N=1,\n"	pointer
"                      last is N=0.\n"	pointer
"  -m, --numeric-owner\n"	pointer
"       --checksig-mode  fifoname  used by swverify --checksig.\n"	pointer
"       --sleep TIME  A configurable delay in seconds.\n"	pointer
"       --gpg-prog gpgexecname     used by --checksig-mode.\n"	pointer
"       --noop        legal option with no effect.\n"	pointer
"       --sha1        applies to -Sd only, show the sha1 digest.\n"	pointer
"       --decode      applies to -C and -S and --audit only.\n"	pointer
"                     Re-encodes the header with the swbis personality.\n"	pointer
"  --audit  Pass the input thru to the output unchanged and audit.\n"	pointer
"  -p, --pass-thru   Pass the input thru to the output unchanged.\n"	pointer
"  --recompress   Applies to pass thru\n"	pointer
"  -C, --catalog-sign-file  Write the catalog signature input file to stdout.\n"	pointer
"  -S, --storage-digest-file  Write the storage digest input file to stdout.\n"	pointer
"  -s, --adjunct-digest-file  Write the adjunct digest input file to stdout.\n"	pointer
"  -d, --show-auth-files    Writes the relevent security file to stderr.\n"	pointer
"              i.e  .../catalog/*/md5sum, or, adjunct_md5sum, or signature.\n"	pointer
"                   is copied directly from the archive to stderr.\n"	pointer
"    --test1  Write digest archive file on stdout and adjunct on stderr.\n"	pointer
"  -G --get-sig-if FILE Checks md5sum and if valid writes sigfile to FILE.\n"	pointer
"                   and the signed file to stdout.\n"	pointer
"  --util-name=NAME  NAME appears in verbose messages\n"	pointer
"  --logger-fd n   write authentication info to file descriptor n\n"	pointer
"\n"	pointer
" Note: The adjunct_md5sum attribute does not cover SYMLNK files in the\n"	pointer
"        archive.  It is a concession to an inability to preserve\n"	pointer
"        the modification time in the installed directory form of a package.\n"	pointer
" Example:  Check the md5sum and the (lesser) adjunct_md5sum:\n"	pointer
"      arf2arf -d -S <serial_archive_package | /usr/bin/md5sum\n"	pointer
"      arf2arf -d -s <serial_archive_package | /usr/bin/md5sum\n"	pointer
"         Note: The pairs of digests should be identical.\n"	pointer
" Example:  Check the package signature:\n"	pointer
"       arf2arf -G /dev/tty packageName.tgz | gpg --verify /dev/tty -\n"	pointer
"       (Copy and paste the sigfile, then hit Ctrl-D.)\n"	pointer
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"\n"	pointer
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"Date: "	pointer
SWBIS_DATE	pointer
"\n"	pointer
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"Copyright (C) 2003 Jim Lowe\n"	pointer
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"This program is distributed under the GNU GPL Software License.\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
enforce_tar_format	function
(	O
int	O
format	pointer
)	O
{	O
if	O
(	O
format	pointer
!=	O
USTAR_FILEFORMAT	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"operation not supported for this archive format[%d]\n"	pointer
,	O
format	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
static	O
void	O
set_if_fd	function
(	O
char	O
*	O
optarg	pointer
,	O
int	O
*	O
pfd	pointer
,	O
char	O
*	O
option_name	pointer
)	O
{	O
int	O
ret	int
;	O
int	O
status	int
;	O
if	O
(	O
optarg	pointer
&&	O
strlen	function
(	O
optarg	pointer
)	O
==	O
1	int
)	O
{	O
*	O
(	O
optarg	pointer
+	O
1	int
)	O
=	O
'\0'	O
;	O
ret	int
=	O
swlib_atoi	function
(	O
optarg	pointer
,	O
&	O
status	int
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
{	O
*	O
pfd	pointer
=	O
ret	int
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: invalid value for option --%s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
option_name	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: invalid value for --%s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
option_name	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
int	O
main	function
(	O
int	O
argc	pointer
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
int	O
fd	int
;	O
int	O
c	int
;	O
int	O
debugmode	int
=	O
0	int
;	O
int	O
format	pointer
=	O
arf_ustar	int
;	O
int	O
detected_format	int
;	O
int	O
numeric_uids	int
=	O
0	int
;	O
int	O
do_decode_pass_thru	int
=	O
0	int
;	O
int	O
ret	int
=	O
0	int
;	O
int	O
ifd	int
;	O
int	O
flags	int
;	O
int	O
cat_sign	int
=	O
0	int
;	O
int	O
store_sign	int
=	O
0	int
;	O
int	O
opt_gnutar	int
=	O
0	int
;	O
int	O
do_checksig	int
=	O
0	int
;	O
int	O
adjunct_store_sign	int
=	O
0	int
;	O
int	O
do_test1	int
=	O
0	int
;	O
int	O
verbose_stderr	int
=	O
0	int
;	O
int	O
pass_thru_mode	int
=	O
0	int
;	O
int	O
do_audit	int
=	O
0	int
;	O
int	O
get_sign_if	int
=	O
0	int
;	O
int	O
uverbose	int
=	O
1	int
;	O
int	O
digest_type	int
=	O
0	int
;	O
int	O
iret	int
;	O
int	O
logger_fd	int
;	O
int	O
signed_bytes_fd	int
;	O
int	O
do_recompress	int
=	O
0	int
;	O
int	O
which_sig	int
=	O
-	O
1	int
;	O
int	O
stdoutXfileno	int
;	O
uintmax_t	long
statbytes	pointer
;	O
char	O
*	O
gpg_prog	pointer
=	O
NULL	O
;	O
char	O
*	O
filearg	pointer
;	O
char	O
*	O
sleeptime	pointer
=	O
NULL	O
;	O
XFORMAT	struct
*	O
xformat	pointer
;	O
char	O
*	O
sigfilename	pointer
=	O
NULL	O
;	O
char	O
*	O
which_sig_arg	pointer
;	O
stdoutXfileno	int
=	O
STDOUT_FILENO	int
;	O
flags	int
=	O
UINFILE_DETECT_FORCEUXFIOFD	O
|	O
UINFILE_DETECT_IEEE	O
|	O
UINFILE_UXFIO_BUFTYPE_MEM	O
;	O
gpg_prog	pointer
=	O
strdup	function
(	O
SWGPG_GPG_BIN	pointer
)	O
;	O
signed_bytes_fd	int
=	O
stdoutXfileno	int
;	O
logger_fd	int
=	O
STDERR_FILENO	int
;	O
verboseG	int
=	O
uverbose	int
;	O
which_sig_arg	pointer
=	O
strdup	function
(	O
"-1"	pointer
)	O
;	O
swlib_utilname_set	function
(	O
"arf2arf"	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
yylval	union
.	O
strb	pointer
=	O
strob_open	function
(	O
8	int
)	O
;	O
while	O
(	O
1	int
)	O
{	O
int	O
option_index	int
=	O
0	int
;	O
static	O
struct	O
option	struct
long_options	array
[	O
]	O
=	O
{	O
{	O
"format"	pointer
,	O
1	int
,	O
0	int
,	O
'H'	O
}	O
,	O
{	O
"get-sig-if"	pointer
,	O
1	int
,	O
0	int
,	O
'G'	O
}	O
,	O
{	O
"verbose"	pointer
,	O
0	int
,	O
0	int
,	O
'v'	O
}	O
,	O
{	O
"numeric-owner"	pointer
,	O
0	int
,	O
0	int
,	O
'x'	O
}	O
,	O
{	O
"decode"	pointer
,	O
0	int
,	O
0	int
,	O
151	int
}	O
,	O
{	O
"debug-mode"	pointer
,	O
0	int
,	O
0	int
,	O
'D'	O
}	O
,	O
{	O
"catalog-sign-file"	pointer
,	O
0	int
,	O
0	int
,	O
'C'	O
}	O
,	O
{	O
"storage-sign-file"	pointer
,	O
0	int
,	O
0	int
,	O
'S'	O
}	O
,	O
{	O
"null-ofd"	pointer
,	O
0	int
,	O
0	int
,	O
'N'	O
}	O
,	O
{	O
"adjunct-storage-sign-file"	pointer
,	O
0	int
,	O
0	int
,	O
's'	O
}	O
,	O
{	O
"show-auth-files"	pointer
,	O
0	int
,	O
0	int
,	O
'd'	O
}	O
,	O
{	O
"sig-number"	pointer
,	O
1	int
,	O
0	int
,	O
'n'	O
}	O
,	O
{	O
"pass-thru"	pointer
,	O
0	int
,	O
0	int
,	O
'p'	O
}	O
,	O
{	O
"test1"	pointer
,	O
0	int
,	O
0	int
,	O
152	int
}	O
,	O
{	O
"help"	pointer
,	O
0	int
,	O
0	int
,	O
150	int
}	O
,	O
{	O
"noop"	pointer
,	O
0	int
,	O
0	int
,	O
158	int
}	O
,	O
{	O
"checksig-mode"	pointer
,	O
1	int
,	O
0	int
,	O
159	int
}	O
,	O
{	O
"sha1"	pointer
,	O
0	int
,	O
0	int
,	O
160	int
}	O
,	O
{	O
"gpg-prog"	pointer
,	O
1	int
,	O
0	int
,	O
161	int
}	O
,	O
{	O
"sleep"	pointer
,	O
1	int
,	O
0	int
,	O
162	int
}	O
,	O
{	O
"audit"	pointer
,	O
0	int
,	O
0	int
,	O
163	int
}	O
,	O
{	O
"verbose-level"	pointer
,	O
1	int
,	O
0	int
,	O
164	int
}	O
,	O
{	O
"util-name"	pointer
,	O
1	int
,	O
0	int
,	O
165	int
}	O
,	O
{	O
"logger-fd"	pointer
,	O
1	int
,	O
0	int
,	O
166	int
}	O
,	O
{	O
"signed-bytes-fd"	pointer
,	O
1	int
,	O
0	int
,	O
167	int
}	O
,	O
{	O
"recompress"	pointer
,	O
0	int
,	O
0	int
,	O
168	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
c	int
=	O
ugetopt_long	function
(	O
argc	pointer
,	O
argv	pointer
,	O
"n:NpdsSCxDH:G:v"	pointer
,	O
long_options	array
,	O
&	O
option_index	int
)	O
;	O
if	O
(	O
c	int
==	O
-	O
1	int
)	O
break	O
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
'x'	O
:	O
numeric_uids	int
=	O
1	int
;	O
break	O
;	O
case	O
'p'	O
:	O
pass_thru_mode	int
=	O
1	int
;	O
break	O
;	O
case	O
'v'	O
:	O
uverbose	int
++	O
;	O
verboseG	int
++	O
;	O
break	O
;	O
case	O
'd'	O
:	O
verbose_stderr	int
=	O
1	int
;	O
break	O
;	O
case	O
'D'	O
:	O
debugmode	int
=	O
1	int
;	O
break	O
;	O
case	O
'N'	O
:	O
stdoutXfileno	int
=	O
open	function
(	O
"/dev/null"	pointer
,	O
O_RDWR	int
,	O
0	int
)	O
;	O
if	O
(	O
stdoutXfileno	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s : %s\n"	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
break	O
;	O
case	O
'n'	O
:	O
which_sig	int
=	O
swlib_atoi	function
(	O
optarg	pointer
,	O
NULL	O
)	O
;	O
which_sig_arg	pointer
=	O
strdup	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'G'	O
:	O
get_sign_if	int
=	O
1	int
;	O
sigfilename	pointer
=	O
strdup	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'H'	O
:	O
if	O
(	O
!	O
strcmp	function
(	O
optarg	pointer
,	O
"ustar"	pointer
)	O
)	O
{	O
format	pointer
=	O
arf_ustar	int
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
optarg	pointer
,	O
"gnutar"	pointer
)	O
)	O
{	O
opt_gnutar	int
=	O
1	int
;	O
format	pointer
=	O
arf_ustar	int
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
optarg	pointer
,	O
"newc"	pointer
)	O
)	O
{	O
format	pointer
=	O
arf_newascii	int
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
optarg	pointer
,	O
"crc"	pointer
)	O
)	O
{	O
format	pointer
=	O
arf_crcascii	int
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
optarg	pointer
,	O
"odc"	pointer
)	O
)	O
{	O
format	pointer
=	O
arf_oldascii	int
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"unrecognized format: %s\n"	pointer
,	O
optarg	pointer
)	O
;	O
exit	function
(	O
2	int
)	O
;	O
}	O
break	O
;	O
case	O
'C'	O
:	O
cat_sign	int
=	O
1	int
;	O
break	O
;	O
case	O
'S'	O
:	O
store_sign	int
=	O
1	int
;	O
break	O
;	O
case	O
's'	O
:	O
adjunct_store_sign	int
=	O
1	int
;	O
break	O
;	O
case	O
160	int
:	O
digest_type	int
=	O
3	int
;	O
break	O
;	O
case	O
158	int
:	O
break	O
;	O
case	O
150	int
:	O
usage	function
(	O
stdout	pointer
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
break	O
;	O
case	O
151	int
:	O
do_decode_pass_thru	int
=	O
1	int
;	O
break	O
;	O
case	O
152	int
:	O
do_test1	int
=	O
1	int
;	O
break	O
;	O
case	O
159	int
:	O
do_checksig	int
=	O
1	int
;	O
sigfilename	pointer
=	O
strdup	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
161	int
:	O
gpg_prog	pointer
=	O
strdup	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
162	int
:	O
sleeptime	pointer
=	O
strdup	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
163	int
:	O
do_audit	int
=	O
1	int
;	O
flags	int
=	O
UINFILE_DETECT_FORCEUXFIOFD	O
|	O
UINFILE_DETECT_IEEE	O
|	O
UINFILE_DETECT_OTARALLOW	O
|	O
UINFILE_UXFIO_BUFTYPE_DYNAMIC_MEM	O
;	O
break	O
;	O
case	O
164	int
:	O
uverbose	int
=	O
swlib_atoi	function
(	O
optarg	pointer
,	O
NULL	O
)	O
;	O
verboseG	int
=	O
swlib_atoi	function
(	O
optarg	pointer
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
165	int
:	O
swlib_utilname_set	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
166	int
:	O
set_if_fd	function
(	O
optarg	pointer
,	O
&	O
logger_fd	int
,	O
"logger-fd"	pointer
)	O
;	O
break	O
;	O
case	O
167	int
:	O
set_if_fd	function
(	O
optarg	pointer
,	O
&	O
signed_bytes_fd	int
,	O
"signed-bytes-fd"	pointer
)	O
;	O
break	O
;	O
case	O
168	int
:	O
do_recompress	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
usage	function
(	O
stderr	pointer
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
exit	function
(	O
2	int
)	O
;	O
break	O
;	O
}	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
do_decode_pass_thru	int
&&	O
verbose_stderr	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"option combination not supported.\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
sleeptime	pointer
&&	O
swlib_atoi	function
(	O
sleeptime	pointer
,	O
NULL	O
)	O
)	O
{	O
sleep	function
(	O
swlib_atoi	function
(	O
sleeptime	pointer
,	O
NULL	O
)	O
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
optind	int
<	O
argc	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
optind	int
]	O
,	O
"-"	pointer
)	O
)	O
{	O
fd	int
=	O
open	function
(	O
argv	pointer
[	O
optind	int
]	O
,	O
O_RDONLY	int
,	O
0	int
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s : %s\n"	pointer
,	O
argv	pointer
[	O
optind	int
]	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
filearg	pointer
=	O
strdup	function
(	O
argv	pointer
[	O
optind	int
]	O
)	O
;	O
}	O
else	O
{	O
filearg	pointer
=	O
strdup	function
(	O
"-"	pointer
)	O
;	O
fd	int
=	O
STDIN_FILENO	int
;	O
}	O
}	O
else	O
{	O
filearg	pointer
=	O
strdup	function
(	O
"-"	pointer
)	O
;	O
fd	int
=	O
STDIN_FILENO	int
;	O
}	O
if	O
(	O
do_checksig	int
)	O
{	O
E_DEBUG2	O
(	O
"which_sig_arg=[%s]"	pointer
,	O
which_sig_arg	pointer
)	O
;	O
ret	int
=	O
swgpg_run_checksig2	function
(	O
sigfilename	pointer
,	O
SWBISLIBEXECDIR	O
"/swbis/arf2arf"	pointer
,	O
filearg	pointer
,	O
gpg_prog	pointer
,	O
uverbose	int
,	O
which_sig_arg	pointer
)	O
;	O
E_DEBUG2	O
(	O
"swgpg_run_checksig2 ret=[%d]"	pointer
,	O
ret	int
)	O
;	O
if	O
(	O
uverbose	int
>	O
5	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: do_checksig returned %d\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
ret	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
ret	int
=	O
1	int
;	O
E_DEBUG2	O
(	O
"exiting ret=[%d]"	pointer
,	O
ret	int
)	O
;	O
exit	function
(	O
ret	int
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
xformat	pointer
=	O
xformat_open	function
(	O
STDIN_FILENO	int
,	O
stdoutXfileno	int
,	O
format	pointer
)	O
;	O
if	O
(	O
!	O
xformat	pointer
)	O
exit	function
(	O
1	int
)	O
;	O
if	O
(	O
do_recompress	int
)	O
{	O
flags	int
=	O
flags	int
|	O
UINFILE_DETECT_RECOMPRESS	O
;	O
}	O
if	O
(	O
xformat_open_archive_by_fd	function
(	O
xformat	pointer
,	O
fd	int
,	O
flags	int
,	O
0	int
)	O
)	O
{	O
if	O
(	O
get_sign_if	int
)	O
{	O
int	O
sigfd	int
=	O
open	function
(	O
sigfilename	pointer
,	O
O_RDWR	int
|	O
O_TRUNC	int
|	O
O_CREAT	int
,	O
0600	int
)	O
;	O
if	O
(	O
sigfd	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"open failed ( %s ) : %s\n"	pointer
,	O
sigfilename	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
else	O
{	O
close	pointer
(	O
sigfd	int
)	O
;	O
}	O
}	O
close	pointer
(	O
stdoutXfileno	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
detected_format	int
=	O
xformat_get_format	function
(	O
xformat	pointer
)	O
;	O
xformat_set_numeric_uids	function
(	O
xformat	pointer
,	O
numeric_uids	int
)	O
;	O
if	O
(	O
opt_gnutar	int
)	O
{	O
xformat_set_tarheader_flag	function
(	O
xformat	pointer
,	O
TARU_TAR_GNU_OLDGNUTAR	O
,	O
1	int
)	O
;	O
xformat_set_tarheader_flag	function
(	O
xformat	pointer
,	O
TARU_TAR_GNU_LONG_LINKS	O
,	O
1	int
)	O
;	O
}	O
if	O
(	O
store_sign	int
)	O
{	O
enforce_tar_format	function
(	O
detected_format	int
)	O
;	O
xformat_set_tarheader_flag	function
(	O
xformat	pointer
,	O
TARU_TAR_FRAGILE_FORMAT	O
,	O
1	int
)	O
;	O
if	O
(	O
do_decode_pass_thru	int
)	O
{	O
ret	int
=	O
swlib_write_signing_files	function
(	O
xformat	pointer
,	O
stdoutXfileno	int
,	O
1	int
,	O
0	int
)	O
;	O
}	O
else	O
{	O
ret	int
=	O
taruib_write_storage_stream	function
(	O
(	O
void	O
*	O
)	O
xformat	pointer
,	O
stdoutXfileno	int
,	O
1	int
,	O
-	O
1	int
,	O
verbose_stderr	int
,	O
digest_type	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
get_sign_if	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
enforce_tar_format	function
(	O
detected_format	int
)	O
;	O
xformat_set_tarheader_flag	function
(	O
xformat	pointer
,	O
TARU_TAR_FRAGILE_FORMAT	O
,	O
1	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
E_DEBUG2	O
(	O
"which_sig=[%d]"	pointer
,	O
which_sig	int
)	O
;	O
ret	int
=	O
taruib_write_signedfile_if	function
(	O
(	O
void	O
*	O
)	O
xformat	pointer
,	O
signed_bytes_fd	int
,	O
sigfilename	pointer
,	O
uverbose	int
,	O
which_sig	int
,	O
logger_fd	int
)	O
;	O
E_DEBUG2	O
(	O
"taruib_write_signedfile_if: ret=%d"	pointer
,	O
ret	int
)	O
;	O
if	O
(	O
uverbose	int
>=	O
5	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: taruib_write_signedfile_if returned %d\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
ret	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
adjunct_store_sign	int
)	O
{	O
enforce_tar_format	function
(	O
detected_format	int
)	O
;	O
if	O
(	O
do_decode_pass_thru	int
)	O
{	O
swlib_write_signing_files	function
(	O
xformat	pointer
,	O
stdoutXfileno	int
,	O
1	int
,	O
1	int
)	O
;	O
}	O
else	O
{	O
int	O
nullfd	int
;	O
nullfd	int
=	O
open	function
(	O
"/dev/null"	pointer
,	O
O_RDWR	int
,	O
0	int
)	O
;	O
if	O
(	O
nullfd	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"error opening /dev/null \n"	pointer
)	O
;	O
exit	function
(	O
2	int
)	O
;	O
}	O
taruib_write_storage_stream	function
(	O
(	O
void	O
*	O
)	O
xformat	pointer
,	O
nullfd	int
,	O
1	int
,	O
stdoutXfileno	int
,	O
verbose_stderr	int
,	O
digest_type	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
cat_sign	int
)	O
{	O
enforce_tar_format	function
(	O
detected_format	int
)	O
;	O
if	O
(	O
do_decode_pass_thru	int
)	O
{	O
ret	int
=	O
swlib_write_signing_files	function
(	O
xformat	pointer
,	O
stdoutXfileno	int
,	O
0	int
,	O
0	int
)	O
;	O
}	O
else	O
{	O
ret	int
=	O
taruib_write_catalog_stream	function
(	O
(	O
void	O
*	O
)	O
xformat	pointer
,	O
stdoutXfileno	int
,	O
1	int
,	O
verbose_stderr	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
do_test1	int
)	O
{	O
xformat_set_tarheader_flag	function
(	O
xformat	pointer
,	O
TARU_TAR_FRAGILE_FORMAT	O
,	O
1	int
)	O
;	O
ret	int
=	O
taruib_write_storage_stream	function
(	O
xformat	pointer
,	O
stdoutXfileno	int
,	O
1	int
,	O
STDERR_FILENO	int
,	O
0	int
,	O
digest_type	int
)	O
;	O
}	O
else	O
if	O
(	O
pass_thru_mode	int
)	O
{	O
SHCMD	struct
*	O
*	O
cmd_vec	pointer
;	O
SHCMD	struct
*	O
cmd	int
;	O
int	O
ipipe	array
[	O
2	int
]	O
;	O
pid_t	int
childi	int
;	O
if	O
(	O
do_recompress	int
)	O
{	O
E_DEBUG	O
(	O
"do_recompress"	pointer
)	O
;	O
cmd_vec	pointer
=	O
uinfile_get_recompress_vector	function
(	O
swvarfs_get_uinformat	function
(	O
xformat_get_swvarfs	function
(	O
xformat	pointer
)	O
)	O
)	O
;	O
}	O
else	O
{	O
cmd_vec	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
cmd_vec	pointer
)	O
{	O
E_DEBUG	O
(	O
"do_recompress: have cmd_vec"	pointer
)	O
;	O
pipe	function
(	O
ipipe	array
)	O
;	O
childi	int
=	O
swfork	O
(	O
(	O
sigset_t	struct
*	O
)	O
(	O
NULL	O
)	O
)	O
;	O
if	O
(	O
childi	int
==	O
0	int
)	O
{	O
int	O
ret	int
;	O
swgp_signal	function
(	O
SIGPIPE	int
,	O
SIG_DFL	O
)	O
;	O
swgp_signal	function
(	O
SIGINT	int
,	O
SIG_DFL	O
)	O
;	O
swgp_signal	function
(	O
SIGTERM	int
,	O
SIG_DFL	O
)	O
;	O
swgp_signal	function
(	O
SIGUSR1	int
,	O
SIG_DFL	O
)	O
;	O
swgp_signal	function
(	O
SIGUSR2	int
,	O
SIG_DFL	O
)	O
;	O
close	pointer
(	O
ipipe	array
[	O
0	int
]	O
)	O
;	O
ret	int
=	O
taruib_write_pass_files	function
(	O
(	O
void	O
*	O
)	O
xformat	pointer
,	O
ipipe	array
[	O
1	int
]	O
,	O
-	O
1	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
ret	int
=	O
1	int
;	O
else	O
ret	int
=	O
0	int
;	O
_exit	function
(	O
ret	int
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
childi	int
<	O
0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
close	pointer
(	O
ipipe	array
[	O
1	int
]	O
)	O
;	O
shcmd_set_srcfd	function
(	O
cmd_vec	pointer
[	O
0	int
]	O
,	O
ipipe	array
[	O
0	int
]	O
)	O
;	O
cmd	int
=	O
shcmd_get_last_command	function
(	O
cmd_vec	pointer
)	O
;	O
shcmd_set_dstfd	function
(	O
cmd	int
,	O
stdoutXfileno	int
)	O
;	O
shcmd_cmdvec_exec	function
(	O
cmd_vec	pointer
)	O
;	O
ret	int
=	O
shcmd_cmdvec_wait2	function
(	O
cmd_vec	pointer
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
ret	int
=	O
-	O
1	int
;	O
}	O
else	O
{	O
ret	int
=	O
taruib_write_pass_files	function
(	O
(	O
void	O
*	O
)	O
xformat	pointer
,	O
stdoutXfileno	int
,	O
-	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
do_audit	int
)	O
{	O
ret	int
=	O
swlib_audit_distribution	function
(	O
xformat	pointer
,	O
do_decode_pass_thru	int
,	O
stdoutXfileno	int
,	O
&	O
statbytes	pointer
,	O
(	O
int	O
*	O
)	O
(	O
NULL	O
)	O
,	O
(	O
void	O
(	O
*	O
)	O
(	O
int	O
)	O
)	O
(	O
NULL	O
)	O
)	O
;	O
}	O
else	O
{	O
xformat_set_output_format	function
(	O
xformat	pointer
,	O
(	O
int	O
)	O
format	pointer
)	O
;	O
xformat_set_false_inodes	function
(	O
xformat	pointer
,	O
XFORMAT_OFF	int
)	O
;	O
ifd	int
=	O
xformat_get_ifd	function
(	O
xformat	pointer
)	O
;	O
while	O
(	O
(	O
ret	int
=	O
xformat_read_header	function
(	O
xformat	pointer
)	O
)	O
>	O
0	int
)	O
{	O
if	O
(	O
xformat_is_end_of_archive	function
(	O
xformat	pointer
)	O
)	O
{	O
break	O
;	O
}	O
xformat_write_header	function
(	O
xformat	pointer
)	O
;	O
xformat_copy_pass	function
(	O
xformat	pointer
,	O
stdoutXfileno	int
,	O
ifd	int
)	O
;	O
}	O
if	O
(	O
ret	int
>=	O
0	int
)	O
{	O
xformat_write_trailer	function
(	O
xformat	pointer
)	O
;	O
if	O
(	O
xformat_get_pass_fd	function
(	O
xformat	pointer
)	O
)	O
{	O
xformat_clear_pass_buffer	function
(	O
xformat	pointer
)	O
;	O
}	O
}	O
}	O
iret	int
=	O
xformat_close	function
(	O
xformat	pointer
)	O
;	O
if	O
(	O
fd	int
!=	O
STDIN_FILENO	int
)	O
close	pointer
(	O
fd	int
)	O
;	O
if	O
(	O
uverbose	int
>=	O
5	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s : ret=%d\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
ret	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s : iret=%d\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
iret	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s : exiting with %d\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
ret	int
)	O
;	O
}	O
if	O
(	O
ret	int
==	O
0	int
)	O
ret	int
=	O
iret	int
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
ret	int
=	O
1	int
;	O
E_DEBUG2	O
(	O
"exiting with [%d]"	pointer
,	O
ret	int
)	O
;	O
exit	function
(	O
ret	int
)	O
;	O
}	O
