static	O
int	O
goal_dist	function
(	O
int	O
pos	int
,	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
)	O
;	O
static	O
int	O
compare_angles	function
(	O
const	O
void	O
*	O
a	char
,	O
const	O
void	O
*	O
b	char
)	O
;	O
static	O
void	O
show_surround_map	function
(	O
signed	O
char	O
mf	array
[	O
BOARDMAX	O
]	O
,	O
signed	O
char	O
mn	array
[	O
BOARDMAX	O
]	O
)	O
;	O
static	O
int	O
gg	int
;	O
int	O
compute_surroundings	function
(	O
int	O
pos	int
,	O
int	O
apos	int
,	O
int	O
showboard	function
,	O
int	O
*	O
surround_size	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
m	int
,	O
n	int
;	O
int	O
k	int
;	O
int	O
dpos	int
;	O
int	O
surrounded	int
;	O
int	O
left_corner	array
[	O
MAX_BOARD	int
]	O
;	O
int	O
right_corner	array
[	O
MAX_BOARD	int
]	O
;	O
int	O
corner	array
[	O
BOARDMAX	O
]	O
;	O
int	O
left_corners	int
=	O
0	int
,	O
right_corners	int
=	O
0	int
;	O
int	O
corners	int
=	O
0	int
;	O
int	O
top_row	int
,	O
bottom_row	int
;	O
int	O
color	int
=	O
board	pointer
[	O
pos	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
gi	int
=	O
0	int
;	O
int	O
gj	int
=	O
0	int
;	O
int	O
stones	pointer
=	O
0	int
;	O
int	O
found_some	int
;	O
signed	O
char	O
mf	array
[	O
BOARDMAX	O
]	O
;	O
signed	O
char	O
mn	array
[	O
BOARDMAX	O
]	O
;	O
int	O
sd	array
[	O
BOARDMAX	O
]	O
;	O
if	O
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
hostile_neighbors	int
==	O
0	int
)	O
return	O
(	O
0	int
)	O
;	O
memset	function
(	O
mf	array
,	O
0	int
,	O
sizeof	O
(	O
mf	array
)	O
)	O
;	O
memset	function
(	O
mn	array
,	O
0	int
,	O
sizeof	O
(	O
mn	array
)	O
)	O
;	O
memset	function
(	O
sd	array
,	O
0	int
,	O
sizeof	O
(	O
sd	array
)	O
)	O
;	O
mark_dragon	function
(	O
pos	int
,	O
mf	array
,	O
1	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
DRAGON2	O
(	O
pos	int
)	O
.	O
neighbors	int
;	O
k	int
++	O
)	O
{	O
int	O
nd	int
=	O
DRAGON	O
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
adjacent	array
[	O
k	int
]	O
)	O
.	O
origin	int
;	O
if	O
(	O
board	pointer
[	O
nd	int
]	O
!=	O
color	int
)	O
{	O
if	O
(	O
0	int
)	O
gprintf	function
(	O
"neighbor: %1m\n"	pointer
,	O
nd	int
)	O
;	O
mark_dragon	function
(	O
nd	int
,	O
mn	array
,	O
1	int
)	O
;	O
}	O
}	O
for	O
(	O
dpos	int
=	O
BOARDMIN	O
;	O
dpos	int
<	O
BOARDMAX	O
;	O
dpos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
dpos	int
)	O
&&	O
mn	array
[	O
dpos	int
]	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
d	int
=	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
dpos	int
+	O
d	int
)	O
)	O
continue	O
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
dpos	int
+	O
2	int
*	O
d	int
)	O
)	O
{	O
if	O
(	O
board	pointer
[	O
dpos	int
+	O
d	int
]	O
==	O
EMPTY	int
)	O
mn	array
[	O
dpos	int
+	O
d	int
]	O
=	O
1	int
;	O
}	O
else	O
if	O
(	O
!	O
ON_BOARD	O
(	O
dpos	int
+	O
3	int
*	O
d	int
)	O
)	O
{	O
if	O
(	O
board	pointer
[	O
dpos	int
+	O
d	int
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
dpos	int
+	O
2	int
*	O
d	int
]	O
==	O
EMPTY	int
)	O
mn	array
[	O
dpos	int
+	O
2	int
*	O
d	int
]	O
=	O
1	int
;	O
}	O
}	O
}	O
for	O
(	O
dpos	int
=	O
BOARDMIN	O
;	O
dpos	int
<	O
BOARDMAX	O
;	O
dpos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
dpos	int
)	O
&&	O
mn	array
[	O
dpos	int
]	O
)	O
sd	array
[	O
dpos	int
]	O
=	O
goal_dist	function
(	O
dpos	int
,	O
mf	array
)	O
;	O
do	O
{	O
found_some	int
=	O
0	int
;	O
for	O
(	O
dpos	int
=	O
BOARDMIN	O
;	O
dpos	int
<	O
BOARDMAX	O
;	O
dpos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
dpos	int
)	O
&&	O
mn	array
[	O
dpos	int
]	O
&&	O
sd	array
[	O
dpos	int
]	O
>	O
8	int
)	O
{	O
for	O
(	O
i	int
=	O
BOARDMIN	O
;	O
i	int
<	O
BOARDMAX	O
;	O
i	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
i	int
)	O
&&	O
mn	array
[	O
i	int
]	O
&&	O
i	int
!=	O
dpos	int
&&	O
sd	array
[	O
i	int
]	O
<	O
sd	array
[	O
dpos	int
]	O
&&	O
square_dist	function
(	O
i	int
,	O
dpos	int
)	O
<	O
sd	array
[	O
dpos	int
]	O
)	O
{	O
for	O
(	O
j	int
=	O
i	int
+	O
1	int
;	O
j	int
<	O
BOARDMAX	O
;	O
j	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
j	int
)	O
&&	O
mn	array
[	O
j	int
]	O
&&	O
j	int
!=	O
dpos	int
&&	O
sd	array
[	O
j	int
]	O
<	O
sd	array
[	O
dpos	int
]	O
&&	O
square_dist	function
(	O
j	int
,	O
dpos	int
)	O
<	O
sd	array
[	O
dpos	int
]	O
&&	O
square_dist	function
(	O
i	int
,	O
j	int
)	O
<	O
sd	array
[	O
dpos	int
]	O
)	O
{	O
mn	array
[	O
dpos	int
]	O
=	O
0	int
;	O
found_some	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
mn	array
[	O
dpos	int
]	O
==	O
0	int
)	O
break	O
;	O
}	O
}	O
}	O
while	O
(	O
found_some	int
)	O
;	O
for	O
(	O
dpos	int
=	O
BOARDMIN	O
;	O
dpos	int
<	O
BOARDMAX	O
;	O
dpos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
dpos	int
)	O
&&	O
mn	array
[	O
dpos	int
]	O
)	O
corner	array
[	O
corners	int
++	O
]	O
=	O
dpos	int
;	O
for	O
(	O
dpos	int
=	O
BOARDMIN	O
;	O
dpos	int
<	O
BOARDMAX	O
;	O
dpos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
dpos	int
)	O
&&	O
mf	array
[	O
dpos	int
]	O
)	O
{	O
gi	int
+=	O
I	O
(	O
dpos	int
)	O
;	O
gj	int
+=	O
J	O
(	O
dpos	int
)	O
;	O
stones	pointer
++	O
;	O
}	O
gi	int
/=	O
stones	pointer
;	O
gj	int
/=	O
stones	pointer
;	O
gg	int
=	O
POS	O
(	O
gi	int
,	O
gj	int
)	O
;	O
gg_sort	function
(	O
corner	array
,	O
corners	int
,	O
sizeof	O
(	O
int	O
)	O
,	O
compare_angles	function
)	O
;	O
if	O
(	O
apos	int
!=	O
NO_MOVE	O
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
apos	int
)	O
;	O
mn	array
[	O
apos	int
]	O
=	O
1	int
;	O
}	O
if	O
(	O
showboard	function
==	O
1	int
)	O
{	O
show_surround_map	function
(	O
mf	array
,	O
mn	array
)	O
;	O
}	O
top_row	int
=	O
-	O
1	int
;	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
board_size	int
;	O
m	int
++	O
)	O
{	O
if	O
(	O
top_row	int
!=	O
-	O
1	int
)	O
break	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
board_size	int
;	O
n	int
++	O
)	O
if	O
(	O
mn	array
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
)	O
{	O
left_corner	array
[	O
0	int
]	O
=	O
POS	O
(	O
m	int
,	O
n	int
)	O
;	O
top_row	int
=	O
m	int
;	O
break	O
;	O
}	O
}	O
bottom_row	int
=	O
-	O
1	int
;	O
for	O
(	O
m	int
=	O
board_size	int
-	O
1	int
;	O
m	int
>=	O
0	int
;	O
m	int
--	O
)	O
{	O
if	O
(	O
bottom_row	int
!=	O
-	O
1	int
)	O
break	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
board_size	int
;	O
n	int
++	O
)	O
if	O
(	O
mn	array
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
)	O
{	O
bottom_row	int
=	O
m	int
;	O
break	O
;	O
}	O
}	O
for	O
(	O
left_corners	int
=	O
1	int
;	O
I	O
(	O
left_corner	array
[	O
left_corners	int
-	O
1	int
]	O
)	O
<	O
bottom_row	int
;	O
left_corners	int
++	O
)	O
{	O
int	O
best_found	int
=	O
0	int
;	O
float	O
best_slope	float
=	O
0.	int
;	O
int	O
m	int
=	O
I	O
(	O
left_corner	array
[	O
left_corners	int
-	O
1	int
]	O
)	O
;	O
int	O
n	int
=	O
J	O
(	O
left_corner	array
[	O
left_corners	int
-	O
1	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
m	int
+	O
1	int
;	O
i	int
<=	O
bottom_row	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
board_size	int
;	O
j	int
++	O
)	O
if	O
(	O
mn	array
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
)	O
{	O
float	O
slope	float
=	O
(	O
(	O
float	O
)	O
(	O
j	int
-	O
n	int
)	O
)	O
/	O
(	O
(	O
float	O
)	O
(	O
i	int
-	O
m	int
)	O
)	O
;	O
if	O
(	O
0	int
)	O
gprintf	function
(	O
"(left) at %m, last %m, slope=%f\n"	pointer
,	O
i	int
,	O
j	int
,	O
m	int
,	O
n	int
,	O
slope	float
)	O
;	O
if	O
(	O
!	O
best_found	int
||	O
slope	float
<	O
best_slope	float
)	O
{	O
best_found	int
=	O
POS	O
(	O
i	int
,	O
j	int
)	O
;	O
best_slope	float
=	O
slope	float
;	O
}	O
}	O
ASSERT_ON_BOARD1	O
(	O
best_found	int
)	O
;	O
left_corner	array
[	O
left_corners	int
]	O
=	O
best_found	int
;	O
}	O
for	O
(	O
n	int
=	O
board_size	int
-	O
1	int
;	O
n	int
>=	O
0	int
;	O
n	int
--	O
)	O
if	O
(	O
mn	array
[	O
POS	O
(	O
top_row	int
,	O
n	int
)	O
]	O
)	O
{	O
right_corner	array
[	O
0	int
]	O
=	O
POS	O
(	O
top_row	int
,	O
n	int
)	O
;	O
break	O
;	O
}	O
for	O
(	O
right_corners	int
=	O
1	int
;	O
I	O
(	O
right_corner	array
[	O
right_corners	int
-	O
1	int
]	O
)	O
<	O
bottom_row	int
;	O
right_corners	int
++	O
)	O
{	O
int	O
best_found	int
=	O
0	int
;	O
float	O
best_slope	float
=	O
0.	int
;	O
int	O
m	int
=	O
I	O
(	O
right_corner	array
[	O
right_corners	int
-	O
1	int
]	O
)	O
;	O
int	O
n	int
=	O
J	O
(	O
right_corner	array
[	O
right_corners	int
-	O
1	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
m	int
+	O
1	int
;	O
i	int
<=	O
bottom_row	int
;	O
i	int
++	O
)	O
{	O
for	O
(	O
j	int
=	O
board_size	int
-	O
1	int
;	O
j	int
>=	O
0	int
;	O
j	int
--	O
)	O
{	O
if	O
(	O
mn	array
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
)	O
{	O
float	O
slope	float
=	O
(	O
(	O
float	O
)	O
(	O
j	int
-	O
n	int
)	O
)	O
/	O
(	O
(	O
float	O
)	O
(	O
i	int
-	O
m	int
)	O
)	O
;	O
if	O
(	O
0	int
)	O
gprintf	function
(	O
"(right) at %m, last %m, slope=%f\n"	pointer
,	O
i	int
,	O
j	int
,	O
m	int
,	O
n	int
,	O
slope	float
)	O
;	O
if	O
(	O
!	O
best_found	int
||	O
slope	float
>	O
best_slope	float
)	O
{	O
best_found	int
=	O
POS	O
(	O
i	int
,	O
j	int
)	O
;	O
best_slope	float
=	O
slope	float
;	O
}	O
}	O
}	O
}	O
ASSERT_ON_BOARD1	O
(	O
best_found	int
)	O
;	O
right_corner	array
[	O
right_corners	int
]	O
=	O
best_found	int
;	O
}	O
if	O
(	O
0	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
left_corners	int
;	O
k	int
++	O
)	O
gprintf	function
(	O
"left corner %d: %1m\n"	pointer
,	O
k	int
,	O
left_corner	array
[	O
k	int
]	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
right_corners	int
;	O
k	int
++	O
)	O
gprintf	function
(	O
"right corner %d: %1m\n"	pointer
,	O
k	int
,	O
right_corner	array
[	O
k	int
]	O
)	O
;	O
}	O
for	O
(	O
n	int
=	O
J	O
(	O
left_corner	array
[	O
0	int
]	O
)	O
;	O
n	int
<=	O
J	O
(	O
right_corner	array
[	O
0	int
]	O
)	O
;	O
n	int
++	O
)	O
mn	array
[	O
POS	O
(	O
top_row	int
,	O
n	int
)	O
]	O
=	O
1	int
;	O
for	O
(	O
n	int
=	O
J	O
(	O
left_corner	array
[	O
left_corners	int
-	O
1	int
]	O
)	O
;	O
n	int
<=	O
J	O
(	O
right_corner	array
[	O
right_corners	int
-	O
1	int
]	O
)	O
;	O
n	int
++	O
)	O
mn	array
[	O
POS	O
(	O
bottom_row	int
,	O
n	int
)	O
]	O
=	O
1	int
;	O
for	O
(	O
m	int
=	O
top_row	int
+	O
1	int
;	O
m	int
<	O
bottom_row	int
;	O
m	int
++	O
)	O
{	O
int	O
left_boundary	int
=	O
-	O
1	int
,	O
right_boundary	int
=	O
-	O
1	int
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<	O
left_corners	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
I	O
(	O
left_corner	array
[	O
k	int
]	O
)	O
>	O
m	int
)	O
{	O
float	O
ti	float
=	O
I	O
(	O
left_corner	array
[	O
k	int
-	O
1	int
]	O
)	O
;	O
float	O
tj	float
=	O
J	O
(	O
left_corner	array
[	O
k	int
-	O
1	int
]	O
)	O
;	O
float	O
bi	float
=	O
I	O
(	O
left_corner	array
[	O
k	int
]	O
)	O
;	O
float	O
bj	float
=	O
J	O
(	O
left_corner	array
[	O
k	int
]	O
)	O
;	O
if	O
(	O
0	int
)	O
gprintf	function
(	O
"(left) %d: %1m %1m\n"	pointer
,	O
m	int
,	O
left_corner	array
[	O
k	int
-	O
1	int
]	O
,	O
left_corner	array
[	O
k	int
]	O
)	O
;	O
left_boundary	int
=	O
ceil	function
(	O
tj	float
+	O
(	O
m	int
-	O
ti	float
)	O
*	O
(	O
bj	float
-	O
tj	float
)	O
/	O
(	O
bi	float
-	O
ti	float
)	O
)	O
;	O
break	O
;	O
}	O
}	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<	O
right_corners	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
I	O
(	O
right_corner	array
[	O
k	int
]	O
)	O
>	O
m	int
)	O
{	O
float	O
ti	float
=	O
I	O
(	O
right_corner	array
[	O
k	int
-	O
1	int
]	O
)	O
;	O
float	O
tj	float
=	O
J	O
(	O
right_corner	array
[	O
k	int
-	O
1	int
]	O
)	O
;	O
float	O
bi	float
=	O
I	O
(	O
right_corner	array
[	O
k	int
]	O
)	O
;	O
float	O
bj	float
=	O
J	O
(	O
right_corner	array
[	O
k	int
]	O
)	O
;	O
if	O
(	O
0	int
)	O
gprintf	function
(	O
"(right) %d: %1m %1m\n"	pointer
,	O
m	int
,	O
right_corner	array
[	O
k	int
-	O
1	int
]	O
,	O
right_corner	array
[	O
k	int
]	O
)	O
;	O
right_boundary	int
=	O
floor	function
(	O
tj	float
+	O
(	O
m	int
-	O
ti	float
)	O
*	O
(	O
bj	float
-	O
tj	float
)	O
/	O
(	O
bi	float
-	O
ti	float
)	O
)	O
;	O
break	O
;	O
}	O
}	O
for	O
(	O
n	int
=	O
left_boundary	int
;	O
n	int
<=	O
right_boundary	int
;	O
n	int
++	O
)	O
mn	array
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
=	O
1	int
;	O
}	O
for	O
(	O
dpos	int
=	O
BOARDMIN	O
;	O
dpos	int
<	O
BOARDMAX	O
;	O
dpos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
dpos	int
)	O
&&	O
mn	array
[	O
dpos	int
]	O
==	O
1	int
)	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
dpos	int
+	O
delta	array
[	O
k	int
]	O
)	O
&&	O
!	O
mn	array
[	O
dpos	int
+	O
delta	array
[	O
k	int
]	O
]	O
)	O
mn	array
[	O
dpos	int
+	O
delta	array
[	O
k	int
]	O
]	O
=	O
2	int
;	O
for	O
(	O
dpos	int
=	O
BOARDMIN	O
;	O
dpos	int
<	O
BOARDMAX	O
;	O
dpos	int
++	O
)	O
{	O
int	O
mpos	int
;	O
if	O
(	O
ON_BOARD	O
(	O
dpos	int
)	O
&&	O
mn	array
[	O
dpos	int
]	O
==	O
1	int
&&	O
board	pointer
[	O
dpos	int
]	O
==	O
color	int
&&	O
are_neighbor_dragons	function
(	O
pos	int
,	O
dpos	int
)	O
&&	O
!	O
mf	array
[	O
dpos	int
]	O
)	O
{	O
for	O
(	O
mpos	int
=	O
BOARDMIN	O
;	O
mpos	int
<	O
BOARDMAX	O
;	O
mpos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
mpos	int
)	O
&&	O
is_same_dragon	function
(	O
mpos	int
,	O
dpos	int
)	O
)	O
mf	array
[	O
mpos	int
]	O
=	O
2	int
;	O
}	O
if	O
(	O
ON_BOARD	O
(	O
dpos	int
)	O
&&	O
mn	array
[	O
dpos	int
]	O
==	O
2	int
&&	O
board	pointer
[	O
dpos	int
]	O
==	O
color	int
&&	O
are_neighbor_dragons	function
(	O
pos	int
,	O
dpos	int
)	O
&&	O
!	O
mf	array
[	O
dpos	int
]	O
)	O
{	O
for	O
(	O
k	int
=	O
4	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
dpos	int
+	O
delta	array
[	O
k	int
]	O
)	O
&&	O
board	pointer
[	O
dpos	int
+	O
delta	array
[	O
k	int
]	O
]	O
==	O
color	int
&&	O
mn	array
[	O
dpos	int
+	O
delta	array
[	O
k	int
]	O
]	O
==	O
1	int
&&	O
board	pointer
[	O
dpos	int
+	O
delta	array
[	O
k	int
-	O
4	int
]	O
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
dpos	int
+	O
delta	array
[	O
(	O
k	int
-	O
3	int
)	O
%	O
4	int
]	O
]	O
==	O
EMPTY	int
)	O
{	O
for	O
(	O
mpos	int
=	O
BOARDMIN	O
;	O
mpos	int
<	O
BOARDMAX	O
;	O
mpos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
mpos	int
)	O
&&	O
is_same_dragon	function
(	O
mpos	int
,	O
dpos	int
)	O
)	O
mf	array
[	O
mpos	int
]	O
=	O
2	int
;	O
}	O
}	O
}	O
surrounded	int
=	O
SURROUNDED	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
corners	int
-	O
1	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
is_edge_vertex	function
(	O
corner	array
[	O
k	int
]	O
)	O
&&	O
is_edge_vertex	function
(	O
corner	array
[	O
k	int
+	O
1	int
]	O
)	O
)	O
continue	O
;	O
if	O
(	O
square_dist	function
(	O
corner	array
[	O
k	int
]	O
,	O
corner	array
[	O
k	int
+	O
1	int
]	O
)	O
>	O
60	int
)	O
{	O
surrounded	int
=	O
0	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
square_dist	function
(	O
corner	array
[	O
k	int
]	O
,	O
corner	array
[	O
k	int
+	O
1	int
]	O
)	O
>	O
27	int
)	O
surrounded	int
=	O
WEAKLY_SURROUNDED	int
;	O
}	O
if	O
(	O
surrounded	int
&&	O
(	O
!	O
is_edge_vertex	function
(	O
corner	array
[	O
0	int
]	O
)	O
||	O
!	O
is_edge_vertex	function
(	O
corner	array
[	O
corners	int
-	O
1	int
]	O
)	O
)	O
)	O
{	O
if	O
(	O
square_dist	function
(	O
corner	array
[	O
0	int
]	O
,	O
corner	array
[	O
corners	int
-	O
1	int
]	O
)	O
>	O
60	int
)	O
surrounded	int
=	O
0	int
;	O
else	O
if	O
(	O
square_dist	function
(	O
corner	array
[	O
0	int
]	O
,	O
corner	array
[	O
corners	int
-	O
1	int
]	O
)	O
>	O
27	int
)	O
surrounded	int
=	O
WEAKLY_SURROUNDED	int
;	O
}	O
if	O
(	O
surrounded	int
)	O
for	O
(	O
dpos	int
=	O
BOARDMIN	O
;	O
dpos	int
<	O
BOARDMAX	O
;	O
dpos	int
++	O
)	O
if	O
(	O
mf	array
[	O
dpos	int
]	O
)	O
{	O
if	O
(	O
mn	array
[	O
dpos	int
]	O
==	O
0	int
)	O
{	O
surrounded	int
=	O
0	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
mn	array
[	O
dpos	int
]	O
==	O
2	int
)	O
surrounded	int
=	O
WEAKLY_SURROUNDED	int
;	O
}	O
if	O
(	O
stones	pointer
==	O
1	int
&&	O
surrounded	int
==	O
WEAKLY_SURROUNDED	int
&&	O
mn	array
[	O
pos	int
]	O
==	O
2	int
)	O
surrounded	int
=	O
0	int
;	O
if	O
(	O
surrounded	int
)	O
{	O
for	O
(	O
dpos	int
=	O
BOARDMIN	O
;	O
dpos	int
<	O
BOARDMAX	O
&&	O
surrounded	int
;	O
dpos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
dpos	int
)	O
||	O
!	O
mf	array
[	O
dpos	int
]	O
)	O
continue	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
up	int
=	O
delta	array
[	O
k	int
]	O
;	O
int	O
right	int
=	O
delta	array
[	O
(	O
k	int
+	O
1	int
)	O
%	O
4	int
]	O
;	O
if	O
(	O
board	pointer
[	O
dpos	int
+	O
up	int
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
dpos	int
+	O
2	int
*	O
up	int
]	O
==	O
color	int
&&	O
mn	array
[	O
dpos	int
+	O
2	int
*	O
up	int
]	O
!=	O
1	int
&&	O
ON_BOARD	O
(	O
dpos	int
+	O
up	int
+	O
right	int
)	O
&&	O
board	pointer
[	O
dpos	int
+	O
up	int
+	O
right	int
]	O
!=	O
other	int
&&	O
ON_BOARD	O
(	O
dpos	int
+	O
up	int
-	O
right	int
)	O
&&	O
board	pointer
[	O
dpos	int
+	O
up	int
-	O
right	int
]	O
!=	O
other	int
)	O
{	O
surrounded	int
=	O
0	int
;	O
break	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
showboard	function
==	O
1	int
||	O
(	O
showboard	function
==	O
2	int
&&	O
surrounded	int
)	O
)	O
{	O
show_surround_map	function
(	O
mf	array
,	O
mn	array
)	O
;	O
}	O
if	O
(	O
!	O
apos	int
&&	O
surrounded	int
&&	O
surround_pointer	int
<	O
MAX_SURROUND	int
)	O
{	O
memcpy	function
(	O
surroundings	array
[	O
surround_pointer	int
]	O
.	O
surround_map	function
,	O
mn	array
,	O
sizeof	O
(	O
mn	array
)	O
)	O
;	O
surroundings	array
[	O
surround_pointer	int
]	O
.	O
dragon_number	int
=	O
dragon	int
[	O
pos	int
]	O
.	O
id	int
;	O
surround_pointer	int
++	O
;	O
}	O
if	O
(	O
surround_size	pointer
)	O
{	O
int	O
pos	int
;	O
*	O
surround_size	pointer
=	O
0	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
mn	array
[	O
pos	int
]	O
==	O
1	int
)	O
(	O
*	O
surround_size	pointer
)	O
++	O
;	O
}	O
return	O
surrounded	int
;	O
}	O
static	O
int	O
goal_dist	function
(	O
int	O
pos	int
,	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
dist	int
=	O
10000	int
;	O
int	O
ii	int
;	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
ii	int
)	O
&&	O
goal	pointer
[	O
ii	int
]	O
)	O
dist	int
=	O
gg_min	O
(	O
dist	int
,	O
square_dist	function
(	O
ii	int
,	O
pos	int
)	O
)	O
;	O
return	O
dist	int
;	O
}	O
static	O
int	O
compare_angles	function
(	O
const	O
void	O
*	O
a	char
,	O
const	O
void	O
*	O
b	char
)	O
{	O
int	O
aa	int
=	O
*	O
(	O
(	O
const	O
int	O
*	O
)	O
a	char
)	O
;	O
int	O
bb	int
=	O
*	O
(	O
(	O
const	O
int	O
*	O
)	O
b	char
)	O
;	O
int	O
di_a	int
=	O
I	O
(	O
aa	int
)	O
-	O
I	O
(	O
gg	int
)	O
;	O
int	O
dj_a	int
=	O
J	O
(	O
aa	int
)	O
-	O
J	O
(	O
gg	int
)	O
;	O
int	O
di_b	int
=	O
I	O
(	O
bb	int
)	O
-	O
I	O
(	O
gg	int
)	O
;	O
int	O
dj_b	int
=	O
J	O
(	O
bb	int
)	O
-	O
J	O
(	O
gg	int
)	O
;	O
float	O
sin_a	float
,	O
sin_b	float
;	O
if	O
(	O
aa	int
==	O
gg	int
)	O
return	O
1	int
;	O
if	O
(	O
bb	int
==	O
gg	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
dj_a	int
==	O
0	int
)	O
{	O
if	O
(	O
di_a	int
>	O
0	int
)	O
{	O
if	O
(	O
dj_b	int
!=	O
0	int
||	O
di_b	int
<=	O
0	int
)	O
return	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
dj_b	int
>	O
0	int
)	O
return	O
-	O
1	int
;	O
else	O
if	O
(	O
dj_b	int
<	O
0	int
||	O
di_b	int
>	O
0	int
)	O
return	O
1	int
;	O
else	O
return	O
0	int
;	O
}	O
}	O
sin_a	float
=	O
(	O
float	O
)	O
di_a	int
/	O
sqrt	function
(	O
di_a	int
*	O
di_a	int
+	O
dj_a	int
*	O
dj_a	int
)	O
;	O
sin_b	float
=	O
(	O
float	O
)	O
di_b	int
/	O
sqrt	function
(	O
di_b	int
*	O
di_b	int
+	O
dj_b	int
*	O
dj_b	int
)	O
;	O
if	O
(	O
dj_a	int
>	O
0	int
)	O
{	O
if	O
(	O
dj_b	int
<=	O
0	int
)	O
return	O
1	int
;	O
if	O
(	O
sin_a	float
>	O
sin_b	float
)	O
return	O
1	int
;	O
else	O
if	O
(	O
sin_a	float
<	O
sin_b	float
)	O
return	O
-	O
1	int
;	O
else	O
return	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
dj_b	int
>	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
sin_a	float
<	O
sin_b	float
)	O
return	O
1	int
;	O
else	O
if	O
(	O
sin_a	float
>	O
sin_b	float
)	O
return	O
-	O
1	int
;	O
else	O
return	O
0	int
;	O
}	O
}	O
static	O
void	O
show_surround_map	function
(	O
signed	O
char	O
mf	array
[	O
BOARDMAX	O
]	O
,	O
signed	O
char	O
mn	array
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
m	int
,	O
n	int
;	O
start_draw_board	function
(	O
)	O
;	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
board_size	int
;	O
m	int
++	O
)	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
board_size	int
;	O
n	int
++	O
)	O
{	O
int	O
col	int
,	O
c	char
;	O
if	O
(	O
mf	array
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
)	O
{	O
if	O
(	O
mn	array
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
==	O
1	int
)	O
col	int
=	O
GG_COLOR_RED	int
;	O
else	O
if	O
(	O
mn	array
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
==	O
2	int
)	O
col	int
=	O
GG_COLOR_YELLOW	int
;	O
else	O
col	int
=	O
GG_COLOR_GREEN	int
;	O
}	O
else	O
if	O
(	O
mn	array
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
==	O
1	int
)	O
col	int
=	O
GG_COLOR_BLUE	int
;	O
else	O
if	O
(	O
mn	array
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
==	O
2	int
)	O
col	int
=	O
GG_COLOR_CYAN	int
;	O
else	O
col	int
=	O
GG_COLOR_BLACK	int
;	O
if	O
(	O
board	pointer
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
==	O
BLACK	int
)	O
c	char
=	O
'X'	O
;	O
else	O
if	O
(	O
board	pointer
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
==	O
WHITE	int
)	O
c	char
=	O
'O'	O
;	O
else	O
if	O
(	O
mn	array
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
)	O
c	char
=	O
'*'	O
;	O
else	O
c	char
=	O
'.'	O
;	O
draw_color_char	function
(	O
m	int
,	O
n	int
,	O
c	char
,	O
col	int
)	O
;	O
}	O
end_draw_board	function
(	O
)	O
;	O
}	O
int	O
is_surrounded	function
(	O
int	O
dr	int
)	O
{	O
return	O
(	O
DRAGON2	O
(	O
dr	int
)	O
.	O
surround_status	int
)	O
;	O
}	O
int	O
does_surround	function
(	O
int	O
move	pointer
,	O
int	O
dr	int
)	O
{	O
if	O
(	O
DRAGON2	O
(	O
dr	int
)	O
.	O
surround_status	int
)	O
return	O
0	int
;	O
return	O
compute_surroundings	function
(	O
dr	int
,	O
move	pointer
,	O
0	int
,	O
NULL	O
)	O
;	O
}	O
void	O
reset_surround_data	function
(	O
void	O
)	O
{	O
surround_pointer	int
=	O
0	int
;	O
}	O
int	O
surround_map	function
(	O
int	O
dr	int
,	O
int	O
pos	int
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
surround_pointer	int
;	O
k	int
++	O
)	O
if	O
(	O
surroundings	array
[	O
k	int
]	O
.	O
dragon_number	int
==	O
dragon	int
[	O
dr	int
]	O
.	O
id	int
)	O
return	O
surroundings	array
[	O
k	int
]	O
.	O
surround_map	function
[	O
pos	int
]	O
;	O
return	O
-	O
1	int
;	O
}	O
