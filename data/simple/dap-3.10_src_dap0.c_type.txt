dataobs	struct
dap_obs	array
[	O
3	int
]	O
;	O
dataobs	struct
dap_prev	array
[	O
2	int
]	O
;	O
static	O
dataobs	struct
dosave	struct
;	O
static	O
RFILE	struct
*	O
rfile	pointer
;	O
static	O
DFILE	struct
*	O
dfile	pointer
;	O
DFILE	struct
*	O
dap_in	array
[	O
3	int
]	O
;	O
DFILE	struct
*	O
dap_out	array
[	O
3	int
]	O
;	O
FILE	struct
*	O
dap_lst	pointer
;	O
FILE	struct
*	O
dap_log	pointer
;	O
FILE	struct
*	O
dap_err	pointer
;	O
int	O
dap_ono	int
;	O
int	O
dap_delim	int
;	O
static	O
int	O
*	O
fieldwd	pointer
;	O
static	O
int	O
nfields	int
;	O
static	O
int	O
lineno	array
[	O
2	int
]	O
;	O
static	O
int	O
outline	int
;	O
static	O
int	O
pageno	int
;	O
static	O
int	O
eof	array
[	O
2	int
]	O
;	O
static	O
long	O
filepos	array
[	O
2	int
]	O
;	O
static	O
int	O
intype	int
;	O
static	O
int	O
inlen	int
;	O
static	O
int	O
toolong	int
;	O
char	O
*	O
dap_title	pointer
=	O
NULL	O
;	O
char	O
*	O
dap_dapname	pointer
;	O
char	O
*	O
dap_psname	pointer
;	O
extern	O
int	O
dap_dblhigh	int
;	O
extern	O
int	O
dap_dbllow	int
;	O
extern	O
double	O
dap_double	double
;	O
static	O
int	O
nmallocs	int
=	O
0	int
;	O
static	O
int	O
nfrees	int
=	O
0	int
;	O
char	O
*	O
dap_malloc	function
(	O
int	O
nbytes	int
,	O
char	O
*	O
mesg	pointer
)	O
{	O
char	O
*	O
m	pointer
;	O
nmallocs	int
++	O
;	O
if	O
(	O
!	O
(	O
m	pointer
=	O
malloc	function
(	O
nbytes	int
)	O
)	O
)	O
{	O
perror	function
(	O
dap_dapname	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
dap_memtrace	pointer
)	O
{	O
fprintf	function
(	O
dap_log	pointer
,	O
"malloc %x %s\n"	pointer
,	O
(	O
unsigned	O
int	O
)	O
m	pointer
,	O
mesg	pointer
)	O
;	O
fflush	function
(	O
dap_log	pointer
)	O
;	O
if	O
(	O
dap_mabort	int
&&	O
m	pointer
==	O
dap_memtrace	pointer
)	O
abort	function
(	O
)	O
;	O
}	O
return	O
m	pointer
;	O
}	O
void	O
dap_free	function
(	O
void	O
*	O
ptr	pointer
,	O
char	O
*	O
mesg	pointer
)	O
{	O
nfrees	int
++	O
;	O
if	O
(	O
dap_memtrace	pointer
)	O
{	O
fprintf	function
(	O
dap_log	pointer
,	O
"free %x %s\n"	pointer
,	O
(	O
unsigned	O
int	O
)	O
ptr	pointer
,	O
mesg	pointer
)	O
;	O
fflush	function
(	O
dap_log	pointer
)	O
;	O
if	O
(	O
dap_fabort	int
&&	O
ptr	pointer
==	O
dap_memtrace	pointer
)	O
abort	function
(	O
)	O
;	O
}	O
free	function
(	O
ptr	pointer
)	O
;	O
}	O
static	O
void	O
initdo	function
(	O
dataobs	struct
*	O
dato	pointer
)	O
{	O
int	O
d	int
;	O
dato	pointer
->	O
do_int	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"initdo: dato->do_int"	pointer
)	O
;	O
dato	pointer
->	O
do_il	pointer
=	O
(	O
int	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
*	O
)	O
*	O
dap_maxvar	int
,	O
"initdo: dato->do_il"	pointer
)	O
;	O
dato	pointer
->	O
do_dbl	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
dap_maxvar	int
,	O
"initdo: dato->do_dbl"	pointer
)	O
;	O
dato	pointer
->	O
do_dl	pointer
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
*	O
)	O
*	O
dap_maxvar	int
,	O
"initdo: dato->do_dl"	pointer
)	O
;	O
dato	pointer
->	O
do_str	pointer
=	O
(	O
char	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
dap_maxvar	int
,	O
"initdo: dato->do_str"	pointer
)	O
;	O
dato	pointer
->	O
do_sl	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"initdo: dato->do_sl"	pointer
)	O
;	O
dato	pointer
->	O
do_nam	pointer
=	O
(	O
char	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
dap_maxvar	int
,	O
"initdo: dato->do_nam"	pointer
)	O
;	O
dato	pointer
->	O
do_len	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"initdo: dato->do_len"	pointer
)	O
;	O
dato	pointer
->	O
do_in	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"initdo: dato->do_in"	pointer
)	O
;	O
dato	pointer
->	O
do_out	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"initdo: dato->do_out"	pointer
)	O
;	O
for	O
(	O
d	int
=	O
0	int
;	O
d	int
<	O
dap_maxvar	int
;	O
d	int
++	O
)	O
{	O
dato	pointer
->	O
do_str	pointer
[	O
d	int
]	O
=	O
NULL	O
;	O
dato	pointer
->	O
do_nam	pointer
[	O
d	int
]	O
=	O
NULL	O
;	O
}	O
}	O
static	O
double	O
testd	double
;	O
static	O
unsigned	O
int	O
*	O
ptesti	pointer
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
char	O
*	O
lstname	pointer
;	O
char	O
*	O
logname	pointer
;	O
char	O
*	O
errname	pointer
;	O
int	O
len	int
;	O
int	O
v	int
;	O
dap_dapname	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
len	int
=	O
strlen	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
lstname	pointer
=	O
malloc	function
(	O
len	int
+	O
5	int
)	O
;	O
strcpy	function
(	O
lstname	pointer
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
if	O
(	O
len	int
>=	O
4	int
&&	O
!	O
strcmp	function
(	O
lstname	pointer
+	O
len	int
-	O
4	int
,	O
".dap"	pointer
)	O
)	O
strcpy	function
(	O
lstname	pointer
+	O
len	int
-	O
3	int
,	O
"lst"	pointer
)	O
;	O
else	O
{	O
strcat	function
(	O
lstname	pointer
,	O
".lst"	pointer
)	O
;	O
len	int
+=	O
4	int
;	O
}	O
if	O
(	O
!	O
(	O
dap_lst	pointer
=	O
fopen	function
(	O
lstname	pointer
,	O
"a"	pointer
)	O
)	O
)	O
{	O
perror	function
(	O
dap_dapname	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
logname	pointer
=	O
malloc	function
(	O
len	int
+	O
1	int
)	O
;	O
strcpy	function
(	O
logname	pointer
,	O
lstname	pointer
)	O
;	O
strcpy	function
(	O
logname	pointer
+	O
len	int
-	O
3	int
,	O
"log"	pointer
)	O
;	O
if	O
(	O
!	O
(	O
dap_log	pointer
=	O
fopen	function
(	O
logname	pointer
,	O
"w"	pointer
)	O
)	O
)	O
{	O
perror	function
(	O
dap_dapname	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
errname	pointer
=	O
malloc	function
(	O
len	int
+	O
1	int
)	O
;	O
strcpy	function
(	O
errname	pointer
,	O
lstname	pointer
)	O
;	O
strcpy	function
(	O
errname	pointer
+	O
len	int
-	O
3	int
,	O
"err"	pointer
)	O
;	O
if	O
(	O
!	O
(	O
dap_err	pointer
=	O
fopen	function
(	O
errname	pointer
,	O
"w"	pointer
)	O
)	O
)	O
{	O
perror	function
(	O
dap_dapname	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
initdo	function
(	O
dap_obs	array
)	O
;	O
initdo	function
(	O
dap_obs	array
+	O
1	int
)	O
;	O
initdo	function
(	O
dap_obs	array
+	O
2	int
)	O
;	O
initdo	function
(	O
dap_prev	array
)	O
;	O
initdo	function
(	O
dap_prev	array
+	O
1	int
)	O
;	O
initdo	function
(	O
&	O
dosave	struct
)	O
;	O
rfile	pointer
=	O
(	O
RFILE	struct
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
RFILE	struct
)	O
*	O
dap_nrfiles	int
,	O
"main: rfile"	pointer
)	O
;	O
dfile	pointer
=	O
(	O
DFILE	struct
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
DFILE	struct
)	O
*	O
(	O
dap_nrfiles	int
+	O
NDFILES	int
)	O
,	O
"main: dfile"	pointer
)	O
;	O
pageno	int
=	O
1	int
;	O
dap_psname	pointer
=	O
dap_malloc	function
(	O
len	int
+	O
1	int
,	O
"main: dap_psname"	pointer
)	O
;	O
strcpy	function
(	O
dap_psname	pointer
,	O
lstname	pointer
)	O
;	O
strcpy	function
(	O
dap_psname	pointer
+	O
len	int
-	O
3	int
,	O
"ps"	pointer
)	O
;	O
dap_initpict	function
(	O
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
dap_maxvar	int
;	O
v	int
++	O
)	O
{	O
for	O
(	O
dap_ono	int
=	O
0	int
;	O
dap_ono	int
<	O
3	int
;	O
dap_ono	int
++	O
)	O
{	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
v	int
]	O
=	O
NULL	O
;	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dl	pointer
[	O
v	int
]	O
=	O
NULL	O
;	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_il	pointer
[	O
v	int
]	O
=	O
NULL	O
;	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
v	int
]	O
=	O
NULL	O
;	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_sl	pointer
[	O
v	int
]	O
=	O
0	int
;	O
if	O
(	O
dap_ono	int
<	O
2	int
)	O
dap_prev	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
v	int
]	O
=	O
NULL	O
;	O
}	O
dosave	struct
.	O
do_str	pointer
[	O
v	int
]	O
=	O
NULL	O
;	O
}	O
dap_ono	int
=	O
0	int
;	O
testd	double
=	O
-	O
2.0	int
;	O
ptesti	pointer
=	O
(	O
int	O
*	O
)	O
&	O
testd	double
;	O
if	O
(	O
!	O
(	O
*	O
ptesti	pointer
)	O
)	O
{	O
dap_dbllow	int
=	O
0	int
;	O
dap_dblhigh	int
=	O
1	int
;	O
}	O
else	O
{	O
dap_dbllow	int
=	O
1	int
;	O
dap_dblhigh	int
=	O
0	int
;	O
}	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
3	int
;	O
v	int
++	O
)	O
{	O
dap_in	array
[	O
v	int
]	O
=	O
(	O
DFILE	struct
*	O
)	O
NULL	O
;	O
dap_out	array
[	O
v	int
]	O
=	O
(	O
DFILE	struct
*	O
)	O
NULL	O
;	O
}	O
dap_main	function
(	O
argc	int
,	O
argv	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
FILE	struct
*	O
dopen	function
(	O
char	O
fname	array
[	O
]	O
,	O
char	O
mode	array
[	O
]	O
)	O
{	O
char	O
*	O
dname	array
;	O
FILE	struct
*	O
f	pointer
;	O
dname	array
=	O
dap_malloc	function
(	O
strlen	function
(	O
fname	array
)	O
+	O
strlen	function
(	O
dap_setdir	pointer
)	O
+	O
2	int
,	O
"dopen: dname"	pointer
)	O
;	O
dap_name	function
(	O
dname	array
,	O
fname	array
)	O
;	O
f	pointer
=	O
fopen	function
(	O
dname	array
,	O
mode	array
)	O
;	O
dap_free	function
(	O
dname	array
,	O
"dopen: dname"	pointer
)	O
;	O
return	O
f	pointer
;	O
}	O
static	O
DFILE	struct
*	O
dfopen	function
(	O
char	O
*	O
fname	array
,	O
char	O
*	O
mode	array
)	O
{	O
static	O
int	O
rfileinit	int
=	O
0	int
;	O
int	O
f	pointer
;	O
char	O
truemode	array
[	O
2	int
]	O
;	O
if	O
(	O
!	O
rfileinit	int
)	O
{	O
rfileinit	int
=	O
1	int
;	O
for	O
(	O
f	pointer
=	O
0	int
;	O
f	pointer
<	O
dap_nrfiles	int
;	O
f	pointer
++	O
)	O
{	O
dfile	pointer
[	O
NDFILES	int
+	O
f	pointer
]	O
.	O
dfile_name	pointer
=	O
NULL	O
;	O
dfile	pointer
[	O
NDFILES	int
+	O
f	pointer
]	O
.	O
dfile_ram	pointer
=	O
rfile	pointer
+	O
f	pointer
;	O
dfile	pointer
[	O
NDFILES	int
+	O
f	pointer
]	O
.	O
dfile_disk	pointer
=	O
NULL	O
;	O
rfile	pointer
[	O
f	pointer
]	O
.	O
rfile_str	pointer
=	O
NULL	O
;	O
}	O
for	O
(	O
f	pointer
=	O
0	int
;	O
f	pointer
<	O
NDFILES	int
;	O
f	pointer
++	O
)	O
{	O
dfile	pointer
[	O
f	pointer
]	O
.	O
dfile_disk	pointer
=	O
NULL	O
;	O
dfile	pointer
[	O
f	pointer
]	O
.	O
dfile_ram	pointer
=	O
NULL	O
;	O
}	O
}	O
if	O
(	O
!	O
fname	array
)	O
{	O
fputs	function
(	O
"(dfopen) no file name given\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
fname	array
[	O
0	int
]	O
==	O
'<'	O
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
mode	array
,	O
"r"	pointer
)	O
)	O
{	O
for	O
(	O
f	pointer
=	O
0	int
;	O
f	pointer
<	O
dap_nrfiles	int
;	O
f	pointer
++	O
)	O
{	O
if	O
(	O
dfile	pointer
[	O
NDFILES	int
+	O
f	pointer
]	O
.	O
dfile_name	pointer
&&	O
!	O
strcmp	function
(	O
dfile	pointer
[	O
NDFILES	int
+	O
f	pointer
]	O
.	O
dfile_name	pointer
,	O
fname	array
+	O
1	int
)	O
)	O
{	O
rfile	pointer
[	O
f	pointer
]	O
.	O
rfile_pos	pointer
=	O
rfile	pointer
[	O
f	pointer
]	O
.	O
rfile_str	pointer
;	O
return	O
dfile	pointer
+	O
NDFILES	int
+	O
f	pointer
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
mode	array
,	O
"w"	pointer
)	O
)	O
{	O
for	O
(	O
f	pointer
=	O
0	int
;	O
f	pointer
<	O
dap_nrfiles	int
;	O
f	pointer
++	O
)	O
{	O
if	O
(	O
dfile	pointer
[	O
NDFILES	int
+	O
f	pointer
]	O
.	O
dfile_name	pointer
&&	O
!	O
strcmp	function
(	O
dfile	pointer
[	O
NDFILES	int
+	O
f	pointer
]	O
.	O
dfile_name	pointer
,	O
fname	array
+	O
1	int
)	O
)	O
{	O
rfile	pointer
[	O
f	pointer
]	O
.	O
rfile_end	pointer
=	O
rfile	pointer
[	O
f	pointer
]	O
.	O
rfile_str	pointer
;	O
rfile	pointer
[	O
f	pointer
]	O
.	O
rfile_pos	pointer
=	O
rfile	pointer
[	O
f	pointer
]	O
.	O
rfile_str	pointer
;	O
return	O
dfile	pointer
+	O
NDFILES	int
+	O
f	pointer
;	O
}	O
}	O
for	O
(	O
f	pointer
=	O
0	int
;	O
f	pointer
<	O
dap_nrfiles	int
;	O
f	pointer
++	O
)	O
{	O
if	O
(	O
!	O
dfile	pointer
[	O
NDFILES	int
+	O
f	pointer
]	O
.	O
dfile_name	pointer
)	O
{	O
rfile	pointer
[	O
f	pointer
]	O
.	O
rfile_str	pointer
=	O
dap_malloc	function
(	O
dap_rfilesize	int
,	O
"dfopen: rfile[f].rfile_str"	pointer
)	O
;	O
dfile	pointer
[	O
NDFILES	int
+	O
f	pointer
]	O
.	O
dfile_name	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
fname	array
)	O
,	O
"dfopen: dfile[NDFILES + f].dfile_name"	pointer
)	O
;	O
strcpy	function
(	O
dfile	pointer
[	O
NDFILES	int
+	O
f	pointer
]	O
.	O
dfile_name	pointer
,	O
fname	array
+	O
1	int
)	O
;	O
rfile	pointer
[	O
f	pointer
]	O
.	O
rfile_end	pointer
=	O
rfile	pointer
[	O
f	pointer
]	O
.	O
rfile_str	pointer
;	O
rfile	pointer
[	O
f	pointer
]	O
.	O
rfile_pos	pointer
=	O
rfile	pointer
[	O
f	pointer
]	O
.	O
rfile_str	pointer
;	O
return	O
dfile	pointer
+	O
NDFILES	int
+	O
f	pointer
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
mode	array
,	O
"a"	pointer
)	O
)	O
{	O
for	O
(	O
f	pointer
=	O
0	int
;	O
f	pointer
<	O
dap_nrfiles	int
;	O
f	pointer
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
dfile	pointer
[	O
NDFILES	int
+	O
f	pointer
]	O
.	O
dfile_name	pointer
,	O
fname	array
+	O
1	int
)	O
)	O
{	O
rfile	pointer
[	O
f	pointer
]	O
.	O
rfile_pos	pointer
=	O
rfile	pointer
[	O
f	pointer
]	O
.	O
rfile_end	pointer
;	O
return	O
dfile	pointer
+	O
NDFILES	int
+	O
f	pointer
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dfopen) bad mode: %s\n"	pointer
,	O
mode	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
for	O
(	O
f	pointer
=	O
0	int
;	O
f	pointer
<	O
NDFILES	int
;	O
f	pointer
++	O
)	O
{	O
if	O
(	O
!	O
dfile	pointer
[	O
f	pointer
]	O
.	O
dfile_disk	pointer
)	O
{	O
if	O
(	O
mode	array
[	O
1	int
]	O
==	O
'f'	O
)	O
{	O
truemode	array
[	O
0	int
]	O
=	O
mode	array
[	O
0	int
]	O
;	O
truemode	array
[	O
1	int
]	O
=	O
'\0'	O
;	O
dfile	pointer
[	O
f	pointer
]	O
.	O
dfile_disk	pointer
=	O
fopen	function
(	O
fname	array
,	O
truemode	array
)	O
;	O
}	O
else	O
dfile	pointer
[	O
f	pointer
]	O
.	O
dfile_disk	pointer
=	O
dopen	function
(	O
fname	array
,	O
mode	array
)	O
;	O
if	O
(	O
dfile	pointer
[	O
f	pointer
]	O
.	O
dfile_disk	pointer
)	O
{	O
dfile	pointer
[	O
f	pointer
]	O
.	O
dfile_name	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
fname	array
)	O
+	O
1	int
,	O
"dfopen: dfile[f].dfile_name"	pointer
)	O
;	O
strcpy	function
(	O
dfile	pointer
[	O
f	pointer
]	O
.	O
dfile_name	pointer
,	O
fname	array
)	O
;	O
return	O
dfile	pointer
+	O
f	pointer
;	O
}	O
else	O
return	O
NULL	O
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
static	O
void	O
dfclose	function
(	O
DFILE	struct
*	O
fp	pointer
)	O
{	O
if	O
(	O
fp	pointer
->	O
dfile_disk	pointer
)	O
{	O
fclose	function
(	O
fp	pointer
->	O
dfile_disk	pointer
)	O
;	O
fp	pointer
->	O
dfile_disk	pointer
=	O
NULL	O
;	O
}	O
else	O
fp	pointer
->	O
dfile_ram	pointer
->	O
rfile_pos	pointer
=	O
fp	pointer
->	O
dfile_ram	pointer
->	O
rfile_str	pointer
;	O
}	O
static	O
int	O
dgetc	function
(	O
DFILE	struct
*	O
fp	pointer
)	O
{	O
int	O
c	int
;	O
if	O
(	O
fp	pointer
->	O
dfile_disk	pointer
)	O
c	int
=	O
getc	function
(	O
fp	pointer
->	O
dfile_disk	pointer
)	O
;	O
else	O
if	O
(	O
fp	pointer
->	O
dfile_ram	pointer
->	O
rfile_pos	pointer
<	O
fp	pointer
->	O
dfile_ram	pointer
->	O
rfile_end	pointer
)	O
c	int
=	O
*	O
fp	pointer
->	O
dfile_ram	pointer
->	O
rfile_pos	pointer
++	O
;	O
else	O
c	int
=	O
EOF	O
;	O
return	O
c	int
;	O
}	O
static	O
void	O
undgetc	function
(	O
int	O
c	int
,	O
DFILE	struct
*	O
fp	pointer
)	O
{	O
if	O
(	O
fp	pointer
->	O
dfile_disk	pointer
)	O
ungetc	function
(	O
c	int
,	O
fp	pointer
->	O
dfile_disk	pointer
)	O
;	O
else	O
if	O
(	O
fp	pointer
->	O
dfile_ram	pointer
->	O
rfile_pos	pointer
>	O
fp	pointer
->	O
dfile_ram	pointer
->	O
rfile_str	pointer
)	O
{	O
--	O
fp	pointer
->	O
dfile_ram	pointer
->	O
rfile_pos	pointer
;	O
*	O
fp	pointer
->	O
dfile_ram	pointer
->	O
rfile_pos	pointer
=	O
c	int
;	O
}	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(undgetc) can't unget past beginning of file %s\n"	pointer
,	O
fp	pointer
->	O
dfile_name	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
void	O
dap_putc	function
(	O
int	O
c	int
,	O
DFILE	struct
*	O
fp	pointer
)	O
{	O
if	O
(	O
fp	pointer
->	O
dfile_disk	pointer
)	O
putc	function
(	O
c	int
,	O
fp	pointer
->	O
dfile_disk	pointer
)	O
;	O
else	O
if	O
(	O
fp	pointer
->	O
dfile_ram	pointer
->	O
rfile_pos	pointer
<	O
fp	pointer
->	O
dfile_ram	pointer
->	O
rfile_str	pointer
+	O
dap_rfilesize	int
)	O
{	O
*	O
fp	pointer
->	O
dfile_ram	pointer
->	O
rfile_pos	pointer
++	O
=	O
c	int
;	O
fp	pointer
->	O
dfile_ram	pointer
->	O
rfile_end	pointer
++	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dap_putc) too many characters: %s\n"	pointer
,	O
fp	pointer
->	O
dfile_name	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
static	O
void	O
dputs	function
(	O
char	O
*	O
s	pointer
,	O
char	O
*	O
suff	array
,	O
DFILE	struct
*	O
fp	pointer
)	O
{	O
if	O
(	O
fp	pointer
->	O
dfile_disk	pointer
)	O
{	O
fputs	function
(	O
s	pointer
,	O
fp	pointer
->	O
dfile_disk	pointer
)	O
;	O
fputs	function
(	O
suff	array
,	O
fp	pointer
->	O
dfile_disk	pointer
)	O
;	O
}	O
else	O
{	O
while	O
(	O
*	O
s	pointer
)	O
dap_putc	function
(	O
*	O
s	pointer
++	O
,	O
fp	pointer
)	O
;	O
while	O
(	O
*	O
suff	array
)	O
dap_putc	function
(	O
*	O
suff	array
++	O
,	O
fp	pointer
)	O
;	O
}	O
}	O
static	O
void	O
dputi	function
(	O
int	O
i	int
,	O
DFILE	struct
*	O
fp	pointer
)	O
{	O
static	O
char	O
*	O
istr	pointer
=	O
NULL	O
;	O
int	O
s	pointer
;	O
if	O
(	O
!	O
istr	pointer
)	O
istr	pointer
=	O
dap_malloc	function
(	O
dap_intlen	int
+	O
1	int
,	O
"dputi: istr"	pointer
)	O
;	O
if	O
(	O
fp	pointer
->	O
dfile_disk	pointer
)	O
fprintf	function
(	O
fp	pointer
->	O
dfile_disk	pointer
,	O
"%d"	pointer
,	O
i	int
)	O
;	O
else	O
{	O
sprintf	function
(	O
istr	pointer
,	O
"%d"	pointer
,	O
i	int
)	O
;	O
for	O
(	O
s	pointer
=	O
0	int
;	O
s	pointer
<	O
strlen	function
(	O
istr	pointer
)	O
;	O
s	pointer
++	O
)	O
dap_putc	function
(	O
istr	pointer
[	O
s	pointer
]	O
,	O
fp	pointer
)	O
;	O
}	O
}	O
static	O
void	O
dflush	function
(	O
DFILE	struct
*	O
fp	pointer
)	O
{	O
fflush	function
(	O
fp	pointer
->	O
dfile_disk	pointer
)	O
;	O
}	O
void	O
dap_suffix	function
(	O
char	O
dst	array
[	O
]	O
,	O
char	O
src	array
[	O
]	O
,	O
char	O
suff	array
[	O
]	O
)	O
{	O
int	O
n	int
,	O
s	pointer
;	O
for	O
(	O
n	int
=	O
0	int
;	O
src	array
[	O
n	int
]	O
;	O
n	int
++	O
)	O
dst	array
[	O
n	int
]	O
=	O
src	array
[	O
n	int
]	O
;	O
if	O
(	O
suff	array
[	O
0	int
]	O
==	O
'<'	O
)	O
{	O
while	O
(	O
--	O
n	int
>=	O
0	int
)	O
{	O
if	O
(	O
dst	array
[	O
n	int
]	O
==	O
'.'	O
)	O
break	O
;	O
}	O
if	O
(	O
n	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dap_suffix) source name has no '.': %s\n"	pointer
,	O
src	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
n	int
++	O
;	O
s	pointer
=	O
1	int
;	O
}	O
else	O
s	pointer
=	O
0	int
;	O
for	O
(	O
;	O
suff	array
[	O
s	pointer
]	O
;	O
s	pointer
++	O
)	O
dst	array
[	O
n	int
++	O
]	O
=	O
suff	array
[	O
s	pointer
]	O
;	O
dst	array
[	O
n	int
]	O
=	O
'\0'	O
;	O
}	O
int	O
dap_varnum	function
(	O
char	O
*	O
vname	array
)	O
{	O
int	O
v	int
;	O
int	O
nonblank	int
;	O
while	O
(	O
*	O
vname	array
==	O
' '	O
)	O
vname	array
++	O
;	O
for	O
(	O
nonblank	int
=	O
0	int
;	O
vname	array
[	O
nonblank	int
]	O
&&	O
vname	array
[	O
nonblank	int
]	O
!=	O
' '	O
;	O
nonblank	int
++	O
)	O
;	O
if	O
(	O
vname	array
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
!	O
strncmp	function
(	O
vname	array
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
v	int
]	O
,	O
nonblank	int
)	O
&&	O
!	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
v	int
]	O
[	O
nonblank	int
]	O
)	O
return	O
v	int
;	O
}	O
}	O
return	O
-	O
1	int
;	O
}	O
int	O
dap_arrnum	function
(	O
char	O
vname	array
[	O
]	O
,	O
int	O
*	O
dim	pointer
)	O
{	O
int	O
v	int
;	O
int	O
n	int
;	O
int	O
d	int
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nvar	int
;	O
v	int
++	O
)	O
{	O
for	O
(	O
n	int
=	O
0	int
;	O
vname	array
[	O
n	int
]	O
&&	O
vname	array
[	O
n	int
]	O
==	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
v	int
]	O
[	O
n	int
]	O
;	O
n	int
++	O
)	O
;	O
if	O
(	O
!	O
vname	array
[	O
n	int
]	O
&&	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
v	int
]	O
[	O
n	int
]	O
==	O
'['	O
)	O
{	O
for	O
(	O
d	int
=	O
1	int
;	O
v	int
+	O
d	int
<	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nvar	int
;	O
d	int
++	O
)	O
{	O
for	O
(	O
n	int
=	O
0	int
;	O
vname	array
[	O
n	int
]	O
&&	O
vname	array
[	O
n	int
]	O
==	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
v	int
+	O
d	int
]	O
[	O
n	int
]	O
;	O
n	int
++	O
)	O
;	O
if	O
(	O
vname	array
[	O
n	int
]	O
||	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
v	int
+	O
d	int
]	O
[	O
n	int
]	O
!=	O
'['	O
)	O
break	O
;	O
}	O
*	O
dim	pointer
=	O
d	int
;	O
return	O
v	int
;	O
}	O
}	O
return	O
-	O
1	int
;	O
}	O
static	O
int	O
dap_getline	function
(	O
DFILE	struct
*	O
fp	pointer
,	O
char	O
*	O
line	pointer
)	O
{	O
int	O
l	int
;	O
int	O
c	int
;	O
int	O
cc	int
;	O
c	int
=	O
EOF	O
;	O
switch	O
(	O
intype	int
)	O
{	O
case	O
TEXT	int
:	O
case	O
DSET	int
:	O
for	O
(	O
l	int
=	O
0	int
;	O
(	O
c	int
=	O
dgetc	function
(	O
fp	pointer
)	O
)	O
!=	O
EOF	O
;	O
)	O
{	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
break	O
;	O
else	O
if	O
(	O
c	int
==	O
'\r'	O
)	O
{	O
if	O
(	O
(	O
cc	int
=	O
dgetc	function
(	O
fp	pointer
)	O
)	O
!=	O
'\n'	O
)	O
undgetc	function
(	O
cc	int
,	O
fp	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
l	int
<	O
dap_linelen	int
)	O
line	pointer
[	O
l	int
++	O
]	O
=	O
c	int
;	O
else	O
{	O
line	pointer
[	O
l	int
]	O
=	O
'\0'	O
;	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dap_getline) line too long:\n%s\n"	pointer
,	O
line	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
line	pointer
[	O
l	int
]	O
=	O
'\0'	O
;	O
break	O
;	O
case	O
DBASE	int
:	O
dgetc	function
(	O
fp	pointer
)	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
inlen	int
;	O
l	int
++	O
)	O
{	O
if	O
(	O
(	O
c	int
=	O
dgetc	function
(	O
fp	pointer
)	O
)	O
==	O
EOF	O
)	O
break	O
;	O
else	O
line	pointer
[	O
l	int
]	O
=	O
c	int
;	O
}	O
if	O
(	O
l	int
<	O
inlen	int
)	O
l	int
=	O
0	int
;	O
line	pointer
[	O
l	int
]	O
=	O
'\0'	O
;	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dap_getline) bad infile type: %d\n"	pointer
,	O
intype	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
!	O
l	int
&&	O
c	int
==	O
EOF	O
)	O
return	O
-	O
1	int
;	O
return	O
l	int
;	O
}	O
void	O
dap_swap	function
(	O
)	O
{	O
int	O
iv	int
;	O
double	O
dbltmp	double
;	O
int	O
inttmp	int
;	O
char	O
strtmp	char
;	O
int	O
s	pointer
;	O
char	O
*	O
so	pointer
,	O
*	O
sp	pointer
;	O
for	O
(	O
iv	int
=	O
0	int
;	O
iv	int
<	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_ivar	int
;	O
iv	int
++	O
)	O
{	O
switch	O
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
)	O
{	O
case	O
DBL	O
:	O
dbltmp	double
=	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
;	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
=	O
dap_prev	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
;	O
dap_prev	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
=	O
dbltmp	double
;	O
if	O
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dl	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
)	O
*	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dl	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
=	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
;	O
break	O
;	O
case	O
INT	int
:	O
inttmp	int
=	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_int	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
;	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_int	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
=	O
dap_prev	array
[	O
dap_ono	int
]	O
.	O
do_int	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
;	O
dap_prev	array
[	O
dap_ono	int
]	O
.	O
do_int	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
=	O
inttmp	int
;	O
if	O
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_il	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
)	O
*	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_il	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
=	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_int	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
;	O
break	O
;	O
default	O
:	O
so	pointer
=	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
;	O
sp	pointer
=	O
dap_prev	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
;	O
for	O
(	O
s	pointer
=	O
0	int
;	O
s	pointer
<	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
;	O
s	pointer
++	O
)	O
{	O
strtmp	char
=	O
so	pointer
[	O
s	pointer
]	O
;	O
so	pointer
[	O
s	pointer
]	O
=	O
sp	pointer
[	O
s	pointer
]	O
;	O
sp	pointer
[	O
s	pointer
]	O
=	O
strtmp	char
;	O
}	O
break	O
;	O
}	O
}	O
}	O
void	O
dap_save	function
(	O
)	O
{	O
int	O
iv	int
;	O
for	O
(	O
iv	int
=	O
0	int
;	O
iv	int
<	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_ivar	int
;	O
iv	int
++	O
)	O
{	O
switch	O
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
)	O
{	O
case	O
DBL	O
:	O
dosave	struct
.	O
do_dbl	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
=	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
;	O
break	O
;	O
case	O
INT	int
:	O
dosave	struct
.	O
do_int	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
=	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_int	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
dosave	struct
.	O
do_str	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
)	O
dap_free	function
(	O
dosave	struct
.	O
do_str	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
,	O
"dap_save: dosave.do_str[dap_obs[dap_ono].do_in[iv]]"	pointer
)	O
;	O
dosave	struct
.	O
do_str	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
=	O
dap_malloc	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
+	O
1	int
,	O
"dap_save: dap_obs[dap_ono].do_nam[dap_obs[dap_ono].do_in[iv]]"	pointer
)	O
;	O
strncpy	function
(	O
dosave	struct
.	O
do_str	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
+	O
1	int
)	O
;	O
break	O
;	O
}	O
}	O
}	O
void	O
dap_rest	function
(	O
)	O
{	O
int	O
iv	int
;	O
for	O
(	O
iv	int
=	O
0	int
;	O
iv	int
<	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_ivar	int
;	O
iv	int
++	O
)	O
{	O
switch	O
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
)	O
{	O
case	O
DBL	O
:	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
=	O
dosave	struct
.	O
do_dbl	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
;	O
if	O
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dl	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
)	O
*	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dl	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
=	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
;	O
break	O
;	O
case	O
INT	int
:	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_int	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
=	O
dosave	struct
.	O
do_int	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
;	O
if	O
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_il	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
)	O
*	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_il	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
=	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_int	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
;	O
break	O
;	O
default	O
:	O
strncpy	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
,	O
dosave	struct
.	O
do_str	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
+	O
1	int
)	O
;	O
break	O
;	O
}	O
}	O
}	O
long	O
dap_ftell	function
(	O
DFILE	struct
*	O
fp	pointer
)	O
{	O
if	O
(	O
fp	pointer
->	O
dfile_disk	pointer
)	O
return	O
ftell	function
(	O
fp	pointer
->	O
dfile_disk	pointer
)	O
;	O
return	O
fp	pointer
->	O
dfile_ram	pointer
->	O
rfile_pos	pointer
-	O
fp	pointer
->	O
dfile_ram	pointer
->	O
rfile_str	pointer
;	O
}	O
void	O
dap_mark	function
(	O
)	O
{	O
filepos	array
[	O
dap_ono	int
]	O
=	O
dap_ftell	function
(	O
dap_in	array
[	O
dap_ono	int
]	O
)	O
;	O
}	O
static	O
void	O
dfseek	function
(	O
DFILE	struct
*	O
fp	pointer
,	O
long	O
pos	long
,	O
int	O
mode	array
)	O
{	O
if	O
(	O
fp	pointer
->	O
dfile_disk	pointer
)	O
fseek	function
(	O
fp	pointer
->	O
dfile_disk	pointer
,	O
pos	long
,	O
mode	array
)	O
;	O
else	O
{	O
if	O
(	O
fp	pointer
->	O
dfile_ram	pointer
->	O
rfile_str	pointer
+	O
pos	long
<	O
fp	pointer
->	O
dfile_ram	pointer
->	O
rfile_end	pointer
)	O
fp	pointer
->	O
dfile_ram	pointer
->	O
rfile_pos	pointer
=	O
fp	pointer
->	O
dfile_ram	pointer
->	O
rfile_str	pointer
+	O
pos	long
;	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dfseek) seek past end of ramfile %s\n"	pointer
,	O
fp	pointer
->	O
dfile_name	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
}	O
void	O
dap_rewind	function
(	O
)	O
{	O
if	O
(	O
dap_in	array
[	O
dap_ono	int
]	O
)	O
{	O
if	O
(	O
filepos	array
[	O
dap_ono	int
]	O
<	O
dap_ftell	function
(	O
dap_in	array
[	O
dap_ono	int
]	O
)	O
)	O
eof	array
[	O
dap_ono	int
]	O
=	O
0	int
;	O
dfseek	function
(	O
dap_in	array
[	O
dap_ono	int
]	O
,	O
filepos	array
[	O
dap_ono	int
]	O
,	O
SEEK_SET	int
)	O
;	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_valid	int
=	O
0	int
;	O
}	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dap_rewind) file (%d) is closed.\n"	pointer
,	O
dap_ono	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
int	O
dap_blank	function
(	O
char	O
str	array
[	O
]	O
)	O
{	O
int	O
b	double
;	O
for	O
(	O
b	double
=	O
0	int
;	O
str	array
[	O
b	double
]	O
==	O
' '	O
;	O
b	double
++	O
)	O
;	O
if	O
(	O
str	array
[	O
b	double
]	O
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
void	O
skip	function
(	O
int	O
nlines	int
)	O
{	O
char	O
*	O
line	pointer
;	O
line	pointer
=	O
dap_malloc	function
(	O
dap_linelen	int
+	O
1	int
,	O
"skip: line"	pointer
)	O
;	O
while	O
(	O
--	O
nlines	int
>=	O
0	int
)	O
{	O
if	O
(	O
!	O
dap_in	array
[	O
dap_ono	int
]	O
||	O
eof	array
[	O
dap_ono	int
]	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(skip) tried to read past end of file (%d).\n"	pointer
,	O
dap_ono	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
dap_getline	function
(	O
dap_in	array
[	O
dap_ono	int
]	O
,	O
line	pointer
)	O
<	O
0	int
)	O
eof	array
[	O
dap_ono	int
]	O
=	O
1	int
;	O
lineno	array
[	O
dap_ono	int
]	O
++	O
;	O
}	O
dap_free	function
(	O
line	pointer
,	O
"skip: line"	pointer
)	O
;	O
}	O
int	O
step	function
(	O
)	O
{	O
static	O
int	O
stepinit	int
=	O
0	int
;	O
static	O
char	O
*	O
line	pointer
=	O
NULL	O
;	O
static	O
char	O
*	O
value	pointer
=	O
NULL	O
;	O
int	O
v	int
;	O
int	O
l	int
;	O
int	O
i	int
;	O
int	O
iv	int
;	O
int	O
nread	int
;	O
if	O
(	O
!	O
stepinit	int
)	O
{	O
stepinit	int
=	O
1	int
;	O
line	pointer
=	O
dap_malloc	function
(	O
dap_linelen	int
+	O
1	int
,	O
"step: line"	pointer
)	O
;	O
value	pointer
=	O
dap_malloc	function
(	O
dap_linelen	int
+	O
1	int
,	O
"step: value"	pointer
)	O
;	O
}	O
if	O
(	O
!	O
dap_in	array
[	O
dap_ono	int
]	O
||	O
eof	array
[	O
dap_ono	int
]	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(step) ERROR: tried to read past end of file (%s).\n"	pointer
,	O
(	O
dap_in	array
[	O
dap_ono	int
]	O
?	O
dap_in	array
[	O
dap_ono	int
]	O
->	O
dfile_name	pointer
:	O
"?"	pointer
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
for	O
(	O
iv	int
=	O
0	int
;	O
iv	int
<	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_ivar	int
;	O
iv	int
++	O
)	O
{	O
switch	O
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
)	O
{	O
case	O
DBL	O
:	O
dap_prev	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
=	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
;	O
break	O
;	O
case	O
INT	int
:	O
dap_prev	array
[	O
dap_ono	int
]	O
.	O
do_int	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
=	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_int	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
;	O
break	O
;	O
default	O
:	O
strncpy	function
(	O
dap_prev	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
iv	int
]	O
]	O
+	O
1	int
)	O
;	O
}	O
}	O
dap_prev	array
[	O
dap_ono	int
]	O
.	O
do_valid	int
=	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_valid	int
;	O
if	O
(	O
(	O
nread	int
=	O
dap_getline	function
(	O
dap_in	array
[	O
dap_ono	int
]	O
,	O
line	pointer
)	O
)	O
<=	O
0	int
)	O
{	O
eof	array
[	O
dap_ono	int
]	O
=	O
1	int
;	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_valid	int
=	O
0	int
;	O
fprintf	function
(	O
stderr	pointer
,	O
"(step) %d lines read from %s\n"	pointer
,	O
lineno	array
[	O
dap_ono	int
]	O
-	O
1	int
,	O
dap_in	array
[	O
dap_ono	int
]	O
->	O
dfile_name	pointer
)	O
;	O
if	O
(	O
!	O
nread	int
)	O
fputs	function
(	O
"(step) WARNING: terminated on null line\n"	pointer
,	O
stderr	pointer
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
fprintf	function
(	O
dap_log	pointer
,	O
"(step) %d lines read from  %s\n"	pointer
,	O
lineno	array
[	O
dap_ono	int
]	O
-	O
1	int
,	O
dap_in	array
[	O
dap_ono	int
]	O
->	O
dfile_name	pointer
)	O
;	O
if	O
(	O
!	O
nread	int
)	O
fputs	function
(	O
"(step) WARNING: terminated on null line\n"	pointer
,	O
dap_log	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
nfields	int
&&	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_ivar	int
!=	O
nfields	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(step) ERROR: number of input variables %d different from number of fields specified %d for %s.\n"	pointer
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_ivar	int
,	O
nfields	int
,	O
dap_in	array
[	O
dap_ono	int
]	O
->	O
dfile_name	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
for	O
(	O
v	int
=	O
0	int
,	O
l	int
=	O
0	int
;	O
v	int
<	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_ivar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
nfields	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
line	pointer
[	O
l	int
+	O
i	int
]	O
&&	O
i	int
<	O
fieldwd	pointer
[	O
v	int
]	O
;	O
i	int
++	O
)	O
value	pointer
[	O
i	int
]	O
=	O
line	pointer
[	O
l	int
+	O
i	int
]	O
;	O
value	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
i	int
<	O
fieldwd	pointer
[	O
v	int
]	O
)	O
{	O
fprintf	function
(	O
dap_log	pointer
,	O
"(step (%s:%d)) ERROR: got %d of %d characters for fixed length field for %s: %s\n"	pointer
,	O
dap_in	array
[	O
dap_ono	int
]	O
->	O
dfile_name	pointer
,	O
lineno	array
[	O
dap_ono	int
]	O
,	O
i	int
,	O
fieldwd	pointer
[	O
v	int
]	O
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
v	int
]	O
]	O
,	O
value	pointer
)	O
;	O
fprintf	function
(	O
dap_err	pointer
,	O
"(step (%s:%d)) ERROR: got %d of %d characters for fixed length field for %s: %s\n"	pointer
,	O
dap_in	array
[	O
dap_ono	int
]	O
->	O
dfile_name	pointer
,	O
lineno	array
[	O
dap_ono	int
]	O
,	O
i	int
,	O
fieldwd	pointer
[	O
v	int
]	O
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
v	int
]	O
]	O
,	O
value	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
line	pointer
[	O
l	int
+	O
i	int
]	O
&&	O
line	pointer
[	O
l	int
+	O
i	int
]	O
!=	O
dap_delim	int
;	O
i	int
++	O
)	O
value	pointer
[	O
i	int
]	O
=	O
line	pointer
[	O
l	int
+	O
i	int
]	O
;	O
value	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
v	int
]	O
]	O
==	O
INT	int
)	O
{	O
if	O
(	O
intype	int
==	O
DSET	int
)	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_int	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
v	int
]	O
]	O
=	O
dap_getint	function
(	O
value	pointer
)	O
;	O
else	O
if	O
(	O
sscanf	function
(	O
value	pointer
,	O
" %d"	pointer
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_int	pointer
+	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
v	int
]	O
)	O
!=	O
1	int
)	O
{	O
if	O
(	O
dap_blank	function
(	O
value	pointer
)	O
)	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_int	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
v	int
]	O
]	O
=	O
0	int
;	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(step (%s:%d)) ERROR: invalid integer data for %s: %s\n"	pointer
,	O
dap_in	array
[	O
dap_ono	int
]	O
->	O
dfile_name	pointer
,	O
lineno	array
[	O
dap_ono	int
]	O
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
v	int
]	O
]	O
,	O
value	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
dap_ono	int
&&	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_il	pointer
[	O
dap_obs	array
[	O
0	int
]	O
.	O
do_in	pointer
[	O
v	int
]	O
]	O
)	O
*	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_il	pointer
[	O
dap_obs	array
[	O
0	int
]	O
.	O
do_in	pointer
[	O
v	int
]	O
]	O
=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_int	pointer
[	O
dap_obs	array
[	O
0	int
]	O
.	O
do_in	pointer
[	O
v	int
]	O
]	O
;	O
}	O
else	O
if	O
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
v	int
]	O
]	O
==	O
DBL	O
)	O
{	O
if	O
(	O
intype	int
==	O
DSET	int
)	O
{	O
dap_getdouble	function
(	O
value	pointer
)	O
;	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
v	int
]	O
]	O
=	O
dap_double	double
;	O
}	O
else	O
{	O
if	O
(	O
!	O
i	int
||	O
(	O
nfields	int
&&	O
dap_blank	function
(	O
value	pointer
)	O
)	O
||	O
!	O
strcmp	function
(	O
value	pointer
,	O
"."	pointer
)	O
)	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
else	O
if	O
(	O
sscanf	function
(	O
value	pointer
,	O
" %lf"	pointer
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
+	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
v	int
]	O
)	O
!=	O
1	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(step (%s:%d)) ERROR: invalid double data for %s: %s\n"	pointer
,	O
dap_in	array
[	O
dap_ono	int
]	O
->	O
dfile_name	pointer
,	O
lineno	array
[	O
dap_ono	int
]	O
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
v	int
]	O
]	O
,	O
value	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
dap_ono	int
&&	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dl	pointer
[	O
dap_obs	array
[	O
0	int
]	O
.	O
do_in	pointer
[	O
v	int
]	O
]	O
)	O
*	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dl	pointer
[	O
dap_obs	array
[	O
0	int
]	O
.	O
do_in	pointer
[	O
v	int
]	O
]	O
=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
dap_obs	array
[	O
0	int
]	O
.	O
do_in	pointer
[	O
v	int
]	O
]	O
;	O
}	O
else	O
{	O
if	O
(	O
i	int
<=	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
v	int
]	O
]	O
)	O
strcpy	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
v	int
]	O
]	O
,	O
value	pointer
)	O
;	O
else	O
{	O
strncpy	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
v	int
]	O
]	O
,	O
value	pointer
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
v	int
]	O
]	O
)	O
;	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
v	int
]	O
]	O
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
v	int
]	O
]	O
]	O
=	O
'\0'	O
;	O
if	O
(	O
toolong	int
<	O
dap_toolong	int
)	O
{	O
fprintf	function
(	O
dap_log	pointer
,	O
"(step (%s:%d)) WARNING: string data too long (%d) for %s (%d): %s\n"	pointer
,	O
dap_in	array
[	O
dap_ono	int
]	O
->	O
dfile_name	pointer
,	O
lineno	array
[	O
dap_ono	int
]	O
,	O
i	int
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
v	int
]	O
]	O
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
v	int
]	O
]	O
,	O
value	pointer
)	O
;	O
toolong	int
++	O
;	O
}	O
}	O
}	O
l	int
+=	O
i	int
;	O
if	O
(	O
!	O
nfields	int
&&	O
line	pointer
[	O
l	int
]	O
==	O
dap_delim	int
)	O
l	int
++	O
;	O
}	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_valid	int
=	O
1	int
;	O
lineno	array
[	O
dap_ono	int
]	O
++	O
;	O
return	O
1	int
;	O
}	O
int	O
dap_vd	function
(	O
char	O
*	O
varspec	array
,	O
int	O
invar	int
)	O
{	O
int	O
s	pointer
;	O
int	O
i	int
;	O
char	O
*	O
varnam	pointer
;	O
int	O
sign	int
;	O
int	O
v	int
;	O
int	O
vlen	int
;	O
int	O
redeclare	int
;	O
v	int
=	O
-	O
1	int
;	O
varnam	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
varspec	array
)	O
,	O
"dap_vd: varnam"	pointer
)	O
;	O
for	O
(	O
s	pointer
=	O
0	int
;	O
varspec	array
[	O
s	pointer
]	O
==	O
' '	O
;	O
)	O
s	pointer
++	O
;	O
while	O
(	O
varspec	array
[	O
s	pointer
]	O
)	O
{	O
if	O
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nvar	int
<	O
dap_maxvar	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
varspec	array
[	O
s	pointer
+	O
i	int
]	O
&&	O
varspec	array
[	O
s	pointer
+	O
i	int
]	O
!=	O
' '	O
;	O
i	int
++	O
)	O
varnam	pointer
[	O
i	int
]	O
=	O
varspec	array
[	O
s	pointer
+	O
i	int
]	O
;	O
varnam	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
(	O
v	int
=	O
dap_varnum	function
(	O
varnam	pointer
)	O
)	O
<	O
0	int
)	O
{	O
redeclare	int
=	O
0	int
;	O
v	int
=	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nvar	int
;	O
if	O
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
v	int
]	O
)	O
dap_free	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
v	int
]	O
,	O
"dap_vd: dap_obs[dap_ono].do_nam[v]"	pointer
)	O
;	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
v	int
]	O
=	O
dap_malloc	function
(	O
i	int
+	O
1	int
,	O
"dap_vd: dap_obs[dap_ono].do_nam[v]"	pointer
)	O
;	O
strcpy	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
v	int
]	O
,	O
varnam	pointer
)	O
;	O
if	O
(	O
invar	int
)	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_ivar	int
++	O
]	O
=	O
v	int
;	O
}	O
else	O
redeclare	int
=	O
1	int
;	O
while	O
(	O
varspec	array
[	O
s	pointer
+	O
i	int
]	O
&&	O
varspec	array
[	O
s	pointer
+	O
i	int
]	O
==	O
' '	O
)	O
i	int
++	O
;	O
if	O
(	O
!	O
varspec	array
[	O
s	pointer
+	O
i	int
]	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dap_vd) missing variable length: %s\n"	pointer
,	O
varspec	array
+	O
s	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
s	pointer
+=	O
i	int
;	O
if	O
(	O
varspec	array
[	O
s	pointer
]	O
==	O
'-'	O
)	O
{	O
sign	int
=	O
-	O
1	int
;	O
for	O
(	O
s	pointer
++	O
;	O
varspec	array
[	O
s	pointer
]	O
==	O
' '	O
;	O
s	pointer
++	O
)	O
;	O
}	O
else	O
sign	int
=	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
,	O
vlen	int
=	O
0	int
;	O
'0'	O
<=	O
varspec	array
[	O
s	pointer
+	O
i	int
]	O
&&	O
varspec	array
[	O
s	pointer
+	O
i	int
]	O
<=	O
'9'	O
;	O
i	int
++	O
)	O
vlen	int
=	O
10	int
*	O
vlen	int
+	O
varspec	array
[	O
s	pointer
+	O
i	int
]	O
-	O
'0'	O
;	O
vlen	int
*=	O
sign	int
;	O
if	O
(	O
redeclare	int
)	O
{	O
if	O
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
v	int
]	O
!=	O
vlen	int
)	O
{	O
if	O
(	O
vlen	int
>	O
0	int
&&	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
v	int
]	O
>	O
0	int
)	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dap_vd) respecification of length of %s from %d to %d\n"	pointer
,	O
varnam	pointer
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
v	int
]	O
+	O
1	int
,	O
vlen	int
+	O
1	int
)	O
;	O
else	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dap_vd) respecification of type of %s\n"	pointer
,	O
varnam	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
else	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
v	int
]	O
=	O
vlen	int
;	O
if	O
(	O
varspec	array
[	O
s	pointer
+	O
i	int
]	O
&&	O
varspec	array
[	O
s	pointer
+	O
i	int
]	O
!=	O
' '	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dap_vd) invalid variable length for %s: %s\n"	pointer
,	O
varnam	pointer
,	O
varspec	array
+	O
s	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
!	O
redeclare	int
&&	O
vlen	int
>	O
0	int
)	O
{	O
if	O
(	O
!	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_sl	pointer
[	O
v	int
]	O
&&	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
v	int
]	O
)	O
dap_free	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
v	int
]	O
,	O
"dap_vd: dap_obs[dap_ono].do_str[v]"	pointer
)	O
;	O
if	O
(	O
dap_ono	int
<	O
2	int
&&	O
dap_prev	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
v	int
]	O
)	O
dap_free	function
(	O
dap_prev	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
v	int
]	O
,	O
"dap_vd: dap_prev[dap_ono].do_str[v]"	pointer
)	O
;	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
v	int
]	O
=	O
dap_malloc	function
(	O
vlen	int
+	O
1	int
,	O
"dap_vd: dap_obs[dap_ono].do_str[v]"	pointer
)	O
;	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_sl	pointer
[	O
v	int
]	O
=	O
0	int
;	O
if	O
(	O
dap_ono	int
<	O
2	int
)	O
dap_prev	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
v	int
]	O
=	O
dap_malloc	function
(	O
vlen	int
+	O
1	int
,	O
"dap_vd: dap_prev[dap_ono].do_str[v]"	pointer
)	O
;	O
}	O
if	O
(	O
vlen	int
==	O
DBL	O
)	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
v	int
]	O
=	O
0.0	int
/	O
0.0	int
;	O
else	O
if	O
(	O
vlen	int
==	O
INT	int
)	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_int	pointer
[	O
v	int
]	O
=	O
0	int
;	O
else	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
v	int
]	O
[	O
0	int
]	O
=	O
'\0'	O
;	O
s	pointer
+=	O
i	int
;	O
while	O
(	O
varspec	array
[	O
s	pointer
]	O
==	O
' '	O
)	O
s	pointer
++	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dap_vd) too many variables: %s\n"	pointer
,	O
varspec	array
+	O
s	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
!	O
redeclare	int
)	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nvar	int
++	O
;	O
}	O
dap_free	function
(	O
varnam	pointer
,	O
"dap_vd: varnam"	pointer
)	O
;	O
return	O
v	int
;	O
}	O
void	O
dap_dl	function
(	O
char	O
varname	array
[	O
]	O
,	O
double	O
*	O
dbl	pointer
)	O
{	O
int	O
v	int
;	O
int	O
dim	pointer
;	O
int	O
d	int
;	O
if	O
(	O
(	O
v	int
=	O
dap_varnum	function
(	O
varname	array
)	O
)	O
>=	O
0	int
)	O
{	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dl	pointer
[	O
v	int
]	O
=	O
dbl	pointer
;	O
*	O
dbl	pointer
=	O
0.0	int
/	O
0.0	int
;	O
}	O
else	O
{	O
if	O
(	O
(	O
v	int
=	O
dap_arrnum	function
(	O
varname	array
,	O
&	O
dim	pointer
)	O
)	O
>	O
0	int
)	O
{	O
for	O
(	O
d	int
=	O
0	int
;	O
d	int
<	O
dim	pointer
;	O
d	int
++	O
)	O
{	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dl	pointer
[	O
v	int
+	O
d	int
]	O
=	O
dbl	pointer
+	O
d	int
;	O
dbl	pointer
[	O
d	int
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
}	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dap_dl) unknown variable %s\n"	pointer
,	O
varname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
}	O
void	O
dap_il	function
(	O
char	O
varname	array
[	O
]	O
,	O
int	O
*	O
i	int
)	O
{	O
int	O
v	int
;	O
int	O
dim	pointer
;	O
int	O
d	int
;	O
if	O
(	O
(	O
v	int
=	O
dap_varnum	function
(	O
varname	array
)	O
)	O
>	O
0	int
)	O
{	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_il	pointer
[	O
v	int
]	O
=	O
i	int
;	O
*	O
i	int
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
(	O
v	int
=	O
dap_arrnum	function
(	O
varname	array
,	O
&	O
dim	pointer
)	O
)	O
>	O
0	int
)	O
{	O
for	O
(	O
d	int
=	O
0	int
;	O
d	int
<	O
dim	pointer
;	O
d	int
++	O
)	O
{	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_il	pointer
[	O
v	int
+	O
d	int
]	O
=	O
i	int
+	O
d	int
;	O
i	int
[	O
d	int
]	O
=	O
0	int
;	O
}	O
}	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dap_il) unknown variable %s\n"	pointer
,	O
varname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
}	O
void	O
dap_sl	function
(	O
char	O
varname	array
[	O
]	O
,	O
char	O
*	O
s	pointer
)	O
{	O
int	O
v	int
;	O
if	O
(	O
(	O
v	int
=	O
dap_varnum	function
(	O
varname	array
)	O
)	O
>=	O
0	int
)	O
{	O
dap_free	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
v	int
]	O
,	O
"dap_sl: dap_obs[dap_ono].do_str[v]"	pointer
)	O
;	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
v	int
]	O
=	O
s	pointer
;	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_sl	pointer
[	O
v	int
]	O
=	O
1	int
;	O
s	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dap_sl) unknown variable %s\n"	pointer
,	O
varname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
void	O
dap_name	function
(	O
char	O
dname	array
[	O
]	O
,	O
char	O
*	O
fname	array
)	O
{	O
struct	O
stat	struct
statbuf	struct
;	O
if	O
(	O
!	O
fname	array
||	O
!	O
fname	array
[	O
0	int
]	O
)	O
{	O
strcpy	function
(	O
dname	array
,	O
"/dev/null"	pointer
)	O
;	O
return	O
;	O
}	O
strcpy	function
(	O
dname	array
,	O
dap_setdir	pointer
)	O
;	O
if	O
(	O
stat	struct
(	O
dname	array
,	O
&	O
statbuf	struct
)	O
<	O
0	int
)	O
{	O
if	O
(	O
mkdir	function
(	O
dname	array
,	O
(	O
mode_t	int
)	O
0700	int
)	O
<	O
0	int
)	O
{	O
perror	function
(	O
dap_dapname	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
(	O
statbuf	struct
.	O
st_mode	int
&	O
S_IFDIR	O
)	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"%s: non-directory file exists: %s\n"	pointer
,	O
dap_dapname	pointer
,	O
dname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
strcat	function
(	O
dname	array
,	O
"/"	pointer
)	O
;	O
strcat	function
(	O
dname	array
,	O
fname	array
)	O
;	O
}	O
static	O
int	O
dblcmp	function
(	O
double	O
*	O
d1	pointer
,	O
double	O
*	O
d2	pointer
)	O
{	O
if	O
(	O
*	O
d1	pointer
<	O
*	O
d2	pointer
)	O
return	O
-	O
1	int
;	O
else	O
if	O
(	O
*	O
d1	pointer
>	O
*	O
d2	pointer
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
intcmp	function
(	O
int	O
*	O
i1	pointer
,	O
int	O
*	O
i2	pointer
)	O
{	O
if	O
(	O
*	O
i1	pointer
<	O
*	O
i2	pointer
)	O
return	O
-	O
1	int
;	O
else	O
if	O
(	O
*	O
i1	pointer
>	O
*	O
i2	pointer
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
stcmp	function
(	O
char	O
*	O
*	O
s1	pointer
,	O
char	O
*	O
*	O
s2	pointer
)	O
{	O
return	O
strcmp	function
(	O
*	O
s1	pointer
,	O
*	O
s2	pointer
)	O
;	O
}	O
static	O
int	O
findlev	function
(	O
int	O
class	int
,	O
double	O
dlevel	array
[	O
]	O
,	O
int	O
ilevel	array
[	O
]	O
,	O
char	O
*	O
slevel	array
[	O
]	O
,	O
int	O
nlevels	int
)	O
{	O
int	O
v	int
;	O
if	O
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
class	int
]	O
==	O
DBL	O
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nlevels	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
class	int
]	O
==	O
dlevel	array
[	O
v	int
]	O
)	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
class	int
]	O
==	O
INT	int
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nlevels	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_int	pointer
[	O
class	int
]	O
==	O
ilevel	array
[	O
v	int
]	O
)	O
break	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nlevels	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
class	int
]	O
,	O
slevel	array
[	O
v	int
]	O
)	O
)	O
break	O
;	O
}	O
}	O
if	O
(	O
v	int
<	O
nlevels	int
)	O
return	O
v	int
;	O
return	O
-	O
1	int
;	O
}	O
int	O
inclev	function
(	O
int	O
lev	array
[	O
]	O
,	O
int	O
nlevels	int
[	O
]	O
,	O
int	O
nclass	int
)	O
{	O
int	O
c	int
;	O
for	O
(	O
c	int
=	O
nclass	int
-	O
1	int
;	O
c	int
>=	O
0	int
;	O
--	O
c	int
)	O
{	O
if	O
(	O
lev	array
[	O
c	int
]	O
<	O
nlevels	int
[	O
c	int
]	O
-	O
1	int
)	O
break	O
;	O
}	O
if	O
(	O
c	int
<	O
0	int
)	O
return	O
0	int
;	O
lev	array
[	O
c	int
]	O
++	O
;	O
while	O
(	O
++	O
c	int
<	O
nclass	int
)	O
lev	array
[	O
c	int
]	O
=	O
0	int
;	O
return	O
1	int
;	O
}	O
void	O
dataset	function
(	O
char	O
oldname	array
[	O
]	O
,	O
char	O
newname	array
[	O
]	O
,	O
char	O
action	pointer
[	O
]	O
)	O
{	O
static	O
int	O
datsetinit	int
=	O
0	int
;	O
char	O
*	O
dold	pointer
,	O
*	O
dnew	pointer
;	O
int	O
fold	int
,	O
fnew	int
;	O
DFILE	struct
*	O
doldf	pointer
,	O
*	O
dnewf	pointer
;	O
int	O
c	int
;	O
int	O
v	int
;	O
int	O
onum	int
;	O
int	O
maxnamlen	int
;	O
static	O
dataobs	struct
baseobs	struct
;	O
char	O
*	O
varspec	array
;	O
char	O
*	O
oldvmem	pointer
;	O
char	O
*	O
newvmem	pointer
;	O
char	O
*	O
*	O
oldvar	pointer
;	O
char	O
*	O
*	O
newvar	pointer
;	O
int	O
nvar	int
;	O
int	O
ncell	int
,	O
nclass	int
;	O
char	O
*	O
celllist	pointer
;	O
int	O
*	O
cellv	pointer
,	O
*	O
classv	pointer
;	O
char	O
*	O
*	O
slevelmem	pointer
;	O
char	O
*	O
*	O
*	O
slevel	array
;	O
double	O
*	O
dlevelmem	pointer
;	O
double	O
*	O
*	O
dlevel	array
;	O
int	O
*	O
ilevelmem	pointer
;	O
int	O
*	O
*	O
ilevel	array
;	O
int	O
*	O
inlev	pointer
;	O
int	O
*	O
outlev	pointer
;	O
int	O
*	O
nlevels	int
;	O
int	O
(	O
*	O
dcmp	pointer
)	O
(	O
)	O
=	O
&	O
dblcmp	function
;	O
int	O
(	O
*	O
icmp	pointer
)	O
(	O
)	O
=	O
&	O
intcmp	function
;	O
int	O
(	O
*	O
scmp	pointer
)	O
(	O
)	O
=	O
&	O
stcmp	function
;	O
int	O
vn	int
,	O
nv	int
;	O
int	O
dim	pointer
,	O
ndim	int
;	O
char	O
*	O
outlist	pointer
;	O
static	O
char	O
dimstr	array
[	O
7	int
]	O
;	O
int	O
*	O
clearvar	pointer
;	O
int	O
nclear	int
;	O
if	O
(	O
!	O
datsetinit	int
)	O
{	O
datsetinit	int
=	O
1	int
;	O
initdo	function
(	O
&	O
baseobs	struct
)	O
;	O
}	O
if	O
(	O
dap_in	array
[	O
0	int
]	O
)	O
{	O
dfclose	function
(	O
dap_in	array
[	O
0	int
]	O
)	O
;	O
dap_in	array
[	O
0	int
]	O
=	O
(	O
DFILE	struct
*	O
)	O
NULL	O
;	O
}	O
if	O
(	O
dap_out	array
[	O
0	int
]	O
)	O
{	O
dfclose	function
(	O
dap_out	array
[	O
0	int
]	O
)	O
;	O
dap_out	array
[	O
0	int
]	O
=	O
(	O
DFILE	struct
*	O
)	O
NULL	O
;	O
}	O
celllist	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
slevelmem	pointer
=	O
(	O
char	O
*	O
*	O
)	O
NULL	O
;	O
cellv	pointer
=	O
(	O
int	O
*	O
)	O
NULL	O
;	O
classv	pointer
=	O
(	O
int	O
*	O
)	O
NULL	O
;	O
outlist	pointer
=	O
dap_malloc	function
(	O
dap_listlen	int
,	O
"dataset: outlist"	pointer
)	O
;	O
oldvmem	pointer
=	O
dap_malloc	function
(	O
dap_maxvar	int
*	O
(	O
dap_namelen	int
+	O
1	int
)	O
,	O
"dataset: oldvmem"	pointer
)	O
;	O
oldvar	pointer
=	O
(	O
char	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
dap_maxvar	int
,	O
"dataset: oldvar"	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
dap_maxvar	int
;	O
v	int
++	O
)	O
oldvar	pointer
[	O
v	int
]	O
=	O
oldvmem	pointer
+	O
v	int
*	O
(	O
dap_namelen	int
+	O
1	int
)	O
;	O
newvmem	pointer
=	O
dap_malloc	function
(	O
dap_maxvar	int
*	O
(	O
dap_namelen	int
+	O
1	int
)	O
,	O
"dataset: newvmem"	pointer
)	O
;	O
newvar	pointer
=	O
(	O
char	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
dap_maxvar	int
,	O
"dataset: newvar"	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
dap_maxvar	int
;	O
v	int
++	O
)	O
newvar	pointer
[	O
v	int
]	O
=	O
newvmem	pointer
+	O
v	int
*	O
(	O
dap_namelen	int
+	O
1	int
)	O
;	O
dold	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
oldname	array
)	O
+	O
strlen	function
(	O
dap_setdir	pointer
)	O
+	O
2	int
,	O
"dataset: dold"	pointer
)	O
;	O
dnew	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
newname	array
)	O
+	O
strlen	function
(	O
dap_setdir	pointer
)	O
+	O
2	int
,	O
"dataset: dnew"	pointer
)	O
;	O
dap_name	function
(	O
dold	pointer
,	O
oldname	array
)	O
;	O
dap_name	function
(	O
dnew	pointer
,	O
newname	array
)	O
;	O
clearvar	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
action	pointer
,	O
"RENAME"	pointer
)	O
)	O
{	O
if	O
(	O
oldname	array
[	O
0	int
]	O
==	O
'<'	O
)	O
{	O
if	O
(	O
newname	array
[	O
0	int
]	O
==	O
'<'	O
)	O
{	O
for	O
(	O
fold	int
=	O
0	int
;	O
fold	int
<	O
dap_nrfiles	int
;	O
fold	int
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
dfile	pointer
[	O
NDFILES	int
+	O
fold	int
]	O
.	O
dfile_name	pointer
,	O
oldname	array
+	O
1	int
)	O
)	O
break	O
;	O
}	O
if	O
(	O
fold	int
<	O
dap_nrfiles	int
)	O
{	O
for	O
(	O
fnew	int
=	O
0	int
;	O
fnew	int
<	O
dap_nrfiles	int
;	O
fnew	int
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
dfile	pointer
[	O
NDFILES	int
+	O
fnew	int
]	O
.	O
dfile_name	pointer
,	O
newname	array
+	O
1	int
)	O
)	O
break	O
;	O
}	O
if	O
(	O
fnew	int
<	O
dap_nrfiles	int
)	O
dfile	pointer
[	O
NDFILES	int
+	O
fnew	int
]	O
.	O
dfile_name	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
strcpy	function
(	O
dfile	pointer
[	O
NDFILES	int
+	O
fold	int
]	O
.	O
dfile_name	pointer
,	O
newname	array
+	O
1	int
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dataset) can't find ramfile %s\n"	pointer
,	O
oldname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dataset) can't rename ramfile %s to disk file %s\n"	pointer
,	O
oldname	array
,	O
newname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
newname	array
[	O
0	int
]	O
==	O
'<'	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dataset) can't rename disk file %s to ramfile %s\n"	pointer
,	O
oldname	array
,	O
newname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
else	O
rename	function
(	O
dold	pointer
,	O
dnew	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
action	pointer
,	O
"COPY"	pointer
,	O
4	int
)	O
)	O
{	O
for	O
(	O
v	int
=	O
4	int
;	O
action	pointer
[	O
v	int
]	O
==	O
' '	O
;	O
v	int
++	O
)	O
;	O
for	O
(	O
nvar	int
=	O
0	int
;	O
action	pointer
[	O
v	int
]	O
;	O
nvar	int
++	O
)	O
{	O
for	O
(	O
c	int
=	O
0	int
;	O
action	pointer
[	O
v	int
]	O
&&	O
action	pointer
[	O
v	int
]	O
!=	O
' '	O
&&	O
action	pointer
[	O
v	int
]	O
!=	O
'>'	O
;	O
)	O
{	O
if	O
(	O
c	int
<	O
dap_namelen	int
)	O
oldvar	pointer
[	O
nvar	int
]	O
[	O
c	int
++	O
]	O
=	O
action	pointer
[	O
v	int
++	O
]	O
;	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dataset) variable name too long: %s\n"	pointer
,	O
action	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
oldvar	pointer
[	O
nvar	int
]	O
[	O
c	int
]	O
=	O
'\0'	O
;	O
while	O
(	O
action	pointer
[	O
v	int
]	O
==	O
' '	O
)	O
v	int
++	O
;	O
if	O
(	O
action	pointer
[	O
v	int
]	O
==	O
'>'	O
)	O
{	O
for	O
(	O
v	int
++	O
;	O
action	pointer
[	O
v	int
]	O
==	O
' '	O
;	O
v	int
++	O
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
action	pointer
[	O
v	int
]	O
&&	O
action	pointer
[	O
v	int
]	O
!=	O
' '	O
;	O
)	O
{	O
if	O
(	O
c	int
<	O
dap_namelen	int
)	O
newvar	pointer
[	O
nvar	int
]	O
[	O
c	int
++	O
]	O
=	O
action	pointer
[	O
v	int
++	O
]	O
;	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dataset) new variable name too long: %s\n"	pointer
,	O
action	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
newvar	pointer
[	O
nvar	int
]	O
[	O
c	int
]	O
=	O
'\0'	O
;	O
while	O
(	O
action	pointer
[	O
v	int
]	O
==	O
' '	O
)	O
v	int
++	O
;	O
}	O
else	O
strcpy	function
(	O
newvar	pointer
[	O
nvar	int
]	O
,	O
oldvar	pointer
[	O
nvar	int
]	O
)	O
;	O
}	O
if	O
(	O
nvar	int
)	O
{	O
inset	function
(	O
oldname	array
)	O
;	O
for	O
(	O
v	int
=	O
0	int
,	O
outlist	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
v	int
)	O
strcat	function
(	O
outlist	pointer
,	O
" "	pointer
)	O
;	O
strcat	function
(	O
outlist	pointer
,	O
newvar	pointer
[	O
v	int
]	O
)	O
;	O
if	O
(	O
strcmp	function
(	O
oldvar	pointer
[	O
v	int
]	O
,	O
newvar	pointer
[	O
v	int
]	O
)	O
)	O
{	O
if	O
(	O
(	O
vn	int
=	O
dap_varnum	function
(	O
oldvar	pointer
[	O
v	int
]	O
)	O
)	O
>=	O
0	int
)	O
{	O
if	O
(	O
(	O
nv	int
=	O
dap_varnum	function
(	O
newvar	pointer
[	O
v	int
]	O
)	O
)	O
>=	O
0	int
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
nv	int
]	O
[	O
0	int
]	O
=	O
'0'	O
;	O
dap_free	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
vn	int
]	O
,	O
"dataset: dap_obs[0].do_nam[vn]"	pointer
)	O
;	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
vn	int
]	O
=	O
dap_malloc	function
(	O
strlen	function
(	O
newvar	pointer
[	O
v	int
]	O
)	O
+	O
1	int
,	O
"dataset: dap_obs[0].do_nam[vn]"	pointer
)	O
;	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
vn	int
]	O
,	O
newvar	pointer
[	O
v	int
]	O
)	O
;	O
}	O
else	O
if	O
(	O
(	O
vn	int
=	O
dap_arrnum	function
(	O
oldvar	pointer
[	O
v	int
]	O
,	O
&	O
dim	pointer
)	O
)	O
>=	O
0	int
)	O
{	O
if	O
(	O
(	O
nv	int
=	O
dap_arrnum	function
(	O
newvar	pointer
[	O
v	int
]	O
,	O
&	O
ndim	int
)	O
)	O
>=	O
0	int
)	O
{	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
ndim	int
;	O
c	int
++	O
)	O
{	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
nv	int
+	O
c	int
]	O
[	O
0	int
]	O
=	O
'0'	O
;	O
sprintf	function
(	O
dimstr	array
,	O
"[%d]"	pointer
,	O
c	int
)	O
;	O
strcat	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
vn	int
+	O
c	int
]	O
,	O
dimstr	array
)	O
;	O
}	O
}	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
dim	pointer
;	O
c	int
++	O
)	O
{	O
sprintf	function
(	O
dimstr	array
,	O
"[%d]"	pointer
,	O
c	int
)	O
;	O
dap_free	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
vn	int
+	O
c	int
]	O
,	O
"dataset: dap_obs[0].do_nam[vn + c]"	pointer
)	O
;	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
vn	int
+	O
c	int
]	O
=	O
dap_malloc	function
(	O
strlen	function
(	O
newvar	pointer
[	O
v	int
]	O
)	O
+	O
strlen	function
(	O
dimstr	array
)	O
+	O
1	int
,	O
"dataset: dap_obs[0].do_nam[vn + c]"	pointer
)	O
;	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
vn	int
+	O
c	int
]	O
,	O
newvar	pointer
[	O
v	int
]	O
)	O
;	O
strcat	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
vn	int
+	O
c	int
]	O
,	O
dimstr	array
)	O
;	O
}	O
}	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dataset) unknown variable %s\n"	pointer
,	O
oldvar	pointer
[	O
v	int
]	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
}	O
outset	function
(	O
newname	array
,	O
outlist	pointer
)	O
;	O
while	O
(	O
step	function
(	O
)	O
)	O
output	function
(	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
(	O
doldf	pointer
=	O
dfopen	function
(	O
oldname	array
,	O
"r"	pointer
)	O
)	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dataset) can't read %s for copy.\n"	pointer
,	O
oldname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
!	O
(	O
dnewf	pointer
=	O
dfopen	function
(	O
newname	array
,	O
"w"	pointer
)	O
)	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dataset) can't write %s for copy.\n"	pointer
,	O
newname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
while	O
(	O
(	O
c	int
=	O
dgetc	function
(	O
doldf	pointer
)	O
)	O
!=	O
EOF	O
)	O
dap_putc	function
(	O
c	int
,	O
dnewf	pointer
)	O
;	O
dfclose	function
(	O
dnewf	pointer
)	O
;	O
dfclose	function
(	O
doldf	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
action	pointer
,	O
"FILL"	pointer
,	O
4	int
)	O
)	O
{	O
inset	function
(	O
oldname	array
)	O
;	O
celllist	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
action	pointer
)	O
,	O
"dataset: celllist"	pointer
)	O
;	O
for	O
(	O
v	int
=	O
4	int
,	O
c	int
=	O
0	int
;	O
action	pointer
[	O
v	int
]	O
&&	O
action	pointer
[	O
v	int
]	O
!=	O
':'	O
;	O
)	O
celllist	pointer
[	O
c	int
++	O
]	O
=	O
action	pointer
[	O
v	int
++	O
]	O
;	O
celllist	pointer
[	O
c	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
!	O
action	pointer
[	O
v	int
]	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dataset) missing ':' between variable lists in %s\n"	pointer
,	O
action	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
ncell	int
=	O
c	int
/	O
2	int
;	O
cellv	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
ncell	int
,	O
"dataset: cellv"	pointer
)	O
;	O
ncell	int
=	O
dap_list	function
(	O
celllist	pointer
,	O
cellv	pointer
,	O
ncell	int
)	O
;	O
nclass	int
=	O
(	O
strlen	function
(	O
action	pointer
)	O
-	O
v	int
)	O
/	O
2	int
;	O
classv	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
nclass	int
,	O
"dataset: classv"	pointer
)	O
;	O
nclass	int
=	O
dap_list	function
(	O
action	pointer
+	O
v	int
+	O
1	int
,	O
classv	pointer
,	O
nclass	int
)	O
;	O
inlev	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
nclass	int
,	O
"dataset: inlev"	pointer
)	O
;	O
outlev	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
nclass	int
,	O
"dataset: outlev"	pointer
)	O
;	O
slevelmem	pointer
=	O
(	O
char	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
nclass	int
*	O
dap_maxlev	int
,	O
"dataset: slevelmem"	pointer
)	O
;	O
slevel	array
=	O
(	O
char	O
*	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
char	O
*	O
*	O
)	O
*	O
nclass	int
,	O
"dataset: slevel"	pointer
)	O
;	O
dlevelmem	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
nclass	int
*	O
dap_maxlev	int
,	O
"dataset: dlevelmem"	pointer
)	O
;	O
dlevel	array
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
*	O
)	O
*	O
nclass	int
,	O
"dataset: dlevel"	pointer
)	O
;	O
ilevelmem	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
nclass	int
*	O
dap_maxlev	int
,	O
"dataset: ilevelmem"	pointer
)	O
;	O
ilevel	array
=	O
(	O
int	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
*	O
)	O
*	O
nclass	int
,	O
"dataset: ilevel"	pointer
)	O
;	O
nlevels	int
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
nclass	int
,	O
"dataset: nlevels"	pointer
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
slevel	array
[	O
c	int
]	O
=	O
slevelmem	pointer
+	O
c	int
*	O
dap_maxlev	int
;	O
dlevel	array
[	O
c	int
]	O
=	O
dlevelmem	pointer
+	O
c	int
*	O
dap_maxlev	int
;	O
ilevel	array
[	O
c	int
]	O
=	O
ilevelmem	pointer
+	O
c	int
*	O
dap_maxlev	int
;	O
}	O
outset	function
(	O
newname	array
,	O
""	pointer
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
nlevels	int
[	O
c	int
]	O
=	O
0	int
;	O
for	O
(	O
dap_mark	function
(	O
)	O
;	O
step	function
(	O
)	O
;	O
)	O
{	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
if	O
(	O
(	O
v	int
=	O
findlev	function
(	O
classv	pointer
[	O
c	int
]	O
,	O
dlevel	array
[	O
c	int
]	O
,	O
ilevel	array
[	O
c	int
]	O
,	O
slevel	array
[	O
c	int
]	O
,	O
nlevels	int
[	O
c	int
]	O
)	O
)	O
<	O
0	int
)	O
{	O
if	O
(	O
nlevels	int
[	O
c	int
]	O
<	O
dap_maxlev	int
)	O
{	O
if	O
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
classv	pointer
[	O
c	int
]	O
]	O
==	O
DBL	O
)	O
{	O
dlevel	array
[	O
c	int
]	O
[	O
nlevels	int
[	O
c	int
]	O
++	O
]	O
=	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
classv	pointer
[	O
c	int
]	O
]	O
;	O
}	O
else	O
if	O
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
classv	pointer
[	O
c	int
]	O
]	O
==	O
INT	int
)	O
{	O
ilevel	array
[	O
c	int
]	O
[	O
nlevels	int
[	O
c	int
]	O
++	O
]	O
=	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_int	pointer
[	O
classv	pointer
[	O
c	int
]	O
]	O
;	O
}	O
else	O
{	O
slevel	array
[	O
c	int
]	O
[	O
nlevels	int
[	O
c	int
]	O
]	O
=	O
dap_malloc	function
(	O
strlen	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
classv	pointer
[	O
c	int
]	O
]	O
)	O
+	O
1	int
,	O
"dataset: slevel[c][nlevels[c]]"	pointer
)	O
;	O
strcpy	function
(	O
slevel	array
[	O
c	int
]	O
[	O
nlevels	int
[	O
c	int
]	O
++	O
]	O
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
classv	pointer
[	O
c	int
]	O
]	O
)	O
;	O
}	O
}	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dataset) too many levels for \%s\n"	pointer
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
classv	pointer
[	O
c	int
]	O
]	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
}	O
}	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
classv	pointer
[	O
c	int
]	O
]	O
==	O
DBL	O
)	O
qsort	function
(	O
dlevel	array
[	O
c	int
]	O
,	O
nlevels	int
[	O
c	int
]	O
,	O
sizeof	O
(	O
double	O
)	O
,	O
dcmp	pointer
)	O
;	O
else	O
if	O
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
classv	pointer
[	O
c	int
]	O
]	O
==	O
INT	int
)	O
qsort	function
(	O
ilevel	array
[	O
c	int
]	O
,	O
nlevels	int
[	O
c	int
]	O
,	O
sizeof	O
(	O
int	O
)	O
,	O
icmp	pointer
)	O
;	O
else	O
qsort	function
(	O
slevel	array
[	O
c	int
]	O
,	O
nlevels	int
[	O
c	int
]	O
,	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
scmp	pointer
)	O
;	O
outlev	pointer
[	O
c	int
]	O
=	O
0	int
;	O
}	O
dap_rewind	function
(	O
)	O
;	O
while	O
(	O
step	function
(	O
)	O
)	O
{	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
inlev	pointer
[	O
c	int
]	O
=	O
findlev	function
(	O
classv	pointer
[	O
c	int
]	O
,	O
dlevel	array
[	O
c	int
]	O
,	O
ilevel	array
[	O
c	int
]	O
,	O
slevel	array
[	O
c	int
]	O
,	O
nlevels	int
[	O
c	int
]	O
)	O
;	O
}	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
if	O
(	O
outlev	pointer
[	O
c	int
]	O
<	O
inlev	pointer
[	O
c	int
]	O
)	O
break	O
;	O
}	O
if	O
(	O
c	int
<	O
nclass	int
)	O
{	O
dap_save	function
(	O
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
ncell	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
cellv	pointer
[	O
v	int
]	O
]	O
==	O
DBL	O
)	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
cellv	pointer
[	O
v	int
]	O
]	O
=	O
0.0	int
;	O
else	O
if	O
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
cellv	pointer
[	O
v	int
]	O
]	O
==	O
INT	int
)	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_int	pointer
[	O
cellv	pointer
[	O
v	int
]	O
]	O
=	O
0	int
;	O
else	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
cellv	pointer
[	O
v	int
]	O
]	O
[	O
0	int
]	O
=	O
'\0'	O
;	O
}	O
do	O
{	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
if	O
(	O
outlev	pointer
[	O
c	int
]	O
<	O
inlev	pointer
[	O
c	int
]	O
)	O
break	O
;	O
}	O
if	O
(	O
c	int
==	O
nclass	int
)	O
break	O
;	O
for	O
(	O
v	int
=	O
c	int
;	O
v	int
<	O
nclass	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
classv	pointer
[	O
v	int
]	O
]	O
==	O
DBL	O
)	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
classv	pointer
[	O
v	int
]	O
]	O
=	O
dlevel	array
[	O
v	int
]	O
[	O
outlev	pointer
[	O
v	int
]	O
]	O
;	O
else	O
if	O
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
classv	pointer
[	O
v	int
]	O
]	O
==	O
INT	int
)	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_int	pointer
[	O
classv	pointer
[	O
v	int
]	O
]	O
=	O
ilevel	array
[	O
v	int
]	O
[	O
outlev	pointer
[	O
v	int
]	O
]	O
;	O
else	O
strcpy	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
classv	pointer
[	O
v	int
]	O
]	O
,	O
slevel	array
[	O
v	int
]	O
[	O
outlev	pointer
[	O
v	int
]	O
]	O
)	O
;	O
}	O
output	function
(	O
)	O
;	O
}	O
while	O
(	O
inclev	function
(	O
outlev	pointer
,	O
nlevels	int
,	O
nclass	int
)	O
)	O
;	O
dap_rest	function
(	O
)	O
;	O
}	O
output	function
(	O
)	O
;	O
inclev	function
(	O
outlev	pointer
,	O
nlevels	int
,	O
nclass	int
)	O
;	O
}	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nlevels	int
[	O
c	int
]	O
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
classv	pointer
[	O
c	int
]	O
]	O
>	O
0	int
)	O
dap_free	function
(	O
slevel	array
[	O
c	int
]	O
[	O
v	int
]	O
,	O
"dataset: slevel[c][v]"	pointer
)	O
;	O
}	O
nlevels	int
[	O
c	int
]	O
=	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
action	pointer
,	O
"REMOVE"	pointer
)	O
)	O
{	O
if	O
(	O
oldname	array
[	O
0	int
]	O
==	O
'<'	O
)	O
{	O
for	O
(	O
fold	int
=	O
0	int
;	O
fold	int
<	O
dap_nrfiles	int
;	O
fold	int
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
dfile	pointer
[	O
NDFILES	int
+	O
fold	int
]	O
.	O
dfile_name	pointer
,	O
oldname	array
+	O
1	int
)	O
)	O
{	O
dap_free	function
(	O
dfile	pointer
[	O
NDFILES	int
+	O
fold	int
]	O
.	O
dfile_name	pointer
,	O
"dataset: dfile[NDFILES + fold].dfile_name"	pointer
)	O
;	O
dfile	pointer
[	O
NDFILES	int
+	O
fold	int
]	O
.	O
dfile_name	pointer
=	O
NULL	O
;	O
dap_free	function
(	O
rfile	pointer
[	O
fold	int
]	O
.	O
rfile_str	pointer
,	O
"dataset: rfile[fold].rfile_str"	pointer
)	O
;	O
break	O
;	O
}	O
}	O
}	O
else	O
unlink	function
(	O
dold	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
action	pointer
,	O
"APPEND"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
(	O
dap_out	array
[	O
0	int
]	O
=	O
dfopen	function
(	O
newname	array
,	O
"r"	pointer
)	O
)	O
)	O
{	O
if	O
(	O
!	O
(	O
dap_out	array
[	O
0	int
]	O
=	O
dfopen	function
(	O
newname	array
,	O
"w"	pointer
)	O
)	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dataset) Can't create new data set for append: %s\n"	pointer
,	O
newname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
!	O
(	O
dap_in	array
[	O
0	int
]	O
=	O
dfopen	function
(	O
oldname	array
,	O
"r"	pointer
)	O
)	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dataset) can't read old data set for append: %s\n"	pointer
,	O
oldname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
while	O
(	O
(	O
c	int
=	O
dgetc	function
(	O
dap_in	array
[	O
0	int
]	O
)	O
)	O
!=	O
EOF	O
)	O
dap_putc	function
(	O
c	int
,	O
dap_out	array
[	O
0	int
]	O
)	O
;	O
dfclose	function
(	O
dap_in	array
[	O
0	int
]	O
)	O
;	O
dap_in	array
[	O
0	int
]	O
=	O
(	O
DFILE	struct
*	O
)	O
NULL	O
;	O
dfclose	function
(	O
dap_out	array
[	O
0	int
]	O
)	O
;	O
dap_out	array
[	O
0	int
]	O
=	O
(	O
DFILE	struct
*	O
)	O
NULL	O
;	O
return	O
;	O
}	O
else	O
{	O
inset	function
(	O
newname	array
)	O
;	O
outset	function
(	O
"dap_null"	pointer
,	O
""	pointer
)	O
;	O
baseobs	struct
.	O
do_nvar	int
=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nvar	int
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
baseobs	struct
.	O
do_nvar	int
;	O
v	int
++	O
)	O
{	O
baseobs	struct
.	O
do_len	pointer
[	O
v	int
]	O
=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
v	int
]	O
;	O
baseobs	struct
.	O
do_nam	pointer
[	O
v	int
]	O
=	O
dap_malloc	function
(	O
strlen	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
v	int
]	O
)	O
+	O
1	int
,	O
"dataset: baseobs.do_nam[v]"	pointer
)	O
;	O
strcpy	function
(	O
baseobs	struct
.	O
do_nam	pointer
[	O
v	int
]	O
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
v	int
]	O
)	O
;	O
}	O
dfclose	function
(	O
dap_out	array
[	O
0	int
]	O
)	O
;	O
dap_out	array
[	O
0	int
]	O
=	O
(	O
DFILE	struct
*	O
)	O
NULL	O
;	O
inset	function
(	O
oldname	array
)	O
;	O
dap_obs	array
[	O
0	int
]	O
.	O
do_ovar	int
=	O
0	int
;	O
for	O
(	O
v	int
=	O
0	int
,	O
maxnamlen	int
=	O
0	int
;	O
v	int
<	O
baseobs	struct
.	O
do_nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
maxnamlen	int
<	O
strlen	function
(	O
baseobs	struct
.	O
do_nam	pointer
[	O
v	int
]	O
)	O
)	O
maxnamlen	int
=	O
strlen	function
(	O
baseobs	struct
.	O
do_nam	pointer
[	O
v	int
]	O
)	O
;	O
}	O
varspec	array
=	O
dap_malloc	function
(	O
maxnamlen	int
+	O
dap_intlen	int
+	O
2	int
,	O
"dataset: varspec"	pointer
)	O
;	O
clearvar	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
baseobs	struct
.	O
do_nvar	int
,	O
"dataset: clearvar"	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
,	O
nclear	int
=	O
0	int
;	O
v	int
<	O
baseobs	struct
.	O
do_nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
(	O
onum	int
=	O
dap_varnum	function
(	O
baseobs	struct
.	O
do_nam	pointer
[	O
v	int
]	O
)	O
)	O
<	O
0	int
)	O
{	O
sprintf	function
(	O
varspec	array
,	O
"%s %d"	pointer
,	O
baseobs	struct
.	O
do_nam	pointer
[	O
v	int
]	O
,	O
baseobs	struct
.	O
do_len	pointer
[	O
v	int
]	O
)	O
;	O
onum	int
=	O
dap_vd	function
(	O
varspec	array
,	O
0	int
)	O
;	O
clearvar	pointer
[	O
nclear	int
++	O
]	O
=	O
onum	int
;	O
}	O
else	O
{	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
onum	int
]	O
!=	O
baseobs	struct
.	O
do_len	pointer
[	O
v	int
]	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"(dataset) variable %s has different lengths (%d appended to %d) in datasets\n"	pointer
,	O
baseobs	struct
.	O
do_nam	pointer
[	O
v	int
]	O
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
onum	int
]	O
,	O
baseobs	struct
.	O
do_len	pointer
[	O
v	int
]	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
dap_obs	array
[	O
0	int
]	O
.	O
do_out	pointer
[	O
dap_obs	array
[	O
0	int
]	O
.	O
do_ovar	int
++	O
]	O
=	O
onum	int
;	O
}	O
if	O
(	O
!	O
(	O
dap_out	array
[	O
0	int
]	O
=	O
dfopen	function
(	O
newname	array
,	O
"a"	pointer
)	O
)	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dataset) can't append to new data set: %s\n"	pointer
,	O
newname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
while	O
(	O
step	function
(	O
)	O
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nclear	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
clearvar	pointer
[	O
v	int
]	O
]	O
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
clearvar	pointer
[	O
v	int
]	O
]	O
[	O
0	int
]	O
=	O
'\0'	O
;	O
dap_obs	array
[	O
0	int
]	O
.	O
do_sl	pointer
[	O
clearvar	pointer
[	O
v	int
]	O
]	O
=	O
0	int
;	O
dap_obs	array
[	O
0	int
]	O
.	O
do_int	pointer
[	O
clearvar	pointer
[	O
v	int
]	O
]	O
=	O
0	int
;	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
clearvar	pointer
[	O
v	int
]	O
]	O
=	O
0.0	int
;	O
}	O
output	function
(	O
)	O
;	O
}	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
baseobs	struct
.	O
do_nvar	int
;	O
v	int
++	O
)	O
{	O
dap_free	function
(	O
baseobs	struct
.	O
do_nam	pointer
[	O
v	int
]	O
,	O
"dataset: baseobs.do_nam[v]"	pointer
)	O
;	O
baseobs	struct
.	O
do_nam	pointer
[	O
v	int
]	O
=	O
NULL	O
;	O
}	O
dap_free	function
(	O
varspec	array
,	O
"dataset: varspec"	pointer
)	O
;	O
}	O
}	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dataset) unknown action: %s\n"	pointer
,	O
action	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
dap_free	function
(	O
dold	pointer
,	O
"dataset: dold"	pointer
)	O
;	O
dap_free	function
(	O
dnew	pointer
,	O
"dataset: dnew"	pointer
)	O
;	O
dap_free	function
(	O
oldvmem	pointer
,	O
"dataset: oldvmem"	pointer
)	O
;	O
dap_free	function
(	O
oldvar	pointer
,	O
"dataset: oldvar"	pointer
)	O
;	O
dap_free	function
(	O
newvmem	pointer
,	O
"dataset: newvmem"	pointer
)	O
;	O
dap_free	function
(	O
newvar	pointer
,	O
"dataset: newvar"	pointer
)	O
;	O
dap_free	function
(	O
outlist	pointer
,	O
"dataset: outlist"	pointer
)	O
;	O
if	O
(	O
clearvar	pointer
)	O
dap_free	function
(	O
clearvar	pointer
,	O
"dataset: clearvar"	pointer
)	O
;	O
if	O
(	O
celllist	pointer
)	O
dap_free	function
(	O
celllist	pointer
,	O
"dataset: celllist"	pointer
)	O
;	O
if	O
(	O
cellv	pointer
)	O
dap_free	function
(	O
cellv	pointer
,	O
"dataset: cellv"	pointer
)	O
;	O
if	O
(	O
classv	pointer
)	O
dap_free	function
(	O
classv	pointer
,	O
"dataset: classv"	pointer
)	O
;	O
if	O
(	O
slevelmem	pointer
)	O
{	O
dap_free	function
(	O
slevelmem	pointer
,	O
"dataset: slevelmem"	pointer
)	O
;	O
dap_free	function
(	O
slevel	array
,	O
"dataset: slevel"	pointer
)	O
;	O
dap_free	function
(	O
dlevelmem	pointer
,	O
"dataset: dlevelmem"	pointer
)	O
;	O
dap_free	function
(	O
dlevel	array
,	O
"dataset: dlevel"	pointer
)	O
;	O
dap_free	function
(	O
ilevelmem	pointer
,	O
"dataset: ilevelmem"	pointer
)	O
;	O
dap_free	function
(	O
ilevel	array
,	O
"dataset: ilevel"	pointer
)	O
;	O
dap_free	function
(	O
inlev	pointer
,	O
"dataset: inlev"	pointer
)	O
;	O
dap_free	function
(	O
outlev	pointer
,	O
"dataset: outlev"	pointer
)	O
;	O
dap_free	function
(	O
nlevels	int
,	O
"dataset: nlevels"	pointer
)	O
;	O
}	O
}	O
static	O
int	O
getblock	function
(	O
DFILE	struct
*	O
fp	pointer
)	O
{	O
char	O
block	array
[	O
BLOCKLEN	int
]	O
;	O
int	O
b	double
;	O
if	O
(	O
(	O
block	array
[	O
0	int
]	O
=	O
dgetc	function
(	O
fp	pointer
)	O
)	O
==	O
'\r'	O
)	O
return	O
0	int
;	O
for	O
(	O
b	double
=	O
1	int
;	O
b	double
<	O
BLOCKLEN	int
;	O
b	double
++	O
)	O
block	array
[	O
b	double
]	O
=	O
dgetc	function
(	O
fp	pointer
)	O
;	O
return	O
(	O
block	array
[	O
16	int
]	O
&	O
0xff	int
)	O
;	O
}	O
int	O
dap_clearobs	function
(	O
char	O
*	O
varspec	array
)	O
{	O
int	O
v	int
;	O
if	O
(	O
dap_ono	int
<	O
2	int
)	O
{	O
dap_prev	array
[	O
dap_ono	int
]	O
.	O
do_ivar	int
=	O
0	int
;	O
eof	array
[	O
dap_ono	int
]	O
=	O
0	int
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
dap_maxvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dap_prev	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
v	int
]	O
)	O
dap_free	function
(	O
dap_prev	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
v	int
]	O
,	O
"clearobs: dap_prev[dap_ono].do_str[v]"	pointer
)	O
;	O
dap_prev	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
v	int
]	O
=	O
NULL	O
;	O
}	O
}	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_ivar	int
=	O
0	int
;	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_ovar	int
=	O
0	int
;	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nvar	int
=	O
0	int
;	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_valid	int
=	O
0	int
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
dap_maxvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
v	int
]	O
)	O
dap_free	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
v	int
]	O
,	O
"clearobs: dap_obs[dap_ono].do_nam[v]"	pointer
)	O
;	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
v	int
]	O
=	O
NULL	O
;	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dl	pointer
[	O
v	int
]	O
=	O
NULL	O
;	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_il	pointer
[	O
v	int
]	O
=	O
NULL	O
;	O
if	O
(	O
!	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_sl	pointer
[	O
v	int
]	O
&&	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
v	int
]	O
)	O
dap_free	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
v	int
]	O
,	O
"clearobs: dap_obs[dap_ono].do_str[v]"	pointer
)	O
;	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
v	int
]	O
=	O
NULL	O
;	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_sl	pointer
[	O
v	int
]	O
=	O
0	int
;	O
}	O
if	O
(	O
varspec	array
)	O
dap_vd	function
(	O
varspec	array
,	O
1	int
)	O
;	O
else	O
dap_vd	function
(	O
"_type_ 8"	pointer
,	O
0	int
)	O
;	O
if	O
(	O
(	O
v	int
=	O
dap_varnum	function
(	O
"_type_"	pointer
)	O
)	O
<	O
0	int
)	O
{	O
fputs	function
(	O
"(clearobs) missing _type_ variable\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_out	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_ovar	int
++	O
]	O
=	O
v	int
;	O
return	O
v	int
;	O
}	O
void	O
infile	function
(	O
char	O
*	O
ifname	pointer
,	O
char	O
*	O
idelim	pointer
)	O
{	O
static	O
int	O
infinit	int
=	O
0	int
;	O
int	O
v	int
;	O
int	O
d	int
;	O
int	O
infldlen	int
;	O
char	O
*	O
fname	array
;	O
static	O
char	O
*	O
delim	array
;	O
static	O
int	O
delimlen	int
;	O
if	O
(	O
!	O
infinit	int
)	O
{	O
infinit	int
=	O
1	int
;	O
delimlen	int
=	O
(	O
dap_linelen	int
+	O
1	int
)	O
/	O
8	int
-	O
1	int
;	O
delim	array
=	O
dap_malloc	function
(	O
delimlen	int
+	O
1	int
,	O
"infile: delim"	pointer
)	O
;	O
fieldwd	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"infile: fieldwd"	pointer
)	O
;	O
}	O
if	O
(	O
dap_in	array
[	O
dap_ono	int
]	O
)	O
{	O
dfclose	function
(	O
dap_in	array
[	O
dap_ono	int
]	O
)	O
;	O
dap_in	array
[	O
dap_ono	int
]	O
=	O
(	O
DFILE	struct
*	O
)	O
NULL	O
;	O
}	O
if	O
(	O
dap_out	array
[	O
dap_ono	int
]	O
)	O
{	O
dfclose	function
(	O
dap_out	array
[	O
dap_ono	int
]	O
)	O
;	O
dap_out	array
[	O
dap_ono	int
]	O
=	O
(	O
DFILE	struct
*	O
)	O
NULL	O
;	O
}	O
if	O
(	O
!	O
ifname	pointer
||	O
!	O
ifname	pointer
[	O
0	int
]	O
)	O
{	O
fname	array
=	O
"/dev/null"	pointer
;	O
strcpy	function
(	O
delim	array
,	O
"|"	pointer
)	O
;	O
}	O
else	O
{	O
fname	array
=	O
ifname	pointer
;	O
if	O
(	O
!	O
idelim	pointer
||	O
!	O
idelim	pointer
[	O
0	int
]	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(infile) Delimiter string must be at least one character: %s\n"	pointer
,	O
delim	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
strlen	function
(	O
idelim	pointer
)	O
<=	O
delimlen	int
)	O
strcpy	function
(	O
delim	array
,	O
idelim	pointer
)	O
;	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(infile) Delimiter string too long: %s\n"	pointer
,	O
idelim	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
(	O
dap_in	array
[	O
dap_ono	int
]	O
=	O
dfopen	function
(	O
fname	array
,	O
"rf"	pointer
)	O
)	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(infile) can't read data file: %s\n"	pointer
,	O
fname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
intype	int
=	O
TEXT	int
;	O
if	O
(	O
!	O
strcmp	function
(	O
fname	array
+	O
strlen	function
(	O
fname	array
)	O
-	O
4	int
,	O
".dbf"	pointer
)	O
)	O
{	O
intype	int
=	O
DBASE	int
;	O
getblock	function
(	O
dap_in	array
[	O
dap_ono	int
]	O
)	O
;	O
for	O
(	O
inlen	int
=	O
0	int
;	O
(	O
infldlen	int
=	O
getblock	function
(	O
dap_in	array
[	O
dap_ono	int
]	O
)	O
)	O
;	O
inlen	int
+=	O
infldlen	int
)	O
;	O
}	O
dap_delim	int
=	O
delim	array
[	O
0	int
]	O
;	O
for	O
(	O
nfields	int
=	O
0	int
,	O
d	int
=	O
1	int
;	O
delim	array
[	O
d	int
]	O
;	O
nfields	int
++	O
)	O
{	O
if	O
(	O
nfields	int
<	O
dap_maxvar	int
)	O
{	O
for	O
(	O
fieldwd	pointer
[	O
nfields	int
]	O
=	O
0	int
;	O
delim	array
[	O
d	int
]	O
&&	O
delim	array
[	O
d	int
]	O
!=	O
dap_delim	int
;	O
)	O
{	O
fieldwd	pointer
[	O
nfields	int
]	O
=	O
10	int
*	O
fieldwd	pointer
[	O
nfields	int
]	O
+	O
delim	array
[	O
d	int
++	O
]	O
-	O
'0'	O
;	O
}	O
if	O
(	O
delim	array
[	O
d	int
]	O
)	O
d	int
++	O
;	O
}	O
else	O
{	O
fputs	function
(	O
"(infile) too many field width specifiers.\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
v	int
=	O
dap_clearobs	function
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
strcpy	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
v	int
]	O
,	O
"OBS"	pointer
)	O
;	O
lineno	array
[	O
dap_ono	int
]	O
=	O
1	int
;	O
toolong	int
=	O
0	int
;	O
}	O
void	O
input	function
(	O
char	O
varlist	array
[	O
]	O
)	O
{	O
int	O
v	int
;	O
int	O
l	int
;	O
int	O
i	int
;	O
static	O
char	O
*	O
vname	array
=	O
NULL	O
;	O
int	O
dim	pointer
;	O
int	O
d	int
;	O
if	O
(	O
!	O
vname	array
)	O
vname	array
=	O
dap_malloc	function
(	O
dap_namelen	int
+	O
1	int
,	O
"input: vname"	pointer
)	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
varlist	array
[	O
l	int
]	O
==	O
' '	O
;	O
l	int
++	O
)	O
;	O
while	O
(	O
varlist	array
[	O
l	int
]	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
varlist	array
[	O
l	int
+	O
i	int
]	O
&&	O
varlist	array
[	O
l	int
+	O
i	int
]	O
!=	O
' '	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
<	O
dap_namelen	int
)	O
vname	array
[	O
i	int
]	O
=	O
varlist	array
[	O
l	int
+	O
i	int
]	O
;	O
else	O
{	O
vname	array
[	O
i	int
]	O
=	O
'\0'	O
;	O
fprintf	function
(	O
dap_err	pointer
,	O
"(input) variable name too long: %s\n"	pointer
,	O
vname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
vname	array
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
(	O
v	int
=	O
dap_varnum	function
(	O
vname	array
)	O
)	O
>=	O
0	int
)	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_ivar	int
++	O
]	O
=	O
v	int
;	O
else	O
if	O
(	O
(	O
v	int
=	O
dap_arrnum	function
(	O
vname	array
,	O
&	O
dim	pointer
)	O
)	O
>=	O
0	int
)	O
{	O
for	O
(	O
d	int
=	O
0	int
;	O
d	int
<	O
dim	pointer
;	O
d	int
++	O
)	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_in	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_ivar	int
++	O
]	O
=	O
v	int
+	O
d	int
;	O
}	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(input) unknown variable: %s\n"	pointer
,	O
vname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
l	int
+=	O
i	int
;	O
while	O
(	O
varlist	array
[	O
l	int
]	O
==	O
' '	O
)	O
l	int
++	O
;	O
}	O
}	O
void	O
inset	function
(	O
char	O
*	O
fname	array
)	O
{	O
int	O
v	int
;	O
static	O
char	O
*	O
varspec	array
=	O
NULL	O
;	O
double	O
testd	double
;	O
if	O
(	O
!	O
varspec	array
)	O
varspec	array
=	O
dap_malloc	function
(	O
dap_linelen	int
+	O
1	int
,	O
"inset: varspec"	pointer
)	O
;	O
if	O
(	O
dap_in	array
[	O
dap_ono	int
]	O
)	O
{	O
dfclose	function
(	O
dap_in	array
[	O
dap_ono	int
]	O
)	O
;	O
dap_in	array
[	O
dap_ono	int
]	O
=	O
(	O
DFILE	struct
*	O
)	O
NULL	O
;	O
}	O
if	O
(	O
dap_out	array
[	O
dap_ono	int
]	O
)	O
{	O
dfclose	function
(	O
dap_out	array
[	O
dap_ono	int
]	O
)	O
;	O
dap_out	array
[	O
dap_ono	int
]	O
=	O
(	O
DFILE	struct
*	O
)	O
NULL	O
;	O
}	O
if	O
(	O
!	O
fname	array
)	O
return	O
;	O
if	O
(	O
!	O
(	O
dap_in	array
[	O
dap_ono	int
]	O
=	O
dfopen	function
(	O
fname	array
,	O
"r"	pointer
)	O
)	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(inset) can't read data set: %s\n"	pointer
,	O
fname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
intype	int
=	O
DSET	int
;	O
dap_delim	int
=	O
'\0'	O
;	O
if	O
(	O
dap_getline	function
(	O
dap_in	array
[	O
dap_ono	int
]	O
,	O
varspec	array
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(inset) data set empty: %s\n"	pointer
,	O
fname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
nfields	int
=	O
0	int
;	O
dap_clearobs	function
(	O
varspec	array
)	O
;	O
dap_delim	int
=	O
SETDELIM	char
;	O
lineno	array
[	O
dap_ono	int
]	O
=	O
1	int
;	O
}	O
static	O
void	O
fixlist	function
(	O
char	O
*	O
varl	pointer
,	O
char	O
*	O
varlist	array
)	O
{	O
static	O
int	O
fixinit	int
=	O
0	int
;	O
int	O
l	int
;	O
int	O
f	pointer
;	O
int	O
inbrack	int
;	O
static	O
char	O
*	O
vname	array
;	O
int	O
dim	pointer
;	O
static	O
int	O
*	O
outv	pointer
;	O
int	O
l0	int
;	O
int	O
l1	int
;	O
int	O
f1	int
;	O
int	O
nv	int
;	O
int	O
v	int
;	O
int	O
vn	int
;	O
if	O
(	O
!	O
fixinit	int
)	O
{	O
fixinit	int
=	O
1	int
;	O
vname	array
=	O
dap_malloc	function
(	O
dap_namelen	int
+	O
1	int
,	O
"fixlist: vname"	pointer
)	O
;	O
outv	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"fixlist: outv"	pointer
)	O
;	O
}	O
if	O
(	O
!	O
varl	pointer
)	O
{	O
fputs	function
(	O
"(fixlist) missing variable list.\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
!	O
varlist	array
)	O
{	O
fputs	function
(	O
"(fixlist) missing string for fixed variable list.\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
for	O
(	O
inbrack	int
=	O
0	int
,	O
l	int
=	O
0	int
,	O
f	pointer
=	O
0	int
;	O
varl	pointer
[	O
l	int
]	O
;	O
l	int
++	O
)	O
{	O
if	O
(	O
inbrack	int
)	O
{	O
if	O
(	O
varl	pointer
[	O
l	int
]	O
==	O
']'	O
)	O
inbrack	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
varl	pointer
[	O
l	int
]	O
==	O
'['	O
)	O
inbrack	int
=	O
1	int
;	O
else	O
varlist	array
[	O
f	pointer
++	O
]	O
=	O
varl	pointer
[	O
l	int
]	O
;	O
}	O
varlist	array
[	O
f	pointer
]	O
=	O
'\0'	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
varlist	array
[	O
l	int
]	O
==	O
' '	O
;	O
l	int
++	O
)	O
;	O
l0	int
=	O
0	int
;	O
if	O
(	O
varlist	array
[	O
l	int
]	O
==	O
'!'	O
)	O
{	O
for	O
(	O
l	int
++	O
;	O
varlist	array
[	O
l	int
]	O
==	O
' '	O
;	O
l	int
++	O
)	O
;	O
varlist	array
[	O
l0	int
++	O
]	O
=	O
'!'	O
;	O
}	O
for	O
(	O
nv	int
=	O
0	int
,	O
l1	int
=	O
l0	int
;	O
varlist	array
[	O
l	int
]	O
;	O
)	O
{	O
for	O
(	O
f	pointer
=	O
0	int
;	O
varlist	array
[	O
l	int
+	O
f	pointer
]	O
&&	O
varlist	array
[	O
l	int
+	O
f	pointer
]	O
!=	O
' '	O
;	O
f	pointer
++	O
)	O
{	O
if	O
(	O
f	pointer
<	O
dap_namelen	int
)	O
vname	array
[	O
f	pointer
]	O
=	O
varlist	array
[	O
l	int
+	O
f	pointer
]	O
;	O
else	O
{	O
vname	array
[	O
f	pointer
]	O
=	O
'\0'	O
;	O
fprintf	function
(	O
dap_err	pointer
,	O
"(fixlist) variable name too long: %s\n"	pointer
,	O
vname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
vname	array
[	O
f	pointer
]	O
=	O
'\0'	O
;	O
if	O
(	O
(	O
(	O
v	int
=	O
dap_varnum	function
(	O
vname	array
)	O
)	O
<	O
0	int
)	O
&&	O
(	O
(	O
v	int
=	O
dap_arrnum	function
(	O
vname	array
,	O
&	O
dim	pointer
)	O
)	O
<	O
0	int
)	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(fixlist) unknown variable: %s\n"	pointer
,	O
vname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
for	O
(	O
vn	int
=	O
0	int
;	O
vn	int
<	O
nv	int
;	O
vn	int
++	O
)	O
{	O
if	O
(	O
outv	pointer
[	O
vn	int
]	O
==	O
v	int
)	O
break	O
;	O
}	O
if	O
(	O
vn	int
==	O
nv	int
)	O
{	O
outv	pointer
[	O
nv	int
++	O
]	O
=	O
v	int
;	O
if	O
(	O
l1	int
>	O
l0	int
)	O
varlist	array
[	O
l1	int
++	O
]	O
=	O
' '	O
;	O
for	O
(	O
f1	int
=	O
0	int
;	O
f1	int
<	O
f	pointer
;	O
f1	int
++	O
)	O
varlist	array
[	O
l1	int
++	O
]	O
=	O
varlist	array
[	O
l	int
++	O
]	O
;	O
}	O
else	O
l	int
+=	O
f	pointer
;	O
while	O
(	O
varlist	array
[	O
l	int
]	O
==	O
' '	O
)	O
l	int
++	O
;	O
}	O
varlist	array
[	O
l1	int
]	O
=	O
'\0'	O
;	O
}	O
void	O
outset	function
(	O
char	O
*	O
fname	array
,	O
char	O
*	O
varl	pointer
)	O
{	O
static	O
int	O
outinit	int
=	O
0	int
;	O
int	O
l	int
;	O
int	O
i	int
;	O
static	O
char	O
*	O
varlist	array
;	O
static	O
char	O
*	O
vname	array
;	O
int	O
v	int
;	O
int	O
w	int
;	O
int	O
first	int
;	O
int	O
dim	pointer
;	O
int	O
d	int
;	O
double	O
testd	double
;	O
if	O
(	O
dap_out	array
[	O
dap_ono	int
]	O
)	O
{	O
dfclose	function
(	O
dap_out	array
[	O
dap_ono	int
]	O
)	O
;	O
dap_out	array
[	O
dap_ono	int
]	O
=	O
(	O
DFILE	struct
*	O
)	O
NULL	O
;	O
}	O
if	O
(	O
!	O
fname	array
)	O
{	O
fputs	function
(	O
"(outset) no dataset name.\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
!	O
outinit	int
)	O
{	O
outinit	int
=	O
1	int
;	O
varlist	array
=	O
dap_malloc	function
(	O
dap_listlen	int
,	O
"outset: varlist"	pointer
)	O
;	O
vname	array
=	O
dap_malloc	function
(	O
dap_listlen	int
,	O
"outset: vname"	pointer
)	O
;	O
}	O
if	O
(	O
!	O
(	O
dap_out	array
[	O
dap_ono	int
]	O
=	O
dfopen	function
(	O
fname	array
,	O
"w"	pointer
)	O
)	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(outset) Can't write data set: %s\n"	pointer
,	O
fname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
!	O
varl	pointer
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(outset (%s)) Missing variable list.\n"	pointer
,	O
fname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
fixlist	function
(	O
varl	pointer
,	O
varlist	array
)	O
;	O
if	O
(	O
varlist	array
[	O
0	int
]	O
)	O
{	O
for	O
(	O
l	int
=	O
0	int
;	O
varlist	array
[	O
l	int
]	O
==	O
' '	O
;	O
l	int
++	O
)	O
;	O
if	O
(	O
varlist	array
[	O
l	int
]	O
==	O
'!'	O
)	O
{	O
for	O
(	O
l	int
++	O
;	O
varlist	array
[	O
l	int
]	O
==	O
' '	O
;	O
l	int
++	O
)	O
;	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_ovar	int
=	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nvar	int
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nvar	int
;	O
v	int
++	O
)	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_out	pointer
[	O
v	int
]	O
=	O
v	int
;	O
while	O
(	O
varlist	array
[	O
l	int
]	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
varlist	array
[	O
l	int
+	O
i	int
]	O
&&	O
varlist	array
[	O
l	int
+	O
i	int
]	O
!=	O
' '	O
;	O
i	int
++	O
)	O
vname	array
[	O
i	int
]	O
=	O
varlist	array
[	O
l	int
+	O
i	int
]	O
;	O
vname	array
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
(	O
w	int
=	O
dap_varnum	function
(	O
vname	array
)	O
)	O
>=	O
0	int
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_ovar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_out	pointer
[	O
v	int
]	O
==	O
w	int
)	O
break	O
;	O
}	O
if	O
(	O
v	int
==	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_ovar	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(outset (%s)) variable not in list of variables to exclude: %s\n"	pointer
,	O
fname	array
,	O
vname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
while	O
(	O
v	int
<	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_ovar	int
-	O
1	int
)	O
{	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_out	pointer
[	O
v	int
]	O
=	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_out	pointer
[	O
v	int
+	O
1	int
]	O
;	O
v	int
++	O
;	O
}	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_ovar	int
--	O
;	O
}	O
else	O
if	O
(	O
(	O
w	int
=	O
dap_arrnum	function
(	O
vname	array
,	O
&	O
dim	pointer
)	O
)	O
>=	O
0	int
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_ovar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_out	pointer
[	O
v	int
]	O
==	O
w	int
)	O
break	O
;	O
}	O
while	O
(	O
v	int
<	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_ovar	int
-	O
dim	pointer
)	O
{	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_out	pointer
[	O
v	int
]	O
=	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_out	pointer
[	O
v	int
+	O
dim	pointer
]	O
;	O
v	int
++	O
;	O
}	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_ovar	int
-=	O
dim	pointer
;	O
}	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(outset(%s)) unknown variable: %s\n"	pointer
,	O
fname	array
,	O
vname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
l	int
+=	O
i	int
;	O
while	O
(	O
varlist	array
[	O
l	int
]	O
==	O
' '	O
)	O
l	int
++	O
;	O
}	O
}	O
else	O
{	O
while	O
(	O
varlist	array
[	O
l	int
]	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
varlist	array
[	O
l	int
+	O
i	int
]	O
&&	O
varlist	array
[	O
l	int
+	O
i	int
]	O
!=	O
' '	O
;	O
i	int
++	O
)	O
vname	array
[	O
i	int
]	O
=	O
varlist	array
[	O
l	int
+	O
i	int
]	O
;	O
vname	array
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
(	O
v	int
=	O
dap_varnum	function
(	O
vname	array
)	O
)	O
>=	O
0	int
)	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_out	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_ovar	int
++	O
]	O
=	O
v	int
;	O
else	O
if	O
(	O
(	O
v	int
=	O
dap_arrnum	function
(	O
vname	array
,	O
&	O
dim	pointer
)	O
)	O
>=	O
0	int
)	O
{	O
for	O
(	O
d	int
=	O
0	int
;	O
d	int
<	O
dim	pointer
;	O
d	int
++	O
)	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_out	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_ovar	int
++	O
]	O
=	O
v	int
+	O
d	int
;	O
}	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(outset(%s)) unknown variable: %s\n"	pointer
,	O
fname	array
,	O
vname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
l	int
+=	O
i	int
;	O
while	O
(	O
varlist	array
[	O
l	int
]	O
==	O
' '	O
)	O
l	int
++	O
;	O
}	O
}	O
}	O
else	O
{	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_ovar	int
=	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nvar	int
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nvar	int
;	O
v	int
++	O
)	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_out	pointer
[	O
v	int
]	O
=	O
v	int
;	O
}	O
if	O
(	O
dap_varnum	function
(	O
"_type_"	pointer
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(outset (%s)) missing _type_ variable\n"	pointer
,	O
fname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_ovar	int
;	O
v	int
++	O
)	O
{	O
for	O
(	O
w	int
=	O
v	int
+	O
1	int
;	O
w	int
<	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_ovar	int
;	O
w	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_out	pointer
[	O
v	int
]	O
==	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_out	pointer
[	O
w	int
]	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(outset (%s)) duplicate variable in output list: %s\n"	pointer
,	O
fname	array
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_out	pointer
[	O
w	int
]	O
]	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
}	O
for	O
(	O
v	int
=	O
0	int
,	O
first	int
=	O
1	int
;	O
v	int
<	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_ovar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
!	O
first	int
)	O
dap_putc	function
(	O
' '	O
,	O
dap_out	array
[	O
dap_ono	int
]	O
)	O
;	O
dputs	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_out	pointer
[	O
v	int
]	O
]	O
,	O
" "	pointer
,	O
dap_out	array
[	O
dap_ono	int
]	O
)	O
;	O
dputi	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_out	pointer
[	O
v	int
]	O
]	O
,	O
dap_out	array
[	O
dap_ono	int
]	O
)	O
;	O
first	int
=	O
0	int
;	O
}	O
dap_putc	function
(	O
'\n'	O
,	O
dap_out	array
[	O
dap_ono	int
]	O
)	O
;	O
dflush	function
(	O
dap_out	array
[	O
dap_ono	int
]	O
)	O
;	O
outline	int
=	O
0	int
;	O
}	O
void	O
output	function
(	O
)	O
{	O
int	O
v	int
;	O
int	O
first	int
;	O
if	O
(	O
(	O
v	int
=	O
dap_varnum	function
(	O
"_type_"	pointer
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(output) missing _type_ variable\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
for	O
(	O
v	int
=	O
0	int
,	O
first	int
=	O
1	int
;	O
v	int
<	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_ovar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
!	O
first	int
)	O
dap_putc	function
(	O
SETDELIM	char
,	O
dap_out	array
[	O
dap_ono	int
]	O
)	O
;	O
if	O
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_out	pointer
[	O
v	int
]	O
]	O
==	O
INT	int
)	O
{	O
if	O
(	O
!	O
dap_ono	int
&&	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_il	pointer
[	O
dap_obs	array
[	O
0	int
]	O
.	O
do_out	pointer
[	O
v	int
]	O
]	O
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_int	pointer
[	O
dap_obs	array
[	O
0	int
]	O
.	O
do_out	pointer
[	O
v	int
]	O
]	O
=	O
*	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_il	pointer
[	O
dap_obs	array
[	O
0	int
]	O
.	O
do_out	pointer
[	O
v	int
]	O
]	O
;	O
dap_putint	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_int	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_out	pointer
[	O
v	int
]	O
]	O
,	O
dap_out	array
[	O
dap_ono	int
]	O
)	O
;	O
}	O
else	O
if	O
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_out	pointer
[	O
v	int
]	O
]	O
==	O
DBL	O
)	O
{	O
if	O
(	O
!	O
dap_ono	int
&&	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dl	pointer
[	O
dap_obs	array
[	O
0	int
]	O
.	O
do_out	pointer
[	O
v	int
]	O
]	O
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
dap_obs	array
[	O
0	int
]	O
.	O
do_out	pointer
[	O
v	int
]	O
]	O
=	O
*	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dl	pointer
[	O
dap_obs	array
[	O
0	int
]	O
.	O
do_out	pointer
[	O
v	int
]	O
]	O
;	O
dap_double	double
=	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_out	pointer
[	O
v	int
]	O
]	O
;	O
dap_putdouble	function
(	O
dap_out	array
[	O
dap_ono	int
]	O
)	O
;	O
}	O
else	O
{	O
dputs	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_out	pointer
[	O
v	int
]	O
]	O
,	O
""	pointer
,	O
dap_out	array
[	O
dap_ono	int
]	O
)	O
;	O
}	O
first	int
=	O
0	int
;	O
}	O
dap_putc	function
(	O
'\n'	O
,	O
dap_out	array
[	O
dap_ono	int
]	O
)	O
;	O
dflush	function
(	O
dap_out	array
[	O
dap_ono	int
]	O
)	O
;	O
if	O
(	O
dap_outreport	int
&&	O
!	O
(	O
++	O
outline	int
%	O
dap_outreport	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"(output) %d lines written to %s...\n"	pointer
,	O
outline	int
,	O
dap_out	array
[	O
dap_ono	int
]	O
->	O
dfile_name	pointer
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
}	O
}	O
static	O
int	O
expand	function
(	O
char	O
*	O
varlist	array
,	O
int	O
*	O
varv	array
,	O
int	O
maxvars	int
)	O
{	O
int	O
nvars	int
;	O
int	O
m	pointer
;	O
int	O
i	int
;	O
char	O
*	O
mname	pointer
;	O
char	O
*	O
newname	array
;	O
int	O
arrn	int
;	O
int	O
dim	pointer
;	O
int	O
d	int
;	O
int	O
include	int
;	O
if	O
(	O
!	O
varlist	array
)	O
return	O
0	int
;	O
if	O
(	O
!	O
varv	array
)	O
{	O
fputs	function
(	O
"(expand) Missing variable index list.\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
mname	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
varlist	array
)	O
+	O
1	int
,	O
"expand: mname"	pointer
)	O
;	O
newname	array
=	O
dap_malloc	function
(	O
strlen	function
(	O
varlist	array
)	O
+	O
1	int
,	O
"expand: newname"	pointer
)	O
;	O
include	int
=	O
1	int
;	O
for	O
(	O
m	pointer
=	O
0	int
;	O
varlist	array
[	O
m	pointer
]	O
==	O
' '	O
;	O
m	pointer
++	O
)	O
;	O
if	O
(	O
varlist	array
[	O
m	pointer
]	O
==	O
'!'	O
)	O
{	O
for	O
(	O
m	pointer
++	O
;	O
varlist	array
[	O
m	pointer
]	O
==	O
' '	O
;	O
m	pointer
++	O
)	O
;	O
include	int
=	O
-	O
1	int
;	O
}	O
for	O
(	O
nvars	int
=	O
0	int
;	O
varlist	array
[	O
m	pointer
]	O
;	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
varlist	array
[	O
m	pointer
+	O
i	int
]	O
&&	O
varlist	array
[	O
m	pointer
+	O
i	int
]	O
!=	O
' '	O
&&	O
varlist	array
[	O
m	pointer
+	O
i	int
]	O
!=	O
'>'	O
;	O
i	int
++	O
)	O
mname	pointer
[	O
i	int
]	O
=	O
varlist	array
[	O
m	pointer
+	O
i	int
]	O
;	O
mname	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
m	pointer
+=	O
i	int
;	O
while	O
(	O
varlist	array
[	O
m	pointer
]	O
==	O
' '	O
)	O
m	pointer
++	O
;	O
newname	array
[	O
0	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
varlist	array
[	O
m	pointer
]	O
==	O
'>'	O
)	O
{	O
if	O
(	O
include	int
<	O
0	int
)	O
{	O
fputs	function
(	O
"(expand) Can't rename variables being excluded\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
for	O
(	O
m	pointer
++	O
;	O
varlist	array
[	O
m	pointer
]	O
==	O
' '	O
;	O
m	pointer
++	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
varlist	array
[	O
m	pointer
+	O
i	int
]	O
&&	O
varlist	array
[	O
m	pointer
+	O
i	int
]	O
!=	O
' '	O
&&	O
varlist	array
[	O
m	pointer
+	O
i	int
]	O
!=	O
'>'	O
;	O
i	int
++	O
)	O
newname	array
[	O
i	int
]	O
=	O
varlist	array
[	O
m	pointer
+	O
i	int
]	O
;	O
newname	array
[	O
i	int
]	O
=	O
'\0'	O
;	O
m	pointer
+=	O
i	int
;	O
while	O
(	O
varlist	array
[	O
m	pointer
]	O
==	O
' '	O
)	O
m	pointer
++	O
;	O
}	O
if	O
(	O
nvars	int
>=	O
maxvars	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(expand) More than %d variables: %s\n"	pointer
,	O
maxvars	int
,	O
varlist	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
arrn	int
=	O
dap_arrnum	function
(	O
mname	pointer
,	O
&	O
dim	pointer
)	O
)	O
>=	O
0	int
)	O
{	O
for	O
(	O
d	int
=	O
0	int
;	O
d	int
<	O
dim	pointer
;	O
d	int
++	O
)	O
{	O
if	O
(	O
newname	array
[	O
0	int
]	O
)	O
{	O
dap_free	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
arrn	int
]	O
,	O
"expand: dap_obs[dap_ono].do_nam[arrn]"	pointer
)	O
;	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
arrn	int
]	O
=	O
dap_malloc	function
(	O
strlen	function
(	O
newname	array
)	O
+	O
6	int
,	O
"expand: dap_obs[dap_ono].do_nam[arrn]"	pointer
)	O
;	O
sprintf	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
arrn	int
]	O
,	O
"%s[%d]"	pointer
,	O
newname	array
,	O
d	int
)	O
;	O
}	O
varv	array
[	O
nvars	int
++	O
]	O
=	O
arrn	int
++	O
;	O
}	O
}	O
else	O
if	O
(	O
(	O
varv	array
[	O
nvars	int
]	O
=	O
dap_varnum	function
(	O
mname	pointer
)	O
)	O
>	O
0	int
)	O
{	O
if	O
(	O
newname	array
[	O
0	int
]	O
)	O
{	O
dap_free	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
nvars	int
]	O
]	O
,	O
"expand: dap_obs[dap_ono].do_nam[varv[nvars]]"	pointer
)	O
;	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
nvars	int
]	O
]	O
=	O
dap_malloc	function
(	O
strlen	function
(	O
newname	array
)	O
+	O
1	int
,	O
"expand: dap_obs[dap_ono].do_nam[varv[nvars]]"	pointer
)	O
;	O
strcpy	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
nvars	int
]	O
]	O
,	O
newname	array
)	O
;	O
}	O
nvars	int
++	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(expand) Variable unknown: %s\n"	pointer
,	O
mname	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
dap_free	function
(	O
mname	pointer
,	O
"expand: mname"	pointer
)	O
;	O
dap_free	function
(	O
newname	array
,	O
"expand: newname"	pointer
)	O
;	O
return	O
include	int
*	O
nvars	int
;	O
}	O
static	O
void	O
varcat	function
(	O
char	O
*	O
to	pointer
,	O
char	O
*	O
from	pointer
)	O
{	O
int	O
t	int
,	O
f	pointer
,	O
ff	int
;	O
for	O
(	O
f	pointer
=	O
0	int
;	O
from	pointer
[	O
f	pointer
]	O
==	O
' '	O
;	O
f	pointer
++	O
)	O
;	O
for	O
(	O
t	int
=	O
0	int
;	O
to	pointer
[	O
t	int
]	O
;	O
t	int
++	O
)	O
;	O
while	O
(	O
from	pointer
[	O
f	pointer
]	O
)	O
{	O
for	O
(	O
ff	int
=	O
f	pointer
;	O
from	pointer
[	O
ff	int
]	O
&&	O
from	pointer
[	O
ff	int
]	O
!=	O
' '	O
&&	O
from	pointer
[	O
ff	int
]	O
!=	O
'>'	O
;	O
ff	int
++	O
)	O
;	O
while	O
(	O
from	pointer
[	O
ff	int
]	O
==	O
' '	O
)	O
ff	int
++	O
;	O
if	O
(	O
from	pointer
[	O
ff	int
]	O
==	O
'>'	O
)	O
{	O
for	O
(	O
f	pointer
=	O
ff	int
+	O
1	int
;	O
from	pointer
[	O
f	pointer
]	O
==	O
' '	O
;	O
f	pointer
++	O
)	O
;	O
}	O
while	O
(	O
from	pointer
[	O
f	pointer
]	O
&&	O
from	pointer
[	O
f	pointer
]	O
!=	O
' '	O
)	O
to	pointer
[	O
t	int
++	O
]	O
=	O
from	pointer
[	O
f	pointer
++	O
]	O
;	O
to	pointer
[	O
t	int
++	O
]	O
=	O
' '	O
;	O
while	O
(	O
from	pointer
[	O
f	pointer
]	O
==	O
' '	O
)	O
f	pointer
++	O
;	O
}	O
to	pointer
[	O
t	int
]	O
=	O
'\0'	O
;	O
}	O
void	O
merge	function
(	O
char	O
*	O
fname1	pointer
,	O
char	O
*	O
vars1	pointer
,	O
char	O
*	O
fname2	pointer
,	O
char	O
*	O
vars2	pointer
,	O
char	O
*	O
marks	array
,	O
char	O
*	O
outname	pointer
)	O
{	O
int	O
*	O
varv1	pointer
,	O
*	O
varv2	pointer
;	O
int	O
*	O
ovarv1	pointer
,	O
*	O
ovarv2	pointer
;	O
int	O
nvar1	int
,	O
nvar2	int
;	O
int	O
*	O
markv1	pointer
;	O
int	O
*	O
markv2	pointer
;	O
int	O
nmark	int
;	O
int	O
v1	int
,	O
v2	int
;	O
int	O
vv1	int
,	O
vv2	int
;	O
char	O
*	O
outlist	pointer
;	O
char	O
*	O
outlist1	pointer
;	O
char	O
*	O
outlist2	pointer
;	O
int	O
goon1	int
;	O
double	O
ddiff	double
;	O
int	O
isdiff	int
;	O
int	O
vars1null	int
,	O
vars2null	int
;	O
char	O
*	O
vars1a	pointer
,	O
*	O
vars2a	pointer
;	O
int	O
exclude1	int
,	O
exclude2	int
;	O
int	O
nvar1a	int
,	O
nvar2a	int
;	O
int	O
*	O
varv1a	pointer
,	O
*	O
varv2a	pointer
;	O
if	O
(	O
!	O
fname1	pointer
||	O
!	O
fname2	pointer
||	O
!	O
outname	pointer
)	O
{	O
fputs	function
(	O
"(merge) Missing dataset name.\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
vars1	pointer
&&	O
index	function
(	O
vars1	pointer
,	O
'['	O
)	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(merge) Variable lists may not contain individual array elements: %s\n"	pointer
,	O
vars1	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
vars2	pointer
&&	O
index	function
(	O
vars2	pointer
,	O
'['	O
)	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(merge) Variable lists may not contain individual array elements: %s\n"	pointer
,	O
vars2	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
vars1null	int
=	O
0	int
;	O
vars2null	int
=	O
0	int
;	O
outlist	pointer
=	O
dap_malloc	function
(	O
dap_listlen	int
,	O
"merge: outlist"	pointer
)	O
;	O
outlist1	pointer
=	O
dap_malloc	function
(	O
dap_listlen	int
,	O
"merge: outlist1"	pointer
)	O
;	O
outlist2	pointer
=	O
dap_malloc	function
(	O
dap_listlen	int
,	O
"merge:outlist2"	pointer
)	O
;	O
varv1	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"merge: varv1"	pointer
)	O
;	O
varv2	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"merge: varv2"	pointer
)	O
;	O
ovarv1	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"merge: ovarv1"	pointer
)	O
;	O
ovarv2	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"merge: ovarv2"	pointer
)	O
;	O
markv1	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"merge: markv1"	pointer
)	O
;	O
markv2	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"merge: markv2"	pointer
)	O
;	O
dap_ono	int
=	O
0	int
;	O
inset	function
(	O
fname1	pointer
)	O
;	O
if	O
(	O
vars1	pointer
&&	O
!	O
vars1	pointer
[	O
0	int
]	O
)	O
{	O
vars1null	int
=	O
1	int
;	O
vars1	pointer
=	O
dap_malloc	function
(	O
dap_listlen	int
,	O
"merge: vars1"	pointer
)	O
;	O
vars1	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
for	O
(	O
v1	int
=	O
0	int
;	O
v1	int
<	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nvar	int
;	O
v1	int
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
v1	int
]	O
,	O
"_type_"	pointer
)	O
)	O
{	O
strcat	function
(	O
vars1	pointer
,	O
" "	pointer
)	O
;	O
strcat	function
(	O
vars1	pointer
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
v1	int
]	O
)	O
;	O
}	O
}	O
}	O
nvar1	int
=	O
expand	function
(	O
vars1	pointer
,	O
varv1	pointer
,	O
dap_maxvar	int
)	O
;	O
exclude1	int
=	O
0	int
;	O
if	O
(	O
nvar1	int
<	O
0	int
)	O
{	O
exclude1	int
=	O
1	int
;	O
nvar1	int
=	O
-	O
nvar1	int
;	O
vars1a	pointer
=	O
dap_malloc	function
(	O
dap_listlen	int
,	O
"merge: vars1a"	pointer
)	O
;	O
vars1a	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
varv1a	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
dap_maxvar	int
,	O
"merge: varv1a"	pointer
)	O
;	O
for	O
(	O
v1	int
=	O
0	int
,	O
nvar1a	int
=	O
0	int
;	O
v1	int
<	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nvar	int
;	O
v1	int
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
v1	int
]	O
,	O
"_type_"	pointer
)	O
)	O
continue	O
;	O
for	O
(	O
vv1	int
=	O
0	int
;	O
vv1	int
<	O
nvar1	int
;	O
vv1	int
++	O
)	O
{	O
if	O
(	O
varv1	pointer
[	O
vv1	int
]	O
==	O
v1	int
)	O
break	O
;	O
}	O
if	O
(	O
vv1	int
==	O
nvar1	int
)	O
{	O
strcat	function
(	O
vars1a	pointer
,	O
" "	pointer
)	O
;	O
strcat	function
(	O
vars1a	pointer
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
v1	int
]	O
)	O
;	O
varv1a	pointer
[	O
nvar1a	int
++	O
]	O
=	O
v1	int
;	O
}	O
}	O
if	O
(	O
vars1null	int
)	O
dap_free	function
(	O
vars1	pointer
,	O
"merge: vars1"	pointer
)	O
;	O
vars1	pointer
=	O
vars1a	pointer
;	O
nvar1	int
=	O
nvar1a	int
;	O
dap_free	function
(	O
varv1	pointer
,	O
"merge: varv1"	pointer
)	O
;	O
varv1	pointer
=	O
varv1a	pointer
;	O
}	O
if	O
(	O
marks	array
)	O
nmark	int
=	O
dap_list	function
(	O
marks	array
,	O
markv1	pointer
,	O
dap_maxvar	int
)	O
;	O
else	O
nmark	int
=	O
0	int
;	O
dap_ono	int
=	O
1	int
;	O
inset	function
(	O
fname2	pointer
)	O
;	O
if	O
(	O
vars2	pointer
&&	O
!	O
vars2	pointer
[	O
0	int
]	O
)	O
{	O
vars2null	int
=	O
1	int
;	O
vars2	pointer
=	O
dap_malloc	function
(	O
dap_listlen	int
,	O
"merge: vars2"	pointer
)	O
;	O
vars2	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
for	O
(	O
v2	int
=	O
0	int
;	O
v2	int
<	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nvar	int
;	O
v2	int
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
v2	int
]	O
,	O
"_type_"	pointer
)	O
)	O
{	O
strcat	function
(	O
vars2	pointer
,	O
" "	pointer
)	O
;	O
strcat	function
(	O
vars2	pointer
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
v2	int
]	O
)	O
;	O
}	O
}	O
}	O
nvar2	int
=	O
expand	function
(	O
vars2	pointer
,	O
varv2	pointer
,	O
dap_maxvar	int
)	O
;	O
exclude2	int
=	O
0	int
;	O
if	O
(	O
nvar2	int
<	O
0	int
)	O
{	O
exclude2	int
=	O
1	int
;	O
nvar2	int
=	O
-	O
nvar2	int
;	O
vars2a	pointer
=	O
dap_malloc	function
(	O
dap_listlen	int
,	O
"merge: vars2a"	pointer
)	O
;	O
vars2a	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
varv2a	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
dap_maxvar	int
,	O
"merge: varv2a"	pointer
)	O
;	O
for	O
(	O
v2	int
=	O
0	int
,	O
nvar2a	int
=	O
0	int
;	O
v2	int
<	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nvar	int
;	O
v2	int
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
v2	int
]	O
,	O
"_type_"	pointer
)	O
)	O
continue	O
;	O
for	O
(	O
vv2	int
=	O
0	int
;	O
vv2	int
<	O
nvar2	int
;	O
vv2	int
++	O
)	O
{	O
if	O
(	O
varv2	pointer
[	O
vv2	int
]	O
==	O
v2	int
)	O
break	O
;	O
}	O
if	O
(	O
vv2	int
==	O
nvar2	int
)	O
{	O
strcat	function
(	O
vars2a	pointer
,	O
" "	pointer
)	O
;	O
strcat	function
(	O
vars2a	pointer
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
v2	int
]	O
)	O
;	O
varv2a	pointer
[	O
nvar2a	int
++	O
]	O
=	O
v2	int
;	O
}	O
}	O
if	O
(	O
vars2null	int
)	O
dap_free	function
(	O
vars2	pointer
,	O
"merge: vars2"	pointer
)	O
;	O
vars2	pointer
=	O
vars2a	pointer
;	O
nvar2	int
=	O
nvar2a	int
;	O
dap_free	function
(	O
varv2	pointer
,	O
"merge: varv2"	pointer
)	O
;	O
varv2	pointer
=	O
varv2a	pointer
;	O
}	O
dap_list	function
(	O
marks	array
,	O
markv2	pointer
,	O
dap_maxvar	int
)	O
;	O
for	O
(	O
v1	int
=	O
0	int
;	O
v1	int
<	O
nmark	int
;	O
v1	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
markv1	pointer
[	O
v1	int
]	O
]	O
!=	O
dap_obs	array
[	O
1	int
]	O
.	O
do_len	pointer
[	O
markv2	pointer
[	O
v1	int
]	O
]	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(merge) Part variables of different types: %s (%d) and %s (%d)\n"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
markv1	pointer
[	O
v1	int
]	O
]	O
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
markv1	pointer
[	O
v1	int
]	O
]	O
,	O
dap_obs	array
[	O
1	int
]	O
.	O
do_nam	pointer
[	O
markv2	pointer
[	O
v1	int
]	O
]	O
,	O
dap_obs	array
[	O
1	int
]	O
.	O
do_len	pointer
[	O
markv2	pointer
[	O
v1	int
]	O
]	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
outlist	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
vars2	pointer
&&	O
nvar2	int
>	O
0	int
)	O
varcat	function
(	O
outlist	pointer
,	O
vars2	pointer
)	O
;	O
outlist2	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
vars2	pointer
&&	O
nvar2	int
>	O
0	int
)	O
varcat	function
(	O
outlist2	pointer
,	O
vars2	pointer
)	O
;	O
dap_ono	int
=	O
2	int
;	O
dap_obs	array
[	O
2	int
]	O
.	O
do_nvar	int
=	O
0	int
;	O
dap_obs	array
[	O
2	int
]	O
.	O
do_ovar	int
=	O
0	int
;	O
dap_obs	array
[	O
2	int
]	O
.	O
do_out	pointer
[	O
dap_obs	array
[	O
2	int
]	O
.	O
do_ovar	int
++	O
]	O
=	O
dap_vd	function
(	O
"_type_ 8"	pointer
,	O
0	int
)	O
;	O
for	O
(	O
v2	int
=	O
0	int
;	O
v2	int
<	O
nvar2	int
;	O
v2	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array
[	O
2	int
]	O
.	O
do_nam	pointer
[	O
dap_obs	array
[	O
2	int
]	O
.	O
do_nvar	int
]	O
)	O
dap_free	function
(	O
dap_obs	array
[	O
2	int
]	O
.	O
do_nam	pointer
[	O
dap_obs	array
[	O
2	int
]	O
.	O
do_nvar	int
]	O
,	O
"merge: dap_obs[2].do_nam[dap_obs[2].do_nvar]"	pointer
)	O
;	O
dap_obs	array
[	O
2	int
]	O
.	O
do_nam	pointer
[	O
dap_obs	array
[	O
2	int
]	O
.	O
do_nvar	int
]	O
=	O
dap_malloc	function
(	O
strlen	function
(	O
dap_obs	array
[	O
1	int
]	O
.	O
do_nam	pointer
[	O
varv2	pointer
[	O
v2	int
]	O
]	O
)	O
+	O
1	int
,	O
"merge: dap_obs[1].do_nam[varv2[v2]]"	pointer
)	O
;	O
strcpy	function
(	O
dap_obs	array
[	O
2	int
]	O
.	O
do_nam	pointer
[	O
dap_obs	array
[	O
2	int
]	O
.	O
do_nvar	int
]	O
,	O
dap_obs	array
[	O
1	int
]	O
.	O
do_nam	pointer
[	O
varv2	pointer
[	O
v2	int
]	O
]	O
)	O
;	O
dap_obs	array
[	O
2	int
]	O
.	O
do_len	pointer
[	O
dap_obs	array
[	O
2	int
]	O
.	O
do_nvar	int
]	O
=	O
dap_obs	array
[	O
1	int
]	O
.	O
do_len	pointer
[	O
varv2	pointer
[	O
v2	int
]	O
]	O
;	O
dap_obs	array
[	O
2	int
]	O
.	O
do_nvar	int
++	O
;	O
}	O
outlist1	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
vars1	pointer
&&	O
nvar1	int
>	O
0	int
)	O
{	O
strcat	function
(	O
outlist	pointer
,	O
" "	pointer
)	O
;	O
varcat	function
(	O
outlist	pointer
,	O
vars1	pointer
)	O
;	O
varcat	function
(	O
outlist1	pointer
,	O
vars1	pointer
)	O
;	O
}	O
for	O
(	O
v1	int
=	O
0	int
;	O
v1	int
<	O
nvar1	int
;	O
v1	int
++	O
)	O
{	O
for	O
(	O
v2	int
=	O
0	int
;	O
v2	int
<	O
nvar2	int
;	O
v2	int
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv1	pointer
[	O
v1	int
]	O
]	O
,	O
dap_obs	array
[	O
1	int
]	O
.	O
do_nam	pointer
[	O
varv2	pointer
[	O
v2	int
]	O
]	O
)	O
)	O
break	O
;	O
}	O
if	O
(	O
v2	int
<	O
nvar2	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(merge) variable appears in lists for both %s and %s: %s\n"	pointer
,	O
fname1	pointer
,	O
fname2	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv1	pointer
[	O
v1	int
]	O
]	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
dap_obs	array
[	O
2	int
]	O
.	O
do_nam	pointer
[	O
dap_obs	array
[	O
2	int
]	O
.	O
do_nvar	int
]	O
)	O
dap_free	function
(	O
dap_obs	array
[	O
2	int
]	O
.	O
do_nam	pointer
[	O
dap_obs	array
[	O
2	int
]	O
.	O
do_nvar	int
]	O
,	O
"merge: dap_obs[2].do_nam[dap_obs[2].do_nvar]"	pointer
)	O
;	O
dap_obs	array
[	O
2	int
]	O
.	O
do_nam	pointer
[	O
dap_obs	array
[	O
2	int
]	O
.	O
do_nvar	int
]	O
=	O
dap_malloc	function
(	O
strlen	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv1	pointer
[	O
v1	int
]	O
]	O
)	O
+	O
1	int
,	O
"merge: dap_obs[0].do_nam[varv1[v1]]"	pointer
)	O
;	O
strcpy	function
(	O
dap_obs	array
[	O
2	int
]	O
.	O
do_nam	pointer
[	O
dap_obs	array
[	O
2	int
]	O
.	O
do_nvar	int
]	O
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv1	pointer
[	O
v1	int
]	O
]	O
)	O
;	O
dap_obs	array
[	O
2	int
]	O
.	O
do_len	pointer
[	O
dap_obs	array
[	O
2	int
]	O
.	O
do_nvar	int
]	O
=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
varv1	pointer
[	O
v1	int
]	O
]	O
;	O
dap_obs	array
[	O
2	int
]	O
.	O
do_nvar	int
++	O
;	O
}	O
}	O
outset	function
(	O
outname	pointer
,	O
outlist	pointer
)	O
;	O
strcpy	function
(	O
dap_obs	array
[	O
2	int
]	O
.	O
do_str	pointer
[	O
dap_varnum	function
(	O
"_type_"	pointer
)	O
]	O
,	O
"OBS"	pointer
)	O
;	O
expand	function
(	O
outlist1	pointer
,	O
ovarv1	pointer
,	O
dap_maxvar	int
)	O
;	O
expand	function
(	O
outlist2	pointer
,	O
ovarv2	pointer
,	O
dap_maxvar	int
)	O
;	O
dap_ono	int
=	O
0	int
;	O
goon1	int
=	O
step	function
(	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
dap_ono	int
=	O
1	int
;	O
if	O
(	O
step	function
(	O
)	O
)	O
{	O
while	O
(	O
goon1	int
)	O
{	O
isdiff	int
=	O
0	int
;	O
if	O
(	O
nmark	int
)	O
{	O
for	O
(	O
v1	int
=	O
0	int
;	O
v1	int
<	O
nmark	int
;	O
v1	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
markv1	pointer
[	O
v1	int
]	O
]	O
==	O
DBL	O
)	O
{	O
ddiff	double
=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
markv1	pointer
[	O
v1	int
]	O
]	O
-	O
dap_obs	array
[	O
1	int
]	O
.	O
do_dbl	pointer
[	O
markv2	pointer
[	O
v1	int
]	O
]	O
;	O
if	O
(	O
ddiff	double
<	O
0.0	int
)	O
isdiff	int
=	O
-	O
1	int
;	O
else	O
if	O
(	O
ddiff	double
>	O
0.0	int
)	O
isdiff	int
=	O
1	int
;	O
else	O
isdiff	int
=	O
0	int
;	O
if	O
(	O
isdiff	int
)	O
break	O
;	O
}	O
else	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
markv1	pointer
[	O
v1	int
]	O
]	O
==	O
INT	int
)	O
{	O
isdiff	int
=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_int	pointer
[	O
markv1	pointer
[	O
v1	int
]	O
]	O
-	O
dap_obs	array
[	O
1	int
]	O
.	O
do_int	pointer
[	O
markv2	pointer
[	O
v1	int
]	O
]	O
;	O
if	O
(	O
isdiff	int
)	O
break	O
;	O
}	O
else	O
if	O
(	O
(	O
isdiff	int
=	O
strcmp	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
markv1	pointer
[	O
v1	int
]	O
]	O
,	O
dap_obs	array
[	O
1	int
]	O
.	O
do_str	pointer
[	O
markv2	pointer
[	O
v1	int
]	O
]	O
)	O
)	O
)	O
break	O
;	O
}	O
}	O
if	O
(	O
isdiff	int
<	O
0	int
)	O
{	O
dap_ono	int
=	O
0	int
;	O
goon1	int
=	O
step	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
isdiff	int
>	O
0	int
)	O
break	O
;	O
else	O
{	O
for	O
(	O
v1	int
=	O
0	int
;	O
v1	int
<	O
nvar1	int
;	O
v1	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
varv1	pointer
[	O
v1	int
]	O
]	O
==	O
DBL	O
)	O
dap_obs	array
[	O
2	int
]	O
.	O
do_dbl	pointer
[	O
ovarv1	pointer
[	O
v1	int
]	O
]	O
=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv1	pointer
[	O
v1	int
]	O
]	O
;	O
else	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
varv1	pointer
[	O
v1	int
]	O
]	O
==	O
INT	int
)	O
dap_obs	array
[	O
2	int
]	O
.	O
do_int	pointer
[	O
ovarv1	pointer
[	O
v1	int
]	O
]	O
=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_int	pointer
[	O
varv1	pointer
[	O
v1	int
]	O
]	O
;	O
else	O
{	O
if	O
(	O
dap_obs	array
[	O
2	int
]	O
.	O
do_str	pointer
[	O
ovarv1	pointer
[	O
v1	int
]	O
]	O
)	O
dap_free	function
(	O
dap_obs	array
[	O
2	int
]	O
.	O
do_str	pointer
[	O
ovarv1	pointer
[	O
v1	int
]	O
]	O
,	O
"merge: dap_obs[2].do_str[ovarv1[v1]]"	pointer
)	O
;	O
dap_obs	array
[	O
2	int
]	O
.	O
do_str	pointer
[	O
ovarv1	pointer
[	O
v1	int
]	O
]	O
=	O
dap_malloc	function
(	O
strlen	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
varv1	pointer
[	O
v1	int
]	O
]	O
)	O
+	O
1	int
,	O
"merge: dap_obs[0].do_str[ovarv1[v1]]"	pointer
)	O
;	O
strcpy	function
(	O
dap_obs	array
[	O
2	int
]	O
.	O
do_str	pointer
[	O
ovarv1	pointer
[	O
v1	int
]	O
]	O
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
varv1	pointer
[	O
v1	int
]	O
]	O
)	O
;	O
}	O
}	O
for	O
(	O
v2	int
=	O
0	int
;	O
v2	int
<	O
nvar2	int
;	O
v2	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array
[	O
1	int
]	O
.	O
do_len	pointer
[	O
varv2	pointer
[	O
v2	int
]	O
]	O
==	O
DBL	O
)	O
dap_obs	array
[	O
2	int
]	O
.	O
do_dbl	pointer
[	O
ovarv2	pointer
[	O
v2	int
]	O
]	O
=	O
dap_obs	array
[	O
1	int
]	O
.	O
do_dbl	pointer
[	O
varv2	pointer
[	O
v2	int
]	O
]	O
;	O
else	O
if	O
(	O
dap_obs	array
[	O
1	int
]	O
.	O
do_len	pointer
[	O
varv2	pointer
[	O
v2	int
]	O
]	O
==	O
INT	int
)	O
dap_obs	array
[	O
2	int
]	O
.	O
do_int	pointer
[	O
ovarv2	pointer
[	O
v2	int
]	O
]	O
=	O
dap_obs	array
[	O
1	int
]	O
.	O
do_int	pointer
[	O
varv2	pointer
[	O
v2	int
]	O
]	O
;	O
else	O
{	O
if	O
(	O
dap_obs	array
[	O
2	int
]	O
.	O
do_str	pointer
[	O
ovarv2	pointer
[	O
v2	int
]	O
]	O
)	O
dap_free	function
(	O
dap_obs	array
[	O
2	int
]	O
.	O
do_str	pointer
[	O
ovarv2	pointer
[	O
v2	int
]	O
]	O
,	O
"merge: dap_obs[2].do_str[ovarv2[v2]]"	pointer
)	O
;	O
dap_obs	array
[	O
2	int
]	O
.	O
do_str	pointer
[	O
ovarv2	pointer
[	O
v2	int
]	O
]	O
=	O
dap_malloc	function
(	O
strlen	function
(	O
dap_obs	array
[	O
1	int
]	O
.	O
do_str	pointer
[	O
varv2	pointer
[	O
v2	int
]	O
]	O
)	O
+	O
1	int
,	O
"merge: dap_obs[1].do_str[ovarv2[v2]]"	pointer
)	O
;	O
strcpy	function
(	O
dap_obs	array
[	O
2	int
]	O
.	O
do_str	pointer
[	O
ovarv2	pointer
[	O
v2	int
]	O
]	O
,	O
dap_obs	array
[	O
1	int
]	O
.	O
do_str	pointer
[	O
varv2	pointer
[	O
v2	int
]	O
]	O
)	O
;	O
}	O
}	O
dap_ono	int
=	O
2	int
;	O
output	function
(	O
)	O
;	O
dap_ono	int
=	O
0	int
;	O
goon1	int
=	O
step	function
(	O
)	O
;	O
}	O
if	O
(	O
!	O
nmark	int
)	O
break	O
;	O
}	O
}	O
else	O
break	O
;	O
}	O
dap_ono	int
=	O
0	int
;	O
if	O
(	O
dap_in	array
[	O
0	int
]	O
)	O
{	O
dfclose	function
(	O
dap_in	array
[	O
0	int
]	O
)	O
;	O
dap_in	array
[	O
0	int
]	O
=	O
(	O
DFILE	struct
*	O
)	O
NULL	O
;	O
}	O
if	O
(	O
dap_in	array
[	O
1	int
]	O
)	O
{	O
dfclose	function
(	O
dap_in	array
[	O
1	int
]	O
)	O
;	O
dap_in	array
[	O
1	int
]	O
=	O
(	O
DFILE	struct
*	O
)	O
NULL	O
;	O
}	O
if	O
(	O
dap_out	array
[	O
dap_ono	int
]	O
)	O
{	O
dfclose	function
(	O
dap_out	array
[	O
dap_ono	int
]	O
)	O
;	O
dap_out	array
[	O
dap_ono	int
]	O
=	O
(	O
DFILE	struct
*	O
)	O
NULL	O
;	O
}	O
dap_free	function
(	O
outlist	pointer
,	O
"merge: outlist"	pointer
)	O
;	O
dap_free	function
(	O
outlist1	pointer
,	O
"merge: outlist1"	pointer
)	O
;	O
dap_free	function
(	O
outlist2	pointer
,	O
"merge: outlist2"	pointer
)	O
;	O
dap_free	function
(	O
ovarv1	pointer
,	O
"merge: ovarv1"	pointer
)	O
;	O
dap_free	function
(	O
ovarv2	pointer
,	O
"merge: ovarv2"	pointer
)	O
;	O
dap_free	function
(	O
markv1	pointer
,	O
"merge: markv1"	pointer
)	O
;	O
dap_free	function
(	O
markv2	pointer
,	O
"merge: markv2"	pointer
)	O
;	O
if	O
(	O
vars1null	int
)	O
dap_free	function
(	O
vars1	pointer
,	O
"merge: vars1"	pointer
)	O
;	O
if	O
(	O
vars2null	int
)	O
dap_free	function
(	O
vars2	pointer
,	O
"merge: vars2"	pointer
)	O
;	O
if	O
(	O
exclude1	int
<	O
0	int
)	O
{	O
dap_free	function
(	O
vars1a	pointer
,	O
"merge: vars1a"	pointer
)	O
;	O
dap_free	function
(	O
varv1a	pointer
,	O
"merge: varv1a"	pointer
)	O
;	O
}	O
else	O
dap_free	function
(	O
varv1	pointer
,	O
"merge: varv1"	pointer
)	O
;	O
if	O
(	O
exclude2	int
<	O
0	int
)	O
{	O
dap_free	function
(	O
vars2a	pointer
,	O
"merge: vars2a"	pointer
)	O
;	O
dap_free	function
(	O
varv2a	pointer
,	O
"merge: varv2a"	pointer
)	O
;	O
}	O
else	O
dap_free	function
(	O
varv2	pointer
,	O
"merge: varv2"	pointer
)	O
;	O
}	O
void	O
title	function
(	O
char	O
*	O
text	pointer
)	O
{	O
dap_title	pointer
=	O
text	pointer
;	O
}	O
void	O
dap_head	function
(	O
int	O
markv	array
[	O
]	O
,	O
int	O
nmark	int
)	O
{	O
time_t	long
t	int
;	O
int	O
m	pointer
;	O
fputs	function
(	O
"\n================================="	pointer
,	O
dap_lst	pointer
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"\nDap %3d. "	pointer
,	O
pageno	int
++	O
)	O
;	O
time	function
(	O
&	O
t	int
)	O
;	O
fputs	function
(	O
ctime	function
(	O
&	O
t	int
)	O
,	O
dap_lst	pointer
)	O
;	O
putc	function
(	O
'\n'	O
,	O
dap_lst	pointer
)	O
;	O
if	O
(	O
dap_title	pointer
)	O
{	O
fputs	function
(	O
dap_title	pointer
,	O
dap_lst	pointer
)	O
;	O
putc	function
(	O
'\n'	O
,	O
dap_lst	pointer
)	O
;	O
}	O
if	O
(	O
nmark	int
)	O
{	O
fprintf	function
(	O
dap_lst	pointer
,	O
"\nFor: "	pointer
)	O
;	O
for	O
(	O
m	pointer
=	O
0	int
;	O
m	pointer
<	O
nmark	int
;	O
m	pointer
++	O
)	O
{	O
switch	O
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
markv	array
[	O
m	pointer
]	O
]	O
)	O
{	O
case	O
DBL	O
:	O
fprintf	function
(	O
dap_lst	pointer
,	O
"%s = %g"	pointer
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
markv	array
[	O
m	pointer
]	O
]	O
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
markv	array
[	O
m	pointer
]	O
]	O
)	O
;	O
break	O
;	O
case	O
INT	int
:	O
fprintf	function
(	O
dap_lst	pointer
,	O
"%s = %d"	pointer
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
markv	array
[	O
m	pointer
]	O
]	O
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_int	pointer
[	O
markv	array
[	O
m	pointer
]	O
]	O
)	O
;	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
dap_lst	pointer
,	O
"%s = %s"	pointer
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
markv	array
[	O
m	pointer
]	O
]	O
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
markv	array
[	O
m	pointer
]	O
]	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
m	pointer
<	O
nmark	int
-	O
1	int
)	O
fputs	function
(	O
", "	pointer
,	O
dap_lst	pointer
)	O
;	O
}	O
putc	function
(	O
'\n'	O
,	O
dap_lst	pointer
)	O
;	O
}	O
putc	function
(	O
'\n'	O
,	O
dap_lst	pointer
)	O
;	O
}	O
typedef	O
struct	O
CharList	struct
CharList	struct
;	O
struct	O
CharList	struct
{	O
char	O
*	O
word	pointer
;	O
CharList	struct
*	O
next	pointer
;	O
}	O
;	O
typedef	O
struct	O
AttributeList	struct
AttributeList	struct
;	O
struct	O
AttributeList	struct
{	O
char	O
*	O
word	pointer
;	O
int	O
size	int
;	O
int	O
type	int
;	O
AttributeList	struct
*	O
next	pointer
;	O
}	O
;	O
CharList	struct
extractWords	function
(	O
char	O
*	O
buffer	pointer
,	O
long	O
size	int
,	O
char	O
*	O
delimiter	pointer
)	O
{	O
char	O
*	O
bufferWord	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
char	O
)	O
*	O
size	int
+	O
1	int
)	O
;	O
memset	function
(	O
bufferWord	pointer
,	O
'\0'	O
,	O
size	int
+	O
1	int
)	O
;	O
CharList	struct
list	struct
;	O
list	struct
.	O
word	pointer
=	O
NULL	O
;	O
list	struct
.	O
next	pointer
=	O
NULL	O
;	O
CharList	struct
*	O
current	pointer
=	O
&	O
list	struct
;	O
long	O
i	int
=	O
0l	int
;	O
long	O
sSize	long
=	O
0l	int
;	O
long	O
sIndex	long
=	O
0l	int
;	O
for	O
(	O
i	int
=	O
0l	int
;	O
i	int
<	O
size	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
buffer	pointer
[	O
i	int
]	O
==	O
'\r'	O
||	O
buffer	pointer
[	O
i	int
]	O
==	O
'\t'	O
)	O
continue	O
;	O
if	O
(	O
buffer	pointer
[	O
i	int
]	O
==	O
delimiter	pointer
[	O
0	int
]	O
)	O
{	O
current	pointer
->	O
word	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
char	O
)	O
*	O
sIndex	long
+	O
5	int
)	O
;	O
strcpy	function
(	O
current	pointer
->	O
word	pointer
,	O
bufferWord	pointer
)	O
;	O
current	pointer
->	O
next	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
CharList	struct
)	O
)	O
;	O
current	pointer
=	O
current	pointer
->	O
next	pointer
;	O
sSize	long
=	O
sIndex	long
;	O
sIndex	long
=	O
0	int
;	O
memset	function
(	O
bufferWord	pointer
,	O
'\0'	O
,	O
size	int
+	O
1	int
)	O
;	O
}	O
else	O
{	O
bufferWord	pointer
[	O
sIndex	long
]	O
=	O
buffer	pointer
[	O
i	int
]	O
;	O
sIndex	long
++	O
;	O
}	O
}	O
if	O
(	O
sIndex	long
>	O
0	int
)	O
{	O
current	pointer
->	O
word	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
(	O
sizeof	O
(	O
char	O
)	O
*	O
strlen	function
(	O
bufferWord	pointer
)	O
)	O
+	O
1	int
)	O
;	O
strcpy	function
(	O
current	pointer
->	O
word	pointer
,	O
bufferWord	pointer
)	O
;	O
current	pointer
->	O
next	pointer
=	O
NULL	O
;	O
}	O
free	function
(	O
bufferWord	pointer
)	O
;	O
return	O
list	struct
;	O
}	O
void	O
cleanAttributeList	function
(	O
AttributeList	struct
*	O
list	struct
)	O
{	O
AttributeList	struct
*	O
actualatt	pointer
=	O
list	struct
;	O
do	O
{	O
actualatt	pointer
=	O
list	struct
;	O
AttributeList	struct
*	O
prev	pointer
=	O
list	struct
;	O
AttributeList	struct
*	O
prev2	pointer
=	O
list	struct
;	O
do	O
{	O
prev2	pointer
=	O
prev	pointer
;	O
prev	pointer
=	O
actualatt	pointer
;	O
actualatt	pointer
=	O
actualatt	pointer
->	O
next	pointer
;	O
}	O
while	O
(	O
actualatt	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
prev	pointer
!=	O
list	struct
)	O
{	O
free	function
(	O
prev	pointer
->	O
word	pointer
)	O
;	O
free	function
(	O
prev	pointer
)	O
;	O
}	O
prev2	pointer
->	O
next	pointer
=	O
NULL	O
;	O
}	O
while	O
(	O
list	struct
->	O
next	pointer
!=	O
NULL	O
)	O
;	O
}	O
void	O
cleanCharList	function
(	O
CharList	struct
*	O
list	struct
)	O
{	O
CharList	struct
*	O
actualatt	pointer
=	O
list	struct
;	O
do	O
{	O
actualatt	pointer
=	O
list	struct
;	O
CharList	struct
*	O
prev	pointer
=	O
list	struct
;	O
CharList	struct
*	O
prev2	pointer
=	O
list	struct
;	O
do	O
{	O
prev2	pointer
=	O
prev	pointer
;	O
prev	pointer
=	O
actualatt	pointer
;	O
actualatt	pointer
=	O
actualatt	pointer
->	O
next	pointer
;	O
}	O
while	O
(	O
actualatt	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
prev	pointer
!=	O
list	struct
)	O
{	O
free	function
(	O
prev	pointer
->	O
word	pointer
)	O
;	O
free	function
(	O
prev	pointer
)	O
;	O
}	O
prev2	pointer
->	O
next	pointer
=	O
NULL	O
;	O
}	O
while	O
(	O
list	struct
->	O
next	pointer
!=	O
NULL	O
)	O
;	O
}	O
int	O
import	function
(	O
char	O
*	O
fname	array
,	O
char	O
*	O
fileToLoad	pointer
,	O
char	O
*	O
format	array
,	O
char	O
*	O
delimiter	pointer
,	O
int	O
replace	int
,	O
int	O
getnames	int
)	O
{	O
infile	function
(	O
fileToLoad	pointer
,	O
delimiter	pointer
)	O
;	O
FILE	struct
*	O
pFile	pointer
;	O
long	O
lSize	long
;	O
char	O
*	O
buffer	pointer
;	O
char	O
*	O
bufferline	pointer
;	O
size_t	long
result	long
;	O
if	O
(	O
strcmp	function
(	O
format	array
,	O
"CSV"	pointer
)	O
&&	O
strcmp	function
(	O
format	array
,	O
"DLM"	pointer
)	O
&&	O
strcmp	function
(	O
format	array
,	O
"csv"	pointer
)	O
&&	O
strcmp	function
(	O
format	array
,	O
"dlm"	pointer
)	O
&&	O
strcmp	function
(	O
format	array
,	O
"TAB"	pointer
)	O
&&	O
strcmp	function
(	O
format	array
,	O
"tab"	pointer
)	O
)	O
{	O
printf	function
(	O
"Format not supported :%s\n"	pointer
,	O
format	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
strlen	function
(	O
delimiter	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
strcmp	function
(	O
format	array
,	O
"CSV"	pointer
)	O
||	O
strcmp	function
(	O
format	array
,	O
"csv"	pointer
)	O
)	O
delimiter	pointer
=	O
","	pointer
;	O
if	O
(	O
strcmp	function
(	O
format	array
,	O
"DLM"	pointer
)	O
||	O
strcmp	function
(	O
format	array
,	O
"dlm"	pointer
)	O
)	O
delimiter	pointer
=	O
" "	pointer
;	O
if	O
(	O
strcmp	function
(	O
format	array
,	O
"TAB"	pointer
)	O
||	O
strcmp	function
(	O
format	array
,	O
"tab"	pointer
)	O
)	O
delimiter	pointer
=	O
"\t"	pointer
;	O
}	O
pFile	pointer
=	O
fopen	function
(	O
fileToLoad	pointer
,	O
"rb"	pointer
)	O
;	O
if	O
(	O
pFile	pointer
==	O
NULL	O
)	O
{	O
printf	function
(	O
"File loading error :%s\n"	pointer
,	O
fileToLoad	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
fseek	function
(	O
pFile	pointer
,	O
0	int
,	O
SEEK_END	int
)	O
;	O
lSize	long
=	O
ftell	function
(	O
pFile	pointer
)	O
;	O
rewind	function
(	O
pFile	pointer
)	O
;	O
buffer	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
char	O
)	O
*	O
lSize	long
)	O
;	O
if	O
(	O
buffer	pointer
==	O
NULL	O
)	O
{	O
printf	function
(	O
"Memory error \n"	pointer
)	O
;	O
exit	function
(	O
2	int
)	O
;	O
}	O
bufferline	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
char	O
)	O
*	O
lSize	long
)	O
;	O
if	O
(	O
bufferline	pointer
==	O
NULL	O
)	O
{	O
printf	function
(	O
"2nd Memory error \n"	pointer
)	O
;	O
exit	function
(	O
2	int
)	O
;	O
}	O
result	long
=	O
fread	function
(	O
buffer	pointer
,	O
1	int
,	O
lSize	long
,	O
pFile	pointer
)	O
;	O
if	O
(	O
result	long
!=	O
lSize	long
)	O
{	O
printf	function
(	O
"Reading error \n"	pointer
)	O
;	O
exit	function
(	O
3	int
)	O
;	O
}	O
long	O
sIndex	long
=	O
0l	int
;	O
long	O
sSize	long
=	O
0l	int
;	O
long	O
i	int
=	O
0l	int
;	O
AttributeList	struct
listatt	struct
;	O
listatt	struct
.	O
word	pointer
=	O
NULL	O
;	O
listatt	struct
.	O
next	pointer
=	O
NULL	O
;	O
int	O
lineCnt	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0l	int
;	O
i	int
<	O
lSize	long
;	O
i	int
++	O
)	O
{	O
if	O
(	O
buffer	pointer
[	O
i	int
]	O
==	O
'\n'	O
)	O
{	O
CharList	struct
list	struct
=	O
extractWords	function
(	O
bufferline	pointer
,	O
sIndex	long
,	O
delimiter	pointer
)	O
;	O
CharList	struct
*	O
actual	pointer
=	O
&	O
list	struct
;	O
int	O
counter	int
=	O
0	int
;	O
do	O
{	O
char	O
*	O
word	pointer
=	O
actual	pointer
->	O
word	pointer
;	O
int	O
sizeStr	int
=	O
strlen	function
(	O
word	pointer
)	O
;	O
AttributeList	struct
*	O
actualatt	pointer
=	O
&	O
listatt	struct
;	O
AttributeList	struct
*	O
prev	pointer
=	O
actualatt	pointer
;	O
if	O
(	O
lineCnt	int
==	O
0	int
)	O
{	O
if	O
(	O
actualatt	pointer
->	O
word	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
getnames	int
)	O
{	O
actualatt	pointer
->	O
word	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
char	O
)	O
*	O
strlen	function
(	O
word	pointer
)	O
+	O
5	int
)	O
;	O
strcpy	function
(	O
actualatt	pointer
->	O
word	pointer
,	O
word	pointer
)	O
;	O
}	O
else	O
{	O
actualatt	pointer
->	O
word	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
char	O
)	O
*	O
10	int
)	O
;	O
sprintf	function
(	O
actualatt	pointer
->	O
word	pointer
,	O
"X%d"	pointer
,	O
counter	int
)	O
;	O
}	O
}	O
else	O
{	O
do	O
{	O
char	O
*	O
wordatt	pointer
=	O
actualatt	pointer
->	O
word	pointer
;	O
if	O
(	O
strcmp	function
(	O
wordatt	pointer
,	O
word	pointer
)	O
==	O
0	int
)	O
{	O
break	O
;	O
}	O
prev	pointer
=	O
actualatt	pointer
;	O
actualatt	pointer
=	O
actualatt	pointer
->	O
next	pointer
;	O
}	O
while	O
(	O
actualatt	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
actualatt	pointer
==	O
NULL	O
)	O
{	O
prev	pointer
->	O
next	pointer
=	O
(	O
AttributeList	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
AttributeList	struct
)	O
)	O
;	O
prev	pointer
->	O
next	pointer
->	O
word	pointer
=	O
NULL	O
;	O
prev	pointer
=	O
prev	pointer
->	O
next	pointer
;	O
if	O
(	O
getnames	int
)	O
{	O
prev	pointer
->	O
word	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
char	O
)	O
*	O
strlen	function
(	O
word	pointer
)	O
+	O
5	int
)	O
;	O
strcpy	function
(	O
prev	pointer
->	O
word	pointer
,	O
word	pointer
)	O
;	O
}	O
else	O
{	O
prev	pointer
->	O
word	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
char	O
)	O
*	O
10	int
)	O
;	O
sprintf	function
(	O
prev	pointer
->	O
word	pointer
,	O
"X%d"	pointer
,	O
counter	int
)	O
;	O
}	O
prev	pointer
->	O
next	pointer
=	O
NULL	O
;	O
}	O
}	O
}	O
actualatt	pointer
=	O
&	O
listatt	struct
;	O
prev	pointer
=	O
actualatt	pointer
;	O
if	O
(	O
(	O
getnames	int
&&	O
lineCnt	int
>	O
0	int
)	O
||	O
!	O
getnames	int
)	O
{	O
int	O
counterbis	int
=	O
0	int
;	O
do	O
{	O
if	O
(	O
counter	int
==	O
counterbis	int
)	O
break	O
;	O
actualatt	pointer
=	O
actualatt	pointer
->	O
next	pointer
;	O
counterbis	int
++	O
;	O
}	O
while	O
(	O
actualatt	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
actualatt	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
sizeStr	int
>	O
actualatt	pointer
->	O
size	int
)	O
actualatt	pointer
->	O
size	int
=	O
sizeStr	int
;	O
if	O
(	O
actualatt	pointer
->	O
size	int
>	O
1000	int
)	O
actualatt	pointer
->	O
size	int
=	O
1000	int
;	O
float	O
f	pointer
;	O
if	O
(	O
sscanf	function
(	O
word	pointer
,	O
"%f"	pointer
,	O
&	O
f	pointer
)	O
!=	O
0	int
)	O
actualatt	pointer
->	O
type	int
=	O
DOUBLER	int
;	O
else	O
actualatt	pointer
->	O
type	int
=	O
STRINGER	int
;	O
}	O
}	O
actual	pointer
=	O
actual	pointer
->	O
next	pointer
;	O
counter	int
++	O
;	O
}	O
while	O
(	O
actual	pointer
!=	O
NULL	O
)	O
;	O
sSize	long
=	O
sIndex	long
;	O
sIndex	long
=	O
0	int
;	O
lineCnt	int
++	O
;	O
cleanCharList	function
(	O
&	O
list	struct
)	O
;	O
}	O
else	O
{	O
bufferline	pointer
[	O
sIndex	long
]	O
=	O
buffer	pointer
[	O
i	int
]	O
;	O
sIndex	long
++	O
;	O
}	O
}	O
fclose	function
(	O
pFile	pointer
)	O
;	O
free	function
(	O
buffer	pointer
)	O
;	O
free	function
(	O
bufferline	pointer
)	O
;	O
AttributeList	struct
*	O
actualatt	pointer
=	O
&	O
listatt	struct
;	O
int	O
countcol	int
=	O
0	int
;	O
do	O
{	O
char	O
*	O
wordatt	pointer
=	O
actualatt	pointer
->	O
word	pointer
;	O
if	O
(	O
wordatt	pointer
!=	O
NULL	O
)	O
{	O
int	O
sierr	int
=	O
strlen	function
(	O
wordatt	pointer
)	O
+	O
6	int
;	O
char	O
*	O
bufferer	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
char	O
)	O
*	O
sierr	int
)	O
;	O
if	O
(	O
actualatt	pointer
->	O
type	int
==	O
DOUBLER	int
)	O
{	O
sprintf	function
(	O
bufferer	pointer
,	O
"%s -1"	pointer
,	O
wordatt	pointer
)	O
;	O
dap_vd	function
(	O
bufferer	pointer
,	O
-	O
1	int
)	O
;	O
}	O
else	O
{	O
int	O
size	int
=	O
1000	int
;	O
if	O
(	O
actualatt	pointer
->	O
size	int
<	O
1000	int
)	O
size	int
=	O
actualatt	pointer
->	O
size	int
;	O
sprintf	function
(	O
bufferer	pointer
,	O
"%s %d"	pointer
,	O
wordatt	pointer
,	O
actualatt	pointer
->	O
size	int
)	O
;	O
dap_vd	function
(	O
bufferer	pointer
,	O
size	int
)	O
;	O
}	O
}	O
countcol	int
++	O
;	O
actualatt	pointer
=	O
actualatt	pointer
->	O
next	pointer
;	O
}	O
while	O
(	O
actualatt	pointer
!=	O
NULL	O
)	O
;	O
outset	function
(	O
fname	array
,	O
""	pointer
)	O
;	O
skip	function
(	O
2	int
)	O
;	O
while	O
(	O
step	function
(	O
)	O
)	O
output	function
(	O
)	O
;	O
cleanAttributeList	function
(	O
&	O
listatt	struct
)	O
;	O
return	O
0	int
;	O
}	O
