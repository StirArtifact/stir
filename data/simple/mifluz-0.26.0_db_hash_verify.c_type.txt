static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: hash_verify.c,v 1.2 2014/04/17 20:27:29 sebdiaz Exp $"	pointer
;	O
static	O
int	O
__ham_dups_unsorted	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
u_int8_t	char
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
int	O
__ham_vrfy_bucket	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
VRFY_DBINFO	struct
*	O
,	O
HMETA	struct
*	O
,	O
u_int32_t	int
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
int	O
__ham_vrfy_item	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
VRFY_DBINFO	struct
*	O
,	O
db_pgno_t	int
,	O
PAGE	struct
*	O
,	O
u_int32_t	int
,	O
u_int32_t	int
)	O
)	O
;	O
int	O
CDB___ham_vrfy_meta	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
m	pointer
,	O
pgno	int
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
HMETA	struct
*	O
m	pointer
;	O
db_pgno_t	int
pgno	int
;	O
u_int32_t	int
flags	int
;	O
{	O
HASH	struct
*	O
hashp	pointer
;	O
VRFY_PAGEINFO	struct
*	O
pip	pointer
;	O
int	O
i	int
,	O
ret	int
,	O
t_ret	int
,	O
isbad	int
;	O
u_int32_t	int
pwr	int
,	O
mbucket	int
;	O
u_int32_t	int
(	O
*	O
hfunc	pointer
)	O
__P	O
(	O
(	O
const	O
void	O
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_getpageinfo	function
(	O
vdp	pointer
,	O
pgno	int
,	O
&	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
isbad	int
=	O
0	int
;	O
hashp	pointer
=	O
dbp	pointer
->	O
h_internal	pointer
;	O
if	O
(	O
hashp	pointer
!=	O
NULL	O
&&	O
hashp	pointer
->	O
h_hash	pointer
!=	O
NULL	O
)	O
hfunc	pointer
=	O
hashp	pointer
->	O
h_hash	pointer
;	O
else	O
hfunc	pointer
=	O
CDB___ham_func5	function
;	O
if	O
(	O
!	O
F_ISSET	O
(	O
pip	pointer
,	O
VRFY_INCOMPLETE	int
)	O
&&	O
(	O
ret	int
=	O
CDB___db_vrfy_meta	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
&	O
m	pointer
->	O
dbmeta	struct
,	O
pgno	int
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
ret	int
==	O
DB_VERIFY_BAD	O
)	O
isbad	int
=	O
1	int
;	O
else	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
!	O
LF_ISSET	O
(	O
DB_NOORDERCHK	int
)	O
)	O
if	O
(	O
m	pointer
->	O
h_charkey	int
!=	O
hfunc	pointer
(	O
CHARKEY	pointer
,	O
sizeof	O
(	O
CHARKEY	pointer
)	O
)	O
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Database has different custom hash function; reverify with DB_NOORDERCHK set"	pointer
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
m	pointer
->	O
max_bucket	int
>	O
vdp	pointer
->	O
last_pgno	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Impossible max_bucket %lu on meta page %lu"	pointer
,	O
m	pointer
->	O
max_bucket	int
,	O
pgno	int
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
goto	O
err	pointer
;	O
}	O
pwr	int
=	O
(	O
m	pointer
->	O
max_bucket	int
==	O
0	int
)	O
?	O
1	int
:	O
1	int
<<	O
CDB___db_log2	function
(	O
m	pointer
->	O
max_bucket	int
+	O
1	int
)	O
;	O
if	O
(	O
m	pointer
->	O
high_mask	int
!=	O
pwr	int
-	O
1	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Incorrect high_mask %lu on page %lu, should be %lu"	pointer
,	O
m	pointer
->	O
high_mask	int
,	O
pgno	int
,	O
pwr	int
-	O
1	int
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
}	O
pwr	int
>>=	O
1	int
;	O
if	O
(	O
m	pointer
->	O
low_mask	int
!=	O
pwr	int
-	O
1	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Incorrect low_mask %lu on page %lu, should be %lu"	pointer
,	O
m	pointer
->	O
low_mask	int
,	O
pgno	int
,	O
pwr	int
-	O
1	int
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
}	O
pip	pointer
->	O
h_ffactor	int
=	O
m	pointer
->	O
ffactor	int
;	O
if	O
(	O
m	pointer
->	O
nelem	int
>	O
0x80000000	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Suspiciously high nelem of %lu on page %lu"	pointer
,	O
m	pointer
->	O
nelem	int
,	O
pgno	int
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
pip	pointer
->	O
h_nelem	int
=	O
0	int
;	O
}	O
else	O
pip	pointer
->	O
h_nelem	int
=	O
m	pointer
->	O
nelem	int
;	O
if	O
(	O
F_ISSET	O
(	O
&	O
m	pointer
->	O
dbmeta	struct
,	O
DB_HASH_DUP	int
)	O
)	O
F_SET	O
(	O
pip	pointer
,	O
VRFY_HAS_DUPS	int
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
&	O
m	pointer
->	O
dbmeta	struct
,	O
DB_HASH_DUPSORT	int
)	O
)	O
F_SET	O
(	O
pip	pointer
,	O
VRFY_HAS_DUPSORT	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
m	pointer
->	O
spares	array
[	O
i	int
]	O
!=	O
0	int
&&	O
i	int
<	O
NCACHED	int
;	O
i	int
++	O
)	O
{	O
mbucket	int
=	O
(	O
1	int
<<	O
i	int
)	O
-	O
1	int
;	O
if	O
(	O
mbucket	int
+	O
m	pointer
->	O
spares	array
[	O
CDB___db_log2	function
(	O
mbucket	int
+	O
1	int
)	O
]	O
>	O
vdp	pointer
->	O
last_pgno	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Spares array entry %lu, page %lu is invalid"	pointer
,	O
i	int
,	O
pgno	int
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
}	O
}	O
err	pointer
:	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___db_vrfy_putpageinfo	function
(	O
vdp	pointer
,	O
pip	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
(	O
ret	int
==	O
0	int
&&	O
isbad	int
==	O
1	int
)	O
?	O
DB_VERIFY_BAD	O
:	O
ret	int
)	O
;	O
}	O
int	O
CDB___ham_vrfy	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
h	pointer
,	O
pgno	int
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
PAGE	struct
*	O
h	pointer
;	O
db_pgno_t	int
pgno	int
;	O
u_int32_t	int
flags	int
;	O
{	O
VRFY_PAGEINFO	struct
*	O
pip	pointer
;	O
db_indx_t	short
ent	short
,	O
himark	short
,	O
inpend	short
;	O
int	O
isbad	int
,	O
ret	int
,	O
t_ret	int
;	O
isbad	int
=	O
0	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_getpageinfo	function
(	O
vdp	pointer
,	O
pgno	int
,	O
&	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_fchk	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"CDB___ham_vrfy"	pointer
,	O
flags	int
,	O
DB_AGGRESSIVE	int
|	O
DB_NOORDERCHK	int
|	O
DB_SALVAGE	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
TYPE	O
(	O
h	pointer
)	O
!=	O
P_HASH	int
)	O
{	O
TYPE_ERR_PRINT	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"CDB___ham_vrfy"	pointer
,	O
pgno	int
,	O
TYPE	O
(	O
h	pointer
)	O
)	O
;	O
DB_ASSERT	O
(	O
0	int
)	O
;	O
ret	int
=	O
EINVAL	int
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_datapage	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
h	pointer
,	O
pgno	int
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
ret	int
==	O
DB_VERIFY_BAD	O
)	O
isbad	int
=	O
1	int
;	O
else	O
goto	O
err	pointer
;	O
}	O
for	O
(	O
ent	short
=	O
0	int
,	O
himark	short
=	O
dbp	pointer
->	O
pgsize	int
,	O
inpend	short
=	O
(	O
u_int8_t	char
*	O
)	O
h	pointer
->	O
inp	array
-	O
(	O
u_int8_t	char
*	O
)	O
h	pointer
;	O
ent	short
<	O
NUM_ENT	O
(	O
h	pointer
)	O
;	O
ent	short
++	O
)	O
if	O
(	O
h	pointer
->	O
inp	array
[	O
ent	short
]	O
>=	O
himark	short
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Item %lu on page %lu out of order or nonsensical"	pointer
,	O
ent	short
,	O
pgno	int
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
goto	O
err	pointer
;	O
}	O
else	O
if	O
(	O
inpend	short
>=	O
himark	short
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"inp array collided with data on page %lu"	pointer
,	O
pgno	int
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
goto	O
err	pointer
;	O
}	O
else	O
{	O
himark	short
=	O
h	pointer
->	O
inp	array
[	O
ent	short
]	O
;	O
inpend	short
+=	O
sizeof	O
(	O
db_indx_t	short
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
__ham_vrfy_item	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
pgno	int
,	O
h	pointer
,	O
ent	short
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
err	pointer
:	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___db_vrfy_putpageinfo	function
(	O
vdp	pointer
,	O
pip	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
ret	int
==	O
0	int
&&	O
isbad	int
==	O
1	int
?	O
DB_VERIFY_BAD	O
:	O
ret	int
)	O
;	O
}	O
static	O
int	O
__ham_vrfy_item	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
pgno	int
,	O
h	pointer
,	O
i	int
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
db_pgno_t	int
pgno	int
;	O
PAGE	struct
*	O
h	pointer
;	O
u_int32_t	int
i	int
,	O
flags	int
;	O
{	O
HOFFPAGE	struct
hop	struct
;	O
HOFFDUP	struct
hod	struct
;	O
VRFY_CHILDINFO	struct
child	struct
;	O
VRFY_PAGEINFO	struct
*	O
pip	pointer
;	O
db_indx_t	short
offset	int
,	O
len	short
,	O
dlen	int
,	O
elen	short
;	O
int	O
ret	int
,	O
t_ret	int
;	O
u_int8_t	char
*	O
databuf	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_getpageinfo	function
(	O
vdp	pointer
,	O
pgno	int
,	O
&	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
switch	O
(	O
HPAGE_TYPE	O
(	O
h	pointer
,	O
i	int
)	O
)	O
{	O
case	O
H_KEYDATA	int
:	O
break	O
;	O
case	O
H_DUPLICATE	int
:	O
if	O
(	O
i	int
%	O
2	int
==	O
0	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Hash key stored as duplicate at page %lu item %lu"	pointer
,	O
pip	pointer
->	O
pgno	int
,	O
i	int
)	O
)	O
;	O
}	O
len	short
=	O
LEN_HKEYDATA	O
(	O
h	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
i	int
)	O
;	O
databuf	pointer
=	O
HKEYDATA_DATA	O
(	O
P_ENTRY	O
(	O
h	pointer
,	O
i	int
)	O
)	O
;	O
for	O
(	O
offset	int
=	O
0	int
;	O
offset	int
<	O
len	short
;	O
offset	int
+=	O
DUP_SIZE	O
(	O
dlen	int
)	O
)	O
{	O
memcpy	function
(	O
&	O
dlen	int
,	O
databuf	pointer
+	O
offset	int
,	O
sizeof	O
(	O
db_indx_t	short
)	O
)	O
;	O
if	O
(	O
offset	int
+	O
DUP_SIZE	O
(	O
dlen	int
)	O
>	O
len	short
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Duplicate item %lu, page %lu has bad length"	pointer
,	O
i	int
,	O
pip	pointer
->	O
pgno	int
)	O
)	O
;	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
goto	O
err	pointer
;	O
}	O
memcpy	function
(	O
&	O
elen	short
,	O
databuf	pointer
+	O
offset	int
+	O
dlen	int
+	O
sizeof	O
(	O
db_indx_t	short
)	O
,	O
sizeof	O
(	O
db_indx_t	short
)	O
)	O
;	O
if	O
(	O
elen	short
!=	O
dlen	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Duplicate item %lu, page %lu has two different lengths"	pointer
,	O
i	int
,	O
pip	pointer
->	O
pgno	int
)	O
)	O
;	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
goto	O
err	pointer
;	O
}	O
}	O
F_SET	O
(	O
pip	pointer
,	O
VRFY_HAS_DUPS	int
)	O
;	O
if	O
(	O
!	O
LF_ISSET	O
(	O
DB_NOORDERCHK	int
)	O
&&	O
__ham_dups_unsorted	function
(	O
dbp	pointer
,	O
databuf	pointer
,	O
len	short
)	O
)	O
F_SET	O
(	O
pip	pointer
,	O
VRFY_DUPS_UNSORTED	int
)	O
;	O
break	O
;	O
case	O
H_OFFPAGE	int
:	O
memcpy	function
(	O
&	O
hop	struct
,	O
P_ENTRY	O
(	O
h	pointer
,	O
i	int
)	O
,	O
HOFFPAGE_SIZE	O
)	O
;	O
if	O
(	O
!	O
IS_VALID_PGNO	O
(	O
hop	struct
.	O
pgno	int
)	O
||	O
hop	struct
.	O
pgno	int
==	O
pip	pointer
->	O
pgno	int
||	O
hop	struct
.	O
pgno	int
==	O
PGNO_INVALID	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Offpage item %lu, page %lu has bad page number"	pointer
,	O
i	int
,	O
pip	pointer
->	O
pgno	int
)	O
)	O
;	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
goto	O
err	pointer
;	O
}	O
memset	function
(	O
&	O
child	struct
,	O
0	int
,	O
sizeof	O
(	O
VRFY_CHILDINFO	struct
)	O
)	O
;	O
child	struct
.	O
pgno	int
=	O
hop	struct
.	O
pgno	int
;	O
child	struct
.	O
type	enum
=	O
V_OVERFLOW	int
;	O
child	struct
.	O
tlen	int
=	O
hop	struct
.	O
tlen	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_childput	function
(	O
vdp	pointer
,	O
pip	pointer
->	O
pgno	int
,	O
&	O
child	struct
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
break	O
;	O
case	O
H_OFFDUP	int
:	O
memcpy	function
(	O
&	O
hod	struct
,	O
P_ENTRY	O
(	O
h	pointer
,	O
i	int
)	O
,	O
HOFFDUP_SIZE	O
)	O
;	O
if	O
(	O
!	O
IS_VALID_PGNO	O
(	O
hod	struct
.	O
pgno	int
)	O
||	O
hod	struct
.	O
pgno	int
==	O
pip	pointer
->	O
pgno	int
||	O
hod	struct
.	O
pgno	int
==	O
PGNO_INVALID	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Offpage item %lu, page %lu has bad page number"	pointer
,	O
i	int
,	O
pip	pointer
->	O
pgno	int
)	O
)	O
;	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
goto	O
err	pointer
;	O
}	O
memset	function
(	O
&	O
child	struct
,	O
0	int
,	O
sizeof	O
(	O
VRFY_CHILDINFO	struct
)	O
)	O
;	O
child	struct
.	O
pgno	int
=	O
hod	struct
.	O
pgno	int
;	O
child	struct
.	O
type	enum
=	O
V_DUPLICATE	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_childput	function
(	O
vdp	pointer
,	O
pip	pointer
->	O
pgno	int
,	O
&	O
child	struct
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
F_SET	O
(	O
pip	pointer
,	O
VRFY_HAS_DUPS	int
)	O
;	O
break	O
;	O
default	O
:	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Item %i, page %lu has bad type"	pointer
,	O
i	int
,	O
pip	pointer
->	O
pgno	int
)	O
)	O
;	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
break	O
;	O
}	O
err	pointer
:	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___db_vrfy_putpageinfo	function
(	O
vdp	pointer
,	O
pip	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___ham_vrfy_structure	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
meta_pgno	int
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
db_pgno_t	int
meta_pgno	int
;	O
u_int32_t	int
flags	int
;	O
{	O
DB	struct
*	O
pgset	pointer
;	O
HMETA	struct
*	O
m	pointer
;	O
PAGE	struct
*	O
h	pointer
;	O
VRFY_PAGEINFO	struct
*	O
pip	pointer
;	O
int	O
isbad	int
,	O
p	pointer
,	O
ret	int
,	O
t_ret	int
;	O
db_pgno_t	int
pgno	int
;	O
u_int32_t	int
bucket	int
;	O
ret	int
=	O
isbad	int
=	O
0	int
;	O
h	pointer
=	O
NULL	O
;	O
pgset	pointer
=	O
vdp	pointer
->	O
pgset	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_pgset_get	function
(	O
pgset	pointer
,	O
meta_pgno	int
,	O
&	O
p	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
p	pointer
!=	O
0	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Hash meta page %lu referenced twice"	pointer
,	O
meta_pgno	int
)	O
)	O
;	O
return	O
(	O
DB_VERIFY_BAD	O
)	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_pgset_inc	function
(	O
pgset	pointer
,	O
meta_pgno	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
meta_pgno	int
,	O
0	int
,	O
&	O
m	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
for	O
(	O
bucket	int
=	O
0	int
;	O
bucket	int
<=	O
m	pointer
->	O
max_bucket	int
;	O
bucket	int
++	O
)	O
if	O
(	O
(	O
ret	int
=	O
__ham_vrfy_bucket	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
m	pointer
,	O
bucket	int
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
ret	int
==	O
DB_VERIFY_BAD	O
)	O
isbad	int
=	O
1	int
;	O
else	O
goto	O
err	pointer
;	O
}	O
for	O
(	O
bucket	int
=	O
m	pointer
->	O
max_bucket	int
+	O
1	int
;	O
bucket	int
<=	O
m	pointer
->	O
high_mask	int
;	O
bucket	int
++	O
)	O
{	O
pgno	int
=	O
bucket	int
+	O
m	pointer
->	O
spares	array
[	O
CDB___db_log2	function
(	O
bucket	int
+	O
1	int
)	O
]	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_getpageinfo	function
(	O
vdp	pointer
,	O
pgno	int
,	O
&	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
F_CLR	O
(	O
pip	pointer
,	O
VRFY_IS_ALLZEROES	int
)	O
;	O
if	O
(	O
pip	pointer
->	O
type	enum
!=	O
P_HASH	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Hash bucket %lu maps to non-hash page %lu"	pointer
,	O
bucket	int
,	O
pgno	int
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
pip	pointer
->	O
entries	short
!=	O
0	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Non-empty page %lu in unused hash bucket %lu"	pointer
,	O
pgno	int
,	O
bucket	int
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_pgset_get	function
(	O
pgset	pointer
,	O
pgno	int
,	O
&	O
p	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
p	pointer
!=	O
0	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Hash page %lu above max_bucket referenced"	pointer
,	O
pgno	int
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_pgset_inc	function
(	O
pgset	pointer
,	O
pgno	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_putpageinfo	function
(	O
vdp	pointer
,	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
continue	O
;	O
}	O
}	O
(	O
void	O
)	O
CDB___db_vrfy_putpageinfo	function
(	O
vdp	pointer
,	O
pip	pointer
)	O
;	O
goto	O
err	pointer
;	O
}	O
err	pointer
:	O
if	O
(	O
(	O
t_ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
m	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
t_ret	int
)	O
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
&&	O
(	O
t_ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
t_ret	int
)	O
;	O
return	O
(	O
(	O
isbad	int
==	O
1	int
&&	O
ret	int
==	O
0	int
)	O
?	O
DB_VERIFY_BAD	O
:	O
ret	int
)	O
;	O
}	O
static	O
int	O
__ham_vrfy_bucket	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
m	pointer
,	O
bucket	int
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
HMETA	struct
*	O
m	pointer
;	O
u_int32_t	int
bucket	int
,	O
flags	int
;	O
{	O
HASH	struct
*	O
hashp	pointer
;	O
VRFY_CHILDINFO	struct
*	O
child	struct
;	O
VRFY_PAGEINFO	struct
*	O
mip	pointer
,	O
*	O
pip	pointer
;	O
int	O
ret	int
,	O
t_ret	int
,	O
isbad	int
,	O
p	pointer
;	O
db_pgno_t	int
pgno	int
,	O
next_pgno	int
;	O
DBC	struct
*	O
cc	pointer
;	O
u_int32_t	int
(	O
*	O
hfunc	pointer
)	O
__P	O
(	O
(	O
const	O
void	O
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
isbad	int
=	O
0	int
;	O
pip	pointer
=	O
NULL	O
;	O
cc	pointer
=	O
NULL	O
;	O
hashp	pointer
=	O
dbp	pointer
->	O
h_internal	pointer
;	O
if	O
(	O
hashp	pointer
!=	O
NULL	O
&&	O
hashp	pointer
->	O
h_hash	pointer
!=	O
NULL	O
)	O
hfunc	pointer
=	O
hashp	pointer
->	O
h_hash	pointer
;	O
else	O
hfunc	pointer
=	O
CDB___ham_func5	function
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_getpageinfo	function
(	O
vdp	pointer
,	O
PGNO	O
(	O
m	pointer
)	O
,	O
&	O
mip	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
pgno	int
=	O
bucket	int
+	O
m	pointer
->	O
spares	array
[	O
CDB___db_log2	function
(	O
bucket	int
+	O
1	int
)	O
]	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_getpageinfo	function
(	O
vdp	pointer
,	O
pgno	int
,	O
&	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
pgno	int
>	O
vdp	pointer
->	O
last_pgno	int
||	O
pip	pointer
->	O
type	enum
!=	O
P_HASH	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Bucket %lu has impossible first page %lu"	pointer
,	O
bucket	int
,	O
pgno	int
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
pip	pointer
->	O
prev_pgno	int
!=	O
PGNO_INVALID	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"First hash page %lu in bucket %lu has a prev_pgno"	pointer
,	O
pgno	int
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
}	O
flags	int
|=	O
F_ISSET	O
(	O
mip	pointer
,	O
VRFY_HAS_DUPS	int
)	O
?	O
ST_DUPOK	int
:	O
0	int
;	O
flags	int
|=	O
F_ISSET	O
(	O
mip	pointer
,	O
VRFY_HAS_DUPSORT	int
)	O
?	O
ST_DUPSORT	int
:	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_pgset_get	function
(	O
vdp	pointer
->	O
pgset	pointer
,	O
pgno	int
,	O
&	O
p	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
p	pointer
!=	O
0	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Hash page %lu referenced twice"	pointer
,	O
pgno	int
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
goto	O
err	pointer
;	O
}	O
else	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_pgset_inc	function
(	O
vdp	pointer
->	O
pgset	pointer
,	O
pgno	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
F_CLR	O
(	O
pip	pointer
,	O
VRFY_IS_ALLZEROES	int
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
pip	pointer
,	O
VRFY_HAS_DUPS	int
)	O
&&	O
!	O
F_ISSET	O
(	O
mip	pointer
,	O
VRFY_HAS_DUPS	int
)	O
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Duplicates present in non-duplicate database, page %lu"	pointer
,	O
pgno	int
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
}	O
if	O
(	O
F_ISSET	O
(	O
mip	pointer
,	O
VRFY_HAS_DUPSORT	int
)	O
&&	O
F_ISSET	O
(	O
pip	pointer
,	O
VRFY_DUPS_UNSORTED	int
)	O
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Unsorted dups in sorted-dup database, page %lu"	pointer
,	O
pgno	int
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_childcursor	function
(	O
vdp	pointer
,	O
&	O
cc	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
for	O
(	O
ret	int
=	O
CDB___db_vrfy_ccset	function
(	O
cc	pointer
,	O
pip	pointer
->	O
pgno	int
,	O
&	O
child	struct
)	O
;	O
ret	int
==	O
0	int
;	O
ret	int
=	O
CDB___db_vrfy_ccnext	function
(	O
cc	pointer
,	O
&	O
child	struct
)	O
)	O
if	O
(	O
child	struct
->	O
type	enum
==	O
V_OVERFLOW	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_ovfl_structure	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
child	struct
->	O
pgno	int
,	O
child	struct
->	O
tlen	int
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
ret	int
==	O
DB_VERIFY_BAD	O
)	O
isbad	int
=	O
1	int
;	O
else	O
goto	O
err	pointer
;	O
}	O
}	O
else	O
if	O
(	O
child	struct
->	O
type	enum
==	O
V_DUPLICATE	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_duptype	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
child	struct
->	O
pgno	int
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
{	O
isbad	int
=	O
1	int
;	O
continue	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_vrfy_subtree	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
child	struct
->	O
pgno	int
,	O
NULL	O
,	O
NULL	O
,	O
flags	int
|	O
ST_RECNUM	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
ret	int
==	O
DB_VERIFY_BAD	O
)	O
isbad	int
=	O
1	int
;	O
else	O
goto	O
err	pointer
;	O
}	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_ccclose	function
(	O
cc	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
cc	pointer
=	O
NULL	O
;	O
if	O
(	O
isbad	int
==	O
0	int
&&	O
!	O
LF_ISSET	O
(	O
DB_NOORDERCHK	int
)	O
&&	O
(	O
ret	int
=	O
CDB___ham_vrfy_hashing	function
(	O
dbp	pointer
,	O
pip	pointer
->	O
entries	short
,	O
m	pointer
,	O
bucket	int
,	O
pgno	int
,	O
flags	int
,	O
hfunc	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
ret	int
==	O
DB_VERIFY_BAD	O
)	O
isbad	int
=	O
1	int
;	O
else	O
goto	O
err	pointer
;	O
}	O
next_pgno	int
=	O
pip	pointer
->	O
next_pgno	int
;	O
ret	int
=	O
CDB___db_vrfy_putpageinfo	function
(	O
vdp	pointer
,	O
pip	pointer
)	O
;	O
pip	pointer
=	O
NULL	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
next_pgno	int
==	O
PGNO_INVALID	int
)	O
break	O
;	O
if	O
(	O
!	O
IS_VALID_PGNO	O
(	O
next_pgno	int
)	O
)	O
{	O
DB_ASSERT	O
(	O
0	int
)	O
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Hash page %lu has bad next_pgno"	pointer
,	O
pgno	int
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_getpageinfo	function
(	O
vdp	pointer
,	O
next_pgno	int
,	O
&	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
pip	pointer
->	O
prev_pgno	int
!=	O
pgno	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Hash page %lu has bad prev_pgno"	pointer
,	O
next_pgno	int
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
}	O
pgno	int
=	O
next_pgno	int
;	O
}	O
err	pointer
:	O
if	O
(	O
cc	pointer
!=	O
NULL	O
&&	O
(	O
(	O
t_ret	int
=	O
CDB___db_vrfy_ccclose	function
(	O
cc	pointer
)	O
)	O
!=	O
0	int
)	O
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
mip	pointer
!=	O
NULL	O
&&	O
(	O
(	O
t_ret	int
=	O
CDB___db_vrfy_putpageinfo	function
(	O
vdp	pointer
,	O
mip	pointer
)	O
)	O
!=	O
0	int
)	O
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
pip	pointer
!=	O
NULL	O
&&	O
(	O
(	O
t_ret	int
=	O
CDB___db_vrfy_putpageinfo	function
(	O
vdp	pointer
,	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
(	O
ret	int
==	O
0	int
&&	O
isbad	int
==	O
1	int
)	O
?	O
DB_VERIFY_BAD	O
:	O
ret	int
)	O
;	O
}	O
int	O
CDB___ham_vrfy_hashing	function
(	O
dbp	pointer
,	O
nentries	int
,	O
m	pointer
,	O
thisbucket	int
,	O
pgno	int
,	O
flags	int
,	O
hfunc	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
u_int32_t	int
nentries	int
;	O
HMETA	struct
*	O
m	pointer
;	O
u_int32_t	int
thisbucket	int
;	O
db_pgno_t	int
pgno	int
;	O
u_int32_t	int
flags	int
;	O
u_int32_t	int
(	O
*	O
hfunc	pointer
)	O
__P	O
(	O
(	O
const	O
void	O
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
{	O
DBT	struct
dbt	struct
;	O
PAGE	struct
*	O
h	pointer
;	O
db_indx_t	short
i	int
;	O
int	O
ret	int
,	O
t_ret	int
,	O
isbad	int
;	O
u_int32_t	int
hval	int
,	O
bucket	int
;	O
ret	int
=	O
isbad	int
=	O
0	int
;	O
memset	function
(	O
&	O
dbt	struct
,	O
0	int
,	O
sizeof	O
(	O
DBT	struct
)	O
)	O
;	O
F_SET	O
(	O
&	O
dbt	struct
,	O
DB_DBT_REALLOC	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pgno	int
,	O
0	int
,	O
&	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nentries	int
;	O
i	int
+=	O
2	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_ret	function
(	O
dbp	pointer
,	O
h	pointer
,	O
i	int
,	O
&	O
dbt	struct
,	O
NULL	O
,	O
NULL	O
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
hval	int
=	O
hfunc	pointer
(	O
dbt	struct
.	O
data	pointer
,	O
dbt	struct
.	O
size	int
)	O
;	O
bucket	int
=	O
hval	int
&	O
m	pointer
->	O
high_mask	int
;	O
if	O
(	O
bucket	int
>	O
m	pointer
->	O
max_bucket	int
)	O
bucket	int
=	O
bucket	int
&	O
m	pointer
->	O
low_mask	int
;	O
if	O
(	O
bucket	int
!=	O
thisbucket	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Item %lu on page %lu hashes incorrectly"	pointer
,	O
i	int
,	O
pgno	int
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
}	O
}	O
err	pointer
:	O
if	O
(	O
dbt	struct
.	O
data	pointer
!=	O
NULL	O
)	O
CDB___os_free	function
(	O
dbt	struct
.	O
data	pointer
,	O
0	int
)	O
;	O
if	O
(	O
(	O
t_ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
t_ret	int
)	O
;	O
return	O
(	O
(	O
ret	int
==	O
0	int
&&	O
isbad	int
==	O
1	int
)	O
?	O
DB_VERIFY_BAD	O
:	O
ret	int
)	O
;	O
}	O
int	O
CDB___ham_salvage	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
pgno	int
,	O
h	pointer
,	O
handle	pointer
,	O
callback	pointer
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
db_pgno_t	int
pgno	int
;	O
PAGE	struct
*	O
h	pointer
;	O
void	O
*	O
handle	pointer
;	O
int	O
(	O
*	O
callback	pointer
)	O
__P	O
(	O
(	O
void	O
*	O
,	O
const	O
void	O
*	O
)	O
)	O
;	O
u_int32_t	int
flags	int
;	O
{	O
DBT	struct
dbt	struct
,	O
unkdbt	struct
;	O
db_pgno_t	int
dpgno	int
;	O
int	O
ret	int
,	O
err_ret	int
,	O
t_ret	int
;	O
u_int32_t	int
himark	short
,	O
tlen	int
;	O
u_int8_t	char
*	O
hk	pointer
;	O
void	O
*	O
buf	pointer
;	O
db_indx_t	short
dlen	int
,	O
len	short
,	O
i	int
;	O
memset	function
(	O
&	O
dbt	struct
,	O
0	int
,	O
sizeof	O
(	O
DBT	struct
)	O
)	O
;	O
dbt	struct
.	O
flags	int
=	O
DB_DBT_REALLOC	int
;	O
memset	function
(	O
&	O
unkdbt	struct
,	O
0	int
,	O
sizeof	O
(	O
DBT	struct
)	O
)	O
;	O
unkdbt	struct
.	O
size	int
=	O
strlen	function
(	O
"UNKNOWN"	pointer
)	O
+	O
1	int
;	O
unkdbt	struct
.	O
data	pointer
=	O
"UNKNOWN"	pointer
;	O
err_ret	int
=	O
0	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
NULL	O
,	O
&	O
buf	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
himark	short
=	O
dbp	pointer
->	O
pgsize	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
!	O
LF_ISSET	O
(	O
DB_AGGRESSIVE	int
)	O
&&	O
i	int
>=	O
NUM_ENT	O
(	O
h	pointer
)	O
)	O
break	O
;	O
ret	int
=	O
CDB___db_vrfy_inpitem	function
(	O
dbp	pointer
,	O
h	pointer
,	O
pgno	int
,	O
i	int
,	O
0	int
,	O
flags	int
,	O
&	O
himark	short
,	O
NULL	O
)	O
;	O
if	O
(	O
ret	int
==	O
DB_VERIFY_FATAL	O
)	O
break	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
{	O
hk	pointer
=	O
P_ENTRY	O
(	O
h	pointer
,	O
i	int
)	O
;	O
len	short
=	O
LEN_HKEYDATA	O
(	O
h	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
i	int
)	O
;	O
if	O
(	O
(	O
u_int32_t	int
)	O
(	O
hk	pointer
+	O
len	short
-	O
(	O
u_int8_t	char
*	O
)	O
h	pointer
)	O
>	O
dbp	pointer
->	O
pgsize	int
)	O
{	O
if	O
(	O
!	O
LF_ISSET	O
(	O
DB_AGGRESSIVE	int
)	O
)	O
continue	O
;	O
len	short
=	O
dbp	pointer
->	O
pgsize	int
-	O
(	O
u_int32_t	int
)	O
(	O
hk	pointer
-	O
(	O
u_int8_t	char
*	O
)	O
h	pointer
)	O
;	O
err_ret	int
=	O
DB_VERIFY_BAD	O
;	O
}	O
switch	O
(	O
HPAGE_PTYPE	O
(	O
hk	pointer
)	O
)	O
{	O
default	O
:	O
if	O
(	O
!	O
LF_ISSET	O
(	O
DB_AGGRESSIVE	int
)	O
)	O
break	O
;	O
err_ret	int
=	O
DB_VERIFY_BAD	O
;	O
case	O
H_KEYDATA	int
:	O
keydata	O
:	O
memcpy	function
(	O
buf	pointer
,	O
HKEYDATA_DATA	O
(	O
hk	pointer
)	O
,	O
len	short
)	O
;	O
dbt	struct
.	O
size	int
=	O
len	short
;	O
dbt	struct
.	O
data	pointer
=	O
buf	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_prdbt	function
(	O
&	O
dbt	struct
,	O
0	int
,	O
" "	pointer
,	O
handle	pointer
,	O
callback	pointer
,	O
0	int
,	O
NULL	O
)	O
)	O
!=	O
0	int
)	O
err_ret	int
=	O
ret	int
;	O
break	O
;	O
case	O
H_OFFPAGE	int
:	O
if	O
(	O
len	short
<	O
HOFFPAGE_SIZE	O
)	O
{	O
err_ret	int
=	O
DB_VERIFY_BAD	O
;	O
continue	O
;	O
}	O
memcpy	function
(	O
&	O
dpgno	int
,	O
HOFFPAGE_PGNO	O
(	O
hk	pointer
)	O
,	O
sizeof	O
(	O
dpgno	int
)	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_safe_goff	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
dpgno	int
,	O
&	O
dbt	struct
,	O
&	O
buf	pointer
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
{	O
err_ret	int
=	O
ret	int
;	O
(	O
void	O
)	O
CDB___db_prdbt	function
(	O
&	O
unkdbt	struct
,	O
0	int
,	O
" "	pointer
,	O
handle	pointer
,	O
callback	pointer
,	O
0	int
,	O
NULL	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_prdbt	function
(	O
&	O
dbt	struct
,	O
0	int
,	O
" "	pointer
,	O
handle	pointer
,	O
callback	pointer
,	O
0	int
,	O
NULL	O
)	O
)	O
!=	O
0	int
)	O
err_ret	int
=	O
ret	int
;	O
break	O
;	O
case	O
H_OFFDUP	int
:	O
if	O
(	O
len	short
<	O
HOFFPAGE_SIZE	O
)	O
{	O
err_ret	int
=	O
DB_VERIFY_BAD	O
;	O
continue	O
;	O
}	O
memcpy	function
(	O
&	O
dpgno	int
,	O
HOFFPAGE_PGNO	O
(	O
hk	pointer
)	O
,	O
sizeof	O
(	O
dpgno	int
)	O
)	O
;	O
if	O
(	O
!	O
IS_VALID_PGNO	O
(	O
dpgno	int
)	O
||	O
(	O
i	int
%	O
2	int
==	O
0	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_prdbt	function
(	O
&	O
unkdbt	struct
,	O
0	int
,	O
" "	pointer
,	O
handle	pointer
,	O
callback	pointer
,	O
0	int
,	O
NULL	O
)	O
)	O
!=	O
0	int
)	O
err_ret	int
=	O
ret	int
;	O
}	O
else	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_salvage_duptree	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
dpgno	int
,	O
&	O
dbt	struct
,	O
handle	pointer
,	O
callback	pointer
,	O
flags	int
|	O
SA_SKIPFIRSTKEY	int
)	O
)	O
!=	O
0	int
)	O
err_ret	int
=	O
ret	int
;	O
break	O
;	O
case	O
H_DUPLICATE	int
:	O
if	O
(	O
i	int
%	O
2	int
==	O
0	int
)	O
{	O
err_ret	int
=	O
ret	int
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_AGGRESSIVE	int
)	O
)	O
goto	O
keydata	O
;	O
break	O
;	O
}	O
if	O
(	O
len	short
<	O
HKEYDATA_SIZE	O
(	O
2	int
*	O
sizeof	O
(	O
db_indx_t	short
)	O
)	O
)	O
{	O
err_ret	int
=	O
DB_VERIFY_BAD	O
;	O
continue	O
;	O
}	O
for	O
(	O
tlen	int
=	O
0	int
;	O
tlen	int
+	O
sizeof	O
(	O
db_indx_t	short
)	O
<	O
len	short
;	O
tlen	int
+=	O
dlen	int
)	O
{	O
tlen	int
+=	O
sizeof	O
(	O
db_indx_t	short
)	O
;	O
memcpy	function
(	O
&	O
dlen	int
,	O
hk	pointer
,	O
sizeof	O
(	O
db_indx_t	short
)	O
)	O
;	O
if	O
(	O
dlen	int
+	O
tlen	int
>	O
len	short
)	O
dlen	int
=	O
len	short
-	O
tlen	int
;	O
memcpy	function
(	O
buf	pointer
,	O
hk	pointer
+	O
tlen	int
,	O
dlen	int
)	O
;	O
dbt	struct
.	O
size	int
=	O
dlen	int
;	O
dbt	struct
.	O
data	pointer
=	O
buf	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_prdbt	function
(	O
&	O
dbt	struct
,	O
0	int
,	O
" "	pointer
,	O
handle	pointer
,	O
callback	pointer
,	O
0	int
,	O
NULL	O
)	O
)	O
!=	O
0	int
)	O
err_ret	int
=	O
ret	int
;	O
tlen	int
+=	O
sizeof	O
(	O
db_indx_t	short
)	O
;	O
}	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___db_salvage_markdone	function
(	O
vdp	pointer
,	O
pgno	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
t_ret	int
)	O
;	O
return	O
(	O
(	O
ret	int
==	O
0	int
&&	O
err_ret	int
!=	O
0	int
)	O
?	O
err_ret	int
:	O
ret	int
)	O
;	O
}	O
int	O
CDB___ham_meta2pgset	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
hmeta	pointer
,	O
flags	int
,	O
pgset	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
HMETA	struct
*	O
hmeta	pointer
;	O
u_int32_t	int
flags	int
;	O
DB	struct
*	O
pgset	pointer
;	O
{	O
if	O
(	O
flags	int
)	O
{	O
}	O
PAGE	struct
*	O
h	pointer
;	O
db_pgno_t	int
pgno	int
;	O
u_int32_t	int
bucket	int
,	O
totpgs	int
;	O
int	O
ret	int
,	O
val	int
;	O
COMPQUIET	O
(	O
flags	int
,	O
0	int
)	O
;	O
DB_ASSERT	O
(	O
pgset	pointer
!=	O
NULL	O
)	O
;	O
totpgs	int
=	O
0	int
;	O
for	O
(	O
bucket	int
=	O
0	int
;	O
bucket	int
<=	O
hmeta	pointer
->	O
max_bucket	int
;	O
bucket	int
++	O
)	O
{	O
pgno	int
=	O
bucket	int
+	O
hmeta	pointer
->	O
spares	array
[	O
CDB___db_log2	function
(	O
bucket	int
+	O
1	int
)	O
]	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pgno	int
,	O
0	int
,	O
&	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_HASH	int
)	O
{	O
if	O
(	O
++	O
totpgs	int
>	O
vdp	pointer
->	O
last_pgno	int
)	O
{	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
;	O
return	O
(	O
DB_VERIFY_BAD	O
)	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_pgset_inc	function
(	O
pgset	pointer
,	O
pgno	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
pgno	int
=	O
NEXT_PGNO	O
(	O
h	pointer
)	O
;	O
}	O
else	O
pgno	int
=	O
PGNO_INVALID	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
!	O
IS_VALID_PGNO	O
(	O
pgno	int
)	O
||	O
pgno	int
==	O
PGNO_INVALID	int
)	O
goto	O
nextbucket	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_pgset_get	function
(	O
pgset	pointer
,	O
pgno	int
,	O
&	O
val	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
val	int
!=	O
0	int
)	O
goto	O
nextbucket	O
;	O
}	O
nextbucket	O
:	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__ham_dups_unsorted	function
(	O
dbp	pointer
,	O
buf	pointer
,	O
len	short
)	O
DB	struct
*	O
dbp	pointer
;	O
u_int8_t	char
*	O
buf	pointer
;	O
u_int32_t	int
len	short
;	O
{	O
DBT	struct
a	struct
,	O
b	struct
;	O
db_indx_t	short
offset	int
,	O
dlen	int
;	O
int	O
(	O
*	O
func	pointer
)	O
__P	O
(	O
(	O
const	O
DBT	struct
*	O
,	O
const	O
DBT	struct
*	O
)	O
)	O
;	O
memset	function
(	O
&	O
a	struct
,	O
0	int
,	O
sizeof	O
(	O
DBT	struct
)	O
)	O
;	O
memset	function
(	O
&	O
b	struct
,	O
0	int
,	O
sizeof	O
(	O
DBT	struct
)	O
)	O
;	O
func	pointer
=	O
(	O
dbp	pointer
->	O
dup_compare	pointer
==	O
NULL	O
)	O
?	O
CDB___bam_defcmp	function
:	O
dbp	pointer
->	O
dup_compare	pointer
;	O
for	O
(	O
offset	int
=	O
0	int
;	O
offset	int
<	O
len	short
;	O
offset	int
+=	O
DUP_SIZE	O
(	O
dlen	int
)	O
)	O
{	O
memcpy	function
(	O
&	O
dlen	int
,	O
buf	pointer
+	O
offset	int
,	O
sizeof	O
(	O
db_indx_t	short
)	O
)	O
;	O
b	struct
.	O
data	pointer
=	O
buf	pointer
+	O
offset	int
+	O
sizeof	O
(	O
db_indx_t	short
)	O
;	O
b	struct
.	O
size	int
=	O
dlen	int
;	O
if	O
(	O
a	struct
.	O
data	pointer
!=	O
NULL	O
&&	O
func	pointer
(	O
&	O
a	struct
,	O
&	O
b	struct
)	O
>	O
0	int
)	O
return	O
(	O
1	int
)	O
;	O
a	struct
.	O
data	pointer
=	O
b	struct
.	O
data	pointer
;	O
a	struct
.	O
size	int
=	O
b	struct
.	O
size	int
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
