int	O
debug	int
=	O
0	int
;	O
struct	O
{	O
double	O
alt	double
;	O
double	O
rho	double
;	O
double	O
mach1	double
;	O
}	O
*	O
rhop	pointer
,	O
rhoTable	array
[	O
]	O
=	O
{	O
{	O
60.0	int
,	O
2.238	int
,	O
968.5	int
}	O
,	O
{	O
80.0	int
,	O
0.9065	int
,	O
980.0	int
}	O
,	O
{	O
100.0	int
,	O
0.3371	int
,	O
1015.0	int
}	O
,	O
{	O
120.0	int
,	O
0.1340	int
,	O
1053.0	int
}	O
,	O
{	O
160.0	int
,	O
0.02622	int
,	O
1083.0	int
}	O
,	O
{	O
100000.0	int
,	O
0.02622	int
,	O
1083.0	int
}	O
}	O
;	O
double	O
deltaT	double
;	O
double	O
halfDeltaTSquared	double
;	O
double	O
CM	double
,	O
CN	double
,	O
C_Y	double
;	O
extern	O
double	O
groundContactTime	function
(	O
craft	struct
*	O
c	pointer
,	O
VPoint	struct
*	O
contactSg	pointer
)	O
;	O
extern	O
int	O
groundDynamics	function
(	O
craft	struct
*	O
c	pointer
,	O
double	O
startT	double
,	O
double	O
CL	double
,	O
double	O
CD	double
,	O
double	O
CM	double
,	O
double	O
w	pointer
,	O
double	O
qS	double
)	O
;	O
double	O
calcRho	function
(	O
double	O
alt	double
,	O
double	O
*	O
mach	double
)	O
{	O
double	O
deltaAlt	double
,	O
b	float
;	O
extern	O
void	O
airProperties	function
(	O
double	O
h	int
,	O
double	O
*	O
rho	double
,	O
double	O
*	O
mach1	double
)	O
;	O
double	O
rho	double
;	O
if	O
(	O
alt	double
<=	O
60000.0	int
)	O
{	O
airProperties	function
(	O
alt	double
,	O
&	O
rho	double
,	O
mach	double
)	O
;	O
return	O
rho	double
;	O
}	O
alt	double
=	O
alt	double
/	O
1000.0	int
;	O
for	O
(	O
rhop	pointer
=	O
rhoTable	array
;	O
alt	double
>	O
(	O
rhop	pointer
+	O
1	int
)	O
->	O
alt	double
;	O
++	O
rhop	pointer
)	O
;	O
deltaAlt	double
=	O
(	O
rhop	pointer
+	O
1	int
)	O
->	O
alt	double
-	O
rhop	pointer
->	O
alt	double
;	O
b	float
=	O
(	O
(	O
rhop	pointer
+	O
1	int
)	O
->	O
mach1	double
-	O
rhop	pointer
->	O
mach1	double
)	O
/	O
deltaAlt	double
;	O
*	O
mach	double
=	O
rhop	pointer
->	O
mach1	double
+	O
b	float
*	O
(	O
alt	double
-	O
rhop	pointer
->	O
alt	double
)	O
;	O
b	float
=	O
(	O
(	O
rhop	pointer
+	O
1	int
)	O
->	O
rho	double
-	O
rhop	pointer
->	O
rho	double
)	O
/	O
deltaAlt	double
;	O
return	O
(	O
rhop	pointer
->	O
rho	double
+	O
b	float
*	O
(	O
alt	double
-	O
rhop	pointer
->	O
alt	double
)	O
)	O
/	O
10000.0	int
;	O
}	O
void	O
twoOrder	function
(	O
double	O
k	double
,	O
double	O
d	long
,	O
double	O
y	short
,	O
double	O
v	struct
,	O
double	O
*	O
newy	pointer
,	O
double	O
*	O
newv	pointer
)	O
{	O
double	O
s	double
,	O
s1	double
,	O
s2	double
,	O
t	double
,	O
ac	double
,	O
x	float
,	O
c1	double
,	O
c2	double
,	O
exp_s1_x	double
,	O
exp_s2_x	double
;	O
int	O
return_zero	int
=	O
0	int
;	O
k	double
=	O
-	O
k	double
;	O
d	long
=	O
-	O
d	long
;	O
ac	double
=	O
d	long
*	O
d	long
-	O
4.0	int
*	O
k	double
;	O
if	O
(	O
ac	double
<	O
0.0	int
)	O
{	O
s	double
=	O
-	O
d	long
/	O
2.0	int
;	O
t	double
=	O
sqrt	function
(	O
-	O
ac	double
)	O
/	O
2.0	int
;	O
}	O
else	O
if	O
(	O
ac	double
==	O
0.0	int
)	O
{	O
s	double
=	O
(	O
-	O
d	long
+	O
sqrt	function
(	O
ac	double
)	O
)	O
/	O
2.0	int
;	O
t	double
=	O
0.0	int
;	O
}	O
else	O
{	O
s1	double
=	O
(	O
-	O
d	long
+	O
sqrt	function
(	O
ac	double
)	O
)	O
/	O
2.0	int
;	O
s2	double
=	O
(	O
-	O
d	long
-	O
sqrt	function
(	O
ac	double
)	O
)	O
/	O
2.0	int
;	O
c1	double
=	O
(	O
s2	double
*	O
y	short
-	O
v	struct
)	O
/	O
(	O
s2	double
-	O
s1	double
)	O
;	O
c2	double
=	O
y	short
-	O
c1	double
;	O
x	float
=	O
deltaT	double
;	O
exp_s1_x	double
=	O
exp	function
(	O
s1	double
*	O
x	float
)	O
;	O
exp_s2_x	double
=	O
exp	function
(	O
s2	double
*	O
x	float
)	O
;	O
*	O
newy	pointer
=	O
c1	double
*	O
exp_s1_x	double
+	O
c2	double
*	O
exp_s2_x	double
;	O
*	O
newv	pointer
=	O
c1	double
*	O
s1	double
*	O
exp_s1_x	double
+	O
c2	double
*	O
s2	double
*	O
exp_s2_x	double
;	O
return	O
;	O
}	O
if	O
(	O
t	double
==	O
0.0	int
||	O
y	short
==	O
0.0	int
)	O
{	O
x	float
=	O
0.0	int
;	O
}	O
else	O
{	O
x	float
=	O
atan2	function
(	O
y	short
*	O
s	double
-	O
v	struct
,	O
t	double
*	O
y	short
)	O
/	O
t	double
;	O
}	O
if	O
(	O
x	float
==	O
0.0	int
)	O
{	O
c1	double
=	O
y	short
;	O
}	O
else	O
if	O
(	O
cos	function
(	O
t	double
*	O
x	float
)	O
!=	O
0.0	int
)	O
{	O
exp_s1_x	double
=	O
exp	function
(	O
s	double
*	O
x	float
)	O
;	O
if	O
(	O
exp_s1_x	double
==	O
0.0	int
)	O
{	O
return_zero	int
=	O
1	int
;	O
}	O
else	O
{	O
c1	double
=	O
y	short
/	O
(	O
exp_s1_x	double
*	O
cos	function
(	O
t	double
*	O
x	float
)	O
)	O
;	O
}	O
}	O
else	O
{	O
return_zero	int
=	O
1	int
;	O
}	O
if	O
(	O
return_zero	int
)	O
{	O
*	O
newy	pointer
=	O
0.0	int
;	O
*	O
newv	pointer
=	O
v	struct
;	O
return	O
;	O
}	O
x	float
+=	O
deltaT	double
;	O
*	O
newy	pointer
=	O
exp	function
(	O
s	double
*	O
x	float
)	O
*	O
c1	double
*	O
cos	function
(	O
t	double
*	O
x	float
)	O
;	O
*	O
newv	pointer
=	O
exp	function
(	O
s	double
*	O
x	float
)	O
*	O
c1	double
*	O
(	O
s	double
*	O
cos	function
(	O
t	double
*	O
x	float
)	O
-	O
t	double
*	O
sin	function
(	O
t	double
*	O
x	float
)	O
)	O
;	O
if	O
(	O
isnan	function
(	O
*	O
newy	pointer
)	O
||	O
isnan	function
(	O
*	O
newv	pointer
)	O
)	O
{	O
printf	function
(	O
"Gotcha\n"	pointer
)	O
;	O
}	O
}	O
void	O
calcCoefficients	function
(	O
craft	struct
*	O
c	pointer
,	O
double	O
*	O
CLift	pointer
,	O
double	O
*	O
CDrag	pointer
)	O
{	O
double	O
CDAlpha	double
,	O
CDBeta	double
;	O
register	O
craftType	struct
*	O
p	pointer
=	O
c	pointer
->	O
cinfo	pointer
;	O
*	O
CLift	pointer
=	O
interpolate	function
(	O
p	pointer
->	O
CLift	pointer
,	O
c	pointer
->	O
alpha	double
)	O
+	O
sin	function
(	O
c	pointer
->	O
curFlap	double
)	O
*	O
p	pointer
->	O
cFlap	double
;	O
CM	double
=	O
p	pointer
->	O
cmSlope	double
+	O
c	pointer
->	O
damageCM	double
;	O
CDAlpha	double
=	O
interpolate	function
(	O
p	pointer
->	O
CDb	pointer
,	O
c	pointer
->	O
mach	double
)	O
+	O
*	O
CLift	pointer
*	O
*	O
CLift	pointer
/	O
(	O
pi	int
*	O
p	pointer
->	O
aspectRatio	double
)	O
;	O
CDAlpha	double
+=	O
sin	function
(	O
c	pointer
->	O
curSpeedBrake	double
)	O
*	O
p	pointer
->	O
cSpeedBrake	double
;	O
CDAlpha	double
+=	O
sin	function
(	O
c	pointer
->	O
curFlap	double
)	O
*	O
p	pointer
->	O
cFlapDrag	double
;	O
CDAlpha	double
+=	O
(	O
sin	function
(	O
c	pointer
->	O
curGear	array
[	O
0	int
]	O
)	O
+	O
sin	function
(	O
c	pointer
->	O
curGear	array
[	O
1	int
]	O
)	O
+	O
sin	function
(	O
c	pointer
->	O
curGear	array
[	O
2	int
]	O
)	O
)	O
/	O
3.0	int
*	O
p	pointer
->	O
cGearDrag	double
;	O
if	O
(	O
fabs	function
(	O
c	pointer
->	O
beta	double
)	O
>	O
p	pointer
->	O
betaStall	double
)	O
CN	double
=	O
interpolate	function
(	O
p	pointer
->	O
CnBeta	pointer
,	O
fabs	function
(	O
c	pointer
->	O
alpha	double
)	O
)	O
*	O
fabs	function
(	O
sin	function
(	O
c	pointer
->	O
beta	double
)	O
)	O
;	O
else	O
CN	double
=	O
interpolate	function
(	O
p	pointer
->	O
CnBeta	pointer
,	O
fabs	function
(	O
c	pointer
->	O
alpha	double
)	O
)	O
;	O
CDBeta	double
=	O
p	pointer
->	O
CDBOrigin	double
+	O
p	pointer
->	O
CDBFactor	double
*	O
sin	function
(	O
c	pointer
->	O
beta	double
+	O
p	pointer
->	O
CDBPhase	double
)	O
;	O
*	O
CDrag	pointer
=	O
sqrt	function
(	O
CDAlpha	double
*	O
CDAlpha	double
+	O
CDBeta	double
*	O
CDBeta	double
)	O
;	O
C_Y	double
=	O
p	pointer
->	O
CYbeta	double
*	O
c	pointer
->	O
beta	double
;	O
}	O
double	O
heading	double
(	O
VPoint	struct
*	O
x	float
)	O
{	O
double	O
m	float
;	O
if	O
(	O
x	float
->	O
x	float
==	O
0.0	int
&&	O
x	float
->	O
y	short
==	O
0.0	int
)	O
return	O
0.0	int
;	O
if	O
(	O
(	O
m	float
=	O
atan2	function
(	O
x	float
->	O
y	short
,	O
x	float
->	O
x	float
)	O
)	O
<	O
0.0	int
)	O
return	O
(	O
pi	int
*	O
2.0	int
+	O
m	float
)	O
;	O
else	O
return	O
m	float
;	O
}	O
void	O
matrixToEuler	function
(	O
VMatrix	struct
*	O
mt	pointer
,	O
double	O
*	O
heading	double
,	O
double	O
*	O
pitch	double
,	O
double	O
*	O
roll	double
)	O
{	O
double	O
sin_theta	double
;	O
sin_theta	double
=	O
-	O
mt	pointer
->	O
m	float
[	O
2	int
]	O
[	O
0	int
]	O
;	O
if	O
(	O
fabs	function
(	O
sin_theta	double
)	O
>	O
1.0	int
-	O
EPSILON	int
)	O
{	O
*	O
heading	double
=	O
atan2	function
(	O
-	O
mt	pointer
->	O
m	float
[	O
0	int
]	O
[	O
1	int
]	O
,	O
mt	pointer
->	O
m	float
[	O
1	int
]	O
[	O
1	int
]	O
)	O
;	O
if	O
(	O
*	O
heading	double
<	O
0.0	int
)	O
*	O
heading	double
+=	O
2.0	int
*	O
M_PI	int
;	O
if	O
(	O
sin_theta	double
>	O
0.0	int
)	O
*	O
pitch	double
=	O
M_PI	int
/	O
2.0	int
;	O
else	O
*	O
pitch	double
=	O
-	O
M_PI	int
/	O
2.0	int
;	O
*	O
roll	double
=	O
0.0	int
;	O
}	O
else	O
{	O
*	O
heading	double
=	O
atan2	function
(	O
mt	pointer
->	O
m	float
[	O
1	int
]	O
[	O
0	int
]	O
,	O
mt	pointer
->	O
m	float
[	O
0	int
]	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
*	O
heading	double
<	O
0.0	int
)	O
*	O
heading	double
+=	O
2.0	int
*	O
M_PI	int
;	O
*	O
pitch	double
=	O
asin	function
(	O
sin_theta	double
)	O
;	O
*	O
roll	double
=	O
atan2	function
(	O
mt	pointer
->	O
m	float
[	O
2	int
]	O
[	O
1	int
]	O
,	O
mt	pointer
->	O
m	float
[	O
2	int
]	O
[	O
2	int
]	O
)	O
;	O
}	O
}	O
void	O
euler	function
(	O
craft	struct
*	O
c	pointer
)	O
{	O
register	O
double	O
i	int
,	O
j	int
,	O
k	double
,	O
m	float
;	O
i	int
=	O
c	pointer
->	O
trihedral	struct
.	O
m	float
[	O
0	int
]	O
[	O
0	int
]	O
;	O
j	int
=	O
c	pointer
->	O
trihedral	struct
.	O
m	float
[	O
1	int
]	O
[	O
0	int
]	O
;	O
k	double
=	O
c	pointer
->	O
trihedral	struct
.	O
m	float
[	O
2	int
]	O
[	O
0	int
]	O
;	O
if	O
(	O
i	int
==	O
0.0	int
&&	O
j	int
==	O
0.0	int
)	O
c	pointer
->	O
curHeading	double
=	O
0.0	int
;	O
else	O
if	O
(	O
(	O
m	float
=	O
atan2	function
(	O
j	int
,	O
i	int
)	O
)	O
<	O
0.0	int
)	O
c	pointer
->	O
curHeading	double
=	O
pi	int
*	O
2.0	int
+	O
m	float
;	O
else	O
c	pointer
->	O
curHeading	double
=	O
m	float
;	O
c	pointer
->	O
curPitch	double
=	O
-	O
asin	function
(	O
k	double
)	O
;	O
c	pointer
->	O
curRoll	double
=	O
atan2	function
(	O
c	pointer
->	O
trihedral	struct
.	O
m	float
[	O
2	int
]	O
[	O
1	int
]	O
,	O
c	pointer
->	O
trihedral	struct
.	O
m	float
[	O
2	int
]	O
[	O
2	int
]	O
)	O
;	O
}	O
void	O
craftToGround	function
(	O
craft	struct
*	O
c	pointer
,	O
VPoint	struct
*	O
p	pointer
,	O
VPoint	struct
*	O
g	pointer
)	O
{	O
VTransform_	function
(	O
p	pointer
,	O
&	O
(	O
c	pointer
->	O
trihedral	struct
)	O
,	O
g	pointer
)	O
;	O
}	O
void	O
calcGForces	function
(	O
craft	struct
*	O
c	pointer
,	O
VPoint	struct
*	O
f	struct
,	O
double	O
w	pointer
)	O
{	O
VPoint	struct
t	double
,	O
t1	struct
;	O
double	O
m_slugs	double
;	O
m_slugs	double
=	O
w	pointer
/	O
earth_g	int
;	O
t	double
=	O
*	O
f	struct
;	O
t	double
.	O
x	float
=	O
t	double
.	O
x	float
/	O
m_slugs	double
;	O
t	double
.	O
y	short
=	O
t	double
.	O
y	short
/	O
m_slugs	double
;	O
t	double
.	O
z	short
=	O
t	double
.	O
z	short
/	O
m_slugs	double
;	O
VReverseTransform_	function
(	O
&	O
t	double
,	O
&	O
c	pointer
->	O
trihedral	struct
,	O
&	O
c	pointer
->	O
linAcc	struct
)	O
;	O
t	double
.	O
z	short
-=	O
earth_g	int
;	O
VReverseTransform_	function
(	O
&	O
t	double
,	O
&	O
c	pointer
->	O
trihedral	struct
,	O
&	O
t1	struct
)	O
;	O
c	pointer
->	O
G	struct
.	O
x	float
=	O
t1	struct
.	O
x	float
/	O
earth_g	int
;	O
c	pointer
->	O
G	struct
.	O
y	short
=	O
t1	struct
.	O
y	short
/	O
earth_g	int
;	O
c	pointer
->	O
G	struct
.	O
z	short
=	O
t1	struct
.	O
z	short
/	O
earth_g	int
;	O
}	O
void	O
calcAlphaBeta	function
(	O
craft	struct
*	O
c	pointer
,	O
double	O
*	O
alpha	double
,	O
double	O
*	O
beta	double
)	O
{	O
VPoint	struct
C	struct
;	O
double	O
h	int
;	O
if	O
(	O
mag	O
(	O
c	pointer
->	O
Cg	struct
)	O
>	O
0.0	int
)	O
{	O
VReverseTransform_	function
(	O
&	O
c	pointer
->	O
Cg	struct
,	O
&	O
c	pointer
->	O
trihedral	struct
,	O
&	O
C	struct
)	O
;	O
*	O
beta	double
=	O
atan2	function
(	O
C	struct
.	O
y	short
,	O
C	struct
.	O
x	float
)	O
;	O
h	int
=	O
sqrt	function
(	O
C	struct
.	O
y	short
*	O
C	struct
.	O
y	short
+	O
C	struct
.	O
x	float
*	O
C	struct
.	O
x	float
)	O
;	O
*	O
alpha	double
=	O
atan	function
(	O
C	struct
.	O
z	short
/	O
h	int
)	O
;	O
}	O
else	O
{	O
*	O
alpha	double
=	O
0.0	int
;	O
*	O
beta	double
=	O
0.0	int
;	O
}	O
}	O
void	O
buildEulerMatrix	function
(	O
double	O
roll	double
,	O
double	O
pitch	double
,	O
double	O
heading	double
,	O
VMatrix	struct
*	O
m	float
)	O
{	O
register	O
double	O
sinPhi	double
,	O
cosPhi	double
,	O
sinTheta	double
,	O
cosTheta	double
,	O
sinPsi	double
,	O
cosPsi	double
;	O
sinPhi	double
=	O
sin	function
(	O
roll	double
)	O
;	O
cosPhi	double
=	O
cos	function
(	O
roll	double
)	O
;	O
sinTheta	double
=	O
sin	function
(	O
pitch	double
)	O
;	O
cosTheta	double
=	O
cos	function
(	O
pitch	double
)	O
;	O
sinPsi	double
=	O
sin	function
(	O
heading	double
)	O
;	O
cosPsi	double
=	O
cos	function
(	O
heading	double
)	O
;	O
m	float
->	O
m	float
[	O
0	int
]	O
[	O
0	int
]	O
=	O
cosTheta	double
*	O
cosPsi	double
;	O
m	float
->	O
m	float
[	O
0	int
]	O
[	O
1	int
]	O
=	O
sinPhi	double
*	O
sinTheta	double
*	O
cosPsi	double
-	O
cosPhi	double
*	O
sinPsi	double
;	O
m	float
->	O
m	float
[	O
0	int
]	O
[	O
2	int
]	O
=	O
cosPhi	double
*	O
sinTheta	double
*	O
cosPsi	double
+	O
sinPhi	double
*	O
sinPsi	double
;	O
m	float
->	O
m	float
[	O
1	int
]	O
[	O
0	int
]	O
=	O
cosTheta	double
*	O
sinPsi	double
;	O
m	float
->	O
m	float
[	O
1	int
]	O
[	O
1	int
]	O
=	O
sinPhi	double
*	O
sinTheta	double
*	O
sinPsi	double
+	O
cosPhi	double
*	O
cosPsi	double
;	O
m	float
->	O
m	float
[	O
1	int
]	O
[	O
2	int
]	O
=	O
cosPhi	double
*	O
sinTheta	double
*	O
sinPsi	double
-	O
sinPhi	double
*	O
cosPsi	double
;	O
m	float
->	O
m	float
[	O
2	int
]	O
[	O
0	int
]	O
=	O
-	O
sinTheta	double
;	O
m	float
->	O
m	float
[	O
2	int
]	O
[	O
1	int
]	O
=	O
sinPhi	double
*	O
cosTheta	double
;	O
m	float
->	O
m	float
[	O
2	int
]	O
[	O
2	int
]	O
=	O
cosPhi	double
*	O
cosTheta	double
;	O
m	float
->	O
m	float
[	O
0	int
]	O
[	O
3	int
]	O
=	O
m	float
->	O
m	float
[	O
1	int
]	O
[	O
3	int
]	O
=	O
m	float
->	O
m	float
[	O
2	int
]	O
[	O
3	int
]	O
=	O
0.0	int
;	O
m	float
->	O
m	float
[	O
3	int
]	O
[	O
0	int
]	O
=	O
m	float
->	O
m	float
[	O
3	int
]	O
[	O
1	int
]	O
=	O
m	float
->	O
m	float
[	O
3	int
]	O
[	O
2	int
]	O
=	O
0.0	int
;	O
m	float
->	O
m	float
[	O
3	int
]	O
[	O
3	int
]	O
=	O
1.0	int
;	O
}	O
double	O
elevatorSetting	function
(	O
craft	struct
*	O
c	pointer
,	O
double	O
qS	double
,	O
double	O
w	pointer
)	O
{	O
register	O
double	O
s	double
,	O
n	double
,	O
L	double
,	O
an	double
;	O
register	O
craftType	struct
*	O
p	pointer
=	O
c	pointer
->	O
cinfo	pointer
;	O
s	double
=	O
c	pointer
->	O
Se	double
+	O
c	pointer
->	O
SeTrim	double
;	O
if	O
(	O
s	double
>	O
1.0	int
)	O
s	double
=	O
1.0	int
;	O
else	O
if	O
(	O
s	double
<	O
-	O
1.0	int
)	O
s	double
=	O
-	O
1.0	int
;	O
L	double
=	O
p	pointer
->	O
effElevator	double
*	O
p	pointer
->	O
CLSlope	double
;	O
an	double
=	O
cos	function
(	O
s	double
*	O
p	pointer
->	O
effElevator	double
)	O
;	O
n	double
=	O
an	double
*	O
(	O
-	O
s	double
*	O
L	double
+	O
p	pointer
->	O
CLOrigin	double
)	O
*	O
qS	double
/	O
w	pointer
;	O
if	O
(	O
n	double
>	O
9.5	int
)	O
s	double
=	O
-	O
(	O
9.5	int
/	O
(	O
an	double
*	O
qS	double
)	O
*	O
w	pointer
-	O
p	pointer
->	O
CLOrigin	double
)	O
/	O
L	double
;	O
else	O
if	O
(	O
n	double
<	O
-	O
3.0	int
)	O
s	double
=	O
-	O
(	O
-	O
3.0	int
/	O
(	O
an	double
*	O
qS	double
)	O
*	O
w	pointer
-	O
p	pointer
->	O
CLOrigin	double
)	O
/	O
L	double
;	O
return	O
s	double
;	O
}	O
double	O
aileronSetting	function
(	O
craft	struct
*	O
c	pointer
)	O
{	O
double	O
Sa	double
=	O
c	pointer
->	O
Sa	double
+	O
c	pointer
->	O
SaTrim	double
;	O
if	O
(	O
Sa	double
>	O
1.0	int
)	O
{	O
Sa	double
=	O
1.0	int
;	O
}	O
else	O
if	O
(	O
Sa	double
<	O
-	O
1.0	int
)	O
{	O
Sa	double
=	O
-	O
1.0	int
;	O
}	O
return	O
Sa	double
;	O
}	O
int	O
flightCalculations	function
(	O
craft	struct
*	O
c	pointer
)	O
{	O
register	O
craftType	struct
*	O
p	pointer
=	O
c	pointer
->	O
cinfo	pointer
;	O
double	O
qS	double
,	O
s	double
,	O
CLift	pointer
,	O
CDrag	pointer
;	O
double	O
ClBeta	pointer
;	O
double	O
FLift	double
,	O
FDrag	double
,	O
FWeight	double
,	O
FSideForce	double
;	O
double	O
deltaRoll	double
,	O
deltaPitch	double
,	O
deltaYaw	double
;	O
double	O
y	short
,	O
newy	pointer
;	O
double	O
xa	double
,	O
xb	double
,	O
xc	double
,	O
xd	double
,	O
r0	double
;	O
double	O
dNorth	double
,	O
dEast	double
,	O
dmag	double
,	O
dHeading_rad	double
;	O
double	O
mass_slugs	double
;	O
VPoint	struct
F	struct
,	O
Fg	struct
,	O
tmp	struct
;	O
VMatrix	struct
mtx	struct
,	O
new_trihedral	struct
;	O
dis_entity_appearance	long
appearance	long
;	O
int	O
airborne	int
=	O
1	int
;	O
c	pointer
->	O
prevSg	struct
=	O
c	pointer
->	O
Sg	struct
;	O
c	pointer
->	O
prevw	struct
=	O
c	pointer
->	O
w	pointer
;	O
c	pointer
->	O
rho	double
=	O
calcRho	function
(	O
METERStoFEET	O
(	O
c	pointer
->	O
w	pointer
.	O
z	short
)	O
,	O
&	O
c	pointer
->	O
mach1	double
)	O
;	O
calcAlphaBeta	function
(	O
c	pointer
,	O
&	O
(	O
c	pointer
->	O
alpha	double
)	O
,	O
&	O
(	O
c	pointer
->	O
beta	double
)	O
)	O
;	O
c	pointer
->	O
VT	double
=	O
mag	O
(	O
c	pointer
->	O
Cg	struct
)	O
;	O
c	pointer
->	O
mach	double
=	O
c	pointer
->	O
VT	double
/	O
c	pointer
->	O
mach1	double
;	O
if	O
(	O
disInUse	int
)	O
{	O
appearance	long
=	O
dis_getEntityAppearance	function
(	O
c	pointer
->	O
disId	int
)	O
;	O
appearance	long
&=	O
~	O
(	O
DISAppearanceAirAfterburnerOn	O
|	O
DISAppearancePlatformPowerplantOn	O
)	O
;	O
}	O
if	O
(	O
c	pointer
->	O
fuel	double
<=	O
0.0	int
||	O
isFunctioning	O
(	O
c	pointer
,	O
SYS_ENGINE1	int
)	O
==	O
0	int
)	O
{	O
c	pointer
->	O
curThrust	double
=	O
0.0	int
;	O
}	O
else	O
{	O
c	pointer
->	O
curThrust	double
=	O
(	O
*	O
p	pointer
->	O
thrust	pointer
)	O
(	O
c	pointer
)	O
;	O
if	O
(	O
c	pointer
->	O
flags	short
&	O
FL_AFTERBURNER	O
)	O
{	O
appearance	long
|=	O
DISAppearanceAirAfterburnerOn	O
;	O
}	O
appearance	long
|=	O
DISAppearancePlatformPowerplantOn	O
;	O
}	O
if	O
(	O
disInUse	int
)	O
{	O
dis_setEntityAppearance	function
(	O
c	pointer
->	O
disId	int
,	O
appearance	long
)	O
;	O
}	O
calcCoefficients	function
(	O
c	pointer
,	O
&	O
CLift	pointer
,	O
&	O
CDrag	pointer
)	O
;	O
ClBeta	pointer
=	O
interpolate	function
(	O
p	pointer
->	O
ClBeta	pointer
,	O
fabs	function
(	O
c	pointer
->	O
alpha	double
)	O
)	O
;	O
qS	double
=	O
c	pointer
->	O
rho	double
*	O
p	pointer
->	O
wingS	double
*	O
c	pointer
->	O
VT	double
*	O
c	pointer
->	O
VT	double
*	O
0.5	int
;	O
s	double
=	O
p	pointer
->	O
wings	double
;	O
FLift	double
=	O
CLift	pointer
*	O
qS	double
;	O
FDrag	double
=	O
CDrag	pointer
*	O
qS	double
;	O
FSideForce	double
=	O
C_Y	double
*	O
qS	double
;	O
FWeight	double
=	O
p	pointer
->	O
emptyWeight	double
+	O
c	pointer
->	O
fuel	double
;	O
setBackgroundSound	function
(	O
c	pointer
,	O
c	pointer
->	O
rpm	double
,	O
(	O
c	pointer
->	O
flags	short
&	O
FL_AFTERBURNER	O
)	O
?	O
1	int
:	O
0	int
,	O
qS	double
/	O
p	pointer
->	O
wingS	double
)	O
;	O
F	struct
.	O
x	float
=	O
c	pointer
->	O
curThrust	double
+	O
FLift	double
*	O
sin	function
(	O
c	pointer
->	O
alpha	double
)	O
-	O
FDrag	double
*	O
cos	function
(	O
c	pointer
->	O
alpha	double
)	O
*	O
cos	function
(	O
c	pointer
->	O
beta	double
)	O
;	O
F	struct
.	O
y	short
=	O
-	O
FDrag	double
*	O
sin	function
(	O
c	pointer
->	O
beta	double
)	O
+	O
FSideForce	double
;	O
F	struct
.	O
z	short
=	O
-	O
FLift	double
*	O
cos	function
(	O
c	pointer
->	O
alpha	double
)	O
-	O
FDrag	double
*	O
cos	function
(	O
c	pointer
->	O
beta	double
)	O
*	O
sin	function
(	O
c	pointer
->	O
alpha	double
)	O
;	O
if	O
(	O
(	O
c	pointer
->	O
VT	double
>	O
p	pointer
->	O
maxNWS	double
)	O
||	O
(	O
(	O
c	pointer
->	O
flags	short
&	O
FL_GND_CONTACT	O
)	O
==	O
0	int
)	O
)	O
c	pointer
->	O
flags	short
&=	O
~	O
FL_NWS	O
;	O
else	O
c	pointer
->	O
flags	short
|=	O
FL_NWS	O
;	O
if	O
(	O
c	pointer
->	O
flags	short
&	O
FL_GND_CONTACT	O
)	O
{	O
airborne	int
=	O
0	int
;	O
if	O
(	O
groundDynamics	function
(	O
c	pointer
,	O
0.0	int
,	O
CLift	pointer
,	O
CDrag	pointer
,	O
CM	double
,	O
FWeight	double
,	O
qS	double
)	O
)	O
{	O
return	O
1	int
;	O
}	O
craftToGround	function
(	O
c	pointer
,	O
&	O
F	struct
,	O
&	O
Fg	struct
)	O
;	O
if	O
(	O
(	O
c	pointer
->	O
fuel	double
-=	O
fuelUsed	function
(	O
c	pointer
)	O
+	O
c	pointer
->	O
leakRate	double
*	O
deltaT	double
)	O
<=	O
0.0	int
)	O
{	O
c	pointer
->	O
fuel	double
=	O
0.0	int
;	O
c	pointer
->	O
curThrust	double
=	O
0.0	int
;	O
c	pointer
->	O
throttle	int
=	O
0	int
;	O
}	O
Fg	struct
.	O
z	short
+=	O
FWeight	double
;	O
Fg	struct
.	O
z	short
=	O
0.0	int
;	O
}	O
else	O
{	O
xa	double
=	O
p	pointer
->	O
wings	double
*	O
p	pointer
->	O
wings	double
*	O
p	pointer
->	O
wingS	double
*	O
c	pointer
->	O
rho	double
*	O
c	pointer
->	O
VT	double
*	O
p	pointer
->	O
Clp	double
;	O
xb	double
=	O
-	O
p	pointer
->	O
I	int
.	O
m	float
[	O
0	int
]	O
[	O
0	int
]	O
;	O
xc	double
=	O
qS	double
*	O
p	pointer
->	O
wings	double
*	O
2.0	int
*	O
(	O
p	pointer
->	O
Clda	double
*	O
-	O
aileronSetting	function
(	O
c	pointer
)	O
*	O
p	pointer
->	O
maxAileron	double
+	O
ClBeta	pointer
*	O
c	pointer
->	O
beta	double
+	O
p	pointer
->	O
Cldr	double
*	O
c	pointer
->	O
Sr	double
*	O
p	pointer
->	O
maxRudder	double
)	O
+	O
c	pointer
->	O
damageCL	double
*	O
qS	double
;	O
xd	double
=	O
c	pointer
->	O
p	pointer
+	O
xc	double
/	O
xa	double
;	O
r0	double
=	O
-	O
xd	double
*	O
xb	double
/	O
xa	double
;	O
deltaRoll	double
=	O
-	O
xd	double
*	O
xb	double
/	O
xa	double
*	O
exp	function
(	O
-	O
xa	double
/	O
xb	double
*	O
deltaT	double
)	O
-	O
deltaT	double
*	O
xc	double
/	O
xa	double
-	O
r0	double
;	O
c	pointer
->	O
p	pointer
=	O
xd	double
*	O
exp	function
(	O
-	O
xa	double
/	O
xb	double
*	O
deltaT	double
)	O
-	O
xc	double
/	O
xa	double
;	O
y	short
=	O
c	pointer
->	O
alpha	double
+	O
elevatorSetting	function
(	O
c	pointer
,	O
qS	double
,	O
FWeight	double
)	O
*	O
p	pointer
->	O
effElevator	double
;	O
twoOrder	function
(	O
CM	double
*	O
qS	double
*	O
p	pointer
->	O
c	pointer
/	O
p	pointer
->	O
I	int
.	O
m	float
[	O
1	int
]	O
[	O
1	int
]	O
,	O
(	O
0.25	int
*	O
p	pointer
->	O
wingS	double
*	O
c	pointer
->	O
rho	double
*	O
p	pointer
->	O
c	pointer
*	O
p	pointer
->	O
c	pointer
*	O
c	pointer
->	O
VT	double
*	O
p	pointer
->	O
Cmq	double
)	O
/	O
p	pointer
->	O
I	int
.	O
m	float
[	O
1	int
]	O
[	O
1	int
]	O
,	O
y	short
,	O
c	pointer
->	O
q	double
,	O
&	O
newy	pointer
,	O
&	O
(	O
c	pointer
->	O
q	double
)	O
)	O
;	O
deltaPitch	double
=	O
newy	pointer
-	O
y	short
;	O
y	short
=	O
c	pointer
->	O
beta	double
-	O
c	pointer
->	O
Sr	double
*	O
p	pointer
->	O
effRudder	double
;	O
if	O
(	O
y	short
>	O
pi	int
/	O
2.0	int
)	O
{	O
y	short
=	O
pi	int
-	O
y	short
;	O
}	O
else	O
if	O
(	O
y	short
<	O
-	O
pi	int
/	O
2.0	int
)	O
{	O
y	short
=	O
-	O
pi	int
-	O
y	short
;	O
}	O
twoOrder	function
(	O
CN	double
*	O
qS	double
*	O
s	double
/	O
p	pointer
->	O
I	int
.	O
m	float
[	O
2	int
]	O
[	O
2	int
]	O
,	O
(	O
p	pointer
->	O
wingS	double
*	O
c	pointer
->	O
rho	double
*	O
s	double
*	O
s	double
*	O
c	pointer
->	O
VT	double
*	O
p	pointer
->	O
Cnr	double
)	O
/	O
p	pointer
->	O
I	int
.	O
m	float
[	O
2	int
]	O
[	O
2	int
]	O
,	O
y	short
,	O
c	pointer
->	O
r	pointer
,	O
&	O
newy	pointer
,	O
&	O
(	O
c	pointer
->	O
r	pointer
)	O
)	O
;	O
deltaYaw	double
=	O
y	short
-	O
newy	pointer
;	O
buildEulerMatrix	function
(	O
deltaRoll	double
,	O
deltaPitch	double
,	O
deltaYaw	double
,	O
&	O
mtx	struct
)	O
;	O
VMatrixMultByRank	function
(	O
&	O
mtx	struct
,	O
&	O
c	pointer
->	O
trihedral	struct
,	O
&	O
new_trihedral	struct
,	O
3	int
)	O
;	O
craftToGround	function
(	O
c	pointer
,	O
&	O
F	struct
,	O
&	O
Fg	struct
)	O
;	O
if	O
(	O
(	O
c	pointer
->	O
fuel	double
-=	O
fuelUsed	function
(	O
c	pointer
)	O
+	O
c	pointer
->	O
leakRate	double
*	O
deltaT	double
)	O
<=	O
0.0	int
)	O
{	O
c	pointer
->	O
fuel	double
=	O
0.0	int
;	O
c	pointer
->	O
curThrust	double
=	O
0.0	int
;	O
}	O
Fg	struct
.	O
z	short
+=	O
FWeight	double
;	O
if	O
(	O
airborne	int
)	O
{	O
calcGForces	function
(	O
c	pointer
,	O
&	O
Fg	struct
,	O
FWeight	double
)	O
;	O
}	O
mass_slugs	double
=	O
FWeight	double
/	O
earth_g	int
;	O
dNorth	double
=	O
FEETtoMETERS	O
(	O
c	pointer
->	O
Cg	struct
.	O
x	float
*	O
deltaT	double
+	O
Fg	struct
.	O
x	float
/	O
mass_slugs	double
*	O
halfDeltaTSquared	double
)	O
;	O
dEast	double
=	O
FEETtoMETERS	O
(	O
c	pointer
->	O
Cg	struct
.	O
y	short
*	O
deltaT	double
+	O
Fg	struct
.	O
y	short
/	O
mass_slugs	double
*	O
halfDeltaTSquared	double
)	O
;	O
c	pointer
->	O
w	pointer
.	O
z	short
-=	O
FEETtoMETERS	O
(	O
c	pointer
->	O
Cg	struct
.	O
z	short
*	O
deltaT	double
+	O
Fg	struct
.	O
z	short
/	O
mass_slugs	double
*	O
halfDeltaTSquared	double
)	O
;	O
dmag	double
=	O
sqrt	function
(	O
dNorth	double
*	O
dNorth	double
+	O
dEast	double
*	O
dEast	double
)	O
;	O
DISUpdateWorldCoordinatesEx	function
(	O
&	O
c	pointer
->	O
w	pointer
,	O
dNorth	double
/	O
dmag	double
,	O
dEast	double
/	O
dmag	double
,	O
dmag	double
,	O
&	O
dHeading_rad	double
)	O
;	O
c	pointer
->	O
Cg	struct
.	O
x	float
+=	O
Fg	struct
.	O
x	float
/	O
mass_slugs	double
*	O
deltaT	double
;	O
c	pointer
->	O
Cg	struct
.	O
y	short
+=	O
Fg	struct
.	O
y	short
/	O
mass_slugs	double
*	O
deltaT	double
;	O
c	pointer
->	O
Cg	struct
.	O
z	short
+=	O
Fg	struct
.	O
z	short
/	O
mass_slugs	double
*	O
deltaT	double
;	O
VIdentMatrix	function
(	O
&	O
mtx	struct
)	O
;	O
VRotate	function
(	O
&	O
mtx	struct
,	O
ZRotation	int
,	O
dHeading_rad	double
)	O
;	O
VMatrixMultByRank	function
(	O
&	O
mtx	struct
,	O
&	O
new_trihedral	struct
,	O
&	O
c	pointer
->	O
trihedral	struct
,	O
3	int
)	O
;	O
c	pointer
->	O
trihedral	struct
=	O
new_trihedral	struct
;	O
VTransform_	function
(	O
&	O
c	pointer
->	O
Cg	struct
,	O
&	O
mtx	struct
,	O
&	O
tmp	struct
)	O
;	O
c	pointer
->	O
Cg	struct
=	O
tmp	struct
;	O
euler	function
(	O
c	pointer
)	O
;	O
y	short
=	O
groundContactTime	function
(	O
c	pointer
,	O
&	O
tmp	struct
)	O
;	O
if	O
(	O
y	short
>=	O
0.0	int
)	O
{	O
if	O
(	O
groundDynamics	function
(	O
c	pointer
,	O
y	short
,	O
CLift	pointer
,	O
CDrag	pointer
,	O
CM	double
,	O
FWeight	double
,	O
qS	double
)	O
)	O
{	O
return	O
1	int
;	O
}	O
playSound	function
(	O
c	pointer
,	O
SoundTouchdown	int
)	O
;	O
}	O
}	O
DISWorldCoordinatesToGeocentric	function
(	O
&	O
c	pointer
->	O
w	pointer
,	O
(	O
dis_world_coordinates	struct
*	O
)	O
&	O
c	pointer
->	O
Sg	struct
)	O
;	O
GenerateWorldToLocalMatrix	function
(	O
&	O
c	pointer
->	O
w	pointer
,	O
&	O
c	pointer
->	O
XYZtoNED	struct
)	O
;	O
return	O
0	int
;	O
}	O
