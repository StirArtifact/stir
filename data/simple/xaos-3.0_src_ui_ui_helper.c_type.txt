static	O
struct	O
filter	struct
*	O
uih_getinstance	function
(	O
struct	O
filteraction	struct
*	O
a	pointer
)	O
;	O
static	O
void	O
uih_destroyinstance	function
(	O
struct	O
filter	struct
*	O
f	pointer
)	O
;	O
static	O
int	O
uih_require	function
(	O
struct	O
filter	struct
*	O
f	pointer
,	O
struct	O
requirements	struct
*	O
r	int
)	O
;	O
static	O
int	O
uih_initialize	function
(	O
struct	O
filter	struct
*	O
f	pointer
,	O
struct	O
initdata	struct
*	O
i	pointer
)	O
;	O
static	O
struct	O
filteraction	struct
ui_filter	struct
=	O
{	O
"XaoS's user interface layer"	pointer
,	O
"ui"	pointer
,	O
0	int
,	O
uih_getinstance	function
,	O
uih_destroyinstance	function
,	O
NULL	O
,	O
uih_require	function
,	O
uih_initialize	function
,	O
convertupgeneric	function
,	O
convertdowngeneric	function
,	O
NULL	O
}	O
;	O
static	O
uih_context	struct
*	O
uih	pointer
;	O
static	O
int	O
waitcount	int
,	O
waitcount1	int
;	O
extern	O
struct	O
filteraction	struct
interlace_filter	struct
,	O
stereogram_filter	struct
,	O
subwindow_filter	struct
,	O
smalliter_filter	struct
,	O
julia_filter	struct
,	O
blur_filter	struct
,	O
edge_filter	struct
,	O
edge2_filter	struct
,	O
rotate_filter	struct
,	O
starfield_filter	struct
,	O
truecolor_filter	struct
,	O
fixedcolor_filter	struct
,	O
bitmap_filter	struct
,	O
emboss_filter	struct
,	O
palette_filter	struct
;	O
struct	O
filteraction	struct
*	O
uih_filters	array
[	O
MAXFILTERS	int
]	O
=	O
{	O
&	O
edge_filter	struct
,	O
&	O
edge2_filter	struct
,	O
&	O
starfield_filter	struct
,	O
&	O
stereogram_filter	struct
,	O
&	O
interlace_filter	struct
,	O
&	O
blur_filter	struct
,	O
&	O
emboss_filter	struct
,	O
&	O
palette_filter	struct
,	O
&	O
truecolor_filter	struct
,	O
NULL	O
}	O
;	O
int	O
uih_nfilters	int
=	O
9	int
;	O
static	O
void	O
uih_invalidatepos	function
(	O
uih_context	struct
*	O
uih	pointer
)	O
{	O
uih	pointer
->	O
xcenterm	int
=	O
INT_MAX	O
;	O
uih	pointer
->	O
xcenterm	int
=	O
INT_MAX	O
;	O
}	O
static	O
void	O
uih_finishpalette	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
)	O
{	O
if	O
(	O
uih	pointer
->	O
image	struct
->	O
palette	struct
->	O
flags	int
&	O
UNFINISHED	int
)	O
{	O
if	O
(	O
uih	pointer
->	O
image	struct
->	O
palette	struct
->	O
allocfinished	pointer
!=	O
NULL	O
)	O
uih	pointer
->	O
image	struct
->	O
palette	struct
->	O
allocfinished	pointer
(	O
uih	pointer
->	O
image	struct
->	O
palette	struct
)	O
;	O
uih	pointer
->	O
image	struct
->	O
palette	struct
->	O
flags	int
&=	O
~	O
UNFINISHED	int
;	O
}	O
}	O
static	O
void	O
uih_getcoord	function
(	O
uih_context	struct
*	O
uih	pointer
,	O
int	O
x	pointer
,	O
int	O
y	pointer
,	O
number_t	double
*	O
xr	pointer
,	O
number_t	double
*	O
yr	pointer
)	O
{	O
uih	pointer
->	O
uifilter	pointer
->	O
action	pointer
->	O
convertdown	pointer
(	O
uih	pointer
->	O
uifilter	pointer
,	O
&	O
x	pointer
,	O
&	O
y	pointer
)	O
;	O
*	O
xr	pointer
=	O
(	O
(	O
(	O
number_t	double
)	O
(	O
uih	pointer
->	O
fcontext	pointer
->	O
rs	struct
.	O
nc	double
+	O
(	O
x	pointer
)	O
*	O
(	O
(	O
uih	pointer
->	O
fcontext	pointer
->	O
rs	struct
.	O
mc	double
-	O
uih	pointer
->	O
fcontext	pointer
->	O
rs	struct
.	O
nc	double
)	O
/	O
(	O
number_t	double
)	O
uih	pointer
->	O
zengine	pointer
->	O
image	struct
->	O
width	int
)	O
)	O
)	O
)	O
;	O
*	O
yr	pointer
=	O
(	O
(	O
(	O
number_t	double
)	O
(	O
uih	pointer
->	O
fcontext	pointer
->	O
rs	struct
.	O
ni	double
+	O
(	O
y	pointer
)	O
*	O
(	O
(	O
uih	pointer
->	O
fcontext	pointer
->	O
rs	struct
.	O
mi	double
-	O
uih	pointer
->	O
fcontext	pointer
->	O
rs	struct
.	O
ni	double
)	O
/	O
(	O
number_t	double
)	O
uih	pointer
->	O
zengine	pointer
->	O
image	struct
->	O
height	int
)	O
)	O
)	O
)	O
;	O
rotateback	O
(	O
*	O
(	O
uih	pointer
->	O
fcontext	pointer
)	O
,	O
*	O
xr	pointer
,	O
*	O
yr	pointer
)	O
;	O
}	O
int	O
uih_enablefilter	function
(	O
uih_context	struct
*	O
c	pointer
,	O
int	O
n	int
)	O
{	O
if	O
(	O
c	pointer
->	O
filter	struct
[	O
n	int
]	O
==	O
NULL	O
)	O
{	O
struct	O
filter	struct
*	O
f	pointer
,	O
*	O
f1	pointer
;	O
int	O
i	pointer
,	O
wascycling	int
=	O
0	int
;	O
if	O
(	O
uih	pointer
->	O
cycling	int
)	O
uih_cycling_off	function
(	O
c	pointer
)	O
,	O
wascycling	int
=	O
1	int
;	O
f	pointer
=	O
uih_filters	array
[	O
n	int
]	O
->	O
getinstance	pointer
(	O
uih_filters	array
[	O
n	int
]	O
)	O
;	O
f1	pointer
=	O
c	pointer
->	O
uifilter	pointer
;	O
if	O
(	O
c	pointer
->	O
fixedcolor	pointer
!=	O
NULL	O
)	O
f1	pointer
=	O
c	pointer
->	O
fixedcolor	pointer
;	O
for	O
(	O
i	pointer
=	O
MAXFILTERS	int
-	O
1	int
;	O
i	pointer
>	O
n	int
;	O
i	pointer
--	O
)	O
{	O
if	O
(	O
c	pointer
->	O
filter	struct
[	O
i	pointer
]	O
)	O
f1	pointer
=	O
c	pointer
->	O
filter	struct
[	O
i	pointer
]	O
;	O
}	O
uih_newimage	O
(	O
c	pointer
)	O
;	O
insertfilter	function
(	O
f	pointer
,	O
f1	pointer
)	O
;	O
if	O
(	O
!	O
initqueue	function
(	O
c	pointer
->	O
queue	pointer
)	O
)	O
{	O
removefilter	pointer
(	O
f	pointer
)	O
;	O
f	pointer
->	O
action	pointer
->	O
destroyinstance	pointer
(	O
f	pointer
)	O
;	O
if	O
(	O
!	O
initqueue	function
(	O
c	pointer
->	O
queue	pointer
)	O
)	O
{	O
printf	function
(	O
"Fatal error. Can not continue\n"	pointer
)	O
;	O
exit	function
(	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
wascycling	int
)	O
uih_cycling_on	function
(	O
c	pointer
)	O
;	O
return	O
0	int
;	O
}	O
else	O
c	pointer
->	O
filter	struct
[	O
n	int
]	O
=	O
f	pointer
;	O
if	O
(	O
wascycling	int
)	O
uih_cycling_on	function
(	O
c	pointer
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
uih_fastrotateenable	function
(	O
uih_context	struct
*	O
c	pointer
)	O
{	O
int	O
wascycling	int
=	O
0	int
;	O
if	O
(	O
!	O
c	pointer
->	O
fastrotate	int
&&	O
!	O
c	pointer
->	O
juliamode	int
)	O
{	O
if	O
(	O
uih	pointer
->	O
cycling	int
)	O
uih_cycling_off	function
(	O
c	pointer
)	O
,	O
wascycling	int
=	O
1	int
;	O
c	pointer
->	O
rotatef	pointer
=	O
rotate_filter	struct
.	O
getinstance	pointer
(	O
&	O
rotate_filter	struct
)	O
;	O
if	O
(	O
c	pointer
->	O
rotatef	pointer
==	O
NULL	O
)	O
goto	O
end	int
;	O
uih_newimage	O
(	O
c	pointer
)	O
;	O
addfilter	function
(	O
c	pointer
->	O
rotatef	pointer
,	O
c	pointer
->	O
zengine	pointer
)	O
;	O
if	O
(	O
!	O
initqueue	function
(	O
c	pointer
->	O
queue	pointer
)	O
)	O
goto	O
end2	O
;	O
if	O
(	O
wascycling	int
)	O
uih_cycling_on	function
(	O
c	pointer
)	O
;	O
c	pointer
->	O
fastrotate	int
=	O
1	int
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
end2	O
:	O
removefilter	pointer
(	O
c	pointer
->	O
rotatef	pointer
)	O
;	O
initqueue	function
(	O
c	pointer
->	O
queue	pointer
)	O
;	O
c	pointer
->	O
rotatef	pointer
->	O
action	pointer
->	O
destroyinstance	pointer
(	O
c	pointer
->	O
rotatef	pointer
)	O
;	O
end	int
:	O
if	O
(	O
wascycling	int
)	O
uih_cycling_on	function
(	O
c	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
uih_fastrotatedisable	function
(	O
uih_context	struct
*	O
c	pointer
)	O
{	O
if	O
(	O
c	pointer
->	O
fastrotate	int
)	O
{	O
int	O
wascycling	int
=	O
0	int
;	O
if	O
(	O
uih	pointer
->	O
cycling	int
)	O
uih_cycling_off	function
(	O
c	pointer
)	O
,	O
wascycling	int
=	O
1	int
;	O
c	pointer
->	O
fastrotate	int
=	O
0	int
;	O
removefilter	pointer
(	O
c	pointer
->	O
rotatef	pointer
)	O
;	O
initqueue	function
(	O
c	pointer
->	O
queue	pointer
)	O
;	O
c	pointer
->	O
rotatef	pointer
->	O
action	pointer
->	O
destroyinstance	pointer
(	O
c	pointer
->	O
rotatef	pointer
)	O
;	O
c	pointer
->	O
rotatemode	int
=	O
ROTATE_NONE	int
;	O
uih_newimage	O
(	O
c	pointer
)	O
;	O
if	O
(	O
wascycling	int
)	O
uih_cycling_on	function
(	O
c	pointer
)	O
;	O
}	O
}	O
static	O
int	O
uih_fixedcolorenable	function
(	O
uih_context	struct
*	O
c	pointer
)	O
{	O
printf	function
(	O
"Fixed color not supported, please recompile XaoS\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
uih_fixedcolordisable	function
(	O
uih_context	struct
*	O
c	pointer
)	O
{	O
}	O
int	O
uih_fastrotate	function
(	O
uih_context	struct
*	O
c	pointer
,	O
int	O
mode	int
)	O
{	O
if	O
(	O
mode	int
)	O
return	O
(	O
uih_fastrotateenable	function
(	O
c	pointer
)	O
)	O
;	O
uih_fastrotatedisable	function
(	O
c	pointer
)	O
;	O
return	O
1	int
;	O
}	O
void	O
uih_angle	function
(	O
uih_context	struct
*	O
c	pointer
,	O
number_t	double
angle	double
)	O
{	O
if	O
(	O
angle	double
!=	O
c	pointer
->	O
fcontext	pointer
->	O
angle	double
)	O
{	O
if	O
(	O
!	O
c	pointer
->	O
fastrotate	int
)	O
{	O
c	pointer
->	O
fcontext	pointer
->	O
version	int
++	O
;	O
uih_newimage	O
(	O
c	pointer
)	O
;	O
}	O
c	pointer
->	O
fcontext	pointer
->	O
angle	double
=	O
angle	double
;	O
uih_animate_image	O
(	O
c	pointer
)	O
;	O
}	O
}	O
void	O
uih_rotatemode	function
(	O
uih_context	struct
*	O
c	pointer
,	O
int	O
mode	int
)	O
{	O
if	O
(	O
c	pointer
->	O
fastrotate	int
)	O
{	O
if	O
(	O
c	pointer
->	O
rotatemode	int
!=	O
mode	int
)	O
{	O
c	pointer
->	O
rotatemode	int
=	O
mode	int
;	O
if	O
(	O
mode	int
==	O
ROTATE_CONTINUOUS	int
)	O
tl_reset_timer	function
(	O
uih	pointer
->	O
doittimer	pointer
)	O
;	O
}	O
}	O
}	O
int	O
uih_enablejulia	function
(	O
uih_context	struct
*	O
c	pointer
)	O
{	O
int	O
wascycling	int
=	O
0	int
;	O
if	O
(	O
!	O
c	pointer
->	O
juliamode	int
&&	O
c	pointer
->	O
fcontext	pointer
->	O
mandelbrot	int
)	O
{	O
struct	O
filter	struct
*	O
addf	pointer
=	O
c	pointer
->	O
zengine	pointer
;	O
uih_newimage	O
(	O
c	pointer
)	O
;	O
if	O
(	O
c	pointer
->	O
fastrotate	int
)	O
addf	pointer
=	O
c	pointer
->	O
rotatef	pointer
;	O
if	O
(	O
uih	pointer
->	O
cycling	int
)	O
uih_cycling_off	function
(	O
c	pointer
)	O
,	O
wascycling	int
=	O
1	int
;	O
if	O
(	O
c	pointer
->	O
fcontext	pointer
->	O
currentformula	pointer
->	O
calculate_julia	pointer
==	O
NULL	O
)	O
c	pointer
->	O
julia	pointer
=	O
zoom_filter	struct
.	O
getinstance	pointer
(	O
&	O
zoom_filter	struct
)	O
;	O
else	O
c	pointer
->	O
julia	pointer
=	O
julia_filter	struct
.	O
getinstance	pointer
(	O
&	O
julia_filter	struct
)	O
;	O
if	O
(	O
c	pointer
->	O
julia	pointer
==	O
NULL	O
)	O
goto	O
end	int
;	O
c	pointer
->	O
subwindow	pointer
=	O
subwindow_filter	struct
.	O
getinstance	pointer
(	O
&	O
subwindow_filter	struct
)	O
;	O
if	O
(	O
c	pointer
->	O
subwindow	pointer
==	O
NULL	O
)	O
goto	O
end2	O
;	O
if	O
(	O
c	pointer
->	O
fcontext	pointer
->	O
currentformula	pointer
->	O
calculate_julia	pointer
!=	O
NULL	O
)	O
{	O
c	pointer
->	O
smalliter	pointer
=	O
smalliter_filter	struct
.	O
getinstance	pointer
(	O
&	O
smalliter_filter	struct
)	O
;	O
if	O
(	O
c	pointer
->	O
smalliter	pointer
==	O
NULL	O
)	O
goto	O
end3	O
;	O
}	O
else	O
c	pointer
->	O
smalliter	pointer
=	O
NULL	O
;	O
uih_fastrotatedisable	function
(	O
c	pointer
)	O
;	O
addfilter	function
(	O
c	pointer
->	O
subwindow	pointer
,	O
addf	pointer
)	O
;	O
if	O
(	O
c	pointer
->	O
fcontext	pointer
->	O
currentformula	pointer
->	O
calculate_julia	pointer
!=	O
NULL	O
)	O
{	O
addfilter	function
(	O
c	pointer
->	O
smalliter	pointer
,	O
addf	pointer
)	O
;	O
}	O
addfilter	function
(	O
c	pointer
->	O
julia	pointer
,	O
addf	pointer
)	O
;	O
subwindow_setsecond	function
(	O
c	pointer
->	O
subwindow	pointer
,	O
addf	pointer
)	O
;	O
if	O
(	O
!	O
initqueue	function
(	O
c	pointer
->	O
queue	pointer
)	O
)	O
goto	O
end4	O
;	O
if	O
(	O
c	pointer
->	O
fcontext	pointer
->	O
currentformula	pointer
->	O
calculate_julia	pointer
==	O
NULL	O
)	O
c	pointer
->	O
juliamode	int
=	O
2	int
;	O
else	O
c	pointer
->	O
juliamode	int
=	O
1	int
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
end4	O
:	O
;	O
removefilter	pointer
(	O
c	pointer
->	O
subwindow	pointer
)	O
;	O
removefilter	pointer
(	O
c	pointer
->	O
julia	pointer
)	O
;	O
if	O
(	O
c	pointer
->	O
smalliter	pointer
!=	O
NULL	O
)	O
removefilter	pointer
(	O
c	pointer
->	O
smalliter	pointer
)	O
;	O
initqueue	function
(	O
c	pointer
->	O
queue	pointer
)	O
;	O
end3	O
:	O
;	O
c	pointer
->	O
smalliter	pointer
->	O
action	pointer
->	O
destroyinstance	pointer
(	O
c	pointer
->	O
smalliter	pointer
)	O
;	O
end2	O
:	O
;	O
c	pointer
->	O
subwindow	pointer
->	O
action	pointer
->	O
destroyinstance	pointer
(	O
c	pointer
->	O
subwindow	pointer
)	O
;	O
end	int
:	O
;	O
c	pointer
->	O
julia	pointer
->	O
action	pointer
->	O
destroyinstance	pointer
(	O
c	pointer
->	O
julia	pointer
)	O
;	O
if	O
(	O
wascycling	int
)	O
uih_cycling_on	function
(	O
c	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
uih_disablejulia	function
(	O
uih_context	struct
*	O
c	pointer
)	O
{	O
int	O
wascycling	int
=	O
0	int
;	O
if	O
(	O
uih	pointer
->	O
juliamode	int
)	O
{	O
uih_newimage	O
(	O
c	pointer
)	O
;	O
uih	pointer
->	O
fcontext	pointer
->	O
version	int
++	O
;	O
if	O
(	O
uih	pointer
->	O
cycling	int
)	O
uih_cycling_off	function
(	O
c	pointer
)	O
,	O
wascycling	int
=	O
1	int
;	O
removefilter	pointer
(	O
c	pointer
->	O
subwindow	pointer
)	O
;	O
removefilter	pointer
(	O
c	pointer
->	O
julia	pointer
)	O
;	O
if	O
(	O
c	pointer
->	O
smalliter	pointer
!=	O
NULL	O
)	O
removefilter	pointer
(	O
c	pointer
->	O
smalliter	pointer
)	O
;	O
initqueue	function
(	O
c	pointer
->	O
queue	pointer
)	O
;	O
if	O
(	O
c	pointer
->	O
smalliter	pointer
!=	O
NULL	O
)	O
c	pointer
->	O
smalliter	pointer
->	O
action	pointer
->	O
destroyinstance	pointer
(	O
c	pointer
->	O
smalliter	pointer
)	O
;	O
c	pointer
->	O
subwindow	pointer
->	O
action	pointer
->	O
destroyinstance	pointer
(	O
c	pointer
->	O
subwindow	pointer
)	O
;	O
c	pointer
->	O
julia	pointer
->	O
action	pointer
->	O
destroyinstance	pointer
(	O
c	pointer
->	O
julia	pointer
)	O
;	O
if	O
(	O
wascycling	int
)	O
uih_cycling_on	function
(	O
c	pointer
)	O
;	O
c	pointer
->	O
juliamode	int
=	O
0	int
;	O
}	O
}	O
int	O
uih_setjuliamode	function
(	O
uih_context	struct
*	O
c	pointer
,	O
int	O
mode	int
)	O
{	O
if	O
(	O
mode	int
)	O
return	O
uih_enablejulia	function
(	O
c	pointer
)	O
;	O
uih_disablejulia	function
(	O
c	pointer
)	O
;	O
return	O
1	int
;	O
}	O
void	O
uih_rotationspeed	function
(	O
uih_context	struct
*	O
c	pointer
,	O
number_t	double
speed	double
)	O
{	O
c	pointer
->	O
rotationspeed	double
=	O
speed	double
;	O
}	O
void	O
uih_disablefilter	function
(	O
uih_context	struct
*	O
c	pointer
,	O
int	O
n	int
)	O
{	O
if	O
(	O
c	pointer
->	O
filter	struct
[	O
n	int
]	O
!=	O
NULL	O
)	O
{	O
int	O
wascycling	int
=	O
0	int
;	O
struct	O
filter	struct
*	O
f	pointer
=	O
c	pointer
->	O
filter	struct
[	O
n	int
]	O
;	O
if	O
(	O
uih	pointer
->	O
cycling	int
)	O
uih_cycling_off	function
(	O
c	pointer
)	O
,	O
wascycling	int
=	O
1	int
;	O
uih_newimage	O
(	O
c	pointer
)	O
;	O
removefilter	pointer
(	O
f	pointer
)	O
;	O
f	pointer
->	O
action	pointer
->	O
destroyinstance	pointer
(	O
f	pointer
)	O
;	O
if	O
(	O
!	O
initqueue	function
(	O
c	pointer
->	O
queue	pointer
)	O
)	O
{	O
printf	function
(	O
"Fatal error. Can not continue\n"	pointer
)	O
;	O
exit	function
(	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
wascycling	int
)	O
uih_cycling_on	function
(	O
c	pointer
)	O
;	O
}	O
c	pointer
->	O
filter	struct
[	O
n	int
]	O
=	O
NULL	O
;	O
}	O
static	O
void	O
uih_cyclinghandler	function
(	O
void	O
*	O
userdata	pointer
,	O
int	O
n	int
)	O
{	O
struct	O
uih_context	struct
*	O
uih	pointer
=	O
userdata	pointer
;	O
int	O
direct	int
;	O
if	O
(	O
uih	pointer
->	O
zengine	pointer
->	O
fractalc	pointer
->	O
palette	struct
!=	O
NULL	O
&&	O
uih	pointer
->	O
zengine	pointer
->	O
fractalc	pointer
->	O
palette	struct
->	O
cyclecolors	pointer
==	O
NULL	O
)	O
return	O
;	O
direct	int
=	O
uih	pointer
->	O
direction	int
*	O
n	int
;	O
if	O
(	O
direct	int
>	O
0	int
)	O
direct	int
%=	O
uih	pointer
->	O
zengine	pointer
->	O
fractalc	pointer
->	O
palette	struct
->	O
size	int
-	O
1	int
;	O
else	O
direct	int
=	O
-	O
(	O
(	O
-	O
direct	int
)	O
%	O
(	O
uih	pointer
->	O
zengine	pointer
->	O
fractalc	pointer
->	O
palette	struct
->	O
size	int
-	O
1	int
)	O
)	O
;	O
if	O
(	O
direct	int
)	O
{	O
uih	pointer
->	O
paletteshift	int
+=	O
direct	int
;	O
while	O
(	O
uih	pointer
->	O
paletteshift	int
<	O
0	int
)	O
uih	pointer
->	O
paletteshift	int
+=	O
uih	pointer
->	O
zengine	pointer
->	O
fractalc	pointer
->	O
palette	struct
->	O
size	int
-	O
1	int
;	O
uih	pointer
->	O
paletteshift	int
=	O
uih	pointer
->	O
paletteshift	int
%	O
(	O
uih	pointer
->	O
zengine	pointer
->	O
fractalc	pointer
->	O
palette	struct
->	O
size	int
-	O
1	int
)	O
;	O
uih	pointer
->	O
zengine	pointer
->	O
fractalc	pointer
->	O
palette	struct
->	O
cyclecolors	pointer
(	O
uih	pointer
->	O
zengine	pointer
->	O
fractalc	pointer
->	O
palette	struct
,	O
direct	int
)	O
;	O
if	O
(	O
uih	pointer
->	O
flags	int
&	O
UPDATE_AFTER_PALETTE	int
&&	O
(	O
!	O
uih	pointer
->	O
play	int
||	O
!	O
uih	pointer
->	O
nonfractalscreen	int
)	O
)	O
uih	pointer
->	O
display	int
=	O
1	int
;	O
uih_palettechg	O
(	O
uih	pointer
)	O
;	O
}	O
}	O
void	O
uih_cycling_off	function
(	O
struct	O
uih_context	struct
*	O
c	pointer
)	O
{	O
if	O
(	O
c	pointer
->	O
cycling	int
)	O
{	O
tl_free_timer	function
(	O
c	pointer
->	O
cyclingtimer	pointer
)	O
;	O
c	pointer
->	O
cycling	int
=	O
0	int
;	O
}	O
}	O
void	O
uih_display	function
(	O
struct	O
uih_context	struct
*	O
c	pointer
)	O
{	O
c	pointer
->	O
display	int
=	O
1	int
;	O
c	pointer
->	O
nonfractalscreen	int
=	O
0	int
;	O
if	O
(	O
c	pointer
->	O
clearscreen	int
)	O
c	pointer
->	O
clearscreen	int
=	O
0	int
;	O
if	O
(	O
c	pointer
->	O
displaytext	int
)	O
c	pointer
->	O
displaytext	int
=	O
0	int
,	O
free	function
(	O
c	pointer
->	O
text	pointer
)	O
;	O
}	O
void	O
uih_cycling_stop	function
(	O
struct	O
uih_context	struct
*	O
c	pointer
)	O
{	O
if	O
(	O
c	pointer
->	O
cycling	int
&&	O
!	O
c	pointer
->	O
stopped	int
)	O
{	O
tl_remove_timer	function
(	O
c	pointer
->	O
cyclingtimer	pointer
)	O
;	O
c	pointer
->	O
stopped	int
=	O
1	int
;	O
}	O
}	O
void	O
uih_cycling_continue	function
(	O
struct	O
uih_context	struct
*	O
c	pointer
)	O
{	O
if	O
(	O
c	pointer
->	O
cycling	int
&&	O
c	pointer
->	O
stopped	int
)	O
{	O
c	pointer
->	O
stopped	int
=	O
0	int
;	O
tl_add_timer	function
(	O
syncgroup	pointer
,	O
c	pointer
->	O
cyclingtimer	pointer
)	O
;	O
}	O
}	O
char	O
*	O
uih_save	function
(	O
struct	O
uih_context	struct
*	O
c	pointer
,	O
xio_path	pointer
filename	pointer
)	O
{	O
xio_file	pointer
f	pointer
;	O
char	O
*	O
r	int
;	O
uih_cycling_stop	function
(	O
c	pointer
)	O
;	O
uih_stoptimers	function
(	O
c	pointer
)	O
;	O
f	pointer
=	O
xio_wbopen	O
(	O
filename	pointer
)	O
;	O
r	int
=	O
(	O
char	O
*	O
)	O
writepng	function
(	O
f	pointer
,	O
uih	pointer
->	O
queue	pointer
->	O
saveimage	pointer
)	O
;	O
uih_cycling_continue	function
(	O
c	pointer
)	O
;	O
uih_resumetimers	function
(	O
c	pointer
)	O
;	O
return	O
(	O
r	int
)	O
;	O
}	O
void	O
uih_setcycling	function
(	O
struct	O
uih_context	struct
*	O
c	pointer
,	O
int	O
speed	double
)	O
{	O
c	pointer
->	O
cyclingspeed	int
=	O
speed	double
;	O
if	O
(	O
c	pointer
->	O
cyclingspeed	int
<	O
0	int
)	O
c	pointer
->	O
direction	int
=	O
-	O
1	int
;	O
else	O
c	pointer
->	O
direction	int
=	O
1	int
;	O
if	O
(	O
c	pointer
->	O
cycling	int
)	O
tl_set_interval	function
(	O
c	pointer
->	O
cyclingtimer	pointer
,	O
1000000	int
/	O
c	pointer
->	O
cyclingspeed	int
*	O
c	pointer
->	O
direction	int
)	O
;	O
}	O
int	O
uih_cycling_on	function
(	O
struct	O
uih_context	struct
*	O
c	pointer
)	O
{	O
if	O
(	O
uih	pointer
->	O
zengine	pointer
->	O
fractalc	pointer
->	O
palette	struct
!=	O
NULL	O
&&	O
uih	pointer
->	O
zengine	pointer
->	O
fractalc	pointer
->	O
palette	struct
->	O
cyclecolors	pointer
!=	O
NULL	O
)	O
{	O
c	pointer
->	O
cycling	int
=	O
1	int
;	O
tl_update_time	function
(	O
)	O
;	O
c	pointer
->	O
cyclingtimer	pointer
=	O
tl_create_timer	function
(	O
)	O
;	O
uih_setcycling	function
(	O
uih	pointer
,	O
c	pointer
->	O
cyclingspeed	int
)	O
;	O
tl_set_multihandler	function
(	O
c	pointer
->	O
cyclingtimer	pointer
,	O
uih_cyclinghandler	function
,	O
c	pointer
)	O
;	O
tl_add_timer	function
(	O
syncgroup	pointer
,	O
c	pointer
->	O
cyclingtimer	pointer
)	O
;	O
}	O
else	O
{	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
int	O
uih_cycling	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
,	O
int	O
mode	int
)	O
{	O
if	O
(	O
mode	int
)	O
return	O
(	O
uih_cycling_on	function
(	O
uih	pointer
)	O
)	O
;	O
uih_cycling_off	function
(	O
uih	pointer
)	O
;	O
return	O
1	int
;	O
}	O
static	O
void	O
uih_waitfunc	function
(	O
struct	O
filter	struct
*	O
f	pointer
)	O
{	O
int	O
l	int
;	O
tl_process_group	function
(	O
syncgroup	pointer
,	O
NULL	O
)	O
;	O
l	int
=	O
tl_lookup_timer	function
(	O
uih	pointer
->	O
calculatetimer	pointer
)	O
;	O
if	O
(	O
uih	pointer
->	O
interrupt	int
)	O
f	pointer
->	O
interrupt	int
=	O
1	int
,	O
uih	pointer
->	O
endtime	int
=	O
l	int
;	O
if	O
(	O
uih	pointer
->	O
interruptiblemode	int
)	O
{	O
if	O
(	O
f	pointer
->	O
incalculation	int
&&	O
!	O
uih	pointer
->	O
starttime	int
)	O
uih	pointer
->	O
starttime	int
=	O
l	int
;	O
else	O
if	O
(	O
uih	pointer
->	O
starttime	int
&&	O
!	O
f	pointer
->	O
incalculation	int
&&	O
!	O
uih	pointer
->	O
endtime	int
)	O
uih	pointer
->	O
endtime	int
=	O
l	int
;	O
if	O
(	O
(	O
uih	pointer
->	O
maxtime	int
&&	O
l	int
>	O
uih	pointer
->	O
maxtime	int
&&	O
f	pointer
->	O
readyforinterrupt	int
)	O
||	O
uih	pointer
->	O
interrupt	int
)	O
f	pointer
->	O
interrupt	int
=	O
1	int
,	O
uih	pointer
->	O
endtime	int
=	O
l	int
;	O
}	O
if	O
(	O
(	O
l	int
)	O
>	O
(	O
waitcount	int
+	O
1	int
)	O
*	O
WAITTIME	int
)	O
{	O
int	O
display	int
=	O
0	int
;	O
if	O
(	O
f	pointer
->	O
image	struct
==	O
uih	pointer
->	O
image	struct
&&	O
!	O
uih	pointer
->	O
interruptiblemode	int
&&	O
l	int
>	O
(	O
waitcount1	int
+	O
1	int
)	O
*	O
WAITTIME1	int
)	O
{	O
if	O
(	O
!	O
uih	pointer
->	O
play	int
)	O
display	int
=	O
1	int
,	O
uih_finishpalette	function
(	O
uih	pointer
)	O
;	O
waitcount1	int
++	O
;	O
}	O
if	O
(	O
uih	pointer
->	O
passfunc	pointer
!=	O
NULL	O
)	O
f	pointer
->	O
interrupt	int
|=	O
uih	pointer
->	O
passfunc	pointer
(	O
uih	pointer
,	O
display	int
,	O
f	pointer
->	O
pass	pointer
,	O
(	O
float	O
)	O
(	O
f	pointer
->	O
max	int
?	O
f	pointer
->	O
pos	int
*	O
100.0	int
/	O
f	pointer
->	O
max	int
:	O
100.0	int
)	O
)	O
;	O
waitcount	int
++	O
;	O
}	O
}	O
void	O
uih_do_fractal	function
(	O
uih_context	struct
*	O
c	pointer
)	O
{	O
int	O
flags	int
;	O
int	O
time	int
;	O
uih	pointer
->	O
interrupt	int
=	O
0	int
;	O
uih	pointer
=	O
c	pointer
;	O
if	O
(	O
c	pointer
->	O
juliamode	int
&&	O
!	O
c	pointer
->	O
fcontext	pointer
->	O
mandelbrot	int
)	O
{	O
uih_disablejulia	function
(	O
c	pointer
)	O
;	O
}	O
if	O
(	O
(	O
c	pointer
->	O
juliamode	int
==	O
1	int
&&	O
c	pointer
->	O
fcontext	pointer
->	O
currentformula	pointer
->	O
calculate_julia	pointer
==	O
NULL	O
)	O
||	O
(	O
c	pointer
->	O
juliamode	int
==	O
2	int
&&	O
c	pointer
->	O
fcontext	pointer
->	O
currentformula	pointer
->	O
calculate_julia	pointer
!=	O
NULL	O
)	O
)	O
{	O
uih_disablejulia	function
(	O
c	pointer
)	O
;	O
uih_enablejulia	function
(	O
c	pointer
)	O
;	O
uih	pointer
->	O
fcontext	pointer
->	O
version	int
++	O
;	O
}	O
tl_update_time	function
(	O
)	O
;	O
if	O
(	O
uih	pointer
->	O
recalculatemode	int
<	O
uih	pointer
->	O
fastmode	int
)	O
uih	pointer
->	O
interruptiblemode	int
=	O
1	int
;	O
else	O
uih	pointer
->	O
interruptiblemode	int
=	O
0	int
;	O
if	O
(	O
!	O
uih	pointer
->	O
interruptiblemode	int
&&	O
uih	pointer
->	O
recalculatemode	int
>	O
UIH_ANIMATION	int
)	O
{	O
if	O
(	O
uih	pointer
->	O
longwait	pointer
!=	O
NULL	O
)	O
uih	pointer
->	O
longwait	pointer
(	O
uih	pointer
)	O
;	O
uih_stoptimers	function
(	O
uih	pointer
)	O
;	O
}	O
tl_reset_timer	function
(	O
uih	pointer
->	O
calculatetimer	pointer
)	O
;	O
uih	pointer
->	O
starttime	int
=	O
0	int
;	O
uih	pointer
->	O
endtime	int
=	O
0	int
;	O
waitcount	int
=	O
tl_lookup_timer	function
(	O
uih	pointer
->	O
maintimer	pointer
)	O
/	O
WAITTIME	int
+	O
2	int
;	O
waitcount1	int
=	O
tl_lookup_timer	function
(	O
uih	pointer
->	O
maintimer	pointer
)	O
/	O
WAITTIME1	int
+	O
1	int
;	O
uih	pointer
->	O
incalculation	int
=	O
1	int
;	O
if	O
(	O
!	O
(	O
uih	pointer
->	O
flags	int
&	O
ROTATE_INSIDE_CALCULATION	int
)	O
)	O
uih_cycling_stop	function
(	O
uih	pointer
)	O
;	O
time	int
=	O
tl_lookup_timer	function
(	O
uih	pointer
->	O
doittimer	pointer
)	O
;	O
if	O
(	O
uih	pointer
->	O
rotatemode	int
==	O
ROTATE_CONTINUOUS	int
)	O
{	O
uih	pointer
->	O
fcontext	pointer
->	O
angle	double
+=	O
uih	pointer
->	O
rotationspeed	double
*	O
time	int
/	O
1000000.0	int
;	O
}	O
tl_reset_timer	function
(	O
uih	pointer
->	O
doittimer	pointer
)	O
;	O
uih	pointer
->	O
indofractal	int
=	O
1	int
;	O
if	O
(	O
uih	pointer
->	O
recalculatemode	int
<	O
UIH_PALETTEDRAW	O
)	O
{	O
if	O
(	O
uih	pointer
->	O
queue	pointer
->	O
palettechg	pointer
!=	O
NULL	O
)	O
flags	int
=	O
uih	pointer
->	O
queue	pointer
->	O
palettechg	pointer
->	O
action	pointer
->	O
doit	pointer
(	O
uih	pointer
->	O
queue	pointer
->	O
palettechg	pointer
,	O
PALETTEONLY	int
,	O
0	int
)	O
;	O
else	O
flags	int
=	O
CHANGED	int
;	O
}	O
else	O
flags	int
=	O
uih	pointer
->	O
uifilter	pointer
->	O
previous	pointer
->	O
action	pointer
->	O
doit	pointer
(	O
uih	pointer
->	O
uifilter	pointer
->	O
previous	pointer
,	O
uih	pointer
->	O
interruptiblemode	int
?	O
INTERRUPTIBLE	int
:	O
0	int
,	O
time	int
)	O
;	O
uih	pointer
->	O
indofractal	int
=	O
0	int
;	O
if	O
(	O
!	O
(	O
uih	pointer
->	O
flags	int
&	O
ROTATE_INSIDE_CALCULATION	int
)	O
)	O
uih_cycling_continue	function
(	O
uih	pointer
)	O
;	O
uih	pointer
->	O
dirty	int
=	O
0	int
;	O
if	O
(	O
uih	pointer
->	O
inanimation	int
)	O
uih	pointer
->	O
inanimation	int
--	O
;	O
uih	pointer
->	O
ddatalost	int
=	O
0	int
;	O
uih	pointer
->	O
recalculatemode	int
=	O
0	int
;	O
if	O
(	O
flags	int
&	O
ANIMATION	int
)	O
uih	pointer
->	O
fastanimation	int
=	O
1	int
;	O
else	O
uih	pointer
->	O
fastanimation	int
=	O
0	int
;	O
if	O
(	O
flags	int
&	O
(	O
ANIMATION	int
|	O
UNCOMPLETTE	O
)	O
||	O
(	O
uih	pointer
->	O
rotatemode	int
==	O
ROTATE_CONTINUOUS	int
)	O
)	O
{	O
tl_resume_timer	function
(	O
uih	pointer
->	O
doittimer	pointer
)	O
;	O
uih	pointer
->	O
uncomplette	int
=	O
1	int
,	O
uih	pointer
->	O
inanimation	int
=	O
2	int
,	O
uih	pointer
->	O
recalculatemode	int
=	O
UIH_ANIMATION	int
;	O
}	O
else	O
{	O
tl_stop_timer	function
(	O
uih	pointer
->	O
doittimer	pointer
)	O
;	O
uih	pointer
->	O
uncomplette	int
=	O
0	int
;	O
}	O
if	O
(	O
(	O
flags	int
&	O
CHANGED	int
)	O
&&	O
(	O
!	O
uih	pointer
->	O
play	int
||	O
!	O
uih	pointer
->	O
nonfractalscreen	int
)	O
)	O
{	O
uih	pointer
->	O
display	int
=	O
1	int
;	O
if	O
(	O
flags	int
&	O
INEXACT	int
)	O
uih	pointer
->	O
dirty	int
=	O
1	int
;	O
}	O
else	O
uih	pointer
->	O
incalculation	int
=	O
0	int
;	O
uih_callcomplette	function
(	O
uih	pointer
)	O
;	O
}	O
void	O
uih_callcomplette	function
(	O
uih_context	struct
*	O
c	pointer
)	O
{	O
if	O
(	O
!	O
c	pointer
->	O
uncomplette	int
&&	O
!	O
c	pointer
->	O
display	int
&&	O
!	O
c	pointer
->	O
recalculatemode	int
&&	O
!	O
c	pointer
->	O
inanimation	int
&&	O
c	pointer
->	O
complettehandler	pointer
!=	O
NULL	O
)	O
{	O
uih	pointer
->	O
complettehandler	pointer
(	O
uih	pointer
->	O
handlerdata	pointer
)	O
;	O
}	O
}	O
void	O
uih_setcomplettehandler	function
(	O
uih_context	struct
*	O
c	pointer
,	O
void	O
(	O
h	function
)	O
(	O
void	O
*	O
)	O
,	O
void	O
*	O
d	pointer
)	O
{	O
uih	pointer
->	O
complettehandler	pointer
=	O
h	function
;	O
uih	pointer
->	O
handlerdata	pointer
=	O
d	pointer
;	O
}	O
void	O
uih_letterspersec	function
(	O
uih_context	struct
*	O
c	pointer
,	O
int	O
n	int
)	O
{	O
if	O
(	O
n	int
<	O
1	int
)	O
n	int
=	O
1	int
;	O
c	pointer
->	O
letterspersec	int
=	O
n	int
;	O
}	O
double	O
uih_displayed	function
(	O
uih_context	struct
*	O
c	pointer
)	O
{	O
int	O
drawingtime	int
;	O
uih_finishpalette	function
(	O
c	pointer
)	O
;	O
if	O
(	O
uih	pointer
->	O
indofractal	int
)	O
return	O
0	int
;	O
uih	pointer
->	O
display	int
=	O
0	int
;	O
tl_update_time	function
(	O
)	O
;	O
uih_resumetimers	function
(	O
uih	pointer
)	O
;	O
c	pointer
->	O
nonfractalscreen	int
=	O
0	int
;	O
c	pointer
->	O
nletters	int
=	O
0	int
;	O
if	O
(	O
uih	pointer
->	O
incalculation	int
)	O
{	O
uih	pointer
->	O
incalculation	int
=	O
0	int
;	O
drawingtime	int
=	O
tl_lookup_timer	function
(	O
uih	pointer
->	O
calculatetimer	pointer
)	O
;	O
if	O
(	O
uih	pointer
->	O
lasttime	double
==	O
-	O
1	int
||	O
(	O
drawingtime	int
&&	O
uih	pointer
->	O
lasttime	double
&&	O
(	O
drawingtime	int
/	O
uih	pointer
->	O
lasttime	double
<	O
0.2	int
||	O
drawingtime	int
/	O
uih	pointer
->	O
lasttime	double
>	O
4	int
)	O
)	O
)	O
uih	pointer
->	O
lasttime	double
=	O
drawingtime	int
;	O
uih	pointer
->	O
lasttime	double
=	O
(	O
uih	pointer
->	O
lasttime	double
*	O
30	int
+	O
drawingtime	int
)	O
/	O
31	int
;	O
uih	pointer
->	O
lastspeed	double
=	O
uih	pointer
->	O
lasttime	double
?	O
1000000.0	int
/	O
uih	pointer
->	O
lasttime	double
:	O
100.0	int
;	O
if	O
(	O
uih	pointer
->	O
interruptiblemode	int
)	O
{	O
int	O
i	pointer
;	O
int	O
time1	int
,	O
time	int
;	O
time1	int
=	O
drawingtime	int
;	O
time1	int
-=	O
uih	pointer
->	O
endtime	int
;	O
time	int
=	O
(	O
drawingtime	int
-	O
uih	pointer
->	O
endtime	int
)	O
+	O
uih	pointer
->	O
starttime	int
;	O
if	O
(	O
uih	pointer
->	O
times	array
[	O
0	int
]	O
[	O
0	int
]	O
==	O
-	O
1	int
)	O
{	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
AVRGSIZE	int
;	O
i	pointer
++	O
)	O
uih	pointer
->	O
times	array
[	O
0	int
]	O
[	O
i	pointer
]	O
=	O
time	int
,	O
uih	pointer
->	O
times	array
[	O
1	int
]	O
[	O
i	pointer
]	O
=	O
time1	int
;	O
uih	pointer
->	O
count	array
[	O
0	int
]	O
=	O
time	int
*	O
AVRGSIZE	int
,	O
uih	pointer
->	O
count	array
[	O
1	int
]	O
=	O
time1	int
*	O
AVRGSIZE	int
;	O
}	O
uih	pointer
->	O
timespos	int
=	O
(	O
uih	pointer
->	O
timespos	int
+	O
1	int
)	O
%	O
AVRGSIZE	int
;	O
uih	pointer
->	O
count	array
[	O
0	int
]	O
+=	O
time	int
-	O
uih	pointer
->	O
times	array
[	O
0	int
]	O
[	O
uih	pointer
->	O
timespos	int
]	O
;	O
uih	pointer
->	O
count	array
[	O
1	int
]	O
+=	O
time1	int
-	O
uih	pointer
->	O
times	array
[	O
1	int
]	O
[	O
uih	pointer
->	O
timespos	int
]	O
;	O
uih	pointer
->	O
times	array
[	O
0	int
]	O
[	O
uih	pointer
->	O
timespos	int
]	O
=	O
time	int
;	O
uih	pointer
->	O
times	array
[	O
1	int
]	O
[	O
uih	pointer
->	O
timespos	int
]	O
=	O
time1	int
;	O
uih	pointer
->	O
maxtime	int
=	O
(	O
uih	pointer
->	O
count	array
[	O
0	int
]	O
*	O
5	int
)	O
/	O
AVRGSIZE	int
;	O
if	O
(	O
uih	pointer
->	O
step	double
||	O
uih	pointer
->	O
pressed	int
||	O
(	O
uih	pointer
->	O
play	int
&&	O
(	O
uih	pointer
->	O
playc	pointer
->	O
morph	int
||	O
uih	pointer
->	O
playc	pointer
->	O
morphangle	int
||	O
uih	pointer
->	O
playc	pointer
->	O
morphjulia	int
)	O
)	O
||	O
(	O
uih	pointer
->	O
rotatemode	int
==	O
ROTATE_CONTINUOUS	int
)	O
||	O
uih	pointer
->	O
fastanimation	int
)	O
{	O
if	O
(	O
uih	pointer
->	O
maxtime	int
>	O
1000000	int
/	O
25	int
)	O
uih	pointer
->	O
maxtime	int
=	O
uih	pointer
->	O
count	array
[	O
0	int
]	O
*	O
3	int
/	O
AVRGSIZE	int
;	O
if	O
(	O
uih	pointer
->	O
maxtime	int
>	O
1000000	int
/	O
15	int
)	O
uih	pointer
->	O
maxtime	int
=	O
1000000	int
/	O
15	int
;	O
}	O
else	O
{	O
uih	pointer
->	O
maxtime	int
=	O
1000000	int
/	O
3	int
;	O
}	O
if	O
(	O
uih	pointer
->	O
maxtime	int
<	O
1000000	int
/	O
30	int
)	O
uih	pointer
->	O
maxtime	int
=	O
1000000	int
/	O
30	int
;	O
uih	pointer
->	O
maxtime	int
-=	O
uih	pointer
->	O
count	array
[	O
1	int
]	O
/	O
AVRGSIZE	int
;	O
if	O
(	O
uih	pointer
->	O
maxtime	int
<	O
uih	pointer
->	O
starttime	int
+	O
10000	int
)	O
uih	pointer
->	O
maxtime	int
=	O
uih	pointer
->	O
starttime	int
+	O
10000	int
;	O
}	O
}	O
uih_callcomplette	function
(	O
uih	pointer
)	O
;	O
return	O
(	O
uih	pointer
->	O
lastspeed	double
)	O
;	O
}	O
void	O
uih_text	function
(	O
uih_context	struct
*	O
c	pointer
,	O
char	O
*	O
text	pointer
)	O
{	O
int	O
i	pointer
,	O
l	int
;	O
if	O
(	O
c	pointer
->	O
displaytext	int
)	O
free	function
(	O
c	pointer
->	O
text	pointer
)	O
;	O
c	pointer
->	O
text	pointer
=	O
strdup	function
(	O
text	pointer
)	O
;	O
l	int
=	O
strlen	function
(	O
text	pointer
)	O
;	O
c	pointer
->	O
todisplayletters	int
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
l	int
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
isalnum	function
(	O
text	pointer
[	O
i	pointer
]	O
)	O
)	O
c	pointer
->	O
todisplayletters	int
++	O
;	O
if	O
(	O
text	pointer
[	O
i	pointer
]	O
==	O
'-'	O
)	O
c	pointer
->	O
todisplayletters	int
+=	O
3	int
;	O
if	O
(	O
text	pointer
[	O
i	pointer
]	O
==	O
'.'	O
)	O
c	pointer
->	O
todisplayletters	int
+=	O
2	int
;	O
}	O
c	pointer
->	O
step	double
=	O
0	int
;	O
c	pointer
->	O
displaytext	int
=	O
1	int
;	O
if	O
(	O
c	pointer
->	O
save	int
)	O
{	O
if	O
(	O
c	pointer
->	O
savec	pointer
->	O
displaytext	int
)	O
free	function
(	O
c	pointer
->	O
text	pointer
)	O
;	O
c	pointer
->	O
savec	pointer
->	O
text	pointer
=	O
strdup	function
(	O
text	pointer
)	O
;	O
c	pointer
->	O
savec	pointer
->	O
displaytext	int
=	O
1	int
;	O
}	O
}	O
void	O
uih_clearscreen	function
(	O
uih_context	struct
*	O
c	pointer
)	O
{	O
c	pointer
->	O
clearscreen	int
=	O
1	int
;	O
if	O
(	O
c	pointer
->	O
save	int
)	O
c	pointer
->	O
savec	pointer
->	O
clearscreen	int
=	O
1	int
;	O
if	O
(	O
c	pointer
->	O
displaytext	int
)	O
c	pointer
->	O
displaytext	int
=	O
0	int
,	O
free	function
(	O
c	pointer
->	O
text	pointer
)	O
;	O
}	O
void	O
uih_settextpos	function
(	O
uih_context	struct
*	O
c	pointer
,	O
int	O
x	pointer
,	O
int	O
y	pointer
)	O
{	O
c	pointer
->	O
xtextpos	int
=	O
x	pointer
;	O
c	pointer
->	O
ytextpos	int
=	O
y	pointer
;	O
}	O
void	O
uih_tbreak	function
(	O
uih_context	struct
*	O
c	pointer
)	O
{	O
c	pointer
->	O
tbreak	int
=	O
1	int
;	O
}	O
void	O
uih_stoptimers	function
(	O
uih_context	struct
*	O
c	pointer
)	O
{	O
if	O
(	O
!	O
c	pointer
->	O
stoppedtimers	int
)	O
{	O
c	pointer
->	O
stoppedtimers	int
=	O
1	int
;	O
c	pointer
->	O
display	int
=	O
1	int
;	O
tl_stop_timer	function
(	O
c	pointer
->	O
maintimer	pointer
)	O
;	O
tl_stop_timer	function
(	O
c	pointer
->	O
doittimer	pointer
)	O
;	O
if	O
(	O
c	pointer
->	O
autopilot	int
)	O
tl_stop_timer	function
(	O
c	pointer
->	O
autopilottimer	pointer
)	O
;	O
if	O
(	O
c	pointer
->	O
play	int
)	O
{	O
tl_stop_timer	function
(	O
c	pointer
->	O
playc	pointer
->	O
timer	struct
)	O
;	O
if	O
(	O
c	pointer
->	O
cycling	int
)	O
tl_stop_timer	function
(	O
c	pointer
->	O
cyclingtimer	pointer
)	O
;	O
}	O
if	O
(	O
c	pointer
->	O
save	int
)	O
{	O
tl_stop_timer	function
(	O
c	pointer
->	O
savec	pointer
->	O
timer	struct
)	O
;	O
if	O
(	O
c	pointer
->	O
cycling	int
)	O
tl_stop_timer	function
(	O
c	pointer
->	O
cyclingtimer	pointer
)	O
;	O
}	O
}	O
}	O
void	O
uih_slowdowntimers	function
(	O
uih_context	struct
*	O
c	pointer
,	O
int	O
time	int
)	O
{	O
tl_slowdown_timer	function
(	O
c	pointer
->	O
maintimer	pointer
,	O
time	int
)	O
;	O
if	O
(	O
c	pointer
->	O
autopilot	int
)	O
tl_slowdown_timer	function
(	O
c	pointer
->	O
autopilottimer	pointer
,	O
time	int
)	O
;	O
if	O
(	O
c	pointer
->	O
play	int
)	O
{	O
tl_slowdown_timer	function
(	O
c	pointer
->	O
playc	pointer
->	O
timer	struct
,	O
time	int
)	O
;	O
if	O
(	O
c	pointer
->	O
cycling	int
)	O
tl_slowdown_timer	function
(	O
c	pointer
->	O
cyclingtimer	pointer
,	O
time	int
)	O
;	O
}	O
if	O
(	O
c	pointer
->	O
save	int
)	O
{	O
tl_slowdown_timer	function
(	O
c	pointer
->	O
savec	pointer
->	O
timer	struct
,	O
time	int
)	O
;	O
if	O
(	O
c	pointer
->	O
cycling	int
)	O
tl_slowdown_timer	function
(	O
c	pointer
->	O
cyclingtimer	pointer
,	O
time	int
)	O
;	O
}	O
}	O
void	O
uih_resumetimers	function
(	O
uih_context	struct
*	O
c	pointer
)	O
{	O
if	O
(	O
c	pointer
->	O
stoppedtimers	int
)	O
{	O
c	pointer
->	O
stoppedtimers	int
=	O
0	int
;	O
tl_resume_timer	function
(	O
c	pointer
->	O
maintimer	pointer
)	O
;	O
if	O
(	O
c	pointer
->	O
cycling	int
)	O
tl_resume_timer	function
(	O
c	pointer
->	O
cyclingtimer	pointer
)	O
;	O
if	O
(	O
c	pointer
->	O
autopilot	int
)	O
tl_resume_timer	function
(	O
c	pointer
->	O
autopilottimer	pointer
)	O
;	O
if	O
(	O
c	pointer
->	O
play	int
)	O
{	O
tl_resume_timer	function
(	O
c	pointer
->	O
playc	pointer
->	O
timer	struct
)	O
;	O
}	O
if	O
(	O
c	pointer
->	O
save	int
)	O
{	O
tl_resume_timer	function
(	O
c	pointer
->	O
savec	pointer
->	O
timer	struct
)	O
;	O
}	O
}	O
}	O
static	O
void	O
uih_changed	function
(	O
void	O
)	O
{	O
uih_newimage	O
(	O
uih	pointer
)	O
;	O
}	O
static	O
void	O
uih_autopilothandler	function
(	O
void	O
*	O
uih1	pointer
,	O
int	O
n	int
)	O
{	O
struct	O
uih_context	struct
*	O
uih	pointer
=	O
uih1	pointer
;	O
do_autopilot	function
(	O
uih	pointer
,	O
&	O
uih	pointer
->	O
autopilotx	int
,	O
&	O
uih	pointer
->	O
autopiloty	int
,	O
&	O
uih	pointer
->	O
autopilotbuttons	int
,	O
uih_changed	function
,	O
n	int
)	O
;	O
}	O
static	O
INLINE	O
void	O
uih_zoom	function
(	O
uih_context	struct
*	O
uih	pointer
)	O
{	O
uih	pointer
->	O
step	double
+=	O
uih	pointer
->	O
speedup	double
*	O
2	int
*	O
uih	pointer
->	O
mul	double
;	O
if	O
(	O
uih	pointer
->	O
step	double
>	O
uih	pointer
->	O
maxstep	double
)	O
uih	pointer
->	O
step	double
=	O
uih	pointer
->	O
maxstep	double
;	O
else	O
if	O
(	O
uih	pointer
->	O
step	double
<	O
-	O
uih	pointer
->	O
maxstep	double
)	O
uih	pointer
->	O
step	double
=	O
-	O
uih	pointer
->	O
maxstep	double
;	O
}	O
static	O
INLINE	O
void	O
uih_unzoom	function
(	O
uih_context	struct
*	O
uih	pointer
)	O
{	O
uih	pointer
->	O
step	double
-=	O
uih	pointer
->	O
speedup	double
*	O
2	int
*	O
uih	pointer
->	O
mul	double
;	O
if	O
(	O
uih	pointer
->	O
step	double
>	O
uih	pointer
->	O
maxstep	double
)	O
uih	pointer
->	O
step	double
=	O
uih	pointer
->	O
maxstep	double
;	O
else	O
if	O
(	O
uih	pointer
->	O
step	double
<	O
-	O
uih	pointer
->	O
maxstep	double
)	O
uih	pointer
->	O
step	double
=	O
-	O
uih	pointer
->	O
maxstep	double
;	O
}	O
static	O
INLINE	O
void	O
uih_slowdown	function
(	O
uih_context	struct
*	O
uih	pointer
)	O
{	O
if	O
(	O
uih	pointer
->	O
step	double
>	O
0	int
)	O
{	O
if	O
(	O
uih	pointer
->	O
step	double
<	O
uih	pointer
->	O
speedup	double
*	O
uih	pointer
->	O
mul	double
)	O
uih	pointer
->	O
step	double
=	O
0	int
;	O
else	O
uih	pointer
->	O
step	double
-=	O
uih	pointer
->	O
speedup	double
*	O
uih	pointer
->	O
mul	double
;	O
}	O
else	O
if	O
(	O
uih	pointer
->	O
step	double
<	O
0	int
)	O
{	O
if	O
(	O
uih	pointer
->	O
step	double
>	O
-	O
uih	pointer
->	O
speedup	double
*	O
uih	pointer
->	O
mul	double
)	O
uih	pointer
->	O
step	double
=	O
0	int
;	O
else	O
uih	pointer
->	O
step	double
+=	O
uih	pointer
->	O
speedup	double
*	O
uih	pointer
->	O
mul	double
;	O
}	O
}	O
static	O
INLINE	O
void	O
uih_zoomupdate	function
(	O
uih_context	struct
*	O
uih	pointer
)	O
{	O
number_t	double
x	pointer
;	O
number_t	double
y	pointer
;	O
number_t	double
mmul	double
=	O
pow	function
(	O
(	O
double	O
)	O
(	O
1	int
-	O
uih	pointer
->	O
step	double
)	O
,	O
(	O
double	O
)	O
uih	pointer
->	O
mul	double
)	O
;	O
number_t	double
mc	double
=	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
cr	double
-	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
rr	double
/	O
2	int
;	O
number_t	double
nc	double
=	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
cr	double
+	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
rr	double
/	O
2	int
;	O
number_t	double
mi	double
=	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
ci	double
-	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
ri	double
/	O
2	int
;	O
number_t	double
ni	double
=	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
ci	double
+	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
ri	double
/	O
2	int
;	O
x	pointer
=	O
uih	pointer
->	O
xcenter	double
,	O
y	pointer
=	O
uih	pointer
->	O
ycenter	double
;	O
mc	double
=	O
x	pointer
+	O
(	O
mc	double
-	O
x	pointer
)	O
*	O
(	O
mmul	double
)	O
;	O
nc	double
=	O
x	pointer
+	O
(	O
nc	double
-	O
x	pointer
)	O
*	O
(	O
mmul	double
)	O
;	O
mi	double
=	O
y	pointer
+	O
(	O
mi	double
-	O
y	pointer
)	O
*	O
(	O
mmul	double
)	O
;	O
ni	double
=	O
y	pointer
+	O
(	O
ni	double
-	O
y	pointer
)	O
*	O
(	O
mmul	double
)	O
;	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
rr	double
=	O
nc	double
-	O
mc	double
;	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
ri	double
=	O
ni	double
-	O
mi	double
;	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
cr	double
=	O
(	O
nc	double
+	O
mc	double
)	O
/	O
2	int
;	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
ci	double
=	O
(	O
ni	double
+	O
mi	double
)	O
/	O
2	int
;	O
uih_animate_image	O
(	O
uih	pointer
)	O
;	O
}	O
int	O
uih_update	function
(	O
uih_context	struct
*	O
c	pointer
,	O
int	O
mousex	int
,	O
int	O
mousey	int
,	O
int	O
mousebuttons	int
)	O
{	O
int	O
inmovement	int
=	O
0	int
;	O
int	O
slowdown	int
=	O
1	int
;	O
int	O
time	int
;	O
uih	pointer
=	O
c	pointer
;	O
if	O
(	O
mousebuttons	int
==	O
(	O
BUTTON1	int
|	O
BUTTON3	int
)	O
)	O
mousebuttons	int
=	O
BUTTON2	int
;	O
tl_process_group	function
(	O
syncgroup	pointer
,	O
NULL	O
)	O
;	O
tl_update_time	function
(	O
)	O
;	O
time	int
=	O
tl_lookup_timer	function
(	O
uih	pointer
->	O
maintimer	pointer
)	O
;	O
if	O
(	O
!	O
uih	pointer
->	O
inanimation	int
)	O
time	int
=	O
0	int
;	O
if	O
(	O
time	int
>	O
2000000	int
)	O
{	O
uih_slowdowntimers	function
(	O
uih	pointer
,	O
time	int
-	O
2000000	int
)	O
;	O
time	int
=	O
2000000	int
;	O
}	O
if	O
(	O
uih	pointer
->	O
inanimation	int
)	O
uih	pointer
->	O
inanimation	int
--	O
;	O
tl_reset_timer	function
(	O
uih	pointer
->	O
maintimer	pointer
)	O
;	O
uih	pointer
->	O
mul	double
=	O
(	O
double	O
)	O
time	int
/	O
FRAMETIME	O
;	O
if	O
(	O
uih	pointer
->	O
tbreak	int
)	O
uih	pointer
->	O
mul	double
=	O
1	int
,	O
uih	pointer
->	O
tbreak	int
--	O
;	O
if	O
(	O
uih	pointer
->	O
mul	double
==	O
0	int
)	O
uih	pointer
->	O
mul	double
=	O
0.00000001	int
;	O
if	O
(	O
uih	pointer
->	O
play	int
)	O
{	O
uih_playupdate	function
(	O
uih	pointer
)	O
;	O
if	O
(	O
!	O
uih	pointer
->	O
play	int
)	O
{	O
uih	pointer
->	O
inanimation	int
=	O
2	int
;	O
return	O
1	int
;	O
}	O
if	O
(	O
!	O
uih	pointer
->	O
juliamode	int
)	O
{	O
if	O
(	O
uih	pointer
->	O
step	double
)	O
uih_zoomupdate	function
(	O
uih	pointer
)	O
,	O
inmovement	int
=	O
1	int
;	O
switch	O
(	O
uih	pointer
->	O
zoomactive	int
)	O
{	O
case	O
1	int
:	O
uih_zoom	function
(	O
uih	pointer
)	O
,	O
inmovement	int
=	O
1	int
;	O
break	O
;	O
case	O
-	O
1	int
:	O
uih_unzoom	function
(	O
uih	pointer
)	O
,	O
inmovement	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
uih_slowdown	function
(	O
uih	pointer
)	O
;	O
}	O
if	O
(	O
uih	pointer
->	O
playc	pointer
->	O
morph	int
)	O
{	O
number_t	double
mmul	double
=	O
(	O
tl_lookup_timer	function
(	O
uih	pointer
->	O
playc	pointer
->	O
timer	struct
)	O
-	O
uih	pointer
->	O
playc	pointer
->	O
starttime	int
)	O
/	O
(	O
number_t	double
)	O
(	O
uih	pointer
->	O
playc	pointer
->	O
frametime	int
-	O
uih	pointer
->	O
playc	pointer
->	O
starttime	int
)	O
;	O
number_t	double
srr	double
,	O
drr	double
;	O
number_t	double
mmul1	double
;	O
if	O
(	O
uih	pointer
->	O
playc	pointer
->	O
source	struct
.	O
rr	double
*	O
uih	pointer
->	O
fcontext	pointer
->	O
windowwidth	float
>	O
uih	pointer
->	O
playc	pointer
->	O
source	struct
.	O
ri	double
*	O
uih	pointer
->	O
fcontext	pointer
->	O
windowheight	float
)	O
srr	double
=	O
uih	pointer
->	O
playc	pointer
->	O
source	struct
.	O
rr	double
;	O
else	O
srr	double
=	O
uih	pointer
->	O
playc	pointer
->	O
source	struct
.	O
ri	double
;	O
if	O
(	O
uih	pointer
->	O
playc	pointer
->	O
destination	struct
.	O
rr	double
*	O
uih	pointer
->	O
fcontext	pointer
->	O
windowwidth	float
>	O
uih	pointer
->	O
playc	pointer
->	O
destination	struct
.	O
ri	double
*	O
uih	pointer
->	O
fcontext	pointer
->	O
windowheight	float
)	O
drr	double
=	O
uih	pointer
->	O
playc	pointer
->	O
destination	struct
.	O
rr	double
;	O
else	O
drr	double
=	O
uih	pointer
->	O
playc	pointer
->	O
destination	struct
.	O
ri	double
;	O
if	O
(	O
srr	double
==	O
drr	double
)	O
mmul1	double
=	O
mmul	double
;	O
else	O
mmul1	double
=	O
(	O
exp	function
(	O
log	function
(	O
srr	double
)	O
+	O
(	O
(	O
log	function
(	O
drr	double
)	O
-	O
log	function
(	O
srr	double
)	O
)	O
*	O
mmul	double
)	O
)	O
-	O
srr	double
)	O
/	O
(	O
drr	double
-	O
srr	double
)	O
;	O
if	O
(	O
mmul1	double
>	O
1	int
)	O
mmul1	double
=	O
1	int
;	O
if	O
(	O
mmul1	double
<	O
0	int
)	O
mmul1	double
=	O
0	int
;	O
inmovement	int
=	O
1	int
;	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
rr	double
=	O
uih	pointer
->	O
playc	pointer
->	O
source	struct
.	O
rr	double
+	O
(	O
uih	pointer
->	O
playc	pointer
->	O
destination	struct
.	O
rr	double
-	O
uih	pointer
->	O
playc	pointer
->	O
source	struct
.	O
rr	double
)	O
*	O
mmul1	double
;	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
ri	double
=	O
uih	pointer
->	O
playc	pointer
->	O
source	struct
.	O
ri	double
+	O
(	O
uih	pointer
->	O
playc	pointer
->	O
destination	struct
.	O
ri	double
-	O
uih	pointer
->	O
playc	pointer
->	O
source	struct
.	O
ri	double
)	O
*	O
mmul1	double
;	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
cr	double
=	O
uih	pointer
->	O
playc	pointer
->	O
source	struct
.	O
cr	double
+	O
(	O
uih	pointer
->	O
playc	pointer
->	O
destination	struct
.	O
cr	double
-	O
uih	pointer
->	O
playc	pointer
->	O
source	struct
.	O
cr	double
)	O
*	O
mmul1	double
;	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
ci	double
=	O
uih	pointer
->	O
playc	pointer
->	O
source	struct
.	O
ci	double
+	O
(	O
uih	pointer
->	O
playc	pointer
->	O
destination	struct
.	O
ci	double
-	O
uih	pointer
->	O
playc	pointer
->	O
source	struct
.	O
ci	double
)	O
*	O
mmul1	double
;	O
uih_animate_image	O
(	O
uih	pointer
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
uih	pointer
->	O
playc	pointer
->	O
morphjulia	int
)	O
{	O
number_t	double
mmul	double
=	O
(	O
tl_lookup_timer	function
(	O
uih	pointer
->	O
playc	pointer
->	O
timer	struct
)	O
-	O
uih	pointer
->	O
playc	pointer
->	O
starttime	int
)	O
/	O
(	O
number_t	double
)	O
(	O
uih	pointer
->	O
playc	pointer
->	O
frametime	int
-	O
uih	pointer
->	O
playc	pointer
->	O
starttime	int
)	O
;	O
uih	pointer
->	O
fcontext	pointer
->	O
pre	double
=	O
uih	pointer
->	O
playc	pointer
->	O
sr	double
+	O
(	O
uih	pointer
->	O
playc	pointer
->	O
dr	double
-	O
uih	pointer
->	O
playc	pointer
->	O
sr	double
)	O
*	O
mmul	double
;	O
uih	pointer
->	O
fcontext	pointer
->	O
pim	double
=	O
uih	pointer
->	O
playc	pointer
->	O
si	double
+	O
(	O
uih	pointer
->	O
playc	pointer
->	O
di	double
-	O
uih	pointer
->	O
playc	pointer
->	O
si	double
)	O
*	O
mmul	double
;	O
uih_animate_image	O
(	O
uih	pointer
)	O
;	O
inmovement	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
uih	pointer
->	O
playc	pointer
->	O
morphangle	int
)	O
{	O
number_t	double
mmul	double
=	O
(	O
tl_lookup_timer	function
(	O
uih	pointer
->	O
playc	pointer
->	O
timer	struct
)	O
-	O
uih	pointer
->	O
playc	pointer
->	O
starttime	int
)	O
/	O
(	O
number_t	double
)	O
(	O
uih	pointer
->	O
playc	pointer
->	O
frametime	int
-	O
uih	pointer
->	O
playc	pointer
->	O
starttime	int
)	O
;	O
uih_angle	function
(	O
uih	pointer
,	O
uih	pointer
->	O
playc	pointer
->	O
srcangle	double
+	O
(	O
uih	pointer
->	O
playc	pointer
->	O
destangle	double
-	O
uih	pointer
->	O
playc	pointer
->	O
srcangle	double
)	O
*	O
mmul	double
)	O
;	O
inmovement	int
=	O
1	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
uih	pointer
->	O
juliamode	int
)	O
{	O
if	O
(	O
uih	pointer
->	O
autopilot	int
)	O
{	O
tl_process_group	function
(	O
uih	pointer
->	O
autopilotgroup	pointer
,	O
NULL	O
)	O
;	O
mousex	int
=	O
uih	pointer
->	O
autopilotx	int
;	O
mousey	int
=	O
uih	pointer
->	O
autopiloty	int
;	O
mousebuttons	int
=	O
uih	pointer
->	O
autopilotbuttons	int
;	O
inmovement	int
=	O
1	int
;	O
}	O
if	O
(	O
uih	pointer
->	O
step	double
)	O
{	O
number_t	double
x	pointer
;	O
number_t	double
y	pointer
;	O
if	O
(	O
mousex	int
!=	O
uih	pointer
->	O
xcenterm	int
||	O
mousey	int
!=	O
uih	pointer
->	O
ycenterm	int
)	O
{	O
uih	pointer
->	O
xcenterm	int
=	O
mousex	int
;	O
uih	pointer
->	O
ycenterm	int
=	O
mousey	int
;	O
uih_getcoord	function
(	O
uih	pointer
,	O
mousex	int
,	O
mousey	int
,	O
&	O
x	pointer
,	O
&	O
y	pointer
)	O
;	O
uih	pointer
->	O
xcenter	double
=	O
x	pointer
;	O
uih	pointer
->	O
ycenter	double
=	O
y	pointer
;	O
}	O
uih_zoomupdate	function
(	O
uih	pointer
)	O
,	O
inmovement	int
=	O
1	int
;	O
}	O
uih	pointer
->	O
zoomactive	int
=	O
0	int
;	O
if	O
(	O
uih	pointer
->	O
rotatemode	int
!=	O
ROTATE_MOUSE	int
)	O
switch	O
(	O
mousebuttons	int
)	O
{	O
case	O
BUTTON1	int
:	O
uih	pointer
->	O
zoomactive	int
=	O
1	int
;	O
inmovement	int
=	O
1	int
;	O
break	O
;	O
case	O
BUTTON3	int
:	O
uih	pointer
->	O
zoomactive	int
=	O
-	O
1	int
;	O
inmovement	int
=	O
1	int
;	O
break	O
;	O
}	O
uih_saveframe	function
(	O
uih	pointer
)	O
;	O
if	O
(	O
uih	pointer
->	O
rotatemode	int
!=	O
ROTATE_MOUSE	int
)	O
{	O
uih	pointer
->	O
rotatepressed	int
=	O
0	int
;	O
switch	O
(	O
mousebuttons	int
)	O
{	O
case	O
BUTTON1	int
:	O
uih_zoom	function
(	O
uih	pointer
)	O
,	O
slowdown	int
=	O
0	int
;	O
break	O
;	O
case	O
BUTTON3	int
:	O
uih_unzoom	function
(	O
uih	pointer
)	O
,	O
slowdown	int
=	O
0	int
;	O
break	O
;	O
case	O
BUTTON2	int
:	O
{	O
number_t	double
x	pointer
,	O
y	pointer
;	O
uih_getcoord	function
(	O
uih	pointer
,	O
mousex	int
,	O
mousey	int
,	O
&	O
x	pointer
,	O
&	O
y	pointer
)	O
;	O
if	O
(	O
uih	pointer
->	O
pressed	int
&&	O
(	O
uih	pointer
->	O
oldx	double
!=	O
x	pointer
||	O
uih	pointer
->	O
oldy	double
!=	O
y	pointer
)	O
)	O
{	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
cr	double
-=	O
x	pointer
-	O
uih	pointer
->	O
oldx	double
;	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
ci	double
-=	O
y	pointer
-	O
uih	pointer
->	O
oldy	double
;	O
uih_animate_image	O
(	O
uih	pointer
)	O
;	O
uih	pointer
->	O
moved	int
=	O
1	int
;	O
}	O
uih	pointer
->	O
pressed	int
=	O
1	int
;	O
uih	pointer
->	O
speed	double
=	O
0	int
;	O
update_view	function
(	O
uih	pointer
->	O
fcontext	pointer
)	O
;	O
uih_getcoord	function
(	O
uih	pointer
,	O
mousex	int
,	O
mousey	int
,	O
&	O
uih	pointer
->	O
oldx	double
,	O
&	O
uih	pointer
->	O
oldy	double
)	O
;	O
}	O
break	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
mousebuttons	int
&	O
BUTTON1	int
)	O
{	O
number_t	double
x	pointer
,	O
y	pointer
;	O
number_t	double
angle	double
;	O
x	pointer
=	O
(	O
mousex	int
-	O
uih	pointer
->	O
image	struct
->	O
width	int
/	O
2	int
)	O
*	O
uih	pointer
->	O
image	struct
->	O
pixelwidth	float
;	O
y	pointer
=	O
(	O
mousey	int
-	O
uih	pointer
->	O
image	struct
->	O
height	int
/	O
2	int
)	O
*	O
uih	pointer
->	O
image	struct
->	O
pixelheight	float
;	O
angle	double
=	O
-	O
atan2	function
(	O
x	pointer
,	O
y	pointer
)	O
*	O
180	int
/	O
M_PI	int
;	O
if	O
(	O
uih	pointer
->	O
rotatepressed	int
)	O
{	O
uih_angle	function
(	O
uih	pointer
,	O
uih	pointer
->	O
fcontext	pointer
->	O
angle	double
+	O
angle	double
-	O
uih	pointer
->	O
oldangle	double
)	O
;	O
}	O
uih	pointer
->	O
rotatepressed	int
=	O
1	int
;	O
uih	pointer
->	O
oldangle	double
=	O
angle	double
;	O
}	O
else	O
uih	pointer
->	O
rotatepressed	int
=	O
0	int
;	O
}	O
if	O
(	O
!	O
(	O
mousebuttons	int
&	O
BUTTON2	int
)	O
)	O
uih	pointer
->	O
pressed	int
=	O
0	int
;	O
if	O
(	O
slowdown	int
)	O
uih_slowdown	function
(	O
uih	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
mousebuttons	int
&	O
BUTTON1	int
)	O
{	O
number_t	double
x	pointer
,	O
x1	double
=	O
uih	pointer
->	O
fcontext	pointer
->	O
pre	double
;	O
number_t	double
y	pointer
,	O
y1	function
=	O
uih	pointer
->	O
fcontext	pointer
->	O
pim	double
;	O
uih	pointer
->	O
zoomactive	int
=	O
0	int
;	O
uih_getcoord	function
(	O
uih	pointer
,	O
mousex	int
,	O
mousey	int
,	O
&	O
x	pointer
,	O
&	O
y	pointer
)	O
;	O
uih	pointer
->	O
fcontext	pointer
->	O
pre	double
=	O
x	pointer
;	O
uih	pointer
->	O
fcontext	pointer
->	O
pim	double
=	O
y	pointer
;	O
uih_saveframe	function
(	O
uih	pointer
)	O
;	O
uih	pointer
->	O
pressed	int
=	O
1	int
;	O
recalculate	function
(	O
uih	pointer
->	O
fcontext	pointer
->	O
plane	int
,	O
&	O
uih	pointer
->	O
fcontext	pointer
->	O
pre	double
,	O
&	O
uih	pointer
->	O
fcontext	pointer
->	O
pim	double
)	O
;	O
if	O
(	O
uih	pointer
->	O
fcontext	pointer
->	O
pre	double
!=	O
x1	double
||	O
uih	pointer
->	O
fcontext	pointer
->	O
pim	double
!=	O
y1	function
)	O
{	O
uih_animate_image	O
(	O
uih	pointer
)	O
;	O
}	O
}	O
else	O
uih	pointer
->	O
pressed	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
!	O
inmovement	int
)	O
uih_tbreak	function
(	O
uih	pointer
)	O
;	O
if	O
(	O
uih	pointer
->	O
uncomplette	int
)	O
inmovement	int
=	O
1	int
;	O
if	O
(	O
!	O
uih	pointer
->	O
recalculatemode	int
&&	O
!	O
uih	pointer
->	O
display	int
)	O
uih_finishpalette	function
(	O
uih	pointer
)	O
;	O
if	O
(	O
!	O
inmovement	int
)	O
uih_callcomplette	function
(	O
uih	pointer
)	O
;	O
if	O
(	O
uih	pointer
->	O
inanimation	int
<	O
inmovement	int
*	O
2	int
)	O
uih	pointer
->	O
inanimation	int
=	O
inmovement	int
*	O
2	int
;	O
return	O
(	O
inmovement	int
*	O
2	int
)	O
;	O
}	O
void	O
uih_autopilot_on	function
(	O
uih_context	struct
*	O
c	pointer
)	O
{	O
if	O
(	O
!	O
c	pointer
->	O
autopilot	int
)	O
{	O
clean_autopilot	function
(	O
c	pointer
)	O
;	O
uih_autopilothandler	function
(	O
uih	pointer
,	O
1	int
)	O
;	O
tl_update_time	function
(	O
)	O
;	O
uih_resumetimers	function
(	O
uih	pointer
)	O
;	O
c	pointer
->	O
autopilottimer	pointer
=	O
tl_create_timer	function
(	O
)	O
;	O
c	pointer
->	O
autopilotgroup	pointer
=	O
tl_create_group	function
(	O
)	O
;	O
tl_set_multihandler	function
(	O
c	pointer
->	O
autopilottimer	pointer
,	O
uih_autopilothandler	function
,	O
uih	pointer
)	O
;	O
tl_set_interval	function
(	O
c	pointer
->	O
autopilottimer	pointer
,	O
1000000	int
/	O
25	int
)	O
;	O
tl_reset_timer	function
(	O
c	pointer
->	O
autopilottimer	pointer
)	O
;	O
tl_add_timer	function
(	O
c	pointer
->	O
autopilotgroup	pointer
,	O
c	pointer
->	O
autopilottimer	pointer
)	O
;	O
tl_update_time	function
(	O
)	O
;	O
c	pointer
->	O
autopilot	int
=	O
1	int
;	O
}	O
}	O
void	O
uih_autopilot_off	function
(	O
uih_context	struct
*	O
c	pointer
)	O
{	O
if	O
(	O
c	pointer
->	O
autopilot	int
)	O
{	O
tl_remove_timer	function
(	O
c	pointer
->	O
autopilottimer	pointer
)	O
;	O
tl_free_timer	function
(	O
c	pointer
->	O
autopilottimer	pointer
)	O
;	O
tl_free_group	function
(	O
c	pointer
->	O
autopilotgroup	pointer
)	O
;	O
c	pointer
->	O
autopilot	int
=	O
0	int
;	O
}	O
}	O
void	O
uih_mkdefaultpalette	function
(	O
uih_context	struct
*	O
c	pointer
)	O
{	O
if	O
(	O
c	pointer
->	O
zengine	pointer
->	O
fractalc	pointer
->	O
palette	struct
==	O
NULL	O
)	O
return	O
;	O
uih_cycling_stop	function
(	O
uih	pointer
)	O
;	O
if	O
(	O
mkdefaultpalette	function
(	O
c	pointer
->	O
zengine	pointer
->	O
fractalc	pointer
->	O
palette	struct
)	O
!=	O
0	int
)	O
{	O
uih_newimage	O
(	O
c	pointer
)	O
;	O
}	O
uih_palettechg	O
(	O
uih	pointer
)	O
;	O
uih	pointer
->	O
paletteshift	int
=	O
0	int
;	O
uih	pointer
->	O
palettechanged	int
=	O
1	int
;	O
uih	pointer
->	O
palettetype	int
=	O
0	int
;	O
uih_finishpalette	function
(	O
uih	pointer
)	O
;	O
uih_cycling_continue	function
(	O
uih	pointer
)	O
;	O
}	O
void	O
uih_mkpalette	function
(	O
uih_context	struct
*	O
c	pointer
)	O
{	O
int	O
seed	int
;	O
int	O
alg	int
=	O
rand	function
(	O
)	O
%	O
PALGORITHMS	int
;	O
if	O
(	O
c	pointer
->	O
zengine	pointer
->	O
fractalc	pointer
->	O
palette	struct
==	O
NULL	O
)	O
return	O
;	O
uih_cycling_stop	function
(	O
uih	pointer
)	O
;	O
if	O
(	O
mkpalette	function
(	O
c	pointer
->	O
zengine	pointer
->	O
fractalc	pointer
->	O
palette	struct
,	O
seed	int
=	O
rand	function
(	O
)	O
,	O
alg	int
)	O
!=	O
0	int
)	O
{	O
uih_newimage	O
(	O
c	pointer
)	O
;	O
}	O
uih_palettechg	O
(	O
uih	pointer
)	O
;	O
uih	pointer
->	O
paletteshift	int
=	O
0	int
;	O
uih	pointer
->	O
paletteseed	int
=	O
seed	int
;	O
uih_finishpalette	function
(	O
uih	pointer
)	O
;	O
uih	pointer
->	O
palettechanged	int
=	O
1	int
;	O
uih	pointer
->	O
palettetype	int
=	O
alg	int
+	O
1	int
;	O
uih_cycling_continue	function
(	O
uih	pointer
)	O
;	O
}	O
static	O
void	O
uih_alloctables	function
(	O
uih_context	struct
*	O
c	pointer
)	O
{	O
c	pointer
->	O
zengine	pointer
=	O
zoom_filter	struct
.	O
getinstance	pointer
(	O
&	O
zoom_filter	struct
)	O
;	O
if	O
(	O
c	pointer
->	O
zengine	pointer
==	O
NULL	O
)	O
return	O
;	O
c	pointer
->	O
fcontext	pointer
=	O
make_fractalc	function
(	O
0	int
,	O
c	pointer
->	O
image	struct
->	O
pixelwidth	float
*	O
c	pointer
->	O
image	struct
->	O
width	int
,	O
c	pointer
->	O
image	struct
->	O
pixelheight	float
*	O
c	pointer
->	O
image	struct
->	O
height	int
)	O
;	O
uih	pointer
=	O
c	pointer
;	O
c	pointer
->	O
uifilter	pointer
=	O
ui_filter	struct
.	O
getinstance	pointer
(	O
&	O
ui_filter	struct
)	O
;	O
c	pointer
->	O
queue	pointer
=	O
create_queue	function
(	O
c	pointer
->	O
uifilter	pointer
)	O
;	O
insertfilter	function
(	O
c	pointer
->	O
zengine	pointer
,	O
c	pointer
->	O
uifilter	pointer
)	O
;	O
}	O
static	O
int	O
uih_initqueue	function
(	O
uih_context	struct
*	O
c	pointer
)	O
{	O
return	O
(	O
initqueue	function
(	O
c	pointer
->	O
queue	pointer
)	O
)	O
;	O
}	O
void	O
uih_setmaxstep	function
(	O
uih_context	struct
*	O
c	pointer
,	O
number_t	double
p	double
)	O
{	O
c	pointer
->	O
maxstep	double
=	O
p	double
;	O
}	O
void	O
uih_setspeedup	function
(	O
uih_context	struct
*	O
c	pointer
,	O
number_t	double
p	double
)	O
{	O
c	pointer
->	O
speedup	double
=	O
p	double
;	O
}	O
void	O
uih_setmaxiter	function
(	O
uih_context	struct
*	O
c	pointer
,	O
int	O
maxiter	int
)	O
{	O
if	O
(	O
maxiter	int
<	O
1	int
)	O
maxiter	int
=	O
1	int
;	O
if	O
(	O
maxiter	int
>	O
2000000	int
)	O
maxiter	int
=	O
2000000	int
;	O
if	O
(	O
c	pointer
->	O
fcontext	pointer
->	O
maxiter	int
!=	O
(	O
unsigned	O
int	O
)	O
maxiter	int
)	O
{	O
c	pointer
->	O
fcontext	pointer
->	O
maxiter	int
=	O
maxiter	int
;	O
c	pointer
->	O
fcontext	pointer
->	O
version	int
++	O
;	O
uih_newimage	O
(	O
uih	pointer
)	O
;	O
}	O
}	O
void	O
uih_setincoloringmode	function
(	O
uih_context	struct
*	O
c	pointer
,	O
int	O
mode	int
)	O
{	O
if	O
(	O
mode	int
<	O
0	int
)	O
mode	int
=	O
0	int
;	O
if	O
(	O
mode	int
>	O
INCOLORING	int
)	O
mode	int
=	O
INCOLORING	int
;	O
if	O
(	O
c	pointer
->	O
fcontext	pointer
->	O
incoloringmode	int
!=	O
mode	int
)	O
{	O
c	pointer
->	O
fcontext	pointer
->	O
incoloringmode	int
=	O
mode	int
;	O
c	pointer
->	O
fcontext	pointer
->	O
version	int
++	O
;	O
uih_newimage	O
(	O
uih	pointer
)	O
;	O
}	O
}	O
void	O
uih_setintcolor	function
(	O
uih_context	struct
*	O
c	pointer
,	O
int	O
mode	int
)	O
{	O
if	O
(	O
mode	int
<	O
0	int
)	O
mode	int
=	O
0	int
;	O
if	O
(	O
mode	int
>	O
TCOLOR	int
)	O
mode	int
=	O
TCOLOR	int
;	O
if	O
(	O
c	pointer
->	O
fcontext	pointer
->	O
intcolor	int
!=	O
mode	int
)	O
{	O
c	pointer
->	O
fcontext	pointer
->	O
intcolor	int
=	O
mode	int
;	O
if	O
(	O
c	pointer
->	O
fcontext	pointer
->	O
incoloringmode	int
==	O
10	int
)	O
{	O
c	pointer
->	O
fcontext	pointer
->	O
version	int
++	O
;	O
uih_newimage	O
(	O
uih	pointer
)	O
;	O
}	O
}	O
}	O
void	O
uih_setouttcolor	function
(	O
uih_context	struct
*	O
c	pointer
,	O
int	O
mode	int
)	O
{	O
if	O
(	O
mode	int
<	O
0	int
)	O
mode	int
=	O
0	int
;	O
if	O
(	O
mode	int
>	O
TCOLOR	int
)	O
mode	int
=	O
TCOLOR	int
;	O
if	O
(	O
c	pointer
->	O
fcontext	pointer
->	O
outtcolor	int
!=	O
mode	int
)	O
{	O
c	pointer
->	O
fcontext	pointer
->	O
outtcolor	int
=	O
mode	int
;	O
if	O
(	O
c	pointer
->	O
fcontext	pointer
->	O
coloringmode	int
==	O
10	int
)	O
{	O
c	pointer
->	O
fcontext	pointer
->	O
version	int
++	O
;	O
uih_newimage	O
(	O
uih	pointer
)	O
;	O
}	O
}	O
}	O
void	O
uih_setperbutation	function
(	O
uih_context	struct
*	O
c	pointer
,	O
number_t	double
zre	double
,	O
number_t	double
zim	double
)	O
{	O
if	O
(	O
c	pointer
->	O
fcontext	pointer
->	O
bre	double
!=	O
zre	double
||	O
c	pointer
->	O
fcontext	pointer
->	O
bim	double
!=	O
zim	double
)	O
{	O
c	pointer
->	O
fcontext	pointer
->	O
bre	double
=	O
zre	double
;	O
c	pointer
->	O
fcontext	pointer
->	O
bim	double
=	O
zim	double
;	O
if	O
(	O
c	pointer
->	O
fcontext	pointer
->	O
mandelbrot	int
)	O
{	O
c	pointer
->	O
fcontext	pointer
->	O
version	int
++	O
;	O
uih_newimage	O
(	O
uih	pointer
)	O
;	O
}	O
}	O
}	O
void	O
uih_perbutation	function
(	O
uih_context	struct
*	O
c	pointer
,	O
int	O
mousex	int
,	O
int	O
mousey	int
)	O
{	O
number_t	double
r	int
,	O
i	pointer
;	O
uih_getcoord	function
(	O
c	pointer
,	O
mousex	int
,	O
mousey	int
,	O
&	O
r	int
,	O
&	O
i	pointer
)	O
;	O
uih_setperbutation	function
(	O
c	pointer
,	O
r	int
,	O
i	pointer
)	O
;	O
}	O
void	O
uih_setjuliaseed	function
(	O
uih_context	struct
*	O
c	pointer
,	O
number_t	double
zre	double
,	O
number_t	double
zim	double
)	O
{	O
if	O
(	O
c	pointer
->	O
fcontext	pointer
->	O
pre	double
!=	O
zre	double
||	O
c	pointer
->	O
fcontext	pointer
->	O
pim	double
!=	O
zim	double
)	O
{	O
c	pointer
->	O
fcontext	pointer
->	O
pre	double
=	O
zre	double
;	O
c	pointer
->	O
fcontext	pointer
->	O
pim	double
=	O
zim	double
;	O
if	O
(	O
c	pointer
->	O
juliamode	int
)	O
{	O
uih_animate_image	O
(	O
uih	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
c	pointer
->	O
fcontext	pointer
->	O
mandelbrot	int
)	O
uih_newimage	O
(	O
uih	pointer
)	O
;	O
}	O
}	O
}	O
void	O
uih_setfastmode	function
(	O
uih_context	struct
*	O
c	pointer
,	O
int	O
mode	int
)	O
{	O
if	O
(	O
mode	int
<	O
0	int
)	O
mode	int
=	O
0	int
;	O
c	pointer
->	O
fastmode	int
=	O
mode	int
;	O
}	O
void	O
uih_setoutcoloringmode	function
(	O
uih_context	struct
*	O
c	pointer
,	O
int	O
mode	int
)	O
{	O
if	O
(	O
mode	int
<	O
0	int
)	O
mode	int
=	O
0	int
;	O
if	O
(	O
mode	int
>	O
OUTCOLORING	int
)	O
mode	int
=	O
OUTCOLORING	int
-	O
1	int
;	O
if	O
(	O
c	pointer
->	O
fcontext	pointer
->	O
coloringmode	int
!=	O
mode	int
)	O
{	O
c	pointer
->	O
fcontext	pointer
->	O
coloringmode	int
=	O
mode	int
;	O
c	pointer
->	O
fcontext	pointer
->	O
version	int
++	O
;	O
uih_newimage	O
(	O
uih	pointer
)	O
;	O
}	O
}	O
void	O
uih_setplane	function
(	O
uih_context	struct
*	O
c	pointer
,	O
int	O
mode	int
)	O
{	O
if	O
(	O
mode	int
<	O
0	int
)	O
mode	int
=	O
0	int
;	O
if	O
(	O
mode	int
>	O
PLANES	int
)	O
mode	int
=	O
PLANES	int
-	O
1	int
;	O
uih_invalidatepos	function
(	O
uih	pointer
)	O
;	O
if	O
(	O
c	pointer
->	O
fcontext	pointer
->	O
plane	int
!=	O
mode	int
)	O
{	O
c	pointer
->	O
fcontext	pointer
->	O
plane	int
=	O
mode	int
;	O
c	pointer
->	O
fcontext	pointer
->	O
version	int
++	O
;	O
uih_newimage	O
(	O
uih	pointer
)	O
;	O
}	O
}	O
void	O
uih_setmandelbrot	function
(	O
uih_context	struct
*	O
c	pointer
,	O
int	O
mode	int
,	O
int	O
mousex	int
,	O
int	O
mousey	int
)	O
{	O
if	O
(	O
mode	int
<	O
0	int
)	O
mode	int
=	O
0	int
;	O
if	O
(	O
mode	int
>	O
1	int
)	O
mode	int
=	O
1	int
;	O
if	O
(	O
c	pointer
->	O
fcontext	pointer
->	O
mandelbrot	int
!=	O
mode	int
)	O
{	O
c	pointer
->	O
fcontext	pointer
->	O
mandelbrot	int
=	O
mode	int
;	O
if	O
(	O
c	pointer
->	O
fcontext	pointer
->	O
mandelbrot	int
==	O
0	int
&&	O
!	O
c	pointer
->	O
juliamode	int
)	O
{	O
uih_getcoord	function
(	O
c	pointer
,	O
mousex	int
,	O
mousey	int
,	O
&	O
c	pointer
->	O
fcontext	pointer
->	O
pre	double
,	O
&	O
c	pointer
->	O
fcontext	pointer
->	O
pim	double
)	O
;	O
recalculate	function
(	O
c	pointer
->	O
fcontext	pointer
->	O
plane	int
,	O
&	O
c	pointer
->	O
fcontext	pointer
->	O
pre	double
,	O
&	O
c	pointer
->	O
fcontext	pointer
->	O
pim	double
)	O
;	O
}	O
else	O
uih_disablejulia	function
(	O
c	pointer
)	O
;	O
c	pointer
->	O
fcontext	pointer
->	O
version	int
++	O
;	O
uih_newimage	O
(	O
uih	pointer
)	O
;	O
}	O
}	O
void	O
uih_setguessing	function
(	O
uih_context	struct
*	O
c	pointer
,	O
int	O
range	int
)	O
{	O
c	pointer
->	O
fcontext	pointer
->	O
range	int
=	O
range	int
;	O
}	O
void	O
uih_setperiodicity	function
(	O
uih_context	struct
*	O
c	pointer
,	O
int	O
periodicity	int
)	O
{	O
c	pointer
->	O
fcontext	pointer
->	O
periodicity	int
=	O
periodicity	int
;	O
}	O
void	O
uih_interrupt	function
(	O
uih_context	struct
*	O
c	pointer
)	O
{	O
if	O
(	O
c	pointer
->	O
incalculation	int
)	O
c	pointer
->	O
interrupt	int
=	O
1	int
;	O
}	O
void	O
uih_stopzooming	function
(	O
uih_context	struct
*	O
c	pointer
)	O
{	O
c	pointer
->	O
speed	double
=	O
0	int
;	O
}	O
int	O
uih_updateimage	function
(	O
uih_context	struct
*	O
c	pointer
,	O
struct	O
image	struct
*	O
image	struct
)	O
{	O
c	pointer
->	O
image	struct
=	O
image	struct
;	O
c	pointer
->	O
queue	pointer
->	O
isinitialized	int
=	O
0	int
;	O
uih	pointer
->	O
ddatalost	int
=	O
1	int
;	O
fractalc_resize_to	function
(	O
c	pointer
->	O
fcontext	pointer
,	O
c	pointer
->	O
image	struct
->	O
pixelwidth	float
*	O
c	pointer
->	O
image	struct
->	O
width	int
,	O
c	pointer
->	O
image	struct
->	O
pixelheight	float
*	O
c	pointer
->	O
image	struct
->	O
height	int
)	O
;	O
uih	pointer
->	O
display	int
=	O
1	int
;	O
uih	pointer
->	O
inanimation	int
=	O
2	int
;	O
uih_newimage	O
(	O
uih	pointer
)	O
;	O
if	O
(	O
image	struct
->	O
palette	struct
->	O
type	int
&	O
(	O
FIXEDCOLOR	int
|	O
BITMAPS	O
)	O
)	O
uih_fixedcolorenable	function
(	O
uih	pointer
)	O
;	O
else	O
uih_fixedcolordisable	function
(	O
uih	pointer
)	O
;	O
return	O
(	O
uih_initqueue	function
(	O
uih	pointer
)	O
)	O
;	O
}	O
struct	O
uih_context	struct
*	O
uih_mkcontext	function
(	O
int	O
flags	int
,	O
struct	O
image	struct
*	O
image	struct
,	O
int	O
(	O
*	O
passfunc	pointer
)	O
(	O
struct	O
uih_context	struct
*	O
,	O
int	O
,	O
char	O
*	O
,	O
float	O
)	O
,	O
void	O
(	O
*	O
longwait	pointer
)	O
(	O
struct	O
uih_context	struct
*	O
)	O
)	O
{	O
uih_context	struct
*	O
uih	pointer
;	O
uih	pointer
=	O
(	O
uih_context	struct
*	O
)	O
calloc	function
(	O
sizeof	O
(	O
*	O
uih	pointer
)	O
,	O
1	int
)	O
;	O
uih	pointer
->	O
autopilot	int
=	O
0	int
;	O
uih	pointer
->	O
flags	int
=	O
flags	int
;	O
uih	pointer
->	O
image	struct
=	O
image	struct
;	O
uih	pointer
->	O
speed	double
=	O
0	int
;	O
uih	pointer
->	O
step	double
=	O
0	int
;	O
uih	pointer
->	O
speedup	double
=	O
STEP	O
;	O
uih	pointer
->	O
maxstep	double
=	O
MAXSTEP	O
;	O
uih	pointer
->	O
lasttime	double
=	O
-	O
1	int
;	O
uih	pointer
->	O
recalculatemode	int
=	O
UIH_NEW_IMAGE	int
;	O
uih	pointer
->	O
fastmode	int
=	O
2	int
;	O
uih	pointer
->	O
direction	int
=	O
1	int
;	O
uih	pointer
->	O
cyclingspeed	int
=	O
ROTATIONSPEED	int
;	O
uih	pointer
->	O
ddatalost	int
=	O
1	int
;	O
uih	pointer
->	O
xtextpos	int
=	O
1	int
;	O
uih	pointer
->	O
complettehandler	pointer
=	O
0	int
;	O
uih	pointer
->	O
ytextpos	int
=	O
1	int
;	O
uih	pointer
->	O
display	int
=	O
0	int
;	O
uih	pointer
->	O
errstring	pointer
=	O
NULL	O
;	O
uih	pointer
->	O
rotatemode	int
=	O
0	int
;	O
uih	pointer
->	O
rotationspeed	double
=	O
10	int
;	O
uih	pointer
->	O
longwait	pointer
=	O
longwait	pointer
;	O
uih	pointer
->	O
passfunc	pointer
=	O
passfunc	pointer
;	O
uih	pointer
->	O
nletters	int
=	O
0	int
;	O
uih	pointer
->	O
letterspersec	int
=	O
15	int
;	O
uih	pointer
->	O
maintimer	pointer
=	O
tl_create_timer	function
(	O
)	O
;	O
uih	pointer
->	O
calculatetimer	pointer
=	O
tl_create_timer	function
(	O
)	O
;	O
uih	pointer
->	O
doittimer	pointer
=	O
tl_create_timer	function
(	O
)	O
;	O
tl_update_time	function
(	O
)	O
;	O
tl_reset_timer	function
(	O
uih	pointer
->	O
maintimer	pointer
)	O
;	O
tl_reset_timer	function
(	O
uih	pointer
->	O
calculatetimer	pointer
)	O
;	O
tl_stop_timer	function
(	O
uih	pointer
->	O
doittimer	pointer
)	O
;	O
tl_reset_timer	function
(	O
uih	pointer
->	O
doittimer	pointer
)	O
;	O
uih_alloctables	function
(	O
uih	pointer
)	O
;	O
uih_initqueue	function
(	O
uih	pointer
)	O
;	O
if	O
(	O
image	struct
->	O
palette	struct
->	O
type	int
&	O
(	O
FIXEDCOLOR	int
|	O
BITMAPS	O
)	O
)	O
uih_fixedcolorenable	function
(	O
uih	pointer
)	O
;	O
uih_mkdefaultpalette	function
(	O
uih	pointer
)	O
;	O
uih_stoptimers	function
(	O
uih	pointer
)	O
;	O
clean_autopilot	function
(	O
uih	pointer
)	O
;	O
uih_newimage	O
(	O
uih	pointer
)	O
;	O
return	O
(	O
uih	pointer
)	O
;	O
}	O
void	O
uih_savepalette	function
(	O
uih_context	struct
*	O
c	pointer
)	O
{	O
if	O
(	O
uih	pointer
->	O
palette2	pointer
!=	O
NULL	O
)	O
destroypalette	function
(	O
uih	pointer
->	O
palette2	pointer
)	O
;	O
if	O
(	O
uih	pointer
->	O
zengine	pointer
->	O
fractalc	pointer
->	O
palette	struct
!=	O
NULL	O
)	O
uih	pointer
->	O
palette2	pointer
=	O
clonepalette	function
(	O
uih	pointer
->	O
zengine	pointer
->	O
fractalc	pointer
->	O
palette	struct
)	O
;	O
}	O
void	O
uih_restorepalette	function
(	O
uih_context	struct
*	O
uih	pointer
)	O
{	O
if	O
(	O
uih	pointer
->	O
palette2	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
uih	pointer
->	O
zengine	pointer
->	O
fractalc	pointer
->	O
palette	struct
!=	O
NULL	O
)	O
restorepalette	function
(	O
uih	pointer
->	O
zengine	pointer
->	O
fractalc	pointer
->	O
palette	struct
,	O
uih	pointer
->	O
palette2	pointer
)	O
;	O
destroypalette	function
(	O
uih	pointer
->	O
palette2	pointer
)	O
;	O
}	O
uih	pointer
->	O
palette2	pointer
=	O
NULL	O
;	O
uih_finishpalette	function
(	O
uih	pointer
)	O
;	O
}	O
void	O
uih_freecontext	function
(	O
uih_context	struct
*	O
c	pointer
)	O
{	O
struct	O
filter	struct
*	O
f	pointer
;	O
while	O
(	O
c	pointer
->	O
queue	pointer
->	O
first	pointer
)	O
{	O
f	pointer
=	O
c	pointer
->	O
queue	pointer
->	O
first	pointer
;	O
removefilter	pointer
(	O
c	pointer
->	O
queue	pointer
->	O
first	pointer
)	O
;	O
f	pointer
->	O
action	pointer
->	O
destroyinstance	pointer
(	O
f	pointer
)	O
;	O
}	O
free	function
(	O
c	pointer
->	O
queue	pointer
)	O
;	O
free_fractalc	function
(	O
c	pointer
->	O
fcontext	pointer
)	O
;	O
free	function
(	O
c	pointer
)	O
;	O
}	O
static	O
struct	O
filter	struct
*	O
uih_getinstance	function
(	O
struct	O
filteraction	struct
*	O
a	pointer
)	O
{	O
struct	O
filter	struct
*	O
f	pointer
=	O
createfilter	function
(	O
a	pointer
)	O
;	O
f	pointer
->	O
data	pointer
=	O
uih	pointer
;	O
f	pointer
->	O
name	pointer
=	O
"XaoS's user interface layer"	pointer
;	O
return	O
(	O
f	pointer
)	O
;	O
}	O
static	O
void	O
uih_destroyinstance	function
(	O
struct	O
filter	struct
*	O
f	pointer
)	O
{	O
struct	O
uih_context	struct
*	O
c	pointer
=	O
f	pointer
->	O
data	pointer
;	O
if	O
(	O
c	pointer
->	O
autopilot	int
)	O
uih_autopilot_off	function
(	O
c	pointer
)	O
;	O
if	O
(	O
c	pointer
->	O
cycling	int
)	O
uih_cycling_off	function
(	O
c	pointer
)	O
;	O
tl_free_timer	function
(	O
uih	pointer
->	O
maintimer	pointer
)	O
;	O
tl_free_timer	function
(	O
uih	pointer
->	O
calculatetimer	pointer
)	O
;	O
tl_free_timer	function
(	O
uih	pointer
->	O
doittimer	pointer
)	O
;	O
if	O
(	O
c	pointer
->	O
displaytext	int
)	O
c	pointer
->	O
displaytext	int
=	O
0	int
,	O
free	function
(	O
c	pointer
->	O
text	pointer
)	O
;	O
if	O
(	O
c	pointer
->	O
save	int
)	O
uih_save_disable	function
(	O
c	pointer
)	O
;	O
if	O
(	O
c	pointer
->	O
play	int
)	O
uih_replaydisable	function
(	O
c	pointer
)	O
;	O
free	function
(	O
f	pointer
)	O
;	O
}	O
static	O
int	O
wascycling	int
=	O
0	int
;	O
static	O
int	O
uih_require	function
(	O
struct	O
filter	struct
*	O
f	pointer
,	O
struct	O
requirements	struct
*	O
r	int
)	O
{	O
struct	O
uih_context	struct
*	O
uih	pointer
;	O
uih	pointer
=	O
f	pointer
->	O
data	pointer
;	O
if	O
(	O
uih	pointer
->	O
cycling	int
)	O
uih_cycling_off	function
(	O
uih	pointer
)	O
,	O
wascycling	int
=	O
1	int
;	O
return	O
(	O
1	int
)	O
;	O
}	O
static	O
int	O
uih_initialize	function
(	O
struct	O
filter	struct
*	O
f	pointer
,	O
struct	O
initdata	struct
*	O
i	pointer
)	O
{	O
struct	O
uih_context	struct
*	O
uih	pointer
;	O
int	O
returnval	int
;	O
uih	pointer
=	O
f	pointer
->	O
data	pointer
;	O
f	pointer
->	O
queue	pointer
->	O
saveimage	pointer
=	O
uih	pointer
->	O
image	struct
;	O
i	pointer
->	O
fractalc	pointer
=	O
uih	pointer
->	O
fcontext	pointer
;	O
tl_update_time	function
(	O
)	O
;	O
f	pointer
->	O
image	struct
=	O
uih	pointer
->	O
image	struct
;	O
f	pointer
->	O
wait_function	pointer
=	O
uih_waitfunc	function
;	O
uih	pointer
->	O
times	array
[	O
0	int
]	O
[	O
0	int
]	O
=	O
-	O
1	int
;	O
i	pointer
->	O
image	struct
=	O
uih	pointer
->	O
image	struct
;	O
f	pointer
->	O
fractalc	pointer
=	O
i	pointer
->	O
fractalc	pointer
;	O
f	pointer
->	O
image	struct
->	O
palette	struct
->	O
flags	int
|=	O
FINISHLATER	int
;	O
i	pointer
->	O
fractalc	pointer
->	O
palette	struct
=	O
uih	pointer
->	O
image	struct
->	O
palette	struct
;	O
i	pointer
->	O
wait_function	pointer
=	O
uih_waitfunc	function
;	O
if	O
(	O
uih	pointer
->	O
ddatalost	int
)	O
i	pointer
->	O
flags	int
|=	O
DATALOST	int
;	O
uih	pointer
->	O
tbreak	int
=	O
2	int
;	O
uih_invalidatepos	function
(	O
uih	pointer
)	O
;	O
clean_autopilot	function
(	O
uih	pointer
)	O
;	O
returnval	int
=	O
f	pointer
->	O
previous	pointer
->	O
action	pointer
->	O
initialize	pointer
(	O
f	pointer
->	O
previous	pointer
,	O
i	pointer
)	O
;	O
if	O
(	O
wascycling	int
)	O
uih_cycling_on	function
(	O
uih	pointer
)	O
,	O
wascycling	int
=	O
0	int
;	O
return	O
returnval	int
;	O
}	O
