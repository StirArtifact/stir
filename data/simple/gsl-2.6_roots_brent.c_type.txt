typedef	O
struct	O
{	O
double	O
a	double
,	O
b	double
,	O
c	double
,	O
d	double
,	O
e	int
;	O
double	O
fa	double
,	O
fb	double
,	O
fc	double
;	O
}	O
brent_state_t	struct
;	O
static	O
int	O
brent_init	function
(	O
void	O
*	O
vstate	pointer
,	O
gsl_function	struct
*	O
f	pointer
,	O
double	O
*	O
root	pointer
,	O
double	O
x_lower	double
,	O
double	O
x_upper	double
)	O
;	O
static	O
int	O
brent_iterate	function
(	O
void	O
*	O
vstate	pointer
,	O
gsl_function	struct
*	O
f	pointer
,	O
double	O
*	O
root	pointer
,	O
double	O
*	O
x_lower	double
,	O
double	O
*	O
x_upper	double
)	O
;	O
static	O
int	O
brent_init	function
(	O
void	O
*	O
vstate	pointer
,	O
gsl_function	struct
*	O
f	pointer
,	O
double	O
*	O
root	pointer
,	O
double	O
x_lower	double
,	O
double	O
x_upper	double
)	O
{	O
brent_state_t	struct
*	O
state	pointer
=	O
(	O
brent_state_t	struct
*	O
)	O
vstate	pointer
;	O
double	O
f_lower	double
,	O
f_upper	double
;	O
*	O
root	pointer
=	O
0.5	int
*	O
(	O
x_lower	double
+	O
x_upper	double
)	O
;	O
SAFE_FUNC_CALL	O
(	O
f	pointer
,	O
x_lower	double
,	O
&	O
f_lower	double
)	O
;	O
SAFE_FUNC_CALL	O
(	O
f	pointer
,	O
x_upper	double
,	O
&	O
f_upper	double
)	O
;	O
state	pointer
->	O
a	double
=	O
x_lower	double
;	O
state	pointer
->	O
fa	double
=	O
f_lower	double
;	O
state	pointer
->	O
b	double
=	O
x_upper	double
;	O
state	pointer
->	O
fb	double
=	O
f_upper	double
;	O
state	pointer
->	O
c	double
=	O
x_upper	double
;	O
state	pointer
->	O
fc	double
=	O
f_upper	double
;	O
state	pointer
->	O
d	double
=	O
x_upper	double
-	O
x_lower	double
;	O
state	pointer
->	O
e	int
=	O
x_upper	double
-	O
x_lower	double
;	O
if	O
(	O
(	O
f_lower	double
<	O
0.0	int
&&	O
f_upper	double
<	O
0.0	int
)	O
||	O
(	O
f_lower	double
>	O
0.0	int
&&	O
f_upper	double
>	O
0.0	int
)	O
)	O
{	O
GSL_ERROR	O
(	O
"endpoints do not straddle y=0"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
brent_iterate	function
(	O
void	O
*	O
vstate	pointer
,	O
gsl_function	struct
*	O
f	pointer
,	O
double	O
*	O
root	pointer
,	O
double	O
*	O
x_lower	double
,	O
double	O
*	O
x_upper	double
)	O
{	O
brent_state_t	struct
*	O
state	pointer
=	O
(	O
brent_state_t	struct
*	O
)	O
vstate	pointer
;	O
double	O
tol	double
,	O
m	double
;	O
int	O
ac_equal	int
=	O
0	int
;	O
double	O
a	double
=	O
state	pointer
->	O
a	double
,	O
b	double
=	O
state	pointer
->	O
b	double
,	O
c	double
=	O
state	pointer
->	O
c	double
;	O
double	O
fa	double
=	O
state	pointer
->	O
fa	double
,	O
fb	double
=	O
state	pointer
->	O
fb	double
,	O
fc	double
=	O
state	pointer
->	O
fc	double
;	O
double	O
d	double
=	O
state	pointer
->	O
d	double
,	O
e	int
=	O
state	pointer
->	O
e	int
;	O
if	O
(	O
(	O
fb	double
<	O
0	int
&&	O
fc	double
<	O
0	int
)	O
||	O
(	O
fb	double
>	O
0	int
&&	O
fc	double
>	O
0	int
)	O
)	O
{	O
ac_equal	int
=	O
1	int
;	O
c	double
=	O
a	double
;	O
fc	double
=	O
fa	double
;	O
d	double
=	O
b	double
-	O
a	double
;	O
e	int
=	O
b	double
-	O
a	double
;	O
}	O
if	O
(	O
fabs	function
(	O
fc	double
)	O
<	O
fabs	function
(	O
fb	double
)	O
)	O
{	O
ac_equal	int
=	O
1	int
;	O
a	double
=	O
b	double
;	O
b	double
=	O
c	double
;	O
c	double
=	O
a	double
;	O
fa	double
=	O
fb	double
;	O
fb	double
=	O
fc	double
;	O
fc	double
=	O
fa	double
;	O
}	O
tol	double
=	O
0.5	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
b	double
)	O
;	O
m	double
=	O
0.5	int
*	O
(	O
c	double
-	O
b	double
)	O
;	O
if	O
(	O
fb	double
==	O
0	int
)	O
{	O
*	O
root	pointer
=	O
b	double
;	O
*	O
x_lower	double
=	O
b	double
;	O
*	O
x_upper	double
=	O
b	double
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
if	O
(	O
fabs	function
(	O
m	double
)	O
<=	O
tol	double
)	O
{	O
*	O
root	pointer
=	O
b	double
;	O
if	O
(	O
b	double
<	O
c	double
)	O
{	O
*	O
x_lower	double
=	O
b	double
;	O
*	O
x_upper	double
=	O
c	double
;	O
}	O
else	O
{	O
*	O
x_lower	double
=	O
c	double
;	O
*	O
x_upper	double
=	O
b	double
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
if	O
(	O
fabs	function
(	O
e	int
)	O
<	O
tol	double
||	O
fabs	function
(	O
fa	double
)	O
<=	O
fabs	function
(	O
fb	double
)	O
)	O
{	O
d	double
=	O
m	double
;	O
e	int
=	O
m	double
;	O
}	O
else	O
{	O
double	O
p	double
,	O
q	double
,	O
r	double
;	O
double	O
s	pointer
=	O
fb	double
/	O
fa	double
;	O
if	O
(	O
ac_equal	int
)	O
{	O
p	double
=	O
2	int
*	O
m	double
*	O
s	pointer
;	O
q	double
=	O
1	int
-	O
s	pointer
;	O
}	O
else	O
{	O
q	double
=	O
fa	double
/	O
fc	double
;	O
r	double
=	O
fb	double
/	O
fc	double
;	O
p	double
=	O
s	pointer
*	O
(	O
2	int
*	O
m	double
*	O
q	double
*	O
(	O
q	double
-	O
r	double
)	O
-	O
(	O
b	double
-	O
a	double
)	O
*	O
(	O
r	double
-	O
1	int
)	O
)	O
;	O
q	double
=	O
(	O
q	double
-	O
1	int
)	O
*	O
(	O
r	double
-	O
1	int
)	O
*	O
(	O
s	pointer
-	O
1	int
)	O
;	O
}	O
if	O
(	O
p	double
>	O
0	int
)	O
{	O
q	double
=	O
-	O
q	double
;	O
}	O
else	O
{	O
p	double
=	O
-	O
p	double
;	O
}	O
if	O
(	O
2	int
*	O
p	double
<	O
GSL_MIN	O
(	O
3	int
*	O
m	double
*	O
q	double
-	O
fabs	function
(	O
tol	double
*	O
q	double
)	O
,	O
fabs	function
(	O
e	int
*	O
q	double
)	O
)	O
)	O
{	O
e	int
=	O
d	double
;	O
d	double
=	O
p	double
/	O
q	double
;	O
}	O
else	O
{	O
d	double
=	O
m	double
;	O
e	int
=	O
m	double
;	O
}	O
}	O
a	double
=	O
b	double
;	O
fa	double
=	O
fb	double
;	O
if	O
(	O
fabs	function
(	O
d	double
)	O
>	O
tol	double
)	O
{	O
b	double
+=	O
d	double
;	O
}	O
else	O
{	O
b	double
+=	O
(	O
m	double
>	O
0	int
?	O
+	O
tol	double
:	O
-	O
tol	double
)	O
;	O
}	O
SAFE_FUNC_CALL	O
(	O
f	pointer
,	O
b	double
,	O
&	O
fb	double
)	O
;	O
state	pointer
->	O
a	double
=	O
a	double
;	O
state	pointer
->	O
b	double
=	O
b	double
;	O
state	pointer
->	O
c	double
=	O
c	double
;	O
state	pointer
->	O
d	double
=	O
d	double
;	O
state	pointer
->	O
e	int
=	O
e	int
;	O
state	pointer
->	O
fa	double
=	O
fa	double
;	O
state	pointer
->	O
fb	double
=	O
fb	double
;	O
state	pointer
->	O
fc	double
=	O
fc	double
;	O
*	O
root	pointer
=	O
b	double
;	O
if	O
(	O
(	O
fb	double
<	O
0	int
&&	O
fc	double
<	O
0	int
)	O
||	O
(	O
fb	double
>	O
0	int
&&	O
fc	double
>	O
0	int
)	O
)	O
{	O
c	double
=	O
a	double
;	O
}	O
if	O
(	O
b	double
<	O
c	double
)	O
{	O
*	O
x_lower	double
=	O
b	double
;	O
*	O
x_upper	double
=	O
c	double
;	O
}	O
else	O
{	O
*	O
x_lower	double
=	O
c	double
;	O
*	O
x_upper	double
=	O
b	double
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
const	O
gsl_root_fsolver_type	struct
brent_type	struct
=	O
{	O
"brent"	pointer
,	O
sizeof	O
(	O
brent_state_t	struct
)	O
,	O
&	O
brent_init	function
,	O
&	O
brent_iterate	function
}	O
;	O
const	O
gsl_root_fsolver_type	struct
*	O
gsl_root_fsolver_brent	pointer
=	O
&	O
brent_type	struct
;	O
