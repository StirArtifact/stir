static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: log.c,v 1.3 2000/06/28 16:47:02 loic Exp $"	pointer
;	O
static	O
int	O
__log_init	function
__P	O
(	O
(	O
DB_ENV	struct
*	O
,	O
DB_LOG	struct
*	O
)	O
)	O
;	O
static	O
int	O
__log_recover	function
__P	O
(	O
(	O
DB_LOG	struct
*	O
)	O
)	O
;	O
int	O
CDB___log_open	function
(	O
dbenv	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
{	O
DB_LOG	struct
*	O
dblp	pointer
;	O
LOG	struct
*	O
lp	pointer
;	O
int	O
ret	int
;	O
u_int8_t	char
*	O
readbufp	pointer
;	O
readbufp	pointer
=	O
NULL	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_calloc	function
(	O
dbenv	pointer
,	O
1	int
,	O
sizeof	O
(	O
DB_LOG	struct
)	O
,	O
&	O
dblp	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_calloc	function
(	O
dbenv	pointer
,	O
1	int
,	O
dbenv	pointer
->	O
lg_bsize	int
,	O
&	O
readbufp	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
ZERO_LSN	O
(	O
dblp	pointer
->	O
c_lsn	struct
)	O
;	O
dblp	pointer
->	O
dbenv	pointer
=	O
dbenv	pointer
;	O
dblp	pointer
->	O
reginfo	pointer
.	O
id	int
=	O
REG_ID_LOG	int
;	O
dblp	pointer
->	O
reginfo	pointer
.	O
mode	enum
=	O
dbenv	pointer
->	O
db_mode	int
;	O
if	O
(	O
F_ISSET	O
(	O
dbenv	pointer
,	O
DB_ENV_CREATE	int
)	O
)	O
F_SET	O
(	O
&	O
dblp	pointer
->	O
reginfo	pointer
,	O
REGION_CREATE_OK	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_r_attach	function
(	O
dbenv	pointer
,	O
&	O
dblp	pointer
->	O
reginfo	pointer
,	O
LG_BASE_REGION_SIZE	O
+	O
dbenv	pointer
->	O
lg_bsize	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
dblp	pointer
->	O
readbufp	pointer
=	O
readbufp	pointer
;	O
if	O
(	O
F_ISSET	O
(	O
&	O
dblp	pointer
->	O
reginfo	pointer
,	O
REGION_CREATE	int
)	O
&&	O
(	O
ret	int
=	O
__log_init	function
(	O
dbenv	pointer
,	O
dblp	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
lp	pointer
=	O
dblp	pointer
->	O
reginfo	pointer
.	O
primary	int
=	O
R_ADDR	O
(	O
&	O
dblp	pointer
->	O
reginfo	pointer
,	O
dblp	pointer
->	O
reginfo	pointer
.	O
rp	pointer
->	O
primary	int
)	O
;	O
dblp	pointer
->	O
bufp	pointer
=	O
R_ADDR	O
(	O
&	O
dblp	pointer
->	O
reginfo	pointer
,	O
lp	pointer
->	O
buffer_off	int
)	O
;	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
&	O
dblp	pointer
->	O
reginfo	pointer
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
dbenv	pointer
,	O
DB_ENV_THREAD	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_mutex_alloc	function
(	O
dbenv	pointer
,	O
&	O
dblp	pointer
->	O
reginfo	pointer
,	O
&	O
dblp	pointer
->	O
mutexp	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
detach	O
;	O
if	O
(	O
(	O
ret	int
=	O
__db_mutex_init	O
(	O
dbenv	pointer
,	O
dblp	pointer
->	O
mutexp	pointer
,	O
0	int
,	O
MUTEX_THREAD	int
)	O
)	O
!=	O
0	int
)	O
goto	O
detach	O
;	O
}	O
dblp	pointer
->	O
r_file	int
=	O
0	int
;	O
dblp	pointer
->	O
r_off	int
=	O
0	int
;	O
dblp	pointer
->	O
r_size	int
=	O
0	int
;	O
dbenv	pointer
->	O
lg_handle	pointer
=	O
dblp	pointer
;	O
return	O
(	O
0	int
)	O
;	O
err	pointer
:	O
if	O
(	O
dblp	pointer
->	O
reginfo	pointer
.	O
addr	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
F_ISSET	O
(	O
&	O
dblp	pointer
->	O
reginfo	pointer
,	O
REGION_CREATE	int
)	O
)	O
F_SET	O
(	O
dblp	pointer
->	O
reginfo	pointer
.	O
rp	pointer
,	O
REG_DEAD	int
)	O
;	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
&	O
dblp	pointer
->	O
reginfo	pointer
)	O
;	O
detach	O
:	O
(	O
void	O
)	O
CDB___db_r_detach	function
(	O
dbenv	pointer
,	O
&	O
dblp	pointer
->	O
reginfo	pointer
,	O
0	int
)	O
;	O
}	O
if	O
(	O
readbufp	pointer
!=	O
NULL	O
)	O
CDB___os_free	function
(	O
readbufp	pointer
,	O
sizeof	O
(	O
dbenv	pointer
->	O
lg_bsize	int
)	O
)	O
;	O
CDB___os_free	function
(	O
dblp	pointer
,	O
sizeof	O
(	O
*	O
dblp	pointer
)	O
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__log_init	function
(	O
dbenv	pointer
,	O
dblp	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_LOG	struct
*	O
dblp	pointer
;	O
{	O
LOG	struct
*	O
region	pointer
;	O
int	O
ret	int
;	O
void	O
*	O
p	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_shalloc	function
(	O
dblp	pointer
->	O
reginfo	pointer
.	O
addr	pointer
,	O
sizeof	O
(	O
*	O
region	pointer
)	O
,	O
0	int
,	O
&	O
dblp	pointer
->	O
reginfo	pointer
.	O
primary	int
)	O
)	O
!=	O
0	int
)	O
goto	O
mem_err	O
;	O
dblp	pointer
->	O
reginfo	pointer
.	O
rp	pointer
->	O
primary	int
=	O
R_OFFSET	O
(	O
&	O
dblp	pointer
->	O
reginfo	pointer
,	O
dblp	pointer
->	O
reginfo	pointer
.	O
primary	int
)	O
;	O
region	pointer
=	O
dblp	pointer
->	O
reginfo	pointer
.	O
primary	int
;	O
memset	function
(	O
region	pointer
,	O
0	int
,	O
sizeof	O
(	O
*	O
region	pointer
)	O
)	O
;	O
region	pointer
->	O
persist	struct
.	O
lg_max	int
=	O
dbenv	pointer
->	O
lg_max	int
;	O
region	pointer
->	O
persist	struct
.	O
magic	int
=	O
DB_LOGMAGIC	int
;	O
region	pointer
->	O
persist	struct
.	O
version	int
=	O
DB_LOGVERSION	int
;	O
region	pointer
->	O
persist	struct
.	O
mode	enum
=	O
dbenv	pointer
->	O
db_mode	int
;	O
SH_TAILQ_INIT	O
(	O
&	O
region	pointer
->	O
fq	struct
)	O
;	O
region	pointer
->	O
lsn	struct
.	O
file	int
=	O
1	int
;	O
region	pointer
->	O
lsn	struct
.	O
offset	int
=	O
0	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_shalloc	function
(	O
dblp	pointer
->	O
reginfo	pointer
.	O
addr	pointer
,	O
dbenv	pointer
->	O
lg_bsize	int
,	O
0	int
,	O
&	O
p	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
mem_err	O
:	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"Unable to allocate memory for the log buffer"	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
region	pointer
->	O
buffer_size	int
=	O
dbenv	pointer
->	O
lg_bsize	int
;	O
region	pointer
->	O
buffer_off	int
=	O
R_OFFSET	O
(	O
&	O
dblp	pointer
->	O
reginfo	pointer
,	O
p	pointer
)	O
;	O
dblp	pointer
->	O
lfh	struct
.	O
log_size	int
=	O
dbenv	pointer
->	O
lg_max	int
;	O
return	O
(	O
__log_recover	function
(	O
dblp	pointer
)	O
)	O
;	O
}	O
static	O
int	O
__log_recover	function
(	O
dblp	pointer
)	O
DB_LOG	struct
*	O
dblp	pointer
;	O
{	O
DBT	struct
dbt	struct
;	O
DB_LSN	struct
lsn	struct
;	O
LOG	struct
*	O
lp	pointer
;	O
u_int32_t	int
chk	int
;	O
int	O
cnt	int
,	O
found_checkpoint	int
,	O
ret	int
;	O
lp	pointer
=	O
dblp	pointer
->	O
reginfo	pointer
.	O
primary	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___log_find	function
(	O
dblp	pointer
,	O
0	int
,	O
&	O
cnt	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
cnt	int
==	O
0	int
)	O
return	O
(	O
0	int
)	O
;	O
lp	pointer
->	O
lsn	struct
.	O
file	int
=	O
cnt	int
+	O
1	int
;	O
lp	pointer
->	O
lsn	struct
.	O
offset	int
=	O
0	int
;	O
lsn	struct
.	O
file	int
=	O
cnt	int
;	O
lsn	struct
.	O
offset	int
=	O
0	int
;	O
memset	function
(	O
&	O
dbt	struct
,	O
0	int
,	O
sizeof	O
(	O
dbt	struct
)	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___log_get	function
(	O
dblp	pointer
,	O
&	O
lsn	struct
,	O
&	O
dbt	struct
,	O
DB_SET	int
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
found_checkpoint	int
=	O
0	int
;	O
while	O
(	O
CDB___log_get	function
(	O
dblp	pointer
,	O
&	O
lsn	struct
,	O
&	O
dbt	struct
,	O
DB_NEXT	int
,	O
1	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
dbt	struct
.	O
size	int
<	O
sizeof	O
(	O
u_int32_t	int
)	O
)	O
continue	O
;	O
memcpy	function
(	O
&	O
chk	int
,	O
dbt	struct
.	O
data	pointer
,	O
sizeof	O
(	O
u_int32_t	int
)	O
)	O
;	O
if	O
(	O
chk	int
==	O
DB_txn_ckp	int
)	O
{	O
lp	pointer
->	O
chkpt_lsn	struct
=	O
lsn	struct
;	O
found_checkpoint	int
=	O
1	int
;	O
}	O
}	O
lp	pointer
->	O
lsn	struct
=	O
lp	pointer
->	O
s_lsn	struct
=	O
lsn	struct
;	O
lp	pointer
->	O
lsn	struct
.	O
offset	int
+=	O
dblp	pointer
->	O
c_len	int
;	O
lp	pointer
->	O
len	int
=	O
dblp	pointer
->	O
c_len	int
;	O
lp	pointer
->	O
b_off	long
=	O
0	int
;	O
lp	pointer
->	O
w_off	int
=	O
lp	pointer
->	O
lsn	struct
.	O
offset	int
;	O
if	O
(	O
!	O
found_checkpoint	int
&&	O
cnt	int
>	O
1	int
)	O
{	O
lsn	struct
.	O
file	int
=	O
cnt	int
;	O
lsn	struct
.	O
offset	int
=	O
0	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___log_get	function
(	O
dblp	pointer
,	O
&	O
lsn	struct
,	O
&	O
dbt	struct
,	O
DB_SET	int
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
while	O
(	O
CDB___log_get	function
(	O
dblp	pointer
,	O
&	O
lsn	struct
,	O
&	O
dbt	struct
,	O
DB_PREV	int
,	O
1	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
dbt	struct
.	O
size	int
<	O
sizeof	O
(	O
u_int32_t	int
)	O
)	O
continue	O
;	O
memcpy	function
(	O
&	O
chk	int
,	O
dbt	struct
.	O
data	pointer
,	O
sizeof	O
(	O
u_int32_t	int
)	O
)	O
;	O
if	O
(	O
chk	int
==	O
DB_txn_ckp	int
)	O
{	O
lp	pointer
->	O
chkpt_lsn	struct
=	O
lsn	struct
;	O
found_checkpoint	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
found_checkpoint	int
)	O
ZERO_LSN	O
(	O
lp	pointer
->	O
chkpt_lsn	struct
)	O
;	O
ZERO_LSN	O
(	O
dblp	pointer
->	O
c_lsn	struct
)	O
;	O
if	O
(	O
FLD_ISSET	O
(	O
dblp	pointer
->	O
dbenv	pointer
->	O
verbose	int
,	O
DB_VERB_RECOVERY	int
)	O
)	O
CDB___db_err	function
(	O
dblp	pointer
->	O
dbenv	pointer
,	O
"Finding last valid log LSN: file: %lu offset %lu"	pointer
,	O
(	O
u_long	long
)	O
lp	pointer
->	O
lsn	struct
.	O
file	int
,	O
(	O
u_long	long
)	O
lp	pointer
->	O
lsn	struct
.	O
offset	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___log_find	function
(	O
dblp	pointer
,	O
find_first	int
,	O
valp	pointer
)	O
DB_LOG	struct
*	O
dblp	pointer
;	O
int	O
find_first	int
,	O
*	O
valp	pointer
;	O
{	O
u_int32_t	int
clv	int
,	O
logval	int
;	O
int	O
cnt	int
,	O
fcnt	int
,	O
ret	int
;	O
const	O
char	O
*	O
dir	pointer
;	O
char	O
*	O
*	O
names	pointer
,	O
*	O
p	pointer
,	O
*	O
q	struct
;	O
*	O
valp	pointer
=	O
0	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___log_name	function
(	O
dblp	pointer
,	O
1	int
,	O
&	O
p	pointer
,	O
NULL	O
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
q	struct
=	O
CDB___db_rpath	function
(	O
p	pointer
)	O
)	O
==	O
NULL	O
)	O
dir	pointer
=	O
PATH_DOT	pointer
;	O
else	O
{	O
*	O
q	struct
=	O
'\0'	O
;	O
dir	pointer
=	O
p	pointer
;	O
}	O
ret	int
=	O
CDB___os_dirlist	function
(	O
dblp	pointer
->	O
dbenv	pointer
,	O
dir	pointer
,	O
&	O
names	pointer
,	O
&	O
fcnt	int
)	O
;	O
if	O
(	O
q	struct
!=	O
NULL	O
)	O
*	O
q	struct
=	O
'a'	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dblp	pointer
->	O
dbenv	pointer
,	O
"%s: %s"	pointer
,	O
dir	pointer
,	O
CDB_db_strerror	function
(	O
ret	int
)	O
)	O
;	O
CDB___os_freestr	function
(	O
p	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
for	O
(	O
cnt	int
=	O
fcnt	int
,	O
clv	int
=	O
logval	int
=	O
0	int
;	O
--	O
cnt	int
>=	O
0	int
;	O
)	O
{	O
if	O
(	O
strncmp	function
(	O
names	pointer
[	O
cnt	int
]	O
,	O
LFPREFIX	pointer
,	O
sizeof	O
(	O
LFPREFIX	pointer
)	O
-	O
1	int
)	O
!=	O
0	int
)	O
continue	O
;	O
clv	int
=	O
atoi	function
(	O
names	pointer
[	O
cnt	int
]	O
+	O
(	O
sizeof	O
(	O
LFPREFIX	pointer
)	O
-	O
1	int
)	O
)	O
;	O
if	O
(	O
find_first	int
)	O
{	O
if	O
(	O
logval	int
!=	O
0	int
&&	O
clv	int
>	O
logval	int
)	O
continue	O
;	O
}	O
else	O
if	O
(	O
logval	int
!=	O
0	int
&&	O
clv	int
<	O
logval	int
)	O
continue	O
;	O
if	O
(	O
CDB___log_valid	function
(	O
dblp	pointer
,	O
clv	int
,	O
1	int
)	O
==	O
0	int
)	O
logval	int
=	O
clv	int
;	O
}	O
*	O
valp	pointer
=	O
logval	int
;	O
CDB___os_dirfree	function
(	O
names	pointer
,	O
fcnt	int
)	O
;	O
CDB___os_freestr	function
(	O
p	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___log_valid	function
(	O
dblp	pointer
,	O
number	int
,	O
set_persist	int
)	O
DB_LOG	struct
*	O
dblp	pointer
;	O
u_int32_t	int
number	int
;	O
int	O
set_persist	int
;	O
{	O
DB_FH	struct
fh	struct
;	O
LOG	struct
*	O
region	pointer
;	O
LOGP	struct
persist	struct
;	O
size_t	long
nw	long
;	O
int	O
ret	int
;	O
char	O
*	O
fname	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___log_name	function
(	O
dblp	pointer
,	O
number	int
,	O
&	O
fname	pointer
,	O
&	O
fh	struct
,	O
DB_OSO_RDONLY	int
|	O
DB_OSO_SEQ	int
)	O
)	O
!=	O
0	int
)	O
{	O
CDB___os_freestr	function
(	O
fname	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_seek	function
(	O
dblp	pointer
->	O
dbenv	pointer
,	O
&	O
fh	struct
,	O
0	int
,	O
0	int
,	O
sizeof	O
(	O
HDR	struct
)	O
,	O
0	int
,	O
DB_OS_SEEK_SET	int
)	O
)	O
!=	O
0	int
||	O
(	O
ret	int
=	O
CDB___os_read	function
(	O
dblp	pointer
->	O
dbenv	pointer
,	O
&	O
fh	struct
,	O
&	O
persist	struct
,	O
sizeof	O
(	O
LOGP	struct
)	O
,	O
&	O
nw	long
)	O
)	O
!=	O
0	int
||	O
nw	long
!=	O
sizeof	O
(	O
LOGP	struct
)	O
)	O
{	O
if	O
(	O
ret	int
==	O
0	int
)	O
ret	int
=	O
EIO	int
;	O
(	O
void	O
)	O
CDB___os_closehandle	function
(	O
&	O
fh	struct
)	O
;	O
CDB___db_err	function
(	O
dblp	pointer
->	O
dbenv	pointer
,	O
"Ignoring log file: %s: %s"	pointer
,	O
fname	pointer
,	O
CDB_db_strerror	function
(	O
ret	int
)	O
)	O
;	O
goto	O
err	pointer
;	O
}	O
(	O
void	O
)	O
CDB___os_closehandle	function
(	O
&	O
fh	struct
)	O
;	O
if	O
(	O
persist	struct
.	O
magic	int
!=	O
DB_LOGMAGIC	int
)	O
{	O
CDB___db_err	function
(	O
dblp	pointer
->	O
dbenv	pointer
,	O
"Ignoring log file: %s: magic number %lx, not %lx"	pointer
,	O
fname	pointer
,	O
(	O
u_long	long
)	O
persist	struct
.	O
magic	int
,	O
(	O
u_long	long
)	O
DB_LOGMAGIC	int
)	O
;	O
ret	int
=	O
EINVAL	int
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
persist	struct
.	O
version	int
<	O
DB_LOGOLDVER	int
||	O
persist	struct
.	O
version	int
>	O
DB_LOGVERSION	int
)	O
{	O
CDB___db_err	function
(	O
dblp	pointer
->	O
dbenv	pointer
,	O
"Ignoring log file: %s: unsupported log version %lu"	pointer
,	O
fname	pointer
,	O
(	O
u_long	long
)	O
persist	struct
.	O
version	int
)	O
;	O
ret	int
=	O
EINVAL	int
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
set_persist	int
)	O
{	O
region	pointer
=	O
dblp	pointer
->	O
reginfo	pointer
.	O
primary	int
;	O
region	pointer
->	O
persist	struct
.	O
lg_max	int
=	O
persist	struct
.	O
lg_max	int
;	O
region	pointer
->	O
persist	struct
.	O
mode	enum
=	O
persist	struct
.	O
mode	enum
;	O
}	O
ret	int
=	O
0	int
;	O
err	pointer
:	O
CDB___os_freestr	function
(	O
fname	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___log_close	function
(	O
dbenv	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
{	O
DB_LOG	struct
*	O
dblp	pointer
;	O
int	O
ret	int
,	O
t_ret	int
;	O
ret	int
=	O
0	int
;	O
dblp	pointer
=	O
dbenv	pointer
->	O
lg_handle	pointer
;	O
F_SET	O
(	O
dblp	pointer
,	O
DBLOG_RECOVER	int
)	O
;	O
CDB___log_close_files	function
(	O
dbenv	pointer
)	O
;	O
if	O
(	O
dblp	pointer
->	O
mutexp	pointer
!=	O
NULL	O
)	O
CDB___db_mutex_free	function
(	O
dbenv	pointer
,	O
&	O
dblp	pointer
->	O
reginfo	pointer
,	O
dblp	pointer
->	O
mutexp	pointer
)	O
;	O
ret	int
=	O
CDB___db_r_detach	function
(	O
dbenv	pointer
,	O
&	O
dblp	pointer
->	O
reginfo	pointer
,	O
0	int
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
&	O
dblp	pointer
->	O
lfh	struct
,	O
DB_FH_VALID	int
)	O
&&	O
(	O
t_ret	int
=	O
CDB___os_closehandle	function
(	O
&	O
dblp	pointer
->	O
lfh	struct
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
dblp	pointer
->	O
c_dbt	struct
.	O
data	pointer
!=	O
NULL	O
)	O
CDB___os_free	function
(	O
dblp	pointer
->	O
c_dbt	struct
.	O
data	pointer
,	O
dblp	pointer
->	O
c_dbt	struct
.	O
ulen	int
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
&	O
dblp	pointer
->	O
c_fh	struct
,	O
DB_FH_VALID	int
)	O
&&	O
(	O
t_ret	int
=	O
CDB___os_closehandle	function
(	O
&	O
dblp	pointer
->	O
c_fh	struct
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
dblp	pointer
->	O
dbentry	pointer
!=	O
NULL	O
)	O
CDB___os_free	function
(	O
dblp	pointer
->	O
dbentry	pointer
,	O
(	O
dblp	pointer
->	O
dbentry_cnt	int
*	O
sizeof	O
(	O
DB_ENTRY	struct
)	O
)	O
)	O
;	O
if	O
(	O
dblp	pointer
->	O
readbufp	pointer
!=	O
NULL	O
)	O
CDB___os_free	function
(	O
dblp	pointer
->	O
readbufp	pointer
,	O
dbenv	pointer
->	O
lg_bsize	int
)	O
;	O
CDB___os_free	function
(	O
dblp	pointer
,	O
sizeof	O
(	O
*	O
dblp	pointer
)	O
)	O
;	O
dbenv	pointer
->	O
lg_handle	pointer
=	O
NULL	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB_log_stat	function
(	O
dbenv	pointer
,	O
statp	pointer
,	O
db_malloc	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_LOG_STAT	struct
*	O
*	O
statp	pointer
;	O
void	O
*	O
(	O
*	O
db_malloc	pointer
)	O
__P	O
(	O
(	O
size_t	long
)	O
)	O
;	O
{	O
DB_LOG	struct
*	O
dblp	pointer
;	O
DB_LOG_STAT	struct
*	O
stats	pointer
;	O
LOG	struct
*	O
region	pointer
;	O
int	O
ret	int
;	O
PANIC_CHECK	O
(	O
dbenv	pointer
)	O
;	O
ENV_REQUIRES_CONFIG	O
(	O
dbenv	pointer
,	O
dbenv	pointer
->	O
lg_handle	pointer
,	O
DB_INIT_LOG	int
)	O
;	O
*	O
statp	pointer
=	O
NULL	O
;	O
dblp	pointer
=	O
dbenv	pointer
->	O
lg_handle	pointer
;	O
region	pointer
=	O
dblp	pointer
->	O
reginfo	pointer
.	O
primary	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbenv	pointer
,	O
sizeof	O
(	O
DB_LOG_STAT	struct
)	O
,	O
db_malloc	pointer
,	O
&	O
stats	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
R_LOCK	O
(	O
dbenv	pointer
,	O
&	O
dblp	pointer
->	O
reginfo	pointer
)	O
;	O
*	O
stats	pointer
=	O
region	pointer
->	O
stat	pointer
;	O
stats	pointer
->	O
st_magic	int
=	O
region	pointer
->	O
persist	struct
.	O
magic	int
;	O
stats	pointer
->	O
st_version	int
=	O
region	pointer
->	O
persist	struct
.	O
version	int
;	O
stats	pointer
->	O
st_mode	int
=	O
region	pointer
->	O
persist	struct
.	O
mode	enum
;	O
stats	pointer
->	O
st_lg_bsize	int
=	O
region	pointer
->	O
buffer_size	int
;	O
stats	pointer
->	O
st_lg_max	int
=	O
region	pointer
->	O
persist	struct
.	O
lg_max	int
;	O
stats	pointer
->	O
st_region_wait	int
=	O
dblp	pointer
->	O
reginfo	pointer
.	O
rp	pointer
->	O
mutex	union
.	O
mutex_set_wait	int
;	O
stats	pointer
->	O
st_region_nowait	int
=	O
dblp	pointer
->	O
reginfo	pointer
.	O
rp	pointer
->	O
mutex	union
.	O
mutex_set_nowait	int
;	O
stats	pointer
->	O
st_regsize	int
=	O
dblp	pointer
->	O
reginfo	pointer
.	O
rp	pointer
->	O
size	int
;	O
stats	pointer
->	O
st_cur_file	int
=	O
region	pointer
->	O
lsn	struct
.	O
file	int
;	O
stats	pointer
->	O
st_cur_offset	int
=	O
region	pointer
->	O
lsn	struct
.	O
offset	int
;	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
&	O
dblp	pointer
->	O
reginfo	pointer
)	O
;	O
*	O
statp	pointer
=	O
stats	pointer
;	O
return	O
(	O
0	int
)	O
;	O
}	O
