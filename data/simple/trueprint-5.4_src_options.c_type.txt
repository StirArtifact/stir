extern	O
int	O
optind	int
;	O
typedef	O
enum	O
{	O
NOPARM	int
,	O
OPTIONAL	int
,	O
BOOLEAN	int
,	O
CHAR	int
,	O
CHOICE	int
,	O
SHORT	int
,	O
INT	int
,	O
STRING	int
,	O
FLAG_STRING	int
}	O
option_types	enum
;	O
typedef	O
struct	O
option_type	struct
{	O
char	O
letter	char
;	O
option_types	enum
type	enum
;	O
boolean	enum
set	enum
;	O
char	O
need_string	char
;	O
option_class	enum
class	enum
;	O
union	O
{	O
struct	O
{	O
char	O
*	O
string	pointer
;	O
boolean	enum
default_opt	enum
;	O
void	O
(	O
*	O
handler	pointer
)	O
(	O
const	O
char	O
*	O
p	pointer
,	O
const	O
char	O
*	O
s	pointer
)	O
;	O
void	O
(	O
*	O
set_default	pointer
)	O
(	O
void	O
)	O
;	O
char	O
*	O
help_string	pointer
;	O
}	O
onoparm	struct
;	O
struct	O
{	O
char	O
*	O
string	pointer
;	O
void	O
(	O
*	O
handler	pointer
)	O
(	O
const	O
char	O
*	O
p	pointer
,	O
const	O
char	O
*	O
s	pointer
,	O
char	O
*	O
value	pointer
)	O
;	O
char	O
*	O
help_string	pointer
;	O
}	O
ooptional	struct
;	O
struct	O
{	O
char	O
*	O
true_string	pointer
;	O
char	O
*	O
false_string	pointer
;	O
boolean	enum
*	O
var	pointer
;	O
boolean	enum
default_value	enum
;	O
void	O
(	O
*	O
handler	pointer
)	O
(	O
const	O
char	O
*	O
p	pointer
,	O
const	O
char	O
*	O
s	pointer
,	O
boolean	enum
value	pointer
)	O
;	O
void	O
(	O
*	O
set_default	pointer
)	O
(	O
boolean	enum
value	pointer
)	O
;	O
char	O
*	O
true_help_string	pointer
;	O
char	O
*	O
false_help_string	pointer
;	O
}	O
obool	struct
;	O
struct	O
{	O
char	O
*	O
string	pointer
;	O
char	O
*	O
var	pointer
;	O
char	O
default_value	enum
;	O
char	O
*	O
valid_set	pointer
;	O
void	O
(	O
*	O
handler	pointer
)	O
(	O
const	O
char	O
*	O
p	pointer
,	O
const	O
char	O
*	O
s	pointer
,	O
char	O
value	pointer
,	O
char	O
*	O
valid_set	pointer
)	O
;	O
void	O
(	O
*	O
set_default	pointer
)	O
(	O
char	O
value	pointer
)	O
;	O
char	O
*	O
help_string	pointer
;	O
}	O
ochar	struct
;	O
struct	O
{	O
char	O
*	O
var	pointer
;	O
char	O
*	O
choice1_string	pointer
;	O
char	O
*	O
choice2_string	pointer
;	O
char	O
choice1	char
;	O
char	O
choice2	char
;	O
void	O
(	O
*	O
handler	pointer
)	O
(	O
const	O
char	O
*	O
p	pointer
,	O
const	O
char	O
*	O
s	pointer
,	O
char	O
value	pointer
)	O
;	O
void	O
(	O
*	O
set_default	pointer
)	O
(	O
char	O
value	pointer
)	O
;	O
char	O
*	O
choice1_help_string	pointer
;	O
char	O
*	O
choice2_help_string	pointer
;	O
}	O
ochoice	struct
;	O
struct	O
{	O
char	O
*	O
string	pointer
;	O
short	O
*	O
var	pointer
;	O
short	O
default_value	enum
;	O
char	O
*	O
special_string	pointer
;	O
short	O
special_value	short
;	O
short	O
min	short
;	O
short	O
max	short
;	O
void	O
(	O
*	O
handler	pointer
)	O
(	O
const	O
char	O
*	O
p	pointer
,	O
const	O
char	O
*	O
s	pointer
,	O
short	O
value	pointer
,	O
short	O
min	short
,	O
short	O
max	short
)	O
;	O
void	O
(	O
*	O
set_default	pointer
)	O
(	O
short	O
value	pointer
)	O
;	O
char	O
*	O
help_string	pointer
;	O
char	O
*	O
special_help_string	pointer
;	O
}	O
oshrt	struct
;	O
struct	O
{	O
char	O
*	O
string	pointer
;	O
int	O
*	O
var	pointer
;	O
int	O
default_value	enum
;	O
char	O
*	O
special_string	pointer
;	O
short	O
special_value	short
;	O
int	O
min	short
;	O
int	O
max	short
;	O
void	O
(	O
*	O
handler	pointer
)	O
(	O
const	O
char	O
*	O
p	pointer
,	O
const	O
char	O
*	O
s	pointer
,	O
int	O
value	pointer
,	O
int	O
min	short
,	O
int	O
max	short
)	O
;	O
void	O
(	O
*	O
set_default	pointer
)	O
(	O
int	O
value	pointer
)	O
;	O
char	O
*	O
help_string	pointer
;	O
char	O
*	O
special_help_string	pointer
;	O
}	O
oint	struct
;	O
struct	O
{	O
char	O
*	O
string	pointer
;	O
char	O
*	O
*	O
var	pointer
;	O
char	O
*	O
default_value	enum
;	O
void	O
(	O
*	O
handler	pointer
)	O
(	O
const	O
char	O
*	O
p	pointer
,	O
const	O
char	O
*	O
s	pointer
,	O
char	O
*	O
value	pointer
)	O
;	O
void	O
(	O
*	O
set_default	pointer
)	O
(	O
char	O
*	O
value	pointer
)	O
;	O
char	O
*	O
help_string	pointer
;	O
}	O
ostrng	struct
;	O
struct	O
{	O
char	O
*	O
set_string	pointer
;	O
char	O
*	O
not_set_string	pointer
;	O
boolean	enum
flag_var	enum
;	O
char	O
*	O
*	O
var	pointer
;	O
boolean	enum
default_value	enum
;	O
char	O
*	O
true_value	pointer
;	O
char	O
*	O
false_value	pointer
;	O
void	O
(	O
*	O
handler	pointer
)	O
(	O
const	O
char	O
*	O
p	pointer
,	O
const	O
char	O
*	O
s	pointer
,	O
boolean	enum
value	pointer
,	O
char	O
*	O
true_value	pointer
,	O
char	O
*	O
false_value	pointer
)	O
;	O
void	O
(	O
*	O
set_default	pointer
)	O
(	O
boolean	enum
value	pointer
,	O
char	O
*	O
string_value	pointer
)	O
;	O
char	O
*	O
set_help_string	pointer
;	O
char	O
*	O
not_set_help_string	pointer
;	O
}	O
oflg	struct
;	O
}	O
t	union
;	O
}	O
option_type	struct
;	O
static	O
void	O
set_option	function
(	O
int	O
option	struct
,	O
char	O
*	O
prefix	pointer
,	O
const	O
char	O
*	O
option_name	pointer
,	O
char	O
*	O
value	pointer
)	O
;	O
static	O
void	O
set_option_default	function
(	O
int	O
option	struct
)	O
;	O
static	O
int	O
short_options	array
[	O
62	int
]	O
;	O
static	O
struct	O
option_type	struct
option_list	array
[	O
MAX_OPTIONS	int
+	O
1	int
]	O
;	O
static	O
struct	O
option	struct
long_options	array
[	O
MAX_OPTIONS	int
+	O
1	int
]	O
;	O
static	O
int	O
next_option	int
;	O
static	O
int	O
next_long_option	int
;	O
static	O
int	O
this_option	int
;	O
void	O
setup_options	function
(	O
void	O
)	O
{	O
next_option	int
=	O
0	int
;	O
next_long_option	int
=	O
0	int
;	O
}	O
void	O
handle_string_options	function
(	O
char	O
*	O
options	pointer
)	O
{	O
int	O
opt_argc	int
=	O
-	O
1	int
;	O
char	O
arguments	array
[	O
100	int
]	O
[	O
100	int
]	O
;	O
char	O
*	O
opt_argv	array
[	O
100	int
]	O
;	O
int	O
options_index	int
=	O
-	O
1	int
;	O
int	O
argv_index	int
=	O
0	int
;	O
boolean	enum
quoted	enum
=	O
FALSE	int
;	O
boolean	enum
ended	enum
=	O
FALSE	int
;	O
if	O
(	O
options	pointer
==	O
(	O
char	O
*	O
)	O
0	int
)	O
return	O
;	O
if	O
(	O
strlen	function
(	O
options	pointer
)	O
==	O
0	int
)	O
return	O
;	O
while	O
(	O
ended	enum
==	O
FALSE	int
)	O
{	O
switch	O
(	O
options	pointer
[	O
++	O
options_index	int
]	O
)	O
{	O
case	O
' '	O
:	O
case	O
'	'	O
:	O
if	O
(	O
quoted	enum
)	O
{	O
if	O
(	O
argv_index	int
==	O
0	int
)	O
opt_argc	int
+=	O
1	int
;	O
arguments	array
[	O
opt_argc	int
]	O
[	O
argv_index	int
++	O
]	O
=	O
options	pointer
[	O
options_index	int
]	O
;	O
continue	O
;	O
}	O
if	O
(	O
argv_index	int
>	O
0	int
)	O
{	O
arguments	array
[	O
opt_argc	int
]	O
[	O
argv_index	int
]	O
=	O
'\0'	O
;	O
argv_index	int
=	O
0	int
;	O
}	O
break	O
;	O
case	O
'\0'	O
:	O
if	O
(	O
argv_index	int
>	O
0	int
)	O
{	O
arguments	array
[	O
opt_argc	int
]	O
[	O
argv_index	int
]	O
=	O
'\0'	O
;	O
argv_index	int
=	O
0	int
;	O
}	O
ended	enum
=	O
TRUE	int
;	O
break	O
;	O
case	O
'"'	O
:	O
if	O
(	O
quoted	enum
)	O
quoted	enum
=	O
FALSE	int
;	O
else	O
quoted	enum
=	O
TRUE	int
;	O
break	O
;	O
default	O
:	O
if	O
(	O
argv_index	int
==	O
0	int
)	O
opt_argc	int
+=	O
1	int
;	O
arguments	array
[	O
opt_argc	int
]	O
[	O
argv_index	int
++	O
]	O
=	O
options	pointer
[	O
options_index	int
]	O
;	O
break	O
;	O
}	O
}	O
opt_argc	int
+=	O
1	int
;	O
for	O
(	O
argv_index	int
=	O
0	int
;	O
argv_index	int
<	O
opt_argc	int
;	O
argv_index	int
++	O
)	O
opt_argv	array
[	O
argv_index	int
+	O
1	int
]	O
=	O
arguments	array
[	O
argv_index	int
]	O
;	O
opt_argv	array
[	O
0	int
]	O
=	O
opt_argv	array
[	O
1	int
]	O
;	O
opt_argc	int
+=	O
1	int
;	O
handle_options	function
(	O
opt_argc	int
,	O
opt_argv	array
)	O
;	O
return	O
;	O
}	O
unsigned	O
int	O
handle_options	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
option	struct
;	O
int	O
option_index	int
;	O
int	O
short_option_index	int
=	O
0	int
;	O
int	O
long_option_index	int
;	O
char	O
short_option_list	array
[	O
125	int
]	O
;	O
optind	int
=	O
1	int
;	O
for	O
(	O
option_index	int
=	O
0	int
;	O
option_index	int
<	O
next_long_option	int
;	O
option_index	int
++	O
)	O
{	O
if	O
(	O
option_list	array
[	O
option_index	int
]	O
.	O
letter	char
)	O
{	O
short_option_list	array
[	O
short_option_index	int
++	O
]	O
=	O
option_list	array
[	O
option_index	int
]	O
.	O
letter	char
;	O
if	O
(	O
option_list	array
[	O
option_index	int
]	O
.	O
need_string	char
)	O
short_option_list	array
[	O
short_option_index	int
++	O
]	O
=	O
':'	O
;	O
}	O
}	O
long_options	array
[	O
next_long_option	int
]	O
.	O
name	pointer
=	O
0	int
;	O
long_options	array
[	O
next_long_option	int
]	O
.	O
has_arg	int
=	O
0	int
;	O
long_options	array
[	O
next_long_option	int
]	O
.	O
flag	pointer
=	O
0	int
;	O
long_options	array
[	O
next_long_option	int
]	O
.	O
val	int
=	O
0	int
;	O
while	O
(	O
(	O
option	struct
=	O
getopt_long	function
(	O
(	O
unsigned	O
int	O
)	O
argc	int
,	O
argv	pointer
,	O
short_option_list	array
,	O
long_options	array
,	O
&	O
long_option_index	int
)	O
)	O
!=	O
EOF	O
)	O
{	O
if	O
(	O
option	struct
==	O
'?'	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
gettext	function
(	O
CMD_NAME	pointer
": failed to parse options\n"	pointer
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
option	struct
!=	O
0	int
)	O
{	O
char	O
*	O
option_name	pointer
;	O
option_name	pointer
=	O
xmalloc	function
(	O
2	int
)	O
;	O
option_name	pointer
[	O
0	int
]	O
=	O
option	struct
;	O
option_name	pointer
[	O
1	int
]	O
=	O
'\0'	O
;	O
option_index	int
=	O
SHORT_OPTION	O
(	O
option	struct
)	O
;	O
set_option	function
(	O
option_index	int
,	O
"-"	pointer
,	O
option_name	pointer
,	O
optarg	pointer
)	O
;	O
}	O
else	O
{	O
set_option	function
(	O
this_option	int
,	O
"--"	pointer
,	O
long_options	array
[	O
long_option_index	int
]	O
.	O
name	pointer
,	O
optarg	pointer
)	O
;	O
}	O
}	O
return	O
(	O
optind	int
)	O
;	O
}	O
void	O
noparm_option	function
(	O
char	O
*	O
c	pointer
,	O
char	O
*	O
s	pointer
,	O
boolean	enum
default_opt	enum
,	O
void	O
(	O
*	O
handler	pointer
)	O
(	O
const	O
char	O
*	O
p	pointer
,	O
const	O
char	O
*	O
s	pointer
)	O
,	O
void	O
(	O
*	O
set_default	pointer
)	O
(	O
void	O
)	O
,	O
option_class	enum
class	enum
,	O
char	O
*	O
help_string	pointer
)	O
{	O
int	O
option_index	int
=	O
next_option	int
++	O
;	O
if	O
(	O
s	pointer
)	O
{	O
int	O
long_option_index	int
=	O
next_long_option	int
++	O
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
name	pointer
=	O
s	pointer
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
has_arg	int
=	O
0	int
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
flag	pointer
=	O
&	O
this_option	int
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
val	int
=	O
option_index	int
;	O
}	O
if	O
(	O
(	O
next_option	int
>	O
MAX_OPTIONS	int
)	O
||	O
(	O
next_long_option	int
>	O
MAX_OPTIONS	int
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
handler	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
default_opt	enum
&&	O
set_default	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
c	pointer
)	O
{	O
option_list	array
[	O
option_index	int
]	O
.	O
letter	char
=	O
*	O
c	pointer
;	O
SHORT_OPTION	O
(	O
*	O
c	pointer
)	O
=	O
option_index	int
;	O
}	O
else	O
option_list	array
[	O
option_index	int
]	O
.	O
letter	char
=	O
0	int
;	O
option_list	array
[	O
option_index	int
]	O
.	O
type	enum
=	O
NOPARM	int
;	O
option_list	array
[	O
option_index	int
]	O
.	O
class	enum
=	O
class	enum
;	O
option_list	array
[	O
option_index	int
]	O
.	O
need_string	char
=	O
FALSE	int
;	O
option_list	array
[	O
option_index	int
]	O
.	O
set	enum
=	O
FALSE	int
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
onoparm	struct
.	O
string	pointer
=	O
s	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
onoparm	struct
.	O
default_opt	enum
=	O
default_opt	enum
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
onoparm	struct
.	O
handler	pointer
=	O
handler	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
onoparm	struct
.	O
set_default	pointer
=	O
set_default	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
onoparm	struct
.	O
help_string	pointer
=	O
help_string	pointer
;	O
}	O
void	O
optional_string_option	function
(	O
char	O
*	O
c	pointer
,	O
char	O
*	O
s	pointer
,	O
void	O
(	O
*	O
handler	pointer
)	O
(	O
const	O
char	O
*	O
p	pointer
,	O
const	O
char	O
*	O
s	pointer
,	O
char	O
*	O
value	pointer
)	O
,	O
option_class	enum
class	enum
,	O
char	O
*	O
help_string	pointer
)	O
{	O
int	O
option_index	int
=	O
next_option	int
++	O
;	O
if	O
(	O
s	pointer
)	O
{	O
int	O
long_option_index	int
=	O
next_long_option	int
++	O
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
name	pointer
=	O
s	pointer
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
has_arg	int
=	O
2	int
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
flag	pointer
=	O
&	O
this_option	int
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
val	int
=	O
option_index	int
;	O
}	O
if	O
(	O
(	O
next_option	int
>	O
MAX_OPTIONS	int
)	O
||	O
(	O
next_long_option	int
>	O
MAX_OPTIONS	int
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
handler	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
c	pointer
)	O
{	O
option_list	array
[	O
option_index	int
]	O
.	O
letter	char
=	O
*	O
c	pointer
;	O
SHORT_OPTION	O
(	O
*	O
c	pointer
)	O
=	O
option_index	int
;	O
}	O
else	O
option_list	array
[	O
option_index	int
]	O
.	O
letter	char
=	O
0	int
;	O
option_list	array
[	O
option_index	int
]	O
.	O
type	enum
=	O
OPTIONAL	int
;	O
option_list	array
[	O
option_index	int
]	O
.	O
class	enum
=	O
class	enum
;	O
option_list	array
[	O
option_index	int
]	O
.	O
need_string	char
=	O
FALSE	int
;	O
option_list	array
[	O
option_index	int
]	O
.	O
set	enum
=	O
FALSE	int
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
ooptional	struct
.	O
string	pointer
=	O
s	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
ooptional	struct
.	O
handler	pointer
=	O
handler	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
ooptional	struct
.	O
help_string	pointer
=	O
help_string	pointer
;	O
}	O
void	O
boolean_option	function
(	O
char	O
*	O
c	pointer
,	O
char	O
*	O
s1	pointer
,	O
char	O
*	O
s2	pointer
,	O
boolean	enum
default_value	enum
,	O
boolean	enum
*	O
var	pointer
,	O
void	O
(	O
*	O
handler	pointer
)	O
(	O
const	O
char	O
*	O
p	pointer
,	O
const	O
char	O
*	O
s	pointer
,	O
boolean	enum
value	pointer
)	O
,	O
void	O
(	O
*	O
set_default	pointer
)	O
(	O
boolean	enum
value	pointer
)	O
,	O
option_class	enum
class	enum
,	O
char	O
*	O
true_help_string	pointer
,	O
char	O
*	O
false_help_string	pointer
)	O
{	O
int	O
option_index	int
=	O
next_option	int
++	O
;	O
if	O
(	O
c	pointer
)	O
{	O
int	O
long_option_index	int
=	O
next_long_option	int
++	O
;	O
option_list	array
[	O
option_index	int
]	O
.	O
letter	char
=	O
*	O
c	pointer
;	O
SHORT_OPTION	O
(	O
*	O
c	pointer
)	O
=	O
option_index	int
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
name	pointer
=	O
c	pointer
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
has_arg	int
=	O
0	int
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
flag	pointer
=	O
&	O
this_option	int
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
val	int
=	O
option_index	int
|	O
OPT_FLAG	int
;	O
}	O
else	O
option_list	array
[	O
option_index	int
]	O
.	O
letter	char
=	O
0	int
;	O
if	O
(	O
s1	pointer
)	O
{	O
int	O
long_option_index	int
=	O
next_long_option	int
++	O
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
name	pointer
=	O
s1	pointer
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
has_arg	int
=	O
0	int
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
flag	pointer
=	O
&	O
this_option	int
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
val	int
=	O
option_index	int
;	O
}	O
if	O
(	O
s2	pointer
)	O
{	O
int	O
long_option_index	int
=	O
next_long_option	int
++	O
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
name	pointer
=	O
s2	pointer
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
has_arg	int
=	O
0	int
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
flag	pointer
=	O
&	O
this_option	int
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
val	int
=	O
option_index	int
|	O
OPT_FLAG	int
;	O
}	O
if	O
(	O
(	O
next_option	int
>	O
MAX_OPTIONS	int
)	O
||	O
(	O
next_long_option	int
>	O
MAX_OPTIONS	int
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
(	O
var	pointer
==	O
NULL	O
)	O
&&	O
(	O
handler	pointer
==	O
NULL	O
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
(	O
var	pointer
!=	O
NULL	O
)	O
&&	O
(	O
handler	pointer
!=	O
NULL	O
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
(	O
handler	pointer
==	O
NULL	O
)	O
!=	O
(	O
set_default	pointer
==	O
NULL	O
)	O
)	O
abort	function
(	O
)	O
;	O
option_list	array
[	O
option_index	int
]	O
.	O
type	enum
=	O
BOOLEAN	int
;	O
option_list	array
[	O
option_index	int
]	O
.	O
class	enum
=	O
class	enum
;	O
option_list	array
[	O
option_index	int
]	O
.	O
need_string	char
=	O
FALSE	int
;	O
option_list	array
[	O
option_index	int
]	O
.	O
set	enum
=	O
FALSE	int
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
obool	struct
.	O
true_string	pointer
=	O
s1	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
obool	struct
.	O
false_string	pointer
=	O
s2	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
obool	struct
.	O
var	pointer
=	O
var	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
obool	struct
.	O
default_value	enum
=	O
default_value	enum
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
obool	struct
.	O
handler	pointer
=	O
handler	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
obool	struct
.	O
set_default	pointer
=	O
set_default	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
obool	struct
.	O
true_help_string	pointer
=	O
true_help_string	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
obool	struct
.	O
false_help_string	pointer
=	O
false_help_string	pointer
;	O
}	O
void	O
choice_option	function
(	O
char	O
*	O
c	pointer
,	O
char	O
*	O
s1	pointer
,	O
char	O
*	O
s2	pointer
,	O
char	O
choice1	char
,	O
char	O
choice2	char
,	O
char	O
*	O
var	pointer
,	O
void	O
(	O
*	O
handler	pointer
)	O
(	O
const	O
char	O
*	O
p	pointer
,	O
const	O
char	O
*	O
s	pointer
,	O
char	O
value	pointer
)	O
,	O
void	O
(	O
*	O
set_default	pointer
)	O
(	O
char	O
value	pointer
)	O
,	O
option_class	enum
class	enum
,	O
char	O
*	O
choice1_help_string	pointer
,	O
char	O
*	O
choice2_help_string	pointer
)	O
{	O
int	O
option_index	int
=	O
next_option	int
++	O
;	O
if	O
(	O
c	pointer
)	O
{	O
option_list	array
[	O
option_index	int
]	O
.	O
letter	char
=	O
*	O
c	pointer
;	O
SHORT_OPTION	O
(	O
*	O
c	pointer
)	O
=	O
option_index	int
;	O
}	O
else	O
option_list	array
[	O
option_index	int
]	O
.	O
letter	char
=	O
0	int
;	O
if	O
(	O
s1	pointer
)	O
{	O
int	O
long_option_index	int
=	O
next_long_option	int
++	O
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
name	pointer
=	O
s1	pointer
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
has_arg	int
=	O
0	int
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
flag	pointer
=	O
&	O
this_option	int
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
val	int
=	O
option_index	int
;	O
}	O
if	O
(	O
s2	pointer
)	O
{	O
int	O
long_option_index	int
=	O
next_long_option	int
++	O
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
name	pointer
=	O
s2	pointer
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
has_arg	int
=	O
0	int
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
flag	pointer
=	O
&	O
this_option	int
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
val	int
=	O
option_index	int
|	O
OPT_FLAG	int
;	O
}	O
if	O
(	O
(	O
next_option	int
>	O
MAX_OPTIONS	int
)	O
||	O
(	O
next_long_option	int
>	O
MAX_OPTIONS	int
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
(	O
var	pointer
==	O
NULL	O
)	O
&&	O
(	O
handler	pointer
==	O
NULL	O
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
(	O
var	pointer
!=	O
NULL	O
)	O
&&	O
(	O
handler	pointer
!=	O
NULL	O
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
(	O
handler	pointer
==	O
NULL	O
)	O
!=	O
(	O
set_default	pointer
==	O
NULL	O
)	O
)	O
abort	function
(	O
)	O
;	O
option_list	array
[	O
option_index	int
]	O
.	O
type	enum
=	O
CHOICE	int
;	O
option_list	array
[	O
option_index	int
]	O
.	O
class	enum
=	O
class	enum
;	O
option_list	array
[	O
option_index	int
]	O
.	O
need_string	char
=	O
TRUE	int
;	O
option_list	array
[	O
option_index	int
]	O
.	O
set	enum
=	O
FALSE	int
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
ochoice	struct
.	O
var	pointer
=	O
var	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
ochoice	struct
.	O
choice1_string	pointer
=	O
s1	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
ochoice	struct
.	O
choice2_string	pointer
=	O
s2	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
ochoice	struct
.	O
choice1	char
=	O
choice1	char
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
ochoice	struct
.	O
choice2	char
=	O
choice2	char
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
ochoice	struct
.	O
handler	pointer
=	O
handler	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
ochoice	struct
.	O
set_default	pointer
=	O
set_default	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
ochoice	struct
.	O
choice1_help_string	pointer
=	O
choice1_help_string	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
ochoice	struct
.	O
choice2_help_string	pointer
=	O
choice2_help_string	pointer
;	O
}	O
void	O
char_option	function
(	O
char	O
*	O
c	pointer
,	O
char	O
*	O
s	pointer
,	O
char	O
default_value	enum
,	O
char	O
*	O
valid_set	pointer
,	O
char	O
*	O
var	pointer
,	O
void	O
(	O
*	O
handler	pointer
)	O
(	O
const	O
char	O
*	O
p	pointer
,	O
const	O
char	O
*	O
s	pointer
,	O
char	O
value	pointer
,	O
char	O
*	O
var	pointer
)	O
,	O
void	O
(	O
*	O
set_default	pointer
)	O
(	O
char	O
value	pointer
)	O
,	O
option_class	enum
class	enum
,	O
char	O
*	O
help_string	pointer
)	O
{	O
int	O
option_index	int
=	O
next_option	int
++	O
;	O
if	O
(	O
c	pointer
)	O
{	O
option_list	array
[	O
option_index	int
]	O
.	O
letter	char
=	O
*	O
c	pointer
;	O
SHORT_OPTION	O
(	O
*	O
c	pointer
)	O
=	O
option_index	int
;	O
}	O
else	O
option_list	array
[	O
option_index	int
]	O
.	O
letter	char
=	O
0	int
;	O
if	O
(	O
s	pointer
)	O
{	O
int	O
long_option_index	int
=	O
next_long_option	int
++	O
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
name	pointer
=	O
s	pointer
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
has_arg	int
=	O
1	int
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
flag	pointer
=	O
&	O
this_option	int
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
val	int
=	O
option_index	int
;	O
}	O
if	O
(	O
(	O
next_option	int
>	O
MAX_OPTIONS	int
)	O
||	O
(	O
next_long_option	int
>	O
MAX_OPTIONS	int
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
(	O
var	pointer
==	O
NULL	O
)	O
&&	O
(	O
handler	pointer
==	O
NULL	O
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
(	O
var	pointer
!=	O
NULL	O
)	O
&&	O
(	O
handler	pointer
!=	O
NULL	O
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
(	O
handler	pointer
==	O
NULL	O
)	O
!=	O
(	O
set_default	pointer
==	O
NULL	O
)	O
)	O
abort	function
(	O
)	O
;	O
option_list	array
[	O
option_index	int
]	O
.	O
type	enum
=	O
CHAR	int
;	O
option_list	array
[	O
option_index	int
]	O
.	O
class	enum
=	O
class	enum
;	O
option_list	array
[	O
option_index	int
]	O
.	O
need_string	char
=	O
TRUE	int
;	O
option_list	array
[	O
option_index	int
]	O
.	O
set	enum
=	O
FALSE	int
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
ochar	struct
.	O
string	pointer
=	O
s	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
ochar	struct
.	O
var	pointer
=	O
var	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
ochar	struct
.	O
default_value	enum
=	O
default_value	enum
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
ochar	struct
.	O
valid_set	pointer
=	O
valid_set	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
ochar	struct
.	O
handler	pointer
=	O
handler	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
ochar	struct
.	O
set_default	pointer
=	O
set_default	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
ochar	struct
.	O
help_string	pointer
=	O
help_string	pointer
;	O
}	O
void	O
short_option	function
(	O
char	O
*	O
c	pointer
,	O
char	O
*	O
s	pointer
,	O
short	O
default_value	enum
,	O
char	O
*	O
special_string	pointer
,	O
short	O
special_value	short
,	O
short	O
min	short
,	O
short	O
max	short
,	O
short	O
*	O
var	pointer
,	O
void	O
(	O
*	O
handler	pointer
)	O
(	O
const	O
char	O
*	O
p	pointer
,	O
const	O
char	O
*	O
s	pointer
,	O
short	O
value	pointer
,	O
short	O
min	short
,	O
short	O
max	short
)	O
,	O
void	O
(	O
*	O
set_default	pointer
)	O
(	O
short	O
value	pointer
)	O
,	O
option_class	enum
class	enum
,	O
char	O
*	O
help_string	pointer
,	O
char	O
*	O
special_help_string	pointer
)	O
{	O
int	O
option_index	int
=	O
next_option	int
++	O
;	O
if	O
(	O
c	pointer
)	O
{	O
option_list	array
[	O
option_index	int
]	O
.	O
letter	char
=	O
*	O
c	pointer
;	O
SHORT_OPTION	O
(	O
*	O
c	pointer
)	O
=	O
option_index	int
;	O
}	O
else	O
option_list	array
[	O
option_index	int
]	O
.	O
letter	char
=	O
0	int
;	O
if	O
(	O
s	pointer
)	O
{	O
int	O
long_option_index	int
=	O
next_long_option	int
++	O
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
name	pointer
=	O
s	pointer
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
has_arg	int
=	O
1	int
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
flag	pointer
=	O
&	O
this_option	int
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
val	int
=	O
option_index	int
;	O
}	O
if	O
(	O
special_string	pointer
)	O
{	O
int	O
long_option_index	int
=	O
next_long_option	int
++	O
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
name	pointer
=	O
special_string	pointer
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
has_arg	int
=	O
0	int
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
flag	pointer
=	O
&	O
this_option	int
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
val	int
=	O
option_index	int
|	O
OPT_FLAG	int
;	O
}	O
if	O
(	O
(	O
next_option	int
>	O
MAX_OPTIONS	int
)	O
||	O
(	O
next_long_option	int
>	O
MAX_OPTIONS	int
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
(	O
var	pointer
==	O
NULL	O
)	O
&&	O
(	O
handler	pointer
==	O
NULL	O
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
(	O
var	pointer
!=	O
NULL	O
)	O
&&	O
(	O
handler	pointer
!=	O
NULL	O
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
(	O
handler	pointer
==	O
NULL	O
)	O
!=	O
(	O
set_default	pointer
==	O
NULL	O
)	O
)	O
abort	function
(	O
)	O
;	O
option_list	array
[	O
option_index	int
]	O
.	O
type	enum
=	O
SHORT	int
;	O
option_list	array
[	O
option_index	int
]	O
.	O
class	enum
=	O
class	enum
;	O
option_list	array
[	O
option_index	int
]	O
.	O
need_string	char
=	O
TRUE	int
;	O
option_list	array
[	O
option_index	int
]	O
.	O
set	enum
=	O
FALSE	int
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
oshrt	struct
.	O
string	pointer
=	O
s	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
oshrt	struct
.	O
var	pointer
=	O
var	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
oshrt	struct
.	O
min	short
=	O
min	short
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
oshrt	struct
.	O
max	short
=	O
max	short
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
oshrt	struct
.	O
default_value	enum
=	O
default_value	enum
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
oshrt	struct
.	O
handler	pointer
=	O
handler	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
oshrt	struct
.	O
set_default	pointer
=	O
set_default	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
oshrt	struct
.	O
help_string	pointer
=	O
help_string	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
oshrt	struct
.	O
special_string	pointer
=	O
special_string	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
oshrt	struct
.	O
special_value	short
=	O
special_value	short
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
oshrt	struct
.	O
special_help_string	pointer
=	O
special_help_string	pointer
;	O
}	O
void	O
int_option	function
(	O
char	O
*	O
c	pointer
,	O
char	O
*	O
s	pointer
,	O
int	O
default_value	enum
,	O
char	O
*	O
special_string	pointer
,	O
int	O
special_value	short
,	O
int	O
min	short
,	O
int	O
max	short
,	O
int	O
*	O
var	pointer
,	O
void	O
(	O
*	O
handler	pointer
)	O
(	O
const	O
char	O
*	O
p	pointer
,	O
const	O
char	O
*	O
s	pointer
,	O
int	O
value	pointer
,	O
int	O
min	short
,	O
int	O
max	short
)	O
,	O
void	O
(	O
*	O
set_default	pointer
)	O
(	O
int	O
value	pointer
)	O
,	O
option_class	enum
class	enum
,	O
char	O
*	O
help_string	pointer
,	O
char	O
*	O
special_help_string	pointer
)	O
{	O
int	O
option_index	int
=	O
next_option	int
++	O
;	O
if	O
(	O
c	pointer
)	O
{	O
option_list	array
[	O
option_index	int
]	O
.	O
letter	char
=	O
*	O
c	pointer
;	O
SHORT_OPTION	O
(	O
*	O
c	pointer
)	O
=	O
option_index	int
;	O
}	O
else	O
option_list	array
[	O
option_index	int
]	O
.	O
letter	char
=	O
0	int
;	O
if	O
(	O
s	pointer
)	O
{	O
int	O
long_option_index	int
=	O
next_long_option	int
++	O
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
name	pointer
=	O
s	pointer
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
has_arg	int
=	O
1	int
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
flag	pointer
=	O
&	O
this_option	int
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
val	int
=	O
option_index	int
;	O
}	O
if	O
(	O
special_string	pointer
)	O
{	O
int	O
long_option_index	int
=	O
next_long_option	int
++	O
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
name	pointer
=	O
special_string	pointer
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
has_arg	int
=	O
0	int
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
flag	pointer
=	O
&	O
this_option	int
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
val	int
=	O
option_index	int
|	O
OPT_FLAG	int
;	O
}	O
if	O
(	O
(	O
next_option	int
>	O
MAX_OPTIONS	int
)	O
||	O
(	O
next_long_option	int
>	O
MAX_OPTIONS	int
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
(	O
var	pointer
==	O
NULL	O
)	O
&&	O
(	O
handler	pointer
==	O
NULL	O
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
(	O
var	pointer
!=	O
NULL	O
)	O
&&	O
(	O
handler	pointer
!=	O
NULL	O
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
(	O
handler	pointer
==	O
NULL	O
)	O
!=	O
(	O
set_default	pointer
==	O
NULL	O
)	O
)	O
abort	function
(	O
)	O
;	O
option_list	array
[	O
option_index	int
]	O
.	O
type	enum
=	O
INT	int
;	O
option_list	array
[	O
option_index	int
]	O
.	O
class	enum
=	O
class	enum
;	O
option_list	array
[	O
option_index	int
]	O
.	O
need_string	char
=	O
TRUE	int
;	O
option_list	array
[	O
option_index	int
]	O
.	O
set	enum
=	O
FALSE	int
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
oint	struct
.	O
string	pointer
=	O
s	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
oint	struct
.	O
var	pointer
=	O
var	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
oint	struct
.	O
min	short
=	O
min	short
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
oint	struct
.	O
max	short
=	O
max	short
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
oint	struct
.	O
default_value	enum
=	O
default_value	enum
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
oint	struct
.	O
handler	pointer
=	O
handler	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
oint	struct
.	O
set_default	pointer
=	O
set_default	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
oint	struct
.	O
help_string	pointer
=	O
help_string	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
oint	struct
.	O
special_string	pointer
=	O
special_string	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
oint	struct
.	O
special_value	short
=	O
special_value	short
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
oint	struct
.	O
special_help_string	pointer
=	O
special_help_string	pointer
;	O
}	O
void	O
string_option	function
(	O
char	O
*	O
c	pointer
,	O
char	O
*	O
s	pointer
,	O
char	O
*	O
default_value	enum
,	O
char	O
*	O
*	O
var	pointer
,	O
void	O
(	O
*	O
handler	pointer
)	O
(	O
const	O
char	O
*	O
p	pointer
,	O
const	O
char	O
*	O
s	pointer
,	O
char	O
*	O
value	pointer
)	O
,	O
void	O
(	O
*	O
set_default	pointer
)	O
(	O
char	O
*	O
value	pointer
)	O
,	O
option_class	enum
class	enum
,	O
char	O
*	O
help_string	pointer
)	O
{	O
int	O
option_index	int
=	O
next_option	int
++	O
;	O
if	O
(	O
c	pointer
)	O
{	O
option_list	array
[	O
option_index	int
]	O
.	O
letter	char
=	O
*	O
c	pointer
;	O
SHORT_OPTION	O
(	O
*	O
c	pointer
)	O
=	O
option_index	int
;	O
}	O
else	O
option_list	array
[	O
option_index	int
]	O
.	O
letter	char
=	O
0	int
;	O
if	O
(	O
s	pointer
)	O
{	O
int	O
long_option_index	int
=	O
next_long_option	int
++	O
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
name	pointer
=	O
s	pointer
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
has_arg	int
=	O
1	int
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
flag	pointer
=	O
&	O
this_option	int
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
val	int
=	O
option_index	int
;	O
}	O
if	O
(	O
(	O
var	pointer
==	O
NULL	O
)	O
&&	O
(	O
handler	pointer
==	O
NULL	O
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
(	O
var	pointer
!=	O
NULL	O
)	O
&&	O
(	O
handler	pointer
!=	O
NULL	O
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
(	O
handler	pointer
==	O
NULL	O
)	O
!=	O
(	O
set_default	pointer
==	O
NULL	O
)	O
)	O
abort	function
(	O
)	O
;	O
option_list	array
[	O
option_index	int
]	O
.	O
type	enum
=	O
STRING	int
;	O
option_list	array
[	O
option_index	int
]	O
.	O
class	enum
=	O
class	enum
;	O
option_list	array
[	O
option_index	int
]	O
.	O
need_string	char
=	O
TRUE	int
;	O
option_list	array
[	O
option_index	int
]	O
.	O
set	enum
=	O
FALSE	int
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
ostrng	struct
.	O
string	pointer
=	O
s	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
ostrng	struct
.	O
var	pointer
=	O
var	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
ostrng	struct
.	O
default_value	enum
=	O
default_value	enum
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
ostrng	struct
.	O
handler	pointer
=	O
handler	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
ostrng	struct
.	O
set_default	pointer
=	O
set_default	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
ostrng	struct
.	O
help_string	pointer
=	O
help_string	pointer
;	O
}	O
void	O
flag_string_option	function
(	O
char	O
*	O
c	pointer
,	O
char	O
*	O
s1	pointer
,	O
char	O
*	O
s2	pointer
,	O
boolean	enum
default_value	enum
,	O
char	O
*	O
true_value	pointer
,	O
char	O
*	O
false_value	pointer
,	O
char	O
*	O
*	O
var	pointer
,	O
void	O
(	O
*	O
handler	pointer
)	O
(	O
const	O
char	O
*	O
p	pointer
,	O
const	O
char	O
*	O
s	pointer
,	O
boolean	enum
value	pointer
,	O
char	O
*	O
true_value	pointer
,	O
char	O
*	O
false_value	pointer
)	O
,	O
void	O
(	O
*	O
set_default	pointer
)	O
(	O
boolean	enum
value	pointer
,	O
char	O
*	O
string_value	pointer
)	O
,	O
option_class	enum
class	enum
,	O
char	O
*	O
set_help_string	pointer
,	O
char	O
*	O
not_set_help_string	pointer
)	O
{	O
int	O
option_index	int
=	O
next_option	int
++	O
;	O
if	O
(	O
c	pointer
)	O
{	O
option_list	array
[	O
option_index	int
]	O
.	O
letter	char
=	O
*	O
c	pointer
;	O
SHORT_OPTION	O
(	O
*	O
c	pointer
)	O
=	O
option_index	int
;	O
}	O
else	O
option_list	array
[	O
option_index	int
]	O
.	O
letter	char
=	O
0	int
;	O
if	O
(	O
s1	pointer
)	O
{	O
int	O
long_option_index	int
=	O
next_long_option	int
++	O
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
name	pointer
=	O
s1	pointer
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
has_arg	int
=	O
1	int
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
flag	pointer
=	O
&	O
this_option	int
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
val	int
=	O
option_index	int
;	O
}	O
if	O
(	O
s2	pointer
)	O
{	O
int	O
long_option_index	int
=	O
next_long_option	int
++	O
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
name	pointer
=	O
s2	pointer
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
has_arg	int
=	O
0	int
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
flag	pointer
=	O
&	O
this_option	int
;	O
long_options	array
[	O
long_option_index	int
]	O
.	O
val	int
=	O
option_index	int
|	O
OPT_FLAG	int
;	O
}	O
if	O
(	O
(	O
next_option	int
>	O
MAX_OPTIONS	int
)	O
||	O
(	O
next_long_option	int
>	O
MAX_OPTIONS	int
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
(	O
var	pointer
==	O
NULL	O
)	O
&&	O
(	O
handler	pointer
==	O
NULL	O
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
(	O
var	pointer
!=	O
NULL	O
)	O
&&	O
(	O
handler	pointer
!=	O
NULL	O
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
(	O
handler	pointer
==	O
NULL	O
)	O
!=	O
(	O
set_default	pointer
==	O
NULL	O
)	O
)	O
abort	function
(	O
)	O
;	O
option_list	array
[	O
option_index	int
]	O
.	O
type	enum
=	O
FLAG_STRING	int
;	O
option_list	array
[	O
option_index	int
]	O
.	O
class	enum
=	O
class	enum
;	O
option_list	array
[	O
option_index	int
]	O
.	O
need_string	char
=	O
FALSE	int
;	O
option_list	array
[	O
option_index	int
]	O
.	O
set	enum
=	O
FALSE	int
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
oflg	struct
.	O
var	pointer
=	O
var	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
oflg	struct
.	O
set_string	pointer
=	O
s1	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
oflg	struct
.	O
not_set_string	pointer
=	O
s2	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
oflg	struct
.	O
default_value	enum
=	O
default_value	enum
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
oflg	struct
.	O
true_value	pointer
=	O
true_value	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
oflg	struct
.	O
false_value	pointer
=	O
false_value	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
oflg	struct
.	O
handler	pointer
=	O
handler	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
oflg	struct
.	O
set_default	pointer
=	O
set_default	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
oflg	struct
.	O
set_help_string	pointer
=	O
set_help_string	pointer
;	O
option_list	array
[	O
option_index	int
]	O
.	O
t	union
.	O
oflg	struct
.	O
not_set_help_string	pointer
=	O
not_set_help_string	pointer
;	O
}	O
void	O
set_option	function
(	O
int	O
index	function
,	O
char	O
*	O
prefix	pointer
,	O
const	O
char	O
*	O
option_name	pointer
,	O
char	O
*	O
value	pointer
)	O
{	O
boolean	enum
flag_set	enum
=	O
(	O
(	O
index	function
&	O
OPT_FLAG	int
)	O
!=	O
0	int
)	O
;	O
struct	O
option_type	struct
*	O
op	pointer
;	O
if	O
(	O
flag_set	enum
)	O
op	pointer
=	O
&	O
option_list	array
[	O
index	function
-	O
OPT_FLAG	int
]	O
;	O
else	O
op	pointer
=	O
&	O
option_list	array
[	O
index	function
]	O
;	O
if	O
(	O
value	pointer
)	O
dm	function
(	O
'o'	O
,	O
3	int
,	O
"Trying to set option %s%s to %s\n"	pointer
,	O
prefix	pointer
,	O
option_name	pointer
,	O
value	pointer
)	O
;	O
else	O
dm	function
(	O
'o'	O
,	O
3	int
,	O
"Trying to set option %s%s\n"	pointer
,	O
prefix	pointer
,	O
option_name	pointer
)	O
;	O
if	O
(	O
op	pointer
->	O
set	enum
)	O
{	O
dm	function
(	O
'o'	O
,	O
3	int
,	O
"Option %s%s already set\n"	pointer
,	O
prefix	pointer
,	O
option_name	pointer
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
op	pointer
->	O
type	enum
)	O
{	O
case	O
NOPARM	int
:	O
(	O
*	O
(	O
op	pointer
->	O
t	union
.	O
onoparm	struct
.	O
handler	pointer
)	O
)	O
(	O
prefix	pointer
,	O
option_name	pointer
)	O
;	O
break	O
;	O
case	O
OPTIONAL	int
:	O
(	O
*	O
(	O
op	pointer
->	O
t	union
.	O
ooptional	struct
.	O
handler	pointer
)	O
)	O
(	O
prefix	pointer
,	O
option_name	pointer
,	O
value	pointer
)	O
;	O
break	O
;	O
case	O
BOOLEAN	int
:	O
if	O
(	O
op	pointer
->	O
t	union
.	O
obool	struct
.	O
var	pointer
)	O
{	O
*	O
(	O
op	pointer
->	O
t	union
.	O
obool	struct
.	O
var	pointer
)	O
=	O
(	O
!	O
flag_set	enum
)	O
;	O
}	O
else	O
{	O
(	O
*	O
(	O
op	pointer
->	O
t	union
.	O
obool	struct
.	O
handler	pointer
)	O
)	O
(	O
prefix	pointer
,	O
option_name	pointer
,	O
!	O
flag_set	enum
)	O
;	O
}	O
break	O
;	O
case	O
CHAR	int
:	O
if	O
(	O
strlen	function
(	O
value	pointer
)	O
!=	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
gettext	function
(	O
CMD_NAME	pointer
": must have one character parameter for %s%s flag, but got '%s'\n"	pointer
)	O
,	O
prefix	pointer
,	O
option_name	pointer
,	O
value	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
op	pointer
->	O
t	union
.	O
ochar	struct
.	O
var	pointer
)	O
{	O
*	O
(	O
op	pointer
->	O
t	union
.	O
ochar	struct
.	O
var	pointer
)	O
=	O
*	O
value	pointer
;	O
}	O
else	O
{	O
(	O
*	O
(	O
op	pointer
->	O
t	union
.	O
ochar	struct
.	O
handler	pointer
)	O
)	O
(	O
prefix	pointer
,	O
option_name	pointer
,	O
*	O
value	pointer
,	O
op	pointer
->	O
t	union
.	O
ochar	struct
.	O
valid_set	pointer
)	O
;	O
}	O
break	O
;	O
case	O
CHOICE	int
:	O
if	O
(	O
strlen	function
(	O
prefix	pointer
)	O
==	O
1	int
)	O
{	O
if	O
(	O
strlen	function
(	O
value	pointer
)	O
!=	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
gettext	function
(	O
CMD_NAME	pointer
": must have one character parameter for %s%s flag, but got '%s'\n"	pointer
)	O
,	O
prefix	pointer
,	O
option_name	pointer
,	O
value	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
*	O
value	pointer
!=	O
op	pointer
->	O
t	union
.	O
ochoice	struct
.	O
choice1	char
)	O
&&	O
(	O
*	O
value	pointer
!=	O
op	pointer
->	O
t	union
.	O
ochoice	struct
.	O
choice2	char
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
gettext	function
(	O
CMD_NAME	pointer
": option %s%s can only take %c or %c, not %c\n"	pointer
)	O
,	O
prefix	pointer
,	O
option_name	pointer
,	O
op	pointer
->	O
t	union
.	O
ochoice	struct
.	O
choice1	char
,	O
op	pointer
->	O
t	union
.	O
ochoice	struct
.	O
choice2	char
,	O
*	O
value	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
op	pointer
->	O
t	union
.	O
ochoice	struct
.	O
var	pointer
)	O
{	O
*	O
(	O
op	pointer
->	O
t	union
.	O
ochoice	struct
.	O
var	pointer
)	O
=	O
*	O
value	pointer
;	O
}	O
else	O
{	O
(	O
*	O
(	O
op	pointer
->	O
t	union
.	O
ochoice	struct
.	O
handler	pointer
)	O
)	O
(	O
prefix	pointer
,	O
option_name	pointer
,	O
*	O
value	pointer
)	O
;	O
}	O
}	O
else	O
{	O
char	O
chosen_value	char
;	O
if	O
(	O
strcmp	function
(	O
option_name	pointer
,	O
op	pointer
->	O
t	union
.	O
ochoice	struct
.	O
choice1_string	pointer
)	O
==	O
0	int
)	O
{	O
chosen_value	char
=	O
op	pointer
->	O
t	union
.	O
ochoice	struct
.	O
choice1	char
;	O
}	O
else	O
{	O
chosen_value	char
=	O
op	pointer
->	O
t	union
.	O
ochoice	struct
.	O
choice2	char
;	O
}	O
if	O
(	O
op	pointer
->	O
t	union
.	O
ochoice	struct
.	O
var	pointer
)	O
{	O
*	O
(	O
op	pointer
->	O
t	union
.	O
ochoice	struct
.	O
var	pointer
)	O
=	O
chosen_value	char
;	O
}	O
else	O
{	O
(	O
*	O
(	O
op	pointer
->	O
t	union
.	O
ochoice	struct
.	O
handler	pointer
)	O
)	O
(	O
prefix	pointer
,	O
option_name	pointer
,	O
chosen_value	char
)	O
;	O
}	O
}	O
break	O
;	O
case	O
SHORT	int
:	O
if	O
(	O
flag_set	enum
)	O
{	O
if	O
(	O
op	pointer
->	O
t	union
.	O
oshrt	struct
.	O
var	pointer
)	O
{	O
*	O
(	O
op	pointer
->	O
t	union
.	O
oshrt	struct
.	O
var	pointer
)	O
=	O
op	pointer
->	O
t	union
.	O
oshrt	struct
.	O
special_value	short
;	O
}	O
else	O
{	O
(	O
*	O
(	O
op	pointer
->	O
t	union
.	O
oshrt	struct
.	O
handler	pointer
)	O
)	O
(	O
prefix	pointer
,	O
option_name	pointer
,	O
op	pointer
->	O
t	union
.	O
oshrt	struct
.	O
special_value	short
,	O
op	pointer
->	O
t	union
.	O
oshrt	struct
.	O
min	short
,	O
op	pointer
->	O
t	union
.	O
oshrt	struct
.	O
max	short
)	O
;	O
}	O
}	O
else	O
{	O
int	O
intvalue	int
=	O
atoi	function
(	O
value	pointer
)	O
;	O
if	O
(	O
(	O
intvalue	int
>	O
op	pointer
->	O
t	union
.	O
oshrt	struct
.	O
max	short
)	O
||	O
(	O
intvalue	int
<	O
op	pointer
->	O
t	union
.	O
oshrt	struct
.	O
min	short
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
gettext	function
(	O
CMD_NAME	pointer
": option %s%s not between %d and %d\n"	pointer
)	O
,	O
prefix	pointer
,	O
option_name	pointer
,	O
op	pointer
->	O
t	union
.	O
oshrt	struct
.	O
min	short
,	O
op	pointer
->	O
t	union
.	O
oshrt	struct
.	O
max	short
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
op	pointer
->	O
t	union
.	O
oshrt	struct
.	O
var	pointer
)	O
{	O
*	O
(	O
op	pointer
->	O
t	union
.	O
oshrt	struct
.	O
var	pointer
)	O
=	O
(	O
short	O
)	O
intvalue	int
;	O
}	O
else	O
{	O
(	O
*	O
(	O
op	pointer
->	O
t	union
.	O
oshrt	struct
.	O
handler	pointer
)	O
)	O
(	O
prefix	pointer
,	O
option_name	pointer
,	O
(	O
short	O
)	O
intvalue	int
,	O
op	pointer
->	O
t	union
.	O
oshrt	struct
.	O
min	short
,	O
op	pointer
->	O
t	union
.	O
oshrt	struct
.	O
max	short
)	O
;	O
}	O
}	O
break	O
;	O
case	O
INT	int
:	O
if	O
(	O
flag_set	enum
)	O
{	O
if	O
(	O
op	pointer
->	O
t	union
.	O
oint	struct
.	O
var	pointer
)	O
{	O
*	O
(	O
op	pointer
->	O
t	union
.	O
oint	struct
.	O
var	pointer
)	O
=	O
op	pointer
->	O
t	union
.	O
oint	struct
.	O
special_value	short
;	O
}	O
else	O
{	O
(	O
*	O
(	O
op	pointer
->	O
t	union
.	O
oint	struct
.	O
handler	pointer
)	O
)	O
(	O
prefix	pointer
,	O
option_name	pointer
,	O
op	pointer
->	O
t	union
.	O
oint	struct
.	O
special_value	short
,	O
op	pointer
->	O
t	union
.	O
oint	struct
.	O
min	short
,	O
op	pointer
->	O
t	union
.	O
oint	struct
.	O
max	short
)	O
;	O
}	O
}	O
else	O
{	O
int	O
intvalue	int
=	O
atoi	function
(	O
value	pointer
)	O
;	O
if	O
(	O
(	O
intvalue	int
>	O
op	pointer
->	O
t	union
.	O
oint	struct
.	O
max	short
)	O
||	O
(	O
intvalue	int
<	O
op	pointer
->	O
t	union
.	O
oint	struct
.	O
min	short
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
gettext	function
(	O
CMD_NAME	pointer
": option %s%s not between %d and %d\n"	pointer
)	O
,	O
prefix	pointer
,	O
option_name	pointer
,	O
op	pointer
->	O
t	union
.	O
oint	struct
.	O
min	short
,	O
op	pointer
->	O
t	union
.	O
oint	struct
.	O
max	short
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
op	pointer
->	O
t	union
.	O
oint	struct
.	O
var	pointer
)	O
{	O
*	O
(	O
op	pointer
->	O
t	union
.	O
oint	struct
.	O
var	pointer
)	O
=	O
intvalue	int
;	O
}	O
else	O
{	O
(	O
*	O
(	O
op	pointer
->	O
t	union
.	O
oint	struct
.	O
handler	pointer
)	O
)	O
(	O
prefix	pointer
,	O
option_name	pointer
,	O
intvalue	int
,	O
op	pointer
->	O
t	union
.	O
oint	struct
.	O
min	short
,	O
op	pointer
->	O
t	union
.	O
oint	struct
.	O
max	short
)	O
;	O
}	O
}	O
break	O
;	O
case	O
STRING	int
:	O
if	O
(	O
op	pointer
->	O
t	union
.	O
ostrng	struct
.	O
var	pointer
)	O
{	O
*	O
(	O
op	pointer
->	O
t	union
.	O
ostrng	struct
.	O
var	pointer
)	O
=	O
strdup	function
(	O
value	pointer
)	O
;	O
}	O
else	O
{	O
(	O
*	O
(	O
op	pointer
->	O
t	union
.	O
ostrng	struct
.	O
handler	pointer
)	O
)	O
(	O
prefix	pointer
,	O
option_name	pointer
,	O
value	pointer
)	O
;	O
}	O
break	O
;	O
case	O
FLAG_STRING	int
:	O
if	O
(	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
var	pointer
)	O
{	O
if	O
(	O
flag_set	enum
)	O
{	O
if	O
(	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
true_value	pointer
)	O
{	O
*	O
(	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
var	pointer
)	O
=	O
strdup	function
(	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
true_value	pointer
)	O
;	O
}	O
else	O
{	O
*	O
(	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
var	pointer
)	O
=	O
NULL	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
false_value	pointer
)	O
{	O
*	O
(	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
var	pointer
)	O
=	O
strdup	function
(	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
false_value	pointer
)	O
;	O
}	O
else	O
{	O
*	O
(	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
var	pointer
)	O
=	O
NULL	O
;	O
}	O
}	O
}	O
else	O
{	O
(	O
*	O
(	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
handler	pointer
)	O
)	O
(	O
prefix	pointer
,	O
option_name	pointer
,	O
!	O
flag_set	enum
,	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
true_value	pointer
,	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
false_value	pointer
)	O
;	O
}	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
op	pointer
->	O
set	enum
=	O
TRUE	int
;	O
dm	function
(	O
'o'	O
,	O
3	int
,	O
"Succeeded - %s%s has not been set before\n"	pointer
,	O
prefix	pointer
,	O
option_name	pointer
)	O
;	O
}	O
void	O
set_option_default	function
(	O
int	O
index	function
)	O
{	O
option_type	struct
*	O
op	pointer
=	O
&	O
option_list	array
[	O
index	function
]	O
;	O
dm	function
(	O
'o'	O
,	O
3	int
,	O
"Trying to set option %d to default value\n"	pointer
,	O
index	function
)	O
;	O
if	O
(	O
op	pointer
->	O
set	enum
)	O
{	O
dm	function
(	O
'o'	O
,	O
3	int
,	O
"Option %d already set\n"	pointer
,	O
index	function
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
op	pointer
->	O
type	enum
)	O
{	O
case	O
NOPARM	int
:	O
if	O
(	O
op	pointer
->	O
t	union
.	O
onoparm	struct
.	O
default_opt	enum
)	O
(	O
*	O
(	O
op	pointer
->	O
t	union
.	O
onoparm	struct
.	O
set_default	pointer
)	O
)	O
(	O
)	O
;	O
break	O
;	O
case	O
OPTIONAL	int
:	O
break	O
;	O
case	O
BOOLEAN	int
:	O
if	O
(	O
op	pointer
->	O
t	union
.	O
obool	struct
.	O
var	pointer
)	O
{	O
*	O
(	O
op	pointer
->	O
t	union
.	O
obool	struct
.	O
var	pointer
)	O
=	O
op	pointer
->	O
t	union
.	O
obool	struct
.	O
default_value	enum
;	O
}	O
else	O
{	O
(	O
*	O
(	O
op	pointer
->	O
t	union
.	O
obool	struct
.	O
set_default	pointer
)	O
)	O
(	O
op	pointer
->	O
t	union
.	O
obool	struct
.	O
default_value	enum
)	O
;	O
}	O
break	O
;	O
case	O
CHAR	int
:	O
if	O
(	O
op	pointer
->	O
t	union
.	O
ochar	struct
.	O
var	pointer
)	O
{	O
*	O
(	O
op	pointer
->	O
t	union
.	O
ochar	struct
.	O
var	pointer
)	O
=	O
op	pointer
->	O
t	union
.	O
ochar	struct
.	O
default_value	enum
;	O
}	O
else	O
{	O
(	O
*	O
(	O
op	pointer
->	O
t	union
.	O
ochar	struct
.	O
set_default	pointer
)	O
)	O
(	O
op	pointer
->	O
t	union
.	O
ochar	struct
.	O
default_value	enum
)	O
;	O
}	O
break	O
;	O
case	O
CHOICE	int
:	O
if	O
(	O
op	pointer
->	O
t	union
.	O
ochoice	struct
.	O
var	pointer
)	O
{	O
*	O
(	O
op	pointer
->	O
t	union
.	O
ochoice	struct
.	O
var	pointer
)	O
=	O
op	pointer
->	O
t	union
.	O
ochoice	struct
.	O
choice1	char
;	O
}	O
else	O
{	O
(	O
*	O
(	O
op	pointer
->	O
t	union
.	O
ochoice	struct
.	O
set_default	pointer
)	O
)	O
(	O
op	pointer
->	O
t	union
.	O
ochoice	struct
.	O
choice1	char
)	O
;	O
}	O
break	O
;	O
case	O
SHORT	int
:	O
if	O
(	O
op	pointer
->	O
t	union
.	O
oshrt	struct
.	O
var	pointer
)	O
{	O
*	O
(	O
op	pointer
->	O
t	union
.	O
oshrt	struct
.	O
var	pointer
)	O
=	O
op	pointer
->	O
t	union
.	O
oshrt	struct
.	O
default_value	enum
;	O
}	O
else	O
{	O
(	O
*	O
(	O
op	pointer
->	O
t	union
.	O
oshrt	struct
.	O
set_default	pointer
)	O
)	O
(	O
op	pointer
->	O
t	union
.	O
oshrt	struct
.	O
default_value	enum
)	O
;	O
}	O
break	O
;	O
case	O
INT	int
:	O
if	O
(	O
op	pointer
->	O
t	union
.	O
oint	struct
.	O
var	pointer
)	O
{	O
*	O
(	O
op	pointer
->	O
t	union
.	O
oint	struct
.	O
var	pointer
)	O
=	O
op	pointer
->	O
t	union
.	O
oint	struct
.	O
default_value	enum
;	O
}	O
else	O
{	O
(	O
*	O
(	O
op	pointer
->	O
t	union
.	O
oint	struct
.	O
set_default	pointer
)	O
)	O
(	O
op	pointer
->	O
t	union
.	O
oint	struct
.	O
default_value	enum
)	O
;	O
}	O
break	O
;	O
case	O
STRING	int
:	O
if	O
(	O
op	pointer
->	O
t	union
.	O
ostrng	struct
.	O
var	pointer
)	O
{	O
if	O
(	O
op	pointer
->	O
t	union
.	O
ostrng	struct
.	O
default_value	enum
)	O
{	O
*	O
(	O
op	pointer
->	O
t	union
.	O
ostrng	struct
.	O
var	pointer
)	O
=	O
strdup	function
(	O
op	pointer
->	O
t	union
.	O
ostrng	struct
.	O
default_value	enum
)	O
;	O
}	O
else	O
{	O
*	O
(	O
op	pointer
->	O
t	union
.	O
ostrng	struct
.	O
var	pointer
)	O
=	O
NULL	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
op	pointer
->	O
t	union
.	O
ostrng	struct
.	O
default_value	enum
)	O
{	O
(	O
*	O
(	O
op	pointer
->	O
t	union
.	O
ostrng	struct
.	O
set_default	pointer
)	O
)	O
(	O
strdup	function
(	O
op	pointer
->	O
t	union
.	O
ostrng	struct
.	O
default_value	enum
)	O
)	O
;	O
}	O
else	O
{	O
(	O
*	O
(	O
op	pointer
->	O
t	union
.	O
ostrng	struct
.	O
set_default	pointer
)	O
)	O
(	O
NULL	O
)	O
;	O
}	O
}	O
break	O
;	O
case	O
FLAG_STRING	int
:	O
if	O
(	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
var	pointer
)	O
{	O
if	O
(	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
default_value	enum
)	O
{	O
if	O
(	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
true_value	pointer
)	O
{	O
*	O
(	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
var	pointer
)	O
=	O
strdup	function
(	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
true_value	pointer
)	O
;	O
}	O
else	O
{	O
*	O
(	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
var	pointer
)	O
=	O
NULL	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
false_value	pointer
)	O
{	O
*	O
(	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
var	pointer
)	O
=	O
strdup	function
(	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
false_value	pointer
)	O
;	O
}	O
else	O
{	O
*	O
(	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
var	pointer
)	O
=	O
NULL	O
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
default_value	enum
)	O
{	O
if	O
(	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
true_value	pointer
)	O
{	O
(	O
*	O
(	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
set_default	pointer
)	O
)	O
(	O
1	int
,	O
strdup	function
(	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
true_value	pointer
)	O
)	O
;	O
}	O
else	O
{	O
(	O
*	O
(	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
set_default	pointer
)	O
)	O
(	O
1	int
,	O
NULL	O
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
false_value	pointer
)	O
{	O
(	O
*	O
(	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
set_default	pointer
)	O
)	O
(	O
0	int
,	O
strdup	function
(	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
false_value	pointer
)	O
)	O
;	O
}	O
else	O
{	O
(	O
*	O
(	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
set_default	pointer
)	O
)	O
(	O
0	int
,	O
NULL	O
)	O
;	O
}	O
}	O
}	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
dm	function
(	O
'o'	O
,	O
3	int
,	O
"Succeeded - option %d has not been set before\n"	pointer
,	O
index	function
)	O
;	O
}	O
void	O
print_usage_msgs	function
(	O
option_class	enum
class	enum
)	O
{	O
int	O
option_index	int
;	O
switch	O
(	O
class	enum
)	O
{	O
case	O
OPT_MISC	int
:	O
printf	function
(	O
gettext	function
(	O
"Miscellaneous options:\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
OPT_PAGE_FURNITURE	int
:	O
printf	function
(	O
gettext	function
(	O
"Page furniture options:\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
OPT_TEXT_FORMAT	int
:	O
printf	function
(	O
gettext	function
(	O
"Text formatting options:\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
OPT_PRINT	int
:	O
printf	function
(	O
gettext	function
(	O
"Print selection options:\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
OPT_PAGE_FORMAT	int
:	O
printf	function
(	O
gettext	function
(	O
"Page format options:\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
OPT_OUTPUT	int
:	O
printf	function
(	O
gettext	function
(	O
"Output options:\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
for	O
(	O
option_index	int
=	O
0	int
;	O
option_index	int
<	O
next_option	int
;	O
option_index	int
++	O
)	O
{	O
option_type	struct
*	O
op	pointer
=	O
&	O
option_list	array
[	O
option_index	int
]	O
;	O
if	O
(	O
class	enum
==	O
op	pointer
->	O
class	enum
)	O
{	O
switch	O
(	O
op	pointer
->	O
type	enum
)	O
{	O
case	O
NOPARM	int
:	O
if	O
(	O
op	pointer
->	O
letter	char
)	O
printf	function
(	O
"-%c  "	pointer
,	O
op	pointer
->	O
letter	char
)	O
;	O
if	O
(	O
op	pointer
->	O
t	union
.	O
onoparm	struct
.	O
string	pointer
)	O
printf	function
(	O
"--%s"	pointer
,	O
op	pointer
->	O
t	union
.	O
onoparm	struct
.	O
string	pointer
)	O
;	O
printf	function
(	O
"\n    %s\n"	pointer
,	O
gettext	function
(	O
op	pointer
->	O
t	union
.	O
onoparm	struct
.	O
help_string	pointer
)	O
)	O
;	O
break	O
;	O
case	O
OPTIONAL	int
:	O
if	O
(	O
op	pointer
->	O
letter	char
)	O
printf	function
(	O
"-%c  "	pointer
,	O
op	pointer
->	O
letter	char
)	O
;	O
if	O
(	O
op	pointer
->	O
t	union
.	O
ooptional	struct
.	O
string	pointer
)	O
printf	function
(	O
"--%s[=<string>]"	pointer
,	O
op	pointer
->	O
t	union
.	O
ooptional	struct
.	O
string	pointer
)	O
;	O
printf	function
(	O
"\n    %s\n"	pointer
,	O
gettext	function
(	O
op	pointer
->	O
t	union
.	O
ooptional	struct
.	O
help_string	pointer
)	O
)	O
;	O
break	O
;	O
case	O
BOOLEAN	int
:	O
if	O
(	O
op	pointer
->	O
letter	char
)	O
printf	function
(	O
"-%c  "	pointer
,	O
op	pointer
->	O
letter	char
)	O
;	O
if	O
(	O
op	pointer
->	O
t	union
.	O
obool	struct
.	O
true_string	pointer
)	O
printf	function
(	O
"--%s"	pointer
,	O
op	pointer
->	O
t	union
.	O
obool	struct
.	O
true_string	pointer
)	O
;	O
printf	function
(	O
"\n    %s\n"	pointer
,	O
gettext	function
(	O
op	pointer
->	O
t	union
.	O
obool	struct
.	O
true_help_string	pointer
)	O
)	O
;	O
if	O
(	O
op	pointer
->	O
letter	char
)	O
printf	function
(	O
"--%c  "	pointer
,	O
op	pointer
->	O
letter	char
)	O
;	O
if	O
(	O
op	pointer
->	O
t	union
.	O
obool	struct
.	O
false_string	pointer
)	O
printf	function
(	O
"--%s"	pointer
,	O
op	pointer
->	O
t	union
.	O
obool	struct
.	O
false_string	pointer
)	O
;	O
printf	function
(	O
"\n    %s\n"	pointer
,	O
gettext	function
(	O
op	pointer
->	O
t	union
.	O
obool	struct
.	O
false_help_string	pointer
)	O
)	O
;	O
break	O
;	O
case	O
CHAR	int
:	O
if	O
(	O
op	pointer
->	O
letter	char
)	O
printf	function
(	O
"-%c <char>  "	pointer
,	O
op	pointer
->	O
letter	char
)	O
;	O
if	O
(	O
op	pointer
->	O
t	union
.	O
ochar	struct
.	O
string	pointer
)	O
printf	function
(	O
"--%s <char>"	pointer
,	O
op	pointer
->	O
t	union
.	O
ochar	struct
.	O
string	pointer
)	O
;	O
printf	function
(	O
"\n    %s\n"	pointer
,	O
gettext	function
(	O
op	pointer
->	O
t	union
.	O
ochar	struct
.	O
help_string	pointer
)	O
)	O
;	O
break	O
;	O
case	O
CHOICE	int
:	O
if	O
(	O
op	pointer
->	O
letter	char
)	O
printf	function
(	O
"-%c %c  "	pointer
,	O
op	pointer
->	O
letter	char
,	O
op	pointer
->	O
t	union
.	O
ochoice	struct
.	O
choice1	char
)	O
;	O
if	O
(	O
op	pointer
->	O
t	union
.	O
ochoice	struct
.	O
choice1_string	pointer
)	O
printf	function
(	O
"--%s"	pointer
,	O
op	pointer
->	O
t	union
.	O
ochoice	struct
.	O
choice1_string	pointer
)	O
;	O
printf	function
(	O
"\n    %s\n"	pointer
,	O
gettext	function
(	O
op	pointer
->	O
t	union
.	O
ochoice	struct
.	O
choice1_help_string	pointer
)	O
)	O
;	O
if	O
(	O
op	pointer
->	O
letter	char
)	O
printf	function
(	O
"-%c %c  "	pointer
,	O
op	pointer
->	O
letter	char
,	O
op	pointer
->	O
t	union
.	O
ochoice	struct
.	O
choice2	char
)	O
;	O
if	O
(	O
op	pointer
->	O
t	union
.	O
ochoice	struct
.	O
choice2_string	pointer
)	O
printf	function
(	O
"--%s"	pointer
,	O
op	pointer
->	O
t	union
.	O
ochoice	struct
.	O
choice2_string	pointer
)	O
;	O
printf	function
(	O
"\n    %s\n"	pointer
,	O
gettext	function
(	O
op	pointer
->	O
t	union
.	O
ochoice	struct
.	O
choice2_help_string	pointer
)	O
)	O
;	O
break	O
;	O
case	O
SHORT	int
:	O
if	O
(	O
op	pointer
->	O
letter	char
)	O
printf	function
(	O
"-%c <number>  "	pointer
,	O
op	pointer
->	O
letter	char
)	O
;	O
if	O
(	O
op	pointer
->	O
t	union
.	O
oshrt	struct
.	O
string	pointer
)	O
printf	function
(	O
"--%s=<number>"	pointer
,	O
op	pointer
->	O
t	union
.	O
oshrt	struct
.	O
string	pointer
)	O
;	O
printf	function
(	O
"\n    %s\n"	pointer
,	O
gettext	function
(	O
op	pointer
->	O
t	union
.	O
oshrt	struct
.	O
help_string	pointer
)	O
)	O
;	O
if	O
(	O
op	pointer
->	O
t	union
.	O
oshrt	struct
.	O
special_string	pointer
)	O
printf	function
(	O
"--%s\n    %s\n"	pointer
,	O
op	pointer
->	O
t	union
.	O
oshrt	struct
.	O
special_string	pointer
,	O
gettext	function
(	O
op	pointer
->	O
t	union
.	O
oshrt	struct
.	O
special_help_string	pointer
)	O
)	O
;	O
break	O
;	O
case	O
INT	int
:	O
if	O
(	O
op	pointer
->	O
letter	char
)	O
printf	function
(	O
"-%c <number>  "	pointer
,	O
op	pointer
->	O
letter	char
)	O
;	O
if	O
(	O
op	pointer
->	O
t	union
.	O
oint	struct
.	O
string	pointer
)	O
printf	function
(	O
"--%s=<number>"	pointer
,	O
op	pointer
->	O
t	union
.	O
oint	struct
.	O
string	pointer
)	O
;	O
printf	function
(	O
"\n    %s\n"	pointer
,	O
gettext	function
(	O
op	pointer
->	O
t	union
.	O
oint	struct
.	O
help_string	pointer
)	O
)	O
;	O
if	O
(	O
op	pointer
->	O
t	union
.	O
oint	struct
.	O
special_string	pointer
)	O
printf	function
(	O
"--%s\n    %s\n"	pointer
,	O
op	pointer
->	O
t	union
.	O
oint	struct
.	O
special_string	pointer
,	O
gettext	function
(	O
op	pointer
->	O
t	union
.	O
oint	struct
.	O
special_help_string	pointer
)	O
)	O
;	O
break	O
;	O
case	O
STRING	int
:	O
if	O
(	O
op	pointer
->	O
letter	char
)	O
printf	function
(	O
"-%c <string>  "	pointer
,	O
op	pointer
->	O
letter	char
)	O
;	O
if	O
(	O
op	pointer
->	O
t	union
.	O
ostrng	struct
.	O
string	pointer
)	O
printf	function
(	O
"--%s=<string>"	pointer
,	O
op	pointer
->	O
t	union
.	O
ostrng	struct
.	O
string	pointer
)	O
;	O
printf	function
(	O
"\n    %s\n"	pointer
,	O
gettext	function
(	O
op	pointer
->	O
t	union
.	O
ostrng	struct
.	O
help_string	pointer
)	O
)	O
;	O
break	O
;	O
case	O
FLAG_STRING	int
:	O
if	O
(	O
op	pointer
->	O
letter	char
)	O
printf	function
(	O
"-%c <string>  "	pointer
,	O
op	pointer
->	O
letter	char
)	O
;	O
if	O
(	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
set_string	pointer
)	O
printf	function
(	O
"--%s=<string>"	pointer
,	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
set_string	pointer
)	O
;	O
printf	function
(	O
"\n    %s\n"	pointer
,	O
gettext	function
(	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
set_help_string	pointer
)	O
)	O
;	O
if	O
(	O
op	pointer
->	O
letter	char
)	O
printf	function
(	O
"--%c  "	pointer
,	O
op	pointer
->	O
letter	char
)	O
;	O
if	O
(	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
set_string	pointer
)	O
printf	function
(	O
"--%s"	pointer
,	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
not_set_string	pointer
)	O
;	O
printf	function
(	O
"\n    %s\n"	pointer
,	O
gettext	function
(	O
op	pointer
->	O
t	union
.	O
oflg	struct
.	O
not_set_help_string	pointer
)	O
)	O
;	O
}	O
}	O
}	O
}	O
void	O
set_option_defaults	function
(	O
void	O
)	O
{	O
int	O
option_index	int
;	O
for	O
(	O
option_index	int
=	O
0	int
;	O
option_index	int
<	O
next_option	int
;	O
option_index	int
++	O
)	O
{	O
set_option_default	function
(	O
option_index	int
)	O
;	O
}	O
}	O
