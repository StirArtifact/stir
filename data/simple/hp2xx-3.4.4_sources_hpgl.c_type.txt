LineType	enum
CurrentLineType	enum
=	O
LT_solid	int
;	O
short	O
scale_flag	int
=	O
FALSE	int
;	O
short	O
record_off	short
=	O
FALSE	int
;	O
long	O
vec_cntr_w	long
=	O
0L	int
;	O
long	O
n_commands	long
=	O
0L	int
;	O
short	O
silent_mode	short
=	O
FALSE	int
;	O
FILE	struct
*	O
td	pointer
;	O
HPGL_Pt	struct
HP_pos	struct
=	O
{	O
0	int
,	O
0	int
}	O
;	O
HPGL_Pt	struct
P1	struct
=	O
{	O
P1X_default	int
,	O
P1Y_default	int
}	O
;	O
HPGL_Pt	struct
P2	struct
=	O
{	O
P2X_default	int
,	O
P2Y_default	int
}	O
;	O
int	O
iwflag	int
=	O
0	int
;	O
int	O
mode_vert	int
=	O
0	int
;	O
HPGL_Pt	struct
C1	struct
=	O
{	O
P1X_default	int
,	O
P1Y_default	int
}	O
;	O
HPGL_Pt	struct
C2	struct
=	O
{	O
P2X_default	int
,	O
P2Y_default	int
}	O
;	O
HPGL_Pt	struct
S1	struct
=	O
{	O
P1X_default	int
,	O
P1Y_default	int
}	O
;	O
HPGL_Pt	struct
S2	struct
=	O
{	O
P2X_default	int
,	O
P2Y_default	int
}	O
;	O
HPGL_Pt	struct
Q	struct
=	O
{	O
1.	int
,	O
1.	int
}	O
;	O
HPGL_Pt	struct
M	struct
;	O
extern	O
TextPar	pointer
tp	pointer
;	O
static	O
float	O
xmin	double
,	O
xmax	double
,	O
ymin	double
,	O
ymax	double
,	O
neg_ticklen	float
,	O
pos_ticklen	float
;	O
static	O
double	O
Diag_P1_P2	double
,	O
pat_pos	double
;	O
static	O
HPGL_Pt	struct
p_last	struct
=	O
{	O
M_PI	int
,	O
M_PI	int
}	O
;	O
static	O
HPGL_Pt	struct
polygons	array
[	O
MAXPOLY	int
]	O
;	O
static	O
int	O
vertices	int
=	O
-	O
1	int
;	O
static	O
short	O
polygon_mode	short
=	O
FALSE	int
;	O
static	O
int	O
filltype	int
=	O
1	int
;	O
static	O
float	O
hatchspace	float
=	O
0.	int
;	O
static	O
float	O
hatchangle	float
=	O
0.	int
;	O
static	O
float	O
saved_hatchspace	array
[	O
2	int
]	O
=	O
{	O
0.	int
,	O
0.	int
}	O
;	O
static	O
float	O
saved_hatchangle	array
[	O
2	int
]	O
=	O
{	O
0.	int
,	O
0.	int
}	O
;	O
static	O
float	O
thickness	float
=	O
0.	int
;	O
static	O
short	O
polygon_penup	short
=	O
FALSE	int
;	O
static	O
HPGL_Pt	struct
anchor	struct
=	O
{	O
100000.0	int
,	O
100000.0	int
}	O
;	O
static	O
HPGL_Pt	struct
polystart	struct
=	O
{	O
0.0	int
,	O
0.0	int
}	O
;	O
static	O
float	O
rot_cos	float
,	O
rot_sin	float
;	O
static	O
short	O
rotate_flag	short
=	O
FALSE	int
;	O
static	O
short	O
ps_flag	short
=	O
FALSE	int
;	O
static	O
short	O
ac_flag	short
=	O
FALSE	int
;	O
static	O
double	O
rot_ang	double
=	O
0.	int
;	O
static	O
double	O
rot_tmp	double
=	O
0.	int
;	O
static	O
short	O
mv_flag	short
=	O
FALSE	int
;	O
static	O
short	O
pg_flag	short
=	O
FALSE	int
;	O
static	O
short	O
ct_dist	short
=	O
FALSE	int
;	O
static	O
short	O
fixedcolor	short
=	O
FALSE	int
;	O
static	O
short	O
fixedwidth	short
=	O
FALSE	int
;	O
static	O
int	O
first_page	int
=	O
0	int
;	O
static	O
int	O
last_page	int
=	O
0	int
;	O
static	O
int	O
n_unexpected	int
=	O
0	int
;	O
static	O
int	O
n_unknown	int
=	O
0	int
;	O
static	O
int	O
page_number	int
=	O
1	int
;	O
static	O
long	O
vec_cntr_r	long
=	O
0L	int
;	O
static	O
short	O
pen	int
=	O
-	O
1	int
;	O
static	O
short	O
pens_in_use	array
[	O
NUMPENS	int
]	O
;	O
static	O
short	O
pen_down	short
=	O
FALSE	int
;	O
static	O
short	O
plot_rel	short
=	O
FALSE	int
;	O
static	O
short	O
saved_penstate	short
=	O
FALSE	int
;	O
static	O
short	O
wu_relative	short
=	O
FALSE	int
;	O
static	O
int	O
again	int
=	O
FALSE	int
;	O
static	O
char	O
StrTerm	char
=	O
ETX	char
;	O
static	O
short	O
StrTermSilent	short
=	O
1	int
;	O
static	O
char	O
*	O
strbuf	pointer
=	O
NULL	O
;	O
static	O
unsigned	O
int	O
strbufsize	int
=	O
MAX_LB_LEN	int
+	O
1	int
;	O
static	O
char	O
symbol_char	char
=	O
'\0'	O
;	O
static	O
unsigned	O
char	O
r_base	char
=	O
0	int
;	O
static	O
unsigned	O
char	O
g_base	char
=	O
0	int
;	O
static	O
unsigned	O
char	O
b_base	char
=	O
0	int
;	O
static	O
unsigned	O
char	O
r_max	char
=	O
255	int
;	O
static	O
unsigned	O
char	O
g_max	char
=	O
255	int
;	O
static	O
unsigned	O
char	O
b_max	char
=	O
255	int
;	O
static	O
void	O
par_err_exit	function
(	O
int	O
code	int
,	O
int	O
cmd	enum
,	O
FILE	struct
*	O
hd	pointer
)	O
{	O
const	O
char	O
*	O
msg	pointer
;	O
char	O
tmpstr	array
[	O
21	int
]	O
;	O
switch	O
(	O
code	int
)	O
{	O
case	O
0	int
:	O
msg	pointer
=	O
"Illegal parameters"	pointer
;	O
break	O
;	O
case	O
1	int
:	O
msg	pointer
=	O
"Error in first parameter"	pointer
;	O
break	O
;	O
case	O
2	int
:	O
msg	pointer
=	O
"No second parameter"	pointer
;	O
break	O
;	O
case	O
3	int
:	O
msg	pointer
=	O
"No third parameter"	pointer
;	O
break	O
;	O
case	O
4	int
:	O
msg	pointer
=	O
"No fourth parameter"	pointer
;	O
break	O
;	O
case	O
98	int
:	O
msg	pointer
=	O
"sscanf error: corrupted file?"	pointer
;	O
break	O
;	O
case	O
99	int
:	O
default	O
:	O
msg	pointer
=	O
"Internal error"	pointer
;	O
break	O
;	O
}	O
Eprintf	function
(	O
"\nError in command %c%c: %s\n"	pointer
,	O
cmd	enum
>>	O
8	int
,	O
cmd	enum
&	O
0xFF	int
,	O
msg	pointer
)	O
;	O
Eprintf	function
(	O
" @ Cmd %ld\n"	pointer
,	O
vec_cntr_w	long
)	O
;	O
fseek	function
(	O
hd	pointer
,	O
-	O
10L	int
,	O
SEEK_CUR	int
)	O
;	O
read_string	function
(	O
tmpstr	array
,	O
hd	pointer
)	O
;	O
tmpstr	array
[	O
20	int
]	O
=	O
'\0'	O
;	O
Eprintf	function
(	O
" lately read: %s\n"	pointer
,	O
tmpstr	array
)	O
;	O
exit	function
(	O
ERROR	O
)	O
;	O
}	O
static	O
void	O
reset_HPGL	function
(	O
void	O
)	O
{	O
int	O
i	int
;	O
p_last	struct
.	O
x	int
=	O
p_last	struct
.	O
y	int
=	O
M_PI	int
;	O
pen_down	short
=	O
FALSE	int
;	O
plot_rel	short
=	O
FALSE	int
;	O
pen	int
=	O
-	O
1	int
;	O
mv_flag	short
=	O
FALSE	int
;	O
wu_relative	short
=	O
FALSE	int
;	O
pg_flag	short
=	O
FALSE	int
;	O
iwflag	int
=	O
FALSE	int
;	O
ps_flag	short
=	O
FALSE	int
;	O
ac_flag	short
=	O
FALSE	int
;	O
filltype	int
=	O
1	int
;	O
saved_hatchangle	array
[	O
0	int
]	O
=	O
saved_hatchangle	array
[	O
1	int
]	O
=	O
0.	int
;	O
saved_hatchspace	array
[	O
0	int
]	O
=	O
saved_hatchspace	array
[	O
1	int
]	O
=	O
0.	int
;	O
ct_dist	short
=	O
FALSE	int
;	O
CurrentLineType	enum
=	O
LT_solid	int
;	O
set_line_style_defaults	function
(	O
)	O
;	O
CurrentLineAttr	struct
.	O
Join	enum
=	O
LAJ_plain_miter	int
;	O
CurrentLineAttr	struct
.	O
End	enum
=	O
LAE_butt	int
;	O
CurrentLineAttr	struct
.	O
Limit	int
=	O
5	int
;	O
tp	pointer
->	O
sstrokewidth	double
=	O
tp	pointer
->	O
astrokewidth	double
=	O
tp	pointer
->	O
strokewidth	double
=	O
0.11	int
;	O
StrTerm	char
=	O
ETX	char
;	O
StrTermSilent	short
=	O
1	int
;	O
if	O
(	O
strbuf	pointer
==	O
NULL	O
)	O
{	O
strbuf	pointer
=	O
malloc	function
(	O
strbufsize	int
)	O
;	O
if	O
(	O
strbuf	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"\nNo memory !\n"	pointer
)	O
;	O
exit	function
(	O
ERROR	O
)	O
;	O
}	O
}	O
strbuf	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
P1	struct
.	O
x	int
=	O
P1X_default	int
;	O
P1	struct
.	O
y	int
=	O
P1Y_default	int
;	O
Diag_P1_P2	double
=	O
HYPOT	O
(	O
P2	struct
.	O
x	int
-	O
P1	struct
.	O
x	int
,	O
P2	struct
.	O
y	int
-	O
P1	struct
.	O
y	int
)	O
;	O
CurrentLinePatLen	double
=	O
0.04	int
*	O
Diag_P1_P2	double
;	O
pat_pos	double
=	O
0.0	int
;	O
scale_flag	int
=	O
FALSE	int
;	O
S1	struct
=	O
P1	struct
;	O
S2	struct
=	O
P2	struct
;	O
Q	struct
.	O
x	int
=	O
Q	struct
.	O
y	int
=	O
1.0	int
;	O
HP_pos	struct
.	O
x	int
=	O
HP_pos	struct
.	O
y	int
=	O
0.0	int
;	O
neg_ticklen	float
=	O
0.005	int
;	O
pos_ticklen	float
=	O
0.005	int
;	O
symbol_char	char
=	O
'\0'	O
;	O
rot_ang	double
-=	O
rot_tmp	double
;	O
rot_tmp	double
=	O
0.	int
;	O
if	O
(	O
rot_ang	double
==	O
0.	int
)	O
rotate_flag	short
=	O
FALSE	int
;	O
if	O
(	O
rotate_flag	short
)	O
{	O
rot_cos	float
=	O
cos	function
(	O
M_PI	int
*	O
rot_ang	double
/	O
180.0	int
)	O
;	O
rot_sin	float
=	O
sin	function
(	O
M_PI	int
*	O
rot_ang	double
/	O
180.0	int
)	O
;	O
}	O
init_text_par	function
(	O
)	O
;	O
if	O
(	O
fixedcolor	short
==	O
FALSE	int
)	O
{	O
set_color_rgb	function
(	O
xxBackground	int
,	O
255	int
,	O
255	int
,	O
255	int
)	O
;	O
set_color_rgb	function
(	O
xxForeground	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
set_color_rgb	function
(	O
xxRed	int
,	O
255	int
,	O
0	int
,	O
0	int
)	O
;	O
set_color_rgb	function
(	O
xxGreen	int
,	O
0	int
,	O
255	int
,	O
0	int
)	O
;	O
set_color_rgb	function
(	O
xxBlue	int
,	O
0	int
,	O
0	int
,	O
255	int
)	O
;	O
set_color_rgb	function
(	O
xxCyan	int
,	O
0	int
,	O
255	int
,	O
255	int
)	O
;	O
set_color_rgb	function
(	O
xxMagenta	int
,	O
255	int
,	O
0	int
,	O
255	int
)	O
;	O
set_color_rgb	function
(	O
xxYellow	int
,	O
255	int
,	O
255	int
,	O
0	int
)	O
;	O
pt	struct
.	O
color	array
[	O
0	int
]	O
=	O
xxBackground	int
;	O
pt	struct
.	O
color	array
[	O
1	int
]	O
=	O
xxForeground	int
;	O
pt	struct
.	O
color	array
[	O
2	int
]	O
=	O
xxRed	int
;	O
pt	struct
.	O
color	array
[	O
3	int
]	O
=	O
xxGreen	int
;	O
pt	struct
.	O
color	array
[	O
4	int
]	O
=	O
xxBlue	int
;	O
pt	struct
.	O
color	array
[	O
5	int
]	O
=	O
xxCyan	int
;	O
pt	struct
.	O
color	array
[	O
6	int
]	O
=	O
xxMagenta	int
;	O
pt	struct
.	O
color	array
[	O
7	int
]	O
=	O
xxYellow	int
;	O
}	O
if	O
(	O
fixedwidth	short
==	O
FALSE	int
)	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
8	int
;	O
i	int
++	O
)	O
pt	struct
.	O
width	array
[	O
i	int
]	O
=	O
0.1	int
;	O
record_off	short
=	O
(	O
first_page	int
>	O
page_number	int
)	O
||	O
(	O
(	O
last_page	int
<	O
page_number	int
)	O
&&	O
(	O
last_page	int
>	O
0	int
)	O
)	O
;	O
}	O
static	O
void	O
init_HPGL	function
(	O
GEN_PAR	struct
*	O
pg	pointer
,	O
const	O
IN_PAR	struct
*	O
pi	pointer
)	O
{	O
td	pointer
=	O
pg	pointer
->	O
td	pointer
;	O
silent_mode	short
=	O
(	O
short	O
)	O
pg	pointer
->	O
quiet	int
;	O
xmin	double
=	O
pi	pointer
->	O
x0	double
;	O
ymin	double
=	O
pi	pointer
->	O
y0	function
;	O
xmax	double
=	O
pi	pointer
->	O
x1	double
;	O
ymax	double
=	O
pi	pointer
->	O
y1	function
;	O
fixedcolor	short
=	O
(	O
short	O
)	O
pi	pointer
->	O
hwcolor	int
;	O
fixedwidth	short
=	O
(	O
short	O
)	O
pi	pointer
->	O
hwsize	int
;	O
r_base	char
=	O
g_base	char
=	O
b_base	char
=	O
0	int
;	O
r_max	char
=	O
g_max	char
=	O
b_max	char
=	O
255	int
;	O
pg	pointer
->	O
maxpens	int
=	O
8	int
;	O
pg	pointer
->	O
maxcolor	int
=	O
1	int
;	O
memset	function
(	O
pens_in_use	array
,	O
0	int
,	O
NUMPENS	int
*	O
sizeof	O
(	O
short	O
)	O
)	O
;	O
first_page	int
=	O
pi	pointer
->	O
first_page	int
;	O
last_page	int
=	O
pi	pointer
->	O
last_page	int
;	O
record_off	short
=	O
(	O
first_page	int
>	O
page_number	int
)	O
||	O
(	O
(	O
last_page	int
<	O
page_number	int
)	O
&&	O
(	O
last_page	int
>	O
0	int
)	O
)	O
;	O
rot_ang	double
=	O
pi	pointer
->	O
rotation	double
;	O
rotate_flag	short
=	O
(	O
rot_ang	double
!=	O
0.0	int
)	O
?	O
TRUE	int
:	O
FALSE	int
;	O
if	O
(	O
rotate_flag	short
)	O
{	O
rot_cos	float
=	O
cos	function
(	O
M_PI	int
*	O
rot_ang	double
/	O
180.0	int
)	O
;	O
rot_sin	float
=	O
sin	function
(	O
M_PI	int
*	O
rot_ang	double
/	O
180.0	int
)	O
;	O
}	O
vec_cntr_r	long
=	O
0L	int
;	O
vec_cntr_w	long
=	O
0L	int
;	O
n_unexpected	int
=	O
0	int
;	O
n_commands	long
=	O
0	int
;	O
n_unknown	int
=	O
0	int
;	O
if	O
(	O
pi	pointer
->	O
hwlimit	struct
.	O
x	int
>	O
0.	int
)	O
P2	struct
.	O
x	int
=	O
S2	struct
.	O
x	int
=	O
pi	pointer
->	O
hwlimit	struct
.	O
x	int
;	O
if	O
(	O
pi	pointer
->	O
hwlimit	struct
.	O
y	int
>	O
0.	int
)	O
P2	struct
.	O
y	int
=	O
S2	struct
.	O
y	int
=	O
pi	pointer
->	O
hwlimit	struct
.	O
y	int
;	O
reset_HPGL	function
(	O
)	O
;	O
}	O
static	O
void	O
User_to_Plotter_coord	function
(	O
const	O
HPGL_Pt	struct
*	O
p_usr	pointer
,	O
HPGL_Pt	struct
*	O
p_plot	pointer
)	O
{	O
p_plot	pointer
->	O
x	int
=	O
P1	struct
.	O
x	int
+	O
(	O
p_usr	pointer
->	O
x	int
-	O
S1	struct
.	O
x	int
)	O
*	O
Q	struct
.	O
x	int
;	O
p_plot	pointer
->	O
y	int
=	O
P1	struct
.	O
y	int
+	O
(	O
p_usr	pointer
->	O
y	int
-	O
S1	struct
.	O
y	int
)	O
*	O
Q	struct
.	O
y	int
;	O
}	O
static	O
void	O
Plotter_to_User_coord	function
(	O
const	O
HPGL_Pt	struct
*	O
p_plot	pointer
,	O
HPGL_Pt	struct
*	O
p_usr	pointer
)	O
{	O
p_usr	pointer
->	O
x	int
=	O
S1	struct
.	O
x	int
+	O
(	O
p_plot	pointer
->	O
x	int
-	O
P1	struct
.	O
x	int
)	O
/	O
Q	struct
.	O
x	int
;	O
p_usr	pointer
->	O
y	int
=	O
S1	struct
.	O
y	int
+	O
(	O
p_plot	pointer
->	O
y	int
-	O
P1	struct
.	O
y	int
)	O
/	O
Q	struct
.	O
y	int
;	O
}	O
void	O
PlotCmd_to_tmpfile	function
(	O
PlotCmd	enum
cmd	enum
)	O
{	O
if	O
(	O
record_off	short
)	O
return	O
;	O
if	O
(	O
!	O
silent_mode	short
)	O
switch	O
(	O
vec_cntr_w	long
++	O
)	O
{	O
case	O
0	int
:	O
Eprintf	function
(	O
"Writing Cmd: "	pointer
)	O
;	O
break	O
;	O
case	O
1	int
:	O
Eprintf	function
(	O
"1 "	pointer
)	O
;	O
break	O
;	O
case	O
2	int
:	O
Eprintf	function
(	O
"2 "	pointer
)	O
;	O
break	O
;	O
case	O
5	int
:	O
Eprintf	function
(	O
"5 "	pointer
)	O
;	O
break	O
;	O
case	O
10	int
:	O
Eprintf	function
(	O
"10 "	pointer
)	O
;	O
break	O
;	O
case	O
20	int
:	O
Eprintf	function
(	O
"20 "	pointer
)	O
;	O
break	O
;	O
case	O
50	int
:	O
Eprintf	function
(	O
"50 "	pointer
)	O
;	O
break	O
;	O
case	O
100	int
:	O
Eprintf	function
(	O
"100 "	pointer
)	O
;	O
break	O
;	O
case	O
200	int
:	O
Eprintf	function
(	O
"200 "	pointer
)	O
;	O
break	O
;	O
case	O
500	int
:	O
Eprintf	function
(	O
"500 "	pointer
)	O
;	O
break	O
;	O
case	O
1000	int
:	O
Eprintf	function
(	O
"1k "	pointer
)	O
;	O
break	O
;	O
case	O
2000	int
:	O
Eprintf	function
(	O
"2k "	pointer
)	O
;	O
break	O
;	O
case	O
5000	int
:	O
Eprintf	function
(	O
"5k "	pointer
)	O
;	O
break	O
;	O
case	O
10000	int
:	O
Eprintf	function
(	O
"10k "	pointer
)	O
;	O
break	O
;	O
case	O
20000	int
:	O
Eprintf	function
(	O
"20k "	pointer
)	O
;	O
break	O
;	O
case	O
50000L	int
:	O
Eprintf	function
(	O
"50k "	pointer
)	O
;	O
break	O
;	O
case	O
100000L	int
:	O
Eprintf	function
(	O
"100k "	pointer
)	O
;	O
break	O
;	O
case	O
200000L	int
:	O
Eprintf	function
(	O
"200k "	pointer
)	O
;	O
break	O
;	O
case	O
500000L	int
:	O
Eprintf	function
(	O
"500k "	pointer
)	O
;	O
break	O
;	O
case	O
1000000L	int
:	O
Eprintf	function
(	O
"1000k "	pointer
)	O
;	O
break	O
;	O
case	O
2000000L	int
:	O
Eprintf	function
(	O
"2000k "	pointer
)	O
;	O
break	O
;	O
case	O
3000000L	int
:	O
Eprintf	function
(	O
"3000k "	pointer
)	O
;	O
break	O
;	O
case	O
4000000L	int
:	O
Eprintf	function
(	O
"4000k "	pointer
)	O
;	O
break	O
;	O
case	O
5000000L	int
:	O
Eprintf	function
(	O
"5000k... "	pointer
)	O
;	O
break	O
;	O
case	O
10000000L	int
:	O
Eprintf	function
(	O
"10000k "	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
fputc	function
(	O
(	O
int	O
)	O
cmd	enum
,	O
td	pointer
)	O
==	O
EOF	O
)	O
{	O
PError	function
(	O
"PlotCmd_to_tmpfile"	pointer
)	O
;	O
Eprintf	function
(	O
"Error @ Cmd %ld\n"	pointer
,	O
vec_cntr_w	long
)	O
;	O
exit	function
(	O
ERROR	O
)	O
;	O
}	O
}	O
void	O
HPGL_Pt_to_tmpfile	function
(	O
const	O
HPGL_Pt	struct
*	O
pf	pointer
)	O
{	O
if	O
(	O
record_off	short
)	O
return	O
;	O
if	O
(	O
fwrite	function
(	O
(	O
VOID	void
*	O
)	O
pf	pointer
,	O
sizeof	O
(	O
*	O
pf	pointer
)	O
,	O
1	int
,	O
td	pointer
)	O
!=	O
1	int
)	O
{	O
PError	function
(	O
"HPGL_Pt_to_tmpfile"	pointer
)	O
;	O
Eprintf	function
(	O
"Error @ Cmd %ld\n"	pointer
,	O
vec_cntr_w	long
)	O
;	O
exit	function
(	O
ERROR	O
)	O
;	O
}	O
xmin	double
=	O
MIN	O
(	O
pf	pointer
->	O
x	int
,	O
xmin	double
)	O
;	O
ymin	double
=	O
MIN	O
(	O
pf	pointer
->	O
y	int
,	O
ymin	double
)	O
;	O
xmax	double
=	O
MAX	O
(	O
pf	pointer
->	O
x	int
,	O
xmax	double
)	O
;	O
ymax	double
=	O
MAX	O
(	O
pf	pointer
->	O
y	int
,	O
ymax	double
)	O
;	O
}	O
void	O
HPGL_Pt_to_polygon	function
(	O
HPGL_Pt	struct
pf	pointer
)	O
{	O
if	O
(	O
record_off	short
)	O
return	O
;	O
polygons	array
[	O
++	O
vertices	int
]	O
=	O
pf	pointer
;	O
if	O
(	O
rotate_flag	short
)	O
{	O
double	O
tmp	double
=	O
rot_cos	float
*	O
pf	pointer
.	O
x	int
-	O
rot_sin	float
*	O
pf	pointer
.	O
y	int
;	O
pf	pointer
.	O
y	int
=	O
rot_sin	float
*	O
pf	pointer
.	O
x	int
+	O
rot_cos	float
*	O
pf	pointer
.	O
y	int
;	O
pf	pointer
.	O
x	int
=	O
tmp	double
;	O
}	O
xmin	double
=	O
MIN	O
(	O
pf	pointer
.	O
x	int
,	O
xmin	double
)	O
;	O
ymin	double
=	O
MIN	O
(	O
pf	pointer
.	O
y	int
,	O
ymin	double
)	O
;	O
xmax	double
=	O
MAX	O
(	O
pf	pointer
.	O
x	int
,	O
xmax	double
)	O
;	O
ymax	double
=	O
MAX	O
(	O
pf	pointer
.	O
y	int
,	O
ymax	double
)	O
;	O
}	O
static	O
void	O
LPattern_Generator	function
(	O
HPGL_Pt	struct
*	O
pa	pointer
,	O
double	O
dx	double
,	O
double	O
dy	double
,	O
double	O
start_of_pat	double
,	O
double	O
end_of_pat	double
)	O
{	O
double	O
length_of_ele	double
,	O
start_of_action	double
,	O
end_of_action	double
;	O
static	O
double	O
*	O
p_cur_pat	pointer
;	O
p_cur_pat	pointer
=	O
lt	array
[	O
(	O
LT_MIN	O
*	O
-	O
1	int
)	O
+	O
(	O
int	O
)	O
CurrentLinePattern	int
]	O
;	O
if	O
(	O
CurrentLineType	enum
==	O
LT_adaptive	int
)	O
for	O
(	O
;	O
;	O
)	O
{	O
length_of_ele	double
=	O
(	O
double	O
)	O
*	O
p_cur_pat	pointer
++	O
/	O
100	int
;	O
if	O
(	O
length_of_ele	double
<	O
0.	int
)	O
return	O
;	O
if	O
(	O
length_of_ele	double
<	O
1.e-5	int
)	O
PlotCmd_to_tmpfile	function
(	O
PLOT_AT	int
)	O
;	O
else	O
PlotCmd_to_tmpfile	function
(	O
DRAW_TO	int
)	O
;	O
pa	pointer
->	O
x	int
+=	O
dx	double
*	O
length_of_ele	double
;	O
pa	pointer
->	O
y	int
+=	O
dy	double
*	O
length_of_ele	double
;	O
HPGL_Pt_to_tmpfile	function
(	O
pa	pointer
)	O
;	O
length_of_ele	double
=	O
(	O
double	O
)	O
*	O
p_cur_pat	pointer
++	O
/	O
100	int
;	O
if	O
(	O
length_of_ele	double
<	O
0.	int
)	O
return	O
;	O
pa	pointer
->	O
x	int
+=	O
dx	double
*	O
length_of_ele	double
;	O
pa	pointer
->	O
y	int
+=	O
dy	double
*	O
length_of_ele	double
;	O
PlotCmd_to_tmpfile	function
(	O
MOVE_TO	int
)	O
;	O
HPGL_Pt_to_tmpfile	function
(	O
pa	pointer
)	O
;	O
}	O
else	O
for	O
(	O
end_of_action	double
=	O
0.0	int
;	O
;	O
)	O
{	O
start_of_action	double
=	O
end_of_action	double
;	O
length_of_ele	double
=	O
(	O
double	O
)	O
*	O
p_cur_pat	pointer
++	O
/	O
100	int
;	O
if	O
(	O
length_of_ele	double
<	O
0.	int
)	O
return	O
;	O
if	O
(	O
length_of_ele	double
<	O
1.e-5	int
)	O
{	O
PlotCmd_to_tmpfile	function
(	O
PLOT_AT	int
)	O
;	O
HPGL_Pt_to_tmpfile	function
(	O
pa	pointer
)	O
;	O
}	O
else	O
{	O
end_of_action	double
+=	O
length_of_ele	double
;	O
if	O
(	O
end_of_action	double
>	O
start_of_pat	double
)	O
{	O
if	O
(	O
start_of_pat	double
<=	O
start_of_action	double
)	O
{	O
if	O
(	O
end_of_action	double
<=	O
end_of_pat	double
)	O
{	O
pa	pointer
->	O
x	int
+=	O
dx	double
*	O
length_of_ele	double
;	O
pa	pointer
->	O
y	int
+=	O
dy	double
*	O
length_of_ele	double
;	O
PlotCmd_to_tmpfile	function
(	O
DRAW_TO	int
)	O
;	O
HPGL_Pt_to_tmpfile	function
(	O
pa	pointer
)	O
;	O
}	O
else	O
{	O
pa	pointer
->	O
x	int
+=	O
dx	double
*	O
(	O
end_of_pat	double
-	O
start_of_action	double
)	O
;	O
pa	pointer
->	O
y	int
+=	O
dy	double
*	O
(	O
end_of_pat	double
-	O
start_of_action	double
)	O
;	O
PlotCmd_to_tmpfile	function
(	O
DRAW_TO	int
)	O
;	O
HPGL_Pt_to_tmpfile	function
(	O
pa	pointer
)	O
;	O
return	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
end_of_action	double
<=	O
end_of_pat	double
)	O
{	O
pa	pointer
->	O
x	int
+=	O
dx	double
*	O
(	O
end_of_action	double
-	O
start_of_pat	double
)	O
;	O
pa	pointer
->	O
y	int
+=	O
dy	double
*	O
(	O
end_of_action	double
-	O
start_of_pat	double
)	O
;	O
PlotCmd_to_tmpfile	function
(	O
DRAW_TO	int
)	O
;	O
HPGL_Pt_to_tmpfile	function
(	O
pa	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
end_of_pat	double
==	O
start_of_pat	double
)	O
PlotCmd_to_tmpfile	function
(	O
PLOT_AT	int
)	O
;	O
else	O
PlotCmd_to_tmpfile	function
(	O
DRAW_TO	int
)	O
;	O
pa	pointer
->	O
x	int
+=	O
dx	double
*	O
(	O
end_of_pat	double
-	O
start_of_pat	double
)	O
;	O
pa	pointer
->	O
y	int
+=	O
dy	double
*	O
(	O
end_of_pat	double
-	O
start_of_pat	double
)	O
;	O
HPGL_Pt_to_tmpfile	function
(	O
pa	pointer
)	O
;	O
return	O
;	O
}	O
}	O
}	O
}	O
start_of_action	double
=	O
end_of_action	double
;	O
length_of_ele	double
=	O
(	O
double	O
)	O
*	O
p_cur_pat	pointer
++	O
/	O
100	int
;	O
if	O
(	O
length_of_ele	double
<	O
0	int
)	O
return	O
;	O
end_of_action	double
+=	O
length_of_ele	double
;	O
if	O
(	O
end_of_action	double
>	O
start_of_pat	double
)	O
{	O
if	O
(	O
start_of_pat	double
<=	O
start_of_action	double
)	O
{	O
if	O
(	O
end_of_action	double
<=	O
end_of_pat	double
)	O
{	O
pa	pointer
->	O
x	int
+=	O
dx	double
*	O
length_of_ele	double
;	O
pa	pointer
->	O
y	int
+=	O
dy	double
*	O
length_of_ele	double
;	O
PlotCmd_to_tmpfile	function
(	O
MOVE_TO	int
)	O
;	O
HPGL_Pt_to_tmpfile	function
(	O
pa	pointer
)	O
;	O
}	O
else	O
{	O
pa	pointer
->	O
x	int
+=	O
dx	double
*	O
(	O
end_of_pat	double
-	O
start_of_action	double
)	O
;	O
pa	pointer
->	O
y	int
+=	O
dy	double
*	O
(	O
end_of_pat	double
-	O
start_of_action	double
)	O
;	O
PlotCmd_to_tmpfile	function
(	O
MOVE_TO	int
)	O
;	O
HPGL_Pt_to_tmpfile	function
(	O
pa	pointer
)	O
;	O
return	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
end_of_action	double
<=	O
end_of_pat	double
)	O
{	O
pa	pointer
->	O
x	int
+=	O
dx	double
*	O
(	O
end_of_action	double
-	O
start_of_pat	double
)	O
;	O
pa	pointer
->	O
y	int
+=	O
dy	double
*	O
(	O
end_of_action	double
-	O
start_of_pat	double
)	O
;	O
PlotCmd_to_tmpfile	function
(	O
MOVE_TO	int
)	O
;	O
HPGL_Pt_to_tmpfile	function
(	O
pa	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
end_of_pat	double
==	O
start_of_pat	double
)	O
return	O
;	O
pa	pointer
->	O
x	int
+=	O
dx	double
*	O
(	O
end_of_pat	double
-	O
start_of_pat	double
)	O
;	O
pa	pointer
->	O
y	int
+=	O
dy	double
*	O
(	O
end_of_pat	double
-	O
start_of_pat	double
)	O
;	O
PlotCmd_to_tmpfile	function
(	O
MOVE_TO	int
)	O
;	O
HPGL_Pt_to_tmpfile	function
(	O
pa	pointer
)	O
;	O
return	O
;	O
}	O
}	O
}	O
}	O
}	O
static	O
void	O
rect	int
(	O
int	O
relative	int
,	O
int	O
filled	int
,	O
float	O
cur_pensize	float
,	O
HPGL_Pt	struct
p	struct
)	O
{	O
HPGL_Pt	struct
p1	struct
;	O
if	O
(	O
relative	int
)	O
{	O
p	struct
.	O
x	int
+=	O
p_last	struct
.	O
x	int
;	O
p	struct
.	O
y	int
+=	O
p_last	struct
.	O
y	int
;	O
}	O
if	O
(	O
!	O
filled	int
)	O
{	O
p1	struct
.	O
x	int
=	O
p_last	struct
.	O
x	int
;	O
p1	struct
.	O
y	int
=	O
p	struct
.	O
y	int
;	O
Pen_action_to_tmpfile	function
(	O
DRAW_TO	int
,	O
&	O
p1	struct
,	O
scale_flag	int
)	O
;	O
p1	struct
.	O
x	int
=	O
p	struct
.	O
x	int
;	O
p1	struct
.	O
y	int
=	O
p	struct
.	O
y	int
;	O
Pen_action_to_tmpfile	function
(	O
DRAW_TO	int
,	O
&	O
p1	struct
,	O
scale_flag	int
)	O
;	O
p1	struct
.	O
x	int
=	O
p	struct
.	O
x	int
;	O
p1	struct
.	O
y	int
=	O
p_last	struct
.	O
y	int
;	O
Pen_action_to_tmpfile	function
(	O
DRAW_TO	int
,	O
&	O
p1	struct
,	O
scale_flag	int
)	O
;	O
p1	struct
.	O
x	int
=	O
p_last	struct
.	O
x	int
;	O
p1	struct
.	O
y	int
=	O
p_last	struct
.	O
y	int
;	O
Pen_action_to_tmpfile	function
(	O
DRAW_TO	int
,	O
&	O
p1	struct
,	O
scale_flag	int
)	O
;	O
}	O
else	O
{	O
vertices	int
=	O
-	O
1	int
;	O
HPGL_Pt_to_polygon	function
(	O
p_last	struct
)	O
;	O
p1	struct
.	O
x	int
=	O
p_last	struct
.	O
x	int
;	O
p1	struct
.	O
y	int
=	O
p	struct
.	O
y	int
;	O
HPGL_Pt_to_polygon	function
(	O
p1	struct
)	O
;	O
HPGL_Pt_to_polygon	function
(	O
p1	struct
)	O
;	O
HPGL_Pt_to_polygon	function
(	O
p	struct
)	O
;	O
HPGL_Pt_to_polygon	function
(	O
p	struct
)	O
;	O
p1	struct
.	O
x	int
=	O
p	struct
.	O
x	int
;	O
p1	struct
.	O
y	int
=	O
p_last	struct
.	O
y	int
;	O
HPGL_Pt_to_polygon	function
(	O
p1	struct
)	O
;	O
HPGL_Pt_to_polygon	function
(	O
p1	struct
)	O
;	O
HPGL_Pt_to_polygon	function
(	O
p_last	struct
)	O
;	O
if	O
(	O
hatchspace	float
==	O
0.	int
)	O
hatchspace	float
=	O
cur_pensize	float
;	O
if	O
(	O
filltype	int
<	O
3	int
&&	O
thickness	float
>	O
0.	int
)	O
hatchspace	float
=	O
thickness	float
;	O
if	O
(	O
ac_flag	short
==	O
0	int
)	O
{	O
anchor	struct
.	O
x	int
=	O
P1	struct
.	O
x	int
;	O
anchor	struct
.	O
y	int
=	O
P1	struct
.	O
y	int
;	O
}	O
fill	function
(	O
polygons	array
,	O
vertices	int
,	O
anchor	struct
,	O
P2	struct
,	O
scale_flag	int
,	O
filltype	int
,	O
hatchspace	float
,	O
hatchangle	float
)	O
;	O
}	O
Pen_action_to_tmpfile	function
(	O
MOVE_TO	int
,	O
&	O
p_last	struct
,	O
scale_flag	int
)	O
;	O
}	O
static	O
void	O
rects	function
(	O
int	O
relative	int
,	O
int	O
filled	int
,	O
float	O
cur_pensize	float
,	O
FILE	struct
*	O
hd	pointer
)	O
{	O
HPGL_Pt	struct
p	struct
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
read_float	function
(	O
&	O
p	struct
.	O
x	int
,	O
hd	pointer
)	O
)	O
return	O
;	O
if	O
(	O
read_float	function
(	O
&	O
p	struct
.	O
y	int
,	O
hd	pointer
)	O
)	O
par_err_exit	function
(	O
2	int
,	O
EA	int
,	O
hd	pointer
)	O
;	O
rect	int
(	O
relative	int
,	O
filled	int
,	O
cur_pensize	float
,	O
p	struct
)	O
;	O
}	O
}	O
int	O
read_PE_flags	function
(	O
GEN_PAR	struct
*	O
pg	pointer
,	O
int	O
c	int
,	O
FILE	struct
*	O
hd	pointer
,	O
PE_flags	struct
*	O
fl	pointer
)	O
{	O
short	O
old_pen	short
;	O
float	O
ftmp	float
;	O
int	O
ctmp	int
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
183	int
:	O
case	O
'7'	O
:	O
fl	pointer
->	O
sbmode	int
=	O
1	int
;	O
break	O
;	O
case	O
185	int
:	O
case	O
'9'	O
:	O
fl	pointer
->	O
rect	int
=	O
1	int
;	O
fl	pointer
->	O
up	int
=	O
1	int
;	O
break	O
;	O
case	O
186	int
:	O
case	O
':'	O
:	O
if	O
(	O
EOF	O
==	O
(	O
fl	pointer
->	O
pen	int
=	O
getc	function
(	O
hd	pointer
)	O
)	O
)	O
{	O
par_err_exit	function
(	O
98	int
,	O
PE	int
,	O
hd	pointer
)	O
;	O
}	O
old_pen	short
=	O
pen	int
;	O
read_PE_coord	function
(	O
fl	pointer
->	O
pen	int
,	O
hd	pointer
,	O
fl	pointer
,	O
&	O
ftmp	float
)	O
;	O
pen	int
=	O
(	O
short	O
)	O
ftmp	float
;	O
if	O
(	O
pen	int
<	O
0	int
||	O
(	O
int	O
)	O
pen	int
>	O
pg	pointer
->	O
maxpens	int
)	O
{	O
Eprintf	function
(	O
"\nIllegal pen number %d: replaced by %d\n"	pointer
,	O
pen	int
,	O
pen	int
%	O
pg	pointer
->	O
maxpens	int
)	O
;	O
n_unexpected	int
++	O
;	O
pen	int
=	O
pen	int
%	O
pg	pointer
->	O
maxpens	int
;	O
}	O
if	O
(	O
pen	int
==	O
0	int
&&	O
pg	pointer
->	O
mapzero	int
>	O
-	O
1	int
)	O
pen	int
=	O
pg	pointer
->	O
mapzero	int
;	O
if	O
(	O
old_pen	short
!=	O
pen	int
)	O
{	O
if	O
(	O
(	O
fputc	function
(	O
SET_PEN	int
,	O
td	pointer
)	O
==	O
EOF	O
)	O
||	O
(	O
fputc	function
(	O
pen	int
,	O
td	pointer
)	O
==	O
EOF	O
)	O
)	O
{	O
PError	function
(	O
"Writing to temporary file:"	pointer
)	O
;	O
Eprintf	function
(	O
"Error @ Cmd %ld\n"	pointer
,	O
vec_cntr_w	long
)	O
;	O
exit	function
(	O
ERROR	O
)	O
;	O
}	O
}	O
if	O
(	O
pen	int
)	O
pens_in_use	array
[	O
pen	int
]	O
=	O
1	int
;	O
pg	pointer
->	O
maxcolor	int
=	O
MAX	O
(	O
pg	pointer
->	O
maxcolor	int
,	O
(	O
int	O
)	O
pen	int
)	O
;	O
break	O
;	O
case	O
190	int
:	O
case	O
'>'	O
:	O
if	O
(	O
EOF	O
==	O
(	O
ctmp	int
=	O
getc	function
(	O
hd	pointer
)	O
)	O
)	O
{	O
par_err_exit	function
(	O
98	int
,	O
PE	int
,	O
hd	pointer
)	O
;	O
}	O
fl	pointer
->	O
fract	int
=	O
decode_PE_char	function
(	O
ctmp	int
,	O
fl	pointer
)	O
;	O
fl	pointer
->	O
fract	int
=	O
(	O
(	O
fl	pointer
->	O
fract	int
>>	O
1	int
)	O
*	O
(	O
(	O
fl	pointer
->	O
fract	int
&	O
0x01	int
)	O
?	O
-	O
1	int
:	O
1	int
)	O
)	O
;	O
break	O
;	O
case	O
188	int
:	O
case	O
'<'	O
:	O
fl	pointer
->	O
up	int
=	O
1	int
;	O
fl	pointer
->	O
rect	int
=	O
0	int
;	O
break	O
;	O
case	O
189	int
:	O
case	O
'='	O
:	O
fl	pointer
->	O
abs	function
=	O
1	int
;	O
break	O
;	O
default	O
:	O
return	O
(	O
0	int
)	O
;	O
}	O
return	O
(	O
1	int
)	O
;	O
}	O
int	O
isPEterm	function
(	O
int	O
c	int
,	O
PE_flags	struct
*	O
fl	pointer
)	O
{	O
if	O
(	O
(	O
fl	pointer
->	O
sbmode	int
)	O
&&	O
(	O
(	O
c	int
>	O
94	int
)	O
||	O
(	O
c	int
<	O
63	int
)	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
(	O
!	O
fl	pointer
->	O
sbmode	int
)	O
&&	O
(	O
(	O
c	int
>	O
190	int
)	O
||	O
(	O
c	int
<	O
63	int
)	O
)	O
)	O
return	O
1	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
decode_PE_char	function
(	O
int	O
c	int
,	O
PE_flags	struct
*	O
fl	pointer
)	O
{	O
if	O
(	O
fl	pointer
->	O
sbmode	int
)	O
{	O
c	int
&=	O
0x7f	int
;	O
return	O
(	O
(	O
c	int
>	O
94	int
)	O
?	O
(	O
c	int
-	O
95	int
)	O
:	O
(	O
c	int
-	O
63	int
)	O
)	O
;	O
}	O
else	O
{	O
return	O
(	O
(	O
c	int
>	O
190	int
)	O
?	O
(	O
c	int
-	O
191	int
)	O
:	O
(	O
c	int
-	O
63	int
)	O
)	O
;	O
}	O
}	O
int	O
read_PE_coord	function
(	O
int	O
c	int
,	O
FILE	struct
*	O
hd	pointer
,	O
PE_flags	struct
*	O
fl	pointer
,	O
float	O
*	O
fv	pointer
)	O
{	O
long	O
lv	long
=	O
0	int
;	O
int	O
i	int
=	O
0	int
;	O
int	O
shft	int
=	O
(	O
fl	pointer
->	O
sbmode	int
)	O
?	O
5	int
:	O
6	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
c	int
<	O
63	int
)	O
{	O
if	O
(	O
!	O
i	int
)	O
{	O
Eprintf	function
(	O
"error in PE data!\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
ungetc	function
(	O
c	int
,	O
hd	pointer
)	O
;	O
break	O
;	O
}	O
lv	long
|=	O
(	O
(	O
long	O
)	O
decode_PE_char	function
(	O
c	int
,	O
fl	pointer
)	O
)	O
<<	O
(	O
i	int
*	O
shft	int
)	O
;	O
i	int
++	O
;	O
if	O
(	O
isPEterm	function
(	O
c	int
,	O
fl	pointer
)	O
)	O
{	O
break	O
;	O
}	O
if	O
(	O
EOF	O
==	O
(	O
c	int
=	O
getc	function
(	O
hd	pointer
)	O
)	O
)	O
{	O
par_err_exit	function
(	O
98	int
,	O
PE	int
,	O
hd	pointer
)	O
;	O
}	O
}	O
*	O
fv	pointer
=	O
(	O
float	O
)	O
(	O
(	O
(	O
lv	long
>>	O
1	int
)	O
*	O
(	O
(	O
lv	long
&	O
0x01	int
)	O
?	O
-	O
1	int
:	O
1	int
)	O
)	O
<<	O
fl	pointer
->	O
fract	int
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
int	O
read_PE_pair	function
(	O
int	O
c	int
,	O
FILE	struct
*	O
hd	pointer
,	O
PE_flags	struct
*	O
fl	pointer
,	O
HPGL_Pt	struct
*	O
p	struct
)	O
{	O
if	O
(	O
!	O
read_PE_coord	function
(	O
c	int
,	O
hd	pointer
,	O
fl	pointer
,	O
&	O
(	O
p	struct
->	O
x	int
)	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
EOF	O
==	O
(	O
c	int
=	O
getc	function
(	O
hd	pointer
)	O
)	O
)	O
{	O
par_err_exit	function
(	O
98	int
,	O
PE	int
,	O
hd	pointer
)	O
;	O
}	O
if	O
(	O
!	O
read_PE_coord	function
(	O
c	int
,	O
hd	pointer
,	O
fl	pointer
,	O
&	O
(	O
p	struct
->	O
y	int
)	O
)	O
)	O
return	O
0	int
;	O
return	O
(	O
1	int
)	O
;	O
}	O
void	O
read_PE	function
(	O
GEN_PAR	struct
*	O
pg	pointer
,	O
FILE	struct
*	O
hd	pointer
)	O
{	O
int	O
c	int
;	O
HPGL_Pt	struct
p	struct
;	O
PE_flags	struct
fl	pointer
;	O
fl	pointer
.	O
fract	int
=	O
0	int
;	O
fl	pointer
.	O
sbmode	int
=	O
0	int
;	O
fl	pointer
.	O
abs	function
=	O
0	int
;	O
fl	pointer
.	O
up	int
=	O
0	int
;	O
fl	pointer
.	O
pen	int
=	O
0	int
;	O
for	O
(	O
c	int
=	O
getc	function
(	O
hd	pointer
)	O
;	O
(	O
c	int
!=	O
EOF	O
)	O
&&	O
(	O
c	int
!=	O
';'	O
)	O
;	O
c	int
=	O
getc	function
(	O
hd	pointer
)	O
)	O
{	O
if	O
(	O
!	O
read_PE_flags	function
(	O
pg	pointer
,	O
c	int
,	O
hd	pointer
,	O
&	O
fl	pointer
)	O
)	O
{	O
if	O
(	O
!	O
read_PE_pair	function
(	O
c	int
,	O
hd	pointer
,	O
&	O
fl	pointer
,	O
&	O
p	struct
)	O
)	O
continue	O
;	O
switch	O
(	O
fl	pointer
.	O
rect	int
)	O
{	O
case	O
1	int
:	O
pen_down	short
=	O
0	int
;	O
line	function
(	O
!	O
fl	pointer
.	O
abs	function
,	O
p	struct
)	O
;	O
fl	pointer
.	O
rect	int
=	O
2	int
;	O
break	O
;	O
case	O
2	int
:	O
pen_down	short
=	O
1	int
;	O
rect	int
(	O
1	int
,	O
pg	pointer
->	O
nofill	int
?	O
0	int
:	O
1	int
,	O
pt	struct
.	O
width	array
[	O
pen	int
]	O
,	O
p	struct
)	O
;	O
fl	pointer
.	O
rect	int
=	O
1	int
;	O
pen_down	short
=	O
0	int
;	O
break	O
;	O
default	O
:	O
pen_down	short
=	O
(	O
fl	pointer
.	O
up	int
)	O
?	O
FALSE	int
:	O
TRUE	int
;	O
line	function
(	O
!	O
fl	pointer
.	O
abs	function
,	O
p	struct
)	O
;	O
fl	pointer
.	O
up	int
=	O
0	int
;	O
break	O
;	O
}	O
fl	pointer
.	O
abs	function
=	O
0	int
;	O
tp	pointer
->	O
CR_point	struct
=	O
HP_pos	struct
;	O
}	O
}	O
}	O
double	O
ceil_with_tolerance	function
(	O
double	O
x	int
,	O
double	O
tol	double
)	O
{	O
double	O
rounded	double
;	O
rounded	double
=	O
(	O
double	O
)	O
(	O
x	int
+	O
0.5	int
)	O
;	O
if	O
(	O
fabs	function
(	O
rounded	double
-	O
x	int
)	O
<=	O
tol	double
)	O
return	O
(	O
rounded	double
)	O
;	O
else	O
return	O
(	O
ceil	function
(	O
x	int
)	O
)	O
;	O
}	O
static	O
void	O
Line_Generator	function
(	O
HPGL_Pt	struct
*	O
pa	pointer
,	O
const	O
HPGL_Pt	struct
*	O
pb	pointer
,	O
int	O
mv_flag	short
)	O
{	O
double	O
seg_len	double
,	O
dx	double
,	O
dy	double
,	O
quot	int
;	O
int	O
n_pat	int
,	O
i	int
;	O
dx	double
=	O
pb	pointer
->	O
x	int
-	O
pa	pointer
->	O
x	int
;	O
dy	double
=	O
pb	pointer
->	O
y	int
-	O
pa	pointer
->	O
y	int
;	O
seg_len	double
=	O
HYPOT	O
(	O
dx	double
,	O
dy	double
)	O
;	O
switch	O
(	O
CurrentLineType	enum
)	O
{	O
case	O
LT_solid	int
:	O
if	O
(	O
seg_len	double
<	O
1.e-8	int
)	O
{	O
if	O
(	O
!	O
silent_mode	short
)	O
Eprintf	function
(	O
"Warning: Zero line segment length -- skipped\n"	pointer
)	O
;	O
return	O
;	O
}	O
PlotCmd_to_tmpfile	function
(	O
DRAW_TO	int
)	O
;	O
HPGL_Pt_to_tmpfile	function
(	O
pb	pointer
)	O
;	O
return	O
;	O
case	O
LT_adaptive	int
:	O
if	O
(	O
seg_len	double
<	O
1.e-8	int
)	O
{	O
if	O
(	O
!	O
silent_mode	short
)	O
Eprintf	function
(	O
"Warning: Zero line segment length -- skipped\n"	pointer
)	O
;	O
return	O
;	O
}	O
pat_pos	double
=	O
0.0	int
;	O
n_pat	int
=	O
(	O
int	O
)	O
ceil_with_tolerance	function
(	O
seg_len	double
/	O
CurrentLinePatLen	double
,	O
CurrentLinePatLen	double
*	O
LT_PATTERN_TOL	int
)	O
;	O
if	O
(	O
n_pat	int
==	O
0	int
)	O
{	O
n_pat	int
=	O
1	int
;	O
if	O
(	O
!	O
silent_mode	short
)	O
fprintf	function
(	O
stderr	pointer
,	O
"very short pattern run encountered\n"	pointer
)	O
;	O
}	O
dx	double
/=	O
n_pat	int
;	O
dy	double
/=	O
n_pat	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_pat	int
;	O
i	int
++	O
)	O
LPattern_Generator	function
(	O
pa	pointer
,	O
dx	double
,	O
dy	double
,	O
0.0	int
,	O
1.0	int
)	O
;	O
return	O
;	O
case	O
LT_plot_at	int
:	O
PlotCmd_to_tmpfile	function
(	O
PLOT_AT	int
)	O
;	O
HPGL_Pt_to_tmpfile	function
(	O
pb	pointer
)	O
;	O
return	O
;	O
case	O
LT_fixed	int
:	O
if	O
(	O
seg_len	double
<	O
1.e-8	int
)	O
{	O
if	O
(	O
!	O
silent_mode	short
)	O
Eprintf	function
(	O
"Warning: Zero line segment length -- skipped\n"	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
mv_flag	short
)	O
pat_pos	double
=	O
0.0	int
;	O
quot	int
=	O
seg_len	double
/	O
CurrentLinePatLen	double
;	O
dx	double
/=	O
quot	int
;	O
dy	double
/=	O
quot	int
;	O
while	O
(	O
quot	int
>=	O
1.0	int
)	O
{	O
LPattern_Generator	function
(	O
pa	pointer
,	O
dx	double
,	O
dy	double
,	O
pat_pos	double
,	O
1.0	int
)	O
;	O
quot	int
-=	O
(	O
1.0	int
-	O
pat_pos	double
)	O
;	O
pat_pos	double
=	O
0.0	int
;	O
}	O
quot	int
+=	O
pat_pos	double
;	O
if	O
(	O
quot	int
>=	O
1.0	int
)	O
{	O
LPattern_Generator	function
(	O
pa	pointer
,	O
dx	double
,	O
dy	double
,	O
pat_pos	double
,	O
1.0	int
)	O
;	O
quot	int
-=	O
1.0	int
;	O
pat_pos	double
=	O
0.0	int
;	O
}	O
if	O
(	O
quot	int
>	O
LT_PATTERN_TOL	int
)	O
{	O
LPattern_Generator	function
(	O
pa	pointer
,	O
dx	double
,	O
dy	double
,	O
pat_pos	double
,	O
quot	int
)	O
;	O
pat_pos	double
=	O
quot	int
;	O
}	O
else	O
{	O
PlotCmd_to_tmpfile	function
(	O
MOVE_TO	int
)	O
;	O
HPGL_Pt_to_tmpfile	function
(	O
pb	pointer
)	O
;	O
}	O
return	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
void	O
Pen_action_to_tmpfile	function
(	O
PlotCmd	enum
cmd	enum
,	O
const	O
HPGL_Pt	struct
*	O
p	struct
,	O
int	O
scaled	int
)	O
{	O
static	O
HPGL_Pt	struct
P_last	struct
;	O
HPGL_Pt	struct
P	struct
;	O
double	O
tmp	double
;	O
if	O
(	O
record_off	short
)	O
return	O
;	O
if	O
(	O
scaled	int
)	O
User_to_Plotter_coord	function
(	O
p	struct
,	O
&	O
P	struct
)	O
;	O
else	O
P	struct
=	O
*	O
p	struct
;	O
HP_pos	struct
=	O
P	struct
;	O
if	O
(	O
rotate_flag	short
)	O
{	O
tmp	double
=	O
rot_cos	float
*	O
P	struct
.	O
x	int
-	O
rot_sin	float
*	O
P	struct
.	O
y	int
;	O
P	struct
.	O
y	int
=	O
rot_sin	float
*	O
P	struct
.	O
x	int
+	O
rot_cos	float
*	O
P	struct
.	O
y	int
;	O
P	struct
.	O
x	int
=	O
tmp	double
;	O
}	O
switch	O
(	O
cmd	enum
)	O
{	O
case	O
MOVE_TO	int
:	O
mv_flag	short
=	O
TRUE	int
;	O
break	O
;	O
case	O
DRAW_TO	int
:	O
if	O
(	O
mv_flag	short
)	O
{	O
PlotCmd_to_tmpfile	function
(	O
MOVE_TO	int
)	O
;	O
HPGL_Pt_to_tmpfile	function
(	O
&	O
P_last	struct
)	O
;	O
}	O
case	O
PLOT_AT	int
:	O
Line_Generator	function
(	O
&	O
P_last	struct
,	O
&	O
P	struct
,	O
mv_flag	short
)	O
;	O
mv_flag	short
=	O
FALSE	int
;	O
break	O
;	O
default	O
:	O
Eprintf	function
(	O
"Illegal Pen Action: %d\n"	pointer
,	O
cmd	enum
)	O
;	O
Eprintf	function
(	O
"Error @ Cmd %ld\n"	pointer
,	O
vec_cntr_w	long
)	O
;	O
exit	function
(	O
ERROR	O
)	O
;	O
}	O
P_last	struct
=	O
P	struct
;	O
}	O
int	O
read_float	function
(	O
float	O
*	O
pnum	pointer
,	O
FILE	struct
*	O
hd	pointer
)	O
{	O
int	O
c	int
;	O
char	O
*	O
ptr	pointer
,	O
numbuf	array
[	O
80	int
]	O
;	O
for	O
(	O
c	int
=	O
getc	function
(	O
hd	pointer
)	O
;	O
(	O
c	int
!=	O
'.'	O
)	O
&&	O
(	O
c	int
!=	O
'+'	O
)	O
&&	O
(	O
c	int
!=	O
'-'	O
)	O
&&	O
(	O
(	O
c	int
<	O
'0'	O
)	O
||	O
(	O
c	int
>	O
'9'	O
)	O
)	O
;	O
c	int
=	O
getc	function
(	O
hd	pointer
)	O
)	O
{	O
if	O
(	O
c	int
==	O
EOF	O
)	O
return	O
EOF	O
;	O
if	O
(	O
c	int
==	O
';'	O
)	O
return	O
1	int
;	O
if	O
(	O
(	O
(	O
c	int
>=	O
'A'	O
)	O
&&	O
(	O
c	int
<=	O
'Z'	O
)	O
)	O
||	O
(	O
(	O
c	int
>=	O
'a'	O
)	O
&&	O
(	O
c	int
<=	O
'a'	O
)	O
)	O
||	O
(	O
c	int
==	O
ESC	char
)	O
)	O
{	O
ungetc	function
(	O
c	int
,	O
hd	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
ptr	pointer
=	O
numbuf	array
;	O
for	O
(	O
*	O
ptr	pointer
++	O
=	O
c	int
,	O
c	int
=	O
getc	function
(	O
hd	pointer
)	O
;	O
(	O
(	O
c	int
>=	O
'0'	O
)	O
&&	O
(	O
c	int
<=	O
'9'	O
)	O
)	O
||	O
(	O
c	int
==	O
'.'	O
)	O
;	O
c	int
=	O
getc	function
(	O
hd	pointer
)	O
)	O
*	O
ptr	pointer
++	O
=	O
c	int
;	O
*	O
ptr	pointer
=	O
'\0'	O
;	O
if	O
(	O
c	int
!=	O
EOF	O
)	O
ungetc	function
(	O
c	int
,	O
hd	pointer
)	O
;	O
if	O
(	O
sscanf	function
(	O
numbuf	array
,	O
"%f"	pointer
,	O
pnum	pointer
)	O
!=	O
1	int
)	O
return	O
11	int
;	O
return	O
0	int
;	O
}	O
void	O
read_string	function
(	O
char	O
*	O
buf	pointer
,	O
FILE	struct
*	O
hd	pointer
)	O
{	O
int	O
c	int
;	O
unsigned	O
int	O
n	int
;	O
for	O
(	O
n	int
=	O
0	int
,	O
c	int
=	O
getc	function
(	O
hd	pointer
)	O
;	O
(	O
c	int
!=	O
EOF	O
)	O
&&	O
(	O
c	int
!=	O
StrTerm	char
)	O
;	O
c	int
=	O
getc	function
(	O
hd	pointer
)	O
)	O
{	O
if	O
(	O
n	int
>	O
strbufsize	int
/	O
2	int
)	O
{	O
strbufsize	int
*=	O
2	int
;	O
strbuf	pointer
=	O
realloc	function
(	O
strbuf	pointer
,	O
strbufsize	int
)	O
;	O
if	O
(	O
strbuf	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"\nNo memory !\n"	pointer
)	O
;	O
exit	function
(	O
ERROR	O
)	O
;	O
}	O
buf	pointer
=	O
strbuf	pointer
+	O
n	int
;	O
}	O
if	O
(	O
c	int
==	O
'\0'	O
)	O
continue	O
;	O
if	O
(	O
n	int
++	O
<	O
strbufsize	int
)	O
*	O
buf	pointer
++	O
=	O
c	int
;	O
}	O
if	O
(	O
c	int
!=	O
StrTerm	char
||	O
StrTermSilent	short
==	O
0	int
)	O
*	O
buf	pointer
++	O
=	O
c	int
;	O
*	O
buf	pointer
=	O
'\0'	O
;	O
}	O
static	O
void	O
read_symbol_char	function
(	O
FILE	struct
*	O
hd	pointer
)	O
{	O
int	O
c	int
;	O
for	O
(	O
c	int
=	O
getc	function
(	O
hd	pointer
)	O
;	O
;	O
c	int
=	O
getc	function
(	O
hd	pointer
)	O
)	O
switch	O
(	O
c	int
)	O
{	O
case	O
' '	O
:	O
case	O
_HT	char
:	O
case	O
_LF	char
:	O
break	O
;	O
case	O
_CR	char
:	O
case	O
EOF	O
:	O
case	O
';'	O
:	O
symbol_char	char
=	O
'\0'	O
;	O
return	O
;	O
default	O
:	O
if	O
(	O
c	int
<	O
' '	O
||	O
c	int
>	O
'~'	O
)	O
break	O
;	O
else	O
{	O
symbol_char	char
=	O
c	int
;	O
return	O
;	O
}	O
}	O
}	O
static	O
void	O
read_ESC_HP7550A	function
(	O
FILE	struct
*	O
hd	pointer
)	O
{	O
int	O
c	int
;	O
switch	O
(	O
getc	function
(	O
hd	pointer
)	O
)	O
{	O
case	O
EOF	O
:	O
n_unexpected	int
++	O
;	O
Eprintf	function
(	O
"\nUnexpected EOF!\n"	pointer
)	O
;	O
return	O
;	O
break	O
;	O
case	O
'A'	O
:	O
case	O
'B'	O
:	O
case	O
'E'	O
:	O
case	O
'J'	O
:	O
case	O
'K'	O
:	O
case	O
'L'	O
:	O
case	O
'O'	O
:	O
case	O
'U'	O
:	O
case	O
'Y'	O
:	O
case	O
'('	O
:	O
case	O
')'	O
:	O
return	O
;	O
case	O
'@'	O
:	O
case	O
'H'	O
:	O
case	O
'I'	O
:	O
case	O
'M'	O
:	O
case	O
'N'	O
:	O
case	O
'P'	O
:	O
case	O
'Q'	O
:	O
case	O
'S'	O
:	O
case	O
'T'	O
:	O
do	O
{	O
c	int
=	O
getc	function
(	O
hd	pointer
)	O
;	O
}	O
while	O
(	O
(	O
c	int
!=	O
':'	O
)	O
&&	O
(	O
c	int
!=	O
EOF	O
)	O
)	O
;	O
if	O
(	O
c	int
==	O
EOF	O
)	O
{	O
n_unexpected	int
++	O
;	O
Eprintf	function
(	O
"\nUnexpected EOF!\n"	pointer
)	O
;	O
}	O
return	O
;	O
default	O
:	O
n_unknown	int
++	O
;	O
return	O
;	O
}	O
}	O
static	O
int	O
read_PJL	function
(	O
FILE	struct
*	O
hd	pointer
)	O
{	O
char	O
strbuf	pointer
[	O
PJLBS	int
]	O
;	O
int	O
i	int
,	O
j	int
,	O
ov	int
,	O
ctmp	int
,	O
qt	int
,	O
el	int
=	O
0	int
,	O
nw	int
=	O
0	int
,	O
rc	int
=	O
-	O
2	int
,	O
nl	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
for	O
(	O
i	int
=	O
ov	int
=	O
qt	int
=	O
0	int
;	O
;	O
i	int
++	O
)	O
{	O
ctmp	int
=	O
getc	function
(	O
hd	pointer
)	O
;	O
if	O
(	O
ctmp	int
==	O
ESC	char
)	O
{	O
while	O
(	O
ctmp	int
!=	O
'X'	O
)	O
ctmp	int
=	O
getc	function
(	O
hd	pointer
)	O
;	O
ctmp	int
=	O
getc	function
(	O
hd	pointer
)	O
;	O
}	O
if	O
(	O
PJLBS	int
-	O
1	int
==	O
i	int
)	O
{	O
if	O
(	O
!	O
silent_mode	short
)	O
Eprintf	function
(	O
"PJL buffer overflow, rest of token dropped\n"	pointer
)	O
;	O
ov	int
=	O
1	int
;	O
strbuf	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
!	O
ov	int
)	O
strbuf	pointer
[	O
i	int
]	O
=	O
(	O
0	int
==	O
nw	int
||	O
qt	int
)	O
?	O
ctmp	int
:	O
toupper	function
(	O
ctmp	int
)	O
;	O
if	O
(	O
EOF	O
==	O
ctmp	int
)	O
{	O
if	O
(	O
!	O
ov	int
)	O
strbuf	pointer
[	O
i	int
]	O
=	O
0	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
'='	O
==	O
ctmp	int
&&	O
0	int
==	O
i	int
)	O
{	O
strbuf	pointer
[	O
i	int
]	O
=	O
'='	O
;	O
strbuf	pointer
[	O
++	O
i	int
]	O
=	O
'\0'	O
;	O
ctmp	int
=	O
' '	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
strchr	function
(	O
" \t="	pointer
,	O
ctmp	int
)	O
)	O
{	O
if	O
(	O
!	O
qt	int
)	O
{	O
if	O
(	O
!	O
ov	int
)	O
strbuf	pointer
[	O
i	int
]	O
=	O
0	int
;	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
'\n'	O
==	O
ctmp	int
||	O
'\r'	O
==	O
ctmp	int
)	O
{	O
if	O
(	O
!	O
ov	int
)	O
strbuf	pointer
[	O
i	int
]	O
=	O
0	int
;	O
nl	int
=	O
1	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
'"'	O
==	O
ctmp	int
)	O
{	O
qt	int
=	O
!	O
qt	int
;	O
}	O
}	O
if	O
(	O
i	int
)	O
{	O
if	O
(	O
0	int
==	O
nw	int
&&	O
strcmp	function
(	O
strbuf	pointer
,	O
"@PJL"	pointer
)	O
)	O
{	O
Eprintf	function
(	O
"unexpected end of a PJL header!\n"	pointer
)	O
;	O
return	O
(	O
TRUE	int
)	O
;	O
}	O
else	O
if	O
(	O
1	int
==	O
nw	int
&&	O
!	O
strcmp	function
(	O
strbuf	pointer
,	O
"EOJ"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
silent_mode	short
)	O
Eprintf	function
(	O
"end of a PJL job\n"	pointer
)	O
;	O
rc	int
=	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
1	int
==	O
nw	int
&&	O
!	O
strcmp	function
(	O
strbuf	pointer
,	O
"ENTER"	pointer
)	O
)	O
{	O
el	int
++	O
;	O
}	O
else	O
if	O
(	O
2	int
==	O
nw	int
&&	O
1	int
==	O
el	int
&&	O
!	O
strcmp	function
(	O
strbuf	pointer
,	O
"LANGUAGE"	pointer
)	O
)	O
{	O
el	int
++	O
;	O
}	O
else	O
if	O
(	O
3	int
==	O
nw	int
&&	O
2	int
==	O
el	int
&&	O
!	O
strcmp	function
(	O
strbuf	pointer
,	O
"="	pointer
)	O
)	O
{	O
el	int
++	O
;	O
}	O
else	O
if	O
(	O
4	int
==	O
nw	int
&&	O
3	int
==	O
el	int
)	O
{	O
if	O
(	O
!	O
silent_mode	short
)	O
Eprintf	function
(	O
"Entering %s context\n"	pointer
,	O
strbuf	pointer
)	O
;	O
rc	int
=	O
strncmp	function
(	O
strbuf	pointer
,	O
"HPGL"	pointer
,	O
4	int
)	O
?	O
FALSE	int
:	O
TRUE	int
;	O
}	O
nw	int
++	O
;	O
}	O
for	O
(	O
j	int
=	O
0	int
;	O
EOF	O
!=	O
ctmp	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
!	O
strchr	function
(	O
" \t\n\r"	pointer
,	O
ctmp	int
)	O
)	O
{	O
ungetc	function
(	O
ctmp	int
,	O
hd	pointer
)	O
;	O
break	O
;	O
}	O
ctmp	int
=	O
getc	function
(	O
hd	pointer
)	O
;	O
if	O
(	O
'\n'	O
==	O
ctmp	int
)	O
{	O
nl	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
nl	int
)	O
{	O
nw	int
=	O
el	int
=	O
nl	int
=	O
0	int
;	O
if	O
(	O
-	O
2	int
!=	O
rc	int
)	O
return	O
rc	int
;	O
}	O
if	O
(	O
EOF	O
==	O
ctmp	int
)	O
{	O
if	O
(	O
!	O
silent_mode	short
)	O
Eprintf	function
(	O
"EOF in PJL context\n"	pointer
)	O
;	O
return	O
(	O
FALSE	int
)	O
;	O
}	O
}	O
}	O
static	O
void	O
read_ESC_RTL	function
(	O
FILE	struct
*	O
hd	pointer
,	O
int	O
c1	int
,	O
int	O
hp	int
)	O
{	O
int	O
c0	int
,	O
c2	int
,	O
ctmp	int
=	O
0	int
,	O
nf	int
;	O
for	O
(	O
c0	int
=	O
ESC	char
,	O
c2	int
=	O
getc	function
(	O
hd	pointer
)	O
,	O
nf	int
=	O
0	int
;	O
EOF	O
!=	O
c2	int
;	O
c0	int
=	O
c1	int
,	O
c1	int
=	O
c2	int
,	O
c2	int
=	O
getc	function
(	O
hd	pointer
)	O
)	O
{	O
if	O
(	O
(	O
ESC	char
==	O
c0	int
)	O
&&	O
(	O
c1	int
==	O
'%'	O
)	O
)	O
{	O
if	O
(	O
'-'	O
==	O
c2	int
)	O
{	O
c2	int
=	O
getc	function
(	O
hd	pointer
)	O
;	O
nf	int
=	O
1	int
;	O
}	O
switch	O
(	O
c2	int
)	O
{	O
case	O
EOF	O
:	O
n_unexpected	int
++	O
;	O
Eprintf	function
(	O
"\nUnexpected EOF!\n"	pointer
)	O
;	O
return	O
;	O
break	O
;	O
case	O
'1'	O
:	O
case	O
'0'	O
:	O
switch	O
(	O
ctmp	int
=	O
getc	function
(	O
hd	pointer
)	O
)	O
{	O
case	O
'A'	O
:	O
if	O
(	O
hp	int
&&	O
!	O
silent_mode	short
)	O
{	O
hp	int
=	O
FALSE	int
;	O
}	O
continue	O
;	O
case	O
'B'	O
:	O
return	O
;	O
case	O
'2'	O
:	O
if	O
(	O
nf	int
&&	O
'1'	O
==	O
c2	int
&&	O
'3'	O
==	O
(	O
c2	int
=	O
getc	function
(	O
hd	pointer
)	O
)	O
&&	O
'4'	O
==	O
(	O
c2	int
=	O
getc	function
(	O
hd	pointer
)	O
)	O
&&	O
'5'	O
==	O
(	O
c2	int
=	O
getc	function
(	O
hd	pointer
)	O
)	O
&&	O
'X'	O
==	O
(	O
c2	int
=	O
getc	function
(	O
hd	pointer
)	O
)	O
)	O
{	O
if	O
(	O
read_PJL	function
(	O
hd	pointer
)	O
)	O
{	O
return	O
;	O
}	O
else	O
{	O
hp	int
=	O
0	int
;	O
continue	O
;	O
}	O
}	O
else	O
{	O
ungetc	function
(	O
ctmp	int
,	O
hd	pointer
)	O
;	O
if	O
(	O
hp	int
)	O
return	O
;	O
}	O
break	O
;	O
default	O
:	O
if	O
(	O
!	O
silent_mode	short
)	O
Eprintf	function
(	O
"unknown escape: ESC%%%s%c%c\n"	pointer
,	O
nf	int
?	O
"-"	pointer
:	O
""	pointer
,	O
c2	int
,	O
ctmp	int
)	O
;	O
ungetc	function
(	O
ctmp	int
,	O
hd	pointer
)	O
;	O
if	O
(	O
hp	int
)	O
return	O
;	O
}	O
break	O
;	O
default	O
:	O
if	O
(	O
!	O
silent_mode	short
)	O
Eprintf	function
(	O
"unknown escape: ESC%%%s%c"	pointer
,	O
nf	int
?	O
"-"	pointer
:	O
""	pointer
,	O
c2	int
)	O
;	O
ungetc	function
(	O
ctmp	int
,	O
hd	pointer
)	O
;	O
if	O
(	O
hp	int
)	O
return	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
hp	int
==	O
TRUE	int
&&	O
!	O
nf	int
&&	O
c1	int
!=	O
'%'	O
&&	O
c1	int
!=	O
'E'	O
)	O
{	O
ungetc	function
(	O
ctmp	int
,	O
hd	pointer
)	O
;	O
if	O
(	O
!	O
silent_mode	short
)	O
Eprintf	function
(	O
"invalid escape ESC%c%c\n"	pointer
,	O
c1	int
,	O
c2	int
)	O
;	O
return	O
;	O
}	O
}	O
}	O
static	O
void	O
read_ESC_cmd	function
(	O
FILE	struct
*	O
hd	pointer
,	O
int	O
hp	int
)	O
{	O
int	O
ctmp	int
;	O
switch	O
(	O
ctmp	int
=	O
getc	function
(	O
hd	pointer
)	O
)	O
{	O
case	O
'.'	O
:	O
read_ESC_HP7550A	function
(	O
hd	pointer
)	O
;	O
break	O
;	O
case	O
EOF	O
:	O
n_unexpected	int
++	O
;	O
Eprintf	function
(	O
"\nUnexpected EOF!\n"	pointer
)	O
;	O
return	O
;	O
default	O
:	O
read_ESC_RTL	function
(	O
hd	pointer
,	O
ctmp	int
,	O
hp	int
)	O
;	O
break	O
;	O
}	O
}	O
static	O
void	O
lines	function
(	O
int	O
relative	int
,	O
FILE	struct
*	O
hd	pointer
)	O
{	O
HPGL_Pt	struct
p	struct
;	O
int	O
numcmds	int
=	O
0	int
;	O
int	O
outside	int
=	O
0	int
;	O
double	O
p1x	double
,	O
p1y	double
,	O
p2x	double
,	O
p2y	double
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
read_float	function
(	O
&	O
p	struct
.	O
x	int
,	O
hd	pointer
)	O
)	O
{	O
if	O
(	O
numcmds	int
>	O
0	int
)	O
return	O
;	O
if	O
(	O
pen_down	short
&&	O
mv_flag	short
&&	O
pen	int
>	O
0	int
&&	O
pt	struct
.	O
width	array
[	O
pen	int
]	O
<	O
0.35	int
)	O
{	O
p	struct
.	O
x	int
=	O
p_last	struct
.	O
x	int
+	O
0.01	int
;	O
p	struct
.	O
y	int
=	O
p_last	struct
.	O
y	int
+	O
0.01	int
;	O
outside	int
=	O
0	int
;	O
if	O
(	O
iwflag	int
)	O
{	O
p1x	double
=	O
P1	struct
.	O
x	int
+	O
(	O
p_last	struct
.	O
x	int
-	O
S1	struct
.	O
x	int
)	O
*	O
Q	struct
.	O
x	int
;	O
p1y	double
=	O
P1	struct
.	O
y	int
+	O
(	O
p_last	struct
.	O
y	int
-	O
S1	struct
.	O
y	int
)	O
*	O
Q	struct
.	O
y	int
;	O
p2x	double
=	O
P1	struct
.	O
x	int
+	O
(	O
p	struct
.	O
x	int
-	O
S1	struct
.	O
x	int
)	O
*	O
Q	struct
.	O
x	int
;	O
p2y	double
=	O
P1	struct
.	O
y	int
+	O
(	O
p	struct
.	O
y	int
-	O
S1	struct
.	O
y	int
)	O
*	O
Q	struct
.	O
y	int
;	O
outside	int
=	O
(	O
DtClipLine	function
(	O
C1	struct
.	O
x	int
,	O
C1	struct
.	O
y	int
,	O
C2	struct
.	O
x	int
,	O
C2	struct
.	O
y	int
,	O
&	O
p1x	double
,	O
&	O
p1y	double
,	O
&	O
p2x	double
,	O
&	O
p2y	double
)	O
==	O
CLIP_NODRAW	int
)	O
;	O
}	O
if	O
(	O
!	O
outside	int
)	O
{	O
Pen_action_to_tmpfile	function
(	O
MOVE_TO	int
,	O
&	O
p	struct
,	O
scale_flag	int
)	O
;	O
Pen_action_to_tmpfile	function
(	O
DRAW_TO	int
,	O
&	O
p_last	struct
,	O
scale_flag	int
)	O
;	O
}	O
}	O
return	O
;	O
}	O
if	O
(	O
read_float	function
(	O
&	O
p	struct
.	O
y	int
,	O
hd	pointer
)	O
)	O
par_err_exit	function
(	O
2	int
,	O
PA	int
,	O
hd	pointer
)	O
;	O
line	function
(	O
relative	int
,	O
p	struct
)	O
;	O
numcmds	int
++	O
;	O
}	O
}	O
void	O
line	function
(	O
int	O
relative	int
,	O
HPGL_Pt	struct
p	struct
)	O
{	O
HPGL_Pt	struct
pl	struct
,	O
porig	struct
;	O
int	O
outside	int
=	O
0	int
;	O
double	O
x1	double
,	O
y1	function
,	O
x2	pointer
,	O
y2	pointer
;	O
if	O
(	O
relative	int
)	O
{	O
p	struct
.	O
x	int
+=	O
p_last	struct
.	O
x	int
;	O
p	struct
.	O
y	int
+=	O
p_last	struct
.	O
y	int
;	O
}	O
porig	struct
.	O
x	int
=	O
p	struct
.	O
x	int
;	O
porig	struct
.	O
y	int
=	O
p	struct
.	O
y	int
;	O
if	O
(	O
iwflag	int
)	O
{	O
x1	double
=	O
P1	struct
.	O
x	int
+	O
(	O
p_last	struct
.	O
x	int
-	O
S1	struct
.	O
x	int
)	O
*	O
Q	struct
.	O
x	int
;	O
y1	function
=	O
P1	struct
.	O
y	int
+	O
(	O
p_last	struct
.	O
y	int
-	O
S1	struct
.	O
y	int
)	O
*	O
Q	struct
.	O
y	int
;	O
x2	pointer
=	O
P1	struct
.	O
x	int
+	O
(	O
p	struct
.	O
x	int
-	O
S1	struct
.	O
x	int
)	O
*	O
Q	struct
.	O
x	int
;	O
y2	pointer
=	O
P1	struct
.	O
y	int
+	O
(	O
p	struct
.	O
y	int
-	O
S1	struct
.	O
y	int
)	O
*	O
Q	struct
.	O
y	int
;	O
outside	int
=	O
(	O
DtClipLine	function
(	O
C1	struct
.	O
x	int
,	O
C1	struct
.	O
y	int
,	O
C2	struct
.	O
x	int
,	O
C2	struct
.	O
y	int
,	O
&	O
x1	double
,	O
&	O
y1	function
,	O
&	O
x2	pointer
,	O
&	O
y2	pointer
)	O
==	O
CLIP_NODRAW	int
)	O
;	O
if	O
(	O
!	O
outside	int
)	O
{	O
p	struct
.	O
x	int
=	O
(	O
x2	pointer
-	O
P1	struct
.	O
x	int
)	O
/	O
Q	struct
.	O
x	int
+	O
S1	struct
.	O
x	int
;	O
p	struct
.	O
y	int
=	O
(	O
y2	pointer
-	O
P1	struct
.	O
y	int
)	O
/	O
Q	struct
.	O
y	int
+	O
S1	struct
.	O
y	int
;	O
pl	struct
.	O
x	int
=	O
(	O
x1	double
-	O
P1	struct
.	O
x	int
)	O
/	O
Q	struct
.	O
x	int
+	O
S1	struct
.	O
x	int
;	O
pl	struct
.	O
y	int
=	O
(	O
y1	function
-	O
P1	struct
.	O
y	int
)	O
/	O
Q	struct
.	O
y	int
+	O
S1	struct
.	O
y	int
;	O
if	O
(	O
pl	struct
.	O
x	int
!=	O
p_last	struct
.	O
x	int
||	O
pl	struct
.	O
y	int
!=	O
p_last	struct
.	O
y	int
)	O
Pen_action_to_tmpfile	function
(	O
MOVE_TO	int
,	O
&	O
pl	struct
,	O
scale_flag	int
)	O
;	O
}	O
}	O
else	O
pl	struct
=	O
p_last	struct
;	O
if	O
(	O
polygon_mode	short
&&	O
polygon_penup	short
)	O
pen_down	short
=	O
FALSE	int
;	O
if	O
(	O
pen_down	short
&&	O
!	O
outside	int
)	O
{	O
if	O
(	O
polygon_mode	short
)	O
{	O
HPGL_Pt_to_polygon	function
(	O
pl	struct
)	O
;	O
HPGL_Pt_to_polygon	function
(	O
p	struct
)	O
;	O
}	O
else	O
{	O
Pen_action_to_tmpfile	function
(	O
DRAW_TO	int
,	O
&	O
p	struct
,	O
scale_flag	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
iwflag	int
)	O
{	O
Pen_action_to_tmpfile	function
(	O
MOVE_TO	int
,	O
&	O
porig	struct
,	O
scale_flag	int
)	O
;	O
}	O
else	O
{	O
Pen_action_to_tmpfile	function
(	O
MOVE_TO	int
,	O
&	O
p	struct
,	O
scale_flag	int
)	O
;	O
}	O
}	O
if	O
(	O
polygon_mode	short
&&	O
polygon_penup	short
)	O
{	O
polygon_penup	short
=	O
FALSE	int
;	O
polystart	struct
=	O
p	struct
;	O
pen_down	short
=	O
TRUE	int
;	O
}	O
if	O
(	O
symbol_char	char
)	O
{	O
plot_symbol_char	function
(	O
symbol_char	char
)	O
;	O
Pen_action_to_tmpfile	function
(	O
MOVE_TO	int
,	O
&	O
p	struct
,	O
scale_flag	int
)	O
;	O
}	O
outside	int
=	O
0	int
;	O
p_last	struct
=	O
porig	struct
;	O
}	O
static	O
void	O
arc_increment	function
(	O
HPGL_Pt	struct
*	O
pcenter	pointer
,	O
double	O
r	char
,	O
double	O
phi	double
)	O
{	O
HPGL_Pt	struct
p	struct
;	O
int	O
outside	int
=	O
0	int
;	O
p	struct
.	O
x	int
=	O
pcenter	pointer
->	O
x	int
+	O
r	char
*	O
cos	function
(	O
phi	double
)	O
;	O
p	struct
.	O
y	int
=	O
pcenter	pointer
->	O
y	int
+	O
r	char
*	O
sin	function
(	O
phi	double
)	O
;	O
if	O
(	O
iwflag	int
)	O
{	O
if	O
(	O
P1	struct
.	O
x	int
+	O
(	O
p	struct
.	O
x	int
-	O
S1	struct
.	O
x	int
)	O
*	O
Q	struct
.	O
x	int
>	O
C2	struct
.	O
x	int
||	O
P1	struct
.	O
y	int
+	O
(	O
p	struct
.	O
y	int
-	O
S1	struct
.	O
y	int
)	O
*	O
Q	struct
.	O
y	int
>	O
C2	struct
.	O
y	int
)	O
{	O
outside	int
=	O
1	int
;	O
}	O
if	O
(	O
P1	struct
.	O
x	int
+	O
(	O
p	struct
.	O
x	int
-	O
S1	struct
.	O
x	int
)	O
*	O
Q	struct
.	O
x	int
<	O
C1	struct
.	O
x	int
||	O
P1	struct
.	O
y	int
+	O
(	O
p	struct
.	O
y	int
-	O
S1	struct
.	O
y	int
)	O
*	O
Q	struct
.	O
y	int
<	O
C1	struct
.	O
y	int
)	O
{	O
outside	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
polygon_mode	short
)	O
{	O
if	O
(	O
polygon_penup	short
)	O
polygon_penup	short
=	O
FALSE	int
;	O
else	O
if	O
(	O
pen_down	short
&&	O
!	O
outside	int
)	O
{	O
HPGL_Pt_to_polygon	function
(	O
p_last	struct
)	O
;	O
HPGL_Pt_to_polygon	function
(	O
p	struct
)	O
;	O
}	O
else	O
if	O
(	O
(	O
p	struct
.	O
x	int
!=	O
p_last	struct
.	O
x	int
)	O
||	O
(	O
p	struct
.	O
y	int
!=	O
p_last	struct
.	O
y	int
)	O
)	O
{	O
HPGL_Pt_to_polygon	function
(	O
p_last	struct
)	O
;	O
HPGL_Pt_to_polygon	function
(	O
p	struct
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
pen_down	short
&&	O
!	O
outside	int
)	O
Pen_action_to_tmpfile	function
(	O
DRAW_TO	int
,	O
&	O
p	struct
,	O
scale_flag	int
)	O
;	O
else	O
if	O
(	O
!	O
outside	int
&&	O
(	O
(	O
p	struct
.	O
x	int
!=	O
p_last	struct
.	O
x	int
)	O
||	O
(	O
p	struct
.	O
y	int
!=	O
p_last	struct
.	O
y	int
)	O
)	O
)	O
Pen_action_to_tmpfile	function
(	O
MOVE_TO	int
,	O
&	O
p	struct
,	O
scale_flag	int
)	O
;	O
}	O
p_last	struct
=	O
p	struct
;	O
}	O
static	O
void	O
bezier	function
(	O
int	O
relative	int
,	O
FILE	struct
*	O
hd	pointer
)	O
{	O
HPGL_Pt	struct
p	struct
,	O
p1	struct
,	O
p2	struct
,	O
p3	struct
,	O
polyp	struct
;	O
int	O
i	int
,	O
outside	int
;	O
float	O
t	float
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
read_float	function
(	O
&	O
p1	struct
.	O
x	int
,	O
hd	pointer
)	O
)	O
return	O
;	O
if	O
(	O
read_float	function
(	O
&	O
p1	struct
.	O
y	int
,	O
hd	pointer
)	O
)	O
par_err_exit	function
(	O
2	int
,	O
BZ	int
,	O
hd	pointer
)	O
;	O
if	O
(	O
read_float	function
(	O
&	O
p2	struct
.	O
x	int
,	O
hd	pointer
)	O
)	O
return	O
;	O
if	O
(	O
read_float	function
(	O
&	O
p2	struct
.	O
y	int
,	O
hd	pointer
)	O
)	O
par_err_exit	function
(	O
2	int
,	O
BZ	int
,	O
hd	pointer
)	O
;	O
if	O
(	O
read_float	function
(	O
&	O
p3	struct
.	O
x	int
,	O
hd	pointer
)	O
)	O
par_err_exit	function
(	O
3	int
,	O
BZ	int
,	O
hd	pointer
)	O
;	O
if	O
(	O
read_float	function
(	O
&	O
p3	struct
.	O
y	int
,	O
hd	pointer
)	O
)	O
par_err_exit	function
(	O
3	int
,	O
BZ	int
,	O
hd	pointer
)	O
;	O
if	O
(	O
relative	int
)	O
{	O
p1	struct
.	O
x	int
=	O
p1	struct
.	O
x	int
+	O
p_last	struct
.	O
x	int
;	O
p1	struct
.	O
y	int
=	O
p1	struct
.	O
y	int
+	O
p_last	struct
.	O
y	int
;	O
p2	struct
.	O
x	int
=	O
p2	struct
.	O
x	int
+	O
p_last	struct
.	O
x	int
;	O
p2	struct
.	O
y	int
=	O
p2	struct
.	O
y	int
+	O
p_last	struct
.	O
y	int
;	O
p3	struct
.	O
x	int
=	O
p3	struct
.	O
x	int
+	O
p_last	struct
.	O
x	int
;	O
p3	struct
.	O
y	int
=	O
p3	struct
.	O
y	int
+	O
p_last	struct
.	O
y	int
;	O
}	O
polyp	struct
=	O
p_last	struct
;	O
outside	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
51	int
;	O
i	int
++	O
)	O
{	O
t	float
=	O
(	O
float	O
)	O
i	int
/	O
50.	int
;	O
p	struct
.	O
x	int
=	O
t	float
*	O
t	float
*	O
t	float
*	O
p3	struct
.	O
x	int
+	O
3	int
*	O
t	float
*	O
t	float
*	O
(	O
1.	int
-	O
t	float
)	O
*	O
p2	struct
.	O
x	int
+	O
3	int
*	O
t	float
*	O
(	O
1.	int
-	O
t	float
)	O
*	O
(	O
1.	int
-	O
t	float
)	O
*	O
p1	struct
.	O
x	int
+	O
(	O
1.	int
-	O
t	float
)	O
*	O
(	O
1.	int
-	O
t	float
)	O
*	O
(	O
1.	int
-	O
t	float
)	O
*	O
p_last	struct
.	O
x	int
;	O
p	struct
.	O
y	int
=	O
t	float
*	O
t	float
*	O
t	float
*	O
p3	struct
.	O
y	int
+	O
3	int
*	O
t	float
*	O
t	float
*	O
(	O
1.	int
-	O
t	float
)	O
*	O
p2	struct
.	O
y	int
+	O
3	int
*	O
t	float
*	O
(	O
1.	int
-	O
t	float
)	O
*	O
(	O
1.	int
-	O
t	float
)	O
*	O
p1	struct
.	O
y	int
+	O
(	O
1.	int
-	O
t	float
)	O
*	O
(	O
1.	int
-	O
t	float
)	O
*	O
(	O
1.	int
-	O
t	float
)	O
*	O
p_last	struct
.	O
y	int
;	O
if	O
(	O
iwflag	int
)	O
{	O
if	O
(	O
P1	struct
.	O
x	int
+	O
(	O
p	struct
.	O
x	int
-	O
S1	struct
.	O
x	int
)	O
*	O
Q	struct
.	O
x	int
>	O
C2	struct
.	O
x	int
||	O
P1	struct
.	O
y	int
+	O
(	O
p	struct
.	O
y	int
-	O
S1	struct
.	O
y	int
)	O
*	O
Q	struct
.	O
y	int
>	O
C2	struct
.	O
y	int
)	O
{	O
outside	int
=	O
1	int
;	O
}	O
if	O
(	O
P1	struct
.	O
x	int
+	O
(	O
p	struct
.	O
x	int
-	O
S1	struct
.	O
x	int
)	O
*	O
Q	struct
.	O
x	int
<	O
C1	struct
.	O
x	int
||	O
P1	struct
.	O
y	int
+	O
(	O
p	struct
.	O
y	int
-	O
S1	struct
.	O
y	int
)	O
*	O
Q	struct
.	O
y	int
<	O
C1	struct
.	O
y	int
)	O
{	O
outside	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
!	O
outside	int
)	O
{	O
if	O
(	O
polygon_mode	short
)	O
{	O
HPGL_Pt_to_polygon	function
(	O
polyp	struct
)	O
;	O
HPGL_Pt_to_polygon	function
(	O
p	struct
)	O
;	O
polyp	struct
.	O
x	int
=	O
p	struct
.	O
x	int
;	O
polyp	struct
.	O
y	int
=	O
p	struct
.	O
y	int
;	O
}	O
else	O
{	O
Pen_action_to_tmpfile	function
(	O
DRAW_TO	int
,	O
&	O
p	struct
,	O
scale_flag	int
)	O
;	O
}	O
}	O
else	O
Pen_action_to_tmpfile	function
(	O
MOVE_TO	int
,	O
&	O
p	struct
,	O
scale_flag	int
)	O
;	O
outside	int
=	O
0	int
;	O
}	O
p_last	struct
.	O
x	int
=	O
p3	struct
.	O
x	int
;	O
p_last	struct
.	O
y	int
=	O
p3	struct
.	O
y	int
;	O
}	O
}	O
static	O
void	O
tarcs	function
(	O
int	O
relative	int
,	O
FILE	struct
*	O
hd	pointer
)	O
{	O
HPGL_Pt	struct
p	struct
,	O
p2	struct
,	O
p3	struct
,	O
center	struct
,	O
d	struct
;	O
float	O
alpha	float
,	O
eps	float
;	O
double	O
phi	double
,	O
phi0	double
,	O
r	char
;	O
double	O
SafeLinePatLen	double
=	O
CurrentLinePatLen	double
;	O
if	O
(	O
read_float	function
(	O
&	O
p2	struct
.	O
x	int
,	O
hd	pointer
)	O
)	O
return	O
;	O
if	O
(	O
read_float	function
(	O
&	O
p2	struct
.	O
y	int
,	O
hd	pointer
)	O
)	O
par_err_exit	function
(	O
2	int
,	O
AT	int
,	O
hd	pointer
)	O
;	O
if	O
(	O
read_float	function
(	O
&	O
p3	struct
.	O
x	int
,	O
hd	pointer
)	O
)	O
par_err_exit	function
(	O
3	int
,	O
AT	int
,	O
hd	pointer
)	O
;	O
if	O
(	O
read_float	function
(	O
&	O
p3	struct
.	O
y	int
,	O
hd	pointer
)	O
)	O
par_err_exit	function
(	O
3	int
,	O
AT	int
,	O
hd	pointer
)	O
;	O
switch	O
(	O
read_float	function
(	O
&	O
eps	float
,	O
hd	pointer
)	O
)	O
{	O
case	O
0	int
:	O
if	O
(	O
eps	float
<	O
0.5	int
)	O
eps	float
=	O
0.5	int
;	O
break	O
;	O
case	O
1	int
:	O
eps	float
=	O
5.0	int
;	O
break	O
;	O
case	O
2	int
:	O
par_err_exit	function
(	O
98	int
,	O
AT	int
,	O
hd	pointer
)	O
;	O
case	O
EOF	O
:	O
return	O
;	O
default	O
:	O
par_err_exit	function
(	O
99	int
,	O
AT	int
,	O
hd	pointer
)	O
;	O
}	O
if	O
(	O
ct_dist	short
==	O
FALSE	int
)	O
eps	float
*=	O
M_PI	int
/	O
180.0	int
;	O
d	struct
=	O
p_last	struct
;	O
if	O
(	O
!	O
relative	int
)	O
{	O
p2	struct
.	O
x	int
=	O
p2	struct
.	O
x	int
-	O
p_last	struct
.	O
x	int
;	O
p2	struct
.	O
y	int
=	O
p2	struct
.	O
y	int
-	O
p_last	struct
.	O
y	int
;	O
p3	struct
.	O
x	int
=	O
p3	struct
.	O
x	int
-	O
p_last	struct
.	O
x	int
;	O
p3	struct
.	O
y	int
=	O
p3	struct
.	O
y	int
-	O
p_last	struct
.	O
y	int
;	O
}	O
center	struct
.	O
x	int
=	O
(	O
2.	int
*	O
p2	struct
.	O
y	int
*	O
(	O
p3	struct
.	O
x	int
*	O
p3	struct
.	O
x	int
+	O
p3	struct
.	O
y	int
*	O
p3	struct
.	O
y	int
)	O
-	O
2.	int
*	O
p3	struct
.	O
y	int
*	O
p2	struct
.	O
x	int
*	O
p2	struct
.	O
x	int
-	O
2.	int
*	O
p3	struct
.	O
y	int
*	O
p2	struct
.	O
y	int
*	O
p2	struct
.	O
y	int
)	O
/	O
(	O
2.	int
*	O
p3	struct
.	O
x	int
-	O
4.	int
*	O
p2	struct
.	O
x	int
*	O
p3	struct
.	O
y	int
)	O
;	O
center	struct
.	O
y	int
=	O
(	O
p2	struct
.	O
x	int
*	O
p2	struct
.	O
x	int
+	O
p2	struct
.	O
y	int
*	O
p2	struct
.	O
y	int
-	O
2.	int
*	O
p2	struct
.	O
x	int
*	O
center	struct
.	O
x	int
)	O
/	O
(	O
2.	int
*	O
p2	struct
.	O
y	int
)	O
;	O
r	char
=	O
sqrt	function
(	O
center	struct
.	O
x	int
*	O
center	struct
.	O
x	int
+	O
center	struct
.	O
y	int
*	O
center	struct
.	O
y	int
)	O
;	O
if	O
(	O
ct_dist	short
==	O
TRUE	int
)	O
eps	float
=	O
2.	int
*	O
acos	function
(	O
(	O
r	char
-	O
eps	float
)	O
/	O
r	char
)	O
;	O
center	struct
.	O
x	int
=	O
center	struct
.	O
x	int
+	O
p_last	struct
.	O
x	int
;	O
center	struct
.	O
y	int
=	O
center	struct
.	O
y	int
+	O
p_last	struct
.	O
y	int
;	O
d	struct
.	O
x	int
=	O
p_last	struct
.	O
x	int
-	O
center	struct
.	O
x	int
;	O
d	struct
.	O
y	int
=	O
p_last	struct
.	O
y	int
-	O
center	struct
.	O
y	int
;	O
phi0	double
=	O
atan2	function
(	O
d	struct
.	O
y	int
,	O
d	struct
.	O
x	int
)	O
;	O
d	struct
.	O
x	int
=	O
p3	struct
.	O
x	int
+	O
p_last	struct
.	O
x	int
-	O
center	struct
.	O
x	int
;	O
d	struct
.	O
y	int
=	O
p3	struct
.	O
y	int
+	O
p_last	struct
.	O
y	int
-	O
center	struct
.	O
y	int
;	O
alpha	float
=	O
2.	int
*	O
atan2	function
(	O
d	struct
.	O
y	int
,	O
d	struct
.	O
x	int
)	O
;	O
if	O
(	O
CurrentLineType	enum
==	O
LT_adaptive	int
)	O
{	O
p	struct
.	O
x	int
=	O
r	char
*	O
cos	function
(	O
eps	float
)	O
;	O
p	struct
.	O
y	int
=	O
r	char
*	O
sin	function
(	O
eps	float
)	O
;	O
if	O
(	O
scale_flag	int
)	O
User_to_Plotter_coord	function
(	O
&	O
p	struct
,	O
&	O
p	struct
)	O
;	O
CurrentLinePatLen	double
=	O
HYPOT	O
(	O
p	struct
.	O
x	int
,	O
p	struct
.	O
y	int
)	O
;	O
}	O
if	O
(	O
alpha	float
>	O
0.0	int
)	O
{	O
for	O
(	O
phi	double
=	O
phi0	double
+	O
MIN	O
(	O
eps	float
,	O
alpha	float
)	O
;	O
phi	double
<	O
phi0	double
+	O
alpha	float
;	O
phi	double
+=	O
eps	float
)	O
arc_increment	function
(	O
&	O
center	struct
,	O
r	char
,	O
phi	double
)	O
;	O
arc_increment	function
(	O
&	O
center	struct
,	O
r	char
,	O
phi0	double
+	O
alpha	float
)	O
;	O
}	O
else	O
{	O
for	O
(	O
phi	double
=	O
phi0	double
-	O
MIN	O
(	O
eps	float
,	O
-	O
alpha	float
)	O
;	O
phi	double
>	O
phi0	double
+	O
alpha	float
;	O
phi	double
-=	O
eps	float
)	O
arc_increment	function
(	O
&	O
center	struct
,	O
r	char
,	O
phi	double
)	O
;	O
arc_increment	function
(	O
&	O
center	struct
,	O
r	char
,	O
phi0	double
+	O
alpha	float
)	O
;	O
}	O
CurrentLinePatLen	double
=	O
SafeLinePatLen	double
;	O
p_last	struct
.	O
x	int
=	O
p_last	struct
.	O
x	int
+	O
p3	struct
.	O
x	int
;	O
p_last	struct
.	O
y	int
=	O
p_last	struct
.	O
y	int
+	O
p3	struct
.	O
y	int
;	O
}	O
static	O
void	O
arcs	function
(	O
int	O
relative	int
,	O
FILE	struct
*	O
hd	pointer
)	O
{	O
HPGL_Pt	struct
p	struct
,	O
d	struct
,	O
center	struct
;	O
float	O
alpha	float
,	O
eps	float
;	O
double	O
phi	double
,	O
phi0	double
,	O
r	char
;	O
double	O
SafeLinePatLen	double
=	O
CurrentLinePatLen	double
;	O
if	O
(	O
read_float	function
(	O
&	O
p	struct
.	O
x	int
,	O
hd	pointer
)	O
)	O
return	O
;	O
if	O
(	O
read_float	function
(	O
&	O
p	struct
.	O
y	int
,	O
hd	pointer
)	O
)	O
par_err_exit	function
(	O
2	int
,	O
AA	int
,	O
hd	pointer
)	O
;	O
if	O
(	O
read_float	function
(	O
&	O
alpha	float
,	O
hd	pointer
)	O
)	O
par_err_exit	function
(	O
3	int
,	O
AA	int
,	O
hd	pointer
)	O
;	O
else	O
alpha	float
*=	O
M_PI	int
/	O
180.0	int
;	O
switch	O
(	O
read_float	function
(	O
&	O
eps	float
,	O
hd	pointer
)	O
)	O
{	O
case	O
0	int
:	O
if	O
(	O
eps	float
<	O
0.5	int
)	O
eps	float
=	O
0.5	int
;	O
break	O
;	O
case	O
1	int
:	O
eps	float
=	O
5.0	int
;	O
break	O
;	O
case	O
2	int
:	O
par_err_exit	function
(	O
98	int
,	O
AA	int
,	O
hd	pointer
)	O
;	O
case	O
EOF	O
:	O
return	O
;	O
default	O
:	O
par_err_exit	function
(	O
99	int
,	O
AA	int
,	O
hd	pointer
)	O
;	O
}	O
if	O
(	O
ct_dist	short
==	O
FALSE	int
)	O
eps	float
*=	O
M_PI	int
/	O
180.0	int
;	O
if	O
(	O
relative	int
)	O
{	O
d	struct
=	O
p	struct
;	O
center	struct
.	O
x	int
=	O
d	struct
.	O
x	int
+	O
p_last	struct
.	O
x	int
;	O
center	struct
.	O
y	int
=	O
d	struct
.	O
y	int
+	O
p_last	struct
.	O
y	int
;	O
}	O
else	O
{	O
d	struct
.	O
x	int
=	O
p	struct
.	O
x	int
-	O
p_last	struct
.	O
x	int
;	O
d	struct
.	O
y	int
=	O
p	struct
.	O
y	int
-	O
p_last	struct
.	O
y	int
;	O
center	struct
.	O
x	int
=	O
p	struct
.	O
x	int
;	O
center	struct
.	O
y	int
=	O
p	struct
.	O
y	int
;	O
}	O
if	O
(	O
(	O
(	O
r	char
=	O
sqrt	function
(	O
d	struct
.	O
x	int
*	O
d	struct
.	O
x	int
+	O
d	struct
.	O
y	int
*	O
d	struct
.	O
y	int
)	O
)	O
==	O
0.0	int
)	O
||	O
(	O
alpha	float
==	O
0.0	int
)	O
)	O
return	O
;	O
if	O
(	O
ct_dist	short
==	O
TRUE	int
)	O
eps	float
=	O
2.	int
*	O
acos	function
(	O
(	O
r	char
-	O
eps	float
)	O
/	O
r	char
)	O
;	O
phi0	double
=	O
atan2	function
(	O
-	O
d	struct
.	O
y	int
,	O
-	O
d	struct
.	O
x	int
)	O
;	O
if	O
(	O
CurrentLineType	enum
==	O
LT_adaptive	int
)	O
{	O
p	struct
.	O
x	int
=	O
r	char
*	O
cos	function
(	O
eps	float
)	O
;	O
p	struct
.	O
y	int
=	O
r	char
*	O
sin	function
(	O
eps	float
)	O
;	O
if	O
(	O
scale_flag	int
)	O
User_to_Plotter_coord	function
(	O
&	O
p	struct
,	O
&	O
p	struct
)	O
;	O
CurrentLinePatLen	double
=	O
HYPOT	O
(	O
p	struct
.	O
x	int
,	O
p	struct
.	O
y	int
)	O
;	O
}	O
if	O
(	O
alpha	float
>	O
0.0	int
)	O
{	O
for	O
(	O
phi	double
=	O
phi0	double
+	O
MIN	O
(	O
eps	float
,	O
alpha	float
)	O
;	O
phi	double
<	O
phi0	double
+	O
alpha	float
;	O
phi	double
+=	O
eps	float
)	O
arc_increment	function
(	O
&	O
center	struct
,	O
r	char
,	O
phi	double
)	O
;	O
arc_increment	function
(	O
&	O
center	struct
,	O
r	char
,	O
phi0	double
+	O
alpha	float
)	O
;	O
}	O
else	O
{	O
for	O
(	O
phi	double
=	O
phi0	double
-	O
MIN	O
(	O
eps	float
,	O
-	O
alpha	float
)	O
;	O
phi	double
>	O
phi0	double
+	O
alpha	float
;	O
phi	double
-=	O
eps	float
)	O
arc_increment	function
(	O
&	O
center	struct
,	O
r	char
,	O
phi	double
)	O
;	O
arc_increment	function
(	O
&	O
center	struct
,	O
r	char
,	O
phi0	double
+	O
alpha	float
)	O
;	O
}	O
CurrentLinePatLen	double
=	O
SafeLinePatLen	double
;	O
}	O
static	O
void	O
fwedges	function
(	O
FILE	struct
*	O
hd	pointer
,	O
float	O
cur_pensize	float
)	O
{	O
HPGL_Pt	struct
p	struct
,	O
oldp	struct
,	O
center	struct
;	O
float	O
eps	float
,	O
r	char
,	O
start	float
,	O
sweep	float
;	O
double	O
phi	double
;	O
double	O
SafeLinePatLen	double
=	O
CurrentLinePatLen	double
;	O
int	O
outside	int
=	O
0	int
;	O
int	O
i	int
;	O
if	O
(	O
read_float	function
(	O
&	O
r	char
,	O
hd	pointer
)	O
)	O
return	O
;	O
if	O
(	O
read_float	function
(	O
&	O
start	float
,	O
hd	pointer
)	O
)	O
return	O
;	O
if	O
(	O
read_float	function
(	O
&	O
sweep	float
,	O
hd	pointer
)	O
)	O
return	O
;	O
switch	O
(	O
read_float	function
(	O
&	O
eps	float
,	O
hd	pointer
)	O
)	O
{	O
case	O
0	int
:	O
if	O
(	O
eps	float
<	O
0.5	int
)	O
eps	float
=	O
0.5	int
;	O
break	O
;	O
case	O
1	int
:	O
eps	float
=	O
5.0	int
;	O
break	O
;	O
case	O
2	int
:	O
par_err_exit	function
(	O
98	int
,	O
EW	int
,	O
hd	pointer
)	O
;	O
case	O
EOF	O
:	O
return	O
;	O
default	O
:	O
par_err_exit	function
(	O
99	int
,	O
EW	int
,	O
hd	pointer
)	O
;	O
}	O
if	O
(	O
ct_dist	short
==	O
TRUE	int
)	O
eps	float
=	O
2.	int
*	O
acos	function
(	O
(	O
r	char
-	O
eps	float
)	O
/	O
r	char
)	O
;	O
else	O
eps	float
*=	O
M_PI	int
/	O
180.0	int
;	O
start	float
*=	O
M_PI	int
/	O
180.0	int
;	O
sweep	float
*=	O
M_PI	int
/	O
180.0	int
;	O
center	struct
=	O
p_last	struct
;	O
vertices	int
=	O
-	O
1	int
;	O
if	O
(	O
r	char
==	O
0.0	int
)	O
return	O
;	O
HPGL_Pt_to_polygon	function
(	O
p_last	struct
)	O
;	O
p	struct
.	O
x	int
=	O
center	struct
.	O
x	int
+	O
r	char
*	O
cos	function
(	O
start	float
)	O
;	O
p	struct
.	O
y	int
=	O
center	struct
.	O
y	int
+	O
r	char
*	O
sin	function
(	O
start	float
)	O
;	O
HPGL_Pt_to_polygon	function
(	O
p	struct
)	O
;	O
if	O
(	O
CurrentLineType	enum
==	O
LT_adaptive	int
)	O
{	O
p	struct
.	O
x	int
=	O
r	char
*	O
cos	function
(	O
eps	float
)	O
;	O
p	struct
.	O
y	int
=	O
r	char
*	O
sin	function
(	O
eps	float
)	O
;	O
if	O
(	O
scale_flag	int
)	O
User_to_Plotter_coord	function
(	O
&	O
p	struct
,	O
&	O
p	struct
)	O
;	O
CurrentLinePatLen	double
=	O
HYPOT	O
(	O
p	struct
.	O
x	int
,	O
p	struct
.	O
y	int
)	O
;	O
}	O
i	int
=	O
1	int
;	O
for	O
(	O
phi	double
=	O
eps	float
;	O
phi	double
<=	O
sweep	float
;	O
phi	double
+=	O
eps	float
)	O
{	O
oldp	struct
=	O
p	struct
;	O
p	struct
.	O
x	int
=	O
center	struct
.	O
x	int
+	O
r	char
*	O
cos	function
(	O
start	float
+	O
phi	double
)	O
;	O
p	struct
.	O
y	int
=	O
center	struct
.	O
y	int
+	O
r	char
*	O
sin	function
(	O
start	float
+	O
phi	double
)	O
;	O
if	O
(	O
iwflag	int
)	O
{	O
if	O
(	O
P1	struct
.	O
x	int
+	O
(	O
p	struct
.	O
x	int
-	O
S1	struct
.	O
x	int
)	O
*	O
Q	struct
.	O
x	int
>	O
C2	struct
.	O
x	int
||	O
P1	struct
.	O
y	int
+	O
(	O
p	struct
.	O
y	int
-	O
S1	struct
.	O
y	int
)	O
*	O
Q	struct
.	O
y	int
>	O
C2	struct
.	O
y	int
)	O
{	O
outside	int
=	O
1	int
;	O
}	O
if	O
(	O
P1	struct
.	O
x	int
+	O
(	O
p	struct
.	O
x	int
-	O
S1	struct
.	O
x	int
)	O
*	O
Q	struct
.	O
x	int
<	O
C1	struct
.	O
x	int
||	O
P1	struct
.	O
y	int
+	O
(	O
p	struct
.	O
y	int
-	O
S1	struct
.	O
y	int
)	O
*	O
Q	struct
.	O
y	int
<	O
C1	struct
.	O
y	int
)	O
{	O
outside	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
!	O
outside	int
)	O
{	O
HPGL_Pt_to_polygon	function
(	O
oldp	struct
)	O
;	O
HPGL_Pt_to_polygon	function
(	O
p	struct
)	O
;	O
}	O
outside	int
=	O
0	int
;	O
}	O
HPGL_Pt_to_polygon	function
(	O
p	struct
)	O
;	O
HPGL_Pt_to_polygon	function
(	O
center	struct
)	O
;	O
if	O
(	O
hatchspace	float
==	O
0.	int
)	O
hatchspace	float
=	O
cur_pensize	float
;	O
if	O
(	O
filltype	int
<	O
3	int
&&	O
thickness	float
>	O
0.	int
)	O
hatchspace	float
=	O
thickness	float
;	O
if	O
(	O
!	O
ac_flag	short
)	O
{	O
anchor	struct
.	O
x	int
=	O
P1	struct
.	O
x	int
;	O
anchor	struct
.	O
y	int
=	O
P1	struct
.	O
y	int
;	O
}	O
fill	function
(	O
polygons	array
,	O
vertices	int
,	O
anchor	struct
,	O
P2	struct
,	O
scale_flag	int
,	O
filltype	int
,	O
hatchspace	float
,	O
hatchangle	float
)	O
;	O
CurrentLinePatLen	double
=	O
SafeLinePatLen	double
;	O
}	O
static	O
void	O
circles	function
(	O
FILE	struct
*	O
hd	pointer
)	O
{	O
HPGL_Pt	struct
p	struct
,	O
center	struct
,	O
polyp	struct
;	O
float	O
eps	float
,	O
r	char
;	O
double	O
phi	double
;	O
double	O
SafeLinePatLen	double
=	O
CurrentLinePatLen	double
;	O
int	O
outside	int
=	O
0	int
;	O
if	O
(	O
read_float	function
(	O
&	O
r	char
,	O
hd	pointer
)	O
)	O
return	O
;	O
switch	O
(	O
read_float	function
(	O
&	O
eps	float
,	O
hd	pointer
)	O
)	O
{	O
case	O
0	int
:	O
if	O
(	O
eps	float
<	O
0.5	int
)	O
eps	float
=	O
0.5	int
;	O
break	O
;	O
case	O
1	int
:	O
eps	float
=	O
5.0	int
;	O
break	O
;	O
case	O
2	int
:	O
par_err_exit	function
(	O
98	int
,	O
CI	int
,	O
hd	pointer
)	O
;	O
case	O
EOF	O
:	O
return	O
;	O
default	O
:	O
par_err_exit	function
(	O
99	int
,	O
CI	int
,	O
hd	pointer
)	O
;	O
}	O
if	O
(	O
ct_dist	short
==	O
TRUE	int
)	O
eps	float
=	O
2.	int
*	O
acos	function
(	O
(	O
r	char
-	O
eps	float
)	O
/	O
r	char
)	O
;	O
else	O
eps	float
*=	O
M_PI	int
/	O
180.0	int
;	O
center	struct
=	O
p_last	struct
;	O
if	O
(	O
r	char
==	O
0.0	int
)	O
return	O
;	O
p	struct
.	O
x	int
=	O
center	struct
.	O
x	int
+	O
r	char
;	O
p	struct
.	O
y	int
=	O
center	struct
.	O
y	int
;	O
Pen_action_to_tmpfile	function
(	O
MOVE_TO	int
,	O
&	O
p	struct
,	O
scale_flag	int
)	O
;	O
if	O
(	O
polygon_mode	short
)	O
{	O
polyp	struct
.	O
x	int
=	O
p	struct
.	O
x	int
;	O
polyp	struct
.	O
y	int
=	O
p	struct
.	O
y	int
;	O
}	O
if	O
(	O
CurrentLineType	enum
==	O
LT_adaptive	int
)	O
{	O
p	struct
.	O
x	int
=	O
r	char
*	O
cos	function
(	O
eps	float
)	O
;	O
p	struct
.	O
y	int
=	O
r	char
*	O
sin	function
(	O
eps	float
)	O
;	O
if	O
(	O
scale_flag	int
)	O
User_to_Plotter_coord	function
(	O
&	O
p	struct
,	O
&	O
p	struct
)	O
;	O
CurrentLinePatLen	double
=	O
HYPOT	O
(	O
p	struct
.	O
x	int
,	O
p	struct
.	O
y	int
)	O
;	O
}	O
for	O
(	O
phi	double
=	O
eps	float
;	O
phi	double
<	O
2.0	int
*	O
M_PI	int
;	O
phi	double
+=	O
eps	float
)	O
{	O
p	struct
.	O
x	int
=	O
center	struct
.	O
x	int
+	O
r	char
*	O
cos	function
(	O
phi	double
)	O
;	O
p	struct
.	O
y	int
=	O
center	struct
.	O
y	int
+	O
r	char
*	O
sin	function
(	O
phi	double
)	O
;	O
if	O
(	O
iwflag	int
)	O
{	O
if	O
(	O
P1	struct
.	O
x	int
+	O
(	O
p	struct
.	O
x	int
-	O
S1	struct
.	O
x	int
)	O
*	O
Q	struct
.	O
x	int
>	O
C2	struct
.	O
x	int
||	O
P1	struct
.	O
y	int
+	O
(	O
p	struct
.	O
y	int
-	O
S1	struct
.	O
y	int
)	O
*	O
Q	struct
.	O
y	int
>	O
C2	struct
.	O
y	int
)	O
{	O
outside	int
=	O
1	int
;	O
}	O
if	O
(	O
P1	struct
.	O
x	int
+	O
(	O
p	struct
.	O
x	int
-	O
S1	struct
.	O
x	int
)	O
*	O
Q	struct
.	O
x	int
<	O
C1	struct
.	O
x	int
||	O
P1	struct
.	O
y	int
+	O
(	O
p	struct
.	O
y	int
-	O
S1	struct
.	O
y	int
)	O
*	O
Q	struct
.	O
y	int
<	O
C1	struct
.	O
y	int
)	O
{	O
outside	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
!	O
outside	int
)	O
{	O
if	O
(	O
polygon_mode	short
)	O
{	O
HPGL_Pt_to_polygon	function
(	O
polyp	struct
)	O
;	O
HPGL_Pt_to_polygon	function
(	O
p	struct
)	O
;	O
polyp	struct
.	O
x	int
=	O
p	struct
.	O
x	int
;	O
polyp	struct
.	O
y	int
=	O
p	struct
.	O
y	int
;	O
}	O
else	O
{	O
Pen_action_to_tmpfile	function
(	O
DRAW_TO	int
,	O
&	O
p	struct
,	O
scale_flag	int
)	O
;	O
}	O
}	O
else	O
Pen_action_to_tmpfile	function
(	O
MOVE_TO	int
,	O
&	O
p	struct
,	O
scale_flag	int
)	O
;	O
outside	int
=	O
0	int
;	O
}	O
p	struct
.	O
x	int
=	O
center	struct
.	O
x	int
+	O
r	char
;	O
p	struct
.	O
y	int
=	O
center	struct
.	O
y	int
;	O
if	O
(	O
polygon_mode	short
)	O
{	O
HPGL_Pt_to_polygon	function
(	O
polyp	struct
)	O
;	O
HPGL_Pt_to_polygon	function
(	O
p	struct
)	O
;	O
}	O
else	O
Pen_action_to_tmpfile	function
(	O
DRAW_TO	int
,	O
&	O
p	struct
,	O
scale_flag	int
)	O
;	O
if	O
(	O
!	O
polygon_mode	short
)	O
{	O
p	struct
.	O
x	int
=	O
center	struct
.	O
x	int
+	O
r	char
*	O
cos	function
(	O
eps	float
)	O
;	O
p	struct
.	O
y	int
=	O
center	struct
.	O
y	int
+	O
r	char
*	O
sin	function
(	O
eps	float
)	O
;	O
if	O
(	O
iwflag	int
)	O
{	O
if	O
(	O
P1	struct
.	O
x	int
+	O
(	O
p	struct
.	O
x	int
-	O
S1	struct
.	O
x	int
)	O
*	O
Q	struct
.	O
x	int
>	O
C2	struct
.	O
x	int
||	O
P1	struct
.	O
y	int
+	O
(	O
p	struct
.	O
y	int
-	O
S1	struct
.	O
y	int
)	O
*	O
Q	struct
.	O
y	int
>	O
C2	struct
.	O
y	int
)	O
{	O
outside	int
=	O
1	int
;	O
}	O
if	O
(	O
P1	struct
.	O
x	int
+	O
(	O
p	struct
.	O
x	int
-	O
S1	struct
.	O
x	int
)	O
*	O
Q	struct
.	O
x	int
<	O
C1	struct
.	O
x	int
||	O
P1	struct
.	O
y	int
+	O
(	O
p	struct
.	O
y	int
-	O
S1	struct
.	O
y	int
)	O
*	O
Q	struct
.	O
y	int
<	O
C1	struct
.	O
y	int
)	O
{	O
outside	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
!	O
outside	int
)	O
{	O
if	O
(	O
polygon_mode	short
)	O
{	O
HPGL_Pt_to_polygon	function
(	O
polyp	struct
)	O
;	O
HPGL_Pt_to_polygon	function
(	O
p	struct
)	O
;	O
polyp	struct
.	O
x	int
=	O
p	struct
.	O
x	int
;	O
polyp	struct
.	O
y	int
=	O
p	struct
.	O
y	int
;	O
}	O
else	O
{	O
Pen_action_to_tmpfile	function
(	O
DRAW_TO	int
,	O
&	O
p	struct
,	O
scale_flag	int
)	O
;	O
}	O
}	O
}	O
Pen_action_to_tmpfile	function
(	O
MOVE_TO	int
,	O
&	O
center	struct
,	O
scale_flag	int
)	O
;	O
CurrentLinePatLen	double
=	O
SafeLinePatLen	double
;	O
}	O
static	O
void	O
wedges	function
(	O
FILE	struct
*	O
hd	pointer
)	O
{	O
HPGL_Pt	struct
p	struct
,	O
center	struct
;	O
float	O
eps	float
,	O
r	char
,	O
start	float
,	O
sweep	float
;	O
double	O
phi	double
;	O
double	O
SafeLinePatLen	double
=	O
CurrentLinePatLen	double
;	O
int	O
outside	int
=	O
0	int
;	O
if	O
(	O
read_float	function
(	O
&	O
r	char
,	O
hd	pointer
)	O
)	O
return	O
;	O
if	O
(	O
read_float	function
(	O
&	O
start	float
,	O
hd	pointer
)	O
)	O
return	O
;	O
if	O
(	O
read_float	function
(	O
&	O
sweep	float
,	O
hd	pointer
)	O
)	O
return	O
;	O
switch	O
(	O
read_float	function
(	O
&	O
eps	float
,	O
hd	pointer
)	O
)	O
{	O
case	O
0	int
:	O
if	O
(	O
eps	float
<	O
0.5	int
)	O
eps	float
=	O
0.5	int
;	O
break	O
;	O
case	O
1	int
:	O
eps	float
=	O
5.0	int
;	O
break	O
;	O
case	O
2	int
:	O
par_err_exit	function
(	O
98	int
,	O
EW	int
,	O
hd	pointer
)	O
;	O
case	O
EOF	O
:	O
return	O
;	O
default	O
:	O
par_err_exit	function
(	O
99	int
,	O
EW	int
,	O
hd	pointer
)	O
;	O
}	O
if	O
(	O
ct_dist	short
==	O
TRUE	int
)	O
eps	float
=	O
2.	int
*	O
acos	function
(	O
(	O
r	char
-	O
eps	float
)	O
/	O
r	char
)	O
;	O
else	O
eps	float
*=	O
M_PI	int
/	O
180.0	int
;	O
start	float
*=	O
M_PI	int
/	O
180.0	int
;	O
sweep	float
*=	O
M_PI	int
/	O
180.0	int
;	O
center	struct
=	O
p_last	struct
;	O
if	O
(	O
r	char
==	O
0.0	int
)	O
return	O
;	O
p	struct
.	O
x	int
=	O
center	struct
.	O
x	int
+	O
r	char
*	O
cos	function
(	O
start	float
)	O
;	O
p	struct
.	O
y	int
=	O
center	struct
.	O
y	int
+	O
r	char
*	O
sin	function
(	O
start	float
)	O
;	O
Pen_action_to_tmpfile	function
(	O
DRAW_TO	int
,	O
&	O
p	struct
,	O
scale_flag	int
)	O
;	O
if	O
(	O
CurrentLineType	enum
==	O
LT_adaptive	int
)	O
{	O
p	struct
.	O
x	int
=	O
r	char
*	O
cos	function
(	O
eps	float
)	O
;	O
p	struct
.	O
y	int
=	O
r	char
*	O
sin	function
(	O
eps	float
)	O
;	O
if	O
(	O
scale_flag	int
)	O
User_to_Plotter_coord	function
(	O
&	O
p	struct
,	O
&	O
p	struct
)	O
;	O
CurrentLinePatLen	double
=	O
HYPOT	O
(	O
p	struct
.	O
x	int
,	O
p	struct
.	O
y	int
)	O
;	O
}	O
for	O
(	O
phi	double
=	O
eps	float
;	O
phi	double
<=	O
sweep	float
;	O
phi	double
+=	O
eps	float
)	O
{	O
p	struct
.	O
x	int
=	O
center	struct
.	O
x	int
+	O
r	char
*	O
cos	function
(	O
start	float
+	O
phi	double
)	O
;	O
p	struct
.	O
y	int
=	O
center	struct
.	O
y	int
+	O
r	char
*	O
sin	function
(	O
start	float
+	O
phi	double
)	O
;	O
if	O
(	O
iwflag	int
)	O
{	O
if	O
(	O
P1	struct
.	O
x	int
+	O
(	O
p	struct
.	O
x	int
-	O
S1	struct
.	O
x	int
)	O
*	O
Q	struct
.	O
x	int
>	O
C2	struct
.	O
x	int
||	O
P1	struct
.	O
y	int
+	O
(	O
p	struct
.	O
y	int
-	O
S1	struct
.	O
y	int
)	O
*	O
Q	struct
.	O
y	int
>	O
C2	struct
.	O
y	int
)	O
{	O
outside	int
=	O
1	int
;	O
}	O
if	O
(	O
P1	struct
.	O
x	int
+	O
(	O
p	struct
.	O
x	int
-	O
S1	struct
.	O
x	int
)	O
*	O
Q	struct
.	O
x	int
<	O
C1	struct
.	O
x	int
||	O
P1	struct
.	O
y	int
+	O
(	O
p	struct
.	O
y	int
-	O
S1	struct
.	O
y	int
)	O
*	O
Q	struct
.	O
y	int
<	O
C1	struct
.	O
y	int
)	O
{	O
outside	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
!	O
outside	int
)	O
Pen_action_to_tmpfile	function
(	O
DRAW_TO	int
,	O
&	O
p	struct
,	O
scale_flag	int
)	O
;	O
else	O
Pen_action_to_tmpfile	function
(	O
MOVE_TO	int
,	O
&	O
p	struct
,	O
scale_flag	int
)	O
;	O
outside	int
=	O
0	int
;	O
}	O
Pen_action_to_tmpfile	function
(	O
DRAW_TO	int
,	O
&	O
center	struct
,	O
scale_flag	int
)	O
;	O
CurrentLinePatLen	double
=	O
SafeLinePatLen	double
;	O
}	O
static	O
void	O
ax_ticks	function
(	O
int	O
mode	enum
)	O
{	O
HPGL_Pt	struct
p0	struct
,	O
p1	struct
,	O
p2	struct
;	O
LineType	enum
SafeLineType	enum
=	O
CurrentLineType	enum
;	O
p0	struct
=	O
p1	struct
=	O
p2	struct
=	O
p_last	struct
;	O
CurrentLineType	enum
=	O
LT_solid	int
;	O
if	O
(	O
mode	enum
==	O
0	int
)	O
{	O
if	O
(	O
scale_flag	int
)	O
{	O
p1	struct
.	O
y	int
-=	O
neg_ticklen	float
*	O
(	O
P2	struct
.	O
y	int
-	O
P1	struct
.	O
y	int
)	O
/	O
Q	struct
.	O
y	int
;	O
p2	struct
.	O
y	int
+=	O
pos_ticklen	float
*	O
(	O
P2	struct
.	O
y	int
-	O
P1	struct
.	O
y	int
)	O
/	O
Q	struct
.	O
y	int
;	O
}	O
else	O
{	O
p1	struct
.	O
y	int
-=	O
neg_ticklen	float
*	O
(	O
P2	struct
.	O
y	int
-	O
P1	struct
.	O
y	int
)	O
;	O
p2	struct
.	O
y	int
+=	O
pos_ticklen	float
*	O
(	O
P2	struct
.	O
y	int
-	O
P1	struct
.	O
y	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
scale_flag	int
)	O
{	O
p1	struct
.	O
x	int
-=	O
neg_ticklen	float
*	O
(	O
P2	struct
.	O
x	int
-	O
P1	struct
.	O
x	int
)	O
/	O
Q	struct
.	O
x	int
;	O
p2	struct
.	O
x	int
+=	O
pos_ticklen	float
*	O
(	O
P2	struct
.	O
x	int
-	O
P1	struct
.	O
x	int
)	O
/	O
Q	struct
.	O
x	int
;	O
}	O
else	O
{	O
p1	struct
.	O
x	int
-=	O
neg_ticklen	float
*	O
(	O
P2	struct
.	O
x	int
-	O
P1	struct
.	O
x	int
)	O
;	O
p2	struct
.	O
x	int
+=	O
pos_ticklen	float
*	O
(	O
P2	struct
.	O
x	int
-	O
P1	struct
.	O
x	int
)	O
;	O
}	O
}	O
Pen_action_to_tmpfile	function
(	O
MOVE_TO	int
,	O
&	O
p1	struct
,	O
scale_flag	int
)	O
;	O
Pen_action_to_tmpfile	function
(	O
DRAW_TO	int
,	O
&	O
p2	struct
,	O
scale_flag	int
)	O
;	O
Pen_action_to_tmpfile	function
(	O
MOVE_TO	int
,	O
&	O
p0	struct
,	O
scale_flag	int
)	O
;	O
CurrentLineType	enum
=	O
SafeLineType	enum
;	O
}	O
static	O
void	O
read_HPGL_cmd	function
(	O
GEN_PAR	struct
*	O
pg	pointer
,	O
int	O
cmd	enum
,	O
FILE	struct
*	O
hd	pointer
)	O
{	O
short	O
old_pen	short
;	O
HPGL_Pt	struct
p1	struct
=	O
{	O
0.	int
,	O
0.	int
}	O
,	O
p2	struct
=	O
{	O
0.	int
,	O
0.	int
}	O
;	O
float	O
ftmp	float
;	O
float	O
csfont	float
;	O
int	O
mypen	int
,	O
myred	int
,	O
mygreen	int
,	O
myblue	int
,	O
i	int
;	O
float	O
mywidth	float
,	O
myheight	float
;	O
char	O
tmpstr	array
[	O
1024	int
]	O
;	O
char	O
SafeTerm	char
;	O
static	O
int	O
FoundUserFill	int
=	O
0	int
;	O
switch	O
(	O
cmd	enum
&	O
0xDFDF	int
)	O
{	O
case	O
AA	int
:	O
arcs	function
(	O
FALSE	int
,	O
hd	pointer
)	O
;	O
tp	pointer
->	O
CR_point	struct
=	O
HP_pos	struct
;	O
break	O
;	O
case	O
AR	int
:	O
arcs	function
(	O
TRUE	int
,	O
hd	pointer
)	O
;	O
tp	pointer
->	O
CR_point	struct
=	O
HP_pos	struct
;	O
break	O
;	O
case	O
AT	int
:	O
tarcs	function
(	O
FALSE	int
,	O
hd	pointer
)	O
;	O
break	O
;	O
case	O
BR	int
:	O
bezier	function
(	O
TRUE	int
,	O
hd	pointer
)	O
;	O
break	O
;	O
case	O
BZ	int
:	O
bezier	function
(	O
FALSE	int
,	O
hd	pointer
)	O
;	O
break	O
;	O
case	O
AC	int
:	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
)	O
{	O
anchor	struct
.	O
x	int
=	O
P1	struct
.	O
x	int
;	O
anchor	struct
.	O
y	int
=	O
P1	struct
.	O
y	int
;	O
if	O
(	O
scale_flag	int
)	O
User_to_Plotter_coord	function
(	O
&	O
anchor	struct
,	O
&	O
anchor	struct
)	O
;	O
break	O
;	O
}	O
else	O
{	O
ac_flag	short
=	O
1	int
;	O
anchor	struct
.	O
x	int
=	O
ftmp	float
;	O
}	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
)	O
anchor	struct
.	O
y	int
=	O
0.	int
;	O
else	O
anchor	struct
.	O
y	int
=	O
ftmp	float
;	O
if	O
(	O
scale_flag	int
)	O
User_to_Plotter_coord	function
(	O
&	O
anchor	struct
,	O
&	O
anchor	struct
)	O
;	O
break	O
;	O
case	O
AD	int
:	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
)	O
tp	pointer
->	O
altfont	int
=	O
0	int
;	O
else	O
{	O
switch	O
(	O
(	O
int	O
)	O
ftmp	float
)	O
{	O
case	O
1	int
:	O
if	O
(	O
read_float	function
(	O
&	O
csfont	float
,	O
hd	pointer
)	O
)	O
par_err_exit	function
(	O
2	int
,	O
cmd	enum
,	O
hd	pointer
)	O
;	O
else	O
tp	pointer
->	O
altfont	int
=	O
(	O
int	O
)	O
csfont	float
;	O
break	O
;	O
case	O
2	int
:	O
if	O
(	O
read_float	function
(	O
&	O
csfont	float
,	O
hd	pointer
)	O
)	O
par_err_exit	function
(	O
2	int
,	O
cmd	enum
,	O
hd	pointer
)	O
;	O
else	O
if	O
(	O
(	O
int	O
)	O
csfont	float
==	O
1	int
&&	O
!	O
silent_mode	short
)	O
fprintf	function
(	O
stderr	pointer
,	O
"only fixed fonts available\n"	pointer
)	O
;	O
break	O
;	O
case	O
3	int
:	O
case	O
4	int
:	O
case	O
5	int
:	O
case	O
6	int
:	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
)	O
par_err_exit	function
(	O
2	int
,	O
cmd	enum
,	O
hd	pointer
)	O
;	O
if	O
(	O
ftmp	float
==	O
9999	int
)	O
tp	pointer
->	O
astrokewidth	double
=	O
ftmp	float
;	O
else	O
{	O
if	O
(	O
ftmp	float
<	O
-	O
7.	int
||	O
ftmp	float
>	O
7.	int
)	O
ftmp	float
=	O
0.	int
;	O
tp	pointer
->	O
astrokewidth	double
=	O
0.11	int
+	O
ftmp	float
/	O
70.	int
;	O
}	O
break	O
;	O
case	O
7	int
:	O
if	O
(	O
read_float	function
(	O
&	O
csfont	float
,	O
hd	pointer
)	O
)	O
par_err_exit	function
(	O
2	int
,	O
cmd	enum
,	O
hd	pointer
)	O
;	O
else	O
if	O
(	O
!	O
silent_mode	short
)	O
fprintf	function
(	O
stderr	pointer
,	O
"pitch/height/posture/typeface unsupported\n"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
par_err_exit	function
(	O
1	int
,	O
cmd	enum
,	O
hd	pointer
)	O
;	O
}	O
}	O
break	O
;	O
case	O
CA	int
:	O
if	O
(	O
read_float	function
(	O
&	O
csfont	float
,	O
hd	pointer
)	O
)	O
tp	pointer
->	O
altfont	int
=	O
0	int
;	O
else	O
tp	pointer
->	O
altfont	int
=	O
(	O
int	O
)	O
csfont	float
;	O
break	O
;	O
case	O
CI	int
:	O
circles	function
(	O
hd	pointer
)	O
;	O
break	O
;	O
case	O
CO	int
:	O
SafeTerm	char
=	O
StrTerm	char
;	O
StrTerm	char
=	O
';'	O
;	O
read_string	function
(	O
tmpstr	array
,	O
hd	pointer
)	O
;	O
StrTerm	char
=	O
SafeTerm	char
;	O
if	O
(	O
strlen	function
(	O
tmpstr	array
)	O
>	O
0	int
)	O
tmpstr	array
[	O
strlen	function
(	O
tmpstr	array
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
!	O
silent_mode	short
)	O
printf	function
(	O
"\n%s\n"	pointer
,	O
tmpstr	array
)	O
;	O
break	O
;	O
case	O
CR	int
:	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
)	O
{	O
r_base	char
=	O
g_base	char
=	O
b_base	char
=	O
0	int
;	O
r_max	char
=	O
g_max	char
=	O
b_max	char
=	O
255	int
;	O
break	O
;	O
}	O
else	O
{	O
r_base	char
=	O
(	O
unsigned	O
char	O
)	O
ftmp	float
;	O
}	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
)	O
{	O
r_max	char
=	O
255	int
;	O
break	O
;	O
}	O
else	O
{	O
r_max	char
=	O
(	O
unsigned	O
char	O
)	O
ftmp	float
;	O
}	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
)	O
{	O
break	O
;	O
}	O
else	O
{	O
g_base	char
=	O
(	O
unsigned	O
char	O
)	O
ftmp	float
;	O
}	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
)	O
{	O
g_max	char
=	O
255	int
;	O
break	O
;	O
}	O
else	O
{	O
g_max	char
=	O
(	O
unsigned	O
char	O
)	O
ftmp	float
;	O
}	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
)	O
{	O
break	O
;	O
}	O
else	O
{	O
b_base	char
=	O
(	O
unsigned	O
char	O
)	O
ftmp	float
;	O
}	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
)	O
{	O
b_max	char
=	O
255	int
;	O
break	O
;	O
}	O
else	O
{	O
b_max	char
=	O
(	O
unsigned	O
char	O
)	O
ftmp	float
;	O
break	O
;	O
}	O
case	O
CS	int
:	O
if	O
(	O
read_float	function
(	O
&	O
csfont	float
,	O
hd	pointer
)	O
)	O
tp	pointer
->	O
font	int
=	O
0	int
;	O
else	O
tp	pointer
->	O
font	int
=	O
(	O
int	O
)	O
csfont	float
;	O
tp	pointer
->	O
stdfont	int
=	O
tp	pointer
->	O
font	int
;	O
break	O
;	O
case	O
CT	int
:	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
||	O
ftmp	float
!=	O
1.	int
)	O
ct_dist	short
=	O
FALSE	int
;	O
else	O
ct_dist	short
=	O
TRUE	int
;	O
break	O
;	O
case	O
EP	int
:	O
if	O
(	O
polygon_penup	short
==	O
TRUE	int
)	O
if	O
(	O
p_last	struct
.	O
x	int
!=	O
polystart	struct
.	O
x	int
||	O
p_last	struct
.	O
y	int
!=	O
polystart	struct
.	O
y	int
)	O
vertices	int
-=	O
2	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
vertices	int
;	O
i	int
=	O
i	int
+	O
2	int
)	O
{	O
p1	struct
.	O
x	int
=	O
polygons	array
[	O
i	int
]	O
.	O
x	int
;	O
p1	struct
.	O
y	int
=	O
polygons	array
[	O
i	int
]	O
.	O
y	int
;	O
Pen_action_to_tmpfile	function
(	O
MOVE_TO	int
,	O
&	O
p1	struct
,	O
scale_flag	int
)	O
;	O
p1	struct
.	O
x	int
=	O
polygons	array
[	O
i	int
+	O
1	int
]	O
.	O
x	int
;	O
p1	struct
.	O
y	int
=	O
polygons	array
[	O
i	int
+	O
1	int
]	O
.	O
y	int
;	O
Pen_action_to_tmpfile	function
(	O
DRAW_TO	int
,	O
&	O
p1	struct
,	O
scale_flag	int
)	O
;	O
}	O
Pen_action_to_tmpfile	function
(	O
MOVE_TO	int
,	O
&	O
p_last	struct
,	O
scale_flag	int
)	O
;	O
break	O
;	O
case	O
EW	int
:	O
wedges	function
(	O
hd	pointer
)	O
;	O
break	O
;	O
case	O
EC	int
:	O
break	O
;	O
case	O
FP	int
:	O
if	O
(	O
pg	pointer
->	O
nofill	int
)	O
{	O
if	O
(	O
!	O
silent_mode	short
)	O
fprintf	function
(	O
stderr	pointer
,	O
"FP : suppressed\n"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
vertices	int
;	O
i	int
=	O
i	int
+	O
2	int
)	O
{	O
p1	struct
.	O
x	int
=	O
polygons	array
[	O
i	int
]	O
.	O
x	int
;	O
p1	struct
.	O
y	int
=	O
polygons	array
[	O
i	int
]	O
.	O
y	int
;	O
Pen_action_to_tmpfile	function
(	O
MOVE_TO	int
,	O
&	O
p1	struct
,	O
scale_flag	int
)	O
;	O
p1	struct
.	O
x	int
=	O
polygons	array
[	O
i	int
+	O
1	int
]	O
.	O
x	int
;	O
p1	struct
.	O
y	int
=	O
polygons	array
[	O
i	int
+	O
1	int
]	O
.	O
y	int
;	O
Pen_action_to_tmpfile	function
(	O
DRAW_TO	int
,	O
&	O
p1	struct
,	O
scale_flag	int
)	O
;	O
}	O
Pen_action_to_tmpfile	function
(	O
MOVE_TO	int
,	O
&	O
p_last	struct
,	O
scale_flag	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
hatchspace	float
==	O
0.	int
)	O
hatchspace	float
=	O
pt	struct
.	O
width	array
[	O
pen	int
]	O
;	O
if	O
(	O
filltype	int
<	O
3	int
&&	O
thickness	float
>	O
0.	int
)	O
hatchspace	float
=	O
thickness	float
;	O
if	O
(	O
!	O
ac_flag	short
)	O
{	O
anchor	struct
.	O
x	int
=	O
P1	struct
.	O
x	int
;	O
anchor	struct
.	O
y	int
=	O
P1	struct
.	O
y	int
;	O
}	O
fill	function
(	O
polygons	array
,	O
vertices	int
,	O
anchor	struct
,	O
P2	struct
,	O
scale_flag	int
,	O
filltype	int
,	O
hatchspace	float
,	O
hatchangle	float
)	O
;	O
Pen_action_to_tmpfile	function
(	O
MOVE_TO	int
,	O
&	O
p_last	struct
,	O
scale_flag	int
)	O
;	O
break	O
;	O
case	O
FT	int
:	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
)	O
{	O
filltype	int
=	O
1	int
;	O
break	O
;	O
}	O
else	O
{	O
filltype	int
=	O
(	O
int	O
)	O
ftmp	float
;	O
}	O
if	O
(	O
filltype	int
<	O
3	int
)	O
break	O
;	O
if	O
(	O
filltype	int
>	O
4	int
)	O
{	O
if	O
(	O
FoundUserFill	int
==	O
0	int
)	O
{	O
FoundUserFill	int
=	O
1	int
;	O
if	O
(	O
!	O
silent_mode	short
)	O
fprintf	function
(	O
stderr	pointer
,	O
"\nNo support for user-defined fill types, using type 1 instead\n"	pointer
)	O
;	O
}	O
filltype	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
)	O
{	O
hatchspace	float
=	O
saved_hatchspace	array
[	O
filltype	int
-	O
3	int
]	O
;	O
if	O
(	O
hatchspace	float
==	O
0.	int
)	O
hatchspace	float
=	O
0.01	int
*	O
Diag_P1_P2	double
;	O
hatchangle	float
=	O
saved_hatchangle	array
[	O
filltype	int
-	O
3	int
]	O
;	O
break	O
;	O
}	O
else	O
{	O
if	O
(	O
ftmp	float
<=	O
0.	int
)	O
ftmp	float
=	O
0.01	int
*	O
Diag_P1_P2	double
;	O
hatchspace	float
=	O
ftmp	float
;	O
saved_hatchspace	array
[	O
filltype	int
-	O
3	int
]	O
=	O
hatchspace	float
;	O
}	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
)	O
{	O
hatchangle	float
=	O
saved_hatchangle	array
[	O
filltype	int
-	O
3	int
]	O
;	O
break	O
;	O
}	O
else	O
{	O
hatchangle	float
=	O
ftmp	float
;	O
saved_hatchangle	array
[	O
filltype	int
-	O
3	int
]	O
=	O
hatchangle	float
;	O
}	O
break	O
;	O
case	O
NP	int
:	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
||	O
ftmp	float
>	O
NUMPENS	int
)	O
break	O
;	O
else	O
{	O
pg	pointer
->	O
maxpens	int
=	O
(	O
int	O
)	O
ftmp	float
;	O
if	O
(	O
!	O
silent_mode	short
)	O
fprintf	function
(	O
stderr	pointer
,	O
"NP: %d pens requested\n"	pointer
,	O
pg	pointer
->	O
maxpens	int
)	O
;	O
}	O
break	O
;	O
case	O
NR	int
:	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
)	O
break	O
;	O
break	O
;	O
case	O
PA	int
:	O
lines	function
(	O
plot_rel	short
=	O
FALSE	int
,	O
hd	pointer
)	O
;	O
tp	pointer
->	O
CR_point	struct
=	O
HP_pos	struct
;	O
break	O
;	O
case	O
PC	int
:	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
||	O
fixedcolor	short
||	O
(	O
int	O
)	O
ftmp	float
>	O
pg	pointer
->	O
maxpens	int
)	O
{	O
break	O
;	O
}	O
else	O
{	O
mypen	int
=	O
(	O
int	O
)	O
ftmp	float
;	O
if	O
(	O
pg	pointer
->	O
mapzero	int
==	O
mypen	int
)	O
break	O
;	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
)	O
myred	int
=	O
0	int
;	O
else	O
myred	int
=	O
255	int
*	O
(	O
ftmp	float
-	O
r_base	char
)	O
/	O
r_max	char
;	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
)	O
mygreen	int
=	O
0	int
;	O
else	O
mygreen	int
=	O
255	int
*	O
(	O
ftmp	float
-	O
g_base	char
)	O
/	O
g_max	char
;	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
)	O
myblue	int
=	O
0	int
;	O
else	O
myblue	int
=	O
255	int
*	O
(	O
ftmp	float
-	O
b_base	char
)	O
/	O
b_max	char
;	O
pg	pointer
->	O
is_color	int
=	O
TRUE	int
;	O
PlotCmd_to_tmpfile	function
(	O
DEF_PC	int
)	O
;	O
if	O
(	O
mypen	int
==	O
0	int
&&	O
pg	pointer
->	O
mapzero	int
>	O
-	O
1	int
)	O
mypen	int
=	O
pg	pointer
->	O
mapzero	int
;	O
Pen_Color_to_tmpfile	function
(	O
mypen	int
,	O
myred	int
,	O
mygreen	int
,	O
myblue	int
)	O
;	O
break	O
;	O
}	O
case	O
PD	int
:	O
pen_down	short
=	O
TRUE	int
;	O
lines	function
(	O
plot_rel	short
,	O
hd	pointer
)	O
;	O
tp	pointer
->	O
CR_point	struct
=	O
HP_pos	struct
;	O
break	O
;	O
case	O
PE	int
:	O
read_PE	function
(	O
pg	pointer
,	O
hd	pointer
)	O
;	O
tp	pointer
->	O
CR_point	struct
=	O
HP_pos	struct
;	O
break	O
;	O
case	O
PM	int
:	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
||	O
ftmp	float
==	O
0	int
)	O
{	O
polygon_mode	short
=	O
TRUE	int
;	O
polygon_penup	short
=	O
FALSE	int
;	O
saved_penstate	short
=	O
pen_down	short
;	O
vertices	int
=	O
-	O
1	int
;	O
polystart	struct
=	O
p_last	struct
;	O
break	O
;	O
}	O
if	O
(	O
ftmp	float
==	O
1	int
)	O
{	O
if	O
(	O
vertices	int
>	O
0	int
)	O
polygon_penup	short
=	O
TRUE	int
;	O
pen_down	short
=	O
FALSE	int
;	O
break	O
;	O
}	O
if	O
(	O
ftmp	float
==	O
2	int
)	O
{	O
polygon_mode	short
=	O
FALSE	int
;	O
pen_down	short
=	O
saved_penstate	short
;	O
if	O
(	O
p_last	struct
.	O
x	int
!=	O
polystart	struct
.	O
x	int
||	O
p_last	struct
.	O
y	int
!=	O
polystart	struct
.	O
y	int
)	O
{	O
int	O
outside	int
=	O
0	int
;	O
double	O
x1	double
,	O
y1	function
,	O
x2	pointer
,	O
y2	pointer
;	O
if	O
(	O
iwflag	int
)	O
{	O
x1	double
=	O
P1	struct
.	O
x	int
+	O
(	O
p_last	struct
.	O
x	int
-	O
S1	struct
.	O
x	int
)	O
*	O
Q	struct
.	O
x	int
;	O
y1	function
=	O
P1	struct
.	O
y	int
+	O
(	O
p_last	struct
.	O
y	int
-	O
S1	struct
.	O
y	int
)	O
*	O
Q	struct
.	O
y	int
;	O
x2	pointer
=	O
P1	struct
.	O
x	int
+	O
(	O
polystart	struct
.	O
x	int
-	O
S1	struct
.	O
x	int
)	O
*	O
Q	struct
.	O
x	int
;	O
y2	pointer
=	O
P1	struct
.	O
y	int
+	O
(	O
polystart	struct
.	O
y	int
-	O
S1	struct
.	O
y	int
)	O
*	O
Q	struct
.	O
y	int
;	O
outside	int
=	O
(	O
DtClipLine	function
(	O
C1	struct
.	O
x	int
,	O
C1	struct
.	O
y	int
,	O
C2	struct
.	O
x	int
,	O
C2	struct
.	O
y	int
,	O
&	O
x1	double
,	O
&	O
y1	function
,	O
&	O
x2	pointer
,	O
&	O
y2	pointer
)	O
==	O
CLIP_NODRAW	int
)	O
;	O
if	O
(	O
!	O
outside	int
)	O
{	O
p_last	struct
.	O
x	int
=	O
(	O
x2	pointer
-	O
P1	struct
.	O
x	int
)	O
/	O
Q	struct
.	O
x	int
+	O
S1	struct
.	O
x	int
;	O
p_last	struct
.	O
y	int
=	O
(	O
y2	pointer
-	O
P1	struct
.	O
y	int
)	O
/	O
Q	struct
.	O
y	int
+	O
S1	struct
.	O
y	int
;	O
polystart	struct
.	O
x	int
=	O
(	O
x1	double
-	O
P1	struct
.	O
x	int
)	O
/	O
Q	struct
.	O
x	int
+	O
S1	struct
.	O
x	int
;	O
polystart	struct
.	O
y	int
=	O
(	O
y1	function
-	O
P1	struct
.	O
y	int
)	O
/	O
Q	struct
.	O
y	int
+	O
S1	struct
.	O
y	int
;	O
}	O
}	O
if	O
(	O
!	O
outside	int
)	O
{	O
HPGL_Pt_to_polygon	function
(	O
p_last	struct
)	O
;	O
HPGL_Pt_to_polygon	function
(	O
polystart	struct
)	O
;	O
}	O
}	O
}	O
break	O
;	O
case	O
PR	int
:	O
lines	function
(	O
plot_rel	short
=	O
TRUE	int
,	O
hd	pointer
)	O
;	O
tp	pointer
->	O
CR_point	struct
=	O
HP_pos	struct
;	O
break	O
;	O
case	O
PS	int
:	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
||	O
ftmp	float
==	O
0.	int
)	O
{	O
break	O
;	O
}	O
else	O
{	O
myheight	float
=	O
ftmp	float
;	O
}	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
)	O
{	O
mywidth	float
=	O
P2	struct
.	O
y	int
;	O
}	O
else	O
{	O
mywidth	float
=	O
ftmp	float
;	O
if	O
(	O
mywidth	float
>	O
myheight	float
)	O
{	O
mywidth	float
=	O
myheight	float
;	O
myheight	float
=	O
ftmp	float
;	O
}	O
}	O
if	O
(	O
pg	pointer
->	O
no_ps	int
==	O
TRUE	int
)	O
{	O
if	O
(	O
!	O
silent_mode	short
)	O
Eprintf	function
(	O
"PS: suppressed\n"	pointer
)	O
;	O
break	O
;	O
}	O
ps_flag	short
=	O
1	int
;	O
M	struct
.	O
x	int
=	O
myheight	float
;	O
M	struct
.	O
y	int
=	O
mywidth	float
;	O
p1	struct
.	O
x	int
=	O
0	int
;	O
p1	struct
.	O
y	int
=	O
0	int
;	O
if	O
(	O
scale_flag	int
)	O
User_to_Plotter_coord	function
(	O
&	O
p1	struct
,	O
&	O
p2	struct
)	O
;	O
else	O
p2	struct
=	O
p1	struct
;	O
if	O
(	O
rotate_flag	short
)	O
{	O
ftmp	float
=	O
rot_cos	float
*	O
p2	struct
.	O
x	int
-	O
rot_sin	float
*	O
p2	struct
.	O
y	int
;	O
p2	struct
.	O
y	int
=	O
rot_sin	float
*	O
p2	struct
.	O
x	int
+	O
rot_cos	float
*	O
p2	struct
.	O
y	int
;	O
p2	struct
.	O
x	int
=	O
ftmp	float
;	O
}	O
xmin	double
=	O
MIN	O
(	O
p2	struct
.	O
x	int
,	O
xmin	double
)	O
;	O
ymin	double
=	O
MIN	O
(	O
p2	struct
.	O
y	int
,	O
ymin	double
)	O
;	O
xmax	double
=	O
MAX	O
(	O
p2	struct
.	O
x	int
,	O
xmax	double
)	O
;	O
ymax	double
=	O
MAX	O
(	O
p2	struct
.	O
y	int
,	O
ymax	double
)	O
;	O
p1	struct
.	O
x	int
=	O
myheight	float
;	O
p1	struct
.	O
y	int
=	O
mywidth	float
;	O
if	O
(	O
scale_flag	int
)	O
User_to_Plotter_coord	function
(	O
&	O
p1	struct
,	O
&	O
p2	struct
)	O
;	O
else	O
p2	struct
=	O
p1	struct
;	O
if	O
(	O
rotate_flag	short
)	O
{	O
ftmp	float
=	O
rot_cos	float
*	O
p2	struct
.	O
x	int
-	O
rot_sin	float
*	O
p2	struct
.	O
y	int
;	O
p2	struct
.	O
y	int
=	O
rot_sin	float
*	O
p2	struct
.	O
x	int
+	O
rot_cos	float
*	O
p2	struct
.	O
y	int
;	O
p2	struct
.	O
x	int
=	O
ftmp	float
;	O
}	O
xmin	double
=	O
MIN	O
(	O
p2	struct
.	O
x	int
,	O
xmin	double
)	O
;	O
ymin	double
=	O
MIN	O
(	O
p2	struct
.	O
y	int
,	O
ymin	double
)	O
;	O
xmax	double
=	O
MAX	O
(	O
p2	struct
.	O
x	int
,	O
xmax	double
)	O
;	O
ymax	double
=	O
MAX	O
(	O
p2	struct
.	O
y	int
,	O
ymax	double
)	O
;	O
P1	struct
.	O
x	int
=	O
0.	int
;	O
P1	struct
.	O
y	int
=	O
0.	int
;	O
P2	struct
.	O
x	int
=	O
myheight	float
;	O
P2	struct
.	O
y	int
=	O
mywidth	float
;	O
if	O
(	O
rotate_flag	short
)	O
{	O
P2	struct
.	O
x	int
=	O
mywidth	float
;	O
P2	struct
.	O
y	int
=	O
myheight	float
;	O
}	O
Diag_P1_P2	double
=	O
HYPOT	O
(	O
P2	struct
.	O
x	int
-	O
P1	struct
.	O
x	int
,	O
P2	struct
.	O
y	int
-	O
P1	struct
.	O
y	int
)	O
;	O
CurrentLinePatLen	double
=	O
0.04	int
*	O
Diag_P1_P2	double
;	O
S1	struct
=	O
P1	struct
;	O
S2	struct
=	O
P2	struct
;	O
break	O
;	O
case	O
PT	int
:	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
)	O
{	O
thickness	float
=	O
0.3	int
;	O
break	O
;	O
}	O
else	O
{	O
if	O
(	O
ftmp	float
>=	O
0.1	int
&&	O
ftmp	float
<=	O
5.	int
)	O
thickness	float
=	O
ftmp	float
;	O
}	O
case	O
PU	int
:	O
pen_down	short
=	O
FALSE	int
;	O
if	O
(	O
polygon_mode	short
)	O
polygon_penup	short
=	O
TRUE	int
;	O
lines	function
(	O
plot_rel	short
,	O
hd	pointer
)	O
;	O
tp	pointer
->	O
CR_point	struct
=	O
HP_pos	struct
;	O
break	O
;	O
case	O
PW	int
:	O
if	O
(	O
fixedwidth	short
)	O
{	O
if	O
(	O
!	O
silent_mode	short
)	O
fprintf	function
(	O
stderr	pointer
,	O
"PW: ignored (hardware mode)\n"	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
)	O
{	O
mywidth	float
=	O
0.35	int
;	O
if	O
(	O
wu_relative	short
)	O
mywidth	float
=	O
Diag_P1_P2	double
/	O
1000.	int
;	O
if	O
(	O
mywidth	float
<	O
0.1	int
)	O
mywidth	float
=	O
0.1	int
;	O
PlotCmd_to_tmpfile	function
(	O
DEF_PW	int
)	O
;	O
Pen_Width_to_tmpfile	function
(	O
0	int
,	O
mywidth	float
)	O
;	O
break	O
;	O
}	O
else	O
{	O
mywidth	float
=	O
ftmp	float
;	O
if	O
(	O
wu_relative	short
)	O
mywidth	float
=	O
Diag_P1_P2	double
*	O
ftmp	float
/	O
1000.	int
;	O
if	O
(	O
mywidth	float
<	O
0.1	int
)	O
mywidth	float
=	O
0.1	int
;	O
}	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
)	O
{	O
PlotCmd_to_tmpfile	function
(	O
DEF_PW	int
)	O
;	O
Pen_Width_to_tmpfile	function
(	O
0	int
,	O
mywidth	float
)	O
;	O
if	O
(	O
pg	pointer
->	O
maxpensize	float
<	O
mywidth	float
)	O
pg	pointer
->	O
maxpensize	float
=	O
mywidth	float
;	O
}	O
else	O
{	O
PlotCmd_to_tmpfile	function
(	O
DEF_PW	int
)	O
;	O
Pen_Width_to_tmpfile	function
(	O
(	O
int	O
)	O
ftmp	float
,	O
mywidth	float
)	O
;	O
if	O
(	O
(	O
int	O
)	O
ftmp	float
<=	O
pg	pointer
->	O
maxpens	int
)	O
{	O
if	O
(	O
pg	pointer
->	O
maxpensize	float
<	O
mywidth	float
)	O
pg	pointer
->	O
maxpensize	float
=	O
mywidth	float
;	O
}	O
}	O
break	O
;	O
case	O
TL	int
:	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
)	O
{	O
neg_ticklen	float
=	O
pos_ticklen	float
=	O
0.005	int
;	O
return	O
;	O
}	O
else	O
pos_ticklen	float
=	O
ftmp	float
/	O
100.0	int
;	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
)	O
{	O
neg_ticklen	float
=	O
0.0	int
;	O
return	O
;	O
}	O
else	O
neg_ticklen	float
=	O
ftmp	float
/	O
100.0	int
;	O
break	O
;	O
case	O
WG	int
:	O
fwedges	function
(	O
hd	pointer
,	O
pt	struct
.	O
width	array
[	O
pen	int
]	O
)	O
;	O
break	O
;	O
case	O
WU	int
:	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
||	O
ftmp	float
==	O
0.	int
)	O
wu_relative	short
=	O
FALSE	int
;	O
else	O
wu_relative	short
=	O
TRUE	int
;	O
break	O
;	O
case	O
XT	int
:	O
ax_ticks	function
(	O
0	int
)	O
;	O
break	O
;	O
case	O
YT	int
:	O
ax_ticks	function
(	O
1	int
)	O
;	O
break	O
;	O
case	O
IP	int
:	O
tp	pointer
->	O
width	array
/=	O
(	O
P2	struct
.	O
x	int
-	O
P1	struct
.	O
x	int
)	O
;	O
tp	pointer
->	O
height	double
/=	O
(	O
P2	struct
.	O
y	int
-	O
P1	struct
.	O
y	int
)	O
;	O
if	O
(	O
read_float	function
(	O
&	O
p1	struct
.	O
x	int
,	O
hd	pointer
)	O
)	O
{	O
P1	struct
.	O
x	int
=	O
P1X_default	int
;	O
P1	struct
.	O
y	int
=	O
P1Y_default	int
;	O
P2	struct
.	O
x	int
=	O
P2X_default	int
;	O
P2	struct
.	O
y	int
=	O
P2Y_default	int
;	O
goto	O
IP_Exit	O
;	O
}	O
if	O
(	O
read_float	function
(	O
&	O
p1	struct
.	O
y	int
,	O
hd	pointer
)	O
)	O
par_err_exit	function
(	O
2	int
,	O
cmd	enum
,	O
hd	pointer
)	O
;	O
if	O
(	O
read_float	function
(	O
&	O
p2	struct
.	O
x	int
,	O
hd	pointer
)	O
)	O
{	O
P2	struct
.	O
x	int
+=	O
p1	struct
.	O
x	int
-	O
P1	struct
.	O
x	int
;	O
P2	struct
.	O
y	int
+=	O
p1	struct
.	O
y	int
-	O
P1	struct
.	O
y	int
;	O
P1	struct
=	O
p1	struct
;	O
goto	O
IP_Exit	O
;	O
}	O
if	O
(	O
read_float	function
(	O
&	O
p2	struct
.	O
y	int
,	O
hd	pointer
)	O
)	O
par_err_exit	function
(	O
4	int
,	O
cmd	enum
,	O
hd	pointer
)	O
;	O
P1	struct
=	O
p1	struct
;	O
P2	struct
=	O
p2	struct
;	O
IP_Exit	O
:	O
S1	struct
=	O
P1	struct
;	O
S2	struct
=	O
P2	struct
;	O
Q	struct
.	O
x	int
=	O
(	O
P2	struct
.	O
x	int
-	O
P1	struct
.	O
x	int
)	O
/	O
(	O
S2	struct
.	O
x	int
-	O
S1	struct
.	O
x	int
)	O
;	O
Q	struct
.	O
y	int
=	O
(	O
P2	struct
.	O
y	int
-	O
P1	struct
.	O
y	int
)	O
/	O
(	O
S2	struct
.	O
y	int
-	O
S1	struct
.	O
y	int
)	O
;	O
Diag_P1_P2	double
=	O
HYPOT	O
(	O
P2	struct
.	O
x	int
-	O
P1	struct
.	O
x	int
,	O
P2	struct
.	O
y	int
-	O
P1	struct
.	O
y	int
)	O
;	O
CurrentLinePatLen	double
=	O
0.04	int
*	O
Diag_P1_P2	double
;	O
tp	pointer
->	O
width	array
*=	O
(	O
P2	struct
.	O
x	int
-	O
P1	struct
.	O
x	int
)	O
;	O
tp	pointer
->	O
height	double
*=	O
(	O
P2	struct
.	O
y	int
-	O
P1	struct
.	O
y	int
)	O
;	O
adjust_text_par	function
(	O
)	O
;	O
return	O
;	O
case	O
IR	int
:	O
if	O
(	O
read_float	function
(	O
&	O
p1	struct
.	O
x	int
,	O
hd	pointer
)	O
)	O
return	O
;	O
if	O
(	O
read_float	function
(	O
&	O
p1	struct
.	O
y	int
,	O
hd	pointer
)	O
)	O
par_err_exit	function
(	O
2	int
,	O
cmd	enum
,	O
hd	pointer
)	O
;	O
mywidth	float
=	O
P2	struct
.	O
x	int
-	O
P1	struct
.	O
x	int
;	O
myheight	float
=	O
P2	struct
.	O
y	int
-	O
P1	struct
.	O
y	int
;	O
ftmp	float
=	O
p1	struct
.	O
x	int
;	O
p1	struct
.	O
x	int
=	O
P1	struct
.	O
x	int
;	O
P1	struct
.	O
x	int
=	O
p1	struct
.	O
x	int
+	O
ftmp	float
/	O
100.	int
*	O
mywidth	float
;	O
ftmp	float
=	O
p1	struct
.	O
y	int
;	O
p1	struct
.	O
y	int
=	O
P1	struct
.	O
y	int
;	O
P1	struct
.	O
y	int
=	O
p1	struct
.	O
y	int
+	O
ftmp	float
/	O
100.	int
*	O
myheight	float
;	O
if	O
(	O
read_float	function
(	O
&	O
p2	struct
.	O
x	int
,	O
hd	pointer
)	O
)	O
{	O
P2	struct
.	O
x	int
=	O
P1	struct
.	O
x	int
+	O
mywidth	float
;	O
P2	struct
.	O
y	int
=	O
P1	struct
.	O
y	int
+	O
myheight	float
;	O
return	O
;	O
}	O
if	O
(	O
read_float	function
(	O
&	O
p2	struct
.	O
y	int
,	O
hd	pointer
)	O
)	O
par_err_exit	function
(	O
4	int
,	O
cmd	enum
,	O
hd	pointer
)	O
;	O
P2	struct
.	O
x	int
=	O
p1	struct
.	O
x	int
+	O
p2	struct
.	O
x	int
/	O
100.	int
*	O
mywidth	float
;	O
P2	struct
.	O
y	int
=	O
p1	struct
.	O
y	int
+	O
p2	struct
.	O
y	int
/	O
100.	int
*	O
myheight	float
;	O
if	O
(	O
P1	struct
.	O
x	int
==	O
P2	struct
.	O
x	int
)	O
P2	struct
.	O
x	int
=	O
P2	struct
.	O
x	int
+	O
1.	int
;	O
if	O
(	O
P1	struct
.	O
y	int
==	O
P2	struct
.	O
y	int
)	O
P2	struct
.	O
y	int
=	O
P2	struct
.	O
y	int
+	O
1.	int
;	O
fprintf	function
(	O
stderr	pointer
,	O
"P1,P2 nach IR: %f %f, %f %f\n"	pointer
,	O
P1	struct
.	O
x	int
,	O
P1	struct
.	O
y	int
,	O
P2	struct
.	O
x	int
,	O
P2	struct
.	O
y	int
)	O
;	O
Q	struct
.	O
x	int
=	O
(	O
P2	struct
.	O
x	int
-	O
P1	struct
.	O
x	int
)	O
/	O
(	O
S2	struct
.	O
x	int
-	O
S1	struct
.	O
x	int
)	O
;	O
Q	struct
.	O
y	int
=	O
(	O
P2	struct
.	O
y	int
-	O
P1	struct
.	O
y	int
)	O
/	O
(	O
S2	struct
.	O
y	int
-	O
S1	struct
.	O
y	int
)	O
;	O
Diag_P1_P2	double
=	O
HYPOT	O
(	O
P2	struct
.	O
x	int
-	O
P1	struct
.	O
x	int
,	O
P2	struct
.	O
y	int
-	O
P1	struct
.	O
y	int
)	O
;	O
CurrentLinePatLen	double
=	O
0.04	int
*	O
Diag_P1_P2	double
;	O
tp	pointer
->	O
width	array
*=	O
(	O
P2	struct
.	O
x	int
-	O
P1	struct
.	O
x	int
)	O
;	O
tp	pointer
->	O
height	double
*=	O
(	O
P2	struct
.	O
y	int
-	O
P1	struct
.	O
y	int
)	O
;	O
adjust_text_par	function
(	O
)	O
;	O
return	O
;	O
case	O
IW	int
:	O
iwflag	int
=	O
1	int
;	O
if	O
(	O
read_float	function
(	O
&	O
C1	struct
.	O
x	int
,	O
hd	pointer
)	O
)	O
{	O
if	O
(	O
P1	struct
.	O
x	int
==	O
P1X_default	int
&&	O
P1	struct
.	O
y	int
==	O
P1Y_default	int
&&	O
P2	struct
.	O
x	int
==	O
P2X_default	int
&&	O
P2	struct
.	O
y	int
==	O
P2Y_default	int
)	O
{	O
iwflag	int
=	O
0	int
;	O
break	O
;	O
}	O
C1	struct
=	O
P1	struct
;	O
C2	struct
=	O
P2	struct
;	O
if	O
(	O
scale_flag	int
)	O
{	O
C1	struct
=	O
S1	struct
;	O
C2	struct
=	O
S2	struct
;	O
}	O
if	O
(	O
rotate_flag	short
&&	O
!	O
ps_flag	short
)	O
{	O
switch	O
(	O
(	O
int	O
)	O
fabs	function
(	O
rot_tmp	double
)	O
)	O
{	O
case	O
90	int
:	O
case	O
270	int
:	O
ftmp	float
=	O
C1	struct
.	O
x	int
;	O
C1	struct
.	O
x	int
=	O
C1	struct
.	O
y	int
;	O
C1	struct
.	O
y	int
=	O
ftmp	float
;	O
ftmp	float
=	O
C2	struct
.	O
x	int
;	O
C2	struct
.	O
x	int
=	O
C2	struct
.	O
y	int
;	O
C2	struct
.	O
y	int
=	O
ftmp	float
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
read_float	function
(	O
&	O
C1	struct
.	O
y	int
,	O
hd	pointer
)	O
)	O
par_err_exit	function
(	O
2	int
,	O
cmd	enum
,	O
hd	pointer
)	O
;	O
if	O
(	O
read_float	function
(	O
&	O
C2	struct
.	O
x	int
,	O
hd	pointer
)	O
)	O
par_err_exit	function
(	O
3	int
,	O
cmd	enum
,	O
hd	pointer
)	O
;	O
if	O
(	O
read_float	function
(	O
&	O
C2	struct
.	O
y	int
,	O
hd	pointer
)	O
)	O
par_err_exit	function
(	O
4	int
,	O
cmd	enum
,	O
hd	pointer
)	O
;	O
}	O
if	O
(	O
scale_flag	int
)	O
{	O
User_to_Plotter_coord	function
(	O
&	O
C1	struct
,	O
&	O
C1	struct
)	O
;	O
User_to_Plotter_coord	function
(	O
&	O
C2	struct
,	O
&	O
C2	struct
)	O
;	O
}	O
if	O
(	O
C2	struct
.	O
x	int
<	O
C1	struct
.	O
x	int
)	O
{	O
ftmp	float
=	O
C2	struct
.	O
x	int
;	O
C2	struct
.	O
x	int
=	O
C1	struct
.	O
x	int
;	O
C1	struct
.	O
x	int
=	O
ftmp	float
;	O
}	O
if	O
(	O
C2	struct
.	O
y	int
<	O
C1	struct
.	O
y	int
)	O
{	O
ftmp	float
=	O
C2	struct
.	O
y	int
;	O
C2	struct
.	O
y	int
=	O
C1	struct
.	O
y	int
;	O
C1	struct
.	O
y	int
=	O
ftmp	float
;	O
}	O
C1	struct
.	O
x	int
-=	O
pg	pointer
->	O
extraclip	int
;	O
C1	struct
.	O
y	int
-=	O
pg	pointer
->	O
extraclip	int
;	O
C2	struct
.	O
x	int
+=	O
pg	pointer
->	O
extraclip	int
;	O
C2	struct
.	O
y	int
+=	O
pg	pointer
->	O
extraclip	int
;	O
break	O
;	O
case	O
OP	int
:	O
if	O
(	O
!	O
silent_mode	short
)	O
{	O
Eprintf	function
(	O
"\nP1 = (%g, %g)\n"	pointer
,	O
P1	struct
.	O
x	int
,	O
P1	struct
.	O
y	int
)	O
;	O
Eprintf	function
(	O
"P2 = (%g, %g)\n"	pointer
,	O
P2	struct
.	O
x	int
,	O
P2	struct
.	O
y	int
)	O
;	O
}	O
break	O
;	O
case	O
OW	int
:	O
if	O
(	O
!	O
silent_mode	short
)	O
{	O
Eprintf	function
(	O
"\nC1 = (%g, %g)\n"	pointer
,	O
C1	struct
.	O
x	int
,	O
C1	struct
.	O
y	int
)	O
;	O
Eprintf	function
(	O
"C2 = (%g, %g)\n"	pointer
,	O
C2	struct
.	O
x	int
,	O
C2	struct
.	O
y	int
)	O
;	O
}	O
break	O
;	O
case	O
AF	int
:	O
case	O
AH	int
:	O
case	O
PG	int
:	O
page_number	int
++	O
;	O
record_off	short
=	O
(	O
first_page	int
>	O
page_number	int
)	O
||	O
(	O
(	O
last_page	int
<	O
page_number	int
)	O
&&	O
(	O
last_page	int
>	O
0	int
)	O
)	O
;	O
pg_flag	short
=	O
TRUE	int
;	O
return	O
;	O
break	O
;	O
case	O
EA	int
:	O
rects	function
(	O
plot_rel	short
=	O
FALSE	int
,	O
0	int
,	O
pt	struct
.	O
width	array
[	O
pen	int
]	O
,	O
hd	pointer
)	O
;	O
tp	pointer
->	O
CR_point	struct
=	O
HP_pos	struct
;	O
break	O
;	O
case	O
ER	int
:	O
rects	function
(	O
TRUE	int
,	O
0	int
,	O
0.	int
,	O
hd	pointer
)	O
;	O
tp	pointer
->	O
CR_point	struct
=	O
HP_pos	struct
;	O
break	O
;	O
case	O
RA	int
:	O
rects	function
(	O
plot_rel	short
=	O
FALSE	int
,	O
1	int
,	O
pt	struct
.	O
width	array
[	O
pen	int
]	O
,	O
hd	pointer
)	O
;	O
tp	pointer
->	O
CR_point	struct
=	O
HP_pos	struct
;	O
break	O
;	O
case	O
RR	int
:	O
rects	function
(	O
plot_rel	short
=	O
TRUE	int
,	O
1	int
,	O
pt	struct
.	O
width	array
[	O
pen	int
]	O
,	O
hd	pointer
)	O
;	O
tp	pointer
->	O
CR_point	struct
=	O
HP_pos	struct
;	O
break	O
;	O
case	O
RT	int
:	O
tarcs	function
(	O
TRUE	int
,	O
hd	pointer
)	O
;	O
break	O
;	O
case	O
LT	int
:	O
if	O
(	O
read_float	function
(	O
&	O
p1	struct
.	O
x	int
,	O
hd	pointer
)	O
)	O
CurrentLineType	enum
=	O
LT_solid	int
;	O
else	O
{	O
if	O
(	O
(	O
(	O
(	O
int	O
)	O
p1	struct
.	O
x	int
)	O
>=	O
LT_MIN	O
)	O
&&	O
(	O
(	O
(	O
int	O
)	O
p1	struct
.	O
x	int
)	O
<	O
LT_ZERO	int
)	O
)	O
CurrentLineType	enum
=	O
LT_adaptive	int
;	O
else	O
if	O
(	O
(	O
(	O
int	O
)	O
p1	struct
.	O
x	int
)	O
==	O
LT_ZERO	int
)	O
CurrentLineType	enum
=	O
LT_plot_at	int
;	O
else	O
if	O
(	O
(	O
(	O
(	O
int	O
)	O
p1	struct
.	O
x	int
)	O
>	O
LT_ZERO	int
)	O
&&	O
(	O
(	O
(	O
int	O
)	O
p1	struct
.	O
x	int
)	O
<=	O
LT_MAX	int
)	O
)	O
CurrentLineType	enum
=	O
LT_fixed	int
;	O
else	O
{	O
Eprintf	function
(	O
"Illegal line type:\t%d\n"	pointer
,	O
(	O
int	O
)	O
p1	struct
.	O
x	int
)	O
;	O
CurrentLineType	enum
=	O
LT_solid	int
;	O
}	O
CurrentLinePattern	int
=	O
(	O
int	O
)	O
p1	struct
.	O
x	int
;	O
if	O
(	O
!	O
read_float	function
(	O
&	O
p1	struct
.	O
y	int
,	O
hd	pointer
)	O
)	O
{	O
if	O
(	O
p1	struct
.	O
y	int
<=	O
0.0	int
)	O
Eprintf	function
(	O
"Illegal pattern length:\t%g\n"	pointer
,	O
p1	struct
.	O
y	int
)	O
;	O
else	O
{	O
Diag_P1_P2	double
=	O
HYPOT	O
(	O
P2	struct
.	O
x	int
-	O
P1	struct
.	O
x	int
,	O
P2	struct
.	O
y	int
-	O
P1	struct
.	O
y	int
)	O
;	O
if	O
(	O
!	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
)	O
{	O
if	O
(	O
ftmp	float
==	O
1.0	int
)	O
{	O
CurrentLinePatLen	double
=	O
p1	struct
.	O
y	int
*	O
40	int
;	O
}	O
else	O
{	O
CurrentLinePatLen	double
=	O
Diag_P1_P2	double
*	O
p1	struct
.	O
y	int
/	O
100.0	int
;	O
}	O
}	O
else	O
{	O
CurrentLinePatLen	double
=	O
Diag_P1_P2	double
*	O
p1	struct
.	O
y	int
/	O
100.0	int
;	O
}	O
}	O
}	O
}	O
break	O
;	O
case	O
SC	int
:	O
User_to_Plotter_coord	function
(	O
&	O
p_last	struct
,	O
&	O
p_last	struct
)	O
;	O
if	O
(	O
read_float	function
(	O
&	O
p1	struct
.	O
x	int
,	O
hd	pointer
)	O
)	O
{	O
S1	struct
.	O
x	int
=	O
P1X_default	int
;	O
S1	struct
.	O
y	int
=	O
P1Y_default	int
;	O
S2	struct
.	O
x	int
=	O
P2X_default	int
;	O
S2	struct
.	O
y	int
=	O
P2Y_default	int
;	O
scale_flag	int
=	O
FALSE	int
;	O
Q	struct
.	O
x	int
=	O
Q	struct
.	O
y	int
=	O
1.0	int
;	O
break	O
;	O
}	O
if	O
(	O
read_float	function
(	O
&	O
p2	struct
.	O
x	int
,	O
hd	pointer
)	O
)	O
par_err_exit	function
(	O
2	int
,	O
cmd	enum
,	O
hd	pointer
)	O
;	O
if	O
(	O
read_float	function
(	O
&	O
p1	struct
.	O
y	int
,	O
hd	pointer
)	O
)	O
par_err_exit	function
(	O
3	int
,	O
cmd	enum
,	O
hd	pointer
)	O
;	O
if	O
(	O
read_float	function
(	O
&	O
p2	struct
.	O
y	int
,	O
hd	pointer
)	O
)	O
par_err_exit	function
(	O
4	int
,	O
cmd	enum
,	O
hd	pointer
)	O
;	O
if	O
(	O
p1	struct
.	O
x	int
==	O
p2	struct
.	O
x	int
||	O
p1	struct
.	O
y	int
==	O
p2	struct
.	O
y	int
)	O
{	O
if	O
(	O
!	O
silent_mode	short
)	O
Eprintf	function
(	O
"Warning: Invalid SC command parameters -- ignored\n"	pointer
)	O
;	O
Q	struct
.	O
x	int
=	O
Q	struct
.	O
y	int
=	O
1.0	int
;	O
break	O
;	O
}	O
S1	struct
.	O
x	int
=	O
p1	struct
.	O
x	int
;	O
S1	struct
.	O
y	int
=	O
p1	struct
.	O
y	int
;	O
S2	struct
.	O
x	int
=	O
p2	struct
.	O
x	int
;	O
S2	struct
.	O
y	int
=	O
p2	struct
.	O
y	int
;	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
)	O
ftmp	float
=	O
0	int
;	O
switch	O
(	O
(	O
int	O
)	O
ftmp	float
)	O
{	O
case	O
0	int
:	O
Q	struct
.	O
x	int
=	O
(	O
P2	struct
.	O
x	int
-	O
P1	struct
.	O
x	int
)	O
/	O
(	O
S2	struct
.	O
x	int
-	O
S1	struct
.	O
x	int
)	O
;	O
Q	struct
.	O
y	int
=	O
(	O
P2	struct
.	O
y	int
-	O
P1	struct
.	O
y	int
)	O
/	O
(	O
S2	struct
.	O
y	int
-	O
S1	struct
.	O
y	int
)	O
;	O
break	O
;	O
case	O
1	int
:	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
)	O
ftmp	float
=	O
50.0	int
;	O
Q	struct
.	O
x	int
=	O
(	O
P2	struct
.	O
x	int
-	O
P1	struct
.	O
x	int
)	O
/	O
(	O
S2	struct
.	O
x	int
-	O
S1	struct
.	O
x	int
)	O
;	O
Q	struct
.	O
y	int
=	O
(	O
P2	struct
.	O
y	int
-	O
P1	struct
.	O
y	int
)	O
/	O
(	O
S2	struct
.	O
y	int
-	O
S1	struct
.	O
y	int
)	O
;	O
if	O
(	O
Q	struct
.	O
x	int
<	O
Q	struct
.	O
y	int
)	O
{	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
)	O
ftmp	float
=	O
50.0	int
;	O
S1	struct
.	O
y	int
+=	O
ftmp	float
*	O
(	O
(	O
P2	struct
.	O
y	int
-	O
P1	struct
.	O
y	int
)	O
/	O
Q	struct
.	O
y	int
-	O
(	O
P2	struct
.	O
y	int
-	O
P1	struct
.	O
y	int
)	O
/	O
Q	struct
.	O
x	int
)	O
/	O
100.0	int
;	O
Q	struct
.	O
y	int
=	O
Q	struct
.	O
x	int
;	O
S2	struct
.	O
y	int
=	O
S1	struct
.	O
y	int
+	O
(	O
P2	struct
.	O
y	int
-	O
P1	struct
.	O
y	int
)	O
/	O
Q	struct
.	O
y	int
;	O
}	O
else	O
{	O
S1	struct
.	O
x	int
+=	O
ftmp	float
*	O
(	O
(	O
P2	struct
.	O
x	int
-	O
P1	struct
.	O
x	int
)	O
/	O
Q	struct
.	O
x	int
-	O
(	O
P2	struct
.	O
x	int
-	O
P1	struct
.	O
x	int
)	O
/	O
Q	struct
.	O
y	int
)	O
/	O
100.0	int
;	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
;	O
Q	struct
.	O
x	int
=	O
Q	struct
.	O
y	int
;	O
S2	struct
.	O
x	int
=	O
S1	struct
.	O
x	int
+	O
(	O
P2	struct
.	O
x	int
-	O
P1	struct
.	O
x	int
)	O
/	O
Q	struct
.	O
x	int
;	O
}	O
break	O
;	O
case	O
2	int
:	O
Q	struct
.	O
x	int
=	O
S2	struct
.	O
x	int
;	O
Q	struct
.	O
y	int
=	O
S2	struct
.	O
y	int
;	O
S2	struct
.	O
x	int
=	O
S1	struct
.	O
x	int
+	O
(	O
P2	struct
.	O
x	int
-	O
P1	struct
.	O
x	int
)	O
/	O
Q	struct
.	O
x	int
;	O
S2	struct
.	O
y	int
=	O
S1	struct
.	O
y	int
+	O
(	O
P2	struct
.	O
y	int
-	O
P1	struct
.	O
y	int
)	O
/	O
Q	struct
.	O
y	int
;	O
break	O
;	O
default	O
:	O
par_err_exit	function
(	O
0	int
,	O
cmd	enum
,	O
hd	pointer
)	O
;	O
}	O
scale_flag	int
=	O
TRUE	int
;	O
Plotter_to_User_coord	function
(	O
&	O
p_last	struct
,	O
&	O
p_last	struct
)	O
;	O
break	O
;	O
case	O
SP	int
:	O
old_pen	short
=	O
pen	int
;	O
thickness	float
=	O
0.	int
;	O
if	O
(	O
read_float	function
(	O
&	O
p1	struct
.	O
x	int
,	O
hd	pointer
)	O
)	O
pen	int
=	O
0	int
;	O
else	O
{	O
pen	int
=	O
(	O
short	O
)	O
p1	struct
.	O
x	int
;	O
if	O
(	O
pen	int
==	O
0	int
&&	O
pg	pointer
->	O
mapzero	int
>	O
-	O
1	int
)	O
pen	int
=	O
pg	pointer
->	O
mapzero	int
;	O
}	O
if	O
(	O
pen	int
<	O
0	int
||	O
(	O
int	O
)	O
pen	int
>	O
pg	pointer
->	O
maxpens	int
)	O
{	O
Eprintf	function
(	O
"\nIllegal pen number %d: replaced by %d\n"	pointer
,	O
pen	int
,	O
pen	int
%	O
pg	pointer
->	O
maxpens	int
)	O
;	O
n_unexpected	int
++	O
;	O
pen	int
=	O
pen	int
%	O
pg	pointer
->	O
maxpens	int
;	O
}	O
if	O
(	O
old_pen	short
!=	O
pen	int
)	O
{	O
if	O
(	O
(	O
fputc	function
(	O
SET_PEN	int
,	O
td	pointer
)	O
==	O
EOF	O
)	O
||	O
(	O
fputc	function
(	O
pen	int
,	O
td	pointer
)	O
==	O
EOF	O
)	O
)	O
{	O
PError	function
(	O
"Writing to temporary file:"	pointer
)	O
;	O
Eprintf	function
(	O
"Error @ Cmd %ld\n"	pointer
,	O
vec_cntr_w	long
)	O
;	O
exit	function
(	O
ERROR	O
)	O
;	O
}	O
}	O
if	O
(	O
pen	int
)	O
pens_in_use	array
[	O
pen	int
]	O
=	O
1	int
;	O
pg	pointer
->	O
maxcolor	int
=	O
MAX	O
(	O
pg	pointer
->	O
maxcolor	int
,	O
(	O
int	O
)	O
pen	int
)	O
;	O
break	O
;	O
case	O
BP	int
:	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
)	O
{	O
break	O
;	O
}	O
else	O
{	O
switch	O
(	O
(	O
int	O
)	O
ftmp	float
)	O
{	O
case	O
1	int
:	O
tmpstr	array
[	O
0	int
]	O
=	O
fgetc	function
(	O
hd	pointer
)	O
;	O
tmpstr	array
[	O
0	int
]	O
=	O
fgetc	function
(	O
hd	pointer
)	O
;	O
if	O
(	O
!	O
silent_mode	short
)	O
fprintf	function
(	O
stderr	pointer
,	O
"HPGL picture name: %c"	pointer
,	O
tmpstr	array
[	O
0	int
]	O
)	O
;	O
if	O
(	O
tmpstr	array
[	O
0	int
]	O
==	O
'"'	O
)	O
{	O
tmpstr	array
[	O
0	int
]	O
=	O
' '	O
;	O
do	O
{	O
tmpstr	array
[	O
0	int
]	O
=	O
fgetc	function
(	O
hd	pointer
)	O
;	O
if	O
(	O
!	O
silent_mode	short
)	O
fputc	function
(	O
tmpstr	array
[	O
0	int
]	O
,	O
stderr	pointer
)	O
;	O
}	O
while	O
(	O
tmpstr	array
[	O
0	int
]	O
!=	O
'"'	O
)	O
;	O
}	O
if	O
(	O
!	O
silent_mode	short
)	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
break	O
;	O
case	O
2	int
:	O
case	O
3	int
:	O
case	O
4	int
:	O
case	O
5	int
:	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
)	O
break	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
}	O
case	O
DF	int
:	O
case	O
IN	int
:	O
reset_HPGL	function
(	O
)	O
;	O
tp	pointer
->	O
CR_point	struct
=	O
HP_pos	struct
;	O
break	O
;	O
case	O
RO	int
:	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
)	O
{	O
break	O
;	O
}	O
else	O
{	O
rotate_flag	short
=	O
1	int
;	O
rot_ang	double
+=	O
ftmp	float
;	O
rot_tmp	double
=	O
ftmp	float
;	O
switch	O
(	O
(	O
int	O
)	O
ftmp	float
)	O
{	O
case	O
90	int
:	O
case	O
270	int
:	O
ftmp	float
=	O
M	struct
.	O
x	int
;	O
M	struct
.	O
x	int
=	O
M	struct
.	O
y	int
;	O
M	struct
.	O
y	int
=	O
ftmp	float
;	O
break	O
;	O
case	O
0	int
:	O
case	O
180	int
:	O
break	O
;	O
default	O
:	O
rotate_flag	short
=	O
0	int
;	O
break	O
;	O
}	O
rot_cos	float
=	O
cos	function
(	O
M_PI	int
*	O
rot_ang	double
/	O
180.0	int
)	O
;	O
rot_sin	float
=	O
sin	function
(	O
M_PI	int
*	O
rot_ang	double
/	O
180.0	int
)	O
;	O
if	O
(	O
ps_flag	short
)	O
{	O
xmin	double
=	O
1e10	int
;	O
ymin	double
=	O
1e10	int
;	O
xmax	double
=	O
1e-10	int
;	O
ymax	double
=	O
1e-10	int
;	O
p1	struct
.	O
x	int
=	O
0	int
;	O
p1	struct
.	O
y	int
=	O
0	int
;	O
if	O
(	O
scale_flag	int
)	O
User_to_Plotter_coord	function
(	O
&	O
p1	struct
,	O
&	O
p2	struct
)	O
;	O
else	O
p2	struct
=	O
p1	struct
;	O
HP_pos	struct
=	O
p2	struct
;	O
ftmp	float
=	O
rot_cos	float
*	O
p2	struct
.	O
x	int
-	O
rot_sin	float
*	O
p2	struct
.	O
y	int
;	O
p2	struct
.	O
y	int
=	O
rot_sin	float
*	O
p2	struct
.	O
x	int
+	O
rot_cos	float
*	O
p2	struct
.	O
y	int
;	O
p2	struct
.	O
x	int
=	O
ftmp	float
;	O
xmin	double
=	O
MIN	O
(	O
p2	struct
.	O
x	int
,	O
xmin	double
)	O
;	O
ymin	double
=	O
MIN	O
(	O
p2	struct
.	O
y	int
,	O
ymin	double
)	O
;	O
xmax	double
=	O
MAX	O
(	O
p2	struct
.	O
x	int
,	O
xmax	double
)	O
;	O
ymax	double
=	O
MAX	O
(	O
p2	struct
.	O
y	int
,	O
ymax	double
)	O
;	O
p1	struct
.	O
x	int
=	O
M	struct
.	O
x	int
;	O
p1	struct
.	O
y	int
=	O
M	struct
.	O
y	int
;	O
if	O
(	O
scale_flag	int
)	O
User_to_Plotter_coord	function
(	O
&	O
p1	struct
,	O
&	O
p2	struct
)	O
;	O
else	O
p2	struct
=	O
p1	struct
;	O
HP_pos	struct
=	O
p2	struct
;	O
ftmp	float
=	O
rot_cos	float
*	O
p2	struct
.	O
x	int
-	O
rot_sin	float
*	O
p2	struct
.	O
y	int
;	O
p2	struct
.	O
y	int
=	O
rot_sin	float
*	O
p2	struct
.	O
x	int
+	O
rot_cos	float
*	O
p2	struct
.	O
y	int
;	O
p2	struct
.	O
x	int
=	O
ftmp	float
;	O
xmin	double
=	O
MIN	O
(	O
p2	struct
.	O
x	int
,	O
xmin	double
)	O
;	O
ymin	double
=	O
MIN	O
(	O
p2	struct
.	O
y	int
,	O
ymin	double
)	O
;	O
xmax	double
=	O
MAX	O
(	O
p2	struct
.	O
x	int
,	O
xmax	double
)	O
;	O
ymax	double
=	O
MAX	O
(	O
p2	struct
.	O
y	int
,	O
ymax	double
)	O
;	O
}	O
}	O
break	O
;	O
case	O
BL	int
:	O
read_string	function
(	O
strbuf	pointer
,	O
hd	pointer
)	O
;	O
break	O
;	O
case	O
CP	int
:	O
if	O
(	O
read_float	function
(	O
&	O
p1	struct
.	O
x	int
,	O
hd	pointer
)	O
)	O
{	O
plot_string	function
(	O
"\n\r"	pointer
,	O
LB_direct	int
,	O
pen	int
)	O
;	O
return	O
;	O
}	O
else	O
if	O
(	O
read_float	function
(	O
&	O
p1	struct
.	O
y	int
,	O
hd	pointer
)	O
)	O
par_err_exit	function
(	O
2	int
,	O
cmd	enum
,	O
hd	pointer
)	O
;	O
p2	struct
.	O
x	int
=	O
p1	struct
.	O
x	int
*	O
tp	pointer
->	O
chardiff	struct
.	O
x	int
-	O
p1	struct
.	O
y	int
*	O
tp	pointer
->	O
linediff	struct
.	O
x	int
+	O
HP_pos	struct
.	O
x	int
;	O
p2	struct
.	O
y	int
=	O
p1	struct
.	O
x	int
*	O
tp	pointer
->	O
chardiff	struct
.	O
y	int
-	O
p1	struct
.	O
y	int
*	O
tp	pointer
->	O
linediff	struct
.	O
y	int
+	O
HP_pos	struct
.	O
y	int
;	O
Pen_action_to_tmpfile	function
(	O
MOVE_TO	int
,	O
&	O
p2	struct
,	O
FALSE	int
)	O
;	O
break	O
;	O
case	O
DI	int
:	O
if	O
(	O
read_float	function
(	O
&	O
p1	struct
.	O
x	int
,	O
hd	pointer
)	O
)	O
{	O
tp	pointer
->	O
dir	float
=	O
0.0	int
;	O
tp	pointer
->	O
CR_point	struct
=	O
HP_pos	struct
;	O
adjust_text_par	function
(	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
read_float	function
(	O
&	O
p1	struct
.	O
y	int
,	O
hd	pointer
)	O
)	O
par_err_exit	function
(	O
2	int
,	O
cmd	enum
,	O
hd	pointer
)	O
;	O
if	O
(	O
(	O
p1	struct
.	O
x	int
==	O
0.0	int
)	O
&&	O
(	O
p1	struct
.	O
y	int
==	O
0.0	int
)	O
)	O
par_err_exit	function
(	O
0	int
,	O
cmd	enum
,	O
hd	pointer
)	O
;	O
tp	pointer
->	O
dir	float
=	O
atan2	function
(	O
p1	struct
.	O
y	int
,	O
p1	struct
.	O
x	int
)	O
;	O
tp	pointer
->	O
CR_point	struct
=	O
HP_pos	struct
;	O
adjust_text_par	function
(	O
)	O
;	O
break	O
;	O
case	O
DR	int
:	O
if	O
(	O
read_float	function
(	O
&	O
p1	struct
.	O
x	int
,	O
hd	pointer
)	O
)	O
{	O
tp	pointer
->	O
dir	float
=	O
0.0	int
;	O
tp	pointer
->	O
CR_point	struct
=	O
HP_pos	struct
;	O
adjust_text_par	function
(	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
read_float	function
(	O
&	O
p1	struct
.	O
y	int
,	O
hd	pointer
)	O
)	O
par_err_exit	function
(	O
2	int
,	O
cmd	enum
,	O
hd	pointer
)	O
;	O
if	O
(	O
(	O
p1	struct
.	O
x	int
==	O
0.0	int
)	O
&&	O
(	O
p1	struct
.	O
y	int
==	O
0.0	int
)	O
)	O
par_err_exit	function
(	O
0	int
,	O
cmd	enum
,	O
hd	pointer
)	O
;	O
tp	pointer
->	O
dir	float
=	O
atan2	function
(	O
p1	struct
.	O
y	int
*	O
(	O
P2	struct
.	O
y	int
-	O
P1	struct
.	O
y	int
)	O
,	O
p1	struct
.	O
x	int
*	O
(	O
P2	struct
.	O
x	int
-	O
P1	struct
.	O
x	int
)	O
)	O
;	O
tp	pointer
->	O
CR_point	struct
=	O
HP_pos	struct
;	O
adjust_text_par	function
(	O
)	O
;	O
break	O
;	O
case	O
DT	int
:	O
StrTerm	char
=	O
getc	function
(	O
hd	pointer
)	O
;	O
if	O
(	O
StrTerm	char
==	O
';'	O
)	O
{	O
StrTerm	char
=	O
ETX	char
;	O
StrTermSilent	short
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
)	O
{	O
StrTermSilent	short
=	O
1	int
;	O
}	O
else	O
StrTermSilent	short
=	O
(	O
short	O
)	O
ftmp	float
;	O
break	O
;	O
case	O
DV	int
:	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
||	O
ftmp	float
==	O
0	int
)	O
mode_vert	int
=	O
0	int
;	O
else	O
mode_vert	int
=	O
1	int
;	O
break	O
;	O
case	O
ES	int
:	O
if	O
(	O
read_float	function
(	O
&	O
tp	pointer
->	O
espace	float
,	O
hd	pointer
)	O
)	O
{	O
tp	pointer
->	O
espace	float
=	O
0.0	int
;	O
tp	pointer
->	O
eline	float
=	O
0.0	int
;	O
}	O
else	O
if	O
(	O
read_float	function
(	O
&	O
tp	pointer
->	O
eline	float
,	O
hd	pointer
)	O
)	O
tp	pointer
->	O
eline	float
=	O
0.0	int
;	O
adjust_text_par	function
(	O
)	O
;	O
break	O
;	O
case	O
LA	int
:	O
set_line_attr	function
(	O
hd	pointer
)	O
;	O
break	O
;	O
case	O
LB	int
:	O
read_string	function
(	O
strbuf	pointer
,	O
hd	pointer
)	O
;	O
plot_string	function
(	O
strbuf	pointer
,	O
LB_direct	int
,	O
pen	int
)	O
;	O
if	O
(	O
scale_flag	int
)	O
Plotter_to_User_coord	function
(	O
&	O
HP_pos	struct
,	O
&	O
p_last	struct
)	O
;	O
else	O
p_last	struct
=	O
HP_pos	struct
;	O
break	O
;	O
case	O
LO	int
:	O
if	O
(	O
read_float	function
(	O
&	O
p1	struct
.	O
x	int
,	O
hd	pointer
)	O
)	O
tp	pointer
->	O
orig	int
=	O
1	int
;	O
else	O
{	O
tp	pointer
->	O
orig	int
=	O
(	O
int	O
)	O
p1	struct
.	O
x	int
;	O
if	O
(	O
tp	pointer
->	O
orig	int
<	O
1	int
||	O
tp	pointer
->	O
orig	int
==	O
10	int
||	O
tp	pointer
->	O
orig	int
>	O
19	int
)	O
tp	pointer
->	O
orig	int
=	O
1	int
;	O
}	O
adjust_text_par	function
(	O
)	O
;	O
break	O
;	O
case	O
PB	int
:	O
plot_string	function
(	O
strbuf	pointer
,	O
LB_buffered	int
,	O
pen	int
)	O
;	O
break	O
;	O
case	O
SI	int
:	O
if	O
(	O
read_float	function
(	O
&	O
tp	pointer
->	O
width	array
,	O
hd	pointer
)	O
)	O
{	O
tp	pointer
->	O
width	array
=	O
0.187	int
;	O
tp	pointer
->	O
height	double
=	O
0.269	int
;	O
}	O
else	O
{	O
if	O
(	O
read_float	function
(	O
&	O
tp	pointer
->	O
height	double
,	O
hd	pointer
)	O
)	O
par_err_exit	function
(	O
2	int
,	O
cmd	enum
,	O
hd	pointer
)	O
;	O
if	O
(	O
(	O
tp	pointer
->	O
width	array
==	O
0.0	int
)	O
||	O
(	O
tp	pointer
->	O
height	double
==	O
0.0	int
)	O
)	O
par_err_exit	function
(	O
0	int
,	O
cmd	enum
,	O
hd	pointer
)	O
;	O
}	O
tp	pointer
->	O
width	array
*=	O
400.0	int
;	O
tp	pointer
->	O
height	double
*=	O
400.0	int
;	O
adjust_text_par	function
(	O
)	O
;	O
break	O
;	O
case	O
SL	int
:	O
if	O
(	O
read_float	function
(	O
&	O
tp	pointer
->	O
slant	float
,	O
hd	pointer
)	O
)	O
tp	pointer
->	O
slant	float
=	O
0.0	int
;	O
adjust_text_par	function
(	O
)	O
;	O
break	O
;	O
case	O
SM	int
:	O
read_symbol_char	function
(	O
hd	pointer
)	O
;	O
break	O
;	O
case	O
SR	int
:	O
if	O
(	O
read_float	function
(	O
&	O
tp	pointer
->	O
width	array
,	O
hd	pointer
)	O
)	O
{	O
tp	pointer
->	O
width	array
=	O
0.75	int
;	O
tp	pointer
->	O
height	double
=	O
1.5	int
;	O
}	O
else	O
{	O
if	O
(	O
read_float	function
(	O
&	O
tp	pointer
->	O
height	double
,	O
hd	pointer
)	O
)	O
par_err_exit	function
(	O
2	int
,	O
(	O
short	O
)	O
cmd	enum
,	O
hd	pointer
)	O
;	O
if	O
(	O
(	O
tp	pointer
->	O
width	array
==	O
0.0	int
)	O
||	O
(	O
tp	pointer
->	O
height	double
==	O
0.0	int
)	O
)	O
par_err_exit	function
(	O
0	int
,	O
(	O
short	O
)	O
cmd	enum
,	O
hd	pointer
)	O
;	O
}	O
tp	pointer
->	O
width	array
*=	O
(	O
P2	struct
.	O
x	int
-	O
P1	struct
.	O
x	int
)	O
/	O
100.0	int
;	O
tp	pointer
->	O
height	double
*=	O
(	O
P2	struct
.	O
y	int
-	O
P1	struct
.	O
y	int
)	O
/	O
100.0	int
;	O
adjust_text_par	function
(	O
)	O
;	O
break	O
;	O
case	O
SA	int
:	O
if	O
(	O
tp	pointer
->	O
altfont	int
)	O
tp	pointer
->	O
font	int
=	O
tp	pointer
->	O
altfont	int
;	O
else	O
tp	pointer
->	O
font	int
=	O
0	int
;	O
tp	pointer
->	O
strokewidth	double
=	O
tp	pointer
->	O
astrokewidth	double
;	O
break	O
;	O
case	O
SD	int
:	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
)	O
tp	pointer
->	O
stdfont	int
=	O
0	int
;	O
else	O
{	O
switch	O
(	O
(	O
int	O
)	O
ftmp	float
)	O
{	O
case	O
1	int
:	O
if	O
(	O
read_float	function
(	O
&	O
csfont	float
,	O
hd	pointer
)	O
)	O
par_err_exit	function
(	O
2	int
,	O
cmd	enum
,	O
hd	pointer
)	O
;	O
else	O
tp	pointer
->	O
stdfont	int
=	O
(	O
int	O
)	O
csfont	float
;	O
break	O
;	O
case	O
2	int
:	O
if	O
(	O
read_float	function
(	O
&	O
csfont	float
,	O
hd	pointer
)	O
)	O
par_err_exit	function
(	O
2	int
,	O
cmd	enum
,	O
hd	pointer
)	O
;	O
else	O
if	O
(	O
(	O
int	O
)	O
csfont	float
==	O
1	int
&&	O
!	O
silent_mode	short
)	O
fprintf	function
(	O
stderr	pointer
,	O
"only fixed fonts available\n"	pointer
)	O
;	O
break	O
;	O
case	O
3	int
:	O
case	O
4	int
:	O
case	O
5	int
:	O
case	O
6	int
:	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
)	O
par_err_exit	function
(	O
2	int
,	O
cmd	enum
,	O
hd	pointer
)	O
;	O
if	O
(	O
ftmp	float
==	O
9999	int
)	O
tp	pointer
->	O
sstrokewidth	double
=	O
ftmp	float
;	O
else	O
{	O
if	O
(	O
ftmp	float
<	O
-	O
7.	int
||	O
ftmp	float
>	O
7.	int
)	O
ftmp	float
=	O
0.	int
;	O
tp	pointer
->	O
sstrokewidth	double
=	O
0.11	int
+	O
ftmp	float
/	O
70.	int
;	O
}	O
break	O
;	O
case	O
7	int
:	O
if	O
(	O
read_float	function
(	O
&	O
csfont	float
,	O
hd	pointer
)	O
)	O
par_err_exit	function
(	O
2	int
,	O
cmd	enum
,	O
hd	pointer
)	O
;	O
else	O
if	O
(	O
!	O
silent_mode	short
)	O
fprintf	function
(	O
stderr	pointer
,	O
"pitch/height/posture/typeface unsupported\n"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
par_err_exit	function
(	O
1	int
,	O
cmd	enum
,	O
hd	pointer
)	O
;	O
}	O
}	O
break	O
;	O
case	O
SS	int
:	O
if	O
(	O
tp	pointer
->	O
stdfont	int
)	O
tp	pointer
->	O
font	int
=	O
tp	pointer
->	O
stdfont	int
;	O
else	O
tp	pointer
->	O
font	int
=	O
0	int
;	O
tp	pointer
->	O
strokewidth	double
=	O
tp	pointer
->	O
sstrokewidth	double
;	O
break	O
;	O
case	O
UC	int
:	O
plot_user_char	function
(	O
hd	pointer
,	O
pen	int
)	O
;	O
break	O
;	O
case	O
UL	int
:	O
set_line_style_by_UL	function
(	O
hd	pointer
)	O
;	O
break	O
;	O
case	O
MG	int
:	O
case	O
WD	int
:	O
read_string	function
(	O
strbuf	pointer
,	O
hd	pointer
)	O
;	O
if	O
(	O
!	O
silent_mode	short
)	O
Eprintf	function
(	O
"\nLABEL: %s\n"	pointer
,	O
strbuf	pointer
)	O
;	O
break	O
;	O
case	O
VS	int
:	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
)	O
break	O
;	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
)	O
break	O
;	O
if	O
(	O
read_float	function
(	O
&	O
ftmp	float
,	O
hd	pointer
)	O
)	O
break	O
;	O
default	O
:	O
n_unknown	int
++	O
;	O
if	O
(	O
!	O
silent_mode	short
)	O
Eprintf	function
(	O
"  %c%c: ignored  "	pointer
,	O
cmd	enum
>>	O
8	int
,	O
cmd	enum
&	O
0xFF	int
)	O
;	O
if	O
(	O
cmd	enum
==	O
EOF	O
)	O
{	O
n_unexpected	int
++	O
;	O
if	O
(	O
!	O
silent_mode	short
)	O
Eprintf	function
(	O
"\nUnexpected EOF!\t"	pointer
)	O
;	O
}	O
break	O
;	O
}	O
}	O
void	O
read_HPGL	function
(	O
GEN_PAR	struct
*	O
pg	pointer
,	O
const	O
IN_PAR	struct
*	O
pi	pointer
)	O
{	O
int	O
c	int
;	O
int	O
cmd	enum
;	O
vec_cntr_r	long
=	O
0L	int
;	O
vec_cntr_w	long
=	O
0L	int
;	O
n_unexpected	int
=	O
0	int
;	O
n_commands	long
=	O
0	int
;	O
n_unknown	int
=	O
0	int
;	O
if	O
(	O
(	O
c	int
=	O
getc	function
(	O
pi	pointer
->	O
hd	pointer
)	O
)	O
==	O
EOF	O
)	O
return	O
;	O
else	O
ungetc	function
(	O
c	int
,	O
pi	pointer
->	O
hd	pointer
)	O
;	O
if	O
(	O
!	O
pg_flag	short
)	O
init_HPGL	function
(	O
pg	pointer
,	O
pi	pointer
)	O
;	O
if	O
(	O
!	O
pg	pointer
->	O
quiet	int
)	O
Eprintf	function
(	O
"\nReading HPGL file\n"	pointer
)	O
;	O
while	O
(	O
(	O
c	int
=	O
getc	function
(	O
pi	pointer
->	O
hd	pointer
)	O
)	O
!=	O
EOF	O
)	O
{	O
switch	O
(	O
c	int
)	O
{	O
case	O
ESC	char
:	O
read_ESC_cmd	function
(	O
pi	pointer
->	O
hd	pointer
,	O
TRUE	int
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
(	O
c	int
<	O
'A'	O
)	O
||	O
(	O
c	int
>	O
'z'	O
)	O
||	O
(	O
(	O
c	int
>	O
'Z'	O
)	O
&&	O
(	O
c	int
<	O
'a'	O
)	O
)	O
)	O
break	O
;	O
if	O
(	O
c	int
==	O
'P'	O
)	O
{	O
if	O
(	O
(	O
cmd	enum
=	O
getc	function
(	O
pi	pointer
->	O
hd	pointer
)	O
)	O
==	O
'G'	O
)	O
{	O
page_number	int
++	O
;	O
record_off	short
=	O
(	O
first_page	int
>	O
page_number	int
)	O
||	O
(	O
(	O
last_page	int
<	O
page_number	int
)	O
&&	O
(	O
last_page	int
>	O
0	int
)	O
)	O
;	O
goto	O
END	O
;	O
}	O
else	O
{	O
if	O
(	O
cmd	enum
==	O
EOF	O
)	O
return	O
;	O
ungetc	function
(	O
cmd	enum
,	O
pi	pointer
->	O
hd	pointer
)	O
;	O
}	O
}	O
if	O
(	O
c	int
==	O
'N'	O
)	O
{	O
if	O
(	O
(	O
cmd	enum
=	O
getc	function
(	O
pi	pointer
->	O
hd	pointer
)	O
)	O
==	O
'R'	O
)	O
{	O
page_number	int
++	O
;	O
record_off	short
=	O
(	O
first_page	int
>	O
page_number	int
)	O
||	O
(	O
(	O
last_page	int
<	O
page_number	int
)	O
&&	O
(	O
last_page	int
>	O
0	int
)	O
)	O
;	O
goto	O
END	O
;	O
}	O
else	O
{	O
if	O
(	O
cmd	enum
==	O
EOF	O
)	O
return	O
;	O
ungetc	function
(	O
cmd	enum
,	O
pi	pointer
->	O
hd	pointer
)	O
;	O
}	O
}	O
if	O
(	O
c	int
==	O
'A'	O
)	O
{	O
cmd	enum
=	O
getc	function
(	O
pi	pointer
->	O
hd	pointer
)	O
;	O
if	O
(	O
cmd	enum
==	O
'F'	O
||	O
cmd	enum
==	O
'H'	O
)	O
{	O
page_number	int
++	O
;	O
record_off	short
=	O
(	O
first_page	int
>	O
page_number	int
)	O
||	O
(	O
(	O
last_page	int
<	O
page_number	int
)	O
&&	O
(	O
last_page	int
>	O
0	int
)	O
)	O
;	O
goto	O
END	O
;	O
}	O
else	O
{	O
if	O
(	O
cmd	enum
==	O
EOF	O
)	O
return	O
;	O
ungetc	function
(	O
cmd	enum
,	O
pi	pointer
->	O
hd	pointer
)	O
;	O
}	O
}	O
cmd	enum
=	O
c	int
<<	O
8	int
;	O
if	O
(	O
(	O
c	int
=	O
getc	function
(	O
pi	pointer
->	O
hd	pointer
)	O
)	O
==	O
EOF	O
)	O
return	O
;	O
if	O
(	O
(	O
c	int
<	O
'A'	O
)	O
||	O
(	O
c	int
>	O
'z'	O
)	O
||	O
(	O
(	O
c	int
>	O
'Z'	O
)	O
&&	O
(	O
c	int
<	O
'a'	O
)	O
)	O
)	O
{	O
ungetc	function
(	O
c	int
,	O
pi	pointer
->	O
hd	pointer
)	O
;	O
break	O
;	O
}	O
cmd	enum
|=	O
(	O
c	int
&	O
0xFF	int
)	O
;	O
n_commands	long
++	O
;	O
read_HPGL_cmd	function
(	O
pg	pointer
,	O
cmd	enum
,	O
pi	pointer
->	O
hd	pointer
)	O
;	O
}	O
}	O
if	O
(	O
c	int
==	O
EOF	O
)	O
{	O
page_number	int
++	O
;	O
}	O
END	O
:	O
if	O
(	O
!	O
pg	pointer
->	O
quiet	int
&&	O
n_commands	long
>	O
0	int
)	O
{	O
Eprintf	function
(	O
"Page number %d of range %d - %d\n"	pointer
,	O
page_number	int
-	O
1	int
,	O
pi	pointer
->	O
first_page	int
,	O
pi	pointer
->	O
last_page	int
)	O
;	O
Eprintf	function
(	O
"\nHPGL commands read: %d\n"	pointer
,	O
n_commands	long
)	O
;	O
Eprintf	function
(	O
"HPGL command(s) ignored: %d\n"	pointer
,	O
n_unknown	int
)	O
;	O
Eprintf	function
(	O
"Unexpected event(s):  %d\n"	pointer
,	O
n_unexpected	int
)	O
;	O
Eprintf	function
(	O
"Internal command(s):  %ld\n"	pointer
,	O
vec_cntr_w	long
)	O
;	O
if	O
(	O
(	O
pi	pointer
->	O
first_page	int
>	O
page_number	int
-	O
1	int
)	O
||	O
(	O
(	O
pi	pointer
->	O
last_page	int
<	O
page_number	int
-	O
1	int
)	O
&&	O
(	O
pi	pointer
->	O
last_page	int
>	O
0	int
)	O
)	O
)	O
{	O
n_commands	long
=	O
-	O
1	int
;	O
Eprintf	function
(	O
"Page %d not drawn (outside selected range %d-%d)\n"	pointer
,	O
page_number	int
-	O
1	int
,	O
pi	pointer
->	O
first_page	int
,	O
pi	pointer
->	O
last_page	int
)	O
;	O
}	O
Eprintf	function
(	O
"Pens used: "	pointer
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
NUMPENS	int
;	O
c	int
++	O
)	O
if	O
(	O
pens_in_use	array
[	O
c	int
]	O
==	O
1	int
)	O
Eprintf	function
(	O
"%d "	pointer
,	O
c	int
)	O
;	O
Eprintf	function
(	O
"\nMax. number of pages: %d\n"	pointer
,	O
page_number	int
-	O
1	int
)	O
;	O
}	O
}	O
void	O
adjust_input_transform	function
(	O
const	O
GEN_PAR	struct
*	O
pg	pointer
,	O
const	O
IN_PAR	struct
*	O
pi	pointer
,	O
OUT_PAR	struct
*	O
po	pointer
)	O
{	O
double	O
dot_ratio	double
,	O
Dx	double
,	O
Dy	double
,	O
tmp_w	double
,	O
tmp_h	double
;	O
char	O
*	O
dir_str	pointer
;	O
Dx	double
=	O
xmax	double
-	O
xmin	double
;	O
Dy	double
=	O
ymax	double
-	O
ymin	double
;	O
dot_ratio	double
=	O
(	O
double	O
)	O
po	pointer
->	O
dpi_y	int
/	O
(	O
double	O
)	O
po	pointer
->	O
dpi_x	int
;	O
po	pointer
->	O
width	array
=	O
pi	pointer
->	O
width	array
;	O
po	pointer
->	O
height	double
=	O
pi	pointer
->	O
height	double
;	O
po	pointer
->	O
xoff	double
=	O
pi	pointer
->	O
xoff	double
;	O
po	pointer
->	O
yoff	double
=	O
pi	pointer
->	O
yoff	double
;	O
tmp_w	double
=	O
pi	pointer
->	O
height	double
*	O
Dx	double
/	O
Dy	double
*	O
pi	pointer
->	O
aspectfactor	double
;	O
tmp_h	double
=	O
pi	pointer
->	O
width	array
*	O
Dy	double
/	O
Dx	double
/	O
pi	pointer
->	O
aspectfactor	double
;	O
if	O
(	O
pi	pointer
->	O
truesize	int
)	O
{	O
po	pointer
->	O
width	array
=	O
Dx	double
/	O
40.0	int
;	O
po	pointer
->	O
height	double
=	O
Dy	double
/	O
40.0	int
;	O
po	pointer
->	O
HP_to_xdots	double
=	O
(	O
float	O
)	O
(	O
po	pointer
->	O
dpi_x	int
/	O
1016.0	int
)	O
;	O
po	pointer
->	O
HP_to_ydots	double
=	O
(	O
float	O
)	O
(	O
po	pointer
->	O
dpi_y	int
/	O
1016.0	int
)	O
;	O
dir_str	pointer
=	O
"true sizes"	pointer
;	O
if	O
(	O
pi	pointer
->	O
center_mode	int
)	O
{	O
if	O
(	O
!	O
pg	pointer
->	O
quiet	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"trying to center image\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"po->width ?<? tmp_w: %f %f\n"	pointer
,	O
po	pointer
->	O
width	array
,	O
tmp_w	double
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"po->height ?<? tmp_h: %f %f\n"	pointer
,	O
po	pointer
->	O
height	double
,	O
tmp_h	double
)	O
;	O
}	O
if	O
(	O
po	pointer
->	O
width	array
<	O
tmp_w	double
)	O
po	pointer
->	O
xoff	double
+=	O
(	O
tmp_w	double
-	O
po	pointer
->	O
width	array
)	O
/	O
2.0	int
;	O
if	O
(	O
po	pointer
->	O
height	double
<	O
tmp_h	double
)	O
po	pointer
->	O
yoff	double
+=	O
(	O
tmp_h	double
-	O
po	pointer
->	O
height	double
)	O
/	O
2.0	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
Dy	double
>	O
Dx	double
)	O
{	O
po	pointer
->	O
HP_to_ydots	double
=	O
(	O
float	O
)	O
(	O
po	pointer
->	O
dpi_y	int
*	O
po	pointer
->	O
height	double
)	O
/	O
Dy	double
/	O
25.4	int
;	O
po	pointer
->	O
HP_to_xdots	double
=	O
po	pointer
->	O
HP_to_ydots	double
*	O
pi	pointer
->	O
aspectfactor	double
/	O
dot_ratio	double
;	O
if	O
(	O
pi	pointer
->	O
center_mode	int
)	O
po	pointer
->	O
xoff	double
+=	O
(	O
po	pointer
->	O
width	array
-	O
tmp_w	double
)	O
/	O
2.0	int
;	O
po	pointer
->	O
width	array
=	O
tmp_w	double
;	O
dir_str	pointer
=	O
"width adapted"	pointer
;	O
}	O
else	O
{	O
po	pointer
->	O
HP_to_xdots	double
=	O
(	O
float	O
)	O
(	O
po	pointer
->	O
dpi_x	int
*	O
po	pointer
->	O
width	array
)	O
/	O
Dx	double
/	O
25.4	int
;	O
po	pointer
->	O
HP_to_ydots	double
=	O
po	pointer
->	O
HP_to_xdots	double
*	O
dot_ratio	double
/	O
pi	pointer
->	O
aspectfactor	double
;	O
if	O
(	O
pi	pointer
->	O
center_mode	int
)	O
po	pointer
->	O
yoff	double
+=	O
(	O
po	pointer
->	O
height	double
-	O
tmp_h	double
)	O
/	O
2.0	int
;	O
po	pointer
->	O
height	double
=	O
tmp_h	double
;	O
dir_str	pointer
=	O
"height adapted"	pointer
;	O
}	O
}	O
if	O
(	O
!	O
pg	pointer
->	O
quiet	int
)	O
{	O
Eprintf	function
(	O
"\nWidth  x  height: %5.2f x %5.2f mm, %s\n"	pointer
,	O
po	pointer
->	O
width	array
,	O
po	pointer
->	O
height	double
,	O
dir_str	pointer
)	O
;	O
Eprintf	function
(	O
"Coordinate range: (%g, %g) ... (%g, %g)\n"	pointer
,	O
xmin	double
,	O
ymin	double
,	O
xmax	double
,	O
ymax	double
)	O
;	O
}	O
po	pointer
->	O
xmin	double
=	O
xmin	double
;	O
po	pointer
->	O
xmax	double
=	O
xmax	double
;	O
po	pointer
->	O
ymin	double
=	O
ymin	double
;	O
po	pointer
->	O
ymax	double
=	O
ymax	double
;	O
}	O
PlotCmd	enum
PlotCmd_from_tmpfile	function
(	O
void	O
)	O
{	O
PlotCmd	enum
cmd	enum
;	O
if	O
(	O
!	O
silent_mode	short
&&	O
!	O
again	int
)	O
switch	O
(	O
vec_cntr_r	long
++	O
)	O
{	O
case	O
0	int
:	O
Eprintf	function
(	O
"\nProcessing Cmd: "	pointer
)	O
;	O
break	O
;	O
case	O
1	int
:	O
Eprintf	function
(	O
"1 "	pointer
)	O
;	O
break	O
;	O
case	O
2	int
:	O
Eprintf	function
(	O
"2 "	pointer
)	O
;	O
break	O
;	O
case	O
5	int
:	O
Eprintf	function
(	O
"5 "	pointer
)	O
;	O
break	O
;	O
case	O
10	int
:	O
Eprintf	function
(	O
"10 "	pointer
)	O
;	O
break	O
;	O
case	O
20	int
:	O
Eprintf	function
(	O
"20 "	pointer
)	O
;	O
break	O
;	O
case	O
50	int
:	O
Eprintf	function
(	O
"50 "	pointer
)	O
;	O
break	O
;	O
case	O
100	int
:	O
Eprintf	function
(	O
"100 "	pointer
)	O
;	O
break	O
;	O
case	O
200	int
:	O
Eprintf	function
(	O
"200 "	pointer
)	O
;	O
break	O
;	O
case	O
500	int
:	O
Eprintf	function
(	O
"500 "	pointer
)	O
;	O
break	O
;	O
case	O
1000	int
:	O
Eprintf	function
(	O
"1k "	pointer
)	O
;	O
break	O
;	O
case	O
2000	int
:	O
Eprintf	function
(	O
"2k "	pointer
)	O
;	O
break	O
;	O
case	O
5000	int
:	O
Eprintf	function
(	O
"5k "	pointer
)	O
;	O
break	O
;	O
case	O
10000	int
:	O
Eprintf	function
(	O
"10k "	pointer
)	O
;	O
break	O
;	O
case	O
20000	int
:	O
Eprintf	function
(	O
"20k "	pointer
)	O
;	O
break	O
;	O
case	O
50000L	int
:	O
Eprintf	function
(	O
"50k "	pointer
)	O
;	O
break	O
;	O
case	O
100000L	int
:	O
Eprintf	function
(	O
"100k "	pointer
)	O
;	O
break	O
;	O
case	O
200000L	int
:	O
Eprintf	function
(	O
"200k "	pointer
)	O
;	O
break	O
;	O
case	O
500000L	int
:	O
Eprintf	function
(	O
"500k "	pointer
)	O
;	O
break	O
;	O
}	O
switch	O
(	O
cmd	enum
=	O
fgetc	function
(	O
td	pointer
)	O
)	O
{	O
case	O
NOP	int
:	O
case	O
MOVE_TO	int
:	O
case	O
DRAW_TO	int
:	O
case	O
PLOT_AT	int
:	O
case	O
SET_PEN	int
:	O
case	O
DEF_PW	int
:	O
case	O
DEF_PC	int
:	O
case	O
DEF_LA	int
:	O
return	O
cmd	enum
;	O
case	O
(	O
unsigned	O
int	O
)	O
EOF	O
:	O
default	O
:	O
return	O
CMD_EOF	int
;	O
}	O
}	O
void	O
HPGL_Pt_from_tmpfile	function
(	O
HPGL_Pt	struct
*	O
pf	pointer
)	O
{	O
if	O
(	O
fread	function
(	O
(	O
VOID	void
*	O
)	O
pf	pointer
,	O
sizeof	O
(	O
*	O
pf	pointer
)	O
,	O
1	int
,	O
td	pointer
)	O
!=	O
1	int
)	O
{	O
PError	function
(	O
"HPGL_Pt_from_tmpfile"	pointer
)	O
;	O
Eprintf	function
(	O
"Error @ Cmd %ld\n"	pointer
,	O
vec_cntr_r	long
)	O
;	O
exit	function
(	O
ERROR	O
)	O
;	O
}	O
if	O
(	O
pf	pointer
->	O
x	int
<	O
xmin	double
||	O
pf	pointer
->	O
x	int
>	O
xmax	double
)	O
Eprintf	function
(	O
"HPGL_Pt_from_tmpfile: x out of range (%g not in [%g, %g])\n"	pointer
,	O
pf	pointer
->	O
x	int
,	O
xmin	double
,	O
xmax	double
)	O
;	O
if	O
(	O
pf	pointer
->	O
y	int
<	O
ymin	double
||	O
pf	pointer
->	O
y	int
>	O
ymax	double
)	O
Eprintf	function
(	O
"HPGL_Pt_from_tmpfile: y out of range (%g not in [%g, %g])\n"	pointer
,	O
pf	pointer
->	O
y	int
,	O
ymin	double
,	O
ymax	double
)	O
;	O
}	O
