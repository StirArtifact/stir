extern	O
struct	O
display	struct
*	O
display	struct
;	O
extern	O
int	O
captionalways	int
;	O
struct	O
layout	struct
*	O
layouts	pointer
;	O
struct	O
layout	struct
*	O
laytab	array
[	O
MAXLAY	int
]	O
;	O
struct	O
layout	struct
*	O
layout_last	pointer
,	O
layout_last_marker	struct
;	O
struct	O
layout	struct
*	O
layout_attach	pointer
=	O
&	O
layout_last_marker	struct
;	O
void	O
FreeLayoutCv	function
(	O
struct	O
canvas	struct
*	O
cv	pointer
)	O
{	O
struct	O
canvas	struct
*	O
cnext	pointer
,	O
*	O
c	pointer
=	O
cv	pointer
;	O
for	O
(	O
;	O
cv	pointer
;	O
cv	pointer
=	O
cnext	pointer
)	O
{	O
if	O
(	O
cv	pointer
->	O
c_slperp	pointer
)	O
{	O
FreeLayoutCv	function
(	O
cv	pointer
->	O
c_slperp	pointer
)	O
;	O
free	function
(	O
cv	pointer
->	O
c_slperp	pointer
)	O
;	O
cv	pointer
->	O
c_slperp	pointer
=	O
0	int
;	O
}	O
cnext	pointer
=	O
cv	pointer
->	O
c_slnext	pointer
;	O
cv	pointer
->	O
c_slnext	pointer
=	O
0	int
;	O
if	O
(	O
cv	pointer
!=	O
c	pointer
)	O
free	function
(	O
cv	pointer
)	O
;	O
}	O
}	O
struct	O
layout	struct
*	O
CreateLayout	function
(	O
char	O
*	O
title	pointer
,	O
int	O
startat	int
)	O
{	O
struct	O
layout	struct
*	O
lay	pointer
,	O
*	O
*	O
pl	pointer
;	O
int	O
i	int
;	O
if	O
(	O
startat	int
>=	O
MAXLAY	int
||	O
startat	int
<	O
0	int
)	O
startat	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
startat	int
;	O
;	O
)	O
{	O
if	O
(	O
!	O
laytab	array
[	O
i	int
]	O
)	O
break	O
;	O
if	O
(	O
++	O
i	int
==	O
MAXLAY	int
)	O
i	int
=	O
0	int
;	O
if	O
(	O
i	int
==	O
startat	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"No more layouts\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
}	O
lay	pointer
=	O
(	O
struct	O
layout	struct
*	O
)	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
lay	pointer
)	O
)	O
;	O
lay	pointer
->	O
lay_title	pointer
=	O
SaveStr	function
(	O
title	pointer
)	O
;	O
lay	pointer
->	O
lay_autosave	int
=	O
1	int
;	O
lay	pointer
->	O
lay_number	int
=	O
i	int
;	O
laytab	array
[	O
i	int
]	O
=	O
lay	pointer
;	O
lay	pointer
->	O
lay_next	pointer
=	O
0	int
;	O
pl	pointer
=	O
&	O
layouts	pointer
;	O
while	O
(	O
*	O
pl	pointer
)	O
pl	pointer
=	O
&	O
(	O
*	O
pl	pointer
)	O
->	O
lay_next	pointer
;	O
*	O
pl	pointer
=	O
lay	pointer
;	O
return	O
lay	pointer
;	O
}	O
void	O
SaveLayout	function
(	O
char	O
*	O
name	pointer
,	O
struct	O
canvas	struct
*	O
cv	pointer
)	O
{	O
struct	O
layout	struct
*	O
lay	pointer
;	O
struct	O
canvas	struct
*	O
fcv	pointer
;	O
for	O
(	O
lay	pointer
=	O
layouts	pointer
;	O
lay	pointer
;	O
lay	pointer
=	O
lay	pointer
->	O
lay_next	pointer
)	O
if	O
(	O
!	O
strcmp	function
(	O
lay	pointer
->	O
lay_title	pointer
,	O
name	pointer
)	O
)	O
break	O
;	O
if	O
(	O
lay	pointer
)	O
FreeLayoutCv	function
(	O
&	O
lay	pointer
->	O
lay_canvas	struct
)	O
;	O
else	O
lay	pointer
=	O
CreateLayout	function
(	O
name	pointer
,	O
0	int
)	O
;	O
if	O
(	O
!	O
lay	pointer
)	O
return	O
;	O
fcv	pointer
=	O
D_forecv	O
;	O
DupLayoutCv	function
(	O
cv	pointer
,	O
&	O
lay	pointer
->	O
lay_canvas	struct
,	O
1	int
)	O
;	O
lay	pointer
->	O
lay_forecv	pointer
=	O
D_forecv	O
;	O
D_forecv	O
=	O
fcv	pointer
;	O
D_layout	O
=	O
lay	pointer
;	O
}	O
void	O
AutosaveLayout	function
(	O
struct	O
layout	struct
*	O
lay	pointer
)	O
{	O
struct	O
canvas	struct
*	O
fcv	pointer
;	O
if	O
(	O
!	O
lay	pointer
||	O
!	O
lay	pointer
->	O
lay_autosave	int
)	O
return	O
;	O
FreeLayoutCv	function
(	O
&	O
lay	pointer
->	O
lay_canvas	struct
)	O
;	O
fcv	pointer
=	O
D_forecv	O
;	O
DupLayoutCv	function
(	O
&	O
D_canvas	O
,	O
&	O
lay	pointer
->	O
lay_canvas	struct
,	O
1	int
)	O
;	O
lay	pointer
->	O
lay_forecv	pointer
=	O
D_forecv	O
;	O
D_forecv	O
=	O
fcv	pointer
;	O
}	O
struct	O
layout	struct
*	O
FindLayout	function
(	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
layout	struct
*	O
lay	pointer
;	O
char	O
*	O
s	pointer
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
,	O
s	pointer
=	O
name	pointer
;	O
*	O
s	pointer
>=	O
'0'	O
&&	O
*	O
s	pointer
<=	O
'9'	O
;	O
s	pointer
++	O
)	O
i	int
=	O
i	int
*	O
10	int
+	O
(	O
*	O
s	pointer
-	O
'0'	O
)	O
;	O
if	O
(	O
!	O
*	O
s	pointer
&&	O
s	pointer
!=	O
name	pointer
&&	O
i	int
>=	O
0	int
&&	O
i	int
<	O
MAXLAY	int
)	O
return	O
laytab	array
[	O
i	int
]	O
;	O
for	O
(	O
lay	pointer
=	O
layouts	pointer
;	O
lay	pointer
;	O
lay	pointer
=	O
lay	pointer
->	O
lay_next	pointer
)	O
if	O
(	O
!	O
strcmp	function
(	O
lay	pointer
->	O
lay_title	pointer
,	O
name	pointer
)	O
)	O
break	O
;	O
return	O
lay	pointer
;	O
}	O
void	O
LoadLayout	function
(	O
struct	O
layout	struct
*	O
lay	pointer
,	O
struct	O
canvas	struct
*	O
cv	pointer
)	O
{	O
AutosaveLayout	function
(	O
D_layout	O
)	O
;	O
if	O
(	O
!	O
lay	pointer
)	O
{	O
while	O
(	O
D_canvas	O
.	O
c_slperp	pointer
)	O
FreeCanvas	function
(	O
D_canvas	O
.	O
c_slperp	pointer
)	O
;	O
MakeDefaultCanvas	function
(	O
)	O
;	O
SetCanvasWindow	function
(	O
D_forecv	O
,	O
0	int
)	O
;	O
D_layout	O
=	O
0	int
;	O
return	O
;	O
}	O
while	O
(	O
D_canvas	O
.	O
c_slperp	pointer
)	O
FreeCanvas	function
(	O
D_canvas	O
.	O
c_slperp	pointer
)	O
;	O
D_cvlist	O
=	O
0	int
;	O
D_forecv	O
=	O
lay	pointer
->	O
lay_forecv	pointer
;	O
if	O
(	O
!	O
D_forecv	O
)	O
MakeDefaultCanvas	function
(	O
)	O
;	O
DupLayoutCv	function
(	O
&	O
lay	pointer
->	O
lay_canvas	struct
,	O
&	O
D_canvas	O
,	O
0	int
)	O
;	O
D_canvas	O
.	O
c_ys	int
=	O
(	O
D_has_hstatus	O
==	O
HSTATUS_FIRSTLINE	int
)	O
;	O
D_canvas	O
.	O
c_ye	int
=	O
D_height	O
-	O
1	int
-	O
(	O
(	O
D_canvas	O
.	O
c_slperp	pointer
&&	O
D_canvas	O
.	O
c_slperp	pointer
->	O
c_slnext	pointer
)	O
||	O
captionalways	int
)	O
-	O
(	O
D_has_hstatus	O
==	O
HSTATUS_LASTLINE	int
)	O
;	O
ResizeCanvas	function
(	O
&	O
D_canvas	O
)	O
;	O
RecreateCanvasChain	function
(	O
)	O
;	O
RethinkDisplayViewports	function
(	O
)	O
;	O
PutWindowCv	function
(	O
&	O
D_canvas	O
)	O
;	O
ResizeLayersToCanvases	function
(	O
)	O
;	O
D_layout	O
=	O
lay	pointer
;	O
}	O
void	O
NewLayout	function
(	O
char	O
*	O
title	pointer
,	O
int	O
startat	int
)	O
{	O
struct	O
layout	struct
*	O
lay	pointer
;	O
struct	O
canvas	struct
*	O
fcv	pointer
;	O
lay	pointer
=	O
CreateLayout	function
(	O
title	pointer
,	O
startat	int
)	O
;	O
if	O
(	O
!	O
lay	pointer
)	O
return	O
;	O
if	O
(	O
display	struct
)	O
{	O
LoadLayout	function
(	O
0	int
,	O
&	O
D_canvas	O
)	O
;	O
fcv	pointer
=	O
D_forecv	O
;	O
DupLayoutCv	function
(	O
&	O
D_canvas	O
,	O
&	O
lay	pointer
->	O
lay_canvas	struct
,	O
1	int
)	O
;	O
lay	pointer
->	O
lay_forecv	pointer
=	O
D_forecv	O
;	O
D_forecv	O
=	O
fcv	pointer
;	O
D_layout	O
=	O
lay	pointer
;	O
}	O
else	O
layout_attach	pointer
=	O
lay	pointer
;	O
lay	pointer
->	O
lay_autosave	int
=	O
1	int
;	O
}	O
static	O
char	O
*	O
AddLayoutsInfo	function
(	O
char	O
*	O
buf	pointer
,	O
int	O
len	int
,	O
int	O
where	int
)	O
{	O
char	O
*	O
s	pointer
,	O
*	O
ss	pointer
,	O
*	O
t	pointer
;	O
struct	O
layout	struct
*	O
p	pointer
,	O
*	O
*	O
pp	pointer
;	O
int	O
l	int
;	O
s	pointer
=	O
ss	pointer
=	O
buf	pointer
;	O
for	O
(	O
pp	pointer
=	O
laytab	array
;	O
pp	pointer
<	O
laytab	array
+	O
MAXLAY	int
;	O
pp	pointer
++	O
)	O
{	O
if	O
(	O
pp	pointer
-	O
laytab	array
==	O
where	int
&&	O
ss	pointer
==	O
buf	pointer
)	O
ss	pointer
=	O
s	pointer
;	O
if	O
(	O
(	O
p	pointer
=	O
*	O
pp	pointer
)	O
==	O
0	int
)	O
continue	O
;	O
t	pointer
=	O
p	pointer
->	O
lay_title	pointer
;	O
l	int
=	O
strlen	function
(	O
t	pointer
)	O
;	O
if	O
(	O
l	int
>	O
20	int
)	O
l	int
=	O
20	int
;	O
if	O
(	O
s	pointer
-	O
buf	pointer
+	O
l	int
>	O
len	int
-	O
24	int
)	O
break	O
;	O
if	O
(	O
s	pointer
>	O
buf	pointer
)	O
{	O
*	O
s	pointer
++	O
=	O
' '	O
;	O
*	O
s	pointer
++	O
=	O
' '	O
;	O
}	O
sprintf	function
(	O
s	pointer
,	O
"%d"	pointer
,	O
p	pointer
->	O
lay_number	int
)	O
;	O
if	O
(	O
p	pointer
->	O
lay_number	int
==	O
where	int
)	O
ss	pointer
=	O
s	pointer
;	O
s	pointer
+=	O
strlen	function
(	O
s	pointer
)	O
;	O
if	O
(	O
display	struct
&&	O
p	pointer
==	O
D_layout	O
)	O
*	O
s	pointer
++	O
=	O
'*'	O
;	O
*	O
s	pointer
++	O
=	O
' '	O
;	O
strncpy	function
(	O
s	pointer
,	O
t	pointer
,	O
l	int
)	O
;	O
s	pointer
+=	O
l	int
;	O
}	O
*	O
s	pointer
=	O
0	int
;	O
return	O
ss	pointer
;	O
}	O
void	O
ShowLayouts	function
(	O
int	O
where	int
)	O
{	O
char	O
buf	pointer
[	O
1024	int
]	O
;	O
char	O
*	O
s	pointer
,	O
*	O
ss	pointer
;	O
if	O
(	O
!	O
display	struct
)	O
return	O
;	O
if	O
(	O
!	O
layouts	pointer
)	O
{	O
Msg	function
(	O
0	int
,	O
"No layouts defined\n"	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
where	int
==	O
-	O
1	int
&&	O
D_layout	O
)	O
where	int
=	O
D_layout	O
->	O
lay_number	int
;	O
ss	pointer
=	O
AddLayoutsInfo	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
where	int
)	O
;	O
s	pointer
=	O
buf	pointer
+	O
strlen	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
ss	pointer
-	O
buf	pointer
>	O
D_width	O
/	O
2	int
)	O
{	O
ss	pointer
-=	O
D_width	O
/	O
2	int
;	O
if	O
(	O
s	pointer
-	O
ss	pointer
<	O
D_width	O
)	O
{	O
ss	pointer
=	O
s	pointer
-	O
D_width	O
;	O
if	O
(	O
ss	pointer
<	O
buf	pointer
)	O
ss	pointer
=	O
buf	pointer
;	O
}	O
}	O
else	O
ss	pointer
=	O
buf	pointer
;	O
Msg	function
(	O
0	int
,	O
"%s"	pointer
,	O
ss	pointer
)	O
;	O
}	O
void	O
RemoveLayout	function
(	O
struct	O
layout	struct
*	O
lay	pointer
)	O
{	O
struct	O
layout	struct
*	O
*	O
layp	pointer
=	O
&	O
layouts	pointer
;	O
for	O
(	O
;	O
*	O
layp	pointer
;	O
layp	pointer
=	O
&	O
(	O
*	O
layp	pointer
)	O
->	O
lay_next	pointer
)	O
{	O
if	O
(	O
*	O
layp	pointer
==	O
lay	pointer
)	O
{	O
*	O
layp	pointer
=	O
lay	pointer
->	O
lay_next	pointer
;	O
break	O
;	O
}	O
}	O
laytab	array
[	O
lay	pointer
->	O
lay_number	int
]	O
=	O
(	O
struct	O
layout	struct
*	O
)	O
0	int
;	O
if	O
(	O
display	struct
&&	O
D_layout	O
==	O
lay	pointer
)	O
D_layout	O
=	O
(	O
struct	O
layout	struct
*	O
)	O
0	int
;	O
FreeLayoutCv	function
(	O
&	O
lay	pointer
->	O
lay_canvas	struct
)	O
;	O
if	O
(	O
lay	pointer
->	O
lay_title	pointer
)	O
free	function
(	O
lay	pointer
->	O
lay_title	pointer
)	O
;	O
free	function
(	O
lay	pointer
)	O
;	O
if	O
(	O
layouts	pointer
)	O
LoadLayout	function
(	O
(	O
display	struct
&&	O
D_layout	O
)	O
?	O
D_layout	O
:	O
*	O
layp	pointer
?	O
*	O
layp	pointer
:	O
layouts	pointer
,	O
display	struct
?	O
&	O
D_canvas	O
:	O
(	O
struct	O
canvas	struct
*	O
)	O
0	int
)	O
;	O
Activate	function
(	O
0	int
)	O
;	O
}	O
void	O
UpdateLayoutCanvas	function
(	O
struct	O
canvas	struct
*	O
cv	pointer
,	O
struct	O
win	struct
*	O
wi	pointer
)	O
{	O
for	O
(	O
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_slnext	pointer
)	O
{	O
if	O
(	O
cv	pointer
->	O
c_layer	pointer
&&	O
Layer2Window	O
(	O
cv	pointer
->	O
c_layer	pointer
)	O
==	O
wi	pointer
)	O
{	O
struct	O
layer	struct
*	O
l	int
=	O
cv	pointer
->	O
c_layer	pointer
;	O
cv	pointer
->	O
c_layer	pointer
=	O
0	int
;	O
if	O
(	O
l	int
->	O
l_cvlist	pointer
==	O
0	int
&&	O
(	O
wi	pointer
==	O
0	int
||	O
l	int
!=	O
wi	pointer
->	O
w_savelayer	pointer
)	O
)	O
KillLayerChain	function
(	O
l	int
)	O
;	O
l	int
=	O
&	O
cv	pointer
->	O
c_blank	struct
;	O
l	int
->	O
l_data	pointer
=	O
0	int
;	O
if	O
(	O
l	int
->	O
l_cvlist	pointer
!=	O
cv	pointer
)	O
{	O
cv	pointer
->	O
c_lnext	pointer
=	O
l	int
->	O
l_cvlist	pointer
;	O
l	int
->	O
l_cvlist	pointer
=	O
cv	pointer
;	O
}	O
cv	pointer
->	O
c_layer	pointer
=	O
l	int
;	O
}	O
if	O
(	O
cv	pointer
->	O
c_slperp	pointer
)	O
UpdateLayoutCanvas	function
(	O
cv	pointer
->	O
c_slperp	pointer
,	O
wi	pointer
)	O
;	O
}	O
}	O
static	O
void	O
dump_canvas	function
(	O
struct	O
canvas	struct
*	O
cv	pointer
,	O
FILE	struct
*	O
file	pointer
)	O
{	O
struct	O
canvas	struct
*	O
c	pointer
;	O
for	O
(	O
c	pointer
=	O
cv	pointer
->	O
c_slperp	pointer
;	O
c	pointer
&&	O
c	pointer
->	O
c_slnext	pointer
;	O
c	pointer
=	O
c	pointer
->	O
c_slnext	pointer
)	O
fprintf	function
(	O
file	pointer
,	O
"split%s\n"	pointer
,	O
c	pointer
->	O
c_slorient	int
==	O
SLICE_HORI	O
?	O
" -v"	pointer
:	O
""	pointer
)	O
;	O
for	O
(	O
c	pointer
=	O
cv	pointer
->	O
c_slperp	pointer
;	O
c	pointer
;	O
c	pointer
=	O
c	pointer
->	O
c_slnext	pointer
)	O
{	O
if	O
(	O
c	pointer
->	O
c_slperp	pointer
)	O
dump_canvas	function
(	O
c	pointer
,	O
file	pointer
)	O
;	O
else	O
fprintf	function
(	O
file	pointer
,	O
"focus\n"	pointer
)	O
;	O
}	O
}	O
int	O
LayoutDumpCanvas	function
(	O
struct	O
canvas	struct
*	O
cv	pointer
,	O
char	O
*	O
filename	pointer
)	O
{	O
FILE	struct
*	O
file	pointer
=	O
secfopen	function
(	O
filename	pointer
,	O
"a"	pointer
)	O
;	O
if	O
(	O
!	O
file	pointer
)	O
return	O
0	int
;	O
dump_canvas	function
(	O
cv	pointer
,	O
file	pointer
)	O
;	O
fclose	function
(	O
file	pointer
)	O
;	O
return	O
1	int
;	O
}	O
void	O
RenameLayout	function
(	O
struct	O
layout	struct
*	O
layout	struct
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
free	function
(	O
layout	struct
->	O
lay_title	pointer
)	O
;	O
layout	struct
->	O
lay_title	pointer
=	O
SaveStr	function
(	O
name	pointer
)	O
;	O
}	O
int	O
RenumberLayout	function
(	O
struct	O
layout	struct
*	O
layout	struct
,	O
int	O
number	int
)	O
{	O
int	O
old	int
;	O
struct	O
layout	struct
*	O
lay	pointer
;	O
old	int
=	O
layout	struct
->	O
lay_number	int
;	O
if	O
(	O
number	int
<	O
0	int
||	O
number	int
>=	O
MAXLAY	int
)	O
return	O
0	int
;	O
lay	pointer
=	O
laytab	array
[	O
number	int
]	O
;	O
laytab	array
[	O
number	int
]	O
=	O
layout	struct
;	O
layout	struct
->	O
lay_number	int
=	O
number	int
;	O
laytab	array
[	O
old	int
]	O
=	O
lay	pointer
;	O
if	O
(	O
lay	pointer
)	O
lay	pointer
->	O
lay_number	int
=	O
old	int
;	O
return	O
1	int
;	O
}	O
