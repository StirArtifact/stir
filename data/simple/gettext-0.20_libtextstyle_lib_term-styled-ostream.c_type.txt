typedef	O
struct	O
{	O
term_color_t	O
color	O
;	O
term_color_t	O
bgcolor	O
;	O
term_weight_t	O
weight	O
;	O
term_posture_t	O
posture	O
;	O
term_underline_t	O
underline	O
;	O
}	O
attributes_t	O
;	O
const	O
typeinfo_t	O
term_styled_ostream_typeinfo	O
=	O
{	O
"term_styled_ostream"	pointer
}	O
;	O
static	O
const	O
typeinfo_t	O
*	O
const	O
term_styled_ostream_superclasses	array
[	O
]	O
=	O
{	O
term_styled_ostream_SUPERCLASSES	O
}	O
;	O
static	O
void	O
term_styled_ostream__write_mem	function
(	O
term_styled_ostream_t	O
stream	int
,	O
const	O
void	O
*	O
data	pointer
,	O
size_t	O
len	int
)	O
{	O
term_ostream_set_color	function
(	O
stream	int
->	O
destination	O
,	O
stream	int
->	O
curr_attr	O
->	O
color	O
)	O
;	O
term_ostream_set_bgcolor	function
(	O
stream	int
->	O
destination	O
,	O
stream	int
->	O
curr_attr	O
->	O
bgcolor	O
)	O
;	O
term_ostream_set_weight	function
(	O
stream	int
->	O
destination	O
,	O
stream	int
->	O
curr_attr	O
->	O
weight	O
)	O
;	O
term_ostream_set_posture	function
(	O
stream	int
->	O
destination	O
,	O
stream	int
->	O
curr_attr	O
->	O
posture	O
)	O
;	O
term_ostream_set_underline	function
(	O
stream	int
->	O
destination	O
,	O
stream	int
->	O
curr_attr	O
->	O
underline	O
)	O
;	O
term_ostream_write_mem	function
(	O
stream	int
->	O
destination	O
,	O
data	pointer
,	O
len	int
)	O
;	O
}	O
static	O
void	O
term_styled_ostream__flush	function
(	O
term_styled_ostream_t	O
stream	int
,	O
ostream_flush_scope_t	O
scope	int
)	O
{	O
term_ostream_flush	function
(	O
stream	int
->	O
destination	O
,	O
scope	int
)	O
;	O
}	O
static	O
void	O
term_styled_ostream__free	function
(	O
term_styled_ostream_t	O
stream	int
)	O
{	O
term_ostream_free	function
(	O
stream	int
->	O
destination	O
)	O
;	O
cr_cascade_destroy	O
(	O
stream	int
->	O
css_document	O
)	O
;	O
cr_sel_eng_destroy	O
(	O
stream	int
->	O
css_engine	O
)	O
;	O
free	function
(	O
stream	int
->	O
curr_classes	O
)	O
;	O
{	O
void	O
*	O
ptr	pointer
=	O
NULL	O
;	O
const	O
void	O
*	O
key	pointer
;	O
size_t	O
keylen	O
;	O
void	O
*	O
data	pointer
;	O
while	O
(	O
hash_iterate	O
(	O
&	O
stream	int
->	O
cache	O
,	O
&	O
ptr	pointer
,	O
&	O
key	pointer
,	O
&	O
keylen	O
,	O
&	O
data	pointer
)	O
==	O
0	int
)	O
{	O
free	function
(	O
data	pointer
)	O
;	O
}	O
}	O
hash_destroy	O
(	O
&	O
stream	int
->	O
cache	O
)	O
;	O
free	function
(	O
stream	int
)	O
;	O
}	O
enum	O
CRXTextDecorationType	enum
{	O
TEXT_DECORATION_NONE	int
,	O
TEXT_DECORATION_UNDERLINE	int
,	O
TEXT_DECORATION_OVERLINE	int
,	O
TEXT_DECORATION_LINE_THROUGH	int
,	O
TEXT_DECORATION_BLINK	int
,	O
TEXT_DECORATION_INHERIT	int
}	O
;	O
typedef	O
struct	O
_CRXStyle	struct
{	O
struct	O
_CRXStyle	struct
*	O
parent_style	pointer
;	O
CRStyle	O
*	O
base	pointer
;	O
enum	O
CRXTextDecorationType	enum
text_decoration	enum
;	O
}	O
CRXStyle	struct
;	O
static	O
CRXStyle	struct
*	O
crx_style_new	function
(	O
gboolean	O
a_set_props_to_initial_values	int
)	O
{	O
CRStyle	O
*	O
base	pointer
;	O
CRXStyle	struct
*	O
result	pointer
;	O
base	pointer
=	O
cr_style_new	O
(	O
a_set_props_to_initial_values	int
)	O
;	O
if	O
(	O
base	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
result	pointer
=	O
XMALLOC	function
(	O
CRXStyle	struct
)	O
;	O
result	pointer
->	O
base	pointer
=	O
base	pointer
;	O
if	O
(	O
a_set_props_to_initial_values	int
)	O
result	pointer
->	O
text_decoration	enum
=	O
TEXT_DECORATION_NONE	int
;	O
else	O
result	pointer
->	O
text_decoration	enum
=	O
TEXT_DECORATION_INHERIT	int
;	O
return	O
result	pointer
;	O
}	O
static	O
void	O
crx_style_destroy	function
(	O
CRXStyle	struct
*	O
a_style	pointer
)	O
{	O
cr_style_destroy	O
(	O
a_style	pointer
->	O
base	pointer
)	O
;	O
free	function
(	O
a_style	pointer
)	O
;	O
}	O
static	O
enum	O
CRStatus	O
crx_sel_eng_get_matched_style	function
(	O
CRSelEng	O
*	O
a_this	pointer
,	O
CRCascade	O
*	O
a_cascade	pointer
,	O
xmlNode	O
*	O
a_node	pointer
,	O
CRXStyle	struct
*	O
a_parent_style	pointer
,	O
CRXStyle	struct
*	O
*	O
a_style	pointer
,	O
gboolean	O
a_set_props_to_initial_values	int
)	O
{	O
enum	O
CRStatus	O
status	enum
;	O
CRPropList	O
*	O
props	O
=	O
NULL	O
;	O
if	O
(	O
!	O
(	O
a_this	pointer
&&	O
a_cascade	pointer
&&	O
a_node	pointer
&&	O
a_style	pointer
)	O
)	O
return	O
CR_BAD_PARAM_ERROR	O
;	O
status	enum
=	O
cr_sel_eng_get_matched_properties_from_cascade	O
(	O
a_this	pointer
,	O
a_cascade	pointer
,	O
a_node	pointer
,	O
&	O
props	O
)	O
;	O
if	O
(	O
!	O
(	O
status	enum
==	O
CR_OK	O
)	O
)	O
return	O
status	enum
;	O
if	O
(	O
props	O
)	O
{	O
CRXStyle	struct
*	O
style	pointer
;	O
if	O
(	O
!	O
*	O
a_style	pointer
)	O
{	O
*	O
a_style	pointer
=	O
crx_style_new	function
(	O
a_set_props_to_initial_values	int
)	O
;	O
if	O
(	O
!	O
*	O
a_style	pointer
)	O
return	O
CR_ERROR	O
;	O
}	O
else	O
{	O
if	O
(	O
a_set_props_to_initial_values	int
)	O
{	O
cr_style_set_props_to_initial_values	O
(	O
(	O
*	O
a_style	pointer
)	O
->	O
base	pointer
)	O
;	O
(	O
*	O
a_style	pointer
)	O
->	O
text_decoration	enum
=	O
TEXT_DECORATION_NONE	int
;	O
}	O
else	O
{	O
cr_style_set_props_to_default_values	O
(	O
(	O
*	O
a_style	pointer
)	O
->	O
base	pointer
)	O
;	O
(	O
*	O
a_style	pointer
)	O
->	O
text_decoration	enum
=	O
TEXT_DECORATION_INHERIT	int
;	O
}	O
}	O
style	pointer
=	O
*	O
a_style	pointer
;	O
style	pointer
->	O
parent_style	pointer
=	O
a_parent_style	pointer
;	O
style	pointer
->	O
base	pointer
->	O
parent_style	pointer
=	O
(	O
a_parent_style	pointer
!=	O
NULL	O
?	O
a_parent_style	pointer
->	O
base	pointer
:	O
NULL	O
)	O
;	O
{	O
CRPropList	O
*	O
cur	O
;	O
for	O
(	O
cur	O
=	O
props	O
;	O
cur	O
!=	O
NULL	O
;	O
cur	O
=	O
cr_prop_list_get_next	O
(	O
cur	O
)	O
)	O
{	O
CRDeclaration	O
*	O
decl	O
=	O
NULL	O
;	O
cr_prop_list_get_decl	O
(	O
cur	O
,	O
&	O
decl	O
)	O
;	O
cr_style_set_style_from_decl	O
(	O
style	pointer
->	O
base	pointer
,	O
decl	O
)	O
;	O
if	O
(	O
decl	O
!=	O
NULL	O
&&	O
decl	O
->	O
property	O
!=	O
NULL	O
&&	O
decl	O
->	O
property	O
->	O
stryng	O
!=	O
NULL	O
&&	O
decl	O
->	O
property	O
->	O
stryng	O
->	O
str	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
strcmp	O
(	O
decl	O
->	O
property	O
->	O
stryng	O
->	O
str	O
,	O
"text-decoration"	pointer
)	O
==	O
0	int
&&	O
decl	O
->	O
value	pointer
!=	O
NULL	O
&&	O
decl	O
->	O
value	pointer
->	O
type	O
==	O
TERM_IDENT	O
&&	O
decl	O
->	O
value	pointer
->	O
content	O
.	O
str	O
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
value	pointer
=	O
cr_string_peek_raw_str	O
(	O
decl	O
->	O
value	pointer
->	O
content	O
.	O
str	O
)	O
;	O
if	O
(	O
value	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
strcmp	O
(	O
value	pointer
,	O
"none"	pointer
)	O
==	O
0	int
)	O
style	pointer
->	O
text_decoration	enum
=	O
TEXT_DECORATION_NONE	int
;	O
else	O
if	O
(	O
strcmp	O
(	O
value	pointer
,	O
"underline"	pointer
)	O
==	O
0	int
)	O
style	pointer
->	O
text_decoration	enum
=	O
TEXT_DECORATION_UNDERLINE	int
;	O
else	O
if	O
(	O
strcmp	O
(	O
value	pointer
,	O
"overline"	pointer
)	O
==	O
0	int
)	O
style	pointer
->	O
text_decoration	enum
=	O
TEXT_DECORATION_OVERLINE	int
;	O
else	O
if	O
(	O
strcmp	O
(	O
value	pointer
,	O
"line-through"	pointer
)	O
==	O
0	int
)	O
style	pointer
->	O
text_decoration	enum
=	O
TEXT_DECORATION_LINE_THROUGH	int
;	O
else	O
if	O
(	O
strcmp	O
(	O
value	pointer
,	O
"blink"	pointer
)	O
==	O
0	int
)	O
style	pointer
->	O
text_decoration	enum
=	O
TEXT_DECORATION_BLINK	int
;	O
else	O
if	O
(	O
strcmp	O
(	O
value	pointer
,	O
"inherit"	pointer
)	O
==	O
0	int
)	O
style	pointer
->	O
text_decoration	enum
=	O
TEXT_DECORATION_INHERIT	int
;	O
}	O
}	O
}	O
}	O
}	O
cr_prop_list_destroy	O
(	O
props	O
)	O
;	O
}	O
return	O
CR_OK	O
;	O
}	O
static	O
term_color_t	O
style_compute_color_value	function
(	O
CRStyle	O
*	O
style	pointer
,	O
enum	O
CRRgbProp	O
which	enum
,	O
term_ostream_t	O
stream	int
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
style	pointer
==	O
NULL	O
)	O
return	O
COLOR_DEFAULT	O
;	O
if	O
(	O
cr_rgb_is_set_to_inherit	O
(	O
&	O
style	pointer
->	O
rgb_props	O
[	O
which	enum
]	O
.	O
sv	O
)	O
)	O
style	pointer
=	O
style	pointer
->	O
parent_style	pointer
;	O
else	O
if	O
(	O
cr_rgb_is_set_to_transparent	O
(	O
&	O
style	pointer
->	O
rgb_props	O
[	O
which	enum
]	O
.	O
sv	O
)	O
)	O
return	O
COLOR_DEFAULT	O
;	O
else	O
{	O
CRRgb	O
rgb	O
;	O
int	O
r	int
;	O
int	O
g	int
;	O
int	O
b	int
;	O
cr_rgb_copy	O
(	O
&	O
rgb	O
,	O
&	O
style	pointer
->	O
rgb_props	O
[	O
which	enum
]	O
.	O
sv	O
)	O
;	O
if	O
(	O
cr_rgb_compute_from_percentage	O
(	O
&	O
rgb	O
)	O
!=	O
CR_OK	O
)	O
abort	O
(	O
)	O
;	O
r	int
=	O
rgb	O
.	O
red	O
&	O
0xff	int
;	O
g	int
=	O
rgb	O
.	O
green	O
&	O
0xff	int
;	O
b	int
=	O
rgb	O
.	O
blue	O
&	O
0xff	int
;	O
return	O
term_ostream_rgb_to_color	function
(	O
stream	int
,	O
r	int
,	O
g	int
,	O
b	int
)	O
;	O
}	O
}	O
}	O
static	O
term_weight_t	O
style_compute_font_weight_value	function
(	O
const	O
CRStyle	O
*	O
style	pointer
)	O
{	O
int	O
value	pointer
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
style	pointer
==	O
NULL	O
)	O
value	pointer
+=	O
4	int
;	O
else	O
switch	O
(	O
style	pointer
->	O
font_weight	O
)	O
{	O
case	O
FONT_WEIGHT_INHERIT	O
:	O
style	pointer
=	O
style	pointer
->	O
parent_style	pointer
;	O
continue	O
;	O
case	O
FONT_WEIGHT_BOLDER	O
:	O
value	pointer
+=	O
1	int
;	O
style	pointer
=	O
style	pointer
->	O
parent_style	pointer
;	O
continue	O
;	O
case	O
FONT_WEIGHT_LIGHTER	O
:	O
value	pointer
-=	O
1	int
;	O
style	pointer
=	O
style	pointer
->	O
parent_style	pointer
;	O
continue	O
;	O
case	O
FONT_WEIGHT_100	O
:	O
value	pointer
+=	O
1	int
;	O
break	O
;	O
case	O
FONT_WEIGHT_200	O
:	O
value	pointer
+=	O
2	int
;	O
break	O
;	O
case	O
FONT_WEIGHT_300	O
:	O
value	pointer
+=	O
3	int
;	O
break	O
;	O
case	O
FONT_WEIGHT_400	O
:	O
case	O
FONT_WEIGHT_NORMAL	O
:	O
value	pointer
+=	O
4	int
;	O
break	O
;	O
case	O
FONT_WEIGHT_500	O
:	O
value	pointer
+=	O
5	int
;	O
break	O
;	O
case	O
FONT_WEIGHT_600	O
:	O
value	pointer
+=	O
6	int
;	O
break	O
;	O
case	O
FONT_WEIGHT_700	O
:	O
case	O
FONT_WEIGHT_BOLD	O
:	O
value	pointer
+=	O
7	int
;	O
break	O
;	O
case	O
FONT_WEIGHT_800	O
:	O
value	pointer
+=	O
8	int
;	O
break	O
;	O
case	O
FONT_WEIGHT_900	O
:	O
value	pointer
+=	O
9	int
;	O
break	O
;	O
default	O
:	O
abort	O
(	O
)	O
;	O
}	O
return	O
(	O
value	pointer
>=	O
6	int
?	O
WEIGHT_BOLD	O
:	O
WEIGHT_NORMAL	O
)	O
;	O
}	O
}	O
static	O
term_posture_t	O
style_compute_font_posture_value	function
(	O
const	O
CRStyle	O
*	O
style	pointer
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
style	pointer
==	O
NULL	O
)	O
return	O
POSTURE_DEFAULT	O
;	O
switch	O
(	O
style	pointer
->	O
font_style	O
)	O
{	O
case	O
FONT_STYLE_INHERIT	O
:	O
style	pointer
=	O
style	pointer
->	O
parent_style	pointer
;	O
break	O
;	O
case	O
FONT_STYLE_NORMAL	O
:	O
return	O
POSTURE_NORMAL	O
;	O
case	O
FONT_STYLE_ITALIC	O
:	O
case	O
FONT_STYLE_OBLIQUE	O
:	O
return	O
POSTURE_ITALIC	O
;	O
default	O
:	O
abort	O
(	O
)	O
;	O
}	O
}	O
}	O
static	O
term_underline_t	O
style_compute_text_underline_value	function
(	O
const	O
CRXStyle	struct
*	O
style	pointer
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
style	pointer
==	O
NULL	O
)	O
return	O
UNDERLINE_DEFAULT	O
;	O
switch	O
(	O
style	pointer
->	O
text_decoration	enum
)	O
{	O
case	O
TEXT_DECORATION_INHERIT	int
:	O
style	pointer
=	O
style	pointer
->	O
parent_style	pointer
;	O
break	O
;	O
case	O
TEXT_DECORATION_NONE	int
:	O
case	O
TEXT_DECORATION_OVERLINE	int
:	O
case	O
TEXT_DECORATION_LINE_THROUGH	int
:	O
case	O
TEXT_DECORATION_BLINK	int
:	O
return	O
UNDERLINE_OFF	O
;	O
case	O
TEXT_DECORATION_UNDERLINE	int
:	O
return	O
UNDERLINE_ON	O
;	O
default	O
:	O
abort	O
(	O
)	O
;	O
}	O
}	O
}	O
static	O
attributes_t	O
*	O
match	function
(	O
term_styled_ostream_t	O
stream	int
)	O
{	O
xmlNodePtr	O
root	O
;	O
xmlNodePtr	O
curr	O
;	O
char	O
*	O
p_end	pointer
;	O
char	O
*	O
p_start	pointer
;	O
CRXStyle	struct
*	O
curr_style	pointer
;	O
CRStyle	O
*	O
curr_style_base	O
;	O
attributes_t	O
*	O
attr	O
;	O
root	O
=	O
xmlNewNode	O
(	O
NULL	O
,	O
(	O
const	O
xmlChar	O
*	O
)	O
"__root__"	pointer
)	O
;	O
root	O
->	O
type	O
=	O
XML_ELEMENT_NODE	O
;	O
curr	O
=	O
root	O
;	O
p_end	pointer
=	O
&	O
stream	int
->	O
curr_classes	O
[	O
stream	int
->	O
curr_classes_length	O
]	O
;	O
p_start	pointer
=	O
stream	int
->	O
curr_classes	O
;	O
while	O
(	O
p_start	pointer
<	O
p_end	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
xmlNodePtr	O
child	O
;	O
if	O
(	O
!	O
(	O
*	O
p_start	pointer
==	O
' '	O
)	O
)	O
abort	O
(	O
)	O
;	O
p_start	pointer
++	O
;	O
for	O
(	O
p	pointer
=	O
p_start	pointer
;	O
p	pointer
<	O
p_end	pointer
&&	O
*	O
p	pointer
!=	O
' '	O
;	O
p	pointer
++	O
)	O
;	O
*	O
p	pointer
=	O
'\0'	O
;	O
child	O
=	O
xmlNewNode	O
(	O
NULL	O
,	O
(	O
const	O
xmlChar	O
*	O
)	O
p_start	pointer
)	O
;	O
child	O
->	O
type	O
=	O
XML_ELEMENT_NODE	O
;	O
xmlSetProp	O
(	O
child	O
,	O
(	O
const	O
xmlChar	O
*	O
)	O
"class"	pointer
,	O
(	O
const	O
xmlChar	O
*	O
)	O
p_start	pointer
)	O
;	O
*	O
p	pointer
=	O
' '	O
;	O
if	O
(	O
xmlAddChild	O
(	O
curr	O
,	O
child	O
)	O
==	O
NULL	O
)	O
abort	O
(	O
)	O
;	O
curr	O
=	O
child	O
;	O
p_start	pointer
=	O
p	pointer
;	O
}	O
curr_style	pointer
=	O
NULL	O
;	O
for	O
(	O
curr	O
=	O
root	O
;	O
curr	O
!=	O
NULL	O
;	O
curr	O
=	O
curr	O
->	O
children	O
)	O
{	O
CRXStyle	struct
*	O
parent_style	pointer
=	O
curr_style	pointer
;	O
curr_style	pointer
=	O
NULL	O
;	O
if	O
(	O
crx_sel_eng_get_matched_style	function
(	O
stream	int
->	O
css_engine	O
,	O
stream	int
->	O
css_document	O
,	O
curr	O
,	O
parent_style	pointer
,	O
&	O
curr_style	pointer
,	O
FALSE	O
)	O
!=	O
CR_OK	O
)	O
abort	O
(	O
)	O
;	O
if	O
(	O
curr_style	pointer
==	O
NULL	O
)	O
curr_style	pointer
=	O
parent_style	pointer
;	O
else	O
;	O
}	O
curr_style_base	O
=	O
(	O
curr_style	pointer
!=	O
NULL	O
?	O
curr_style	pointer
->	O
base	pointer
:	O
NULL	O
)	O
;	O
attr	O
=	O
XMALLOC	function
(	O
attributes_t	O
)	O
;	O
attr	O
->	O
color	O
=	O
style_compute_color_value	function
(	O
curr_style_base	O
,	O
RGB_PROP_COLOR	O
,	O
stream	int
->	O
destination	O
)	O
;	O
attr	O
->	O
bgcolor	O
=	O
style_compute_color_value	function
(	O
curr_style_base	O
,	O
RGB_PROP_BACKGROUND_COLOR	O
,	O
stream	int
->	O
destination	O
)	O
;	O
attr	O
->	O
weight	O
=	O
style_compute_font_weight_value	function
(	O
curr_style_base	O
)	O
;	O
attr	O
->	O
posture	O
=	O
style_compute_font_posture_value	function
(	O
curr_style_base	O
)	O
;	O
attr	O
->	O
underline	O
=	O
style_compute_text_underline_value	function
(	O
curr_style	pointer
)	O
;	O
while	O
(	O
curr_style	pointer
!=	O
NULL	O
)	O
{	O
CRXStyle	struct
*	O
parent_style	pointer
=	O
curr_style	pointer
->	O
parent_style	pointer
;	O
crx_style_destroy	function
(	O
curr_style	pointer
)	O
;	O
curr_style	pointer
=	O
parent_style	pointer
;	O
}	O
xmlFreeNodeList	O
(	O
root	O
)	O
;	O
return	O
attr	O
;	O
}	O
static	O
void	O
match_and_cache	function
(	O
term_styled_ostream_t	O
stream	int
)	O
{	O
attributes_t	O
*	O
attr	O
=	O
match	function
(	O
stream	int
)	O
;	O
if	O
(	O
hash_insert_entry	O
(	O
&	O
stream	int
->	O
cache	O
,	O
stream	int
->	O
curr_classes	O
,	O
stream	int
->	O
curr_classes_length	O
,	O
attr	O
)	O
==	O
NULL	O
)	O
abort	O
(	O
)	O
;	O
stream	int
->	O
curr_attr	O
=	O
attr	O
;	O
}	O
static	O
void	O
term_styled_ostream__begin_use_class	function
(	O
term_styled_ostream_t	O
stream	int
,	O
const	O
char	O
*	O
classname	pointer
)	O
{	O
size_t	O
classname_len	O
;	O
char	O
*	O
p	pointer
;	O
void	O
*	O
found	pointer
;	O
if	O
(	O
classname	pointer
[	O
0	int
]	O
==	O
'\0'	O
||	O
strchr	O
(	O
classname	pointer
,	O
' '	O
)	O
!=	O
NULL	O
)	O
abort	O
(	O
)	O
;	O
classname_len	O
=	O
strlen	O
(	O
classname	pointer
)	O
;	O
if	O
(	O
stream	int
->	O
curr_classes_length	O
+	O
1	int
+	O
classname_len	O
+	O
1	int
>	O
stream	int
->	O
curr_classes_allocated	O
)	O
{	O
size_t	O
new_allocated	O
=	O
stream	int
->	O
curr_classes_length	O
+	O
1	int
+	O
classname_len	O
+	O
1	int
;	O
if	O
(	O
new_allocated	O
<	O
2	int
*	O
stream	int
->	O
curr_classes_allocated	O
)	O
new_allocated	O
=	O
2	int
*	O
stream	int
->	O
curr_classes_allocated	O
;	O
stream	int
->	O
curr_classes	O
=	O
xrealloc	O
(	O
stream	int
->	O
curr_classes	O
,	O
new_allocated	O
)	O
;	O
stream	int
->	O
curr_classes_allocated	O
=	O
new_allocated	O
;	O
}	O
p	pointer
=	O
&	O
stream	int
->	O
curr_classes	O
[	O
stream	int
->	O
curr_classes_length	O
]	O
;	O
*	O
p	pointer
++	O
=	O
' '	O
;	O
memcpy	O
(	O
p	pointer
,	O
classname	pointer
,	O
classname_len	O
)	O
;	O
stream	int
->	O
curr_classes_length	O
+=	O
1	int
+	O
classname_len	O
;	O
if	O
(	O
hash_find_entry	O
(	O
&	O
stream	int
->	O
cache	O
,	O
stream	int
->	O
curr_classes	O
,	O
stream	int
->	O
curr_classes_length	O
,	O
&	O
found	pointer
)	O
<	O
0	int
)	O
match_and_cache	function
(	O
stream	int
)	O
;	O
else	O
stream	int
->	O
curr_attr	O
=	O
(	O
attributes_t	O
*	O
)	O
found	pointer
;	O
}	O
static	O
void	O
term_styled_ostream__end_use_class	function
(	O
term_styled_ostream_t	O
stream	int
,	O
const	O
char	O
*	O
classname	pointer
)	O
{	O
char	O
*	O
p_end	pointer
;	O
char	O
*	O
p_start	pointer
;	O
char	O
*	O
p	pointer
;	O
void	O
*	O
found	pointer
;	O
if	O
(	O
stream	int
->	O
curr_classes_length	O
==	O
0	int
)	O
abort	O
(	O
)	O
;	O
p_end	pointer
=	O
&	O
stream	int
->	O
curr_classes	O
[	O
stream	int
->	O
curr_classes_length	O
]	O
;	O
p	pointer
=	O
p_end	pointer
;	O
while	O
(	O
*	O
--	O
p	pointer
!=	O
' '	O
)	O
;	O
p_start	pointer
=	O
p	pointer
+	O
1	int
;	O
if	O
(	O
!	O
(	O
p_end	pointer
-	O
p_start	pointer
==	O
strlen	O
(	O
classname	pointer
)	O
&&	O
memcmp	O
(	O
p_start	pointer
,	O
classname	pointer
,	O
p_end	pointer
-	O
p_start	pointer
)	O
==	O
0	int
)	O
)	O
abort	O
(	O
)	O
;	O
stream	int
->	O
curr_classes_length	O
=	O
p	pointer
-	O
stream	int
->	O
curr_classes	O
;	O
if	O
(	O
hash_find_entry	O
(	O
&	O
stream	int
->	O
cache	O
,	O
stream	int
->	O
curr_classes	O
,	O
stream	int
->	O
curr_classes_length	O
,	O
&	O
found	pointer
)	O
<	O
0	int
)	O
abort	O
(	O
)	O
;	O
stream	int
->	O
curr_attr	O
=	O
(	O
attributes_t	O
*	O
)	O
found	pointer
;	O
}	O
static	O
void	O
term_styled_ostream__flush_to_current_style	function
(	O
term_styled_ostream_t	O
stream	int
)	O
{	O
term_ostream_set_color	function
(	O
stream	int
->	O
destination	O
,	O
stream	int
->	O
curr_attr	O
->	O
color	O
)	O
;	O
term_ostream_set_bgcolor	function
(	O
stream	int
->	O
destination	O
,	O
stream	int
->	O
curr_attr	O
->	O
bgcolor	O
)	O
;	O
term_ostream_set_weight	function
(	O
stream	int
->	O
destination	O
,	O
stream	int
->	O
curr_attr	O
->	O
weight	O
)	O
;	O
term_ostream_set_posture	function
(	O
stream	int
->	O
destination	O
,	O
stream	int
->	O
curr_attr	O
->	O
posture	O
)	O
;	O
term_ostream_set_underline	function
(	O
stream	int
->	O
destination	O
,	O
stream	int
->	O
curr_attr	O
->	O
underline	O
)	O
;	O
term_ostream_flush_to_current_style	function
(	O
stream	int
->	O
destination	O
)	O
;	O
}	O
term_styled_ostream_t	O
term_styled_ostream_create	function
(	O
int	O
fd	int
,	O
const	O
char	O
*	O
filename	pointer
,	O
ttyctl_t	O
tty_control	int
,	O
const	O
char	O
*	O
css_filename	pointer
)	O
{	O
term_styled_ostream_t	O
stream	int
;	O
CRStyleSheet	O
*	O
css_file_contents	O
;	O
if	O
(	O
css_filename	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
stream	int
=	O
XMALLOC	function
(	O
struct	O
term_styled_ostream_representation	O
)	O
;	O
stream	int
->	O
base	pointer
.	O
base	pointer
.	O
vtable	pointer
=	O
&	O
term_styled_ostream_vtable	O
;	O
stream	int
->	O
destination	O
=	O
term_ostream_create	function
(	O
fd	int
,	O
filename	pointer
,	O
tty_control	int
)	O
;	O
if	O
(	O
cr_om_parser_simply_parse_file	O
(	O
(	O
const	O
guchar	O
*	O
)	O
css_filename	pointer
,	O
CR_UTF_8	O
,	O
&	O
css_file_contents	O
)	O
!=	O
CR_OK	O
)	O
{	O
term_ostream_free	function
(	O
stream	int
->	O
destination	O
)	O
;	O
free	function
(	O
stream	int
)	O
;	O
return	O
NULL	O
;	O
}	O
stream	int
->	O
css_document	O
=	O
cr_cascade_new	O
(	O
NULL	O
,	O
css_file_contents	O
,	O
NULL	O
)	O
;	O
stream	int
->	O
css_engine	O
=	O
cr_sel_eng_new	O
(	O
)	O
;	O
stream	int
->	O
curr_classes_allocated	O
=	O
60	int
;	O
stream	int
->	O
curr_classes	O
=	O
XNMALLOC	function
(	O
stream	int
->	O
curr_classes_allocated	O
,	O
char	O
)	O
;	O
stream	int
->	O
curr_classes_length	O
=	O
0	int
;	O
hash_init	O
(	O
&	O
stream	int
->	O
cache	O
,	O
10	int
)	O
;	O
match_and_cache	function
(	O
stream	int
)	O
;	O
return	O
stream	int
;	O
}	O
const	O
struct	O
term_styled_ostream_implementation	O
term_styled_ostream_vtable	O
=	O
{	O
term_styled_ostream_superclasses	array
,	O
sizeof	O
(	O
term_styled_ostream_superclasses	array
)	O
/	O
sizeof	O
(	O
term_styled_ostream_superclasses	array
[	O
0	int
]	O
)	O
,	O
sizeof	O
(	O
struct	O
term_styled_ostream_representation	O
)	O
,	O
term_styled_ostream__write_mem	function
,	O
term_styled_ostream__flush	function
,	O
term_styled_ostream__free	function
,	O
term_styled_ostream__begin_use_class	function
,	O
term_styled_ostream__end_use_class	function
,	O
term_styled_ostream__flush_to_current_style	function
,	O
}	O
;	O
void	O
term_styled_ostream_write_mem	function
(	O
term_styled_ostream_t	O
first_arg	int
,	O
const	O
void	O
*	O
data	pointer
,	O
size_t	O
len	int
)	O
{	O
const	O
struct	O
term_styled_ostream_implementation	O
*	O
vtable	pointer
=	O
(	O
(	O
struct	O
term_styled_ostream_representation_header	O
*	O
)	O
(	O
struct	O
term_styled_ostream_representation	O
*	O
)	O
first_arg	int
)	O
->	O
vtable	pointer
;	O
vtable	pointer
->	O
write_mem	O
(	O
first_arg	int
,	O
data	pointer
,	O
len	int
)	O
;	O
}	O
void	O
term_styled_ostream_flush	function
(	O
term_styled_ostream_t	O
first_arg	int
,	O
ostream_flush_scope_t	O
scope	int
)	O
{	O
const	O
struct	O
term_styled_ostream_implementation	O
*	O
vtable	pointer
=	O
(	O
(	O
struct	O
term_styled_ostream_representation_header	O
*	O
)	O
(	O
struct	O
term_styled_ostream_representation	O
*	O
)	O
first_arg	int
)	O
->	O
vtable	pointer
;	O
vtable	pointer
->	O
flush	O
(	O
first_arg	int
,	O
scope	int
)	O
;	O
}	O
void	O
term_styled_ostream_free	function
(	O
term_styled_ostream_t	O
first_arg	int
)	O
{	O
const	O
struct	O
term_styled_ostream_implementation	O
*	O
vtable	pointer
=	O
(	O
(	O
struct	O
term_styled_ostream_representation_header	O
*	O
)	O
(	O
struct	O
term_styled_ostream_representation	O
*	O
)	O
first_arg	int
)	O
->	O
vtable	pointer
;	O
vtable	pointer
->	O
free	function
(	O
first_arg	int
)	O
;	O
}	O
void	O
term_styled_ostream_begin_use_class	function
(	O
term_styled_ostream_t	O
first_arg	int
,	O
const	O
char	O
*	O
classname	pointer
)	O
{	O
const	O
struct	O
term_styled_ostream_implementation	O
*	O
vtable	pointer
=	O
(	O
(	O
struct	O
term_styled_ostream_representation_header	O
*	O
)	O
(	O
struct	O
term_styled_ostream_representation	O
*	O
)	O
first_arg	int
)	O
->	O
vtable	pointer
;	O
vtable	pointer
->	O
begin_use_class	O
(	O
first_arg	int
,	O
classname	pointer
)	O
;	O
}	O
void	O
term_styled_ostream_end_use_class	function
(	O
term_styled_ostream_t	O
first_arg	int
,	O
const	O
char	O
*	O
classname	pointer
)	O
{	O
const	O
struct	O
term_styled_ostream_implementation	O
*	O
vtable	pointer
=	O
(	O
(	O
struct	O
term_styled_ostream_representation_header	O
*	O
)	O
(	O
struct	O
term_styled_ostream_representation	O
*	O
)	O
first_arg	int
)	O
->	O
vtable	pointer
;	O
vtable	pointer
->	O
end_use_class	O
(	O
first_arg	int
,	O
classname	pointer
)	O
;	O
}	O
void	O
term_styled_ostream_flush_to_current_style	function
(	O
term_styled_ostream_t	O
first_arg	int
)	O
{	O
const	O
struct	O
term_styled_ostream_implementation	O
*	O
vtable	pointer
=	O
(	O
(	O
struct	O
term_styled_ostream_representation_header	O
*	O
)	O
(	O
struct	O
term_styled_ostream_representation	O
*	O
)	O
first_arg	int
)	O
->	O
vtable	pointer
;	O
vtable	pointer
->	O
flush_to_current_style	O
(	O
first_arg	int
)	O
;	O
}	O
