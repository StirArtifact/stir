static	O
unsigned	O
int	O
cur_ver	int
=	O
0	int
;	O
static	O
void	O
dwg_geojson_feature	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
const	O
char	O
*	O
restrict	O
subclass	pointer
)	O
{	O
int	O
error	int
;	O
char	O
*	O
name	pointer
;	O
char	O
tmp	array
[	O
64	int
]	O
;	O
PAIR_S	O
(	O
type	short
,	O
"Feature"	pointer
)	O
;	O
KEY	O
(	O
properties	O
)	O
;	O
SAMEHASH	O
;	O
PAIR_S	O
(	O
SubClasses	O
,	O
subclass	pointer
)	O
;	O
if	O
(	O
obj	pointer
->	O
supertype	enum
==	O
DWG_SUPERTYPE_ENTITY	int
)	O
{	O
Dwg_Object	struct
*	O
layer	int
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
layer	int
?	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
layer	int
->	O
obj	pointer
:	O
NULL	O
;	O
if	O
(	O
layer	int
&&	O
(	O
layer	int
->	O
type	short
==	O
DWG_TYPE_LAYER	int
||	O
layer	int
->	O
type	short
==	O
DWG_TYPE_DICTIONARY	int
)	O
)	O
{	O
name	pointer
=	O
dwg_obj_table_get_name	function
(	O
layer	int
,	O
&	O
error	int
)	O
;	O
if	O
(	O
!	O
error	int
)	O
{	O
PAIR_S	O
(	O
Layer	O
,	O
name	pointer
)	O
;	O
if	O
(	O
dat	pointer
->	O
version	short
>=	O
R_2007	int
)	O
free	function
(	O
name	pointer
)	O
;	O
}	O
}	O
if	O
(	O
dat	pointer
->	O
version	short
>=	O
R_2004	int
)	O
{	O
sprintf	function
(	O
tmp	array
,	O
"%06X"	pointer
,	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
color	short
.	O
rgb	int
&	O
0xffffff	int
)	O
;	O
PAIR_S	O
(	O
color	short
,	O
tmp	array
)	O
;	O
}	O
else	O
{	O
PAIR_D	O
(	O
color	short
,	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
color	short
.	O
index	short
)	O
;	O
}	O
name	pointer
=	O
dwg_ent_get_ltype_name	function
(	O
obj	pointer
->	O
tio	union
.	O
entity	long
,	O
&	O
error	int
)	O
;	O
if	O
(	O
!	O
error	int
&&	O
strNE	O
(	O
name	pointer
,	O
"ByLayer"	pointer
)	O
)	O
{	O
PAIR_S	O
(	O
Linetype	O
,	O
name	pointer
)	O
;	O
if	O
(	O
dat	pointer
->	O
version	short
>=	O
R_2007	int
)	O
free	function
(	O
name	pointer
)	O
;	O
}	O
}	O
sprintf	function
(	O
tmp	array
,	O
"%lX"	pointer
,	O
obj	pointer
->	O
handle	pointer
.	O
value	double
)	O
;	O
if	O
(	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_GEOPOSITIONMARKER	int
)	O
{	O
Dwg_Entity_GEOPOSITIONMARKER	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
GEOPOSITIONMARKER	pointer
;	O
PAIR_S	O
(	O
Text	O
,	O
_obj	pointer
->	O
text	pointer
)	O
}	O
else	O
if	O
(	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_TEXT	int
)	O
{	O
Dwg_Entity_TEXT	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
TEXT	pointer
;	O
PAIR_S	O
(	O
Text	O
,	O
_obj	pointer
->	O
text_value	pointer
)	O
}	O
else	O
if	O
(	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_MTEXT	int
)	O
{	O
Dwg_Entity_MTEXT	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
MTEXT	pointer
;	O
PAIR_S	O
(	O
Text	O
,	O
_obj	pointer
->	O
text	pointer
)	O
}	O
else	O
if	O
(	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_INSERT	int
)	O
{	O
Dwg_Entity_INSERT	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
INSERT	pointer
;	O
Dwg_Object	struct
*	O
hdr	pointer
=	O
dwg_ref_get_object	function
(	O
_obj	pointer
->	O
block_header	pointer
,	O
&	O
error	int
)	O
;	O
if	O
(	O
!	O
error	int
&&	O
hdr	pointer
&&	O
hdr	pointer
->	O
type	short
==	O
DWG_TYPE_BLOCK_HEADER	int
)	O
{	O
Dwg_Object_BLOCK_HEADER	struct
*	O
_hdr	pointer
=	O
hdr	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
BLOCK_HEADER	pointer
;	O
char	O
*	O
text	pointer
;	O
if	O
(	O
dat	pointer
->	O
version	short
>=	O
R_2007	int
)	O
text	pointer
=	O
bit_convert_TU	function
(	O
(	O
BITCODE_TU	pointer
)	O
_hdr	pointer
->	O
name	pointer
)	O
;	O
else	O
text	pointer
=	O
_hdr	pointer
->	O
name	pointer
;	O
if	O
(	O
text	pointer
)	O
{	O
PAIR_S	O
(	O
name	pointer
,	O
text	pointer
)	O
;	O
if	O
(	O
dat	pointer
->	O
version	short
>=	O
R_2007	int
)	O
free	function
(	O
text	pointer
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_MINSERT	int
)	O
{	O
Dwg_Entity_MINSERT	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
MINSERT	pointer
;	O
Dwg_Object	struct
*	O
hdr	pointer
=	O
dwg_ref_get_object	function
(	O
_obj	pointer
->	O
block_header	pointer
,	O
&	O
error	int
)	O
;	O
if	O
(	O
!	O
error	int
&&	O
hdr	pointer
&&	O
hdr	pointer
->	O
type	short
==	O
DWG_TYPE_BLOCK_HEADER	int
)	O
{	O
Dwg_Object_BLOCK_HEADER	struct
*	O
_hdr	pointer
=	O
hdr	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
BLOCK_HEADER	pointer
;	O
char	O
*	O
text	pointer
;	O
if	O
(	O
dat	pointer
->	O
version	short
>=	O
R_2007	int
)	O
text	pointer
=	O
bit_convert_TU	function
(	O
(	O
BITCODE_TU	pointer
)	O
_hdr	pointer
->	O
name	pointer
)	O
;	O
else	O
text	pointer
=	O
_hdr	pointer
->	O
name	pointer
;	O
if	O
(	O
text	pointer
)	O
{	O
PAIR_S	O
(	O
name	pointer
,	O
text	pointer
)	O
;	O
if	O
(	O
dat	pointer
->	O
version	short
>=	O
R_2007	int
)	O
free	function
(	O
text	pointer
)	O
;	O
}	O
}	O
}	O
LASTPAIR_S	O
(	O
EntityHandle	O
,	O
tmp	array
)	O
;	O
ENDHASH	O
;	O
}	O
static	O
int	O
dwg_geojson_LWPOLYLINE	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
BITCODE_BL	int
j	int
,	O
last_j	int
;	O
Dwg_Entity_LWPOLYLINE	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
LWPOLYLINE	pointer
;	O
last_j	int
=	O
_obj	pointer
->	O
num_points	int
-	O
1	int
;	O
FEATURE	O
(	O
AcDbEntity	O
:	O
AcDbLwPolyline	O
,	O
obj	pointer
)	O
;	O
GEOMETRY	O
(	O
LineString	O
)	O
;	O
KEY	O
(	O
coordinates	O
)	O
;	O
ARRAY	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
last_j	int
;	O
j	int
++	O
)	O
{	O
FIELD_2DPOINT	O
(	O
points	pointer
[	O
j	int
]	O
)	O
;	O
}	O
LASTFIELD_2DPOINT	O
(	O
points	pointer
[	O
last_j	int
]	O
)	O
;	O
LASTENDARRAY	O
;	O
ENDGEOMETRY	O
;	O
ENDFEATURE	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
dwg_geojson_variable_type	function
(	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
int	O
i	int
;	O
char	O
*	O
dxfname	pointer
;	O
Dwg_Class	struct
*	O
klass	pointer
;	O
int	O
is_entity	int
;	O
i	int
=	O
obj	pointer
->	O
type	short
-	O
500	int
;	O
if	O
(	O
i	int
<	O
0	int
||	O
i	int
>=	O
(	O
int	O
)	O
dwg	pointer
->	O
num_classes	short
)	O
return	O
DWG_ERR_INVALIDTYPE	int
;	O
klass	pointer
=	O
&	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
;	O
if	O
(	O
!	O
klass	pointer
||	O
!	O
klass	pointer
->	O
dxfname	pointer
)	O
return	O
DWG_ERR_INTERNALERROR	int
;	O
dxfname	pointer
=	O
klass	pointer
->	O
dxfname	pointer
;	O
is_entity	int
=	O
dwg_class_is_entity	function
(	O
klass	pointer
)	O
;	O
if	O
(	O
strEQc	O
(	O
dxfname	pointer
,	O
"LWPOLYLINE"	pointer
)	O
)	O
{	O
return	O
dwg_geojson_LWPOLYLINE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
}	O
if	O
(	O
strEQc	O
(	O
dxfname	pointer
,	O
"GEODATA"	pointer
)	O
)	O
{	O
Dwg_Object_GEODATA	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
GEODATA	pointer
;	O
WARN_UNSTABLE_CLASS	O
;	O
FEATURE	O
(	O
AcDbObject	O
:	O
AcDbGeoData	O
,	O
obj	pointer
)	O
;	O
ENDFEATURE	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
strEQc	O
(	O
dxfname	pointer
,	O
"GEOPOSITIONMARKER"	pointer
)	O
)	O
{	O
Dwg_Entity_GEOPOSITIONMARKER	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
GEOPOSITIONMARKER	pointer
;	O
WARN_UNSTABLE_CLASS	O
;	O
FEATURE	O
(	O
AcDbEntity	O
:	O
AcDbGeoPositionMarker	O
,	O
obj	pointer
)	O
;	O
GEOMETRY	O
(	O
Point	O
)	O
;	O
KEY	O
(	O
coordinates	O
)	O
;	O
if	O
(	O
fabs	function
(	O
_obj	pointer
->	O
position	struct
.	O
z	double
)	O
>	O
0.000001	int
)	O
{	O
VALUE_3DPOINT	O
(	O
_obj	pointer
->	O
position	struct
.	O
x	double
,	O
_obj	pointer
->	O
position	struct
.	O
y	double
,	O
_obj	pointer
->	O
position	struct
.	O
z	double
)	O
;	O
}	O
else	O
{	O
VALUE_2DPOINT	O
(	O
_obj	pointer
->	O
position	struct
.	O
x	double
,	O
_obj	pointer
->	O
position	struct
.	O
y	double
)	O
;	O
}	O
ENDGEOMETRY	O
;	O
ENDFEATURE	O
;	O
return	O
0	int
;	O
}	O
return	O
DWG_ERR_UNHANDLEDCLASS	int
;	O
}	O
static	O
void	O
dwg_geojson_object	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
switch	O
(	O
obj	pointer
->	O
type	short
)	O
{	O
case	O
DWG_TYPE_INSERT	int
:	O
{	O
Dwg_Entity_INSERT	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
INSERT	pointer
;	O
FEATURE	O
(	O
AcDbEntity	O
:	O
AcDbBlockReference	O
,	O
obj	pointer
)	O
;	O
GEOMETRY	O
(	O
Point	O
)	O
;	O
KEY	O
(	O
coordinates	O
)	O
;	O
ARRAY	O
;	O
LASTFIELD_3DPOINT	O
(	O
ins_pt	struct
)	O
;	O
LASTENDARRAY	O
;	O
ENDGEOMETRY	O
;	O
ENDFEATURE	O
;	O
}	O
break	O
;	O
case	O
DWG_TYPE_MINSERT	int
:	O
LOG_TRACE	O
(	O
"MINSERT not yet supported"	pointer
)	O
break	O
;	O
case	O
DWG_TYPE_POLYLINE_2D	int
:	O
{	O
int	O
error	int
;	O
BITCODE_BL	int
j	int
,	O
numpts	int
;	O
dwg_point_2d	struct
*	O
pts	pointer
;	O
FEATURE	O
(	O
AcDbEntity	O
:	O
AcDbPolyline	O
,	O
obj	pointer
)	O
;	O
GEOMETRY	O
(	O
MultiLineString	O
)	O
;	O
KEY	O
(	O
coordinates	O
)	O
;	O
ARRAY	O
;	O
numpts	int
=	O
dwg_object_polyline_2d_get_numpoints	function
(	O
obj	pointer
,	O
&	O
error	int
)	O
;	O
pts	pointer
=	O
dwg_object_polyline_2d_get_points	function
(	O
obj	pointer
,	O
&	O
error	int
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
numpts	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
j	int
==	O
numpts	int
-	O
1	int
)	O
{	O
LASTVALUE_2DPOINT	O
(	O
pts	pointer
[	O
j	int
]	O
.	O
x	double
,	O
pts	pointer
[	O
j	int
]	O
.	O
y	double
)	O
;	O
}	O
else	O
{	O
VALUE_2DPOINT	O
(	O
pts	pointer
[	O
j	int
]	O
.	O
x	double
,	O
pts	pointer
[	O
j	int
]	O
.	O
y	double
)	O
;	O
}	O
}	O
free	function
(	O
pts	pointer
)	O
;	O
LASTENDARRAY	O
;	O
ENDGEOMETRY	O
;	O
ENDFEATURE	O
;	O
}	O
break	O
;	O
case	O
DWG_TYPE_POLYLINE_3D	int
:	O
{	O
int	O
error	int
;	O
BITCODE_BL	int
j	int
,	O
numpts	int
;	O
dwg_point_3d	struct
*	O
pts	pointer
;	O
FEATURE	O
(	O
AcDbEntity	O
:	O
AcDbPolyline	O
,	O
obj	pointer
)	O
;	O
GEOMETRY	O
(	O
MultiLineString	O
)	O
;	O
KEY	O
(	O
coordinates	O
)	O
;	O
ARRAY	O
;	O
numpts	int
=	O
dwg_object_polyline_3d_get_numpoints	function
(	O
obj	pointer
,	O
&	O
error	int
)	O
;	O
pts	pointer
=	O
dwg_object_polyline_3d_get_points	function
(	O
obj	pointer
,	O
&	O
error	int
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
numpts	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
j	int
==	O
numpts	int
-	O
1	int
)	O
{	O
LASTVALUE_3DPOINT	O
(	O
pts	pointer
[	O
j	int
]	O
.	O
x	double
,	O
pts	pointer
[	O
j	int
]	O
.	O
y	double
,	O
pts	pointer
[	O
j	int
]	O
.	O
z	double
)	O
;	O
}	O
else	O
{	O
VALUE_3DPOINT	O
(	O
pts	pointer
[	O
j	int
]	O
.	O
x	double
,	O
pts	pointer
[	O
j	int
]	O
.	O
y	double
,	O
pts	pointer
[	O
j	int
]	O
.	O
z	double
)	O
;	O
}	O
}	O
free	function
(	O
pts	pointer
)	O
;	O
LASTENDARRAY	O
;	O
ENDGEOMETRY	O
;	O
ENDFEATURE	O
;	O
}	O
break	O
;	O
case	O
DWG_TYPE_ARC	int
:	O
LOG_TRACE	O
(	O
"ARC not yet supported"	pointer
)	O
break	O
;	O
case	O
DWG_TYPE_CIRCLE	int
:	O
LOG_TRACE	O
(	O
"CIRCLE not yet supported"	pointer
)	O
break	O
;	O
case	O
DWG_TYPE_LINE	int
:	O
{	O
Dwg_Entity_LINE	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
LINE	pointer
;	O
FEATURE	O
(	O
AcDbEntity	O
:	O
AcDbLine	O
,	O
obj	pointer
)	O
;	O
GEOMETRY	O
(	O
LineString	O
)	O
;	O
KEY	O
(	O
coordinates	O
)	O
;	O
ARRAY	O
;	O
FIELD_3DPOINT	O
(	O
start	struct
)	O
;	O
LASTFIELD_3DPOINT	O
(	O
end	struct
)	O
;	O
LASTENDARRAY	O
;	O
ENDGEOMETRY	O
;	O
ENDFEATURE	O
;	O
}	O
break	O
;	O
case	O
DWG_TYPE_POINT	int
:	O
{	O
Dwg_Entity_POINT	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
POINT	pointer
;	O
FEATURE	O
(	O
AcDbEntity	O
:	O
AcDbPoint	O
,	O
obj	pointer
)	O
;	O
GEOMETRY	O
(	O
Point	O
)	O
;	O
KEY	O
(	O
coordinates	O
)	O
;	O
if	O
(	O
fabs	function
(	O
_obj	pointer
->	O
z	double
)	O
>	O
0.000001	int
)	O
{	O
LASTVALUE_3DPOINT	O
(	O
_obj	pointer
->	O
x	double
,	O
_obj	pointer
->	O
y	double
,	O
_obj	pointer
->	O
z	double
)	O
;	O
}	O
else	O
{	O
LASTVALUE_2DPOINT	O
(	O
_obj	pointer
->	O
x	double
,	O
_obj	pointer
->	O
y	double
)	O
;	O
}	O
ENDGEOMETRY	O
;	O
ENDFEATURE	O
;	O
}	O
break	O
;	O
case	O
DWG_TYPE__3DFACE	int
:	O
LOG_TRACE	O
(	O
"3DFACE not yet supported"	pointer
)	O
break	O
;	O
case	O
DWG_TYPE_POLYLINE_PFACE	int
:	O
LOG_TRACE	O
(	O
"POLYLINE_PFACE not yet supported"	pointer
)	O
break	O
;	O
case	O
DWG_TYPE_POLYLINE_MESH	int
:	O
LOG_TRACE	O
(	O
"POLYLINE_MESH not yet supported"	pointer
)	O
break	O
;	O
case	O
DWG_TYPE_SOLID	int
:	O
LOG_TRACE	O
(	O
"SOLID not yet supported"	pointer
)	O
break	O
;	O
case	O
DWG_TYPE_TRACE	int
:	O
LOG_TRACE	O
(	O
"TRACE not yet supported"	pointer
)	O
break	O
;	O
case	O
DWG_TYPE_ELLIPSE	int
:	O
LOG_TRACE	O
(	O
"ELLIPSE not yet supported"	pointer
)	O
break	O
;	O
case	O
DWG_TYPE_SPLINE	int
:	O
LOG_TRACE	O
(	O
"SPLINE not yet supported"	pointer
)	O
break	O
;	O
case	O
DWG_TYPE_HATCH	int
:	O
break	O
;	O
case	O
DWG_TYPE__3DSOLID	int
:	O
break	O
;	O
case	O
DWG_TYPE_REGION	int
:	O
break	O
;	O
case	O
DWG_TYPE_BODY	int
:	O
break	O
;	O
case	O
DWG_TYPE_RAY	int
:	O
LOG_TRACE	O
(	O
"RAY not yet supported"	pointer
)	O
break	O
;	O
case	O
DWG_TYPE_XLINE	int
:	O
LOG_TRACE	O
(	O
"XLINE not yet supported"	pointer
)	O
break	O
;	O
case	O
DWG_TYPE_TEXT	int
:	O
{	O
Dwg_Entity_TEXT	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
TEXT	pointer
;	O
FEATURE	O
(	O
AcDbEntity	O
:	O
AcDbText	O
,	O
obj	pointer
)	O
;	O
GEOMETRY	O
(	O
Point	O
)	O
;	O
KEY	O
(	O
coordinates	O
)	O
;	O
ARRAY	O
;	O
LASTFIELD_2DPOINT	O
(	O
insertion_pt	struct
)	O
;	O
LASTENDARRAY	O
;	O
ENDGEOMETRY	O
;	O
ENDFEATURE	O
;	O
}	O
break	O
;	O
case	O
DWG_TYPE_MTEXT	int
:	O
{	O
Dwg_Entity_MTEXT	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
MTEXT	pointer
;	O
FEATURE	O
(	O
AcDbEntity	O
:	O
AcDbMText	O
,	O
obj	pointer
)	O
;	O
GEOMETRY	O
(	O
Point	O
)	O
;	O
KEY	O
(	O
coordinates	O
)	O
;	O
ARRAY	O
;	O
LASTFIELD_3DPOINT	O
(	O
insertion_pt	struct
)	O
;	O
LASTENDARRAY	O
;	O
ENDGEOMETRY	O
;	O
ENDFEATURE	O
;	O
}	O
break	O
;	O
case	O
DWG_TYPE_MLINE	int
:	O
LOG_TRACE	O
(	O
"MLINE not yet supported"	pointer
)	O
break	O
;	O
case	O
DWG_TYPE_LWPOLYLINE	int
:	O
(	O
void	O
)	O
dwg_geojson_LWPOLYLINE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
obj	pointer
->	O
type	short
!=	O
obj	pointer
->	O
parent	pointer
->	O
layout_type	int
)	O
dwg_geojson_variable_type	function
(	O
obj	pointer
->	O
parent	pointer
,	O
dat	pointer
,	O
obj	pointer
)	O
;	O
}	O
}	O
static	O
int	O
geojson_entities_write	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
BITCODE_BL	int
i	int
;	O
SECTION	O
(	O
features	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dwg	pointer
->	O
num_objects	int
;	O
i	int
++	O
)	O
{	O
Dwg_Object	struct
*	O
obj	pointer
=	O
&	O
dwg	pointer
->	O
object	pointer
[	O
i	int
]	O
;	O
dwg_geojson_object	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
}	O
NOCOMMA	O
;	O
ENDSEC	O
(	O
)	O
;	O
return	O
0	int
;	O
}	O
EXPORT	O
int	O
dwg_write_geojson	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
char	O
date	struct
[	O
12	int
]	O
=	O
"YYYY-MM-DD"	pointer
;	O
time_t	long
rawtime	long
;	O
HASH	O
;	O
PAIR_S	O
(	O
type	short
,	O
"FeatureCollection"	pointer
)	O
;	O
if	O
(	O
geojson_entities_write	function
(	O
dat	pointer
,	O
dwg	pointer
)	O
)	O
goto	O
fail	O
;	O
KEY	O
(	O
geocoding	O
)	O
;	O
HASH	O
;	O
time	function
(	O
&	O
rawtime	long
)	O
;	O
strftime	function
(	O
date	struct
,	O
12	int
,	O
"%Y-%m-%d"	pointer
,	O
localtime	function
(	O
&	O
rawtime	long
)	O
)	O
;	O
PAIR_S	O
(	O
creation_date	O
,	O
date	struct
)	O
;	O
KEY	O
(	O
generator	O
)	O
;	O
HASH	O
;	O
KEY	O
(	O
author	O
)	O
;	O
HASH	O
;	O
LASTPAIR_S	O
(	O
name	pointer
,	O
"dwgread"	pointer
)	O
;	O
ENDHASH	O
;	O
PAIR_S	O
(	O
package	O
,	O
PACKAGE_NAME	pointer
)	O
;	O
LASTPAIR_S	O
(	O
version	short
,	O
PACKAGE_VERSION	pointer
)	O
;	O
LASTENDHASH	O
;	O
LASTENDHASH	O
;	O
LASTENDHASH	O
;	O
return	O
0	int
;	O
fail	O
:	O
return	O
1	int
;	O
}	O
