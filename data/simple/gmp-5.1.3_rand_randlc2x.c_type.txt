typedef	O
struct	O
{	O
mpz_t	array
_mp_seed	array
;	O
mpz_t	array
_mp_a	array
;	O
mp_size_t	long
_cn	long
;	O
mp_limb_t	long
_cp	array
[	O
LIMBS_PER_ULONG	int
]	O
;	O
unsigned	O
long	O
_mp_m2exp	long
;	O
}	O
gmp_rand_lc_struct	struct
;	O
static	O
unsigned	O
long	O
int	O
lc	function
(	O
mp_ptr	pointer
rp	pointer
,	O
gmp_randstate_t	array
rstate	array
)	O
{	O
mp_ptr	pointer
tp	pointer
,	O
seedp	pointer
,	O
ap	pointer
;	O
mp_size_t	long
ta	long
;	O
mp_size_t	long
tn	long
,	O
seedn	long
,	O
an	long
;	O
unsigned	O
long	O
int	O
m2exp	long
;	O
unsigned	O
long	O
int	O
bits	int
;	O
int	O
cy	int
;	O
mp_size_t	long
xn	long
;	O
gmp_rand_lc_struct	struct
*	O
p	pointer
;	O
TMP_DECL	O
;	O
p	pointer
=	O
(	O
gmp_rand_lc_struct	struct
*	O
)	O
RNG_STATE	O
(	O
rstate	array
)	O
;	O
m2exp	long
=	O
p	pointer
->	O
_mp_m2exp	long
;	O
seedp	pointer
=	O
PTR	O
(	O
p	pointer
->	O
_mp_seed	array
)	O
;	O
seedn	long
=	O
SIZ	O
(	O
p	pointer
->	O
_mp_seed	array
)	O
;	O
ap	pointer
=	O
PTR	O
(	O
p	pointer
->	O
_mp_a	array
)	O
;	O
an	long
=	O
SIZ	O
(	O
p	pointer
->	O
_mp_a	array
)	O
;	O
TMP_MARK	O
;	O
ta	long
=	O
an	long
+	O
seedn	long
+	O
1	int
;	O
tn	long
=	O
BITS_TO_LIMBS	O
(	O
m2exp	long
)	O
;	O
if	O
(	O
ta	long
<=	O
tn	long
)	O
{	O
mp_size_t	long
tmp	long
=	O
an	long
+	O
seedn	long
;	O
ta	long
=	O
tn	long
+	O
1	int
;	O
tp	pointer
=	O
TMP_ALLOC_LIMBS	O
(	O
ta	long
)	O
;	O
MPN_ZERO	O
(	O
&	O
tp	pointer
[	O
tmp	long
]	O
,	O
ta	long
-	O
tmp	long
)	O
;	O
}	O
else	O
tp	pointer
=	O
TMP_ALLOC_LIMBS	O
(	O
ta	long
)	O
;	O
ASSERT	O
(	O
seedn	long
>=	O
an	long
&&	O
an	long
>	O
0	int
)	O
;	O
mpn_mul	O
(	O
tp	pointer
,	O
seedp	pointer
,	O
seedn	long
,	O
ap	pointer
,	O
an	long
)	O
;	O
ASSERT	O
(	O
tn	long
>=	O
p	pointer
->	O
_cn	long
)	O
;	O
__GMPN_ADD	O
(	O
cy	int
,	O
tp	pointer
,	O
tp	pointer
,	O
tn	long
,	O
p	pointer
->	O
_cp	array
,	O
p	pointer
->	O
_cn	long
)	O
;	O
tp	pointer
[	O
m2exp	long
/	O
GMP_NUMB_BITS	O
]	O
&=	O
(	O
CNST_LIMB	O
(	O
1	int
)	O
<<	O
m2exp	long
%	O
GMP_NUMB_BITS	O
)	O
-	O
1	int
;	O
MPN_COPY	O
(	O
PTR	O
(	O
p	pointer
->	O
_mp_seed	array
)	O
,	O
tp	pointer
,	O
tn	long
)	O
;	O
bits	int
=	O
m2exp	long
/	O
2	int
;	O
xn	long
=	O
bits	int
/	O
GMP_NUMB_BITS	O
;	O
tn	long
-=	O
xn	long
;	O
if	O
(	O
tn	long
>	O
0	int
)	O
{	O
unsigned	O
int	O
cnt	int
=	O
bits	int
%	O
GMP_NUMB_BITS	O
;	O
if	O
(	O
cnt	int
!=	O
0	int
)	O
{	O
mpn_rshift	O
(	O
tp	pointer
,	O
tp	pointer
+	O
xn	long
,	O
tn	long
,	O
cnt	int
)	O
;	O
MPN_COPY_INCR	O
(	O
rp	pointer
,	O
tp	pointer
,	O
xn	long
+	O
1	int
)	O
;	O
}	O
else	O
MPN_COPY_INCR	O
(	O
rp	pointer
,	O
tp	pointer
+	O
xn	long
,	O
tn	long
)	O
;	O
}	O
TMP_FREE	O
;	O
return	O
(	O
m2exp	long
+	O
1	int
)	O
/	O
2	int
;	O
}	O
static	O
void	O
randget_lc	function
(	O
gmp_randstate_t	array
rstate	array
,	O
mp_ptr	pointer
rp	pointer
,	O
unsigned	O
long	O
int	O
nbits	long
)	O
{	O
unsigned	O
long	O
int	O
rbitpos	long
;	O
int	O
chunk_nbits	int
;	O
mp_ptr	pointer
tp	pointer
;	O
mp_size_t	long
tn	long
;	O
gmp_rand_lc_struct	struct
*	O
p	pointer
;	O
TMP_DECL	O
;	O
p	pointer
=	O
(	O
gmp_rand_lc_struct	struct
*	O
)	O
RNG_STATE	O
(	O
rstate	array
)	O
;	O
TMP_MARK	O
;	O
chunk_nbits	int
=	O
p	pointer
->	O
_mp_m2exp	long
/	O
2	int
;	O
tn	long
=	O
BITS_TO_LIMBS	O
(	O
chunk_nbits	int
)	O
;	O
tp	pointer
=	O
TMP_ALLOC_LIMBS	O
(	O
tn	long
)	O
;	O
rbitpos	long
=	O
0	int
;	O
while	O
(	O
rbitpos	long
+	O
chunk_nbits	int
<=	O
nbits	long
)	O
{	O
mp_ptr	pointer
r2p	pointer
=	O
rp	pointer
+	O
rbitpos	long
/	O
GMP_NUMB_BITS	O
;	O
if	O
(	O
rbitpos	long
%	O
GMP_NUMB_BITS	O
!=	O
0	int
)	O
{	O
mp_limb_t	long
savelimb	long
,	O
rcy	long
;	O
lc	function
(	O
tp	pointer
,	O
rstate	array
)	O
;	O
savelimb	long
=	O
r2p	pointer
[	O
0	int
]	O
;	O
rcy	long
=	O
mpn_lshift	O
(	O
r2p	pointer
,	O
tp	pointer
,	O
tn	long
,	O
rbitpos	long
%	O
GMP_NUMB_BITS	O
)	O
;	O
r2p	pointer
[	O
0	int
]	O
|=	O
savelimb	long
;	O
if	O
(	O
(	O
chunk_nbits	int
%	O
GMP_NUMB_BITS	O
+	O
rbitpos	long
%	O
GMP_NUMB_BITS	O
)	O
>	O
GMP_NUMB_BITS	O
)	O
r2p	pointer
[	O
tn	long
]	O
=	O
rcy	long
;	O
}	O
else	O
{	O
lc	function
(	O
r2p	pointer
,	O
rstate	array
)	O
;	O
}	O
rbitpos	long
+=	O
chunk_nbits	int
;	O
}	O
if	O
(	O
rbitpos	long
!=	O
nbits	long
)	O
{	O
mp_ptr	pointer
r2p	pointer
=	O
rp	pointer
+	O
rbitpos	long
/	O
GMP_NUMB_BITS	O
;	O
int	O
last_nbits	int
=	O
nbits	long
-	O
rbitpos	long
;	O
tn	long
=	O
BITS_TO_LIMBS	O
(	O
last_nbits	int
)	O
;	O
lc	function
(	O
tp	pointer
,	O
rstate	array
)	O
;	O
if	O
(	O
rbitpos	long
%	O
GMP_NUMB_BITS	O
!=	O
0	int
)	O
{	O
mp_limb_t	long
savelimb	long
,	O
rcy	long
;	O
savelimb	long
=	O
r2p	pointer
[	O
0	int
]	O
;	O
rcy	long
=	O
mpn_lshift	O
(	O
r2p	pointer
,	O
tp	pointer
,	O
tn	long
,	O
rbitpos	long
%	O
GMP_NUMB_BITS	O
)	O
;	O
r2p	pointer
[	O
0	int
]	O
|=	O
savelimb	long
;	O
if	O
(	O
rbitpos	long
+	O
tn	long
*	O
GMP_NUMB_BITS	O
-	O
rbitpos	long
%	O
GMP_NUMB_BITS	O
<	O
nbits	long
)	O
r2p	pointer
[	O
tn	long
]	O
=	O
rcy	long
;	O
}	O
else	O
{	O
MPN_COPY	O
(	O
r2p	pointer
,	O
tp	pointer
,	O
tn	long
)	O
;	O
}	O
if	O
(	O
nbits	long
%	O
GMP_NUMB_BITS	O
!=	O
0	int
)	O
rp	pointer
[	O
nbits	long
/	O
GMP_NUMB_BITS	O
]	O
&=	O
~	O
(	O
~	O
CNST_LIMB	O
(	O
0	int
)	O
<<	O
nbits	long
%	O
GMP_NUMB_BITS	O
)	O
;	O
}	O
TMP_FREE	O
;	O
}	O
static	O
void	O
randseed_lc	function
(	O
gmp_randstate_t	array
rstate	array
,	O
mpz_srcptr	pointer
seed	pointer
)	O
{	O
gmp_rand_lc_struct	struct
*	O
p	pointer
=	O
(	O
gmp_rand_lc_struct	struct
*	O
)	O
RNG_STATE	O
(	O
rstate	array
)	O
;	O
mpz_ptr	pointer
seedz	pointer
=	O
p	pointer
->	O
_mp_seed	array
;	O
mp_size_t	long
seedn	long
=	O
BITS_TO_LIMBS	O
(	O
p	pointer
->	O
_mp_m2exp	long
)	O
;	O
mpz_fdiv_r_2exp	O
(	O
seedz	pointer
,	O
seed	pointer
,	O
p	pointer
->	O
_mp_m2exp	long
)	O
;	O
MPN_ZERO	O
(	O
&	O
PTR	O
(	O
seedz	pointer
)	O
[	O
SIZ	O
(	O
seedz	pointer
)	O
]	O
,	O
seedn	long
-	O
SIZ	O
(	O
seedz	pointer
)	O
)	O
;	O
SIZ	O
(	O
seedz	pointer
)	O
=	O
seedn	long
;	O
}	O
static	O
void	O
randclear_lc	function
(	O
gmp_randstate_t	array
rstate	array
)	O
{	O
gmp_rand_lc_struct	struct
*	O
p	pointer
=	O
(	O
gmp_rand_lc_struct	struct
*	O
)	O
RNG_STATE	O
(	O
rstate	array
)	O
;	O
mpz_clear	O
(	O
p	pointer
->	O
_mp_seed	array
)	O
;	O
mpz_clear	O
(	O
p	pointer
->	O
_mp_a	array
)	O
;	O
(	O
*	O
__gmp_free_func	pointer
)	O
(	O
p	pointer
,	O
sizeof	O
(	O
gmp_rand_lc_struct	struct
)	O
)	O
;	O
}	O
static	O
void	O
randiset_lc	function
(	O
gmp_randstate_ptr	pointer
,	O
gmp_randstate_srcptr	pointer
)	O
;	O
static	O
const	O
gmp_randfnptr_t	struct
Linear_Congruential_Generator	struct
=	O
{	O
randseed_lc	function
,	O
randget_lc	function
,	O
randclear_lc	function
,	O
randiset_lc	function
}	O
;	O
static	O
void	O
randiset_lc	function
(	O
gmp_randstate_ptr	pointer
dst	pointer
,	O
gmp_randstate_srcptr	pointer
src	pointer
)	O
{	O
gmp_rand_lc_struct	struct
*	O
dstp	pointer
,	O
*	O
srcp	pointer
;	O
srcp	pointer
=	O
(	O
gmp_rand_lc_struct	struct
*	O
)	O
RNG_STATE	O
(	O
src	pointer
)	O
;	O
dstp	pointer
=	O
(	O
gmp_rand_lc_struct	struct
*	O
)	O
(	O
*	O
__gmp_allocate_func	pointer
)	O
(	O
sizeof	O
(	O
gmp_rand_lc_struct	struct
)	O
)	O
;	O
RNG_STATE	O
(	O
dst	pointer
)	O
=	O
(	O
mp_limb_t	long
*	O
)	O
(	O
void	O
*	O
)	O
dstp	pointer
;	O
RNG_FNPTR	O
(	O
dst	pointer
)	O
=	O
(	O
void	O
*	O
)	O
&	O
Linear_Congruential_Generator	struct
;	O
mpz_init_set	O
(	O
dstp	pointer
->	O
_mp_seed	array
,	O
srcp	pointer
->	O
_mp_seed	array
)	O
;	O
mpz_init_set	O
(	O
dstp	pointer
->	O
_mp_a	array
,	O
srcp	pointer
->	O
_mp_a	array
)	O
;	O
dstp	pointer
->	O
_cn	long
=	O
srcp	pointer
->	O
_cn	long
;	O
dstp	pointer
->	O
_cp	array
[	O
0	int
]	O
=	O
srcp	pointer
->	O
_cp	array
[	O
0	int
]	O
;	O
if	O
(	O
LIMBS_PER_ULONG	int
>	O
1	int
)	O
dstp	pointer
->	O
_cp	array
[	O
1	int
]	O
=	O
srcp	pointer
->	O
_cp	array
[	O
1	int
]	O
;	O
if	O
(	O
LIMBS_PER_ULONG	int
>	O
2	int
)	O
MPN_COPY	O
(	O
dstp	pointer
->	O
_cp	array
+	O
2	int
,	O
srcp	pointer
->	O
_cp	array
+	O
2	int
,	O
LIMBS_PER_ULONG	int
-	O
2	int
)	O
;	O
dstp	pointer
->	O
_mp_m2exp	long
=	O
srcp	pointer
->	O
_mp_m2exp	long
;	O
}	O
void	O
gmp_randinit_lc_2exp	O
(	O
gmp_randstate_t	array
rstate	array
,	O
mpz_srcptr	pointer
a	int
,	O
unsigned	O
long	O
int	O
c	long
,	O
mp_bitcnt_t	long
m2exp	long
)	O
{	O
gmp_rand_lc_struct	struct
*	O
p	pointer
;	O
mp_size_t	long
seedn	long
=	O
BITS_TO_LIMBS	O
(	O
m2exp	long
)	O
;	O
ASSERT_ALWAYS	O
(	O
m2exp	long
!=	O
0	int
)	O
;	O
p	pointer
=	O
__GMP_ALLOCATE_FUNC_TYPE	O
(	O
1	int
,	O
gmp_rand_lc_struct	struct
)	O
;	O
RNG_STATE	O
(	O
rstate	array
)	O
=	O
(	O
mp_limb_t	long
*	O
)	O
(	O
void	O
*	O
)	O
p	pointer
;	O
RNG_FNPTR	O
(	O
rstate	array
)	O
=	O
(	O
void	O
*	O
)	O
&	O
Linear_Congruential_Generator	struct
;	O
mpz_init2	O
(	O
p	pointer
->	O
_mp_seed	array
,	O
m2exp	long
)	O
;	O
MPN_ZERO	O
(	O
PTR	O
(	O
p	pointer
->	O
_mp_seed	array
)	O
,	O
seedn	long
)	O
;	O
SIZ	O
(	O
p	pointer
->	O
_mp_seed	array
)	O
=	O
seedn	long
;	O
PTR	O
(	O
p	pointer
->	O
_mp_seed	array
)	O
[	O
0	int
]	O
=	O
1	int
;	O
mpz_init	O
(	O
p	pointer
->	O
_mp_a	array
)	O
;	O
mpz_fdiv_r_2exp	O
(	O
p	pointer
->	O
_mp_a	array
,	O
a	int
,	O
m2exp	long
)	O
;	O
if	O
(	O
SIZ	O
(	O
p	pointer
->	O
_mp_a	array
)	O
==	O
0	int
)	O
{	O
SIZ	O
(	O
p	pointer
->	O
_mp_a	array
)	O
=	O
1	int
;	O
PTR	O
(	O
p	pointer
->	O
_mp_a	array
)	O
[	O
0	int
]	O
=	O
CNST_LIMB	O
(	O
0	int
)	O
;	O
}	O
MPN_SET_UI	O
(	O
p	pointer
->	O
_cp	array
,	O
p	pointer
->	O
_cn	long
,	O
c	long
)	O
;	O
if	O
(	O
seedn	long
<	O
p	pointer
->	O
_cn	long
)	O
p	pointer
->	O
_cn	long
=	O
(	O
p	pointer
->	O
_cp	array
[	O
0	int
]	O
!=	O
0	int
)	O
;	O
p	pointer
->	O
_mp_m2exp	long
=	O
m2exp	long
;	O
}	O
