static	O
void	O
copyin_regular_file	function
(	O
struct	O
cpio_file_stat	struct
*	O
file_hdr	pointer
,	O
int	O
in_file_des	int
)	O
;	O
void	O
warn_junk_bytes	function
(	O
long	O
bytes_skipped	long
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
ngettext	function
(	O
"warning: skipped %ld byte of junk"	pointer
,	O
"warning: skipped %ld bytes of junk"	pointer
,	O
bytes_skipped	long
)	O
,	O
bytes_skipped	long
)	O
;	O
}	O
static	O
int	O
query_rename	function
(	O
struct	O
cpio_file_stat	struct
*	O
file_hdr	pointer
,	O
FILE	struct
*	O
tty_in	pointer
,	O
FILE	struct
*	O
tty_out	pointer
,	O
FILE	struct
*	O
rename_in	pointer
)	O
{	O
char	O
*	O
str_res	pointer
;	O
static	O
dynamic_string	struct
new_name	struct
;	O
static	O
int	O
initialized_new_name	int
=	O
false	int
;	O
if	O
(	O
!	O
initialized_new_name	int
)	O
{	O
ds_init	function
(	O
&	O
new_name	struct
,	O
128	int
)	O
;	O
initialized_new_name	int
=	O
true	int
;	O
}	O
if	O
(	O
rename_flag	int
)	O
{	O
fprintf	function
(	O
tty_out	pointer
,	O
_	O
(	O
"rename %s -> "	pointer
)	O
,	O
file_hdr	pointer
->	O
c_name	pointer
)	O
;	O
fflush	function
(	O
tty_out	pointer
)	O
;	O
str_res	pointer
=	O
ds_fgets	function
(	O
tty_in	pointer
,	O
&	O
new_name	struct
)	O
;	O
}	O
else	O
{	O
str_res	pointer
=	O
ds_fgetstr	function
(	O
rename_in	pointer
,	O
&	O
new_name	struct
,	O
'\n'	O
)	O
;	O
}	O
if	O
(	O
str_res	pointer
==	O
NULL	O
||	O
str_res	pointer
[	O
0	int
]	O
==	O
0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
else	O
cpio_set_c_name	function
(	O
file_hdr	pointer
,	O
new_name	struct
.	O
ds_string	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
tape_skip_padding	function
(	O
int	O
in_file_des	int
,	O
off_t	long
offset	long
)	O
{	O
off_t	long
pad	long
;	O
if	O
(	O
archive_format	enum
==	O
arf_crcascii	int
||	O
archive_format	enum
==	O
arf_newascii	int
)	O
pad	long
=	O
(	O
4	int
-	O
(	O
offset	long
%	O
4	int
)	O
)	O
%	O
4	int
;	O
else	O
if	O
(	O
archive_format	enum
==	O
arf_binary	int
||	O
archive_format	enum
==	O
arf_hpbinary	int
)	O
pad	long
=	O
(	O
2	int
-	O
(	O
offset	long
%	O
2	int
)	O
)	O
%	O
2	int
;	O
else	O
if	O
(	O
archive_format	enum
==	O
arf_tar	int
||	O
archive_format	enum
==	O
arf_ustar	int
)	O
pad	long
=	O
(	O
512	int
-	O
(	O
offset	long
%	O
512	int
)	O
)	O
%	O
512	int
;	O
else	O
pad	long
=	O
0	int
;	O
if	O
(	O
pad	long
!=	O
0	int
)	O
tape_toss_input	function
(	O
in_file_des	int
,	O
pad	long
)	O
;	O
}	O
static	O
char	O
*	O
get_link_name	function
(	O
struct	O
cpio_file_stat	struct
*	O
file_hdr	pointer
,	O
int	O
in_file_des	int
)	O
{	O
char	O
*	O
link_name	pointer
;	O
if	O
(	O
file_hdr	pointer
->	O
c_filesize	array
<	O
0	int
||	O
file_hdr	pointer
->	O
c_filesize	array
>	O
SIZE_MAX	O
-	O
1	int
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s: stored filename length is out of range"	pointer
)	O
,	O
file_hdr	pointer
->	O
c_name	pointer
)	O
;	O
link_name	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
link_name	pointer
=	O
xmalloc	function
(	O
file_hdr	pointer
->	O
c_filesize	array
+	O
1	int
)	O
;	O
tape_buffered_read	function
(	O
link_name	pointer
,	O
in_file_des	int
,	O
file_hdr	pointer
->	O
c_filesize	array
)	O
;	O
link_name	pointer
[	O
file_hdr	pointer
->	O
c_filesize	array
]	O
=	O
'\0'	O
;	O
tape_skip_padding	function
(	O
in_file_des	int
,	O
file_hdr	pointer
->	O
c_filesize	array
)	O
;	O
}	O
return	O
link_name	pointer
;	O
}	O
static	O
void	O
list_file	function
(	O
struct	O
cpio_file_stat	struct
*	O
file_hdr	pointer
,	O
int	O
in_file_des	int
)	O
{	O
if	O
(	O
verbose_flag	int
)	O
{	O
if	O
(	O
(	O
file_hdr	pointer
->	O
c_mode	short
&	O
CP_IFMT	int
)	O
==	O
CP_IFLNK	int
)	O
{	O
if	O
(	O
archive_format	enum
!=	O
arf_tar	int
&&	O
archive_format	enum
!=	O
arf_ustar	int
)	O
{	O
char	O
*	O
link_name	pointer
=	O
get_link_name	function
(	O
file_hdr	pointer
,	O
in_file_des	int
)	O
;	O
if	O
(	O
link_name	pointer
)	O
{	O
long_format	function
(	O
file_hdr	pointer
,	O
link_name	pointer
)	O
;	O
free	function
(	O
link_name	pointer
)	O
;	O
}	O
}	O
else	O
long_format	function
(	O
file_hdr	pointer
,	O
file_hdr	pointer
->	O
c_tar_linkname	pointer
)	O
;	O
return	O
;	O
}	O
else	O
long_format	function
(	O
file_hdr	pointer
,	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
}	O
else	O
{	O
printf	function
(	O
"%s%c"	pointer
,	O
file_hdr	pointer
->	O
c_name	pointer
,	O
name_end	char
)	O
;	O
}	O
crc	int
=	O
0	int
;	O
tape_toss_input	function
(	O
in_file_des	int
,	O
file_hdr	pointer
->	O
c_filesize	array
)	O
;	O
tape_skip_padding	function
(	O
in_file_des	int
,	O
file_hdr	pointer
->	O
c_filesize	array
)	O
;	O
if	O
(	O
only_verify_crc_flag	int
)	O
{	O
if	O
(	O
(	O
file_hdr	pointer
->	O
c_mode	short
&	O
CP_IFMT	int
)	O
==	O
CP_IFLNK	int
)	O
{	O
return	O
;	O
}	O
if	O
(	O
crc	int
!=	O
file_hdr	pointer
->	O
c_chksum	array
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s: checksum error (0x%x, should be 0x%x)"	pointer
)	O
,	O
file_hdr	pointer
->	O
c_name	pointer
,	O
crc	int
,	O
file_hdr	pointer
->	O
c_chksum	array
)	O
;	O
}	O
}	O
}	O
static	O
int	O
try_existing_file	function
(	O
struct	O
cpio_file_stat	struct
*	O
file_hdr	pointer
,	O
int	O
in_file_des	int
,	O
bool	bool
*	O
existing_dir	int
)	O
{	O
struct	O
stat	struct
file_stat	pointer
;	O
*	O
existing_dir	int
=	O
false	int
;	O
if	O
(	O
lstat	function
(	O
file_hdr	pointer
->	O
c_name	pointer
,	O
&	O
file_stat	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
S_ISDIR	O
(	O
file_stat	pointer
.	O
st_mode	int
)	O
&&	O
(	O
(	O
file_hdr	pointer
->	O
c_mode	short
&	O
CP_IFMT	int
)	O
==	O
CP_IFDIR	int
)	O
)	O
{	O
*	O
existing_dir	int
=	O
true	int
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
!	O
unconditional_flag	int
&&	O
file_hdr	pointer
->	O
c_mtime	array
<=	O
file_stat	pointer
.	O
st_mtime	O
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s not created: newer or same age version exists"	pointer
)	O
,	O
file_hdr	pointer
->	O
c_name	pointer
)	O
;	O
tape_toss_input	function
(	O
in_file_des	int
,	O
file_hdr	pointer
->	O
c_filesize	array
)	O
;	O
tape_skip_padding	function
(	O
in_file_des	int
,	O
file_hdr	pointer
->	O
c_filesize	array
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
S_ISDIR	O
(	O
file_stat	pointer
.	O
st_mode	int
)	O
?	O
rmdir	function
(	O
file_hdr	pointer
->	O
c_name	pointer
)	O
:	O
unlink	function
(	O
file_hdr	pointer
->	O
c_name	pointer
)	O
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"cannot remove current %s"	pointer
)	O
,	O
file_hdr	pointer
->	O
c_name	pointer
)	O
;	O
tape_toss_input	function
(	O
in_file_des	int
,	O
file_hdr	pointer
->	O
c_filesize	array
)	O
;	O
tape_skip_padding	function
(	O
in_file_des	int
,	O
file_hdr	pointer
->	O
c_filesize	array
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
struct	O
deferment	struct
*	O
deferments	pointer
=	O
NULL	O
;	O
static	O
void	O
defer_copyin	function
(	O
struct	O
cpio_file_stat	struct
*	O
file_hdr	pointer
)	O
{	O
struct	O
deferment	struct
*	O
d	pointer
;	O
d	pointer
=	O
create_deferment	function
(	O
file_hdr	pointer
)	O
;	O
d	pointer
->	O
next	pointer
=	O
deferments	pointer
;	O
deferments	pointer
=	O
d	pointer
;	O
return	O
;	O
}	O
static	O
void	O
create_defered_links	function
(	O
struct	O
cpio_file_stat	struct
*	O
file_hdr	pointer
)	O
{	O
struct	O
deferment	struct
*	O
d	pointer
;	O
struct	O
deferment	struct
*	O
d_prev	pointer
;	O
ino_t	long
ino	long
;	O
int	O
maj	int
;	O
int	O
min	int
;	O
int	O
link_res	int
;	O
ino	long
=	O
file_hdr	pointer
->	O
c_ino	short
;	O
maj	int
=	O
file_hdr	pointer
->	O
c_dev_maj	array
;	O
min	int
=	O
file_hdr	pointer
->	O
c_dev_min	array
;	O
d	pointer
=	O
deferments	pointer
;	O
d_prev	pointer
=	O
NULL	O
;	O
while	O
(	O
d	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
d	pointer
->	O
header	pointer
.	O
c_ino	short
==	O
ino	long
)	O
&&	O
(	O
d	pointer
->	O
header	pointer
.	O
c_dev_maj	array
==	O
maj	int
)	O
&&	O
(	O
d	pointer
->	O
header	pointer
.	O
c_dev_min	array
==	O
min	int
)	O
)	O
{	O
struct	O
deferment	struct
*	O
d_free	pointer
;	O
link_res	int
=	O
link_to_name	function
(	O
d	pointer
->	O
header	pointer
.	O
c_name	pointer
,	O
file_hdr	pointer
->	O
c_name	pointer
)	O
;	O
if	O
(	O
link_res	int
<	O
0	int
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"cannot link %s to %s"	pointer
)	O
,	O
d	pointer
->	O
header	pointer
.	O
c_name	pointer
,	O
file_hdr	pointer
->	O
c_name	pointer
)	O
;	O
}	O
if	O
(	O
d_prev	pointer
!=	O
NULL	O
)	O
d_prev	pointer
->	O
next	pointer
=	O
d	pointer
->	O
next	pointer
;	O
else	O
deferments	pointer
=	O
d	pointer
->	O
next	pointer
;	O
d_free	pointer
=	O
d	pointer
;	O
d	pointer
=	O
d	pointer
->	O
next	pointer
;	O
free_deferment	function
(	O
d_free	pointer
)	O
;	O
}	O
else	O
{	O
d_prev	pointer
=	O
d	pointer
;	O
d	pointer
=	O
d	pointer
->	O
next	pointer
;	O
}	O
}	O
}	O
static	O
int	O
create_defered_links_to_skipped	function
(	O
struct	O
cpio_file_stat	struct
*	O
file_hdr	pointer
,	O
int	O
in_file_des	int
)	O
{	O
struct	O
deferment	struct
*	O
d	pointer
;	O
struct	O
deferment	struct
*	O
d_prev	pointer
;	O
ino_t	long
ino	long
;	O
int	O
maj	int
;	O
int	O
min	int
;	O
if	O
(	O
file_hdr	pointer
->	O
c_filesize	array
==	O
0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
ino	long
=	O
file_hdr	pointer
->	O
c_ino	short
;	O
maj	int
=	O
file_hdr	pointer
->	O
c_dev_maj	array
;	O
min	int
=	O
file_hdr	pointer
->	O
c_dev_min	array
;	O
d	pointer
=	O
deferments	pointer
;	O
d_prev	pointer
=	O
NULL	O
;	O
while	O
(	O
d	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
d	pointer
->	O
header	pointer
.	O
c_ino	short
==	O
ino	long
)	O
&&	O
(	O
d	pointer
->	O
header	pointer
.	O
c_dev_maj	array
==	O
maj	int
)	O
&&	O
(	O
d	pointer
->	O
header	pointer
.	O
c_dev_min	array
==	O
min	int
)	O
)	O
{	O
if	O
(	O
d_prev	pointer
!=	O
NULL	O
)	O
d_prev	pointer
->	O
next	pointer
=	O
d	pointer
->	O
next	pointer
;	O
else	O
deferments	pointer
=	O
d	pointer
->	O
next	pointer
;	O
cpio_set_c_name	function
(	O
file_hdr	pointer
,	O
d	pointer
->	O
header	pointer
.	O
c_name	pointer
)	O
;	O
free_deferment	function
(	O
d	pointer
)	O
;	O
copyin_regular_file	function
(	O
file_hdr	pointer
,	O
in_file_des	int
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
d_prev	pointer
=	O
d	pointer
;	O
d	pointer
=	O
d	pointer
->	O
next	pointer
;	O
}	O
}	O
return	O
-	O
1	int
;	O
}	O
static	O
void	O
create_final_defers	function
(	O
)	O
{	O
struct	O
deferment	struct
*	O
d	pointer
;	O
int	O
link_res	int
;	O
int	O
out_file_des	int
;	O
for	O
(	O
d	pointer
=	O
deferments	pointer
;	O
d	pointer
!=	O
NULL	O
;	O
d	pointer
=	O
d	pointer
->	O
next	pointer
)	O
{	O
link_res	int
=	O
link_to_maj_min_ino	function
(	O
d	pointer
->	O
header	pointer
.	O
c_name	pointer
,	O
d	pointer
->	O
header	pointer
.	O
c_dev_maj	array
,	O
d	pointer
->	O
header	pointer
.	O
c_dev_min	array
,	O
d	pointer
->	O
header	pointer
.	O
c_ino	short
)	O
;	O
if	O
(	O
link_res	int
==	O
0	int
)	O
{	O
continue	O
;	O
}	O
out_file_des	int
=	O
open	function
(	O
d	pointer
->	O
header	pointer
.	O
c_name	pointer
,	O
O_CREAT	int
|	O
O_WRONLY	int
|	O
O_BINARY	int
,	O
0600	int
)	O
;	O
if	O
(	O
out_file_des	int
<	O
0	int
&&	O
create_dir_flag	int
)	O
{	O
create_all_directories	function
(	O
d	pointer
->	O
header	pointer
.	O
c_name	pointer
)	O
;	O
out_file_des	int
=	O
open	function
(	O
d	pointer
->	O
header	pointer
.	O
c_name	pointer
,	O
O_CREAT	int
|	O
O_WRONLY	int
|	O
O_BINARY	int
,	O
0600	int
)	O
;	O
}	O
if	O
(	O
out_file_des	int
<	O
0	int
)	O
{	O
open_error	function
(	O
d	pointer
->	O
header	pointer
.	O
c_name	pointer
)	O
;	O
continue	O
;	O
}	O
set_perms	function
(	O
out_file_des	int
,	O
&	O
d	pointer
->	O
header	pointer
)	O
;	O
if	O
(	O
close	function
(	O
out_file_des	int
)	O
<	O
0	int
)	O
close_error	function
(	O
d	pointer
->	O
header	pointer
.	O
c_name	pointer
)	O
;	O
}	O
}	O
static	O
void	O
copyin_regular_file	function
(	O
struct	O
cpio_file_stat	struct
*	O
file_hdr	pointer
,	O
int	O
in_file_des	int
)	O
{	O
int	O
out_file_des	int
;	O
if	O
(	O
to_stdout_option	bool
)	O
out_file_des	int
=	O
STDOUT_FILENO	int
;	O
else	O
{	O
if	O
(	O
file_hdr	pointer
->	O
c_nlink	short
>	O
1	int
&&	O
(	O
archive_format	enum
==	O
arf_newascii	int
||	O
archive_format	enum
==	O
arf_crcascii	int
)	O
)	O
{	O
int	O
link_res	int
;	O
if	O
(	O
file_hdr	pointer
->	O
c_filesize	array
==	O
0	int
)	O
{	O
defer_copyin	function
(	O
file_hdr	pointer
)	O
;	O
tape_toss_input	function
(	O
in_file_des	int
,	O
file_hdr	pointer
->	O
c_filesize	array
)	O
;	O
tape_skip_padding	function
(	O
in_file_des	int
,	O
file_hdr	pointer
->	O
c_filesize	array
)	O
;	O
return	O
;	O
}	O
link_res	int
=	O
link_to_maj_min_ino	function
(	O
file_hdr	pointer
->	O
c_name	pointer
,	O
file_hdr	pointer
->	O
c_dev_maj	array
,	O
file_hdr	pointer
->	O
c_dev_min	array
,	O
file_hdr	pointer
->	O
c_ino	short
)	O
;	O
if	O
(	O
link_res	int
==	O
0	int
)	O
{	O
tape_toss_input	function
(	O
in_file_des	int
,	O
file_hdr	pointer
->	O
c_filesize	array
)	O
;	O
tape_skip_padding	function
(	O
in_file_des	int
,	O
file_hdr	pointer
->	O
c_filesize	array
)	O
;	O
return	O
;	O
}	O
}	O
else	O
if	O
(	O
file_hdr	pointer
->	O
c_nlink	short
>	O
1	int
&&	O
archive_format	enum
!=	O
arf_tar	int
&&	O
archive_format	enum
!=	O
arf_ustar	int
)	O
{	O
int	O
link_res	int
;	O
link_res	int
=	O
link_to_maj_min_ino	function
(	O
file_hdr	pointer
->	O
c_name	pointer
,	O
file_hdr	pointer
->	O
c_dev_maj	array
,	O
file_hdr	pointer
->	O
c_dev_min	array
,	O
file_hdr	pointer
->	O
c_ino	short
)	O
;	O
if	O
(	O
link_res	int
==	O
0	int
)	O
{	O
tape_toss_input	function
(	O
in_file_des	int
,	O
file_hdr	pointer
->	O
c_filesize	array
)	O
;	O
tape_skip_padding	function
(	O
in_file_des	int
,	O
file_hdr	pointer
->	O
c_filesize	array
)	O
;	O
return	O
;	O
}	O
}	O
else	O
if	O
(	O
(	O
archive_format	enum
==	O
arf_tar	int
||	O
archive_format	enum
==	O
arf_ustar	int
)	O
&&	O
file_hdr	pointer
->	O
c_tar_linkname	pointer
&&	O
file_hdr	pointer
->	O
c_tar_linkname	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
int	O
link_res	int
;	O
link_res	int
=	O
link_to_name	function
(	O
file_hdr	pointer
->	O
c_name	pointer
,	O
file_hdr	pointer
->	O
c_tar_linkname	pointer
)	O
;	O
if	O
(	O
link_res	int
<	O
0	int
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"cannot link %s to %s"	pointer
)	O
,	O
file_hdr	pointer
->	O
c_tar_linkname	pointer
,	O
file_hdr	pointer
->	O
c_name	pointer
)	O
;	O
}	O
return	O
;	O
}	O
out_file_des	int
=	O
open	function
(	O
file_hdr	pointer
->	O
c_name	pointer
,	O
O_CREAT	int
|	O
O_WRONLY	int
|	O
O_BINARY	int
,	O
0600	int
)	O
;	O
if	O
(	O
out_file_des	int
<	O
0	int
&&	O
create_dir_flag	int
)	O
{	O
create_all_directories	function
(	O
file_hdr	pointer
->	O
c_name	pointer
)	O
;	O
out_file_des	int
=	O
open	function
(	O
file_hdr	pointer
->	O
c_name	pointer
,	O
O_CREAT	int
|	O
O_WRONLY	int
|	O
O_BINARY	int
,	O
0600	int
)	O
;	O
}	O
if	O
(	O
out_file_des	int
<	O
0	int
)	O
{	O
open_error	function
(	O
file_hdr	pointer
->	O
c_name	pointer
)	O
;	O
tape_toss_input	function
(	O
in_file_des	int
,	O
file_hdr	pointer
->	O
c_filesize	array
)	O
;	O
tape_skip_padding	function
(	O
in_file_des	int
,	O
file_hdr	pointer
->	O
c_filesize	array
)	O
;	O
return	O
;	O
}	O
}	O
crc	int
=	O
0	int
;	O
if	O
(	O
swap_halfwords_flag	int
)	O
{	O
if	O
(	O
(	O
file_hdr	pointer
->	O
c_filesize	array
%	O
4	int
)	O
==	O
0	int
)	O
swapping_halfwords	int
=	O
true	int
;	O
else	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"cannot swap halfwords of %s: odd number of halfwords"	pointer
)	O
,	O
file_hdr	pointer
->	O
c_name	pointer
)	O
;	O
}	O
if	O
(	O
swap_bytes_flag	int
)	O
{	O
if	O
(	O
(	O
file_hdr	pointer
->	O
c_filesize	array
%	O
2	int
)	O
==	O
0	int
)	O
swapping_bytes	int
=	O
true	int
;	O
else	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"cannot swap bytes of %s: odd number of bytes"	pointer
)	O
,	O
file_hdr	pointer
->	O
c_name	pointer
)	O
;	O
}	O
copy_files_tape_to_disk	function
(	O
in_file_des	int
,	O
out_file_des	int
,	O
file_hdr	pointer
->	O
c_filesize	array
)	O
;	O
disk_empty_output_buffer	function
(	O
out_file_des	int
,	O
true	int
)	O
;	O
if	O
(	O
to_stdout_option	bool
)	O
{	O
if	O
(	O
archive_format	enum
==	O
arf_crcascii	int
)	O
{	O
if	O
(	O
crc	int
!=	O
file_hdr	pointer
->	O
c_chksum	array
)	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s: checksum error (0x%x, should be 0x%x)"	pointer
)	O
,	O
file_hdr	pointer
->	O
c_name	pointer
,	O
crc	int
,	O
file_hdr	pointer
->	O
c_chksum	array
)	O
;	O
}	O
tape_skip_padding	function
(	O
in_file_des	int
,	O
file_hdr	pointer
->	O
c_filesize	array
)	O
;	O
return	O
;	O
}	O
set_perms	function
(	O
out_file_des	int
,	O
file_hdr	pointer
)	O
;	O
if	O
(	O
close	function
(	O
out_file_des	int
)	O
<	O
0	int
)	O
close_error	function
(	O
file_hdr	pointer
->	O
c_name	pointer
)	O
;	O
if	O
(	O
archive_format	enum
==	O
arf_crcascii	int
)	O
{	O
if	O
(	O
crc	int
!=	O
file_hdr	pointer
->	O
c_chksum	array
)	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s: checksum error (0x%x, should be 0x%x)"	pointer
)	O
,	O
file_hdr	pointer
->	O
c_name	pointer
,	O
crc	int
,	O
file_hdr	pointer
->	O
c_chksum	array
)	O
;	O
}	O
tape_skip_padding	function
(	O
in_file_des	int
,	O
file_hdr	pointer
->	O
c_filesize	array
)	O
;	O
if	O
(	O
file_hdr	pointer
->	O
c_nlink	short
>	O
1	int
&&	O
(	O
archive_format	enum
==	O
arf_newascii	int
||	O
archive_format	enum
==	O
arf_crcascii	int
)	O
)	O
{	O
create_defered_links	function
(	O
file_hdr	pointer
)	O
;	O
}	O
}	O
static	O
void	O
copyin_device	function
(	O
struct	O
cpio_file_stat	struct
*	O
file_hdr	pointer
)	O
{	O
int	O
res	int
;	O
if	O
(	O
to_stdout_option	bool
)	O
return	O
;	O
if	O
(	O
file_hdr	pointer
->	O
c_nlink	short
>	O
1	int
&&	O
archive_format	enum
!=	O
arf_tar	int
&&	O
archive_format	enum
!=	O
arf_ustar	int
)	O
{	O
int	O
link_res	int
;	O
link_res	int
=	O
link_to_maj_min_ino	function
(	O
file_hdr	pointer
->	O
c_name	pointer
,	O
file_hdr	pointer
->	O
c_dev_maj	array
,	O
file_hdr	pointer
->	O
c_dev_min	array
,	O
file_hdr	pointer
->	O
c_ino	short
)	O
;	O
if	O
(	O
link_res	int
==	O
0	int
)	O
{	O
return	O
;	O
}	O
}	O
else	O
if	O
(	O
archive_format	enum
==	O
arf_ustar	int
&&	O
file_hdr	pointer
->	O
c_tar_linkname	pointer
&&	O
file_hdr	pointer
->	O
c_tar_linkname	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
int	O
link_res	int
;	O
link_res	int
=	O
link_to_name	function
(	O
file_hdr	pointer
->	O
c_name	pointer
,	O
file_hdr	pointer
->	O
c_tar_linkname	pointer
)	O
;	O
if	O
(	O
link_res	int
<	O
0	int
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"cannot link %s to %s"	pointer
)	O
,	O
file_hdr	pointer
->	O
c_tar_linkname	pointer
,	O
file_hdr	pointer
->	O
c_name	pointer
)	O
;	O
}	O
return	O
;	O
}	O
res	int
=	O
mknod	function
(	O
file_hdr	pointer
->	O
c_name	pointer
,	O
file_hdr	pointer
->	O
c_mode	short
,	O
makedev	O
(	O
file_hdr	pointer
->	O
c_rdev_maj	array
,	O
file_hdr	pointer
->	O
c_rdev_min	array
)	O
)	O
;	O
if	O
(	O
res	int
<	O
0	int
&&	O
create_dir_flag	int
)	O
{	O
create_all_directories	function
(	O
file_hdr	pointer
->	O
c_name	pointer
)	O
;	O
res	int
=	O
mknod	function
(	O
file_hdr	pointer
->	O
c_name	pointer
,	O
file_hdr	pointer
->	O
c_mode	short
,	O
makedev	O
(	O
file_hdr	pointer
->	O
c_rdev_maj	array
,	O
file_hdr	pointer
->	O
c_rdev_min	array
)	O
)	O
;	O
}	O
if	O
(	O
res	int
<	O
0	int
)	O
{	O
mknod_error	function
(	O
file_hdr	pointer
->	O
c_name	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
no_chown_flag	int
)	O
{	O
uid_t	int
uid	int
=	O
set_owner_flag	int
?	O
set_owner	int
:	O
file_hdr	pointer
->	O
c_uid	short
;	O
gid_t	int
gid	int
=	O
set_group_flag	int
?	O
set_group	int
:	O
file_hdr	pointer
->	O
c_gid	short
;	O
if	O
(	O
(	O
chown	function
(	O
file_hdr	pointer
->	O
c_name	pointer
,	O
uid	int
,	O
gid	int
)	O
<	O
0	int
)	O
&&	O
errno	O
!=	O
EPERM	int
)	O
chown_error_details	function
(	O
file_hdr	pointer
->	O
c_name	pointer
,	O
uid	int
,	O
gid	int
)	O
;	O
}	O
if	O
(	O
chmod	function
(	O
file_hdr	pointer
->	O
c_name	pointer
,	O
file_hdr	pointer
->	O
c_mode	short
)	O
<	O
0	int
)	O
chmod_error_details	function
(	O
file_hdr	pointer
->	O
c_name	pointer
,	O
file_hdr	pointer
->	O
c_mode	short
)	O
;	O
if	O
(	O
retain_time_flag	int
)	O
set_file_times	function
(	O
-	O
1	int
,	O
file_hdr	pointer
->	O
c_name	pointer
,	O
file_hdr	pointer
->	O
c_mtime	array
,	O
file_hdr	pointer
->	O
c_mtime	array
)	O
;	O
}	O
static	O
void	O
copyin_link	function
(	O
struct	O
cpio_file_stat	struct
*	O
file_hdr	pointer
,	O
int	O
in_file_des	int
)	O
{	O
char	O
*	O
link_name	pointer
=	O
NULL	O
;	O
int	O
res	int
;	O
if	O
(	O
archive_format	enum
!=	O
arf_tar	int
&&	O
archive_format	enum
!=	O
arf_ustar	int
)	O
{	O
if	O
(	O
to_stdout_option	bool
)	O
{	O
tape_toss_input	function
(	O
in_file_des	int
,	O
file_hdr	pointer
->	O
c_filesize	array
)	O
;	O
tape_skip_padding	function
(	O
in_file_des	int
,	O
file_hdr	pointer
->	O
c_filesize	array
)	O
;	O
return	O
;	O
}	O
link_name	pointer
=	O
get_link_name	function
(	O
file_hdr	pointer
,	O
in_file_des	int
)	O
;	O
if	O
(	O
!	O
link_name	pointer
)	O
return	O
;	O
}	O
else	O
{	O
if	O
(	O
to_stdout_option	bool
)	O
return	O
;	O
link_name	pointer
=	O
xstrdup	function
(	O
file_hdr	pointer
->	O
c_tar_linkname	pointer
)	O
;	O
}	O
cpio_safer_name_suffix	function
(	O
link_name	pointer
,	O
true	int
,	O
!	O
no_abs_paths_flag	int
,	O
false	int
)	O
;	O
res	int
=	O
UMASKED_SYMLINK	O
(	O
link_name	pointer
,	O
file_hdr	pointer
->	O
c_name	pointer
,	O
file_hdr	pointer
->	O
c_mode	short
)	O
;	O
if	O
(	O
res	int
<	O
0	int
&&	O
create_dir_flag	int
)	O
{	O
create_all_directories	function
(	O
file_hdr	pointer
->	O
c_name	pointer
)	O
;	O
res	int
=	O
UMASKED_SYMLINK	O
(	O
link_name	pointer
,	O
file_hdr	pointer
->	O
c_name	pointer
,	O
file_hdr	pointer
->	O
c_mode	short
)	O
;	O
}	O
if	O
(	O
res	int
<	O
0	int
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"%s: Cannot symlink to %s"	pointer
)	O
,	O
quotearg_colon	function
(	O
link_name	pointer
)	O
,	O
quote_n	function
(	O
1	int
,	O
file_hdr	pointer
->	O
c_name	pointer
)	O
)	O
;	O
free	function
(	O
link_name	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
no_chown_flag	int
)	O
{	O
uid_t	int
uid	int
=	O
set_owner_flag	int
?	O
set_owner	int
:	O
file_hdr	pointer
->	O
c_uid	short
;	O
gid_t	int
gid	int
=	O
set_group_flag	int
?	O
set_group	int
:	O
file_hdr	pointer
->	O
c_gid	short
;	O
if	O
(	O
(	O
lchown	function
(	O
file_hdr	pointer
->	O
c_name	pointer
,	O
uid	int
,	O
gid	int
)	O
<	O
0	int
)	O
&&	O
errno	O
!=	O
EPERM	int
)	O
chown_error_details	function
(	O
file_hdr	pointer
->	O
c_name	pointer
,	O
uid	int
,	O
gid	int
)	O
;	O
}	O
free	function
(	O
link_name	pointer
)	O
;	O
}	O
static	O
void	O
copyin_file	function
(	O
struct	O
cpio_file_stat	struct
*	O
file_hdr	pointer
,	O
int	O
in_file_des	int
)	O
{	O
bool	bool
existing_dir	int
=	O
false	int
;	O
if	O
(	O
!	O
to_stdout_option	bool
&&	O
try_existing_file	function
(	O
file_hdr	pointer
,	O
in_file_des	int
,	O
&	O
existing_dir	int
)	O
<	O
0	int
)	O
return	O
;	O
switch	O
(	O
file_hdr	pointer
->	O
c_mode	short
&	O
CP_IFMT	int
)	O
{	O
case	O
CP_IFREG	int
:	O
copyin_regular_file	function
(	O
file_hdr	pointer
,	O
in_file_des	int
)	O
;	O
break	O
;	O
case	O
CP_IFDIR	int
:	O
cpio_create_dir	function
(	O
file_hdr	pointer
,	O
existing_dir	int
)	O
;	O
break	O
;	O
case	O
CP_IFCHR	int
:	O
case	O
CP_IFBLK	int
:	O
case	O
CP_IFSOCK	int
:	O
case	O
CP_IFIFO	int
:	O
copyin_device	function
(	O
file_hdr	pointer
)	O
;	O
break	O
;	O
case	O
CP_IFLNK	int
:	O
copyin_link	function
(	O
file_hdr	pointer
,	O
in_file_des	int
)	O
;	O
break	O
;	O
default	O
:	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s: unknown file type"	pointer
)	O
,	O
file_hdr	pointer
->	O
c_name	pointer
)	O
;	O
tape_toss_input	function
(	O
in_file_des	int
,	O
file_hdr	pointer
->	O
c_filesize	array
)	O
;	O
tape_skip_padding	function
(	O
in_file_des	int
,	O
file_hdr	pointer
->	O
c_filesize	array
)	O
;	O
}	O
}	O
static	O
time_t	long
current_time	long
;	O
void	O
long_format	function
(	O
struct	O
cpio_file_stat	struct
*	O
file_hdr	pointer
,	O
char	O
const	O
*	O
link_name	pointer
)	O
{	O
char	O
mbuf	array
[	O
11	int
]	O
;	O
char	O
tbuf	array
[	O
40	int
]	O
;	O
time_t	long
when	long
;	O
mode_string	function
(	O
file_hdr	pointer
->	O
c_mode	short
,	O
mbuf	array
)	O
;	O
mbuf	array
[	O
10	int
]	O
=	O
'\0'	O
;	O
when	long
=	O
file_hdr	pointer
->	O
c_mtime	array
;	O
strcpy	function
(	O
tbuf	array
,	O
ctime	function
(	O
&	O
when	long
)	O
)	O
;	O
if	O
(	O
current_time	long
-	O
when	long
>	O
6L	int
*	O
30L	int
*	O
24L	int
*	O
60L	int
*	O
60L	int
||	O
current_time	long
-	O
when	long
<	O
0L	int
)	O
{	O
strcpy	function
(	O
tbuf	array
+	O
11	int
,	O
tbuf	array
+	O
19	int
)	O
;	O
}	O
tbuf	array
[	O
16	int
]	O
=	O
'\0'	O
;	O
printf	function
(	O
"%s %3lu "	pointer
,	O
mbuf	array
,	O
(	O
unsigned	O
long	O
)	O
file_hdr	pointer
->	O
c_nlink	short
)	O
;	O
if	O
(	O
numeric_uid	int
)	O
printf	function
(	O
"%-8u %-8u "	pointer
,	O
(	O
unsigned	O
int	O
)	O
file_hdr	pointer
->	O
c_uid	short
,	O
(	O
unsigned	O
int	O
)	O
file_hdr	pointer
->	O
c_gid	short
)	O
;	O
else	O
printf	function
(	O
"%-8.8s %-8.8s "	pointer
,	O
getuser	function
(	O
file_hdr	pointer
->	O
c_uid	short
)	O
,	O
getgroup	function
(	O
file_hdr	pointer
->	O
c_gid	short
)	O
)	O
;	O
if	O
(	O
(	O
file_hdr	pointer
->	O
c_mode	short
&	O
CP_IFMT	int
)	O
==	O
CP_IFCHR	int
||	O
(	O
file_hdr	pointer
->	O
c_mode	short
&	O
CP_IFMT	int
)	O
==	O
CP_IFBLK	int
)	O
printf	function
(	O
"%3lu, %3lu "	pointer
,	O
file_hdr	pointer
->	O
c_rdev_maj	array
,	O
file_hdr	pointer
->	O
c_rdev_min	array
)	O
;	O
else	O
printf	function
(	O
"%8"	pointer
PRIuMAX	O
" "	pointer
,	O
(	O
uintmax_t	long
)	O
file_hdr	pointer
->	O
c_filesize	array
)	O
;	O
printf	function
(	O
"%s "	pointer
,	O
tbuf	array
+	O
4	int
)	O
;	O
printf	function
(	O
"%s"	pointer
,	O
quotearg	function
(	O
file_hdr	pointer
->	O
c_name	pointer
)	O
)	O
;	O
if	O
(	O
link_name	pointer
)	O
{	O
printf	function
(	O
" -> "	pointer
)	O
;	O
printf	function
(	O
"%s"	pointer
,	O
quotearg	function
(	O
link_name	pointer
)	O
)	O
;	O
}	O
putc	function
(	O
'\n'	O
,	O
stdout	pointer
)	O
;	O
}	O
static	O
void	O
read_pattern_file	function
(	O
)	O
{	O
int	O
max_new_patterns	int
;	O
char	O
*	O
*	O
new_save_patterns	pointer
;	O
int	O
new_num_patterns	int
;	O
int	O
i	int
;	O
dynamic_string	struct
pattern_name	struct
;	O
FILE	struct
*	O
pattern_fp	pointer
;	O
if	O
(	O
num_patterns	int
<	O
0	int
)	O
num_patterns	int
=	O
0	int
;	O
max_new_patterns	int
=	O
1	int
+	O
num_patterns	int
;	O
new_save_patterns	pointer
=	O
(	O
char	O
*	O
*	O
)	O
xmalloc	function
(	O
max_new_patterns	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
new_num_patterns	int
=	O
num_patterns	int
;	O
ds_init	function
(	O
&	O
pattern_name	struct
,	O
128	int
)	O
;	O
pattern_fp	pointer
=	O
fopen	function
(	O
pattern_file_name	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
pattern_fp	pointer
==	O
NULL	O
)	O
open_fatal	function
(	O
pattern_file_name	pointer
)	O
;	O
while	O
(	O
ds_fgetstr	function
(	O
pattern_fp	pointer
,	O
&	O
pattern_name	struct
,	O
'\n'	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
new_num_patterns	int
>=	O
max_new_patterns	int
)	O
{	O
max_new_patterns	int
+=	O
1	int
;	O
new_save_patterns	pointer
=	O
(	O
char	O
*	O
*	O
)	O
xrealloc	function
(	O
(	O
char	O
*	O
)	O
new_save_patterns	pointer
,	O
max_new_patterns	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
}	O
new_save_patterns	pointer
[	O
new_num_patterns	int
]	O
=	O
xstrdup	function
(	O
pattern_name	struct
.	O
ds_string	pointer
)	O
;	O
++	O
new_num_patterns	int
;	O
}	O
if	O
(	O
ferror	function
(	O
pattern_fp	pointer
)	O
||	O
fclose	function
(	O
pattern_fp	pointer
)	O
==	O
EOF	O
)	O
close_error	function
(	O
pattern_file_name	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_patterns	int
;	O
++	O
i	int
)	O
new_save_patterns	pointer
[	O
i	int
]	O
=	O
save_patterns	pointer
[	O
i	int
]	O
;	O
save_patterns	pointer
=	O
new_save_patterns	pointer
;	O
num_patterns	int
=	O
new_num_patterns	int
;	O
}	O
uintmax_t	long
from_ascii	function
(	O
char	O
const	O
*	O
where	pointer
,	O
size_t	long
digs	long
,	O
unsigned	O
logbase	int
)	O
{	O
uintmax_t	long
value	long
=	O
0	int
;	O
char	O
const	O
*	O
buf	pointer
=	O
where	pointer
;	O
char	O
const	O
*	O
end	pointer
=	O
buf	pointer
+	O
digs	long
;	O
int	O
overflow	int
=	O
0	int
;	O
static	O
char	O
codetab	array
[	O
]	O
=	O
"0123456789ABCDEF"	pointer
;	O
for	O
(	O
;	O
*	O
buf	pointer
==	O
' '	O
;	O
buf	pointer
++	O
)	O
{	O
if	O
(	O
buf	pointer
==	O
end	pointer
)	O
return	O
0	int
;	O
}	O
if	O
(	O
buf	pointer
==	O
end	pointer
||	O
*	O
buf	pointer
==	O
0	int
)	O
return	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
unsigned	O
d	pointer
;	O
char	O
*	O
p	pointer
=	O
strchr	function
(	O
codetab	array
,	O
toupper	function
(	O
*	O
buf	pointer
)	O
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"Malformed number %.*s"	pointer
)	O
,	O
(	O
int	O
)	O
digs	long
,	O
where	pointer
)	O
;	O
break	O
;	O
}	O
d	pointer
=	O
p	pointer
-	O
codetab	array
;	O
if	O
(	O
(	O
d	pointer
>>	O
logbase	int
)	O
>	O
1	int
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"Malformed number %.*s"	pointer
)	O
,	O
(	O
int	O
)	O
digs	long
,	O
where	pointer
)	O
;	O
break	O
;	O
}	O
value	long
+=	O
d	pointer
;	O
if	O
(	O
++	O
buf	pointer
==	O
end	pointer
||	O
*	O
buf	pointer
==	O
0	int
)	O
break	O
;	O
overflow	int
|=	O
value	long
^	O
(	O
value	long
<<	O
logbase	int
>>	O
logbase	int
)	O
;	O
value	long
<<=	O
logbase	int
;	O
}	O
if	O
(	O
overflow	int
)	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"Archive value %.*s is out of range"	pointer
)	O
,	O
(	O
int	O
)	O
digs	long
,	O
where	pointer
)	O
;	O
return	O
value	long
;	O
}	O
void	O
read_in_header	function
(	O
struct	O
cpio_file_stat	struct
*	O
file_hdr	pointer
,	O
int	O
in_des	int
)	O
{	O
union	O
{	O
char	O
str	pointer
[	O
6	int
]	O
;	O
unsigned	O
short	O
num	short
;	O
struct	O
old_cpio_header	struct
old_header	struct
;	O
}	O
magic	union
;	O
long	O
bytes_skipped	long
=	O
0	int
;	O
if	O
(	O
archive_format	enum
==	O
arf_unknown	int
)	O
{	O
union	O
{	O
char	O
s	long
[	O
512	int
]	O
;	O
unsigned	O
short	O
us	short
;	O
}	O
tmpbuf	union
;	O
int	O
check_tar	int
;	O
int	O
peeked_bytes	int
;	O
while	O
(	O
archive_format	enum
==	O
arf_unknown	int
)	O
{	O
peeked_bytes	int
=	O
tape_buffered_peek	function
(	O
tmpbuf	union
.	O
s	long
,	O
in_des	int
,	O
512	int
)	O
;	O
if	O
(	O
peeked_bytes	int
<	O
6	int
)	O
error	function
(	O
PAXEXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"premature end of archive"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
strncmp	function
(	O
tmpbuf	union
.	O
s	long
,	O
"070701"	pointer
,	O
6	int
)	O
)	O
archive_format	enum
=	O
arf_newascii	int
;	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
tmpbuf	union
.	O
s	long
,	O
"070707"	pointer
,	O
6	int
)	O
)	O
archive_format	enum
=	O
arf_oldascii	int
;	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
tmpbuf	union
.	O
s	long
,	O
"070702"	pointer
,	O
6	int
)	O
)	O
{	O
archive_format	enum
=	O
arf_crcascii	int
;	O
crc_i_flag	int
=	O
true	int
;	O
}	O
else	O
if	O
(	O
tmpbuf	union
.	O
us	short
==	O
070707	int
||	O
tmpbuf	union
.	O
us	short
==	O
swab_short	O
(	O
(	O
unsigned	O
short	O
)	O
070707	int
)	O
)	O
archive_format	enum
=	O
arf_binary	int
;	O
else	O
if	O
(	O
peeked_bytes	int
>=	O
512	int
&&	O
(	O
check_tar	int
=	O
is_tar_header	function
(	O
tmpbuf	union
.	O
s	long
)	O
)	O
)	O
{	O
if	O
(	O
check_tar	int
==	O
2	int
)	O
archive_format	enum
=	O
arf_ustar	int
;	O
else	O
archive_format	enum
=	O
arf_tar	int
;	O
}	O
else	O
{	O
tape_buffered_read	function
(	O
tmpbuf	union
.	O
s	long
,	O
in_des	int
,	O
1L	int
)	O
;	O
++	O
bytes_skipped	long
;	O
}	O
}	O
}	O
if	O
(	O
archive_format	enum
==	O
arf_tar	int
||	O
archive_format	enum
==	O
arf_ustar	int
)	O
{	O
if	O
(	O
append_flag	int
)	O
last_header_start	int
=	O
input_bytes	long
-	O
io_block_size	int
+	O
(	O
in_buff	pointer
-	O
input_buffer	pointer
)	O
;	O
if	O
(	O
bytes_skipped	long
>	O
0	int
)	O
warn_junk_bytes	function
(	O
bytes_skipped	long
)	O
;	O
read_in_tar_header	function
(	O
file_hdr	pointer
,	O
in_des	int
)	O
;	O
return	O
;	O
}	O
file_hdr	pointer
->	O
c_tar_linkname	pointer
=	O
NULL	O
;	O
tape_buffered_read	function
(	O
magic	union
.	O
str	pointer
,	O
in_des	int
,	O
sizeof	O
(	O
magic	union
.	O
str	pointer
)	O
)	O
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
append_flag	int
)	O
last_header_start	int
=	O
input_bytes	long
-	O
io_block_size	int
+	O
(	O
in_buff	pointer
-	O
input_buffer	pointer
)	O
-	O
6	int
;	O
if	O
(	O
archive_format	enum
==	O
arf_newascii	int
&&	O
!	O
strncmp	function
(	O
magic	union
.	O
str	pointer
,	O
"070701"	pointer
,	O
6	int
)	O
)	O
{	O
if	O
(	O
bytes_skipped	long
>	O
0	int
)	O
warn_junk_bytes	function
(	O
bytes_skipped	long
)	O
;	O
file_hdr	pointer
->	O
c_magic	short
=	O
070701	int
;	O
read_in_new_ascii	function
(	O
file_hdr	pointer
,	O
in_des	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
archive_format	enum
==	O
arf_crcascii	int
&&	O
!	O
strncmp	function
(	O
magic	union
.	O
str	pointer
,	O
"070702"	pointer
,	O
6	int
)	O
)	O
{	O
if	O
(	O
bytes_skipped	long
>	O
0	int
)	O
warn_junk_bytes	function
(	O
bytes_skipped	long
)	O
;	O
file_hdr	pointer
->	O
c_magic	short
=	O
070702	int
;	O
read_in_new_ascii	function
(	O
file_hdr	pointer
,	O
in_des	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
(	O
archive_format	enum
==	O
arf_oldascii	int
||	O
archive_format	enum
==	O
arf_hpoldascii	int
)	O
&&	O
!	O
strncmp	function
(	O
magic	union
.	O
str	pointer
,	O
"070707"	pointer
,	O
6	int
)	O
)	O
{	O
if	O
(	O
bytes_skipped	long
>	O
0	int
)	O
warn_junk_bytes	function
(	O
bytes_skipped	long
)	O
;	O
file_hdr	pointer
->	O
c_magic	short
=	O
070707	int
;	O
read_in_old_ascii	function
(	O
file_hdr	pointer
,	O
in_des	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
(	O
archive_format	enum
==	O
arf_binary	int
||	O
archive_format	enum
==	O
arf_hpbinary	int
)	O
&&	O
(	O
magic	union
.	O
num	short
==	O
070707	int
||	O
magic	union
.	O
num	short
==	O
swab_short	O
(	O
(	O
unsigned	O
short	O
)	O
070707	int
)	O
)	O
)	O
{	O
if	O
(	O
bytes_skipped	long
>	O
0	int
)	O
warn_junk_bytes	function
(	O
bytes_skipped	long
)	O
;	O
file_hdr	pointer
->	O
c_magic	short
=	O
070707	int
;	O
read_in_binary	function
(	O
file_hdr	pointer
,	O
&	O
magic	union
.	O
old_header	struct
,	O
in_des	int
)	O
;	O
break	O
;	O
}	O
bytes_skipped	long
++	O
;	O
memmove	function
(	O
magic	union
.	O
str	pointer
,	O
magic	union
.	O
str	pointer
+	O
1	int
,	O
sizeof	O
(	O
magic	union
.	O
str	pointer
)	O
-	O
1	int
)	O
;	O
tape_buffered_read	function
(	O
magic	union
.	O
str	pointer
+	O
sizeof	O
(	O
magic	union
.	O
str	pointer
)	O
-	O
1	int
,	O
in_des	int
,	O
1L	int
)	O
;	O
}	O
}	O
static	O
void	O
read_name_from_file	function
(	O
struct	O
cpio_file_stat	struct
*	O
file_hdr	pointer
,	O
int	O
fd	int
,	O
uintmax_t	long
len	long
)	O
{	O
cpio_realloc_c_name	function
(	O
file_hdr	pointer
,	O
len	long
)	O
;	O
tape_buffered_read	function
(	O
file_hdr	pointer
->	O
c_name	pointer
,	O
fd	int
,	O
len	long
)	O
;	O
file_hdr	pointer
->	O
c_namesize	short
=	O
len	long
;	O
}	O
void	O
read_in_old_ascii	function
(	O
struct	O
cpio_file_stat	struct
*	O
file_hdr	pointer
,	O
int	O
in_des	int
)	O
{	O
struct	O
old_ascii_header	struct
ascii_header	struct
;	O
unsigned	O
long	O
dev	long
;	O
tape_buffered_read	function
(	O
ascii_header	struct
.	O
c_dev	short
,	O
in_des	int
,	O
sizeof	O
ascii_header	struct
-	O
sizeof	O
ascii_header	struct
.	O
c_magic	short
)	O
;	O
dev	long
=	O
FROM_OCTAL	O
(	O
ascii_header	struct
.	O
c_dev	short
)	O
;	O
file_hdr	pointer
->	O
c_dev_maj	array
=	O
major	O
(	O
dev	long
)	O
;	O
file_hdr	pointer
->	O
c_dev_min	array
=	O
minor	O
(	O
dev	long
)	O
;	O
file_hdr	pointer
->	O
c_ino	short
=	O
FROM_OCTAL	O
(	O
ascii_header	struct
.	O
c_ino	short
)	O
;	O
file_hdr	pointer
->	O
c_mode	short
=	O
FROM_OCTAL	O
(	O
ascii_header	struct
.	O
c_mode	short
)	O
;	O
file_hdr	pointer
->	O
c_uid	short
=	O
FROM_OCTAL	O
(	O
ascii_header	struct
.	O
c_uid	short
)	O
;	O
file_hdr	pointer
->	O
c_gid	short
=	O
FROM_OCTAL	O
(	O
ascii_header	struct
.	O
c_gid	short
)	O
;	O
file_hdr	pointer
->	O
c_nlink	short
=	O
FROM_OCTAL	O
(	O
ascii_header	struct
.	O
c_nlink	short
)	O
;	O
dev	long
=	O
FROM_OCTAL	O
(	O
ascii_header	struct
.	O
c_rdev	short
)	O
;	O
file_hdr	pointer
->	O
c_rdev_maj	array
=	O
major	O
(	O
dev	long
)	O
;	O
file_hdr	pointer
->	O
c_rdev_min	array
=	O
minor	O
(	O
dev	long
)	O
;	O
file_hdr	pointer
->	O
c_mtime	array
=	O
FROM_OCTAL	O
(	O
ascii_header	struct
.	O
c_mtime	array
)	O
;	O
file_hdr	pointer
->	O
c_filesize	array
=	O
FROM_OCTAL	O
(	O
ascii_header	struct
.	O
c_filesize	array
)	O
;	O
read_name_from_file	function
(	O
file_hdr	pointer
,	O
in_des	int
,	O
FROM_OCTAL	O
(	O
ascii_header	struct
.	O
c_namesize	short
)	O
)	O
;	O
switch	O
(	O
file_hdr	pointer
->	O
c_mode	short
&	O
CP_IFMT	int
)	O
{	O
case	O
CP_IFCHR	int
:	O
case	O
CP_IFBLK	int
:	O
case	O
CP_IFSOCK	int
:	O
case	O
CP_IFIFO	int
:	O
if	O
(	O
file_hdr	pointer
->	O
c_filesize	array
!=	O
0	int
&&	O
file_hdr	pointer
->	O
c_rdev_maj	array
==	O
0	int
&&	O
file_hdr	pointer
->	O
c_rdev_min	array
==	O
1	int
)	O
{	O
file_hdr	pointer
->	O
c_rdev_maj	array
=	O
major	O
(	O
file_hdr	pointer
->	O
c_filesize	array
)	O
;	O
file_hdr	pointer
->	O
c_rdev_min	array
=	O
minor	O
(	O
file_hdr	pointer
->	O
c_filesize	array
)	O
;	O
file_hdr	pointer
->	O
c_filesize	array
=	O
0	int
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
void	O
read_in_new_ascii	function
(	O
struct	O
cpio_file_stat	struct
*	O
file_hdr	pointer
,	O
int	O
in_des	int
)	O
{	O
struct	O
new_ascii_header	struct
ascii_header	struct
;	O
tape_buffered_read	function
(	O
ascii_header	struct
.	O
c_ino	short
,	O
in_des	int
,	O
sizeof	O
ascii_header	struct
-	O
sizeof	O
ascii_header	struct
.	O
c_magic	short
)	O
;	O
file_hdr	pointer
->	O
c_ino	short
=	O
FROM_HEX	O
(	O
ascii_header	struct
.	O
c_ino	short
)	O
;	O
file_hdr	pointer
->	O
c_mode	short
=	O
FROM_HEX	O
(	O
ascii_header	struct
.	O
c_mode	short
)	O
;	O
file_hdr	pointer
->	O
c_uid	short
=	O
FROM_HEX	O
(	O
ascii_header	struct
.	O
c_uid	short
)	O
;	O
file_hdr	pointer
->	O
c_gid	short
=	O
FROM_HEX	O
(	O
ascii_header	struct
.	O
c_gid	short
)	O
;	O
file_hdr	pointer
->	O
c_nlink	short
=	O
FROM_HEX	O
(	O
ascii_header	struct
.	O
c_nlink	short
)	O
;	O
file_hdr	pointer
->	O
c_mtime	array
=	O
FROM_HEX	O
(	O
ascii_header	struct
.	O
c_mtime	array
)	O
;	O
file_hdr	pointer
->	O
c_filesize	array
=	O
FROM_HEX	O
(	O
ascii_header	struct
.	O
c_filesize	array
)	O
;	O
file_hdr	pointer
->	O
c_dev_maj	array
=	O
FROM_HEX	O
(	O
ascii_header	struct
.	O
c_dev_maj	array
)	O
;	O
file_hdr	pointer
->	O
c_dev_min	array
=	O
FROM_HEX	O
(	O
ascii_header	struct
.	O
c_dev_min	array
)	O
;	O
file_hdr	pointer
->	O
c_rdev_maj	array
=	O
FROM_HEX	O
(	O
ascii_header	struct
.	O
c_rdev_maj	array
)	O
;	O
file_hdr	pointer
->	O
c_rdev_min	array
=	O
FROM_HEX	O
(	O
ascii_header	struct
.	O
c_rdev_min	array
)	O
;	O
file_hdr	pointer
->	O
c_chksum	array
=	O
FROM_HEX	O
(	O
ascii_header	struct
.	O
c_chksum	array
)	O
;	O
read_name_from_file	function
(	O
file_hdr	pointer
,	O
in_des	int
,	O
FROM_HEX	O
(	O
ascii_header	struct
.	O
c_namesize	short
)	O
)	O
;	O
tape_skip_padding	function
(	O
in_des	int
,	O
file_hdr	pointer
->	O
c_namesize	short
+	O
110	int
)	O
;	O
}	O
void	O
read_in_binary	function
(	O
struct	O
cpio_file_stat	struct
*	O
file_hdr	pointer
,	O
struct	O
old_cpio_header	struct
*	O
short_hdr	pointer
,	O
int	O
in_des	int
)	O
{	O
file_hdr	pointer
->	O
c_magic	short
=	O
short_hdr	pointer
->	O
c_magic	short
;	O
tape_buffered_read	function
(	O
(	O
(	O
char	O
*	O
)	O
short_hdr	pointer
)	O
+	O
6	int
,	O
in_des	int
,	O
sizeof	O
*	O
short_hdr	pointer
-	O
6	int
)	O
;	O
if	O
(	O
file_hdr	pointer
->	O
c_magic	short
==	O
swab_short	O
(	O
(	O
unsigned	O
short	O
)	O
070707	int
)	O
)	O
{	O
static	O
int	O
warned	int
=	O
0	int
;	O
if	O
(	O
warned	int
==	O
0	int
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"warning: archive header has reverse byte-order"	pointer
)	O
)	O
;	O
warned	int
=	O
1	int
;	O
}	O
swab_array	function
(	O
(	O
char	O
*	O
)	O
short_hdr	pointer
,	O
13	int
)	O
;	O
}	O
file_hdr	pointer
->	O
c_dev_maj	array
=	O
major	O
(	O
short_hdr	pointer
->	O
c_dev	short
)	O
;	O
file_hdr	pointer
->	O
c_dev_min	array
=	O
minor	O
(	O
short_hdr	pointer
->	O
c_dev	short
)	O
;	O
file_hdr	pointer
->	O
c_ino	short
=	O
short_hdr	pointer
->	O
c_ino	short
;	O
file_hdr	pointer
->	O
c_mode	short
=	O
short_hdr	pointer
->	O
c_mode	short
;	O
file_hdr	pointer
->	O
c_uid	short
=	O
short_hdr	pointer
->	O
c_uid	short
;	O
file_hdr	pointer
->	O
c_gid	short
=	O
short_hdr	pointer
->	O
c_gid	short
;	O
file_hdr	pointer
->	O
c_nlink	short
=	O
short_hdr	pointer
->	O
c_nlink	short
;	O
file_hdr	pointer
->	O
c_rdev_maj	array
=	O
major	O
(	O
short_hdr	pointer
->	O
c_rdev	short
)	O
;	O
file_hdr	pointer
->	O
c_rdev_min	array
=	O
minor	O
(	O
short_hdr	pointer
->	O
c_rdev	short
)	O
;	O
file_hdr	pointer
->	O
c_mtime	array
=	O
(	O
unsigned	O
long	O
)	O
short_hdr	pointer
->	O
c_mtimes	array
[	O
0	int
]	O
<<	O
16	int
|	O
short_hdr	pointer
->	O
c_mtimes	array
[	O
1	int
]	O
;	O
file_hdr	pointer
->	O
c_filesize	array
=	O
(	O
unsigned	O
long	O
)	O
short_hdr	pointer
->	O
c_filesizes	array
[	O
0	int
]	O
<<	O
16	int
|	O
short_hdr	pointer
->	O
c_filesizes	array
[	O
1	int
]	O
;	O
read_name_from_file	function
(	O
file_hdr	pointer
,	O
in_des	int
,	O
short_hdr	pointer
->	O
c_namesize	short
)	O
;	O
if	O
(	O
file_hdr	pointer
->	O
c_namesize	short
%	O
2	int
)	O
tape_toss_input	function
(	O
in_des	int
,	O
1L	int
)	O
;	O
switch	O
(	O
file_hdr	pointer
->	O
c_mode	short
&	O
CP_IFMT	int
)	O
{	O
case	O
CP_IFCHR	int
:	O
case	O
CP_IFBLK	int
:	O
case	O
CP_IFSOCK	int
:	O
case	O
CP_IFIFO	int
:	O
if	O
(	O
file_hdr	pointer
->	O
c_filesize	array
!=	O
0	int
&&	O
file_hdr	pointer
->	O
c_rdev_maj	array
==	O
0	int
&&	O
file_hdr	pointer
->	O
c_rdev_min	array
==	O
1	int
)	O
{	O
file_hdr	pointer
->	O
c_rdev_maj	array
=	O
major	O
(	O
file_hdr	pointer
->	O
c_filesize	array
)	O
;	O
file_hdr	pointer
->	O
c_rdev_min	array
=	O
minor	O
(	O
file_hdr	pointer
->	O
c_filesize	array
)	O
;	O
file_hdr	pointer
->	O
c_filesize	array
=	O
0	int
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
void	O
swab_array	function
(	O
char	O
*	O
ptr	pointer
,	O
int	O
count	int
)	O
{	O
char	O
tmp	char
;	O
while	O
(	O
count	int
--	O
>	O
0	int
)	O
{	O
tmp	char
=	O
*	O
ptr	pointer
;	O
*	O
ptr	pointer
=	O
*	O
(	O
ptr	pointer
+	O
1	int
)	O
;	O
++	O
ptr	pointer
;	O
*	O
ptr	pointer
=	O
tmp	char
;	O
++	O
ptr	pointer
;	O
}	O
}	O
void	O
process_copy_in	function
(	O
)	O
{	O
char	O
done	char
=	O
false	int
;	O
FILE	struct
*	O
tty_in	pointer
=	O
NULL	O
;	O
FILE	struct
*	O
tty_out	pointer
=	O
NULL	O
;	O
FILE	struct
*	O
rename_in	pointer
=	O
NULL	O
;	O
struct	O
stat	struct
file_stat	pointer
;	O
struct	O
cpio_file_stat	struct
file_hdr	pointer
=	O
CPIO_FILE_STAT_INITIALIZER	O
;	O
int	O
in_file_des	int
;	O
char	O
skip_file	char
;	O
int	O
i	int
;	O
newdir_umask	int
=	O
umask	function
(	O
0	int
)	O
;	O
if	O
(	O
pattern_file_name	pointer
)	O
{	O
read_pattern_file	function
(	O
)	O
;	O
}	O
if	O
(	O
rename_batch_file	pointer
)	O
{	O
rename_in	pointer
=	O
fopen	function
(	O
rename_batch_file	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
rename_in	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
PAXEXIT_FAILURE	int
,	O
errno	O
,	O
TTY_NAME	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
rename_flag	int
)	O
{	O
tty_in	pointer
=	O
fopen	function
(	O
TTY_NAME	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
tty_in	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
PAXEXIT_FAILURE	int
,	O
errno	O
,	O
TTY_NAME	pointer
)	O
;	O
}	O
tty_out	pointer
=	O
fopen	function
(	O
TTY_NAME	pointer
,	O
"w"	pointer
)	O
;	O
if	O
(	O
tty_out	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
PAXEXIT_FAILURE	int
,	O
errno	O
,	O
TTY_NAME	pointer
)	O
;	O
}	O
}	O
if	O
(	O
table_flag	int
&&	O
verbose_flag	int
)	O
{	O
time	struct
(	O
&	O
current_time	long
)	O
;	O
}	O
in_file_des	int
=	O
archive_des	int
;	O
if	O
(	O
_isrmt	O
(	O
in_file_des	int
)	O
)	O
{	O
input_is_special	char
=	O
1	int
;	O
input_is_seekable	char
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
fstat	function
(	O
in_file_des	int
,	O
&	O
file_stat	pointer
)	O
)	O
error	function
(	O
PAXEXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"standard input is closed"	pointer
)	O
)	O
;	O
input_is_special	char
=	O
S_ISBLK	O
(	O
file_stat	pointer
.	O
st_mode	int
)	O
||	O
S_ISCHR	O
(	O
file_stat	pointer
.	O
st_mode	int
)	O
;	O
input_is_seekable	char
=	O
S_ISREG	O
(	O
file_stat	pointer
.	O
st_mode	int
)	O
;	O
}	O
output_is_seekable	char
=	O
true	int
;	O
change_dir	function
(	O
)	O
;	O
while	O
(	O
!	O
done	char
)	O
{	O
swapping_halfwords	int
=	O
swapping_bytes	int
=	O
false	int
;	O
read_in_header	function
(	O
&	O
file_hdr	pointer
,	O
in_file_des	int
)	O
;	O
if	O
(	O
file_hdr	pointer
.	O
c_namesize	short
==	O
0	int
)	O
skip_file	char
=	O
true	int
;	O
else	O
{	O
if	O
(	O
strcmp	function
(	O
CPIO_TRAILER_NAME	pointer
,	O
file_hdr	pointer
.	O
c_name	pointer
)	O
==	O
0	int
)	O
{	O
done	char
=	O
true	int
;	O
break	O
;	O
}	O
cpio_safer_name_suffix	function
(	O
file_hdr	pointer
.	O
c_name	pointer
,	O
false	int
,	O
!	O
no_abs_paths_flag	int
,	O
false	int
)	O
;	O
if	O
(	O
num_patterns	int
<=	O
0	int
)	O
skip_file	char
=	O
false	int
;	O
else	O
{	O
skip_file	char
=	O
copy_matching_files	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_patterns	int
&&	O
skip_file	char
==	O
copy_matching_files	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
fnmatch	function
(	O
save_patterns	pointer
[	O
i	int
]	O
,	O
file_hdr	pointer
.	O
c_name	pointer
,	O
0	int
)	O
==	O
0	int
)	O
skip_file	char
=	O
!	O
copy_matching_files	int
;	O
}	O
}	O
}	O
if	O
(	O
skip_file	char
)	O
{	O
if	O
(	O
file_hdr	pointer
.	O
c_nlink	short
>	O
1	int
&&	O
(	O
archive_format	enum
==	O
arf_newascii	int
||	O
archive_format	enum
==	O
arf_crcascii	int
)	O
)	O
{	O
if	O
(	O
create_defered_links_to_skipped	function
(	O
&	O
file_hdr	pointer
,	O
in_file_des	int
)	O
<	O
0	int
)	O
{	O
tape_toss_input	function
(	O
in_file_des	int
,	O
file_hdr	pointer
.	O
c_filesize	array
)	O
;	O
tape_skip_padding	function
(	O
in_file_des	int
,	O
file_hdr	pointer
.	O
c_filesize	array
)	O
;	O
}	O
}	O
else	O
{	O
tape_toss_input	function
(	O
in_file_des	int
,	O
file_hdr	pointer
.	O
c_filesize	array
)	O
;	O
tape_skip_padding	function
(	O
in_file_des	int
,	O
file_hdr	pointer
.	O
c_filesize	array
)	O
;	O
}	O
}	O
else	O
if	O
(	O
table_flag	int
)	O
{	O
list_file	function
(	O
&	O
file_hdr	pointer
,	O
in_file_des	int
)	O
;	O
}	O
else	O
if	O
(	O
append_flag	int
)	O
{	O
tape_toss_input	function
(	O
in_file_des	int
,	O
file_hdr	pointer
.	O
c_filesize	array
)	O
;	O
tape_skip_padding	function
(	O
in_file_des	int
,	O
file_hdr	pointer
.	O
c_filesize	array
)	O
;	O
}	O
else	O
if	O
(	O
only_verify_crc_flag	int
)	O
{	O
if	O
(	O
(	O
file_hdr	pointer
.	O
c_mode	short
&	O
CP_IFMT	int
)	O
==	O
CP_IFLNK	int
)	O
{	O
if	O
(	O
archive_format	enum
!=	O
arf_tar	int
&&	O
archive_format	enum
!=	O
arf_ustar	int
)	O
{	O
tape_toss_input	function
(	O
in_file_des	int
,	O
file_hdr	pointer
.	O
c_filesize	array
)	O
;	O
tape_skip_padding	function
(	O
in_file_des	int
,	O
file_hdr	pointer
.	O
c_filesize	array
)	O
;	O
continue	O
;	O
}	O
}	O
crc	int
=	O
0	int
;	O
tape_toss_input	function
(	O
in_file_des	int
,	O
file_hdr	pointer
.	O
c_filesize	array
)	O
;	O
tape_skip_padding	function
(	O
in_file_des	int
,	O
file_hdr	pointer
.	O
c_filesize	array
)	O
;	O
if	O
(	O
crc	int
!=	O
file_hdr	pointer
.	O
c_chksum	array
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s: checksum error (0x%x, should be 0x%x)"	pointer
)	O
,	O
file_hdr	pointer
.	O
c_name	pointer
,	O
crc	int
,	O
file_hdr	pointer
.	O
c_chksum	array
)	O
;	O
}	O
if	O
(	O
verbose_flag	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s\n"	pointer
,	O
file_hdr	pointer
.	O
c_name	pointer
)	O
;	O
}	O
if	O
(	O
dot_flag	int
)	O
{	O
fputc	function
(	O
'.'	O
,	O
stderr	pointer
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
rename_flag	int
||	O
rename_batch_file	pointer
)	O
{	O
if	O
(	O
query_rename	function
(	O
&	O
file_hdr	pointer
,	O
tty_in	pointer
,	O
tty_out	pointer
,	O
rename_in	pointer
)	O
<	O
0	int
)	O
{	O
tape_toss_input	function
(	O
in_file_des	int
,	O
file_hdr	pointer
.	O
c_filesize	array
)	O
;	O
tape_skip_padding	function
(	O
in_file_des	int
,	O
file_hdr	pointer
.	O
c_filesize	array
)	O
;	O
continue	O
;	O
}	O
}	O
copyin_file	function
(	O
&	O
file_hdr	pointer
,	O
in_file_des	int
)	O
;	O
if	O
(	O
verbose_flag	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s\n"	pointer
,	O
file_hdr	pointer
.	O
c_name	pointer
)	O
;	O
if	O
(	O
dot_flag	int
)	O
fputc	function
(	O
'.'	O
,	O
stderr	pointer
)	O
;	O
}	O
}	O
if	O
(	O
dot_flag	int
)	O
fputc	function
(	O
'\n'	O
,	O
stderr	pointer
)	O
;	O
apply_delayed_set_stat	function
(	O
)	O
;	O
cpio_file_stat_free	function
(	O
&	O
file_hdr	pointer
)	O
;	O
if	O
(	O
append_flag	int
)	O
return	O
;	O
if	O
(	O
archive_format	enum
==	O
arf_newascii	int
||	O
archive_format	enum
==	O
arf_crcascii	int
)	O
{	O
create_final_defers	function
(	O
)	O
;	O
}	O
if	O
(	O
!	O
quiet_flag	int
)	O
{	O
size_t	long
blocks	long
;	O
blocks	long
=	O
(	O
input_bytes	long
+	O
io_block_size	int
-	O
1	int
)	O
/	O
io_block_size	int
;	O
fprintf	function
(	O
stderr	pointer
,	O
ngettext	function
(	O
"%lu block\n"	pointer
,	O
"%lu blocks\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
blocks	long
)	O
,	O
(	O
unsigned	O
long	O
)	O
blocks	long
)	O
;	O
}	O
}	O
