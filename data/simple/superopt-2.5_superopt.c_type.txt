word	int
random_word	function
(	O
void	O
)	O
;	O
int	O
goal_function_arity	int
;	O
enum	O
goal_func	enum
goal_function	enum
;	O
word	int
(	O
*	O
eval_goal_function	pointer
)	O
(	O
const	O
word	int
*	O
)	O
;	O
int	O
flag_output_assembly	int
=	O
0	int
;	O
int	O
flag_use_carry	int
=	O
1	int
;	O
int	O
flag_shifts	int
=	O
0	int
;	O
int	O
flag_extracts	int
=	O
0	int
;	O
int	O
flag_nl	int
=	O
0	int
;	O
int	O
success	int
;	O
char	O
*	O
insn_name	array
[	O
]	O
=	O
{	O
}	O
;	O
char	O
insn_class	array
[	O
]	O
=	O
{	O
}	O
;	O
void	O
init_immediates	function
(	O
word	int
*	O
values	pointer
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
-	O
1	int
;	O
i	int
<	O
BITS_PER_WORD	int
;	O
i	int
++	O
)	O
values	pointer
[	O
0x20	int
+	O
i	int
]	O
=	O
i	int
;	O
values	pointer
[	O
0x20	int
-	O
2	int
]	O
=	O
VALUE_MIN_SIGNED	O
;	O
values	pointer
[	O
0x20	int
-	O
3	int
]	O
=	O
VALUE_MAX_SIGNED	O
;	O
values	pointer
[	O
0x20	int
-	O
4	int
]	O
=	O
0xFFFF	int
;	O
values	pointer
[	O
0x20	int
-	O
5	int
]	O
=	O
0xFF	int
;	O
}	O
void	O
init_random_word	function
(	O
void	O
)	O
{	O
static	O
char	O
state1	array
[	O
128	int
]	O
=	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
3	int
,	O
0x9a	int
,	O
0x31	int
,	O
0x90	int
,	O
0x39	int
,	O
0x32	int
,	O
0xd9	int
,	O
0xc0	int
,	O
0x24	int
,	O
0x9b	int
,	O
0x66	int
,	O
0x31	int
,	O
0x82	int
,	O
0x5d	int
,	O
0xa1	int
,	O
0xf3	int
,	O
0x42	int
,	O
0x74	int
,	O
0x49	int
,	O
0xe5	int
,	O
0x6b	int
,	O
0xbe	int
,	O
0xb1	int
,	O
0xdb	int
,	O
0xb0	int
,	O
0xab	int
,	O
0x5c	int
,	O
0x59	int
,	O
0x18	int
,	O
0x94	int
,	O
0x65	int
,	O
0x54	int
,	O
0xfd	int
,	O
0x8c	int
,	O
0x2e	int
,	O
0x68	int
,	O
0x0f	int
,	O
0xeb	int
,	O
0x3d	int
,	O
0x79	int
,	O
0x9f	int
,	O
0xb1	int
,	O
0x1e	int
,	O
0xe0	int
,	O
0xb7	int
,	O
0x2d	int
,	O
0x43	int
,	O
0x6b	int
,	O
0x86	int
,	O
0xda	int
,	O
0x67	int
,	O
0x2e	int
,	O
0x2a	int
,	O
0x15	int
,	O
0x88	int
,	O
0xca	int
,	O
0x88	int
,	O
0xe3	int
,	O
0x69	int
,	O
0x73	int
,	O
0x5d	int
,	O
0x90	int
,	O
0x4f	int
,	O
0x35	int
,	O
0xf7	int
,	O
0xd7	int
,	O
0x15	int
,	O
0x8f	int
,	O
0xd6	int
,	O
0x6f	int
,	O
0xa6	int
,	O
0xf0	int
,	O
0x51	int
,	O
0x61	int
,	O
0x6e	int
,	O
0x6b	int
,	O
0x96	int
,	O
0xac	int
,	O
0x94	int
,	O
0xef	int
,	O
0xdc	int
,	O
0xde	int
,	O
0x3b	int
,	O
0x81	int
,	O
0xe0	int
,	O
0xdf	int
,	O
0x0a	int
,	O
0x6f	int
,	O
0xb5	int
,	O
0xf1	int
,	O
0x03	int
,	O
0xbc	int
,	O
0x02	int
,	O
0x48	int
,	O
0xf3	int
,	O
0x40	int
,	O
0xfb	int
,	O
0x36	int
,	O
0x41	int
,	O
0x3f	int
,	O
0x93	int
,	O
0xc6	int
,	O
0x22	int
,	O
0xc2	int
,	O
0x98	int
,	O
0xf5	int
,	O
0xa4	int
,	O
0x2a	int
,	O
0xb8	int
,	O
0x8a	int
,	O
0x88	int
,	O
0xd7	int
,	O
0x7b	int
,	O
0xf5	int
,	O
0xad	int
,	O
0x9d	int
,	O
0x0e	int
,	O
0x89	int
,	O
0x99	int
,	O
0x22	int
,	O
0x0b	int
,	O
0x27	int
,	O
0xfb	int
,	O
0x47	int
,	O
0xb9	int
}	O
;	O
unsigned	O
seed	int
;	O
int	O
n	int
;	O
seed	int
=	O
1	int
;	O
n	int
=	O
128	int
;	O
initstate	function
(	O
seed	int
,	O
(	O
char	O
*	O
)	O
state1	array
,	O
n	int
)	O
;	O
setstate	function
(	O
state1	array
)	O
;	O
}	O
word	int
random_word	function
(	O
void	O
)	O
{	O
word	int
x	int
;	O
unsigned	O
int	O
ran	int
,	O
n_bits	int
;	O
int	O
valid_randbits	int
=	O
0	int
;	O
int	O
tmp	int
,	O
i	int
;	O
RANDOM	O
(	O
tmp	int
,	O
9	int
)	O
;	O
if	O
(	O
tmp	int
<=	O
60	int
)	O
return	O
tmp	int
+	O
4	int
;	O
RANDOM	O
(	O
tmp	int
,	O
1	int
)	O
;	O
x	int
=	O
0	int
;	O
if	O
(	O
tmp	int
)	O
x	int
=	O
~	O
x	int
;	O
n_bits	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
8	int
*	O
sizeof	O
(	O
word	int
)	O
;	O
i	int
>=	O
0	int
;	O
i	int
-=	O
n_bits	int
)	O
{	O
RANDOM	O
(	O
tmp	int
,	O
3	int
)	O
;	O
n_bits	int
=	O
tmp	int
+	O
1	int
;	O
x	int
<<=	O
n_bits	int
;	O
RANDOM	O
(	O
tmp	int
,	O
1	int
)	O
;	O
if	O
(	O
tmp	int
)	O
x	int
|=	O
(	O
(	O
word	int
)	O
1	int
<<	O
n_bits	int
)	O
-	O
1	int
;	O
}	O
return	O
x	int
;	O
}	O
void	O
*	O
malloc	function
(	O
)	O
,	O
*	O
realloc	function
(	O
)	O
;	O
char	O
*	O
xrealloc	function
(	O
ptr	pointer
,	O
size	int
)	O
char	O
*	O
ptr	pointer
;	O
unsigned	O
size	int
;	O
{	O
char	O
*	O
result	pointer
=	O
(	O
char	O
*	O
)	O
realloc	function
(	O
ptr	pointer
,	O
size	int
)	O
;	O
if	O
(	O
!	O
result	pointer
)	O
abort	O
(	O
)	O
;	O
return	O
result	pointer
;	O
}	O
char	O
*	O
xmalloc	function
(	O
size	int
)	O
unsigned	O
size	int
;	O
{	O
register	O
char	O
*	O
val	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
size	int
)	O
;	O
if	O
(	O
val	pointer
==	O
0	int
)	O
abort	O
(	O
)	O
;	O
return	O
val	pointer
;	O
}	O
static	O
void	O
recurse	function
(	O
opcode_t	enum
opcode	enum
,	O
int	O
d	int
,	O
int	O
s1	int
,	O
int	O
s2	int
,	O
word	int
v	int
,	O
int	O
cost	int
,	O
insn_t	struct
*	O
sequence	pointer
,	O
int	O
n_insns	int
,	O
word	int
*	O
values	pointer
,	O
int	O
n_values	int
,	O
const	O
word	int
goal_value	int
,	O
int	O
allowed_cost	int
,	O
int	O
cy	int
,	O
int	O
prune_flags	enum
)	O
{	O
insn_t	struct
insn	struct
;	O
allowed_cost	int
-=	O
cost	int
;	O
if	O
(	O
allowed_cost	int
>	O
0	int
)	O
{	O
word	int
old_d	int
;	O
old_d	int
=	O
values	pointer
[	O
d	int
]	O
;	O
values	pointer
[	O
d	int
]	O
=	O
v	int
;	O
sequence	pointer
[	O
n_insns	int
]	O
=	O
(	O
insn_t	struct
)	O
{	O
opcode	enum
,	O
s1	int
,	O
s2	int
,	O
d	int
}	O
;	O
SYNTH	O
(	O
sequence	pointer
,	O
n_insns	int
+	O
1	int
,	O
values	pointer
,	O
n_values	int
,	O
goal_value	int
,	O
allowed_cost	int
,	O
cy	int
,	O
prune_flags	enum
,	O
nullify_flag	O
)	O
;	O
values	pointer
[	O
d	int
]	O
=	O
old_d	int
;	O
}	O
else	O
if	O
(	O
goal_value	int
==	O
v	int
)	O
{	O
sequence	pointer
[	O
n_insns	int
]	O
=	O
(	O
insn_t	struct
)	O
{	O
opcode	enum
,	O
s1	int
,	O
s2	int
,	O
d	int
}	O
;	O
test_sequence	function
(	O
sequence	pointer
,	O
n_insns	int
+	O
1	int
)	O
;	O
}	O
}	O
static	O
inline	O
void	O
recurse_last	function
(	O
opcode_t	enum
opcode	enum
,	O
int	O
d	int
,	O
int	O
s1	int
,	O
int	O
s2	int
,	O
word	int
v	int
,	O
insn_t	struct
*	O
sequence	pointer
,	O
int	O
n_insns	int
,	O
const	O
word	int
goal_value	int
)	O
{	O
insn_t	struct
insn	struct
;	O
if	O
(	O
goal_value	int
==	O
v	int
)	O
{	O
sequence	pointer
[	O
n_insns	int
]	O
=	O
(	O
insn_t	struct
)	O
{	O
opcode	enum
,	O
s1	int
,	O
s2	int
,	O
d	int
}	O
;	O
test_sequence	function
(	O
sequence	pointer
,	O
n_insns	int
+	O
1	int
)	O
;	O
}	O
}	O
static	O
char	O
*	O
operand_names	array
[	O
256	int
]	O
=	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
}	O
;	O
void	O
output_assembly	function
(	O
insn_t	struct
insn	struct
)	O
{	O
int	O
d	int
,	O
s1	int
,	O
s2	int
;	O
d	int
=	O
insn	struct
.	O
d	int
;	O
s1	int
=	O
insn	struct
.	O
s1	int
;	O
s2	int
=	O
insn	struct
.	O
s2	int
;	O
printf	function
(	O
"\t"	pointer
)	O
;	O
switch	O
(	O
insn	struct
.	O
opcode	enum
)	O
{	O
default	O
:	O
abort	O
(	O
)	O
;	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
word	int
tvalues	array
[	O
0x100	int
]	O
;	O
word	int
*	O
test_sets	pointer
;	O
int	O
n_test_sets	int
;	O
word	int
test_operands	array
[	O
]	O
=	O
{	O
-	O
3	int
,	O
-	O
2	int
,	O
-	O
1	int
,	O
0	int
,	O
1	int
,	O
2	int
,	O
3	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
63	int
,	O
64	int
,	O
VALUE_MIN_SIGNED	O
,	O
VALUE_MAX_SIGNED	O
,	O
VALUE_MIN_SIGNED	O
+	O
1	int
,	O
VALUE_MAX_SIGNED	O
-	O
1	int
,	O
}	O
;	O
void	O
init_test_sets	function
(	O
)	O
{	O
unsigned	O
int	O
loop_vars	array
[	O
8	int
]	O
;	O
int	O
pc	int
,	O
i	int
,	O
j	int
;	O
word	int
*	O
test_set	pointer
;	O
const	O
int	O
arity	int
=	O
goal_function_arity	int
;	O
word	int
(	O
*	O
eval	pointer
)	O
(	O
const	O
word	int
*	O
)	O
=	O
eval_goal_function	pointer
;	O
if	O
(	O
sizeof	O
(	O
loop_vars	array
)	O
/	O
sizeof	O
(	O
loop_vars	array
[	O
0	int
]	O
)	O
<=	O
arity	int
)	O
abort	O
(	O
)	O
;	O
{	O
static	O
int	O
n_words	int
=	O
0	int
;	O
j	int
=	O
1	int
+	O
arity	int
;	O
for	O
(	O
i	int
=	O
arity	int
-	O
1	int
;	O
i	int
>=	O
0	int
;	O
i	int
--	O
)	O
j	int
*=	O
N_TEST_OPERANDS	O
;	O
j	int
+=	O
(	O
1	int
+	O
arity	int
)	O
*	O
N_RANDOM_TEST_OPERANDS	int
;	O
if	O
(	O
n_words	int
<	O
j	int
)	O
{	O
test_sets	pointer
=	O
(	O
n_words	int
==	O
0	int
?	O
(	O
word	int
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
word	int
)	O
*	O
j	int
)	O
:	O
(	O
word	int
*	O
)	O
xrealloc	function
(	O
test_sets	pointer
,	O
sizeof	O
(	O
word	int
)	O
*	O
j	int
)	O
)	O
;	O
n_words	int
=	O
j	int
;	O
}	O
}	O
test_set	pointer
=	O
test_sets	pointer
;	O
j	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
arity	int
-	O
1	int
;	O
i	int
>=	O
0	int
;	O
i	int
--	O
)	O
loop_vars	array
[	O
i	int
]	O
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
for	O
(	O
i	int
=	O
arity	int
-	O
1	int
;	O
i	int
>=	O
0	int
;	O
i	int
--	O
)	O
tvalues	array
[	O
i	int
]	O
=	O
*	O
test_set	pointer
++	O
=	O
test_operands	array
[	O
loop_vars	array
[	O
i	int
]	O
]	O
;	O
*	O
test_set	pointer
++	O
=	O
(	O
*	O
eval	pointer
)	O
(	O
tvalues	array
)	O
;	O
j	int
++	O
;	O
i	int
=	O
0	int
;	O
loop_vars	array
[	O
i	int
]	O
=	O
(	O
loop_vars	array
[	O
i	int
]	O
+	O
1	int
)	O
%	O
N_TEST_OPERANDS	O
;	O
while	O
(	O
loop_vars	array
[	O
i	int
]	O
==	O
0	int
)	O
{	O
i	int
++	O
;	O
if	O
(	O
i	int
>=	O
arity	int
)	O
goto	O
random	function
;	O
loop_vars	array
[	O
i	int
]	O
=	O
(	O
loop_vars	array
[	O
i	int
]	O
+	O
1	int
)	O
%	O
N_TEST_OPERANDS	O
;	O
}	O
}	O
random	function
:	O
for	O
(	O
i	int
=	O
N_RANDOM_TEST_OPERANDS	int
-	O
1	int
;	O
i	int
>=	O
0	int
;	O
i	int
--	O
)	O
{	O
for	O
(	O
pc	int
=	O
arity	int
-	O
1	int
;	O
pc	int
>=	O
0	int
;	O
pc	int
--	O
)	O
tvalues	array
[	O
pc	int
]	O
=	O
*	O
test_set	pointer
++	O
=	O
random_word	function
(	O
)	O
;	O
*	O
test_set	pointer
++	O
=	O
(	O
*	O
eval	pointer
)	O
(	O
tvalues	array
)	O
;	O
j	int
++	O
;	O
}	O
n_test_sets	int
=	O
j	int
;	O
}	O
void	O
print_operand	function
(	O
int	O
op	int
)	O
{	O
if	O
(	O
IMMEDIATE_P	O
(	O
op	int
)	O
)	O
{	O
if	O
(	O
(	O
signed_word	int
)	O
IMMEDIATE_VAL	O
(	O
op	int
)	O
>=	O
10	int
||	O
(	O
signed_word	int
)	O
IMMEDIATE_VAL	O
(	O
op	int
)	O
<=	O
-	O
10	int
)	O
{	O
printf	function
(	O
PSTR	pointer
,	O
IMMEDIATE_VAL	O
(	O
op	int
)	O
)	O
;	O
}	O
else	O
printf	function
(	O
"%d"	pointer
,	O
(	O
int	O
)	O
IMMEDIATE_VAL	O
(	O
op	int
)	O
)	O
;	O
}	O
else	O
printf	function
(	O
"r%u"	pointer
,	O
op	int
)	O
;	O
}	O
void	O
test_sequence	function
(	O
insn_t	struct
*	O
sequence	pointer
,	O
int	O
n_insns	int
)	O
{	O
int	O
pc	int
;	O
int	O
i	int
,	O
j	int
;	O
word	int
*	O
test_set	pointer
=	O
test_sets	pointer
;	O
const	O
int	O
arity	int
=	O
goal_function_arity	int
;	O
for	O
(	O
j	int
=	O
n_test_sets	int
;	O
j	int
>	O
0	int
;	O
j	int
--	O
)	O
{	O
for	O
(	O
i	int
=	O
arity	int
-	O
1	int
;	O
i	int
>=	O
0	int
;	O
i	int
--	O
)	O
tvalues	array
[	O
i	int
]	O
=	O
*	O
test_set	pointer
++	O
;	O
run_program	function
(	O
sequence	pointer
,	O
n_insns	int
,	O
tvalues	array
)	O
;	O
if	O
(	O
tvalues	array
[	O
sequence	pointer
[	O
n_insns	int
-	O
1	int
]	O
.	O
d	int
]	O
!=	O
*	O
test_set	pointer
++	O
)	O
{	O
if	O
(	O
(	O
j	int
=	O
n_test_sets	int
-	O
j	int
)	O
!=	O
0	int
)	O
{	O
int	O
k	int
=	O
j	int
>>	O
1	int
;	O
j	int
*=	O
(	O
arity	int
+	O
1	int
)	O
;	O
k	int
*=	O
(	O
arity	int
+	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
arity	int
;	O
i	int
++	O
)	O
{	O
word	int
t	int
=	O
test_sets	pointer
[	O
j	int
+	O
i	int
]	O
;	O
test_sets	pointer
[	O
j	int
+	O
i	int
]	O
=	O
test_sets	pointer
[	O
k	int
+	O
i	int
]	O
;	O
test_sets	pointer
[	O
k	int
+	O
i	int
]	O
=	O
t	int
;	O
}	O
}	O
return	O
;	O
}	O
}	O
if	O
(	O
success	int
==	O
0	int
||	O
flag_nl	int
)	O
printf	function
(	O
"\n"	pointer
)	O
;	O
success	int
++	O
;	O
printf	function
(	O
"%d:"	pointer
,	O
success	int
)	O
;	O
for	O
(	O
pc	int
=	O
0	int
;	O
pc	int
<	O
n_insns	int
;	O
pc	int
++	O
)	O
{	O
insn_t	struct
insn	struct
;	O
insn	struct
=	O
sequence	pointer
[	O
pc	int
]	O
;	O
if	O
(	O
flag_output_assembly	int
)	O
output_assembly	function
(	O
insn	struct
)	O
;	O
else	O
{	O
if	O
(	O
GET_INSN_CLASS	O
(	O
insn	struct
.	O
opcode	enum
)	O
==	O
'='	O
||	O
GET_INSN_CLASS	O
(	O
insn	struct
.	O
opcode	enum
)	O
==	O
'<'	O
)	O
printf	function
(	O
"\t%s("	pointer
,	O
GET_INSN_NAME	O
(	O
insn	struct
.	O
opcode	enum
)	O
)	O
;	O
else	O
printf	function
(	O
"\tr%u:=%s("	pointer
,	O
insn	struct
.	O
d	int
,	O
GET_INSN_NAME	O
(	O
insn	struct
.	O
opcode	enum
)	O
)	O
;	O
print_operand	function
(	O
insn	struct
.	O
s1	int
)	O
;	O
if	O
(	O
!	O
UNARY_OPERATION	O
(	O
insn	struct
)	O
)	O
{	O
printf	function
(	O
","	pointer
)	O
;	O
print_operand	function
(	O
insn	struct
.	O
s2	int
)	O
;	O
}	O
printf	function
(	O
")\n"	pointer
)	O
;	O
}	O
}	O
fflush	function
(	O
stdout	pointer
)	O
;	O
}	O
void	O
main_synth	function
(	O
int	O
maxmax_cost	int
,	O
int	O
allowed_extra_cost	int
)	O
{	O
int	O
max_cost	int
;	O
word	int
values	pointer
[	O
0x100	int
]	O
;	O
insn_t	struct
sequence	pointer
[	O
0x100	int
]	O
;	O
int	O
i	int
,	O
ii	int
;	O
init_immediates	function
(	O
tvalues	array
)	O
;	O
init_immediates	function
(	O
values	pointer
)	O
;	O
init_random_word	function
(	O
)	O
;	O
init_test_sets	function
(	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
50	int
;	O
i	int
++	O
)	O
{	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
goal_function_arity	int
;	O
ii	int
++	O
)	O
values	pointer
[	O
ii	int
]	O
=	O
random_word	function
(	O
)	O
;	O
if	O
(	O
(	O
*	O
eval_goal_function	pointer
)	O
(	O
values	pointer
)	O
!=	O
0	int
)	O
break	O
;	O
}	O
ii	int
=	O
0	int
;	O
printf	function
(	O
"Superoptimizing at cost"	pointer
)	O
;	O
success	int
=	O
0	int
;	O
for	O
(	O
max_cost	int
=	O
1	int
;	O
max_cost	int
<=	O
maxmax_cost	int
;	O
max_cost	int
++	O
)	O
{	O
if	O
(	O
success	int
)	O
printf	function
(	O
"[cost %d]\n"	pointer
,	O
max_cost	int
+	O
ii	int
)	O
;	O
else	O
printf	function
(	O
" %d"	pointer
,	O
max_cost	int
+	O
ii	int
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
i	int
=	O
run_program	function
(	O
sequence	pointer
,	O
ii	int
,	O
values	pointer
)	O
;	O
SYNTH	O
(	O
sequence	pointer
,	O
ii	int
,	O
values	pointer
,	O
goal_function_arity	int
+	O
ii	int
,	O
(	O
*	O
eval_goal_function	pointer
)	O
(	O
values	pointer
)	O
,	O
max_cost	int
,	O
i	int
,	O
NO_PRUNE	int
,	O
NOT_NULLIFY	O
)	O
;	O
if	O
(	O
success	int
)	O
{	O
allowed_extra_cost	int
--	O
;	O
if	O
(	O
allowed_extra_cost	int
<	O
0	int
)	O
{	O
static	O
char	O
*	O
s	array
[	O
]	O
=	O
{	O
""	pointer
,	O
"s"	pointer
}	O
;	O
printf	function
(	O
"[%d sequence%s found]\n"	pointer
,	O
success	int
,	O
s	array
[	O
success	int
!=	O
1	int
]	O
)	O
;	O
return	O
;	O
}	O
}	O
}	O
printf	function
(	O
" failure.\n"	pointer
)	O
;	O
}	O
struct	O
{	O
char	O
*	O
fname	pointer
;	O
enum	O
goal_func	enum
fcode	enum
;	O
int	O
arity	int
;	O
char	O
*	O
c_code	pointer
;	O
word	int
(	O
*	O
function	pointer
)	O
(	O
const	O
word	int
*	O
)	O
;	O
}	O
goal_table	array
[	O
]	O
=	O
{	O
}	O
;	O
extern	O
char	O
*	O
strrchr	function
(	O
)	O
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
maxmax_cost	int
=	O
4	int
;	O
int	O
allowed_extra_cost	int
=	O
0	int
;	O
int	O
flag_all	int
=	O
0	int
;	O
char	O
*	O
program	pointer
=	O
strrchr	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
'/'	O
)	O
;	O
if	O
(	O
!	O
program	pointer
)	O
program	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
else	O
program	pointer
++	O
;	O
goal_function	enum
=	O
LAST_AND_UNUSED_GOAL_CODE	int
;	O
argv	pointer
++	O
;	O
argc	int
--	O
;	O
while	O
(	O
argc	int
>	O
0	int
)	O
{	O
char	O
*	O
arg	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
int	O
arglen	int
=	O
strlen	function
(	O
arg	pointer
)	O
;	O
if	O
(	O
arglen	int
<	O
2	int
)	O
arglen	int
=	O
2	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
arg	pointer
,	O
"-version"	pointer
,	O
arglen	int
)	O
)	O
{	O
printf	function
(	O
"%s version %s\n"	pointer
,	O
program	pointer
,	O
version_string	pointer
)	O
;	O
printf	function
(	O
"(%s)\n"	pointer
,	O
TARGET_STRING	O
)	O
;	O
if	O
(	O
argc	int
==	O
1	int
)	O
exit	O
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
arg	pointer
,	O
"-assembly"	pointer
,	O
arglen	int
)	O
)	O
flag_output_assembly	int
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
arg	pointer
,	O
"-no-carry-insns"	pointer
,	O
arglen	int
)	O
)	O
flag_use_carry	int
=	O
0	int
;	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
arg	pointer
,	O
"-all"	pointer
,	O
arglen	int
)	O
)	O
flag_all	int
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
arg	pointer
,	O
"-nl"	pointer
,	O
arglen	int
)	O
)	O
flag_nl	int
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
arg	pointer
,	O
"-shifts"	pointer
,	O
arglen	int
)	O
)	O
flag_shifts	int
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
arg	pointer
,	O
"-extracts"	pointer
,	O
arglen	int
)	O
)	O
flag_extracts	int
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
arg	pointer
,	O
"-max-cost"	pointer
,	O
arglen	int
)	O
)	O
{	O
argv	pointer
++	O
;	O
argc	int
--	O
;	O
if	O
(	O
argc	int
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"superoptimizer: argument to `-max-cost' expected\n"	pointer
)	O
;	O
exit	O
(	O
-	O
1	int
)	O
;	O
}	O
maxmax_cost	int
=	O
atoi	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
arg	pointer
,	O
"-extra-cost"	pointer
,	O
arglen	int
)	O
)	O
{	O
argv	pointer
++	O
;	O
argc	int
--	O
;	O
if	O
(	O
argc	int
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"superoptimizer: argument `-extra-cost' expected\n"	pointer
)	O
;	O
exit	O
(	O
-	O
1	int
)	O
;	O
}	O
allowed_extra_cost	int
=	O
atoi	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
arg	pointer
,	O
"-f"	pointer
,	O
2	int
)	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
goal_table	array
)	O
/	O
sizeof	O
(	O
goal_table	array
[	O
0	int
]	O
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
arg	pointer
+	O
2	int
,	O
goal_table	array
[	O
i	int
]	O
.	O
fname	pointer
)	O
)	O
{	O
goal_function	enum
=	O
goal_table	array
[	O
i	int
]	O
.	O
fcode	enum
;	O
goal_function_arity	int
=	O
GET_GOAL_ARITY	O
(	O
goal_function	enum
)	O
;	O
eval_goal_function	pointer
=	O
GET_GOAL_FUNCTION	O
(	O
goal_function	enum
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
goal_function	enum
==	O
LAST_AND_UNUSED_GOAL_CODE	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"superoptimizer: unknown goal function\n"	pointer
)	O
;	O
exit	O
(	O
-	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
int	O
i	int
,	O
len	int
,	O
maxlen	int
,	O
cols	int
,	O
maxcols	int
;	O
char	O
*	O
prefix	pointer
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Calling sequence:\n\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\t%s -f<goal-function> [-assembly] [-max-cost n] \\\n"	pointer
,	O
program	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\t\t[-no-carry-insns] [-extra-cost n] [-nl]\n\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Target machine: %s\n\n"	pointer
,	O
TARGET_STRING	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Supported goal functions:\n\n"	pointer
)	O
;	O
maxlen	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
goal_table	array
)	O
/	O
sizeof	O
(	O
goal_table	array
[	O
0	int
]	O
)	O
;	O
i	int
++	O
)	O
{	O
len	int
=	O
strlen	function
(	O
goal_table	array
[	O
i	int
]	O
.	O
fname	pointer
)	O
;	O
if	O
(	O
len	int
>	O
maxlen	int
)	O
maxlen	int
=	O
len	int
;	O
}	O
maxcols	int
=	O
79	int
/	O
(	O
maxlen	int
+	O
2	int
)	O
;	O
if	O
(	O
maxcols	int
<	O
1	int
)	O
maxcols	int
=	O
1	int
;	O
cols	int
=	O
1	int
;	O
prefix	pointer
=	O
""	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
goal_table	array
)	O
/	O
sizeof	O
(	O
goal_table	array
[	O
0	int
]	O
)	O
;	O
i	int
++	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s  %-*s"	pointer
,	O
prefix	pointer
,	O
maxlen	int
,	O
goal_table	array
[	O
i	int
]	O
.	O
fname	pointer
)	O
;	O
cols	int
++	O
;	O
if	O
(	O
cols	int
>	O
maxcols	int
)	O
{	O
cols	int
=	O
1	int
;	O
prefix	pointer
=	O
"\n"	pointer
;	O
}	O
else	O
prefix	pointer
=	O
""	pointer
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
exit	O
(	O
-	O
1	int
)	O
;	O
}	O
argv	pointer
++	O
;	O
argc	int
--	O
;	O
}	O
if	O
(	O
flag_all	int
)	O
{	O
for	O
(	O
goal_function	enum
=	O
0	int
;	O
goal_function	enum
<	O
LAST_AND_UNUSED_GOAL_CODE	int
;	O
goal_function	enum
++	O
)	O
{	O
printf	function
(	O
"Searching for goal %s: "	pointer
,	O
GET_GOAL_NAME	O
(	O
goal_function	enum
)	O
)	O
;	O
printf	function
(	O
"%s\n"	pointer
,	O
GET_GOAL_C_CODE	O
(	O
goal_function	enum
)	O
)	O
;	O
goal_function_arity	int
=	O
GET_GOAL_ARITY	O
(	O
goal_function	enum
)	O
;	O
eval_goal_function	pointer
=	O
GET_GOAL_FUNCTION	O
(	O
goal_function	enum
)	O
;	O
main_synth	function
(	O
maxmax_cost	int
,	O
allowed_extra_cost	int
)	O
;	O
}	O
exit	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
goal_function	enum
==	O
LAST_AND_UNUSED_GOAL_CODE	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"superoptimizer: missing goal function definition\n"	pointer
)	O
;	O
exit	O
(	O
-	O
1	int
)	O
;	O
}	O
printf	function
(	O
"Searching for %s\n"	pointer
,	O
GET_GOAL_C_CODE	O
(	O
goal_function	enum
)	O
)	O
;	O
main_synth	function
(	O
maxmax_cost	int
,	O
allowed_extra_cost	int
)	O
;	O
exit	O
(	O
!	O
success	int
)	O
;	O
}	O
int	O
ffs_internal	function
(	O
x	int
)	O
word	int
x	int
;	O
{	O
int	O
co	int
,	O
ci	int
=	O
-	O
1	int
;	O
word	int
d	int
;	O
PERFORM_FFS	O
(	O
d	int
,	O
co	int
,	O
x	int
,	O
ci	int
)	O
;	O
return	O
d	int
;	O
}	O
int	O
floor_log2	function
(	O
x	int
)	O
word	int
x	int
;	O
{	O
register	O
int	O
log	int
=	O
-	O
1	int
;	O
while	O
(	O
x	int
!=	O
0	int
)	O
log	int
++	O
,	O
x	int
>>=	O
1	int
;	O
return	O
log	int
;	O
}	O
int	O
ceil_log2	function
(	O
x	int
)	O
word	int
x	int
;	O
{	O
return	O
floor_log2	function
(	O
x	int
-	O
1	int
)	O
+	O
1	int
;	O
}	O
const	O
char	O
clz_tab	array
[	O
]	O
=	O
{	O
32	int
,	O
31	int
,	O
30	int
,	O
30	int
,	O
29	int
,	O
29	int
,	O
29	int
,	O
29	int
,	O
28	int
,	O
28	int
,	O
28	int
,	O
28	int
,	O
28	int
,	O
28	int
,	O
28	int
,	O
28	int
,	O
27	int
,	O
27	int
,	O
27	int
,	O
27	int
,	O
27	int
,	O
27	int
,	O
27	int
,	O
27	int
,	O
27	int
,	O
27	int
,	O
27	int
,	O
27	int
,	O
27	int
,	O
27	int
,	O
27	int
,	O
27	int
,	O
26	int
,	O
26	int
,	O
26	int
,	O
26	int
,	O
26	int
,	O
26	int
,	O
26	int
,	O
26	int
,	O
26	int
,	O
26	int
,	O
26	int
,	O
26	int
,	O
26	int
,	O
26	int
,	O
26	int
,	O
26	int
,	O
26	int
,	O
26	int
,	O
26	int
,	O
26	int
,	O
26	int
,	O
26	int
,	O
26	int
,	O
26	int
,	O
26	int
,	O
26	int
,	O
26	int
,	O
26	int
,	O
26	int
,	O
26	int
,	O
26	int
,	O
26	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
}	O
;	O
const	O
char	O
ctz_tab	array
[	O
]	O
=	O
{	O
8	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
3	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
4	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
3	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
5	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
3	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
4	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
3	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
6	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
3	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
4	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
3	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
5	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
3	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
4	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
3	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
7	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
3	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
4	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
3	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
5	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
3	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
4	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
3	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
6	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
3	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
4	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
3	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
5	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
3	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
4	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
3	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
}	O
;	O
const	O
char	O
ff1_tab	array
[	O
]	O
=	O
{	O
32	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
4	int
,	O
4	int
,	O
4	int
,	O
4	int
,	O
4	int
,	O
4	int
,	O
4	int
,	O
4	int
,	O
4	int
,	O
4	int
,	O
4	int
,	O
4	int
,	O
4	int
,	O
4	int
,	O
4	int
,	O
4	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
}	O
;	O
