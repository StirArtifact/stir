kern_return_t	O
_pager_S_memory_object_data_unlock	function
(	O
struct	O
pager	struct
*	O
p	pointer
,	O
mach_port_t	O
control	int
,	O
vm_offset_t	int
offset	int
,	O
vm_size_t	int
length	int
,	O
vm_prot_t	int
access	int
)	O
{	O
volatile	O
int	O
err	int
;	O
if	O
(	O
!	O
p	pointer
||	O
p	pointer
->	O
port	struct
.	O
class	O
!=	O
_pager_class	pointer
)	O
return	O
EOPNOTSUPP	O
;	O
if	O
(	O
p	pointer
->	O
pager_state	enum
!=	O
NORMAL	int
)	O
{	O
printf	O
(	O
"pager in wrong state for unlock\n"	pointer
)	O
;	O
goto	O
out	O
;	O
}	O
if	O
(	O
control	int
!=	O
p	pointer
->	O
memobjcntl	int
)	O
{	O
printf	O
(	O
"incg data unlock: wrong control port\n"	pointer
)	O
;	O
goto	O
out	O
;	O
}	O
if	O
(	O
(	O
access	int
&	O
VM_PROT_WRITE	O
)	O
==	O
0	int
)	O
{	O
printf	O
(	O
"incg data unlock: not unlock writes\n"	pointer
)	O
;	O
goto	O
out	O
;	O
}	O
if	O
(	O
offset	int
%	O
__vm_page_size	O
)	O
{	O
printf	O
(	O
"incg data unlock: misaligned request\n"	pointer
)	O
;	O
goto	O
out	O
;	O
}	O
if	O
(	O
length	int
!=	O
__vm_page_size	O
)	O
{	O
printf	O
(	O
"incg data unlock: bad length size %zd\n"	pointer
,	O
length	int
)	O
;	O
goto	O
out	O
;	O
}	O
err	int
=	O
pager_unlock_page	function
(	O
p	pointer
->	O
upi	pointer
,	O
offset	int
)	O
;	O
if	O
(	O
!	O
err	int
)	O
_pager_lock_object	function
(	O
p	pointer
,	O
offset	int
,	O
length	int
,	O
MEMORY_OBJECT_RETURN_NONE	O
,	O
0	int
,	O
VM_PROT_NONE	O
,	O
0	int
)	O
;	O
else	O
{	O
_pager_lock_object	function
(	O
p	pointer
,	O
offset	int
,	O
length	int
,	O
MEMORY_OBJECT_RETURN_NONE	O
,	O
1	int
,	O
VM_PROT_WRITE	O
,	O
0	int
)	O
;	O
_pager_mark_next_request_error	function
(	O
p	pointer
,	O
offset	int
,	O
length	int
,	O
err	int
)	O
;	O
}	O
out	O
:	O
return	O
0	int
;	O
}	O
