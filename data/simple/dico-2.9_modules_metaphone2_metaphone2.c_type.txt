struct	O
metaph_segment	struct
{	O
char	O
segm	array
[	O
METAPH_SEGM_SIZE	int
]	O
;	O
struct	O
metaph_segment	struct
*	O
next	pointer
;	O
}	O
;	O
struct	O
metaph_code	struct
{	O
size_t	long
length	long
;	O
size_t	long
nsegm	long
;	O
struct	O
metaph_segment	struct
*	O
segm_head	pointer
,	O
*	O
segm_tail	pointer
;	O
}	O
;	O
static	O
size_t	long
metaph_code_length	function
(	O
struct	O
metaph_code	struct
*	O
code	int
)	O
{	O
return	O
code	int
?	O
code	int
->	O
length	long
:	O
0	int
;	O
}	O
static	O
void	O
metaph_code_trim	function
(	O
struct	O
metaph_code	struct
*	O
code	int
,	O
size_t	long
length	long
)	O
{	O
if	O
(	O
code	int
&&	O
code	int
->	O
length	long
>	O
length	long
)	O
code	int
->	O
length	long
=	O
length	long
;	O
}	O
static	O
struct	O
metaph_code	struct
*	O
metaph_code_create	function
(	O
void	O
)	O
{	O
struct	O
metaph_code	struct
*	O
code	int
=	O
malloc	function
(	O
sizeof	O
*	O
code	int
)	O
;	O
if	O
(	O
code	int
)	O
{	O
code	int
->	O
length	long
=	O
0	int
;	O
code	int
->	O
nsegm	long
=	O
0	int
;	O
code	int
->	O
segm_head	pointer
=	O
code	int
->	O
segm_tail	pointer
=	O
NULL	O
;	O
}	O
return	O
code	int
;	O
}	O
static	O
struct	O
metaph_segment	struct
*	O
metaph_code_alloc_segment	function
(	O
struct	O
metaph_code	struct
*	O
code	int
)	O
{	O
struct	O
metaph_segment	struct
*	O
newseg	pointer
=	O
malloc	function
(	O
sizeof	O
newseg	pointer
[	O
0	int
]	O
)	O
;	O
if	O
(	O
!	O
newseg	pointer
)	O
return	O
NULL	O
;	O
newseg	pointer
->	O
next	pointer
=	O
NULL	O
;	O
memset	function
(	O
newseg	pointer
->	O
segm	array
,	O
0	int
,	O
METAPH_SEGM_SIZE	int
)	O
;	O
if	O
(	O
code	int
->	O
segm_tail	pointer
)	O
code	int
->	O
segm_tail	pointer
->	O
next	pointer
=	O
newseg	pointer
;	O
else	O
code	int
->	O
segm_head	pointer
=	O
newseg	pointer
;	O
code	int
->	O
segm_tail	pointer
=	O
newseg	pointer
;	O
code	int
->	O
nsegm	long
++	O
;	O
return	O
newseg	pointer
;	O
}	O
static	O
struct	O
metaph_code	struct
*	O
metaph_code_dup	function
(	O
struct	O
metaph_code	struct
*	O
src	pointer
)	O
{	O
struct	O
metaph_code	struct
*	O
dst	pointer
=	O
metaph_code_create	function
(	O
)	O
;	O
struct	O
metaph_segment	struct
*	O
src_segm	pointer
,	O
*	O
dst_segm	pointer
;	O
if	O
(	O
!	O
dst	pointer
)	O
return	O
NULL	O
;	O
for	O
(	O
src_segm	pointer
=	O
src	pointer
->	O
segm_head	pointer
;	O
src_segm	pointer
;	O
src_segm	pointer
=	O
src_segm	pointer
->	O
next	pointer
)	O
{	O
dst_segm	pointer
=	O
metaph_code_alloc_segment	function
(	O
dst	pointer
)	O
;	O
memcpy	function
(	O
dst_segm	pointer
->	O
segm	array
,	O
src_segm	pointer
->	O
segm	array
,	O
METAPH_SEGM_SIZE	int
)	O
;	O
}	O
dst	pointer
->	O
length	long
=	O
src	pointer
->	O
length	long
;	O
return	O
dst	pointer
;	O
}	O
static	O
void	O
metaph_code_free	function
(	O
struct	O
metaph_code	struct
*	O
code	int
)	O
{	O
if	O
(	O
code	int
)	O
{	O
struct	O
metaph_segment	struct
*	O
s	pointer
=	O
code	int
->	O
segm_head	pointer
;	O
while	O
(	O
s	pointer
)	O
{	O
struct	O
metaph_segment	struct
*	O
next	pointer
=	O
s	pointer
->	O
next	pointer
;	O
free	function
(	O
s	pointer
)	O
;	O
s	pointer
=	O
next	pointer
;	O
}	O
free	function
(	O
code	int
)	O
;	O
}	O
}	O
static	O
int	O
metaph_code_eq	function
(	O
struct	O
metaph_code	struct
*	O
a	pointer
,	O
struct	O
metaph_code	struct
*	O
b	pointer
)	O
{	O
struct	O
metaph_segment	struct
*	O
sa	pointer
,	O
*	O
sb	pointer
;	O
size_t	long
length	long
;	O
if	O
(	O
a	pointer
==	O
NULL	O
||	O
b	pointer
==	O
NULL	O
)	O
return	O
0	int
;	O
if	O
(	O
a	pointer
->	O
length	long
!=	O
b	pointer
->	O
length	long
)	O
return	O
0	int
;	O
length	long
=	O
a	pointer
->	O
length	long
;	O
sa	pointer
=	O
a	pointer
->	O
segm_head	pointer
;	O
sb	pointer
=	O
b	pointer
->	O
segm_head	pointer
;	O
while	O
(	O
length	long
)	O
{	O
size_t	long
segm_length	long
=	O
length	long
<	O
METAPH_SEGM_SIZE	int
?	O
length	long
:	O
METAPH_SEGM_SIZE	int
;	O
if	O
(	O
memcmp	function
(	O
sa	pointer
->	O
segm	array
,	O
sb	pointer
->	O
segm	array
,	O
segm_length	long
)	O
)	O
return	O
0	int
;	O
length	long
-=	O
segm_length	long
;	O
sa	pointer
=	O
sa	pointer
->	O
next	pointer
;	O
sb	pointer
=	O
sb	pointer
->	O
next	pointer
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
metaph_code_get_buffer	function
(	O
struct	O
metaph_code	struct
*	O
code	int
,	O
char	O
*	O
*	O
ret_ptr	pointer
,	O
size_t	long
*	O
ret_size	pointer
)	O
{	O
size_t	long
s	pointer
=	O
code	int
->	O
nsegm	long
*	O
METAPH_SEGM_SIZE	int
-	O
code	int
->	O
length	long
;	O
if	O
(	O
s	pointer
==	O
0	int
)	O
{	O
if	O
(	O
!	O
metaph_code_alloc_segment	function
(	O
code	int
)	O
)	O
return	O
-	O
1	int
;	O
s	pointer
=	O
METAPH_SEGM_SIZE	int
;	O
}	O
*	O
ret_ptr	pointer
=	O
code	int
->	O
segm_tail	pointer
->	O
segm	array
+	O
code	int
->	O
length	long
%	O
METAPH_SEGM_SIZE	int
;	O
*	O
ret_size	pointer
=	O
s	pointer
;	O
return	O
0	int
;	O
}	O
static	O
int	O
metaph_code_add	function
(	O
struct	O
metaph_code	struct
*	O
code	int
,	O
char	O
const	O
*	O
str	pointer
)	O
{	O
if	O
(	O
str	pointer
)	O
{	O
size_t	long
length	long
=	O
strlen	function
(	O
str	pointer
)	O
;	O
while	O
(	O
length	long
)	O
{	O
char	O
*	O
p	pointer
;	O
size_t	long
n	long
;	O
if	O
(	O
metaph_code_get_buffer	function
(	O
code	int
,	O
&	O
p	pointer
,	O
&	O
n	long
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
n	long
>	O
length	long
)	O
n	long
=	O
length	long
;	O
memcpy	function
(	O
p	pointer
,	O
str	pointer
,	O
n	long
)	O
;	O
str	pointer
+=	O
n	long
;	O
code	int
->	O
length	long
+=	O
n	long
;	O
length	long
-=	O
n	long
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
metaph_code_dump	function
(	O
struct	O
metaph_code	struct
*	O
code	int
)	O
{	O
if	O
(	O
!	O
code	int
)	O
printf	function
(	O
"%s\n"	pointer
,	O
"NULL"	pointer
)	O
;	O
else	O
{	O
struct	O
metaph_segment	struct
*	O
s	pointer
;	O
size_t	long
length	long
;	O
printf	function
(	O
"length = %zu\n"	pointer
,	O
code	int
->	O
length	long
)	O
;	O
printf	function
(	O
"nsegm = %zu\n"	pointer
,	O
code	int
->	O
nsegm	long
)	O
;	O
length	long
=	O
code	int
->	O
length	long
;	O
for	O
(	O
s	pointer
=	O
code	int
->	O
segm_head	pointer
;	O
s	pointer
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
{	O
size_t	long
i	long
;	O
putchar	function
(	O
'\''	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
length	long
>	O
0	int
&&	O
i	long
<	O
METAPH_SEGM_SIZE	int
;	O
i	long
++	O
,	O
length	long
--	O
)	O
putchar	function
(	O
s	pointer
->	O
segm	array
[	O
i	long
]	O
)	O
;	O
printf	function
(	O
"'\n"	pointer
)	O
;	O
}	O
}	O
}	O
static	O
void	O
metaph_code_print	function
(	O
struct	O
metaph_code	struct
*	O
code	int
)	O
{	O
if	O
(	O
!	O
code	int
)	O
printf	function
(	O
"%s\n"	pointer
,	O
"NULL"	pointer
)	O
;	O
else	O
{	O
struct	O
metaph_segment	struct
*	O
s	pointer
;	O
size_t	long
length	long
;	O
length	long
=	O
code	int
->	O
length	long
;	O
for	O
(	O
s	pointer
=	O
code	int
->	O
segm_head	pointer
;	O
s	pointer
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
length	long
>	O
0	int
&&	O
i	long
<	O
METAPH_SEGM_SIZE	int
;	O
i	long
++	O
,	O
length	long
--	O
)	O
putchar	function
(	O
s	pointer
->	O
segm	array
[	O
i	long
]	O
)	O
;	O
}	O
}	O
}	O
typedef	O
struct	O
metaph_code	struct
*	O
double_metaphone_code	array
[	O
2	int
]	O
;	O
static	O
int	O
double_metaphone_add	function
(	O
double_metaphone_code	array
code	int
,	O
char	O
const	O
*	O
primary	pointer
,	O
char	O
const	O
*	O
secondary	pointer
)	O
{	O
if	O
(	O
secondary	pointer
)	O
{	O
if	O
(	O
!	O
code	int
[	O
1	int
]	O
)	O
{	O
code	int
[	O
1	int
]	O
=	O
metaph_code_dup	function
(	O
code	int
[	O
0	int
]	O
)	O
;	O
if	O
(	O
!	O
code	int
[	O
1	int
]	O
)	O
{	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
metaph_code_add	function
(	O
code	int
[	O
1	int
]	O
,	O
secondary	pointer
)	O
)	O
return	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
code	int
[	O
1	int
]	O
)	O
{	O
if	O
(	O
metaph_code_add	function
(	O
code	int
[	O
1	int
]	O
,	O
primary	pointer
)	O
)	O
return	O
-	O
1	int
;	O
}	O
metaph_code_add	function
(	O
code	int
[	O
0	int
]	O
,	O
primary	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
looking_at	function
(	O
unsigned	O
const	O
*	O
str	pointer
,	O
size_t	long
pos	long
,	O
int	O
off	int
,	O
char	O
const	O
*	O
pat	pointer
)	O
{	O
size_t	long
i	long
;	O
if	O
(	O
off	int
<	O
0	int
&&	O
pos	long
<	O
-	O
off	int
)	O
return	O
0	int
;	O
pos	long
+=	O
off	int
;	O
i	long
=	O
pos	long
;	O
while	O
(	O
*	O
pat	pointer
)	O
{	O
if	O
(	O
*	O
pat	pointer
==	O
str	pointer
[	O
i	long
]	O
)	O
{	O
++	O
i	long
;	O
++	O
pat	pointer
;	O
if	O
(	O
!	O
*	O
pat	pointer
||	O
*	O
pat	pointer
==	O
'|'	O
)	O
return	O
1	int
;	O
}	O
else	O
{	O
while	O
(	O
*	O
pat	pointer
&&	O
*	O
pat	pointer
!=	O
'|'	O
)	O
++	O
pat	pointer
;	O
if	O
(	O
*	O
pat	pointer
)	O
++	O
pat	pointer
;	O
i	long
=	O
pos	long
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
double_metaphone_free	function
(	O
double_metaphone_code	array
code	int
)	O
{	O
metaph_code_free	function
(	O
code	int
[	O
0	int
]	O
)	O
;	O
metaph_code_free	function
(	O
code	int
[	O
1	int
]	O
)	O
;	O
}	O
static	O
int	O
is_slavo_germanic	function
(	O
unsigned	O
const	O
*	O
str	pointer
)	O
{	O
static	O
unsigned	O
pat	pointer
[	O
]	O
=	O
{	O
'W'	O
,	O
0	int
,	O
'K'	O
,	O
0	int
,	O
'C'	O
,	O
'Z'	O
,	O
0	int
,	O
'W'	O
,	O
'I'	O
,	O
'T'	O
,	O
'Z'	O
,	O
0	int
,	O
0	int
}	O
;	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
pat	pointer
[	O
i	long
]	O
;	O
i	long
++	O
)	O
{	O
if	O
(	O
utf8_wc_strstr	function
(	O
str	pointer
,	O
pat	pointer
)	O
)	O
return	O
1	int
;	O
while	O
(	O
pat	pointer
[	O
i	long
]	O
)	O
++	O
i	long
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
double_metaphone_encode	function
(	O
double_metaphone_code	array
code	int
,	O
char	O
const	O
*	O
str	pointer
,	O
size_t	long
max_length	long
)	O
{	O
unsigned	O
*	O
buf	pointer
;	O
size_t	long
current	long
=	O
0	int
;	O
size_t	long
length	long
,	O
last	long
;	O
int	O
slavo_germanic	int
=	O
-	O
1	int
;	O
if	O
(	O
utf8_mbstr_to_wc	function
(	O
str	pointer
,	O
&	O
buf	pointer
,	O
NULL	O
)	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
errno	O
,	O
"%s: cannot convert \"%s\""	pointer
,	O
__func__	O
,	O
str	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
length	long
=	O
utf8_wc_strlen	function
(	O
buf	pointer
)	O
;	O
last	long
=	O
length	long
-	O
1	int
;	O
code	int
[	O
0	int
]	O
=	O
metaph_code_create	function
(	O
)	O
;	O
if	O
(	O
!	O
code	int
[	O
0	int
]	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"%s: not enough memory"	pointer
)	O
,	O
__func__	O
)	O
;	O
free	function
(	O
buf	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
code	int
[	O
1	int
]	O
=	O
NULL	O
;	O
utf8_wc_strupper	function
(	O
buf	pointer
)	O
;	O
current	long
=	O
0	int
;	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
0	int
,	O
"GN|KN|PN|WR|PS"	pointer
)	O
)	O
++	O
current	long
;	O
while	O
(	O
current	long
<	O
length	long
&&	O
(	O
max_length	long
==	O
0	int
||	O
metaph_code_length	function
(	O
code	int
[	O
0	int
]	O
)	O
<	O
max_length	long
||	O
metaph_code_length	function
(	O
code	int
[	O
1	int
]	O
)	O
<	O
max_length	long
)	O
)	O
{	O
switch	O
(	O
buf	pointer
[	O
current	long
]	O
)	O
{	O
case	O
'A'	O
:	O
case	O
'E'	O
:	O
case	O
'I'	O
:	O
case	O
'O'	O
:	O
case	O
'U'	O
:	O
case	O
'Y'	O
:	O
if	O
(	O
current	long
==	O
0	int
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"A"	pointer
,	O
NULL	O
)	O
;	O
current	long
++	O
;	O
break	O
;	O
case	O
'B'	O
:	O
DMETAPH_ADD	O
(	O
code	int
,	O
"P"	pointer
,	O
NULL	O
)	O
;	O
++	O
current	long
;	O
if	O
(	O
buf	pointer
[	O
current	long
]	O
==	O
'B'	O
)	O
++	O
current	long
;	O
break	O
;	O
case	O
L'Ç'	O
:	O
DMETAPH_ADD	O
(	O
code	int
,	O
"S"	pointer
,	O
NULL	O
)	O
;	O
++	O
current	long
;	O
break	O
;	O
case	O
'C'	O
:	O
if	O
(	O
current	long
>	O
1	int
&&	O
!	O
ISVOWEL	O
(	O
buf	pointer
,	O
current	long
,	O
-	O
2	int
)	O
&&	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
-	O
1	int
,	O
"ACH"	pointer
)	O
&&	O
buf	pointer
[	O
current	long
+	O
2	int
]	O
!=	O
'I'	O
&&	O
(	O
buf	pointer
[	O
current	long
+	O
2	int
]	O
!=	O
'E'	O
||	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
-	O
2	int
,	O
"BACHER|MACHER"	pointer
)	O
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"K"	pointer
,	O
NULL	O
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
current	long
==	O
0	int
&&	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
0	int
,	O
"CAESAR"	pointer
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"S"	pointer
,	O
NULL	O
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
0	int
,	O
"CHIA"	pointer
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"K"	pointer
,	O
NULL	O
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
0	int
,	O
"CH"	pointer
)	O
)	O
{	O
if	O
(	O
current	long
>	O
0	int
&&	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
0	int
,	O
"CHAE"	pointer
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"K"	pointer
,	O
"X"	pointer
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
current	long
==	O
0	int
&&	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
1	int
,	O
"HARAC|HARIS|HOR|HYM|HIA|HEM"	pointer
)	O
)	O
&&	O
!	O
looking_at	function
(	O
buf	pointer
,	O
0	int
,	O
0	int
,	O
"CHORE"	pointer
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"K"	pointer
,	O
NULL	O
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
(	O
looking_at	function
(	O
buf	pointer
,	O
0	int
,	O
0	int
,	O
"VAN |VON "	pointer
)	O
||	O
looking_at	function
(	O
buf	pointer
,	O
0	int
,	O
0	int
,	O
"SCH"	pointer
)	O
)	O
||	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
-	O
2	int
,	O
"ORCHES|ARCHIT|ORCHID"	pointer
)	O
||	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
+	O
2	int
,	O
"T|S"	pointer
)	O
||	O
(	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
-	O
1	int
,	O
"A|O|U|E"	pointer
)	O
||	O
current	long
==	O
0	int
)	O
&&	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
+	O
2	int
,	O
"L|R|N|M|B|H|F|V|W| "	pointer
)	O
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"K"	pointer
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
current	long
>	O
0	int
)	O
{	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
0	int
,	O
0	int
,	O
"MC"	pointer
)	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"K"	pointer
,	O
NULL	O
)	O
;	O
else	O
DMETAPH_ADD	O
(	O
code	int
,	O
"X"	pointer
,	O
"K"	pointer
)	O
;	O
}	O
else	O
DMETAPH_ADD	O
(	O
code	int
,	O
"X"	pointer
,	O
NULL	O
)	O
;	O
}	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
0	int
,	O
"CZ"	pointer
)	O
&&	O
!	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
-	O
2	int
,	O
"WICZ"	pointer
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"S"	pointer
,	O
"X"	pointer
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
+	O
1	int
,	O
"CIA"	pointer
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"X"	pointer
,	O
NULL	O
)	O
;	O
current	long
+=	O
3	int
;	O
break	O
;	O
}	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
0	int
,	O
"CC"	pointer
)	O
&&	O
!	O
(	O
current	long
==	O
1	int
&&	O
buf	pointer
[	O
0	int
]	O
==	O
'M'	O
)	O
)	O
{	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
+	O
2	int
,	O
"I|E|H"	pointer
)	O
&&	O
!	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
+	O
2	int
,	O
"HU"	pointer
)	O
)	O
{	O
if	O
(	O
(	O
current	long
==	O
1	int
&&	O
buf	pointer
[	O
current	long
-	O
1	int
]	O
==	O
'A'	O
)	O
||	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
-	O
1	int
,	O
"UCCEE|UCCES"	pointer
)	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"KS"	pointer
,	O
NULL	O
)	O
;	O
else	O
DMETAPH_ADD	O
(	O
code	int
,	O
"X"	pointer
,	O
NULL	O
)	O
;	O
current	long
+=	O
3	int
;	O
break	O
;	O
}	O
else	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"K"	pointer
,	O
NULL	O
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
0	int
,	O
"CK|CG|CQ"	pointer
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"K"	pointer
,	O
NULL	O
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
0	int
,	O
"CI|CE|CY"	pointer
)	O
)	O
{	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
0	int
,	O
"CIO|CIE|CIA"	pointer
)	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"S"	pointer
,	O
"X"	pointer
)	O
;	O
else	O
DMETAPH_ADD	O
(	O
code	int
,	O
"S"	pointer
,	O
NULL	O
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
DMETAPH_ADD	O
(	O
code	int
,	O
"K"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
+	O
1	int
,	O
" C| Q| G"	pointer
)	O
)	O
current	long
+=	O
3	int
;	O
else	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
+	O
1	int
,	O
"C|K|Q"	pointer
)	O
&&	O
!	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
+	O
1	int
,	O
"CE|CI"	pointer
)	O
)	O
current	long
+=	O
2	int
;	O
else	O
current	long
++	O
;	O
break	O
;	O
case	O
'D'	O
:	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
0	int
,	O
"DG"	pointer
)	O
)	O
{	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
+	O
2	int
,	O
"I|E|Y"	pointer
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"J"	pointer
,	O
NULL	O
)	O
;	O
current	long
+=	O
3	int
;	O
break	O
;	O
}	O
else	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"TK"	pointer
,	O
NULL	O
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
0	int
,	O
"DT|DD"	pointer
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"T"	pointer
,	O
NULL	O
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
DMETAPH_ADD	O
(	O
code	int
,	O
"T"	pointer
,	O
NULL	O
)	O
;	O
current	long
++	O
;	O
break	O
;	O
case	O
'F'	O
:	O
++	O
current	long
;	O
if	O
(	O
buf	pointer
[	O
current	long
]	O
==	O
'F'	O
)	O
++	O
current	long
;	O
DMETAPH_ADD	O
(	O
code	int
,	O
"F"	pointer
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
'G'	O
:	O
if	O
(	O
buf	pointer
[	O
current	long
+	O
1	int
]	O
==	O
'H'	O
)	O
{	O
if	O
(	O
(	O
current	long
>	O
0	int
)	O
&&	O
!	O
ISVOWEL	O
(	O
buf	pointer
,	O
current	long
,	O
-	O
1	int
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"K"	pointer
,	O
NULL	O
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
current	long
<	O
3	int
)	O
{	O
if	O
(	O
current	long
==	O
0	int
)	O
{	O
if	O
(	O
buf	pointer
[	O
current	long
+	O
2	int
]	O
==	O
'I'	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"J"	pointer
,	O
NULL	O
)	O
;	O
else	O
DMETAPH_ADD	O
(	O
code	int
,	O
"K"	pointer
,	O
NULL	O
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
(	O
current	long
>	O
1	int
&&	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
-	O
2	int
,	O
"B|H|D"	pointer
)	O
)	O
||	O
(	O
current	long
>	O
2	int
&&	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
-	O
3	int
,	O
"B|H|D"	pointer
)	O
)	O
||	O
(	O
current	long
>	O
3	int
&&	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
-	O
4	int
,	O
"B|H"	pointer
)	O
)	O
)	O
{	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
else	O
{	O
if	O
(	O
current	long
>	O
2	int
&&	O
buf	pointer
[	O
current	long
-	O
1	int
]	O
==	O
'U'	O
&&	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
-	O
3	int
,	O
"C|G|L|R|T"	pointer
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"F"	pointer
,	O
NULL	O
)	O
;	O
}	O
else	O
if	O
(	O
current	long
>	O
0	int
&&	O
buf	pointer
[	O
current	long
-	O
1	int
]	O
!=	O
'I'	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"K"	pointer
,	O
NULL	O
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
buf	pointer
[	O
current	long
+	O
1	int
]	O
==	O
'N'	O
)	O
{	O
if	O
(	O
current	long
==	O
1	int
&&	O
ISVOWEL	O
(	O
buf	pointer
,	O
0	int
,	O
0	int
)	O
&&	O
!	O
IS_SLAVO_GERMANIC	O
(	O
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"KN"	pointer
,	O
"N"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
+	O
2	int
,	O
"EY"	pointer
)	O
&&	O
(	O
buf	pointer
[	O
current	long
+	O
1	int
]	O
!=	O
'Y'	O
)	O
&&	O
!	O
IS_SLAVO_GERMANIC	O
(	O
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"N"	pointer
,	O
"KN"	pointer
)	O
;	O
}	O
else	O
DMETAPH_ADD	O
(	O
code	int
,	O
"KN"	pointer
,	O
NULL	O
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
+	O
1	int
,	O
"LI"	pointer
)	O
&&	O
!	O
IS_SLAVO_GERMANIC	O
(	O
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"KL"	pointer
,	O
"L"	pointer
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
current	long
==	O
0	int
&&	O
(	O
buf	pointer
[	O
current	long
+	O
1	int
]	O
==	O
'Y'	O
||	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
+	O
1	int
,	O
"ES|EP|EB|EL|EY|IB|IL|IN|IE|EI|ER"	pointer
)	O
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"K"	pointer
,	O
"J"	pointer
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
+	O
1	int
,	O
"ER"	pointer
)	O
||	O
(	O
buf	pointer
[	O
current	long
+	O
1	int
]	O
==	O
'Y'	O
)	O
)	O
&&	O
!	O
looking_at	function
(	O
buf	pointer
,	O
0	int
,	O
0	int
,	O
"DANGER|RANGER|MANGER"	pointer
)	O
&&	O
!	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
-	O
1	int
,	O
"E|I|RGY|OGY"	pointer
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"K"	pointer
,	O
"J"	pointer
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
+	O
1	int
,	O
"E|I|Y"	pointer
)	O
||	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
-	O
1	int
,	O
"AGGI|OGGI"	pointer
)	O
)	O
{	O
if	O
(	O
(	O
looking_at	function
(	O
buf	pointer
,	O
0	int
,	O
0	int
,	O
"VAN |VON "	pointer
)	O
||	O
looking_at	function
(	O
buf	pointer
,	O
0	int
,	O
0	int
,	O
"SCH"	pointer
)	O
)	O
||	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
+	O
1	int
,	O
"ET"	pointer
)	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"K"	pointer
,	O
NULL	O
)	O
;	O
else	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
+	O
1	int
,	O
"IER "	pointer
)	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"J"	pointer
,	O
NULL	O
)	O
;	O
else	O
DMETAPH_ADD	O
(	O
code	int
,	O
"J"	pointer
,	O
"K"	pointer
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
++	O
current	long
;	O
if	O
(	O
buf	pointer
[	O
current	long
]	O
==	O
'G'	O
)	O
++	O
current	long
;	O
DMETAPH_ADD	O
(	O
code	int
,	O
"K"	pointer
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
'H'	O
:	O
if	O
(	O
(	O
current	long
==	O
0	int
||	O
ISVOWEL	O
(	O
buf	pointer
,	O
current	long
,	O
-	O
1	int
)	O
)	O
&&	O
ISVOWEL	O
(	O
buf	pointer
,	O
current	long
,	O
+	O
1	int
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"H"	pointer
,	O
NULL	O
)	O
;	O
current	long
+=	O
2	int
;	O
}	O
else	O
current	long
++	O
;	O
break	O
;	O
case	O
'J'	O
:	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
0	int
,	O
"JOSE"	pointer
)	O
||	O
looking_at	function
(	O
buf	pointer
,	O
0	int
,	O
0	int
,	O
"SAN "	pointer
)	O
)	O
{	O
if	O
(	O
(	O
current	long
==	O
0	int
&&	O
buf	pointer
[	O
current	long
+	O
4	int
]	O
==	O
' '	O
)	O
||	O
looking_at	function
(	O
buf	pointer
,	O
0	int
,	O
0	int
,	O
"SAN "	pointer
)	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"H"	pointer
,	O
NULL	O
)	O
;	O
else	O
DMETAPH_ADD	O
(	O
code	int
,	O
"J"	pointer
,	O
"H"	pointer
)	O
;	O
current	long
++	O
;	O
break	O
;	O
}	O
if	O
(	O
current	long
==	O
0	int
&&	O
!	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
0	int
,	O
"JOSE"	pointer
)	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"J"	pointer
,	O
"A"	pointer
)	O
;	O
else	O
if	O
(	O
ISVOWEL	O
(	O
buf	pointer
,	O
current	long
,	O
-	O
1	int
)	O
&&	O
!	O
IS_SLAVO_GERMANIC	O
(	O
)	O
&&	O
(	O
buf	pointer
[	O
current	long
+	O
1	int
]	O
==	O
'A'	O
||	O
buf	pointer
[	O
current	long
+	O
1	int
]	O
==	O
'O'	O
)	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"J"	pointer
,	O
"H"	pointer
)	O
;	O
else	O
if	O
(	O
current	long
==	O
last	long
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"J"	pointer
,	O
" "	pointer
)	O
;	O
else	O
if	O
(	O
!	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
+	O
1	int
,	O
"L|T|K|S|N|M|B|Z"	pointer
)	O
&&	O
!	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
-	O
1	int
,	O
"S|K|L"	pointer
)	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"J"	pointer
,	O
NULL	O
)	O
;	O
++	O
current	long
;	O
if	O
(	O
buf	pointer
[	O
current	long
]	O
==	O
'J'	O
)	O
++	O
current	long
;	O
break	O
;	O
case	O
'K'	O
:	O
++	O
current	long
;	O
if	O
(	O
buf	pointer
[	O
current	long
]	O
==	O
'K'	O
)	O
++	O
current	long
;	O
DMETAPH_ADD	O
(	O
code	int
,	O
"K"	pointer
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
'L'	O
:	O
if	O
(	O
buf	pointer
[	O
current	long
+	O
1	int
]	O
==	O
'L'	O
)	O
{	O
if	O
(	O
(	O
current	long
==	O
length	long
-	O
3	int
&&	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
-	O
1	int
,	O
"ILLO|ILLA|ALLE"	pointer
)	O
)	O
||	O
(	O
(	O
looking_at	function
(	O
buf	pointer
,	O
last	long
,	O
-	O
1	int
,	O
"AS|OS"	pointer
)	O
||	O
looking_at	function
(	O
buf	pointer
,	O
last	long
,	O
0	int
,	O
"A|O"	pointer
)	O
)	O
&&	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
-	O
1	int
,	O
"ALLE"	pointer
)	O
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"L"	pointer
,	O
" "	pointer
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
current	long
+=	O
2	int
;	O
}	O
else	O
current	long
++	O
;	O
DMETAPH_ADD	O
(	O
code	int
,	O
"L"	pointer
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
'M'	O
:	O
if	O
(	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
-	O
1	int
,	O
"UMB"	pointer
)	O
&&	O
(	O
current	long
+	O
1	int
==	O
last	long
||	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
+	O
2	int
,	O
"ER"	pointer
)	O
)	O
)	O
||	O
(	O
buf	pointer
[	O
current	long
+	O
1	int
]	O
==	O
'M'	O
)	O
)	O
current	long
+=	O
2	int
;	O
else	O
current	long
++	O
;	O
DMETAPH_ADD	O
(	O
code	int
,	O
"M"	pointer
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
'N'	O
:	O
++	O
current	long
;	O
if	O
(	O
buf	pointer
[	O
current	long
]	O
==	O
'N'	O
)	O
++	O
current	long
;	O
DMETAPH_ADD	O
(	O
code	int
,	O
"N"	pointer
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
L'Ń'	O
:	O
case	O
L'Ñ'	O
:	O
current	long
++	O
;	O
DMETAPH_ADD	O
(	O
code	int
,	O
"N"	pointer
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
'P'	O
:	O
if	O
(	O
buf	pointer
[	O
current	long
+	O
1	int
]	O
==	O
'H'	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"F"	pointer
,	O
NULL	O
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
+	O
1	int
,	O
"P|B"	pointer
)	O
)	O
current	long
+=	O
2	int
;	O
else	O
current	long
++	O
;	O
DMETAPH_ADD	O
(	O
code	int
,	O
"P"	pointer
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
'Q'	O
:	O
++	O
current	long
;	O
if	O
(	O
buf	pointer
[	O
current	long
]	O
==	O
'Q'	O
)	O
++	O
current	long
;	O
DMETAPH_ADD	O
(	O
code	int
,	O
"K"	pointer
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
'R'	O
:	O
if	O
(	O
current	long
==	O
last	long
&&	O
!	O
IS_SLAVO_GERMANIC	O
(	O
)	O
&&	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
-	O
2	int
,	O
"IE"	pointer
)	O
&&	O
!	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
-	O
4	int
,	O
"ME|MA"	pointer
)	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
NULL	O
,	O
"R"	pointer
)	O
;	O
else	O
DMETAPH_ADD	O
(	O
code	int
,	O
"R"	pointer
,	O
NULL	O
)	O
;	O
++	O
current	long
;	O
if	O
(	O
buf	pointer
[	O
current	long
]	O
==	O
'R'	O
)	O
++	O
current	long
;	O
break	O
;	O
case	O
'S'	O
:	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
-	O
1	int
,	O
"ISL|YSL"	pointer
)	O
)	O
{	O
current	long
++	O
;	O
break	O
;	O
}	O
if	O
(	O
current	long
==	O
0	int
&&	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
0	int
,	O
"SUGAR"	pointer
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"X"	pointer
,	O
"S"	pointer
)	O
;	O
current	long
++	O
;	O
break	O
;	O
}	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
0	int
,	O
"SH"	pointer
)	O
)	O
{	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
+	O
1	int
,	O
"HEIM|HOEK|HOLM|HOLZ"	pointer
)	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"S"	pointer
,	O
NULL	O
)	O
;	O
else	O
DMETAPH_ADD	O
(	O
code	int
,	O
"X"	pointer
,	O
NULL	O
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
0	int
,	O
"SIO|SIA"	pointer
)	O
||	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
0	int
,	O
"SIAN"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
IS_SLAVO_GERMANIC	O
(	O
)	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"S"	pointer
,	O
"X"	pointer
)	O
;	O
else	O
DMETAPH_ADD	O
(	O
code	int
,	O
"S"	pointer
,	O
NULL	O
)	O
;	O
current	long
+=	O
3	int
;	O
break	O
;	O
}	O
if	O
(	O
(	O
current	long
==	O
0	int
&&	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
+	O
1	int
,	O
"M|N|L|W"	pointer
)	O
)	O
||	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
+	O
1	int
,	O
"Z"	pointer
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"S"	pointer
,	O
"X"	pointer
)	O
;	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
+	O
1	int
,	O
"Z"	pointer
)	O
)	O
current	long
+=	O
2	int
;	O
else	O
current	long
++	O
;	O
break	O
;	O
}	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
0	int
,	O
"SC"	pointer
)	O
)	O
{	O
if	O
(	O
buf	pointer
[	O
current	long
+	O
2	int
]	O
==	O
'H'	O
)	O
{	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
+	O
3	int
,	O
"OO|ER|EN|UY|ED|EM"	pointer
)	O
)	O
{	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
+	O
3	int
,	O
"ER|EN"	pointer
)	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"X"	pointer
,	O
"SK"	pointer
)	O
;	O
else	O
DMETAPH_ADD	O
(	O
code	int
,	O
"SK"	pointer
,	O
NULL	O
)	O
;	O
current	long
+=	O
3	int
;	O
break	O
;	O
}	O
else	O
{	O
if	O
(	O
current	long
==	O
0	int
&&	O
!	O
ISVOWEL	O
(	O
buf	pointer
,	O
3	int
,	O
0	int
)	O
&&	O
buf	pointer
[	O
3	int
]	O
!=	O
'W'	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"X"	pointer
,	O
"S"	pointer
)	O
;	O
else	O
DMETAPH_ADD	O
(	O
code	int
,	O
"X"	pointer
,	O
NULL	O
)	O
;	O
current	long
+=	O
3	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
+	O
2	int
,	O
"I|E|Y"	pointer
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"S"	pointer
,	O
NULL	O
)	O
;	O
current	long
+=	O
3	int
;	O
break	O
;	O
}	O
DMETAPH_ADD	O
(	O
code	int
,	O
"SK"	pointer
,	O
NULL	O
)	O
;	O
current	long
+=	O
3	int
;	O
break	O
;	O
}	O
if	O
(	O
current	long
==	O
last	long
&&	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
-	O
2	int
,	O
"AI|OI"	pointer
)	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
NULL	O
,	O
"S"	pointer
)	O
;	O
else	O
DMETAPH_ADD	O
(	O
code	int
,	O
"S"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
+	O
1	int
,	O
"S|Z"	pointer
)	O
)	O
current	long
+=	O
2	int
;	O
else	O
current	long
++	O
;	O
break	O
;	O
case	O
'T'	O
:	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
0	int
,	O
"TION"	pointer
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"X"	pointer
,	O
NULL	O
)	O
;	O
current	long
+=	O
3	int
;	O
break	O
;	O
}	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
0	int
,	O
"TIA|TCH"	pointer
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"X"	pointer
,	O
NULL	O
)	O
;	O
current	long
+=	O
3	int
;	O
break	O
;	O
}	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
0	int
,	O
"TH|TTH"	pointer
)	O
)	O
{	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
+	O
2	int
,	O
"OM|AM"	pointer
)	O
||	O
looking_at	function
(	O
buf	pointer
,	O
0	int
,	O
0	int
,	O
"VAN |VON |SCH"	pointer
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"T"	pointer
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"0"	pointer
,	O
"T"	pointer
)	O
;	O
}	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
+	O
1	int
,	O
"T|D"	pointer
)	O
)	O
current	long
+=	O
2	int
;	O
else	O
current	long
++	O
;	O
DMETAPH_ADD	O
(	O
code	int
,	O
"T"	pointer
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
'V'	O
:	O
if	O
(	O
buf	pointer
[	O
current	long
+	O
1	int
]	O
==	O
'V'	O
)	O
current	long
+=	O
2	int
;	O
else	O
current	long
++	O
;	O
DMETAPH_ADD	O
(	O
code	int
,	O
"F"	pointer
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
'W'	O
:	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
0	int
,	O
"WR"	pointer
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"R"	pointer
,	O
NULL	O
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
current	long
==	O
0	int
&&	O
(	O
ISVOWEL	O
(	O
buf	pointer
,	O
current	long
,	O
+	O
1	int
)	O
||	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
0	int
,	O
"WH"	pointer
)	O
)	O
)	O
{	O
if	O
(	O
ISVOWEL	O
(	O
buf	pointer
,	O
current	long
,	O
+	O
1	int
)	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"A"	pointer
,	O
"F"	pointer
)	O
;	O
else	O
DMETAPH_ADD	O
(	O
code	int
,	O
"A"	pointer
,	O
NULL	O
)	O
;	O
}	O
if	O
(	O
(	O
current	long
==	O
last	long
&&	O
ISVOWEL	O
(	O
buf	pointer
,	O
current	long
,	O
-	O
1	int
)	O
)	O
||	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
-	O
1	int
,	O
"EWSKI|EWSKY|OWSKI|OWSKY"	pointer
)	O
||	O
looking_at	function
(	O
buf	pointer
,	O
0	int
,	O
0	int
,	O
"SCH"	pointer
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
NULL	O
,	O
"F"	pointer
)	O
;	O
current	long
++	O
;	O
break	O
;	O
}	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
0	int
,	O
"WICZ|WITZ"	pointer
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"TS"	pointer
,	O
"FX"	pointer
)	O
;	O
current	long
+=	O
4	int
;	O
break	O
;	O
}	O
current	long
++	O
;	O
break	O
;	O
case	O
'X'	O
:	O
if	O
(	O
!	O
(	O
current	long
==	O
last	long
&&	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
-	O
3	int
,	O
"IAU|EAU"	pointer
)	O
||	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
-	O
2	int
,	O
"AU|OU"	pointer
)	O
)	O
)	O
)	O
DMETAPH_ADD	O
(	O
code	int
,	O
"KS"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
+	O
1	int
,	O
"C|X"	pointer
)	O
)	O
current	long
+=	O
2	int
;	O
else	O
current	long
++	O
;	O
break	O
;	O
case	O
'Z'	O
:	O
if	O
(	O
buf	pointer
[	O
current	long
+	O
1	int
]	O
==	O
'H'	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"J"	pointer
,	O
NULL	O
)	O
;	O
current	long
+=	O
2	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
looking_at	function
(	O
buf	pointer
,	O
current	long
,	O
+	O
1	int
,	O
"ZO|ZI|ZA"	pointer
)	O
||	O
(	O
IS_SLAVO_GERMANIC	O
(	O
)	O
&&	O
(	O
current	long
>	O
0	int
&&	O
buf	pointer
[	O
current	long
-	O
1	int
]	O
!=	O
'T'	O
)	O
)	O
)	O
{	O
DMETAPH_ADD	O
(	O
code	int
,	O
"S"	pointer
,	O
"TS"	pointer
)	O
;	O
}	O
else	O
DMETAPH_ADD	O
(	O
code	int
,	O
"S"	pointer
,	O
NULL	O
)	O
;	O
++	O
current	long
;	O
if	O
(	O
buf	pointer
[	O
current	long
]	O
==	O
'Z'	O
)	O
++	O
current	long
;	O
break	O
;	O
default	O
:	O
++	O
current	long
;	O
}	O
}	O
free	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
max_length	long
)	O
{	O
metaph_code_trim	function
(	O
code	int
[	O
0	int
]	O
,	O
max_length	long
)	O
;	O
metaph_code_trim	function
(	O
code	int
[	O
1	int
]	O
,	O
max_length	long
)	O
;	O
}	O
return	O
0	int
;	O
err	int
:	O
free	function
(	O
buf	pointer
)	O
;	O
double_metaphone_free	function
(	O
code	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
static	O
int	O
double_metaphone_eq	function
(	O
double_metaphone_code	array
a	pointer
,	O
double_metaphone_code	array
b	pointer
)	O
{	O
return	O
metaph_code_eq	function
(	O
a	pointer
[	O
0	int
]	O
,	O
b	pointer
[	O
0	int
]	O
)	O
||	O
metaph_code_eq	function
(	O
a	pointer
[	O
1	int
]	O
,	O
b	pointer
[	O
1	int
]	O
)	O
||	O
metaph_code_eq	function
(	O
a	pointer
[	O
0	int
]	O
,	O
b	pointer
[	O
1	int
]	O
)	O
||	O
metaph_code_eq	function
(	O
a	pointer
[	O
1	int
]	O
,	O
b	pointer
[	O
0	int
]	O
)	O
;	O
}	O
static	O
size_t	long
double_metaphone_length	long
=	O
4	int
;	O
static	O
int	O
metaphone2_sel	function
(	O
int	O
cmd	int
,	O
struct	O
dico_key	struct
*	O
key	pointer
,	O
const	O
char	O
*	O
dict_word	pointer
)	O
{	O
double_metaphone_code	array
code	int
;	O
int	O
res	int
;	O
switch	O
(	O
cmd	int
)	O
{	O
case	O
DICO_SELECT_BEGIN	int
:	O
if	O
(	O
double_metaphone_encode	function
(	O
code	int
,	O
key	pointer
->	O
word	pointer
,	O
double_metaphone_length	long
)	O
)	O
return	O
1	int
;	O
key	pointer
->	O
call_data	pointer
=	O
malloc	function
(	O
sizeof	O
code	int
)	O
;	O
if	O
(	O
!	O
key	pointer
->	O
call_data	pointer
)	O
return	O
1	int
;	O
memcpy	function
(	O
key	pointer
->	O
call_data	pointer
,	O
code	int
,	O
sizeof	O
(	O
code	int
)	O
)	O
;	O
break	O
;	O
case	O
DICO_SELECT_RUN	int
:	O
if	O
(	O
double_metaphone_encode	function
(	O
code	int
,	O
dict_word	pointer
,	O
double_metaphone_length	long
)	O
)	O
return	O
1	int
;	O
res	int
=	O
double_metaphone_eq	function
(	O
*	O
(	O
double_metaphone_code	array
*	O
)	O
key	pointer
->	O
call_data	pointer
,	O
code	int
)	O
;	O
double_metaphone_free	function
(	O
code	int
)	O
;	O
return	O
res	int
;	O
case	O
DICO_SELECT_END	int
:	O
double_metaphone_free	function
(	O
*	O
(	O
double_metaphone_code	array
*	O
)	O
key	pointer
->	O
call_data	pointer
)	O
;	O
free	function
(	O
key	pointer
->	O
call_data	pointer
)	O
;	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
dico_strategy	struct
metaphone2_strat	struct
=	O
{	O
"metaphone2"	pointer
,	O
"Match Double Metaphone encodings"	pointer
,	O
metaphone2_sel	function
}	O
;	O
static	O
int	O
metaphone2_init	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
long	O
size	long
=	O
0	int
;	O
struct	O
dico_option	struct
metaphone2_option	array
[	O
]	O
=	O
{	O
{	O
DICO_OPTSTR	O
(	O
size	long
)	O
,	O
dico_opt_long	int
,	O
&	O
size	long
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
if	O
(	O
dico_parseopt	function
(	O
metaphone2_option	array
,	O
argc	int
,	O
argv	pointer
,	O
0	int
,	O
NULL	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
size	long
>	O
0	int
)	O
double_metaphone_length	long
=	O
size	long
;	O
dico_strategy_add	function
(	O
&	O
metaphone2_strat	struct
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
metaphone2_run_test	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
char	O
*	O
modname	pointer
,	O
*	O
cmd	int
;	O
argc	int
--	O
;	O
modname	pointer
=	O
*	O
argv	pointer
++	O
;	O
dico_set_program_name	function
(	O
modname	pointer
)	O
;	O
if	O
(	O
argc	int
==	O
0	int
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
"bad argument list"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
argc	int
--	O
;	O
cmd	int
=	O
*	O
argv	pointer
++	O
;	O
if	O
(	O
strcmp	function
(	O
cmd	int
,	O
"build"	pointer
)	O
==	O
0	int
)	O
{	O
struct	O
metaph_code	struct
*	O
code	int
;	O
code	int
=	O
metaph_code_create	function
(	O
)	O
;	O
assert	O
(	O
code	int
!=	O
NULL	O
)	O
;	O
while	O
(	O
argc	int
--	O
)	O
{	O
int	O
res	int
=	O
metaph_code_add	function
(	O
code	int
,	O
*	O
argv	pointer
++	O
)	O
;	O
assert	O
(	O
res	int
==	O
0	int
)	O
;	O
}	O
metaph_code_dump	function
(	O
code	int
)	O
;	O
metaph_code_free	function
(	O
code	int
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
cmd	int
,	O
"compare"	pointer
)	O
==	O
0	int
)	O
{	O
struct	O
metaph_code	struct
*	O
a	pointer
,	O
*	O
b	pointer
;	O
int	O
res	int
;	O
a	pointer
=	O
metaph_code_create	function
(	O
)	O
;	O
assert	O
(	O
a	pointer
!=	O
NULL	O
)	O
;	O
while	O
(	O
argc	int
--	O
)	O
{	O
char	O
*	O
arg	pointer
=	O
*	O
argv	pointer
++	O
;	O
if	O
(	O
strcmp	function
(	O
arg	pointer
,	O
":"	pointer
)	O
==	O
0	int
)	O
break	O
;	O
else	O
{	O
res	int
=	O
metaph_code_add	function
(	O
a	pointer
,	O
arg	pointer
)	O
;	O
assert	O
(	O
res	int
==	O
0	int
)	O
;	O
}	O
}	O
if	O
(	O
argc	int
<=	O
0	int
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
"bad argument list"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
b	pointer
=	O
metaph_code_create	function
(	O
)	O
;	O
assert	O
(	O
b	pointer
!=	O
NULL	O
)	O
;	O
while	O
(	O
argc	int
--	O
)	O
{	O
res	int
=	O
metaph_code_add	function
(	O
b	pointer
,	O
*	O
argv	pointer
++	O
)	O
;	O
assert	O
(	O
res	int
==	O
0	int
)	O
;	O
}	O
res	int
=	O
metaph_code_eq	function
(	O
a	pointer
,	O
b	pointer
)	O
;	O
metaph_code_free	function
(	O
a	pointer
)	O
;	O
metaph_code_free	function
(	O
b	pointer
)	O
;	O
printf	function
(	O
"%d\n"	pointer
,	O
res	int
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
cmd	int
,	O
"encode"	pointer
)	O
==	O
0	int
)	O
{	O
unsigned	O
long	O
len	int
=	O
0	int
;	O
if	O
(	O
strncmp	function
(	O
*	O
argv	pointer
,	O
"-length="	pointer
,	O
8	int
)	O
==	O
0	int
)	O
{	O
char	O
*	O
p	pointer
;	O
len	int
=	O
strtoul	function
(	O
*	O
argv	pointer
+	O
8	int
,	O
&	O
p	pointer
,	O
10	int
)	O
;	O
assert	O
(	O
*	O
p	pointer
==	O
0	int
)	O
;	O
--	O
argc	int
;	O
++	O
argv	pointer
;	O
}	O
while	O
(	O
argc	int
--	O
)	O
{	O
char	O
*	O
arg	pointer
=	O
*	O
argv	pointer
++	O
;	O
double_metaphone_code	array
code	int
;	O
if	O
(	O
double_metaphone_encode	function
(	O
code	int
,	O
arg	pointer
,	O
len	int
)	O
)	O
dico_log	function
(	O
L_ERR	int
,	O
errno	O
,	O
"can't encode"	pointer
)	O
;	O
else	O
{	O
printf	function
(	O
"%s: "	pointer
,	O
arg	pointer
)	O
;	O
if	O
(	O
code	int
[	O
0	int
]	O
)	O
{	O
printf	function
(	O
"'"	pointer
)	O
;	O
metaph_code_print	function
(	O
code	int
[	O
0	int
]	O
)	O
;	O
printf	function
(	O
"'"	pointer
)	O
;	O
}	O
else	O
{	O
printf	function
(	O
"NULL"	pointer
)	O
;	O
}	O
printf	function
(	O
" -- "	pointer
)	O
;	O
if	O
(	O
code	int
[	O
1	int
]	O
)	O
{	O
printf	function
(	O
"'"	pointer
)	O
;	O
metaph_code_print	function
(	O
code	int
[	O
1	int
]	O
)	O
;	O
printf	function
(	O
"'"	pointer
)	O
;	O
}	O
else	O
{	O
printf	function
(	O
"NULL"	pointer
)	O
;	O
}	O
putchar	function
(	O
'\n'	O
)	O
;	O
double_metaphone_free	function
(	O
code	int
)	O
;	O
}	O
}	O
}	O
else	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
"unrecognized unit test: %s"	pointer
,	O
cmd	int
)	O
;	O
dico_log	function
(	O
L_INFO	int
,	O
0	int
,	O
"usage:"	pointer
)	O
;	O
printf	function
(	O
"usage: %s build SEQ [SEQ...]\n"	pointer
"   build a metaphone code block from the sequence of letters\n"	pointer
,	O
modname	pointer
)	O
;	O
printf	function
(	O
"       %s compare SEQ [SEQ...] : SEQ [SEQ...]\n"	pointer
"   build two blocks and compare them\n"	pointer
,	O
modname	pointer
)	O
;	O
printf	function
(	O
"       %s encode [-length=N] WORD [WORD...]\n"	pointer
"   encode the supplied words\n"	pointer
,	O
modname	pointer
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
struct	O
dico_database_module	struct
DICO_EXPORT	O
(	O
metaphone2	O
,	O
module	O
)	O
=	O
{	O
.	O
dico_version	int
=	O
DICO_MODULE_VERSION	int
,	O
.	O
dico_capabilities	int
=	O
DICO_CAPA_NODB	int
,	O
.	O
dico_init	pointer
=	O
metaphone2_init	function
,	O
.	O
dico_run_test	pointer
=	O
metaphone2_run_test	function
}	O
;	O
