mach_port_t	O
bootstrap_master_device_port	int
;	O
mach_port_t	O
bootstrap_master_host_port	int
;	O
extern	O
void	O
default_pager	function
(	O
)	O
;	O
extern	O
void	O
default_pager_initialize	function
(	O
)	O
;	O
extern	O
void	O
default_pager_setup	function
(	O
)	O
;	O
extern	O
mach_port_t	O
default_pager_exception_port	int
;	O
static	O
void	O
printf_init	function
(	O
device_t	O
master	int
)	O
{	O
mach_port_t	O
cons	O
;	O
kern_return_t	O
rc	O
;	O
rc	O
=	O
device_open	function
(	O
master	int
,	O
D_READ	O
|	O
D_WRITE	O
,	O
"console"	pointer
,	O
&	O
cons	O
)	O
;	O
if	O
(	O
rc	O
)	O
error	function
(	O
2	int
,	O
rc	O
,	O
"cannot open kernel console device"	pointer
)	O
;	O
stdin	O
=	O
mach_open_devstream	function
(	O
cons	O
,	O
"r"	pointer
)	O
;	O
stdout	O
=	O
stderr	O
=	O
mach_open_devstream	function
(	O
cons	O
,	O
"w"	pointer
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
cons	O
)	O
;	O
setbuf	function
(	O
stdout	O
,	O
0	int
)	O
;	O
}	O
int	O
debug	int
;	O
static	O
void	O
nohandler	function
(	O
int	O
sig	int
)	O
{	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
const	O
task_t	O
my_task	int
=	O
mach_task_self	function
(	O
)	O
;	O
error_t	O
err	O
;	O
memory_object_t	O
defpager	O
;	O
err	O
=	O
get_privileged_ports	function
(	O
&	O
bootstrap_master_host_port	int
,	O
&	O
bootstrap_master_device_port	int
)	O
;	O
if	O
(	O
err	O
)	O
error	function
(	O
1	int
,	O
err	O
,	O
"cannot get privileged ports"	pointer
)	O
;	O
defpager	O
=	O
MACH_PORT_NULL	O
;	O
err	O
=	O
vm_set_default_memory_manager	function
(	O
bootstrap_master_host_port	int
,	O
&	O
defpager	O
)	O
;	O
if	O
(	O
err	O
)	O
error	function
(	O
1	int
,	O
err	O
,	O
"cannot check current default memory manager"	pointer
)	O
;	O
if	O
(	O
MACH_PORT_VALID	function
(	O
defpager	O
)	O
)	O
error	function
(	O
2	int
,	O
0	int
,	O
"Another default memory manager is already running"	pointer
)	O
;	O
if	O
(	O
!	O
(	O
argc	int
==	O
2	int
&&	O
!	O
strcmp	O
(	O
argv	pointer
[	O
1	int
]	O
,	O
"-d"	pointer
)	O
)	O
)	O
{	O
sigset_t	O
set	O
;	O
signal	function
(	O
SIGUSR1	O
,	O
nohandler	function
)	O
;	O
signal	function
(	O
SIGCHLD	O
,	O
nohandler	function
)	O
;	O
sigemptyset	function
(	O
&	O
set	O
)	O
;	O
sigaddset	function
(	O
&	O
set	O
,	O
SIGUSR1	O
)	O
;	O
sigaddset	function
(	O
&	O
set	O
,	O
SIGCHLD	O
)	O
;	O
sigprocmask	function
(	O
SIG_SETMASK	O
,	O
&	O
set	O
,	O
NULL	O
)	O
;	O
switch	O
(	O
fork	function
(	O
)	O
)	O
{	O
case	O
-	O
1	int
:	O
error	function
(	O
1	int
,	O
errno	O
,	O
"cannot become daemon"	pointer
)	O
;	O
case	O
0	int
:	O
setsid	function
(	O
)	O
;	O
chdir	function
(	O
"/"	pointer
)	O
;	O
close	function
(	O
0	int
)	O
;	O
close	function
(	O
1	int
)	O
;	O
close	function
(	O
2	int
)	O
;	O
break	O
;	O
default	O
:	O
sigemptyset	function
(	O
&	O
set	O
)	O
;	O
sigsuspend	function
(	O
&	O
set	O
)	O
;	O
_exit	O
(	O
0	int
)	O
;	O
}	O
}	O
mach_port_t	O
proc	O
=	O
getproc	O
(	O
)	O
;	O
if	O
(	O
proc	O
==	O
MACH_PORT_NULL	O
)	O
error	function
(	O
3	int
,	O
err	O
,	O
"cannot get a handle to our process"	pointer
)	O
;	O
err	O
=	O
proc_mark_important	function
(	O
proc	O
)	O
;	O
if	O
(	O
err	O
&&	O
err	O
!=	O
EPERM	O
&&	O
err	O
!=	O
EMIG_BAD_ID	O
)	O
error	function
(	O
3	int
,	O
err	O
,	O
"cannot mark us as important"	pointer
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
proc	O
)	O
;	O
printf_init	function
(	O
bootstrap_master_device_port	int
)	O
;	O
partition_init	function
(	O
)	O
;	O
(	O
void	O
)	O
mach_port_insert_right	function
(	O
my_task	int
,	O
default_pager_exception_port	int
,	O
default_pager_exception_port	int
,	O
MACH_MSG_TYPE_MAKE_SEND	O
)	O
;	O
if	O
(	O
!	O
debug	int
)	O
(	O
void	O
)	O
task_set_exception_port	function
(	O
my_task	int
,	O
default_pager_exception_port	int
)	O
;	O
default_pager_initialize	function
(	O
bootstrap_master_host_port	int
)	O
;	O
if	O
(	O
!	O
(	O
argc	int
==	O
2	int
&&	O
!	O
strcmp	O
(	O
argv	pointer
[	O
1	int
]	O
,	O
"-d"	pointer
)	O
)	O
)	O
kill	function
(	O
getppid	function
(	O
)	O
,	O
SIGUSR1	O
)	O
;	O
default_pager	function
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
void	O
panic	function
(	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	O
ap	O
;	O
fprintf	function
(	O
stderr	O
,	O
"%s: panic: "	pointer
,	O
program_invocation_name	O
)	O
;	O
va_start	O
(	O
ap	O
,	O
fmt	pointer
)	O
;	O
vfprintf	function
(	O
stderr	O
,	O
fmt	pointer
,	O
ap	O
)	O
;	O
va_end	O
(	O
ap	O
)	O
;	O
exit	O
(	O
3	int
)	O
;	O
}	O
