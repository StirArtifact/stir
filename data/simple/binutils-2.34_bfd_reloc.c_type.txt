unsigned	O
int	O
bfd_get_reloc_size	function
(	O
reloc_howto_type	struct
*	O
howto	pointer
)	O
{	O
switch	O
(	O
howto	pointer
->	O
size	long
)	O
{	O
case	O
0	int
:	O
return	O
1	int
;	O
case	O
1	int
:	O
return	O
2	int
;	O
case	O
2	int
:	O
return	O
4	int
;	O
case	O
3	int
:	O
return	O
0	int
;	O
case	O
4	int
:	O
return	O
8	int
;	O
case	O
5	int
:	O
return	O
3	int
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
}	O
bfd_reloc_status_type	enum
bfd_check_overflow	function
(	O
enum	O
complain_overflow	enum
how	enum
,	O
unsigned	O
int	O
bitsize	int
,	O
unsigned	O
int	O
rightshift	int
,	O
unsigned	O
int	O
addrsize	int
,	O
bfd_vma	long
relocation	pointer
)	O
{	O
bfd_vma	long
fieldmask	long
,	O
addrmask	long
,	O
signmask	long
,	O
ss	long
,	O
a	pointer
;	O
bfd_reloc_status_type	enum
flag	enum
=	O
bfd_reloc_ok	int
;	O
fieldmask	long
=	O
N_ONES	O
(	O
bitsize	int
)	O
;	O
signmask	long
=	O
~	O
fieldmask	long
;	O
addrmask	long
=	O
N_ONES	O
(	O
addrsize	int
)	O
|	O
(	O
fieldmask	long
<<	O
rightshift	int
)	O
;	O
a	pointer
=	O
(	O
relocation	pointer
&	O
addrmask	long
)	O
>>	O
rightshift	int
;	O
switch	O
(	O
how	enum
)	O
{	O
case	O
complain_overflow_dont	int
:	O
break	O
;	O
case	O
complain_overflow_signed	int
:	O
signmask	long
=	O
~	O
(	O
fieldmask	long
>>	O
1	int
)	O
;	O
case	O
complain_overflow_bitfield	int
:	O
ss	long
=	O
a	pointer
&	O
signmask	long
;	O
if	O
(	O
ss	long
!=	O
0	int
&&	O
ss	long
!=	O
(	O
(	O
addrmask	long
>>	O
rightshift	int
)	O
&	O
signmask	long
)	O
)	O
flag	enum
=	O
bfd_reloc_overflow	int
;	O
break	O
;	O
case	O
complain_overflow_unsigned	int
:	O
if	O
(	O
(	O
a	pointer
&	O
signmask	long
)	O
!=	O
0	int
)	O
flag	enum
=	O
bfd_reloc_overflow	int
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
return	O
flag	enum
;	O
}	O
bfd_boolean	int
bfd_reloc_offset_in_range	function
(	O
reloc_howto_type	struct
*	O
howto	pointer
,	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
section	pointer
,	O
bfd_size_type	long
octet	long
)	O
{	O
bfd_size_type	long
octet_end	long
=	O
bfd_get_section_limit_octets	function
(	O
abfd	pointer
,	O
section	pointer
)	O
;	O
bfd_size_type	long
reloc_size	long
=	O
bfd_get_reloc_size	function
(	O
howto	pointer
)	O
;	O
return	O
octet	long
<=	O
octet_end	long
&&	O
octet	long
+	O
reloc_size	long
<=	O
octet_end	long
;	O
}	O
static	O
bfd_vma	long
read_reloc	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
bfd_byte	char
*	O
data	pointer
,	O
reloc_howto_type	struct
*	O
howto	pointer
)	O
{	O
switch	O
(	O
howto	pointer
->	O
size	long
)	O
{	O
case	O
0	int
:	O
return	O
bfd_get_8	O
(	O
abfd	pointer
,	O
data	pointer
)	O
;	O
case	O
1	int
:	O
return	O
bfd_get_16	O
(	O
abfd	pointer
,	O
data	pointer
)	O
;	O
case	O
2	int
:	O
return	O
bfd_get_32	O
(	O
abfd	pointer
,	O
data	pointer
)	O
;	O
case	O
3	int
:	O
break	O
;	O
case	O
4	int
:	O
return	O
bfd_get_64	O
(	O
abfd	pointer
,	O
data	pointer
)	O
;	O
case	O
5	int
:	O
return	O
bfd_get_24	O
(	O
abfd	pointer
,	O
data	pointer
)	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
write_reloc	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
bfd_vma	long
val	array
,	O
bfd_byte	char
*	O
data	pointer
,	O
reloc_howto_type	struct
*	O
howto	pointer
)	O
{	O
switch	O
(	O
howto	pointer
->	O
size	long
)	O
{	O
case	O
0	int
:	O
bfd_put_8	O
(	O
abfd	pointer
,	O
val	array
,	O
data	pointer
)	O
;	O
break	O
;	O
case	O
1	int
:	O
bfd_put_16	O
(	O
abfd	pointer
,	O
val	array
,	O
data	pointer
)	O
;	O
break	O
;	O
case	O
2	int
:	O
bfd_put_32	O
(	O
abfd	pointer
,	O
val	array
,	O
data	pointer
)	O
;	O
break	O
;	O
case	O
3	int
:	O
break	O
;	O
case	O
4	int
:	O
bfd_put_64	O
(	O
abfd	pointer
,	O
val	array
,	O
data	pointer
)	O
;	O
break	O
;	O
case	O
5	int
:	O
bfd_put_24	O
(	O
abfd	pointer
,	O
val	array
,	O
data	pointer
)	O
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
}	O
static	O
void	O
apply_reloc	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
bfd_byte	char
*	O
data	pointer
,	O
reloc_howto_type	struct
*	O
howto	pointer
,	O
bfd_vma	long
relocation	pointer
)	O
{	O
bfd_vma	long
val	array
=	O
read_reloc	function
(	O
abfd	pointer
,	O
data	pointer
,	O
howto	pointer
)	O
;	O
if	O
(	O
howto	pointer
->	O
negate	int
)	O
relocation	pointer
=	O
-	O
relocation	pointer
;	O
val	array
=	O
(	O
(	O
val	array
&	O
~	O
howto	pointer
->	O
dst_mask	long
)	O
|	O
(	O
(	O
(	O
val	array
&	O
howto	pointer
->	O
src_mask	long
)	O
+	O
relocation	pointer
)	O
&	O
howto	pointer
->	O
dst_mask	long
)	O
)	O
;	O
write_reloc	function
(	O
abfd	pointer
,	O
val	array
,	O
data	pointer
,	O
howto	pointer
)	O
;	O
}	O
bfd_reloc_status_type	enum
bfd_perform_relocation	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
arelent	struct
*	O
reloc_entry	pointer
,	O
void	O
*	O
data	pointer
,	O
asection	struct
*	O
input_section	pointer
,	O
bfd	struct
*	O
output_bfd	pointer
,	O
char	O
*	O
*	O
error_message	pointer
)	O
{	O
bfd_vma	long
relocation	pointer
;	O
bfd_reloc_status_type	enum
flag	enum
=	O
bfd_reloc_ok	int
;	O
bfd_size_type	long
octets	long
;	O
bfd_vma	long
output_base	long
=	O
0	int
;	O
reloc_howto_type	struct
*	O
howto	pointer
=	O
reloc_entry	pointer
->	O
howto	pointer
;	O
asection	struct
*	O
reloc_target_output_section	pointer
;	O
asymbol	struct
*	O
symbol	pointer
;	O
symbol	pointer
=	O
*	O
(	O
reloc_entry	pointer
->	O
sym_ptr_ptr	pointer
)	O
;	O
if	O
(	O
bfd_is_und_section	function
(	O
symbol	pointer
->	O
section	pointer
)	O
&&	O
(	O
symbol	pointer
->	O
flags	int
&	O
BSF_WEAK	O
)	O
==	O
0	int
&&	O
output_bfd	pointer
==	O
NULL	O
)	O
flag	enum
=	O
bfd_reloc_undefined	int
;	O
if	O
(	O
howto	pointer
&&	O
howto	pointer
->	O
special_function	pointer
)	O
{	O
bfd_reloc_status_type	enum
cont	enum
;	O
cont	enum
=	O
howto	pointer
->	O
special_function	pointer
(	O
abfd	pointer
,	O
reloc_entry	pointer
,	O
symbol	pointer
,	O
data	pointer
,	O
input_section	pointer
,	O
output_bfd	pointer
,	O
error_message	pointer
)	O
;	O
if	O
(	O
cont	enum
!=	O
bfd_reloc_continue	int
)	O
return	O
cont	enum
;	O
}	O
if	O
(	O
bfd_is_abs_section	function
(	O
symbol	pointer
->	O
section	pointer
)	O
&&	O
output_bfd	pointer
!=	O
NULL	O
)	O
{	O
reloc_entry	pointer
->	O
address	long
+=	O
input_section	pointer
->	O
output_offset	long
;	O
return	O
bfd_reloc_ok	int
;	O
}	O
if	O
(	O
howto	pointer
==	O
NULL	O
)	O
return	O
bfd_reloc_undefined	int
;	O
octets	long
=	O
reloc_entry	pointer
->	O
address	long
*	O
bfd_octets_per_byte	function
(	O
abfd	pointer
,	O
input_section	pointer
)	O
;	O
if	O
(	O
!	O
bfd_reloc_offset_in_range	function
(	O
howto	pointer
,	O
abfd	pointer
,	O
input_section	pointer
,	O
octets	long
)	O
)	O
return	O
bfd_reloc_outofrange	int
;	O
if	O
(	O
bfd_is_com_section	function
(	O
symbol	pointer
->	O
section	pointer
)	O
)	O
relocation	pointer
=	O
0	int
;	O
else	O
relocation	pointer
=	O
symbol	pointer
->	O
value	long
;	O
reloc_target_output_section	pointer
=	O
symbol	pointer
->	O
section	pointer
->	O
output_section	pointer
;	O
if	O
(	O
(	O
output_bfd	pointer
&&	O
!	O
howto	pointer
->	O
partial_inplace	int
)	O
||	O
reloc_target_output_section	pointer
==	O
NULL	O
)	O
output_base	long
=	O
0	int
;	O
else	O
output_base	long
=	O
reloc_target_output_section	pointer
->	O
vma	long
;	O
output_base	long
+=	O
symbol	pointer
->	O
section	pointer
->	O
output_offset	long
;	O
if	O
(	O
bfd_get_flavour	function
(	O
abfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
&&	O
(	O
symbol	pointer
->	O
section	pointer
->	O
flags	int
&	O
SEC_ELF_OCTETS	int
)	O
)	O
output_base	long
*=	O
bfd_octets_per_byte	function
(	O
abfd	pointer
,	O
input_section	pointer
)	O
;	O
relocation	pointer
+=	O
output_base	long
;	O
relocation	pointer
+=	O
reloc_entry	pointer
->	O
addend	long
;	O
if	O
(	O
howto	pointer
->	O
pc_relative	int
)	O
{	O
relocation	pointer
-=	O
input_section	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
input_section	pointer
->	O
output_offset	long
;	O
if	O
(	O
howto	pointer
->	O
pcrel_offset	int
)	O
relocation	pointer
-=	O
reloc_entry	pointer
->	O
address	long
;	O
}	O
if	O
(	O
output_bfd	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
howto	pointer
->	O
partial_inplace	int
)	O
{	O
reloc_entry	pointer
->	O
addend	long
=	O
relocation	pointer
;	O
reloc_entry	pointer
->	O
address	long
+=	O
input_section	pointer
->	O
output_offset	long
;	O
return	O
flag	enum
;	O
}	O
else	O
{	O
reloc_entry	pointer
->	O
address	long
+=	O
input_section	pointer
->	O
output_offset	long
;	O
if	O
(	O
abfd	pointer
->	O
xvec	pointer
->	O
flavour	enum
==	O
bfd_target_coff_flavour	int
&&	O
strcmp	function
(	O
abfd	pointer
->	O
xvec	pointer
->	O
name	pointer
,	O
"coff-Intel-little"	pointer
)	O
!=	O
0	int
&&	O
strcmp	function
(	O
abfd	pointer
->	O
xvec	pointer
->	O
name	pointer
,	O
"coff-Intel-big"	pointer
)	O
!=	O
0	int
)	O
{	O
relocation	pointer
-=	O
reloc_entry	pointer
->	O
addend	long
;	O
reloc_entry	pointer
->	O
addend	long
=	O
0	int
;	O
}	O
else	O
{	O
reloc_entry	pointer
->	O
addend	long
=	O
relocation	pointer
;	O
}	O
}	O
}	O
if	O
(	O
howto	pointer
->	O
complain_on_overflow	enum
!=	O
complain_overflow_dont	int
&&	O
flag	enum
==	O
bfd_reloc_ok	int
)	O
flag	enum
=	O
bfd_check_overflow	function
(	O
howto	pointer
->	O
complain_on_overflow	enum
,	O
howto	pointer
->	O
bitsize	int
,	O
howto	pointer
->	O
rightshift	int
,	O
bfd_arch_bits_per_address	function
(	O
abfd	pointer
)	O
,	O
relocation	pointer
)	O
;	O
relocation	pointer
>>=	O
(	O
bfd_vma	long
)	O
howto	pointer
->	O
rightshift	int
;	O
relocation	pointer
<<=	O
(	O
bfd_vma	long
)	O
howto	pointer
->	O
bitpos	int
;	O
data	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
data	pointer
+	O
octets	long
;	O
apply_reloc	function
(	O
abfd	pointer
,	O
data	pointer
,	O
howto	pointer
,	O
relocation	pointer
)	O
;	O
return	O
flag	enum
;	O
}	O
bfd_reloc_status_type	enum
bfd_install_relocation	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
arelent	struct
*	O
reloc_entry	pointer
,	O
void	O
*	O
data_start	long
,	O
bfd_vma	long
data_start_offset	long
,	O
asection	struct
*	O
input_section	pointer
,	O
char	O
*	O
*	O
error_message	pointer
)	O
{	O
bfd_vma	long
relocation	pointer
;	O
bfd_reloc_status_type	enum
flag	enum
=	O
bfd_reloc_ok	int
;	O
bfd_size_type	long
octets	long
;	O
bfd_vma	long
output_base	long
=	O
0	int
;	O
reloc_howto_type	struct
*	O
howto	pointer
=	O
reloc_entry	pointer
->	O
howto	pointer
;	O
asection	struct
*	O
reloc_target_output_section	pointer
;	O
asymbol	struct
*	O
symbol	pointer
;	O
bfd_byte	char
*	O
data	pointer
;	O
symbol	pointer
=	O
*	O
(	O
reloc_entry	pointer
->	O
sym_ptr_ptr	pointer
)	O
;	O
if	O
(	O
howto	pointer
&&	O
howto	pointer
->	O
special_function	pointer
)	O
{	O
bfd_reloc_status_type	enum
cont	enum
;	O
cont	enum
=	O
howto	pointer
->	O
special_function	pointer
(	O
abfd	pointer
,	O
reloc_entry	pointer
,	O
symbol	pointer
,	O
(	O
(	O
bfd_byte	char
*	O
)	O
data_start	long
-	O
data_start_offset	long
)	O
,	O
input_section	pointer
,	O
abfd	pointer
,	O
error_message	pointer
)	O
;	O
if	O
(	O
cont	enum
!=	O
bfd_reloc_continue	int
)	O
return	O
cont	enum
;	O
}	O
if	O
(	O
bfd_is_abs_section	function
(	O
symbol	pointer
->	O
section	pointer
)	O
)	O
{	O
reloc_entry	pointer
->	O
address	long
+=	O
input_section	pointer
->	O
output_offset	long
;	O
return	O
bfd_reloc_ok	int
;	O
}	O
octets	long
=	O
reloc_entry	pointer
->	O
address	long
*	O
bfd_octets_per_byte	function
(	O
abfd	pointer
,	O
input_section	pointer
)	O
;	O
if	O
(	O
!	O
bfd_reloc_offset_in_range	function
(	O
howto	pointer
,	O
abfd	pointer
,	O
input_section	pointer
,	O
octets	long
)	O
)	O
return	O
bfd_reloc_outofrange	int
;	O
if	O
(	O
bfd_is_com_section	function
(	O
symbol	pointer
->	O
section	pointer
)	O
)	O
relocation	pointer
=	O
0	int
;	O
else	O
relocation	pointer
=	O
symbol	pointer
->	O
value	long
;	O
reloc_target_output_section	pointer
=	O
symbol	pointer
->	O
section	pointer
->	O
output_section	pointer
;	O
if	O
(	O
!	O
howto	pointer
->	O
partial_inplace	int
)	O
output_base	long
=	O
0	int
;	O
else	O
output_base	long
=	O
reloc_target_output_section	pointer
->	O
vma	long
;	O
output_base	long
+=	O
symbol	pointer
->	O
section	pointer
->	O
output_offset	long
;	O
if	O
(	O
bfd_get_flavour	function
(	O
abfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
&&	O
(	O
symbol	pointer
->	O
section	pointer
->	O
flags	int
&	O
SEC_ELF_OCTETS	int
)	O
)	O
output_base	long
*=	O
bfd_octets_per_byte	function
(	O
abfd	pointer
,	O
input_section	pointer
)	O
;	O
relocation	pointer
+=	O
output_base	long
;	O
relocation	pointer
+=	O
reloc_entry	pointer
->	O
addend	long
;	O
if	O
(	O
howto	pointer
->	O
pc_relative	int
)	O
{	O
relocation	pointer
-=	O
input_section	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
input_section	pointer
->	O
output_offset	long
;	O
if	O
(	O
howto	pointer
->	O
pcrel_offset	int
&&	O
howto	pointer
->	O
partial_inplace	int
)	O
relocation	pointer
-=	O
reloc_entry	pointer
->	O
address	long
;	O
}	O
if	O
(	O
!	O
howto	pointer
->	O
partial_inplace	int
)	O
{	O
reloc_entry	pointer
->	O
addend	long
=	O
relocation	pointer
;	O
reloc_entry	pointer
->	O
address	long
+=	O
input_section	pointer
->	O
output_offset	long
;	O
return	O
flag	enum
;	O
}	O
else	O
{	O
reloc_entry	pointer
->	O
address	long
+=	O
input_section	pointer
->	O
output_offset	long
;	O
if	O
(	O
abfd	pointer
->	O
xvec	pointer
->	O
flavour	enum
==	O
bfd_target_coff_flavour	int
&&	O
strcmp	function
(	O
abfd	pointer
->	O
xvec	pointer
->	O
name	pointer
,	O
"coff-Intel-little"	pointer
)	O
!=	O
0	int
&&	O
strcmp	function
(	O
abfd	pointer
->	O
xvec	pointer
->	O
name	pointer
,	O
"coff-Intel-big"	pointer
)	O
!=	O
0	int
)	O
{	O
relocation	pointer
-=	O
reloc_entry	pointer
->	O
addend	long
;	O
if	O
(	O
strcmp	function
(	O
abfd	pointer
->	O
xvec	pointer
->	O
name	pointer
,	O
"coff-z8k"	pointer
)	O
!=	O
0	int
)	O
reloc_entry	pointer
->	O
addend	long
=	O
0	int
;	O
}	O
else	O
{	O
reloc_entry	pointer
->	O
addend	long
=	O
relocation	pointer
;	O
}	O
}	O
if	O
(	O
howto	pointer
->	O
complain_on_overflow	enum
!=	O
complain_overflow_dont	int
)	O
flag	enum
=	O
bfd_check_overflow	function
(	O
howto	pointer
->	O
complain_on_overflow	enum
,	O
howto	pointer
->	O
bitsize	int
,	O
howto	pointer
->	O
rightshift	int
,	O
bfd_arch_bits_per_address	function
(	O
abfd	pointer
)	O
,	O
relocation	pointer
)	O
;	O
relocation	pointer
>>=	O
(	O
bfd_vma	long
)	O
howto	pointer
->	O
rightshift	int
;	O
relocation	pointer
<<=	O
(	O
bfd_vma	long
)	O
howto	pointer
->	O
bitpos	int
;	O
data	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
data_start	long
+	O
(	O
octets	long
-	O
data_start_offset	long
)	O
;	O
apply_reloc	function
(	O
abfd	pointer
,	O
data	pointer
,	O
howto	pointer
,	O
relocation	pointer
)	O
;	O
return	O
flag	enum
;	O
}	O
bfd_reloc_status_type	enum
_bfd_final_link_relocate	function
(	O
reloc_howto_type	struct
*	O
howto	pointer
,	O
bfd	struct
*	O
input_bfd	pointer
,	O
asection	struct
*	O
input_section	pointer
,	O
bfd_byte	char
*	O
contents	pointer
,	O
bfd_vma	long
address	long
,	O
bfd_vma	long
value	long
,	O
bfd_vma	long
addend	long
)	O
{	O
bfd_vma	long
relocation	pointer
;	O
bfd_size_type	long
octets	long
=	O
(	O
address	long
*	O
bfd_octets_per_byte	function
(	O
input_bfd	pointer
,	O
input_section	pointer
)	O
)	O
;	O
if	O
(	O
!	O
bfd_reloc_offset_in_range	function
(	O
howto	pointer
,	O
input_bfd	pointer
,	O
input_section	pointer
,	O
octets	long
)	O
)	O
return	O
bfd_reloc_outofrange	int
;	O
relocation	pointer
=	O
value	long
+	O
addend	long
;	O
if	O
(	O
howto	pointer
->	O
pc_relative	int
)	O
{	O
relocation	pointer
-=	O
(	O
input_section	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
input_section	pointer
->	O
output_offset	long
)	O
;	O
if	O
(	O
howto	pointer
->	O
pcrel_offset	int
)	O
relocation	pointer
-=	O
address	long
;	O
}	O
return	O
_bfd_relocate_contents	function
(	O
howto	pointer
,	O
input_bfd	pointer
,	O
relocation	pointer
,	O
contents	pointer
+	O
octets	long
)	O
;	O
}	O
bfd_reloc_status_type	enum
_bfd_relocate_contents	function
(	O
reloc_howto_type	struct
*	O
howto	pointer
,	O
bfd	struct
*	O
input_bfd	pointer
,	O
bfd_vma	long
relocation	pointer
,	O
bfd_byte	char
*	O
location	pointer
)	O
{	O
bfd_vma	long
x	long
;	O
bfd_reloc_status_type	enum
flag	enum
;	O
unsigned	O
int	O
rightshift	int
=	O
howto	pointer
->	O
rightshift	int
;	O
unsigned	O
int	O
bitpos	int
=	O
howto	pointer
->	O
bitpos	int
;	O
if	O
(	O
howto	pointer
->	O
negate	int
)	O
relocation	pointer
=	O
-	O
relocation	pointer
;	O
x	long
=	O
read_reloc	function
(	O
input_bfd	pointer
,	O
location	pointer
,	O
howto	pointer
)	O
;	O
flag	enum
=	O
bfd_reloc_ok	int
;	O
if	O
(	O
howto	pointer
->	O
complain_on_overflow	enum
!=	O
complain_overflow_dont	int
)	O
{	O
bfd_vma	long
addrmask	long
,	O
fieldmask	long
,	O
signmask	long
,	O
ss	long
;	O
bfd_vma	long
a	pointer
,	O
b	pointer
,	O
sum	long
;	O
fieldmask	long
=	O
N_ONES	O
(	O
howto	pointer
->	O
bitsize	int
)	O
;	O
signmask	long
=	O
~	O
fieldmask	long
;	O
addrmask	long
=	O
(	O
N_ONES	O
(	O
bfd_arch_bits_per_address	function
(	O
input_bfd	pointer
)	O
)	O
|	O
(	O
fieldmask	long
<<	O
rightshift	int
)	O
)	O
;	O
a	pointer
=	O
(	O
relocation	pointer
&	O
addrmask	long
)	O
>>	O
rightshift	int
;	O
b	pointer
=	O
(	O
x	long
&	O
howto	pointer
->	O
src_mask	long
&	O
addrmask	long
)	O
>>	O
bitpos	int
;	O
addrmask	long
>>=	O
rightshift	int
;	O
switch	O
(	O
howto	pointer
->	O
complain_on_overflow	enum
)	O
{	O
case	O
complain_overflow_signed	int
:	O
signmask	long
=	O
~	O
(	O
fieldmask	long
>>	O
1	int
)	O
;	O
case	O
complain_overflow_bitfield	int
:	O
ss	long
=	O
a	pointer
&	O
signmask	long
;	O
if	O
(	O
ss	long
!=	O
0	int
&&	O
ss	long
!=	O
(	O
addrmask	long
&	O
signmask	long
)	O
)	O
flag	enum
=	O
bfd_reloc_overflow	int
;	O
ss	long
=	O
(	O
(	O
~	O
howto	pointer
->	O
src_mask	long
)	O
>>	O
1	int
)	O
&	O
howto	pointer
->	O
src_mask	long
;	O
ss	long
>>=	O
bitpos	int
;	O
b	pointer
=	O
(	O
b	pointer
^	O
ss	long
)	O
-	O
ss	long
;	O
sum	long
=	O
a	pointer
+	O
b	pointer
;	O
if	O
(	O
(	O
(	O
~	O
(	O
a	pointer
^	O
b	pointer
)	O
)	O
&	O
(	O
a	pointer
^	O
sum	long
)	O
)	O
&	O
signmask	long
&	O
addrmask	long
)	O
flag	enum
=	O
bfd_reloc_overflow	int
;	O
break	O
;	O
case	O
complain_overflow_unsigned	int
:	O
sum	long
=	O
(	O
a	pointer
+	O
b	pointer
)	O
&	O
addrmask	long
;	O
if	O
(	O
(	O
a	pointer
|	O
b	pointer
|	O
sum	long
)	O
&	O
signmask	long
)	O
flag	enum
=	O
bfd_reloc_overflow	int
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
}	O
relocation	pointer
>>=	O
(	O
bfd_vma	long
)	O
rightshift	int
;	O
relocation	pointer
<<=	O
(	O
bfd_vma	long
)	O
bitpos	int
;	O
x	long
=	O
(	O
(	O
x	long
&	O
~	O
howto	pointer
->	O
dst_mask	long
)	O
|	O
(	O
(	O
(	O
x	long
&	O
howto	pointer
->	O
src_mask	long
)	O
+	O
relocation	pointer
)	O
&	O
howto	pointer
->	O
dst_mask	long
)	O
)	O
;	O
write_reloc	function
(	O
input_bfd	pointer
,	O
x	long
,	O
location	pointer
,	O
howto	pointer
)	O
;	O
return	O
flag	enum
;	O
}	O
bfd_reloc_status_type	enum
_bfd_clear_contents	function
(	O
reloc_howto_type	struct
*	O
howto	pointer
,	O
bfd	struct
*	O
input_bfd	pointer
,	O
asection	struct
*	O
input_section	pointer
,	O
bfd_byte	char
*	O
buf	pointer
,	O
bfd_vma	long
off	long
)	O
{	O
bfd_vma	long
x	long
;	O
bfd_byte	char
*	O
location	pointer
;	O
if	O
(	O
!	O
bfd_reloc_offset_in_range	function
(	O
howto	pointer
,	O
input_bfd	pointer
,	O
input_section	pointer
,	O
off	long
)	O
)	O
return	O
bfd_reloc_outofrange	int
;	O
location	pointer
=	O
buf	pointer
+	O
off	long
;	O
x	long
=	O
read_reloc	function
(	O
input_bfd	pointer
,	O
location	pointer
,	O
howto	pointer
)	O
;	O
x	long
&=	O
~	O
howto	pointer
->	O
dst_mask	long
;	O
if	O
(	O
strcmp	function
(	O
bfd_section_name	function
(	O
input_section	pointer
)	O
,	O
".debug_ranges"	pointer
)	O
==	O
0	int
&&	O
(	O
howto	pointer
->	O
dst_mask	long
&	O
1	int
)	O
!=	O
0	int
)	O
x	long
|=	O
1	int
;	O
write_reloc	function
(	O
input_bfd	pointer
,	O
x	long
,	O
location	pointer
,	O
howto	pointer
)	O
;	O
return	O
bfd_reloc_ok	int
;	O
}	O
reloc_howto_type	struct
*	O
bfd_reloc_type_lookup	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
bfd_reloc_code_real_type	enum
code	int
)	O
{	O
return	O
BFD_SEND	O
(	O
abfd	pointer
,	O
reloc_type_lookup	pointer
,	O
(	O
abfd	pointer
,	O
code	int
)	O
)	O
;	O
}	O
reloc_howto_type	struct
*	O
bfd_reloc_name_lookup	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
char	O
*	O
reloc_name	pointer
)	O
{	O
return	O
BFD_SEND	O
(	O
abfd	pointer
,	O
reloc_name_lookup	pointer
,	O
(	O
abfd	pointer
,	O
reloc_name	pointer
)	O
)	O
;	O
}	O
static	O
reloc_howto_type	struct
bfd_howto_32	struct
=	O
HOWTO	O
(	O
0	int
,	O
00	int
,	O
2	int
,	O
32	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_dont	int
,	O
0	int
,	O
"VRT32"	pointer
,	O
FALSE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
TRUE	int
)	O
;	O
reloc_howto_type	struct
*	O
bfd_default_reloc_type_lookup	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
bfd_reloc_code_real_type	enum
code	int
)	O
{	O
if	O
(	O
code	int
==	O
BFD_RELOC_CTOR	int
&&	O
bfd_arch_bits_per_address	function
(	O
abfd	pointer
)	O
==	O
32	int
)	O
return	O
&	O
bfd_howto_32	struct
;	O
return	O
NULL	O
;	O
}	O
const	O
char	O
*	O
bfd_get_reloc_code_name	function
(	O
bfd_reloc_code_real_type	enum
code	int
)	O
{	O
if	O
(	O
code	int
>	O
BFD_RELOC_UNUSED	int
)	O
return	O
0	int
;	O
return	O
bfd_reloc_code_real_names	array
[	O
code	int
]	O
;	O
}	O
bfd_boolean	int
bfd_generic_relax_section	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
asection	struct
*	O
section	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
bfd_link_info	struct
*	O
link_info	pointer
ATTRIBUTE_UNUSED	O
,	O
bfd_boolean	int
*	O
again	pointer
)	O
{	O
if	O
(	O
bfd_link_relocatable	O
(	O
link_info	pointer
)	O
)	O
(	O
*	O
link_info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
)	O
(	O
_	O
(	O
"%P%F: --relax and -r may not be used together\n"	pointer
)	O
)	O
;	O
*	O
again	pointer
=	O
FALSE	int
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
bfd_generic_gc_sections	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
bfd_generic_lookup_section_flags	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
flag_info	struct
*	O
flaginfo	pointer
,	O
asection	struct
*	O
section	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
if	O
(	O
flaginfo	pointer
!=	O
NULL	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"INPUT_SECTION_FLAGS are not supported"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
bfd_generic_merge_sections	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
bfd_link_info	struct
*	O
link_info	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
TRUE	int
;	O
}	O
bfd_byte	char
*	O
bfd_generic_get_relocated_section_contents	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
link_info	pointer
,	O
struct	O
bfd_link_order	struct
*	O
link_order	pointer
,	O
bfd_byte	char
*	O
data	pointer
,	O
bfd_boolean	int
relocatable	int
,	O
asymbol	struct
*	O
*	O
symbols	pointer
)	O
{	O
bfd	struct
*	O
input_bfd	pointer
=	O
link_order	pointer
->	O
u	union
.	O
indirect	struct
.	O
section	pointer
->	O
owner	pointer
;	O
asection	struct
*	O
input_section	pointer
=	O
link_order	pointer
->	O
u	union
.	O
indirect	struct
.	O
section	pointer
;	O
long	O
reloc_size	long
;	O
arelent	struct
*	O
*	O
reloc_vector	pointer
;	O
long	O
reloc_count	int
;	O
reloc_size	long
=	O
bfd_get_reloc_upper_bound	function
(	O
input_bfd	pointer
,	O
input_section	pointer
)	O
;	O
if	O
(	O
reloc_size	long
<	O
0	int
)	O
return	O
NULL	O
;	O
if	O
(	O
!	O
bfd_get_full_section_contents	function
(	O
input_bfd	pointer
,	O
input_section	pointer
,	O
&	O
data	pointer
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
data	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
reloc_size	long
==	O
0	int
)	O
return	O
data	pointer
;	O
reloc_vector	pointer
=	O
(	O
arelent	struct
*	O
*	O
)	O
bfd_malloc	function
(	O
reloc_size	long
)	O
;	O
if	O
(	O
reloc_vector	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
reloc_count	int
=	O
bfd_canonicalize_reloc	function
(	O
input_bfd	pointer
,	O
input_section	pointer
,	O
reloc_vector	pointer
,	O
symbols	pointer
)	O
;	O
if	O
(	O
reloc_count	int
<	O
0	int
)	O
goto	O
error_return	O
;	O
if	O
(	O
reloc_count	int
>	O
0	int
)	O
{	O
arelent	struct
*	O
*	O
parent	pointer
;	O
for	O
(	O
parent	pointer
=	O
reloc_vector	pointer
;	O
*	O
parent	pointer
!=	O
NULL	O
;	O
parent	pointer
++	O
)	O
{	O
char	O
*	O
error_message	pointer
=	O
NULL	O
;	O
asymbol	struct
*	O
symbol	pointer
;	O
bfd_reloc_status_type	enum
r	enum
;	O
symbol	pointer
=	O
*	O
(	O
*	O
parent	pointer
)	O
->	O
sym_ptr_ptr	pointer
;	O
if	O
(	O
symbol	pointer
==	O
NULL	O
)	O
{	O
link_info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%X%P: %pB(%pA): error: relocation for offset %V has no value\n"	pointer
)	O
,	O
abfd	pointer
,	O
input_section	pointer
,	O
(	O
*	O
parent	pointer
)	O
->	O
address	long
)	O
;	O
goto	O
error_return	O
;	O
}	O
if	O
(	O
(	O
symbol	pointer
->	O
section	pointer
!=	O
NULL	O
&&	O
discarded_section	function
(	O
symbol	pointer
->	O
section	pointer
)	O
)	O
||	O
(	O
symbol	pointer
->	O
section	pointer
==	O
bfd_und_section_ptr	O
&&	O
(	O
input_section	pointer
->	O
flags	int
&	O
SEC_DEBUGGING	int
)	O
!=	O
0	int
&&	O
link_info	pointer
->	O
input_bfds	pointer
==	O
link_info	pointer
->	O
output_bfd	pointer
)	O
)	O
{	O
bfd_vma	long
off	long
;	O
static	O
reloc_howto_type	struct
none_howto	struct
=	O
HOWTO	O
(	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_dont	int
,	O
NULL	O
,	O
"unused"	pointer
,	O
FALSE	int
,	O
0	int
,	O
0	int
,	O
FALSE	int
)	O
;	O
off	long
=	O
(	O
(	O
*	O
parent	pointer
)	O
->	O
address	long
*	O
bfd_octets_per_byte	function
(	O
input_bfd	pointer
,	O
input_section	pointer
)	O
)	O
;	O
_bfd_clear_contents	function
(	O
(	O
*	O
parent	pointer
)	O
->	O
howto	pointer
,	O
input_bfd	pointer
,	O
input_section	pointer
,	O
data	pointer
,	O
off	long
)	O
;	O
(	O
*	O
parent	pointer
)	O
->	O
sym_ptr_ptr	pointer
=	O
bfd_abs_section_ptr	O
->	O
symbol_ptr_ptr	pointer
;	O
(	O
*	O
parent	pointer
)	O
->	O
addend	long
=	O
0	int
;	O
(	O
*	O
parent	pointer
)	O
->	O
howto	pointer
=	O
&	O
none_howto	struct
;	O
r	enum
=	O
bfd_reloc_ok	int
;	O
}	O
else	O
r	enum
=	O
bfd_perform_relocation	function
(	O
input_bfd	pointer
,	O
*	O
parent	pointer
,	O
data	pointer
,	O
input_section	pointer
,	O
relocatable	int
?	O
abfd	pointer
:	O
NULL	O
,	O
&	O
error_message	pointer
)	O
;	O
if	O
(	O
relocatable	int
)	O
{	O
asection	struct
*	O
os	pointer
=	O
input_section	pointer
->	O
output_section	pointer
;	O
os	pointer
->	O
orelocation	pointer
[	O
os	pointer
->	O
reloc_count	int
]	O
=	O
*	O
parent	pointer
;	O
os	pointer
->	O
reloc_count	int
++	O
;	O
}	O
if	O
(	O
r	enum
!=	O
bfd_reloc_ok	int
)	O
{	O
switch	O
(	O
r	enum
)	O
{	O
case	O
bfd_reloc_undefined	int
:	O
(	O
*	O
link_info	pointer
->	O
callbacks	pointer
->	O
undefined_symbol	pointer
)	O
(	O
link_info	pointer
,	O
bfd_asymbol_name	function
(	O
*	O
(	O
*	O
parent	pointer
)	O
->	O
sym_ptr_ptr	pointer
)	O
,	O
input_bfd	pointer
,	O
input_section	pointer
,	O
(	O
*	O
parent	pointer
)	O
->	O
address	long
,	O
TRUE	int
)	O
;	O
break	O
;	O
case	O
bfd_reloc_dangerous	int
:	O
BFD_ASSERT	O
(	O
error_message	pointer
!=	O
NULL	O
)	O
;	O
(	O
*	O
link_info	pointer
->	O
callbacks	pointer
->	O
reloc_dangerous	pointer
)	O
(	O
link_info	pointer
,	O
error_message	pointer
,	O
input_bfd	pointer
,	O
input_section	pointer
,	O
(	O
*	O
parent	pointer
)	O
->	O
address	long
)	O
;	O
break	O
;	O
case	O
bfd_reloc_overflow	int
:	O
(	O
*	O
link_info	pointer
->	O
callbacks	pointer
->	O
reloc_overflow	pointer
)	O
(	O
link_info	pointer
,	O
NULL	O
,	O
bfd_asymbol_name	function
(	O
*	O
(	O
*	O
parent	pointer
)	O
->	O
sym_ptr_ptr	pointer
)	O
,	O
(	O
*	O
parent	pointer
)	O
->	O
howto	pointer
->	O
name	pointer
,	O
(	O
*	O
parent	pointer
)	O
->	O
addend	long
,	O
input_bfd	pointer
,	O
input_section	pointer
,	O
(	O
*	O
parent	pointer
)	O
->	O
address	long
)	O
;	O
break	O
;	O
case	O
bfd_reloc_outofrange	int
:	O
link_info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%X%P: %pB(%pA): relocation \"%pR\" goes out of range\n"	pointer
)	O
,	O
abfd	pointer
,	O
input_section	pointer
,	O
*	O
parent	pointer
)	O
;	O
goto	O
error_return	O
;	O
case	O
bfd_reloc_notsupported	int
:	O
link_info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%X%P: %pB(%pA): relocation \"%pR\" is not supported\n"	pointer
)	O
,	O
abfd	pointer
,	O
input_section	pointer
,	O
*	O
parent	pointer
)	O
;	O
goto	O
error_return	O
;	O
default	O
:	O
link_info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%X%P: %pB(%pA): relocation \"%pR\" returns an unrecognized value %x\n"	pointer
)	O
,	O
abfd	pointer
,	O
input_section	pointer
,	O
*	O
parent	pointer
,	O
r	enum
)	O
;	O
break	O
;	O
}	O
}	O
}	O
}	O
free	function
(	O
reloc_vector	pointer
)	O
;	O
return	O
data	pointer
;	O
error_return	O
:	O
free	function
(	O
reloc_vector	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
void	O
_bfd_generic_set_reloc	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
sec_ptr	pointer
section	pointer
,	O
arelent	struct
*	O
*	O
relptr	pointer
,	O
unsigned	O
int	O
count	int
)	O
{	O
section	pointer
->	O
orelocation	pointer
=	O
relptr	pointer
;	O
section	pointer
->	O
reloc_count	int
=	O
count	int
;	O
}	O
bfd_boolean	int
_bfd_unrecognized_reloc	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
sec_ptr	pointer
section	pointer
,	O
unsigned	O
int	O
r_type	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: unrecognized relocation type %#x in section `%pA'"	pointer
)	O
,	O
abfd	pointer
,	O
r_type	int
,	O
section	pointer
)	O
;	O
_bfd_error_handler	function
(	O
_	O
(	O
"is this version of the linker - %s - out of date ?"	pointer
)	O
,	O
BFD_VERSION_STRING	O
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
reloc_howto_type	struct
*	O
_bfd_norelocs_bfd_reloc_type_lookup	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
bfd_reloc_code_real_type	enum
code	int
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
(	O
reloc_howto_type	struct
*	O
)	O
_bfd_ptr_bfd_null_error	function
(	O
abfd	pointer
)	O
;	O
}	O
reloc_howto_type	struct
*	O
_bfd_norelocs_bfd_reloc_name_lookup	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
char	O
*	O
reloc_name	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
(	O
reloc_howto_type	struct
*	O
)	O
_bfd_ptr_bfd_null_error	function
(	O
abfd	pointer
)	O
;	O
}	O
long	O
_bfd_nodynamic_canonicalize_dynamic_reloc	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
arelent	struct
*	O
*	O
relp	pointer
ATTRIBUTE_UNUSED	O
,	O
asymbol	struct
*	O
*	O
symp	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
_bfd_long_bfd_n1_error	function
(	O
abfd	pointer
)	O
;	O
}	O
