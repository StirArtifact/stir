static	O
FILE	struct
*	O
pfp	pointer
;	O
static	O
int	O
p_says_nonexistent	array
[	O
2	int
]	O
;	O
static	O
int	O
p_rfc934_nesting	int
;	O
static	O
char	O
*	O
p_name	array
[	O
3	int
]	O
;	O
static	O
char	O
const	O
*	O
invalid_names	array
[	O
2	int
]	O
;	O
bool	bool
p_copy	array
[	O
2	int
]	O
;	O
bool	bool
p_rename	array
[	O
2	int
]	O
;	O
static	O
char	O
*	O
p_timestr	array
[	O
2	int
]	O
;	O
static	O
char	O
*	O
p_sha1	array
[	O
2	int
]	O
;	O
static	O
mode_t	int
p_mode	array
[	O
2	int
]	O
;	O
static	O
off_t	long
p_filesize	long
;	O
static	O
lin	long
p_first	long
;	O
static	O
lin	long
p_newfirst	long
;	O
static	O
lin	long
p_ptrn_lines	long
;	O
static	O
lin	long
p_repl_lines	long
;	O
static	O
lin	long
p_end	long
=	O
-	O
1	int
;	O
static	O
lin	long
p_max	long
;	O
static	O
lin	long
p_prefix_context	long
;	O
static	O
lin	long
p_suffix_context	long
;	O
static	O
lin	long
p_input_line	long
;	O
static	O
char	O
*	O
*	O
p_line	pointer
;	O
static	O
size_t	long
*	O
p_len	pointer
;	O
static	O
char	O
*	O
p_Char	pointer
;	O
static	O
lin	long
hunkmax	long
=	O
INITHUNKMAX	int
;	O
static	O
size_t	long
p_indent	long
;	O
static	O
bool	bool
p_strip_trailing_cr	bool
;	O
static	O
bool	bool
p_pass_comments_through	bool
;	O
static	O
file_offset	long
p_base	long
;	O
static	O
lin	long
p_bline	long
;	O
static	O
file_offset	long
p_start	long
;	O
static	O
lin	long
p_sline	long
;	O
static	O
lin	long
p_hunk_beg	long
;	O
static	O
lin	long
p_efake	long
=	O
-	O
1	int
;	O
static	O
lin	long
p_bfake	long
=	O
-	O
1	int
;	O
static	O
char	O
*	O
p_c_function	pointer
;	O
static	O
bool	bool
p_git_diff	bool
;	O
static	O
char	O
*	O
scan_linenum	function
(	O
char	O
*	O
,	O
lin	long
*	O
)	O
;	O
static	O
enum	O
diff	enum
intuit_diff_type	function
(	O
bool	bool
,	O
mode_t	int
*	O
)	O
;	O
static	O
enum	O
nametype	enum
best_name	function
(	O
char	O
*	O
const	O
*	O
,	O
int	O
const	O
*	O
)	O
;	O
static	O
int	O
prefix_components	function
(	O
char	O
*	O
,	O
bool	bool
)	O
;	O
static	O
size_t	long
pget_line	function
(	O
size_t	long
,	O
int	O
,	O
bool	bool
,	O
bool	bool
)	O
;	O
static	O
size_t	long
get_line	function
(	O
void	O
)	O
;	O
static	O
bool	bool
incomplete_line	function
(	O
void	O
)	O
;	O
static	O
bool	bool
grow_hunkmax	function
(	O
void	O
)	O
;	O
static	O
void	O
malformed	function
(	O
void	O
)	O
__attribute__	O
(	O
(	O
noreturn	O
)	O
)	O
;	O
static	O
void	O
next_intuit_at	function
(	O
file_offset	long
,	O
lin	long
)	O
;	O
static	O
void	O
skip_to	function
(	O
file_offset	long
,	O
lin	long
)	O
;	O
static	O
char	O
get_ed_command_letter	function
(	O
char	O
const	O
*	O
)	O
;	O
void	O
re_patch	function
(	O
void	O
)	O
{	O
p_first	long
=	O
0	int
;	O
p_newfirst	long
=	O
0	int
;	O
p_ptrn_lines	long
=	O
0	int
;	O
p_repl_lines	long
=	O
0	int
;	O
p_end	long
=	O
-	O
1	int
;	O
p_max	long
=	O
0	int
;	O
p_indent	long
=	O
0	int
;	O
p_strip_trailing_cr	bool
=	O
false	int
;	O
}	O
void	O
open_patch_file	function
(	O
char	O
const	O
*	O
filename	pointer
)	O
{	O
file_offset	long
file_pos	long
=	O
0	int
;	O
file_offset	long
pos	long
;	O
struct	O
stat	struct
st	pointer
;	O
if	O
(	O
!	O
filename	pointer
||	O
!	O
*	O
filename	pointer
||	O
strEQ	O
(	O
filename	pointer
,	O
"-"	pointer
)	O
)	O
pfp	pointer
=	O
stdin	pointer
;	O
else	O
{	O
pfp	pointer
=	O
fopen	function
(	O
filename	pointer
,	O
binary_transput	int
?	O
"rb"	pointer
:	O
"r"	pointer
)	O
;	O
if	O
(	O
!	O
pfp	pointer
)	O
pfatal	function
(	O
"Can't open patch file %s"	pointer
,	O
quotearg	function
(	O
filename	pointer
)	O
)	O
;	O
}	O
if	O
(	O
fstat	function
(	O
fileno	function
(	O
pfp	pointer
)	O
,	O
&	O
st	pointer
)	O
!=	O
0	int
)	O
pfatal	function
(	O
"fstat"	pointer
)	O
;	O
if	O
(	O
S_ISREG	O
(	O
st	pointer
.	O
st_mode	int
)	O
&&	O
(	O
pos	long
=	O
file_tell	O
(	O
pfp	pointer
)	O
)	O
!=	O
-	O
1	int
)	O
file_pos	long
=	O
pos	long
;	O
else	O
{	O
size_t	long
charsread	long
;	O
int	O
fd	int
=	O
make_tempfile	function
(	O
&	O
TMPPATNAME	pointer
,	O
'p'	O
,	O
NULL	O
,	O
O_RDWR	int
|	O
O_BINARY	int
,	O
0	int
)	O
;	O
FILE	struct
*	O
read_pfp	pointer
=	O
pfp	pointer
;	O
TMPPATNAME_needs_removal	int
=	O
1	int
;	O
pfp	pointer
=	O
fdopen	function
(	O
fd	int
,	O
"w+b"	pointer
)	O
;	O
if	O
(	O
!	O
pfp	pointer
)	O
pfatal	function
(	O
"Can't open stream for file %s"	pointer
,	O
quotearg	function
(	O
TMPPATNAME	pointer
)	O
)	O
;	O
for	O
(	O
st	pointer
.	O
st_size	long
=	O
0	int
;	O
(	O
charsread	long
=	O
fread	function
(	O
buf	pointer
,	O
1	int
,	O
bufsize	long
,	O
read_pfp	pointer
)	O
)	O
!=	O
0	int
;	O
st	pointer
.	O
st_size	long
+=	O
charsread	long
)	O
if	O
(	O
fwrite	function
(	O
buf	pointer
,	O
1	int
,	O
charsread	long
,	O
pfp	pointer
)	O
!=	O
charsread	long
)	O
write_fatal	function
(	O
)	O
;	O
if	O
(	O
ferror	function
(	O
read_pfp	pointer
)	O
||	O
fclose	function
(	O
read_pfp	pointer
)	O
!=	O
0	int
)	O
read_fatal	function
(	O
)	O
;	O
if	O
(	O
fflush	function
(	O
pfp	pointer
)	O
!=	O
0	int
||	O
file_seek	O
(	O
pfp	pointer
,	O
(	O
file_offset	long
)	O
0	int
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
write_fatal	function
(	O
)	O
;	O
}	O
p_filesize	long
=	O
st	pointer
.	O
st_size	long
;	O
if	O
(	O
p_filesize	long
!=	O
(	O
file_offset	long
)	O
p_filesize	long
)	O
fatal	function
(	O
"patch file is too long"	pointer
)	O
;	O
next_intuit_at	function
(	O
file_pos	long
,	O
1	int
)	O
;	O
set_hunkmax	function
(	O
)	O
;	O
}	O
void	O
set_hunkmax	function
(	O
void	O
)	O
{	O
if	O
(	O
!	O
p_line	pointer
)	O
p_line	pointer
=	O
(	O
char	O
*	O
*	O
)	O
malloc	function
(	O
hunkmax	long
*	O
sizeof	O
*	O
p_line	pointer
)	O
;	O
if	O
(	O
!	O
p_len	pointer
)	O
p_len	pointer
=	O
(	O
size_t	long
*	O
)	O
malloc	function
(	O
hunkmax	long
*	O
sizeof	O
*	O
p_len	pointer
)	O
;	O
if	O
(	O
!	O
p_Char	pointer
)	O
p_Char	pointer
=	O
malloc	function
(	O
hunkmax	long
*	O
sizeof	O
*	O
p_Char	pointer
)	O
;	O
}	O
static	O
bool	bool
grow_hunkmax	function
(	O
void	O
)	O
{	O
hunkmax	long
*=	O
2	int
;	O
assert	O
(	O
p_line	pointer
&&	O
p_len	pointer
&&	O
p_Char	pointer
)	O
;	O
if	O
(	O
(	O
p_line	pointer
=	O
(	O
char	O
*	O
*	O
)	O
realloc	function
(	O
p_line	pointer
,	O
hunkmax	long
*	O
sizeof	O
(	O
*	O
p_line	pointer
)	O
)	O
)	O
&&	O
(	O
p_len	pointer
=	O
(	O
size_t	long
*	O
)	O
realloc	function
(	O
p_len	pointer
,	O
hunkmax	long
*	O
sizeof	O
(	O
*	O
p_len	pointer
)	O
)	O
)	O
&&	O
(	O
p_Char	pointer
=	O
realloc	function
(	O
p_Char	pointer
,	O
hunkmax	long
*	O
sizeof	O
(	O
*	O
p_Char	pointer
)	O
)	O
)	O
)	O
return	O
true	int
;	O
if	O
(	O
!	O
using_plan_a	bool
)	O
xalloc_die	function
(	O
)	O
;	O
return	O
false	int
;	O
}	O
static	O
bool	bool
maybe_reverse	function
(	O
char	O
const	O
*	O
name	pointer
,	O
bool	bool
nonexistent	bool
,	O
bool	bool
is_empty	bool
)	O
{	O
bool	bool
looks_reversed	bool
=	O
(	O
!	O
is_empty	bool
)	O
<	O
p_says_nonexistent	array
[	O
reverse	bool
^	O
is_empty	bool
]	O
;	O
if	O
(	O
is_empty	bool
&&	O
p_says_nonexistent	array
[	O
reverse	bool
^	O
nonexistent	bool
]	O
==	O
1	int
&&	O
p_says_nonexistent	array
[	O
!	O
reverse	bool
^	O
nonexistent	bool
]	O
==	O
2	int
)	O
return	O
false	int
;	O
if	O
(	O
looks_reversed	bool
)	O
reverse	bool
^=	O
ok_to_reverse	function
(	O
"The next patch%s would %s the file %s,\nwhich %s!"	pointer
,	O
reverse	bool
?	O
", when reversed,"	pointer
:	O
""	pointer
,	O
(	O
nonexistent	bool
?	O
"delete"	pointer
:	O
is_empty	bool
?	O
"empty out"	pointer
:	O
"create"	pointer
)	O
,	O
quotearg	function
(	O
name	pointer
)	O
,	O
(	O
nonexistent	bool
?	O
"does not exist"	pointer
:	O
is_empty	bool
?	O
"is already empty"	pointer
:	O
"already exists"	pointer
)	O
)	O
;	O
return	O
looks_reversed	bool
;	O
}	O
bool	bool
there_is_another_patch	function
(	O
bool	bool
need_header	bool
,	O
mode_t	int
*	O
file_type	pointer
)	O
{	O
if	O
(	O
p_base	long
!=	O
0	int
&&	O
p_base	long
>=	O
p_filesize	long
)	O
{	O
if	O
(	O
verbosity	enum
==	O
VERBOSE	int
)	O
say	function
(	O
"done\n"	pointer
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
verbosity	enum
==	O
VERBOSE	int
)	O
say	function
(	O
"Hmm..."	pointer
)	O
;	O
diff_type	enum
=	O
intuit_diff_type	function
(	O
need_header	bool
,	O
file_type	pointer
)	O
;	O
if	O
(	O
diff_type	enum
==	O
NO_DIFF	int
)	O
{	O
if	O
(	O
verbosity	enum
==	O
VERBOSE	int
)	O
say	function
(	O
p_base	long
?	O
"  Ignoring the trailing garbage.\ndone\n"	pointer
:	O
"  I can't seem to find a patch in there anywhere.\n"	pointer
)	O
;	O
if	O
(	O
!	O
p_base	long
&&	O
p_filesize	long
)	O
fatal	function
(	O
"Only garbage was found in the patch input."	pointer
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
skip_rest_of_patch	bool
)	O
{	O
Fseek	function
(	O
pfp	pointer
,	O
p_start	long
,	O
SEEK_SET	int
)	O
;	O
p_input_line	long
=	O
p_sline	long
-	O
1	int
;	O
return	O
true	int
;	O
}	O
if	O
(	O
verbosity	enum
==	O
VERBOSE	int
)	O
say	function
(	O
"  %sooks like %s to me...\n"	pointer
,	O
(	O
p_base	long
==	O
0	int
?	O
"L"	pointer
:	O
"The next patch l"	pointer
)	O
,	O
diff_type	enum
==	O
UNI_DIFF	int
?	O
"a unified diff"	pointer
:	O
diff_type	enum
==	O
CONTEXT_DIFF	int
?	O
"a context diff"	pointer
:	O
diff_type	enum
==	O
NEW_CONTEXT_DIFF	int
?	O
"a new-style context diff"	pointer
:	O
diff_type	enum
==	O
NORMAL_DIFF	int
?	O
"a normal diff"	pointer
:	O
diff_type	enum
==	O
GIT_BINARY_DIFF	int
?	O
"a git binary diff"	pointer
:	O
"an ed script"	pointer
)	O
;	O
if	O
(	O
no_strip_trailing_cr	bool
)	O
p_strip_trailing_cr	bool
=	O
false	int
;	O
if	O
(	O
verbosity	enum
!=	O
SILENT	int
)	O
{	O
if	O
(	O
p_indent	long
)	O
say	function
(	O
"(Patch is indented %lu space%s.)\n"	pointer
,	O
(	O
unsigned	O
long	O
int	O
)	O
p_indent	long
,	O
p_indent	long
==	O
1	int
?	O
""	pointer
:	O
"s"	pointer
)	O
;	O
if	O
(	O
p_strip_trailing_cr	bool
)	O
say	function
(	O
"(Stripping trailing CRs from patch.)\n"	pointer
)	O
;	O
if	O
(	O
!	O
inname	pointer
)	O
{	O
char	O
numbuf	array
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
say	function
(	O
"can't find file to patch at input line %s\n"	pointer
,	O
format_linenum	function
(	O
numbuf	array
,	O
p_sline	long
)	O
)	O
;	O
if	O
(	O
diff_type	enum
!=	O
ED_DIFF	int
&&	O
diff_type	enum
!=	O
NORMAL_DIFF	int
)	O
say	function
(	O
strippath	int
==	O
-	O
1	int
?	O
"Perhaps you should have used the -p or --strip option?\n"	pointer
:	O
"Perhaps you used the wrong -p or --strip option?\n"	pointer
)	O
;	O
}	O
}	O
skip_to	function
(	O
p_start	long
,	O
p_sline	long
)	O
;	O
while	O
(	O
!	O
inname	pointer
)	O
{	O
char	O
*	O
t	struct
;	O
if	O
(	O
force	bool
|	O
batch	bool
)	O
{	O
say	function
(	O
"No file to patch.  Skipping patch.\n"	pointer
)	O
;	O
skip_rest_of_patch	bool
=	O
true	int
;	O
return	O
true	int
;	O
}	O
ask	function
(	O
"File to patch: "	pointer
)	O
;	O
t	struct
=	O
buf	pointer
+	O
strlen	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
t	struct
>	O
buf	pointer
+	O
1	int
&&	O
*	O
(	O
t	struct
-	O
1	int
)	O
==	O
'\n'	O
)	O
{	O
inname	pointer
=	O
savebuf	function
(	O
buf	pointer
,	O
t	struct
-	O
buf	pointer
)	O
;	O
inname	pointer
[	O
t	struct
-	O
buf	pointer
-	O
1	int
]	O
=	O
0	int
;	O
if	O
(	O
lstat	function
(	O
inname	pointer
,	O
&	O
instat	struct
)	O
==	O
0	int
)	O
{	O
inerrno	int
=	O
0	int
;	O
invc	int
=	O
-	O
1	int
;	O
}	O
else	O
{	O
perror	function
(	O
inname	pointer
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
free	function
(	O
inname	pointer
)	O
;	O
inname	pointer
=	O
0	int
;	O
}	O
}	O
if	O
(	O
!	O
inname	pointer
)	O
{	O
ask	function
(	O
"Skip this patch? [y] "	pointer
)	O
;	O
if	O
(	O
*	O
buf	pointer
!=	O
'n'	O
)	O
{	O
if	O
(	O
verbosity	enum
!=	O
SILENT	int
)	O
say	function
(	O
"Skipping patch.\n"	pointer
)	O
;	O
skip_rest_of_patch	bool
=	O
true	int
;	O
return	O
true	int
;	O
}	O
}	O
}	O
return	O
true	int
;	O
}	O
static	O
mode_t	int
_GL_ATTRIBUTE_PURE	O
fetchmode	function
(	O
char	O
const	O
*	O
str	pointer
)	O
{	O
const	O
char	O
*	O
s	enum
;	O
mode_t	int
mode	int
;	O
while	O
(	O
ISSPACE	O
(	O
(	O
unsigned	O
char	O
)	O
*	O
str	pointer
)	O
)	O
str	pointer
++	O
;	O
for	O
(	O
s	enum
=	O
str	pointer
,	O
mode	int
=	O
0	int
;	O
s	enum
<	O
str	pointer
+	O
6	int
;	O
s	enum
++	O
)	O
{	O
if	O
(	O
*	O
s	enum
>=	O
'0'	O
&&	O
*	O
s	enum
<=	O
'7'	O
)	O
mode	int
=	O
(	O
mode	int
<<	O
3	int
)	O
+	O
(	O
*	O
s	enum
-	O
'0'	O
)	O
;	O
else	O
{	O
mode	int
=	O
0	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
*	O
s	enum
==	O
'\r'	O
)	O
s	enum
++	O
;	O
if	O
(	O
*	O
s	enum
!=	O
'\n'	O
)	O
mode	int
=	O
0	int
;	O
return	O
mode	int
;	O
}	O
static	O
void	O
get_sha1	function
(	O
char	O
*	O
*	O
sha1	pointer
,	O
char	O
const	O
*	O
start	pointer
,	O
char	O
const	O
*	O
end	pointer
)	O
{	O
unsigned	O
int	O
len	int
=	O
end	pointer
-	O
start	pointer
;	O
*	O
sha1	pointer
=	O
xmalloc	function
(	O
len	int
+	O
1	int
)	O
;	O
memcpy	function
(	O
*	O
sha1	pointer
,	O
start	pointer
,	O
len	int
)	O
;	O
(	O
*	O
sha1	pointer
)	O
[	O
len	int
]	O
=	O
0	int
;	O
}	O
static	O
int	O
_GL_ATTRIBUTE_PURE	O
sha1_says_nonexistent	function
(	O
char	O
const	O
*	O
sha1	pointer
)	O
{	O
char	O
const	O
*	O
empty_sha1	pointer
=	O
"e69de29bb2d1d6434b8b29ae775ad8c2e48c5391"	pointer
;	O
char	O
const	O
*	O
s	enum
;	O
for	O
(	O
s	enum
=	O
sha1	pointer
;	O
*	O
s	enum
;	O
s	enum
++	O
)	O
if	O
(	O
*	O
s	enum
!=	O
'0'	O
)	O
break	O
;	O
if	O
(	O
!	O
*	O
s	enum
)	O
return	O
2	int
;	O
for	O
(	O
s	enum
=	O
sha1	pointer
;	O
*	O
s	enum
;	O
s	enum
++	O
,	O
empty_sha1	pointer
++	O
)	O
if	O
(	O
*	O
s	enum
!=	O
*	O
empty_sha1	pointer
)	O
break	O
;	O
return	O
!	O
*	O
s	enum
;	O
}	O
static	O
char	O
const	O
*	O
_GL_ATTRIBUTE_PURE	O
skip_hex_digits	function
(	O
char	O
const	O
*	O
str	pointer
)	O
{	O
char	O
const	O
*	O
s	enum
;	O
for	O
(	O
s	enum
=	O
str	pointer
;	O
(	O
*	O
s	enum
>=	O
'0'	O
&&	O
*	O
s	enum
<=	O
'9'	O
)	O
||	O
(	O
*	O
s	enum
>=	O
'a'	O
&&	O
*	O
s	enum
<=	O
'f'	O
)	O
;	O
s	enum
++	O
)	O
;	O
return	O
s	enum
==	O
str	pointer
?	O
NULL	O
:	O
s	enum
;	O
}	O
static	O
bool	bool
name_is_valid	function
(	O
char	O
const	O
*	O
name	pointer
)	O
{	O
char	O
const	O
*	O
n	int
;	O
int	O
i	int
;	O
bool	bool
is_valid	bool
=	O
true	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ARRAY_SIZE	O
(	O
invalid_names	array
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
!	O
invalid_names	array
[	O
i	int
]	O
)	O
break	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
invalid_names	array
[	O
i	int
]	O
,	O
name	pointer
)	O
)	O
return	O
false	int
;	O
}	O
if	O
(	O
IS_ABSOLUTE_FILE_NAME	O
(	O
name	pointer
)	O
)	O
is_valid	bool
=	O
false	int
;	O
else	O
for	O
(	O
n	int
=	O
name	pointer
;	O
*	O
n	int
;	O
)	O
{	O
if	O
(	O
*	O
n	int
==	O
'.'	O
&&	O
*	O
++	O
n	int
==	O
'.'	O
&&	O
(	O
!	O
*	O
++	O
n	int
||	O
ISSLASH	O
(	O
*	O
n	int
)	O
)	O
)	O
{	O
is_valid	bool
=	O
false	int
;	O
break	O
;	O
}	O
while	O
(	O
*	O
n	int
&&	O
!	O
ISSLASH	O
(	O
*	O
n	int
)	O
)	O
n	int
++	O
;	O
while	O
(	O
ISSLASH	O
(	O
*	O
n	int
)	O
)	O
n	int
++	O
;	O
}	O
if	O
(	O
!	O
is_valid	bool
)	O
{	O
say	function
(	O
"Ignoring potentially dangerous file name %s\n"	pointer
,	O
quotearg	function
(	O
name	pointer
)	O
)	O
;	O
if	O
(	O
i	int
<	O
ARRAY_SIZE	O
(	O
invalid_names	array
)	O
)	O
invalid_names	array
[	O
i	int
]	O
=	O
name	pointer
;	O
}	O
return	O
is_valid	bool
;	O
}	O
static	O
enum	O
diff	enum
intuit_diff_type	function
(	O
bool	bool
need_header	bool
,	O
mode_t	int
*	O
p_file_type	pointer
)	O
{	O
file_offset	long
this_line	long
=	O
0	int
;	O
file_offset	long
first_command_line	long
=	O
-	O
1	int
;	O
char	O
first_ed_command_letter	char
=	O
0	int
;	O
lin	long
fcl_line	long
=	O
0	int
;	O
bool	bool
this_is_a_command	bool
=	O
false	int
;	O
bool	bool
stars_this_line	bool
=	O
false	int
;	O
bool	bool
extended_headers	bool
=	O
false	int
;	O
enum	O
nametype	enum
i	int
;	O
struct	O
stat	struct
st	pointer
[	O
3	int
]	O
;	O
int	O
stat_errno	array
[	O
3	int
]	O
;	O
int	O
version_controlled	array
[	O
3	int
]	O
;	O
enum	O
diff	enum
retval	enum
;	O
mode_t	int
file_type	pointer
;	O
for	O
(	O
i	int
=	O
OLD	int
;	O
i	int
<=	O
INDEX	int
;	O
i	int
++	O
)	O
if	O
(	O
p_name	array
[	O
i	int
]	O
)	O
{	O
free	function
(	O
p_name	array
[	O
i	int
]	O
)	O
;	O
p_name	array
[	O
i	int
]	O
=	O
0	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ARRAY_SIZE	O
(	O
invalid_names	array
)	O
;	O
i	int
++	O
)	O
invalid_names	array
[	O
i	int
]	O
=	O
NULL	O
;	O
for	O
(	O
i	int
=	O
OLD	int
;	O
i	int
<=	O
NEW	int
;	O
i	int
++	O
)	O
if	O
(	O
p_timestr	array
[	O
i	int
]	O
)	O
{	O
free	function
(	O
p_timestr	array
[	O
i	int
]	O
)	O
;	O
p_timestr	array
[	O
i	int
]	O
=	O
0	int
;	O
}	O
for	O
(	O
i	int
=	O
OLD	int
;	O
i	int
<=	O
NEW	int
;	O
i	int
++	O
)	O
if	O
(	O
p_sha1	array
[	O
i	int
]	O
)	O
{	O
free	function
(	O
p_sha1	array
[	O
i	int
]	O
)	O
;	O
p_sha1	array
[	O
i	int
]	O
=	O
0	int
;	O
}	O
p_git_diff	bool
=	O
false	int
;	O
for	O
(	O
i	int
=	O
OLD	int
;	O
i	int
<=	O
NEW	int
;	O
i	int
++	O
)	O
{	O
p_mode	array
[	O
i	int
]	O
=	O
0	int
;	O
p_copy	array
[	O
i	int
]	O
=	O
false	int
;	O
p_rename	array
[	O
i	int
]	O
=	O
false	int
;	O
}	O
if	O
(	O
diff_type	enum
==	O
ED_DIFF	int
||	O
diff_type	enum
==	O
NORMAL_DIFF	int
)	O
need_header	bool
=	O
false	int
;	O
version_controlled	array
[	O
OLD	int
]	O
=	O
-	O
1	int
;	O
version_controlled	array
[	O
NEW	int
]	O
=	O
-	O
1	int
;	O
version_controlled	array
[	O
INDEX	int
]	O
=	O
-	O
1	int
;	O
p_rfc934_nesting	int
=	O
0	int
;	O
p_timestamp	array
[	O
OLD	int
]	O
.	O
tv_sec	long
=	O
p_timestamp	array
[	O
NEW	int
]	O
.	O
tv_sec	long
=	O
-	O
1	int
;	O
p_says_nonexistent	array
[	O
OLD	int
]	O
=	O
p_says_nonexistent	array
[	O
NEW	int
]	O
=	O
0	int
;	O
Fseek	function
(	O
pfp	pointer
,	O
p_base	long
,	O
SEEK_SET	int
)	O
;	O
p_input_line	long
=	O
p_bline	long
-	O
1	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
char	O
*	O
s	enum
;	O
char	O
*	O
t	struct
;	O
file_offset	long
previous_line	long
=	O
this_line	long
;	O
bool	bool
last_line_was_command	bool
=	O
this_is_a_command	bool
;	O
bool	bool
stars_last_line	bool
=	O
stars_this_line	bool
;	O
size_t	long
indent	long
=	O
0	int
;	O
char	O
ed_command_letter	char
;	O
bool	bool
strip_trailing_cr	bool
;	O
size_t	long
chars_read	long
;	O
this_line	long
=	O
file_tell	O
(	O
pfp	pointer
)	O
;	O
chars_read	long
=	O
pget_line	function
(	O
0	int
,	O
0	int
,	O
false	int
,	O
false	int
)	O
;	O
if	O
(	O
chars_read	long
==	O
(	O
size_t	long
)	O
-	O
1	int
)	O
xalloc_die	function
(	O
)	O
;	O
if	O
(	O
!	O
chars_read	long
)	O
{	O
if	O
(	O
first_ed_command_letter	char
)	O
{	O
p_start	long
=	O
first_command_line	long
;	O
p_sline	long
=	O
fcl_line	long
;	O
retval	enum
=	O
ED_DIFF	int
;	O
goto	O
scan_exit	O
;	O
}	O
else	O
{	O
p_start	long
=	O
this_line	long
;	O
p_sline	long
=	O
p_input_line	long
;	O
if	O
(	O
extended_headers	bool
)	O
{	O
retval	enum
=	O
UNI_DIFF	int
;	O
goto	O
scan_exit	O
;	O
}	O
return	O
NO_DIFF	int
;	O
}	O
}	O
strip_trailing_cr	bool
=	O
2	int
<=	O
chars_read	long
&&	O
buf	pointer
[	O
chars_read	long
-	O
2	int
]	O
==	O
'\r'	O
;	O
for	O
(	O
s	enum
=	O
buf	pointer
;	O
*	O
s	enum
==	O
' '	O
||	O
*	O
s	enum
==	O
'\t'	O
||	O
*	O
s	enum
==	O
'X'	O
;	O
s	enum
++	O
)	O
{	O
if	O
(	O
*	O
s	enum
==	O
'\t'	O
)	O
indent	long
=	O
(	O
indent	long
+	O
8	int
)	O
&	O
~	O
7	int
;	O
else	O
indent	long
++	O
;	O
}	O
if	O
(	O
ISDIGIT	O
(	O
*	O
s	enum
)	O
)	O
{	O
for	O
(	O
t	struct
=	O
s	enum
+	O
1	int
;	O
ISDIGIT	O
(	O
*	O
t	struct
)	O
||	O
*	O
t	struct
==	O
','	O
;	O
t	struct
++	O
)	O
;	O
if	O
(	O
*	O
t	struct
==	O
'd'	O
||	O
*	O
t	struct
==	O
'c'	O
||	O
*	O
t	struct
==	O
'a'	O
)	O
{	O
for	O
(	O
t	struct
++	O
;	O
ISDIGIT	O
(	O
*	O
t	struct
)	O
||	O
*	O
t	struct
==	O
','	O
;	O
t	struct
++	O
)	O
;	O
for	O
(	O
;	O
*	O
t	struct
==	O
' '	O
||	O
*	O
t	struct
==	O
'\t'	O
;	O
t	struct
++	O
)	O
;	O
if	O
(	O
*	O
t	struct
==	O
'\r'	O
)	O
t	struct
++	O
;	O
this_is_a_command	bool
=	O
(	O
*	O
t	struct
==	O
'\n'	O
)	O
;	O
}	O
}	O
if	O
(	O
!	O
need_header	bool
&&	O
first_command_line	long
<	O
0	int
&&	O
(	O
(	O
ed_command_letter	char
=	O
get_ed_command_letter	function
(	O
s	enum
)	O
)	O
||	O
this_is_a_command	bool
)	O
)	O
{	O
first_command_line	long
=	O
this_line	long
;	O
first_ed_command_letter	char
=	O
ed_command_letter	char
;	O
fcl_line	long
=	O
p_input_line	long
;	O
p_indent	long
=	O
indent	long
;	O
p_strip_trailing_cr	bool
=	O
strip_trailing_cr	bool
;	O
}	O
if	O
(	O
!	O
stars_last_line	bool
&&	O
strnEQ	O
(	O
s	enum
,	O
"*** "	pointer
,	O
4	int
)	O
)	O
{	O
fetchname	function
(	O
s	enum
+	O
4	int
,	O
strippath	int
,	O
&	O
p_name	array
[	O
OLD	int
]	O
,	O
&	O
p_timestr	array
[	O
OLD	int
]	O
,	O
&	O
p_timestamp	array
[	O
OLD	int
]	O
)	O
;	O
need_header	bool
=	O
false	int
;	O
}	O
else	O
if	O
(	O
strnEQ	O
(	O
s	enum
,	O
"+++ "	pointer
,	O
4	int
)	O
)	O
{	O
fetchname	function
(	O
s	enum
+	O
4	int
,	O
strippath	int
,	O
&	O
p_name	array
[	O
OLD	int
]	O
,	O
&	O
p_timestr	array
[	O
OLD	int
]	O
,	O
&	O
p_timestamp	array
[	O
OLD	int
]	O
)	O
;	O
need_header	bool
=	O
false	int
;	O
p_strip_trailing_cr	bool
=	O
strip_trailing_cr	bool
;	O
}	O
else	O
if	O
(	O
strnEQ	O
(	O
s	enum
,	O
"Index:"	pointer
,	O
6	int
)	O
)	O
{	O
fetchname	function
(	O
s	enum
+	O
6	int
,	O
strippath	int
,	O
&	O
p_name	array
[	O
INDEX	int
]	O
,	O
(	O
char	O
*	O
*	O
)	O
0	int
,	O
NULL	O
)	O
;	O
need_header	bool
=	O
false	int
;	O
p_strip_trailing_cr	bool
=	O
strip_trailing_cr	bool
;	O
}	O
else	O
if	O
(	O
strnEQ	O
(	O
s	enum
,	O
"Prereq:"	pointer
,	O
7	int
)	O
)	O
{	O
for	O
(	O
t	struct
=	O
s	enum
+	O
7	int
;	O
ISSPACE	O
(	O
(	O
unsigned	O
char	O
)	O
*	O
t	struct
)	O
;	O
t	struct
++	O
)	O
;	O
revision	pointer
=	O
t	struct
;	O
for	O
(	O
t	struct
=	O
revision	pointer
;	O
*	O
t	struct
;	O
t	struct
++	O
)	O
if	O
(	O
ISSPACE	O
(	O
(	O
unsigned	O
char	O
)	O
*	O
t	struct
)	O
)	O
{	O
char	O
const	O
*	O
u	pointer
;	O
for	O
(	O
u	pointer
=	O
t	struct
+	O
1	int
;	O
ISSPACE	O
(	O
(	O
unsigned	O
char	O
)	O
*	O
u	pointer
)	O
;	O
u	pointer
++	O
)	O
;	O
if	O
(	O
*	O
u	pointer
)	O
{	O
char	O
numbuf	array
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
say	function
(	O
"Prereq: with multiple words at line %s of patch\n"	pointer
,	O
format_linenum	function
(	O
numbuf	array
,	O
this_line	long
)	O
)	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
t	struct
==	O
revision	pointer
)	O
revision	pointer
=	O
0	int
;	O
else	O
{	O
char	O
oldc	char
=	O
*	O
t	struct
;	O
*	O
t	struct
=	O
'\0'	O
;	O
revision	pointer
=	O
savestr	function
(	O
revision	pointer
)	O
;	O
*	O
t	struct
=	O
oldc	char
;	O
}	O
}	O
else	O
if	O
(	O
strnEQ	O
(	O
s	enum
,	O
"diff --git "	pointer
,	O
11	int
)	O
)	O
{	O
char	O
const	O
*	O
u	pointer
;	O
if	O
(	O
extended_headers	bool
)	O
{	O
p_start	long
=	O
this_line	long
;	O
p_sline	long
=	O
p_input_line	long
;	O
retval	enum
=	O
UNI_DIFF	int
;	O
goto	O
scan_exit	O
;	O
}	O
for	O
(	O
i	int
=	O
OLD	int
;	O
i	int
<=	O
NEW	int
;	O
i	int
++	O
)	O
{	O
free	function
(	O
p_name	array
[	O
i	int
]	O
)	O
;	O
p_name	array
[	O
i	int
]	O
=	O
0	int
;	O
}	O
if	O
(	O
!	O
(	O
(	O
p_name	array
[	O
OLD	int
]	O
=	O
parse_name	function
(	O
s	enum
+	O
11	int
,	O
strippath	int
,	O
&	O
u	pointer
)	O
)	O
&&	O
ISSPACE	O
(	O
(	O
unsigned	O
char	O
)	O
*	O
u	pointer
)	O
&&	O
(	O
p_name	array
[	O
NEW	int
]	O
=	O
parse_name	function
(	O
u	pointer
,	O
strippath	int
,	O
&	O
u	pointer
)	O
)	O
&&	O
(	O
u	pointer
=	O
skip_spaces	function
(	O
u	pointer
)	O
,	O
!	O
*	O
u	pointer
)	O
)	O
)	O
for	O
(	O
i	int
=	O
OLD	int
;	O
i	int
<=	O
NEW	int
;	O
i	int
++	O
)	O
{	O
free	function
(	O
p_name	array
[	O
i	int
]	O
)	O
;	O
p_name	array
[	O
i	int
]	O
=	O
0	int
;	O
}	O
p_git_diff	bool
=	O
true	int
;	O
}	O
else	O
if	O
(	O
p_git_diff	bool
&&	O
strnEQ	O
(	O
s	enum
,	O
"index "	pointer
,	O
6	int
)	O
)	O
{	O
char	O
const	O
*	O
u	pointer
,	O
*	O
v	pointer
;	O
if	O
(	O
(	O
u	pointer
=	O
skip_hex_digits	function
(	O
s	enum
+	O
6	int
)	O
)	O
&&	O
u	pointer
[	O
0	int
]	O
==	O
'.'	O
&&	O
u	pointer
[	O
1	int
]	O
==	O
'.'	O
&&	O
(	O
v	pointer
=	O
skip_hex_digits	function
(	O
u	pointer
+	O
2	int
)	O
)	O
&&	O
(	O
!	O
*	O
v	pointer
||	O
ISSPACE	O
(	O
(	O
unsigned	O
char	O
)	O
*	O
v	pointer
)	O
)	O
)	O
{	O
get_sha1	function
(	O
&	O
p_sha1	array
[	O
OLD	int
]	O
,	O
s	enum
+	O
6	int
,	O
u	pointer
)	O
;	O
get_sha1	function
(	O
&	O
p_sha1	array
[	O
NEW	int
]	O
,	O
u	pointer
+	O
2	int
,	O
v	pointer
)	O
;	O
p_says_nonexistent	array
[	O
OLD	int
]	O
=	O
sha1_says_nonexistent	function
(	O
p_sha1	array
[	O
OLD	int
]	O
)	O
;	O
p_says_nonexistent	array
[	O
NEW	int
]	O
=	O
sha1_says_nonexistent	function
(	O
p_sha1	array
[	O
NEW	int
]	O
)	O
;	O
if	O
(	O
*	O
(	O
v	pointer
=	O
skip_spaces	function
(	O
v	pointer
)	O
)	O
)	O
p_mode	array
[	O
OLD	int
]	O
=	O
p_mode	array
[	O
NEW	int
]	O
=	O
fetchmode	function
(	O
v	pointer
)	O
;	O
extended_headers	bool
=	O
true	int
;	O
}	O
}	O
else	O
if	O
(	O
p_git_diff	bool
&&	O
strnEQ	O
(	O
s	enum
,	O
"old mode "	pointer
,	O
9	int
)	O
)	O
{	O
p_mode	array
[	O
OLD	int
]	O
=	O
fetchmode	function
(	O
s	enum
+	O
9	int
)	O
;	O
extended_headers	bool
=	O
true	int
;	O
}	O
else	O
if	O
(	O
p_git_diff	bool
&&	O
strnEQ	O
(	O
s	enum
,	O
"new mode "	pointer
,	O
9	int
)	O
)	O
{	O
p_mode	array
[	O
NEW	int
]	O
=	O
fetchmode	function
(	O
s	enum
+	O
9	int
)	O
;	O
extended_headers	bool
=	O
true	int
;	O
}	O
else	O
if	O
(	O
p_git_diff	bool
&&	O
strnEQ	O
(	O
s	enum
,	O
"deleted file mode "	pointer
,	O
18	int
)	O
)	O
{	O
p_mode	array
[	O
OLD	int
]	O
=	O
fetchmode	function
(	O
s	enum
+	O
18	int
)	O
;	O
p_says_nonexistent	array
[	O
NEW	int
]	O
=	O
2	int
;	O
extended_headers	bool
=	O
true	int
;	O
}	O
else	O
if	O
(	O
p_git_diff	bool
&&	O
strnEQ	O
(	O
s	enum
,	O
"new file mode "	pointer
,	O
14	int
)	O
)	O
{	O
p_mode	array
[	O
NEW	int
]	O
=	O
fetchmode	function
(	O
s	enum
+	O
14	int
)	O
;	O
p_says_nonexistent	array
[	O
OLD	int
]	O
=	O
2	int
;	O
extended_headers	bool
=	O
true	int
;	O
}	O
else	O
if	O
(	O
p_git_diff	bool
&&	O
strnEQ	O
(	O
s	enum
,	O
"rename from "	pointer
,	O
12	int
)	O
)	O
{	O
p_rename	array
[	O
OLD	int
]	O
=	O
true	int
;	O
extended_headers	bool
=	O
true	int
;	O
}	O
else	O
if	O
(	O
p_git_diff	bool
&&	O
strnEQ	O
(	O
s	enum
,	O
"rename to "	pointer
,	O
10	int
)	O
)	O
{	O
p_rename	array
[	O
NEW	int
]	O
=	O
true	int
;	O
extended_headers	bool
=	O
true	int
;	O
}	O
else	O
if	O
(	O
p_git_diff	bool
&&	O
strnEQ	O
(	O
s	enum
,	O
"copy from "	pointer
,	O
10	int
)	O
)	O
{	O
p_copy	array
[	O
OLD	int
]	O
=	O
true	int
;	O
extended_headers	bool
=	O
true	int
;	O
}	O
else	O
if	O
(	O
p_git_diff	bool
&&	O
strnEQ	O
(	O
s	enum
,	O
"copy to "	pointer
,	O
8	int
)	O
)	O
{	O
p_copy	array
[	O
NEW	int
]	O
=	O
true	int
;	O
extended_headers	bool
=	O
true	int
;	O
}	O
else	O
if	O
(	O
p_git_diff	bool
&&	O
strnEQ	O
(	O
s	enum
,	O
"GIT binary patch"	pointer
,	O
16	int
)	O
)	O
{	O
p_start	long
=	O
this_line	long
;	O
p_sline	long
=	O
p_input_line	long
;	O
retval	enum
=	O
GIT_BINARY_DIFF	int
;	O
goto	O
scan_exit	O
;	O
}	O
else	O
{	O
for	O
(	O
t	struct
=	O
s	enum
;	O
t	struct
[	O
0	int
]	O
==	O
'-'	O
&&	O
t	struct
[	O
1	int
]	O
==	O
' '	O
;	O
t	struct
+=	O
2	int
)	O
;	O
if	O
(	O
strnEQ	O
(	O
t	struct
,	O
"--- "	pointer
,	O
4	int
)	O
)	O
{	O
struct	O
timespec	struct
timestamp	struct
;	O
timestamp	struct
.	O
tv_sec	long
=	O
-	O
1	int
;	O
fetchname	function
(	O
t	struct
+	O
4	int
,	O
strippath	int
,	O
&	O
p_name	array
[	O
NEW	int
]	O
,	O
&	O
p_timestr	array
[	O
NEW	int
]	O
,	O
&	O
timestamp	struct
)	O
;	O
need_header	bool
=	O
false	int
;	O
if	O
(	O
timestamp	struct
.	O
tv_sec	long
!=	O
-	O
1	int
)	O
{	O
p_timestamp	array
[	O
NEW	int
]	O
=	O
timestamp	struct
;	O
p_rfc934_nesting	int
=	O
(	O
t	struct
-	O
s	enum
)	O
>>	O
1	int
;	O
}	O
p_strip_trailing_cr	bool
=	O
strip_trailing_cr	bool
;	O
}	O
}	O
if	O
(	O
need_header	bool
)	O
continue	O
;	O
if	O
(	O
(	O
diff_type	enum
==	O
NO_DIFF	int
||	O
diff_type	enum
==	O
ED_DIFF	int
)	O
&&	O
first_command_line	long
>=	O
0	int
&&	O
strEQ	O
(	O
s	enum
,	O
".\n"	pointer
)	O
)	O
{	O
p_start	long
=	O
first_command_line	long
;	O
p_sline	long
=	O
fcl_line	long
;	O
retval	enum
=	O
ED_DIFF	int
;	O
goto	O
scan_exit	O
;	O
}	O
if	O
(	O
(	O
diff_type	enum
==	O
NO_DIFF	int
||	O
diff_type	enum
==	O
UNI_DIFF	int
)	O
&&	O
strnEQ	O
(	O
s	enum
,	O
"@@ -"	pointer
,	O
4	int
)	O
)	O
{	O
struct	O
timespec	struct
ti	struct
=	O
p_timestamp	array
[	O
OLD	int
]	O
;	O
p_timestamp	array
[	O
OLD	int
]	O
=	O
p_timestamp	array
[	O
NEW	int
]	O
;	O
p_timestamp	array
[	O
NEW	int
]	O
=	O
ti	struct
;	O
t	struct
=	O
p_name	array
[	O
OLD	int
]	O
;	O
p_name	array
[	O
OLD	int
]	O
=	O
p_name	array
[	O
NEW	int
]	O
;	O
p_name	array
[	O
NEW	int
]	O
=	O
t	struct
;	O
t	struct
=	O
p_timestr	array
[	O
OLD	int
]	O
;	O
p_timestr	array
[	O
OLD	int
]	O
=	O
p_timestr	array
[	O
NEW	int
]	O
;	O
p_timestr	array
[	O
NEW	int
]	O
=	O
t	struct
;	O
s	enum
+=	O
4	int
;	O
if	O
(	O
s	enum
[	O
0	int
]	O
==	O
'0'	O
&&	O
!	O
ISDIGIT	O
(	O
s	enum
[	O
1	int
]	O
)	O
)	O
p_says_nonexistent	array
[	O
OLD	int
]	O
=	O
1	int
+	O
!	O
p_timestamp	array
[	O
OLD	int
]	O
.	O
tv_sec	long
;	O
while	O
(	O
*	O
s	enum
!=	O
' '	O
&&	O
*	O
s	enum
!=	O
'\n'	O
)	O
s	enum
++	O
;	O
while	O
(	O
*	O
s	enum
==	O
' '	O
)	O
s	enum
++	O
;	O
if	O
(	O
s	enum
[	O
0	int
]	O
==	O
'+'	O
&&	O
s	enum
[	O
1	int
]	O
==	O
'0'	O
&&	O
!	O
ISDIGIT	O
(	O
s	enum
[	O
2	int
]	O
)	O
)	O
p_says_nonexistent	array
[	O
NEW	int
]	O
=	O
1	int
+	O
!	O
p_timestamp	array
[	O
NEW	int
]	O
.	O
tv_sec	long
;	O
p_indent	long
=	O
indent	long
;	O
p_start	long
=	O
this_line	long
;	O
p_sline	long
=	O
p_input_line	long
;	O
retval	enum
=	O
UNI_DIFF	int
;	O
if	O
(	O
!	O
(	O
(	O
p_name	array
[	O
OLD	int
]	O
||	O
!	O
p_timestamp	array
[	O
OLD	int
]	O
.	O
tv_sec	long
)	O
&&	O
(	O
p_name	array
[	O
NEW	int
]	O
||	O
!	O
p_timestamp	array
[	O
NEW	int
]	O
.	O
tv_sec	long
)	O
)	O
&&	O
!	O
p_name	array
[	O
INDEX	int
]	O
&&	O
need_header	bool
)	O
{	O
char	O
numbuf	array
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
say	function
(	O
"missing header for unified diff at line %s of patch\n"	pointer
,	O
format_linenum	function
(	O
numbuf	array
,	O
p_sline	long
)	O
)	O
;	O
}	O
goto	O
scan_exit	O
;	O
}	O
stars_this_line	bool
=	O
strnEQ	O
(	O
s	enum
,	O
"********"	pointer
,	O
8	int
)	O
;	O
if	O
(	O
(	O
diff_type	enum
==	O
NO_DIFF	int
||	O
diff_type	enum
==	O
CONTEXT_DIFF	int
||	O
diff_type	enum
==	O
NEW_CONTEXT_DIFF	int
)	O
&&	O
stars_last_line	bool
&&	O
strnEQ	O
(	O
s	enum
,	O
"*** "	pointer
,	O
4	int
)	O
)	O
{	O
s	enum
+=	O
4	int
;	O
if	O
(	O
s	enum
[	O
0	int
]	O
==	O
'0'	O
&&	O
!	O
ISDIGIT	O
(	O
s	enum
[	O
1	int
]	O
)	O
)	O
p_says_nonexistent	array
[	O
OLD	int
]	O
=	O
1	int
+	O
!	O
p_timestamp	array
[	O
OLD	int
]	O
.	O
tv_sec	long
;	O
while	O
(	O
*	O
s	enum
!=	O
'\n'	O
)	O
s	enum
++	O
;	O
p_indent	long
=	O
indent	long
;	O
p_strip_trailing_cr	bool
=	O
strip_trailing_cr	bool
;	O
p_start	long
=	O
previous_line	long
;	O
p_sline	long
=	O
p_input_line	long
-	O
1	int
;	O
retval	enum
=	O
(	O
*	O
(	O
s	enum
-	O
1	int
)	O
==	O
'*'	O
?	O
NEW_CONTEXT_DIFF	int
:	O
CONTEXT_DIFF	int
)	O
;	O
{	O
file_offset	long
saved_p_base	long
=	O
p_base	long
;	O
lin	long
saved_p_bline	long
=	O
p_bline	long
;	O
Fseek	function
(	O
pfp	pointer
,	O
previous_line	long
,	O
SEEK_SET	int
)	O
;	O
p_input_line	long
-=	O
2	int
;	O
if	O
(	O
another_hunk	function
(	O
retval	enum
,	O
false	int
)	O
&&	O
!	O
p_repl_lines	long
&&	O
p_newfirst	long
==	O
1	int
)	O
p_says_nonexistent	array
[	O
NEW	int
]	O
=	O
1	int
+	O
!	O
p_timestamp	array
[	O
NEW	int
]	O
.	O
tv_sec	long
;	O
next_intuit_at	function
(	O
saved_p_base	long
,	O
saved_p_bline	long
)	O
;	O
}	O
if	O
(	O
!	O
(	O
(	O
p_name	array
[	O
OLD	int
]	O
||	O
!	O
p_timestamp	array
[	O
OLD	int
]	O
.	O
tv_sec	long
)	O
&&	O
(	O
p_name	array
[	O
NEW	int
]	O
||	O
!	O
p_timestamp	array
[	O
NEW	int
]	O
.	O
tv_sec	long
)	O
)	O
&&	O
!	O
p_name	array
[	O
INDEX	int
]	O
&&	O
need_header	bool
)	O
{	O
char	O
numbuf	array
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
say	function
(	O
"missing header for context diff at line %s of patch\n"	pointer
,	O
format_linenum	function
(	O
numbuf	array
,	O
p_sline	long
)	O
)	O
;	O
}	O
goto	O
scan_exit	O
;	O
}	O
if	O
(	O
(	O
diff_type	enum
==	O
NO_DIFF	int
||	O
diff_type	enum
==	O
NORMAL_DIFF	int
)	O
&&	O
last_line_was_command	bool
&&	O
(	O
strnEQ	O
(	O
s	enum
,	O
"< "	pointer
,	O
2	int
)	O
||	O
strnEQ	O
(	O
s	enum
,	O
"> "	pointer
,	O
2	int
)	O
)	O
)	O
{	O
p_start	long
=	O
previous_line	long
;	O
p_sline	long
=	O
p_input_line	long
-	O
1	int
;	O
p_indent	long
=	O
indent	long
;	O
retval	enum
=	O
NORMAL_DIFF	int
;	O
goto	O
scan_exit	O
;	O
}	O
}	O
scan_exit	O
:	O
file_type	pointer
=	O
p_mode	array
[	O
OLD	int
]	O
&	O
S_IFMT	O
;	O
if	O
(	O
file_type	pointer
)	O
{	O
mode_t	int
new_file_type	int
=	O
p_mode	array
[	O
NEW	int
]	O
&	O
S_IFMT	O
;	O
if	O
(	O
new_file_type	int
&&	O
file_type	pointer
!=	O
new_file_type	int
)	O
file_type	pointer
=	O
0	int
;	O
}	O
else	O
{	O
file_type	pointer
=	O
p_mode	array
[	O
NEW	int
]	O
&	O
S_IFMT	O
;	O
if	O
(	O
!	O
file_type	pointer
)	O
file_type	pointer
=	O
S_IFREG	O
;	O
}	O
*	O
p_file_type	pointer
=	O
file_type	pointer
;	O
i	int
=	O
NONE	int
;	O
if	O
(	O
!	O
inname	pointer
)	O
{	O
enum	O
nametype	enum
i0	enum
=	O
NONE	int
;	O
if	O
(	O
!	O
posixly_correct	bool
&&	O
(	O
p_name	array
[	O
OLD	int
]	O
||	O
p_name	array
[	O
NEW	int
]	O
)	O
&&	O
p_name	array
[	O
INDEX	int
]	O
)	O
{	O
free	function
(	O
p_name	array
[	O
INDEX	int
]	O
)	O
;	O
p_name	array
[	O
INDEX	int
]	O
=	O
0	int
;	O
}	O
for	O
(	O
i	int
=	O
OLD	int
;	O
i	int
<=	O
INDEX	int
;	O
i	int
++	O
)	O
if	O
(	O
p_name	array
[	O
i	int
]	O
)	O
{	O
if	O
(	O
i0	enum
!=	O
NONE	int
&&	O
strcmp	function
(	O
p_name	array
[	O
i0	enum
]	O
,	O
p_name	array
[	O
i	int
]	O
)	O
==	O
0	int
)	O
{	O
stat_errno	array
[	O
i	int
]	O
=	O
stat_errno	array
[	O
i0	enum
]	O
;	O
if	O
(	O
!	O
stat_errno	array
[	O
i	int
]	O
)	O
st	pointer
[	O
i	int
]	O
=	O
st	pointer
[	O
i0	enum
]	O
;	O
}	O
else	O
if	O
(	O
lstat	function
(	O
p_name	array
[	O
i	int
]	O
,	O
&	O
st	pointer
[	O
i	int
]	O
)	O
!=	O
0	int
)	O
stat_errno	array
[	O
i	int
]	O
=	O
errno	O
;	O
else	O
if	O
(	O
lookup_file_id	function
(	O
&	O
st	pointer
[	O
i	int
]	O
)	O
==	O
DELETE_LATER	int
)	O
stat_errno	array
[	O
i	int
]	O
=	O
ENOENT	int
;	O
else	O
{	O
stat_errno	array
[	O
i	int
]	O
=	O
0	int
;	O
if	O
(	O
posixly_correct	bool
&&	O
name_is_valid	function
(	O
p_name	array
[	O
i	int
]	O
)	O
)	O
break	O
;	O
}	O
i0	enum
=	O
i	int
;	O
}	O
if	O
(	O
!	O
posixly_correct	bool
)	O
{	O
i	int
=	O
best_name	function
(	O
p_name	array
,	O
stat_errno	array
)	O
;	O
if	O
(	O
i	int
==	O
NONE	int
&&	O
patch_get	int
)	O
{	O
enum	O
nametype	enum
nope	enum
=	O
NONE	int
;	O
for	O
(	O
i	int
=	O
OLD	int
;	O
i	int
<=	O
INDEX	int
;	O
i	int
++	O
)	O
if	O
(	O
p_name	array
[	O
i	int
]	O
)	O
{	O
char	O
const	O
*	O
cs	pointer
;	O
char	O
*	O
getbuf	pointer
;	O
char	O
*	O
diffbuf	pointer
;	O
bool	bool
readonly	bool
=	O
(	O
outfile	pointer
&&	O
strcmp	function
(	O
outfile	pointer
,	O
p_name	array
[	O
i	int
]	O
)	O
!=	O
0	int
)	O
;	O
if	O
(	O
nope	enum
==	O
NONE	int
||	O
strcmp	function
(	O
p_name	array
[	O
nope	enum
]	O
,	O
p_name	array
[	O
i	int
]	O
)	O
!=	O
0	int
)	O
{	O
cs	pointer
=	O
(	O
version_controller	function
(	O
p_name	array
[	O
i	int
]	O
,	O
readonly	bool
,	O
(	O
struct	O
stat	struct
*	O
)	O
0	int
,	O
&	O
getbuf	pointer
,	O
&	O
diffbuf	pointer
)	O
)	O
;	O
version_controlled	array
[	O
i	int
]	O
=	O
!	O
!	O
cs	pointer
;	O
if	O
(	O
cs	pointer
)	O
{	O
if	O
(	O
version_get	function
(	O
p_name	array
[	O
i	int
]	O
,	O
cs	pointer
,	O
false	int
,	O
readonly	bool
,	O
getbuf	pointer
,	O
&	O
st	pointer
[	O
i	int
]	O
)	O
)	O
stat_errno	array
[	O
i	int
]	O
=	O
0	int
;	O
else	O
version_controlled	array
[	O
i	int
]	O
=	O
0	int
;	O
free	function
(	O
getbuf	pointer
)	O
;	O
free	function
(	O
diffbuf	pointer
)	O
;	O
if	O
(	O
!	O
stat_errno	array
[	O
i	int
]	O
)	O
break	O
;	O
}	O
}	O
nope	enum
=	O
i	int
;	O
}	O
}	O
if	O
(	O
i0	enum
!=	O
NONE	int
&&	O
(	O
i	int
==	O
NONE	int
||	O
(	O
st	pointer
[	O
i	int
]	O
.	O
st_mode	int
&	O
S_IFMT	O
)	O
==	O
file_type	pointer
)	O
&&	O
maybe_reverse	function
(	O
p_name	array
[	O
i	int
==	O
NONE	int
?	O
i0	enum
:	O
i	int
]	O
,	O
i	int
==	O
NONE	int
,	O
i	int
==	O
NONE	int
||	O
st	pointer
[	O
i	int
]	O
.	O
st_size	long
==	O
0	int
)	O
&&	O
i	int
==	O
NONE	int
)	O
i	int
=	O
i0	enum
;	O
if	O
(	O
i	int
==	O
NONE	int
&&	O
p_says_nonexistent	array
[	O
reverse	bool
]	O
)	O
{	O
int	O
newdirs	array
[	O
3	int
]	O
;	O
int	O
newdirs_min	int
=	O
INT_MAX	O
;	O
int	O
distance_from_minimum	array
[	O
3	int
]	O
;	O
for	O
(	O
i	int
=	O
OLD	int
;	O
i	int
<=	O
INDEX	int
;	O
i	int
++	O
)	O
if	O
(	O
p_name	array
[	O
i	int
]	O
)	O
{	O
newdirs	array
[	O
i	int
]	O
=	O
(	O
prefix_components	function
(	O
p_name	array
[	O
i	int
]	O
,	O
false	int
)	O
-	O
prefix_components	function
(	O
p_name	array
[	O
i	int
]	O
,	O
true	int
)	O
)	O
;	O
if	O
(	O
newdirs	array
[	O
i	int
]	O
<	O
newdirs_min	int
)	O
newdirs_min	int
=	O
newdirs	array
[	O
i	int
]	O
;	O
}	O
for	O
(	O
i	int
=	O
OLD	int
;	O
i	int
<=	O
INDEX	int
;	O
i	int
++	O
)	O
if	O
(	O
p_name	array
[	O
i	int
]	O
)	O
distance_from_minimum	array
[	O
i	int
]	O
=	O
newdirs	array
[	O
i	int
]	O
-	O
newdirs_min	int
;	O
i	int
=	O
best_name	function
(	O
p_name	array
,	O
distance_from_minimum	array
)	O
;	O
}	O
}	O
}	O
if	O
(	O
i	int
==	O
NONE	int
)	O
{	O
if	O
(	O
inname	pointer
)	O
{	O
inerrno	int
=	O
lstat	function
(	O
inname	pointer
,	O
&	O
instat	struct
)	O
==	O
0	int
?	O
0	int
:	O
errno	O
;	O
if	O
(	O
inerrno	int
||	O
(	O
instat	struct
.	O
st_mode	int
&	O
S_IFMT	O
)	O
==	O
file_type	pointer
)	O
maybe_reverse	function
(	O
inname	pointer
,	O
inerrno	int
,	O
inerrno	int
||	O
instat	struct
.	O
st_size	long
==	O
0	int
)	O
;	O
}	O
else	O
inerrno	int
=	O
-	O
1	int
;	O
}	O
else	O
{	O
inname	pointer
=	O
savestr	function
(	O
p_name	array
[	O
i	int
]	O
)	O
;	O
inerrno	int
=	O
stat_errno	array
[	O
i	int
]	O
;	O
invc	int
=	O
version_controlled	array
[	O
i	int
]	O
;	O
instat	struct
=	O
st	pointer
[	O
i	int
]	O
;	O
}	O
return	O
retval	enum
;	O
}	O
static	O
int	O
prefix_components	function
(	O
char	O
*	O
filename	pointer
,	O
bool	bool
checkdirs	bool
)	O
{	O
int	O
count	int
=	O
0	int
;	O
struct	O
stat	struct
stat_buf	struct
;	O
int	O
stat_result	int
;	O
char	O
*	O
f	pointer
=	O
filename	pointer
+	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
filename	pointer
)	O
;	O
if	O
(	O
*	O
f	pointer
)	O
while	O
(	O
*	O
++	O
f	pointer
)	O
if	O
(	O
ISSLASH	O
(	O
f	pointer
[	O
0	int
]	O
)	O
&&	O
!	O
ISSLASH	O
(	O
f	pointer
[	O
-	O
1	int
]	O
)	O
)	O
{	O
if	O
(	O
checkdirs	bool
)	O
{	O
*	O
f	pointer
=	O
'\0'	O
;	O
stat_result	int
=	O
lstat	function
(	O
filename	pointer
,	O
&	O
stat_buf	struct
)	O
;	O
*	O
f	pointer
=	O
'/'	O
;	O
if	O
(	O
!	O
(	O
stat_result	int
==	O
0	int
&&	O
S_ISDIR	O
(	O
stat_buf	struct
.	O
st_mode	int
)	O
)	O
)	O
break	O
;	O
}	O
count	int
++	O
;	O
}	O
return	O
count	int
;	O
}	O
static	O
enum	O
nametype	enum
best_name	function
(	O
char	O
*	O
const	O
*	O
name	pointer
,	O
int	O
const	O
*	O
ignore	pointer
)	O
{	O
enum	O
nametype	enum
i	int
;	O
int	O
components	array
[	O
3	int
]	O
;	O
int	O
components_min	int
=	O
INT_MAX	O
;	O
size_t	long
basename_len	array
[	O
3	int
]	O
;	O
size_t	long
basename_len_min	long
=	O
SIZE_MAX	O
;	O
size_t	long
len	int
[	O
3	int
]	O
;	O
size_t	long
len_min	long
=	O
SIZE_MAX	O
;	O
for	O
(	O
i	int
=	O
OLD	int
;	O
i	int
<=	O
INDEX	int
;	O
i	int
++	O
)	O
if	O
(	O
name	pointer
[	O
i	int
]	O
&&	O
!	O
ignore	pointer
[	O
i	int
]	O
)	O
{	O
components	array
[	O
i	int
]	O
=	O
prefix_components	function
(	O
name	pointer
[	O
i	int
]	O
,	O
false	int
)	O
;	O
if	O
(	O
components_min	int
<	O
components	array
[	O
i	int
]	O
)	O
continue	O
;	O
components_min	int
=	O
components	array
[	O
i	int
]	O
;	O
basename_len	array
[	O
i	int
]	O
=	O
base_len	function
(	O
name	pointer
[	O
i	int
]	O
)	O
;	O
if	O
(	O
basename_len_min	long
<	O
basename_len	array
[	O
i	int
]	O
)	O
continue	O
;	O
basename_len_min	long
=	O
basename_len	array
[	O
i	int
]	O
;	O
len	int
[	O
i	int
]	O
=	O
strlen	function
(	O
name	pointer
[	O
i	int
]	O
)	O
;	O
if	O
(	O
len_min	long
<	O
len	int
[	O
i	int
]	O
)	O
continue	O
;	O
len_min	long
=	O
len	int
[	O
i	int
]	O
;	O
}	O
for	O
(	O
i	int
=	O
OLD	int
;	O
i	int
<=	O
INDEX	int
;	O
i	int
++	O
)	O
if	O
(	O
name	pointer
[	O
i	int
]	O
&&	O
!	O
ignore	pointer
[	O
i	int
]	O
&&	O
name_is_valid	function
(	O
name	pointer
[	O
i	int
]	O
)	O
&&	O
components	array
[	O
i	int
]	O
==	O
components_min	int
&&	O
basename_len	array
[	O
i	int
]	O
==	O
basename_len_min	long
&&	O
len	int
[	O
i	int
]	O
==	O
len_min	long
)	O
break	O
;	O
return	O
i	int
;	O
}	O
static	O
void	O
next_intuit_at	function
(	O
file_offset	long
file_pos	long
,	O
lin	long
file_line	long
)	O
{	O
p_base	long
=	O
file_pos	long
;	O
p_bline	long
=	O
file_line	long
;	O
}	O
static	O
void	O
skip_to	function
(	O
file_offset	long
file_pos	long
,	O
lin	long
file_line	long
)	O
{	O
FILE	struct
*	O
i	int
=	O
pfp	pointer
;	O
FILE	struct
*	O
o	pointer
=	O
stdout	pointer
;	O
int	O
c	char
;	O
assert	O
(	O
p_base	long
<=	O
file_pos	long
)	O
;	O
if	O
(	O
(	O
verbosity	enum
==	O
VERBOSE	int
||	O
!	O
inname	pointer
)	O
&&	O
p_base	long
<	O
file_pos	long
)	O
{	O
Fseek	function
(	O
i	int
,	O
p_base	long
,	O
SEEK_SET	int
)	O
;	O
say	function
(	O
"The text leading up to this was:\n--------------------------\n"	pointer
)	O
;	O
while	O
(	O
file_tell	O
(	O
i	int
)	O
<	O
file_pos	long
)	O
{	O
putc	function
(	O
'|'	O
,	O
o	pointer
)	O
;	O
do	O
{	O
if	O
(	O
(	O
c	char
=	O
getc	function
(	O
i	int
)	O
)	O
==	O
EOF	O
)	O
read_fatal	function
(	O
)	O
;	O
putc	function
(	O
c	char
,	O
o	pointer
)	O
;	O
}	O
while	O
(	O
c	char
!=	O
'\n'	O
)	O
;	O
}	O
say	function
(	O
"--------------------------\n"	pointer
)	O
;	O
}	O
else	O
Fseek	function
(	O
i	int
,	O
file_pos	long
,	O
SEEK_SET	int
)	O
;	O
p_input_line	long
=	O
file_line	long
-	O
1	int
;	O
}	O
static	O
void	O
malformed	function
(	O
void	O
)	O
{	O
char	O
numbuf	array
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
fatal	function
(	O
"malformed patch at line %s: %s"	pointer
,	O
format_linenum	function
(	O
numbuf	array
,	O
p_input_line	long
)	O
,	O
buf	pointer
)	O
;	O
}	O
static	O
char	O
*	O
scan_linenum	function
(	O
char	O
*	O
s0	pointer
,	O
lin	long
*	O
linenum	pointer
)	O
{	O
char	O
*	O
s	enum
;	O
lin	long
n	int
=	O
0	int
;	O
bool	bool
overflow	bool
=	O
false	int
;	O
char	O
numbuf	array
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
for	O
(	O
s	enum
=	O
s0	pointer
;	O
ISDIGIT	O
(	O
*	O
s	enum
)	O
;	O
s	enum
++	O
)	O
{	O
lin	long
new_n	long
=	O
10	int
*	O
n	int
+	O
(	O
*	O
s	enum
-	O
'0'	O
)	O
;	O
overflow	bool
|=	O
new_n	long
/	O
10	int
!=	O
n	int
;	O
n	int
=	O
new_n	long
;	O
}	O
if	O
(	O
s	enum
==	O
s0	pointer
)	O
fatal	function
(	O
"missing line number at line %s: %s"	pointer
,	O
format_linenum	function
(	O
numbuf	array
,	O
p_input_line	long
)	O
,	O
buf	pointer
)	O
;	O
if	O
(	O
overflow	bool
)	O
fatal	function
(	O
"line number %.*s is too large at line %s: %s"	pointer
,	O
(	O
int	O
)	O
(	O
s	enum
-	O
s0	pointer
)	O
,	O
s0	pointer
,	O
format_linenum	function
(	O
numbuf	array
,	O
p_input_line	long
)	O
,	O
buf	pointer
)	O
;	O
*	O
linenum	pointer
=	O
n	int
;	O
return	O
s	enum
;	O
}	O
int	O
another_hunk	function
(	O
enum	O
diff	enum
difftype	enum
,	O
bool	bool
rev	bool
)	O
{	O
char	O
*	O
s	enum
;	O
lin	long
context	pointer
=	O
0	int
;	O
size_t	long
chars_read	long
;	O
char	O
numbuf0	array
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
char	O
numbuf1	array
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
char	O
numbuf2	array
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
char	O
numbuf3	array
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
while	O
(	O
p_end	long
>=	O
0	int
)	O
{	O
if	O
(	O
p_end	long
==	O
p_efake	long
)	O
p_end	long
=	O
p_bfake	long
;	O
else	O
free	function
(	O
p_line	pointer
[	O
p_end	long
]	O
)	O
;	O
p_end	long
--	O
;	O
}	O
assert	O
(	O
p_end	long
==	O
-	O
1	int
)	O
;	O
p_efake	long
=	O
-	O
1	int
;	O
if	O
(	O
p_c_function	pointer
)	O
{	O
free	function
(	O
p_c_function	pointer
)	O
;	O
p_c_function	pointer
=	O
NULL	O
;	O
}	O
p_max	long
=	O
hunkmax	long
;	O
if	O
(	O
difftype	enum
==	O
CONTEXT_DIFF	int
||	O
difftype	enum
==	O
NEW_CONTEXT_DIFF	int
)	O
{	O
file_offset	long
line_beginning	long
=	O
file_tell	O
(	O
pfp	pointer
)	O
;	O
lin	long
repl_beginning	long
=	O
0	int
;	O
lin	long
fillcnt	long
=	O
0	int
;	O
lin	long
fillsrc	long
;	O
lin	long
filldst	long
;	O
bool	bool
ptrn_spaces_eaten	bool
=	O
false	int
;	O
bool	bool
some_context	bool
=	O
false	int
;	O
bool	bool
repl_could_be_missing	bool
=	O
true	int
;	O
bool	bool
ptrn_missing	bool
=	O
false	int
;	O
bool	bool
repl_missing	bool
=	O
false	int
;	O
file_offset	long
repl_backtrack_position	long
=	O
0	int
;	O
lin	long
repl_patch_line	long
;	O
lin	long
repl_context	long
;	O
lin	long
ptrn_prefix_context	long
=	O
-	O
1	int
;	O
lin	long
ptrn_suffix_context	long
=	O
-	O
1	int
;	O
lin	long
repl_prefix_context	long
=	O
-	O
1	int
;	O
lin	long
ptrn_copiable	long
=	O
0	int
;	O
lin	long
repl_copiable	long
=	O
0	int
;	O
fillsrc	long
=	O
filldst	long
=	O
repl_patch_line	long
=	O
repl_context	long
=	O
0	int
;	O
chars_read	long
=	O
get_line	function
(	O
)	O
;	O
if	O
(	O
chars_read	long
==	O
(	O
size_t	long
)	O
-	O
1	int
||	O
chars_read	long
<=	O
8	int
||	O
strncmp	function
(	O
buf	pointer
,	O
"********"	pointer
,	O
8	int
)	O
!=	O
0	int
)	O
{	O
next_intuit_at	function
(	O
line_beginning	long
,	O
p_input_line	long
)	O
;	O
return	O
chars_read	long
==	O
(	O
size_t	long
)	O
-	O
1	int
?	O
-	O
1	int
:	O
0	int
;	O
}	O
s	enum
=	O
buf	pointer
;	O
while	O
(	O
*	O
s	enum
==	O
'*'	O
)	O
s	enum
++	O
;	O
if	O
(	O
*	O
s	enum
==	O
' '	O
)	O
{	O
p_c_function	pointer
=	O
s	enum
;	O
while	O
(	O
*	O
s	enum
!=	O
'\n'	O
)	O
s	enum
++	O
;	O
*	O
s	enum
=	O
'\0'	O
;	O
p_c_function	pointer
=	O
savestr	function
(	O
p_c_function	pointer
)	O
;	O
}	O
p_hunk_beg	long
=	O
p_input_line	long
+	O
1	int
;	O
while	O
(	O
p_end	long
<	O
p_max	long
)	O
{	O
chars_read	long
=	O
get_line	function
(	O
)	O
;	O
if	O
(	O
chars_read	long
==	O
(	O
size_t	long
)	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
!	O
chars_read	long
)	O
{	O
if	O
(	O
repl_beginning	long
&&	O
repl_could_be_missing	bool
)	O
{	O
repl_missing	bool
=	O
true	int
;	O
goto	O
hunk_done	O
;	O
}	O
if	O
(	O
p_max	long
-	O
p_end	long
<	O
4	int
)	O
{	O
strcpy	function
(	O
buf	pointer
,	O
"  \n"	pointer
)	O
;	O
chars_read	long
=	O
3	int
;	O
}	O
else	O
{	O
fatal	function
(	O
"unexpected end of file in patch"	pointer
)	O
;	O
}	O
}	O
p_end	long
++	O
;	O
if	O
(	O
p_end	long
==	O
hunkmax	long
)	O
fatal	function
(	O
"unterminated hunk starting at line %s; giving up at line %s: %s"	pointer
,	O
format_linenum	function
(	O
numbuf0	array
,	O
pch_hunk_beg	function
(	O
)	O
)	O
,	O
format_linenum	function
(	O
numbuf1	array
,	O
p_input_line	long
)	O
,	O
buf	pointer
)	O
;	O
assert	O
(	O
p_end	long
<	O
hunkmax	long
)	O
;	O
p_Char	pointer
[	O
p_end	long
]	O
=	O
*	O
buf	pointer
;	O
p_len	pointer
[	O
p_end	long
]	O
=	O
0	int
;	O
p_line	pointer
[	O
p_end	long
]	O
=	O
0	int
;	O
switch	O
(	O
*	O
buf	pointer
)	O
{	O
case	O
'*'	O
:	O
if	O
(	O
strnEQ	O
(	O
buf	pointer
,	O
"********"	pointer
,	O
8	int
)	O
)	O
{	O
if	O
(	O
repl_beginning	long
&&	O
repl_could_be_missing	bool
)	O
{	O
repl_missing	bool
=	O
true	int
;	O
goto	O
hunk_done	O
;	O
}	O
else	O
fatal	function
(	O
"unexpected end of hunk at line %s"	pointer
,	O
format_linenum	function
(	O
numbuf0	array
,	O
p_input_line	long
)	O
)	O
;	O
}	O
if	O
(	O
p_end	long
!=	O
0	int
)	O
{	O
if	O
(	O
repl_beginning	long
&&	O
repl_could_be_missing	bool
)	O
{	O
repl_missing	bool
=	O
true	int
;	O
goto	O
hunk_done	O
;	O
}	O
fatal	function
(	O
"unexpected '***' at line %s: %s"	pointer
,	O
format_linenum	function
(	O
numbuf0	array
,	O
p_input_line	long
)	O
,	O
buf	pointer
)	O
;	O
}	O
context	pointer
=	O
0	int
;	O
p_len	pointer
[	O
p_end	long
]	O
=	O
strlen	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
!	O
(	O
p_line	pointer
[	O
p_end	long
]	O
=	O
savestr	function
(	O
buf	pointer
)	O
)	O
)	O
{	O
p_end	long
--	O
;	O
return	O
-	O
1	int
;	O
}	O
for	O
(	O
s	enum
=	O
buf	pointer
;	O
*	O
s	enum
&&	O
!	O
ISDIGIT	O
(	O
*	O
s	enum
)	O
;	O
s	enum
++	O
)	O
;	O
if	O
(	O
strnEQ	O
(	O
s	enum
,	O
"0,0"	pointer
,	O
3	int
)	O
)	O
remove_prefix	function
(	O
s	enum
,	O
2	int
)	O
;	O
s	enum
=	O
scan_linenum	function
(	O
s	enum
,	O
&	O
p_first	long
)	O
;	O
if	O
(	O
*	O
s	enum
==	O
','	O
)	O
{	O
while	O
(	O
*	O
s	enum
&&	O
!	O
ISDIGIT	O
(	O
*	O
s	enum
)	O
)	O
s	enum
++	O
;	O
scan_linenum	function
(	O
s	enum
,	O
&	O
p_ptrn_lines	long
)	O
;	O
p_ptrn_lines	long
+=	O
1	int
-	O
p_first	long
;	O
}	O
else	O
if	O
(	O
p_first	long
)	O
p_ptrn_lines	long
=	O
1	int
;	O
else	O
{	O
p_ptrn_lines	long
=	O
0	int
;	O
p_first	long
=	O
1	int
;	O
}	O
p_max	long
=	O
p_ptrn_lines	long
+	O
6	int
;	O
while	O
(	O
p_max	long
+	O
1	int
>=	O
hunkmax	long
)	O
if	O
(	O
!	O
grow_hunkmax	function
(	O
)	O
)	O
return	O
-	O
1	int
;	O
p_max	long
=	O
hunkmax	long
;	O
break	O
;	O
case	O
'-'	O
:	O
if	O
(	O
buf	pointer
[	O
1	int
]	O
!=	O
'-'	O
)	O
goto	O
change_line	O
;	O
if	O
(	O
ptrn_prefix_context	long
==	O
-	O
1	int
)	O
ptrn_prefix_context	long
=	O
context	pointer
;	O
ptrn_suffix_context	long
=	O
context	pointer
;	O
if	O
(	O
repl_beginning	long
||	O
(	O
p_end	long
!=	O
p_ptrn_lines	long
+	O
1	int
+	O
(	O
p_Char	pointer
[	O
p_end	long
-	O
1	int
]	O
==	O
'\n'	O
)	O
)	O
)	O
{	O
if	O
(	O
p_end	long
==	O
1	int
)	O
{	O
ptrn_missing	bool
=	O
true	int
;	O
p_end	long
=	O
p_ptrn_lines	long
+	O
1	int
;	O
ptrn_prefix_context	long
=	O
ptrn_suffix_context	long
=	O
-	O
1	int
;	O
fillsrc	long
=	O
p_end	long
+	O
1	int
;	O
filldst	long
=	O
1	int
;	O
fillcnt	long
=	O
p_ptrn_lines	long
;	O
}	O
else	O
if	O
(	O
!	O
repl_beginning	long
)	O
fatal	function
(	O
"%s '---' at line %s; check line numbers at line %s"	pointer
,	O
(	O
p_end	long
<=	O
p_ptrn_lines	long
?	O
"Premature"	pointer
:	O
"Overdue"	pointer
)	O
,	O
format_linenum	function
(	O
numbuf0	array
,	O
p_input_line	long
)	O
,	O
format_linenum	function
(	O
numbuf1	array
,	O
p_hunk_beg	long
)	O
)	O
;	O
else	O
if	O
(	O
!	O
repl_could_be_missing	bool
)	O
fatal	function
(	O
"duplicate '---' at line %s; check line numbers at line %s"	pointer
,	O
format_linenum	function
(	O
numbuf0	array
,	O
p_input_line	long
)	O
,	O
format_linenum	function
(	O
numbuf1	array
,	O
p_hunk_beg	long
+	O
repl_beginning	long
)	O
)	O
;	O
else	O
{	O
repl_missing	bool
=	O
true	int
;	O
goto	O
hunk_done	O
;	O
}	O
}	O
repl_beginning	long
=	O
p_end	long
;	O
repl_backtrack_position	long
=	O
file_tell	O
(	O
pfp	pointer
)	O
;	O
repl_patch_line	long
=	O
p_input_line	long
;	O
repl_context	long
=	O
context	pointer
;	O
p_len	pointer
[	O
p_end	long
]	O
=	O
strlen	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
!	O
(	O
p_line	pointer
[	O
p_end	long
]	O
=	O
savestr	function
(	O
buf	pointer
)	O
)	O
)	O
{	O
p_end	long
--	O
;	O
return	O
-	O
1	int
;	O
}	O
p_Char	pointer
[	O
p_end	long
]	O
=	O
'='	O
;	O
for	O
(	O
s	enum
=	O
buf	pointer
;	O
*	O
s	enum
&&	O
!	O
ISDIGIT	O
(	O
*	O
s	enum
)	O
;	O
s	enum
++	O
)	O
;	O
s	enum
=	O
scan_linenum	function
(	O
s	enum
,	O
&	O
p_newfirst	long
)	O
;	O
if	O
(	O
*	O
s	enum
==	O
','	O
)	O
{	O
do	O
{	O
if	O
(	O
!	O
*	O
++	O
s	enum
)	O
malformed	function
(	O
)	O
;	O
}	O
while	O
(	O
!	O
ISDIGIT	O
(	O
*	O
s	enum
)	O
)	O
;	O
scan_linenum	function
(	O
s	enum
,	O
&	O
p_repl_lines	long
)	O
;	O
p_repl_lines	long
+=	O
1	int
-	O
p_newfirst	long
;	O
}	O
else	O
if	O
(	O
p_newfirst	long
)	O
p_repl_lines	long
=	O
1	int
;	O
else	O
{	O
p_repl_lines	long
=	O
0	int
;	O
p_newfirst	long
=	O
1	int
;	O
}	O
p_max	long
=	O
p_repl_lines	long
+	O
p_end	long
;	O
while	O
(	O
p_max	long
+	O
1	int
>=	O
hunkmax	long
)	O
if	O
(	O
!	O
grow_hunkmax	function
(	O
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
p_repl_lines	long
!=	O
ptrn_copiable	long
&&	O
(	O
p_prefix_context	long
!=	O
0	int
||	O
context	pointer
!=	O
0	int
||	O
p_repl_lines	long
!=	O
1	int
)	O
)	O
repl_could_be_missing	bool
=	O
false	int
;	O
context	pointer
=	O
0	int
;	O
break	O
;	O
case	O
'+'	O
:	O
case	O
'!'	O
:	O
repl_could_be_missing	bool
=	O
false	int
;	O
change_line	O
:	O
s	enum
=	O
buf	pointer
+	O
1	int
;	O
chars_read	long
--	O
;	O
if	O
(	O
*	O
s	enum
==	O
'\n'	O
&&	O
canonicalize	bool
)	O
{	O
strcpy	function
(	O
s	enum
,	O
" \n"	pointer
)	O
;	O
chars_read	long
=	O
2	int
;	O
}	O
if	O
(	O
*	O
s	enum
==	O
' '	O
||	O
*	O
s	enum
==	O
'\t'	O
)	O
{	O
s	enum
++	O
;	O
chars_read	long
--	O
;	O
}	O
else	O
if	O
(	O
repl_beginning	long
&&	O
repl_could_be_missing	bool
)	O
{	O
repl_missing	bool
=	O
true	int
;	O
goto	O
hunk_done	O
;	O
}	O
if	O
(	O
!	O
repl_beginning	long
)	O
{	O
if	O
(	O
ptrn_prefix_context	long
==	O
-	O
1	int
)	O
ptrn_prefix_context	long
=	O
context	pointer
;	O
}	O
else	O
{	O
if	O
(	O
repl_prefix_context	long
==	O
-	O
1	int
)	O
repl_prefix_context	long
=	O
context	pointer
;	O
}	O
chars_read	long
-=	O
(	O
1	int
<	O
chars_read	long
&&	O
p_end	long
==	O
(	O
repl_beginning	long
?	O
p_max	long
:	O
p_ptrn_lines	long
)	O
&&	O
incomplete_line	function
(	O
)	O
)	O
;	O
p_len	pointer
[	O
p_end	long
]	O
=	O
chars_read	long
;	O
p_line	pointer
[	O
p_end	long
]	O
=	O
savebuf	function
(	O
s	enum
,	O
chars_read	long
)	O
;	O
if	O
(	O
chars_read	long
&&	O
!	O
p_line	pointer
[	O
p_end	long
]	O
)	O
{	O
p_end	long
--	O
;	O
return	O
-	O
1	int
;	O
}	O
context	pointer
=	O
0	int
;	O
break	O
;	O
case	O
'\t'	O
:	O
case	O
'\n'	O
:	O
s	enum
=	O
buf	pointer
;	O
if	O
(	O
*	O
buf	pointer
==	O
'\t'	O
)	O
{	O
s	enum
++	O
;	O
chars_read	long
--	O
;	O
}	O
if	O
(	O
repl_beginning	long
&&	O
repl_could_be_missing	bool
&&	O
(	O
!	O
ptrn_spaces_eaten	bool
||	O
difftype	enum
==	O
NEW_CONTEXT_DIFF	int
)	O
)	O
{	O
repl_missing	bool
=	O
true	int
;	O
goto	O
hunk_done	O
;	O
}	O
chars_read	long
-=	O
(	O
1	int
<	O
chars_read	long
&&	O
p_end	long
==	O
(	O
repl_beginning	long
?	O
p_max	long
:	O
p_ptrn_lines	long
)	O
&&	O
incomplete_line	function
(	O
)	O
)	O
;	O
p_len	pointer
[	O
p_end	long
]	O
=	O
chars_read	long
;	O
p_line	pointer
[	O
p_end	long
]	O
=	O
savebuf	function
(	O
buf	pointer
,	O
chars_read	long
)	O
;	O
if	O
(	O
chars_read	long
&&	O
!	O
p_line	pointer
[	O
p_end	long
]	O
)	O
{	O
p_end	long
--	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
p_end	long
!=	O
p_ptrn_lines	long
+	O
1	int
)	O
{	O
ptrn_spaces_eaten	bool
|=	O
(	O
repl_beginning	long
!=	O
0	int
)	O
;	O
some_context	bool
=	O
true	int
;	O
context	pointer
++	O
;	O
if	O
(	O
repl_beginning	long
)	O
repl_copiable	long
++	O
;	O
else	O
ptrn_copiable	long
++	O
;	O
p_Char	pointer
[	O
p_end	long
]	O
=	O
' '	O
;	O
}	O
break	O
;	O
case	O
' '	O
:	O
s	enum
=	O
buf	pointer
+	O
1	int
;	O
chars_read	long
--	O
;	O
if	O
(	O
*	O
s	enum
==	O
'\n'	O
&&	O
canonicalize	bool
)	O
{	O
strcpy	function
(	O
s	enum
,	O
"\n"	pointer
)	O
;	O
chars_read	long
=	O
2	int
;	O
}	O
if	O
(	O
*	O
s	enum
==	O
' '	O
||	O
*	O
s	enum
==	O
'\t'	O
)	O
{	O
s	enum
++	O
;	O
chars_read	long
--	O
;	O
}	O
else	O
if	O
(	O
repl_beginning	long
&&	O
repl_could_be_missing	bool
)	O
{	O
repl_missing	bool
=	O
true	int
;	O
goto	O
hunk_done	O
;	O
}	O
some_context	bool
=	O
true	int
;	O
context	pointer
++	O
;	O
if	O
(	O
repl_beginning	long
)	O
repl_copiable	long
++	O
;	O
else	O
ptrn_copiable	long
++	O
;	O
chars_read	long
-=	O
(	O
1	int
<	O
chars_read	long
&&	O
p_end	long
==	O
(	O
repl_beginning	long
?	O
p_max	long
:	O
p_ptrn_lines	long
)	O
&&	O
incomplete_line	function
(	O
)	O
)	O
;	O
p_len	pointer
[	O
p_end	long
]	O
=	O
chars_read	long
;	O
p_line	pointer
[	O
p_end	long
]	O
=	O
savebuf	function
(	O
s	enum
,	O
chars_read	long
)	O
;	O
if	O
(	O
chars_read	long
&&	O
!	O
p_line	pointer
[	O
p_end	long
]	O
)	O
{	O
p_end	long
--	O
;	O
return	O
-	O
1	int
;	O
}	O
break	O
;	O
default	O
:	O
if	O
(	O
repl_beginning	long
&&	O
repl_could_be_missing	bool
)	O
{	O
repl_missing	bool
=	O
true	int
;	O
goto	O
hunk_done	O
;	O
}	O
malformed	function
(	O
)	O
;	O
}	O
}	O
hunk_done	O
:	O
if	O
(	O
p_end	long
>=	O
0	int
&&	O
!	O
repl_beginning	long
)	O
fatal	function
(	O
"no '---' found in patch at line %s"	pointer
,	O
format_linenum	function
(	O
numbuf0	array
,	O
pch_hunk_beg	function
(	O
)	O
)	O
)	O
;	O
if	O
(	O
repl_missing	bool
)	O
{	O
p_input_line	long
=	O
repl_patch_line	long
;	O
context	pointer
=	O
repl_context	long
;	O
for	O
(	O
p_end	long
--	O
;	O
p_end	long
>	O
repl_beginning	long
;	O
p_end	long
--	O
)	O
free	function
(	O
p_line	pointer
[	O
p_end	long
]	O
)	O
;	O
Fseek	function
(	O
pfp	pointer
,	O
repl_backtrack_position	long
,	O
SEEK_SET	int
)	O
;	O
fillsrc	long
=	O
1	int
;	O
filldst	long
=	O
repl_beginning	long
+	O
1	int
;	O
fillcnt	long
=	O
p_repl_lines	long
;	O
p_end	long
=	O
p_max	long
;	O
}	O
else	O
if	O
(	O
!	O
ptrn_missing	bool
&&	O
ptrn_copiable	long
!=	O
repl_copiable	long
)	O
fatal	function
(	O
"context mangled in hunk at line %s"	pointer
,	O
format_linenum	function
(	O
numbuf0	array
,	O
p_hunk_beg	long
)	O
)	O
;	O
else	O
if	O
(	O
!	O
some_context	bool
&&	O
fillcnt	long
==	O
1	int
)	O
{	O
while	O
(	O
filldst	long
<	O
p_end	long
)	O
{	O
p_line	pointer
[	O
filldst	long
]	O
=	O
p_line	pointer
[	O
filldst	long
+	O
1	int
]	O
;	O
p_Char	pointer
[	O
filldst	long
]	O
=	O
p_Char	pointer
[	O
filldst	long
+	O
1	int
]	O
;	O
p_len	pointer
[	O
filldst	long
]	O
=	O
p_len	pointer
[	O
filldst	long
+	O
1	int
]	O
;	O
filldst	long
++	O
;	O
}	O
p_end	long
--	O
;	O
p_first	long
++	O
;	O
fillcnt	long
=	O
0	int
;	O
p_ptrn_lines	long
=	O
0	int
;	O
}	O
p_prefix_context	long
=	O
(	O
(	O
repl_prefix_context	long
==	O
-	O
1	int
||	O
(	O
ptrn_prefix_context	long
!=	O
-	O
1	int
&&	O
ptrn_prefix_context	long
<	O
repl_prefix_context	long
)	O
)	O
?	O
ptrn_prefix_context	long
:	O
repl_prefix_context	long
)	O
;	O
p_suffix_context	long
=	O
(	O
(	O
ptrn_suffix_context	long
!=	O
-	O
1	int
&&	O
ptrn_suffix_context	long
<	O
context	pointer
)	O
?	O
ptrn_suffix_context	long
:	O
context	pointer
)	O
;	O
if	O
(	O
p_prefix_context	long
==	O
-	O
1	int
||	O
p_suffix_context	long
==	O
-	O
1	int
)	O
fatal	function
(	O
"replacement text or line numbers mangled in hunk at line %s"	pointer
,	O
format_linenum	function
(	O
numbuf0	array
,	O
p_hunk_beg	long
)	O
)	O
;	O
if	O
(	O
difftype	enum
==	O
CONTEXT_DIFF	int
&&	O
(	O
fillcnt	long
||	O
(	O
p_first	long
>	O
1	int
&&	O
p_prefix_context	long
+	O
p_suffix_context	long
<	O
ptrn_copiable	long
)	O
)	O
)	O
{	O
if	O
(	O
verbosity	enum
==	O
VERBOSE	int
)	O
say	function
(	O
"%s\n%s\n%s\n"	pointer
,	O
"(Fascinating -- this is really a new-style context diff but without"	pointer
,	O
"the telltale extra asterisks on the *** line that usually indicate"	pointer
,	O
"the new style...)"	pointer
)	O
;	O
diff_type	enum
=	O
difftype	enum
=	O
NEW_CONTEXT_DIFF	int
;	O
}	O
if	O
(	O
fillcnt	long
)	O
{	O
p_bfake	long
=	O
filldst	long
;	O
p_efake	long
=	O
filldst	long
+	O
fillcnt	long
-	O
1	int
;	O
while	O
(	O
fillcnt	long
--	O
>	O
0	int
)	O
{	O
while	O
(	O
fillsrc	long
<=	O
p_end	long
&&	O
fillsrc	long
!=	O
repl_beginning	long
&&	O
p_Char	pointer
[	O
fillsrc	long
]	O
!=	O
' '	O
)	O
fillsrc	long
++	O
;	O
if	O
(	O
p_end	long
<	O
fillsrc	long
||	O
fillsrc	long
==	O
repl_beginning	long
)	O
{	O
fatal	function
(	O
"replacement text or line numbers mangled in hunk at line %s"	pointer
,	O
format_linenum	function
(	O
numbuf0	array
,	O
p_hunk_beg	long
)	O
)	O
;	O
}	O
p_line	pointer
[	O
filldst	long
]	O
=	O
p_line	pointer
[	O
fillsrc	long
]	O
;	O
p_Char	pointer
[	O
filldst	long
]	O
=	O
p_Char	pointer
[	O
fillsrc	long
]	O
;	O
p_len	pointer
[	O
filldst	long
]	O
=	O
p_len	pointer
[	O
fillsrc	long
]	O
;	O
fillsrc	long
++	O
;	O
filldst	long
++	O
;	O
}	O
while	O
(	O
fillsrc	long
<=	O
p_end	long
&&	O
fillsrc	long
!=	O
repl_beginning	long
)	O
{	O
if	O
(	O
p_Char	pointer
[	O
fillsrc	long
]	O
==	O
' '	O
)	O
fatal	function
(	O
"replacement text or line numbers mangled in hunk at line %s"	pointer
,	O
format_linenum	function
(	O
numbuf0	array
,	O
p_hunk_beg	long
)	O
)	O
;	O
fillsrc	long
++	O
;	O
}	O
if	O
(	O
debug	int
&	O
64	int
)	O
printf	function
(	O
"fillsrc %s, filldst %s, rb %s, e+1 %s\n"	pointer
,	O
format_linenum	function
(	O
numbuf0	array
,	O
fillsrc	long
)	O
,	O
format_linenum	function
(	O
numbuf1	array
,	O
filldst	long
)	O
,	O
format_linenum	function
(	O
numbuf2	array
,	O
repl_beginning	long
)	O
,	O
format_linenum	function
(	O
numbuf3	array
,	O
p_end	long
+	O
1	int
)	O
)	O
;	O
assert	O
(	O
fillsrc	long
==	O
p_end	long
+	O
1	int
||	O
fillsrc	long
==	O
repl_beginning	long
)	O
;	O
assert	O
(	O
filldst	long
==	O
p_end	long
+	O
1	int
||	O
filldst	long
==	O
repl_beginning	long
)	O
;	O
}	O
}	O
else	O
if	O
(	O
difftype	enum
==	O
UNI_DIFF	int
)	O
{	O
file_offset	long
line_beginning	long
=	O
file_tell	O
(	O
pfp	pointer
)	O
;	O
lin	long
fillsrc	long
;	O
lin	long
filldst	long
;	O
char	O
ch	char
=	O
'\0'	O
;	O
chars_read	long
=	O
get_line	function
(	O
)	O
;	O
if	O
(	O
chars_read	long
==	O
(	O
size_t	long
)	O
-	O
1	int
||	O
chars_read	long
<=	O
4	int
||	O
strncmp	function
(	O
buf	pointer
,	O
"@@ -"	pointer
,	O
4	int
)	O
!=	O
0	int
)	O
{	O
next_intuit_at	function
(	O
line_beginning	long
,	O
p_input_line	long
)	O
;	O
return	O
chars_read	long
==	O
(	O
size_t	long
)	O
-	O
1	int
?	O
-	O
1	int
:	O
0	int
;	O
}	O
s	enum
=	O
scan_linenum	function
(	O
buf	pointer
+	O
4	int
,	O
&	O
p_first	long
)	O
;	O
if	O
(	O
*	O
s	enum
==	O
','	O
)	O
s	enum
=	O
scan_linenum	function
(	O
s	enum
+	O
1	int
,	O
&	O
p_ptrn_lines	long
)	O
;	O
else	O
p_ptrn_lines	long
=	O
1	int
;	O
if	O
(	O
*	O
s	enum
==	O
' '	O
)	O
s	enum
++	O
;	O
if	O
(	O
*	O
s	enum
!=	O
'+'	O
)	O
malformed	function
(	O
)	O
;	O
s	enum
=	O
scan_linenum	function
(	O
s	enum
+	O
1	int
,	O
&	O
p_newfirst	long
)	O
;	O
if	O
(	O
*	O
s	enum
==	O
','	O
)	O
s	enum
=	O
scan_linenum	function
(	O
s	enum
+	O
1	int
,	O
&	O
p_repl_lines	long
)	O
;	O
else	O
p_repl_lines	long
=	O
1	int
;	O
if	O
(	O
*	O
s	enum
==	O
' '	O
)	O
s	enum
++	O
;	O
if	O
(	O
*	O
s	enum
++	O
!=	O
'@'	O
)	O
malformed	function
(	O
)	O
;	O
if	O
(	O
*	O
s	enum
++	O
==	O
'@'	O
&&	O
*	O
s	enum
==	O
' '	O
&&	O
*	O
s	enum
!=	O
'\0'	O
)	O
{	O
p_c_function	pointer
=	O
s	enum
;	O
while	O
(	O
*	O
s	enum
!=	O
'\n'	O
)	O
s	enum
++	O
;	O
*	O
s	enum
=	O
'\0'	O
;	O
p_c_function	pointer
=	O
savestr	function
(	O
p_c_function	pointer
)	O
;	O
}	O
if	O
(	O
!	O
p_ptrn_lines	long
)	O
p_first	long
++	O
;	O
if	O
(	O
!	O
p_repl_lines	long
)	O
p_newfirst	long
++	O
;	O
p_max	long
=	O
p_ptrn_lines	long
+	O
p_repl_lines	long
+	O
1	int
;	O
while	O
(	O
p_max	long
+	O
1	int
>=	O
hunkmax	long
)	O
if	O
(	O
!	O
grow_hunkmax	function
(	O
)	O
)	O
return	O
-	O
1	int
;	O
fillsrc	long
=	O
1	int
;	O
filldst	long
=	O
fillsrc	long
+	O
p_ptrn_lines	long
;	O
p_end	long
=	O
filldst	long
+	O
p_repl_lines	long
;	O
sprintf	function
(	O
buf	pointer
,	O
"*** %s,%s ****\n"	pointer
,	O
format_linenum	function
(	O
numbuf0	array
,	O
p_first	long
)	O
,	O
format_linenum	function
(	O
numbuf1	array
,	O
p_first	long
+	O
p_ptrn_lines	long
-	O
1	int
)	O
)	O
;	O
p_len	pointer
[	O
0	int
]	O
=	O
strlen	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
!	O
(	O
p_line	pointer
[	O
0	int
]	O
=	O
savestr	function
(	O
buf	pointer
)	O
)	O
)	O
{	O
p_end	long
=	O
-	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
p_Char	pointer
[	O
0	int
]	O
=	O
'*'	O
;	O
sprintf	function
(	O
buf	pointer
,	O
"--- %s,%s ----\n"	pointer
,	O
format_linenum	function
(	O
numbuf0	array
,	O
p_newfirst	long
)	O
,	O
format_linenum	function
(	O
numbuf1	array
,	O
p_newfirst	long
+	O
p_repl_lines	long
-	O
1	int
)	O
)	O
;	O
p_len	pointer
[	O
filldst	long
]	O
=	O
strlen	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
!	O
(	O
p_line	pointer
[	O
filldst	long
]	O
=	O
savestr	function
(	O
buf	pointer
)	O
)	O
)	O
{	O
p_end	long
=	O
0	int
;	O
return	O
-	O
1	int
;	O
}	O
p_Char	pointer
[	O
filldst	long
++	O
]	O
=	O
'='	O
;	O
p_prefix_context	long
=	O
-	O
1	int
;	O
p_hunk_beg	long
=	O
p_input_line	long
+	O
1	int
;	O
while	O
(	O
fillsrc	long
<=	O
p_ptrn_lines	long
||	O
filldst	long
<=	O
p_end	long
)	O
{	O
chars_read	long
=	O
get_line	function
(	O
)	O
;	O
if	O
(	O
!	O
chars_read	long
)	O
{	O
if	O
(	O
p_max	long
-	O
filldst	long
<	O
3	int
)	O
{	O
strcpy	function
(	O
buf	pointer
,	O
" \n"	pointer
)	O
;	O
chars_read	long
=	O
2	int
;	O
}	O
else	O
{	O
fatal	function
(	O
"unexpected end of file in patch"	pointer
)	O
;	O
}	O
}	O
if	O
(	O
chars_read	long
==	O
(	O
size_t	long
)	O
-	O
1	int
)	O
s	enum
=	O
0	int
;	O
else	O
if	O
(	O
*	O
buf	pointer
==	O
'\t'	O
||	O
*	O
buf	pointer
==	O
'\n'	O
)	O
{	O
ch	char
=	O
' '	O
;	O
s	enum
=	O
savebuf	function
(	O
buf	pointer
,	O
chars_read	long
)	O
;	O
}	O
else	O
{	O
ch	char
=	O
*	O
buf	pointer
;	O
s	enum
=	O
savebuf	function
(	O
buf	pointer
+	O
1	int
,	O
--	O
chars_read	long
)	O
;	O
}	O
if	O
(	O
chars_read	long
&&	O
!	O
s	enum
)	O
{	O
while	O
(	O
--	O
filldst	long
>	O
p_ptrn_lines	long
)	O
free	function
(	O
p_line	pointer
[	O
filldst	long
]	O
)	O
;	O
p_end	long
=	O
fillsrc	long
-	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
switch	O
(	O
ch	char
)	O
{	O
case	O
'-'	O
:	O
if	O
(	O
fillsrc	long
>	O
p_ptrn_lines	long
)	O
{	O
free	function
(	O
s	enum
)	O
;	O
p_end	long
=	O
filldst	long
-	O
1	int
;	O
malformed	function
(	O
)	O
;	O
}	O
chars_read	long
-=	O
fillsrc	long
==	O
p_ptrn_lines	long
&&	O
incomplete_line	function
(	O
)	O
;	O
p_Char	pointer
[	O
fillsrc	long
]	O
=	O
ch	char
;	O
p_line	pointer
[	O
fillsrc	long
]	O
=	O
s	enum
;	O
p_len	pointer
[	O
fillsrc	long
++	O
]	O
=	O
chars_read	long
;	O
break	O
;	O
case	O
'='	O
:	O
ch	char
=	O
' '	O
;	O
case	O
' '	O
:	O
if	O
(	O
fillsrc	long
>	O
p_ptrn_lines	long
)	O
{	O
free	function
(	O
s	enum
)	O
;	O
while	O
(	O
--	O
filldst	long
>	O
p_ptrn_lines	long
)	O
free	function
(	O
p_line	pointer
[	O
filldst	long
]	O
)	O
;	O
p_end	long
=	O
fillsrc	long
-	O
1	int
;	O
malformed	function
(	O
)	O
;	O
}	O
context	pointer
++	O
;	O
chars_read	long
-=	O
fillsrc	long
==	O
p_ptrn_lines	long
&&	O
incomplete_line	function
(	O
)	O
;	O
p_Char	pointer
[	O
fillsrc	long
]	O
=	O
ch	char
;	O
p_line	pointer
[	O
fillsrc	long
]	O
=	O
s	enum
;	O
p_len	pointer
[	O
fillsrc	long
++	O
]	O
=	O
chars_read	long
;	O
s	enum
=	O
savebuf	function
(	O
s	enum
,	O
chars_read	long
)	O
;	O
if	O
(	O
chars_read	long
&&	O
!	O
s	enum
)	O
{	O
while	O
(	O
--	O
filldst	long
>	O
p_ptrn_lines	long
)	O
free	function
(	O
p_line	pointer
[	O
filldst	long
]	O
)	O
;	O
p_end	long
=	O
fillsrc	long
-	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
case	O
'+'	O
:	O
if	O
(	O
filldst	long
>	O
p_end	long
)	O
{	O
free	function
(	O
s	enum
)	O
;	O
while	O
(	O
--	O
filldst	long
>	O
p_ptrn_lines	long
)	O
free	function
(	O
p_line	pointer
[	O
filldst	long
]	O
)	O
;	O
p_end	long
=	O
fillsrc	long
-	O
1	int
;	O
malformed	function
(	O
)	O
;	O
}	O
chars_read	long
-=	O
filldst	long
==	O
p_end	long
&&	O
incomplete_line	function
(	O
)	O
;	O
p_Char	pointer
[	O
filldst	long
]	O
=	O
ch	char
;	O
p_line	pointer
[	O
filldst	long
]	O
=	O
s	enum
;	O
p_len	pointer
[	O
filldst	long
++	O
]	O
=	O
chars_read	long
;	O
break	O
;	O
default	O
:	O
p_end	long
=	O
filldst	long
;	O
malformed	function
(	O
)	O
;	O
}	O
if	O
(	O
ch	char
!=	O
' '	O
)	O
{	O
if	O
(	O
p_prefix_context	long
==	O
-	O
1	int
)	O
p_prefix_context	long
=	O
context	pointer
;	O
context	pointer
=	O
0	int
;	O
}	O
}	O
if	O
(	O
p_prefix_context	long
==	O
-	O
1	int
)	O
malformed	function
(	O
)	O
;	O
p_suffix_context	long
=	O
context	pointer
;	O
}	O
else	O
{	O
char	O
hunk_type	char
;	O
int	O
i	int
;	O
lin	long
min	long
,	O
max	long
;	O
file_offset	long
line_beginning	long
=	O
file_tell	O
(	O
pfp	pointer
)	O
;	O
p_prefix_context	long
=	O
p_suffix_context	long
=	O
0	int
;	O
chars_read	long
=	O
get_line	function
(	O
)	O
;	O
if	O
(	O
chars_read	long
==	O
(	O
size_t	long
)	O
-	O
1	int
||	O
!	O
chars_read	long
||	O
!	O
ISDIGIT	O
(	O
*	O
buf	pointer
)	O
)	O
{	O
next_intuit_at	function
(	O
line_beginning	long
,	O
p_input_line	long
)	O
;	O
return	O
chars_read	long
==	O
(	O
size_t	long
)	O
-	O
1	int
?	O
-	O
1	int
:	O
0	int
;	O
}	O
s	enum
=	O
scan_linenum	function
(	O
buf	pointer
,	O
&	O
p_first	long
)	O
;	O
if	O
(	O
*	O
s	enum
==	O
','	O
)	O
{	O
s	enum
=	O
scan_linenum	function
(	O
s	enum
+	O
1	int
,	O
&	O
p_ptrn_lines	long
)	O
;	O
p_ptrn_lines	long
+=	O
1	int
-	O
p_first	long
;	O
}	O
else	O
p_ptrn_lines	long
=	O
(	O
*	O
s	enum
!=	O
'a'	O
)	O
;	O
hunk_type	char
=	O
*	O
s	enum
;	O
if	O
(	O
hunk_type	char
==	O
'a'	O
)	O
p_first	long
++	O
;	O
s	enum
=	O
scan_linenum	function
(	O
s	enum
+	O
1	int
,	O
&	O
min	long
)	O
;	O
if	O
(	O
*	O
s	enum
==	O
','	O
)	O
scan_linenum	function
(	O
s	enum
+	O
1	int
,	O
&	O
max	long
)	O
;	O
else	O
max	long
=	O
min	long
;	O
if	O
(	O
hunk_type	char
==	O
'd'	O
)	O
min	long
++	O
;	O
p_end	long
=	O
p_ptrn_lines	long
+	O
1	int
+	O
max	long
-	O
min	long
+	O
1	int
;	O
while	O
(	O
p_end	long
+	O
1	int
>=	O
hunkmax	long
)	O
if	O
(	O
!	O
grow_hunkmax	function
(	O
)	O
)	O
{	O
p_end	long
=	O
-	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
p_newfirst	long
=	O
min	long
;	O
p_repl_lines	long
=	O
max	long
-	O
min	long
+	O
1	int
;	O
sprintf	function
(	O
buf	pointer
,	O
"*** %s,%s\n"	pointer
,	O
format_linenum	function
(	O
numbuf0	array
,	O
p_first	long
)	O
,	O
format_linenum	function
(	O
numbuf1	array
,	O
p_first	long
+	O
p_ptrn_lines	long
-	O
1	int
)	O
)	O
;	O
p_len	pointer
[	O
0	int
]	O
=	O
strlen	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
!	O
(	O
p_line	pointer
[	O
0	int
]	O
=	O
savestr	function
(	O
buf	pointer
)	O
)	O
)	O
{	O
p_end	long
=	O
-	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
p_Char	pointer
[	O
0	int
]	O
=	O
'*'	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
p_ptrn_lines	long
;	O
i	int
++	O
)	O
{	O
chars_read	long
=	O
get_line	function
(	O
)	O
;	O
if	O
(	O
chars_read	long
==	O
(	O
size_t	long
)	O
-	O
1	int
)	O
{	O
p_end	long
=	O
i	int
-	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
!	O
chars_read	long
)	O
fatal	function
(	O
"unexpected end of file in patch at line %s"	pointer
,	O
format_linenum	function
(	O
numbuf0	array
,	O
p_input_line	long
)	O
)	O
;	O
if	O
(	O
buf	pointer
[	O
0	int
]	O
!=	O
'<'	O
||	O
(	O
buf	pointer
[	O
1	int
]	O
!=	O
' '	O
&&	O
buf	pointer
[	O
1	int
]	O
!=	O
'\t'	O
)	O
)	O
fatal	function
(	O
"'<' expected at line %s of patch"	pointer
,	O
format_linenum	function
(	O
numbuf0	array
,	O
p_input_line	long
)	O
)	O
;	O
chars_read	long
-=	O
2	int
+	O
(	O
i	int
==	O
p_ptrn_lines	long
&&	O
incomplete_line	function
(	O
)	O
)	O
;	O
p_len	pointer
[	O
i	int
]	O
=	O
chars_read	long
;	O
p_line	pointer
[	O
i	int
]	O
=	O
savebuf	function
(	O
buf	pointer
+	O
2	int
,	O
chars_read	long
)	O
;	O
if	O
(	O
chars_read	long
&&	O
!	O
p_line	pointer
[	O
i	int
]	O
)	O
{	O
p_end	long
=	O
i	int
-	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
p_Char	pointer
[	O
i	int
]	O
=	O
'-'	O
;	O
}	O
if	O
(	O
hunk_type	char
==	O
'c'	O
)	O
{	O
chars_read	long
=	O
get_line	function
(	O
)	O
;	O
if	O
(	O
chars_read	long
==	O
(	O
size_t	long
)	O
-	O
1	int
)	O
{	O
p_end	long
=	O
i	int
-	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
!	O
chars_read	long
)	O
fatal	function
(	O
"unexpected end of file in patch at line %s"	pointer
,	O
format_linenum	function
(	O
numbuf0	array
,	O
p_input_line	long
)	O
)	O
;	O
if	O
(	O
*	O
buf	pointer
!=	O
'-'	O
)	O
fatal	function
(	O
"'---' expected at line %s of patch"	pointer
,	O
format_linenum	function
(	O
numbuf0	array
,	O
p_input_line	long
)	O
)	O
;	O
}	O
sprintf	function
(	O
buf	pointer
,	O
"--- %s,%s\n"	pointer
,	O
format_linenum	function
(	O
numbuf0	array
,	O
min	long
)	O
,	O
format_linenum	function
(	O
numbuf1	array
,	O
max	long
)	O
)	O
;	O
p_len	pointer
[	O
i	int
]	O
=	O
strlen	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
!	O
(	O
p_line	pointer
[	O
i	int
]	O
=	O
savestr	function
(	O
buf	pointer
)	O
)	O
)	O
{	O
p_end	long
=	O
i	int
-	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
p_Char	pointer
[	O
i	int
]	O
=	O
'='	O
;	O
for	O
(	O
i	int
++	O
;	O
i	int
<=	O
p_end	long
;	O
i	int
++	O
)	O
{	O
chars_read	long
=	O
get_line	function
(	O
)	O
;	O
if	O
(	O
chars_read	long
==	O
(	O
size_t	long
)	O
-	O
1	int
)	O
{	O
p_end	long
=	O
i	int
-	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
!	O
chars_read	long
)	O
fatal	function
(	O
"unexpected end of file in patch at line %s"	pointer
,	O
format_linenum	function
(	O
numbuf0	array
,	O
p_input_line	long
)	O
)	O
;	O
if	O
(	O
buf	pointer
[	O
0	int
]	O
!=	O
'>'	O
||	O
(	O
buf	pointer
[	O
1	int
]	O
!=	O
' '	O
&&	O
buf	pointer
[	O
1	int
]	O
!=	O
'\t'	O
)	O
)	O
fatal	function
(	O
"'>' expected at line %s of patch"	pointer
,	O
format_linenum	function
(	O
numbuf0	array
,	O
p_input_line	long
)	O
)	O
;	O
chars_read	long
-=	O
2	int
+	O
(	O
i	int
==	O
p_end	long
&&	O
incomplete_line	function
(	O
)	O
)	O
;	O
p_len	pointer
[	O
i	int
]	O
=	O
chars_read	long
;	O
p_line	pointer
[	O
i	int
]	O
=	O
savebuf	function
(	O
buf	pointer
+	O
2	int
,	O
chars_read	long
)	O
;	O
if	O
(	O
chars_read	long
&&	O
!	O
p_line	pointer
[	O
i	int
]	O
)	O
{	O
p_end	long
=	O
i	int
-	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
p_Char	pointer
[	O
i	int
]	O
=	O
'+'	O
;	O
}	O
}	O
if	O
(	O
rev	bool
)	O
if	O
(	O
!	O
pch_swap	function
(	O
)	O
)	O
say	function
(	O
"Not enough memory to swap next hunk!\n"	pointer
)	O
;	O
assert	O
(	O
p_end	long
+	O
1	int
<	O
hunkmax	long
)	O
;	O
p_Char	pointer
[	O
p_end	long
+	O
1	int
]	O
=	O
'^'	O
;	O
if	O
(	O
debug	int
&	O
2	int
)	O
{	O
lin	long
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
p_end	long
+	O
1	int
;	O
i	int
++	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s %c"	pointer
,	O
format_linenum	function
(	O
numbuf0	array
,	O
i	int
)	O
,	O
p_Char	pointer
[	O
i	int
]	O
)	O
;	O
if	O
(	O
p_Char	pointer
[	O
i	int
]	O
==	O
'*'	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
" %s,%s\n"	pointer
,	O
format_linenum	function
(	O
numbuf0	array
,	O
p_first	long
)	O
,	O
format_linenum	function
(	O
numbuf1	array
,	O
p_ptrn_lines	long
)	O
)	O
;	O
else	O
if	O
(	O
p_Char	pointer
[	O
i	int
]	O
==	O
'='	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
" %s,%s\n"	pointer
,	O
format_linenum	function
(	O
numbuf0	array
,	O
p_newfirst	long
)	O
,	O
format_linenum	function
(	O
numbuf1	array
,	O
p_repl_lines	long
)	O
)	O
;	O
else	O
if	O
(	O
p_Char	pointer
[	O
i	int
]	O
!=	O
'^'	O
)	O
{	O
fputs	function
(	O
" |"	pointer
,	O
stderr	pointer
)	O
;	O
pch_write_line	function
(	O
i	int
,	O
stderr	pointer
)	O
;	O
}	O
else	O
fputc	function
(	O
'\n'	O
,	O
stderr	pointer
)	O
;	O
}	O
fflush	function
(	O
stderr	pointer
)	O
;	O
}	O
return	O
1	int
;	O
}	O
static	O
size_t	long
get_line	function
(	O
void	O
)	O
{	O
return	O
pget_line	function
(	O
p_indent	long
,	O
p_rfc934_nesting	int
,	O
p_strip_trailing_cr	bool
,	O
p_pass_comments_through	bool
)	O
;	O
}	O
static	O
size_t	long
pget_line	function
(	O
size_t	long
indent	long
,	O
int	O
rfc934_nesting	int
,	O
bool	bool
strip_trailing_cr	bool
,	O
bool	bool
pass_comments_through	bool
)	O
{	O
FILE	struct
*	O
fp	pointer
=	O
pfp	pointer
;	O
int	O
c	char
;	O
size_t	long
i	int
;	O
char	O
*	O
b	struct
;	O
size_t	long
s	enum
;	O
do	O
{	O
i	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
c	char
=	O
getc	function
(	O
fp	pointer
)	O
;	O
if	O
(	O
c	char
==	O
EOF	O
)	O
{	O
if	O
(	O
ferror	function
(	O
fp	pointer
)	O
)	O
read_fatal	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
indent	long
<=	O
i	int
)	O
break	O
;	O
if	O
(	O
c	char
==	O
' '	O
||	O
c	char
==	O
'X'	O
)	O
i	int
++	O
;	O
else	O
if	O
(	O
c	char
==	O
'\t'	O
)	O
i	int
=	O
(	O
i	int
+	O
8	int
)	O
&	O
~	O
7	int
;	O
else	O
break	O
;	O
}	O
i	int
=	O
0	int
;	O
b	struct
=	O
buf	pointer
;	O
while	O
(	O
c	char
==	O
'-'	O
&&	O
0	int
<=	O
--	O
rfc934_nesting	int
)	O
{	O
c	char
=	O
getc	function
(	O
fp	pointer
)	O
;	O
if	O
(	O
c	char
==	O
EOF	O
)	O
goto	O
patch_ends_in_middle_of_line	O
;	O
if	O
(	O
c	char
!=	O
' '	O
)	O
{	O
i	int
=	O
1	int
;	O
b	struct
[	O
0	int
]	O
=	O
'-'	O
;	O
break	O
;	O
}	O
c	char
=	O
getc	function
(	O
fp	pointer
)	O
;	O
if	O
(	O
c	char
==	O
EOF	O
)	O
goto	O
patch_ends_in_middle_of_line	O
;	O
}	O
s	enum
=	O
bufsize	long
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
i	int
==	O
s	enum
-	O
1	int
)	O
{	O
s	enum
*=	O
2	int
;	O
b	struct
=	O
realloc	function
(	O
b	struct
,	O
s	enum
)	O
;	O
if	O
(	O
!	O
b	struct
)	O
{	O
if	O
(	O
!	O
using_plan_a	bool
)	O
xalloc_die	function
(	O
)	O
;	O
return	O
(	O
size_t	long
)	O
-	O
1	int
;	O
}	O
buf	pointer
=	O
b	struct
;	O
bufsize	long
=	O
s	enum
;	O
}	O
b	struct
[	O
i	int
++	O
]	O
=	O
c	char
;	O
if	O
(	O
c	char
==	O
'\n'	O
)	O
break	O
;	O
c	char
=	O
getc	function
(	O
fp	pointer
)	O
;	O
if	O
(	O
c	char
==	O
EOF	O
)	O
goto	O
patch_ends_in_middle_of_line	O
;	O
}	O
p_input_line	long
++	O
;	O
}	O
while	O
(	O
*	O
b	struct
==	O
'#'	O
&&	O
!	O
pass_comments_through	bool
)	O
;	O
if	O
(	O
strip_trailing_cr	bool
&&	O
2	int
<=	O
i	int
&&	O
b	struct
[	O
i	int
-	O
2	int
]	O
==	O
'\r'	O
)	O
b	struct
[	O
i	int
--	O
-	O
2	int
]	O
=	O
'\n'	O
;	O
b	struct
[	O
i	int
]	O
=	O
'\0'	O
;	O
return	O
i	int
;	O
patch_ends_in_middle_of_line	O
:	O
if	O
(	O
ferror	function
(	O
fp	pointer
)	O
)	O
read_fatal	function
(	O
)	O
;	O
say	function
(	O
"patch unexpectedly ends in middle of line\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
bool	bool
incomplete_line	function
(	O
void	O
)	O
{	O
FILE	struct
*	O
fp	pointer
=	O
pfp	pointer
;	O
int	O
c	char
;	O
file_offset	long
line_beginning	long
=	O
file_tell	O
(	O
fp	pointer
)	O
;	O
if	O
(	O
getc	function
(	O
fp	pointer
)	O
==	O
'\\'	O
)	O
{	O
while	O
(	O
(	O
c	char
=	O
getc	function
(	O
fp	pointer
)	O
)	O
!=	O
'\n'	O
&&	O
c	char
!=	O
EOF	O
)	O
;	O
return	O
true	int
;	O
}	O
else	O
{	O
Fseek	function
(	O
pfp	pointer
,	O
line_beginning	long
,	O
SEEK_SET	int
)	O
;	O
return	O
false	int
;	O
}	O
}	O
bool	bool
pch_swap	function
(	O
void	O
)	O
{	O
char	O
*	O
*	O
tp_line	pointer
;	O
size_t	long
*	O
tp_len	pointer
;	O
char	O
*	O
tp_char	pointer
;	O
lin	long
i	int
;	O
lin	long
n	int
;	O
bool	bool
blankline	bool
=	O
false	int
;	O
char	O
*	O
s	enum
;	O
i	int
=	O
p_first	long
;	O
p_first	long
=	O
p_newfirst	long
;	O
p_newfirst	long
=	O
i	int
;	O
tp_line	pointer
=	O
p_line	pointer
;	O
tp_len	pointer
=	O
p_len	pointer
;	O
tp_char	pointer
=	O
p_Char	pointer
;	O
p_line	pointer
=	O
0	int
;	O
p_len	pointer
=	O
0	int
;	O
p_Char	pointer
=	O
0	int
;	O
set_hunkmax	function
(	O
)	O
;	O
if	O
(	O
!	O
p_line	pointer
||	O
!	O
p_len	pointer
||	O
!	O
p_Char	pointer
)	O
{	O
free	function
(	O
p_line	pointer
)	O
;	O
p_line	pointer
=	O
tp_line	pointer
;	O
free	function
(	O
p_len	pointer
)	O
;	O
p_len	pointer
=	O
tp_len	pointer
;	O
free	function
(	O
p_Char	pointer
)	O
;	O
p_Char	pointer
=	O
tp_char	pointer
;	O
return	O
false	int
;	O
}	O
i	int
=	O
p_ptrn_lines	long
+	O
1	int
;	O
if	O
(	O
tp_char	pointer
[	O
i	int
]	O
==	O
'\n'	O
)	O
{	O
blankline	bool
=	O
true	int
;	O
i	int
++	O
;	O
}	O
if	O
(	O
p_efake	long
>=	O
0	int
)	O
{	O
if	O
(	O
p_efake	long
<=	O
i	int
)	O
n	int
=	O
p_end	long
-	O
i	int
+	O
1	int
;	O
else	O
n	int
=	O
-	O
i	int
;	O
p_efake	long
+=	O
n	int
;	O
p_bfake	long
+=	O
n	int
;	O
}	O
for	O
(	O
n	int
=	O
0	int
;	O
i	int
<=	O
p_end	long
;	O
i	int
++	O
,	O
n	int
++	O
)	O
{	O
p_line	pointer
[	O
n	int
]	O
=	O
tp_line	pointer
[	O
i	int
]	O
;	O
p_Char	pointer
[	O
n	int
]	O
=	O
tp_char	pointer
[	O
i	int
]	O
;	O
if	O
(	O
p_Char	pointer
[	O
n	int
]	O
==	O
'+'	O
)	O
p_Char	pointer
[	O
n	int
]	O
=	O
'-'	O
;	O
p_len	pointer
[	O
n	int
]	O
=	O
tp_len	pointer
[	O
i	int
]	O
;	O
}	O
if	O
(	O
blankline	bool
)	O
{	O
i	int
=	O
p_ptrn_lines	long
+	O
1	int
;	O
p_line	pointer
[	O
n	int
]	O
=	O
tp_line	pointer
[	O
i	int
]	O
;	O
p_Char	pointer
[	O
n	int
]	O
=	O
tp_char	pointer
[	O
i	int
]	O
;	O
p_len	pointer
[	O
n	int
]	O
=	O
tp_len	pointer
[	O
i	int
]	O
;	O
n	int
++	O
;	O
}	O
assert	O
(	O
p_Char	pointer
[	O
0	int
]	O
==	O
'='	O
)	O
;	O
p_Char	pointer
[	O
0	int
]	O
=	O
'*'	O
;	O
for	O
(	O
s	enum
=	O
p_line	pointer
[	O
0	int
]	O
;	O
*	O
s	enum
;	O
s	enum
++	O
)	O
if	O
(	O
*	O
s	enum
==	O
'-'	O
)	O
*	O
s	enum
=	O
'*'	O
;	O
assert	O
(	O
tp_char	pointer
[	O
0	int
]	O
==	O
'*'	O
)	O
;	O
tp_char	pointer
[	O
0	int
]	O
=	O
'='	O
;	O
for	O
(	O
s	enum
=	O
tp_line	pointer
[	O
0	int
]	O
;	O
*	O
s	enum
;	O
s	enum
++	O
)	O
if	O
(	O
*	O
s	enum
==	O
'*'	O
)	O
*	O
s	enum
=	O
'-'	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
n	int
<=	O
p_end	long
;	O
i	int
++	O
,	O
n	int
++	O
)	O
{	O
p_line	pointer
[	O
n	int
]	O
=	O
tp_line	pointer
[	O
i	int
]	O
;	O
p_Char	pointer
[	O
n	int
]	O
=	O
tp_char	pointer
[	O
i	int
]	O
;	O
if	O
(	O
p_Char	pointer
[	O
n	int
]	O
==	O
'-'	O
)	O
p_Char	pointer
[	O
n	int
]	O
=	O
'+'	O
;	O
p_len	pointer
[	O
n	int
]	O
=	O
tp_len	pointer
[	O
i	int
]	O
;	O
}	O
assert	O
(	O
i	int
==	O
p_ptrn_lines	long
+	O
1	int
)	O
;	O
i	int
=	O
p_ptrn_lines	long
;	O
p_ptrn_lines	long
=	O
p_repl_lines	long
;	O
p_repl_lines	long
=	O
i	int
;	O
p_Char	pointer
[	O
p_end	long
+	O
1	int
]	O
=	O
'^'	O
;	O
free	function
(	O
tp_line	pointer
)	O
;	O
free	function
(	O
tp_len	pointer
)	O
;	O
free	function
(	O
tp_char	pointer
)	O
;	O
return	O
true	int
;	O
}	O
int	O
pch_says_nonexistent	function
(	O
bool	bool
which	bool
)	O
{	O
return	O
p_says_nonexistent	array
[	O
which	bool
]	O
;	O
}	O
const	O
char	O
*	O
pch_name	function
(	O
enum	O
nametype	enum
type	enum
)	O
{	O
return	O
type	enum
==	O
NONE	int
?	O
NULL	O
:	O
p_name	array
[	O
type	enum
]	O
;	O
}	O
bool	bool
pch_copy	function
(	O
void	O
)	O
{	O
return	O
p_copy	array
[	O
OLD	int
]	O
&&	O
p_copy	array
[	O
NEW	int
]	O
&&	O
p_name	array
[	O
OLD	int
]	O
&&	O
p_name	array
[	O
NEW	int
]	O
;	O
}	O
bool	bool
pch_rename	function
(	O
void	O
)	O
{	O
return	O
p_rename	array
[	O
OLD	int
]	O
&&	O
p_rename	array
[	O
NEW	int
]	O
&&	O
p_name	array
[	O
OLD	int
]	O
&&	O
p_name	array
[	O
NEW	int
]	O
;	O
}	O
lin	long
pch_first	function
(	O
void	O
)	O
{	O
return	O
p_first	long
;	O
}	O
lin	long
pch_ptrn_lines	function
(	O
void	O
)	O
{	O
return	O
p_ptrn_lines	long
;	O
}	O
lin	long
pch_newfirst	function
(	O
void	O
)	O
{	O
return	O
p_newfirst	long
;	O
}	O
lin	long
pch_repl_lines	function
(	O
void	O
)	O
{	O
return	O
p_repl_lines	long
;	O
}	O
lin	long
pch_end	function
(	O
void	O
)	O
{	O
return	O
p_end	long
;	O
}	O
lin	long
pch_prefix_context	function
(	O
void	O
)	O
{	O
return	O
p_prefix_context	long
;	O
}	O
lin	long
pch_suffix_context	function
(	O
void	O
)	O
{	O
return	O
p_suffix_context	long
;	O
}	O
size_t	long
pch_line_len	function
(	O
lin	long
line	long
)	O
{	O
return	O
p_len	pointer
[	O
line	long
]	O
;	O
}	O
char	O
pch_char	function
(	O
lin	long
line	long
)	O
{	O
return	O
p_Char	pointer
[	O
line	long
]	O
;	O
}	O
char	O
*	O
pfetch	function
(	O
lin	long
line	long
)	O
{	O
return	O
p_line	pointer
[	O
line	long
]	O
;	O
}	O
bool	bool
pch_write_line	function
(	O
lin	long
line	long
,	O
FILE	struct
*	O
file	pointer
)	O
{	O
bool	bool
after_newline	bool
=	O
p_line	pointer
[	O
line	long
]	O
[	O
p_len	pointer
[	O
line	long
]	O
-	O
1	int
]	O
==	O
'\n'	O
;	O
if	O
(	O
!	O
fwrite	function
(	O
p_line	pointer
[	O
line	long
]	O
,	O
sizeof	O
(	O
*	O
p_line	pointer
[	O
line	long
]	O
)	O
,	O
p_len	pointer
[	O
line	long
]	O
,	O
file	pointer
)	O
)	O
write_fatal	function
(	O
)	O
;	O
return	O
after_newline	bool
;	O
}	O
lin	long
pch_hunk_beg	function
(	O
void	O
)	O
{	O
return	O
p_hunk_beg	long
;	O
}	O
char	O
const	O
*	O
pch_c_function	function
(	O
void	O
)	O
{	O
return	O
p_c_function	pointer
;	O
}	O
bool	bool
pch_git_diff	function
(	O
void	O
)	O
{	O
return	O
p_git_diff	bool
;	O
}	O
char	O
const	O
*	O
pch_timestr	function
(	O
bool	bool
which	bool
)	O
{	O
return	O
p_timestr	array
[	O
which	bool
]	O
;	O
}	O
char	O
const	O
*	O
pch_sha1	function
(	O
bool	bool
which	bool
)	O
{	O
return	O
p_sha1	array
[	O
which	bool
]	O
;	O
}	O
mode_t	int
pch_mode	function
(	O
bool	bool
which	bool
)	O
{	O
return	O
p_mode	array
[	O
which	bool
]	O
;	O
}	O
static	O
char	O
_GL_ATTRIBUTE_PURE	O
get_ed_command_letter	function
(	O
char	O
const	O
*	O
line	long
)	O
{	O
char	O
const	O
*	O
p	pointer
=	O
line	long
;	O
char	O
letter	char
;	O
bool	bool
pair	bool
=	O
false	int
;	O
if	O
(	O
ISDIGIT	O
(	O
*	O
p	pointer
)	O
)	O
{	O
while	O
(	O
ISDIGIT	O
(	O
*	O
++	O
p	pointer
)	O
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
','	O
)	O
{	O
if	O
(	O
!	O
ISDIGIT	O
(	O
*	O
++	O
p	pointer
)	O
)	O
return	O
0	int
;	O
while	O
(	O
ISDIGIT	O
(	O
*	O
++	O
p	pointer
)	O
)	O
;	O
pair	bool
=	O
true	int
;	O
}	O
}	O
letter	char
=	O
*	O
p	pointer
++	O
;	O
switch	O
(	O
letter	char
)	O
{	O
case	O
'a'	O
:	O
case	O
'i'	O
:	O
if	O
(	O
pair	bool
)	O
return	O
0	int
;	O
break	O
;	O
case	O
'c'	O
:	O
case	O
'd'	O
:	O
break	O
;	O
case	O
's'	O
:	O
if	O
(	O
strncmp	function
(	O
p	pointer
,	O
"/.//"	pointer
,	O
4	int
)	O
!=	O
0	int
)	O
return	O
0	int
;	O
p	pointer
+=	O
4	int
;	O
break	O
;	O
default	O
:	O
return	O
0	int
;	O
}	O
while	O
(	O
*	O
p	pointer
==	O
' '	O
||	O
*	O
p	pointer
==	O
'\t'	O
)	O
p	pointer
++	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'\n'	O
)	O
return	O
letter	char
;	O
return	O
0	int
;	O
}	O
void	O
do_ed_script	function
(	O
char	O
const	O
*	O
inname	pointer
,	O
char	O
const	O
*	O
outname	pointer
,	O
int	O
*	O
outname_needs_removal	pointer
,	O
FILE	struct
*	O
ofp	pointer
)	O
{	O
static	O
char	O
const	O
editor_program	array
[	O
]	O
=	O
EDITOR_PROGRAM	pointer
;	O
file_offset	long
beginning_of_this_line	long
;	O
FILE	struct
*	O
pipefp	pointer
=	O
0	int
;	O
size_t	long
chars_read	long
;	O
if	O
(	O
!	O
dry_run	bool
&&	O
!	O
skip_rest_of_patch	bool
)	O
{	O
int	O
exclusive	int
=	O
*	O
outname_needs_removal	pointer
?	O
0	int
:	O
O_EXCL	int
;	O
assert	O
(	O
!	O
inerrno	int
)	O
;	O
*	O
outname_needs_removal	pointer
=	O
1	int
;	O
copy_file	function
(	O
inname	pointer
,	O
outname	pointer
,	O
0	int
,	O
exclusive	int
,	O
instat	struct
.	O
st_mode	int
,	O
true	int
)	O
;	O
sprintf	function
(	O
buf	pointer
,	O
"%s %s%s"	pointer
,	O
editor_program	array
,	O
verbosity	enum
==	O
VERBOSE	int
?	O
""	pointer
:	O
"- "	pointer
,	O
outname	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
pipefp	pointer
=	O
popen	function
(	O
buf	pointer
,	O
binary_transput	int
?	O
"wb"	pointer
:	O
"w"	pointer
)	O
;	O
if	O
(	O
!	O
pipefp	pointer
)	O
pfatal	function
(	O
"Can't open pipe to %s"	pointer
,	O
quotearg	function
(	O
buf	pointer
)	O
)	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
char	O
ed_command_letter	char
;	O
beginning_of_this_line	long
=	O
file_tell	O
(	O
pfp	pointer
)	O
;	O
chars_read	long
=	O
get_line	function
(	O
)	O
;	O
if	O
(	O
!	O
chars_read	long
)	O
{	O
next_intuit_at	function
(	O
beginning_of_this_line	long
,	O
p_input_line	long
)	O
;	O
break	O
;	O
}	O
ed_command_letter	char
=	O
get_ed_command_letter	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
ed_command_letter	char
)	O
{	O
if	O
(	O
pipefp	pointer
)	O
if	O
(	O
!	O
fwrite	function
(	O
buf	pointer
,	O
sizeof	O
*	O
buf	pointer
,	O
chars_read	long
,	O
pipefp	pointer
)	O
)	O
write_fatal	function
(	O
)	O
;	O
if	O
(	O
ed_command_letter	char
!=	O
'd'	O
&&	O
ed_command_letter	char
!=	O
's'	O
)	O
{	O
p_pass_comments_through	bool
=	O
true	int
;	O
while	O
(	O
(	O
chars_read	long
=	O
get_line	function
(	O
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
pipefp	pointer
)	O
if	O
(	O
!	O
fwrite	function
(	O
buf	pointer
,	O
sizeof	O
*	O
buf	pointer
,	O
chars_read	long
,	O
pipefp	pointer
)	O
)	O
write_fatal	function
(	O
)	O
;	O
if	O
(	O
chars_read	long
==	O
2	int
&&	O
strEQ	O
(	O
buf	pointer
,	O
".\n"	pointer
)	O
)	O
break	O
;	O
}	O
p_pass_comments_through	bool
=	O
false	int
;	O
}	O
}	O
else	O
{	O
next_intuit_at	function
(	O
beginning_of_this_line	long
,	O
p_input_line	long
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
pipefp	pointer
)	O
return	O
;	O
if	O
(	O
fwrite	function
(	O
"w\nq\n"	pointer
,	O
sizeof	O
(	O
char	O
)	O
,	O
(	O
size_t	long
)	O
4	int
,	O
pipefp	pointer
)	O
==	O
0	int
||	O
fflush	function
(	O
pipefp	pointer
)	O
!=	O
0	int
)	O
write_fatal	function
(	O
)	O
;	O
if	O
(	O
pclose	function
(	O
pipefp	pointer
)	O
!=	O
0	int
)	O
fatal	function
(	O
"%s FAILED"	pointer
,	O
editor_program	array
)	O
;	O
if	O
(	O
ofp	pointer
)	O
{	O
FILE	struct
*	O
ifp	pointer
=	O
fopen	function
(	O
outname	pointer
,	O
binary_transput	int
?	O
"rb"	pointer
:	O
"r"	pointer
)	O
;	O
int	O
c	char
;	O
if	O
(	O
!	O
ifp	pointer
)	O
pfatal	function
(	O
"can't open '%s'"	pointer
,	O
outname	pointer
)	O
;	O
while	O
(	O
(	O
c	char
=	O
getc	function
(	O
ifp	pointer
)	O
)	O
!=	O
EOF	O
)	O
if	O
(	O
putc	function
(	O
c	char
,	O
ofp	pointer
)	O
==	O
EOF	O
)	O
write_fatal	function
(	O
)	O
;	O
if	O
(	O
ferror	function
(	O
ifp	pointer
)	O
||	O
fclose	function
(	O
ifp	pointer
)	O
!=	O
0	int
)	O
read_fatal	function
(	O
)	O
;	O
}	O
}	O
void	O
pch_normalize	function
(	O
enum	O
diff	enum
format	enum
)	O
{	O
lin	long
old	long
=	O
1	int
;	O
lin	long
new	long
=	O
p_ptrn_lines	long
+	O
1	int
;	O
while	O
(	O
p_Char	pointer
[	O
new	long
]	O
==	O
'='	O
||	O
p_Char	pointer
[	O
new	long
]	O
==	O
'\n'	O
)	O
new	long
++	O
;	O
if	O
(	O
format	enum
==	O
UNI_DIFF	int
)	O
{	O
for	O
(	O
;	O
old	long
<=	O
p_ptrn_lines	long
;	O
old	long
++	O
)	O
if	O
(	O
p_Char	pointer
[	O
old	long
]	O
==	O
'!'	O
)	O
p_Char	pointer
[	O
old	long
]	O
=	O
'-'	O
;	O
for	O
(	O
;	O
new	long
<=	O
p_end	long
;	O
new	long
++	O
)	O
if	O
(	O
p_Char	pointer
[	O
new	long
]	O
==	O
'!'	O
)	O
p_Char	pointer
[	O
new	long
]	O
=	O
'+'	O
;	O
}	O
else	O
{	O
while	O
(	O
old	long
<=	O
p_ptrn_lines	long
)	O
{	O
if	O
(	O
p_Char	pointer
[	O
old	long
]	O
==	O
'-'	O
)	O
{	O
if	O
(	O
new	long
<=	O
p_end	long
&&	O
p_Char	pointer
[	O
new	long
]	O
==	O
'+'	O
)	O
{	O
do	O
{	O
p_Char	pointer
[	O
old	long
]	O
=	O
'!'	O
;	O
old	long
++	O
;	O
}	O
while	O
(	O
old	long
<=	O
p_ptrn_lines	long
&&	O
p_Char	pointer
[	O
old	long
]	O
==	O
'-'	O
)	O
;	O
do	O
{	O
p_Char	pointer
[	O
new	long
]	O
=	O
'!'	O
;	O
new	long
++	O
;	O
}	O
while	O
(	O
new	long
<=	O
p_end	long
&&	O
p_Char	pointer
[	O
new	long
]	O
==	O
'+'	O
)	O
;	O
}	O
else	O
{	O
do	O
old	long
++	O
;	O
while	O
(	O
old	long
<=	O
p_ptrn_lines	long
&&	O
p_Char	pointer
[	O
old	long
]	O
==	O
'-'	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
new	long
<=	O
p_end	long
&&	O
p_Char	pointer
[	O
new	long
]	O
==	O
'+'	O
)	O
{	O
do	O
new	long
++	O
;	O
while	O
(	O
new	long
<=	O
p_end	long
&&	O
p_Char	pointer
[	O
new	long
]	O
==	O
'+'	O
)	O
;	O
}	O
else	O
{	O
old	long
++	O
;	O
new	long
++	O
;	O
}	O
}	O
}	O
}	O
