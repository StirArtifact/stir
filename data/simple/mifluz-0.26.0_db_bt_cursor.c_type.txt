static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: bt_cursor.c,v 1.6 2014/04/17 20:27:24 sebdiaz Exp $"	pointer
;	O
static	O
int	O
__bam_c_close	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
db_pgno_t	int
,	O
int	O
*	O
)	O
)	O
;	O
static	O
int	O
__bam_c_del	function
__P	O
(	O
(	O
DBC	struct
*	O
)	O
)	O
;	O
static	O
int	O
__bam_c_destroy	function
__P	O
(	O
(	O
DBC	struct
*	O
)	O
)	O
;	O
static	O
int	O
__bam_c_first	function
__P	O
(	O
(	O
DBC	struct
*	O
)	O
)	O
;	O
static	O
int	O
__bam_c_get	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
DBT	struct
*	O
,	O
DBT	struct
*	O
,	O
u_int32_t	int
,	O
db_pgno_t	int
*	O
)	O
)	O
;	O
static	O
int	O
__bam_c_getstack	function
__P	O
(	O
(	O
DBC	struct
*	O
)	O
)	O
;	O
static	O
int	O
__bam_c_last	function
__P	O
(	O
(	O
DBC	struct
*	O
)	O
)	O
;	O
static	O
int	O
__bam_c_next	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
int	O
)	O
)	O
;	O
static	O
int	O
__bam_c_physdel	function
__P	O
(	O
(	O
DBC	struct
*	O
)	O
)	O
;	O
static	O
int	O
__bam_c_prev	function
__P	O
(	O
(	O
DBC	struct
*	O
)	O
)	O
;	O
static	O
int	O
__bam_c_put	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
DBT	struct
*	O
,	O
DBT	struct
*	O
,	O
u_int32_t	int
,	O
db_pgno_t	int
*	O
)	O
)	O
;	O
static	O
void	O
__bam_c_reset	function
__P	O
(	O
(	O
BTREE_CURSOR	struct
*	O
)	O
)	O
;	O
static	O
int	O
__bam_c_search	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
const	O
DBT	struct
*	O
,	O
u_int32_t	int
,	O
int	O
*	O
)	O
)	O
;	O
static	O
int	O
__bam_c_writelock	function
__P	O
(	O
(	O
DBC	struct
*	O
)	O
)	O
;	O
static	O
int	O
__bam_getboth_finddatum	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
DBT	struct
*	O
)	O
)	O
;	O
static	O
int	O
__bam_getbothc	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
DBT	struct
*	O
)	O
)	O
;	O
static	O
int	O
__bam_isopd	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
db_pgno_t	int
*	O
)	O
)	O
;	O
static	O
void	O
__bam_c_reset	function
(	O
cp	pointer
)	O
BTREE_CURSOR	struct
*	O
cp	pointer
;	O
{	O
cp	pointer
->	O
sp	pointer
=	O
cp	pointer
->	O
csp	pointer
=	O
cp	pointer
->	O
stack	array
;	O
cp	pointer
->	O
esp	pointer
=	O
cp	pointer
->	O
stack	array
+	O
sizeof	O
(	O
cp	pointer
->	O
stack	array
)	O
/	O
sizeof	O
(	O
cp	pointer
->	O
stack	array
[	O
0	int
]	O
)	O
;	O
cp	pointer
->	O
lock	struct
.	O
off	long
=	O
LOCK_INVALID	O
;	O
cp	pointer
->	O
lock_mode	enum
=	O
DB_LOCK_NG	int
;	O
cp	pointer
->	O
recno	int
=	O
RECNO_OOB	int
;	O
cp	pointer
->	O
flags	int
=	O
0	int
;	O
}	O
int	O
CDB___bam_c_init	function
(	O
dbc	pointer
,	O
dbtype	enum
)	O
DBC	struct
*	O
dbc	pointer
;	O
DBTYPE	enum
dbtype	enum
;	O
{	O
BTREE	struct
*	O
t	pointer
;	O
BTREE_CURSOR	struct
*	O
cp	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
u_int32_t	int
minkey	int
;	O
int	O
ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
if	O
(	O
dbc	pointer
->	O
internal	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
sizeof	O
(	O
BTREE_CURSOR	struct
)	O
,	O
NULL	O
,	O
&	O
cp	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
dbc	pointer
->	O
internal	pointer
=	O
(	O
DBC_INTERNAL	struct
*	O
)	O
cp	pointer
;	O
}	O
else	O
cp	pointer
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
__bam_c_reset	function
(	O
cp	pointer
)	O
;	O
dbc	pointer
->	O
c_close	pointer
=	O
CDB___db_c_close	function
;	O
dbc	pointer
->	O
c_count	pointer
=	O
CDB___db_c_count	function
;	O
dbc	pointer
->	O
c_del	pointer
=	O
CDB___db_c_del	function
;	O
dbc	pointer
->	O
c_dup	pointer
=	O
CDB___db_c_dup	function
;	O
dbc	pointer
->	O
c_get	pointer
=	O
CDB___db_c_get	function
;	O
dbc	pointer
->	O
c_put	pointer
=	O
CDB___db_c_put	function
;	O
if	O
(	O
dbtype	enum
==	O
DB_BTREE	int
)	O
{	O
dbc	pointer
->	O
c_am_close	pointer
=	O
__bam_c_close	function
;	O
dbc	pointer
->	O
c_am_del	pointer
=	O
__bam_c_del	function
;	O
dbc	pointer
->	O
c_am_destroy	pointer
=	O
__bam_c_destroy	function
;	O
dbc	pointer
->	O
c_am_get	pointer
=	O
__bam_c_get	function
;	O
dbc	pointer
->	O
c_am_put	pointer
=	O
__bam_c_put	function
;	O
dbc	pointer
->	O
c_am_writelock	pointer
=	O
__bam_c_writelock	function
;	O
}	O
else	O
{	O
dbc	pointer
->	O
c_am_close	pointer
=	O
__bam_c_close	function
;	O
dbc	pointer
->	O
c_am_del	pointer
=	O
CDB___ram_c_del	function
;	O
dbc	pointer
->	O
c_am_destroy	pointer
=	O
__bam_c_destroy	function
;	O
dbc	pointer
->	O
c_am_get	pointer
=	O
CDB___ram_c_get	function
;	O
dbc	pointer
->	O
c_am_put	pointer
=	O
CDB___ram_c_put	function
;	O
dbc	pointer
->	O
c_am_writelock	pointer
=	O
__bam_c_writelock	function
;	O
}	O
t	pointer
=	O
dbp	pointer
->	O
bt_internal	pointer
;	O
minkey	int
=	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_OPD	int
)	O
?	O
2	int
:	O
t	pointer
->	O
bt_minkey	int
;	O
cp	pointer
->	O
ovflsize	short
=	O
(	O
dbp	pointer
->	O
pgsize	int
-	O
P_OVERHEAD	O
)	O
/	O
(	O
minkey	int
*	O
P_INDX	int
)	O
-	O
(	O
BKEYDATA_PSIZE	O
(	O
0	int
)	O
+	O
ALIGN	O
(	O
1	int
,	O
4	int
)	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___bam_c_refresh	function
(	O
dbc	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
{	O
BTREE_CURSOR	struct
*	O
cp	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
cp	pointer
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
__bam_c_reset	function
(	O
cp	pointer
)	O
;	O
if	O
(	O
cp	pointer
->	O
root	int
==	O
PGNO_INVALID	int
)	O
cp	pointer
->	O
root	int
=	O
(	O
(	O
BTREE	struct
*	O
)	O
dbp	pointer
->	O
bt_internal	pointer
)	O
->	O
bt_root	int
;	O
if	O
(	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_OPD	int
)	O
||	O
dbc	pointer
->	O
dbtype	enum
==	O
DB_RECNO	int
||	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_BT_RECNUM	int
)	O
)	O
{	O
F_SET	O
(	O
cp	pointer
,	O
C_RECNUM	int
)	O
;	O
if	O
(	O
(	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_OPD	int
)	O
&&	O
dbc	pointer
->	O
dbtype	enum
==	O
DB_RECNO	int
)	O
||	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_BT_RECNUM	int
|	O
DB_RE_RENUMBER	int
)	O
)	O
F_SET	O
(	O
cp	pointer
,	O
C_RENUMBER	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__bam_c_close	function
(	O
dbc	pointer
,	O
root_pgno	int
,	O
rmroot	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
db_pgno_t	int
root_pgno	int
;	O
int	O
*	O
rmroot	pointer
;	O
{	O
BTREE_CURSOR	struct
*	O
cp	pointer
,	O
*	O
cp_opd	pointer
,	O
*	O
cp_c	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
DBC	struct
*	O
dbc_opd	pointer
,	O
*	O
dbc_c	pointer
;	O
PAGE	struct
*	O
h	pointer
;	O
u_int32_t	int
num	int
;	O
int	O
cdb_lock	int
,	O
ret	int
,	O
t_ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
cp	pointer
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
cp_opd	pointer
=	O
(	O
dbc_opd	pointer
=	O
cp	pointer
->	O
opd	pointer
)	O
==	O
NULL	O
?	O
NULL	O
:	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc_opd	pointer
->	O
internal	pointer
;	O
cdb_lock	int
=	O
ret	int
=	O
0	int
;	O
if	O
(	O
dbc_opd	pointer
!=	O
NULL	O
)	O
DB_ASSERT	O
(	O
cp_opd	pointer
->	O
csp	pointer
==	O
cp_opd	pointer
->	O
stack	array
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
cp	pointer
,	O
C_DELETED	int
)	O
)	O
{	O
dbc_c	pointer
=	O
dbc	pointer
;	O
switch	O
(	O
dbc	pointer
->	O
dbtype	enum
)	O
{	O
case	O
DB_BTREE	int
:	O
if	O
(	O
CDB___bam_ca_delete	function
(	O
dbp	pointer
,	O
cp	pointer
->	O
pgno	int
,	O
cp	pointer
->	O
indx	short
,	O
1	int
)	O
==	O
0	int
)	O
goto	O
lock	struct
;	O
goto	O
done	O
;	O
case	O
DB_RECNO	int
:	O
if	O
(	O
!	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_OPD	int
)	O
)	O
goto	O
done	O
;	O
if	O
(	O
CDB___ram_ca_delete	function
(	O
dbp	pointer
,	O
cp	pointer
->	O
root	int
)	O
==	O
0	int
)	O
goto	O
lock	struct
;	O
goto	O
done	O
;	O
default	O
:	O
return	O
(	O
CDB___db_unknown_type	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"__bam_c_close"	pointer
,	O
dbc	pointer
->	O
dbtype	enum
)	O
)	O
;	O
}	O
}	O
if	O
(	O
dbc_opd	pointer
==	O
NULL	O
)	O
goto	O
done	O
;	O
if	O
(	O
F_ISSET	O
(	O
cp_opd	pointer
,	O
C_DELETED	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
cp	pointer
->	O
pgno	int
,	O
0	int
,	O
&	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
root_pgno	int
=	O
GET_BOVERFLOW	O
(	O
h	pointer
,	O
cp	pointer
->	O
indx	short
+	O
O_INDX	int
)	O
->	O
pgno	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
dbc_c	pointer
=	O
dbc_opd	pointer
;	O
switch	O
(	O
dbc_opd	pointer
->	O
dbtype	enum
)	O
{	O
case	O
DB_BTREE	int
:	O
if	O
(	O
CDB___bam_ca_delete	function
(	O
dbp	pointer
,	O
cp_opd	pointer
->	O
pgno	int
,	O
cp_opd	pointer
->	O
indx	short
,	O
1	int
)	O
==	O
0	int
)	O
goto	O
lock	struct
;	O
goto	O
done	O
;	O
case	O
DB_RECNO	int
:	O
if	O
(	O
CDB___ram_ca_delete	function
(	O
dbp	pointer
,	O
cp_opd	pointer
->	O
root	int
)	O
==	O
0	int
)	O
goto	O
lock	struct
;	O
goto	O
done	O
;	O
default	O
:	O
return	O
(	O
CDB___db_unknown_type	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"__bam_c_close"	pointer
,	O
dbc	pointer
->	O
dbtype	enum
)	O
)	O
;	O
}	O
}	O
goto	O
done	O
;	O
lock	struct
:	O
cp_c	pointer
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc_c	pointer
->	O
internal	pointer
;	O
if	O
(	O
LOCKING	O
(	O
dbp	pointer
->	O
dbenv	pointer
)	O
)	O
{	O
DB_ASSERT	O
(	O
!	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_OPD	int
)	O
||	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_WRITEDUP	O
)	O
)	O
;	O
if	O
(	O
!	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_WRITER	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB_lock_get	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbc	pointer
->	O
locker	int
,	O
DB_LOCK_UPGRADE	int
,	O
&	O
dbc	pointer
->	O
lock_dbt	struct
,	O
DB_LOCK_WRITE	int
,	O
&	O
dbc	pointer
->	O
mylock	struct
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
cdb_lock	int
=	O
1	int
;	O
}	O
cp_c	pointer
->	O
lock	struct
.	O
off	long
=	O
LOCK_INVALID	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
cp_c	pointer
->	O
pgno	int
,	O
0	int
,	O
&	O
cp_c	pointer
->	O
page	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
goto	O
delete	O
;	O
}	O
if	O
(	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_OPD	int
)	O
)	O
{	O
cp_c	pointer
->	O
lock	struct
.	O
off	long
=	O
LOCK_INVALID	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
cp_c	pointer
->	O
pgno	int
,	O
0	int
,	O
&	O
cp_c	pointer
->	O
page	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
goto	O
delete	O
;	O
}	O
ACQUIRE	O
(	O
dbc	pointer
,	O
DB_LOCK_WRITE	int
,	O
cp	pointer
->	O
pgno	int
,	O
cp_c	pointer
->	O
lock	struct
,	O
cp_c	pointer
->	O
pgno	int
,	O
cp_c	pointer
->	O
page	pointer
,	O
ret	int
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
goto	O
err	pointer
;	O
delete	O
:	O
if	O
(	O
dbc_c	pointer
->	O
dbtype	enum
==	O
DB_BTREE	int
&&	O
(	O
ret	int
=	O
__bam_c_physdel	function
(	O
dbc_c	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
dbc_opd	pointer
!=	O
NULL	O
)	O
DB_ASSERT	O
(	O
cp_opd	pointer
->	O
csp	pointer
==	O
cp_opd	pointer
->	O
stack	array
)	O
;	O
if	O
(	O
!	O
F_ISSET	O
(	O
dbc_c	pointer
,	O
DBC_OPD	int
)	O
||	O
root_pgno	int
==	O
PGNO_INVALID	int
)	O
goto	O
done	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
root_pgno	int
,	O
0	int
,	O
&	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
num	int
=	O
NUM_ENT	O
(	O
h	pointer
)	O
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_free	function
(	O
dbc	pointer
,	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
else	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
goto	O
done	O
;	O
}	O
if	O
(	O
dbc_opd	pointer
!=	O
NULL	O
)	O
{	O
cp	pointer
->	O
lock	struct
.	O
off	long
=	O
LOCK_INVALID	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
cp	pointer
->	O
pgno	int
,	O
0	int
,	O
&	O
cp	pointer
->	O
page	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
__bam_c_physdel	function
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
else	O
*	O
rmroot	pointer
=	O
1	int
;	O
err	pointer
:	O
done	O
:	O
if	O
(	O
dbc_opd	pointer
!=	O
NULL	O
)	O
{	O
DISCARD_CUR	O
(	O
dbc_opd	pointer
,	O
t_ret	int
)	O
;	O
if	O
(	O
t_ret	int
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
DB_ASSERT	O
(	O
cp_opd	pointer
->	O
csp	pointer
==	O
cp_opd	pointer
->	O
stack	array
)	O
;	O
}	O
DISCARD_CUR	O
(	O
dbc	pointer
,	O
t_ret	int
)	O
;	O
if	O
(	O
t_ret	int
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
DB_ASSERT	O
(	O
cp	pointer
->	O
csp	pointer
==	O
cp	pointer
->	O
stack	array
)	O
;	O
if	O
(	O
cdb_lock	int
)	O
(	O
void	O
)	O
CDB___lock_downgrade	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
&	O
dbc	pointer
->	O
mylock	struct
,	O
DB_LOCK_IWRITE	int
,	O
0	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__bam_c_destroy	function
(	O
dbc	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
{	O
CDB___os_free	function
(	O
dbc	pointer
->	O
internal	pointer
,	O
sizeof	O
(	O
BTREE_CURSOR	struct
)	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___bam_c_count	function
(	O
dbc	pointer
,	O
recnop	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
db_recno_t	int
*	O
recnop	pointer
;	O
{	O
BTREE_CURSOR	struct
*	O
cp	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
db_indx_t	short
indx	short
,	O
top	short
;	O
db_recno_t	int
recno	int
;	O
int	O
ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
cp	pointer
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
if	O
(	O
cp	pointer
->	O
opd	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
cp	pointer
->	O
pgno	int
,	O
0	int
,	O
&	O
cp	pointer
->	O
page	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
for	O
(	O
indx	short
=	O
cp	pointer
->	O
indx	short
;	O
;	O
indx	short
-=	O
P_INDX	int
)	O
if	O
(	O
indx	short
==	O
0	int
||	O
!	O
IS_DUPLICATE	O
(	O
dbc	pointer
,	O
indx	short
,	O
indx	short
-	O
P_INDX	int
)	O
)	O
break	O
;	O
for	O
(	O
recno	int
=	O
1	int
,	O
top	short
=	O
NUM_ENT	O
(	O
cp	pointer
->	O
page	pointer
)	O
;	O
indx	short
<	O
top	short
;	O
++	O
recno	int
,	O
indx	short
+=	O
P_INDX	int
)	O
if	O
(	O
!	O
IS_DUPLICATE	O
(	O
dbc	pointer
,	O
indx	short
,	O
indx	short
+	O
P_INDX	int
)	O
)	O
break	O
;	O
*	O
recnop	pointer
=	O
recno	int
;	O
}	O
else	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
cp	pointer
->	O
opd	pointer
->	O
internal	pointer
->	O
root	int
,	O
0	int
,	O
&	O
cp	pointer
->	O
page	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
*	O
recnop	pointer
=	O
RE_NREC	O
(	O
cp	pointer
->	O
page	pointer
)	O
;	O
}	O
ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
cp	pointer
->	O
page	pointer
,	O
0	int
)	O
;	O
cp	pointer
->	O
page	pointer
=	O
NULL	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__bam_c_del	function
(	O
dbc	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
{	O
BTREE_CURSOR	struct
*	O
cp	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
int	O
ret	int
,	O
t_ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
cp	pointer
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
ret	int
=	O
0	int
;	O
if	O
(	O
F_ISSET	O
(	O
cp	pointer
,	O
C_DELETED	int
)	O
)	O
return	O
(	O
DB_KEYEMPTY	O
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
cp	pointer
,	O
C_RECNUM	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
__bam_c_getstack	function
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
else	O
{	O
ACQUIRE_CUR	O
(	O
dbc	pointer
,	O
DB_LOCK_WRITE	int
,	O
ret	int
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
DB_LOGGING	O
(	O
dbc	pointer
)	O
&&	O
(	O
ret	int
=	O
CDB___bam_cdel_log	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbc	pointer
->	O
txn	pointer
,	O
&	O
LSN	O
(	O
cp	pointer
->	O
page	pointer
)	O
,	O
0	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
PGNO	O
(	O
cp	pointer
->	O
page	pointer
)	O
,	O
&	O
LSN	O
(	O
cp	pointer
->	O
page	pointer
)	O
,	O
cp	pointer
->	O
indx	short
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
TYPE	O
(	O
cp	pointer
->	O
page	pointer
)	O
==	O
P_LBTREE	int
)	O
B_DSET	O
(	O
GET_BKEYDATA	O
(	O
cp	pointer
->	O
page	pointer
,	O
cp	pointer
->	O
indx	short
+	O
O_INDX	int
)	O
->	O
type	enum
)	O
;	O
else	O
B_DSET	O
(	O
GET_BKEYDATA	O
(	O
cp	pointer
->	O
page	pointer
,	O
cp	pointer
->	O
indx	short
)	O
->	O
type	enum
)	O
;	O
ret	int
=	O
CDB_memp_fset	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
cp	pointer
->	O
page	pointer
,	O
DB_MPOOL_DIRTY	int
)	O
;	O
err	pointer
:	O
if	O
(	O
F_ISSET	O
(	O
cp	pointer
,	O
C_RECNUM	int
)	O
)	O
{	O
if	O
(	O
ret	int
==	O
0	int
)	O
ret	int
=	O
CDB___bam_adjust	function
(	O
dbc	pointer
,	O
-	O
1	int
)	O
;	O
(	O
void	O
)	O
CDB___bam_stkrel	function
(	O
dbc	pointer
,	O
STK_CLRDBC	int
)	O
;	O
}	O
else	O
{	O
DISCARD_CUR	O
(	O
dbc	pointer
,	O
t_ret	int
)	O
;	O
if	O
(	O
t_ret	int
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
}	O
if	O
(	O
ret	int
==	O
0	int
)	O
(	O
void	O
)	O
CDB___bam_ca_delete	function
(	O
dbp	pointer
,	O
cp	pointer
->	O
pgno	int
,	O
cp	pointer
->	O
indx	short
,	O
1	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___bam_c_dup	function
(	O
orig_dbc	pointer
,	O
new_dbc	pointer
)	O
DBC	struct
*	O
orig_dbc	pointer
,	O
*	O
new_dbc	pointer
;	O
{	O
BTREE_CURSOR	struct
*	O
orig	struct
,	O
*	O
new	pointer
;	O
int	O
ret	int
;	O
orig	struct
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
orig_dbc	pointer
->	O
internal	pointer
;	O
new	pointer
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
new_dbc	pointer
->	O
internal	pointer
;	O
if	O
(	O
orig	struct
->	O
lock	struct
.	O
off	long
!=	O
LOCK_INVALID	O
&&	O
orig_dbc	pointer
->	O
txn	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_lget	function
(	O
new_dbc	pointer
,	O
0	int
,	O
new	pointer
->	O
pgno	int
,	O
new	pointer
->	O
lock_mode	enum
,	O
0	int
,	O
&	O
new	pointer
->	O
lock	struct
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
new	pointer
->	O
ovflsize	short
=	O
orig	struct
->	O
ovflsize	short
;	O
new	pointer
->	O
recno	int
=	O
orig	struct
->	O
recno	int
;	O
new	pointer
->	O
flags	int
=	O
orig	struct
->	O
flags	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__bam_c_get	function
(	O
dbc	pointer
,	O
key	struct
,	O
data	pointer
,	O
flags	int
,	O
pgnop	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
DBT	struct
*	O
key	struct
,	O
*	O
data	pointer
;	O
u_int32_t	int
flags	int
;	O
db_pgno_t	int
*	O
pgnop	pointer
;	O
{	O
BTREE_CURSOR	struct
*	O
cp	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
db_pgno_t	int
orig_pgno	int
;	O
db_indx_t	short
orig_indx	short
;	O
int	O
exact	int
,	O
newopd	int
,	O
ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
cp	pointer
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
orig_pgno	int
=	O
cp	pointer
->	O
pgno	int
;	O
orig_indx	short
=	O
cp	pointer
->	O
indx	short
;	O
newopd	int
=	O
0	int
;	O
switch	O
(	O
flags	int
)	O
{	O
case	O
DB_CURRENT	int
:	O
if	O
(	O
F_ISSET	O
(	O
cp	pointer
,	O
C_DELETED	int
)	O
)	O
{	O
ret	int
=	O
DB_KEYEMPTY	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
cp	pointer
->	O
pgno	int
,	O
0	int
,	O
&	O
cp	pointer
->	O
page	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
break	O
;	O
case	O
DB_FIRST	int
:	O
newopd	int
=	O
1	int
;	O
if	O
(	O
(	O
ret	int
=	O
__bam_c_first	function
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
break	O
;	O
case	O
DB_GET_BOTH	int
:	O
if	O
(	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_OPD	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
__bam_c_search	function
(	O
dbc	pointer
,	O
data	pointer
,	O
DB_GET_BOTH	int
,	O
&	O
exact	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
!	O
exact	int
)	O
{	O
ret	int
=	O
DB_NOTFOUND	O
;	O
goto	O
err	pointer
;	O
}	O
}	O
else	O
{	O
if	O
(	O
(	O
ret	int
=	O
__bam_c_search	function
(	O
dbc	pointer
,	O
key	struct
,	O
DB_GET_BOTH	int
,	O
&	O
exact	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
!	O
exact	int
)	O
{	O
ret	int
=	O
DB_NOTFOUND	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
pgnop	pointer
!=	O
NULL	O
&&	O
__bam_isopd	function
(	O
dbc	pointer
,	O
pgnop	pointer
)	O
)	O
{	O
newopd	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
__bam_getboth_finddatum	function
(	O
dbc	pointer
,	O
data	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
break	O
;	O
case	O
DB_GET_BOTHC	int
:	O
if	O
(	O
(	O
ret	int
=	O
__bam_getbothc	function
(	O
dbc	pointer
,	O
data	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
break	O
;	O
case	O
DB_LAST	int
:	O
newopd	int
=	O
1	int
;	O
if	O
(	O
(	O
ret	int
=	O
__bam_c_last	function
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
break	O
;	O
case	O
DB_NEXT	int
:	O
newopd	int
=	O
1	int
;	O
if	O
(	O
cp	pointer
->	O
pgno	int
==	O
PGNO_INVALID	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
__bam_c_first	function
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
else	O
if	O
(	O
(	O
ret	int
=	O
__bam_c_next	function
(	O
dbc	pointer
,	O
1	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
break	O
;	O
case	O
DB_NEXT_DUP	int
:	O
if	O
(	O
(	O
ret	int
=	O
__bam_c_next	function
(	O
dbc	pointer
,	O
1	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
!	O
IS_CUR_DUPLICATE	O
(	O
dbc	pointer
,	O
orig_pgno	int
,	O
orig_indx	short
)	O
)	O
{	O
ret	int
=	O
DB_NOTFOUND	O
;	O
goto	O
err	pointer
;	O
}	O
break	O
;	O
case	O
DB_NEXT_NODUP	int
:	O
newopd	int
=	O
1	int
;	O
if	O
(	O
cp	pointer
->	O
pgno	int
==	O
PGNO_INVALID	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
__bam_c_first	function
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
else	O
do	O
{	O
if	O
(	O
(	O
ret	int
=	O
__bam_c_next	function
(	O
dbc	pointer
,	O
1	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
while	O
(	O
IS_CUR_DUPLICATE	O
(	O
dbc	pointer
,	O
orig_pgno	int
,	O
orig_indx	short
)	O
)	O
;	O
break	O
;	O
case	O
DB_PREV	int
:	O
newopd	int
=	O
1	int
;	O
if	O
(	O
cp	pointer
->	O
pgno	int
==	O
PGNO_INVALID	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
__bam_c_last	function
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
else	O
if	O
(	O
(	O
ret	int
=	O
__bam_c_prev	function
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
break	O
;	O
case	O
DB_PREV_NODUP	int
:	O
newopd	int
=	O
1	int
;	O
if	O
(	O
cp	pointer
->	O
pgno	int
==	O
PGNO_INVALID	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
__bam_c_last	function
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
else	O
do	O
{	O
if	O
(	O
(	O
ret	int
=	O
__bam_c_prev	function
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
while	O
(	O
IS_CUR_DUPLICATE	O
(	O
dbc	pointer
,	O
orig_pgno	int
,	O
orig_indx	short
)	O
)	O
;	O
break	O
;	O
case	O
DB_SET	int
:	O
case	O
DB_SET_RECNO	int
:	O
newopd	int
=	O
1	int
;	O
if	O
(	O
(	O
ret	int
=	O
__bam_c_search	function
(	O
dbc	pointer
,	O
key	struct
,	O
flags	int
,	O
&	O
exact	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
break	O
;	O
case	O
DB_SET_RANGE	int
:	O
newopd	int
=	O
1	int
;	O
if	O
(	O
(	O
ret	int
=	O
__bam_c_search	function
(	O
dbc	pointer
,	O
key	struct
,	O
flags	int
,	O
&	O
exact	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
cp	pointer
->	O
indx	short
==	O
NUM_ENT	O
(	O
cp	pointer
->	O
page	pointer
)	O
||	O
IS_CUR_DELETED	O
(	O
dbc	pointer
)	O
)	O
if	O
(	O
(	O
ret	int
=	O
__bam_c_next	function
(	O
dbc	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
break	O
;	O
default	O
:	O
ret	int
=	O
CDB___db_unknown_flag	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"__bam_c_get"	pointer
,	O
flags	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
newopd	int
&&	O
pgnop	pointer
!=	O
NULL	O
)	O
(	O
void	O
)	O
__bam_isopd	function
(	O
dbc	pointer
,	O
pgnop	pointer
)	O
;	O
if	O
(	O
flags	int
==	O
DB_SET	int
)	O
F_SET	O
(	O
key	struct
,	O
DB_DBT_ISSET	int
)	O
;	O
err	pointer
:	O
if	O
(	O
F_ISSET	O
(	O
cp	pointer
,	O
C_DELETED	int
)	O
&&	O
(	O
cp	pointer
->	O
pgno	int
!=	O
orig_pgno	int
||	O
cp	pointer
->	O
indx	short
!=	O
orig_indx	short
)	O
)	O
F_CLR	O
(	O
cp	pointer
,	O
C_DELETED	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__bam_getbothc	function
(	O
dbc	pointer
,	O
data	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
DBT	struct
*	O
data	pointer
;	O
{	O
BTREE_CURSOR	struct
*	O
cp	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
int	O
cmp	int
,	O
exact	int
,	O
ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
cp	pointer
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
cp	pointer
->	O
pgno	int
,	O
0	int
,	O
&	O
cp	pointer
->	O
page	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_OPD	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_cmp	function
(	O
dbp	pointer
,	O
data	pointer
,	O
cp	pointer
->	O
page	pointer
,	O
cp	pointer
->	O
indx	short
,	O
dbp	pointer
->	O
dup_compare	pointer
==	O
NULL	O
?	O
CDB___bam_defcmp	function
:	O
dbp	pointer
->	O
dup_compare	pointer
,	O
&	O
cmp	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
cmp	int
<=	O
0	int
)	O
return	O
(	O
DB_NOTFOUND	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
cp	pointer
->	O
page	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
cp	pointer
->	O
page	pointer
=	O
NULL	O
;	O
return	O
(	O
__bam_c_search	function
(	O
dbc	pointer
,	O
data	pointer
,	O
DB_GET_BOTH	int
,	O
&	O
exact	int
)	O
)	O
;	O
}	O
if	O
(	O
cp	pointer
->	O
indx	short
+	O
P_INDX	int
>=	O
NUM_ENT	O
(	O
cp	pointer
->	O
page	pointer
)	O
||	O
!	O
IS_DUPLICATE	O
(	O
dbc	pointer
,	O
cp	pointer
->	O
indx	short
,	O
cp	pointer
->	O
indx	short
+	O
P_INDX	int
)	O
)	O
return	O
(	O
DB_NOTFOUND	O
)	O
;	O
cp	pointer
->	O
indx	short
+=	O
P_INDX	int
;	O
return	O
(	O
__bam_getboth_finddatum	function
(	O
dbc	pointer
,	O
data	pointer
)	O
)	O
;	O
}	O
static	O
int	O
__bam_getboth_finddatum	function
(	O
dbc	pointer
,	O
data	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
DBT	struct
*	O
data	pointer
;	O
{	O
BTREE_CURSOR	struct
*	O
cp	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
db_indx_t	short
base	short
,	O
lim	short
,	O
top	short
;	O
int	O
cmp	int
,	O
ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
cp	pointer
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
if	O
(	O
dbp	pointer
->	O
dup_compare	pointer
==	O
NULL	O
)	O
{	O
for	O
(	O
;	O
;	O
cp	pointer
->	O
indx	short
+=	O
P_INDX	int
)	O
{	O
if	O
(	O
!	O
IS_CUR_DELETED	O
(	O
dbc	pointer
)	O
&&	O
(	O
ret	int
=	O
CDB___bam_cmp	function
(	O
dbp	pointer
,	O
data	pointer
,	O
cp	pointer
->	O
page	pointer
,	O
cp	pointer
->	O
indx	short
+	O
O_INDX	int
,	O
CDB___bam_defcmp	function
,	O
&	O
cmp	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
cmp	int
==	O
0	int
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
cp	pointer
->	O
indx	short
+	O
P_INDX	int
>=	O
NUM_ENT	O
(	O
cp	pointer
->	O
page	pointer
)	O
||	O
!	O
IS_DUPLICATE	O
(	O
dbc	pointer
,	O
cp	pointer
->	O
indx	short
,	O
cp	pointer
->	O
indx	short
+	O
P_INDX	int
)	O
)	O
break	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
base	short
=	O
top	short
=	O
cp	pointer
->	O
indx	short
;	O
top	short
<	O
NUM_ENT	O
(	O
cp	pointer
->	O
page	pointer
)	O
;	O
top	short
+=	O
P_INDX	int
)	O
if	O
(	O
!	O
IS_DUPLICATE	O
(	O
dbc	pointer
,	O
cp	pointer
->	O
indx	short
,	O
top	short
)	O
)	O
break	O
;	O
if	O
(	O
base	short
==	O
(	O
top	short
-	O
P_INDX	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_cmp	function
(	O
dbp	pointer
,	O
data	pointer
,	O
cp	pointer
->	O
page	pointer
,	O
cp	pointer
->	O
indx	short
+	O
O_INDX	int
,	O
dbp	pointer
->	O
dup_compare	pointer
,	O
&	O
cmp	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
return	O
(	O
cmp	int
==	O
0	int
?	O
0	int
:	O
DB_NOTFOUND	O
)	O
;	O
}	O
for	O
(	O
lim	short
=	O
(	O
top	short
-	O
base	short
)	O
/	O
(	O
db_indx_t	short
)	O
P_INDX	int
;	O
lim	short
!=	O
0	int
;	O
lim	short
>>=	O
1	int
)	O
{	O
cp	pointer
->	O
indx	short
=	O
base	short
+	O
(	O
(	O
lim	short
>>	O
1	int
)	O
*	O
P_INDX	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_cmp	function
(	O
dbp	pointer
,	O
data	pointer
,	O
cp	pointer
->	O
page	pointer
,	O
cp	pointer
->	O
indx	short
+	O
O_INDX	int
,	O
dbp	pointer
->	O
dup_compare	pointer
,	O
&	O
cmp	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
cmp	int
==	O
0	int
)	O
{	O
if	O
(	O
!	O
IS_CUR_DELETED	O
(	O
dbc	pointer
)	O
)	O
return	O
(	O
0	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
cmp	int
>	O
0	int
)	O
{	O
base	short
=	O
cp	pointer
->	O
indx	short
+	O
P_INDX	int
;	O
--	O
lim	short
;	O
}	O
}	O
}	O
return	O
(	O
DB_NOTFOUND	O
)	O
;	O
}	O
static	O
int	O
__bam_c_put	function
(	O
dbc	pointer
,	O
key	struct
,	O
data	pointer
,	O
flags	int
,	O
pgnop	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
DBT	struct
*	O
key	struct
,	O
*	O
data	pointer
;	O
u_int32_t	int
flags	int
;	O
db_pgno_t	int
*	O
pgnop	pointer
;	O
{	O
BTREE_CURSOR	struct
*	O
cp	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
DBT	struct
dbt	struct
;	O
u_int32_t	int
iiop	int
;	O
int	O
cmp	int
,	O
exact	int
,	O
ret	int
,	O
stack	array
;	O
void	O
*	O
arg	pointer
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
cp	pointer
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
split	O
:	O
ret	int
=	O
stack	array
=	O
0	int
;	O
switch	O
(	O
flags	int
)	O
{	O
case	O
DB_AFTER	int
:	O
case	O
DB_BEFORE	int
:	O
case	O
DB_CURRENT	int
:	O
iiop	int
=	O
flags	int
;	O
if	O
(	O
F_ISSET	O
(	O
cp	pointer
,	O
C_RECNUM	int
)	O
&&	O
(	O
flags	int
!=	O
DB_CURRENT	int
||	O
F_ISSET	O
(	O
cp	pointer
,	O
C_DELETED	int
)	O
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
__bam_c_getstack	function
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
stack	array
=	O
1	int
;	O
}	O
else	O
{	O
ACQUIRE_WRITE_LOCK	O
(	O
dbc	pointer
,	O
ret	int
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
cp	pointer
->	O
pgno	int
,	O
0	int
,	O
&	O
cp	pointer
->	O
page	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
break	O
;	O
case	O
DB_KEYFIRST	int
:	O
case	O
DB_KEYLAST	int
:	O
case	O
DB_NODUPDATA	int
:	O
if	O
(	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_OPD	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
__bam_c_search	function
(	O
dbc	pointer
,	O
data	pointer
,	O
flags	int
,	O
&	O
exact	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
stack	array
=	O
1	int
;	O
if	O
(	O
exact	int
)	O
{	O
ret	int
=	O
CDB___db_duperr	function
(	O
dbp	pointer
,	O
flags	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
iiop	int
=	O
DB_BEFORE	int
;	O
break	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
__bam_c_search	function
(	O
dbc	pointer
,	O
key	struct
,	O
flags	int
==	O
DB_KEYFIRST	int
||	O
dbp	pointer
->	O
dup_compare	pointer
!=	O
NULL	O
?	O
DB_KEYFIRST	int
:	O
DB_KEYLAST	int
,	O
&	O
exact	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
stack	array
=	O
1	int
;	O
if	O
(	O
!	O
exact	int
)	O
{	O
iiop	int
=	O
DB_KEYFIRST	int
;	O
break	O
;	O
}	O
if	O
(	O
!	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_DUP	int
)	O
)	O
{	O
iiop	int
=	O
DB_CURRENT	int
;	O
break	O
;	O
}	O
if	O
(	O
pgnop	pointer
!=	O
NULL	O
&&	O
__bam_isopd	function
(	O
dbc	pointer
,	O
pgnop	pointer
)	O
)	O
goto	O
done	O
;	O
if	O
(	O
dbp	pointer
->	O
dup_compare	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
flags	int
==	O
DB_KEYFIRST	int
)	O
iiop	int
=	O
DB_BEFORE	int
;	O
else	O
for	O
(	O
;	O
;	O
cp	pointer
->	O
indx	short
+=	O
P_INDX	int
)	O
if	O
(	O
cp	pointer
->	O
indx	short
+	O
P_INDX	int
>=	O
NUM_ENT	O
(	O
cp	pointer
->	O
page	pointer
)	O
||	O
!	O
IS_DUPLICATE	O
(	O
dbc	pointer
,	O
cp	pointer
->	O
indx	short
,	O
cp	pointer
->	O
indx	short
+	O
P_INDX	int
)	O
)	O
{	O
iiop	int
=	O
DB_AFTER	int
;	O
break	O
;	O
}	O
break	O
;	O
}	O
for	O
(	O
;	O
;	O
cp	pointer
->	O
indx	short
+=	O
P_INDX	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_cmp	function
(	O
dbp	pointer
,	O
data	pointer
,	O
cp	pointer
->	O
page	pointer
,	O
cp	pointer
->	O
indx	short
+	O
O_INDX	int
,	O
dbp	pointer
->	O
dup_compare	pointer
,	O
&	O
cmp	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
cmp	int
<	O
0	int
)	O
{	O
iiop	int
=	O
DB_BEFORE	int
;	O
break	O
;	O
}	O
if	O
(	O
cmp	int
==	O
0	int
)	O
{	O
ret	int
=	O
CDB___db_duperr	function
(	O
dbp	pointer
,	O
flags	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
cp	pointer
->	O
indx	short
+	O
P_INDX	int
>=	O
NUM_ENT	O
(	O
cp	pointer
->	O
page	pointer
)	O
||	O
(	O
(	O
PAGE	struct
*	O
)	O
cp	pointer
->	O
page	pointer
)	O
->	O
inp	array
[	O
cp	pointer
->	O
indx	short
]	O
!=	O
(	O
(	O
PAGE	struct
*	O
)	O
cp	pointer
->	O
page	pointer
)	O
->	O
inp	array
[	O
cp	pointer
->	O
indx	short
+	O
P_INDX	int
]	O
)	O
{	O
iiop	int
=	O
DB_AFTER	int
;	O
break	O
;	O
}	O
}	O
break	O
;	O
default	O
:	O
ret	int
=	O
CDB___db_unknown_flag	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"__bam_c_put"	pointer
,	O
flags	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
switch	O
(	O
ret	int
=	O
CDB___bam_iitem	function
(	O
dbc	pointer
,	O
key	struct
,	O
data	pointer
,	O
iiop	int
,	O
0	int
)	O
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
DB_NEEDSPLIT	O
:	O
if	O
(	O
flags	int
==	O
DB_AFTER	int
||	O
flags	int
==	O
DB_BEFORE	int
||	O
flags	int
==	O
DB_CURRENT	int
)	O
{	O
memset	function
(	O
&	O
dbt	struct
,	O
0	int
,	O
sizeof	O
(	O
DBT	struct
)	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_ret	function
(	O
dbp	pointer
,	O
cp	pointer
->	O
page	pointer
,	O
0	int
,	O
&	O
dbt	struct
,	O
&	O
dbc	pointer
->	O
rkey	struct
.	O
data	pointer
,	O
&	O
dbc	pointer
->	O
rkey	struct
.	O
ulen	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
arg	pointer
=	O
&	O
dbt	struct
;	O
}	O
else	O
arg	pointer
=	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_OPD	int
)	O
?	O
data	pointer
:	O
key	struct
;	O
if	O
(	O
stack	array
)	O
ret	int
=	O
CDB___bam_stkrel	function
(	O
dbc	pointer
,	O
STK_CLRDBC	int
|	O
STK_NOLOCK	int
)	O
;	O
else	O
DISCARD_CUR	O
(	O
dbc	pointer
,	O
ret	int
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_split	function
(	O
dbc	pointer
,	O
arg	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
goto	O
split	O
;	O
default	O
:	O
goto	O
err	pointer
;	O
}	O
err	pointer
:	O
done	O
:	O
if	O
(	O
stack	array
&&	O
BT_STK_POP	O
(	O
cp	pointer
)	O
!=	O
NULL	O
)	O
(	O
void	O
)	O
CDB___bam_stkrel	function
(	O
dbc	pointer
,	O
0	int
)	O
;	O
F_CLR	O
(	O
cp	pointer
,	O
C_DELETED	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___bam_c_rget	function
(	O
dbc	pointer
,	O
data	pointer
,	O
flags	int
)	O
DBC	struct
*	O
dbc	pointer
;	O
DBT	struct
*	O
data	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
if	O
(	O
flags	int
>	O
0	int
)	O
{	O
flags	int
=	O
flags	int
+	O
1	int
;	O
flags	int
=	O
flags	int
-	O
1	int
;	O
}	O
BTREE_CURSOR	struct
*	O
cp	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
DBT	struct
dbt	struct
;	O
db_recno_t	int
recno	int
;	O
int	O
exact	int
,	O
ret	int
;	O
COMPQUIET	O
(	O
flags	int
,	O
0	int
)	O
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
cp	pointer
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
cp	pointer
->	O
pgno	int
,	O
0	int
,	O
&	O
cp	pointer
->	O
page	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
memset	function
(	O
&	O
dbt	struct
,	O
0	int
,	O
sizeof	O
(	O
DBT	struct
)	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_ret	function
(	O
dbp	pointer
,	O
cp	pointer
->	O
page	pointer
,	O
cp	pointer
->	O
indx	short
,	O
&	O
dbt	struct
,	O
&	O
dbc	pointer
->	O
rkey	struct
.	O
data	pointer
,	O
&	O
dbc	pointer
->	O
rkey	struct
.	O
ulen	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
cp	pointer
->	O
page	pointer
,	O
0	int
)	O
;	O
cp	pointer
->	O
page	pointer
=	O
NULL	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_search	function
(	O
dbc	pointer
,	O
&	O
dbt	struct
,	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_RMW	int
)	O
?	O
S_FIND_WR	O
:	O
S_FIND	O
,	O
1	int
,	O
&	O
recno	int
,	O
&	O
exact	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
ret	int
=	O
CDB___db_retcopy	function
(	O
dbp	pointer
,	O
data	pointer
,	O
&	O
recno	int
,	O
sizeof	O
(	O
recno	int
)	O
,	O
&	O
dbc	pointer
->	O
rdata	struct
.	O
data	pointer
,	O
&	O
dbc	pointer
->	O
rdata	struct
.	O
ulen	int
)	O
;	O
err	pointer
:	O
CDB___bam_stkrel	function
(	O
dbc	pointer
,	O
0	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__bam_c_writelock	function
(	O
dbc	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
{	O
BTREE_CURSOR	struct
*	O
cp	pointer
;	O
int	O
ret	int
;	O
cp	pointer
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
if	O
(	O
cp	pointer
->	O
lock_mode	enum
==	O
DB_LOCK_WRITE	int
)	O
return	O
(	O
0	int
)	O
;	O
ACQUIRE_WRITE_LOCK	O
(	O
dbc	pointer
,	O
ret	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__bam_c_first	function
(	O
dbc	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
{	O
BTREE_CURSOR	struct
*	O
cp	pointer
;	O
db_pgno_t	int
pgno	int
;	O
int	O
ret	int
;	O
cp	pointer
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
ret	int
=	O
0	int
;	O
for	O
(	O
pgno	int
=	O
cp	pointer
->	O
root	int
;	O
;	O
)	O
{	O
ACQUIRE_CUR_SET	O
(	O
dbc	pointer
,	O
DB_LOCK_READ	int
,	O
pgno	int
,	O
ret	int
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
ISLEAF	O
(	O
cp	pointer
->	O
page	pointer
)	O
)	O
break	O
;	O
pgno	int
=	O
GET_BINTERNAL	O
(	O
cp	pointer
->	O
page	pointer
,	O
0	int
)	O
->	O
pgno	int
;	O
}	O
if	O
(	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_RMW	int
)	O
)	O
{	O
ACQUIRE_WRITE_LOCK	O
(	O
dbc	pointer
,	O
ret	int
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
NUM_ENT	O
(	O
cp	pointer
->	O
page	pointer
)	O
==	O
0	int
||	O
IS_CUR_DELETED	O
(	O
dbc	pointer
)	O
)	O
if	O
(	O
(	O
ret	int
=	O
__bam_c_next	function
(	O
dbc	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__bam_c_last	function
(	O
dbc	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
{	O
BTREE_CURSOR	struct
*	O
cp	pointer
;	O
db_pgno_t	int
pgno	int
;	O
int	O
ret	int
;	O
cp	pointer
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
ret	int
=	O
0	int
;	O
for	O
(	O
pgno	int
=	O
cp	pointer
->	O
root	int
;	O
;	O
)	O
{	O
ACQUIRE_CUR_SET	O
(	O
dbc	pointer
,	O
DB_LOCK_READ	int
,	O
pgno	int
,	O
ret	int
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
ISLEAF	O
(	O
cp	pointer
->	O
page	pointer
)	O
)	O
break	O
;	O
pgno	int
=	O
GET_BINTERNAL	O
(	O
cp	pointer
->	O
page	pointer
,	O
NUM_ENT	O
(	O
cp	pointer
->	O
page	pointer
)	O
-	O
O_INDX	int
)	O
->	O
pgno	int
;	O
}	O
if	O
(	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_RMW	int
)	O
)	O
{	O
ACQUIRE_WRITE_LOCK	O
(	O
dbc	pointer
,	O
ret	int
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
cp	pointer
->	O
indx	short
=	O
NUM_ENT	O
(	O
cp	pointer
->	O
page	pointer
)	O
==	O
0	int
?	O
0	int
:	O
NUM_ENT	O
(	O
cp	pointer
->	O
page	pointer
)	O
-	O
(	O
TYPE	O
(	O
cp	pointer
->	O
page	pointer
)	O
==	O
P_LBTREE	int
?	O
P_INDX	int
:	O
O_INDX	int
)	O
;	O
if	O
(	O
NUM_ENT	O
(	O
cp	pointer
->	O
page	pointer
)	O
==	O
0	int
||	O
IS_CUR_DELETED	O
(	O
dbc	pointer
)	O
)	O
if	O
(	O
(	O
ret	int
=	O
__bam_c_prev	function
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__bam_c_next	function
(	O
dbc	pointer
,	O
initial_move	int
)	O
DBC	struct
*	O
dbc	pointer
;	O
int	O
initial_move	int
;	O
{	O
BTREE_CURSOR	struct
*	O
cp	pointer
;	O
db_indx_t	short
adjust	int
;	O
db_lockmode_t	enum
lock_mode	enum
;	O
db_pgno_t	int
pgno	int
;	O
int	O
ret	int
;	O
cp	pointer
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
ret	int
=	O
0	int
;	O
if	O
(	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_OPD	int
)	O
)	O
{	O
adjust	int
=	O
O_INDX	int
;	O
lock_mode	enum
=	O
DB_LOCK_NG	int
;	O
}	O
else	O
{	O
adjust	int
=	O
dbc	pointer
->	O
dbtype	enum
==	O
DB_BTREE	int
?	O
P_INDX	int
:	O
O_INDX	int
;	O
lock_mode	enum
=	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_RMW	int
)	O
?	O
DB_LOCK_WRITE	int
:	O
DB_LOCK_READ	int
;	O
}	O
if	O
(	O
cp	pointer
->	O
page	pointer
==	O
NULL	O
)	O
{	O
ACQUIRE_CUR	O
(	O
dbc	pointer
,	O
lock_mode	enum
,	O
ret	int
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
initial_move	int
)	O
cp	pointer
->	O
indx	short
+=	O
adjust	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
cp	pointer
->	O
indx	short
>=	O
NUM_ENT	O
(	O
cp	pointer
->	O
page	pointer
)	O
)	O
{	O
if	O
(	O
(	O
pgno	int
=	O
NEXT_PGNO	O
(	O
cp	pointer
->	O
page	pointer
)	O
)	O
==	O
PGNO_INVALID	int
)	O
return	O
(	O
DB_NOTFOUND	O
)	O
;	O
ACQUIRE_CUR_SET	O
(	O
dbc	pointer
,	O
lock_mode	enum
,	O
pgno	int
,	O
ret	int
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
IS_CUR_DELETED	O
(	O
dbc	pointer
)	O
)	O
{	O
cp	pointer
->	O
indx	short
+=	O
adjust	int
;	O
continue	O
;	O
}	O
break	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__bam_c_prev	function
(	O
dbc	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
{	O
BTREE_CURSOR	struct
*	O
cp	pointer
;	O
db_indx_t	short
adjust	int
;	O
db_lockmode_t	enum
lock_mode	enum
;	O
db_pgno_t	int
pgno	int
;	O
int	O
ret	int
;	O
cp	pointer
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
ret	int
=	O
0	int
;	O
if	O
(	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_OPD	int
)	O
)	O
{	O
adjust	int
=	O
O_INDX	int
;	O
lock_mode	enum
=	O
DB_LOCK_NG	int
;	O
}	O
else	O
{	O
adjust	int
=	O
dbc	pointer
->	O
dbtype	enum
==	O
DB_BTREE	int
?	O
P_INDX	int
:	O
O_INDX	int
;	O
lock_mode	enum
=	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_RMW	int
)	O
?	O
DB_LOCK_WRITE	int
:	O
DB_LOCK_READ	int
;	O
}	O
if	O
(	O
cp	pointer
->	O
page	pointer
==	O
NULL	O
)	O
{	O
ACQUIRE_CUR	O
(	O
dbc	pointer
,	O
lock_mode	enum
,	O
ret	int
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
cp	pointer
->	O
indx	short
==	O
0	int
)	O
{	O
if	O
(	O
(	O
pgno	int
=	O
PREV_PGNO	O
(	O
cp	pointer
->	O
page	pointer
)	O
)	O
==	O
PGNO_INVALID	int
)	O
return	O
(	O
DB_NOTFOUND	O
)	O
;	O
ACQUIRE_CUR_SET	O
(	O
dbc	pointer
,	O
lock_mode	enum
,	O
pgno	int
,	O
ret	int
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
cp	pointer
->	O
indx	short
=	O
NUM_ENT	O
(	O
cp	pointer
->	O
page	pointer
)	O
)	O
==	O
0	int
)	O
continue	O
;	O
}	O
cp	pointer
->	O
indx	short
-=	O
adjust	int
;	O
if	O
(	O
IS_CUR_DELETED	O
(	O
dbc	pointer
)	O
)	O
continue	O
;	O
break	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__bam_c_search	function
(	O
dbc	pointer
,	O
key	struct
,	O
flags	int
,	O
exactp	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
const	O
DBT	struct
*	O
key	struct
;	O
u_int32_t	int
flags	int
;	O
int	O
*	O
exactp	pointer
;	O
{	O
BTREE	struct
*	O
t	pointer
;	O
BTREE_CURSOR	struct
*	O
cp	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
PAGE	struct
*	O
h	pointer
;	O
db_indx_t	short
indx	short
;	O
db_recno_t	int
recno	int
;	O
u_int32_t	int
sflags	int
;	O
int	O
cmp	int
,	O
ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
cp	pointer
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
t	pointer
=	O
dbp	pointer
->	O
bt_internal	pointer
;	O
ret	int
=	O
0	int
;	O
DISCARD_CUR	O
(	O
dbc	pointer
,	O
ret	int
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
switch	O
(	O
flags	int
)	O
{	O
case	O
DB_SET_RECNO	int
:	O
if	O
(	O
(	O
ret	int
=	O
CDB___ram_getno	function
(	O
dbc	pointer
,	O
key	struct
,	O
&	O
recno	int
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
sflags	int
=	O
(	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_RMW	int
)	O
?	O
S_FIND_WR	O
:	O
S_FIND	O
)	O
|	O
S_EXACT	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_rsearch	function
(	O
dbc	pointer
,	O
&	O
recno	int
,	O
sflags	int
,	O
1	int
,	O
exactp	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
break	O
;	O
case	O
DB_SET	int
:	O
case	O
DB_GET_BOTH	int
:	O
sflags	int
=	O
(	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_RMW	int
)	O
?	O
S_FIND_WR	O
:	O
S_FIND	O
)	O
|	O
S_EXACT	int
;	O
goto	O
search	O
;	O
case	O
DB_SET_RANGE	int
:	O
sflags	int
=	O
(	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_RMW	int
)	O
?	O
S_WRITE	int
:	O
S_READ	int
)	O
|	O
S_DUPFIRST	int
;	O
goto	O
search	O
;	O
case	O
DB_KEYFIRST	int
:	O
sflags	int
=	O
S_KEYFIRST	O
;	O
goto	O
fast_search	O
;	O
case	O
DB_KEYLAST	int
:	O
case	O
DB_NODUPDATA	int
:	O
sflags	int
=	O
S_KEYLAST	O
;	O
fast_search	O
:	O
if	O
(	O
F_ISSET	O
(	O
cp	pointer
,	O
C_RECNUM	int
)	O
)	O
goto	O
search	O
;	O
if	O
(	O
t	pointer
->	O
bt_lpgno	int
==	O
PGNO_INVALID	int
)	O
goto	O
search	O
;	O
h	pointer
=	O
NULL	O
;	O
ACQUIRE	O
(	O
dbc	pointer
,	O
DB_LOCK_WRITE	int
,	O
t	pointer
->	O
bt_lpgno	int
,	O
cp	pointer
->	O
lock	struct
,	O
t	pointer
->	O
bt_lpgno	int
,	O
h	pointer
,	O
ret	int
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
TYPE	O
(	O
h	pointer
)	O
!=	O
P_LBTREE	int
||	O
NUM_ENT	O
(	O
h	pointer
)	O
==	O
0	int
)	O
goto	O
fast_miss	O
;	O
if	O
(	O
h	pointer
->	O
next_pgno	int
==	O
PGNO_INVALID	int
)	O
{	O
indx	short
=	O
NUM_ENT	O
(	O
h	pointer
)	O
-	O
P_INDX	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_cmp	function
(	O
dbp	pointer
,	O
key	struct
,	O
h	pointer
,	O
indx	short
,	O
t	pointer
->	O
bt_compare	pointer
,	O
&	O
cmp	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
cmp	int
<	O
0	int
)	O
goto	O
try_begin	O
;	O
if	O
(	O
cmp	int
>	O
0	int
)	O
{	O
indx	short
+=	O
P_INDX	int
;	O
goto	O
fast_hit	O
;	O
}	O
if	O
(	O
flags	int
==	O
DB_KEYLAST	int
)	O
goto	O
fast_hit	O
;	O
for	O
(	O
;	O
indx	short
>	O
0	int
&&	O
h	pointer
->	O
inp	array
[	O
indx	short
-	O
P_INDX	int
]	O
==	O
h	pointer
->	O
inp	array
[	O
indx	short
]	O
;	O
indx	short
-=	O
P_INDX	int
)	O
;	O
goto	O
fast_hit	O
;	O
}	O
try_begin	O
:	O
if	O
(	O
h	pointer
->	O
prev_pgno	int
==	O
PGNO_INVALID	int
)	O
{	O
indx	short
=	O
0	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_cmp	function
(	O
dbp	pointer
,	O
key	struct
,	O
h	pointer
,	O
indx	short
,	O
t	pointer
->	O
bt_compare	pointer
,	O
&	O
cmp	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
cmp	int
>	O
0	int
)	O
goto	O
fast_miss	O
;	O
if	O
(	O
cmp	int
<	O
0	int
)	O
goto	O
fast_hit	O
;	O
if	O
(	O
flags	int
==	O
DB_KEYFIRST	int
)	O
goto	O
fast_hit	O
;	O
for	O
(	O
;	O
indx	short
<	O
(	O
db_indx_t	short
)	O
(	O
NUM_ENT	O
(	O
h	pointer
)	O
-	O
P_INDX	int
)	O
&&	O
h	pointer
->	O
inp	array
[	O
indx	short
]	O
==	O
h	pointer
->	O
inp	array
[	O
indx	short
+	O
P_INDX	int
]	O
;	O
indx	short
+=	O
P_INDX	int
)	O
;	O
goto	O
fast_hit	O
;	O
}	O
goto	O
fast_miss	O
;	O
fast_hit	O
:	O
*	O
exactp	pointer
=	O
cmp	int
==	O
0	int
;	O
BT_STK_CLR	O
(	O
cp	pointer
)	O
;	O
BT_STK_ENTER	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
cp	pointer
,	O
h	pointer
,	O
indx	short
,	O
cp	pointer
->	O
lock	struct
,	O
cp	pointer
->	O
lock_mode	enum
,	O
ret	int
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
break	O
;	O
fast_miss	O
:	O
DISCARD	O
(	O
dbc	pointer
,	O
1	int
,	O
cp	pointer
->	O
lock	struct
,	O
h	pointer
,	O
ret	int
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
search	O
:	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_search	function
(	O
dbc	pointer
,	O
key	struct
,	O
sflags	int
,	O
1	int
,	O
NULL	O
,	O
exactp	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
break	O
;	O
default	O
:	O
return	O
(	O
CDB___db_unknown_flag	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"__bam_c_search"	pointer
,	O
flags	int
)	O
)	O
;	O
}	O
cp	pointer
->	O
page	pointer
=	O
cp	pointer
->	O
csp	pointer
->	O
page	pointer
;	O
cp	pointer
->	O
pgno	int
=	O
cp	pointer
->	O
csp	pointer
->	O
page	pointer
->	O
pgno	int
;	O
cp	pointer
->	O
indx	short
=	O
cp	pointer
->	O
csp	pointer
->	O
indx	short
;	O
cp	pointer
->	O
lock	struct
=	O
cp	pointer
->	O
csp	pointer
->	O
lock	struct
;	O
cp	pointer
->	O
lock_mode	enum
=	O
cp	pointer
->	O
csp	pointer
->	O
lock_mode	enum
;	O
if	O
(	O
TYPE	O
(	O
cp	pointer
->	O
page	pointer
)	O
==	O
P_LBTREE	int
&&	O
(	O
flags	int
==	O
DB_KEYFIRST	int
||	O
flags	int
==	O
DB_KEYLAST	int
)	O
)	O
t	pointer
->	O
bt_lpgno	int
=	O
(	O
NEXT_PGNO	O
(	O
cp	pointer
->	O
page	pointer
)	O
==	O
PGNO_INVALID	int
&&	O
cp	pointer
->	O
indx	short
>=	O
NUM_ENT	O
(	O
cp	pointer
->	O
page	pointer
)	O
)	O
||	O
(	O
PREV_PGNO	O
(	O
cp	pointer
->	O
page	pointer
)	O
==	O
PGNO_INVALID	int
&&	O
cp	pointer
->	O
indx	short
==	O
0	int
)	O
?	O
cp	pointer
->	O
pgno	int
:	O
PGNO_INVALID	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__bam_c_physdel	function
(	O
dbc	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
{	O
BTREE_CURSOR	struct
*	O
cp	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
DBT	struct
key	struct
;	O
DB_LOCK	struct
lock	struct
;	O
PAGE	struct
*	O
h	pointer
;	O
db_pgno_t	int
pgno	int
;	O
int	O
delete_page	int
,	O
empty_page	int
,	O
exact	int
,	O
level	char
,	O
ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
cp	pointer
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
delete_page	int
=	O
empty_page	int
=	O
ret	int
=	O
0	int
;	O
delete_page	int
=	O
empty_page	int
=	O
NUM_ENT	O
(	O
cp	pointer
->	O
page	pointer
)	O
==	O
(	O
TYPE	O
(	O
cp	pointer
->	O
page	pointer
)	O
==	O
P_LBTREE	int
?	O
2	int
:	O
1	int
)	O
;	O
if	O
(	O
delete_page	int
&&	O
!	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_OPD	int
)	O
&&	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_BT_REVSPLIT	int
)	O
)	O
delete_page	int
=	O
0	int
;	O
if	O
(	O
delete_page	int
&&	O
cp	pointer
->	O
pgno	int
==	O
cp	pointer
->	O
root	int
)	O
delete_page	int
=	O
0	int
;	O
if	O
(	O
delete_page	int
)	O
{	O
memset	function
(	O
&	O
key	struct
,	O
0	int
,	O
sizeof	O
(	O
DBT	struct
)	O
)	O
;	O
key	struct
.	O
app_private	pointer
=	O
dbp	pointer
->	O
dbenv	pointer
->	O
app_private	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_ret	function
(	O
dbp	pointer
,	O
cp	pointer
->	O
page	pointer
,	O
0	int
,	O
&	O
key	struct
,	O
&	O
dbc	pointer
->	O
rkey	struct
.	O
data	pointer
,	O
&	O
dbc	pointer
->	O
rkey	struct
.	O
ulen	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
TYPE	O
(	O
cp	pointer
->	O
page	pointer
)	O
==	O
P_LBTREE	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_ditem	function
(	O
dbc	pointer
,	O
cp	pointer
->	O
page	pointer
,	O
cp	pointer
->	O
indx	short
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
!	O
empty_page	int
)	O
CDB___bam_ca_di	function
(	O
dbp	pointer
,	O
PGNO	O
(	O
cp	pointer
->	O
page	pointer
)	O
,	O
cp	pointer
->	O
indx	short
,	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_ditem	function
(	O
dbc	pointer
,	O
cp	pointer
->	O
page	pointer
,	O
cp	pointer
->	O
indx	short
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
!	O
empty_page	int
)	O
CDB___bam_ca_di	function
(	O
dbp	pointer
,	O
PGNO	O
(	O
cp	pointer
->	O
page	pointer
)	O
,	O
cp	pointer
->	O
indx	short
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
delete_page	int
)	O
return	O
(	O
0	int
)	O
;	O
for	O
(	O
level	char
=	O
LEAFLEVEL	int
;	O
;	O
++	O
level	char
)	O
{	O
key	struct
.	O
app_private	pointer
=	O
dbp	pointer
->	O
dbenv	pointer
->	O
app_private	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_search	function
(	O
dbc	pointer
,	O
&	O
key	struct
,	O
S_WRPAIR	O
,	O
level	char
,	O
NULL	O
,	O
&	O
exact	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
h	pointer
=	O
cp	pointer
->	O
csp	pointer
[	O
-	O
1	int
]	O
.	O
page	pointer
;	O
if	O
(	O
h	pointer
->	O
pgno	int
==	O
cp	pointer
->	O
root	int
||	O
NUM_ENT	O
(	O
h	pointer
)	O
!=	O
1	int
)	O
break	O
;	O
(	O
void	O
)	O
CDB___bam_stkrel	function
(	O
dbc	pointer
,	O
STK_NOLOCK	int
)	O
;	O
}	O
++	O
cp	pointer
->	O
csp	pointer
;	O
for	O
(	O
h	pointer
=	O
cp	pointer
->	O
csp	pointer
[	O
-	O
1	int
]	O
.	O
page	pointer
;	O
;	O
)	O
{	O
if	O
(	O
ISLEAF	O
(	O
h	pointer
)	O
)	O
{	O
if	O
(	O
NUM_ENT	O
(	O
h	pointer
)	O
!=	O
0	int
)	O
break	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
NUM_ENT	O
(	O
h	pointer
)	O
!=	O
1	int
)	O
break	O
;	O
switch	O
(	O
TYPE	O
(	O
h	pointer
)	O
)	O
{	O
case	O
P_IBTREE	int
:	O
pgno	int
=	O
GET_BINTERNAL	O
(	O
h	pointer
,	O
0	int
)	O
->	O
pgno	int
;	O
break	O
;	O
case	O
P_IRECNO	int
:	O
pgno	int
=	O
GET_RINTERNAL	O
(	O
h	pointer
,	O
0	int
)	O
->	O
pgno	int
;	O
break	O
;	O
default	O
:	O
return	O
(	O
CDB___db_pgfmt	function
(	O
dbp	pointer
,	O
PGNO	O
(	O
h	pointer
)	O
)	O
)	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_lget	function
(	O
dbc	pointer
,	O
0	int
,	O
pgno	int
,	O
DB_LOCK_WRITE	int
,	O
0	int
,	O
&	O
lock	struct
)	O
)	O
!=	O
0	int
)	O
break	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pgno	int
,	O
0	int
,	O
&	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
break	O
;	O
BT_STK_PUSH	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
cp	pointer
,	O
h	pointer
,	O
0	int
,	O
lock	struct
,	O
DB_LOCK_WRITE	int
,	O
ret	int
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
break	O
;	O
}	O
BT_STK_POP	O
(	O
cp	pointer
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
ret	int
=	O
CDB___bam_dpages	function
(	O
dbc	pointer
,	O
cp	pointer
->	O
sp	pointer
)	O
;	O
else	O
(	O
void	O
)	O
CDB___bam_stkrel	function
(	O
dbc	pointer
,	O
0	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__bam_c_getstack	function
(	O
dbc	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
{	O
BTREE_CURSOR	struct
*	O
cp	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
DBT	struct
dbt	struct
;	O
PAGE	struct
*	O
h	pointer
;	O
int	O
exact	int
,	O
ret	int
,	O
t_ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
cp	pointer
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
cp	pointer
->	O
pgno	int
,	O
0	int
,	O
&	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
memset	function
(	O
&	O
dbt	struct
,	O
0	int
,	O
sizeof	O
(	O
DBT	struct
)	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_ret	function
(	O
dbp	pointer
,	O
h	pointer
,	O
0	int
,	O
&	O
dbt	struct
,	O
&	O
dbc	pointer
->	O
rkey	struct
.	O
data	pointer
,	O
&	O
dbc	pointer
->	O
rkey	struct
.	O
ulen	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
exact	int
=	O
0	int
;	O
ret	int
=	O
CDB___bam_search	function
(	O
dbc	pointer
,	O
&	O
dbt	struct
,	O
S_KEYFIRST	O
,	O
1	int
,	O
NULL	O
,	O
&	O
exact	int
)	O
;	O
err	pointer
:	O
if	O
(	O
(	O
t_ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
{	O
cp	pointer
->	O
page	pointer
=	O
cp	pointer
->	O
csp	pointer
->	O
page	pointer
;	O
cp	pointer
->	O
lock	struct
=	O
cp	pointer
->	O
csp	pointer
->	O
lock	struct
;	O
cp	pointer
->	O
lock_mode	enum
=	O
cp	pointer
->	O
csp	pointer
->	O
lock_mode	enum
;	O
}	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__bam_isopd	function
(	O
dbc	pointer
,	O
pgnop	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
db_pgno_t	int
*	O
pgnop	pointer
;	O
{	O
BOVERFLOW	struct
*	O
bo	pointer
;	O
if	O
(	O
TYPE	O
(	O
dbc	pointer
->	O
internal	pointer
->	O
page	pointer
)	O
!=	O
P_LBTREE	int
)	O
return	O
(	O
0	int
)	O
;	O
bo	pointer
=	O
GET_BOVERFLOW	O
(	O
dbc	pointer
->	O
internal	pointer
->	O
page	pointer
,	O
dbc	pointer
->	O
internal	pointer
->	O
indx	short
+	O
O_INDX	int
)	O
;	O
if	O
(	O
B_TYPE	O
(	O
bo	pointer
->	O
type	enum
)	O
==	O
B_DUPLICATE	int
)	O
{	O
*	O
pgnop	pointer
=	O
bo	pointer
->	O
pgno	int
;	O
return	O
(	O
1	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
