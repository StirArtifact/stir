const	O
char	O
*	O
make_format_description_string	function
(	O
enum	O
is_format	enum
is_format	enum
,	O
const	O
char	O
*	O
lang	pointer
,	O
bool	bool
debug	bool
)	O
{	O
static	O
char	O
result	pointer
[	O
100	int
]	O
;	O
switch	O
(	O
is_format	enum
)	O
{	O
case	O
possible	int
:	O
if	O
(	O
debug	bool
)	O
{	O
sprintf	function
(	O
result	pointer
,	O
"possible-%s-format"	pointer
,	O
lang	pointer
)	O
;	O
break	O
;	O
}	O
case	O
yes_according_to_context	int
:	O
case	O
yes	int
:	O
sprintf	function
(	O
result	pointer
,	O
"%s-format"	pointer
,	O
lang	pointer
)	O
;	O
break	O
;	O
case	O
no	int
:	O
sprintf	function
(	O
result	pointer
,	O
"no-%s-format"	pointer
,	O
lang	pointer
)	O
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
return	O
result	pointer
;	O
}	O
bool	bool
significant_format_p	function
(	O
enum	O
is_format	enum
is_format	enum
)	O
{	O
return	O
is_format	enum
!=	O
undecided	int
&&	O
is_format	enum
!=	O
impossible	int
;	O
}	O
static	O
bool	bool
has_significant_format_p	function
(	O
const	O
enum	O
is_format	enum
is_format	enum
[	O
NFORMATS	int
]	O
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
NFORMATS	int
;	O
i	long
++	O
)	O
if	O
(	O
significant_format_p	function
(	O
is_format	enum
[	O
i	long
]	O
)	O
)	O
return	O
true	int
;	O
return	O
false	int
;	O
}	O
char	O
*	O
make_range_description_string	function
(	O
struct	O
argument_range	struct
range	struct
)	O
{	O
return	O
xasprintf	function
(	O
"range: %d..%d"	pointer
,	O
range	struct
.	O
min	int
,	O
range	struct
.	O
max	int
)	O
;	O
}	O
static	O
const	O
char	O
*	O
make_c_width_description_string	function
(	O
enum	O
is_wrap	O
do_wrap	enum
)	O
{	O
const	O
char	O
*	O
result	pointer
=	O
NULL	O
;	O
switch	O
(	O
do_wrap	enum
)	O
{	O
case	O
yes	int
:	O
result	pointer
=	O
"wrap"	pointer
;	O
break	O
;	O
case	O
no	int
:	O
result	pointer
=	O
"no-wrap"	pointer
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
return	O
result	pointer
;	O
}	O
static	O
inline	O
void	O
begin_css_class	function
(	O
ostream_t	pointer
stream	pointer
,	O
const	O
char	O
*	O
classname	pointer
)	O
{	O
styled_ostream_begin_use_class	function
(	O
(	O
styled_ostream_t	pointer
)	O
stream	pointer
,	O
classname	pointer
)	O
;	O
}	O
static	O
inline	O
void	O
end_css_class	function
(	O
ostream_t	pointer
stream	pointer
,	O
const	O
char	O
*	O
classname	pointer
)	O
{	O
styled_ostream_end_use_class	function
(	O
(	O
styled_ostream_t	pointer
)	O
stream	pointer
,	O
classname	pointer
)	O
;	O
}	O
static	O
const	O
char	O
class_header	array
[	O
]	O
=	O
"header"	pointer
;	O
static	O
const	O
char	O
class_translated	array
[	O
]	O
=	O
"translated"	pointer
;	O
static	O
const	O
char	O
class_untranslated	array
[	O
]	O
=	O
"untranslated"	pointer
;	O
static	O
const	O
char	O
class_fuzzy	array
[	O
]	O
=	O
"fuzzy"	pointer
;	O
static	O
const	O
char	O
class_obsolete	array
[	O
]	O
=	O
"obsolete"	pointer
;	O
static	O
const	O
char	O
class_comment	array
[	O
]	O
=	O
"comment"	pointer
;	O
static	O
const	O
char	O
class_translator_comment	array
[	O
]	O
=	O
"translator-comment"	pointer
;	O
static	O
const	O
char	O
class_extracted_comment	array
[	O
]	O
=	O
"extracted-comment"	pointer
;	O
static	O
const	O
char	O
class_reference_comment	array
[	O
]	O
=	O
"reference-comment"	pointer
;	O
static	O
const	O
char	O
class_reference	array
[	O
]	O
=	O
"reference"	pointer
;	O
static	O
const	O
char	O
class_flag_comment	array
[	O
]	O
=	O
"flag-comment"	pointer
;	O
static	O
const	O
char	O
class_flag	array
[	O
]	O
=	O
"flag"	pointer
;	O
static	O
const	O
char	O
class_fuzzy_flag	array
[	O
]	O
=	O
"fuzzy-flag"	pointer
;	O
static	O
const	O
char	O
class_previous_comment	array
[	O
]	O
=	O
"previous-comment"	pointer
;	O
static	O
const	O
char	O
class_previous	array
[	O
]	O
=	O
"previous"	pointer
;	O
static	O
const	O
char	O
class_msgid	array
[	O
]	O
=	O
"msgid"	pointer
;	O
static	O
const	O
char	O
class_msgstr	array
[	O
]	O
=	O
"msgstr"	pointer
;	O
static	O
const	O
char	O
class_keyword	array
[	O
]	O
=	O
"keyword"	pointer
;	O
static	O
const	O
char	O
class_string	array
[	O
]	O
=	O
"string"	pointer
;	O
static	O
const	O
char	O
class_text	array
[	O
]	O
=	O
"text"	pointer
;	O
static	O
const	O
char	O
class_escape_sequence	array
[	O
]	O
=	O
"escape-sequence"	pointer
;	O
static	O
const	O
char	O
class_format_directive	array
[	O
]	O
=	O
"format-directive"	pointer
;	O
static	O
const	O
char	O
class_invalid_format_directive	array
[	O
]	O
=	O
"invalid-format-directive"	pointer
;	O
enum	O
{	O
ATTR_ESCAPE_SEQUENCE	int
=	O
1	int
<<	O
0	int
,	O
ATTR_FORMAT_DIRECTIVE	int
=	O
1	int
<<	O
1	int
,	O
ATTR_INVALID_FORMAT_DIRECTIVE	int
=	O
1	int
<<	O
2	int
}	O
;	O
static	O
bool	bool
print_comment	bool
=	O
true	int
;	O
void	O
message_print_style_comment	function
(	O
bool	bool
flag	bool
)	O
{	O
print_comment	bool
=	O
flag	bool
;	O
}	O
void	O
message_print_comment	function
(	O
const	O
message_ty	struct
*	O
mp	pointer
,	O
ostream_t	pointer
stream	pointer
)	O
{	O
if	O
(	O
print_comment	bool
&&	O
mp	pointer
->	O
comment	pointer
!=	O
NULL	O
)	O
{	O
size_t	long
j	long
;	O
begin_css_class	function
(	O
stream	pointer
,	O
class_translator_comment	array
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
mp	pointer
->	O
comment	pointer
->	O
nitems	long
;	O
++	O
j	long
)	O
{	O
const	O
char	O
*	O
s	pointer
=	O
mp	pointer
->	O
comment	pointer
->	O
item	pointer
[	O
j	long
]	O
;	O
do	O
{	O
const	O
char	O
*	O
e	pointer
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
"#"	pointer
)	O
;	O
if	O
(	O
*	O
s	pointer
!=	O
'\0'	O
)	O
ostream_write_str	function
(	O
stream	pointer
,	O
" "	pointer
)	O
;	O
e	pointer
=	O
strchr	function
(	O
s	pointer
,	O
'\n'	O
)	O
;	O
if	O
(	O
e	pointer
==	O
NULL	O
)	O
{	O
ostream_write_str	function
(	O
stream	pointer
,	O
s	pointer
)	O
;	O
s	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
ostream_write_mem	function
(	O
stream	pointer
,	O
s	pointer
,	O
e	pointer
-	O
s	pointer
)	O
;	O
s	pointer
=	O
e	pointer
+	O
1	int
;	O
}	O
ostream_write_str	function
(	O
stream	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
while	O
(	O
s	pointer
!=	O
NULL	O
)	O
;	O
}	O
end_css_class	function
(	O
stream	pointer
,	O
class_translator_comment	array
)	O
;	O
}	O
}	O
void	O
message_print_comment_dot	function
(	O
const	O
message_ty	struct
*	O
mp	pointer
,	O
ostream_t	pointer
stream	pointer
)	O
{	O
if	O
(	O
mp	pointer
->	O
comment_dot	pointer
!=	O
NULL	O
)	O
{	O
size_t	long
j	long
;	O
begin_css_class	function
(	O
stream	pointer
,	O
class_extracted_comment	array
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
mp	pointer
->	O
comment_dot	pointer
->	O
nitems	long
;	O
++	O
j	long
)	O
{	O
const	O
char	O
*	O
s	pointer
=	O
mp	pointer
->	O
comment_dot	pointer
->	O
item	pointer
[	O
j	long
]	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
"#."	pointer
)	O
;	O
if	O
(	O
*	O
s	pointer
!=	O
'\0'	O
)	O
ostream_write_str	function
(	O
stream	pointer
,	O
" "	pointer
)	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
s	pointer
)	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
end_css_class	function
(	O
stream	pointer
,	O
class_extracted_comment	array
)	O
;	O
}	O
}	O
static	O
enum	O
filepos_comment_type	enum
filepos_comment_type	enum
=	O
filepos_comment_full	int
;	O
void	O
message_print_comment_filepos	function
(	O
const	O
message_ty	struct
*	O
mp	pointer
,	O
ostream_t	pointer
stream	pointer
,	O
bool	bool
uniforum	bool
,	O
size_t	long
page_width	long
)	O
{	O
if	O
(	O
filepos_comment_type	enum
!=	O
filepos_comment_none	int
&&	O
mp	pointer
->	O
filepos_count	long
!=	O
0	int
)	O
{	O
size_t	long
filepos_count	long
;	O
lex_pos_ty	struct
*	O
filepos	pointer
;	O
begin_css_class	function
(	O
stream	pointer
,	O
class_reference_comment	array
)	O
;	O
if	O
(	O
filepos_comment_type	enum
==	O
filepos_comment_file	int
)	O
{	O
size_t	long
i	long
;	O
filepos_count	long
=	O
0	int
;	O
filepos	pointer
=	O
XNMALLOC	O
(	O
mp	pointer
->	O
filepos_count	long
,	O
lex_pos_ty	struct
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
mp	pointer
->	O
filepos_count	long
;	O
++	O
i	long
)	O
{	O
lex_pos_ty	struct
*	O
pp	pointer
=	O
&	O
mp	pointer
->	O
filepos	pointer
[	O
i	long
]	O
;	O
size_t	long
j	long
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
filepos_count	long
;	O
j	long
++	O
)	O
if	O
(	O
strcmp	function
(	O
filepos	pointer
[	O
j	long
]	O
.	O
file_name	pointer
,	O
pp	pointer
->	O
file_name	pointer
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
j	long
==	O
filepos_count	long
)	O
{	O
filepos	pointer
[	O
filepos_count	long
]	O
.	O
file_name	pointer
=	O
pp	pointer
->	O
file_name	pointer
;	O
filepos	pointer
[	O
filepos_count	long
]	O
.	O
line_number	long
=	O
(	O
size_t	long
)	O
-	O
1	int
;	O
filepos_count	long
++	O
;	O
}	O
}	O
}	O
else	O
{	O
filepos	pointer
=	O
mp	pointer
->	O
filepos	pointer
;	O
filepos_count	long
=	O
mp	pointer
->	O
filepos_count	long
;	O
}	O
if	O
(	O
uniforum	bool
)	O
{	O
size_t	long
j	long
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
filepos_count	long
;	O
++	O
j	long
)	O
{	O
lex_pos_ty	struct
*	O
pp	pointer
=	O
&	O
filepos	pointer
[	O
j	long
]	O
;	O
const	O
char	O
*	O
cp	pointer
=	O
pp	pointer
->	O
file_name	pointer
;	O
char	O
*	O
str	pointer
;	O
while	O
(	O
cp	pointer
[	O
0	int
]	O
==	O
'.'	O
&&	O
cp	pointer
[	O
1	int
]	O
==	O
'/'	O
)	O
cp	pointer
+=	O
2	int
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
"# "	pointer
)	O
;	O
begin_css_class	function
(	O
stream	pointer
,	O
class_reference	array
)	O
;	O
str	pointer
=	O
xasprintf	function
(	O
"File: %s, line: %ld"	pointer
,	O
cp	pointer
,	O
(	O
long	O
)	O
pp	pointer
->	O
line_number	long
)	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
str	pointer
)	O
;	O
end_css_class	function
(	O
stream	pointer
,	O
class_reference	array
)	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
"\n"	pointer
)	O
;	O
free	function
(	O
str	pointer
)	O
;	O
}	O
}	O
else	O
{	O
size_t	long
column	long
;	O
size_t	long
j	long
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
"#:"	pointer
)	O
;	O
column	long
=	O
2	int
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
filepos_count	long
;	O
++	O
j	long
)	O
{	O
lex_pos_ty	struct
*	O
pp	pointer
;	O
char	O
buffer	array
[	O
21	int
]	O
;	O
const	O
char	O
*	O
cp	pointer
;	O
size_t	long
len	long
;	O
pp	pointer
=	O
&	O
filepos	pointer
[	O
j	long
]	O
;	O
cp	pointer
=	O
pp	pointer
->	O
file_name	pointer
;	O
while	O
(	O
cp	pointer
[	O
0	int
]	O
==	O
'.'	O
&&	O
cp	pointer
[	O
1	int
]	O
==	O
'/'	O
)	O
cp	pointer
+=	O
2	int
;	O
if	O
(	O
filepos_comment_type	enum
==	O
filepos_comment_file	int
||	O
pp	pointer
->	O
line_number	long
==	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
)	O
buffer	array
[	O
0	int
]	O
=	O
'\0'	O
;	O
else	O
sprintf	function
(	O
buffer	array
,	O
":%ld"	pointer
,	O
(	O
long	O
)	O
pp	pointer
->	O
line_number	long
)	O
;	O
len	long
=	O
strlen	function
(	O
cp	pointer
)	O
+	O
strlen	function
(	O
buffer	array
)	O
+	O
1	int
;	O
if	O
(	O
column	long
>	O
2	int
&&	O
column	long
+	O
len	long
>	O
page_width	long
)	O
{	O
ostream_write_str	function
(	O
stream	pointer
,	O
"\n#:"	pointer
)	O
;	O
column	long
=	O
2	int
;	O
}	O
ostream_write_str	function
(	O
stream	pointer
,	O
" "	pointer
)	O
;	O
begin_css_class	function
(	O
stream	pointer
,	O
class_reference	array
)	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
cp	pointer
)	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
buffer	array
)	O
;	O
end_css_class	function
(	O
stream	pointer
,	O
class_reference	array
)	O
;	O
column	long
+=	O
len	long
;	O
}	O
ostream_write_str	function
(	O
stream	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
if	O
(	O
filepos	pointer
!=	O
mp	pointer
->	O
filepos	pointer
)	O
free	function
(	O
filepos	pointer
)	O
;	O
end_css_class	function
(	O
stream	pointer
,	O
class_reference_comment	array
)	O
;	O
}	O
}	O
void	O
message_print_comment_flags	function
(	O
const	O
message_ty	struct
*	O
mp	pointer
,	O
ostream_t	pointer
stream	pointer
,	O
bool	bool
debug	bool
)	O
{	O
if	O
(	O
(	O
mp	pointer
->	O
is_fuzzy	bool
&&	O
mp	pointer
->	O
msgstr	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
||	O
has_significant_format_p	function
(	O
mp	pointer
->	O
is_format	enum
)	O
||	O
has_range_p	O
(	O
mp	pointer
->	O
range	struct
)	O
||	O
mp	pointer
->	O
do_wrap	enum
==	O
no	int
)	O
{	O
bool	bool
first_flag	bool
=	O
true	int
;	O
size_t	long
i	long
;	O
begin_css_class	function
(	O
stream	pointer
,	O
class_flag_comment	array
)	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
"#,"	pointer
)	O
;	O
if	O
(	O
mp	pointer
->	O
is_fuzzy	bool
&&	O
mp	pointer
->	O
msgstr	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
ostream_write_str	function
(	O
stream	pointer
,	O
" "	pointer
)	O
;	O
begin_css_class	function
(	O
stream	pointer
,	O
class_flag	array
)	O
;	O
begin_css_class	function
(	O
stream	pointer
,	O
class_fuzzy_flag	array
)	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
"fuzzy"	pointer
)	O
;	O
end_css_class	function
(	O
stream	pointer
,	O
class_fuzzy_flag	array
)	O
;	O
end_css_class	function
(	O
stream	pointer
,	O
class_flag	array
)	O
;	O
first_flag	bool
=	O
false	int
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
NFORMATS	int
;	O
i	long
++	O
)	O
if	O
(	O
significant_format_p	function
(	O
mp	pointer
->	O
is_format	enum
[	O
i	long
]	O
)	O
)	O
{	O
if	O
(	O
!	O
first_flag	bool
)	O
ostream_write_str	function
(	O
stream	pointer
,	O
","	pointer
)	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
" "	pointer
)	O
;	O
begin_css_class	function
(	O
stream	pointer
,	O
class_flag	array
)	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
make_format_description_string	function
(	O
mp	pointer
->	O
is_format	enum
[	O
i	long
]	O
,	O
format_language	array
[	O
i	long
]	O
,	O
debug	bool
)	O
)	O
;	O
end_css_class	function
(	O
stream	pointer
,	O
class_flag	array
)	O
;	O
first_flag	bool
=	O
false	int
;	O
}	O
if	O
(	O
has_range_p	O
(	O
mp	pointer
->	O
range	struct
)	O
)	O
{	O
char	O
*	O
string	pointer
;	O
if	O
(	O
!	O
first_flag	bool
)	O
ostream_write_str	function
(	O
stream	pointer
,	O
","	pointer
)	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
" "	pointer
)	O
;	O
begin_css_class	function
(	O
stream	pointer
,	O
class_flag	array
)	O
;	O
string	pointer
=	O
make_range_description_string	function
(	O
mp	pointer
->	O
range	struct
)	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
string	pointer
)	O
;	O
free	function
(	O
string	pointer
)	O
;	O
end_css_class	function
(	O
stream	pointer
,	O
class_flag	array
)	O
;	O
first_flag	bool
=	O
false	int
;	O
}	O
if	O
(	O
mp	pointer
->	O
do_wrap	enum
==	O
no	int
)	O
{	O
if	O
(	O
!	O
first_flag	bool
)	O
ostream_write_str	function
(	O
stream	pointer
,	O
","	pointer
)	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
" "	pointer
)	O
;	O
begin_css_class	function
(	O
stream	pointer
,	O
class_flag	array
)	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
make_c_width_description_string	function
(	O
mp	pointer
->	O
do_wrap	enum
)	O
)	O
;	O
end_css_class	function
(	O
stream	pointer
,	O
class_flag	array
)	O
;	O
first_flag	bool
=	O
false	int
;	O
}	O
ostream_write_str	function
(	O
stream	pointer
,	O
"\n"	pointer
)	O
;	O
end_css_class	function
(	O
stream	pointer
,	O
class_flag_comment	array
)	O
;	O
}	O
}	O
static	O
bool	bool
wrap_strings	bool
=	O
true	int
;	O
void	O
message_page_width_ignore	function
(	O
)	O
{	O
wrap_strings	bool
=	O
false	int
;	O
}	O
static	O
bool	bool
indent	bool
=	O
false	int
;	O
static	O
bool	bool
uniforum	bool
=	O
false	int
;	O
static	O
bool	bool
escape	bool
=	O
false	int
;	O
void	O
message_print_style_indent	function
(	O
)	O
{	O
indent	bool
=	O
true	int
;	O
}	O
void	O
message_print_style_uniforum	function
(	O
)	O
{	O
uniforum	bool
=	O
true	int
;	O
}	O
void	O
message_print_style_escape	function
(	O
bool	bool
flag	bool
)	O
{	O
escape	bool
=	O
flag	bool
;	O
}	O
void	O
message_print_style_filepos	function
(	O
enum	O
filepos_comment_type	enum
type	enum
)	O
{	O
filepos_comment_type	enum
=	O
type	enum
;	O
}	O
bool	bool
handle_filepos_comment_option	function
(	O
const	O
char	O
*	O
option	pointer
)	O
{	O
if	O
(	O
option	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
option	pointer
,	O
"never"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
option	pointer
,	O
"no"	pointer
)	O
==	O
0	int
)	O
message_print_style_filepos	function
(	O
filepos_comment_none	int
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
option	pointer
,	O
"full"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
option	pointer
,	O
"yes"	pointer
)	O
==	O
0	int
)	O
message_print_style_filepos	function
(	O
filepos_comment_full	int
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
option	pointer
,	O
"file"	pointer
)	O
==	O
0	int
)	O
message_print_style_filepos	function
(	O
filepos_comment_file	int
)	O
;	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"invalid --add-location argument: %s\n"	pointer
,	O
option	pointer
)	O
;	O
return	O
true	int
;	O
}	O
}	O
else	O
message_print_style_filepos	function
(	O
filepos_comment_full	int
)	O
;	O
return	O
false	int
;	O
}	O
static	O
inline	O
void	O
memcpy_small	function
(	O
void	O
*	O
dst	pointer
,	O
const	O
void	O
*	O
src	pointer
,	O
size_t	long
n	long
)	O
{	O
if	O
(	O
n	long
>	O
0	int
)	O
{	O
char	O
*	O
q	pointer
=	O
(	O
char	O
*	O
)	O
dst	pointer
;	O
const	O
char	O
*	O
p	pointer
=	O
(	O
const	O
char	O
*	O
)	O
src	pointer
;	O
*	O
q	pointer
=	O
*	O
p	pointer
;	O
if	O
(	O
--	O
n	long
>	O
0	int
)	O
do	O
*	O
++	O
q	pointer
=	O
*	O
++	O
p	pointer
;	O
while	O
(	O
--	O
n	long
>	O
0	int
)	O
;	O
}	O
}	O
static	O
inline	O
void	O
memset_small	function
(	O
void	O
*	O
dst	pointer
,	O
char	O
c	int
,	O
size_t	long
n	long
)	O
{	O
if	O
(	O
n	long
>	O
0	int
)	O
{	O
char	O
*	O
p	pointer
=	O
(	O
char	O
*	O
)	O
dst	pointer
;	O
*	O
p	pointer
=	O
c	int
;	O
if	O
(	O
--	O
n	long
>	O
0	int
)	O
do	O
*	O
++	O
p	pointer
=	O
c	int
;	O
while	O
(	O
--	O
n	long
>	O
0	int
)	O
;	O
}	O
}	O
static	O
void	O
wrap	function
(	O
const	O
message_ty	struct
*	O
mp	pointer
,	O
ostream_t	pointer
stream	pointer
,	O
const	O
char	O
*	O
line_prefix	pointer
,	O
int	O
extra_indent	int
,	O
const	O
char	O
*	O
css_class	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
const	O
char	O
*	O
value	pointer
,	O
enum	O
is_wrap	O
do_wrap	enum
,	O
size_t	long
page_width	long
,	O
const	O
char	O
*	O
charset	pointer
)	O
{	O
const	O
char	O
*	O
canon_charset	pointer
;	O
char	O
*	O
fmtdir	pointer
;	O
char	O
*	O
fmtdirattr	pointer
;	O
const	O
char	O
*	O
s	pointer
;	O
bool	bool
first_line	bool
;	O
const	O
char	O
*	O
envval	pointer
;	O
iconv_t	pointer
conv	pointer
;	O
bool	bool
weird_cjk	bool
;	O
canon_charset	pointer
=	O
po_charset_canonicalize	function
(	O
charset	pointer
)	O
;	O
envval	pointer
=	O
getenv	function
(	O
"OLD_PO_FILE_OUTPUT"	pointer
)	O
;	O
if	O
(	O
envval	pointer
!=	O
NULL	O
&&	O
*	O
envval	pointer
!=	O
'\0'	O
)	O
conv	pointer
=	O
(	O
iconv_t	pointer
)	O
(	O
-	O
1	int
)	O
;	O
else	O
if	O
(	O
canon_charset	pointer
==	O
NULL	O
)	O
conv	pointer
=	O
(	O
iconv_t	pointer
)	O
(	O
-	O
1	int
)	O
;	O
else	O
conv	pointer
=	O
iconv_open	function
(	O
"UTF-8"	pointer
,	O
canon_charset	pointer
)	O
;	O
if	O
(	O
conv	pointer
!=	O
(	O
iconv_t	pointer
)	O
(	O
-	O
1	int
)	O
)	O
weird_cjk	bool
=	O
false	int
;	O
else	O
if	O
(	O
canon_charset	pointer
==	O
NULL	O
)	O
weird_cjk	bool
=	O
false	int
;	O
else	O
weird_cjk	bool
=	O
po_is_charset_weird_cjk	function
(	O
canon_charset	pointer
)	O
;	O
if	O
(	O
canon_charset	pointer
==	O
NULL	O
)	O
canon_charset	pointer
=	O
po_charset_ascii	pointer
;	O
fmtdir	pointer
=	O
NULL	O
;	O
fmtdirattr	pointer
=	O
NULL	O
;	O
if	O
(	O
value	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
bool	bool
is_msgstr	bool
=	O
(	O
strlen	function
(	O
name	pointer
)	O
>=	O
6	int
&&	O
memcmp	function
(	O
name	pointer
,	O
"msgstr"	pointer
,	O
6	int
)	O
==	O
0	int
)	O
;	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
NFORMATS	int
;	O
i	long
++	O
)	O
if	O
(	O
possible_format_p	function
(	O
mp	pointer
->	O
is_format	enum
[	O
i	long
]	O
)	O
)	O
{	O
size_t	long
len	long
=	O
strlen	function
(	O
value	pointer
)	O
;	O
struct	O
formatstring_parser	struct
*	O
parser	pointer
=	O
formatstring_parsers	array
[	O
i	long
]	O
;	O
char	O
*	O
invalid_reason	pointer
=	O
NULL	O
;	O
void	O
*	O
descr	pointer
;	O
const	O
char	O
*	O
fdp	pointer
;	O
const	O
char	O
*	O
fd_end	pointer
;	O
char	O
*	O
fdap	pointer
;	O
fmtdir	pointer
=	O
XCALLOC	O
(	O
len	long
,	O
char	O
)	O
;	O
descr	pointer
=	O
parser	pointer
->	O
parse	pointer
(	O
value	pointer
,	O
is_msgstr	bool
,	O
fmtdir	pointer
,	O
&	O
invalid_reason	pointer
)	O
;	O
if	O
(	O
descr	pointer
!=	O
NULL	O
)	O
parser	pointer
->	O
free	function
(	O
descr	pointer
)	O
;	O
fmtdirattr	pointer
=	O
XCALLOC	O
(	O
len	long
,	O
char	O
)	O
;	O
fd_end	pointer
=	O
fmtdir	pointer
+	O
len	long
;	O
for	O
(	O
fdp	pointer
=	O
fmtdir	pointer
,	O
fdap	pointer
=	O
fmtdirattr	pointer
;	O
fdp	pointer
<	O
fd_end	pointer
;	O
fdp	pointer
++	O
,	O
fdap	pointer
++	O
)	O
if	O
(	O
*	O
fdp	pointer
&	O
FMTDIR_START	int
)	O
{	O
const	O
char	O
*	O
fdq	pointer
;	O
for	O
(	O
fdq	pointer
=	O
fdp	pointer
;	O
fdq	pointer
<	O
fd_end	pointer
;	O
fdq	pointer
++	O
)	O
if	O
(	O
*	O
fdq	pointer
&	O
(	O
FMTDIR_END	int
|	O
FMTDIR_ERROR	int
)	O
)	O
break	O
;	O
if	O
(	O
!	O
(	O
fdq	pointer
<	O
fd_end	pointer
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
*	O
fdq	pointer
&	O
FMTDIR_ERROR	int
)	O
memset	function
(	O
fdap	pointer
,	O
ATTR_INVALID_FORMAT_DIRECTIVE	int
,	O
fdq	pointer
-	O
fdp	pointer
+	O
1	int
)	O
;	O
else	O
memset	function
(	O
fdap	pointer
,	O
ATTR_FORMAT_DIRECTIVE	int
,	O
fdq	pointer
-	O
fdp	pointer
+	O
1	int
)	O
;	O
fdap	pointer
+=	O
fdq	pointer
-	O
fdp	pointer
;	O
fdp	pointer
=	O
fdq	pointer
;	O
}	O
else	O
*	O
fdap	pointer
=	O
0	int
;	O
break	O
;	O
}	O
}	O
s	pointer
=	O
value	pointer
;	O
first_line	bool
=	O
true	int
;	O
do	O
{	O
const	O
char	O
*	O
es	pointer
;	O
const	O
char	O
*	O
ep	pointer
;	O
size_t	long
portion_len	long
;	O
char	O
*	O
portion	pointer
;	O
char	O
*	O
overrides	pointer
;	O
char	O
*	O
attributes	pointer
;	O
char	O
*	O
linebreaks	pointer
;	O
char	O
*	O
pp	pointer
;	O
char	O
*	O
op	pointer
;	O
char	O
*	O
ap	pointer
;	O
int	O
startcol	int
,	O
startcol_after_break	int
,	O
width	int
;	O
size_t	long
i	long
;	O
for	O
(	O
es	pointer
=	O
s	pointer
;	O
*	O
es	pointer
!=	O
'\0'	O
;	O
)	O
if	O
(	O
*	O
es	pointer
++	O
==	O
'\n'	O
)	O
break	O
;	O
for	O
(	O
ep	pointer
=	O
s	pointer
,	O
portion_len	long
=	O
0	int
;	O
ep	pointer
<	O
es	pointer
;	O
ep	pointer
++	O
)	O
{	O
char	O
c	int
=	O
*	O
ep	pointer
;	O
if	O
(	O
is_escape	O
(	O
c	int
)	O
)	O
portion_len	long
+=	O
2	int
;	O
else	O
if	O
(	O
escape	bool
&&	O
!	O
c_isprint	function
(	O
(	O
unsigned	O
char	O
)	O
c	int
)	O
)	O
portion_len	long
+=	O
4	int
;	O
else	O
if	O
(	O
c	int
==	O
'\\'	O
||	O
c	int
==	O
'"'	O
)	O
portion_len	long
+=	O
2	int
;	O
else	O
{	O
if	O
(	O
conv	pointer
!=	O
(	O
iconv_t	pointer
)	O
(	O
-	O
1	int
)	O
)	O
{	O
char	O
scratchbuf	array
[	O
64	int
]	O
;	O
const	O
char	O
*	O
inptr	pointer
=	O
ep	pointer
;	O
size_t	long
insize	long
;	O
char	O
*	O
outptr	pointer
=	O
&	O
scratchbuf	array
[	O
0	int
]	O
;	O
size_t	long
outsize	long
=	O
sizeof	O
(	O
scratchbuf	array
)	O
;	O
size_t	long
res	pointer
;	O
res	pointer
=	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
;	O
for	O
(	O
insize	long
=	O
1	int
;	O
inptr	pointer
+	O
insize	long
<=	O
es	pointer
;	O
insize	long
++	O
)	O
{	O
res	pointer
=	O
iconv	function
(	O
conv	pointer
,	O
(	O
ICONV_CONST	O
char	O
*	O
*	O
)	O
&	O
inptr	pointer
,	O
&	O
insize	long
,	O
&	O
outptr	pointer
,	O
&	O
outsize	long
)	O
;	O
if	O
(	O
!	O
(	O
res	pointer
==	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
&&	O
errno	O
==	O
EINVAL	int
)	O
)	O
break	O
;	O
if	O
(	O
inptr	pointer
!=	O
ep	pointer
)	O
abort	function
(	O
)	O
;	O
}	O
if	O
(	O
res	pointer
==	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
)	O
{	O
if	O
(	O
errno	O
==	O
EILSEQ	int
)	O
{	O
po_xerror	pointer
(	O
PO_SEVERITY_ERROR	int
,	O
mp	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	int
,	O
_	O
(	O
"invalid multibyte sequence"	pointer
)	O
)	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
errno	O
==	O
EINVAL	int
)	O
{	O
po_xerror	pointer
(	O
PO_SEVERITY_ERROR	int
,	O
mp	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	int
,	O
_	O
(	O
"incomplete multibyte sequence"	pointer
)	O
)	O
;	O
continue	O
;	O
}	O
else	O
abort	function
(	O
)	O
;	O
}	O
insize	long
=	O
inptr	pointer
-	O
ep	pointer
;	O
portion_len	long
+=	O
insize	long
;	O
ep	pointer
+=	O
insize	long
-	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
weird_cjk	bool
&&	O
ep	pointer
+	O
2	int
<=	O
es	pointer
&&	O
(	O
unsigned	O
char	O
)	O
ep	pointer
[	O
0	int
]	O
>=	O
0x80	int
&&	O
(	O
unsigned	O
char	O
)	O
ep	pointer
[	O
1	int
]	O
>=	O
0x30	int
)	O
{	O
portion_len	long
+=	O
2	int
;	O
ep	pointer
+=	O
1	int
;	O
}	O
else	O
portion_len	long
+=	O
1	int
;	O
}	O
}	O
}	O
portion	pointer
=	O
XNMALLOC	O
(	O
portion_len	long
,	O
char	O
)	O
;	O
overrides	pointer
=	O
XNMALLOC	O
(	O
portion_len	long
,	O
char	O
)	O
;	O
attributes	pointer
=	O
XNMALLOC	O
(	O
portion_len	long
,	O
char	O
)	O
;	O
for	O
(	O
ep	pointer
=	O
s	pointer
,	O
pp	pointer
=	O
portion	pointer
,	O
op	pointer
=	O
overrides	pointer
,	O
ap	pointer
=	O
attributes	pointer
;	O
ep	pointer
<	O
es	pointer
;	O
ep	pointer
++	O
)	O
{	O
char	O
c	int
=	O
*	O
ep	pointer
;	O
char	O
attr	char
=	O
(	O
fmtdirattr	pointer
!=	O
NULL	O
?	O
fmtdirattr	pointer
[	O
ep	pointer
-	O
value	pointer
]	O
:	O
0	int
)	O
;	O
char	O
brk	char
=	O
UC_BREAK_UNDEFINED	int
;	O
if	O
(	O
attr	char
==	O
ATTR_FORMAT_DIRECTIVE	int
&&	O
(	O
fmtdir	pointer
[	O
ep	pointer
-	O
value	pointer
]	O
&	O
FMTDIR_START	int
)	O
==	O
0	int
)	O
brk	char
=	O
UC_BREAK_PROHIBITED	int
;	O
if	O
(	O
is_escape	O
(	O
c	int
)	O
)	O
{	O
switch	O
(	O
c	int
)	O
{	O
case	O
'\a'	O
:	O
c	int
=	O
'a'	O
;	O
break	O
;	O
case	O
'\b'	O
:	O
c	int
=	O
'b'	O
;	O
break	O
;	O
case	O
'\f'	O
:	O
c	int
=	O
'f'	O
;	O
break	O
;	O
case	O
'\n'	O
:	O
c	int
=	O
'n'	O
;	O
break	O
;	O
case	O
'\r'	O
:	O
c	int
=	O
'r'	O
;	O
break	O
;	O
case	O
'\t'	O
:	O
c	int
=	O
't'	O
;	O
break	O
;	O
case	O
'\v'	O
:	O
c	int
=	O
'v'	O
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
*	O
pp	pointer
++	O
=	O
'\\'	O
;	O
*	O
pp	pointer
++	O
=	O
c	int
;	O
*	O
op	pointer
++	O
=	O
brk	char
;	O
*	O
op	pointer
++	O
=	O
UC_BREAK_PROHIBITED	int
;	O
*	O
ap	pointer
++	O
=	O
attr	char
|	O
ATTR_ESCAPE_SEQUENCE	int
;	O
*	O
ap	pointer
++	O
=	O
attr	char
|	O
ATTR_ESCAPE_SEQUENCE	int
;	O
if	O
(	O
c	int
!=	O
'n'	O
&&	O
c	int
!=	O
't'	O
)	O
{	O
char	O
*	O
error_message	pointer
=	O
xasprintf	function
(	O
_	O
(	O
"internationalized messages should not contain the '\\%c' escape sequence"	pointer
)	O
,	O
c	int
)	O
;	O
po_xerror	pointer
(	O
PO_SEVERITY_WARNING	int
,	O
mp	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	int
,	O
error_message	pointer
)	O
;	O
free	function
(	O
error_message	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
escape	bool
&&	O
!	O
c_isprint	function
(	O
(	O
unsigned	O
char	O
)	O
c	int
)	O
)	O
{	O
*	O
pp	pointer
++	O
=	O
'\\'	O
;	O
*	O
pp	pointer
++	O
=	O
'0'	O
+	O
(	O
(	O
(	O
unsigned	O
char	O
)	O
c	int
>>	O
6	int
)	O
&	O
7	int
)	O
;	O
*	O
pp	pointer
++	O
=	O
'0'	O
+	O
(	O
(	O
(	O
unsigned	O
char	O
)	O
c	int
>>	O
3	int
)	O
&	O
7	int
)	O
;	O
*	O
pp	pointer
++	O
=	O
'0'	O
+	O
(	O
(	O
unsigned	O
char	O
)	O
c	int
&	O
7	int
)	O
;	O
*	O
op	pointer
++	O
=	O
brk	char
;	O
*	O
op	pointer
++	O
=	O
UC_BREAK_PROHIBITED	int
;	O
*	O
op	pointer
++	O
=	O
UC_BREAK_PROHIBITED	int
;	O
*	O
op	pointer
++	O
=	O
UC_BREAK_PROHIBITED	int
;	O
*	O
ap	pointer
++	O
=	O
attr	char
|	O
ATTR_ESCAPE_SEQUENCE	int
;	O
*	O
ap	pointer
++	O
=	O
attr	char
|	O
ATTR_ESCAPE_SEQUENCE	int
;	O
*	O
ap	pointer
++	O
=	O
attr	char
|	O
ATTR_ESCAPE_SEQUENCE	int
;	O
*	O
ap	pointer
++	O
=	O
attr	char
|	O
ATTR_ESCAPE_SEQUENCE	int
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'\\'	O
||	O
c	int
==	O
'"'	O
)	O
{	O
*	O
pp	pointer
++	O
=	O
'\\'	O
;	O
*	O
pp	pointer
++	O
=	O
c	int
;	O
*	O
op	pointer
++	O
=	O
brk	char
;	O
*	O
op	pointer
++	O
=	O
UC_BREAK_PROHIBITED	int
;	O
*	O
ap	pointer
++	O
=	O
attr	char
|	O
ATTR_ESCAPE_SEQUENCE	int
;	O
*	O
ap	pointer
++	O
=	O
attr	char
|	O
ATTR_ESCAPE_SEQUENCE	int
;	O
}	O
else	O
{	O
if	O
(	O
conv	pointer
!=	O
(	O
iconv_t	pointer
)	O
(	O
-	O
1	int
)	O
)	O
{	O
char	O
scratchbuf	array
[	O
64	int
]	O
;	O
const	O
char	O
*	O
inptr	pointer
=	O
ep	pointer
;	O
size_t	long
insize	long
;	O
char	O
*	O
outptr	pointer
=	O
&	O
scratchbuf	array
[	O
0	int
]	O
;	O
size_t	long
outsize	long
=	O
sizeof	O
(	O
scratchbuf	array
)	O
;	O
size_t	long
res	pointer
;	O
res	pointer
=	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
;	O
for	O
(	O
insize	long
=	O
1	int
;	O
inptr	pointer
+	O
insize	long
<=	O
es	pointer
;	O
insize	long
++	O
)	O
{	O
res	pointer
=	O
iconv	function
(	O
conv	pointer
,	O
(	O
ICONV_CONST	O
char	O
*	O
*	O
)	O
&	O
inptr	pointer
,	O
&	O
insize	long
,	O
&	O
outptr	pointer
,	O
&	O
outsize	long
)	O
;	O
if	O
(	O
!	O
(	O
res	pointer
==	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
&&	O
errno	O
==	O
EINVAL	int
)	O
)	O
break	O
;	O
if	O
(	O
inptr	pointer
!=	O
ep	pointer
)	O
abort	function
(	O
)	O
;	O
}	O
if	O
(	O
res	pointer
==	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
)	O
{	O
if	O
(	O
errno	O
==	O
EILSEQ	int
)	O
{	O
po_xerror	pointer
(	O
PO_SEVERITY_ERROR	int
,	O
mp	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	int
,	O
_	O
(	O
"invalid multibyte sequence"	pointer
)	O
)	O
;	O
continue	O
;	O
}	O
else	O
abort	function
(	O
)	O
;	O
}	O
insize	long
=	O
inptr	pointer
-	O
ep	pointer
;	O
memcpy_small	function
(	O
pp	pointer
,	O
ep	pointer
,	O
insize	long
)	O
;	O
pp	pointer
+=	O
insize	long
;	O
*	O
op	pointer
=	O
brk	char
;	O
memset_small	function
(	O
op	pointer
+	O
1	int
,	O
UC_BREAK_PROHIBITED	int
,	O
insize	long
-	O
1	int
)	O
;	O
op	pointer
+=	O
insize	long
;	O
memset_small	function
(	O
ap	pointer
,	O
attr	char
,	O
insize	long
)	O
;	O
ap	pointer
+=	O
insize	long
;	O
ep	pointer
+=	O
insize	long
-	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
weird_cjk	bool
&&	O
ep	pointer
+	O
2	int
<=	O
es	pointer
&&	O
(	O
unsigned	O
char	O
)	O
c	int
>=	O
0x80	int
&&	O
(	O
unsigned	O
char	O
)	O
ep	pointer
[	O
1	int
]	O
>=	O
0x30	int
)	O
{	O
*	O
pp	pointer
++	O
=	O
c	int
;	O
ep	pointer
+=	O
1	int
;	O
*	O
pp	pointer
++	O
=	O
*	O
ep	pointer
;	O
*	O
op	pointer
++	O
=	O
brk	char
;	O
*	O
op	pointer
++	O
=	O
UC_BREAK_PROHIBITED	int
;	O
*	O
ap	pointer
++	O
=	O
attr	char
;	O
*	O
ap	pointer
++	O
=	O
attr	char
;	O
}	O
else	O
{	O
*	O
pp	pointer
++	O
=	O
c	int
;	O
*	O
op	pointer
++	O
=	O
brk	char
;	O
*	O
ap	pointer
++	O
=	O
attr	char
;	O
}	O
}	O
}	O
}	O
if	O
(	O
es	pointer
>	O
s	pointer
&&	O
es	pointer
[	O
-	O
1	int
]	O
==	O
'\n'	O
)	O
overrides	pointer
[	O
portion_len	long
-	O
2	int
]	O
=	O
UC_BREAK_PROHIBITED	int
;	O
linebreaks	pointer
=	O
XNMALLOC	O
(	O
portion_len	long
,	O
char	O
)	O
;	O
startcol_after_break	int
=	O
(	O
line_prefix	pointer
?	O
strlen	function
(	O
line_prefix	pointer
)	O
:	O
0	int
)	O
;	O
if	O
(	O
indent	bool
)	O
startcol_after_break	int
=	O
(	O
startcol_after_break	int
+	O
extra_indent	int
+	O
8	int
)	O
&	O
~	O
7	int
;	O
startcol_after_break	int
++	O
;	O
width	int
=	O
(	O
wrap_strings	bool
&&	O
do_wrap	enum
!=	O
no	int
?	O
page_width	long
:	O
INT_MAX	O
)	O
-	O
1	int
;	O
width	int
-=	O
startcol_after_break	int
;	O
recompute	O
:	O
startcol	int
=	O
(	O
line_prefix	pointer
?	O
strlen	function
(	O
line_prefix	pointer
)	O
:	O
0	int
)	O
;	O
if	O
(	O
first_line	bool
)	O
{	O
startcol	int
+=	O
strlen	function
(	O
name	pointer
)	O
;	O
if	O
(	O
indent	bool
)	O
startcol	int
=	O
(	O
startcol	int
+	O
extra_indent	int
+	O
8	int
)	O
&	O
~	O
7	int
;	O
else	O
startcol	int
++	O
;	O
}	O
else	O
{	O
if	O
(	O
indent	bool
)	O
startcol	int
=	O
(	O
startcol	int
+	O
extra_indent	int
+	O
8	int
)	O
&	O
~	O
7	int
;	O
}	O
startcol	int
++	O
;	O
startcol	int
-=	O
startcol_after_break	int
;	O
ulc_width_linebreaks	function
(	O
portion	pointer
,	O
portion_len	long
,	O
width	int
,	O
startcol	int
,	O
0	int
,	O
overrides	pointer
,	O
canon_charset	pointer
,	O
linebreaks	pointer
)	O
;	O
if	O
(	O
first_line	bool
&&	O
!	O
indent	bool
&&	O
portion_len	long
>	O
0	int
&&	O
(	O
*	O
es	pointer
!=	O
'\0'	O
||	O
startcol	int
>	O
width	int
||	O
memchr	function
(	O
linebreaks	pointer
,	O
UC_BREAK_POSSIBLE	int
,	O
portion_len	long
)	O
!=	O
NULL	O
)	O
)	O
{	O
if	O
(	O
line_prefix	pointer
!=	O
NULL	O
)	O
ostream_write_str	function
(	O
stream	pointer
,	O
line_prefix	pointer
)	O
;	O
begin_css_class	function
(	O
stream	pointer
,	O
css_class	pointer
)	O
;	O
begin_css_class	function
(	O
stream	pointer
,	O
class_keyword	array
)	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
name	pointer
)	O
;	O
end_css_class	function
(	O
stream	pointer
,	O
class_keyword	array
)	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
" "	pointer
)	O
;	O
begin_css_class	function
(	O
stream	pointer
,	O
class_string	array
)	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
"\"\""	pointer
)	O
;	O
end_css_class	function
(	O
stream	pointer
,	O
class_string	array
)	O
;	O
end_css_class	function
(	O
stream	pointer
,	O
css_class	pointer
)	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
"\n"	pointer
)	O
;	O
first_line	bool
=	O
false	int
;	O
goto	O
recompute	O
;	O
}	O
{	O
int	O
currcol	int
=	O
0	int
;	O
if	O
(	O
line_prefix	pointer
!=	O
NULL	O
)	O
{	O
ostream_write_str	function
(	O
stream	pointer
,	O
line_prefix	pointer
)	O
;	O
currcol	int
=	O
strlen	function
(	O
line_prefix	pointer
)	O
;	O
}	O
begin_css_class	function
(	O
stream	pointer
,	O
css_class	pointer
)	O
;	O
if	O
(	O
first_line	bool
)	O
{	O
begin_css_class	function
(	O
stream	pointer
,	O
class_keyword	array
)	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
name	pointer
)	O
;	O
currcol	int
+=	O
strlen	function
(	O
name	pointer
)	O
;	O
end_css_class	function
(	O
stream	pointer
,	O
class_keyword	array
)	O
;	O
if	O
(	O
indent	bool
)	O
{	O
if	O
(	O
extra_indent	int
>	O
0	int
)	O
ostream_write_mem	function
(	O
stream	pointer
,	O
"        "	pointer
,	O
extra_indent	int
)	O
;	O
currcol	int
+=	O
extra_indent	int
;	O
ostream_write_mem	function
(	O
stream	pointer
,	O
"        "	pointer
,	O
8	int
-	O
(	O
currcol	int
&	O
7	int
)	O
)	O
;	O
currcol	int
=	O
(	O
currcol	int
+	O
8	int
)	O
&	O
~	O
7	int
;	O
}	O
else	O
{	O
ostream_write_str	function
(	O
stream	pointer
,	O
" "	pointer
)	O
;	O
currcol	int
++	O
;	O
}	O
first_line	bool
=	O
false	int
;	O
}	O
else	O
{	O
if	O
(	O
indent	bool
)	O
{	O
if	O
(	O
extra_indent	int
>	O
0	int
)	O
ostream_write_mem	function
(	O
stream	pointer
,	O
"        "	pointer
,	O
extra_indent	int
)	O
;	O
currcol	int
+=	O
extra_indent	int
;	O
ostream_write_mem	function
(	O
stream	pointer
,	O
"        "	pointer
,	O
8	int
-	O
(	O
currcol	int
&	O
7	int
)	O
)	O
;	O
currcol	int
=	O
(	O
currcol	int
+	O
8	int
)	O
&	O
~	O
7	int
;	O
}	O
}	O
}	O
{	O
char	O
currattr	char
=	O
0	int
;	O
begin_css_class	function
(	O
stream	pointer
,	O
class_string	array
)	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
"\""	pointer
)	O
;	O
begin_css_class	function
(	O
stream	pointer
,	O
class_text	array
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
portion_len	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
linebreaks	pointer
[	O
i	long
]	O
==	O
UC_BREAK_POSSIBLE	int
)	O
{	O
int	O
currcol	int
;	O
if	O
(	O
currattr	char
&	O
ATTR_ESCAPE_SEQUENCE	int
)	O
{	O
end_css_class	function
(	O
stream	pointer
,	O
class_escape_sequence	array
)	O
;	O
currattr	char
&=	O
~	O
ATTR_ESCAPE_SEQUENCE	int
;	O
}	O
if	O
(	O
currattr	char
&	O
ATTR_FORMAT_DIRECTIVE	int
)	O
{	O
end_css_class	function
(	O
stream	pointer
,	O
class_format_directive	array
)	O
;	O
currattr	char
&=	O
~	O
ATTR_FORMAT_DIRECTIVE	int
;	O
}	O
else	O
if	O
(	O
currattr	char
&	O
ATTR_INVALID_FORMAT_DIRECTIVE	int
)	O
{	O
end_css_class	function
(	O
stream	pointer
,	O
class_invalid_format_directive	array
)	O
;	O
currattr	char
&=	O
~	O
ATTR_INVALID_FORMAT_DIRECTIVE	int
;	O
}	O
if	O
(	O
!	O
(	O
currattr	char
==	O
0	int
)	O
)	O
abort	function
(	O
)	O
;	O
end_css_class	function
(	O
stream	pointer
,	O
class_text	array
)	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
"\""	pointer
)	O
;	O
end_css_class	function
(	O
stream	pointer
,	O
class_string	array
)	O
;	O
end_css_class	function
(	O
stream	pointer
,	O
css_class	pointer
)	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
"\n"	pointer
)	O
;	O
currcol	int
=	O
0	int
;	O
if	O
(	O
line_prefix	pointer
!=	O
NULL	O
)	O
{	O
ostream_write_str	function
(	O
stream	pointer
,	O
line_prefix	pointer
)	O
;	O
currcol	int
=	O
strlen	function
(	O
line_prefix	pointer
)	O
;	O
}	O
begin_css_class	function
(	O
stream	pointer
,	O
css_class	pointer
)	O
;	O
if	O
(	O
indent	bool
)	O
{	O
ostream_write_mem	function
(	O
stream	pointer
,	O
"        "	pointer
,	O
8	int
-	O
(	O
currcol	int
&	O
7	int
)	O
)	O
;	O
currcol	int
=	O
(	O
currcol	int
+	O
8	int
)	O
&	O
~	O
7	int
;	O
}	O
begin_css_class	function
(	O
stream	pointer
,	O
class_string	array
)	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
"\""	pointer
)	O
;	O
begin_css_class	function
(	O
stream	pointer
,	O
class_text	array
)	O
;	O
}	O
if	O
(	O
attributes	pointer
[	O
i	long
]	O
!=	O
currattr	char
)	O
{	O
if	O
(	O
currattr	char
&	O
ATTR_ESCAPE_SEQUENCE	int
)	O
{	O
end_css_class	function
(	O
stream	pointer
,	O
class_escape_sequence	array
)	O
;	O
currattr	char
&=	O
~	O
ATTR_ESCAPE_SEQUENCE	int
;	O
}	O
if	O
(	O
~	O
attributes	pointer
[	O
i	long
]	O
&	O
currattr	char
&	O
ATTR_FORMAT_DIRECTIVE	int
)	O
{	O
end_css_class	function
(	O
stream	pointer
,	O
class_format_directive	array
)	O
;	O
currattr	char
&=	O
~	O
ATTR_FORMAT_DIRECTIVE	int
;	O
}	O
else	O
if	O
(	O
~	O
attributes	pointer
[	O
i	long
]	O
&	O
currattr	char
&	O
ATTR_INVALID_FORMAT_DIRECTIVE	int
)	O
{	O
end_css_class	function
(	O
stream	pointer
,	O
class_invalid_format_directive	array
)	O
;	O
currattr	char
&=	O
~	O
ATTR_INVALID_FORMAT_DIRECTIVE	int
;	O
}	O
if	O
(	O
attributes	pointer
[	O
i	long
]	O
&	O
~	O
currattr	char
&	O
ATTR_FORMAT_DIRECTIVE	int
)	O
{	O
begin_css_class	function
(	O
stream	pointer
,	O
class_format_directive	array
)	O
;	O
currattr	char
|=	O
ATTR_FORMAT_DIRECTIVE	int
;	O
}	O
else	O
if	O
(	O
attributes	pointer
[	O
i	long
]	O
&	O
~	O
currattr	char
&	O
ATTR_INVALID_FORMAT_DIRECTIVE	int
)	O
{	O
begin_css_class	function
(	O
stream	pointer
,	O
class_invalid_format_directive	array
)	O
;	O
currattr	char
|=	O
ATTR_INVALID_FORMAT_DIRECTIVE	int
;	O
}	O
if	O
(	O
attributes	pointer
[	O
i	long
]	O
&	O
~	O
currattr	char
&	O
ATTR_ESCAPE_SEQUENCE	int
)	O
{	O
begin_css_class	function
(	O
stream	pointer
,	O
class_escape_sequence	array
)	O
;	O
currattr	char
|=	O
ATTR_ESCAPE_SEQUENCE	int
;	O
}	O
}	O
ostream_write_mem	function
(	O
stream	pointer
,	O
&	O
portion	pointer
[	O
i	long
]	O
,	O
1	int
)	O
;	O
}	O
if	O
(	O
currattr	char
&	O
ATTR_ESCAPE_SEQUENCE	int
)	O
{	O
end_css_class	function
(	O
stream	pointer
,	O
class_escape_sequence	array
)	O
;	O
currattr	char
&=	O
~	O
ATTR_ESCAPE_SEQUENCE	int
;	O
}	O
if	O
(	O
currattr	char
&	O
ATTR_FORMAT_DIRECTIVE	int
)	O
{	O
end_css_class	function
(	O
stream	pointer
,	O
class_format_directive	array
)	O
;	O
currattr	char
&=	O
~	O
ATTR_FORMAT_DIRECTIVE	int
;	O
}	O
else	O
if	O
(	O
currattr	char
&	O
ATTR_INVALID_FORMAT_DIRECTIVE	int
)	O
{	O
end_css_class	function
(	O
stream	pointer
,	O
class_invalid_format_directive	array
)	O
;	O
currattr	char
&=	O
~	O
ATTR_INVALID_FORMAT_DIRECTIVE	int
;	O
}	O
if	O
(	O
!	O
(	O
currattr	char
==	O
0	int
)	O
)	O
abort	function
(	O
)	O
;	O
end_css_class	function
(	O
stream	pointer
,	O
class_text	array
)	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
"\""	pointer
)	O
;	O
end_css_class	function
(	O
stream	pointer
,	O
class_string	array
)	O
;	O
end_css_class	function
(	O
stream	pointer
,	O
css_class	pointer
)	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
free	function
(	O
linebreaks	pointer
)	O
;	O
free	function
(	O
attributes	pointer
)	O
;	O
free	function
(	O
overrides	pointer
)	O
;	O
free	function
(	O
portion	pointer
)	O
;	O
s	pointer
=	O
es	pointer
;	O
}	O
while	O
(	O
*	O
s	pointer
)	O
;	O
if	O
(	O
fmtdirattr	pointer
!=	O
NULL	O
)	O
free	function
(	O
fmtdirattr	pointer
)	O
;	O
if	O
(	O
fmtdir	pointer
!=	O
NULL	O
)	O
free	function
(	O
fmtdir	pointer
)	O
;	O
if	O
(	O
conv	pointer
!=	O
(	O
iconv_t	pointer
)	O
(	O
-	O
1	int
)	O
)	O
iconv_close	function
(	O
conv	pointer
)	O
;	O
}	O
static	O
void	O
print_blank_line	function
(	O
ostream_t	pointer
stream	pointer
)	O
{	O
if	O
(	O
uniforum	bool
)	O
{	O
begin_css_class	function
(	O
stream	pointer
,	O
class_comment	array
)	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
"#\n"	pointer
)	O
;	O
end_css_class	function
(	O
stream	pointer
,	O
class_comment	array
)	O
;	O
}	O
else	O
ostream_write_str	function
(	O
stream	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
static	O
void	O
message_print	function
(	O
const	O
message_ty	struct
*	O
mp	pointer
,	O
ostream_t	pointer
stream	pointer
,	O
const	O
char	O
*	O
charset	pointer
,	O
size_t	long
page_width	long
,	O
bool	bool
blank_line	bool
,	O
bool	bool
debug	bool
)	O
{	O
int	O
extra_indent	int
;	O
if	O
(	O
blank_line	bool
&&	O
(	O
!	O
uniforum	bool
||	O
mp	pointer
->	O
comment	pointer
==	O
NULL	O
||	O
mp	pointer
->	O
comment	pointer
->	O
nitems	long
==	O
0	int
||	O
mp	pointer
->	O
comment	pointer
->	O
item	pointer
[	O
0	int
]	O
[	O
0	int
]	O
!=	O
'\0'	O
)	O
)	O
print_blank_line	function
(	O
stream	pointer
)	O
;	O
if	O
(	O
is_header	O
(	O
mp	pointer
)	O
)	O
begin_css_class	function
(	O
stream	pointer
,	O
class_header	array
)	O
;	O
else	O
if	O
(	O
mp	pointer
->	O
msgstr	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
begin_css_class	function
(	O
stream	pointer
,	O
class_untranslated	array
)	O
;	O
else	O
if	O
(	O
mp	pointer
->	O
is_fuzzy	bool
)	O
begin_css_class	function
(	O
stream	pointer
,	O
class_fuzzy	array
)	O
;	O
else	O
begin_css_class	function
(	O
stream	pointer
,	O
class_translated	array
)	O
;	O
begin_css_class	function
(	O
stream	pointer
,	O
class_comment	array
)	O
;	O
message_print_comment	function
(	O
mp	pointer
,	O
stream	pointer
)	O
;	O
message_print_comment_dot	function
(	O
mp	pointer
,	O
stream	pointer
)	O
;	O
message_print_comment_filepos	function
(	O
mp	pointer
,	O
stream	pointer
,	O
uniforum	bool
,	O
page_width	long
)	O
;	O
message_print_comment_flags	function
(	O
mp	pointer
,	O
stream	pointer
,	O
debug	bool
)	O
;	O
begin_css_class	function
(	O
stream	pointer
,	O
class_previous_comment	array
)	O
;	O
if	O
(	O
mp	pointer
->	O
prev_msgctxt	pointer
!=	O
NULL	O
)	O
wrap	function
(	O
mp	pointer
,	O
stream	pointer
,	O
"#| "	pointer
,	O
0	int
,	O
class_previous	array
,	O
"msgctxt"	pointer
,	O
mp	pointer
->	O
prev_msgctxt	pointer
,	O
mp	pointer
->	O
do_wrap	enum
,	O
page_width	long
,	O
charset	pointer
)	O
;	O
if	O
(	O
mp	pointer
->	O
prev_msgid	pointer
!=	O
NULL	O
)	O
wrap	function
(	O
mp	pointer
,	O
stream	pointer
,	O
"#| "	pointer
,	O
0	int
,	O
class_previous	array
,	O
"msgid"	pointer
,	O
mp	pointer
->	O
prev_msgid	pointer
,	O
mp	pointer
->	O
do_wrap	enum
,	O
page_width	long
,	O
charset	pointer
)	O
;	O
if	O
(	O
mp	pointer
->	O
prev_msgid_plural	pointer
!=	O
NULL	O
)	O
wrap	function
(	O
mp	pointer
,	O
stream	pointer
,	O
"#| "	pointer
,	O
0	int
,	O
class_previous	array
,	O
"msgid_plural"	pointer
,	O
mp	pointer
->	O
prev_msgid_plural	pointer
,	O
mp	pointer
->	O
do_wrap	enum
,	O
page_width	long
,	O
charset	pointer
)	O
;	O
end_css_class	function
(	O
stream	pointer
,	O
class_previous_comment	array
)	O
;	O
extra_indent	int
=	O
(	O
mp	pointer
->	O
prev_msgctxt	pointer
!=	O
NULL	O
||	O
mp	pointer
->	O
prev_msgid	pointer
!=	O
NULL	O
||	O
mp	pointer
->	O
prev_msgid_plural	pointer
!=	O
NULL	O
?	O
3	int
:	O
0	int
)	O
;	O
end_css_class	function
(	O
stream	pointer
,	O
class_comment	array
)	O
;	O
if	O
(	O
mp	pointer
->	O
msgctxt	pointer
!=	O
NULL	O
&&	O
!	O
is_ascii_string	function
(	O
mp	pointer
->	O
msgctxt	pointer
)	O
&&	O
po_charset_canonicalize	function
(	O
charset	pointer
)	O
!=	O
po_charset_utf8	pointer
)	O
{	O
char	O
*	O
warning_message	pointer
=	O
xasprintf	function
(	O
_	O
(	O
"The following msgctxt contains non-ASCII characters.\nThis will cause problems to translators who use a character encoding\ndifferent from yours. Consider using a pure ASCII msgctxt instead.\n%s\n"	pointer
)	O
,	O
mp	pointer
->	O
msgctxt	pointer
)	O
;	O
po_xerror	pointer
(	O
PO_SEVERITY_WARNING	int
,	O
mp	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
true	int
,	O
warning_message	pointer
)	O
;	O
free	function
(	O
warning_message	pointer
)	O
;	O
}	O
if	O
(	O
!	O
is_ascii_string	function
(	O
mp	pointer
->	O
msgid	pointer
)	O
&&	O
po_charset_canonicalize	function
(	O
charset	pointer
)	O
!=	O
po_charset_utf8	pointer
)	O
{	O
char	O
*	O
warning_message	pointer
=	O
xasprintf	function
(	O
_	O
(	O
"The following msgid contains non-ASCII characters.\nThis will cause problems to translators who use a character encoding\ndifferent from yours. Consider using a pure ASCII msgid instead.\n%s\n"	pointer
)	O
,	O
mp	pointer
->	O
msgid	pointer
)	O
;	O
po_xerror	pointer
(	O
PO_SEVERITY_WARNING	int
,	O
mp	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
true	int
,	O
warning_message	pointer
)	O
;	O
free	function
(	O
warning_message	pointer
)	O
;	O
}	O
if	O
(	O
mp	pointer
->	O
msgctxt	pointer
!=	O
NULL	O
)	O
wrap	function
(	O
mp	pointer
,	O
stream	pointer
,	O
NULL	O
,	O
extra_indent	int
,	O
class_msgid	array
,	O
"msgctxt"	pointer
,	O
mp	pointer
->	O
msgctxt	pointer
,	O
mp	pointer
->	O
do_wrap	enum
,	O
page_width	long
,	O
charset	pointer
)	O
;	O
wrap	function
(	O
mp	pointer
,	O
stream	pointer
,	O
NULL	O
,	O
extra_indent	int
,	O
class_msgid	array
,	O
"msgid"	pointer
,	O
mp	pointer
->	O
msgid	pointer
,	O
mp	pointer
->	O
do_wrap	enum
,	O
page_width	long
,	O
charset	pointer
)	O
;	O
if	O
(	O
mp	pointer
->	O
msgid_plural	pointer
!=	O
NULL	O
)	O
wrap	function
(	O
mp	pointer
,	O
stream	pointer
,	O
NULL	O
,	O
extra_indent	int
,	O
class_msgid	array
,	O
"msgid_plural"	pointer
,	O
mp	pointer
->	O
msgid_plural	pointer
,	O
mp	pointer
->	O
do_wrap	enum
,	O
page_width	long
,	O
charset	pointer
)	O
;	O
if	O
(	O
mp	pointer
->	O
msgid_plural	pointer
==	O
NULL	O
)	O
wrap	function
(	O
mp	pointer
,	O
stream	pointer
,	O
NULL	O
,	O
extra_indent	int
,	O
class_msgstr	array
,	O
"msgstr"	pointer
,	O
mp	pointer
->	O
msgstr	pointer
,	O
mp	pointer
->	O
do_wrap	enum
,	O
page_width	long
,	O
charset	pointer
)	O
;	O
else	O
{	O
char	O
prefix_buf	array
[	O
20	int
]	O
;	O
unsigned	O
int	O
i	long
;	O
const	O
char	O
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
mp	pointer
->	O
msgstr	pointer
,	O
i	long
=	O
0	int
;	O
p	pointer
<	O
mp	pointer
->	O
msgstr	pointer
+	O
mp	pointer
->	O
msgstr_len	long
;	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
+	O
1	int
,	O
i	long
++	O
)	O
{	O
sprintf	function
(	O
prefix_buf	array
,	O
"msgstr[%u]"	pointer
,	O
i	long
)	O
;	O
wrap	function
(	O
mp	pointer
,	O
stream	pointer
,	O
NULL	O
,	O
extra_indent	int
,	O
class_msgstr	array
,	O
prefix_buf	array
,	O
p	pointer
,	O
mp	pointer
->	O
do_wrap	enum
,	O
page_width	long
,	O
charset	pointer
)	O
;	O
}	O
}	O
if	O
(	O
is_header	O
(	O
mp	pointer
)	O
)	O
end_css_class	function
(	O
stream	pointer
,	O
class_header	array
)	O
;	O
else	O
if	O
(	O
mp	pointer
->	O
msgstr	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
end_css_class	function
(	O
stream	pointer
,	O
class_untranslated	array
)	O
;	O
else	O
if	O
(	O
mp	pointer
->	O
is_fuzzy	bool
)	O
end_css_class	function
(	O
stream	pointer
,	O
class_fuzzy	array
)	O
;	O
else	O
end_css_class	function
(	O
stream	pointer
,	O
class_translated	array
)	O
;	O
}	O
static	O
void	O
message_print_obsolete	function
(	O
const	O
message_ty	struct
*	O
mp	pointer
,	O
ostream_t	pointer
stream	pointer
,	O
const	O
char	O
*	O
charset	pointer
,	O
size_t	long
page_width	long
,	O
bool	bool
blank_line	bool
,	O
bool	bool
debug	bool
)	O
{	O
int	O
extra_indent	int
;	O
if	O
(	O
mp	pointer
->	O
msgstr	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
return	O
;	O
if	O
(	O
blank_line	bool
)	O
print_blank_line	function
(	O
stream	pointer
)	O
;	O
begin_css_class	function
(	O
stream	pointer
,	O
class_obsolete	array
)	O
;	O
begin_css_class	function
(	O
stream	pointer
,	O
class_comment	array
)	O
;	O
message_print_comment	function
(	O
mp	pointer
,	O
stream	pointer
)	O
;	O
message_print_comment_dot	function
(	O
mp	pointer
,	O
stream	pointer
)	O
;	O
message_print_comment_filepos	function
(	O
mp	pointer
,	O
stream	pointer
,	O
uniforum	bool
,	O
page_width	long
)	O
;	O
if	O
(	O
mp	pointer
->	O
is_fuzzy	bool
||	O
has_significant_format_p	function
(	O
mp	pointer
->	O
is_format	enum
)	O
||	O
mp	pointer
->	O
do_wrap	enum
==	O
no	int
)	O
{	O
bool	bool
first_flag	bool
=	O
true	int
;	O
size_t	long
i	long
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
"#,"	pointer
)	O
;	O
if	O
(	O
mp	pointer
->	O
is_fuzzy	bool
)	O
{	O
ostream_write_str	function
(	O
stream	pointer
,	O
" fuzzy"	pointer
)	O
;	O
first_flag	bool
=	O
false	int
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
NFORMATS	int
;	O
i	long
++	O
)	O
if	O
(	O
significant_format_p	function
(	O
mp	pointer
->	O
is_format	enum
[	O
i	long
]	O
)	O
)	O
{	O
if	O
(	O
!	O
first_flag	bool
)	O
ostream_write_str	function
(	O
stream	pointer
,	O
","	pointer
)	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
" "	pointer
)	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
make_format_description_string	function
(	O
mp	pointer
->	O
is_format	enum
[	O
i	long
]	O
,	O
format_language	array
[	O
i	long
]	O
,	O
debug	bool
)	O
)	O
;	O
first_flag	bool
=	O
false	int
;	O
}	O
if	O
(	O
mp	pointer
->	O
do_wrap	enum
==	O
no	int
)	O
{	O
if	O
(	O
!	O
first_flag	bool
)	O
ostream_write_str	function
(	O
stream	pointer
,	O
","	pointer
)	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
" "	pointer
)	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
make_c_width_description_string	function
(	O
mp	pointer
->	O
do_wrap	enum
)	O
)	O
;	O
first_flag	bool
=	O
false	int
;	O
}	O
ostream_write_str	function
(	O
stream	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
begin_css_class	function
(	O
stream	pointer
,	O
class_previous_comment	array
)	O
;	O
if	O
(	O
mp	pointer
->	O
prev_msgctxt	pointer
!=	O
NULL	O
)	O
wrap	function
(	O
mp	pointer
,	O
stream	pointer
,	O
"#~| "	pointer
,	O
0	int
,	O
class_previous	array
,	O
"msgctxt"	pointer
,	O
mp	pointer
->	O
prev_msgctxt	pointer
,	O
mp	pointer
->	O
do_wrap	enum
,	O
page_width	long
,	O
charset	pointer
)	O
;	O
if	O
(	O
mp	pointer
->	O
prev_msgid	pointer
!=	O
NULL	O
)	O
wrap	function
(	O
mp	pointer
,	O
stream	pointer
,	O
"#~| "	pointer
,	O
0	int
,	O
class_previous	array
,	O
"msgid"	pointer
,	O
mp	pointer
->	O
prev_msgid	pointer
,	O
mp	pointer
->	O
do_wrap	enum
,	O
page_width	long
,	O
charset	pointer
)	O
;	O
if	O
(	O
mp	pointer
->	O
prev_msgid_plural	pointer
!=	O
NULL	O
)	O
wrap	function
(	O
mp	pointer
,	O
stream	pointer
,	O
"#~| "	pointer
,	O
0	int
,	O
class_previous	array
,	O
"msgid_plural"	pointer
,	O
mp	pointer
->	O
prev_msgid_plural	pointer
,	O
mp	pointer
->	O
do_wrap	enum
,	O
page_width	long
,	O
charset	pointer
)	O
;	O
end_css_class	function
(	O
stream	pointer
,	O
class_previous_comment	array
)	O
;	O
extra_indent	int
=	O
(	O
mp	pointer
->	O
prev_msgctxt	pointer
!=	O
NULL	O
||	O
mp	pointer
->	O
prev_msgid	pointer
!=	O
NULL	O
||	O
mp	pointer
->	O
prev_msgid_plural	pointer
!=	O
NULL	O
?	O
1	int
:	O
0	int
)	O
;	O
end_css_class	function
(	O
stream	pointer
,	O
class_comment	array
)	O
;	O
if	O
(	O
mp	pointer
->	O
msgctxt	pointer
!=	O
NULL	O
&&	O
!	O
is_ascii_string	function
(	O
mp	pointer
->	O
msgctxt	pointer
)	O
&&	O
po_charset_canonicalize	function
(	O
charset	pointer
)	O
!=	O
po_charset_utf8	pointer
)	O
{	O
char	O
*	O
warning_message	pointer
=	O
xasprintf	function
(	O
_	O
(	O
"The following msgctxt contains non-ASCII characters.\nThis will cause problems to translators who use a character encoding\ndifferent from yours. Consider using a pure ASCII msgctxt instead.\n%s\n"	pointer
)	O
,	O
mp	pointer
->	O
msgctxt	pointer
)	O
;	O
po_xerror	pointer
(	O
PO_SEVERITY_WARNING	int
,	O
mp	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
true	int
,	O
warning_message	pointer
)	O
;	O
free	function
(	O
warning_message	pointer
)	O
;	O
}	O
if	O
(	O
!	O
is_ascii_string	function
(	O
mp	pointer
->	O
msgid	pointer
)	O
&&	O
po_charset_canonicalize	function
(	O
charset	pointer
)	O
!=	O
po_charset_utf8	pointer
)	O
{	O
char	O
*	O
warning_message	pointer
=	O
xasprintf	function
(	O
_	O
(	O
"The following msgid contains non-ASCII characters.\nThis will cause problems to translators who use a character encoding\ndifferent from yours. Consider using a pure ASCII msgid instead.\n%s\n"	pointer
)	O
,	O
mp	pointer
->	O
msgid	pointer
)	O
;	O
po_xerror	pointer
(	O
PO_SEVERITY_WARNING	int
,	O
mp	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
true	int
,	O
warning_message	pointer
)	O
;	O
free	function
(	O
warning_message	pointer
)	O
;	O
}	O
if	O
(	O
mp	pointer
->	O
msgctxt	pointer
!=	O
NULL	O
)	O
wrap	function
(	O
mp	pointer
,	O
stream	pointer
,	O
"#~ "	pointer
,	O
extra_indent	int
,	O
class_msgid	array
,	O
"msgctxt"	pointer
,	O
mp	pointer
->	O
msgctxt	pointer
,	O
mp	pointer
->	O
do_wrap	enum
,	O
page_width	long
,	O
charset	pointer
)	O
;	O
wrap	function
(	O
mp	pointer
,	O
stream	pointer
,	O
"#~ "	pointer
,	O
extra_indent	int
,	O
class_msgid	array
,	O
"msgid"	pointer
,	O
mp	pointer
->	O
msgid	pointer
,	O
mp	pointer
->	O
do_wrap	enum
,	O
page_width	long
,	O
charset	pointer
)	O
;	O
if	O
(	O
mp	pointer
->	O
msgid_plural	pointer
!=	O
NULL	O
)	O
wrap	function
(	O
mp	pointer
,	O
stream	pointer
,	O
"#~ "	pointer
,	O
extra_indent	int
,	O
class_msgid	array
,	O
"msgid_plural"	pointer
,	O
mp	pointer
->	O
msgid_plural	pointer
,	O
mp	pointer
->	O
do_wrap	enum
,	O
page_width	long
,	O
charset	pointer
)	O
;	O
if	O
(	O
mp	pointer
->	O
msgid_plural	pointer
==	O
NULL	O
)	O
wrap	function
(	O
mp	pointer
,	O
stream	pointer
,	O
"#~ "	pointer
,	O
extra_indent	int
,	O
class_msgstr	array
,	O
"msgstr"	pointer
,	O
mp	pointer
->	O
msgstr	pointer
,	O
mp	pointer
->	O
do_wrap	enum
,	O
page_width	long
,	O
charset	pointer
)	O
;	O
else	O
{	O
char	O
prefix_buf	array
[	O
20	int
]	O
;	O
unsigned	O
int	O
i	long
;	O
const	O
char	O
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
mp	pointer
->	O
msgstr	pointer
,	O
i	long
=	O
0	int
;	O
p	pointer
<	O
mp	pointer
->	O
msgstr	pointer
+	O
mp	pointer
->	O
msgstr_len	long
;	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
+	O
1	int
,	O
i	long
++	O
)	O
{	O
sprintf	function
(	O
prefix_buf	array
,	O
"msgstr[%u]"	pointer
,	O
i	long
)	O
;	O
wrap	function
(	O
mp	pointer
,	O
stream	pointer
,	O
"#~ "	pointer
,	O
extra_indent	int
,	O
class_msgstr	array
,	O
prefix_buf	array
,	O
p	pointer
,	O
mp	pointer
->	O
do_wrap	enum
,	O
page_width	long
,	O
charset	pointer
)	O
;	O
}	O
}	O
end_css_class	function
(	O
stream	pointer
,	O
class_obsolete	array
)	O
;	O
}	O
static	O
void	O
msgdomain_list_print_po	function
(	O
msgdomain_list_ty	struct
*	O
mdlp	pointer
,	O
ostream_t	pointer
stream	pointer
,	O
size_t	long
page_width	long
,	O
bool	bool
debug	bool
)	O
{	O
size_t	long
j	long
,	O
k	long
;	O
bool	bool
blank_line	bool
;	O
blank_line	bool
=	O
false	int
;	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
mdlp	pointer
->	O
nitems	long
;	O
k	long
++	O
)	O
{	O
message_list_ty	struct
*	O
mlp	pointer
;	O
const	O
char	O
*	O
header	pointer
;	O
const	O
char	O
*	O
charset	pointer
;	O
char	O
*	O
allocated_charset	pointer
;	O
if	O
(	O
!	O
(	O
k	long
==	O
0	int
&&	O
strcmp	function
(	O
mdlp	pointer
->	O
item	pointer
[	O
k	long
]	O
->	O
domain	pointer
,	O
MESSAGE_DOMAIN_DEFAULT	pointer
)	O
==	O
0	int
)	O
)	O
{	O
if	O
(	O
blank_line	bool
)	O
print_blank_line	function
(	O
stream	pointer
)	O
;	O
begin_css_class	function
(	O
stream	pointer
,	O
class_keyword	array
)	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
"domain"	pointer
)	O
;	O
end_css_class	function
(	O
stream	pointer
,	O
class_keyword	array
)	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
" "	pointer
)	O
;	O
begin_css_class	function
(	O
stream	pointer
,	O
class_string	array
)	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
"\""	pointer
)	O
;	O
begin_css_class	function
(	O
stream	pointer
,	O
class_text	array
)	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
mdlp	pointer
->	O
item	pointer
[	O
k	long
]	O
->	O
domain	pointer
)	O
;	O
end_css_class	function
(	O
stream	pointer
,	O
class_text	array
)	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
"\""	pointer
)	O
;	O
end_css_class	function
(	O
stream	pointer
,	O
class_string	array
)	O
;	O
ostream_write_str	function
(	O
stream	pointer
,	O
"\n"	pointer
)	O
;	O
blank_line	bool
=	O
true	int
;	O
}	O
mlp	pointer
=	O
mdlp	pointer
->	O
item	pointer
[	O
k	long
]	O
->	O
messages	pointer
;	O
header	pointer
=	O
NULL	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
mlp	pointer
->	O
nitems	long
;	O
++	O
j	long
)	O
if	O
(	O
is_header	O
(	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
)	O
&&	O
!	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
->	O
obsolete	bool
)	O
{	O
header	pointer
=	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
->	O
msgstr	pointer
;	O
break	O
;	O
}	O
charset	pointer
=	O
"ASCII"	pointer
;	O
allocated_charset	pointer
=	O
NULL	O
;	O
if	O
(	O
header	pointer
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
charsetstr	pointer
=	O
c_strstr	function
(	O
header	pointer
,	O
"charset="	pointer
)	O
;	O
if	O
(	O
charsetstr	pointer
!=	O
NULL	O
)	O
{	O
size_t	long
len	long
;	O
charsetstr	pointer
+=	O
strlen	function
(	O
"charset="	pointer
)	O
;	O
len	long
=	O
strcspn	function
(	O
charsetstr	pointer
,	O
" \t\n"	pointer
)	O
;	O
allocated_charset	pointer
=	O
(	O
char	O
*	O
)	O
xmalloca	O
(	O
len	long
+	O
1	int
)	O
;	O
memcpy	function
(	O
allocated_charset	pointer
,	O
charsetstr	pointer
,	O
len	long
)	O
;	O
allocated_charset	pointer
[	O
len	long
]	O
=	O
'\0'	O
;	O
charset	pointer
=	O
allocated_charset	pointer
;	O
if	O
(	O
strcmp	function
(	O
charset	pointer
,	O
"CHARSET"	pointer
)	O
==	O
0	int
)	O
charset	pointer
=	O
"ASCII"	pointer
;	O
}	O
}	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
mlp	pointer
->	O
nitems	long
;	O
++	O
j	long
)	O
if	O
(	O
!	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
->	O
obsolete	bool
)	O
{	O
message_print	function
(	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
,	O
stream	pointer
,	O
charset	pointer
,	O
page_width	long
,	O
blank_line	bool
,	O
debug	bool
)	O
;	O
blank_line	bool
=	O
true	int
;	O
}	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
mlp	pointer
->	O
nitems	long
;	O
++	O
j	long
)	O
if	O
(	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
->	O
obsolete	bool
)	O
{	O
message_print_obsolete	function
(	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
,	O
stream	pointer
,	O
charset	pointer
,	O
page_width	long
,	O
blank_line	bool
,	O
debug	bool
)	O
;	O
blank_line	bool
=	O
true	int
;	O
}	O
if	O
(	O
allocated_charset	pointer
!=	O
NULL	O
)	O
freea	function
(	O
allocated_charset	pointer
)	O
;	O
}	O
}	O
const	O
struct	O
catalog_output_format	struct
output_format_po	struct
=	O
{	O
msgdomain_list_print_po	function
,	O
false	int
,	O
true	int
,	O
true	int
,	O
true	int
,	O
true	int
,	O
true	int
,	O
false	int
,	O
false	int
}	O
;	O
