static	O
unsigned	O
int	O
loglevel	int
;	O
BITCODE_H	pointer
dwg_find_tablehandle_silent	function
(	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
const	O
char	O
*	O
restrict	O
name	pointer
,	O
const	O
char	O
*	O
restrict	O
table	pointer
)	O
;	O
static	O
int	O
dat_read_file	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
FILE	struct
*	O
restrict	O
fp	pointer
,	O
const	O
char	O
*	O
restrict	O
filename	pointer
)	O
{	O
size_t	long
size	char
;	O
dat	pointer
->	O
chain	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
calloc	function
(	O
1	int
,	O
dat	pointer
->	O
size	char
)	O
;	O
if	O
(	O
!	O
dat	pointer
->	O
chain	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Not enough memory.\n"	pointer
)	O
fclose	function
(	O
fp	pointer
)	O
;	O
return	O
DWG_ERR_OUTOFMEM	int
;	O
}	O
size	char
=	O
fread	function
(	O
dat	pointer
->	O
chain	pointer
,	O
sizeof	O
(	O
char	O
)	O
,	O
dat	pointer
->	O
size	char
,	O
fp	pointer
)	O
;	O
if	O
(	O
size	char
!=	O
dat	pointer
->	O
size	char
)	O
{	O
LOG_ERROR	O
(	O
"Could not read file (%lu out of %lu): %s\n"	pointer
,	O
(	O
long	O
unsigned	O
int	O
)	O
size	char
,	O
dat	pointer
->	O
size	char
,	O
filename	pointer
)	O
fclose	function
(	O
fp	pointer
)	O
;	O
free	function
(	O
dat	pointer
->	O
chain	pointer
)	O
;	O
dat	pointer
->	O
chain	pointer
=	O
NULL	O
;	O
dat	pointer
->	O
size	char
=	O
0	int
;	O
return	O
DWG_ERR_IOERROR	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
dat_read_stream	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
FILE	struct
*	O
restrict	O
fp	pointer
)	O
{	O
size_t	long
size	char
=	O
0	int
;	O
do	O
{	O
if	O
(	O
dat	pointer
->	O
chain	pointer
)	O
dat	pointer
->	O
chain	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
realloc	function
(	O
dat	pointer
->	O
chain	pointer
,	O
dat	pointer
->	O
size	char
+	O
4096	int
)	O
;	O
else	O
{	O
dat	pointer
->	O
chain	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
calloc	function
(	O
1	int
,	O
4096	int
)	O
;	O
dat	pointer
->	O
size	char
=	O
0	int
;	O
}	O
if	O
(	O
!	O
dat	pointer
->	O
chain	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Not enough memory.\n"	pointer
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
return	O
DWG_ERR_OUTOFMEM	int
;	O
}	O
size	char
=	O
fread	function
(	O
&	O
dat	pointer
->	O
chain	pointer
[	O
dat	pointer
->	O
size	char
]	O
,	O
sizeof	O
(	O
char	O
)	O
,	O
4096	int
,	O
fp	pointer
)	O
;	O
dat	pointer
->	O
size	char
+=	O
size	char
;	O
}	O
while	O
(	O
size	char
==	O
4096	int
)	O
;	O
if	O
(	O
dat	pointer
->	O
size	char
==	O
0	int
)	O
{	O
LOG_ERROR	O
(	O
"Could not read from stream (%lu out of %lu)\n"	pointer
,	O
(	O
long	O
unsigned	O
int	O
)	O
size	char
,	O
dat	pointer
->	O
size	char
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
free	function
(	O
dat	pointer
->	O
chain	pointer
)	O
;	O
dat	pointer
->	O
chain	pointer
=	O
NULL	O
;	O
return	O
DWG_ERR_IOERROR	int
;	O
}	O
size	char
=	O
dat	pointer
->	O
size	char
&	O
0xfff	int
;	O
if	O
(	O
size	char
)	O
{	O
memset	function
(	O
&	O
dat	pointer
->	O
chain	pointer
[	O
dat	pointer
->	O
size	char
]	O
,	O
0	int
,	O
0xfff	int
-	O
size	char
)	O
;	O
dat	pointer
->	O
chain	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
realloc	function
(	O
dat	pointer
->	O
chain	pointer
,	O
dat	pointer
->	O
size	char
)	O
;	O
}	O
return	O
0	int
;	O
}	O
EXPORT	O
int	O
dwg_read_file	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
FILE	struct
*	O
fp	pointer
;	O
struct	O
stat	struct
attrib	struct
;	O
size_t	long
size	char
;	O
Bit_Chain	struct
bit_chain	struct
=	O
{	O
0	int
}	O
;	O
int	O
error	int
;	O
loglevel	int
=	O
dwg	pointer
->	O
opts	int
&	O
DWG_OPTS_LOGLEVEL	int
;	O
memset	function
(	O
dwg	pointer
,	O
0	int
,	O
sizeof	O
(	O
Dwg_Data	struct
)	O
)	O
;	O
dwg	pointer
->	O
opts	int
=	O
loglevel	int
;	O
if	O
(	O
strEQc	O
(	O
filename	pointer
,	O
"-"	pointer
)	O
)	O
{	O
fp	pointer
=	O
stdin	pointer
;	O
}	O
else	O
{	O
if	O
(	O
stat	struct
(	O
filename	pointer
,	O
&	O
attrib	struct
)	O
)	O
{	O
LOG_ERROR	O
(	O
"File not found: %s\n"	pointer
,	O
filename	pointer
)	O
;	O
return	O
DWG_ERR_IOERROR	int
;	O
}	O
if	O
(	O
!	O
(	O
S_ISREG	O
(	O
attrib	struct
.	O
st_mode	int
)	O
||	O
S_ISLNK	O
(	O
attrib	struct
.	O
st_mode	int
)	O
)	O
)	O
{	O
LOG_ERROR	O
(	O
"Error: %s\n"	pointer
,	O
filename	pointer
)	O
;	O
return	O
DWG_ERR_IOERROR	int
;	O
}	O
fp	pointer
=	O
fopen	function
(	O
filename	pointer
,	O
"rb"	pointer
)	O
;	O
}	O
if	O
(	O
!	O
fp	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Could not open file: %s\n"	pointer
,	O
filename	pointer
)	O
return	O
DWG_ERR_IOERROR	int
;	O
}	O
memset	function
(	O
&	O
bit_chain	struct
,	O
0	int
,	O
sizeof	O
(	O
Bit_Chain	struct
)	O
)	O
;	O
if	O
(	O
fp	pointer
==	O
stdin	pointer
)	O
{	O
error	int
=	O
dat_read_stream	function
(	O
&	O
bit_chain	struct
,	O
fp	pointer
)	O
;	O
if	O
(	O
error	int
>=	O
DWG_ERR_CRITICAL	O
)	O
return	O
error	int
;	O
}	O
else	O
{	O
bit_chain	struct
.	O
size	char
=	O
attrib	struct
.	O
st_size	long
;	O
error	int
=	O
dat_read_file	function
(	O
&	O
bit_chain	struct
,	O
fp	pointer
,	O
filename	pointer
)	O
;	O
if	O
(	O
error	int
>=	O
DWG_ERR_CRITICAL	O
)	O
return	O
error	int
;	O
}	O
fclose	function
(	O
fp	pointer
)	O
;	O
error	int
=	O
dwg_decode	function
(	O
&	O
bit_chain	struct
,	O
dwg	pointer
)	O
;	O
if	O
(	O
error	int
>=	O
DWG_ERR_CRITICAL	O
)	O
{	O
LOG_ERROR	O
(	O
"Failed to decode file: %s 0x%x\n"	pointer
,	O
filename	pointer
,	O
error	int
)	O
free	function
(	O
bit_chain	struct
.	O
chain	pointer
)	O
;	O
bit_chain	struct
.	O
chain	pointer
=	O
NULL	O
;	O
bit_chain	struct
.	O
size	char
=	O
0	int
;	O
return	O
error	int
;	O
}	O
free	function
(	O
bit_chain	struct
.	O
chain	pointer
)	O
;	O
bit_chain	struct
.	O
chain	pointer
=	O
NULL	O
;	O
bit_chain	struct
.	O
size	char
=	O
0	int
;	O
return	O
error	int
;	O
}	O
EXPORT	O
int	O
dxf_read_file	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
int	O
error	int
;	O
FILE	struct
*	O
fp	pointer
;	O
struct	O
stat	struct
attrib	struct
;	O
size_t	long
size	char
;	O
Bit_Chain	struct
dat	pointer
=	O
{	O
0	int
}	O
;	O
loglevel	int
=	O
dwg	pointer
->	O
opts	int
&	O
DWG_OPTS_LOGLEVEL	int
;	O
if	O
(	O
!	O
filename	pointer
||	O
stat	struct
(	O
filename	pointer
,	O
&	O
attrib	struct
)	O
)	O
{	O
LOG_ERROR	O
(	O
"File not found: %s\n"	pointer
,	O
filename	pointer
?	O
filename	pointer
:	O
"(null)"	pointer
)	O
return	O
DWG_ERR_IOERROR	int
;	O
}	O
if	O
(	O
!	O
(	O
S_ISREG	O
(	O
attrib	struct
.	O
st_mode	int
)	O
||	O
S_ISLNK	O
(	O
attrib	struct
.	O
st_mode	int
)	O
)	O
)	O
{	O
LOG_ERROR	O
(	O
"Error: %s\n"	pointer
,	O
filename	pointer
)	O
return	O
DWG_ERR_IOERROR	int
;	O
}	O
fp	pointer
=	O
fopen	function
(	O
filename	pointer
,	O
"rb"	pointer
)	O
;	O
if	O
(	O
!	O
fp	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Could not open file: %s\n"	pointer
,	O
filename	pointer
)	O
return	O
DWG_ERR_IOERROR	int
;	O
}	O
memset	function
(	O
dwg	pointer
,	O
0	int
,	O
sizeof	O
(	O
Dwg_Data	struct
)	O
)	O
;	O
dwg	pointer
->	O
opts	int
=	O
loglevel	int
|	O
DWG_OPTS_INDXF	int
;	O
memset	function
(	O
&	O
dat	pointer
,	O
0	int
,	O
sizeof	O
(	O
Bit_Chain	struct
)	O
)	O
;	O
dat	pointer
.	O
size	char
=	O
attrib	struct
.	O
st_size	long
;	O
dat	pointer
.	O
chain	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
calloc	function
(	O
1	int
,	O
dat	pointer
.	O
size	char
+	O
2	int
)	O
;	O
if	O
(	O
!	O
dat	pointer
.	O
chain	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Not enough memory.\n"	pointer
)	O
fclose	function
(	O
fp	pointer
)	O
;	O
return	O
DWG_ERR_OUTOFMEM	int
;	O
}	O
dat	pointer
.	O
byte	char
=	O
0	int
;	O
dat	pointer
.	O
bit	char
=	O
0	int
;	O
dat	pointer
.	O
from_version	enum
=	O
dwg	pointer
->	O
header	struct
.	O
from_version	enum
;	O
dat	pointer
.	O
version	short
=	O
dwg	pointer
->	O
header	struct
.	O
version	short
;	O
dat	pointer
.	O
opts	int
=	O
dwg	pointer
->	O
opts	int
;	O
size	char
=	O
fread	function
(	O
dat	pointer
.	O
chain	pointer
,	O
sizeof	O
(	O
char	O
)	O
,	O
dat	pointer
.	O
size	char
,	O
fp	pointer
)	O
;	O
if	O
(	O
size	char
!=	O
dat	pointer
.	O
size	char
)	O
{	O
LOG_ERROR	O
(	O
"Could not read the entire file (%lu out of %lu): %s\n"	pointer
,	O
(	O
long	O
unsigned	O
int	O
)	O
size	char
,	O
dat	pointer
.	O
size	char
,	O
filename	pointer
)	O
fclose	function
(	O
fp	pointer
)	O
;	O
free	function
(	O
dat	pointer
.	O
chain	pointer
)	O
;	O
dat	pointer
.	O
chain	pointer
=	O
NULL	O
;	O
dat	pointer
.	O
size	char
=	O
0	int
;	O
return	O
DWG_ERR_IOERROR	int
;	O
}	O
fclose	function
(	O
fp	pointer
)	O
;	O
dat	pointer
.	O
chain	pointer
[	O
size	char
]	O
=	O
'\n'	O
;	O
dat	pointer
.	O
chain	pointer
[	O
size	char
+	O
1	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
!	O
memcmp	function
(	O
dat	pointer
.	O
chain	pointer
,	O
"AC10"	pointer
,	O
4	int
)	O
)	O
{	O
LOG_ERROR	O
(	O
"This is a DWG, not a DXF file: %s\n"	pointer
,	O
filename	pointer
)	O
free	function
(	O
dat	pointer
.	O
chain	pointer
)	O
;	O
dat	pointer
.	O
chain	pointer
=	O
NULL	O
;	O
dat	pointer
.	O
size	char
=	O
0	int
;	O
return	O
DWG_ERR_INVALIDDWG	int
;	O
}	O
if	O
(	O
!	O
memcmp	function
(	O
dat	pointer
.	O
chain	pointer
,	O
"AutoCAD Binary DXF"	pointer
,	O
sizeof	O
(	O
"AutoCAD Binary DXF"	pointer
)	O
-	O
1	int
)	O
)	O
error	int
=	O
dwg_read_dxfb	function
(	O
&	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
else	O
error	int
=	O
dwg_read_dxf	function
(	O
&	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
dwg	pointer
->	O
opts	int
|=	O
(	O
DWG_OPTS_INDXF	int
|	O
loglevel	int
)	O
;	O
if	O
(	O
error	int
>=	O
DWG_ERR_CRITICAL	O
)	O
{	O
LOG_ERROR	O
(	O
"Failed to decode DXF file: %s\n"	pointer
,	O
filename	pointer
)	O
free	function
(	O
dat	pointer
.	O
chain	pointer
)	O
;	O
dat	pointer
.	O
chain	pointer
=	O
NULL	O
;	O
dat	pointer
.	O
size	char
=	O
0	int
;	O
return	O
error	int
;	O
}	O
free	function
(	O
dat	pointer
.	O
chain	pointer
)	O
;	O
dat	pointer
.	O
chain	pointer
=	O
NULL	O
;	O
dat	pointer
.	O
size	char
=	O
0	int
;	O
return	O
0	int
;	O
}	O
EXPORT	O
int	O
dwg_write_file	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
FILE	struct
*	O
fh	pointer
;	O
struct	O
stat	struct
attrib	struct
;	O
Bit_Chain	struct
dat	pointer
=	O
{	O
0	int
}	O
;	O
int	O
error	int
;	O
loglevel	int
=	O
dwg	pointer
->	O
opts	int
&	O
DWG_OPTS_LOGLEVEL	int
;	O
assert	O
(	O
filename	pointer
)	O
;	O
assert	O
(	O
dwg	pointer
)	O
;	O
dat	pointer
.	O
opts	int
=	O
dwg	pointer
->	O
opts	int
;	O
dat	pointer
.	O
version	short
=	O
(	O
Dwg_Version_Type	enum
)	O
dwg	pointer
->	O
header	struct
.	O
version	short
;	O
dat	pointer
.	O
from_version	enum
=	O
(	O
Dwg_Version_Type	enum
)	O
dwg	pointer
->	O
header	struct
.	O
from_version	enum
;	O
dat	pointer
.	O
size	char
=	O
0	int
;	O
error	int
=	O
dwg_encode	function
(	O
(	O
Dwg_Data	struct
*	O
)	O
dwg	pointer
,	O
&	O
dat	pointer
)	O
;	O
if	O
(	O
error	int
>=	O
DWG_ERR_CRITICAL	O
)	O
{	O
LOG_ERROR	O
(	O
"Failed to encode datastructure.\n"	pointer
)	O
if	O
(	O
dat	pointer
.	O
size	char
>	O
0	int
)	O
{	O
free	function
(	O
dat	pointer
.	O
chain	pointer
)	O
;	O
dat	pointer
.	O
chain	pointer
=	O
NULL	O
;	O
dat	pointer
.	O
size	char
=	O
0	int
;	O
}	O
return	O
error	int
;	O
}	O
if	O
(	O
!	O
stat	struct
(	O
filename	pointer
,	O
&	O
attrib	struct
)	O
&&	O
strNE	O
(	O
filename	pointer
,	O
"/dev/null"	pointer
)	O
)	O
{	O
LOG_ERROR	O
(	O
"The file already exists. We won't overwrite it."	pointer
)	O
return	O
error	int
|	O
DWG_ERR_IOERROR	int
;	O
}	O
fh	pointer
=	O
fopen	function
(	O
filename	pointer
,	O
"wb"	pointer
)	O
;	O
if	O
(	O
!	O
fh	pointer
||	O
!	O
dat	pointer
.	O
chain	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Failed to create the file: %s\n"	pointer
,	O
filename	pointer
)	O
return	O
error	int
|	O
DWG_ERR_IOERROR	int
;	O
}	O
if	O
(	O
fwrite	function
(	O
dat	pointer
.	O
chain	pointer
,	O
sizeof	O
(	O
char	O
)	O
,	O
dat	pointer
.	O
size	char
,	O
fh	pointer
)	O
!=	O
dat	pointer
.	O
size	char
)	O
{	O
LOG_ERROR	O
(	O
"Failed to write data into the file: %s\n"	pointer
,	O
filename	pointer
)	O
fclose	function
(	O
fh	pointer
)	O
;	O
free	function
(	O
dat	pointer
.	O
chain	pointer
)	O
;	O
dat	pointer
.	O
chain	pointer
=	O
NULL	O
;	O
dat	pointer
.	O
size	char
=	O
0	int
;	O
return	O
error	int
|	O
DWG_ERR_IOERROR	int
;	O
}	O
fclose	function
(	O
fh	pointer
)	O
;	O
if	O
(	O
dat	pointer
.	O
size	char
>	O
0	int
)	O
{	O
free	function
(	O
dat	pointer
.	O
chain	pointer
)	O
;	O
dat	pointer
.	O
chain	pointer
=	O
NULL	O
;	O
dat	pointer
.	O
size	char
=	O
0	int
;	O
}	O
return	O
error	int
;	O
}	O
EXPORT	O
unsigned	O
char	O
*	O
dwg_bmp	function
(	O
const	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
BITCODE_RL	int
*	O
restrict	O
size	char
)	O
{	O
BITCODE_RC	char
i	int
,	O
num_pictures	char
,	O
code	char
;	O
int	O
found	int
;	O
BITCODE_RL	int
header_size	int
,	O
address	long
,	O
osize	int
;	O
Bit_Chain	struct
*	O
dat	pointer
;	O
loglevel	int
=	O
dwg	pointer
->	O
opts	int
&	O
DWG_OPTS_LOGLEVEL	int
;	O
*	O
size	char
=	O
0	int
;	O
assert	O
(	O
dwg	pointer
)	O
;	O
dat	pointer
=	O
(	O
Bit_Chain	struct
*	O
)	O
&	O
dwg	pointer
->	O
thumbnail	struct
;	O
if	O
(	O
!	O
dat	pointer
||	O
!	O
dat	pointer
->	O
size	char
)	O
{	O
LOG_INFO	O
(	O
"no THUMBNAIL Image Data\n"	pointer
)	O
return	O
NULL	O
;	O
}	O
dat	pointer
->	O
bit	char
=	O
0	int
;	O
dat	pointer
->	O
version	short
=	O
dwg	pointer
->	O
header	struct
.	O
version	short
;	O
dat	pointer
->	O
from_version	enum
=	O
dwg	pointer
->	O
header	struct
.	O
from_version	enum
;	O
osize	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"overall size: "	pointer
FORMAT_RL	O
" [RL]\n"	pointer
,	O
osize	int
)	O
;	O
if	O
(	O
osize	int
>	O
dat	pointer
->	O
size	char
)	O
{	O
LOG_ERROR	O
(	O
"Preview overflow > %lu"	pointer
,	O
dat	pointer
->	O
size	char
)	O
;	O
return	O
NULL	O
;	O
}	O
num_pictures	char
=	O
bit_read_RC	function
(	O
dat	pointer
)	O
;	O
LOG_INFO	O
(	O
"num_pictures: %d [RC]\n"	pointer
,	O
(	O
int	O
)	O
num_pictures	char
)	O
found	int
=	O
0	int
;	O
header_size	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_pictures	char
;	O
i	int
++	O
)	O
{	O
if	O
(	O
dat	pointer
->	O
byte	char
>	O
dat	pointer
->	O
size	char
)	O
{	O
LOG_ERROR	O
(	O
"Preview overflow"	pointer
)	O
;	O
break	O
;	O
}	O
code	char
=	O
bit_read_RC	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"\t[%i] Code: %i [RC]\n"	pointer
,	O
i	int
,	O
code	char
)	O
address	long
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"\t\tHeader data start: 0x%x [RL]\n"	pointer
,	O
address	long
)	O
if	O
(	O
code	char
==	O
1	int
)	O
{	O
header_size	int
+=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"\t\tHeader data size: %i [RL]\n"	pointer
,	O
header_size	int
)	O
}	O
else	O
if	O
(	O
code	char
==	O
2	int
&&	O
found	int
==	O
0	int
)	O
{	O
*	O
size	char
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
found	int
=	O
1	int
;	O
LOG_INFO	O
(	O
"\t\tBMP size: %i [RL]\n"	pointer
,	O
*	O
size	char
)	O
}	O
else	O
if	O
(	O
code	char
==	O
3	int
)	O
{	O
osize	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
LOG_INFO	O
(	O
"\t\tWMF size: %i [RL]\n"	pointer
,	O
osize	int
)	O
}	O
else	O
{	O
osize	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"\t\tSize of unknown code %i: %i [RL]\n"	pointer
,	O
code	char
,	O
osize	int
)	O
}	O
}	O
dat	pointer
->	O
byte	char
+=	O
header_size	int
;	O
if	O
(	O
*	O
size	char
)	O
LOG_TRACE	O
(	O
"BMP offset: %lu\n"	pointer
,	O
dat	pointer
->	O
byte	char
)	O
if	O
(	O
*	O
size	char
>	O
0	int
)	O
return	O
(	O
dat	pointer
->	O
chain	pointer
+	O
dat	pointer
->	O
byte	char
)	O
;	O
else	O
return	O
NULL	O
;	O
}	O
EXPORT	O
double	O
dwg_model_x_min	function
(	O
const	O
Dwg_Data	struct
*	O
dwg	pointer
)	O
{	O
assert	O
(	O
dwg	pointer
)	O
;	O
return	O
dwg	pointer
->	O
header_vars	struct
.	O
EXTMIN	struct
.	O
x	double
;	O
}	O
EXPORT	O
double	O
dwg_model_x_max	function
(	O
const	O
Dwg_Data	struct
*	O
dwg	pointer
)	O
{	O
assert	O
(	O
dwg	pointer
)	O
;	O
return	O
dwg	pointer
->	O
header_vars	struct
.	O
EXTMAX	struct
.	O
x	double
;	O
}	O
EXPORT	O
double	O
dwg_model_y_min	function
(	O
const	O
Dwg_Data	struct
*	O
dwg	pointer
)	O
{	O
assert	O
(	O
dwg	pointer
)	O
;	O
return	O
dwg	pointer
->	O
header_vars	struct
.	O
EXTMIN	struct
.	O
y	double
;	O
}	O
EXPORT	O
double	O
dwg_model_y_max	function
(	O
const	O
Dwg_Data	struct
*	O
dwg	pointer
)	O
{	O
assert	O
(	O
dwg	pointer
)	O
;	O
return	O
dwg	pointer
->	O
header_vars	struct
.	O
EXTMAX	struct
.	O
y	double
;	O
}	O
EXPORT	O
double	O
dwg_model_z_min	function
(	O
const	O
Dwg_Data	struct
*	O
dwg	pointer
)	O
{	O
assert	O
(	O
dwg	pointer
)	O
;	O
return	O
dwg	pointer
->	O
header_vars	struct
.	O
EXTMIN	struct
.	O
z	double
;	O
}	O
EXPORT	O
double	O
dwg_model_z_max	function
(	O
const	O
Dwg_Data	struct
*	O
dwg	pointer
)	O
{	O
assert	O
(	O
dwg	pointer
)	O
;	O
return	O
dwg	pointer
->	O
header_vars	struct
.	O
EXTMAX	struct
.	O
z	double
;	O
}	O
EXPORT	O
double	O
dwg_page_x_min	function
(	O
const	O
Dwg_Data	struct
*	O
dwg	pointer
)	O
{	O
assert	O
(	O
dwg	pointer
)	O
;	O
return	O
dwg	pointer
->	O
header_vars	struct
.	O
EXTMIN	struct
.	O
x	double
;	O
}	O
EXPORT	O
double	O
dwg_page_x_max	function
(	O
const	O
Dwg_Data	struct
*	O
dwg	pointer
)	O
{	O
assert	O
(	O
dwg	pointer
)	O
;	O
return	O
dwg	pointer
->	O
header_vars	struct
.	O
PEXTMAX	struct
.	O
x	double
;	O
}	O
EXPORT	O
double	O
dwg_page_y_min	function
(	O
const	O
Dwg_Data	struct
*	O
dwg	pointer
)	O
{	O
assert	O
(	O
dwg	pointer
)	O
;	O
return	O
dwg	pointer
->	O
header_vars	struct
.	O
PEXTMIN	struct
.	O
y	double
;	O
}	O
EXPORT	O
double	O
dwg_page_y_max	function
(	O
const	O
Dwg_Data	struct
*	O
dwg	pointer
)	O
{	O
assert	O
(	O
dwg	pointer
)	O
;	O
return	O
dwg	pointer
->	O
header_vars	struct
.	O
PEXTMAX	struct
.	O
y	double
;	O
}	O
EXPORT	O
unsigned	O
int	O
dwg_get_layer_count	function
(	O
const	O
Dwg_Data	struct
*	O
dwg	pointer
)	O
{	O
assert	O
(	O
dwg	pointer
)	O
;	O
return	O
dwg	pointer
->	O
layer_control	struct
.	O
num_entries	short
;	O
}	O
EXPORT	O
Dwg_Object_LAYER	struct
*	O
*	O
dwg_get_layers	function
(	O
const	O
Dwg_Data	struct
*	O
dwg	pointer
)	O
{	O
unsigned	O
int	O
i	int
;	O
unsigned	O
int	O
num_layers	int
=	O
dwg_get_layer_count	function
(	O
dwg	pointer
)	O
;	O
Dwg_Object_LAYER	struct
*	O
*	O
layers	pointer
;	O
assert	O
(	O
dwg	pointer
)	O
;	O
layers	pointer
=	O
(	O
Dwg_Object_LAYER	struct
*	O
*	O
)	O
calloc	function
(	O
num_layers	int
,	O
sizeof	O
(	O
Dwg_Object_LAYER	struct
*	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_layers	int
;	O
i	int
++	O
)	O
layers	pointer
[	O
i	int
]	O
=	O
dwg	pointer
->	O
layer_control	struct
.	O
entries	pointer
[	O
i	int
]	O
->	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
LAYER	pointer
;	O
return	O
layers	pointer
;	O
}	O
BITCODE_BL	int
dwg_get_object_num_objects	function
(	O
const	O
Dwg_Data	struct
*	O
dwg	pointer
)	O
{	O
assert	O
(	O
dwg	pointer
)	O
;	O
return	O
dwg	pointer
->	O
num_objects	int
-	O
dwg	pointer
->	O
num_entities	int
;	O
}	O
BITCODE_BL	int
dwg_get_num_objects	function
(	O
const	O
Dwg_Data	struct
*	O
dwg	pointer
)	O
{	O
assert	O
(	O
dwg	pointer
)	O
;	O
return	O
dwg	pointer
->	O
num_objects	int
;	O
}	O
BITCODE_BL	int
dwg_get_num_entities	function
(	O
const	O
Dwg_Data	struct
*	O
dwg	pointer
)	O
{	O
assert	O
(	O
dwg	pointer
)	O
;	O
return	O
dwg	pointer
->	O
num_entities	int
;	O
}	O
EXPORT	O
Dwg_Object_Entity	struct
*	O
*	O
dwg_get_entities	function
(	O
const	O
Dwg_Data	struct
*	O
dwg	pointer
)	O
{	O
BITCODE_BL	int
i	int
,	O
ent_count	int
=	O
0	int
;	O
Dwg_Object_Entity	struct
*	O
*	O
entities	pointer
;	O
assert	O
(	O
dwg	pointer
)	O
;	O
entities	pointer
=	O
(	O
Dwg_Object_Entity	struct
*	O
*	O
)	O
calloc	function
(	O
dwg_get_num_entities	function
(	O
dwg	pointer
)	O
,	O
sizeof	O
(	O
Dwg_Object_Entity	struct
*	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dwg	pointer
->	O
num_objects	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
dwg	pointer
->	O
object	pointer
[	O
i	int
]	O
.	O
supertype	enum
==	O
DWG_SUPERTYPE_ENTITY	int
)	O
{	O
entities	pointer
[	O
ent_count	int
]	O
=	O
dwg	pointer
->	O
object	pointer
[	O
i	int
]	O
.	O
tio	union
.	O
entity	long
;	O
ent_count	int
++	O
;	O
assert	O
(	O
ent_count	int
<	O
dwg	pointer
->	O
num_objects	int
)	O
;	O
}	O
}	O
return	O
entities	pointer
;	O
}	O
EXPORT	O
Dwg_Object_LAYER	struct
*	O
dwg_get_entity_layer	function
(	O
const	O
Dwg_Object_Entity	struct
*	O
ent	pointer
)	O
{	O
return	O
ent	pointer
->	O
layer	int
?	O
ent	pointer
->	O
layer	int
->	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
LAYER	pointer
:	O
NULL	O
;	O
}	O
EXPORT	O
Dwg_Object	struct
*	O
dwg_next_object	function
(	O
const	O
Dwg_Object	struct
*	O
obj	pointer
)	O
{	O
Dwg_Data	struct
*	O
dwg	pointer
;	O
if	O
(	O
!	O
obj	pointer
)	O
return	O
NULL	O
;	O
dwg	pointer
=	O
obj	pointer
->	O
parent	pointer
;	O
if	O
(	O
(	O
obj	pointer
->	O
index	short
+	O
1	int
)	O
>	O
(	O
dwg	pointer
->	O
num_objects	int
-	O
1	int
)	O
)	O
return	O
NULL	O
;	O
return	O
&	O
dwg	pointer
->	O
object	pointer
[	O
obj	pointer
->	O
index	short
+	O
1	int
]	O
;	O
}	O
EXPORT	O
Dwg_Object	struct
*	O
dwg_ref_object	function
(	O
const	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
Dwg_Object_Ref	struct
*	O
restrict	O
ref	pointer
)	O
{	O
if	O
(	O
!	O
ref	pointer
)	O
return	O
NULL	O
;	O
if	O
(	O
ref	pointer
->	O
obj	pointer
&&	O
!	O
dwg	pointer
->	O
dirty_refs	int
)	O
return	O
ref	pointer
->	O
obj	pointer
;	O
if	O
(	O
(	O
ref	pointer
->	O
handleref	struct
.	O
code	char
<	O
6	int
&&	O
dwg_resolve_handleref	function
(	O
ref	pointer
,	O
NULL	O
)	O
)	O
||	O
ref	pointer
->	O
absolute_ref	long
)	O
{	O
Dwg_Object	struct
*	O
obj	pointer
=	O
dwg_resolve_handle	function
(	O
dwg	pointer
,	O
ref	pointer
->	O
absolute_ref	long
)	O
;	O
if	O
(	O
!	O
dwg	pointer
->	O
dirty_refs	int
&&	O
obj	pointer
)	O
ref	pointer
->	O
obj	pointer
=	O
obj	pointer
;	O
return	O
obj	pointer
;	O
}	O
else	O
return	O
NULL	O
;	O
}	O
EXPORT	O
Dwg_Object	struct
*	O
dwg_ref_object_relative	function
(	O
const	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
Dwg_Object_Ref	struct
*	O
restrict	O
ref	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
if	O
(	O
ref	pointer
->	O
obj	pointer
&&	O
!	O
dwg	pointer
->	O
dirty_refs	int
)	O
return	O
ref	pointer
->	O
obj	pointer
;	O
if	O
(	O
dwg_resolve_handleref	function
(	O
ref	pointer
,	O
obj	pointer
)	O
)	O
{	O
Dwg_Object	struct
*	O
o	pointer
=	O
dwg_resolve_handle	function
(	O
dwg	pointer
,	O
ref	pointer
->	O
absolute_ref	long
)	O
;	O
if	O
(	O
!	O
dwg	pointer
->	O
dirty_refs	int
&&	O
o	pointer
)	O
ref	pointer
->	O
obj	pointer
=	O
o	pointer
;	O
return	O
o	pointer
;	O
}	O
else	O
return	O
NULL	O
;	O
}	O
EXPORT	O
Dwg_Object	struct
*	O
dwg_resolve_handle	function
(	O
const	O
Dwg_Data	struct
*	O
dwg	pointer
,	O
const	O
unsigned	O
long	O
absref	long
)	O
{	O
uint32_t	int
i	int
;	O
if	O
(	O
!	O
absref	long
)	O
return	O
NULL	O
;	O
i	int
=	O
hash_get	function
(	O
dwg	pointer
->	O
object_map	pointer
,	O
(	O
uint32_t	int
)	O
absref	long
)	O
;	O
if	O
(	O
i	int
!=	O
HASH_NOT_FOUND	O
)	O
LOG_HANDLE	O
(	O
"object_map{%lX} => %u\n"	pointer
,	O
absref	long
,	O
i	int
)	O
;	O
if	O
(	O
i	int
==	O
HASH_NOT_FOUND	O
||	O
(	O
BITCODE_BL	int
)	O
i	int
>=	O
dwg	pointer
->	O
num_objects	int
)	O
{	O
if	O
(	O
absref	long
&&	O
absref	long
<	O
dwg	pointer
->	O
num_objects	int
)	O
{	O
LOG_WARN	O
(	O
"Object handle not found, %lu/%lX in "	pointer
FORMAT_BL	O
" objects"	pointer
,	O
absref	long
,	O
absref	long
,	O
dwg	pointer
->	O
num_objects	int
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
return	O
&	O
dwg	pointer
->	O
object	pointer
[	O
i	int
]	O
;	O
}	O
EXPORT	O
Dwg_Object	struct
*	O
dwg_resolve_handle_silent	function
(	O
const	O
Dwg_Data	struct
*	O
dwg	pointer
,	O
const	O
BITCODE_BL	int
absref	long
)	O
{	O
uint32_t	int
i	int
;	O
if	O
(	O
!	O
absref	long
)	O
return	O
NULL	O
;	O
i	int
=	O
hash_get	function
(	O
dwg	pointer
->	O
object_map	pointer
,	O
(	O
uint32_t	int
)	O
absref	long
)	O
;	O
if	O
(	O
i	int
==	O
HASH_NOT_FOUND	O
||	O
(	O
BITCODE_BL	int
)	O
i	int
>=	O
dwg	pointer
->	O
num_objects	int
)	O
return	O
NULL	O
;	O
return	O
&	O
dwg	pointer
->	O
object	pointer
[	O
i	int
]	O
;	O
}	O
EXPORT	O
Dwg_Object	struct
*	O
dwg_ref_object_silent	function
(	O
const	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
Dwg_Object_Ref	struct
*	O
restrict	O
ref	pointer
)	O
{	O
if	O
(	O
!	O
ref	pointer
)	O
return	O
NULL	O
;	O
if	O
(	O
ref	pointer
->	O
obj	pointer
&&	O
!	O
dwg	pointer
->	O
dirty_refs	int
)	O
return	O
ref	pointer
->	O
obj	pointer
;	O
if	O
(	O
(	O
ref	pointer
->	O
handleref	struct
.	O
code	char
<	O
6	int
&&	O
dwg_resolve_handleref	function
(	O
(	O
Dwg_Object_Ref	struct
*	O
)	O
ref	pointer
,	O
NULL	O
)	O
)	O
||	O
ref	pointer
->	O
absolute_ref	long
)	O
{	O
Dwg_Object	struct
*	O
obj	pointer
=	O
dwg_resolve_handle_silent	function
(	O
dwg	pointer
,	O
ref	pointer
->	O
absolute_ref	long
)	O
;	O
if	O
(	O
!	O
dwg	pointer
->	O
dirty_refs	int
&&	O
obj	pointer
)	O
ref	pointer
->	O
obj	pointer
=	O
obj	pointer
;	O
return	O
obj	pointer
;	O
}	O
else	O
return	O
NULL	O
;	O
}	O
EXPORT	O
int	O
dwg_resolve_handleref	function
(	O
Dwg_Object_Ref	struct
*	O
restrict	O
ref	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
switch	O
(	O
ref	pointer
->	O
handleref	struct
.	O
code	char
)	O
{	O
case	O
6	int
:	O
ref	pointer
->	O
absolute_ref	long
=	O
(	O
obj	pointer
->	O
handle	pointer
.	O
value	double
+	O
1	int
)	O
;	O
break	O
;	O
case	O
8	int
:	O
ref	pointer
->	O
absolute_ref	long
=	O
(	O
obj	pointer
->	O
handle	pointer
.	O
value	double
-	O
1	int
)	O
;	O
break	O
;	O
case	O
10	int
:	O
ref	pointer
->	O
absolute_ref	long
=	O
(	O
obj	pointer
->	O
handle	pointer
.	O
value	double
+	O
ref	pointer
->	O
handleref	struct
.	O
value	double
)	O
;	O
break	O
;	O
case	O
12	int
:	O
ref	pointer
->	O
absolute_ref	long
=	O
(	O
obj	pointer
->	O
handle	pointer
.	O
value	double
-	O
ref	pointer
->	O
handleref	struct
.	O
value	double
)	O
;	O
break	O
;	O
case	O
2	int
:	O
case	O
3	int
:	O
case	O
4	int
:	O
case	O
5	int
:	O
ref	pointer
->	O
absolute_ref	long
=	O
ref	pointer
->	O
handleref	struct
.	O
value	double
;	O
break	O
;	O
case	O
0	int
:	O
ref	pointer
->	O
absolute_ref	long
=	O
ref	pointer
->	O
handleref	struct
.	O
value	double
;	O
break	O
;	O
default	O
:	O
ref	pointer
->	O
absolute_ref	long
=	O
ref	pointer
->	O
handleref	struct
.	O
value	double
;	O
LOG_WARN	O
(	O
"Invalid handle pointer code %d"	pointer
,	O
ref	pointer
->	O
handleref	struct
.	O
code	char
)	O
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
EXPORT	O
Dwg_Object_BLOCK_CONTROL	struct
*	O
dwg_block_control	function
(	O
Dwg_Data	struct
*	O
dwg	pointer
)	O
{	O
if	O
(	O
!	O
dwg	pointer
->	O
block_control	struct
.	O
parent	pointer
)	O
{	O
LOG_ERROR	O
(	O
"dwg->block_control missing"	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
&	O
(	O
dwg	pointer
->	O
block_control	struct
)	O
;	O
}	O
EXPORT	O
Dwg_Object_Ref	struct
*	O
dwg_model_space_ref	function
(	O
Dwg_Data	struct
*	O
dwg	pointer
)	O
{	O
if	O
(	O
dwg	pointer
->	O
header_vars	struct
.	O
BLOCK_RECORD_MSPACE	pointer
&&	O
dwg	pointer
->	O
header_vars	struct
.	O
BLOCK_RECORD_MSPACE	pointer
->	O
obj	pointer
)	O
return	O
dwg	pointer
->	O
header_vars	struct
.	O
BLOCK_RECORD_MSPACE	pointer
;	O
return	O
dwg	pointer
->	O
block_control	struct
.	O
model_space	pointer
&&	O
dwg	pointer
->	O
block_control	struct
.	O
model_space	pointer
->	O
obj	pointer
?	O
dwg	pointer
->	O
block_control	struct
.	O
model_space	pointer
:	O
NULL	O
;	O
}	O
EXPORT	O
Dwg_Object_Ref	struct
*	O
dwg_paper_space_ref	function
(	O
Dwg_Data	struct
*	O
dwg	pointer
)	O
{	O
if	O
(	O
dwg	pointer
->	O
header_vars	struct
.	O
BLOCK_RECORD_PSPACE	pointer
&&	O
dwg	pointer
->	O
header_vars	struct
.	O
BLOCK_RECORD_PSPACE	pointer
->	O
obj	pointer
)	O
return	O
dwg	pointer
->	O
header_vars	struct
.	O
BLOCK_RECORD_PSPACE	pointer
;	O
return	O
dwg	pointer
->	O
block_control	struct
.	O
paper_space	pointer
&&	O
dwg	pointer
->	O
block_control	struct
.	O
paper_space	pointer
->	O
obj	pointer
?	O
dwg	pointer
->	O
block_control	struct
.	O
paper_space	pointer
:	O
NULL	O
;	O
}	O
EXPORT	O
Dwg_Object	struct
*	O
dwg_model_space_object	function
(	O
Dwg_Data	struct
*	O
dwg	pointer
)	O
{	O
Dwg_Object_Ref	struct
*	O
msref	pointer
=	O
dwg_model_space_ref	function
(	O
dwg	pointer
)	O
;	O
Dwg_Object_BLOCK_CONTROL	struct
*	O
ctrl	pointer
;	O
if	O
(	O
msref	pointer
&&	O
msref	pointer
->	O
obj	pointer
&&	O
msref	pointer
->	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_BLOCK_HEADER	int
)	O
return	O
msref	pointer
->	O
obj	pointer
;	O
ctrl	pointer
=	O
dwg_block_control	function
(	O
dwg	pointer
)	O
;	O
if	O
(	O
ctrl	pointer
&&	O
ctrl	pointer
->	O
model_space	pointer
&&	O
ctrl	pointer
->	O
model_space	pointer
->	O
obj	pointer
)	O
return	O
ctrl	pointer
->	O
model_space	pointer
->	O
obj	pointer
;	O
if	O
(	O
dwg	pointer
->	O
header_vars	struct
.	O
BLOCK_RECORD_MSPACE	pointer
&&	O
dwg	pointer
->	O
header_vars	struct
.	O
BLOCK_RECORD_MSPACE	pointer
->	O
obj	pointer
)	O
return	O
dwg	pointer
->	O
header_vars	struct
.	O
BLOCK_RECORD_MSPACE	pointer
->	O
obj	pointer
;	O
return	O
dwg_resolve_handle	function
(	O
dwg	pointer
,	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_2000	int
?	O
0x1F	int
:	O
0x17	int
)	O
;	O
}	O
EXPORT	O
Dwg_Object	struct
*	O
get_first_owned_entity	function
(	O
const	O
Dwg_Object	struct
*	O
hdr	pointer
)	O
{	O
unsigned	O
int	O
version	short
=	O
hdr	pointer
->	O
parent	pointer
->	O
header	struct
.	O
version	short
;	O
Dwg_Object_BLOCK_HEADER	struct
*	O
_hdr	pointer
=	O
hdr	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
BLOCK_HEADER	pointer
;	O
if	O
(	O
hdr	pointer
->	O
type	short
!=	O
DWG_TYPE_BLOCK_HEADER	int
)	O
{	O
LOG_ERROR	O
(	O
"Invalid BLOCK_HEADER type %d"	pointer
,	O
hdr	pointer
->	O
type	short
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
R_13	int
<=	O
version	short
&&	O
version	short
<=	O
R_2000	int
)	O
{	O
return	O
_hdr	pointer
->	O
first_entity	pointer
?	O
_hdr	pointer
->	O
first_entity	pointer
->	O
obj	pointer
:	O
NULL	O
;	O
}	O
else	O
if	O
(	O
version	short
>=	O
R_2004	int
)	O
{	O
_hdr	pointer
->	O
__iterator	int
=	O
0	int
;	O
if	O
(	O
_hdr	pointer
->	O
entities	pointer
&&	O
_hdr	pointer
->	O
num_owned	int
&&	O
_hdr	pointer
->	O
entities	pointer
[	O
0	int
]	O
)	O
return	O
_hdr	pointer
->	O
entities	pointer
[	O
0	int
]	O
->	O
obj	pointer
;	O
else	O
return	O
NULL	O
;	O
}	O
LOG_ERROR	O
(	O
"Unsupported version: %d\n"	pointer
,	O
version	short
)	O
;	O
return	O
NULL	O
;	O
}	O
EXPORT	O
Dwg_Object	struct
*	O
get_next_owned_entity	function
(	O
const	O
Dwg_Object	struct
*	O
restrict	O
hdr	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
current	pointer
)	O
{	O
unsigned	O
int	O
version	short
=	O
hdr	pointer
->	O
parent	pointer
->	O
header	struct
.	O
version	short
;	O
Dwg_Object_BLOCK_HEADER	struct
*	O
_hdr	pointer
=	O
hdr	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
BLOCK_HEADER	pointer
;	O
if	O
(	O
hdr	pointer
->	O
type	short
!=	O
DWG_TYPE_BLOCK_HEADER	int
)	O
{	O
LOG_ERROR	O
(	O
"Invalid BLOCK_HEADER type %d"	pointer
,	O
hdr	pointer
->	O
type	short
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
R_13	int
<=	O
version	short
&&	O
version	short
<=	O
R_2000	int
)	O
{	O
Dwg_Object	struct
*	O
obj	pointer
;	O
if	O
(	O
_hdr	pointer
->	O
last_entity	pointer
==	O
NULL	O
||	O
current	pointer
==	O
_hdr	pointer
->	O
last_entity	pointer
->	O
obj	pointer
)	O
return	O
NULL	O
;	O
obj	pointer
=	O
dwg_next_object	function
(	O
current	pointer
)	O
;	O
while	O
(	O
obj	pointer
&&	O
(	O
obj	pointer
->	O
supertype	enum
!=	O
DWG_SUPERTYPE_ENTITY	int
||	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_ATTDEF	int
||	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_ATTRIB	int
||	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_VERTEX_2D	int
||	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_VERTEX_3D	int
||	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_VERTEX_MESH	int
||	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_VERTEX_PFACE	int
||	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_VERTEX_PFACE_FACE	int
)	O
)	O
{	O
obj	pointer
=	O
dwg_next_object	function
(	O
obj	pointer
)	O
;	O
if	O
(	O
obj	pointer
&&	O
obj	pointer
->	O
supertype	enum
==	O
DWG_SUPERTYPE_ENTITY	int
&&	O
obj	pointer
->	O
tio	union
.	O
entity	long
!=	O
NULL	O
&&	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
ownerhandle	pointer
!=	O
NULL	O
&&	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
ownerhandle	pointer
->	O
absolute_ref	long
!=	O
hdr	pointer
->	O
handle	pointer
.	O
value	double
)	O
obj	pointer
=	O
NULL	O
;	O
if	O
(	O
obj	pointer
==	O
_hdr	pointer
->	O
last_entity	pointer
->	O
obj	pointer
)	O
return	O
obj	pointer
;	O
}	O
return	O
obj	pointer
;	O
}	O
else	O
if	O
(	O
version	short
>=	O
R_2004	int
)	O
{	O
Dwg_Object_Ref	struct
*	O
ref	pointer
;	O
_hdr	pointer
->	O
__iterator	int
++	O
;	O
if	O
(	O
_hdr	pointer
->	O
__iterator	int
==	O
_hdr	pointer
->	O
num_owned	int
)	O
return	O
NULL	O
;	O
ref	pointer
=	O
_hdr	pointer
->	O
entities	pointer
?	O
_hdr	pointer
->	O
entities	pointer
[	O
_hdr	pointer
->	O
__iterator	int
]	O
:	O
NULL	O
;	O
return	O
ref	pointer
?	O
ref	pointer
->	O
obj	pointer
:	O
NULL	O
;	O
}	O
LOG_ERROR	O
(	O
"Unsupported version: %d\n"	pointer
,	O
version	short
)	O
;	O
return	O
NULL	O
;	O
}	O
EXPORT	O
Dwg_Object	struct
*	O
get_first_owned_subentity	function
(	O
const	O
Dwg_Object	struct
*	O
owner	pointer
)	O
{	O
unsigned	O
int	O
version	short
=	O
owner	pointer
->	O
parent	pointer
->	O
header	struct
.	O
version	short
;	O
const	O
unsigned	O
int	O
type	short
=	O
owner	pointer
->	O
type	short
;	O
if	O
(	O
type	short
==	O
DWG_TYPE_INSERT	int
)	O
{	O
Dwg_Entity_INSERT	struct
*	O
_obj	pointer
=	O
owner	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
INSERT	pointer
;	O
if	O
(	O
version	short
<=	O
R_2000	int
)	O
return	O
_obj	pointer
->	O
first_attrib	pointer
?	O
_obj	pointer
->	O
first_attrib	pointer
->	O
obj	pointer
:	O
NULL	O
;	O
else	O
return	O
_obj	pointer
->	O
attrib_handles	pointer
&&	O
_obj	pointer
->	O
attrib_handles	pointer
[	O
0	int
]	O
?	O
_obj	pointer
->	O
attrib_handles	pointer
[	O
0	int
]	O
->	O
obj	pointer
:	O
NULL	O
;	O
}	O
else	O
if	O
(	O
type	short
==	O
DWG_TYPE_MINSERT	int
)	O
{	O
Dwg_Entity_MINSERT	struct
*	O
_obj	pointer
=	O
owner	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
MINSERT	pointer
;	O
if	O
(	O
version	short
<=	O
R_2000	int
)	O
return	O
_obj	pointer
->	O
first_attrib	pointer
?	O
_obj	pointer
->	O
first_attrib	pointer
->	O
obj	pointer
:	O
NULL	O
;	O
else	O
return	O
_obj	pointer
->	O
attrib_handles	pointer
&&	O
_obj	pointer
->	O
attrib_handles	pointer
[	O
0	int
]	O
?	O
_obj	pointer
->	O
attrib_handles	pointer
[	O
0	int
]	O
->	O
obj	pointer
:	O
NULL	O
;	O
}	O
else	O
if	O
(	O
type	short
==	O
DWG_TYPE_POLYLINE_2D	int
||	O
type	short
==	O
DWG_TYPE_POLYLINE_3D	int
||	O
type	short
==	O
DWG_TYPE_POLYLINE_PFACE	int
||	O
type	short
==	O
DWG_TYPE_POLYLINE_MESH	int
)	O
{	O
Dwg_Entity_POLYLINE_2D	struct
*	O
_obj	pointer
=	O
owner	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
POLYLINE_2D	pointer
;	O
if	O
(	O
version	short
<=	O
R_2000	int
)	O
return	O
_obj	pointer
->	O
first_vertex	pointer
?	O
_obj	pointer
->	O
first_vertex	pointer
->	O
obj	pointer
:	O
NULL	O
;	O
else	O
return	O
_obj	pointer
->	O
vertex	pointer
&&	O
_obj	pointer
->	O
vertex	pointer
[	O
0	int
]	O
?	O
_obj	pointer
->	O
vertex	pointer
[	O
0	int
]	O
->	O
obj	pointer
:	O
NULL	O
;	O
}	O
else	O
{	O
LOG_ERROR	O
(	O
"Wrong type %d, has no subentity"	pointer
,	O
type	short
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
EXPORT	O
Dwg_Object	struct
*	O
get_next_owned_subentity	function
(	O
const	O
Dwg_Object	struct
*	O
restrict	O
owner	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
current	pointer
)	O
{	O
Dwg_Version_Type	enum
version	short
=	O
owner	pointer
->	O
parent	pointer
->	O
header	struct
.	O
version	short
;	O
const	O
Dwg_Object_Type	enum
type	short
=	O
owner	pointer
->	O
type	short
;	O
Dwg_Object_Entity	struct
*	O
ent	pointer
=	O
owner	pointer
->	O
tio	union
.	O
entity	long
;	O
Dwg_Object	struct
*	O
obj	pointer
=	O
dwg_next_object	function
(	O
current	pointer
)	O
;	O
if	O
(	O
type	short
==	O
DWG_TYPE_INSERT	int
)	O
{	O
Dwg_Entity_INSERT	struct
*	O
_obj	pointer
=	O
owner	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
INSERT	pointer
;	O
if	O
(	O
version	short
<=	O
R_2000	int
)	O
return	O
(	O
_obj	pointer
->	O
last_attrib	pointer
&&	O
current	pointer
!=	O
_obj	pointer
->	O
last_attrib	pointer
->	O
obj	pointer
&&	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_ATTRIB	int
)	O
?	O
obj	pointer
:	O
NULL	O
;	O
else	O
{	O
ent	pointer
->	O
__iterator	int
++	O
;	O
if	O
(	O
ent	pointer
->	O
__iterator	int
==	O
_obj	pointer
->	O
num_owned	int
)	O
{	O
ent	pointer
->	O
__iterator	int
=	O
0	int
;	O
return	O
NULL	O
;	O
}	O
else	O
return	O
_obj	pointer
->	O
attrib_handles	pointer
?	O
_obj	pointer
->	O
attrib_handles	pointer
[	O
ent	pointer
->	O
__iterator	int
]	O
->	O
obj	pointer
:	O
NULL	O
;	O
}	O
}	O
else	O
if	O
(	O
type	short
==	O
DWG_TYPE_MINSERT	int
)	O
{	O
Dwg_Entity_MINSERT	struct
*	O
_obj	pointer
=	O
owner	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
MINSERT	pointer
;	O
if	O
(	O
version	short
<=	O
R_2000	int
)	O
return	O
(	O
_obj	pointer
->	O
last_attrib	pointer
&&	O
current	pointer
!=	O
_obj	pointer
->	O
last_attrib	pointer
->	O
obj	pointer
&&	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_ATTRIB	int
)	O
?	O
obj	pointer
:	O
NULL	O
;	O
else	O
{	O
ent	pointer
->	O
__iterator	int
++	O
;	O
if	O
(	O
ent	pointer
->	O
__iterator	int
==	O
_obj	pointer
->	O
num_owned	int
)	O
{	O
ent	pointer
->	O
__iterator	int
=	O
0	int
;	O
return	O
NULL	O
;	O
}	O
else	O
return	O
_obj	pointer
->	O
attrib_handles	pointer
?	O
_obj	pointer
->	O
attrib_handles	pointer
[	O
ent	pointer
->	O
__iterator	int
]	O
->	O
obj	pointer
:	O
NULL	O
;	O
}	O
}	O
else	O
if	O
(	O
type	short
==	O
DWG_TYPE_POLYLINE_2D	int
||	O
type	short
==	O
DWG_TYPE_POLYLINE_3D	int
||	O
type	short
==	O
DWG_TYPE_POLYLINE_PFACE	int
||	O
type	short
==	O
DWG_TYPE_POLYLINE_MESH	int
)	O
{	O
Dwg_Entity_POLYLINE_2D	struct
*	O
_obj	pointer
=	O
owner	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
POLYLINE_2D	pointer
;	O
if	O
(	O
version	short
<=	O
R_2000	int
)	O
return	O
(	O
_obj	pointer
->	O
last_vertex	pointer
&&	O
current	pointer
!=	O
_obj	pointer
->	O
last_vertex	pointer
->	O
obj	pointer
)	O
?	O
obj	pointer
:	O
NULL	O
;	O
else	O
{	O
ent	pointer
->	O
__iterator	int
++	O
;	O
if	O
(	O
ent	pointer
->	O
__iterator	int
==	O
_obj	pointer
->	O
num_owned	int
)	O
{	O
ent	pointer
->	O
__iterator	int
=	O
0	int
;	O
return	O
NULL	O
;	O
}	O
else	O
return	O
_obj	pointer
->	O
vertex	pointer
?	O
_obj	pointer
->	O
vertex	pointer
[	O
ent	pointer
->	O
__iterator	int
]	O
->	O
obj	pointer
:	O
NULL	O
;	O
}	O
}	O
else	O
{	O
LOG_ERROR	O
(	O
"Wrong type %d, has no subentity"	pointer
,	O
type	short
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
EXPORT	O
Dwg_Object	struct
*	O
get_first_owned_block	function
(	O
const	O
Dwg_Object	struct
*	O
hdr	pointer
)	O
{	O
unsigned	O
int	O
version	short
=	O
hdr	pointer
->	O
parent	pointer
->	O
header	struct
.	O
version	short
;	O
const	O
Dwg_Object_BLOCK_HEADER	struct
*	O
restrict	O
_hdr	pointer
=	O
hdr	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
BLOCK_HEADER	pointer
;	O
if	O
(	O
hdr	pointer
->	O
type	short
!=	O
DWG_TYPE_BLOCK_HEADER	int
)	O
{	O
LOG_ERROR	O
(	O
"Invalid BLOCK_HEADER type %d"	pointer
,	O
hdr	pointer
->	O
type	short
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
version	short
>=	O
R_13	int
)	O
{	O
if	O
(	O
_hdr	pointer
->	O
block_entity	pointer
)	O
return	O
_hdr	pointer
->	O
block_entity	pointer
->	O
obj	pointer
;	O
else	O
{	O
Dwg_Object	struct
*	O
obj	pointer
=	O
(	O
Dwg_Object	struct
*	O
)	O
hdr	pointer
;	O
while	O
(	O
obj	pointer
&&	O
obj	pointer
->	O
type	short
!=	O
DWG_TYPE_BLOCK	int
)	O
obj	pointer
=	O
dwg_next_object	function
(	O
obj	pointer
)	O
;	O
return	O
obj	pointer
;	O
}	O
}	O
LOG_ERROR	O
(	O
"Unsupported version: %d\n"	pointer
,	O
version	short
)	O
;	O
return	O
NULL	O
;	O
}	O
EXPORT	O
Dwg_Object	struct
*	O
get_next_owned_block	function
(	O
const	O
Dwg_Object	struct
*	O
restrict	O
hdr	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
current	pointer
)	O
{	O
unsigned	O
int	O
version	short
=	O
hdr	pointer
->	O
parent	pointer
->	O
header	struct
.	O
version	short
;	O
const	O
Dwg_Object_BLOCK_HEADER	struct
*	O
restrict	O
_hdr	pointer
=	O
hdr	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
BLOCK_HEADER	pointer
;	O
if	O
(	O
hdr	pointer
->	O
type	short
!=	O
DWG_TYPE_BLOCK_HEADER	int
)	O
{	O
LOG_ERROR	O
(	O
"Invalid BLOCK_HEADER type %d"	pointer
,	O
hdr	pointer
->	O
type	short
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
version	short
>=	O
R_13	int
)	O
{	O
if	O
(	O
!	O
_hdr	pointer
->	O
endblk_entity	pointer
||	O
current	pointer
==	O
_hdr	pointer
->	O
endblk_entity	pointer
->	O
obj	pointer
)	O
return	O
NULL	O
;	O
return	O
dwg_next_object	function
(	O
current	pointer
)	O
;	O
}	O
LOG_ERROR	O
(	O
"Unsupported version: %d\n"	pointer
,	O
version	short
)	O
;	O
return	O
NULL	O
;	O
}	O
EXPORT	O
Dwg_Object	struct
*	O
get_last_owned_block	function
(	O
const	O
Dwg_Object	struct
*	O
restrict	O
hdr	pointer
)	O
{	O
Dwg_Data	struct
*	O
dwg	pointer
=	O
hdr	pointer
->	O
parent	pointer
;	O
Dwg_Object_BLOCK_HEADER	struct
*	O
restrict	O
_hdr	pointer
=	O
hdr	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
BLOCK_HEADER	pointer
;	O
unsigned	O
int	O
version	short
=	O
dwg	pointer
->	O
header	struct
.	O
version	short
;	O
if	O
(	O
hdr	pointer
->	O
type	short
!=	O
DWG_TYPE_BLOCK_HEADER	int
)	O
{	O
LOG_ERROR	O
(	O
"Invalid BLOCK_HEADER type %d"	pointer
,	O
hdr	pointer
->	O
type	short
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
version	short
>=	O
R_13	int
)	O
{	O
if	O
(	O
_hdr	pointer
->	O
endblk_entity	pointer
&&	O
_hdr	pointer
->	O
endblk_entity	pointer
->	O
obj	pointer
)	O
return	O
_hdr	pointer
->	O
endblk_entity	pointer
->	O
obj	pointer
;	O
else	O
{	O
Dwg_Object	struct
*	O
obj	pointer
=	O
(	O
Dwg_Object	struct
*	O
)	O
hdr	pointer
;	O
while	O
(	O
obj	pointer
&&	O
obj	pointer
->	O
type	short
!=	O
DWG_TYPE_ENDBLK	int
)	O
obj	pointer
=	O
dwg_next_object	function
(	O
obj	pointer
)	O
;	O
if	O
(	O
obj	pointer
&&	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_ENDBLK	int
)	O
{	O
if	O
(	O
!	O
_hdr	pointer
->	O
endblk_entity	pointer
)	O
{	O
_hdr	pointer
->	O
endblk_entity	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
Dwg_Object_Ref	struct
)	O
)	O
;	O
if	O
(	O
_hdr	pointer
->	O
endblk_entity	pointer
)	O
{	O
_hdr	pointer
->	O
endblk_entity	pointer
->	O
obj	pointer
=	O
obj	pointer
;	O
_hdr	pointer
->	O
endblk_entity	pointer
->	O
handleref	struct
.	O
value	double
=	O
_hdr	pointer
->	O
endblk_entity	pointer
->	O
absolute_ref	long
=	O
obj	pointer
->	O
handle	pointer
.	O
value	double
;	O
}	O
}	O
else	O
if	O
(	O
!	O
_hdr	pointer
->	O
endblk_entity	pointer
->	O
obj	pointer
)	O
_hdr	pointer
->	O
endblk_entity	pointer
->	O
obj	pointer
=	O
obj	pointer
;	O
}	O
return	O
obj	pointer
;	O
}	O
}	O
LOG_ERROR	O
(	O
"Unsupported version: %d\n"	pointer
,	O
version	short
)	O
;	O
return	O
NULL	O
;	O
}	O
EXPORT	O
int	O
dwg_class_is_entity	function
(	O
const	O
Dwg_Class	struct
*	O
restrict	O
klass	pointer
)	O
{	O
return	O
(	O
klass	pointer
!=	O
NULL	O
&&	O
(	O
int	O
)	O
klass	pointer
->	O
item_class_id	short
==	O
0x1f2	int
)	O
?	O
1	int
:	O
0	int
;	O
}	O
EXPORT	O
int	O
dwg_obj_is_control	function
(	O
const	O
Dwg_Object	struct
*	O
obj	pointer
)	O
{	O
const	O
unsigned	O
int	O
type	short
=	O
obj	pointer
->	O
type	short
;	O
return	O
(	O
obj	pointer
->	O
supertype	enum
==	O
DWG_SUPERTYPE_OBJECT	int
)	O
&&	O
(	O
type	short
==	O
DWG_TYPE_BLOCK_CONTROL	int
||	O
type	short
==	O
DWG_TYPE_LAYER_CONTROL	int
||	O
type	short
==	O
DWG_TYPE_STYLE_CONTROL	int
||	O
type	short
==	O
DWG_TYPE_LTYPE_CONTROL	int
||	O
type	short
==	O
DWG_TYPE_VIEW_CONTROL	int
||	O
type	short
==	O
DWG_TYPE_UCS_CONTROL	int
||	O
type	short
==	O
DWG_TYPE_VPORT_CONTROL	int
||	O
type	short
==	O
DWG_TYPE_APPID_CONTROL	int
||	O
type	short
==	O
DWG_TYPE_DIMSTYLE_CONTROL	int
||	O
type	short
==	O
DWG_TYPE_VPORT_ENTITY_CONTROL	int
)	O
;	O
}	O
EXPORT	O
int	O
dwg_obj_is_table	function
(	O
const	O
Dwg_Object	struct
*	O
obj	pointer
)	O
{	O
const	O
unsigned	O
int	O
type	short
=	O
obj	pointer
->	O
type	short
;	O
return	O
(	O
obj	pointer
->	O
supertype	enum
==	O
DWG_SUPERTYPE_OBJECT	int
)	O
&&	O
(	O
type	short
==	O
DWG_TYPE_BLOCK_HEADER	int
||	O
type	short
==	O
DWG_TYPE_LAYER	int
||	O
type	short
==	O
DWG_TYPE_STYLE	int
||	O
type	short
==	O
DWG_TYPE_LTYPE	int
||	O
type	short
==	O
DWG_TYPE_VIEW	int
||	O
type	short
==	O
DWG_TYPE_UCS	int
||	O
type	short
==	O
DWG_TYPE_VPORT	int
||	O
type	short
==	O
DWG_TYPE_APPID	int
||	O
type	short
==	O
DWG_TYPE_DIMSTYLE	int
||	O
type	short
==	O
DWG_TYPE_VPORT_ENTITY_HEADER	int
)	O
;	O
}	O
EXPORT	O
int	O
dwg_obj_is_subentity	function
(	O
const	O
Dwg_Object	struct
*	O
obj	pointer
)	O
{	O
const	O
unsigned	O
int	O
type	short
=	O
obj	pointer
->	O
type	short
;	O
return	O
(	O
obj	pointer
->	O
supertype	enum
==	O
DWG_SUPERTYPE_ENTITY	int
)	O
&&	O
(	O
type	short
==	O
DWG_TYPE_ATTRIB	int
||	O
type	short
==	O
DWG_TYPE_VERTEX_2D	int
||	O
type	short
==	O
DWG_TYPE_VERTEX_3D	int
||	O
type	short
==	O
DWG_TYPE_VERTEX_MESH	int
||	O
type	short
==	O
DWG_TYPE_VERTEX_PFACE	int
||	O
type	short
==	O
DWG_TYPE_VERTEX_PFACE_FACE	int
)	O
;	O
}	O
EXPORT	O
int	O
dwg_obj_has_subentity	function
(	O
const	O
Dwg_Object	struct
*	O
obj	pointer
)	O
{	O
const	O
unsigned	O
int	O
type	short
=	O
obj	pointer
->	O
type	short
;	O
return	O
(	O
obj	pointer
->	O
supertype	enum
==	O
DWG_SUPERTYPE_ENTITY	int
)	O
&&	O
(	O
type	short
==	O
DWG_TYPE_INSERT	int
||	O
type	short
==	O
DWG_TYPE_MINSERT	int
||	O
type	short
==	O
DWG_TYPE_POLYLINE_2D	int
||	O
type	short
==	O
DWG_TYPE_POLYLINE_3D	int
||	O
type	short
==	O
DWG_TYPE_POLYLINE_PFACE	int
||	O
type	short
==	O
DWG_TYPE_POLYLINE_MESH	int
)	O
;	O
}	O
EXPORT	O
Dwg_Section_Type	enum
dwg_section_type	function
(	O
const	O
DWGCHAR	O
*	O
wname	pointer
)	O
{	O
DWGCHAR	O
*	O
wp	pointer
;	O
char	O
name	pointer
[	O
24	int
]	O
;	O
uint16_t	short
c	short
;	O
int	O
i	int
=	O
0	int
;	O
if	O
(	O
wname	pointer
==	O
NULL	O
)	O
return	O
SECTION_UNKNOWN	int
;	O
wp	pointer
=	O
(	O
DWGCHAR	O
*	O
)	O
wname	pointer
;	O
while	O
(	O
(	O
c	short
=	O
*	O
wp	pointer
++	O
)	O
)	O
{	O
name	pointer
[	O
i	int
++	O
]	O
=	O
(	O
char	O
)	O
(	O
c	short
&	O
0xff	int
)	O
;	O
}	O
name	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"AcDb:Header"	pointer
)	O
)	O
{	O
return	O
SECTION_HEADER	int
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"AcDb:Classes"	pointer
)	O
)	O
{	O
return	O
SECTION_CLASSES	int
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"AcDb:SummaryInfo"	pointer
)	O
)	O
{	O
return	O
SECTION_SUMMARYINFO	int
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"AcDb:Preview"	pointer
)	O
)	O
{	O
return	O
SECTION_PREVIEW	int
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"AcDb:VBAProject"	pointer
)	O
)	O
{	O
return	O
SECTION_VBAPROJECT	int
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"AcDb:AppInfo"	pointer
)	O
)	O
{	O
return	O
SECTION_APPINFO	int
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"AcDb:FileDepList"	pointer
)	O
)	O
{	O
return	O
SECTION_FILEDEPLIST	int
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"AcDb:RevHistory"	pointer
)	O
)	O
{	O
return	O
SECTION_REVHISTORY	int
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"AcDb:Security"	pointer
)	O
)	O
{	O
return	O
SECTION_SECURITY	int
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"AcDb:AcDbObjects"	pointer
)	O
)	O
{	O
return	O
SECTION_OBJECTS	int
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"AcDb:ObjFreeSpace"	pointer
)	O
)	O
{	O
return	O
SECTION_OBJFREESPACE	int
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"AcDb:Template"	pointer
)	O
)	O
{	O
return	O
SECTION_TEMPLATE	int
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"AcDb:Handles"	pointer
)	O
)	O
{	O
return	O
SECTION_HANDLES	int
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"AcDb:AcDsPrototype_1b"	pointer
)	O
)	O
{	O
return	O
SECTION_PROTOTYPE	int
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"AcDb:AuxHeader"	pointer
)	O
)	O
{	O
return	O
SECTION_AUXHEADER	int
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"AcDb:Signature"	pointer
)	O
)	O
{	O
return	O
SECTION_SIGNATURE	int
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"AcDb:AppInfoHistory"	pointer
)	O
)	O
{	O
return	O
SECTION_APPINFOHISTORY	int
;	O
}	O
return	O
SECTION_UNKNOWN	int
;	O
}	O
const	O
int	O
lweights	array
[	O
]	O
=	O
{	O
0	int
,	O
5	int
,	O
9	int
,	O
13	int
,	O
15	int
,	O
18	int
,	O
20	int
,	O
25	int
,	O
30	int
,	O
35	int
,	O
40	int
,	O
50	int
,	O
53	int
,	O
60	int
,	O
70	int
,	O
80	int
,	O
90	int
,	O
100	int
,	O
106	int
,	O
120	int
,	O
140	int
,	O
158	int
,	O
200	int
,	O
211	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
-	O
1	int
,	O
-	O
2	int
,	O
-	O
3	int
}	O
;	O
EXPORT	O
int	O
dxf_cvt_lweight	function
(	O
const	O
BITCODE_BSd	short
value	double
)	O
{	O
return	O
lweights	array
[	O
value	double
%	O
32	int
]	O
;	O
}	O
EXPORT	O
BITCODE_BSd	short
dxf_revcvt_lweight	function
(	O
const	O
int	O
lw	int
)	O
{	O
for	O
(	O
BITCODE_BSd	short
i	int
=	O
0	int
;	O
i	int
<	O
(	O
BITCODE_BSd	short
)	O
ARRAY_SIZE	O
(	O
lweights	array
)	O
;	O
i	int
++	O
)	O
if	O
(	O
lweights	array
[	O
i	int
]	O
==	O
lw	int
)	O
return	O
i	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
set_handle_size	function
(	O
Dwg_Handle	struct
*	O
restrict	O
hdl	array
)	O
{	O
if	O
(	O
hdl	array
->	O
value	double
)	O
{	O
int	O
i	int
;	O
unsigned	O
char	O
*	O
val	pointer
;	O
memset	function
(	O
&	O
val	pointer
,	O
0	int
,	O
sizeof	O
(	O
val	pointer
)	O
)	O
;	O
val	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
&	O
hdl	array
->	O
value	double
;	O
for	O
(	O
i	int
=	O
sizeof	O
(	O
val	pointer
)	O
-	O
1	int
;	O
i	int
>=	O
0	int
;	O
i	int
--	O
)	O
if	O
(	O
val	pointer
[	O
i	int
]	O
)	O
break	O
;	O
hdl	array
->	O
size	char
=	O
i	int
+	O
1	int
;	O
}	O
else	O
hdl	array
->	O
size	char
=	O
0	int
;	O
}	O
EXPORT	O
int	O
dwg_add_handle	function
(	O
Dwg_Handle	struct
*	O
restrict	O
hdl	array
,	O
BITCODE_RC	char
code	char
,	O
unsigned	O
long	O
value	double
,	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
int	O
offset	double
=	O
obj	pointer
?	O
(	O
value	double
-	O
(	O
int	O
)	O
obj	pointer
->	O
handle	pointer
.	O
value	double
)	O
:	O
0	int
;	O
hdl	array
->	O
code	char
=	O
code	char
;	O
hdl	array
->	O
value	double
=	O
value	double
;	O
if	O
(	O
obj	pointer
&&	O
!	O
offset	double
&&	O
value	double
)	O
{	O
LOG_HANDLE	O
(	O
"object_map{%lX} = %u\n"	pointer
,	O
value	double
,	O
obj	pointer
->	O
index	short
)	O
;	O
hash_set	function
(	O
obj	pointer
->	O
parent	pointer
->	O
object_map	pointer
,	O
value	double
,	O
(	O
uint32_t	int
)	O
obj	pointer
->	O
index	short
)	O
;	O
}	O
set_handle_size	function
(	O
hdl	array
)	O
;	O
if	O
(	O
code	char
==	O
4	int
&&	O
obj	pointer
&&	O
value	double
)	O
{	O
if	O
(	O
offset	double
==	O
1	int
)	O
{	O
hdl	array
->	O
code	char
=	O
6	int
;	O
hdl	array
->	O
value	double
=	O
0	int
;	O
hdl	array
->	O
size	char
=	O
0	int
;	O
}	O
else	O
if	O
(	O
offset	double
==	O
-	O
1	int
)	O
{	O
hdl	array
->	O
code	char
=	O
8	int
;	O
hdl	array
->	O
value	double
=	O
0	int
;	O
hdl	array
->	O
size	char
=	O
0	int
;	O
}	O
else	O
if	O
(	O
offset	double
>	O
0	int
)	O
{	O
hdl	array
->	O
code	char
=	O
10	int
;	O
hdl	array
->	O
value	double
=	O
offset	double
;	O
set_handle_size	function
(	O
hdl	array
)	O
;	O
}	O
else	O
if	O
(	O
offset	double
<	O
0	int
)	O
{	O
hdl	array
->	O
code	char
=	O
12	int
;	O
hdl	array
->	O
value	double
=	O
-	O
offset	double
;	O
set_handle_size	function
(	O
hdl	array
)	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
EXPORT	O
Dwg_Object_Ref	struct
*	O
dwg_add_handleref	function
(	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
BITCODE_RC	char
code	char
,	O
unsigned	O
long	O
value	double
,	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
Dwg_Object_Ref	struct
*	O
ref	pointer
;	O
if	O
(	O
code	char
>	O
5	int
||	O
(	O
code	char
==	O
4	int
&&	O
obj	pointer
&&	O
(	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_DICTIONARY	int
||	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_XRECORD	int
||	O
obj	pointer
->	O
type	short
>=	O
DWG_TYPE_GROUP	int
)	O
)	O
)	O
)	O
;	O
else	O
{	O
for	O
(	O
BITCODE_BL	int
i	int
=	O
0	int
;	O
i	int
<	O
dwg	pointer
->	O
num_object_refs	int
;	O
i	int
++	O
)	O
{	O
Dwg_Object_Ref	struct
*	O
refi	pointer
=	O
dwg	pointer
->	O
object_ref	pointer
[	O
i	int
]	O
;	O
if	O
(	O
refi	pointer
->	O
absolute_ref	long
==	O
value	double
&&	O
refi	pointer
->	O
handleref	struct
.	O
code	char
==	O
code	char
)	O
return	O
refi	pointer
;	O
}	O
}	O
ref	pointer
=	O
dwg_new_ref	function
(	O
dwg	pointer
)	O
;	O
dwg_add_handle	function
(	O
&	O
ref	pointer
->	O
handleref	struct
,	O
code	char
,	O
value	double
,	O
obj	pointer
)	O
;	O
ref	pointer
->	O
absolute_ref	long
=	O
value	double
;	O
return	O
ref	pointer
;	O
}	O
EXPORT	O
BITCODE_H	pointer
dwg_find_table_control	function
(	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
const	O
char	O
*	O
restrict	O
table	pointer
)	O
{	O
BITCODE_BL	int
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dwg	pointer
->	O
num_objects	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
strEQ	O
(	O
dwg	pointer
->	O
object	pointer
[	O
i	int
]	O
.	O
name	pointer
,	O
table	pointer
)	O
)	O
{	O
Dwg_Handle	struct
*	O
hdl	array
=	O
&	O
dwg	pointer
->	O
object	pointer
[	O
i	int
]	O
.	O
handle	pointer
;	O
return	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
3	int
,	O
hdl	array
->	O
value	double
,	O
NULL	O
)	O
;	O
}	O
}	O
LOG_TRACE	O
(	O
"dwg_find_table_control: table control object %s not found\n"	pointer
,	O
table	pointer
)	O
return	O
NULL	O
;	O
}	O
EXPORT	O
BITCODE_H	pointer
dwg_find_dictionary	function
(	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
const	O
char	O
*	O
restrict	O
name	pointer
)	O
{	O
for	O
(	O
BITCODE_BL	int
i	int
=	O
0	int
;	O
i	int
<	O
dwg	pointer
->	O
num_objects	int
;	O
i	int
++	O
)	O
{	O
Dwg_Object	struct
*	O
obj	pointer
=	O
&	O
dwg	pointer
->	O
object	pointer
[	O
i	int
]	O
;	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_DICTIONARY	int
)	O
{	O
Dwg_Object_DICTIONARY	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
DICTIONARY	pointer
;	O
for	O
(	O
BITCODE_BL	int
j	int
=	O
0	int
;	O
j	int
<	O
_obj	pointer
->	O
numitems	int
;	O
j	int
++	O
)	O
{	O
char	O
*	O
u8	pointer
;	O
if	O
(	O
!	O
_obj	pointer
->	O
texts	pointer
||	O
!	O
_obj	pointer
->	O
itemhandles	pointer
)	O
continue	O
;	O
u8	pointer
=	O
_obj	pointer
->	O
texts	pointer
[	O
j	int
]	O
;	O
if	O
(	O
!	O
u8	pointer
)	O
continue	O
;	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_2007	int
)	O
u8	pointer
=	O
bit_convert_TU	function
(	O
(	O
BITCODE_TU	pointer
)	O
u8	pointer
)	O
;	O
if	O
(	O
u8	pointer
&&	O
strEQ	O
(	O
u8	pointer
,	O
name	pointer
)	O
)	O
{	O
Dwg_Object_Ref	struct
*	O
ref	pointer
=	O
_obj	pointer
->	O
itemhandles	pointer
[	O
j	int
]	O
;	O
if	O
(	O
!	O
ref	pointer
)	O
continue	O
;	O
dwg_resolve_handleref	function
(	O
ref	pointer
,	O
obj	pointer
)	O
;	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_2007	int
)	O
free	function
(	O
u8	pointer
)	O
;	O
return	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
5	int
,	O
ref	pointer
->	O
absolute_ref	long
,	O
NULL	O
)	O
;	O
}	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_2007	int
)	O
free	function
(	O
u8	pointer
)	O
;	O
}	O
}	O
}	O
LOG_TRACE	O
(	O
"dwg_find_dictionary: DICTIONARY with %s not found\n"	pointer
,	O
name	pointer
)	O
return	O
NULL	O
;	O
}	O
EXPORT	O
BITCODE_H	pointer
dwg_find_dicthandle	function
(	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
BITCODE_H	pointer
dict	pointer
,	O
const	O
char	O
*	O
restrict	O
name	pointer
)	O
{	O
BITCODE_BL	int
i	int
;	O
Dwg_Object_DICTIONARY	struct
*	O
_obj	pointer
;	O
Dwg_Object	struct
*	O
obj	pointer
=	O
dwg_resolve_handle	function
(	O
dwg	pointer
,	O
dict	pointer
->	O
absolute_ref	long
)	O
;	O
if	O
(	O
!	O
obj	pointer
||	O
!	O
obj	pointer
->	O
tio	union
.	O
object	pointer
)	O
{	O
LOG_TRACE	O
(	O
"dwg_find_dicthandle: Could not resolve dict "	pointer
FORMAT_REF	pointer
"\n"	pointer
,	O
ARGS_REF	O
(	O
dict	pointer
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
obj	pointer
->	O
type	short
!=	O
DWG_TYPE_DICTIONARY	int
)	O
{	O
LOG_ERROR	O
(	O
"dwg_find_dicthandle: dict not a DICTIONARY\n"	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
DICTIONARY	pointer
;	O
if	O
(	O
!	O
_obj	pointer
->	O
numitems	int
)	O
return	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
_obj	pointer
->	O
numitems	int
;	O
i	int
++	O
)	O
{	O
char	O
*	O
hdlname	pointer
;	O
BITCODE_H	pointer
*	O
hdlv	pointer
=	O
_obj	pointer
->	O
itemhandles	pointer
;	O
Dwg_Object	struct
*	O
hobj	pointer
;	O
Dwg_Object_APPID	struct
*	O
_o	pointer
;	O
int	O
isnew	pointer
=	O
0	int
;	O
bool	bool
ok	bool
;	O
if	O
(	O
!	O
hdlv	pointer
|	O
!	O
hdlv	pointer
[	O
i	int
]	O
)	O
continue	O
;	O
hobj	pointer
=	O
dwg_resolve_handle	function
(	O
dwg	pointer
,	O
hdlv	pointer
[	O
i	int
]	O
->	O
absolute_ref	long
)	O
;	O
if	O
(	O
!	O
hobj	pointer
||	O
!	O
hobj	pointer
->	O
tio	union
.	O
object	pointer
||	O
!	O
hobj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
APPID	pointer
||	O
!	O
hobj	pointer
->	O
name	pointer
)	O
continue	O
;	O
_o	pointer
=	O
hobj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
APPID	pointer
;	O
ok	bool
=	O
dwg_dynapi_entity_utf8text	function
(	O
_o	pointer
,	O
hobj	pointer
->	O
name	pointer
,	O
"name"	pointer
,	O
&	O
hdlname	pointer
,	O
&	O
isnew	pointer
,	O
NULL	O
)	O
;	O
LOG_HANDLE	O
(	O
" %s.%s[%d] => %s.name: %s\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"entries"	pointer
,	O
i	int
,	O
hobj	pointer
->	O
name	pointer
,	O
hdlname	pointer
?	O
hdlname	pointer
:	O
"NULL"	pointer
)	O
;	O
if	O
(	O
ok	bool
&&	O
hdlname	pointer
&&	O
(	O
strEQ	O
(	O
name	pointer
,	O
hdlname	pointer
)	O
||	O
!	O
strcasecmp	function
(	O
name	pointer
,	O
hdlname	pointer
)	O
)	O
)	O
{	O
if	O
(	O
isnew	pointer
)	O
free	function
(	O
hdlname	pointer
)	O
;	O
return	O
hdlv	pointer
[	O
i	int
]	O
;	O
}	O
if	O
(	O
ok	bool
&&	O
isnew	pointer
&&	O
hdlname	pointer
)	O
free	function
(	O
hdlname	pointer
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
BITCODE_H	pointer
dwg_find_tablehandle_silent	function
(	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
const	O
char	O
*	O
restrict	O
name	pointer
,	O
const	O
char	O
*	O
restrict	O
table	pointer
)	O
{	O
BITCODE_H	pointer
ref	pointer
;	O
int	O
oldopts	int
=	O
dwg	pointer
->	O
opts	int
;	O
dwg	pointer
->	O
opts	int
&=	O
~	O
(	O
DWG_OPTS_LOGLEVEL	int
)	O
;	O
loglevel	int
=	O
0	int
;	O
ref	pointer
=	O
dwg_find_tablehandle	function
(	O
dwg	pointer
,	O
name	pointer
,	O
table	pointer
)	O
;	O
dwg	pointer
->	O
opts	int
=	O
oldopts	int
;	O
loglevel	int
=	O
oldopts	int
&	O
DWG_OPTS_LOGLEVEL	int
;	O
return	O
ref	pointer
;	O
}	O
EXPORT	O
BITCODE_H	pointer
dwg_find_tablehandle	function
(	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
const	O
char	O
*	O
restrict	O
name	pointer
,	O
const	O
char	O
*	O
restrict	O
table	pointer
)	O
{	O
BITCODE_BL	int
i	int
,	O
num_entries	short
=	O
0	int
;	O
BITCODE_H	pointer
ctrl	pointer
=	O
NULL	O
,	O
*	O
hdlv	pointer
=	O
NULL	O
;	O
Dwg_Object	struct
*	O
obj	pointer
;	O
Dwg_Object_APPID_CONTROL	struct
*	O
_obj	pointer
;	O
Dwg_Header_Variables	struct
*	O
vars	pointer
=	O
&	O
dwg	pointer
->	O
header_vars	struct
;	O
if	O
(	O
!	O
dwg	pointer
||	O
!	O
name	pointer
||	O
!	O
table	pointer
)	O
return	O
NULL	O
;	O
if	O
(	O
strEQc	O
(	O
table	pointer
,	O
"BLOCK"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
(	O
ctrl	pointer
=	O
vars	pointer
->	O
BLOCK_CONTROL_OBJECT	pointer
)	O
)	O
vars	pointer
->	O
BLOCK_CONTROL_OBJECT	pointer
=	O
ctrl	pointer
=	O
dwg_find_table_control	function
(	O
dwg	pointer
,	O
"BLOCK_CONTROL"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
table	pointer
,	O
"LAYER"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
(	O
ctrl	pointer
=	O
vars	pointer
->	O
LAYER_CONTROL_OBJECT	pointer
)	O
)	O
vars	pointer
->	O
LAYER_CONTROL_OBJECT	pointer
=	O
ctrl	pointer
=	O
dwg_find_table_control	function
(	O
dwg	pointer
,	O
"LAYER_CONTROL"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
table	pointer
,	O
"STYLE"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
(	O
ctrl	pointer
=	O
vars	pointer
->	O
STYLE_CONTROL_OBJECT	pointer
)	O
)	O
vars	pointer
->	O
STYLE_CONTROL_OBJECT	pointer
=	O
ctrl	pointer
=	O
dwg_find_table_control	function
(	O
dwg	pointer
,	O
"STYLE_CONTROL"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
table	pointer
,	O
"LTYPE"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
(	O
ctrl	pointer
=	O
vars	pointer
->	O
LTYPE_CONTROL_OBJECT	pointer
)	O
)	O
vars	pointer
->	O
LTYPE_CONTROL_OBJECT	pointer
=	O
ctrl	pointer
=	O
dwg_find_table_control	function
(	O
dwg	pointer
,	O
"LTYPE_CONTROL"	pointer
)	O
;	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"BYLAYER"	pointer
)	O
||	O
strEQc	O
(	O
name	pointer
,	O
"ByLayer"	pointer
)	O
)	O
{	O
if	O
(	O
vars	pointer
->	O
LTYPE_BYLAYER	pointer
)	O
return	O
vars	pointer
->	O
LTYPE_BYLAYER	pointer
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"BYBLOCK"	pointer
)	O
||	O
strEQc	O
(	O
name	pointer
,	O
"ByBlock"	pointer
)	O
)	O
{	O
if	O
(	O
vars	pointer
->	O
LTYPE_BYBLOCK	pointer
)	O
return	O
vars	pointer
->	O
LTYPE_BYBLOCK	pointer
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"CONTINUOUS"	pointer
)	O
||	O
strEQc	O
(	O
name	pointer
,	O
"Continuous"	pointer
)	O
)	O
{	O
if	O
(	O
vars	pointer
->	O
LTYPE_CONTINUOUS	pointer
)	O
return	O
vars	pointer
->	O
LTYPE_CONTINUOUS	pointer
;	O
}	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
table	pointer
,	O
"VIEW"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
(	O
ctrl	pointer
=	O
vars	pointer
->	O
VIEW_CONTROL_OBJECT	pointer
)	O
)	O
vars	pointer
->	O
VIEW_CONTROL_OBJECT	pointer
=	O
ctrl	pointer
=	O
dwg_find_table_control	function
(	O
dwg	pointer
,	O
"VIEW_CONTROL"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
table	pointer
,	O
"UCS"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
(	O
ctrl	pointer
=	O
vars	pointer
->	O
UCS_CONTROL_OBJECT	pointer
)	O
)	O
vars	pointer
->	O
UCS_CONTROL_OBJECT	pointer
=	O
ctrl	pointer
=	O
dwg_find_table_control	function
(	O
dwg	pointer
,	O
"UCS_CONTROL"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
table	pointer
,	O
"VPORT"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
(	O
ctrl	pointer
=	O
vars	pointer
->	O
VPORT_CONTROL_OBJECT	pointer
)	O
)	O
vars	pointer
->	O
VPORT_CONTROL_OBJECT	pointer
=	O
ctrl	pointer
=	O
dwg_find_table_control	function
(	O
dwg	pointer
,	O
"VPORT_CONTROL"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
table	pointer
,	O
"APPID"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
(	O
ctrl	pointer
=	O
vars	pointer
->	O
APPID_CONTROL_OBJECT	pointer
)	O
)	O
vars	pointer
->	O
APPID_CONTROL_OBJECT	pointer
=	O
ctrl	pointer
=	O
dwg_find_table_control	function
(	O
dwg	pointer
,	O
"APPID_CONTROL"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
table	pointer
,	O
"DIMSTYLE"	pointer
)	O
||	O
memBEGINc	O
(	O
table	pointer
,	O
"ACAD_DSTYLE_DIM"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
(	O
ctrl	pointer
=	O
vars	pointer
->	O
DIMSTYLE_CONTROL_OBJECT	pointer
)	O
)	O
vars	pointer
->	O
DIMSTYLE_CONTROL_OBJECT	pointer
=	O
ctrl	pointer
=	O
dwg_find_table_control	function
(	O
dwg	pointer
,	O
"DIMSTYLE_CONTROL"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
table	pointer
,	O
"VPORT_ENTITY"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
(	O
ctrl	pointer
=	O
vars	pointer
->	O
VPORT_ENTITY_CONTROL_OBJECT	pointer
)	O
)	O
vars	pointer
->	O
VPORT_ENTITY_CONTROL_OBJECT	pointer
=	O
ctrl	pointer
=	O
dwg_find_table_control	function
(	O
dwg	pointer
,	O
"VPORT_ENTITY_CONTROL"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
table	pointer
,	O
"GROUP"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
(	O
ctrl	pointer
=	O
vars	pointer
->	O
DICTIONARY_ACAD_GROUP	pointer
)	O
)	O
vars	pointer
->	O
DICTIONARY_ACAD_GROUP	pointer
=	O
ctrl	pointer
=	O
dwg_find_dictionary	function
(	O
dwg	pointer
,	O
"ACAD_GROUP"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
table	pointer
,	O
"MLSTYLE"	pointer
)	O
||	O
strEQc	O
(	O
table	pointer
,	O
"MLINESTYLE"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
(	O
ctrl	pointer
=	O
vars	pointer
->	O
DICTIONARY_ACAD_MLINESTYLE	pointer
)	O
)	O
vars	pointer
->	O
DICTIONARY_ACAD_MLINESTYLE	pointer
=	O
ctrl	pointer
=	O
dwg_find_dictionary	function
(	O
dwg	pointer
,	O
"ACAD_MLINESTYLE"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
table	pointer
,	O
"MLEADERSTYLE"	pointer
)	O
||	O
strEQc	O
(	O
table	pointer
,	O
"ACAD_MLEADERVER"	pointer
)	O
)	O
{	O
ctrl	pointer
=	O
dwg_find_dictionary	function
(	O
dwg	pointer
,	O
"ACAD_MLEADERSTYLE"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
table	pointer
,	O
"NAMED_OBJECT"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
(	O
ctrl	pointer
=	O
vars	pointer
->	O
DICTIONARY_NAMED_OBJECT	pointer
)	O
)	O
vars	pointer
->	O
DICTIONARY_NAMED_OBJECT	pointer
=	O
ctrl	pointer
=	O
dwg_add_handleref	function
(	O
dwg	pointer
,	O
3	int
,	O
0xC	int
,	O
NULL	O
)	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
table	pointer
,	O
"LAYOUT"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
(	O
ctrl	pointer
=	O
vars	pointer
->	O
DICTIONARY_LAYOUT	pointer
)	O
)	O
vars	pointer
->	O
DICTIONARY_LAYOUT	pointer
=	O
ctrl	pointer
=	O
dwg_find_dictionary	function
(	O
dwg	pointer
,	O
"ACAD_LAYOUT"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
table	pointer
,	O
"PLOTSETTINGS"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
(	O
ctrl	pointer
=	O
vars	pointer
->	O
DICTIONARY_PLOTSETTINGS	pointer
)	O
)	O
vars	pointer
->	O
DICTIONARY_PLOTSETTINGS	pointer
=	O
ctrl	pointer
=	O
dwg_find_dictionary	function
(	O
dwg	pointer
,	O
"ACAD_PLOTSETTINGS"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
table	pointer
,	O
"PLOTSTYLENAME"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
(	O
ctrl	pointer
=	O
vars	pointer
->	O
DICTIONARY_PLOTSTYLENAME	pointer
)	O
)	O
vars	pointer
->	O
DICTIONARY_PLOTSTYLENAME	pointer
=	O
ctrl	pointer
=	O
dwg_find_dictionary	function
(	O
dwg	pointer
,	O
"ACAD_PLOTSTYLENAME"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
table	pointer
,	O
"MATERIAL"	pointer
)	O
||	O
memBEGINc	O
(	O
table	pointer
,	O
"ACAD_MATERIAL_MAPPER"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
(	O
ctrl	pointer
=	O
vars	pointer
->	O
DICTIONARY_MATERIAL	pointer
)	O
)	O
vars	pointer
->	O
DICTIONARY_MATERIAL	pointer
=	O
ctrl	pointer
=	O
dwg_find_dictionary	function
(	O
dwg	pointer
,	O
"ACAD_MATERIAL"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
table	pointer
,	O
"COLOR"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
(	O
ctrl	pointer
=	O
vars	pointer
->	O
DICTIONARY_COLOR	pointer
)	O
)	O
vars	pointer
->	O
DICTIONARY_COLOR	pointer
=	O
ctrl	pointer
=	O
dwg_find_dictionary	function
(	O
dwg	pointer
,	O
"ACAD_COLOR"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
table	pointer
,	O
"VISUALSTYLE"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
(	O
ctrl	pointer
=	O
vars	pointer
->	O
DICTIONARY_VISUALSTYLE	pointer
)	O
)	O
vars	pointer
->	O
DICTIONARY_VISUALSTYLE	pointer
=	O
ctrl	pointer
=	O
dwg_find_dictionary	function
(	O
dwg	pointer
,	O
"ACAD_VISUALSTYLE"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strEQc	O
(	O
table	pointer
,	O
"LIGHTLIST"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
(	O
ctrl	pointer
=	O
vars	pointer
->	O
DICTIONARY_LIGHTLIST	pointer
)	O
)	O
vars	pointer
->	O
DICTIONARY_LIGHTLIST	pointer
=	O
ctrl	pointer
=	O
dwg_find_dictionary	function
(	O
dwg	pointer
,	O
"ACAD_LIGHTLIST"	pointer
)	O
;	O
}	O
else	O
{	O
LOG_ERROR	O
(	O
"dwg_find_tablehandle: Unsupported table %s"	pointer
,	O
table	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
ctrl	pointer
)	O
{	O
LOG_TRACE	O
(	O
"dwg_find_tablehandle: Empty header_vars table %s\n"	pointer
,	O
table	pointer
)	O
;	O
return	O
0	int
;	O
}	O
obj	pointer
=	O
dwg_resolve_handle	function
(	O
dwg	pointer
,	O
ctrl	pointer
->	O
absolute_ref	long
)	O
;	O
if	O
(	O
!	O
obj	pointer
)	O
{	O
LOG_TRACE	O
(	O
"dwg_find_tablehandle: Could not resolve table %s\n"	pointer
,	O
table	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_DICTIONARY	int
)	O
return	O
dwg_find_dicthandle	function
(	O
dwg	pointer
,	O
ctrl	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
!	O
dwg_obj_is_control	function
(	O
obj	pointer
)	O
)	O
{	O
LOG_ERROR	O
(	O
"dwg_find_tablehandle: Could not resolve CONTROL object %s "	pointer
"for table %s"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
table	pointer
)	O
;	O
return	O
0	int
;	O
}	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
APPID_CONTROL	pointer
;	O
dwg_dynapi_entity_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"num_entries"	pointer
,	O
&	O
num_entries	short
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
num_entries	short
)	O
return	O
0	int
;	O
dwg_dynapi_entity_value	function
(	O
_obj	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"entries"	pointer
,	O
&	O
hdlv	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
hdlv	pointer
)	O
return	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_entries	short
;	O
i	int
++	O
)	O
{	O
char	O
*	O
hdlname	pointer
;	O
Dwg_Object	struct
*	O
hobj	pointer
;	O
Dwg_Object_APPID	struct
*	O
_o	pointer
;	O
int	O
isnew	pointer
=	O
0	int
;	O
bool	bool
ok	bool
;	O
if	O
(	O
!	O
hdlv	pointer
[	O
i	int
]	O
)	O
continue	O
;	O
hobj	pointer
=	O
dwg_resolve_handle	function
(	O
dwg	pointer
,	O
hdlv	pointer
[	O
i	int
]	O
->	O
absolute_ref	long
)	O
;	O
if	O
(	O
!	O
hobj	pointer
||	O
!	O
hobj	pointer
->	O
tio	union
.	O
object	pointer
||	O
!	O
hobj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
APPID	pointer
)	O
continue	O
;	O
_o	pointer
=	O
hobj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
APPID	pointer
;	O
ok	bool
=	O
dwg_dynapi_entity_utf8text	function
(	O
_o	pointer
,	O
hobj	pointer
->	O
name	pointer
,	O
"name"	pointer
,	O
&	O
hdlname	pointer
,	O
&	O
isnew	pointer
,	O
NULL	O
)	O
;	O
LOG_HANDLE	O
(	O
" %s.%s[%d] => %s.name: %s\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"entries"	pointer
,	O
i	int
,	O
hobj	pointer
->	O
name	pointer
,	O
hdlname	pointer
?	O
hdlname	pointer
:	O
"NULL"	pointer
)	O
;	O
if	O
(	O
ok	bool
&&	O
hdlname	pointer
&&	O
(	O
strEQ	O
(	O
name	pointer
,	O
hdlname	pointer
)	O
||	O
!	O
strcasecmp	function
(	O
name	pointer
,	O
hdlname	pointer
)	O
)	O
)	O
{	O
if	O
(	O
isnew	pointer
)	O
free	function
(	O
hdlname	pointer
)	O
;	O
return	O
hdlv	pointer
[	O
i	int
]	O
;	O
}	O
if	O
(	O
ok	bool
&&	O
isnew	pointer
&&	O
hdlname	pointer
)	O
free	function
(	O
hdlname	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
bool	bool
xdata_string_match	function
(	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
Dwg_Resbuf	struct
*	O
restrict	O
xdata	pointer
,	O
int	O
type	short
,	O
char	O
*	O
restrict	O
str	struct
)	O
{	O
if	O
(	O
xdata	pointer
->	O
type	short
!=	O
type	short
)	O
return	O
0	int
;	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
from_version	enum
<	O
R_2007	int
)	O
{	O
return	O
strEQ	O
(	O
xdata	pointer
->	O
value	double
.	O
str	struct
.	O
u	union
.	O
data	pointer
,	O
str	struct
)	O
;	O
}	O
else	O
{	O
return	O
memcmp	function
(	O
xdata	pointer
->	O
value	double
.	O
str	struct
.	O
u	union
.	O
wdata	pointer
,	O
str	struct
,	O
xdata	pointer
->	O
value	double
.	O
str	struct
.	O
size	char
*	O
2	int
)	O
==	O
0	int
;	O
}	O
}	O
static	O
bool	bool
is_extnames_xrecord	function
(	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
Dwg_Object	struct
*	O
restrict	O
xrec	pointer
,	O
Dwg_Object	struct
*	O
restrict	O
xdic	pointer
)	O
{	O
const	O
int16_t	short
w	double
[	O
8	int
]	O
=	O
{	O
'E'	O
,	O
'X'	O
,	O
'T'	O
,	O
'N'	O
,	O
'A'	O
,	O
'M'	O
,	O
'E'	O
,	O
'S'	O
}	O
;	O
const	O
char	O
*	O
extnames	pointer
=	O
dwg	pointer
->	O
header	struct
.	O
from_version	enum
<	O
R_2007	int
?	O
"EXTNAMES"	pointer
:	O
(	O
const	O
char	O
*	O
)	O
w	double
;	O
return	O
(	O
xrec	pointer
&&	O
xdic	pointer
&&	O
dwg	pointer
&&	O
xrec	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_XRECORD	int
&&	O
xrec	pointer
->	O
tio	union
.	O
object	pointer
->	O
ownerhandle	pointer
&&	O
xrec	pointer
->	O
tio	union
.	O
object	pointer
->	O
ownerhandle	pointer
->	O
absolute_ref	long
==	O
xdic	pointer
->	O
handle	pointer
.	O
value	double
&&	O
xrec	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
XRECORD	pointer
->	O
num_xdata	int
>=	O
2	int
&&	O
xrec	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
XRECORD	pointer
->	O
xdata	pointer
&&	O
xdata_string_match	function
(	O
dwg	pointer
,	O
xrec	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
XRECORD	pointer
->	O
xdata	pointer
,	O
102	int
,	O
(	O
char	O
*	O
)	O
extnames	pointer
)	O
)	O
;	O
}	O
EXPORT	O
char	O
*	O
dwg_find_table_extname	function
(	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
name	pointer
;	O
Dwg_Object	struct
*	O
xdic	pointer
;	O
Dwg_Object_DICTIONARY	struct
*	O
_xdic	pointer
;	O
Dwg_Object_Ref	struct
*	O
xdicref	pointer
;	O
Dwg_Object	struct
*	O
xrec	pointer
=	O
NULL	O
;	O
Dwg_Object_XRECORD	struct
*	O
_xrec	pointer
;	O
Dwg_Resbuf	struct
*	O
xdata	pointer
;	O
BITCODE_BL	int
i	int
;	O
if	O
(	O
!	O
dwg_obj_is_table	function
(	O
obj	pointer
)	O
)	O
return	O
NULL	O
;	O
name	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
LAYER	pointer
->	O
name	pointer
;	O
xdicref	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
xdicobjhandle	pointer
;	O
if	O
(	O
!	O
xdicref	pointer
)	O
return	O
NULL	O
;	O
xdic	pointer
=	O
dwg_ref_object	function
(	O
dwg	pointer
,	O
xdicref	pointer
)	O
;	O
if	O
(	O
!	O
xdic	pointer
||	O
xdic	pointer
->	O
type	short
!=	O
DWG_TYPE_DICTIONARY	int
)	O
return	O
NULL	O
;	O
_xdic	pointer
=	O
xdic	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
DICTIONARY	pointer
;	O
if	O
(	O
_xdic	pointer
->	O
numitems	int
<	O
1	int
||	O
!	O
_xdic	pointer
->	O
texts	pointer
[	O
0	int
]	O
)	O
return	O
NULL	O
;	O
if	O
(	O
xdic	pointer
->	O
tio	union
.	O
object	pointer
->	O
ownerhandle	pointer
->	O
absolute_ref	long
!=	O
obj	pointer
->	O
handle	pointer
.	O
value	double
)	O
return	O
NULL	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
_xdic	pointer
->	O
numitems	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
strEQc	O
(	O
_xdic	pointer
->	O
texts	pointer
[	O
i	int
]	O
,	O
"ACAD_XREC_ROUNDTRIP"	pointer
)	O
)	O
break	O
;	O
}	O
if	O
(	O
i	int
==	O
_xdic	pointer
->	O
numitems	int
)	O
return	O
NULL	O
;	O
xrec	pointer
=	O
dwg_ref_object	function
(	O
dwg	pointer
,	O
_xdic	pointer
->	O
itemhandles	pointer
[	O
i	int
]	O
)	O
;	O
if	O
(	O
!	O
xrec	pointer
||	O
!	O
is_extnames_xrecord	function
(	O
dwg	pointer
,	O
xrec	pointer
,	O
xdic	pointer
)	O
)	O
return	O
NULL	O
;	O
_xrec	pointer
=	O
xrec	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
XRECORD	pointer
;	O
xdata	pointer
=	O
_xrec	pointer
->	O
xdata	pointer
;	O
xdata	pointer
=	O
xdata	pointer
->	O
next	pointer
;	O
if	O
(	O
xdata	pointer
->	O
type	short
==	O
1	int
)	O
{	O
cmp	O
:	O
if	O
(	O
!	O
xdata_string_match	function
(	O
dwg	pointer
,	O
xdata	pointer
,	O
1	int
,	O
name	pointer
)	O
)	O
{	O
xdata	pointer
=	O
xdata	pointer
->	O
next	pointer
;	O
while	O
(	O
xdata	pointer
&&	O
xdata	pointer
->	O
type	short
!=	O
1	int
&&	O
xdata	pointer
->	O
type	short
!=	O
102	int
)	O
xdata	pointer
=	O
xdata	pointer
->	O
next	pointer
;	O
if	O
(	O
xdata	pointer
)	O
goto	O
cmp	O
;	O
}	O
if	O
(	O
!	O
xdata	pointer
)	O
return	O
NULL	O
;	O
xdata	pointer
=	O
xdata	pointer
->	O
next	pointer
;	O
if	O
(	O
xdata	pointer
->	O
type	short
==	O
2	int
)	O
{	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
from_version	enum
<	O
R_2007	int
)	O
return	O
xdata	pointer
->	O
value	double
.	O
str	struct
.	O
u	union
.	O
data	pointer
;	O
else	O
return	O
(	O
char	O
*	O
)	O
xdata	pointer
->	O
value	double
.	O
str	struct
.	O
u	union
.	O
wdata	pointer
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
