struct	O
font	struct
{	O
struct	O
character	struct
*	O
chars	pointer
;	O
unsigned	O
char	O
*	O
map	pointer
;	O
struct	O
kern_pair	struct
*	O
kern	pointer
;	O
}	O
;	O
struct	O
character	struct
{	O
int	O
wx	int
;	O
int	O
llx	int
,	O
lly	int
,	O
urx	int
,	O
ury	int
;	O
}	O
;	O
struct	O
kern_pair	struct
{	O
unsigned	O
char	O
c0	char
,	O
c1	char
;	O
int	O
amt	int
;	O
}	O
;	O
enum	O
output_mode	enum
{	O
MODE_TEXT	int
,	O
MODE_POSTSCRIPT	int
}	O
;	O
enum	O
token_type	enum
{	O
TOKEN_EOF	int
,	O
TOKEN_LPAREN	int
,	O
TOKEN_RPAREN	int
,	O
TOKEN_LEFT	int
,	O
TOKEN_MIDDLE	int
,	O
TOKEN_RIGHT	int
,	O
TOKEN_COMMA	int
,	O
TOKEN_PRODUCES	int
,	O
TOKEN_TWOWAY	int
,	O
TOKEN_ADJACENT	int
,	O
TOKEN_NO_CIRCLE	int
,	O
TOKEN_LEADER	int
,	O
TOKEN_SHADE	int
,	O
TOKEN_THREAD	int
,	O
TOKEN_NAME	int
,	O
TOKEN_NO_LINE	int
,	O
TOKEN_QUOTE	int
,	O
TOKEN_INCORRECT	int
,	O
TOKEN_JUSTIFICATION	int
,	O
TOKEN_SHAPE	int
,	O
TOKEN_LABEL	int
}	O
;	O
struct	O
token	struct
{	O
int	O
ln	int
;	O
enum	O
token_type	enum
type	enum
;	O
int	O
c	int
;	O
int	O
eof	int
;	O
}	O
;	O
enum	O
tree_type	enum
{	O
TREE_BINARY	int
,	O
TREE_PRODUCTION	int
,	O
TREE_SHIFT	int
}	O
;	O
enum	O
tree_options	enum
{	O
TOPT_LEADER	int
=	O
001	int
,	O
TOPT_NO_CIRCLE	int
=	O
002	int
,	O
TOPT_THREAD	int
=	O
004	int
,	O
TOPT_NO_LINE	int
=	O
010	int
}	O
;	O
enum	O
label_position	enum
{	O
LP_MIDDLE	int
,	O
LP_LEFT	int
,	O
LP_RIGHT	int
,	O
LP_COUNT	int
}	O
;	O
struct	O
tree	struct
{	O
enum	O
tree_type	enum
type	enum
;	O
int	O
w	int
,	O
h	int
;	O
double	O
x	double
,	O
y	double
;	O
int	O
ofs	int
;	O
enum	O
tree_options	enum
options	enum
;	O
char	O
*	O
label	array
[	O
LP_COUNT	int
]	O
;	O
struct	O
tree	struct
*	O
link	array
[	O
2	int
]	O
;	O
struct	O
tree	struct
*	O
thread	array
[	O
2	int
]	O
;	O
int	O
shade	int
;	O
char	O
*	O
name	pointer
;	O
int	O
margin	array
[	O
2	int
]	O
;	O
int	O
justify	int
;	O
int	O
shape	int
;	O
enum	O
token_type	enum
prod_type	enum
;	O
}	O
;	O
static	O
struct	O
tree	struct
outside_thread	struct
;	O
struct	O
canvas	struct
{	O
int	O
w	int
;	O
int	O
ll	int
;	O
int	O
h	int
;	O
unsigned	O
char	O
*	O
buf	pointer
;	O
}	O
;	O
struct	O
space	struct
{	O
int	O
sh	int
;	O
int	O
x0	int
,	O
w	int
;	O
int	O
y0	int
,	O
h	int
;	O
}	O
;	O
enum	O
justification	enum
{	O
JT_LEFT	int
=	O
001	int
,	O
JT_RIGHT	int
=	O
002	int
,	O
JT_CENTER	int
=	O
003	int
,	O
JT_HORZ	int
=	O
003	int
,	O
JT_TOP	int
=	O
010	int
,	O
JT_MIDDLE	int
=	O
030	int
,	O
JT_VERT	int
=	O
030	int
}	O
;	O
static	O
void	O
lex_init	function
(	O
struct	O
token	struct
*	O
)	O
;	O
static	O
void	O
lex_get	function
(	O
struct	O
token	struct
*	O
)	O
;	O
static	O
int	O
lex_match	function
(	O
struct	O
token	struct
*	O
token	struct
,	O
enum	O
token_type	enum
type	enum
)	O
;	O
static	O
void	O
lex_get_string	function
(	O
struct	O
token	struct
*	O
token	struct
,	O
char	O
*	O
*	O
s	pointer
)	O
;	O
static	O
struct	O
tree	struct
*	O
tree_parse	function
(	O
struct	O
token	struct
*	O
,	O
enum	O
output_mode	enum
)	O
;	O
static	O
void	O
tree_free	function
(	O
struct	O
tree	struct
*	O
tree	struct
)	O
;	O
static	O
void	O
tree_print	function
(	O
struct	O
tree	struct
*	O
)	O
;	O
static	O
void	O
ps_resolve_threads	function
(	O
struct	O
tree	struct
*	O
this	pointer
,	O
struct	O
tree	struct
*	O
top	pointer
)	O
;	O
static	O
void	O
ps_measure_tree	function
(	O
struct	O
tree	struct
*	O
,	O
int	O
*	O
radius	pointer
)	O
;	O
static	O
void	O
ps_draw_tree	function
(	O
struct	O
tree	struct
*	O
tree	struct
,	O
struct	O
space	struct
*	O
space	struct
,	O
int	O
radius	pointer
)	O
;	O
static	O
void	O
ps_draw_threads	function
(	O
const	O
struct	O
tree	struct
*	O
tree	struct
,	O
double	O
radius	pointer
)	O
;	O
static	O
int	O
ps_determine_diam	function
(	O
const	O
struct	O
tree	struct
*	O
tree	struct
)	O
;	O
static	O
void	O
ps_measure_text	function
(	O
const	O
char	O
*	O
text	pointer
,	O
int	O
*	O
w	int
,	O
int	O
*	O
h	int
)	O
;	O
static	O
void	O
ps_layout_tree	function
(	O
struct	O
tree	struct
*	O
tree	struct
,	O
int	O
radius	pointer
)	O
;	O
static	O
void	O
ps_draw_tree_justified	function
(	O
struct	O
tree	struct
*	O
tree	struct
,	O
struct	O
space	struct
*	O
space	struct
,	O
int	O
x	double
,	O
int	O
radius	pointer
)	O
;	O
static	O
void	O
space_create	function
(	O
struct	O
space	struct
*	O
space	struct
,	O
int	O
w	int
,	O
int	O
h	int
)	O
;	O
static	O
void	O
space_subdivide	function
(	O
struct	O
space	struct
*	O
dst	pointer
,	O
const	O
struct	O
space	struct
*	O
src	pointer
,	O
int	O
x0	int
,	O
int	O
y0	int
,	O
int	O
x1	int
,	O
int	O
y1	int
)	O
;	O
static	O
void	O
space_line	function
(	O
struct	O
space	struct
*	O
space	struct
,	O
int	O
x0	int
,	O
int	O
y0	int
,	O
int	O
x1	int
,	O
int	O
y1	int
,	O
int	O
radius	pointer
,	O
int	O
s0	int
,	O
int	O
s1	int
)	O
;	O
static	O
void	O
space_circle	function
(	O
struct	O
space	struct
*	O
space	struct
,	O
int	O
x	double
,	O
int	O
y	double
,	O
int	O
radius	pointer
,	O
int	O
shade	int
)	O
;	O
static	O
void	O
space_square	function
(	O
struct	O
space	struct
*	O
space	struct
,	O
int	O
x0	int
,	O
int	O
y0	int
,	O
int	O
x1	int
,	O
int	O
y1	int
,	O
int	O
shade	int
)	O
;	O
static	O
void	O
space_text	function
(	O
struct	O
space	struct
*	O
space	struct
,	O
int	O
x	double
,	O
int	O
y	double
,	O
const	O
char	O
*	O
text	pointer
,	O
enum	O
justification	enum
,	O
int	O
adjust_height	int
,	O
int	O
shade	int
)	O
;	O
static	O
void	O
space_special	function
(	O
struct	O
space	struct
*	O
space	struct
,	O
int	O
x	double
,	O
int	O
y	double
,	O
int	O
w	int
,	O
int	O
h	int
,	O
const	O
char	O
*	O
text	pointer
)	O
;	O
static	O
double	O
space_xc	function
(	O
const	O
struct	O
space	struct
*	O
space	struct
,	O
double	O
x	double
)	O
;	O
static	O
double	O
space_yc	function
(	O
const	O
struct	O
space	struct
*	O
space	struct
,	O
double	O
y	double
)	O
;	O
static	O
void	O
space_distance_along	function
(	O
double	O
x0	int
,	O
double	O
y0	int
,	O
double	O
x1	int
,	O
double	O
y1	int
,	O
double	O
radius	pointer
,	O
int	O
dir	int
,	O
double	O
*	O
x	double
,	O
double	O
*	O
y	double
,	O
int	O
shape	int
)	O
;	O
static	O
void	O
text_measure_tree	function
(	O
struct	O
tree	struct
*	O
)	O
;	O
static	O
void	O
text_draw_tree	function
(	O
const	O
struct	O
tree	struct
*	O
,	O
struct	O
canvas	struct
*	O
)	O
;	O
static	O
void	O
text_measure_text	function
(	O
const	O
char	O
*	O
text	pointer
,	O
int	O
*	O
w	int
,	O
int	O
*	O
h	int
)	O
;	O
static	O
struct	O
tree	struct
*	O
text_shift_tree	function
(	O
struct	O
tree	struct
*	O
old	pointer
,	O
int	O
direction	int
)	O
;	O
static	O
int	O
text_trivial	function
(	O
const	O
struct	O
tree	struct
*	O
tree	struct
)	O
;	O
static	O
int	O
text_caret	function
(	O
const	O
struct	O
tree	struct
*	O
tree	struct
)	O
;	O
static	O
void	O
text_draw_line	function
(	O
struct	O
canvas	struct
*	O
,	O
int	O
x0	int
,	O
int	O
x1	int
,	O
int	O
y	double
)	O
;	O
static	O
void	O
text_draw_text	function
(	O
struct	O
canvas	struct
*	O
canvas	struct
,	O
int	O
x	double
,	O
int	O
y	double
,	O
int	O
w	int
,	O
const	O
char	O
*	O
text	pointer
)	O
;	O
static	O
void	O
text_draw_tree_justified	function
(	O
const	O
struct	O
tree	struct
*	O
tree	struct
,	O
struct	O
canvas	struct
*	O
canvas	struct
,	O
int	O
x	double
)	O
;	O
static	O
void	O
canvas_create	function
(	O
struct	O
canvas	struct
*	O
,	O
int	O
w	int
,	O
int	O
h	int
)	O
;	O
static	O
void	O
canvas_free	function
(	O
struct	O
canvas	struct
*	O
)	O
;	O
static	O
int	O
canvas_get	function
(	O
const	O
struct	O
canvas	struct
*	O
canvas	struct
,	O
int	O
x	double
,	O
int	O
y	double
)	O
;	O
static	O
void	O
canvas_set	function
(	O
struct	O
canvas	struct
*	O
,	O
int	O
x	double
,	O
int	O
y	double
,	O
int	O
c	int
)	O
;	O
static	O
void	O
canvas_subdivide	function
(	O
struct	O
canvas	struct
*	O
dst	pointer
,	O
const	O
struct	O
canvas	struct
*	O
src	pointer
,	O
int	O
x0	int
,	O
int	O
y0	int
,	O
int	O
x1	int
,	O
int	O
y1	int
)	O
;	O
static	O
void	O
canvas_print	function
(	O
const	O
struct	O
canvas	struct
*	O
)	O
;	O
static	O
void	O
error	function
(	O
struct	O
token	struct
*	O
,	O
const	O
char	O
*	O
,	O
...	O
)	O
ATTRIBUTE	O
(	O
(	O
format	pointer
(	O
printf	function
,	O
2	int
,	O
3	int
)	O
)	O
)	O
;	O
static	O
void	O
*	O
xmalloc	function
(	O
size_t	long
)	O
;	O
static	O
void	O
*	O
xrealloc	function
(	O
void	O
*	O
ptr	pointer
,	O
size_t	long
size	long
)	O
;	O
static	O
int	O
max	function
(	O
int	O
a	int
,	O
int	O
b	int
)	O
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array
[	O
]	O
)	O
{	O
struct	O
token	struct
token	struct
;	O
enum	O
output_mode	enum
mode	enum
=	O
MODE_POSTSCRIPT	int
;	O
struct	O
tree	struct
*	O
*	O
input	pointer
=	O
NULL	O
;	O
int	O
*	O
radius	pointer
=	O
NULL	O
;	O
int	O
m	int
,	O
n	int
;	O
int	O
width	int
,	O
height	int
;	O
int	O
page_width	int
;	O
int	O
i	int
,	O
y	double
;	O
struct	O
space	struct
page	struct
;	O
if	O
(	O
argc	int
>=	O
2	int
&&	O
!	O
strncmp	function
(	O
argv	array
[	O
1	int
]	O
,	O
"--"	pointer
,	O
2	int
)	O
)	O
argv	array
[	O
1	int
]	O
+=	O
2	int
;	O
if	O
(	O
argc	int
<	O
2	int
||	O
!	O
strcmp	function
(	O
argv	array
[	O
1	int
]	O
,	O
"help"	pointer
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"texitree, a program for drawing binary trees\n"	pointer
"Usage: %s COMMAND [OPTION...]\n"	pointer
"\nCommands:\n"	pointer
"  text < tree.in > tree.txt   output plain text\n"	pointer
"  ps < tree.in > tree.eps     output PostScript\n"	pointer
"  help                        print this help, then exit\n"	pointer
"  version                     show version, then exit\n"	pointer
"\nOptions:\n"	pointer
"  -w WIDTH  page width for centering, WIDTH in characters (text)\n"	pointer
"            or 1/1000 point (PostScript), default 72 or 612000\n"	pointer
"\nReport bugs to Ben Pfaff <blp@gnu.org>.\n"	pointer
,	O
argv	array
[	O
0	int
]	O
)	O
;	O
return	O
argc	int
==	O
2	int
?	O
EXIT_SUCCESS	int
:	O
EXIT_FAILURE	int
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
argv	array
[	O
1	int
]	O
,	O
"version"	pointer
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"texitree 0.9.0\n"	pointer
"Copyright (C) 2000 Free Software Foundation, Inc.\n"	pointer
"texiweb comes with NO WARRANTY, to the extent permitted by law,\n"	pointer
"not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"	pointer
"You may redistribute copies of texiweb under the terms of the GNU\n"	pointer
"General Public License.  For more information about these\n"	pointer
"matters, see the file named COPYING.\n"	pointer
"Written by Ben Pfaff <blp@gnu.org>.\n"	pointer
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
argv	array
[	O
1	int
]	O
,	O
"ps"	pointer
)	O
)	O
{	O
mode	enum
=	O
MODE_POSTSCRIPT	int
;	O
page_width	int
=	O
612000	int
;	O
if	O
(	O
argc	int
==	O
4	int
&&	O
!	O
strcmp	function
(	O
argv	array
[	O
2	int
]	O
,	O
"-w"	pointer
)	O
)	O
page_width	int
=	O
atoi	function
(	O
argv	array
[	O
3	int
]	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
argv	array
[	O
1	int
]	O
,	O
"text"	pointer
)	O
)	O
{	O
mode	enum
=	O
MODE_TEXT	int
;	O
page_width	int
=	O
72	int
;	O
if	O
(	O
argc	int
==	O
4	int
&&	O
!	O
strcmp	function
(	O
argv	array
[	O
2	int
]	O
,	O
"-w"	pointer
)	O
)	O
page_width	int
=	O
atoi	function
(	O
argv	array
[	O
3	int
]	O
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"bad command; use --help for usage\n"	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
lex_init	function
(	O
&	O
token	struct
)	O
;	O
lex_get	function
(	O
&	O
token	struct
)	O
;	O
n	int
=	O
m	int
=	O
0	int
;	O
while	O
(	O
token	struct
.	O
type	enum
!=	O
TOKEN_EOF	int
)	O
{	O
if	O
(	O
n	int
>=	O
m	int
)	O
{	O
m	int
=	O
2	int
*	O
n	int
+	O
8	int
;	O
input	pointer
=	O
xrealloc	function
(	O
input	pointer
,	O
sizeof	O
*	O
input	pointer
*	O
m	int
)	O
;	O
radius	pointer
=	O
xrealloc	function
(	O
radius	pointer
,	O
sizeof	O
*	O
radius	pointer
*	O
m	int
)	O
;	O
}	O
input	pointer
[	O
n	int
++	O
]	O
=	O
tree_parse	function
(	O
&	O
token	struct
,	O
mode	enum
)	O
;	O
}	O
height	int
=	O
0	int
;	O
if	O
(	O
mode	enum
==	O
MODE_POSTSCRIPT	int
)	O
{	O
height	int
+=	O
(	O
n	int
-	O
1	int
)	O
*	O
PS_CHAR_HEIGHT	int
;	O
height	int
+=	O
PS_TOP_MARGIN	int
+	O
PS_BOT_MARGIN	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
mode	enum
==	O
MODE_POSTSCRIPT	int
)	O
{	O
ps_resolve_threads	function
(	O
input	pointer
[	O
i	int
]	O
,	O
input	pointer
[	O
i	int
]	O
)	O
;	O
ps_measure_tree	function
(	O
input	pointer
[	O
i	int
]	O
,	O
&	O
radius	pointer
[	O
i	int
]	O
)	O
;	O
}	O
else	O
text_measure_tree	function
(	O
input	pointer
[	O
i	int
]	O
)	O
;	O
height	int
+=	O
input	pointer
[	O
i	int
]	O
->	O
h	int
;	O
}	O
width	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
width	int
=	O
max	function
(	O
width	int
,	O
input	pointer
[	O
i	int
]	O
->	O
w	int
)	O
;	O
if	O
(	O
width	int
>	O
page_width	int
)	O
page_width	int
=	O
width	int
;	O
y	double
=	O
mode	enum
==	O
MODE_POSTSCRIPT	int
?	O
72000	int
:	O
0	int
;	O
if	O
(	O
mode	enum
==	O
MODE_POSTSCRIPT	int
)	O
{	O
int	O
x0	int
=	O
page_width	int
/	O
2	int
-	O
width	int
/	O
2	int
-	O
1000	int
;	O
int	O
x1	int
=	O
page_width	int
/	O
2	int
+	O
width	int
/	O
2	int
+	O
1000	int
;	O
int	O
y0	int
=	O
y	double
-	O
1000	int
;	O
int	O
y1	int
=	O
y	double
+	O
height	int
+	O
1000	int
;	O
space_create	function
(	O
&	O
page	struct
,	O
page_width	int
,	O
792000	int
)	O
;	O
printf	function
(	O
"%%!PS-Adobe-3.0 EPSF-3.0\n"	pointer
"%%%%BoundingBox: %.0f %.0f %.0f %.0f\n"	pointer
"/ED { exch def } def\n"	pointer
"/MT { moveto } def\n"	pointer
"/LT { lineto } def\n"	pointer
"/L { newpath MT LT stroke } bind def\n"	pointer
"/F { exch findfont exch scalefont setfont } bind def\n"	pointer
"/C { dup 3 index add 2 index MT 0 360 arc stroke } "	pointer
"bind def\n"	pointer
"/SG { 100 div setgray } bind def\n"	pointer
"/D { SG dup 3 index add 2 index MT 0 360 arc fill 0 SG } "	pointer
"bind def\n"	pointer
"/TC { SG dup stringwidth pop 2 div 4 -1 roll exch sub\n"	pointer
"     3 -1 roll MT show 0 SG } bind def\n"	pointer
"/TR { SG dup stringwidth pop 4 -1 roll exch sub\n"	pointer
"     3 -1 roll MT show 0 SG } bind def\n"	pointer
"/TL { SG 0 4 -1 roll exch sub\n"	pointer
"     3 -1 roll MT show 0 SG } bind def\n"	pointer
"/S { gsave /Symbol 12 F 0 TC grestore } bind def\n"	pointer
"/T { [2 1] 0 setdash MT curveto stroke } bind def\n"	pointer
"/A { [] 0 setdash /y ED /x ED x 1.4 sub y 4 sub\n"	pointer
"     MT x y LT x 1.4 add y 4 sub LT fill } def\n"	pointer
"/Q { /y1 ED /x1 ED /y0 ED /x0 ED\n"	pointer
"     x0 y0 MT x1 y0 LT x1 y1 LT x0 y1 LT\n"	pointer
"     x0 y0 LT closepath } def\n"	pointer
"/SD { Q stroke } def\n"	pointer
"/SS { SG Q fill 0 SG } def\n"	pointer
"/Helvetica 12 F\n"	pointer
,	O
space_xc	function
(	O
&	O
page	struct
,	O
x0	int
)	O
,	O
space_yc	function
(	O
&	O
page	struct
,	O
y1	int
)	O
,	O
space_xc	function
(	O
&	O
page	struct
,	O
x1	int
)	O
,	O
space_yc	function
(	O
&	O
page	struct
,	O
y0	int
)	O
)	O
;	O
y	double
+=	O
PS_TOP_MARGIN	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
{	O
int	O
x0	int
=	O
page_width	int
/	O
2	int
-	O
input	pointer
[	O
i	int
]	O
->	O
w	int
/	O
2	int
;	O
if	O
(	O
mode	enum
==	O
MODE_POSTSCRIPT	int
)	O
{	O
struct	O
space	struct
space	struct
;	O
space_subdivide	function
(	O
&	O
space	struct
,	O
&	O
page	struct
,	O
x0	int
,	O
y	double
,	O
x0	int
+	O
input	pointer
[	O
i	int
]	O
->	O
w	int
,	O
y	double
+	O
input	pointer
[	O
i	int
]	O
->	O
h	int
)	O
;	O
ps_draw_tree	function
(	O
input	pointer
[	O
i	int
]	O
,	O
&	O
space	struct
,	O
radius	pointer
[	O
i	int
]	O
)	O
;	O
ps_draw_threads	function
(	O
input	pointer
[	O
i	int
]	O
,	O
radius	pointer
[	O
i	int
]	O
/	O
1000.	int
)	O
;	O
if	O
(	O
i	int
<	O
n	int
-	O
1	int
)	O
y	double
+=	O
input	pointer
[	O
i	int
]	O
->	O
h	int
+	O
PS_CHAR_HEIGHT	int
;	O
}	O
else	O
{	O
struct	O
canvas	struct
canvas	struct
,	O
subcanvas	struct
;	O
canvas_create	function
(	O
&	O
canvas	struct
,	O
x0	int
+	O
input	pointer
[	O
i	int
]	O
->	O
w	int
,	O
input	pointer
[	O
i	int
]	O
->	O
h	int
)	O
;	O
canvas_subdivide	function
(	O
&	O
subcanvas	struct
,	O
&	O
canvas	struct
,	O
x0	int
,	O
0	int
,	O
x0	int
+	O
input	pointer
[	O
i	int
]	O
->	O
w	int
,	O
input	pointer
[	O
i	int
]	O
->	O
h	int
)	O
;	O
text_draw_tree	function
(	O
input	pointer
[	O
i	int
]	O
,	O
&	O
subcanvas	struct
)	O
;	O
canvas_print	function
(	O
&	O
canvas	struct
)	O
;	O
canvas_free	function
(	O
&	O
canvas	struct
)	O
;	O
if	O
(	O
i	int
<	O
n	int
-	O
1	int
)	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
tree_free	function
(	O
input	pointer
[	O
i	int
]	O
)	O
;	O
}	O
if	O
(	O
mode	enum
==	O
MODE_POSTSCRIPT	int
)	O
fputs	function
(	O
"showpage\n"	pointer
"%%EOF\n"	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
mode	enum
==	O
MODE_TEXT	int
)	O
fputs	function
(	O
" \n"	pointer
,	O
stdout	pointer
)	O
;	O
free	function
(	O
input	pointer
)	O
;	O
free	function
(	O
radius	pointer
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
}	O
static	O
void	O
lex_init	function
(	O
struct	O
token	struct
*	O
token	struct
)	O
{	O
token	struct
->	O
ln	int
=	O
1	int
;	O
token	struct
->	O
eof	int
=	O
0	int
;	O
}	O
static	O
void	O
lex_putback	function
(	O
int	O
c	int
)	O
{	O
if	O
(	O
c	int
!=	O
EOF	O
)	O
ungetc	function
(	O
c	int
,	O
stdin	pointer
)	O
;	O
}	O
static	O
void	O
lex_get	function
(	O
struct	O
token	struct
*	O
token	struct
)	O
{	O
int	O
c	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
do	O
{	O
c	int
=	O
getchar	function
(	O
)	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
token	struct
->	O
ln	int
++	O
;	O
}	O
while	O
(	O
isspace	function
(	O
(	O
unsigned	O
char	O
)	O
c	int
)	O
)	O
;	O
if	O
(	O
c	int
!=	O
'#'	O
)	O
break	O
;	O
do	O
{	O
c	int
=	O
getchar	function
(	O
)	O
;	O
}	O
while	O
(	O
c	int
!=	O
'\n'	O
&&	O
c	int
!=	O
EOF	O
)	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
token	struct
->	O
ln	int
++	O
;	O
}	O
token	struct
->	O
c	int
=	O
c	int
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
EOF	O
:	O
token	struct
->	O
type	enum
=	O
TOKEN_EOF	int
;	O
if	O
(	O
token	struct
->	O
eof	int
==	O
1	int
)	O
error	function
(	O
token	struct
,	O
"unexpected end of file"	pointer
)	O
;	O
token	struct
->	O
eof	int
=	O
1	int
;	O
break	O
;	O
case	O
'('	O
:	O
token	struct
->	O
type	enum
=	O
TOKEN_LPAREN	int
;	O
break	O
;	O
case	O
')'	O
:	O
token	struct
->	O
type	enum
=	O
TOKEN_RPAREN	int
;	O
break	O
;	O
case	O
'/'	O
:	O
token	struct
->	O
type	enum
=	O
TOKEN_LEFT	int
;	O
break	O
;	O
case	O
'\\'	O
:	O
token	struct
->	O
type	enum
=	O
TOKEN_RIGHT	int
;	O
break	O
;	O
case	O
','	O
:	O
token	struct
->	O
type	enum
=	O
TOKEN_COMMA	int
;	O
break	O
;	O
case	O
'<'	O
:	O
c	int
=	O
getchar	function
(	O
)	O
;	O
if	O
(	O
c	int
==	O
'>'	O
)	O
token	struct
->	O
type	enum
=	O
TOKEN_TWOWAY	int
;	O
break	O
;	O
case	O
'='	O
:	O
c	int
=	O
getchar	function
(	O
)	O
;	O
if	O
(	O
c	int
==	O
'>'	O
)	O
token	struct
->	O
type	enum
=	O
TOKEN_PRODUCES	int
;	O
else	O
{	O
lex_putback	function
(	O
c	int
)	O
;	O
token	struct
->	O
type	enum
=	O
TOKEN_NAME	int
;	O
}	O
break	O
;	O
case	O
'^'	O
:	O
token	struct
->	O
type	enum
=	O
TOKEN_NO_CIRCLE	int
;	O
break	O
;	O
case	O
'*'	O
:	O
c	int
=	O
getchar	function
(	O
)	O
;	O
if	O
(	O
c	int
==	O
'*'	O
)	O
token	struct
->	O
type	enum
=	O
TOKEN_INCORRECT	int
;	O
else	O
{	O
lex_putback	function
(	O
c	int
)	O
;	O
token	struct
->	O
type	enum
=	O
TOKEN_LEADER	int
;	O
}	O
break	O
;	O
case	O
'%'	O
:	O
token	struct
->	O
type	enum
=	O
TOKEN_SHADE	int
;	O
break	O
;	O
case	O
'|'	O
:	O
c	int
=	O
getchar	function
(	O
)	O
;	O
if	O
(	O
c	int
==	O
'|'	O
)	O
token	struct
->	O
type	enum
=	O
TOKEN_ADJACENT	int
;	O
else	O
{	O
lex_putback	function
(	O
c	int
)	O
;	O
token	struct
->	O
type	enum
=	O
TOKEN_MIDDLE	int
;	O
}	O
break	O
;	O
case	O
'>'	O
:	O
token	struct
->	O
type	enum
=	O
TOKEN_THREAD	int
;	O
break	O
;	O
case	O
'!'	O
:	O
token	struct
->	O
type	enum
=	O
TOKEN_NO_LINE	int
;	O
break	O
;	O
case	O
'"'	O
:	O
token	struct
->	O
type	enum
=	O
TOKEN_QUOTE	int
;	O
break	O
;	O
case	O
'$'	O
:	O
token	struct
->	O
type	enum
=	O
TOKEN_JUSTIFICATION	int
;	O
break	O
;	O
case	O
'@'	O
:	O
token	struct
->	O
type	enum
=	O
TOKEN_SHAPE	int
;	O
break	O
;	O
default	O
:	O
if	O
(	O
isprint	function
(	O
c	int
)	O
)	O
token	struct
->	O
type	enum
=	O
TOKEN_LABEL	int
;	O
else	O
error	function
(	O
token	struct
,	O
"bad character in input"	pointer
)	O
;	O
break	O
;	O
}	O
}	O
static	O
int	O
lex_match	function
(	O
struct	O
token	struct
*	O
token	struct
,	O
enum	O
token_type	enum
type	enum
)	O
{	O
if	O
(	O
token	struct
->	O
type	enum
==	O
type	enum
)	O
{	O
lex_get	function
(	O
token	struct
)	O
;	O
return	O
1	int
;	O
}	O
else	O
return	O
0	int
;	O
}	O
static	O
void	O
add_char	function
(	O
char	O
*	O
*	O
s	pointer
,	O
int	O
c	int
)	O
{	O
size_t	long
len	long
=	O
0	int
;	O
if	O
(	O
*	O
s	pointer
!=	O
NULL	O
)	O
len	long
=	O
strlen	function
(	O
*	O
s	pointer
)	O
;	O
*	O
s	pointer
=	O
xrealloc	function
(	O
*	O
s	pointer
,	O
len	long
+	O
2	int
)	O
;	O
(	O
*	O
s	pointer
)	O
[	O
len	long
]	O
=	O
c	int
;	O
(	O
*	O
s	pointer
)	O
[	O
len	long
+	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
static	O
void	O
lex_get_string	function
(	O
struct	O
token	struct
*	O
token	struct
,	O
char	O
*	O
*	O
s	pointer
)	O
{	O
if	O
(	O
*	O
s	pointer
!=	O
NULL	O
)	O
error	function
(	O
token	struct
,	O
"duplicate node or thread name"	pointer
)	O
;	O
if	O
(	O
token	struct
->	O
type	enum
==	O
TOKEN_QUOTE	int
)	O
{	O
lex_get	function
(	O
token	struct
)	O
;	O
do	O
{	O
if	O
(	O
token	struct
->	O
type	enum
!=	O
TOKEN_LABEL	int
)	O
error	function
(	O
token	struct
,	O
"non-label character inside quoted string"	pointer
)	O
;	O
add_char	function
(	O
s	pointer
,	O
token	struct
->	O
c	int
)	O
;	O
lex_get	function
(	O
token	struct
)	O
;	O
}	O
while	O
(	O
token	struct
->	O
type	enum
!=	O
TOKEN_QUOTE	int
)	O
;	O
}	O
else	O
if	O
(	O
token	struct
->	O
type	enum
==	O
TOKEN_LABEL	int
)	O
add_char	function
(	O
s	pointer
,	O
token	struct
->	O
c	int
)	O
;	O
else	O
error	function
(	O
token	struct
,	O
"node or thread name expected"	pointer
)	O
;	O
}	O
static	O
struct	O
tree	struct
*	O
parse_production	function
(	O
struct	O
token	struct
*	O
token	struct
,	O
struct	O
tree	struct
*	O
tree1	pointer
,	O
enum	O
token_type	enum
,	O
enum	O
output_mode	enum
)	O
;	O
static	O
void	O
parse_tree_label	function
(	O
struct	O
token	struct
*	O
token	struct
,	O
struct	O
tree	struct
*	O
tree	struct
,	O
enum	O
output_mode	enum
mode	enum
)	O
;	O
static	O
struct	O
tree	struct
*	O
tree_parse	function
(	O
struct	O
token	struct
*	O
token	struct
,	O
enum	O
output_mode	enum
mode	enum
)	O
{	O
struct	O
tree	struct
*	O
tree	struct
=	O
xmalloc	function
(	O
sizeof	O
*	O
tree	struct
)	O
;	O
tree	struct
->	O
type	enum
=	O
TREE_BINARY	int
;	O
tree	struct
->	O
options	enum
=	O
0	int
;	O
tree	struct
->	O
thread	array
[	O
0	int
]	O
=	O
tree	struct
->	O
thread	array
[	O
1	int
]	O
=	O
NULL	O
;	O
tree	struct
->	O
margin	array
[	O
0	int
]	O
=	O
tree	struct
->	O
margin	array
[	O
1	int
]	O
=	O
0	int
;	O
tree	struct
->	O
name	pointer
=	O
NULL	O
;	O
parse_tree_label	function
(	O
token	struct
,	O
tree	struct
,	O
mode	enum
)	O
;	O
tree	struct
->	O
link	array
[	O
0	int
]	O
=	O
tree	struct
->	O
link	array
[	O
1	int
]	O
=	O
NULL	O
;	O
if	O
(	O
lex_match	function
(	O
token	struct
,	O
TOKEN_LPAREN	int
)	O
)	O
{	O
if	O
(	O
token	struct
->	O
type	enum
!=	O
TOKEN_COMMA	int
)	O
tree	struct
->	O
link	array
[	O
0	int
]	O
=	O
tree_parse	function
(	O
token	struct
,	O
mode	enum
)	O
;	O
if	O
(	O
lex_match	function
(	O
token	struct
,	O
TOKEN_COMMA	int
)	O
)	O
tree	struct
->	O
link	array
[	O
1	int
]	O
=	O
tree_parse	function
(	O
token	struct
,	O
mode	enum
)	O
;	O
if	O
(	O
!	O
lex_match	function
(	O
token	struct
,	O
TOKEN_RPAREN	int
)	O
)	O
error	function
(	O
token	struct
,	O
"expecting right paren"	pointer
)	O
;	O
}	O
if	O
(	O
strlen	function
(	O
tree	struct
->	O
label	array
[	O
LP_MIDDLE	int
]	O
)	O
==	O
0	int
&&	O
tree	struct
->	O
label	array
[	O
LP_LEFT	int
]	O
==	O
NULL	O
&&	O
tree	struct
->	O
label	array
[	O
LP_RIGHT	int
]	O
==	O
NULL	O
&&	O
tree	struct
->	O
link	array
[	O
0	int
]	O
==	O
NULL	O
&&	O
tree	struct
->	O
link	array
[	O
1	int
]	O
==	O
NULL	O
)	O
error	function
(	O
token	struct
,	O
"node has no label and no children"	pointer
)	O
;	O
if	O
(	O
lex_match	function
(	O
token	struct
,	O
TOKEN_TWOWAY	int
)	O
)	O
return	O
parse_production	function
(	O
token	struct
,	O
tree	struct
,	O
TOKEN_TWOWAY	int
,	O
mode	enum
)	O
;	O
else	O
if	O
(	O
lex_match	function
(	O
token	struct
,	O
TOKEN_PRODUCES	int
)	O
)	O
return	O
parse_production	function
(	O
token	struct
,	O
tree	struct
,	O
TOKEN_PRODUCES	int
,	O
mode	enum
)	O
;	O
else	O
if	O
(	O
lex_match	function
(	O
token	struct
,	O
TOKEN_ADJACENT	int
)	O
)	O
return	O
parse_production	function
(	O
token	struct
,	O
tree	struct
,	O
TOKEN_ADJACENT	int
,	O
mode	enum
)	O
;	O
else	O
return	O
tree	struct
;	O
}	O
static	O
void	O
parse_tree_label	function
(	O
struct	O
token	struct
*	O
token	struct
,	O
struct	O
tree	struct
*	O
tree	struct
,	O
enum	O
output_mode	enum
mode	enum
)	O
{	O
enum	O
label_position	enum
pos	enum
;	O
size_t	long
count	long
;	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
LP_COUNT	int
;	O
i	int
++	O
)	O
tree	struct
->	O
label	array
[	O
i	int
]	O
=	O
NULL	O
;	O
}	O
tree	struct
->	O
shade	int
=	O
100	int
;	O
tree	struct
->	O
justify	int
=	O
'm'	O
;	O
tree	struct
->	O
shape	int
=	O
'c'	O
;	O
pos	enum
=	O
LP_MIDDLE	int
;	O
for	O
(	O
count	long
=	O
0	int
;	O
;	O
lex_get	function
(	O
token	struct
)	O
,	O
count	long
++	O
)	O
switch	O
(	O
token	struct
->	O
type	enum
)	O
{	O
case	O
TOKEN_INCORRECT	int
:	O
add_char	function
(	O
&	O
tree	struct
->	O
label	array
[	O
LP_MIDDLE	int
]	O
,	O
'*'	O
)	O
;	O
add_char	function
(	O
&	O
tree	struct
->	O
label	array
[	O
LP_MIDDLE	int
]	O
,	O
'*'	O
)	O
;	O
tree	struct
->	O
options	enum
|=	O
TOPT_NO_CIRCLE	int
;	O
break	O
;	O
case	O
TOKEN_LEFT	int
:	O
if	O
(	O
mode	enum
==	O
MODE_POSTSCRIPT	int
)	O
pos	enum
=	O
LP_LEFT	int
;	O
break	O
;	O
case	O
TOKEN_RIGHT	int
:	O
if	O
(	O
mode	enum
==	O
MODE_POSTSCRIPT	int
)	O
pos	enum
=	O
LP_RIGHT	int
;	O
break	O
;	O
case	O
TOKEN_MIDDLE	int
:	O
pos	enum
=	O
LP_MIDDLE	int
;	O
break	O
;	O
case	O
TOKEN_LABEL	int
:	O
if	O
(	O
token	struct
->	O
c	int
==	O
'\''	O
)	O
{	O
add_char	function
(	O
&	O
tree	struct
->	O
label	array
[	O
pos	enum
]	O
,	O
'*'	O
)	O
;	O
}	O
else	O
if	O
(	O
token	struct
->	O
c	int
==	O
';'	O
)	O
{	O
if	O
(	O
mode	enum
==	O
MODE_TEXT	int
)	O
add_char	function
(	O
&	O
tree	struct
->	O
label	array
[	O
pos	enum
]	O
,	O
','	O
)	O
;	O
}	O
else	O
add_char	function
(	O
&	O
tree	struct
->	O
label	array
[	O
pos	enum
]	O
,	O
token	struct
->	O
c	int
)	O
;	O
break	O
;	O
break	O
;	O
case	O
TOKEN_SHADE	int
:	O
{	O
char	O
*	O
arg	pointer
=	O
NULL	O
;	O
lex_get	function
(	O
token	struct
)	O
;	O
lex_get_string	function
(	O
token	struct
,	O
&	O
arg	pointer
)	O
;	O
if	O
(	O
mode	enum
==	O
MODE_POSTSCRIPT	int
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
arg	pointer
,	O
"b"	pointer
)	O
)	O
tree	struct
->	O
shade	int
=	O
0	int
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
arg	pointer
,	O
"g"	pointer
)	O
)	O
tree	struct
->	O
shade	int
=	O
100	int
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
arg	pointer
,	O
"r"	pointer
)	O
)	O
tree	struct
->	O
shade	int
=	O
75	int
;	O
else	O
for	O
(	O
;	O
*	O
arg	pointer
!=	O
'\0'	O
;	O
arg	pointer
++	O
)	O
add_char	function
(	O
&	O
tree	struct
->	O
label	array
[	O
pos	enum
]	O
,	O
*	O
arg	pointer
)	O
;	O
}	O
else	O
{	O
add_char	function
(	O
&	O
tree	struct
->	O
label	array
[	O
pos	enum
]	O
,	O
'&'	O
)	O
;	O
add_char	function
(	O
&	O
tree	struct
->	O
label	array
[	O
pos	enum
]	O
,	O
'<'	O
)	O
;	O
for	O
(	O
;	O
*	O
arg	pointer
!=	O
'\0'	O
;	O
arg	pointer
++	O
)	O
add_char	function
(	O
&	O
tree	struct
->	O
label	array
[	O
pos	enum
]	O
,	O
*	O
arg	pointer
)	O
;	O
add_char	function
(	O
&	O
tree	struct
->	O
label	array
[	O
pos	enum
]	O
,	O
'>'	O
)	O
;	O
}	O
}	O
break	O
;	O
case	O
TOKEN_JUSTIFICATION	int
:	O
lex_get	function
(	O
token	struct
)	O
;	O
if	O
(	O
token	struct
->	O
c	int
==	O
't'	O
||	O
token	struct
->	O
c	int
==	O
'm'	O
||	O
token	struct
->	O
c	int
==	O
'b'	O
)	O
tree	struct
->	O
justify	int
=	O
token	struct
->	O
c	int
;	O
else	O
error	function
(	O
token	struct
,	O
"expecting `t', `m', or `b'"	pointer
)	O
;	O
break	O
;	O
case	O
TOKEN_SHAPE	int
:	O
lex_get	function
(	O
token	struct
)	O
;	O
if	O
(	O
token	struct
->	O
c	int
==	O
'c'	O
||	O
token	struct
->	O
c	int
==	O
's'	O
)	O
tree	struct
->	O
shape	int
=	O
token	struct
->	O
c	int
;	O
else	O
error	function
(	O
token	struct
,	O
"expecting `c', `s'"	pointer
)	O
;	O
if	O
(	O
tree	struct
->	O
shape	int
==	O
's'	O
&&	O
mode	enum
==	O
MODE_TEXT	int
)	O
add_char	function
(	O
&	O
tree	struct
->	O
label	array
[	O
LP_MIDDLE	int
]	O
,	O
'['	O
)	O
;	O
break	O
;	O
case	O
TOKEN_NO_CIRCLE	int
:	O
tree	struct
->	O
options	enum
|=	O
TOPT_NO_CIRCLE	int
;	O
break	O
;	O
case	O
TOKEN_NO_LINE	int
:	O
tree	struct
->	O
options	enum
|=	O
TOPT_NO_LINE	int
;	O
break	O
;	O
case	O
TOKEN_LEADER	int
:	O
tree	struct
->	O
options	enum
|=	O
TOPT_LEADER	int
;	O
break	O
;	O
case	O
TOKEN_NAME	int
:	O
lex_get	function
(	O
token	struct
)	O
;	O
lex_get_string	function
(	O
token	struct
,	O
&	O
tree	struct
->	O
name	pointer
)	O
;	O
break	O
;	O
case	O
TOKEN_THREAD	int
:	O
lex_get	function
(	O
token	struct
)	O
;	O
if	O
(	O
token	struct
->	O
type	enum
!=	O
TOKEN_THREAD	int
)	O
lex_get_string	function
(	O
token	struct
,	O
&	O
tree	struct
->	O
name	pointer
)	O
;	O
if	O
(	O
mode	enum
==	O
MODE_POSTSCRIPT	int
)	O
tree	struct
->	O
options	enum
|=	O
TOPT_THREAD	int
;	O
add_char	function
(	O
&	O
tree	struct
->	O
label	array
[	O
LP_MIDDLE	int
]	O
,	O
'['	O
)	O
;	O
if	O
(	O
token	struct
->	O
c	int
!=	O
'>'	O
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
tree	struct
->	O
name	pointer
;	O
*	O
p	pointer
!=	O
'\0'	O
;	O
p	pointer
++	O
)	O
add_char	function
(	O
&	O
tree	struct
->	O
label	array
[	O
LP_MIDDLE	int
]	O
,	O
*	O
p	pointer
)	O
;	O
}	O
add_char	function
(	O
&	O
tree	struct
->	O
label	array
[	O
LP_MIDDLE	int
]	O
,	O
']'	O
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
count	long
==	O
0	int
)	O
error	function
(	O
token	struct
,	O
"expecting label"	pointer
)	O
;	O
if	O
(	O
tree	struct
->	O
shape	int
==	O
's'	O
&&	O
mode	enum
==	O
MODE_TEXT	int
)	O
add_char	function
(	O
&	O
tree	struct
->	O
label	array
[	O
LP_MIDDLE	int
]	O
,	O
']'	O
)	O
;	O
if	O
(	O
tree	struct
->	O
label	array
[	O
LP_MIDDLE	int
]	O
==	O
NULL	O
)	O
add_char	function
(	O
&	O
tree	struct
->	O
label	array
[	O
LP_MIDDLE	int
]	O
,	O
'\0'	O
)	O
;	O
return	O
;	O
}	O
}	O
static	O
struct	O
tree	struct
*	O
parse_production	function
(	O
struct	O
token	struct
*	O
token	struct
,	O
struct	O
tree	struct
*	O
tree1	pointer
,	O
enum	O
token_type	enum
prod_type	enum
,	O
enum	O
output_mode	enum
mode	enum
)	O
{	O
struct	O
tree	struct
*	O
tree2	pointer
=	O
tree_parse	function
(	O
token	struct
,	O
mode	enum
)	O
;	O
struct	O
tree	struct
*	O
production	pointer
=	O
xmalloc	function
(	O
sizeof	O
*	O
production	pointer
)	O
;	O
production	pointer
->	O
type	enum
=	O
TREE_PRODUCTION	int
;	O
production	pointer
->	O
prod_type	enum
=	O
prod_type	enum
;	O
production	pointer
->	O
link	array
[	O
0	int
]	O
=	O
tree1	pointer
;	O
production	pointer
->	O
link	array
[	O
1	int
]	O
=	O
tree2	pointer
;	O
production	pointer
->	O
name	pointer
=	O
NULL	O
;	O
return	O
production	pointer
;	O
}	O
static	O
void	O
tree_free	function
(	O
struct	O
tree	struct
*	O
tree	struct
)	O
{	O
if	O
(	O
tree	struct
->	O
link	array
[	O
0	int
]	O
!=	O
NULL	O
)	O
tree_free	function
(	O
tree	struct
->	O
link	array
[	O
0	int
]	O
)	O
;	O
if	O
(	O
tree	struct
->	O
link	array
[	O
1	int
]	O
!=	O
NULL	O
)	O
tree_free	function
(	O
tree	struct
->	O
link	array
[	O
1	int
]	O
)	O
;	O
free	function
(	O
tree	struct
->	O
name	pointer
)	O
;	O
if	O
(	O
tree	struct
->	O
type	enum
==	O
TREE_BINARY	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
LP_COUNT	int
;	O
i	int
++	O
)	O
free	function
(	O
tree	struct
->	O
label	array
[	O
i	int
]	O
)	O
;	O
}	O
free	function
(	O
tree	struct
)	O
;	O
}	O
static	O
void	O
tree_print	function
(	O
struct	O
tree	struct
*	O
tree	struct
)	O
{	O
switch	O
(	O
tree	struct
->	O
type	enum
)	O
{	O
case	O
TREE_BINARY	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"%s"	pointer
,	O
tree	struct
->	O
label	array
[	O
LP_MIDDLE	int
]	O
)	O
;	O
if	O
(	O
tree	struct
->	O
link	array
[	O
0	int
]	O
!=	O
NULL	O
||	O
tree	struct
->	O
link	array
[	O
1	int
]	O
!=	O
NULL	O
)	O
{	O
putc	function
(	O
'('	O
,	O
stderr	pointer
)	O
;	O
if	O
(	O
tree	struct
->	O
link	array
[	O
0	int
]	O
!=	O
NULL	O
)	O
tree_print	function
(	O
tree	struct
->	O
link	array
[	O
0	int
]	O
)	O
;	O
if	O
(	O
tree	struct
->	O
link	array
[	O
1	int
]	O
!=	O
NULL	O
)	O
{	O
putc	function
(	O
','	O
,	O
stderr	pointer
)	O
;	O
tree_print	function
(	O
tree	struct
->	O
link	array
[	O
1	int
]	O
)	O
;	O
putc	function
(	O
')'	O
,	O
stderr	pointer
)	O
;	O
}	O
}	O
break	O
;	O
case	O
TREE_PRODUCTION	int
:	O
tree_print	function
(	O
tree	struct
->	O
link	array
[	O
0	int
]	O
)	O
;	O
if	O
(	O
tree	struct
->	O
prod_type	enum
==	O
TOKEN_TWOWAY	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
" <> "	pointer
)	O
;	O
else	O
if	O
(	O
tree	struct
->	O
prod_type	enum
==	O
TOKEN_PRODUCES	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
" => "	pointer
)	O
;	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
" || "	pointer
)	O
;	O
tree_print	function
(	O
tree	struct
->	O
link	array
[	O
1	int
]	O
)	O
;	O
break	O
;	O
default	O
:	O
assert	O
(	O
0	int
)	O
;	O
}	O
}	O
static	O
struct	O
tree	struct
*	O
find_node_by_name	function
(	O
struct	O
tree	struct
*	O
tree	struct
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
if	O
(	O
tree	struct
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
!	O
(	O
tree	struct
->	O
options	enum
&	O
TOPT_THREAD	int
)	O
&&	O
tree	struct
->	O
name	pointer
!=	O
NULL	O
&&	O
!	O
strcmp	function
(	O
tree	struct
->	O
name	pointer
,	O
name	pointer
)	O
)	O
return	O
tree	struct
;	O
{	O
struct	O
tree	struct
*	O
tmp	pointer
=	O
find_node_by_name	function
(	O
tree	struct
->	O
link	array
[	O
0	int
]	O
,	O
name	pointer
)	O
;	O
if	O
(	O
tmp	pointer
!=	O
NULL	O
)	O
return	O
tmp	pointer
;	O
}	O
return	O
find_node_by_name	function
(	O
tree	struct
->	O
link	array
[	O
1	int
]	O
,	O
name	pointer
)	O
;	O
}	O
static	O
void	O
ps_resolve_threads	function
(	O
struct	O
tree	struct
*	O
this	pointer
,	O
struct	O
tree	struct
*	O
top	pointer
)	O
{	O
int	O
i	int
;	O
if	O
(	O
this	pointer
==	O
NULL	O
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
2	int
;	O
i	int
++	O
)	O
if	O
(	O
this	pointer
->	O
type	enum
==	O
TREE_BINARY	int
&&	O
this	pointer
->	O
link	array
[	O
i	int
]	O
!=	O
NULL	O
&&	O
(	O
this	pointer
->	O
link	array
[	O
i	int
]	O
->	O
options	enum
&	O
TOPT_THREAD	int
)	O
)	O
{	O
if	O
(	O
this	pointer
->	O
link	array
[	O
i	int
]	O
->	O
name	pointer
!=	O
NULL	O
)	O
{	O
this	pointer
->	O
thread	array
[	O
i	int
]	O
=	O
find_node_by_name	function
(	O
top	pointer
,	O
this	pointer
->	O
link	array
[	O
i	int
]	O
->	O
name	pointer
)	O
;	O
if	O
(	O
this	pointer
->	O
thread	array
[	O
i	int
]	O
==	O
NULL	O
)	O
error	function
(	O
NULL	O
,	O
"thread to nonexistent node %s"	pointer
,	O
this	pointer
->	O
link	array
[	O
i	int
]	O
->	O
name	pointer
)	O
;	O
}	O
else	O
this	pointer
->	O
thread	array
[	O
i	int
]	O
=	O
&	O
outside_thread	struct
;	O
tree_free	function
(	O
this	pointer
->	O
link	array
[	O
i	int
]	O
)	O
;	O
this	pointer
->	O
link	array
[	O
i	int
]	O
=	O
NULL	O
;	O
}	O
else	O
ps_resolve_threads	function
(	O
this	pointer
->	O
link	array
[	O
i	int
]	O
,	O
this	pointer
->	O
type	enum
==	O
TREE_BINARY	int
?	O
top	pointer
:	O
this	pointer
->	O
link	array
[	O
i	int
]	O
)	O
;	O
}	O
static	O
int	O
calc_margin	function
(	O
struct	O
tree	struct
*	O
tree	struct
,	O
int	O
side	int
)	O
{	O
int	O
label_pos	int
=	O
side	int
==	O
0	int
?	O
LP_LEFT	int
:	O
LP_RIGHT	int
;	O
int	O
margin	array
=	O
0	int
;	O
for	O
(	O
;	O
tree	struct
!=	O
NULL	O
;	O
tree	struct
=	O
tree	struct
->	O
link	array
[	O
side	int
]	O
)	O
if	O
(	O
tree	struct
->	O
label	array
[	O
label_pos	int
]	O
!=	O
NULL	O
)	O
{	O
int	O
w	int
,	O
h	int
;	O
int	O
threshold	int
;	O
threshold	int
=	O
0	int
;	O
if	O
(	O
tree	struct
->	O
thread	array
[	O
side	int
]	O
==	O
&	O
outside_thread	struct
)	O
threshold	int
+=	O
PS_THREAD_WIDTH	int
;	O
if	O
(	O
tree	struct
->	O
link	array
[	O
side	int
]	O
!=	O
NULL	O
)	O
threshold	int
+=	O
tree	struct
->	O
link	array
[	O
side	int
]	O
->	O
w	int
;	O
ps_measure_text	function
(	O
tree	struct
->	O
label	array
[	O
label_pos	int
]	O
,	O
&	O
w	int
,	O
&	O
h	int
)	O
;	O
w	int
+=	O
2	int
*	O
PS_MARGIN	int
;	O
if	O
(	O
w	int
>	O
threshold	int
&&	O
w	int
-	O
threshold	int
>	O
margin	array
)	O
margin	array
=	O
w	int
-	O
threshold	int
;	O
}	O
return	O
margin	array
;	O
}	O
static	O
void	O
pad_top_level_tree	function
(	O
struct	O
tree	struct
*	O
tree	struct
)	O
{	O
tree	struct
->	O
w	int
+=	O
tree	struct
->	O
margin	array
[	O
0	int
]	O
=	O
calc_margin	function
(	O
tree	struct
,	O
0	int
)	O
;	O
tree	struct
->	O
w	int
+=	O
tree	struct
->	O
margin	array
[	O
1	int
]	O
=	O
calc_margin	function
(	O
tree	struct
,	O
1	int
)	O
;	O
}	O
static	O
void	O
ps_measure_tree	function
(	O
struct	O
tree	struct
*	O
tree	struct
,	O
int	O
*	O
radius	pointer
)	O
{	O
*	O
radius	pointer
=	O
(	O
ps_determine_diam	function
(	O
tree	struct
)	O
+	O
PS_MARGIN	int
+	O
1	int
)	O
/	O
2	int
;	O
ps_layout_tree	function
(	O
tree	struct
,	O
*	O
radius	pointer
)	O
;	O
if	O
(	O
tree	struct
->	O
type	enum
==	O
TREE_BINARY	int
)	O
pad_top_level_tree	function
(	O
tree	struct
)	O
;	O
}	O
static	O
void	O
ps_draw_tree	function
(	O
struct	O
tree	struct
*	O
tree	struct
,	O
struct	O
space	struct
*	O
space	struct
,	O
int	O
radius	pointer
)	O
{	O
switch	O
(	O
tree	struct
->	O
type	enum
)	O
{	O
case	O
TREE_BINARY	int
:	O
{	O
int	O
x	double
=	O
0	int
;	O
if	O
(	O
tree	struct
->	O
thread	array
[	O
0	int
]	O
==	O
&	O
outside_thread	struct
)	O
x	double
+=	O
PS_THREAD_WIDTH	int
;	O
x	double
+=	O
tree	struct
->	O
margin	array
[	O
0	int
]	O
;	O
if	O
(	O
tree	struct
->	O
options	enum
&	O
TOPT_LEADER	int
)	O
space_subdivide	function
(	O
space	struct
,	O
space	struct
,	O
0	int
,	O
radius	pointer
,	O
space	struct
->	O
w	int
,	O
space	struct
->	O
h	int
)	O
;	O
if	O
(	O
tree	struct
->	O
link	array
[	O
0	int
]	O
!=	O
NULL	O
)	O
{	O
struct	O
space	struct
subspace	struct
;	O
space_subdivide	function
(	O
&	O
subspace	struct
,	O
space	struct
,	O
x	double
,	O
radius	pointer
*	O
3	int
,	O
x	double
+	O
tree	struct
->	O
link	array
[	O
0	int
]	O
->	O
w	int
,	O
radius	pointer
*	O
3	int
+	O
tree	struct
->	O
link	array
[	O
0	int
]	O
->	O
h	int
)	O
;	O
ps_draw_tree	function
(	O
tree	struct
->	O
link	array
[	O
0	int
]	O
,	O
&	O
subspace	struct
,	O
radius	pointer
)	O
;	O
x	double
+=	O
tree	struct
->	O
link	array
[	O
0	int
]	O
->	O
w	int
;	O
if	O
(	O
!	O
(	O
tree	struct
->	O
link	array
[	O
0	int
]	O
->	O
options	enum
&	O
TOPT_NO_LINE	int
)	O
)	O
space_line	function
(	O
space	struct
,	O
x	double
+	O
radius	pointer
,	O
radius	pointer
,	O
tree	struct
->	O
margin	array
[	O
0	int
]	O
+	O
tree	struct
->	O
link	array
[	O
0	int
]	O
->	O
ofs	int
+	O
radius	pointer
,	O
radius	pointer
*	O
4	int
,	O
radius	pointer
,	O
tree	struct
->	O
shape	int
,	O
tree	struct
->	O
link	array
[	O
0	int
]	O
->	O
shape	int
)	O
;	O
}	O
tree	struct
->	O
x	double
=	O
space_xc	function
(	O
space	struct
,	O
x	double
+	O
radius	pointer
)	O
;	O
tree	struct
->	O
y	double
=	O
space_yc	function
(	O
space	struct
,	O
radius	pointer
)	O
;	O
if	O
(	O
!	O
(	O
tree	struct
->	O
options	enum
&	O
TOPT_NO_CIRCLE	int
)	O
)	O
{	O
if	O
(	O
tree	struct
->	O
shape	int
==	O
'c'	O
)	O
space_circle	function
(	O
space	struct
,	O
x	double
+	O
radius	pointer
,	O
radius	pointer
,	O
radius	pointer
,	O
tree	struct
->	O
shade	int
)	O
;	O
else	O
space_square	function
(	O
space	struct
,	O
x	double
,	O
0	int
,	O
x	double
+	O
2	int
*	O
radius	pointer
,	O
2	int
*	O
radius	pointer
,	O
tree	struct
->	O
shade	int
)	O
;	O
space_text	function
(	O
space	struct
,	O
x	double
+	O
radius	pointer
,	O
radius	pointer
,	O
tree	struct
->	O
label	array
[	O
LP_MIDDLE	int
]	O
,	O
JT_CENTER	int
|	O
JT_MIDDLE	int
,	O
1	int
,	O
tree	struct
->	O
shade	int
<=	O
50	int
?	O
100	int
:	O
0	int
)	O
;	O
if	O
(	O
tree	struct
->	O
label	array
[	O
LP_LEFT	int
]	O
!=	O
NULL	O
)	O
space_text	function
(	O
space	struct
,	O
x	double
-	O
PS_MARGIN	int
,	O
radius	pointer
,	O
tree	struct
->	O
label	array
[	O
LP_LEFT	int
]	O
,	O
JT_RIGHT	int
|	O
JT_MIDDLE	int
,	O
1	int
,	O
0	int
)	O
;	O
x	double
+=	O
2	int
*	O
radius	pointer
;	O
if	O
(	O
tree	struct
->	O
label	array
[	O
LP_RIGHT	int
]	O
!=	O
NULL	O
)	O
space_text	function
(	O
space	struct
,	O
x	double
+	O
PS_MARGIN	int
,	O
radius	pointer
,	O
tree	struct
->	O
label	array
[	O
LP_RIGHT	int
]	O
,	O
JT_LEFT	int
|	O
JT_MIDDLE	int
,	O
1	int
,	O
0	int
)	O
;	O
}	O
else	O
{	O
int	O
w	int
,	O
h	int
;	O
ps_measure_text	function
(	O
tree	struct
->	O
label	array
[	O
LP_MIDDLE	int
]	O
,	O
&	O
w	int
,	O
&	O
h	int
)	O
;	O
space_text	function
(	O
space	struct
,	O
x	double
+	O
PS_MARGIN	int
+	O
w	int
/	O
2	int
,	O
radius	pointer
,	O
tree	struct
->	O
label	array
[	O
LP_MIDDLE	int
]	O
,	O
JT_CENTER	int
|	O
JT_TOP	int
,	O
0	int
,	O
0	int
)	O
;	O
x	double
+=	O
w	int
+	O
PS_MARGIN	int
*	O
2	int
;	O
}	O
if	O
(	O
tree	struct
->	O
options	enum
&	O
TOPT_LEADER	int
)	O
space_line	function
(	O
space	struct
,	O
x	double
-	O
radius	pointer
,	O
-	O
radius	pointer
,	O
x	double
-	O
radius	pointer
,	O
0	int
,	O
0	int
,	O
'c'	O
,	O
tree	struct
->	O
shape	int
)	O
;	O
if	O
(	O
tree	struct
->	O
link	array
[	O
1	int
]	O
!=	O
NULL	O
)	O
{	O
struct	O
space	struct
subspace	struct
;	O
if	O
(	O
!	O
(	O
tree	struct
->	O
link	array
[	O
1	int
]	O
->	O
options	enum
&	O
TOPT_NO_LINE	int
)	O
)	O
space_line	function
(	O
space	struct
,	O
x	double
+	O
tree	struct
->	O
link	array
[	O
1	int
]	O
->	O
ofs	int
+	O
radius	pointer
,	O
radius	pointer
*	O
4	int
,	O
x	double
-	O
radius	pointer
,	O
radius	pointer
,	O
radius	pointer
,	O
tree	struct
->	O
link	array
[	O
1	int
]	O
->	O
shape	int
,	O
tree	struct
->	O
shape	int
)	O
;	O
space_subdivide	function
(	O
&	O
subspace	struct
,	O
space	struct
,	O
x	double
,	O
radius	pointer
*	O
3	int
,	O
x	double
+	O
tree	struct
->	O
link	array
[	O
1	int
]	O
->	O
w	int
,	O
radius	pointer
*	O
3	int
+	O
tree	struct
->	O
link	array
[	O
1	int
]	O
->	O
h	int
)	O
;	O
ps_draw_tree	function
(	O
tree	struct
->	O
link	array
[	O
1	int
]	O
,	O
&	O
subspace	struct
,	O
radius	pointer
)	O
;	O
}	O
}	O
break	O
;	O
case	O
TREE_PRODUCTION	int
:	O
{	O
int	O
extra_space	int
;	O
ps_draw_tree_justified	function
(	O
tree	struct
->	O
link	array
[	O
0	int
]	O
,	O
space	struct
,	O
0	int
,	O
radius	pointer
)	O
;	O
if	O
(	O
tree	struct
->	O
prod_type	enum
==	O
TOKEN_PRODUCES	int
)	O
space_special	function
(	O
space	struct
,	O
tree	struct
->	O
link	array
[	O
0	int
]	O
->	O
w	int
,	O
0	int
,	O
PS_CHAR_WIDTH	int
*	O
4	int
,	O
tree	struct
->	O
h	int
,	O
"\\336"	pointer
)	O
;	O
else	O
if	O
(	O
tree	struct
->	O
prod_type	enum
==	O
TOKEN_TWOWAY	int
)	O
space_special	function
(	O
space	struct
,	O
tree	struct
->	O
link	array
[	O
0	int
]	O
->	O
w	int
,	O
0	int
,	O
PS_CHAR_WIDTH	int
*	O
4	int
,	O
tree	struct
->	O
h	int
,	O
"\\333"	pointer
)	O
;	O
if	O
(	O
tree	struct
->	O
prod_type	enum
==	O
TOKEN_ADJACENT	int
)	O
extra_space	int
=	O
2	int
*	O
PS_CHAR_WIDTH	int
;	O
else	O
extra_space	int
=	O
4	int
*	O
PS_CHAR_WIDTH	int
;	O
ps_draw_tree_justified	function
(	O
tree	struct
->	O
link	array
[	O
1	int
]	O
,	O
space	struct
,	O
tree	struct
->	O
link	array
[	O
0	int
]	O
->	O
w	int
+	O
extra_space	int
,	O
radius	pointer
)	O
;	O
}	O
break	O
;	O
default	O
:	O
assert	O
(	O
0	int
)	O
;	O
}	O
}	O
static	O
void	O
ps_draw_threads	function
(	O
const	O
struct	O
tree	struct
*	O
tree	struct
,	O
double	O
radius	pointer
)	O
{	O
int	O
i	int
;	O
if	O
(	O
tree	struct
==	O
NULL	O
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
2	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
tree	struct
->	O
type	enum
==	O
TREE_BINARY	int
&&	O
tree	struct
->	O
thread	array
[	O
i	int
]	O
!=	O
NULL	O
)	O
{	O
double	O
x	double
[	O
4	int
]	O
,	O
y	double
[	O
4	int
]	O
;	O
x	double
[	O
0	int
]	O
=	O
tree	struct
->	O
x	double
-	O
2	int
+	O
4	int
*	O
i	int
;	O
y	double
[	O
0	int
]	O
=	O
tree	struct
->	O
y	double
-	O
radius	pointer
;	O
x	double
[	O
1	int
]	O
=	O
x	double
[	O
0	int
]	O
;	O
y	double
[	O
1	int
]	O
=	O
y	double
[	O
0	int
]	O
-	O
10.	int
;	O
if	O
(	O
tree	struct
->	O
thread	array
[	O
i	int
]	O
!=	O
&	O
outside_thread	struct
)	O
{	O
x	double
[	O
3	int
]	O
=	O
tree	struct
->	O
thread	array
[	O
i	int
]	O
->	O
x	double
+	O
2	int
-	O
4	int
*	O
i	int
;	O
y	double
[	O
3	int
]	O
=	O
tree	struct
->	O
thread	array
[	O
i	int
]	O
->	O
y	double
-	O
radius	pointer
-	O
3	int
;	O
}	O
else	O
{	O
if	O
(	O
i	int
==	O
0	int
)	O
x	double
[	O
3	int
]	O
=	O
x	double
[	O
0	int
]	O
-	O
radius	pointer
-	O
PS_THREAD_WIDTH	int
/	O
1000.	int
+	O
3	int
;	O
else	O
x	double
[	O
3	int
]	O
=	O
x	double
[	O
0	int
]	O
+	O
radius	pointer
+	O
PS_THREAD_WIDTH	int
/	O
1000.	int
-	O
3	int
;	O
y	double
[	O
3	int
]	O
=	O
y	double
[	O
0	int
]	O
+	O
radius	pointer
;	O
}	O
x	double
[	O
2	int
]	O
=	O
x	double
[	O
3	int
]	O
;	O
y	double
[	O
2	int
]	O
=	O
y	double
[	O
1	int
]	O
;	O
printf	function
(	O
"%.1f %.1f %.1f %.1f %.1f %.1f %.1f %.1f T\n"	pointer
,	O
x	double
[	O
1	int
]	O
,	O
y	double
[	O
1	int
]	O
,	O
x	double
[	O
2	int
]	O
,	O
y	double
[	O
2	int
]	O
,	O
x	double
[	O
3	int
]	O
,	O
y	double
[	O
3	int
]	O
,	O
x	double
[	O
0	int
]	O
,	O
y	double
[	O
0	int
]	O
)	O
;	O
printf	function
(	O
"%.1f %.1f A\n"	pointer
,	O
x	double
[	O
3	int
]	O
,	O
y	double
[	O
3	int
]	O
+	O
3	int
)	O
;	O
}	O
ps_draw_threads	function
(	O
tree	struct
->	O
link	array
[	O
i	int
]	O
,	O
radius	pointer
)	O
;	O
}	O
}	O
static	O
int	O
ps_determine_diam	function
(	O
const	O
struct	O
tree	struct
*	O
tree	struct
)	O
{	O
int	O
w	int
,	O
h	int
;	O
int	O
diam	int
;	O
if	O
(	O
tree	struct
->	O
type	enum
==	O
TREE_BINARY	int
&&	O
!	O
(	O
tree	struct
->	O
options	enum
&	O
TOPT_NO_CIRCLE	int
)	O
)	O
{	O
ps_measure_text	function
(	O
tree	struct
->	O
label	array
[	O
LP_MIDDLE	int
]	O
,	O
&	O
w	int
,	O
&	O
h	int
)	O
;	O
diam	int
=	O
max	function
(	O
w	int
,	O
h	int
)	O
;	O
}	O
else	O
diam	int
=	O
0	int
;	O
if	O
(	O
tree	struct
->	O
link	array
[	O
0	int
]	O
!=	O
NULL	O
)	O
diam	int
=	O
max	function
(	O
diam	int
,	O
ps_determine_diam	function
(	O
tree	struct
->	O
link	array
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
tree	struct
->	O
link	array
[	O
1	int
]	O
!=	O
NULL	O
)	O
diam	int
=	O
max	function
(	O
diam	int
,	O
ps_determine_diam	function
(	O
tree	struct
->	O
link	array
[	O
1	int
]	O
)	O
)	O
;	O
return	O
diam	int
;	O
}	O
static	O
void	O
ps_measure_text	function
(	O
const	O
char	O
*	O
text	pointer
,	O
int	O
*	O
w	int
,	O
int	O
*	O
h	int
)	O
{	O
int	O
ll	int
=	O
0	int
;	O
*	O
w	int
=	O
0	int
;	O
*	O
h	int
=	O
PS_CHAR_HEIGHT	int
;	O
for	O
(	O
;	O
;	O
text	pointer
++	O
)	O
switch	O
(	O
*	O
text	pointer
)	O
{	O
case	O
'\0'	O
:	O
*	O
w	int
=	O
(	O
*	O
w	int
/	O
10	int
)	O
*	O
(	O
PS_CHAR_HEIGHT	int
/	O
10	int
)	O
/	O
10	int
;	O
return	O
;	O
case	O
'&'	O
:	O
*	O
h	int
+=	O
PS_CHAR_HEIGHT	int
;	O
ll	int
=	O
0	int
;	O
break	O
;	O
default	O
:	O
{	O
int	O
ch	int
=	O
*	O
text	pointer
==	O
'_'	O
?	O
' '	O
:	O
(	O
unsigned	O
char	O
)	O
*	O
text	pointer
;	O
int	O
first	int
=	O
ll	int
==	O
0	int
;	O
int	O
last	int
=	O
ch	int
!=	O
'\''	O
&&	O
(	O
text	pointer
[	O
1	int
]	O
==	O
'&'	O
||	O
text	pointer
[	O
1	int
]	O
==	O
'\0'	O
)	O
;	O
struct	O
character	struct
*	O
c	int
=	O
&	O
font	struct
.	O
chars	pointer
[	O
font	struct
.	O
map	pointer
[	O
ch	int
]	O
]	O
;	O
if	O
(	O
first	int
&&	O
last	int
)	O
ll	int
+=	O
c	int
->	O
urx	int
-	O
c	int
->	O
llx	int
;	O
else	O
if	O
(	O
first	int
)	O
ll	int
+=	O
c	int
->	O
wx	int
-	O
c	int
->	O
llx	int
;	O
else	O
if	O
(	O
last	int
)	O
ll	int
+=	O
c	int
->	O
urx	int
;	O
else	O
ll	int
+=	O
c	int
->	O
wx	int
;	O
}	O
*	O
w	int
=	O
max	function
(	O
ll	int
,	O
*	O
w	int
)	O
;	O
break	O
;	O
}	O
}	O
static	O
void	O
ps_layout_tree	function
(	O
struct	O
tree	struct
*	O
tree	struct
,	O
int	O
radius	pointer
)	O
{	O
switch	O
(	O
tree	struct
->	O
type	enum
)	O
{	O
case	O
TREE_BINARY	int
:	O
{	O
int	O
subtree_height	int
=	O
0	int
;	O
if	O
(	O
!	O
(	O
tree	struct
->	O
options	enum
&	O
TOPT_NO_CIRCLE	int
)	O
)	O
tree	struct
->	O
w	int
=	O
tree	struct
->	O
h	int
=	O
2	int
*	O
radius	pointer
;	O
else	O
{	O
ps_measure_text	function
(	O
tree	struct
->	O
label	array
[	O
LP_MIDDLE	int
]	O
,	O
&	O
tree	struct
->	O
w	int
,	O
&	O
tree	struct
->	O
h	int
)	O
;	O
tree	struct
->	O
w	int
+=	O
2	int
*	O
PS_MARGIN	int
;	O
tree	struct
->	O
h	int
+=	O
2	int
*	O
PS_MARGIN	int
;	O
}	O
tree	struct
->	O
ofs	int
=	O
0	int
;	O
if	O
(	O
tree	struct
->	O
link	array
[	O
0	int
]	O
!=	O
NULL	O
)	O
{	O
ps_layout_tree	function
(	O
tree	struct
->	O
link	array
[	O
0	int
]	O
,	O
radius	pointer
)	O
;	O
tree	struct
->	O
w	int
+=	O
tree	struct
->	O
ofs	int
=	O
tree	struct
->	O
link	array
[	O
0	int
]	O
->	O
w	int
;	O
subtree_height	int
=	O
radius	pointer
+	O
tree	struct
->	O
link	array
[	O
0	int
]	O
->	O
h	int
;	O
}	O
if	O
(	O
tree	struct
->	O
thread	array
[	O
0	int
]	O
==	O
&	O
outside_thread	struct
)	O
{	O
tree	struct
->	O
w	int
+=	O
PS_THREAD_WIDTH	int
;	O
tree	struct
->	O
ofs	int
+=	O
PS_THREAD_WIDTH	int
;	O
}	O
if	O
(	O
tree	struct
->	O
link	array
[	O
1	int
]	O
!=	O
NULL	O
)	O
{	O
ps_layout_tree	function
(	O
tree	struct
->	O
link	array
[	O
1	int
]	O
,	O
radius	pointer
)	O
;	O
tree	struct
->	O
w	int
+=	O
tree	struct
->	O
link	array
[	O
1	int
]	O
->	O
w	int
;	O
subtree_height	int
=	O
max	function
(	O
subtree_height	int
,	O
radius	pointer
+	O
tree	struct
->	O
link	array
[	O
1	int
]	O
->	O
h	int
)	O
;	O
}	O
tree	struct
->	O
h	int
+=	O
subtree_height	int
;	O
if	O
(	O
tree	struct
->	O
thread	array
[	O
1	int
]	O
==	O
&	O
outside_thread	struct
)	O
tree	struct
->	O
w	int
+=	O
PS_THREAD_WIDTH	int
;	O
if	O
(	O
subtree_height	int
==	O
0	int
&&	O
(	O
tree	struct
->	O
thread	array
[	O
0	int
]	O
!=	O
NULL	O
||	O
tree	struct
->	O
thread	array
[	O
1	int
]	O
!=	O
NULL	O
)	O
)	O
tree	struct
->	O
h	int
+=	O
PS_THREAD_HEIGHT	int
;	O
if	O
(	O
tree	struct
->	O
options	enum
&	O
TOPT_LEADER	int
)	O
tree	struct
->	O
h	int
+=	O
radius	pointer
;	O
}	O
break	O
;	O
case	O
TREE_PRODUCTION	int
:	O
{	O
int	O
extra_space	int
;	O
ps_layout_tree	function
(	O
tree	struct
->	O
link	array
[	O
0	int
]	O
,	O
radius	pointer
)	O
;	O
ps_layout_tree	function
(	O
tree	struct
->	O
link	array
[	O
1	int
]	O
,	O
radius	pointer
)	O
;	O
pad_top_level_tree	function
(	O
tree	struct
->	O
link	array
[	O
0	int
]	O
)	O
;	O
if	O
(	O
tree	struct
->	O
link	array
[	O
1	int
]	O
->	O
type	enum
==	O
TREE_BINARY	int
)	O
pad_top_level_tree	function
(	O
tree	struct
->	O
link	array
[	O
1	int
]	O
)	O
;	O
if	O
(	O
tree	struct
->	O
prod_type	enum
==	O
TOKEN_ADJACENT	int
)	O
extra_space	int
=	O
2	int
*	O
PS_CHAR_WIDTH	int
;	O
else	O
extra_space	int
=	O
4	int
*	O
PS_CHAR_WIDTH	int
;	O
tree	struct
->	O
w	int
=	O
tree	struct
->	O
link	array
[	O
0	int
]	O
->	O
w	int
+	O
extra_space	int
+	O
tree	struct
->	O
link	array
[	O
1	int
]	O
->	O
w	int
;	O
tree	struct
->	O
h	int
=	O
max	function
(	O
tree	struct
->	O
link	array
[	O
0	int
]	O
->	O
h	int
,	O
tree	struct
->	O
link	array
[	O
1	int
]	O
->	O
h	int
)	O
;	O
}	O
break	O
;	O
default	O
:	O
assert	O
(	O
0	int
)	O
;	O
}	O
}	O
static	O
void	O
ps_draw_tree_justified	function
(	O
struct	O
tree	struct
*	O
tree	struct
,	O
struct	O
space	struct
*	O
space	struct
,	O
int	O
x	double
,	O
int	O
radius	pointer
)	O
{	O
struct	O
space	struct
subspace	struct
;	O
int	O
ofs	int
;	O
if	O
(	O
tree	struct
->	O
type	enum
==	O
TREE_BINARY	int
)	O
{	O
if	O
(	O
tree	struct
->	O
justify	int
==	O
'm'	O
)	O
ofs	int
=	O
(	O
space	struct
->	O
h	int
-	O
tree	struct
->	O
h	int
)	O
/	O
2	int
;	O
else	O
if	O
(	O
tree	struct
->	O
justify	int
==	O
'b'	O
)	O
ofs	int
=	O
(	O
space	struct
->	O
h	int
-	O
tree	struct
->	O
h	int
)	O
;	O
else	O
ofs	int
=	O
0	int
;	O
}	O
else	O
ofs	int
=	O
0	int
;	O
space_subdivide	function
(	O
&	O
subspace	struct
,	O
space	struct
,	O
x	double
,	O
ofs	int
,	O
x	double
+	O
tree	struct
->	O
w	int
,	O
ofs	int
+	O
tree	struct
->	O
h	int
)	O
;	O
ps_draw_tree	function
(	O
tree	struct
,	O
&	O
subspace	struct
,	O
radius	pointer
)	O
;	O
}	O
static	O
void	O
space_create	function
(	O
struct	O
space	struct
*	O
space	struct
,	O
int	O
w	int
,	O
int	O
h	int
)	O
{	O
space	struct
->	O
x0	int
=	O
space	struct
->	O
y0	int
=	O
0	int
;	O
space	struct
->	O
w	int
=	O
w	int
;	O
space	struct
->	O
h	int
=	O
space	struct
->	O
sh	int
=	O
h	int
;	O
}	O
static	O
void	O
space_subdivide	function
(	O
struct	O
space	struct
*	O
dst	pointer
,	O
const	O
struct	O
space	struct
*	O
src	pointer
,	O
int	O
x0	int
,	O
int	O
y0	int
,	O
int	O
x1	int
,	O
int	O
y1	int
)	O
{	O
assert	O
(	O
x0	int
>=	O
0	int
&&	O
x0	int
<	O
src	pointer
->	O
w	int
&&	O
x1	int
>=	O
x0	int
&&	O
x1	int
<=	O
src	pointer
->	O
w	int
)	O
;	O
assert	O
(	O
y0	int
>=	O
0	int
&&	O
y0	int
<	O
src	pointer
->	O
h	int
&&	O
y1	int
>=	O
y0	int
&&	O
y1	int
<=	O
src	pointer
->	O
h	int
)	O
;	O
dst	pointer
->	O
sh	int
=	O
src	pointer
->	O
sh	int
;	O
dst	pointer
->	O
x0	int
=	O
src	pointer
->	O
x0	int
+	O
x0	int
;	O
dst	pointer
->	O
w	int
=	O
x1	int
-	O
x0	int
;	O
dst	pointer
->	O
y0	int
=	O
src	pointer
->	O
y0	int
+	O
y0	int
;	O
dst	pointer
->	O
h	int
=	O
y1	int
-	O
y0	int
;	O
}	O
static	O
void	O
space_line	function
(	O
struct	O
space	struct
*	O
space	struct
,	O
int	O
x0	int
,	O
int	O
y0	int
,	O
int	O
x1	int
,	O
int	O
y1	int
,	O
int	O
radius	pointer
,	O
int	O
s0	int
,	O
int	O
s1	int
)	O
{	O
double	O
ax0	double
,	O
ay0	double
;	O
double	O
ax1	double
,	O
ay1	double
;	O
space_distance_along	function
(	O
x0	int
,	O
y0	int
,	O
x1	int
,	O
y1	int
,	O
radius	pointer
,	O
-	O
1	int
,	O
&	O
ax0	double
,	O
&	O
ay0	double
,	O
s0	int
)	O
;	O
space_distance_along	function
(	O
x1	int
,	O
y1	int
,	O
x0	int
,	O
y0	int
,	O
radius	pointer
,	O
+	O
1	int
,	O
&	O
ax1	double
,	O
&	O
ay1	double
,	O
s1	int
)	O
;	O
printf	function
(	O
"%.1f %.1f %.1f %.1f L\n"	pointer
,	O
space_xc	function
(	O
space	struct
,	O
ax0	double
)	O
,	O
space_yc	function
(	O
space	struct
,	O
ay0	double
)	O
,	O
space_xc	function
(	O
space	struct
,	O
ax1	double
)	O
,	O
space_yc	function
(	O
space	struct
,	O
ay1	double
)	O
)	O
;	O
}	O
static	O
void	O
space_circle	function
(	O
struct	O
space	struct
*	O
space	struct
,	O
int	O
x	double
,	O
int	O
y	double
,	O
int	O
radius	pointer
,	O
int	O
shade	int
)	O
{	O
double	O
x0	int
=	O
space_xc	function
(	O
space	struct
,	O
x	double
)	O
;	O
double	O
y0	int
=	O
space_yc	function
(	O
space	struct
,	O
y	double
)	O
;	O
if	O
(	O
shade	int
!=	O
100	int
)	O
printf	function
(	O
"%.1f %.1f %.1f %d D\n"	pointer
,	O
x0	int
,	O
y0	int
,	O
radius	pointer
/	O
1000.	int
,	O
shade	int
)	O
;	O
printf	function
(	O
"%.1f %.1f %.1f C\n"	pointer
,	O
x0	int
,	O
y0	int
,	O
radius	pointer
/	O
1000.	int
)	O
;	O
}	O
static	O
void	O
space_square	function
(	O
struct	O
space	struct
*	O
space	struct
,	O
int	O
px0	int
,	O
int	O
py0	int
,	O
int	O
px1	int
,	O
int	O
py1	int
,	O
int	O
shade	int
)	O
{	O
double	O
x0	int
=	O
space_xc	function
(	O
space	struct
,	O
px0	int
)	O
;	O
double	O
y0	int
=	O
space_yc	function
(	O
space	struct
,	O
py0	int
)	O
;	O
double	O
x1	int
=	O
space_xc	function
(	O
space	struct
,	O
px1	int
)	O
;	O
double	O
y1	int
=	O
space_yc	function
(	O
space	struct
,	O
py1	int
)	O
;	O
if	O
(	O
shade	int
!=	O
100	int
)	O
printf	function
(	O
"%.1f %.1f %.1f %.1f %d SS\n"	pointer
,	O
x0	int
,	O
y0	int
,	O
x1	int
,	O
y1	int
,	O
shade	int
)	O
;	O
printf	function
(	O
"%.1f %.1f %.1f %.1f SD\n"	pointer
,	O
x0	int
,	O
y0	int
,	O
x1	int
,	O
y1	int
)	O
;	O
}	O
static	O
void	O
space_text	function
(	O
struct	O
space	struct
*	O
space	struct
,	O
int	O
x	double
,	O
int	O
y	double
,	O
const	O
char	O
*	O
text	pointer
,	O
enum	O
justification	enum
j	enum
,	O
int	O
adjust_height	int
,	O
int	O
shade	int
)	O
{	O
enum	O
justification	enum
h	int
=	O
j	enum
&	O
JT_HORZ	int
;	O
enum	O
justification	enum
v	enum
=	O
j	enum
&	O
JT_VERT	int
;	O
int	O
tw	int
,	O
th	int
;	O
ps_measure_text	function
(	O
text	pointer
,	O
&	O
tw	int
,	O
&	O
th	int
)	O
;	O
{	O
struct	O
character	struct
*	O
c	int
=	O
&	O
font	struct
.	O
chars	pointer
[	O
font	struct
.	O
map	pointer
[	O
(	O
unsigned	O
char	O
)	O
*	O
text	pointer
]	O
]	O
;	O
if	O
(	O
v	enum
==	O
JT_MIDDLE	int
)	O
{	O
if	O
(	O
adjust_height	int
&&	O
strlen	function
(	O
text	pointer
)	O
==	O
1	int
)	O
y	double
+=	O
(	O
(	O
c	int
->	O
ury	int
-	O
c	int
->	O
lly	int
)	O
/	O
2	int
+	O
c	int
->	O
lly	int
)	O
*	O
PS_CHAR_HEIGHT	int
/	O
1000	int
;	O
else	O
y	double
+=	O
PS_CHAR_HEIGHT	int
*	O
3	int
/	O
4	int
-	O
th	int
/	O
2	int
;	O
}	O
else	O
y	double
+=	O
PS_CHAR_HEIGHT	int
*	O
3	int
/	O
8	int
;	O
x	double
-=	O
c	int
->	O
llx	int
;	O
}	O
if	O
(	O
!	O
strcmp	function
(	O
text	pointer
,	O
"**"	pointer
)	O
)	O
{	O
space_special	function
(	O
space	struct
,	O
x	double
,	O
y	double
,	O
tw	int
+	O
PS_CHAR_WIDTH	int
,	O
th	int
-	O
PS_CHAR_HEIGHT	int
/	O
2	int
,	O
"**"	pointer
)	O
;	O
return	O
;	O
}	O
while	O
(	O
*	O
text	pointer
!=	O
'\0'	O
)	O
{	O
printf	function
(	O
"%.1f %.1f ("	pointer
,	O
space_xc	function
(	O
space	struct
,	O
x	double
)	O
,	O
space_yc	function
(	O
space	struct
,	O
y	double
)	O
)	O
;	O
for	O
(	O
;	O
*	O
text	pointer
&&	O
*	O
text	pointer
!=	O
'&'	O
;	O
text	pointer
++	O
)	O
if	O
(	O
*	O
text	pointer
==	O
'_'	O
)	O
putchar	function
(	O
' '	O
)	O
;	O
else	O
putchar	function
(	O
*	O
text	pointer
)	O
;	O
printf	function
(	O
") %d T%c\n"	pointer
,	O
shade	int
,	O
h	int
==	O
JT_CENTER	int
?	O
'C'	O
:	O
h	int
==	O
JT_LEFT	int
?	O
'L'	O
:	O
'R'	O
)	O
;	O
if	O
(	O
*	O
text	pointer
==	O
'&'	O
)	O
{	O
text	pointer
++	O
;	O
y	double
+=	O
PS_CHAR_HEIGHT	int
;	O
}	O
}	O
}	O
static	O
void	O
space_special	function
(	O
struct	O
space	struct
*	O
space	struct
,	O
int	O
x	double
,	O
int	O
y	double
,	O
int	O
w	int
,	O
int	O
h	int
,	O
const	O
char	O
*	O
c	int
)	O
{	O
x	double
+=	O
w	int
/	O
2	int
;	O
y	double
+=	O
(	O
h	int
-	O
PS_CHAR_HEIGHT	int
)	O
/	O
2	int
+	O
(	O
PS_CHAR_HEIGHT	int
*	O
3	int
/	O
4	int
)	O
;	O
printf	function
(	O
"%.0f %.0f (%s) S\n"	pointer
,	O
space_xc	function
(	O
space	struct
,	O
x	double
)	O
,	O
space_yc	function
(	O
space	struct
,	O
y	double
)	O
,	O
c	int
)	O
;	O
}	O
static	O
double	O
space_xc	function
(	O
const	O
struct	O
space	struct
*	O
space	struct
,	O
double	O
x	double
)	O
{	O
return	O
(	O
x	double
+	O
space	struct
->	O
x0	int
)	O
/	O
1000.	int
;	O
}	O
static	O
double	O
space_yc	function
(	O
const	O
struct	O
space	struct
*	O
space	struct
,	O
double	O
y	double
)	O
{	O
return	O
(	O
space	struct
->	O
sh	int
-	O
(	O
y	double
+	O
space	struct
->	O
y0	int
)	O
)	O
/	O
1000.	int
;	O
}	O
static	O
void	O
space_distance_along	function
(	O
double	O
x0	int
,	O
double	O
y0	int
,	O
double	O
x1	int
,	O
double	O
y1	int
,	O
double	O
radius	pointer
,	O
int	O
dir	int
,	O
double	O
*	O
x	double
,	O
double	O
*	O
y	double
,	O
int	O
shape	int
)	O
{	O
if	O
(	O
shape	int
==	O
'c'	O
)	O
{	O
if	O
(	O
x1	int
!=	O
x0	int
)	O
{	O
double	O
m	int
=	O
(	O
y1	int
-	O
y0	int
)	O
/	O
(	O
x1	int
-	O
x0	int
)	O
;	O
double	O
dx	double
=	O
radius	pointer
/	O
sqrt	function
(	O
m	int
*	O
m	int
+	O
1	int
)	O
;	O
double	O
dy	double
=	O
m	int
*	O
dx	double
;	O
*	O
x	double
=	O
x0	int
+	O
dx	double
*	O
dir	int
;	O
*	O
y	double
=	O
y0	int
+	O
dy	double
*	O
dir	int
;	O
}	O
else	O
{	O
*	O
x	double
=	O
x0	int
;	O
*	O
y	double
=	O
y0	int
;	O
}	O
}	O
else	O
{	O
*	O
x	double
=	O
x0	int
;	O
*	O
y	double
=	O
y0	int
-	O
radius	pointer
;	O
}	O
}	O
static	O
void	O
text_measure_tree	function
(	O
struct	O
tree	struct
*	O
tree	struct
)	O
{	O
switch	O
(	O
tree	struct
->	O
type	enum
)	O
{	O
case	O
TREE_BINARY	int
:	O
if	O
(	O
tree	struct
->	O
link	array
[	O
0	int
]	O
!=	O
NULL	O
)	O
text_measure_tree	function
(	O
tree	struct
->	O
link	array
[	O
0	int
]	O
)	O
;	O
if	O
(	O
tree	struct
->	O
link	array
[	O
1	int
]	O
!=	O
NULL	O
)	O
text_measure_tree	function
(	O
tree	struct
->	O
link	array
[	O
1	int
]	O
)	O
;	O
if	O
(	O
text_caret	function
(	O
tree	struct
)	O
)	O
{	O
tree	struct
->	O
w	int
=	O
3	int
;	O
tree	struct
->	O
h	int
=	O
3	int
;	O
tree	struct
->	O
ofs	int
=	O
1	int
;	O
}	O
else	O
{	O
int	O
subtree_height	int
=	O
0	int
;	O
text_measure_text	function
(	O
tree	struct
->	O
label	array
[	O
LP_MIDDLE	int
]	O
,	O
&	O
tree	struct
->	O
w	int
,	O
&	O
tree	struct
->	O
h	int
)	O
;	O
if	O
(	O
tree	struct
->	O
link	array
[	O
0	int
]	O
!=	O
NULL	O
)	O
{	O
assert	O
(	O
tree	struct
->	O
link	array
[	O
0	int
]	O
->	O
ofs	int
>=	O
0	int
&&	O
tree	struct
->	O
link	array
[	O
0	int
]	O
->	O
ofs	int
<	O
tree	struct
->	O
link	array
[	O
0	int
]	O
->	O
w	int
)	O
;	O
if	O
(	O
tree	struct
->	O
link	array
[	O
0	int
]	O
->	O
ofs	int
==	O
tree	struct
->	O
link	array
[	O
0	int
]	O
->	O
w	int
-	O
1	int
)	O
tree	struct
->	O
link	array
[	O
0	int
]	O
=	O
text_shift_tree	function
(	O
tree	struct
->	O
link	array
[	O
0	int
]	O
,	O
-	O
1	int
)	O
;	O
tree	struct
->	O
w	int
+=	O
tree	struct
->	O
ofs	int
=	O
tree	struct
->	O
link	array
[	O
0	int
]	O
->	O
w	int
;	O
subtree_height	int
=	O
max	function
(	O
subtree_height	int
,	O
1	int
+	O
tree	struct
->	O
link	array
[	O
0	int
]	O
->	O
h	int
)	O
;	O
}	O
else	O
tree	struct
->	O
ofs	int
=	O
0	int
;	O
if	O
(	O
tree	struct
->	O
link	array
[	O
1	int
]	O
!=	O
NULL	O
)	O
{	O
assert	O
(	O
tree	struct
->	O
link	array
[	O
1	int
]	O
->	O
ofs	int
>=	O
0	int
&&	O
tree	struct
->	O
link	array
[	O
1	int
]	O
->	O
ofs	int
<	O
tree	struct
->	O
link	array
[	O
1	int
]	O
->	O
w	int
)	O
;	O
if	O
(	O
tree	struct
->	O
link	array
[	O
1	int
]	O
->	O
ofs	int
==	O
0	int
)	O
tree	struct
->	O
link	array
[	O
1	int
]	O
=	O
text_shift_tree	function
(	O
tree	struct
->	O
link	array
[	O
1	int
]	O
,	O
+	O
1	int
)	O
;	O
tree	struct
->	O
w	int
+=	O
tree	struct
->	O
link	array
[	O
1	int
]	O
->	O
w	int
;	O
subtree_height	int
=	O
max	function
(	O
subtree_height	int
,	O
1	int
+	O
tree	struct
->	O
link	array
[	O
1	int
]	O
->	O
h	int
)	O
;	O
}	O
tree	struct
->	O
h	int
+=	O
subtree_height	int
;	O
}	O
if	O
(	O
tree	struct
->	O
options	enum
&	O
TOPT_LEADER	int
)	O
tree	struct
->	O
h	int
++	O
;	O
break	O
;	O
case	O
TREE_PRODUCTION	int
:	O
{	O
text_measure_tree	function
(	O
tree	struct
->	O
link	array
[	O
0	int
]	O
)	O
;	O
text_measure_tree	function
(	O
tree	struct
->	O
link	array
[	O
1	int
]	O
)	O
;	O
tree	struct
->	O
w	int
=	O
tree	struct
->	O
link	array
[	O
0	int
]	O
->	O
w	int
+	O
4	int
+	O
tree	struct
->	O
link	array
[	O
1	int
]	O
->	O
w	int
;	O
tree	struct
->	O
h	int
=	O
max	function
(	O
tree	struct
->	O
link	array
[	O
0	int
]	O
->	O
h	int
,	O
tree	struct
->	O
link	array
[	O
1	int
]	O
->	O
h	int
)	O
;	O
}	O
break	O
;	O
default	O
:	O
assert	O
(	O
0	int
)	O
;	O
}	O
}	O
static	O
char	O
text_first_char	function
(	O
const	O
char	O
*	O
s	pointer
)	O
{	O
while	O
(	O
*	O
s	pointer
==	O
'&'	O
||	O
*	O
s	pointer
==	O
'_'	O
)	O
s	pointer
++	O
;	O
return	O
*	O
s	pointer
;	O
}	O
static	O
void	O
text_draw_tree	function
(	O
const	O
struct	O
tree	struct
*	O
tree	struct
,	O
struct	O
canvas	struct
*	O
canvas	struct
)	O
{	O
switch	O
(	O
tree	struct
->	O
type	enum
)	O
{	O
case	O
TREE_BINARY	int
:	O
{	O
struct	O
canvas	struct
c	int
;	O
int	O
x	double
,	O
tx	int
,	O
ty	int
;	O
if	O
(	O
tree	struct
->	O
options	enum
&	O
TOPT_LEADER	int
)	O
canvas_subdivide	function
(	O
&	O
c	int
,	O
canvas	struct
,	O
0	int
,	O
1	int
,	O
canvas	struct
->	O
w	int
,	O
canvas	struct
->	O
h	int
)	O
;	O
else	O
c	int
=	O
*	O
canvas	struct
;	O
x	double
=	O
0	int
;	O
if	O
(	O
text_caret	function
(	O
tree	struct
)	O
)	O
{	O
canvas_set	function
(	O
&	O
c	int
,	O
1	int
,	O
0	int
,	O
text_first_char	function
(	O
tree	struct
->	O
label	array
[	O
LP_MIDDLE	int
]	O
)	O
)	O
;	O
canvas_set	function
(	O
&	O
c	int
,	O
1	int
,	O
1	int
,	O
'^'	O
)	O
;	O
canvas_set	function
(	O
&	O
c	int
,	O
0	int
,	O
2	int
,	O
text_first_char	function
(	O
tree	struct
->	O
link	array
[	O
0	int
]	O
->	O
label	array
[	O
LP_MIDDLE	int
]	O
)	O
)	O
;	O
canvas_set	function
(	O
&	O
c	int
,	O
2	int
,	O
2	int
,	O
text_first_char	function
(	O
tree	struct
->	O
link	array
[	O
1	int
]	O
->	O
label	array
[	O
LP_MIDDLE	int
]	O
)	O
)	O
;	O
if	O
(	O
tree	struct
->	O
options	enum
&	O
TOPT_LEADER	int
)	O
canvas_set	function
(	O
canvas	struct
,	O
1	int
,	O
0	int
,	O
'|'	O
)	O
;	O
return	O
;	O
}	O
text_measure_text	function
(	O
tree	struct
->	O
label	array
[	O
LP_MIDDLE	int
]	O
,	O
&	O
tx	int
,	O
&	O
ty	int
)	O
;	O
if	O
(	O
tree	struct
->	O
link	array
[	O
0	int
]	O
!=	O
NULL	O
)	O
{	O
struct	O
canvas	struct
subcanvas	struct
;	O
canvas_subdivide	function
(	O
&	O
subcanvas	struct
,	O
&	O
c	int
,	O
x	double
,	O
ty	int
+	O
1	int
,	O
x	double
+	O
tree	struct
->	O
link	array
[	O
0	int
]	O
->	O
w	int
,	O
ty	int
+	O
1	int
+	O
tree	struct
->	O
link	array
[	O
0	int
]	O
->	O
h	int
)	O
;	O
text_draw_tree	function
(	O
tree	struct
->	O
link	array
[	O
0	int
]	O
,	O
&	O
subcanvas	struct
)	O
;	O
x	double
+=	O
tree	struct
->	O
link	array
[	O
0	int
]	O
->	O
w	int
;	O
if	O
(	O
!	O
(	O
tree	struct
->	O
link	array
[	O
0	int
]	O
->	O
options	enum
&	O
TOPT_NO_LINE	int
)	O
)	O
text_draw_line	function
(	O
&	O
c	int
,	O
tree	struct
->	O
link	array
[	O
0	int
]	O
->	O
ofs	int
+	O
1	int
,	O
x	double
,	O
ty	int
)	O
;	O
}	O
if	O
(	O
tree	struct
->	O
options	enum
&	O
TOPT_LEADER	int
)	O
canvas_set	function
(	O
canvas	struct
,	O
x	double
+	O
tx	int
/	O
2	int
,	O
0	int
,	O
'|'	O
)	O
;	O
text_draw_text	function
(	O
&	O
c	int
,	O
x	double
,	O
0	int
,	O
tx	int
,	O
tree	struct
->	O
label	array
[	O
LP_MIDDLE	int
]	O
)	O
;	O
x	double
+=	O
tx	int
;	O
if	O
(	O
tree	struct
->	O
link	array
[	O
1	int
]	O
!=	O
NULL	O
)	O
{	O
struct	O
canvas	struct
subcanvas	struct
;	O
canvas_subdivide	function
(	O
&	O
subcanvas	struct
,	O
&	O
c	int
,	O
x	double
,	O
ty	int
+	O
1	int
,	O
x	double
+	O
tree	struct
->	O
link	array
[	O
1	int
]	O
->	O
w	int
,	O
ty	int
+	O
1	int
+	O
tree	struct
->	O
link	array
[	O
1	int
]	O
->	O
h	int
)	O
;	O
text_draw_tree	function
(	O
tree	struct
->	O
link	array
[	O
1	int
]	O
,	O
&	O
subcanvas	struct
)	O
;	O
if	O
(	O
!	O
(	O
tree	struct
->	O
link	array
[	O
1	int
]	O
->	O
options	enum
&	O
TOPT_NO_LINE	int
)	O
)	O
text_draw_line	function
(	O
&	O
c	int
,	O
x	double
+	O
tree	struct
->	O
link	array
[	O
1	int
]	O
->	O
ofs	int
-	O
1	int
,	O
x	double
-	O
1	int
,	O
ty	int
)	O
;	O
}	O
}	O
break	O
;	O
case	O
TREE_PRODUCTION	int
:	O
{	O
text_draw_tree_justified	function
(	O
tree	struct
->	O
link	array
[	O
0	int
]	O
,	O
canvas	struct
,	O
0	int
)	O
;	O
if	O
(	O
tree	struct
->	O
prod_type	enum
==	O
TOKEN_PRODUCES	int
)	O
{	O
canvas_set	function
(	O
canvas	struct
,	O
tree	struct
->	O
link	array
[	O
0	int
]	O
->	O
w	int
+	O
1	int
,	O
tree	struct
->	O
h	int
/	O
2	int
,	O
'='	O
)	O
;	O
canvas_set	function
(	O
canvas	struct
,	O
tree	struct
->	O
link	array
[	O
0	int
]	O
->	O
w	int
+	O
2	int
,	O
tree	struct
->	O
h	int
/	O
2	int
,	O
'>'	O
)	O
;	O
}	O
text_draw_tree_justified	function
(	O
tree	struct
->	O
link	array
[	O
1	int
]	O
,	O
canvas	struct
,	O
tree	struct
->	O
link	array
[	O
0	int
]	O
->	O
w	int
+	O
4	int
)	O
;	O
}	O
break	O
;	O
case	O
TREE_SHIFT	int
:	O
{	O
struct	O
canvas	struct
subcanvas	struct
;	O
int	O
shift	int
;	O
shift	int
=	O
tree	struct
->	O
ofs	int
-	O
tree	struct
->	O
link	array
[	O
0	int
]	O
->	O
ofs	int
;	O
canvas_subdivide	function
(	O
&	O
subcanvas	struct
,	O
canvas	struct
,	O
shift	int
,	O
0	int
,	O
shift	int
+	O
tree	struct
->	O
link	array
[	O
0	int
]	O
->	O
w	int
,	O
tree	struct
->	O
h	int
)	O
;	O
text_draw_tree	function
(	O
tree	struct
->	O
link	array
[	O
0	int
]	O
,	O
&	O
subcanvas	struct
)	O
;	O
}	O
break	O
;	O
default	O
:	O
assert	O
(	O
0	int
)	O
;	O
}	O
}	O
static	O
void	O
text_measure_text	function
(	O
const	O
char	O
*	O
text	pointer
,	O
int	O
*	O
w	int
,	O
int	O
*	O
h	int
)	O
{	O
int	O
ll	int
=	O
0	int
;	O
*	O
w	int
=	O
0	int
;	O
*	O
h	int
=	O
1	int
;	O
while	O
(	O
*	O
text	pointer
==	O
'&'	O
||	O
*	O
text	pointer
==	O
'_'	O
)	O
text	pointer
++	O
;	O
for	O
(	O
;	O
;	O
)	O
switch	O
(	O
*	O
text	pointer
++	O
)	O
{	O
case	O
'\0'	O
:	O
return	O
;	O
case	O
'&'	O
:	O
(	O
*	O
h	int
)	O
++	O
;	O
ll	int
=	O
0	int
;	O
break	O
;	O
case	O
'_'	O
:	O
break	O
;	O
default	O
:	O
*	O
w	int
=	O
max	function
(	O
++	O
ll	int
,	O
*	O
w	int
)	O
;	O
break	O
;	O
}	O
}	O
static	O
struct	O
tree	struct
*	O
text_shift_tree	function
(	O
struct	O
tree	struct
*	O
old	pointer
,	O
int	O
move	int
)	O
{	O
struct	O
tree	struct
*	O
new	pointer
=	O
xmalloc	function
(	O
sizeof	O
*	O
new	pointer
)	O
;	O
new	pointer
->	O
type	enum
=	O
TREE_SHIFT	int
;	O
new	pointer
->	O
w	int
=	O
old	pointer
->	O
w	int
+	O
abs	function
(	O
move	int
)	O
;	O
new	pointer
->	O
h	int
=	O
old	pointer
->	O
h	int
;	O
new	pointer
->	O
ofs	int
=	O
old	pointer
->	O
ofs	int
+	O
(	O
move	int
>	O
0	int
?	O
move	int
:	O
0	int
)	O
;	O
new	pointer
->	O
options	enum
=	O
old	pointer
->	O
options	enum
;	O
new	pointer
->	O
name	pointer
=	O
NULL	O
;	O
assert	O
(	O
new	pointer
->	O
ofs	int
>=	O
0	int
&&	O
new	pointer
->	O
ofs	int
<	O
new	pointer
->	O
w	int
)	O
;	O
new	pointer
->	O
link	array
[	O
0	int
]	O
=	O
old	pointer
;	O
new	pointer
->	O
link	array
[	O
1	int
]	O
=	O
NULL	O
;	O
return	O
new	pointer
;	O
}	O
static	O
int	O
text_trivial	function
(	O
const	O
struct	O
tree	struct
*	O
tree	struct
)	O
{	O
return	O
(	O
tree	struct
->	O
w	int
==	O
1	int
&&	O
tree	struct
->	O
link	array
[	O
0	int
]	O
==	O
NULL	O
&&	O
tree	struct
->	O
link	array
[	O
1	int
]	O
==	O
NULL	O
)	O
;	O
}	O
static	O
int	O
text_caret	function
(	O
const	O
struct	O
tree	struct
*	O
tree	struct
)	O
{	O
return	O
(	O
tree	struct
->	O
type	enum
==	O
TREE_BINARY	int
&&	O
strlen	function
(	O
tree	struct
->	O
label	array
[	O
LP_MIDDLE	int
]	O
)	O
==	O
1	int
&&	O
tree	struct
->	O
link	array
[	O
0	int
]	O
!=	O
NULL	O
&&	O
text_trivial	function
(	O
tree	struct
->	O
link	array
[	O
0	int
]	O
)	O
&&	O
tree	struct
->	O
link	array
[	O
1	int
]	O
!=	O
NULL	O
&&	O
text_trivial	function
(	O
tree	struct
->	O
link	array
[	O
1	int
]	O
)	O
)	O
;	O
}	O
static	O
void	O
text_draw_line	function
(	O
struct	O
canvas	struct
*	O
canvas	struct
,	O
int	O
x0	int
,	O
int	O
x1	int
,	O
int	O
y	double
)	O
{	O
if	O
(	O
x1	int
==	O
x0	int
+	O
1	int
)	O
canvas_set	function
(	O
canvas	struct
,	O
x0	int
,	O
y	double
,	O
'/'	O
)	O
;	O
else	O
if	O
(	O
x1	int
==	O
x0	int
-	O
1	int
)	O
canvas_set	function
(	O
canvas	struct
,	O
x0	int
,	O
y	double
,	O
'\\'	O
)	O
;	O
else	O
if	O
(	O
x1	int
>	O
x0	int
)	O
{	O
int	O
x	double
;	O
for	O
(	O
x	double
=	O
x0	int
;	O
x	double
<	O
x1	int
;	O
x	double
++	O
)	O
{	O
static	O
const	O
char	O
lines	array
[	O
]	O
=	O
"_.-'"	pointer
;	O
size_t	long
frac	long
=	O
(	O
(	O
double	O
)	O
x	double
-	O
x0	int
)	O
/	O
(	O
x1	int
-	O
x0	int
-	O
1	int
)	O
*	O
3	int
;	O
assert	O
(	O
frac	long
<	O
sizeof	O
lines	array
)	O
;	O
canvas_set	function
(	O
canvas	struct
,	O
x	double
,	O
y	double
,	O
lines	array
[	O
frac	long
]	O
)	O
;	O
}	O
}	O
else	O
{	O
int	O
x	double
;	O
for	O
(	O
x	double
=	O
x0	int
;	O
x	double
>	O
x1	int
;	O
x	double
--	O
)	O
{	O
static	O
const	O
char	O
lines	array
[	O
]	O
=	O
"_.-`"	pointer
;	O
size_t	long
frac	long
=	O
(	O
(	O
double	O
)	O
x0	int
-	O
x	double
)	O
/	O
(	O
x0	int
-	O
x1	int
-	O
1	int
)	O
*	O
3	int
;	O
assert	O
(	O
frac	long
<	O
sizeof	O
lines	array
)	O
;	O
canvas_set	function
(	O
canvas	struct
,	O
x	double
,	O
y	double
,	O
lines	array
[	O
frac	long
]	O
)	O
;	O
}	O
}	O
}	O
static	O
size_t	long
text_line_len	function
(	O
const	O
char	O
*	O
text	pointer
)	O
{	O
size_t	long
len	long
=	O
0	int
;	O
for	O
(	O
;	O
*	O
text	pointer
!=	O
'\0'	O
&&	O
*	O
text	pointer
!=	O
'&'	O
;	O
text	pointer
++	O
)	O
if	O
(	O
*	O
text	pointer
!=	O
'_'	O
)	O
len	long
++	O
;	O
return	O
len	long
;	O
}	O
static	O
void	O
text_draw_text	function
(	O
struct	O
canvas	struct
*	O
canvas	struct
,	O
int	O
x0	int
,	O
int	O
y0	int
,	O
int	O
w	int
,	O
const	O
char	O
*	O
text	pointer
)	O
{	O
int	O
y	double
=	O
y0	int
;	O
while	O
(	O
*	O
text	pointer
==	O
'&'	O
||	O
*	O
text	pointer
==	O
'_'	O
)	O
text	pointer
++	O
;	O
while	O
(	O
*	O
text	pointer
!=	O
'\0'	O
)	O
{	O
int	O
line_len	int
=	O
text_line_len	function
(	O
text	pointer
)	O
;	O
int	O
x	double
=	O
x0	int
+	O
w	int
/	O
2	int
-	O
line_len	int
/	O
2	int
;	O
for	O
(	O
;	O
*	O
text	pointer
!=	O
'\0'	O
&&	O
*	O
text	pointer
!=	O
'&'	O
;	O
text	pointer
++	O
)	O
if	O
(	O
*	O
text	pointer
!=	O
'_'	O
)	O
canvas_set	function
(	O
canvas	struct
,	O
x	double
++	O
,	O
y	double
,	O
*	O
text	pointer
)	O
;	O
if	O
(	O
*	O
text	pointer
==	O
'&'	O
||	O
*	O
text	pointer
==	O
'_'	O
)	O
{	O
y	double
++	O
;	O
while	O
(	O
*	O
text	pointer
==	O
'&'	O
||	O
*	O
text	pointer
==	O
'_'	O
)	O
text	pointer
++	O
;	O
}	O
}	O
}	O
static	O
void	O
text_draw_tree_justified	function
(	O
const	O
struct	O
tree	struct
*	O
tree	struct
,	O
struct	O
canvas	struct
*	O
canvas	struct
,	O
int	O
x	double
)	O
{	O
struct	O
canvas	struct
subcanvas	struct
;	O
int	O
ofs	int
;	O
if	O
(	O
tree	struct
->	O
type	enum
==	O
TREE_BINARY	int
)	O
{	O
if	O
(	O
tree	struct
->	O
justify	int
==	O
'm'	O
)	O
ofs	int
=	O
(	O
canvas	struct
->	O
h	int
-	O
tree	struct
->	O
h	int
)	O
/	O
2	int
;	O
else	O
if	O
(	O
tree	struct
->	O
justify	int
==	O
'b'	O
)	O
ofs	int
=	O
canvas	struct
->	O
h	int
-	O
tree	struct
->	O
h	int
;	O
else	O
ofs	int
=	O
0	int
;	O
}	O
else	O
ofs	int
=	O
0	int
;	O
canvas_subdivide	function
(	O
&	O
subcanvas	struct
,	O
canvas	struct
,	O
x	double
,	O
ofs	int
,	O
x	double
+	O
tree	struct
->	O
w	int
,	O
ofs	int
+	O
tree	struct
->	O
h	int
)	O
;	O
text_draw_tree	function
(	O
tree	struct
,	O
&	O
subcanvas	struct
)	O
;	O
}	O
static	O
void	O
canvas_create	function
(	O
struct	O
canvas	struct
*	O
canvas	struct
,	O
int	O
w	int
,	O
int	O
h	int
)	O
{	O
canvas	struct
->	O
w	int
=	O
canvas	struct
->	O
ll	int
=	O
w	int
;	O
canvas	struct
->	O
h	int
=	O
h	int
;	O
canvas	struct
->	O
buf	pointer
=	O
xmalloc	function
(	O
w	int
*	O
h	int
)	O
;	O
memset	function
(	O
canvas	struct
->	O
buf	pointer
,	O
' '	O
,	O
w	int
*	O
h	int
)	O
;	O
}	O
static	O
void	O
canvas_subdivide	function
(	O
struct	O
canvas	struct
*	O
dst	pointer
,	O
const	O
struct	O
canvas	struct
*	O
src	pointer
,	O
int	O
x0	int
,	O
int	O
y0	int
,	O
int	O
x1	int
,	O
int	O
y1	int
)	O
{	O
assert	O
(	O
dst	pointer
!=	O
NULL	O
&&	O
src	pointer
!=	O
NULL	O
)	O
;	O
assert	O
(	O
x0	int
>=	O
0	int
&&	O
x0	int
<	O
src	pointer
->	O
w	int
&&	O
x1	int
>=	O
0	int
&&	O
x1	int
<=	O
src	pointer
->	O
w	int
&&	O
x0	int
<=	O
x1	int
)	O
;	O
assert	O
(	O
y0	int
>=	O
0	int
&&	O
y0	int
<	O
src	pointer
->	O
h	int
&&	O
y1	int
>=	O
0	int
&&	O
y1	int
<=	O
src	pointer
->	O
h	int
&&	O
y0	int
<=	O
y1	int
)	O
;	O
dst	pointer
->	O
w	int
=	O
x1	int
-	O
x0	int
;	O
dst	pointer
->	O
ll	int
=	O
src	pointer
->	O
ll	int
;	O
dst	pointer
->	O
h	int
=	O
y1	int
-	O
y0	int
;	O
dst	pointer
->	O
buf	pointer
=	O
src	pointer
->	O
buf	pointer
+	O
x0	int
+	O
y0	int
*	O
src	pointer
->	O
ll	int
;	O
}	O
static	O
void	O
canvas_free	function
(	O
struct	O
canvas	struct
*	O
canvas	struct
)	O
{	O
free	function
(	O
canvas	struct
->	O
buf	pointer
)	O
;	O
}	O
static	O
void	O
canvas_set	function
(	O
struct	O
canvas	struct
*	O
canvas	struct
,	O
int	O
x	double
,	O
int	O
y	double
,	O
int	O
c	int
)	O
{	O
assert	O
(	O
canvas	struct
!=	O
NULL	O
)	O
;	O
assert	O
(	O
x	double
>=	O
0	int
&&	O
x	double
<	O
canvas	struct
->	O
w	int
)	O
;	O
assert	O
(	O
y	double
>=	O
0	int
&&	O
y	double
<	O
canvas	struct
->	O
h	int
)	O
;	O
assert	O
(	O
c	int
>=	O
0	int
&&	O
c	int
<=	O
UCHAR_MAX	O
)	O
;	O
assert	O
(	O
canvas	struct
->	O
buf	pointer
[	O
x	double
+	O
y	double
*	O
canvas	struct
->	O
ll	int
]	O
==	O
' '	O
)	O
;	O
canvas	struct
->	O
buf	pointer
[	O
x	double
+	O
y	double
*	O
canvas	struct
->	O
ll	int
]	O
=	O
c	int
;	O
}	O
static	O
int	O
canvas_get	function
(	O
const	O
struct	O
canvas	struct
*	O
canvas	struct
,	O
int	O
x	double
,	O
int	O
y	double
)	O
{	O
assert	O
(	O
canvas	struct
!=	O
NULL	O
)	O
;	O
assert	O
(	O
x	double
>=	O
0	int
&&	O
x	double
<	O
canvas	struct
->	O
w	int
)	O
;	O
assert	O
(	O
y	double
>=	O
0	int
&&	O
y	double
<	O
canvas	struct
->	O
h	int
)	O
;	O
return	O
canvas	struct
->	O
buf	pointer
[	O
x	double
+	O
y	double
*	O
canvas	struct
->	O
ll	int
]	O
;	O
}	O
static	O
void	O
canvas_print	function
(	O
const	O
struct	O
canvas	struct
*	O
canvas	struct
)	O
{	O
int	O
y	double
;	O
for	O
(	O
y	double
=	O
0	int
;	O
y	double
<	O
canvas	struct
->	O
h	int
;	O
y	double
++	O
)	O
{	O
int	O
x	double
,	O
w	int
;	O
w	int
=	O
canvas	struct
->	O
w	int
;	O
while	O
(	O
w	int
>	O
0	int
&&	O
canvas_get	function
(	O
canvas	struct
,	O
w	int
-	O
1	int
,	O
y	double
)	O
==	O
' '	O
)	O
w	int
--	O
;	O
for	O
(	O
x	double
=	O
0	int
;	O
x	double
<	O
w	int
;	O
x	double
++	O
)	O
putchar	function
(	O
canvas_get	function
(	O
canvas	struct
,	O
x	double
,	O
y	double
)	O
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
}	O
static	O
void	O
error	function
(	O
struct	O
token	struct
*	O
token	struct
,	O
const	O
char	O
*	O
format	pointer
,	O
...	O
)	O
{	O
va_list	array
args	array
;	O
if	O
(	O
token	struct
==	O
NULL	O
)	O
fputs	function
(	O
"error: "	pointer
,	O
stderr	pointer
)	O
;	O
else	O
if	O
(	O
token	struct
->	O
c	int
==	O
EOF	O
)	O
fputs	function
(	O
"error at end-of-file: "	pointer
,	O
stderr	pointer
)	O
;	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
"line %d: error at `%c': "	pointer
,	O
token	struct
->	O
ln	int
,	O
token	struct
->	O
c	int
)	O
;	O
va_start	O
(	O
args	array
,	O
format	pointer
)	O
;	O
vfprintf	function
(	O
stderr	pointer
,	O
format	pointer
,	O
args	array
)	O
;	O
va_end	O
(	O
args	array
)	O
;	O
putc	function
(	O
'\n'	O
,	O
stderr	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
static	O
void	O
*	O
xmalloc	function
(	O
size_t	long
amt	int
)	O
{	O
void	O
*	O
p	pointer
;	O
if	O
(	O
amt	int
==	O
0	int
)	O
return	O
NULL	O
;	O
p	pointer
=	O
malloc	function
(	O
amt	int
)	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"virtual memory exhausted\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
return	O
p	pointer
;	O
}	O
static	O
void	O
*	O
xrealloc	function
(	O
void	O
*	O
ptr	pointer
,	O
size_t	long
size	long
)	O
{	O
void	O
*	O
vp	pointer
;	O
if	O
(	O
!	O
size	long
)	O
{	O
if	O
(	O
ptr	pointer
)	O
free	function
(	O
ptr	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
ptr	pointer
)	O
vp	pointer
=	O
realloc	function
(	O
ptr	pointer
,	O
size	long
)	O
;	O
else	O
vp	pointer
=	O
malloc	function
(	O
size	long
)	O
;	O
if	O
(	O
!	O
vp	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"virtual memory exhausted\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
return	O
vp	pointer
;	O
}	O
static	O
int	O
max	function
(	O
int	O
a	int
,	O
int	O
b	int
)	O
{	O
return	O
a	int
>	O
b	int
?	O
a	int
:	O
b	int
;	O
}	O
