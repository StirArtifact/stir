struct	O
dwcfi_seg_list	struct
{	O
segT	pointer
seg	pointer
;	O
int	O
subseg	int
;	O
char	O
*	O
seg_name	pointer
;	O
}	O
;	O
static	O
bfd_boolean	int
compact_eh	int
;	O
static	O
struct	O
hash_control	O
*	O
dwcfi_hash	pointer
;	O
static	O
inline	O
void	O
out_one	function
(	O
int	O
byte	int
)	O
{	O
FRAG_APPEND_1_CHAR	O
(	O
byte	int
)	O
;	O
}	O
static	O
inline	O
void	O
out_two	function
(	O
int	O
data	pointer
)	O
{	O
md_number_to_chars	O
(	O
frag_more	function
(	O
2	int
)	O
,	O
data	pointer
,	O
2	int
)	O
;	O
}	O
static	O
inline	O
void	O
out_four	function
(	O
int	O
data	pointer
)	O
{	O
md_number_to_chars	O
(	O
frag_more	function
(	O
4	int
)	O
,	O
data	pointer
,	O
4	int
)	O
;	O
}	O
static	O
void	O
out_uleb128	function
(	O
addressT	long
value	long
)	O
{	O
output_leb128	function
(	O
frag_more	function
(	O
sizeof_leb128	function
(	O
value	long
,	O
0	int
)	O
)	O
,	O
value	long
,	O
0	int
)	O
;	O
}	O
static	O
void	O
out_sleb128	function
(	O
offsetT	long
value	long
)	O
{	O
output_leb128	function
(	O
frag_more	function
(	O
sizeof_leb128	function
(	O
value	long
,	O
1	int
)	O
)	O
,	O
value	long
,	O
1	int
)	O
;	O
}	O
static	O
unsigned	O
int	O
encoding_size	function
(	O
unsigned	O
char	O
encoding	int
)	O
{	O
if	O
(	O
encoding	int
==	O
DW_EH_PE_omit	int
)	O
return	O
0	int
;	O
switch	O
(	O
encoding	int
&	O
0x7	int
)	O
{	O
case	O
0	int
:	O
return	O
bfd_get_arch_size	function
(	O
stdoutput	pointer
)	O
==	O
64	int
?	O
8	int
:	O
4	int
;	O
case	O
DW_EH_PE_udata2	int
:	O
return	O
2	int
;	O
case	O
DW_EH_PE_udata4	int
:	O
return	O
4	int
;	O
case	O
DW_EH_PE_udata8	int
:	O
return	O
8	int
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
}	O
static	O
void	O
emit_expr_encoded	function
(	O
expressionS	struct
*	O
exp	pointer
,	O
int	O
encoding	int
,	O
bfd_boolean	int
emit_encoding	int
)	O
{	O
unsigned	O
int	O
size	int
=	O
encoding_size	function
(	O
encoding	int
)	O
;	O
bfd_reloc_code_real_type	enum
code	int
;	O
if	O
(	O
encoding	int
==	O
DW_EH_PE_omit	int
)	O
return	O
;	O
if	O
(	O
emit_encoding	int
)	O
out_one	function
(	O
encoding	int
)	O
;	O
code	int
=	O
tc_cfi_reloc_for_encoding	O
(	O
encoding	int
)	O
;	O
if	O
(	O
code	int
!=	O
BFD_RELOC_NONE	int
)	O
{	O
reloc_howto_type	struct
*	O
howto	pointer
=	O
bfd_reloc_type_lookup	function
(	O
stdoutput	pointer
,	O
code	int
)	O
;	O
char	O
*	O
p	pointer
=	O
frag_more	function
(	O
size	int
)	O
;	O
gas_assert	O
(	O
size	int
==	O
(	O
unsigned	O
)	O
howto	pointer
->	O
bitsize	int
/	O
8	int
)	O
;	O
md_number_to_chars	O
(	O
p	pointer
,	O
0	int
,	O
size	int
)	O
;	O
fix_new	function
(	O
frag_now	pointer
,	O
p	pointer
-	O
frag_now	pointer
->	O
fr_literal	array
,	O
size	int
,	O
exp	pointer
->	O
X_add_symbol	pointer
,	O
exp	pointer
->	O
X_add_number	long
,	O
howto	pointer
->	O
pc_relative	int
,	O
code	int
)	O
;	O
}	O
else	O
if	O
(	O
(	O
encoding	int
&	O
0x70	int
)	O
==	O
DW_EH_PE_pcrel	int
)	O
{	O
expressionS	struct
tmp	struct
=	O
*	O
exp	pointer
;	O
tmp	struct
.	O
X_op	enum
=	O
O_subtract	int
;	O
tmp	struct
.	O
X_op_symbol	pointer
=	O
symbol_temp_new_now	function
(	O
)	O
;	O
emit_expr	function
(	O
&	O
tmp	struct
,	O
size	int
)	O
;	O
}	O
else	O
emit_expr	function
(	O
exp	pointer
,	O
size	int
)	O
;	O
}	O
static	O
char	O
*	O
get_debugseg_name	function
(	O
segT	pointer
seg	pointer
,	O
const	O
char	O
*	O
base_name	pointer
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
const	O
char	O
*	O
dollar	pointer
;	O
const	O
char	O
*	O
dot	pointer
;	O
if	O
(	O
!	O
seg	pointer
)	O
return	O
concat	function
(	O
base_name	pointer
,	O
NULL	O
)	O
;	O
name	pointer
=	O
bfd_section_name	function
(	O
seg	pointer
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
||	O
*	O
name	pointer
==	O
0	int
)	O
return	O
concat	function
(	O
base_name	pointer
,	O
NULL	O
)	O
;	O
dollar	pointer
=	O
strchr	function
(	O
name	pointer
,	O
'$'	O
)	O
;	O
dot	pointer
=	O
strchr	function
(	O
name	pointer
+	O
1	int
,	O
'.'	O
)	O
;	O
if	O
(	O
!	O
dollar	pointer
&&	O
!	O
dot	pointer
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
base_name	pointer
,	O
".eh_frame_entry"	pointer
)	O
&&	O
strcmp	function
(	O
name	pointer
,	O
".text"	pointer
)	O
!=	O
0	int
)	O
return	O
concat	function
(	O
base_name	pointer
,	O
"."	pointer
,	O
name	pointer
,	O
NULL	O
)	O
;	O
name	pointer
=	O
""	pointer
;	O
}	O
else	O
if	O
(	O
!	O
dollar	pointer
)	O
name	pointer
=	O
dot	pointer
;	O
else	O
if	O
(	O
!	O
dot	pointer
)	O
name	pointer
=	O
dollar	pointer
;	O
else	O
if	O
(	O
dot	pointer
<	O
dollar	pointer
)	O
name	pointer
=	O
dot	pointer
;	O
else	O
name	pointer
=	O
dollar	pointer
;	O
return	O
concat	function
(	O
base_name	pointer
,	O
name	pointer
,	O
NULL	O
)	O
;	O
}	O
static	O
struct	O
dwcfi_seg_list	struct
*	O
alloc_debugseg_item	function
(	O
segT	pointer
seg	pointer
,	O
int	O
subseg	int
,	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
dwcfi_seg_list	struct
*	O
r	struct
;	O
r	struct
=	O
(	O
struct	O
dwcfi_seg_list	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
dwcfi_seg_list	struct
)	O
+	O
strlen	function
(	O
name	pointer
)	O
)	O
;	O
r	struct
->	O
seg	pointer
=	O
seg	pointer
;	O
r	struct
->	O
subseg	int
=	O
subseg	int
;	O
r	struct
->	O
seg_name	pointer
=	O
name	pointer
;	O
return	O
r	struct
;	O
}	O
static	O
segT	pointer
is_now_linkonce_segment	function
(	O
void	O
)	O
{	O
if	O
(	O
compact_eh	int
)	O
return	O
now_seg	pointer
;	O
if	O
(	O
(	O
bfd_section_flags	function
(	O
now_seg	pointer
)	O
&	O
(	O
SEC_LINK_ONCE	int
|	O
SEC_LINK_DUPLICATES_DISCARD	int
|	O
SEC_LINK_DUPLICATES_ONE_ONLY	int
|	O
SEC_LINK_DUPLICATES_SAME_SIZE	int
|	O
SEC_LINK_DUPLICATES_SAME_CONTENTS	O
)	O
)	O
!=	O
0	int
)	O
return	O
now_seg	pointer
;	O
return	O
NULL	O
;	O
}	O
static	O
segT	pointer
make_debug_seg	function
(	O
segT	pointer
cseg	pointer
,	O
char	O
*	O
name	pointer
,	O
int	O
sflags	int
)	O
{	O
segT	pointer
save_seg	pointer
=	O
now_seg	pointer
;	O
int	O
save_subseg	int
=	O
now_subseg	int
;	O
segT	pointer
r	struct
;	O
flagword	int
flags	int
;	O
r	struct
=	O
subseg_new	function
(	O
name	pointer
,	O
0	int
)	O
;	O
if	O
(	O
!	O
cseg	pointer
)	O
flags	int
=	O
0	int
;	O
else	O
flags	int
=	O
(	O
bfd_section_flags	function
(	O
cseg	pointer
)	O
&	O
(	O
SEC_LINK_ONCE	int
|	O
SEC_LINK_DUPLICATES_DISCARD	int
|	O
SEC_LINK_DUPLICATES_ONE_ONLY	int
|	O
SEC_LINK_DUPLICATES_SAME_SIZE	int
|	O
SEC_LINK_DUPLICATES_SAME_CONTENTS	O
)	O
)	O
;	O
flags	int
|=	O
sflags	int
;	O
if	O
(	O
!	O
bfd_set_section_flags	function
(	O
r	struct
,	O
flags	int
)	O
)	O
as_bad	function
(	O
_	O
(	O
"bfd_set_section_flags: %s"	pointer
)	O
,	O
bfd_errmsg	function
(	O
bfd_get_error	function
(	O
)	O
)	O
)	O
;	O
if	O
(	O
save_seg	pointer
!=	O
NULL	O
)	O
subseg_set	function
(	O
save_seg	pointer
,	O
save_subseg	int
)	O
;	O
return	O
r	struct
;	O
}	O
static	O
void	O
dwcfi_hash_insert	function
(	O
const	O
char	O
*	O
name	pointer
,	O
struct	O
dwcfi_seg_list	struct
*	O
item	pointer
)	O
{	O
const	O
char	O
*	O
error_string	pointer
;	O
if	O
(	O
(	O
error_string	pointer
=	O
hash_jam	function
(	O
dwcfi_hash	pointer
,	O
name	pointer
,	O
(	O
char	O
*	O
)	O
item	pointer
)	O
)	O
)	O
as_fatal	function
(	O
_	O
(	O
"Inserting \"%s\" into structure table failed: %s"	pointer
)	O
,	O
name	pointer
,	O
error_string	pointer
)	O
;	O
}	O
static	O
struct	O
dwcfi_seg_list	struct
*	O
dwcfi_hash_find	function
(	O
char	O
*	O
name	pointer
)	O
{	O
return	O
(	O
struct	O
dwcfi_seg_list	struct
*	O
)	O
hash_find	function
(	O
dwcfi_hash	pointer
,	O
name	pointer
)	O
;	O
}	O
static	O
struct	O
dwcfi_seg_list	struct
*	O
dwcfi_hash_find_or_make	function
(	O
segT	pointer
cseg	pointer
,	O
const	O
char	O
*	O
base_name	pointer
,	O
int	O
flags	int
)	O
{	O
struct	O
dwcfi_seg_list	struct
*	O
item	pointer
;	O
char	O
*	O
name	pointer
;	O
if	O
(	O
!	O
dwcfi_hash	pointer
)	O
dwcfi_hash	pointer
=	O
hash_new	function
(	O
)	O
;	O
name	pointer
=	O
get_debugseg_name	function
(	O
cseg	pointer
,	O
base_name	pointer
)	O
;	O
item	pointer
=	O
dwcfi_hash_find	function
(	O
name	pointer
)	O
;	O
if	O
(	O
!	O
item	pointer
)	O
{	O
item	pointer
=	O
alloc_debugseg_item	function
(	O
make_debug_seg	function
(	O
cseg	pointer
,	O
name	pointer
,	O
flags	int
)	O
,	O
0	int
,	O
name	pointer
)	O
;	O
dwcfi_hash_insert	function
(	O
item	pointer
->	O
seg_name	pointer
,	O
item	pointer
)	O
;	O
}	O
else	O
free	function
(	O
name	pointer
)	O
;	O
return	O
item	pointer
;	O
}	O
static	O
void	O
generic_dwarf2_emit_offset	function
(	O
symbolS	struct
*	O
symbol	pointer
,	O
unsigned	O
int	O
size	int
)	O
{	O
expressionS	struct
exp	pointer
;	O
exp	pointer
.	O
X_op	enum
=	O
O_symbol	int
;	O
exp	pointer
.	O
X_add_symbol	pointer
=	O
symbol	pointer
;	O
exp	pointer
.	O
X_add_number	long
=	O
0	int
;	O
emit_expr	function
(	O
&	O
exp	pointer
,	O
size	int
)	O
;	O
}	O
struct	O
cfi_escape_data	struct
{	O
struct	O
cfi_escape_data	struct
*	O
next	pointer
;	O
expressionS	struct
exp	pointer
;	O
}	O
;	O
struct	O
cie_entry	struct
{	O
struct	O
cie_entry	struct
*	O
next	pointer
;	O
symbolS	struct
*	O
start_address	long
;	O
unsigned	O
int	O
return_column	int
;	O
unsigned	O
int	O
signal_frame	int
;	O
unsigned	O
char	O
fde_encoding	int
;	O
unsigned	O
char	O
per_encoding	char
;	O
unsigned	O
char	O
lsda_encoding	int
;	O
expressionS	struct
personality	struct
;	O
struct	O
cfi_insn_data	struct
*	O
first	pointer
,	O
*	O
last	pointer
;	O
}	O
;	O
struct	O
fde_entry	struct
*	O
all_fde_data	pointer
;	O
static	O
struct	O
fde_entry	struct
*	O
*	O
last_fde_data	pointer
=	O
&	O
all_fde_data	pointer
;	O
static	O
struct	O
cie_entry	struct
*	O
cie_root	pointer
;	O
static	O
struct	O
fde_entry	struct
*	O
alloc_fde_entry	function
(	O
void	O
)	O
{	O
struct	O
fde_entry	struct
*	O
fde	struct
=	O
XCNEW	O
(	O
struct	O
fde_entry	struct
)	O
;	O
frchain_now	pointer
->	O
frch_cfi_data	struct
=	O
XCNEW	O
(	O
struct	O
frch_cfi_data	struct
)	O
;	O
frchain_now	pointer
->	O
frch_cfi_data	struct
->	O
cur_fde_data	pointer
=	O
fde	struct
;	O
*	O
last_fde_data	pointer
=	O
fde	struct
;	O
last_fde_data	pointer
=	O
&	O
fde	struct
->	O
next	pointer
;	O
SET_CUR_SEG	O
(	O
fde	struct
,	O
is_now_linkonce_segment	function
(	O
)	O
)	O
;	O
SET_HANDLED	O
(	O
fde	struct
,	O
0	int
)	O
;	O
fde	struct
->	O
last	pointer
=	O
&	O
fde	struct
->	O
data	pointer
;	O
fde	struct
->	O
return_column	int
=	O
DWARF2_DEFAULT_RETURN_COLUMN	O
;	O
fde	struct
->	O
per_encoding	char
=	O
DW_EH_PE_omit	int
;	O
fde	struct
->	O
lsda_encoding	int
=	O
DW_EH_PE_omit	int
;	O
fde	struct
->	O
eh_header_type	int
=	O
EH_COMPACT_UNKNOWN	int
;	O
return	O
fde	struct
;	O
}	O
static	O
bfd_boolean	int
cfi_sections_set	int
=	O
FALSE	int
;	O
static	O
int	O
cfi_sections	int
=	O
CFI_EMIT_eh_frame	O
;	O
int	O
all_cfi_sections	int
=	O
0	int
;	O
static	O
struct	O
fde_entry	struct
*	O
last_fde	pointer
;	O
static	O
struct	O
cfi_insn_data	struct
*	O
alloc_cfi_insn_data	function
(	O
void	O
)	O
{	O
struct	O
cfi_insn_data	struct
*	O
insn	int
=	O
XCNEW	O
(	O
struct	O
cfi_insn_data	struct
)	O
;	O
struct	O
fde_entry	struct
*	O
cur_fde_data	pointer
=	O
frchain_now	pointer
->	O
frch_cfi_data	struct
->	O
cur_fde_data	pointer
;	O
*	O
cur_fde_data	pointer
->	O
last	pointer
=	O
insn	int
;	O
cur_fde_data	pointer
->	O
last	pointer
=	O
&	O
insn	int
->	O
next	pointer
;	O
SET_CUR_SEG	O
(	O
insn	int
,	O
is_now_linkonce_segment	function
(	O
)	O
)	O
;	O
return	O
insn	int
;	O
}	O
void	O
cfi_new_fde	function
(	O
symbolS	struct
*	O
label	long
)	O
{	O
struct	O
fde_entry	struct
*	O
fde	struct
=	O
alloc_fde_entry	function
(	O
)	O
;	O
fde	struct
->	O
start_address	long
=	O
label	long
;	O
frchain_now	pointer
->	O
frch_cfi_data	struct
->	O
last_address	pointer
=	O
label	long
;	O
}	O
void	O
cfi_end_fde	function
(	O
symbolS	struct
*	O
label	long
)	O
{	O
frchain_now	pointer
->	O
frch_cfi_data	struct
->	O
cur_fde_data	pointer
->	O
end_address	pointer
=	O
label	long
;	O
free	function
(	O
frchain_now	pointer
->	O
frch_cfi_data	struct
)	O
;	O
frchain_now	pointer
->	O
frch_cfi_data	struct
=	O
NULL	O
;	O
}	O
void	O
cfi_set_return_column	function
(	O
unsigned	O
regno	int
)	O
{	O
frchain_now	pointer
->	O
frch_cfi_data	struct
->	O
cur_fde_data	pointer
->	O
return_column	int
=	O
regno	int
;	O
}	O
void	O
cfi_set_sections	function
(	O
void	O
)	O
{	O
frchain_now	pointer
->	O
frch_cfi_data	struct
->	O
cur_fde_data	pointer
->	O
sections	pointer
=	O
all_cfi_sections	int
;	O
cfi_sections_set	int
=	O
TRUE	int
;	O
}	O
static	O
void	O
cfi_add_CFA_insn	function
(	O
int	O
insn	int
)	O
{	O
struct	O
cfi_insn_data	struct
*	O
insn_ptr	pointer
=	O
alloc_cfi_insn_data	function
(	O
)	O
;	O
insn_ptr	pointer
->	O
insn	int
=	O
insn	int
;	O
}	O
static	O
void	O
cfi_add_CFA_insn_reg	function
(	O
int	O
insn	int
,	O
unsigned	O
regno	int
)	O
{	O
struct	O
cfi_insn_data	struct
*	O
insn_ptr	pointer
=	O
alloc_cfi_insn_data	function
(	O
)	O
;	O
insn_ptr	pointer
->	O
insn	int
=	O
insn	int
;	O
insn_ptr	pointer
->	O
u	union
.	O
r	struct
=	O
regno	int
;	O
}	O
static	O
void	O
cfi_add_CFA_insn_offset	function
(	O
int	O
insn	int
,	O
offsetT	long
offset	long
)	O
{	O
struct	O
cfi_insn_data	struct
*	O
insn_ptr	pointer
=	O
alloc_cfi_insn_data	function
(	O
)	O
;	O
insn_ptr	pointer
->	O
insn	int
=	O
insn	int
;	O
insn_ptr	pointer
->	O
u	union
.	O
i	pointer
=	O
offset	long
;	O
}	O
static	O
void	O
cfi_add_CFA_insn_reg_reg	function
(	O
int	O
insn	int
,	O
unsigned	O
reg1	int
,	O
unsigned	O
reg2	int
)	O
{	O
struct	O
cfi_insn_data	struct
*	O
insn_ptr	pointer
=	O
alloc_cfi_insn_data	function
(	O
)	O
;	O
insn_ptr	pointer
->	O
insn	int
=	O
insn	int
;	O
insn_ptr	pointer
->	O
u	union
.	O
rr	struct
.	O
reg1	int
=	O
reg1	int
;	O
insn_ptr	pointer
->	O
u	union
.	O
rr	struct
.	O
reg2	int
=	O
reg2	int
;	O
}	O
static	O
void	O
cfi_add_CFA_insn_reg_offset	function
(	O
int	O
insn	int
,	O
unsigned	O
regno	int
,	O
offsetT	long
offset	long
)	O
{	O
struct	O
cfi_insn_data	struct
*	O
insn_ptr	pointer
=	O
alloc_cfi_insn_data	function
(	O
)	O
;	O
insn_ptr	pointer
->	O
insn	int
=	O
insn	int
;	O
insn_ptr	pointer
->	O
u	union
.	O
ri	struct
.	O
reg	int
=	O
regno	int
;	O
insn_ptr	pointer
->	O
u	union
.	O
ri	struct
.	O
offset	long
=	O
offset	long
;	O
}	O
void	O
cfi_add_advance_loc	function
(	O
symbolS	struct
*	O
label	long
)	O
{	O
struct	O
cfi_insn_data	struct
*	O
insn	int
=	O
alloc_cfi_insn_data	function
(	O
)	O
;	O
insn	int
->	O
insn	int
=	O
DW_CFA_advance_loc	int
;	O
insn	int
->	O
u	union
.	O
ll	struct
.	O
lab1	pointer
=	O
frchain_now	pointer
->	O
frch_cfi_data	struct
->	O
last_address	pointer
;	O
insn	int
->	O
u	union
.	O
ll	struct
.	O
lab2	pointer
=	O
label	long
;	O
frchain_now	pointer
->	O
frch_cfi_data	struct
->	O
last_address	pointer
=	O
label	long
;	O
}	O
void	O
cfi_add_label	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
unsigned	O
int	O
len	long
=	O
strlen	function
(	O
name	pointer
)	O
+	O
1	int
;	O
struct	O
cfi_insn_data	struct
*	O
insn	int
=	O
alloc_cfi_insn_data	function
(	O
)	O
;	O
insn	int
->	O
insn	int
=	O
CFI_label	int
;	O
obstack_grow	O
(	O
&	O
notes	struct
,	O
name	pointer
,	O
len	long
)	O
;	O
insn	int
->	O
u	union
.	O
sym_name	pointer
=	O
(	O
char	O
*	O
)	O
obstack_finish	O
(	O
&	O
notes	struct
)	O
;	O
}	O
void	O
cfi_add_CFA_offset	function
(	O
unsigned	O
regno	int
,	O
offsetT	long
offset	long
)	O
{	O
unsigned	O
int	O
abs_data_align	int
;	O
gas_assert	O
(	O
DWARF2_CIE_DATA_ALIGNMENT	O
!=	O
0	int
)	O
;	O
cfi_add_CFA_insn_reg_offset	function
(	O
DW_CFA_offset	int
,	O
regno	int
,	O
offset	long
)	O
;	O
abs_data_align	int
=	O
(	O
DWARF2_CIE_DATA_ALIGNMENT	O
<	O
0	int
?	O
-	O
DWARF2_CIE_DATA_ALIGNMENT	O
:	O
DWARF2_CIE_DATA_ALIGNMENT	O
)	O
;	O
if	O
(	O
offset	long
%	O
abs_data_align	int
)	O
as_bad	function
(	O
_	O
(	O
"register save offset not a multiple of %u"	pointer
)	O
,	O
abs_data_align	int
)	O
;	O
}	O
void	O
cfi_add_CFA_val_offset	function
(	O
unsigned	O
regno	int
,	O
offsetT	long
offset	long
)	O
{	O
unsigned	O
int	O
abs_data_align	int
;	O
gas_assert	O
(	O
DWARF2_CIE_DATA_ALIGNMENT	O
!=	O
0	int
)	O
;	O
cfi_add_CFA_insn_reg_offset	function
(	O
DW_CFA_val_offset	int
,	O
regno	int
,	O
offset	long
)	O
;	O
abs_data_align	int
=	O
(	O
DWARF2_CIE_DATA_ALIGNMENT	O
<	O
0	int
?	O
-	O
DWARF2_CIE_DATA_ALIGNMENT	O
:	O
DWARF2_CIE_DATA_ALIGNMENT	O
)	O
;	O
if	O
(	O
offset	long
%	O
abs_data_align	int
)	O
as_bad	function
(	O
_	O
(	O
"register save offset not a multiple of %u"	pointer
)	O
,	O
abs_data_align	int
)	O
;	O
}	O
void	O
cfi_add_CFA_def_cfa	function
(	O
unsigned	O
regno	int
,	O
offsetT	long
offset	long
)	O
{	O
cfi_add_CFA_insn_reg_offset	function
(	O
DW_CFA_def_cfa	int
,	O
regno	int
,	O
offset	long
)	O
;	O
frchain_now	pointer
->	O
frch_cfi_data	struct
->	O
cur_cfa_offset	long
=	O
offset	long
;	O
}	O
void	O
cfi_add_CFA_register	function
(	O
unsigned	O
reg1	int
,	O
unsigned	O
reg2	int
)	O
{	O
cfi_add_CFA_insn_reg_reg	function
(	O
DW_CFA_register	int
,	O
reg1	int
,	O
reg2	int
)	O
;	O
}	O
void	O
cfi_add_CFA_def_cfa_register	function
(	O
unsigned	O
regno	int
)	O
{	O
cfi_add_CFA_insn_reg	function
(	O
DW_CFA_def_cfa_register	int
,	O
regno	int
)	O
;	O
}	O
void	O
cfi_add_CFA_def_cfa_offset	function
(	O
offsetT	long
offset	long
)	O
{	O
cfi_add_CFA_insn_offset	function
(	O
DW_CFA_def_cfa_offset	int
,	O
offset	long
)	O
;	O
frchain_now	pointer
->	O
frch_cfi_data	struct
->	O
cur_cfa_offset	long
=	O
offset	long
;	O
}	O
void	O
cfi_add_CFA_restore	function
(	O
unsigned	O
regno	int
)	O
{	O
cfi_add_CFA_insn_reg	function
(	O
DW_CFA_restore	int
,	O
regno	int
)	O
;	O
}	O
void	O
cfi_add_CFA_undefined	function
(	O
unsigned	O
regno	int
)	O
{	O
cfi_add_CFA_insn_reg	function
(	O
DW_CFA_undefined	int
,	O
regno	int
)	O
;	O
}	O
void	O
cfi_add_CFA_same_value	function
(	O
unsigned	O
regno	int
)	O
{	O
cfi_add_CFA_insn_reg	function
(	O
DW_CFA_same_value	int
,	O
regno	int
)	O
;	O
}	O
void	O
cfi_add_CFA_remember_state	function
(	O
void	O
)	O
{	O
struct	O
cfa_save_data	struct
*	O
p	pointer
;	O
cfi_add_CFA_insn	function
(	O
DW_CFA_remember_state	int
)	O
;	O
p	pointer
=	O
XNEW	O
(	O
struct	O
cfa_save_data	struct
)	O
;	O
p	pointer
->	O
cfa_offset	long
=	O
frchain_now	pointer
->	O
frch_cfi_data	struct
->	O
cur_cfa_offset	long
;	O
p	pointer
->	O
next	pointer
=	O
frchain_now	pointer
->	O
frch_cfi_data	struct
->	O
cfa_save_stack	pointer
;	O
frchain_now	pointer
->	O
frch_cfi_data	struct
->	O
cfa_save_stack	pointer
=	O
p	pointer
;	O
}	O
void	O
cfi_add_CFA_restore_state	function
(	O
void	O
)	O
{	O
struct	O
cfa_save_data	struct
*	O
p	pointer
;	O
cfi_add_CFA_insn	function
(	O
DW_CFA_restore_state	int
)	O
;	O
p	pointer
=	O
frchain_now	pointer
->	O
frch_cfi_data	struct
->	O
cfa_save_stack	pointer
;	O
if	O
(	O
p	pointer
)	O
{	O
frchain_now	pointer
->	O
frch_cfi_data	struct
->	O
cur_cfa_offset	long
=	O
p	pointer
->	O
cfa_offset	long
;	O
frchain_now	pointer
->	O
frch_cfi_data	struct
->	O
cfa_save_stack	pointer
=	O
p	pointer
->	O
next	pointer
;	O
free	function
(	O
p	pointer
)	O
;	O
}	O
else	O
as_bad	function
(	O
_	O
(	O
"CFI state restore without previous remember"	pointer
)	O
)	O
;	O
}	O
static	O
void	O
dot_cfi	function
(	O
int	O
)	O
;	O
static	O
void	O
dot_cfi_escape	function
(	O
int	O
)	O
;	O
static	O
void	O
dot_cfi_sections	function
(	O
int	O
)	O
;	O
static	O
void	O
dot_cfi_startproc	function
(	O
int	O
)	O
;	O
static	O
void	O
dot_cfi_endproc	function
(	O
int	O
)	O
;	O
static	O
void	O
dot_cfi_fde_data	function
(	O
int	O
)	O
;	O
static	O
void	O
dot_cfi_personality	function
(	O
int	O
)	O
;	O
static	O
void	O
dot_cfi_personality_id	function
(	O
int	O
)	O
;	O
static	O
void	O
dot_cfi_lsda	function
(	O
int	O
)	O
;	O
static	O
void	O
dot_cfi_val_encoded_addr	function
(	O
int	O
)	O
;	O
static	O
void	O
dot_cfi_inline_lsda	function
(	O
int	O
)	O
;	O
static	O
void	O
dot_cfi_label	function
(	O
int	O
)	O
;	O
const	O
pseudo_typeS	struct
cfi_pseudo_table	array
[	O
]	O
=	O
{	O
{	O
"cfi_sections"	pointer
,	O
dot_cfi_sections	function
,	O
0	int
}	O
,	O
{	O
"cfi_startproc"	pointer
,	O
dot_cfi_startproc	function
,	O
0	int
}	O
,	O
{	O
"cfi_endproc"	pointer
,	O
dot_cfi_endproc	function
,	O
0	int
}	O
,	O
{	O
"cfi_fde_data"	pointer
,	O
dot_cfi_fde_data	function
,	O
0	int
}	O
,	O
{	O
"cfi_def_cfa"	pointer
,	O
dot_cfi	function
,	O
DW_CFA_def_cfa	int
}	O
,	O
{	O
"cfi_def_cfa_register"	pointer
,	O
dot_cfi	function
,	O
DW_CFA_def_cfa_register	int
}	O
,	O
{	O
"cfi_def_cfa_offset"	pointer
,	O
dot_cfi	function
,	O
DW_CFA_def_cfa_offset	int
}	O
,	O
{	O
"cfi_adjust_cfa_offset"	pointer
,	O
dot_cfi	function
,	O
CFI_adjust_cfa_offset	int
}	O
,	O
{	O
"cfi_offset"	pointer
,	O
dot_cfi	function
,	O
DW_CFA_offset	int
}	O
,	O
{	O
"cfi_rel_offset"	pointer
,	O
dot_cfi	function
,	O
CFI_rel_offset	int
}	O
,	O
{	O
"cfi_register"	pointer
,	O
dot_cfi	function
,	O
DW_CFA_register	int
}	O
,	O
{	O
"cfi_return_column"	pointer
,	O
dot_cfi	function
,	O
CFI_return_column	int
}	O
,	O
{	O
"cfi_restore"	pointer
,	O
dot_cfi	function
,	O
DW_CFA_restore	int
}	O
,	O
{	O
"cfi_undefined"	pointer
,	O
dot_cfi	function
,	O
DW_CFA_undefined	int
}	O
,	O
{	O
"cfi_same_value"	pointer
,	O
dot_cfi	function
,	O
DW_CFA_same_value	int
}	O
,	O
{	O
"cfi_remember_state"	pointer
,	O
dot_cfi	function
,	O
DW_CFA_remember_state	int
}	O
,	O
{	O
"cfi_restore_state"	pointer
,	O
dot_cfi	function
,	O
DW_CFA_restore_state	int
}	O
,	O
{	O
"cfi_window_save"	pointer
,	O
dot_cfi	function
,	O
DW_CFA_GNU_window_save	int
}	O
,	O
{	O
"cfi_negate_ra_state"	pointer
,	O
dot_cfi	function
,	O
DW_CFA_AARCH64_negate_ra_state	int
}	O
,	O
{	O
"cfi_escape"	pointer
,	O
dot_cfi_escape	function
,	O
0	int
}	O
,	O
{	O
"cfi_signal_frame"	pointer
,	O
dot_cfi	function
,	O
CFI_signal_frame	int
}	O
,	O
{	O
"cfi_personality"	pointer
,	O
dot_cfi_personality	function
,	O
0	int
}	O
,	O
{	O
"cfi_personality_id"	pointer
,	O
dot_cfi_personality_id	function
,	O
0	int
}	O
,	O
{	O
"cfi_lsda"	pointer
,	O
dot_cfi_lsda	function
,	O
0	int
}	O
,	O
{	O
"cfi_val_encoded_addr"	pointer
,	O
dot_cfi_val_encoded_addr	function
,	O
0	int
}	O
,	O
{	O
"cfi_inline_lsda"	pointer
,	O
dot_cfi_inline_lsda	function
,	O
0	int
}	O
,	O
{	O
"cfi_label"	pointer
,	O
dot_cfi_label	function
,	O
0	int
}	O
,	O
{	O
"cfi_val_offset"	pointer
,	O
dot_cfi	function
,	O
DW_CFA_val_offset	int
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
void	O
cfi_parse_separator	function
(	O
void	O
)	O
{	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	pointer
==	O
','	O
)	O
input_line_pointer	pointer
++	O
;	O
else	O
as_bad	function
(	O
_	O
(	O
"missing separator"	pointer
)	O
)	O
;	O
}	O
static	O
unsigned	O
cfi_parse_reg	function
(	O
void	O
)	O
{	O
int	O
regno	int
;	O
expressionS	struct
exp	pointer
;	O
tc_parse_to_dw2regnum	O
(	O
&	O
exp	pointer
)	O
;	O
switch	O
(	O
exp	pointer
.	O
X_op	enum
)	O
{	O
case	O
O_register	int
:	O
case	O
O_constant	int
:	O
regno	int
=	O
exp	pointer
.	O
X_add_number	long
;	O
break	O
;	O
default	O
:	O
regno	int
=	O
-	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
regno	int
<	O
0	int
)	O
{	O
as_bad	function
(	O
_	O
(	O
"bad register expression"	pointer
)	O
)	O
;	O
regno	int
=	O
0	int
;	O
}	O
return	O
regno	int
;	O
}	O
static	O
offsetT	long
cfi_parse_const	function
(	O
void	O
)	O
{	O
return	O
get_absolute_expression	function
(	O
)	O
;	O
}	O
static	O
void	O
dot_cfi	function
(	O
int	O
arg	pointer
)	O
{	O
offsetT	long
offset	long
;	O
unsigned	O
reg1	int
,	O
reg2	int
;	O
if	O
(	O
frchain_now	pointer
->	O
frch_cfi_data	struct
==	O
NULL	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"CFI instruction used without previous .cfi_startproc"	pointer
)	O
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
symbol_get_frag	function
(	O
frchain_now	pointer
->	O
frch_cfi_data	struct
->	O
last_address	pointer
)	O
!=	O
frag_now	pointer
||	O
(	O
S_GET_VALUE	function
(	O
frchain_now	pointer
->	O
frch_cfi_data	struct
->	O
last_address	pointer
)	O
!=	O
frag_now_fix	function
(	O
)	O
)	O
)	O
cfi_add_advance_loc	function
(	O
symbol_temp_new_now	function
(	O
)	O
)	O
;	O
switch	O
(	O
arg	pointer
)	O
{	O
case	O
DW_CFA_offset	int
:	O
reg1	int
=	O
cfi_parse_reg	function
(	O
)	O
;	O
cfi_parse_separator	function
(	O
)	O
;	O
offset	long
=	O
cfi_parse_const	function
(	O
)	O
;	O
cfi_add_CFA_offset	function
(	O
reg1	int
,	O
offset	long
)	O
;	O
break	O
;	O
case	O
DW_CFA_val_offset	int
:	O
reg1	int
=	O
cfi_parse_reg	function
(	O
)	O
;	O
cfi_parse_separator	function
(	O
)	O
;	O
offset	long
=	O
cfi_parse_const	function
(	O
)	O
;	O
cfi_add_CFA_val_offset	function
(	O
reg1	int
,	O
offset	long
)	O
;	O
break	O
;	O
case	O
CFI_rel_offset	int
:	O
reg1	int
=	O
cfi_parse_reg	function
(	O
)	O
;	O
cfi_parse_separator	function
(	O
)	O
;	O
offset	long
=	O
cfi_parse_const	function
(	O
)	O
;	O
cfi_add_CFA_offset	function
(	O
reg1	int
,	O
offset	long
-	O
frchain_now	pointer
->	O
frch_cfi_data	struct
->	O
cur_cfa_offset	long
)	O
;	O
break	O
;	O
case	O
DW_CFA_def_cfa	int
:	O
reg1	int
=	O
cfi_parse_reg	function
(	O
)	O
;	O
cfi_parse_separator	function
(	O
)	O
;	O
offset	long
=	O
cfi_parse_const	function
(	O
)	O
;	O
cfi_add_CFA_def_cfa	function
(	O
reg1	int
,	O
offset	long
)	O
;	O
break	O
;	O
case	O
DW_CFA_register	int
:	O
reg1	int
=	O
cfi_parse_reg	function
(	O
)	O
;	O
cfi_parse_separator	function
(	O
)	O
;	O
reg2	int
=	O
cfi_parse_reg	function
(	O
)	O
;	O
cfi_add_CFA_register	function
(	O
reg1	int
,	O
reg2	int
)	O
;	O
break	O
;	O
case	O
DW_CFA_def_cfa_register	int
:	O
reg1	int
=	O
cfi_parse_reg	function
(	O
)	O
;	O
cfi_add_CFA_def_cfa_register	function
(	O
reg1	int
)	O
;	O
break	O
;	O
case	O
DW_CFA_def_cfa_offset	int
:	O
offset	long
=	O
cfi_parse_const	function
(	O
)	O
;	O
cfi_add_CFA_def_cfa_offset	function
(	O
offset	long
)	O
;	O
break	O
;	O
case	O
CFI_adjust_cfa_offset	int
:	O
offset	long
=	O
cfi_parse_const	function
(	O
)	O
;	O
cfi_add_CFA_def_cfa_offset	function
(	O
frchain_now	pointer
->	O
frch_cfi_data	struct
->	O
cur_cfa_offset	long
+	O
offset	long
)	O
;	O
break	O
;	O
case	O
DW_CFA_restore	int
:	O
for	O
(	O
;	O
;	O
)	O
{	O
reg1	int
=	O
cfi_parse_reg	function
(	O
)	O
;	O
cfi_add_CFA_restore	function
(	O
reg1	int
)	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	pointer
!=	O
','	O
)	O
break	O
;	O
++	O
input_line_pointer	pointer
;	O
}	O
break	O
;	O
case	O
DW_CFA_undefined	int
:	O
for	O
(	O
;	O
;	O
)	O
{	O
reg1	int
=	O
cfi_parse_reg	function
(	O
)	O
;	O
cfi_add_CFA_undefined	function
(	O
reg1	int
)	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	pointer
!=	O
','	O
)	O
break	O
;	O
++	O
input_line_pointer	pointer
;	O
}	O
break	O
;	O
case	O
DW_CFA_same_value	int
:	O
reg1	int
=	O
cfi_parse_reg	function
(	O
)	O
;	O
cfi_add_CFA_same_value	function
(	O
reg1	int
)	O
;	O
break	O
;	O
case	O
CFI_return_column	int
:	O
reg1	int
=	O
cfi_parse_reg	function
(	O
)	O
;	O
cfi_set_return_column	function
(	O
reg1	int
)	O
;	O
break	O
;	O
case	O
DW_CFA_remember_state	int
:	O
cfi_add_CFA_remember_state	function
(	O
)	O
;	O
break	O
;	O
case	O
DW_CFA_restore_state	int
:	O
cfi_add_CFA_restore_state	function
(	O
)	O
;	O
break	O
;	O
case	O
DW_CFA_GNU_window_save	int
:	O
cfi_add_CFA_insn	function
(	O
DW_CFA_GNU_window_save	int
)	O
;	O
break	O
;	O
case	O
CFI_signal_frame	int
:	O
frchain_now	pointer
->	O
frch_cfi_data	struct
->	O
cur_fde_data	pointer
->	O
signal_frame	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
}	O
static	O
void	O
dot_cfi_escape	function
(	O
int	O
ignored	int
ATTRIBUTE_UNUSED	O
)	O
{	O
struct	O
cfi_escape_data	struct
*	O
head	pointer
,	O
*	O
*	O
tail	pointer
,	O
*	O
e	pointer
;	O
struct	O
cfi_insn_data	struct
*	O
insn	int
;	O
if	O
(	O
frchain_now	pointer
->	O
frch_cfi_data	struct
==	O
NULL	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"CFI instruction used without previous .cfi_startproc"	pointer
)	O
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
symbol_get_frag	function
(	O
frchain_now	pointer
->	O
frch_cfi_data	struct
->	O
last_address	pointer
)	O
!=	O
frag_now	pointer
||	O
(	O
S_GET_VALUE	function
(	O
frchain_now	pointer
->	O
frch_cfi_data	struct
->	O
last_address	pointer
)	O
!=	O
frag_now_fix	function
(	O
)	O
)	O
)	O
cfi_add_advance_loc	function
(	O
symbol_temp_new_now	function
(	O
)	O
)	O
;	O
tail	pointer
=	O
&	O
head	pointer
;	O
do	O
{	O
e	pointer
=	O
XNEW	O
(	O
struct	O
cfi_escape_data	struct
)	O
;	O
do_parse_cons_expression	function
(	O
&	O
e	pointer
->	O
exp	pointer
,	O
1	int
)	O
;	O
*	O
tail	pointer
=	O
e	pointer
;	O
tail	pointer
=	O
&	O
e	pointer
->	O
next	pointer
;	O
}	O
while	O
(	O
*	O
input_line_pointer	pointer
++	O
==	O
','	O
)	O
;	O
*	O
tail	pointer
=	O
NULL	O
;	O
insn	int
=	O
alloc_cfi_insn_data	function
(	O
)	O
;	O
insn	int
->	O
insn	int
=	O
CFI_escape	int
;	O
insn	int
->	O
u	union
.	O
esc	pointer
=	O
head	pointer
;	O
--	O
input_line_pointer	pointer
;	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
}	O
static	O
void	O
dot_cfi_personality	function
(	O
int	O
ignored	int
ATTRIBUTE_UNUSED	O
)	O
{	O
struct	O
fde_entry	struct
*	O
fde	struct
;	O
offsetT	long
encoding	int
;	O
if	O
(	O
frchain_now	pointer
->	O
frch_cfi_data	struct
==	O
NULL	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"CFI instruction used without previous .cfi_startproc"	pointer
)	O
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
fde	struct
=	O
frchain_now	pointer
->	O
frch_cfi_data	struct
->	O
cur_fde_data	pointer
;	O
encoding	int
=	O
cfi_parse_const	function
(	O
)	O
;	O
if	O
(	O
encoding	int
==	O
DW_EH_PE_omit	int
)	O
{	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
fde	struct
->	O
per_encoding	char
=	O
encoding	int
;	O
return	O
;	O
}	O
if	O
(	O
(	O
encoding	int
&	O
0xff	int
)	O
!=	O
encoding	int
||	O
(	O
(	O
(	O
(	O
encoding	int
&	O
0x70	int
)	O
!=	O
0	int
&&	O
(	O
encoding	int
&	O
0x70	int
)	O
!=	O
DW_EH_PE_pcrel	int
)	O
||	O
(	O
encoding	int
&	O
7	int
)	O
==	O
DW_EH_PE_uleb128	int
||	O
(	O
encoding	int
&	O
7	int
)	O
>	O
DW_EH_PE_udata8	int
)	O
&&	O
tc_cfi_reloc_for_encoding	O
(	O
encoding	int
)	O
==	O
BFD_RELOC_NONE	int
)	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"invalid or unsupported encoding in .cfi_personality"	pointer
)	O
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
*	O
input_line_pointer	pointer
++	O
!=	O
','	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
".cfi_personality requires encoding and symbol arguments"	pointer
)	O
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
expression_and_evaluate	O
(	O
&	O
fde	struct
->	O
personality	struct
)	O
;	O
switch	O
(	O
fde	struct
->	O
personality	struct
.	O
X_op	enum
)	O
{	O
case	O
O_symbol	int
:	O
break	O
;	O
case	O
O_constant	int
:	O
if	O
(	O
(	O
encoding	int
&	O
0x70	int
)	O
==	O
DW_EH_PE_pcrel	int
)	O
encoding	int
=	O
DW_EH_PE_omit	int
;	O
break	O
;	O
default	O
:	O
encoding	int
=	O
DW_EH_PE_omit	int
;	O
break	O
;	O
}	O
fde	struct
->	O
per_encoding	char
=	O
encoding	int
;	O
if	O
(	O
encoding	int
==	O
DW_EH_PE_omit	int
)	O
{	O
as_bad	function
(	O
_	O
(	O
"wrong second argument to .cfi_personality"	pointer
)	O
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
}	O
static	O
void	O
dot_cfi_lsda	function
(	O
int	O
ignored	int
ATTRIBUTE_UNUSED	O
)	O
{	O
struct	O
fde_entry	struct
*	O
fde	struct
;	O
offsetT	long
encoding	int
;	O
if	O
(	O
frchain_now	pointer
->	O
frch_cfi_data	struct
==	O
NULL	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"CFI instruction used without previous .cfi_startproc"	pointer
)	O
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
fde	struct
=	O
frchain_now	pointer
->	O
frch_cfi_data	struct
->	O
cur_fde_data	pointer
;	O
encoding	int
=	O
cfi_parse_const	function
(	O
)	O
;	O
if	O
(	O
encoding	int
==	O
DW_EH_PE_omit	int
)	O
{	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
fde	struct
->	O
lsda_encoding	int
=	O
encoding	int
;	O
return	O
;	O
}	O
if	O
(	O
(	O
encoding	int
&	O
0xff	int
)	O
!=	O
encoding	int
||	O
(	O
(	O
(	O
(	O
encoding	int
&	O
0x70	int
)	O
!=	O
0	int
&&	O
(	O
encoding	int
&	O
0x70	int
)	O
!=	O
DW_EH_PE_pcrel	int
)	O
||	O
(	O
encoding	int
&	O
7	int
)	O
==	O
DW_EH_PE_uleb128	int
||	O
(	O
encoding	int
&	O
7	int
)	O
>	O
DW_EH_PE_udata8	int
)	O
&&	O
tc_cfi_reloc_for_encoding	O
(	O
encoding	int
)	O
==	O
BFD_RELOC_NONE	int
)	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"invalid or unsupported encoding in .cfi_lsda"	pointer
)	O
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
*	O
input_line_pointer	pointer
++	O
!=	O
','	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
".cfi_lsda requires encoding and symbol arguments"	pointer
)	O
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
fde	struct
->	O
lsda_encoding	int
=	O
encoding	int
;	O
expression_and_evaluate	O
(	O
&	O
fde	struct
->	O
lsda	struct
)	O
;	O
switch	O
(	O
fde	struct
->	O
lsda	struct
.	O
X_op	enum
)	O
{	O
case	O
O_symbol	int
:	O
break	O
;	O
case	O
O_constant	int
:	O
if	O
(	O
(	O
encoding	int
&	O
0x70	int
)	O
==	O
DW_EH_PE_pcrel	int
)	O
encoding	int
=	O
DW_EH_PE_omit	int
;	O
break	O
;	O
default	O
:	O
encoding	int
=	O
DW_EH_PE_omit	int
;	O
break	O
;	O
}	O
fde	struct
->	O
lsda_encoding	int
=	O
encoding	int
;	O
if	O
(	O
encoding	int
==	O
DW_EH_PE_omit	int
)	O
{	O
as_bad	function
(	O
_	O
(	O
"wrong second argument to .cfi_lsda"	pointer
)	O
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
}	O
static	O
void	O
dot_cfi_val_encoded_addr	function
(	O
int	O
ignored	int
ATTRIBUTE_UNUSED	O
)	O
{	O
struct	O
cfi_insn_data	struct
*	O
insn_ptr	pointer
;	O
offsetT	long
encoding	int
;	O
if	O
(	O
frchain_now	pointer
->	O
frch_cfi_data	struct
==	O
NULL	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"CFI instruction used without previous .cfi_startproc"	pointer
)	O
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
symbol_get_frag	function
(	O
frchain_now	pointer
->	O
frch_cfi_data	struct
->	O
last_address	pointer
)	O
!=	O
frag_now	pointer
||	O
(	O
S_GET_VALUE	function
(	O
frchain_now	pointer
->	O
frch_cfi_data	struct
->	O
last_address	pointer
)	O
!=	O
frag_now_fix	function
(	O
)	O
)	O
)	O
cfi_add_advance_loc	function
(	O
symbol_temp_new_now	function
(	O
)	O
)	O
;	O
insn_ptr	pointer
=	O
alloc_cfi_insn_data	function
(	O
)	O
;	O
insn_ptr	pointer
->	O
insn	int
=	O
CFI_val_encoded_addr	int
;	O
insn_ptr	pointer
->	O
u	union
.	O
ea	struct
.	O
reg	int
=	O
cfi_parse_reg	function
(	O
)	O
;	O
cfi_parse_separator	function
(	O
)	O
;	O
encoding	int
=	O
cfi_parse_const	function
(	O
)	O
;	O
if	O
(	O
(	O
encoding	int
&	O
0xff	int
)	O
!=	O
encoding	int
||	O
(	O
(	O
encoding	int
&	O
0x70	int
)	O
!=	O
0	int
&&	O
(	O
encoding	int
&	O
0x70	int
)	O
!=	O
DW_EH_PE_pcrel	int
)	O
||	O
(	O
encoding	int
&	O
7	int
)	O
==	O
DW_EH_PE_uleb128	int
||	O
(	O
encoding	int
&	O
7	int
)	O
>	O
DW_EH_PE_udata8	int
)	O
{	O
as_bad	function
(	O
_	O
(	O
"invalid or unsupported encoding in .cfi_lsda"	pointer
)	O
)	O
;	O
encoding	int
=	O
DW_EH_PE_omit	int
;	O
}	O
cfi_parse_separator	function
(	O
)	O
;	O
expression_and_evaluate	O
(	O
&	O
insn_ptr	pointer
->	O
u	union
.	O
ea	struct
.	O
exp	pointer
)	O
;	O
switch	O
(	O
insn_ptr	pointer
->	O
u	union
.	O
ea	struct
.	O
exp	pointer
.	O
X_op	enum
)	O
{	O
case	O
O_symbol	int
:	O
break	O
;	O
case	O
O_constant	int
:	O
if	O
(	O
(	O
encoding	int
&	O
0x70	int
)	O
!=	O
DW_EH_PE_pcrel	int
)	O
break	O
;	O
default	O
:	O
encoding	int
=	O
DW_EH_PE_omit	int
;	O
break	O
;	O
}	O
insn_ptr	pointer
->	O
u	union
.	O
ea	struct
.	O
encoding	int
=	O
encoding	int
;	O
if	O
(	O
encoding	int
==	O
DW_EH_PE_omit	int
)	O
{	O
as_bad	function
(	O
_	O
(	O
"wrong third argument to .cfi_val_encoded_addr"	pointer
)	O
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
}	O
static	O
void	O
dot_cfi_label	function
(	O
int	O
ignored	int
ATTRIBUTE_UNUSED	O
)	O
{	O
char	O
*	O
name	pointer
;	O
if	O
(	O
frchain_now	pointer
->	O
frch_cfi_data	struct
==	O
NULL	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"CFI instruction used without previous .cfi_startproc"	pointer
)	O
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
name	pointer
=	O
read_symbol_name	function
(	O
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
symbol_get_frag	function
(	O
frchain_now	pointer
->	O
frch_cfi_data	struct
->	O
last_address	pointer
)	O
!=	O
frag_now	pointer
||	O
(	O
S_GET_VALUE	function
(	O
frchain_now	pointer
->	O
frch_cfi_data	struct
->	O
last_address	pointer
)	O
!=	O
frag_now_fix	function
(	O
)	O
)	O
)	O
cfi_add_advance_loc	function
(	O
symbol_temp_new_now	function
(	O
)	O
)	O
;	O
cfi_add_label	function
(	O
name	pointer
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
}	O
static	O
void	O
dot_cfi_sections	function
(	O
int	O
ignored	int
ATTRIBUTE_UNUSED	O
)	O
{	O
int	O
sections	pointer
=	O
0	int
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
is_name_beginner	O
(	O
*	O
input_line_pointer	pointer
)	O
||	O
*	O
input_line_pointer	pointer
==	O
'"'	O
)	O
while	O
(	O
1	int
)	O
{	O
char	O
*	O
saved_ilp	pointer
;	O
char	O
*	O
name	pointer
,	O
c	struct
;	O
saved_ilp	pointer
=	O
input_line_pointer	pointer
;	O
c	struct
=	O
get_symbol_name	function
(	O
&	O
name	pointer
)	O
;	O
if	O
(	O
strncmp	function
(	O
name	pointer
,	O
".eh_frame"	pointer
,	O
sizeof	O
".eh_frame"	pointer
)	O
==	O
0	int
&&	O
name	pointer
[	O
9	int
]	O
!=	O
'_'	O
)	O
sections	pointer
|=	O
CFI_EMIT_eh_frame	O
;	O
else	O
if	O
(	O
strncmp	function
(	O
name	pointer
,	O
".debug_frame"	pointer
,	O
sizeof	O
".debug_frame"	pointer
)	O
==	O
0	int
)	O
sections	pointer
|=	O
CFI_EMIT_debug_frame	O
;	O
else	O
{	O
*	O
input_line_pointer	pointer
=	O
c	struct
;	O
input_line_pointer	pointer
=	O
saved_ilp	pointer
;	O
break	O
;	O
}	O
*	O
input_line_pointer	pointer
=	O
c	struct
;	O
SKIP_WHITESPACE_AFTER_NAME	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	pointer
==	O
','	O
)	O
{	O
name	pointer
=	O
input_line_pointer	pointer
++	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
!	O
is_name_beginner	O
(	O
*	O
input_line_pointer	pointer
)	O
&&	O
*	O
input_line_pointer	pointer
!=	O
'"'	O
)	O
{	O
input_line_pointer	pointer
=	O
name	pointer
;	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
is_name_beginner	O
(	O
*	O
input_line_pointer	pointer
)	O
||	O
*	O
input_line_pointer	pointer
==	O
'"'	O
)	O
break	O
;	O
}	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
if	O
(	O
cfi_sections_set	int
&&	O
(	O
sections	pointer
&	O
(	O
CFI_EMIT_eh_frame	O
|	O
CFI_EMIT_eh_frame_compact	O
)	O
)	O
&&	O
(	O
(	O
cfi_sections	int
&	O
(	O
CFI_EMIT_eh_frame	O
|	O
CFI_EMIT_eh_frame_compact	O
)	O
)	O
!=	O
(	O
sections	pointer
&	O
(	O
CFI_EMIT_eh_frame	O
|	O
CFI_EMIT_eh_frame_compact	O
)	O
)	O
)	O
)	O
as_bad	function
(	O
_	O
(	O
"inconsistent uses of .cfi_sections"	pointer
)	O
)	O
;	O
cfi_sections	int
=	O
sections	pointer
;	O
}	O
static	O
void	O
dot_cfi_startproc	function
(	O
int	O
ignored	int
ATTRIBUTE_UNUSED	O
)	O
{	O
int	O
simple	int
=	O
0	int
;	O
if	O
(	O
frchain_now	pointer
->	O
frch_cfi_data	struct
!=	O
NULL	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"previous CFI entry not closed (missing .cfi_endproc)"	pointer
)	O
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
cfi_new_fde	function
(	O
symbol_temp_new_now	function
(	O
)	O
)	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
is_name_beginner	O
(	O
*	O
input_line_pointer	pointer
)	O
||	O
*	O
input_line_pointer	pointer
==	O
'"'	O
)	O
{	O
char	O
*	O
saved_ilp	pointer
=	O
input_line_pointer	pointer
;	O
char	O
*	O
name	pointer
,	O
c	struct
;	O
c	struct
=	O
get_symbol_name	function
(	O
&	O
name	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
name	pointer
,	O
"simple"	pointer
)	O
==	O
0	int
)	O
{	O
simple	int
=	O
1	int
;	O
restore_line_pointer	function
(	O
c	struct
)	O
;	O
}	O
else	O
input_line_pointer	pointer
=	O
saved_ilp	pointer
;	O
}	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
cfi_sections_set	int
=	O
TRUE	int
;	O
all_cfi_sections	int
|=	O
cfi_sections	int
;	O
cfi_set_sections	function
(	O
)	O
;	O
frchain_now	pointer
->	O
frch_cfi_data	struct
->	O
cur_cfa_offset	long
=	O
0	int
;	O
if	O
(	O
!	O
simple	int
)	O
tc_cfi_frame_initial_instructions	O
(	O
)	O
;	O
if	O
(	O
(	O
cfi_sections	int
&	O
CFI_EMIT_target	O
)	O
!=	O
0	int
)	O
tc_cfi_startproc	O
(	O
)	O
;	O
}	O
static	O
void	O
dot_cfi_endproc	function
(	O
int	O
ignored	int
ATTRIBUTE_UNUSED	O
)	O
{	O
if	O
(	O
frchain_now	pointer
->	O
frch_cfi_data	struct
==	O
NULL	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
".cfi_endproc without corresponding .cfi_startproc"	pointer
)	O
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
last_fde	pointer
=	O
frchain_now	pointer
->	O
frch_cfi_data	struct
->	O
cur_fde_data	pointer
;	O
cfi_end_fde	function
(	O
symbol_temp_new_now	function
(	O
)	O
)	O
;	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
cfi_sections_set	int
=	O
TRUE	int
;	O
if	O
(	O
(	O
cfi_sections	int
&	O
CFI_EMIT_target	O
)	O
!=	O
0	int
)	O
tc_cfi_endproc	O
(	O
last_fde	pointer
)	O
;	O
}	O
static	O
segT	pointer
get_cfi_seg	function
(	O
segT	pointer
cseg	pointer
,	O
const	O
char	O
*	O
base	int
,	O
flagword	int
flags	int
,	O
int	O
align	int
)	O
{	O
if	O
(	O
SUPPORT_FRAME_LINKONCE	int
||	O
(	O
(	O
flags	int
&	O
SEC_DEBUGGING	int
)	O
==	O
0	int
&&	O
compact_eh	int
)	O
)	O
{	O
struct	O
dwcfi_seg_list	struct
*	O
l	long
;	O
l	long
=	O
dwcfi_hash_find_or_make	function
(	O
cseg	pointer
,	O
base	int
,	O
flags	int
)	O
;	O
cseg	pointer
=	O
l	long
->	O
seg	pointer
;	O
subseg_set	function
(	O
cseg	pointer
,	O
l	long
->	O
subseg	int
)	O
;	O
}	O
else	O
{	O
cseg	pointer
=	O
subseg_new	function
(	O
base	int
,	O
0	int
)	O
;	O
bfd_set_section_flags	function
(	O
cseg	pointer
,	O
flags	int
)	O
;	O
}	O
record_alignment	function
(	O
cseg	pointer
,	O
align	int
)	O
;	O
return	O
cseg	pointer
;	O
}	O
static	O
void	O
dot_cfi_inline_lsda	function
(	O
int	O
ignored	int
ATTRIBUTE_UNUSED	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
".cfi_inline_lsda is not supported for this target"	pointer
)	O
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
}	O
static	O
void	O
dot_cfi_fde_data	function
(	O
int	O
ignored	int
ATTRIBUTE_UNUSED	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
".cfi_fde_data is not supported for this target"	pointer
)	O
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
}	O
static	O
void	O
dot_cfi_personality_id	function
(	O
int	O
ignored	int
ATTRIBUTE_UNUSED	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
".cfi_personality_id is not supported for this target"	pointer
)	O
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
}	O
static	O
void	O
output_cfi_insn	function
(	O
struct	O
cfi_insn_data	struct
*	O
insn	int
)	O
{	O
offsetT	long
offset	long
;	O
unsigned	O
int	O
regno	int
;	O
switch	O
(	O
insn	int
->	O
insn	int
)	O
{	O
case	O
DW_CFA_advance_loc	int
:	O
{	O
symbolS	struct
*	O
from	pointer
=	O
insn	int
->	O
u	union
.	O
ll	struct
.	O
lab1	pointer
;	O
symbolS	struct
*	O
to	pointer
=	O
insn	int
->	O
u	union
.	O
ll	struct
.	O
lab2	pointer
;	O
if	O
(	O
symbol_get_frag	function
(	O
to	pointer
)	O
==	O
symbol_get_frag	function
(	O
from	pointer
)	O
)	O
{	O
addressT	long
delta	long
=	O
S_GET_VALUE	function
(	O
to	pointer
)	O
-	O
S_GET_VALUE	function
(	O
from	pointer
)	O
;	O
addressT	long
scaled	long
=	O
delta	long
/	O
DWARF2_LINE_MIN_INSN_LENGTH	int
;	O
if	O
(	O
scaled	long
==	O
0	int
)	O
;	O
else	O
if	O
(	O
scaled	long
<=	O
0x3F	int
)	O
out_one	function
(	O
DW_CFA_advance_loc	int
+	O
scaled	long
)	O
;	O
else	O
if	O
(	O
scaled	long
<=	O
0xFF	int
)	O
{	O
out_one	function
(	O
DW_CFA_advance_loc1	int
)	O
;	O
out_one	function
(	O
scaled	long
)	O
;	O
}	O
else	O
if	O
(	O
scaled	long
<=	O
0xFFFF	int
)	O
{	O
out_one	function
(	O
DW_CFA_advance_loc2	int
)	O
;	O
out_two	function
(	O
scaled	long
)	O
;	O
}	O
else	O
{	O
out_one	function
(	O
DW_CFA_advance_loc4	int
)	O
;	O
out_four	function
(	O
scaled	long
)	O
;	O
}	O
}	O
else	O
{	O
expressionS	struct
exp	pointer
;	O
exp	pointer
.	O
X_op	enum
=	O
O_subtract	int
;	O
exp	pointer
.	O
X_add_symbol	pointer
=	O
to	pointer
;	O
exp	pointer
.	O
X_op_symbol	pointer
=	O
from	pointer
;	O
exp	pointer
.	O
X_add_number	long
=	O
0	int
;	O
frag_grow	function
(	O
5	int
)	O
;	O
*	O
frag_more	function
(	O
1	int
)	O
=	O
DW_CFA_advance_loc4	int
;	O
frag_var	function
(	O
rs_cfa	int
,	O
4	int
,	O
0	int
,	O
DWARF2_LINE_MIN_INSN_LENGTH	int
<<	O
3	int
,	O
make_expr_symbol	function
(	O
&	O
exp	pointer
)	O
,	O
frag_now_fix	function
(	O
)	O
-	O
1	int
,	O
(	O
char	O
*	O
)	O
frag_now	pointer
)	O
;	O
}	O
}	O
break	O
;	O
case	O
DW_CFA_def_cfa	int
:	O
offset	long
=	O
insn	int
->	O
u	union
.	O
ri	struct
.	O
offset	long
;	O
if	O
(	O
offset	long
<	O
0	int
)	O
{	O
out_one	function
(	O
DW_CFA_def_cfa_sf	int
)	O
;	O
out_uleb128	function
(	O
insn	int
->	O
u	union
.	O
ri	struct
.	O
reg	int
)	O
;	O
out_sleb128	function
(	O
offset	long
/	O
DWARF2_CIE_DATA_ALIGNMENT	O
)	O
;	O
}	O
else	O
{	O
out_one	function
(	O
DW_CFA_def_cfa	int
)	O
;	O
out_uleb128	function
(	O
insn	int
->	O
u	union
.	O
ri	struct
.	O
reg	int
)	O
;	O
out_uleb128	function
(	O
offset	long
)	O
;	O
}	O
break	O
;	O
case	O
DW_CFA_def_cfa_register	int
:	O
case	O
DW_CFA_undefined	int
:	O
case	O
DW_CFA_same_value	int
:	O
out_one	function
(	O
insn	int
->	O
insn	int
)	O
;	O
out_uleb128	function
(	O
insn	int
->	O
u	union
.	O
r	struct
)	O
;	O
break	O
;	O
case	O
DW_CFA_def_cfa_offset	int
:	O
offset	long
=	O
insn	int
->	O
u	union
.	O
i	pointer
;	O
if	O
(	O
offset	long
<	O
0	int
)	O
{	O
out_one	function
(	O
DW_CFA_def_cfa_offset_sf	int
)	O
;	O
out_sleb128	function
(	O
offset	long
/	O
DWARF2_CIE_DATA_ALIGNMENT	O
)	O
;	O
}	O
else	O
{	O
out_one	function
(	O
DW_CFA_def_cfa_offset	int
)	O
;	O
out_uleb128	function
(	O
offset	long
)	O
;	O
}	O
break	O
;	O
case	O
DW_CFA_restore	int
:	O
regno	int
=	O
insn	int
->	O
u	union
.	O
r	struct
;	O
if	O
(	O
regno	int
<=	O
0x3F	int
)	O
{	O
out_one	function
(	O
DW_CFA_restore	int
+	O
regno	int
)	O
;	O
}	O
else	O
{	O
out_one	function
(	O
DW_CFA_restore_extended	int
)	O
;	O
out_uleb128	function
(	O
regno	int
)	O
;	O
}	O
break	O
;	O
case	O
DW_CFA_offset	int
:	O
regno	int
=	O
insn	int
->	O
u	union
.	O
ri	struct
.	O
reg	int
;	O
offset	long
=	O
insn	int
->	O
u	union
.	O
ri	struct
.	O
offset	long
/	O
DWARF2_CIE_DATA_ALIGNMENT	O
;	O
if	O
(	O
offset	long
<	O
0	int
)	O
{	O
out_one	function
(	O
DW_CFA_offset_extended_sf	int
)	O
;	O
out_uleb128	function
(	O
regno	int
)	O
;	O
out_sleb128	function
(	O
offset	long
)	O
;	O
}	O
else	O
if	O
(	O
regno	int
<=	O
0x3F	int
)	O
{	O
out_one	function
(	O
DW_CFA_offset	int
+	O
regno	int
)	O
;	O
out_uleb128	function
(	O
offset	long
)	O
;	O
}	O
else	O
{	O
out_one	function
(	O
DW_CFA_offset_extended	int
)	O
;	O
out_uleb128	function
(	O
regno	int
)	O
;	O
out_uleb128	function
(	O
offset	long
)	O
;	O
}	O
break	O
;	O
case	O
DW_CFA_val_offset	int
:	O
regno	int
=	O
insn	int
->	O
u	union
.	O
ri	struct
.	O
reg	int
;	O
offset	long
=	O
insn	int
->	O
u	union
.	O
ri	struct
.	O
offset	long
/	O
DWARF2_CIE_DATA_ALIGNMENT	O
;	O
if	O
(	O
offset	long
<	O
0	int
)	O
{	O
out_one	function
(	O
DW_CFA_val_offset_sf	int
)	O
;	O
out_uleb128	function
(	O
regno	int
)	O
;	O
out_sleb128	function
(	O
offset	long
)	O
;	O
}	O
else	O
{	O
out_one	function
(	O
DW_CFA_val_offset	int
)	O
;	O
out_uleb128	function
(	O
regno	int
)	O
;	O
out_uleb128	function
(	O
offset	long
)	O
;	O
}	O
break	O
;	O
case	O
DW_CFA_register	int
:	O
out_one	function
(	O
DW_CFA_register	int
)	O
;	O
out_uleb128	function
(	O
insn	int
->	O
u	union
.	O
rr	struct
.	O
reg1	int
)	O
;	O
out_uleb128	function
(	O
insn	int
->	O
u	union
.	O
rr	struct
.	O
reg2	int
)	O
;	O
break	O
;	O
case	O
DW_CFA_remember_state	int
:	O
case	O
DW_CFA_restore_state	int
:	O
out_one	function
(	O
insn	int
->	O
insn	int
)	O
;	O
break	O
;	O
case	O
DW_CFA_GNU_window_save	int
:	O
out_one	function
(	O
DW_CFA_GNU_window_save	int
)	O
;	O
break	O
;	O
case	O
CFI_escape	int
:	O
{	O
struct	O
cfi_escape_data	struct
*	O
e	pointer
;	O
for	O
(	O
e	pointer
=	O
insn	int
->	O
u	union
.	O
esc	pointer
;	O
e	pointer
;	O
e	pointer
=	O
e	pointer
->	O
next	pointer
)	O
emit_expr	function
(	O
&	O
e	pointer
->	O
exp	pointer
,	O
1	int
)	O
;	O
break	O
;	O
}	O
case	O
CFI_val_encoded_addr	int
:	O
{	O
unsigned	O
encoding	int
=	O
insn	int
->	O
u	union
.	O
ea	struct
.	O
encoding	int
;	O
offsetT	long
enc_size	long
;	O
if	O
(	O
encoding	int
==	O
DW_EH_PE_omit	int
)	O
break	O
;	O
out_one	function
(	O
DW_CFA_val_expression	int
)	O
;	O
out_uleb128	function
(	O
insn	int
->	O
u	union
.	O
ea	struct
.	O
reg	int
)	O
;	O
switch	O
(	O
encoding	int
&	O
0x7	int
)	O
{	O
case	O
DW_EH_PE_absptr	int
:	O
enc_size	long
=	O
DWARF2_ADDR_SIZE	O
(	O
stdoutput	pointer
)	O
;	O
break	O
;	O
case	O
DW_EH_PE_udata2	int
:	O
enc_size	long
=	O
2	int
;	O
break	O
;	O
case	O
DW_EH_PE_udata4	int
:	O
enc_size	long
=	O
4	int
;	O
break	O
;	O
case	O
DW_EH_PE_udata8	int
:	O
enc_size	long
=	O
8	int
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
if	O
(	O
insn	int
->	O
u	union
.	O
ea	struct
.	O
encoding	int
==	O
DW_EH_PE_absptr	int
)	O
{	O
out_uleb128	function
(	O
1	int
+	O
enc_size	long
)	O
;	O
out_one	function
(	O
DW_OP_addr	int
)	O
;	O
}	O
else	O
{	O
out_uleb128	function
(	O
1	int
+	O
1	int
+	O
enc_size	long
)	O
;	O
out_one	function
(	O
DW_OP_GNU_encoded_addr	int
)	O
;	O
out_one	function
(	O
encoding	int
)	O
;	O
if	O
(	O
(	O
encoding	int
&	O
0x70	int
)	O
==	O
DW_EH_PE_pcrel	int
)	O
{	O
insn	int
->	O
u	union
.	O
ea	struct
.	O
exp	pointer
.	O
X_op	enum
=	O
O_subtract	int
;	O
insn	int
->	O
u	union
.	O
ea	struct
.	O
exp	pointer
.	O
X_op_symbol	pointer
=	O
symbol_temp_new_now	function
(	O
)	O
;	O
}	O
}	O
emit_expr	function
(	O
&	O
insn	int
->	O
u	union
.	O
ea	struct
.	O
exp	pointer
,	O
enc_size	long
)	O
;	O
}	O
break	O
;	O
case	O
CFI_label	int
:	O
colon	function
(	O
insn	int
->	O
u	union
.	O
sym_name	pointer
)	O
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
}	O
static	O
void	O
output_cie	function
(	O
struct	O
cie_entry	struct
*	O
cie	struct
,	O
bfd_boolean	int
eh_frame	int
,	O
int	O
align	int
)	O
{	O
symbolS	struct
*	O
after_size_address	pointer
,	O
*	O
end_address	pointer
;	O
expressionS	struct
exp	pointer
;	O
struct	O
cfi_insn_data	struct
*	O
i	pointer
;	O
offsetT	long
augmentation_size	long
;	O
int	O
enc	int
;	O
enum	O
dwarf2_format	enum
fmt	pointer
=	O
DWARF2_FORMAT	O
(	O
now_seg	pointer
)	O
;	O
cie	struct
->	O
start_address	long
=	O
symbol_temp_new_now	function
(	O
)	O
;	O
after_size_address	pointer
=	O
symbol_temp_make	function
(	O
)	O
;	O
end_address	pointer
=	O
symbol_temp_make	function
(	O
)	O
;	O
exp	pointer
.	O
X_op	enum
=	O
O_subtract	int
;	O
exp	pointer
.	O
X_add_symbol	pointer
=	O
end_address	pointer
;	O
exp	pointer
.	O
X_op_symbol	pointer
=	O
after_size_address	pointer
;	O
exp	pointer
.	O
X_add_number	long
=	O
0	int
;	O
if	O
(	O
eh_frame	int
||	O
fmt	pointer
==	O
dwarf2_format_32bit	int
)	O
emit_expr	function
(	O
&	O
exp	pointer
,	O
4	int
)	O
;	O
else	O
{	O
if	O
(	O
fmt	pointer
==	O
dwarf2_format_64bit	int
)	O
out_four	function
(	O
-	O
1	int
)	O
;	O
emit_expr	function
(	O
&	O
exp	pointer
,	O
8	int
)	O
;	O
}	O
symbol_set_value_now	function
(	O
after_size_address	pointer
)	O
;	O
if	O
(	O
eh_frame	int
)	O
out_four	function
(	O
0	int
)	O
;	O
else	O
{	O
out_four	function
(	O
-	O
1	int
)	O
;	O
if	O
(	O
fmt	pointer
!=	O
dwarf2_format_32bit	int
)	O
out_four	function
(	O
-	O
1	int
)	O
;	O
}	O
out_one	function
(	O
flag_dwarf_cie_version	int
)	O
;	O
if	O
(	O
eh_frame	int
)	O
{	O
out_one	function
(	O
'z'	O
)	O
;	O
if	O
(	O
cie	struct
->	O
per_encoding	char
!=	O
DW_EH_PE_omit	int
)	O
out_one	function
(	O
'P'	O
)	O
;	O
if	O
(	O
cie	struct
->	O
lsda_encoding	int
!=	O
DW_EH_PE_omit	int
)	O
out_one	function
(	O
'L'	O
)	O
;	O
out_one	function
(	O
'R'	O
)	O
;	O
}	O
if	O
(	O
cie	struct
->	O
signal_frame	int
)	O
out_one	function
(	O
'S'	O
)	O
;	O
out_one	function
(	O
0	int
)	O
;	O
if	O
(	O
flag_dwarf_cie_version	int
>=	O
4	int
)	O
{	O
int	O
address_size	int
=	O
dwarf2_format_32bit	int
?	O
4	int
:	O
8	int
;	O
out_one	function
(	O
address_size	int
)	O
;	O
out_one	function
(	O
0	int
)	O
;	O
}	O
out_uleb128	function
(	O
DWARF2_LINE_MIN_INSN_LENGTH	int
)	O
;	O
out_sleb128	function
(	O
DWARF2_CIE_DATA_ALIGNMENT	O
)	O
;	O
if	O
(	O
flag_dwarf_cie_version	int
==	O
1	int
)	O
{	O
if	O
(	O
(	O
cie	struct
->	O
return_column	int
&	O
0xff	int
)	O
!=	O
cie	struct
->	O
return_column	int
)	O
as_bad	function
(	O
_	O
(	O
"return column number %d overflows in CIE version 1"	pointer
)	O
,	O
cie	struct
->	O
return_column	int
)	O
;	O
out_one	function
(	O
cie	struct
->	O
return_column	int
)	O
;	O
}	O
else	O
out_uleb128	function
(	O
cie	struct
->	O
return_column	int
)	O
;	O
if	O
(	O
eh_frame	int
)	O
{	O
augmentation_size	long
=	O
1	int
+	O
(	O
cie	struct
->	O
lsda_encoding	int
!=	O
DW_EH_PE_omit	int
)	O
;	O
if	O
(	O
cie	struct
->	O
per_encoding	char
!=	O
DW_EH_PE_omit	int
)	O
augmentation_size	long
+=	O
1	int
+	O
encoding_size	function
(	O
cie	struct
->	O
per_encoding	char
)	O
;	O
out_uleb128	function
(	O
augmentation_size	long
)	O
;	O
emit_expr_encoded	function
(	O
&	O
cie	struct
->	O
personality	struct
,	O
cie	struct
->	O
per_encoding	char
,	O
TRUE	int
)	O
;	O
if	O
(	O
cie	struct
->	O
lsda_encoding	int
!=	O
DW_EH_PE_omit	int
)	O
out_one	function
(	O
cie	struct
->	O
lsda_encoding	int
)	O
;	O
}	O
switch	O
(	O
DWARF2_FDE_RELOC_SIZE	int
)	O
{	O
case	O
2	int
:	O
enc	int
=	O
DW_EH_PE_sdata2	int
;	O
break	O
;	O
case	O
4	int
:	O
enc	int
=	O
DW_EH_PE_sdata4	int
;	O
break	O
;	O
case	O
8	int
:	O
enc	int
=	O
DW_EH_PE_sdata8	int
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
enc	int
|=	O
DW_EH_PE_pcrel	int
;	O
cie	struct
->	O
fde_encoding	int
=	O
enc	int
;	O
if	O
(	O
eh_frame	int
)	O
out_one	function
(	O
enc	int
)	O
;	O
if	O
(	O
cie	struct
->	O
first	pointer
)	O
{	O
for	O
(	O
i	pointer
=	O
cie	struct
->	O
first	pointer
;	O
i	pointer
!=	O
cie	struct
->	O
last	pointer
;	O
i	pointer
=	O
i	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
CUR_SEG	O
(	O
i	pointer
)	O
!=	O
CUR_SEG	O
(	O
cie	struct
)	O
)	O
continue	O
;	O
output_cfi_insn	function
(	O
i	pointer
)	O
;	O
}	O
}	O
frag_align	function
(	O
align	int
,	O
DW_CFA_nop	int
,	O
0	int
)	O
;	O
symbol_set_value_now	function
(	O
end_address	pointer
)	O
;	O
}	O
static	O
void	O
output_fde	function
(	O
struct	O
fde_entry	struct
*	O
fde	struct
,	O
struct	O
cie_entry	struct
*	O
cie	struct
,	O
bfd_boolean	int
eh_frame	int
,	O
struct	O
cfi_insn_data	struct
*	O
first	pointer
,	O
int	O
align	int
)	O
{	O
symbolS	struct
*	O
after_size_address	pointer
,	O
*	O
end_address	pointer
;	O
expressionS	struct
exp	pointer
;	O
offsetT	long
augmentation_size	long
;	O
enum	O
dwarf2_format	enum
fmt	pointer
=	O
DWARF2_FORMAT	O
(	O
now_seg	pointer
)	O
;	O
unsigned	O
int	O
offset_size	int
;	O
unsigned	O
int	O
addr_size	int
;	O
after_size_address	pointer
=	O
symbol_temp_make	function
(	O
)	O
;	O
end_address	pointer
=	O
symbol_temp_make	function
(	O
)	O
;	O
exp	pointer
.	O
X_op	enum
=	O
O_subtract	int
;	O
exp	pointer
.	O
X_add_symbol	pointer
=	O
end_address	pointer
;	O
exp	pointer
.	O
X_op_symbol	pointer
=	O
after_size_address	pointer
;	O
exp	pointer
.	O
X_add_number	long
=	O
0	int
;	O
if	O
(	O
eh_frame	int
||	O
fmt	pointer
==	O
dwarf2_format_32bit	int
)	O
offset_size	int
=	O
4	int
;	O
else	O
{	O
if	O
(	O
fmt	pointer
==	O
dwarf2_format_64bit	int
)	O
out_four	function
(	O
-	O
1	int
)	O
;	O
offset_size	int
=	O
8	int
;	O
}	O
emit_expr	function
(	O
&	O
exp	pointer
,	O
offset_size	int
)	O
;	O
symbol_set_value_now	function
(	O
after_size_address	pointer
)	O
;	O
if	O
(	O
eh_frame	int
)	O
{	O
exp	pointer
.	O
X_op	enum
=	O
O_subtract	int
;	O
exp	pointer
.	O
X_add_symbol	pointer
=	O
after_size_address	pointer
;	O
exp	pointer
.	O
X_op_symbol	pointer
=	O
cie	struct
->	O
start_address	long
;	O
exp	pointer
.	O
X_add_number	long
=	O
0	int
;	O
emit_expr	function
(	O
&	O
exp	pointer
,	O
offset_size	int
)	O
;	O
}	O
else	O
{	O
TC_DWARF2_EMIT_OFFSET	O
(	O
cie	struct
->	O
start_address	long
,	O
offset_size	int
)	O
;	O
}	O
exp	pointer
.	O
X_op	enum
=	O
O_symbol	int
;	O
if	O
(	O
eh_frame	int
)	O
{	O
bfd_reloc_code_real_type	enum
code	int
=	O
tc_cfi_reloc_for_encoding	O
(	O
cie	struct
->	O
fde_encoding	int
)	O
;	O
addr_size	int
=	O
DWARF2_FDE_RELOC_SIZE	int
;	O
if	O
(	O
code	int
!=	O
BFD_RELOC_NONE	int
)	O
{	O
reloc_howto_type	struct
*	O
howto	pointer
=	O
bfd_reloc_type_lookup	function
(	O
stdoutput	pointer
,	O
code	int
)	O
;	O
char	O
*	O
p	pointer
=	O
frag_more	function
(	O
addr_size	int
)	O
;	O
gas_assert	O
(	O
addr_size	int
==	O
(	O
unsigned	O
)	O
howto	pointer
->	O
bitsize	int
/	O
8	int
)	O
;	O
md_number_to_chars	O
(	O
p	pointer
,	O
0	int
,	O
addr_size	int
)	O
;	O
fix_new	function
(	O
frag_now	pointer
,	O
p	pointer
-	O
frag_now	pointer
->	O
fr_literal	array
,	O
addr_size	int
,	O
fde	struct
->	O
start_address	long
,	O
0	int
,	O
howto	pointer
->	O
pc_relative	int
,	O
code	int
)	O
;	O
}	O
else	O
{	O
exp	pointer
.	O
X_op	enum
=	O
O_subtract	int
;	O
exp	pointer
.	O
X_add_number	long
=	O
0	int
;	O
exp	pointer
.	O
X_add_symbol	pointer
=	O
fde	struct
->	O
start_address	long
;	O
exp	pointer
.	O
X_op_symbol	pointer
=	O
symbol_temp_new_now	function
(	O
)	O
;	O
emit_expr	function
(	O
&	O
exp	pointer
,	O
addr_size	int
)	O
;	O
}	O
}	O
else	O
{	O
exp	pointer
.	O
X_add_number	long
=	O
0	int
;	O
exp	pointer
.	O
X_add_symbol	pointer
=	O
fde	struct
->	O
start_address	long
;	O
addr_size	int
=	O
DWARF2_ADDR_SIZE	O
(	O
stdoutput	pointer
)	O
;	O
emit_expr	function
(	O
&	O
exp	pointer
,	O
addr_size	int
)	O
;	O
}	O
exp	pointer
.	O
X_op	enum
=	O
O_subtract	int
;	O
exp	pointer
.	O
X_add_symbol	pointer
=	O
fde	struct
->	O
end_address	pointer
;	O
exp	pointer
.	O
X_op_symbol	pointer
=	O
fde	struct
->	O
start_address	long
;	O
exp	pointer
.	O
X_add_number	long
=	O
0	int
;	O
emit_expr	function
(	O
&	O
exp	pointer
,	O
addr_size	int
)	O
;	O
augmentation_size	long
=	O
encoding_size	function
(	O
fde	struct
->	O
lsda_encoding	int
)	O
;	O
if	O
(	O
eh_frame	int
)	O
out_uleb128	function
(	O
augmentation_size	long
)	O
;	O
emit_expr_encoded	function
(	O
&	O
fde	struct
->	O
lsda	struct
,	O
cie	struct
->	O
lsda_encoding	int
,	O
FALSE	int
)	O
;	O
for	O
(	O
;	O
first	pointer
;	O
first	pointer
=	O
first	pointer
->	O
next	pointer
)	O
if	O
(	O
CUR_SEG	O
(	O
first	pointer
)	O
==	O
CUR_SEG	O
(	O
fde	struct
)	O
)	O
output_cfi_insn	function
(	O
first	pointer
)	O
;	O
frag_align	function
(	O
align	int
,	O
DW_CFA_nop	int
,	O
0	int
)	O
;	O
symbol_set_value_now	function
(	O
end_address	pointer
)	O
;	O
}	O
static	O
struct	O
cie_entry	struct
*	O
select_cie_for_fde	function
(	O
struct	O
fde_entry	struct
*	O
fde	struct
,	O
bfd_boolean	int
eh_frame	int
,	O
struct	O
cfi_insn_data	struct
*	O
*	O
pfirst	pointer
,	O
int	O
align	int
)	O
{	O
struct	O
cfi_insn_data	struct
*	O
i	pointer
,	O
*	O
j	pointer
;	O
struct	O
cie_entry	struct
*	O
cie	struct
;	O
for	O
(	O
cie	struct
=	O
cie_root	pointer
;	O
cie	struct
;	O
cie	struct
=	O
cie	struct
->	O
next	pointer
)	O
{	O
if	O
(	O
CUR_SEG	O
(	O
cie	struct
)	O
!=	O
CUR_SEG	O
(	O
fde	struct
)	O
)	O
continue	O
;	O
if	O
(	O
cie	struct
->	O
return_column	int
!=	O
fde	struct
->	O
return_column	int
||	O
cie	struct
->	O
signal_frame	int
!=	O
fde	struct
->	O
signal_frame	int
||	O
cie	struct
->	O
per_encoding	char
!=	O
fde	struct
->	O
per_encoding	char
||	O
cie	struct
->	O
lsda_encoding	int
!=	O
fde	struct
->	O
lsda_encoding	int
)	O
continue	O
;	O
if	O
(	O
cie	struct
->	O
per_encoding	char
!=	O
DW_EH_PE_omit	int
)	O
{	O
if	O
(	O
cie	struct
->	O
personality	struct
.	O
X_op	enum
!=	O
fde	struct
->	O
personality	struct
.	O
X_op	enum
||	O
(	O
cie	struct
->	O
personality	struct
.	O
X_add_number	long
!=	O
fde	struct
->	O
personality	struct
.	O
X_add_number	long
)	O
)	O
continue	O
;	O
switch	O
(	O
cie	struct
->	O
personality	struct
.	O
X_op	enum
)	O
{	O
case	O
O_constant	int
:	O
if	O
(	O
cie	struct
->	O
personality	struct
.	O
X_unsigned	int
!=	O
fde	struct
->	O
personality	struct
.	O
X_unsigned	int
)	O
continue	O
;	O
break	O
;	O
case	O
O_symbol	int
:	O
if	O
(	O
cie	struct
->	O
personality	struct
.	O
X_add_symbol	pointer
!=	O
fde	struct
->	O
personality	struct
.	O
X_add_symbol	pointer
)	O
continue	O
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
}	O
for	O
(	O
i	pointer
=	O
cie	struct
->	O
first	pointer
,	O
j	pointer
=	O
fde	struct
->	O
data	pointer
;	O
i	pointer
!=	O
cie	struct
->	O
last	pointer
&&	O
j	pointer
!=	O
NULL	O
;	O
i	pointer
=	O
i	pointer
->	O
next	pointer
,	O
j	pointer
=	O
j	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
i	pointer
->	O
insn	int
!=	O
j	pointer
->	O
insn	int
)	O
goto	O
fail	O
;	O
switch	O
(	O
i	pointer
->	O
insn	int
)	O
{	O
case	O
DW_CFA_advance_loc	int
:	O
case	O
DW_CFA_remember_state	int
:	O
goto	O
fail	O
;	O
case	O
DW_CFA_offset	int
:	O
case	O
DW_CFA_def_cfa	int
:	O
if	O
(	O
i	pointer
->	O
u	union
.	O
ri	struct
.	O
reg	int
!=	O
j	pointer
->	O
u	union
.	O
ri	struct
.	O
reg	int
)	O
goto	O
fail	O
;	O
if	O
(	O
i	pointer
->	O
u	union
.	O
ri	struct
.	O
offset	long
!=	O
j	pointer
->	O
u	union
.	O
ri	struct
.	O
offset	long
)	O
goto	O
fail	O
;	O
break	O
;	O
case	O
DW_CFA_register	int
:	O
if	O
(	O
i	pointer
->	O
u	union
.	O
rr	struct
.	O
reg1	int
!=	O
j	pointer
->	O
u	union
.	O
rr	struct
.	O
reg1	int
)	O
goto	O
fail	O
;	O
if	O
(	O
i	pointer
->	O
u	union
.	O
rr	struct
.	O
reg2	int
!=	O
j	pointer
->	O
u	union
.	O
rr	struct
.	O
reg2	int
)	O
goto	O
fail	O
;	O
break	O
;	O
case	O
DW_CFA_def_cfa_register	int
:	O
case	O
DW_CFA_restore	int
:	O
case	O
DW_CFA_undefined	int
:	O
case	O
DW_CFA_same_value	int
:	O
if	O
(	O
i	pointer
->	O
u	union
.	O
r	struct
!=	O
j	pointer
->	O
u	union
.	O
r	struct
)	O
goto	O
fail	O
;	O
break	O
;	O
case	O
DW_CFA_def_cfa_offset	int
:	O
if	O
(	O
i	pointer
->	O
u	union
.	O
i	pointer
!=	O
j	pointer
->	O
u	union
.	O
i	pointer
)	O
goto	O
fail	O
;	O
break	O
;	O
case	O
CFI_escape	int
:	O
case	O
CFI_val_encoded_addr	int
:	O
case	O
CFI_label	int
:	O
goto	O
fail	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
}	O
if	O
(	O
i	pointer
==	O
cie	struct
->	O
last	pointer
&&	O
(	O
!	O
j	pointer
||	O
j	pointer
->	O
insn	int
==	O
DW_CFA_advance_loc	int
||	O
j	pointer
->	O
insn	int
==	O
DW_CFA_remember_state	int
||	O
j	pointer
->	O
insn	int
==	O
CFI_escape	int
||	O
j	pointer
->	O
insn	int
==	O
CFI_val_encoded_addr	int
||	O
j	pointer
->	O
insn	int
==	O
CFI_label	int
)	O
)	O
{	O
*	O
pfirst	pointer
=	O
j	pointer
;	O
return	O
cie	struct
;	O
}	O
fail	O
:	O
;	O
}	O
cie	struct
=	O
XNEW	O
(	O
struct	O
cie_entry	struct
)	O
;	O
cie	struct
->	O
next	pointer
=	O
cie_root	pointer
;	O
cie_root	pointer
=	O
cie	struct
;	O
SET_CUR_SEG	O
(	O
cie	struct
,	O
CUR_SEG	O
(	O
fde	struct
)	O
)	O
;	O
cie	struct
->	O
return_column	int
=	O
fde	struct
->	O
return_column	int
;	O
cie	struct
->	O
signal_frame	int
=	O
fde	struct
->	O
signal_frame	int
;	O
cie	struct
->	O
per_encoding	char
=	O
fde	struct
->	O
per_encoding	char
;	O
cie	struct
->	O
lsda_encoding	int
=	O
fde	struct
->	O
lsda_encoding	int
;	O
cie	struct
->	O
personality	struct
=	O
fde	struct
->	O
personality	struct
;	O
cie	struct
->	O
first	pointer
=	O
fde	struct
->	O
data	pointer
;	O
for	O
(	O
i	pointer
=	O
cie	struct
->	O
first	pointer
;	O
i	pointer
;	O
i	pointer
=	O
i	pointer
->	O
next	pointer
)	O
if	O
(	O
i	pointer
->	O
insn	int
==	O
DW_CFA_advance_loc	int
||	O
i	pointer
->	O
insn	int
==	O
DW_CFA_remember_state	int
||	O
i	pointer
->	O
insn	int
==	O
CFI_escape	int
||	O
i	pointer
->	O
insn	int
==	O
CFI_val_encoded_addr	int
||	O
i	pointer
->	O
insn	int
==	O
CFI_label	int
)	O
break	O
;	O
cie	struct
->	O
last	pointer
=	O
i	pointer
;	O
*	O
pfirst	pointer
=	O
i	pointer
;	O
output_cie	function
(	O
cie	struct
,	O
eh_frame	int
,	O
align	int
)	O
;	O
return	O
cie	struct
;	O
}	O
void	O
cfi_finish	function
(	O
void	O
)	O
{	O
struct	O
cie_entry	struct
*	O
cie	struct
,	O
*	O
cie_next	pointer
;	O
segT	pointer
cfi_seg	pointer
,	O
ccseg	pointer
;	O
struct	O
fde_entry	struct
*	O
fde	struct
;	O
struct	O
cfi_insn_data	struct
*	O
first	pointer
;	O
int	O
save_flag_traditional_format	int
,	O
seek_next_seg	int
;	O
if	O
(	O
all_fde_data	pointer
==	O
0	int
)	O
return	O
;	O
cfi_sections_set	int
=	O
TRUE	int
;	O
if	O
(	O
(	O
all_cfi_sections	int
&	O
CFI_EMIT_eh_frame	O
)	O
!=	O
0	int
||	O
(	O
all_cfi_sections	int
&	O
CFI_EMIT_eh_frame_compact	O
)	O
!=	O
0	int
)	O
{	O
save_flag_traditional_format	int
=	O
flag_traditional_format	int
;	O
flag_traditional_format	int
=	O
1	int
;	O
if	O
(	O
!	O
EH_FRAME_LINKONCE	O
)	O
{	O
cfi_seg	pointer
=	O
get_cfi_seg	function
(	O
NULL	O
,	O
".eh_frame"	pointer
,	O
(	O
SEC_ALLOC	int
|	O
SEC_LOAD	int
|	O
SEC_DATA	int
|	O
DWARF2_EH_FRAME_READ_ONLY	O
)	O
,	O
EH_FRAME_ALIGNMENT	O
)	O
;	O
(	O
void	O
)	O
cfi_seg	pointer
;	O
}	O
do	O
{	O
ccseg	pointer
=	O
NULL	O
;	O
seek_next_seg	int
=	O
0	int
;	O
for	O
(	O
cie	struct
=	O
cie_root	pointer
;	O
cie	struct
;	O
cie	struct
=	O
cie_next	pointer
)	O
{	O
cie_next	pointer
=	O
cie	struct
->	O
next	pointer
;	O
free	function
(	O
(	O
void	O
*	O
)	O
cie	struct
)	O
;	O
}	O
cie_root	pointer
=	O
NULL	O
;	O
for	O
(	O
fde	struct
=	O
all_fde_data	pointer
;	O
fde	struct
;	O
fde	struct
=	O
fde	struct
->	O
next	pointer
)	O
{	O
if	O
(	O
(	O
fde	struct
->	O
sections	pointer
&	O
CFI_EMIT_eh_frame	O
)	O
==	O
0	int
&&	O
(	O
fde	struct
->	O
sections	pointer
&	O
CFI_EMIT_eh_frame_compact	O
)	O
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
EH_FRAME_LINKONCE	O
)	O
{	O
if	O
(	O
HANDLED	int
(	O
fde	struct
)	O
)	O
continue	O
;	O
if	O
(	O
seek_next_seg	int
&&	O
CUR_SEG	O
(	O
fde	struct
)	O
!=	O
ccseg	pointer
)	O
{	O
seek_next_seg	int
=	O
2	int
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
seek_next_seg	int
)	O
{	O
ccseg	pointer
=	O
CUR_SEG	O
(	O
fde	struct
)	O
;	O
cfi_seg	pointer
=	O
get_cfi_seg	function
(	O
ccseg	pointer
,	O
".eh_frame"	pointer
,	O
(	O
SEC_ALLOC	int
|	O
SEC_LOAD	int
|	O
SEC_DATA	int
|	O
DWARF2_EH_FRAME_READ_ONLY	O
)	O
,	O
EH_FRAME_ALIGNMENT	O
)	O
;	O
(	O
void	O
)	O
cfi_seg	pointer
;	O
seek_next_seg	int
=	O
1	int
;	O
}	O
SET_HANDLED	O
(	O
fde	struct
,	O
1	int
)	O
;	O
}	O
if	O
(	O
fde	struct
->	O
end_address	pointer
==	O
NULL	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"open CFI at the end of file; "	pointer
"missing .cfi_endproc directive"	pointer
)	O
)	O
;	O
fde	struct
->	O
end_address	pointer
=	O
fde	struct
->	O
start_address	long
;	O
}	O
cie	struct
=	O
select_cie_for_fde	function
(	O
fde	struct
,	O
TRUE	int
,	O
&	O
first	pointer
,	O
2	int
)	O
;	O
fde	struct
->	O
eh_loc	pointer
=	O
symbol_temp_new_now	function
(	O
)	O
;	O
output_fde	function
(	O
fde	struct
,	O
cie	struct
,	O
TRUE	int
,	O
first	pointer
,	O
fde	struct
->	O
next	pointer
==	O
NULL	O
?	O
EH_FRAME_ALIGNMENT	O
:	O
2	int
)	O
;	O
}	O
}	O
while	O
(	O
EH_FRAME_LINKONCE	O
&&	O
seek_next_seg	int
==	O
2	int
)	O
;	O
if	O
(	O
EH_FRAME_LINKONCE	O
)	O
for	O
(	O
fde	struct
=	O
all_fde_data	pointer
;	O
fde	struct
;	O
fde	struct
=	O
fde	struct
->	O
next	pointer
)	O
SET_HANDLED	O
(	O
fde	struct
,	O
0	int
)	O
;	O
flag_traditional_format	int
=	O
save_flag_traditional_format	int
;	O
}	O
cfi_sections_set	int
=	O
TRUE	int
;	O
if	O
(	O
(	O
all_cfi_sections	int
&	O
CFI_EMIT_debug_frame	O
)	O
!=	O
0	int
)	O
{	O
int	O
alignment	int
=	O
ffs	function
(	O
DWARF2_ADDR_SIZE	O
(	O
stdoutput	pointer
)	O
)	O
-	O
1	int
;	O
if	O
(	O
!	O
SUPPORT_FRAME_LINKONCE	int
)	O
get_cfi_seg	function
(	O
NULL	O
,	O
".debug_frame"	pointer
,	O
SEC_READONLY	int
|	O
SEC_DEBUGGING	int
,	O
alignment	int
)	O
;	O
do	O
{	O
ccseg	pointer
=	O
NULL	O
;	O
seek_next_seg	int
=	O
0	int
;	O
for	O
(	O
cie	struct
=	O
cie_root	pointer
;	O
cie	struct
;	O
cie	struct
=	O
cie_next	pointer
)	O
{	O
cie_next	pointer
=	O
cie	struct
->	O
next	pointer
;	O
free	function
(	O
(	O
void	O
*	O
)	O
cie	struct
)	O
;	O
}	O
cie_root	pointer
=	O
NULL	O
;	O
for	O
(	O
fde	struct
=	O
all_fde_data	pointer
;	O
fde	struct
;	O
fde	struct
=	O
fde	struct
->	O
next	pointer
)	O
{	O
if	O
(	O
(	O
fde	struct
->	O
sections	pointer
&	O
CFI_EMIT_debug_frame	O
)	O
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
SUPPORT_FRAME_LINKONCE	int
)	O
{	O
if	O
(	O
HANDLED	int
(	O
fde	struct
)	O
)	O
continue	O
;	O
if	O
(	O
seek_next_seg	int
&&	O
CUR_SEG	O
(	O
fde	struct
)	O
!=	O
ccseg	pointer
)	O
{	O
seek_next_seg	int
=	O
2	int
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
seek_next_seg	int
)	O
{	O
ccseg	pointer
=	O
CUR_SEG	O
(	O
fde	struct
)	O
;	O
get_cfi_seg	function
(	O
ccseg	pointer
,	O
".debug_frame"	pointer
,	O
SEC_READONLY	int
|	O
SEC_DEBUGGING	int
,	O
alignment	int
)	O
;	O
seek_next_seg	int
=	O
1	int
;	O
}	O
SET_HANDLED	O
(	O
fde	struct
,	O
1	int
)	O
;	O
}	O
if	O
(	O
fde	struct
->	O
end_address	pointer
==	O
NULL	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"open CFI at the end of file; "	pointer
"missing .cfi_endproc directive"	pointer
)	O
)	O
;	O
fde	struct
->	O
end_address	pointer
=	O
fde	struct
->	O
start_address	long
;	O
}	O
fde	struct
->	O
per_encoding	char
=	O
DW_EH_PE_omit	int
;	O
fde	struct
->	O
lsda_encoding	int
=	O
DW_EH_PE_omit	int
;	O
cfi_change_reg_numbers	O
(	O
fde	struct
->	O
data	pointer
,	O
ccseg	pointer
)	O
;	O
cie	struct
=	O
select_cie_for_fde	function
(	O
fde	struct
,	O
FALSE	int
,	O
&	O
first	pointer
,	O
alignment	int
)	O
;	O
output_fde	function
(	O
fde	struct
,	O
cie	struct
,	O
FALSE	int
,	O
first	pointer
,	O
alignment	int
)	O
;	O
}	O
}	O
while	O
(	O
SUPPORT_FRAME_LINKONCE	int
&&	O
seek_next_seg	int
==	O
2	int
)	O
;	O
if	O
(	O
SUPPORT_FRAME_LINKONCE	int
)	O
for	O
(	O
fde	struct
=	O
all_fde_data	pointer
;	O
fde	struct
;	O
fde	struct
=	O
fde	struct
->	O
next	pointer
)	O
SET_HANDLED	O
(	O
fde	struct
,	O
0	int
)	O
;	O
}	O
}	O
