struct	O
limits_rec	struct
{	O
unsigned	O
set	int
;	O
rlim_t	long
limit_as	long
;	O
rlim_t	long
limit_cpu	long
;	O
rlim_t	long
limit_data	long
;	O
rlim_t	long
limit_fsize	long
;	O
rlim_t	long
limit_nproc	long
;	O
rlim_t	long
limit_core	long
;	O
rlim_t	long
limit_memlock	long
;	O
rlim_t	long
limit_nofile	long
;	O
rlim_t	long
limit_rss	long
;	O
rlim_t	long
limit_stack	long
;	O
size_t	long
limit_logins	long
;	O
int	O
limit_prio	int
;	O
}	O
;	O
int	O
do_set_limit	function
(	O
int	O
rlimit	struct
,	O
rlim_t	long
limit	long
)	O
{	O
struct	O
rlimit	struct
rlim	struct
;	O
debug	O
(	O
2	int
,	O
_	O
(	O
"Setting limit %d to %lu"	pointer
)	O
,	O
rlimit	struct
,	O
(	O
unsigned	O
long	O
)	O
limit	long
)	O
;	O
rlim	struct
.	O
rlim_cur	long
=	O
limit	long
;	O
rlim	struct
.	O
rlim_max	long
=	O
limit	long
;	O
if	O
(	O
setrlimit	function
(	O
rlimit	struct
,	O
&	O
rlim	struct
)	O
)	O
{	O
logmsg	function
(	O
LOG_NOTICE	int
,	O
_	O
(	O
"error setting limit: %s"	pointer
)	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
set_prio	function
(	O
int	O
prio	int
)	O
{	O
debug	O
(	O
2	int
,	O
_	O
(	O
"Setting priority to %d"	pointer
)	O
,	O
prio	int
)	O
;	O
if	O
(	O
setpriority	function
(	O
PRIO_PROCESS	int
,	O
0	int
,	O
prio	int
)	O
)	O
{	O
logmsg	function
(	O
LOG_NOTICE	int
,	O
_	O
(	O
"error setting priority: %s"	pointer
)	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
check_logins	function
(	O
const	O
char	O
*	O
name	pointer
,	O
size_t	long
limit	long
)	O
{	O
size_t	long
count	long
=	O
0	int
;	O
struct	O
rush_wtmp	struct
*	O
wtmp	pointer
=	O
0	int
;	O
int	O
status	int
;	O
if	O
(	O
limit	long
==	O
0	int
)	O
{	O
debug	O
(	O
2	int
,	O
_	O
(	O
"No logins allowed for `%s'"	pointer
)	O
,	O
name	pointer
)	O
;	O
logmsg	function
(	O
LOG_ERR	int
,	O
_	O
(	O
"No logins allowed for `%s'"	pointer
)	O
,	O
name	pointer
)	O
;	O
return	O
1	int
;	O
}	O
debug	O
(	O
3	int
,	O
_	O
(	O
"counting logins for %s"	pointer
)	O
,	O
name	pointer
)	O
;	O
switch	O
(	O
rushdb_open	function
(	O
RUSH_DB	O
,	O
0	int
)	O
)	O
{	O
case	O
rushdb_result_ok	int
:	O
break	O
;	O
case	O
rushdb_result_eof	int
:	O
debug	O
(	O
3	int
,	O
"%s"	pointer
,	O
_	O
(	O
"acct database is empty"	pointer
)	O
)	O
;	O
return	O
0	int
;	O
case	O
rushdb_result_fail	int
:	O
logmsg	function
(	O
LOG_ERR	int
,	O
_	O
(	O
"Cannot open database %s: %s"	pointer
)	O
,	O
RUSH_DB	O
,	O
rushdb_error_string	pointer
)	O
;	O
return	O
0	int
;	O
}	O
while	O
(	O
rush_utmp_read	function
(	O
RUSH_STATUS_MAP_BIT	O
(	O
RUSH_STATUS_INUSE	int
)	O
,	O
&	O
status	int
,	O
&	O
wtmp	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
strcmp	function
(	O
wtmp	pointer
->	O
user	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
++	O
count	long
>=	O
limit	long
)	O
break	O
;	O
}	O
free	function
(	O
wtmp	pointer
)	O
;	O
wtmp	pointer
=	O
NULL	O
;	O
}	O
free	function
(	O
wtmp	pointer
)	O
;	O
rushdb_close	function
(	O
)	O
;	O
debug	O
(	O
3	int
,	O
_	O
(	O
"counted %zu/%zu logins for %s"	pointer
)	O
,	O
count	long
,	O
limit	long
,	O
name	pointer
)	O
;	O
if	O
(	O
count	long
>=	O
limit	long
)	O
{	O
debug	O
(	O
2	int
,	O
_	O
(	O
"Too many logins (max %zu) for %s"	pointer
)	O
,	O
limit	long
,	O
name	pointer
)	O
;	O
logmsg	function
(	O
LOG_ERR	int
,	O
_	O
(	O
"Too many logins (max %zu) for %s"	pointer
)	O
,	O
limit	long
,	O
name	pointer
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
set_user_limits	function
(	O
const	O
char	O
*	O
name	pointer
,	O
struct	O
limits_rec	struct
*	O
lrec	pointer
)	O
{	O
int	O
rc	int
=	O
0	int
;	O
if	O
(	O
!	O
lrec	pointer
)	O
return	O
0	int
;	O
debug	O
(	O
2	int
,	O
_	O
(	O
"Setting limits for %s"	pointer
)	O
,	O
name	pointer
)	O
;	O
if	O
(	O
lrec	pointer
->	O
set	int
&	O
SET_LIMIT_AS	int
)	O
rc	int
|=	O
do_set_limit	function
(	O
RLIMIT_AS	int
,	O
lrec	pointer
->	O
limit_as	long
)	O
;	O
if	O
(	O
lrec	pointer
->	O
set	int
&	O
SET_LIMIT_CPU	int
)	O
rc	int
|=	O
do_set_limit	function
(	O
RLIMIT_CPU	int
,	O
lrec	pointer
->	O
limit_cpu	long
)	O
;	O
if	O
(	O
lrec	pointer
->	O
set	int
&	O
SET_LIMIT_DATA	int
)	O
rc	int
|=	O
do_set_limit	function
(	O
RLIMIT_DATA	int
,	O
lrec	pointer
->	O
limit_data	long
)	O
;	O
if	O
(	O
lrec	pointer
->	O
set	int
&	O
SET_LIMIT_FSIZE	int
)	O
rc	int
|=	O
do_set_limit	function
(	O
RLIMIT_FSIZE	int
,	O
lrec	pointer
->	O
limit_fsize	long
)	O
;	O
if	O
(	O
lrec	pointer
->	O
set	int
&	O
SET_LIMIT_NPROC	int
)	O
rc	int
|=	O
do_set_limit	function
(	O
RLIMIT_NPROC	O
,	O
lrec	pointer
->	O
limit_nproc	long
)	O
;	O
if	O
(	O
lrec	pointer
->	O
set	int
&	O
SET_LIMIT_CORE	int
)	O
rc	int
|=	O
do_set_limit	function
(	O
RLIMIT_CORE	int
,	O
lrec	pointer
->	O
limit_core	long
)	O
;	O
if	O
(	O
lrec	pointer
->	O
set	int
&	O
SET_LIMIT_MEMLOCK	int
)	O
rc	int
|=	O
do_set_limit	function
(	O
RLIMIT_MEMLOCK	O
,	O
lrec	pointer
->	O
limit_memlock	long
)	O
;	O
if	O
(	O
lrec	pointer
->	O
set	int
&	O
SET_LIMIT_NOFILE	int
)	O
rc	int
|=	O
do_set_limit	function
(	O
RLIMIT_NOFILE	int
,	O
lrec	pointer
->	O
limit_nofile	long
)	O
;	O
if	O
(	O
lrec	pointer
->	O
set	int
&	O
SET_LIMIT_RSS	int
)	O
rc	int
|=	O
do_set_limit	function
(	O
RLIMIT_RSS	O
,	O
lrec	pointer
->	O
limit_rss	long
)	O
;	O
if	O
(	O
lrec	pointer
->	O
set	int
&	O
SET_LIMIT_STACK	int
)	O
rc	int
|=	O
do_set_limit	function
(	O
RLIMIT_STACK	int
,	O
lrec	pointer
->	O
limit_stack	long
)	O
;	O
if	O
(	O
lrec	pointer
->	O
set	int
&	O
SET_LIMIT_LOGINS	int
)	O
rc	int
|=	O
check_logins	function
(	O
name	pointer
,	O
lrec	pointer
->	O
limit_logins	long
)	O
;	O
if	O
(	O
lrec	pointer
->	O
set	int
&	O
SET_LIMIT_PRIO	int
)	O
rc	int
|=	O
set_prio	function
(	O
lrec	pointer
->	O
limit_prio	int
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
getlimit	function
(	O
char	O
*	O
*	O
ptr	pointer
,	O
rlim_t	long
*	O
rlim	struct
,	O
int	O
mul	int
)	O
{	O
unsigned	O
long	O
val	array
;	O
val	array
=	O
strtoul	function
(	O
*	O
ptr	pointer
,	O
ptr	pointer
,	O
10	int
)	O
;	O
if	O
(	O
val	array
==	O
0	int
)	O
return	O
1	int
;	O
*	O
rlim	struct
=	O
val	array
*	O
mul	int
;	O
return	O
0	int
;	O
}	O
limits_record_t	pointer
limits_record_create	function
(	O
void	O
)	O
{	O
struct	O
limits_rec	struct
*	O
lrec	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
*	O
lrec	pointer
)	O
)	O
;	O
lrec	pointer
->	O
set	int
=	O
0	int
;	O
return	O
lrec	pointer
;	O
}	O
int	O
limits_record_add	function
(	O
limits_record_t	pointer
lrec	pointer
,	O
char	O
*	O
str	pointer
,	O
char	O
*	O
*	O
endp	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
switch	O
(	O
*	O
str	pointer
++	O
)	O
{	O
case	O
'a'	O
:	O
case	O
'A'	O
:	O
if	O
(	O
getlimit	function
(	O
&	O
str	pointer
,	O
&	O
lrec	pointer
->	O
limit_as	long
,	O
1024	int
)	O
)	O
{	O
*	O
endp	pointer
=	O
str	pointer
;	O
return	O
lrec_badval	int
;	O
}	O
lrec	pointer
->	O
set	int
|=	O
SET_LIMIT_AS	int
;	O
break	O
;	O
case	O
't'	O
:	O
case	O
'T'	O
:	O
if	O
(	O
getlimit	function
(	O
&	O
str	pointer
,	O
&	O
lrec	pointer
->	O
limit_cpu	long
,	O
60	int
)	O
)	O
{	O
*	O
endp	pointer
=	O
str	pointer
;	O
return	O
lrec_badval	int
;	O
}	O
lrec	pointer
->	O
set	int
|=	O
SET_LIMIT_CPU	int
;	O
break	O
;	O
case	O
'd'	O
:	O
case	O
'D'	O
:	O
if	O
(	O
getlimit	function
(	O
&	O
str	pointer
,	O
&	O
lrec	pointer
->	O
limit_data	long
,	O
1024	int
)	O
)	O
{	O
*	O
endp	pointer
=	O
str	pointer
;	O
return	O
lrec_badval	int
;	O
}	O
lrec	pointer
->	O
set	int
|=	O
SET_LIMIT_DATA	int
;	O
break	O
;	O
case	O
'f'	O
:	O
case	O
'F'	O
:	O
if	O
(	O
getlimit	function
(	O
&	O
str	pointer
,	O
&	O
lrec	pointer
->	O
limit_fsize	long
,	O
1024	int
)	O
)	O
{	O
*	O
endp	pointer
=	O
str	pointer
;	O
return	O
lrec_badval	int
;	O
}	O
lrec	pointer
->	O
set	int
|=	O
SET_LIMIT_FSIZE	int
;	O
break	O
;	O
case	O
'u'	O
:	O
case	O
'U'	O
:	O
if	O
(	O
getlimit	function
(	O
&	O
str	pointer
,	O
&	O
lrec	pointer
->	O
limit_nproc	long
,	O
1	int
)	O
)	O
{	O
*	O
endp	pointer
=	O
str	pointer
;	O
return	O
lrec_badval	int
;	O
}	O
lrec	pointer
->	O
set	int
|=	O
SET_LIMIT_NPROC	int
;	O
break	O
;	O
case	O
'c'	O
:	O
case	O
'C'	O
:	O
if	O
(	O
getlimit	function
(	O
&	O
str	pointer
,	O
&	O
lrec	pointer
->	O
limit_core	long
,	O
1024	int
)	O
)	O
{	O
*	O
endp	pointer
=	O
str	pointer
;	O
return	O
lrec_badval	int
;	O
}	O
lrec	pointer
->	O
set	int
|=	O
SET_LIMIT_CORE	int
;	O
break	O
;	O
case	O
'm'	O
:	O
case	O
'M'	O
:	O
if	O
(	O
getlimit	function
(	O
&	O
str	pointer
,	O
&	O
lrec	pointer
->	O
limit_memlock	long
,	O
1024	int
)	O
)	O
{	O
*	O
endp	pointer
=	O
str	pointer
;	O
return	O
lrec_badval	int
;	O
}	O
lrec	pointer
->	O
set	int
|=	O
SET_LIMIT_MEMLOCK	int
;	O
break	O
;	O
case	O
'n'	O
:	O
case	O
'N'	O
:	O
if	O
(	O
getlimit	function
(	O
&	O
str	pointer
,	O
&	O
lrec	pointer
->	O
limit_nofile	long
,	O
1	int
)	O
)	O
{	O
*	O
endp	pointer
=	O
str	pointer
;	O
return	O
lrec_badval	int
;	O
}	O
lrec	pointer
->	O
set	int
|=	O
SET_LIMIT_NOFILE	int
;	O
break	O
;	O
case	O
'r'	O
:	O
case	O
'R'	O
:	O
if	O
(	O
getlimit	function
(	O
&	O
str	pointer
,	O
&	O
lrec	pointer
->	O
limit_rss	long
,	O
1024	int
)	O
)	O
{	O
*	O
endp	pointer
=	O
str	pointer
;	O
return	O
lrec_badval	int
;	O
}	O
lrec	pointer
->	O
set	int
|=	O
SET_LIMIT_RSS	int
;	O
break	O
;	O
case	O
's'	O
:	O
case	O
'S'	O
:	O
if	O
(	O
getlimit	function
(	O
&	O
str	pointer
,	O
&	O
lrec	pointer
->	O
limit_stack	long
,	O
1024	int
)	O
)	O
{	O
*	O
endp	pointer
=	O
str	pointer
;	O
return	O
lrec_badval	int
;	O
}	O
lrec	pointer
->	O
set	int
|=	O
SET_LIMIT_STACK	int
;	O
break	O
;	O
case	O
'l'	O
:	O
case	O
'L'	O
:	O
lrec	pointer
->	O
limit_logins	long
=	O
strtoul	function
(	O
str	pointer
,	O
&	O
p	pointer
,	O
10	int
)	O
;	O
if	O
(	O
p	pointer
==	O
str	pointer
)	O
{	O
*	O
endp	pointer
=	O
p	pointer
;	O
return	O
lrec_badval	int
;	O
}	O
lrec	pointer
->	O
set	int
|=	O
SET_LIMIT_LOGINS	int
;	O
break	O
;	O
case	O
'p'	O
:	O
case	O
'P'	O
:	O
lrec	pointer
->	O
limit_prio	int
=	O
strtol	function
(	O
str	pointer
,	O
&	O
p	pointer
,	O
10	int
)	O
;	O
if	O
(	O
p	pointer
==	O
str	pointer
)	O
{	O
*	O
endp	pointer
=	O
p	pointer
;	O
return	O
lrec_badval	int
;	O
}	O
if	O
(	O
lrec	pointer
->	O
limit_prio	int
>	O
0	int
)	O
lrec	pointer
->	O
set	int
|=	O
SET_LIMIT_PRIO	int
;	O
break	O
;	O
default	O
:	O
*	O
endp	pointer
=	O
str	pointer
-	O
1	int
;	O
return	O
lrec_error	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
parse_limits	function
(	O
limits_record_t	pointer
*	O
plrec	pointer
,	O
char	O
*	O
str	pointer
,	O
char	O
*	O
*	O
endp	pointer
)	O
{	O
int	O
c	int
;	O
struct	O
limits_rec	struct
*	O
lrec	pointer
=	O
limits_record_create	function
(	O
)	O
;	O
int	O
rc	int
;	O
while	O
(	O
(	O
c	int
=	O
*	O
str	pointer
++	O
)	O
)	O
{	O
if	O
(	O
ISWS	O
(	O
c	int
)	O
)	O
continue	O
;	O
rc	int
=	O
limits_record_add	function
(	O
lrec	pointer
,	O
str	pointer
,	O
endp	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
free	function
(	O
lrec	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
}	O
*	O
plrec	pointer
=	O
lrec	pointer
;	O
return	O
0	int
;	O
}	O
