static	O
int	O
arg_int	function
(	O
const	O
char	O
*	O
str	pointer
)	O
{	O
char	O
*	O
endp	pointer
;	O
long	O
value	bool
;	O
size_t	long
len	long
=	O
strlen	function
(	O
str	pointer
)	O
;	O
if	O
(	O
!	O
len	long
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
_	O
(	O
"empty string treated as 0"	pointer
)	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
errno	O
=	O
0	int
;	O
value	bool
=	O
strtol	function
(	O
str	pointer
,	O
&	O
endp	pointer
,	O
10	int
)	O
;	O
if	O
(	O
endp	pointer
-	O
str	pointer
-	O
len	long
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
_	O
(	O
"non-numeric argument %s"	pointer
)	O
,	O
str	pointer
)	O
)	O
;	O
else	O
if	O
(	O
isspace	function
(	O
to_uchar	O
(	O
*	O
str	pointer
)	O
)	O
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
_	O
(	O
"leading whitespace ignored"	pointer
)	O
)	O
)	O
;	O
else	O
if	O
(	O
errno	O
==	O
ERANGE	int
||	O
(	O
int	O
)	O
value	bool
!=	O
value	bool
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
_	O
(	O
"numeric overflow detected"	pointer
)	O
)	O
)	O
;	O
return	O
value	bool
;	O
}	O
static	O
long	O
arg_long	function
(	O
const	O
char	O
*	O
str	pointer
)	O
{	O
char	O
*	O
endp	pointer
;	O
long	O
value	bool
;	O
size_t	long
len	long
=	O
strlen	function
(	O
str	pointer
)	O
;	O
if	O
(	O
!	O
len	long
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
_	O
(	O
"empty string treated as 0"	pointer
)	O
)	O
)	O
;	O
return	O
0L	int
;	O
}	O
errno	O
=	O
0	int
;	O
value	bool
=	O
strtol	function
(	O
str	pointer
,	O
&	O
endp	pointer
,	O
10	int
)	O
;	O
if	O
(	O
endp	pointer
-	O
str	pointer
-	O
len	long
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
_	O
(	O
"non-numeric argument %s"	pointer
)	O
,	O
str	pointer
)	O
)	O
;	O
else	O
if	O
(	O
isspace	function
(	O
to_uchar	O
(	O
*	O
str	pointer
)	O
)	O
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
_	O
(	O
"leading whitespace ignored"	pointer
)	O
)	O
)	O
;	O
else	O
if	O
(	O
errno	O
==	O
ERANGE	int
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
_	O
(	O
"numeric overflow detected"	pointer
)	O
)	O
)	O
;	O
return	O
value	bool
;	O
}	O
static	O
double	O
arg_double	function
(	O
const	O
char	O
*	O
str	pointer
)	O
{	O
char	O
*	O
endp	pointer
;	O
double	O
value	bool
;	O
size_t	long
len	long
=	O
strlen	function
(	O
str	pointer
)	O
;	O
if	O
(	O
!	O
len	long
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
_	O
(	O
"empty string treated as 0"	pointer
)	O
)	O
)	O
;	O
return	O
0.0	int
;	O
}	O
errno	O
=	O
0	int
;	O
value	bool
=	O
strtod	function
(	O
str	pointer
,	O
&	O
endp	pointer
)	O
;	O
if	O
(	O
endp	pointer
-	O
str	pointer
-	O
len	long
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
_	O
(	O
"non-numeric argument %s"	pointer
)	O
,	O
str	pointer
)	O
)	O
;	O
else	O
if	O
(	O
isspace	function
(	O
to_uchar	O
(	O
*	O
str	pointer
)	O
)	O
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
_	O
(	O
"leading whitespace ignored"	pointer
)	O
)	O
)	O
;	O
else	O
if	O
(	O
errno	O
==	O
ERANGE	int
)	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
_	O
(	O
"numeric overflow detected"	pointer
)	O
)	O
)	O
;	O
return	O
value	bool
;	O
}	O
void	O
expand_format	function
(	O
struct	O
obstack	struct
*	O
obs	pointer
,	O
int	O
argc	int
,	O
token_data	struct
*	O
*	O
argv	pointer
)	O
{	O
const	O
char	O
*	O
f	pointer
;	O
const	O
char	O
*	O
fmt	pointer
;	O
char	O
fstart	array
[	O
]	O
=	O
"%'+- 0#*.*hhd"	pointer
;	O
char	O
*	O
p	pointer
;	O
unsigned	O
char	O
c	char
;	O
char	O
flags	int
;	O
enum	O
{	O
THOUSANDS	int
=	O
0x01	int
,	O
PLUS	int
=	O
0x02	int
,	O
MINUS	int
=	O
0x04	int
,	O
SPACE	int
=	O
0x08	int
,	O
ZERO	int
=	O
0x10	int
,	O
ALT	int
=	O
0x20	int
,	O
DONE	int
=	O
0x40	int
}	O
;	O
int	O
width	int
;	O
int	O
prec	int
;	O
char	O
lflag	char
;	O
char	O
ok	array
[	O
128	int
]	O
;	O
char	O
*	O
str	pointer
;	O
enum	O
{	O
CHAR	int
,	O
INT	int
,	O
LONG	int
,	O
DOUBLE	int
,	O
STR	int
}	O
datatype	enum
;	O
f	pointer
=	O
fmt	pointer
=	O
ARG_STR	O
(	O
argc	int
,	O
argv	pointer
)	O
;	O
memset	function
(	O
ok	array
,	O
0	int
,	O
sizeof	O
ok	array
)	O
;	O
while	O
(	O
1	int
)	O
{	O
const	O
char	O
*	O
percent	pointer
=	O
strchr	function
(	O
fmt	pointer
,	O
'%'	O
)	O
;	O
if	O
(	O
!	O
percent	pointer
)	O
{	O
obstack_grow	O
(	O
obs	pointer
,	O
fmt	pointer
,	O
strlen	function
(	O
fmt	pointer
)	O
)	O
;	O
return	O
;	O
}	O
obstack_grow	O
(	O
obs	pointer
,	O
fmt	pointer
,	O
percent	pointer
-	O
fmt	pointer
)	O
;	O
fmt	pointer
=	O
percent	pointer
+	O
1	int
;	O
if	O
(	O
*	O
fmt	pointer
==	O
'%'	O
)	O
{	O
obstack_1grow	O
(	O
obs	pointer
,	O
'%'	O
)	O
;	O
fmt	pointer
++	O
;	O
continue	O
;	O
}	O
p	pointer
=	O
fstart	array
+	O
1	int
;	O
lflag	char
=	O
0	int
;	O
ok	array
[	O
'a'	O
]	O
=	O
ok	array
[	O
'A'	O
]	O
=	O
ok	array
[	O
'c'	O
]	O
=	O
ok	array
[	O
'd'	O
]	O
=	O
ok	array
[	O
'e'	O
]	O
=	O
ok	array
[	O
'E'	O
]	O
=	O
ok	array
[	O
'f'	O
]	O
=	O
ok	array
[	O
'F'	O
]	O
=	O
ok	array
[	O
'g'	O
]	O
=	O
ok	array
[	O
'G'	O
]	O
=	O
ok	array
[	O
'i'	O
]	O
=	O
ok	array
[	O
'o'	O
]	O
=	O
ok	array
[	O
's'	O
]	O
=	O
ok	array
[	O
'u'	O
]	O
=	O
ok	array
[	O
'x'	O
]	O
=	O
ok	array
[	O
'X'	O
]	O
=	O
1	int
;	O
flags	int
=	O
0	int
;	O
do	O
{	O
switch	O
(	O
*	O
fmt	pointer
)	O
{	O
case	O
'\''	O
:	O
ok	array
[	O
'a'	O
]	O
=	O
ok	array
[	O
'A'	O
]	O
=	O
ok	array
[	O
'c'	O
]	O
=	O
ok	array
[	O
'e'	O
]	O
=	O
ok	array
[	O
'E'	O
]	O
=	O
ok	array
[	O
'o'	O
]	O
=	O
ok	array
[	O
's'	O
]	O
=	O
ok	array
[	O
'x'	O
]	O
=	O
ok	array
[	O
'X'	O
]	O
=	O
0	int
;	O
flags	int
|=	O
THOUSANDS	int
;	O
break	O
;	O
case	O
'+'	O
:	O
ok	array
[	O
'c'	O
]	O
=	O
ok	array
[	O
'o'	O
]	O
=	O
ok	array
[	O
's'	O
]	O
=	O
ok	array
[	O
'u'	O
]	O
=	O
ok	array
[	O
'x'	O
]	O
=	O
ok	array
[	O
'X'	O
]	O
=	O
0	int
;	O
flags	int
|=	O
PLUS	int
;	O
break	O
;	O
case	O
' '	O
:	O
ok	array
[	O
'c'	O
]	O
=	O
ok	array
[	O
'o'	O
]	O
=	O
ok	array
[	O
's'	O
]	O
=	O
ok	array
[	O
'u'	O
]	O
=	O
ok	array
[	O
'x'	O
]	O
=	O
ok	array
[	O
'X'	O
]	O
=	O
0	int
;	O
flags	int
|=	O
SPACE	int
;	O
break	O
;	O
case	O
'0'	O
:	O
ok	array
[	O
'c'	O
]	O
=	O
ok	array
[	O
's'	O
]	O
=	O
0	int
;	O
flags	int
|=	O
ZERO	int
;	O
break	O
;	O
case	O
'#'	O
:	O
ok	array
[	O
'c'	O
]	O
=	O
ok	array
[	O
'd'	O
]	O
=	O
ok	array
[	O
'i'	O
]	O
=	O
ok	array
[	O
's'	O
]	O
=	O
ok	array
[	O
'u'	O
]	O
=	O
0	int
;	O
flags	int
|=	O
ALT	int
;	O
break	O
;	O
case	O
'-'	O
:	O
flags	int
|=	O
MINUS	int
;	O
break	O
;	O
default	O
:	O
flags	int
|=	O
DONE	int
;	O
break	O
;	O
}	O
}	O
while	O
(	O
!	O
(	O
flags	int
&	O
DONE	int
)	O
&&	O
fmt	pointer
++	O
)	O
;	O
if	O
(	O
flags	int
&	O
THOUSANDS	int
)	O
*	O
p	pointer
++	O
=	O
'\''	O
;	O
if	O
(	O
flags	int
&	O
PLUS	int
)	O
*	O
p	pointer
++	O
=	O
'+'	O
;	O
if	O
(	O
flags	int
&	O
MINUS	int
)	O
*	O
p	pointer
++	O
=	O
'-'	O
;	O
if	O
(	O
flags	int
&	O
SPACE	int
)	O
*	O
p	pointer
++	O
=	O
' '	O
;	O
if	O
(	O
flags	int
&	O
ZERO	int
)	O
*	O
p	pointer
++	O
=	O
'0'	O
;	O
if	O
(	O
flags	int
&	O
ALT	int
)	O
*	O
p	pointer
++	O
=	O
'#'	O
;	O
width	int
=	O
0	int
;	O
*	O
p	pointer
++	O
=	O
'*'	O
;	O
if	O
(	O
*	O
fmt	pointer
==	O
'*'	O
)	O
{	O
width	int
=	O
ARG_INT	O
(	O
argc	int
,	O
argv	pointer
)	O
;	O
fmt	pointer
++	O
;	O
}	O
else	O
while	O
(	O
isdigit	function
(	O
to_uchar	O
(	O
*	O
fmt	pointer
)	O
)	O
)	O
{	O
width	int
=	O
10	int
*	O
width	int
+	O
*	O
fmt	pointer
-	O
'0'	O
;	O
fmt	pointer
++	O
;	O
}	O
prec	int
=	O
-	O
1	int
;	O
*	O
p	pointer
++	O
=	O
'.'	O
;	O
*	O
p	pointer
++	O
=	O
'*'	O
;	O
if	O
(	O
*	O
fmt	pointer
==	O
'.'	O
)	O
{	O
ok	array
[	O
'c'	O
]	O
=	O
0	int
;	O
if	O
(	O
*	O
(	O
++	O
fmt	pointer
)	O
==	O
'*'	O
)	O
{	O
prec	int
=	O
ARG_INT	O
(	O
argc	int
,	O
argv	pointer
)	O
;	O
++	O
fmt	pointer
;	O
}	O
else	O
{	O
prec	int
=	O
0	int
;	O
while	O
(	O
isdigit	function
(	O
to_uchar	O
(	O
*	O
fmt	pointer
)	O
)	O
)	O
{	O
prec	int
=	O
10	int
*	O
prec	int
+	O
*	O
fmt	pointer
-	O
'0'	O
;	O
fmt	pointer
++	O
;	O
}	O
}	O
}	O
if	O
(	O
*	O
fmt	pointer
==	O
'l'	O
)	O
{	O
*	O
p	pointer
++	O
=	O
'l'	O
;	O
lflag	char
=	O
1	int
;	O
fmt	pointer
++	O
;	O
ok	array
[	O
'c'	O
]	O
=	O
ok	array
[	O
's'	O
]	O
=	O
0	int
;	O
}	O
else	O
if	O
(	O
*	O
fmt	pointer
==	O
'h'	O
)	O
{	O
*	O
p	pointer
++	O
=	O
'h'	O
;	O
fmt	pointer
++	O
;	O
if	O
(	O
*	O
fmt	pointer
==	O
'h'	O
)	O
{	O
*	O
p	pointer
++	O
=	O
'h'	O
;	O
fmt	pointer
++	O
;	O
}	O
ok	array
[	O
'a'	O
]	O
=	O
ok	array
[	O
'A'	O
]	O
=	O
ok	array
[	O
'c'	O
]	O
=	O
ok	array
[	O
'e'	O
]	O
=	O
ok	array
[	O
'E'	O
]	O
=	O
ok	array
[	O
'f'	O
]	O
=	O
ok	array
[	O
'F'	O
]	O
=	O
ok	array
[	O
'g'	O
]	O
=	O
ok	array
[	O
'G'	O
]	O
=	O
ok	array
[	O
's'	O
]	O
=	O
0	int
;	O
}	O
c	char
=	O
*	O
fmt	pointer
++	O
;	O
if	O
(	O
sizeof	O
ok	array
<=	O
c	char
||	O
!	O
ok	array
[	O
c	char
]	O
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"Warning: unrecognized specifier in `%s'"	pointer
,	O
f	pointer
)	O
)	O
;	O
if	O
(	O
c	char
==	O
'\0'	O
)	O
fmt	pointer
--	O
;	O
continue	O
;	O
}	O
switch	O
(	O
c	char
)	O
{	O
case	O
'c'	O
:	O
datatype	enum
=	O
CHAR	int
;	O
p	pointer
-=	O
2	int
;	O
break	O
;	O
case	O
's'	O
:	O
datatype	enum
=	O
STR	int
;	O
break	O
;	O
case	O
'd'	O
:	O
case	O
'i'	O
:	O
case	O
'o'	O
:	O
case	O
'x'	O
:	O
case	O
'X'	O
:	O
case	O
'u'	O
:	O
datatype	enum
=	O
lflag	char
?	O
LONG	int
:	O
INT	int
;	O
break	O
;	O
case	O
'a'	O
:	O
case	O
'A'	O
:	O
case	O
'e'	O
:	O
case	O
'E'	O
:	O
case	O
'f'	O
:	O
case	O
'F'	O
:	O
case	O
'g'	O
:	O
case	O
'G'	O
:	O
datatype	enum
=	O
DOUBLE	int
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
*	O
p	pointer
++	O
=	O
c	char
;	O
*	O
p	pointer
=	O
'\0'	O
;	O
switch	O
(	O
datatype	enum
)	O
{	O
case	O
CHAR	int
:	O
str	pointer
=	O
xasprintf	function
(	O
fstart	array
,	O
width	int
,	O
ARG_INT	O
(	O
argc	int
,	O
argv	pointer
)	O
)	O
;	O
break	O
;	O
case	O
INT	int
:	O
str	pointer
=	O
xasprintf	function
(	O
fstart	array
,	O
width	int
,	O
prec	int
,	O
ARG_INT	O
(	O
argc	int
,	O
argv	pointer
)	O
)	O
;	O
break	O
;	O
case	O
LONG	int
:	O
str	pointer
=	O
xasprintf	function
(	O
fstart	array
,	O
width	int
,	O
prec	int
,	O
ARG_LONG	O
(	O
argc	int
,	O
argv	pointer
)	O
)	O
;	O
break	O
;	O
case	O
DOUBLE	int
:	O
str	pointer
=	O
xasprintf	function
(	O
fstart	array
,	O
width	int
,	O
prec	int
,	O
ARG_DOUBLE	O
(	O
argc	int
,	O
argv	pointer
)	O
)	O
;	O
break	O
;	O
case	O
STR	int
:	O
str	pointer
=	O
xasprintf	function
(	O
fstart	array
,	O
width	int
,	O
prec	int
,	O
ARG_STR	O
(	O
argc	int
,	O
argv	pointer
)	O
)	O
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
if	O
(	O
str	pointer
==	O
NULL	O
)	O
continue	O
;	O
obstack_grow	O
(	O
obs	pointer
,	O
str	pointer
,	O
strlen	function
(	O
str	pointer
)	O
)	O
;	O
free	function
(	O
str	pointer
)	O
;	O
}	O
}	O
