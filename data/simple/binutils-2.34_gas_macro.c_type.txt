struct	O
hash_control	O
*	O
macro_hash	pointer
;	O
int	O
macro_defined	int
;	O
static	O
int	O
macro_alternate	int
;	O
static	O
int	O
macro_mri	int
;	O
static	O
int	O
macro_strip_at	int
;	O
static	O
size_t	long
(	O
*	O
macro_expr	pointer
)	O
(	O
const	O
char	O
*	O
,	O
size_t	long
,	O
sb	pointer
*	O
,	O
offsetT	long
*	O
)	O
;	O
static	O
int	O
macro_number	int
;	O
void	O
macro_init	function
(	O
int	O
alternate	int
,	O
int	O
mri	int
,	O
int	O
strip_at	int
,	O
size_t	long
(	O
*	O
exp	pointer
)	O
(	O
const	O
char	O
*	O
,	O
size_t	long
,	O
sb	pointer
*	O
,	O
offsetT	long
*	O
)	O
)	O
{	O
macro_hash	pointer
=	O
hash_new	function
(	O
)	O
;	O
macro_defined	int
=	O
0	int
;	O
macro_alternate	int
=	O
alternate	int
;	O
macro_mri	int
=	O
mri	int
;	O
macro_strip_at	int
=	O
strip_at	int
;	O
macro_expr	pointer
=	O
exp	pointer
;	O
}	O
void	O
macro_set_alternate	function
(	O
int	O
alternate	int
)	O
{	O
macro_alternate	int
=	O
alternate	int
;	O
}	O
void	O
macro_mri_mode	function
(	O
int	O
mri	int
)	O
{	O
macro_mri	int
=	O
mri	int
;	O
}	O
int	O
buffer_and_nest	function
(	O
const	O
char	O
*	O
from	pointer
,	O
const	O
char	O
*	O
to	pointer
,	O
sb	pointer
*	O
ptr	pointer
,	O
size_t	long
(	O
*	O
get_line	pointer
)	O
(	O
sb	pointer
*	O
)	O
)	O
{	O
size_t	long
from_len	long
;	O
size_t	long
to_len	long
=	O
strlen	function
(	O
to	pointer
)	O
;	O
int	O
depth	int
=	O
1	int
;	O
size_t	long
line_start	long
=	O
ptr	pointer
->	O
len	long
;	O
size_t	long
more	long
=	O
get_line	pointer
(	O
ptr	pointer
)	O
;	O
if	O
(	O
to_len	long
==	O
4	int
&&	O
strcasecmp	function
(	O
to	pointer
,	O
"ENDR"	pointer
)	O
==	O
0	int
)	O
{	O
from	pointer
=	O
NULL	O
;	O
from_len	long
=	O
0	int
;	O
}	O
else	O
from_len	long
=	O
strlen	function
(	O
from	pointer
)	O
;	O
while	O
(	O
more	long
)	O
{	O
size_t	long
i	pointer
=	O
line_start	long
;	O
bfd_boolean	int
had_colon	int
=	O
FALSE	int
;	O
if	O
(	O
!	O
LABELS_WITHOUT_COLONS	int
)	O
{	O
while	O
(	O
i	pointer
<	O
ptr	pointer
->	O
len	long
&&	O
ISWHITE	O
(	O
ptr	pointer
->	O
ptr	pointer
[	O
i	pointer
]	O
)	O
)	O
i	pointer
++	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
i	pointer
>=	O
ptr	pointer
->	O
len	long
||	O
!	O
is_name_beginner	O
(	O
ptr	pointer
->	O
ptr	pointer
[	O
i	pointer
]	O
)	O
)	O
break	O
;	O
i	pointer
++	O
;	O
while	O
(	O
i	pointer
<	O
ptr	pointer
->	O
len	long
&&	O
is_part_of_name	O
(	O
ptr	pointer
->	O
ptr	pointer
[	O
i	pointer
]	O
)	O
)	O
i	pointer
++	O
;	O
if	O
(	O
i	pointer
<	O
ptr	pointer
->	O
len	long
&&	O
is_name_ender	O
(	O
ptr	pointer
->	O
ptr	pointer
[	O
i	pointer
]	O
)	O
)	O
i	pointer
++	O
;	O
while	O
(	O
i	pointer
<	O
ptr	pointer
->	O
len	long
&&	O
ISWHITE	O
(	O
ptr	pointer
->	O
ptr	pointer
[	O
i	pointer
]	O
)	O
)	O
i	pointer
++	O
;	O
if	O
(	O
i	pointer
>=	O
ptr	pointer
->	O
len	long
||	O
ptr	pointer
->	O
ptr	pointer
[	O
i	pointer
]	O
!=	O
':'	O
)	O
{	O
if	O
(	O
LABELS_WITHOUT_COLONS	int
&&	O
!	O
had_colon	int
)	O
break	O
;	O
i	pointer
=	O
line_start	long
;	O
break	O
;	O
}	O
i	pointer
++	O
;	O
line_start	long
=	O
i	pointer
;	O
had_colon	int
=	O
TRUE	int
;	O
}	O
while	O
(	O
i	pointer
<	O
ptr	pointer
->	O
len	long
&&	O
ISWHITE	O
(	O
ptr	pointer
->	O
ptr	pointer
[	O
i	pointer
]	O
)	O
)	O
i	pointer
++	O
;	O
if	O
(	O
i	pointer
<	O
ptr	pointer
->	O
len	long
&&	O
(	O
ptr	pointer
->	O
ptr	pointer
[	O
i	pointer
]	O
==	O
'.'	O
||	O
NO_PSEUDO_DOT	int
||	O
macro_mri	int
)	O
)	O
{	O
if	O
(	O
!	O
flag_m68k_mri	int
&&	O
ptr	pointer
->	O
ptr	pointer
[	O
i	pointer
]	O
==	O
'.'	O
)	O
i	pointer
++	O
;	O
if	O
(	O
from	pointer
==	O
NULL	O
&&	O
strncasecmp	function
(	O
ptr	pointer
->	O
ptr	pointer
+	O
i	pointer
,	O
"IRPC"	pointer
,	O
from_len	long
=	O
4	int
)	O
!=	O
0	int
&&	O
strncasecmp	function
(	O
ptr	pointer
->	O
ptr	pointer
+	O
i	pointer
,	O
"IRP"	pointer
,	O
from_len	long
=	O
3	int
)	O
!=	O
0	int
&&	O
strncasecmp	function
(	O
ptr	pointer
->	O
ptr	pointer
+	O
i	pointer
,	O
"IREPC"	pointer
,	O
from_len	long
=	O
5	int
)	O
!=	O
0	int
&&	O
strncasecmp	function
(	O
ptr	pointer
->	O
ptr	pointer
+	O
i	pointer
,	O
"IREP"	pointer
,	O
from_len	long
=	O
4	int
)	O
!=	O
0	int
&&	O
strncasecmp	function
(	O
ptr	pointer
->	O
ptr	pointer
+	O
i	pointer
,	O
"REPT"	pointer
,	O
from_len	long
=	O
4	int
)	O
!=	O
0	int
&&	O
strncasecmp	function
(	O
ptr	pointer
->	O
ptr	pointer
+	O
i	pointer
,	O
"REP"	pointer
,	O
from_len	long
=	O
3	int
)	O
!=	O
0	int
)	O
from_len	long
=	O
0	int
;	O
if	O
(	O
(	O
from	pointer
!=	O
NULL	O
?	O
strncasecmp	function
(	O
ptr	pointer
->	O
ptr	pointer
+	O
i	pointer
,	O
from	pointer
,	O
from_len	long
)	O
==	O
0	int
:	O
from_len	long
>	O
0	int
)	O
&&	O
(	O
ptr	pointer
->	O
len	long
==	O
(	O
i	pointer
+	O
from_len	long
)	O
||	O
!	O
(	O
is_part_of_name	O
(	O
ptr	pointer
->	O
ptr	pointer
[	O
i	pointer
+	O
from_len	long
]	O
)	O
||	O
is_name_ender	O
(	O
ptr	pointer
->	O
ptr	pointer
[	O
i	pointer
+	O
from_len	long
]	O
)	O
)	O
)	O
)	O
depth	int
++	O
;	O
if	O
(	O
strncasecmp	function
(	O
ptr	pointer
->	O
ptr	pointer
+	O
i	pointer
,	O
to	pointer
,	O
to_len	long
)	O
==	O
0	int
&&	O
(	O
ptr	pointer
->	O
len	long
==	O
(	O
i	pointer
+	O
to_len	long
)	O
||	O
!	O
(	O
is_part_of_name	O
(	O
ptr	pointer
->	O
ptr	pointer
[	O
i	pointer
+	O
to_len	long
]	O
)	O
||	O
is_name_ender	O
(	O
ptr	pointer
->	O
ptr	pointer
[	O
i	pointer
+	O
to_len	long
]	O
)	O
)	O
)	O
)	O
{	O
depth	int
--	O
;	O
if	O
(	O
depth	int
==	O
0	int
)	O
{	O
ptr	pointer
->	O
len	long
=	O
line_start	long
;	O
break	O
;	O
}	O
}	O
if	O
(	O
strncasecmp	function
(	O
ptr	pointer
->	O
ptr	pointer
+	O
i	pointer
,	O
"linefile"	pointer
,	O
8	int
)	O
==	O
0	int
)	O
{	O
char	O
saved_eol_char	char
=	O
ptr	pointer
->	O
ptr	pointer
[	O
ptr	pointer
->	O
len	long
]	O
;	O
ptr	pointer
->	O
ptr	pointer
[	O
ptr	pointer
->	O
len	long
]	O
=	O
'\0'	O
;	O
temp_ilp	function
(	O
ptr	pointer
->	O
ptr	pointer
+	O
i	pointer
+	O
8	int
)	O
;	O
s_app_line	function
(	O
0	int
)	O
;	O
restore_ilp	function
(	O
)	O
;	O
ptr	pointer
->	O
ptr	pointer
[	O
ptr	pointer
->	O
len	long
]	O
=	O
saved_eol_char	char
;	O
ptr	pointer
->	O
len	long
=	O
line_start	long
;	O
}	O
}	O
sb_add_char	function
(	O
ptr	pointer
,	O
more	long
)	O
;	O
line_start	long
=	O
ptr	pointer
->	O
len	long
;	O
more	long
=	O
get_line	pointer
(	O
ptr	pointer
)	O
;	O
}	O
return	O
depth	int
==	O
0	int
;	O
}	O
static	O
size_t	long
get_token	function
(	O
size_t	long
idx	int
,	O
sb	pointer
*	O
in	pointer
,	O
sb	pointer
*	O
name	pointer
)	O
{	O
if	O
(	O
idx	int
<	O
in	pointer
->	O
len	long
&&	O
is_name_beginner	O
(	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
)	O
)	O
{	O
sb_add_char	function
(	O
name	pointer
,	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
++	O
]	O
)	O
;	O
while	O
(	O
idx	int
<	O
in	pointer
->	O
len	long
&&	O
is_part_of_name	O
(	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
)	O
)	O
{	O
sb_add_char	function
(	O
name	pointer
,	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
++	O
]	O
)	O
;	O
}	O
if	O
(	O
idx	int
<	O
in	pointer
->	O
len	long
&&	O
is_name_ender	O
(	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
)	O
)	O
{	O
sb_add_char	function
(	O
name	pointer
,	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
++	O
]	O
)	O
;	O
}	O
}	O
if	O
(	O
macro_alternate	int
&&	O
idx	int
<	O
in	pointer
->	O
len	long
&&	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
==	O
'&'	O
)	O
idx	int
++	O
;	O
return	O
idx	int
;	O
}	O
static	O
size_t	long
getstring	function
(	O
size_t	long
idx	int
,	O
sb	pointer
*	O
in	pointer
,	O
sb	pointer
*	O
acc	pointer
)	O
{	O
while	O
(	O
idx	int
<	O
in	pointer
->	O
len	long
&&	O
(	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
==	O
'"'	O
||	O
(	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
==	O
'<'	O
&&	O
(	O
macro_alternate	int
||	O
macro_mri	int
)	O
)	O
||	O
(	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
==	O
'\''	O
&&	O
macro_alternate	int
)	O
)	O
)	O
{	O
if	O
(	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
==	O
'<'	O
)	O
{	O
int	O
nest	int
=	O
0	int
;	O
idx	int
++	O
;	O
while	O
(	O
idx	int
<	O
in	pointer
->	O
len	long
&&	O
(	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
!=	O
'>'	O
||	O
nest	int
)	O
)	O
{	O
if	O
(	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
==	O
'!'	O
)	O
{	O
idx	int
++	O
;	O
sb_add_char	function
(	O
acc	pointer
,	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
++	O
]	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
==	O
'>'	O
)	O
nest	int
--	O
;	O
if	O
(	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
==	O
'<'	O
)	O
nest	int
++	O
;	O
sb_add_char	function
(	O
acc	pointer
,	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
++	O
]	O
)	O
;	O
}	O
}	O
idx	int
++	O
;	O
}	O
else	O
if	O
(	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
==	O
'"'	O
||	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
==	O
'\''	O
)	O
{	O
char	O
tchar	char
=	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
;	O
int	O
escaped	int
=	O
0	int
;	O
idx	int
++	O
;	O
while	O
(	O
idx	int
<	O
in	pointer
->	O
len	long
)	O
{	O
if	O
(	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
-	O
1	int
]	O
==	O
'\\'	O
)	O
escaped	int
^=	O
1	int
;	O
else	O
escaped	int
=	O
0	int
;	O
if	O
(	O
macro_alternate	int
&&	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
==	O
'!'	O
)	O
{	O
idx	int
++	O
;	O
sb_add_char	function
(	O
acc	pointer
,	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
)	O
;	O
idx	int
++	O
;	O
}	O
else	O
if	O
(	O
escaped	int
&&	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
==	O
tchar	char
)	O
{	O
sb_add_char	function
(	O
acc	pointer
,	O
tchar	char
)	O
;	O
idx	int
++	O
;	O
}	O
else	O
{	O
if	O
(	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
==	O
tchar	char
)	O
{	O
idx	int
++	O
;	O
if	O
(	O
idx	int
>=	O
in	pointer
->	O
len	long
||	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
!=	O
tchar	char
)	O
break	O
;	O
}	O
sb_add_char	function
(	O
acc	pointer
,	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
)	O
;	O
idx	int
++	O
;	O
}	O
}	O
}	O
}	O
return	O
idx	int
;	O
}	O
static	O
size_t	long
get_any_string	function
(	O
size_t	long
idx	int
,	O
sb	pointer
*	O
in	pointer
,	O
sb	pointer
*	O
out	pointer
)	O
{	O
sb_reset	function
(	O
out	pointer
)	O
;	O
idx	int
=	O
sb_skip_white	function
(	O
idx	int
,	O
in	pointer
)	O
;	O
if	O
(	O
idx	int
<	O
in	pointer
->	O
len	long
)	O
{	O
if	O
(	O
in	pointer
->	O
len	long
>	O
idx	int
+	O
2	int
&&	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
+	O
1	int
]	O
==	O
'\''	O
&&	O
ISBASE	O
(	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
)	O
)	O
{	O
while	O
(	O
idx	int
<	O
in	pointer
->	O
len	long
&&	O
!	O
ISSEP	O
(	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
)	O
)	O
sb_add_char	function
(	O
out	pointer
,	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
++	O
]	O
)	O
;	O
}	O
else	O
if	O
(	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
==	O
'%'	O
&&	O
macro_alternate	int
)	O
{	O
offsetT	long
val	int
;	O
char	O
buf	pointer
[	O
64	int
]	O
;	O
idx	int
=	O
(	O
*	O
macro_expr	pointer
)	O
(	O
_	O
(	O
"% operator needs absolute expression"	pointer
)	O
,	O
idx	int
+	O
1	int
,	O
in	pointer
,	O
&	O
val	int
)	O
;	O
sprintf	function
(	O
buf	pointer
,	O
"%"	pointer
BFD_VMA_FMT	pointer
"d"	pointer
,	O
val	int
)	O
;	O
sb_add_string	function
(	O
out	pointer
,	O
buf	pointer
)	O
;	O
}	O
else	O
if	O
(	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
==	O
'"'	O
||	O
(	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
==	O
'<'	O
&&	O
(	O
macro_alternate	int
||	O
macro_mri	int
)	O
)	O
||	O
(	O
macro_alternate	int
&&	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
==	O
'\''	O
)	O
)	O
{	O
if	O
(	O
macro_alternate	int
&&	O
!	O
macro_strip_at	int
&&	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
!=	O
'<'	O
)	O
{	O
sb_add_char	function
(	O
out	pointer
,	O
'"'	O
)	O
;	O
idx	int
=	O
getstring	function
(	O
idx	int
,	O
in	pointer
,	O
out	pointer
)	O
;	O
sb_add_char	function
(	O
out	pointer
,	O
'"'	O
)	O
;	O
}	O
else	O
{	O
idx	int
=	O
getstring	function
(	O
idx	int
,	O
in	pointer
,	O
out	pointer
)	O
;	O
}	O
}	O
else	O
{	O
char	O
*	O
br_buf	pointer
=	O
XNEWVEC	O
(	O
char	O
,	O
1	int
)	O
;	O
char	O
*	O
in_br	pointer
=	O
br_buf	pointer
;	O
*	O
in_br	pointer
=	O
'\0'	O
;	O
while	O
(	O
idx	int
<	O
in	pointer
->	O
len	long
&&	O
(	O
*	O
in_br	pointer
||	O
(	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
!=	O
' '	O
&&	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
!=	O
'\t'	O
)	O
)	O
&&	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
!=	O
','	O
&&	O
(	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
!=	O
'<'	O
||	O
(	O
!	O
macro_alternate	int
&&	O
!	O
macro_mri	int
)	O
)	O
)	O
{	O
char	O
tchar	char
=	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
;	O
switch	O
(	O
tchar	char
)	O
{	O
case	O
'"'	O
:	O
case	O
'\''	O
:	O
sb_add_char	function
(	O
out	pointer
,	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
++	O
]	O
)	O
;	O
while	O
(	O
idx	int
<	O
in	pointer
->	O
len	long
&&	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
!=	O
tchar	char
)	O
sb_add_char	function
(	O
out	pointer
,	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
++	O
]	O
)	O
;	O
if	O
(	O
idx	int
==	O
in	pointer
->	O
len	long
)	O
{	O
free	function
(	O
br_buf	pointer
)	O
;	O
return	O
idx	int
;	O
}	O
break	O
;	O
case	O
'('	O
:	O
case	O
'['	O
:	O
if	O
(	O
in_br	pointer
>	O
br_buf	pointer
)	O
--	O
in_br	pointer
;	O
else	O
{	O
br_buf	pointer
=	O
XNEWVEC	O
(	O
char	O
,	O
strlen	function
(	O
in_br	pointer
)	O
+	O
2	int
)	O
;	O
strcpy	function
(	O
br_buf	pointer
+	O
1	int
,	O
in_br	pointer
)	O
;	O
free	function
(	O
in_br	pointer
)	O
;	O
in_br	pointer
=	O
br_buf	pointer
;	O
}	O
*	O
in_br	pointer
=	O
tchar	char
;	O
break	O
;	O
case	O
')'	O
:	O
if	O
(	O
*	O
in_br	pointer
==	O
'('	O
)	O
++	O
in_br	pointer
;	O
break	O
;	O
case	O
']'	O
:	O
if	O
(	O
*	O
in_br	pointer
==	O
'['	O
)	O
++	O
in_br	pointer
;	O
break	O
;	O
}	O
sb_add_char	function
(	O
out	pointer
,	O
tchar	char
)	O
;	O
++	O
idx	int
;	O
}	O
free	function
(	O
br_buf	pointer
)	O
;	O
}	O
}	O
return	O
idx	int
;	O
}	O
static	O
formal_entry	struct
*	O
new_formal	function
(	O
void	O
)	O
{	O
formal_entry	struct
*	O
formal	pointer
;	O
formal	pointer
=	O
XNEW	O
(	O
formal_entry	struct
)	O
;	O
sb_new	function
(	O
&	O
formal	pointer
->	O
name	pointer
)	O
;	O
sb_new	function
(	O
&	O
formal	pointer
->	O
def	struct
)	O
;	O
sb_new	function
(	O
&	O
formal	pointer
->	O
actual	struct
)	O
;	O
formal	pointer
->	O
next	pointer
=	O
NULL	O
;	O
formal	pointer
->	O
type	char
=	O
FORMAL_OPTIONAL	int
;	O
return	O
formal	pointer
;	O
}	O
static	O
void	O
del_formal	function
(	O
formal_entry	struct
*	O
formal	pointer
)	O
{	O
sb_kill	function
(	O
&	O
formal	pointer
->	O
actual	struct
)	O
;	O
sb_kill	function
(	O
&	O
formal	pointer
->	O
def	struct
)	O
;	O
sb_kill	function
(	O
&	O
formal	pointer
->	O
name	pointer
)	O
;	O
free	function
(	O
formal	pointer
)	O
;	O
}	O
static	O
size_t	long
do_formals	function
(	O
macro_entry	struct
*	O
macro	pointer
,	O
size_t	long
idx	int
,	O
sb	pointer
*	O
in	pointer
)	O
{	O
formal_entry	struct
*	O
*	O
p	pointer
=	O
&	O
macro	pointer
->	O
formals	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
idx	int
=	O
sb_skip_white	function
(	O
idx	int
,	O
in	pointer
)	O
;	O
while	O
(	O
idx	int
<	O
in	pointer
->	O
len	long
)	O
{	O
formal_entry	struct
*	O
formal	pointer
=	O
new_formal	function
(	O
)	O
;	O
size_t	long
cidx	long
;	O
idx	int
=	O
get_token	function
(	O
idx	int
,	O
in	pointer
,	O
&	O
formal	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
formal	pointer
->	O
name	pointer
.	O
len	long
==	O
0	int
)	O
{	O
if	O
(	O
macro	pointer
->	O
formal_count	int
)	O
--	O
idx	int
;	O
del_formal	function
(	O
formal	pointer
)	O
;	O
break	O
;	O
}	O
idx	int
=	O
sb_skip_white	function
(	O
idx	int
,	O
in	pointer
)	O
;	O
name	pointer
=	O
sb_terminate	function
(	O
&	O
formal	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
!	O
macro_mri	int
&&	O
idx	int
<	O
in	pointer
->	O
len	long
&&	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
==	O
':'	O
&&	O
(	O
!	O
is_name_beginner	O
(	O
':'	O
)	O
||	O
idx	int
+	O
1	int
>=	O
in	pointer
->	O
len	long
||	O
!	O
is_part_of_name	O
(	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
+	O
1	int
]	O
)	O
)	O
)	O
{	O
sb	pointer
qual	struct
;	O
sb_new	function
(	O
&	O
qual	struct
)	O
;	O
idx	int
=	O
get_token	function
(	O
sb_skip_white	function
(	O
idx	int
+	O
1	int
,	O
in	pointer
)	O
,	O
in	pointer
,	O
&	O
qual	struct
)	O
;	O
sb_terminate	function
(	O
&	O
qual	struct
)	O
;	O
if	O
(	O
qual	struct
.	O
len	long
==	O
0	int
)	O
as_bad_where	function
(	O
macro	pointer
->	O
file	pointer
,	O
macro	pointer
->	O
line	int
,	O
_	O
(	O
"Missing parameter qualifier for `%s' in macro `%s'"	pointer
)	O
,	O
name	pointer
,	O
macro	pointer
->	O
name	pointer
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
qual	struct
.	O
ptr	pointer
,	O
"req"	pointer
)	O
==	O
0	int
)	O
formal	pointer
->	O
type	char
=	O
FORMAL_REQUIRED	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
qual	struct
.	O
ptr	pointer
,	O
"vararg"	pointer
)	O
==	O
0	int
)	O
formal	pointer
->	O
type	char
=	O
FORMAL_VARARG	int
;	O
else	O
as_bad_where	function
(	O
macro	pointer
->	O
file	pointer
,	O
macro	pointer
->	O
line	int
,	O
_	O
(	O
"`%s' is not a valid parameter qualifier for `%s' in macro `%s'"	pointer
)	O
,	O
qual	struct
.	O
ptr	pointer
,	O
name	pointer
,	O
macro	pointer
->	O
name	pointer
)	O
;	O
sb_kill	function
(	O
&	O
qual	struct
)	O
;	O
idx	int
=	O
sb_skip_white	function
(	O
idx	int
,	O
in	pointer
)	O
;	O
}	O
if	O
(	O
idx	int
<	O
in	pointer
->	O
len	long
&&	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
==	O
'='	O
)	O
{	O
idx	int
=	O
get_any_string	function
(	O
idx	int
+	O
1	int
,	O
in	pointer
,	O
&	O
formal	pointer
->	O
def	struct
)	O
;	O
idx	int
=	O
sb_skip_white	function
(	O
idx	int
,	O
in	pointer
)	O
;	O
if	O
(	O
formal	pointer
->	O
type	char
==	O
FORMAL_REQUIRED	int
)	O
{	O
sb_reset	function
(	O
&	O
formal	pointer
->	O
def	struct
)	O
;	O
as_warn_where	function
(	O
macro	pointer
->	O
file	pointer
,	O
macro	pointer
->	O
line	int
,	O
_	O
(	O
"Pointless default value for required parameter `%s' in macro `%s'"	pointer
)	O
,	O
name	pointer
,	O
macro	pointer
->	O
name	pointer
)	O
;	O
}	O
}	O
if	O
(	O
!	O
hash_find	function
(	O
macro	pointer
->	O
formal_hash	pointer
,	O
name	pointer
)	O
)	O
hash_jam	function
(	O
macro	pointer
->	O
formal_hash	pointer
,	O
name	pointer
,	O
formal	pointer
)	O
;	O
else	O
as_bad_where	function
(	O
macro	pointer
->	O
file	pointer
,	O
macro	pointer
->	O
line	int
,	O
_	O
(	O
"A parameter named `%s' already exists for macro `%s'"	pointer
)	O
,	O
name	pointer
,	O
macro	pointer
->	O
name	pointer
)	O
;	O
formal	pointer
->	O
index	function
=	O
macro	pointer
->	O
formal_count	int
++	O
;	O
*	O
p	pointer
=	O
formal	pointer
;	O
p	pointer
=	O
&	O
formal	pointer
->	O
next	pointer
;	O
if	O
(	O
formal	pointer
->	O
type	char
==	O
FORMAL_VARARG	int
)	O
break	O
;	O
cidx	long
=	O
idx	int
;	O
idx	int
=	O
sb_skip_comma	function
(	O
idx	int
,	O
in	pointer
)	O
;	O
if	O
(	O
idx	int
!=	O
cidx	long
&&	O
idx	int
>=	O
in	pointer
->	O
len	long
)	O
{	O
idx	int
=	O
cidx	long
;	O
break	O
;	O
}	O
}	O
if	O
(	O
macro_mri	int
)	O
{	O
formal_entry	struct
*	O
formal	pointer
=	O
new_formal	function
(	O
)	O
;	O
if	O
(	O
macro_strip_at	int
)	O
name	pointer
=	O
"$NARG"	pointer
;	O
else	O
name	pointer
=	O
"NARG"	pointer
;	O
sb_add_string	function
(	O
&	O
formal	pointer
->	O
name	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
hash_find	function
(	O
macro	pointer
->	O
formal_hash	pointer
,	O
name	pointer
)	O
)	O
as_bad_where	function
(	O
macro	pointer
->	O
file	pointer
,	O
macro	pointer
->	O
line	int
,	O
_	O
(	O
"Reserved word `%s' used as parameter in macro `%s'"	pointer
)	O
,	O
name	pointer
,	O
macro	pointer
->	O
name	pointer
)	O
;	O
hash_jam	function
(	O
macro	pointer
->	O
formal_hash	pointer
,	O
name	pointer
,	O
formal	pointer
)	O
;	O
formal	pointer
->	O
index	function
=	O
NARG_INDEX	O
;	O
*	O
p	pointer
=	O
formal	pointer
;	O
}	O
return	O
idx	int
;	O
}	O
static	O
void	O
free_macro	function
(	O
macro_entry	struct
*	O
macro	pointer
)	O
{	O
formal_entry	struct
*	O
formal	pointer
;	O
for	O
(	O
formal	pointer
=	O
macro	pointer
->	O
formals	pointer
;	O
formal	pointer
;	O
)	O
{	O
formal_entry	struct
*	O
f	pointer
;	O
f	pointer
=	O
formal	pointer
;	O
formal	pointer
=	O
formal	pointer
->	O
next	pointer
;	O
del_formal	function
(	O
f	pointer
)	O
;	O
}	O
hash_die	function
(	O
macro	pointer
->	O
formal_hash	pointer
)	O
;	O
sb_kill	function
(	O
&	O
macro	pointer
->	O
sub	struct
)	O
;	O
free	function
(	O
macro	pointer
)	O
;	O
}	O
const	O
char	O
*	O
define_macro	function
(	O
size_t	long
idx	int
,	O
sb	pointer
*	O
in	pointer
,	O
sb	pointer
*	O
label	long
,	O
size_t	long
(	O
*	O
get_line	pointer
)	O
(	O
sb	pointer
*	O
)	O
,	O
const	O
char	O
*	O
file	pointer
,	O
unsigned	O
int	O
line	int
,	O
const	O
char	O
*	O
*	O
namep	pointer
)	O
{	O
macro_entry	struct
*	O
macro	pointer
;	O
sb	pointer
name	pointer
;	O
const	O
char	O
*	O
error	pointer
=	O
NULL	O
;	O
macro	pointer
=	O
XNEW	O
(	O
macro_entry	struct
)	O
;	O
sb_new	function
(	O
&	O
macro	pointer
->	O
sub	struct
)	O
;	O
sb_new	function
(	O
&	O
name	pointer
)	O
;	O
macro	pointer
->	O
file	pointer
=	O
file	pointer
;	O
macro	pointer
->	O
line	int
=	O
line	int
;	O
macro	pointer
->	O
formal_count	int
=	O
0	int
;	O
macro	pointer
->	O
formals	pointer
=	O
0	int
;	O
macro	pointer
->	O
formal_hash	pointer
=	O
hash_new_sized	function
(	O
7	int
)	O
;	O
idx	int
=	O
sb_skip_white	function
(	O
idx	int
,	O
in	pointer
)	O
;	O
if	O
(	O
!	O
buffer_and_nest	function
(	O
"MACRO"	pointer
,	O
"ENDM"	pointer
,	O
&	O
macro	pointer
->	O
sub	struct
,	O
get_line	pointer
)	O
)	O
error	pointer
=	O
_	O
(	O
"unexpected end of file in macro `%s' definition"	pointer
)	O
;	O
if	O
(	O
label	long
!=	O
NULL	O
&&	O
label	long
->	O
len	long
!=	O
0	int
)	O
{	O
sb_add_sb	function
(	O
&	O
name	pointer
,	O
label	long
)	O
;	O
macro	pointer
->	O
name	pointer
=	O
sb_terminate	function
(	O
&	O
name	pointer
)	O
;	O
if	O
(	O
idx	int
<	O
in	pointer
->	O
len	long
&&	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
==	O
'('	O
)	O
{	O
idx	int
=	O
do_formals	function
(	O
macro	pointer
,	O
idx	int
+	O
1	int
,	O
in	pointer
)	O
;	O
if	O
(	O
idx	int
<	O
in	pointer
->	O
len	long
&&	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
==	O
')'	O
)	O
idx	int
=	O
sb_skip_white	function
(	O
idx	int
+	O
1	int
,	O
in	pointer
)	O
;	O
else	O
if	O
(	O
!	O
error	pointer
)	O
error	pointer
=	O
_	O
(	O
"missing `)' after formals in macro definition `%s'"	pointer
)	O
;	O
}	O
else	O
{	O
idx	int
=	O
do_formals	function
(	O
macro	pointer
,	O
idx	int
,	O
in	pointer
)	O
;	O
}	O
}	O
else	O
{	O
size_t	long
cidx	long
;	O
idx	int
=	O
get_token	function
(	O
idx	int
,	O
in	pointer
,	O
&	O
name	pointer
)	O
;	O
macro	pointer
->	O
name	pointer
=	O
sb_terminate	function
(	O
&	O
name	pointer
)	O
;	O
if	O
(	O
name	pointer
.	O
len	long
==	O
0	int
)	O
error	pointer
=	O
_	O
(	O
"Missing macro name"	pointer
)	O
;	O
cidx	long
=	O
sb_skip_white	function
(	O
idx	int
,	O
in	pointer
)	O
;	O
idx	int
=	O
sb_skip_comma	function
(	O
cidx	long
,	O
in	pointer
)	O
;	O
if	O
(	O
idx	int
==	O
cidx	long
||	O
idx	int
<	O
in	pointer
->	O
len	long
)	O
idx	int
=	O
do_formals	function
(	O
macro	pointer
,	O
idx	int
,	O
in	pointer
)	O
;	O
else	O
idx	int
=	O
cidx	long
;	O
}	O
if	O
(	O
!	O
error	pointer
&&	O
idx	int
<	O
in	pointer
->	O
len	long
)	O
error	pointer
=	O
_	O
(	O
"Bad parameter list for macro `%s'"	pointer
)	O
;	O
for	O
(	O
idx	int
=	O
0	int
;	O
idx	int
<	O
name	pointer
.	O
len	long
;	O
idx	int
++	O
)	O
name	pointer
.	O
ptr	pointer
[	O
idx	int
]	O
=	O
TOLOWER	O
(	O
name	pointer
.	O
ptr	pointer
[	O
idx	int
]	O
)	O
;	O
if	O
(	O
hash_find	function
(	O
macro_hash	pointer
,	O
macro	pointer
->	O
name	pointer
)	O
)	O
error	pointer
=	O
_	O
(	O
"Macro `%s' was already defined"	pointer
)	O
;	O
if	O
(	O
!	O
error	pointer
)	O
error	pointer
=	O
hash_jam	function
(	O
macro_hash	pointer
,	O
macro	pointer
->	O
name	pointer
,	O
(	O
void	O
*	O
)	O
macro	pointer
)	O
;	O
if	O
(	O
namep	pointer
!=	O
NULL	O
)	O
*	O
namep	pointer
=	O
macro	pointer
->	O
name	pointer
;	O
if	O
(	O
!	O
error	pointer
)	O
macro_defined	int
=	O
1	int
;	O
else	O
free_macro	function
(	O
macro	pointer
)	O
;	O
return	O
error	pointer
;	O
}	O
static	O
size_t	long
get_apost_token	function
(	O
size_t	long
idx	int
,	O
sb	pointer
*	O
in	pointer
,	O
sb	pointer
*	O
name	pointer
,	O
int	O
kind	int
)	O
{	O
idx	int
=	O
get_token	function
(	O
idx	int
,	O
in	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
idx	int
<	O
in	pointer
->	O
len	long
&&	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
==	O
kind	int
&&	O
(	O
!	O
macro_mri	int
||	O
macro_strip_at	int
)	O
&&	O
(	O
!	O
macro_strip_at	int
||	O
kind	int
==	O
'@'	O
)	O
)	O
idx	int
++	O
;	O
return	O
idx	int
;	O
}	O
static	O
size_t	long
sub_actual	function
(	O
size_t	long
start	long
,	O
sb	pointer
*	O
in	pointer
,	O
sb	pointer
*	O
t	pointer
,	O
struct	O
hash_control	O
*	O
formal_hash	pointer
,	O
int	O
kind	int
,	O
sb	pointer
*	O
out	pointer
,	O
int	O
copyifnotthere	int
)	O
{	O
size_t	long
src	long
;	O
formal_entry	struct
*	O
ptr	pointer
;	O
src	long
=	O
get_apost_token	function
(	O
start	long
,	O
in	pointer
,	O
t	pointer
,	O
kind	int
)	O
;	O
if	O
(	O
macro_strip_at	int
&&	O
kind	int
==	O
'@'	O
&&	O
(	O
src	long
==	O
start	long
||	O
in	pointer
->	O
ptr	pointer
[	O
src	long
-	O
1	int
]	O
!=	O
'@'	O
)	O
)	O
ptr	pointer
=	O
NULL	O
;	O
else	O
ptr	pointer
=	O
(	O
formal_entry	struct
*	O
)	O
hash_find	function
(	O
formal_hash	pointer
,	O
sb_terminate	function
(	O
t	pointer
)	O
)	O
;	O
if	O
(	O
ptr	pointer
)	O
{	O
if	O
(	O
ptr	pointer
->	O
actual	struct
.	O
len	long
)	O
{	O
sb_add_sb	function
(	O
out	pointer
,	O
&	O
ptr	pointer
->	O
actual	struct
)	O
;	O
}	O
else	O
{	O
sb_add_sb	function
(	O
out	pointer
,	O
&	O
ptr	pointer
->	O
def	struct
)	O
;	O
}	O
}	O
else	O
if	O
(	O
kind	int
==	O
'&'	O
)	O
{	O
sb_add_char	function
(	O
out	pointer
,	O
'&'	O
)	O
;	O
sb_add_sb	function
(	O
out	pointer
,	O
t	pointer
)	O
;	O
if	O
(	O
src	long
!=	O
start	long
&&	O
in	pointer
->	O
ptr	pointer
[	O
src	long
-	O
1	int
]	O
==	O
'&'	O
)	O
sb_add_char	function
(	O
out	pointer
,	O
'&'	O
)	O
;	O
}	O
else	O
if	O
(	O
copyifnotthere	int
)	O
{	O
sb_add_sb	function
(	O
out	pointer
,	O
t	pointer
)	O
;	O
}	O
else	O
{	O
sb_add_char	function
(	O
out	pointer
,	O
'\\'	O
)	O
;	O
sb_add_sb	function
(	O
out	pointer
,	O
t	pointer
)	O
;	O
}	O
return	O
src	long
;	O
}	O
static	O
const	O
char	O
*	O
macro_expand_body	function
(	O
sb	pointer
*	O
in	pointer
,	O
sb	pointer
*	O
out	pointer
,	O
formal_entry	struct
*	O
formals	pointer
,	O
struct	O
hash_control	O
*	O
formal_hash	pointer
,	O
const	O
macro_entry	struct
*	O
macro	pointer
)	O
{	O
sb	pointer
t	pointer
;	O
size_t	long
src	long
=	O
0	int
;	O
int	O
inquote	int
=	O
0	int
,	O
macro_line	int
=	O
0	int
;	O
formal_entry	struct
*	O
loclist	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
err	pointer
=	O
NULL	O
;	O
sb_new	function
(	O
&	O
t	pointer
)	O
;	O
while	O
(	O
src	long
<	O
in	pointer
->	O
len	long
&&	O
!	O
err	pointer
)	O
{	O
if	O
(	O
in	pointer
->	O
ptr	pointer
[	O
src	long
]	O
==	O
'&'	O
)	O
{	O
sb_reset	function
(	O
&	O
t	pointer
)	O
;	O
if	O
(	O
macro_mri	int
)	O
{	O
if	O
(	O
src	long
+	O
1	int
<	O
in	pointer
->	O
len	long
&&	O
in	pointer
->	O
ptr	pointer
[	O
src	long
+	O
1	int
]	O
==	O
'&'	O
)	O
src	long
=	O
sub_actual	function
(	O
src	long
+	O
2	int
,	O
in	pointer
,	O
&	O
t	pointer
,	O
formal_hash	pointer
,	O
'\''	O
,	O
out	pointer
,	O
1	int
)	O
;	O
else	O
sb_add_char	function
(	O
out	pointer
,	O
in	pointer
->	O
ptr	pointer
[	O
src	long
++	O
]	O
)	O
;	O
}	O
else	O
{	O
src	long
=	O
sub_actual	function
(	O
src	long
+	O
1	int
,	O
in	pointer
,	O
&	O
t	pointer
,	O
formal_hash	pointer
,	O
'&'	O
,	O
out	pointer
,	O
0	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
in	pointer
->	O
ptr	pointer
[	O
src	long
]	O
==	O
'\\'	O
)	O
{	O
src	long
++	O
;	O
if	O
(	O
src	long
<	O
in	pointer
->	O
len	long
&&	O
in	pointer
->	O
ptr	pointer
[	O
src	long
]	O
==	O
'('	O
)	O
{	O
src	long
++	O
;	O
while	O
(	O
src	long
<	O
in	pointer
->	O
len	long
&&	O
in	pointer
->	O
ptr	pointer
[	O
src	long
]	O
!=	O
')'	O
)	O
{	O
sb_add_char	function
(	O
out	pointer
,	O
in	pointer
->	O
ptr	pointer
[	O
src	long
++	O
]	O
)	O
;	O
}	O
if	O
(	O
src	long
<	O
in	pointer
->	O
len	long
)	O
src	long
++	O
;	O
else	O
if	O
(	O
!	O
macro	pointer
)	O
err	pointer
=	O
_	O
(	O
"missing `)'"	pointer
)	O
;	O
else	O
as_bad_where	function
(	O
macro	pointer
->	O
file	pointer
,	O
macro	pointer
->	O
line	int
+	O
macro_line	int
,	O
_	O
(	O
"missing `)'"	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
src	long
<	O
in	pointer
->	O
len	long
&&	O
in	pointer
->	O
ptr	pointer
[	O
src	long
]	O
==	O
'@'	O
)	O
{	O
char	O
buffer	array
[	O
12	int
]	O
;	O
src	long
++	O
;	O
sprintf	function
(	O
buffer	array
,	O
"%d"	pointer
,	O
macro_number	int
)	O
;	O
sb_add_string	function
(	O
out	pointer
,	O
buffer	array
)	O
;	O
}	O
else	O
if	O
(	O
src	long
<	O
in	pointer
->	O
len	long
&&	O
in	pointer
->	O
ptr	pointer
[	O
src	long
]	O
==	O
'&'	O
)	O
{	O
sb_add_char	function
(	O
out	pointer
,	O
'\\'	O
)	O
;	O
sb_add_char	function
(	O
out	pointer
,	O
'&'	O
)	O
;	O
src	long
++	O
;	O
}	O
else	O
if	O
(	O
macro_mri	int
&&	O
src	long
<	O
in	pointer
->	O
len	long
&&	O
ISALNUM	O
(	O
in	pointer
->	O
ptr	pointer
[	O
src	long
]	O
)	O
)	O
{	O
int	O
ind	int
;	O
formal_entry	struct
*	O
f	pointer
;	O
if	O
(	O
ISDIGIT	O
(	O
in	pointer
->	O
ptr	pointer
[	O
src	long
]	O
)	O
)	O
ind	int
=	O
in	pointer
->	O
ptr	pointer
[	O
src	long
]	O
-	O
'0'	O
;	O
else	O
if	O
(	O
ISUPPER	O
(	O
in	pointer
->	O
ptr	pointer
[	O
src	long
]	O
)	O
)	O
ind	int
=	O
in	pointer
->	O
ptr	pointer
[	O
src	long
]	O
-	O
'A'	O
+	O
10	int
;	O
else	O
ind	int
=	O
in	pointer
->	O
ptr	pointer
[	O
src	long
]	O
-	O
'a'	O
+	O
10	int
;	O
++	O
src	long
;	O
for	O
(	O
f	pointer
=	O
formals	pointer
;	O
f	pointer
!=	O
NULL	O
;	O
f	pointer
=	O
f	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
f	pointer
->	O
index	function
==	O
ind	int
-	O
1	int
)	O
{	O
if	O
(	O
f	pointer
->	O
actual	struct
.	O
len	long
!=	O
0	int
)	O
sb_add_sb	function
(	O
out	pointer
,	O
&	O
f	pointer
->	O
actual	struct
)	O
;	O
else	O
sb_add_sb	function
(	O
out	pointer
,	O
&	O
f	pointer
->	O
def	struct
)	O
;	O
break	O
;	O
}	O
}	O
}	O
else	O
{	O
sb_reset	function
(	O
&	O
t	pointer
)	O
;	O
src	long
=	O
sub_actual	function
(	O
src	long
,	O
in	pointer
,	O
&	O
t	pointer
,	O
formal_hash	pointer
,	O
'\''	O
,	O
out	pointer
,	O
0	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
(	O
macro_alternate	int
||	O
macro_mri	int
)	O
&&	O
is_name_beginner	O
(	O
in	pointer
->	O
ptr	pointer
[	O
src	long
]	O
)	O
&&	O
(	O
!	O
inquote	int
||	O
!	O
macro_strip_at	int
||	O
(	O
src	long
>	O
0	int
&&	O
in	pointer
->	O
ptr	pointer
[	O
src	long
-	O
1	int
]	O
==	O
'@'	O
)	O
)	O
)	O
{	O
if	O
(	O
!	O
macro	pointer
||	O
src	long
+	O
5	int
>=	O
in	pointer
->	O
len	long
||	O
strncasecmp	function
(	O
in	pointer
->	O
ptr	pointer
+	O
src	long
,	O
"LOCAL"	pointer
,	O
5	int
)	O
!=	O
0	int
||	O
!	O
ISWHITE	O
(	O
in	pointer
->	O
ptr	pointer
[	O
src	long
+	O
5	int
]	O
)	O
||	O
inquote	int
)	O
{	O
sb_reset	function
(	O
&	O
t	pointer
)	O
;	O
src	long
=	O
sub_actual	function
(	O
src	long
,	O
in	pointer
,	O
&	O
t	pointer
,	O
formal_hash	pointer
,	O
(	O
macro_strip_at	int
&&	O
inquote	int
)	O
?	O
'@'	O
:	O
'\''	O
,	O
out	pointer
,	O
1	int
)	O
;	O
}	O
else	O
{	O
src	long
=	O
sb_skip_white	function
(	O
src	long
+	O
5	int
,	O
in	pointer
)	O
;	O
while	O
(	O
in	pointer
->	O
ptr	pointer
[	O
src	long
]	O
!=	O
'\n'	O
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
formal_entry	struct
*	O
f	pointer
=	O
new_formal	function
(	O
)	O
;	O
src	long
=	O
get_token	function
(	O
src	long
,	O
in	pointer
,	O
&	O
f	pointer
->	O
name	pointer
)	O
;	O
name	pointer
=	O
sb_terminate	function
(	O
&	O
f	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
!	O
hash_find	function
(	O
formal_hash	pointer
,	O
name	pointer
)	O
)	O
{	O
static	O
int	O
loccnt	int
;	O
char	O
buf	pointer
[	O
20	int
]	O
;	O
f	pointer
->	O
index	function
=	O
LOCAL_INDEX	O
;	O
f	pointer
->	O
next	pointer
=	O
loclist	pointer
;	O
loclist	pointer
=	O
f	pointer
;	O
sprintf	function
(	O
buf	pointer
,	O
IS_ELF	int
?	O
".LL%04x"	pointer
:	O
"LL%04x"	pointer
,	O
++	O
loccnt	int
)	O
;	O
sb_add_string	function
(	O
&	O
f	pointer
->	O
actual	struct
,	O
buf	pointer
)	O
;	O
err	pointer
=	O
hash_jam	function
(	O
formal_hash	pointer
,	O
name	pointer
,	O
f	pointer
)	O
;	O
if	O
(	O
err	pointer
!=	O
NULL	O
)	O
break	O
;	O
}	O
else	O
{	O
as_bad_where	function
(	O
macro	pointer
->	O
file	pointer
,	O
macro	pointer
->	O
line	int
+	O
macro_line	int
,	O
_	O
(	O
"`%s' was already used as parameter (or another local) name"	pointer
)	O
,	O
name	pointer
)	O
;	O
del_formal	function
(	O
f	pointer
)	O
;	O
}	O
src	long
=	O
sb_skip_comma	function
(	O
src	long
,	O
in	pointer
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
in	pointer
->	O
ptr	pointer
[	O
src	long
]	O
==	O
'"'	O
||	O
(	O
macro_mri	int
&&	O
in	pointer
->	O
ptr	pointer
[	O
src	long
]	O
==	O
'\''	O
)	O
)	O
{	O
inquote	int
=	O
!	O
inquote	int
;	O
sb_add_char	function
(	O
out	pointer
,	O
in	pointer
->	O
ptr	pointer
[	O
src	long
++	O
]	O
)	O
;	O
}	O
else	O
if	O
(	O
in	pointer
->	O
ptr	pointer
[	O
src	long
]	O
==	O
'@'	O
&&	O
macro_strip_at	int
)	O
{	O
++	O
src	long
;	O
if	O
(	O
src	long
<	O
in	pointer
->	O
len	long
&&	O
in	pointer
->	O
ptr	pointer
[	O
src	long
]	O
==	O
'@'	O
)	O
{	O
sb_add_char	function
(	O
out	pointer
,	O
'@'	O
)	O
;	O
++	O
src	long
;	O
}	O
}	O
else	O
if	O
(	O
macro_mri	int
&&	O
in	pointer
->	O
ptr	pointer
[	O
src	long
]	O
==	O
'='	O
&&	O
src	long
+	O
1	int
<	O
in	pointer
->	O
len	long
&&	O
in	pointer
->	O
ptr	pointer
[	O
src	long
+	O
1	int
]	O
==	O
'='	O
)	O
{	O
formal_entry	struct
*	O
ptr	pointer
;	O
sb_reset	function
(	O
&	O
t	pointer
)	O
;	O
src	long
=	O
get_token	function
(	O
src	long
+	O
2	int
,	O
in	pointer
,	O
&	O
t	pointer
)	O
;	O
ptr	pointer
=	O
(	O
formal_entry	struct
*	O
)	O
hash_find	function
(	O
formal_hash	pointer
,	O
sb_terminate	function
(	O
&	O
t	pointer
)	O
)	O
;	O
if	O
(	O
ptr	pointer
==	O
NULL	O
)	O
{	O
sb_add_char	function
(	O
out	pointer
,	O
'='	O
)	O
;	O
sb_add_char	function
(	O
out	pointer
,	O
'='	O
)	O
;	O
sb_add_sb	function
(	O
out	pointer
,	O
&	O
t	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
ptr	pointer
->	O
actual	struct
.	O
len	long
)	O
{	O
sb_add_string	function
(	O
out	pointer
,	O
"-1"	pointer
)	O
;	O
}	O
else	O
{	O
sb_add_char	function
(	O
out	pointer
,	O
'0'	O
)	O
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
in	pointer
->	O
ptr	pointer
[	O
src	long
]	O
==	O
'\n'	O
)	O
++	O
macro_line	int
;	O
sb_add_char	function
(	O
out	pointer
,	O
in	pointer
->	O
ptr	pointer
[	O
src	long
++	O
]	O
)	O
;	O
}	O
}	O
sb_kill	function
(	O
&	O
t	pointer
)	O
;	O
while	O
(	O
loclist	pointer
!=	O
NULL	O
)	O
{	O
formal_entry	struct
*	O
f	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
f	pointer
=	O
loclist	pointer
->	O
next	pointer
;	O
name	pointer
=	O
sb_terminate	function
(	O
&	O
loclist	pointer
->	O
name	pointer
)	O
;	O
hash_delete	function
(	O
formal_hash	pointer
,	O
name	pointer
,	O
f	pointer
==	O
NULL	O
)	O
;	O
del_formal	function
(	O
loclist	pointer
)	O
;	O
loclist	pointer
=	O
f	pointer
;	O
}	O
return	O
err	pointer
;	O
}	O
static	O
const	O
char	O
*	O
macro_expand	function
(	O
size_t	long
idx	int
,	O
sb	pointer
*	O
in	pointer
,	O
macro_entry	struct
*	O
m	pointer
,	O
sb	pointer
*	O
out	pointer
)	O
{	O
sb	pointer
t	pointer
;	O
formal_entry	struct
*	O
ptr	pointer
;	O
formal_entry	struct
*	O
f	pointer
;	O
int	O
is_keyword	int
=	O
0	int
;	O
int	O
narg	int
=	O
0	int
;	O
const	O
char	O
*	O
err	pointer
=	O
NULL	O
;	O
sb_new	function
(	O
&	O
t	pointer
)	O
;	O
for	O
(	O
f	pointer
=	O
m	pointer
->	O
formals	pointer
;	O
f	pointer
;	O
f	pointer
=	O
f	pointer
->	O
next	pointer
)	O
sb_reset	function
(	O
&	O
f	pointer
->	O
actual	struct
)	O
;	O
f	pointer
=	O
m	pointer
->	O
formals	pointer
;	O
while	O
(	O
f	pointer
!=	O
NULL	O
&&	O
f	pointer
->	O
index	function
<	O
0	int
)	O
f	pointer
=	O
f	pointer
->	O
next	pointer
;	O
if	O
(	O
macro_mri	int
)	O
{	O
if	O
(	O
idx	int
<	O
in	pointer
->	O
len	long
&&	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
==	O
'.'	O
)	O
{	O
idx	int
++	O
;	O
if	O
(	O
idx	int
<	O
in	pointer
->	O
len	long
&&	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
!=	O
' '	O
&&	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
!=	O
'\t'	O
)	O
{	O
formal_entry	struct
*	O
n	int
=	O
new_formal	function
(	O
)	O
;	O
n	int
->	O
index	function
=	O
QUAL_INDEX	O
;	O
n	int
->	O
next	pointer
=	O
m	pointer
->	O
formals	pointer
;	O
m	pointer
->	O
formals	pointer
=	O
n	int
;	O
idx	int
=	O
get_any_string	function
(	O
idx	int
,	O
in	pointer
,	O
&	O
n	int
->	O
actual	struct
)	O
;	O
}	O
}	O
}	O
idx	int
=	O
sb_skip_white	function
(	O
idx	int
,	O
in	pointer
)	O
;	O
while	O
(	O
idx	int
<	O
in	pointer
->	O
len	long
)	O
{	O
size_t	long
scan	pointer
;	O
scan	pointer
=	O
idx	int
;	O
while	O
(	O
scan	pointer
<	O
in	pointer
->	O
len	long
&&	O
!	O
ISSEP	O
(	O
in	pointer
->	O
ptr	pointer
[	O
scan	pointer
]	O
)	O
&&	O
!	O
(	O
macro_mri	int
&&	O
in	pointer
->	O
ptr	pointer
[	O
scan	pointer
]	O
==	O
'\''	O
)	O
&&	O
(	O
!	O
macro_alternate	int
&&	O
in	pointer
->	O
ptr	pointer
[	O
scan	pointer
]	O
!=	O
'='	O
)	O
)	O
scan	pointer
++	O
;	O
if	O
(	O
scan	pointer
<	O
in	pointer
->	O
len	long
&&	O
!	O
macro_alternate	int
&&	O
in	pointer
->	O
ptr	pointer
[	O
scan	pointer
]	O
==	O
'='	O
)	O
{	O
is_keyword	int
=	O
1	int
;	O
sb_reset	function
(	O
&	O
t	pointer
)	O
;	O
idx	int
=	O
get_token	function
(	O
idx	int
,	O
in	pointer
,	O
&	O
t	pointer
)	O
;	O
if	O
(	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
!=	O
'='	O
)	O
{	O
err	pointer
=	O
_	O
(	O
"confusion in formal parameters"	pointer
)	O
;	O
break	O
;	O
}	O
ptr	pointer
=	O
(	O
formal_entry	struct
*	O
)	O
hash_find	function
(	O
m	pointer
->	O
formal_hash	pointer
,	O
sb_terminate	function
(	O
&	O
t	pointer
)	O
)	O
;	O
if	O
(	O
!	O
ptr	pointer
)	O
{	O
as_bad	function
(	O
_	O
(	O
"Parameter named `%s' does not exist for macro `%s'"	pointer
)	O
,	O
t	pointer
.	O
ptr	pointer
,	O
m	pointer
->	O
name	pointer
)	O
;	O
sb_reset	function
(	O
&	O
t	pointer
)	O
;	O
idx	int
=	O
get_any_string	function
(	O
idx	int
+	O
1	int
,	O
in	pointer
,	O
&	O
t	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
ptr	pointer
->	O
actual	struct
.	O
len	long
)	O
{	O
as_warn	function
(	O
_	O
(	O
"Value for parameter `%s' of macro `%s' was already specified"	pointer
)	O
,	O
ptr	pointer
->	O
name	pointer
.	O
ptr	pointer
,	O
m	pointer
->	O
name	pointer
)	O
;	O
sb_reset	function
(	O
&	O
ptr	pointer
->	O
actual	struct
)	O
;	O
}	O
idx	int
=	O
get_any_string	function
(	O
idx	int
+	O
1	int
,	O
in	pointer
,	O
&	O
ptr	pointer
->	O
actual	struct
)	O
;	O
if	O
(	O
ptr	pointer
->	O
actual	struct
.	O
len	long
>	O
0	int
)	O
++	O
narg	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
is_keyword	int
)	O
{	O
err	pointer
=	O
_	O
(	O
"can't mix positional and keyword arguments"	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
f	pointer
)	O
{	O
formal_entry	struct
*	O
*	O
pf	pointer
;	O
int	O
c	struct
;	O
if	O
(	O
!	O
macro_mri	int
)	O
{	O
err	pointer
=	O
_	O
(	O
"too many positional arguments"	pointer
)	O
;	O
break	O
;	O
}	O
f	pointer
=	O
new_formal	function
(	O
)	O
;	O
c	struct
=	O
-	O
1	int
;	O
for	O
(	O
pf	pointer
=	O
&	O
m	pointer
->	O
formals	pointer
;	O
*	O
pf	pointer
!=	O
NULL	O
;	O
pf	pointer
=	O
&	O
(	O
*	O
pf	pointer
)	O
->	O
next	pointer
)	O
if	O
(	O
(	O
*	O
pf	pointer
)	O
->	O
index	function
>=	O
c	struct
)	O
c	struct
=	O
(	O
*	O
pf	pointer
)	O
->	O
index	function
+	O
1	int
;	O
if	O
(	O
c	struct
==	O
-	O
1	int
)	O
c	struct
=	O
0	int
;	O
*	O
pf	pointer
=	O
f	pointer
;	O
f	pointer
->	O
index	function
=	O
c	struct
;	O
}	O
if	O
(	O
f	pointer
->	O
type	char
!=	O
FORMAL_VARARG	int
)	O
idx	int
=	O
get_any_string	function
(	O
idx	int
,	O
in	pointer
,	O
&	O
f	pointer
->	O
actual	struct
)	O
;	O
else	O
{	O
sb_add_buffer	function
(	O
&	O
f	pointer
->	O
actual	struct
,	O
in	pointer
->	O
ptr	pointer
+	O
idx	int
,	O
in	pointer
->	O
len	long
-	O
idx	int
)	O
;	O
idx	int
=	O
in	pointer
->	O
len	long
;	O
}	O
if	O
(	O
f	pointer
->	O
actual	struct
.	O
len	long
>	O
0	int
)	O
++	O
narg	int
;	O
do	O
{	O
f	pointer
=	O
f	pointer
->	O
next	pointer
;	O
}	O
while	O
(	O
f	pointer
!=	O
NULL	O
&&	O
f	pointer
->	O
index	function
<	O
0	int
)	O
;	O
}	O
if	O
(	O
!	O
macro_mri	int
)	O
idx	int
=	O
sb_skip_comma	function
(	O
idx	int
,	O
in	pointer
)	O
;	O
else	O
{	O
if	O
(	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
==	O
','	O
)	O
++	O
idx	int
;	O
if	O
(	O
ISWHITE	O
(	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
)	O
)	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
err	pointer
)	O
{	O
for	O
(	O
ptr	pointer
=	O
m	pointer
->	O
formals	pointer
;	O
ptr	pointer
;	O
ptr	pointer
=	O
ptr	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
ptr	pointer
->	O
type	char
==	O
FORMAL_REQUIRED	int
&&	O
ptr	pointer
->	O
actual	struct
.	O
len	long
==	O
0	int
)	O
as_bad	function
(	O
_	O
(	O
"Missing value for required parameter `%s' of macro `%s'"	pointer
)	O
,	O
ptr	pointer
->	O
name	pointer
.	O
ptr	pointer
,	O
m	pointer
->	O
name	pointer
)	O
;	O
}	O
if	O
(	O
macro_mri	int
)	O
{	O
char	O
buffer	array
[	O
20	int
]	O
;	O
sb_reset	function
(	O
&	O
t	pointer
)	O
;	O
sb_add_string	function
(	O
&	O
t	pointer
,	O
macro_strip_at	int
?	O
"$NARG"	pointer
:	O
"NARG"	pointer
)	O
;	O
ptr	pointer
=	O
(	O
formal_entry	struct
*	O
)	O
hash_find	function
(	O
m	pointer
->	O
formal_hash	pointer
,	O
sb_terminate	function
(	O
&	O
t	pointer
)	O
)	O
;	O
sprintf	function
(	O
buffer	array
,	O
"%d"	pointer
,	O
narg	int
)	O
;	O
sb_add_string	function
(	O
&	O
ptr	pointer
->	O
actual	struct
,	O
buffer	array
)	O
;	O
}	O
err	pointer
=	O
macro_expand_body	function
(	O
&	O
m	pointer
->	O
sub	struct
,	O
out	pointer
,	O
m	pointer
->	O
formals	pointer
,	O
m	pointer
->	O
formal_hash	pointer
,	O
m	pointer
)	O
;	O
}	O
if	O
(	O
macro_mri	int
)	O
{	O
formal_entry	struct
*	O
*	O
pf	pointer
;	O
pf	pointer
=	O
&	O
m	pointer
->	O
formals	pointer
;	O
while	O
(	O
*	O
pf	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
*	O
pf	pointer
)	O
->	O
name	pointer
.	O
len	long
!=	O
0	int
)	O
pf	pointer
=	O
&	O
(	O
*	O
pf	pointer
)	O
->	O
next	pointer
;	O
else	O
{	O
f	pointer
=	O
(	O
*	O
pf	pointer
)	O
->	O
next	pointer
;	O
del_formal	function
(	O
*	O
pf	pointer
)	O
;	O
*	O
pf	pointer
=	O
f	pointer
;	O
}	O
}	O
}	O
sb_kill	function
(	O
&	O
t	pointer
)	O
;	O
if	O
(	O
!	O
err	pointer
)	O
macro_number	int
++	O
;	O
return	O
err	pointer
;	O
}	O
int	O
check_macro	function
(	O
const	O
char	O
*	O
line	int
,	O
sb	pointer
*	O
expand	pointer
,	O
const	O
char	O
*	O
*	O
error	pointer
,	O
macro_entry	struct
*	O
*	O
info	pointer
)	O
{	O
const	O
char	O
*	O
s	pointer
;	O
char	O
*	O
copy	int
,	O
*	O
cls	pointer
;	O
macro_entry	struct
*	O
macro	pointer
;	O
sb	pointer
line_sb	struct
;	O
if	O
(	O
!	O
is_name_beginner	O
(	O
*	O
line	int
)	O
&&	O
(	O
!	O
macro_mri	int
||	O
*	O
line	int
!=	O
'.'	O
)	O
)	O
return	O
0	int
;	O
s	pointer
=	O
line	int
+	O
1	int
;	O
while	O
(	O
is_part_of_name	O
(	O
*	O
s	pointer
)	O
)	O
++	O
s	pointer
;	O
if	O
(	O
is_name_ender	O
(	O
*	O
s	pointer
)	O
)	O
++	O
s	pointer
;	O
copy	int
=	O
xmemdup0	function
(	O
line	int
,	O
s	pointer
-	O
line	int
)	O
;	O
for	O
(	O
cls	pointer
=	O
copy	int
;	O
*	O
cls	pointer
!=	O
'\0'	O
;	O
cls	pointer
++	O
)	O
*	O
cls	pointer
=	O
TOLOWER	O
(	O
*	O
cls	pointer
)	O
;	O
macro	pointer
=	O
(	O
macro_entry	struct
*	O
)	O
hash_find	function
(	O
macro_hash	pointer
,	O
copy	int
)	O
;	O
free	function
(	O
copy	int
)	O
;	O
if	O
(	O
macro	pointer
==	O
NULL	O
)	O
return	O
0	int
;	O
sb_new	function
(	O
&	O
line_sb	struct
)	O
;	O
while	O
(	O
*	O
s	pointer
!=	O
'\0'	O
&&	O
*	O
s	pointer
!=	O
'\n'	O
&&	O
*	O
s	pointer
!=	O
'\r'	O
)	O
sb_add_char	function
(	O
&	O
line_sb	struct
,	O
*	O
s	pointer
++	O
)	O
;	O
sb_new	function
(	O
expand	pointer
)	O
;	O
*	O
error	pointer
=	O
macro_expand	function
(	O
0	int
,	O
&	O
line_sb	struct
,	O
macro	pointer
,	O
expand	pointer
)	O
;	O
sb_kill	function
(	O
&	O
line_sb	struct
)	O
;	O
if	O
(	O
info	pointer
)	O
*	O
info	pointer
=	O
macro	pointer
;	O
return	O
1	int
;	O
}	O
void	O
delete_macro	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
char	O
*	O
copy	int
;	O
size_t	long
i	pointer
,	O
len	long
;	O
macro_entry	struct
*	O
macro	pointer
;	O
len	long
=	O
strlen	function
(	O
name	pointer
)	O
;	O
copy	int
=	O
XNEWVEC	O
(	O
char	O
,	O
len	long
+	O
1	int
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
len	long
;	O
++	O
i	pointer
)	O
copy	int
[	O
i	pointer
]	O
=	O
TOLOWER	O
(	O
name	pointer
[	O
i	pointer
]	O
)	O
;	O
copy	int
[	O
i	pointer
]	O
=	O
'\0'	O
;	O
if	O
(	O
(	O
macro	pointer
=	O
(	O
macro_entry	struct
*	O
)	O
hash_find	function
(	O
macro_hash	pointer
,	O
copy	int
)	O
)	O
!=	O
NULL	O
)	O
{	O
hash_jam	function
(	O
macro_hash	pointer
,	O
copy	int
,	O
NULL	O
)	O
;	O
free_macro	function
(	O
macro	pointer
)	O
;	O
}	O
else	O
as_warn	function
(	O
_	O
(	O
"Attempt to purge non-existing macro `%s'"	pointer
)	O
,	O
copy	int
)	O
;	O
free	function
(	O
copy	int
)	O
;	O
}	O
const	O
char	O
*	O
expand_irp	function
(	O
int	O
irpc	int
,	O
size_t	long
idx	int
,	O
sb	pointer
*	O
in	pointer
,	O
sb	pointer
*	O
out	pointer
,	O
size_t	long
(	O
*	O
get_line	pointer
)	O
(	O
sb	pointer
*	O
)	O
)	O
{	O
sb	pointer
sub	struct
;	O
formal_entry	struct
f	pointer
;	O
struct	O
hash_control	O
*	O
h	pointer
;	O
const	O
char	O
*	O
err	pointer
;	O
idx	int
=	O
sb_skip_white	function
(	O
idx	int
,	O
in	pointer
)	O
;	O
sb_new	function
(	O
&	O
sub	struct
)	O
;	O
if	O
(	O
!	O
buffer_and_nest	function
(	O
NULL	O
,	O
"ENDR"	pointer
,	O
&	O
sub	struct
,	O
get_line	pointer
)	O
)	O
return	O
_	O
(	O
"unexpected end of file in irp or irpc"	pointer
)	O
;	O
sb_new	function
(	O
&	O
f	pointer
.	O
name	pointer
)	O
;	O
sb_new	function
(	O
&	O
f	pointer
.	O
def	struct
)	O
;	O
sb_new	function
(	O
&	O
f	pointer
.	O
actual	struct
)	O
;	O
idx	int
=	O
get_token	function
(	O
idx	int
,	O
in	pointer
,	O
&	O
f	pointer
.	O
name	pointer
)	O
;	O
if	O
(	O
f	pointer
.	O
name	pointer
.	O
len	long
==	O
0	int
)	O
return	O
_	O
(	O
"missing model parameter"	pointer
)	O
;	O
h	pointer
=	O
hash_new	function
(	O
)	O
;	O
err	pointer
=	O
hash_jam	function
(	O
h	pointer
,	O
sb_terminate	function
(	O
&	O
f	pointer
.	O
name	pointer
)	O
,	O
&	O
f	pointer
)	O
;	O
if	O
(	O
err	pointer
!=	O
NULL	O
)	O
return	O
err	pointer
;	O
f	pointer
.	O
index	function
=	O
1	int
;	O
f	pointer
.	O
next	pointer
=	O
NULL	O
;	O
f	pointer
.	O
type	char
=	O
FORMAL_OPTIONAL	int
;	O
sb_reset	function
(	O
out	pointer
)	O
;	O
idx	int
=	O
sb_skip_comma	function
(	O
idx	int
,	O
in	pointer
)	O
;	O
if	O
(	O
idx	int
>=	O
in	pointer
->	O
len	long
)	O
{	O
err	pointer
=	O
macro_expand_body	function
(	O
&	O
sub	struct
,	O
out	pointer
,	O
&	O
f	pointer
,	O
h	pointer
,	O
0	int
)	O
;	O
}	O
else	O
{	O
bfd_boolean	int
in_quotes	int
=	O
FALSE	int
;	O
if	O
(	O
irpc	int
&&	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
==	O
'"'	O
)	O
{	O
in_quotes	int
=	O
TRUE	int
;	O
++	O
idx	int
;	O
}	O
while	O
(	O
idx	int
<	O
in	pointer
->	O
len	long
)	O
{	O
if	O
(	O
!	O
irpc	int
)	O
idx	int
=	O
get_any_string	function
(	O
idx	int
,	O
in	pointer
,	O
&	O
f	pointer
.	O
actual	struct
)	O
;	O
else	O
{	O
if	O
(	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
==	O
'"'	O
)	O
{	O
size_t	long
nxt	long
;	O
if	O
(	O
irpc	int
)	O
in_quotes	int
=	O
!	O
in_quotes	int
;	O
nxt	long
=	O
sb_skip_white	function
(	O
idx	int
+	O
1	int
,	O
in	pointer
)	O
;	O
if	O
(	O
nxt	long
>=	O
in	pointer
->	O
len	long
)	O
{	O
idx	int
=	O
nxt	long
;	O
break	O
;	O
}	O
}	O
sb_reset	function
(	O
&	O
f	pointer
.	O
actual	struct
)	O
;	O
sb_add_char	function
(	O
&	O
f	pointer
.	O
actual	struct
,	O
in	pointer
->	O
ptr	pointer
[	O
idx	int
]	O
)	O
;	O
++	O
idx	int
;	O
}	O
err	pointer
=	O
macro_expand_body	function
(	O
&	O
sub	struct
,	O
out	pointer
,	O
&	O
f	pointer
,	O
h	pointer
,	O
0	int
)	O
;	O
if	O
(	O
err	pointer
!=	O
NULL	O
)	O
break	O
;	O
if	O
(	O
!	O
irpc	int
)	O
idx	int
=	O
sb_skip_comma	function
(	O
idx	int
,	O
in	pointer
)	O
;	O
else	O
if	O
(	O
!	O
in_quotes	int
)	O
idx	int
=	O
sb_skip_white	function
(	O
idx	int
,	O
in	pointer
)	O
;	O
}	O
}	O
hash_die	function
(	O
h	pointer
)	O
;	O
sb_kill	function
(	O
&	O
f	pointer
.	O
actual	struct
)	O
;	O
sb_kill	function
(	O
&	O
f	pointer
.	O
def	struct
)	O
;	O
sb_kill	function
(	O
&	O
f	pointer
.	O
name	pointer
)	O
;	O
sb_kill	function
(	O
&	O
sub	struct
)	O
;	O
return	O
err	pointer
;	O
}	O
