static	O
void	O
invoke_handler	function
(	O
int	O
,	O
int	O
)	O
;	O
void	O
*	O
sfaslp	pointer
;	O
EXTER	O
unsigned	O
long	O
s4_neg_int	array
[	O
4	int
]	O
,	O
small_neg_int	array
[	O
3	int
]	O
,	O
small_pos_int	array
[	O
3	int
]	O
;	O
handler_function_type	O
our_signal_handler	array
[	O
32	int
]	O
;	O
struct	O
save_for_interrupt	struct
{	O
object	O
free1	array
[	O
32	int
]	O
;	O
object	O
free2	array
[	O
32	int
]	O
;	O
object	O
altfree1	array
[	O
32	int
]	O
;	O
object	O
altfree2	array
[	O
32	int
]	O
;	O
union	O
lispunion	O
buf	int
[	O
32	int
]	O
;	O
struct	O
call_data	O
fcall	struct
;	O
object	O
*	O
vs_top	pointer
,	O
vs_topVAL	int
,	O
*	O
vs_base	pointer
;	O
struct	O
bds_bd	O
*	O
bds_top	pointer
,	O
bds_topVAL	struct
;	O
struct	O
invocation_history	O
*	O
ihs_top	pointer
,	O
ihs_topVAL	struct
;	O
char	O
*	O
token_bufp	pointer
;	O
char	O
token_buf	char
[	O
4	int
*	O
INITIAL_TOKEN_LENGTH	O
]	O
;	O
int	O
token_st_dim	int
;	O
void	O
*	O
save_objects	array
[	O
75	int
]	O
;	O
}	O
;	O
char	O
signals_handled	array
[	O
]	O
=	O
{	O
SIGINT	O
,	O
SIGUSR2	O
,	O
SIGUSR1	O
,	O
SIGIO	O
,	O
SIGALRM	O
,	O
0	int
}	O
;	O
char	O
safety_required	array
[	O
]	O
=	O
{	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
,	O
XX	O
}	O
;	O
void	O
gcl_init_safety	function
(	O
void	O
)	O
{	O
safety_required	array
[	O
SIGINT	O
]	O
=	O
sig_try_to_delay	O
;	O
safety_required	array
[	O
SIGALRM	O
]	O
=	O
sig_normal	O
;	O
}	O
DO_INIT	O
(	O
gcl_init_safety	function
(	O
)	O
;	O
)	O
DEFUN_NEW	function
(	O
"SIGNAL-SAFETY-REQUIRED"	pointer
,	O
object	O
,	O
sSsignal_safety_required	O
,	O
SI	O
,	O
2	int
,	O
2	int
,	O
NONE	O
,	O
OI	O
,	O
IO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
fixnum	O
signo	int
,	O
fixnum	O
safety	O
)	O
,	O
"Set the safety level required for handling SIGNO to SAFETY, or if SAFETY is negative just return the current safety level for that signal number.  Value of 1 means allow interrupt at any place not specifically marked in the code as bad, and value of 2 means allow it only in very SAFE places."	pointer
)	O
{	O
if	O
(	O
signo	int
>	O
sizeof	O
(	O
safety_required	array
)	O
)	O
{	O
FEerror	O
(	O
"Illegal signo:~a."	pointer
,	O
1	int
,	O
make_fixnum	function
(	O
signo	int
)	O
)	O
;	O
}	O
if	O
(	O
safety	O
>=	O
0	int
)	O
safety_required	array
[	O
signo	int
]	O
=	O
safety	O
;	O
return	O
small_fixnum	O
(	O
safety_required	array
[	O
signo	int
]	O
)	O
;	O
}	O
void	O
main_signal_handler	O
(	O
int	O
signo	int
,	O
int	O
a	O
,	O
int	O
b	O
)	O
{	O
int	O
allowed	int
=	O
signals_allowed	O
;	O
if	O
(	O
allowed	int
>=	O
safety_required	array
[	O
signo	int
]	O
)	O
{	O
signals_allowed	O
=	O
sig_none	O
;	O
if	O
(	O
signo	int
==	O
SIGUSR1	O
||	O
signo	int
==	O
SIGIO	O
)	O
{	O
unblock_sigusr_sigio	O
(	O
)	O
;	O
}	O
invoke_handler	function
(	O
signo	int
,	O
allowed	int
)	O
;	O
signals_allowed	O
=	O
allowed	int
;	O
}	O
else	O
{	O
signals_pending	O
|=	O
signal_mask	function
(	O
signo	int
)	O
;	O
alarm	function
(	O
1	int
)	O
;	O
}	O
return	O
;	O
}	O
static	O
void	O
before_interrupt	function
(	O
struct	O
save_for_interrupt	struct
*	O
p	pointer
,	O
int	O
allowed	int
)	O
;	O
static	O
void	O
after_interrupt	function
(	O
struct	O
save_for_interrupt	struct
*	O
p	pointer
,	O
int	O
allowed	int
)	O
;	O
static	O
void	O
invoke_handler	function
(	O
int	O
signo	int
,	O
int	O
allowed	int
)	O
{	O
struct	O
save_for_interrupt	struct
buf	int
;	O
before_interrupt	function
(	O
&	O
buf	int
,	O
allowed	int
)	O
;	O
signals_pending	O
&=	O
~	O
(	O
signal_mask	function
(	O
signo	int
)	O
)	O
;	O
{	O
int	O
prev_in_handler	int
=	O
in_signal_handler	O
;	O
in_signal_handler	O
|=	O
(	O
allowed	int
<=	O
sig_normal	O
?	O
1	int
:	O
0	int
)	O
;	O
signals_allowed	O
=	O
allowed	int
;	O
our_signal_handler	array
[	O
signo	int
]	O
(	O
signo	int
)	O
;	O
signals_allowed	O
=	O
0	int
;	O
in_signal_handler	O
=	O
prev_in_handler	int
;	O
after_interrupt	function
(	O
&	O
buf	int
,	O
allowed	int
)	O
;	O
}	O
}	O
int	O
tok_leng	int
;	O
static	O
void	O
before_interrupt	function
(	O
struct	O
save_for_interrupt	struct
*	O
p	pointer
,	O
int	O
allowed	int
)	O
{	O
int	O
i	int
;	O
if	O
(	O
allowed	int
<	O
sig_safe	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
t_end	O
;	O
i	int
++	O
)	O
{	O
struct	O
typemanager	O
*	O
ad	pointer
=	O
&	O
tm_table	O
[	O
i	int
]	O
;	O
{	O
SS1	O
(	O
p	pointer
->	O
free1	array
[	O
i	int
]	O
,	O
ad	pointer
->	O
tm_free	O
)	O
;	O
if	O
(	O
p	pointer
->	O
free1	array
[	O
i	int
]	O
)	O
{	O
char	O
*	O
beg	pointer
=	O
(	O
char	O
*	O
)	O
(	O
p	pointer
->	O
free1	array
[	O
i	int
]	O
)	O
;	O
object	O
x	O
=	O
(	O
object	O
)	O
beg	pointer
;	O
int	O
amt	int
=	O
ad	pointer
->	O
tm_size	O
;	O
SS1	O
(	O
p	pointer
->	O
free2	array
[	O
i	int
]	O
,	O
OBJ_LINK	function
(	O
p	pointer
->	O
free1	array
[	O
i	int
]	O
)	O
)	O
;	O
ad	pointer
->	O
tm_nfree	O
--	O
;	O
bcopy	function
(	O
beg	pointer
,	O
&	O
(	O
p	pointer
->	O
buf	int
[	O
i	int
]	O
)	O
,	O
amt	int
)	O
;	O
bzero	function
(	O
beg	pointer
+	O
sizeof	O
(	O
struct	O
freelist	O
)	O
,	O
amt	int
-	O
sizeof	O
(	O
struct	O
freelist	O
)	O
)	O
;	O
make_unfree	function
(	O
x	O
)	O
;	O
if	O
(	O
p	pointer
->	O
free2	array
[	O
i	int
]	O
)	O
{	O
x	O
=	O
(	O
object	O
)	O
p	pointer
->	O
free2	array
[	O
i	int
]	O
;	O
beg	pointer
=	O
(	O
char	O
*	O
)	O
x	O
;	O
make_unfree	function
(	O
x	O
)	O
;	O
bzero	function
(	O
beg	pointer
+	O
sizeof	O
(	O
struct	O
freelist	O
)	O
,	O
amt	int
-	O
sizeof	O
(	O
struct	O
freelist	O
)	O
)	O
;	O
SS1	O
(	O
ad	pointer
->	O
tm_free	O
,	O
OBJ_LINK	function
(	O
p	pointer
->	O
free2	array
[	O
i	int
]	O
)	O
)	O
;	O
ad	pointer
->	O
tm_nfree	O
--	O
;	O
}	O
else	O
{	O
SS1	O
(	O
ad	pointer
->	O
tm_free	O
,	O
OBJ_LINK	function
(	O
p	pointer
->	O
free1	array
[	O
i	int
]	O
)	O
)	O
;	O
}	O
}	O
}	O
}	O
}	O
SS1	O
(	O
p	pointer
->	O
fcall	struct
,	O
fcall	struct
)	O
;	O
SS1	O
(	O
p	pointer
->	O
vs_top	pointer
,	O
vs_top	pointer
)	O
;	O
SS1	O
(	O
p	pointer
->	O
vs_topVAL	int
,	O
*	O
vs_top	pointer
)	O
;	O
SS1	O
(	O
p	pointer
->	O
vs_base	pointer
,	O
vs_base	pointer
)	O
;	O
SS1	O
(	O
p	pointer
->	O
bds_top	pointer
,	O
bds_top	pointer
)	O
;	O
SS1	O
(	O
p	pointer
->	O
bds_topVAL	struct
,	O
*	O
bds_top	pointer
)	O
;	O
SS1	O
(	O
p	pointer
->	O
ihs_top	pointer
,	O
ihs_top	pointer
)	O
;	O
SS1	O
(	O
p	pointer
->	O
ihs_topVAL	struct
,	O
*	O
ihs_top	pointer
)	O
;	O
{	O
void	O
*	O
*	O
pp	pointer
=	O
p	pointer
->	O
save_objects	array
;	O
if	O
(	O
(	O
pp	pointer
-	O
(	O
&	O
(	O
p	pointer
->	O
save_objects	array
)	O
[	O
0	int
]	O
)	O
)	O
>=	O
(	O
sizeof	O
(	O
p	pointer
->	O
save_objects	array
)	O
/	O
sizeof	O
(	O
void	O
*	O
)	O
)	O
)	O
abort	function
(	O
)	O
;	O
}	O
p	pointer
->	O
token_st_dim	int
=	O
MINN	O
(	O
token	O
->	O
st	O
.	O
st_dim	O
,	O
tok_leng	int
+	O
1	int
)	O
;	O
if	O
(	O
p	pointer
->	O
token_st_dim	int
<	O
sizeof	O
(	O
p	pointer
->	O
token_buf	char
)	O
)	O
p	pointer
->	O
token_bufp	pointer
=	O
p	pointer
->	O
token_buf	char
;	O
else	O
{	O
p	pointer
->	O
token_bufp	pointer
=	O
(	O
void	O
*	O
)	O
alloca	function
(	O
p	pointer
->	O
token_st_dim	int
)	O
;	O
}	O
bcopy	function
(	O
token	O
->	O
st	O
.	O
st_self	O
,	O
p	pointer
->	O
token_bufp	pointer
,	O
p	pointer
->	O
token_st_dim	int
)	O
;	O
}	O
static	O
void	O
after_interrupt	function
(	O
struct	O
save_for_interrupt	struct
*	O
p	pointer
,	O
int	O
allowed	int
)	O
{	O
int	O
i	int
;	O
if	O
(	O
allowed	int
<	O
sig_safe	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
t_end	O
;	O
i	int
++	O
)	O
{	O
struct	O
typemanager	O
*	O
ad	pointer
=	O
&	O
tm_table	O
[	O
i	int
]	O
;	O
object	O
current_fl	O
=	O
ad	pointer
->	O
tm_free	O
;	O
{	O
RS1	O
(	O
p	pointer
->	O
free1	array
[	O
i	int
]	O
,	O
ad	pointer
->	O
tm_free	O
)	O
;	O
if	O
(	O
p	pointer
->	O
free1	array
[	O
i	int
]	O
)	O
{	O
char	O
*	O
beg	pointer
=	O
(	O
char	O
*	O
)	O
(	O
p	pointer
->	O
free1	array
[	O
i	int
]	O
)	O
;	O
object	O
x	O
=	O
(	O
object	O
)	O
beg	pointer
;	O
int	O
amt	int
=	O
ad	pointer
->	O
tm_size	O
;	O
RS1	O
(	O
p	pointer
->	O
free2	array
[	O
i	int
]	O
,	O
(	O
p	pointer
->	O
free1	array
[	O
i	int
]	O
)	O
)	O
;	O
if	O
(	O
is_marked_or_free	function
(	O
x	O
)	O
)	O
error	function
(	O
"should not be free"	pointer
)	O
;	O
bcopy	function
(	O
&	O
(	O
p	pointer
->	O
buf	int
[	O
i	int
]	O
)	O
,	O
beg	pointer
,	O
amt	int
)	O
;	O
if	O
(	O
p	pointer
->	O
free2	array
[	O
i	int
]	O
)	O
{	O
x	O
=	O
(	O
object	O
)	O
p	pointer
->	O
free2	array
[	O
i	int
]	O
;	O
if	O
(	O
is_marked_or_free	function
(	O
x	O
)	O
)	O
error	function
(	O
"should not be free"	pointer
)	O
;	O
make_free	function
(	O
x	O
)	O
;	O
F_LINK	function
(	O
F_LINK	function
(	O
ad	pointer
->	O
tm_free	O
)	O
)	O
=	O
(	O
long	O
)	O
current_fl	O
;	O
ad	pointer
->	O
tm_nfree	O
+=	O
2	int
;	O
}	O
else	O
ad	pointer
->	O
tm_nfree	O
=	O
1	int
;	O
}	O
else	O
ad	pointer
->	O
tm_nfree	O
=	O
0	int
;	O
}	O
}	O
}	O
RS1	O
(	O
p	pointer
->	O
fcall	struct
,	O
fcall	struct
)	O
;	O
RS1	O
(	O
p	pointer
->	O
vs_top	pointer
,	O
vs_top	pointer
)	O
;	O
RS1	O
(	O
p	pointer
->	O
vs_topVAL	int
,	O
*	O
vs_top	pointer
)	O
;	O
RS1	O
(	O
p	pointer
->	O
vs_base	pointer
,	O
vs_base	pointer
)	O
;	O
RS1	O
(	O
p	pointer
->	O
bds_top	pointer
,	O
bds_top	pointer
)	O
;	O
RS1	O
(	O
p	pointer
->	O
bds_topVAL	struct
,	O
*	O
bds_top	pointer
)	O
;	O
RS1	O
(	O
p	pointer
->	O
ihs_top	pointer
,	O
ihs_top	pointer
)	O
;	O
RS1	O
(	O
p	pointer
->	O
ihs_topVAL	struct
,	O
*	O
ihs_top	pointer
)	O
;	O
{	O
void	O
*	O
*	O
pp	pointer
=	O
p	pointer
->	O
save_objects	array
;	O
}	O
bcopy	function
(	O
p	pointer
->	O
token_bufp	pointer
,	O
token	O
->	O
st	O
.	O
st_self	O
,	O
p	pointer
->	O
token_st_dim	int
)	O
;	O
}	O
void	O
raise_pending_signals	function
(	O
int	O
cond	int
)	O
{	O
unsigned	O
int	O
allowed	int
=	O
signals_allowed	O
;	O
if	O
(	O
cond	int
==	O
sig_use_signals_allowed_value	O
)	O
if	O
(	O
cond	int
==	O
sig_none	O
||	O
interrupt_enable	O
==	O
0	int
)	O
return	O
;	O
AGAIN	O
:	O
{	O
unsigned	O
int	O
pending	int
=	O
signals_pending	O
;	O
char	O
*	O
p	pointer
=	O
signals_handled	array
;	O
if	O
(	O
pending	int
)	O
while	O
(	O
*	O
p	pointer
)	O
{	O
if	O
(	O
signal_mask	function
(	O
*	O
p	pointer
)	O
&	O
pending	int
&&	O
cond	int
>=	O
safety_required	array
[	O
(	O
unsigned	O
char	O
)	O
*	O
p	pointer
]	O
)	O
{	O
signals_pending	O
&=	O
~	O
(	O
signal_mask	function
(	O
*	O
p	pointer
)	O
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
SIGALRM	O
&&	O
cond	int
>=	O
sig_safe	O
)	O
{	O
alarm	function
(	O
0	int
)	O
;	O
}	O
else	O
invoke_handler	function
(	O
*	O
p	pointer
,	O
cond	int
)	O
;	O
goto	O
AGAIN	O
;	O
}	O
p	pointer
++	O
;	O
}	O
signals_allowed	O
=	O
allowed	int
;	O
return	O
;	O
}	O
}	O
DEFUN_NEW	function
(	O
"ALLOW-SIGNAL"	pointer
,	O
object	O
,	O
fSallow_signal	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OI	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
fixnum	O
n	O
)	O
,	O
"Install the default signal handler on signal N"	pointer
)	O
{	O
signals_allowed	O
|=	O
signal_mask	function
(	O
n	O
)	O
;	O
unblock_signals	function
(	O
n	O
,	O
n	O
)	O
;	O
if	O
(	O
our_signal_handler	array
[	O
n	O
]	O
)	O
{	O
gcl_signal	function
(	O
n	O
,	O
our_signal_handler	array
[	O
n	O
]	O
)	O
;	O
return	O
make_fixnum	function
(	O
1	int
)	O
;	O
}	O
else	O
return	O
make_fixnum	function
(	O
0	int
)	O
;	O
}	O
