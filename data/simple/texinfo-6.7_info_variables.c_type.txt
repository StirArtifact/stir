static	O
VARIABLE_ALIST	struct
*	O
read_variable_name	function
(	O
char	O
*	O
prompt	pointer
,	O
WINDOW	struct
*	O
window	pointer
)	O
;	O
static	O
char	O
*	O
on_off_choices	array
[	O
]	O
=	O
{	O
"Off"	pointer
,	O
"On"	pointer
,	O
NULL	O
}	O
;	O
static	O
char	O
*	O
mouse_choices	array
[	O
]	O
=	O
{	O
"Off"	pointer
,	O
"normal-tracking"	pointer
,	O
NULL	O
}	O
;	O
static	O
char	O
*	O
follow_strategy_choices	array
[	O
]	O
=	O
{	O
"remain"	pointer
,	O
"path"	pointer
,	O
NULL	O
}	O
;	O
static	O
char	O
*	O
nodeline_choices	array
[	O
]	O
=	O
{	O
"no"	pointer
,	O
"print"	pointer
,	O
"pointers"	pointer
,	O
NULL	O
}	O
;	O
static	O
char	O
*	O
info_scroll_choices	array
[	O
]	O
=	O
{	O
"Continuous"	pointer
,	O
"Next Only"	pointer
,	O
"Page Only"	pointer
,	O
NULL	O
}	O
;	O
static	O
char	O
*	O
scroll_last_node_choices	array
[	O
]	O
=	O
{	O
"Stop"	pointer
,	O
"Top"	pointer
,	O
NULL	O
}	O
;	O
static	O
char	O
*	O
rendition_choices	array
[	O
]	O
=	O
{	O
"black"	pointer
,	O
"red"	pointer
,	O
"green"	pointer
,	O
"yellow"	pointer
,	O
"blue"	pointer
,	O
"magenta"	pointer
,	O
"cyan"	pointer
,	O
"white"	pointer
,	O
"nocolour"	pointer
,	O
"bgblack"	pointer
,	O
"bgred"	pointer
,	O
"bggreen"	pointer
,	O
"bgyellow"	pointer
,	O
"bgblue"	pointer
,	O
"bgmagenta"	pointer
,	O
"bgcyan"	pointer
,	O
"bgwhite"	pointer
,	O
"nobgcolour"	pointer
,	O
"underline"	pointer
,	O
"nounderline"	pointer
,	O
"standout"	pointer
,	O
"nostandout"	pointer
,	O
"bold"	pointer
,	O
"regular"	pointer
,	O
"blink"	pointer
,	O
"noblink"	pointer
,	O
NULL	O
}	O
;	O
static	O
int	O
*	O
highlight_searches	pointer
;	O
VARIABLE_ALIST	struct
info_variables	array
[	O
]	O
=	O
{	O
{	O
"automatic-footnotes"	pointer
,	O
N_	O
(	O
"When \"On\", footnotes appear and disappear automatically"	pointer
)	O
,	O
&	O
auto_footnotes_p	int
,	O
(	O
char	O
*	O
*	O
)	O
on_off_choices	array
}	O
,	O
{	O
"automatic-tiling"	pointer
,	O
N_	O
(	O
"When \"On\", creating or deleting a window resizes other windows"	pointer
)	O
,	O
&	O
auto_tiling_p	int
,	O
(	O
char	O
*	O
*	O
)	O
on_off_choices	array
}	O
,	O
{	O
"visible-bell"	pointer
,	O
N_	O
(	O
"When \"On\", flash the screen instead of ringing the bell"	pointer
)	O
,	O
&	O
terminal_use_visible_bell_p	int
,	O
(	O
char	O
*	O
*	O
)	O
on_off_choices	array
}	O
,	O
{	O
"errors-ring-bell"	pointer
,	O
N_	O
(	O
"When \"On\", errors cause the bell to ring"	pointer
)	O
,	O
&	O
info_error_rings_bell_p	int
,	O
(	O
char	O
*	O
*	O
)	O
on_off_choices	array
}	O
,	O
{	O
"gc-compressed-files"	pointer
,	O
N_	O
(	O
"When \"On\", Info garbage collects files which had to be uncompressed"	pointer
)	O
,	O
&	O
gc_compressed_files	int
,	O
(	O
char	O
*	O
*	O
)	O
on_off_choices	array
}	O
,	O
{	O
"show-index-match"	pointer
,	O
N_	O
(	O
"When \"On\", the portion of the matched search string is highlighted"	pointer
)	O
,	O
&	O
show_index_match	int
,	O
(	O
char	O
*	O
*	O
)	O
on_off_choices	array
}	O
,	O
{	O
"scroll-behaviour"	pointer
,	O
N_	O
(	O
"Controls what happens when scrolling is requested at the end of a node"	pointer
)	O
,	O
&	O
info_scroll_behaviour	int
,	O
(	O
char	O
*	O
*	O
)	O
info_scroll_choices	array
}	O
,	O
{	O
"scroll-behavior"	pointer
,	O
N_	O
(	O
"Same as scroll-behaviour"	pointer
)	O
,	O
&	O
info_scroll_behaviour	int
,	O
(	O
char	O
*	O
*	O
)	O
info_scroll_choices	array
}	O
,	O
{	O
"scroll-step"	pointer
,	O
N_	O
(	O
"The number lines to scroll when the cursor moves out of the window"	pointer
)	O
,	O
&	O
window_scroll_step	int
,	O
NULL	O
}	O
,	O
{	O
"cursor-movement-scrolls"	pointer
,	O
N_	O
(	O
"Controls whether scroll-behavior affects cursor movement commands"	pointer
)	O
,	O
&	O
cursor_movement_scrolls_p	int
,	O
(	O
char	O
*	O
*	O
)	O
on_off_choices	array
}	O
,	O
{	O
"ISO-Latin"	pointer
,	O
N_	O
(	O
"When \"On\", Info accepts and displays ISO Latin characters"	pointer
)	O
,	O
&	O
ISO_Latin_p	int
,	O
(	O
char	O
*	O
*	O
)	O
on_off_choices	array
}	O
,	O
{	O
"scroll-last-node"	pointer
,	O
N_	O
(	O
"What to do when a scrolling command is issued at the end of the "	pointer
"last node"	pointer
)	O
,	O
&	O
scroll_last_node	int
,	O
(	O
char	O
*	O
*	O
)	O
scroll_last_node_choices	array
}	O
,	O
{	O
"min-search-length"	pointer
,	O
N_	O
(	O
"Minimal length of a search string"	pointer
)	O
,	O
&	O
min_search_length	int
,	O
NULL	O
}	O
,	O
{	O
"search-skip-screen"	pointer
,	O
N_	O
(	O
"Skip current window when searching"	pointer
)	O
,	O
&	O
search_skip_screen_p	int
,	O
(	O
char	O
*	O
*	O
)	O
on_off_choices	array
}	O
,	O
{	O
"infopath-no-defaults"	pointer
,	O
N_	O
(	O
"Exclude default directories from file search path"	pointer
)	O
,	O
&	O
infopath_no_defaults_p	int
,	O
(	O
char	O
*	O
*	O
)	O
on_off_choices	array
}	O
,	O
{	O
"hide-note-references"	pointer
,	O
N_	O
(	O
"Hide some Info file syntax in the text of nodes"	pointer
)	O
,	O
&	O
preprocess_nodes_p	int
,	O
(	O
char	O
*	O
*	O
)	O
on_off_choices	array
}	O
,	O
{	O
"key-time"	pointer
,	O
N_	O
(	O
"Length of time in milliseconds to wait for the next byte in a sequence indicating that a key has been pressed"	pointer
)	O
,	O
&	O
key_time	int
,	O
NULL	O
}	O
,	O
{	O
"mouse"	pointer
,	O
N_	O
(	O
"Method to use to track mouse events"	pointer
)	O
,	O
&	O
mouse_protocol	int
,	O
(	O
char	O
*	O
*	O
)	O
mouse_choices	array
}	O
,	O
{	O
"follow-strategy"	pointer
,	O
N_	O
(	O
"How to follow a cross-reference"	pointer
)	O
,	O
&	O
follow_strategy	int
,	O
(	O
char	O
*	O
*	O
)	O
follow_strategy_choices	array
}	O
,	O
{	O
"highlight-searches"	pointer
,	O
N_	O
(	O
"Highlight search matches"	pointer
)	O
,	O
&	O
highlight_searches	pointer
,	O
(	O
char	O
*	O
*	O
)	O
on_off_choices	array
}	O
,	O
{	O
"link-style"	pointer
,	O
N_	O
(	O
"Styles for links"	pointer
)	O
,	O
&	O
ref_rendition	struct
,	O
(	O
char	O
*	O
*	O
)	O
rendition_choices	array
}	O
,	O
{	O
"active-link-style"	pointer
,	O
N_	O
(	O
"Styles for active links"	pointer
)	O
,	O
&	O
hl_ref_rendition	struct
,	O
(	O
char	O
*	O
*	O
)	O
rendition_choices	array
}	O
,	O
{	O
"match-style"	pointer
,	O
N_	O
(	O
"Styles for search matches"	pointer
)	O
,	O
&	O
match_rendition	struct
,	O
(	O
char	O
*	O
*	O
)	O
rendition_choices	array
}	O
,	O
{	O
"nodeline"	pointer
,	O
N_	O
(	O
"How to print the information line at the start of a node"	pointer
)	O
,	O
&	O
nodeline_print	int
,	O
(	O
char	O
*	O
*	O
)	O
nodeline_choices	array
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
char	O
*	O
rendition_to_string	function
(	O
RENDITION	struct
*	O
rendition	pointer
)	O
{	O
static	O
char	O
string	pointer
[	O
8	int
+	O
1	int
+	O
10	int
+	O
1	int
+	O
11	int
+	O
1	int
+	O
10	int
+	O
1	int
+	O
7	int
+	O
1	int
+	O
7	int
+	O
1	int
]	O
;	O
unsigned	O
long	O
style	int
;	O
static	O
const	O
char	O
*	O
fg	array
[	O
]	O
=	O
{	O
"black"	pointer
,	O
"red"	pointer
,	O
"green"	pointer
,	O
"yellow"	pointer
,	O
"blue"	pointer
,	O
"magenta"	pointer
,	O
"cyan"	pointer
,	O
"white"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
bg	array
[	O
]	O
=	O
{	O
"bgblack"	pointer
,	O
"bgred"	pointer
,	O
"bggreen"	pointer
,	O
"bgyellow"	pointer
,	O
"bgblue"	pointer
,	O
"bgmagenta"	pointer
,	O
"bgcyan"	pointer
,	O
"bgwhite"	pointer
}	O
;	O
*	O
string	pointer
=	O
'\0'	O
;	O
if	O
(	O
rendition	pointer
->	O
mask	long
&	O
BLINK_MASK	int
)	O
strcat	function
(	O
string	pointer
,	O
rendition	pointer
->	O
value	union
&	O
BLINK_MASK	int
?	O
"blink"	pointer
:	O
"noblink"	pointer
)	O
;	O
if	O
(	O
rendition	pointer
->	O
mask	long
&	O
BOLD_MASK	int
)	O
{	O
if	O
(	O
*	O
string	pointer
!=	O
'\0'	O
)	O
strcat	function
(	O
string	pointer
,	O
","	pointer
)	O
;	O
strcat	function
(	O
string	pointer
,	O
rendition	pointer
->	O
value	union
&	O
BOLD_MASK	int
?	O
"bold"	pointer
:	O
"nobold"	pointer
)	O
;	O
}	O
if	O
(	O
rendition	pointer
->	O
mask	long
&	O
STANDOUT_MASK	int
)	O
{	O
if	O
(	O
*	O
string	pointer
!=	O
'\0'	O
)	O
strcat	function
(	O
string	pointer
,	O
","	pointer
)	O
;	O
strcat	function
(	O
string	pointer
,	O
rendition	pointer
->	O
value	union
&	O
STANDOUT_MASK	int
?	O
"standout"	pointer
:	O
"nostandout"	pointer
)	O
;	O
}	O
if	O
(	O
rendition	pointer
->	O
mask	long
&	O
UNDERLINE_MASK	int
)	O
{	O
if	O
(	O
*	O
string	pointer
!=	O
'\0'	O
)	O
strcat	function
(	O
string	pointer
,	O
","	pointer
)	O
;	O
strcat	function
(	O
string	pointer
,	O
rendition	pointer
->	O
value	union
&	O
UNDERLINE_MASK	int
?	O
"underline"	pointer
:	O
"nounderline"	pointer
)	O
;	O
}	O
if	O
(	O
rendition	pointer
->	O
mask	long
&	O
COLOUR_MASK	int
)	O
{	O
if	O
(	O
*	O
string	pointer
!=	O
'\0'	O
)	O
strcat	function
(	O
string	pointer
,	O
","	pointer
)	O
;	O
style	int
=	O
rendition	pointer
->	O
value	union
&	O
COLOUR_MASK	int
;	O
strcat	function
(	O
string	pointer
,	O
style	int
>=	O
8	int
?	O
fg	array
[	O
style	int
-	O
8	int
]	O
:	O
"nocolour"	pointer
)	O
;	O
}	O
if	O
(	O
rendition	pointer
->	O
mask	long
&	O
BGCOLOUR_MASK	int
)	O
{	O
if	O
(	O
*	O
string	pointer
!=	O
'\0'	O
)	O
strcat	function
(	O
string	pointer
,	O
","	pointer
)	O
;	O
style	int
=	O
(	O
rendition	pointer
->	O
value	union
&	O
BGCOLOUR_MASK	int
)	O
>>	O
9	int
;	O
strcat	function
(	O
string	pointer
,	O
style	int
>=	O
8	int
?	O
bg	array
[	O
style	int
-	O
8	int
]	O
:	O
"nobgcolour"	pointer
)	O
;	O
}	O
return	O
string	pointer
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
describe_variable	function
,	O
_	O
(	O
"Explain the use of a variable"	pointer
)	O
)	O
{	O
VARIABLE_ALIST	struct
*	O
var	pointer
;	O
char	O
*	O
description	pointer
;	O
var	pointer
=	O
read_variable_name	function
(	O
_	O
(	O
"Describe variable: "	pointer
)	O
,	O
window	pointer
)	O
;	O
if	O
(	O
!	O
var	pointer
)	O
return	O
;	O
if	O
(	O
var	pointer
->	O
choices	pointer
)	O
asprintf	function
(	O
&	O
description	pointer
,	O
"%s (%s): %s."	pointer
,	O
var	pointer
->	O
name	pointer
,	O
var	pointer
->	O
value	union
==	O
&	O
highlight_searches	pointer
?	O
on_off_choices	array
[	O
match_rendition	struct
.	O
mask	long
!=	O
0	int
]	O
:	O
var	pointer
->	O
choices	pointer
==	O
(	O
char	O
*	O
*	O
)	O
&	O
rendition_choices	array
?	O
rendition_to_string	function
(	O
var	pointer
->	O
value	union
)	O
:	O
var	pointer
->	O
choices	pointer
[	O
*	O
(	O
int	O
*	O
)	O
var	pointer
->	O
value	union
]	O
,	O
_	O
(	O
var	pointer
->	O
doc	pointer
)	O
)	O
;	O
else	O
asprintf	function
(	O
&	O
description	pointer
,	O
"%s (%d): %s."	pointer
,	O
var	pointer
->	O
name	pointer
,	O
*	O
(	O
int	O
*	O
)	O
var	pointer
->	O
value	union
,	O
_	O
(	O
var	pointer
->	O
doc	pointer
)	O
)	O
;	O
window_message_in_echo_area	function
(	O
"%s"	pointer
,	O
description	pointer
)	O
;	O
free	function
(	O
description	pointer
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
set_variable	function
,	O
_	O
(	O
"Set the value of an Info variable"	pointer
)	O
)	O
{	O
VARIABLE_ALIST	struct
*	O
var	pointer
;	O
char	O
*	O
line	pointer
;	O
char	O
prompt	pointer
[	O
100	int
]	O
;	O
var	pointer
=	O
read_variable_name	function
(	O
_	O
(	O
"Set variable: "	pointer
)	O
,	O
window	pointer
)	O
;	O
if	O
(	O
!	O
var	pointer
)	O
return	O
;	O
if	O
(	O
!	O
var	pointer
->	O
choices	pointer
)	O
{	O
int	O
potential_value	int
;	O
if	O
(	O
info_explicit_arg	int
||	O
count	pointer
!=	O
1	int
)	O
potential_value	int
=	O
count	pointer
;	O
else	O
potential_value	int
=	O
*	O
(	O
int	O
*	O
)	O
(	O
var	pointer
->	O
value	union
)	O
;	O
sprintf	function
(	O
prompt	pointer
,	O
_	O
(	O
"Set %s to value (%d): "	pointer
)	O
,	O
var	pointer
->	O
name	pointer
,	O
potential_value	int
)	O
;	O
line	pointer
=	O
info_read_in_echo_area	function
(	O
prompt	pointer
)	O
;	O
if	O
(	O
!	O
line	pointer
)	O
return	O
;	O
canonicalize_whitespace	function
(	O
line	pointer
)	O
;	O
set_variable_to_value	function
(	O
var	pointer
,	O
line	pointer
,	O
SET_IN_SESSION	int
)	O
;	O
free	function
(	O
line	pointer
)	O
;	O
}	O
else	O
{	O
register	O
int	O
i	int
;	O
REFERENCE	struct
*	O
*	O
array	pointer
=	O
NULL	O
;	O
size_t	long
array_index	long
=	O
0	int
;	O
size_t	long
array_slots	long
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
var	pointer
->	O
choices	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
REFERENCE	struct
*	O
entry	pointer
;	O
entry	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
REFERENCE	struct
)	O
)	O
;	O
entry	pointer
->	O
label	pointer
=	O
xstrdup	function
(	O
var	pointer
->	O
choices	pointer
[	O
i	int
]	O
)	O
;	O
entry	pointer
->	O
nodename	pointer
=	O
NULL	O
;	O
entry	pointer
->	O
filename	pointer
=	O
NULL	O
;	O
add_pointer_to_array	O
(	O
entry	pointer
,	O
array_index	long
,	O
array	pointer
,	O
array_slots	long
,	O
10	int
)	O
;	O
}	O
sprintf	function
(	O
prompt	pointer
,	O
_	O
(	O
"Set %s to value (%s): "	pointer
)	O
,	O
var	pointer
->	O
name	pointer
,	O
var	pointer
->	O
value	union
==	O
&	O
highlight_searches	pointer
?	O
on_off_choices	array
[	O
match_rendition	struct
.	O
mask	long
!=	O
0	int
]	O
:	O
var	pointer
->	O
choices	pointer
==	O
(	O
char	O
*	O
*	O
)	O
&	O
rendition_choices	array
?	O
rendition_to_string	function
(	O
var	pointer
->	O
value	union
)	O
:	O
var	pointer
->	O
choices	pointer
[	O
*	O
(	O
int	O
*	O
)	O
(	O
var	pointer
->	O
value	union
)	O
]	O
)	O
;	O
if	O
(	O
var	pointer
->	O
choices	pointer
==	O
(	O
char	O
*	O
*	O
)	O
&	O
rendition_choices	array
)	O
line	pointer
=	O
info_read_maybe_completing	function
(	O
prompt	pointer
,	O
array	pointer
)	O
;	O
else	O
line	pointer
=	O
info_read_completing_in_echo_area	function
(	O
prompt	pointer
,	O
array	pointer
)	O
;	O
info_free_references	function
(	O
array	pointer
)	O
;	O
if	O
(	O
!	O
line	pointer
)	O
{	O
info_abort_key	function
(	O
active_window	pointer
,	O
0	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
*	O
line	pointer
)	O
{	O
free	function
(	O
line	pointer
)	O
;	O
return	O
;	O
}	O
set_variable_to_value	function
(	O
var	pointer
,	O
line	pointer
,	O
SET_IN_SESSION	int
)	O
;	O
}	O
}	O
VARIABLE_ALIST	struct
*	O
variable_by_name	function
(	O
char	O
*	O
name	pointer
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
info_variables	array
[	O
i	int
]	O
.	O
name	pointer
;	O
i	int
++	O
)	O
if	O
(	O
strcmp	function
(	O
info_variables	array
[	O
i	int
]	O
.	O
name	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
!	O
info_variables	array
[	O
i	int
]	O
.	O
name	pointer
)	O
return	O
NULL	O
;	O
else	O
return	O
&	O
info_variables	array
[	O
i	int
]	O
;	O
}	O
static	O
VARIABLE_ALIST	struct
*	O
read_variable_name	function
(	O
char	O
*	O
prompt	pointer
,	O
WINDOW	struct
*	O
window	pointer
)	O
{	O
char	O
*	O
line	pointer
;	O
REFERENCE	struct
*	O
*	O
variables	pointer
;	O
variables	pointer
=	O
make_variable_completions_array	function
(	O
)	O
;	O
line	pointer
=	O
info_read_completing_in_echo_area	function
(	O
prompt	pointer
,	O
variables	pointer
)	O
;	O
info_free_references	function
(	O
variables	pointer
)	O
;	O
if	O
(	O
!	O
line	pointer
)	O
{	O
info_abort_key	function
(	O
active_window	pointer
,	O
0	int
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
!	O
*	O
line	pointer
)	O
{	O
free	function
(	O
line	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
variable_by_name	function
(	O
line	pointer
)	O
;	O
}	O
REFERENCE	struct
*	O
*	O
make_variable_completions_array	function
(	O
void	O
)	O
{	O
register	O
int	O
i	int
;	O
REFERENCE	struct
*	O
*	O
array	pointer
=	O
NULL	O
;	O
size_t	long
array_index	long
=	O
0	int
,	O
array_slots	long
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
info_variables	array
[	O
i	int
]	O
.	O
name	pointer
;	O
i	int
++	O
)	O
{	O
REFERENCE	struct
*	O
entry	pointer
;	O
entry	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
REFERENCE	struct
)	O
)	O
;	O
entry	pointer
->	O
label	pointer
=	O
xstrdup	function
(	O
info_variables	array
[	O
i	int
]	O
.	O
name	pointer
)	O
;	O
entry	pointer
->	O
nodename	pointer
=	O
NULL	O
;	O
entry	pointer
->	O
filename	pointer
=	O
NULL	O
;	O
add_pointer_to_array	O
(	O
entry	pointer
,	O
array_index	long
,	O
array	pointer
,	O
array_slots	long
,	O
200	int
)	O
;	O
}	O
return	O
array	pointer
;	O
}	O
int	O
set_variable_to_value	function
(	O
VARIABLE_ALIST	struct
*	O
var	pointer
,	O
char	O
*	O
value	union
,	O
int	O
where	int
)	O
{	O
if	O
(	O
var	pointer
->	O
where_set	int
>	O
where	int
)	O
return	O
1	int
;	O
if	O
(	O
var	pointer
->	O
choices	pointer
)	O
{	O
register	O
int	O
j	int
;	O
if	O
(	O
var	pointer
->	O
value	union
==	O
&	O
highlight_searches	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
on_off_choices	array
[	O
0	int
]	O
,	O
value	union
)	O
==	O
0	int
)	O
{	O
match_rendition	struct
.	O
mask	long
=	O
0	int
;	O
match_rendition	struct
.	O
value	union
=	O
0	int
;	O
}	O
else	O
{	O
match_rendition	struct
.	O
mask	long
=	O
STANDOUT_MASK	int
;	O
match_rendition	struct
.	O
value	union
=	O
STANDOUT_MASK	int
;	O
}	O
}	O
else	O
if	O
(	O
var	pointer
->	O
choices	pointer
!=	O
(	O
char	O
*	O
*	O
)	O
&	O
rendition_choices	array
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
var	pointer
->	O
choices	pointer
[	O
j	int
]	O
;	O
j	int
++	O
)	O
if	O
(	O
strcmp	function
(	O
var	pointer
->	O
choices	pointer
[	O
j	int
]	O
,	O
value	union
)	O
==	O
0	int
)	O
{	O
*	O
(	O
int	O
*	O
)	O
var	pointer
->	O
value	union
=	O
j	int
;	O
var	pointer
->	O
where_set	int
=	O
where	int
;	O
return	O
1	int
;	O
}	O
}	O
else	O
{	O
static	O
struct	O
{	O
unsigned	O
long	O
mask	long
;	O
unsigned	O
long	O
value	union
;	O
char	O
*	O
name	pointer
;	O
}	O
styles	array
[	O
]	O
=	O
{	O
COLOUR_MASK	int
,	O
COLOUR_BLACK	O
,	O
"black"	pointer
,	O
COLOUR_MASK	int
,	O
COLOUR_RED	O
,	O
"red"	pointer
,	O
COLOUR_MASK	int
,	O
COLOUR_GREEN	O
,	O
"green"	pointer
,	O
COLOUR_MASK	int
,	O
COLOUR_YELLOW	O
,	O
"yellow"	pointer
,	O
COLOUR_MASK	int
,	O
COLOUR_BLUE	O
,	O
"blue"	pointer
,	O
COLOUR_MASK	int
,	O
COLOUR_MAGENTA	O
,	O
"magenta"	pointer
,	O
COLOUR_MASK	int
,	O
COLOUR_CYAN	O
,	O
"cyan"	pointer
,	O
COLOUR_MASK	int
,	O
COLOUR_WHITE	O
,	O
"white"	pointer
,	O
COLOUR_MASK	int
,	O
0	int
,	O
"nocolour"	pointer
,	O
COLOUR_MASK	int
,	O
0	int
,	O
"nocolor"	pointer
,	O
BGCOLOUR_MASK	int
,	O
BGCOLOUR_BLACK	O
,	O
"bgblack"	pointer
,	O
BGCOLOUR_MASK	int
,	O
BGCOLOUR_RED	O
,	O
"bgred"	pointer
,	O
BGCOLOUR_MASK	int
,	O
BGCOLOUR_GREEN	O
,	O
"bggreen"	pointer
,	O
BGCOLOUR_MASK	int
,	O
BGCOLOUR_YELLOW	O
,	O
"bgyellow"	pointer
,	O
BGCOLOUR_MASK	int
,	O
BGCOLOUR_BLUE	O
,	O
"bgblue"	pointer
,	O
BGCOLOUR_MASK	int
,	O
BGCOLOUR_MAGENTA	O
,	O
"bgmagenta"	pointer
,	O
BGCOLOUR_MASK	int
,	O
BGCOLOUR_CYAN	O
,	O
"bgcyan"	pointer
,	O
BGCOLOUR_MASK	int
,	O
BGCOLOUR_WHITE	O
,	O
"bgwhite"	pointer
,	O
BGCOLOUR_MASK	int
,	O
0	int
,	O
"nobgcolour"	pointer
,	O
BGCOLOUR_MASK	int
,	O
0	int
,	O
"nobgcolor"	pointer
,	O
UNDERLINE_MASK	int
,	O
UNDERLINE_MASK	int
,	O
"underline"	pointer
,	O
UNDERLINE_MASK	int
,	O
0	int
,	O
"nounderline"	pointer
,	O
STANDOUT_MASK	int
,	O
STANDOUT_MASK	int
,	O
"standout"	pointer
,	O
STANDOUT_MASK	int
,	O
0	int
,	O
"nostandout"	pointer
,	O
BOLD_MASK	int
,	O
BOLD_MASK	int
,	O
"bold"	pointer
,	O
BOLD_MASK	int
,	O
0	int
,	O
"regular"	pointer
,	O
BOLD_MASK	int
,	O
0	int
,	O
"nobold"	pointer
,	O
BLINK_MASK	int
,	O
BLINK_MASK	int
,	O
"blink"	pointer
,	O
BLINK_MASK	int
,	O
0	int
,	O
"noblink"	pointer
,	O
}	O
;	O
int	O
i	int
;	O
char	O
*	O
component	pointer
;	O
unsigned	O
long	O
rendition_mask	long
=	O
0	int
;	O
unsigned	O
long	O
rendition_value	long
=	O
0	int
;	O
component	pointer
=	O
strtok	function
(	O
value	union
,	O
","	pointer
)	O
;	O
while	O
(	O
component	pointer
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
styles	array
[	O
i	int
]	O
.	O
name	pointer
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
styles	array
[	O
i	int
]	O
.	O
name	pointer
,	O
component	pointer
)	O
)	O
break	O
;	O
}	O
if	O
(	O
styles	array
[	O
i	int
]	O
.	O
name	pointer
)	O
{	O
rendition_mask	long
|=	O
styles	array
[	O
i	int
]	O
.	O
mask	long
;	O
rendition_value	long
&=	O
~	O
styles	array
[	O
i	int
]	O
.	O
mask	long
;	O
rendition_value	long
|=	O
styles	array
[	O
i	int
]	O
.	O
value	union
;	O
}	O
component	pointer
=	O
strtok	function
(	O
0	int
,	O
","	pointer
)	O
;	O
}	O
(	O
(	O
RENDITION	struct
*	O
)	O
var	pointer
->	O
value	union
)	O
->	O
mask	long
=	O
rendition_mask	long
;	O
(	O
(	O
RENDITION	struct
*	O
)	O
var	pointer
->	O
value	union
)	O
->	O
value	union
=	O
rendition_value	long
;	O
}	O
return	O
1	int
;	O
}	O
else	O
{	O
char	O
*	O
p	pointer
;	O
long	O
n	long
=	O
strtol	function
(	O
value	union
,	O
&	O
p	pointer
,	O
10	int
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
0	int
&&	O
INT_MIN	O
<=	O
n	long
&&	O
n	long
<=	O
INT_MAX	O
)	O
{	O
*	O
(	O
int	O
*	O
)	O
var	pointer
->	O
value	union
=	O
n	long
;	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
