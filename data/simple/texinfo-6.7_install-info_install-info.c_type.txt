static	O
char	O
*	O
progname	pointer
=	O
"install-info"	pointer
;	O
static	O
char	O
*	O
default_section	pointer
=	O
NULL	O
;	O
struct	O
spec_entry	struct
;	O
struct	O
spec_section	struct
;	O
struct	O
line_data	struct
*	O
findlines	function
(	O
char	O
*	O
data	pointer
,	O
int	O
size	int
,	O
int	O
*	O
nlinesp	pointer
)	O
;	O
void	O
insert_entry_here	function
(	O
struct	O
spec_entry	struct
*	O
entry	pointer
,	O
int	O
line_number	int
,	O
struct	O
line_data	struct
*	O
dir_lines	pointer
,	O
int	O
n_entries	int
)	O
;	O
int	O
compare_section_names	function
(	O
const	O
void	O
*	O
s1	pointer
,	O
const	O
void	O
*	O
s2	pointer
)	O
;	O
int	O
compare_entries_text	function
(	O
const	O
void	O
*	O
e1	pointer
,	O
const	O
void	O
*	O
e2	pointer
)	O
;	O
struct	O
line_data	struct
{	O
char	O
*	O
start	pointer
;	O
int	O
size	int
;	O
struct	O
spec_entry	struct
*	O
*	O
add_entries_before	pointer
;	O
struct	O
spec_section	struct
*	O
*	O
add_sections_before	pointer
;	O
int	O
num_sections_to_add	int
;	O
int	O
delete	int
;	O
}	O
;	O
struct	O
spec_section	struct
{	O
struct	O
spec_section	struct
*	O
next	pointer
;	O
char	O
*	O
name	pointer
;	O
int	O
missing	int
;	O
}	O
;	O
struct	O
spec_entry	struct
{	O
struct	O
spec_entry	struct
*	O
next	pointer
;	O
char	O
*	O
text	pointer
;	O
size_t	long
text_len	long
;	O
struct	O
spec_section	struct
*	O
entry_sections	pointer
;	O
struct	O
spec_section	struct
*	O
entry_sections_tail	pointer
;	O
int	O
missing_name	int
;	O
int	O
missing_description	int
;	O
int	O
missing_basename	int
;	O
}	O
;	O
struct	O
node	struct
{	O
struct	O
node	struct
*	O
next	pointer
;	O
char	O
*	O
name	pointer
;	O
int	O
start_line	int
;	O
int	O
end_line	int
;	O
char	O
*	O
menu_start	pointer
;	O
struct	O
menu_section	struct
*	O
sections	pointer
;	O
struct	O
menu_section	struct
*	O
last_section	pointer
;	O
}	O
;	O
struct	O
menu_section	struct
{	O
struct	O
menu_section	struct
*	O
next	pointer
;	O
char	O
*	O
name	pointer
;	O
int	O
start_line	int
;	O
int	O
end_line	int
;	O
}	O
;	O
struct	O
option	struct
longopts	array
[	O
]	O
=	O
{	O
{	O
"add-once"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'1'	O
}	O
,	O
{	O
"align"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'A'	O
}	O
,	O
{	O
"append-new-sections"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'a'	O
}	O
,	O
{	O
"calign"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'C'	O
}	O
,	O
{	O
"debug"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'g'	O
}	O
,	O
{	O
"delete"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'r'	O
}	O
,	O
{	O
"defentry"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'E'	O
}	O
,	O
{	O
"defsection"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'S'	O
}	O
,	O
{	O
"dir-file"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'd'	O
}	O
,	O
{	O
"entry"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'e'	O
}	O
,	O
{	O
"name"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
't'	O
}	O
,	O
{	O
"menuentry"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
't'	O
}	O
,	O
{	O
"description"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'c'	O
}	O
,	O
{	O
"help"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'h'	O
}	O
,	O
{	O
"no-indent"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'I'	O
}	O
,	O
{	O
"infodir"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'D'	O
}	O
,	O
{	O
"info-dir"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'D'	O
}	O
,	O
{	O
"info-file"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'i'	O
}	O
,	O
{	O
"item"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'e'	O
}	O
,	O
{	O
"keep-old"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'k'	O
}	O
,	O
{	O
"maxwidth"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'W'	O
}	O
,	O
{	O
"max-width"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'W'	O
}	O
,	O
{	O
"quiet"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'q'	O
}	O
,	O
{	O
"remove"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'r'	O
}	O
,	O
{	O
"remove-exactly"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'x'	O
}	O
,	O
{	O
"section"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
's'	O
}	O
,	O
{	O
"regex"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'R'	O
}	O
,	O
{	O
"silent"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'q'	O
}	O
,	O
{	O
"test"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'n'	O
}	O
,	O
{	O
"dry-run"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'n'	O
}	O
,	O
{	O
"version"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'V'	O
}	O
,	O
{	O
0	int
}	O
}	O
;	O
regex_t	struct
*	O
psecreg	pointer
=	O
NULL	O
;	O
int	O
remove_exactly	int
=	O
0	int
;	O
int	O
remove_empty_sections	int
=	O
1	int
;	O
int	O
add_entries_into_all_matching_sections	int
=	O
1	int
;	O
int	O
keep_old_flag	int
=	O
0	int
;	O
int	O
chicken_flag	int
=	O
0	int
;	O
int	O
indent_flag	int
=	O
1	int
;	O
int	O
order_new_sections_alphabetically_flag	int
=	O
1	int
;	O
void	O
vdiag	function
(	O
const	O
char	O
*	O
fmt	pointer
,	O
const	O
char	O
*	O
diagtype	pointer
,	O
va_list	array
ap	array
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: "	pointer
,	O
progname	pointer
)	O
;	O
if	O
(	O
diagtype	pointer
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: "	pointer
,	O
diagtype	pointer
)	O
;	O
vfprintf	function
(	O
stderr	pointer
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
putc	function
(	O
'\n'	O
,	O
stderr	pointer
)	O
;	O
}	O
void	O
error	function
(	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
vdiag	function
(	O
fmt	pointer
,	O
NULL	O
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
}	O
void	O
warning	function
(	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
vdiag	function
(	O
fmt	pointer
,	O
"warning"	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
}	O
void	O
fatal	function
(	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
vdiag	function
(	O
fmt	pointer
,	O
NULL	O
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
char	O
*	O
concat	function
(	O
const	O
char	O
*	O
s1	pointer
,	O
const	O
char	O
*	O
s2	pointer
,	O
const	O
char	O
*	O
s3	pointer
)	O
{	O
int	O
len1	int
=	O
strlen	function
(	O
s1	pointer
)	O
,	O
len2	int
=	O
strlen	function
(	O
s2	pointer
)	O
,	O
len3	int
=	O
strlen	function
(	O
s3	pointer
)	O
;	O
char	O
*	O
result	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
len1	int
+	O
len2	int
+	O
len3	int
+	O
1	int
)	O
;	O
strcpy	function
(	O
result	pointer
,	O
s1	pointer
)	O
;	O
strcpy	function
(	O
result	pointer
+	O
len1	int
,	O
s2	pointer
)	O
;	O
strcpy	function
(	O
result	pointer
+	O
len1	int
+	O
len2	int
,	O
s3	pointer
)	O
;	O
*	O
(	O
result	pointer
+	O
len1	int
+	O
len2	int
+	O
len3	int
)	O
=	O
0	int
;	O
return	O
result	pointer
;	O
}	O
char	O
*	O
copy_string	function
(	O
const	O
char	O
*	O
string	pointer
,	O
int	O
size	int
)	O
{	O
int	O
i	int
;	O
char	O
*	O
copy	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
size	int
+	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
size	int
;	O
i	int
++	O
)	O
copy	pointer
[	O
i	int
]	O
=	O
string	pointer
[	O
i	int
]	O
;	O
copy	pointer
[	O
size	int
]	O
=	O
0	int
;	O
return	O
copy	pointer
;	O
}	O
void	O
pfatal_with_name	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
if	O
(	O
errno	O
==	O
0	int
)	O
fatal	function
(	O
_	O
(	O
"%s: empty file"	pointer
)	O
,	O
name	pointer
)	O
;	O
fatal	function
(	O
_	O
(	O
"%s for %s"	pointer
)	O
,	O
strerror	function
(	O
errno	O
)	O
,	O
name	pointer
)	O
;	O
}	O
static	O
int	O
menu_line_lessp	function
(	O
char	O
*	O
line1	pointer
,	O
int	O
len1	int
,	O
char	O
*	O
line2	pointer
,	O
int	O
len2	int
)	O
{	O
int	O
minlen	int
=	O
(	O
len1	int
<	O
len2	int
?	O
len1	int
:	O
len2	int
)	O
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
minlen	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
line1	pointer
[	O
i	int
]	O
==	O
':'	O
&&	O
line2	pointer
[	O
i	int
]	O
!=	O
':'	O
)	O
return	O
1	int
;	O
if	O
(	O
line2	pointer
[	O
i	int
]	O
==	O
':'	O
&&	O
line1	pointer
[	O
i	int
]	O
!=	O
':'	O
)	O
return	O
0	int
;	O
if	O
(	O
line1	pointer
[	O
i	int
]	O
<	O
line2	pointer
[	O
i	int
]	O
)	O
return	O
1	int
;	O
if	O
(	O
line1	pointer
[	O
i	int
]	O
>	O
line2	pointer
[	O
i	int
]	O
)	O
return	O
0	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
menu_line_equal	function
(	O
char	O
*	O
line1	pointer
,	O
int	O
len1	int
,	O
char	O
*	O
line2	pointer
,	O
int	O
len2	int
)	O
{	O
int	O
minlen	int
=	O
(	O
len1	int
<	O
len2	int
?	O
len1	int
:	O
len2	int
)	O
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
minlen	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
line1	pointer
[	O
i	int
]	O
==	O
':'	O
&&	O
line2	pointer
[	O
i	int
]	O
==	O
':'	O
)	O
return	O
1	int
;	O
if	O
(	O
line1	pointer
[	O
i	int
]	O
!=	O
line2	pointer
[	O
i	int
]	O
)	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
char	O
*	O
extract_menu_item_name	function
(	O
char	O
*	O
item_text	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
if	O
(	O
*	O
item_text	pointer
==	O
'*'	O
)	O
item_text	pointer
++	O
;	O
while	O
(	O
*	O
item_text	pointer
==	O
' '	O
)	O
item_text	pointer
++	O
;	O
p	pointer
=	O
item_text	pointer
;	O
while	O
(	O
*	O
p	pointer
&&	O
*	O
p	pointer
!=	O
':'	O
)	O
p	pointer
++	O
;	O
return	O
copy_string	function
(	O
item_text	pointer
,	O
p	pointer
-	O
item_text	pointer
)	O
;	O
}	O
char	O
*	O
extract_menu_file_name	function
(	O
char	O
*	O
item_text	pointer
)	O
{	O
char	O
*	O
p	pointer
=	O
item_text	pointer
;	O
if	O
(	O
*	O
p	pointer
==	O
'*'	O
)	O
p	pointer
++	O
;	O
while	O
(	O
*	O
p	pointer
==	O
' '	O
)	O
p	pointer
++	O
;	O
while	O
(	O
*	O
p	pointer
&&	O
*	O
p	pointer
!=	O
'\n'	O
&&	O
*	O
p	pointer
!=	O
':'	O
)	O
p	pointer
++	O
;	O
if	O
(	O
*	O
p	pointer
==	O
':'	O
)	O
p	pointer
++	O
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
*	O
p	pointer
==	O
'('	O
)	O
break	O
;	O
else	O
if	O
(	O
*	O
p	pointer
==	O
' '	O
||	O
*	O
p	pointer
==	O
'\t'	O
)	O
p	pointer
++	O
;	O
else	O
return	O
"(none)"	pointer
;	O
}	O
p	pointer
++	O
;	O
item_text	pointer
=	O
p	pointer
;	O
while	O
(	O
*	O
p	pointer
&&	O
*	O
p	pointer
!=	O
'\n'	O
&&	O
*	O
p	pointer
!=	O
')'	O
)	O
p	pointer
++	O
;	O
if	O
(	O
*	O
p	pointer
!=	O
')'	O
)	O
return	O
"(none)"	pointer
;	O
return	O
copy_string	function
(	O
item_text	pointer
,	O
p	pointer
-	O
item_text	pointer
)	O
;	O
}	O
static	O
char	O
*	O
strip_info_suffix	function
(	O
char	O
*	O
fname	pointer
)	O
{	O
char	O
*	O
ret	pointer
=	O
xstrdup	function
(	O
fname	pointer
)	O
;	O
unsigned	O
len	int
=	O
strlen	function
(	O
ret	pointer
)	O
;	O
if	O
(	O
len	int
>	O
3	int
&&	O
FILENAME_CMP	O
(	O
ret	pointer
+	O
len	int
-	O
3	int
,	O
".gz"	pointer
)	O
==	O
0	int
)	O
{	O
len	int
-=	O
3	int
;	O
ret	pointer
[	O
len	int
]	O
=	O
0	int
;	O
}	O
else	O
if	O
(	O
len	int
>	O
3	int
&&	O
FILENAME_CMP	O
(	O
ret	pointer
+	O
len	int
-	O
3	int
,	O
".xz"	pointer
)	O
==	O
0	int
)	O
{	O
len	int
-=	O
3	int
;	O
ret	pointer
[	O
len	int
]	O
=	O
0	int
;	O
}	O
else	O
if	O
(	O
len	int
>	O
4	int
&&	O
FILENAME_CMP	O
(	O
ret	pointer
+	O
len	int
-	O
4	int
,	O
".bz2"	pointer
)	O
==	O
0	int
)	O
{	O
len	int
-=	O
4	int
;	O
ret	pointer
[	O
len	int
]	O
=	O
0	int
;	O
}	O
else	O
if	O
(	O
len	int
>	O
3	int
&&	O
FILENAME_CMP	O
(	O
ret	pointer
+	O
len	int
-	O
3	int
,	O
".lz"	pointer
)	O
==	O
0	int
)	O
{	O
len	int
-=	O
3	int
;	O
ret	pointer
[	O
len	int
]	O
=	O
0	int
;	O
}	O
else	O
if	O
(	O
len	int
>	O
5	int
&&	O
FILENAME_CMP	O
(	O
ret	pointer
+	O
len	int
-	O
5	int
,	O
".lzma"	pointer
)	O
==	O
0	int
)	O
{	O
len	int
-=	O
5	int
;	O
ret	pointer
[	O
len	int
]	O
=	O
0	int
;	O
}	O
if	O
(	O
len	int
>	O
5	int
&&	O
FILENAME_CMP	O
(	O
ret	pointer
+	O
len	int
-	O
5	int
,	O
".info"	pointer
)	O
==	O
0	int
)	O
{	O
len	int
-=	O
5	int
;	O
ret	pointer
[	O
len	int
]	O
=	O
0	int
;	O
}	O
else	O
if	O
(	O
len	int
>	O
4	int
&&	O
FILENAME_CMP	O
(	O
ret	pointer
+	O
len	int
-	O
4	int
,	O
".inf"	pointer
)	O
==	O
0	int
)	O
{	O
len	int
-=	O
4	int
;	O
ret	pointer
[	O
len	int
]	O
=	O
0	int
;	O
}	O
return	O
ret	pointer
;	O
}	O
static	O
int	O
menu_item_equal	function
(	O
const	O
char	O
*	O
item	pointer
,	O
char	O
term_char	char
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
int	O
ret	pointer
;	O
const	O
char	O
*	O
item_basename	pointer
=	O
item	pointer
;	O
unsigned	O
name_len	int
=	O
strlen	function
(	O
name	pointer
)	O
;	O
if	O
(	O
!	O
remove_exactly	int
)	O
{	O
while	O
(	O
*	O
item_basename	pointer
&&	O
!	O
IS_SLASH	O
(	O
*	O
item_basename	pointer
)	O
&&	O
*	O
item_basename	pointer
!=	O
term_char	char
)	O
item_basename	pointer
++	O
;	O
if	O
(	O
!	O
*	O
item_basename	pointer
||	O
*	O
item_basename	pointer
==	O
term_char	char
)	O
item_basename	pointer
=	O
item	pointer
;	O
else	O
item_basename	pointer
++	O
;	O
}	O
ret	pointer
=	O
mbsncasecmp	function
(	O
item_basename	pointer
,	O
name	pointer
,	O
name_len	int
)	O
==	O
0	int
;	O
if	O
(	O
ret	pointer
)	O
{	O
static	O
char	O
*	O
suffixes	array
[	O
]	O
=	O
{	O
""	pointer
,	O
".info.gz"	pointer
,	O
".info"	pointer
,	O
".inf"	pointer
,	O
".gz"	pointer
,	O
NULL	O
}	O
;	O
unsigned	O
i	int
;	O
ret	pointer
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
!	O
ret	pointer
&&	O
suffixes	array
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
char	O
*	O
suffix	pointer
=	O
suffixes	array
[	O
i	int
]	O
;	O
unsigned	O
suffix_len	int
=	O
strlen	function
(	O
suffix	pointer
)	O
;	O
ret	pointer
=	O
mbsncasecmp	function
(	O
item_basename	pointer
+	O
name_len	int
,	O
suffix	pointer
,	O
suffix_len	int
)	O
==	O
0	int
&&	O
item_basename	pointer
[	O
name_len	int
+	O
suffix_len	int
]	O
==	O
term_char	char
;	O
}	O
}	O
return	O
ret	pointer
;	O
}	O
void	O
suggest_asking_for_help	function
(	O
void	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"\tTry `%s --help' for a complete list of options.\n"	pointer
)	O
,	O
progname	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
void	O
print_help	function
(	O
void	O
)	O
{	O
printf	function
(	O
_	O
(	O
"Usage: %s [OPTION]... [INFO-FILE [DIR-FILE]]\n"	pointer
)	O
,	O
progname	pointer
)	O
;	O
puts	function
(	O
""	pointer
)	O
;	O
puts	function
(	O
_	O
(	O
"Add or remove entries in INFO-FILE from the Info directory DIR-FILE."	pointer
)	O
)	O
;	O
puts	function
(	O
_	O
(	O
"INFO-FILE and DIR-FILE are required unless the --info-file\nor --dir-file (or --info-dir) options are given, respectively."	pointer
)	O
)	O
;	O
puts	function
(	O
""	pointer
)	O
;	O
puts	function
(	O
_	O
(	O
"Options:\n --add-once          add only to first matching section, not all.\n --align=COL         start description of new entries at column COL.\n --calign=COL        format second and subsequent description lines to\n                       start at column COL."	pointer
)	O
)	O
;	O
puts	function
(	O
_	O
(	O
" --debug             report what is being done.\n --delete            delete existing entries for INFO-FILE from DIR-FILE;\n                      don't insert any new entries.\n --defsection=TEXT   like --section, but only use TEXT if no sections\n                      are present in INFO-FILE (replacing \"Miscellaneous\").\n --description=TEXT  the description of the entry is TEXT; used with\n                      the --name option to become synonymous with the\n                      --entry option.\n --dir-file=NAME     specify file name of Info directory file;\n                      equivalent to using the DIR-FILE argument.\n --dry-run           same as --test."	pointer
)	O
)	O
;	O
puts	function
(	O
_	O
(	O
" --entry=TEXT        insert TEXT as an Info directory entry,\n                      overriding any corresponding entry from DIR-FILE.\n                      TEXT is written as an Info menu item line followed\n                       by zero or more extra lines starting with whitespace.\n                      If you specify more than one entry, all are added.\n                      If you don't specify any entries, they are determined\n                       from information in the Info file itself."	pointer
)	O
)	O
;	O
puts	function
(	O
_	O
(	O
" --help              display this help and exit.\n --info-dir=DIR      same as --dir-file=DIR/dir.\n --info-file=FILE    specify Info file to install in the directory;\n                      equivalent to using the INFO-FILE argument.\n --item=TEXT         same as --entry=TEXT.\n --keep-old          do not replace entries, or remove empty sections."	pointer
)	O
)	O
;	O
puts	function
(	O
_	O
(	O
" --maxwidth, --max-width=COL  wrap description at column COL.\n --menuentry=TEXT    same as --name=TEXT.\n --name=TEXT         the name of the entry is TEXT; used with --description\n                      to become synonymous with the --entry option.\n --no-indent         do not format new entries in the DIR file.\n --quiet             suppress warnings."	pointer
)	O
)	O
;	O
puts	function
(	O
_	O
(	O
" --regex=R           put this file's entries in all sections that match the\n                      regular expression R (ignoring case).\n --remove            same as --delete.\n --remove-exactly    only remove if the info file name matches exactly;\n                      suffixes such as .info and .gz are not ignored.\n --section=SEC       put entries in section SEC of the directory.\n                      If you specify more than one section, all the entries\n                       are added in each of the sections.\n                      If you don't specify any sections, they are determined\n                       from information in the Info file itself;\n                       if nothing is available there, the --defsection\n                       value is used; if that is not specified, the\n                       final default is \"Miscellaneous\".\n --section R SEC     equivalent to --regex=R --section=SEC --add-once."	pointer
)	O
)	O
;	O
puts	function
(	O
_	O
(	O
" --silent            suppress warnings.\n --test              suppress updating of DIR-FILE.\n --version           display version information and exit."	pointer
)	O
)	O
;	O
puts	function
(	O
""	pointer
)	O
;	O
puts	function
(	O
_	O
(	O
"Email bug reports to bug-texinfo@gnu.org,\ngeneral questions and discussion to help-texinfo@gnu.org.\nTexinfo home page: http://www.gnu.org/software/texinfo/"	pointer
)	O
)	O
;	O
}	O
static	O
void	O
ensure_dirfile_exists	function
(	O
char	O
*	O
dirfile	pointer
)	O
{	O
int	O
desc	int
;	O
if	O
(	O
chicken_flag	int
)	O
return	O
;	O
desc	int
=	O
open	function
(	O
dirfile	pointer
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
desc	int
<	O
0	int
&&	O
errno	O
==	O
ENOENT	int
)	O
{	O
FILE	struct
*	O
f	pointer
;	O
char	O
*	O
readerr	pointer
=	O
strerror	function
(	O
errno	O
)	O
;	O
f	pointer
=	O
fopen	function
(	O
dirfile	pointer
,	O
"w"	pointer
)	O
;	O
if	O
(	O
f	pointer
)	O
{	O
fprintf	function
(	O
f	pointer
,	O
_	O
(	O
"This is the file .../info/dir, which contains the\ntopmost node of the Info hierarchy, called (dir)Top.\nThe first time you invoke Info you start off looking at this node.\n%c\n%s\tThis is the top of the INFO tree\n\n  This (the Directory node) gives a menu of major topics.\n  Typing \"q\" exits, \"H\" lists all Info commands, \"d\" returns here,\n  \"h\" gives a primer for first-timers,\n  \"mEmacs<Return>\" visits the Emacs manual, etc.\n\n  In Emacs, you can click mouse button 2 on a menu item or cross reference\n  to select it.\n\n%s\n"	pointer
)	O
,	O
'\x1f'	O
,	O
"File: dir,\tNode: Top"	pointer
,	O
"* Menu:"	pointer
)	O
;	O
if	O
(	O
fclose	function
(	O
f	pointer
)	O
<	O
0	int
)	O
pfatal_with_name	function
(	O
dirfile	pointer
)	O
;	O
}	O
else	O
{	O
fatal	function
(	O
_	O
(	O
"%s: could not read (%s) and could not create (%s)"	pointer
)	O
,	O
dirfile	pointer
,	O
readerr	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
}	O
else	O
close	pointer
(	O
desc	int
)	O
;	O
}	O
FILE	struct
*	O
open_possibly_compressed_file	function
(	O
char	O
*	O
filename	pointer
,	O
void	O
(	O
*	O
create_callback	pointer
)	O
(	O
char	O
*	O
)	O
,	O
char	O
*	O
*	O
opened_filename	pointer
,	O
char	O
*	O
*	O
compression_program	pointer
)	O
{	O
char	O
*	O
local_opened_filename	pointer
,	O
*	O
local_compression_program	pointer
;	O
int	O
nread	int
;	O
char	O
data	pointer
[	O
13	int
]	O
;	O
FILE	struct
*	O
f	pointer
;	O
if	O
(	O
!	O
opened_filename	pointer
)	O
opened_filename	pointer
=	O
&	O
local_opened_filename	pointer
;	O
*	O
opened_filename	pointer
=	O
filename	pointer
;	O
f	pointer
=	O
fopen	function
(	O
*	O
opened_filename	pointer
,	O
FOPEN_RBIN	pointer
)	O
;	O
if	O
(	O
!	O
f	pointer
)	O
{	O
*	O
opened_filename	pointer
=	O
concat	function
(	O
filename	pointer
,	O
".gz"	pointer
,	O
""	pointer
)	O
;	O
f	pointer
=	O
fopen	function
(	O
*	O
opened_filename	pointer
,	O
FOPEN_RBIN	pointer
)	O
;	O
}	O
if	O
(	O
!	O
f	pointer
)	O
{	O
free	function
(	O
*	O
opened_filename	pointer
)	O
;	O
*	O
opened_filename	pointer
=	O
concat	function
(	O
filename	pointer
,	O
".xz"	pointer
,	O
""	pointer
)	O
;	O
f	pointer
=	O
fopen	function
(	O
*	O
opened_filename	pointer
,	O
FOPEN_RBIN	pointer
)	O
;	O
}	O
if	O
(	O
!	O
f	pointer
)	O
{	O
free	function
(	O
*	O
opened_filename	pointer
)	O
;	O
*	O
opened_filename	pointer
=	O
concat	function
(	O
filename	pointer
,	O
".bz2"	pointer
,	O
""	pointer
)	O
;	O
f	pointer
=	O
fopen	function
(	O
*	O
opened_filename	pointer
,	O
FOPEN_RBIN	pointer
)	O
;	O
}	O
if	O
(	O
!	O
f	pointer
)	O
{	O
free	function
(	O
*	O
opened_filename	pointer
)	O
;	O
*	O
opened_filename	pointer
=	O
concat	function
(	O
filename	pointer
,	O
".lz"	pointer
,	O
""	pointer
)	O
;	O
f	pointer
=	O
fopen	function
(	O
*	O
opened_filename	pointer
,	O
FOPEN_RBIN	pointer
)	O
;	O
}	O
if	O
(	O
!	O
f	pointer
)	O
{	O
free	function
(	O
*	O
opened_filename	pointer
)	O
;	O
*	O
opened_filename	pointer
=	O
concat	function
(	O
filename	pointer
,	O
".lzma"	pointer
,	O
""	pointer
)	O
;	O
f	pointer
=	O
fopen	function
(	O
*	O
opened_filename	pointer
,	O
FOPEN_RBIN	pointer
)	O
;	O
}	O
if	O
(	O
!	O
f	pointer
)	O
{	O
free	function
(	O
*	O
opened_filename	pointer
)	O
;	O
*	O
opened_filename	pointer
=	O
filename	pointer
;	O
if	O
(	O
create_callback	pointer
)	O
{	O
(	O
*	O
create_callback	pointer
)	O
(	O
filename	pointer
)	O
;	O
f	pointer
=	O
fopen	function
(	O
*	O
opened_filename	pointer
,	O
FOPEN_RBIN	pointer
)	O
;	O
if	O
(	O
!	O
f	pointer
)	O
return	O
0	int
;	O
}	O
else	O
return	O
0	int
;	O
}	O
nread	int
=	O
fread	function
(	O
data	pointer
,	O
sizeof	O
(	O
data	pointer
)	O
,	O
1	int
,	O
f	pointer
)	O
;	O
if	O
(	O
nread	int
!=	O
1	int
)	O
{	O
if	O
(	O
nread	int
==	O
0	int
)	O
{	O
if	O
(	O
feof	function
(	O
f	pointer
)	O
&&	O
create_callback	pointer
)	O
{	O
if	O
(	O
fclose	function
(	O
f	pointer
)	O
!=	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
remove	function
(	O
filename	pointer
)	O
!=	O
0	int
)	O
return	O
0	int
;	O
(	O
*	O
create_callback	pointer
)	O
(	O
filename	pointer
)	O
;	O
f	pointer
=	O
fopen	function
(	O
*	O
opened_filename	pointer
,	O
FOPEN_RBIN	pointer
)	O
;	O
if	O
(	O
!	O
f	pointer
)	O
return	O
0	int
;	O
nread	int
=	O
fread	function
(	O
data	pointer
,	O
sizeof	O
(	O
data	pointer
)	O
,	O
1	int
,	O
f	pointer
)	O
;	O
if	O
(	O
nread	int
==	O
0	int
)	O
return	O
0	int
;	O
goto	O
determine_file_type	O
;	O
}	O
}	O
errno	O
=	O
0	int
;	O
return	O
0	int
;	O
}	O
determine_file_type	O
:	O
if	O
(	O
!	O
compression_program	pointer
)	O
compression_program	pointer
=	O
&	O
local_compression_program	pointer
;	O
if	O
(	O
data	pointer
[	O
0	int
]	O
==	O
'\x1f'	O
&&	O
data	pointer
[	O
1	int
]	O
==	O
'\x8b'	O
)	O
*	O
compression_program	pointer
=	O
"gzip"	pointer
;	O
else	O
if	O
(	O
data	pointer
[	O
0	int
]	O
==	O
'\xFD'	O
&&	O
data	pointer
[	O
1	int
]	O
==	O
'7'	O
&&	O
data	pointer
[	O
2	int
]	O
==	O
'z'	O
&&	O
data	pointer
[	O
3	int
]	O
==	O
'X'	O
&&	O
data	pointer
[	O
4	int
]	O
==	O
'Z'	O
&&	O
data	pointer
[	O
5	int
]	O
==	O
0	int
)	O
*	O
compression_program	pointer
=	O
"xz"	pointer
;	O
else	O
if	O
(	O
data	pointer
[	O
0	int
]	O
==	O
'B'	O
&&	O
data	pointer
[	O
1	int
]	O
==	O
'Z'	O
&&	O
data	pointer
[	O
2	int
]	O
==	O
'h'	O
)	O
*	O
compression_program	pointer
=	O
"bzip2"	pointer
;	O
else	O
if	O
(	O
data	pointer
[	O
0	int
]	O
==	O
'B'	O
&&	O
data	pointer
[	O
1	int
]	O
==	O
'Z'	O
&&	O
data	pointer
[	O
2	int
]	O
==	O
'0'	O
)	O
*	O
compression_program	pointer
=	O
"bzip"	pointer
;	O
else	O
if	O
(	O
data	pointer
[	O
0	int
]	O
==	O
0x4C	int
&&	O
data	pointer
[	O
1	int
]	O
==	O
0x5A	int
&&	O
data	pointer
[	O
2	int
]	O
==	O
0x49	int
&&	O
data	pointer
[	O
3	int
]	O
==	O
0x50	int
&&	O
data	pointer
[	O
4	int
]	O
==	O
1	int
)	O
*	O
compression_program	pointer
=	O
"lzip"	pointer
;	O
else	O
if	O
(	O
(	O
data	pointer
[	O
9	int
]	O
==	O
0x00	int
&&	O
data	pointer
[	O
10	int
]	O
==	O
0x00	int
&&	O
data	pointer
[	O
11	int
]	O
==	O
0x00	int
&&	O
data	pointer
[	O
12	int
]	O
==	O
0x00	int
)	O
||	O
(	O
data	pointer
[	O
5	int
]	O
==	O
'\xFF'	O
&&	O
data	pointer
[	O
6	int
]	O
==	O
'\xFF'	O
&&	O
data	pointer
[	O
7	int
]	O
==	O
'\xFF'	O
&&	O
data	pointer
[	O
8	int
]	O
==	O
'\xFF'	O
&&	O
data	pointer
[	O
9	int
]	O
==	O
'\xFF'	O
&&	O
data	pointer
[	O
10	int
]	O
==	O
'\xFF'	O
&&	O
data	pointer
[	O
11	int
]	O
==	O
'\xFF'	O
&&	O
data	pointer
[	O
12	int
]	O
==	O
'\xFF'	O
)	O
||	O
(	O
data	pointer
[	O
0	int
]	O
==	O
'\xFF'	O
&&	O
data	pointer
[	O
1	int
]	O
==	O
'L'	O
&&	O
data	pointer
[	O
2	int
]	O
==	O
'Z'	O
&&	O
data	pointer
[	O
3	int
]	O
==	O
'M'	O
&&	O
data	pointer
[	O
4	int
]	O
==	O
'A'	O
&&	O
data	pointer
[	O
5	int
]	O
==	O
0x00	int
)	O
)	O
*	O
compression_program	pointer
=	O
"lzma"	pointer
;	O
else	O
*	O
compression_program	pointer
=	O
NULL	O
;	O
if	O
(	O
fseek	function
(	O
f	pointer
,	O
0	int
,	O
0	int
)	O
<	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
*	O
compression_program	pointer
)	O
{	O
char	O
*	O
command	pointer
=	O
concat	function
(	O
*	O
compression_program	pointer
,	O
" -d"	pointer
,	O
""	pointer
)	O
;	O
if	O
(	O
fclose	function
(	O
f	pointer
)	O
<	O
0	int
)	O
return	O
0	int
;	O
f	pointer
=	O
freopen	function
(	O
*	O
opened_filename	pointer
,	O
FOPEN_RBIN	pointer
,	O
stdin	pointer
)	O
;	O
if	O
(	O
!	O
f	pointer
)	O
return	O
0	int
;	O
f	pointer
=	O
popen	function
(	O
command	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
!	O
f	pointer
)	O
{	O
*	O
opened_filename	pointer
=	O
command	pointer
;	O
return	O
0	int
;	O
}	O
}	O
else	O
{	O
}	O
return	O
f	pointer
;	O
}	O
char	O
*	O
readfile	function
(	O
char	O
*	O
filename	pointer
,	O
int	O
*	O
sizep	pointer
,	O
void	O
(	O
*	O
create_callback	pointer
)	O
(	O
char	O
*	O
)	O
,	O
char	O
*	O
*	O
opened_filename	pointer
,	O
char	O
*	O
*	O
compression_program	pointer
)	O
{	O
FILE	struct
*	O
f	pointer
;	O
int	O
filled	int
=	O
0	int
;	O
int	O
data_size	int
=	O
8192	int
;	O
char	O
*	O
data	pointer
=	O
xmalloc	function
(	O
data_size	int
)	O
;	O
f	pointer
=	O
open_possibly_compressed_file	function
(	O
filename	pointer
,	O
create_callback	pointer
,	O
opened_filename	pointer
,	O
compression_program	pointer
)	O
;	O
if	O
(	O
!	O
f	pointer
)	O
return	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
nread	int
=	O
fread	function
(	O
data	pointer
+	O
filled	int
,	O
1	int
,	O
data_size	int
-	O
filled	int
,	O
f	pointer
)	O
;	O
if	O
(	O
nread	int
<	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
nread	int
==	O
0	int
)	O
break	O
;	O
filled	int
+=	O
nread	int
;	O
if	O
(	O
filled	int
==	O
data_size	int
)	O
{	O
data_size	int
+=	O
65536	int
;	O
data	pointer
=	O
xrealloc	function
(	O
data	pointer
,	O
data_size	int
)	O
;	O
}	O
}	O
if	O
(	O
f	pointer
!=	O
stdin	pointer
)	O
pclose	function
(	O
f	pointer
)	O
;	O
*	O
sizep	pointer
=	O
filled	int
;	O
return	O
data	pointer
;	O
}	O
static	O
void	O
output_dirfile	function
(	O
char	O
*	O
dirfile	pointer
,	O
int	O
dir_nlines	int
,	O
struct	O
line_data	struct
*	O
dir_lines	pointer
,	O
int	O
n_entries_to_add	int
,	O
struct	O
spec_entry	struct
*	O
entries_to_add	pointer
,	O
struct	O
spec_section	struct
*	O
input_sections	pointer
,	O
char	O
*	O
compression_program	pointer
)	O
{	O
int	O
n_entries_added	int
=	O
0	int
;	O
int	O
i	int
;	O
FILE	struct
*	O
output	pointer
;	O
if	O
(	O
compression_program	pointer
)	O
{	O
char	O
*	O
command	pointer
=	O
concat	function
(	O
compression_program	pointer
,	O
">"	pointer
,	O
dirfile	pointer
)	O
;	O
output	pointer
=	O
popen	function
(	O
command	pointer
,	O
"w"	pointer
)	O
;	O
}	O
else	O
output	pointer
=	O
fopen	function
(	O
dirfile	pointer
,	O
"w"	pointer
)	O
;	O
if	O
(	O
!	O
output	pointer
)	O
{	O
perror	function
(	O
dirfile	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
dir_nlines	int
;	O
i	int
++	O
)	O
{	O
int	O
j	int
;	O
if	O
(	O
dir_lines	pointer
[	O
i	int
]	O
.	O
add_entries_before	pointer
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
n_entries_to_add	int
;	O
j	int
++	O
)	O
{	O
struct	O
spec_entry	struct
*	O
this	pointer
=	O
dir_lines	pointer
[	O
i	int
]	O
.	O
add_entries_before	pointer
[	O
j	int
]	O
;	O
if	O
(	O
this	pointer
==	O
0	int
)	O
break	O
;	O
if	O
(	O
n_entries_added	int
>=	O
1	int
&&	O
!	O
add_entries_into_all_matching_sections	int
)	O
break	O
;	O
fputs	function
(	O
this	pointer
->	O
text	pointer
,	O
output	pointer
)	O
;	O
n_entries_added	int
++	O
;	O
}	O
if	O
(	O
dir_lines	pointer
[	O
i	int
]	O
.	O
add_sections_before	pointer
)	O
{	O
struct	O
spec_section	struct
*	O
spec	pointer
;	O
struct	O
spec_entry	struct
*	O
entry	pointer
;	O
struct	O
spec_entry	struct
*	O
*	O
entries	pointer
;	O
int	O
n_entries	int
=	O
0	int
;	O
if	O
(	O
n_entries_added	int
>=	O
1	int
&&	O
!	O
add_entries_into_all_matching_sections	int
)	O
break	O
;	O
qsort	function
(	O
dir_lines	pointer
[	O
i	int
]	O
.	O
add_sections_before	pointer
,	O
dir_lines	pointer
[	O
i	int
]	O
.	O
num_sections_to_add	int
,	O
sizeof	O
(	O
struct	O
spec_section	struct
*	O
)	O
,	O
compare_section_names	function
)	O
;	O
for	O
(	O
entry	pointer
=	O
entries_to_add	pointer
;	O
entry	pointer
;	O
entry	pointer
=	O
entry	pointer
->	O
next	pointer
)	O
n_entries	int
++	O
;	O
entries	pointer
=	O
(	O
(	O
struct	O
spec_entry	struct
*	O
*	O
)	O
xmalloc	function
(	O
n_entries	int
*	O
sizeof	O
(	O
struct	O
spec_entry	struct
*	O
)	O
)	O
)	O
;	O
j	int
=	O
0	int
;	O
for	O
(	O
entry	pointer
=	O
entries_to_add	pointer
;	O
entry	pointer
;	O
entry	pointer
=	O
entry	pointer
->	O
next	pointer
)	O
entries	pointer
[	O
j	int
++	O
]	O
=	O
entry	pointer
;	O
qsort	function
(	O
entries	pointer
,	O
n_entries	int
,	O
sizeof	O
(	O
struct	O
spec_entry	struct
*	O
)	O
,	O
compare_entries_text	function
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
dir_lines	pointer
[	O
i	int
]	O
.	O
num_sections_to_add	int
;	O
j	int
++	O
)	O
{	O
spec	pointer
=	O
dir_lines	pointer
[	O
i	int
]	O
.	O
add_sections_before	pointer
[	O
j	int
]	O
;	O
if	O
(	O
spec	pointer
->	O
missing	int
)	O
{	O
int	O
k	int
;	O
putc	function
(	O
'\n'	O
,	O
output	pointer
)	O
;	O
fputs	function
(	O
spec	pointer
->	O
name	pointer
,	O
output	pointer
)	O
;	O
putc	function
(	O
'\n'	O
,	O
output	pointer
)	O
;	O
spec	pointer
->	O
missing	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
n_entries	int
;	O
k	int
++	O
)	O
{	O
struct	O
spec_section	struct
*	O
spec1	pointer
;	O
entry	pointer
=	O
entries	pointer
[	O
k	int
]	O
;	O
for	O
(	O
spec1	pointer
=	O
entry	pointer
->	O
entry_sections	pointer
;	O
spec1	pointer
&&	O
spec1	pointer
!=	O
entry	pointer
->	O
entry_sections_tail	pointer
;	O
spec1	pointer
=	O
spec1	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
spec1	pointer
->	O
name	pointer
,	O
spec	pointer
->	O
name	pointer
)	O
)	O
break	O
;	O
}	O
if	O
(	O
spec1	pointer
&&	O
spec1	pointer
!=	O
entry	pointer
->	O
entry_sections_tail	pointer
)	O
fputs	function
(	O
entry	pointer
->	O
text	pointer
,	O
output	pointer
)	O
;	O
}	O
}	O
}	O
n_entries_added	int
++	O
;	O
free	function
(	O
entries	pointer
)	O
;	O
}	O
if	O
(	O
i	int
<	O
dir_nlines	int
&&	O
!	O
dir_lines	pointer
[	O
i	int
]	O
.	O
delete	int
)	O
{	O
fwrite	function
(	O
dir_lines	pointer
[	O
i	int
]	O
.	O
start	pointer
,	O
1	int
,	O
dir_lines	pointer
[	O
i	int
]	O
.	O
size	int
,	O
output	pointer
)	O
;	O
putc	function
(	O
'\n'	O
,	O
output	pointer
)	O
;	O
}	O
}	O
if	O
(	O
compression_program	pointer
)	O
pclose	function
(	O
output	pointer
)	O
;	O
else	O
fclose	function
(	O
output	pointer
)	O
;	O
}	O
int	O
parse_input	function
(	O
const	O
struct	O
line_data	struct
*	O
lines	pointer
,	O
int	O
nlines	int
,	O
struct	O
spec_section	struct
*	O
*	O
sections	pointer
,	O
struct	O
spec_entry	struct
*	O
*	O
entries	pointer
,	O
int	O
delete_flag	int
)	O
{	O
int	O
n_entries	int
=	O
0	int
;	O
int	O
prefix_length	int
=	O
strlen	function
(	O
"INFO-DIR-SECTION "	pointer
)	O
;	O
struct	O
spec_section	struct
*	O
head	pointer
=	O
*	O
sections	pointer
,	O
*	O
tail	pointer
=	O
NULL	O
;	O
int	O
reset_tail	int
=	O
0	int
;	O
char	O
*	O
start_of_this_entry	pointer
=	O
0	int
;	O
int	O
ignore_sections	int
=	O
*	O
sections	pointer
!=	O
0	int
;	O
int	O
ignore_entries	int
=	O
delete_flag	int
?	O
0	int
:	O
*	O
entries	pointer
!=	O
0	int
;	O
int	O
i	int
;	O
if	O
(	O
ignore_sections	int
&&	O
ignore_entries	int
)	O
return	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nlines	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
!	O
ignore_sections	int
&&	O
!	O
strncmp	function
(	O
"INFO-DIR-SECTION "	pointer
,	O
lines	pointer
[	O
i	int
]	O
.	O
start	pointer
,	O
prefix_length	int
)	O
)	O
{	O
struct	O
spec_section	struct
*	O
next	pointer
=	O
(	O
struct	O
spec_section	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
spec_section	struct
)	O
)	O
;	O
next	pointer
->	O
name	pointer
=	O
copy_string	function
(	O
lines	pointer
[	O
i	int
]	O
.	O
start	pointer
+	O
prefix_length	int
,	O
lines	pointer
[	O
i	int
]	O
.	O
size	int
-	O
prefix_length	int
)	O
;	O
next	pointer
->	O
next	pointer
=	O
*	O
sections	pointer
;	O
next	pointer
->	O
missing	int
=	O
1	int
;	O
if	O
(	O
reset_tail	int
)	O
{	O
tail	pointer
=	O
*	O
sections	pointer
;	O
reset_tail	int
=	O
0	int
;	O
}	O
*	O
sections	pointer
=	O
next	pointer
;	O
head	pointer
=	O
*	O
sections	pointer
;	O
}	O
else	O
if	O
(	O
!	O
ignore_entries	int
)	O
{	O
if	O
(	O
!	O
strncmp	function
(	O
"START-INFO-DIR-ENTRY"	pointer
,	O
lines	pointer
[	O
i	int
]	O
.	O
start	pointer
,	O
lines	pointer
[	O
i	int
]	O
.	O
size	int
)	O
&&	O
sizeof	O
(	O
"START-INFO-DIR-ENTRY"	pointer
)	O
-	O
1	int
==	O
lines	pointer
[	O
i	int
]	O
.	O
size	int
)	O
{	O
if	O
(	O
!	O
*	O
sections	pointer
)	O
{	O
*	O
sections	pointer
=	O
(	O
struct	O
spec_section	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
spec_section	struct
)	O
)	O
;	O
(	O
*	O
sections	pointer
)	O
->	O
name	pointer
=	O
"Miscellaneous"	pointer
;	O
(	O
*	O
sections	pointer
)	O
->	O
next	pointer
=	O
0	int
;	O
(	O
*	O
sections	pointer
)	O
->	O
missing	int
=	O
1	int
;	O
head	pointer
=	O
*	O
sections	pointer
;	O
}	O
reset_tail	int
=	O
1	int
;	O
if	O
(	O
start_of_this_entry	pointer
!=	O
0	int
)	O
fatal	function
(	O
_	O
(	O
"START-INFO-DIR-ENTRY without matching END-INFO-DIR-ENTRY"	pointer
)	O
)	O
;	O
start_of_this_entry	pointer
=	O
lines	pointer
[	O
i	int
+	O
1	int
]	O
.	O
start	pointer
;	O
}	O
else	O
if	O
(	O
start_of_this_entry	pointer
)	O
{	O
if	O
(	O
(	O
!	O
strncmp	function
(	O
"* "	pointer
,	O
lines	pointer
[	O
i	int
]	O
.	O
start	pointer
,	O
2	int
)	O
&&	O
lines	pointer
[	O
i	int
]	O
.	O
start	pointer
>	O
start_of_this_entry	pointer
)	O
||	O
(	O
!	O
strncmp	function
(	O
"END-INFO-DIR-ENTRY"	pointer
,	O
lines	pointer
[	O
i	int
]	O
.	O
start	pointer
,	O
lines	pointer
[	O
i	int
]	O
.	O
size	int
)	O
&&	O
sizeof	O
(	O
"END-INFO-DIR-ENTRY"	pointer
)	O
-	O
1	int
==	O
lines	pointer
[	O
i	int
]	O
.	O
size	int
)	O
)	O
{	O
struct	O
spec_entry	struct
*	O
next	pointer
=	O
(	O
struct	O
spec_entry	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
spec_entry	struct
)	O
)	O
;	O
next	pointer
->	O
text	pointer
=	O
copy_string	function
(	O
start_of_this_entry	pointer
,	O
lines	pointer
[	O
i	int
]	O
.	O
start	pointer
-	O
start_of_this_entry	pointer
)	O
;	O
next	pointer
->	O
text_len	long
=	O
lines	pointer
[	O
i	int
]	O
.	O
start	pointer
-	O
start_of_this_entry	pointer
;	O
next	pointer
->	O
entry_sections	pointer
=	O
head	pointer
;	O
next	pointer
->	O
entry_sections_tail	pointer
=	O
tail	pointer
;	O
next	pointer
->	O
missing_basename	int
=	O
0	int
;	O
next	pointer
->	O
next	pointer
=	O
*	O
entries	pointer
;	O
*	O
entries	pointer
=	O
next	pointer
;	O
n_entries	int
++	O
;	O
if	O
(	O
!	O
strncmp	function
(	O
"END-INFO-DIR-ENTRY"	pointer
,	O
lines	pointer
[	O
i	int
]	O
.	O
start	pointer
,	O
lines	pointer
[	O
i	int
]	O
.	O
size	int
)	O
&&	O
sizeof	O
(	O
"END-INFO-DIR-ENTRY"	pointer
)	O
-	O
1	int
==	O
lines	pointer
[	O
i	int
]	O
.	O
size	int
)	O
start_of_this_entry	pointer
=	O
0	int
;	O
else	O
start_of_this_entry	pointer
=	O
lines	pointer
[	O
i	int
]	O
.	O
start	pointer
;	O
}	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
"END-INFO-DIR-ENTRY"	pointer
,	O
lines	pointer
[	O
i	int
]	O
.	O
start	pointer
,	O
lines	pointer
[	O
i	int
]	O
.	O
size	int
)	O
&&	O
sizeof	O
(	O
"END-INFO-DIR-ENTRY"	pointer
)	O
-	O
1	int
==	O
lines	pointer
[	O
i	int
]	O
.	O
size	int
)	O
fatal	function
(	O
_	O
(	O
"END-INFO-DIR-ENTRY without matching START-INFO-DIR-ENTRY"	pointer
)	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
start_of_this_entry	pointer
!=	O
0	int
)	O
fatal	function
(	O
_	O
(	O
"START-INFO-DIR-ENTRY without matching END-INFO-DIR-ENTRY"	pointer
)	O
)	O
;	O
if	O
(	O
ignore_entries	int
&&	O
*	O
entries	pointer
)	O
{	O
struct	O
spec_entry	struct
*	O
entry	pointer
;	O
for	O
(	O
entry	pointer
=	O
*	O
entries	pointer
;	O
entry	pointer
;	O
entry	pointer
=	O
entry	pointer
->	O
next	pointer
)	O
{	O
entry	pointer
->	O
entry_sections	pointer
=	O
head	pointer
;	O
entry	pointer
->	O
entry_sections_tail	pointer
=	O
tail	pointer
;	O
}	O
}	O
return	O
n_entries	int
;	O
}	O
static	O
void	O
parse_dir_file	function
(	O
struct	O
line_data	struct
*	O
lines	pointer
,	O
int	O
nlines	int
,	O
struct	O
node	struct
*	O
*	O
nodes	pointer
)	O
{	O
int	O
node_header_flag	int
=	O
0	int
;	O
int	O
i	int
;	O
*	O
nodes	pointer
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nlines	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
node_header_flag	int
)	O
{	O
int	O
j	int
,	O
end	pointer
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
lines	pointer
[	O
i	int
]	O
.	O
size	int
;	O
j	int
++	O
)	O
if	O
(	O
!	O
strncmp	function
(	O
"Node:"	pointer
,	O
lines	pointer
[	O
i	int
]	O
.	O
start	pointer
+	O
j	int
,	O
5	int
)	O
)	O
{	O
char	O
*	O
line	pointer
=	O
lines	pointer
[	O
i	int
]	O
.	O
start	pointer
;	O
j	int
+=	O
5	int
;	O
while	O
(	O
line	pointer
[	O
j	int
]	O
==	O
' '	O
||	O
line	pointer
[	O
j	int
]	O
==	O
'\t'	O
)	O
j	int
++	O
;	O
end	pointer
=	O
j	int
;	O
while	O
(	O
line	pointer
[	O
end	pointer
]	O
!=	O
0	int
&&	O
line	pointer
[	O
end	pointer
]	O
!=	O
','	O
&&	O
line	pointer
[	O
end	pointer
]	O
!=	O
'\n'	O
&&	O
line	pointer
[	O
end	pointer
]	O
!=	O
'\t'	O
)	O
end	pointer
++	O
;	O
(	O
*	O
nodes	pointer
)	O
->	O
name	pointer
=	O
copy_string	function
(	O
line	pointer
+	O
j	int
,	O
end	pointer
-	O
j	int
)	O
;	O
}	O
node_header_flag	int
=	O
0	int
;	O
}	O
if	O
(	O
*	O
lines	pointer
[	O
i	int
]	O
.	O
start	pointer
==	O
037	int
)	O
{	O
struct	O
node	struct
*	O
next	pointer
=	O
(	O
struct	O
node	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
node	struct
)	O
)	O
;	O
next	pointer
->	O
next	pointer
=	O
*	O
nodes	pointer
;	O
next	pointer
->	O
name	pointer
=	O
NULL	O
;	O
next	pointer
->	O
start_line	int
=	O
i	int
;	O
next	pointer
->	O
end_line	int
=	O
0	int
;	O
next	pointer
->	O
menu_start	pointer
=	O
NULL	O
;	O
next	pointer
->	O
sections	pointer
=	O
NULL	O
;	O
next	pointer
->	O
last_section	pointer
=	O
NULL	O
;	O
if	O
(	O
*	O
nodes	pointer
!=	O
0	int
)	O
(	O
*	O
nodes	pointer
)	O
->	O
end_line	int
=	O
i	int
;	O
if	O
(	O
*	O
nodes	pointer
!=	O
0	int
&&	O
(	O
*	O
nodes	pointer
)	O
->	O
last_section	pointer
!=	O
0	int
)	O
(	O
*	O
nodes	pointer
)	O
->	O
last_section	pointer
->	O
end_line	int
=	O
i	int
;	O
*	O
nodes	pointer
=	O
next	pointer
;	O
node_header_flag	int
=	O
1	int
;	O
}	O
if	O
(	O
*	O
nodes	pointer
!=	O
0	int
&&	O
!	O
strncmp	function
(	O
"* Menu:"	pointer
,	O
lines	pointer
[	O
i	int
]	O
.	O
start	pointer
,	O
7	int
)	O
)	O
(	O
*	O
nodes	pointer
)	O
->	O
menu_start	pointer
=	O
lines	pointer
[	O
i	int
+	O
1	int
]	O
.	O
start	pointer
;	O
if	O
(	O
*	O
nodes	pointer
!=	O
0	int
&&	O
(	O
*	O
nodes	pointer
)	O
->	O
menu_start	pointer
!=	O
0	int
&&	O
*	O
lines	pointer
[	O
i	int
]	O
.	O
start	pointer
!=	O
'\n'	O
&&	O
*	O
lines	pointer
[	O
i	int
]	O
.	O
start	pointer
!=	O
'*'	O
&&	O
*	O
lines	pointer
[	O
i	int
]	O
.	O
start	pointer
!=	O
' '	O
&&	O
*	O
lines	pointer
[	O
i	int
]	O
.	O
start	pointer
!=	O
'\t'	O
)	O
{	O
struct	O
menu_section	struct
*	O
next	pointer
=	O
(	O
struct	O
menu_section	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
menu_section	struct
)	O
)	O
;	O
next	pointer
->	O
start_line	int
=	O
i	int
+	O
1	int
;	O
next	pointer
->	O
next	pointer
=	O
0	int
;	O
next	pointer
->	O
end_line	int
=	O
0	int
;	O
next	pointer
->	O
name	pointer
=	O
copy_string	function
(	O
lines	pointer
[	O
i	int
]	O
.	O
start	pointer
,	O
lines	pointer
[	O
i	int
]	O
.	O
size	int
)	O
;	O
if	O
(	O
(	O
*	O
nodes	pointer
)	O
->	O
sections	pointer
)	O
{	O
(	O
*	O
nodes	pointer
)	O
->	O
last_section	pointer
->	O
next	pointer
=	O
next	pointer
;	O
(	O
*	O
nodes	pointer
)	O
->	O
last_section	pointer
->	O
end_line	int
=	O
i	int
;	O
}	O
else	O
(	O
*	O
nodes	pointer
)	O
->	O
sections	pointer
=	O
next	pointer
;	O
(	O
*	O
nodes	pointer
)	O
->	O
last_section	pointer
=	O
next	pointer
;	O
}	O
}	O
if	O
(	O
*	O
nodes	pointer
!=	O
0	int
)	O
{	O
(	O
*	O
nodes	pointer
)	O
->	O
end_line	int
=	O
nlines	int
;	O
if	O
(	O
(	O
*	O
nodes	pointer
)	O
->	O
last_section	pointer
!=	O
0	int
)	O
(	O
*	O
nodes	pointer
)	O
->	O
last_section	pointer
->	O
end_line	int
=	O
nlines	int
;	O
}	O
}	O
int	O
mark_entry_for_deletion	function
(	O
struct	O
line_data	struct
*	O
lines	pointer
,	O
int	O
nlines	int
,	O
char	O
*	O
name	pointer
)	O
{	O
int	O
something_deleted	int
=	O
0	int
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nlines	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
*	O
lines	pointer
[	O
i	int
]	O
.	O
start	pointer
==	O
'*'	O
)	O
{	O
char	O
*	O
q	pointer
;	O
char	O
*	O
p	pointer
=	O
lines	pointer
[	O
i	int
]	O
.	O
start	pointer
;	O
p	pointer
++	O
;	O
while	O
(	O
*	O
p	pointer
==	O
' '	O
)	O
p	pointer
++	O
;	O
q	pointer
=	O
p	pointer
;	O
while	O
(	O
*	O
p	pointer
!=	O
0	int
&&	O
*	O
p	pointer
!=	O
':'	O
)	O
p	pointer
++	O
;	O
p	pointer
++	O
;	O
if	O
(	O
*	O
p	pointer
==	O
':'	O
)	O
{	O
if	O
(	O
menu_item_equal	function
(	O
q	pointer
,	O
':'	O
,	O
name	pointer
)	O
)	O
{	O
lines	pointer
[	O
i	int
]	O
.	O
delete	int
=	O
1	int
;	O
something_deleted	int
=	O
1	int
;	O
}	O
}	O
else	O
{	O
while	O
(	O
*	O
p	pointer
==	O
' '	O
)	O
p	pointer
++	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'('	O
)	O
{	O
p	pointer
++	O
;	O
if	O
(	O
menu_item_equal	function
(	O
p	pointer
,	O
')'	O
,	O
name	pointer
)	O
)	O
{	O
lines	pointer
[	O
i	int
]	O
.	O
delete	int
=	O
1	int
;	O
something_deleted	int
=	O
1	int
;	O
}	O
}	O
}	O
}	O
else	O
if	O
(	O
i	int
>	O
0	int
&&	O
(	O
*	O
lines	pointer
[	O
i	int
]	O
.	O
start	pointer
==	O
' '	O
||	O
*	O
lines	pointer
[	O
i	int
]	O
.	O
start	pointer
==	O
'\t'	O
)	O
)	O
{	O
lines	pointer
[	O
i	int
]	O
.	O
delete	int
=	O
lines	pointer
[	O
i	int
-	O
1	int
]	O
.	O
delete	int
;	O
}	O
}	O
return	O
something_deleted	int
;	O
}	O
static	O
size_t	long
adjust_column	function
(	O
size_t	long
column	long
,	O
char	O
c	int
)	O
{	O
if	O
(	O
c	int
==	O
'\b'	O
)	O
{	O
if	O
(	O
column	long
>	O
0	int
)	O
column	long
--	O
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'\r'	O
)	O
column	long
=	O
0	int
;	O
else	O
if	O
(	O
c	int
==	O
'\t'	O
)	O
column	long
+=	O
TAB_WIDTH	int
-	O
column	long
%	O
TAB_WIDTH	int
;	O
else	O
column	long
++	O
;	O
return	O
column	long
;	O
}	O
static	O
int	O
format_entry	function
(	O
char	O
*	O
name	pointer
,	O
size_t	long
name_len	int
,	O
char	O
*	O
desc	int
,	O
size_t	long
desc_len	long
,	O
int	O
calign	int
,	O
int	O
align	int
,	O
size_t	long
width	long
,	O
char	O
*	O
*	O
outstr_out	pointer
,	O
size_t	long
*	O
outstr_len	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
char	O
c	int
;	O
size_t	long
column	long
=	O
0	int
;	O
static	O
char	O
*	O
line_out	pointer
=	O
NULL	O
;	O
size_t	long
offset_out	long
=	O
0	int
;	O
static	O
size_t	long
allocated_out	long
=	O
0	int
;	O
char	O
*	O
outstr	pointer
;	O
if	O
(	O
!	O
desc	int
||	O
!	O
name	pointer
)	O
return	O
1	int
;	O
outstr	pointer
=	O
xmalloc	function
(	O
width	long
+	O
(	O
desc_len	long
+	O
width	long
)	O
/	O
(	O
width	long
-	O
align	int
)	O
*	O
width	long
*	O
2	int
*	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
outstr	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
strncat	function
(	O
outstr	pointer
,	O
name	pointer
,	O
name_len	int
)	O
;	O
column	long
=	O
name_len	int
;	O
if	O
(	O
name_len	int
>	O
calign	int
-	O
2	int
)	O
{	O
if	O
(	O
desc_len	long
>	O
1	int
)	O
{	O
strcat	function
(	O
outstr	pointer
,	O
"\n"	pointer
)	O
;	O
column	long
=	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
calign	int
-	O
1	int
;	O
j	int
++	O
)	O
{	O
column	long
=	O
adjust_column	function
(	O
column	long
,	O
' '	O
)	O
;	O
strcat	function
(	O
outstr	pointer
,	O
" "	pointer
)	O
;	O
}	O
}	O
}	O
else	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
calign	int
-	O
name_len	int
-	O
1	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
desc_len	long
<=	O
2	int
)	O
break	O
;	O
column	long
=	O
adjust_column	function
(	O
column	long
,	O
' '	O
)	O
;	O
strcat	function
(	O
outstr	pointer
,	O
" "	pointer
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
desc_len	long
;	O
i	int
++	O
)	O
{	O
if	O
(	O
desc_len	long
<=	O
2	int
)	O
break	O
;	O
c	int
=	O
desc	int
[	O
i	int
]	O
;	O
if	O
(	O
offset_out	long
+	O
1	int
>=	O
allocated_out	long
)	O
{	O
allocated_out	long
=	O
offset_out	long
+	O
1	int
;	O
line_out	pointer
=	O
(	O
char	O
*	O
)	O
xrealloc	function
(	O
(	O
void	O
*	O
)	O
line_out	pointer
,	O
allocated_out	long
+	O
1	int
)	O
;	O
}	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
{	O
line_out	pointer
[	O
offset_out	long
++	O
]	O
=	O
c	int
;	O
strncat	function
(	O
outstr	pointer
,	O
line_out	pointer
,	O
offset_out	long
)	O
;	O
column	long
=	O
offset_out	long
=	O
0	int
;	O
continue	O
;	O
}	O
rescan	O
:	O
column	long
=	O
adjust_column	function
(	O
column	long
,	O
c	int
)	O
;	O
if	O
(	O
column	long
>	O
width	long
)	O
{	O
int	O
found_blank	int
=	O
0	int
;	O
size_t	long
logical_end	long
=	O
offset_out	long
;	O
while	O
(	O
logical_end	long
)	O
{	O
--	O
logical_end	long
;	O
if	O
(	O
line_out	pointer
[	O
logical_end	long
]	O
==	O
' '	O
||	O
line_out	pointer
[	O
logical_end	long
]	O
==	O
'\t'	O
)	O
{	O
found_blank	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
found_blank	int
)	O
{	O
size_t	long
i	int
;	O
logical_end	long
++	O
;	O
strncat	function
(	O
outstr	pointer
,	O
line_out	pointer
,	O
logical_end	long
)	O
;	O
strcat	function
(	O
outstr	pointer
,	O
"\n"	pointer
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
align	int
-	O
1	int
;	O
j	int
++	O
)	O
{	O
column	long
=	O
adjust_column	function
(	O
column	long
,	O
' '	O
)	O
;	O
strcat	function
(	O
outstr	pointer
,	O
" "	pointer
)	O
;	O
}	O
memmove	function
(	O
line_out	pointer
,	O
line_out	pointer
+	O
logical_end	long
,	O
offset_out	long
-	O
logical_end	long
)	O
;	O
offset_out	long
-=	O
logical_end	long
;	O
for	O
(	O
column	long
=	O
i	int
=	O
0	int
;	O
i	int
<	O
offset_out	long
;	O
i	int
++	O
)	O
column	long
=	O
adjust_column	function
(	O
column	long
,	O
line_out	pointer
[	O
i	int
]	O
)	O
;	O
goto	O
rescan	O
;	O
}	O
if	O
(	O
offset_out	long
==	O
0	int
)	O
{	O
line_out	pointer
[	O
offset_out	long
++	O
]	O
=	O
c	int
;	O
continue	O
;	O
}	O
line_out	pointer
[	O
offset_out	long
++	O
]	O
=	O
'\n'	O
;	O
strncat	function
(	O
outstr	pointer
,	O
line_out	pointer
,	O
offset_out	long
)	O
;	O
column	long
=	O
offset_out	long
=	O
0	int
;	O
goto	O
rescan	O
;	O
}	O
line_out	pointer
[	O
offset_out	long
++	O
]	O
=	O
c	int
;	O
}	O
if	O
(	O
desc_len	long
<=	O
2	int
)	O
strcat	function
(	O
outstr	pointer
,	O
"\n"	pointer
)	O
;	O
if	O
(	O
offset_out	long
)	O
strncat	function
(	O
outstr	pointer
,	O
line_out	pointer
,	O
offset_out	long
)	O
;	O
*	O
outstr_out	pointer
=	O
outstr	pointer
;	O
*	O
outstr_len	pointer
=	O
strlen	function
(	O
outstr	pointer
)	O
;	O
return	O
1	int
;	O
}	O
static	O
void	O
split_entry	function
(	O
const	O
char	O
*	O
entry	pointer
,	O
char	O
*	O
*	O
name	pointer
,	O
size_t	long
*	O
name_len	int
,	O
char	O
*	O
*	O
description	pointer
,	O
size_t	long
*	O
description_len	pointer
)	O
{	O
char	O
*	O
endptr	pointer
;	O
char	O
*	O
ptr	pointer
=	O
strchr	function
(	O
entry	pointer
,	O
'.'	O
)	O
;	O
while	O
(	O
ptr	pointer
&&	O
ptr	pointer
[	O
1	int
]	O
!=	O
' '	O
&&	O
ptr	pointer
[	O
1	int
]	O
!=	O
'\t'	O
&&	O
ptr	pointer
[	O
1	int
]	O
!=	O
'\n'	O
)	O
{	O
ptr	pointer
=	O
strchr	function
(	O
ptr	pointer
+	O
1	int
,	O
'.'	O
)	O
;	O
}	O
if	O
(	O
!	O
ptr	pointer
)	O
{	O
size_t	long
length	long
=	O
strlen	function
(	O
entry	pointer
)	O
;	O
if	O
(	O
length	long
==	O
0	int
)	O
return	O
;	O
*	O
name	pointer
=	O
strdup	function
(	O
entry	pointer
)	O
;	O
*	O
name_len	int
=	O
length	long
+	O
1	int
;	O
return	O
;	O
}	O
*	O
name_len	int
=	O
(	O
size_t	long
)	O
(	O
ptr	pointer
-	O
entry	pointer
+	O
1	int
)	O
;	O
*	O
name	pointer
=	O
xmalloc	function
(	O
*	O
name_len	int
+	O
1	int
)	O
;	O
(	O
*	O
name	pointer
)	O
[	O
0	int
]	O
=	O
'\0'	O
;	O
strncat	function
(	O
*	O
name	pointer
,	O
entry	pointer
,	O
*	O
name_len	int
)	O
;	O
ptr	pointer
++	O
;	O
*	O
description	pointer
=	O
xmalloc	function
(	O
strlen	function
(	O
entry	pointer
)	O
)	O
;	O
(	O
*	O
description	pointer
)	O
[	O
0	int
]	O
=	O
'\0'	O
;	O
while	O
(	O
ptr	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
while	O
(	O
isspace	function
(	O
ptr	pointer
[	O
0	int
]	O
)	O
)	O
ptr	pointer
++	O
;	O
if	O
(	O
ptr	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
continue	O
;	O
endptr	pointer
=	O
strchr	function
(	O
ptr	pointer
,	O
'\n'	O
)	O
;	O
if	O
(	O
endptr	pointer
)	O
{	O
size_t	long
length	long
=	O
(	O
size_t	long
)	O
(	O
endptr	pointer
-	O
ptr	pointer
)	O
/	O
sizeof	O
(	O
char	O
)	O
;	O
strncat	function
(	O
*	O
description	pointer
,	O
ptr	pointer
,	O
length	long
)	O
;	O
ptr	pointer
=	O
endptr	pointer
;	O
ptr	pointer
++	O
;	O
if	O
(	O
length	long
>	O
1	int
&&	O
strlen	function
(	O
ptr	pointer
)	O
>	O
0	int
)	O
{	O
endptr	pointer
--	O
;	O
if	O
(	O
*	O
endptr	pointer
==	O
'.'	O
)	O
strcat	function
(	O
*	O
description	pointer
,	O
"  "	pointer
)	O
;	O
else	O
if	O
(	O
!	O
isspace	function
(	O
*	O
endptr	pointer
)	O
)	O
strcat	function
(	O
*	O
description	pointer
,	O
" "	pointer
)	O
;	O
}	O
}	O
else	O
{	O
size_t	long
length	long
=	O
strlen	function
(	O
ptr	pointer
)	O
;	O
strncat	function
(	O
*	O
description	pointer
,	O
ptr	pointer
,	O
length	long
)	O
;	O
ptr	pointer
+=	O
length	long
;	O
}	O
}	O
strcat	function
(	O
*	O
description	pointer
,	O
"\n"	pointer
)	O
;	O
*	O
description_len	pointer
=	O
strlen	function
(	O
*	O
description	pointer
)	O
;	O
}	O
static	O
void	O
reformat_new_entries	function
(	O
struct	O
spec_entry	struct
*	O
entries	pointer
,	O
int	O
calign_cli	int
,	O
int	O
align_cli	int
,	O
int	O
maxwidth_cli	int
)	O
{	O
struct	O
spec_entry	struct
*	O
entry	pointer
;	O
for	O
(	O
entry	pointer
=	O
entries	pointer
;	O
entry	pointer
;	O
entry	pointer
=	O
entry	pointer
->	O
next	pointer
)	O
{	O
int	O
calign	int
=	O
-	O
1	int
,	O
align	int
=	O
-	O
1	int
,	O
maxwidth	int
=	O
-	O
1	int
;	O
char	O
*	O
name	pointer
=	O
NULL	O
,	O
*	O
desc	int
=	O
NULL	O
;	O
size_t	long
name_len	int
=	O
0	int
,	O
desc_len	long
=	O
0	int
;	O
split_entry	function
(	O
entry	pointer
->	O
text	pointer
,	O
&	O
name	pointer
,	O
&	O
name_len	int
,	O
&	O
desc	int
,	O
&	O
desc_len	long
)	O
;	O
free	function
(	O
entry	pointer
->	O
text	pointer
)	O
;	O
if	O
(	O
calign_cli	int
==	O
-	O
1	int
||	O
align_cli	int
==	O
-	O
1	int
)	O
{	O
struct	O
spec_section	struct
*	O
section	pointer
;	O
calign	int
=	O
calign_cli	int
;	O
align	int
=	O
align_cli	int
;	O
for	O
(	O
section	pointer
=	O
entry	pointer
->	O
entry_sections	pointer
;	O
section	pointer
&&	O
section	pointer
!=	O
entry	pointer
->	O
entry_sections_tail	pointer
;	O
section	pointer
=	O
section	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
section	pointer
->	O
name	pointer
,	O
"Individual utilities"	pointer
)	O
)	O
{	O
if	O
(	O
calign	int
==	O
-	O
1	int
)	O
calign	int
=	O
48	int
+	O
1	int
;	O
if	O
(	O
align	int
==	O
-	O
1	int
)	O
align	int
=	O
50	int
+	O
1	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
calign	int
==	O
-	O
1	int
)	O
calign	int
=	O
32	int
+	O
1	int
;	O
if	O
(	O
align	int
==	O
-	O
1	int
)	O
align	int
=	O
34	int
+	O
1	int
;	O
}	O
else	O
{	O
calign	int
=	O
calign_cli	int
;	O
align	int
=	O
align_cli	int
;	O
}	O
maxwidth	int
=	O
maxwidth_cli	int
==	O
-	O
1	int
?	O
79	int
:	O
maxwidth_cli	int
;	O
format_entry	function
(	O
name	pointer
,	O
name_len	int
,	O
desc	int
,	O
desc_len	long
,	O
calign	int
,	O
align	int
,	O
maxwidth	int
,	O
&	O
entry	pointer
->	O
text	pointer
,	O
&	O
entry	pointer
->	O
text_len	long
)	O
;	O
}	O
}	O
void	O
add_missing_basenames	function
(	O
struct	O
spec_entry	struct
*	O
entries	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
spec_entry	struct
*	O
entry	pointer
;	O
for	O
(	O
entry	pointer
=	O
entries	pointer
;	O
entry	pointer
;	O
entry	pointer
=	O
entry	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
entry	pointer
->	O
missing_basename	int
)	O
{	O
char	O
*	O
info	pointer
,	O
*	O
rest	pointer
,	O
*	O
text	pointer
;	O
size_t	long
name_len	int
=	O
strlen	function
(	O
name	pointer
)	O
;	O
char	O
*	O
ptr	pointer
=	O
strstr	function
(	O
entry	pointer
->	O
text	pointer
,	O
": (). "	pointer
)	O
;	O
if	O
(	O
!	O
ptr	pointer
)	O
return	O
;	O
ptr	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
rest	pointer
=	O
ptr	pointer
+=	O
strlen	function
(	O
": (). "	pointer
)	O
;	O
info	pointer
=	O
xmalloc	function
(	O
name_len	int
+	O
7	int
)	O
;	O
snprintf	function
(	O
info	pointer
,	O
name_len	int
+	O
7	int
,	O
": (%s). "	pointer
,	O
name	pointer
)	O
;	O
text	pointer
=	O
concat	function
(	O
entry	pointer
->	O
text	pointer
,	O
info	pointer
,	O
rest	pointer
)	O
;	O
free	function
(	O
info	pointer
)	O
;	O
if	O
(	O
entry	pointer
->	O
text	pointer
)	O
free	function
(	O
entry	pointer
->	O
text	pointer
)	O
;	O
entry	pointer
->	O
text	pointer
=	O
text	pointer
;	O
entry	pointer
->	O
text_len	long
=	O
strlen	function
(	O
entry	pointer
->	O
text	pointer
)	O
;	O
entry	pointer
->	O
missing_name	int
=	O
0	int
;	O
entry	pointer
->	O
missing_basename	int
=	O
0	int
;	O
}	O
}	O
}	O
void	O
add_missing_names	function
(	O
struct	O
spec_entry	struct
*	O
entries	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
spec_entry	struct
*	O
entry	pointer
;	O
for	O
(	O
entry	pointer
=	O
entries	pointer
;	O
entry	pointer
;	O
entry	pointer
=	O
entry	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
entry	pointer
->	O
missing_name	int
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
add_nl	int
=	O
1	int
;	O
if	O
(	O
entry	pointer
->	O
text	pointer
)	O
if	O
(	O
entry	pointer
->	O
text	pointer
[	O
entry	pointer
->	O
text_len	long
-	O
1	int
]	O
==	O
'\n'	O
)	O
add_nl	int
=	O
0	int
;	O
if	O
(	O
name	pointer
[	O
0	int
]	O
==	O
'*'	O
)	O
text	pointer
=	O
concat	function
(	O
name	pointer
,	O
entry	pointer
->	O
text	pointer
==	O
NULL	O
?	O
""	pointer
:	O
entry	pointer
->	O
text	pointer
,	O
add_nl	int
?	O
"\n"	pointer
:	O
""	pointer
)	O
;	O
else	O
{	O
size_t	long
full_name_len	long
=	O
strlen	function
(	O
name	pointer
)	O
*	O
2	int
+	O
9	int
;	O
char	O
*	O
full_name	pointer
=	O
xmalloc	function
(	O
full_name_len	long
)	O
;	O
snprintf	function
(	O
full_name	pointer
,	O
full_name_len	long
,	O
"* %s: (%s)."	pointer
,	O
name	pointer
,	O
name	pointer
)	O
;	O
text	pointer
=	O
concat	function
(	O
full_name	pointer
,	O
entry	pointer
->	O
text	pointer
==	O
NULL	O
?	O
""	pointer
:	O
entry	pointer
->	O
text	pointer
,	O
add_nl	int
?	O
"\n"	pointer
:	O
""	pointer
)	O
;	O
free	function
(	O
full_name	pointer
)	O
;	O
}	O
if	O
(	O
entry	pointer
->	O
text	pointer
)	O
free	function
(	O
entry	pointer
->	O
text	pointer
)	O
;	O
entry	pointer
->	O
text	pointer
=	O
text	pointer
;	O
entry	pointer
->	O
text_len	long
=	O
strlen	function
(	O
entry	pointer
->	O
text	pointer
)	O
;	O
entry	pointer
->	O
missing_name	int
=	O
0	int
;	O
entry	pointer
->	O
missing_basename	int
=	O
0	int
;	O
}	O
}	O
}	O
void	O
add_missing_descriptions	function
(	O
struct	O
spec_entry	struct
*	O
entries	pointer
,	O
char	O
*	O
desc	int
)	O
{	O
struct	O
spec_entry	struct
*	O
entry	pointer
;	O
for	O
(	O
entry	pointer
=	O
entries	pointer
;	O
entry	pointer
;	O
entry	pointer
=	O
entry	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
entry	pointer
->	O
missing_description	int
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
add_nl	int
=	O
1	int
;	O
if	O
(	O
strlen	function
(	O
desc	int
)	O
>	O
1	int
)	O
if	O
(	O
desc	int
[	O
strlen	function
(	O
desc	int
)	O
-	O
1	int
]	O
==	O
'\n'	O
)	O
add_nl	int
=	O
0	int
;	O
text	pointer
=	O
concat	function
(	O
entry	pointer
->	O
text	pointer
==	O
NULL	O
?	O
""	pointer
:	O
entry	pointer
->	O
text	pointer
,	O
desc	int
,	O
add_nl	int
?	O
"\n"	pointer
:	O
""	pointer
)	O
;	O
if	O
(	O
entry	pointer
->	O
text	pointer
)	O
free	function
(	O
entry	pointer
->	O
text	pointer
)	O
;	O
entry	pointer
->	O
text	pointer
=	O
text	pointer
;	O
entry	pointer
->	O
text_len	long
=	O
strlen	function
(	O
entry	pointer
->	O
text	pointer
)	O
;	O
}	O
}	O
}	O
static	O
int	O
munge_old_style_debian_options	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
int	O
*	O
new_argc	pointer
,	O
char	O
*	O
*	O
*	O
new_argv	pointer
)	O
{	O
char	O
*	O
opt	pointer
=	O
NULL	O
;	O
int	O
i	int
,	O
err	int
;	O
char	O
*	O
argz	pointer
=	O
NULL	O
;	O
size_t	long
argz_len	long
=	O
0	int
;	O
const	O
char	O
*	O
regex	pointer
,	O
*	O
title	pointer
;	O
int	O
munge	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
"--section"	pointer
)	O
==	O
0	int
)	O
{	O
FILE	struct
*	O
fileptr	pointer
;	O
if	O
(	O
i	int
+	O
1	int
<	O
argc	int
)	O
i	int
++	O
;	O
else	O
return	O
-	O
1	int
;	O
regex	pointer
=	O
argv	pointer
[	O
i	int
]	O
;	O
if	O
(	O
i	int
+	O
1	int
<	O
argc	int
)	O
i	int
++	O
;	O
else	O
return	O
-	O
1	int
;	O
title	pointer
=	O
argv	pointer
[	O
i	int
]	O
;	O
if	O
(	O
title	pointer
[	O
0	int
]	O
==	O
'-'	O
)	O
break	O
;	O
fileptr	pointer
=	O
fopen	function
(	O
title	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
fileptr	pointer
)	O
{	O
fclose	function
(	O
fileptr	pointer
)	O
;	O
break	O
;	O
}	O
munge	int
=	O
1	int
;	O
opt	pointer
=	O
xmalloc	function
(	O
strlen	function
(	O
regex	pointer
)	O
+	O
sizeof	O
(	O
"--regex="	pointer
)	O
)	O
;	O
if	O
(	O
sprintf	function
(	O
opt	pointer
,	O
"--regex=%s"	pointer
,	O
regex	pointer
)	O
==	O
-	O
1	int
)	O
err	int
=	O
1	int
;	O
if	O
(	O
!	O
err	int
)	O
err	int
=	O
argz_add	function
(	O
&	O
argz	pointer
,	O
&	O
argz_len	long
,	O
opt	pointer
)	O
;	O
free	function
(	O
opt	pointer
)	O
;	O
opt	pointer
=	O
NULL	O
;	O
opt	pointer
=	O
xmalloc	function
(	O
strlen	function
(	O
title	pointer
)	O
+	O
sizeof	O
(	O
"--section="	pointer
)	O
)	O
;	O
if	O
(	O
sprintf	function
(	O
opt	pointer
,	O
"--section=%s"	pointer
,	O
title	pointer
)	O
==	O
-	O
1	int
)	O
err	int
=	O
1	int
;	O
if	O
(	O
!	O
err	int
)	O
err	int
=	O
argz_add	function
(	O
&	O
argz	pointer
,	O
&	O
argz_len	long
,	O
opt	pointer
)	O
;	O
free	function
(	O
opt	pointer
)	O
;	O
opt	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
err	int
)	O
err	int
=	O
argz_add	function
(	O
&	O
argz	pointer
,	O
&	O
argz_len	long
,	O
"--add-once"	pointer
)	O
;	O
}	O
else	O
err	int
=	O
argz_add	function
(	O
&	O
argz	pointer
,	O
&	O
argz_len	long
,	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
if	O
(	O
err	int
)	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
munge	int
)	O
{	O
*	O
new_argc	pointer
=	O
argz_count	function
(	O
argz	pointer
,	O
argz_len	long
)	O
;	O
*	O
new_argv	pointer
=	O
xmalloc	function
(	O
(	O
*	O
new_argc	pointer
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
opt	pointer
=	O
NULL	O
;	O
i	int
=	O
0	int
;	O
while	O
(	O
(	O
opt	pointer
=	O
argz_next	function
(	O
argz	pointer
,	O
argz_len	long
,	O
opt	pointer
)	O
)	O
)	O
{	O
(	O
*	O
new_argv	pointer
)	O
[	O
i	int
]	O
=	O
xstrdup	function
(	O
opt	pointer
)	O
;	O
i	int
++	O
;	O
}	O
(	O
*	O
new_argv	pointer
)	O
[	O
*	O
new_argc	pointer
]	O
=	O
NULL	O
;	O
}	O
free	function
(	O
argz	pointer
)	O
;	O
return	O
munge	int
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
char	O
*	O
opened_dirfilename	pointer
;	O
char	O
*	O
compression_program	pointer
;	O
char	O
*	O
infile_sans_info	pointer
;	O
char	O
*	O
infile	pointer
=	O
0	int
,	O
*	O
dirfile	pointer
=	O
0	int
;	O
int	O
calign	int
=	O
-	O
1	int
;	O
int	O
align	int
=	O
-	O
1	int
;	O
int	O
maxwidth	int
=	O
-	O
1	int
;	O
char	O
*	O
input_data	pointer
=	O
NULL	O
;	O
int	O
input_size	int
=	O
0	int
;	O
struct	O
line_data	struct
*	O
input_lines	pointer
=	O
NULL	O
;	O
int	O
input_nlines	int
=	O
0	int
;	O
struct	O
spec_section	struct
*	O
input_sections	pointer
=	O
NULL	O
;	O
struct	O
spec_entry	struct
*	O
entries_to_add	pointer
=	O
NULL	O
;	O
struct	O
spec_entry	struct
*	O
entries_to_add_from_file	pointer
=	O
NULL	O
;	O
int	O
n_entries_to_add	int
=	O
0	int
;	O
struct	O
spec_entry	struct
*	O
default_entries_to_add	pointer
=	O
NULL	O
;	O
int	O
n_default_entries_to_add	int
=	O
0	int
;	O
char	O
*	O
dir_data	pointer
;	O
int	O
dir_size	int
;	O
int	O
dir_nlines	int
;	O
struct	O
line_data	struct
*	O
dir_lines	pointer
;	O
struct	O
node	struct
*	O
dir_nodes	pointer
;	O
int	O
delete_flag	int
=	O
0	int
;	O
int	O
something_deleted	int
=	O
0	int
;	O
int	O
quiet_flag	int
=	O
0	int
;	O
int	O
debug_flag	int
=	O
0	int
;	O
int	O
i	int
;	O
setlocale	function
(	O
LC_ALL	O
,	O
""	pointer
)	O
;	O
bindtextdomain	function
(	O
PACKAGE	pointer
,	O
LOCALEDIR	O
)	O
;	O
textdomain	function
(	O
PACKAGE	pointer
)	O
;	O
if	O
(	O
!	O
freopen	function
(	O
NULL_DEVICE	pointer
,	O
"r"	pointer
,	O
stdin	pointer
)	O
)	O
pfatal_with_name	function
(	O
NULL_DEVICE	pointer
)	O
;	O
munge_old_style_debian_options	function
(	O
argc	int
,	O
argv	pointer
,	O
&	O
argc	int
,	O
&	O
argv	pointer
)	O
;	O
while	O
(	O
1	int
)	O
{	O
int	O
opt	pointer
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
"i:d:e:s:t:E:c:C:W:A:hHrk1Ia"	pointer
,	O
longopts	array
,	O
0	int
)	O
;	O
if	O
(	O
opt	pointer
==	O
EOF	O
)	O
break	O
;	O
switch	O
(	O
opt	pointer
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
1	int
:	O
abort	function
(	O
)	O
;	O
case	O
'1'	O
:	O
add_entries_into_all_matching_sections	int
=	O
0	int
;	O
break	O
;	O
case	O
'a'	O
:	O
order_new_sections_alphabetically_flag	int
=	O
0	int
;	O
break	O
;	O
case	O
'A'	O
:	O
{	O
char	O
*	O
end	pointer
=	O
NULL	O
;	O
unsigned	O
long	O
int	O
val	int
;	O
val	int
=	O
strtoul	function
(	O
optarg	pointer
,	O
&	O
end	pointer
,	O
0	int
)	O
;	O
if	O
(	O
end	pointer
==	O
NULL	O
||	O
end	pointer
==	O
optarg	pointer
||	O
*	O
end	pointer
!=	O
'\0'	O
)	O
suggest_asking_for_help	function
(	O
)	O
;	O
align	int
=	O
val	int
;	O
if	O
(	O
align	int
<=	O
0	int
)	O
suggest_asking_for_help	function
(	O
)	O
;	O
}	O
break	O
;	O
case	O
'c'	O
:	O
{	O
struct	O
spec_entry	struct
*	O
next	pointer
;	O
size_t	long
length	long
=	O
strlen	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
!	O
entries_to_add	pointer
)	O
{	O
next	pointer
=	O
(	O
struct	O
spec_entry	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
spec_entry	struct
)	O
)	O
;	O
next	pointer
->	O
text	pointer
=	O
NULL	O
;	O
next	pointer
->	O
text_len	long
=	O
0	int
;	O
next	pointer
->	O
entry_sections	pointer
=	O
NULL	O
;	O
next	pointer
->	O
entry_sections_tail	pointer
=	O
NULL	O
;	O
next	pointer
->	O
missing_name	int
=	O
1	int
;	O
next	pointer
->	O
missing_basename	int
=	O
1	int
;	O
next	pointer
->	O
next	pointer
=	O
entries_to_add	pointer
;	O
entries_to_add	pointer
=	O
next	pointer
;	O
n_entries_to_add	int
++	O
;	O
}	O
else	O
next	pointer
=	O
entries_to_add	pointer
;	O
next	pointer
->	O
missing_description	int
=	O
0	int
;	O
if	O
(	O
next	pointer
->	O
text	pointer
)	O
{	O
char	O
*	O
nl	pointer
=	O
strrchr	function
(	O
next	pointer
->	O
text	pointer
,	O
'\n'	O
)	O
;	O
if	O
(	O
nl	pointer
)	O
nl	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
}	O
next	pointer
->	O
text	pointer
=	O
concat	function
(	O
next	pointer
->	O
text	pointer
?	O
next	pointer
->	O
text	pointer
:	O
" "	pointer
,	O
optarg	pointer
,	O
optarg	pointer
[	O
length	long
-	O
1	int
]	O
==	O
'\n'	O
?	O
""	pointer
:	O
"\n"	pointer
)	O
;	O
next	pointer
->	O
text_len	long
=	O
strlen	function
(	O
next	pointer
->	O
text	pointer
)	O
;	O
}	O
break	O
;	O
case	O
'C'	O
:	O
{	O
char	O
*	O
end	pointer
=	O
NULL	O
;	O
unsigned	O
long	O
int	O
val	int
;	O
val	int
=	O
strtoul	function
(	O
optarg	pointer
,	O
&	O
end	pointer
,	O
0	int
)	O
;	O
if	O
(	O
end	pointer
==	O
NULL	O
||	O
end	pointer
==	O
optarg	pointer
||	O
*	O
end	pointer
!=	O
'\0'	O
)	O
suggest_asking_for_help	function
(	O
)	O
;	O
calign	int
=	O
val	int
;	O
if	O
(	O
calign	int
<=	O
0	int
)	O
suggest_asking_for_help	function
(	O
)	O
;	O
}	O
break	O
;	O
case	O
'd'	O
:	O
if	O
(	O
dirfile	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: already have dir file: %s\n"	pointer
)	O
,	O
progname	pointer
,	O
dirfile	pointer
)	O
;	O
suggest_asking_for_help	function
(	O
)	O
;	O
}	O
dirfile	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'D'	O
:	O
if	O
(	O
dirfile	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: already have dir file: %s\n"	pointer
)	O
,	O
progname	pointer
,	O
dirfile	pointer
)	O
;	O
suggest_asking_for_help	function
(	O
)	O
;	O
}	O
dirfile	pointer
=	O
concat	function
(	O
optarg	pointer
,	O
""	pointer
,	O
"/dir"	pointer
)	O
;	O
break	O
;	O
case	O
't'	O
:	O
{	O
struct	O
spec_entry	struct
*	O
next	pointer
=	O
(	O
struct	O
spec_entry	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
spec_entry	struct
)	O
)	O
;	O
size_t	long
length	long
;	O
if	O
(	O
optarg	pointer
[	O
0	int
]	O
!=	O
'*'	O
)	O
{	O
length	long
=	O
strlen	function
(	O
optarg	pointer
)	O
+	O
9	int
;	O
next	pointer
->	O
text	pointer
=	O
xmalloc	function
(	O
length	long
)	O
;	O
snprintf	function
(	O
next	pointer
->	O
text	pointer
,	O
length	long
,	O
"* %s: (). "	pointer
,	O
optarg	pointer
)	O
;	O
next	pointer
->	O
missing_basename	int
=	O
1	int
;	O
}	O
else	O
{	O
length	long
=	O
strlen	function
(	O
optarg	pointer
)	O
+	O
2	int
;	O
next	pointer
->	O
text	pointer
=	O
xmalloc	function
(	O
length	long
)	O
;	O
snprintf	function
(	O
next	pointer
->	O
text	pointer
,	O
length	long
,	O
"%s "	pointer
,	O
optarg	pointer
)	O
;	O
next	pointer
->	O
missing_basename	int
=	O
0	int
;	O
}	O
next	pointer
->	O
text_len	long
=	O
length	long
-	O
1	int
;	O
next	pointer
->	O
entry_sections	pointer
=	O
NULL	O
;	O
next	pointer
->	O
entry_sections_tail	pointer
=	O
NULL	O
;	O
next	pointer
->	O
next	pointer
=	O
entries_to_add	pointer
;	O
next	pointer
->	O
missing_name	int
=	O
0	int
;	O
next	pointer
->	O
missing_description	int
=	O
1	int
;	O
entries_to_add	pointer
=	O
next	pointer
;	O
n_entries_to_add	int
++	O
;	O
}	O
break	O
;	O
case	O
'E'	O
:	O
case	O
'e'	O
:	O
{	O
struct	O
spec_entry	struct
*	O
next	pointer
=	O
(	O
struct	O
spec_entry	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
spec_entry	struct
)	O
)	O
;	O
int	O
olen	int
=	O
strlen	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
!	O
(	O
*	O
optarg	pointer
!=	O
0	int
&&	O
optarg	pointer
[	O
olen	int
-	O
1	int
]	O
==	O
'\n'	O
)	O
)	O
{	O
optarg	pointer
=	O
concat	function
(	O
optarg	pointer
,	O
"\n"	pointer
,	O
""	pointer
)	O
;	O
olen	int
++	O
;	O
}	O
next	pointer
->	O
text	pointer
=	O
optarg	pointer
;	O
next	pointer
->	O
text_len	long
=	O
olen	int
;	O
next	pointer
->	O
entry_sections	pointer
=	O
NULL	O
;	O
next	pointer
->	O
entry_sections_tail	pointer
=	O
NULL	O
;	O
next	pointer
->	O
missing_name	int
=	O
0	int
;	O
next	pointer
->	O
missing_basename	int
=	O
0	int
;	O
next	pointer
->	O
missing_description	int
=	O
0	int
;	O
if	O
(	O
opt	pointer
==	O
'e'	O
)	O
{	O
next	pointer
->	O
next	pointer
=	O
entries_to_add	pointer
;	O
entries_to_add	pointer
=	O
next	pointer
;	O
n_entries_to_add	int
++	O
;	O
}	O
else	O
{	O
next	pointer
->	O
next	pointer
=	O
default_entries_to_add	pointer
;	O
default_entries_to_add	pointer
=	O
next	pointer
;	O
n_default_entries_to_add	int
++	O
;	O
}	O
}	O
break	O
;	O
case	O
'g'	O
:	O
debug_flag	int
=	O
1	int
;	O
break	O
;	O
case	O
'h'	O
:	O
case	O
'H'	O
:	O
print_help	function
(	O
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
case	O
'i'	O
:	O
if	O
(	O
infile	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: Specify the Info file only once.\n"	pointer
)	O
,	O
progname	pointer
)	O
;	O
suggest_asking_for_help	function
(	O
)	O
;	O
}	O
infile	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'I'	O
:	O
indent_flag	int
=	O
0	int
;	O
break	O
;	O
case	O
'k'	O
:	O
keep_old_flag	int
=	O
1	int
;	O
break	O
;	O
case	O
'n'	O
:	O
chicken_flag	int
=	O
1	int
;	O
break	O
;	O
case	O
'q'	O
:	O
quiet_flag	int
=	O
1	int
;	O
break	O
;	O
case	O
'r'	O
:	O
delete_flag	int
=	O
1	int
;	O
break	O
;	O
case	O
'R'	O
:	O
{	O
int	O
error	function
;	O
if	O
(	O
psecreg	pointer
)	O
{	O
warning	function
(	O
_	O
(	O
"Extra regular expression specified, ignoring `%s'"	pointer
)	O
,	O
optarg	pointer
)	O
;	O
break	O
;	O
}	O
psecreg	pointer
=	O
(	O
regex_t	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
regex_t	struct
)	O
)	O
;	O
error	function
=	O
regcomp	O
(	O
psecreg	pointer
,	O
optarg	pointer
,	O
REG_ICASE	O
|	O
REG_NOSUB	O
)	O
;	O
if	O
(	O
error	function
!=	O
0	int
)	O
{	O
int	O
errbuf_size	int
=	O
regerror	O
(	O
error	function
,	O
psecreg	pointer
,	O
NULL	O
,	O
0	int
)	O
;	O
char	O
*	O
errbuf	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
errbuf_size	int
)	O
;	O
regerror	O
(	O
error	function
,	O
psecreg	pointer
,	O
errbuf	pointer
,	O
errbuf_size	int
)	O
;	O
fatal	function
(	O
_	O
(	O
"Error in regular expression `%s': %s"	pointer
)	O
,	O
optarg	pointer
,	O
errbuf	pointer
)	O
;	O
}	O
;	O
}	O
break	O
;	O
case	O
'S'	O
:	O
default_section	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
's'	O
:	O
{	O
struct	O
spec_section	struct
*	O
next	pointer
=	O
(	O
struct	O
spec_section	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
spec_section	struct
)	O
)	O
;	O
next	pointer
->	O
name	pointer
=	O
optarg	pointer
;	O
next	pointer
->	O
next	pointer
=	O
input_sections	pointer
;	O
next	pointer
->	O
missing	int
=	O
1	int
;	O
input_sections	pointer
=	O
next	pointer
;	O
}	O
break	O
;	O
case	O
'V'	O
:	O
printf	function
(	O
"install-info (GNU %s) %s\n"	pointer
,	O
PACKAGE	pointer
,	O
VERSION	pointer
)	O
;	O
puts	function
(	O
""	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Copyright (C) %s Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n"	pointer
)	O
,	O
"2019"	pointer
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
case	O
'W'	O
:	O
{	O
char	O
*	O
end	pointer
=	O
NULL	O
;	O
unsigned	O
long	O
int	O
val	int
;	O
val	int
=	O
strtoul	function
(	O
optarg	pointer
,	O
&	O
end	pointer
,	O
0	int
)	O
;	O
if	O
(	O
end	pointer
==	O
NULL	O
||	O
end	pointer
==	O
optarg	pointer
||	O
*	O
end	pointer
!=	O
'\0'	O
)	O
suggest_asking_for_help	function
(	O
)	O
;	O
maxwidth	int
=	O
val	int
;	O
if	O
(	O
maxwidth	int
<=	O
0	int
)	O
suggest_asking_for_help	function
(	O
)	O
;	O
}	O
break	O
;	O
case	O
'x'	O
:	O
delete_flag	int
=	O
1	int
;	O
remove_exactly	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
suggest_asking_for_help	function
(	O
)	O
;	O
}	O
}	O
for	O
(	O
;	O
optind	int
<	O
argc	int
;	O
++	O
optind	int
)	O
{	O
if	O
(	O
infile	pointer
==	O
0	int
)	O
infile	pointer
=	O
argv	pointer
[	O
optind	int
]	O
;	O
else	O
if	O
(	O
dirfile	pointer
==	O
0	int
)	O
dirfile	pointer
=	O
argv	pointer
[	O
optind	int
]	O
;	O
else	O
error	function
(	O
_	O
(	O
"excess command line argument `%s'"	pointer
)	O
,	O
argv	pointer
[	O
optind	int
]	O
)	O
;	O
}	O
if	O
(	O
!	O
infile	pointer
)	O
fatal	function
(	O
_	O
(	O
"No input file specified; try --help for more information."	pointer
)	O
)	O
;	O
if	O
(	O
!	O
dirfile	pointer
)	O
fatal	function
(	O
_	O
(	O
"No dir file specified; try --help for more information."	pointer
)	O
)	O
;	O
if	O
(	O
debug_flag	int
)	O
printf	function
(	O
"debug: reading dir file %s\n"	pointer
,	O
dirfile	pointer
)	O
;	O
if	O
(	O
!	O
delete_flag	int
)	O
{	O
dir_data	pointer
=	O
readfile	function
(	O
dirfile	pointer
,	O
&	O
dir_size	int
,	O
ensure_dirfile_exists	function
,	O
&	O
opened_dirfilename	pointer
,	O
&	O
compression_program	pointer
)	O
;	O
if	O
(	O
!	O
dir_data	pointer
)	O
pfatal_with_name	function
(	O
opened_dirfilename	pointer
)	O
;	O
}	O
else	O
{	O
dir_data	pointer
=	O
readfile	function
(	O
dirfile	pointer
,	O
&	O
dir_size	int
,	O
NULL	O
,	O
&	O
opened_dirfilename	pointer
,	O
&	O
compression_program	pointer
)	O
;	O
if	O
(	O
!	O
dir_data	pointer
)	O
{	O
warning	function
(	O
_	O
(	O
"Could not read %s."	pointer
)	O
,	O
opened_dirfilename	pointer
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
}	O
dir_lines	pointer
=	O
findlines	function
(	O
dir_data	pointer
,	O
dir_size	int
,	O
&	O
dir_nlines	int
)	O
;	O
parse_dir_file	function
(	O
dir_lines	pointer
,	O
dir_nlines	int
,	O
&	O
dir_nodes	pointer
)	O
;	O
if	O
(	O
!	O
delete_flag	int
)	O
{	O
if	O
(	O
psecreg	pointer
)	O
{	O
struct	O
node	struct
*	O
node	struct
;	O
struct	O
menu_section	struct
*	O
section	pointer
;	O
for	O
(	O
node	struct
=	O
dir_nodes	pointer
;	O
node	struct
;	O
node	struct
=	O
node	struct
->	O
next	pointer
)	O
for	O
(	O
section	pointer
=	O
node	struct
->	O
sections	pointer
;	O
section	pointer
;	O
section	pointer
=	O
section	pointer
->	O
next	pointer
)	O
if	O
(	O
regexec	O
(	O
psecreg	pointer
,	O
section	pointer
->	O
name	pointer
,	O
0	int
,	O
NULL	O
,	O
0	int
)	O
==	O
0	int
)	O
{	O
struct	O
spec_section	struct
*	O
next	pointer
=	O
(	O
struct	O
spec_section	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
spec_section	struct
)	O
)	O
;	O
next	pointer
->	O
name	pointer
=	O
section	pointer
->	O
name	pointer
;	O
next	pointer
->	O
next	pointer
=	O
input_sections	pointer
;	O
next	pointer
->	O
missing	int
=	O
0	int
;	O
input_sections	pointer
=	O
next	pointer
;	O
}	O
}	O
}	O
if	O
(	O
!	O
remove_exactly	int
)	O
{	O
char	O
*	O
infile_basename	pointer
=	O
infile	pointer
+	O
strlen	function
(	O
infile	pointer
)	O
;	O
if	O
(	O
HAVE_DRIVE	O
(	O
infile	pointer
)	O
)	O
infile	pointer
+=	O
2	int
;	O
while	O
(	O
infile_basename	pointer
>	O
infile	pointer
&&	O
!	O
IS_SLASH	O
(	O
infile_basename	pointer
[	O
-	O
1	int
]	O
)	O
)	O
infile_basename	pointer
--	O
;	O
infile_sans_info	pointer
=	O
strip_info_suffix	function
(	O
infile_basename	pointer
)	O
;	O
}	O
else	O
infile_sans_info	pointer
=	O
xstrdup	function
(	O
infile	pointer
)	O
;	O
if	O
(	O
!	O
remove_exactly	int
)	O
{	O
char	O
*	O
opened_infilename	pointer
;	O
if	O
(	O
debug_flag	int
)	O
printf	function
(	O
"debug: reading input file %s\n"	pointer
,	O
infile	pointer
)	O
;	O
input_data	pointer
=	O
readfile	function
(	O
infile	pointer
,	O
&	O
input_size	int
,	O
NULL	O
,	O
&	O
opened_infilename	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
input_data	pointer
)	O
pfatal_with_name	function
(	O
opened_infilename	pointer
)	O
;	O
input_lines	pointer
=	O
findlines	function
(	O
input_data	pointer
,	O
input_size	int
,	O
&	O
input_nlines	int
)	O
;	O
}	O
i	int
=	O
parse_input	function
(	O
input_lines	pointer
,	O
input_nlines	int
,	O
&	O
input_sections	pointer
,	O
&	O
entries_to_add_from_file	pointer
,	O
delete_flag	int
)	O
;	O
if	O
(	O
!	O
delete_flag	int
)	O
{	O
if	O
(	O
entries_to_add	pointer
==	O
NULL	O
)	O
{	O
entries_to_add	pointer
=	O
entries_to_add_from_file	pointer
;	O
n_entries_to_add	int
=	O
i	int
;	O
}	O
else	O
if	O
(	O
entries_to_add	pointer
)	O
{	O
if	O
(	O
entries_to_add_from_file	pointer
==	O
NULL	O
)	O
{	O
add_missing_names	function
(	O
entries_to_add	pointer
,	O
infile_sans_info	pointer
)	O
;	O
}	O
else	O
{	O
char	O
*	O
desc	int
=	O
NULL	O
;	O
size_t	long
desc_len	long
=	O
0	int
;	O
char	O
*	O
name	pointer
=	O
NULL	O
;	O
size_t	long
name_len	int
=	O
0	int
;	O
split_entry	function
(	O
entries_to_add_from_file	pointer
->	O
text	pointer
,	O
&	O
name	pointer
,	O
&	O
name_len	int
,	O
&	O
desc	int
,	O
&	O
desc_len	long
)	O
;	O
if	O
(	O
name	pointer
)	O
{	O
if	O
(	O
name	pointer
[	O
0	int
]	O
!=	O
'*'	O
)	O
add_missing_names	function
(	O
entries_to_add	pointer
,	O
infile_sans_info	pointer
)	O
;	O
else	O
add_missing_names	function
(	O
entries_to_add	pointer
,	O
name	pointer
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
}	O
if	O
(	O
desc	int
)	O
{	O
add_missing_descriptions	function
(	O
entries_to_add	pointer
,	O
desc	int
)	O
;	O
free	function
(	O
desc	int
)	O
;	O
}	O
}	O
}	O
add_missing_basenames	function
(	O
entries_to_add	pointer
,	O
infile_sans_info	pointer
)	O
;	O
if	O
(	O
indent_flag	int
)	O
{	O
char	O
*	O
no_indent	pointer
=	O
getenv	function
(	O
"INSTALL_INFO_NO_INDENT"	pointer
)	O
;	O
if	O
(	O
!	O
no_indent	pointer
)	O
reformat_new_entries	function
(	O
entries_to_add	pointer
,	O
calign	int
,	O
align	int
,	O
maxwidth	int
)	O
;	O
}	O
if	O
(	O
input_sections	pointer
==	O
NULL	O
)	O
{	O
input_sections	pointer
=	O
(	O
struct	O
spec_section	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
spec_section	struct
)	O
)	O
;	O
input_sections	pointer
->	O
name	pointer
=	O
default_section	pointer
?	O
default_section	pointer
:	O
"Miscellaneous"	pointer
;	O
input_sections	pointer
->	O
next	pointer
=	O
NULL	O
;	O
input_sections	pointer
->	O
missing	int
=	O
1	int
;	O
}	O
if	O
(	O
entries_to_add	pointer
==	O
0	int
)	O
{	O
if	O
(	O
!	O
quiet_flag	int
)	O
warning	function
(	O
_	O
(	O
"no info dir entry in `%s'"	pointer
)	O
,	O
infile	pointer
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
if	O
(	O
n_entries_to_add	int
>	O
0	int
&&	O
entries_to_add	pointer
->	O
entry_sections	pointer
==	O
NULL	O
)	O
{	O
struct	O
spec_entry	struct
*	O
ep	pointer
;	O
for	O
(	O
ep	pointer
=	O
entries_to_add	pointer
;	O
ep	pointer
;	O
ep	pointer
=	O
ep	pointer
->	O
next	pointer
)	O
ep	pointer
->	O
entry_sections	pointer
=	O
input_sections	pointer
;	O
}	O
}	O
if	O
(	O
delete_flag	int
)	O
{	O
something_deleted	int
=	O
mark_entry_for_deletion	function
(	O
dir_lines	pointer
,	O
dir_nlines	int
,	O
infile_sans_info	pointer
)	O
;	O
if	O
(	O
!	O
something_deleted	int
&&	O
!	O
remove_exactly	int
)	O
{	O
struct	O
spec_entry	struct
*	O
entry	pointer
;	O
for	O
(	O
entry	pointer
=	O
entries_to_add	pointer
;	O
entry	pointer
;	O
entry	pointer
=	O
entry	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
entry	pointer
->	O
entry_sections	pointer
!=	O
NULL	O
)	O
{	O
char	O
*	O
name	pointer
=	O
extract_menu_item_name	function
(	O
entry	pointer
->	O
text	pointer
)	O
;	O
something_deleted	int
=	O
mark_entry_for_deletion	function
(	O
dir_lines	pointer
,	O
dir_nlines	int
,	O
name	pointer
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
}	O
}	O
if	O
(	O
!	O
something_deleted	int
)	O
{	O
struct	O
spec_entry	struct
*	O
entry	pointer
;	O
for	O
(	O
entry	pointer
=	O
entries_to_add	pointer
;	O
entry	pointer
;	O
entry	pointer
=	O
entry	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
entry	pointer
->	O
entry_sections	pointer
==	O
NULL	O
)	O
something_deleted	int
=	O
mark_entry_for_deletion	function
(	O
dir_lines	pointer
,	O
dir_nlines	int
,	O
entry	pointer
->	O
text	pointer
)	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
delete_flag	int
&&	O
something_deleted	int
&&	O
!	O
keep_old_flag	int
)	O
{	O
struct	O
node	struct
*	O
node	struct
;	O
struct	O
menu_section	struct
*	O
section	pointer
;	O
int	O
section_empty	int
;	O
for	O
(	O
node	struct
=	O
dir_nodes	pointer
;	O
node	struct
;	O
node	struct
=	O
node	struct
->	O
next	pointer
)	O
for	O
(	O
section	pointer
=	O
node	struct
->	O
sections	pointer
;	O
section	pointer
;	O
section	pointer
=	O
section	pointer
->	O
next	pointer
)	O
{	O
section_empty	int
=	O
1	int
;	O
for	O
(	O
i	int
=	O
section	pointer
->	O
end_line	int
;	O
i	int
>	O
section	pointer
->	O
start_line	int
;	O
i	int
--	O
)	O
{	O
if	O
(	O
dir_lines	pointer
[	O
i	int
-	O
1	int
]	O
.	O
delete	int
==	O
0	int
&&	O
dir_lines	pointer
[	O
i	int
-	O
1	int
]	O
.	O
size	int
!=	O
0	int
)	O
{	O
section_empty	int
=	O
0	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
section_empty	int
)	O
{	O
for	O
(	O
i	int
=	O
section	pointer
->	O
end_line	int
;	O
i	int
>=	O
section	pointer
->	O
start_line	int
;	O
i	int
--	O
)	O
dir_lines	pointer
[	O
i	int
-	O
1	int
]	O
.	O
delete	int
=	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
!	O
delete_flag	int
)	O
{	O
struct	O
node	struct
*	O
node	struct
;	O
struct	O
menu_section	struct
*	O
section	pointer
;	O
struct	O
spec_section	struct
*	O
spec	pointer
;	O
for	O
(	O
node	struct
=	O
dir_nodes	pointer
;	O
node	struct
;	O
node	struct
=	O
node	struct
->	O
next	pointer
)	O
for	O
(	O
section	pointer
=	O
node	struct
->	O
sections	pointer
;	O
section	pointer
;	O
section	pointer
=	O
section	pointer
->	O
next	pointer
)	O
{	O
for	O
(	O
i	int
=	O
section	pointer
->	O
end_line	int
;	O
i	int
>	O
section	pointer
->	O
start_line	int
;	O
i	int
--	O
)	O
if	O
(	O
dir_lines	pointer
[	O
i	int
-	O
1	int
]	O
.	O
size	int
!=	O
0	int
)	O
break	O
;	O
section	pointer
->	O
end_line	int
=	O
i	int
;	O
for	O
(	O
spec	pointer
=	O
input_sections	pointer
;	O
spec	pointer
;	O
spec	pointer
=	O
spec	pointer
->	O
next	pointer
)	O
if	O
(	O
!	O
strcmp	function
(	O
spec	pointer
->	O
name	pointer
,	O
section	pointer
->	O
name	pointer
)	O
)	O
break	O
;	O
if	O
(	O
spec	pointer
)	O
{	O
int	O
add_at_line	int
=	O
section	pointer
->	O
end_line	int
;	O
struct	O
spec_entry	struct
*	O
entry	pointer
;	O
spec	pointer
->	O
missing	int
=	O
0	int
;	O
for	O
(	O
entry	pointer
=	O
entries_to_add	pointer
;	O
entry	pointer
;	O
entry	pointer
=	O
entry	pointer
->	O
next	pointer
)	O
{	O
for	O
(	O
spec	pointer
=	O
entry	pointer
->	O
entry_sections	pointer
;	O
spec	pointer
&&	O
spec	pointer
!=	O
entry	pointer
->	O
entry_sections_tail	pointer
;	O
spec	pointer
=	O
spec	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
spec	pointer
->	O
name	pointer
,	O
section	pointer
->	O
name	pointer
)	O
)	O
break	O
;	O
}	O
if	O
(	O
!	O
spec	pointer
||	O
spec	pointer
==	O
entry	pointer
->	O
entry_sections_tail	pointer
)	O
continue	O
;	O
for	O
(	O
i	int
=	O
section	pointer
->	O
end_line	int
-	O
1	int
;	O
i	int
>=	O
section	pointer
->	O
start_line	int
-	O
1	int
;	O
i	int
--	O
)	O
{	O
if	O
(	O
dir_lines	pointer
[	O
i	int
]	O
.	O
start	pointer
[	O
0	int
]	O
==	O
'*'	O
&&	O
menu_line_equal	function
(	O
entry	pointer
->	O
text	pointer
,	O
entry	pointer
->	O
text_len	long
,	O
dir_lines	pointer
[	O
i	int
]	O
.	O
start	pointer
,	O
dir_lines	pointer
[	O
i	int
]	O
.	O
size	int
)	O
&&	O
!	O
dir_lines	pointer
[	O
i	int
]	O
.	O
delete	int
)	O
{	O
if	O
(	O
keep_old_flag	int
)	O
{	O
add_at_line	int
=	O
-	O
1	int
;	O
break	O
;	O
}	O
else	O
{	O
int	O
j	int
;	O
dir_lines	pointer
[	O
i	int
]	O
.	O
delete	int
=	O
1	int
;	O
for	O
(	O
j	int
=	O
i	int
+	O
1	int
;	O
j	int
<	O
section	pointer
->	O
end_line	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
dir_lines	pointer
[	O
j	int
]	O
.	O
start	pointer
[	O
0	int
]	O
==	O
'*'	O
)	O
break	O
;	O
dir_lines	pointer
[	O
j	int
]	O
.	O
delete	int
=	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
dir_lines	pointer
[	O
i	int
]	O
.	O
start	pointer
[	O
0	int
]	O
==	O
'*'	O
&&	O
menu_line_lessp	function
(	O
entry	pointer
->	O
text	pointer
,	O
entry	pointer
->	O
text_len	long
,	O
dir_lines	pointer
[	O
i	int
]	O
.	O
start	pointer
,	O
dir_lines	pointer
[	O
i	int
]	O
.	O
size	int
)	O
)	O
add_at_line	int
=	O
i	int
;	O
}	O
if	O
(	O
add_at_line	int
<	O
0	int
)	O
continue	O
;	O
insert_entry_here	function
(	O
entry	pointer
,	O
add_at_line	int
,	O
dir_lines	pointer
,	O
n_entries_to_add	int
)	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
!	O
delete_flag	int
)	O
{	O
struct	O
node	struct
*	O
node	struct
;	O
struct	O
node	struct
*	O
top	pointer
=	O
NULL	O
;	O
for	O
(	O
node	struct
=	O
dir_nodes	pointer
;	O
node	struct
;	O
node	struct
=	O
node	struct
->	O
next	pointer
)	O
if	O
(	O
node	struct
->	O
name	pointer
&&	O
strcmp	function
(	O
node	struct
->	O
name	pointer
,	O
"Top"	pointer
)	O
==	O
0	int
)	O
top	pointer
=	O
node	struct
;	O
if	O
(	O
top	pointer
)	O
{	O
struct	O
spec_section	struct
*	O
spec	pointer
;	O
int	O
found	int
=	O
0	int
;	O
struct	O
line_data	struct
*	O
target_line	pointer
=	O
NULL	O
;	O
for	O
(	O
spec	pointer
=	O
input_sections	pointer
;	O
spec	pointer
;	O
spec	pointer
=	O
spec	pointer
->	O
next	pointer
)	O
{	O
found	int
=	O
0	int
;	O
target_line	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
spec	pointer
->	O
missing	int
)	O
continue	O
;	O
if	O
(	O
order_new_sections_alphabetically_flag	int
)	O
{	O
struct	O
menu_section	struct
*	O
section	pointer
;	O
struct	O
menu_section	struct
*	O
prev_section	pointer
=	O
NULL	O
;	O
for	O
(	O
section	pointer
=	O
top	pointer
->	O
sections	pointer
;	O
section	pointer
;	O
section	pointer
=	O
section	pointer
->	O
next	pointer
)	O
{	O
found	int
=	O
(	O
mbscasecmp	function
(	O
spec	pointer
->	O
name	pointer
,	O
section	pointer
->	O
name	pointer
)	O
<	O
0	int
)	O
;	O
if	O
(	O
found	int
)	O
{	O
if	O
(	O
prev_section	pointer
)	O
target_line	pointer
=	O
&	O
dir_lines	pointer
[	O
prev_section	pointer
->	O
end_line	int
]	O
;	O
else	O
target_line	pointer
=	O
&	O
dir_lines	pointer
[	O
top	pointer
->	O
sections	pointer
->	O
start_line	int
-	O
2	int
]	O
;	O
break	O
;	O
}	O
prev_section	pointer
=	O
section	pointer
;	O
}	O
}	O
if	O
(	O
!	O
found	int
)	O
target_line	pointer
=	O
&	O
dir_lines	pointer
[	O
top	pointer
->	O
end_line	int
]	O
;	O
target_line	pointer
->	O
num_sections_to_add	int
++	O
;	O
target_line	pointer
->	O
add_sections_before	pointer
=	O
(	O
struct	O
spec_section	struct
*	O
*	O
)	O
xrealloc	function
(	O
target_line	pointer
->	O
add_sections_before	pointer
,	O
(	O
target_line	pointer
->	O
num_sections_to_add	int
*	O
sizeof	O
(	O
struct	O
spec_section	struct
*	O
)	O
)	O
)	O
;	O
i	int
=	O
target_line	pointer
->	O
num_sections_to_add	int
-	O
1	int
;	O
target_line	pointer
->	O
add_sections_before	pointer
[	O
i	int
]	O
=	O
spec	pointer
;	O
}	O
}	O
}	O
if	O
(	O
delete_flag	int
&&	O
!	O
something_deleted	int
&&	O
!	O
quiet_flag	int
)	O
warning	function
(	O
_	O
(	O
"no entries found for `%s'; nothing deleted"	pointer
)	O
,	O
infile	pointer
)	O
;	O
if	O
(	O
debug_flag	int
)	O
printf	function
(	O
"debug: writing dir file %s\n"	pointer
,	O
opened_dirfilename	pointer
)	O
;	O
if	O
(	O
chicken_flag	int
)	O
printf	function
(	O
"test mode, not updating dir file %s\n"	pointer
,	O
opened_dirfilename	pointer
)	O
;	O
else	O
output_dirfile	function
(	O
opened_dirfilename	pointer
,	O
dir_nlines	int
,	O
dir_lines	pointer
,	O
n_entries_to_add	int
,	O
entries_to_add	pointer
,	O
input_sections	pointer
,	O
compression_program	pointer
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
struct	O
line_data	struct
*	O
findlines	function
(	O
char	O
*	O
data	pointer
,	O
int	O
size	int
,	O
int	O
*	O
nlinesp	pointer
)	O
{	O
int	O
i	int
;	O
int	O
lineflag	int
=	O
1	int
;	O
int	O
lines_allocated	int
=	O
511	int
;	O
int	O
filled	int
=	O
0	int
;	O
struct	O
line_data	struct
*	O
lines	pointer
=	O
xmalloc	function
(	O
(	O
lines_allocated	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
struct	O
line_data	struct
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
size	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
lineflag	int
)	O
{	O
if	O
(	O
filled	int
==	O
lines_allocated	int
)	O
{	O
lines_allocated	int
=	O
(	O
(	O
lines_allocated	int
+	O
1	int
)	O
*	O
2	int
)	O
-	O
1	int
;	O
lines	pointer
=	O
xrealloc	function
(	O
lines	pointer
,	O
(	O
lines_allocated	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
struct	O
line_data	struct
)	O
)	O
;	O
}	O
lines	pointer
[	O
filled	int
]	O
.	O
start	pointer
=	O
&	O
data	pointer
[	O
i	int
]	O
;	O
lines	pointer
[	O
filled	int
]	O
.	O
add_entries_before	pointer
=	O
0	int
;	O
lines	pointer
[	O
filled	int
]	O
.	O
add_sections_before	pointer
=	O
NULL	O
;	O
lines	pointer
[	O
filled	int
]	O
.	O
num_sections_to_add	int
=	O
0	int
;	O
lines	pointer
[	O
filled	int
]	O
.	O
delete	int
=	O
0	int
;	O
if	O
(	O
filled	int
>	O
0	int
)	O
lines	pointer
[	O
filled	int
-	O
1	int
]	O
.	O
size	int
=	O
lines	pointer
[	O
filled	int
]	O
.	O
start	pointer
-	O
lines	pointer
[	O
filled	int
-	O
1	int
]	O
.	O
start	pointer
-	O
1	int
;	O
filled	int
++	O
;	O
}	O
lineflag	int
=	O
(	O
data	pointer
[	O
i	int
]	O
==	O
'\n'	O
)	O
;	O
}	O
if	O
(	O
filled	int
>	O
0	int
)	O
lines	pointer
[	O
filled	int
-	O
1	int
]	O
.	O
size	int
=	O
&	O
data	pointer
[	O
i	int
]	O
-	O
lines	pointer
[	O
filled	int
-	O
1	int
]	O
.	O
start	pointer
-	O
lineflag	int
;	O
lines	pointer
[	O
filled	int
]	O
.	O
start	pointer
=	O
NULL	O
;	O
lines	pointer
[	O
filled	int
]	O
.	O
add_entries_before	pointer
=	O
NULL	O
;	O
lines	pointer
[	O
filled	int
]	O
.	O
add_sections_before	pointer
=	O
NULL	O
;	O
lines	pointer
[	O
filled	int
]	O
.	O
num_sections_to_add	int
=	O
0	int
;	O
lines	pointer
[	O
filled	int
]	O
.	O
delete	int
=	O
0	int
;	O
lines	pointer
[	O
filled	int
]	O
.	O
size	int
=	O
0	int
;	O
*	O
nlinesp	pointer
=	O
filled	int
;	O
return	O
lines	pointer
;	O
}	O
int	O
compare_section_names	function
(	O
const	O
void	O
*	O
p1	pointer
,	O
const	O
void	O
*	O
p2	pointer
)	O
{	O
struct	O
spec_section	struct
*	O
*	O
sec1	pointer
=	O
(	O
struct	O
spec_section	struct
*	O
*	O
)	O
p1	pointer
;	O
struct	O
spec_section	struct
*	O
*	O
sec2	pointer
=	O
(	O
struct	O
spec_section	struct
*	O
*	O
)	O
p2	pointer
;	O
char	O
*	O
name1	pointer
=	O
(	O
*	O
sec1	pointer
)	O
->	O
name	pointer
;	O
char	O
*	O
name2	pointer
=	O
(	O
*	O
sec2	pointer
)	O
->	O
name	pointer
;	O
return	O
strcmp	function
(	O
name1	pointer
,	O
name2	pointer
)	O
;	O
}	O
int	O
compare_entries_text	function
(	O
const	O
void	O
*	O
p1	pointer
,	O
const	O
void	O
*	O
p2	pointer
)	O
{	O
struct	O
spec_entry	struct
*	O
*	O
entry1	pointer
=	O
(	O
struct	O
spec_entry	struct
*	O
*	O
)	O
p1	pointer
;	O
struct	O
spec_entry	struct
*	O
*	O
entry2	pointer
=	O
(	O
struct	O
spec_entry	struct
*	O
*	O
)	O
p2	pointer
;	O
char	O
*	O
text1	pointer
=	O
(	O
*	O
entry1	pointer
)	O
->	O
text	pointer
;	O
char	O
*	O
text2	pointer
=	O
(	O
*	O
entry2	pointer
)	O
->	O
text	pointer
;	O
char	O
*	O
colon1	pointer
=	O
strchr	function
(	O
text1	pointer
,	O
':'	O
)	O
;	O
char	O
*	O
colon2	pointer
=	O
strchr	function
(	O
text2	pointer
,	O
':'	O
)	O
;	O
int	O
len1	int
,	O
len2	int
;	O
if	O
(	O
!	O
colon1	pointer
)	O
len1	int
=	O
strlen	function
(	O
text1	pointer
)	O
;	O
else	O
len1	int
=	O
colon1	pointer
-	O
text1	pointer
;	O
if	O
(	O
!	O
colon2	pointer
)	O
len2	int
=	O
strlen	function
(	O
text2	pointer
)	O
;	O
else	O
len2	int
=	O
colon2	pointer
-	O
text2	pointer
;	O
return	O
mbsncasecmp	function
(	O
text1	pointer
,	O
text2	pointer
,	O
len1	int
<=	O
len2	int
?	O
len1	int
:	O
len2	int
)	O
;	O
}	O
void	O
insert_entry_here	function
(	O
struct	O
spec_entry	struct
*	O
entry	pointer
,	O
int	O
line_number	int
,	O
struct	O
line_data	struct
*	O
dir_lines	pointer
,	O
int	O
n_entries	int
)	O
{	O
int	O
i	int
,	O
j	int
;	O
if	O
(	O
dir_lines	pointer
[	O
line_number	int
]	O
.	O
add_entries_before	pointer
==	O
0	int
)	O
{	O
dir_lines	pointer
[	O
line_number	int
]	O
.	O
add_entries_before	pointer
=	O
(	O
struct	O
spec_entry	struct
*	O
*	O
)	O
xmalloc	function
(	O
n_entries	int
*	O
sizeof	O
(	O
struct	O
spec_entry	struct
*	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_entries	int
;	O
i	int
++	O
)	O
dir_lines	pointer
[	O
line_number	int
]	O
.	O
add_entries_before	pointer
[	O
i	int
]	O
=	O
0	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_entries	int
;	O
i	int
++	O
)	O
if	O
(	O
dir_lines	pointer
[	O
line_number	int
]	O
.	O
add_entries_before	pointer
[	O
i	int
]	O
==	O
0	int
||	O
menu_line_lessp	function
(	O
entry	pointer
->	O
text	pointer
,	O
strlen	function
(	O
entry	pointer
->	O
text	pointer
)	O
,	O
dir_lines	pointer
[	O
line_number	int
]	O
.	O
add_entries_before	pointer
[	O
i	int
]	O
->	O
text	pointer
,	O
strlen	function
(	O
dir_lines	pointer
[	O
line_number	int
]	O
.	O
add_entries_before	pointer
[	O
i	int
]	O
->	O
text	pointer
)	O
)	O
)	O
break	O
;	O
if	O
(	O
i	int
==	O
n_entries	int
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
dir_lines	pointer
[	O
line_number	int
]	O
.	O
add_entries_before	pointer
[	O
i	int
]	O
!=	O
0	int
)	O
for	O
(	O
j	int
=	O
n_entries	int
-	O
1	int
;	O
j	int
>	O
i	int
;	O
j	int
--	O
)	O
dir_lines	pointer
[	O
line_number	int
]	O
.	O
add_entries_before	pointer
[	O
j	int
]	O
=	O
dir_lines	pointer
[	O
line_number	int
]	O
.	O
add_entries_before	pointer
[	O
j	int
-	O
1	int
]	O
;	O
dir_lines	pointer
[	O
line_number	int
]	O
.	O
add_entries_before	pointer
[	O
i	int
]	O
=	O
entry	pointer
;	O
}	O
