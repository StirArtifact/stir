static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: db_pr.c,v 1.4 2014/04/17 20:27:27 sebdiaz Exp $"	pointer
;	O
static	O
int	O
__db_bmeta	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
FILE	struct
*	O
,	O
BTMETA	struct
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
int	O
__db_hmeta	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
FILE	struct
*	O
,	O
HMETA	struct
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
void	O
__db_meta	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
DBMETA	struct
*	O
,	O
FILE	struct
*	O
,	O
FN	struct
const	O
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
const	O
char	O
*	O
__db_dbtype_to_string	function
__P	O
(	O
(	O
DB	struct
*	O
)	O
)	O
;	O
static	O
void	O
__db_prdb	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
FILE	struct
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
FILE	struct
*	O
__db_prinit	function
__P	O
(	O
(	O
FILE	struct
*	O
)	O
)	O
;	O
static	O
void	O
__db_proff	function
__P	O
(	O
(	O
void	O
*	O
)	O
)	O
;	O
static	O
int	O
__db_prtree	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
void	O
__db_psize	function
__P	O
(	O
(	O
DB	struct
*	O
)	O
)	O
;	O
static	O
int	O
__db_qmeta	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
FILE	struct
*	O
,	O
QMETA	struct
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
size_t	long
set_psize	long
=	O
PSIZE_BOUNDARY	O
;	O
static	O
FILE	struct
*	O
set_fp	pointer
;	O
void	O
CDB___db_loadme	function
(	O
)	O
{	O
getpid	function
(	O
)	O
;	O
}	O
int	O
CDB___db_dump	function
(	O
dbp	pointer
,	O
op	enum
,	O
name	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
char	O
*	O
op	enum
,	O
*	O
name	pointer
;	O
{	O
FILE	struct
*	O
fp	pointer
,	O
*	O
save_fp	pointer
;	O
u_int32_t	int
flags	int
;	O
COMPQUIET	O
(	O
save_fp	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
set_psize	long
==	O
PSIZE_BOUNDARY	O
)	O
__db_psize	function
(	O
dbp	pointer
)	O
;	O
if	O
(	O
name	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
fp	pointer
=	O
fopen	function
(	O
name	pointer
,	O
"w"	pointer
)	O
)	O
==	O
NULL	O
)	O
return	O
(	O
CDB___os_get_errno	function
(	O
)	O
)	O
;	O
save_fp	pointer
=	O
set_fp	pointer
;	O
set_fp	pointer
=	O
fp	pointer
;	O
}	O
else	O
fp	pointer
=	O
__db_prinit	function
(	O
NULL	O
)	O
;	O
for	O
(	O
flags	int
=	O
0	int
;	O
*	O
op	enum
!=	O
'\0'	O
;	O
++	O
op	enum
)	O
switch	O
(	O
*	O
op	enum
)	O
{	O
case	O
'a'	O
:	O
LF_SET	O
(	O
DB_PR_PAGE	int
)	O
;	O
break	O
;	O
case	O
'h'	O
:	O
break	O
;	O
case	O
'r'	O
:	O
LF_SET	O
(	O
DB_PR_RECOVERYTEST	int
)	O
;	O
break	O
;	O
default	O
:	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
__db_prdb	function
(	O
dbp	pointer
,	O
fp	pointer
,	O
flags	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"%s\n"	pointer
,	O
DB_LINE	pointer
)	O
;	O
(	O
void	O
)	O
__db_prtree	function
(	O
dbp	pointer
,	O
flags	int
)	O
;	O
fflush	function
(	O
fp	pointer
)	O
;	O
if	O
(	O
name	pointer
!=	O
NULL	O
)	O
{	O
fclose	function
(	O
fp	pointer
)	O
;	O
set_fp	pointer
=	O
save_fp	pointer
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
void	O
__db_prdb	function
(	O
dbp	pointer
,	O
fp	pointer
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
FILE	struct
*	O
fp	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
if	O
(	O
flags	int
)	O
{	O
}	O
static	O
const	O
FN	struct
fn	array
[	O
]	O
=	O
{	O
{	O
DB_AM_DISCARD	int
,	O
"discard cached pages"	pointer
}	O
,	O
{	O
DB_AM_DUP	int
,	O
"duplicates"	pointer
}	O
,	O
{	O
DB_AM_INMEM	int
,	O
"in-memory"	pointer
}	O
,	O
{	O
DB_AM_PGDEF	int
,	O
"default page size"	pointer
}	O
,	O
{	O
DB_AM_RDONLY	int
,	O
"read-only"	pointer
}	O
,	O
{	O
DB_AM_SUBDB	int
,	O
"multiple-databases"	pointer
}	O
,	O
{	O
DB_AM_SWAP	int
,	O
"needswap"	pointer
}	O
,	O
{	O
DB_BT_RECNUM	int
,	O
"btree:recnum"	pointer
}	O
,	O
{	O
DB_BT_REVSPLIT	int
,	O
"btree:no reverse split"	pointer
}	O
,	O
{	O
DB_DBM_ERROR	int
,	O
"dbm/ndbm error"	pointer
}	O
,	O
{	O
DB_OPEN_CALLED	int
,	O
"DB->open called"	pointer
}	O
,	O
{	O
DB_RE_DELIMITER	int
,	O
"recno:delimiter"	pointer
}	O
,	O
{	O
DB_RE_FIXEDLEN	int
,	O
"recno:fixed-length"	pointer
}	O
,	O
{	O
DB_RE_PAD	int
,	O
"recno:pad"	pointer
}	O
,	O
{	O
DB_RE_RENUMBER	int
,	O
"recno:renumber"	pointer
}	O
,	O
{	O
DB_RE_SNAPSHOT	int
,	O
"recno:snapshot"	pointer
}	O
,	O
{	O
0	int
,	O
NULL	O
}	O
}	O
;	O
static	O
const	O
FN	struct
bfn	array
[	O
]	O
=	O
{	O
{	O
RECNO_MODIFIED	int
,	O
"recno:modified"	pointer
}	O
,	O
{	O
RECNO_READFILE	int
,	O
"recno:readfile"	pointer
}	O
,	O
{	O
0	int
,	O
NULL	O
}	O
}	O
;	O
BTREE	struct
*	O
bt	pointer
;	O
HASH	struct
*	O
h	pointer
;	O
QUEUE	struct
*	O
q	struct
;	O
COMPQUIET	O
(	O
flags	int
,	O
0	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"In-memory DB structure:\n%s: %#lx"	pointer
,	O
__db_dbtype_to_string	function
(	O
dbp	pointer
)	O
,	O
(	O
u_long	long
)	O
dbp	pointer
->	O
flags	int
)	O
;	O
CDB___db_prflags	function
(	O
dbp	pointer
->	O
flags	int
,	O
fn	array
,	O
fp	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\n"	pointer
)	O
;	O
switch	O
(	O
dbp	pointer
->	O
type	enum
)	O
{	O
case	O
DB_BTREE	int
:	O
case	O
DB_RECNO	int
:	O
bt	pointer
=	O
dbp	pointer
->	O
bt_internal	pointer
;	O
fprintf	function
(	O
fp	pointer
,	O
"bt_lpgno: %lu\n"	pointer
,	O
(	O
u_long	long
)	O
bt	pointer
->	O
bt_lpgno	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"bt_meta: %lu: bt_root: %lu\n"	pointer
,	O
(	O
u_long	long
)	O
bt	pointer
->	O
bt_meta	int
,	O
(	O
u_long	long
)	O
bt	pointer
->	O
bt_root	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"bt_maxkey: %lu bt_minkey: %lu\n"	pointer
,	O
(	O
u_long	long
)	O
bt	pointer
->	O
bt_maxkey	int
,	O
(	O
u_long	long
)	O
bt	pointer
->	O
bt_minkey	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"bt_compare: %#lx bt_prefix: %#lx\n"	pointer
,	O
(	O
u_long	long
)	O
bt	pointer
->	O
bt_compare	pointer
,	O
(	O
u_long	long
)	O
bt	pointer
->	O
bt_prefix	pointer
)	O
;	O
if	O
(	O
dbp	pointer
->	O
type	enum
==	O
DB_RECNO	int
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"re_pad: %#lx re_delim: %#lx re_len: %lu re_source: %s\n"	pointer
,	O
(	O
u_long	long
)	O
bt	pointer
->	O
re_pad	int
,	O
(	O
u_long	long
)	O
bt	pointer
->	O
re_delim	int
,	O
(	O
u_long	long
)	O
bt	pointer
->	O
re_len	int
,	O
bt	pointer
->	O
re_source	pointer
==	O
NULL	O
?	O
""	pointer
:	O
bt	pointer
->	O
re_source	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"re_last: %lu\n"	pointer
,	O
(	O
u_long	long
)	O
bt	pointer
->	O
re_last	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"cmap: %#lx smap: %#lx emap: %#lx msize: %lu\n"	pointer
,	O
(	O
u_long	long
)	O
bt	pointer
->	O
re_cmap	pointer
,	O
(	O
u_long	long
)	O
bt	pointer
->	O
re_smap	pointer
,	O
(	O
u_long	long
)	O
bt	pointer
->	O
re_emap	pointer
,	O
(	O
u_long	long
)	O
bt	pointer
->	O
re_msize	long
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"re_irec: %#lx\n"	pointer
,	O
(	O
u_long	long
)	O
bt	pointer
->	O
re_irec	pointer
)	O
;	O
}	O
fprintf	function
(	O
fp	pointer
,	O
"flags: %#lx"	pointer
,	O
(	O
u_long	long
)	O
bt	pointer
->	O
flags	int
)	O
;	O
CDB___db_prflags	function
(	O
bt	pointer
->	O
flags	int
,	O
bfn	array
,	O
fp	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\n"	pointer
)	O
;	O
break	O
;	O
case	O
DB_HASH	int
:	O
h	pointer
=	O
dbp	pointer
->	O
h_internal	pointer
;	O
fprintf	function
(	O
fp	pointer
,	O
"meta_pgno: %lu\n"	pointer
,	O
(	O
u_long	long
)	O
h	pointer
->	O
meta_pgno	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"h_ffactor: %lu\n"	pointer
,	O
(	O
u_long	long
)	O
h	pointer
->	O
h_ffactor	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"h_nelem: %lu\n"	pointer
,	O
(	O
u_long	long
)	O
h	pointer
->	O
h_nelem	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"h_hash: %#lx\n"	pointer
,	O
(	O
u_long	long
)	O
h	pointer
->	O
h_hash	pointer
)	O
;	O
break	O
;	O
case	O
DB_QUEUE	int
:	O
q	struct
=	O
dbp	pointer
->	O
q_internal	pointer
;	O
fprintf	function
(	O
fp	pointer
,	O
"q_meta: %lu\n"	pointer
,	O
(	O
u_long	long
)	O
q	struct
->	O
q_meta	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"q_root: %lu\n"	pointer
,	O
(	O
u_long	long
)	O
q	struct
->	O
q_root	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"re_pad: %#lx re_len: %lu\n"	pointer
,	O
(	O
u_long	long
)	O
q	struct
->	O
re_pad	int
,	O
(	O
u_long	long
)	O
q	struct
->	O
re_len	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"rec_page: %lu\n"	pointer
,	O
(	O
u_long	long
)	O
q	struct
->	O
rec_page	int
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
static	O
int	O
__db_prtree	function
(	O
dbp	pointer
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
PAGE	struct
*	O
h	pointer
;	O
db_pgno_t	int
i	int
,	O
last	int
;	O
int	O
ret	int
;	O
if	O
(	O
set_psize	long
==	O
PSIZE_BOUNDARY	O
)	O
__db_psize	function
(	O
dbp	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
last	int
,	O
DB_MPOOL_LAST	int
,	O
&	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
last	int
;	O
++	O
i	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
i	int
,	O
0	int
,	O
&	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
(	O
void	O
)	O
CDB___db_prpage	function
(	O
dbp	pointer
,	O
h	pointer
,	O
flags	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
(	O
void	O
)	O
fflush	function
(	O
__db_prinit	function
(	O
NULL	O
)	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
void	O
__db_meta	function
(	O
dbp	pointer
,	O
dbmeta	struct
,	O
fp	pointer
,	O
fn	array
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
DBMETA	struct
*	O
dbmeta	struct
;	O
FILE	struct
*	O
fp	pointer
;	O
FN	struct
const	O
*	O
fn	array
;	O
u_int32_t	int
flags	int
;	O
{	O
PAGE	struct
*	O
h	pointer
;	O
int	O
cnt	int
;	O
db_pgno_t	int
pgno	int
;	O
u_int8_t	char
*	O
p	pointer
;	O
int	O
ret	int
;	O
const	O
char	O
*	O
sep	pointer
;	O
fprintf	function
(	O
fp	pointer
,	O
"\tmagic: %#lx\n"	pointer
,	O
(	O
u_long	long
)	O
dbmeta	struct
->	O
magic	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\tversion: %lu\n"	pointer
,	O
(	O
u_long	long
)	O
dbmeta	struct
->	O
version	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\tpagesize: %lu\n"	pointer
,	O
(	O
u_long	long
)	O
dbmeta	struct
->	O
pagesize	long
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\ttype: %lu\n"	pointer
,	O
(	O
u_long	long
)	O
dbmeta	struct
->	O
type	enum
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\tkeys: %lu\trecords: %lu\n"	pointer
,	O
(	O
u_long	long
)	O
dbmeta	struct
->	O
key_count	int
,	O
(	O
u_long	long
)	O
dbmeta	struct
->	O
record_count	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\talloc_lsn(lsn.file: %lu lsn.offset: %lu)\n"	pointer
,	O
(	O
u_long	long
)	O
dbmeta	struct
->	O
alloc_lsn	struct
.	O
file	int
,	O
(	O
u_long	long
)	O
dbmeta	struct
->	O
alloc_lsn	struct
.	O
offset	int
)	O
;	O
if	O
(	O
!	O
LF_ISSET	O
(	O
DB_PR_RECOVERYTEST	int
)	O
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"\tfree list: %lu"	pointer
,	O
(	O
u_long	long
)	O
dbmeta	struct
->	O
free	function
)	O
;	O
for	O
(	O
pgno	int
=	O
dbmeta	struct
->	O
free	function
,	O
cnt	int
=	O
0	int
,	O
sep	pointer
=	O
", "	pointer
;	O
pgno	int
!=	O
PGNO_INVALID	int
;	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pgno	int
,	O
0	int
,	O
&	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"Unable to retrieve free-list page: %lu: %s\n"	pointer
,	O
(	O
u_long	long
)	O
pgno	int
,	O
CDB_db_strerror	function
(	O
ret	int
)	O
)	O
;	O
break	O
;	O
}	O
pgno	int
=	O
h	pointer
->	O
next_pgno	int
;	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"%s%lu"	pointer
,	O
sep	pointer
,	O
(	O
u_long	long
)	O
pgno	int
)	O
;	O
if	O
(	O
++	O
cnt	int
%	O
10	int
==	O
0	int
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"\n"	pointer
)	O
;	O
cnt	int
=	O
0	int
;	O
sep	pointer
=	O
"\t"	pointer
;	O
}	O
else	O
sep	pointer
=	O
", "	pointer
;	O
}	O
fprintf	function
(	O
fp	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
if	O
(	O
fn	array
!=	O
NULL	O
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"\tflags: %#lx"	pointer
,	O
(	O
u_long	long
)	O
dbmeta	struct
->	O
flags	int
)	O
;	O
CDB___db_prflags	function
(	O
dbmeta	struct
->	O
flags	int
,	O
fn	array
,	O
fp	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
fprintf	function
(	O
fp	pointer
,	O
"\tuid: "	pointer
)	O
;	O
for	O
(	O
p	pointer
=	O
(	O
u_int8_t	char
*	O
)	O
dbmeta	struct
->	O
uid	array
,	O
cnt	int
=	O
0	int
;	O
cnt	int
<	O
DB_FILE_ID_LEN	int
;	O
++	O
cnt	int
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"%x"	pointer
,	O
*	O
p	pointer
++	O
)	O
;	O
if	O
(	O
cnt	int
<	O
DB_FILE_ID_LEN	int
-	O
1	int
)	O
fprintf	function
(	O
fp	pointer
,	O
" "	pointer
)	O
;	O
}	O
fprintf	function
(	O
fp	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
static	O
int	O
__db_bmeta	function
(	O
dbp	pointer
,	O
fp	pointer
,	O
h	pointer
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
FILE	struct
*	O
fp	pointer
;	O
BTMETA	struct
*	O
h	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
static	O
const	O
FN	struct
mfn	array
[	O
]	O
=	O
{	O
{	O
BTM_DUP	int
,	O
"duplicates"	pointer
}	O
,	O
{	O
BTM_RECNO	int
,	O
"recno"	pointer
}	O
,	O
{	O
BTM_RECNUM	int
,	O
"btree:recnum"	pointer
}	O
,	O
{	O
BTM_FIXEDLEN	int
,	O
"recno:fixed-length"	pointer
}	O
,	O
{	O
BTM_RENUMBER	int
,	O
"recno:renumber"	pointer
}	O
,	O
{	O
BTM_SUBDB	int
,	O
"multiple-databases"	pointer
}	O
,	O
{	O
0	int
,	O
NULL	O
}	O
}	O
;	O
__db_meta	function
(	O
dbp	pointer
,	O
(	O
DBMETA	struct
*	O
)	O
h	pointer
,	O
fp	pointer
,	O
mfn	array
,	O
flags	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\tmaxkey: %lu minkey: %lu\n"	pointer
,	O
(	O
u_long	long
)	O
h	pointer
->	O
maxkey	int
,	O
(	O
u_long	long
)	O
h	pointer
->	O
minkey	int
)	O
;	O
if	O
(	O
dbp	pointer
->	O
type	enum
==	O
DB_RECNO	int
)	O
fprintf	function
(	O
fp	pointer
,	O
"\tre_len: %#lx re_pad: %lu\n"	pointer
,	O
(	O
u_long	long
)	O
h	pointer
->	O
re_len	int
,	O
(	O
u_long	long
)	O
h	pointer
->	O
re_pad	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\troot: %lu\n"	pointer
,	O
(	O
u_long	long
)	O
h	pointer
->	O
root	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__db_hmeta	function
(	O
dbp	pointer
,	O
fp	pointer
,	O
h	pointer
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
FILE	struct
*	O
fp	pointer
;	O
HMETA	struct
*	O
h	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
static	O
const	O
FN	struct
mfn	array
[	O
]	O
=	O
{	O
{	O
DB_HASH_DUP	int
,	O
"duplicates"	pointer
}	O
,	O
{	O
DB_HASH_SUBDB	int
,	O
"multiple-databases"	pointer
}	O
,	O
{	O
0	int
,	O
NULL	O
}	O
}	O
;	O
int	O
i	int
;	O
__db_meta	function
(	O
dbp	pointer
,	O
(	O
DBMETA	struct
*	O
)	O
h	pointer
,	O
fp	pointer
,	O
mfn	array
,	O
flags	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\tmax_bucket: %lu\n"	pointer
,	O
(	O
u_long	long
)	O
h	pointer
->	O
max_bucket	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\thigh_mask: %#lx\n"	pointer
,	O
(	O
u_long	long
)	O
h	pointer
->	O
high_mask	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\tlow_mask:  %#lx\n"	pointer
,	O
(	O
u_long	long
)	O
h	pointer
->	O
low_mask	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\tffactor: %lu\n"	pointer
,	O
(	O
u_long	long
)	O
h	pointer
->	O
ffactor	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\tnelem: %lu\n"	pointer
,	O
(	O
u_long	long
)	O
h	pointer
->	O
nelem	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\th_charkey: %#lx\n"	pointer
,	O
(	O
u_long	long
)	O
h	pointer
->	O
h_charkey	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\tspare points: "	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NCACHED	int
;	O
i	int
++	O
)	O
fprintf	function
(	O
fp	pointer
,	O
"%lu "	pointer
,	O
(	O
u_long	long
)	O
h	pointer
->	O
spares	array
[	O
i	int
]	O
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\n"	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__db_qmeta	function
(	O
dbp	pointer
,	O
fp	pointer
,	O
h	pointer
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
FILE	struct
*	O
fp	pointer
;	O
QMETA	struct
*	O
h	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
__db_meta	function
(	O
dbp	pointer
,	O
(	O
DBMETA	struct
*	O
)	O
h	pointer
,	O
fp	pointer
,	O
NULL	O
,	O
flags	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\tstart: %lu\n"	pointer
,	O
(	O
u_long	long
)	O
h	pointer
->	O
start	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\tfirst_recno: %lu\n"	pointer
,	O
(	O
u_long	long
)	O
h	pointer
->	O
first_recno	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\tcur_recno: %lu\n"	pointer
,	O
(	O
u_long	long
)	O
h	pointer
->	O
cur_recno	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\tre_len: %#lx re_pad: %lu\n"	pointer
,	O
(	O
u_long	long
)	O
h	pointer
->	O
re_len	int
,	O
(	O
u_long	long
)	O
h	pointer
->	O
re_pad	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\trec_page: %lu\n"	pointer
,	O
(	O
u_long	long
)	O
h	pointer
->	O
rec_page	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___db_prnpage	function
(	O
dbp	pointer
,	O
pgno	int
)	O
DB	struct
*	O
dbp	pointer
;	O
db_pgno_t	int
pgno	int
;	O
{	O
PAGE	struct
*	O
h	pointer
;	O
int	O
ret	int
;	O
if	O
(	O
set_psize	long
==	O
PSIZE_BOUNDARY	O
)	O
__db_psize	function
(	O
dbp	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pgno	int
,	O
0	int
,	O
&	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
ret	int
=	O
CDB___db_prpage	function
(	O
dbp	pointer
,	O
h	pointer
,	O
DB_PR_PAGE	int
)	O
;	O
(	O
void	O
)	O
fflush	function
(	O
__db_prinit	function
(	O
NULL	O
)	O
)	O
;	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___db_prpage	function
(	O
dbp	pointer
,	O
h	pointer
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
PAGE	struct
*	O
h	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
BINTERNAL	struct
*	O
bi	pointer
;	O
BKEYDATA	struct
*	O
bk	pointer
;	O
FILE	struct
*	O
fp	pointer
;	O
HOFFPAGE	struct
a_hkd	struct
;	O
QAMDATA	struct
*	O
qp	pointer
,	O
*	O
qep	pointer
;	O
RINTERNAL	struct
*	O
ri	pointer
;	O
db_indx_t	short
dlen	int
,	O
len	short
,	O
i	int
;	O
db_pgno_t	int
pgno	int
;	O
db_recno_t	int
recno	int
;	O
int	O
deleted	int
,	O
ret	int
;	O
const	O
char	O
*	O
s	pointer
;	O
u_int32_t	int
qlen	int
;	O
u_int8_t	char
*	O
ep	pointer
,	O
*	O
hk	pointer
,	O
*	O
p	pointer
;	O
void	O
*	O
sp	pointer
;	O
fp	pointer
=	O
__db_prinit	function
(	O
NULL	O
)	O
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_PR_RECOVERYTEST	int
)	O
&&	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_INVALID	int
)	O
return	O
(	O
0	int
)	O
;	O
s	pointer
=	O
CDB___db_pagetype_to_string	function
(	O
TYPE	O
(	O
h	pointer
)	O
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"ILLEGAL PAGE TYPE: page: %lu type: %lu\n"	pointer
,	O
(	O
u_long	long
)	O
h	pointer
->	O
pgno	int
,	O
(	O
u_long	long
)	O
TYPE	O
(	O
h	pointer
)	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
fprintf	function
(	O
fp	pointer
,	O
"page %lu: %s level: %lu"	pointer
,	O
(	O
u_long	long
)	O
h	pointer
->	O
pgno	int
,	O
s	pointer
,	O
(	O
u_long	long
)	O
h	pointer
->	O
level	char
)	O
;	O
if	O
(	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_IBTREE	int
||	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_IRECNO	int
||	O
(	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_LRECNO	int
&&	O
h	pointer
->	O
pgno	int
==	O
(	O
(	O
BTREE	struct
*	O
)	O
dbp	pointer
->	O
bt_internal	pointer
)	O
->	O
bt_root	int
)	O
)	O
fprintf	function
(	O
fp	pointer
,	O
" records: %lu"	pointer
,	O
(	O
u_long	long
)	O
RE_NREC	O
(	O
h	pointer
)	O
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
" (lsn.file: %lu lsn.offset: %lu)\n"	pointer
,	O
(	O
u_long	long
)	O
LSN	O
(	O
h	pointer
)	O
.	O
file	int
,	O
(	O
u_long	long
)	O
LSN	O
(	O
h	pointer
)	O
.	O
offset	int
)	O
;	O
switch	O
(	O
TYPE	O
(	O
h	pointer
)	O
)	O
{	O
case	O
P_BTREEMETA	int
:	O
return	O
(	O
__db_bmeta	function
(	O
dbp	pointer
,	O
fp	pointer
,	O
(	O
BTMETA	struct
*	O
)	O
h	pointer
,	O
flags	int
)	O
)	O
;	O
case	O
P_HASHMETA	int
:	O
return	O
(	O
__db_hmeta	function
(	O
dbp	pointer
,	O
fp	pointer
,	O
(	O
HMETA	struct
*	O
)	O
h	pointer
,	O
flags	int
)	O
)	O
;	O
case	O
P_QAMMETA	int
:	O
return	O
(	O
__db_qmeta	function
(	O
dbp	pointer
,	O
fp	pointer
,	O
(	O
QMETA	struct
*	O
)	O
h	pointer
,	O
flags	int
)	O
)	O
;	O
case	O
P_QAMDATA	int
:	O
if	O
(	O
!	O
LF_ISSET	O
(	O
DB_PR_PAGE	int
)	O
)	O
return	O
(	O
0	int
)	O
;	O
qlen	int
=	O
(	O
(	O
QUEUE	struct
*	O
)	O
dbp	pointer
->	O
q_internal	pointer
)	O
->	O
re_len	int
;	O
recno	int
=	O
(	O
h	pointer
->	O
pgno	int
-	O
1	int
)	O
*	O
QAM_RECNO_PER_PAGE	O
(	O
dbp	pointer
)	O
+	O
1	int
;	O
i	int
=	O
0	int
;	O
qep	pointer
=	O
(	O
QAMDATA	struct
*	O
)	O
(	O
(	O
u_int8_t	char
*	O
)	O
h	pointer
+	O
set_psize	long
-	O
qlen	int
)	O
;	O
for	O
(	O
qp	pointer
=	O
QAM_GET_RECORD	O
(	O
dbp	pointer
,	O
h	pointer
,	O
i	int
)	O
;	O
qp	pointer
<	O
qep	pointer
;	O
recno	int
++	O
,	O
i	int
++	O
,	O
qp	pointer
=	O
QAM_GET_RECORD	O
(	O
dbp	pointer
,	O
h	pointer
,	O
i	int
)	O
)	O
{	O
if	O
(	O
!	O
F_ISSET	O
(	O
qp	pointer
,	O
QAM_SET	int
)	O
)	O
continue	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"%s"	pointer
,	O
F_ISSET	O
(	O
qp	pointer
,	O
QAM_VALID	int
)	O
?	O
"\t"	pointer
:	O
"       D"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"[%03lu] %4lu "	pointer
,	O
(	O
u_long	long
)	O
recno	int
,	O
(	O
u_long	long
)	O
qp	pointer
-	O
(	O
u_long	long
)	O
h	pointer
)	O
;	O
CDB___db_pr	function
(	O
qp	pointer
->	O
data	pointer
,	O
qlen	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
s	pointer
=	O
"\t"	pointer
;	O
if	O
(	O
TYPE	O
(	O
h	pointer
)	O
!=	O
P_IBTREE	int
&&	O
TYPE	O
(	O
h	pointer
)	O
!=	O
P_IRECNO	int
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"%sprev: %4lu next: %4lu"	pointer
,	O
s	pointer
,	O
(	O
u_long	long
)	O
PREV_PGNO	O
(	O
h	pointer
)	O
,	O
(	O
u_long	long
)	O
NEXT_PGNO	O
(	O
h	pointer
)	O
)	O
;	O
s	pointer
=	O
" "	pointer
;	O
}	O
if	O
(	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_OVERFLOW	int
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"%sref cnt: %4lu "	pointer
,	O
s	pointer
,	O
(	O
u_long	long
)	O
OV_REF	O
(	O
h	pointer
)	O
)	O
;	O
CDB___db_pr	function
(	O
(	O
u_int8_t	char
*	O
)	O
h	pointer
+	O
P_OVERHEAD	O
,	O
OV_LEN	O
(	O
h	pointer
)	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
fprintf	function
(	O
fp	pointer
,	O
"%sentries: %4lu"	pointer
,	O
s	pointer
,	O
(	O
u_long	long
)	O
NUM_ENT	O
(	O
h	pointer
)	O
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
" offset: %4lu\n"	pointer
,	O
(	O
u_long	long
)	O
HOFFSET	O
(	O
h	pointer
)	O
)	O
;	O
if	O
(	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_INVALID	int
||	O
!	O
LF_ISSET	O
(	O
DB_PR_PAGE	int
)	O
)	O
return	O
(	O
0	int
)	O
;	O
ret	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NUM_ENT	O
(	O
h	pointer
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
P_ENTRY	O
(	O
h	pointer
,	O
i	int
)	O
-	O
(	O
u_int8_t	char
*	O
)	O
h	pointer
<	O
P_OVERHEAD	O
||	O
(	O
size_t	long
)	O
(	O
P_ENTRY	O
(	O
h	pointer
,	O
i	int
)	O
-	O
(	O
u_int8_t	char
*	O
)	O
h	pointer
)	O
>=	O
set_psize	long
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"ILLEGAL PAGE OFFSET: indx: %lu of %lu\n"	pointer
,	O
(	O
u_long	long
)	O
i	int
,	O
(	O
u_long	long
)	O
h	pointer
->	O
inp	array
[	O
i	int
]	O
)	O
;	O
ret	int
=	O
EINVAL	int
;	O
continue	O
;	O
}	O
deleted	int
=	O
0	int
;	O
switch	O
(	O
TYPE	O
(	O
h	pointer
)	O
)	O
{	O
case	O
P_HASH	int
:	O
case	O
P_IBTREE	int
:	O
case	O
P_IRECNO	int
:	O
sp	pointer
=	O
P_ENTRY	O
(	O
h	pointer
,	O
i	int
)	O
;	O
break	O
;	O
case	O
P_LBTREE	int
:	O
sp	pointer
=	O
P_ENTRY	O
(	O
h	pointer
,	O
i	int
)	O
;	O
deleted	int
=	O
i	int
%	O
2	int
==	O
0	int
&&	O
B_DISSET	O
(	O
GET_BKEYDATA	O
(	O
h	pointer
,	O
i	int
+	O
O_INDX	int
)	O
->	O
type	enum
)	O
;	O
break	O
;	O
case	O
P_LDUP	int
:	O
case	O
P_LRECNO	int
:	O
sp	pointer
=	O
P_ENTRY	O
(	O
h	pointer
,	O
i	int
)	O
;	O
deleted	int
=	O
B_DISSET	O
(	O
GET_BKEYDATA	O
(	O
h	pointer
,	O
i	int
)	O
->	O
type	enum
)	O
;	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
fp	pointer
,	O
"ILLEGAL PAGE ITEM: %lu\n"	pointer
,	O
(	O
u_long	long
)	O
TYPE	O
(	O
h	pointer
)	O
)	O
;	O
ret	int
=	O
EINVAL	int
;	O
continue	O
;	O
}	O
fprintf	function
(	O
fp	pointer
,	O
"%s"	pointer
,	O
deleted	int
?	O
"       D"	pointer
:	O
"\t"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"[%03lu] %4lu "	pointer
,	O
(	O
u_long	long
)	O
i	int
,	O
(	O
u_long	long
)	O
h	pointer
->	O
inp	array
[	O
i	int
]	O
)	O
;	O
switch	O
(	O
TYPE	O
(	O
h	pointer
)	O
)	O
{	O
case	O
P_HASH	int
:	O
hk	pointer
=	O
sp	pointer
;	O
switch	O
(	O
HPAGE_PTYPE	O
(	O
hk	pointer
)	O
)	O
{	O
case	O
H_OFFDUP	int
:	O
memcpy	function
(	O
&	O
pgno	int
,	O
HOFFDUP_PGNO	O
(	O
hk	pointer
)	O
,	O
sizeof	O
(	O
db_pgno_t	int
)	O
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"%4lu [offpage dups]\n"	pointer
,	O
(	O
u_long	long
)	O
pgno	int
)	O
;	O
break	O
;	O
case	O
H_DUPLICATE	int
:	O
if	O
(	O
i	int
!=	O
0	int
)	O
len	short
=	O
LEN_HKEYDATA	O
(	O
h	pointer
,	O
0	int
,	O
i	int
)	O
;	O
else	O
len	short
=	O
1	int
;	O
fprintf	function
(	O
fp	pointer
,	O
"Duplicates:\n"	pointer
)	O
;	O
for	O
(	O
p	pointer
=	O
HKEYDATA_DATA	O
(	O
hk	pointer
)	O
,	O
ep	pointer
=	O
p	pointer
+	O
len	short
;	O
p	pointer
<	O
ep	pointer
;	O
)	O
{	O
memcpy	function
(	O
&	O
dlen	int
,	O
p	pointer
,	O
sizeof	O
(	O
db_indx_t	short
)	O
)	O
;	O
p	pointer
+=	O
sizeof	O
(	O
db_indx_t	short
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\t\t"	pointer
)	O
;	O
CDB___db_pr	function
(	O
p	pointer
,	O
dlen	int
)	O
;	O
p	pointer
+=	O
sizeof	O
(	O
db_indx_t	short
)	O
+	O
dlen	int
;	O
}	O
break	O
;	O
case	O
H_KEYDATA	int
:	O
CDB___db_pr	function
(	O
HKEYDATA_DATA	O
(	O
hk	pointer
)	O
,	O
LEN_HKEYDATA	O
(	O
h	pointer
,	O
i	int
==	O
0	int
?	O
set_psize	long
:	O
0	int
,	O
i	int
)	O
)	O
;	O
break	O
;	O
case	O
H_OFFPAGE	int
:	O
memcpy	function
(	O
&	O
a_hkd	struct
,	O
hk	pointer
,	O
HOFFPAGE_SIZE	O
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"overflow: total len: %4lu page: %4lu\n"	pointer
,	O
(	O
u_long	long
)	O
a_hkd	struct
.	O
tlen	int
,	O
(	O
u_long	long
)	O
a_hkd	struct
.	O
pgno	int
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
P_IBTREE	int
:	O
bi	pointer
=	O
sp	pointer
;	O
fprintf	function
(	O
fp	pointer
,	O
"count: %4lu pgno: %4lu type: %4lu"	pointer
,	O
(	O
u_long	long
)	O
bi	pointer
->	O
nrecs	int
,	O
(	O
u_long	long
)	O
bi	pointer
->	O
pgno	int
,	O
(	O
u_long	long
)	O
bi	pointer
->	O
type	enum
)	O
;	O
switch	O
(	O
B_TYPE	O
(	O
bi	pointer
->	O
type	enum
)	O
)	O
{	O
case	O
B_KEYDATA	int
:	O
CDB___db_pr	function
(	O
bi	pointer
->	O
data	pointer
,	O
bi	pointer
->	O
len	short
)	O
;	O
break	O
;	O
case	O
B_DUPLICATE	int
:	O
case	O
B_OVERFLOW	int
:	O
__db_proff	function
(	O
bi	pointer
->	O
data	pointer
)	O
;	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
fp	pointer
,	O
"ILLEGAL BINTERNAL TYPE: %lu\n"	pointer
,	O
(	O
u_long	long
)	O
B_TYPE	O
(	O
bi	pointer
->	O
type	enum
)	O
)	O
;	O
ret	int
=	O
EINVAL	int
;	O
break	O
;	O
}	O
break	O
;	O
case	O
P_IRECNO	int
:	O
ri	pointer
=	O
sp	pointer
;	O
fprintf	function
(	O
fp	pointer
,	O
"entries %4lu pgno %4lu\n"	pointer
,	O
(	O
u_long	long
)	O
ri	pointer
->	O
nrecs	int
,	O
(	O
u_long	long
)	O
ri	pointer
->	O
pgno	int
)	O
;	O
break	O
;	O
case	O
P_LBTREE	int
:	O
case	O
P_LDUP	int
:	O
case	O
P_LRECNO	int
:	O
bk	pointer
=	O
sp	pointer
;	O
switch	O
(	O
B_TYPE	O
(	O
bk	pointer
->	O
type	enum
)	O
)	O
{	O
case	O
B_KEYDATA	int
:	O
CDB___db_pr	function
(	O
bk	pointer
->	O
data	pointer
,	O
bk	pointer
->	O
len	short
)	O
;	O
break	O
;	O
case	O
B_DUPLICATE	int
:	O
case	O
B_OVERFLOW	int
:	O
__db_proff	function
(	O
bk	pointer
)	O
;	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
fp	pointer
,	O
"ILLEGAL DUPLICATE/LBTREE/LRECNO TYPE: %lu\n"	pointer
,	O
(	O
u_long	long
)	O
B_TYPE	O
(	O
bk	pointer
->	O
type	enum
)	O
)	O
;	O
ret	int
=	O
EINVAL	int
;	O
break	O
;	O
}	O
break	O
;	O
}	O
}	O
(	O
void	O
)	O
fflush	function
(	O
fp	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
void	O
CDB___db_pr	function
(	O
p	pointer
,	O
len	short
)	O
u_int8_t	char
*	O
p	pointer
;	O
u_int32_t	int
len	short
;	O
{	O
FILE	struct
*	O
fp	pointer
;	O
u_int	int
lastch	int
;	O
int	O
i	int
;	O
fp	pointer
=	O
__db_prinit	function
(	O
NULL	O
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"len: %3lu"	pointer
,	O
(	O
u_long	long
)	O
len	short
)	O
;	O
lastch	int
=	O
'.'	O
;	O
if	O
(	O
len	short
!=	O
0	int
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
" data: "	pointer
)	O
;	O
for	O
(	O
i	int
=	O
len	short
<=	O
20	int
?	O
len	short
:	O
20	int
;	O
i	int
>	O
0	int
;	O
--	O
i	int
,	O
++	O
p	pointer
)	O
{	O
lastch	int
=	O
*	O
p	pointer
;	O
if	O
(	O
isprint	function
(	O
*	O
p	pointer
)	O
||	O
*	O
p	pointer
==	O
'\n'	O
)	O
fprintf	function
(	O
fp	pointer
,	O
"%c"	pointer
,	O
*	O
p	pointer
)	O
;	O
else	O
fprintf	function
(	O
fp	pointer
,	O
"0x%.2x"	pointer
,	O
(	O
u_int	int
)	O
*	O
p	pointer
)	O
;	O
}	O
if	O
(	O
len	short
>	O
20	int
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"..."	pointer
)	O
;	O
lastch	int
=	O
'.'	O
;	O
}	O
}	O
if	O
(	O
lastch	int
!=	O
'\n'	O
)	O
fprintf	function
(	O
fp	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
int	O
CDB___db_prdbt	function
(	O
dbtp	pointer
,	O
checkprint	int
,	O
prefix	int
,	O
handle	pointer
,	O
callback	pointer
,	O
is_recno	int
,	O
vdp	pointer
)	O
DBT	struct
*	O
dbtp	pointer
;	O
int	O
checkprint	int
;	O
const	O
char	O
*	O
prefix	int
;	O
void	O
*	O
handle	pointer
;	O
int	O
(	O
*	O
callback	pointer
)	O
__P	O
(	O
(	O
void	O
*	O
,	O
const	O
void	O
*	O
)	O
)	O
;	O
int	O
is_recno	int
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
{	O
static	O
const	O
char	O
hex	array
[	O
]	O
=	O
"0123456789abcdef"	pointer
;	O
char	O
buf	pointer
[	O
DBTBUFLEN	int
]	O
;	O
db_recno_t	int
recno	int
;	O
int	O
ret	int
;	O
u_int32_t	int
len	short
;	O
u_int8_t	char
*	O
p	pointer
;	O
if	O
(	O
vdp	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
F_ISSET	O
(	O
vdp	pointer
,	O
SALVAGE_PRINTHEADER	int
)	O
)	O
(	O
void	O
)	O
CDB___db_prheader	function
(	O
NULL	O
,	O
"__OTHER__"	pointer
,	O
0	int
,	O
0	int
,	O
handle	pointer
,	O
callback	pointer
,	O
vdp	pointer
,	O
0	int
)	O
;	O
F_CLR	O
(	O
vdp	pointer
,	O
SALVAGE_PRINTHEADER	int
)	O
;	O
F_SET	O
(	O
vdp	pointer
,	O
SALVAGE_PRINTFOOTER	int
)	O
;	O
}	O
if	O
(	O
prefix	int
!=	O
NULL	O
&&	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
prefix	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
is_recno	int
)	O
{	O
CDB___ua_memcpy	function
(	O
&	O
recno	int
,	O
dbtp	pointer
->	O
data	pointer
,	O
sizeof	O
(	O
recno	int
)	O
)	O
;	O
snprintf	function
(	O
buf	pointer
,	O
DBTBUFLEN	int
,	O
"%lu"	pointer
,	O
(	O
u_long	long
)	O
recno	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
buf	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
else	O
if	O
(	O
checkprint	int
)	O
{	O
for	O
(	O
len	short
=	O
dbtp	pointer
->	O
size	int
,	O
p	pointer
=	O
dbtp	pointer
->	O
data	pointer
;	O
len	short
--	O
;	O
++	O
p	pointer
)	O
if	O
(	O
isprint	function
(	O
*	O
p	pointer
)	O
)	O
{	O
if	O
(	O
*	O
p	pointer
==	O
'\\'	O
&&	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
"\\"	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
snprintf	function
(	O
buf	pointer
,	O
DBTBUFLEN	int
,	O
"%c"	pointer
,	O
*	O
p	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
buf	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
else	O
{	O
snprintf	function
(	O
buf	pointer
,	O
DBTBUFLEN	int
,	O
"\\%c%c"	pointer
,	O
hex	array
[	O
(	O
u_int8_t	char
)	O
(	O
*	O
p	pointer
&	O
0xf0	int
)	O
>>	O
4	int
]	O
,	O
hex	array
[	O
*	O
p	pointer
&	O
0x0f	int
]	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
buf	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
}	O
else	O
for	O
(	O
len	short
=	O
dbtp	pointer
->	O
size	int
,	O
p	pointer
=	O
dbtp	pointer
->	O
data	pointer
;	O
len	short
--	O
;	O
++	O
p	pointer
)	O
{	O
snprintf	function
(	O
buf	pointer
,	O
DBTBUFLEN	int
,	O
"%c%c"	pointer
,	O
hex	array
[	O
(	O
u_int8_t	char
)	O
(	O
*	O
p	pointer
&	O
0xf0	int
)	O
>>	O
4	int
]	O
,	O
hex	array
[	O
*	O
p	pointer
&	O
0x0f	int
]	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
buf	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
return	O
(	O
callback	pointer
(	O
handle	pointer
,	O
"\n"	pointer
)	O
)	O
;	O
}	O
static	O
void	O
__db_proff	function
(	O
vp	pointer
)	O
void	O
*	O
vp	pointer
;	O
{	O
FILE	struct
*	O
fp	pointer
;	O
BOVERFLOW	struct
*	O
bo	pointer
;	O
fp	pointer
=	O
__db_prinit	function
(	O
NULL	O
)	O
;	O
bo	pointer
=	O
vp	pointer
;	O
switch	O
(	O
B_TYPE	O
(	O
bo	pointer
->	O
type	enum
)	O
)	O
{	O
case	O
B_OVERFLOW	int
:	O
fprintf	function
(	O
fp	pointer
,	O
"overflow: total len: %4lu page: %4lu\n"	pointer
,	O
(	O
u_long	long
)	O
bo	pointer
->	O
tlen	int
,	O
(	O
u_long	long
)	O
bo	pointer
->	O
pgno	int
)	O
;	O
break	O
;	O
case	O
B_DUPLICATE	int
:	O
fprintf	function
(	O
fp	pointer
,	O
"duplicate: page: %4lu\n"	pointer
,	O
(	O
u_long	long
)	O
bo	pointer
->	O
pgno	int
)	O
;	O
break	O
;	O
}	O
}	O
void	O
CDB___db_prflags	function
(	O
flags	int
,	O
fn	array
,	O
fp	pointer
)	O
u_int32_t	int
flags	int
;	O
FN	struct
const	O
*	O
fn	array
;	O
FILE	struct
*	O
fp	pointer
;	O
{	O
const	O
FN	struct
*	O
fnp	pointer
;	O
int	O
found	int
;	O
const	O
char	O
*	O
sep	pointer
;	O
sep	pointer
=	O
" ("	pointer
;	O
for	O
(	O
found	int
=	O
0	int
,	O
fnp	pointer
=	O
fn	array
;	O
fnp	pointer
->	O
mask	int
!=	O
0	int
;	O
++	O
fnp	pointer
)	O
if	O
(	O
LF_ISSET	O
(	O
fnp	pointer
->	O
mask	int
)	O
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"%s%s"	pointer
,	O
sep	pointer
,	O
fnp	pointer
->	O
name	pointer
)	O
;	O
sep	pointer
=	O
", "	pointer
;	O
found	int
=	O
1	int
;	O
}	O
if	O
(	O
found	int
)	O
fprintf	function
(	O
fp	pointer
,	O
")"	pointer
)	O
;	O
}	O
static	O
FILE	struct
*	O
__db_prinit	function
(	O
fp	pointer
)	O
FILE	struct
*	O
fp	pointer
;	O
{	O
if	O
(	O
set_fp	pointer
==	O
NULL	O
)	O
set_fp	pointer
=	O
fp	pointer
==	O
NULL	O
?	O
stdout	pointer
:	O
fp	pointer
;	O
return	O
(	O
set_fp	pointer
)	O
;	O
}	O
static	O
void	O
__db_psize	function
(	O
dbp	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
{	O
DBMETA	struct
*	O
mp	pointer
;	O
db_pgno_t	int
pgno	int
;	O
set_psize	long
=	O
PSIZE_BOUNDARY	O
-	O
1	int
;	O
pgno	int
=	O
PGNO_BASE_MD	int
;	O
if	O
(	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pgno	int
,	O
0	int
,	O
&	O
mp	pointer
)	O
!=	O
0	int
)	O
return	O
;	O
switch	O
(	O
mp	pointer
->	O
magic	int
)	O
{	O
case	O
DB_BTREEMAGIC	int
:	O
case	O
DB_HASHMAGIC	int
:	O
case	O
DB_QAMMAGIC	int
:	O
set_psize	long
=	O
mp	pointer
->	O
pagesize	long
;	O
break	O
;	O
}	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
mp	pointer
,	O
0	int
)	O
;	O
}	O
static	O
const	O
char	O
*	O
__db_dbtype_to_string	function
(	O
dbp	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
{	O
switch	O
(	O
dbp	pointer
->	O
type	enum
)	O
{	O
case	O
DB_BTREE	int
:	O
return	O
(	O
"btree"	pointer
)	O
;	O
case	O
DB_HASH	int
:	O
return	O
(	O
"hash"	pointer
)	O
;	O
break	O
;	O
case	O
DB_RECNO	int
:	O
return	O
(	O
"recno"	pointer
)	O
;	O
break	O
;	O
case	O
DB_QUEUE	int
:	O
return	O
(	O
"queue"	pointer
)	O
;	O
default	O
:	O
return	O
(	O
"UNKNOWN TYPE"	pointer
)	O
;	O
}	O
}	O
const	O
char	O
*	O
CDB___db_pagetype_to_string	function
(	O
type	enum
)	O
u_int32_t	int
type	enum
;	O
{	O
char	O
*	O
s	pointer
;	O
s	pointer
=	O
NULL	O
;	O
switch	O
(	O
type	enum
)	O
{	O
case	O
P_BTREEMETA	int
:	O
s	pointer
=	O
"btree metadata"	pointer
;	O
break	O
;	O
case	O
P_LDUP	int
:	O
s	pointer
=	O
"duplicate"	pointer
;	O
break	O
;	O
case	O
P_HASH	int
:	O
s	pointer
=	O
"hash"	pointer
;	O
break	O
;	O
case	O
P_HASHMETA	int
:	O
s	pointer
=	O
"hash metadata"	pointer
;	O
break	O
;	O
case	O
P_IBTREE	int
:	O
s	pointer
=	O
"btree internal"	pointer
;	O
break	O
;	O
case	O
P_INVALID	int
:	O
s	pointer
=	O
"invalid"	pointer
;	O
break	O
;	O
case	O
P_IRECNO	int
:	O
s	pointer
=	O
"recno internal"	pointer
;	O
break	O
;	O
case	O
P_LBTREE	int
:	O
s	pointer
=	O
"btree leaf"	pointer
;	O
break	O
;	O
case	O
P_LRECNO	int
:	O
s	pointer
=	O
"recno leaf"	pointer
;	O
break	O
;	O
case	O
P_OVERFLOW	int
:	O
s	pointer
=	O
"overflow"	pointer
;	O
break	O
;	O
case	O
P_QAMMETA	int
:	O
s	pointer
=	O
"queue metadata"	pointer
;	O
break	O
;	O
case	O
P_QAMDATA	int
:	O
s	pointer
=	O
"queue"	pointer
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
return	O
(	O
s	pointer
)	O
;	O
}	O
int	O
CDB___db_prheader	function
(	O
dbp	pointer
,	O
subname	pointer
,	O
pflag	int
,	O
keyflag	int
,	O
handle	pointer
,	O
callback	pointer
,	O
vdp	pointer
,	O
meta_pgno	int
)	O
DB	struct
*	O
dbp	pointer
;	O
char	O
*	O
subname	pointer
;	O
int	O
pflag	int
,	O
keyflag	int
;	O
void	O
*	O
handle	pointer
;	O
int	O
(	O
*	O
callback	pointer
)	O
__P	O
(	O
(	O
void	O
*	O
,	O
const	O
void	O
*	O
)	O
)	O
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
db_pgno_t	int
meta_pgno	int
;	O
{	O
DB_BTREE_STAT	struct
*	O
btsp	pointer
;	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_HASH_STAT	struct
*	O
hsp	pointer
;	O
DB_QUEUE_STAT	struct
*	O
qsp	pointer
;	O
VRFY_PAGEINFO	struct
*	O
pip	pointer
;	O
char	O
*	O
buf	pointer
;	O
int	O
ret	int
,	O
t_ret	int
,	O
buflen	int
;	O
u_int32_t	int
dbtype	enum
;	O
btsp	pointer
=	O
NULL	O
;	O
hsp	pointer
=	O
NULL	O
;	O
qsp	pointer
=	O
NULL	O
;	O
ret	int
=	O
0	int
;	O
buf	pointer
=	O
NULL	O
;	O
COMPQUIET	O
(	O
buflen	int
,	O
0	int
)	O
;	O
if	O
(	O
dbp	pointer
==	O
NULL	O
)	O
dbenv	pointer
=	O
NULL	O
;	O
else	O
dbenv	pointer
=	O
dbp	pointer
->	O
dbenv	pointer
;	O
if	O
(	O
vdp	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_getpageinfo	function
(	O
vdp	pointer
,	O
meta_pgno	int
,	O
&	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
else	O
pip	pointer
=	O
NULL	O
;	O
if	O
(	O
dbp	pointer
==	O
NULL	O
)	O
dbtype	enum
=	O
DB_BTREE	int
;	O
else	O
if	O
(	O
pip	pointer
!=	O
NULL	O
)	O
switch	O
(	O
pip	pointer
->	O
type	enum
)	O
{	O
case	O
P_BTREEMETA	int
:	O
if	O
(	O
F_ISSET	O
(	O
pip	pointer
,	O
VRFY_IS_RECNO	int
)	O
)	O
dbtype	enum
=	O
DB_RECNO	int
;	O
else	O
dbtype	enum
=	O
DB_BTREE	int
;	O
break	O
;	O
case	O
P_HASHMETA	int
:	O
dbtype	enum
=	O
DB_HASH	int
;	O
break	O
;	O
default	O
:	O
DB_ASSERT	O
(	O
0	int
)	O
;	O
ret	int
=	O
EINVAL	int
;	O
goto	O
err	pointer
;	O
}	O
else	O
dbtype	enum
=	O
dbp	pointer
->	O
type	enum
;	O
if	O
(	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
"VERSION=2\n"	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
pflag	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
"format=print\n"	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
else	O
if	O
(	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
"format=bytevalue\n"	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
buflen	int
=	O
64	int
+	O
(	O
(	O
subname	pointer
!=	O
NULL	O
)	O
?	O
strlen	function
(	O
subname	pointer
)	O
:	O
0	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbenv	pointer
,	O
buflen	int
,	O
NULL	O
,	O
&	O
buf	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
subname	pointer
!=	O
NULL	O
)	O
{	O
snprintf	function
(	O
buf	pointer
,	O
buflen	int
,	O
"database=%s\n"	pointer
,	O
subname	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
buf	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
switch	O
(	O
dbtype	enum
)	O
{	O
case	O
DB_BTREE	int
:	O
if	O
(	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
"type=btree\n"	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
pip	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
F_ISSET	O
(	O
pip	pointer
,	O
VRFY_HAS_RECNUMS	int
)	O
)	O
if	O
(	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
"recnum=1\n"	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
pip	pointer
->	O
bt_maxkey	int
!=	O
0	int
)	O
{	O
snprintf	function
(	O
buf	pointer
,	O
buflen	int
,	O
"bt_maxkey=%lu\n"	pointer
,	O
(	O
u_long	long
)	O
pip	pointer
->	O
bt_maxkey	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
buf	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
pip	pointer
->	O
bt_minkey	int
!=	O
0	int
&&	O
pip	pointer
->	O
bt_minkey	int
!=	O
DEFMINKEYPAGE	O
)	O
{	O
snprintf	function
(	O
buf	pointer
,	O
buflen	int
,	O
"bt_minkey=%lu\n"	pointer
,	O
(	O
u_long	long
)	O
pip	pointer
->	O
bt_minkey	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
buf	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
break	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
dbp	pointer
->	O
stat	pointer
(	O
dbp	pointer
,	O
&	O
btsp	pointer
,	O
NULL	O
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
{	O
dbp	pointer
->	O
err	pointer
(	O
dbp	pointer
,	O
ret	int
,	O
"DB->stat"	pointer
)	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_BT_RECNUM	int
)	O
)	O
if	O
(	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
"recnum=1\n"	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
btsp	pointer
->	O
bt_maxkey	int
!=	O
0	int
)	O
{	O
snprintf	function
(	O
buf	pointer
,	O
buflen	int
,	O
"bt_maxkey=%lu\n"	pointer
,	O
(	O
u_long	long
)	O
btsp	pointer
->	O
bt_maxkey	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
buf	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
btsp	pointer
->	O
bt_minkey	int
!=	O
0	int
&&	O
btsp	pointer
->	O
bt_minkey	int
!=	O
DEFMINKEYPAGE	O
)	O
{	O
snprintf	function
(	O
buf	pointer
,	O
buflen	int
,	O
"bt_minkey=%lu\n"	pointer
,	O
(	O
u_long	long
)	O
btsp	pointer
->	O
bt_minkey	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
buf	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
break	O
;	O
case	O
DB_HASH	int
:	O
if	O
(	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
"type=hash\n"	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
pip	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
pip	pointer
->	O
h_ffactor	int
!=	O
0	int
)	O
{	O
snprintf	function
(	O
buf	pointer
,	O
buflen	int
,	O
"h_ffactor=%lu\n"	pointer
,	O
(	O
u_long	long
)	O
pip	pointer
->	O
h_ffactor	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
buf	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
pip	pointer
->	O
h_nelem	int
!=	O
0	int
)	O
{	O
snprintf	function
(	O
buf	pointer
,	O
buflen	int
,	O
"h_nelem=%lu\n"	pointer
,	O
(	O
u_long	long
)	O
pip	pointer
->	O
h_nelem	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
buf	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
break	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
dbp	pointer
->	O
stat	pointer
(	O
dbp	pointer
,	O
&	O
hsp	pointer
,	O
NULL	O
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
{	O
dbp	pointer
->	O
err	pointer
(	O
dbp	pointer
,	O
ret	int
,	O
"DB->stat"	pointer
)	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
hsp	pointer
->	O
hash_ffactor	int
!=	O
0	int
)	O
{	O
snprintf	function
(	O
buf	pointer
,	O
buflen	int
,	O
"h_ffactor=%lu\n"	pointer
,	O
(	O
u_long	long
)	O
hsp	pointer
->	O
hash_ffactor	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
buf	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
hsp	pointer
->	O
hash_nelem	int
!=	O
0	int
||	O
hsp	pointer
->	O
hash_nkeys	int
!=	O
0	int
)	O
{	O
snprintf	function
(	O
buf	pointer
,	O
buflen	int
,	O
"h_nelem=%lu\n"	pointer
,	O
hsp	pointer
->	O
hash_nelem	int
>	O
hsp	pointer
->	O
hash_nkeys	int
?	O
(	O
u_long	long
)	O
hsp	pointer
->	O
hash_nelem	int
:	O
(	O
u_long	long
)	O
hsp	pointer
->	O
hash_nkeys	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
buf	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
break	O
;	O
case	O
DB_QUEUE	int
:	O
if	O
(	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
"type=queue\n"	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
vdp	pointer
!=	O
NULL	O
)	O
{	O
snprintf	function
(	O
buf	pointer
,	O
buflen	int
,	O
"re_len=%lu\n"	pointer
,	O
(	O
u_long	long
)	O
vdp	pointer
->	O
re_len	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
buf	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
break	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
dbp	pointer
->	O
stat	pointer
(	O
dbp	pointer
,	O
&	O
qsp	pointer
,	O
NULL	O
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
{	O
dbp	pointer
->	O
err	pointer
(	O
dbp	pointer
,	O
ret	int
,	O
"DB->stat"	pointer
)	O
;	O
goto	O
err	pointer
;	O
}	O
snprintf	function
(	O
buf	pointer
,	O
buflen	int
,	O
"re_len=%lu\n"	pointer
,	O
(	O
u_long	long
)	O
qsp	pointer
->	O
qs_re_len	int
)	O
;	O
if	O
(	O
qsp	pointer
->	O
qs_re_pad	int
!=	O
0	int
&&	O
qsp	pointer
->	O
qs_re_pad	int
!=	O
' '	O
)	O
snprintf	function
(	O
buf	pointer
,	O
buflen	int
,	O
"re_pad=%#x\n"	pointer
,	O
qsp	pointer
->	O
qs_re_pad	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
buf	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
break	O
;	O
case	O
DB_RECNO	int
:	O
if	O
(	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
"type=recno\n"	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
pip	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
F_ISSET	O
(	O
pip	pointer
,	O
VRFY_IS_RRECNO	int
)	O
)	O
if	O
(	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
"renumber=1\n"	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
pip	pointer
->	O
re_len	int
>	O
0	int
)	O
{	O
snprintf	function
(	O
buf	pointer
,	O
buflen	int
,	O
"re_len=%lu\n"	pointer
,	O
(	O
u_long	long
)	O
pip	pointer
->	O
re_len	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
buf	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
break	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
dbp	pointer
->	O
stat	pointer
(	O
dbp	pointer
,	O
&	O
btsp	pointer
,	O
NULL	O
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
{	O
dbp	pointer
->	O
err	pointer
(	O
dbp	pointer
,	O
ret	int
,	O
"DB->stat"	pointer
)	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_RE_RENUMBER	int
)	O
)	O
if	O
(	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
"renumber=1\n"	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_RE_FIXEDLEN	int
)	O
)	O
{	O
snprintf	function
(	O
buf	pointer
,	O
buflen	int
,	O
"re_len=%lu\n"	pointer
,	O
(	O
u_long	long
)	O
btsp	pointer
->	O
bt_re_len	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
buf	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
btsp	pointer
->	O
bt_re_pad	int
!=	O
0	int
&&	O
btsp	pointer
->	O
bt_re_pad	int
!=	O
' '	O
)	O
{	O
snprintf	function
(	O
buf	pointer
,	O
buflen	int
,	O
"re_pad=%#x\n"	pointer
,	O
btsp	pointer
->	O
bt_re_pad	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
buf	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
break	O
;	O
case	O
DB_UNKNOWN	int
:	O
DB_ASSERT	O
(	O
0	int
)	O
;	O
CDB___db_err	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Impossible DB type in CDB___db_prheader"	pointer
)	O
;	O
ret	int
=	O
EINVAL	int
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
pip	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
F_ISSET	O
(	O
pip	pointer
,	O
VRFY_HAS_DUPS	int
)	O
)	O
if	O
(	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
"duplicates=1\n"	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
F_ISSET	O
(	O
pip	pointer
,	O
VRFY_HAS_DUPSORT	int
)	O
)	O
if	O
(	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
"dupsort=1\n"	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
else	O
{	O
if	O
(	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_DUP	int
)	O
)	O
if	O
(	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
"duplicates=1\n"	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_DUPSORT	int
)	O
)	O
if	O
(	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
"dupsort=1\n"	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
!	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_PGDEF	int
)	O
)	O
{	O
snprintf	function
(	O
buf	pointer
,	O
buflen	int
,	O
"db_pagesize=%lu\n"	pointer
,	O
(	O
u_long	long
)	O
dbp	pointer
->	O
pgsize	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
buf	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
}	O
if	O
(	O
keyflag	int
)	O
if	O
(	O
(	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
"keys=1\n"	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
ret	int
=	O
callback	pointer
(	O
handle	pointer
,	O
"HEADER=END\n"	pointer
)	O
;	O
err	pointer
:	O
if	O
(	O
pip	pointer
!=	O
NULL	O
&&	O
(	O
t_ret	int
=	O
CDB___db_vrfy_putpageinfo	function
(	O
vdp	pointer
,	O
pip	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
btsp	pointer
!=	O
NULL	O
)	O
CDB___os_free	function
(	O
btsp	pointer
,	O
0	int
)	O
;	O
if	O
(	O
hsp	pointer
!=	O
NULL	O
)	O
CDB___os_free	function
(	O
hsp	pointer
,	O
0	int
)	O
;	O
if	O
(	O
qsp	pointer
!=	O
NULL	O
)	O
CDB___os_free	function
(	O
qsp	pointer
,	O
0	int
)	O
;	O
if	O
(	O
buf	pointer
!=	O
NULL	O
)	O
CDB___os_free	function
(	O
buf	pointer
,	O
buflen	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___db_prfooter	function
(	O
handle	pointer
,	O
callback	pointer
)	O
void	O
*	O
handle	pointer
;	O
int	O
(	O
*	O
callback	pointer
)	O
__P	O
(	O
(	O
void	O
*	O
,	O
const	O
void	O
*	O
)	O
)	O
;	O
{	O
return	O
(	O
callback	pointer
(	O
handle	pointer
,	O
"DATA=END\n"	pointer
)	O
)	O
;	O
}	O
