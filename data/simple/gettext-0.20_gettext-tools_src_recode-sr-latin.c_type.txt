static	O
const	O
struct	O
option	struct
long_options	array
[	O
]	O
=	O
{	O
{	O
"help"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'h'	O
}	O
,	O
{	O
"version"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'V'	O
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
void	O
usage	function
(	O
int	O
status	int
)	O
__attribute__	O
(	O
(	O
noreturn	O
)	O
)	O
;	O
static	O
void	O
process	function
(	O
FILE	struct
*	O
stream	pointer
)	O
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array
[	O
]	O
)	O
{	O
bool	bool
do_help	bool
=	O
false	int
;	O
bool	bool
do_version	bool
=	O
false	int
;	O
int	O
opt	int
;	O
set_program_name	function
(	O
argv	array
[	O
0	int
]	O
)	O
;	O
setlocale	function
(	O
LC_ALL	O
,	O
""	pointer
)	O
;	O
bindtextdomain	function
(	O
PACKAGE	pointer
,	O
relocate	O
(	O
LOCALEDIR	O
)	O
)	O
;	O
textdomain	function
(	O
PACKAGE	pointer
)	O
;	O
atexit	function
(	O
close_stdout	function
)	O
;	O
while	O
(	O
(	O
opt	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	array
,	O
"hV"	pointer
,	O
long_options	array
,	O
NULL	O
)	O
)	O
!=	O
EOF	O
)	O
switch	O
(	O
opt	int
)	O
{	O
case	O
'\0'	O
:	O
break	O
;	O
case	O
'h'	O
:	O
do_help	bool
=	O
true	int
;	O
break	O
;	O
case	O
'V'	O
:	O
do_version	bool
=	O
true	int
;	O
break	O
;	O
default	O
:	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
do_version	bool
)	O
{	O
printf	function
(	O
"%s (GNU %s) %s\n"	pointer
,	O
basename	function
(	O
program_name	pointer
)	O
,	O
PACKAGE	pointer
,	O
VERSION	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Copyright (C) %s Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n"	pointer
)	O
,	O
"2006-2019"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Written by %s and %s.\n"	pointer
)	O
,	O
proper_name_utf8	function
(	O
"Danilo Segan"	pointer
,	O
"Danilo \305\240egan"	pointer
)	O
,	O
proper_name	function
(	O
"Bruno Haible"	pointer
)	O
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
if	O
(	O
do_help	bool
)	O
usage	function
(	O
EXIT_SUCCESS	int
)	O
;	O
if	O
(	O
argc	int
-	O
optind	int
>	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"too many arguments"	pointer
)	O
)	O
;	O
process	function
(	O
stdin	pointer
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
static	O
void	O
usage	function
(	O
int	O
status	int
)	O
{	O
if	O
(	O
status	int
!=	O
EXIT_SUCCESS	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Try '%s --help' for more information.\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
else	O
{	O
printf	function
(	O
_	O
(	O
"Usage: %s [OPTION]\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Recode Serbian text from Cyrillic to Latin script.\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"The input text is read from standard input.  The converted text is output to\nstandard output.\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Informative output:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -h, --help                  display this help and exit\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -V, --version               output version information and exit\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
fputs	function
(	O
_	O
(	O
"Report bugs to <bug-gnu-gettext@gnu.org>.\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
}	O
exit	function
(	O
status	int
)	O
;	O
}	O
struct	O
linebuffer	struct
{	O
size_t	long
size	long
;	O
size_t	long
length	long
;	O
char	O
*	O
buffer	pointer
;	O
}	O
;	O
static	O
inline	O
void	O
init_linebuffer	function
(	O
struct	O
linebuffer	struct
*	O
lb	pointer
)	O
{	O
lb	pointer
->	O
size	long
=	O
0	int
;	O
lb	pointer
->	O
length	long
=	O
0	int
;	O
lb	pointer
->	O
buffer	pointer
=	O
NULL	O
;	O
}	O
static	O
struct	O
linebuffer	struct
*	O
read_linebuffer	function
(	O
struct	O
linebuffer	struct
*	O
lb	pointer
,	O
FILE	struct
*	O
stream	pointer
)	O
{	O
if	O
(	O
feof	function
(	O
stream	pointer
)	O
)	O
return	O
NULL	O
;	O
else	O
{	O
char	O
*	O
p	pointer
=	O
lb	pointer
->	O
buffer	pointer
;	O
char	O
*	O
end	pointer
=	O
lb	pointer
->	O
buffer	pointer
+	O
lb	pointer
->	O
size	long
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
c	int
=	O
getc	function
(	O
stream	pointer
)	O
;	O
if	O
(	O
c	int
==	O
EOF	O
)	O
{	O
if	O
(	O
p	pointer
==	O
lb	pointer
->	O
buffer	pointer
||	O
ferror	function
(	O
stream	pointer
)	O
)	O
return	O
NULL	O
;	O
break	O
;	O
}	O
if	O
(	O
p	pointer
==	O
end	pointer
)	O
{	O
size_t	long
oldsize	long
=	O
lb	pointer
->	O
size	long
;	O
size_t	long
newsize	long
=	O
2	int
*	O
oldsize	long
+	O
40	int
;	O
lb	pointer
->	O
buffer	pointer
=	O
(	O
char	O
*	O
)	O
xrealloc	function
(	O
lb	pointer
->	O
buffer	pointer
,	O
newsize	long
)	O
;	O
lb	pointer
->	O
size	long
=	O
newsize	long
;	O
p	pointer
=	O
lb	pointer
->	O
buffer	pointer
+	O
oldsize	long
;	O
end	pointer
=	O
lb	pointer
->	O
buffer	pointer
+	O
newsize	long
;	O
}	O
*	O
p	pointer
++	O
=	O
c	int
;	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
break	O
;	O
}	O
lb	pointer
->	O
length	long
=	O
p	pointer
-	O
lb	pointer
->	O
buffer	pointer
;	O
return	O
lb	pointer
;	O
}	O
}	O
static	O
inline	O
void	O
destroy_linebuffer	function
(	O
struct	O
linebuffer	struct
*	O
lb	pointer
)	O
{	O
if	O
(	O
lb	pointer
->	O
buffer	pointer
!=	O
NULL	O
)	O
free	function
(	O
lb	pointer
->	O
buffer	pointer
)	O
;	O
}	O
static	O
void	O
process	function
(	O
FILE	struct
*	O
stream	pointer
)	O
{	O
struct	O
linebuffer	struct
lb	pointer
;	O
const	O
char	O
*	O
locale_code	pointer
=	O
locale_charset	function
(	O
)	O
;	O
bool	bool
need_code_conversion	bool
=	O
(	O
c_strcasecmp	function
(	O
locale_code	pointer
,	O
"UTF-8"	pointer
)	O
!=	O
0	int
)	O
;	O
iconv_t	pointer
conv_to_utf8	pointer
=	O
(	O
iconv_t	pointer
)	O
(	O
-	O
1	int
)	O
;	O
iconv_t	pointer
conv_from_utf8	pointer
=	O
(	O
iconv_t	pointer
)	O
(	O
-	O
1	int
)	O
;	O
char	O
*	O
last_utf8_line	pointer
;	O
size_t	long
last_utf8_line_len	long
;	O
char	O
*	O
last_backconv_line	pointer
;	O
size_t	long
last_backconv_line_len	long
;	O
init_linebuffer	function
(	O
&	O
lb	pointer
)	O
;	O
if	O
(	O
need_code_conversion	bool
)	O
{	O
{	O
conv_to_utf8	pointer
=	O
iconv_open	function
(	O
"UTF-8"	pointer
,	O
locale_code	pointer
)	O
;	O
conv_from_utf8	pointer
=	O
iconv_open	function
(	O
locale_code	pointer
,	O
"UTF-8"	pointer
)	O
;	O
}	O
if	O
(	O
conv_to_utf8	pointer
==	O
(	O
iconv_t	pointer
)	O
(	O
-	O
1	int
)	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"Cannot convert from \"%s\" to \"%s\". %s relies on iconv(), and iconv() does not support this conversion."	pointer
)	O
,	O
locale_code	pointer
,	O
"UTF-8"	pointer
,	O
basename	function
(	O
program_name	pointer
)	O
)	O
;	O
if	O
(	O
conv_from_utf8	pointer
==	O
(	O
iconv_t	pointer
)	O
(	O
-	O
1	int
)	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"Cannot convert from \"%s\" to \"%s\". %s relies on iconv(), and iconv() does not support this conversion."	pointer
)	O
,	O
"UTF-8"	pointer
,	O
locale_code	pointer
,	O
basename	function
(	O
program_name	pointer
)	O
)	O
;	O
last_utf8_line	pointer
=	O
NULL	O
;	O
last_utf8_line_len	long
=	O
0	int
;	O
last_backconv_line	pointer
=	O
NULL	O
;	O
last_backconv_line_len	long
=	O
0	int
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
char	O
*	O
line	pointer
;	O
size_t	long
line_len	long
;	O
char	O
*	O
filtered_line	pointer
;	O
size_t	long
filtered_line_len	long
;	O
if	O
(	O
read_linebuffer	function
(	O
&	O
lb	pointer
,	O
stream	pointer
)	O
==	O
NULL	O
)	O
break	O
;	O
line	pointer
=	O
lb	pointer
.	O
buffer	pointer
;	O
line_len	long
=	O
lb	pointer
.	O
length	long
;	O
if	O
(	O
line_len	long
==	O
0	int
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
need_code_conversion	bool
)	O
{	O
char	O
*	O
utf8_line	pointer
=	O
last_utf8_line	pointer
;	O
size_t	long
utf8_line_len	long
=	O
last_utf8_line_len	long
;	O
if	O
(	O
xmem_cd_iconv	function
(	O
line	pointer
,	O
line_len	long
,	O
conv_to_utf8	pointer
,	O
&	O
utf8_line	pointer
,	O
&	O
utf8_line_len	long
)	O
!=	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"input is not valid in \"%s\" encoding"	pointer
)	O
,	O
locale_code	pointer
)	O
;	O
if	O
(	O
utf8_line	pointer
!=	O
last_utf8_line	pointer
)	O
{	O
if	O
(	O
last_utf8_line	pointer
!=	O
NULL	O
)	O
free	function
(	O
last_utf8_line	pointer
)	O
;	O
last_utf8_line	pointer
=	O
utf8_line	pointer
;	O
last_utf8_line_len	long
=	O
utf8_line_len	long
;	O
}	O
line	pointer
=	O
utf8_line	pointer
;	O
line_len	long
=	O
utf8_line_len	long
;	O
}	O
serbian_to_latin	function
(	O
line	pointer
,	O
line_len	long
,	O
&	O
filtered_line	pointer
,	O
&	O
filtered_line_len	long
)	O
;	O
if	O
(	O
need_code_conversion	bool
)	O
{	O
char	O
*	O
backconv_line	pointer
=	O
last_backconv_line	pointer
;	O
size_t	long
backconv_line_len	long
=	O
last_backconv_line_len	long
;	O
if	O
(	O
xmem_cd_iconv	function
(	O
filtered_line	pointer
,	O
filtered_line_len	long
,	O
conv_from_utf8	pointer
,	O
&	O
backconv_line	pointer
,	O
&	O
backconv_line_len	long
)	O
!=	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"error while converting from \"%s\" encoding to \"%s\" encoding"	pointer
)	O
,	O
"UTF-8"	pointer
,	O
locale_code	pointer
)	O
;	O
if	O
(	O
backconv_line	pointer
!=	O
last_backconv_line	pointer
)	O
{	O
if	O
(	O
last_backconv_line	pointer
!=	O
NULL	O
)	O
free	function
(	O
last_backconv_line	pointer
)	O
;	O
last_backconv_line	pointer
=	O
backconv_line	pointer
;	O
last_backconv_line_len	long
=	O
backconv_line_len	long
;	O
}	O
fwrite	function
(	O
backconv_line	pointer
,	O
1	int
,	O
backconv_line_len	long
,	O
stdout	pointer
)	O
;	O
}	O
else	O
fwrite	function
(	O
filtered_line	pointer
,	O
1	int
,	O
filtered_line_len	long
,	O
stdout	pointer
)	O
;	O
free	function
(	O
filtered_line	pointer
)	O
;	O
}	O
if	O
(	O
need_code_conversion	bool
)	O
{	O
iconv_close	function
(	O
conv_from_utf8	pointer
)	O
;	O
iconv_close	function
(	O
conv_to_utf8	pointer
)	O
;	O
}	O
destroy_linebuffer	function
(	O
&	O
lb	pointer
)	O
;	O
}	O
