struct	O
rpc_list	struct
{	O
struct	O
rpc_list	struct
*	O
next	pointer
,	O
*	O
*	O
prevp	pointer
;	O
void	O
*	O
reply	pointer
;	O
}	O
;	O
static	O
struct	O
rpc_list	struct
*	O
outstanding_rpcs	pointer
;	O
static	O
pthread_cond_t	union
rpc_wakeup	union
=	O
PTHREAD_COND_INITIALIZER	O
;	O
static	O
pthread_mutex_t	union
outstanding_lock	union
=	O
PTHREAD_MUTEX_INITIALIZER	O
;	O
static	O
inline	O
int	O
generate_xid	function
(	O
)	O
{	O
static	O
int	O
nextxid	int
;	O
if	O
(	O
nextxid	int
==	O
0	int
)	O
nextxid	int
=	O
mapped_time	pointer
->	O
seconds	O
;	O
return	O
nextxid	int
++	O
;	O
}	O
int	O
*	O
initialize_rpc	function
(	O
int	O
program	int
,	O
int	O
version	int
,	O
int	O
rpc_proc	int
,	O
size_t	long
len	long
,	O
void	O
*	O
*	O
bufp	pointer
,	O
uid_t	int
uid	int
,	O
gid_t	int
gid	int
,	O
gid_t	int
second_gid	int
)	O
{	O
void	O
*	O
buf	pointer
;	O
int	O
*	O
p	pointer
,	O
*	O
lenaddr	pointer
;	O
struct	O
rpc_list	struct
*	O
hdr	pointer
;	O
buf	pointer
=	O
malloc	O
(	O
len	long
+	O
1024	int
)	O
;	O
if	O
(	O
!	O
buf	pointer
)	O
{	O
errno	O
=	O
ENOMEM	int
;	O
return	O
NULL	O
;	O
}	O
hdr	pointer
=	O
buf	pointer
;	O
hdr	pointer
->	O
reply	pointer
=	O
0	int
;	O
p	pointer
=	O
buf	pointer
+	O
sizeof	O
(	O
struct	O
rpc_list	struct
)	O
;	O
*	O
(	O
p	pointer
++	O
)	O
=	O
htonl	function
(	O
generate_xid	function
(	O
)	O
)	O
;	O
*	O
(	O
p	pointer
++	O
)	O
=	O
htonl	function
(	O
CALL	O
)	O
;	O
*	O
(	O
p	pointer
++	O
)	O
=	O
htonl	function
(	O
RPC_MSG_VERSION	O
)	O
;	O
*	O
(	O
p	pointer
++	O
)	O
=	O
htonl	function
(	O
program	int
)	O
;	O
*	O
(	O
p	pointer
++	O
)	O
=	O
htonl	function
(	O
version	int
)	O
;	O
*	O
(	O
p	pointer
++	O
)	O
=	O
htonl	function
(	O
rpc_proc	int
)	O
;	O
assert	function
(	O
(	O
uid	int
==	O
-	O
1	int
)	O
==	O
(	O
gid	int
==	O
-	O
1	int
)	O
)	O
;	O
if	O
(	O
uid	int
==	O
-	O
1	int
)	O
{	O
*	O
(	O
p	pointer
++	O
)	O
=	O
htonl	function
(	O
AUTH_NONE	O
)	O
;	O
*	O
(	O
p	pointer
++	O
)	O
=	O
0	int
;	O
}	O
else	O
{	O
*	O
(	O
p	pointer
++	O
)	O
=	O
htonl	function
(	O
AUTH_UNIX	O
)	O
;	O
lenaddr	pointer
=	O
p	pointer
++	O
;	O
*	O
(	O
p	pointer
++	O
)	O
=	O
htonl	function
(	O
mapped_time	pointer
->	O
seconds	O
)	O
;	O
p	pointer
=	O
xdr_encode_string	function
(	O
p	pointer
,	O
hostname	pointer
)	O
;	O
*	O
(	O
p	pointer
++	O
)	O
=	O
htonl	function
(	O
uid	int
)	O
;	O
*	O
(	O
p	pointer
++	O
)	O
=	O
htonl	function
(	O
gid	int
)	O
;	O
if	O
(	O
second_gid	int
==	O
-	O
1	int
)	O
*	O
(	O
p	pointer
++	O
)	O
=	O
0	int
;	O
else	O
{	O
*	O
(	O
p	pointer
++	O
)	O
=	O
htonl	function
(	O
1	int
)	O
;	O
*	O
(	O
p	pointer
++	O
)	O
=	O
htonl	function
(	O
second_gid	int
)	O
;	O
}	O
*	O
lenaddr	pointer
=	O
htonl	function
(	O
(	O
p	pointer
-	O
(	O
lenaddr	pointer
+	O
1	int
)	O
)	O
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
}	O
*	O
(	O
p	pointer
++	O
)	O
=	O
htonl	function
(	O
AUTH_NONE	O
)	O
;	O
*	O
(	O
p	pointer
++	O
)	O
=	O
0	int
;	O
*	O
bufp	pointer
=	O
buf	pointer
;	O
return	O
p	pointer
;	O
}	O
static	O
inline	O
void	O
unlink_rpc	function
(	O
struct	O
rpc_list	struct
*	O
hdr	pointer
)	O
{	O
*	O
hdr	pointer
->	O
prevp	pointer
=	O
hdr	pointer
->	O
next	pointer
;	O
if	O
(	O
hdr	pointer
->	O
next	pointer
)	O
hdr	pointer
->	O
next	pointer
->	O
prevp	pointer
=	O
hdr	pointer
->	O
prevp	pointer
;	O
}	O
static	O
inline	O
void	O
link_rpc	function
(	O
struct	O
rpc_list	struct
*	O
*	O
list	pointer
,	O
struct	O
rpc_list	struct
*	O
hdr	pointer
)	O
{	O
hdr	pointer
->	O
next	pointer
=	O
*	O
list	pointer
;	O
if	O
(	O
hdr	pointer
->	O
next	pointer
)	O
hdr	pointer
->	O
next	pointer
->	O
prevp	pointer
=	O
&	O
hdr	pointer
->	O
next	pointer
;	O
hdr	pointer
->	O
prevp	pointer
=	O
list	pointer
;	O
*	O
list	pointer
=	O
hdr	pointer
;	O
}	O
error_t	int
conduct_rpc	function
(	O
void	O
*	O
*	O
rpcbuf	pointer
,	O
int	O
*	O
*	O
pp	pointer
)	O
{	O
struct	O
rpc_list	struct
*	O
hdr	pointer
=	O
*	O
rpcbuf	pointer
;	O
error_t	int
err	int
;	O
size_t	long
cc	long
,	O
nc	long
;	O
int	O
timeout	int
=	O
initial_transmit_timeout	int
;	O
time_t	long
lasttrans	long
;	O
int	O
ntransmit	int
=	O
0	int
;	O
int	O
*	O
p	pointer
;	O
int	O
xid	int
;	O
int	O
n	int
;	O
int	O
cancel	int
;	O
pthread_mutex_lock	function
(	O
&	O
outstanding_lock	union
)	O
;	O
link_rpc	function
(	O
&	O
outstanding_rpcs	pointer
,	O
hdr	pointer
)	O
;	O
xid	int
=	O
*	O
(	O
int	O
*	O
)	O
(	O
*	O
rpcbuf	pointer
+	O
sizeof	O
(	O
struct	O
rpc_list	struct
)	O
)	O
;	O
do	O
{	O
if	O
(	O
mounted_soft	int
&&	O
ntransmit	int
==	O
soft_retries	int
)	O
{	O
unlink_rpc	function
(	O
hdr	pointer
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
outstanding_lock	union
)	O
;	O
return	O
ETIMEDOUT	int
;	O
}	O
lasttrans	long
=	O
mapped_time	pointer
->	O
seconds	O
;	O
ntransmit	int
++	O
;	O
nc	long
=	O
(	O
void	O
*	O
)	O
*	O
pp	pointer
-	O
*	O
rpcbuf	pointer
-	O
sizeof	O
(	O
struct	O
rpc_list	struct
)	O
;	O
cc	long
=	O
write	function
(	O
main_udp_socket	int
,	O
*	O
rpcbuf	pointer
+	O
sizeof	O
(	O
struct	O
rpc_list	struct
)	O
,	O
nc	long
)	O
;	O
if	O
(	O
cc	long
==	O
-	O
1	int
)	O
{	O
unlink_rpc	function
(	O
hdr	pointer
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
outstanding_lock	union
)	O
;	O
return	O
errno	O
;	O
}	O
else	O
assert	function
(	O
cc	long
==	O
nc	long
)	O
;	O
cancel	int
=	O
0	int
;	O
while	O
(	O
!	O
hdr	pointer
->	O
reply	pointer
&&	O
(	O
mapped_time	pointer
->	O
seconds	O
-	O
lasttrans	long
<	O
timeout	int
)	O
&&	O
!	O
cancel	int
)	O
cancel	int
=	O
pthread_hurd_cond_wait_np	function
(	O
&	O
rpc_wakeup	union
,	O
&	O
outstanding_lock	union
)	O
;	O
if	O
(	O
cancel	int
)	O
{	O
unlink_rpc	function
(	O
hdr	pointer
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
outstanding_lock	union
)	O
;	O
return	O
EINTR	int
;	O
}	O
if	O
(	O
!	O
hdr	pointer
->	O
reply	pointer
)	O
{	O
timeout	int
*=	O
2	int
;	O
if	O
(	O
timeout	int
>	O
max_transmit_timeout	int
)	O
timeout	int
=	O
max_transmit_timeout	int
;	O
}	O
}	O
while	O
(	O
!	O
hdr	pointer
->	O
reply	pointer
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
outstanding_lock	union
)	O
;	O
*	O
rpcbuf	pointer
=	O
hdr	pointer
->	O
reply	pointer
;	O
free	function
(	O
hdr	pointer
)	O
;	O
p	pointer
=	O
(	O
int	O
*	O
)	O
*	O
rpcbuf	pointer
;	O
assert	function
(	O
*	O
p	pointer
==	O
xid	int
)	O
;	O
p	pointer
++	O
;	O
switch	O
(	O
ntohl	function
(	O
*	O
p	pointer
)	O
)	O
{	O
default	O
:	O
err	int
=	O
EBADRPC	O
;	O
break	O
;	O
case	O
REPLY	O
:	O
p	pointer
++	O
;	O
switch	O
(	O
ntohl	function
(	O
*	O
p	pointer
)	O
)	O
{	O
default	O
:	O
err	int
=	O
EBADRPC	O
;	O
break	O
;	O
case	O
MSG_DENIED	O
:	O
p	pointer
++	O
;	O
switch	O
(	O
ntohl	function
(	O
*	O
p	pointer
)	O
)	O
{	O
default	O
:	O
err	int
=	O
EBADRPC	O
;	O
break	O
;	O
case	O
RPC_MISMATCH	O
:	O
err	int
=	O
ERPCMISMATCH	O
;	O
break	O
;	O
case	O
AUTH_ERROR	O
:	O
p	pointer
++	O
;	O
switch	O
(	O
ntohl	function
(	O
*	O
p	pointer
)	O
)	O
{	O
case	O
AUTH_BADCRED	O
:	O
case	O
AUTH_REJECTEDCRED	O
:	O
err	int
=	O
EAUTH	O
;	O
break	O
;	O
case	O
AUTH_TOOWEAK	O
:	O
err	int
=	O
ENEEDAUTH	O
;	O
break	O
;	O
case	O
AUTH_BADVERF	O
:	O
case	O
AUTH_REJECTEDVERF	O
:	O
default	O
:	O
err	int
=	O
EBADRPC	O
;	O
break	O
;	O
}	O
break	O
;	O
}	O
break	O
;	O
case	O
MSG_ACCEPTED	O
:	O
p	pointer
++	O
;	O
p	pointer
++	O
;	O
n	int
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
p	pointer
+=	O
INTSIZE	O
(	O
n	int
)	O
;	O
switch	O
(	O
ntohl	function
(	O
*	O
p	pointer
)	O
)	O
{	O
default	O
:	O
case	O
GARBAGE_ARGS	O
:	O
err	int
=	O
EBADRPC	O
;	O
break	O
;	O
case	O
PROG_UNAVAIL	O
:	O
err	int
=	O
EPROGUNAVAIL	O
;	O
break	O
;	O
case	O
PROG_MISMATCH	O
:	O
err	int
=	O
EPROGMISMATCH	O
;	O
break	O
;	O
case	O
PROC_UNAVAIL	O
:	O
err	int
=	O
EPROCUNAVAIL	O
;	O
break	O
;	O
case	O
SUCCESS	O
:	O
p	pointer
++	O
;	O
*	O
pp	pointer
=	O
p	pointer
;	O
err	int
=	O
0	int
;	O
break	O
;	O
}	O
break	O
;	O
}	O
break	O
;	O
}	O
return	O
err	int
;	O
}	O
void	O
*	O
timeout_service_thread	function
(	O
void	O
*	O
arg	pointer
)	O
{	O
(	O
void	O
)	O
arg	pointer
;	O
while	O
(	O
1	int
)	O
{	O
sleep	function
(	O
1	int
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
outstanding_lock	union
)	O
;	O
pthread_cond_broadcast	function
(	O
&	O
rpc_wakeup	union
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
outstanding_lock	union
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
void	O
*	O
rpc_receive_thread	function
(	O
void	O
*	O
arg	pointer
)	O
{	O
void	O
*	O
buf	pointer
;	O
(	O
void	O
)	O
arg	pointer
;	O
buf	pointer
=	O
malloc	O
(	O
1024	int
+	O
read_size	int
)	O
;	O
assert	function
(	O
buf	pointer
)	O
;	O
while	O
(	O
1	int
)	O
{	O
int	O
cc	long
=	O
read	function
(	O
main_udp_socket	int
,	O
buf	pointer
,	O
1024	int
+	O
read_size	int
)	O
;	O
if	O
(	O
cc	long
==	O
-	O
1	int
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
"nfs read"	pointer
)	O
;	O
continue	O
;	O
}	O
else	O
{	O
struct	O
rpc_list	struct
*	O
r	pointer
;	O
int	O
xid	int
=	O
*	O
(	O
int	O
*	O
)	O
buf	pointer
;	O
pthread_mutex_lock	function
(	O
&	O
outstanding_lock	union
)	O
;	O
for	O
(	O
r	pointer
=	O
outstanding_rpcs	pointer
;	O
r	pointer
;	O
r	pointer
=	O
r	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
*	O
(	O
int	O
*	O
)	O
&	O
r	pointer
[	O
1	int
]	O
==	O
xid	int
)	O
{	O
unlink_rpc	function
(	O
r	pointer
)	O
;	O
r	pointer
->	O
reply	pointer
=	O
buf	pointer
;	O
pthread_cond_broadcast	function
(	O
&	O
rpc_wakeup	union
)	O
;	O
break	O
;	O
}	O
}	O
pthread_mutex_unlock	function
(	O
&	O
outstanding_lock	union
)	O
;	O
if	O
(	O
r	pointer
)	O
{	O
buf	pointer
=	O
malloc	O
(	O
1024	int
+	O
read_size	int
)	O
;	O
assert	function
(	O
buf	pointer
)	O
;	O
}	O
}	O
}	O
return	O
NULL	O
;	O
}	O
