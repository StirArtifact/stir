static	O
avail_elem	struct
get_elem	function
(	O
int	O
,	O
avail_elem	struct
[	O
]	O
,	O
int	O
*	O
)	O
;	O
static	O
avail_elem	struct
get_block	function
(	O
int	O
,	O
GDBM_FILE	pointer
)	O
;	O
static	O
int	O
push_avail_block	function
(	O
GDBM_FILE	pointer
)	O
;	O
static	O
int	O
pop_avail_block	function
(	O
GDBM_FILE	pointer
)	O
;	O
static	O
int	O
adjust_bucket_avail	function
(	O
GDBM_FILE	pointer
)	O
;	O
off_t	long
_gdbm_alloc	function
(	O
GDBM_FILE	pointer
dbf	pointer
,	O
int	O
num_bytes	int
)	O
{	O
off_t	long
file_adr	long
;	O
avail_elem	struct
av_el	struct
;	O
av_el	struct
=	O
get_elem	function
(	O
num_bytes	int
,	O
dbf	pointer
->	O
bucket	pointer
->	O
bucket_avail	array
,	O
&	O
dbf	pointer
->	O
bucket	pointer
->	O
av_count	int
)	O
;	O
if	O
(	O
av_el	struct
.	O
av_size	int
==	O
0	int
)	O
{	O
if	O
(	O
(	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
count	int
<=	O
(	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
size	int
>>	O
1	int
)	O
)	O
&&	O
(	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
next_block	long
!=	O
0	int
)	O
)	O
if	O
(	O
pop_avail_block	function
(	O
dbf	pointer
)	O
)	O
return	O
0	int
;	O
av_el	struct
=	O
get_elem	function
(	O
num_bytes	int
,	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
av_table	array
,	O
&	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
count	int
)	O
;	O
if	O
(	O
av_el	struct
.	O
av_size	int
==	O
0	int
)	O
av_el	struct
=	O
get_block	function
(	O
num_bytes	int
,	O
dbf	pointer
)	O
;	O
dbf	pointer
->	O
header_changed	int
=	O
TRUE	int
;	O
}	O
file_adr	long
=	O
av_el	struct
.	O
av_adr	long
;	O
av_el	struct
.	O
av_adr	long
+=	O
num_bytes	int
;	O
av_el	struct
.	O
av_size	int
-=	O
num_bytes	int
;	O
if	O
(	O
_gdbm_free	function
(	O
dbf	pointer
,	O
av_el	struct
.	O
av_adr	long
,	O
av_el	struct
.	O
av_size	int
)	O
)	O
return	O
0	int
;	O
return	O
file_adr	long
;	O
}	O
int	O
_gdbm_free	function
(	O
GDBM_FILE	pointer
dbf	pointer
,	O
off_t	long
file_adr	long
,	O
int	O
num_bytes	int
)	O
{	O
avail_elem	struct
temp	struct
;	O
if	O
(	O
num_bytes	int
<=	O
IGNORE_SIZE	int
)	O
return	O
0	int
;	O
temp	struct
.	O
av_size	int
=	O
num_bytes	int
;	O
temp	struct
.	O
av_adr	long
=	O
file_adr	long
;	O
if	O
(	O
(	O
num_bytes	int
>=	O
dbf	pointer
->	O
header	pointer
->	O
block_size	int
)	O
||	O
dbf	pointer
->	O
central_free	int
)	O
{	O
if	O
(	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
count	int
==	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
size	int
)	O
{	O
if	O
(	O
push_avail_block	function
(	O
dbf	pointer
)	O
)	O
return	O
-	O
1	int
;	O
}	O
_gdbm_put_av_elem	function
(	O
temp	struct
,	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
av_table	array
,	O
&	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
count	int
,	O
dbf	pointer
->	O
coalesce_blocks	int
)	O
;	O
dbf	pointer
->	O
header_changed	int
=	O
TRUE	int
;	O
}	O
else	O
{	O
if	O
(	O
dbf	pointer
->	O
bucket	pointer
->	O
av_count	int
<	O
BUCKET_AVAIL	int
)	O
_gdbm_put_av_elem	function
(	O
temp	struct
,	O
dbf	pointer
->	O
bucket	pointer
->	O
bucket_avail	array
,	O
&	O
dbf	pointer
->	O
bucket	pointer
->	O
av_count	int
,	O
dbf	pointer
->	O
coalesce_blocks	int
)	O
;	O
else	O
{	O
if	O
(	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
count	int
==	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
size	int
)	O
{	O
if	O
(	O
push_avail_block	function
(	O
dbf	pointer
)	O
)	O
return	O
-	O
1	int
;	O
}	O
_gdbm_put_av_elem	function
(	O
temp	struct
,	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
av_table	array
,	O
&	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
count	int
,	O
dbf	pointer
->	O
coalesce_blocks	int
)	O
;	O
dbf	pointer
->	O
header_changed	int
=	O
TRUE	int
;	O
}	O
}	O
if	O
(	O
dbf	pointer
->	O
header_changed	int
&&	O
adjust_bucket_avail	function
(	O
dbf	pointer
)	O
)	O
return	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
pop_avail_block	function
(	O
GDBM_FILE	pointer
dbf	pointer
)	O
{	O
int	O
rc	int
;	O
off_t	long
file_pos	long
;	O
avail_elem	struct
new_el	struct
;	O
avail_block	struct
*	O
new_blk	pointer
;	O
int	O
index	function
;	O
if	O
(	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
count	int
==	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
size	int
)	O
{	O
if	O
(	O
push_avail_block	function
(	O
dbf	pointer
)	O
)	O
return	O
-	O
1	int
;	O
}	O
new_el	struct
.	O
av_adr	long
=	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
next_block	long
;	O
new_el	struct
.	O
av_size	int
=	O
(	O
(	O
(	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
size	int
*	O
sizeof	O
(	O
avail_elem	struct
)	O
)	O
>>	O
1	int
)	O
+	O
sizeof	O
(	O
avail_block	struct
)	O
)	O
;	O
new_blk	pointer
=	O
malloc	function
(	O
new_el	struct
.	O
av_size	int
)	O
;	O
if	O
(	O
new_blk	pointer
==	O
NULL	O
)	O
{	O
GDBM_SET_ERRNO	O
(	O
dbf	pointer
,	O
GDBM_MALLOC_ERROR	int
,	O
TRUE	int
)	O
;	O
_gdbm_fatal	function
(	O
dbf	pointer
,	O
_	O
(	O
"malloc failed"	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
file_pos	long
=	O
gdbm_file_seek	function
(	O
dbf	pointer
,	O
new_el	struct
.	O
av_adr	long
,	O
SEEK_SET	int
)	O
;	O
if	O
(	O
file_pos	long
!=	O
new_el	struct
.	O
av_adr	long
)	O
{	O
GDBM_SET_ERRNO	O
(	O
dbf	pointer
,	O
GDBM_FILE_SEEK_ERROR	int
,	O
TRUE	int
)	O
;	O
free	function
(	O
new_blk	pointer
)	O
;	O
_gdbm_fatal	function
(	O
dbf	pointer
,	O
_	O
(	O
"lseek error"	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
rc	int
=	O
_gdbm_full_read	function
(	O
dbf	pointer
,	O
new_blk	pointer
,	O
new_el	struct
.	O
av_size	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
free	function
(	O
new_blk	pointer
)	O
;	O
_gdbm_fatal	function
(	O
dbf	pointer
,	O
gdbm_db_strerror	function
(	O
dbf	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
gdbm_avail_block_validate	function
(	O
dbf	pointer
,	O
new_blk	pointer
)	O
)	O
{	O
free	function
(	O
new_blk	pointer
)	O
;	O
_gdbm_fatal	function
(	O
dbf	pointer
,	O
gdbm_db_strerror	function
(	O
dbf	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
index	function
=	O
0	int
;	O
while	O
(	O
index	function
<	O
new_blk	pointer
->	O
count	int
)	O
{	O
while	O
(	O
index	function
<	O
new_blk	pointer
->	O
count	int
&&	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
count	int
<	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
size	int
)	O
{	O
_gdbm_put_av_elem	function
(	O
new_blk	pointer
->	O
av_table	array
[	O
index	function
]	O
,	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
av_table	array
,	O
&	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
count	int
,	O
TRUE	int
)	O
;	O
index	function
++	O
;	O
}	O
if	O
(	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
count	int
==	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
size	int
)	O
{	O
if	O
(	O
push_avail_block	function
(	O
dbf	pointer
)	O
)	O
{	O
free	function
(	O
new_blk	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
}	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
next_block	long
=	O
new_blk	pointer
->	O
next_block	long
;	O
dbf	pointer
->	O
header_changed	int
=	O
TRUE	int
;	O
if	O
(	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
count	int
==	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
size	int
)	O
{	O
if	O
(	O
push_avail_block	function
(	O
dbf	pointer
)	O
)	O
{	O
free	function
(	O
new_blk	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
_gdbm_put_av_elem	function
(	O
new_el	struct
,	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
av_table	array
,	O
&	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
count	int
,	O
TRUE	int
)	O
;	O
free	function
(	O
new_blk	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
push_avail_block	function
(	O
GDBM_FILE	pointer
dbf	pointer
)	O
{	O
int	O
av_size	int
;	O
off_t	long
av_adr	long
;	O
int	O
index	function
;	O
off_t	long
file_pos	long
;	O
avail_block	struct
*	O
temp	struct
;	O
avail_elem	struct
new_loc	struct
;	O
int	O
rc	int
;	O
av_size	int
=	O
(	O
(	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
size	int
*	O
sizeof	O
(	O
avail_elem	struct
)	O
)	O
>>	O
1	int
)	O
+	O
sizeof	O
(	O
avail_block	struct
)	O
;	O
new_loc	struct
=	O
get_elem	function
(	O
av_size	int
,	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
av_table	array
,	O
&	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
count	int
)	O
;	O
if	O
(	O
new_loc	struct
.	O
av_size	int
==	O
0	int
)	O
new_loc	struct
=	O
get_block	function
(	O
av_size	int
,	O
dbf	pointer
)	O
;	O
av_adr	long
=	O
new_loc	struct
.	O
av_adr	long
;	O
temp	struct
=	O
calloc	function
(	O
1	int
,	O
av_size	int
)	O
;	O
if	O
(	O
temp	struct
==	O
NULL	O
)	O
{	O
GDBM_SET_ERRNO	O
(	O
dbf	pointer
,	O
GDBM_MALLOC_ERROR	int
,	O
TRUE	int
)	O
;	O
_gdbm_fatal	function
(	O
dbf	pointer
,	O
_	O
(	O
"malloc error"	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
temp	struct
->	O
size	int
=	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
size	int
;	O
temp	struct
->	O
count	int
=	O
0	int
;	O
temp	struct
->	O
next_block	long
=	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
next_block	long
;	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
next_block	long
=	O
av_adr	long
;	O
for	O
(	O
index	function
=	O
1	int
;	O
index	function
<	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
count	int
;	O
index	function
++	O
)	O
if	O
(	O
(	O
index	function
&	O
0x1	int
)	O
==	O
1	int
)	O
temp	struct
->	O
av_table	array
[	O
temp	struct
->	O
count	int
++	O
]	O
=	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
av_table	array
[	O
index	function
]	O
;	O
else	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
av_table	array
[	O
index	function
>>	O
1	int
]	O
=	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
av_table	array
[	O
index	function
]	O
;	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
count	int
>>=	O
1	int
;	O
rc	int
=	O
0	int
;	O
do	O
{	O
new_loc	struct
.	O
av_adr	long
+=	O
av_size	int
;	O
new_loc	struct
.	O
av_size	int
-=	O
av_size	int
;	O
if	O
(	O
_gdbm_free	function
(	O
dbf	pointer
,	O
new_loc	struct
.	O
av_adr	long
,	O
new_loc	struct
.	O
av_size	int
)	O
)	O
{	O
rc	int
=	O
-	O
1	int
;	O
break	O
;	O
}	O
file_pos	long
=	O
gdbm_file_seek	function
(	O
dbf	pointer
,	O
av_adr	long
,	O
SEEK_SET	int
)	O
;	O
if	O
(	O
file_pos	long
!=	O
av_adr	long
)	O
{	O
GDBM_SET_ERRNO	O
(	O
dbf	pointer
,	O
GDBM_FILE_SEEK_ERROR	int
,	O
TRUE	int
)	O
;	O
_gdbm_fatal	function
(	O
dbf	pointer
,	O
_	O
(	O
"lseek error"	pointer
)	O
)	O
;	O
rc	int
=	O
-	O
1	int
;	O
break	O
;	O
}	O
rc	int
=	O
_gdbm_full_write	function
(	O
dbf	pointer
,	O
temp	struct
,	O
av_size	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
GDBM_DEBUG	O
(	O
GDBM_DEBUG_STORE	O
|	O
GDBM_DEBUG_ERR	O
,	O
"%s: error writing avail data: %s"	pointer
,	O
dbf	pointer
->	O
name	pointer
,	O
gdbm_db_strerror	function
(	O
dbf	pointer
)	O
)	O
;	O
_gdbm_fatal	function
(	O
dbf	pointer
,	O
gdbm_db_strerror	function
(	O
dbf	pointer
)	O
)	O
;	O
rc	int
=	O
-	O
1	int
;	O
}	O
}	O
while	O
(	O
0	int
)	O
;	O
free	function
(	O
temp	struct
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
avail_lookup	function
(	O
int	O
size	int
,	O
avail_elem	struct
*	O
av_table	array
,	O
int	O
count	int
)	O
{	O
int	O
start	int
=	O
0	int
;	O
while	O
(	O
count	int
>	O
0	int
)	O
{	O
int	O
pivot	int
=	O
start	int
+	O
(	O
count	int
>>	O
1	int
)	O
;	O
if	O
(	O
size	int
==	O
av_table	array
[	O
pivot	int
]	O
.	O
av_size	int
)	O
return	O
pivot	int
;	O
if	O
(	O
size	int
>	O
av_table	array
[	O
pivot	int
]	O
.	O
av_size	int
)	O
{	O
start	int
=	O
pivot	int
+	O
1	int
;	O
count	int
--	O
;	O
}	O
count	int
>>=	O
1	int
;	O
}	O
return	O
start	int
;	O
}	O
static	O
inline	O
void	O
avail_move	function
(	O
avail_elem	struct
*	O
av_table	array
,	O
int	O
*	O
av_count	int
,	O
int	O
src	pointer
,	O
int	O
dst	pointer
)	O
{	O
memmove	function
(	O
av_table	array
+	O
dst	pointer
,	O
av_table	array
+	O
src	pointer
,	O
(	O
*	O
av_count	int
-	O
src	pointer
)	O
*	O
sizeof	O
av_table	array
[	O
0	int
]	O
)	O
;	O
*	O
av_count	int
+=	O
dst	pointer
-	O
src	pointer
;	O
}	O
static	O
avail_elem	struct
get_elem	function
(	O
int	O
size	int
,	O
avail_elem	struct
av_table	array
[	O
]	O
,	O
int	O
*	O
av_count	int
)	O
{	O
int	O
index	function
;	O
avail_elem	struct
val	struct
;	O
val	struct
.	O
av_adr	long
=	O
0	int
;	O
val	struct
.	O
av_size	int
=	O
0	int
;	O
index	function
=	O
avail_lookup	function
(	O
size	int
,	O
av_table	array
,	O
*	O
av_count	int
)	O
;	O
if	O
(	O
index	function
>=	O
*	O
av_count	int
)	O
return	O
val	struct
;	O
val	struct
=	O
av_table	array
[	O
index	function
]	O
;	O
avail_move	function
(	O
av_table	array
,	O
av_count	int
,	O
index	function
+	O
1	int
,	O
index	function
)	O
;	O
return	O
val	struct
;	O
}	O
void	O
_gdbm_put_av_elem	function
(	O
avail_elem	struct
new_el	struct
,	O
avail_elem	struct
av_table	array
[	O
]	O
,	O
int	O
*	O
av_count	int
,	O
int	O
can_merge	int
)	O
{	O
int	O
index	function
;	O
if	O
(	O
new_el	struct
.	O
av_size	int
<=	O
IGNORE_SIZE	int
)	O
return	O
;	O
if	O
(	O
can_merge	int
==	O
TRUE	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
*	O
av_count	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
av_table	array
[	O
i	int
]	O
.	O
av_adr	long
+	O
av_table	array
[	O
i	int
]	O
.	O
av_size	int
)	O
==	O
new_el	struct
.	O
av_adr	long
)	O
{	O
new_el	struct
.	O
av_size	int
+=	O
av_table	array
[	O
i	int
]	O
.	O
av_size	int
;	O
new_el	struct
.	O
av_adr	long
=	O
av_table	array
[	O
i	int
]	O
.	O
av_adr	long
;	O
avail_move	function
(	O
av_table	array
,	O
av_count	int
,	O
i	int
+	O
1	int
,	O
i	int
)	O
;	O
--	O
i	int
;	O
}	O
if	O
(	O
(	O
new_el	struct
.	O
av_adr	long
+	O
new_el	struct
.	O
av_size	int
)	O
==	O
av_table	array
[	O
i	int
]	O
.	O
av_adr	long
)	O
{	O
new_el	struct
.	O
av_size	int
+=	O
av_table	array
[	O
i	int
]	O
.	O
av_size	int
;	O
avail_move	function
(	O
av_table	array
,	O
av_count	int
,	O
i	int
+	O
1	int
,	O
i	int
)	O
;	O
--	O
i	int
;	O
}	O
}	O
}	O
index	function
=	O
avail_lookup	function
(	O
new_el	struct
.	O
av_size	int
,	O
av_table	array
,	O
*	O
av_count	int
)	O
;	O
avail_move	function
(	O
av_table	array
,	O
av_count	int
,	O
index	function
,	O
index	function
+	O
1	int
)	O
;	O
av_table	array
[	O
index	function
]	O
=	O
new_el	struct
;	O
}	O
static	O
avail_elem	struct
get_block	function
(	O
int	O
size	int
,	O
GDBM_FILE	pointer
dbf	pointer
)	O
{	O
avail_elem	struct
val	struct
;	O
val	struct
.	O
av_adr	long
=	O
dbf	pointer
->	O
header	pointer
->	O
next_block	long
;	O
val	struct
.	O
av_size	int
=	O
dbf	pointer
->	O
header	pointer
->	O
block_size	int
;	O
while	O
(	O
val	struct
.	O
av_size	int
<	O
size	int
)	O
val	struct
.	O
av_size	int
+=	O
dbf	pointer
->	O
header	pointer
->	O
block_size	int
;	O
dbf	pointer
->	O
header	pointer
->	O
next_block	long
+=	O
val	struct
.	O
av_size	int
;	O
dbf	pointer
->	O
header_changed	int
=	O
TRUE	int
;	O
return	O
val	struct
;	O
}	O
static	O
int	O
adjust_bucket_avail	function
(	O
GDBM_FILE	pointer
dbf	pointer
)	O
{	O
int	O
third	int
=	O
BUCKET_AVAIL	int
/	O
3	int
;	O
avail_elem	struct
av_el	struct
;	O
if	O
(	O
dbf	pointer
->	O
bucket	pointer
->	O
av_count	int
<	O
third	int
)	O
{	O
if	O
(	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
count	int
>	O
0	int
)	O
{	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
count	int
-=	O
1	int
;	O
av_el	struct
=	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
av_table	array
[	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
count	int
]	O
;	O
_gdbm_put_av_elem	function
(	O
av_el	struct
,	O
dbf	pointer
->	O
bucket	pointer
->	O
bucket_avail	array
,	O
&	O
dbf	pointer
->	O
bucket	pointer
->	O
av_count	int
,	O
dbf	pointer
->	O
coalesce_blocks	int
)	O
;	O
dbf	pointer
->	O
bucket_changed	int
=	O
TRUE	int
;	O
}	O
return	O
0	int
;	O
}	O
while	O
(	O
dbf	pointer
->	O
bucket	pointer
->	O
av_count	int
>	O
BUCKET_AVAIL	int
-	O
third	int
&&	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
count	int
<	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
size	int
)	O
{	O
av_el	struct
=	O
get_elem	function
(	O
0	int
,	O
dbf	pointer
->	O
bucket	pointer
->	O
bucket_avail	array
,	O
&	O
dbf	pointer
->	O
bucket	pointer
->	O
av_count	int
)	O
;	O
if	O
(	O
av_el	struct
.	O
av_size	int
==	O
0	int
)	O
{	O
GDBM_SET_ERRNO	O
(	O
dbf	pointer
,	O
GDBM_BAD_AVAIL	int
,	O
TRUE	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
_gdbm_put_av_elem	function
(	O
av_el	struct
,	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
av_table	array
,	O
&	O
dbf	pointer
->	O
header	pointer
->	O
avail	struct
.	O
count	int
,	O
dbf	pointer
->	O
coalesce_blocks	int
)	O
;	O
dbf	pointer
->	O
bucket_changed	int
=	O
TRUE	int
;	O
}	O
return	O
0	int
;	O
}	O
