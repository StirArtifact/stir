static	O
error_t	O
lookup_user	function
(	O
struct	O
usermux	struct
*	O
mux	pointer
,	O
const	O
char	O
*	O
user	pointer
,	O
struct	O
node	pointer
*	O
*	O
node	pointer
)	O
;	O
error_t	O
netfs_attempt_lookup	function
(	O
struct	O
iouser	O
*	O
user	pointer
,	O
struct	O
node	pointer
*	O
dir	pointer
,	O
char	O
*	O
name	pointer
,	O
struct	O
node	pointer
*	O
*	O
node	pointer
)	O
{	O
error_t	O
err	O
;	O
if	O
(	O
dir	pointer
->	O
nn	O
->	O
name	pointer
)	O
err	O
=	O
ENOTDIR	O
;	O
else	O
err	O
=	O
lookup_user	function
(	O
dir	pointer
->	O
nn	O
->	O
mux	pointer
,	O
name	pointer
,	O
node	pointer
)	O
;	O
fshelp_touch	function
(	O
&	O
dir	pointer
->	O
nn_stat	O
,	O
TOUCH_ATIME	O
,	O
usermux_maptime	pointer
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
if	O
(	O
!	O
err	O
)	O
pthread_mutex_lock	function
(	O
&	O
(	O
*	O
node	pointer
)	O
->	O
lock	O
)	O
;	O
return	O
err	O
;	O
}	O
static	O
error_t	O
get_dirents	function
(	O
struct	O
node	pointer
*	O
dir	pointer
,	O
int	O
first_entry	int
,	O
int	O
max_entries	int
,	O
char	O
*	O
*	O
data	pointer
,	O
mach_msg_type_number_t	O
*	O
data_len	pointer
,	O
vm_size_t	O
max_data_len	int
,	O
int	O
*	O
data_entries	pointer
)	O
{	O
error_t	O
err	O
=	O
0	int
;	O
if	O
(	O
dir	pointer
->	O
nn	O
->	O
name	pointer
)	O
return	O
ENOTDIR	O
;	O
setpwent	function
(	O
)	O
;	O
while	O
(	O
first_entry	int
--	O
>	O
0	int
)	O
if	O
(	O
!	O
getpwent	function
(	O
)	O
)	O
{	O
max_entries	int
=	O
0	int
;	O
break	O
;	O
}	O
if	O
(	O
max_entries	int
!=	O
0	int
)	O
{	O
size_t	long
size	long
=	O
(	O
max_data_len	int
==	O
0	int
?	O
DIRENTS_CHUNK_SIZE	O
:	O
max_data_len	int
)	O
;	O
*	O
data	pointer
=	O
mmap	function
(	O
0	int
,	O
size	long
,	O
PROT_READ	int
|	O
PROT_WRITE	int
,	O
MAP_ANON	O
,	O
0	int
,	O
0	int
)	O
;	O
err	O
=	O
(	O
data	pointer
!=	O
(	O
void	O
*	O
)	O
-	O
1	int
)	O
?	O
errno	O
:	O
0	int
;	O
if	O
(	O
!	O
err	O
)	O
{	O
struct	O
passwd	struct
*	O
pw	pointer
;	O
char	O
*	O
p	pointer
=	O
*	O
data	pointer
;	O
int	O
count	int
=	O
0	int
;	O
int	O
entry_type	int
=	O
(	O
S_ISLNK	function
(	O
dir	pointer
->	O
nn	O
->	O
mux	pointer
->	O
stat_template	struct
.	O
st_mode	O
)	O
?	O
DT_LNK	int
:	O
DT_REG	int
)	O
;	O
while	O
(	O
(	O
max_entries	int
==	O
-	O
1	int
||	O
count	int
<	O
max_entries	int
)	O
&&	O
(	O
pw	pointer
=	O
getpwent	function
(	O
)	O
)	O
)	O
{	O
struct	O
dirent	struct
hdr	struct
;	O
size_t	long
name_len	long
=	O
strlen	function
(	O
pw	pointer
->	O
pw_name	pointer
)	O
;	O
size_t	long
sz	long
=	O
DIRENT_LEN	O
(	O
name_len	long
)	O
;	O
if	O
(	O
(	O
p	pointer
-	O
*	O
data	pointer
)	O
+	O
sz	long
>	O
size	long
)	O
{	O
if	O
(	O
max_data_len	int
>	O
0	int
)	O
break	O
;	O
else	O
{	O
vm_address_t	O
extension	O
=	O
(	O
vm_address_t	O
)	O
(	O
*	O
data	pointer
+	O
size	long
)	O
;	O
err	O
=	O
vm_allocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
&	O
extension	O
,	O
DIRENTS_CHUNK_SIZE	O
,	O
0	int
)	O
;	O
if	O
(	O
err	O
)	O
break	O
;	O
size	long
+=	O
DIRENTS_CHUNK_SIZE	O
;	O
}	O
}	O
hdr	struct
.	O
d_namlen	O
=	O
name_len	long
;	O
hdr	struct
.	O
d_fileno	O
=	O
pw	pointer
->	O
pw_uid	int
+	O
USERMUX_FILENO_UID_OFFSET	int
;	O
hdr	struct
.	O
d_reclen	short
=	O
sz	long
;	O
hdr	struct
.	O
d_type	char
=	O
entry_type	int
;	O
memcpy	function
(	O
p	pointer
,	O
&	O
hdr	struct
,	O
DIRENT_NAME_OFFS	O
)	O
;	O
strcpy	function
(	O
p	pointer
+	O
DIRENT_NAME_OFFS	O
,	O
pw	pointer
->	O
pw_name	pointer
)	O
;	O
p	pointer
+=	O
sz	long
;	O
count	int
++	O
;	O
}	O
if	O
(	O
err	O
)	O
munmap	function
(	O
*	O
data	pointer
,	O
size	long
)	O
;	O
else	O
{	O
vm_address_t	O
alloc_end	O
=	O
(	O
vm_address_t	O
)	O
(	O
*	O
data	pointer
+	O
size	long
)	O
;	O
vm_address_t	O
real_end	O
=	O
round_page	O
(	O
p	pointer
)	O
;	O
if	O
(	O
alloc_end	O
>	O
real_end	O
)	O
munmap	function
(	O
(	O
caddr_t	O
)	O
real_end	O
,	O
alloc_end	O
-	O
real_end	O
)	O
;	O
*	O
data_len	pointer
=	O
p	pointer
-	O
*	O
data	pointer
;	O
*	O
data_entries	pointer
=	O
count	int
;	O
}	O
}	O
}	O
endpwent	function
(	O
)	O
;	O
return	O
err	O
;	O
}	O
error_t	O
netfs_get_dirents	function
(	O
struct	O
iouser	O
*	O
cred	pointer
,	O
struct	O
node	pointer
*	O
dir	pointer
,	O
int	O
first_entry	int
,	O
int	O
max_entries	int
,	O
char	O
*	O
*	O
data	pointer
,	O
mach_msg_type_number_t	O
*	O
data_len	pointer
,	O
vm_size_t	O
max_data_len	int
,	O
int	O
*	O
data_entries	pointer
)	O
{	O
error_t	O
err	O
;	O
static	O
time_t	long
cache_timestamp	long
=	O
0	int
;	O
static	O
pthread_rwlock_t	union
cache_lock	union
=	O
PTHREAD_RWLOCK_INITIALIZER	O
;	O
static	O
char	O
*	O
cached_data	pointer
=	O
0	int
;	O
static	O
mach_msg_type_number_t	O
cached_data_len	int
=	O
0	int
;	O
static	O
int	O
cached_data_entries	int
=	O
0	int
;	O
struct	O
timeval	struct
tv	struct
;	O
char	O
*	O
first	pointer
;	O
size_t	long
bytes_left	long
,	O
entries_left	long
;	O
maptime_read	function
(	O
usermux_maptime	pointer
,	O
&	O
tv	struct
)	O
;	O
if	O
(	O
tv	struct
.	O
tv_sec	long
>	O
cache_timestamp	long
+	O
DIRENTS_CACHE_TIME	int
)	O
{	O
pthread_rwlock_wrlock	function
(	O
&	O
cache_lock	union
)	O
;	O
if	O
(	O
cached_data_len	int
>	O
0	int
)	O
{	O
munmap	function
(	O
cached_data	pointer
,	O
cached_data_len	int
)	O
;	O
cached_data	pointer
=	O
0	int
;	O
cached_data_len	int
=	O
0	int
;	O
}	O
err	O
=	O
get_dirents	function
(	O
dir	pointer
,	O
0	int
,	O
-	O
1	int
,	O
&	O
cached_data	pointer
,	O
&	O
cached_data_len	int
,	O
0	int
,	O
&	O
cached_data_entries	int
)	O
;	O
if	O
(	O
!	O
err	O
)	O
cache_timestamp	long
=	O
tv	struct
.	O
tv_sec	long
;	O
pthread_rwlock_unlock	function
(	O
&	O
cache_lock	union
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
}	O
pthread_rwlock_rdlock	function
(	O
&	O
cache_lock	union
)	O
;	O
first	pointer
=	O
cached_data	pointer
;	O
bytes_left	long
=	O
cached_data_len	int
;	O
entries_left	long
=	O
cached_data_entries	int
;	O
while	O
(	O
first_entry	int
>	O
0	int
)	O
{	O
struct	O
dirent	struct
*	O
e	pointer
=	O
(	O
struct	O
dirent	struct
*	O
)	O
first	pointer
;	O
if	O
(	O
entries_left	long
==	O
0	int
)	O
{	O
pthread_rwlock_unlock	function
(	O
&	O
cache_lock	union
)	O
;	O
return	O
EINVAL	O
;	O
}	O
first	pointer
+=	O
e	pointer
->	O
d_reclen	short
;	O
bytes_left	long
-=	O
e	pointer
->	O
d_reclen	short
;	O
entries_left	long
--	O
;	O
}	O
if	O
(	O
(	O
max_data_len	int
>	O
0	int
&&	O
max_data_len	int
<	O
bytes_left	long
)	O
||	O
(	O
max_entries	int
>	O
0	int
&&	O
max_entries	int
<	O
entries_left	long
)	O
)	O
{	O
char	O
*	O
lim	pointer
=	O
first	pointer
;	O
int	O
entries	int
=	O
0	int
;	O
while	O
(	O
entries_left	long
>	O
0	int
&&	O
max_entries	int
>	O
0	int
&&	O
max_data_len	int
>	O
(	O
(	O
struct	O
dirent	struct
*	O
)	O
lim	pointer
)	O
->	O
d_reclen	short
)	O
{	O
size_t	long
reclen	long
=	O
(	O
(	O
struct	O
dirent	struct
*	O
)	O
lim	pointer
)	O
->	O
d_reclen	short
;	O
max_data_len	int
-=	O
reclen	long
;	O
max_entries	int
--	O
;	O
entries	int
++	O
;	O
lim	pointer
+=	O
reclen	long
;	O
}	O
bytes_left	long
=	O
(	O
lim	pointer
-	O
first	pointer
)	O
;	O
entries_left	long
=	O
entries	int
;	O
}	O
*	O
data_len	pointer
=	O
bytes_left	long
;	O
*	O
data_entries	pointer
=	O
entries_left	long
;	O
*	O
data	pointer
=	O
mmap	function
(	O
0	int
,	O
bytes_left	long
,	O
PROT_READ	int
|	O
PROT_WRITE	int
,	O
MAP_ANON	O
,	O
0	int
,	O
0	int
)	O
;	O
err	O
=	O
(	O
*	O
data	pointer
==	O
(	O
void	O
*	O
)	O
-	O
1	int
)	O
?	O
errno	O
:	O
0	int
;	O
if	O
(	O
!	O
err	O
)	O
bcopy	function
(	O
cached_data	pointer
,	O
*	O
data	pointer
,	O
bytes_left	long
)	O
;	O
pthread_rwlock_unlock	function
(	O
&	O
cache_lock	union
)	O
;	O
fshelp_touch	function
(	O
&	O
dir	pointer
->	O
nn_stat	O
,	O
TOUCH_ATIME	O
,	O
usermux_maptime	pointer
)	O
;	O
return	O
err	O
;	O
}	O
static	O
void	O
free_name	function
(	O
struct	O
usermux_name	struct
*	O
nm	pointer
)	O
{	O
free	function
(	O
(	O
char	O
*	O
)	O
nm	pointer
->	O
name	pointer
)	O
;	O
free	function
(	O
nm	pointer
)	O
;	O
}	O
static	O
int	O
lookup_cached	function
(	O
struct	O
usermux	struct
*	O
mux	pointer
,	O
const	O
char	O
*	O
user	pointer
,	O
int	O
purge	int
,	O
struct	O
node	pointer
*	O
*	O
node	pointer
)	O
{	O
struct	O
usermux_name	struct
*	O
nm	pointer
=	O
mux	pointer
->	O
names	pointer
,	O
*	O
*	O
prevl	pointer
=	O
&	O
mux	pointer
->	O
names	pointer
;	O
while	O
(	O
nm	pointer
)	O
{	O
struct	O
usermux_name	struct
*	O
next	pointer
=	O
nm	pointer
->	O
next	pointer
;	O
if	O
(	O
strcasecmp	function
(	O
user	pointer
,	O
nm	pointer
->	O
name	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
nm	pointer
->	O
node	pointer
)	O
netfs_nref	function
(	O
nm	pointer
->	O
node	pointer
)	O
;	O
if	O
(	O
nm	pointer
->	O
node	pointer
)	O
{	O
*	O
node	pointer
=	O
nm	pointer
->	O
node	pointer
;	O
return	O
1	int
;	O
}	O
}	O
if	O
(	O
purge	int
&&	O
!	O
nm	pointer
->	O
node	pointer
)	O
{	O
*	O
prevl	pointer
=	O
nm	pointer
->	O
next	pointer
;	O
free_name	function
(	O
nm	pointer
)	O
;	O
}	O
else	O
prevl	pointer
=	O
&	O
nm	pointer
->	O
next	pointer
;	O
nm	pointer
=	O
next	pointer
;	O
}	O
return	O
0	int
;	O
}	O
static	O
error_t	O
lookup_pwent	function
(	O
struct	O
usermux	struct
*	O
mux	pointer
,	O
const	O
char	O
*	O
user	pointer
,	O
struct	O
passwd	struct
*	O
pw	pointer
,	O
struct	O
node	pointer
*	O
*	O
node	pointer
)	O
{	O
error_t	O
err	O
;	O
struct	O
usermux_name	struct
*	O
nm	pointer
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
usermux_name	struct
)	O
)	O
;	O
if	O
(	O
!	O
nm	pointer
)	O
return	O
ENOMEM	O
;	O
nm	pointer
->	O
name	pointer
=	O
strdup	function
(	O
user	pointer
)	O
;	O
err	O
=	O
create_user_node	function
(	O
mux	pointer
,	O
nm	pointer
,	O
pw	pointer
,	O
node	pointer
)	O
;	O
if	O
(	O
err	O
)	O
{	O
free_name	function
(	O
nm	pointer
)	O
;	O
return	O
err	O
;	O
}	O
pthread_rwlock_wrlock	function
(	O
&	O
mux	pointer
->	O
names_lock	union
)	O
;	O
if	O
(	O
lookup_cached	function
(	O
mux	pointer
,	O
user	pointer
,	O
1	int
,	O
node	pointer
)	O
)	O
{	O
pthread_rwlock_unlock	function
(	O
&	O
mux	pointer
->	O
names_lock	union
)	O
;	O
nm	pointer
->	O
node	pointer
->	O
nn	O
->	O
name	pointer
=	O
0	int
;	O
netfs_nrele	function
(	O
nm	pointer
->	O
node	pointer
)	O
;	O
free_name	function
(	O
nm	pointer
)	O
;	O
}	O
else	O
{	O
nm	pointer
->	O
next	pointer
=	O
mux	pointer
->	O
names	pointer
;	O
mux	pointer
->	O
names	pointer
=	O
nm	pointer
;	O
pthread_rwlock_unlock	function
(	O
&	O
mux	pointer
->	O
names_lock	union
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
error_t	O
lookup_user	function
(	O
struct	O
usermux	struct
*	O
mux	pointer
,	O
const	O
char	O
*	O
user	pointer
,	O
struct	O
node	pointer
*	O
*	O
node	pointer
)	O
{	O
int	O
was_cached	int
;	O
struct	O
passwd	struct
_pw	struct
,	O
*	O
pw	pointer
;	O
char	O
pwent_data	array
[	O
2048	int
]	O
;	O
pthread_rwlock_rdlock	function
(	O
&	O
mux	pointer
->	O
names_lock	union
)	O
;	O
was_cached	int
=	O
lookup_cached	function
(	O
mux	pointer
,	O
user	pointer
,	O
0	int
,	O
node	pointer
)	O
;	O
pthread_rwlock_unlock	function
(	O
&	O
mux	pointer
->	O
names_lock	union
)	O
;	O
if	O
(	O
was_cached	int
)	O
return	O
0	int
;	O
else	O
{	O
if	O
(	O
getpwnam_r	function
(	O
user	pointer
,	O
&	O
_pw	struct
,	O
pwent_data	array
,	O
sizeof	O
pwent_data	array
,	O
&	O
pw	pointer
)	O
)	O
return	O
ENOENT	O
;	O
if	O
(	O
pw	pointer
==	O
NULL	O
)	O
return	O
ENOENT	O
;	O
return	O
lookup_pwent	function
(	O
mux	pointer
,	O
user	pointer
,	O
pw	pointer
,	O
node	pointer
)	O
;	O
}	O
}	O
error_t	O
netfs_attempt_syncfs	function
(	O
struct	O
iouser	O
*	O
cred	pointer
,	O
int	O
wait	int
)	O
{	O
return	O
0	int
;	O
}	O
error_t	O
netfs_attempt_chown	function
(	O
struct	O
iouser	O
*	O
cred	pointer
,	O
struct	O
node	pointer
*	O
node	pointer
,	O
uid_t	int
uid	int
,	O
uid_t	int
gid	int
)	O
{	O
if	O
(	O
node	pointer
->	O
nn	O
->	O
name	pointer
)	O
return	O
EOPNOTSUPP	O
;	O
else	O
{	O
struct	O
usermux	struct
*	O
mux	pointer
=	O
node	pointer
->	O
nn	O
->	O
mux	pointer
;	O
error_t	O
err	O
=	O
file_chown	O
(	O
mux	pointer
->	O
underlying	int
,	O
uid	int
,	O
gid	int
)	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
struct	O
usermux_name	struct
*	O
nm	pointer
;	O
mux	pointer
->	O
stat_template	struct
.	O
st_uid	O
=	O
uid	int
;	O
mux	pointer
->	O
stat_template	struct
.	O
st_gid	O
=	O
gid	int
;	O
node	pointer
->	O
nn_stat	O
.	O
st_uid	O
=	O
uid	int
;	O
node	pointer
->	O
nn_stat	O
.	O
st_gid	O
=	O
gid	int
;	O
pthread_rwlock_rdlock	function
(	O
&	O
mux	pointer
->	O
names_lock	union
)	O
;	O
for	O
(	O
nm	pointer
=	O
mux	pointer
->	O
names	pointer
;	O
nm	pointer
;	O
nm	pointer
=	O
nm	pointer
->	O
next	pointer
)	O
if	O
(	O
nm	pointer
->	O
node	pointer
)	O
{	O
nm	pointer
->	O
node	pointer
->	O
nn_stat	O
.	O
st_uid	O
=	O
uid	int
;	O
nm	pointer
->	O
node	pointer
->	O
nn_stat	O
.	O
st_gid	O
=	O
gid	int
;	O
}	O
pthread_rwlock_unlock	function
(	O
&	O
mux	pointer
->	O
names_lock	union
)	O
;	O
fshelp_touch	function
(	O
&	O
node	pointer
->	O
nn_stat	O
,	O
TOUCH_CTIME	O
,	O
usermux_maptime	pointer
)	O
;	O
}	O
return	O
err	O
;	O
}	O
}	O
error_t	O
netfs_attempt_chauthor	function
(	O
struct	O
iouser	O
*	O
cred	pointer
,	O
struct	O
node	pointer
*	O
node	pointer
,	O
uid_t	int
author	int
)	O
{	O
if	O
(	O
node	pointer
->	O
nn	O
->	O
name	pointer
)	O
return	O
EOPNOTSUPP	O
;	O
else	O
{	O
struct	O
usermux	struct
*	O
mux	pointer
=	O
node	pointer
->	O
nn	O
->	O
mux	pointer
;	O
error_t	O
err	O
=	O
file_chauthor	O
(	O
mux	pointer
->	O
underlying	int
,	O
author	int
)	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
struct	O
usermux_name	struct
*	O
nm	pointer
;	O
mux	pointer
->	O
stat_template	struct
.	O
st_author	O
=	O
author	int
;	O
node	pointer
->	O
nn_stat	O
.	O
st_author	O
=	O
author	int
;	O
pthread_rwlock_rdlock	function
(	O
&	O
mux	pointer
->	O
names_lock	union
)	O
;	O
for	O
(	O
nm	pointer
=	O
mux	pointer
->	O
names	pointer
;	O
nm	pointer
;	O
nm	pointer
=	O
nm	pointer
->	O
next	pointer
)	O
if	O
(	O
nm	pointer
->	O
node	pointer
)	O
nm	pointer
->	O
node	pointer
->	O
nn_stat	O
.	O
st_author	O
=	O
author	int
;	O
pthread_rwlock_unlock	function
(	O
&	O
mux	pointer
->	O
names_lock	union
)	O
;	O
fshelp_touch	function
(	O
&	O
node	pointer
->	O
nn_stat	O
,	O
TOUCH_CTIME	O
,	O
usermux_maptime	pointer
)	O
;	O
}	O
return	O
err	O
;	O
}	O
}	O
error_t	O
netfs_attempt_chmod	function
(	O
struct	O
iouser	O
*	O
cred	pointer
,	O
struct	O
node	pointer
*	O
node	pointer
,	O
mode_t	int
mode	int
)	O
{	O
mode	int
&=	O
~	O
S_ITRANS	O
;	O
if	O
(	O
(	O
mode	int
&	O
S_IFMT	O
)	O
==	O
0	int
)	O
mode	int
|=	O
(	O
node	pointer
->	O
nn_stat	O
.	O
st_mode	O
&	O
S_IFMT	O
)	O
;	O
if	O
(	O
node	pointer
->	O
nn	O
->	O
name	pointer
||	O
(	O
(	O
mode	int
&	O
S_IFMT	O
)	O
!=	O
(	O
node	pointer
->	O
nn_stat	O
.	O
st_mode	O
&	O
S_IFMT	O
)	O
)	O
)	O
return	O
EOPNOTSUPP	O
;	O
else	O
{	O
error_t	O
err	O
=	O
file_chmod	O
(	O
node	pointer
->	O
nn	O
->	O
mux	pointer
->	O
underlying	int
,	O
mode	int
&	O
~	O
S_IFMT	O
)	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
node	pointer
->	O
nn_stat	O
.	O
st_mode	O
=	O
mode	int
;	O
fshelp_touch	function
(	O
&	O
node	pointer
->	O
nn_stat	O
,	O
TOUCH_CTIME	O
,	O
usermux_maptime	pointer
)	O
;	O
}	O
return	O
err	O
;	O
}	O
}	O
