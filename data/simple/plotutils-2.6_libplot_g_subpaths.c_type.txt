static	O
void	O
_prepare_chord_table	function
(	O
double	O
sagitta	double
,	O
double	O
custom_chord_table	array
[	O
TABULATED_ARC_SUBDIVISIONS	int
]	O
)	O
;	O
static	O
void	O
_fakearc	function
(	O
plPath	struct
*	O
path	pointer
,	O
plPoint	struct
p0	struct
,	O
plPoint	struct
p1	struct
,	O
int	O
arc_type	int
,	O
const	O
double	O
*	O
custom_chord_table	array
,	O
const	O
double	O
m	array
[	O
4	int
]	O
)	O
;	O
plPath	struct
*	O
_new_plPath	function
(	O
void	O
)	O
{	O
plPath	struct
*	O
path	pointer
;	O
path	pointer
=	O
(	O
plPath	struct
*	O
)	O
_pl_xmalloc	function
(	O
sizeof	O
(	O
plPath	struct
)	O
)	O
;	O
path	pointer
->	O
type	enum
=	O
PATH_SEGMENT_LIST	int
;	O
path	pointer
->	O
segments	pointer
=	O
(	O
plPathSegment	struct
*	O
)	O
NULL	O
;	O
path	pointer
->	O
segments_len	int
=	O
0	int
;	O
path	pointer
->	O
num_segments	int
=	O
0	int
;	O
path	pointer
->	O
primitive	enum
=	O
false	int
;	O
path	pointer
->	O
llx	double
=	O
DBL_MAX	O
;	O
path	pointer
->	O
lly	double
=	O
DBL_MAX	O
;	O
path	pointer
->	O
urx	double
=	O
-	O
(	O
DBL_MAX	O
)	O
;	O
path	pointer
->	O
ury	double
=	O
-	O
(	O
DBL_MAX	O
)	O
;	O
return	O
path	pointer
;	O
}	O
void	O
_delete_plPath	function
(	O
plPath	struct
*	O
path	pointer
)	O
{	O
if	O
(	O
path	pointer
==	O
(	O
plPath	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	pointer
->	O
type	enum
==	O
PATH_SEGMENT_LIST	int
&&	O
path	pointer
->	O
segments_len	int
>	O
0	int
)	O
free	function
(	O
path	pointer
->	O
segments	pointer
)	O
;	O
free	function
(	O
path	pointer
)	O
;	O
}	O
void	O
_reset_plPath	function
(	O
plPath	struct
*	O
path	pointer
)	O
{	O
if	O
(	O
path	pointer
==	O
(	O
plPath	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	pointer
->	O
type	enum
==	O
PATH_SEGMENT_LIST	int
&&	O
path	pointer
->	O
segments_len	int
>	O
0	int
)	O
free	function
(	O
path	pointer
->	O
segments	pointer
)	O
;	O
path	pointer
->	O
segments	pointer
=	O
(	O
plPathSegment	struct
*	O
)	O
NULL	O
;	O
path	pointer
->	O
segments_len	int
=	O
0	int
;	O
path	pointer
->	O
type	enum
=	O
PATH_SEGMENT_LIST	int
;	O
path	pointer
->	O
num_segments	int
=	O
0	int
;	O
path	pointer
->	O
primitive	enum
=	O
false	int
;	O
path	pointer
->	O
llx	double
=	O
DBL_MAX	O
;	O
path	pointer
->	O
lly	double
=	O
DBL_MAX	O
;	O
path	pointer
->	O
urx	double
=	O
-	O
(	O
DBL_MAX	O
)	O
;	O
path	pointer
->	O
ury	double
=	O
-	O
(	O
DBL_MAX	O
)	O
;	O
}	O
void	O
_add_moveto	function
(	O
plPath	struct
*	O
path	pointer
,	O
plPoint	struct
p	struct
)	O
{	O
if	O
(	O
path	pointer
==	O
(	O
plPath	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	pointer
->	O
type	enum
!=	O
PATH_SEGMENT_LIST	int
||	O
path	pointer
->	O
num_segments	int
>	O
0	int
)	O
return	O
;	O
path	pointer
->	O
segments	pointer
=	O
(	O
plPathSegment	struct
*	O
)	O
_pl_xmalloc	function
(	O
DATAPOINTS_BUFSIZ	O
*	O
sizeof	O
(	O
plPathSegment	struct
)	O
)	O
;	O
path	pointer
->	O
segments_len	int
=	O
DATAPOINTS_BUFSIZ	O
;	O
path	pointer
->	O
segments	pointer
[	O
0	int
]	O
.	O
type	enum
=	O
S_MOVETO	int
;	O
path	pointer
->	O
segments	pointer
[	O
0	int
]	O
.	O
p	struct
=	O
p	struct
;	O
path	pointer
->	O
num_segments	int
=	O
1	int
;	O
path	pointer
->	O
llx	double
=	O
p	struct
.	O
x	double
;	O
path	pointer
->	O
lly	double
=	O
p	struct
.	O
y	double
;	O
path	pointer
->	O
urx	double
=	O
p	struct
.	O
x	double
;	O
path	pointer
->	O
ury	double
=	O
p	struct
.	O
y	double
;	O
}	O
void	O
_add_line	function
(	O
plPath	struct
*	O
path	pointer
,	O
plPoint	struct
p	struct
)	O
{	O
if	O
(	O
path	pointer
==	O
(	O
plPath	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	pointer
->	O
type	enum
!=	O
PATH_SEGMENT_LIST	int
||	O
path	pointer
->	O
num_segments	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
path	pointer
->	O
num_segments	int
==	O
0	int
)	O
{	O
path	pointer
->	O
segments	pointer
=	O
(	O
plPathSegment	struct
*	O
)	O
_pl_xmalloc	function
(	O
DATAPOINTS_BUFSIZ	O
*	O
sizeof	O
(	O
plPathSegment	struct
)	O
)	O
;	O
path	pointer
->	O
segments_len	int
=	O
DATAPOINTS_BUFSIZ	O
;	O
}	O
if	O
(	O
path	pointer
->	O
num_segments	int
==	O
path	pointer
->	O
segments_len	int
)	O
{	O
path	pointer
->	O
segments	pointer
=	O
(	O
plPathSegment	struct
*	O
)	O
_pl_xrealloc	function
(	O
path	pointer
->	O
segments	pointer
,	O
2	int
*	O
path	pointer
->	O
segments_len	int
*	O
sizeof	O
(	O
plPathSegment	struct
)	O
)	O
;	O
path	pointer
->	O
segments_len	int
*=	O
2	int
;	O
}	O
path	pointer
->	O
segments	pointer
[	O
path	pointer
->	O
num_segments	int
]	O
.	O
type	enum
=	O
S_LINE	int
;	O
path	pointer
->	O
segments	pointer
[	O
path	pointer
->	O
num_segments	int
]	O
.	O
p	struct
=	O
p	struct
;	O
path	pointer
->	O
num_segments	int
++	O
;	O
path	pointer
->	O
llx	double
=	O
DMIN	O
(	O
path	pointer
->	O
llx	double
,	O
p	struct
.	O
x	double
)	O
;	O
path	pointer
->	O
lly	double
=	O
DMIN	O
(	O
path	pointer
->	O
lly	double
,	O
p	struct
.	O
y	double
)	O
;	O
path	pointer
->	O
urx	double
=	O
DMAX	O
(	O
path	pointer
->	O
urx	double
,	O
p	struct
.	O
x	double
)	O
;	O
path	pointer
->	O
ury	double
=	O
DMAX	O
(	O
path	pointer
->	O
ury	double
,	O
p	struct
.	O
y	double
)	O
;	O
}	O
void	O
_add_closepath	function
(	O
plPath	struct
*	O
path	pointer
)	O
{	O
if	O
(	O
path	pointer
==	O
(	O
plPath	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	pointer
->	O
type	enum
!=	O
PATH_SEGMENT_LIST	int
||	O
path	pointer
->	O
num_segments	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
path	pointer
->	O
num_segments	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
path	pointer
->	O
num_segments	int
==	O
path	pointer
->	O
segments_len	int
)	O
{	O
path	pointer
->	O
segments	pointer
=	O
(	O
plPathSegment	struct
*	O
)	O
_pl_xrealloc	function
(	O
path	pointer
->	O
segments	pointer
,	O
2	int
*	O
path	pointer
->	O
segments_len	int
*	O
sizeof	O
(	O
plPathSegment	struct
)	O
)	O
;	O
path	pointer
->	O
segments_len	int
*=	O
2	int
;	O
}	O
path	pointer
->	O
segments	pointer
[	O
path	pointer
->	O
num_segments	int
]	O
.	O
type	enum
=	O
S_CLOSEPATH	int
;	O
path	pointer
->	O
segments	pointer
[	O
path	pointer
->	O
num_segments	int
]	O
.	O
p	struct
=	O
path	pointer
->	O
segments	pointer
[	O
0	int
]	O
.	O
p	struct
;	O
path	pointer
->	O
num_segments	int
++	O
;	O
}	O
void	O
_add_bezier2	function
(	O
plPath	struct
*	O
path	pointer
,	O
plPoint	struct
pc	struct
,	O
plPoint	struct
p	struct
)	O
{	O
if	O
(	O
path	pointer
==	O
(	O
plPath	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	pointer
->	O
type	enum
!=	O
PATH_SEGMENT_LIST	int
||	O
path	pointer
->	O
num_segments	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
path	pointer
->	O
num_segments	int
==	O
0	int
)	O
{	O
path	pointer
->	O
segments	pointer
=	O
(	O
plPathSegment	struct
*	O
)	O
_pl_xmalloc	function
(	O
DATAPOINTS_BUFSIZ	O
*	O
sizeof	O
(	O
plPathSegment	struct
)	O
)	O
;	O
path	pointer
->	O
segments_len	int
=	O
DATAPOINTS_BUFSIZ	O
;	O
}	O
if	O
(	O
path	pointer
->	O
num_segments	int
==	O
path	pointer
->	O
segments_len	int
)	O
{	O
path	pointer
->	O
segments	pointer
=	O
(	O
plPathSegment	struct
*	O
)	O
_pl_xrealloc	function
(	O
path	pointer
->	O
segments	pointer
,	O
2	int
*	O
path	pointer
->	O
segments_len	int
*	O
sizeof	O
(	O
plPathSegment	struct
)	O
)	O
;	O
path	pointer
->	O
segments_len	int
*=	O
2	int
;	O
}	O
path	pointer
->	O
segments	pointer
[	O
path	pointer
->	O
num_segments	int
]	O
.	O
type	enum
=	O
S_QUAD	int
;	O
path	pointer
->	O
segments	pointer
[	O
path	pointer
->	O
num_segments	int
]	O
.	O
p	struct
=	O
p	struct
;	O
path	pointer
->	O
segments	pointer
[	O
path	pointer
->	O
num_segments	int
]	O
.	O
pc	struct
=	O
pc	struct
;	O
path	pointer
->	O
num_segments	int
++	O
;	O
}	O
void	O
_add_bezier3	function
(	O
plPath	struct
*	O
path	pointer
,	O
plPoint	struct
pc	struct
,	O
plPoint	struct
pd	struct
,	O
plPoint	struct
p	struct
)	O
{	O
if	O
(	O
path	pointer
==	O
(	O
plPath	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	pointer
->	O
type	enum
!=	O
PATH_SEGMENT_LIST	int
||	O
path	pointer
->	O
num_segments	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
path	pointer
->	O
num_segments	int
==	O
0	int
)	O
{	O
path	pointer
->	O
segments	pointer
=	O
(	O
plPathSegment	struct
*	O
)	O
_pl_xmalloc	function
(	O
DATAPOINTS_BUFSIZ	O
*	O
sizeof	O
(	O
plPathSegment	struct
)	O
)	O
;	O
path	pointer
->	O
segments_len	int
=	O
DATAPOINTS_BUFSIZ	O
;	O
}	O
if	O
(	O
path	pointer
->	O
num_segments	int
==	O
path	pointer
->	O
segments_len	int
)	O
{	O
path	pointer
->	O
segments	pointer
=	O
(	O
plPathSegment	struct
*	O
)	O
_pl_xrealloc	function
(	O
path	pointer
->	O
segments	pointer
,	O
2	int
*	O
path	pointer
->	O
segments_len	int
*	O
sizeof	O
(	O
plPathSegment	struct
)	O
)	O
;	O
path	pointer
->	O
segments_len	int
*=	O
2	int
;	O
}	O
path	pointer
->	O
segments	pointer
[	O
path	pointer
->	O
num_segments	int
]	O
.	O
type	enum
=	O
S_CUBIC	int
;	O
path	pointer
->	O
segments	pointer
[	O
path	pointer
->	O
num_segments	int
]	O
.	O
p	struct
=	O
p	struct
;	O
path	pointer
->	O
segments	pointer
[	O
path	pointer
->	O
num_segments	int
]	O
.	O
pc	struct
=	O
pc	struct
;	O
path	pointer
->	O
segments	pointer
[	O
path	pointer
->	O
num_segments	int
]	O
.	O
pd	struct
=	O
pd	struct
;	O
path	pointer
->	O
num_segments	int
++	O
;	O
}	O
void	O
_add_arc	function
(	O
plPath	struct
*	O
path	pointer
,	O
plPoint	struct
pc	struct
,	O
plPoint	struct
p1	struct
)	O
{	O
if	O
(	O
path	pointer
==	O
(	O
plPath	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	pointer
->	O
type	enum
!=	O
PATH_SEGMENT_LIST	int
||	O
path	pointer
->	O
num_segments	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
path	pointer
->	O
num_segments	int
==	O
0	int
)	O
{	O
path	pointer
->	O
segments	pointer
=	O
(	O
plPathSegment	struct
*	O
)	O
_pl_xmalloc	function
(	O
DATAPOINTS_BUFSIZ	O
*	O
sizeof	O
(	O
plPathSegment	struct
)	O
)	O
;	O
path	pointer
->	O
segments_len	int
=	O
DATAPOINTS_BUFSIZ	O
;	O
}	O
if	O
(	O
path	pointer
->	O
num_segments	int
==	O
path	pointer
->	O
segments_len	int
)	O
{	O
path	pointer
->	O
segments	pointer
=	O
(	O
plPathSegment	struct
*	O
)	O
_pl_xrealloc	function
(	O
path	pointer
->	O
segments	pointer
,	O
2	int
*	O
path	pointer
->	O
segments_len	int
*	O
sizeof	O
(	O
plPathSegment	struct
)	O
)	O
;	O
path	pointer
->	O
segments_len	int
*=	O
2	int
;	O
}	O
path	pointer
->	O
segments	pointer
[	O
path	pointer
->	O
num_segments	int
]	O
.	O
type	enum
=	O
S_ARC	int
;	O
path	pointer
->	O
segments	pointer
[	O
path	pointer
->	O
num_segments	int
]	O
.	O
p	struct
=	O
p1	struct
;	O
path	pointer
->	O
segments	pointer
[	O
path	pointer
->	O
num_segments	int
]	O
.	O
pc	struct
=	O
pc	struct
;	O
path	pointer
->	O
num_segments	int
++	O
;	O
}	O
void	O
_add_ellarc	function
(	O
plPath	struct
*	O
path	pointer
,	O
plPoint	struct
pc	struct
,	O
plPoint	struct
p1	struct
)	O
{	O
if	O
(	O
path	pointer
==	O
(	O
plPath	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	pointer
->	O
type	enum
!=	O
PATH_SEGMENT_LIST	int
||	O
path	pointer
->	O
num_segments	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
path	pointer
->	O
num_segments	int
==	O
0	int
)	O
{	O
path	pointer
->	O
segments	pointer
=	O
(	O
plPathSegment	struct
*	O
)	O
_pl_xmalloc	function
(	O
DATAPOINTS_BUFSIZ	O
*	O
sizeof	O
(	O
plPathSegment	struct
)	O
)	O
;	O
path	pointer
->	O
segments_len	int
=	O
DATAPOINTS_BUFSIZ	O
;	O
}	O
if	O
(	O
path	pointer
->	O
num_segments	int
==	O
path	pointer
->	O
segments_len	int
)	O
{	O
path	pointer
->	O
segments	pointer
=	O
(	O
plPathSegment	struct
*	O
)	O
_pl_xrealloc	function
(	O
path	pointer
->	O
segments	pointer
,	O
2	int
*	O
path	pointer
->	O
segments_len	int
*	O
sizeof	O
(	O
plPathSegment	struct
)	O
)	O
;	O
path	pointer
->	O
segments_len	int
*=	O
2	int
;	O
}	O
path	pointer
->	O
segments	pointer
[	O
path	pointer
->	O
num_segments	int
]	O
.	O
type	enum
=	O
S_ELLARC	int
;	O
path	pointer
->	O
segments	pointer
[	O
path	pointer
->	O
num_segments	int
]	O
.	O
p	struct
=	O
p1	struct
;	O
path	pointer
->	O
segments	pointer
[	O
path	pointer
->	O
num_segments	int
]	O
.	O
pc	struct
=	O
pc	struct
;	O
path	pointer
->	O
num_segments	int
++	O
;	O
}	O
void	O
_add_box	function
(	O
plPath	struct
*	O
path	pointer
,	O
plPoint	struct
p0	struct
,	O
plPoint	struct
p1	struct
,	O
bool	enum
clockwise	enum
)	O
{	O
if	O
(	O
path	pointer
==	O
(	O
plPath	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	pointer
->	O
type	enum
!=	O
PATH_SEGMENT_LIST	int
||	O
path	pointer
->	O
num_segments	int
>	O
0	int
)	O
return	O
;	O
path	pointer
->	O
type	enum
=	O
PATH_BOX	int
;	O
path	pointer
->	O
p0	struct
=	O
p0	struct
;	O
path	pointer
->	O
p1	struct
=	O
p1	struct
;	O
path	pointer
->	O
clockwise	enum
=	O
clockwise	enum
;	O
path	pointer
->	O
llx	double
=	O
DMIN	O
(	O
path	pointer
->	O
llx	double
,	O
p0	struct
.	O
x	double
)	O
;	O
path	pointer
->	O
lly	double
=	O
DMIN	O
(	O
path	pointer
->	O
lly	double
,	O
p0	struct
.	O
y	double
)	O
;	O
path	pointer
->	O
urx	double
=	O
DMAX	O
(	O
path	pointer
->	O
urx	double
,	O
p0	struct
.	O
x	double
)	O
;	O
path	pointer
->	O
ury	double
=	O
DMAX	O
(	O
path	pointer
->	O
ury	double
,	O
p0	struct
.	O
y	double
)	O
;	O
path	pointer
->	O
llx	double
=	O
DMIN	O
(	O
path	pointer
->	O
llx	double
,	O
p1	struct
.	O
x	double
)	O
;	O
path	pointer
->	O
lly	double
=	O
DMIN	O
(	O
path	pointer
->	O
lly	double
,	O
p1	struct
.	O
y	double
)	O
;	O
path	pointer
->	O
urx	double
=	O
DMAX	O
(	O
path	pointer
->	O
urx	double
,	O
p1	struct
.	O
x	double
)	O
;	O
path	pointer
->	O
ury	double
=	O
DMAX	O
(	O
path	pointer
->	O
ury	double
,	O
p1	struct
.	O
y	double
)	O
;	O
}	O
void	O
_add_circle	function
(	O
plPath	struct
*	O
path	pointer
,	O
plPoint	struct
pc	struct
,	O
double	O
radius	double
,	O
bool	enum
clockwise	enum
)	O
{	O
if	O
(	O
path	pointer
==	O
(	O
plPath	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	pointer
->	O
type	enum
!=	O
PATH_SEGMENT_LIST	int
||	O
path	pointer
->	O
num_segments	int
>	O
0	int
)	O
return	O
;	O
path	pointer
->	O
type	enum
=	O
PATH_CIRCLE	int
;	O
path	pointer
->	O
pc	struct
=	O
pc	struct
;	O
path	pointer
->	O
radius	double
=	O
radius	double
;	O
path	pointer
->	O
clockwise	enum
=	O
clockwise	enum
;	O
}	O
void	O
_add_ellipse	function
(	O
plPath	struct
*	O
path	pointer
,	O
plPoint	struct
pc	struct
,	O
double	O
rx	double
,	O
double	O
ry	double
,	O
double	O
angle	double
,	O
bool	enum
clockwise	enum
)	O
{	O
if	O
(	O
path	pointer
==	O
(	O
plPath	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	pointer
->	O
type	enum
!=	O
PATH_SEGMENT_LIST	int
||	O
path	pointer
->	O
num_segments	int
>	O
0	int
)	O
return	O
;	O
path	pointer
->	O
type	enum
=	O
PATH_ELLIPSE	int
;	O
path	pointer
->	O
pc	struct
=	O
pc	struct
;	O
path	pointer
->	O
rx	double
=	O
rx	double
;	O
path	pointer
->	O
ry	double
=	O
ry	double
;	O
path	pointer
->	O
angle	double
=	O
angle	double
;	O
path	pointer
->	O
clockwise	enum
=	O
clockwise	enum
;	O
}	O
void	O
_add_arc_as_lines	function
(	O
plPath	struct
*	O
path	pointer
,	O
plPoint	struct
pc	struct
,	O
plPoint	struct
p1	struct
)	O
{	O
plPoint	struct
p0	struct
;	O
plPoint	struct
pb	struct
,	O
pm	struct
;	O
double	O
m	array
[	O
4	int
]	O
;	O
plVector	struct
v	pointer
,	O
v0	struct
,	O
v1	struct
;	O
double	O
radius	double
,	O
sagitta	double
;	O
double	O
cross	double
,	O
orientation	int
;	O
double	O
custom_chord_table	array
[	O
TABULATED_ARC_SUBDIVISIONS	int
]	O
;	O
if	O
(	O
path	pointer
==	O
(	O
plPath	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	pointer
->	O
type	enum
!=	O
PATH_SEGMENT_LIST	int
||	O
path	pointer
->	O
num_segments	int
==	O
0	int
)	O
return	O
;	O
p0	struct
=	O
path	pointer
->	O
segments	pointer
[	O
path	pointer
->	O
num_segments	int
-	O
1	int
]	O
.	O
p	struct
;	O
if	O
(	O
p0	struct
.	O
x	double
==	O
p1	struct
.	O
x	double
&&	O
p0	struct
.	O
y	double
==	O
p1	struct
.	O
y	double
)	O
_add_line	function
(	O
path	pointer
,	O
p0	struct
)	O
;	O
else	O
{	O
v0	struct
.	O
x	double
=	O
p0	struct
.	O
x	double
-	O
pc	struct
.	O
x	double
;	O
v0	struct
.	O
y	double
=	O
p0	struct
.	O
y	double
-	O
pc	struct
.	O
y	double
;	O
v1	struct
.	O
x	double
=	O
p1	struct
.	O
x	double
-	O
pc	struct
.	O
x	double
;	O
v1	struct
.	O
y	double
=	O
p1	struct
.	O
y	double
-	O
pc	struct
.	O
y	double
;	O
cross	double
=	O
v0	struct
.	O
x	double
*	O
v1	struct
.	O
y	double
-	O
v1	struct
.	O
x	double
*	O
v0	struct
.	O
y	double
;	O
orientation	int
=	O
(	O
cross	double
>=	O
0.0	int
?	O
1.0	int
:	O
-	O
1.0	int
)	O
;	O
radius	double
=	O
DIST	O
(	O
pc	struct
,	O
p0	struct
)	O
;	O
pm	struct
.	O
x	double
=	O
0.5	int
*	O
(	O
p0	struct
.	O
x	double
+	O
p1	struct
.	O
x	double
)	O
;	O
pm	struct
.	O
y	double
=	O
0.5	int
*	O
(	O
p0	struct
.	O
y	double
+	O
p1	struct
.	O
y	double
)	O
;	O
v	pointer
.	O
x	double
=	O
p1	struct
.	O
x	double
-	O
p0	struct
.	O
x	double
;	O
v	pointer
.	O
y	double
=	O
p1	struct
.	O
y	double
-	O
p0	struct
.	O
y	double
;	O
_vscale	function
(	O
&	O
v	pointer
,	O
radius	double
)	O
;	O
pb	struct
.	O
x	double
=	O
pc	struct
.	O
x	double
+	O
orientation	int
*	O
v	pointer
.	O
y	double
;	O
pb	struct
.	O
y	double
=	O
pc	struct
.	O
y	double
-	O
orientation	int
*	O
v	pointer
.	O
x	double
;	O
sagitta	double
=	O
DIST	O
(	O
pb	struct
,	O
pm	struct
)	O
/	O
radius	double
;	O
_prepare_chord_table	function
(	O
sagitta	double
,	O
custom_chord_table	array
)	O
;	O
m	array
[	O
0	int
]	O
=	O
0.0	int
,	O
m	array
[	O
1	int
]	O
=	O
orientation	int
,	O
m	array
[	O
2	int
]	O
=	O
-	O
orientation	int
,	O
m	array
[	O
3	int
]	O
=	O
0.0	int
;	O
_fakearc	function
(	O
path	pointer
,	O
p0	struct
,	O
p1	struct
,	O
USER_DEFINED_ARC	O
,	O
custom_chord_table	array
,	O
m	array
)	O
;	O
}	O
}	O
void	O
_add_ellarc_as_lines	function
(	O
plPath	struct
*	O
path	pointer
,	O
plPoint	struct
pc	struct
,	O
plPoint	struct
p1	struct
)	O
{	O
plPoint	struct
p0	struct
;	O
plVector	struct
v0	struct
,	O
v1	struct
;	O
double	O
cross	double
;	O
double	O
m	array
[	O
4	int
]	O
;	O
if	O
(	O
path	pointer
==	O
(	O
plPath	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	pointer
->	O
type	enum
!=	O
PATH_SEGMENT_LIST	int
||	O
path	pointer
->	O
num_segments	int
==	O
0	int
)	O
return	O
;	O
p0	struct
=	O
path	pointer
->	O
segments	pointer
[	O
path	pointer
->	O
num_segments	int
-	O
1	int
]	O
.	O
p	struct
;	O
v0	struct
.	O
x	double
=	O
p0	struct
.	O
x	double
-	O
pc	struct
.	O
x	double
;	O
v0	struct
.	O
y	double
=	O
p0	struct
.	O
y	double
-	O
pc	struct
.	O
y	double
;	O
v1	struct
.	O
x	double
=	O
p1	struct
.	O
x	double
-	O
pc	struct
.	O
x	double
;	O
v1	struct
.	O
y	double
=	O
p1	struct
.	O
y	double
-	O
pc	struct
.	O
y	double
;	O
cross	double
=	O
v0	struct
.	O
x	double
*	O
v1	struct
.	O
y	double
-	O
v1	struct
.	O
x	double
*	O
v0	struct
.	O
y	double
;	O
if	O
(	O
FROUND	O
(	O
cross	double
)	O
==	O
0.0	int
)	O
_add_line	function
(	O
path	pointer
,	O
p1	struct
)	O
;	O
else	O
{	O
m	array
[	O
0	int
]	O
=	O
-	O
(	O
v0	struct
.	O
x	double
*	O
v0	struct
.	O
y	double
+	O
v1	struct
.	O
x	double
*	O
v1	struct
.	O
y	double
)	O
/	O
cross	double
;	O
m	array
[	O
1	int
]	O
=	O
(	O
v0	struct
.	O
x	double
*	O
v0	struct
.	O
x	double
+	O
v1	struct
.	O
x	double
*	O
v1	struct
.	O
x	double
)	O
/	O
cross	double
;	O
m	array
[	O
2	int
]	O
=	O
-	O
(	O
v0	struct
.	O
y	double
*	O
v0	struct
.	O
y	double
+	O
v1	struct
.	O
y	double
*	O
v1	struct
.	O
y	double
)	O
/	O
cross	double
;	O
m	array
[	O
3	int
]	O
=	O
(	O
v0	struct
.	O
x	double
*	O
v0	struct
.	O
y	double
+	O
v1	struct
.	O
x	double
*	O
v1	struct
.	O
y	double
)	O
/	O
cross	double
;	O
_fakearc	function
(	O
path	pointer
,	O
p0	struct
,	O
p1	struct
,	O
QUARTER_ARC	int
,	O
(	O
double	O
*	O
)	O
NULL	O
,	O
m	array
)	O
;	O
}	O
}	O
void	O
_add_arc_as_bezier3	function
(	O
plPath	struct
*	O
path	pointer
,	O
plPoint	struct
pc	struct
,	O
plPoint	struct
p1	struct
)	O
{	O
plPoint	struct
p0	struct
;	O
plVector	struct
v0	struct
,	O
v1	struct
;	O
if	O
(	O
path	pointer
==	O
(	O
plPath	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	pointer
->	O
type	enum
!=	O
PATH_SEGMENT_LIST	int
||	O
path	pointer
->	O
num_segments	int
==	O
0	int
)	O
return	O
;	O
p0	struct
=	O
path	pointer
->	O
segments	pointer
[	O
path	pointer
->	O
num_segments	int
-	O
1	int
]	O
.	O
p	struct
;	O
v0	struct
.	O
x	double
=	O
p0	struct
.	O
x	double
-	O
pc	struct
.	O
x	double
;	O
v0	struct
.	O
y	double
=	O
p0	struct
.	O
y	double
-	O
pc	struct
.	O
y	double
;	O
v1	struct
.	O
x	double
=	O
p1	struct
.	O
x	double
-	O
pc	struct
.	O
x	double
;	O
v1	struct
.	O
y	double
=	O
p1	struct
.	O
y	double
-	O
pc	struct
.	O
y	double
;	O
if	O
(	O
(	O
v0	struct
.	O
x	double
==	O
0.0	int
&&	O
v0	struct
.	O
y	double
==	O
0.0	int
)	O
||	O
(	O
v1	struct
.	O
x	double
==	O
0.0	int
&&	O
v1	struct
.	O
y	double
==	O
0.0	int
)	O
||	O
(	O
v0	struct
.	O
x	double
==	O
v1	struct
.	O
x	double
&&	O
v0	struct
.	O
y	double
==	O
v1	struct
.	O
y	double
)	O
)	O
_add_line	function
(	O
path	pointer
,	O
p1	struct
)	O
;	O
else	O
{	O
double	O
oldangle	double
,	O
newangle	double
,	O
anglerange	int
;	O
double	O
cross	double
;	O
int	O
orientation	int
;	O
cross	double
=	O
v0	struct
.	O
x	double
*	O
v1	struct
.	O
y	double
-	O
v1	struct
.	O
x	double
*	O
v0	struct
.	O
y	double
;	O
orientation	int
=	O
(	O
cross	double
>=	O
0.0	int
?	O
1	int
:	O
-	O
1	int
)	O
;	O
oldangle	double
=	O
_xatan2	function
(	O
v0	struct
.	O
y	double
,	O
v0	struct
.	O
x	double
)	O
;	O
newangle	double
=	O
_xatan2	function
(	O
v1	struct
.	O
y	double
,	O
v1	struct
.	O
x	double
)	O
;	O
anglerange	int
=	O
newangle	double
-	O
oldangle	double
;	O
if	O
(	O
anglerange	int
>	O
M_PI	int
)	O
anglerange	int
-=	O
(	O
2	int
*	O
M_PI	int
)	O
;	O
if	O
(	O
anglerange	int
<=	O
-	O
(	O
M_PI	int
)	O
)	O
anglerange	int
+=	O
(	O
2	int
*	O
M_PI	int
)	O
;	O
if	O
(	O
FABS	O
(	O
anglerange	int
)	O
>	O
0.51	int
*	O
M_PI	int
)	O
{	O
double	O
radius	double
;	O
plPoint	struct
pb	struct
;	O
plVector	struct
v	pointer
;	O
radius	double
=	O
DIST	O
(	O
pc	struct
,	O
p0	struct
)	O
;	O
v	pointer
.	O
x	double
=	O
p1	struct
.	O
x	double
-	O
p0	struct
.	O
x	double
;	O
v	pointer
.	O
y	double
=	O
p1	struct
.	O
y	double
-	O
p0	struct
.	O
y	double
;	O
_vscale	function
(	O
&	O
v	pointer
,	O
radius	double
)	O
;	O
pb	struct
.	O
x	double
=	O
pc	struct
.	O
x	double
+	O
orientation	int
*	O
v	pointer
.	O
y	double
;	O
pb	struct
.	O
y	double
=	O
pc	struct
.	O
y	double
-	O
orientation	int
*	O
v	pointer
.	O
x	double
;	O
_add_arc_as_bezier3	function
(	O
path	pointer
,	O
pc	struct
,	O
pb	struct
)	O
;	O
_add_arc_as_bezier3	function
(	O
path	pointer
,	O
pc	struct
,	O
p1	struct
)	O
;	O
}	O
else	O
{	O
double	O
halfangle	double
,	O
sinhalf	double
,	O
coshalf	double
,	O
kappa	double
;	O
plPoint	struct
pc_bezier3	struct
,	O
pd_bezier3	struct
;	O
halfangle	double
=	O
0.5	int
*	O
FABS	O
(	O
anglerange	int
)	O
;	O
sinhalf	double
=	O
sin	function
(	O
halfangle	double
)	O
;	O
coshalf	double
=	O
cos	function
(	O
halfangle	double
)	O
;	O
if	O
(	O
FABS	O
(	O
sinhalf	double
)	O
<	O
0.5	int
)	O
kappa	double
=	O
(	O
4.0	int
/	O
3.0	int
)	O
*	O
sinhalf	double
/	O
(	O
1.0	int
+	O
coshalf	double
)	O
;	O
else	O
kappa	double
=	O
(	O
4.0	int
/	O
3.0	int
)	O
*	O
(	O
1.0	int
-	O
coshalf	double
)	O
/	O
sinhalf	double
;	O
pc_bezier3	struct
.	O
x	double
=	O
p0	struct
.	O
x	double
-	O
kappa	double
*	O
orientation	int
*	O
v0	struct
.	O
y	double
;	O
pc_bezier3	struct
.	O
y	double
=	O
p0	struct
.	O
y	double
+	O
kappa	double
*	O
orientation	int
*	O
v0	struct
.	O
x	double
;	O
pd_bezier3	struct
.	O
x	double
=	O
p1	struct
.	O
x	double
+	O
kappa	double
*	O
orientation	int
*	O
v1	struct
.	O
y	double
;	O
pd_bezier3	struct
.	O
y	double
=	O
p1	struct
.	O
y	double
-	O
kappa	double
*	O
orientation	int
*	O
v1	struct
.	O
x	double
;	O
_add_bezier3	function
(	O
path	pointer
,	O
pc_bezier3	struct
,	O
pd_bezier3	struct
,	O
p1	struct
)	O
;	O
}	O
}	O
}	O
void	O
_add_ellarc_as_bezier3	function
(	O
plPath	struct
*	O
path	pointer
,	O
plPoint	struct
pc	struct
,	O
plPoint	struct
p1	struct
)	O
{	O
plPoint	struct
p0	struct
,	O
pc_bezier3	struct
,	O
pd_bezier3	struct
;	O
plVector	struct
v0	struct
,	O
v1	struct
;	O
if	O
(	O
path	pointer
==	O
(	O
plPath	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	pointer
->	O
type	enum
!=	O
PATH_SEGMENT_LIST	int
||	O
path	pointer
->	O
num_segments	int
==	O
0	int
)	O
return	O
;	O
p0	struct
=	O
path	pointer
->	O
segments	pointer
[	O
path	pointer
->	O
num_segments	int
-	O
1	int
]	O
.	O
p	struct
;	O
v0	struct
.	O
x	double
=	O
p0	struct
.	O
x	double
-	O
pc	struct
.	O
x	double
;	O
v0	struct
.	O
y	double
=	O
p0	struct
.	O
y	double
-	O
pc	struct
.	O
y	double
;	O
v1	struct
.	O
x	double
=	O
p1	struct
.	O
x	double
-	O
pc	struct
.	O
x	double
;	O
v1	struct
.	O
y	double
=	O
p1	struct
.	O
y	double
-	O
pc	struct
.	O
y	double
;	O
pc_bezier3	struct
.	O
x	double
=	O
p0	struct
.	O
x	double
+	O
KAPPA_FOR_QUARTER_CIRCLE	int
*	O
v1	struct
.	O
x	double
;	O
pc_bezier3	struct
.	O
y	double
=	O
p0	struct
.	O
y	double
+	O
KAPPA_FOR_QUARTER_CIRCLE	int
*	O
v1	struct
.	O
y	double
;	O
pd_bezier3	struct
.	O
x	double
=	O
p1	struct
.	O
x	double
+	O
KAPPA_FOR_QUARTER_CIRCLE	int
*	O
v0	struct
.	O
x	double
;	O
pd_bezier3	struct
.	O
y	double
=	O
p1	struct
.	O
y	double
+	O
KAPPA_FOR_QUARTER_CIRCLE	int
*	O
v0	struct
.	O
y	double
;	O
_add_bezier3	function
(	O
path	pointer
,	O
pc_bezier3	struct
,	O
pd_bezier3	struct
,	O
p1	struct
)	O
;	O
}	O
void	O
_add_bezier2_as_lines	function
(	O
plPath	struct
*	O
path	pointer
,	O
plPoint	struct
pc	struct
,	O
plPoint	struct
p	struct
)	O
{	O
plPoint	struct
r0	array
[	O
MAX_NUM_BEZIER2_SUBDIVISIONS	int
+	O
1	int
]	O
,	O
r1	array
[	O
MAX_NUM_BEZIER2_SUBDIVISIONS	int
+	O
1	int
]	O
,	O
r2	array
[	O
MAX_NUM_BEZIER2_SUBDIVISIONS	int
+	O
1	int
]	O
;	O
int	O
level	int
[	O
MAX_NUM_BEZIER2_SUBDIVISIONS	int
+	O
1	int
]	O
;	O
int	O
n	array
=	O
0	int
;	O
int	O
segments_drawn	int
=	O
0	int
;	O
plPoint	struct
p0	struct
;	O
double	O
sqdist	double
,	O
max_squared_length	double
;	O
if	O
(	O
path	pointer
==	O
(	O
plPath	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	pointer
->	O
type	enum
!=	O
PATH_SEGMENT_LIST	int
||	O
path	pointer
->	O
num_segments	int
==	O
0	int
)	O
return	O
;	O
p0	struct
=	O
path	pointer
->	O
segments	pointer
[	O
path	pointer
->	O
num_segments	int
-	O
1	int
]	O
.	O
p	struct
;	O
sqdist	double
=	O
(	O
p	struct
.	O
x	double
-	O
p0	struct
.	O
x	double
)	O
*	O
(	O
p	struct
.	O
x	double
-	O
p0	struct
.	O
x	double
)	O
+	O
(	O
p	struct
.	O
y	double
-	O
p0	struct
.	O
y	double
)	O
*	O
(	O
p	struct
.	O
y	double
-	O
p0	struct
.	O
y	double
)	O
;	O
max_squared_length	double
=	O
REL_QUAD_FLATNESS	int
*	O
REL_QUAD_FLATNESS	int
*	O
sqdist	double
;	O
r0	array
[	O
0	int
]	O
=	O
p0	struct
;	O
r1	array
[	O
0	int
]	O
=	O
pc	struct
;	O
r2	array
[	O
0	int
]	O
=	O
p	struct
;	O
level	int
[	O
0	int
]	O
=	O
0	int
;	O
while	O
(	O
n	array
>=	O
0	int
)	O
{	O
int	O
current_level	int
;	O
plPoint	struct
q0	struct
,	O
q1	struct
,	O
q2	struct
;	O
current_level	int
=	O
level	int
[	O
n	array
]	O
;	O
q0	struct
=	O
r0	array
[	O
n	array
]	O
;	O
q1	struct
=	O
r1	array
[	O
n	array
]	O
;	O
q2	struct
=	O
r2	array
[	O
n	array
]	O
;	O
if	O
(	O
current_level	int
>=	O
MAX_NUM_BEZIER2_SUBDIVISIONS	int
)	O
{	O
_add_line	function
(	O
path	pointer
,	O
q2	struct
)	O
;	O
segments_drawn	int
++	O
;	O
n	array
--	O
;	O
}	O
else	O
{	O
plPoint	struct
qq0	struct
,	O
qq1	struct
;	O
plPoint	struct
qqq0	struct
;	O
plVector	struct
vec1	struct
;	O
vec1	struct
.	O
x	double
=	O
q0	struct
.	O
x	double
-	O
2	int
*	O
q1	struct
.	O
x	double
+	O
q2	struct
.	O
x	double
;	O
vec1	struct
.	O
y	double
=	O
q0	struct
.	O
y	double
-	O
2	int
*	O
q1	struct
.	O
y	double
+	O
q2	struct
.	O
y	double
;	O
if	O
(	O
vec1	struct
.	O
x	double
*	O
vec1	struct
.	O
x	double
+	O
vec1	struct
.	O
y	double
*	O
vec1	struct
.	O
y	double
<	O
max_squared_length	double
)	O
{	O
_add_line	function
(	O
path	pointer
,	O
q2	struct
)	O
;	O
segments_drawn	int
++	O
;	O
n	array
--	O
;	O
}	O
else	O
{	O
qq0	struct
.	O
x	double
=	O
MIDWAY	O
(	O
q0	struct
.	O
x	double
,	O
q1	struct
.	O
x	double
)	O
;	O
qq0	struct
.	O
y	double
=	O
MIDWAY	O
(	O
q0	struct
.	O
y	double
,	O
q1	struct
.	O
y	double
)	O
;	O
qq1	struct
.	O
x	double
=	O
MIDWAY	O
(	O
q1	struct
.	O
x	double
,	O
q2	struct
.	O
x	double
)	O
;	O
qq1	struct
.	O
y	double
=	O
MIDWAY	O
(	O
q1	struct
.	O
y	double
,	O
q2	struct
.	O
y	double
)	O
;	O
qqq0	struct
.	O
x	double
=	O
MIDWAY	O
(	O
qq0	struct
.	O
x	double
,	O
qq1	struct
.	O
x	double
)	O
;	O
qqq0	struct
.	O
y	double
=	O
MIDWAY	O
(	O
qq0	struct
.	O
y	double
,	O
qq1	struct
.	O
y	double
)	O
;	O
r0	array
[	O
n	array
+	O
1	int
]	O
=	O
q0	struct
;	O
r1	array
[	O
n	array
+	O
1	int
]	O
=	O
qq0	struct
;	O
r2	array
[	O
n	array
+	O
1	int
]	O
=	O
qqq0	struct
;	O
level	int
[	O
n	array
+	O
1	int
]	O
=	O
current_level	int
+	O
1	int
;	O
r0	array
[	O
n	array
]	O
=	O
qqq0	struct
;	O
r1	array
[	O
n	array
]	O
=	O
qq1	struct
;	O
r2	array
[	O
n	array
]	O
=	O
q2	struct
;	O
level	int
[	O
n	array
]	O
=	O
current_level	int
+	O
1	int
;	O
n	array
++	O
;	O
}	O
}	O
}	O
}	O
void	O
_add_bezier3_as_lines	function
(	O
plPath	struct
*	O
path	pointer
,	O
plPoint	struct
pc	struct
,	O
plPoint	struct
pd	struct
,	O
plPoint	struct
p	struct
)	O
{	O
plPoint	struct
r0	array
[	O
MAX_NUM_BEZIER3_SUBDIVISIONS	int
+	O
1	int
]	O
,	O
r1	array
[	O
MAX_NUM_BEZIER3_SUBDIVISIONS	int
+	O
1	int
]	O
,	O
r2	array
[	O
MAX_NUM_BEZIER3_SUBDIVISIONS	int
+	O
1	int
]	O
,	O
r3	array
[	O
MAX_NUM_BEZIER3_SUBDIVISIONS	int
+	O
1	int
]	O
;	O
int	O
level	int
[	O
MAX_NUM_BEZIER3_SUBDIVISIONS	int
+	O
1	int
]	O
;	O
int	O
n	array
=	O
0	int
;	O
int	O
segments_drawn	int
=	O
0	int
;	O
plPoint	struct
p0	struct
;	O
double	O
sqdist	double
,	O
max_squared_length	double
;	O
if	O
(	O
path	pointer
==	O
(	O
plPath	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	pointer
->	O
type	enum
!=	O
PATH_SEGMENT_LIST	int
||	O
path	pointer
->	O
num_segments	int
==	O
0	int
)	O
return	O
;	O
p0	struct
=	O
path	pointer
->	O
segments	pointer
[	O
path	pointer
->	O
num_segments	int
-	O
1	int
]	O
.	O
p	struct
;	O
sqdist	double
=	O
(	O
p	struct
.	O
x	double
-	O
p0	struct
.	O
x	double
)	O
*	O
(	O
p	struct
.	O
x	double
-	O
p0	struct
.	O
x	double
)	O
+	O
(	O
p	struct
.	O
y	double
-	O
p0	struct
.	O
y	double
)	O
*	O
(	O
p	struct
.	O
y	double
-	O
p0	struct
.	O
y	double
)	O
;	O
max_squared_length	double
=	O
REL_CUBIC_FLATNESS	int
*	O
REL_CUBIC_FLATNESS	int
*	O
sqdist	double
;	O
r0	array
[	O
0	int
]	O
=	O
p0	struct
;	O
r1	array
[	O
0	int
]	O
=	O
pc	struct
;	O
r2	array
[	O
0	int
]	O
=	O
pd	struct
;	O
r3	array
[	O
0	int
]	O
=	O
p	struct
;	O
level	int
[	O
0	int
]	O
=	O
0	int
;	O
while	O
(	O
n	array
>=	O
0	int
)	O
{	O
int	O
current_level	int
;	O
plPoint	struct
q0	struct
,	O
q1	struct
,	O
q2	struct
,	O
q3	struct
;	O
current_level	int
=	O
level	int
[	O
n	array
]	O
;	O
q0	struct
=	O
r0	array
[	O
n	array
]	O
;	O
q1	struct
=	O
r1	array
[	O
n	array
]	O
;	O
q2	struct
=	O
r2	array
[	O
n	array
]	O
;	O
q3	struct
=	O
r3	array
[	O
n	array
]	O
;	O
if	O
(	O
current_level	int
>=	O
MAX_NUM_BEZIER3_SUBDIVISIONS	int
)	O
{	O
_add_line	function
(	O
path	pointer
,	O
q3	struct
)	O
;	O
segments_drawn	int
++	O
;	O
n	array
--	O
;	O
}	O
else	O
{	O
plPoint	struct
qq0	struct
,	O
qq1	struct
,	O
qq2	struct
;	O
plPoint	struct
qqq0	struct
,	O
qqq1	struct
;	O
plPoint	struct
qqqq0	struct
;	O
plVector	struct
vec1	struct
,	O
vec2	struct
;	O
vec1	struct
.	O
x	double
=	O
q0	struct
.	O
x	double
-	O
2	int
*	O
q1	struct
.	O
x	double
+	O
q2	struct
.	O
x	double
;	O
vec1	struct
.	O
y	double
=	O
q0	struct
.	O
y	double
-	O
2	int
*	O
q1	struct
.	O
y	double
+	O
q2	struct
.	O
y	double
;	O
vec2	struct
.	O
x	double
=	O
q1	struct
.	O
x	double
-	O
2	int
*	O
q2	struct
.	O
x	double
+	O
q3	struct
.	O
x	double
;	O
vec2	struct
.	O
y	double
=	O
q1	struct
.	O
y	double
-	O
2	int
*	O
q2	struct
.	O
y	double
+	O
q3	struct
.	O
y	double
;	O
if	O
(	O
vec1	struct
.	O
x	double
*	O
vec1	struct
.	O
x	double
+	O
vec1	struct
.	O
y	double
*	O
vec1	struct
.	O
y	double
<	O
max_squared_length	double
&&	O
vec2	struct
.	O
x	double
*	O
vec2	struct
.	O
x	double
+	O
vec2	struct
.	O
y	double
*	O
vec2	struct
.	O
y	double
<	O
max_squared_length	double
)	O
{	O
_add_line	function
(	O
path	pointer
,	O
q3	struct
)	O
;	O
segments_drawn	int
++	O
;	O
n	array
--	O
;	O
}	O
else	O
{	O
qq0	struct
.	O
x	double
=	O
MIDWAY	O
(	O
q0	struct
.	O
x	double
,	O
q1	struct
.	O
x	double
)	O
;	O
qq0	struct
.	O
y	double
=	O
MIDWAY	O
(	O
q0	struct
.	O
y	double
,	O
q1	struct
.	O
y	double
)	O
;	O
qq1	struct
.	O
x	double
=	O
MIDWAY	O
(	O
q1	struct
.	O
x	double
,	O
q2	struct
.	O
x	double
)	O
;	O
qq1	struct
.	O
y	double
=	O
MIDWAY	O
(	O
q1	struct
.	O
y	double
,	O
q2	struct
.	O
y	double
)	O
;	O
qq2	struct
.	O
x	double
=	O
MIDWAY	O
(	O
q2	struct
.	O
x	double
,	O
q3	struct
.	O
x	double
)	O
;	O
qq2	struct
.	O
y	double
=	O
MIDWAY	O
(	O
q2	struct
.	O
y	double
,	O
q3	struct
.	O
y	double
)	O
;	O
qqq0	struct
.	O
x	double
=	O
MIDWAY	O
(	O
qq0	struct
.	O
x	double
,	O
qq1	struct
.	O
x	double
)	O
;	O
qqq0	struct
.	O
y	double
=	O
MIDWAY	O
(	O
qq0	struct
.	O
y	double
,	O
qq1	struct
.	O
y	double
)	O
;	O
qqq1	struct
.	O
x	double
=	O
MIDWAY	O
(	O
qq1	struct
.	O
x	double
,	O
qq2	struct
.	O
x	double
)	O
;	O
qqq1	struct
.	O
y	double
=	O
MIDWAY	O
(	O
qq1	struct
.	O
y	double
,	O
qq2	struct
.	O
y	double
)	O
;	O
qqqq0	struct
.	O
x	double
=	O
MIDWAY	O
(	O
qqq0	struct
.	O
x	double
,	O
qqq1	struct
.	O
x	double
)	O
;	O
qqqq0	struct
.	O
y	double
=	O
MIDWAY	O
(	O
qqq0	struct
.	O
y	double
,	O
qqq1	struct
.	O
y	double
)	O
;	O
level	int
[	O
n	array
+	O
1	int
]	O
=	O
current_level	int
+	O
1	int
;	O
r0	array
[	O
n	array
+	O
1	int
]	O
=	O
q0	struct
;	O
r1	array
[	O
n	array
+	O
1	int
]	O
=	O
qq0	struct
;	O
r2	array
[	O
n	array
+	O
1	int
]	O
=	O
qqq0	struct
;	O
r3	array
[	O
n	array
+	O
1	int
]	O
=	O
qqqq0	struct
;	O
level	int
[	O
n	array
]	O
=	O
current_level	int
+	O
1	int
;	O
r0	array
[	O
n	array
]	O
=	O
qqqq0	struct
;	O
r1	array
[	O
n	array
]	O
=	O
qqq1	struct
;	O
r2	array
[	O
n	array
]	O
=	O
qq2	struct
;	O
r3	array
[	O
n	array
]	O
=	O
q3	struct
;	O
n	array
++	O
;	O
}	O
}	O
}	O
}	O
void	O
_add_box_as_lines	function
(	O
plPath	struct
*	O
path	pointer
,	O
plPoint	struct
p0	struct
,	O
plPoint	struct
p1	struct
,	O
bool	enum
clockwise	enum
)	O
{	O
bool	enum
x_move_is_first	enum
;	O
plPoint	struct
newpoint	struct
;	O
if	O
(	O
path	pointer
==	O
(	O
plPath	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	pointer
->	O
type	enum
!=	O
PATH_SEGMENT_LIST	int
||	O
path	pointer
->	O
num_segments	int
>	O
0	int
)	O
return	O
;	O
_add_moveto	function
(	O
path	pointer
,	O
p0	struct
)	O
;	O
x_move_is_first	enum
=	O
(	O
(	O
p1	struct
.	O
x	double
>=	O
p0	struct
.	O
x	double
&&	O
p1	struct
.	O
y	double
>=	O
p0	struct
.	O
y	double
)	O
||	O
(	O
p1	struct
.	O
x	double
<	O
p0	struct
.	O
x	double
&&	O
p1	struct
.	O
y	double
<	O
p0	struct
.	O
y	double
)	O
?	O
true	int
:	O
false	int
)	O
;	O
if	O
(	O
clockwise	enum
)	O
x_move_is_first	enum
=	O
(	O
x_move_is_first	enum
==	O
true	int
?	O
false	int
:	O
true	int
)	O
;	O
if	O
(	O
x_move_is_first	enum
)	O
{	O
newpoint	struct
.	O
x	double
=	O
p1	struct
.	O
x	double
;	O
newpoint	struct
.	O
y	double
=	O
p0	struct
.	O
y	double
;	O
}	O
else	O
{	O
newpoint	struct
.	O
x	double
=	O
p0	struct
.	O
x	double
;	O
newpoint	struct
.	O
y	double
=	O
p1	struct
.	O
y	double
;	O
}	O
_add_line	function
(	O
path	pointer
,	O
newpoint	struct
)	O
;	O
_add_line	function
(	O
path	pointer
,	O
p1	struct
)	O
;	O
if	O
(	O
x_move_is_first	enum
)	O
{	O
newpoint	struct
.	O
x	double
=	O
p0	struct
.	O
x	double
;	O
newpoint	struct
.	O
y	double
=	O
p1	struct
.	O
y	double
;	O
}	O
else	O
{	O
newpoint	struct
.	O
x	double
=	O
p1	struct
.	O
x	double
;	O
newpoint	struct
.	O
y	double
=	O
p0	struct
.	O
y	double
;	O
}	O
_add_line	function
(	O
path	pointer
,	O
newpoint	struct
)	O
;	O
_add_line	function
(	O
path	pointer
,	O
p0	struct
)	O
;	O
path	pointer
->	O
primitive	enum
=	O
true	int
;	O
}	O
void	O
_add_ellipse_as_bezier3s	function
(	O
plPath	struct
*	O
path	pointer
,	O
plPoint	struct
pc	struct
,	O
double	O
rx	double
,	O
double	O
ry	double
,	O
double	O
angle	double
,	O
bool	enum
clockwise	enum
)	O
{	O
plPoint	struct
startpoint	struct
,	O
newpoint	struct
;	O
double	O
theta	double
,	O
costheta	double
,	O
sintheta	double
;	O
double	O
xc	int
,	O
yc	int
;	O
if	O
(	O
path	pointer
==	O
(	O
plPath	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	pointer
->	O
type	enum
!=	O
PATH_SEGMENT_LIST	int
||	O
path	pointer
->	O
num_segments	int
>	O
0	int
)	O
return	O
;	O
theta	double
=	O
(	O
M_PI	int
/	O
180.0	int
)	O
*	O
angle	double
;	O
costheta	double
=	O
cos	function
(	O
theta	double
)	O
;	O
sintheta	double
=	O
sin	function
(	O
theta	double
)	O
;	O
xc	int
=	O
pc	struct
.	O
x	double
;	O
yc	int
=	O
pc	struct
.	O
y	double
;	O
startpoint	struct
.	O
x	double
=	O
xc	int
+	O
rx	double
*	O
costheta	double
;	O
startpoint	struct
.	O
y	double
=	O
yc	int
+	O
rx	double
*	O
sintheta	double
;	O
_add_moveto	function
(	O
path	pointer
,	O
startpoint	struct
)	O
;	O
if	O
(	O
clockwise	enum
)	O
{	O
newpoint	struct
.	O
x	double
=	O
xc	int
+	O
ry	double
*	O
sintheta	double
;	O
newpoint	struct
.	O
y	double
=	O
yc	int
-	O
ry	double
*	O
costheta	double
;	O
}	O
else	O
{	O
newpoint	struct
.	O
x	double
=	O
xc	int
-	O
ry	double
*	O
sintheta	double
;	O
newpoint	struct
.	O
y	double
=	O
yc	int
+	O
ry	double
*	O
costheta	double
;	O
}	O
_add_ellarc_as_bezier3	function
(	O
path	pointer
,	O
pc	struct
,	O
newpoint	struct
)	O
;	O
newpoint	struct
.	O
x	double
=	O
xc	int
-	O
rx	double
*	O
costheta	double
;	O
newpoint	struct
.	O
y	double
=	O
yc	int
-	O
rx	double
*	O
sintheta	double
;	O
_add_ellarc_as_bezier3	function
(	O
path	pointer
,	O
pc	struct
,	O
newpoint	struct
)	O
;	O
if	O
(	O
clockwise	enum
)	O
{	O
newpoint	struct
.	O
x	double
=	O
xc	int
-	O
ry	double
*	O
sintheta	double
;	O
newpoint	struct
.	O
y	double
=	O
yc	int
+	O
ry	double
*	O
costheta	double
;	O
}	O
else	O
{	O
newpoint	struct
.	O
x	double
=	O
xc	int
+	O
ry	double
*	O
sintheta	double
;	O
newpoint	struct
.	O
y	double
=	O
yc	int
-	O
ry	double
*	O
costheta	double
;	O
}	O
_add_ellarc_as_bezier3	function
(	O
path	pointer
,	O
pc	struct
,	O
newpoint	struct
)	O
;	O
_add_ellarc_as_bezier3	function
(	O
path	pointer
,	O
pc	struct
,	O
startpoint	struct
)	O
;	O
path	pointer
->	O
primitive	enum
=	O
true	int
;	O
}	O
void	O
_add_ellipse_as_ellarcs	function
(	O
plPath	struct
*	O
path	pointer
,	O
plPoint	struct
pc	struct
,	O
double	O
rx	double
,	O
double	O
ry	double
,	O
double	O
angle	double
,	O
bool	enum
clockwise	enum
)	O
{	O
plPoint	struct
startpoint	struct
,	O
newpoint	struct
;	O
double	O
theta	double
,	O
costheta	double
,	O
sintheta	double
;	O
double	O
xc	int
,	O
yc	int
;	O
if	O
(	O
path	pointer
==	O
(	O
plPath	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	pointer
->	O
type	enum
!=	O
PATH_SEGMENT_LIST	int
||	O
path	pointer
->	O
num_segments	int
>	O
0	int
)	O
return	O
;	O
theta	double
=	O
(	O
M_PI	int
/	O
180.0	int
)	O
*	O
angle	double
;	O
costheta	double
=	O
cos	function
(	O
theta	double
)	O
;	O
sintheta	double
=	O
sin	function
(	O
theta	double
)	O
;	O
xc	int
=	O
pc	struct
.	O
x	double
;	O
yc	int
=	O
pc	struct
.	O
y	double
;	O
startpoint	struct
.	O
x	double
=	O
xc	int
+	O
rx	double
*	O
costheta	double
;	O
startpoint	struct
.	O
y	double
=	O
yc	int
+	O
rx	double
*	O
sintheta	double
;	O
_add_moveto	function
(	O
path	pointer
,	O
startpoint	struct
)	O
;	O
if	O
(	O
clockwise	enum
)	O
{	O
newpoint	struct
.	O
x	double
=	O
xc	int
+	O
ry	double
*	O
sintheta	double
;	O
newpoint	struct
.	O
y	double
=	O
yc	int
-	O
ry	double
*	O
costheta	double
;	O
}	O
else	O
{	O
newpoint	struct
.	O
x	double
=	O
xc	int
-	O
ry	double
*	O
sintheta	double
;	O
newpoint	struct
.	O
y	double
=	O
yc	int
+	O
ry	double
*	O
costheta	double
;	O
}	O
_add_ellarc	function
(	O
path	pointer
,	O
pc	struct
,	O
newpoint	struct
)	O
;	O
newpoint	struct
.	O
x	double
=	O
xc	int
-	O
rx	double
*	O
costheta	double
;	O
newpoint	struct
.	O
y	double
=	O
yc	int
-	O
rx	double
*	O
sintheta	double
;	O
_add_ellarc	function
(	O
path	pointer
,	O
pc	struct
,	O
newpoint	struct
)	O
;	O
if	O
(	O
clockwise	enum
)	O
{	O
newpoint	struct
.	O
x	double
=	O
xc	int
-	O
ry	double
*	O
sintheta	double
;	O
newpoint	struct
.	O
y	double
=	O
yc	int
+	O
ry	double
*	O
costheta	double
;	O
}	O
else	O
{	O
newpoint	struct
.	O
x	double
=	O
xc	int
+	O
ry	double
*	O
sintheta	double
;	O
newpoint	struct
.	O
y	double
=	O
yc	int
-	O
ry	double
*	O
costheta	double
;	O
}	O
_add_ellarc	function
(	O
path	pointer
,	O
pc	struct
,	O
newpoint	struct
)	O
;	O
_add_ellarc	function
(	O
path	pointer
,	O
pc	struct
,	O
startpoint	struct
)	O
;	O
path	pointer
->	O
primitive	enum
=	O
true	int
;	O
}	O
void	O
_add_ellipse_as_lines	function
(	O
plPath	struct
*	O
path	pointer
,	O
plPoint	struct
pc	struct
,	O
double	O
rx	double
,	O
double	O
ry	double
,	O
double	O
angle	double
,	O
bool	enum
clockwise	enum
)	O
{	O
plPoint	struct
startpoint	struct
,	O
newpoint	struct
;	O
double	O
theta	double
,	O
costheta	double
,	O
sintheta	double
;	O
double	O
xc	int
,	O
yc	int
;	O
if	O
(	O
path	pointer
==	O
(	O
plPath	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	pointer
->	O
type	enum
!=	O
PATH_SEGMENT_LIST	int
||	O
path	pointer
->	O
num_segments	int
>	O
0	int
)	O
return	O
;	O
theta	double
=	O
(	O
M_PI	int
/	O
180.0	int
)	O
*	O
angle	double
;	O
costheta	double
=	O
cos	function
(	O
theta	double
)	O
;	O
sintheta	double
=	O
sin	function
(	O
theta	double
)	O
;	O
xc	int
=	O
pc	struct
.	O
x	double
;	O
yc	int
=	O
pc	struct
.	O
y	double
;	O
startpoint	struct
.	O
x	double
=	O
xc	int
+	O
rx	double
*	O
costheta	double
;	O
startpoint	struct
.	O
y	double
=	O
yc	int
+	O
rx	double
*	O
sintheta	double
;	O
_add_moveto	function
(	O
path	pointer
,	O
startpoint	struct
)	O
;	O
if	O
(	O
clockwise	enum
)	O
{	O
newpoint	struct
.	O
x	double
=	O
xc	int
+	O
ry	double
*	O
sintheta	double
;	O
newpoint	struct
.	O
y	double
=	O
yc	int
-	O
ry	double
*	O
costheta	double
;	O
}	O
else	O
{	O
newpoint	struct
.	O
x	double
=	O
xc	int
-	O
ry	double
*	O
sintheta	double
;	O
newpoint	struct
.	O
y	double
=	O
yc	int
+	O
ry	double
*	O
costheta	double
;	O
}	O
_add_ellarc_as_lines	function
(	O
path	pointer
,	O
pc	struct
,	O
newpoint	struct
)	O
;	O
newpoint	struct
.	O
x	double
=	O
xc	int
-	O
rx	double
*	O
costheta	double
;	O
newpoint	struct
.	O
y	double
=	O
yc	int
-	O
rx	double
*	O
sintheta	double
;	O
_add_ellarc_as_lines	function
(	O
path	pointer
,	O
pc	struct
,	O
newpoint	struct
)	O
;	O
if	O
(	O
clockwise	enum
)	O
{	O
newpoint	struct
.	O
x	double
=	O
xc	int
-	O
ry	double
*	O
sintheta	double
;	O
newpoint	struct
.	O
y	double
=	O
yc	int
+	O
ry	double
*	O
costheta	double
;	O
}	O
else	O
{	O
newpoint	struct
.	O
x	double
=	O
xc	int
+	O
ry	double
*	O
sintheta	double
;	O
newpoint	struct
.	O
y	double
=	O
yc	int
-	O
ry	double
*	O
costheta	double
;	O
}	O
_add_ellarc_as_lines	function
(	O
path	pointer
,	O
pc	struct
,	O
newpoint	struct
)	O
;	O
_add_ellarc_as_lines	function
(	O
path	pointer
,	O
pc	struct
,	O
startpoint	struct
)	O
;	O
path	pointer
->	O
primitive	enum
=	O
true	int
;	O
}	O
void	O
_add_circle_as_bezier3s	function
(	O
plPath	struct
*	O
path	pointer
,	O
plPoint	struct
pc	struct
,	O
double	O
radius	double
,	O
bool	enum
clockwise	enum
)	O
{	O
if	O
(	O
path	pointer
==	O
(	O
plPath	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
_add_ellipse_as_bezier3s	function
(	O
path	pointer
,	O
pc	struct
,	O
radius	double
,	O
radius	double
,	O
0.0	int
,	O
clockwise	enum
)	O
;	O
path	pointer
->	O
primitive	enum
=	O
true	int
;	O
}	O
void	O
_add_circle_as_ellarcs	function
(	O
plPath	struct
*	O
path	pointer
,	O
plPoint	struct
pc	struct
,	O
double	O
radius	double
,	O
bool	enum
clockwise	enum
)	O
{	O
if	O
(	O
path	pointer
==	O
(	O
plPath	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
_add_ellipse_as_ellarcs	function
(	O
path	pointer
,	O
pc	struct
,	O
radius	double
,	O
radius	double
,	O
0.0	int
,	O
clockwise	enum
)	O
;	O
path	pointer
->	O
primitive	enum
=	O
true	int
;	O
}	O
void	O
_add_circle_as_lines	function
(	O
plPath	struct
*	O
path	pointer
,	O
plPoint	struct
pc	struct
,	O
double	O
radius	double
,	O
bool	enum
clockwise	enum
)	O
{	O
if	O
(	O
path	pointer
==	O
(	O
plPath	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
_add_ellipse_as_lines	function
(	O
path	pointer
,	O
pc	struct
,	O
radius	double
,	O
radius	double
,	O
0.0	int
,	O
clockwise	enum
)	O
;	O
path	pointer
->	O
primitive	enum
=	O
true	int
;	O
}	O
static	O
void	O
_fakearc	function
(	O
plPath	struct
*	O
path	pointer
,	O
plPoint	struct
p0	struct
,	O
plPoint	struct
p1	struct
,	O
int	O
arc_type	int
,	O
const	O
double	O
*	O
custom_chord_table	array
,	O
const	O
double	O
m	array
[	O
4	int
]	O
)	O
{	O
plPoint	struct
p	struct
[	O
NUM_ARC_SUBDIVISIONS	int
+	O
1	int
]	O
,	O
q	array
[	O
NUM_ARC_SUBDIVISIONS	int
+	O
1	int
]	O
;	O
int	O
level	int
[	O
NUM_ARC_SUBDIVISIONS	int
+	O
1	int
]	O
;	O
int	O
n	array
=	O
0	int
;	O
int	O
segments_drawn	int
=	O
0	int
;	O
const	O
double	O
*	O
our_chord_table	pointer
;	O
if	O
(	O
arc_type	int
==	O
USER_DEFINED_ARC	O
)	O
our_chord_table	pointer
=	O
custom_chord_table	array
;	O
else	O
our_chord_table	pointer
=	O
_chord_table	array
[	O
arc_type	int
]	O
;	O
p	struct
[	O
0	int
]	O
=	O
p0	struct
;	O
q	array
[	O
0	int
]	O
=	O
p1	struct
;	O
level	int
[	O
0	int
]	O
=	O
0	int
;	O
while	O
(	O
n	array
>=	O
0	int
)	O
{	O
if	O
(	O
level	int
[	O
n	array
]	O
>=	O
NUM_ARC_SUBDIVISIONS	int
)	O
{	O
_add_line	function
(	O
path	pointer
,	O
q	array
[	O
n	array
]	O
)	O
;	O
segments_drawn	int
++	O
;	O
n	array
--	O
;	O
}	O
else	O
{	O
plVector	struct
v	pointer
;	O
plPoint	struct
pm	struct
,	O
pb	struct
;	O
v	pointer
.	O
x	double
=	O
q	array
[	O
n	array
]	O
.	O
x	double
-	O
p	struct
[	O
n	array
]	O
.	O
x	double
;	O
v	pointer
.	O
y	double
=	O
q	array
[	O
n	array
]	O
.	O
y	double
-	O
p	struct
[	O
n	array
]	O
.	O
y	double
;	O
pm	struct
.	O
x	double
=	O
p	struct
[	O
n	array
]	O
.	O
x	double
+	O
0.5	int
*	O
v	pointer
.	O
x	double
;	O
pm	struct
.	O
y	double
=	O
p	struct
[	O
n	array
]	O
.	O
y	double
+	O
0.5	int
*	O
v	pointer
.	O
y	double
;	O
pb	struct
.	O
x	double
=	O
pm	struct
.	O
x	double
+	O
our_chord_table	pointer
[	O
level	int
[	O
n	array
]	O
]	O
*	O
(	O
m	array
[	O
0	int
]	O
*	O
v	pointer
.	O
x	double
+	O
m	array
[	O
1	int
]	O
*	O
v	pointer
.	O
y	double
)	O
;	O
pb	struct
.	O
y	double
=	O
pm	struct
.	O
y	double
+	O
our_chord_table	pointer
[	O
level	int
[	O
n	array
]	O
]	O
*	O
(	O
m	array
[	O
2	int
]	O
*	O
v	pointer
.	O
x	double
+	O
m	array
[	O
3	int
]	O
*	O
v	pointer
.	O
y	double
)	O
;	O
p	struct
[	O
n	array
+	O
1	int
]	O
=	O
p	struct
[	O
n	array
]	O
;	O
q	array
[	O
n	array
+	O
1	int
]	O
=	O
pb	struct
;	O
level	int
[	O
n	array
+	O
1	int
]	O
=	O
level	int
[	O
n	array
]	O
+	O
1	int
;	O
p	struct
[	O
n	array
]	O
=	O
pb	struct
;	O
q	array
[	O
n	array
]	O
=	O
q	array
[	O
n	array
]	O
;	O
level	int
[	O
n	array
]	O
=	O
level	int
[	O
n	array
]	O
+	O
1	int
;	O
n	array
++	O
;	O
}	O
}	O
}	O
static	O
void	O
_prepare_chord_table	function
(	O
double	O
sagitta	double
,	O
double	O
custom_chord_table	array
[	O
TABULATED_ARC_SUBDIVISIONS	int
]	O
)	O
{	O
double	O
half_chord_length	double
;	O
int	O
i	int
;	O
half_chord_length	double
=	O
sqrt	function
(	O
sagitta	double
*	O
(	O
2.0	int
-	O
sagitta	double
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
TABULATED_ARC_SUBDIVISIONS	int
;	O
i	int
++	O
)	O
{	O
custom_chord_table	array
[	O
i	int
]	O
=	O
0.5	int
*	O
sagitta	double
/	O
half_chord_length	double
;	O
sagitta	double
=	O
1.0	int
-	O
sqrt	function
(	O
1.0	int
-	O
0.5	int
*	O
sagitta	double
)	O
;	O
half_chord_length	double
=	O
0.5	int
*	O
half_chord_length	double
/	O
(	O
1.0	int
-	O
sagitta	double
)	O
;	O
}	O
}	O
plPath	struct
*	O
_flatten_path	function
(	O
const	O
plPath	struct
*	O
path	pointer
)	O
{	O
plPath	struct
*	O
newpath	pointer
;	O
if	O
(	O
path	pointer
==	O
(	O
plPath	struct
*	O
)	O
NULL	O
)	O
return	O
(	O
plPath	struct
*	O
)	O
NULL	O
;	O
switch	O
(	O
path	pointer
->	O
type	enum
)	O
{	O
case	O
PATH_SEGMENT_LIST	int
:	O
{	O
bool	enum
do_flatten	enum
=	O
false	int
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
path	pointer
->	O
num_segments	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
path	pointer
->	O
segments	pointer
[	O
i	int
]	O
.	O
type	enum
!=	O
S_MOVETO	int
&&	O
path	pointer
->	O
segments	pointer
[	O
i	int
]	O
.	O
type	enum
!=	O
S_LINE	int
&&	O
path	pointer
->	O
segments	pointer
[	O
i	int
]	O
.	O
type	enum
!=	O
S_CLOSEPATH	int
)	O
{	O
do_flatten	enum
=	O
true	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
do_flatten	enum
==	O
false	int
)	O
newpath	pointer
=	O
(	O
plPath	struct
*	O
)	O
path	pointer
;	O
else	O
{	O
newpath	pointer
=	O
_new_plPath	function
(	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
path	pointer
->	O
num_segments	int
;	O
i	int
++	O
)	O
{	O
switch	O
(	O
(	O
int	O
)	O
(	O
path	pointer
->	O
segments	pointer
[	O
i	int
]	O
.	O
type	enum
)	O
)	O
{	O
case	O
(	O
int	O
)	O
S_MOVETO	int
:	O
_add_moveto	function
(	O
newpath	pointer
,	O
path	pointer
->	O
segments	pointer
[	O
i	int
]	O
.	O
p	struct
)	O
;	O
break	O
;	O
case	O
(	O
int	O
)	O
S_LINE	int
:	O
_add_line	function
(	O
newpath	pointer
,	O
path	pointer
->	O
segments	pointer
[	O
i	int
]	O
.	O
p	struct
)	O
;	O
break	O
;	O
case	O
(	O
int	O
)	O
S_CLOSEPATH	int
:	O
_add_closepath	function
(	O
newpath	pointer
)	O
;	O
break	O
;	O
case	O
(	O
int	O
)	O
S_ARC	int
:	O
_add_arc_as_lines	function
(	O
newpath	pointer
,	O
path	pointer
->	O
segments	pointer
[	O
i	int
]	O
.	O
pc	struct
,	O
path	pointer
->	O
segments	pointer
[	O
i	int
]	O
.	O
p	struct
)	O
;	O
break	O
;	O
case	O
(	O
int	O
)	O
S_ELLARC	int
:	O
_add_ellarc_as_lines	function
(	O
newpath	pointer
,	O
path	pointer
->	O
segments	pointer
[	O
i	int
]	O
.	O
pc	struct
,	O
path	pointer
->	O
segments	pointer
[	O
i	int
]	O
.	O
p	struct
)	O
;	O
break	O
;	O
case	O
(	O
int	O
)	O
S_QUAD	int
:	O
_add_bezier2_as_lines	function
(	O
newpath	pointer
,	O
path	pointer
->	O
segments	pointer
[	O
i	int
]	O
.	O
pc	struct
,	O
path	pointer
->	O
segments	pointer
[	O
i	int
]	O
.	O
p	struct
)	O
;	O
break	O
;	O
case	O
(	O
int	O
)	O
S_CUBIC	int
:	O
_add_bezier3_as_lines	function
(	O
newpath	pointer
,	O
path	pointer
->	O
segments	pointer
[	O
i	int
]	O
.	O
pc	struct
,	O
path	pointer
->	O
segments	pointer
[	O
i	int
]	O
.	O
pd	struct
,	O
path	pointer
->	O
segments	pointer
[	O
i	int
]	O
.	O
p	struct
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
}	O
break	O
;	O
}	O
case	O
PATH_CIRCLE	int
:	O
newpath	pointer
=	O
_new_plPath	function
(	O
)	O
;	O
_add_circle_as_lines	function
(	O
newpath	pointer
,	O
path	pointer
->	O
pc	struct
,	O
path	pointer
->	O
radius	double
,	O
path	pointer
->	O
clockwise	enum
)	O
;	O
break	O
;	O
case	O
PATH_ELLIPSE	int
:	O
newpath	pointer
=	O
_new_plPath	function
(	O
)	O
;	O
_add_ellipse_as_lines	function
(	O
newpath	pointer
,	O
path	pointer
->	O
pc	struct
,	O
path	pointer
->	O
rx	double
,	O
path	pointer
->	O
ry	double
,	O
path	pointer
->	O
angle	double
,	O
path	pointer
->	O
clockwise	enum
)	O
;	O
break	O
;	O
case	O
PATH_BOX	int
:	O
newpath	pointer
=	O
_new_plPath	function
(	O
)	O
;	O
_add_box_as_lines	function
(	O
newpath	pointer
,	O
path	pointer
->	O
p0	struct
,	O
path	pointer
->	O
p1	struct
,	O
path	pointer
->	O
clockwise	enum
)	O
;	O
break	O
;	O
default	O
:	O
newpath	pointer
=	O
_new_plPath	function
(	O
)	O
;	O
break	O
;	O
}	O
return	O
newpath	pointer
;	O
}	O
typedef	O
struct	O
subpath_struct	struct
{	O
plPathSegment	struct
*	O
segments	pointer
;	O
int	O
num_segments	int
;	O
struct	O
subpath_struct	struct
*	O
*	O
parents	pointer
;	O
struct	O
subpath_struct	struct
*	O
parent	pointer
;	O
struct	O
subpath_struct	struct
*	O
*	O
children	pointer
;	O
int	O
num_children	int
;	O
int	O
num_outside	int
;	O
double	O
llx	double
,	O
lly	double
,	O
urx	double
,	O
ury	double
;	O
bool	enum
inserted	enum
;	O
}	O
subpath	struct
;	O
static	O
subpath	struct
*	O
new_subpath	function
(	O
void	O
)	O
;	O
static	O
subpath	struct
*	O
*	O
new_subpath_array	function
(	O
int	O
n	array
)	O
;	O
static	O
void	O
delete_subpath	function
(	O
subpath	struct
*	O
s	pointer
)	O
;	O
static	O
void	O
delete_subpath_array	function
(	O
subpath	struct
*	O
*	O
s	pointer
,	O
int	O
n	array
)	O
;	O
static	O
bool	enum
is_inside_of	function
(	O
const	O
subpath	struct
*	O
s	pointer
,	O
const	O
subpath	struct
*	O
other	pointer
)	O
;	O
static	O
double	O
_cheap_lower_bound_on_distance	function
(	O
const	O
subpath	struct
*	O
path1	pointer
,	O
const	O
subpath	struct
*	O
path2	pointer
)	O
;	O
static	O
void	O
linearize_subpath	function
(	O
subpath	struct
*	O
s	pointer
)	O
;	O
static	O
void	O
read_into_subpath	function
(	O
subpath	struct
*	O
s	pointer
,	O
const	O
plPath	struct
*	O
path	pointer
)	O
;	O
static	O
void	O
find_parents_in_subpath_list	function
(	O
subpath	struct
*	O
*	O
annotated_paths	pointer
,	O
int	O
num_paths	int
)	O
;	O
static	O
void	O
insert_subpath	function
(	O
plPathSegment	struct
*	O
parent_segments	pointer
,	O
const	O
plPathSegment	struct
*	O
child_segments	pointer
,	O
int	O
parent_size	int
,	O
int	O
child_size	int
,	O
int	O
parent_index	int
,	O
int	O
child_index	int
)	O
;	O
static	O
void	O
_compute_closest	function
(	O
const	O
plPathSegment	struct
*	O
p1	struct
,	O
const	O
plPathSegment	struct
*	O
p2	pointer
,	O
int	O
size1	int
,	O
int	O
size2	int
,	O
double	O
*	O
distance	pointer
,	O
int	O
*	O
index1	pointer
,	O
int	O
*	O
index2	pointer
)	O
;	O
static	O
subpath	struct
*	O
new_subpath	function
(	O
void	O
)	O
{	O
subpath	struct
*	O
s	pointer
;	O
s	pointer
=	O
(	O
subpath	struct
*	O
)	O
_pl_xmalloc	function
(	O
sizeof	O
(	O
subpath	struct
)	O
)	O
;	O
s	pointer
->	O
segments	pointer
=	O
(	O
plPathSegment	struct
*	O
)	O
NULL	O
;	O
s	pointer
->	O
num_segments	int
=	O
0	int
;	O
s	pointer
->	O
parents	pointer
=	O
(	O
subpath	struct
*	O
*	O
)	O
NULL	O
;	O
s	pointer
->	O
parent	pointer
=	O
(	O
subpath	struct
*	O
)	O
NULL	O
;	O
s	pointer
->	O
children	pointer
=	O
(	O
subpath	struct
*	O
*	O
)	O
NULL	O
;	O
s	pointer
->	O
num_children	int
=	O
0	int
;	O
s	pointer
->	O
num_outside	int
=	O
0	int
;	O
s	pointer
->	O
llx	double
=	O
DBL_MAX	O
;	O
s	pointer
->	O
lly	double
=	O
DBL_MAX	O
;	O
s	pointer
->	O
urx	double
=	O
-	O
DBL_MAX	O
;	O
s	pointer
->	O
ury	double
=	O
-	O
DBL_MAX	O
;	O
s	pointer
->	O
inserted	enum
=	O
false	int
;	O
return	O
s	pointer
;	O
}	O
static	O
subpath	struct
*	O
*	O
new_subpath_array	function
(	O
int	O
n	array
)	O
{	O
int	O
i	int
;	O
subpath	struct
*	O
*	O
s	pointer
;	O
s	pointer
=	O
(	O
subpath	struct
*	O
*	O
)	O
_pl_xmalloc	function
(	O
n	array
*	O
sizeof	O
(	O
subpath	struct
*	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	array
;	O
i	int
++	O
)	O
s	pointer
[	O
i	int
]	O
=	O
new_subpath	function
(	O
)	O
;	O
return	O
s	pointer
;	O
}	O
static	O
void	O
delete_subpath	function
(	O
subpath	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
s	pointer
)	O
{	O
if	O
(	O
s	pointer
->	O
segments	pointer
)	O
free	function
(	O
s	pointer
->	O
segments	pointer
)	O
;	O
if	O
(	O
s	pointer
->	O
children	pointer
)	O
free	function
(	O
s	pointer
->	O
children	pointer
)	O
;	O
if	O
(	O
s	pointer
->	O
parents	pointer
)	O
free	function
(	O
s	pointer
->	O
parents	pointer
)	O
;	O
free	function
(	O
s	pointer
)	O
;	O
}	O
}	O
static	O
void	O
delete_subpath_array	function
(	O
subpath	struct
*	O
*	O
s	pointer
,	O
int	O
n	array
)	O
{	O
int	O
i	int
;	O
if	O
(	O
s	pointer
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	array
;	O
i	int
++	O
)	O
delete_subpath	function
(	O
s	pointer
[	O
i	int
]	O
)	O
;	O
free	function
(	O
s	pointer
)	O
;	O
}	O
}	O
static	O
void	O
linearize_subpath	function
(	O
subpath	struct
*	O
s	pointer
)	O
{	O
s	pointer
->	O
segments	pointer
[	O
0	int
]	O
.	O
type	enum
=	O
S_LINE	int
;	O
if	O
(	O
s	pointer
->	O
segments	pointer
[	O
s	pointer
->	O
num_segments	int
-	O
1	int
]	O
.	O
type	enum
==	O
S_CLOSEPATH	int
)	O
{	O
s	pointer
->	O
segments	pointer
[	O
s	pointer
->	O
num_segments	int
-	O
1	int
]	O
.	O
type	enum
=	O
S_LINE	int
;	O
s	pointer
->	O
segments	pointer
[	O
s	pointer
->	O
num_segments	int
-	O
1	int
]	O
.	O
p	struct
=	O
s	pointer
->	O
segments	pointer
[	O
0	int
]	O
.	O
p	struct
;	O
}	O
}	O
static	O
void	O
read_into_subpath	function
(	O
subpath	struct
*	O
s	pointer
,	O
const	O
plPath	struct
*	O
path	pointer
)	O
{	O
bool	enum
need_to_close	enum
=	O
false	int
;	O
int	O
i	int
;	O
if	O
(	O
path	pointer
->	O
type	enum
!=	O
PATH_SEGMENT_LIST	int
)	O
return	O
;	O
s	pointer
->	O
segments	pointer
=	O
(	O
plPathSegment	struct
*	O
)	O
_pl_xmalloc	function
(	O
(	O
path	pointer
->	O
num_segments	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
plPathSegment	struct
)	O
)	O
;	O
s	pointer
->	O
num_segments	int
=	O
path	pointer
->	O
num_segments	int
;	O
if	O
(	O
path	pointer
->	O
num_segments	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
path	pointer
->	O
segments	pointer
[	O
path	pointer
->	O
num_segments	int
-	O
1	int
]	O
.	O
type	enum
!=	O
S_CLOSEPATH	int
&&	O
(	O
path	pointer
->	O
segments	pointer
[	O
path	pointer
->	O
num_segments	int
-	O
1	int
]	O
.	O
p	struct
.	O
x	double
!=	O
path	pointer
->	O
segments	pointer
[	O
0	int
]	O
.	O
p	struct
.	O
x	double
||	O
path	pointer
->	O
segments	pointer
[	O
path	pointer
->	O
num_segments	int
-	O
1	int
]	O
.	O
p	struct
.	O
y	double
!=	O
path	pointer
->	O
segments	pointer
[	O
0	int
]	O
.	O
p	struct
.	O
y	double
)	O
)	O
need_to_close	enum
=	O
true	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
path	pointer
->	O
num_segments	int
;	O
i	int
++	O
)	O
{	O
plPathSegment	struct
e	struct
;	O
e	struct
=	O
path	pointer
->	O
segments	pointer
[	O
i	int
]	O
;	O
s	pointer
->	O
segments	pointer
[	O
i	int
]	O
=	O
e	struct
;	O
if	O
(	O
e	struct
.	O
p	struct
.	O
x	double
<	O
s	pointer
->	O
llx	double
)	O
s	pointer
->	O
llx	double
=	O
e	struct
.	O
p	struct
.	O
x	double
;	O
if	O
(	O
e	struct
.	O
p	struct
.	O
y	double
<	O
s	pointer
->	O
lly	double
)	O
s	pointer
->	O
lly	double
=	O
e	struct
.	O
p	struct
.	O
y	double
;	O
if	O
(	O
e	struct
.	O
p	struct
.	O
x	double
>	O
s	pointer
->	O
urx	double
)	O
s	pointer
->	O
urx	double
=	O
e	struct
.	O
p	struct
.	O
x	double
;	O
if	O
(	O
e	struct
.	O
p	struct
.	O
y	double
>	O
s	pointer
->	O
ury	double
)	O
s	pointer
->	O
ury	double
=	O
e	struct
.	O
p	struct
.	O
y	double
;	O
}	O
if	O
(	O
need_to_close	enum
)	O
{	O
s	pointer
->	O
segments	pointer
[	O
path	pointer
->	O
num_segments	int
]	O
.	O
type	enum
=	O
S_LINE	int
;	O
s	pointer
->	O
segments	pointer
[	O
path	pointer
->	O
num_segments	int
]	O
.	O
p	struct
=	O
path	pointer
->	O
segments	pointer
[	O
0	int
]	O
.	O
p	struct
;	O
s	pointer
->	O
num_segments	int
++	O
;	O
}	O
}	O
static	O
bool	enum
is_inside_of	function
(	O
const	O
subpath	struct
*	O
s	pointer
,	O
const	O
subpath	struct
*	O
other	pointer
)	O
{	O
int	O
inside	int
=	O
0	int
;	O
int	O
outside	int
=	O
0	int
;	O
int	O
i	int
;	O
if	O
(	O
!	O
(	O
(	O
s	pointer
->	O
llx	double
>=	O
other	pointer
->	O
llx	double
)	O
&&	O
(	O
s	pointer
->	O
lly	double
>=	O
other	pointer
->	O
lly	double
)	O
&&	O
(	O
s	pointer
->	O
urx	double
<=	O
other	pointer
->	O
urx	double
)	O
&&	O
(	O
s	pointer
->	O
ury	double
<=	O
other	pointer
->	O
ury	double
)	O
)	O
)	O
return	O
false	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
s	pointer
->	O
num_segments	int
;	O
i	int
++	O
)	O
{	O
bool	enum
point_is_inside	enum
;	O
if	O
(	O
s	pointer
->	O
segments	pointer
[	O
i	int
]	O
.	O
type	enum
==	O
S_CLOSEPATH	int
)	O
continue	O
;	O
{	O
plPoint	struct
p	struct
;	O
int	O
k	int
,	O
crossings	int
;	O
double	O
x1	double
,	O
y1	function
;	O
double	O
x2	double
,	O
y2	double
;	O
p	struct
=	O
s	pointer
->	O
segments	pointer
[	O
i	int
]	O
.	O
p	struct
;	O
x1	double
=	O
(	O
DMAX	O
(	O
p	struct
.	O
x	double
,	O
other	pointer
->	O
urx	double
)	O
+	O
SMALL_X_FACTOR	O
*	O
(	O
DMAX	O
(	O
p	struct
.	O
x	double
,	O
other	pointer
->	O
urx	double
)	O
-	O
DMIN	O
(	O
p	struct
.	O
x	double
,	O
other	pointer
->	O
llx	double
)	O
)	O
)	O
;	O
y1	function
=	O
(	O
DMAX	O
(	O
p	struct
.	O
y	double
,	O
other	pointer
->	O
ury	double
)	O
+	O
SMALL_Y_FACTOR	O
*	O
(	O
DMAX	O
(	O
p	struct
.	O
y	double
,	O
other	pointer
->	O
ury	double
)	O
-	O
DMIN	O
(	O
p	struct
.	O
y	double
,	O
other	pointer
->	O
lly	double
)	O
)	O
)	O
;	O
x2	double
=	O
p	struct
.	O
x	double
;	O
y2	double
=	O
p	struct
.	O
y	double
;	O
crossings	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
other	pointer
->	O
num_segments	int
;	O
k	int
++	O
)	O
{	O
int	O
j	int
;	O
double	O
x3	double
,	O
y3	double
,	O
x4	double
,	O
y4	double
,	O
det	double
,	O
det1	double
,	O
det2	double
;	O
if	O
(	O
other	pointer
->	O
segments	pointer
[	O
k	int
]	O
.	O
type	enum
==	O
S_CLOSEPATH	int
)	O
{	O
x3	double
=	O
other	pointer
->	O
segments	pointer
[	O
k	int
-	O
1	int
]	O
.	O
p	struct
.	O
x	double
;	O
y3	double
=	O
other	pointer
->	O
segments	pointer
[	O
k	int
-	O
1	int
]	O
.	O
p	struct
.	O
y	double
;	O
}	O
else	O
{	O
x3	double
=	O
other	pointer
->	O
segments	pointer
[	O
k	int
]	O
.	O
p	struct
.	O
x	double
;	O
y3	double
=	O
other	pointer
->	O
segments	pointer
[	O
k	int
]	O
.	O
p	struct
.	O
y	double
;	O
}	O
j	int
=	O
(	O
k	int
==	O
other	pointer
->	O
num_segments	int
-	O
1	int
?	O
0	int
:	O
k	int
+	O
1	int
)	O
;	O
if	O
(	O
other	pointer
->	O
segments	pointer
[	O
j	int
]	O
.	O
type	enum
==	O
S_CLOSEPATH	int
)	O
continue	O
;	O
x4	double
=	O
other	pointer
->	O
segments	pointer
[	O
j	int
]	O
.	O
p	struct
.	O
x	double
;	O
y4	double
=	O
other	pointer
->	O
segments	pointer
[	O
j	int
]	O
.	O
p	struct
.	O
y	double
;	O
det	double
=	O
(	O
x2	double
-	O
x1	double
)	O
*	O
(	O
-	O
(	O
y4	double
-	O
y3	double
)	O
)	O
-	O
(	O
-	O
(	O
x4	double
-	O
x3	double
)	O
)	O
*	O
(	O
y2	double
-	O
y1	function
)	O
;	O
if	O
(	O
det	double
==	O
0.0	int
)	O
continue	O
;	O
det1	double
=	O
(	O
x3	double
-	O
x1	double
)	O
*	O
(	O
-	O
(	O
y4	double
-	O
y3	double
)	O
)	O
-	O
(	O
-	O
(	O
x4	double
-	O
x3	double
)	O
)	O
*	O
(	O
y3	double
-	O
y1	function
)	O
;	O
det2	double
=	O
(	O
x2	double
-	O
x1	double
)	O
*	O
(	O
y3	double
-	O
y1	function
)	O
-	O
(	O
x3	double
-	O
x1	double
)	O
*	O
(	O
y2	double
-	O
y1	function
)	O
;	O
if	O
(	O
(	O
det	double
<	O
0.0	int
&&	O
(	O
det1	double
>	O
0.0	int
||	O
det2	double
>	O
0.0	int
||	O
det1	double
<	O
det	double
||	O
det2	double
<	O
det	double
)	O
)	O
||	O
(	O
det	double
>	O
0.0	int
&&	O
(	O
det1	double
<	O
0.0	int
||	O
det2	double
<	O
0.0	int
||	O
det1	double
>	O
det	double
||	O
det2	double
>	O
det	double
)	O
)	O
)	O
continue	O
;	O
crossings	int
++	O
;	O
}	O
point_is_inside	enum
=	O
(	O
crossings	int
&	O
1	int
)	O
?	O
true	int
:	O
false	int
;	O
}	O
if	O
(	O
point_is_inside	enum
)	O
inside	int
++	O
;	O
else	O
outside	int
++	O
;	O
}	O
return	O
(	O
inside	int
>	O
outside	int
?	O
true	int
:	O
false	int
)	O
;	O
}	O
static	O
void	O
find_parents_in_subpath_list	function
(	O
subpath	struct
*	O
*	O
annotated_paths	pointer
,	O
int	O
num_paths	int
)	O
{	O
int	O
i	int
,	O
j	int
;	O
subpath	struct
*	O
parent	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_paths	int
;	O
i	int
++	O
)	O
{	O
annotated_paths	pointer
[	O
i	int
]	O
->	O
parents	pointer
=	O
new_subpath_array	function
(	O
num_paths	int
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
num_paths	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
j	int
!=	O
i	int
)	O
{	O
if	O
(	O
is_inside_of	function
(	O
annotated_paths	pointer
[	O
i	int
]	O
,	O
annotated_paths	pointer
[	O
j	int
]	O
)	O
)	O
{	O
annotated_paths	pointer
[	O
i	int
]	O
->	O
parents	pointer
[	O
annotated_paths	pointer
[	O
i	int
]	O
->	O
num_outside	int
]	O
=	O
annotated_paths	pointer
[	O
j	int
]	O
;	O
annotated_paths	pointer
[	O
i	int
]	O
->	O
num_outside	int
++	O
;	O
}	O
}	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_paths	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
annotated_paths	pointer
[	O
i	int
]	O
->	O
num_outside	int
&	O
1	int
)	O
==	O
0	int
)	O
{	O
annotated_paths	pointer
[	O
i	int
]	O
->	O
children	pointer
=	O
new_subpath_array	function
(	O
num_paths	int
)	O
;	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_paths	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
annotated_paths	pointer
[	O
i	int
]	O
->	O
num_outside	int
&	O
1	int
)	O
==	O
0	int
)	O
continue	O
;	O
else	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
annotated_paths	pointer
[	O
i	int
]	O
->	O
num_outside	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
annotated_paths	pointer
[	O
i	int
]	O
->	O
num_outside	int
==	O
annotated_paths	pointer
[	O
i	int
]	O
->	O
parents	pointer
[	O
j	int
]	O
->	O
num_outside	int
+	O
1	int
)	O
{	O
parent	pointer
=	O
annotated_paths	pointer
[	O
i	int
]	O
->	O
parents	pointer
[	O
j	int
]	O
;	O
annotated_paths	pointer
[	O
i	int
]	O
->	O
parent	pointer
=	O
parent	pointer
;	O
parent	pointer
->	O
children	pointer
[	O
parent	pointer
->	O
num_children	int
]	O
=	O
annotated_paths	pointer
[	O
i	int
]	O
;	O
parent	pointer
->	O
num_children	int
++	O
;	O
break	O
;	O
}	O
}	O
}	O
}	O
}	O
static	O
void	O
_compute_closest	function
(	O
const	O
plPathSegment	struct
*	O
p1	struct
,	O
const	O
plPathSegment	struct
*	O
p2	pointer
,	O
int	O
size1	int
,	O
int	O
size2	int
,	O
double	O
*	O
distance	pointer
,	O
int	O
*	O
index1	pointer
,	O
int	O
*	O
index2	pointer
)	O
{	O
int	O
best_i	int
=	O
0	int
,	O
best_j	int
=	O
0	int
;	O
double	O
best_distance	double
=	O
DBL_MAX	O
;	O
int	O
ii	int
,	O
jj	int
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
size1	int
;	O
ii	int
++	O
)	O
{	O
plPoint	struct
point1	struct
;	O
point1	struct
=	O
p1	struct
[	O
ii	int
]	O
.	O
p	struct
;	O
for	O
(	O
jj	int
=	O
0	int
;	O
jj	int
<	O
size2	int
;	O
jj	int
++	O
)	O
{	O
double	O
tmp1	double
,	O
tmp2	double
,	O
distance	pointer
;	O
plPoint	struct
point2	struct
;	O
point2	struct
=	O
p2	pointer
[	O
jj	int
]	O
.	O
p	struct
;	O
tmp1	double
=	O
point1	struct
.	O
x	double
-	O
point2	struct
.	O
x	double
;	O
tmp2	double
=	O
point1	struct
.	O
y	double
-	O
point2	struct
.	O
y	double
;	O
distance	pointer
=	O
tmp1	double
*	O
tmp1	double
+	O
tmp2	double
*	O
tmp2	double
;	O
if	O
(	O
distance	pointer
<	O
best_distance	double
)	O
{	O
best_distance	double
=	O
distance	pointer
;	O
best_i	int
=	O
ii	int
;	O
best_j	int
=	O
jj	int
;	O
}	O
}	O
}	O
*	O
distance	pointer
=	O
best_distance	double
;	O
*	O
index1	pointer
=	O
best_i	int
;	O
*	O
index2	pointer
=	O
best_j	int
;	O
}	O
static	O
double	O
_cheap_lower_bound_on_distance	function
(	O
const	O
subpath	struct
*	O
path1	pointer
,	O
const	O
subpath	struct
*	O
path2	pointer
)	O
{	O
double	O
xdist	double
=	O
0.0	int
,	O
ydist	double
=	O
0.0	int
,	O
dist	double
;	O
if	O
(	O
path1	pointer
->	O
urx	double
<	O
path2	pointer
->	O
llx	double
)	O
xdist	double
=	O
path2	pointer
->	O
llx	double
-	O
path1	pointer
->	O
urx	double
;	O
else	O
if	O
(	O
path2	pointer
->	O
urx	double
<	O
path1	pointer
->	O
llx	double
)	O
xdist	double
=	O
path1	pointer
->	O
llx	double
-	O
path2	pointer
->	O
urx	double
;	O
if	O
(	O
path1	pointer
->	O
ury	double
<	O
path2	pointer
->	O
lly	double
)	O
ydist	double
=	O
path2	pointer
->	O
lly	double
-	O
path1	pointer
->	O
ury	double
;	O
else	O
if	O
(	O
path2	pointer
->	O
ury	double
<	O
path1	pointer
->	O
lly	double
)	O
ydist	double
=	O
path1	pointer
->	O
lly	double
-	O
path2	pointer
->	O
ury	double
;	O
dist	double
=	O
xdist	double
*	O
xdist	double
+	O
ydist	double
*	O
ydist	double
;	O
return	O
dist	double
;	O
}	O
static	O
void	O
insert_subpath	function
(	O
plPathSegment	struct
*	O
parent	pointer
,	O
const	O
plPathSegment	struct
*	O
child	pointer
,	O
int	O
parent_size	int
,	O
int	O
child_size	int
,	O
int	O
parent_index	int
,	O
int	O
child_index	int
)	O
{	O
int	O
i	int
;	O
plPathSegment	struct
e1	struct
,	O
e2	struct
;	O
int	O
src_index	int
;	O
if	O
(	O
child_index	int
==	O
child_size	int
-	O
1	int
)	O
child_index	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
parent_size	int
-	O
1	int
;	O
i	int
>=	O
parent_index	int
+	O
1	int
;	O
i	int
--	O
)	O
parent	pointer
[	O
i	int
+	O
child_size	int
+	O
1	int
]	O
=	O
parent	pointer
[	O
i	int
]	O
;	O
e1	struct
=	O
child	pointer
[	O
child_index	int
]	O
;	O
e1	struct
.	O
type	enum
=	O
S_LINE	int
;	O
parent	pointer
[	O
parent_index	int
+	O
1	int
]	O
=	O
e1	struct
;	O
src_index	int
=	O
child_index	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
child_size	int
-	O
1	int
;	O
i	int
++	O
)	O
{	O
src_index	int
++	O
;	O
if	O
(	O
src_index	int
==	O
child_size	int
-	O
1	int
)	O
src_index	int
=	O
0	int
;	O
parent	pointer
[	O
parent_index	int
+	O
2	int
+	O
i	int
]	O
=	O
child	pointer
[	O
src_index	int
]	O
;	O
}	O
e2	struct
=	O
parent	pointer
[	O
parent_index	int
]	O
;	O
e2	struct
.	O
type	enum
=	O
S_LINE	int
;	O
parent	pointer
[	O
parent_index	int
+	O
child_size	int
+	O
1	int
]	O
=	O
e2	struct
;	O
}	O
plPath	struct
*	O
*	O
_merge_paths	function
(	O
const	O
plPath	struct
*	O
*	O
paths	pointer
,	O
int	O
num_paths	int
)	O
{	O
int	O
i	int
;	O
subpath	struct
*	O
*	O
annotated_paths	pointer
;	O
plPath	struct
*	O
*	O
flattened_paths	pointer
;	O
plPath	struct
*	O
*	O
merged_paths	pointer
;	O
flattened_paths	pointer
=	O
(	O
plPath	struct
*	O
*	O
)	O
_pl_xmalloc	function
(	O
num_paths	int
*	O
sizeof	O
(	O
plPath	struct
*	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_paths	int
;	O
i	int
++	O
)	O
{	O
flattened_paths	pointer
[	O
i	int
]	O
=	O
_flatten_path	function
(	O
paths	pointer
[	O
i	int
]	O
)	O
;	O
}	O
annotated_paths	pointer
=	O
new_subpath_array	function
(	O
num_paths	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_paths	int
;	O
i	int
++	O
)	O
read_into_subpath	function
(	O
annotated_paths	pointer
[	O
i	int
]	O
,	O
flattened_paths	pointer
[	O
i	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_paths	int
;	O
i	int
++	O
)	O
if	O
(	O
flattened_paths	pointer
[	O
i	int
]	O
!=	O
paths	pointer
[	O
i	int
]	O
)	O
_delete_plPath	function
(	O
flattened_paths	pointer
[	O
i	int
]	O
)	O
;	O
find_parents_in_subpath_list	function
(	O
annotated_paths	pointer
,	O
num_paths	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_paths	int
;	O
i	int
++	O
)	O
if	O
(	O
annotated_paths	pointer
[	O
i	int
]	O
->	O
parent	pointer
!=	O
(	O
subpath	struct
*	O
)	O
NULL	O
)	O
linearize_subpath	function
(	O
annotated_paths	pointer
[	O
i	int
]	O
)	O
;	O
merged_paths	pointer
=	O
(	O
plPath	struct
*	O
*	O
)	O
_pl_xmalloc	function
(	O
num_paths	int
*	O
sizeof	O
(	O
plPath	struct
*	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_paths	int
;	O
i	int
++	O
)	O
{	O
int	O
j	int
,	O
k	int
,	O
num_segments_in_merged_path	int
;	O
subpath	struct
*	O
parent	pointer
;	O
plPath	struct
*	O
merged_path	pointer
;	O
double	O
*	O
parent_to_child_distances	pointer
;	O
int	O
*	O
child_best_indices	pointer
,	O
*	O
parent_best_indices	pointer
;	O
if	O
(	O
annotated_paths	pointer
[	O
i	int
]	O
->	O
parent	pointer
!=	O
(	O
subpath	struct
*	O
)	O
NULL	O
)	O
{	O
merged_paths	pointer
[	O
i	int
]	O
=	O
(	O
plPath	struct
*	O
)	O
NULL	O
;	O
continue	O
;	O
}	O
if	O
(	O
annotated_paths	pointer
[	O
i	int
]	O
->	O
num_children	int
==	O
0	int
)	O
{	O
merged_paths	pointer
[	O
i	int
]	O
=	O
(	O
plPath	struct
*	O
)	O
paths	pointer
[	O
i	int
]	O
;	O
continue	O
;	O
}	O
parent	pointer
=	O
annotated_paths	pointer
[	O
i	int
]	O
;	O
num_segments_in_merged_path	int
=	O
parent	pointer
->	O
num_segments	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
parent	pointer
->	O
num_children	int
;	O
j	int
++	O
)	O
num_segments_in_merged_path	int
+=	O
(	O
parent	pointer
->	O
children	pointer
[	O
j	int
]	O
->	O
num_segments	int
+	O
1	int
)	O
;	O
merged_path	pointer
=	O
_new_plPath	function
(	O
)	O
;	O
merged_path	pointer
->	O
segments	pointer
=	O
(	O
plPathSegment	struct
*	O
)	O
_pl_xmalloc	function
(	O
num_segments_in_merged_path	int
*	O
sizeof	O
(	O
plPathSegment	struct
)	O
)	O
;	O
merged_path	pointer
->	O
num_segments	int
=	O
0	int
;	O
merged_path	pointer
->	O
segments_len	int
=	O
num_segments_in_merged_path	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
parent	pointer
->	O
num_segments	int
;	O
j	int
++	O
)	O
merged_path	pointer
->	O
segments	pointer
[	O
j	int
]	O
=	O
parent	pointer
->	O
segments	pointer
[	O
j	int
]	O
;	O
merged_path	pointer
->	O
num_segments	int
=	O
parent	pointer
->	O
num_segments	int
;	O
parent_to_child_distances	pointer
=	O
(	O
double	O
*	O
)	O
_pl_xmalloc	function
(	O
parent	pointer
->	O
num_children	int
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
parent_best_indices	pointer
=	O
(	O
int	O
*	O
)	O
_pl_xmalloc	function
(	O
parent	pointer
->	O
num_children	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
child_best_indices	pointer
=	O
(	O
int	O
*	O
)	O
_pl_xmalloc	function
(	O
parent	pointer
->	O
num_children	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
parent	pointer
->	O
num_children	int
;	O
j	int
++	O
)	O
_compute_closest	function
(	O
parent	pointer
->	O
segments	pointer
,	O
parent	pointer
->	O
children	pointer
[	O
j	int
]	O
->	O
segments	pointer
,	O
parent	pointer
->	O
num_segments	int
,	O
parent	pointer
->	O
children	pointer
[	O
j	int
]	O
->	O
num_segments	int
,	O
&	O
(	O
parent_to_child_distances	pointer
[	O
j	int
]	O
)	O
,	O
&	O
(	O
parent_best_indices	pointer
[	O
j	int
]	O
)	O
,	O
&	O
(	O
child_best_indices	pointer
[	O
j	int
]	O
)	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
parent	pointer
->	O
num_children	int
;	O
k	int
++	O
)	O
{	O
double	O
min_distance	double
;	O
int	O
closest	int
=	O
0	int
;	O
double	O
*	O
new_parent_to_child_distances	pointer
;	O
int	O
*	O
new_child_best_indices	pointer
,	O
*	O
new_parent_best_indices	pointer
;	O
new_parent_to_child_distances	pointer
=	O
(	O
double	O
*	O
)	O
_pl_xmalloc	function
(	O
parent	pointer
->	O
num_children	int
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
new_parent_best_indices	pointer
=	O
(	O
int	O
*	O
)	O
_pl_xmalloc	function
(	O
parent	pointer
->	O
num_children	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
new_child_best_indices	pointer
=	O
(	O
int	O
*	O
)	O
_pl_xmalloc	function
(	O
parent	pointer
->	O
num_children	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
parent	pointer
->	O
num_children	int
;	O
j	int
++	O
)	O
{	O
new_parent_to_child_distances	pointer
[	O
j	int
]	O
=	O
parent_to_child_distances	pointer
[	O
j	int
]	O
;	O
new_parent_best_indices	pointer
[	O
j	int
]	O
=	O
parent_best_indices	pointer
[	O
j	int
]	O
;	O
new_child_best_indices	pointer
[	O
j	int
]	O
=	O
child_best_indices	pointer
[	O
j	int
]	O
;	O
}	O
min_distance	double
=	O
DBL_MAX	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
parent	pointer
->	O
num_children	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
parent	pointer
->	O
children	pointer
[	O
j	int
]	O
->	O
inserted	enum
)	O
continue	O
;	O
if	O
(	O
parent_to_child_distances	pointer
[	O
j	int
]	O
<	O
min_distance	double
)	O
{	O
closest	int
=	O
j	int
;	O
min_distance	double
=	O
parent_to_child_distances	pointer
[	O
j	int
]	O
;	O
}	O
}	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
parent	pointer
->	O
num_children	int
;	O
j	int
++	O
)	O
{	O
double	O
inter_child_distance	double
;	O
int	O
inter_child_best_index1	int
,	O
inter_child_best_index2	int
;	O
double	O
lower_bound_on_inter_child_distance	double
;	O
bool	enum
compute_carefully	enum
;	O
if	O
(	O
parent	pointer
->	O
children	pointer
[	O
j	int
]	O
->	O
inserted	enum
)	O
continue	O
;	O
if	O
(	O
j	int
==	O
closest	int
)	O
continue	O
;	O
lower_bound_on_inter_child_distance	double
=	O
_cheap_lower_bound_on_distance	function
(	O
parent	pointer
->	O
children	pointer
[	O
j	int
]	O
,	O
parent	pointer
->	O
children	pointer
[	O
closest	int
]	O
)	O
;	O
compute_carefully	enum
=	O
(	O
lower_bound_on_inter_child_distance	double
<	O
parent_to_child_distances	pointer
[	O
j	int
]	O
)	O
?	O
true	int
:	O
false	int
;	O
if	O
(	O
compute_carefully	enum
)	O
_compute_closest	function
(	O
parent	pointer
->	O
children	pointer
[	O
j	int
]	O
->	O
segments	pointer
,	O
parent	pointer
->	O
children	pointer
[	O
closest	int
]	O
->	O
segments	pointer
,	O
parent	pointer
->	O
children	pointer
[	O
j	int
]	O
->	O
num_segments	int
,	O
parent	pointer
->	O
children	pointer
[	O
closest	int
]	O
->	O
num_segments	int
,	O
&	O
inter_child_distance	double
,	O
&	O
inter_child_best_index1	int
,	O
&	O
inter_child_best_index2	int
)	O
;	O
if	O
(	O
compute_carefully	enum
&&	O
inter_child_distance	double
<	O
parent_to_child_distances	pointer
[	O
j	int
]	O
)	O
{	O
int	O
nearest_index_in_closest_child	int
;	O
new_parent_to_child_distances	pointer
[	O
j	int
]	O
=	O
inter_child_distance	double
;	O
new_child_best_indices	pointer
[	O
j	int
]	O
=	O
inter_child_best_index1	int
;	O
nearest_index_in_closest_child	int
=	O
inter_child_best_index2	int
;	O
if	O
(	O
nearest_index_in_closest_child	int
==	O
parent	pointer
->	O
children	pointer
[	O
closest	int
]	O
->	O
num_segments	int
-	O
1	int
)	O
nearest_index_in_closest_child	int
=	O
0	int
;	O
new_parent_best_indices	pointer
[	O
j	int
]	O
=	O
CHILD_VERTEX_IN_MERGED_PATH	O
(	O
nearest_index_in_closest_child	int
,	O
parent_best_indices	pointer
[	O
closest	int
]	O
,	O
merged_path	pointer
->	O
num_segments	int
,	O
child_best_indices	pointer
[	O
closest	int
]	O
,	O
parent	pointer
->	O
children	pointer
[	O
closest	int
]	O
->	O
num_segments	int
)	O
;	O
}	O
else	O
{	O
int	O
nearest_index_in_parent	int
;	O
nearest_index_in_parent	int
=	O
parent_best_indices	pointer
[	O
j	int
]	O
;	O
new_parent_best_indices	pointer
[	O
j	int
]	O
=	O
PARENT_VERTEX_IN_MERGED_PATH	O
(	O
nearest_index_in_parent	int
,	O
parent_best_indices	pointer
[	O
closest	int
]	O
,	O
merged_path	pointer
->	O
num_segments	int
,	O
child_best_indices	pointer
[	O
closest	int
]	O
,	O
parent	pointer
->	O
children	pointer
[	O
closest	int
]	O
->	O
num_segments	int
)	O
;	O
}	O
}	O
insert_subpath	function
(	O
merged_path	pointer
->	O
segments	pointer
,	O
parent	pointer
->	O
children	pointer
[	O
closest	int
]	O
->	O
segments	pointer
,	O
merged_path	pointer
->	O
num_segments	int
,	O
parent	pointer
->	O
children	pointer
[	O
closest	int
]	O
->	O
num_segments	int
,	O
parent_best_indices	pointer
[	O
closest	int
]	O
,	O
child_best_indices	pointer
[	O
closest	int
]	O
)	O
;	O
merged_path	pointer
->	O
num_segments	int
+=	O
(	O
parent	pointer
->	O
children	pointer
[	O
closest	int
]	O
->	O
num_segments	int
+	O
1	int
)	O
;	O
parent	pointer
->	O
children	pointer
[	O
closest	int
]	O
->	O
inserted	enum
=	O
true	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
parent	pointer
->	O
num_children	int
;	O
j	int
++	O
)	O
{	O
parent_to_child_distances	pointer
[	O
j	int
]	O
=	O
new_parent_to_child_distances	pointer
[	O
j	int
]	O
;	O
parent_best_indices	pointer
[	O
j	int
]	O
=	O
new_parent_best_indices	pointer
[	O
j	int
]	O
;	O
child_best_indices	pointer
[	O
j	int
]	O
=	O
new_child_best_indices	pointer
[	O
j	int
]	O
;	O
}	O
free	function
(	O
new_parent_to_child_distances	pointer
)	O
;	O
free	function
(	O
new_parent_best_indices	pointer
)	O
;	O
free	function
(	O
new_child_best_indices	pointer
)	O
;	O
}	O
merged_path	pointer
->	O
segments	pointer
[	O
0	int
]	O
.	O
type	enum
=	O
S_MOVETO	int
;	O
merged_paths	pointer
[	O
i	int
]	O
=	O
merged_path	pointer
;	O
free	function
(	O
parent_to_child_distances	pointer
)	O
;	O
free	function
(	O
parent_best_indices	pointer
)	O
;	O
free	function
(	O
child_best_indices	pointer
)	O
;	O
}	O
delete_subpath_array	function
(	O
annotated_paths	pointer
,	O
num_paths	int
)	O
;	O
return	O
merged_paths	pointer
;	O
}	O
