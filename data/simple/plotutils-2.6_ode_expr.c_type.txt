double	O
stack	array
[	O
NSTACK	int
]	O
;	O
double	O
eval	function
(	O
const	O
struct	O
expr	struct
*	O
ep	pointer
)	O
{	O
double	O
*	O
sp	pointer
;	O
double	O
tmp	double
,	O
tmp2	double
;	O
for	O
(	O
sp	pointer
=	O
&	O
stack	array
[	O
NSTACK	int
]	O
;	O
ep	pointer
!=	O
NULL	O
;	O
ep	pointer
=	O
ep	pointer
->	O
ex_next	pointer
)	O
{	O
if	O
(	O
sp	pointer
<=	O
stack	array
)	O
panic	function
(	O
"stack overflow -- bump NSTACK and recompile"	pointer
)	O
;	O
switch	O
(	O
ep	pointer
->	O
ex_oper	enum
)	O
{	O
case	O
O_CONST	int
:	O
*	O
--	O
sp	pointer
=	O
ep	pointer
->	O
ex_value	double
;	O
break	O
;	O
case	O
O_IDENT	int
:	O
*	O
--	O
sp	pointer
=	O
ep	pointer
->	O
ex_sym	pointer
->	O
sy_value	double
;	O
break	O
;	O
case	O
O_PLUS	int
:	O
tmp	double
=	O
*	O
sp	pointer
++	O
;	O
*	O
sp	pointer
+=	O
tmp	double
;	O
break	O
;	O
case	O
O_MINUS	int
:	O
tmp	double
=	O
*	O
sp	pointer
++	O
;	O
*	O
sp	pointer
-=	O
tmp	double
;	O
break	O
;	O
case	O
O_MULT	int
:	O
tmp	double
=	O
*	O
sp	pointer
++	O
;	O
*	O
sp	pointer
*=	O
tmp	double
;	O
break	O
;	O
case	O
O_DIV	int
:	O
tmp	double
=	O
*	O
sp	pointer
++	O
;	O
*	O
sp	pointer
/=	O
tmp	double
;	O
break	O
;	O
case	O
O_POWER	int
:	O
tmp	double
=	O
*	O
sp	pointer
++	O
;	O
if	O
(	O
(	O
tmp	double
!=	O
(	O
int	O
)	O
tmp	double
)	O
&&	O
(	O
*	O
sp	pointer
<	O
0	int
)	O
)	O
rterror	function
(	O
"negative number to non-integer power"	pointer
)	O
;	O
*	O
sp	pointer
=	O
pow	function
(	O
*	O
sp	pointer
,	O
tmp	double
)	O
;	O
break	O
;	O
case	O
O_SQAR	int
:	O
*	O
sp	pointer
*=	O
*	O
sp	pointer
;	O
break	O
;	O
case	O
O_CUBE	int
:	O
*	O
sp	pointer
*=	O
*	O
sp	pointer
*	O
*	O
sp	pointer
;	O
break	O
;	O
case	O
O_INV	int
:	O
*	O
sp	pointer
=	O
1.	int
/	O
*	O
sp	pointer
;	O
break	O
;	O
case	O
O_SQRT	int
:	O
if	O
(	O
*	O
sp	pointer
<	O
0	int
)	O
rterror	function
(	O
"square root of a negative number"	pointer
)	O
;	O
*	O
sp	pointer
=	O
sqrt	function
(	O
*	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
O_SIN	int
:	O
*	O
sp	pointer
=	O
sin	function
(	O
*	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
O_COS	int
:	O
*	O
sp	pointer
=	O
cos	function
(	O
*	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
O_TAN	int
:	O
*	O
sp	pointer
=	O
tan	function
(	O
*	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
O_ASIN	int
:	O
*	O
sp	pointer
=	O
asin	function
(	O
*	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
O_ACOS	int
:	O
*	O
sp	pointer
=	O
acos	function
(	O
*	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
O_ATAN	int
:	O
*	O
sp	pointer
=	O
atan	function
(	O
*	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
O_ABS	int
:	O
if	O
(	O
*	O
sp	pointer
<	O
0	int
)	O
*	O
sp	pointer
=	O
-	O
*	O
sp	pointer
;	O
break	O
;	O
case	O
O_EXP	int
:	O
*	O
sp	pointer
=	O
exp	function
(	O
*	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
O_LOG	int
:	O
if	O
(	O
*	O
sp	pointer
<=	O
0	int
)	O
rterror	function
(	O
"logarithm of non-positive number"	pointer
)	O
;	O
*	O
sp	pointer
=	O
log	function
(	O
*	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
O_LOG10	int
:	O
if	O
(	O
*	O
sp	pointer
<=	O
0	int
)	O
rterror	function
(	O
"logarithm of non-positive number"	pointer
)	O
;	O
*	O
sp	pointer
=	O
log10	function
(	O
*	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
O_SINH	int
:	O
*	O
sp	pointer
=	O
sinh	function
(	O
*	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
O_COSH	int
:	O
*	O
sp	pointer
=	O
cosh	function
(	O
*	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
O_TANH	int
:	O
*	O
sp	pointer
=	O
tanh	function
(	O
*	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
O_ASINH	int
:	O
*	O
sp	pointer
=	O
asinh	function
(	O
*	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
O_ACOSH	int
:	O
*	O
sp	pointer
=	O
acosh	function
(	O
*	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
O_ATANH	int
:	O
*	O
sp	pointer
=	O
atanh	function
(	O
*	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
O_FLOOR	int
:	O
*	O
sp	pointer
=	O
floor	function
(	O
*	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
O_CEIL	int
:	O
*	O
sp	pointer
=	O
ceil	function
(	O
*	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
O_J0	int
:	O
*	O
sp	pointer
=	O
j0	function
(	O
*	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
O_J1	int
:	O
*	O
sp	pointer
=	O
j1	function
(	O
*	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
O_Y0	int
:	O
*	O
sp	pointer
=	O
y0	function
(	O
*	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
O_GAMMA	int
:	O
*	O
sp	pointer
=	O
f_gamma	function
(	O
*	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
O_LGAMMA	int
:	O
*	O
sp	pointer
=	O
F_LGAMMA	O
(	O
*	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
O_ERFC	int
:	O
*	O
sp	pointer
=	O
erfc	function
(	O
*	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
O_ERF	int
:	O
*	O
sp	pointer
=	O
erf	function
(	O
*	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
O_INVERF	int
:	O
*	O
sp	pointer
=	O
inverf	function
(	O
*	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
O_NORM	int
:	O
*	O
sp	pointer
=	O
norm	function
(	O
*	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
O_INVNORM	int
:	O
*	O
sp	pointer
=	O
invnorm	function
(	O
*	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
O_NEG	int
:	O
*	O
sp	pointer
=	O
-	O
*	O
sp	pointer
;	O
break	O
;	O
case	O
O_IGAMMA	int
:	O
tmp	double
=	O
*	O
sp	pointer
++	O
;	O
*	O
sp	pointer
=	O
igamma	function
(	O
*	O
sp	pointer
,	O
tmp	double
)	O
;	O
break	O
;	O
case	O
O_IBETA	int
:	O
tmp2	double
=	O
*	O
sp	pointer
++	O
;	O
tmp	double
=	O
*	O
sp	pointer
++	O
;	O
*	O
sp	pointer
=	O
ibeta	function
(	O
*	O
sp	pointer
,	O
tmp	double
,	O
tmp2	double
)	O
;	O
break	O
;	O
default	O
:	O
panicn	function
(	O
"bad op spec (%d) in eval()"	pointer
,	O
(	O
int	O
)	O
(	O
ep	pointer
->	O
ex_oper	enum
)	O
)	O
;	O
}	O
}	O
return	O
*	O
sp	pointer
;	O
}	O
struct	O
expr	struct
*	O
ealloc	function
(	O
void	O
)	O
{	O
struct	O
expr	struct
*	O
ep	pointer
;	O
ep	pointer
=	O
(	O
struct	O
expr	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
expr	struct
)	O
)	O
;	O
ep	pointer
->	O
ex_next	pointer
=	O
NULL	O
;	O
ep	pointer
->	O
ex_sym	pointer
=	O
NULL	O
;	O
ep	pointer
->	O
ex_oper	enum
=	O
O_NOOP	int
;	O
return	O
ep	pointer
;	O
}	O
void	O
efree	function
(	O
struct	O
expr	struct
*	O
ep	pointer
)	O
{	O
if	O
(	O
ep	pointer
==	O
NULL	O
||	O
ep	pointer
==	O
&	O
exprzero	struct
||	O
ep	pointer
==	O
&	O
exprone	struct
)	O
return	O
;	O
efree	function
(	O
ep	pointer
->	O
ex_next	pointer
)	O
;	O
free	function
(	O
(	O
void	O
*	O
)	O
ep	pointer
)	O
;	O
}	O
