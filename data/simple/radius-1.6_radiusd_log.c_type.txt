static	O
int	O
logging_category	int
=	O
GRAD_LOG_CAT	O
(	O
GRAD_LOG_MAIN	O
)	O
;	O
static	O
grad_list_t	struct
*	O
chanlist	pointer
;	O
static	O
char	O
*	O
log_prefix_hook	pointer
;	O
static	O
char	O
*	O
log_suffix_hook	pointer
;	O
struct	O
log_data	struct
{	O
int	O
cat	int
;	O
int	O
pri	int
;	O
const	O
grad_request_t	struct
*	O
req	pointer
;	O
const	O
char	O
*	O
prefix	pointer
;	O
const	O
char	O
*	O
text	pointer
;	O
const	O
char	O
*	O
errtext	pointer
;	O
}	O
;	O
struct	O
logbuf	struct
{	O
char	O
*	O
ptr	pointer
;	O
size_t	long
size	int
;	O
size_t	long
pos	long
;	O
}	O
;	O
void	O
logbuf_append	function
(	O
struct	O
logbuf	struct
*	O
buf	pointer
,	O
const	O
char	O
*	O
str	pointer
)	O
{	O
size_t	long
length	short
=	O
strlen	function
(	O
str	pointer
)	O
;	O
size_t	long
rest	pointer
=	O
buf	pointer
->	O
size	int
-	O
buf	pointer
->	O
pos	long
;	O
if	O
(	O
rest	pointer
<=	O
1	int
)	O
buf	pointer
->	O
ptr	pointer
[	O
buf	pointer
->	O
pos	long
-	O
1	int
]	O
=	O
'>'	O
;	O
else	O
if	O
(	O
rest	pointer
==	O
2	int
)	O
buf	pointer
->	O
ptr	pointer
[	O
buf	pointer
->	O
pos	long
++	O
]	O
=	O
'>'	O
;	O
else	O
if	O
(	O
length	short
>=	O
rest	pointer
)	O
{	O
if	O
(	O
--	O
rest	pointer
>	O
1	int
)	O
{	O
if	O
(	O
rest	pointer
>=	O
2	int
)	O
rest	pointer
--	O
;	O
memcpy	function
(	O
buf	pointer
->	O
ptr	pointer
+	O
buf	pointer
->	O
pos	long
,	O
str	pointer
,	O
rest	pointer
)	O
;	O
buf	pointer
->	O
pos	long
+=	O
rest	pointer
;	O
}	O
buf	pointer
->	O
ptr	pointer
[	O
buf	pointer
->	O
pos	long
++	O
]	O
=	O
'>'	O
;	O
}	O
else	O
{	O
memcpy	function
(	O
buf	pointer
->	O
ptr	pointer
+	O
buf	pointer
->	O
pos	long
,	O
str	pointer
,	O
length	short
)	O
;	O
buf	pointer
->	O
pos	long
+=	O
length	short
;	O
}	O
}	O
void	O
logbuf_append_line	function
(	O
struct	O
logbuf	struct
*	O
buf	pointer
,	O
size_t	long
line	long
)	O
{	O
char	O
linestr	array
[	O
64	int
]	O
;	O
snprintf	function
(	O
linestr	array
,	O
sizeof	O
(	O
linestr	array
)	O
,	O
"%lu"	pointer
,	O
(	O
unsigned	O
long	O
)	O
line	long
)	O
;	O
logbuf_append	function
(	O
buf	pointer
,	O
linestr	array
)	O
;	O
}	O
void	O
logbuf_vformat	function
(	O
struct	O
logbuf	struct
*	O
buf	pointer
,	O
const	O
char	O
*	O
fmt	pointer
,	O
va_list	array
ap	array
)	O
{	O
size_t	long
rest	pointer
=	O
buf	pointer
->	O
size	int
-	O
buf	pointer
->	O
pos	long
;	O
size_t	long
length	short
;	O
int	O
n	long
;	O
if	O
(	O
rest	pointer
<=	O
1	int
)	O
return	O
;	O
n	long
=	O
vsnprintf	function
(	O
buf	pointer
->	O
ptr	pointer
+	O
buf	pointer
->	O
pos	long
,	O
rest	pointer
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
length	short
=	O
strlen	function
(	O
buf	pointer
->	O
ptr	pointer
+	O
buf	pointer
->	O
pos	long
)	O
;	O
buf	pointer
->	O
pos	long
+=	O
length	short
;	O
if	O
(	O
n	long
==	O
-	O
1	int
||	O
length	short
<	O
n	long
)	O
buf	pointer
->	O
ptr	pointer
[	O
buf	pointer
->	O
pos	long
-	O
1	int
]	O
=	O
'>'	O
;	O
}	O
char	O
*	O
logbuf_ptr	function
(	O
struct	O
logbuf	struct
*	O
buf	pointer
)	O
{	O
buf	pointer
->	O
ptr	pointer
[	O
buf	pointer
->	O
pos	long
]	O
=	O
0	int
;	O
return	O
buf	pointer
->	O
ptr	pointer
;	O
}	O
size_t	long
logbuf_printable_length	function
(	O
struct	O
logbuf	struct
*	O
buf	pointer
)	O
{	O
return	O
buf	pointer
->	O
pos	long
;	O
}	O
static	O
int	O
log_get_category	function
(	O
)	O
{	O
return	O
logging_category	int
;	O
}	O
static	O
void	O
log_set_category	function
(	O
int	O
cat	int
)	O
{	O
logging_category	int
=	O
GRAD_LOG_CAT	O
(	O
cat	int
)	O
;	O
}	O
void	O
log_open	function
(	O
int	O
cat	int
)	O
{	O
log_set_category	function
(	O
cat	int
)	O
;	O
}	O
void	O
log_close	function
(	O
)	O
{	O
log_set_category	function
(	O
GRAD_LOG_MAIN	O
)	O
;	O
}	O
static	O
char	O
*	O
catname	array
[	O
]	O
=	O
{	O
N_	O
(	O
"none"	pointer
)	O
,	O
N_	O
(	O
"Main"	pointer
)	O
,	O
N_	O
(	O
"Auth"	pointer
)	O
,	O
N_	O
(	O
"Acct"	pointer
)	O
,	O
N_	O
(	O
"Proxy"	pointer
)	O
,	O
N_	O
(	O
"SNMP"	pointer
)	O
,	O
}	O
;	O
static	O
char	O
*	O
priname	array
[	O
]	O
=	O
{	O
N_	O
(	O
"emerg"	pointer
)	O
,	O
N_	O
(	O
"alert"	pointer
)	O
,	O
N_	O
(	O
"crit"	pointer
)	O
,	O
N_	O
(	O
"error"	pointer
)	O
,	O
N_	O
(	O
"warning"	pointer
)	O
,	O
N_	O
(	O
"notice"	pointer
)	O
,	O
N_	O
(	O
"info"	pointer
)	O
,	O
N_	O
(	O
"debug"	pointer
)	O
}	O
;	O
static	O
char	O
*	O
run_log_hook	function
(	O
const	O
grad_request_t	struct
*	O
req	pointer
,	O
const	O
char	O
*	O
hook_name	pointer
)	O
{	O
grad_value_t	struct
val	array
;	O
char	O
nasbuf	array
[	O
GRAD_MAX_LONGNAME	int
]	O
;	O
memset	function
(	O
&	O
val	array
,	O
0	int
,	O
sizeof	O
(	O
val	array
)	O
)	O
;	O
if	O
(	O
rewrite_invoke	function
(	O
String	int
,	O
&	O
val	array
,	O
hook_name	pointer
,	O
req	pointer
,	O
"isi"	pointer
,	O
req	pointer
->	O
code	char
,	O
grad_nas_request_to_name	function
(	O
req	pointer
,	O
nasbuf	array
,	O
sizeof	O
nasbuf	array
)	O
,	O
req	pointer
->	O
id	char
)	O
)	O
return	O
NULL	O
;	O
return	O
val	array
.	O
datum	union
.	O
sval	struct
.	O
data	pointer
;	O
}	O
static	O
void	O
log_format_hook	function
(	O
struct	O
logbuf	struct
*	O
bufp	pointer
,	O
char	O
*	O
*	O
hook_name_ptr	pointer
,	O
const	O
grad_request_t	struct
*	O
req	pointer
)	O
{	O
char	O
*	O
hook_res	pointer
=	O
NULL	O
;	O
if	O
(	O
*	O
hook_name_ptr	pointer
)	O
{	O
hook_res	pointer
=	O
run_log_hook	function
(	O
req	pointer
,	O
*	O
hook_name_ptr	pointer
)	O
;	O
if	O
(	O
!	O
hook_res	pointer
)	O
*	O
hook_name_ptr	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
hook_res	pointer
)	O
{	O
logbuf_append	function
(	O
bufp	pointer
,	O
hook_res	pointer
)	O
;	O
grad_free	function
(	O
hook_res	pointer
)	O
;	O
}	O
}	O
static	O
FILE	struct
*	O
channel_open_file	function
(	O
Channel	struct
*	O
chan	pointer
)	O
{	O
FILE	struct
*	O
fp	pointer
=	O
NULL	O
;	O
if	O
(	O
strcmp	function
(	O
chan	pointer
->	O
id	char
.	O
file	pointer
,	O
"stdout"	pointer
)	O
)	O
fp	pointer
=	O
fopen	function
(	O
chan	pointer
->	O
id	char
.	O
file	pointer
,	O
"a"	pointer
)	O
;	O
return	O
fp	pointer
?	O
fp	pointer
:	O
stderr	pointer
;	O
}	O
static	O
void	O
channel_close_file	function
(	O
Channel	struct
*	O
chan	pointer
,	O
FILE	struct
*	O
fp	pointer
)	O
{	O
if	O
(	O
fp	pointer
!=	O
stderr	pointer
)	O
fclose	function
(	O
fp	pointer
)	O
;	O
}	O
int	O
log_to_channel	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
pdata	pointer
)	O
{	O
Channel	struct
*	O
chan	pointer
=	O
item	pointer
;	O
struct	O
log_data	struct
*	O
data	pointer
=	O
pdata	pointer
;	O
LOGBUF_DECL	O
(	O
pri_prefix	struct
,	O
64	int
)	O
;	O
LOGBUF_DECL	O
(	O
req_prefix	struct
,	O
256	int
)	O
;	O
LOGBUF_DECL	O
(	O
req_suffix	struct
,	O
256	int
)	O
;	O
time_t	long
timeval	struct
;	O
char	O
buffer	pointer
[	O
256	int
]	O
;	O
struct	O
tm	struct
*	O
tm	struct
,	O
tms	struct
;	O
int	O
spri	int
;	O
FILE	struct
*	O
fp	pointer
;	O
if	O
(	O
!	O
(	O
chan	pointer
->	O
pmask	array
[	O
data	pointer
->	O
cat	int
]	O
&	O
GRAD_LOG_MASK	O
(	O
data	pointer
->	O
pri	int
)	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
chan	pointer
->	O
options	int
&	O
LO_CAT	int
)	O
{	O
logbuf_append	function
(	O
&	O
pri_prefix	struct
,	O
_	O
(	O
catname	array
[	O
data	pointer
->	O
cat	int
]	O
)	O
)	O
;	O
logbuf_append	function
(	O
&	O
pri_prefix	struct
,	O
"."	pointer
)	O
;	O
}	O
if	O
(	O
chan	pointer
->	O
options	int
&	O
LO_PRI	int
)	O
logbuf_append	function
(	O
&	O
pri_prefix	struct
,	O
_	O
(	O
priname	array
[	O
data	pointer
->	O
pri	int
]	O
)	O
)	O
;	O
if	O
(	O
data	pointer
->	O
req	pointer
)	O
{	O
log_format_hook	function
(	O
&	O
req_prefix	struct
,	O
chan	pointer
->	O
prefix_hook	pointer
?	O
&	O
chan	pointer
->	O
prefix_hook	pointer
:	O
&	O
log_prefix_hook	pointer
,	O
data	pointer
->	O
req	pointer
)	O
;	O
log_format_hook	function
(	O
&	O
req_suffix	struct
,	O
chan	pointer
->	O
suffix_hook	pointer
?	O
&	O
chan	pointer
->	O
suffix_hook	pointer
:	O
&	O
log_suffix_hook	pointer
,	O
data	pointer
->	O
req	pointer
)	O
;	O
}	O
switch	O
(	O
chan	pointer
->	O
mode	int
)	O
{	O
case	O
LM_FILE	int
:	O
if	O
(	O
chan	pointer
->	O
options	int
&	O
LO_MSEC	int
)	O
{	O
struct	O
timeval	struct
tv	pointer
;	O
int	O
len	int
;	O
gettimeofday	function
(	O
&	O
tv	pointer
,	O
NULL	O
)	O
;	O
tm	struct
=	O
localtime_r	function
(	O
&	O
tv	pointer
.	O
tv_sec	long
,	O
&	O
tms	struct
)	O
;	O
strftime	function
(	O
buffer	pointer
,	O
sizeof	O
(	O
buffer	pointer
)	O
,	O
"%b %d %H:%M:%S"	pointer
,	O
tm	struct
)	O
;	O
len	int
=	O
strlen	function
(	O
buffer	pointer
)	O
;	O
snprintf	function
(	O
buffer	pointer
+	O
len	int
,	O
sizeof	O
(	O
buffer	pointer
)	O
-	O
len	int
,	O
".%06d"	pointer
,	O
(	O
int	O
)	O
tv	pointer
.	O
tv_usec	long
)	O
;	O
}	O
else	O
{	O
timeval	struct
=	O
time	struct
(	O
NULL	O
)	O
;	O
tm	struct
=	O
localtime_r	function
(	O
&	O
timeval	struct
,	O
&	O
tms	struct
)	O
;	O
strftime	function
(	O
buffer	pointer
,	O
sizeof	O
(	O
buffer	pointer
)	O
,	O
"%b %d %H:%M:%S"	pointer
,	O
tm	struct
)	O
;	O
}	O
fp	pointer
=	O
channel_open_file	function
(	O
chan	pointer
)	O
;	O
if	O
(	O
!	O
fp	pointer
)	O
break	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"%s "	pointer
,	O
buffer	pointer
)	O
;	O
if	O
(	O
chan	pointer
->	O
options	int
&	O
LO_PID	int
)	O
fprintf	function
(	O
fp	pointer
,	O
"[%lu]: "	pointer
,	O
(	O
u_long	long
)	O
getpid	function
(	O
)	O
)	O
;	O
if	O
(	O
logbuf_printable_length	function
(	O
&	O
pri_prefix	struct
)	O
)	O
fprintf	function
(	O
fp	pointer
,	O
"%s: "	pointer
,	O
logbuf_ptr	function
(	O
&	O
pri_prefix	struct
)	O
)	O
;	O
if	O
(	O
data	pointer
->	O
prefix	pointer
)	O
fprintf	function
(	O
fp	pointer
,	O
"%s"	pointer
,	O
data	pointer
->	O
prefix	pointer
)	O
;	O
if	O
(	O
logbuf_printable_length	function
(	O
&	O
req_prefix	struct
)	O
)	O
fprintf	function
(	O
fp	pointer
,	O
"%s"	pointer
,	O
logbuf_ptr	function
(	O
&	O
req_prefix	struct
)	O
)	O
;	O
if	O
(	O
data	pointer
->	O
text	pointer
)	O
fprintf	function
(	O
fp	pointer
,	O
"%s"	pointer
,	O
data	pointer
->	O
text	pointer
)	O
;	O
if	O
(	O
data	pointer
->	O
errtext	pointer
)	O
fprintf	function
(	O
fp	pointer
,	O
": %s"	pointer
,	O
data	pointer
->	O
errtext	pointer
)	O
;	O
if	O
(	O
logbuf_printable_length	function
(	O
&	O
req_suffix	struct
)	O
)	O
fprintf	function
(	O
fp	pointer
,	O
"%s"	pointer
,	O
logbuf_ptr	function
(	O
&	O
req_suffix	struct
)	O
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\n"	pointer
)	O
;	O
channel_close_file	function
(	O
chan	pointer
,	O
fp	pointer
)	O
;	O
break	O
;	O
case	O
LM_SYSLOG	int
:	O
spri	int
=	O
chan	pointer
->	O
id	char
.	O
sl	struct
.	O
prio	int
;	O
openlog	function
(	O
chan	pointer
->	O
id	char
.	O
sl	struct
.	O
tag	char
?	O
chan	pointer
->	O
id	char
.	O
sl	struct
.	O
tag	char
:	O
"radiusd"	pointer
,	O
(	O
chan	pointer
->	O
options	int
&	O
LO_PID	int
)	O
?	O
LOG_PID	int
:	O
0	int
,	O
chan	pointer
->	O
id	char
.	O
sl	struct
.	O
fac	int
)	O
;	O
if	O
(	O
logbuf_printable_length	function
(	O
&	O
pri_prefix	struct
)	O
)	O
{	O
if	O
(	O
data	pointer
->	O
errtext	pointer
)	O
syslog	function
(	O
spri	int
,	O
"%s: %s%s%s: %s%s"	pointer
,	O
logbuf_ptr	function
(	O
&	O
pri_prefix	struct
)	O
,	O
SP	O
(	O
data	pointer
->	O
prefix	pointer
)	O
,	O
logbuf_ptr	function
(	O
&	O
req_prefix	struct
)	O
,	O
SP	O
(	O
data	pointer
->	O
text	pointer
)	O
,	O
data	pointer
->	O
errtext	pointer
,	O
logbuf_ptr	function
(	O
&	O
req_suffix	struct
)	O
)	O
;	O
else	O
syslog	function
(	O
spri	int
,	O
"%s: %s%s%s%s"	pointer
,	O
logbuf_ptr	function
(	O
&	O
pri_prefix	struct
)	O
,	O
SP	O
(	O
data	pointer
->	O
prefix	pointer
)	O
,	O
logbuf_ptr	function
(	O
&	O
req_prefix	struct
)	O
,	O
SP	O
(	O
data	pointer
->	O
text	pointer
)	O
,	O
logbuf_ptr	function
(	O
&	O
req_suffix	struct
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
data	pointer
->	O
errtext	pointer
)	O
syslog	function
(	O
spri	int
,	O
"%s%s%s: %s%s"	pointer
,	O
SP	O
(	O
data	pointer
->	O
prefix	pointer
)	O
,	O
logbuf_ptr	function
(	O
&	O
req_prefix	struct
)	O
,	O
SP	O
(	O
data	pointer
->	O
text	pointer
)	O
,	O
data	pointer
->	O
errtext	pointer
,	O
logbuf_ptr	function
(	O
&	O
req_suffix	struct
)	O
)	O
;	O
else	O
syslog	function
(	O
spri	int
,	O
"%s%s%s%s"	pointer
,	O
SP	O
(	O
data	pointer
->	O
prefix	pointer
)	O
,	O
logbuf_ptr	function
(	O
&	O
req_prefix	struct
)	O
,	O
SP	O
(	O
data	pointer
->	O
text	pointer
)	O
,	O
logbuf_ptr	function
(	O
&	O
req_suffix	struct
)	O
)	O
;	O
}	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
void	O
radiusd_logger	function
(	O
int	O
level	int
,	O
const	O
grad_request_t	struct
*	O
req	pointer
,	O
const	O
grad_locus_t	struct
*	O
loc	struct
,	O
const	O
char	O
*	O
func_name	pointer
,	O
int	O
en	int
,	O
const	O
char	O
*	O
fmt	pointer
,	O
va_list	array
ap	array
)	O
{	O
Channel	struct
*	O
chan	pointer
;	O
int	O
cat	int
,	O
pri	int
;	O
struct	O
log_data	struct
log_data	struct
;	O
LOGBUF_DECL	O
(	O
buf1	struct
,	O
256	int
)	O
;	O
LOGBUF_DECL	O
(	O
buf2	struct
,	O
1024	int
)	O
;	O
char	O
*	O
errstr	pointer
=	O
NULL	O
;	O
cat	int
=	O
GRAD_LOG_CAT	O
(	O
level	int
)	O
;	O
if	O
(	O
cat	int
==	O
0	int
)	O
cat	int
=	O
log_get_category	function
(	O
)	O
;	O
pri	int
=	O
GRAD_LOG_PRI	O
(	O
level	int
)	O
;	O
if	O
(	O
loc	struct
&&	O
loc	struct
->	O
file	pointer
)	O
{	O
logbuf_append	function
(	O
&	O
buf1	struct
,	O
loc	struct
->	O
file	pointer
)	O
;	O
logbuf_append	function
(	O
&	O
buf1	struct
,	O
":"	pointer
)	O
;	O
logbuf_append_line	function
(	O
&	O
buf1	struct
,	O
loc	struct
->	O
line	long
)	O
;	O
if	O
(	O
func_name	pointer
)	O
{	O
logbuf_append	function
(	O
&	O
buf1	struct
,	O
":"	pointer
)	O
;	O
logbuf_append	function
(	O
&	O
buf1	struct
,	O
func_name	pointer
)	O
;	O
}	O
logbuf_append	function
(	O
&	O
buf1	struct
,	O
": "	pointer
)	O
;	O
}	O
if	O
(	O
en	int
)	O
errstr	pointer
=	O
strerror	function
(	O
en	int
)	O
;	O
logbuf_vformat	function
(	O
&	O
buf2	struct
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
log_data	struct
.	O
cat	int
=	O
cat	int
;	O
log_data	struct
.	O
pri	int
=	O
pri	int
;	O
log_data	struct
.	O
req	pointer
=	O
req	pointer
;	O
log_data	struct
.	O
prefix	pointer
=	O
logbuf_ptr	function
(	O
&	O
buf1	struct
)	O
;	O
log_data	struct
.	O
text	pointer
=	O
logbuf_ptr	function
(	O
&	O
buf2	struct
)	O
;	O
log_data	struct
.	O
errtext	pointer
=	O
errstr	pointer
;	O
grad_list_iterate	function
(	O
chanlist	pointer
,	O
log_to_channel	function
,	O
&	O
log_data	struct
)	O
;	O
}	O
void	O
channel_free	function
(	O
Channel	struct
*	O
chan	pointer
)	O
{	O
grad_free	function
(	O
chan	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
chan	pointer
->	O
mode	int
==	O
LM_FILE	int
)	O
grad_free	function
(	O
chan	pointer
->	O
id	char
.	O
file	pointer
)	O
;	O
else	O
grad_free	function
(	O
chan	pointer
->	O
id	char
.	O
sl	struct
.	O
tag	char
)	O
;	O
grad_free	function
(	O
chan	pointer
->	O
prefix_hook	pointer
)	O
;	O
grad_free	function
(	O
chan	pointer
->	O
suffix_hook	pointer
)	O
;	O
grad_free	function
(	O
chan	pointer
)	O
;	O
}	O
Channel	struct
*	O
log_mark	function
(	O
)	O
{	O
return	O
grad_list_item	function
(	O
chanlist	pointer
,	O
0	int
)	O
;	O
}	O
void	O
log_release	function
(	O
Channel	struct
*	O
chan	pointer
)	O
{	O
Channel	struct
*	O
cp	pointer
;	O
int	O
emerg	int
,	O
alert	int
,	O
crit	int
;	O
grad_iterator_t	struct
*	O
itr	pointer
=	O
grad_iterator_create	function
(	O
chanlist	pointer
)	O
;	O
for	O
(	O
cp	pointer
=	O
grad_iterator_first	function
(	O
itr	pointer
)	O
;	O
cp	pointer
;	O
cp	pointer
=	O
grad_iterator_next	function
(	O
itr	pointer
)	O
)	O
if	O
(	O
cp	pointer
==	O
chan	pointer
)	O
break	O
;	O
for	O
(	O
;	O
cp	pointer
;	O
cp	pointer
=	O
grad_iterator_next	function
(	O
itr	pointer
)	O
)	O
{	O
if	O
(	O
!	O
(	O
cp	pointer
->	O
options	int
&	O
LO_PERSIST	int
)	O
)	O
{	O
grad_list_remove	function
(	O
chanlist	pointer
,	O
cp	pointer
,	O
NULL	O
)	O
;	O
channel_free	function
(	O
cp	pointer
)	O
;	O
}	O
}	O
emerg	int
=	O
GRAD_LOG_EMERG	int
;	O
alert	int
=	O
GRAD_LOG_ALERT	int
;	O
crit	int
=	O
GRAD_LOG_CRIT	int
;	O
for	O
(	O
cp	pointer
=	O
grad_iterator_first	function
(	O
itr	pointer
)	O
;	O
cp	pointer
;	O
cp	pointer
=	O
grad_iterator_next	function
(	O
itr	pointer
)	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
GRAD_LOG_NCAT	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
emerg	int
&&	O
(	O
cp	pointer
->	O
pmask	array
[	O
i	int
]	O
&	O
GRAD_LOG_MASK	O
(	O
emerg	int
)	O
)	O
)	O
emerg	int
=	O
0	int
;	O
if	O
(	O
alert	int
&&	O
(	O
cp	pointer
->	O
pmask	array
[	O
i	int
]	O
&	O
GRAD_LOG_MASK	O
(	O
alert	int
)	O
)	O
)	O
alert	int
=	O
0	int
;	O
if	O
(	O
crit	int
&&	O
(	O
cp	pointer
->	O
pmask	array
[	O
i	int
]	O
&	O
GRAD_LOG_MASK	O
(	O
crit	int
)	O
)	O
)	O
crit	int
=	O
0	int
;	O
}	O
}	O
grad_iterator_destroy	function
(	O
&	O
itr	pointer
)	O
;	O
if	O
(	O
emerg	int
||	O
alert	int
||	O
crit	int
)	O
log_set_default	function
(	O
"##emerg##"	pointer
,	O
-	O
1	int
,	O
emerg	int
|	O
alert	int
|	O
crit	int
)	O
;	O
}	O
int	O
log_change_owner	function
(	O
RADIUS_USER	struct
*	O
usr	pointer
)	O
{	O
Channel	struct
*	O
cp	pointer
;	O
int	O
errcnt	long
=	O
0	int
;	O
grad_iterator_t	struct
*	O
itr	pointer
=	O
grad_iterator_create	function
(	O
chanlist	pointer
)	O
;	O
for	O
(	O
cp	pointer
=	O
grad_iterator_first	function
(	O
itr	pointer
)	O
;	O
cp	pointer
;	O
cp	pointer
=	O
grad_iterator_next	function
(	O
itr	pointer
)	O
)	O
{	O
if	O
(	O
cp	pointer
->	O
mode	int
==	O
LM_FILE	int
&&	O
chown	function
(	O
cp	pointer
->	O
id	char
.	O
file	pointer
,	O
usr	pointer
->	O
uid	int
,	O
usr	pointer
->	O
gid	int
)	O
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"%s: cannot change owner to %d:%d"	pointer
)	O
,	O
cp	pointer
->	O
id	char
.	O
file	pointer
,	O
usr	pointer
->	O
uid	int
,	O
usr	pointer
->	O
gid	int
)	O
;	O
errcnt	long
++	O
;	O
}	O
}	O
grad_iterator_destroy	function
(	O
&	O
itr	pointer
)	O
;	O
return	O
errcnt	long
;	O
}	O
static	O
int	O
_chancmp	function
(	O
const	O
void	O
*	O
item	pointer
,	O
const	O
void	O
*	O
data	pointer
)	O
{	O
const	O
Channel	struct
*	O
chan	pointer
=	O
item	pointer
;	O
const	O
char	O
*	O
name	pointer
=	O
data	pointer
;	O
return	O
strcmp	function
(	O
chan	pointer
->	O
name	pointer
,	O
name	pointer
)	O
;	O
}	O
Channel	struct
*	O
channel_lookup	function
(	O
char	O
*	O
name	pointer
)	O
{	O
return	O
grad_list_locate	function
(	O
chanlist	pointer
,	O
name	pointer
,	O
_chancmp	function
)	O
;	O
}	O
void	O
register_channel	function
(	O
Channel	struct
*	O
chan	pointer
)	O
{	O
FILE	struct
*	O
fp	pointer
;	O
Channel	struct
*	O
channel	struct
;	O
char	O
*	O
filename	pointer
;	O
if	O
(	O
chan	pointer
->	O
mode	int
==	O
LM_FILE	int
)	O
{	O
if	O
(	O
strcmp	function
(	O
chan	pointer
->	O
id	char
.	O
file	pointer
,	O
"stdout"	pointer
)	O
)	O
{	O
filename	pointer
=	O
grad_mkfilename	function
(	O
grad_log_dir	pointer
?	O
grad_log_dir	pointer
:	O
RADLOG_DIR	O
,	O
chan	pointer
->	O
id	char
.	O
file	pointer
)	O
;	O
fp	pointer
=	O
fopen	function
(	O
filename	pointer
,	O
"a"	pointer
)	O
;	O
if	O
(	O
!	O
fp	pointer
)	O
{	O
grad_log	function
(	O
GRAD_LOG_CRIT	int
|	O
GRAD_LOG_PERROR	int
,	O
_	O
(	O
"can't access log file `%s'"	pointer
)	O
,	O
filename	pointer
)	O
;	O
grad_free	function
(	O
filename	pointer
)	O
;	O
filename	pointer
=	O
grad_estrdup	function
(	O
"stdout"	pointer
)	O
;	O
}	O
else	O
fclose	function
(	O
fp	pointer
)	O
;	O
}	O
else	O
filename	pointer
=	O
grad_estrdup	function
(	O
"stdout"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
chan	pointer
->	O
mode	int
==	O
LM_SYSLOG	int
)	O
{	O
}	O
channel	struct
=	O
grad_emalloc	function
(	O
sizeof	O
(	O
*	O
channel	struct
)	O
)	O
;	O
channel	struct
->	O
name	pointer
=	O
grad_estrdup	function
(	O
chan	pointer
->	O
name	pointer
)	O
;	O
channel	struct
->	O
mode	int
=	O
chan	pointer
->	O
mode	int
;	O
if	O
(	O
chan	pointer
->	O
mode	int
==	O
LM_FILE	int
)	O
channel	struct
->	O
id	char
.	O
file	pointer
=	O
filename	pointer
;	O
else	O
if	O
(	O
chan	pointer
->	O
mode	int
==	O
LM_SYSLOG	int
)	O
{	O
channel	struct
->	O
id	char
.	O
sl	struct
.	O
prio	int
=	O
chan	pointer
->	O
id	char
.	O
sl	struct
.	O
prio	int
;	O
channel	struct
->	O
id	char
.	O
sl	struct
.	O
fac	int
=	O
chan	pointer
->	O
id	char
.	O
sl	struct
.	O
fac	int
;	O
channel	struct
->	O
id	char
.	O
sl	struct
.	O
tag	char
=	O
chan	pointer
->	O
id	char
.	O
sl	struct
.	O
tag	char
?	O
grad_estrdup	function
(	O
chan	pointer
->	O
id	char
.	O
sl	struct
.	O
tag	char
)	O
:	O
NULL	O
;	O
}	O
channel	struct
->	O
options	int
=	O
chan	pointer
->	O
options	int
;	O
channel	struct
->	O
prefix_hook	pointer
=	O
chan	pointer
->	O
prefix_hook	pointer
;	O
channel	struct
->	O
suffix_hook	pointer
=	O
chan	pointer
->	O
suffix_hook	pointer
;	O
if	O
(	O
!	O
chanlist	pointer
)	O
chanlist	pointer
=	O
grad_list_create	function
(	O
)	O
;	O
grad_list_prepend	function
(	O
chanlist	pointer
,	O
channel	struct
)	O
;	O
}	O
void	O
register_category0	function
(	O
int	O
cat	int
,	O
int	O
pri	int
,	O
Channel	struct
*	O
chan	pointer
)	O
{	O
if	O
(	O
cat	int
==	O
-	O
1	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
GRAD_LOG_NCAT	int
;	O
i	int
++	O
)	O
chan	pointer
->	O
pmask	array
[	O
i	int
]	O
|=	O
pri	int
;	O
}	O
else	O
chan	pointer
->	O
pmask	array
[	O
GRAD_LOG_CAT	O
(	O
cat	int
)	O
]	O
|=	O
pri	int
;	O
}	O
struct	O
category_closure	struct
{	O
int	O
cat	int
;	O
int	O
pri	int
;	O
}	O
;	O
static	O
int	O
_regcat	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
Channel	struct
*	O
chan	pointer
=	O
item	pointer
;	O
struct	O
category_closure	struct
*	O
cp	pointer
=	O
data	pointer
;	O
register_category0	function
(	O
cp	pointer
->	O
cat	int
,	O
cp	pointer
->	O
pri	int
,	O
chan	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
register_category	function
(	O
int	O
cat	int
,	O
int	O
pri	int
,	O
grad_list_t	struct
*	O
clist	pointer
)	O
{	O
struct	O
category_closure	struct
clos	struct
;	O
if	O
(	O
pri	int
==	O
-	O
1	int
)	O
pri	int
=	O
GRAD_LOG_UPTO	O
(	O
GRAD_LOG_DEBUG	int
)	O
;	O
clos	struct
.	O
cat	int
=	O
cat	int
;	O
clos	struct
.	O
pri	int
=	O
pri	int
;	O
grad_list_iterate	function
(	O
clist	pointer
,	O
_regcat	function
,	O
&	O
clos	struct
)	O
;	O
}	O
void	O
log_set_to_console	function
(	O
int	O
cat	int
,	O
int	O
pri	int
)	O
{	O
Channel	struct
chan	pointer
;	O
chan	pointer
.	O
mode	int
=	O
LM_FILE	int
;	O
chan	pointer
.	O
name	pointer
=	O
"stdout"	pointer
;	O
chan	pointer
.	O
id	char
.	O
file	pointer
=	O
"stdout"	pointer
;	O
chan	pointer
.	O
options	int
=	O
LO_CAT	int
|	O
LO_PRI	int
|	O
LO_PERSIST	int
;	O
register_channel	function
(	O
&	O
chan	pointer
)	O
;	O
register_category0	function
(	O
cat	int
,	O
pri	int
,	O
channel_lookup	function
(	O
"stdout"	pointer
)	O
)	O
;	O
}	O
void	O
log_set_default	function
(	O
char	O
*	O
name	pointer
,	O
int	O
cat	int
,	O
int	O
pri	int
)	O
{	O
Channel	struct
chan	pointer
;	O
chan	pointer
.	O
mode	int
=	O
LM_FILE	int
;	O
chan	pointer
.	O
name	pointer
=	O
name	pointer
;	O
chan	pointer
.	O
id	char
.	O
file	pointer
=	O
"radius.log"	pointer
;	O
chan	pointer
.	O
options	int
=	O
LO_CAT	int
|	O
LO_PRI	int
;	O
chan	pointer
.	O
prefix_hook	pointer
=	O
chan	pointer
.	O
suffix_hook	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
channel_lookup	function
(	O
name	pointer
)	O
)	O
register_channel	function
(	O
&	O
chan	pointer
)	O
;	O
register_category0	function
(	O
cat	int
,	O
pri	int
,	O
channel_lookup	function
(	O
name	pointer
)	O
)	O
;	O
}	O
void	O
format_exit_status	function
(	O
char	O
*	O
buffer	pointer
,	O
int	O
buflen	int
,	O
int	O
status	int
)	O
{	O
if	O
(	O
WIFEXITED	O
(	O
status	int
)	O
)	O
{	O
snprintf	function
(	O
buffer	pointer
,	O
buflen	int
,	O
_	O
(	O
"exited with status %d"	pointer
)	O
,	O
WEXITSTATUS	O
(	O
status	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
WIFSIGNALED	O
(	O
status	int
)	O
)	O
{	O
snprintf	function
(	O
buffer	pointer
,	O
buflen	int
,	O
_	O
(	O
"terminated on signal %d"	pointer
)	O
,	O
WTERMSIG	O
(	O
status	int
)	O
)	O
;	O
}	O
else	O
snprintf	function
(	O
buffer	pointer
,	O
buflen	int
,	O
_	O
(	O
"terminated"	pointer
)	O
)	O
;	O
}	O
static	O
Channel	struct
*	O
mark	pointer
,	O
channel	struct
;	O
static	O
struct	O
category_def	struct
{	O
int	O
init	int
;	O
int	O
cat	int
;	O
int	O
pri	int
;	O
grad_list_t	struct
*	O
clist	pointer
;	O
int	O
level	int
;	O
}	O
cat_def	struct
;	O
static	O
grad_keyword_t	struct
syslog_facility	array
[	O
]	O
=	O
{	O
{	O
"user"	pointer
,	O
LOG_USER	O
}	O
,	O
{	O
"daemon"	pointer
,	O
LOG_DAEMON	O
}	O
,	O
{	O
"auth"	pointer
,	O
LOG_AUTH	O
}	O
,	O
{	O
"local0"	pointer
,	O
LOG_LOCAL0	O
}	O
,	O
{	O
"local1"	pointer
,	O
LOG_LOCAL1	O
}	O
,	O
{	O
"local2"	pointer
,	O
LOG_LOCAL2	O
}	O
,	O
{	O
"local3"	pointer
,	O
LOG_LOCAL3	O
}	O
,	O
{	O
"local4"	pointer
,	O
LOG_LOCAL4	O
}	O
,	O
{	O
"local5"	pointer
,	O
LOG_LOCAL5	O
}	O
,	O
{	O
"local6"	pointer
,	O
LOG_LOCAL6	O
}	O
,	O
{	O
"local7"	pointer
,	O
LOG_LOCAL7	O
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
grad_keyword_t	struct
syslog_priority	array
[	O
]	O
=	O
{	O
{	O
"emerg"	pointer
,	O
LOG_EMERG	int
}	O
,	O
{	O
"alert"	pointer
,	O
LOG_ALERT	int
}	O
,	O
{	O
"crit"	pointer
,	O
LOG_CRIT	int
}	O
,	O
{	O
"err"	pointer
,	O
LOG_ERR	int
}	O
,	O
{	O
"warning"	pointer
,	O
LOG_WARNING	int
}	O
,	O
{	O
"notice"	pointer
,	O
LOG_NOTICE	int
}	O
,	O
{	O
"info"	pointer
,	O
LOG_INFO	int
}	O
,	O
{	O
"debug"	pointer
,	O
LOG_DEBUG	int
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
grad_keyword_t	struct
log_categories	array
[	O
]	O
=	O
{	O
{	O
"main"	pointer
,	O
GRAD_LOG_MAIN	O
}	O
,	O
{	O
"auth"	pointer
,	O
GRAD_LOG_AUTH	O
}	O
,	O
{	O
"acct"	pointer
,	O
GRAD_LOG_ACCT	O
}	O
,	O
{	O
"snmp"	pointer
,	O
GRAD_LOG_SNMP	O
}	O
,	O
{	O
"proxy"	pointer
,	O
GRAD_LOG_PROXY	O
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
grad_keyword_t	struct
log_priorities	array
[	O
]	O
=	O
{	O
{	O
"emerg"	pointer
,	O
GRAD_LOG_EMERG	int
}	O
,	O
{	O
"alert"	pointer
,	O
GRAD_LOG_ALERT	int
}	O
,	O
{	O
"crit"	pointer
,	O
GRAD_LOG_CRIT	int
}	O
,	O
{	O
"err"	pointer
,	O
GRAD_LOG_ERR	int
}	O
,	O
{	O
"warning"	pointer
,	O
GRAD_LOG_WARN	int
}	O
,	O
{	O
"notice"	pointer
,	O
GRAD_LOG_NOTICE	int
}	O
,	O
{	O
"info"	pointer
,	O
GRAD_LOG_INFO	int
}	O
,	O
{	O
"debug"	pointer
,	O
GRAD_LOG_DEBUG	int
}	O
,	O
{	O
0	int
}	O
}	O
;	O
int	O
logging_stmt_handler	function
(	O
int	O
argc	int
,	O
cfg_value_t	struct
*	O
argv	pointer
,	O
void	O
*	O
block_data	pointer
,	O
void	O
*	O
handler_data	pointer
)	O
{	O
mark	pointer
=	O
log_mark	function
(	O
)	O
;	O
grad_free	function
(	O
log_prefix_hook	pointer
)	O
;	O
log_prefix_hook	pointer
=	O
NULL	O
;	O
grad_free	function
(	O
log_suffix_hook	pointer
)	O
;	O
log_suffix_hook	pointer
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
int	O
logging_stmt_end	function
(	O
void	O
*	O
block_data	pointer
,	O
void	O
*	O
handler_data	pointer
)	O
{	O
log_release	function
(	O
mark	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
logging_stmt_begin	function
(	O
int	O
finish	int
,	O
void	O
*	O
block_data	pointer
,	O
void	O
*	O
handler_data	pointer
)	O
{	O
return	O
0	int
;	O
}	O
static	O
int	O
channel_stmt_handler	function
(	O
int	O
argc	int
,	O
cfg_value_t	struct
*	O
argv	pointer
,	O
void	O
*	O
block_data	pointer
,	O
void	O
*	O
handler_data	pointer
)	O
{	O
if	O
(	O
argc	int
!=	O
2	int
)	O
{	O
cfg_argc_error	function
(	O
argc	int
<	O
2	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
argv	pointer
[	O
1	int
]	O
.	O
type	int
!=	O
CFG_STRING	int
)	O
{	O
cfg_type_error	function
(	O
CFG_STRING	int
)	O
;	O
return	O
0	int
;	O
}	O
memset	function
(	O
&	O
channel	struct
,	O
0	int
,	O
sizeof	O
(	O
channel	struct
)	O
)	O
;	O
channel	struct
.	O
mode	int
=	O
LM_UNKNOWN	O
;	O
channel	struct
.	O
name	pointer
=	O
argv	pointer
[	O
1	int
]	O
.	O
v	union
.	O
string	pointer
;	O
return	O
0	int
;	O
}	O
static	O
int	O
channel_stmt_end	function
(	O
void	O
*	O
block_data	pointer
,	O
void	O
*	O
handler_data	pointer
)	O
{	O
if	O
(	O
channel	struct
.	O
mode	int
==	O
LM_UNKNOWN	O
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"%s:%d: no channel mode for `%s'"	pointer
)	O
,	O
cfg_filename	pointer
,	O
cfg_line_num	int
,	O
channel	struct
.	O
name	pointer
)	O
;	O
}	O
else	O
register_channel	function
(	O
&	O
channel	struct
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
get_priority	function
(	O
cfg_value_t	struct
*	O
argv	pointer
)	O
{	O
if	O
(	O
argv	pointer
[	O
0	int
]	O
.	O
type	int
!=	O
CFG_CHAR	int
||	O
argv	pointer
[	O
1	int
]	O
.	O
type	int
!=	O
CFG_STRING	int
)	O
return	O
1	int
;	O
cat_def	struct
.	O
pri	int
=	O
grad_xlat_keyword	function
(	O
log_priorities	array
,	O
argv	pointer
[	O
1	int
]	O
.	O
v	union
.	O
string	pointer
,	O
-	O
1	int
)	O
;	O
if	O
(	O
cat_def	struct
.	O
pri	int
==	O
-	O
1	int
)	O
return	O
1	int
;	O
switch	O
(	O
argv	pointer
[	O
0	int
]	O
.	O
v	union
.	O
ch	char
)	O
{	O
case	O
'!'	O
:	O
cat_def	struct
.	O
pri	int
=	O
GRAD_LOG_UPTO	O
(	O
GRAD_LOG_DEBUG	int
)	O
&	O
~	O
GRAD_LOG_MASK	O
(	O
cat_def	struct
.	O
pri	int
)	O
;	O
break	O
;	O
case	O
'='	O
:	O
cat_def	struct
.	O
pri	int
=	O
GRAD_LOG_MASK	O
(	O
cat_def	struct
.	O
pri	int
)	O
;	O
break	O
;	O
default	O
:	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
category_stmt_handler	function
(	O
int	O
argc	int
,	O
cfg_value_t	struct
*	O
argv	pointer
,	O
void	O
*	O
block_data	pointer
,	O
void	O
*	O
handler_data	pointer
)	O
{	O
cat_def	struct
.	O
init	int
=	O
0	int
;	O
cat_def	struct
.	O
cat	int
=	O
cat_def	struct
.	O
pri	int
=	O
-	O
1	int
;	O
cat_def	struct
.	O
level	int
=	O
0	int
;	O
switch	O
(	O
argc	int
)	O
{	O
case	O
2	int
:	O
switch	O
(	O
argv	pointer
[	O
1	int
]	O
.	O
type	int
)	O
{	O
case	O
CFG_CHAR	int
:	O
if	O
(	O
argv	pointer
[	O
1	int
]	O
.	O
v	union
.	O
ch	char
==	O
'*'	O
)	O
cat_def	struct
.	O
cat	int
=	O
cat_def	struct
.	O
pri	int
=	O
-	O
1	int
;	O
else	O
return	O
1	int
;	O
break	O
;	O
case	O
CFG_STRING	int
:	O
cat_def	struct
.	O
cat	int
=	O
grad_xlat_keyword	function
(	O
log_categories	array
,	O
argv	pointer
[	O
1	int
]	O
.	O
v	union
.	O
string	pointer
,	O
-	O
1	int
)	O
;	O
if	O
(	O
cat_def	struct
.	O
cat	int
==	O
-	O
1	int
)	O
{	O
cat_def	struct
.	O
pri	int
=	O
grad_xlat_keyword	function
(	O
log_priorities	array
,	O
argv	pointer
[	O
1	int
]	O
.	O
v	union
.	O
string	pointer
,	O
-	O
1	int
)	O
;	O
if	O
(	O
cat_def	struct
.	O
pri	int
==	O
-	O
1	int
)	O
return	O
1	int
;	O
cat_def	struct
.	O
pri	int
=	O
GRAD_LOG_UPTO	O
(	O
cat_def	struct
.	O
pri	int
)	O
;	O
}	O
}	O
break	O
;	O
case	O
3	int
:	O
if	O
(	O
get_priority	function
(	O
argv	pointer
+	O
1	int
)	O
)	O
return	O
1	int
;	O
break	O
;	O
case	O
4	int
:	O
if	O
(	O
!	O
(	O
argv	pointer
[	O
2	int
]	O
.	O
type	int
==	O
CFG_CHAR	int
&&	O
argv	pointer
[	O
2	int
]	O
.	O
v	union
.	O
ch	char
==	O
'.'	O
)	O
)	O
return	O
1	int
;	O
switch	O
(	O
argv	pointer
[	O
1	int
]	O
.	O
type	int
)	O
{	O
case	O
CFG_CHAR	int
:	O
if	O
(	O
argv	pointer
[	O
1	int
]	O
.	O
v	union
.	O
ch	char
==	O
'*'	O
)	O
cat_def	struct
.	O
cat	int
=	O
-	O
1	int
;	O
else	O
return	O
1	int
;	O
break	O
;	O
case	O
CFG_STRING	int
:	O
cat_def	struct
.	O
cat	int
=	O
grad_xlat_keyword	function
(	O
log_categories	array
,	O
argv	pointer
[	O
1	int
]	O
.	O
v	union
.	O
string	pointer
,	O
-	O
1	int
)	O
;	O
if	O
(	O
cat_def	struct
.	O
cat	int
==	O
-	O
1	int
)	O
return	O
1	int
;	O
break	O
;	O
default	O
:	O
return	O
1	int
;	O
}	O
switch	O
(	O
argv	pointer
[	O
3	int
]	O
.	O
type	int
)	O
{	O
case	O
CFG_CHAR	int
:	O
if	O
(	O
argv	pointer
[	O
3	int
]	O
.	O
v	union
.	O
ch	char
==	O
'*'	O
)	O
cat_def	struct
.	O
pri	int
=	O
-	O
1	int
;	O
else	O
return	O
1	int
;	O
break	O
;	O
case	O
CFG_STRING	int
:	O
cat_def	struct
.	O
pri	int
=	O
grad_xlat_keyword	function
(	O
log_priorities	array
,	O
argv	pointer
[	O
3	int
]	O
.	O
v	union
.	O
string	pointer
,	O
-	O
1	int
)	O
;	O
if	O
(	O
cat_def	struct
.	O
pri	int
==	O
-	O
1	int
)	O
return	O
1	int
;	O
cat_def	struct
.	O
pri	int
=	O
GRAD_LOG_UPTO	O
(	O
cat_def	struct
.	O
pri	int
)	O
;	O
break	O
;	O
default	O
:	O
return	O
1	int
;	O
}	O
break	O
;	O
case	O
5	int
:	O
if	O
(	O
!	O
(	O
argv	pointer
[	O
2	int
]	O
.	O
type	int
==	O
CFG_CHAR	int
&&	O
argv	pointer
[	O
2	int
]	O
.	O
v	union
.	O
ch	char
==	O
'.'	O
)	O
)	O
return	O
1	int
;	O
switch	O
(	O
argv	pointer
[	O
1	int
]	O
.	O
type	int
)	O
{	O
case	O
CFG_CHAR	int
:	O
if	O
(	O
argv	pointer
[	O
1	int
]	O
.	O
v	union
.	O
ch	char
==	O
'*'	O
)	O
cat_def	struct
.	O
cat	int
=	O
-	O
1	int
;	O
else	O
return	O
1	int
;	O
break	O
;	O
case	O
CFG_STRING	int
:	O
cat_def	struct
.	O
cat	int
=	O
grad_xlat_keyword	function
(	O
log_categories	array
,	O
argv	pointer
[	O
1	int
]	O
.	O
v	union
.	O
string	pointer
,	O
-	O
1	int
)	O
;	O
if	O
(	O
cat_def	struct
.	O
cat	int
==	O
-	O
1	int
)	O
return	O
1	int
;	O
break	O
;	O
default	O
:	O
return	O
1	int
;	O
}	O
if	O
(	O
get_priority	function
(	O
argv	pointer
+	O
3	int
)	O
)	O
return	O
1	int
;	O
break	O
;	O
default	O
:	O
cfg_argc_error	function
(	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
cat_def	struct
.	O
init	int
=	O
1	int
;	O
cat_def	struct
.	O
clist	pointer
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
category_stmt_end	function
(	O
void	O
*	O
block_data	pointer
,	O
void	O
*	O
handler_data	pointer
)	O
{	O
if	O
(	O
cat_def	struct
.	O
init	int
)	O
{	O
switch	O
(	O
cat_def	struct
.	O
cat	int
)	O
{	O
case	O
GRAD_LOG_AUTH	O
:	O
log_mode	int
=	O
cat_def	struct
.	O
level	int
;	O
break	O
;	O
default	O
:	O
if	O
(	O
cat_def	struct
.	O
level	int
)	O
grad_log	function
(	O
GRAD_LOG_WARN	int
,	O
"%s:%d: %s"	pointer
,	O
cfg_filename	pointer
,	O
cfg_line_num	int
,	O
_	O
(	O
"no levels applicable for this category"	pointer
)	O
)	O
;	O
}	O
register_category	function
(	O
cat_def	struct
.	O
cat	int
,	O
cat_def	struct
.	O
pri	int
,	O
cat_def	struct
.	O
clist	pointer
)	O
;	O
grad_list_destroy	function
(	O
&	O
cat_def	struct
.	O
clist	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
category_set_channel	function
(	O
int	O
argc	int
,	O
cfg_value_t	struct
*	O
argv	pointer
,	O
void	O
*	O
block_data	pointer
,	O
void	O
*	O
handler_data	pointer
)	O
{	O
Channel	struct
*	O
channel	struct
;	O
if	O
(	O
argc	int
!=	O
2	int
)	O
{	O
cfg_argc_error	function
(	O
argc	int
<	O
2	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
argv	pointer
[	O
1	int
]	O
.	O
type	int
!=	O
CFG_STRING	int
)	O
{	O
cfg_type_error	function
(	O
CFG_STRING	int
)	O
;	O
return	O
0	int
;	O
}	O
channel	struct
=	O
channel_lookup	function
(	O
argv	pointer
[	O
1	int
]	O
.	O
v	union
.	O
string	pointer
)	O
;	O
if	O
(	O
!	O
channel	struct
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"%s:%d: channel `%s' not defined"	pointer
)	O
,	O
cfg_filename	pointer
,	O
cfg_line_num	int
,	O
argv	pointer
[	O
1	int
]	O
.	O
v	union
.	O
string	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
cat_def	struct
.	O
clist	pointer
)	O
cat_def	struct
.	O
clist	pointer
=	O
grad_list_create	function
(	O
)	O
;	O
grad_list_append	function
(	O
cat_def	struct
.	O
clist	pointer
,	O
channel	struct
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
category_set_flag	function
(	O
int	O
argc	int
,	O
cfg_value_t	struct
*	O
argv	pointer
,	O
void	O
*	O
block_data	pointer
,	O
void	O
*	O
handler_data	pointer
)	O
{	O
int	O
flag	int
=	O
(	O
int	O
)	O
handler_data	pointer
;	O
if	O
(	O
argc	int
!=	O
2	int
)	O
{	O
cfg_argc_error	function
(	O
argc	int
<	O
2	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
argv	pointer
[	O
1	int
]	O
.	O
type	int
!=	O
CFG_BOOLEAN	int
)	O
{	O
cfg_type_error	function
(	O
CFG_BOOLEAN	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
argv	pointer
[	O
1	int
]	O
.	O
v	union
.	O
bool	int
)	O
cat_def	struct
.	O
level	int
|=	O
flag	int
;	O
else	O
cat_def	struct
.	O
level	int
&=	O
~	O
flag	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
category_set_level	function
(	O
int	O
argc	int
,	O
cfg_value_t	struct
*	O
argv	pointer
,	O
void	O
*	O
block_data	pointer
,	O
void	O
*	O
handler_data	pointer
)	O
{	O
int	O
i	int
;	O
grad_clear_debug	function
(	O
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
)	O
{	O
char	O
*	O
modname	pointer
;	O
int	O
level	int
;	O
if	O
(	O
argv	pointer
[	O
i	int
]	O
.	O
type	int
!=	O
CFG_STRING	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"%s:%d: list item %d has wrong datatype"	pointer
)	O
,	O
cfg_filename	pointer
,	O
cfg_line_num	int
,	O
i	int
)	O
;	O
return	O
1	int
;	O
}	O
modname	pointer
=	O
argv	pointer
[	O
i	int
++	O
]	O
.	O
v	union
.	O
string	pointer
;	O
level	int
=	O
-	O
1	int
;	O
if	O
(	O
i	int
<	O
argc	int
&&	O
argv	pointer
[	O
i	int
]	O
.	O
type	int
==	O
CFG_CHAR	int
&&	O
argv	pointer
[	O
i	int
]	O
.	O
v	union
.	O
ch	char
==	O
'='	O
)	O
{	O
i	int
++	O
;	O
if	O
(	O
i	int
==	O
argc	int
||	O
argv	pointer
[	O
i	int
]	O
.	O
type	int
!=	O
CFG_INTEGER	int
)	O
return	O
1	int
;	O
level	int
=	O
argv	pointer
[	O
i	int
++	O
]	O
.	O
v	union
.	O
number	long
;	O
}	O
if	O
(	O
grad_set_module_debug_level	function
(	O
modname	pointer
,	O
level	int
)	O
)	O
{	O
grad_log	function
(	O
GRAD_LOG_WARN	int
,	O
_	O
(	O
"%s:%d: no such module name: %s"	pointer
)	O
,	O
cfg_filename	pointer
,	O
cfg_line_num	int
,	O
modname	pointer
)	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
channel_file_handler	function
(	O
int	O
argc	int
,	O
cfg_value_t	struct
*	O
argv	pointer
,	O
void	O
*	O
block_data	pointer
,	O
void	O
*	O
handler_data	pointer
)	O
{	O
if	O
(	O
argc	int
!=	O
2	int
)	O
{	O
cfg_argc_error	function
(	O
argc	int
<	O
2	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
argv	pointer
[	O
1	int
]	O
.	O
type	int
!=	O
CFG_STRING	int
)	O
{	O
cfg_type_error	function
(	O
CFG_STRING	int
)	O
;	O
return	O
0	int
;	O
}	O
channel	struct
.	O
mode	int
=	O
LM_FILE	int
;	O
channel	struct
.	O
id	char
.	O
file	pointer
=	O
argv	pointer
[	O
1	int
]	O
.	O
v	union
.	O
string	pointer
;	O
return	O
0	int
;	O
}	O
static	O
int	O
channel_syslog_handler	function
(	O
int	O
argc	int
,	O
cfg_value_t	struct
*	O
argv	pointer
,	O
void	O
*	O
block_data	pointer
,	O
void	O
*	O
handler_data	pointer
)	O
{	O
int	O
facility	int
;	O
int	O
prio	int
;	O
if	O
(	O
argc	int
<	O
4	int
||	O
argc	int
>	O
5	int
)	O
{	O
cfg_argc_error	function
(	O
argc	int
<	O
4	int
)	O
;	O
return	O
0	int
;	O
}	O
switch	O
(	O
argv	pointer
[	O
1	int
]	O
.	O
type	int
)	O
{	O
case	O
CFG_INTEGER	int
:	O
facility	int
=	O
argv	pointer
[	O
1	int
]	O
.	O
v	union
.	O
number	long
;	O
break	O
;	O
case	O
CFG_STRING	int
:	O
facility	int
=	O
grad_xlat_keyword	function
(	O
syslog_facility	array
,	O
argv	pointer
[	O
1	int
]	O
.	O
v	union
.	O
string	pointer
,	O
-	O
1	int
)	O
;	O
break	O
;	O
default	O
:	O
return	O
1	int
;	O
}	O
if	O
(	O
facility	int
==	O
-	O
1	int
)	O
return	O
1	int
;	O
if	O
(	O
argv	pointer
[	O
2	int
]	O
.	O
type	int
!=	O
CFG_CHAR	int
||	O
argv	pointer
[	O
2	int
]	O
.	O
v	union
.	O
ch	char
!=	O
'.'	O
)	O
return	O
1	int
;	O
switch	O
(	O
argv	pointer
[	O
3	int
]	O
.	O
type	int
)	O
{	O
case	O
CFG_INTEGER	int
:	O
prio	int
=	O
argv	pointer
[	O
3	int
]	O
.	O
v	union
.	O
number	long
;	O
break	O
;	O
case	O
CFG_STRING	int
:	O
prio	int
=	O
grad_xlat_keyword	function
(	O
syslog_priority	array
,	O
argv	pointer
[	O
3	int
]	O
.	O
v	union
.	O
string	pointer
,	O
-	O
1	int
)	O
;	O
break	O
;	O
default	O
:	O
return	O
1	int
;	O
}	O
if	O
(	O
prio	int
==	O
-	O
1	int
)	O
return	O
1	int
;	O
if	O
(	O
argc	int
==	O
5	int
)	O
{	O
if	O
(	O
argv	pointer
[	O
4	int
]	O
.	O
type	int
!=	O
CFG_STRING	int
)	O
{	O
cfg_type_error	function
(	O
CFG_STRING	int
)	O
;	O
return	O
0	int
;	O
}	O
channel	struct
.	O
id	char
.	O
sl	struct
.	O
tag	char
=	O
argv	pointer
[	O
4	int
]	O
.	O
v	union
.	O
string	pointer
;	O
}	O
else	O
channel	struct
.	O
id	char
.	O
sl	struct
.	O
tag	char
=	O
NULL	O
;	O
channel	struct
.	O
mode	int
=	O
LM_SYSLOG	int
;	O
channel	struct
.	O
id	char
.	O
sl	struct
.	O
prio	int
=	O
prio	int
;	O
channel	struct
.	O
id	char
.	O
sl	struct
.	O
fac	int
=	O
facility	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
channel_set_flag	function
(	O
int	O
argc	int
,	O
cfg_value_t	struct
*	O
argv	pointer
,	O
void	O
*	O
block_data	pointer
,	O
void	O
*	O
handler_data	pointer
)	O
{	O
int	O
flag	int
=	O
(	O
int	O
)	O
handler_data	pointer
;	O
if	O
(	O
argc	int
!=	O
2	int
)	O
{	O
cfg_argc_error	function
(	O
argc	int
<	O
2	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
argv	pointer
[	O
1	int
]	O
.	O
type	int
!=	O
CFG_BOOLEAN	int
)	O
{	O
cfg_type_error	function
(	O
CFG_BOOLEAN	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
argv	pointer
[	O
1	int
]	O
.	O
v	union
.	O
bool	int
)	O
channel	struct
.	O
options	int
|=	O
flag	int
;	O
else	O
channel	struct
.	O
options	int
&=	O
~	O
flag	int
;	O
return	O
0	int
;	O
}	O
static	O
struct	O
cfg_stmt	struct
channel_stmt	array
[	O
]	O
=	O
{	O
{	O
"file"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
channel_file_handler	function
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"syslog"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
channel_syslog_handler	function
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"print-pid"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
channel_set_flag	function
,	O
(	O
void	O
*	O
)	O
LO_PID	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"print-cons"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
channel_set_flag	function
,	O
(	O
void	O
*	O
)	O
LO_CONS	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"print-level"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
channel_set_flag	function
,	O
(	O
void	O
*	O
)	O
LO_PRI	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"print-category"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
channel_set_flag	function
,	O
(	O
void	O
*	O
)	O
LO_CAT	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"print-priority"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
channel_set_flag	function
,	O
(	O
void	O
*	O
)	O
LO_PRI	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"print-milliseconds"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
channel_set_flag	function
,	O
(	O
void	O
*	O
)	O
LO_MSEC	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"prefix-hook"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_string	function
,	O
&	O
channel	struct
.	O
prefix_hook	pointer
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"suffix-hook"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_string	function
,	O
&	O
channel	struct
.	O
suffix_hook	pointer
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
struct	O
cfg_stmt	struct
category_stmt	array
[	O
]	O
=	O
{	O
{	O
"channel"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
category_set_channel	function
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"print-auth"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
category_set_flag	function
,	O
(	O
void	O
*	O
)	O
RLOG_AUTH	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"print-failed-pass"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
category_set_flag	function
,	O
(	O
void	O
*	O
)	O
RLOG_FAILED_PASS	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"print-pass"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
category_set_flag	function
,	O
(	O
void	O
*	O
)	O
RLOG_AUTH_PASS	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"level"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
category_set_level	function
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
struct	O
cfg_stmt	struct
logging_stmt	array
[	O
]	O
=	O
{	O
{	O
"channel"	pointer
,	O
CS_BLOCK	int
,	O
NULL	O
,	O
channel_stmt_handler	function
,	O
NULL	O
,	O
channel_stmt	array
,	O
channel_stmt_end	function
}	O
,	O
{	O
"category"	pointer
,	O
CS_BLOCK	int
,	O
NULL	O
,	O
category_stmt_handler	function
,	O
NULL	O
,	O
category_stmt	array
,	O
category_stmt_end	function
}	O
,	O
{	O
"prefix-hook"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_string	function
,	O
&	O
log_prefix_hook	pointer
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"suffix-hook"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_string	function
,	O
&	O
log_suffix_hook	pointer
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
NULL	O
}	O
,	O
}	O
;	O
