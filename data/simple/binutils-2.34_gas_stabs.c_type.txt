int	O
outputting_stabs_line_debug	int
=	O
0	int
;	O
static	O
void	O
generate_asm_file	function
(	O
int	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
in_dot_func_p	int
=	O
FALSE	int
;	O
static	O
const	O
char	O
*	O
current_function_label	pointer
;	O
unsigned	O
int	O
get_stab_string_offset	function
(	O
const	O
char	O
*	O
string	pointer
,	O
const	O
char	O
*	O
stabstr_secname	pointer
,	O
bfd_boolean	int
free_stabstr_secname	int
)	O
{	O
unsigned	O
int	O
length	char
;	O
unsigned	O
int	O
retval	pointer
;	O
segT	pointer
save_seg	pointer
;	O
subsegT	int
save_subseg	int
;	O
segT	pointer
seg	pointer
;	O
char	O
*	O
p	pointer
;	O
if	O
(	O
!	O
SEPARATE_STAB_SECTIONS	int
)	O
abort	function
(	O
)	O
;	O
length	char
=	O
strlen	function
(	O
string	pointer
)	O
;	O
save_seg	pointer
=	O
now_seg	pointer
;	O
save_subseg	int
=	O
now_subseg	int
;	O
seg	pointer
=	O
subseg_new	function
(	O
stabstr_secname	pointer
,	O
0	int
)	O
;	O
if	O
(	O
free_stabstr_secname	int
&&	O
seg	pointer
->	O
name	pointer
!=	O
stabstr_secname	pointer
)	O
free	function
(	O
(	O
char	O
*	O
)	O
stabstr_secname	pointer
)	O
;	O
retval	pointer
=	O
seg_info	O
(	O
seg	pointer
)	O
->	O
stabu	union
.	O
stab_string_size	long
;	O
if	O
(	O
retval	pointer
<=	O
0	int
)	O
{	O
p	pointer
=	O
frag_more	function
(	O
1	int
)	O
;	O
*	O
p	pointer
=	O
0	int
;	O
retval	pointer
=	O
seg_info	O
(	O
seg	pointer
)	O
->	O
stabu	union
.	O
stab_string_size	long
=	O
1	int
;	O
bfd_set_section_flags	function
(	O
seg	pointer
,	O
SEC_READONLY	int
|	O
SEC_DEBUGGING	int
)	O
;	O
}	O
if	O
(	O
length	char
>	O
0	int
)	O
{	O
p	pointer
=	O
frag_more	function
(	O
length	char
+	O
1	int
)	O
;	O
strcpy	function
(	O
p	pointer
,	O
string	pointer
)	O
;	O
seg_info	O
(	O
seg	pointer
)	O
->	O
stabu	union
.	O
stab_string_size	long
+=	O
length	char
+	O
1	int
;	O
}	O
else	O
retval	pointer
=	O
0	int
;	O
subseg_set	function
(	O
save_seg	pointer
,	O
save_subseg	int
)	O
;	O
return	O
retval	pointer
;	O
}	O
static	O
void	O
s_stab_generic	function
(	O
int	O
what	int
,	O
const	O
char	O
*	O
stab_secname	pointer
,	O
const	O
char	O
*	O
stabstr_secname	pointer
,	O
const	O
char	O
*	O
stab_secname_obstack_end	pointer
)	O
{	O
long	O
longint	long
;	O
const	O
char	O
*	O
string	pointer
;	O
char	O
*	O
saved_string_obstack_end	pointer
;	O
int	O
type	char
;	O
int	O
other	int
;	O
int	O
desc	int
;	O
if	O
(	O
what	int
!=	O
's'	O
)	O
{	O
string	pointer
=	O
""	pointer
;	O
saved_string_obstack_end	pointer
=	O
0	int
;	O
}	O
else	O
{	O
int	O
length	char
;	O
string	pointer
=	O
demand_copy_C_string	function
(	O
&	O
length	char
)	O
;	O
if	O
(	O
string	pointer
==	O
NULL	O
)	O
{	O
as_warn	function
(	O
_	O
(	O
".stab%c: missing string"	pointer
)	O
,	O
what	int
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
saved_string_obstack_end	pointer
=	O
obstack_next_free	O
(	O
&	O
notes	struct
)	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	pointer
==	O
','	O
)	O
input_line_pointer	pointer
++	O
;	O
else	O
{	O
as_warn	function
(	O
_	O
(	O
".stab%c: missing comma"	pointer
)	O
,	O
what	int
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
}	O
if	O
(	O
get_absolute_expression_and_terminator	function
(	O
&	O
longint	long
)	O
!=	O
','	O
)	O
{	O
as_warn	function
(	O
_	O
(	O
".stab%c: missing comma"	pointer
)	O
,	O
what	int
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
type	char
=	O
longint	long
;	O
if	O
(	O
get_absolute_expression_and_terminator	function
(	O
&	O
longint	long
)	O
!=	O
','	O
)	O
{	O
as_warn	function
(	O
_	O
(	O
".stab%c: missing comma"	pointer
)	O
,	O
what	int
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
other	int
=	O
longint	long
;	O
desc	int
=	O
get_absolute_expression	function
(	O
)	O
;	O
if	O
(	O
(	O
desc	int
>	O
0xffff	int
)	O
||	O
(	O
desc	int
<	O
-	O
0x8000	int
)	O
)	O
as_warn	function
(	O
_	O
(	O
".stab%c: description field '%x' too big, try a different debug format"	pointer
)	O
,	O
what	int
,	O
desc	int
)	O
;	O
if	O
(	O
what	int
==	O
's'	O
||	O
what	int
==	O
'n'	O
)	O
{	O
if	O
(	O
*	O
input_line_pointer	pointer
!=	O
','	O
)	O
{	O
as_warn	function
(	O
_	O
(	O
".stab%c: missing comma"	pointer
)	O
,	O
what	int
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
input_line_pointer	pointer
++	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
}	O
if	O
(	O
listing	int
)	O
{	O
switch	O
(	O
type	char
)	O
{	O
case	O
N_SLINE	int
:	O
listing_source_line	function
(	O
(	O
unsigned	O
int	O
)	O
desc	int
)	O
;	O
break	O
;	O
case	O
N_SO	int
:	O
case	O
N_SOL	int
:	O
listing_source_file	function
(	O
string	pointer
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
SEPARATE_STAB_SECTIONS	int
)	O
{	O
segT	pointer
saved_seg	pointer
=	O
now_seg	pointer
;	O
subsegT	int
saved_subseg	int
=	O
now_subseg	int
;	O
fragS	struct
*	O
saved_frag	pointer
=	O
frag_now	pointer
;	O
valueT	long
dot	pointer
;	O
segT	pointer
seg	pointer
;	O
unsigned	O
int	O
stroff	int
;	O
char	O
*	O
p	pointer
;	O
static	O
segT	pointer
cached_sec	pointer
;	O
dot	pointer
=	O
frag_now_fix	function
(	O
)	O
;	O
if	O
(	O
cached_sec	pointer
&&	O
strcmp	function
(	O
cached_sec	pointer
->	O
name	pointer
,	O
stab_secname	pointer
)	O
==	O
0	int
)	O
{	O
seg	pointer
=	O
cached_sec	pointer
;	O
subseg_set	function
(	O
seg	pointer
,	O
0	int
)	O
;	O
}	O
else	O
{	O
seg	pointer
=	O
subseg_new	function
(	O
stab_secname	pointer
,	O
0	int
)	O
;	O
cached_sec	pointer
=	O
seg	pointer
;	O
}	O
if	O
(	O
!	O
seg_info	O
(	O
seg	pointer
)	O
->	O
hadone	int
)	O
{	O
bfd_set_section_flags	function
(	O
seg	pointer
,	O
SEC_READONLY	int
|	O
SEC_RELOC	int
|	O
SEC_DEBUGGING	int
)	O
;	O
INIT_STAB_SECTION	O
(	O
seg	pointer
)	O
;	O
seg_info	O
(	O
seg	pointer
)	O
->	O
hadone	int
=	O
1	int
;	O
}	O
stroff	int
=	O
get_stab_string_offset	function
(	O
string	pointer
,	O
stabstr_secname	pointer
,	O
stab_secname_obstack_end	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
saved_string_obstack_end	pointer
!=	O
NULL	O
&&	O
saved_string_obstack_end	pointer
==	O
obstack_next_free	O
(	O
&	O
notes	struct
)	O
)	O
obstack_free	O
(	O
&	O
notes	struct
,	O
string	pointer
)	O
;	O
if	O
(	O
seg	pointer
->	O
name	pointer
!=	O
stab_secname	pointer
&&	O
stab_secname_obstack_end	pointer
!=	O
NULL	O
&&	O
stab_secname_obstack_end	pointer
==	O
obstack_next_free	O
(	O
&	O
notes	struct
)	O
)	O
obstack_free	O
(	O
&	O
notes	struct
,	O
stab_secname	pointer
)	O
;	O
p	pointer
=	O
frag_more	function
(	O
8	int
)	O
;	O
md_number_to_chars	O
(	O
p	pointer
,	O
(	O
valueT	long
)	O
stroff	int
,	O
4	int
)	O
;	O
md_number_to_chars	O
(	O
p	pointer
+	O
4	int
,	O
(	O
valueT	long
)	O
type	char
,	O
1	int
)	O
;	O
md_number_to_chars	O
(	O
p	pointer
+	O
5	int
,	O
(	O
valueT	long
)	O
other	int
,	O
1	int
)	O
;	O
md_number_to_chars	O
(	O
p	pointer
+	O
6	int
,	O
(	O
valueT	long
)	O
desc	int
,	O
2	int
)	O
;	O
if	O
(	O
what	int
==	O
's'	O
||	O
what	int
==	O
'n'	O
)	O
{	O
cons	function
(	O
4	int
)	O
;	O
input_line_pointer	pointer
--	O
;	O
}	O
else	O
{	O
symbolS	struct
*	O
symbol	pointer
;	O
expressionS	struct
exp	pointer
;	O
symbol	pointer
=	O
symbol_temp_new	function
(	O
saved_seg	pointer
,	O
dot	pointer
,	O
saved_frag	pointer
)	O
;	O
exp	pointer
.	O
X_op	enum
=	O
O_symbol	int
;	O
exp	pointer
.	O
X_add_symbol	pointer
=	O
symbol	pointer
;	O
exp	pointer
.	O
X_add_number	long
=	O
0	int
;	O
emit_expr	function
(	O
&	O
exp	pointer
,	O
4	int
)	O
;	O
}	O
subseg_set	function
(	O
saved_seg	pointer
,	O
saved_subseg	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
stab_secname_obstack_end	pointer
!=	O
NULL	O
)	O
{	O
free	function
(	O
(	O
char	O
*	O
)	O
stabstr_secname	pointer
)	O
;	O
if	O
(	O
stab_secname_obstack_end	pointer
==	O
obstack_next_free	O
(	O
&	O
notes	struct
)	O
)	O
obstack_free	O
(	O
&	O
notes	struct
,	O
stab_secname	pointer
)	O
;	O
}	O
abort	function
(	O
)	O
;	O
}	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
}	O
void	O
s_stab	function
(	O
int	O
what	int
)	O
{	O
s_stab_generic	function
(	O
what	int
,	O
STAB_SECTION_NAME	pointer
,	O
STAB_STRING_SECTION_NAME	pointer
,	O
NULL	O
)	O
;	O
}	O
void	O
s_xstab	function
(	O
int	O
what	int
)	O
{	O
int	O
length	char
;	O
char	O
*	O
stab_secname	pointer
,	O
*	O
stabstr_secname	pointer
,	O
*	O
stab_secname_obstack_end	pointer
;	O
stab_secname	pointer
=	O
demand_copy_C_string	function
(	O
&	O
length	char
)	O
;	O
stab_secname_obstack_end	pointer
=	O
obstack_next_free	O
(	O
&	O
notes	struct
)	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	pointer
==	O
','	O
)	O
input_line_pointer	pointer
++	O
;	O
else	O
{	O
as_bad	function
(	O
_	O
(	O
"comma missing in .xstabs"	pointer
)	O
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
stabstr_secname	pointer
=	O
concat	function
(	O
stab_secname	pointer
,	O
"str"	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
s_stab_generic	function
(	O
what	int
,	O
stab_secname	pointer
,	O
stabstr_secname	pointer
,	O
stab_secname_obstack_end	pointer
)	O
;	O
}	O
void	O
stabs_generate_asm_file	function
(	O
void	O
)	O
{	O
const	O
char	O
*	O
file	pointer
;	O
unsigned	O
int	O
lineno	pointer
;	O
file	pointer
=	O
as_where	function
(	O
&	O
lineno	pointer
)	O
;	O
if	O
(	O
use_gnu_debug_info_extensions	int
)	O
{	O
const	O
char	O
*	O
dir	pointer
;	O
char	O
*	O
dir2	pointer
;	O
dir	pointer
=	O
remap_debug_filename	function
(	O
getpwd	function
(	O
)	O
)	O
;	O
dir2	pointer
=	O
concat	function
(	O
dir	pointer
,	O
"/"	pointer
,	O
NULL	O
)	O
;	O
generate_asm_file	function
(	O
N_SO	int
,	O
dir2	pointer
)	O
;	O
free	function
(	O
dir2	pointer
)	O
;	O
xfree	O
(	O
(	O
char	O
*	O
)	O
dir	pointer
)	O
;	O
}	O
generate_asm_file	function
(	O
N_SO	int
,	O
file	pointer
)	O
;	O
}	O
static	O
void	O
generate_asm_file	function
(	O
int	O
type	char
,	O
const	O
char	O
*	O
file	pointer
)	O
{	O
static	O
char	O
*	O
last_file	pointer
;	O
static	O
int	O
label_count	int
;	O
char	O
sym	pointer
[	O
30	int
]	O
;	O
char	O
*	O
buf	pointer
;	O
const	O
char	O
*	O
tmp	pointer
=	O
file	pointer
;	O
const	O
char	O
*	O
file_endp	pointer
=	O
file	pointer
+	O
strlen	function
(	O
file	pointer
)	O
;	O
char	O
*	O
bufp	pointer
;	O
if	O
(	O
last_file	pointer
!=	O
NULL	O
&&	O
filename_cmp	function
(	O
last_file	pointer
,	O
file	pointer
)	O
==	O
0	int
)	O
return	O
;	O
sprintf	function
(	O
sym	pointer
,	O
"%sF%d"	pointer
,	O
FAKE_LABEL_NAME	pointer
,	O
label_count	int
)	O
;	O
++	O
label_count	int
;	O
bufp	pointer
=	O
buf	pointer
=	O
XNEWVEC	O
(	O
char	O
,	O
2	int
*	O
strlen	function
(	O
file	pointer
)	O
+	O
strlen	function
(	O
sym	pointer
)	O
+	O
12	int
)	O
;	O
*	O
bufp	pointer
++	O
=	O
'"'	O
;	O
while	O
(	O
tmp	pointer
<	O
file_endp	pointer
)	O
{	O
const	O
char	O
*	O
bslash	pointer
=	O
strchr	function
(	O
tmp	pointer
,	O
'\\'	O
)	O
;	O
size_t	long
len	long
=	O
bslash	pointer
!=	O
NULL	O
?	O
bslash	pointer
-	O
tmp	pointer
+	O
1	int
:	O
file_endp	pointer
-	O
tmp	pointer
;	O
memcpy	function
(	O
bufp	pointer
,	O
tmp	pointer
,	O
len	long
)	O
;	O
tmp	pointer
+=	O
len	long
;	O
bufp	pointer
+=	O
len	long
;	O
if	O
(	O
bslash	pointer
!=	O
NULL	O
)	O
*	O
bufp	pointer
++	O
=	O
'\\'	O
;	O
}	O
sprintf	function
(	O
bufp	pointer
,	O
"\",%d,0,0,%s\n"	pointer
,	O
type	char
,	O
sym	pointer
)	O
;	O
temp_ilp	function
(	O
buf	pointer
)	O
;	O
s_stab	function
(	O
's'	O
)	O
;	O
restore_ilp	function
(	O
)	O
;	O
colon	function
(	O
sym	pointer
)	O
;	O
if	O
(	O
last_file	pointer
!=	O
NULL	O
)	O
free	function
(	O
last_file	pointer
)	O
;	O
last_file	pointer
=	O
xstrdup	function
(	O
file	pointer
)	O
;	O
free	function
(	O
buf	pointer
)	O
;	O
}	O
void	O
stabs_generate_asm_lineno	function
(	O
void	O
)	O
{	O
static	O
int	O
label_count	int
;	O
const	O
char	O
*	O
file	pointer
;	O
unsigned	O
int	O
lineno	pointer
;	O
char	O
*	O
buf	pointer
;	O
char	O
sym	pointer
[	O
30	int
]	O
;	O
static	O
unsigned	O
int	O
prev_lineno	int
=	O
-	O
1	int
;	O
static	O
char	O
*	O
prev_file	pointer
=	O
NULL	O
;	O
file	pointer
=	O
as_where	function
(	O
&	O
lineno	pointer
)	O
;	O
if	O
(	O
prev_file	pointer
==	O
NULL	O
)	O
{	O
prev_file	pointer
=	O
xstrdup	function
(	O
file	pointer
)	O
;	O
prev_lineno	int
=	O
lineno	pointer
;	O
}	O
else	O
if	O
(	O
lineno	pointer
==	O
prev_lineno	int
&&	O
filename_cmp	function
(	O
file	pointer
,	O
prev_file	pointer
)	O
==	O
0	int
)	O
{	O
return	O
;	O
}	O
else	O
{	O
prev_lineno	int
=	O
lineno	pointer
;	O
if	O
(	O
filename_cmp	function
(	O
file	pointer
,	O
prev_file	pointer
)	O
!=	O
0	int
)	O
{	O
free	function
(	O
prev_file	pointer
)	O
;	O
prev_file	pointer
=	O
xstrdup	function
(	O
file	pointer
)	O
;	O
}	O
}	O
outputting_stabs_line_debug	int
=	O
1	int
;	O
generate_asm_file	function
(	O
N_SOL	int
,	O
file	pointer
)	O
;	O
sprintf	function
(	O
sym	pointer
,	O
"%sL%d"	pointer
,	O
FAKE_LABEL_NAME	pointer
,	O
label_count	int
)	O
;	O
++	O
label_count	int
;	O
if	O
(	O
in_dot_func_p	int
)	O
{	O
buf	pointer
=	O
XNEWVEC	O
(	O
char	O
,	O
100	int
+	O
strlen	function
(	O
current_function_label	pointer
)	O
)	O
;	O
sprintf	function
(	O
buf	pointer
,	O
"%d,0,%d,%s-%s\n"	pointer
,	O
N_SLINE	int
,	O
lineno	pointer
,	O
sym	pointer
,	O
current_function_label	pointer
)	O
;	O
}	O
else	O
{	O
buf	pointer
=	O
XNEWVEC	O
(	O
char	O
,	O
100	int
)	O
;	O
sprintf	function
(	O
buf	pointer
,	O
"%d,0,%d,%s\n"	pointer
,	O
N_SLINE	int
,	O
lineno	pointer
,	O
sym	pointer
)	O
;	O
}	O
temp_ilp	function
(	O
buf	pointer
)	O
;	O
s_stab	function
(	O
'n'	O
)	O
;	O
restore_ilp	function
(	O
)	O
;	O
colon	function
(	O
sym	pointer
)	O
;	O
outputting_stabs_line_debug	int
=	O
0	int
;	O
free	function
(	O
buf	pointer
)	O
;	O
}	O
void	O
stabs_generate_asm_func	function
(	O
const	O
char	O
*	O
funcname	pointer
,	O
const	O
char	O
*	O
startlabname	pointer
)	O
{	O
static	O
bfd_boolean	int
void_emitted_p	int
=	O
FALSE	int
;	O
char	O
*	O
buf	pointer
;	O
unsigned	O
int	O
lineno	pointer
;	O
if	O
(	O
!	O
void_emitted_p	int
)	O
{	O
temp_ilp	function
(	O
(	O
char	O
*	O
)	O
"\"void:t1=1\",128,0,0,0"	pointer
)	O
;	O
s_stab	function
(	O
's'	O
)	O
;	O
restore_ilp	function
(	O
)	O
;	O
void_emitted_p	int
=	O
TRUE	int
;	O
}	O
as_where	function
(	O
&	O
lineno	pointer
)	O
;	O
if	O
(	O
asprintf	function
(	O
&	O
buf	pointer
,	O
"\"%s:F1\",%d,0,%d,%s"	pointer
,	O
funcname	pointer
,	O
N_FUN	int
,	O
lineno	pointer
+	O
1	int
,	O
startlabname	pointer
)	O
==	O
-	O
1	int
)	O
as_fatal	function
(	O
"%s"	pointer
,	O
xstrerror	function
(	O
errno	O
)	O
)	O
;	O
temp_ilp	function
(	O
buf	pointer
)	O
;	O
s_stab	function
(	O
's'	O
)	O
;	O
restore_ilp	function
(	O
)	O
;	O
free	function
(	O
buf	pointer
)	O
;	O
current_function_label	pointer
=	O
xstrdup	function
(	O
startlabname	pointer
)	O
;	O
in_dot_func_p	int
=	O
TRUE	int
;	O
}	O
void	O
stabs_generate_asm_endfunc	function
(	O
const	O
char	O
*	O
funcname	pointer
ATTRIBUTE_UNUSED	O
,	O
const	O
char	O
*	O
startlabname	pointer
)	O
{	O
static	O
int	O
label_count	int
;	O
char	O
*	O
buf	pointer
;	O
char	O
sym	pointer
[	O
30	int
]	O
;	O
sprintf	function
(	O
sym	pointer
,	O
"%sendfunc%d"	pointer
,	O
FAKE_LABEL_NAME	pointer
,	O
label_count	int
)	O
;	O
++	O
label_count	int
;	O
colon	function
(	O
sym	pointer
)	O
;	O
if	O
(	O
asprintf	function
(	O
&	O
buf	pointer
,	O
"\"\",%d,0,0,%s-%s"	pointer
,	O
N_FUN	int
,	O
sym	pointer
,	O
startlabname	pointer
)	O
==	O
-	O
1	int
)	O
as_fatal	function
(	O
"%s"	pointer
,	O
xstrerror	function
(	O
errno	O
)	O
)	O
;	O
temp_ilp	function
(	O
buf	pointer
)	O
;	O
s_stab	function
(	O
's'	O
)	O
;	O
restore_ilp	function
(	O
)	O
;	O
free	function
(	O
buf	pointer
)	O
;	O
in_dot_func_p	int
=	O
FALSE	int
;	O
current_function_label	pointer
=	O
NULL	O
;	O
}	O
