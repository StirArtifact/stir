unsigned	O
col_diff	array
[	O
3	int
]	O
[	O
512	int
]	O
;	O
void	O
bestfit_init	function
(	O
void	O
)	O
{	O
int	O
i	pointer
;	O
for	O
(	O
i	pointer
=	O
1	int
;	O
i	pointer
<	O
256	int
;	O
i	pointer
++	O
)	O
{	O
int	O
k	double
=	O
i	pointer
*	O
i	pointer
;	O
col_diff	array
[	O
0	int
]	O
[	O
i	pointer
]	O
=	O
col_diff	array
[	O
0	int
]	O
[	O
512	int
-	O
i	pointer
]	O
=	O
k	double
*	O
(	O
59	int
*	O
59	int
)	O
/	O
256	int
;	O
col_diff	array
[	O
1	int
]	O
[	O
i	pointer
]	O
=	O
col_diff	array
[	O
1	int
]	O
[	O
512	int
-	O
i	pointer
]	O
=	O
k	double
*	O
(	O
30	int
*	O
30	int
)	O
/	O
256	int
;	O
col_diff	array
[	O
2	int
]	O
[	O
i	pointer
]	O
=	O
col_diff	array
[	O
2	int
]	O
[	O
512	int
-	O
i	pointer
]	O
=	O
k	double
*	O
(	O
11	int
*	O
11	int
)	O
/	O
256	int
;	O
}	O
}	O
static	O
int	O
allocgenerictruecolor	function
(	O
struct	O
palette	struct
*	O
palette	struct
,	O
int	O
init	int
,	O
int	O
r	int
,	O
int	O
g	int
,	O
int	O
b	int
)	O
{	O
unsigned	O
int	O
n	int
;	O
switch	O
(	O
palette	struct
->	O
type	int
)	O
{	O
case	O
LARGEITER	int
:	O
case	O
SMALLITER	O
:	O
return	O
1	int
;	O
break	O
;	O
case	O
REALCOLOR	int
:	O
n	int
=	O
(	O
(	O
r	int
>>	O
3	int
)	O
<<	O
10	int
)	O
+	O
(	O
(	O
g	int
>>	O
3	int
)	O
<<	O
5	int
)	O
+	O
(	O
b	int
>>	O
3	int
)	O
;	O
break	O
;	O
case	O
HICOLOR	int
:	O
n	int
=	O
(	O
(	O
r	int
>>	O
3	int
)	O
<<	O
11	int
)	O
+	O
(	O
(	O
g	int
>>	O
2	int
)	O
<<	O
5	int
)	O
+	O
(	O
b	int
>>	O
3	int
)	O
;	O
break	O
;	O
case	O
TRUECOLORMI	int
:	O
n	int
=	O
(	O
r	int
<<	O
8	int
)	O
+	O
(	O
g	int
<<	O
16	int
)	O
+	O
(	O
b	int
<<	O
24	int
)	O
;	O
break	O
;	O
case	O
TRUECOLOR	int
:	O
case	O
TRUECOLOR24	int
:	O
default	O
:	O
n	int
=	O
(	O
r	int
<<	O
16	int
)	O
+	O
(	O
g	int
<<	O
8	int
)	O
+	O
(	O
b	int
)	O
;	O
}	O
if	O
(	O
init	int
)	O
palette	struct
->	O
size	int
=	O
0	int
;	O
else	O
if	O
(	O
palette	struct
->	O
size	int
>=	O
palette	struct
->	O
end	int
-	O
palette	struct
->	O
start	int
)	O
return	O
0	int
;	O
palette	struct
->	O
pixels	pointer
[	O
palette	struct
->	O
size	int
]	O
=	O
n	int
;	O
palette	struct
->	O
size	int
++	O
;	O
return	O
palette	struct
->	O
size	int
;	O
}	O
static	O
int	O
allocgeneric	function
(	O
struct	O
palette	struct
*	O
palette	struct
,	O
int	O
init	int
,	O
int	O
r	int
,	O
int	O
g	int
,	O
int	O
b	int
)	O
{	O
if	O
(	O
init	int
)	O
palette	struct
->	O
size	int
=	O
0	int
;	O
else	O
if	O
(	O
palette	struct
->	O
size	int
>=	O
palette	struct
->	O
end	int
-	O
palette	struct
->	O
start	int
)	O
return	O
-	O
1	int
;	O
palette	struct
->	O
pixels	pointer
[	O
palette	struct
->	O
size	int
]	O
=	O
palette	struct
->	O
size	int
+	O
palette	struct
->	O
start	int
;	O
palette	struct
->	O
rgb	pointer
[	O
palette	struct
->	O
size	int
+	O
palette	struct
->	O
start	int
]	O
[	O
0	int
]	O
=	O
r	int
;	O
palette	struct
->	O
rgb	pointer
[	O
palette	struct
->	O
size	int
+	O
palette	struct
->	O
start	int
]	O
[	O
1	int
]	O
=	O
g	int
;	O
palette	struct
->	O
rgb	pointer
[	O
palette	struct
->	O
size	int
+	O
palette	struct
->	O
start	int
]	O
[	O
2	int
]	O
=	O
b	int
;	O
palette	struct
->	O
size	int
++	O
;	O
return	O
(	O
palette	struct
->	O
size	int
-	O
1	int
)	O
;	O
}	O
int	O
fixedalloccolor	function
(	O
struct	O
palette	struct
*	O
palette	struct
,	O
int	O
init	int
,	O
int	O
r	int
,	O
int	O
g	int
,	O
int	O
b	int
)	O
{	O
int	O
i	pointer
,	O
coldif	int
,	O
lowest	int
,	O
bestfit	int
;	O
if	O
(	O
init	int
)	O
palette	struct
->	O
size	int
=	O
0	int
;	O
else	O
if	O
(	O
palette	struct
->	O
size	int
>=	O
palette	struct
->	O
end	int
-	O
palette	struct
->	O
start	int
)	O
return	O
-	O
1	int
;	O
lowest	int
=	O
INT_MAX	O
;	O
bestfit	int
=	O
1	int
;	O
if	O
(	O
palette	struct
->	O
type	int
==	O
FIXEDCOLOR	int
)	O
{	O
for	O
(	O
i	pointer
=	O
palette	struct
->	O
start	int
;	O
i	pointer
<	O
palette	struct
->	O
end	int
;	O
i	pointer
++	O
)	O
{	O
coldif	int
=	O
col_diff	array
[	O
0	int
]	O
[	O
(	O
g	int
-	O
palette	struct
->	O
rgb	pointer
[	O
i	pointer
]	O
[	O
1	int
]	O
)	O
&	O
0x1ff	int
]	O
;	O
if	O
(	O
coldif	int
<	O
lowest	int
)	O
{	O
coldif	int
+=	O
col_diff	array
[	O
1	int
]	O
[	O
(	O
r	int
-	O
palette	struct
->	O
rgb	pointer
[	O
i	pointer
]	O
[	O
0	int
]	O
)	O
&	O
0x1ff	int
]	O
;	O
if	O
(	O
coldif	int
<	O
lowest	int
)	O
{	O
coldif	int
+=	O
col_diff	array
[	O
2	int
]	O
[	O
(	O
b	int
-	O
palette	struct
->	O
rgb	pointer
[	O
i	pointer
]	O
[	O
2	int
]	O
)	O
&	O
0x1ff	int
]	O
;	O
if	O
(	O
coldif	int
<	O
lowest	int
)	O
{	O
bestfit	int
=	O
i	pointer
;	O
if	O
(	O
!	O
coldif	int
)	O
break	O
;	O
lowest	int
=	O
coldif	int
;	O
}	O
}	O
}	O
}	O
}	O
else	O
{	O
bestfit	int
=	O
(	O
r	int
*	O
30	int
+	O
g	int
*	O
59	int
+	O
b	int
*	O
11	int
)	O
*	O
(	O
palette	struct
->	O
end	int
-	O
palette	struct
->	O
start	int
)	O
/	O
256	int
/	O
100	int
+	O
palette	struct
->	O
start	int
;	O
}	O
palette	struct
->	O
pixels	pointer
[	O
palette	struct
->	O
size	int
]	O
=	O
bestfit	int
;	O
palette	struct
->	O
size	int
++	O
;	O
return	O
(	O
palette	struct
->	O
size	int
-	O
1	int
)	O
;	O
}	O
static	O
void	O
setcolorgeneric	function
(	O
struct	O
palette	struct
*	O
palette	struct
,	O
int	O
start	int
,	O
int	O
end	int
,	O
rgb_t	array
*	O
rgb	pointer
)	O
{	O
}	O
static	O
void	O
allocfinishedgeneric	function
(	O
struct	O
palette	struct
*	O
palette	struct
)	O
{	O
palette	struct
->	O
setpalette	pointer
(	O
palette	struct
,	O
palette	struct
->	O
start	int
,	O
palette	struct
->	O
size	int
+	O
palette	struct
->	O
start	int
,	O
palette	struct
->	O
rgb	pointer
+	O
palette	struct
->	O
start	int
)	O
;	O
}	O
static	O
void	O
cycle_entries	function
(	O
struct	O
palette	struct
*	O
c	pointer
,	O
int	O
direction	int
)	O
{	O
int	O
i	pointer
;	O
int	O
i1	int
,	O
i2	int
,	O
i3	int
;	O
rgb_t	array
*	O
co	pointer
;	O
if	O
(	O
direction	int
>	O
0	int
)	O
direction	int
%=	O
c	pointer
->	O
size	int
-	O
1	int
;	O
else	O
direction	int
=	O
-	O
(	O
(	O
-	O
direction	int
)	O
%	O
(	O
c	pointer
->	O
size	int
-	O
1	int
)	O
)	O
;	O
if	O
(	O
!	O
direction	int
)	O
return	O
;	O
co	pointer
=	O
malloc	function
(	O
c	pointer
->	O
end	int
*	O
sizeof	O
(	O
rgb_t	array
)	O
)	O
;	O
memcpy	function
(	O
co	pointer
,	O
c	pointer
->	O
rgb	pointer
,	O
sizeof	O
(	O
*	O
co	pointer
)	O
*	O
c	pointer
->	O
end	int
)	O
;	O
i3	int
=	O
(	O
c	pointer
->	O
size	int
-	O
1	int
+	O
direction	int
)	O
%	O
(	O
c	pointer
->	O
size	int
-	O
1	int
)	O
+	O
1	int
;	O
for	O
(	O
i	pointer
=	O
1	int
;	O
i	pointer
<	O
c	pointer
->	O
size	int
;	O
i	pointer
++	O
)	O
{	O
i1	int
=	O
c	pointer
->	O
pixels	pointer
[	O
i	pointer
]	O
;	O
i2	int
=	O
c	pointer
->	O
pixels	pointer
[	O
i3	int
]	O
;	O
c	pointer
->	O
rgb	pointer
[	O
i1	int
]	O
[	O
0	int
]	O
=	O
co	pointer
[	O
i2	int
]	O
[	O
0	int
]	O
;	O
c	pointer
->	O
rgb	pointer
[	O
i1	int
]	O
[	O
1	int
]	O
=	O
co	pointer
[	O
i2	int
]	O
[	O
1	int
]	O
;	O
c	pointer
->	O
rgb	pointer
[	O
i1	int
]	O
[	O
2	int
]	O
=	O
co	pointer
[	O
i2	int
]	O
[	O
2	int
]	O
;	O
i3	int
++	O
;	O
if	O
(	O
i3	int
>=	O
c	pointer
->	O
size	int
)	O
i3	int
=	O
1	int
;	O
}	O
free	function
(	O
co	pointer
)	O
;	O
}	O
static	O
void	O
cyclecolorsgeneric	function
(	O
struct	O
palette	struct
*	O
pal	pointer
,	O
int	O
direction	int
)	O
{	O
cycle_entries	function
(	O
pal	pointer
,	O
direction	int
)	O
;	O
pal	pointer
->	O
setpalette	pointer
(	O
pal	pointer
,	O
pal	pointer
->	O
start	int
,	O
pal	pointer
->	O
size	int
+	O
pal	pointer
->	O
start	int
,	O
pal	pointer
->	O
rgb	pointer
+	O
pal	pointer
->	O
start	int
)	O
;	O
}	O
struct	O
palette	struct
*	O
createpalette	function
(	O
int	O
start	int
,	O
int	O
end	int
,	O
int	O
type	int
,	O
int	O
flags	int
,	O
int	O
maxentries	int
,	O
int	O
(	O
*	O
alloccolor	pointer
)	O
(	O
struct	O
palette	struct
*	O
pal	pointer
,	O
int	O
init	int
,	O
int	O
r	int
,	O
int	O
g	int
,	O
int	O
b	int
)	O
,	O
void	O
(	O
*	O
setcolor	pointer
)	O
(	O
struct	O
palette	struct
*	O
pal	pointer
,	O
int	O
start	int
,	O
int	O
end	int
,	O
rgb_t	array
*	O
rgb	pointer
)	O
,	O
void	O
(	O
*	O
allocfinished	pointer
)	O
(	O
struct	O
palette	struct
*	O
pal	pointer
)	O
,	O
void	O
(	O
*	O
cyclecolors	pointer
)	O
(	O
struct	O
palette	struct
*	O
pal	pointer
,	O
int	O
direction	int
)	O
)	O
{	O
static	O
int	O
versioncount	int
;	O
struct	O
palette	struct
*	O
palette	struct
=	O
calloc	function
(	O
sizeof	O
(	O
struct	O
palette	struct
)	O
,	O
1	int
)	O
;	O
if	O
(	O
col_diff	array
[	O
0	int
]	O
[	O
1	int
]	O
==	O
0	int
)	O
bestfit_init	function
(	O
)	O
;	O
palette	struct
->	O
size	int
=	O
0	int
;	O
palette	struct
->	O
rgb	pointer
=	O
NULL	O
;	O
if	O
(	O
palette	struct
==	O
NULL	O
)	O
return	O
NULL	O
;	O
switch	O
(	O
type	int
)	O
{	O
case	O
LBITMAP	int
:	O
case	O
MBITMAP	int
:	O
case	O
LIBITMAP	int
:	O
case	O
MIBITMAP	int
:	O
end	int
=	O
2	int
;	O
start	int
=	O
0	int
;	O
maxentries	int
=	O
2	int
;	O
palette	struct
->	O
rgb	pointer
=	O
calloc	function
(	O
sizeof	O
(	O
*	O
palette	struct
->	O
rgb	pointer
)	O
,	O
end	int
)	O
;	O
if	O
(	O
palette	struct
->	O
rgb	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
palette	struct
)	O
;	O
return	O
NULL	O
;	O
}	O
palette	struct
->	O
rgb	pointer
[	O
0	int
]	O
[	O
0	int
]	O
=	O
0	int
;	O
palette	struct
->	O
rgb	pointer
[	O
0	int
]	O
[	O
1	int
]	O
=	O
0	int
;	O
palette	struct
->	O
rgb	pointer
[	O
0	int
]	O
[	O
2	int
]	O
=	O
0	int
;	O
palette	struct
->	O
rgb	pointer
[	O
1	int
]	O
[	O
0	int
]	O
=	O
255	int
;	O
palette	struct
->	O
rgb	pointer
[	O
1	int
]	O
[	O
1	int
]	O
=	O
255	int
;	O
palette	struct
->	O
rgb	pointer
[	O
1	int
]	O
[	O
2	int
]	O
=	O
255	int
;	O
palette	struct
->	O
maxentries	int
=	O
maxentries	int
;	O
palette	struct
->	O
alloccolor	pointer
=	O
fixedalloccolor	function
;	O
palette	struct
->	O
setpalette	pointer
=	O
NULL	O
;	O
palette	struct
->	O
allocfinished	pointer
=	O
NULL	O
;	O
palette	struct
->	O
cyclecolors	pointer
=	O
NULL	O
;	O
break	O
;	O
case	O
FIXEDCOLOR	int
:	O
palette	struct
->	O
rgb	pointer
=	O
calloc	function
(	O
sizeof	O
(	O
*	O
palette	struct
->	O
rgb	pointer
)	O
,	O
end	int
)	O
;	O
if	O
(	O
palette	struct
->	O
rgb	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
palette	struct
)	O
;	O
return	O
NULL	O
;	O
}	O
palette	struct
->	O
maxentries	int
=	O
maxentries	int
;	O
palette	struct
->	O
alloccolor	pointer
=	O
fixedalloccolor	function
;	O
palette	struct
->	O
setpalette	pointer
=	O
NULL	O
;	O
palette	struct
->	O
allocfinished	pointer
=	O
NULL	O
;	O
palette	struct
->	O
cyclecolors	pointer
=	O
NULL	O
;	O
break	O
;	O
case	O
GRAYSCALE	int
:	O
palette	struct
->	O
maxentries	int
=	O
4096	int
;	O
palette	struct
->	O
alloccolor	pointer
=	O
fixedalloccolor	function
;	O
palette	struct
->	O
setpalette	pointer
=	O
NULL	O
;	O
palette	struct
->	O
allocfinished	pointer
=	O
NULL	O
;	O
palette	struct
->	O
cyclecolors	pointer
=	O
NULL	O
;	O
palette	struct
->	O
size	int
=	O
end	int
-	O
start	int
;	O
break	O
;	O
case	O
C256	int
:	O
if	O
(	O
cyclecolors	pointer
==	O
NULL	O
&&	O
setcolor	pointer
!=	O
NULL	O
)	O
cyclecolors	pointer
=	O
cyclecolorsgeneric	function
;	O
if	O
(	O
alloccolor	pointer
==	O
NULL	O
)	O
{	O
alloccolor	pointer
=	O
allocgeneric	function
,	O
allocfinished	pointer
=	O
allocfinishedgeneric	function
;	O
if	O
(	O
setcolor	pointer
==	O
NULL	O
&&	O
type	int
==	O
C256	int
)	O
setcolor	pointer
=	O
setcolorgeneric	function
,	O
cyclecolors	pointer
=	O
cyclecolorsgeneric	function
;	O
}	O
palette	struct
->	O
rgb	pointer
=	O
calloc	function
(	O
sizeof	O
(	O
*	O
palette	struct
->	O
rgb	pointer
)	O
,	O
end	int
)	O
;	O
if	O
(	O
palette	struct
->	O
rgb	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
palette	struct
)	O
;	O
return	O
NULL	O
;	O
}	O
palette	struct
->	O
maxentries	int
=	O
maxentries	int
;	O
palette	struct
->	O
alloccolor	pointer
=	O
alloccolor	pointer
;	O
palette	struct
->	O
setpalette	pointer
=	O
setcolor	pointer
;	O
palette	struct
->	O
allocfinished	pointer
=	O
allocfinished	pointer
;	O
palette	struct
->	O
cyclecolors	pointer
=	O
cyclecolors	pointer
;	O
break	O
;	O
default	O
:	O
end	int
=	O
TRUECOLORPALETTE	int
;	O
start	int
=	O
0	int
;	O
if	O
(	O
type	int
==	O
SMALLITER	O
)	O
end	int
=	O
256	int
;	O
start	int
=	O
0	int
;	O
palette	struct
->	O
maxentries	int
=	O
end	int
;	O
palette	struct
->	O
alloccolor	pointer
=	O
allocgenerictruecolor	function
;	O
palette	struct
->	O
cyclecolors	pointer
=	O
NULL	O
;	O
palette	struct
->	O
setpalette	pointer
=	O
NULL	O
;	O
palette	struct
->	O
allocfinished	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
end	int
<	O
256	int
)	O
palette	struct
->	O
pixels	pointer
=	O
calloc	function
(	O
sizeof	O
(	O
*	O
palette	struct
->	O
pixels	pointer
)	O
,	O
256	int
)	O
;	O
else	O
palette	struct
->	O
pixels	pointer
=	O
calloc	function
(	O
sizeof	O
(	O
*	O
palette	struct
->	O
pixels	pointer
)	O
,	O
end	int
)	O
;	O
if	O
(	O
palette	struct
->	O
pixels	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
palette	struct
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
type	int
&	O
(	O
LARGEITER	int
|	O
SMALLITER	O
)	O
)	O
{	O
int	O
i	pointer
;	O
palette	struct
->	O
size	int
=	O
end	int
;	O
palette	struct
->	O
flags	int
|=	O
DONOTCHANGE	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
end	int
;	O
i	pointer
++	O
)	O
palette	struct
->	O
pixels	pointer
[	O
i	pointer
]	O
=	O
i	pointer
;	O
}	O
palette	struct
->	O
start	int
=	O
start	int
;	O
palette	struct
->	O
end	int
=	O
end	int
;	O
palette	struct
->	O
type	int
=	O
type	int
;	O
palette	struct
->	O
flags	int
|=	O
flags	int
;	O
palette	struct
->	O
version	int
=	O
(	O
versioncount	int
+=	O
65536	int
)	O
;	O
if	O
(	O
type	int
==	O
FIXEDCOLOR	int
)	O
{	O
int	O
i	pointer
;	O
if	O
(	O
setcolor	pointer
!=	O
NULL	O
)	O
setcolor	pointer
(	O
palette	struct
,	O
start	int
,	O
end	int
,	O
palette	struct
->	O
rgb	pointer
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
end	int
-	O
start	int
;	O
i	pointer
++	O
)	O
palette	struct
->	O
pixels	pointer
[	O
i	pointer
]	O
=	O
i	pointer
+	O
start	int
;	O
}	O
if	O
(	O
type	int
==	O
GRAYSCALE	int
)	O
{	O
int	O
i	pointer
;	O
for	O
(	O
i	pointer
=	O
palette	struct
->	O
start	int
;	O
i	pointer
<	O
end	int
-	O
start	int
;	O
i	pointer
++	O
)	O
palette	struct
->	O
pixels	pointer
[	O
i	pointer
]	O
=	O
i	pointer
+	O
start	int
;	O
}	O
return	O
(	O
palette	struct
)	O
;	O
}	O
void	O
destroypalette	function
(	O
struct	O
palette	struct
*	O
palette	struct
)	O
{	O
free	function
(	O
palette	struct
->	O
pixels	pointer
)	O
;	O
if	O
(	O
palette	struct
->	O
rgb	pointer
!=	O
NULL	O
)	O
free	function
(	O
palette	struct
->	O
rgb	pointer
)	O
;	O
free	function
(	O
palette	struct
)	O
;	O
}	O
struct	O
palette	struct
*	O
clonepalette	function
(	O
struct	O
palette	struct
*	O
palette	struct
)	O
{	O
struct	O
palette	struct
*	O
pal	pointer
=	O
createpalette	function
(	O
palette	struct
->	O
start	int
,	O
palette	struct
->	O
end	int
,	O
palette	struct
->	O
type	int
,	O
palette	struct
->	O
flags	int
,	O
palette	struct
->	O
maxentries	int
,	O
palette	struct
->	O
alloccolor	pointer
,	O
palette	struct
->	O
setpalette	pointer
,	O
palette	struct
->	O
allocfinished	pointer
,	O
palette	struct
->	O
cyclecolors	pointer
)	O
;	O
memcpy	function
(	O
pal	pointer
->	O
pixels	pointer
,	O
palette	struct
->	O
pixels	pointer
,	O
sizeof	O
(	O
*	O
pal	pointer
->	O
pixels	pointer
)	O
*	O
MYMIN	O
(	O
palette	struct
->	O
end	int
,	O
pal	pointer
->	O
end	int
)	O
)	O
;	O
if	O
(	O
pal	pointer
->	O
rgb	pointer
!=	O
NULL	O
)	O
{	O
memcpy	function
(	O
pal	pointer
->	O
rgb	pointer
,	O
palette	struct
->	O
rgb	pointer
,	O
sizeof	O
(	O
*	O
pal	pointer
->	O
rgb	pointer
)	O
*	O
MYMIN	O
(	O
palette	struct
->	O
end	int
,	O
pal	pointer
->	O
end	int
)	O
)	O
;	O
}	O
pal	pointer
->	O
size	int
=	O
palette	struct
->	O
size	int
;	O
return	O
(	O
pal	pointer
)	O
;	O
}	O
void	O
restorepalette	function
(	O
struct	O
palette	struct
*	O
dest	pointer
,	O
struct	O
palette	struct
*	O
src	pointer
)	O
{	O
int	O
i	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
src	pointer
->	O
size	int
;	O
i	pointer
++	O
)	O
{	O
int	O
r	int
=	O
0	int
,	O
g	int
=	O
0	int
,	O
b	int
=	O
0	int
;	O
switch	O
(	O
src	pointer
->	O
type	int
)	O
{	O
case	O
SMALLITER	O
:	O
r	int
=	O
g	int
=	O
b	int
=	O
i	pointer
;	O
break	O
;	O
case	O
LARGEITER	int
:	O
r	int
=	O
g	int
=	O
b	int
=	O
i	pointer
/	O
256	int
;	O
break	O
;	O
case	O
GRAYSCALE	int
:	O
r	int
=	O
g	int
=	O
b	int
=	O
src	pointer
->	O
pixels	pointer
[	O
i	pointer
]	O
;	O
break	O
;	O
case	O
C256	int
:	O
case	O
FIXEDCOLOR	int
:	O
case	O
MBITMAP	int
:	O
case	O
LBITMAP	int
:	O
case	O
MIBITMAP	int
:	O
case	O
LIBITMAP	int
:	O
r	int
=	O
src	pointer
->	O
rgb	pointer
[	O
src	pointer
->	O
pixels	pointer
[	O
i	pointer
]	O
]	O
[	O
0	int
]	O
;	O
g	int
=	O
src	pointer
->	O
rgb	pointer
[	O
src	pointer
->	O
pixels	pointer
[	O
i	pointer
]	O
]	O
[	O
1	int
]	O
;	O
b	int
=	O
src	pointer
->	O
rgb	pointer
[	O
src	pointer
->	O
pixels	pointer
[	O
i	pointer
]	O
]	O
[	O
2	int
]	O
;	O
break	O
;	O
case	O
HICOLOR	int
:	O
r	int
=	O
(	O
(	O
src	pointer
->	O
pixels	pointer
[	O
i	pointer
]	O
>>	O
11	int
)	O
&	O
31	int
)	O
<<	O
3	int
;	O
g	int
=	O
(	O
(	O
src	pointer
->	O
pixels	pointer
[	O
i	pointer
]	O
>>	O
5	int
)	O
&	O
63	int
)	O
<<	O
2	int
;	O
b	int
=	O
(	O
src	pointer
->	O
pixels	pointer
[	O
i	pointer
]	O
&	O
31	int
)	O
<<	O
3	int
;	O
break	O
;	O
case	O
REALCOLOR	int
:	O
r	int
=	O
(	O
(	O
src	pointer
->	O
pixels	pointer
[	O
i	pointer
]	O
>>	O
10	int
)	O
&	O
31	int
)	O
<<	O
3	int
;	O
g	int
=	O
(	O
(	O
src	pointer
->	O
pixels	pointer
[	O
i	pointer
]	O
>>	O
5	int
)	O
&	O
31	int
)	O
<<	O
3	int
;	O
b	int
=	O
(	O
src	pointer
->	O
pixels	pointer
[	O
i	pointer
]	O
&	O
31	int
)	O
<<	O
3	int
;	O
break	O
;	O
case	O
TRUECOLORMI	int
:	O
r	int
=	O
(	O
src	pointer
->	O
pixels	pointer
[	O
i	pointer
]	O
>>	O
8	int
)	O
&	O
255	int
;	O
g	int
=	O
(	O
src	pointer
->	O
pixels	pointer
[	O
i	pointer
]	O
>>	O
16	int
)	O
&	O
255	int
;	O
b	int
=	O
(	O
src	pointer
->	O
pixels	pointer
[	O
i	pointer
]	O
>>	O
24	int
)	O
&	O
255	int
;	O
break	O
;	O
case	O
TRUECOLOR	int
:	O
case	O
TRUECOLOR24	int
:	O
r	int
=	O
(	O
src	pointer
->	O
pixels	pointer
[	O
i	pointer
]	O
>>	O
16	int
)	O
&	O
255	int
;	O
g	int
=	O
(	O
src	pointer
->	O
pixels	pointer
[	O
i	pointer
]	O
>>	O
8	int
)	O
&	O
255	int
;	O
b	int
=	O
src	pointer
->	O
pixels	pointer
[	O
i	pointer
]	O
&	O
255	int
;	O
}	O
if	O
(	O
dest	pointer
->	O
size	int
>=	O
dest	pointer
->	O
maxentries	int
)	O
break	O
;	O
if	O
(	O
dest	pointer
->	O
alloccolor	pointer
(	O
dest	pointer
,	O
i	pointer
==	O
0	int
,	O
r	int
,	O
g	int
,	O
b	int
)	O
==	O
-	O
1	int
)	O
break	O
;	O
}	O
if	O
(	O
!	O
(	O
dest	pointer
->	O
flags	int
&	O
FINISHLATER	int
)	O
)	O
{	O
if	O
(	O
dest	pointer
->	O
allocfinished	pointer
!=	O
NULL	O
)	O
dest	pointer
->	O
allocfinished	pointer
(	O
dest	pointer
)	O
;	O
}	O
else	O
dest	pointer
->	O
flags	int
|=	O
UNFINISHED	int
;	O
dest	pointer
->	O
version	int
++	O
;	O
}	O
static	O
int	O
segmentsize	int
;	O
static	O
unsigned	O
char	O
colors	array
[	O
MAXNSEGMENTS	O
]	O
[	O
3	int
]	O
;	O
static	O
CONST	O
unsigned	O
char	O
colors1	array
[	O
DEFNSEGMENTS	O
]	O
[	O
3	int
]	O
=	O
{	O
{	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
120	int
,	O
119	int
,	O
238	int
}	O
,	O
{	O
24	int
,	O
7	int
,	O
25	int
}	O
,	O
{	O
197	int
,	O
66	int
,	O
28	int
}	O
,	O
{	O
29	int
,	O
18	int
,	O
11	int
}	O
,	O
{	O
135	int
,	O
46	int
,	O
71	int
}	O
,	O
{	O
24	int
,	O
27	int
,	O
13	int
}	O
,	O
{	O
241	int
,	O
230	int
,	O
128	int
}	O
,	O
{	O
17	int
,	O
31	int
,	O
24	int
}	O
,	O
{	O
240	int
,	O
162	int
,	O
139	int
}	O
,	O
{	O
11	int
,	O
4	int
,	O
30	int
}	O
,	O
{	O
106	int
,	O
87	int
,	O
189	int
}	O
,	O
{	O
29	int
,	O
21	int
,	O
14	int
}	O
,	O
{	O
12	int
,	O
140	int
,	O
118	int
}	O
,	O
{	O
10	int
,	O
6	int
,	O
29	int
}	O
,	O
{	O
50	int
,	O
144	int
,	O
77	int
}	O
,	O
{	O
22	int
,	O
0	int
,	O
24	int
}	O
,	O
{	O
148	int
,	O
188	int
,	O
243	int
}	O
,	O
{	O
4	int
,	O
32	int
,	O
7	int
}	O
,	O
{	O
231	int
,	O
146	int
,	O
14	int
}	O
,	O
{	O
10	int
,	O
13	int
,	O
20	int
}	O
,	O
{	O
184	int
,	O
147	int
,	O
68	int
}	O
,	O
{	O
13	int
,	O
28	int
,	O
3	int
}	O
,	O
{	O
169	int
,	O
248	int
,	O
152	int
}	O
,	O
{	O
4	int
,	O
0	int
,	O
34	int
}	O
,	O
{	O
62	int
,	O
83	int
,	O
48	int
}	O
,	O
{	O
7	int
,	O
21	int
,	O
22	int
}	O
,	O
{	O
152	int
,	O
97	int
,	O
184	int
}	O
,	O
{	O
8	int
,	O
3	int
,	O
12	int
}	O
,	O
{	O
247	int
,	O
92	int
,	O
235	int
}	O
,	O
{	O
31	int
,	O
32	int
,	O
16	int
}	O
}	O
;	O
static	O
struct	O
palette	struct
*	O
context	pointer
;	O
static	O
int	O
maxentries	int
;	O
static	O
int	O
needupdate	int
;	O
static	O
int	O
allocate	function
(	O
int	O
r	int
,	O
int	O
g	int
,	O
int	O
b	int
,	O
int	O
init	int
)	O
REGISTERS	O
(	O
3	int
)	O
;	O
static	O
int	O
allocate	function
(	O
int	O
r	int
,	O
int	O
g	int
,	O
int	O
b	int
,	O
int	O
init	int
)	O
{	O
unsigned	O
int	O
n	int
=	O
context	pointer
->	O
pixels	pointer
[	O
(	O
init	int
?	O
0	int
:	O
context	pointer
->	O
size	int
)	O
]	O
;	O
if	O
(	O
!	O
init	int
&&	O
context	pointer
->	O
size	int
==	O
maxentries	int
)	O
return	O
0	int
;	O
if	O
(	O
(	O
context	pointer
->	O
alloccolor	pointer
(	O
context	pointer
,	O
init	int
,	O
(	O
int	O
)	O
r	int
,	O
(	O
int	O
)	O
g	int
,	O
(	O
int	O
)	O
b	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
context	pointer
->	O
pixels	pointer
[	O
context	pointer
->	O
size	int
-	O
1	int
]	O
!=	O
n	int
)	O
{	O
needupdate	int
=	O
1	int
;	O
}	O
return	O
(	O
1	int
)	O
;	O
}	O
static	O
int	O
mksmooth	function
(	O
int	O
nsegments	int
,	O
int	O
setsegments	int
)	O
{	O
int	O
i	pointer
,	O
y	pointer
;	O
float	O
r	int
,	O
g	int
,	O
b	int
,	O
rs	struct
,	O
gs	float
,	O
bs	float
;	O
int	O
segmentsize1	int
=	O
segmentsize	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
setsegments	int
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
i	pointer
==	O
setsegments	int
-	O
1	int
&&	O
!	O
(	O
context	pointer
->	O
flags	int
&	O
UNKNOWNENTRIES	int
)	O
)	O
{	O
segmentsize1	int
=	O
context	pointer
->	O
maxentries	int
-	O
context	pointer
->	O
size	int
-	O
2	int
;	O
}	O
r	int
=	O
colors	array
[	O
i	pointer
%	O
nsegments	int
]	O
[	O
0	int
]	O
;	O
g	int
=	O
colors	array
[	O
i	pointer
%	O
nsegments	int
]	O
[	O
1	int
]	O
;	O
b	int
=	O
colors	array
[	O
i	pointer
%	O
nsegments	int
]	O
[	O
2	int
]	O
;	O
rs	struct
=	O
(	O
(	O
int	O
)	O
colors	array
[	O
(	O
i	pointer
+	O
1	int
)	O
%	O
setsegments	int
%	O
nsegments	int
]	O
[	O
0	int
]	O
-	O
r	int
)	O
/	O
(	O
unsigned	O
int	O
)	O
segmentsize1	int
;	O
gs	float
=	O
(	O
(	O
int	O
)	O
colors	array
[	O
(	O
i	pointer
+	O
1	int
)	O
%	O
setsegments	int
%	O
nsegments	int
]	O
[	O
1	int
]	O
-	O
g	int
)	O
/	O
(	O
unsigned	O
int	O
)	O
segmentsize1	int
;	O
bs	float
=	O
(	O
(	O
int	O
)	O
colors	array
[	O
(	O
i	pointer
+	O
1	int
)	O
%	O
setsegments	int
%	O
nsegments	int
]	O
[	O
2	int
]	O
-	O
b	int
)	O
/	O
(	O
unsigned	O
int	O
)	O
segmentsize1	int
;	O
for	O
(	O
y	pointer
=	O
0	int
;	O
y	pointer
<	O
segmentsize1	int
;	O
y	pointer
++	O
)	O
{	O
if	O
(	O
!	O
allocate	function
(	O
(	O
int	O
)	O
r	int
,	O
(	O
int	O
)	O
g	int
,	O
(	O
int	O
)	O
b	int
,	O
i	pointer
==	O
0	int
&&	O
y	pointer
==	O
0	int
)	O
)	O
{	O
if	O
(	O
!	O
i	pointer
)	O
context	pointer
->	O
size	int
=	O
2	int
;	O
context	pointer
->	O
size	int
=	O
i	pointer
*	O
segmentsize	int
;	O
return	O
0	int
;	O
}	O
r	int
+=	O
rs	struct
;	O
g	int
+=	O
gs	float
;	O
b	int
+=	O
bs	float
;	O
}	O
}	O
if	O
(	O
context	pointer
->	O
flags	int
&	O
UNKNOWNENTRIES	int
)	O
context	pointer
->	O
size	int
=	O
i	pointer
*	O
segmentsize	int
;	O
return	O
1	int
;	O
}	O
static	O
INLINE	O
void	O
hsv_to_rgb	function
(	O
int	O
h	int
,	O
int	O
s	struct
,	O
int	O
v	struct
,	O
unsigned	O
char	O
*	O
red	pointer
,	O
unsigned	O
char	O
*	O
green	pointer
,	O
unsigned	O
char	O
*	O
blue	pointer
)	O
{	O
int	O
hue	int
;	O
int	O
f	pointer
,	O
p	int
,	O
q	pointer
,	O
t	int
;	O
h	int
+=	O
256	int
;	O
h	int
%=	O
256	int
;	O
if	O
(	O
s	struct
==	O
0	int
)	O
{	O
*	O
red	pointer
=	O
v	struct
;	O
*	O
green	pointer
=	O
v	struct
;	O
*	O
blue	pointer
=	O
v	struct
;	O
}	O
else	O
{	O
h	int
%=	O
256	int
;	O
if	O
(	O
h	int
<	O
0	int
)	O
h	int
+=	O
256	int
;	O
hue	int
=	O
h	int
*	O
6	int
;	O
f	pointer
=	O
hue	int
&	O
255	int
;	O
p	int
=	O
v	struct
*	O
(	O
256	int
-	O
s	struct
)	O
/	O
256	int
;	O
q	pointer
=	O
v	struct
*	O
(	O
256	int
-	O
(	O
s	struct
*	O
f	pointer
)	O
/	O
256	int
)	O
>>	O
8	int
;	O
t	int
=	O
v	struct
*	O
(	O
256	int
*	O
256	int
-	O
(	O
s	struct
*	O
(	O
256	int
-	O
f	pointer
)	O
)	O
)	O
>>	O
16	int
;	O
switch	O
(	O
(	O
int	O
)	O
(	O
hue	int
/	O
256	int
)	O
)	O
{	O
case	O
0	int
:	O
*	O
red	pointer
=	O
v	struct
;	O
*	O
green	pointer
=	O
t	int
;	O
*	O
blue	pointer
=	O
p	int
;	O
break	O
;	O
case	O
1	int
:	O
*	O
red	pointer
=	O
q	pointer
;	O
*	O
green	pointer
=	O
v	struct
;	O
*	O
blue	pointer
=	O
p	int
;	O
break	O
;	O
case	O
2	int
:	O
*	O
red	pointer
=	O
p	int
;	O
*	O
green	pointer
=	O
v	struct
;	O
*	O
blue	pointer
=	O
t	int
;	O
break	O
;	O
case	O
3	int
:	O
*	O
red	pointer
=	O
p	int
;	O
*	O
green	pointer
=	O
q	pointer
;	O
*	O
blue	pointer
=	O
v	struct
;	O
break	O
;	O
case	O
4	int
:	O
*	O
red	pointer
=	O
t	int
;	O
*	O
green	pointer
=	O
p	int
;	O
*	O
blue	pointer
=	O
v	struct
;	O
break	O
;	O
case	O
5	int
:	O
*	O
red	pointer
=	O
v	struct
;	O
*	O
green	pointer
=	O
p	int
;	O
*	O
blue	pointer
=	O
q	pointer
;	O
break	O
;	O
}	O
}	O
}	O
static	O
void	O
randomize_segments3	function
(	O
int	O
whitemode	int
,	O
int	O
nsegments	int
)	O
{	O
int	O
i	pointer
=	O
0	int
;	O
int	O
h	int
,	O
s	struct
,	O
v	struct
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
nsegments	int
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
!	O
(	O
i	pointer
%	O
3	int
)	O
)	O
{	O
if	O
(	O
i	pointer
%	O
6	int
)	O
colors	array
[	O
i	pointer
]	O
[	O
0	int
]	O
=	O
255	int
,	O
colors	array
[	O
i	pointer
]	O
[	O
1	int
]	O
=	O
255	int
,	O
colors	array
[	O
i	pointer
]	O
[	O
2	int
]	O
=	O
255	int
;	O
else	O
colors	array
[	O
i	pointer
]	O
[	O
0	int
]	O
=	O
0	int
,	O
colors	array
[	O
i	pointer
]	O
[	O
1	int
]	O
=	O
0	int
,	O
colors	array
[	O
i	pointer
]	O
[	O
2	int
]	O
=	O
0	int
;	O
}	O
else	O
{	O
s	struct
=	O
XaoS_random	function
(	O
)	O
%	O
256	int
;	O
h	int
=	O
XaoS_random	function
(	O
)	O
%	O
(	O
128	int
-	O
32	int
)	O
;	O
v	struct
=	O
XaoS_random	function
(	O
)	O
%	O
128	int
;	O
if	O
(	O
(	O
(	O
i	pointer
)	O
%	O
6	int
>	O
3	int
)	O
^	O
(	O
(	O
i	pointer
)	O
%	O
3	int
==	O
1	int
)	O
)	O
h	int
+=	O
42	int
+	O
16	int
;	O
else	O
h	int
+=	O
42	int
+	O
128	int
+	O
16	int
,	O
v	struct
+=	O
128	int
+	O
64	int
;	O
hsv_to_rgb	function
(	O
h	int
,	O
s	struct
,	O
v	struct
,	O
colors	array
[	O
i	pointer
]	O
,	O
colors	array
[	O
i	pointer
]	O
+	O
1	int
,	O
colors	array
[	O
i	pointer
]	O
+	O
2	int
)	O
;	O
}	O
}	O
colors	array
[	O
i	pointer
-	O
1	int
]	O
[	O
0	int
]	O
=	O
colors	array
[	O
0	int
]	O
[	O
0	int
]	O
;	O
colors	array
[	O
i	pointer
-	O
1	int
]	O
[	O
1	int
]	O
=	O
colors	array
[	O
0	int
]	O
[	O
1	int
]	O
;	O
colors	array
[	O
i	pointer
-	O
1	int
]	O
[	O
2	int
]	O
=	O
colors	array
[	O
0	int
]	O
[	O
2	int
]	O
;	O
}	O
static	O
void	O
randomize_segments2	function
(	O
int	O
whitemode	int
,	O
int	O
nsegments	int
)	O
{	O
int	O
i	pointer
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
nsegments	int
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
i	pointer
%	O
3	int
==	O
2	int
)	O
colors	array
[	O
i	pointer
]	O
[	O
0	int
]	O
=	O
whitemode	int
*	O
255	int
,	O
colors	array
[	O
i	pointer
]	O
[	O
1	int
]	O
=	O
whitemode	int
*	O
255	int
,	O
colors	array
[	O
i	pointer
]	O
[	O
2	int
]	O
=	O
whitemode	int
*	O
255	int
;	O
else	O
if	O
(	O
i	pointer
%	O
3	int
==	O
0	int
)	O
colors	array
[	O
i	pointer
]	O
[	O
0	int
]	O
=	O
(	O
!	O
whitemode	int
)	O
*	O
255	int
,	O
colors	array
[	O
i	pointer
]	O
[	O
1	int
]	O
=	O
(	O
!	O
whitemode	int
)	O
*	O
255	int
,	O
colors	array
[	O
i	pointer
]	O
[	O
2	int
]	O
=	O
(	O
!	O
whitemode	int
)	O
*	O
255	int
;	O
else	O
colors	array
[	O
i	pointer
]	O
[	O
0	int
]	O
=	O
XaoS_random	function
(	O
)	O
%	O
256	int
,	O
colors	array
[	O
i	pointer
]	O
[	O
1	int
]	O
=	O
XaoS_random	function
(	O
)	O
%	O
256	int
,	O
colors	array
[	O
i	pointer
]	O
[	O
2	int
]	O
=	O
XaoS_random	function
(	O
)	O
%	O
256	int
;	O
}	O
colors	array
[	O
i	pointer
-	O
1	int
]	O
[	O
0	int
]	O
=	O
colors	array
[	O
0	int
]	O
[	O
0	int
]	O
;	O
colors	array
[	O
i	pointer
-	O
1	int
]	O
[	O
1	int
]	O
=	O
colors	array
[	O
0	int
]	O
[	O
1	int
]	O
;	O
colors	array
[	O
i	pointer
-	O
1	int
]	O
[	O
2	int
]	O
=	O
colors	array
[	O
0	int
]	O
[	O
2	int
]	O
;	O
}	O
static	O
void	O
randomize_segments	function
(	O
int	O
whitemode	int
,	O
int	O
nsegments	int
)	O
{	O
int	O
i	pointer
=	O
0	int
;	O
if	O
(	O
whitemode	int
)	O
{	O
colors	array
[	O
0	int
]	O
[	O
0	int
]	O
=	O
255	int
,	O
colors	array
[	O
0	int
]	O
[	O
1	int
]	O
=	O
255	int
,	O
colors	array
[	O
0	int
]	O
[	O
2	int
]	O
=	O
255	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
nsegments	int
;	O
i	pointer
+=	O
2	int
)	O
{	O
if	O
(	O
i	pointer
!=	O
0	int
)	O
{	O
colors	array
[	O
i	pointer
]	O
[	O
0	int
]	O
=	O
XaoS_random	function
(	O
)	O
%	O
256	int
,	O
colors	array
[	O
i	pointer
]	O
[	O
1	int
]	O
=	O
XaoS_random	function
(	O
)	O
%	O
256	int
,	O
colors	array
[	O
i	pointer
]	O
[	O
2	int
]	O
=	O
XaoS_random	function
(	O
)	O
%	O
256	int
;	O
}	O
if	O
(	O
i	pointer
+	O
1	int
<	O
nsegments	int
)	O
colors	array
[	O
i	pointer
+	O
1	int
]	O
[	O
0	int
]	O
=	O
XaoS_random	function
(	O
)	O
%	O
35	int
,	O
colors	array
[	O
i	pointer
+	O
1	int
]	O
[	O
1	int
]	O
=	O
XaoS_random	function
(	O
)	O
%	O
35	int
,	O
colors	array
[	O
i	pointer
+	O
1	int
]	O
[	O
2	int
]	O
=	O
XaoS_random	function
(	O
)	O
%	O
35	int
;	O
}	O
}	O
else	O
{	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
nsegments	int
;	O
i	pointer
+=	O
2	int
)	O
{	O
colors	array
[	O
i	pointer
]	O
[	O
0	int
]	O
=	O
XaoS_random	function
(	O
)	O
%	O
35	int
,	O
colors	array
[	O
i	pointer
]	O
[	O
1	int
]	O
=	O
XaoS_random	function
(	O
)	O
%	O
35	int
,	O
colors	array
[	O
i	pointer
]	O
[	O
2	int
]	O
=	O
XaoS_random	function
(	O
)	O
%	O
35	int
;	O
if	O
(	O
i	pointer
+	O
1	int
<	O
nsegments	int
)	O
colors	array
[	O
i	pointer
+	O
1	int
]	O
[	O
0	int
]	O
=	O
XaoS_random	function
(	O
)	O
%	O
256	int
,	O
colors	array
[	O
i	pointer
+	O
1	int
]	O
[	O
1	int
]	O
=	O
XaoS_random	function
(	O
)	O
%	O
256	int
,	O
colors	array
[	O
i	pointer
+	O
1	int
]	O
[	O
2	int
]	O
=	O
XaoS_random	function
(	O
)	O
%	O
256	int
;	O
}	O
}	O
colors	array
[	O
i	pointer
-	O
1	int
]	O
[	O
0	int
]	O
=	O
colors	array
[	O
0	int
]	O
[	O
0	int
]	O
;	O
colors	array
[	O
i	pointer
-	O
1	int
]	O
[	O
1	int
]	O
=	O
colors	array
[	O
0	int
]	O
[	O
1	int
]	O
;	O
colors	array
[	O
i	pointer
-	O
1	int
]	O
[	O
2	int
]	O
=	O
colors	array
[	O
0	int
]	O
[	O
2	int
]	O
;	O
}	O
int	O
mkpalette	function
(	O
struct	O
palette	struct
*	O
c	pointer
,	O
int	O
seed	int
,	O
int	O
algorithm	int
)	O
{	O
int	O
i	pointer
,	O
ncolors	int
=	O
c	pointer
->	O
size	int
;	O
int	O
whitemode	int
;	O
int	O
i1	int
;	O
context	pointer
=	O
c	pointer
;	O
needupdate	int
=	O
0	int
;	O
if	O
(	O
c	pointer
->	O
flags	int
&	O
DONOTCHANGE	int
)	O
return	O
0	int
;	O
XaoS_srandom	function
(	O
seed	int
)	O
;	O
seed	int
=	O
XaoS_random	function
(	O
)	O
;	O
whitemode	int
=	O
XaoS_random	function
(	O
)	O
%	O
2	int
;	O
if	O
(	O
(	O
c	pointer
->	O
flags	int
&	O
UNKNOWNENTRIES	int
)	O
||	O
!	O
c	pointer
->	O
size	int
)	O
{	O
maxentries	int
=	O
context	pointer
->	O
maxentries	int
;	O
segmentsize	int
=	O
(	O
rrandom	O
(	O
maxentries	int
/	O
2	int
)	O
)	O
&	O
(	O
~	O
3	int
)	O
;	O
if	O
(	O
segmentsize	int
<	O
1	int
)	O
segmentsize	int
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
maxentries	int
>	O
8	int
)	O
{	O
int	O
qq	int
=	O
255	int
;	O
maxentries	int
=	O
context	pointer
->	O
maxentries	int
;	O
segmentsize	int
=	O
rrandom	O
(	O
qq	int
/	O
3	int
+	O
4	int
)	O
;	O
segmentsize	int
+=	O
rrandom	O
(	O
qq	int
/	O
3	int
+	O
4	int
)	O
;	O
segmentsize	int
+=	O
rrandom	O
(	O
qq	int
/	O
3	int
+	O
4	int
)	O
;	O
segmentsize	int
+=	O
rrandom	O
(	O
qq	int
/	O
3	int
+	O
4	int
)	O
;	O
segmentsize	int
=	O
abs	function
(	O
segmentsize	int
/	O
2	int
-	O
qq	int
/	O
3	int
+	O
3	int
)	O
;	O
if	O
(	O
segmentsize	int
<	O
8	int
)	O
segmentsize	int
=	O
8	int
;	O
if	O
(	O
segmentsize	int
>	O
maxentries	int
/	O
3	int
)	O
segmentsize	int
=	O
maxentries	int
/	O
3	int
;	O
}	O
}	O
if	O
(	O
c	pointer
->	O
flags	int
&	O
UNKNOWNENTRIES	int
)	O
i	pointer
=	O
rrandom	O
(	O
maxentries	int
)	O
;	O
else	O
i	pointer
=	O
(	O
maxentries	int
+	O
segmentsize	int
-	O
5	int
)	O
/	O
segmentsize	int
;	O
if	O
(	O
i	pointer
<	O
0	int
)	O
i	pointer
=	O
1	int
;	O
if	O
(	O
i	pointer
>	O
MAXNSEGMENTS	O
)	O
i1	int
=	O
MAXNSEGMENTS	O
;	O
else	O
i1	int
=	O
i	pointer
;	O
XaoS_srandom	function
(	O
seed	int
)	O
;	O
switch	O
(	O
algorithm	int
)	O
{	O
case	O
2	int
:	O
randomize_segments3	function
(	O
whitemode	int
,	O
i1	int
)	O
;	O
break	O
;	O
case	O
1	int
:	O
randomize_segments2	function
(	O
whitemode	int
,	O
i1	int
)	O
;	O
break	O
;	O
case	O
0	int
:	O
randomize_segments	function
(	O
whitemode	int
,	O
i1	int
)	O
;	O
}	O
mksmooth	function
(	O
i1	int
,	O
i	pointer
)	O
;	O
if	O
(	O
!	O
(	O
c	pointer
->	O
flags	int
&	O
FINISHLATER	int
)	O
)	O
{	O
if	O
(	O
c	pointer
->	O
allocfinished	pointer
!=	O
NULL	O
)	O
c	pointer
->	O
allocfinished	pointer
(	O
c	pointer
)	O
;	O
}	O
else	O
c	pointer
->	O
flags	int
|=	O
UNFINISHED	int
;	O
if	O
(	O
context	pointer
->	O
size	int
!=	O
ncolors	int
||	O
needupdate	int
)	O
{	O
context	pointer
->	O
version	int
++	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
mkstereogrampalette	function
(	O
struct	O
palette	struct
*	O
c	pointer
)	O
{	O
int	O
i	pointer
,	O
ncolors	int
=	O
c	pointer
->	O
size	int
;	O
context	pointer
=	O
c	pointer
;	O
needupdate	int
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
16	int
;	O
i	pointer
++	O
)	O
allocate	function
(	O
i	pointer
*	O
4	int
,	O
i	pointer
*	O
4	int
,	O
i	pointer
*	O
16	int
,	O
i	pointer
==	O
0	int
)	O
;	O
if	O
(	O
!	O
(	O
c	pointer
->	O
flags	int
&	O
FINISHLATER	int
)	O
)	O
{	O
if	O
(	O
c	pointer
->	O
allocfinished	pointer
!=	O
NULL	O
)	O
c	pointer
->	O
allocfinished	pointer
(	O
c	pointer
)	O
;	O
}	O
else	O
c	pointer
->	O
flags	int
|=	O
UNFINISHED	int
;	O
if	O
(	O
context	pointer
->	O
size	int
!=	O
ncolors	int
||	O
needupdate	int
)	O
{	O
context	pointer
->	O
version	int
++	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
mkstarfieldpalette	function
(	O
struct	O
palette	struct
*	O
c	pointer
)	O
{	O
int	O
i	pointer
,	O
ncolors	int
=	O
c	pointer
->	O
size	int
;	O
context	pointer
=	O
c	pointer
;	O
needupdate	int
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
16	int
;	O
i	pointer
++	O
)	O
if	O
(	O
i	pointer
%	O
2	int
)	O
allocate	function
(	O
i	pointer
*	O
4	int
,	O
i	pointer
*	O
4	int
,	O
i	pointer
*	O
16	int
,	O
i	pointer
==	O
0	int
)	O
;	O
else	O
allocate	function
(	O
i	pointer
*	O
16	int
,	O
i	pointer
*	O
16	int
,	O
i	pointer
*	O
16	int
,	O
i	pointer
==	O
0	int
)	O
;	O
if	O
(	O
!	O
(	O
c	pointer
->	O
flags	int
&	O
FINISHLATER	int
)	O
)	O
{	O
if	O
(	O
c	pointer
->	O
allocfinished	pointer
!=	O
NULL	O
)	O
c	pointer
->	O
allocfinished	pointer
(	O
c	pointer
)	O
;	O
}	O
else	O
c	pointer
->	O
flags	int
|=	O
UNFINISHED	int
;	O
if	O
(	O
context	pointer
->	O
size	int
!=	O
ncolors	int
||	O
needupdate	int
)	O
{	O
context	pointer
->	O
version	int
++	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
mkblurpalette	function
(	O
struct	O
palette	struct
*	O
c	pointer
)	O
{	O
int	O
i	pointer
,	O
ncolors	int
=	O
c	pointer
->	O
size	int
;	O
context	pointer
=	O
c	pointer
;	O
needupdate	int
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
63	int
;	O
i	pointer
++	O
)	O
allocate	function
(	O
i	pointer
*	O
2	int
,	O
i	pointer
*	O
2	int
,	O
i	pointer
*	O
4	int
,	O
i	pointer
==	O
0	int
)	O
;	O
allocate	function
(	O
i	pointer
*	O
2	int
,	O
i	pointer
*	O
2	int
,	O
i	pointer
*	O
4	int
-	O
1	int
,	O
0	int
)	O
;	O
if	O
(	O
!	O
(	O
c	pointer
->	O
flags	int
&	O
FINISHLATER	int
)	O
)	O
{	O
if	O
(	O
c	pointer
->	O
allocfinished	pointer
!=	O
NULL	O
)	O
c	pointer
->	O
allocfinished	pointer
(	O
c	pointer
)	O
;	O
}	O
else	O
c	pointer
->	O
flags	int
|=	O
UNFINISHED	int
;	O
if	O
(	O
context	pointer
->	O
size	int
!=	O
ncolors	int
||	O
needupdate	int
)	O
{	O
context	pointer
->	O
version	int
++	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
mkgraypalette	function
(	O
struct	O
palette	struct
*	O
c	pointer
)	O
{	O
int	O
i	pointer
,	O
ncolors	int
=	O
c	pointer
->	O
size	int
;	O
context	pointer
=	O
c	pointer
;	O
needupdate	int
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
64	int
;	O
i	pointer
++	O
)	O
allocate	function
(	O
i	pointer
*	O
4	int
,	O
i	pointer
*	O
4	int
,	O
i	pointer
*	O
4	int
,	O
i	pointer
==	O
0	int
)	O
;	O
if	O
(	O
!	O
(	O
c	pointer
->	O
flags	int
&	O
FINISHLATER	int
)	O
)	O
{	O
if	O
(	O
c	pointer
->	O
allocfinished	pointer
!=	O
NULL	O
)	O
c	pointer
->	O
allocfinished	pointer
(	O
c	pointer
)	O
;	O
}	O
else	O
c	pointer
->	O
flags	int
|=	O
UNFINISHED	int
;	O
if	O
(	O
context	pointer
->	O
size	int
!=	O
ncolors	int
||	O
needupdate	int
)	O
{	O
context	pointer
->	O
version	int
++	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
mkdefaultpalette	function
(	O
struct	O
palette	struct
*	O
c	pointer
)	O
{	O
int	O
i	pointer
,	O
ncolors	int
=	O
c	pointer
->	O
size	int
;	O
context	pointer
=	O
c	pointer
;	O
needupdate	int
=	O
0	int
;	O
segmentsize	int
=	O
8	int
;	O
if	O
(	O
c	pointer
->	O
flags	int
&	O
DONOTCHANGE	int
)	O
return	O
0	int
;	O
memcpy	function
(	O
colors	array
,	O
colors1	array
,	O
sizeof	O
(	O
colors1	array
)	O
)	O
;	O
maxentries	int
=	O
context	pointer
->	O
maxentries	int
;	O
if	O
(	O
c	pointer
->	O
flags	int
&	O
UNKNOWNENTRIES	int
)	O
i	pointer
=	O
128	int
/	O
8	int
;	O
else	O
i	pointer
=	O
(	O
maxentries	int
+	O
3	int
)	O
/	O
8	int
;	O
if	O
(	O
i	pointer
<	O
0	int
)	O
i	pointer
=	O
1	int
;	O
mksmooth	function
(	O
255	int
/	O
8	int
,	O
i	pointer
)	O
;	O
if	O
(	O
!	O
(	O
c	pointer
->	O
flags	int
&	O
FINISHLATER	int
)	O
)	O
{	O
if	O
(	O
c	pointer
->	O
allocfinished	pointer
!=	O
NULL	O
)	O
c	pointer
->	O
allocfinished	pointer
(	O
c	pointer
)	O
;	O
}	O
else	O
c	pointer
->	O
flags	int
|=	O
UNFINISHED	int
;	O
if	O
(	O
context	pointer
->	O
size	int
!=	O
ncolors	int
||	O
needupdate	int
)	O
{	O
context	pointer
->	O
version	int
++	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
shiftpalette	function
(	O
struct	O
palette	struct
*	O
c	pointer
,	O
int	O
shift	int
)	O
{	O
if	O
(	O
!	O
c	pointer
->	O
size	int
)	O
return	O
0	int
;	O
while	O
(	O
shift	int
<	O
0	int
)	O
shift	int
+=	O
c	pointer
->	O
size	int
-	O
1	int
;	O
shift	int
=	O
shift	int
%	O
(	O
c	pointer
->	O
size	int
-	O
1	int
)	O
;	O
if	O
(	O
!	O
shift	int
)	O
return	O
0	int
;	O
if	O
(	O
c	pointer
->	O
cyclecolors	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
c	pointer
->	O
flags	int
&	O
UNFINISHED	int
)	O
{	O
cycle_entries	function
(	O
c	pointer
,	O
shift	int
)	O
;	O
}	O
else	O
{	O
c	pointer
->	O
cyclecolors	pointer
(	O
c	pointer
,	O
shift	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
if	O
(	O
c	pointer
->	O
type	int
&	O
(	O
TRUECOLORS	O
|	O
TRUECOLOR24	int
|	O
HICOLOR	int
|	O
REALCOLOR	int
)	O
)	O
{	O
int	O
i	pointer
;	O
int	O
i3	int
;	O
int	O
*	O
co	pointer
;	O
if	O
(	O
shift	int
>	O
0	int
)	O
shift	int
%=	O
c	pointer
->	O
size	int
-	O
1	int
;	O
else	O
shift	int
=	O
-	O
(	O
(	O
-	O
shift	int
)	O
%	O
(	O
c	pointer
->	O
size	int
-	O
1	int
)	O
)	O
;	O
if	O
(	O
!	O
shift	int
)	O
return	O
0	int
;	O
co	pointer
=	O
malloc	function
(	O
c	pointer
->	O
size	int
*	O
sizeof	O
(	O
*	O
co	pointer
)	O
)	O
;	O
memcpy	function
(	O
co	pointer
,	O
c	pointer
->	O
pixels	pointer
,	O
sizeof	O
(	O
*	O
co	pointer
)	O
*	O
c	pointer
->	O
size	int
)	O
;	O
i3	int
=	O
(	O
c	pointer
->	O
size	int
-	O
1	int
+	O
shift	int
)	O
%	O
(	O
c	pointer
->	O
size	int
-	O
1	int
)	O
+	O
1	int
;	O
for	O
(	O
i	pointer
=	O
1	int
;	O
i	pointer
<	O
c	pointer
->	O
size	int
;	O
i	pointer
++	O
)	O
{	O
c	pointer
->	O
pixels	pointer
[	O
i	pointer
]	O
=	O
co	pointer
[	O
i3	int
]	O
;	O
i3	int
++	O
;	O
if	O
(	O
i3	int
>=	O
c	pointer
->	O
size	int
)	O
i3	int
=	O
1	int
;	O
}	O
free	function
(	O
co	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
allocrgb	function
(	O
struct	O
palette	struct
*	O
c	pointer
,	O
int	O
r1	int
,	O
int	O
g1	int
,	O
int	O
b1	int
)	O
{	O
int	O
r	int
,	O
g	int
,	O
b	int
;	O
int	O
f	pointer
=	O
1	int
;	O
for	O
(	O
g	int
=	O
0	int
;	O
g	int
<	O
g1	int
;	O
g	int
++	O
)	O
for	O
(	O
b	int
=	O
0	int
;	O
b	int
<	O
b1	int
;	O
b	int
++	O
)	O
{	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
r1	int
;	O
r	int
++	O
)	O
{	O
if	O
(	O
!	O
allocate	function
(	O
r	int
*	O
255	int
/	O
(	O
r1	int
-	O
1	int
)	O
,	O
g	int
*	O
255	int
/	O
(	O
g1	int
-	O
1	int
)	O
,	O
b	int
*	O
255	int
/	O
(	O
b1	int
-	O
1	int
)	O
,	O
f	pointer
)	O
)	O
return	O
0	int
;	O
f	pointer
=	O
0	int
;	O
}	O
}	O
return	O
1	int
;	O
}	O
int	O
mkrgb	function
(	O
struct	O
palette	struct
*	O
c	pointer
)	O
{	O
int	O
ncolors	int
=	O
c	pointer
->	O
size	int
;	O
int	O
red	pointer
=	O
8	int
,	O
green	pointer
=	O
8	int
,	O
blue	pointer
=	O
4	int
;	O
context	pointer
=	O
c	pointer
;	O
needupdate	int
=	O
0	int
;	O
if	O
(	O
c	pointer
->	O
flags	int
&	O
UNKNOWNENTRIES	int
)	O
{	O
while	O
(	O
blue	pointer
>	O
0	int
)	O
{	O
if	O
(	O
allocrgb	function
(	O
c	pointer
,	O
red	pointer
,	O
green	pointer
,	O
blue	pointer
)	O
)	O
break	O
;	O
red	pointer
--	O
;	O
if	O
(	O
allocrgb	function
(	O
c	pointer
,	O
red	pointer
,	O
green	pointer
,	O
blue	pointer
)	O
)	O
break	O
;	O
green	pointer
--	O
;	O
if	O
(	O
allocrgb	function
(	O
c	pointer
,	O
red	pointer
,	O
green	pointer
,	O
blue	pointer
)	O
)	O
break	O
;	O
red	pointer
--	O
;	O
if	O
(	O
allocrgb	function
(	O
c	pointer
,	O
red	pointer
,	O
green	pointer
,	O
blue	pointer
)	O
)	O
break	O
;	O
green	pointer
--	O
;	O
if	O
(	O
allocrgb	function
(	O
c	pointer
,	O
red	pointer
,	O
green	pointer
,	O
blue	pointer
)	O
)	O
break	O
;	O
blue	pointer
--	O
;	O
}	O
}	O
else	O
{	O
number_t	double
n	int
=	O
pow	function
(	O
c	pointer
->	O
maxentries	int
/	O
(	O
0.5	int
*	O
0.2	int
*	O
0.3	int
)	O
,	O
1.0	int
/	O
3	int
)	O
;	O
green	pointer
=	O
n	int
*	O
0.5	int
;	O
blue	pointer
=	O
n	int
*	O
0.2	int
;	O
red	pointer
=	O
n	int
*	O
0.3	int
;	O
while	O
(	O
(	O
blue	pointer
+	O
1	int
)	O
*	O
red	pointer
*	O
green	pointer
<	O
c	pointer
->	O
maxentries	int
)	O
blue	pointer
++	O
;	O
while	O
(	O
(	O
red	pointer
+	O
1	int
)	O
*	O
blue	pointer
*	O
green	pointer
<	O
c	pointer
->	O
maxentries	int
)	O
red	pointer
++	O
;	O
while	O
(	O
(	O
green	pointer
+	O
1	int
)	O
*	O
blue	pointer
*	O
red	pointer
<	O
c	pointer
->	O
maxentries	int
)	O
green	pointer
++	O
;	O
allocrgb	function
(	O
c	pointer
,	O
red	pointer
,	O
green	pointer
,	O
blue	pointer
)	O
;	O
}	O
if	O
(	O
!	O
(	O
c	pointer
->	O
flags	int
&	O
FINISHLATER	int
)	O
)	O
{	O
if	O
(	O
c	pointer
->	O
allocfinished	pointer
!=	O
NULL	O
)	O
c	pointer
->	O
allocfinished	pointer
(	O
c	pointer
)	O
;	O
}	O
else	O
c	pointer
->	O
flags	int
|=	O
UNFINISHED	int
;	O
if	O
(	O
context	pointer
->	O
size	int
!=	O
ncolors	int
||	O
needupdate	int
)	O
{	O
context	pointer
->	O
version	int
++	O
;	O
}	O
return	O
red	pointer
*	O
256	int
*	O
256	int
+	O
green	pointer
*	O
256	int
+	O
blue	pointer
;	O
}	O
