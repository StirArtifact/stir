lex_pos_ty	struct
gram_pos	struct
;	O
int	O
gram_pos_column	int
;	O
void	O
po_gram_error	function
(	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
char	O
*	O
buffer	pointer
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
if	O
(	O
vasprintf	function
(	O
&	O
buffer	pointer
,	O
fmt	pointer
,	O
ap	array
)	O
<	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"memory exhausted"	pointer
)	O
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
po_xerror	pointer
(	O
PO_SEVERITY_ERROR	int
,	O
NULL	O
,	O
gram_pos	struct
.	O
file_name	pointer
,	O
gram_pos	struct
.	O
line_number	long
,	O
gram_pos_column	int
+	O
1	int
,	O
false	int
,	O
buffer	pointer
)	O
;	O
free	function
(	O
buffer	pointer
)	O
;	O
if	O
(	O
error_message_count	int
>=	O
gram_max_allowed_errors	int
)	O
po_error	pointer
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"too many errors, aborting"	pointer
)	O
)	O
;	O
}	O
void	O
po_gram_error_at_line	function
(	O
const	O
lex_pos_ty	struct
*	O
pp	pointer
,	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
char	O
*	O
buffer	pointer
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
if	O
(	O
vasprintf	function
(	O
&	O
buffer	pointer
,	O
fmt	pointer
,	O
ap	array
)	O
<	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"memory exhausted"	pointer
)	O
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
po_xerror	pointer
(	O
PO_SEVERITY_ERROR	int
,	O
NULL	O
,	O
pp	pointer
->	O
file_name	pointer
,	O
pp	pointer
->	O
line_number	long
,	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
,	O
false	int
,	O
buffer	pointer
)	O
;	O
free	function
(	O
buffer	pointer
)	O
;	O
if	O
(	O
error_message_count	int
>=	O
gram_max_allowed_errors	int
)	O
po_error	pointer
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"too many errors, aborting"	pointer
)	O
)	O
;	O
}	O
struct	O
mbchar	struct
{	O
size_t	long
bytes	long
;	O
bool	bool
uc_valid	bool
;	O
ucs4_t	int
uc	int
;	O
char	O
buf	array
[	O
MBCHAR_BUF_SIZE	int
]	O
;	O
}	O
;	O
typedef	O
struct	O
mbchar	struct
mbchar_t	array
[	O
1	int
]	O
;	O
static	O
inline	O
void	O
memcpy_small	function
(	O
void	O
*	O
dst	pointer
,	O
const	O
void	O
*	O
src	pointer
,	O
size_t	long
n	long
)	O
{	O
if	O
(	O
n	long
>	O
0	int
)	O
{	O
char	O
*	O
q	pointer
=	O
(	O
char	O
*	O
)	O
dst	pointer
;	O
const	O
char	O
*	O
p	pointer
=	O
(	O
const	O
char	O
*	O
)	O
src	pointer
;	O
*	O
q	pointer
=	O
*	O
p	pointer
;	O
if	O
(	O
--	O
n	long
>	O
0	int
)	O
do	O
*	O
++	O
q	pointer
=	O
*	O
++	O
p	pointer
;	O
while	O
(	O
--	O
n	long
>	O
0	int
)	O
;	O
}	O
}	O
static	O
inline	O
bool	bool
mb_iseof	function
(	O
const	O
mbchar_t	array
mbc	array
)	O
{	O
return	O
(	O
mbc	array
->	O
bytes	long
==	O
0	int
)	O
;	O
}	O
static	O
inline	O
const	O
char	O
*	O
mb_ptr	function
(	O
const	O
mbchar_t	array
mbc	array
)	O
{	O
return	O
mbc	array
->	O
buf	array
;	O
}	O
static	O
inline	O
size_t	long
mb_len	function
(	O
const	O
mbchar_t	array
mbc	array
)	O
{	O
return	O
mbc	array
->	O
bytes	long
;	O
}	O
static	O
inline	O
bool	bool
mb_iseq	function
(	O
const	O
mbchar_t	array
mbc	array
,	O
char	O
sc	char
)	O
{	O
return	O
(	O
mbc	array
->	O
bytes	long
==	O
1	int
&&	O
mbc	array
->	O
buf	array
[	O
0	int
]	O
==	O
sc	char
)	O
;	O
}	O
static	O
inline	O
bool	bool
mb_isnul	function
(	O
const	O
mbchar_t	array
mbc	array
)	O
{	O
if	O
(	O
mbc	array
->	O
uc_valid	bool
)	O
return	O
(	O
mbc	array
->	O
uc	int
==	O
0	int
)	O
;	O
else	O
return	O
(	O
mbc	array
->	O
bytes	long
==	O
1	int
&&	O
mbc	array
->	O
buf	array
[	O
0	int
]	O
==	O
0	int
)	O
;	O
}	O
static	O
inline	O
int	O
mb_cmp	function
(	O
const	O
mbchar_t	array
mbc1	array
,	O
const	O
mbchar_t	array
mbc2	array
)	O
{	O
if	O
(	O
mbc1	array
->	O
uc_valid	bool
&&	O
mbc2	array
->	O
uc_valid	bool
)	O
return	O
(	O
int	O
)	O
mbc1	array
->	O
uc	int
-	O
(	O
int	O
)	O
mbc2	array
->	O
uc	int
;	O
else	O
return	O
(	O
mbc1	array
->	O
bytes	long
==	O
mbc2	array
->	O
bytes	long
?	O
memcmp	function
(	O
mbc1	array
->	O
buf	array
,	O
mbc2	array
->	O
buf	array
,	O
mbc1	array
->	O
bytes	long
)	O
:	O
mbc1	array
->	O
bytes	long
<	O
mbc2	array
->	O
bytes	long
?	O
(	O
memcmp	function
(	O
mbc1	array
->	O
buf	array
,	O
mbc2	array
->	O
buf	array
,	O
mbc1	array
->	O
bytes	long
)	O
>	O
0	int
?	O
1	int
:	O
-	O
1	int
)	O
:	O
(	O
memcmp	function
(	O
mbc1	array
->	O
buf	array
,	O
mbc2	array
->	O
buf	array
,	O
mbc2	array
->	O
bytes	long
)	O
>=	O
0	int
?	O
1	int
:	O
-	O
1	int
)	O
)	O
;	O
}	O
static	O
inline	O
bool	bool
mb_equal	function
(	O
const	O
mbchar_t	array
mbc1	array
,	O
const	O
mbchar_t	array
mbc2	array
)	O
{	O
if	O
(	O
mbc1	array
->	O
uc_valid	bool
&&	O
mbc2	array
->	O
uc_valid	bool
)	O
return	O
mbc1	array
->	O
uc	int
==	O
mbc2	array
->	O
uc	int
;	O
else	O
return	O
(	O
mbc1	array
->	O
bytes	long
==	O
mbc2	array
->	O
bytes	long
&&	O
memcmp	function
(	O
mbc1	array
->	O
buf	array
,	O
mbc2	array
->	O
buf	array
,	O
mbc1	array
->	O
bytes	long
)	O
==	O
0	int
)	O
;	O
}	O
static	O
inline	O
bool	bool
mb_isascii	function
(	O
const	O
mbchar_t	array
mbc	array
)	O
{	O
if	O
(	O
mbc	array
->	O
uc_valid	bool
)	O
return	O
(	O
mbc	array
->	O
uc	int
>=	O
0x0000	int
&&	O
mbc	array
->	O
uc	int
<=	O
0x007F	int
)	O
;	O
else	O
return	O
(	O
mbc	array
->	O
bytes	long
==	O
1	int
&&	O
mbc	array
->	O
buf	array
[	O
0	int
]	O
>=	O
0x00	int
)	O
;	O
}	O
static	O
int	O
mb_width	function
(	O
const	O
mbchar_t	array
mbc	array
)	O
{	O
if	O
(	O
mbc	array
->	O
uc_valid	bool
)	O
{	O
ucs4_t	int
uc	int
=	O
mbc	array
->	O
uc	int
;	O
const	O
char	O
*	O
encoding	pointer
=	O
(	O
po_lex_iconv	pointer
!=	O
(	O
iconv_t	pointer
)	O
(	O
-	O
1	int
)	O
?	O
po_lex_charset	pointer
:	O
""	pointer
)	O
;	O
int	O
w	int
=	O
uc_width	function
(	O
uc	int
,	O
encoding	pointer
)	O
;	O
if	O
(	O
w	int
>=	O
0	int
)	O
return	O
w	int
;	O
if	O
(	O
uc	int
>=	O
0x0000	int
&&	O
uc	int
<=	O
0x001F	int
)	O
{	O
if	O
(	O
uc	int
==	O
0x0009	int
)	O
return	O
8	int
-	O
(	O
gram_pos_column	int
&	O
7	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
(	O
uc	int
>=	O
0x007F	int
&&	O
uc	int
<=	O
0x009F	int
)	O
||	O
(	O
uc	int
>=	O
0x2028	int
&&	O
uc	int
<=	O
0x2029	int
)	O
)	O
return	O
0	int
;	O
return	O
MB_UNPRINTABLE_WIDTH	int
;	O
}	O
else	O
{	O
if	O
(	O
mbc	array
->	O
bytes	long
==	O
1	int
)	O
{	O
if	O
(	O
mbc	array
->	O
buf	array
[	O
0	int
]	O
>=	O
0x00	int
&&	O
mbc	array
->	O
buf	array
[	O
0	int
]	O
<=	O
0x1F	int
)	O
{	O
if	O
(	O
mbc	array
->	O
buf	array
[	O
0	int
]	O
==	O
0x09	int
)	O
return	O
8	int
-	O
(	O
gram_pos_column	int
&	O
7	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
mbc	array
->	O
buf	array
[	O
0	int
]	O
==	O
0x7F	int
)	O
return	O
0	int
;	O
}	O
return	O
MB_UNPRINTABLE_WIDTH	int
;	O
}	O
}	O
static	O
inline	O
void	O
mb_putc	function
(	O
const	O
mbchar_t	array
mbc	array
,	O
FILE	struct
*	O
stream	pointer
)	O
{	O
fwrite	function
(	O
mbc	array
->	O
buf	array
,	O
1	int
,	O
mbc	array
->	O
bytes	long
,	O
stream	pointer
)	O
;	O
}	O
static	O
inline	O
void	O
mb_setascii	function
(	O
mbchar_t	array
mbc	array
,	O
char	O
sc	char
)	O
{	O
mbc	array
->	O
bytes	long
=	O
1	int
;	O
mbc	array
->	O
uc_valid	bool
=	O
1	int
;	O
mbc	array
->	O
uc	int
=	O
sc	char
;	O
mbc	array
->	O
buf	array
[	O
0	int
]	O
=	O
sc	char
;	O
}	O
static	O
inline	O
void	O
mb_copy	function
(	O
mbchar_t	array
new_mbc	array
,	O
const	O
mbchar_t	array
old_mbc	array
)	O
{	O
memcpy_small	function
(	O
&	O
new_mbc	array
->	O
buf	array
[	O
0	int
]	O
,	O
&	O
old_mbc	array
->	O
buf	array
[	O
0	int
]	O
,	O
old_mbc	array
->	O
bytes	long
)	O
;	O
new_mbc	array
->	O
bytes	long
=	O
old_mbc	array
->	O
bytes	long
;	O
if	O
(	O
(	O
new_mbc	array
->	O
uc_valid	bool
=	O
old_mbc	array
->	O
uc_valid	bool
)	O
)	O
new_mbc	array
->	O
uc	int
=	O
old_mbc	array
->	O
uc	int
;	O
}	O
struct	O
mbfile	struct
{	O
FILE	struct
*	O
fp	pointer
;	O
bool	bool
eof_seen	bool
;	O
int	O
have_pushback	int
;	O
unsigned	O
int	O
bufcount	int
;	O
char	O
buf	array
[	O
MBCHAR_BUF_SIZE	int
]	O
;	O
struct	O
mbchar	struct
pushback	array
[	O
NPUSHBACK	int
]	O
;	O
}	O
;	O
typedef	O
struct	O
mbfile	struct
mbfile_t	array
[	O
1	int
]	O
;	O
static	O
bool	bool
signal_eilseq	bool
;	O
static	O
inline	O
void	O
mbfile_init	function
(	O
mbfile_t	array
mbf	array
,	O
FILE	struct
*	O
stream	pointer
)	O
{	O
mbf	array
->	O
fp	pointer
=	O
stream	pointer
;	O
mbf	array
->	O
eof_seen	bool
=	O
false	int
;	O
mbf	array
->	O
have_pushback	int
=	O
0	int
;	O
mbf	array
->	O
bufcount	int
=	O
0	int
;	O
}	O
static	O
void	O
mbfile_getc	function
(	O
mbchar_t	array
mbc	array
,	O
mbfile_t	array
mbf	array
)	O
{	O
size_t	long
bytes	long
;	O
if	O
(	O
mbf	array
->	O
eof_seen	bool
)	O
goto	O
eof	O
;	O
if	O
(	O
mbf	array
->	O
have_pushback	int
>	O
0	int
)	O
{	O
mbf	array
->	O
have_pushback	int
--	O
;	O
mb_copy	function
(	O
mbc	array
,	O
&	O
mbf	array
->	O
pushback	array
[	O
mbf	array
->	O
have_pushback	int
]	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
mbf	array
->	O
bufcount	int
==	O
0	int
)	O
{	O
int	O
c	int
=	O
getc	function
(	O
mbf	array
->	O
fp	pointer
)	O
;	O
if	O
(	O
c	int
==	O
EOF	O
)	O
{	O
mbf	array
->	O
eof_seen	bool
=	O
true	int
;	O
goto	O
eof	O
;	O
}	O
mbf	array
->	O
buf	array
[	O
0	int
]	O
=	O
(	O
unsigned	O
char	O
)	O
c	int
;	O
mbf	array
->	O
bufcount	int
++	O
;	O
}	O
if	O
(	O
po_lex_iconv	pointer
!=	O
(	O
iconv_t	pointer
)	O
(	O
-	O
1	int
)	O
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
unsigned	O
char	O
scratchbuf	array
[	O
64	int
]	O
;	O
const	O
char	O
*	O
inptr	pointer
=	O
&	O
mbf	array
->	O
buf	array
[	O
0	int
]	O
;	O
size_t	long
insize	long
=	O
mbf	array
->	O
bufcount	int
;	O
char	O
*	O
outptr	pointer
=	O
(	O
char	O
*	O
)	O
&	O
scratchbuf	array
[	O
0	int
]	O
;	O
size_t	long
outsize	long
=	O
sizeof	O
(	O
scratchbuf	array
)	O
;	O
size_t	long
res	long
=	O
iconv	function
(	O
po_lex_iconv	pointer
,	O
(	O
ICONV_CONST	O
char	O
*	O
*	O
)	O
&	O
inptr	pointer
,	O
&	O
insize	long
,	O
&	O
outptr	pointer
,	O
&	O
outsize	long
)	O
;	O
if	O
(	O
(	O
insize	long
<	O
mbf	array
->	O
bufcount	int
)	O
!=	O
(	O
outsize	long
<	O
sizeof	O
(	O
scratchbuf	array
)	O
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
outsize	long
==	O
sizeof	O
(	O
scratchbuf	array
)	O
)	O
{	O
if	O
(	O
res	long
!=	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
errno	O
==	O
EILSEQ	int
)	O
{	O
if	O
(	O
signal_eilseq	bool
)	O
po_gram_error	function
(	O
_	O
(	O
"invalid multibyte sequence"	pointer
)	O
)	O
;	O
bytes	long
=	O
1	int
;	O
mbc	array
->	O
uc_valid	bool
=	O
false	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
errno	O
==	O
EINVAL	int
)	O
{	O
int	O
c	int
;	O
if	O
(	O
mbf	array
->	O
bufcount	int
==	O
MBCHAR_BUF_SIZE	int
)	O
{	O
bytes	long
=	O
1	int
;	O
mbc	array
->	O
uc_valid	bool
=	O
false	int
;	O
break	O
;	O
}	O
c	int
=	O
getc	function
(	O
mbf	array
->	O
fp	pointer
)	O
;	O
if	O
(	O
c	int
==	O
EOF	O
)	O
{	O
mbf	array
->	O
eof_seen	bool
=	O
true	int
;	O
if	O
(	O
ferror	function
(	O
mbf	array
->	O
fp	pointer
)	O
)	O
goto	O
eof	O
;	O
if	O
(	O
signal_eilseq	bool
)	O
po_gram_error	function
(	O
_	O
(	O
"incomplete multibyte sequence at end of file"	pointer
)	O
)	O
;	O
bytes	long
=	O
mbf	array
->	O
bufcount	int
;	O
mbc	array
->	O
uc_valid	bool
=	O
false	int
;	O
break	O
;	O
}	O
mbf	array
->	O
buf	array
[	O
mbf	array
->	O
bufcount	int
++	O
]	O
=	O
(	O
unsigned	O
char	O
)	O
c	int
;	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
{	O
if	O
(	O
signal_eilseq	bool
)	O
po_gram_error	function
(	O
_	O
(	O
"incomplete multibyte sequence at end of line"	pointer
)	O
)	O
;	O
bytes	long
=	O
mbf	array
->	O
bufcount	int
-	O
1	int
;	O
mbc	array
->	O
uc_valid	bool
=	O
false	int
;	O
break	O
;	O
}	O
}	O
else	O
{	O
const	O
char	O
*	O
errno_description	pointer
=	O
strerror	function
(	O
errno	O
)	O
;	O
po_xerror	pointer
(	O
PO_SEVERITY_FATAL_ERROR	int
,	O
NULL	O
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	int
,	O
xasprintf	function
(	O
"%s: %s"	pointer
,	O
_	O
(	O
"iconv failure"	pointer
)	O
,	O
errno_description	pointer
)	O
)	O
;	O
}	O
}	O
else	O
{	O
size_t	long
outbytes	long
=	O
sizeof	O
(	O
scratchbuf	array
)	O
-	O
outsize	long
;	O
bytes	long
=	O
mbf	array
->	O
bufcount	int
-	O
insize	long
;	O
if	O
(	O
bytes	long
==	O
0	int
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
outbytes	long
==	O
0	int
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
u8_mbtoucr	function
(	O
&	O
mbc	array
->	O
uc	int
,	O
scratchbuf	array
,	O
outbytes	long
)	O
<	O
(	O
int	O
)	O
outbytes	long
)	O
{	O
if	O
(	O
signal_eilseq	bool
)	O
po_gram_error	function
(	O
_	O
(	O
"invalid multibyte sequence"	pointer
)	O
)	O
;	O
mbc	array
->	O
uc_valid	bool
=	O
false	int
;	O
break	O
;	O
}	O
mbc	array
->	O
uc_valid	bool
=	O
true	int
;	O
break	O
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
po_lex_weird_cjk	bool
&&	O
(	O
unsigned	O
char	O
)	O
mbf	array
->	O
buf	array
[	O
0	int
]	O
>=	O
0x80	int
)	O
{	O
if	O
(	O
mbf	array
->	O
bufcount	int
==	O
1	int
)	O
{	O
int	O
c	int
=	O
getc	function
(	O
mbf	array
->	O
fp	pointer
)	O
;	O
if	O
(	O
c	int
==	O
EOF	O
)	O
{	O
if	O
(	O
ferror	function
(	O
mbf	array
->	O
fp	pointer
)	O
)	O
{	O
mbf	array
->	O
eof_seen	bool
=	O
true	int
;	O
goto	O
eof	O
;	O
}	O
}	O
else	O
{	O
mbf	array
->	O
buf	array
[	O
1	int
]	O
=	O
(	O
unsigned	O
char	O
)	O
c	int
;	O
mbf	array
->	O
bufcount	int
++	O
;	O
}	O
}	O
if	O
(	O
mbf	array
->	O
bufcount	int
>=	O
2	int
&&	O
(	O
unsigned	O
char	O
)	O
mbf	array
->	O
buf	array
[	O
1	int
]	O
>=	O
0x30	int
)	O
bytes	long
=	O
2	int
;	O
else	O
bytes	long
=	O
1	int
;	O
}	O
else	O
{	O
bytes	long
=	O
1	int
;	O
}	O
mbc	array
->	O
uc_valid	bool
=	O
false	int
;	O
}	O
memcpy_small	function
(	O
&	O
mbc	array
->	O
buf	array
[	O
0	int
]	O
,	O
&	O
mbf	array
->	O
buf	array
[	O
0	int
]	O
,	O
bytes	long
)	O
;	O
mbc	array
->	O
bytes	long
=	O
bytes	long
;	O
mbf	array
->	O
bufcount	int
-=	O
bytes	long
;	O
if	O
(	O
mbf	array
->	O
bufcount	int
>	O
0	int
)	O
{	O
unsigned	O
int	O
count	int
=	O
mbf	array
->	O
bufcount	int
;	O
char	O
*	O
p	pointer
=	O
&	O
mbf	array
->	O
buf	array
[	O
0	int
]	O
;	O
do	O
{	O
*	O
p	pointer
=	O
*	O
(	O
p	pointer
+	O
bytes	long
)	O
;	O
p	pointer
++	O
;	O
}	O
while	O
(	O
--	O
count	int
>	O
0	int
)	O
;	O
}	O
return	O
;	O
eof	O
:	O
mbc	array
->	O
bytes	long
=	O
0	int
;	O
mbc	array
->	O
uc_valid	bool
=	O
false	int
;	O
return	O
;	O
}	O
static	O
void	O
mbfile_ungetc	function
(	O
const	O
mbchar_t	array
mbc	array
,	O
mbfile_t	array
mbf	array
)	O
{	O
if	O
(	O
mbf	array
->	O
have_pushback	int
>=	O
NPUSHBACK	int
)	O
abort	function
(	O
)	O
;	O
mb_copy	function
(	O
&	O
mbf	array
->	O
pushback	array
[	O
mbf	array
->	O
have_pushback	int
]	O
,	O
mbc	array
)	O
;	O
mbf	array
->	O
have_pushback	int
++	O
;	O
}	O
static	O
mbfile_t	array
mbf	array
;	O
unsigned	O
int	O
gram_max_allowed_errors	int
=	O
20	int
;	O
static	O
bool	bool
po_lex_obsolete	bool
;	O
static	O
bool	bool
po_lex_previous	bool
;	O
static	O
bool	bool
pass_comments	bool
=	O
false	int
;	O
bool	bool
pass_obsolete_entries	bool
=	O
false	int
;	O
void	O
lex_start	function
(	O
FILE	struct
*	O
fp	pointer
,	O
const	O
char	O
*	O
real_filename	pointer
,	O
const	O
char	O
*	O
logical_filename	pointer
)	O
{	O
gram_pos	struct
.	O
file_name	pointer
=	O
xstrdup	function
(	O
real_filename	pointer
)	O
;	O
mbfile_init	function
(	O
mbf	array
,	O
fp	pointer
)	O
;	O
gram_pos	struct
.	O
line_number	long
=	O
1	int
;	O
gram_pos_column	int
=	O
0	int
;	O
signal_eilseq	bool
=	O
true	int
;	O
po_lex_obsolete	bool
=	O
false	int
;	O
po_lex_previous	bool
=	O
false	int
;	O
po_lex_charset_init	function
(	O
)	O
;	O
}	O
void	O
lex_end	function
(	O
)	O
{	O
mbf	array
->	O
fp	pointer
=	O
NULL	O
;	O
gram_pos	struct
.	O
file_name	pointer
=	O
NULL	O
;	O
gram_pos	struct
.	O
line_number	long
=	O
0	int
;	O
gram_pos_column	int
=	O
0	int
;	O
signal_eilseq	bool
=	O
false	int
;	O
po_lex_obsolete	bool
=	O
false	int
;	O
po_lex_previous	bool
=	O
false	int
;	O
po_lex_charset_close	function
(	O
)	O
;	O
}	O
static	O
void	O
lex_getc	function
(	O
mbchar_t	array
mbc	array
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
mbfile_getc	function
(	O
mbc	array
,	O
mbf	array
)	O
;	O
if	O
(	O
mb_iseof	function
(	O
mbc	array
)	O
)	O
{	O
if	O
(	O
ferror	function
(	O
mbf	array
->	O
fp	pointer
)	O
)	O
bomb	O
:	O
{	O
const	O
char	O
*	O
errno_description	pointer
=	O
strerror	function
(	O
errno	O
)	O
;	O
po_xerror	pointer
(	O
PO_SEVERITY_FATAL_ERROR	int
,	O
NULL	O
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	int
,	O
xasprintf	function
(	O
"%s: %s"	pointer
,	O
xasprintf	function
(	O
_	O
(	O
"error while reading \"%s\""	pointer
)	O
,	O
gram_pos	struct
.	O
file_name	pointer
)	O
,	O
errno_description	pointer
)	O
)	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
mb_iseq	function
(	O
mbc	array
,	O
'\n'	O
)	O
)	O
{	O
gram_pos	struct
.	O
line_number	long
++	O
;	O
gram_pos_column	int
=	O
0	int
;	O
break	O
;	O
}	O
gram_pos_column	int
+=	O
mb_width	function
(	O
mbc	array
)	O
;	O
if	O
(	O
mb_iseq	function
(	O
mbc	array
,	O
'\\'	O
)	O
)	O
{	O
mbchar_t	array
mbc2	array
;	O
mbfile_getc	function
(	O
mbc2	array
,	O
mbf	array
)	O
;	O
if	O
(	O
mb_iseof	function
(	O
mbc2	array
)	O
)	O
{	O
if	O
(	O
ferror	function
(	O
mbf	array
->	O
fp	pointer
)	O
)	O
goto	O
bomb	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
mb_iseq	function
(	O
mbc2	array
,	O
'\n'	O
)	O
)	O
{	O
mbfile_ungetc	function
(	O
mbc2	array
,	O
mbf	array
)	O
;	O
break	O
;	O
}	O
gram_pos	struct
.	O
line_number	long
++	O
;	O
gram_pos_column	int
=	O
0	int
;	O
}	O
else	O
break	O
;	O
}	O
}	O
static	O
void	O
lex_ungetc	function
(	O
const	O
mbchar_t	array
mbc	array
)	O
{	O
if	O
(	O
!	O
mb_iseof	function
(	O
mbc	array
)	O
)	O
{	O
if	O
(	O
mb_iseq	function
(	O
mbc	array
,	O
'\n'	O
)	O
)	O
gram_pos	struct
.	O
line_number	long
--	O
;	O
else	O
gram_pos_column	int
-=	O
mb_width	function
(	O
mbc	array
)	O
;	O
mbfile_ungetc	function
(	O
mbc	array
,	O
mbf	array
)	O
;	O
}	O
}	O
static	O
int	O
keyword_p	function
(	O
const	O
char	O
*	O
s	pointer
)	O
{	O
if	O
(	O
!	O
po_lex_previous	bool
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
s	pointer
,	O
"domain"	pointer
)	O
)	O
return	O
DOMAIN	int
;	O
if	O
(	O
!	O
strcmp	function
(	O
s	pointer
,	O
"msgid"	pointer
)	O
)	O
return	O
MSGID	int
;	O
if	O
(	O
!	O
strcmp	function
(	O
s	pointer
,	O
"msgid_plural"	pointer
)	O
)	O
return	O
MSGID_PLURAL	int
;	O
if	O
(	O
!	O
strcmp	function
(	O
s	pointer
,	O
"msgstr"	pointer
)	O
)	O
return	O
MSGSTR	int
;	O
if	O
(	O
!	O
strcmp	function
(	O
s	pointer
,	O
"msgctxt"	pointer
)	O
)	O
return	O
MSGCTXT	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
s	pointer
,	O
"msgid"	pointer
)	O
)	O
return	O
PREV_MSGID	int
;	O
if	O
(	O
!	O
strcmp	function
(	O
s	pointer
,	O
"msgid_plural"	pointer
)	O
)	O
return	O
PREV_MSGID_PLURAL	int
;	O
if	O
(	O
!	O
strcmp	function
(	O
s	pointer
,	O
"msgctxt"	pointer
)	O
)	O
return	O
PREV_MSGCTXT	int
;	O
}	O
po_gram_error_at_line	function
(	O
&	O
gram_pos	struct
,	O
_	O
(	O
"keyword \"%s\" unknown"	pointer
)	O
,	O
s	pointer
)	O
;	O
return	O
NAME	int
;	O
}	O
static	O
int	O
control_sequence	function
(	O
)	O
{	O
mbchar_t	array
mbc	array
;	O
int	O
val	int
;	O
int	O
max	int
;	O
lex_getc	function
(	O
mbc	array
)	O
;	O
if	O
(	O
mb_len	function
(	O
mbc	array
)	O
==	O
1	int
)	O
switch	O
(	O
mb_ptr	function
(	O
mbc	array
)	O
[	O
0	int
]	O
)	O
{	O
case	O
'n'	O
:	O
return	O
'\n'	O
;	O
case	O
't'	O
:	O
return	O
'\t'	O
;	O
case	O
'b'	O
:	O
return	O
'\b'	O
;	O
case	O
'r'	O
:	O
return	O
'\r'	O
;	O
case	O
'f'	O
:	O
return	O
'\f'	O
;	O
case	O
'v'	O
:	O
return	O
'\v'	O
;	O
case	O
'a'	O
:	O
return	O
'\a'	O
;	O
case	O
'\\'	O
:	O
case	O
'"'	O
:	O
return	O
mb_ptr	function
(	O
mbc	array
)	O
[	O
0	int
]	O
;	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
val	int
=	O
0	int
;	O
max	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
char	O
c	int
=	O
mb_ptr	function
(	O
mbc	array
)	O
[	O
0	int
]	O
;	O
val	int
=	O
val	int
*	O
8	int
+	O
(	O
c	int
-	O
'0'	O
)	O
;	O
if	O
(	O
++	O
max	int
==	O
3	int
)	O
break	O
;	O
lex_getc	function
(	O
mbc	array
)	O
;	O
if	O
(	O
mb_len	function
(	O
mbc	array
)	O
==	O
1	int
)	O
switch	O
(	O
mb_ptr	function
(	O
mbc	array
)	O
[	O
0	int
]	O
)	O
{	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
continue	O
;	O
default	O
:	O
break	O
;	O
}	O
lex_ungetc	function
(	O
mbc	array
)	O
;	O
break	O
;	O
}	O
return	O
val	int
;	O
case	O
'x'	O
:	O
lex_getc	function
(	O
mbc	array
)	O
;	O
if	O
(	O
mb_iseof	function
(	O
mbc	array
)	O
||	O
mb_len	function
(	O
mbc	array
)	O
!=	O
1	int
||	O
!	O
c_isxdigit	function
(	O
mb_ptr	function
(	O
mbc	array
)	O
[	O
0	int
]	O
)	O
)	O
break	O
;	O
val	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
char	O
c	int
=	O
mb_ptr	function
(	O
mbc	array
)	O
[	O
0	int
]	O
;	O
val	int
*=	O
16	int
;	O
if	O
(	O
c_isdigit	function
(	O
c	int
)	O
)	O
val	int
+=	O
c	int
-	O
'0'	O
;	O
else	O
if	O
(	O
c_isupper	function
(	O
c	int
)	O
)	O
val	int
+=	O
c	int
-	O
'A'	O
+	O
10	int
;	O
else	O
val	int
+=	O
c	int
-	O
'a'	O
+	O
10	int
;	O
lex_getc	function
(	O
mbc	array
)	O
;	O
if	O
(	O
mb_len	function
(	O
mbc	array
)	O
==	O
1	int
)	O
switch	O
(	O
mb_ptr	function
(	O
mbc	array
)	O
[	O
0	int
]	O
)	O
{	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
case	O
'a'	O
:	O
case	O
'b'	O
:	O
case	O
'c'	O
:	O
case	O
'd'	O
:	O
case	O
'e'	O
:	O
case	O
'f'	O
:	O
case	O
'A'	O
:	O
case	O
'B'	O
:	O
case	O
'C'	O
:	O
case	O
'D'	O
:	O
case	O
'E'	O
:	O
case	O
'F'	O
:	O
continue	O
;	O
default	O
:	O
break	O
;	O
}	O
lex_ungetc	function
(	O
mbc	array
)	O
;	O
break	O
;	O
}	O
return	O
val	int
;	O
}	O
lex_ungetc	function
(	O
mbc	array
)	O
;	O
po_gram_error	function
(	O
_	O
(	O
"invalid control sequence"	pointer
)	O
)	O
;	O
return	O
' '	O
;	O
}	O
int	O
po_gram_lex	function
(	O
)	O
{	O
static	O
char	O
*	O
buf	array
;	O
static	O
size_t	long
bufmax	long
;	O
mbchar_t	array
mbc	array
;	O
size_t	long
bufpos	long
;	O
for	O
(	O
;	O
;	O
)	O
{	O
lex_getc	function
(	O
mbc	array
)	O
;	O
if	O
(	O
mb_iseof	function
(	O
mbc	array
)	O
)	O
return	O
0	int
;	O
if	O
(	O
mb_len	function
(	O
mbc	array
)	O
==	O
1	int
)	O
switch	O
(	O
mb_ptr	function
(	O
mbc	array
)	O
[	O
0	int
]	O
)	O
{	O
case	O
'\n'	O
:	O
po_lex_obsolete	bool
=	O
false	int
;	O
po_lex_previous	bool
=	O
false	int
;	O
break	O
;	O
case	O
' '	O
:	O
case	O
'\t'	O
:	O
case	O
'\r'	O
:	O
case	O
'\f'	O
:	O
case	O
'\v'	O
:	O
break	O
;	O
case	O
'#'	O
:	O
lex_getc	function
(	O
mbc	array
)	O
;	O
if	O
(	O
mb_iseq	function
(	O
mbc	array
,	O
'~'	O
)	O
)	O
{	O
po_lex_obsolete	bool
=	O
true	int
;	O
lex_getc	function
(	O
mbc	array
)	O
;	O
if	O
(	O
mb_iseq	function
(	O
mbc	array
,	O
'|'	O
)	O
)	O
po_lex_previous	bool
=	O
true	int
;	O
else	O
lex_ungetc	function
(	O
mbc	array
)	O
;	O
break	O
;	O
}	O
if	O
(	O
mb_iseq	function
(	O
mbc	array
,	O
'|'	O
)	O
)	O
{	O
po_lex_previous	bool
=	O
true	int
;	O
break	O
;	O
}	O
signal_eilseq	bool
=	O
false	int
;	O
if	O
(	O
pass_comments	bool
)	O
{	O
bufpos	long
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
while	O
(	O
bufpos	long
+	O
mb_len	function
(	O
mbc	array
)	O
>=	O
bufmax	long
)	O
{	O
bufmax	long
+=	O
100	int
;	O
buf	array
=	O
xrealloc	function
(	O
buf	array
,	O
bufmax	long
)	O
;	O
}	O
if	O
(	O
mb_iseof	function
(	O
mbc	array
)	O
||	O
mb_iseq	function
(	O
mbc	array
,	O
'\n'	O
)	O
)	O
break	O
;	O
memcpy_small	function
(	O
&	O
buf	array
[	O
bufpos	long
]	O
,	O
mb_ptr	function
(	O
mbc	array
)	O
,	O
mb_len	function
(	O
mbc	array
)	O
)	O
;	O
bufpos	long
+=	O
mb_len	function
(	O
mbc	array
)	O
;	O
lex_getc	function
(	O
mbc	array
)	O
;	O
}	O
buf	array
[	O
bufpos	long
]	O
=	O
'\0'	O
;	O
po_gram_lval	union
.	O
string	pointer
.	O
string	pointer
=	O
buf	array
;	O
po_gram_lval	union
.	O
string	pointer
.	O
pos	pointer
=	O
gram_pos	struct
;	O
po_gram_lval	union
.	O
string	pointer
.	O
obsolete	bool
=	O
po_lex_obsolete	bool
;	O
po_lex_obsolete	bool
=	O
false	int
;	O
signal_eilseq	bool
=	O
true	int
;	O
return	O
COMMENT	int
;	O
}	O
else	O
{	O
while	O
(	O
!	O
mb_iseof	function
(	O
mbc	array
)	O
&&	O
!	O
mb_iseq	function
(	O
mbc	array
,	O
'\n'	O
)	O
)	O
lex_getc	function
(	O
mbc	array
)	O
;	O
po_lex_obsolete	bool
=	O
false	int
;	O
signal_eilseq	bool
=	O
true	int
;	O
}	O
break	O
;	O
case	O
'"'	O
:	O
bufpos	long
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
lex_getc	function
(	O
mbc	array
)	O
;	O
while	O
(	O
bufpos	long
+	O
mb_len	function
(	O
mbc	array
)	O
>=	O
bufmax	long
)	O
{	O
bufmax	long
+=	O
100	int
;	O
buf	array
=	O
xrealloc	function
(	O
buf	array
,	O
bufmax	long
)	O
;	O
}	O
if	O
(	O
mb_iseof	function
(	O
mbc	array
)	O
)	O
{	O
po_gram_error_at_line	function
(	O
&	O
gram_pos	struct
,	O
_	O
(	O
"end-of-file within string"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
mb_iseq	function
(	O
mbc	array
,	O
'\n'	O
)	O
)	O
{	O
po_gram_error_at_line	function
(	O
&	O
gram_pos	struct
,	O
_	O
(	O
"end-of-line within string"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
mb_iseq	function
(	O
mbc	array
,	O
'"'	O
)	O
)	O
break	O
;	O
if	O
(	O
mb_iseq	function
(	O
mbc	array
,	O
'\\'	O
)	O
)	O
{	O
buf	array
[	O
bufpos	long
++	O
]	O
=	O
control_sequence	function
(	O
)	O
;	O
continue	O
;	O
}	O
memcpy_small	function
(	O
&	O
buf	array
[	O
bufpos	long
]	O
,	O
mb_ptr	function
(	O
mbc	array
)	O
,	O
mb_len	function
(	O
mbc	array
)	O
)	O
;	O
bufpos	long
+=	O
mb_len	function
(	O
mbc	array
)	O
;	O
}	O
buf	array
[	O
bufpos	long
]	O
=	O
'\0'	O
;	O
if	O
(	O
strchr	function
(	O
buf	array
,	O
MSGCTXT_SEPARATOR	char
)	O
!=	O
NULL	O
)	O
po_gram_error_at_line	function
(	O
&	O
gram_pos	struct
,	O
_	O
(	O
"context separator <EOT> within string"	pointer
)	O
)	O
;	O
po_gram_lval	union
.	O
string	pointer
.	O
string	pointer
=	O
xstrdup	function
(	O
buf	array
)	O
;	O
po_gram_lval	union
.	O
string	pointer
.	O
pos	pointer
=	O
gram_pos	struct
;	O
po_gram_lval	union
.	O
string	pointer
.	O
obsolete	bool
=	O
po_lex_obsolete	bool
;	O
return	O
(	O
po_lex_previous	bool
?	O
PREV_STRING	int
:	O
STRING	int
)	O
;	O
case	O
'a'	O
:	O
case	O
'b'	O
:	O
case	O
'c'	O
:	O
case	O
'd'	O
:	O
case	O
'e'	O
:	O
case	O
'f'	O
:	O
case	O
'g'	O
:	O
case	O
'h'	O
:	O
case	O
'i'	O
:	O
case	O
'j'	O
:	O
case	O
'k'	O
:	O
case	O
'l'	O
:	O
case	O
'm'	O
:	O
case	O
'n'	O
:	O
case	O
'o'	O
:	O
case	O
'p'	O
:	O
case	O
'q'	O
:	O
case	O
'r'	O
:	O
case	O
's'	O
:	O
case	O
't'	O
:	O
case	O
'u'	O
:	O
case	O
'v'	O
:	O
case	O
'w'	O
:	O
case	O
'x'	O
:	O
case	O
'y'	O
:	O
case	O
'z'	O
:	O
case	O
'A'	O
:	O
case	O
'B'	O
:	O
case	O
'C'	O
:	O
case	O
'D'	O
:	O
case	O
'E'	O
:	O
case	O
'F'	O
:	O
case	O
'G'	O
:	O
case	O
'H'	O
:	O
case	O
'I'	O
:	O
case	O
'J'	O
:	O
case	O
'K'	O
:	O
case	O
'L'	O
:	O
case	O
'M'	O
:	O
case	O
'N'	O
:	O
case	O
'O'	O
:	O
case	O
'P'	O
:	O
case	O
'Q'	O
:	O
case	O
'R'	O
:	O
case	O
'S'	O
:	O
case	O
'T'	O
:	O
case	O
'U'	O
:	O
case	O
'V'	O
:	O
case	O
'W'	O
:	O
case	O
'X'	O
:	O
case	O
'Y'	O
:	O
case	O
'Z'	O
:	O
case	O
'_'	O
:	O
case	O
'$'	O
:	O
bufpos	long
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
char	O
c	int
=	O
mb_ptr	function
(	O
mbc	array
)	O
[	O
0	int
]	O
;	O
if	O
(	O
bufpos	long
+	O
1	int
>=	O
bufmax	long
)	O
{	O
bufmax	long
+=	O
100	int
;	O
buf	array
=	O
xrealloc	function
(	O
buf	array
,	O
bufmax	long
)	O
;	O
}	O
buf	array
[	O
bufpos	long
++	O
]	O
=	O
c	int
;	O
lex_getc	function
(	O
mbc	array
)	O
;	O
if	O
(	O
mb_len	function
(	O
mbc	array
)	O
==	O
1	int
)	O
switch	O
(	O
mb_ptr	function
(	O
mbc	array
)	O
[	O
0	int
]	O
)	O
{	O
default	O
:	O
break	O
;	O
case	O
'a'	O
:	O
case	O
'b'	O
:	O
case	O
'c'	O
:	O
case	O
'd'	O
:	O
case	O
'e'	O
:	O
case	O
'f'	O
:	O
case	O
'g'	O
:	O
case	O
'h'	O
:	O
case	O
'i'	O
:	O
case	O
'j'	O
:	O
case	O
'k'	O
:	O
case	O
'l'	O
:	O
case	O
'm'	O
:	O
case	O
'n'	O
:	O
case	O
'o'	O
:	O
case	O
'p'	O
:	O
case	O
'q'	O
:	O
case	O
'r'	O
:	O
case	O
's'	O
:	O
case	O
't'	O
:	O
case	O
'u'	O
:	O
case	O
'v'	O
:	O
case	O
'w'	O
:	O
case	O
'x'	O
:	O
case	O
'y'	O
:	O
case	O
'z'	O
:	O
case	O
'A'	O
:	O
case	O
'B'	O
:	O
case	O
'C'	O
:	O
case	O
'D'	O
:	O
case	O
'E'	O
:	O
case	O
'F'	O
:	O
case	O
'G'	O
:	O
case	O
'H'	O
:	O
case	O
'I'	O
:	O
case	O
'J'	O
:	O
case	O
'K'	O
:	O
case	O
'L'	O
:	O
case	O
'M'	O
:	O
case	O
'N'	O
:	O
case	O
'O'	O
:	O
case	O
'P'	O
:	O
case	O
'Q'	O
:	O
case	O
'R'	O
:	O
case	O
'S'	O
:	O
case	O
'T'	O
:	O
case	O
'U'	O
:	O
case	O
'V'	O
:	O
case	O
'W'	O
:	O
case	O
'X'	O
:	O
case	O
'Y'	O
:	O
case	O
'Z'	O
:	O
case	O
'_'	O
:	O
case	O
'$'	O
:	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
continue	O
;	O
}	O
break	O
;	O
}	O
lex_ungetc	function
(	O
mbc	array
)	O
;	O
buf	array
[	O
bufpos	long
]	O
=	O
'\0'	O
;	O
{	O
int	O
k	int
=	O
keyword_p	function
(	O
buf	array
)	O
;	O
if	O
(	O
k	int
==	O
NAME	int
)	O
{	O
po_gram_lval	union
.	O
string	pointer
.	O
string	pointer
=	O
xstrdup	function
(	O
buf	array
)	O
;	O
po_gram_lval	union
.	O
string	pointer
.	O
pos	pointer
=	O
gram_pos	struct
;	O
po_gram_lval	union
.	O
string	pointer
.	O
obsolete	bool
=	O
po_lex_obsolete	bool
;	O
}	O
else	O
{	O
po_gram_lval	union
.	O
pos	pointer
.	O
pos	pointer
=	O
gram_pos	struct
;	O
po_gram_lval	union
.	O
pos	pointer
.	O
obsolete	bool
=	O
po_lex_obsolete	bool
;	O
}	O
return	O
k	int
;	O
}	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
bufpos	long
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
char	O
c	int
=	O
mb_ptr	function
(	O
mbc	array
)	O
[	O
0	int
]	O
;	O
if	O
(	O
bufpos	long
+	O
1	int
>=	O
bufmax	long
)	O
{	O
bufmax	long
+=	O
100	int
;	O
buf	array
=	O
xrealloc	function
(	O
buf	array
,	O
bufmax	long
+	O
1	int
)	O
;	O
}	O
buf	array
[	O
bufpos	long
++	O
]	O
=	O
c	int
;	O
lex_getc	function
(	O
mbc	array
)	O
;	O
if	O
(	O
mb_len	function
(	O
mbc	array
)	O
==	O
1	int
)	O
switch	O
(	O
mb_ptr	function
(	O
mbc	array
)	O
[	O
0	int
]	O
)	O
{	O
default	O
:	O
break	O
;	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
continue	O
;	O
}	O
break	O
;	O
}	O
lex_ungetc	function
(	O
mbc	array
)	O
;	O
buf	array
[	O
bufpos	long
]	O
=	O
'\0'	O
;	O
po_gram_lval	union
.	O
number	long
.	O
number	long
=	O
atol	function
(	O
buf	array
)	O
;	O
po_gram_lval	union
.	O
number	long
.	O
pos	pointer
=	O
gram_pos	struct
;	O
po_gram_lval	union
.	O
number	long
.	O
obsolete	bool
=	O
po_lex_obsolete	bool
;	O
return	O
NUMBER	int
;	O
case	O
'['	O
:	O
po_gram_lval	union
.	O
pos	pointer
.	O
pos	pointer
=	O
gram_pos	struct
;	O
po_gram_lval	union
.	O
pos	pointer
.	O
obsolete	bool
=	O
po_lex_obsolete	bool
;	O
return	O
'['	O
;	O
case	O
']'	O
:	O
po_gram_lval	union
.	O
pos	pointer
.	O
pos	pointer
=	O
gram_pos	struct
;	O
po_gram_lval	union
.	O
pos	pointer
.	O
obsolete	bool
=	O
po_lex_obsolete	bool
;	O
return	O
']'	O
;	O
default	O
:	O
return	O
JUNK	int
;	O
}	O
else	O
return	O
JUNK	int
;	O
}	O
}	O
void	O
po_lex_pass_comments	function
(	O
bool	bool
flag	bool
)	O
{	O
pass_comments	bool
=	O
flag	bool
;	O
}	O
void	O
po_lex_pass_obsolete_entries	function
(	O
bool	bool
flag	bool
)	O
{	O
pass_obsolete_entries	bool
=	O
flag	bool
;	O
}	O
