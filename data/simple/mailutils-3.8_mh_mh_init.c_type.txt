void	O
mh_init	function
(	O
void	O
)	O
{	O
mu_stdstream_setup	function
(	O
MU_STDSTREAM_RESET_NONE	int
)	O
;	O
mu_register_all_formats	O
(	O
)	O
;	O
mh_read_profile	function
(	O
)	O
;	O
}	O
void	O
mh_init2	function
(	O
void	O
)	O
{	O
mh_current_folder	function
(	O
)	O
;	O
}	O
void	O
mh_err_memory	function
(	O
int	O
fatal	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"not enough memory"	pointer
)	O
)	O
;	O
if	O
(	O
fatal	int
)	O
abort	function
(	O
)	O
;	O
}	O
static	O
mu_address_t	pointer
mh_local_mailbox	function
(	O
void	O
)	O
{	O
static	O
mu_address_t	pointer
local_mailbox	pointer
;	O
if	O
(	O
!	O
local_mailbox	pointer
)	O
{	O
const	O
char	O
*	O
p	pointer
=	O
mh_global_profile_get	O
(	O
"Local-Mailbox"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
p	pointer
=	O
mu_get_user_email	function
(	O
NULL	O
)	O
;	O
mu_address_create	function
(	O
&	O
local_mailbox	pointer
,	O
p	pointer
)	O
;	O
}	O
return	O
local_mailbox	pointer
;	O
}	O
char	O
const	O
*	O
mh_get_my_user_name	function
(	O
void	O
)	O
{	O
mu_address_t	pointer
addr	pointer
=	O
mh_local_mailbox	function
(	O
)	O
;	O
char	O
const	O
*	O
s	pointer
;	O
MU_ASSERT	O
(	O
mu_address_sget_local_part	function
(	O
addr	pointer
,	O
1	int
,	O
&	O
s	pointer
)	O
)	O
;	O
return	O
s	pointer
;	O
}	O
char	O
const	O
*	O
mh_get_my_real_name	function
(	O
void	O
)	O
{	O
mu_address_t	pointer
addr	pointer
=	O
mh_local_mailbox	function
(	O
)	O
;	O
char	O
const	O
*	O
s	pointer
;	O
if	O
(	O
mu_address_sget_personal	function
(	O
addr	pointer
,	O
1	int
,	O
&	O
s	pointer
)	O
)	O
return	O
NULL	O
;	O
return	O
s	pointer
;	O
}	O
char	O
const	O
*	O
mh_my_email	function
(	O
void	O
)	O
{	O
mu_address_t	pointer
addr	pointer
=	O
mh_local_mailbox	function
(	O
)	O
;	O
char	O
const	O
*	O
s	pointer
;	O
MU_ASSERT	O
(	O
mu_address_sget_printable	function
(	O
addr	pointer
,	O
&	O
s	pointer
)	O
)	O
;	O
return	O
s	pointer
;	O
}	O
char	O
const	O
*	O
mh_my_host	function
(	O
void	O
)	O
{	O
mu_address_t	pointer
addr	pointer
=	O
mh_local_mailbox	function
(	O
)	O
;	O
char	O
const	O
*	O
s	pointer
;	O
MU_ASSERT	O
(	O
mu_address_sget_domain	function
(	O
addr	pointer
,	O
1	int
,	O
&	O
s	pointer
)	O
)	O
;	O
return	O
s	pointer
;	O
}	O
enum	O
part_match_mode	enum
{	O
part_match_local	int
,	O
part_match_domain	int
}	O
;	O
enum	O
part_match_result	enum
{	O
part_match_false	int
,	O
part_match_true	int
,	O
part_match_abort	int
}	O
;	O
static	O
int	O
match_char_class	function
(	O
char	O
const	O
*	O
*	O
pexpr	pointer
,	O
char	O
c	char
,	O
int	O
icase	int
)	O
;	O
static	O
enum	O
part_match_result	enum
part_match	function
(	O
char	O
const	O
*	O
expr	pointer
,	O
char	O
const	O
*	O
name	pointer
,	O
enum	O
part_match_mode	enum
mode	int
)	O
{	O
int	O
c	char
;	O
while	O
(	O
*	O
expr	pointer
)	O
{	O
if	O
(	O
*	O
name	pointer
==	O
0	int
&&	O
*	O
expr	pointer
!=	O
'*'	O
)	O
return	O
part_match_abort	int
;	O
switch	O
(	O
*	O
expr	pointer
)	O
{	O
case	O
'*'	O
:	O
while	O
(	O
*	O
++	O
expr	pointer
==	O
'*'	O
)	O
;	O
if	O
(	O
*	O
expr	pointer
==	O
0	int
)	O
return	O
part_match_true	int
;	O
while	O
(	O
*	O
name	pointer
)	O
{	O
int	O
res	pointer
=	O
part_match	function
(	O
expr	pointer
,	O
name	pointer
++	O
,	O
mode	int
)	O
;	O
if	O
(	O
res	pointer
!=	O
part_match_false	int
)	O
return	O
res	pointer
;	O
}	O
return	O
part_match_abort	int
;	O
case	O
'?'	O
:	O
expr	pointer
++	O
;	O
if	O
(	O
*	O
name	pointer
==	O
0	int
)	O
return	O
part_match_false	int
;	O
name	pointer
++	O
;	O
break	O
;	O
case	O
'['	O
:	O
if	O
(	O
!	O
match_char_class	function
(	O
&	O
expr	pointer
,	O
*	O
name	pointer
,	O
mode	int
==	O
part_match_domain	int
)	O
)	O
return	O
part_match_false	int
;	O
name	pointer
++	O
;	O
break	O
;	O
case	O
'\\'	O
:	O
if	O
(	O
expr	pointer
[	O
1	int
]	O
)	O
{	O
c	char
=	O
*	O
++	O
expr	pointer
;	O
expr	pointer
++	O
;	O
if	O
(	O
*	O
name	pointer
!=	O
mu_wordsplit_c_unquote_char	function
(	O
c	char
)	O
)	O
return	O
part_match_false	int
;	O
name	pointer
++	O
;	O
break	O
;	O
}	O
default	O
:	O
if	O
(	O
mode	int
==	O
part_match_local	int
)	O
{	O
if	O
(	O
*	O
expr	pointer
!=	O
*	O
name	pointer
)	O
return	O
part_match_false	int
;	O
if	O
(	O
'@'	O
==	O
*	O
name	pointer
)	O
mode	int
=	O
part_match_domain	int
;	O
}	O
else	O
{	O
if	O
(	O
mu_tolower	O
(	O
*	O
expr	pointer
)	O
!=	O
mu_tolower	O
(	O
*	O
name	pointer
)	O
)	O
return	O
part_match_false	int
;	O
}	O
expr	pointer
++	O
;	O
name	pointer
++	O
;	O
}	O
}	O
if	O
(	O
*	O
name	pointer
==	O
0	int
)	O
return	O
part_match_true	int
;	O
if	O
(	O
mode	int
==	O
part_match_local	int
&&	O
*	O
name	pointer
==	O
'@'	O
)	O
return	O
part_match_true	int
;	O
return	O
part_match_false	int
;	O
}	O
static	O
int	O
match_char_class	function
(	O
char	O
const	O
*	O
*	O
pexpr	pointer
,	O
char	O
c	char
,	O
int	O
icase	int
)	O
{	O
int	O
res	pointer
;	O
int	O
rc	int
;	O
char	O
const	O
*	O
expr	pointer
=	O
*	O
pexpr	pointer
;	O
if	O
(	O
icase	int
)	O
c	char
=	O
mu_toupper	O
(	O
c	char
)	O
;	O
expr	pointer
++	O
;	O
if	O
(	O
*	O
expr	pointer
==	O
'^'	O
)	O
{	O
res	pointer
=	O
0	int
;	O
expr	pointer
++	O
;	O
}	O
else	O
res	pointer
=	O
1	int
;	O
if	O
(	O
*	O
expr	pointer
==	O
'-'	O
||	O
*	O
expr	pointer
==	O
']'	O
)	O
rc	int
=	O
c	char
==	O
*	O
expr	pointer
++	O
;	O
else	O
rc	int
=	O
!	O
res	pointer
;	O
for	O
(	O
;	O
*	O
expr	pointer
&&	O
*	O
expr	pointer
!=	O
']'	O
;	O
expr	pointer
++	O
)	O
{	O
if	O
(	O
rc	int
==	O
res	pointer
)	O
{	O
if	O
(	O
*	O
expr	pointer
==	O
'\\'	O
&&	O
expr	pointer
[	O
1	int
]	O
==	O
']'	O
)	O
expr	pointer
++	O
;	O
}	O
else	O
if	O
(	O
expr	pointer
[	O
1	int
]	O
==	O
'-'	O
)	O
{	O
if	O
(	O
*	O
expr	pointer
==	O
'\\'	O
)	O
rc	int
=	O
*	O
++	O
expr	pointer
==	O
c	char
;	O
else	O
{	O
if	O
(	O
icase	int
)	O
rc	int
=	O
mu_toupper	O
(	O
*	O
expr	pointer
)	O
<=	O
c	char
&&	O
c	char
<=	O
mu_toupper	O
(	O
expr	pointer
[	O
2	int
]	O
)	O
;	O
else	O
rc	int
=	O
*	O
expr	pointer
<=	O
c	char
&&	O
c	char
<=	O
expr	pointer
[	O
2	int
]	O
;	O
expr	pointer
+=	O
2	int
;	O
}	O
}	O
else	O
if	O
(	O
*	O
expr	pointer
==	O
'\\'	O
&&	O
expr	pointer
[	O
1	int
]	O
==	O
']'	O
)	O
rc	int
=	O
*	O
++	O
expr	pointer
==	O
c	char
;	O
else	O
if	O
(	O
icase	int
)	O
rc	int
=	O
mu_toupper	O
(	O
*	O
expr	pointer
)	O
==	O
c	char
;	O
else	O
rc	int
=	O
*	O
expr	pointer
==	O
c	char
;	O
}	O
*	O
pexpr	pointer
=	O
*	O
expr	pointer
?	O
expr	pointer
+	O
1	int
:	O
expr	pointer
;	O
return	O
rc	int
==	O
res	pointer
;	O
}	O
static	O
int	O
email_match	function
(	O
char	O
const	O
*	O
pattern	pointer
,	O
char	O
const	O
*	O
name	pointer
)	O
{	O
return	O
part_match	function
(	O
pattern	pointer
,	O
name	pointer
,	O
part_match_local	int
)	O
==	O
part_match_true	int
;	O
}	O
int	O
mh_is_my_name	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
static	O
mu_address_t	pointer
addr	pointer
;	O
mu_address_t	pointer
p	pointer
;	O
if	O
(	O
!	O
addr	pointer
)	O
{	O
const	O
char	O
*	O
nlist	pointer
;	O
int	O
rc	int
;	O
rc	int
=	O
mu_address_create	function
(	O
&	O
addr	pointer
,	O
mh_my_email	function
(	O
)	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_address_create"	pointer
,	O
mh_my_email	function
(	O
)	O
,	O
rc	int
)	O
;	O
return	O
0	int
;	O
}	O
nlist	pointer
=	O
mh_global_profile_get	O
(	O
"Alternate-Mailboxes"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
nlist	pointer
)	O
{	O
mu_address_t	pointer
tmp	pointer
;	O
struct	O
mu_address	struct
hint	pointer
;	O
hint	pointer
.	O
domain	pointer
=	O
NULL	O
;	O
rc	int
=	O
mu_address_create_hint	function
(	O
&	O
tmp	pointer
,	O
nlist	pointer
,	O
&	O
hint	pointer
,	O
MU_ADDR_HINT_DOMAIN	int
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
rc	int
=	O
mu_address_union	function
(	O
&	O
addr	pointer
,	O
tmp	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_address_union"	pointer
,	O
NULL	O
,	O
rc	int
)	O
;	O
mu_address_destroy	function
(	O
&	O
tmp	pointer
)	O
;	O
}	O
else	O
{	O
mu_error	function
(	O
_	O
(	O
"bad Alternate-Mailboxes: %s; please fix"	pointer
)	O
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
}	O
}	O
}	O
for	O
(	O
p	pointer
=	O
addr	pointer
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
email_match	function
(	O
p	pointer
->	O
email	pointer
,	O
name	pointer
)	O
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
make_dir_hier	function
(	O
const	O
char	O
*	O
p	pointer
,	O
mode_t	int
perm	int
)	O
{	O
int	O
rc	int
=	O
0	int
;	O
char	O
*	O
dir	pointer
=	O
mu_strdup	function
(	O
p	pointer
)	O
;	O
char	O
*	O
q	pointer
=	O
dir	pointer
;	O
while	O
(	O
!	O
rc	int
&&	O
(	O
q	pointer
=	O
strchr	function
(	O
q	pointer
+	O
1	int
,	O
'/'	O
)	O
)	O
)	O
{	O
*	O
q	pointer
=	O
0	int
;	O
if	O
(	O
access	function
(	O
dir	pointer
,	O
X_OK	int
)	O
)	O
{	O
if	O
(	O
errno	O
!=	O
ENOENT	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"cannot create directory %s: error accessing name component %s: %s"	pointer
)	O
,	O
p	pointer
,	O
dir	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
rc	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
(	O
rc	int
=	O
mkdir	function
(	O
dir	pointer
,	O
perm	int
)	O
)	O
)	O
mu_error	function
(	O
_	O
(	O
"cannot create directory %s: error creating name component %s: %s"	pointer
)	O
,	O
p	pointer
,	O
dir	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
}	O
*	O
q	pointer
=	O
'/'	O
;	O
}	O
free	function
(	O
dir	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mh_makedir	function
(	O
const	O
char	O
*	O
p	pointer
)	O
{	O
int	O
rc	int
;	O
mode_t	int
save_umask	int
;	O
mode_t	int
perm	int
=	O
0711	int
;	O
const	O
char	O
*	O
pb	pointer
=	O
mh_global_profile_get	O
(	O
"Folder-Protect"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
pb	pointer
)	O
perm	int
=	O
strtoul	function
(	O
pb	pointer
,	O
NULL	O
,	O
8	int
)	O
;	O
save_umask	int
=	O
umask	function
(	O
0	int
)	O
;	O
if	O
(	O
(	O
rc	int
=	O
make_dir_hier	function
(	O
p	pointer
,	O
perm	int
)	O
)	O
==	O
0	int
)	O
{	O
rc	int
=	O
mkdir	function
(	O
p	pointer
,	O
perm	int
)	O
;	O
if	O
(	O
rc	int
)	O
mu_error	function
(	O
_	O
(	O
"cannot create directory %s: %s"	pointer
)	O
,	O
p	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
umask	function
(	O
save_umask	int
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mh_check_folder	function
(	O
const	O
char	O
*	O
pathname	pointer
,	O
int	O
confirm	int
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
struct	O
stat	pointer
st	pointer
;	O
if	O
(	O
(	O
p	pointer
=	O
strchr	function
(	O
pathname	pointer
,	O
':'	O
)	O
)	O
!=	O
NULL	O
)	O
p	pointer
++	O
;	O
else	O
p	pointer
=	O
pathname	pointer
;	O
if	O
(	O
stat	pointer
(	O
p	pointer
,	O
&	O
st	pointer
)	O
)	O
{	O
if	O
(	O
errno	O
==	O
ENOENT	int
)	O
{	O
if	O
(	O
!	O
confirm	int
||	O
mh_getyn	function
(	O
_	O
(	O
"Create folder \"%s\""	pointer
)	O
,	O
p	pointer
)	O
)	O
return	O
mh_makedir	function
(	O
p	pointer
)	O
;	O
else	O
return	O
1	int
;	O
}	O
else	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"stat"	pointer
,	O
p	pointer
,	O
errno	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
int	O
mh_interactive_mode_p	function
(	O
void	O
)	O
{	O
static	O
int	O
interactive	int
=	O
-	O
1	int
;	O
if	O
(	O
interactive	int
<	O
0	int
)	O
interactive	int
=	O
isatty	function
(	O
fileno	function
(	O
stdin	pointer
)	O
)	O
?	O
1	int
:	O
0	int
;	O
return	O
interactive	int
;	O
}	O
int	O
mh_vgetyn	function
(	O
const	O
char	O
*	O
fmt	pointer
,	O
va_list	array
ap	array
)	O
{	O
char	O
repl	array
[	O
64	int
]	O
;	O
while	O
(	O
1	int
)	O
{	O
char	O
*	O
p	pointer
;	O
int	O
len	int
,	O
rc	int
;	O
vfprintf	function
(	O
stdout	pointer
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
fprintf	function
(	O
stdout	pointer
,	O
"? "	pointer
)	O
;	O
p	pointer
=	O
fgets	function
(	O
repl	array
,	O
sizeof	O
repl	array
,	O
stdin	pointer
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
0	int
;	O
len	int
=	O
strlen	function
(	O
p	pointer
)	O
;	O
if	O
(	O
len	int
>	O
0	int
&&	O
p	pointer
[	O
len	int
-	O
1	int
]	O
==	O
'\n'	O
)	O
p	pointer
[	O
len	int
--	O
]	O
=	O
0	int
;	O
rc	int
=	O
mu_true_answer_p	function
(	O
p	pointer
)	O
;	O
if	O
(	O
rc	int
>=	O
0	int
)	O
return	O
rc	int
;	O
fprintf	function
(	O
stdout	pointer
,	O
_	O
(	O
"Please answer yes or no: "	pointer
)	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
mh_getyn	function
(	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
int	O
rc	int
;	O
if	O
(	O
!	O
mh_interactive_mode_p	function
(	O
)	O
)	O
return	O
1	int
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
rc	int
=	O
mh_vgetyn	function
(	O
fmt	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mh_getyn_interactive	function
(	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
int	O
rc	int
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
rc	int
=	O
mh_vgetyn	function
(	O
fmt	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
return	O
rc	int
;	O
}	O
mu_stream_t	pointer
mh_audit_open	function
(	O
char	O
*	O
name	pointer
,	O
mu_mailbox_t	pointer
mbox	pointer
)	O
{	O
mu_stream_t	pointer
str	pointer
;	O
char	O
date	struct
[	O
64	int
]	O
;	O
time_t	long
t	long
;	O
struct	O
tm	struct
*	O
tm	struct
;	O
mu_url_t	pointer
url	pointer
;	O
char	O
*	O
namep	pointer
;	O
int	O
rc	int
;	O
namep	pointer
=	O
mu_tilde_expansion	function
(	O
name	pointer
,	O
MU_HIERARCHY_DELIMITER	char
,	O
NULL	O
)	O
;	O
if	O
(	O
strchr	function
(	O
namep	pointer
,	O
MU_HIERARCHY_DELIMITER	char
)	O
==	O
NULL	O
)	O
{	O
char	O
*	O
p	pointer
=	O
mh_safe_make_file_name	function
(	O
mu_folder_directory	function
(	O
)	O
,	O
namep	pointer
)	O
;	O
free	function
(	O
namep	pointer
)	O
;	O
namep	pointer
=	O
p	pointer
;	O
}	O
rc	int
=	O
mu_file_stream_create	function
(	O
&	O
str	pointer
,	O
namep	pointer
,	O
MU_STREAM_CREAT	int
|	O
MU_STREAM_APPEND	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"cannot open audit file %s: %s"	pointer
)	O
,	O
namep	pointer
,	O
strerror	function
(	O
rc	int
)	O
)	O
;	O
free	function
(	O
namep	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
free	function
(	O
namep	pointer
)	O
;	O
time	struct
(	O
&	O
t	long
)	O
;	O
tm	struct
=	O
localtime	function
(	O
&	O
t	long
)	O
;	O
mu_strftime	function
(	O
date	struct
,	O
sizeof	O
date	struct
,	O
"%a, %d %b %Y %H:%M:%S %Z"	pointer
,	O
tm	struct
)	O
;	O
mu_mailbox_get_url	function
(	O
mbox	pointer
,	O
&	O
url	pointer
)	O
;	O
mu_stream_printf	function
(	O
str	pointer
,	O
"<<%s>> %s %s\n"	pointer
,	O
mu_program_name	pointer
,	O
date	struct
,	O
mu_url_to_string	function
(	O
url	pointer
)	O
)	O
;	O
return	O
str	pointer
;	O
}	O
void	O
mh_audit_close	function
(	O
mu_stream_t	pointer
str	pointer
)	O
{	O
mu_stream_close	function
(	O
str	pointer
)	O
;	O
}	O
int	O
mh_message_number	function
(	O
mu_message_t	pointer
msg	pointer
,	O
size_t	long
*	O
pnum	pointer
)	O
{	O
return	O
mu_message_get_uid	function
(	O
msg	pointer
,	O
pnum	pointer
)	O
;	O
}	O
mu_mailbox_t	pointer
mh_open_folder	function
(	O
const	O
char	O
*	O
folder	pointer
,	O
int	O
flags	int
)	O
{	O
mu_mailbox_t	pointer
mbox	pointer
=	O
NULL	O
;	O
char	O
*	O
name	pointer
;	O
name	pointer
=	O
mh_expand_name	function
(	O
NULL	O
,	O
folder	pointer
,	O
NAME_FOLDER	int
)	O
;	O
if	O
(	O
(	O
flags	int
&	O
MU_STREAM_CREAT	int
)	O
&&	O
mh_check_folder	function
(	O
name	pointer
,	O
1	int
)	O
)	O
exit	function
(	O
0	int
)	O
;	O
if	O
(	O
mu_mailbox_create_default	function
(	O
&	O
mbox	pointer
,	O
name	pointer
)	O
)	O
{	O
mu_error	function
(	O
_	O
(	O
"cannot create mailbox %s: %s"	pointer
)	O
,	O
name	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
mu_mailbox_open	function
(	O
mbox	pointer
,	O
flags	int
)	O
)	O
{	O
mu_error	function
(	O
_	O
(	O
"cannot open mailbox %s: %s"	pointer
)	O
,	O
name	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
free	function
(	O
name	pointer
)	O
;	O
return	O
mbox	pointer
;	O
}	O
char	O
*	O
mh_get_dir	function
(	O
void	O
)	O
{	O
const	O
char	O
*	O
mhdir	pointer
=	O
mh_global_profile_get	O
(	O
"Path"	pointer
,	O
"Mail"	pointer
)	O
;	O
char	O
*	O
mhcopy	pointer
;	O
if	O
(	O
mhdir	pointer
[	O
0	int
]	O
!=	O
'/'	O
)	O
{	O
char	O
*	O
p	pointer
=	O
mu_get_homedir	function
(	O
)	O
;	O
mhcopy	pointer
=	O
mh_safe_make_file_name	function
(	O
p	pointer
,	O
mhdir	pointer
)	O
;	O
free	function
(	O
p	pointer
)	O
;	O
}	O
else	O
mhcopy	pointer
=	O
strdup	function
(	O
mhdir	pointer
)	O
;	O
if	O
(	O
!	O
mhcopy	pointer
)	O
{	O
mu_error	function
(	O
_	O
(	O
"not enough memory"	pointer
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
return	O
mhcopy	pointer
;	O
}	O
char	O
*	O
mh_expand_name	function
(	O
const	O
char	O
*	O
base	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
int	O
what	int
)	O
{	O
char	O
*	O
p	pointer
=	O
NULL	O
;	O
char	O
*	O
namep	pointer
=	O
NULL	O
;	O
namep	pointer
=	O
mu_tilde_expansion	function
(	O
name	pointer
,	O
MU_HIERARCHY_DELIMITER	char
,	O
NULL	O
)	O
;	O
if	O
(	O
namep	pointer
[	O
0	int
]	O
==	O
'+'	O
)	O
memmove	function
(	O
namep	pointer
,	O
namep	pointer
+	O
1	int
,	O
strlen	function
(	O
namep	pointer
)	O
)	O
;	O
else	O
if	O
(	O
strncmp	function
(	O
namep	pointer
,	O
"../"	pointer
,	O
3	int
)	O
==	O
0	int
||	O
strncmp	function
(	O
namep	pointer
,	O
"./"	pointer
,	O
2	int
)	O
==	O
0	int
)	O
{	O
char	O
*	O
cwd	short
=	O
mu_getcwd	function
(	O
)	O
;	O
char	O
*	O
tmp	pointer
=	O
mh_safe_make_file_name	function
(	O
cwd	short
,	O
namep	pointer
)	O
;	O
free	function
(	O
cwd	short
)	O
;	O
if	O
(	O
what	int
==	O
NAME_FILE	int
)	O
return	O
tmp	pointer
;	O
free	function
(	O
namep	pointer
)	O
;	O
namep	pointer
=	O
tmp	pointer
;	O
}	O
if	O
(	O
what	int
==	O
NAME_FOLDER	int
)	O
{	O
if	O
(	O
memcmp	function
(	O
namep	pointer
,	O
"mh:/"	pointer
,	O
4	int
)	O
==	O
0	int
)	O
return	O
namep	pointer
;	O
else	O
if	O
(	O
namep	pointer
[	O
0	int
]	O
==	O
'/'	O
)	O
mu_asprintf	function
(	O
&	O
p	pointer
,	O
"mh:%s"	pointer
,	O
namep	pointer
)	O
;	O
else	O
mu_asprintf	function
(	O
&	O
p	pointer
,	O
"mh:%s/%s"	pointer
,	O
base	pointer
?	O
base	pointer
:	O
mu_folder_directory	function
(	O
)	O
,	O
namep	pointer
)	O
;	O
}	O
else	O
if	O
(	O
namep	pointer
[	O
0	int
]	O
!=	O
'/'	O
)	O
{	O
if	O
(	O
what	int
==	O
NAME_FILE	int
)	O
{	O
char	O
*	O
cwd	short
=	O
mu_getcwd	function
(	O
)	O
;	O
p	pointer
=	O
mh_safe_make_file_name	function
(	O
cwd	short
,	O
namep	pointer
)	O
;	O
free	function
(	O
cwd	short
)	O
;	O
}	O
else	O
p	pointer
=	O
mh_safe_make_file_name	function
(	O
base	pointer
?	O
base	pointer
:	O
mu_folder_directory	function
(	O
)	O
,	O
namep	pointer
)	O
;	O
}	O
else	O
return	O
namep	pointer
;	O
free	function
(	O
namep	pointer
)	O
;	O
return	O
p	pointer
;	O
}	O
int	O
mh_find_file	function
(	O
const	O
char	O
*	O
name	pointer
,	O
char	O
*	O
*	O
resolved_name	pointer
)	O
{	O
char	O
*	O
s	pointer
;	O
int	O
rc	int
;	O
if	O
(	O
name	pointer
[	O
0	int
]	O
==	O
'/'	O
||	O
(	O
name	pointer
[	O
0	int
]	O
==	O
'.'	O
&&	O
name	pointer
[	O
1	int
]	O
==	O
'/'	O
)	O
||	O
(	O
name	pointer
[	O
0	int
]	O
==	O
'.'	O
&&	O
name	pointer
[	O
1	int
]	O
==	O
'.'	O
&&	O
name	pointer
[	O
2	int
]	O
==	O
'/'	O
)	O
)	O
{	O
*	O
resolved_name	pointer
=	O
mu_strdup	function
(	O
name	pointer
)	O
;	O
if	O
(	O
access	function
(	O
name	pointer
,	O
R_OK	int
)	O
==	O
0	int
)	O
return	O
0	int
;	O
return	O
errno	O
;	O
}	O
if	O
(	O
name	pointer
[	O
0	int
]	O
==	O
'~'	O
)	O
{	O
s	pointer
=	O
mu_tilde_expansion	function
(	O
name	pointer
,	O
MU_HIERARCHY_DELIMITER	char
,	O
NULL	O
)	O
;	O
*	O
resolved_name	pointer
=	O
s	pointer
;	O
if	O
(	O
access	function
(	O
s	pointer
,	O
R_OK	int
)	O
==	O
0	int
)	O
return	O
0	int
;	O
return	O
errno	O
;	O
}	O
s	pointer
=	O
mh_expand_name	function
(	O
NULL	O
,	O
name	pointer
,	O
NAME_ANY	int
)	O
;	O
if	O
(	O
access	function
(	O
s	pointer
,	O
R_OK	int
)	O
==	O
0	int
)	O
{	O
*	O
resolved_name	pointer
=	O
s	pointer
;	O
return	O
0	int
;	O
}	O
if	O
(	O
errno	O
!=	O
ENOENT	int
)	O
mu_diag_output	function
(	O
MU_DIAG_WARNING	O
,	O
_	O
(	O
"cannot access %s: %s"	pointer
)	O
,	O
s	pointer
,	O
mu_strerror	function
(	O
errno	O
)	O
)	O
;	O
free	function
(	O
s	pointer
)	O
;	O
s	pointer
=	O
mh_expand_name	function
(	O
mh_global_profile_get	O
(	O
"mhetcdir"	pointer
,	O
MHLIBDIR	O
)	O
,	O
name	pointer
,	O
NAME_ANY	int
)	O
;	O
if	O
(	O
access	function
(	O
s	pointer
,	O
R_OK	int
)	O
==	O
0	int
)	O
{	O
*	O
resolved_name	pointer
=	O
s	pointer
;	O
return	O
0	int
;	O
}	O
if	O
(	O
errno	O
!=	O
ENOENT	int
)	O
mu_diag_output	function
(	O
MU_DIAG_WARNING	O
,	O
_	O
(	O
"cannot access %s: %s"	pointer
)	O
,	O
s	pointer
,	O
mu_strerror	function
(	O
errno	O
)	O
)	O
;	O
free	function
(	O
s	pointer
)	O
;	O
*	O
resolved_name	pointer
=	O
mu_strdup	function
(	O
name	pointer
)	O
;	O
if	O
(	O
access	function
(	O
name	pointer
,	O
R_OK	int
)	O
==	O
0	int
)	O
return	O
0	int
;	O
rc	int
=	O
errno	O
;	O
if	O
(	O
rc	int
!=	O
ENOENT	int
)	O
mu_diag_output	function
(	O
MU_DIAG_WARNING	O
,	O
_	O
(	O
"cannot access %s: %s"	pointer
)	O
,	O
s	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mh_spawnp	function
(	O
const	O
char	O
*	O
prog	pointer
,	O
const	O
char	O
*	O
file	pointer
)	O
{	O
struct	O
mu_wordsplit	struct
ws	pointer
;	O
size_t	long
i	long
;	O
int	O
rc	int
,	O
status	int
;	O
char	O
*	O
*	O
xargv	pointer
;	O
ws	pointer
.	O
ws_comment	pointer
=	O
"#"	pointer
;	O
if	O
(	O
mu_wordsplit	struct
(	O
prog	pointer
,	O
&	O
ws	pointer
,	O
MU_WRDSF_DEFFLAGS	O
|	O
MU_WRDSF_COMMENT	O
)	O
)	O
{	O
mu_error	function
(	O
_	O
(	O
"cannot split line `%s': %s"	pointer
)	O
,	O
prog	pointer
,	O
mu_wordsplit_strerror	function
(	O
&	O
ws	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
xargv	pointer
=	O
calloc	function
(	O
ws	pointer
.	O
ws_wordc	long
+	O
2	int
,	O
sizeof	O
(	O
*	O
xargv	pointer
)	O
)	O
;	O
if	O
(	O
!	O
xargv	pointer
)	O
{	O
mh_err_memory	function
(	O
0	int
)	O
;	O
mu_wordsplit_free	function
(	O
&	O
ws	pointer
)	O
;	O
return	O
1	int
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
ws	pointer
.	O
ws_wordc	long
;	O
i	long
++	O
)	O
xargv	pointer
[	O
i	long
]	O
=	O
ws	pointer
.	O
ws_wordv	pointer
[	O
i	long
]	O
;	O
xargv	pointer
[	O
i	long
++	O
]	O
=	O
(	O
char	O
*	O
)	O
file	pointer
;	O
xargv	pointer
[	O
i	long
++	O
]	O
=	O
NULL	O
;	O
rc	int
=	O
mu_spawnvp	function
(	O
xargv	pointer
[	O
0	int
]	O
,	O
xargv	pointer
,	O
&	O
status	int
)	O
;	O
free	function
(	O
xargv	pointer
)	O
;	O
mu_wordsplit_free	function
(	O
&	O
ws	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mh_file_copy	function
(	O
const	O
char	O
*	O
from	pointer
,	O
const	O
char	O
*	O
to	pointer
)	O
{	O
mu_stream_t	pointer
in	pointer
,	O
out	pointer
,	O
flt	pointer
;	O
int	O
rc	int
;	O
if	O
(	O
(	O
rc	int
=	O
mu_file_stream_create	function
(	O
&	O
in	pointer
,	O
from	pointer
,	O
MU_STREAM_READ	int
)	O
)	O
)	O
{	O
mu_error	function
(	O
_	O
(	O
"cannot open input file `%s': %s"	pointer
)	O
,	O
from	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
(	O
rc	int
=	O
mu_file_stream_create	function
(	O
&	O
out	pointer
,	O
to	pointer
,	O
MU_STREAM_RDWR	O
|	O
MU_STREAM_CREAT	int
)	O
)	O
)	O
{	O
mu_error	function
(	O
_	O
(	O
"cannot open output file `%s': %s"	pointer
)	O
,	O
to	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
mu_stream_destroy	function
(	O
&	O
in	pointer
)	O
;	O
return	O
1	int
;	O
}	O
rc	int
=	O
mu_filter_create	function
(	O
&	O
flt	pointer
,	O
in	pointer
,	O
"INLINE-COMMENT"	pointer
,	O
MU_FILTER_DECODE	int
,	O
MU_STREAM_READ	int
)	O
;	O
mu_stream_unref	function
(	O
in	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"cannot open filter stream: %s"	pointer
)	O
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
mu_stream_destroy	function
(	O
&	O
out	pointer
)	O
;	O
return	O
1	int
;	O
}	O
rc	int
=	O
mu_stream_copy	function
(	O
out	pointer
,	O
flt	pointer
,	O
0	int
,	O
NULL	O
)	O
;	O
mu_stream_destroy	function
(	O
&	O
flt	pointer
)	O
;	O
mu_stream_destroy	function
(	O
&	O
out	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
mu_error	function
(	O
_	O
(	O
"error copying file `%s' to `%s': %s"	pointer
)	O
,	O
from	pointer
,	O
to	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
mu_message_t	pointer
_file_to_message	function
(	O
const	O
char	O
*	O
file_name	pointer
)	O
{	O
struct	O
stat	pointer
st	pointer
;	O
int	O
rc	int
;	O
mu_stream_t	pointer
instream	pointer
;	O
if	O
(	O
stat	pointer
(	O
file_name	pointer
,	O
&	O
st	pointer
)	O
<	O
0	int
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"stat"	pointer
,	O
file_name	pointer
,	O
errno	O
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
(	O
rc	int
=	O
mu_file_stream_create	function
(	O
&	O
instream	pointer
,	O
file_name	pointer
,	O
MU_STREAM_READ	int
)	O
)	O
)	O
{	O
mu_error	function
(	O
_	O
(	O
"cannot create input stream (file %s): %s"	pointer
)	O
,	O
file_name	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
mh_stream_to_message	function
(	O
instream	pointer
)	O
;	O
}	O
mu_message_t	pointer
mh_file_to_message	function
(	O
const	O
char	O
*	O
folder	pointer
,	O
const	O
char	O
*	O
file_name	pointer
)	O
{	O
mu_message_t	pointer
msg	pointer
;	O
char	O
*	O
tmp_name	pointer
=	O
NULL	O
;	O
if	O
(	O
folder	pointer
)	O
{	O
tmp_name	pointer
=	O
mh_expand_name	function
(	O
folder	pointer
,	O
file_name	pointer
,	O
NAME_ANY	int
)	O
;	O
msg	pointer
=	O
_file_to_message	function
(	O
tmp_name	pointer
)	O
;	O
free	function
(	O
tmp_name	pointer
)	O
;	O
}	O
else	O
msg	pointer
=	O
_file_to_message	function
(	O
file_name	pointer
)	O
;	O
return	O
msg	pointer
;	O
}	O
void	O
mh_install_help	function
(	O
char	O
*	O
mhdir	pointer
)	O
{	O
static	O
char	O
*	O
text	pointer
=	O
N_	O
(	O
"Prior to using MH, it is necessary to have a file in your login\n"	pointer
"directory (%s) named .mh_profile which contains information\n"	pointer
"to direct certain MH operations.  The only item which is required\n"	pointer
"is the path to use for all MH folder operations.  The suggested MH\n"	pointer
"path for you is %s...\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
text	pointer
)	O
,	O
mu_get_homedir	function
(	O
)	O
,	O
mhdir	pointer
)	O
;	O
}	O
void	O
mh_real_install	function
(	O
char	O
*	O
name	pointer
,	O
int	O
automode	int
)	O
{	O
char	O
*	O
home	pointer
=	O
mu_get_homedir	function
(	O
)	O
;	O
char	O
*	O
mhdir	pointer
;	O
char	O
*	O
ctx	pointer
;	O
int	O
rc	int
;	O
mu_stream_t	pointer
profile	pointer
;	O
mhdir	pointer
=	O
mh_safe_make_file_name	function
(	O
home	pointer
,	O
"Mail"	pointer
)	O
;	O
if	O
(	O
!	O
automode	int
)	O
{	O
if	O
(	O
mh_getyn_interactive	function
(	O
_	O
(	O
"Do you need help"	pointer
)	O
)	O
)	O
mh_install_help	function
(	O
mhdir	pointer
)	O
;	O
if	O
(	O
!	O
mh_getyn_interactive	function
(	O
_	O
(	O
"Do you want the standard MH path \"%s\""	pointer
)	O
,	O
mhdir	pointer
)	O
)	O
{	O
int	O
local	int
;	O
char	O
*	O
p	pointer
,	O
*	O
buf	pointer
=	O
NULL	O
;	O
size_t	long
size	long
=	O
0	int
;	O
local	int
=	O
mh_getyn_interactive	function
(	O
_	O
(	O
"Do you want a path below your login directory"	pointer
)	O
)	O
;	O
if	O
(	O
local	int
)	O
mu_printf	function
(	O
_	O
(	O
"What is the path? "	pointer
)	O
)	O
;	O
else	O
mu_printf	function
(	O
_	O
(	O
"What is the full path? "	pointer
)	O
)	O
;	O
mu_stream_flush	function
(	O
mu_strin	pointer
)	O
;	O
if	O
(	O
mu_stream_getline	function
(	O
mu_strin	pointer
,	O
&	O
buf	pointer
,	O
&	O
size	long
,	O
NULL	O
)	O
)	O
exit	function
(	O
1	int
)	O
;	O
p	pointer
=	O
mu_str_stripws	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
p	pointer
>	O
buf	pointer
)	O
memmove	function
(	O
buf	pointer
,	O
p	pointer
,	O
strlen	function
(	O
p	pointer
)	O
+	O
1	int
)	O
;	O
free	function
(	O
mhdir	pointer
)	O
;	O
if	O
(	O
local	int
)	O
{	O
mhdir	pointer
=	O
mh_safe_make_file_name	function
(	O
home	pointer
,	O
p	pointer
)	O
;	O
free	function
(	O
p	pointer
)	O
;	O
}	O
else	O
mhdir	pointer
=	O
p	pointer
;	O
}	O
}	O
if	O
(	O
mh_check_folder	function
(	O
mhdir	pointer
,	O
!	O
automode	int
)	O
)	O
exit	function
(	O
1	int
)	O
;	O
rc	int
=	O
mu_file_stream_create	function
(	O
&	O
profile	pointer
,	O
name	pointer
,	O
MU_STREAM_WRITE	int
|	O
MU_STREAM_CREAT	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"cannot open file %s: %s"	pointer
)	O
,	O
name	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
mu_stream_printf	function
(	O
profile	pointer
,	O
"Path: %s\n"	pointer
,	O
mhdir	pointer
)	O
;	O
mu_stream_destroy	function
(	O
&	O
profile	pointer
)	O
;	O
ctx	pointer
=	O
mh_safe_make_file_name	function
(	O
mhdir	pointer
,	O
MH_CONTEXT_FILE	pointer
)	O
;	O
rc	int
=	O
mu_file_stream_create	function
(	O
&	O
profile	pointer
,	O
ctx	pointer
,	O
MU_STREAM_WRITE	int
|	O
MU_STREAM_CREAT	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_stream_printf	function
(	O
profile	pointer
,	O
"Current-Folder: inbox\n"	pointer
)	O
;	O
mu_stream_destroy	function
(	O
&	O
profile	pointer
)	O
;	O
}	O
free	function
(	O
ctx	pointer
)	O
;	O
ctx	pointer
=	O
mh_safe_make_file_name	function
(	O
mhdir	pointer
,	O
"inbox"	pointer
)	O
;	O
if	O
(	O
mh_check_folder	function
(	O
ctx	pointer
,	O
!	O
automode	int
)	O
)	O
exit	function
(	O
1	int
)	O
;	O
free	function
(	O
ctx	pointer
)	O
;	O
free	function
(	O
mhdir	pointer
)	O
;	O
}	O
void	O
mh_install	function
(	O
char	O
*	O
name	pointer
,	O
int	O
automode	int
)	O
{	O
struct	O
stat	pointer
st	pointer
;	O
if	O
(	O
stat	pointer
(	O
name	pointer
,	O
&	O
st	pointer
)	O
)	O
{	O
if	O
(	O
errno	O
==	O
ENOENT	int
)	O
{	O
if	O
(	O
automode	int
)	O
printf	function
(	O
_	O
(	O
"I'm going to create the standard MH path for you.\n"	pointer
)	O
)	O
;	O
mh_real_install	function
(	O
name	pointer
,	O
automode	int
)	O
;	O
}	O
else	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"stat"	pointer
,	O
name	pointer
,	O
errno	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
(	O
st	pointer
.	O
st_mode	int
&	O
S_IFREG	O
)	O
||	O
(	O
st	pointer
.	O
st_mode	int
&	O
S_IFLNK	O
)	O
)	O
{	O
mu_error	function
(	O
_	O
(	O
"You already have an MH profile, use an editor to modify it"	pointer
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
else	O
{	O
mu_error	function
(	O
_	O
(	O
"You already have file %s which is not a regular file or a symbolic link."	pointer
)	O
,	O
name	pointer
)	O
;	O
mu_error	function
(	O
_	O
(	O
"Please remove it and try again"	pointer
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
void	O
mh_annotate	function
(	O
mu_message_t	pointer
msg	pointer
,	O
const	O
char	O
*	O
field	pointer
,	O
const	O
char	O
*	O
text	pointer
,	O
int	O
date	struct
)	O
{	O
mu_header_t	pointer
hdr	pointer
;	O
mu_attribute_t	pointer
attr	pointer
;	O
if	O
(	O
mu_message_get_header	function
(	O
msg	pointer
,	O
&	O
hdr	pointer
)	O
)	O
return	O
;	O
if	O
(	O
date	struct
)	O
{	O
time_t	long
t	long
;	O
struct	O
tm	struct
*	O
tm	struct
;	O
char	O
datebuf	array
[	O
80	int
]	O
;	O
t	long
=	O
time	struct
(	O
NULL	O
)	O
;	O
tm	struct
=	O
localtime	function
(	O
&	O
t	long
)	O
;	O
mu_strftime	function
(	O
datebuf	array
,	O
sizeof	O
datebuf	array
,	O
"%a, %d %b %Y %H:%M:%S %Z"	pointer
,	O
tm	struct
)	O
;	O
mu_header_prepend	function
(	O
hdr	pointer
,	O
field	pointer
,	O
datebuf	array
)	O
;	O
}	O
if	O
(	O
text	pointer
)	O
mu_header_prepend	function
(	O
hdr	pointer
,	O
field	pointer
,	O
text	pointer
)	O
;	O
mu_message_get_attribute	function
(	O
msg	pointer
,	O
&	O
attr	pointer
)	O
;	O
mu_attribute_set_modified	function
(	O
attr	pointer
)	O
;	O
}	O
char	O
*	O
mh_create_message_id	function
(	O
int	O
subpart	int
)	O
{	O
char	O
*	O
p	pointer
;	O
mu_rfc2822_msg_id	function
(	O
subpart	int
,	O
&	O
p	pointer
)	O
;	O
return	O
p	pointer
;	O
}	O
void	O
mh_set_reply_regex	function
(	O
const	O
char	O
*	O
str	pointer
)	O
{	O
char	O
*	O
err	long
;	O
int	O
rc	int
=	O
mu_unre_set_regex	function
(	O
str	pointer
,	O
0	int
,	O
&	O
err	long
)	O
;	O
if	O
(	O
rc	int
)	O
mu_error	function
(	O
"reply_regex: %s%s%s"	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
,	O
err	long
?	O
": "	pointer
:	O
""	pointer
,	O
mu_prstr	function
(	O
err	long
)	O
)	O
;	O
}	O
const	O
char	O
*	O
mh_charset	function
(	O
const	O
char	O
*	O
dfl	pointer
)	O
{	O
const	O
char	O
*	O
charset	pointer
=	O
mh_global_profile_get	O
(	O
"Charset"	pointer
,	O
dfl	pointer
)	O
;	O
if	O
(	O
!	O
charset	pointer
)	O
return	O
NULL	O
;	O
if	O
(	O
mu_c_strcasecmp	function
(	O
charset	pointer
,	O
"auto"	pointer
)	O
==	O
0	int
)	O
{	O
static	O
char	O
*	O
saved_charset	pointer
;	O
if	O
(	O
!	O
saved_charset	pointer
)	O
{	O
struct	O
mu_lc_all	struct
lc_all	struct
;	O
if	O
(	O
mu_parse_lc_all	function
(	O
getenv	function
(	O
"LC_ALL"	pointer
)	O
,	O
&	O
lc_all	struct
,	O
MU_LC_CSET	int
)	O
==	O
0	int
)	O
saved_charset	pointer
=	O
lc_all	struct
.	O
charset	pointer
;	O
}	O
charset	pointer
=	O
saved_charset	pointer
;	O
}	O
return	O
charset	pointer
;	O
}	O
int	O
mh_decode_2047	function
(	O
char	O
const	O
*	O
text	pointer
,	O
char	O
*	O
*	O
decoded_text	pointer
)	O
{	O
const	O
char	O
*	O
charset	pointer
=	O
mh_charset	function
(	O
NULL	O
)	O
;	O
if	O
(	O
!	O
charset	pointer
)	O
return	O
1	int
;	O
return	O
mu_rfc2047_decode	function
(	O
charset	pointer
,	O
text	pointer
,	O
decoded_text	pointer
)	O
;	O
}	O
void	O
mh_quote	function
(	O
const	O
char	O
*	O
in	pointer
,	O
char	O
*	O
*	O
out	pointer
)	O
{	O
size_t	long
len	int
=	O
strlen	function
(	O
in	pointer
)	O
;	O
if	O
(	O
len	int
&&	O
in	pointer
[	O
0	int
]	O
==	O
'"'	O
&&	O
in	pointer
[	O
len	int
-	O
1	int
]	O
==	O
'"'	O
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
char	O
*	O
q	pointer
;	O
for	O
(	O
p	pointer
=	O
in	pointer
+	O
1	int
;	O
p	pointer
<	O
in	pointer
+	O
len	int
-	O
1	int
;	O
p	pointer
++	O
)	O
if	O
(	O
*	O
p	pointer
==	O
'\\'	O
||	O
*	O
p	pointer
==	O
'"'	O
)	O
len	int
++	O
;	O
*	O
out	pointer
=	O
mu_alloc	function
(	O
len	int
+	O
1	int
)	O
;	O
q	pointer
=	O
*	O
out	pointer
;	O
p	pointer
=	O
in	pointer
;	O
*	O
q	pointer
++	O
=	O
*	O
p	pointer
++	O
;	O
while	O
(	O
p	pointer
[	O
1	int
]	O
)	O
{	O
if	O
(	O
*	O
p	pointer
==	O
'\\'	O
||	O
*	O
p	pointer
==	O
'"'	O
)	O
*	O
q	pointer
++	O
=	O
'\\'	O
;	O
*	O
q	pointer
++	O
=	O
*	O
p	pointer
++	O
;	O
}	O
*	O
q	pointer
++	O
=	O
*	O
p	pointer
++	O
;	O
*	O
q	pointer
=	O
0	int
;	O
}	O
else	O
*	O
out	pointer
=	O
mu_strdup	function
(	O
in	pointer
)	O
;	O
}	O
void	O
mh_expand_aliases	function
(	O
mu_message_t	pointer
msg	pointer
,	O
mu_address_t	pointer
*	O
addr_to	pointer
,	O
mu_address_t	pointer
*	O
addr_cc	pointer
,	O
mu_address_t	pointer
*	O
addr_bcc	pointer
)	O
{	O
mu_header_t	pointer
hdr	pointer
;	O
size_t	long
i	long
,	O
num	long
;	O
const	O
char	O
*	O
buf	pointer
;	O
mu_message_get_header	function
(	O
msg	pointer
,	O
&	O
hdr	pointer
)	O
;	O
mu_header_get_field_count	function
(	O
hdr	pointer
,	O
&	O
num	long
)	O
;	O
for	O
(	O
i	long
=	O
1	int
;	O
i	long
<=	O
num	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
mu_header_sget_field_name	function
(	O
hdr	pointer
,	O
i	long
,	O
&	O
buf	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
mu_c_strcasecmp	function
(	O
buf	pointer
,	O
MU_HEADER_TO	pointer
)	O
==	O
0	int
||	O
mu_c_strcasecmp	function
(	O
buf	pointer
,	O
MU_HEADER_CC	pointer
)	O
==	O
0	int
||	O
mu_c_strcasecmp	function
(	O
buf	pointer
,	O
MU_HEADER_BCC	pointer
)	O
==	O
0	int
)	O
{	O
char	O
*	O
value	pointer
;	O
mu_address_t	pointer
addr	pointer
=	O
NULL	O
;	O
int	O
incl	pointer
;	O
mu_header_aget_field_value_unfold	function
(	O
hdr	pointer
,	O
i	long
,	O
&	O
value	pointer
)	O
;	O
mh_alias_expand	function
(	O
value	pointer
,	O
&	O
addr	pointer
,	O
&	O
incl	pointer
)	O
;	O
free	function
(	O
value	pointer
)	O
;	O
if	O
(	O
mu_c_strcasecmp	function
(	O
buf	pointer
,	O
MU_HEADER_TO	pointer
)	O
==	O
0	int
)	O
mu_address_union	function
(	O
addr_to	pointer
,	O
addr	pointer
)	O
;	O
else	O
if	O
(	O
mu_c_strcasecmp	function
(	O
buf	pointer
,	O
MU_HEADER_CC	pointer
)	O
==	O
0	int
)	O
mu_address_union	function
(	O
addr_cc	pointer
?	O
addr_cc	pointer
:	O
addr_to	pointer
,	O
addr	pointer
)	O
;	O
else	O
if	O
(	O
mu_c_strcasecmp	function
(	O
buf	pointer
,	O
MU_HEADER_BCC	pointer
)	O
==	O
0	int
)	O
mu_address_union	function
(	O
addr_bcc	pointer
?	O
addr_bcc	pointer
:	O
addr_to	pointer
,	O
addr	pointer
)	O
;	O
}	O
}	O
}	O
}	O
int	O
mh_draft_message	function
(	O
const	O
char	O
*	O
name	pointer
,	O
const	O
char	O
*	O
msgspec	pointer
,	O
char	O
*	O
*	O
pname	pointer
)	O
{	O
mu_url_t	pointer
url	pointer
;	O
size_t	long
uid	int
;	O
int	O
rc	int
;	O
mu_mailbox_t	pointer
mbox	pointer
;	O
const	O
char	O
*	O
path	pointer
;	O
mbox	pointer
=	O
mh_open_folder	function
(	O
name	pointer
,	O
MU_STREAM_RDWR	O
)	O
;	O
if	O
(	O
!	O
mbox	pointer
)	O
return	O
1	int
;	O
mu_mailbox_get_url	function
(	O
mbox	pointer
,	O
&	O
url	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
msgspec	pointer
,	O
"new"	pointer
)	O
==	O
0	int
)	O
{	O
mu_property_t	pointer
prop	pointer
;	O
rc	int
=	O
mu_mailbox_uidnext	function
(	O
mbox	pointer
,	O
&	O
uid	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"cannot obtain sequence number for the new message: %s"	pointer
)	O
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
mu_mailbox_get_property	function
(	O
mbox	pointer
,	O
&	O
prop	pointer
)	O
;	O
mu_property_set_value	function
(	O
prop	pointer
,	O
"cur"	pointer
,	O
mu_umaxtostr	function
(	O
0	int
,	O
uid	int
)	O
,	O
1	int
)	O
;	O
}	O
else	O
{	O
char	O
*	O
argv	pointer
[	O
2	int
]	O
;	O
mu_msgset_t	pointer
msgset	pointer
;	O
argv	pointer
[	O
0	int
]	O
=	O
(	O
char	O
*	O
)	O
msgspec	pointer
;	O
argv	pointer
[	O
1	int
]	O
=	O
NULL	O
;	O
mh_msgset_parse	function
(	O
&	O
msgset	pointer
,	O
mbox	pointer
,	O
1	int
,	O
argv	pointer
,	O
"cur"	pointer
)	O
;	O
if	O
(	O
!	O
mh_msgset_single_message	function
(	O
msgset	pointer
)	O
)	O
mu_error	function
(	O
_	O
(	O
"only one message at a time!"	pointer
)	O
)	O
;	O
else	O
uid	int
=	O
mh_msgset_first	function
(	O
msgset	pointer
,	O
RET_UID	int
)	O
;	O
mu_msgset_free	function
(	O
msgset	pointer
)	O
;	O
}	O
mu_url_sget_path	function
(	O
url	pointer
,	O
&	O
path	pointer
)	O
;	O
rc	int
=	O
mu_asprintf	function
(	O
pname	pointer
,	O
"%s/%lu"	pointer
,	O
path	pointer
,	O
(	O
unsigned	O
long	O
)	O
uid	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_asprintf"	pointer
,	O
NULL	O
,	O
rc	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
mu_mailbox_close	function
(	O
mbox	pointer
)	O
;	O
mu_mailbox_destroy	function
(	O
&	O
mbox	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
char	O
*	O
mh_safe_make_file_name	function
(	O
const	O
char	O
*	O
dir	pointer
,	O
const	O
char	O
*	O
file	pointer
)	O
{	O
char	O
*	O
name	pointer
=	O
mu_make_file_name	O
(	O
dir	pointer
,	O
file	pointer
)	O
;	O
if	O
(	O
!	O
name	pointer
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_make_file_name"	pointer
,	O
NULL	O
,	O
ENOMEM	int
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
return	O
name	pointer
;	O
}	O
int	O
mh_width	function
(	O
void	O
)	O
{	O
struct	O
winsize	struct
ws	pointer
;	O
ws	pointer
.	O
ws_col	short
=	O
ws	pointer
.	O
ws_row	short
=	O
0	int
;	O
if	O
(	O
(	O
ioctl	function
(	O
1	int
,	O
TIOCGWINSZ	int
,	O
(	O
char	O
*	O
)	O
&	O
ws	pointer
)	O
<	O
0	int
)	O
||	O
ws	pointer
.	O
ws_col	short
==	O
0	int
)	O
return	O
80	int
;	O
return	O
ws	pointer
.	O
ws_col	short
;	O
}	O
