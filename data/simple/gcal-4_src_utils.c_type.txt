__BEGIN_DECLARATIONS	O
static	O
void	O
gregorian2julian	function
__P_	O
(	O
(	O
int	O
*	O
day	int
,	O
int	O
*	O
month	int
,	O
int	O
*	O
year	int
)	O
)	O
;	O
static	O
int	O
raw_week_number	function
__P_	O
(	O
(	O
const	O
int	O
day	int
,	O
const	O
int	O
month	int
,	O
const	O
int	O
year	int
,	O
const	O
Bool	int
is_iso_week	int
,	O
const	O
int	O
start_day_of_week	int
)	O
)	O
;	O
static	O
const	O
char	O
*	O
dflt_day_name	function
__P_	O
(	O
(	O
const	O
int	O
day	int
)	O
)	O
;	O
static	O
const	O
char	O
*	O
dflt_month_name	function
__P_	O
(	O
(	O
const	O
int	O
month	int
)	O
)	O
;	O
__END_DECLARATIONS	O
VOID_PTR	O
my_malloc	function
(	O
amount	int
,	O
exit_status	int
,	O
module_name	pointer
,	O
module_line	long
,	O
var_name	pointer
,	O
var_contents	int
)	O
const	O
int	O
amount	int
;	O
const	O
int	O
exit_status	int
;	O
const	O
char	O
*	O
module_name	pointer
;	O
const	O
long	O
module_line	long
;	O
const	O
char	O
*	O
var_name	pointer
;	O
const	O
int	O
var_contents	int
;	O
{	O
auto	O
VOID_PTR	O
ptr_memblock	pointer
;	O
if	O
(	O
(	O
Uint	int
)	O
amount	int
>	O
testval	int
)	O
my_error	function
(	O
ERR_INTERNAL_TABLE_CRASH	int
,	O
module_name	pointer
,	O
module_line	long
,	O
var_name	pointer
,	O
(	O
int	O
)	O
testval	int
)	O
;	O
ptr_memblock	pointer
=	O
(	O
VOID_PTR	O
)	O
malloc	function
(	O
(	O
int	O
)	O
amount	int
)	O
;	O
if	O
(	O
ptr_memblock	pointer
==	O
(	O
VOID_PTR	O
)	O
NULL	O
)	O
my_error	function
(	O
exit_status	int
,	O
module_name	pointer
,	O
module_line	long
,	O
var_name	pointer
,	O
var_contents	int
)	O
;	O
return	O
(	O
ptr_memblock	pointer
)	O
;	O
}	O
VOID_PTR	O
my_realloc	function
(	O
ptr_memblock	pointer
,	O
amount	int
,	O
exit_status	int
,	O
module_name	pointer
,	O
module_line	long
,	O
var_name	pointer
,	O
var_contents	int
)	O
VOID_PTR	O
ptr_memblock	pointer
;	O
const	O
int	O
amount	int
;	O
const	O
int	O
exit_status	int
;	O
const	O
char	O
*	O
module_name	pointer
;	O
const	O
long	O
module_line	long
;	O
const	O
char	O
*	O
var_name	pointer
;	O
const	O
int	O
var_contents	int
;	O
{	O
if	O
(	O
(	O
Uint	int
)	O
amount	int
>	O
testval	int
)	O
my_error	function
(	O
ERR_INTERNAL_TABLE_CRASH	int
,	O
module_name	pointer
,	O
module_line	long
,	O
var_name	pointer
,	O
(	O
int	O
)	O
testval	int
)	O
;	O
if	O
(	O
ptr_memblock	pointer
==	O
(	O
VOID_PTR	O
)	O
NULL	O
)	O
return	O
(	O
my_malloc	function
(	O
amount	int
,	O
exit_status	int
,	O
module_name	pointer
,	O
module_line	long
,	O
var_name	pointer
,	O
var_contents	int
)	O
)	O
;	O
ptr_memblock	pointer
=	O
(	O
VOID_PTR	O
)	O
realloc	function
(	O
ptr_memblock	pointer
,	O
(	O
int	O
)	O
amount	int
)	O
;	O
if	O
(	O
ptr_memblock	pointer
==	O
(	O
VOID_PTR	O
)	O
NULL	O
)	O
my_error	function
(	O
exit_status	int
,	O
module_name	pointer
,	O
module_line	long
,	O
var_name	pointer
,	O
var_contents	int
)	O
;	O
return	O
(	O
ptr_memblock	pointer
)	O
;	O
}	O
void	O
allocate_all_strings	function
(	O
amount	int
,	O
module_name	pointer
,	O
module_line	long
)	O
const	O
int	O
amount	int
;	O
const	O
char	O
*	O
module_name	pointer
;	O
const	O
long	O
module_line	long
;	O
{	O
static	O
Bool	int
all_strings_initialized	int
=	O
FALSE	O
;	O
if	O
(	O
!	O
all_strings_initialized	int
)	O
{	O
s1	pointer
=	O
(	O
char	O
*	O
)	O
my_malloc	function
(	O
amount	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
module_name	pointer
,	O
module_line	long
,	O
"s1"	pointer
,	O
0	int
)	O
;	O
s2	pointer
=	O
(	O
char	O
*	O
)	O
my_malloc	function
(	O
amount	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
module_name	pointer
,	O
module_line	long
,	O
"s2"	pointer
,	O
0	int
)	O
;	O
s3	pointer
=	O
(	O
char	O
*	O
)	O
my_malloc	function
(	O
amount	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
module_name	pointer
,	O
module_line	long
,	O
"s3"	pointer
,	O
0	int
)	O
;	O
s4	pointer
=	O
(	O
char	O
*	O
)	O
my_malloc	function
(	O
amount	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
module_name	pointer
,	O
module_line	long
,	O
"s4"	pointer
,	O
0	int
)	O
;	O
s5	pointer
=	O
(	O
char	O
*	O
)	O
my_malloc	function
(	O
amount	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
module_name	pointer
,	O
module_line	long
,	O
"s5"	pointer
,	O
0	int
)	O
;	O
s6	pointer
=	O
(	O
char	O
*	O
)	O
my_malloc	function
(	O
amount	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
module_name	pointer
,	O
module_line	long
,	O
"s6"	pointer
,	O
0	int
)	O
;	O
s7	pointer
=	O
(	O
char	O
*	O
)	O
my_malloc	function
(	O
amount	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
module_name	pointer
,	O
module_line	long
,	O
"s7"	pointer
,	O
0	int
)	O
;	O
line_buffer	pointer
=	O
(	O
char	O
*	O
)	O
my_malloc	function
(	O
amount	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
module_name	pointer
,	O
module_line	long
,	O
"line_buffer"	pointer
,	O
0	int
)	O
;	O
all_strings_initialized	int
=	O
TRUE	O
;	O
}	O
}	O
void	O
resize_all_strings	function
(	O
amount	int
,	O
with_line_buffer	int
,	O
module_name	pointer
,	O
module_line	long
)	O
const	O
int	O
amount	int
;	O
const	O
Bool	int
with_line_buffer	int
;	O
const	O
char	O
*	O
module_name	pointer
;	O
const	O
long	O
module_line	long
;	O
{	O
if	O
(	O
(	O
(	O
Uint	int
)	O
amount	int
>	O
testval	int
)	O
&&	O
(	O
maxlen_max	int
<	O
testval	int
)	O
)	O
maxlen_max	int
=	O
testval	int
;	O
else	O
maxlen_max	int
=	O
(	O
Uint	int
)	O
amount	int
;	O
s1	pointer
=	O
(	O
char	O
*	O
)	O
my_realloc	function
(	O
(	O
VOID_PTR	O
)	O
s1	pointer
,	O
maxlen_max	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
module_name	pointer
,	O
module_line	long
,	O
"s1"	pointer
,	O
maxlen_max	int
)	O
;	O
s2	pointer
=	O
(	O
char	O
*	O
)	O
my_realloc	function
(	O
(	O
VOID_PTR	O
)	O
s2	pointer
,	O
maxlen_max	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
module_name	pointer
,	O
module_line	long
,	O
"s2"	pointer
,	O
maxlen_max	int
)	O
;	O
s3	pointer
=	O
(	O
char	O
*	O
)	O
my_realloc	function
(	O
(	O
VOID_PTR	O
)	O
s3	pointer
,	O
maxlen_max	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
module_name	pointer
,	O
module_line	long
,	O
"s3"	pointer
,	O
maxlen_max	int
)	O
;	O
s4	pointer
=	O
(	O
char	O
*	O
)	O
my_realloc	function
(	O
(	O
VOID_PTR	O
)	O
s4	pointer
,	O
maxlen_max	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
module_name	pointer
,	O
module_line	long
,	O
"s4"	pointer
,	O
maxlen_max	int
)	O
;	O
s5	pointer
=	O
(	O
char	O
*	O
)	O
my_realloc	function
(	O
(	O
VOID_PTR	O
)	O
s5	pointer
,	O
maxlen_max	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
module_name	pointer
,	O
module_line	long
,	O
"s5"	pointer
,	O
maxlen_max	int
)	O
;	O
s6	pointer
=	O
(	O
char	O
*	O
)	O
my_realloc	function
(	O
(	O
VOID_PTR	O
)	O
s6	pointer
,	O
maxlen_max	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
module_name	pointer
,	O
module_line	long
,	O
"s6"	pointer
,	O
maxlen_max	int
)	O
;	O
s7	pointer
=	O
(	O
char	O
*	O
)	O
my_realloc	function
(	O
(	O
VOID_PTR	O
)	O
s7	pointer
,	O
maxlen_max	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
module_name	pointer
,	O
module_line	long
,	O
"s7"	pointer
,	O
maxlen_max	int
)	O
;	O
if	O
(	O
with_line_buffer	int
)	O
line_buffer	pointer
=	O
(	O
char	O
*	O
)	O
my_realloc	function
(	O
(	O
VOID_PTR	O
)	O
line_buffer	pointer
,	O
maxlen_max	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
module_name	pointer
,	O
module_line	long
,	O
"line_buffer"	pointer
,	O
maxlen_max	int
)	O
;	O
}	O
void	O
my_error	function
(	O
exit_status	int
,	O
module_name	pointer
,	O
module_line	long
,	O
var_name	pointer
,	O
var_contents	int
)	O
const	O
int	O
exit_status	int
;	O
const	O
char	O
*	O
module_name	pointer
;	O
const	O
long	O
module_line	long
;	O
const	O
char	O
*	O
var_name	pointer
;	O
const	O
int	O
var_contents	int
;	O
{	O
S_NEWLINE	O
(	O
stderr	pointer
)	O
;	O
if	O
(	O
prgr_name	pointer
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
prgr_name	pointer
=	O
PACKAGE_NAME	pointer
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: abort, "	pointer
)	O
,	O
prgr_name	pointer
)	O
;	O
switch	O
(	O
exit_status	int
)	O
{	O
case	O
ERR_INVALID_EASTER_DATE	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"invalid year for computing Easter Sundays date\nYear must be in range (%d...%d)"	pointer
)	O
,	O
EASTER_MIN	int
,	O
EASTER_MAX	O
)	O
;	O
break	O
;	O
case	O
ERR_NO_MEMORY_AVAILABLE	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"`%s' line %ld: virtual memory exhausted (%s=%d)"	pointer
)	O
,	O
module_name	pointer
,	O
module_line	long
,	O
var_name	pointer
,	O
var_contents	int
)	O
;	O
break	O
;	O
case	O
ERR_INVALID_DATE_FIELD	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"invalid date part in file `%s'\nLine %ld: %s"	pointer
)	O
,	O
module_name	pointer
,	O
module_line	long
,	O
var_name	pointer
)	O
;	O
break	O
;	O
case	O
ERR_INVALID_MONTH_FIELD	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"invalid month field(%02d) in file `%s'\nLine %ld: %s"	pointer
)	O
,	O
var_contents	int
,	O
module_name	pointer
,	O
module_line	long
,	O
var_name	pointer
)	O
;	O
break	O
;	O
case	O
ERR_INVALID_DAY_FIELD	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"invalid day field(%02d) in file `%s'\nLine %ld: %s"	pointer
)	O
,	O
var_contents	int
,	O
module_name	pointer
,	O
module_line	long
,	O
var_name	pointer
)	O
;	O
break	O
;	O
case	O
ERR_MALFORMED_INCLUDE	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"malformed %s in file `%s'\nLine %ld: %s"	pointer
)	O
,	O
RC_INCL_STMENT	pointer
,	O
module_name	pointer
,	O
module_line	long
,	O
var_name	pointer
)	O
;	O
break	O
;	O
case	O
ERR_CYCLIC_INCLUDE	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"invalid recursive/cyclic %s in file `%s'\nLine %ld: %s"	pointer
)	O
,	O
RC_INCL_STMENT	pointer
,	O
module_name	pointer
,	O
module_line	long
,	O
var_name	pointer
)	O
;	O
break	O
;	O
case	O
ERR_FILE_NOT_FOUND	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"file `%s' not found"	pointer
)	O
,	O
module_name	pointer
)	O
;	O
break	O
;	O
case	O
ERR_INVALID_NWD_FIELD	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"invalid N'th weekday field(%d) in file `%s'\nLine %ld: %s"	pointer
)	O
,	O
var_contents	int
,	O
module_name	pointer
,	O
module_line	long
,	O
var_name	pointer
)	O
;	O
break	O
;	O
case	O
ERR_NO_SEPARATOR_CHAR	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"missing `whitespace' character after date part in file `%s'\nLine %ld: %s"	pointer
)	O
,	O
module_name	pointer
,	O
module_line	long
,	O
var_name	pointer
)	O
;	O
break	O
;	O
case	O
ERR_WRITE_FILE	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"file `%s' can't be written\nStorage media full!"	pointer
)	O
,	O
var_name	pointer
)	O
;	O
break	O
;	O
case	O
ERR_EMAIL_SEND_FAILURE	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"sending eMail to <%s> failed"	pointer
)	O
,	O
var_name	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"\n`%s' line %ld: "	pointer
)	O
,	O
module_name	pointer
,	O
module_line	long
)	O
;	O
perror	function
(	O
"perror"	pointer
)	O
;	O
break	O
;	O
case	O
ERR_INTERNAL_C_FUNC_FAILURE	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"`%s' line %ld: (`%s') `%s%d' failed"	pointer
)	O
,	O
module_name	pointer
,	O
module_line	long
,	O
_	O
(	O
"Internal"	pointer
)	O
,	O
var_name	pointer
,	O
var_contents	int
)	O
;	O
perror	function
(	O
"\nperror"	pointer
)	O
;	O
break	O
;	O
case	O
ERR_READ_FILE	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"read error in file `%s'"	pointer
)	O
,	O
var_name	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"\n`%s' line %ld: "	pointer
)	O
,	O
module_name	pointer
,	O
module_line	long
)	O
;	O
perror	function
(	O
"perror"	pointer
)	O
;	O
break	O
;	O
case	O
ERR_ILLEGAL_CHAR_IN_FILE	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"illegal character in response file `%s'\nLine %ld: %s"	pointer
)	O
,	O
module_name	pointer
,	O
module_line	long
,	O
var_name	pointer
)	O
;	O
break	O
;	O
case	O
ERR_INTERNAL_TABLE_CRASH	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"`%s' line %ld: (`%s') invalid value for table size `sizeof %s>%d'"	pointer
)	O
,	O
module_name	pointer
,	O
module_line	long
,	O
_	O
(	O
"Internal"	pointer
)	O
,	O
var_name	pointer
,	O
var_contents	int
)	O
;	O
break	O
;	O
case	O
ERR_INVALID_DATE_FORMAT	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"(`%s') date format `%s' is invalid"	pointer
)	O
,	O
module_name	pointer
,	O
var_name	pointer
)	O
;	O
break	O
;	O
case	O
ERR_INVALID_REGEX_PATTERN	int
:	O
if	O
(	O
*	O
module_name	pointer
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s in search pattern `%s'"	pointer
)	O
,	O
module_name	pointer
,	O
var_name	pointer
)	O
;	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"invalid search pattern `%s' specified"	pointer
)	O
,	O
var_name	pointer
)	O
;	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"`%s' line %ld: (`%s') unmanaged error (%d)"	pointer
)	O
,	O
module_name	pointer
,	O
module_line	long
,	O
_	O
(	O
"internal"	pointer
)	O
,	O
exit_status	int
)	O
;	O
}	O
S_NEWLINE	O
(	O
stderr	pointer
)	O
;	O
my_exit	function
(	O
exit_status	int
)	O
;	O
}	O
RETSIGTYPE	void
handle_signal	function
(	O
the_signal	int
)	O
int	O
the_signal	int
;	O
{	O
fflush	function
(	O
stdout	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"\n%s: program aborted by signal %d\n"	pointer
)	O
,	O
prgr_name	pointer
,	O
the_signal	int
)	O
;	O
my_exit	function
(	O
ERR_TERMINATION_BY_SIGNAL	int
)	O
;	O
}	O
void	O
my_exit	function
(	O
exit_status	int
)	O
const	O
int	O
exit_status	int
;	O
{	O
if	O
(	O
rc_tvar_tfp	pointer
!=	O
(	O
FILE	struct
*	O
)	O
NULL	O
)	O
(	O
void	O
)	O
fclose	function
(	O
rc_tvar_tfp	pointer
)	O
;	O
if	O
(	O
rc_tvar_tfn	pointer
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
(	O
void	O
)	O
unlink	function
(	O
rc_tvar_tfn	pointer
)	O
;	O
if	O
(	O
rc_here_fp	pointer
!=	O
(	O
FILE	struct
*	O
)	O
NULL	O
)	O
(	O
void	O
)	O
fclose	function
(	O
rc_here_fp	pointer
)	O
;	O
if	O
(	O
rc_here_fn	pointer
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
(	O
void	O
)	O
unlink	function
(	O
rc_here_fn	pointer
)	O
;	O
if	O
(	O
tfp	pointer
!=	O
(	O
FILE	struct
*	O
)	O
NULL	O
)	O
(	O
void	O
)	O
fclose	function
(	O
tfp	pointer
)	O
;	O
if	O
(	O
tfn	pointer
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
(	O
void	O
)	O
unlink	function
(	O
tfn	pointer
)	O
;	O
exit	function
(	O
exit_status	int
)	O
;	O
}	O
int	O
my_atoi	function
(	O
string	pointer
)	O
const	O
char	O
*	O
string	pointer
;	O
{	O
while	O
(	O
*	O
string	pointer
==	O
'0'	O
)	O
string	pointer
++	O
;	O
if	O
(	O
*	O
string	pointer
==	O
'-'	O
||	O
(	O
int	O
)	O
strlen	function
(	O
string	pointer
)	O
>	O
len_year_max	int
)	O
return	O
(	O
0	int
)	O
;	O
return	O
(	O
atoi	function
(	O
string	pointer
)	O
)	O
;	O
}	O
int	O
my_system	function
(	O
command	pointer
)	O
const	O
char	O
*	O
command	pointer
;	O
{	O
return	O
(	O
(	O
(	O
unsigned	O
int	O
)	O
system	function
(	O
command	pointer
)	O
>>	O
8	int
)	O
&	O
0xff	int
)	O
;	O
}	O
Bool	int
get_actual_date	function
(	O
)	O
{	O
auto	O
struct	O
tm	struct
*	O
sys_date	pointer
;	O
auto	O
MY_TIME_T	O
sys_time	long
;	O
static	O
Bool	int
got_time	int
=	O
FALSE	O
;	O
sys_time	long
=	O
time	struct
(	O
(	O
MY_TIME_T	O
*	O
)	O
NULL	O
)	O
;	O
sys_date	pointer
=	O
localtime	function
(	O
&	O
sys_time	long
)	O
;	O
true_day	int
=	O
act_day	int
=	O
sys_date	pointer
->	O
tm_mday	int
;	O
true_month	int
=	O
act_month	int
=	O
sys_date	pointer
->	O
tm_mon	int
+	O
1	int
;	O
act_year	int
=	O
sys_date	pointer
->	O
tm_year	int
;	O
if	O
(	O
act_year	int
<	O
CENTURY	int
)	O
act_year	int
+=	O
CENTURY	int
;	O
true_year	int
=	O
act_year	int
;	O
if	O
(	O
!	O
got_time	int
)	O
{	O
act_sec	int
=	O
sys_date	pointer
->	O
tm_sec	int
;	O
act_min	int
=	O
sys_date	pointer
->	O
tm_min	int
;	O
act_hour	int
=	O
sys_date	pointer
->	O
tm_hour	int
;	O
buf_ad	int
=	O
act_day	int
;	O
buf_am	int
=	O
act_month	int
;	O
buf_ay	int
=	O
act_year	int
;	O
}	O
if	O
(	O
rc_adate	pointer
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
auto	O
int	O
d	int
=	O
0	int
;	O
auto	O
int	O
m	int
=	O
0	int
;	O
auto	O
int	O
y	int
=	O
0	int
;	O
auto	O
int	O
n	long
=	O
0	int
;	O
auto	O
int	O
hn	int
=	O
0	int
;	O
auto	O
int	O
hwd	int
=	O
0	int
;	O
auto	O
int	O
i_dummy	int
;	O
auto	O
char	O
hc	char
=	O
'\0'	O
;	O
auto	O
char	O
*	O
c_dummy	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
auto	O
Bool	int
b_dummy	int
;	O
if	O
(	O
!	O
*	O
rc_adate	pointer
||	O
*	O
rc_adate	pointer
==	O
RC_HDY_CHAR	char
)	O
return	O
(	O
FALSE	O
)	O
;	O
m	int
=	O
act_month	int
;	O
y	int
=	O
act_year	int
;	O
if	O
(	O
isdigit	function
(	O
*	O
rc_adate	pointer
)	O
)	O
{	O
if	O
(	O
(	O
int	O
)	O
strlen	function
(	O
rc_adate	pointer
)	O
<=	O
2	int
)	O
{	O
d	int
=	O
atoi	function
(	O
rc_adate	pointer
)	O
;	O
if	O
(	O
!	O
d	int
)	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
else	O
(	O
void	O
)	O
rc_get_date	function
(	O
rc_adate	pointer
,	O
lptrs3	pointer
,	O
FALSE	O
,	O
&	O
b_dummy	int
,	O
&	O
d	int
,	O
&	O
m	int
,	O
&	O
y	int
,	O
&	O
n	long
,	O
&	O
i_dummy	int
,	O
&	O
hc	char
,	O
&	O
hn	int
,	O
&	O
hwd	int
,	O
_	O
(	O
"Internal"	pointer
)	O
,	O
-	O
1L	int
,	O
rc_adate	pointer
,	O
FALSE	O
)	O
;	O
}	O
else	O
{	O
d	int
=	O
compare_d_m_name	function
(	O
rc_adate	pointer
,	O
DAy	int
)	O
;	O
if	O
(	O
d	int
)	O
{	O
c_dummy	pointer
=	O
rc_adate	pointer
;	O
while	O
(	O
isalpha	function
(	O
*	O
c_dummy	pointer
)	O
)	O
c_dummy	pointer
++	O
;	O
if	O
(	O
*	O
c_dummy	pointer
)	O
{	O
n	long
=	O
atoi	function
(	O
c_dummy	pointer
)	O
;	O
if	O
(	O
!	O
n	long
)	O
return	O
(	O
FALSE	O
)	O
;	O
c_dummy	pointer
++	O
;	O
if	O
(	O
*	O
c_dummy	pointer
)	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
else	O
{	O
hn	int
=	O
act_day	int
;	O
i_dummy	int
=	O
weekday_of_date	function
(	O
act_day	int
,	O
act_month	int
,	O
act_year	int
)	O
;	O
if	O
(	O
d	int
>	O
i_dummy	int
)	O
do	O
{	O
(	O
void	O
)	O
next_date	function
(	O
&	O
hn	int
,	O
&	O
m	int
,	O
&	O
y	int
)	O
;	O
}	O
while	O
(	O
d	int
!=	O
weekday_of_date	function
(	O
hn	int
,	O
m	int
,	O
y	int
)	O
)	O
;	O
else	O
if	O
(	O
d	int
<	O
i_dummy	int
)	O
do	O
{	O
(	O
void	O
)	O
prev_date	function
(	O
&	O
hn	int
,	O
&	O
m	int
,	O
&	O
y	int
)	O
;	O
}	O
while	O
(	O
d	int
!=	O
weekday_of_date	function
(	O
hn	int
,	O
m	int
,	O
y	int
)	O
)	O
;	O
d	int
=	O
hn	int
;	O
}	O
}	O
else	O
{	O
m	int
=	O
compare_d_m_name	function
(	O
rc_adate	pointer
,	O
MOnth	int
)	O
;	O
if	O
(	O
!	O
m	int
)	O
return	O
(	O
FALSE	O
)	O
;	O
c_dummy	pointer
=	O
rc_adate	pointer
;	O
while	O
(	O
isupper	function
(	O
*	O
c_dummy	pointer
)	O
||	O
islower	function
(	O
*	O
c_dummy	pointer
)	O
)	O
c_dummy	pointer
++	O
;	O
if	O
(	O
*	O
c_dummy	pointer
)	O
{	O
d	int
=	O
atoi	function
(	O
c_dummy	pointer
)	O
;	O
if	O
(	O
!	O
d	int
)	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
else	O
d	int
=	O
act_day	int
;	O
}	O
}	O
if	O
(	O
y	int
>=	O
0	int
)	O
{	O
if	O
(	O
!	O
y	int
)	O
y	int
=	O
act_year	int
;	O
if	O
(	O
!	O
m	int
)	O
m	int
=	O
act_month	int
;	O
if	O
(	O
n	long
)	O
{	O
if	O
(	O
d	int
>	O
DAY_MAX	int
)	O
return	O
(	O
FALSE	O
)	O
;	O
if	O
(	O
!	O
d	int
)	O
d	int
=	O
weekday_of_date	function
(	O
act_day	int
,	O
m	int
,	O
y	int
)	O
;	O
if	O
(	O
m	int
==	O
2	int
)	O
i_dummy	int
=	O
days_of_february	function
(	O
y	int
)	O
;	O
else	O
i_dummy	int
=	O
dvec	array
[	O
m	int
-	O
1	int
]	O
;	O
if	O
(	O
n	long
==	O
9	int
)	O
d	int
=	O
eval_holiday	function
(	O
i_dummy	int
,	O
m	int
,	O
y	int
,	O
d	int
,	O
FALSE	O
)	O
;	O
else	O
if	O
(	O
(	O
n	long
>=	O
1	int
)	O
&&	O
(	O
n	long
<=	O
5	int
)	O
)	O
{	O
d	int
=	O
eval_holiday	function
(	O
DAY_MIN	int
,	O
m	int
,	O
y	int
,	O
d	int
,	O
TRUE	O
)	O
;	O
d	int
+=	O
(	O
DAY_MAX	int
*	O
(	O
n	long
-	O
1	int
)	O
)	O
;	O
if	O
(	O
d	int
>	O
i_dummy	int
)	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
else	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
else	O
if	O
(	O
hc	char
)	O
{	O
switch	O
(	O
hc	char
)	O
{	O
case	O
RC_EASTER_CHAR	char
:	O
case	O
RC_TODAY_CHAR	char
:	O
if	O
(	O
!	O
precomp_date	function
(	O
hn	int
,	O
hwd	int
,	O
&	O
d	int
,	O
&	O
m	int
,	O
y	int
,	O
(	O
hc	char
==	O
RC_EASTER_CHAR	char
)	O
?	O
EAster	int
:	O
TOday	int
)	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
break	O
;	O
case	O
'D'	O
:	O
case	O
'W'	O
:	O
if	O
(	O
!	O
precomp_nth_wd	function
(	O
hn	int
,	O
hwd	int
,	O
&	O
n	long
,	O
&	O
d	int
,	O
&	O
m	int
,	O
&	O
y	int
,	O
(	O
(	O
hc	char
==	O
'D'	O
)	O
?	O
DAy	int
:	O
WEek	int
)	O
)	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
!	O
islower	function
(	O
hc	char
)	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
else	O
if	O
(	O
!	O
precomp_date	function
(	O
hn	int
,	O
hwd	int
,	O
&	O
d	int
,	O
&	O
m	int
,	O
y	int
,	O
DVar	int
)	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
d	int
)	O
d	int
=	O
act_day	int
;	O
else	O
if	O
(	O
d	int
==	O
99	int
)	O
{	O
if	O
(	O
m	int
==	O
2	int
)	O
d	int
=	O
days_of_february	function
(	O
y	int
)	O
;	O
else	O
d	int
=	O
dvec	array
[	O
m	int
-	O
1	int
]	O
;	O
}	O
if	O
(	O
valid_date	function
(	O
d	int
,	O
m	int
,	O
y	int
)	O
)	O
{	O
act_day	int
=	O
d	int
;	O
act_month	int
=	O
m	int
;	O
act_year	int
=	O
y	int
;	O
}	O
else	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
else	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
gregorian2julian	function
(	O
&	O
act_day	int
,	O
&	O
act_month	int
,	O
&	O
act_year	int
)	O
;	O
if	O
(	O
!	O
got_time	int
)	O
{	O
got_time	int
=	O
TRUE	O
;	O
sys_date	pointer
=	O
gmtime	function
(	O
&	O
sys_time	long
)	O
;	O
gmt_min	int
=	O
sys_date	pointer
->	O
tm_min	int
;	O
gmt_hour	int
=	O
sys_date	pointer
->	O
tm_hour	int
;	O
buf_gd	int
=	O
sys_date	pointer
->	O
tm_mday	int
;	O
buf_gm	int
=	O
sys_date	pointer
->	O
tm_mon	int
+	O
1	int
;	O
buf_gy	int
=	O
sys_date	pointer
->	O
tm_year	int
;	O
if	O
(	O
buf_gy	int
<	O
CENTURY	int
)	O
buf_gy	int
+=	O
CENTURY	int
;	O
gregorian2julian	function
(	O
&	O
buf_gd	int
,	O
&	O
buf_gm	int
,	O
&	O
buf_gy	int
)	O
;	O
gmt_loc_diff	int
=	O
(	O
int	O
)	O
d_between	function
(	O
buf_ad	int
,	O
buf_am	int
,	O
buf_ay	int
,	O
buf_gd	int
,	O
buf_gm	int
,	O
buf_gy	int
)	O
;	O
buf_ad	int
=	O
act_day	int
;	O
buf_am	int
=	O
act_month	int
;	O
buf_ay	int
=	O
act_year	int
;	O
}	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
int	O
compare_d_m_name	function
(	O
string	pointer
,	O
mode	enum
)	O
const	O
char	O
*	O
string	pointer
;	O
const	O
Cmode_enum	enum
mode	enum
;	O
{	O
register	O
int	O
len	int
=	O
(	O
int	O
)	O
strlen	function
(	O
string	pointer
)	O
;	O
register	O
const	O
int	O
len_min	int
=	O
(	O
mode	enum
==	O
DAy	int
)	O
?	O
TXTLEN_DAY	int
:	O
TXTLEN_MONTH	int
;	O
register	O
int	O
i	int
;	O
register	O
int	O
imax	int
=	O
(	O
mode	enum
==	O
DAy	int
)	O
?	O
DAY_MAX	int
:	O
MONTH_MAX	int
;	O
register	O
int	O
j	int
=	O
0	int
;	O
register	O
int	O
checks	int
;	O
auto	O
const	O
char	O
*	O
ptr_char	pointer
=	O
string	pointer
;	O
if	O
(	O
is_en	int
)	O
checks	int
=	O
1	int
;	O
else	O
checks	int
=	O
2	int
;	O
if	O
(	O
len	int
>=	O
TXTLEN_DAY	int
)	O
{	O
while	O
(	O
*	O
(	O
ptr_char	pointer
+	O
j	int
)	O
&&	O
!	O
isdigit	function
(	O
*	O
(	O
ptr_char	pointer
+	O
j	int
)	O
)	O
&&	O
(	O
*	O
(	O
ptr_char	pointer
+	O
j	int
)	O
!=	O
RC_REPEAT_CHAR	char
)	O
&&	O
(	O
*	O
(	O
ptr_char	pointer
+	O
j	int
)	O
!=	O
RC_APPEARS_CHAR	char
)	O
)	O
j	int
++	O
;	O
if	O
(	O
j	int
>=	O
len_min	int
)	O
do	O
{	O
for	O
(	O
i	int
=	O
(	O
mode	enum
==	O
DAy	int
)	O
?	O
DAY_MIN	int
:	O
MONTH_MIN	int
;	O
i	int
<=	O
imax	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
checks	int
==	O
2	int
)	O
ptr_char	pointer
=	O
(	O
mode	enum
==	O
DAy	int
)	O
?	O
day_name	function
(	O
i	int
)	O
:	O
month_name	function
(	O
i	int
)	O
;	O
else	O
ptr_char	pointer
=	O
(	O
mode	enum
==	O
DAy	int
)	O
?	O
dflt_day_name	function
(	O
i	int
)	O
:	O
dflt_month_name	function
(	O
i	int
)	O
;	O
j	int
=	O
0	int
;	O
while	O
(	O
*	O
(	O
ptr_char	pointer
+	O
j	int
)	O
&&	O
string	pointer
[	O
j	int
]	O
)	O
if	O
(	O
tolower	function
(	O
*	O
(	O
ptr_char	pointer
+	O
j	int
)	O
)	O
==	O
tolower	function
(	O
string	pointer
[	O
j	int
]	O
)	O
)	O
j	int
++	O
;	O
else	O
break	O
;	O
if	O
(	O
j	int
==	O
len	int
||	O
(	O
j	int
&&	O
(	O
isdigit	function
(	O
string	pointer
[	O
j	int
]	O
)	O
||	O
string	pointer
[	O
j	int
]	O
==	O
RC_REPEAT_CHAR	char
||	O
string	pointer
[	O
j	int
]	O
==	O
RC_APPEARS_CHAR	char
)	O
)	O
||	O
!	O
*	O
(	O
ptr_char	pointer
+	O
j	int
)	O
)	O
return	O
(	O
i	int
)	O
;	O
}	O
}	O
while	O
(	O
--	O
checks	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
asc_sort	function
(	O
a	pointer
,	O
b	pointer
)	O
const	O
char	O
*	O
*	O
a	pointer
;	O
const	O
char	O
*	O
*	O
b	pointer
;	O
{	O
return	O
(	O
strcmp	function
(	O
*	O
a	pointer
,	O
*	O
b	pointer
)	O
)	O
;	O
}	O
int	O
des_sort	function
(	O
a	pointer
,	O
b	pointer
)	O
const	O
char	O
*	O
*	O
a	pointer
;	O
const	O
char	O
*	O
*	O
b	pointer
;	O
{	O
return	O
(	O
strcmp	function
(	O
*	O
b	pointer
,	O
*	O
a	pointer
)	O
)	O
;	O
}	O
Bool	int
is_presorted	function
(	O
table	pointer
,	O
elems	int
)	O
char	O
*	O
*	O
table	pointer
;	O
int	O
elems	int
;	O
{	O
if	O
(	O
--	O
elems	int
>	O
0	int
)	O
{	O
register	O
int	O
i	int
=	O
0	int
;	O
register	O
int	O
j	int
=	O
0	int
;	O
while	O
(	O
elems	int
--	O
)	O
{	O
j	int
++	O
;	O
if	O
(	O
*	O
table	pointer
[	O
i	int
]	O
>=	O
*	O
table	pointer
[	O
j	int
]	O
)	O
if	O
(	O
strcmp	function
(	O
table	pointer
[	O
i	int
]	O
,	O
table	pointer
[	O
j	int
]	O
)	O
>	O
0	int
)	O
return	O
(	O
FALSE	O
)	O
;	O
i	int
++	O
;	O
}	O
}	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
void	O
reverse_order	function
(	O
table	pointer
,	O
elems	int
)	O
char	O
*	O
*	O
table	pointer
;	O
const	O
int	O
elems	int
;	O
{	O
register	O
int	O
right	int
=	O
elems	int
-	O
1	int
;	O
if	O
(	O
right	int
>	O
0	int
)	O
{	O
register	O
int	O
left	int
=	O
0	int
;	O
auto	O
char	O
*	O
ptr_elem	pointer
;	O
while	O
(	O
left	int
<	O
right	int
)	O
{	O
ptr_elem	pointer
=	O
table	pointer
[	O
left	int
]	O
;	O
table	pointer
[	O
left	int
++	O
]	O
=	O
table	pointer
[	O
right	int
]	O
;	O
table	pointer
[	O
right	int
--	O
]	O
=	O
ptr_elem	pointer
;	O
}	O
}	O
}	O
const	O
char	O
*	O
day_suffix	function
(	O
day	int
)	O
int	O
day	int
;	O
{	O
static	O
const	O
char	O
*	O
suffix	array
[	O
]	O
=	O
{	O
N_	O
(	O
"th"	pointer
)	O
,	O
N_	O
(	O
"st"	pointer
)	O
,	O
N_	O
(	O
"nd"	pointer
)	O
,	O
N_	O
(	O
"rd"	pointer
)	O
}	O
;	O
register	O
int	O
i	int
=	O
0	int
;	O
if	O
(	O
day	int
<	O
0	int
)	O
day	int
=	O
-	O
day	int
;	O
if	O
(	O
day	int
>	O
10000	int
)	O
day	int
%=	O
10000	int
;	O
if	O
(	O
day	int
>	O
1000	int
)	O
day	int
%=	O
1000	int
;	O
if	O
(	O
day	int
>	O
100	int
)	O
day	int
%=	O
100	int
;	O
if	O
(	O
day	int
<	O
11	int
||	O
day	int
>	O
13	int
)	O
i	int
=	O
day	int
%	O
10	int
;	O
if	O
(	O
i	int
>	O
3	int
)	O
i	int
=	O
0	int
;	O
return	O
(	O
_	O
(	O
suffix	array
[	O
i	int
]	O
)	O
)	O
;	O
}	O
const	O
char	O
*	O
short3_day_name	function
(	O
day	int
)	O
const	O
int	O
day	int
;	O
{	O
static	O
const	O
char	O
*	O
name	array
[	O
]	O
=	O
{	O
N_	O
(	O
"invalid day"	pointer
)	O
,	O
N_	O
(	O
"Mon"	pointer
)	O
,	O
N_	O
(	O
"Tue"	pointer
)	O
,	O
N_	O
(	O
"Wed"	pointer
)	O
,	O
N_	O
(	O
"Thu"	pointer
)	O
,	O
N_	O
(	O
"Fri"	pointer
)	O
,	O
N_	O
(	O
"Sat"	pointer
)	O
,	O
N_	O
(	O
"Sun"	pointer
)	O
}	O
;	O
return	O
(	O
(	O
(	O
day	int
<	O
DAY_MIN	int
)	O
||	O
(	O
day	int
>	O
DAY_MAX	int
)	O
)	O
?	O
_	O
(	O
name	array
[	O
0	int
]	O
)	O
:	O
_	O
(	O
name	array
[	O
day	int
]	O
)	O
)	O
;	O
}	O
const	O
char	O
*	O
short_day_name	function
(	O
day	int
)	O
const	O
int	O
day	int
;	O
{	O
static	O
const	O
char	O
*	O
name	array
[	O
]	O
=	O
{	O
N_	O
(	O
"invalid day"	pointer
)	O
,	O
N_	O
(	O
"Mo"	pointer
)	O
,	O
N_	O
(	O
"Tu"	pointer
)	O
,	O
N_	O
(	O
"We"	pointer
)	O
,	O
N_	O
(	O
"Th"	pointer
)	O
,	O
N_	O
(	O
"Fr"	pointer
)	O
,	O
N_	O
(	O
"Sa"	pointer
)	O
,	O
N_	O
(	O
"Su"	pointer
)	O
}	O
;	O
return	O
(	O
(	O
(	O
day	int
<	O
DAY_MIN	int
)	O
||	O
(	O
day	int
>	O
DAY_MAX	int
)	O
)	O
?	O
_	O
(	O
name	array
[	O
0	int
]	O
)	O
:	O
_	O
(	O
name	array
[	O
day	int
]	O
)	O
)	O
;	O
}	O
const	O
char	O
*	O
day_name	function
(	O
day	int
)	O
const	O
int	O
day	int
;	O
{	O
static	O
const	O
char	O
*	O
name	array
[	O
]	O
=	O
{	O
N_	O
(	O
"invalid day"	pointer
)	O
,	O
N_	O
(	O
"Monday"	pointer
)	O
,	O
N_	O
(	O
"Tuesday"	pointer
)	O
,	O
N_	O
(	O
"Wednesday"	pointer
)	O
,	O
N_	O
(	O
"Thursday"	pointer
)	O
,	O
N_	O
(	O
"Friday"	pointer
)	O
,	O
N_	O
(	O
"Saturday"	pointer
)	O
,	O
N_	O
(	O
"Sunday"	pointer
)	O
}	O
;	O
return	O
(	O
(	O
(	O
day	int
<	O
DAY_MIN	int
)	O
||	O
(	O
day	int
>	O
DAY_MAX	int
)	O
)	O
?	O
_	O
(	O
name	array
[	O
0	int
]	O
)	O
:	O
_	O
(	O
name	array
[	O
day	int
]	O
)	O
)	O
;	O
}	O
const	O
char	O
*	O
short_month_name	function
(	O
month	int
)	O
const	O
int	O
month	int
;	O
{	O
static	O
const	O
char	O
*	O
name	array
[	O
]	O
=	O
{	O
N_	O
(	O
"invalid month"	pointer
)	O
,	O
N_	O
(	O
"Jan"	pointer
)	O
,	O
N_	O
(	O
"Feb"	pointer
)	O
,	O
N_	O
(	O
"Mar"	pointer
)	O
,	O
N_	O
(	O
"Apr"	pointer
)	O
,	O
N_	O
(	O
"May"	pointer
)	O
,	O
N_	O
(	O
"Jun"	pointer
)	O
,	O
N_	O
(	O
"Jul"	pointer
)	O
,	O
N_	O
(	O
"Aug"	pointer
)	O
,	O
N_	O
(	O
"Sep"	pointer
)	O
,	O
N_	O
(	O
"Oct"	pointer
)	O
,	O
N_	O
(	O
"Nov"	pointer
)	O
,	O
N_	O
(	O
"Dec"	pointer
)	O
}	O
;	O
return	O
(	O
(	O
(	O
month	int
<	O
MONTH_MIN	int
)	O
||	O
(	O
month	int
>	O
MONTH_MAX	int
)	O
)	O
?	O
_	O
(	O
name	array
[	O
0	int
]	O
)	O
:	O
_	O
(	O
name	array
[	O
month	int
]	O
)	O
)	O
;	O
}	O
const	O
char	O
*	O
month_name	function
(	O
month	int
)	O
const	O
int	O
month	int
;	O
{	O
static	O
char	O
*	O
name	array
[	O
]	O
=	O
{	O
N_	O
(	O
"invalid month"	pointer
)	O
,	O
N_	O
(	O
"January"	pointer
)	O
,	O
N_	O
(	O
"February"	pointer
)	O
,	O
N_	O
(	O
"March"	pointer
)	O
,	O
N_	O
(	O
"April"	pointer
)	O
,	O
N_	O
(	O
"May "	pointer
)	O
,	O
N_	O
(	O
"June"	pointer
)	O
,	O
N_	O
(	O
"July"	pointer
)	O
,	O
N_	O
(	O
"August"	pointer
)	O
,	O
N_	O
(	O
"September"	pointer
)	O
,	O
N_	O
(	O
"October"	pointer
)	O
,	O
N_	O
(	O
"November"	pointer
)	O
,	O
N_	O
(	O
"December"	pointer
)	O
}	O
;	O
if	O
(	O
month	int
==	O
5	int
)	O
{	O
static	O
char	O
*	O
mayname	pointer
;	O
static	O
Bool	int
is_initialized	int
=	O
FALSE	O
;	O
if	O
(	O
!	O
is_initialized	int
)	O
{	O
register	O
int	O
len	int
;	O
auto	O
char	O
*	O
s	pointer
=	O
_	O
(	O
name	array
[	O
month	int
]	O
)	O
;	O
len	int
=	O
(	O
int	O
)	O
strlen	function
(	O
s	pointer
)	O
-	O
1	int
;	O
mayname	pointer
=	O
(	O
char	O
*	O
)	O
my_malloc	function
(	O
len	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"mayname"	pointer
,	O
0	int
)	O
;	O
strcpy	function
(	O
mayname	pointer
,	O
s	pointer
)	O
;	O
while	O
(	O
*	O
(	O
mayname	pointer
+	O
len	int
)	O
==	O
' '	O
)	O
*	O
(	O
mayname	pointer
+	O
len	int
--	O
)	O
=	O
'\0'	O
;	O
is_initialized	int
=	O
TRUE	O
;	O
}	O
return	O
(	O
mayname	pointer
)	O
;	O
}	O
return	O
(	O
(	O
(	O
month	int
<	O
MONTH_MIN	int
)	O
||	O
(	O
month	int
>	O
MONTH_MAX	int
)	O
)	O
?	O
_	O
(	O
name	array
[	O
0	int
]	O
)	O
:	O
_	O
(	O
name	array
[	O
month	int
]	O
)	O
)	O
;	O
}	O
Ulint	long
date2num	function
(	O
day	int
,	O
month	int
,	O
year	int
)	O
const	O
int	O
day	int
;	O
const	O
int	O
month	int
;	O
const	O
int	O
year	int
;	O
{	O
auto	O
Ulint	long
mjd	long
=	O
(	O
Ulint	long
)	O
(	O
(	O
year	int
-	O
1	int
)	O
*	O
(	O
Ulint	long
)	O
(	O
DAY_LAST	int
)	O
+	O
(	O
(	O
year	int
-	O
1	int
)	O
>>	O
2	int
)	O
)	O
;	O
if	O
(	O
year	int
>	O
greg	pointer
->	O
year	int
||	O
(	O
(	O
year	int
==	O
greg	pointer
->	O
year	int
)	O
&&	O
(	O
month	int
>	O
greg	pointer
->	O
month	int
||	O
(	O
(	O
month	int
==	O
greg	pointer
->	O
month	int
)	O
&&	O
(	O
day	int
>	O
greg	pointer
->	O
last_day	int
)	O
)	O
)	O
)	O
)	O
mjd	long
-=	O
(	O
Ulint	long
)	O
(	O
greg	pointer
->	O
last_day	int
-	O
greg	pointer
->	O
first_day	int
+	O
1	int
)	O
;	O
if	O
(	O
year	int
>	O
greg	pointer
->	O
year	int
)	O
{	O
mjd	long
+=	O
(	O
(	O
(	O
year	int
-	O
1	int
)	O
/	O
400	int
)	O
-	O
(	O
greg	pointer
->	O
year	int
/	O
400	int
)	O
)	O
;	O
mjd	long
-=	O
(	O
(	O
(	O
year	int
-	O
1	int
)	O
/	O
100	int
)	O
-	O
(	O
greg	pointer
->	O
year	int
/	O
100	int
)	O
)	O
;	O
if	O
(	O
!	O
(	O
greg	pointer
->	O
year	int
%	O
100	int
)	O
&&	O
(	O
greg	pointer
->	O
year	int
%	O
400	int
)	O
)	O
mjd	long
--	O
;	O
}	O
mjd	long
+=	O
(	O
Ulint	long
)	O
mvec	array
[	O
month	int
-	O
1	int
]	O
;	O
mjd	long
+=	O
day	int
;	O
if	O
(	O
(	O
days_of_february	function
(	O
year	int
)	O
==	O
29	int
)	O
&&	O
(	O
month	int
>	O
2	int
)	O
)	O
mjd	long
++	O
;	O
return	O
(	O
mjd	long
)	O
;	O
}	O
void	O
num2date	function
(	O
mjd	long
,	O
day	int
,	O
month	int
,	O
year	int
)	O
Ulint	long
mjd	long
;	O
int	O
*	O
day	int
;	O
int	O
*	O
month	int
;	O
int	O
*	O
year	int
;	O
{	O
auto	O
double	O
x	double
;	O
auto	O
Ulint	long
jdays	long
=	O
date2num	function
(	O
greg	pointer
->	O
first_day	int
-	O
1	int
,	O
greg	pointer
->	O
month	int
,	O
greg	pointer
->	O
year	int
)	O
;	O
register	O
int	O
i	int
;	O
if	O
(	O
mjd	long
>	O
jdays	long
)	O
mjd	long
+=	O
(	O
Ulint	long
)	O
(	O
greg	pointer
->	O
last_day	int
-	O
greg	pointer
->	O
first_day	int
+	O
1	int
)	O
;	O
x	double
=	O
(	O
double	O
)	O
mjd	long
/	O
(	O
DAY_LAST	int
+	O
0.25	int
)	O
;	O
i	int
=	O
(	O
int	O
)	O
x	double
;	O
if	O
(	O
(	O
double	O
)	O
i	int
!=	O
x	double
)	O
*	O
year	int
=	O
i	int
+	O
1	int
;	O
else	O
{	O
*	O
year	int
=	O
i	int
;	O
i	int
--	O
;	O
}	O
if	O
(	O
mjd	long
>	O
jdays	long
)	O
{	O
mjd	long
-=	O
(	O
Ulint	long
)	O
(	O
(	O
*	O
year	int
/	O
400	int
)	O
-	O
(	O
greg	pointer
->	O
year	int
/	O
400	int
)	O
)	O
;	O
mjd	long
+=	O
(	O
Ulint	long
)	O
(	O
(	O
*	O
year	int
/	O
100	int
)	O
-	O
(	O
greg	pointer
->	O
year	int
/	O
100	int
)	O
)	O
;	O
x	double
=	O
(	O
double	O
)	O
mjd	long
/	O
(	O
DAY_LAST	int
+	O
0.25	int
)	O
;	O
i	int
=	O
(	O
int	O
)	O
x	double
;	O
if	O
(	O
(	O
double	O
)	O
i	int
!=	O
x	double
)	O
*	O
year	int
=	O
i	int
+	O
1	int
;	O
else	O
{	O
*	O
year	int
=	O
i	int
;	O
i	int
--	O
;	O
}	O
if	O
(	O
(	O
*	O
year	int
%	O
400	int
)	O
&&	O
!	O
(	O
*	O
year	int
%	O
100	int
)	O
)	O
mjd	long
--	O
;	O
}	O
i	int
=	O
(	O
int	O
)	O
(	O
mjd	long
-	O
(	O
Ulint	long
)	O
(	O
i	int
*	O
(	O
DAY_LAST	int
+	O
0.25	int
)	O
)	O
)	O
;	O
if	O
(	O
(	O
*	O
year	int
>	O
greg	pointer
->	O
year	int
)	O
&&	O
(	O
*	O
year	int
%	O
400	int
)	O
&&	O
!	O
(	O
*	O
year	int
%	O
100	int
)	O
&&	O
(	O
i	int
<	O
(	O
(	O
*	O
year	int
/	O
100	int
)	O
-	O
(	O
greg	pointer
->	O
year	int
/	O
100	int
)	O
)	O
-	O
(	O
(	O
*	O
year	int
/	O
400	int
)	O
-	O
(	O
greg	pointer
->	O
year	int
/	O
400	int
)	O
)	O
)	O
)	O
i	int
++	O
;	O
(	O
void	O
)	O
doy2date	function
(	O
i	int
,	O
(	O
days_of_february	function
(	O
*	O
year	int
)	O
==	O
29	int
)	O
,	O
day	int
,	O
month	int
)	O
;	O
}	O
Bool	int
doy2date	function
(	O
doy	pointer
,	O
is_leap_year	int
,	O
day	int
,	O
month	int
)	O
int	O
doy	pointer
;	O
const	O
int	O
is_leap_year	int
;	O
int	O
*	O
day	int
;	O
int	O
*	O
month	int
;	O
{	O
register	O
int	O
i	int
;	O
auto	O
Bool	int
decrement_date	int
;	O
if	O
(	O
doy	pointer
>	O
DAY_LAST	int
+	O
is_leap_year	int
||	O
doy	pointer
<	O
DAY_MIN	int
)	O
return	O
(	O
FALSE	O
)	O
;	O
decrement_date	int
=	O
(	O
Bool	int
)	O
(	O
is_leap_year	int
&&	O
(	O
doy	pointer
>	O
mvec	array
[	O
2	int
]	O
)	O
)	O
;	O
if	O
(	O
decrement_date	int
)	O
doy	pointer
--	O
;	O
for	O
(	O
i	int
=	O
MONTH_MIN	int
;	O
i	int
<	O
MONTH_MAX	int
;	O
i	int
++	O
)	O
{	O
doy	pointer
-=	O
dvec	array
[	O
i	int
-	O
1	int
]	O
;	O
if	O
(	O
doy	pointer
<=	O
0	int
)	O
{	O
doy	pointer
+=	O
dvec	array
[	O
i	int
-	O
1	int
]	O
;	O
break	O
;	O
}	O
}	O
*	O
month	int
=	O
i	int
;	O
*	O
day	int
=	O
doy	pointer
;	O
if	O
(	O
decrement_date	int
&&	O
(	O
*	O
month	int
==	O
2	int
)	O
&&	O
(	O
*	O
day	int
==	O
28	int
)	O
)	O
(	O
*	O
day	int
)	O
++	O
;	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
int	O
weekday_of_date	function
(	O
day	int
,	O
month	int
,	O
year	int
)	O
const	O
int	O
day	int
;	O
const	O
int	O
month	int
;	O
const	O
int	O
year	int
;	O
{	O
auto	O
Ulint	long
mjd	long
=	O
date2num	function
(	O
day	int
,	O
month	int
,	O
year	int
)	O
%	O
DAY_MAX	int
;	O
return	O
(	O
(	O
mjd	long
>	O
2	int
)	O
?	O
(	O
int	O
)	O
mjd	long
-	O
2	int
:	O
(	O
int	O
)	O
mjd	long
+	O
5	int
)	O
;	O
}	O
int	O
day_of_year	function
(	O
day	int
,	O
month	int
,	O
year	int
)	O
const	O
int	O
day	int
;	O
const	O
int	O
month	int
;	O
const	O
int	O
year	int
;	O
{	O
register	O
int	O
i	int
;	O
if	O
(	O
month	int
<	O
3	int
)	O
i	int
=	O
mvec	array
[	O
month	int
-	O
1	int
]	O
+	O
day	int
;	O
else	O
i	int
=	O
mvec	array
[	O
month	int
-	O
1	int
]	O
+	O
day	int
+	O
(	O
days_of_february	function
(	O
year	int
)	O
==	O
29	int
)	O
;	O
return	O
(	O
i	int
)	O
;	O
}	O
int	O
days_of_february	function
(	O
year	int
)	O
const	O
int	O
year	int
;	O
{	O
register	O
int	O
day	int
;	O
if	O
(	O
(	O
year	int
>	O
greg	pointer
->	O
year	int
)	O
||	O
(	O
(	O
year	int
==	O
greg	pointer
->	O
year	int
)	O
&&	O
(	O
greg	pointer
->	O
month	int
==	O
1	int
||	O
(	O
(	O
greg	pointer
->	O
month	int
==	O
2	int
)	O
&&	O
(	O
greg	pointer
->	O
last_day	int
>=	O
28	int
)	O
)	O
)	O
)	O
)	O
{	O
if	O
(	O
orthodox_calendar	int
)	O
day	int
=	O
(	O
year	int
&	O
3	int
)	O
?	O
28	int
:	O
(	O
(	O
!	O
(	O
year	int
%	O
100	int
)	O
)	O
?	O
(	O
(	O
(	O
year	int
%	O
9	int
)	O
==	O
2	int
||	O
(	O
year	int
%	O
9	int
)	O
==	O
6	int
)	O
?	O
29	int
:	O
28	int
)	O
:	O
29	int
)	O
;	O
else	O
day	int
=	O
(	O
year	int
&	O
3	int
)	O
?	O
28	int
:	O
(	O
(	O
!	O
(	O
year	int
%	O
100	int
)	O
&&	O
(	O
year	int
%	O
400	int
)	O
)	O
?	O
28	int
:	O
29	int
)	O
;	O
}	O
else	O
day	int
=	O
(	O
year	int
&	O
3	int
)	O
?	O
28	int
:	O
29	int
;	O
if	O
(	O
year	int
==	O
4	int
)	O
day	int
--	O
;	O
return	O
(	O
day	int
)	O
;	O
}	O
Bool	int
valid_date	function
(	O
day	int
,	O
month	int
,	O
year	int
)	O
const	O
int	O
day	int
;	O
const	O
int	O
month	int
;	O
const	O
int	O
year	int
;	O
{	O
if	O
(	O
day	int
<	O
0	int
||	O
month	int
<	O
MONTH_MIN	int
||	O
month	int
>	O
MONTH_MAX	int
||	O
(	O
(	O
month	int
!=	O
2	int
)	O
&&	O
(	O
day	int
>	O
dvec	array
[	O
month	int
-	O
1	int
]	O
)	O
)	O
||	O
(	O
(	O
month	int
==	O
2	int
)	O
&&	O
(	O
day	int
>	O
days_of_february	function
(	O
year	int
)	O
)	O
)	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
Bool	int
prev_date	function
(	O
day	int
,	O
month	int
,	O
year	int
)	O
int	O
*	O
day	int
;	O
int	O
*	O
month	int
;	O
int	O
*	O
year	int
;	O
{	O
auto	O
Bool	int
no_missing_date	int
=	O
TRUE	O
;	O
if	O
(	O
(	O
*	O
day	int
<=	O
greg	pointer
->	O
last_day	int
+	O
1	int
)	O
&&	O
(	O
*	O
day	int
>=	O
greg	pointer
->	O
first_day	int
)	O
&&	O
(	O
*	O
month	int
==	O
greg	pointer
->	O
month	int
)	O
&&	O
(	O
*	O
year	int
==	O
greg	pointer
->	O
year	int
)	O
)	O
{	O
no_missing_date	int
=	O
FALSE	O
;	O
*	O
day	int
=	O
greg	pointer
->	O
first_day	int
-	O
1	int
;	O
}	O
else	O
{	O
(	O
*	O
day	int
)	O
--	O
;	O
if	O
(	O
!	O
*	O
day	int
||	O
!	O
valid_date	function
(	O
*	O
day	int
,	O
*	O
month	int
,	O
*	O
year	int
)	O
)	O
{	O
(	O
*	O
month	int
)	O
--	O
;	O
if	O
(	O
*	O
month	int
<	O
MONTH_MIN	int
)	O
{	O
*	O
month	int
=	O
MONTH_MAX	int
;	O
(	O
*	O
year	int
)	O
--	O
;	O
}	O
if	O
(	O
*	O
month	int
==	O
2	int
)	O
*	O
day	int
=	O
days_of_february	function
(	O
*	O
year	int
)	O
;	O
else	O
*	O
day	int
=	O
dvec	array
[	O
*	O
month	int
-	O
1	int
]	O
;	O
}	O
}	O
return	O
(	O
no_missing_date	int
)	O
;	O
}	O
Bool	int
next_date	function
(	O
day	int
,	O
month	int
,	O
year	int
)	O
int	O
*	O
day	int
;	O
int	O
*	O
month	int
;	O
int	O
*	O
year	int
;	O
{	O
auto	O
Bool	int
no_missing_date	int
=	O
TRUE	O
;	O
if	O
(	O
(	O
*	O
day	int
>=	O
greg	pointer
->	O
first_day	int
-	O
1	int
)	O
&&	O
(	O
*	O
day	int
<=	O
greg	pointer
->	O
last_day	int
)	O
&&	O
(	O
*	O
month	int
==	O
greg	pointer
->	O
month	int
)	O
&&	O
(	O
*	O
year	int
==	O
greg	pointer
->	O
year	int
)	O
)	O
{	O
no_missing_date	int
=	O
FALSE	O
;	O
*	O
day	int
=	O
greg	pointer
->	O
last_day	int
+	O
1	int
;	O
}	O
else	O
{	O
(	O
*	O
day	int
)	O
++	O
;	O
if	O
(	O
!	O
valid_date	function
(	O
*	O
day	int
,	O
*	O
month	int
,	O
*	O
year	int
)	O
)	O
{	O
*	O
day	int
=	O
DAY_MIN	int
;	O
if	O
(	O
*	O
month	int
==	O
MONTH_MAX	int
)	O
{	O
*	O
month	int
=	O
MONTH_MIN	int
;	O
(	O
*	O
year	int
)	O
++	O
;	O
}	O
else	O
(	O
*	O
month	int
)	O
++	O
;	O
}	O
}	O
return	O
(	O
no_missing_date	int
)	O
;	O
}	O
int	O
week_number	function
(	O
day	int
,	O
month	int
,	O
year	int
,	O
is_iso_week	int
,	O
start_day_of_week	int
)	O
const	O
int	O
day	int
;	O
const	O
int	O
month	int
;	O
const	O
int	O
year	int
;	O
const	O
Bool	int
is_iso_week	int
;	O
const	O
int	O
start_day_of_week	int
;	O
{	O
register	O
int	O
i	int
=	O
raw_week_number	function
(	O
day	int
,	O
month	int
,	O
year	int
,	O
is_iso_week	int
,	O
start_day_of_week	int
)	O
;	O
register	O
int	O
j	int
;	O
register	O
int	O
wmax	int
=	O
WEEK_MAX	int
;	O
if	O
(	O
(	O
i	int
>	O
1	int
)	O
&&	O
(	O
year	int
==	O
greg	pointer
->	O
year	int
)	O
)	O
wmax	int
=	O
(	O
(	O
DAY_LAST	int
+	O
(	O
days_of_february	function
(	O
greg	pointer
->	O
year	int
)	O
==	O
29	int
)	O
-	O
(	O
greg	pointer
->	O
last_day	int
-	O
greg	pointer
->	O
first_day	int
+	O
1	int
)	O
)	O
/	O
DAY_MAX	int
)	O
+	O
1	int
;	O
if	O
(	O
i	int
>=	O
wmax	int
)	O
{	O
if	O
(	O
month	int
==	O
MONTH_MIN	int
)	O
{	O
j	int
=	O
raw_week_number	function
(	O
dvec	array
[	O
MONTH_MAX	int
-	O
1	int
]	O
,	O
MONTH_MAX	int
,	O
year	int
-	O
1	int
,	O
is_iso_week	int
,	O
start_day_of_week	int
)	O
;	O
if	O
(	O
i	int
==	O
j	int
)	O
i	int
=	O
-	O
i	int
;	O
else	O
i	int
=	O
0	int
;	O
}	O
else	O
{	O
j	int
=	O
raw_week_number	function
(	O
DAY_MIN	int
,	O
MONTH_MIN	int
,	O
year	int
+	O
1	int
,	O
is_iso_week	int
,	O
start_day_of_week	int
)	O
;	O
if	O
(	O
i	int
==	O
j	int
)	O
i	int
=	O
-	O
i	int
;	O
else	O
if	O
(	O
(	O
j	int
==	O
1	int
)	O
&&	O
(	O
i	int
==	O
wmax	int
+	O
1	int
)	O
)	O
i	int
=	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
i	int
==	O
1	int
)	O
{	O
if	O
(	O
(	O
is_iso_week	int
&&	O
(	O
weekday_of_date	function
(	O
DAY_MIN	int
,	O
MONTH_MIN	int
,	O
year	int
)	O
<=	O
4	int
)	O
)	O
||	O
(	O
!	O
is_iso_week	int
&&	O
(	O
weekday_of_date	function
(	O
DAY_MIN	int
,	O
MONTH_MIN	int
,	O
year	int
)	O
<=	O
start_day_of_week	int
)	O
)	O
)	O
{	O
j	int
=	O
raw_week_number	function
(	O
dvec	array
[	O
MONTH_MAX	int
-	O
1	int
]	O
,	O
MONTH_MAX	int
,	O
year	int
-	O
1	int
,	O
is_iso_week	int
,	O
start_day_of_week	int
)	O
;	O
if	O
(	O
year	int
-	O
1	int
==	O
greg	pointer
->	O
year	int
)	O
wmax	int
=	O
(	O
(	O
DAY_LAST	int
+	O
(	O
days_of_february	function
(	O
greg	pointer
->	O
year	int
)	O
==	O
29	int
)	O
-	O
(	O
greg	pointer
->	O
last_day	int
-	O
greg	pointer
->	O
first_day	int
+	O
1	int
)	O
)	O
/	O
DAY_MAX	int
)	O
+	O
1	int
;	O
if	O
(	O
j	int
!=	O
wmax	int
)	O
i	int
=	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
(	O
i	int
==	O
wmax	int
-	O
1	int
)	O
&&	O
(	O
month	int
==	O
MONTH_MIN	int
)	O
&&	O
(	O
year	int
==	O
greg	pointer
->	O
year	int
+	O
1	int
)	O
)	O
i	int
=	O
-	O
i	int
;	O
return	O
(	O
i	int
)	O
;	O
}	O
int	O
weekno2doy	function
(	O
week	int
,	O
year	int
,	O
is_iso_week	int
,	O
start_day_of_week	int
)	O
int	O
week	int
;	O
const	O
int	O
year	int
;	O
const	O
Bool	int
is_iso_week	int
;	O
const	O
int	O
start_day_of_week	int
;	O
{	O
register	O
int	O
wd	int
=	O
weekday_of_date	function
(	O
DAY_MIN	int
,	O
MONTH_MIN	int
,	O
year	int
)	O
;	O
register	O
int	O
ww	int
=	O
week_number	function
(	O
DAY_MIN	int
,	O
MONTH_MIN	int
,	O
year	int
,	O
is_iso_week	int
,	O
start_day_of_week	int
)	O
;	O
register	O
int	O
wm	int
=	O
week_number	function
(	O
dvec	array
[	O
MONTH_MAX	int
-	O
1	int
]	O
,	O
MONTH_MAX	int
,	O
year	int
,	O
is_iso_week	int
,	O
start_day_of_week	int
)	O
;	O
register	O
int	O
wmax	int
=	O
WEEK_MAX	int
;	O
register	O
int	O
i	int
=	O
DAY_MIN	int
;	O
if	O
(	O
wm	int
<	O
0	int
)	O
wm	int
=	O
-	O
wm	int
;	O
if	O
(	O
ww	int
==	O
-	O
(	O
wmax	int
-	O
1	int
)	O
||	O
year	int
==	O
greg	pointer
->	O
year	int
)	O
wmax	int
=	O
(	O
(	O
DAY_LAST	int
+	O
(	O
days_of_february	function
(	O
greg	pointer
->	O
year	int
)	O
==	O
29	int
)	O
-	O
(	O
greg	pointer
->	O
last_day	int
-	O
greg	pointer
->	O
first_day	int
+	O
1	int
)	O
)	O
/	O
DAY_MAX	int
)	O
+	O
1	int
;	O
if	O
(	O
ww	int
<	O
0	int
)	O
ww	int
=	O
-	O
ww	int
;	O
if	O
(	O
ww	int
>	O
1	int
)	O
i	int
+=	O
SDAY	O
(	O
DAY_MAX	int
-	O
wd	int
+	O
1	int
,	O
start_day_of_week	int
)	O
;	O
else	O
if	O
(	O
!	O
ww	int
)	O
i	int
-=	O
SDAY	O
(	O
wd	int
-	O
1	int
,	O
start_day_of_week	int
)	O
;	O
if	O
(	O
wm	int
&&	O
(	O
wm	int
!=	O
wmax	int
+	O
1	int
)	O
&&	O
(	O
week	int
==	O
wmax	int
+	O
1	int
)	O
)	O
return	O
(	O
-	O
WEEK_MAX	int
)	O
;	O
else	O
if	O
(	O
week	int
==	O
99	int
)	O
{	O
week	int
=	O
wm	int
;	O
if	O
(	O
!	O
wm	int
)	O
week	int
=	O
wmax	int
+	O
1	int
;	O
i	int
+=	O
(	O
(	O
(	O
week	int
-	O
1	int
)	O
*	O
DAY_MAX	int
)	O
)	O
;	O
}	O
else	O
{	O
i	int
+=	O
(	O
(	O
(	O
week	int
-	O
1	int
)	O
*	O
DAY_MAX	int
)	O
)	O
;	O
if	O
(	O
!	O
week	int
&&	O
(	O
i	int
<=	O
-	O
(	O
DAY_MAX	int
-	O
1	int
)	O
)	O
)	O
i	int
+=	O
DAY_MAX	int
;	O
}	O
if	O
(	O
year	int
==	O
greg	pointer
->	O
year	int
)	O
if	O
(	O
i	int
+	O
(	O
greg	pointer
->	O
last_day	int
-	O
greg	pointer
->	O
first_day	int
+	O
1	int
)	O
>	O
day_of_year	function
(	O
greg	pointer
->	O
last_day	int
,	O
greg	pointer
->	O
month	int
,	O
greg	pointer
->	O
year	int
)	O
)	O
i	int
+=	O
(	O
greg	pointer
->	O
last_day	int
-	O
greg	pointer
->	O
first_day	int
+	O
1	int
)	O
;	O
if	O
(	O
i	int
>	O
DAY_LAST	int
+	O
(	O
days_of_february	function
(	O
year	int
)	O
==	O
29	int
)	O
)	O
return	O
(	O
-	O
WEEK_MAX	int
)	O
;	O
return	O
(	O
i	int
)	O
;	O
}	O
int	O
knuth_easter_formula	function
(	O
year	int
)	O
const	O
int	O
year	int
;	O
{	O
auto	O
long	O
extra_days	long
;	O
register	O
int	O
golden_number	int
=	O
(	O
year	int
%	O
19	int
)	O
+	O
1	int
;	O
register	O
int	O
century	int
;	O
register	O
int	O
gregorian_correction	int
;	O
register	O
int	O
clavian_correction	int
;	O
register	O
int	O
epact	int
;	O
register	O
int	O
day	int
;	O
register	O
int	O
month	int
;	O
register	O
int	O
easter	int
;	O
auto	O
Bool	int
was_julian	int
=	O
FALSE	O
;	O
if	O
(	O
(	O
year	int
>	O
greg	pointer
->	O
year	int
)	O
||	O
(	O
(	O
year	int
==	O
greg	pointer
->	O
year	int
)	O
&&	O
(	O
greg	pointer
->	O
month	int
<	O
3	int
||	O
(	O
(	O
greg	pointer
->	O
month	int
==	O
3	int
)	O
&&	O
(	O
greg	pointer
->	O
last_day	int
<	O
22	int
)	O
)	O
)	O
)	O
)	O
{	O
LABEL_compute_gregorian	O
:	O
century	int
=	O
year	int
/	O
100	int
+	O
1	int
;	O
gregorian_correction	int
=	O
(	O
3	int
*	O
century	int
/	O
4	int
)	O
-	O
12	int
;	O
clavian_correction	int
=	O
(	O
(	O
8	int
*	O
century	int
+	O
5	int
)	O
/	O
25	int
)	O
-	O
5	int
;	O
extra_days	long
=	O
(	O
5L	int
*	O
year	int
/	O
4	int
)	O
-	O
gregorian_correction	int
-	O
10	int
;	O
epact	int
=	O
(	O
11	int
*	O
golden_number	int
+	O
20	int
+	O
clavian_correction	int
-	O
gregorian_correction	int
)	O
%	O
30	int
;	O
if	O
(	O
epact	int
<=	O
0	int
)	O
epact	int
+=	O
30	int
;	O
if	O
(	O
(	O
(	O
epact	int
==	O
25	int
)	O
&&	O
(	O
golden_number	int
>	O
11	int
)	O
)	O
||	O
epact	int
==	O
24	int
)	O
epact	int
++	O
;	O
}	O
else	O
{	O
was_julian	int
=	O
TRUE	O
;	O
extra_days	long
=	O
(	O
5L	int
*	O
year	int
)	O
/	O
4	int
;	O
epact	int
=	O
(	O
(	O
11	int
*	O
golden_number	int
-	O
4	int
)	O
%	O
30	int
)	O
+	O
1	int
;	O
}	O
day	int
=	O
44	int
-	O
epact	int
;	O
if	O
(	O
day	int
<	O
21	int
)	O
day	int
+=	O
30	int
;	O
day	int
+=	O
DAY_MAX	int
-	O
(	O
int	O
)	O
(	O
(	O
extra_days	long
+	O
day	int
)	O
%	O
DAY_MAX	int
)	O
;	O
if	O
(	O
day	int
>	O
MONTH_LAST	int
)	O
{	O
day	int
-=	O
MONTH_LAST	int
;	O
month	int
=	O
4	int
;	O
}	O
else	O
month	int
=	O
3	int
;	O
easter	int
=	O
day_of_year	function
(	O
day	int
,	O
month	int
,	O
year	int
)	O
;	O
if	O
(	O
was_julian	int
&&	O
(	O
year	int
==	O
greg	pointer
->	O
year	int
)	O
&&	O
(	O
greg	pointer
->	O
month	int
==	O
3	int
||	O
(	O
(	O
greg	pointer
->	O
month	int
==	O
4	int
)	O
&&	O
(	O
greg	pointer
->	O
last_day	int
<=	O
25	int
)	O
)	O
)	O
)	O
{	O
was_julian	int
=	O
FALSE	O
;	O
if	O
(	O
(	O
easter	int
>=	O
day_of_year	function
(	O
greg	pointer
->	O
first_day	int
,	O
greg	pointer
->	O
month	int
,	O
greg	pointer
->	O
year	int
)	O
)	O
&&	O
(	O
easter	int
<=	O
day_of_year	function
(	O
greg	pointer
->	O
last_day	int
,	O
greg	pointer
->	O
month	int
,	O
greg	pointer
->	O
year	int
)	O
)	O
)	O
goto	O
LABEL_compute_gregorian	O
;	O
}	O
return	O
(	O
easter	int
)	O
;	O
}	O
int	O
julian_gregorian_diff	function
(	O
day	int
,	O
month	int
,	O
year	int
)	O
const	O
int	O
day	int
;	O
const	O
int	O
month	int
;	O
const	O
int	O
year	int
;	O
{	O
auto	O
Ulint	long
mjd	long
=	O
(	O
Ulint	long
)	O
(	O
(	O
year	int
-	O
1	int
)	O
*	O
(	O
Ulint	long
)	O
(	O
DAY_LAST	int
)	O
+	O
(	O
(	O
year	int
-	O
1	int
)	O
>>	O
2	int
)	O
)	O
;	O
mjd	long
+=	O
(	O
Ulint	long
)	O
(	O
mvec	array
[	O
month	int
-	O
1	int
]	O
+	O
day	int
)	O
;	O
if	O
(	O
(	O
days_of_february	function
(	O
year	int
)	O
==	O
29	int
)	O
&&	O
(	O
month	int
>	O
2	int
)	O
)	O
mjd	long
++	O
;	O
return	O
(	O
(	O
int	O
)	O
(	O
mjd	long
-	O
date2num	function
(	O
day	int
,	O
month	int
,	O
year	int
)	O
)	O
)	O
;	O
}	O
static	O
void	O
gregorian2julian	function
(	O
day	int
,	O
month	int
,	O
year	int
)	O
int	O
*	O
day	int
;	O
int	O
*	O
month	int
;	O
int	O
*	O
year	int
;	O
{	O
if	O
(	O
*	O
year	int
<	O
greg	pointer
->	O
year	int
||	O
(	O
(	O
*	O
year	int
==	O
greg	pointer
->	O
year	int
)	O
&&	O
(	O
*	O
month	int
<	O
greg	pointer
->	O
month	int
||	O
(	O
(	O
*	O
month	int
==	O
greg	pointer
->	O
month	int
)	O
&&	O
(	O
*	O
day	int
<	O
greg	pointer
->	O
first_day	int
)	O
)	O
)	O
)	O
)	O
{	O
auto	O
Greg_struct	struct
tmp_greg	struct
;	O
auto	O
Ulint	long
mjd	long
;	O
register	O
int	O
diff	int
;	O
tmp_greg	struct
.	O
first_day	int
=	O
greg	pointer
->	O
first_day	int
;	O
tmp_greg	struct
.	O
last_day	int
=	O
greg	pointer
->	O
last_day	int
;	O
tmp_greg	struct
.	O
month	int
=	O
greg	pointer
->	O
month	int
;	O
tmp_greg	struct
.	O
year	int
=	O
greg	pointer
->	O
year	int
;	O
greg	pointer
->	O
first_day	int
=	O
5	int
;	O
greg	pointer
->	O
last_day	int
=	O
14	int
;	O
greg	pointer
->	O
month	int
=	O
10	int
;	O
greg	pointer
->	O
year	int
=	O
1582	int
;	O
mjd	long
=	O
date2num	function
(	O
*	O
day	int
,	O
*	O
month	int
,	O
*	O
year	int
)	O
;	O
diff	int
=	O
julian_gregorian_diff	function
(	O
*	O
day	int
,	O
*	O
month	int
,	O
*	O
year	int
)	O
;	O
num2date	function
(	O
mjd	long
-	O
diff	int
,	O
day	int
,	O
month	int
,	O
year	int
)	O
;	O
greg	pointer
->	O
year	int
=	O
tmp_greg	struct
.	O
year	int
;	O
greg	pointer
->	O
month	int
=	O
tmp_greg	struct
.	O
month	int
;	O
greg	pointer
->	O
last_day	int
=	O
tmp_greg	struct
.	O
last_day	int
;	O
greg	pointer
->	O
first_day	int
=	O
tmp_greg	struct
.	O
first_day	int
;	O
}	O
}	O
static	O
int	O
raw_week_number	function
(	O
day	int
,	O
month	int
,	O
year	int
,	O
is_iso_week	int
,	O
start_day_of_week	int
)	O
const	O
int	O
day	int
;	O
const	O
int	O
month	int
;	O
const	O
int	O
year	int
;	O
const	O
Bool	int
is_iso_week	int
;	O
const	O
int	O
start_day_of_week	int
;	O
{	O
register	O
int	O
jd	int
=	O
day_of_year	function
(	O
day	int
,	O
month	int
,	O
year	int
)	O
;	O
register	O
int	O
sd	int
=	O
weekday_of_date	function
(	O
DAY_MIN	int
,	O
MONTH_MIN	int
,	O
year	int
)	O
;	O
register	O
int	O
ww	int
;	O
if	O
(	O
(	O
year	int
==	O
greg	pointer
->	O
year	int
)	O
&&	O
(	O
month	int
>	O
greg	pointer
->	O
month	int
||	O
(	O
(	O
month	int
==	O
greg	pointer
->	O
month	int
)	O
&&	O
(	O
day	int
>	O
greg	pointer
->	O
last_day	int
)	O
)	O
)	O
)	O
jd	int
-=	O
(	O
greg	pointer
->	O
last_day	int
-	O
greg	pointer
->	O
first_day	int
+	O
1	int
)	O
;	O
if	O
(	O
is_iso_week	int
)	O
{	O
if	O
(	O
sd	int
>	O
4	int
)	O
jd	int
-=	O
(	O
(	O
DAY_MAX	int
-	O
sd	int
)	O
+	O
1	int
)	O
;	O
else	O
jd	int
+=	O
(	O
sd	int
-	O
1	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
sd	int
>	O
start_day_of_week	int
)	O
jd	int
-=	O
(	O
DAY_MAX	int
-	O
(	O
sd	int
-	O
start_day_of_week	int
)	O
)	O
;	O
else	O
jd	int
+=	O
(	O
sd	int
-	O
start_day_of_week	int
)	O
;	O
}	O
if	O
(	O
jd	int
>	O
0	int
)	O
ww	int
=	O
(	O
jd	int
-	O
1	int
)	O
/	O
DAY_MAX	int
+	O
1	int
;	O
else	O
ww	int
=	O
raw_week_number	function
(	O
dvec	array
[	O
MONTH_MAX	int
-	O
1	int
]	O
,	O
MONTH_MAX	int
,	O
year	int
-	O
1	int
,	O
is_iso_week	int
,	O
start_day_of_week	int
)	O
;	O
return	O
(	O
ww	int
)	O
;	O
}	O
static	O
const	O
char	O
*	O
dflt_day_name	function
(	O
day	int
)	O
const	O
int	O
day	int
;	O
{	O
static	O
const	O
char	O
*	O
name	array
[	O
]	O
=	O
{	O
"invalid day"	pointer
,	O
"Monday"	pointer
,	O
"Tuesday"	pointer
,	O
"Wednesday"	pointer
,	O
"Thursday"	pointer
,	O
"Friday"	pointer
,	O
"Saturday"	pointer
,	O
"Sunday"	pointer
}	O
;	O
return	O
(	O
(	O
(	O
day	int
<	O
DAY_MIN	int
)	O
||	O
(	O
day	int
>	O
DAY_MAX	int
)	O
)	O
?	O
name	array
[	O
0	int
]	O
:	O
name	array
[	O
day	int
]	O
)	O
;	O
}	O
static	O
const	O
char	O
*	O
dflt_month_name	function
(	O
month	int
)	O
const	O
int	O
month	int
;	O
{	O
static	O
const	O
char	O
*	O
name	array
[	O
]	O
=	O
{	O
"invalid month"	pointer
,	O
"January"	pointer
,	O
"February"	pointer
,	O
"March"	pointer
,	O
"April"	pointer
,	O
"May"	pointer
,	O
"June"	pointer
,	O
"July"	pointer
,	O
"August"	pointer
,	O
"September"	pointer
,	O
"October"	pointer
,	O
"November"	pointer
,	O
"December"	pointer
}	O
;	O
return	O
(	O
(	O
(	O
month	int
<	O
MONTH_MIN	int
)	O
||	O
(	O
month	int
>	O
MONTH_MAX	int
)	O
)	O
?	O
name	array
[	O
0	int
]	O
:	O
name	array
[	O
month	int
]	O
)	O
;	O
}	O
