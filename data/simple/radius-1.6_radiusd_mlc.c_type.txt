struct	O
mlc_dispatch	struct
{	O
char	O
*	O
name	pointer
;	O
mlc_collect_user_t	pointer
collect_user	pointer
;	O
mlc_collect_realm_t	pointer
collect_realm	pointer
;	O
mlc_close_t	pointer
close	pointer
;	O
mlc_enabled_t	pointer
enabled_p	pointer
;	O
}	O
;	O
static	O
grad_list_t	struct
*	O
mlc_dispatch_list	pointer
;	O
struct	O
mlc_dispatch	struct
*	O
mlc_disptab	pointer
;	O
void	O
mlc_register_method	function
(	O
char	O
*	O
name	pointer
,	O
mlc_collect_user_t	pointer
collect_user	pointer
,	O
mlc_collect_realm_t	pointer
collect_realm	pointer
,	O
mlc_close_t	pointer
close	pointer
,	O
mlc_enabled_t	pointer
enabled_p	pointer
)	O
{	O
struct	O
mlc_dispatch	struct
*	O
mp	pointer
=	O
grad_emalloc	function
(	O
sizeof	O
(	O
*	O
mp	pointer
)	O
)	O
;	O
mp	pointer
->	O
name	pointer
=	O
grad_estrdup	function
(	O
name	pointer
)	O
;	O
mp	pointer
->	O
collect_user	pointer
=	O
collect_user	pointer
;	O
mp	pointer
->	O
collect_realm	pointer
=	O
collect_realm	pointer
;	O
mp	pointer
->	O
close	pointer
=	O
close	pointer
;	O
mp	pointer
->	O
enabled_p	pointer
=	O
enabled_p	pointer
;	O
if	O
(	O
!	O
mlc_dispatch_list	pointer
)	O
mlc_dispatch_list	pointer
=	O
grad_list_create	function
(	O
)	O
;	O
grad_list_append	function
(	O
mlc_dispatch_list	pointer
,	O
mp	pointer
)	O
;	O
}	O
int	O
radius_mlc_enabled_p	function
(	O
)	O
{	O
return	O
mlc_disptab	pointer
?	O
mlc_disptab	pointer
->	O
enabled_p	pointer
(	O
)	O
:	O
0	int
;	O
}	O
int	O
radius_mlc_collect_user	function
(	O
char	O
*	O
name	pointer
,	O
radiusd_request_t	struct
*	O
request	pointer
,	O
grad_list_t	struct
*	O
*	O
sess_list	pointer
)	O
{	O
GRAD_DEBUG	O
(	O
20	int
,	O
"Entered"	pointer
)	O
;	O
return	O
mlc_disptab	pointer
->	O
collect_user	pointer
(	O
name	pointer
,	O
request	pointer
,	O
sess_list	pointer
)	O
;	O
}	O
int	O
radius_mlc_collect_realm	function
(	O
radiusd_request_t	struct
*	O
request	pointer
,	O
grad_list_t	struct
*	O
*	O
sess_list	pointer
)	O
{	O
GRAD_DEBUG	O
(	O
20	int
,	O
"Entered"	pointer
)	O
;	O
return	O
mlc_disptab	pointer
->	O
collect_realm	pointer
(	O
request	pointer
,	O
sess_list	pointer
)	O
;	O
}	O
void	O
radius_mlc_close	function
(	O
struct	O
radutmp	struct
*	O
up	pointer
)	O
{	O
char	O
ipbuf	array
[	O
GRAD_IPV4_STRING_LENGTH	int
]	O
;	O
GRAD_DEBUG2	O
(	O
20	int
,	O
"Closing session: NAS %s port %d"	pointer
,	O
grad_ip_iptostr	function
(	O
ntohl	function
(	O
up	pointer
->	O
nas_address	int
)	O
,	O
ipbuf	array
)	O
,	O
up	pointer
->	O
nas_port	int
)	O
;	O
mlc_disptab	pointer
->	O
close	pointer
(	O
up	pointer
)	O
;	O
}	O
static	O
int	O
check_ts	function
(	O
struct	O
radutmp	struct
*	O
ut	pointer
)	O
{	O
grad_nas_t	struct
*	O
nas	int
;	O
if	O
(	O
(	O
nas	int
=	O
grad_nas_lookup_ip	function
(	O
ntohl	function
(	O
ut	pointer
->	O
nas_address	int
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
grad_log	function
(	O
GRAD_LOG_NOTICE	int
,	O
_	O
(	O
"check_ts(): unknown NAS"	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
strcmp	function
(	O
nas	int
->	O
nastype	array
,	O
"true"	pointer
)	O
==	O
0	int
)	O
return	O
1	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
nas	int
->	O
nastype	array
,	O
"false"	pointer
)	O
==	O
0	int
)	O
return	O
0	int
;	O
return	O
checkrad	function
(	O
nas	int
,	O
ut	pointer
)	O
;	O
}	O
static	O
int	O
rad_check_ts	function
(	O
struct	O
radutmp	struct
*	O
ut	pointer
)	O
{	O
int	O
result	pointer
;	O
switch	O
(	O
result	pointer
=	O
check_ts	function
(	O
ut	pointer
)	O
)	O
{	O
case	O
0	int
:	O
case	O
1	int
:	O
return	O
result	pointer
;	O
default	O
:	O
if	O
(	O
checkrad_assume_logged	int
)	O
grad_log	function
(	O
GRAD_LOG_NOTICE	int
,	O
_	O
(	O
"assuming `%s' is logged in"	pointer
)	O
,	O
ut	pointer
->	O
login	array
)	O
;	O
else	O
grad_log	function
(	O
GRAD_LOG_NOTICE	int
,	O
_	O
(	O
"assuming `%s' is NOT logged in"	pointer
)	O
,	O
ut	pointer
->	O
login	array
)	O
;	O
return	O
checkrad_assume_logged	int
;	O
}	O
}	O
static	O
int	O
utmp_free	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
ARG_UNUSED	O
)	O
{	O
grad_free	function
(	O
item	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
radius_mlc_user	function
(	O
char	O
*	O
name	pointer
,	O
radiusd_request_t	struct
*	O
request	pointer
,	O
size_t	long
maxsimul	long
,	O
size_t	long
*	O
pcount	pointer
)	O
{	O
void	O
*	O
mlc	pointer
;	O
struct	O
radutmp	struct
*	O
up	pointer
;	O
int	O
mpp	int
=	O
1	int
;	O
grad_list_t	struct
*	O
sess_list	pointer
=	O
NULL	O
;	O
size_t	long
count	int
;	O
GRAD_DEBUG2	O
(	O
1	int
,	O
"User %s, maxsimul %lu"	pointer
,	O
name	pointer
,	O
(	O
u_long	long
)	O
maxsimul	long
)	O
;	O
if	O
(	O
radius_mlc_collect_user	function
(	O
name	pointer
,	O
request	pointer
,	O
&	O
sess_list	pointer
)	O
)	O
{	O
GRAD_DEBUG	O
(	O
1	int
,	O
"radius_mlc_collect_user() failed"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
count	int
=	O
grad_list_count	function
(	O
sess_list	pointer
)	O
;	O
GRAD_DEBUG2	O
(	O
1	int
,	O
"Found %lu active sessions for user %s"	pointer
,	O
(	O
u_long	long
)	O
count	int
,	O
name	pointer
)	O
;	O
if	O
(	O
count	int
>=	O
maxsimul	long
)	O
{	O
grad_iterator_t	struct
*	O
itr	pointer
;	O
grad_uint32_t	int
ipno	int
=	O
0	int
;	O
grad_avp_t	struct
*	O
fra	pointer
=	O
grad_avl_find	function
(	O
request	pointer
->	O
request	pointer
->	O
avlist	pointer
,	O
DA_FRAMED_IP_ADDRESS	int
)	O
;	O
if	O
(	O
fra	pointer
)	O
ipno	int
=	O
htonl	function
(	O
fra	pointer
->	O
avp_lvalue	O
)	O
;	O
count	int
=	O
0	int
;	O
itr	pointer
=	O
grad_iterator_create	function
(	O
sess_list	pointer
)	O
;	O
for	O
(	O
up	pointer
=	O
grad_iterator_first	function
(	O
itr	pointer
)	O
;	O
up	pointer
;	O
up	pointer
=	O
grad_iterator_next	function
(	O
itr	pointer
)	O
)	O
{	O
if	O
(	O
rad_check_ts	function
(	O
up	pointer
)	O
==	O
1	int
)	O
{	O
count	int
++	O
;	O
if	O
(	O
ipno	int
&&	O
up	pointer
->	O
framed_address	int
==	O
ipno	int
)	O
switch	O
(	O
up	pointer
->	O
proto	int
)	O
{	O
case	O
DV_FRAMED_PROTOCOL_PPP	int
:	O
case	O
DV_FRAMED_PROTOCOL_SLIP	int
:	O
case	O
256	int
:	O
mpp	int
=	O
0	int
;	O
}	O
}	O
else	O
{	O
radius_mlc_close	function
(	O
up	pointer
)	O
;	O
}	O
}	O
grad_iterator_destroy	function
(	O
&	O
itr	pointer
)	O
;	O
}	O
grad_list_destroy	function
(	O
&	O
sess_list	pointer
,	O
utmp_free	function
,	O
NULL	O
)	O
;	O
GRAD_DEBUG1	O
(	O
1	int
,	O
"%lu sessions really active"	pointer
,	O
(	O
u_long	long
)	O
count	int
)	O
;	O
*	O
pcount	pointer
=	O
count	int
;	O
return	O
(	O
count	int
<	O
maxsimul	long
)	O
?	O
0	int
:	O
mpp	int
;	O
}	O
int	O
radius_mlc_realm	function
(	O
radiusd_request_t	struct
*	O
request	pointer
)	O
{	O
size_t	long
count	int
;	O
struct	O
radutmp	struct
*	O
up	pointer
;	O
radut_file_t	pointer
file	pointer
;	O
size_t	long
maxlogins	long
;	O
grad_list_t	struct
*	O
sess_list	pointer
=	O
NULL	O
;	O
grad_realm_t	struct
*	O
realm	array
=	O
request	pointer
->	O
realm	array
;	O
if	O
(	O
!	O
realm	array
||	O
(	O
maxlogins	long
=	O
grad_realm_get_quota	function
(	O
realm	array
)	O
)	O
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
radius_mlc_collect_realm	function
(	O
request	pointer
,	O
&	O
sess_list	pointer
)	O
)	O
{	O
GRAD_DEBUG	O
(	O
1	int
,	O
"radius_mlc_collect_realm() failed"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
count	int
=	O
grad_list_count	function
(	O
sess_list	pointer
)	O
;	O
GRAD_DEBUG2	O
(	O
1	int
,	O
"Found %lu active sessions for realm %s"	pointer
,	O
(	O
u_long	long
)	O
count	int
,	O
realm	array
->	O
realm	array
)	O
;	O
if	O
(	O
count	int
>=	O
maxlogins	long
)	O
{	O
grad_iterator_t	struct
*	O
itr	pointer
;	O
count	int
=	O
0	int
;	O
itr	pointer
=	O
grad_iterator_create	function
(	O
sess_list	pointer
)	O
;	O
for	O
(	O
up	pointer
=	O
grad_iterator_first	function
(	O
itr	pointer
)	O
;	O
up	pointer
;	O
up	pointer
=	O
grad_iterator_next	function
(	O
itr	pointer
)	O
)	O
{	O
if	O
(	O
rad_check_ts	function
(	O
up	pointer
)	O
==	O
1	int
)	O
count	int
++	O
;	O
else	O
radius_mlc_close	function
(	O
up	pointer
)	O
;	O
}	O
grad_iterator_destroy	function
(	O
&	O
itr	pointer
)	O
;	O
}	O
grad_list_destroy	function
(	O
&	O
sess_list	pointer
,	O
utmp_free	function
,	O
NULL	O
)	O
;	O
GRAD_DEBUG1	O
(	O
1	int
,	O
"%lu sessions really active"	pointer
,	O
(	O
u_long	long
)	O
count	int
)	O
;	O
return	O
count	int
>=	O
maxlogins	long
;	O
}	O
static	O
int	O
name_cmp	function
(	O
const	O
void	O
*	O
item	pointer
,	O
const	O
void	O
*	O
data	pointer
)	O
{	O
const	O
struct	O
mlc_dispatch	struct
*	O
mp	pointer
=	O
item	pointer
;	O
const	O
char	O
*	O
name	pointer
=	O
data	pointer
;	O
return	O
strcmp	function
(	O
mp	pointer
->	O
name	pointer
,	O
name	pointer
)	O
;	O
}	O
static	O
int	O
mlc_set_method	function
(	O
int	O
argc	int
,	O
cfg_value_t	struct
*	O
argv	pointer
,	O
void	O
*	O
block_data	pointer
,	O
void	O
*	O
handler_data	pointer
)	O
{	O
struct	O
mlc_dispatch	struct
*	O
mp	pointer
;	O
if	O
(	O
argc	int
!=	O
2	int
||	O
argv	pointer
[	O
1	int
]	O
.	O
type	int
!=	O
CFG_STRING	int
)	O
return	O
1	int
;	O
mp	pointer
=	O
grad_list_locate	function
(	O
mlc_dispatch_list	pointer
,	O
argv	pointer
[	O
1	int
]	O
.	O
v	union
.	O
string	pointer
,	O
name_cmp	function
)	O
;	O
if	O
(	O
mp	pointer
)	O
{	O
mlc_disptab	pointer
=	O
mp	pointer
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
struct	O
cfg_stmt	struct
mlc_stmt	array
[	O
]	O
=	O
{	O
{	O
"method"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
mlc_set_method	function
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"checkrad-assume-logged"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_boolean	function
,	O
&	O
checkrad_assume_logged	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
NULL	O
,	O
}	O
}	O
;	O
void	O
mlc_init	function
(	O
)	O
{	O
mlc_register_method	function
(	O
"system"	pointer
,	O
radutmp_mlc_collect_user	function
,	O
radutmp_mlc_collect_realm	function
,	O
radutmp_mlc_close	function
,	O
radutmp_mlc_enabled_p	function
)	O
;	O
mlc_disptab	pointer
=	O
grad_list_item	function
(	O
mlc_dispatch_list	pointer
,	O
0	int
)	O
;	O
grad_insist	O
(	O
mlc_disptab	pointer
!=	O
NULL	O
)	O
;	O
}	O
