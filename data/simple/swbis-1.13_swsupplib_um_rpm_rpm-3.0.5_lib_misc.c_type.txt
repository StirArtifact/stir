static	O
int	O
_debug	int
=	O
0	int
;	O
char	O
*	O
RPMVERSION	pointer
=	O
VERSION	pointer
;	O
char	O
*	O
rpm_stpcpy	function
(	O
dest	pointer
,	O
src	pointer
)	O
char	O
*	O
dest	pointer
;	O
const	O
char	O
*	O
src	pointer
;	O
{	O
register	O
char	O
*	O
d	pointer
=	O
dest	pointer
;	O
register	O
const	O
char	O
*	O
s	pointer
=	O
src	pointer
;	O
do	O
*	O
d	pointer
++	O
=	O
*	O
s	pointer
;	O
while	O
(	O
*	O
s	pointer
++	O
!=	O
'\0'	O
)	O
;	O
return	O
d	pointer
-	O
1	int
;	O
}	O
char	O
*	O
*	O
splitString	function
(	O
const	O
char	O
*	O
str	pointer
,	O
int	O
length	int
,	O
char	O
sep	char
)	O
{	O
const	O
char	O
*	O
source	enum
;	O
char	O
*	O
s	pointer
,	O
*	O
dest	pointer
;	O
char	O
*	O
*	O
list	pointer
;	O
int	O
i	int
;	O
int	O
fields	int
;	O
s	pointer
=	O
xmalloc	function
(	O
length	int
+	O
1	int
)	O
;	O
fields	int
=	O
1	int
;	O
for	O
(	O
source	enum
=	O
str	pointer
,	O
dest	pointer
=	O
s	pointer
,	O
i	int
=	O
0	int
;	O
i	int
<	O
length	int
;	O
i	int
++	O
,	O
source	enum
++	O
,	O
dest	pointer
++	O
)	O
{	O
*	O
dest	pointer
=	O
*	O
source	enum
;	O
if	O
(	O
*	O
dest	pointer
==	O
sep	char
)	O
fields	int
++	O
;	O
}	O
*	O
dest	pointer
=	O
'\0'	O
;	O
list	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
fields	int
+	O
1	int
)	O
)	O
;	O
dest	pointer
=	O
s	pointer
;	O
list	pointer
[	O
0	int
]	O
=	O
dest	pointer
;	O
i	int
=	O
1	int
;	O
while	O
(	O
i	int
<	O
fields	int
)	O
{	O
if	O
(	O
*	O
dest	pointer
==	O
sep	char
)	O
{	O
list	pointer
[	O
i	int
++	O
]	O
=	O
dest	pointer
+	O
1	int
;	O
*	O
dest	pointer
=	O
0	int
;	O
}	O
dest	pointer
++	O
;	O
}	O
list	pointer
[	O
i	int
]	O
=	O
NULL	O
;	O
return	O
list	pointer
;	O
}	O
int	O
headerNVR	function
(	O
Header	pointer
h	pointer
,	O
const	O
char	O
*	O
*	O
np	pointer
,	O
const	O
char	O
*	O
*	O
vp	pointer
,	O
const	O
char	O
*	O
*	O
rp	pointer
)	O
{	O
int	O
type	enum
,	O
count	long
;	O
if	O
(	O
np	pointer
&&	O
!	O
headerGetEntry	function
(	O
h	pointer
,	O
RPMTAG_NAME	int
,	O
&	O
type	enum
,	O
(	O
void	O
*	O
*	O
)	O
np	pointer
,	O
&	O
count	long
)	O
)	O
*	O
np	pointer
=	O
NULL	O
;	O
if	O
(	O
vp	pointer
&&	O
!	O
headerGetEntry	function
(	O
h	pointer
,	O
RPMTAG_VERSION	int
,	O
&	O
type	enum
,	O
(	O
void	O
*	O
*	O
)	O
vp	pointer
,	O
&	O
count	long
)	O
)	O
*	O
vp	pointer
=	O
NULL	O
;	O
if	O
(	O
rp	pointer
&&	O
!	O
headerGetEntry	function
(	O
h	pointer
,	O
RPMTAG_RELEASE	int
,	O
&	O
type	enum
,	O
(	O
void	O
*	O
*	O
)	O
rp	pointer
,	O
&	O
count	long
)	O
)	O
*	O
rp	pointer
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
void	O
freeSplitString	function
(	O
char	O
*	O
*	O
list	pointer
)	O
{	O
free	function
(	O
list	pointer
[	O
0	int
]	O
)	O
;	O
free	function
(	O
list	pointer
)	O
;	O
}	O
int	O
rpmfileexists	function
(	O
const	O
char	O
*	O
urlfn	pointer
)	O
{	O
const	O
char	O
*	O
fn	pointer
;	O
int	O
urltype	enum
=	O
urlPath	function
(	O
urlfn	pointer
,	O
&	O
fn	pointer
)	O
;	O
struct	O
stat	struct
buf	pointer
;	O
if	O
(	O
*	O
fn	pointer
==	O
'\0'	O
)	O
fn	pointer
=	O
"/"	pointer
;	O
switch	O
(	O
urltype	enum
)	O
{	O
case	O
URL_IS_FTP	int
:	O
case	O
URL_IS_HTTP	int
:	O
case	O
URL_IS_PATH	int
:	O
case	O
URL_IS_UNKNOWN	int
:	O
if	O
(	O
Stat	function
(	O
fn	pointer
,	O
&	O
buf	pointer
)	O
)	O
{	O
switch	O
(	O
errno	O
)	O
{	O
case	O
ENOENT	int
:	O
case	O
EINVAL	int
:	O
return	O
0	int
;	O
}	O
}	O
break	O
;	O
case	O
URL_IS_DASH	int
:	O
default	O
:	O
return	O
0	int
;	O
break	O
;	O
}	O
return	O
1	int
;	O
}	O
int	O
rpmvercmp	function
(	O
const	O
char	O
*	O
a	pointer
,	O
const	O
char	O
*	O
b	pointer
)	O
{	O
char	O
oldch1	char
,	O
oldch2	char
;	O
char	O
*	O
str1	pointer
,	O
*	O
str2	pointer
;	O
char	O
*	O
one	pointer
,	O
*	O
two	pointer
;	O
int	O
rc	int
;	O
int	O
isnum	int
;	O
if	O
(	O
!	O
strcmp	function
(	O
a	pointer
,	O
b	pointer
)	O
)	O
return	O
0	int
;	O
str1	pointer
=	O
alloca	function
(	O
strlen	function
(	O
a	pointer
)	O
+	O
1	int
)	O
;	O
str2	pointer
=	O
alloca	function
(	O
strlen	function
(	O
b	pointer
)	O
+	O
1	int
)	O
;	O
strcpy	function
(	O
str1	pointer
,	O
a	pointer
)	O
;	O
strcpy	function
(	O
str2	pointer
,	O
b	pointer
)	O
;	O
one	pointer
=	O
str1	pointer
;	O
two	pointer
=	O
str2	pointer
;	O
while	O
(	O
*	O
one	pointer
&&	O
*	O
two	pointer
)	O
{	O
while	O
(	O
*	O
one	pointer
&&	O
!	O
isalnum	function
(	O
*	O
one	pointer
)	O
)	O
one	pointer
++	O
;	O
while	O
(	O
*	O
two	pointer
&&	O
!	O
isalnum	function
(	O
*	O
two	pointer
)	O
)	O
two	pointer
++	O
;	O
str1	pointer
=	O
one	pointer
;	O
str2	pointer
=	O
two	pointer
;	O
if	O
(	O
isdigit	function
(	O
*	O
str1	pointer
)	O
)	O
{	O
while	O
(	O
*	O
str1	pointer
&&	O
isdigit	function
(	O
*	O
str1	pointer
)	O
)	O
str1	pointer
++	O
;	O
while	O
(	O
*	O
str2	pointer
&&	O
isdigit	function
(	O
*	O
str2	pointer
)	O
)	O
str2	pointer
++	O
;	O
isnum	int
=	O
1	int
;	O
}	O
else	O
{	O
while	O
(	O
*	O
str1	pointer
&&	O
isalpha	function
(	O
*	O
str1	pointer
)	O
)	O
str1	pointer
++	O
;	O
while	O
(	O
*	O
str2	pointer
&&	O
isalpha	function
(	O
*	O
str2	pointer
)	O
)	O
str2	pointer
++	O
;	O
isnum	int
=	O
0	int
;	O
}	O
oldch1	char
=	O
*	O
str1	pointer
;	O
*	O
str1	pointer
=	O
'\0'	O
;	O
oldch2	char
=	O
*	O
str2	pointer
;	O
*	O
str2	pointer
=	O
'\0'	O
;	O
if	O
(	O
one	pointer
==	O
str1	pointer
)	O
return	O
-	O
1	int
;	O
if	O
(	O
two	pointer
==	O
str2	pointer
)	O
return	O
-	O
1	int
;	O
if	O
(	O
isnum	int
)	O
{	O
while	O
(	O
*	O
one	pointer
==	O
'0'	O
)	O
one	pointer
++	O
;	O
while	O
(	O
*	O
two	pointer
==	O
'0'	O
)	O
two	pointer
++	O
;	O
if	O
(	O
strlen	function
(	O
one	pointer
)	O
>	O
strlen	function
(	O
two	pointer
)	O
)	O
return	O
1	int
;	O
if	O
(	O
strlen	function
(	O
two	pointer
)	O
>	O
strlen	function
(	O
one	pointer
)	O
)	O
return	O
-	O
1	int
;	O
}	O
rc	int
=	O
strcmp	function
(	O
one	pointer
,	O
two	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
*	O
str1	pointer
=	O
oldch1	char
;	O
one	pointer
=	O
str1	pointer
;	O
*	O
str2	pointer
=	O
oldch2	char
;	O
two	pointer
=	O
str2	pointer
;	O
}	O
if	O
(	O
(	O
!	O
*	O
one	pointer
)	O
&&	O
(	O
!	O
*	O
two	pointer
)	O
)	O
return	O
0	int
;	O
if	O
(	O
!	O
*	O
one	pointer
)	O
return	O
-	O
1	int
;	O
else	O
return	O
1	int
;	O
}	O
void	O
stripTrailingSlashes	function
(	O
char	O
*	O
str	pointer
)	O
{	O
char	O
*	O
chptr	pointer
;	O
chptr	pointer
=	O
str	pointer
+	O
strlen	function
(	O
str	pointer
)	O
-	O
1	int
;	O
while	O
(	O
*	O
chptr	pointer
==	O
'/'	O
&&	O
chptr	pointer
>=	O
str	pointer
)	O
{	O
*	O
chptr	pointer
=	O
'\0'	O
;	O
chptr	pointer
--	O
;	O
}	O
}	O
int	O
doputenv	function
(	O
const	O
char	O
*	O
str	pointer
)	O
{	O
char	O
*	O
a	pointer
;	O
a	pointer
=	O
xmalloc	function
(	O
strlen	function
(	O
str	pointer
)	O
+	O
1	int
)	O
;	O
strcpy	function
(	O
a	pointer
,	O
str	pointer
)	O
;	O
return	O
putenv	function
(	O
a	pointer
)	O
;	O
}	O
int	O
dosetenv	function
(	O
const	O
char	O
*	O
name	pointer
,	O
const	O
char	O
*	O
value	pointer
,	O
int	O
overwrite	int
)	O
{	O
int	O
i	int
;	O
char	O
*	O
a	pointer
;	O
if	O
(	O
!	O
overwrite	int
&&	O
getenv	function
(	O
name	pointer
)	O
)	O
return	O
0	int
;	O
i	int
=	O
strlen	function
(	O
name	pointer
)	O
+	O
strlen	function
(	O
value	pointer
)	O
+	O
2	int
;	O
a	pointer
=	O
xmalloc	function
(	O
i	int
)	O
;	O
if	O
(	O
!	O
a	pointer
)	O
return	O
1	int
;	O
strcpy	function
(	O
a	pointer
,	O
name	pointer
)	O
;	O
strcat	function
(	O
a	pointer
,	O
"="	pointer
)	O
;	O
strcat	function
(	O
a	pointer
,	O
value	pointer
)	O
;	O
return	O
putenv	function
(	O
a	pointer
)	O
;	O
}	O
int	O
unameToUid	function
(	O
const	O
char	O
*	O
thisUname	pointer
,	O
uid_t	int
*	O
uid	int
)	O
{	O
static	O
char	O
*	O
lastUname	pointer
=	O
NULL	O
;	O
static	O
int	O
lastUnameLen	int
=	O
0	int
;	O
static	O
int	O
lastUnameAlloced	int
;	O
static	O
uid_t	int
lastUid	int
;	O
struct	O
passwd	struct
*	O
pwent	pointer
;	O
int	O
thisUnameLen	int
;	O
if	O
(	O
!	O
thisUname	pointer
)	O
{	O
lastUnameLen	int
=	O
0	int
;	O
return	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
thisUname	pointer
,	O
"root"	pointer
)	O
)	O
{	O
*	O
uid	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
thisUnameLen	int
=	O
strlen	function
(	O
thisUname	pointer
)	O
;	O
if	O
(	O
!	O
lastUname	pointer
||	O
thisUnameLen	int
!=	O
lastUnameLen	int
||	O
strcmp	function
(	O
thisUname	pointer
,	O
lastUname	pointer
)	O
)	O
{	O
if	O
(	O
lastUnameAlloced	int
<	O
thisUnameLen	int
+	O
1	int
)	O
{	O
lastUnameAlloced	int
=	O
thisUnameLen	int
+	O
10	int
;	O
lastUname	pointer
=	O
xrealloc	function
(	O
lastUname	pointer
,	O
lastUnameAlloced	int
)	O
;	O
}	O
strcpy	function
(	O
lastUname	pointer
,	O
thisUname	pointer
)	O
;	O
pwent	pointer
=	O
getpwnam	function
(	O
thisUname	pointer
)	O
;	O
if	O
(	O
!	O
pwent	pointer
)	O
{	O
endpwent	function
(	O
)	O
;	O
pwent	pointer
=	O
getpwnam	function
(	O
thisUname	pointer
)	O
;	O
if	O
(	O
!	O
pwent	pointer
)	O
return	O
-	O
1	int
;	O
}	O
lastUid	int
=	O
pwent	pointer
->	O
pw_uid	int
;	O
}	O
*	O
uid	int
=	O
lastUid	int
;	O
return	O
0	int
;	O
}	O
int	O
gnameToGid	function
(	O
const	O
char	O
*	O
thisGname	pointer
,	O
gid_t	int
*	O
gid	int
)	O
{	O
static	O
char	O
*	O
lastGname	pointer
=	O
NULL	O
;	O
static	O
int	O
lastGnameLen	int
=	O
0	int
;	O
static	O
int	O
lastGnameAlloced	int
;	O
static	O
uid_t	int
lastGid	int
;	O
int	O
thisGnameLen	int
;	O
struct	O
group	struct
*	O
grent	pointer
;	O
if	O
(	O
!	O
thisGname	pointer
)	O
{	O
lastGnameLen	int
=	O
0	int
;	O
return	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
thisGname	pointer
,	O
"root"	pointer
)	O
)	O
{	O
*	O
gid	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
thisGnameLen	int
=	O
strlen	function
(	O
thisGname	pointer
)	O
;	O
if	O
(	O
!	O
lastGname	pointer
||	O
thisGnameLen	int
!=	O
lastGnameLen	int
||	O
strcmp	function
(	O
thisGname	pointer
,	O
lastGname	pointer
)	O
)	O
{	O
if	O
(	O
lastGnameAlloced	int
<	O
thisGnameLen	int
+	O
1	int
)	O
{	O
lastGnameAlloced	int
=	O
thisGnameLen	int
+	O
10	int
;	O
lastGname	pointer
=	O
xrealloc	function
(	O
lastGname	pointer
,	O
lastGnameAlloced	int
)	O
;	O
}	O
strcpy	function
(	O
lastGname	pointer
,	O
thisGname	pointer
)	O
;	O
grent	pointer
=	O
getgrnam	function
(	O
thisGname	pointer
)	O
;	O
if	O
(	O
!	O
grent	pointer
)	O
{	O
endgrent	function
(	O
)	O
;	O
grent	pointer
=	O
getgrnam	function
(	O
thisGname	pointer
)	O
;	O
if	O
(	O
!	O
grent	pointer
)	O
return	O
-	O
1	int
;	O
}	O
lastGid	int
=	O
grent	pointer
->	O
gr_gid	int
;	O
}	O
*	O
gid	int
=	O
lastGid	int
;	O
return	O
0	int
;	O
}	O
char	O
*	O
uidToUname	function
(	O
uid_t	int
uid	int
)	O
{	O
static	O
int	O
lastUid	int
=	O
-	O
1	int
;	O
static	O
char	O
*	O
lastUname	pointer
=	O
NULL	O
;	O
static	O
int	O
lastUnameLen	int
=	O
0	int
;	O
struct	O
passwd	struct
*	O
pwent	pointer
;	O
int	O
len	int
;	O
if	O
(	O
uid	int
==	O
(	O
uid_t	int
)	O
-	O
1	int
)	O
{	O
lastUid	int
=	O
-	O
1	int
;	O
return	O
NULL	O
;	O
}	O
else	O
if	O
(	O
!	O
uid	int
)	O
{	O
return	O
"root"	pointer
;	O
}	O
else	O
if	O
(	O
uid	int
==	O
lastUid	int
)	O
{	O
return	O
lastUname	pointer
;	O
}	O
else	O
{	O
pwent	pointer
=	O
getpwuid	function
(	O
uid	int
)	O
;	O
if	O
(	O
!	O
pwent	pointer
)	O
return	O
NULL	O
;	O
lastUid	int
=	O
uid	int
;	O
len	int
=	O
strlen	function
(	O
pwent	pointer
->	O
pw_name	pointer
)	O
;	O
if	O
(	O
lastUnameLen	int
<	O
len	int
+	O
1	int
)	O
{	O
lastUnameLen	int
=	O
len	int
+	O
20	int
;	O
lastUname	pointer
=	O
xrealloc	function
(	O
lastUname	pointer
,	O
lastUnameLen	int
)	O
;	O
}	O
strcpy	function
(	O
lastUname	pointer
,	O
pwent	pointer
->	O
pw_name	pointer
)	O
;	O
return	O
lastUname	pointer
;	O
}	O
}	O
char	O
*	O
gidToGname	function
(	O
gid_t	int
gid	int
)	O
{	O
static	O
int	O
lastGid	int
=	O
-	O
1	int
;	O
static	O
char	O
*	O
lastGname	pointer
=	O
NULL	O
;	O
static	O
int	O
lastGnameLen	int
=	O
0	int
;	O
struct	O
group	struct
*	O
grent	pointer
;	O
int	O
len	int
;	O
if	O
(	O
gid	int
==	O
(	O
gid_t	int
)	O
-	O
1	int
)	O
{	O
lastGid	int
=	O
-	O
1	int
;	O
return	O
NULL	O
;	O
}	O
else	O
if	O
(	O
!	O
gid	int
)	O
{	O
return	O
"root"	pointer
;	O
}	O
else	O
if	O
(	O
gid	int
==	O
lastGid	int
)	O
{	O
return	O
lastGname	pointer
;	O
}	O
else	O
{	O
grent	pointer
=	O
getgrgid	function
(	O
gid	int
)	O
;	O
if	O
(	O
!	O
grent	pointer
)	O
return	O
NULL	O
;	O
lastGid	int
=	O
gid	int
;	O
len	int
=	O
strlen	function
(	O
grent	pointer
->	O
gr_name	pointer
)	O
;	O
if	O
(	O
lastGnameLen	int
<	O
len	int
+	O
1	int
)	O
{	O
lastGnameLen	int
=	O
len	int
+	O
20	int
;	O
lastGname	pointer
=	O
xrealloc	function
(	O
lastGname	pointer
,	O
lastGnameLen	int
)	O
;	O
}	O
strcpy	function
(	O
lastGname	pointer
,	O
grent	pointer
->	O
gr_name	pointer
)	O
;	O
return	O
lastGname	pointer
;	O
}	O
}	O
int	O
makeTempFile	function
(	O
const	O
char	O
*	O
prefix	pointer
,	O
const	O
char	O
*	O
*	O
fnptr	pointer
,	O
FD_t	pointer
*	O
fdptr	pointer
)	O
{	O
const	O
char	O
*	O
tempfn	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
tfn	pointer
=	O
NULL	O
;	O
int	O
temput	int
;	O
FD_t	pointer
fd	pointer
=	O
NULL	O
;	O
int	O
ran	int
;	O
if	O
(	O
!	O
prefix	pointer
)	O
prefix	pointer
=	O
""	pointer
;	O
srand	function
(	O
time	struct
(	O
NULL	O
)	O
)	O
;	O
ran	int
=	O
rand	function
(	O
)	O
%	O
100000	int
;	O
do	O
{	O
char	O
tfnbuf	array
[	O
64	int
]	O
;	O
sprintf	function
(	O
tfnbuf	array
,	O
"rpm-tmp.%d"	pointer
,	O
ran	int
++	O
)	O
;	O
if	O
(	O
tempfn	pointer
)	O
xfree	O
(	O
tempfn	pointer
)	O
;	O
tempfn	pointer
=	O
rpmGenPath	function
(	O
prefix	pointer
,	O
"%{_tmppath}/"	pointer
,	O
tfnbuf	array
)	O
;	O
temput	int
=	O
urlPath	function
(	O
tempfn	pointer
,	O
&	O
tfn	pointer
)	O
;	O
if	O
(	O
*	O
tfn	pointer
==	O
'\0'	O
)	O
goto	O
errxit	O
;	O
switch	O
(	O
temput	int
)	O
{	O
case	O
URL_IS_HTTP	int
:	O
case	O
URL_IS_DASH	int
:	O
goto	O
errxit	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
fd	pointer
=	O
Fopen	function
(	O
tempfn	pointer
,	O
"w+x.ufdio"	pointer
)	O
;	O
}	O
while	O
(	O
(	O
fd	pointer
==	O
NULL	O
||	O
Ferror	function
(	O
fd	pointer
)	O
)	O
&&	O
errno	O
==	O
EEXIST	int
)	O
;	O
if	O
(	O
fd	pointer
==	O
NULL	O
||	O
Ferror	function
(	O
fd	pointer
)	O
)	O
goto	O
errxit	O
;	O
switch	O
(	O
temput	int
)	O
{	O
struct	O
stat	struct
sb	struct
,	O
sb2	struct
;	O
case	O
URL_IS_PATH	int
:	O
case	O
URL_IS_UNKNOWN	int
:	O
if	O
(	O
!	O
stat	struct
(	O
tfn	pointer
,	O
&	O
sb	struct
)	O
&&	O
S_ISLNK	O
(	O
sb	struct
.	O
st_mode	int
)	O
)	O
{	O
rpmError	function
(	O
RPMERR_SCRIPT	O
,	O
_	O
(	O
"error creating temporary file %s"	pointer
)	O
,	O
tfn	pointer
)	O
;	O
goto	O
errxit	O
;	O
}	O
if	O
(	O
sb	struct
.	O
st_nlink	long
!=	O
1	int
)	O
{	O
rpmError	function
(	O
RPMERR_SCRIPT	O
,	O
_	O
(	O
"error creating temporary file %s"	pointer
)	O
,	O
tfn	pointer
)	O
;	O
goto	O
errxit	O
;	O
}	O
if	O
(	O
fstat	function
(	O
Fileno	function
(	O
fd	pointer
)	O
,	O
&	O
sb2	struct
)	O
==	O
0	int
)	O
{	O
if	O
(	O
sb2	struct
.	O
st_ino	long
!=	O
sb	struct
.	O
st_ino	long
||	O
sb2	struct
.	O
st_dev	long
!=	O
sb	struct
.	O
st_dev	long
)	O
{	O
rpmError	function
(	O
RPMERR_SCRIPT	O
,	O
_	O
(	O
"error creating temporary file %s"	pointer
)	O
,	O
tfn	pointer
)	O
;	O
goto	O
errxit	O
;	O
}	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
fnptr	pointer
)	O
*	O
fnptr	pointer
=	O
tempfn	pointer
;	O
else	O
if	O
(	O
tempfn	pointer
)	O
{	O
xfree	O
(	O
tempfn	pointer
)	O
;	O
tempfn	pointer
=	O
NULL	O
;	O
}	O
*	O
fdptr	pointer
=	O
fd	pointer
;	O
return	O
0	int
;	O
errxit	O
:	O
if	O
(	O
tempfn	pointer
)	O
xfree	O
(	O
tempfn	pointer
)	O
;	O
if	O
(	O
fd	pointer
)	O
Fclose	function
(	O
fd	pointer
)	O
;	O
return	O
1	int
;	O
}	O
char	O
*	O
currentDirectory	function
(	O
void	O
)	O
{	O
int	O
currDirLen	int
;	O
char	O
*	O
currDir	pointer
;	O
currDirLen	int
=	O
50	int
;	O
currDir	pointer
=	O
xmalloc	function
(	O
currDirLen	int
)	O
;	O
while	O
(	O
!	O
getcwd	function
(	O
currDir	pointer
,	O
currDirLen	int
)	O
&&	O
errno	O
==	O
ERANGE	int
)	O
{	O
currDirLen	int
+=	O
50	int
;	O
currDir	pointer
=	O
xrealloc	function
(	O
currDir	pointer
,	O
currDirLen	int
)	O
;	O
}	O
return	O
currDir	pointer
;	O
}	O
int	O
_noDirTokens	int
=	O
1	int
;	O
static	O
int	O
dncmp	function
(	O
const	O
void	O
*	O
a	pointer
,	O
const	O
void	O
*	O
b	pointer
)	O
{	O
const	O
char	O
*	O
const	O
*	O
first	pointer
=	O
a	pointer
;	O
const	O
char	O
*	O
const	O
*	O
second	pointer
=	O
b	pointer
;	O
return	O
strcmp	function
(	O
*	O
first	pointer
,	O
*	O
second	pointer
)	O
;	O
}	O
void	O
compressFilelist	function
(	O
Header	pointer
h	pointer
)	O
{	O
char	O
*	O
*	O
fileNames	pointer
;	O
const	O
char	O
*	O
*	O
dirNames	pointer
;	O
const	O
char	O
*	O
*	O
baseNames	pointer
;	O
int_32	int
*	O
dirIndexes	pointer
;	O
int	O
count	long
;	O
int	O
i	int
;	O
int	O
dirIndex	int
=	O
-	O
1	int
;	O
if	O
(	O
!	O
headerGetEntry	function
(	O
h	pointer
,	O
RPMTAG_OLDFILENAMES	int
,	O
NULL	O
,	O
(	O
void	O
*	O
*	O
)	O
&	O
fileNames	pointer
,	O
&	O
count	long
)	O
)	O
return	O
;	O
dirNames	pointer
=	O
alloca	function
(	O
sizeof	O
(	O
*	O
dirNames	pointer
)	O
*	O
count	long
)	O
;	O
baseNames	pointer
=	O
alloca	function
(	O
sizeof	O
(	O
*	O
dirNames	pointer
)	O
*	O
count	long
)	O
;	O
dirIndexes	pointer
=	O
alloca	function
(	O
sizeof	O
(	O
*	O
dirIndexes	pointer
)	O
*	O
count	long
)	O
;	O
if	O
(	O
fileNames	pointer
[	O
0	int
]	O
[	O
0	int
]	O
!=	O
'/'	O
)	O
{	O
dirIndex	int
=	O
0	int
;	O
dirNames	pointer
[	O
dirIndex	int
]	O
=	O
""	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
count	long
;	O
i	int
++	O
)	O
{	O
dirIndexes	pointer
[	O
i	int
]	O
=	O
dirIndex	int
;	O
baseNames	pointer
[	O
i	int
]	O
=	O
fileNames	pointer
[	O
i	int
]	O
;	O
}	O
goto	O
exit	function
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
count	long
;	O
i	int
++	O
)	O
{	O
const	O
char	O
*	O
*	O
needle	pointer
;	O
char	O
*	O
baseName	pointer
=	O
strrchr	function
(	O
fileNames	pointer
[	O
i	int
]	O
,	O
'/'	O
)	O
+	O
1	int
;	O
char	O
savechar	char
;	O
int	O
len	int
=	O
baseName	pointer
-	O
fileNames	pointer
[	O
i	int
]	O
;	O
savechar	char
=	O
*	O
baseName	pointer
;	O
*	O
baseName	pointer
=	O
'\0'	O
;	O
if	O
(	O
dirIndex	int
<	O
0	int
||	O
(	O
needle	pointer
=	O
bsearch	function
(	O
&	O
fileNames	pointer
[	O
i	int
]	O
,	O
dirNames	pointer
,	O
dirIndex	int
+	O
1	int
,	O
sizeof	O
(	O
dirNames	pointer
[	O
0	int
]	O
)	O
,	O
dncmp	function
)	O
)	O
==	O
NULL	O
)	O
{	O
char	O
*	O
s	pointer
=	O
alloca	function
(	O
len	int
+	O
1	int
)	O
;	O
memcpy	function
(	O
s	pointer
,	O
fileNames	pointer
[	O
i	int
]	O
,	O
len	int
+	O
1	int
)	O
;	O
s	pointer
[	O
len	int
]	O
=	O
'\0'	O
;	O
dirIndexes	pointer
[	O
i	int
]	O
=	O
++	O
dirIndex	int
;	O
dirNames	pointer
[	O
dirIndex	int
]	O
=	O
s	pointer
;	O
}	O
else	O
dirIndexes	pointer
[	O
i	int
]	O
=	O
needle	pointer
-	O
dirNames	pointer
;	O
*	O
baseName	pointer
=	O
savechar	char
;	O
baseNames	pointer
[	O
i	int
]	O
=	O
baseName	pointer
;	O
}	O
exit	function
:	O
headerAddEntry	function
(	O
h	pointer
,	O
RPMTAG_DIRNAMES	int
,	O
RPM_STRING_ARRAY_TYPE	int
,	O
dirNames	pointer
,	O
dirIndex	int
+	O
1	int
)	O
;	O
headerAddEntry	function
(	O
h	pointer
,	O
RPMTAG_DIRINDEXES	int
,	O
RPM_INT32_TYPE	int
,	O
dirIndexes	pointer
,	O
count	long
)	O
;	O
headerAddEntry	function
(	O
h	pointer
,	O
RPMTAG_BASENAMES	int
,	O
RPM_STRING_ARRAY_TYPE	int
,	O
baseNames	pointer
,	O
count	long
)	O
;	O
xfree	O
(	O
fileNames	pointer
)	O
;	O
headerRemoveEntry	function
(	O
h	pointer
,	O
RPMTAG_OLDFILENAMES	int
)	O
;	O
}	O
static	O
void	O
doBuildFileList	function
(	O
Header	pointer
h	pointer
,	O
const	O
char	O
*	O
*	O
*	O
fileListPtr	pointer
,	O
int	O
*	O
fileCountPtr	pointer
,	O
int	O
baseNameTag	int
,	O
int	O
dirNameTag	int
,	O
int	O
dirIndexesTag	int
)	O
{	O
const	O
char	O
*	O
*	O
baseNames	pointer
;	O
const	O
char	O
*	O
*	O
dirNames	pointer
;	O
int	O
*	O
dirIndexes	pointer
;	O
int	O
count	long
;	O
const	O
char	O
*	O
*	O
fileNames	pointer
;	O
int	O
size	long
;	O
char	O
*	O
data	pointer
;	O
int	O
i	int
;	O
if	O
(	O
!	O
headerGetEntry	function
(	O
h	pointer
,	O
baseNameTag	int
,	O
NULL	O
,	O
(	O
void	O
*	O
*	O
)	O
&	O
baseNames	pointer
,	O
&	O
count	long
)	O
)	O
{	O
*	O
fileListPtr	pointer
=	O
NULL	O
;	O
*	O
fileCountPtr	pointer
=	O
0	int
;	O
return	O
;	O
}	O
headerGetEntry	function
(	O
h	pointer
,	O
dirNameTag	int
,	O
NULL	O
,	O
(	O
void	O
*	O
*	O
)	O
&	O
dirNames	pointer
,	O
NULL	O
)	O
;	O
headerGetEntry	function
(	O
h	pointer
,	O
dirIndexesTag	int
,	O
NULL	O
,	O
(	O
void	O
*	O
*	O
)	O
&	O
dirIndexes	pointer
,	O
&	O
count	long
)	O
;	O
size	long
=	O
sizeof	O
(	O
*	O
fileNames	pointer
)	O
*	O
count	long
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
count	long
;	O
i	int
++	O
)	O
size	long
+=	O
strlen	function
(	O
baseNames	pointer
[	O
i	int
]	O
)	O
+	O
strlen	function
(	O
dirNames	pointer
[	O
dirIndexes	pointer
[	O
i	int
]	O
]	O
)	O
+	O
1	int
;	O
fileNames	pointer
=	O
xmalloc	function
(	O
size	long
)	O
;	O
data	pointer
=	O
(	O
(	O
char	O
*	O
)	O
fileNames	pointer
)	O
+	O
(	O
sizeof	O
(	O
*	O
fileNames	pointer
)	O
*	O
count	long
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
count	long
;	O
i	int
++	O
)	O
{	O
fileNames	pointer
[	O
i	int
]	O
=	O
data	pointer
;	O
data	pointer
=	O
rpm_stpcpy	function
(	O
rpm_stpcpy	function
(	O
data	pointer
,	O
dirNames	pointer
[	O
dirIndexes	pointer
[	O
i	int
]	O
]	O
)	O
,	O
baseNames	pointer
[	O
i	int
]	O
)	O
;	O
*	O
data	pointer
++	O
=	O
'\0'	O
;	O
}	O
xfree	O
(	O
baseNames	pointer
)	O
;	O
xfree	O
(	O
dirNames	pointer
)	O
;	O
*	O
fileListPtr	pointer
=	O
fileNames	pointer
;	O
*	O
fileCountPtr	pointer
=	O
count	long
;	O
}	O
void	O
expandFilelist	function
(	O
Header	pointer
h	pointer
)	O
{	O
const	O
char	O
*	O
*	O
fileNames	pointer
=	O
NULL	O
;	O
int	O
count	long
=	O
0	int
;	O
doBuildFileList	function
(	O
h	pointer
,	O
&	O
fileNames	pointer
,	O
&	O
count	long
,	O
RPMTAG_BASENAMES	int
,	O
RPMTAG_DIRNAMES	int
,	O
RPMTAG_DIRINDEXES	int
)	O
;	O
if	O
(	O
fileNames	pointer
==	O
NULL	O
||	O
count	long
<=	O
0	int
)	O
return	O
;	O
headerAddEntry	function
(	O
h	pointer
,	O
RPMTAG_OLDFILENAMES	int
,	O
RPM_STRING_ARRAY_TYPE	int
,	O
fileNames	pointer
,	O
count	long
)	O
;	O
xfree	O
(	O
fileNames	pointer
)	O
;	O
headerRemoveEntry	function
(	O
h	pointer
,	O
RPMTAG_BASENAMES	int
)	O
;	O
headerRemoveEntry	function
(	O
h	pointer
,	O
RPMTAG_DIRNAMES	int
)	O
;	O
headerRemoveEntry	function
(	O
h	pointer
,	O
RPMTAG_DIRINDEXES	int
)	O
;	O
}	O
void	O
rpmBuildFileList	function
(	O
Header	pointer
h	pointer
,	O
const	O
char	O
*	O
*	O
*	O
fileListPtr	pointer
,	O
int	O
*	O
fileCountPtr	pointer
)	O
{	O
doBuildFileList	function
(	O
h	pointer
,	O
fileListPtr	pointer
,	O
fileCountPtr	pointer
,	O
RPMTAG_BASENAMES	int
,	O
RPMTAG_DIRNAMES	int
,	O
RPMTAG_DIRINDEXES	int
)	O
;	O
}	O
void	O
buildOrigFileList	function
(	O
Header	pointer
h	pointer
,	O
const	O
char	O
*	O
*	O
*	O
fileListPtr	pointer
,	O
int	O
*	O
fileCountPtr	pointer
)	O
{	O
doBuildFileList	function
(	O
h	pointer
,	O
fileListPtr	pointer
,	O
fileCountPtr	pointer
,	O
RPMTAG_ORIGBASENAMES	int
,	O
RPMTAG_ORIGDIRNAMES	int
,	O
RPMTAG_ORIGDIRINDEXES	int
)	O
;	O
}	O
int	O
myGlobPatternP	function
(	O
const	O
char	O
*	O
patternURL	pointer
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
char	O
c	int
;	O
int	O
open	function
=	O
0	int
;	O
(	O
void	O
)	O
urlPath	function
(	O
patternURL	pointer
,	O
&	O
p	pointer
)	O
;	O
while	O
(	O
(	O
c	int
=	O
*	O
p	pointer
++	O
)	O
!=	O
'\0'	O
)	O
switch	O
(	O
c	int
)	O
{	O
case	O
'?'	O
:	O
case	O
'*'	O
:	O
return	O
(	O
1	int
)	O
;	O
case	O
'['	O
:	O
open	function
++	O
;	O
continue	O
;	O
case	O
']'	O
:	O
if	O
(	O
open	function
)	O
return	O
(	O
1	int
)	O
;	O
continue	O
;	O
case	O
'\\'	O
:	O
if	O
(	O
*	O
p	pointer
++	O
==	O
'\0'	O
)	O
return	O
(	O
0	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
glob_error	function
(	O
const	O
char	O
*	O
foo	pointer
,	O
int	O
bar	int
)	O
{	O
return	O
1	int
;	O
}	O
int	O
rpmGlob	function
(	O
const	O
char	O
*	O
patterns	pointer
,	O
int	O
*	O
argcPtr	pointer
,	O
const	O
char	O
*	O
*	O
*	O
argvPtr	pointer
)	O
{	O
int	O
ac	int
=	O
0	int
;	O
const	O
char	O
*	O
*	O
av	pointer
=	O
NULL	O
;	O
int	O
argc	int
=	O
0	int
;	O
const	O
char	O
*	O
*	O
argv	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
path	pointer
;	O
const	O
char	O
*	O
globURL	pointer
;	O
char	O
*	O
globRoot	pointer
=	O
NULL	O
;	O
size_t	long
maxb	long
,	O
nb	long
;	O
glob_t	struct
gl	struct
;	O
int	O
ut	int
;	O
int	O
i	int
,	O
j	int
;	O
int	O
rc	int
;	O
fprintf	function
(	O
stderr	pointer
,	O
"fatal error in (rpm)misc.c:%d\n"	pointer
,	O
__LINE__	O
)	O
;	O
exit	function
(	O
223	int
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
ac	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
!	O
myGlobPatternP	function
(	O
av	pointer
[	O
j	int
]	O
)	O
)	O
{	O
if	O
(	O
argc	int
==	O
0	int
)	O
argv	pointer
=	O
xmalloc	function
(	O
(	O
argc	int
+	O
2	int
)	O
*	O
sizeof	O
(	O
*	O
argv	pointer
)	O
)	O
;	O
else	O
argv	pointer
=	O
xrealloc	function
(	O
argv	pointer
,	O
(	O
argc	int
+	O
2	int
)	O
*	O
sizeof	O
(	O
*	O
argv	pointer
)	O
)	O
;	O
if	O
(	O
_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"*** rpmGlob argv[%d] \"%s\"\n"	pointer
,	O
argc	int
,	O
av	pointer
[	O
j	int
]	O
)	O
;	O
argv	pointer
[	O
argc	int
++	O
]	O
=	O
xstrdup	function
(	O
av	pointer
[	O
j	int
]	O
)	O
;	O
continue	O
;	O
}	O
gl	struct
.	O
gl_pathc	long
=	O
0	int
;	O
gl	struct
.	O
gl_pathv	pointer
=	O
NULL	O
;	O
rc	int
=	O
Glob	function
(	O
av	pointer
[	O
j	int
]	O
,	O
0	int
,	O
glob_error	function
,	O
&	O
gl	struct
)	O
;	O
if	O
(	O
rc	int
)	O
goto	O
exit	function
;	O
maxb	long
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
gl	struct
.	O
gl_pathc	long
;	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
nb	long
=	O
strlen	function
(	O
&	O
(	O
gl	struct
.	O
gl_pathv	pointer
[	O
i	int
]	O
[	O
0	int
]	O
)	O
)	O
)	O
>	O
maxb	long
)	O
maxb	long
=	O
nb	long
;	O
}	O
ut	int
=	O
urlPath	function
(	O
av	pointer
[	O
j	int
]	O
,	O
&	O
path	pointer
)	O
;	O
nb	long
=	O
(	O
(	O
ut	int
>	O
URL_IS_DASH	int
)	O
?	O
(	O
path	pointer
-	O
av	pointer
[	O
j	int
]	O
)	O
:	O
0	int
)	O
;	O
maxb	long
+=	O
nb	long
;	O
maxb	long
+=	O
1	int
;	O
globURL	pointer
=	O
globRoot	pointer
=	O
xmalloc	function
(	O
maxb	long
)	O
;	O
switch	O
(	O
ut	int
)	O
{	O
case	O
URL_IS_HTTP	int
:	O
case	O
URL_IS_FTP	int
:	O
case	O
URL_IS_PATH	int
:	O
case	O
URL_IS_DASH	int
:	O
strncpy	function
(	O
globRoot	pointer
,	O
av	pointer
[	O
j	int
]	O
,	O
nb	long
)	O
;	O
break	O
;	O
case	O
URL_IS_UNKNOWN	int
:	O
break	O
;	O
}	O
globRoot	pointer
+=	O
nb	long
;	O
*	O
globRoot	pointer
=	O
'\0'	O
;	O
if	O
(	O
_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"*** GLOB maxb %d diskURL %d %*s globURL %p %s\n"	pointer
,	O
maxb	long
,	O
nb	long
,	O
nb	long
,	O
av	pointer
[	O
j	int
]	O
,	O
globURL	pointer
,	O
globURL	pointer
)	O
;	O
if	O
(	O
argc	int
==	O
0	int
)	O
argv	pointer
=	O
xmalloc	function
(	O
(	O
gl	struct
.	O
gl_pathc	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
*	O
argv	pointer
)	O
)	O
;	O
else	O
if	O
(	O
gl	struct
.	O
gl_pathc	long
>	O
0	int
)	O
argv	pointer
=	O
xrealloc	function
(	O
argv	pointer
,	O
(	O
argc	int
+	O
gl	struct
.	O
gl_pathc	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
*	O
argv	pointer
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
gl	struct
.	O
gl_pathc	long
;	O
i	int
++	O
)	O
{	O
const	O
char	O
*	O
globFile	pointer
=	O
&	O
(	O
gl	struct
.	O
gl_pathv	pointer
[	O
i	int
]	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
globRoot	pointer
>	O
globURL	pointer
&&	O
globRoot	pointer
[	O
-	O
1	int
]	O
==	O
'/'	O
)	O
while	O
(	O
*	O
globFile	pointer
==	O
'/'	O
)	O
globFile	pointer
++	O
;	O
strcpy	function
(	O
globRoot	pointer
,	O
globFile	pointer
)	O
;	O
if	O
(	O
_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"*** rpmGlob argv[%d] \"%s\"\n"	pointer
,	O
argc	int
,	O
globURL	pointer
)	O
;	O
argv	pointer
[	O
argc	int
++	O
]	O
=	O
xstrdup	function
(	O
globURL	pointer
)	O
;	O
}	O
Globfree	function
(	O
&	O
gl	struct
)	O
;	O
xfree	O
(	O
globURL	pointer
)	O
;	O
}	O
argv	pointer
[	O
argc	int
]	O
=	O
NULL	O
;	O
if	O
(	O
argvPtr	pointer
)	O
*	O
argvPtr	pointer
=	O
argv	pointer
;	O
if	O
(	O
argcPtr	pointer
)	O
*	O
argcPtr	pointer
=	O
argc	int
;	O
rc	int
=	O
0	int
;	O
exit	function
:	O
if	O
(	O
av	pointer
)	O
xfree	O
(	O
av	pointer
)	O
;	O
if	O
(	O
(	O
rc	int
||	O
argvPtr	pointer
==	O
NULL	O
)	O
&&	O
argv	pointer
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
xfree	O
(	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
xfree	O
(	O
argv	pointer
)	O
;	O
argv	pointer
=	O
NULL	O
;	O
}	O
return	O
rc	int
;	O
}	O
int	O
rpmHeaderGetEntry	function
(	O
Header	pointer
h	pointer
,	O
int_32	int
tag	int
,	O
int_32	int
*	O
type	enum
,	O
void	O
*	O
*	O
p	pointer
,	O
int_32	int
*	O
c	int
)	O
{	O
switch	O
(	O
tag	int
)	O
{	O
case	O
RPMTAG_OLDFILENAMES	int
:	O
{	O
const	O
char	O
*	O
*	O
fl	pointer
=	O
NULL	O
;	O
int	O
count	long
;	O
rpmBuildFileList	function
(	O
h	pointer
,	O
&	O
fl	pointer
,	O
&	O
count	long
)	O
;	O
if	O
(	O
count	long
>	O
0	int
)	O
{	O
*	O
p	pointer
=	O
fl	pointer
;	O
if	O
(	O
c	int
)	O
*	O
c	int
=	O
count	long
;	O
return	O
1	int
;	O
}	O
if	O
(	O
c	int
)	O
*	O
c	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
break	O
;	O
case	O
RPMTAG_GROUP	int
:	O
case	O
RPMTAG_DESCRIPTION	int
:	O
case	O
RPMTAG_SUMMARY	int
:	O
{	O
char	O
fmt	pointer
[	O
128	int
]	O
;	O
const	O
char	O
*	O
msgstr	pointer
;	O
const	O
char	O
*	O
errstr	pointer
;	O
fmt	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
(	O
void	O
)	O
rpm_stpcpy	function
(	O
rpm_stpcpy	function
(	O
rpm_stpcpy	function
(	O
fmt	pointer
,	O
"%{"	pointer
)	O
,	O
tagName	function
(	O
tag	int
)	O
)	O
,	O
"}\n"	pointer
)	O
;	O
msgstr	pointer
=	O
headerSprintf	function
(	O
h	pointer
,	O
fmt	pointer
,	O
rpmTagTable	array
,	O
rpmHeaderFormats	array
,	O
&	O
errstr	pointer
)	O
;	O
if	O
(	O
msgstr	pointer
)	O
{	O
*	O
p	pointer
=	O
(	O
void	O
*	O
)	O
msgstr	pointer
;	O
if	O
(	O
type	enum
)	O
*	O
type	enum
=	O
RPM_STRING_TYPE	int
;	O
if	O
(	O
c	int
)	O
*	O
c	int
=	O
1	int
;	O
return	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
c	int
)	O
*	O
c	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
}	O
break	O
;	O
default	O
:	O
return	O
headerGetEntry	function
(	O
h	pointer
,	O
tag	int
,	O
type	enum
,	O
p	pointer
,	O
c	int
)	O
;	O
break	O
;	O
}	O
}	O
