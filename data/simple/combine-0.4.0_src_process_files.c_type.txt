int	O
process_reference_files	function
(	O
)	O
{	O
STRINGTYPE	O
*	O
key_value	pointer
;	O
STRINGTYPE	O
*	O
hrchy_key_value	pointer
;	O
STRINGTYPE	O
*	O
*	O
ref_output_fields	pointer
;	O
STRINGTYPE	O
*	O
input_record_desc	pointer
;	O
HASHTYPE	O
hash_index	long
;	O
long	O
int	O
i	long
;	O
long	O
int	O
j	long
;	O
COUNTTYPE	O
temp_number	long
;	O
int	O
return_code	int
;	O
FILE	struct
*	O
reference_file	pointer
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gi_reference_file_count	int
;	O
i	long
++	O
)	O
{	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
=	O
calloc	function
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_size	long
,	O
sizeof	O
(	O
*	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
)	O
)	O
;	O
if	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
==	O
NULL	O
)	O
{	O
FATAL_ERROR3	O
(	O
_	O
(	O
"unable to allocate hash table for %s -- wanted %ld things of size %ld bytes\n"	pointer
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
file_name	pointer
,	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_size	long
,	O
sizeof	O
(	O
*	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
)	O
)	O
;	O
}	O
if	O
(	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hrchy_key_range_count	int
!=	O
0	int
||	O
REFINFO	O
[	O
i	long
]	O
.	O
hrchy_key_end_start	int
!=	O
0	int
)	O
&&	O
REFINFO	O
[	O
i	long
]	O
.	O
hrchy_direction	int
==	O
0	int
)	O
{	O
REFINFO	O
[	O
i	long
]	O
.	O
hrchy_hash_table	pointer
=	O
calloc	function
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_size	long
,	O
sizeof	O
(	O
*	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
)	O
)	O
;	O
if	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hrchy_hash_table	pointer
==	O
NULL	O
)	O
{	O
FATAL_ERROR3	O
(	O
_	O
(	O
"unable to allocate hash table for %s -- wanted %ld things of size %ld bytes\n"	pointer
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
file_name	pointer
,	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_size	long
,	O
sizeof	O
(	O
*	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
)	O
)	O
;	O
}	O
}	O
else	O
REFINFO	O
[	O
i	long
]	O
.	O
hrchy_hash_table	pointer
=	O
NULL	O
;	O
if	O
(	O
strcmp	function
(	O
REFINFO	O
[	O
i	long
]	O
.	O
file_name	pointer
,	O
"-"	pointer
)	O
==	O
0	int
)	O
reference_file	pointer
=	O
stdin	pointer
;	O
else	O
{	O
reference_file	pointer
=	O
fopen	function
(	O
REFINFO	O
[	O
i	long
]	O
.	O
file_name	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
reference_file	pointer
==	O
NULL	O
)	O
FATAL_PERROR	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
file_name	pointer
)	O
;	O
}	O
input_record_desc	pointer
=	O
df_get_next_record	function
(	O
reference_file	pointer
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
input_buffer	pointer
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
input_buffer_pos	long
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
input_buffer_size	long
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
input_record_delimiter	pointer
,	O
REFINFO	O
[	O
i	long
]	O
.	O
input_record_length	int
)	O
;	O
while	O
(	O
input_record_desc	pointer
!=	O
NULL	O
)	O
{	O
int	O
keep_record	int
;	O
REFINFO	O
[	O
i	long
]	O
.	O
records_read	int
++	O
;	O
keep_record	int
=	O
1	int
;	O
if	O
(	O
gi_verbose_ind	int
!=	O
0	int
&&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
records_read	int
%	O
1000	int
)	O
==	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"\rReading from reference file (%ld) %s: %12d records"	pointer
)	O
,	O
i	long
+	O
1	int
,	O
REFINFO	O
[	O
i	long
]	O
.	O
file_name	pointer
,	O
REFINFO	O
[	O
i	long
]	O
.	O
records_read	int
)	O
;	O
key_value	pointer
=	O
dstrnew	function
(	O
)	O
;	O
find_input_ranges	function
(	O
key_value	pointer
,	O
input_record_desc	pointer
,	O
REFINFO	O
[	O
i	long
]	O
.	O
key_ranges	pointer
,	O
REFINFO	O
[	O
i	long
]	O
.	O
key_range_count	int
,	O
REFINFO	O
[	O
i	long
]	O
.	O
key_end_start	int
,	O
REFINFO	O
[	O
i	long
]	O
.	O
input_field_delimiter	pointer
,	O
REFINFO	O
[	O
i	long
]	O
.	O
input_field_delimiter_repeat	int
,	O
gs_output_field_delimiter	pointer
)	O
;	O
if	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hrchy_key_range_count	int
!=	O
0	int
||	O
REFINFO	O
[	O
i	long
]	O
.	O
hrchy_key_end_start	int
!=	O
0	int
)	O
{	O
hrchy_key_value	pointer
=	O
dstrnew	function
(	O
)	O
;	O
find_input_ranges	function
(	O
hrchy_key_value	pointer
,	O
input_record_desc	pointer
,	O
REFINFO	O
[	O
i	long
]	O
.	O
hrchy_key_ranges	pointer
,	O
REFINFO	O
[	O
i	long
]	O
.	O
hrchy_key_range_count	int
,	O
REFINFO	O
[	O
i	long
]	O
.	O
hrchy_key_end_start	int
,	O
REFINFO	O
[	O
i	long
]	O
.	O
input_field_delimiter	pointer
,	O
REFINFO	O
[	O
i	long
]	O
.	O
input_field_delimiter_repeat	int
,	O
gs_output_field_delimiter	pointer
)	O
;	O
}	O
else	O
hrchy_key_value	pointer
=	O
NULL	O
;	O
return_code	int
=	O
a_find_input_ranges	function
(	O
&	O
(	O
ref_output_fields	pointer
)	O
,	O
input_record_desc	pointer
,	O
REFINFO	O
[	O
i	long
]	O
.	O
out_ranges	pointer
,	O
REFINFO	O
[	O
i	long
]	O
.	O
out_range_count	int
,	O
REFINFO	O
[	O
i	long
]	O
.	O
out_end_start	int
,	O
REFINFO	O
[	O
i	long
]	O
.	O
input_field_delimiter	pointer
,	O
REFINFO	O
[	O
i	long
]	O
.	O
input_field_delimiter_repeat	int
,	O
DStr_own	int
,	O
gs_output_field_delimiter	pointer
,	O
REFINFO	O
[	O
i	long
]	O
.	O
empty_string	pointer
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
if	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
empty_string	pointer
!=	O
NULL	O
)	O
{	O
return_code	int
=	O
fill_empty_fields	function
(	O
ref_output_fields	pointer
,	O
REFINFO	O
[	O
i	long
]	O
.	O
out_range_count	int
,	O
REFINFO	O
[	O
i	long
]	O
.	O
empty_string	pointer
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
if	O
(	O
keep_record	int
)	O
{	O
if	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
unique_ind	int
==	O
0	int
||	O
find_table_entry	function
(	O
key_value	pointer
,	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
,	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_size	long
)	O
==	O
-	O
1	int
)	O
{	O
hash_index	long
=	O
create_table_entry	function
(	O
key_value	pointer
,	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
,	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_size	long
)	O
;	O
if	O
(	O
hash_index	long
==	O
-	O
1	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to insert new hash entry"	pointer
)	O
)	O
;	O
else	O
{	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
[	O
hash_index	long
]	O
.	O
info	pointer
=	O
malloc	function
(	O
NUM_COUNTERS	O
*	O
sizeof	O
(	O
temp_number	long
)	O
+	O
sizeof	O
(	O
&	O
temp_number	long
)	O
)	O
;	O
if	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
[	O
hash_index	long
]	O
.	O
info	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
NUM_COUNTERS	O
;	O
j	long
++	O
)	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
[	O
hash_index	long
]	O
.	O
info	pointer
)	O
)	O
[	O
j	long
]	O
=	O
0	int
;	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
[	O
hash_index	long
]	O
.	O
output_fields	pointer
=	O
ref_output_fields	pointer
;	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
[	O
hash_index	long
]	O
.	O
chain_key	pointer
=	O
hrchy_key_value	pointer
;	O
}	O
if	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hrchy_hash_table	pointer
!=	O
NULL	O
)	O
{	O
hash_index	long
=	O
create_table_entry	function
(	O
hrchy_key_value	pointer
,	O
REFINFO	O
[	O
i	long
]	O
.	O
hrchy_hash_table	pointer
,	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_size	long
)	O
;	O
if	O
(	O
hash_index	long
==	O
-	O
1	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to insert new hash entry"	pointer
)	O
)	O
;	O
else	O
{	O
REFINFO	O
[	O
i	long
]	O
.	O
hrchy_hash_table	pointer
[	O
hash_index	long
]	O
.	O
info	pointer
=	O
NULL	O
;	O
REFINFO	O
[	O
i	long
]	O
.	O
hrchy_hash_table	pointer
[	O
hash_index	long
]	O
.	O
output_fields	pointer
=	O
ref_output_fields	pointer
;	O
REFINFO	O
[	O
i	long
]	O
.	O
hrchy_hash_table	pointer
[	O
hash_index	long
]	O
.	O
chain_key	pointer
=	O
key_value	pointer
;	O
}	O
}	O
key_value	pointer
=	O
NULL	O
;	O
hrchy_key_value	pointer
=	O
NULL	O
;	O
ref_output_fields	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
dstrfree	function
(	O
key_value	pointer
)	O
;	O
key_value	pointer
=	O
NULL	O
;	O
dstrfree	function
(	O
hrchy_key_value	pointer
)	O
;	O
hrchy_key_value	pointer
=	O
NULL	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
REFINFO	O
[	O
i	long
]	O
.	O
out_range_count	int
;	O
j	long
++	O
)	O
dstrfree	function
(	O
ref_output_fields	pointer
[	O
j	long
]	O
)	O
;	O
free	function
(	O
ref_output_fields	pointer
)	O
;	O
ref_output_fields	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
gi_data_is_reference	int
!=	O
0	int
)	O
{	O
int	O
write_dummy	int
;	O
process_data_reference_matches	function
(	O
NULL	O
,	O
0	int
,	O
&	O
write_dummy	int
,	O
input_record_desc	pointer
)	O
;	O
}	O
}	O
else	O
{	O
REFINFO	O
[	O
i	long
]	O
.	O
records_dropped_filter	int
++	O
;	O
}	O
dstrfree	function
(	O
input_record_desc	pointer
)	O
;	O
input_record_desc	pointer
=	O
df_get_next_record	function
(	O
reference_file	pointer
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
input_buffer	pointer
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
input_buffer_pos	long
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
input_buffer_size	long
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
input_record_delimiter	pointer
,	O
REFINFO	O
[	O
i	long
]	O
.	O
input_record_length	int
)	O
;	O
}	O
if	O
(	O
gi_verbose_ind	int
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"\rReading from reference file (%ld) %s: %12d records"	pointer
)	O
,	O
i	long
+	O
1	int
,	O
REFINFO	O
[	O
i	long
]	O
.	O
file_name	pointer
,	O
REFINFO	O
[	O
i	long
]	O
.	O
records_read	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
{	O
int	O
return_code	int
;	O
return_code	int
=	O
fclose	function
(	O
reference_file	pointer
)	O
;	O
if	O
(	O
return_code	int
!=	O
0	int
)	O
FATAL_PERROR	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
file_name	pointer
)	O
;	O
}	O
}	O
return	O
EXIT_SUCCESS	int
;	O
}	O
int	O
process_data_file	function
(	O
input_filename	pointer
)	O
char	O
*	O
input_filename	pointer
;	O
{	O
STRINGTYPE	O
*	O
value	pointer
;	O
int	O
write_record	int
;	O
STRINGTYPE	O
*	O
new_value	pointer
;	O
STRINGTYPE	O
*	O
key_value	pointer
;	O
STRINGTYPE	O
*	O
tmp_buf_ptr	pointer
;	O
STRINGTYPE	O
*	O
input_record_desc	pointer
;	O
STRINGTYPE	O
*	O
*	O
output_fields	pointer
;	O
int	O
i	long
;	O
int	O
return_code	int
;	O
value	pointer
=	O
NULL	O
;	O
new_value	pointer
=	O
NULL	O
;	O
key_value	pointer
=	O
NULL	O
;	O
tmp_buf_ptr	pointer
=	O
NULL	O
;	O
gi_file_records_read	int
=	O
0	int
;	O
gi_file_records_dropped_filter	int
=	O
0	int
;	O
gi_file_records_matched	int
=	O
0	int
;	O
gi_file_output_records_written	int
=	O
0	int
;	O
if	O
(	O
strcmp	function
(	O
input_filename	pointer
,	O
"-"	pointer
)	O
)	O
input_file	pointer
=	O
fopen	function
(	O
input_filename	pointer
,	O
"r"	pointer
)	O
;	O
else	O
input_file	pointer
=	O
stdin	pointer
;	O
if	O
(	O
input_file	pointer
==	O
NULL	O
)	O
FATAL_PERROR	O
(	O
input_filename	pointer
)	O
;	O
input_record_desc	pointer
=	O
df_get_next_record	function
(	O
input_file	pointer
,	O
&	O
(	O
gs_data_input_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_input_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_input_buffer_size	long
)	O
,	O
gs_data_input_record_delimiter	pointer
,	O
gi_data_input_record_length	int
)	O
;	O
while	O
(	O
input_record_desc	pointer
!=	O
NULL	O
)	O
{	O
int	O
keep_record	int
;	O
gi_data_records_read	int
++	O
;	O
gi_file_records_read	int
++	O
;	O
keep_record	int
=	O
1	int
;	O
write_record	int
=	O
1	int
;	O
if	O
(	O
gi_verbose_ind	int
!=	O
0	int
&&	O
(	O
gi_file_records_read	int
%	O
1000	int
)	O
==	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"\rReading from data file %s: %12d records"	pointer
)	O
,	O
(	O
input_file	pointer
==	O
stdin	pointer
?	O
"stdin"	pointer
:	O
input_filename	pointer
)	O
,	O
gi_file_records_read	int
)	O
;	O
return_code	int
=	O
a_find_input_ranges	function
(	O
&	O
output_fields	pointer
,	O
input_record_desc	pointer
,	O
gra_data_out_ranges	pointer
,	O
gi_data_out_range_count	int
,	O
gi_data_out_end_start	int
,	O
gs_data_input_field_delimiter	pointer
,	O
gi_data_input_field_delimiter_repeat	int
,	O
DStr_not_own	int
,	O
gs_output_field_delimiter	pointer
,	O
gs_data_empty_string	pointer
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
if	O
(	O
gs_data_empty_string	pointer
!=	O
NULL	O
)	O
{	O
return_code	int
=	O
fill_empty_fields	function
(	O
output_fields	pointer
,	O
gi_data_out_range_count	int
,	O
gs_data_empty_string	pointer
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
if	O
(	O
keep_record	int
)	O
{	O
process_data_reference_matches	function
(	O
output_fields	pointer
,	O
0	int
,	O
&	O
write_record	int
,	O
input_record_desc	pointer
)	O
;	O
if	O
(	O
write_record	int
!=	O
0	int
)	O
{	O
gi_data_records_matched	int
++	O
;	O
gi_file_records_matched	int
++	O
;	O
}	O
}	O
else	O
{	O
gi_file_records_dropped_filter	int
++	O
;	O
gi_data_records_dropped_filter	int
++	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gi_data_out_range_count	int
;	O
i	long
++	O
)	O
dstrfree	function
(	O
output_fields	pointer
[	O
i	long
]	O
)	O
;	O
free	function
(	O
output_fields	pointer
)	O
;	O
dstrfree	function
(	O
input_record_desc	pointer
)	O
;	O
input_record_desc	pointer
=	O
df_get_next_record	function
(	O
input_file	pointer
,	O
&	O
(	O
gs_data_input_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_input_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_input_buffer_size	long
)	O
,	O
gs_data_input_record_delimiter	pointer
,	O
gi_data_input_record_length	int
)	O
;	O
}	O
if	O
(	O
gi_verbose_ind	int
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"\rReading from data file %s: %12d records"	pointer
)	O
,	O
(	O
input_file	pointer
==	O
stdin	pointer
?	O
"stdin"	pointer
:	O
input_filename	pointer
)	O
,	O
gi_file_records_read	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
if	O
(	O
ferror	function
(	O
input_file	pointer
)	O
)	O
FATAL_PERROR	O
(	O
input_filename	pointer
)	O
;	O
if	O
(	O
input_file	pointer
!=	O
stdin	pointer
)	O
{	O
int	O
return_code	int
;	O
return_code	int
=	O
fclose	function
(	O
input_file	pointer
)	O
;	O
if	O
(	O
return_code	int
!=	O
0	int
)	O
FATAL_PERROR	O
(	O
input_filename	pointer
)	O
;	O
}	O
if	O
(	O
gi_data_optional_ind	int
!=	O
0	int
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gi_reference_file_count	int
;	O
i	long
++	O
)	O
{	O
int	O
j	long
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
gi_reference_file_count	int
;	O
j	long
++	O
)	O
{	O
REFINFO	O
[	O
j	long
]	O
.	O
current_hash_selection	int
=	O
-	O
1	int
;	O
}	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_size	long
;	O
j	long
++	O
)	O
{	O
if	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
[	O
j	long
]	O
.	O
value	pointer
!=	O
NULL	O
&&	O
*	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
[	O
j	long
]	O
.	O
info	pointer
)	O
==	O
0	int
)	O
{	O
REFINFO	O
[	O
i	long
]	O
.	O
current_hash_selection	int
=	O
j	long
;	O
write_match_record	function
(	O
NULL	O
)	O
;	O
}	O
}	O
REFINFO	O
[	O
i	long
]	O
.	O
current_hash_selection	int
=	O
-	O
1	int
;	O
}	O
}	O
free	function
(	O
gs_data_input_buffer	pointer
)	O
;	O
gs_data_input_buffer	pointer
=	O
NULL	O
;	O
gi_data_input_buffer_size	long
=	O
0	int
;	O
gi_data_input_buffer_pos	long
=	O
0	int
;	O
if	O
(	O
gi_statistics_ind	int
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Statistics for data file %s\n"	pointer
)	O
,	O
input_filename	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  Number of records read:              %15d\n"	pointer
)	O
,	O
gi_file_records_read	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  Number of records dropped by filter: %15d\n"	pointer
)	O
,	O
gi_file_records_dropped_filter	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  Number of records matched on key:    %15d\n"	pointer
)	O
,	O
gi_file_records_matched	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  Number of records written:           %15d\n"	pointer
)	O
,	O
gi_file_output_records_written	int
)	O
;	O
}	O
return	O
EXIT_SUCCESS	int
;	O
}	O
int	O
process_data_reference_matches	function
(	O
data_output_fields	pointer
,	O
reference_file_number	int
,	O
write_record	int
,	O
input_record_desc	pointer
)	O
STRINGTYPE	O
*	O
*	O
data_output_fields	pointer
;	O
int	O
reference_file_number	int
;	O
int	O
*	O
write_record	int
;	O
STRINGTYPE	O
*	O
input_record_desc	pointer
;	O
{	O
STRINGTYPE	O
*	O
key_value	pointer
;	O
int	O
j	long
;	O
int	O
k	int
;	O
HASHTYPE	O
hash_index	long
;	O
int	O
first_written	int
;	O
if	O
(	O
reference_file_number	int
<	O
gi_reference_file_count	int
)	O
{	O
key_value	pointer
=	O
dstrnew	function
(	O
)	O
;	O
if	O
(	O
key_value	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
find_input_ranges	function
(	O
key_value	pointer
,	O
input_record_desc	pointer
,	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
data_key_ranges	pointer
,	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
data_key_range_count	int
,	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
data_key_end_start	int
,	O
gs_data_input_field_delimiter	pointer
,	O
gi_data_input_field_delimiter_repeat	int
,	O
gs_output_field_delimiter	pointer
)	O
;	O
hash_index	long
=	O
find_table_entry	function
(	O
key_value	pointer
,	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_table	pointer
,	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_size	long
)	O
;	O
}	O
do	O
{	O
int	O
keep_match	int
;	O
keep_match	int
=	O
1	int
;	O
if	O
(	O
(	O
hash_index	long
==	O
-	O
1	int
||	O
keep_match	int
!=	O
1	int
)	O
&&	O
gi_reference_file_count	int
!=	O
0	int
)	O
{	O
if	O
(	O
gi_reference_file_count	int
!=	O
0	int
&&	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
optional_ind	int
==	O
0	int
)	O
*	O
write_record	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
gi_reference_file_count	int
!=	O
0	int
&&	O
keep_match	int
==	O
1	int
)	O
{	O
if	O
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_key_range_count	int
!=	O
0	int
||	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_key_end_start	int
!=	O
0	int
)	O
{	O
traverse_hierarchy	function
(	O
data_output_fields	pointer
,	O
reference_file_number	int
,	O
write_record	int
,	O
input_record_desc	pointer
,	O
hash_index	long
,	O
0	int
)	O
;	O
}	O
else	O
update_counters	function
(	O
reference_file_number	int
,	O
hash_index	long
,	O
data_output_fields	pointer
,	O
input_record_desc	pointer
)	O
;	O
}	O
if	O
(	O
keep_match	int
!=	O
1	int
||	O
gi_reference_file_count	int
==	O
0	int
||	O
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_key_range_count	int
==	O
0	int
&&	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_key_end_start	int
==	O
0	int
)	O
)	O
{	O
if	O
(	O
keep_match	int
==	O
1	int
&&	O
gi_reference_file_count	int
!=	O
0	int
)	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
current_hash_selection	int
=	O
hash_index	long
;	O
else	O
if	O
(	O
gi_reference_file_count	int
!=	O
0	int
)	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
current_hash_selection	int
=	O
-	O
1	int
;	O
if	O
(	O
*	O
write_record	int
==	O
0	int
&&	O
gi_checkallref_ind	int
==	O
0	int
)	O
{	O
dstrfree	function
(	O
key_value	pointer
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
}	O
if	O
(	O
reference_file_number	int
<	O
gi_reference_file_count	int
-	O
1	int
)	O
{	O
process_data_reference_matches	function
(	O
data_output_fields	pointer
,	O
reference_file_number	int
+	O
1	int
,	O
write_record	int
,	O
input_record_desc	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
*	O
write_record	int
!=	O
0	int
&&	O
gi_data_write_ind	int
==	O
1	int
)	O
{	O
int	O
return_code	int
;	O
write_match_record	function
(	O
data_output_fields	pointer
)	O
;	O
}	O
}	O
}	O
if	O
(	O
gi_reference_file_count	int
>	O
0	int
&&	O
hash_index	long
!=	O
-	O
1	int
&&	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_table	pointer
[	O
hash_index	long
]	O
.	O
another_for_key	int
!=	O
0	int
)	O
{	O
do	O
{	O
hash_index	long
=	O
(	O
hash_index	long
+	O
1	int
)	O
%	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_size	long
;	O
}	O
while	O
(	O
dstrcmp	function
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_table	pointer
[	O
hash_index	long
]	O
.	O
value	pointer
,	O
key_value	pointer
)	O
!=	O
0	int
)	O
;	O
}	O
else	O
hash_index	long
=	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_size	long
+	O
1	int
;	O
}	O
while	O
(	O
gi_reference_file_count	int
>	O
0	int
&&	O
hash_index	long
!=	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_size	long
+	O
1	int
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
}	O
int	O
write_output	function
(	O
)	O
{	O
int	O
i	long
;	O
int	O
j	long
;	O
int	O
k	int
;	O
char	O
counterformat	array
[	O
10	int
]	O
;	O
FILE	struct
*	O
outfile	pointer
;	O
int	O
return_code	int
;	O
int	O
first_written	int
;	O
sprintf	function
(	O
counterformat	array
,	O
"%%%dd"	pointer
,	O
gi_output_counter_size	int
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gi_reference_file_count	int
;	O
i	long
++	O
)	O
{	O
if	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_file_name	pointer
!=	O
NULL	O
)	O
{	O
outfile	pointer
=	O
fopen	function
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_file_name	pointer
,	O
"w"	pointer
)	O
;	O
if	O
(	O
outfile	pointer
==	O
NULL	O
)	O
FATAL_PERROR	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_file_name	pointer
)	O
;	O
}	O
else	O
outfile	pointer
=	O
stdout	pointer
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_size	long
;	O
j	long
++	O
)	O
{	O
if	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
[	O
j	long
]	O
.	O
value	pointer
!=	O
NULL	O
)	O
{	O
REFINFO	O
[	O
i	long
]	O
.	O
records_stored	int
++	O
;	O
first_written	int
=	O
0	int
;	O
if	O
(	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
[	O
j	long
]	O
.	O
info	pointer
)	O
)	O
[	O
FLAG_INDEX	O
]	O
!=	O
0	int
)	O
REFINFO	O
[	O
i	long
]	O
.	O
records_matched_key	int
++	O
;	O
if	O
(	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
[	O
j	long
]	O
.	O
info	pointer
)	O
)	O
[	O
FLAG_INDEX	O
]	O
==	O
1	int
)	O
REFINFO	O
[	O
i	long
]	O
.	O
records_matched	int
++	O
;	O
REFINFO	O
[	O
i	long
]	O
.	O
data_records_matched	int
+=	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
[	O
j	long
]	O
.	O
info	pointer
)	O
)	O
[	O
COUNTER_INDEX	O
]	O
;	O
if	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
write_ind	int
==	O
1	int
)	O
{	O
if	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
TOTAL_REF_OUT_RANGES	O
(	O
i	long
)	O
>	O
0	int
)	O
{	O
if	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
constant_string	pointer
!=	O
NULL	O
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
outfile	pointer
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer	pointer
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_pos	long
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
constant_string	pointer
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
REFINFO	O
[	O
i	long
]	O
.	O
suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_file_name	pointer
)	O
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
REFINFO	O
[	O
i	long
]	O
.	O
out_range_count	int
;	O
k	int
++	O
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
outfile	pointer
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer	pointer
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_pos	long
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
[	O
j	long
]	O
.	O
output_fields	pointer
[	O
k	int
]	O
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
REFINFO	O
[	O
i	long
]	O
.	O
suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_file_name	pointer
)	O
;	O
}	O
if	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
out_end_start	int
!=	O
0	int
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
outfile	pointer
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer	pointer
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_pos	long
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
[	O
j	long
]	O
.	O
output_fields	pointer
[	O
REFINFO	O
[	O
i	long
]	O
.	O
out_range_count	int
]	O
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
REFINFO	O
[	O
i	long
]	O
.	O
suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_file_name	pointer
)	O
;	O
}	O
}	O
else	O
{	O
return_code	int
=	O
df_write_output	function
(	O
outfile	pointer
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer	pointer
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_pos	long
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
[	O
j	long
]	O
.	O
value	pointer
,	O
gs_output_record_delimiter	pointer
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_file_name	pointer
)	O
;	O
first_written	int
=	O
1	int
;	O
}	O
for	O
(	O
k	int
=	O
SKIP_COUNTERS	O
;	O
k	int
<	O
NUM_COUNTERS	O
;	O
k	int
++	O
)	O
{	O
char	O
temp_value	array
[	O
100	int
]	O
;	O
STRINGTYPE	O
*	O
temp_dstring	pointer
;	O
if	O
(	O
k	int
<	O
2	int
||	O
gra_data_sum_ranges	pointer
[	O
k	int
-	O
2	int
]	O
.	O
precision	int
==	O
0	int
)	O
{	O
sprintf	function
(	O
temp_value	array
,	O
COUNTFORMAT	pointer
,	O
gi_output_counter_size	int
,	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
[	O
j	long
]	O
.	O
info	pointer
)	O
)	O
[	O
k	int
]	O
)	O
;	O
temp_dstring	pointer
=	O
dstrdupstr	function
(	O
temp_value	array
)	O
;	O
if	O
(	O
temp_dstring	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
STRINGTYPE	O
*	O
temp_period	pointer
;	O
COUNTTYPE	O
temp_scale	long
;	O
COUNTTYPE	O
temp_remainder	long
;	O
temp_scale	long
=	O
pow	function
(	O
10	int
,	O
gra_data_sum_ranges	pointer
[	O
k	int
-	O
2	int
]	O
.	O
precision	int
)	O
;	O
if	O
(	O
errno	O
==	O
ERANGE	int
)	O
FATAL_ERROR1	O
(	O
_	O
(	O
"precision causes fixed decimal overflow in sum field number %d"	pointer
)	O
,	O
k	int
-	O
1	int
)	O
;	O
if	O
(	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
[	O
j	long
]	O
.	O
info	pointer
)	O
)	O
[	O
k	int
]	O
<	O
0	int
&&	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
[	O
j	long
]	O
.	O
info	pointer
)	O
)	O
[	O
k	int
]	O
>	O
-	O
1	int
*	O
temp_scale	long
)	O
{	O
temp_dstring	pointer
=	O
dstrdupstr	function
(	O
"-"	pointer
)	O
;	O
if	O
(	O
temp_dstring	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
sprintf	function
(	O
temp_value	array
,	O
COUNTFORMAT	pointer
,	O
MIN	O
(	O
gi_output_counter_size	int
-	O
gra_data_sum_ranges	pointer
[	O
k	int
-	O
2	int
]	O
.	O
precision	int
-	O
2	int
,	O
0	int
)	O
,	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
[	O
j	long
]	O
.	O
info	pointer
)	O
)	O
[	O
k	int
]	O
/	O
temp_scale	long
)	O
;	O
temp_period	pointer
=	O
dstrdupstr	function
(	O
temp_value	array
)	O
;	O
if	O
(	O
temp_period	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
temp_dstring	pointer
=	O
dstrcat	function
(	O
temp_dstring	pointer
,	O
temp_period	pointer
)	O
;	O
if	O
(	O
temp_dstring	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
dstrfree	function
(	O
temp_period	pointer
)	O
;	O
}	O
else	O
{	O
sprintf	function
(	O
temp_value	array
,	O
COUNTFORMAT	pointer
,	O
MIN	O
(	O
gi_output_counter_size	int
-	O
gra_data_sum_ranges	pointer
[	O
k	int
-	O
2	int
]	O
.	O
precision	int
-	O
1	int
,	O
0	int
)	O
,	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
[	O
j	long
]	O
.	O
info	pointer
)	O
)	O
[	O
k	int
]	O
/	O
temp_scale	long
)	O
;	O
temp_dstring	pointer
=	O
dstrdupstr	function
(	O
temp_value	array
)	O
;	O
}	O
if	O
(	O
temp_dstring	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
temp_period	pointer
=	O
dstrdupstr	function
(	O
"."	pointer
)	O
;	O
if	O
(	O
temp_period	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
temp_dstring	pointer
=	O
dstrcat	function
(	O
temp_dstring	pointer
,	O
temp_period	pointer
)	O
;	O
if	O
(	O
temp_dstring	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
dstrfree	function
(	O
temp_period	pointer
)	O
;	O
temp_remainder	long
=	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
[	O
j	long
]	O
.	O
info	pointer
)	O
)	O
[	O
k	int
]	O
%	O
temp_scale	long
;	O
if	O
(	O
temp_remainder	long
<	O
0	int
)	O
temp_remainder	long
*=	O
-	O
1	int
;	O
sprintf	function
(	O
temp_value	array
,	O
COUNTFRACTFORMAT	pointer
,	O
gra_data_sum_ranges	pointer
[	O
k	int
-	O
2	int
]	O
.	O
precision	int
,	O
temp_remainder	long
)	O
;	O
temp_period	pointer
=	O
dstrdupstr	function
(	O
temp_value	array
)	O
;	O
if	O
(	O
temp_period	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
temp_dstring	pointer
=	O
dstrcat	function
(	O
temp_dstring	pointer
,	O
temp_period	pointer
)	O
;	O
if	O
(	O
temp_dstring	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
dstrfree	function
(	O
temp_period	pointer
)	O
;	O
}	O
return_code	int
=	O
df_write_field	function
(	O
outfile	pointer
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer	pointer
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_pos	long
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_size	long
)	O
,	O
temp_dstring	pointer
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
REFINFO	O
[	O
i	long
]	O
.	O
suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_file_name	pointer
)	O
;	O
dstrfree	function
(	O
temp_dstring	pointer
)	O
;	O
}	O
}	O
else	O
{	O
char	O
temp_value	array
[	O
100	int
]	O
;	O
STRINGTYPE	O
*	O
temp_dstring	pointer
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order_count	int
;	O
k	int
++	O
)	O
{	O
switch	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	pointer
[	O
k	int
]	O
.	O
source	char
)	O
{	O
case	O
'r'	O
:	O
if	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	pointer
[	O
k	int
]	O
.	O
source_num	int
!=	O
i	long
+	O
1	int
&&	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	pointer
[	O
k	int
]	O
.	O
source_num	int
!=	O
0	int
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"reference file order requests another reference file"	pointer
)	O
)	O
;	O
switch	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	pointer
[	O
k	int
]	O
.	O
type	char
)	O
{	O
case	O
'o'	O
:	O
return_code	int
=	O
df_write_field	function
(	O
outfile	pointer
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer	pointer
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_pos	long
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
[	O
j	long
]	O
.	O
output_fields	pointer
[	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	pointer
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
REFINFO	O
[	O
i	long
]	O
.	O
suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_file_name	pointer
)	O
;	O
break	O
;	O
case	O
'k'	O
:	O
return_code	int
=	O
df_write_field	function
(	O
outfile	pointer
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer	pointer
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_pos	long
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
constant_string	pointer
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
REFINFO	O
[	O
i	long
]	O
.	O
suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_file_name	pointer
)	O
;	O
break	O
;	O
case	O
'f'	O
:	O
sprintf	function
(	O
temp_value	array
,	O
COUNTFORMAT	pointer
,	O
gi_output_counter_size	int
,	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
[	O
j	long
]	O
.	O
info	pointer
)	O
)	O
[	O
FLAG_INDEX	O
]	O
)	O
;	O
temp_dstring	pointer
=	O
dstrdupstr	function
(	O
temp_value	array
)	O
;	O
if	O
(	O
temp_dstring	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
return_code	int
=	O
df_write_field	function
(	O
outfile	pointer
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer	pointer
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_pos	long
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_size	long
)	O
,	O
temp_dstring	pointer
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
REFINFO	O
[	O
i	long
]	O
.	O
suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_file_name	pointer
)	O
;	O
dstrfree	function
(	O
temp_dstring	pointer
)	O
;	O
break	O
;	O
case	O
'n'	O
:	O
sprintf	function
(	O
temp_value	array
,	O
COUNTFORMAT	pointer
,	O
gi_output_counter_size	int
,	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
[	O
j	long
]	O
.	O
info	pointer
)	O
)	O
[	O
COUNTER_INDEX	O
]	O
)	O
;	O
temp_dstring	pointer
=	O
dstrdupstr	function
(	O
temp_value	array
)	O
;	O
if	O
(	O
temp_dstring	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
return_code	int
=	O
df_write_field	function
(	O
outfile	pointer
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer	pointer
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_pos	long
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_size	long
)	O
,	O
temp_dstring	pointer
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
REFINFO	O
[	O
i	long
]	O
.	O
suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_file_name	pointer
)	O
;	O
dstrfree	function
(	O
temp_dstring	pointer
)	O
;	O
break	O
;	O
case	O
's'	O
:	O
if	O
(	O
gra_data_sum_ranges	pointer
[	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	pointer
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
.	O
precision	int
==	O
0	int
)	O
{	O
sprintf	function
(	O
temp_value	array
,	O
COUNTFORMAT	pointer
,	O
gi_output_counter_size	int
,	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
[	O
j	long
]	O
.	O
info	pointer
)	O
)	O
[	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	pointer
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
)	O
;	O
temp_dstring	pointer
=	O
dstrdupstr	function
(	O
temp_value	array
)	O
;	O
if	O
(	O
temp_dstring	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
STRINGTYPE	O
*	O
temp_period	pointer
;	O
COUNTTYPE	O
temp_scale	long
;	O
COUNTTYPE	O
temp_remainder	long
;	O
temp_scale	long
=	O
pow	function
(	O
10	int
,	O
gra_data_sum_ranges	pointer
[	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	pointer
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
.	O
precision	int
)	O
;	O
if	O
(	O
errno	O
==	O
ERANGE	int
)	O
FATAL_ERROR1	O
(	O
_	O
(	O
"precision causes fixed decimal overflow in sum field number %d"	pointer
)	O
,	O
k	int
-	O
1	int
)	O
;	O
if	O
(	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
[	O
j	long
]	O
.	O
info	pointer
)	O
)	O
[	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	pointer
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
<	O
0	int
&&	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
[	O
j	long
]	O
.	O
info	pointer
)	O
)	O
[	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	pointer
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
>	O
-	O
1	int
*	O
temp_scale	long
)	O
{	O
temp_dstring	pointer
=	O
dstrdupstr	function
(	O
"-"	pointer
)	O
;	O
if	O
(	O
temp_dstring	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
sprintf	function
(	O
temp_value	array
,	O
COUNTFORMAT	pointer
,	O
MIN	O
(	O
gi_output_counter_size	int
-	O
gra_data_sum_ranges	pointer
[	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	pointer
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
.	O
precision	int
-	O
2	int
,	O
0	int
)	O
,	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
[	O
j	long
]	O
.	O
info	pointer
)	O
)	O
[	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	pointer
[	O
k	int
]	O
.	O
type_num	int
+	O
1	int
]	O
/	O
temp_scale	long
)	O
;	O
temp_period	pointer
=	O
dstrdupstr	function
(	O
temp_value	array
)	O
;	O
if	O
(	O
temp_period	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
temp_dstring	pointer
=	O
dstrcat	function
(	O
temp_dstring	pointer
,	O
temp_period	pointer
)	O
;	O
if	O
(	O
temp_dstring	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
dstrfree	function
(	O
temp_period	pointer
)	O
;	O
}	O
else	O
{	O
sprintf	function
(	O
temp_value	array
,	O
COUNTFORMAT	pointer
,	O
MIN	O
(	O
gi_output_counter_size	int
-	O
gra_data_sum_ranges	pointer
[	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	pointer
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
.	O
precision	int
-	O
1	int
,	O
0	int
)	O
,	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
[	O
j	long
]	O
.	O
info	pointer
)	O
)	O
[	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	pointer
[	O
k	int
]	O
.	O
type_num	int
+	O
1	int
]	O
/	O
temp_scale	long
)	O
;	O
temp_dstring	pointer
=	O
dstrdupstr	function
(	O
temp_value	array
)	O
;	O
if	O
(	O
temp_dstring	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
temp_period	pointer
=	O
dstrdupstr	function
(	O
"."	pointer
)	O
;	O
if	O
(	O
temp_period	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
temp_dstring	pointer
=	O
dstrcat	function
(	O
temp_dstring	pointer
,	O
temp_period	pointer
)	O
;	O
if	O
(	O
temp_dstring	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
dstrfree	function
(	O
temp_period	pointer
)	O
;	O
temp_remainder	long
=	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
hash_table	pointer
[	O
j	long
]	O
.	O
info	pointer
)	O
)	O
[	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	pointer
[	O
k	int
]	O
.	O
type_num	int
+	O
1	int
]	O
%	O
temp_scale	long
;	O
if	O
(	O
temp_remainder	long
<	O
0	int
)	O
temp_remainder	long
*=	O
-	O
1	int
;	O
sprintf	function
(	O
temp_value	array
,	O
COUNTFRACTFORMAT	pointer
,	O
gra_data_sum_ranges	pointer
[	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	pointer
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
.	O
precision	int
,	O
temp_remainder	long
)	O
;	O
temp_period	pointer
=	O
dstrdupstr	function
(	O
temp_value	array
)	O
;	O
if	O
(	O
temp_period	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
temp_dstring	pointer
=	O
dstrcat	function
(	O
temp_dstring	pointer
,	O
temp_period	pointer
)	O
;	O
if	O
(	O
temp_dstring	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
dstrfree	function
(	O
temp_period	pointer
)	O
;	O
}	O
return_code	int
=	O
df_write_field	function
(	O
outfile	pointer
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer	pointer
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_pos	long
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_size	long
)	O
,	O
temp_dstring	pointer
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
REFINFO	O
[	O
i	long
]	O
.	O
suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_file_name	pointer
)	O
;	O
dstrfree	function
(	O
temp_dstring	pointer
)	O
;	O
break	O
;	O
default	O
:	O
FATAL_ERROR2	O
(	O
_	O
(	O
"unknown reference order field type: %c.%c"	pointer
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	pointer
[	O
k	int
]	O
.	O
source	char
,	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	pointer
[	O
k	int
]	O
.	O
type	char
)	O
;	O
}	O
break	O
;	O
default	O
:	O
FATAL_ERROR1	O
(	O
_	O
(	O
"unknown reference order field source: %c"	pointer
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
output_field_order	pointer
[	O
k	int
]	O
.	O
source	char
)	O
;	O
}	O
}	O
}	O
return_code	int
=	O
df_write_output	function
(	O
outfile	pointer
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer	pointer
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_pos	long
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_size	long
)	O
,	O
NULL	O
,	O
gs_output_record_delimiter	pointer
,	O
1	int
,	O
0	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_file_name	pointer
)	O
;	O
}	O
}	O
}	O
return_code	int
=	O
df_write_output	function
(	O
outfile	pointer
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer	pointer
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_pos	long
)	O
,	O
&	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_buffer_size	long
)	O
,	O
NULL	O
,	O
gs_output_record_delimiter	pointer
,	O
0	int
,	O
1	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_file_name	pointer
)	O
;	O
if	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_file_name	pointer
!=	O
NULL	O
)	O
{	O
return_code	int
=	O
fclose	function
(	O
outfile	pointer
)	O
;	O
if	O
(	O
return_code	int
!=	O
0	int
)	O
FATAL_PERROR	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
output_file_name	pointer
)	O
;	O
}	O
if	O
(	O
gi_statistics_ind	int
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Statistics for reference file %s\n"	pointer
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
file_name	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  Number of records read:              %15d\n"	pointer
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
records_read	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  Number of records dropped by filter: %15d\n"	pointer
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
records_dropped_filter	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  Number of records stored:            %15d\n"	pointer
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
records_stored	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  Number of records matched on key:    %15d\n"	pointer
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
records_matched_key	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  Number of records matched fully:     %15d\n"	pointer
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
records_matched	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"  Number of reference-data matches:    %15d\n"	pointer
)	O
,	O
REFINFO	O
[	O
i	long
]	O
.	O
data_records_matched	int
)	O
;	O
}	O
}	O
return	O
EXIT_SUCCESS	int
;	O
}	O
HASHTYPE	O
traverse_hierarchy	function
(	O
data_output_fields	pointer
,	O
reference_file_number	int
,	O
write_record	int
,	O
input_record_desc	pointer
,	O
start	long
,	O
depth	long
)	O
STRINGTYPE	O
*	O
*	O
data_output_fields	pointer
;	O
int	O
reference_file_number	int
;	O
int	O
*	O
write_record	int
;	O
STRINGTYPE	O
*	O
input_record_desc	pointer
;	O
HASHTYPE	O
start	long
;	O
HASHTYPE	O
depth	long
;	O
{	O
HASHTYPE	O
hash_entry	long
;	O
HASHTYPE	O
next_hash_entry	long
;	O
HASHTYPE	O
other_hash_entry	long
;	O
hash_entry	long
=	O
start	long
;	O
if	O
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_hash_table	pointer
==	O
NULL	O
)	O
{	O
while	O
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_table	pointer
[	O
hash_entry	long
]	O
.	O
chain_key	pointer
!=	O
NULL	O
&&	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_table	pointer
[	O
hash_entry	long
]	O
.	O
chain_key	pointer
->	O
length	long
!=	O
0	int
)	O
{	O
if	O
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_flatten_levels	int
==	O
0	int
&&	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_leaf_only	int
==	O
0	int
)	O
{	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
current_hash_selection	int
=	O
hash_entry	long
;	O
update_counters	function
(	O
reference_file_number	int
,	O
hash_entry	long
,	O
data_output_fields	pointer
,	O
input_record_desc	pointer
)	O
;	O
if	O
(	O
reference_file_number	int
<	O
gi_reference_file_count	int
-	O
1	int
)	O
{	O
process_data_reference_matches	function
(	O
data_output_fields	pointer
,	O
reference_file_number	int
+	O
1	int
,	O
write_record	int
,	O
input_record_desc	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
*	O
write_record	int
!=	O
0	int
&&	O
gi_data_write_ind	int
==	O
1	int
)	O
{	O
int	O
return_code	int
;	O
write_match_record	function
(	O
data_output_fields	pointer
)	O
;	O
}	O
}	O
}	O
next_hash_entry	long
=	O
find_table_entry	function
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_table	pointer
[	O
hash_entry	long
]	O
.	O
chain_key	pointer
,	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_table	pointer
,	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_size	long
)	O
;	O
if	O
(	O
next_hash_entry	long
==	O
-	O
1	int
)	O
FATAL_ERROR2	O
(	O
_	O
(	O
"referential integrity problem: cannot find key %.*s"	pointer
)	O
,	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_table	pointer
[	O
hash_entry	long
]	O
.	O
chain_key	pointer
->	O
length	long
,	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_table	pointer
[	O
hash_entry	long
]	O
.	O
chain_key	pointer
->	O
string	pointer
)	O
;	O
hash_entry	long
=	O
next_hash_entry	long
;	O
}	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
current_hash_selection	int
=	O
hash_entry	long
;	O
update_counters	function
(	O
reference_file_number	int
,	O
hash_entry	long
,	O
data_output_fields	pointer
,	O
input_record_desc	pointer
)	O
;	O
if	O
(	O
reference_file_number	int
<	O
gi_reference_file_count	int
-	O
1	int
)	O
{	O
process_data_reference_matches	function
(	O
data_output_fields	pointer
,	O
reference_file_number	int
+	O
1	int
,	O
write_record	int
,	O
input_record_desc	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
*	O
write_record	int
!=	O
0	int
&&	O
gi_data_write_ind	int
==	O
1	int
)	O
{	O
int	O
return_code	int
;	O
write_match_record	function
(	O
data_output_fields	pointer
)	O
;	O
}	O
}	O
return	O
hash_entry	long
;	O
}	O
else	O
{	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_curr_depth	long
=	O
depth	long
+	O
1	int
;	O
hrchy_add_path	function
(	O
depth	long
,	O
hash_entry	long
,	O
&	O
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_path	pointer
)	O
,	O
&	O
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_path_size	long
)	O
,	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_table	pointer
[	O
hash_entry	long
]	O
.	O
value	pointer
)	O
;	O
if	O
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_flatten_levels	int
==	O
0	int
&&	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_leaf_only	int
==	O
0	int
)	O
{	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
current_hash_selection	int
=	O
hash_entry	long
;	O
update_counters	function
(	O
reference_file_number	int
,	O
hash_entry	long
,	O
data_output_fields	pointer
,	O
input_record_desc	pointer
)	O
;	O
if	O
(	O
reference_file_number	int
<	O
gi_reference_file_count	int
-	O
1	int
)	O
{	O
process_data_reference_matches	function
(	O
data_output_fields	pointer
,	O
reference_file_number	int
+	O
1	int
,	O
write_record	int
,	O
input_record_desc	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
*	O
write_record	int
!=	O
0	int
&&	O
gi_data_write_ind	int
==	O
1	int
)	O
{	O
int	O
return_code	int
;	O
write_match_record	function
(	O
data_output_fields	pointer
)	O
;	O
}	O
}	O
}	O
next_hash_entry	long
=	O
find_table_entry	function
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_table	pointer
[	O
hash_entry	long
]	O
.	O
value	pointer
,	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_hash_table	pointer
,	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_size	long
)	O
;	O
if	O
(	O
next_hash_entry	long
==	O
-	O
1	int
)	O
{	O
if	O
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_leaf_only	int
!=	O
0	int
||	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_flatten_levels	int
!=	O
0	int
)	O
{	O
update_counters	function
(	O
reference_file_number	int
,	O
hash_entry	long
,	O
data_output_fields	pointer
,	O
input_record_desc	pointer
)	O
;	O
if	O
(	O
reference_file_number	int
<	O
gi_reference_file_count	int
-	O
1	int
)	O
{	O
process_data_reference_matches	function
(	O
data_output_fields	pointer
,	O
reference_file_number	int
+	O
1	int
,	O
write_record	int
,	O
input_record_desc	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
*	O
write_record	int
!=	O
0	int
&&	O
gi_data_write_ind	int
==	O
1	int
)	O
{	O
int	O
return_code	int
;	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
current_hash_selection	int
=	O
hash_entry	long
;	O
write_match_record	function
(	O
data_output_fields	pointer
)	O
;	O
}	O
}	O
}	O
}	O
else	O
do	O
{	O
other_hash_entry	long
=	O
find_table_entry	function
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_hash_table	pointer
[	O
next_hash_entry	long
]	O
.	O
chain_key	pointer
,	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_table	pointer
,	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_size	long
)	O
;	O
if	O
(	O
other_hash_entry	long
==	O
-	O
1	int
)	O
FATAL_ERROR2	O
(	O
_	O
(	O
"referential integrity problem: cannot find key %.*s"	pointer
)	O
,	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_hash_table	pointer
[	O
next_hash_entry	long
]	O
.	O
chain_key	pointer
->	O
length	long
,	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_hash_table	pointer
[	O
next_hash_entry	long
]	O
.	O
chain_key	pointer
->	O
string	pointer
)	O
;	O
if	O
(	O
other_hash_entry	long
!=	O
-	O
1	int
)	O
{	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
current_hash_selection	int
=	O
other_hash_entry	long
;	O
traverse_hierarchy	function
(	O
data_output_fields	pointer
,	O
reference_file_number	int
,	O
write_record	int
,	O
input_record_desc	pointer
,	O
other_hash_entry	long
,	O
depth	long
+	O
1	int
)	O
;	O
}	O
if	O
(	O
next_hash_entry	long
!=	O
-	O
1	int
&&	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_hash_table	pointer
[	O
next_hash_entry	long
]	O
.	O
another_for_key	int
!=	O
0	int
)	O
{	O
do	O
{	O
next_hash_entry	long
=	O
(	O
next_hash_entry	long
+	O
1	int
)	O
%	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_size	long
;	O
}	O
while	O
(	O
dstrcmp	function
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hrchy_hash_table	pointer
[	O
next_hash_entry	long
]	O
.	O
value	pointer
,	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_table	pointer
[	O
hash_entry	long
]	O
.	O
value	pointer
)	O
!=	O
0	int
)	O
;	O
}	O
else	O
next_hash_entry	long
=	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_size	long
+	O
1	int
;	O
}	O
while	O
(	O
next_hash_entry	long
!=	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_size	long
+	O
1	int
)	O
;	O
}	O
return	O
start	long
;	O
}	O
int	O
write_match_record	function
(	O
data_output_fields	pointer
)	O
STRINGTYPE	O
*	O
*	O
data_output_fields	pointer
;	O
{	O
int	O
first_written	int
;	O
int	O
return_code	int
;	O
int	O
i	long
;	O
int	O
j	long
;	O
int	O
k	int
;	O
if	O
(	O
data_output_fields	pointer
!=	O
NULL	O
&&	O
gi_data_exclude_match_ind	int
)	O
return	O
EXIT_SUCCESS	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gi_reference_file_count	int
;	O
i	long
++	O
)	O
{	O
if	O
(	O
REFINFO	O
[	O
i	long
]	O
.	O
current_hash_selection	int
!=	O
-	O
1	int
&&	O
REFINFO	O
[	O
i	long
]	O
.	O
exclude_match_ind	int
)	O
return	O
EXIT_SUCCESS	int
;	O
}	O
gi_output_records_written	int
++	O
;	O
gi_file_output_records_written	int
++	O
;	O
first_written	int
=	O
0	int
;	O
if	O
(	O
gra_data_output_field_order	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
data_output_fields	pointer
!=	O
NULL	O
)	O
{	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
gi_data_out_range_count	int
;	O
j	long
++	O
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
data_output_fields	pointer
[	O
j	long
]	O
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
if	O
(	O
gi_data_out_end_start	int
!=	O
0	int
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
data_output_fields	pointer
[	O
gi_data_out_range_count	int
]	O
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
if	O
(	O
gs_data_constant_string	pointer
!=	O
NULL	O
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
gs_data_constant_string	pointer
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
gs_data_missing_string	pointer
!=	O
NULL	O
)	O
{	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
gi_data_out_range_count	int
;	O
j	long
++	O
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
gs_data_missing_string	pointer
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
if	O
(	O
gs_data_constant_string	pointer
!=	O
NULL	O
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
gs_data_missing_string	pointer
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
gi_data_out_range_count	int
;	O
j	long
++	O
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
NULL	O
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
(	O
gra_data_out_ranges	pointer
[	O
j	long
]	O
.	O
upper_bound	long
-	O
gra_data_out_ranges	pointer
[	O
j	long
]	O
.	O
lower_bound	long
+	O
1	int
)	O
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
if	O
(	O
gs_data_constant_string	pointer
!=	O
NULL	O
)	O
{	O
int	O
temp_len	int
;	O
temp_len	int
=	O
gs_data_constant_string	pointer
->	O
length	long
;	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
NULL	O
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
temp_len	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
gi_reference_file_count	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
REFINFO	O
[	O
k	int
]	O
.	O
hrchy_flatten_levels	int
!=	O
0	int
)	O
{	O
if	O
(	O
REFINFO	O
[	O
k	int
]	O
.	O
current_hash_selection	int
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
REFINFO	O
[	O
k	int
]	O
.	O
constant_string	pointer
!=	O
NULL	O
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
k	int
]	O
.	O
constant_string	pointer
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
REFINFO	O
[	O
k	int
]	O
.	O
hrchy_flatten_levels	int
;	O
i	long
++	O
)	O
{	O
if	O
(	O
i	long
<	O
REFINFO	O
[	O
k	int
]	O
.	O
hrchy_curr_depth	long
)	O
{	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
REFINFO	O
[	O
k	int
]	O
.	O
out_range_count	int
;	O
j	long
++	O
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
k	int
]	O
.	O
hash_table	pointer
[	O
REFINFO	O
[	O
k	int
]	O
.	O
hrchy_path	pointer
[	O
i	long
]	O
]	O
.	O
output_fields	pointer
[	O
j	long
]	O
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
if	O
(	O
REFINFO	O
[	O
k	int
]	O
.	O
out_end_start	int
!=	O
0	int
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
k	int
]	O
.	O
hash_table	pointer
[	O
REFINFO	O
[	O
k	int
]	O
.	O
hrchy_path	pointer
[	O
i	long
]	O
]	O
.	O
output_fields	pointer
[	O
REFINFO	O
[	O
k	int
]	O
.	O
out_range_count	int
]	O
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
REFINFO	O
[	O
k	int
]	O
.	O
out_range_count	int
;	O
j	long
++	O
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
NULL	O
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
(	O
REFINFO	O
[	O
k	int
]	O
.	O
out_ranges	pointer
[	O
j	long
]	O
.	O
upper_bound	long
-	O
REFINFO	O
[	O
k	int
]	O
.	O
out_ranges	pointer
[	O
j	long
]	O
.	O
lower_bound	long
+	O
1	int
)	O
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
}	O
}	O
}	O
else	O
if	O
(	O
REFINFO	O
[	O
k	int
]	O
.	O
missing_string	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
REFINFO	O
[	O
k	int
]	O
.	O
constant_string	pointer
!=	O
NULL	O
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
k	int
]	O
.	O
missing_string	pointer
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
REFINFO	O
[	O
k	int
]	O
.	O
out_range_count	int
;	O
j	long
++	O
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
k	int
]	O
.	O
missing_string	pointer
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
REFINFO	O
[	O
k	int
]	O
.	O
constant_string	pointer
!=	O
NULL	O
)	O
{	O
int	O
temp_len	int
;	O
temp_len	int
=	O
REFINFO	O
[	O
k	int
]	O
.	O
constant_string	pointer
->	O
length	long
;	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
NULL	O
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
temp_len	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
REFINFO	O
[	O
k	int
]	O
.	O
out_range_count	int
;	O
j	long
++	O
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
NULL	O
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
(	O
REFINFO	O
[	O
k	int
]	O
.	O
out_ranges	pointer
[	O
j	long
]	O
.	O
upper_bound	long
-	O
REFINFO	O
[	O
k	int
]	O
.	O
out_ranges	pointer
[	O
j	long
]	O
.	O
lower_bound	long
+	O
1	int
)	O
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
REFINFO	O
[	O
k	int
]	O
.	O
current_hash_selection	int
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
REFINFO	O
[	O
k	int
]	O
.	O
constant_string	pointer
!=	O
NULL	O
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
k	int
]	O
.	O
constant_string	pointer
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
REFINFO	O
[	O
k	int
]	O
.	O
out_range_count	int
;	O
j	long
++	O
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
k	int
]	O
.	O
hash_table	pointer
[	O
REFINFO	O
[	O
k	int
]	O
.	O
current_hash_selection	int
]	O
.	O
output_fields	pointer
[	O
j	long
]	O
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
if	O
(	O
REFINFO	O
[	O
k	int
]	O
.	O
out_end_start	int
!=	O
0	int
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
k	int
]	O
.	O
hash_table	pointer
[	O
REFINFO	O
[	O
k	int
]	O
.	O
current_hash_selection	int
]	O
.	O
output_fields	pointer
[	O
REFINFO	O
[	O
k	int
]	O
.	O
out_range_count	int
]	O
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
REFINFO	O
[	O
k	int
]	O
.	O
missing_string	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
REFINFO	O
[	O
k	int
]	O
.	O
constant_string	pointer
!=	O
NULL	O
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
k	int
]	O
.	O
missing_string	pointer
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
REFINFO	O
[	O
k	int
]	O
.	O
out_range_count	int
;	O
j	long
++	O
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
k	int
]	O
.	O
missing_string	pointer
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
REFINFO	O
[	O
k	int
]	O
.	O
constant_string	pointer
!=	O
NULL	O
)	O
{	O
int	O
temp_len	int
;	O
temp_len	int
=	O
REFINFO	O
[	O
k	int
]	O
.	O
constant_string	pointer
->	O
length	long
;	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
NULL	O
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
temp_len	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
REFINFO	O
[	O
k	int
]	O
.	O
out_range_count	int
;	O
j	long
++	O
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
NULL	O
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
(	O
REFINFO	O
[	O
k	int
]	O
.	O
out_ranges	pointer
[	O
j	long
]	O
.	O
upper_bound	long
-	O
REFINFO	O
[	O
k	int
]	O
.	O
out_ranges	pointer
[	O
j	long
]	O
.	O
lower_bound	long
+	O
1	int
)	O
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
}	O
}	O
}	O
else	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
gi_data_output_field_order_count	int
;	O
k	int
++	O
)	O
{	O
switch	O
(	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
source	char
)	O
{	O
case	O
's'	O
:	O
break	O
;	O
case	O
'r'	O
:	O
switch	O
(	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
type	char
)	O
{	O
case	O
'o'	O
:	O
if	O
(	O
REFINFO	O
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
current_hash_selection	int
!=	O
-	O
1	int
)	O
{	O
int	O
hash_pos	int
=	O
REFINFO	O
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
current_hash_selection	int
;	O
if	O
(	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
type_num	int
>	O
0	int
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
hash_table	pointer
[	O
hash_pos	int
]	O
.	O
output_fields	pointer
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
else	O
{	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
-	O
1	int
*	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
;	O
i	long
<	O
REFINFO	O
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
out_range_count	int
+	O
(	O
REFINFO	O
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
out_end_start	int
!=	O
0	int
?	O
1	int
:	O
0	int
)	O
;	O
i	long
++	O
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
hash_table	pointer
[	O
hash_pos	int
]	O
.	O
output_fields	pointer
[	O
i	long
]	O
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
k	int
+	O
1	int
<	O
gi_data_output_field_order_count	int
&&	O
gra_data_output_field_order	pointer
[	O
k	int
+	O
1	int
]	O
.	O
source	char
==	O
's'	O
)	O
{	O
int	O
wrote_something	int
;	O
wrote_something	int
=	O
0	int
;	O
while	O
(	O
k	int
+	O
1	int
<	O
gi_data_output_field_order_count	int
&&	O
gra_data_output_field_order	pointer
[	O
k	int
+	O
1	int
]	O
.	O
source	char
==	O
's'	O
)	O
{	O
int	O
hash_pos	int
;	O
k	int
++	O
;	O
if	O
(	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
source_num	int
==	O
0	int
&&	O
data_output_fields	pointer
!=	O
NULL	O
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
data_output_fields	pointer
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
wrote_something	int
=	O
1	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
source_num	int
!=	O
0	int
)	O
{	O
hash_pos	int
=	O
REFINFO	O
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
current_hash_selection	int
;	O
if	O
(	O
hash_pos	int
!=	O
-	O
1	int
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
hash_table	pointer
[	O
hash_pos	int
]	O
.	O
output_fields	pointer
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
wrote_something	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
wrote_something	int
==	O
0	int
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
NULL	O
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
(	O
REFINFO	O
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
out_ranges	pointer
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
.	O
upper_bound	long
-	O
REFINFO	O
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
out_ranges	pointer
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
.	O
lower_bound	long
+	O
1	int
)	O
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
REFINFO	O
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
missing_string	pointer
!=	O
NULL	O
&&	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
type_num	int
!=	O
REFINFO	O
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
out_range_count	int
+	O
1	int
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
missing_string	pointer
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
else	O
if	O
(	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
type_num	int
!=	O
REFINFO	O
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
out_range_count	int
+	O
1	int
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
NULL	O
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
(	O
REFINFO	O
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
out_ranges	pointer
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
.	O
upper_bound	long
-	O
REFINFO	O
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
out_ranges	pointer
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
.	O
lower_bound	long
+	O
1	int
)	O
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
break	O
;	O
case	O
'k'	O
:	O
if	O
(	O
REFINFO	O
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
current_hash_selection	int
!=	O
-	O
1	int
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
constant_string	pointer
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
else	O
if	O
(	O
REFINFO	O
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
missing_string	pointer
!=	O
NULL	O
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
missing_string	pointer
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
else	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
NULL	O
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
REFINFO	O
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
constant_string	pointer
->	O
length	long
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
break	O
;	O
default	O
:	O
FATAL_ERROR2	O
(	O
_	O
(	O
"unknown data output order field type: %c.%c"	pointer
)	O
,	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
source	char
,	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
type	char
)	O
;	O
}	O
break	O
;	O
case	O
'd'	O
:	O
switch	O
(	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
type	char
)	O
{	O
case	O
'o'	O
:	O
if	O
(	O
data_output_fields	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
type_num	int
>	O
0	int
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
data_output_fields	pointer
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
else	O
{	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
-	O
1	int
*	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
;	O
i	long
<	O
gi_data_out_range_count	int
+	O
(	O
gi_data_out_end_start	int
!=	O
0	int
?	O
1	int
:	O
0	int
)	O
;	O
i	long
++	O
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
data_output_fields	pointer
[	O
i	long
]	O
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
k	int
+	O
1	int
<	O
gi_data_output_field_order_count	int
&&	O
gra_data_output_field_order	pointer
[	O
k	int
+	O
1	int
]	O
.	O
source	char
==	O
's'	O
)	O
{	O
int	O
wrote_something	int
;	O
wrote_something	int
=	O
0	int
;	O
while	O
(	O
k	int
+	O
1	int
<	O
gi_data_output_field_order_count	int
&&	O
gra_data_output_field_order	pointer
[	O
k	int
+	O
1	int
]	O
.	O
source	char
==	O
's'	O
)	O
{	O
int	O
hash_pos	int
;	O
k	int
++	O
;	O
if	O
(	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
source_num	int
==	O
0	int
&&	O
data_output_fields	pointer
!=	O
NULL	O
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
data_output_fields	pointer
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
wrote_something	int
=	O
1	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
source_num	int
!=	O
0	int
)	O
{	O
hash_pos	int
=	O
REFINFO	O
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
current_hash_selection	int
;	O
if	O
(	O
hash_pos	int
!=	O
-	O
1	int
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
REFINFO	O
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
source_num	int
-	O
1	int
]	O
.	O
hash_table	pointer
[	O
hash_pos	int
]	O
.	O
output_fields	pointer
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
wrote_something	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
wrote_something	int
==	O
0	int
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
NULL	O
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
gra_data_out_ranges	pointer
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
.	O
upper_bound	long
-	O
gra_data_out_ranges	pointer
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
.	O
lower_bound	long
+	O
1	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
gs_data_missing_string	pointer
!=	O
NULL	O
&&	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
type_num	int
!=	O
gi_data_out_range_count	int
+	O
1	int
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
gs_data_missing_string	pointer
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
else	O
if	O
(	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
type_num	int
!=	O
gi_data_out_range_count	int
+	O
1	int
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
NULL	O
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
gra_data_out_ranges	pointer
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
.	O
upper_bound	long
-	O
gra_data_out_ranges	pointer
[	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
type_num	int
-	O
1	int
]	O
.	O
lower_bound	long
+	O
1	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
break	O
;	O
case	O
'k'	O
:	O
if	O
(	O
data_output_fields	pointer
!=	O
NULL	O
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
gs_data_constant_string	pointer
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
else	O
if	O
(	O
gs_data_missing_string	pointer
!=	O
NULL	O
)	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
gs_data_missing_string	pointer
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
0	int
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
else	O
{	O
return_code	int
=	O
df_write_field	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
NULL	O
,	O
gs_output_field_delimiter	pointer
,	O
&	O
first_written	int
,	O
gs_data_constant_string	pointer
->	O
length	long
,	O
gi_data_suppress_empty_ind	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
break	O
;	O
default	O
:	O
FATAL_ERROR2	O
(	O
_	O
(	O
"unknown data output order field type: %c.%c"	pointer
)	O
,	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
source	char
,	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
type	char
)	O
;	O
}	O
break	O
;	O
default	O
:	O
FATAL_ERROR1	O
(	O
_	O
(	O
"unknown output order field source: %c"	pointer
)	O
,	O
gra_data_output_field_order	pointer
[	O
k	int
]	O
.	O
source	char
)	O
;	O
}	O
}	O
}	O
return_code	int
=	O
df_write_output	function
(	O
output_file	pointer
,	O
&	O
(	O
gs_data_output_buffer	pointer
)	O
,	O
&	O
(	O
gi_data_output_buffer_pos	long
)	O
,	O
&	O
(	O
gi_data_output_buffer_size	long
)	O
,	O
NULL	O
,	O
gs_output_record_delimiter	pointer
,	O
1	int
,	O
0	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
FATAL_PERROR	O
(	O
gs_data_output_file_name	pointer
)	O
;	O
}	O
int	O
update_counters	function
(	O
reference_file_number	int
,	O
hash_index	long
,	O
data_output_fields	pointer
,	O
input_record_desc	pointer
)	O
int	O
reference_file_number	int
;	O
HASHTYPE	O
hash_index	long
;	O
STRINGTYPE	O
*	O
*	O
data_output_fields	pointer
;	O
STRINGTYPE	O
*	O
input_record_desc	pointer
;	O
{	O
int	O
j	long
;	O
int	O
k	int
;	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_table	pointer
[	O
hash_index	long
]	O
.	O
info	pointer
)	O
)	O
[	O
FLAG_INDEX	O
]	O
|=	O
1	int
;	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_table	pointer
[	O
hash_index	long
]	O
.	O
info	pointer
)	O
)	O
[	O
COUNTER_INDEX	O
]	O
+=	O
1	int
;	O
j	long
=	O
2	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
gi_data_sum_range_count	int
;	O
k	int
++	O
)	O
{	O
DStr_string_descriptor	struct
*	O
temp_string	pointer
;	O
char	O
*	O
temp_value	array
;	O
if	O
(	O
gra_data_sum_ranges	pointer
[	O
k	int
]	O
.	O
format	pointer
!=	O
NULL	O
)	O
{	O
int	O
ifield	int
;	O
for	O
(	O
ifield	int
=	O
0	int
;	O
ifield	int
<	O
gi_data_out_range_count	int
+	O
(	O
gi_data_out_end_start	int
!=	O
0	int
?	O
1	int
:	O
0	int
)	O
;	O
ifield	int
++	O
)	O
{	O
create_scheme_string_variable	function
(	O
&	O
df_name_data_field	struct
,	O
ifield	int
+	O
1	int
,	O
data_output_fields	pointer
[	O
ifield	int
]	O
)	O
;	O
}	O
for	O
(	O
ifield	int
=	O
0	int
;	O
ifield	int
<	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
out_range_count	int
+	O
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
out_end_start	int
!=	O
0	int
?	O
1	int
:	O
0	int
)	O
;	O
ifield	int
++	O
)	O
{	O
create_scheme_string_variable	function
(	O
&	O
df_name_reference_field	struct
,	O
ifield	int
+	O
1	int
,	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_table	pointer
[	O
hash_index	long
]	O
.	O
output_fields	pointer
[	O
ifield	int
]	O
)	O
;	O
}	O
}	O
temp_string	pointer
=	O
find_field	function
(	O
gra_data_sum_ranges	pointer
,	O
gi_data_sum_range_count	int
,	O
k	int
,	O
input_record_desc	pointer
,	O
gs_data_input_field_delimiter	pointer
)	O
;	O
if	O
(	O
temp_string	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
temp_value	array
=	O
strdupdstr	function
(	O
temp_string	pointer
)	O
;	O
if	O
(	O
temp_value	array
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
if	O
(	O
gra_data_sum_ranges	pointer
[	O
k	int
]	O
.	O
precision	int
==	O
0	int
)	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_table	pointer
[	O
hash_index	long
]	O
.	O
info	pointer
)	O
)	O
[	O
j	long
+	O
k	int
]	O
+=	O
CONVERT_SUM	O
(	O
temp_value	array
)	O
;	O
else	O
CONVERT_SUM_PRECISION	O
(	O
temp_value	array
,	O
gra_data_sum_ranges	pointer
[	O
k	int
]	O
.	O
precision	int
,	O
(	O
(	O
COUNTTYPE	O
*	O
)	O
(	O
REFINFO	O
[	O
reference_file_number	int
]	O
.	O
hash_table	pointer
[	O
hash_index	long
]	O
.	O
info	pointer
)	O
)	O
[	O
j	long
+	O
k	int
]	O
)	O
;	O
free	function
(	O
temp_value	array
)	O
;	O
dstrfree	function
(	O
temp_string	pointer
)	O
;	O
}	O
}	O
int	O
hrchy_add_path	function
(	O
depth	long
,	O
new_entry	long
,	O
path	pointer
,	O
path_size	pointer
,	O
key	pointer
)	O
HASHTYPE	O
depth	long
;	O
HASHTYPE	O
new_entry	long
;	O
HASHTYPE	O
*	O
*	O
path	pointer
;	O
HASHTYPE	O
*	O
path_size	pointer
;	O
STRINGTYPE	O
*	O
key	pointer
;	O
{	O
int	O
i	long
;	O
if	O
(	O
*	O
path	pointer
==	O
NULL	O
)	O
{	O
*	O
path	pointer
=	O
malloc	function
(	O
DF_HRCHY_INCREMENT	int
*	O
sizeof	O
(	O
HASHTYPE	O
)	O
)	O
;	O
if	O
(	O
*	O
path	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
*	O
path_size	pointer
=	O
DF_HRCHY_INCREMENT	int
;	O
}	O
else	O
if	O
(	O
*	O
path_size	pointer
<=	O
depth	long
)	O
{	O
*	O
path	pointer
=	O
realloc	function
(	O
*	O
path	pointer
,	O
(	O
*	O
path_size	pointer
+	O
DF_HRCHY_INCREMENT	int
)	O
*	O
sizeof	O
(	O
HASHTYPE	O
)	O
)	O
;	O
if	O
(	O
*	O
path	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
*	O
path_size	pointer
+=	O
DF_HRCHY_INCREMENT	int
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
depth	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
(	O
*	O
path	pointer
)	O
[	O
i	long
]	O
==	O
new_entry	long
)	O
FATAL_ERROR2	O
(	O
_	O
(	O
"loop in hierarchy: %.*s"	pointer
)	O
,	O
key	pointer
->	O
length	long
,	O
key	pointer
->	O
string	pointer
)	O
;	O
}	O
(	O
*	O
path	pointer
)	O
[	O
depth	long
]	O
=	O
new_entry	long
;	O
}	O
