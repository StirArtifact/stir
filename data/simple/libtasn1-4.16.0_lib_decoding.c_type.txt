static	O
int	O
_asn1_get_indefinite_length_string	function
(	O
const	O
unsigned	O
char	O
*	O
der	pointer
,	O
int	O
der_len	int
,	O
int	O
*	O
len	int
)	O
;	O
static	O
int	O
_asn1_decode_simple_ber	function
(	O
unsigned	O
int	O
etype	pointer
,	O
const	O
unsigned	O
char	O
*	O
der	pointer
,	O
unsigned	O
int	O
_der_len	int
,	O
unsigned	O
char	O
*	O
*	O
str	pointer
,	O
unsigned	O
int	O
*	O
str_len	pointer
,	O
unsigned	O
int	O
*	O
ber_len	int
,	O
unsigned	O
dflags	int
)	O
;	O
static	O
int	O
_asn1_decode_simple_der	function
(	O
unsigned	O
int	O
etype	pointer
,	O
const	O
unsigned	O
char	O
*	O
der	pointer
,	O
unsigned	O
int	O
_der_len	int
,	O
const	O
unsigned	O
char	O
*	O
*	O
str	pointer
,	O
unsigned	O
int	O
*	O
str_len	pointer
,	O
unsigned	O
dflags	int
)	O
;	O
static	O
void	O
_asn1_error_description_tag_error	function
(	O
asn1_node	pointer
node	pointer
,	O
char	O
*	O
ErrorDescription	pointer
)	O
{	O
Estrcpy	O
(	O
ErrorDescription	pointer
,	O
":: tag error near element '"	pointer
)	O
;	O
_asn1_hierarchical_name	function
(	O
node	pointer
,	O
ErrorDescription	pointer
+	O
strlen	function
(	O
ErrorDescription	pointer
)	O
,	O
ASN1_MAX_ERROR_DESCRIPTION_SIZE	int
-	O
40	int
)	O
;	O
Estrcat	O
(	O
ErrorDescription	pointer
,	O
"'"	pointer
)	O
;	O
}	O
long	O
asn1_get_length_der	function
(	O
const	O
unsigned	O
char	O
*	O
der	pointer
,	O
int	O
der_len	int
,	O
int	O
*	O
len	int
)	O
{	O
unsigned	O
int	O
ans	int
;	O
int	O
k	int
,	O
punt	int
,	O
sum	int
;	O
*	O
len	int
=	O
0	int
;	O
if	O
(	O
der_len	int
<=	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
!	O
(	O
der	pointer
[	O
0	int
]	O
&	O
128	int
)	O
)	O
{	O
*	O
len	int
=	O
1	int
;	O
ans	int
=	O
der	pointer
[	O
0	int
]	O
;	O
}	O
else	O
{	O
k	int
=	O
der	pointer
[	O
0	int
]	O
&	O
0x7F	int
;	O
punt	int
=	O
1	int
;	O
if	O
(	O
k	int
)	O
{	O
ans	int
=	O
0	int
;	O
while	O
(	O
punt	int
<=	O
k	int
&&	O
punt	int
<	O
der_len	int
)	O
{	O
if	O
(	O
INT_MULTIPLY_OVERFLOW	O
(	O
ans	int
,	O
256	int
)	O
)	O
return	O
-	O
2	int
;	O
ans	int
*=	O
256	int
;	O
if	O
(	O
INT_ADD_OVERFLOW	O
(	O
ans	int
,	O
(	O
(	O
unsigned	O
)	O
der	pointer
[	O
punt	int
]	O
)	O
)	O
)	O
return	O
-	O
2	int
;	O
ans	int
+=	O
der	pointer
[	O
punt	int
]	O
;	O
punt	int
++	O
;	O
}	O
}	O
else	O
{	O
*	O
len	int
=	O
punt	int
;	O
return	O
-	O
1	int
;	O
}	O
*	O
len	int
=	O
punt	int
;	O
}	O
sum	int
=	O
ans	int
;	O
if	O
(	O
ans	int
>=	O
INT_MAX	O
||	O
INT_ADD_OVERFLOW	O
(	O
sum	int
,	O
(	O
*	O
len	int
)	O
)	O
)	O
return	O
-	O
2	int
;	O
sum	int
+=	O
*	O
len	int
;	O
if	O
(	O
sum	int
>	O
der_len	int
)	O
return	O
-	O
4	int
;	O
return	O
ans	int
;	O
}	O
int	O
asn1_get_tag_der	function
(	O
const	O
unsigned	O
char	O
*	O
der	pointer
,	O
int	O
der_len	int
,	O
unsigned	O
char	O
*	O
cls	pointer
,	O
int	O
*	O
len	int
,	O
unsigned	O
long	O
*	O
tag	pointer
)	O
{	O
unsigned	O
int	O
ris	int
;	O
int	O
punt	int
;	O
if	O
(	O
der	pointer
==	O
NULL	O
||	O
der_len	int
<	O
2	int
||	O
len	int
==	O
NULL	O
)	O
return	O
ASN1_DER_ERROR	int
;	O
*	O
cls	pointer
=	O
der	pointer
[	O
0	int
]	O
&	O
0xE0	int
;	O
if	O
(	O
(	O
der	pointer
[	O
0	int
]	O
&	O
0x1F	int
)	O
!=	O
0x1F	int
)	O
{	O
*	O
len	int
=	O
1	int
;	O
ris	int
=	O
der	pointer
[	O
0	int
]	O
&	O
0x1F	int
;	O
}	O
else	O
{	O
punt	int
=	O
1	int
;	O
ris	int
=	O
0	int
;	O
while	O
(	O
punt	int
<	O
der_len	int
&&	O
der	pointer
[	O
punt	int
]	O
&	O
128	int
)	O
{	O
if	O
(	O
INT_MULTIPLY_OVERFLOW	O
(	O
ris	int
,	O
128	int
)	O
)	O
return	O
ASN1_DER_ERROR	int
;	O
ris	int
*=	O
128	int
;	O
if	O
(	O
INT_ADD_OVERFLOW	O
(	O
ris	int
,	O
(	O
(	O
unsigned	O
)	O
(	O
der	pointer
[	O
punt	int
]	O
&	O
0x7F	int
)	O
)	O
)	O
)	O
return	O
ASN1_DER_ERROR	int
;	O
ris	int
+=	O
(	O
der	pointer
[	O
punt	int
]	O
&	O
0x7F	int
)	O
;	O
punt	int
++	O
;	O
}	O
if	O
(	O
punt	int
>=	O
der_len	int
)	O
return	O
ASN1_DER_ERROR	int
;	O
if	O
(	O
INT_MULTIPLY_OVERFLOW	O
(	O
ris	int
,	O
128	int
)	O
)	O
return	O
ASN1_DER_ERROR	int
;	O
ris	int
*=	O
128	int
;	O
if	O
(	O
INT_ADD_OVERFLOW	O
(	O
ris	int
,	O
(	O
(	O
unsigned	O
)	O
(	O
der	pointer
[	O
punt	int
]	O
&	O
0x7F	int
)	O
)	O
)	O
)	O
return	O
ASN1_DER_ERROR	int
;	O
ris	int
+=	O
(	O
der	pointer
[	O
punt	int
]	O
&	O
0x7F	int
)	O
;	O
punt	int
++	O
;	O
*	O
len	int
=	O
punt	int
;	O
}	O
if	O
(	O
tag	pointer
)	O
*	O
tag	pointer
=	O
ris	int
;	O
return	O
ASN1_SUCCESS	int
;	O
}	O
long	O
asn1_get_length_ber	function
(	O
const	O
unsigned	O
char	O
*	O
ber	pointer
,	O
int	O
ber_len	int
,	O
int	O
*	O
len	int
)	O
{	O
int	O
ret	pointer
;	O
long	O
err	long
;	O
ret	pointer
=	O
asn1_get_length_der	function
(	O
ber	pointer
,	O
ber_len	int
,	O
len	int
)	O
;	O
if	O
(	O
ret	pointer
==	O
-	O
1	int
&&	O
ber_len	int
>	O
1	int
)	O
{	O
err	long
=	O
_asn1_get_indefinite_length_string	function
(	O
ber	pointer
+	O
1	int
,	O
ber_len	int
-	O
1	int
,	O
&	O
ret	pointer
)	O
;	O
if	O
(	O
err	long
!=	O
ASN1_SUCCESS	int
)	O
return	O
-	O
3	int
;	O
}	O
return	O
ret	pointer
;	O
}	O
int	O
asn1_get_octet_der	function
(	O
const	O
unsigned	O
char	O
*	O
der	pointer
,	O
int	O
der_len	int
,	O
int	O
*	O
ret_len	pointer
,	O
unsigned	O
char	O
*	O
str	pointer
,	O
int	O
str_size	int
,	O
int	O
*	O
str_len	pointer
)	O
{	O
int	O
len_len	int
=	O
0	int
;	O
if	O
(	O
der_len	int
<=	O
0	int
)	O
return	O
ASN1_GENERIC_ERROR	int
;	O
*	O
str_len	pointer
=	O
asn1_get_length_der	function
(	O
der	pointer
,	O
der_len	int
,	O
&	O
len_len	int
)	O
;	O
if	O
(	O
*	O
str_len	pointer
<	O
0	int
)	O
return	O
ASN1_DER_ERROR	int
;	O
*	O
ret_len	pointer
=	O
*	O
str_len	pointer
+	O
len_len	int
;	O
if	O
(	O
str_size	int
>=	O
*	O
str_len	pointer
)	O
{	O
if	O
(	O
*	O
str_len	pointer
>	O
0	int
&&	O
str	pointer
!=	O
NULL	O
)	O
memcpy	function
(	O
str	pointer
,	O
der	pointer
+	O
len_len	int
,	O
*	O
str_len	pointer
)	O
;	O
}	O
else	O
{	O
return	O
ASN1_MEM_ERROR	int
;	O
}	O
return	O
ASN1_SUCCESS	int
;	O
}	O
static	O
int	O
_asn1_get_time_der	function
(	O
unsigned	O
type	int
,	O
const	O
unsigned	O
char	O
*	O
der	pointer
,	O
int	O
der_len	int
,	O
int	O
*	O
ret_len	pointer
,	O
char	O
*	O
str	pointer
,	O
int	O
str_size	int
,	O
unsigned	O
flags	int
)	O
{	O
int	O
len_len	int
,	O
str_len	pointer
;	O
unsigned	O
i	int
;	O
unsigned	O
sign_count	int
=	O
0	int
;	O
unsigned	O
dot_count	int
=	O
0	int
;	O
const	O
unsigned	O
char	O
*	O
p	pointer
;	O
if	O
(	O
der_len	int
<=	O
0	int
||	O
str	pointer
==	O
NULL	O
)	O
return	O
ASN1_DER_ERROR	int
;	O
str_len	pointer
=	O
asn1_get_length_der	function
(	O
der	pointer
,	O
der_len	int
,	O
&	O
len_len	int
)	O
;	O
if	O
(	O
str_len	pointer
<=	O
0	int
||	O
str_size	int
<	O
str_len	pointer
)	O
return	O
ASN1_DER_ERROR	int
;	O
if	O
(	O
str_len	pointer
<	O
8	int
)	O
{	O
warn	O
(	O
)	O
;	O
return	O
ASN1_TIME_ENCODING_ERROR	int
;	O
}	O
if	O
(	O
(	O
flags	int
&	O
ASN1_DECODE_FLAG_STRICT_DER	O
)	O
&&	O
!	O
(	O
flags	int
&	O
ASN1_DECODE_FLAG_ALLOW_INCORRECT_TIME	O
)	O
)	O
{	O
p	pointer
=	O
&	O
der	pointer
[	O
len_len	int
]	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
(	O
unsigned	O
)	O
(	O
str_len	pointer
-	O
1	int
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
c_isdigit	function
(	O
p	pointer
[	O
i	int
]	O
)	O
==	O
0	int
)	O
{	O
if	O
(	O
type	int
==	O
ASN1_ETYPE_GENERALIZED_TIME	int
)	O
{	O
if	O
(	O
p	pointer
[	O
i	int
]	O
==	O
'.'	O
&&	O
dot_count	int
==	O
0	int
)	O
{	O
dot_count	int
++	O
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
(	O
flags	int
&	O
ASN1_DECODE_FLAG_STRICT_DER	O
)	O
&&	O
(	O
p	pointer
[	O
i	int
]	O
==	O
'+'	O
||	O
p	pointer
[	O
i	int
]	O
==	O
'-'	O
)	O
&&	O
sign_count	int
==	O
0	int
)	O
{	O
sign_count	int
++	O
;	O
continue	O
;	O
}	O
}	O
warn	O
(	O
)	O
;	O
return	O
ASN1_TIME_ENCODING_ERROR	int
;	O
}	O
}	O
if	O
(	O
sign_count	int
==	O
0	int
&&	O
p	pointer
[	O
str_len	pointer
-	O
1	int
]	O
!=	O
'Z'	O
)	O
{	O
warn	O
(	O
)	O
;	O
return	O
ASN1_TIME_ENCODING_ERROR	int
;	O
}	O
}	O
memcpy	function
(	O
str	pointer
,	O
der	pointer
+	O
len_len	int
,	O
str_len	pointer
)	O
;	O
str	pointer
[	O
str_len	pointer
]	O
=	O
0	int
;	O
*	O
ret_len	pointer
=	O
str_len	pointer
+	O
len_len	int
;	O
return	O
ASN1_SUCCESS	int
;	O
}	O
int	O
asn1_get_object_id_der	function
(	O
const	O
unsigned	O
char	O
*	O
der	pointer
,	O
int	O
der_len	int
,	O
int	O
*	O
ret_len	pointer
,	O
char	O
*	O
str	pointer
,	O
int	O
str_size	int
)	O
{	O
int	O
len_len	int
,	O
len	int
,	O
k	int
;	O
int	O
leading	int
,	O
parsed	int
;	O
char	O
temp	array
[	O
LTOSTR_MAX_SIZE	int
]	O
;	O
uint64_t	long
val	long
,	O
val1	long
,	O
val0	long
;	O
*	O
ret_len	pointer
=	O
0	int
;	O
if	O
(	O
str	pointer
&&	O
str_size	int
>	O
0	int
)	O
str	pointer
[	O
0	int
]	O
=	O
0	int
;	O
if	O
(	O
str	pointer
==	O
NULL	O
||	O
der_len	int
<=	O
0	int
)	O
return	O
ASN1_GENERIC_ERROR	int
;	O
len	int
=	O
asn1_get_length_der	function
(	O
der	pointer
,	O
der_len	int
,	O
&	O
len_len	int
)	O
;	O
if	O
(	O
len	int
<=	O
0	int
||	O
len	int
+	O
len_len	int
>	O
der_len	int
)	O
return	O
ASN1_DER_ERROR	int
;	O
if	O
(	O
der	pointer
[	O
len_len	int
]	O
==	O
0x80	int
)	O
return	O
ASN1_DER_ERROR	int
;	O
val0	long
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
len	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
INT_LEFT_SHIFT_OVERFLOW	O
(	O
val0	long
,	O
7	int
)	O
)	O
return	O
ASN1_DER_ERROR	int
;	O
val0	long
<<=	O
7	int
;	O
val0	long
|=	O
der	pointer
[	O
len_len	int
+	O
k	int
]	O
&	O
0x7F	int
;	O
if	O
(	O
!	O
(	O
der	pointer
[	O
len_len	int
+	O
k	int
]	O
&	O
0x80	int
)	O
)	O
break	O
;	O
}	O
parsed	int
=	O
++	O
k	int
;	O
val	long
=	O
0	int
;	O
val1	long
=	O
val0	long
;	O
if	O
(	O
val1	long
>	O
39	int
)	O
{	O
val	long
=	O
1	int
;	O
val1	long
=	O
val0	long
-	O
40	int
;	O
if	O
(	O
val1	long
>	O
39	int
)	O
{	O
val	long
=	O
2	int
;	O
val1	long
=	O
val0	long
-	O
80	int
;	O
}	O
}	O
_asn1_str_cpy	function
(	O
str	pointer
,	O
str_size	int
,	O
_asn1_ltostr	function
(	O
val	long
,	O
temp	array
)	O
)	O
;	O
_asn1_str_cat	function
(	O
str	pointer
,	O
str_size	int
,	O
"."	pointer
)	O
;	O
_asn1_str_cat	function
(	O
str	pointer
,	O
str_size	int
,	O
_asn1_ltostr	function
(	O
val1	long
,	O
temp	array
)	O
)	O
;	O
val	long
=	O
0	int
;	O
leading	int
=	O
1	int
;	O
for	O
(	O
k	int
=	O
parsed	int
;	O
k	int
<	O
len	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
leading	int
!=	O
0	int
&&	O
der	pointer
[	O
len_len	int
+	O
k	int
]	O
==	O
0x80	int
)	O
return	O
ASN1_DER_ERROR	int
;	O
leading	int
=	O
0	int
;	O
if	O
(	O
INT_LEFT_SHIFT_OVERFLOW	O
(	O
val	long
,	O
7	int
)	O
)	O
return	O
ASN1_DER_ERROR	int
;	O
val	long
=	O
val	long
<<	O
7	int
;	O
val	long
|=	O
der	pointer
[	O
len_len	int
+	O
k	int
]	O
&	O
0x7F	int
;	O
if	O
(	O
!	O
(	O
der	pointer
[	O
len_len	int
+	O
k	int
]	O
&	O
0x80	int
)	O
)	O
{	O
_asn1_str_cat	function
(	O
str	pointer
,	O
str_size	int
,	O
"."	pointer
)	O
;	O
_asn1_str_cat	function
(	O
str	pointer
,	O
str_size	int
,	O
_asn1_ltostr	function
(	O
val	long
,	O
temp	array
)	O
)	O
;	O
val	long
=	O
0	int
;	O
leading	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
INT_ADD_OVERFLOW	O
(	O
len	int
,	O
len_len	int
)	O
)	O
return	O
ASN1_DER_ERROR	int
;	O
*	O
ret_len	pointer
=	O
len	int
+	O
len_len	int
;	O
return	O
ASN1_SUCCESS	int
;	O
}	O
int	O
asn1_get_bit_der	function
(	O
const	O
unsigned	O
char	O
*	O
der	pointer
,	O
int	O
der_len	int
,	O
int	O
*	O
ret_len	pointer
,	O
unsigned	O
char	O
*	O
str	pointer
,	O
int	O
str_size	int
,	O
int	O
*	O
bit_len	int
)	O
{	O
int	O
len_len	int
=	O
0	int
,	O
len_byte	int
;	O
if	O
(	O
der_len	int
<=	O
0	int
)	O
return	O
ASN1_GENERIC_ERROR	int
;	O
len_byte	int
=	O
asn1_get_length_der	function
(	O
der	pointer
,	O
der_len	int
,	O
&	O
len_len	int
)	O
-	O
1	int
;	O
if	O
(	O
len_byte	int
<	O
0	int
)	O
return	O
ASN1_DER_ERROR	int
;	O
*	O
ret_len	pointer
=	O
len_byte	int
+	O
len_len	int
+	O
1	int
;	O
*	O
bit_len	int
=	O
len_byte	int
*	O
8	int
-	O
der	pointer
[	O
len_len	int
]	O
;	O
if	O
(	O
*	O
bit_len	int
<	O
0	int
)	O
return	O
ASN1_DER_ERROR	int
;	O
if	O
(	O
str_size	int
>=	O
len_byte	int
)	O
{	O
if	O
(	O
len_byte	int
>	O
0	int
&&	O
str	pointer
)	O
memcpy	function
(	O
str	pointer
,	O
der	pointer
+	O
len_len	int
+	O
1	int
,	O
len_byte	int
)	O
;	O
}	O
else	O
{	O
return	O
ASN1_MEM_ERROR	int
;	O
}	O
return	O
ASN1_SUCCESS	int
;	O
}	O
static	O
int	O
_asn1_extract_tag_der	function
(	O
asn1_node	pointer
node	pointer
,	O
const	O
unsigned	O
char	O
*	O
der	pointer
,	O
int	O
der_len	int
,	O
int	O
*	O
tag_len	pointer
,	O
int	O
*	O
inner_tag_len	pointer
,	O
unsigned	O
flags	int
)	O
{	O
asn1_node	pointer
p	pointer
;	O
int	O
counter	int
,	O
len2	int
,	O
len3	int
,	O
is_tag_implicit	int
;	O
int	O
result	int
;	O
unsigned	O
long	O
tag	pointer
,	O
tag_implicit	long
=	O
0	int
;	O
unsigned	O
char	O
class	int
,	O
class2	char
,	O
class_implicit	char
=	O
0	int
;	O
if	O
(	O
der_len	int
<=	O
0	int
)	O
return	O
ASN1_GENERIC_ERROR	int
;	O
counter	int
=	O
is_tag_implicit	int
=	O
0	int
;	O
if	O
(	O
node	pointer
->	O
type	int
&	O
CONST_TAG	O
)	O
{	O
p	pointer
=	O
node	pointer
->	O
down	pointer
;	O
while	O
(	O
p	pointer
)	O
{	O
if	O
(	O
type_field	function
(	O
p	pointer
->	O
type	int
)	O
==	O
ASN1_ETYPE_TAG	int
)	O
{	O
if	O
(	O
p	pointer
->	O
type	int
&	O
CONST_APPLICATION	O
)	O
class2	char
=	O
ASN1_CLASS_APPLICATION	int
;	O
else	O
if	O
(	O
p	pointer
->	O
type	int
&	O
CONST_UNIVERSAL	O
)	O
class2	char
=	O
ASN1_CLASS_UNIVERSAL	int
;	O
else	O
if	O
(	O
p	pointer
->	O
type	int
&	O
CONST_PRIVATE	O
)	O
class2	char
=	O
ASN1_CLASS_PRIVATE	int
;	O
else	O
class2	char
=	O
ASN1_CLASS_CONTEXT_SPECIFIC	int
;	O
if	O
(	O
p	pointer
->	O
type	int
&	O
CONST_EXPLICIT	O
)	O
{	O
if	O
(	O
asn1_get_tag_der	function
(	O
der	pointer
+	O
counter	int
,	O
der_len	int
,	O
&	O
class	int
,	O
&	O
len2	int
,	O
&	O
tag	pointer
)	O
!=	O
ASN1_SUCCESS	int
)	O
return	O
ASN1_DER_ERROR	int
;	O
DECR_LEN	O
(	O
der_len	int
,	O
len2	int
)	O
;	O
counter	int
+=	O
len2	int
;	O
if	O
(	O
flags	int
&	O
ASN1_DECODE_FLAG_STRICT_DER	O
)	O
len3	int
=	O
asn1_get_length_der	function
(	O
der	pointer
+	O
counter	int
,	O
der_len	int
,	O
&	O
len2	int
)	O
;	O
else	O
len3	int
=	O
asn1_get_length_ber	function
(	O
der	pointer
+	O
counter	int
,	O
der_len	int
,	O
&	O
len2	int
)	O
;	O
if	O
(	O
len3	int
<	O
0	int
)	O
return	O
ASN1_DER_ERROR	int
;	O
DECR_LEN	O
(	O
der_len	int
,	O
len2	int
)	O
;	O
counter	int
+=	O
len2	int
;	O
if	O
(	O
!	O
is_tag_implicit	int
)	O
{	O
if	O
(	O
(	O
class	int
!=	O
(	O
class2	char
|	O
ASN1_CLASS_STRUCTURED	int
)	O
)	O
||	O
(	O
tag	pointer
!=	O
strtoul	function
(	O
(	O
char	O
*	O
)	O
p	pointer
->	O
value	pointer
,	O
NULL	O
,	O
10	int
)	O
)	O
)	O
return	O
ASN1_TAG_ERROR	int
;	O
}	O
else	O
{	O
if	O
(	O
(	O
class	int
!=	O
class_implicit	char
)	O
||	O
(	O
tag	pointer
!=	O
tag_implicit	long
)	O
)	O
return	O
ASN1_TAG_ERROR	int
;	O
}	O
is_tag_implicit	int
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
is_tag_implicit	int
)	O
{	O
if	O
(	O
(	O
type_field	function
(	O
node	pointer
->	O
type	int
)	O
==	O
ASN1_ETYPE_SEQUENCE	int
)	O
||	O
(	O
type_field	function
(	O
node	pointer
->	O
type	int
)	O
==	O
ASN1_ETYPE_SEQUENCE_OF	int
)	O
||	O
(	O
type_field	function
(	O
node	pointer
->	O
type	int
)	O
==	O
ASN1_ETYPE_SET	int
)	O
||	O
(	O
type_field	function
(	O
node	pointer
->	O
type	int
)	O
==	O
ASN1_ETYPE_SET_OF	int
)	O
)	O
class2	char
|=	O
ASN1_CLASS_STRUCTURED	int
;	O
class_implicit	char
=	O
class2	char
;	O
tag_implicit	long
=	O
strtoul	function
(	O
(	O
char	O
*	O
)	O
p	pointer
->	O
value	pointer
,	O
NULL	O
,	O
10	int
)	O
;	O
is_tag_implicit	int
=	O
1	int
;	O
}	O
}	O
}	O
p	pointer
=	O
p	pointer
->	O
right	pointer
;	O
}	O
}	O
if	O
(	O
is_tag_implicit	int
)	O
{	O
if	O
(	O
asn1_get_tag_der	function
(	O
der	pointer
+	O
counter	int
,	O
der_len	int
,	O
&	O
class	int
,	O
&	O
len2	int
,	O
&	O
tag	pointer
)	O
!=	O
ASN1_SUCCESS	int
)	O
return	O
ASN1_DER_ERROR	int
;	O
DECR_LEN	O
(	O
der_len	int
,	O
len2	int
)	O
;	O
if	O
(	O
(	O
class	int
!=	O
class_implicit	char
)	O
||	O
(	O
tag	pointer
!=	O
tag_implicit	long
)	O
)	O
{	O
if	O
(	O
type_field	function
(	O
node	pointer
->	O
type	int
)	O
==	O
ASN1_ETYPE_OCTET_STRING	int
)	O
{	O
class_implicit	char
|=	O
ASN1_CLASS_STRUCTURED	int
;	O
if	O
(	O
(	O
class	int
!=	O
class_implicit	char
)	O
||	O
(	O
tag	pointer
!=	O
tag_implicit	long
)	O
)	O
return	O
ASN1_TAG_ERROR	int
;	O
}	O
else	O
return	O
ASN1_TAG_ERROR	int
;	O
}	O
}	O
else	O
{	O
unsigned	O
type	int
=	O
type_field	function
(	O
node	pointer
->	O
type	int
)	O
;	O
if	O
(	O
type	int
==	O
ASN1_ETYPE_TAG	int
)	O
{	O
*	O
tag_len	pointer
=	O
0	int
;	O
if	O
(	O
inner_tag_len	pointer
)	O
*	O
inner_tag_len	pointer
=	O
0	int
;	O
return	O
ASN1_SUCCESS	int
;	O
}	O
if	O
(	O
asn1_get_tag_der	function
(	O
der	pointer
+	O
counter	int
,	O
der_len	int
,	O
&	O
class	int
,	O
&	O
len2	int
,	O
&	O
tag	pointer
)	O
!=	O
ASN1_SUCCESS	int
)	O
return	O
ASN1_DER_ERROR	int
;	O
DECR_LEN	O
(	O
der_len	int
,	O
len2	int
)	O
;	O
switch	O
(	O
type	int
)	O
{	O
case	O
ASN1_ETYPE_NULL	int
:	O
case	O
ASN1_ETYPE_BOOLEAN	int
:	O
case	O
ASN1_ETYPE_INTEGER	int
:	O
case	O
ASN1_ETYPE_ENUMERATED	int
:	O
case	O
ASN1_ETYPE_OBJECT_ID	int
:	O
case	O
ASN1_ETYPE_GENERALSTRING	int
:	O
case	O
ASN1_ETYPE_NUMERIC_STRING	int
:	O
case	O
ASN1_ETYPE_IA5_STRING	int
:	O
case	O
ASN1_ETYPE_TELETEX_STRING	int
:	O
case	O
ASN1_ETYPE_PRINTABLE_STRING	int
:	O
case	O
ASN1_ETYPE_UNIVERSAL_STRING	int
:	O
case	O
ASN1_ETYPE_BMP_STRING	int
:	O
case	O
ASN1_ETYPE_UTF8_STRING	int
:	O
case	O
ASN1_ETYPE_VISIBLE_STRING	int
:	O
case	O
ASN1_ETYPE_BIT_STRING	int
:	O
case	O
ASN1_ETYPE_SEQUENCE	int
:	O
case	O
ASN1_ETYPE_SEQUENCE_OF	int
:	O
case	O
ASN1_ETYPE_SET	int
:	O
case	O
ASN1_ETYPE_SET_OF	int
:	O
case	O
ASN1_ETYPE_GENERALIZED_TIME	int
:	O
case	O
ASN1_ETYPE_UTC_TIME	int
:	O
if	O
(	O
(	O
class	int
!=	O
_asn1_tags	array
[	O
type	int
]	O
.	O
class	int
)	O
||	O
(	O
tag	pointer
!=	O
_asn1_tags	array
[	O
type	int
]	O
.	O
tag	pointer
)	O
)	O
return	O
ASN1_DER_ERROR	int
;	O
break	O
;	O
case	O
ASN1_ETYPE_OCTET_STRING	int
:	O
if	O
(	O
(	O
(	O
class	int
!=	O
ASN1_CLASS_UNIVERSAL	int
)	O
&&	O
(	O
class	int
!=	O
(	O
ASN1_CLASS_UNIVERSAL	int
|	O
ASN1_CLASS_STRUCTURED	int
)	O
)	O
)	O
||	O
(	O
tag	pointer
!=	O
ASN1_TAG_OCTET_STRING	int
)	O
)	O
return	O
ASN1_DER_ERROR	int
;	O
break	O
;	O
case	O
ASN1_ETYPE_ANY	int
:	O
counter	int
-=	O
len2	int
;	O
break	O
;	O
case	O
ASN1_ETYPE_CHOICE	int
:	O
counter	int
-=	O
len2	int
;	O
break	O
;	O
default	O
:	O
return	O
ASN1_DER_ERROR	int
;	O
break	O
;	O
}	O
}	O
counter	int
+=	O
len2	int
;	O
*	O
tag_len	pointer
=	O
counter	int
;	O
if	O
(	O
inner_tag_len	pointer
)	O
*	O
inner_tag_len	pointer
=	O
len2	int
;	O
return	O
ASN1_SUCCESS	int
;	O
cleanup	O
:	O
return	O
result	int
;	O
}	O
static	O
int	O
extract_tag_der_recursive	function
(	O
asn1_node	pointer
node	pointer
,	O
const	O
unsigned	O
char	O
*	O
der	pointer
,	O
int	O
der_len	int
,	O
int	O
*	O
ret_len	pointer
,	O
int	O
*	O
inner_len	pointer
,	O
unsigned	O
flags	int
)	O
{	O
asn1_node	pointer
p	pointer
;	O
int	O
ris	int
=	O
ASN1_DER_ERROR	int
;	O
if	O
(	O
type_field	function
(	O
node	pointer
->	O
type	int
)	O
==	O
ASN1_ETYPE_CHOICE	int
)	O
{	O
p	pointer
=	O
node	pointer
->	O
down	pointer
;	O
while	O
(	O
p	pointer
)	O
{	O
ris	int
=	O
_asn1_extract_tag_der	function
(	O
p	pointer
,	O
der	pointer
,	O
der_len	int
,	O
ret_len	pointer
,	O
inner_len	pointer
,	O
flags	int
)	O
;	O
if	O
(	O
ris	int
==	O
ASN1_SUCCESS	int
)	O
break	O
;	O
p	pointer
=	O
p	pointer
->	O
right	pointer
;	O
}	O
*	O
ret_len	pointer
=	O
0	int
;	O
return	O
ris	int
;	O
}	O
else	O
return	O
_asn1_extract_tag_der	function
(	O
node	pointer
,	O
der	pointer
,	O
der_len	int
,	O
ret_len	pointer
,	O
inner_len	pointer
,	O
flags	int
)	O
;	O
}	O
static	O
int	O
_asn1_delete_not_used	function
(	O
asn1_node	pointer
node	pointer
)	O
{	O
asn1_node	pointer
p	pointer
,	O
p2	pointer
;	O
if	O
(	O
node	pointer
==	O
NULL	O
)	O
return	O
ASN1_ELEMENT_NOT_FOUND	int
;	O
p	pointer
=	O
node	pointer
;	O
while	O
(	O
p	pointer
)	O
{	O
if	O
(	O
p	pointer
->	O
type	int
&	O
CONST_NOT_USED	O
)	O
{	O
p2	pointer
=	O
NULL	O
;	O
if	O
(	O
p	pointer
!=	O
node	pointer
)	O
{	O
p2	pointer
=	O
_asn1_find_left	function
(	O
p	pointer
)	O
;	O
if	O
(	O
!	O
p2	pointer
)	O
p2	pointer
=	O
_asn1_find_up	function
(	O
p	pointer
)	O
;	O
}	O
asn1_delete_structure	function
(	O
&	O
p	pointer
)	O
;	O
p	pointer
=	O
p2	pointer
;	O
}	O
if	O
(	O
!	O
p	pointer
)	O
break	O
;	O
if	O
(	O
p	pointer
->	O
down	pointer
)	O
{	O
p	pointer
=	O
p	pointer
->	O
down	pointer
;	O
}	O
else	O
{	O
if	O
(	O
p	pointer
==	O
node	pointer
)	O
p	pointer
=	O
NULL	O
;	O
else	O
if	O
(	O
p	pointer
->	O
right	pointer
)	O
p	pointer
=	O
p	pointer
->	O
right	pointer
;	O
else	O
{	O
while	O
(	O
1	int
)	O
{	O
p	pointer
=	O
_asn1_find_up	function
(	O
p	pointer
)	O
;	O
if	O
(	O
p	pointer
==	O
node	pointer
)	O
{	O
p	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
if	O
(	O
p	pointer
->	O
right	pointer
)	O
{	O
p	pointer
=	O
p	pointer
->	O
right	pointer
;	O
break	O
;	O
}	O
}	O
}	O
}	O
}	O
return	O
ASN1_SUCCESS	int
;	O
}	O
static	O
int	O
_asn1_get_indefinite_length_string	function
(	O
const	O
unsigned	O
char	O
*	O
der	pointer
,	O
int	O
der_len	int
,	O
int	O
*	O
len	int
)	O
{	O
int	O
len2	int
,	O
len3	int
,	O
counter	int
,	O
indefinite	int
;	O
int	O
result	int
;	O
unsigned	O
long	O
tag	pointer
;	O
unsigned	O
char	O
class	int
;	O
counter	int
=	O
indefinite	int
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
HAVE_TWO	O
(	O
der_len	int
)	O
&&	O
(	O
der	pointer
[	O
counter	int
]	O
==	O
0	int
)	O
&&	O
(	O
der	pointer
[	O
counter	int
+	O
1	int
]	O
==	O
0	int
)	O
)	O
{	O
counter	int
+=	O
2	int
;	O
DECR_LEN	O
(	O
der_len	int
,	O
2	int
)	O
;	O
indefinite	int
--	O
;	O
if	O
(	O
indefinite	int
<=	O
0	int
)	O
break	O
;	O
else	O
continue	O
;	O
}	O
if	O
(	O
asn1_get_tag_der	function
(	O
der	pointer
+	O
counter	int
,	O
der_len	int
,	O
&	O
class	int
,	O
&	O
len2	int
,	O
&	O
tag	pointer
)	O
!=	O
ASN1_SUCCESS	int
)	O
return	O
ASN1_DER_ERROR	int
;	O
DECR_LEN	O
(	O
der_len	int
,	O
len2	int
)	O
;	O
counter	int
+=	O
len2	int
;	O
len2	int
=	O
asn1_get_length_der	function
(	O
der	pointer
+	O
counter	int
,	O
der_len	int
,	O
&	O
len3	int
)	O
;	O
if	O
(	O
len2	int
<	O
-	O
1	int
)	O
return	O
ASN1_DER_ERROR	int
;	O
if	O
(	O
len2	int
==	O
-	O
1	int
)	O
{	O
indefinite	int
++	O
;	O
counter	int
+=	O
1	int
;	O
DECR_LEN	O
(	O
der_len	int
,	O
1	int
)	O
;	O
}	O
else	O
{	O
counter	int
+=	O
len2	int
+	O
len3	int
;	O
DECR_LEN	O
(	O
der_len	int
,	O
len2	int
+	O
len3	int
)	O
;	O
}	O
}	O
*	O
len	int
=	O
counter	int
;	O
return	O
ASN1_SUCCESS	int
;	O
cleanup	O
:	O
return	O
result	int
;	O
}	O
static	O
void	O
delete_unneeded_choice_fields	function
(	O
asn1_node	pointer
p	pointer
)	O
{	O
asn1_node	pointer
p2	pointer
;	O
while	O
(	O
p	pointer
->	O
right	pointer
)	O
{	O
p2	pointer
=	O
p	pointer
->	O
right	pointer
;	O
asn1_delete_structure	function
(	O
&	O
p2	pointer
)	O
;	O
}	O
}	O
int	O
asn1_der_decoding2	function
(	O
asn1_node	pointer
*	O
element	pointer
,	O
const	O
void	O
*	O
ider	pointer
,	O
int	O
*	O
max_ider_len	pointer
,	O
unsigned	O
int	O
flags	int
,	O
char	O
*	O
errorDescription	pointer
)	O
{	O
asn1_node	pointer
node	pointer
,	O
p	pointer
,	O
p2	pointer
,	O
p3	pointer
;	O
char	O
temp	array
[	O
128	int
]	O
;	O
int	O
counter	int
,	O
len2	int
,	O
len3	int
,	O
len4	int
,	O
move	int
,	O
ris	int
,	O
tlen	int
;	O
struct	O
node_tail_cache_st	struct
tcache	struct
=	O
{	O
NULL	O
,	O
NULL	O
}	O
;	O
unsigned	O
char	O
class	int
;	O
unsigned	O
long	O
tag	pointer
;	O
int	O
tag_len	pointer
;	O
int	O
indefinite	int
,	O
result	int
,	O
total_len	int
=	O
*	O
max_ider_len	pointer
,	O
ider_len	int
=	O
*	O
max_ider_len	pointer
;	O
int	O
inner_tag_len	pointer
;	O
unsigned	O
char	O
*	O
ptmp	pointer
;	O
const	O
unsigned	O
char	O
*	O
ptag	pointer
;	O
const	O
unsigned	O
char	O
*	O
der	pointer
=	O
ider	pointer
;	O
node	pointer
=	O
*	O
element	pointer
;	O
if	O
(	O
errorDescription	pointer
!=	O
NULL	O
)	O
errorDescription	pointer
[	O
0	int
]	O
=	O
0	int
;	O
if	O
(	O
node	pointer
==	O
NULL	O
)	O
return	O
ASN1_ELEMENT_NOT_FOUND	int
;	O
if	O
(	O
node	pointer
->	O
type	int
&	O
CONST_OPTION	O
)	O
{	O
result	int
=	O
ASN1_GENERIC_ERROR	int
;	O
warn	O
(	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
counter	int
=	O
0	int
;	O
move	int
=	O
DOWN	int
;	O
p	pointer
=	O
node	pointer
;	O
while	O
(	O
1	int
)	O
{	O
tag_len	pointer
=	O
0	int
;	O
inner_tag_len	pointer
=	O
0	int
;	O
ris	int
=	O
ASN1_SUCCESS	int
;	O
if	O
(	O
move	int
!=	O
UP	int
)	O
{	O
if	O
(	O
p	pointer
->	O
type	int
&	O
CONST_SET	O
)	O
{	O
p2	pointer
=	O
_asn1_find_up	function
(	O
p	pointer
)	O
;	O
len2	int
=	O
p2	pointer
->	O
tmp_ival	int
;	O
if	O
(	O
len2	int
==	O
-	O
1	int
)	O
{	O
if	O
(	O
HAVE_TWO	O
(	O
ider_len	int
)	O
&&	O
!	O
der	pointer
[	O
counter	int
]	O
&&	O
!	O
der	pointer
[	O
counter	int
+	O
1	int
]	O
)	O
{	O
p	pointer
=	O
p2	pointer
;	O
move	int
=	O
UP	int
;	O
counter	int
+=	O
2	int
;	O
DECR_LEN	O
(	O
ider_len	int
,	O
2	int
)	O
;	O
continue	O
;	O
}	O
}	O
else	O
if	O
(	O
counter	int
==	O
len2	int
)	O
{	O
p	pointer
=	O
p2	pointer
;	O
move	int
=	O
UP	int
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
counter	int
>	O
len2	int
)	O
{	O
result	int
=	O
ASN1_DER_ERROR	int
;	O
warn	O
(	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
p2	pointer
=	O
p2	pointer
->	O
down	pointer
;	O
while	O
(	O
p2	pointer
)	O
{	O
if	O
(	O
(	O
p2	pointer
->	O
type	int
&	O
CONST_SET	O
)	O
&&	O
(	O
p2	pointer
->	O
type	int
&	O
CONST_NOT_USED	O
)	O
)	O
{	O
ris	int
=	O
extract_tag_der_recursive	function
(	O
p2	pointer
,	O
der	pointer
+	O
counter	int
,	O
ider_len	int
,	O
&	O
len2	int
,	O
NULL	O
,	O
flags	int
)	O
;	O
if	O
(	O
ris	int
==	O
ASN1_SUCCESS	int
)	O
{	O
p2	pointer
->	O
type	int
&=	O
~	O
CONST_NOT_USED	O
;	O
p	pointer
=	O
p2	pointer
;	O
break	O
;	O
}	O
}	O
p2	pointer
=	O
p2	pointer
->	O
right	pointer
;	O
}	O
if	O
(	O
p2	pointer
==	O
NULL	O
)	O
{	O
result	int
=	O
ASN1_DER_ERROR	int
;	O
warn	O
(	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
}	O
p	pointer
->	O
start	pointer
=	O
counter	int
;	O
p	pointer
->	O
end	pointer
=	O
total_len	int
-	O
1	int
;	O
if	O
(	O
(	O
p	pointer
->	O
type	int
&	O
CONST_OPTION	O
)	O
||	O
(	O
p	pointer
->	O
type	int
&	O
CONST_DEFAULT	O
)	O
)	O
{	O
p2	pointer
=	O
_asn1_find_up	function
(	O
p	pointer
)	O
;	O
len2	int
=	O
p2	pointer
->	O
tmp_ival	int
;	O
if	O
(	O
counter	int
==	O
len2	int
)	O
{	O
if	O
(	O
p	pointer
->	O
right	pointer
)	O
{	O
p2	pointer
=	O
p	pointer
->	O
right	pointer
;	O
move	int
=	O
RIGHT	int
;	O
}	O
else	O
move	int
=	O
UP	int
;	O
if	O
(	O
p	pointer
->	O
type	int
&	O
CONST_OPTION	O
)	O
asn1_delete_structure	function
(	O
&	O
p	pointer
)	O
;	O
p	pointer
=	O
p2	pointer
;	O
continue	O
;	O
}	O
}	O
if	O
(	O
type_field	function
(	O
p	pointer
->	O
type	int
)	O
==	O
ASN1_ETYPE_CHOICE	int
)	O
{	O
while	O
(	O
p	pointer
->	O
down	pointer
)	O
{	O
ris	int
=	O
extract_tag_der_recursive	function
(	O
p	pointer
->	O
down	pointer
,	O
der	pointer
+	O
counter	int
,	O
ider_len	int
,	O
&	O
len2	int
,	O
NULL	O
,	O
flags	int
)	O
;	O
if	O
(	O
ris	int
==	O
ASN1_SUCCESS	int
)	O
{	O
delete_unneeded_choice_fields	function
(	O
p	pointer
->	O
down	pointer
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
ris	int
==	O
ASN1_ERROR_TYPE_ANY	int
)	O
{	O
result	int
=	O
ASN1_ERROR_TYPE_ANY	int
;	O
warn	O
(	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
else	O
{	O
p2	pointer
=	O
p	pointer
->	O
down	pointer
;	O
asn1_delete_structure	function
(	O
&	O
p2	pointer
)	O
;	O
}	O
}	O
if	O
(	O
p	pointer
->	O
down	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
!	O
(	O
p	pointer
->	O
type	int
&	O
CONST_OPTION	O
)	O
)	O
{	O
result	int
=	O
ASN1_DER_ERROR	int
;	O
warn	O
(	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
}	O
else	O
if	O
(	O
type_field	function
(	O
p	pointer
->	O
type	int
)	O
!=	O
ASN1_ETYPE_CHOICE	int
)	O
p	pointer
=	O
p	pointer
->	O
down	pointer
;	O
p	pointer
->	O
start	pointer
=	O
counter	int
;	O
}	O
if	O
(	O
(	O
p	pointer
->	O
type	int
&	O
CONST_OPTION	O
)	O
||	O
(	O
p	pointer
->	O
type	int
&	O
CONST_DEFAULT	O
)	O
)	O
{	O
p2	pointer
=	O
_asn1_find_up	function
(	O
p	pointer
)	O
;	O
len2	int
=	O
p2	pointer
->	O
tmp_ival	int
;	O
if	O
(	O
(	O
len2	int
!=	O
-	O
1	int
)	O
&&	O
(	O
counter	int
>	O
len2	int
)	O
)	O
ris	int
=	O
ASN1_TAG_ERROR	int
;	O
}	O
if	O
(	O
ris	int
==	O
ASN1_SUCCESS	int
)	O
ris	int
=	O
extract_tag_der_recursive	function
(	O
p	pointer
,	O
der	pointer
+	O
counter	int
,	O
ider_len	int
,	O
&	O
tag_len	pointer
,	O
&	O
inner_tag_len	pointer
,	O
flags	int
)	O
;	O
if	O
(	O
ris	int
!=	O
ASN1_SUCCESS	int
)	O
{	O
if	O
(	O
p	pointer
->	O
type	int
&	O
CONST_OPTION	O
)	O
{	O
p	pointer
->	O
type	int
|=	O
CONST_NOT_USED	O
;	O
move	int
=	O
RIGHT	int
;	O
}	O
else	O
if	O
(	O
p	pointer
->	O
type	int
&	O
CONST_DEFAULT	O
)	O
{	O
_asn1_set_value	function
(	O
p	pointer
,	O
NULL	O
,	O
0	int
)	O
;	O
move	int
=	O
RIGHT	int
;	O
}	O
else	O
{	O
if	O
(	O
errorDescription	pointer
!=	O
NULL	O
)	O
_asn1_error_description_tag_error	function
(	O
p	pointer
,	O
errorDescription	pointer
)	O
;	O
result	int
=	O
ASN1_TAG_ERROR	int
;	O
warn	O
(	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
}	O
else	O
{	O
DECR_LEN	O
(	O
ider_len	int
,	O
tag_len	pointer
)	O
;	O
counter	int
+=	O
tag_len	pointer
;	O
}	O
}	O
if	O
(	O
ris	int
==	O
ASN1_SUCCESS	int
)	O
{	O
switch	O
(	O
type_field	function
(	O
p	pointer
->	O
type	int
)	O
)	O
{	O
case	O
ASN1_ETYPE_NULL	int
:	O
DECR_LEN	O
(	O
ider_len	int
,	O
1	int
)	O
;	O
if	O
(	O
der	pointer
[	O
counter	int
]	O
)	O
{	O
result	int
=	O
ASN1_DER_ERROR	int
;	O
warn	O
(	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
counter	int
++	O
;	O
move	int
=	O
RIGHT	int
;	O
break	O
;	O
case	O
ASN1_ETYPE_BOOLEAN	int
:	O
DECR_LEN	O
(	O
ider_len	int
,	O
2	int
)	O
;	O
if	O
(	O
der	pointer
[	O
counter	int
++	O
]	O
!=	O
1	int
)	O
{	O
result	int
=	O
ASN1_DER_ERROR	int
;	O
warn	O
(	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
if	O
(	O
der	pointer
[	O
counter	int
++	O
]	O
==	O
0	int
)	O
_asn1_set_value	function
(	O
p	pointer
,	O
"F"	pointer
,	O
1	int
)	O
;	O
else	O
_asn1_set_value	function
(	O
p	pointer
,	O
"T"	pointer
,	O
1	int
)	O
;	O
move	int
=	O
RIGHT	int
;	O
break	O
;	O
case	O
ASN1_ETYPE_INTEGER	int
:	O
case	O
ASN1_ETYPE_ENUMERATED	int
:	O
len2	int
=	O
asn1_get_length_der	function
(	O
der	pointer
+	O
counter	int
,	O
ider_len	int
,	O
&	O
len3	int
)	O
;	O
if	O
(	O
len2	int
<	O
0	int
)	O
{	O
result	int
=	O
ASN1_DER_ERROR	int
;	O
warn	O
(	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
DECR_LEN	O
(	O
ider_len	int
,	O
len3	int
+	O
len2	int
)	O
;	O
_asn1_set_value	function
(	O
p	pointer
,	O
der	pointer
+	O
counter	int
,	O
len3	int
+	O
len2	int
)	O
;	O
counter	int
+=	O
len3	int
+	O
len2	int
;	O
move	int
=	O
RIGHT	int
;	O
break	O
;	O
case	O
ASN1_ETYPE_OBJECT_ID	int
:	O
result	int
=	O
asn1_get_object_id_der	function
(	O
der	pointer
+	O
counter	int
,	O
ider_len	int
,	O
&	O
len2	int
,	O
temp	array
,	O
sizeof	O
(	O
temp	array
)	O
)	O
;	O
if	O
(	O
result	int
!=	O
ASN1_SUCCESS	int
)	O
{	O
warn	O
(	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
DECR_LEN	O
(	O
ider_len	int
,	O
len2	int
)	O
;	O
tlen	int
=	O
strlen	function
(	O
temp	array
)	O
;	O
if	O
(	O
tlen	int
>	O
0	int
)	O
_asn1_set_value	function
(	O
p	pointer
,	O
temp	array
,	O
tlen	int
+	O
1	int
)	O
;	O
counter	int
+=	O
len2	int
;	O
move	int
=	O
RIGHT	int
;	O
break	O
;	O
case	O
ASN1_ETYPE_GENERALIZED_TIME	int
:	O
case	O
ASN1_ETYPE_UTC_TIME	int
:	O
result	int
=	O
_asn1_get_time_der	function
(	O
type_field	function
(	O
p	pointer
->	O
type	int
)	O
,	O
der	pointer
+	O
counter	int
,	O
ider_len	int
,	O
&	O
len2	int
,	O
temp	array
,	O
sizeof	O
(	O
temp	array
)	O
-	O
1	int
,	O
flags	int
)	O
;	O
if	O
(	O
result	int
!=	O
ASN1_SUCCESS	int
)	O
{	O
warn	O
(	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
DECR_LEN	O
(	O
ider_len	int
,	O
len2	int
)	O
;	O
tlen	int
=	O
strlen	function
(	O
temp	array
)	O
;	O
if	O
(	O
tlen	int
>	O
0	int
)	O
_asn1_set_value	function
(	O
p	pointer
,	O
temp	array
,	O
tlen	int
)	O
;	O
counter	int
+=	O
len2	int
;	O
move	int
=	O
RIGHT	int
;	O
break	O
;	O
case	O
ASN1_ETYPE_OCTET_STRING	int
:	O
if	O
(	O
counter	int
<	O
inner_tag_len	pointer
)	O
{	O
result	int
=	O
ASN1_DER_ERROR	int
;	O
warn	O
(	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
ptag	pointer
=	O
der	pointer
+	O
counter	int
-	O
inner_tag_len	pointer
;	O
if	O
(	O
(	O
flags	int
&	O
ASN1_DECODE_FLAG_STRICT_DER	O
)	O
||	O
!	O
(	O
ptag	pointer
[	O
0	int
]	O
&	O
ASN1_CLASS_STRUCTURED	int
)	O
)	O
{	O
if	O
(	O
ptag	pointer
[	O
0	int
]	O
&	O
ASN1_CLASS_STRUCTURED	int
)	O
{	O
result	int
=	O
ASN1_DER_ERROR	int
;	O
warn	O
(	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
len2	int
=	O
asn1_get_length_der	function
(	O
der	pointer
+	O
counter	int
,	O
ider_len	int
,	O
&	O
len3	int
)	O
;	O
if	O
(	O
len2	int
<	O
0	int
)	O
{	O
result	int
=	O
ASN1_DER_ERROR	int
;	O
warn	O
(	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
DECR_LEN	O
(	O
ider_len	int
,	O
len3	int
+	O
len2	int
)	O
;	O
_asn1_set_value	function
(	O
p	pointer
,	O
der	pointer
+	O
counter	int
,	O
len3	int
+	O
len2	int
)	O
;	O
counter	int
+=	O
len3	int
+	O
len2	int
;	O
}	O
else	O
{	O
unsigned	O
dflags	int
=	O
0	int
,	O
vlen	int
,	O
ber_len	int
;	O
if	O
(	O
ptag	pointer
[	O
0	int
]	O
&	O
ASN1_CLASS_STRUCTURED	int
)	O
dflags	int
|=	O
DECODE_FLAG_CONSTRUCTED	O
;	O
result	int
=	O
_asn1_decode_simple_ber	function
(	O
type_field	function
(	O
p	pointer
->	O
type	int
)	O
,	O
der	pointer
+	O
counter	int
,	O
ider_len	int
,	O
&	O
ptmp	pointer
,	O
&	O
vlen	int
,	O
&	O
ber_len	int
,	O
dflags	int
)	O
;	O
if	O
(	O
result	int
!=	O
ASN1_SUCCESS	int
)	O
{	O
warn	O
(	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
DECR_LEN	O
(	O
ider_len	int
,	O
ber_len	int
)	O
;	O
_asn1_set_value_lv	function
(	O
p	pointer
,	O
ptmp	pointer
,	O
vlen	int
)	O
;	O
counter	int
+=	O
ber_len	int
;	O
free	function
(	O
ptmp	pointer
)	O
;	O
}	O
move	int
=	O
RIGHT	int
;	O
break	O
;	O
case	O
ASN1_ETYPE_GENERALSTRING	int
:	O
case	O
ASN1_ETYPE_NUMERIC_STRING	int
:	O
case	O
ASN1_ETYPE_IA5_STRING	int
:	O
case	O
ASN1_ETYPE_TELETEX_STRING	int
:	O
case	O
ASN1_ETYPE_PRINTABLE_STRING	int
:	O
case	O
ASN1_ETYPE_UNIVERSAL_STRING	int
:	O
case	O
ASN1_ETYPE_BMP_STRING	int
:	O
case	O
ASN1_ETYPE_UTF8_STRING	int
:	O
case	O
ASN1_ETYPE_VISIBLE_STRING	int
:	O
case	O
ASN1_ETYPE_BIT_STRING	int
:	O
len2	int
=	O
asn1_get_length_der	function
(	O
der	pointer
+	O
counter	int
,	O
ider_len	int
,	O
&	O
len3	int
)	O
;	O
if	O
(	O
len2	int
<	O
0	int
)	O
{	O
result	int
=	O
ASN1_DER_ERROR	int
;	O
warn	O
(	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
DECR_LEN	O
(	O
ider_len	int
,	O
len3	int
+	O
len2	int
)	O
;	O
_asn1_set_value	function
(	O
p	pointer
,	O
der	pointer
+	O
counter	int
,	O
len3	int
+	O
len2	int
)	O
;	O
counter	int
+=	O
len3	int
+	O
len2	int
;	O
move	int
=	O
RIGHT	int
;	O
break	O
;	O
case	O
ASN1_ETYPE_SEQUENCE	int
:	O
case	O
ASN1_ETYPE_SET	int
:	O
if	O
(	O
move	int
==	O
UP	int
)	O
{	O
len2	int
=	O
p	pointer
->	O
tmp_ival	int
;	O
p	pointer
->	O
tmp_ival	int
=	O
0	int
;	O
if	O
(	O
len2	int
==	O
-	O
1	int
)	O
{	O
DECR_LEN	O
(	O
ider_len	int
,	O
2	int
)	O
;	O
if	O
(	O
(	O
der	pointer
[	O
counter	int
]	O
)	O
||	O
der	pointer
[	O
counter	int
+	O
1	int
]	O
)	O
{	O
result	int
=	O
ASN1_DER_ERROR	int
;	O
warn	O
(	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
counter	int
+=	O
2	int
;	O
}	O
else	O
{	O
if	O
(	O
len2	int
!=	O
counter	int
)	O
{	O
result	int
=	O
ASN1_DER_ERROR	int
;	O
warn	O
(	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
}	O
move	int
=	O
RIGHT	int
;	O
}	O
else	O
{	O
len3	int
=	O
asn1_get_length_der	function
(	O
der	pointer
+	O
counter	int
,	O
ider_len	int
,	O
&	O
len2	int
)	O
;	O
if	O
(	O
IS_ERR	O
(	O
len3	int
,	O
flags	int
)	O
)	O
{	O
result	int
=	O
ASN1_DER_ERROR	int
;	O
warn	O
(	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
DECR_LEN	O
(	O
ider_len	int
,	O
len2	int
)	O
;	O
counter	int
+=	O
len2	int
;	O
if	O
(	O
len3	int
>	O
0	int
)	O
{	O
p	pointer
->	O
tmp_ival	int
=	O
counter	int
+	O
len3	int
;	O
move	int
=	O
DOWN	int
;	O
}	O
else	O
if	O
(	O
len3	int
==	O
0	int
)	O
{	O
p2	pointer
=	O
p	pointer
->	O
down	pointer
;	O
while	O
(	O
p2	pointer
)	O
{	O
if	O
(	O
type_field	function
(	O
p2	pointer
->	O
type	int
)	O
!=	O
ASN1_ETYPE_TAG	int
)	O
{	O
p3	pointer
=	O
p2	pointer
->	O
right	pointer
;	O
asn1_delete_structure	function
(	O
&	O
p2	pointer
)	O
;	O
p2	pointer
=	O
p3	pointer
;	O
}	O
else	O
p2	pointer
=	O
p2	pointer
->	O
right	pointer
;	O
}	O
move	int
=	O
RIGHT	int
;	O
}	O
else	O
{	O
p	pointer
->	O
tmp_ival	int
=	O
-	O
1	int
;	O
move	int
=	O
DOWN	int
;	O
}	O
}	O
break	O
;	O
case	O
ASN1_ETYPE_SEQUENCE_OF	int
:	O
case	O
ASN1_ETYPE_SET_OF	int
:	O
if	O
(	O
move	int
==	O
UP	int
)	O
{	O
len2	int
=	O
p	pointer
->	O
tmp_ival	int
;	O
if	O
(	O
len2	int
==	O
-	O
1	int
)	O
{	O
if	O
(	O
!	O
HAVE_TWO	O
(	O
ider_len	int
)	O
||	O
(	O
(	O
der	pointer
[	O
counter	int
]	O
)	O
||	O
der	pointer
[	O
counter	int
+	O
1	int
]	O
)	O
)	O
{	O
result	int
=	O
_asn1_append_sequence_set	function
(	O
p	pointer
,	O
&	O
tcache	struct
)	O
;	O
if	O
(	O
result	int
!=	O
0	int
)	O
{	O
warn	O
(	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
p	pointer
=	O
tcache	struct
.	O
tail	pointer
;	O
move	int
=	O
RIGHT	int
;	O
continue	O
;	O
}	O
p	pointer
->	O
tmp_ival	int
=	O
0	int
;	O
tcache	struct
.	O
tail	pointer
=	O
NULL	O
;	O
tcache	struct
.	O
head	pointer
=	O
NULL	O
;	O
DECR_LEN	O
(	O
ider_len	int
,	O
2	int
)	O
;	O
counter	int
+=	O
2	int
;	O
}	O
else	O
{	O
if	O
(	O
len2	int
>	O
counter	int
)	O
{	O
result	int
=	O
_asn1_append_sequence_set	function
(	O
p	pointer
,	O
&	O
tcache	struct
)	O
;	O
if	O
(	O
result	int
!=	O
0	int
)	O
{	O
warn	O
(	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
p	pointer
=	O
tcache	struct
.	O
tail	pointer
;	O
move	int
=	O
RIGHT	int
;	O
continue	O
;	O
}	O
p	pointer
->	O
tmp_ival	int
=	O
0	int
;	O
tcache	struct
.	O
tail	pointer
=	O
NULL	O
;	O
tcache	struct
.	O
head	pointer
=	O
NULL	O
;	O
if	O
(	O
len2	int
!=	O
counter	int
)	O
{	O
result	int
=	O
ASN1_DER_ERROR	int
;	O
warn	O
(	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
}	O
}	O
else	O
{	O
len3	int
=	O
asn1_get_length_der	function
(	O
der	pointer
+	O
counter	int
,	O
ider_len	int
,	O
&	O
len2	int
)	O
;	O
if	O
(	O
IS_ERR	O
(	O
len3	int
,	O
flags	int
)	O
)	O
{	O
result	int
=	O
ASN1_DER_ERROR	int
;	O
warn	O
(	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
DECR_LEN	O
(	O
ider_len	int
,	O
len2	int
)	O
;	O
counter	int
+=	O
len2	int
;	O
if	O
(	O
len3	int
)	O
{	O
if	O
(	O
len3	int
>	O
0	int
)	O
{	O
p	pointer
->	O
tmp_ival	int
=	O
counter	int
+	O
len3	int
;	O
}	O
else	O
{	O
p	pointer
->	O
tmp_ival	int
=	O
-	O
1	int
;	O
}	O
p2	pointer
=	O
p	pointer
->	O
down	pointer
;	O
if	O
(	O
p2	pointer
==	O
NULL	O
)	O
{	O
result	int
=	O
ASN1_DER_ERROR	int
;	O
warn	O
(	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
while	O
(	O
(	O
type_field	function
(	O
p2	pointer
->	O
type	int
)	O
==	O
ASN1_ETYPE_TAG	int
)	O
||	O
(	O
type_field	function
(	O
p2	pointer
->	O
type	int
)	O
==	O
ASN1_ETYPE_SIZE	int
)	O
)	O
p2	pointer
=	O
p2	pointer
->	O
right	pointer
;	O
if	O
(	O
p2	pointer
->	O
right	pointer
==	O
NULL	O
)	O
{	O
result	int
=	O
_asn1_append_sequence_set	function
(	O
p	pointer
,	O
&	O
tcache	struct
)	O
;	O
if	O
(	O
result	int
!=	O
0	int
)	O
{	O
warn	O
(	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
}	O
p	pointer
=	O
p2	pointer
;	O
}	O
}	O
move	int
=	O
RIGHT	int
;	O
break	O
;	O
case	O
ASN1_ETYPE_ANY	int
:	O
if	O
(	O
!	O
(	O
flags	int
&	O
ASN1_DECODE_FLAG_STRICT_DER	O
)	O
&&	O
(	O
p	pointer
->	O
type	int
&	O
CONST_TAG	O
)	O
&&	O
tag_len	pointer
==	O
2	int
&&	O
(	O
der	pointer
[	O
counter	int
-	O
1	int
]	O
==	O
0x80	int
)	O
)	O
indefinite	int
=	O
1	int
;	O
else	O
indefinite	int
=	O
0	int
;	O
if	O
(	O
asn1_get_tag_der	function
(	O
der	pointer
+	O
counter	int
,	O
ider_len	int
,	O
&	O
class	int
,	O
&	O
len2	int
,	O
&	O
tag	pointer
)	O
!=	O
ASN1_SUCCESS	int
)	O
{	O
result	int
=	O
ASN1_DER_ERROR	int
;	O
warn	O
(	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
DECR_LEN	O
(	O
ider_len	int
,	O
len2	int
)	O
;	O
len4	int
=	O
asn1_get_length_der	function
(	O
der	pointer
+	O
counter	int
+	O
len2	int
,	O
ider_len	int
,	O
&	O
len3	int
)	O
;	O
if	O
(	O
IS_ERR	O
(	O
len4	int
,	O
flags	int
)	O
)	O
{	O
result	int
=	O
ASN1_DER_ERROR	int
;	O
warn	O
(	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
if	O
(	O
len4	int
!=	O
-	O
1	int
)	O
{	O
len2	int
+=	O
len4	int
;	O
DECR_LEN	O
(	O
ider_len	int
,	O
len4	int
+	O
len3	int
)	O
;	O
_asn1_set_value_lv	function
(	O
p	pointer
,	O
der	pointer
+	O
counter	int
,	O
len2	int
+	O
len3	int
)	O
;	O
counter	int
+=	O
len2	int
+	O
len3	int
;	O
}	O
else	O
{	O
ider_len	int
+=	O
len2	int
;	O
if	O
(	O
counter	int
==	O
0	int
)	O
{	O
result	int
=	O
ASN1_DER_ERROR	int
;	O
warn	O
(	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
result	int
=	O
_asn1_get_indefinite_length_string	function
(	O
der	pointer
+	O
counter	int
,	O
ider_len	int
,	O
&	O
len2	int
)	O
;	O
if	O
(	O
result	int
!=	O
ASN1_SUCCESS	int
)	O
{	O
warn	O
(	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
DECR_LEN	O
(	O
ider_len	int
,	O
len2	int
)	O
;	O
_asn1_set_value_lv	function
(	O
p	pointer
,	O
der	pointer
+	O
counter	int
,	O
len2	int
)	O
;	O
counter	int
+=	O
len2	int
;	O
}	O
if	O
(	O
indefinite	int
)	O
{	O
DECR_LEN	O
(	O
ider_len	int
,	O
2	int
)	O
;	O
if	O
(	O
!	O
der	pointer
[	O
counter	int
]	O
&&	O
!	O
der	pointer
[	O
counter	int
+	O
1	int
]	O
)	O
{	O
counter	int
+=	O
2	int
;	O
}	O
else	O
{	O
result	int
=	O
ASN1_DER_ERROR	int
;	O
warn	O
(	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
}	O
move	int
=	O
RIGHT	int
;	O
break	O
;	O
default	O
:	O
move	int
=	O
(	O
move	int
==	O
UP	int
)	O
?	O
RIGHT	int
:	O
DOWN	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
p	pointer
)	O
{	O
p	pointer
->	O
end	pointer
=	O
counter	int
-	O
1	int
;	O
}	O
if	O
(	O
p	pointer
==	O
node	pointer
&&	O
move	int
!=	O
DOWN	int
)	O
break	O
;	O
if	O
(	O
move	int
==	O
DOWN	int
)	O
{	O
if	O
(	O
p	pointer
->	O
down	pointer
)	O
p	pointer
=	O
p	pointer
->	O
down	pointer
;	O
else	O
move	int
=	O
RIGHT	int
;	O
}	O
if	O
(	O
(	O
move	int
==	O
RIGHT	int
)	O
&&	O
!	O
(	O
p	pointer
->	O
type	int
&	O
CONST_SET	O
)	O
)	O
{	O
if	O
(	O
p	pointer
->	O
right	pointer
)	O
p	pointer
=	O
p	pointer
->	O
right	pointer
;	O
else	O
move	int
=	O
UP	int
;	O
}	O
if	O
(	O
move	int
==	O
UP	int
)	O
p	pointer
=	O
_asn1_find_up	function
(	O
p	pointer
)	O
;	O
}	O
_asn1_delete_not_used	function
(	O
*	O
element	pointer
)	O
;	O
if	O
(	O
(	O
ider_len	int
<	O
0	int
)	O
||	O
(	O
!	O
(	O
flags	int
&	O
ASN1_DECODE_FLAG_ALLOW_PADDING	int
)	O
&&	O
(	O
ider_len	int
!=	O
0	int
)	O
)	O
)	O
{	O
warn	O
(	O
)	O
;	O
result	int
=	O
ASN1_DER_ERROR	int
;	O
goto	O
cleanup	O
;	O
}	O
*	O
max_ider_len	pointer
=	O
total_len	int
-	O
ider_len	int
;	O
return	O
ASN1_SUCCESS	int
;	O
cleanup	O
:	O
asn1_delete_structure	function
(	O
element	pointer
)	O
;	O
return	O
result	int
;	O
}	O
int	O
asn1_der_decoding	function
(	O
asn1_node	pointer
*	O
element	pointer
,	O
const	O
void	O
*	O
ider	pointer
,	O
int	O
ider_len	int
,	O
char	O
*	O
errorDescription	pointer
)	O
{	O
return	O
asn1_der_decoding2	function
(	O
element	pointer
,	O
ider	pointer
,	O
&	O
ider_len	int
,	O
0	int
,	O
errorDescription	pointer
)	O
;	O
}	O
int	O
asn1_der_decoding_element	function
(	O
asn1_node	pointer
*	O
structure	pointer
,	O
const	O
char	O
*	O
elementName	pointer
,	O
const	O
void	O
*	O
ider	pointer
,	O
int	O
len	int
,	O
char	O
*	O
errorDescription	pointer
)	O
{	O
return	O
asn1_der_decoding	function
(	O
structure	pointer
,	O
ider	pointer
,	O
len	int
,	O
errorDescription	pointer
)	O
;	O
}	O
int	O
asn1_der_decoding_startEnd	function
(	O
asn1_node	pointer
element	pointer
,	O
const	O
void	O
*	O
ider	pointer
,	O
int	O
ider_len	int
,	O
const	O
char	O
*	O
name_element	pointer
,	O
int	O
*	O
start	pointer
,	O
int	O
*	O
end	pointer
)	O
{	O
asn1_node	pointer
node	pointer
,	O
node_to_find	pointer
;	O
int	O
result	int
=	O
ASN1_DER_ERROR	int
;	O
node	pointer
=	O
element	pointer
;	O
if	O
(	O
node	pointer
==	O
NULL	O
)	O
return	O
ASN1_ELEMENT_NOT_FOUND	int
;	O
node_to_find	pointer
=	O
asn1_find_node	function
(	O
node	pointer
,	O
name_element	pointer
)	O
;	O
if	O
(	O
node_to_find	pointer
==	O
NULL	O
)	O
return	O
ASN1_ELEMENT_NOT_FOUND	int
;	O
*	O
start	pointer
=	O
node_to_find	pointer
->	O
start	pointer
;	O
*	O
end	pointer
=	O
node_to_find	pointer
->	O
end	pointer
;	O
if	O
(	O
*	O
start	pointer
==	O
0	int
&&	O
*	O
end	pointer
==	O
0	int
)	O
{	O
if	O
(	O
ider	pointer
==	O
NULL	O
||	O
ider_len	int
==	O
0	int
)	O
return	O
ASN1_GENERIC_ERROR	int
;	O
result	int
=	O
asn1_der_decoding	function
(	O
&	O
node	pointer
,	O
ider	pointer
,	O
ider_len	int
,	O
NULL	O
)	O
;	O
if	O
(	O
result	int
!=	O
ASN1_SUCCESS	int
)	O
{	O
warn	O
(	O
)	O
;	O
return	O
result	int
;	O
}	O
node_to_find	pointer
=	O
asn1_find_node	function
(	O
node	pointer
,	O
name_element	pointer
)	O
;	O
if	O
(	O
node_to_find	pointer
==	O
NULL	O
)	O
return	O
ASN1_ELEMENT_NOT_FOUND	int
;	O
*	O
start	pointer
=	O
node_to_find	pointer
->	O
start	pointer
;	O
*	O
end	pointer
=	O
node_to_find	pointer
->	O
end	pointer
;	O
}	O
if	O
(	O
*	O
end	pointer
<	O
*	O
start	pointer
)	O
return	O
ASN1_GENERIC_ERROR	int
;	O
return	O
ASN1_SUCCESS	int
;	O
}	O
int	O
asn1_expand_any_defined_by	function
(	O
asn1_node_const	pointer
definitions	pointer
,	O
asn1_node	pointer
*	O
element	pointer
)	O
{	O
char	O
name	pointer
[	O
2	int
*	O
ASN1_MAX_NAME_SIZE	int
+	O
2	int
]	O
,	O
value	pointer
[	O
ASN1_MAX_NAME_SIZE	int
]	O
;	O
int	O
retCode	int
=	O
ASN1_SUCCESS	int
,	O
result	int
;	O
int	O
len	int
,	O
len2	int
,	O
len3	int
;	O
asn1_node_const	pointer
p2	pointer
;	O
asn1_node	pointer
p	pointer
,	O
p3	pointer
,	O
aux	pointer
=	O
NULL	O
;	O
char	O
errorDescription	pointer
[	O
ASN1_MAX_ERROR_DESCRIPTION_SIZE	int
]	O
;	O
const	O
char	O
*	O
definitionsName	pointer
;	O
if	O
(	O
(	O
definitions	pointer
==	O
NULL	O
)	O
||	O
(	O
*	O
element	pointer
==	O
NULL	O
)	O
)	O
return	O
ASN1_ELEMENT_NOT_FOUND	int
;	O
definitionsName	pointer
=	O
definitions	pointer
->	O
name	pointer
;	O
p	pointer
=	O
*	O
element	pointer
;	O
while	O
(	O
p	pointer
)	O
{	O
switch	O
(	O
type_field	function
(	O
p	pointer
->	O
type	int
)	O
)	O
{	O
case	O
ASN1_ETYPE_ANY	int
:	O
if	O
(	O
(	O
p	pointer
->	O
type	int
&	O
CONST_DEFINED_BY	O
)	O
&&	O
(	O
p	pointer
->	O
value	pointer
)	O
)	O
{	O
p2	pointer
=	O
p	pointer
->	O
down	pointer
;	O
while	O
(	O
(	O
p2	pointer
)	O
&&	O
(	O
type_field	function
(	O
p2	pointer
->	O
type	int
)	O
!=	O
ASN1_ETYPE_CONSTANT	int
)	O
)	O
p2	pointer
=	O
p2	pointer
->	O
right	pointer
;	O
if	O
(	O
!	O
p2	pointer
)	O
{	O
retCode	int
=	O
ASN1_ERROR_TYPE_ANY	int
;	O
break	O
;	O
}	O
p3	pointer
=	O
_asn1_find_up	function
(	O
p	pointer
)	O
;	O
if	O
(	O
!	O
p3	pointer
)	O
{	O
retCode	int
=	O
ASN1_ERROR_TYPE_ANY	int
;	O
break	O
;	O
}	O
p3	pointer
=	O
p3	pointer
->	O
down	pointer
;	O
while	O
(	O
p3	pointer
)	O
{	O
if	O
(	O
!	O
(	O
strcmp	function
(	O
p3	pointer
->	O
name	pointer
,	O
p2	pointer
->	O
name	pointer
)	O
)	O
)	O
break	O
;	O
p3	pointer
=	O
p3	pointer
->	O
right	pointer
;	O
}	O
if	O
(	O
(	O
!	O
p3	pointer
)	O
||	O
(	O
type_field	function
(	O
p3	pointer
->	O
type	int
)	O
!=	O
ASN1_ETYPE_OBJECT_ID	int
)	O
||	O
(	O
p3	pointer
->	O
value	pointer
==	O
NULL	O
)	O
)	O
{	O
p3	pointer
=	O
_asn1_find_up	function
(	O
p	pointer
)	O
;	O
p3	pointer
=	O
_asn1_find_up	function
(	O
p3	pointer
)	O
;	O
if	O
(	O
!	O
p3	pointer
)	O
{	O
retCode	int
=	O
ASN1_ERROR_TYPE_ANY	int
;	O
break	O
;	O
}	O
p3	pointer
=	O
p3	pointer
->	O
down	pointer
;	O
while	O
(	O
p3	pointer
)	O
{	O
if	O
(	O
!	O
(	O
strcmp	function
(	O
p3	pointer
->	O
name	pointer
,	O
p2	pointer
->	O
name	pointer
)	O
)	O
)	O
break	O
;	O
p3	pointer
=	O
p3	pointer
->	O
right	pointer
;	O
}	O
if	O
(	O
(	O
!	O
p3	pointer
)	O
||	O
(	O
type_field	function
(	O
p3	pointer
->	O
type	int
)	O
!=	O
ASN1_ETYPE_OBJECT_ID	int
)	O
||	O
(	O
p3	pointer
->	O
value	pointer
==	O
NULL	O
)	O
)	O
{	O
retCode	int
=	O
ASN1_ERROR_TYPE_ANY	int
;	O
break	O
;	O
}	O
}	O
p2	pointer
=	O
definitions	pointer
->	O
down	pointer
;	O
while	O
(	O
p2	pointer
)	O
{	O
if	O
(	O
(	O
type_field	function
(	O
p2	pointer
->	O
type	int
)	O
==	O
ASN1_ETYPE_OBJECT_ID	int
)	O
&&	O
(	O
p2	pointer
->	O
type	int
&	O
CONST_ASSIGN	O
)	O
)	O
{	O
snprintf	function
(	O
name	pointer
,	O
sizeof	O
(	O
name	pointer
)	O
,	O
"%s.%s"	pointer
,	O
definitionsName	pointer
,	O
p2	pointer
->	O
name	pointer
)	O
;	O
len	int
=	O
ASN1_MAX_NAME_SIZE	int
;	O
result	int
=	O
asn1_read_value	function
(	O
definitions	pointer
,	O
name	pointer
,	O
value	pointer
,	O
&	O
len	int
)	O
;	O
if	O
(	O
(	O
result	int
==	O
ASN1_SUCCESS	int
)	O
&&	O
(	O
!	O
_asn1_strcmp	O
(	O
p3	pointer
->	O
value	pointer
,	O
value	pointer
)	O
)	O
)	O
{	O
p2	pointer
=	O
p2	pointer
->	O
right	pointer
;	O
while	O
(	O
(	O
p2	pointer
)	O
&&	O
(	O
p2	pointer
->	O
type	int
&	O
CONST_ASSIGN	O
)	O
)	O
p2	pointer
=	O
p2	pointer
->	O
right	pointer
;	O
if	O
(	O
p2	pointer
)	O
{	O
snprintf	function
(	O
name	pointer
,	O
sizeof	O
(	O
name	pointer
)	O
,	O
"%s.%s"	pointer
,	O
definitionsName	pointer
,	O
p2	pointer
->	O
name	pointer
)	O
;	O
result	int
=	O
asn1_create_element	function
(	O
definitions	pointer
,	O
name	pointer
,	O
&	O
aux	pointer
)	O
;	O
if	O
(	O
result	int
==	O
ASN1_SUCCESS	int
)	O
{	O
_asn1_cpy_name	function
(	O
aux	pointer
,	O
p	pointer
)	O
;	O
len2	int
=	O
asn1_get_length_der	function
(	O
p	pointer
->	O
value	pointer
,	O
p	pointer
->	O
value_len	int
,	O
&	O
len3	int
)	O
;	O
if	O
(	O
len2	int
<	O
0	int
)	O
return	O
ASN1_DER_ERROR	int
;	O
result	int
=	O
asn1_der_decoding	function
(	O
&	O
aux	pointer
,	O
p	pointer
->	O
value	pointer
+	O
len3	int
,	O
len2	int
,	O
errorDescription	pointer
)	O
;	O
if	O
(	O
result	int
==	O
ASN1_SUCCESS	int
)	O
{	O
_asn1_set_right	function
(	O
aux	pointer
,	O
p	pointer
->	O
right	pointer
)	O
;	O
_asn1_set_right	function
(	O
p	pointer
,	O
aux	pointer
)	O
;	O
result	int
=	O
asn1_delete_structure	function
(	O
&	O
p	pointer
)	O
;	O
if	O
(	O
result	int
==	O
ASN1_SUCCESS	int
)	O
{	O
p	pointer
=	O
aux	pointer
;	O
aux	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
else	O
{	O
asn1_delete_structure	function
(	O
&	O
aux	pointer
)	O
;	O
retCode	int
=	O
result	int
;	O
break	O
;	O
}	O
}	O
else	O
{	O
retCode	int
=	O
result	int
;	O
break	O
;	O
}	O
}	O
else	O
{	O
retCode	int
=	O
result	int
;	O
break	O
;	O
}	O
}	O
else	O
{	O
retCode	int
=	O
ASN1_ERROR_TYPE_ANY	int
;	O
break	O
;	O
}	O
}	O
}	O
p2	pointer
=	O
p2	pointer
->	O
right	pointer
;	O
}	O
if	O
(	O
!	O
p2	pointer
)	O
{	O
retCode	int
=	O
ASN1_ERROR_TYPE_ANY	int
;	O
break	O
;	O
}	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
p	pointer
->	O
down	pointer
)	O
{	O
p	pointer
=	O
p	pointer
->	O
down	pointer
;	O
}	O
else	O
if	O
(	O
p	pointer
==	O
*	O
element	pointer
)	O
{	O
p	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
p	pointer
->	O
right	pointer
)	O
p	pointer
=	O
p	pointer
->	O
right	pointer
;	O
else	O
{	O
while	O
(	O
1	int
)	O
{	O
p	pointer
=	O
_asn1_find_up	function
(	O
p	pointer
)	O
;	O
if	O
(	O
p	pointer
==	O
*	O
element	pointer
)	O
{	O
p	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
if	O
(	O
p	pointer
->	O
right	pointer
)	O
{	O
p	pointer
=	O
p	pointer
->	O
right	pointer
;	O
break	O
;	O
}	O
}	O
}	O
}	O
return	O
retCode	int
;	O
}	O
int	O
asn1_expand_octet_string	function
(	O
asn1_node_const	pointer
definitions	pointer
,	O
asn1_node	pointer
*	O
element	pointer
,	O
const	O
char	O
*	O
octetName	pointer
,	O
const	O
char	O
*	O
objectName	pointer
)	O
{	O
char	O
name	pointer
[	O
2	int
*	O
ASN1_MAX_NAME_SIZE	int
+	O
1	int
]	O
,	O
value	pointer
[	O
ASN1_MAX_NAME_SIZE	int
]	O
;	O
int	O
retCode	int
=	O
ASN1_SUCCESS	int
,	O
result	int
;	O
int	O
len	int
,	O
len2	int
,	O
len3	int
;	O
asn1_node_const	pointer
p2	pointer
;	O
asn1_node	pointer
aux	pointer
=	O
NULL	O
;	O
asn1_node	pointer
octetNode	pointer
=	O
NULL	O
,	O
objectNode	pointer
=	O
NULL	O
;	O
char	O
errorDescription	pointer
[	O
ASN1_MAX_ERROR_DESCRIPTION_SIZE	int
]	O
;	O
if	O
(	O
(	O
definitions	pointer
==	O
NULL	O
)	O
||	O
(	O
*	O
element	pointer
==	O
NULL	O
)	O
)	O
return	O
ASN1_ELEMENT_NOT_FOUND	int
;	O
octetNode	pointer
=	O
asn1_find_node	function
(	O
*	O
element	pointer
,	O
octetName	pointer
)	O
;	O
if	O
(	O
octetNode	pointer
==	O
NULL	O
)	O
return	O
ASN1_ELEMENT_NOT_FOUND	int
;	O
if	O
(	O
type_field	function
(	O
octetNode	pointer
->	O
type	int
)	O
!=	O
ASN1_ETYPE_OCTET_STRING	int
)	O
return	O
ASN1_ELEMENT_NOT_FOUND	int
;	O
if	O
(	O
octetNode	pointer
->	O
value	pointer
==	O
NULL	O
)	O
return	O
ASN1_VALUE_NOT_FOUND	int
;	O
objectNode	pointer
=	O
asn1_find_node	function
(	O
*	O
element	pointer
,	O
objectName	pointer
)	O
;	O
if	O
(	O
objectNode	pointer
==	O
NULL	O
)	O
return	O
ASN1_ELEMENT_NOT_FOUND	int
;	O
if	O
(	O
type_field	function
(	O
objectNode	pointer
->	O
type	int
)	O
!=	O
ASN1_ETYPE_OBJECT_ID	int
)	O
return	O
ASN1_ELEMENT_NOT_FOUND	int
;	O
if	O
(	O
objectNode	pointer
->	O
value	pointer
==	O
NULL	O
)	O
return	O
ASN1_VALUE_NOT_FOUND	int
;	O
p2	pointer
=	O
definitions	pointer
->	O
down	pointer
;	O
while	O
(	O
p2	pointer
)	O
{	O
if	O
(	O
(	O
type_field	function
(	O
p2	pointer
->	O
type	int
)	O
==	O
ASN1_ETYPE_OBJECT_ID	int
)	O
&&	O
(	O
p2	pointer
->	O
type	int
&	O
CONST_ASSIGN	O
)	O
)	O
{	O
strcpy	function
(	O
name	pointer
,	O
definitions	pointer
->	O
name	pointer
)	O
;	O
strcat	function
(	O
name	pointer
,	O
"."	pointer
)	O
;	O
strcat	function
(	O
name	pointer
,	O
p2	pointer
->	O
name	pointer
)	O
;	O
len	int
=	O
sizeof	O
(	O
value	pointer
)	O
;	O
result	int
=	O
asn1_read_value	function
(	O
definitions	pointer
,	O
name	pointer
,	O
value	pointer
,	O
&	O
len	int
)	O
;	O
if	O
(	O
(	O
result	int
==	O
ASN1_SUCCESS	int
)	O
&&	O
(	O
!	O
_asn1_strcmp	O
(	O
objectNode	pointer
->	O
value	pointer
,	O
value	pointer
)	O
)	O
)	O
{	O
p2	pointer
=	O
p2	pointer
->	O
right	pointer
;	O
while	O
(	O
(	O
p2	pointer
)	O
&&	O
(	O
p2	pointer
->	O
type	int
&	O
CONST_ASSIGN	O
)	O
)	O
p2	pointer
=	O
p2	pointer
->	O
right	pointer
;	O
if	O
(	O
p2	pointer
)	O
{	O
strcpy	function
(	O
name	pointer
,	O
definitions	pointer
->	O
name	pointer
)	O
;	O
strcat	function
(	O
name	pointer
,	O
"."	pointer
)	O
;	O
strcat	function
(	O
name	pointer
,	O
p2	pointer
->	O
name	pointer
)	O
;	O
result	int
=	O
asn1_create_element	function
(	O
definitions	pointer
,	O
name	pointer
,	O
&	O
aux	pointer
)	O
;	O
if	O
(	O
result	int
==	O
ASN1_SUCCESS	int
)	O
{	O
_asn1_cpy_name	function
(	O
aux	pointer
,	O
octetNode	pointer
)	O
;	O
len2	int
=	O
asn1_get_length_der	function
(	O
octetNode	pointer
->	O
value	pointer
,	O
octetNode	pointer
->	O
value_len	int
,	O
&	O
len3	int
)	O
;	O
if	O
(	O
len2	int
<	O
0	int
)	O
return	O
ASN1_DER_ERROR	int
;	O
result	int
=	O
asn1_der_decoding	function
(	O
&	O
aux	pointer
,	O
octetNode	pointer
->	O
value	pointer
+	O
len3	int
,	O
len2	int
,	O
errorDescription	pointer
)	O
;	O
if	O
(	O
result	int
==	O
ASN1_SUCCESS	int
)	O
{	O
_asn1_set_right	function
(	O
aux	pointer
,	O
octetNode	pointer
->	O
right	pointer
)	O
;	O
_asn1_set_right	function
(	O
octetNode	pointer
,	O
aux	pointer
)	O
;	O
result	int
=	O
asn1_delete_structure	function
(	O
&	O
octetNode	pointer
)	O
;	O
if	O
(	O
result	int
==	O
ASN1_SUCCESS	int
)	O
{	O
aux	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
else	O
{	O
asn1_delete_structure	function
(	O
&	O
aux	pointer
)	O
;	O
retCode	int
=	O
result	int
;	O
break	O
;	O
}	O
}	O
else	O
{	O
retCode	int
=	O
result	int
;	O
break	O
;	O
}	O
}	O
else	O
{	O
retCode	int
=	O
result	int
;	O
break	O
;	O
}	O
}	O
else	O
{	O
retCode	int
=	O
ASN1_VALUE_NOT_VALID	int
;	O
break	O
;	O
}	O
}	O
}	O
p2	pointer
=	O
p2	pointer
->	O
right	pointer
;	O
}	O
if	O
(	O
!	O
p2	pointer
)	O
retCode	int
=	O
ASN1_VALUE_NOT_VALID	int
;	O
return	O
retCode	int
;	O
}	O
static	O
int	O
_asn1_decode_simple_der	function
(	O
unsigned	O
int	O
etype	pointer
,	O
const	O
unsigned	O
char	O
*	O
der	pointer
,	O
unsigned	O
int	O
_der_len	int
,	O
const	O
unsigned	O
char	O
*	O
*	O
str	pointer
,	O
unsigned	O
int	O
*	O
str_len	pointer
,	O
unsigned	O
dflags	int
)	O
{	O
int	O
tag_len	pointer
,	O
len_len	int
;	O
const	O
unsigned	O
char	O
*	O
p	pointer
;	O
int	O
der_len	int
=	O
_der_len	int
;	O
unsigned	O
char	O
class	int
;	O
unsigned	O
long	O
tag	pointer
;	O
long	O
ret	pointer
;	O
if	O
(	O
der	pointer
==	O
NULL	O
||	O
der_len	int
==	O
0	int
)	O
return	O
ASN1_VALUE_NOT_VALID	int
;	O
if	O
(	O
ETYPE_OK	O
(	O
etype	pointer
)	O
==	O
0	int
||	O
ETYPE_IS_STRING	O
(	O
etype	pointer
)	O
==	O
0	int
)	O
return	O
ASN1_VALUE_NOT_VALID	int
;	O
class	int
=	O
ETYPE_CLASS	O
(	O
etype	pointer
)	O
;	O
if	O
(	O
class	int
!=	O
ASN1_CLASS_UNIVERSAL	int
)	O
return	O
ASN1_VALUE_NOT_VALID	int
;	O
p	pointer
=	O
der	pointer
;	O
if	O
(	O
dflags	int
&	O
DECODE_FLAG_HAVE_TAG	int
)	O
{	O
ret	pointer
=	O
asn1_get_tag_der	function
(	O
p	pointer
,	O
der_len	int
,	O
&	O
class	int
,	O
&	O
tag_len	pointer
,	O
&	O
tag	pointer
)	O
;	O
if	O
(	O
ret	pointer
!=	O
ASN1_SUCCESS	int
)	O
return	O
ret	pointer
;	O
if	O
(	O
class	int
!=	O
ETYPE_CLASS	O
(	O
etype	pointer
)	O
||	O
tag	pointer
!=	O
ETYPE_TAG	O
(	O
etype	pointer
)	O
)	O
{	O
warn	O
(	O
)	O
;	O
return	O
ASN1_DER_ERROR	int
;	O
}	O
p	pointer
+=	O
tag_len	pointer
;	O
der_len	int
-=	O
tag_len	pointer
;	O
if	O
(	O
der_len	int
<=	O
0	int
)	O
return	O
ASN1_DER_ERROR	int
;	O
}	O
ret	pointer
=	O
asn1_get_length_der	function
(	O
p	pointer
,	O
der_len	int
,	O
&	O
len_len	int
)	O
;	O
if	O
(	O
ret	pointer
<	O
0	int
)	O
return	O
ASN1_DER_ERROR	int
;	O
p	pointer
+=	O
len_len	int
;	O
der_len	int
-=	O
len_len	int
;	O
if	O
(	O
der_len	int
<=	O
0	int
)	O
return	O
ASN1_DER_ERROR	int
;	O
*	O
str_len	pointer
=	O
ret	pointer
;	O
*	O
str	pointer
=	O
p	pointer
;	O
return	O
ASN1_SUCCESS	int
;	O
}	O
int	O
asn1_decode_simple_der	function
(	O
unsigned	O
int	O
etype	pointer
,	O
const	O
unsigned	O
char	O
*	O
der	pointer
,	O
unsigned	O
int	O
_der_len	int
,	O
const	O
unsigned	O
char	O
*	O
*	O
str	pointer
,	O
unsigned	O
int	O
*	O
str_len	pointer
)	O
{	O
return	O
_asn1_decode_simple_der	function
(	O
etype	pointer
,	O
der	pointer
,	O
_der_len	int
,	O
str	pointer
,	O
str_len	pointer
,	O
DECODE_FLAG_HAVE_TAG	int
)	O
;	O
}	O
static	O
int	O
append	function
(	O
uint8_t	char
*	O
*	O
dst	pointer
,	O
unsigned	O
*	O
dst_size	pointer
,	O
const	O
unsigned	O
char	O
*	O
src	pointer
,	O
unsigned	O
src_size	int
)	O
{	O
if	O
(	O
src_size	int
==	O
0	int
)	O
return	O
ASN1_SUCCESS	int
;	O
*	O
dst	pointer
=	O
_asn1_realloc	function
(	O
*	O
dst	pointer
,	O
*	O
dst_size	pointer
+	O
src_size	int
)	O
;	O
if	O
(	O
*	O
dst	pointer
==	O
NULL	O
)	O
return	O
ASN1_MEM_ALLOC_ERROR	int
;	O
memcpy	function
(	O
*	O
dst	pointer
+	O
*	O
dst_size	pointer
,	O
src	pointer
,	O
src_size	int
)	O
;	O
*	O
dst_size	pointer
+=	O
src_size	int
;	O
return	O
ASN1_SUCCESS	int
;	O
}	O
static	O
int	O
_asn1_decode_simple_ber	function
(	O
unsigned	O
int	O
etype	pointer
,	O
const	O
unsigned	O
char	O
*	O
der	pointer
,	O
unsigned	O
int	O
_der_len	int
,	O
unsigned	O
char	O
*	O
*	O
str	pointer
,	O
unsigned	O
int	O
*	O
str_len	pointer
,	O
unsigned	O
int	O
*	O
ber_len	int
,	O
unsigned	O
dflags	int
)	O
{	O
int	O
tag_len	pointer
,	O
len_len	int
;	O
const	O
unsigned	O
char	O
*	O
p	pointer
;	O
int	O
der_len	int
=	O
_der_len	int
;	O
uint8_t	char
*	O
total	pointer
=	O
NULL	O
;	O
unsigned	O
total_size	int
=	O
0	int
;	O
unsigned	O
char	O
class	int
;	O
unsigned	O
long	O
tag	pointer
;	O
unsigned	O
char	O
*	O
out	pointer
=	O
NULL	O
;	O
const	O
unsigned	O
char	O
*	O
cout	pointer
=	O
NULL	O
;	O
unsigned	O
out_len	int
;	O
long	O
result	int
;	O
if	O
(	O
ber_len	int
)	O
*	O
ber_len	int
=	O
0	int
;	O
if	O
(	O
der	pointer
==	O
NULL	O
||	O
der_len	int
==	O
0	int
)	O
{	O
warn	O
(	O
)	O
;	O
return	O
ASN1_VALUE_NOT_VALID	int
;	O
}	O
if	O
(	O
ETYPE_OK	O
(	O
etype	pointer
)	O
==	O
0	int
)	O
{	O
warn	O
(	O
)	O
;	O
return	O
ASN1_VALUE_NOT_VALID	int
;	O
}	O
class	int
=	O
ETYPE_CLASS	O
(	O
etype	pointer
)	O
;	O
if	O
(	O
class	int
!=	O
ASN1_CLASS_UNIVERSAL	int
)	O
{	O
warn	O
(	O
)	O
;	O
return	O
ASN1_VALUE_NOT_VALID	int
;	O
}	O
p	pointer
=	O
der	pointer
;	O
if	O
(	O
dflags	int
&	O
DECODE_FLAG_HAVE_TAG	int
)	O
{	O
result	int
=	O
asn1_get_tag_der	function
(	O
p	pointer
,	O
der_len	int
,	O
&	O
class	int
,	O
&	O
tag_len	pointer
,	O
&	O
tag	pointer
)	O
;	O
if	O
(	O
result	int
!=	O
ASN1_SUCCESS	int
)	O
{	O
warn	O
(	O
)	O
;	O
return	O
result	int
;	O
}	O
if	O
(	O
tag	pointer
!=	O
ETYPE_TAG	O
(	O
etype	pointer
)	O
)	O
{	O
warn	O
(	O
)	O
;	O
return	O
ASN1_DER_ERROR	int
;	O
}	O
p	pointer
+=	O
tag_len	pointer
;	O
DECR_LEN	O
(	O
der_len	int
,	O
tag_len	pointer
)	O
;	O
if	O
(	O
ber_len	int
)	O
*	O
ber_len	int
+=	O
tag_len	pointer
;	O
}	O
if	O
(	O
(	O
(	O
(	O
dflags	int
&	O
DECODE_FLAG_CONSTRUCTED	O
)	O
||	O
class	int
==	O
ASN1_CLASS_STRUCTURED	int
)	O
&&	O
ETYPE_IS_STRING	O
(	O
etype	pointer
)	O
)	O
&&	O
!	O
(	O
dflags	int
&	O
DECODE_FLAG_LEVEL3	O
)	O
)	O
{	O
if	O
(	O
der_len	int
==	O
0	int
)	O
{	O
warn	O
(	O
)	O
;	O
result	int
=	O
ASN1_DER_ERROR	int
;	O
goto	O
cleanup	O
;	O
}	O
if	O
(	O
der_len	int
>	O
0	int
&&	O
p	pointer
[	O
0	int
]	O
==	O
0x80	int
)	O
{	O
len_len	int
=	O
1	int
;	O
DECR_LEN	O
(	O
der_len	int
,	O
len_len	int
)	O
;	O
p	pointer
+=	O
len_len	int
;	O
if	O
(	O
ber_len	int
)	O
*	O
ber_len	int
+=	O
len_len	int
;	O
do	O
{	O
unsigned	O
tmp_len	int
;	O
unsigned	O
flags	int
=	O
DECODE_FLAG_HAVE_TAG	int
;	O
if	O
(	O
dflags	int
&	O
DECODE_FLAG_LEVEL1	O
)	O
flags	int
|=	O
DECODE_FLAG_LEVEL2	O
;	O
else	O
if	O
(	O
dflags	int
&	O
DECODE_FLAG_LEVEL2	O
)	O
flags	int
|=	O
DECODE_FLAG_LEVEL3	O
;	O
else	O
flags	int
|=	O
DECODE_FLAG_LEVEL1	O
;	O
result	int
=	O
_asn1_decode_simple_ber	function
(	O
etype	pointer
,	O
p	pointer
,	O
der_len	int
,	O
&	O
out	pointer
,	O
&	O
out_len	int
,	O
&	O
tmp_len	int
,	O
flags	int
)	O
;	O
if	O
(	O
result	int
!=	O
ASN1_SUCCESS	int
)	O
{	O
warn	O
(	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
p	pointer
+=	O
tmp_len	int
;	O
DECR_LEN	O
(	O
der_len	int
,	O
tmp_len	int
)	O
;	O
if	O
(	O
ber_len	int
)	O
*	O
ber_len	int
+=	O
tmp_len	int
;	O
DECR_LEN	O
(	O
der_len	int
,	O
2	int
)	O
;	O
result	int
=	O
append	function
(	O
&	O
total	pointer
,	O
&	O
total_size	int
,	O
out	pointer
,	O
out_len	int
)	O
;	O
if	O
(	O
result	int
!=	O
ASN1_SUCCESS	int
)	O
{	O
warn	O
(	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
free	function
(	O
out	pointer
)	O
;	O
out	pointer
=	O
NULL	O
;	O
if	O
(	O
p	pointer
[	O
0	int
]	O
==	O
0	int
&&	O
p	pointer
[	O
1	int
]	O
==	O
0	int
)	O
{	O
if	O
(	O
ber_len	int
)	O
*	O
ber_len	int
+=	O
2	int
;	O
break	O
;	O
}	O
der_len	int
+=	O
2	int
;	O
if	O
(	O
der_len	int
==	O
2	int
)	O
{	O
warn	O
(	O
)	O
;	O
result	int
=	O
ASN1_DER_ERROR	int
;	O
goto	O
cleanup	O
;	O
}	O
}	O
while	O
(	O
1	int
)	O
;	O
}	O
else	O
{	O
long	O
const_len	long
;	O
result	int
=	O
asn1_get_length_ber	function
(	O
p	pointer
,	O
der_len	int
,	O
&	O
len_len	int
)	O
;	O
if	O
(	O
result	int
<	O
0	int
)	O
{	O
warn	O
(	O
)	O
;	O
result	int
=	O
ASN1_DER_ERROR	int
;	O
goto	O
cleanup	O
;	O
}	O
DECR_LEN	O
(	O
der_len	int
,	O
len_len	int
)	O
;	O
p	pointer
+=	O
len_len	int
;	O
const_len	long
=	O
result	int
;	O
if	O
(	O
ber_len	int
)	O
*	O
ber_len	int
+=	O
len_len	int
;	O
while	O
(	O
const_len	long
>	O
0	int
)	O
{	O
unsigned	O
tmp_len	int
;	O
unsigned	O
flags	int
=	O
DECODE_FLAG_HAVE_TAG	int
;	O
if	O
(	O
dflags	int
&	O
DECODE_FLAG_LEVEL1	O
)	O
flags	int
|=	O
DECODE_FLAG_LEVEL2	O
;	O
else	O
if	O
(	O
dflags	int
&	O
DECODE_FLAG_LEVEL2	O
)	O
flags	int
|=	O
DECODE_FLAG_LEVEL3	O
;	O
else	O
flags	int
|=	O
DECODE_FLAG_LEVEL1	O
;	O
result	int
=	O
_asn1_decode_simple_ber	function
(	O
etype	pointer
,	O
p	pointer
,	O
der_len	int
,	O
&	O
out	pointer
,	O
&	O
out_len	int
,	O
&	O
tmp_len	int
,	O
flags	int
)	O
;	O
if	O
(	O
result	int
!=	O
ASN1_SUCCESS	int
)	O
{	O
warn	O
(	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
p	pointer
+=	O
tmp_len	int
;	O
DECR_LEN	O
(	O
der_len	int
,	O
tmp_len	int
)	O
;	O
DECR_LEN	O
(	O
const_len	long
,	O
tmp_len	int
)	O
;	O
if	O
(	O
ber_len	int
)	O
*	O
ber_len	int
+=	O
tmp_len	int
;	O
result	int
=	O
append	function
(	O
&	O
total	pointer
,	O
&	O
total_size	int
,	O
out	pointer
,	O
out_len	int
)	O
;	O
if	O
(	O
result	int
!=	O
ASN1_SUCCESS	int
)	O
{	O
warn	O
(	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
free	function
(	O
out	pointer
)	O
;	O
out	pointer
=	O
NULL	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
class	int
==	O
ETYPE_CLASS	O
(	O
etype	pointer
)	O
)	O
{	O
if	O
(	O
ber_len	int
)	O
{	O
result	int
=	O
asn1_get_length_der	function
(	O
p	pointer
,	O
der_len	int
,	O
&	O
len_len	int
)	O
;	O
if	O
(	O
result	int
<	O
0	int
)	O
{	O
warn	O
(	O
)	O
;	O
result	int
=	O
ASN1_DER_ERROR	int
;	O
goto	O
cleanup	O
;	O
}	O
*	O
ber_len	int
+=	O
result	int
+	O
len_len	int
;	O
}	O
result	int
=	O
_asn1_decode_simple_der	function
(	O
etype	pointer
,	O
der	pointer
,	O
_der_len	int
,	O
&	O
cout	pointer
,	O
&	O
out_len	int
,	O
dflags	int
)	O
;	O
if	O
(	O
result	int
!=	O
ASN1_SUCCESS	int
)	O
{	O
warn	O
(	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
result	int
=	O
append	function
(	O
&	O
total	pointer
,	O
&	O
total_size	int
,	O
cout	pointer
,	O
out_len	int
)	O
;	O
if	O
(	O
result	int
!=	O
ASN1_SUCCESS	int
)	O
{	O
warn	O
(	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
}	O
else	O
{	O
warn	O
(	O
)	O
;	O
result	int
=	O
ASN1_DER_ERROR	int
;	O
goto	O
cleanup	O
;	O
}	O
*	O
str	pointer
=	O
total	pointer
;	O
*	O
str_len	pointer
=	O
total_size	int
;	O
return	O
ASN1_SUCCESS	int
;	O
cleanup	O
:	O
free	function
(	O
out	pointer
)	O
;	O
free	function
(	O
total	pointer
)	O
;	O
return	O
result	int
;	O
}	O
int	O
asn1_decode_simple_ber	function
(	O
unsigned	O
int	O
etype	pointer
,	O
const	O
unsigned	O
char	O
*	O
der	pointer
,	O
unsigned	O
int	O
_der_len	int
,	O
unsigned	O
char	O
*	O
*	O
str	pointer
,	O
unsigned	O
int	O
*	O
str_len	pointer
,	O
unsigned	O
int	O
*	O
ber_len	int
)	O
{	O
return	O
_asn1_decode_simple_ber	function
(	O
etype	pointer
,	O
der	pointer
,	O
_der_len	int
,	O
str	pointer
,	O
str_len	pointer
,	O
ber_len	int
,	O
DECODE_FLAG_HAVE_TAG	int
)	O
;	O
}	O
