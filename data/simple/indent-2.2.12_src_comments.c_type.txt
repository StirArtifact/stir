RCSTAG_CC	O
(	O
"$Id$"	pointer
)	O
;	O
extern	O
void	O
print_comment	function
(	O
int	O
*	O
paren_targ	int
,	O
BOOLEAN	char
*	O
pbreak_line	pointer
)	O
{	O
int	O
column	int
;	O
int	O
format	int
;	O
codes_ty	enum
comment_type	enum
;	O
int	O
start_column	int
;	O
int	O
found_column	int
;	O
int	O
first_comment_line	int
;	O
int	O
right_margin	int
;	O
int	O
boxed_comment	int
;	O
int	O
stars	int
;	O
int	O
blankline_delims	int
;	O
int	O
paragraph_break	int
;	O
int	O
merge_blank_comment_lines	int
;	O
int	O
two_contiguous_comments	int
=	O
0	int
;	O
int	O
save_length	int
=	O
0	int
;	O
char	O
*	O
save_ptr	pointer
=	O
NULL	O
;	O
char	O
*	O
text_on_line	pointer
=	O
NULL	O
;	O
char	O
*	O
line_break_ptr	pointer
=	O
NULL	O
;	O
char	O
*	O
start_delim	pointer
=	O
NULL	O
;	O
char	O
*	O
line_preamble	pointer
=	O
NULL	O
;	O
int	O
line_preamble_length	int
;	O
int	O
visible_preamble	int
;	O
int	O
suppress_cdb	int
=	O
0	int
;	O
inc_pstack	function
(	O
)	O
;	O
if	O
(	O
*	O
(	O
token	pointer
+	O
1	int
)	O
==	O
'/'	O
)	O
{	O
comment_type	enum
=	O
cplus_comment	int
;	O
}	O
else	O
{	O
comment_type	enum
=	O
comment	int
;	O
}	O
if	O
(	O
comment_type	enum
==	O
cplus_comment	int
)	O
{	O
start_delim	pointer
=	O
"//"	pointer
;	O
line_preamble	pointer
=	O
"// "	pointer
;	O
line_preamble_length	int
=	O
strlen	function
(	O
line_preamble	pointer
)	O
;	O
visible_preamble	int
=	O
1	int
;	O
boxed_comment	int
=	O
0	int
;	O
stars	int
=	O
0	int
;	O
blankline_delims	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
(	O
*	O
buf_ptr	pointer
==	O
'*'	O
)	O
||	O
(	O
*	O
buf_ptr	pointer
==	O
'-'	O
)	O
||	O
(	O
*	O
buf_ptr	pointer
==	O
'='	O
)	O
||	O
(	O
*	O
buf_ptr	pointer
==	O
'_'	O
)	O
||	O
(	O
parser_state_tos	pointer
->	O
col_1	int
&&	O
!	O
settings	struct
.	O
format_col1_comments	int
)	O
)	O
{	O
int	O
comment_lines_count	int
=	O
1	int
;	O
stars	int
=	O
0	int
;	O
boxed_comment	int
=	O
0	int
;	O
blankline_delims	int
=	O
0	int
;	O
line_preamble_length	int
=	O
0	int
;	O
visible_preamble	int
=	O
0	int
;	O
if	O
(	O
(	O
buf_ptr	pointer
>=	O
save_com	struct
.	O
ptr	pointer
)	O
&&	O
(	O
buf_ptr	pointer
<=	O
save_com	struct
.	O
ptr	pointer
+	O
save_com	struct
.	O
len	int
)	O
)	O
{	O
start_column	int
=	O
save_com	struct
.	O
start_column	int
;	O
}	O
else	O
{	O
start_column	int
=	O
current_column	function
(	O
)	O
-	O
2	int
;	O
}	O
found_column	int
=	O
start_column	int
;	O
parser_state_tos	pointer
->	O
box_com	int
=	O
1	int
;	O
parser_state_tos	pointer
->	O
com_col	int
=	O
found_column	int
;	O
if	O
(	O
settings	struct
.	O
blanklines_before_blockcomments	int
)	O
{	O
prefix_blankline_requested	int
=	O
1	int
;	O
}	O
*	O
e_com	pointer
++	O
=	O
'/'	O
;	O
*	O
e_com	pointer
++	O
=	O
'*'	O
;	O
while	O
(	O
1	int
)	O
{	O
do	O
{	O
if	O
(	O
*	O
buf_ptr	pointer
==	O
EOL	char
)	O
{	O
++	O
line_no	int
;	O
}	O
CHECK_COM_SIZE	O
(	O
1	int
)	O
;	O
*	O
e_com	pointer
++	O
=	O
*	O
buf_ptr	pointer
++	O
;	O
}	O
while	O
(	O
(	O
*	O
buf_ptr	pointer
!=	O
'*'	O
)	O
&&	O
(	O
buf_ptr	pointer
<	O
buf_end	pointer
)	O
)	O
;	O
if	O
(	O
buf_ptr	pointer
>	O
buf_end	pointer
)	O
buf_ptr	pointer
=	O
buf_end	pointer
;	O
if	O
(	O
settings	struct
.	O
fix_nested_comments	int
)	O
{	O
if	O
(	O
(	O
*	O
buf_ptr	pointer
==	O
'*'	O
)	O
&&	O
(	O
*	O
(	O
buf_ptr	pointer
-	O
1	int
)	O
==	O
'/'	O
)	O
)	O
{	O
*	O
(	O
e_com	pointer
-	O
1	int
)	O
=	O
' '	O
;	O
*	O
e_com	pointer
=	O
'*'	O
;	O
}	O
}	O
if	O
(	O
(	O
*	O
buf_ptr	pointer
==	O
'*'	O
)	O
&&	O
(	O
*	O
(	O
buf_ptr	pointer
+	O
1	int
)	O
==	O
'/'	O
)	O
)	O
{	O
if	O
(	O
buf_ptr	pointer
==	O
buf_end	pointer
)	O
{	O
fill_buffer	function
(	O
)	O
;	O
}	O
buf_ptr	pointer
+=	O
2	int
;	O
if	O
(	O
buf_ptr	pointer
==	O
buf_end	pointer
)	O
{	O
fill_buffer	function
(	O
)	O
;	O
}	O
*	O
e_com	pointer
++	O
=	O
'*'	O
;	O
*	O
e_com	pointer
++	O
=	O
'/'	O
;	O
*	O
e_com	pointer
=	O
'\0'	O
;	O
parser_state_tos	pointer
->	O
tos	int
--	O
;	O
if	O
(	O
comment_lines_count	int
>	O
1	int
)	O
{	O
parser_state_tos	pointer
->	O
com_col	int
=	O
1	int
;	O
}	O
else	O
{	O
parser_state_tos	pointer
->	O
com_col	int
=	O
found_column	int
;	O
}	O
return	O
;	O
}	O
if	O
(	O
buf_ptr	pointer
==	O
buf_end	pointer
)	O
{	O
if	O
(	O
*	O
(	O
buf_ptr	pointer
-	O
1	int
)	O
==	O
EOL	char
)	O
{	O
*	O
(	O
--	O
e_com	pointer
)	O
=	O
EOS	char
;	O
dump_line	function
(	O
true	int
,	O
paren_targ	int
,	O
pbreak_line	pointer
)	O
;	O
comment_lines_count	int
++	O
;	O
parser_state_tos	pointer
->	O
com_col	int
=	O
1	int
;	O
}	O
fill_buffer	function
(	O
)	O
;	O
if	O
(	O
had_eof	char
)	O
{	O
*	O
e_com	pointer
++	O
=	O
'\0'	O
;	O
parser_state_tos	pointer
->	O
tos	int
--	O
;	O
parser_state_tos	pointer
->	O
com_col	int
=	O
start_column	int
;	O
return	O
;	O
}	O
}	O
}	O
}	O
else	O
{	O
start_delim	pointer
=	O
"/*"	pointer
;	O
line_preamble	pointer
=	O
0	int
;	O
line_preamble_length	int
=	O
0	int
;	O
visible_preamble	int
=	O
0	int
;	O
boxed_comment	int
=	O
0	int
;	O
stars	int
=	O
settings	struct
.	O
star_comment_cont	int
;	O
blankline_delims	int
=	O
settings	struct
.	O
comment_delimiter_on_blankline	int
;	O
}	O
paragraph_break	int
=	O
0	int
;	O
merge_blank_comment_lines	int
=	O
0	int
;	O
first_comment_line	int
=	O
com_lines	int
;	O
right_margin	int
=	O
settings	struct
.	O
comment_max_col	int
;	O
found_column	int
=	O
current_column	function
(	O
)	O
-	O
2	int
;	O
if	O
(	O
(	O
s_lab	pointer
==	O
e_lab	pointer
)	O
&&	O
(	O
s_code	pointer
==	O
e_code	pointer
)	O
)	O
{	O
if	O
(	O
parser_state_tos	pointer
->	O
col_1	int
&&	O
!	O
settings	struct
.	O
format_col1_comments	int
)	O
{	O
format	int
=	O
settings	struct
.	O
format_col1_comments	int
;	O
start_column	int
=	O
1	int
;	O
}	O
else	O
{	O
format	int
=	O
settings	struct
.	O
format_comments	int
;	O
if	O
(	O
(	O
parser_state_tos	pointer
->	O
ind_level	int
<=	O
0	int
)	O
&&	O
(	O
!	O
parser_state_tos	pointer
->	O
in_stmt	int
||	O
(	O
parser_state_tos	pointer
->	O
in_decl	char
&&	O
(	O
parser_state_tos	pointer
->	O
paren_level	int
==	O
0	int
)	O
)	O
)	O
)	O
{	O
start_column	int
=	O
found_column	int
;	O
}	O
else	O
{	O
start_column	int
=	O
compute_code_target	function
(	O
*	O
paren_targ	int
)	O
-	O
settings	struct
.	O
unindent_displace	int
;	O
if	O
(	O
start_column	int
<	O
0	int
)	O
{	O
start_column	int
=	O
1	int
;	O
}	O
}	O
}	O
}	O
else	O
{	O
int	O
target	int
;	O
suppress_cdb	int
=	O
1	int
;	O
if	O
(	O
parser_state_tos	pointer
->	O
decl_on_line	int
)	O
{	O
target	int
=	O
settings	struct
.	O
decl_com_ind	int
;	O
}	O
else	O
if	O
(	O
else_or_endif	int
)	O
{	O
target	int
=	O
settings	struct
.	O
else_endif_col	int
;	O
}	O
else	O
{	O
target	int
=	O
settings	struct
.	O
com_ind	int
;	O
}	O
if	O
(	O
s_code	pointer
!=	O
e_code	pointer
)	O
{	O
start_column	int
=	O
count_columns	function
(	O
compute_code_target	function
(	O
*	O
paren_targ	int
)	O
,	O
s_code	pointer
,	O
NULL_CHAR	char
)	O
;	O
}	O
else	O
{	O
start_column	int
=	O
count_columns	function
(	O
compute_label_target	function
(	O
)	O
,	O
s_lab	pointer
,	O
NULL_CHAR	char
)	O
;	O
}	O
if	O
(	O
start_column	int
<	O
target	int
)	O
{	O
start_column	int
=	O
target	int
;	O
}	O
else	O
{	O
if	O
(	O
else_or_endif	int
||	O
settings	struct
.	O
dont_tab_align_comments	int
)	O
{	O
start_column	int
++	O
;	O
else_or_endif	int
=	O
false	int
;	O
}	O
else	O
{	O
start_column	int
+=	O
settings	struct
.	O
tabsize	int
-	O
(	O
(	O
start_column	int
-	O
1	int
)	O
%	O
settings	struct
.	O
tabsize	int
)	O
;	O
}	O
}	O
format	int
=	O
settings	struct
.	O
format_comments	int
;	O
}	O
if	O
(	O
!	O
line_preamble	pointer
)	O
{	O
line_preamble_length	int
=	O
3	int
;	O
if	O
(	O
stars	int
)	O
{	O
line_preamble	pointer
=	O
" * "	pointer
;	O
visible_preamble	int
=	O
1	int
;	O
}	O
else	O
{	O
line_preamble	pointer
=	O
"   "	pointer
;	O
visible_preamble	int
=	O
0	int
;	O
}	O
}	O
parser_state_tos	pointer
->	O
com_col	int
=	O
(	O
two_contiguous_comments	int
?	O
1	int
:	O
start_column	int
)	O
;	O
parser_state_tos	pointer
->	O
box_com	int
=	O
boxed_comment	int
;	O
*	O
e_com	pointer
++	O
=	O
*	O
start_delim	pointer
;	O
*	O
e_com	pointer
++	O
=	O
*	O
(	O
start_delim	pointer
+	O
1	int
)	O
;	O
column	int
=	O
start_column	int
+	O
2	int
;	O
if	O
(	O
blankline_delims	int
&&	O
!	O
suppress_cdb	int
)	O
{	O
char	O
*	O
p	pointer
=	O
buf_ptr	pointer
;	O
*	O
e_com	pointer
=	O
'\0'	O
;	O
dump_line	function
(	O
true	int
,	O
paren_targ	int
,	O
pbreak_line	pointer
)	O
;	O
p	pointer
=	O
skip_horiz_space	function
(	O
p	pointer
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
EOL	char
)	O
{	O
buf_ptr	pointer
=	O
p	pointer
+	O
1	int
;	O
}	O
else	O
if	O
(	O
format	int
)	O
{	O
buf_ptr	pointer
=	O
p	pointer
;	O
}	O
else	O
{	O
}	O
if	O
(	O
buf_ptr	pointer
>=	O
buf_end	pointer
)	O
{	O
fill_buffer	function
(	O
)	O
;	O
}	O
column	int
=	O
start_column	int
;	O
goto	O
begin_line	O
;	O
}	O
else	O
if	O
(	O
format	int
)	O
{	O
*	O
e_com	pointer
++	O
=	O
' '	O
;	O
column	int
=	O
start_column	int
+	O
3	int
;	O
skip_buffered_space	function
(	O
)	O
;	O
}	O
else	O
{	O
}	O
while	O
(	O
!	O
had_eof	char
)	O
{	O
while	O
(	O
!	O
had_eof	char
)	O
{	O
CHECK_COM_SIZE	O
(	O
1	int
)	O
;	O
switch	O
(	O
*	O
buf_ptr	pointer
)	O
{	O
case	O
' '	O
:	O
case	O
TAB	char
:	O
if	O
(	O
format	int
&&	O
(	O
line_break_ptr	pointer
<	O
text_on_line	pointer
)	O
)	O
{	O
line_break_ptr	pointer
=	O
e_com	pointer
;	O
}	O
if	O
(	O
format	int
)	O
{	O
if	O
(	O
(	O
e_com	pointer
==	O
s_com	pointer
)	O
||	O
(	O
e_com	pointer
[	O
-	O
1	int
]	O
!=	O
' '	O
)	O
||	O
(	O
e_com	pointer
-	O
1	int
==	O
s_com	pointer
)	O
||	O
(	O
e_com	pointer
[	O
-	O
2	int
]	O
==	O
'.'	O
)	O
)	O
{	O
*	O
e_com	pointer
++	O
=	O
' '	O
;	O
column	int
++	O
;	O
}	O
}	O
else	O
if	O
(	O
*	O
buf_ptr	pointer
==	O
' '	O
)	O
{	O
*	O
e_com	pointer
++	O
=	O
' '	O
;	O
column	int
++	O
;	O
}	O
else	O
{	O
int	O
tab_width	int
=	O
(	O
settings	struct
.	O
tabsize	int
-	O
(	O
(	O
column	int
+	O
found_column	int
-	O
start_column	int
-	O
1	int
)	O
%	O
settings	struct
.	O
tabsize	int
)	O
)	O
;	O
column	int
+=	O
tab_width	int
;	O
CHECK_COM_SIZE	O
(	O
tab_width	int
)	O
;	O
while	O
(	O
tab_width	int
--	O
)	O
{	O
*	O
e_com	pointer
++	O
=	O
' '	O
;	O
}	O
}	O
break	O
;	O
case	O
EOL	char
:	O
if	O
(	O
comment_type	enum
==	O
cplus_comment	int
)	O
{	O
cplus_exit	O
:	O
parser_state_tos	pointer
->	O
tos	int
--	O
;	O
parser_state_tos	pointer
->	O
com_col	int
=	O
(	O
two_contiguous_comments	int
?	O
1	int
:	O
start_column	int
)	O
;	O
parser_state_tos	pointer
->	O
box_com	int
=	O
boxed_comment	int
;	O
*	O
e_com	pointer
=	O
0	int
;	O
return	O
;	O
}	O
if	O
(	O
format	int
)	O
{	O
if	O
(	O
*	O
buf_ptr	pointer
==	O
EOL	char
)	O
{	O
++	O
line_no	int
;	O
}	O
buf_ptr	pointer
++	O
;	O
if	O
(	O
buf_ptr	pointer
>=	O
buf_end	pointer
)	O
{	O
fill_buffer	function
(	O
)	O
;	O
}	O
if	O
(	O
(	O
e_com	pointer
>	O
line_break_ptr	pointer
)	O
&&	O
(	O
text_on_line	pointer
<	O
line_break_ptr	pointer
)	O
)	O
{	O
e_com	pointer
=	O
line_break_ptr	pointer
;	O
}	O
skip_buffered_space	function
(	O
)	O
;	O
if	O
(	O
(	O
*	O
buf_ptr	pointer
==	O
EOL	char
)	O
||	O
!	O
text_on_line	pointer
)	O
{	O
paragraph_break	int
=	O
1	int
;	O
goto	O
end_line	O
;	O
}	O
if	O
(	O
!	O
boxed_comment	int
&&	O
(	O
current_column	function
(	O
)	O
==	O
found_column	int
+	O
1	int
)	O
&&	O
(	O
buf_ptr	pointer
[	O
0	int
]	O
==	O
'*'	O
)	O
&&	O
(	O
buf_ptr	pointer
[	O
1	int
]	O
!=	O
'/'	O
)	O
)	O
{	O
if	O
(	O
++	O
buf_ptr	pointer
>=	O
buf_end	pointer
)	O
{	O
fill_buffer	function
(	O
)	O
;	O
}	O
if	O
(	O
(	O
*	O
buf_ptr	pointer
==	O
' '	O
)	O
&&	O
(	O
++	O
buf_ptr	pointer
>=	O
buf_end	pointer
)	O
)	O
{	O
fill_buffer	function
(	O
)	O
;	O
}	O
}	O
if	O
(	O
e_com	pointer
[	O
-	O
1	int
]	O
!=	O
' '	O
)	O
{	O
line_break_ptr	pointer
=	O
e_com	pointer
;	O
*	O
e_com	pointer
++	O
=	O
' '	O
;	O
column	int
++	O
;	O
}	O
continue	O
;	O
}	O
goto	O
end_line	O
;	O
case	O
'*'	O
:	O
if	O
(	O
comment_type	enum
==	O
comment	int
)	O
{	O
if	O
(	O
*	O
(	O
buf_ptr	pointer
+	O
1	int
)	O
==	O
'/'	O
)	O
{	O
if	O
(	O
!	O
boxed_comment	int
)	O
{	O
if	O
(	O
text_on_line	pointer
)	O
{	O
if	O
(	O
blankline_delims	int
&&	O
!	O
suppress_cdb	int
)	O
{	O
*	O
e_com	pointer
=	O
'\0'	O
;	O
dump_line	function
(	O
true	int
,	O
paren_targ	int
,	O
pbreak_line	pointer
)	O
;	O
*	O
e_com	pointer
++	O
=	O
' '	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
*	O
(	O
e_com	pointer
-	O
1	int
)	O
!=	O
' '	O
)	O
&&	O
(	O
*	O
(	O
e_com	pointer
-	O
1	int
)	O
!=	O
TAB	char
)	O
)	O
{	O
*	O
e_com	pointer
++	O
=	O
' '	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
(	O
s_com	pointer
==	O
e_com	pointer
)	O
||	O
(	O
*	O
s_com	pointer
!=	O
'/'	O
)	O
)	O
{	O
e_com	pointer
=	O
s_com	pointer
;	O
*	O
e_com	pointer
++	O
=	O
' '	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
*	O
(	O
e_com	pointer
-	O
1	int
)	O
!=	O
' '	O
)	O
&&	O
(	O
*	O
(	O
e_com	pointer
-	O
1	int
)	O
!=	O
TAB	char
)	O
)	O
{	O
*	O
e_com	pointer
++	O
=	O
' '	O
;	O
}	O
}	O
}	O
CHECK_COM_SIZE	O
(	O
3	int
)	O
;	O
*	O
e_com	pointer
++	O
=	O
'*'	O
;	O
*	O
e_com	pointer
++	O
=	O
'/'	O
;	O
*	O
e_com	pointer
=	O
'\0'	O
;	O
buf_ptr	pointer
+=	O
2	int
;	O
buf_ptr	pointer
=	O
skip_horiz_space	function
(	O
buf_ptr	pointer
)	O
;	O
if	O
(	O
buf_ptr	pointer
>=	O
buf_end	pointer
)	O
{	O
fill_buffer	function
(	O
)	O
;	O
}	O
parser_state_tos	pointer
->	O
tos	int
--	O
;	O
parser_state_tos	pointer
->	O
com_col	int
=	O
(	O
two_contiguous_comments	int
?	O
1	int
:	O
start_column	int
)	O
;	O
parser_state_tos	pointer
->	O
box_com	int
=	O
boxed_comment	int
;	O
return	O
;	O
}	O
if	O
(	O
(	O
first_comment_line	int
==	O
com_lines	int
-	O
1	int
)	O
&&	O
(	O
e_com	pointer
==	O
s_com	pointer
+	O
line_preamble_length	int
)	O
)	O
{	O
column	int
-=	O
line_preamble_length	int
-	O
1	int
;	O
line_preamble	pointer
=	O
" "	pointer
;	O
line_preamble_length	int
=	O
1	int
;	O
boxed_comment	int
=	O
1	int
;	O
format	int
=	O
0	int
;	O
blankline_delims	int
=	O
0	int
;	O
*	O
s_com	pointer
=	O
' '	O
;	O
*	O
(	O
s_com	pointer
+	O
1	int
)	O
=	O
'*'	O
;	O
text_on_line	pointer
=	O
e_com	pointer
=	O
s_com	pointer
+	O
2	int
;	O
column	int
++	O
;	O
break	O
;	O
}	O
}	O
default	O
:	O
text_on_line	pointer
=	O
e_com	pointer
;	O
*	O
e_com	pointer
++	O
=	O
*	O
buf_ptr	pointer
;	O
column	int
++	O
;	O
break	O
;	O
}	O
if	O
(	O
format	int
&&	O
(	O
column	int
>	O
right_margin	int
)	O
&&	O
line_break_ptr	pointer
)	O
{	O
if	O
(	O
line_break_ptr	pointer
<	O
e_com	pointer
-	O
1	int
)	O
{	O
*	O
line_break_ptr	pointer
=	O
'\0'	O
;	O
save_ptr	pointer
=	O
line_break_ptr	pointer
+	O
1	int
;	O
save_length	int
=	O
e_com	pointer
-	O
save_ptr	pointer
;	O
e_com	pointer
=	O
line_break_ptr	pointer
;	O
if	O
(	O
(	O
column	int
-	O
save_length	int
)	O
>	O
right_margin	int
)	O
{	O
right_margin	int
=	O
column	int
-	O
save_length	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
comment_type	enum
==	O
cplus_comment	int
)	O
{	O
buf_ptr	pointer
=	O
skip_horiz_space	function
(	O
buf_ptr	pointer
)	O
;	O
buf_ptr	pointer
--	O
;	O
if	O
(	O
*	O
buf_ptr	pointer
==	O
EOL	char
)	O
{	O
goto	O
cplus_exit	O
;	O
}	O
}	O
else	O
{	O
while	O
(	O
(	O
*	O
buf_ptr	pointer
==	O
TAB	char
)	O
||	O
(	O
*	O
buf_ptr	pointer
==	O
' '	O
)	O
||	O
(	O
*	O
buf_ptr	pointer
==	O
EOL	char
)	O
)	O
{	O
if	O
(	O
*	O
buf_ptr	pointer
==	O
EOL	char
)	O
{	O
++	O
line_no	int
;	O
}	O
buf_ptr	pointer
++	O
;	O
if	O
(	O
buf_ptr	pointer
>=	O
buf_end	pointer
)	O
{	O
fill_buffer	function
(	O
)	O
;	O
}	O
}	O
buf_ptr	pointer
--	O
;	O
}	O
*	O
e_com	pointer
=	O
EOS	char
;	O
}	O
goto	O
end_line	O
;	O
}	O
if	O
(	O
*	O
buf_ptr	pointer
==	O
EOL	char
)	O
{	O
++	O
line_no	int
;	O
}	O
buf_ptr	pointer
++	O
;	O
if	O
(	O
buf_ptr	pointer
==	O
buf_end	pointer
)	O
{	O
fill_buffer	function
(	O
)	O
;	O
}	O
}	O
end_line	O
:	O
if	O
(	O
!	O
text_on_line	pointer
&&	O
!	O
visible_preamble	int
&&	O
!	O
(	O
first_comment_line	int
==	O
com_lines	int
)	O
)	O
{	O
e_com	pointer
=	O
s_com	pointer
;	O
}	O
*	O
e_com	pointer
=	O
EOS	char
;	O
dump_line	function
(	O
true	int
,	O
paren_targ	int
,	O
pbreak_line	pointer
)	O
;	O
prefix_blankline_requested	int
=	O
0	int
;	O
if	O
(	O
paragraph_break	int
)	O
{	O
if	O
(	O
merge_blank_comment_lines	int
)	O
{	O
while	O
(	O
(	O
*	O
buf_ptr	pointer
==	O
EOL	char
)	O
||	O
(	O
*	O
buf_ptr	pointer
==	O
' '	O
)	O
||	O
(	O
*	O
buf_ptr	pointer
==	O
TAB	char
)	O
)	O
{	O
if	O
(	O
*	O
buf_ptr	pointer
==	O
EOL	char
)	O
{	O
++	O
line_no	int
;	O
}	O
if	O
(	O
++	O
buf_ptr	pointer
>=	O
buf_end	pointer
)	O
{	O
fill_buffer	function
(	O
)	O
;	O
}	O
}	O
}	O
paragraph_break	int
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
*	O
buf_ptr	pointer
==	O
EOL	char
)	O
{	O
++	O
line_no	int
;	O
}	O
buf_ptr	pointer
++	O
;	O
if	O
(	O
buf_ptr	pointer
>=	O
buf_end	pointer
)	O
{	O
fill_buffer	function
(	O
)	O
;	O
}	O
}	O
begin_line	O
:	O
if	O
(	O
had_eof	char
)	O
{	O
break	O
;	O
}	O
if	O
(	O
line_preamble	pointer
&&	O
line_preamble_length	int
>	O
0	int
)	O
{	O
CHECK_COM_SIZE	O
(	O
line_preamble_length	int
)	O
;	O
(	O
void	O
)	O
memcpy	function
(	O
e_com	pointer
,	O
line_preamble	pointer
,	O
line_preamble_length	int
)	O
;	O
e_com	pointer
+=	O
line_preamble_length	int
;	O
column	int
=	O
start_column	int
+	O
line_preamble_length	int
;	O
}	O
else	O
{	O
column	int
=	O
start_column	int
;	O
}	O
line_break_ptr	pointer
=	O
0	int
;	O
if	O
(	O
save_ptr	pointer
)	O
{	O
while	O
(	O
(	O
(	O
*	O
save_ptr	pointer
==	O
' '	O
)	O
||	O
(	O
*	O
save_ptr	pointer
==	O
TAB	char
)	O
)	O
&&	O
save_length	int
)	O
{	O
save_ptr	pointer
++	O
;	O
save_length	int
--	O
;	O
}	O
CHECK_COM_SIZE	O
(	O
save_length	int
)	O
;	O
(	O
void	O
)	O
memmove	function
(	O
e_com	pointer
,	O
save_ptr	pointer
,	O
save_length	int
)	O
;	O
text_on_line	pointer
=	O
e_com	pointer
;	O
e_com	pointer
+=	O
save_length	int
;	O
column	int
+=	O
save_length	int
;	O
save_ptr	pointer
=	O
0	int
;	O
save_length	int
=	O
0	int
;	O
}	O
else	O
{	O
skip_buffered_space	function
(	O
)	O
;	O
text_on_line	pointer
=	O
0	int
;	O
}	O
}	O
parser_state_tos	pointer
->	O
tos	int
--	O
;	O
parser_state_tos	pointer
->	O
com_col	int
=	O
(	O
two_contiguous_comments	int
?	O
1	int
:	O
start_column	int
)	O
;	O
parser_state_tos	pointer
->	O
box_com	int
=	O
boxed_comment	int
;	O
}	O
