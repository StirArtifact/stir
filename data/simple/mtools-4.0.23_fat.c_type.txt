typedef	O
long	O
long	O
fatBitMask	long long
;	O
typedef	O
struct	O
FatMap_t	struct
{	O
unsigned	O
char	O
*	O
data	pointer
;	O
fatBitMask	long long
dirty	long long
;	O
fatBitMask	long long
valid	long long
;	O
}	O
FatMap_t	struct
;	O
static	O
__inline__	O
int	O
readSector	function
(	O
Fs_t	struct
*	O
This	pointer
,	O
char	O
*	O
buf	pointer
,	O
unsigned	O
int	O
off	long
,	O
size_t	long
size	array
)	O
{	O
return	O
READS	O
(	O
This	pointer
->	O
Next	pointer
,	O
buf	pointer
,	O
sectorsToBytes	function
(	O
(	O
Stream_t	struct
*	O
)	O
This	pointer
,	O
off	long
)	O
,	O
size	array
<<	O
This	pointer
->	O
sectorShift	int
)	O
;	O
}	O
static	O
__inline__	O
int	O
forceReadSector	function
(	O
Fs_t	struct
*	O
This	pointer
,	O
char	O
*	O
buf	pointer
,	O
unsigned	O
int	O
off	long
,	O
size_t	long
size	array
)	O
{	O
return	O
force_read	function
(	O
This	pointer
->	O
Next	pointer
,	O
buf	pointer
,	O
sectorsToBytes	function
(	O
(	O
Stream_t	struct
*	O
)	O
This	pointer
,	O
off	long
)	O
,	O
size	array
<<	O
This	pointer
->	O
sectorShift	int
)	O
;	O
}	O
static	O
__inline__	O
int	O
forceWriteSector	function
(	O
Fs_t	struct
*	O
This	pointer
,	O
char	O
*	O
buf	pointer
,	O
unsigned	O
int	O
off	long
,	O
size_t	long
size	array
)	O
{	O
return	O
force_write	function
(	O
This	pointer
->	O
Next	pointer
,	O
buf	pointer
,	O
sectorsToBytes	function
(	O
(	O
Stream_t	struct
*	O
)	O
This	pointer
,	O
off	long
)	O
,	O
size	array
<<	O
This	pointer
->	O
sectorShift	int
)	O
;	O
}	O
static	O
FatMap_t	struct
*	O
GetFatMap	function
(	O
Fs_t	struct
*	O
Stream	pointer
)	O
{	O
size_t	long
nr_entries	long
;	O
size_t	long
i	long
;	O
FatMap_t	struct
*	O
map	pointer
;	O
Stream	pointer
->	O
fat_error	function
=	O
0	int
;	O
nr_entries	long
=	O
(	O
Stream	pointer
->	O
fat_len	int
+	O
SECT_PER_ENTRY	O
-	O
1	int
)	O
/	O
SECT_PER_ENTRY	O
;	O
map	pointer
=	O
NewArray	O
(	O
nr_entries	long
,	O
FatMap_t	struct
)	O
;	O
if	O
(	O
!	O
map	pointer
)	O
return	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nr_entries	long
;	O
i	long
++	O
)	O
{	O
map	pointer
[	O
i	long
]	O
.	O
data	pointer
=	O
0	int
;	O
map	pointer
[	O
i	long
]	O
.	O
valid	long long
=	O
0	int
;	O
map	pointer
[	O
i	long
]	O
.	O
dirty	long long
=	O
0	int
;	O
}	O
return	O
map	pointer
;	O
}	O
static	O
__inline__	O
int	O
locate	function
(	O
Fs_t	struct
*	O
Stream	pointer
,	O
size_t	long
offset	long
,	O
int	O
*	O
slot	pointer
,	O
int	O
*	O
bit	pointer
)	O
{	O
if	O
(	O
offset	long
>=	O
Stream	pointer
->	O
fat_len	int
)	O
return	O
-	O
1	int
;	O
*	O
slot	pointer
=	O
offset	long
/	O
SECT_PER_ENTRY	O
;	O
*	O
bit	pointer
=	O
offset	long
%	O
SECT_PER_ENTRY	O
;	O
return	O
0	int
;	O
}	O
static	O
__inline__	O
int	O
fatReadSector	function
(	O
Fs_t	struct
*	O
This	pointer
,	O
int	O
sector	int
,	O
int	O
slot	pointer
,	O
int	O
bit	pointer
,	O
int	O
dupe	int
,	O
fatBitMask	long long
bitmap	long long
)	O
{	O
int	O
fat_start	int
,	O
ret	int
;	O
int	O
nr_sectors	int
;	O
dupe	int
=	O
(	O
dupe	int
+	O
This	pointer
->	O
primaryFat	int
)	O
%	O
This	pointer
->	O
num_fat	int
;	O
fat_start	int
=	O
This	pointer
->	O
fat_start	int
+	O
This	pointer
->	O
fat_len	int
*	O
dupe	int
;	O
if	O
(	O
bitmap	long long
==	O
0	int
)	O
{	O
nr_sectors	int
=	O
SECT_PER_ENTRY	O
-	O
bit	pointer
%	O
SECT_PER_ENTRY	O
;	O
}	O
else	O
{	O
nr_sectors	int
=	O
1	int
;	O
}	O
ret	int
=	O
readSector	function
(	O
This	pointer
,	O
(	O
char	O
*	O
)	O
(	O
This	pointer
->	O
FatMap	pointer
[	O
slot	pointer
]	O
.	O
data	pointer
+	O
(	O
bit	pointer
<<	O
This	pointer
->	O
sectorShift	int
)	O
)	O
,	O
fat_start	int
+	O
sector	int
,	O
nr_sectors	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
(	O
unsigned	O
int	O
)	O
ret	int
<	O
This	pointer
->	O
sector_size	int
)	O
{	O
ret	int
=	O
forceReadSector	function
(	O
This	pointer
,	O
(	O
char	O
*	O
)	O
(	O
This	pointer
->	O
FatMap	pointer
[	O
slot	pointer
]	O
.	O
data	pointer
+	O
(	O
bit	pointer
<<	O
This	pointer
->	O
sectorShift	int
)	O
)	O
,	O
fat_start	int
+	O
sector	int
,	O
1	int
)	O
;	O
if	O
(	O
ret	int
<	O
(	O
int	O
)	O
This	pointer
->	O
sector_size	int
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
return	O
ret	int
>>	O
This	pointer
->	O
sectorShift	int
;	O
}	O
static	O
int	O
fatWriteSector	function
(	O
Fs_t	struct
*	O
This	pointer
,	O
int	O
sector	int
,	O
int	O
slot	pointer
,	O
int	O
bit	pointer
,	O
int	O
dupe	int
)	O
{	O
int	O
fat_start	int
;	O
dupe	int
=	O
(	O
dupe	int
+	O
This	pointer
->	O
primaryFat	int
)	O
%	O
This	pointer
->	O
num_fat	int
;	O
if	O
(	O
dupe	int
&&	O
!	O
This	pointer
->	O
writeAllFats	int
)	O
return	O
This	pointer
->	O
sector_size	int
;	O
fat_start	int
=	O
This	pointer
->	O
fat_start	int
+	O
This	pointer
->	O
fat_len	int
*	O
dupe	int
;	O
return	O
forceWriteSector	function
(	O
This	pointer
,	O
(	O
char	O
*	O
)	O
(	O
This	pointer
->	O
FatMap	pointer
[	O
slot	pointer
]	O
.	O
data	pointer
+	O
bit	pointer
*	O
This	pointer
->	O
sector_size	int
)	O
,	O
fat_start	int
+	O
sector	int
,	O
1	int
)	O
;	O
}	O
static	O
unsigned	O
char	O
*	O
loadSector	function
(	O
Fs_t	struct
*	O
This	pointer
,	O
unsigned	O
int	O
sector	int
,	O
fatAccessMode_t	enum
mode	int
,	O
int	O
recurs	int
)	O
{	O
int	O
slot	pointer
,	O
bit	pointer
,	O
ret	int
;	O
if	O
(	O
locate	function
(	O
This	pointer
,	O
sector	int
,	O
&	O
slot	pointer
,	O
&	O
bit	pointer
)	O
<	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
!	O
This	pointer
->	O
FatMap	pointer
[	O
slot	pointer
]	O
.	O
data	pointer
)	O
{	O
This	pointer
->	O
FatMap	pointer
[	O
slot	pointer
]	O
.	O
data	pointer
=	O
malloc	function
(	O
This	pointer
->	O
sector_size	int
*	O
SECT_PER_ENTRY	O
)	O
;	O
if	O
(	O
!	O
This	pointer
->	O
FatMap	pointer
[	O
slot	pointer
]	O
.	O
data	pointer
)	O
return	O
0	int
;	O
memset	function
(	O
This	pointer
->	O
FatMap	pointer
[	O
slot	pointer
]	O
.	O
data	pointer
,	O
0xee	int
,	O
This	pointer
->	O
sector_size	int
*	O
SECT_PER_ENTRY	O
)	O
;	O
}	O
if	O
(	O
!	O
(	O
This	pointer
->	O
FatMap	pointer
[	O
slot	pointer
]	O
.	O
valid	long long
&	O
(	O
ONE	O
<<	O
bit	pointer
)	O
)	O
)	O
{	O
unsigned	O
int	O
i	long
;	O
ret	int
=	O
-	O
1	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
This	pointer
->	O
num_fat	int
;	O
i	long
++	O
)	O
{	O
ret	int
=	O
fatReadSector	function
(	O
This	pointer
,	O
sector	int
,	O
slot	pointer
,	O
bit	pointer
,	O
i	long
,	O
This	pointer
->	O
FatMap	pointer
[	O
slot	pointer
]	O
.	O
valid	long long
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Error reading fat number %d\n"	pointer
,	O
i	long
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
This	pointer
->	O
FatMap	pointer
[	O
slot	pointer
]	O
.	O
valid	long long
)	O
recurs	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
ret	int
==	O
0	int
)	O
return	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
(	O
int	O
)	O
i	long
<	O
ret	int
;	O
i	long
++	O
)	O
This	pointer
->	O
FatMap	pointer
[	O
slot	pointer
]	O
.	O
valid	long long
|=	O
ONE	O
<<	O
(	O
bit	pointer
+	O
i	long
)	O
;	O
if	O
(	O
!	O
recurs	int
&&	O
ret	int
==	O
1	int
)	O
loadSector	function
(	O
This	pointer
,	O
sector	int
+	O
1	int
,	O
mode	int
,	O
1	int
)	O
;	O
if	O
(	O
!	O
recurs	int
&&	O
batchmode	int
)	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
1024	int
;	O
i	long
++	O
)	O
loadSector	function
(	O
This	pointer
,	O
sector	int
+	O
i	long
,	O
mode	int
,	O
1	int
)	O
;	O
}	O
if	O
(	O
mode	int
==	O
FAT_ACCESS_WRITE	int
)	O
{	O
This	pointer
->	O
FatMap	pointer
[	O
slot	pointer
]	O
.	O
dirty	long long
|=	O
ONE	O
<<	O
bit	pointer
;	O
This	pointer
->	O
fat_dirty	int
=	O
1	int
;	O
}	O
return	O
This	pointer
->	O
FatMap	pointer
[	O
slot	pointer
]	O
.	O
data	pointer
+	O
(	O
bit	pointer
<<	O
This	pointer
->	O
sectorShift	int
)	O
;	O
}	O
static	O
unsigned	O
char	O
*	O
getAddress	function
(	O
Fs_t	struct
*	O
Stream	pointer
,	O
unsigned	O
int	O
num	int
,	O
fatAccessMode_t	enum
mode	int
)	O
{	O
unsigned	O
char	O
*	O
ret	int
;	O
int	O
sector	int
;	O
int	O
offset	long
;	O
sector	int
=	O
num	int
>>	O
Stream	pointer
->	O
sectorShift	int
;	O
ret	int
=	O
0	int
;	O
if	O
(	O
sector	int
==	O
Stream	pointer
->	O
lastFatSectorNr	int
&&	O
Stream	pointer
->	O
lastFatAccessMode	enum
>=	O
mode	int
)	O
ret	int
=	O
Stream	pointer
->	O
lastFatSectorData	pointer
;	O
if	O
(	O
!	O
ret	int
)	O
{	O
ret	int
=	O
loadSector	function
(	O
Stream	pointer
,	O
sector	int
,	O
mode	int
,	O
0	int
)	O
;	O
if	O
(	O
!	O
ret	int
)	O
return	O
0	int
;	O
Stream	pointer
->	O
lastFatSectorNr	int
=	O
sector	int
;	O
Stream	pointer
->	O
lastFatSectorData	pointer
=	O
ret	int
;	O
Stream	pointer
->	O
lastFatAccessMode	enum
=	O
mode	int
;	O
}	O
offset	long
=	O
num	int
&	O
Stream	pointer
->	O
sectorMask	int
;	O
return	O
ret	int
+	O
offset	long
;	O
}	O
static	O
int	O
readByte	function
(	O
Fs_t	struct
*	O
Stream	pointer
,	O
int	O
start	array
)	O
{	O
unsigned	O
char	O
*	O
address	long
;	O
address	long
=	O
getAddress	function
(	O
Stream	pointer
,	O
start	array
,	O
FAT_ACCESS_READ	int
)	O
;	O
if	O
(	O
!	O
address	long
)	O
return	O
-	O
1	int
;	O
return	O
*	O
address	long
;	O
}	O
static	O
unsigned	O
int	O
fat12_decode	function
(	O
Fs_t	struct
*	O
Stream	pointer
,	O
unsigned	O
int	O
num	int
)	O
{	O
unsigned	O
int	O
start	array
=	O
num	int
*	O
3	int
/	O
2	int
;	O
int	O
byte0	int
=	O
readByte	function
(	O
Stream	pointer
,	O
start	array
)	O
;	O
int	O
byte1	int
=	O
readByte	function
(	O
Stream	pointer
,	O
start	array
+	O
1	int
)	O
;	O
if	O
(	O
num	int
<	O
2	int
||	O
byte0	int
<	O
0	int
||	O
byte1	int
<	O
0	int
||	O
num	int
>	O
Stream	pointer
->	O
num_clus	int
+	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"[1] Bad address %d\n"	pointer
,	O
num	int
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
num	int
&	O
1	int
)	O
return	O
(	O
byte1	int
<<	O
4	int
)	O
|	O
(	O
(	O
byte0	int
&	O
0xf0	int
)	O
>>	O
4	int
)	O
;	O
else	O
return	O
(	O
(	O
byte1	int
&	O
0xf	int
)	O
<<	O
8	int
)	O
|	O
byte0	int
;	O
}	O
static	O
void	O
fat12_encode	function
(	O
Fs_t	struct
*	O
Stream	pointer
,	O
unsigned	O
int	O
num	int
,	O
unsigned	O
int	O
code	int
)	O
{	O
int	O
start	array
=	O
num	int
*	O
3	int
/	O
2	int
;	O
unsigned	O
char	O
*	O
address0	pointer
=	O
getAddress	function
(	O
Stream	pointer
,	O
start	array
,	O
FAT_ACCESS_WRITE	int
)	O
;	O
unsigned	O
char	O
*	O
address1	pointer
=	O
getAddress	function
(	O
Stream	pointer
,	O
start	array
+	O
1	int
,	O
FAT_ACCESS_WRITE	int
)	O
;	O
if	O
(	O
num	int
&	O
1	int
)	O
{	O
*	O
address0	pointer
=	O
(	O
*	O
address0	pointer
&	O
0x0f	int
)	O
|	O
(	O
(	O
code	int
<<	O
4	int
)	O
&	O
0xf0	int
)	O
;	O
*	O
address1	pointer
=	O
(	O
code	int
>>	O
4	int
)	O
&	O
0xff	int
;	O
}	O
else	O
{	O
*	O
address0	pointer
=	O
code	int
&	O
0xff	int
;	O
*	O
address1	pointer
=	O
(	O
*	O
address1	pointer
&	O
0xf0	int
)	O
|	O
(	O
(	O
code	int
>>	O
8	int
)	O
&	O
0x0f	int
)	O
;	O
}	O
}	O
static	O
unsigned	O
int	O
fat16_decode	function
(	O
Fs_t	struct
*	O
Stream	pointer
,	O
unsigned	O
int	O
num	int
)	O
{	O
unsigned	O
char	O
*	O
address	long
=	O
getAddress	function
(	O
Stream	pointer
,	O
num	int
<<	O
1	int
,	O
FAT_ACCESS_READ	int
)	O
;	O
if	O
(	O
!	O
address	long
)	O
return	O
1	int
;	O
return	O
_WORD	O
(	O
address	long
)	O
;	O
}	O
static	O
void	O
fat16_encode	function
(	O
Fs_t	struct
*	O
Stream	pointer
,	O
unsigned	O
int	O
num	int
,	O
unsigned	O
int	O
code	int
)	O
{	O
unsigned	O
char	O
*	O
address	long
=	O
getAddress	function
(	O
Stream	pointer
,	O
num	int
<<	O
1	int
,	O
FAT_ACCESS_WRITE	int
)	O
;	O
set_word	function
(	O
address	long
,	O
code	int
)	O
;	O
}	O
static	O
unsigned	O
int	O
fast_fat16_decode	function
(	O
Fs_t	struct
*	O
Stream	pointer
,	O
unsigned	O
int	O
num	int
)	O
{	O
unsigned	O
short	O
*	O
address	long
=	O
(	O
unsigned	O
short	O
*	O
)	O
getAddress	function
(	O
Stream	pointer
,	O
num	int
<<	O
1	int
,	O
FAT_ACCESS_READ	int
)	O
;	O
if	O
(	O
!	O
address	long
)	O
return	O
1	int
;	O
return	O
*	O
address	long
;	O
}	O
static	O
void	O
fast_fat16_encode	function
(	O
Fs_t	struct
*	O
Stream	pointer
,	O
unsigned	O
int	O
num	int
,	O
unsigned	O
int	O
code	int
)	O
{	O
unsigned	O
short	O
*	O
address	long
=	O
(	O
unsigned	O
short	O
*	O
)	O
getAddress	function
(	O
Stream	pointer
,	O
num	int
<<	O
1	int
,	O
FAT_ACCESS_WRITE	int
)	O
;	O
*	O
address	long
=	O
code	int
;	O
}	O
static	O
unsigned	O
int	O
fat32_decode	function
(	O
Fs_t	struct
*	O
Stream	pointer
,	O
unsigned	O
int	O
num	int
)	O
{	O
unsigned	O
char	O
*	O
address	long
=	O
getAddress	function
(	O
Stream	pointer
,	O
num	int
<<	O
2	int
,	O
FAT_ACCESS_READ	int
)	O
;	O
if	O
(	O
!	O
address	long
)	O
return	O
1	int
;	O
return	O
_DWORD	O
(	O
address	long
)	O
&	O
FAT32_ADDR	int
;	O
}	O
static	O
void	O
fat32_encode	function
(	O
Fs_t	struct
*	O
Stream	pointer
,	O
unsigned	O
int	O
num	int
,	O
unsigned	O
int	O
code	int
)	O
{	O
unsigned	O
char	O
*	O
address	long
=	O
getAddress	function
(	O
Stream	pointer
,	O
num	int
<<	O
2	int
,	O
FAT_ACCESS_WRITE	int
)	O
;	O
set_dword	function
(	O
address	long
,	O
(	O
code	int
&	O
FAT32_ADDR	int
)	O
|	O
(	O
_DWORD	O
(	O
address	long
)	O
&	O
FAT32_HIGH	int
)	O
)	O
;	O
}	O
static	O
unsigned	O
int	O
fast_fat32_decode	function
(	O
Fs_t	struct
*	O
Stream	pointer
,	O
unsigned	O
int	O
num	int
)	O
{	O
unsigned	O
int	O
*	O
address	long
=	O
(	O
unsigned	O
int	O
*	O
)	O
getAddress	function
(	O
Stream	pointer
,	O
num	int
<<	O
2	int
,	O
FAT_ACCESS_READ	int
)	O
;	O
if	O
(	O
!	O
address	long
)	O
return	O
1	int
;	O
return	O
(	O
*	O
address	long
)	O
&	O
FAT32_ADDR	int
;	O
}	O
static	O
void	O
fast_fat32_encode	function
(	O
Fs_t	struct
*	O
Stream	pointer
,	O
unsigned	O
int	O
num	int
,	O
unsigned	O
int	O
code	int
)	O
{	O
unsigned	O
int	O
*	O
address	long
=	O
(	O
unsigned	O
int	O
*	O
)	O
getAddress	function
(	O
Stream	pointer
,	O
num	int
<<	O
2	int
,	O
FAT_ACCESS_WRITE	int
)	O
;	O
*	O
address	long
=	O
(	O
*	O
address	long
&	O
FAT32_HIGH	int
)	O
|	O
(	O
code	int
&	O
FAT32_ADDR	int
)	O
;	O
}	O
void	O
fat_write	function
(	O
Fs_t	struct
*	O
This	pointer
)	O
{	O
unsigned	O
int	O
i	long
,	O
j	int
,	O
dups	int
,	O
bit	pointer
,	O
slot	pointer
;	O
int	O
ret	int
;	O
if	O
(	O
!	O
This	pointer
->	O
fat_dirty	int
)	O
return	O
;	O
dups	int
=	O
This	pointer
->	O
num_fat	int
;	O
if	O
(	O
This	pointer
->	O
fat_error	function
)	O
dups	int
=	O
1	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
dups	int
;	O
i	long
++	O
)	O
{	O
j	int
=	O
0	int
;	O
for	O
(	O
slot	pointer
=	O
0	int
;	O
j	int
<	O
This	pointer
->	O
fat_len	int
;	O
slot	pointer
++	O
)	O
{	O
if	O
(	O
!	O
This	pointer
->	O
FatMap	pointer
[	O
slot	pointer
]	O
.	O
dirty	long long
)	O
{	O
j	int
+=	O
SECT_PER_ENTRY	O
;	O
continue	O
;	O
}	O
for	O
(	O
bit	pointer
=	O
0	int
;	O
bit	pointer
<	O
SECT_PER_ENTRY	O
&&	O
j	int
<	O
This	pointer
->	O
fat_len	int
;	O
bit	pointer
++	O
,	O
j	int
++	O
)	O
{	O
if	O
(	O
!	O
(	O
This	pointer
->	O
FatMap	pointer
[	O
slot	pointer
]	O
.	O
dirty	long long
&	O
(	O
ONE	O
<<	O
bit	pointer
)	O
)	O
)	O
continue	O
;	O
ret	int
=	O
fatWriteSector	function
(	O
This	pointer
,	O
j	int
,	O
slot	pointer
,	O
bit	pointer
,	O
i	long
)	O
;	O
if	O
(	O
ret	int
<	O
(	O
int	O
)	O
This	pointer
->	O
sector_size	int
)	O
{	O
if	O
(	O
ret	int
<	O
0	int
)	O
{	O
perror	function
(	O
"error in fat_write"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"end of file in fat_write\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
i	long
==	O
dups	int
-	O
1	int
)	O
This	pointer
->	O
FatMap	pointer
[	O
slot	pointer
]	O
.	O
dirty	long long
&=	O
~	O
(	O
ONE	O
<<	O
bit	pointer
)	O
;	O
}	O
}	O
}	O
if	O
(	O
This	pointer
->	O
infoSectorLoc	int
&&	O
This	pointer
->	O
infoSectorLoc	int
!=	O
MAX32	int
)	O
{	O
InfoSector_t	struct
*	O
infoSector	array
;	O
infoSector	array
=	O
(	O
InfoSector_t	struct
*	O
)	O
safe_malloc	function
(	O
This	pointer
->	O
sector_size	int
)	O
;	O
set_dword	function
(	O
infoSector	array
->	O
signature1	array
,	O
INFOSECT_SIGNATURE1	int
)	O
;	O
memset	function
(	O
infoSector	array
->	O
filler1	array
,	O
0	int
,	O
sizeof	O
(	O
infoSector	array
->	O
filler1	array
)	O
)	O
;	O
memset	function
(	O
infoSector	array
->	O
filler2	array
,	O
0	int
,	O
sizeof	O
(	O
infoSector	array
->	O
filler2	array
)	O
)	O
;	O
set_dword	function
(	O
infoSector	array
->	O
signature2	array
,	O
INFOSECT_SIGNATURE2	int
)	O
;	O
set_dword	function
(	O
infoSector	array
->	O
pos	array
,	O
This	pointer
->	O
last	int
)	O
;	O
set_dword	function
(	O
infoSector	array
->	O
count	array
,	O
This	pointer
->	O
freeSpace	int
)	O
;	O
set_word	function
(	O
infoSector	array
->	O
signature3	array
,	O
0xaa55	int
)	O
;	O
if	O
(	O
forceWriteSector	function
(	O
This	pointer
,	O
(	O
char	O
*	O
)	O
infoSector	array
,	O
This	pointer
->	O
infoSectorLoc	int
,	O
1	int
)	O
!=	O
(	O
signed	O
int	O
)	O
This	pointer
->	O
sector_size	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"Trouble writing the info sector\n"	pointer
)	O
;	O
free	function
(	O
infoSector	array
)	O
;	O
}	O
This	pointer
->	O
fat_dirty	int
=	O
0	int
;	O
This	pointer
->	O
lastFatAccessMode	enum
=	O
FAT_ACCESS_READ	int
;	O
}	O
int	O
zero_fat	function
(	O
Fs_t	struct
*	O
Stream	pointer
,	O
int	O
media_descriptor	int
)	O
{	O
unsigned	O
int	O
i	long
,	O
j	int
;	O
unsigned	O
int	O
fat_start	int
;	O
unsigned	O
char	O
*	O
buf	pointer
;	O
buf	pointer
=	O
malloc	function
(	O
Stream	pointer
->	O
sector_size	int
)	O
;	O
if	O
(	O
!	O
buf	pointer
)	O
{	O
perror	function
(	O
"alloc fat sector buffer"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
Stream	pointer
->	O
num_fat	int
;	O
i	long
++	O
)	O
{	O
fat_start	int
=	O
Stream	pointer
->	O
fat_start	int
+	O
i	long
*	O
Stream	pointer
->	O
fat_len	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
Stream	pointer
->	O
fat_len	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
j	int
<=	O
1	int
)	O
memset	function
(	O
buf	pointer
,	O
0	int
,	O
Stream	pointer
->	O
sector_size	int
)	O
;	O
if	O
(	O
!	O
j	int
)	O
{	O
buf	pointer
[	O
0	int
]	O
=	O
media_descriptor	int
;	O
buf	pointer
[	O
2	int
]	O
=	O
buf	pointer
[	O
1	int
]	O
=	O
0xff	int
;	O
if	O
(	O
Stream	pointer
->	O
fat_bits	int
>	O
12	int
)	O
buf	pointer
[	O
3	int
]	O
=	O
0xff	int
;	O
if	O
(	O
Stream	pointer
->	O
fat_bits	int
>	O
16	int
)	O
{	O
buf	pointer
[	O
4	int
]	O
=	O
0xff	int
;	O
buf	pointer
[	O
5	int
]	O
=	O
0xff	int
;	O
buf	pointer
[	O
6	int
]	O
=	O
0xff	int
;	O
buf	pointer
[	O
7	int
]	O
=	O
0x0f	int
;	O
}	O
}	O
if	O
(	O
forceWriteSector	function
(	O
Stream	pointer
,	O
(	O
char	O
*	O
)	O
buf	pointer
,	O
fat_start	int
+	O
j	int
,	O
1	int
)	O
!=	O
(	O
signed	O
int	O
)	O
Stream	pointer
->	O
sector_size	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Trouble initializing a FAT sector\n"	pointer
)	O
;	O
free	function
(	O
buf	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
}	O
free	function
(	O
buf	pointer
)	O
;	O
Stream	pointer
->	O
FatMap	pointer
=	O
GetFatMap	function
(	O
Stream	pointer
)	O
;	O
if	O
(	O
Stream	pointer
->	O
FatMap	pointer
==	O
NULL	O
)	O
{	O
perror	function
(	O
"alloc fat map"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
set_fat12	function
(	O
Fs_t	struct
*	O
This	pointer
)	O
{	O
This	pointer
->	O
fat_bits	int
=	O
12	int
;	O
This	pointer
->	O
end_fat	int
=	O
0xfff	int
;	O
This	pointer
->	O
last_fat	int
=	O
0xff6	int
;	O
This	pointer
->	O
fat_decode	pointer
=	O
fat12_decode	function
;	O
This	pointer
->	O
fat_encode	pointer
=	O
fat12_encode	function
;	O
}	O
static	O
char	O
word_endian_test	array
[	O
]	O
=	O
{	O
0x34	int
,	O
0x12	int
}	O
;	O
void	O
set_fat16	function
(	O
Fs_t	struct
*	O
This	pointer
)	O
{	O
This	pointer
->	O
fat_bits	int
=	O
16	int
;	O
This	pointer
->	O
end_fat	int
=	O
0xffff	int
;	O
This	pointer
->	O
last_fat	int
=	O
0xfff6	int
;	O
if	O
(	O
sizeof	O
(	O
unsigned	O
short	O
)	O
==	O
2	int
&&	O
*	O
(	O
unsigned	O
short	O
*	O
)	O
word_endian_test	array
==	O
0x1234	int
)	O
{	O
This	pointer
->	O
fat_decode	pointer
=	O
fast_fat16_decode	function
;	O
This	pointer
->	O
fat_encode	pointer
=	O
fast_fat16_encode	function
;	O
}	O
else	O
{	O
This	pointer
->	O
fat_decode	pointer
=	O
fat16_decode	function
;	O
This	pointer
->	O
fat_encode	pointer
=	O
fat16_encode	function
;	O
}	O
}	O
static	O
char	O
dword_endian_test	array
[	O
]	O
=	O
{	O
0x78	int
,	O
0x56	int
,	O
0x34	int
,	O
0x12	int
}	O
;	O
void	O
set_fat32	function
(	O
Fs_t	struct
*	O
This	pointer
)	O
{	O
This	pointer
->	O
fat_bits	int
=	O
32	int
;	O
This	pointer
->	O
end_fat	int
=	O
0xfffffff	int
;	O
This	pointer
->	O
last_fat	int
=	O
0xffffff6	int
;	O
if	O
(	O
sizeof	O
(	O
unsigned	O
int	O
)	O
==	O
4	int
&&	O
*	O
(	O
unsigned	O
int	O
*	O
)	O
dword_endian_test	array
==	O
0x12345678	int
)	O
{	O
This	pointer
->	O
fat_decode	pointer
=	O
fast_fat32_decode	function
;	O
This	pointer
->	O
fat_encode	pointer
=	O
fast_fat32_encode	function
;	O
}	O
else	O
{	O
This	pointer
->	O
fat_decode	pointer
=	O
fat32_decode	function
;	O
This	pointer
->	O
fat_encode	pointer
=	O
fat32_encode	function
;	O
}	O
}	O
static	O
int	O
check_fat	function
(	O
Fs_t	struct
*	O
This	pointer
)	O
{	O
unsigned	O
int	O
i	long
,	O
f	int
;	O
unsigned	O
int	O
tocheck	int
;	O
if	O
(	O
mtools_skip_check	int
)	O
return	O
0	int
;	O
if	O
(	O
This	pointer
->	O
fat_len	int
<	O
NEEDED_FAT_SIZE	O
(	O
This	pointer
)	O
)	O
return	O
-	O
1	int
;	O
tocheck	int
=	O
This	pointer
->	O
num_clus	int
;	O
if	O
(	O
tocheck	int
+	O
1	int
>=	O
This	pointer
->	O
last_fat	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Too many clusters in FAT\n"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
tocheck	int
>	O
4096	int
)	O
tocheck	int
=	O
4096	int
;	O
for	O
(	O
i	long
=	O
3	int
;	O
i	long
<	O
tocheck	int
;	O
i	long
++	O
)	O
{	O
f	int
=	O
This	pointer
->	O
fat_decode	pointer
(	O
This	pointer
,	O
i	long
)	O
;	O
if	O
(	O
f	int
==	O
1	int
||	O
(	O
f	int
<	O
This	pointer
->	O
last_fat	int
&&	O
f	int
>	O
This	pointer
->	O
num_clus	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Cluster # at %d too big(%#x)\n"	pointer
,	O
i	long
,	O
f	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Probably non MS-DOS disk\n"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
check_media_type	function
(	O
Fs_t	struct
*	O
This	pointer
,	O
union	O
bootsector	union
*	O
boot	struct
,	O
unsigned	O
int	O
tot_sectors	long
)	O
{	O
unsigned	O
char	O
*	O
address	long
;	O
This	pointer
->	O
num_clus	int
=	O
(	O
tot_sectors	long
-	O
This	pointer
->	O
clus_start	int
)	O
/	O
This	pointer
->	O
cluster_size	int
;	O
This	pointer
->	O
FatMap	pointer
=	O
GetFatMap	function
(	O
This	pointer
)	O
;	O
if	O
(	O
This	pointer
->	O
FatMap	pointer
==	O
NULL	O
)	O
{	O
perror	function
(	O
"alloc fat map"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
address	long
=	O
getAddress	function
(	O
This	pointer
,	O
0	int
,	O
FAT_ACCESS_READ	int
)	O
;	O
if	O
(	O
!	O
address	long
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Could not read first FAT sector\n"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
mtools_skip_check	int
)	O
return	O
0	int
;	O
if	O
(	O
!	O
address	long
[	O
0	int
]	O
&&	O
!	O
address	long
[	O
1	int
]	O
&&	O
!	O
address	long
[	O
2	int
]	O
)	O
return	O
0	int
;	O
if	O
(	O
(	O
address	long
[	O
0	int
]	O
!=	O
boot	struct
->	O
boot	struct
.	O
descr	char
&&	O
boot	struct
->	O
boot	struct
.	O
descr	char
>=	O
0xf0	int
&&	O
(	O
(	O
address	long
[	O
0	int
]	O
!=	O
0xf9	int
&&	O
address	long
[	O
0	int
]	O
!=	O
0xf7	int
)	O
||	O
boot	struct
->	O
boot	struct
.	O
descr	char
!=	O
0xf0	int
)	O
)	O
||	O
address	long
[	O
0	int
]	O
<	O
0xf0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Bad media types %02x/%02x, probably non-MSDOS disk\n"	pointer
,	O
address	long
[	O
0	int
]	O
,	O
boot	struct
->	O
boot	struct
.	O
descr	char
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
address	long
[	O
1	int
]	O
!=	O
0xff	int
||	O
address	long
[	O
2	int
]	O
!=	O
0xff	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Initial byte of fat is not 0xff\n"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
fat_32_read	function
(	O
Fs_t	struct
*	O
This	pointer
,	O
union	O
bootsector	union
*	O
boot	struct
,	O
unsigned	O
int	O
tot_sectors	long
)	O
{	O
size_t	long
size	array
;	O
This	pointer
->	O
fat_len	int
=	O
DWORD	O
(	O
ext	array
.	O
fat32	struct
.	O
bigFat	array
)	O
;	O
This	pointer
->	O
writeAllFats	int
=	O
!	O
(	O
boot	struct
->	O
boot	struct
.	O
ext	array
.	O
fat32	struct
.	O
extFlags	array
[	O
0	int
]	O
&	O
0x80	int
)	O
;	O
This	pointer
->	O
primaryFat	int
=	O
boot	struct
->	O
boot	struct
.	O
ext	array
.	O
fat32	struct
.	O
extFlags	array
[	O
0	int
]	O
&	O
0xf	int
;	O
This	pointer
->	O
rootCluster	array
=	O
DWORD	O
(	O
ext	array
.	O
fat32	struct
.	O
rootCluster	array
)	O
;	O
This	pointer
->	O
clus_start	int
=	O
This	pointer
->	O
fat_start	int
+	O
This	pointer
->	O
num_fat	int
*	O
This	pointer
->	O
fat_len	int
;	O
size	array
=	O
This	pointer
->	O
sector_size	int
;	O
This	pointer
->	O
infoSectorLoc	int
=	O
WORD	O
(	O
ext	array
.	O
fat32	struct
.	O
infoSector	array
)	O
;	O
if	O
(	O
This	pointer
->	O
sector_size	int
>=	O
512	int
&&	O
This	pointer
->	O
infoSectorLoc	int
&&	O
This	pointer
->	O
infoSectorLoc	int
!=	O
MAX32	int
)	O
{	O
InfoSector_t	struct
*	O
infoSector	array
;	O
infoSector	array
=	O
(	O
InfoSector_t	struct
*	O
)	O
safe_malloc	function
(	O
size	array
)	O
;	O
if	O
(	O
forceReadSector	function
(	O
This	pointer
,	O
(	O
char	O
*	O
)	O
infoSector	array
,	O
This	pointer
->	O
infoSectorLoc	int
,	O
1	int
)	O
==	O
(	O
signed	O
int	O
)	O
This	pointer
->	O
sector_size	int
&&	O
_DWORD	O
(	O
infoSector	array
->	O
signature1	array
)	O
==	O
INFOSECT_SIGNATURE1	int
&&	O
_DWORD	O
(	O
infoSector	array
->	O
signature2	array
)	O
==	O
INFOSECT_SIGNATURE2	int
)	O
{	O
This	pointer
->	O
freeSpace	int
=	O
_DWORD	O
(	O
infoSector	array
->	O
count	array
)	O
;	O
This	pointer
->	O
last	int
=	O
_DWORD	O
(	O
infoSector	array
->	O
pos	array
)	O
;	O
}	O
free	function
(	O
infoSector	array
)	O
;	O
}	O
set_fat32	function
(	O
This	pointer
)	O
;	O
return	O
(	O
check_media_type	function
(	O
This	pointer
,	O
boot	struct
,	O
tot_sectors	long
)	O
||	O
check_fat	function
(	O
This	pointer
)	O
)	O
;	O
}	O
static	O
int	O
old_fat_read	function
(	O
Fs_t	struct
*	O
This	pointer
,	O
union	O
bootsector	union
*	O
boot	struct
,	O
size_t	long
tot_sectors	long
,	O
int	O
nodups	int
)	O
{	O
This	pointer
->	O
writeAllFats	int
=	O
1	int
;	O
This	pointer
->	O
primaryFat	int
=	O
0	int
;	O
This	pointer
->	O
dir_start	int
=	O
This	pointer
->	O
fat_start	int
+	O
This	pointer
->	O
num_fat	int
*	O
This	pointer
->	O
fat_len	int
;	O
This	pointer
->	O
clus_start	int
=	O
This	pointer
->	O
dir_start	int
+	O
This	pointer
->	O
dir_len	int
;	O
This	pointer
->	O
infoSectorLoc	int
=	O
MAX32	int
;	O
if	O
(	O
nodups	int
)	O
This	pointer
->	O
num_fat	int
=	O
1	int
;	O
if	O
(	O
check_media_type	function
(	O
This	pointer
,	O
boot	struct
,	O
tot_sectors	long
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
This	pointer
->	O
num_clus	int
>=	O
FAT12	int
)	O
{	O
set_fat16	function
(	O
This	pointer
)	O
;	O
if	O
(	O
!	O
mtools_skip_check	int
&&	O
readByte	function
(	O
This	pointer
,	O
3	int
)	O
!=	O
0xff	int
)	O
return	O
-	O
1	int
;	O
}	O
else	O
set_fat12	function
(	O
This	pointer
)	O
;	O
return	O
check_fat	function
(	O
This	pointer
)	O
;	O
}	O
int	O
fat_read	function
(	O
Fs_t	struct
*	O
This	pointer
,	O
union	O
bootsector	union
*	O
boot	struct
,	O
size_t	long
tot_sectors	long
,	O
int	O
nodups	int
)	O
{	O
This	pointer
->	O
fat_error	function
=	O
0	int
;	O
This	pointer
->	O
fat_dirty	int
=	O
0	int
;	O
This	pointer
->	O
last	int
=	O
MAX32	int
;	O
This	pointer
->	O
freeSpace	int
=	O
MAX32	int
;	O
This	pointer
->	O
lastFatSectorNr	int
=	O
0	int
;	O
This	pointer
->	O
lastFatSectorData	pointer
=	O
0	int
;	O
if	O
(	O
This	pointer
->	O
fat_len	int
)	O
return	O
old_fat_read	function
(	O
This	pointer
,	O
boot	struct
,	O
tot_sectors	long
,	O
nodups	int
)	O
;	O
else	O
return	O
fat_32_read	function
(	O
This	pointer
,	O
boot	struct
,	O
tot_sectors	long
)	O
;	O
}	O
unsigned	O
int	O
fatDecode	function
(	O
Fs_t	struct
*	O
This	pointer
,	O
unsigned	O
int	O
pos	array
)	O
{	O
unsigned	O
int	O
ret	int
;	O
ret	int
=	O
This	pointer
->	O
fat_decode	pointer
(	O
This	pointer
,	O
pos	array
)	O
;	O
if	O
(	O
ret	int
&&	O
(	O
ret	int
<	O
2	int
||	O
ret	int
>	O
This	pointer
->	O
num_clus	int
+	O
1	int
)	O
&&	O
ret	int
<	O
This	pointer
->	O
last_fat	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Bad FAT entry %d at %d\n"	pointer
,	O
ret	int
,	O
pos	array
)	O
;	O
This	pointer
->	O
fat_error	function
++	O
;	O
}	O
return	O
ret	int
;	O
}	O
void	O
fatAppend	function
(	O
Fs_t	struct
*	O
This	pointer
,	O
unsigned	O
int	O
pos	array
,	O
unsigned	O
int	O
newpos	int
)	O
{	O
This	pointer
->	O
fat_encode	pointer
(	O
This	pointer
,	O
pos	array
,	O
newpos	int
)	O
;	O
This	pointer
->	O
fat_encode	pointer
(	O
This	pointer
,	O
newpos	int
,	O
This	pointer
->	O
end_fat	int
)	O
;	O
if	O
(	O
This	pointer
->	O
freeSpace	int
!=	O
MAX32	int
)	O
This	pointer
->	O
freeSpace	int
--	O
;	O
}	O
void	O
fatDeallocate	function
(	O
Fs_t	struct
*	O
This	pointer
,	O
unsigned	O
int	O
pos	array
)	O
{	O
This	pointer
->	O
fat_encode	pointer
(	O
This	pointer
,	O
pos	array
,	O
0	int
)	O
;	O
if	O
(	O
This	pointer
->	O
freeSpace	int
!=	O
MAX32	int
)	O
This	pointer
->	O
freeSpace	int
++	O
;	O
}	O
void	O
fatAllocate	function
(	O
Fs_t	struct
*	O
This	pointer
,	O
unsigned	O
int	O
pos	array
,	O
unsigned	O
int	O
value	int
)	O
{	O
This	pointer
->	O
fat_encode	pointer
(	O
This	pointer
,	O
pos	array
,	O
value	int
)	O
;	O
if	O
(	O
This	pointer
->	O
freeSpace	int
!=	O
MAX32	int
)	O
This	pointer
->	O
freeSpace	int
--	O
;	O
}	O
void	O
fatEncode	function
(	O
Fs_t	struct
*	O
This	pointer
,	O
unsigned	O
int	O
pos	array
,	O
unsigned	O
int	O
value	int
)	O
{	O
unsigned	O
int	O
oldvalue	int
=	O
This	pointer
->	O
fat_decode	pointer
(	O
This	pointer
,	O
pos	array
)	O
;	O
This	pointer
->	O
fat_encode	pointer
(	O
This	pointer
,	O
pos	array
,	O
value	int
)	O
;	O
if	O
(	O
This	pointer
->	O
freeSpace	int
!=	O
MAX32	int
)	O
{	O
if	O
(	O
oldvalue	int
)	O
This	pointer
->	O
freeSpace	int
++	O
;	O
if	O
(	O
value	int
)	O
This	pointer
->	O
freeSpace	int
--	O
;	O
}	O
}	O
unsigned	O
int	O
get_next_free_cluster	function
(	O
Fs_t	struct
*	O
This	pointer
,	O
unsigned	O
int	O
last	int
)	O
{	O
unsigned	O
int	O
i	long
;	O
if	O
(	O
This	pointer
->	O
last	int
!=	O
MAX32	int
)	O
last	int
=	O
This	pointer
->	O
last	int
;	O
if	O
(	O
last	int
<	O
2	int
||	O
last	int
>=	O
This	pointer
->	O
num_clus	int
+	O
1	int
)	O
last	int
=	O
1	int
;	O
for	O
(	O
i	long
=	O
last	int
+	O
1	int
;	O
i	long
<	O
This	pointer
->	O
num_clus	int
+	O
2	int
;	O
i	long
++	O
)	O
{	O
unsigned	O
int	O
r	int
=	O
fatDecode	function
(	O
This	pointer
,	O
i	long
)	O
;	O
if	O
(	O
r	int
==	O
1	int
)	O
goto	O
exit_0	O
;	O
if	O
(	O
!	O
r	int
)	O
{	O
This	pointer
->	O
last	int
=	O
i	long
;	O
return	O
i	long
;	O
}	O
}	O
for	O
(	O
i	long
=	O
2	int
;	O
i	long
<	O
last	int
+	O
1	int
;	O
i	long
++	O
)	O
{	O
unsigned	O
int	O
r	int
=	O
fatDecode	function
(	O
This	pointer
,	O
i	long
)	O
;	O
if	O
(	O
r	int
==	O
1	int
)	O
goto	O
exit_0	O
;	O
if	O
(	O
!	O
r	int
)	O
{	O
This	pointer
->	O
last	int
=	O
i	long
;	O
return	O
i	long
;	O
}	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"No free cluster %d %d\n"	pointer
,	O
This	pointer
->	O
preallocatedClusters	int
,	O
This	pointer
->	O
last	int
)	O
;	O
return	O
1	int
;	O
exit_0	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
"FAT error\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
int	O
fat_error	function
(	O
Stream_t	struct
*	O
Dir	pointer
)	O
{	O
Stream_t	struct
*	O
Stream	pointer
=	O
GetFs	function
(	O
Dir	pointer
)	O
;	O
DeclareThis	O
(	O
Fs_t	struct
)	O
;	O
if	O
(	O
This	pointer
->	O
fat_error	function
)	O
fprintf	function
(	O
stderr	pointer
,	O
"Fat error detected\n"	pointer
)	O
;	O
return	O
This	pointer
->	O
fat_error	function
;	O
}	O
int	O
fat32RootCluster	function
(	O
Stream_t	struct
*	O
Dir	pointer
)	O
{	O
Stream_t	struct
*	O
Stream	pointer
=	O
GetFs	function
(	O
Dir	pointer
)	O
;	O
DeclareThis	O
(	O
Fs_t	struct
)	O
;	O
if	O
(	O
This	pointer
->	O
fat_bits	int
==	O
32	int
)	O
return	O
This	pointer
->	O
rootCluster	array
;	O
else	O
return	O
0	int
;	O
}	O
mt_size_t	long
getfree	function
(	O
Stream_t	struct
*	O
Dir	pointer
)	O
{	O
Stream_t	struct
*	O
Stream	pointer
=	O
GetFs	function
(	O
Dir	pointer
)	O
;	O
DeclareThis	O
(	O
Fs_t	struct
)	O
;	O
if	O
(	O
This	pointer
->	O
freeSpace	int
==	O
MAX32	int
||	O
This	pointer
->	O
freeSpace	int
==	O
0	int
)	O
{	O
register	O
unsigned	O
int	O
i	long
;	O
size_t	long
total	long
;	O
total	long
=	O
0L	int
;	O
for	O
(	O
i	long
=	O
2	int
;	O
i	long
<	O
This	pointer
->	O
num_clus	int
+	O
2	int
;	O
i	long
++	O
)	O
{	O
unsigned	O
int	O
r	int
=	O
fatDecode	function
(	O
This	pointer
,	O
i	long
)	O
;	O
if	O
(	O
r	int
==	O
1	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
!	O
r	int
)	O
total	long
++	O
;	O
}	O
This	pointer
->	O
freeSpace	int
=	O
total	long
;	O
}	O
return	O
sectorsToBytes	function
(	O
(	O
Stream_t	struct
*	O
)	O
This	pointer
,	O
This	pointer
->	O
freeSpace	int
*	O
This	pointer
->	O
cluster_size	int
)	O
;	O
}	O
int	O
getfreeMinClusters	function
(	O
Stream_t	struct
*	O
Dir	pointer
,	O
size_t	long
size	array
)	O
{	O
Stream_t	struct
*	O
Stream	pointer
=	O
GetFs	function
(	O
Dir	pointer
)	O
;	O
DeclareThis	O
(	O
Fs_t	struct
)	O
;	O
register	O
unsigned	O
int	O
i	long
,	O
last	int
;	O
size_t	long
total	long
;	O
if	O
(	O
batchmode	int
&&	O
This	pointer
->	O
freeSpace	int
==	O
MAX32	int
)	O
getfree	function
(	O
Stream	pointer
)	O
;	O
if	O
(	O
This	pointer
->	O
freeSpace	int
!=	O
MAX32	int
)	O
{	O
if	O
(	O
This	pointer
->	O
freeSpace	int
>=	O
size	array
)	O
return	O
1	int
;	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Disk full\n"	pointer
)	O
;	O
got_signal	int
=	O
1	int
;	O
return	O
0	int
;	O
}	O
}	O
total	long
=	O
0L	int
;	O
last	int
=	O
This	pointer
->	O
last	int
;	O
if	O
(	O
last	int
<	O
2	int
||	O
last	int
>=	O
This	pointer
->	O
num_clus	int
+	O
2	int
)	O
last	int
=	O
1	int
;	O
for	O
(	O
i	long
=	O
last	int
+	O
1	int
;	O
i	long
<	O
This	pointer
->	O
num_clus	int
+	O
2	int
;	O
i	long
++	O
)	O
{	O
unsigned	O
int	O
r	int
=	O
fatDecode	function
(	O
This	pointer
,	O
i	long
)	O
;	O
if	O
(	O
r	int
==	O
1	int
)	O
{	O
goto	O
exit_0	O
;	O
}	O
if	O
(	O
!	O
r	int
)	O
total	long
++	O
;	O
if	O
(	O
total	long
>=	O
size	array
)	O
return	O
1	int
;	O
}	O
for	O
(	O
i	long
=	O
2	int
;	O
i	long
<	O
last	int
+	O
1	int
;	O
i	long
++	O
)	O
{	O
unsigned	O
int	O
r	int
=	O
fatDecode	function
(	O
This	pointer
,	O
i	long
)	O
;	O
if	O
(	O
r	int
==	O
1	int
)	O
{	O
goto	O
exit_0	O
;	O
}	O
if	O
(	O
!	O
r	int
)	O
total	long
++	O
;	O
if	O
(	O
total	long
>=	O
size	array
)	O
return	O
1	int
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"Disk full\n"	pointer
)	O
;	O
got_signal	int
=	O
1	int
;	O
return	O
0	int
;	O
exit_0	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
"FAT error\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
getfreeMinBytes	function
(	O
Stream_t	struct
*	O
Dir	pointer
,	O
mt_size_t	long
size	array
)	O
{	O
Stream_t	struct
*	O
Stream	pointer
=	O
GetFs	function
(	O
Dir	pointer
)	O
;	O
DeclareThis	O
(	O
Fs_t	struct
)	O
;	O
size_t	long
size2	long
;	O
size2	long
=	O
size	array
/	O
(	O
This	pointer
->	O
sector_size	int
*	O
This	pointer
->	O
cluster_size	int
)	O
;	O
if	O
(	O
size	array
%	O
(	O
This	pointer
->	O
sector_size	int
*	O
This	pointer
->	O
cluster_size	int
)	O
)	O
size2	long
++	O
;	O
return	O
getfreeMinClusters	function
(	O
Dir	pointer
,	O
size2	long
)	O
;	O
}	O
unsigned	O
int	O
getStart	function
(	O
Stream_t	struct
*	O
Dir	pointer
,	O
struct	O
directory	struct
*	O
dir	pointer
)	O
{	O
Stream_t	struct
*	O
Stream	pointer
=	O
GetFs	function
(	O
Dir	pointer
)	O
;	O
unsigned	O
int	O
first	int
;	O
first	int
=	O
START	O
(	O
dir	pointer
)	O
;	O
if	O
(	O
fat32RootCluster	function
(	O
Stream	pointer
)	O
)	O
first	int
|=	O
STARTHI	O
(	O
dir	pointer
)	O
<<	O
16	int
;	O
return	O
first	int
;	O
}	O
int	O
fs_free	function
(	O
Stream_t	struct
*	O
Stream	pointer
)	O
{	O
DeclareThis	O
(	O
Fs_t	struct
)	O
;	O
if	O
(	O
This	pointer
->	O
FatMap	pointer
)	O
{	O
int	O
i	long
,	O
nr_entries	long
;	O
nr_entries	long
=	O
(	O
This	pointer
->	O
fat_len	int
+	O
SECT_PER_ENTRY	O
-	O
1	int
)	O
/	O
SECT_PER_ENTRY	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nr_entries	long
;	O
i	long
++	O
)	O
if	O
(	O
This	pointer
->	O
FatMap	pointer
[	O
i	long
]	O
.	O
data	pointer
)	O
free	function
(	O
This	pointer
->	O
FatMap	pointer
[	O
i	long
]	O
.	O
data	pointer
)	O
;	O
free	function
(	O
This	pointer
->	O
FatMap	pointer
)	O
;	O
}	O
if	O
(	O
This	pointer
->	O
cp	pointer
)	O
cp_close	function
(	O
This	pointer
->	O
cp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
