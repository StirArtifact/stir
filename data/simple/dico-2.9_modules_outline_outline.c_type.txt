static	O
size_t	long
compare_count	long
;	O
struct	O
entry	struct
{	O
char	O
*	O
word	pointer
;	O
size_t	long
length	long
;	O
size_t	long
wordlen	long
;	O
off_t	long
offset	long
;	O
size_t	long
size	long
;	O
struct	O
entry	struct
*	O
peer	pointer
;	O
}	O
;	O
struct	O
outline_file	struct
{	O
char	O
*	O
name	pointer
;	O
FILE	struct
*	O
fp	pointer
;	O
size_t	long
count	long
;	O
struct	O
entry	struct
*	O
index	pointer
;	O
struct	O
entry	struct
*	O
suf_index	pointer
;	O
struct	O
entry	struct
*	O
info_entry	pointer
,	O
*	O
descr_entry	pointer
,	O
*	O
lang_entry	pointer
,	O
*	O
mime_entry	pointer
;	O
}	O
;	O
static	O
size_t	long
trimnl	function
(	O
char	O
*	O
buf	pointer
)	O
{	O
size_t	long
len	int
=	O
strlen	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
len	int
>	O
0	int
&&	O
buf	pointer
[	O
len	int
-	O
1	int
]	O
==	O
'\n'	O
)	O
buf	pointer
[	O
--	O
len	int
]	O
=	O
0	int
;	O
return	O
len	int
;	O
}	O
static	O
size_t	long
trimws	function
(	O
char	O
*	O
buf	pointer
)	O
{	O
size_t	long
len	int
=	O
strlen	function
(	O
buf	pointer
)	O
;	O
while	O
(	O
len	int
>	O
0	int
&&	O
isspace	function
(	O
buf	pointer
[	O
len	int
-	O
1	int
]	O
)	O
)	O
buf	pointer
[	O
--	O
len	int
]	O
=	O
0	int
;	O
return	O
len	int
;	O
}	O
static	O
int	O
find_header	function
(	O
struct	O
outline_file	struct
*	O
file	pointer
,	O
char	O
*	O
buf	pointer
,	O
size_t	long
size	long
,	O
size_t	long
*	O
pread	pointer
)	O
{	O
while	O
(	O
fgets	function
(	O
buf	pointer
,	O
size	long
,	O
file	pointer
->	O
fp	pointer
)	O
)	O
{	O
size_t	long
rdbytes	long
=	O
strlen	function
(	O
buf	pointer
)	O
;	O
size_t	long
len	int
=	O
trimnl	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
len	int
>	O
0	int
)	O
{	O
int	O
level	int
;	O
for	O
(	O
level	int
=	O
0	int
;	O
buf	pointer
[	O
level	int
]	O
==	O
'*'	O
&&	O
level	int
<	O
len	int
;	O
level	int
++	O
)	O
;	O
if	O
(	O
level	int
)	O
{	O
*	O
pread	pointer
=	O
rdbytes	long
;	O
return	O
level	int
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
off_t	long
skipws	function
(	O
struct	O
outline_file	struct
*	O
file	pointer
,	O
char	O
*	O
buf	pointer
,	O
size_t	long
size	long
)	O
{	O
while	O
(	O
fgets	function
(	O
buf	pointer
,	O
size	long
,	O
file	pointer
->	O
fp	pointer
)	O
)	O
{	O
size_t	long
len	int
=	O
strlen	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
!	O
(	O
len	int
==	O
1	int
&&	O
buf	pointer
[	O
0	int
]	O
==	O
'\n'	O
)	O
)	O
{	O
fseek	function
(	O
file	pointer
->	O
fp	pointer
,	O
-	O
(	O
off_t	long
)	O
len	int
,	O
SEEK_CUR	int
)	O
;	O
break	O
;	O
}	O
}	O
return	O
ftell	function
(	O
file	pointer
->	O
fp	pointer
)	O
;	O
}	O
static	O
struct	O
entry	struct
*	O
alloc_entry	function
(	O
const	O
char	O
*	O
text	pointer
,	O
size_t	long
len	int
)	O
{	O
struct	O
entry	struct
*	O
ep	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
*	O
ep	pointer
)	O
)	O
;	O
if	O
(	O
ep	pointer
)	O
{	O
memset	function
(	O
ep	pointer
,	O
0	int
,	O
sizeof	O
(	O
*	O
ep	pointer
)	O
)	O
;	O
ep	pointer
->	O
word	pointer
=	O
malloc	function
(	O
len	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
ep	pointer
->	O
word	pointer
)	O
{	O
free	function
(	O
ep	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
memcpy	function
(	O
ep	pointer
->	O
word	pointer
,	O
text	pointer
,	O
len	int
)	O
;	O
ep	pointer
->	O
word	pointer
[	O
len	int
]	O
=	O
0	int
;	O
ep	pointer
->	O
length	long
=	O
len	int
;	O
ep	pointer
->	O
wordlen	long
=	O
utf8_strlen	function
(	O
ep	pointer
->	O
word	pointer
)	O
;	O
}	O
return	O
ep	pointer
;	O
}	O
static	O
struct	O
entry	struct
*	O
read_entry	function
(	O
struct	O
outline_file	struct
*	O
file	pointer
,	O
int	O
*	O
plevel	pointer
)	O
{	O
char	O
buf	pointer
[	O
128	int
]	O
,	O
*	O
p	pointer
;	O
struct	O
entry	struct
*	O
ep	pointer
;	O
int	O
level	int
;	O
size_t	long
rdbytes	long
,	O
len	int
;	O
level	int
=	O
find_header	function
(	O
file	pointer
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
&	O
rdbytes	long
)	O
;	O
if	O
(	O
level	int
==	O
0	int
)	O
return	O
NULL	O
;	O
*	O
plevel	pointer
=	O
level	int
;	O
for	O
(	O
p	pointer
=	O
buf	pointer
+	O
level	int
;	O
*	O
p	pointer
&&	O
isspace	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
)	O
;	O
len	int
=	O
trimws	function
(	O
p	pointer
)	O
;	O
ep	pointer
=	O
alloc_entry	function
(	O
p	pointer
,	O
len	int
)	O
;	O
if	O
(	O
!	O
ep	pointer
)	O
return	O
NULL	O
;	O
ep	pointer
->	O
offset	long
=	O
skipws	function
(	O
file	pointer
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
;	O
find_header	function
(	O
file	pointer
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
&	O
rdbytes	long
)	O
;	O
fseek	function
(	O
file	pointer
->	O
fp	pointer
,	O
-	O
(	O
off_t	long
)	O
rdbytes	long
,	O
SEEK_CUR	int
)	O
;	O
ep	pointer
->	O
size	long
=	O
ftell	function
(	O
file	pointer
->	O
fp	pointer
)	O
-	O
ep	pointer
->	O
offset	long
;	O
return	O
ep	pointer
;	O
}	O
enum	O
result_type	enum
{	O
result_match	int
,	O
result_match_list	int
,	O
result_define	int
}	O
;	O
struct	O
result	pointer
{	O
struct	O
outline_file	struct
*	O
file	pointer
;	O
enum	O
result_type	enum
type	enum
;	O
size_t	long
count	long
;	O
size_t	long
compare_count	long
;	O
union	O
{	O
const	O
struct	O
entry	struct
*	O
ep	pointer
;	O
dico_list_t	pointer
list	array
;	O
}	O
v	union
;	O
}	O
;	O
typedef	O
int	O
(	O
*	O
entry_match_t	pointer
)	O
(	O
struct	O
outline_file	struct
*	O
file	pointer
,	O
const	O
char	O
*	O
word	pointer
,	O
struct	O
result	pointer
*	O
res	pointer
)	O
;	O
struct	O
strategy_def	struct
{	O
struct	O
dico_strategy	struct
strat	pointer
;	O
entry_match_t	pointer
match	pointer
;	O
}	O
;	O
static	O
int	O
exact_match	function
(	O
struct	O
outline_file	struct
*	O
,	O
const	O
char	O
*	O
,	O
struct	O
result	pointer
*	O
)	O
;	O
static	O
int	O
prefix_match	function
(	O
struct	O
outline_file	struct
*	O
,	O
const	O
char	O
*	O
,	O
struct	O
result	pointer
*	O
)	O
;	O
static	O
int	O
suffix_match	function
(	O
struct	O
outline_file	struct
*	O
file	pointer
,	O
const	O
char	O
*	O
word	pointer
,	O
struct	O
result	pointer
*	O
res	pointer
)	O
;	O
static	O
struct	O
strategy_def	struct
strat_tab	array
[	O
]	O
=	O
{	O
{	O
{	O
"exact"	pointer
,	O
"Match words exactly"	pointer
}	O
,	O
exact_match	function
}	O
,	O
{	O
{	O
"prefix"	pointer
,	O
"Match word prefixes"	pointer
}	O
,	O
prefix_match	function
}	O
,	O
{	O
{	O
"suffix"	pointer
,	O
"Match word suffixes"	pointer
}	O
,	O
suffix_match	function
}	O
}	O
;	O
static	O
entry_match_t	pointer
find_matcher	function
(	O
const	O
char	O
*	O
strat	pointer
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
DICO_ARRAY_SIZE	O
(	O
strat_tab	array
)	O
;	O
i	int
++	O
)	O
if	O
(	O
strcmp	function
(	O
strat	pointer
,	O
strat_tab	array
[	O
i	int
]	O
.	O
strat	pointer
.	O
name	pointer
)	O
==	O
0	int
)	O
return	O
strat_tab	array
[	O
i	int
]	O
.	O
match	pointer
;	O
return	O
NULL	O
;	O
}	O
static	O
int	O
outline_init	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
DICO_ARRAY_SIZE	O
(	O
strat_tab	array
)	O
;	O
i	int
++	O
)	O
dico_strategy_add	function
(	O
&	O
strat_tab	array
[	O
i	int
]	O
.	O
strat	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
compare_entry	function
(	O
const	O
void	O
*	O
a	pointer
,	O
const	O
void	O
*	O
b	pointer
)	O
{	O
const	O
struct	O
entry	struct
*	O
epa	pointer
=	O
a	pointer
;	O
const	O
struct	O
entry	struct
*	O
epb	pointer
=	O
b	pointer
;	O
compare_count	long
++	O
;	O
return	O
utf8_strcasecmp	function
(	O
epa	pointer
->	O
word	pointer
,	O
epb	pointer
->	O
word	pointer
)	O
;	O
}	O
static	O
void	O
revert_word	function
(	O
char	O
*	O
dst	pointer
,	O
const	O
char	O
*	O
src	pointer
,	O
size_t	long
len	int
)	O
{	O
struct	O
utf8_iterator	struct
itr	pointer
;	O
char	O
*	O
p	pointer
=	O
dst	pointer
+	O
len	int
;	O
*	O
p	pointer
=	O
0	int
;	O
for	O
(	O
utf8_iter_init	function
(	O
&	O
itr	pointer
,	O
(	O
char	O
*	O
)	O
src	pointer
,	O
len	int
)	O
;	O
!	O
utf8_iter_end_p	function
(	O
&	O
itr	pointer
)	O
;	O
utf8_iter_next	function
(	O
&	O
itr	pointer
)	O
)	O
{	O
p	pointer
-=	O
itr	pointer
.	O
curwidth	int
;	O
if	O
(	O
p	pointer
<	O
dst	pointer
)	O
break	O
;	O
memcpy	function
(	O
p	pointer
,	O
itr	pointer
.	O
curptr	pointer
,	O
itr	pointer
.	O
curwidth	int
)	O
;	O
}	O
}	O
static	O
int	O
init_suffix_index	function
(	O
struct	O
outline_file	struct
*	O
file	pointer
)	O
{	O
if	O
(	O
!	O
file	pointer
->	O
suf_index	pointer
)	O
{	O
size_t	long
i	int
;	O
file	pointer
->	O
suf_index	pointer
=	O
calloc	function
(	O
file	pointer
->	O
count	long
,	O
sizeof	O
(	O
file	pointer
->	O
suf_index	pointer
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
file	pointer
->	O
suf_index	pointer
)	O
return	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
file	pointer
->	O
count	long
;	O
i	int
++	O
)	O
{	O
char	O
*	O
p	pointer
=	O
malloc	function
(	O
file	pointer
->	O
index	pointer
[	O
i	int
]	O
.	O
length	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
while	O
(	O
i	int
>	O
0	int
)	O
free	function
(	O
file	pointer
->	O
suf_index	pointer
[	O
--	O
i	int
]	O
.	O
word	pointer
)	O
;	O
free	function
(	O
file	pointer
->	O
suf_index	pointer
)	O
;	O
return	O
1	int
;	O
}	O
revert_word	function
(	O
p	pointer
,	O
file	pointer
->	O
index	pointer
[	O
i	int
]	O
.	O
word	pointer
,	O
file	pointer
->	O
index	pointer
[	O
i	int
]	O
.	O
length	long
)	O
;	O
file	pointer
->	O
suf_index	pointer
[	O
i	int
]	O
=	O
file	pointer
->	O
index	pointer
[	O
i	int
]	O
;	O
file	pointer
->	O
suf_index	pointer
[	O
i	int
]	O
.	O
word	pointer
=	O
p	pointer
;	O
file	pointer
->	O
suf_index	pointer
[	O
i	int
]	O
.	O
peer	pointer
=	O
&	O
file	pointer
->	O
index	pointer
[	O
i	int
]	O
;	O
}	O
}	O
qsort	function
(	O
file	pointer
->	O
suf_index	pointer
,	O
file	pointer
->	O
count	long
,	O
sizeof	O
(	O
file	pointer
->	O
suf_index	pointer
[	O
0	int
]	O
)	O
,	O
compare_entry	function
)	O
;	O
compare_count	long
=	O
0	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
exact_match	function
(	O
struct	O
outline_file	struct
*	O
file	pointer
,	O
const	O
char	O
*	O
word	pointer
,	O
struct	O
result	pointer
*	O
res	pointer
)	O
{	O
struct	O
entry	struct
x	struct
,	O
*	O
ep	pointer
;	O
x	struct
.	O
word	pointer
=	O
(	O
char	O
*	O
)	O
word	pointer
;	O
x	struct
.	O
length	long
=	O
strlen	function
(	O
word	pointer
)	O
;	O
x	struct
.	O
wordlen	long
=	O
utf8_strlen	function
(	O
word	pointer
)	O
;	O
ep	pointer
=	O
bsearch	function
(	O
&	O
x	struct
,	O
file	pointer
->	O
index	pointer
,	O
file	pointer
->	O
count	long
,	O
sizeof	O
(	O
file	pointer
->	O
index	pointer
[	O
0	int
]	O
)	O
,	O
compare_entry	function
)	O
;	O
if	O
(	O
ep	pointer
)	O
{	O
res	pointer
->	O
type	enum
=	O
result_match	int
;	O
res	pointer
->	O
v	union
.	O
ep	pointer
=	O
ep	pointer
;	O
res	pointer
->	O
count	long
=	O
1	int
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
compare_prefix	function
(	O
const	O
void	O
*	O
a	pointer
,	O
const	O
void	O
*	O
b	pointer
)	O
{	O
const	O
struct	O
entry	struct
*	O
pkey	pointer
=	O
a	pointer
;	O
const	O
struct	O
entry	struct
*	O
pelt	pointer
=	O
b	pointer
;	O
size_t	long
wordlen	long
=	O
pkey	pointer
->	O
wordlen	long
;	O
if	O
(	O
pelt	pointer
->	O
wordlen	long
<	O
wordlen	long
)	O
wordlen	long
=	O
pelt	pointer
->	O
wordlen	long
;	O
compare_count	long
++	O
;	O
return	O
utf8_strncasecmp	function
(	O
pkey	pointer
->	O
word	pointer
,	O
pelt	pointer
->	O
word	pointer
,	O
wordlen	long
)	O
;	O
}	O
static	O
int	O
prefix_match	function
(	O
struct	O
outline_file	struct
*	O
file	pointer
,	O
const	O
char	O
*	O
word	pointer
,	O
struct	O
result	pointer
*	O
res	pointer
)	O
{	O
struct	O
entry	struct
x	struct
,	O
*	O
ep	pointer
;	O
x	struct
.	O
word	pointer
=	O
(	O
char	O
*	O
)	O
word	pointer
;	O
x	struct
.	O
length	long
=	O
strlen	function
(	O
word	pointer
)	O
;	O
x	struct
.	O
wordlen	long
=	O
utf8_strlen	function
(	O
word	pointer
)	O
;	O
ep	pointer
=	O
bsearch	function
(	O
&	O
x	struct
,	O
file	pointer
->	O
index	pointer
,	O
file	pointer
->	O
count	long
,	O
sizeof	O
(	O
file	pointer
->	O
index	pointer
[	O
0	int
]	O
)	O
,	O
compare_prefix	function
)	O
;	O
if	O
(	O
ep	pointer
)	O
{	O
size_t	long
count	long
=	O
1	int
;	O
struct	O
entry	struct
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
ep	pointer
-	O
1	int
;	O
p	pointer
>	O
file	pointer
->	O
index	pointer
&&	O
compare_prefix	function
(	O
&	O
x	struct
,	O
p	pointer
)	O
==	O
0	int
;	O
p	pointer
--	O
)	O
count	long
++	O
;	O
for	O
(	O
ep	pointer
++	O
;	O
ep	pointer
<	O
file	pointer
->	O
index	pointer
+	O
file	pointer
->	O
count	long
&&	O
compare_prefix	function
(	O
&	O
x	struct
,	O
ep	pointer
)	O
==	O
0	int
;	O
ep	pointer
++	O
)	O
count	long
++	O
;	O
res	pointer
->	O
type	enum
=	O
result_match	int
;	O
res	pointer
->	O
v	union
.	O
ep	pointer
=	O
p	pointer
+	O
1	int
;	O
res	pointer
->	O
count	long
=	O
count	long
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
compare_entry_ptr	function
(	O
const	O
void	O
*	O
a	pointer
,	O
const	O
void	O
*	O
b	pointer
)	O
{	O
struct	O
entry	struct
*	O
const	O
*	O
epa	pointer
=	O
a	pointer
;	O
struct	O
entry	struct
*	O
const	O
*	O
epb	pointer
=	O
b	pointer
;	O
compare_count	long
++	O
;	O
return	O
utf8_strcasecmp	function
(	O
(	O
*	O
epa	pointer
)	O
->	O
word	pointer
,	O
(	O
*	O
epb	pointer
)	O
->	O
word	pointer
)	O
;	O
}	O
static	O
int	O
suffix_match	function
(	O
struct	O
outline_file	struct
*	O
file	pointer
,	O
const	O
char	O
*	O
word	pointer
,	O
struct	O
result	pointer
*	O
res	pointer
)	O
{	O
struct	O
entry	struct
x	struct
,	O
*	O
ep	pointer
;	O
int	O
rc	int
;	O
if	O
(	O
init_suffix_index	function
(	O
file	pointer
)	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
"not enough memory"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
x	struct
.	O
length	long
=	O
strlen	function
(	O
word	pointer
)	O
;	O
x	struct
.	O
word	pointer
=	O
malloc	function
(	O
x	struct
.	O
length	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
x	struct
.	O
word	pointer
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
"not enough memory"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
x	struct
.	O
wordlen	long
=	O
utf8_strlen	function
(	O
word	pointer
)	O
;	O
revert_word	function
(	O
x	struct
.	O
word	pointer
,	O
word	pointer
,	O
x	struct
.	O
length	long
)	O
;	O
ep	pointer
=	O
bsearch	function
(	O
&	O
x	struct
,	O
file	pointer
->	O
suf_index	pointer
,	O
file	pointer
->	O
count	long
,	O
sizeof	O
(	O
file	pointer
->	O
suf_index	pointer
[	O
0	int
]	O
)	O
,	O
compare_prefix	function
)	O
;	O
if	O
(	O
ep	pointer
)	O
{	O
struct	O
entry	struct
*	O
p	pointer
,	O
*	O
*	O
epp	pointer
;	O
size_t	long
count	long
=	O
1	int
;	O
for	O
(	O
p	pointer
=	O
ep	pointer
-	O
1	int
;	O
p	pointer
>	O
file	pointer
->	O
suf_index	pointer
&&	O
compare_prefix	function
(	O
&	O
x	struct
,	O
p	pointer
)	O
==	O
0	int
;	O
p	pointer
--	O
)	O
count	long
++	O
;	O
for	O
(	O
ep	pointer
++	O
;	O
ep	pointer
<	O
file	pointer
->	O
suf_index	pointer
+	O
file	pointer
->	O
count	long
&&	O
compare_prefix	function
(	O
&	O
x	struct
,	O
ep	pointer
)	O
==	O
0	int
;	O
ep	pointer
++	O
)	O
count	long
++	O
;	O
p	pointer
++	O
;	O
epp	pointer
=	O
calloc	function
(	O
count	long
,	O
sizeof	O
(	O
*	O
epp	pointer
)	O
)	O
;	O
if	O
(	O
!	O
epp	pointer
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
"not enough memory"	pointer
)	O
;	O
rc	int
=	O
1	int
;	O
}	O
else	O
{	O
res	pointer
->	O
type	enum
=	O
result_match_list	int
;	O
res	pointer
->	O
v	union
.	O
list	array
=	O
dico_list_create	function
(	O
)	O
;	O
if	O
(	O
!	O
res	pointer
->	O
v	union
.	O
list	array
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
"not enough memory"	pointer
)	O
;	O
rc	int
=	O
1	int
;	O
}	O
else	O
{	O
size_t	long
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
count	long
;	O
i	int
++	O
)	O
epp	pointer
[	O
i	int
]	O
=	O
p	pointer
[	O
i	int
]	O
.	O
peer	pointer
;	O
qsort	function
(	O
epp	pointer
,	O
count	long
,	O
sizeof	O
(	O
epp	pointer
[	O
0	int
]	O
)	O
,	O
compare_entry_ptr	function
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
count	long
;	O
i	int
++	O
)	O
dico_list_append	function
(	O
res	pointer
->	O
v	union
.	O
list	array
,	O
epp	pointer
[	O
i	int
]	O
)	O
;	O
res	pointer
->	O
count	long
=	O
dico_list_count	function
(	O
res	pointer
->	O
v	union
.	O
list	array
)	O
;	O
rc	int
=	O
0	int
;	O
}	O
free	function
(	O
epp	pointer
)	O
;	O
}	O
}	O
else	O
rc	int
=	O
1	int
;	O
free	function
(	O
x	struct
.	O
word	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
outline_free_db	function
(	O
dico_handle_t	pointer
hp	pointer
)	O
{	O
size_t	long
i	int
;	O
struct	O
outline_file	struct
*	O
file	pointer
=	O
(	O
struct	O
outline_file	struct
*	O
)	O
hp	pointer
;	O
fclose	function
(	O
file	pointer
->	O
fp	pointer
)	O
;	O
free	function
(	O
file	pointer
->	O
name	pointer
)	O
;	O
free	function
(	O
file	pointer
->	O
info_entry	pointer
)	O
;	O
free	function
(	O
file	pointer
->	O
descr_entry	pointer
)	O
;	O
free	function
(	O
file	pointer
->	O
lang_entry	pointer
)	O
;	O
free	function
(	O
file	pointer
->	O
mime_entry	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
file	pointer
->	O
count	long
;	O
i	int
++	O
)	O
{	O
free	function
(	O
file	pointer
->	O
index	pointer
[	O
i	int
]	O
.	O
word	pointer
)	O
;	O
if	O
(	O
file	pointer
->	O
suf_index	pointer
)	O
free	function
(	O
file	pointer
->	O
suf_index	pointer
[	O
i	int
]	O
.	O
word	pointer
)	O
;	O
}	O
free	function
(	O
file	pointer
->	O
index	pointer
)	O
;	O
free	function
(	O
file	pointer
->	O
suf_index	pointer
)	O
;	O
free	function
(	O
file	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
dico_handle_t	pointer
outline_init_db	function
(	O
const	O
char	O
*	O
dbname	pointer
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
FILE	struct
*	O
fp	pointer
;	O
struct	O
outline_file	struct
*	O
file	pointer
;	O
dico_list_t	pointer
list	array
;	O
struct	O
entry	struct
*	O
ep	pointer
;	O
int	O
level	int
;	O
int	O
state	pointer
;	O
size_t	long
i	int
,	O
count	long
;	O
dico_iterator_t	pointer
itr	pointer
;	O
if	O
(	O
argc	int
!=	O
2	int
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"outline_open: wrong number of arguments"	pointer
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
fp	pointer
=	O
fopen	function
(	O
argv	pointer
[	O
1	int
]	O
,	O
"r"	pointer
)	O
;	O
if	O
(	O
!	O
fp	pointer
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
errno	O
,	O
_	O
(	O
"cannot open file %s"	pointer
)	O
,	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
return	O
NULL	O
;	O
}	O
file	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
*	O
file	pointer
)	O
)	O
;	O
if	O
(	O
!	O
file	pointer
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
"not enough memory"	pointer
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
memset	function
(	O
file	pointer
,	O
0	int
,	O
sizeof	O
(	O
*	O
file	pointer
)	O
)	O
;	O
file	pointer
->	O
name	pointer
=	O
strdup	function
(	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
file	pointer
->	O
fp	pointer
=	O
fp	pointer
;	O
list	array
=	O
dico_list_create	function
(	O
)	O
;	O
if	O
(	O
!	O
list	array
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
"not enough memory"	pointer
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
free	function
(	O
file	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
state	pointer
=	O
STATE_INITIAL	int
;	O
while	O
(	O
(	O
ep	pointer
=	O
read_entry	function
(	O
file	pointer
,	O
&	O
level	int
)	O
)	O
)	O
{	O
switch	O
(	O
state	pointer
)	O
{	O
case	O
STATE_DICT	int
:	O
if	O
(	O
level	int
==	O
2	int
)	O
{	O
dico_list_append	function
(	O
list	array
,	O
ep	pointer
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
level	int
==	O
1	int
)	O
{	O
state	pointer
=	O
STATE_INITIAL	int
;	O
}	O
else	O
{	O
free	function
(	O
ep	pointer
)	O
;	O
break	O
;	O
}	O
case	O
STATE_INITIAL	int
:	O
if	O
(	O
level	int
==	O
1	int
)	O
{	O
if	O
(	O
strcasecmp	function
(	O
ep	pointer
->	O
word	pointer
,	O
"info"	pointer
)	O
==	O
0	int
)	O
{	O
file	pointer
->	O
info_entry	pointer
=	O
ep	pointer
;	O
break	O
;	O
}	O
else	O
if	O
(	O
strcasecmp	function
(	O
ep	pointer
->	O
word	pointer
,	O
"description"	pointer
)	O
==	O
0	int
)	O
{	O
file	pointer
->	O
descr_entry	pointer
=	O
ep	pointer
;	O
break	O
;	O
}	O
else	O
if	O
(	O
strcasecmp	function
(	O
ep	pointer
->	O
word	pointer
,	O
"languages"	pointer
)	O
==	O
0	int
)	O
{	O
file	pointer
->	O
lang_entry	pointer
=	O
ep	pointer
;	O
break	O
;	O
}	O
else	O
if	O
(	O
strcasecmp	function
(	O
ep	pointer
->	O
word	pointer
,	O
"mime"	pointer
)	O
==	O
0	int
)	O
{	O
file	pointer
->	O
mime_entry	pointer
=	O
ep	pointer
;	O
break	O
;	O
}	O
else	O
if	O
(	O
strcasecmp	function
(	O
ep	pointer
->	O
word	pointer
,	O
"dictionary"	pointer
)	O
==	O
0	int
)	O
state	pointer
=	O
STATE_DICT	int
;	O
}	O
free	function
(	O
ep	pointer
)	O
;	O
break	O
;	O
}	O
}	O
file	pointer
->	O
count	long
=	O
count	long
=	O
dico_list_count	function
(	O
list	array
)	O
;	O
file	pointer
->	O
index	pointer
=	O
calloc	function
(	O
count	long
,	O
sizeof	O
(	O
file	pointer
->	O
index	pointer
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
file	pointer
->	O
index	pointer
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
"not enough memory"	pointer
)	O
;	O
outline_free_db	function
(	O
(	O
dico_handle_t	pointer
)	O
file	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
itr	pointer
=	O
dico_list_iterator	function
(	O
list	array
)	O
;	O
for	O
(	O
i	int
=	O
0	int
,	O
ep	pointer
=	O
dico_iterator_first	function
(	O
itr	pointer
)	O
;	O
ep	pointer
;	O
i	int
++	O
,	O
ep	pointer
=	O
dico_iterator_next	function
(	O
itr	pointer
)	O
)	O
{	O
file	pointer
->	O
index	pointer
[	O
i	int
]	O
=	O
*	O
ep	pointer
;	O
free	function
(	O
ep	pointer
)	O
;	O
}	O
dico_iterator_destroy	function
(	O
&	O
itr	pointer
)	O
;	O
dico_list_destroy	function
(	O
&	O
list	array
)	O
;	O
qsort	function
(	O
file	pointer
->	O
index	pointer
,	O
count	long
,	O
sizeof	O
(	O
file	pointer
->	O
index	pointer
[	O
0	int
]	O
)	O
,	O
compare_entry	function
)	O
;	O
return	O
(	O
dico_handle_t	pointer
)	O
file	pointer
;	O
}	O
static	O
inline	O
int	O
isws	function
(	O
int	O
c	int
)	O
{	O
return	O
c	int
==	O
' '	O
||	O
c	int
==	O
'\t'	O
||	O
c	int
==	O
'\r'	O
||	O
c	int
==	O
'\f'	O
;	O
}	O
static	O
char	O
*	O
read_buf	function
(	O
struct	O
outline_file	struct
*	O
file	pointer
,	O
struct	O
entry	struct
*	O
ep	pointer
,	O
int	O
trim	int
)	O
{	O
size_t	long
size	long
;	O
char	O
*	O
buf	pointer
=	O
malloc	function
(	O
ep	pointer
->	O
size	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
buf	pointer
)	O
return	O
NULL	O
;	O
fseek	function
(	O
file	pointer
->	O
fp	pointer
,	O
ep	pointer
->	O
offset	long
,	O
SEEK_SET	int
)	O
;	O
size	long
=	O
fread	function
(	O
buf	pointer
,	O
1	int
,	O
ep	pointer
->	O
size	long
,	O
file	pointer
->	O
fp	pointer
)	O
;	O
if	O
(	O
trim	int
&&	O
size	long
>	O
0	int
&&	O
buf	pointer
[	O
size	long
-	O
1	int
]	O
==	O
'\n'	O
)	O
{	O
while	O
(	O
size	long
>	O
0	int
&&	O
buf	pointer
[	O
size	long
-	O
1	int
]	O
==	O
'\n'	O
)	O
{	O
--	O
size	long
;	O
while	O
(	O
size	long
>	O
0	int
&&	O
isws	function
(	O
buf	pointer
[	O
size	long
-	O
1	int
]	O
)	O
)	O
--	O
size	long
;	O
}	O
buf	pointer
[	O
size	long
++	O
]	O
=	O
'\n'	O
;	O
}	O
buf	pointer
[	O
size	long
]	O
=	O
0	int
;	O
return	O
buf	pointer
;	O
}	O
static	O
char	O
*	O
outline_info	function
(	O
dico_handle_t	pointer
hp	pointer
)	O
{	O
struct	O
outline_file	struct
*	O
file	pointer
=	O
(	O
struct	O
outline_file	struct
*	O
)	O
hp	pointer
;	O
if	O
(	O
file	pointer
->	O
info_entry	pointer
)	O
return	O
read_buf	function
(	O
file	pointer
,	O
file	pointer
->	O
info_entry	pointer
,	O
0	int
)	O
;	O
return	O
NULL	O
;	O
}	O
static	O
char	O
*	O
outline_descr	function
(	O
dico_handle_t	pointer
hp	pointer
)	O
{	O
struct	O
outline_file	struct
*	O
file	pointer
=	O
(	O
struct	O
outline_file	struct
*	O
)	O
hp	pointer
;	O
if	O
(	O
file	pointer
->	O
descr_entry	pointer
)	O
{	O
char	O
*	O
buf	pointer
=	O
read_buf	function
(	O
file	pointer
,	O
file	pointer
->	O
descr_entry	pointer
,	O
0	int
)	O
;	O
char	O
*	O
p	pointer
=	O
strchr	function
(	O
buf	pointer
,	O
'\n'	O
)	O
;	O
if	O
(	O
p	pointer
)	O
*	O
p	pointer
=	O
0	int
;	O
return	O
buf	pointer
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
int	O
outline_lang	function
(	O
dico_handle_t	pointer
hp	pointer
,	O
dico_list_t	pointer
list	array
[	O
2	int
]	O
)	O
{	O
struct	O
outline_file	struct
*	O
file	pointer
=	O
(	O
struct	O
outline_file	struct
*	O
)	O
hp	pointer
;	O
list	array
[	O
0	int
]	O
=	O
list	array
[	O
1	int
]	O
=	O
NULL	O
;	O
if	O
(	O
file	pointer
->	O
lang_entry	pointer
)	O
{	O
int	O
n	long
=	O
0	int
;	O
struct	O
wordsplit	struct
ws	pointer
;	O
char	O
*	O
buf	pointer
=	O
read_buf	function
(	O
file	pointer
,	O
file	pointer
->	O
lang_entry	pointer
,	O
0	int
)	O
;	O
ws	pointer
.	O
ws_delim	pointer
=	O
"\n"	pointer
;	O
if	O
(	O
wordsplit	struct
(	O
buf	pointer
,	O
&	O
ws	pointer
,	O
WRDSF_DEFFLAGS	O
|	O
WRDSF_DELIM	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
ws	pointer
.	O
ws_wordc	long
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ws	pointer
.	O
ws_wordc	long
;	O
i	int
++	O
)	O
{	O
if	O
(	O
n	long
==	O
0	int
&&	O
strcmp	function
(	O
ws	pointer
.	O
ws_wordv	pointer
[	O
i	int
]	O
,	O
":"	pointer
)	O
==	O
0	int
)	O
{	O
n	long
=	O
1	int
;	O
free	function
(	O
ws	pointer
.	O
ws_wordv	pointer
[	O
i	int
]	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
list	array
[	O
n	long
]	O
)	O
list	array
[	O
n	long
]	O
=	O
dico_list_create	function
(	O
)	O
;	O
dico_list_append	function
(	O
list	array
[	O
n	long
]	O
,	O
ws	pointer
.	O
ws_wordv	pointer
[	O
i	int
]	O
)	O
;	O
}	O
}	O
}	O
ws	pointer
.	O
ws_wordc	long
=	O
0	int
;	O
wordsplit_free	function
(	O
&	O
ws	pointer
)	O
;	O
}	O
else	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"outline_lang: not enough memory"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
dico_result_t	pointer
outline_match0	function
(	O
dico_handle_t	pointer
hp	pointer
,	O
entry_match_t	pointer
match	pointer
,	O
const	O
char	O
*	O
word	pointer
)	O
{	O
struct	O
outline_file	struct
*	O
file	pointer
=	O
(	O
struct	O
outline_file	struct
*	O
)	O
hp	pointer
;	O
struct	O
result	pointer
*	O
res	pointer
;	O
compare_count	long
=	O
0	int
;	O
res	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
*	O
res	pointer
)	O
)	O
;	O
if	O
(	O
!	O
res	pointer
)	O
return	O
NULL	O
;	O
res	pointer
->	O
file	pointer
=	O
file	pointer
;	O
if	O
(	O
match	pointer
(	O
file	pointer
,	O
word	pointer
,	O
res	pointer
)	O
)	O
{	O
free	function
(	O
res	pointer
)	O
;	O
res	pointer
=	O
NULL	O
;	O
}	O
else	O
res	pointer
->	O
compare_count	long
=	O
compare_count	long
;	O
return	O
(	O
dico_result_t	pointer
)	O
res	pointer
;	O
}	O
static	O
dico_result_t	pointer
outline_match_all	function
(	O
dico_handle_t	pointer
hp	pointer
,	O
dico_strategy_t	pointer
strat	pointer
,	O
const	O
char	O
*	O
word	pointer
)	O
{	O
struct	O
outline_file	struct
*	O
file	pointer
=	O
(	O
struct	O
outline_file	struct
*	O
)	O
hp	pointer
;	O
dico_list_t	pointer
list	array
;	O
size_t	long
count	long
,	O
i	int
;	O
struct	O
result	pointer
*	O
res	pointer
;	O
struct	O
dico_key	struct
key	pointer
;	O
list	array
=	O
dico_list_create	function
(	O
)	O
;	O
if	O
(	O
!	O
list	array
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"outline_match_all: not enough memory"	pointer
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
dico_key_init	function
(	O
&	O
key	pointer
,	O
strat	pointer
,	O
word	pointer
)	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"outline_match_all: key initialization failed"	pointer
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
file	pointer
->	O
count	long
;	O
i	int
++	O
)	O
{	O
if	O
(	O
dico_key_match	function
(	O
&	O
key	pointer
,	O
file	pointer
->	O
index	pointer
[	O
i	int
]	O
.	O
word	pointer
)	O
)	O
dico_list_append	function
(	O
list	array
,	O
&	O
file	pointer
->	O
index	pointer
[	O
i	int
]	O
)	O
;	O
}	O
dico_key_deinit	function
(	O
&	O
key	pointer
)	O
;	O
compare_count	long
=	O
file	pointer
->	O
count	long
;	O
count	long
=	O
dico_list_count	function
(	O
list	array
)	O
;	O
if	O
(	O
count	long
==	O
0	int
)	O
{	O
dico_list_destroy	function
(	O
&	O
list	array
)	O
;	O
return	O
NULL	O
;	O
}	O
res	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
*	O
res	pointer
)	O
)	O
;	O
if	O
(	O
!	O
res	pointer
)	O
return	O
NULL	O
;	O
res	pointer
->	O
file	pointer
=	O
file	pointer
;	O
res	pointer
->	O
type	enum
=	O
result_match_list	int
;	O
res	pointer
->	O
count	long
=	O
count	long
;	O
res	pointer
->	O
v	union
.	O
list	array
=	O
list	array
;	O
res	pointer
->	O
compare_count	long
=	O
compare_count	long
;	O
return	O
(	O
dico_result_t	pointer
)	O
res	pointer
;	O
}	O
static	O
dico_result_t	pointer
outline_match	function
(	O
dico_handle_t	pointer
hp	pointer
,	O
const	O
dico_strategy_t	pointer
strat	pointer
,	O
const	O
char	O
*	O
word	pointer
)	O
{	O
entry_match_t	pointer
match	pointer
=	O
find_matcher	function
(	O
strat	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
match	pointer
)	O
return	O
outline_match0	function
(	O
hp	pointer
,	O
match	pointer
,	O
word	pointer
)	O
;	O
else	O
if	O
(	O
strat	pointer
->	O
sel	pointer
)	O
return	O
outline_match_all	function
(	O
hp	pointer
,	O
strat	pointer
,	O
word	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
static	O
dico_result_t	pointer
outline_define	function
(	O
dico_handle_t	pointer
hp	pointer
,	O
const	O
char	O
*	O
word	pointer
)	O
{	O
struct	O
outline_file	struct
*	O
file	pointer
=	O
(	O
struct	O
outline_file	struct
*	O
)	O
hp	pointer
;	O
struct	O
result	pointer
*	O
res	pointer
;	O
compare_count	long
=	O
0	int
;	O
res	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
*	O
res	pointer
)	O
)	O
;	O
if	O
(	O
!	O
res	pointer
)	O
return	O
NULL	O
;	O
res	pointer
->	O
file	pointer
=	O
file	pointer
;	O
if	O
(	O
exact_match	function
(	O
file	pointer
,	O
word	pointer
,	O
res	pointer
)	O
)	O
{	O
free	function
(	O
res	pointer
)	O
;	O
res	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
res	pointer
->	O
type	enum
=	O
result_define	int
;	O
res	pointer
->	O
compare_count	long
=	O
compare_count	long
;	O
}	O
return	O
(	O
dico_result_t	pointer
)	O
res	pointer
;	O
}	O
static	O
void	O
printdef	function
(	O
dico_stream_t	pointer
str	pointer
,	O
struct	O
outline_file	struct
*	O
file	pointer
,	O
const	O
struct	O
entry	struct
*	O
ep	pointer
)	O
{	O
FILE	struct
*	O
fp	pointer
=	O
file	pointer
->	O
fp	pointer
;	O
size_t	long
size	long
=	O
ep	pointer
->	O
size	long
;	O
char	O
buf	pointer
[	O
128	int
]	O
;	O
fseek	function
(	O
fp	pointer
,	O
ep	pointer
->	O
offset	long
,	O
SEEK_SET	int
)	O
;	O
while	O
(	O
size	long
)	O
{	O
size_t	long
rdsize	long
=	O
size	long
;	O
if	O
(	O
rdsize	long
>	O
sizeof	O
(	O
buf	pointer
)	O
)	O
rdsize	long
=	O
sizeof	O
(	O
buf	pointer
)	O
;	O
rdsize	long
=	O
fread	function
(	O
buf	pointer
,	O
1	int
,	O
rdsize	long
,	O
fp	pointer
)	O
;	O
if	O
(	O
rdsize	long
==	O
0	int
)	O
break	O
;	O
dico_stream_write	function
(	O
str	pointer
,	O
buf	pointer
,	O
rdsize	long
)	O
;	O
size	long
-=	O
rdsize	long
;	O
}	O
}	O
static	O
int	O
outline_output_result	function
(	O
dico_result_t	pointer
rp	pointer
,	O
size_t	long
n	long
,	O
dico_stream_t	pointer
str	pointer
)	O
{	O
struct	O
result	pointer
*	O
res	pointer
=	O
(	O
struct	O
result	pointer
*	O
)	O
rp	pointer
;	O
const	O
struct	O
entry	struct
*	O
ep	pointer
;	O
switch	O
(	O
res	pointer
->	O
type	enum
)	O
{	O
case	O
result_match	int
:	O
ep	pointer
=	O
res	pointer
->	O
v	union
.	O
ep	pointer
+	O
n	long
;	O
dico_stream_write	function
(	O
str	pointer
,	O
ep	pointer
->	O
word	pointer
,	O
strlen	function
(	O
ep	pointer
->	O
word	pointer
)	O
)	O
;	O
break	O
;	O
case	O
result_match_list	int
:	O
ep	pointer
=	O
dico_list_item	function
(	O
res	pointer
->	O
v	union
.	O
list	array
,	O
n	long
)	O
;	O
dico_stream_write	function
(	O
str	pointer
,	O
ep	pointer
->	O
word	pointer
,	O
strlen	function
(	O
ep	pointer
->	O
word	pointer
)	O
)	O
;	O
break	O
;	O
case	O
result_define	int
:	O
ep	pointer
=	O
res	pointer
->	O
v	union
.	O
ep	pointer
+	O
n	long
;	O
printdef	function
(	O
str	pointer
,	O
res	pointer
->	O
file	pointer
,	O
ep	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
size_t	long
outline_result_count	function
(	O
dico_result_t	pointer
rp	pointer
)	O
{	O
struct	O
result	pointer
*	O
res	pointer
=	O
(	O
struct	O
result	pointer
*	O
)	O
rp	pointer
;	O
return	O
res	pointer
->	O
count	long
;	O
}	O
static	O
size_t	long
outline_compare_count	function
(	O
dico_result_t	pointer
rp	pointer
)	O
{	O
struct	O
result	pointer
*	O
res	pointer
=	O
(	O
struct	O
result	pointer
*	O
)	O
rp	pointer
;	O
return	O
res	pointer
->	O
compare_count	long
;	O
}	O
static	O
void	O
outline_free_result	function
(	O
dico_result_t	pointer
rp	pointer
)	O
{	O
struct	O
result	pointer
*	O
res	pointer
=	O
(	O
struct	O
result	pointer
*	O
)	O
rp	pointer
;	O
if	O
(	O
res	pointer
->	O
type	enum
==	O
result_match_list	int
)	O
dico_list_destroy	function
(	O
&	O
res	pointer
->	O
v	union
.	O
list	array
)	O
;	O
free	function
(	O
rp	pointer
)	O
;	O
}	O
static	O
char	O
*	O
outline_db_mime_header	function
(	O
dico_handle_t	pointer
hp	pointer
)	O
{	O
struct	O
outline_file	struct
*	O
file	pointer
=	O
(	O
struct	O
outline_file	struct
*	O
)	O
hp	pointer
;	O
if	O
(	O
file	pointer
->	O
mime_entry	pointer
)	O
return	O
read_buf	function
(	O
file	pointer
,	O
file	pointer
->	O
mime_entry	pointer
,	O
1	int
)	O
;	O
return	O
NULL	O
;	O
}	O
struct	O
dico_database_module	struct
DICO_EXPORT	O
(	O
outline	O
,	O
module	O
)	O
=	O
{	O
.	O
dico_version	int
=	O
DICO_MODULE_VERSION	int
,	O
.	O
dico_capabilities	int
=	O
DICO_CAPA_NONE	int
,	O
.	O
dico_init	pointer
=	O
outline_init	function
,	O
.	O
dico_init_db	pointer
=	O
outline_init_db	function
,	O
.	O
dico_free_db	pointer
=	O
outline_free_db	function
,	O
.	O
dico_db_info	pointer
=	O
outline_info	function
,	O
.	O
dico_db_descr	pointer
=	O
outline_descr	function
,	O
.	O
dico_db_lang	pointer
=	O
outline_lang	function
,	O
.	O
dico_match	pointer
=	O
outline_match	function
,	O
.	O
dico_define	pointer
=	O
outline_define	function
,	O
.	O
dico_output_result	pointer
=	O
outline_output_result	function
,	O
.	O
dico_result_count	pointer
=	O
outline_result_count	function
,	O
.	O
dico_compare_count	pointer
=	O
outline_compare_count	function
,	O
.	O
dico_free_result	pointer
=	O
outline_free_result	function
,	O
.	O
dico_db_mime_header	pointer
=	O
outline_db_mime_header	function
}	O
;	O
