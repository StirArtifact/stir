static	O
void	O
escape_string	function
(	O
register	O
FILE	struct
*	O
out	pointer
,	O
register	O
char	O
const	O
*	O
s	pointer
)	O
{	O
register	O
char	O
c	int
;	O
for	O
(	O
;	O
;	O
)	O
switch	O
(	O
(	O
c	int
=	O
*	O
s	pointer
++	O
)	O
)	O
{	O
case	O
0	int
:	O
return	O
;	O
case	O
'\t'	O
:	O
aputs	function
(	O
"\\t"	pointer
,	O
out	pointer
)	O
;	O
break	O
;	O
case	O
'\n'	O
:	O
aputs	function
(	O
"\\n"	pointer
,	O
out	pointer
)	O
;	O
break	O
;	O
case	O
' '	O
:	O
aputs	function
(	O
"\\040"	pointer
,	O
out	pointer
)	O
;	O
break	O
;	O
case	O
KDELIM	char
:	O
aputs	function
(	O
"\\044"	pointer
,	O
out	pointer
)	O
;	O
break	O
;	O
case	O
'\\'	O
:	O
if	O
(	O
VERSION	O
(	O
5	int
)	O
<=	O
BE	O
(	O
version	int
)	O
)	O
{	O
aputs	function
(	O
"\\\\"	pointer
,	O
out	pointer
)	O
;	O
break	O
;	O
}	O
default	O
:	O
aputc	O
(	O
c	int
,	O
out	pointer
)	O
;	O
break	O
;	O
}	O
}	O
static	O
void	O
keyreplace	function
(	O
struct	O
pool_found	struct
*	O
marker	pointer
,	O
struct	O
expctx	struct
*	O
ctx	pointer
)	O
{	O
struct	O
fro	struct
*	O
infile	pointer
=	O
ctx	pointer
->	O
from	pointer
;	O
register	O
FILE	struct
*	O
out	pointer
=	O
ctx	pointer
->	O
to	pointer
;	O
register	O
struct	O
delta	struct
const	O
*	O
delta	struct
=	O
ctx	pointer
->	O
delta	struct
;	O
bool	bool
dolog	bool
=	O
ctx	pointer
->	O
dolog	bool
,	O
delimstuffed	bool
=	O
ctx	pointer
->	O
delimstuffed	bool
;	O
register	O
char	O
const	O
*	O
sp	pointer
,	O
*	O
cp	pointer
,	O
*	O
date	pointer
;	O
int	O
c	int
;	O
register	O
size_t	long
cs	long
,	O
cw	long
,	O
ls	long
;	O
char	O
const	O
*	O
sp1	pointer
;	O
char	O
datebuf	array
[	O
datesize	O
+	O
zonelenmax	int
]	O
;	O
int	O
RCSv	int
;	O
int	O
exp	int
;	O
bool	bool
include_locker	bool
=	O
BE	O
(	O
inclusive_of_Locker_in_Id_val	bool
)	O
;	O
exp	int
=	O
BE	O
(	O
kws	int
)	O
;	O
date	pointer
=	O
delta	struct
->	O
date	pointer
;	O
RCSv	int
=	O
BE	O
(	O
version	int
)	O
;	O
if	O
(	O
exp	int
!=	O
kwsub_v	int
)	O
aprintf	function
(	O
out	pointer
,	O
"%c%s"	pointer
,	O
KDELIM	char
,	O
marker	pointer
->	O
sym	pointer
->	O
bytes	array
)	O
;	O
if	O
(	O
exp	int
!=	O
kwsub_k	int
)	O
{	O
if	O
(	O
exp	int
!=	O
kwsub_v	int
)	O
aprintf	function
(	O
out	pointer
,	O
"%c%c"	pointer
,	O
VDELIM	char
,	O
marker	pointer
->	O
i	int
==	O
Log	int
&&	O
RCSv	int
<	O
VERSION	O
(	O
5	int
)	O
?	O
'\t'	O
:	O
' '	O
)	O
;	O
switch	O
(	O
marker	pointer
->	O
i	int
)	O
{	O
case	O
Author	int
:	O
aputs	function
(	O
delta	struct
->	O
author	pointer
,	O
out	pointer
)	O
;	O
break	O
;	O
case	O
Date	int
:	O
aputs	function
(	O
date2str	function
(	O
date	pointer
,	O
datebuf	array
)	O
,	O
out	pointer
)	O
;	O
break	O
;	O
case	O
Id	int
:	O
case	O
Header	int
:	O
escape_string	function
(	O
out	pointer
,	O
marker	pointer
->	O
i	int
==	O
Id	int
||	O
RCSv	int
<	O
VERSION	O
(	O
4	int
)	O
?	O
basefilename	function
(	O
REPO	O
(	O
filename	pointer
)	O
)	O
:	O
getfullRCSname	function
(	O
)	O
)	O
;	O
aprintf	function
(	O
out	pointer
,	O
" %s %s %s %s"	pointer
,	O
delta	struct
->	O
num	pointer
,	O
date2str	function
(	O
date	pointer
,	O
datebuf	array
)	O
,	O
delta	struct
->	O
author	pointer
,	O
RCSv	int
==	O
VERSION	O
(	O
3	int
)	O
&&	O
delta	struct
->	O
lockedby	pointer
?	O
"Locked"	pointer
:	O
delta	struct
->	O
state	pointer
)	O
;	O
if	O
(	O
delta	struct
->	O
lockedby	pointer
)	O
{	O
if	O
(	O
VERSION	O
(	O
5	int
)	O
<=	O
RCSv	int
)	O
{	O
if	O
(	O
include_locker	bool
||	O
exp	int
==	O
kwsub_kvl	int
)	O
aprintf	function
(	O
out	pointer
,	O
" %s"	pointer
,	O
delta	struct
->	O
lockedby	pointer
)	O
;	O
}	O
else	O
if	O
(	O
RCSv	int
==	O
VERSION	O
(	O
4	int
)	O
)	O
aprintf	function
(	O
out	pointer
,	O
" Locker: %s"	pointer
,	O
delta	struct
->	O
lockedby	pointer
)	O
;	O
}	O
break	O
;	O
case	O
Locker	int
:	O
if	O
(	O
delta	struct
->	O
lockedby	pointer
)	O
if	O
(	O
include_locker	bool
||	O
exp	int
==	O
kwsub_kvl	int
||	O
RCSv	int
<=	O
VERSION	O
(	O
4	int
)	O
)	O
aputs	function
(	O
delta	struct
->	O
lockedby	pointer
,	O
out	pointer
)	O
;	O
break	O
;	O
case	O
Log	int
:	O
case	O
RCSfile	int
:	O
escape_string	function
(	O
out	pointer
,	O
basefilename	function
(	O
REPO	O
(	O
filename	pointer
)	O
)	O
)	O
;	O
break	O
;	O
case	O
Name	int
:	O
if	O
(	O
delta	struct
->	O
name	pointer
)	O
aputs	function
(	O
delta	struct
->	O
name	pointer
,	O
out	pointer
)	O
;	O
break	O
;	O
case	O
Revision	int
:	O
aputs	function
(	O
delta	struct
->	O
num	pointer
,	O
out	pointer
)	O
;	O
break	O
;	O
case	O
Source	int
:	O
escape_string	function
(	O
out	pointer
,	O
getfullRCSname	function
(	O
)	O
)	O
;	O
break	O
;	O
case	O
State	int
:	O
aputs	function
(	O
delta	struct
->	O
state	pointer
,	O
out	pointer
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
exp	int
!=	O
kwsub_v	int
)	O
afputc	function
(	O
' '	O
,	O
out	pointer
)	O
;	O
}	O
if	O
(	O
exp	int
!=	O
kwsub_v	int
)	O
afputc	function
(	O
KDELIM	char
,	O
out	pointer
)	O
;	O
if	O
(	O
marker	pointer
->	O
i	int
==	O
Log	int
&&	O
dolog	bool
)	O
{	O
char	O
*	O
leader	pointer
=	O
NULL	O
;	O
sp	pointer
=	O
delta	struct
->	O
pretty_log	struct
.	O
string	pointer
;	O
ls	long
=	O
delta	struct
->	O
pretty_log	struct
.	O
size	long
;	O
if	O
(	O
looking_at	function
(	O
&	O
TINY	O
(	O
ciklog	O
)	O
,	O
delta	struct
->	O
pretty_log	struct
.	O
string	pointer
)	O
)	O
return	O
;	O
if	O
(	O
RCSv	int
<	O
VERSION	O
(	O
5	int
)	O
)	O
{	O
cp	pointer
=	O
REPO	O
(	O
log_lead	struct
)	O
.	O
string	pointer
;	O
cs	long
=	O
REPO	O
(	O
log_lead	struct
)	O
.	O
size	long
;	O
}	O
else	O
{	O
bool	bool
kdelim_found	bool
=	O
false	int
;	O
off_t	long
chars_read	long
=	O
fro_tello	function
(	O
infile	pointer
)	O
;	O
c	int
=	O
0	int
;	O
cs	long
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
!	O
--	O
chars_read	long
)	O
goto	O
done_backing_up	O
;	O
GET_PREV_BYTE	O
(	O
)	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
break	O
;	O
if	O
(	O
c	int
==	O
SDELIM	char
&&	O
delimstuffed	bool
)	O
{	O
if	O
(	O
!	O
--	O
chars_read	long
)	O
break	O
;	O
GET_PREV_BYTE	O
(	O
)	O
;	O
if	O
(	O
c	int
!=	O
SDELIM	char
)	O
{	O
GETCHAR	O
(	O
c	int
,	O
infile	pointer
)	O
;	O
break	O
;	O
}	O
}	O
cs	long
+=	O
kdelim_found	bool
;	O
kdelim_found	bool
|=	O
c	int
==	O
KDELIM	char
;	O
}	O
GETCHAR	O
(	O
c	int
,	O
infile	pointer
)	O
;	O
done_backing_up	O
:	O
;	O
leader	pointer
=	O
alloc	function
(	O
SINGLE	O
,	O
"leader"	pointer
,	O
1	int
+	O
cs	long
)	O
;	O
cp	pointer
=	O
leader	pointer
;	O
for	O
(	O
cw	long
=	O
0	int
;	O
cw	long
<	O
cs	long
;	O
cw	long
++	O
)	O
{	O
leader	pointer
[	O
cw	long
]	O
=	O
c	int
;	O
if	O
(	O
c	int
==	O
SDELIM	char
&&	O
delimstuffed	bool
)	O
GETCHAR	O
(	O
c	int
,	O
infile	pointer
)	O
;	O
GETCHAR	O
(	O
c	int
,	O
infile	pointer
)	O
;	O
}	O
for	O
(	O
cw	long
=	O
0	int
;	O
cw	long
<	O
cs	long
;	O
cw	long
++	O
)	O
if	O
(	O
ctab	array
[	O
(	O
unsigned	O
char	O
)	O
cp	pointer
[	O
cw	long
]	O
]	O
!=	O
SPACE	int
)	O
break	O
;	O
if	O
(	O
cw	long
+	O
1	int
<	O
cs	long
&&	O
cp	pointer
[	O
cw	long
+	O
1	int
]	O
==	O
'*'	O
&&	O
(	O
cp	pointer
[	O
cw	long
]	O
==	O
'/'	O
||	O
cp	pointer
[	O
cw	long
]	O
==	O
'('	O
)	O
)	O
{	O
size_t	long
i	int
=	O
cw	long
+	O
1	int
;	O
for	O
(	O
;	O
;	O
)	O
if	O
(	O
++	O
i	int
==	O
cs	long
)	O
{	O
PWARN	O
(	O
"`%c* $Log' is obsolescent; use ` * $Log'."	pointer
,	O
cp	pointer
[	O
cw	long
]	O
)	O
;	O
leader	pointer
[	O
cw	long
]	O
=	O
' '	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
ctab	array
[	O
(	O
unsigned	O
char	O
)	O
cp	pointer
[	O
i	int
]	O
]	O
!=	O
SPACE	int
)	O
break	O
;	O
}	O
do	O
GETCHAR	O
(	O
c	int
,	O
infile	pointer
)	O
;	O
while	O
(	O
c	int
!=	O
KDELIM	char
)	O
;	O
}	O
afputc	function
(	O
'\n'	O
,	O
out	pointer
)	O
;	O
awrite	function
(	O
cp	pointer
,	O
cs	long
,	O
out	pointer
)	O
;	O
sp1	pointer
=	O
date2str	function
(	O
date	pointer
,	O
datebuf	array
)	O
;	O
if	O
(	O
VERSION	O
(	O
5	int
)	O
<=	O
RCSv	int
)	O
{	O
aprintf	function
(	O
out	pointer
,	O
"Revision %s  %s  %s"	pointer
,	O
delta	struct
->	O
num	pointer
,	O
sp1	pointer
,	O
delta	struct
->	O
author	pointer
)	O
;	O
}	O
else	O
{	O
sp1	pointer
=	O
strchr	function
(	O
sp1	pointer
,	O
' '	O
)	O
;	O
aprintf	function
(	O
out	pointer
,	O
"Revision %s  %.*s %s  %s"	pointer
,	O
delta	struct
->	O
num	pointer
,	O
(	O
int	O
)	O
(	O
sp1	pointer
-	O
datebuf	array
)	O
,	O
datebuf	array
,	O
sp1	pointer
,	O
delta	struct
->	O
author	pointer
)	O
;	O
}	O
cw	long
=	O
cs	long
;	O
if	O
(	O
VERSION	O
(	O
5	int
)	O
<=	O
RCSv	int
)	O
for	O
(	O
;	O
cw	long
&&	O
(	O
cp	pointer
[	O
cw	long
-	O
1	int
]	O
==	O
' '	O
||	O
cp	pointer
[	O
cw	long
-	O
1	int
]	O
==	O
'\t'	O
)	O
;	O
--	O
cw	long
)	O
continue	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
afputc	function
(	O
'\n'	O
,	O
out	pointer
)	O
;	O
awrite	function
(	O
cp	pointer
,	O
cw	long
,	O
out	pointer
)	O
;	O
if	O
(	O
!	O
ls	long
)	O
break	O
;	O
--	O
ls	long
;	O
c	int
=	O
*	O
sp	pointer
++	O
;	O
if	O
(	O
c	int
!=	O
'\n'	O
)	O
{	O
awrite	function
(	O
cp	pointer
+	O
cw	long
,	O
cs	long
-	O
cw	long
,	O
out	pointer
)	O
;	O
do	O
{	O
afputc	function
(	O
c	int
,	O
out	pointer
)	O
;	O
if	O
(	O
!	O
ls	long
)	O
break	O
;	O
--	O
ls	long
;	O
c	int
=	O
*	O
sp	pointer
++	O
;	O
}	O
while	O
(	O
c	int
!=	O
'\n'	O
)	O
;	O
}	O
}	O
if	O
(	O
leader	pointer
)	O
brush_off	function
(	O
SINGLE	O
,	O
leader	pointer
)	O
;	O
}	O
}	O
int	O
expandline	function
(	O
struct	O
expctx	struct
*	O
ctx	pointer
)	O
{	O
struct	O
divvy	struct
*	O
lparts	pointer
=	O
ctx	pointer
->	O
lparts	pointer
;	O
struct	O
fro	struct
*	O
fin	pointer
=	O
ctx	pointer
->	O
from	pointer
;	O
bool	bool
delimstuffed	bool
=	O
ctx	pointer
->	O
delimstuffed	bool
;	O
int	O
c	int
;	O
register	O
FILE	struct
*	O
out	pointer
,	O
*	O
frew	pointer
;	O
register	O
int	O
r	pointer
;	O
bool	bool
e	pointer
;	O
struct	O
pool_found	struct
matchresult	struct
;	O
char	O
*	O
cooked	pointer
=	O
NULL	O
;	O
size_t	long
len	char
;	O
if	O
(	O
!	O
lparts	pointer
)	O
lparts	pointer
=	O
ctx	pointer
->	O
lparts	pointer
=	O
make_space	function
(	O
"lparts"	pointer
)	O
;	O
out	pointer
=	O
ctx	pointer
->	O
to	pointer
;	O
frew	pointer
=	O
ctx	pointer
->	O
rewr	pointer
;	O
forget	function
(	O
lparts	pointer
)	O
;	O
e	pointer
=	O
false	int
;	O
r	pointer
=	O
-	O
1	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
delimstuffed	bool
)	O
TEECHAR	O
(	O
)	O
;	O
else	O
GETCHAR_ELSE_GOTO	O
(	O
done	bool
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
switch	O
(	O
c	int
)	O
{	O
case	O
SDELIM	char
:	O
if	O
(	O
delimstuffed	bool
)	O
{	O
TEECHAR	O
(	O
)	O
;	O
if	O
(	O
c	int
!=	O
SDELIM	char
)	O
goto	O
done	bool
;	O
}	O
default	O
:	O
aputc	O
(	O
c	int
,	O
out	pointer
)	O
;	O
r	pointer
=	O
0	int
;	O
break	O
;	O
case	O
'\n'	O
:	O
aputc	O
(	O
c	int
,	O
out	pointer
)	O
;	O
r	pointer
=	O
2	int
;	O
goto	O
done	bool
;	O
case	O
KDELIM	char
:	O
r	pointer
=	O
0	int
;	O
accumulate_byte	function
(	O
lparts	pointer
,	O
KDELIM	char
)	O
;	O
len	char
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
delimstuffed	bool
)	O
TEECHAR	O
(	O
)	O
;	O
else	O
GETCHAR_ELSE_GOTO	O
(	O
keystring_eof	O
)	O
;	O
if	O
(	O
len	char
<=	O
keylength	int
+	O
3	int
)	O
switch	O
(	O
ctab	array
[	O
c	int
]	O
)	O
{	O
case	O
LETTER	int
:	O
case	O
Letter	int
:	O
accumulate_byte	function
(	O
lparts	pointer
,	O
c	int
)	O
;	O
len	char
++	O
;	O
continue	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
}	O
accumulate_byte	function
(	O
lparts	pointer
,	O
c	int
)	O
;	O
cooked	pointer
=	O
finish_string	function
(	O
lparts	pointer
,	O
&	O
len	char
)	O
;	O
if	O
(	O
!	O
recognize_keyword	function
(	O
cooked	pointer
+	O
1	int
,	O
&	O
matchresult	struct
)	O
)	O
{	O
cooked	pointer
[	O
len	char
-	O
1	int
]	O
=	O
'\0'	O
;	O
aputs	function
(	O
cooked	pointer
,	O
out	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
c	int
==	O
VDELIM	char
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
delimstuffed	bool
)	O
TEECHAR	O
(	O
)	O
;	O
else	O
GETCHAR_ELSE_GOTO	O
(	O
keystring_eof	O
)	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
||	O
c	int
==	O
KDELIM	char
)	O
break	O
;	O
accumulate_byte	function
(	O
lparts	pointer
,	O
c	int
)	O
;	O
if	O
(	O
c	int
==	O
SDELIM	char
&&	O
delimstuffed	bool
)	O
{	O
TEECHAR	O
(	O
)	O
;	O
if	O
(	O
c	int
!=	O
SDELIM	char
)	O
goto	O
keystring_eof	O
;	O
}	O
}	O
if	O
(	O
c	int
!=	O
KDELIM	char
)	O
{	O
cooked	pointer
=	O
finish_string	function
(	O
lparts	pointer
,	O
&	O
len	char
)	O
;	O
aputs	function
(	O
cooked	pointer
,	O
out	pointer
)	O
;	O
continue	O
;	O
}	O
cooked	pointer
=	O
finish_string	function
(	O
lparts	pointer
,	O
&	O
len	char
)	O
;	O
}	O
keyreplace	function
(	O
&	O
matchresult	struct
,	O
ctx	pointer
)	O
;	O
e	pointer
=	O
true	int
;	O
break	O
;	O
}	O
break	O
;	O
}	O
}	O
keystring_eof	O
:	O
cooked	pointer
=	O
finish_string	function
(	O
lparts	pointer
,	O
&	O
len	char
)	O
;	O
aputs	function
(	O
cooked	pointer
,	O
out	pointer
)	O
;	O
done	bool
:	O
return	O
r	pointer
+	O
e	pointer
;	O
}	O
