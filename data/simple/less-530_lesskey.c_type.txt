struct	O
cmdname	struct
{	O
char	O
*	O
cn_name	pointer
;	O
int	O
cn_action	int
;	O
}	O
;	O
struct	O
cmdname	struct
cmdnames	array
[	O
]	O
=	O
{	O
{	O
"back-bracket"	pointer
,	O
A_B_BRACKET	int
}	O
,	O
{	O
"back-line"	pointer
,	O
A_B_LINE	int
}	O
,	O
{	O
"back-line-force"	pointer
,	O
A_BF_LINE	int
}	O
,	O
{	O
"back-screen"	pointer
,	O
A_B_SCREEN	int
}	O
,	O
{	O
"back-scroll"	pointer
,	O
A_B_SCROLL	int
}	O
,	O
{	O
"back-search"	pointer
,	O
A_B_SEARCH	int
}	O
,	O
{	O
"back-window"	pointer
,	O
A_B_WINDOW	int
}	O
,	O
{	O
"clear-mark"	pointer
,	O
A_CLRMARK	int
}	O
,	O
{	O
"debug"	pointer
,	O
A_DEBUG	int
}	O
,	O
{	O
"digit"	pointer
,	O
A_DIGIT	int
}	O
,	O
{	O
"display-flag"	pointer
,	O
A_DISP_OPTION	int
}	O
,	O
{	O
"display-option"	pointer
,	O
A_DISP_OPTION	int
}	O
,	O
{	O
"end"	pointer
,	O
A_GOEND	int
}	O
,	O
{	O
"end-scroll"	pointer
,	O
A_RRSHIFT	int
}	O
,	O
{	O
"examine"	pointer
,	O
A_EXAMINE	int
}	O
,	O
{	O
"filter"	pointer
,	O
A_FILTER	int
}	O
,	O
{	O
"first-cmd"	pointer
,	O
A_FIRSTCMD	int
}	O
,	O
{	O
"firstcmd"	pointer
,	O
A_FIRSTCMD	int
}	O
,	O
{	O
"flush-repaint"	pointer
,	O
A_FREPAINT	int
}	O
,	O
{	O
"forw-bracket"	pointer
,	O
A_F_BRACKET	int
}	O
,	O
{	O
"forw-forever"	pointer
,	O
A_F_FOREVER	int
}	O
,	O
{	O
"forw-until-hilite"	pointer
,	O
A_F_UNTIL_HILITE	int
}	O
,	O
{	O
"forw-line"	pointer
,	O
A_F_LINE	int
}	O
,	O
{	O
"forw-line-force"	pointer
,	O
A_FF_LINE	int
}	O
,	O
{	O
"forw-screen"	pointer
,	O
A_F_SCREEN	int
}	O
,	O
{	O
"forw-screen-force"	pointer
,	O
A_FF_SCREEN	int
}	O
,	O
{	O
"forw-scroll"	pointer
,	O
A_F_SCROLL	int
}	O
,	O
{	O
"forw-search"	pointer
,	O
A_F_SEARCH	int
}	O
,	O
{	O
"forw-window"	pointer
,	O
A_F_WINDOW	int
}	O
,	O
{	O
"goto-end"	pointer
,	O
A_GOEND	int
}	O
,	O
{	O
"goto-end-buffered"	pointer
,	O
A_GOEND_BUF	int
}	O
,	O
{	O
"goto-line"	pointer
,	O
A_GOLINE	int
}	O
,	O
{	O
"goto-mark"	pointer
,	O
A_GOMARK	int
}	O
,	O
{	O
"help"	pointer
,	O
A_HELP	int
}	O
,	O
{	O
"index-file"	pointer
,	O
A_INDEX_FILE	int
}	O
,	O
{	O
"invalid"	pointer
,	O
A_UINVALID	int
}	O
,	O
{	O
"left-scroll"	pointer
,	O
A_LSHIFT	int
}	O
,	O
{	O
"next-file"	pointer
,	O
A_NEXT_FILE	int
}	O
,	O
{	O
"next-tag"	pointer
,	O
A_NEXT_TAG	int
}	O
,	O
{	O
"noaction"	pointer
,	O
A_NOACTION	int
}	O
,	O
{	O
"no-scroll"	pointer
,	O
A_LLSHIFT	int
}	O
,	O
{	O
"percent"	pointer
,	O
A_PERCENT	int
}	O
,	O
{	O
"pipe"	pointer
,	O
A_PIPE	int
}	O
,	O
{	O
"prev-file"	pointer
,	O
A_PREV_FILE	int
}	O
,	O
{	O
"prev-tag"	pointer
,	O
A_PREV_TAG	int
}	O
,	O
{	O
"quit"	pointer
,	O
A_QUIT	int
}	O
,	O
{	O
"remove-file"	pointer
,	O
A_REMOVE_FILE	int
}	O
,	O
{	O
"repaint"	pointer
,	O
A_REPAINT	int
}	O
,	O
{	O
"repaint-flush"	pointer
,	O
A_FREPAINT	int
}	O
,	O
{	O
"repeat-search"	pointer
,	O
A_AGAIN_SEARCH	int
}	O
,	O
{	O
"repeat-search-all"	pointer
,	O
A_T_AGAIN_SEARCH	int
}	O
,	O
{	O
"reverse-search"	pointer
,	O
A_REVERSE_SEARCH	int
}	O
,	O
{	O
"reverse-search-all"	pointer
,	O
A_T_REVERSE_SEARCH	int
}	O
,	O
{	O
"right-scroll"	pointer
,	O
A_RSHIFT	int
}	O
,	O
{	O
"set-mark"	pointer
,	O
A_SETMARK	int
}	O
,	O
{	O
"set-mark-bottom"	pointer
,	O
A_SETMARKBOT	int
}	O
,	O
{	O
"shell"	pointer
,	O
A_SHELL	int
}	O
,	O
{	O
"status"	pointer
,	O
A_STAT	int
}	O
,	O
{	O
"toggle-flag"	pointer
,	O
A_OPT_TOGGLE	int
}	O
,	O
{	O
"toggle-option"	pointer
,	O
A_OPT_TOGGLE	int
}	O
,	O
{	O
"undo-hilite"	pointer
,	O
A_UNDO_SEARCH	int
}	O
,	O
{	O
"version"	pointer
,	O
A_VERSION	int
}	O
,	O
{	O
"visual"	pointer
,	O
A_VISUAL	int
}	O
,	O
{	O
NULL	O
,	O
0	int
}	O
}	O
;	O
struct	O
cmdname	struct
editnames	array
[	O
]	O
=	O
{	O
{	O
"back-complete"	pointer
,	O
EC_B_COMPLETE	int
}	O
,	O
{	O
"backspace"	pointer
,	O
EC_BACKSPACE	int
}	O
,	O
{	O
"delete"	pointer
,	O
EC_DELETE	int
}	O
,	O
{	O
"down"	pointer
,	O
EC_DOWN	int
}	O
,	O
{	O
"end"	pointer
,	O
EC_END	int
}	O
,	O
{	O
"expand"	pointer
,	O
EC_EXPAND	int
}	O
,	O
{	O
"forw-complete"	pointer
,	O
EC_F_COMPLETE	int
}	O
,	O
{	O
"home"	pointer
,	O
EC_HOME	int
}	O
,	O
{	O
"insert"	pointer
,	O
EC_INSERT	int
}	O
,	O
{	O
"invalid"	pointer
,	O
EC_UINVALID	int
}	O
,	O
{	O
"kill-line"	pointer
,	O
EC_LINEKILL	int
}	O
,	O
{	O
"abort"	pointer
,	O
EC_ABORT	int
}	O
,	O
{	O
"left"	pointer
,	O
EC_LEFT	int
}	O
,	O
{	O
"literal"	pointer
,	O
EC_LITERAL	int
}	O
,	O
{	O
"right"	pointer
,	O
EC_RIGHT	int
}	O
,	O
{	O
"up"	pointer
,	O
EC_UP	int
}	O
,	O
{	O
"word-backspace"	pointer
,	O
EC_W_BACKSPACE	int
}	O
,	O
{	O
"word-delete"	pointer
,	O
EC_W_DELETE	int
}	O
,	O
{	O
"word-left"	pointer
,	O
EC_W_LEFT	int
}	O
,	O
{	O
"word-right"	pointer
,	O
EC_W_RIGHT	int
}	O
,	O
{	O
NULL	O
,	O
0	int
}	O
}	O
;	O
struct	O
table	pointer
{	O
struct	O
cmdname	struct
*	O
names	pointer
;	O
char	O
*	O
pbuffer	pointer
;	O
char	O
buffer	array
[	O
MAX_USERCMD	int
]	O
;	O
}	O
;	O
struct	O
table	pointer
cmdtable	struct
;	O
struct	O
table	pointer
edittable	struct
;	O
struct	O
table	pointer
vartable	struct
;	O
struct	O
table	pointer
*	O
currtable	pointer
=	O
&	O
cmdtable	struct
;	O
char	O
fileheader	array
[	O
]	O
=	O
{	O
C0_LESSKEY_MAGIC	char
,	O
C1_LESSKEY_MAGIC	char
,	O
C2_LESSKEY_MAGIC	char
,	O
C3_LESSKEY_MAGIC	char
}	O
;	O
char	O
filetrailer	array
[	O
]	O
=	O
{	O
C0_END_LESSKEY_MAGIC	char
,	O
C1_END_LESSKEY_MAGIC	char
,	O
C2_END_LESSKEY_MAGIC	char
}	O
;	O
char	O
cmdsection	array
[	O
1	int
]	O
=	O
{	O
CMD_SECTION	char
}	O
;	O
char	O
editsection	array
[	O
1	int
]	O
=	O
{	O
EDIT_SECTION	char
}	O
;	O
char	O
varsection	array
[	O
1	int
]	O
=	O
{	O
VAR_SECTION	char
}	O
;	O
char	O
endsection	array
[	O
1	int
]	O
=	O
{	O
END_SECTION	char
}	O
;	O
char	O
*	O
infile	pointer
=	O
NULL	O
;	O
char	O
*	O
outfile	pointer
=	O
NULL	O
;	O
int	O
linenum	long
;	O
int	O
errors	int
;	O
extern	O
char	O
version	array
[	O
]	O
;	O
void	O
usage	function
(	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"usage: lesskey [-o output] [input]\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
char	O
*	O
mkpathname	function
(	O
dirname	pointer
,	O
filename	pointer
)	O
char	O
*	O
dirname	pointer
;	O
char	O
*	O
filename	pointer
;	O
{	O
char	O
*	O
pathname	pointer
;	O
pathname	pointer
=	O
calloc	function
(	O
strlen	function
(	O
dirname	pointer
)	O
+	O
strlen	function
(	O
filename	pointer
)	O
+	O
2	int
,	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
strcpy	function
(	O
pathname	pointer
,	O
dirname	pointer
)	O
;	O
strcat	function
(	O
pathname	pointer
,	O
PATHNAME_SEP	pointer
)	O
;	O
strcat	function
(	O
pathname	pointer
,	O
filename	pointer
)	O
;	O
return	O
(	O
pathname	pointer
)	O
;	O
}	O
char	O
*	O
homefile	function
(	O
filename	pointer
)	O
char	O
*	O
filename	pointer
;	O
{	O
char	O
*	O
p	pointer
;	O
char	O
*	O
pathname	pointer
;	O
if	O
(	O
(	O
p	pointer
=	O
getenv	function
(	O
"HOME"	pointer
)	O
)	O
!=	O
NULL	O
&&	O
*	O
p	pointer
!=	O
'\0'	O
)	O
pathname	pointer
=	O
mkpathname	function
(	O
p	pointer
,	O
filename	pointer
)	O
;	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"cannot find $HOME - using current directory\n"	pointer
)	O
;	O
pathname	pointer
=	O
mkpathname	function
(	O
"."	pointer
,	O
filename	pointer
)	O
;	O
}	O
return	O
(	O
pathname	pointer
)	O
;	O
}	O
void	O
parse_args	function
(	O
argc	int
,	O
argv	pointer
)	O
int	O
argc	int
;	O
char	O
*	O
*	O
argv	pointer
;	O
{	O
char	O
*	O
arg	pointer
;	O
outfile	pointer
=	O
NULL	O
;	O
while	O
(	O
--	O
argc	int
>	O
0	int
)	O
{	O
arg	pointer
=	O
*	O
++	O
argv	pointer
;	O
if	O
(	O
arg	pointer
[	O
0	int
]	O
!=	O
'-'	O
)	O
break	O
;	O
if	O
(	O
arg	pointer
[	O
1	int
]	O
==	O
'\0'	O
)	O
break	O
;	O
if	O
(	O
arg	pointer
[	O
1	int
]	O
==	O
'-'	O
&&	O
arg	pointer
[	O
2	int
]	O
==	O
'\0'	O
)	O
{	O
argc	int
--	O
;	O
argv	pointer
++	O
;	O
break	O
;	O
}	O
switch	O
(	O
arg	pointer
[	O
1	int
]	O
)	O
{	O
case	O
'-'	O
:	O
if	O
(	O
strncmp	function
(	O
arg	pointer
,	O
"--output"	pointer
,	O
8	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
arg	pointer
[	O
8	int
]	O
==	O
'\0'	O
)	O
outfile	pointer
=	O
&	O
arg	pointer
[	O
8	int
]	O
;	O
else	O
if	O
(	O
arg	pointer
[	O
8	int
]	O
==	O
'='	O
)	O
outfile	pointer
=	O
&	O
arg	pointer
[	O
9	int
]	O
;	O
else	O
usage	function
(	O
)	O
;	O
goto	O
opt_o	function
;	O
}	O
if	O
(	O
strcmp	function
(	O
arg	pointer
,	O
"--version"	pointer
)	O
==	O
0	int
)	O
{	O
goto	O
opt_V	O
;	O
}	O
usage	function
(	O
)	O
;	O
break	O
;	O
case	O
'o'	O
:	O
outfile	pointer
=	O
&	O
argv	pointer
[	O
0	int
]	O
[	O
2	int
]	O
;	O
opt_o	function
:	O
if	O
(	O
*	O
outfile	pointer
==	O
'\0'	O
)	O
{	O
if	O
(	O
--	O
argc	int
<=	O
0	int
)	O
usage	function
(	O
)	O
;	O
outfile	pointer
=	O
*	O
(	O
++	O
argv	pointer
)	O
;	O
}	O
break	O
;	O
case	O
'V'	O
:	O
opt_V	O
:	O
printf	function
(	O
"lesskey  version %s\n"	pointer
,	O
version	array
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
default	O
:	O
usage	function
(	O
)	O
;	O
}	O
}	O
if	O
(	O
argc	int
>	O
1	int
)	O
usage	function
(	O
)	O
;	O
if	O
(	O
argc	int
>	O
0	int
)	O
infile	pointer
=	O
*	O
argv	pointer
;	O
else	O
infile	pointer
=	O
homefile	function
(	O
DEF_LESSKEYINFILE	pointer
)	O
;	O
}	O
void	O
init_tables	function
(	O
)	O
{	O
cmdtable	struct
.	O
names	pointer
=	O
cmdnames	array
;	O
cmdtable	struct
.	O
pbuffer	pointer
=	O
cmdtable	struct
.	O
buffer	array
;	O
edittable	struct
.	O
names	pointer
=	O
editnames	array
;	O
edittable	struct
.	O
pbuffer	pointer
=	O
edittable	struct
.	O
buffer	array
;	O
vartable	struct
.	O
names	pointer
=	O
NULL	O
;	O
vartable	struct
.	O
pbuffer	pointer
=	O
vartable	struct
.	O
buffer	array
;	O
}	O
char	O
*	O
tstr	function
(	O
pp	pointer
,	O
xlate	int
)	O
char	O
*	O
*	O
pp	pointer
;	O
int	O
xlate	int
;	O
{	O
char	O
*	O
p	pointer
;	O
char	O
ch	long
;	O
int	O
i	int
;	O
static	O
char	O
buf	pointer
[	O
10	int
]	O
;	O
static	O
char	O
tstr_control_k	array
[	O
]	O
=	O
{	O
SK_SPECIAL_KEY	O
,	O
SK_CONTROL_K	int
,	O
6	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
'\0'	O
}	O
;	O
p	pointer
=	O
*	O
pp	pointer
;	O
switch	O
(	O
*	O
p	pointer
)	O
{	O
case	O
'\\'	O
:	O
++	O
p	pointer
;	O
switch	O
(	O
*	O
p	pointer
)	O
{	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
ch	long
=	O
0	int
;	O
i	int
=	O
0	int
;	O
do	O
ch	long
=	O
8	int
*	O
ch	long
+	O
(	O
*	O
p	pointer
-	O
'0'	O
)	O
;	O
while	O
(	O
*	O
++	O
p	pointer
>=	O
'0'	O
&&	O
*	O
p	pointer
<=	O
'7'	O
&&	O
++	O
i	int
<	O
3	int
)	O
;	O
*	O
pp	pointer
=	O
p	pointer
;	O
if	O
(	O
xlate	int
&&	O
ch	long
==	O
CONTROL	O
(	O
'K'	O
)	O
)	O
return	O
tstr_control_k	array
;	O
buf	pointer
[	O
0	int
]	O
=	O
ch	long
;	O
buf	pointer
[	O
1	int
]	O
=	O
'\0'	O
;	O
return	O
(	O
buf	pointer
)	O
;	O
case	O
'b'	O
:	O
*	O
pp	pointer
=	O
p	pointer
+	O
1	int
;	O
return	O
(	O
"\b"	pointer
)	O
;	O
case	O
'e'	O
:	O
*	O
pp	pointer
=	O
p	pointer
+	O
1	int
;	O
buf	pointer
[	O
0	int
]	O
=	O
ESC	O
;	O
buf	pointer
[	O
1	int
]	O
=	O
'\0'	O
;	O
return	O
(	O
buf	pointer
)	O
;	O
case	O
'n'	O
:	O
*	O
pp	pointer
=	O
p	pointer
+	O
1	int
;	O
return	O
(	O
"\n"	pointer
)	O
;	O
case	O
'r'	O
:	O
*	O
pp	pointer
=	O
p	pointer
+	O
1	int
;	O
return	O
(	O
"\r"	pointer
)	O
;	O
case	O
't'	O
:	O
*	O
pp	pointer
=	O
p	pointer
+	O
1	int
;	O
return	O
(	O
"\t"	pointer
)	O
;	O
case	O
'k'	O
:	O
if	O
(	O
xlate	int
)	O
{	O
switch	O
(	O
*	O
++	O
p	pointer
)	O
{	O
case	O
'u'	O
:	O
ch	long
=	O
SK_UP_ARROW	int
;	O
break	O
;	O
case	O
'd'	O
:	O
ch	long
=	O
SK_DOWN_ARROW	int
;	O
break	O
;	O
case	O
'r'	O
:	O
ch	long
=	O
SK_RIGHT_ARROW	int
;	O
break	O
;	O
case	O
'l'	O
:	O
ch	long
=	O
SK_LEFT_ARROW	int
;	O
break	O
;	O
case	O
'U'	O
:	O
ch	long
=	O
SK_PAGE_UP	int
;	O
break	O
;	O
case	O
'D'	O
:	O
ch	long
=	O
SK_PAGE_DOWN	int
;	O
break	O
;	O
case	O
'h'	O
:	O
ch	long
=	O
SK_HOME	int
;	O
break	O
;	O
case	O
'e'	O
:	O
ch	long
=	O
SK_END	int
;	O
break	O
;	O
case	O
'x'	O
:	O
ch	long
=	O
SK_DELETE	int
;	O
break	O
;	O
default	O
:	O
error	function
(	O
"illegal char after \\k"	pointer
,	O
NULL_PARG	O
)	O
;	O
*	O
pp	pointer
=	O
p	pointer
+	O
1	int
;	O
return	O
(	O
""	pointer
)	O
;	O
}	O
*	O
pp	pointer
=	O
p	pointer
+	O
1	int
;	O
buf	pointer
[	O
0	int
]	O
=	O
SK_SPECIAL_KEY	O
;	O
buf	pointer
[	O
1	int
]	O
=	O
ch	long
;	O
buf	pointer
[	O
2	int
]	O
=	O
6	int
;	O
buf	pointer
[	O
3	int
]	O
=	O
1	int
;	O
buf	pointer
[	O
4	int
]	O
=	O
1	int
;	O
buf	pointer
[	O
5	int
]	O
=	O
1	int
;	O
buf	pointer
[	O
6	int
]	O
=	O
'\0'	O
;	O
return	O
(	O
buf	pointer
)	O
;	O
}	O
default	O
:	O
*	O
pp	pointer
=	O
p	pointer
+	O
1	int
;	O
buf	pointer
[	O
0	int
]	O
=	O
*	O
p	pointer
;	O
buf	pointer
[	O
1	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
xlate	int
&&	O
buf	pointer
[	O
0	int
]	O
==	O
CONTROL	O
(	O
'K'	O
)	O
)	O
return	O
tstr_control_k	array
;	O
return	O
(	O
buf	pointer
)	O
;	O
}	O
case	O
'^'	O
:	O
*	O
pp	pointer
=	O
p	pointer
+	O
2	int
;	O
buf	pointer
[	O
0	int
]	O
=	O
CONTROL	O
(	O
p	pointer
[	O
1	int
]	O
)	O
;	O
buf	pointer
[	O
1	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
buf	pointer
[	O
0	int
]	O
==	O
CONTROL	O
(	O
'K'	O
)	O
)	O
return	O
tstr_control_k	array
;	O
return	O
(	O
buf	pointer
)	O
;	O
}	O
*	O
pp	pointer
=	O
p	pointer
+	O
1	int
;	O
buf	pointer
[	O
0	int
]	O
=	O
*	O
p	pointer
;	O
buf	pointer
[	O
1	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
xlate	int
&&	O
buf	pointer
[	O
0	int
]	O
==	O
CONTROL	O
(	O
'K'	O
)	O
)	O
return	O
tstr_control_k	array
;	O
return	O
(	O
buf	pointer
)	O
;	O
}	O
public	O
char	O
*	O
skipsp	function
(	O
s	pointer
)	O
char	O
*	O
s	pointer
;	O
{	O
while	O
(	O
*	O
s	pointer
==	O
' '	O
||	O
*	O
s	pointer
==	O
'\t'	O
)	O
s	pointer
++	O
;	O
return	O
(	O
s	pointer
)	O
;	O
}	O
public	O
char	O
*	O
skipnsp	function
(	O
s	pointer
)	O
char	O
*	O
s	pointer
;	O
{	O
while	O
(	O
*	O
s	pointer
!=	O
'\0'	O
&&	O
*	O
s	pointer
!=	O
' '	O
&&	O
*	O
s	pointer
!=	O
'\t'	O
)	O
s	pointer
++	O
;	O
return	O
(	O
s	pointer
)	O
;	O
}	O
char	O
*	O
clean_line	function
(	O
s	pointer
)	O
char	O
*	O
s	pointer
;	O
{	O
int	O
i	int
;	O
s	pointer
=	O
skipsp	function
(	O
s	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
s	pointer
[	O
i	int
]	O
!=	O
'\n'	O
&&	O
s	pointer
[	O
i	int
]	O
!=	O
'\r'	O
&&	O
s	pointer
[	O
i	int
]	O
!=	O
'\0'	O
;	O
i	int
++	O
)	O
if	O
(	O
s	pointer
[	O
i	int
]	O
==	O
'#'	O
&&	O
(	O
i	int
==	O
0	int
||	O
s	pointer
[	O
i	int
-	O
1	int
]	O
!=	O
'\\'	O
)	O
)	O
break	O
;	O
s	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
return	O
(	O
s	pointer
)	O
;	O
}	O
void	O
add_cmd_char	function
(	O
c	int
)	O
int	O
c	int
;	O
{	O
if	O
(	O
currtable	pointer
->	O
pbuffer	pointer
>=	O
currtable	pointer
->	O
buffer	array
+	O
MAX_USERCMD	int
)	O
{	O
error	function
(	O
"too many commands"	pointer
,	O
NULL_PARG	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
*	O
(	O
currtable	pointer
->	O
pbuffer	pointer
)	O
++	O
=	O
c	int
;	O
}	O
void	O
add_cmd_str	function
(	O
s	pointer
)	O
char	O
*	O
s	pointer
;	O
{	O
for	O
(	O
;	O
*	O
s	pointer
!=	O
'\0'	O
;	O
s	pointer
++	O
)	O
add_cmd_char	function
(	O
*	O
s	pointer
)	O
;	O
}	O
int	O
control_line	function
(	O
s	pointer
)	O
char	O
*	O
s	pointer
;	O
{	O
if	O
(	O
PREFIX	O
(	O
s	pointer
,	O
"#line-edit"	pointer
)	O
)	O
{	O
currtable	pointer
=	O
&	O
edittable	struct
;	O
return	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
PREFIX	O
(	O
s	pointer
,	O
"#command"	pointer
)	O
)	O
{	O
currtable	pointer
=	O
&	O
cmdtable	struct
;	O
return	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
PREFIX	O
(	O
s	pointer
,	O
"#env"	pointer
)	O
)	O
{	O
currtable	pointer
=	O
&	O
vartable	struct
;	O
return	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
PREFIX	O
(	O
s	pointer
,	O
"#stop"	pointer
)	O
)	O
{	O
add_cmd_char	function
(	O
'\0'	O
)	O
;	O
add_cmd_char	function
(	O
A_END_LIST	int
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
void	O
fputbytes	function
(	O
fd	int
,	O
buf	pointer
,	O
len	int
)	O
FILE	struct
*	O
fd	int
;	O
char	O
*	O
buf	pointer
;	O
int	O
len	int
;	O
{	O
while	O
(	O
len	int
--	O
>	O
0	int
)	O
{	O
fwrite	function
(	O
buf	pointer
,	O
sizeof	O
(	O
char	O
)	O
,	O
1	int
,	O
fd	int
)	O
;	O
buf	pointer
++	O
;	O
}	O
}	O
void	O
fputint	function
(	O
fd	int
,	O
val	int
)	O
FILE	struct
*	O
fd	int
;	O
unsigned	O
int	O
val	int
;	O
{	O
char	O
c	int
;	O
if	O
(	O
val	int
>=	O
KRADIX	int
*	O
KRADIX	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"error: integer too big (%d > %d)\n"	pointer
,	O
val	int
,	O
KRADIX	int
*	O
KRADIX	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
c	int
=	O
val	int
%	O
KRADIX	int
;	O
fwrite	function
(	O
&	O
c	int
,	O
sizeof	O
(	O
char	O
)	O
,	O
1	int
,	O
fd	int
)	O
;	O
c	int
=	O
val	int
/	O
KRADIX	int
;	O
fwrite	function
(	O
&	O
c	int
,	O
sizeof	O
(	O
char	O
)	O
,	O
1	int
,	O
fd	int
)	O
;	O
}	O
int	O
findaction	function
(	O
actname	pointer
)	O
char	O
*	O
actname	pointer
;	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
currtable	pointer
->	O
names	pointer
[	O
i	int
]	O
.	O
cn_name	pointer
!=	O
NULL	O
;	O
i	int
++	O
)	O
if	O
(	O
strcmp	function
(	O
currtable	pointer
->	O
names	pointer
[	O
i	int
]	O
.	O
cn_name	pointer
,	O
actname	pointer
)	O
==	O
0	int
)	O
return	O
(	O
currtable	pointer
->	O
names	pointer
[	O
i	int
]	O
.	O
cn_action	int
)	O
;	O
error	function
(	O
"unknown action"	pointer
,	O
NULL_PARG	O
)	O
;	O
return	O
(	O
A_INVALID	int
)	O
;	O
}	O
void	O
error	function
(	O
s	pointer
,	O
parg	union
)	O
char	O
*	O
s	pointer
;	O
PARG	union
*	O
parg	union
;	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"line %d: %s\n"	pointer
,	O
linenum	long
,	O
s	pointer
)	O
;	O
errors	int
++	O
;	O
(	O
void	O
)	O
parg	union
;	O
}	O
void	O
parse_cmdline	function
(	O
p	pointer
)	O
char	O
*	O
p	pointer
;	O
{	O
int	O
cmdlen	int
;	O
char	O
*	O
actname	pointer
;	O
int	O
action	int
;	O
char	O
*	O
s	pointer
;	O
char	O
c	int
;	O
cmdlen	int
=	O
0	int
;	O
do	O
{	O
s	pointer
=	O
tstr	function
(	O
&	O
p	pointer
,	O
1	int
)	O
;	O
cmdlen	int
+=	O
(	O
int	O
)	O
strlen	function
(	O
s	pointer
)	O
;	O
if	O
(	O
cmdlen	int
>	O
MAX_CMDLEN	int
)	O
error	function
(	O
"command too long"	pointer
,	O
NULL_PARG	O
)	O
;	O
else	O
add_cmd_str	function
(	O
s	pointer
)	O
;	O
}	O
while	O
(	O
*	O
p	pointer
!=	O
' '	O
&&	O
*	O
p	pointer
!=	O
'\t'	O
&&	O
*	O
p	pointer
!=	O
'\0'	O
)	O
;	O
add_cmd_char	function
(	O
'\0'	O
)	O
;	O
p	pointer
=	O
skipsp	function
(	O
p	pointer
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'\0'	O
)	O
{	O
error	function
(	O
"missing action"	pointer
,	O
NULL_PARG	O
)	O
;	O
return	O
;	O
}	O
actname	pointer
=	O
p	pointer
;	O
p	pointer
=	O
skipnsp	function
(	O
p	pointer
)	O
;	O
c	int
=	O
*	O
p	pointer
;	O
*	O
p	pointer
=	O
'\0'	O
;	O
action	int
=	O
findaction	function
(	O
actname	pointer
)	O
;	O
*	O
p	pointer
=	O
c	int
;	O
p	pointer
=	O
skipsp	function
(	O
p	pointer
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'\0'	O
)	O
{	O
add_cmd_char	function
(	O
action	int
)	O
;	O
}	O
else	O
{	O
add_cmd_char	function
(	O
action	int
|	O
A_EXTRA	int
)	O
;	O
while	O
(	O
*	O
p	pointer
!=	O
'\0'	O
)	O
add_cmd_str	function
(	O
tstr	function
(	O
&	O
p	pointer
,	O
0	int
)	O
)	O
;	O
add_cmd_char	function
(	O
'\0'	O
)	O
;	O
}	O
}	O
void	O
parse_varline	function
(	O
p	pointer
)	O
char	O
*	O
p	pointer
;	O
{	O
char	O
*	O
s	pointer
;	O
do	O
{	O
s	pointer
=	O
tstr	function
(	O
&	O
p	pointer
,	O
0	int
)	O
;	O
add_cmd_str	function
(	O
s	pointer
)	O
;	O
}	O
while	O
(	O
*	O
p	pointer
!=	O
' '	O
&&	O
*	O
p	pointer
!=	O
'\t'	O
&&	O
*	O
p	pointer
!=	O
'='	O
&&	O
*	O
p	pointer
!=	O
'\0'	O
)	O
;	O
add_cmd_char	function
(	O
'\0'	O
)	O
;	O
p	pointer
=	O
skipsp	function
(	O
p	pointer
)	O
;	O
if	O
(	O
*	O
p	pointer
++	O
!=	O
'='	O
)	O
{	O
error	function
(	O
"missing ="	pointer
,	O
NULL_PARG	O
)	O
;	O
return	O
;	O
}	O
add_cmd_char	function
(	O
EV_OK	int
|	O
A_EXTRA	int
)	O
;	O
p	pointer
=	O
skipsp	function
(	O
p	pointer
)	O
;	O
while	O
(	O
*	O
p	pointer
!=	O
'\0'	O
)	O
{	O
s	pointer
=	O
tstr	function
(	O
&	O
p	pointer
,	O
0	int
)	O
;	O
add_cmd_str	function
(	O
s	pointer
)	O
;	O
}	O
add_cmd_char	function
(	O
'\0'	O
)	O
;	O
}	O
void	O
parse_line	function
(	O
line	pointer
)	O
char	O
*	O
line	pointer
;	O
{	O
char	O
*	O
p	pointer
;	O
if	O
(	O
control_line	function
(	O
line	pointer
)	O
)	O
return	O
;	O
p	pointer
=	O
clean_line	function
(	O
line	pointer
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'\0'	O
)	O
return	O
;	O
if	O
(	O
currtable	pointer
==	O
&	O
vartable	struct
)	O
parse_varline	function
(	O
p	pointer
)	O
;	O
else	O
parse_cmdline	function
(	O
p	pointer
)	O
;	O
}	O
int	O
main	function
(	O
argc	int
,	O
argv	pointer
)	O
int	O
argc	int
;	O
char	O
*	O
argv	pointer
[	O
]	O
;	O
{	O
FILE	struct
*	O
desc	pointer
;	O
FILE	struct
*	O
out	pointer
;	O
char	O
line	pointer
[	O
1024	int
]	O
;	O
parse_args	function
(	O
argc	int
,	O
argv	pointer
)	O
;	O
init_tables	function
(	O
)	O
;	O
if	O
(	O
strcmp	function
(	O
infile	pointer
,	O
"-"	pointer
)	O
==	O
0	int
)	O
desc	pointer
=	O
stdin	pointer
;	O
else	O
if	O
(	O
(	O
desc	pointer
=	O
fopen	function
(	O
infile	pointer
,	O
"r"	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
perror	function
(	O
infile	pointer
)	O
;	O
usage	function
(	O
)	O
;	O
}	O
errors	int
=	O
0	int
;	O
linenum	long
=	O
0	int
;	O
while	O
(	O
fgets	function
(	O
line	pointer
,	O
sizeof	O
(	O
line	pointer
)	O
,	O
desc	pointer
)	O
!=	O
NULL	O
)	O
{	O
++	O
linenum	long
;	O
parse_line	function
(	O
line	pointer
)	O
;	O
}	O
if	O
(	O
errors	int
>	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%d errors; no output produced\n"	pointer
,	O
errors	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
outfile	pointer
==	O
NULL	O
)	O
outfile	pointer
=	O
getenv	function
(	O
"LESSKEY"	pointer
)	O
;	O
if	O
(	O
outfile	pointer
==	O
NULL	O
)	O
outfile	pointer
=	O
homefile	function
(	O
LESSKEYFILE	pointer
)	O
;	O
if	O
(	O
(	O
out	pointer
=	O
fopen	function
(	O
outfile	pointer
,	O
"wb"	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
perror	function
(	O
outfile	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
fputbytes	function
(	O
out	pointer
,	O
fileheader	array
,	O
sizeof	O
(	O
fileheader	array
)	O
)	O
;	O
fputbytes	function
(	O
out	pointer
,	O
cmdsection	array
,	O
sizeof	O
(	O
cmdsection	array
)	O
)	O
;	O
fputint	function
(	O
out	pointer
,	O
cmdtable	struct
.	O
pbuffer	pointer
-	O
cmdtable	struct
.	O
buffer	array
)	O
;	O
fputbytes	function
(	O
out	pointer
,	O
(	O
char	O
*	O
)	O
cmdtable	struct
.	O
buffer	array
,	O
cmdtable	struct
.	O
pbuffer	pointer
-	O
cmdtable	struct
.	O
buffer	array
)	O
;	O
fputbytes	function
(	O
out	pointer
,	O
editsection	array
,	O
sizeof	O
(	O
editsection	array
)	O
)	O
;	O
fputint	function
(	O
out	pointer
,	O
edittable	struct
.	O
pbuffer	pointer
-	O
edittable	struct
.	O
buffer	array
)	O
;	O
fputbytes	function
(	O
out	pointer
,	O
(	O
char	O
*	O
)	O
edittable	struct
.	O
buffer	array
,	O
edittable	struct
.	O
pbuffer	pointer
-	O
edittable	struct
.	O
buffer	array
)	O
;	O
fputbytes	function
(	O
out	pointer
,	O
varsection	array
,	O
sizeof	O
(	O
varsection	array
)	O
)	O
;	O
fputint	function
(	O
out	pointer
,	O
vartable	struct
.	O
pbuffer	pointer
-	O
vartable	struct
.	O
buffer	array
)	O
;	O
fputbytes	function
(	O
out	pointer
,	O
(	O
char	O
*	O
)	O
vartable	struct
.	O
buffer	array
,	O
vartable	struct
.	O
pbuffer	pointer
-	O
vartable	struct
.	O
buffer	array
)	O
;	O
fputbytes	function
(	O
out	pointer
,	O
endsection	array
,	O
sizeof	O
(	O
endsection	array
)	O
)	O
;	O
fputbytes	function
(	O
out	pointer
,	O
filetrailer	array
,	O
sizeof	O
(	O
filetrailer	array
)	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
