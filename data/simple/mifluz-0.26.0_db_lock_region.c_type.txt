static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: lock_region.c,v 1.5 2008/06/04 15:01:40 sebdiaz Exp $"	pointer
;	O
static	O
void	O
__lock_dump_locker	function
(	O
DB_LOCKTAB	struct
*	O
,	O
DB_LOCKER	struct
*	O
,	O
FILE	struct
*	O
)	O
;	O
static	O
void	O
__lock_dump_object	function
(	O
DB_LOCKTAB	struct
*	O
,	O
DB_LOCKOBJ	struct
*	O
,	O
FILE	struct
*	O
)	O
;	O
static	O
const	O
char	O
*	O
__lock_dump_status	function
__P	O
(	O
(	O
db_status_t	enum
)	O
)	O
;	O
static	O
int	O
__lock_init	function
__P	O
(	O
(	O
DB_ENV	struct
*	O
,	O
DB_LOCKTAB	struct
*	O
)	O
)	O
;	O
static	O
size_t	long
__lock_region_size	function
__P	O
(	O
(	O
DB_ENV	struct
*	O
)	O
)	O
;	O
static	O
int	O
__lock_set_lk_conflicts	function
__P	O
(	O
(	O
DB_ENV	struct
*	O
,	O
u_int8_t	char
*	O
,	O
int	O
)	O
)	O
;	O
static	O
int	O
__lock_set_lk_detect	function
__P	O
(	O
(	O
DB_ENV	struct
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
int	O
__lock_set_lk_max	function
__P	O
(	O
(	O
DB_ENV	struct
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
u_int8_t	char
const	O
db_cdb_conflicts	array
[	O
]	O
=	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
1	int
}	O
;	O
void	O
CDB___lock_dbenv_create	function
(	O
dbenv	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
{	O
dbenv	pointer
->	O
lk_max	int
=	O
DB_LOCK_DEFAULT_N	int
;	O
dbenv	pointer
->	O
set_lk_conflicts	pointer
=	O
__lock_set_lk_conflicts	function
;	O
dbenv	pointer
->	O
set_lk_detect	pointer
=	O
__lock_set_lk_detect	function
;	O
dbenv	pointer
->	O
set_lk_max	pointer
=	O
__lock_set_lk_max	function
;	O
}	O
void	O
CDB___lock_dbenv_close	function
(	O
dbenv	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
{	O
if	O
(	O
!	O
F_ISSET	O
(	O
dbenv	pointer
,	O
DB_ENV_USER_ALLOC	int
)	O
&&	O
dbenv	pointer
->	O
lk_conflicts	pointer
!=	O
NULL	O
)	O
{	O
CDB___os_free	function
(	O
dbenv	pointer
->	O
lk_conflicts	pointer
,	O
dbenv	pointer
->	O
lk_modes	int
*	O
dbenv	pointer
->	O
lk_modes	int
)	O
;	O
dbenv	pointer
->	O
lk_conflicts	pointer
=	O
NULL	O
;	O
}	O
}	O
static	O
int	O
__lock_set_lk_conflicts	function
(	O
dbenv	pointer
,	O
lk_conflicts	pointer
,	O
lk_modes	int
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
u_int8_t	char
*	O
lk_conflicts	pointer
;	O
int	O
lk_modes	int
;	O
{	O
int	O
ret	int
;	O
ENV_ILLEGAL_AFTER_OPEN	O
(	O
dbenv	pointer
,	O
"set_lk_conflicts"	pointer
)	O
;	O
if	O
(	O
dbenv	pointer
->	O
lk_conflicts	pointer
!=	O
NULL	O
)	O
{	O
CDB___os_free	function
(	O
dbenv	pointer
->	O
lk_conflicts	pointer
,	O
dbenv	pointer
->	O
lk_modes	int
*	O
dbenv	pointer
->	O
lk_modes	int
)	O
;	O
dbenv	pointer
->	O
lk_conflicts	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbenv	pointer
,	O
lk_modes	int
*	O
lk_modes	int
,	O
NULL	O
,	O
&	O
dbenv	pointer
->	O
lk_conflicts	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
memcpy	function
(	O
dbenv	pointer
->	O
lk_conflicts	pointer
,	O
lk_conflicts	pointer
,	O
lk_modes	int
*	O
lk_modes	int
)	O
;	O
dbenv	pointer
->	O
lk_modes	int
=	O
lk_modes	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__lock_set_lk_detect	function
(	O
dbenv	pointer
,	O
lk_detect	int
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
u_int32_t	int
lk_detect	int
;	O
{	O
ENV_ILLEGAL_AFTER_OPEN	O
(	O
dbenv	pointer
,	O
"set_lk_detect"	pointer
)	O
;	O
switch	O
(	O
lk_detect	int
)	O
{	O
case	O
DB_LOCK_DEFAULT	int
:	O
case	O
DB_LOCK_OLDEST	int
:	O
case	O
DB_LOCK_RANDOM	int
:	O
case	O
DB_LOCK_YOUNGEST	int
:	O
break	O
;	O
default	O
:	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
dbenv	pointer
->	O
lk_detect	int
=	O
lk_detect	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__lock_set_lk_max	function
(	O
dbenv	pointer
,	O
lk_max	int
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
u_int32_t	int
lk_max	int
;	O
{	O
ENV_ILLEGAL_AFTER_OPEN	O
(	O
dbenv	pointer
,	O
"set_lk_max"	pointer
)	O
;	O
dbenv	pointer
->	O
lk_max	int
=	O
lk_max	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___lock_open	function
(	O
dbenv	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
{	O
DB_LOCKREGION	struct
*	O
region	pointer
;	O
DB_LOCKTAB	struct
*	O
lt	pointer
;	O
size_t	long
size	int
;	O
int	O
ret	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_calloc	function
(	O
dbenv	pointer
,	O
1	int
,	O
sizeof	O
(	O
DB_LOCKTAB	struct
)	O
,	O
&	O
lt	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
lt	pointer
->	O
dbenv	pointer
=	O
dbenv	pointer
;	O
lt	pointer
->	O
reginfo	pointer
.	O
id	int
=	O
REG_ID_LOCK	int
;	O
lt	pointer
->	O
reginfo	pointer
.	O
mode	enum
=	O
dbenv	pointer
->	O
db_mode	int
;	O
if	O
(	O
F_ISSET	O
(	O
dbenv	pointer
,	O
DB_ENV_CREATE	int
)	O
)	O
F_SET	O
(	O
&	O
lt	pointer
->	O
reginfo	pointer
,	O
REGION_CREATE_OK	int
)	O
;	O
size	int
=	O
__lock_region_size	function
(	O
dbenv	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_r_attach	function
(	O
dbenv	pointer
,	O
&	O
lt	pointer
->	O
reginfo	pointer
,	O
size	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
F_ISSET	O
(	O
&	O
lt	pointer
->	O
reginfo	pointer
,	O
REGION_CREATE	int
)	O
)	O
if	O
(	O
(	O
ret	int
=	O
__lock_init	function
(	O
dbenv	pointer
,	O
lt	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
region	pointer
=	O
lt	pointer
->	O
reginfo	pointer
.	O
primary	int
=	O
R_ADDR	O
(	O
&	O
lt	pointer
->	O
reginfo	pointer
,	O
lt	pointer
->	O
reginfo	pointer
.	O
rp	pointer
->	O
primary	int
)	O
;	O
if	O
(	O
dbenv	pointer
->	O
lk_detect	int
!=	O
DB_LOCK_NORUN	int
)	O
{	O
if	O
(	O
region	pointer
->	O
detect	int
!=	O
DB_LOCK_NORUN	int
&&	O
dbenv	pointer
->	O
lk_detect	int
!=	O
DB_LOCK_DEFAULT	int
&&	O
region	pointer
->	O
detect	int
!=	O
dbenv	pointer
->	O
lk_detect	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"lock_open: incompatible deadlock detector mode"	pointer
)	O
;	O
ret	int
=	O
EINVAL	int
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
region	pointer
->	O
detect	int
==	O
DB_LOCK_NORUN	int
)	O
region	pointer
->	O
detect	int
=	O
dbenv	pointer
->	O
lk_detect	int
;	O
}	O
lt	pointer
->	O
conflicts	pointer
=	O
(	O
u_int8_t	char
*	O
)	O
R_ADDR	O
(	O
&	O
lt	pointer
->	O
reginfo	pointer
,	O
region	pointer
->	O
conf_off	int
)	O
;	O
lt	pointer
->	O
obj_tab	pointer
=	O
(	O
DB_HASHTAB	struct
*	O
)	O
R_ADDR	O
(	O
&	O
lt	pointer
->	O
reginfo	pointer
,	O
region	pointer
->	O
obj_off	int
)	O
;	O
lt	pointer
->	O
locker_tab	pointer
=	O
(	O
DB_HASHTAB	struct
*	O
)	O
R_ADDR	O
(	O
&	O
lt	pointer
->	O
reginfo	pointer
,	O
region	pointer
->	O
locker_off	int
)	O
;	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
&	O
lt	pointer
->	O
reginfo	pointer
)	O
;	O
dbenv	pointer
->	O
lk_handle	pointer
=	O
lt	pointer
;	O
return	O
(	O
0	int
)	O
;	O
err	pointer
:	O
if	O
(	O
lt	pointer
->	O
reginfo	pointer
.	O
addr	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
F_ISSET	O
(	O
&	O
lt	pointer
->	O
reginfo	pointer
,	O
REGION_CREATE	int
)	O
)	O
F_SET	O
(	O
lt	pointer
->	O
reginfo	pointer
.	O
rp	pointer
,	O
REG_DEAD	int
)	O
;	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
&	O
lt	pointer
->	O
reginfo	pointer
)	O
;	O
(	O
void	O
)	O
CDB___db_r_detach	function
(	O
dbenv	pointer
,	O
&	O
lt	pointer
->	O
reginfo	pointer
,	O
0	int
)	O
;	O
}	O
CDB___os_free	function
(	O
lt	pointer
,	O
sizeof	O
(	O
*	O
lt	pointer
)	O
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
;	O
static	O
int	O
__lock_init	function
(	O
dbenv	pointer
,	O
lt	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_LOCKTAB	struct
*	O
lt	pointer
;	O
{	O
const	O
u_int8_t	char
*	O
lk_conflicts	pointer
;	O
struct	O
__db_lock	struct
*	O
lp	pointer
;	O
DB_LOCKER	struct
*	O
lidp	pointer
;	O
DB_LOCKOBJ	struct
*	O
op	enum
;	O
DB_LOCKREGION	struct
*	O
region	pointer
;	O
u_int32_t	int
i	int
,	O
lk_modes	int
,	O
nelements	int
;	O
u_int8_t	char
*	O
addr	pointer
;	O
int	O
ret	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_shalloc	function
(	O
lt	pointer
->	O
reginfo	pointer
.	O
addr	pointer
,	O
sizeof	O
(	O
DB_LOCKREGION	struct
)	O
,	O
0	int
,	O
&	O
lt	pointer
->	O
reginfo	pointer
.	O
primary	int
)	O
)	O
!=	O
0	int
)	O
goto	O
mem_err	O
;	O
lt	pointer
->	O
reginfo	pointer
.	O
rp	pointer
->	O
primary	int
=	O
R_OFFSET	O
(	O
&	O
lt	pointer
->	O
reginfo	pointer
,	O
lt	pointer
->	O
reginfo	pointer
.	O
primary	int
)	O
;	O
region	pointer
=	O
lt	pointer
->	O
reginfo	pointer
.	O
primary	int
;	O
memset	function
(	O
region	pointer
,	O
0	int
,	O
sizeof	O
(	O
*	O
region	pointer
)	O
)	O
;	O
if	O
(	O
dbenv	pointer
->	O
lk_modes	int
==	O
0	int
)	O
if	O
(	O
LOCKING	O
(	O
dbenv	pointer
)	O
)	O
{	O
lk_modes	int
=	O
DB_LOCK_RW_N	int
+	O
1	int
;	O
lk_conflicts	pointer
=	O
db_cdb_conflicts	array
;	O
}	O
else	O
{	O
lk_modes	int
=	O
DB_LOCK_RW_N	int
;	O
lk_conflicts	pointer
=	O
CDB_db_rw_conflicts	array
;	O
}	O
else	O
{	O
lk_modes	int
=	O
dbenv	pointer
->	O
lk_modes	int
;	O
lk_conflicts	pointer
=	O
dbenv	pointer
->	O
lk_conflicts	pointer
;	O
}	O
region	pointer
->	O
id	int
=	O
0	int
;	O
region	pointer
->	O
need_dd	int
=	O
0	int
;	O
region	pointer
->	O
detect	int
=	O
DB_LOCK_NORUN	int
;	O
region	pointer
->	O
maxlocks	int
=	O
dbenv	pointer
->	O
lk_max	int
;	O
region	pointer
->	O
table_size	int
=	O
CDB___db_tablesize	function
(	O
dbenv	pointer
->	O
lk_max	int
)	O
;	O
region	pointer
->	O
nmodes	int
=	O
lk_modes	int
;	O
region	pointer
->	O
nlockers	int
=	O
0	int
;	O
region	pointer
->	O
maxnlockers	int
=	O
0	int
;	O
region	pointer
->	O
nconflicts	int
=	O
0	int
;	O
region	pointer
->	O
nrequests	int
=	O
0	int
;	O
region	pointer
->	O
nreleases	int
=	O
0	int
;	O
region	pointer
->	O
ndeadlocks	int
=	O
0	int
;	O
nelements	int
=	O
region	pointer
->	O
table_size	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_shalloc	function
(	O
lt	pointer
->	O
reginfo	pointer
.	O
addr	pointer
,	O
lk_modes	int
*	O
lk_modes	int
,	O
0	int
,	O
&	O
addr	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
mem_err	O
;	O
memcpy	function
(	O
addr	pointer
,	O
lk_conflicts	pointer
,	O
lk_modes	int
*	O
lk_modes	int
)	O
;	O
region	pointer
->	O
conf_off	int
=	O
R_OFFSET	O
(	O
&	O
lt	pointer
->	O
reginfo	pointer
,	O
addr	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_shalloc	function
(	O
lt	pointer
->	O
reginfo	pointer
.	O
addr	pointer
,	O
nelements	int
*	O
sizeof	O
(	O
DB_HASHTAB	struct
)	O
,	O
0	int
,	O
&	O
addr	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
mem_err	O
;	O
CDB___db_hashinit	function
(	O
addr	pointer
,	O
nelements	int
)	O
;	O
region	pointer
->	O
obj_off	int
=	O
R_OFFSET	O
(	O
&	O
lt	pointer
->	O
reginfo	pointer
,	O
addr	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_shalloc	function
(	O
lt	pointer
->	O
reginfo	pointer
.	O
addr	pointer
,	O
nelements	int
*	O
sizeof	O
(	O
DB_HASHTAB	struct
)	O
,	O
0	int
,	O
&	O
addr	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
mem_err	O
;	O
CDB___db_hashinit	function
(	O
addr	pointer
,	O
nelements	int
)	O
;	O
region	pointer
->	O
locker_off	int
=	O
R_OFFSET	O
(	O
&	O
lt	pointer
->	O
reginfo	pointer
,	O
addr	pointer
)	O
;	O
SH_TAILQ_INIT	O
(	O
&	O
region	pointer
->	O
free_locks	struct
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
region	pointer
->	O
maxlocks	int
;	O
++	O
i	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_shalloc	function
(	O
lt	pointer
->	O
reginfo	pointer
.	O
addr	pointer
,	O
sizeof	O
(	O
struct	O
__db_lock	struct
)	O
,	O
MUTEX_ALIGN	int
,	O
&	O
lp	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
mem_err	O
;	O
lp	pointer
->	O
status	int
=	O
DB_LSTAT_FREE	int
;	O
if	O
(	O
(	O
ret	int
=	O
__db_mutex_init	O
(	O
dbenv	pointer
,	O
&	O
lp	pointer
->	O
mutex	union
,	O
R_OFFSET	O
(	O
&	O
lt	pointer
->	O
reginfo	pointer
,	O
&	O
lp	pointer
->	O
mutex	union
)	O
+	O
DB_FCNTL_OFF_LOCK	O
,	O
MUTEX_SELF_BLOCK	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
MUTEX_LOCK	O
(	O
&	O
lp	pointer
->	O
mutex	union
,	O
lt	pointer
->	O
dbenv	pointer
->	O
lockfhp	pointer
)	O
;	O
SH_TAILQ_INSERT_HEAD	O
(	O
&	O
region	pointer
->	O
free_locks	struct
,	O
lp	pointer
,	O
links	struct
,	O
__db_lock	struct
)	O
;	O
}	O
SH_TAILQ_INIT	O
(	O
&	O
region	pointer
->	O
dd_objs	struct
)	O
;	O
SH_TAILQ_INIT	O
(	O
&	O
region	pointer
->	O
free_objs	struct
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
region	pointer
->	O
maxlocks	int
;	O
++	O
i	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_shalloc	function
(	O
lt	pointer
->	O
reginfo	pointer
.	O
addr	pointer
,	O
sizeof	O
(	O
DB_LOCKOBJ	struct
)	O
,	O
0	int
,	O
&	O
op	enum
)	O
)	O
!=	O
0	int
)	O
goto	O
mem_err	O
;	O
SH_TAILQ_INSERT_HEAD	O
(	O
&	O
region	pointer
->	O
free_objs	struct
,	O
op	enum
,	O
links	struct
,	O
__db_lockobj	struct
)	O
;	O
}	O
SH_TAILQ_INIT	O
(	O
&	O
region	pointer
->	O
free_lockers	struct
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
region	pointer
->	O
maxlocks	int
;	O
++	O
i	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_shalloc	function
(	O
lt	pointer
->	O
reginfo	pointer
.	O
addr	pointer
,	O
sizeof	O
(	O
DB_LOCKER	struct
)	O
,	O
0	int
,	O
&	O
lidp	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
mem_err	O
:	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"Unable to allocate memory for the lock table"	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
SH_TAILQ_INSERT_HEAD	O
(	O
&	O
region	pointer
->	O
free_lockers	struct
,	O
lidp	pointer
,	O
links	struct
,	O
__db_locker	struct
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___lock_close	function
(	O
dbenv	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
{	O
DB_LOCKTAB	struct
*	O
lt	pointer
;	O
int	O
ret	int
;	O
lt	pointer
=	O
dbenv	pointer
->	O
lk_handle	pointer
;	O
ret	int
=	O
CDB___db_r_detach	function
(	O
dbenv	pointer
,	O
&	O
lt	pointer
->	O
reginfo	pointer
,	O
0	int
)	O
;	O
CDB___os_free	function
(	O
lt	pointer
,	O
sizeof	O
(	O
*	O
lt	pointer
)	O
)	O
;	O
dbenv	pointer
->	O
lk_handle	pointer
=	O
NULL	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB_lock_stat	function
(	O
dbenv	pointer
,	O
statp	pointer
,	O
db_malloc	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_LOCK_STAT	struct
*	O
*	O
statp	pointer
;	O
void	O
*	O
(	O
*	O
db_malloc	pointer
)	O
__P	O
(	O
(	O
size_t	long
)	O
)	O
;	O
{	O
DB_LOCKREGION	struct
*	O
region	pointer
;	O
DB_LOCKTAB	struct
*	O
lt	pointer
;	O
DB_LOCK_STAT	struct
*	O
stats	pointer
;	O
int	O
ret	int
;	O
PANIC_CHECK	O
(	O
dbenv	pointer
)	O
;	O
ENV_REQUIRES_CONFIG	O
(	O
dbenv	pointer
,	O
dbenv	pointer
->	O
lk_handle	pointer
,	O
DB_INIT_LOCK	int
)	O
;	O
*	O
statp	pointer
=	O
NULL	O
;	O
lt	pointer
=	O
dbenv	pointer
->	O
lk_handle	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbenv	pointer
,	O
sizeof	O
(	O
*	O
stats	pointer
)	O
,	O
db_malloc	pointer
,	O
&	O
stats	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
R_LOCK	O
(	O
dbenv	pointer
,	O
&	O
lt	pointer
->	O
reginfo	pointer
)	O
;	O
region	pointer
=	O
lt	pointer
->	O
reginfo	pointer
.	O
primary	int
;	O
stats	pointer
->	O
st_lastid	int
=	O
region	pointer
->	O
id	int
;	O
stats	pointer
->	O
st_maxlocks	int
=	O
region	pointer
->	O
maxlocks	int
;	O
stats	pointer
->	O
st_nmodes	int
=	O
region	pointer
->	O
nmodes	int
;	O
stats	pointer
->	O
st_nlockers	int
=	O
region	pointer
->	O
nlockers	int
;	O
stats	pointer
->	O
st_maxnlockers	int
=	O
region	pointer
->	O
maxnlockers	int
;	O
stats	pointer
->	O
st_nconflicts	int
=	O
region	pointer
->	O
nconflicts	int
;	O
stats	pointer
->	O
st_nrequests	int
=	O
region	pointer
->	O
nrequests	int
;	O
stats	pointer
->	O
st_nreleases	int
=	O
region	pointer
->	O
nreleases	int
;	O
stats	pointer
->	O
st_nnowaits	int
=	O
region	pointer
->	O
nnowaits	int
;	O
stats	pointer
->	O
st_ndeadlocks	int
=	O
region	pointer
->	O
ndeadlocks	int
;	O
stats	pointer
->	O
st_region_wait	int
=	O
lt	pointer
->	O
reginfo	pointer
.	O
rp	pointer
->	O
mutex	union
.	O
mutex_set_wait	int
;	O
stats	pointer
->	O
st_region_nowait	int
=	O
lt	pointer
->	O
reginfo	pointer
.	O
rp	pointer
->	O
mutex	union
.	O
mutex_set_nowait	int
;	O
stats	pointer
->	O
st_regsize	int
=	O
lt	pointer
->	O
reginfo	pointer
.	O
rp	pointer
->	O
size	int
;	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
&	O
lt	pointer
->	O
reginfo	pointer
)	O
;	O
*	O
statp	pointer
=	O
stats	pointer
;	O
return	O
(	O
0	int
)	O
;	O
}	O
void	O
CDB___lock_dump_region	function
(	O
dbenv	pointer
,	O
area	pointer
,	O
fp	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
char	O
*	O
area	pointer
;	O
FILE	struct
*	O
fp	pointer
;	O
{	O
struct	O
__db_lock	struct
*	O
lp	pointer
;	O
DB_LOCKER	struct
*	O
lip	pointer
;	O
DB_LOCKOBJ	struct
*	O
op	enum
;	O
DB_LOCKREGION	struct
*	O
lrp	pointer
;	O
DB_LOCKTAB	struct
*	O
lt	pointer
;	O
u_int32_t	int
flags	int
,	O
i	int
,	O
j	int
;	O
int	O
label	int
;	O
if	O
(	O
fp	pointer
==	O
NULL	O
)	O
fp	pointer
=	O
stderr	pointer
;	O
for	O
(	O
flags	int
=	O
0	int
;	O
*	O
area	pointer
!=	O
'\0'	O
;	O
++	O
area	pointer
)	O
switch	O
(	O
*	O
area	pointer
)	O
{	O
case	O
'A'	O
:	O
LF_SET	O
(	O
LOCK_DUMP_ALL	int
)	O
;	O
break	O
;	O
case	O
'c'	O
:	O
LF_SET	O
(	O
LOCK_DUMP_CONF	int
)	O
;	O
break	O
;	O
case	O
'f'	O
:	O
LF_SET	O
(	O
LOCK_DUMP_FREE	int
)	O
;	O
break	O
;	O
case	O
'l'	O
:	O
LF_SET	O
(	O
LOCK_DUMP_LOCKERS	int
)	O
;	O
break	O
;	O
case	O
'm'	O
:	O
LF_SET	O
(	O
LOCK_DUMP_MEM	int
)	O
;	O
break	O
;	O
case	O
'o'	O
:	O
LF_SET	O
(	O
LOCK_DUMP_OBJECTS	int
)	O
;	O
break	O
;	O
}	O
lt	pointer
=	O
dbenv	pointer
->	O
lk_handle	pointer
;	O
lrp	pointer
=	O
lt	pointer
->	O
reginfo	pointer
.	O
primary	int
;	O
LOCKREGION	O
(	O
dbenv	pointer
,	O
lt	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"%s\nLock region parameters\n"	pointer
,	O
DB_LINE	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"%s: %lu, %s: %lu, %s: %lu, %s: %lu, %s: %lu, %s: %lu\n"	pointer
,	O
"table size"	pointer
,	O
(	O
u_long	long
)	O
lrp	pointer
->	O
table_size	int
,	O
"obj_off"	pointer
,	O
(	O
u_long	long
)	O
lrp	pointer
->	O
obj_off	int
,	O
"osynch_off"	pointer
,	O
(	O
u_long	long
)	O
lrp	pointer
->	O
osynch_off	int
,	O
"locker_off"	pointer
,	O
(	O
u_long	long
)	O
lrp	pointer
->	O
locker_off	int
,	O
"lsynch_off"	pointer
,	O
(	O
u_long	long
)	O
lrp	pointer
->	O
lsynch_off	int
,	O
"need_dd"	pointer
,	O
(	O
u_long	long
)	O
lrp	pointer
->	O
need_dd	int
)	O
;	O
if	O
(	O
LF_ISSET	O
(	O
LOCK_DUMP_CONF	int
)	O
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"\n%s\nConflict matrix\n"	pointer
,	O
DB_LINE	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
lrp	pointer
->	O
nmodes	int
;	O
i	int
++	O
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
lrp	pointer
->	O
nmodes	int
;	O
j	int
++	O
)	O
fprintf	function
(	O
fp	pointer
,	O
"%lu\t"	pointer
,	O
(	O
u_long	long
)	O
lt	pointer
->	O
conflicts	pointer
[	O
i	int
*	O
lrp	pointer
->	O
nmodes	int
+	O
j	int
]	O
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
}	O
if	O
(	O
LF_ISSET	O
(	O
LOCK_DUMP_LOCKERS	int
)	O
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"%s\nLocker hash buckets\n"	pointer
,	O
DB_LINE	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
lrp	pointer
->	O
table_size	int
;	O
i	int
++	O
)	O
{	O
label	int
=	O
1	int
;	O
for	O
(	O
lip	pointer
=	O
SH_TAILQ_FIRST	O
(	O
&	O
lt	pointer
->	O
locker_tab	pointer
[	O
i	int
]	O
,	O
__db_locker	struct
)	O
;	O
lip	pointer
!=	O
NULL	O
;	O
lip	pointer
=	O
SH_TAILQ_NEXT	O
(	O
lip	pointer
,	O
links	struct
,	O
__db_locker	struct
)	O
)	O
{	O
if	O
(	O
label	int
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"Bucket %lu:\n"	pointer
,	O
(	O
u_long	long
)	O
i	int
)	O
;	O
label	int
=	O
0	int
;	O
}	O
__lock_dump_locker	function
(	O
lt	pointer
,	O
lip	pointer
,	O
fp	pointer
)	O
;	O
}	O
}	O
}	O
if	O
(	O
LF_ISSET	O
(	O
LOCK_DUMP_OBJECTS	int
)	O
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"%s\nObject hash buckets\n"	pointer
,	O
DB_LINE	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
lrp	pointer
->	O
table_size	int
;	O
i	int
++	O
)	O
{	O
label	int
=	O
1	int
;	O
for	O
(	O
op	enum
=	O
SH_TAILQ_FIRST	O
(	O
&	O
lt	pointer
->	O
obj_tab	pointer
[	O
i	int
]	O
,	O
__db_lockobj	struct
)	O
;	O
op	enum
!=	O
NULL	O
;	O
op	enum
=	O
SH_TAILQ_NEXT	O
(	O
op	enum
,	O
links	struct
,	O
__db_lockobj	struct
)	O
)	O
{	O
if	O
(	O
label	int
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"Bucket %lu:\n"	pointer
,	O
(	O
u_long	long
)	O
i	int
)	O
;	O
label	int
=	O
0	int
;	O
}	O
__lock_dump_object	function
(	O
lt	pointer
,	O
op	enum
,	O
fp	pointer
)	O
;	O
}	O
}	O
}	O
if	O
(	O
LF_ISSET	O
(	O
LOCK_DUMP_FREE	int
)	O
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"%s\nLock free list\n"	pointer
,	O
DB_LINE	pointer
)	O
;	O
for	O
(	O
lp	pointer
=	O
SH_TAILQ_FIRST	O
(	O
&	O
lrp	pointer
->	O
free_locks	struct
,	O
__db_lock	struct
)	O
;	O
lp	pointer
!=	O
NULL	O
;	O
lp	pointer
=	O
SH_TAILQ_NEXT	O
(	O
lp	pointer
,	O
links	struct
,	O
__db_lock	struct
)	O
)	O
fprintf	function
(	O
fp	pointer
,	O
"0x%lx: %lu\t%lu\t%s\t0x%lx\n"	pointer
,	O
(	O
u_long	long
)	O
lp	pointer
,	O
(	O
u_long	long
)	O
lp	pointer
->	O
holder	int
,	O
(	O
u_long	long
)	O
lp	pointer
->	O
mode	enum
,	O
__lock_dump_status	function
(	O
lp	pointer
->	O
status	int
)	O
,	O
(	O
u_long	long
)	O
lp	pointer
->	O
obj	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"%s\nObject free list\n"	pointer
,	O
DB_LINE	pointer
)	O
;	O
for	O
(	O
op	enum
=	O
SH_TAILQ_FIRST	O
(	O
&	O
lrp	pointer
->	O
free_objs	struct
,	O
__db_lockobj	struct
)	O
;	O
op	enum
!=	O
NULL	O
;	O
op	enum
=	O
SH_TAILQ_NEXT	O
(	O
op	enum
,	O
links	struct
,	O
__db_lockobj	struct
)	O
)	O
fprintf	function
(	O
fp	pointer
,	O
"0x%lx\n"	pointer
,	O
(	O
u_long	long
)	O
op	enum
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"%s\nLocker free list\n"	pointer
,	O
DB_LINE	pointer
)	O
;	O
for	O
(	O
lip	pointer
=	O
SH_TAILQ_FIRST	O
(	O
&	O
lrp	pointer
->	O
free_lockers	struct
,	O
__db_locker	struct
)	O
;	O
lip	pointer
!=	O
NULL	O
;	O
lip	pointer
=	O
SH_TAILQ_NEXT	O
(	O
lip	pointer
,	O
links	struct
,	O
__db_locker	struct
)	O
)	O
fprintf	function
(	O
fp	pointer
,	O
"0x%lx\n"	pointer
,	O
(	O
u_long	long
)	O
lip	pointer
)	O
;	O
}	O
if	O
(	O
LF_ISSET	O
(	O
LOCK_DUMP_MEM	int
)	O
)	O
CDB___db_shalloc_dump	function
(	O
lt	pointer
->	O
reginfo	pointer
.	O
addr	pointer
,	O
fp	pointer
)	O
;	O
UNLOCKREGION	O
(	O
dbenv	pointer
,	O
lt	pointer
)	O
;	O
}	O
static	O
void	O
__lock_dump_locker	function
(	O
lt	pointer
,	O
lip	pointer
,	O
fp	pointer
)	O
DB_LOCKTAB	struct
*	O
lt	pointer
;	O
DB_LOCKER	struct
*	O
lip	pointer
;	O
FILE	struct
*	O
fp	pointer
;	O
{	O
struct	O
__db_lock	struct
*	O
lp	pointer
;	O
fprintf	function
(	O
fp	pointer
,	O
"L %lx [%ld]"	pointer
,	O
(	O
u_long	long
)	O
lip	pointer
->	O
id	int
,	O
(	O
long	O
)	O
lip	pointer
->	O
dd_id	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
" %s "	pointer
,	O
F_ISSET	O
(	O
lip	pointer
,	O
DB_LOCKER_DELETED	int
)	O
?	O
"(D)"	pointer
:	O
"   "	pointer
)	O
;	O
if	O
(	O
(	O
lp	pointer
=	O
SH_LIST_FIRST	O
(	O
&	O
lip	pointer
->	O
heldby	struct
,	O
__db_lock	struct
)	O
)	O
==	O
NULL	O
)	O
fprintf	function
(	O
fp	pointer
,	O
"\n"	pointer
)	O
;	O
else	O
for	O
(	O
;	O
lp	pointer
!=	O
NULL	O
;	O
lp	pointer
=	O
SH_LIST_NEXT	O
(	O
lp	pointer
,	O
locker_links	struct
,	O
__db_lock	struct
)	O
)	O
CDB___lock_printlock	function
(	O
lt	pointer
,	O
lp	pointer
,	O
1	int
)	O
;	O
}	O
static	O
void	O
__lock_dump_object	function
(	O
lt	pointer
,	O
op	enum
,	O
fp	pointer
)	O
DB_LOCKTAB	struct
*	O
lt	pointer
;	O
DB_LOCKOBJ	struct
*	O
op	enum
;	O
FILE	struct
*	O
fp	pointer
;	O
{	O
struct	O
__db_lock	struct
*	O
lp	pointer
;	O
u_int32_t	int
j	int
;	O
u_int8_t	char
*	O
ptr	pointer
;	O
u_int	int
ch	int
;	O
ptr	pointer
=	O
SH_DBT_PTR	O
(	O
&	O
op	enum
->	O
lockobj	struct
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
op	enum
->	O
lockobj	struct
.	O
size	int
;	O
ptr	pointer
++	O
,	O
j	int
++	O
)	O
{	O
ch	int
=	O
*	O
ptr	pointer
;	O
fprintf	function
(	O
fp	pointer
,	O
isprint	function
(	O
ch	int
)	O
?	O
"%c"	pointer
:	O
"\\%o"	pointer
,	O
ch	int
)	O
;	O
}	O
fprintf	function
(	O
fp	pointer
,	O
"\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"H:"	pointer
)	O
;	O
for	O
(	O
lp	pointer
=	O
SH_TAILQ_FIRST	O
(	O
&	O
op	enum
->	O
holders	struct
,	O
__db_lock	struct
)	O
;	O
lp	pointer
!=	O
NULL	O
;	O
lp	pointer
=	O
SH_TAILQ_NEXT	O
(	O
lp	pointer
,	O
links	struct
,	O
__db_lock	struct
)	O
)	O
CDB___lock_printlock	function
(	O
lt	pointer
,	O
lp	pointer
,	O
1	int
)	O
;	O
lp	pointer
=	O
SH_TAILQ_FIRST	O
(	O
&	O
op	enum
->	O
waiters	struct
,	O
__db_lock	struct
)	O
;	O
if	O
(	O
lp	pointer
!=	O
NULL	O
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"\nW:"	pointer
)	O
;	O
for	O
(	O
;	O
lp	pointer
!=	O
NULL	O
;	O
lp	pointer
=	O
SH_TAILQ_NEXT	O
(	O
lp	pointer
,	O
links	struct
,	O
__db_lock	struct
)	O
)	O
CDB___lock_printlock	function
(	O
lt	pointer
,	O
lp	pointer
,	O
1	int
)	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
__lock_dump_status	function
(	O
status	int
)	O
db_status_t	enum
status	int
;	O
{	O
switch	O
(	O
status	int
)	O
{	O
case	O
DB_LSTAT_ABORTED	int
:	O
return	O
(	O
"aborted"	pointer
)	O
;	O
case	O
DB_LSTAT_ERR	int
:	O
return	O
(	O
"err"	pointer
)	O
;	O
case	O
DB_LSTAT_FREE	int
:	O
return	O
(	O
"free"	pointer
)	O
;	O
case	O
DB_LSTAT_HELD	int
:	O
return	O
(	O
"held"	pointer
)	O
;	O
case	O
DB_LSTAT_NOGRANT	int
:	O
return	O
(	O
"nogrant"	pointer
)	O
;	O
case	O
DB_LSTAT_PENDING	int
:	O
return	O
(	O
"pending"	pointer
)	O
;	O
case	O
DB_LSTAT_WAITING	int
:	O
return	O
(	O
"waiting"	pointer
)	O
;	O
}	O
return	O
(	O
"unknown status"	pointer
)	O
;	O
}	O
static	O
size_t	long
__lock_region_size	function
(	O
dbenv	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
{	O
size_t	long
retval	long
;	O
u_int32_t	int
i	int
,	O
nelements	int
,	O
nlocks	int
;	O
int	O
gb	int
;	O
gb	int
=	O
0	int
;	O
nlocks	int
=	O
dbenv	pointer
->	O
lk_max	int
;	O
nelements	int
=	O
CDB___db_tablesize	function
(	O
dbenv	pointer
->	O
lk_max	int
)	O
;	O
retval	long
=	O
0	int
;	O
retval	long
+=	O
ALIGN	O
(	O
sizeof	O
(	O
DB_LOCKREGION	struct
)	O
+	O
gb	int
,	O
1	int
)	O
;	O
retval	long
+=	O
ALIGN	O
(	O
dbenv	pointer
->	O
lk_modes	int
*	O
dbenv	pointer
->	O
lk_modes	int
+	O
gb	int
,	O
1	int
)	O
;	O
retval	long
+=	O
ALIGN	O
(	O
nelements	int
*	O
(	O
sizeof	O
(	O
DB_HASHTAB	struct
)	O
+	O
gb	int
)	O
,	O
1	int
)	O
;	O
retval	long
+=	O
ALIGN	O
(	O
nelements	int
*	O
(	O
sizeof	O
(	O
DB_HASHTAB	struct
)	O
+	O
gb	int
)	O
,	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nlocks	int
;	O
++	O
i	int
)	O
retval	long
+=	O
ALIGN	O
(	O
sizeof	O
(	O
struct	O
__db_lock	struct
)	O
+	O
gb	int
,	O
MUTEX_ALIGN	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nlocks	int
;	O
++	O
i	int
)	O
retval	long
+=	O
ALIGN	O
(	O
sizeof	O
(	O
DB_LOCKOBJ	struct
)	O
+	O
gb	int
,	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nlocks	int
;	O
++	O
i	int
)	O
retval	long
+=	O
ALIGN	O
(	O
sizeof	O
(	O
DB_LOCKER	struct
)	O
+	O
gb	int
,	O
1	int
)	O
;	O
retval	long
+=	O
nlocks	int
*	O
(	O
2	int
*	O
sizeof	O
(	O
ssize_t	long
)	O
+	O
sizeof	O
(	O
size_t	long
)	O
)	O
;	O
retval	long
+=	O
ALIGN	O
(	O
nlocks	int
*	O
16	int
,	O
sizeof	O
(	O
size_t	long
)	O
)	O
;	O
retval	long
+=	O
16	int
*	O
1024	int
;	O
return	O
(	O
retval	long
)	O
;	O
}	O
