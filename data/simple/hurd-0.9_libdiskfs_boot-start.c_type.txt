static	O
mach_port_t	O
diskfs_exec_ctl	int
;	O
extern	O
task_t	O
diskfs_exec_server_task	int
;	O
static	O
task_t	O
parent_task	int
=	O
MACH_PORT_NULL	O
;	O
static	O
pthread_mutex_t	O
execstartlock	int
;	O
static	O
pthread_cond_t	O
execstarted	int
;	O
const	O
char	O
*	O
diskfs_boot_init_program	pointer
=	O
_HURD_STARTUP	O
;	O
static	O
void	O
start_execserver	function
(	O
)	O
;	O
char	O
*	O
*	O
diskfs_argv	pointer
=	O
0	int
;	O
static	O
mach_port_t	O
get_console	function
(	O
)	O
{	O
mach_port_t	O
device_master	O
,	O
console	O
;	O
error_t	O
err	O
=	O
get_privileged_ports	function
(	O
0	int
,	O
&	O
device_master	O
)	O
;	O
if	O
(	O
err	O
)	O
return	O
MACH_PORT_NULL	O
;	O
err	O
=	O
device_open	function
(	O
device_master	O
,	O
D_WRITE	O
|	O
D_READ	O
,	O
"console"	pointer
,	O
&	O
console	O
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
device_master	O
)	O
;	O
if	O
(	O
err	O
)	O
return	O
MACH_PORT_NULL	O
;	O
return	O
console	O
;	O
}	O
void	O
_diskfs_boot_privports	function
(	O
void	O
)	O
{	O
assert	function
(	O
diskfs_boot_filesystem	function
(	O
)	O
)	O
;	O
if	O
(	O
_hurd_host_priv	O
==	O
MACH_PORT_NULL	O
)	O
{	O
mach_port_t	O
bootstrap	O
;	O
error_t	O
err	O
=	O
task_get_bootstrap_port	function
(	O
mach_task_self	function
(	O
)	O
,	O
&	O
bootstrap	O
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
err	O
=	O
fsys_getpriv	function
(	O
bootstrap	O
,	O
&	O
_hurd_host_priv	O
,	O
&	O
_hurd_device_master	O
,	O
&	O
parent_task	int
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
bootstrap	O
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
}	O
}	O
void	O
diskfs_start_bootstrap	function
(	O
)	O
{	O
mach_port_t	O
root_pt	O
,	O
startup_pt	O
,	O
bootpt	O
;	O
retry_type	O
retry	enum
;	O
char	O
pathbuf	array
[	O
1024	int
]	O
;	O
string_t	O
retry_name	O
;	O
mach_port_t	O
portarray	O
[	O
INIT_PORT_MAX	O
]	O
;	O
mach_port_t	O
fdarray	O
[	O
3	int
]	O
;	O
task_t	O
newt	O
;	O
error_t	O
err	O
;	O
char	O
*	O
exec_argv	pointer
,	O
*	O
exec_env	pointer
;	O
const	O
char	O
*	O
initname	pointer
;	O
size_t	O
exec_argvlen	O
,	O
exec_envlen	O
;	O
struct	O
port_info	O
*	O
bootinfo	pointer
;	O
struct	O
protid	O
*	O
rootpi	pointer
;	O
struct	O
peropen	O
*	O
rootpo	pointer
;	O
mach_port_t	O
diskfs_exec	O
;	O
unsigned	O
int	O
init_lookups	int
=	O
0	int
;	O
err	O
=	O
diskfs_make_peropen	function
(	O
diskfs_root_node	O
,	O
O_READ	O
|	O
O_EXEC	O
,	O
0	int
,	O
&	O
rootpo	pointer
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
err	O
=	O
diskfs_create_protid	function
(	O
rootpo	pointer
,	O
0	int
,	O
&	O
rootpi	pointer
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
root_pt	O
=	O
ports_get_send_right	function
(	O
rootpi	pointer
)	O
;	O
ports_port_deref	function
(	O
rootpi	pointer
)	O
;	O
if	O
(	O
diskfs_exec_server_task	int
==	O
MACH_PORT_NULL	O
)	O
{	O
assert	function
(	O
_hurd_ports	O
)	O
;	O
assert	function
(	O
_hurd_ports	O
[	O
INIT_PORT_CRDIR	O
]	O
.	O
port	int
!=	O
MACH_PORT_NULL	O
)	O
;	O
diskfs_exec	O
=	O
file_name_lookup	function
(	O
_SERVERS_EXEC	O
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
diskfs_exec	O
==	O
MACH_PORT_NULL	O
)	O
error	function
(	O
1	int
,	O
errno	O
,	O
"%s"	pointer
,	O
_SERVERS_EXEC	O
)	O
;	O
else	O
{	O
struct	O
port_info	O
*	O
pi	pointer
=	O
ports_lookup_port	function
(	O
diskfs_port_bucket	O
,	O
diskfs_exec	O
,	O
0	int
)	O
;	O
assert	function
(	O
!	O
pi	pointer
)	O
;	O
}	O
printf	O
(	O
"\nContinuing on new root filesystem %s:"	pointer
,	O
diskfs_disk_name	O
)	O
;	O
fflush	function
(	O
stdout	O
)	O
;	O
}	O
else	O
{	O
uid_t	O
idlist	O
[	O
]	O
=	O
{	O
0	int
,	O
0	int
,	O
0	int
}	O
;	O
file_t	O
execnode	O
;	O
printf	O
(	O
"Hurd server bootstrap: %s[%s]"	pointer
,	O
program_invocation_short_name	O
,	O
diskfs_disk_name	O
)	O
;	O
fflush	function
(	O
stdout	O
)	O
;	O
pthread_mutex_init	function
(	O
&	O
execstartlock	int
,	O
NULL	O
)	O
;	O
pthread_cond_init	function
(	O
&	O
execstarted	int
,	O
NULL	O
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
execstartlock	int
)	O
;	O
start_execserver	function
(	O
)	O
;	O
pthread_cond_wait	function
(	O
&	O
execstarted	int
,	O
&	O
execstartlock	int
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
execstartlock	int
)	O
;	O
assert	function
(	O
diskfs_exec_ctl	int
!=	O
MACH_PORT_NULL	O
)	O
;	O
err	O
=	O
fsys_getroot	function
(	O
diskfs_exec_ctl	int
,	O
root_pt	O
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
idlist	O
,	O
3	int
,	O
idlist	O
,	O
3	int
,	O
0	int
,	O
&	O
retry	enum
,	O
retry_name	O
,	O
&	O
diskfs_exec	O
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
assert	function
(	O
retry	enum
==	O
FS_RETRY_NORMAL	O
)	O
;	O
assert	function
(	O
retry_name	O
[	O
0	int
]	O
==	O
'\0'	O
)	O
;	O
assert	function
(	O
diskfs_exec	O
!=	O
MACH_PORT_NULL	O
)	O
;	O
err	O
=	O
dir_lookup	function
(	O
root_pt	O
,	O
_SERVERS_EXEC	O
,	O
O_NOTRANS	O
,	O
0	int
,	O
&	O
retry	enum
,	O
retry_name	O
,	O
&	O
execnode	O
)	O
;	O
if	O
(	O
err	O
)	O
{	O
error	function
(	O
0	int
,	O
err	O
,	O
"cannot set translator on %s"	pointer
,	O
_SERVERS_EXEC	O
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
diskfs_exec_ctl	int
)	O
;	O
}	O
else	O
{	O
assert	function
(	O
retry	enum
==	O
FS_RETRY_NORMAL	O
)	O
;	O
assert	function
(	O
retry_name	O
[	O
0	int
]	O
==	O
'\0'	O
)	O
;	O
assert	function
(	O
execnode	O
!=	O
MACH_PORT_NULL	O
)	O
;	O
err	O
=	O
file_set_translator	function
(	O
execnode	O
,	O
0	int
,	O
FS_TRANS_SET	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
diskfs_exec_ctl	int
,	O
MACH_MSG_TYPE_COPY_SEND	O
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
diskfs_exec_ctl	int
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
execnode	O
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
}	O
diskfs_exec_ctl	int
=	O
MACH_PORT_NULL	O
;	O
}	O
_hurd_port_set	function
(	O
&	O
_diskfs_exec_portcell	struct
,	O
diskfs_exec	O
)	O
;	O
if	O
(	O
_diskfs_boot_command	pointer
)	O
{	O
err	O
=	O
argz_create	function
(	O
_diskfs_boot_command	pointer
,	O
&	O
exec_argv	pointer
,	O
&	O
exec_argvlen	O
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
initname	pointer
=	O
exec_argv	pointer
;	O
while	O
(	O
*	O
initname	pointer
==	O
'/'	O
)	O
initname	pointer
++	O
;	O
}	O
else	O
{	O
initname	pointer
=	O
diskfs_boot_init_program	pointer
;	O
while	O
(	O
*	O
initname	pointer
==	O
'/'	O
)	O
initname	pointer
++	O
;	O
int	O
len	int
=	O
asprintf	function
(	O
&	O
exec_argv	pointer
,	O
"/%s%c"	pointer
,	O
initname	pointer
,	O
'\0'	O
)	O
;	O
assert	function
(	O
len	int
!=	O
-	O
1	int
)	O
;	O
exec_argvlen	O
=	O
(	O
size_t	O
)	O
len	int
;	O
err	O
=	O
argz_add_sep	function
(	O
&	O
exec_argv	pointer
,	O
&	O
exec_argvlen	O
,	O
diskfs_boot_command_line	O
,	O
' '	O
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
initname	pointer
=	O
exec_argv	pointer
+	O
1	int
;	O
}	O
lookup_init	O
:	O
err	O
=	O
dir_lookup	function
(	O
root_pt	O
,	O
(	O
char	O
*	O
)	O
initname	pointer
,	O
O_READ	O
,	O
0	int
,	O
&	O
retry	enum
,	O
pathbuf	array
,	O
&	O
startup_pt	O
)	O
;	O
init_lookups	int
++	O
;	O
if	O
(	O
err	O
)	O
{	O
printf	O
(	O
"\nCannot find startup program `%s': %s\n"	pointer
,	O
initname	pointer
,	O
strerror	O
(	O
err	O
)	O
)	O
;	O
fflush	function
(	O
stdout	O
)	O
;	O
free	function
(	O
exec_argv	pointer
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
}	O
else	O
if	O
(	O
retry	enum
==	O
FS_RETRY_MAGICAL	O
&&	O
pathbuf	array
[	O
0	int
]	O
==	O
'/'	O
)	O
{	O
assert	function
(	O
sysconf	function
(	O
_SC_SYMLOOP_MAX	O
)	O
<	O
0	int
||	O
init_lookups	int
<	O
sysconf	function
(	O
_SC_SYMLOOP_MAX	O
)	O
)	O
;	O
initname	pointer
=	O
strdupa	function
(	O
pathbuf	array
)	O
;	O
goto	O
lookup_init	O
;	O
}	O
assert	function
(	O
retry	enum
==	O
FS_RETRY_NORMAL	O
)	O
;	O
assert	function
(	O
pathbuf	array
[	O
0	int
]	O
==	O
'\0'	O
)	O
;	O
err	O
=	O
ports_create_port	function
(	O
diskfs_initboot_class	O
,	O
diskfs_port_bucket	O
,	O
sizeof	O
(	O
struct	O
port_info	O
)	O
,	O
&	O
bootinfo	pointer
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
bootpt	O
=	O
ports_get_send_right	function
(	O
bootinfo	pointer
)	O
;	O
ports_port_deref	function
(	O
bootinfo	pointer
)	O
;	O
portarray	O
[	O
INIT_PORT_CRDIR	O
]	O
=	O
root_pt	O
;	O
portarray	O
[	O
INIT_PORT_CWDIR	O
]	O
=	O
root_pt	O
;	O
portarray	O
[	O
INIT_PORT_AUTH	O
]	O
=	O
MACH_PORT_NULL	O
;	O
portarray	O
[	O
INIT_PORT_PROC	O
]	O
=	O
MACH_PORT_NULL	O
;	O
portarray	O
[	O
INIT_PORT_CTTYID	O
]	O
=	O
MACH_PORT_NULL	O
;	O
portarray	O
[	O
INIT_PORT_BOOTSTRAP	O
]	O
=	O
bootpt	O
;	O
fdarray	O
[	O
0	int
]	O
=	O
fdarray	O
[	O
1	int
]	O
=	O
fdarray	O
[	O
2	int
]	O
=	O
get_console	function
(	O
)	O
;	O
err	O
=	O
argz_create	function
(	O
environ	O
,	O
&	O
exec_env	pointer
,	O
&	O
exec_envlen	O
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
err	O
=	O
task_create	function
(	O
mach_task_self	function
(	O
)	O
,	O
0	int
,	O
&	O
newt	O
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
if	O
(	O
_diskfs_boot_pause	O
)	O
{	O
printf	O
(	O
"pausing for %s...\n"	pointer
,	O
exec_argv	pointer
)	O
;	O
fflush	function
(	O
stdout	O
)	O
;	O
getc	function
(	O
stdin	O
)	O
;	O
}	O
printf	O
(	O
" %s"	pointer
,	O
basename	function
(	O
exec_argv	pointer
)	O
)	O
;	O
fflush	function
(	O
stdout	O
)	O
;	O
err	O
=	O
exec_exec	function
(	O
diskfs_exec	O
,	O
startup_pt	O
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
newt	O
,	O
0	int
,	O
exec_argv	pointer
,	O
exec_argvlen	O
,	O
exec_env	pointer
,	O
exec_envlen	O
,	O
fdarray	O
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
3	int
,	O
portarray	O
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
INIT_PORT_MAX	O
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
err	O
)	O
error	function
(	O
1	int
,	O
err	O
,	O
"Executing '%s'"	pointer
,	O
exec_argv	pointer
)	O
;	O
free	function
(	O
exec_argv	pointer
)	O
;	O
free	function
(	O
exec_env	pointer
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
root_pt	O
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
startup_pt	O
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
bootpt	O
)	O
;	O
}	O
kern_return_t	O
diskfs_S_exec_startup_get_info	function
(	O
struct	O
bootinfo	pointer
*	O
upt	pointer
,	O
vm_address_t	O
*	O
user_entry	pointer
,	O
vm_address_t	O
*	O
phdr_data	pointer
,	O
vm_size_t	O
*	O
phdr_size	pointer
,	O
vm_address_t	O
*	O
base_addr	pointer
,	O
vm_size_t	O
*	O
stack_size	pointer
,	O
int	O
*	O
flags	pointer
,	O
char	O
*	O
*	O
argvP	pointer
,	O
mach_msg_type_number_t	O
*	O
argvlen	pointer
,	O
char	O
*	O
*	O
envpP	pointer
__attribute__	O
(	O
(	O
unused	O
)	O
)	O
,	O
mach_msg_type_number_t	O
*	O
envplen	pointer
,	O
mach_port_t	O
*	O
*	O
dtableP	pointer
,	O
mach_msg_type_name_t	O
*	O
dtablepoly	pointer
,	O
mach_msg_type_number_t	O
*	O
dtablelen	pointer
,	O
mach_port_t	O
*	O
*	O
portarrayP	pointer
,	O
mach_msg_type_name_t	O
*	O
portarraypoly	pointer
,	O
mach_msg_type_number_t	O
*	O
portarraylen	pointer
,	O
int	O
*	O
*	O
intarrayP	pointer
,	O
mach_msg_type_number_t	O
*	O
intarraylen	pointer
)	O
{	O
error_t	O
err	O
;	O
mach_port_t	O
*	O
portarray	O
,	O
*	O
dtable	O
;	O
mach_port_t	O
rootport	O
;	O
struct	O
protid	O
*	O
rootpi	pointer
;	O
struct	O
peropen	O
*	O
rootpo	pointer
;	O
if	O
(	O
!	O
upt	pointer
)	O
return	O
EOPNOTSUPP	O
;	O
*	O
user_entry	pointer
=	O
0	int
;	O
*	O
phdr_data	pointer
=	O
*	O
base_addr	pointer
=	O
0	int
;	O
*	O
phdr_size	pointer
=	O
*	O
stack_size	pointer
=	O
0	int
;	O
*	O
argvlen	pointer
=	O
*	O
envplen	pointer
=	O
0	int
;	O
*	O
flags	pointer
=	O
EXEC_STACK_ARGS	O
;	O
if	O
(	O
*	O
portarraylen	pointer
<	O
INIT_PORT_MAX	O
)	O
*	O
portarrayP	pointer
=	O
mmap	function
(	O
0	int
,	O
INIT_PORT_MAX	O
*	O
sizeof	O
(	O
mach_port_t	O
)	O
,	O
PROT_READ	O
|	O
PROT_WRITE	O
,	O
MAP_ANON	O
,	O
0	int
,	O
0	int
)	O
;	O
portarray	O
=	O
*	O
portarrayP	pointer
;	O
*	O
portarraylen	pointer
=	O
INIT_PORT_MAX	O
;	O
if	O
(	O
*	O
dtablelen	pointer
<	O
3	int
)	O
*	O
dtableP	pointer
=	O
mmap	function
(	O
0	int
,	O
3	int
*	O
sizeof	O
(	O
mach_port_t	O
)	O
,	O
PROT_READ	O
|	O
PROT_WRITE	O
,	O
MAP_ANON	O
,	O
0	int
,	O
0	int
)	O
;	O
dtable	O
=	O
*	O
dtableP	pointer
;	O
*	O
dtablelen	pointer
=	O
3	int
;	O
dtable	O
[	O
0	int
]	O
=	O
dtable	O
[	O
1	int
]	O
=	O
dtable	O
[	O
2	int
]	O
=	O
get_console	function
(	O
)	O
;	O
*	O
intarrayP	pointer
=	O
NULL	O
;	O
*	O
intarraylen	pointer
=	O
0	int
;	O
err	O
=	O
diskfs_make_peropen	function
(	O
diskfs_root_node	O
,	O
O_READ	O
|	O
O_EXEC	O
,	O
0	int
,	O
&	O
rootpo	pointer
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
err	O
=	O
diskfs_create_protid	function
(	O
rootpo	pointer
,	O
0	int
,	O
&	O
rootpi	pointer
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
rootport	O
=	O
ports_get_right	function
(	O
rootpi	pointer
)	O
;	O
ports_port_deref	function
(	O
rootpi	pointer
)	O
;	O
portarray	O
[	O
INIT_PORT_CWDIR	O
]	O
=	O
rootport	O
;	O
portarray	O
[	O
INIT_PORT_CRDIR	O
]	O
=	O
rootport	O
;	O
portarray	O
[	O
INIT_PORT_AUTH	O
]	O
=	O
MACH_PORT_NULL	O
;	O
portarray	O
[	O
INIT_PORT_PROC	O
]	O
=	O
MACH_PORT_NULL	O
;	O
portarray	O
[	O
INIT_PORT_CTTYID	O
]	O
=	O
MACH_PORT_NULL	O
;	O
portarray	O
[	O
INIT_PORT_BOOTSTRAP	O
]	O
=	O
upt	pointer
->	O
pi	pointer
.	O
port_right	O
;	O
*	O
portarraypoly	pointer
=	O
MACH_MSG_TYPE_MAKE_SEND	O
;	O
*	O
dtablepoly	pointer
=	O
MACH_MSG_TYPE_COPY_SEND	O
;	O
return	O
0	int
;	O
}	O
error_t	O
diskfs_execboot_fsys_startup	function
(	O
mach_port_t	O
port	int
,	O
int	O
flags	pointer
,	O
mach_port_t	O
ctl	int
,	O
mach_port_t	O
*	O
real	pointer
,	O
mach_msg_type_name_t	O
*	O
realpoly	pointer
)	O
{	O
error_t	O
err	O
;	O
string_t	O
pathbuf	array
;	O
enum	O
retry_type	O
retry	enum
;	O
struct	O
port_info	O
*	O
pt	pointer
;	O
struct	O
protid	O
*	O
rootpi	pointer
;	O
struct	O
peropen	O
*	O
rootpo	pointer
;	O
mach_port_t	O
rootport	O
;	O
if	O
(	O
!	O
(	O
pt	pointer
=	O
ports_lookup_port	function
(	O
diskfs_port_bucket	O
,	O
port	int
,	O
diskfs_execboot_class	O
)	O
)	O
)	O
return	O
EOPNOTSUPP	O
;	O
err	O
=	O
diskfs_make_peropen	function
(	O
diskfs_root_node	O
,	O
flags	pointer
,	O
0	int
,	O
&	O
rootpo	pointer
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
err	O
=	O
diskfs_create_protid	function
(	O
rootpo	pointer
,	O
0	int
,	O
&	O
rootpi	pointer
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
rootport	O
=	O
ports_get_send_right	function
(	O
rootpi	pointer
)	O
;	O
ports_port_deref	function
(	O
rootpi	pointer
)	O
;	O
err	O
=	O
dir_lookup	function
(	O
rootport	O
,	O
_SERVERS_EXEC	O
,	O
flags	pointer
|	O
O_NOTRANS	O
,	O
0	int
,	O
&	O
retry	enum
,	O
pathbuf	array
,	O
real	pointer
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
assert	function
(	O
retry	enum
==	O
FS_RETRY_NORMAL	O
)	O
;	O
assert	function
(	O
pathbuf	array
[	O
0	int
]	O
==	O
'\0'	O
)	O
;	O
*	O
realpoly	pointer
=	O
MACH_MSG_TYPE_MOVE_SEND	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
rootport	O
)	O
;	O
diskfs_exec_ctl	int
=	O
ctl	int
;	O
pthread_mutex_lock	function
(	O
&	O
execstartlock	int
)	O
;	O
pthread_cond_signal	function
(	O
&	O
execstarted	int
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
execstartlock	int
)	O
;	O
ports_port_deref	function
(	O
pt	pointer
)	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
diskfs_S_fsys_getpriv	function
(	O
struct	O
diskfs_control	O
*	O
init_bootstrap_port	pointer
,	O
mach_port_t	O
reply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
mach_port_t	O
*	O
host_priv	pointer
,	O
mach_msg_type_name_t	O
*	O
hp_type	pointer
,	O
mach_port_t	O
*	O
dev_master	pointer
,	O
mach_msg_type_name_t	O
*	O
dm_type	pointer
,	O
mach_port_t	O
*	O
fstask	pointer
,	O
mach_msg_type_name_t	O
*	O
task_type	pointer
)	O
{	O
error_t	O
err	O
;	O
if	O
(	O
!	O
init_bootstrap_port	pointer
||	O
init_bootstrap_port	pointer
->	O
pi	pointer
.	O
class	O
!=	O
diskfs_initboot_class	O
)	O
return	O
EOPNOTSUPP	O
;	O
err	O
=	O
get_privileged_ports	function
(	O
host_priv	pointer
,	O
dev_master	pointer
)	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
*	O
fstask	pointer
=	O
mach_task_self	function
(	O
)	O
;	O
*	O
hp_type	pointer
=	O
*	O
dm_type	pointer
=	O
MACH_MSG_TYPE_MOVE_SEND	O
;	O
*	O
task_type	pointer
=	O
MACH_MSG_TYPE_COPY_SEND	O
;	O
}	O
return	O
err	O
;	O
}	O
kern_return_t	O
diskfs_S_fsys_init	function
(	O
struct	O
diskfs_control	O
*	O
pt	pointer
,	O
mach_port_t	O
reply	int
,	O
mach_msg_type_name_t	O
replytype	int
,	O
mach_port_t	O
procserver	int
,	O
mach_port_t	O
authhandle	int
)	O
{	O
static	O
int	O
initdone	int
=	O
0	int
;	O
mach_port_t	O
host	O
,	O
startup	O
;	O
error_t	O
err	O
;	O
mach_port_t	O
root_pt	O
;	O
struct	O
protid	O
*	O
rootpi	pointer
;	O
struct	O
peropen	O
*	O
rootpo	pointer
;	O
if	O
(	O
!	O
pt	pointer
||	O
pt	pointer
->	O
pi	pointer
.	O
class	O
!=	O
diskfs_initboot_class	O
)	O
return	O
EOPNOTSUPP	O
;	O
if	O
(	O
initdone	int
)	O
return	O
EOPNOTSUPP	O
;	O
initdone	int
=	O
1	int
;	O
fsys_init_reply	function
(	O
reply	int
,	O
replytype	int
,	O
0	int
)	O
;	O
err	O
=	O
mach_port_mod_refs	function
(	O
mach_task_self	function
(	O
)	O
,	O
procserver	int
,	O
MACH_PORT_RIGHT_SEND	O
,	O
+	O
1	int
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
err	O
=	O
mach_port_mod_refs	function
(	O
mach_task_self	function
(	O
)	O
,	O
authhandle	int
,	O
MACH_PORT_RIGHT_SEND	O
,	O
+	O
1	int
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
if	O
(	O
diskfs_auth_server_port	O
!=	O
MACH_PORT_NULL	O
)	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
diskfs_auth_server_port	O
)	O
;	O
diskfs_auth_server_port	O
=	O
authhandle	int
;	O
if	O
(	O
diskfs_exec_server_task	int
!=	O
MACH_PORT_NULL	O
)	O
{	O
process_t	O
execprocess	O
;	O
err	O
=	O
proc_task2proc	function
(	O
procserver	int
,	O
diskfs_exec_server_task	int
,	O
&	O
execprocess	O
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
proc_child	function
(	O
procserver	int
,	O
diskfs_exec_server_task	int
)	O
;	O
proc_mark_exec	function
(	O
execprocess	O
)	O
;	O
HURD_PORT_USE	function
(	O
&	O
_diskfs_exec_portcell	struct
,	O
exec_init	function
(	O
port	int
,	O
authhandle	int
,	O
execprocess	O
,	O
MACH_MSG_TYPE_COPY_SEND	O
)	O
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
execprocess	O
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
diskfs_exec_server_task	int
)	O
;	O
diskfs_exec_server_task	int
=	O
MACH_PORT_NULL	O
;	O
}	O
else	O
{	O
mach_port_t	O
bootstrap	O
;	O
process_t	O
parent_proc	O
;	O
assert	function
(	O
parent_task	int
!=	O
MACH_PORT_NULL	O
)	O
;	O
err	O
=	O
proc_child	function
(	O
procserver	int
,	O
parent_task	int
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
err	O
=	O
proc_task2proc	function
(	O
procserver	int
,	O
parent_task	int
,	O
&	O
parent_proc	O
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
parent_task	int
)	O
;	O
parent_task	int
=	O
MACH_PORT_NULL	O
;	O
proc_mark_exec	function
(	O
parent_proc	O
)	O
;	O
err	O
=	O
task_get_bootstrap_port	function
(	O
mach_task_self	function
(	O
)	O
,	O
&	O
bootstrap	O
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
err	O
=	O
fsys_init	function
(	O
bootstrap	O
,	O
parent_proc	O
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
authhandle	int
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
parent_proc	O
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
bootstrap	O
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
}	O
err	O
=	O
diskfs_make_peropen	function
(	O
diskfs_root_node	O
,	O
O_READ	O
|	O
O_EXEC	O
,	O
0	int
,	O
&	O
rootpo	pointer
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
err	O
=	O
diskfs_create_protid	function
(	O
rootpo	pointer
,	O
0	int
,	O
&	O
rootpi	pointer
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
root_pt	O
=	O
ports_get_send_right	function
(	O
rootpi	pointer
)	O
;	O
ports_port_deref	function
(	O
rootpi	pointer
)	O
;	O
mach_port_mod_refs	function
(	O
mach_task_self	function
(	O
)	O
,	O
root_pt	O
,	O
MACH_PORT_RIGHT_SEND	O
,	O
+	O
1	int
)	O
;	O
if	O
(	O
_hurd_ports	O
)	O
{	O
_hurd_port_set	function
(	O
&	O
_hurd_ports	O
[	O
INIT_PORT_PROC	O
]	O
,	O
procserver	int
)	O
;	O
_hurd_port_set	function
(	O
&	O
_hurd_ports	O
[	O
INIT_PORT_AUTH	O
]	O
,	O
authhandle	int
)	O
;	O
_hurd_port_set	function
(	O
&	O
_hurd_ports	O
[	O
INIT_PORT_CRDIR	O
]	O
,	O
root_pt	O
)	O
;	O
_hurd_port_set	function
(	O
&	O
_hurd_ports	O
[	O
INIT_PORT_CWDIR	O
]	O
,	O
root_pt	O
)	O
;	O
_hurd_proc_init	function
(	O
diskfs_argv	pointer
,	O
NULL	O
,	O
0	int
)	O
;	O
}	O
else	O
{	O
mach_port_t	O
*	O
portarray	O
;	O
unsigned	O
int	O
i	int
;	O
portarray	O
=	O
mmap	function
(	O
0	int
,	O
INIT_PORT_MAX	O
*	O
sizeof	O
*	O
portarray	O
,	O
PROT_READ	O
|	O
PROT_WRITE	O
,	O
MAP_ANON	O
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
MACH_PORT_NULL	O
!=	O
(	O
mach_port_t	O
)	O
0	int
)	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
INIT_PORT_MAX	O
;	O
++	O
i	int
)	O
portarray	O
[	O
i	int
]	O
=	O
MACH_PORT_NULL	O
;	O
portarray	O
[	O
INIT_PORT_PROC	O
]	O
=	O
procserver	int
;	O
portarray	O
[	O
INIT_PORT_AUTH	O
]	O
=	O
authhandle	int
;	O
portarray	O
[	O
INIT_PORT_CRDIR	O
]	O
=	O
root_pt	O
;	O
portarray	O
[	O
INIT_PORT_CWDIR	O
]	O
=	O
root_pt	O
;	O
_hurd_init	function
(	O
0	int
,	O
diskfs_argv	pointer
,	O
portarray	O
,	O
INIT_PORT_MAX	O
,	O
NULL	O
,	O
0	int
)	O
;	O
}	O
err	O
=	O
get_privileged_ports	function
(	O
&	O
host	O
,	O
0	int
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
proc_register_version	function
(	O
procserver	int
,	O
host	O
,	O
diskfs_server_name	O
,	O
""	pointer
,	O
diskfs_server_version	O
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
procserver	int
)	O
;	O
startup	O
=	O
file_name_lookup	function
(	O
_SERVERS_STARTUP	O
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
startup	O
==	O
MACH_PORT_NULL	O
)	O
error	function
(	O
0	int
,	O
errno	O
,	O
"%s"	pointer
,	O
_SERVERS_STARTUP	O
)	O
;	O
else	O
{	O
startup_essential_task	function
(	O
startup	O
,	O
mach_task_self	function
(	O
)	O
,	O
MACH_PORT_NULL	O
,	O
diskfs_server_name	O
,	O
host	O
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
startup	O
)	O
;	O
}	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
host	O
)	O
;	O
_diskfs_init_completed	function
(	O
)	O
;	O
return	O
MIG_NO_REPLY	O
;	O
}	O
static	O
void	O
start_execserver	function
(	O
void	O
)	O
{	O
error_t	O
err	O
;	O
mach_port_t	O
right	O
;	O
extern	O
task_t	O
diskfs_exec_server_task	int
;	O
struct	O
port_info	O
*	O
execboot_info	pointer
;	O
assert	function
(	O
diskfs_exec_server_task	int
!=	O
MACH_PORT_NULL	O
)	O
;	O
err	O
=	O
ports_create_port	function
(	O
diskfs_execboot_class	O
,	O
diskfs_port_bucket	O
,	O
sizeof	O
(	O
struct	O
port_info	O
)	O
,	O
&	O
execboot_info	pointer
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
right	O
=	O
ports_get_send_right	function
(	O
execboot_info	pointer
)	O
;	O
ports_port_deref	function
(	O
execboot_info	pointer
)	O
;	O
err	O
=	O
task_set_special_port	function
(	O
diskfs_exec_server_task	int
,	O
TASK_BOOTSTRAP_PORT	O
,	O
right	O
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
err	O
=	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
right	O
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
if	O
(	O
_diskfs_boot_pause	O
)	O
{	O
printf	O
(	O
"pausing for exec\n"	pointer
)	O
;	O
fflush	function
(	O
stdout	O
)	O
;	O
getc	function
(	O
stdin	O
)	O
;	O
}	O
err	O
=	O
task_resume	function
(	O
diskfs_exec_server_task	int
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
printf	O
(	O
" exec"	pointer
)	O
;	O
fflush	function
(	O
stdout	O
)	O
;	O
}	O
