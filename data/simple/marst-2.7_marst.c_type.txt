static	O
char	O
*	O
version	pointer
=	O
"MARST -- Algol-to-C Translator, Version 2.7"	pointer
;	O
static	O
char	O
*	O
infilename	pointer
=	O
""	pointer
;	O
static	O
FILE	struct
*	O
infile	pointer
;	O
static	O
char	O
*	O
outfilename	pointer
=	O
""	pointer
;	O
static	O
FILE	struct
*	O
outfile	pointer
;	O
static	O
int	O
debug	int
=	O
0	int
;	O
static	O
int	O
errmax	int
=	O
0	int
;	O
static	O
int	O
warn	int
=	O
1	int
;	O
static	O
int	O
width	int
=	O
72	int
;	O
static	O
int	O
time_stamp	int
=	O
1	int
;	O
static	O
int	O
first_pass	int
;	O
static	O
int	O
second_pass	int
;	O
static	O
int	O
e_count	int
=	O
0	int
;	O
static	O
int	O
w_count	int
=	O
0	int
;	O
static	O
int	O
l_count	int
;	O
static	O
int	O
l_maxlen	int
=	O
100	int
;	O
static	O
char	O
*	O
line	pointer
;	O
static	O
int	O
pos	int
;	O
static	O
int	O
symbol	int
;	O
static	O
int	O
s_char	int
;	O
static	O
void	O
my_assert	function
(	O
char	O
*	O
expr	pointer
,	O
char	O
*	O
file	pointer
,	O
int	O
line	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Internal translator error: %s, file %s, line %d\n"	pointer
,	O
expr	pointer
,	O
file	pointer
,	O
line	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Please, report to <bug-marst@gnu.org>\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
static	O
void	O
*	O
my_malloc	function
(	O
int	O
size	int
)	O
{	O
void	O
*	O
ptr	pointer
;	O
assert	O
(	O
size	int
>	O
0	int
)	O
;	O
ptr	pointer
=	O
malloc	function
(	O
size	int
)	O
;	O
if	O
(	O
ptr	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Main storage requested not available\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
return	O
ptr	pointer
;	O
}	O
static	O
void	O
*	O
my_realloc	function
(	O
void	O
*	O
ptr	pointer
,	O
int	O
size	int
)	O
{	O
assert	O
(	O
ptr	pointer
!=	O
NULL	O
&&	O
size	int
>	O
0	int
)	O
;	O
ptr	pointer
=	O
realloc	function
(	O
ptr	pointer
,	O
size	int
)	O
;	O
if	O
(	O
ptr	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Main storage requested not available\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
return	O
ptr	pointer
;	O
}	O
static	O
void	O
my_free	function
(	O
void	O
*	O
ptr	pointer
)	O
{	O
assert	O
(	O
ptr	pointer
!=	O
NULL	O
)	O
;	O
free	function
(	O
ptr	pointer
)	O
;	O
return	O
;	O
}	O
static	O
void	O
error	function
(	O
char	O
*	O
msg	pointer
,	O
...	O
)	O
{	O
va_list	array
arg	array
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s:%d: "	pointer
,	O
infilename	pointer
,	O
l_count	int
)	O
;	O
va_start	O
(	O
arg	array
,	O
msg	pointer
)	O
;	O
vfprintf	function
(	O
stderr	pointer
,	O
msg	pointer
,	O
arg	array
)	O
;	O
va_end	O
(	O
arg	array
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
if	O
(	O
debug	int
&&	O
first_pass	int
)	O
{	O
fprintf	function
(	O
outfile	pointer
,	O
">>%s:%d: "	pointer
,	O
infilename	pointer
,	O
l_count	int
)	O
;	O
va_start	O
(	O
arg	array
,	O
msg	pointer
)	O
;	O
vfprintf	function
(	O
outfile	pointer
,	O
msg	pointer
,	O
arg	array
)	O
;	O
va_end	O
(	O
arg	array
)	O
;	O
fprintf	function
(	O
outfile	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
e_count	int
++	O
;	O
if	O
(	O
e_count	int
==	O
errmax	int
)	O
{	O
error	function
(	O
"too many errors detected; translation terminated"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
return	O
;	O
}	O
static	O
void	O
warning	function
(	O
char	O
*	O
msg	pointer
,	O
...	O
)	O
{	O
if	O
(	O
first_pass	int
&&	O
warn	int
)	O
{	O
va_list	array
arg	array
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s:%d: warning: "	pointer
,	O
infilename	pointer
,	O
l_count	int
)	O
;	O
va_start	O
(	O
arg	array
,	O
msg	pointer
)	O
;	O
vfprintf	function
(	O
stderr	pointer
,	O
msg	pointer
,	O
arg	array
)	O
;	O
va_end	O
(	O
arg	array
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
if	O
(	O
debug	int
)	O
{	O
fprintf	function
(	O
outfile	pointer
,	O
">>%s:%d: warning: "	pointer
,	O
infilename	pointer
,	O
l_count	int
)	O
;	O
va_start	O
(	O
arg	array
,	O
msg	pointer
)	O
;	O
vfprintf	function
(	O
outfile	pointer
,	O
msg	pointer
,	O
arg	array
)	O
;	O
va_end	O
(	O
arg	array
)	O
;	O
fprintf	function
(	O
outfile	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
w_count	int
++	O
;	O
}	O
return	O
;	O
}	O
static	O
int	O
read_line	function
(	O
void	O
)	O
{	O
int	O
c	int
,	O
len	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
c	int
=	O
fgetc	function
(	O
infile	pointer
)	O
;	O
if	O
(	O
ferror	function
(	O
infile	pointer
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Read error on `%s' - %s\n"	pointer
,	O
infilename	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
feof	function
(	O
infile	pointer
)	O
)	O
{	O
if	O
(	O
len	int
>	O
0	int
)	O
{	O
l_count	int
++	O
;	O
warning	function
(	O
"missing final newline"	pointer
)	O
;	O
l_count	int
--	O
;	O
break	O
;	O
}	O
line	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
break	O
;	O
if	O
(	O
iscntrl	function
(	O
c	int
)	O
&&	O
!	O
isspace	function
(	O
c	int
)	O
)	O
{	O
l_count	int
++	O
;	O
error	function
(	O
"invalid control character 0x%02X"	pointer
,	O
c	int
)	O
;	O
l_count	int
--	O
;	O
c	int
=	O
' '	O
;	O
}	O
if	O
(	O
len	int
==	O
l_maxlen	int
)	O
{	O
l_maxlen	int
+=	O
l_maxlen	int
;	O
line	pointer
=	O
my_realloc	function
(	O
line	pointer
,	O
l_maxlen	int
+	O
1	int
)	O
;	O
}	O
line	pointer
[	O
len	int
++	O
]	O
=	O
(	O
char	O
)	O
c	int
;	O
}	O
line	pointer
[	O
len	int
]	O
=	O
'\0'	O
;	O
l_count	int
++	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
skip_pad	function
(	O
void	O
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
line	pointer
[	O
pos	int
]	O
==	O
'\0'	O
)	O
{	O
if	O
(	O
read_line	function
(	O
)	O
)	O
line	pointer
[	O
0	int
]	O
=	O
0x1A	int
;	O
pos	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
isspace	function
(	O
line	pointer
[	O
pos	int
]	O
)	O
)	O
{	O
pos	int
++	O
;	O
}	O
else	O
{	O
break	O
;	O
}	O
}	O
return	O
;	O
}	O
static	O
void	O
scan_symbol	function
(	O
void	O
)	O
{	O
scan	O
:	O
skip_pad	function
(	O
)	O
;	O
if	O
(	O
isalpha	function
(	O
line	pointer
[	O
pos	int
]	O
)	O
)	O
{	O
if	O
(	O
pos	int
>	O
0	int
&&	O
isalnum	function
(	O
line	pointer
[	O
pos	int
-	O
1	int
]	O
)	O
)	O
goto	O
alfa	O
;	O
switch	O
(	O
line	pointer
[	O
pos	int
]	O
)	O
{	O
case	O
'a'	O
:	O
check_word	O
(	O
5	int
,	O
"array"	pointer
,	O
S_ARRAY	int
)	O
;	O
goto	O
alfa	O
;	O
case	O
'b'	O
:	O
check_word	O
(	O
5	int
,	O
"begin"	pointer
,	O
S_BEGIN	int
)	O
;	O
check_word	O
(	O
7	int
,	O
"boolean"	pointer
,	O
S_BOOLEAN	int
)	O
;	O
goto	O
alfa	O
;	O
case	O
'B'	O
:	O
check_word	O
(	O
7	int
,	O
"Boolean"	pointer
,	O
S_BOOLEAN	int
)	O
;	O
goto	O
alfa	O
;	O
case	O
'c'	O
:	O
check_word	O
(	O
4	int
,	O
"code"	pointer
,	O
S_CODE	int
)	O
;	O
check_word	O
(	O
7	int
,	O
"comment"	pointer
,	O
S_COMMENT	int
)	O
;	O
goto	O
alfa	O
;	O
case	O
'd'	O
:	O
check_word	O
(	O
2	int
,	O
"do"	pointer
,	O
S_DO	int
)	O
;	O
goto	O
alfa	O
;	O
case	O
'e'	O
:	O
check_word	O
(	O
4	int
,	O
"else"	pointer
,	O
S_ELSE	int
)	O
;	O
check_word	O
(	O
3	int
,	O
"end"	pointer
,	O
S_END	int
)	O
;	O
goto	O
alfa	O
;	O
case	O
'f'	O
:	O
check_word	O
(	O
5	int
,	O
"false"	pointer
,	O
S_FALSE	int
)	O
;	O
check_word	O
(	O
3	int
,	O
"for"	pointer
,	O
S_FOR	int
)	O
;	O
goto	O
alfa	O
;	O
case	O
'g'	O
:	O
check_word	O
(	O
4	int
,	O
"goto"	pointer
,	O
S_GOTO	int
)	O
;	O
check_word	O
(	O
5	int
,	O
"go to"	pointer
,	O
S_GOTO	int
)	O
;	O
check_word	O
(	O
6	int
,	O
"go  to"	pointer
,	O
S_GOTO	int
)	O
;	O
check_word	O
(	O
7	int
,	O
"go   to"	pointer
,	O
S_GOTO	int
)	O
;	O
goto	O
alfa	O
;	O
case	O
'i'	O
:	O
check_word	O
(	O
2	int
,	O
"if"	pointer
,	O
S_IF	int
)	O
;	O
check_word	O
(	O
7	int
,	O
"integer"	pointer
,	O
S_INTEGER	int
)	O
;	O
goto	O
alfa	O
;	O
case	O
'l'	O
:	O
check_word	O
(	O
5	int
,	O
"label"	pointer
,	O
S_LABEL	int
)	O
;	O
goto	O
alfa	O
;	O
case	O
'o'	O
:	O
check_word	O
(	O
3	int
,	O
"own"	pointer
,	O
S_OWN	int
)	O
;	O
goto	O
alfa	O
;	O
case	O
'p'	O
:	O
check_word	O
(	O
9	int
,	O
"procedure"	pointer
,	O
S_PROCEDURE	int
)	O
;	O
goto	O
alfa	O
;	O
case	O
'r'	O
:	O
check_word	O
(	O
4	int
,	O
"real"	pointer
,	O
S_REAL	int
)	O
;	O
goto	O
alfa	O
;	O
case	O
's'	O
:	O
check_word	O
(	O
4	int
,	O
"step"	pointer
,	O
S_STEP	int
)	O
;	O
check_word	O
(	O
6	int
,	O
"string"	pointer
,	O
S_STRING	int
)	O
;	O
check_word	O
(	O
6	int
,	O
"switch"	pointer
,	O
S_SWITCH	int
)	O
;	O
goto	O
alfa	O
;	O
case	O
't'	O
:	O
check_word	O
(	O
4	int
,	O
"then"	pointer
,	O
S_THEN	int
)	O
;	O
check_word	O
(	O
4	int
,	O
"true"	pointer
,	O
S_TRUE	int
)	O
;	O
goto	O
alfa	O
;	O
case	O
'u'	O
:	O
check_word	O
(	O
5	int
,	O
"until"	pointer
,	O
S_UNTIL	int
)	O
;	O
goto	O
alfa	O
;	O
case	O
'v'	O
:	O
check_word	O
(	O
5	int
,	O
"value"	pointer
,	O
S_VALUE	int
)	O
;	O
goto	O
alfa	O
;	O
case	O
'w'	O
:	O
check_word	O
(	O
5	int
,	O
"while"	pointer
,	O
S_WHILE	int
)	O
;	O
goto	O
alfa	O
;	O
default	O
:	O
alfa	O
:	O
symbol	int
=	O
S_LETTER	int
,	O
s_char	int
=	O
(	O
unsigned	O
char	O
)	O
line	pointer
[	O
pos	int
++	O
]	O
;	O
}	O
}	O
else	O
if	O
(	O
isdigit	function
(	O
line	pointer
[	O
pos	int
]	O
)	O
)	O
{	O
symbol	int
=	O
S_DIGIT	int
,	O
s_char	int
=	O
(	O
unsigned	O
char	O
)	O
line	pointer
[	O
pos	int
++	O
]	O
;	O
}	O
else	O
{	O
switch	O
(	O
line	pointer
[	O
pos	int
]	O
)	O
{	O
case	O
0x1A	int
:	O
symbol	int
=	O
S_EOF	int
;	O
break	O
;	O
case	O
'+'	O
:	O
symbol	int
=	O
S_PLUS	int
,	O
pos	int
++	O
;	O
break	O
;	O
case	O
'-'	O
:	O
check_spec	O
(	O
'>'	O
,	O
S_MINUS	int
,	O
S_IMPL	int
)	O
;	O
break	O
;	O
case	O
'*'	O
:	O
check_spec	O
(	O
'*'	O
,	O
S_TIMES	int
,	O
S_POWER	int
)	O
;	O
break	O
;	O
case	O
'/'	O
:	O
symbol	int
=	O
S_SLASH	int
,	O
pos	int
++	O
;	O
break	O
;	O
case	O
'%'	O
:	O
symbol	int
=	O
S_INTDIV	int
,	O
pos	int
++	O
;	O
break	O
;	O
case	O
'^'	O
:	O
symbol	int
=	O
S_POWER	int
,	O
pos	int
++	O
;	O
break	O
;	O
case	O
'<'	O
:	O
check_spec	O
(	O
'='	O
,	O
S_LESS	int
,	O
S_NOTGREATER	int
)	O
;	O
break	O
;	O
case	O
'='	O
:	O
check_spec	O
(	O
'='	O
,	O
S_EQUAL	int
,	O
S_EQUIV	int
)	O
;	O
break	O
;	O
case	O
'>'	O
:	O
check_spec	O
(	O
'='	O
,	O
S_GREATER	int
,	O
S_NOTLESS	int
)	O
;	O
break	O
;	O
case	O
'!'	O
:	O
check_spec	O
(	O
'='	O
,	O
S_NOT	int
,	O
S_NOTEQUAL	int
)	O
;	O
break	O
;	O
case	O
'|'	O
:	O
symbol	int
=	O
S_OR	int
,	O
pos	int
++	O
;	O
break	O
;	O
case	O
'&'	O
:	O
symbol	int
=	O
S_AND	int
,	O
pos	int
++	O
;	O
break	O
;	O
case	O
','	O
:	O
symbol	int
=	O
S_COMMA	int
,	O
pos	int
++	O
;	O
break	O
;	O
case	O
'.'	O
:	O
symbol	int
=	O
S_POINT	int
,	O
pos	int
++	O
;	O
break	O
;	O
case	O
TEN_CHAR	char
:	O
symbol	int
=	O
S_TEN	int
,	O
pos	int
++	O
;	O
break	O
;	O
case	O
':'	O
:	O
check_spec	O
(	O
'='	O
,	O
S_COLON	int
,	O
S_ASSIGN	int
)	O
;	O
break	O
;	O
case	O
';'	O
:	O
symbol	int
=	O
S_SEMICOLON	int
,	O
pos	int
++	O
;	O
break	O
;	O
case	O
'('	O
:	O
symbol	int
=	O
S_LEFT	int
,	O
pos	int
++	O
;	O
break	O
;	O
case	O
')'	O
:	O
symbol	int
=	O
S_RIGHT	int
,	O
pos	int
++	O
;	O
break	O
;	O
case	O
'['	O
:	O
symbol	int
=	O
S_BEGSUB	int
,	O
pos	int
++	O
;	O
break	O
;	O
case	O
']'	O
:	O
symbol	int
=	O
S_ENDSUB	int
,	O
pos	int
++	O
;	O
break	O
;	O
case	O
'"'	O
:	O
symbol	int
=	O
S_OPEN	int
,	O
pos	int
++	O
;	O
break	O
;	O
default	O
:	O
error	function
(	O
"invalid character `%c'"	pointer
,	O
line	pointer
[	O
pos	int
]	O
)	O
;	O
pos	int
++	O
;	O
goto	O
scan	O
;	O
}	O
}	O
return	O
;	O
}	O
static	O
int	O
t_maxlen	int
=	O
100	int
;	O
static	O
struct	O
{	O
int	O
ssn	int
;	O
int	O
code	int
;	O
int	O
delim	int
;	O
int	O
len	int
;	O
char	O
*	O
image	pointer
;	O
}	O
token	array
[	O
3	int
]	O
;	O
static	O
void	O
add_char	function
(	O
int	O
k	int
,	O
int	O
c	int
)	O
{	O
if	O
(	O
token	array
[	O
k	int
]	O
.	O
len	int
==	O
t_maxlen	int
)	O
{	O
int	O
kk	int
;	O
t_maxlen	int
+=	O
t_maxlen	int
;	O
for	O
(	O
kk	int
=	O
0	int
;	O
kk	int
<=	O
2	int
;	O
kk	int
++	O
)	O
token	array
[	O
kk	int
]	O
.	O
image	pointer
=	O
my_realloc	function
(	O
token	array
[	O
kk	int
]	O
.	O
image	pointer
,	O
t_maxlen	int
+	O
1	int
)	O
;	O
}	O
token	array
[	O
k	int
]	O
.	O
image	pointer
[	O
token	array
[	O
k	int
]	O
.	O
len	int
++	O
]	O
=	O
(	O
char	O
)	O
c	int
;	O
token	array
[	O
k	int
]	O
.	O
image	pointer
[	O
token	array
[	O
k	int
]	O
.	O
len	int
]	O
=	O
'\0'	O
;	O
return	O
;	O
}	O
static	O
void	O
scan_token	function
(	O
int	O
k	int
)	O
{	O
assert	O
(	O
k	int
==	O
1	int
||	O
(	O
k	int
==	O
2	int
&&	O
token	array
[	O
2	int
]	O
.	O
code	int
==	O
T_UNDEF	int
)	O
)	O
;	O
scan	O
:	O
if	O
(	O
token	array
[	O
k	int
-	O
1	int
]	O
.	O
code	int
==	O
T_DELIM	int
&&	O
token	array
[	O
k	int
-	O
1	int
]	O
.	O
delim	int
==	O
S_END	int
)	O
{	O
int	O
some	int
=	O
0	int
;	O
int	O
flag	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
symbol	int
==	O
S_EOF	int
||	O
symbol	int
==	O
S_SEMICOLON	int
||	O
symbol	int
==	O
S_ELSE	int
||	O
symbol	int
==	O
S_END	int
)	O
break	O
;	O
some	int
=	O
1	int
;	O
if	O
(	O
!	O
(	O
symbol	int
==	O
S_LETTER	int
||	O
symbol	int
==	O
S_DIGIT	int
||	O
symbol	int
==	O
S_FALSE	int
||	O
symbol	int
==	O
S_TRUE	int
)	O
&&	O
!	O
flag	int
)	O
{	O
warning	function
(	O
"comment sequence following `end' contains delim"	pointer
"iter(s)"	pointer
)	O
;	O
flag	int
=	O
1	int
;	O
}	O
scan_symbol	function
(	O
)	O
;	O
}	O
if	O
(	O
symbol	int
==	O
S_EOF	int
&&	O
some	int
)	O
warning	function
(	O
"comment sequence following `end' terminated by eof"	pointer
)	O
;	O
}	O
{	O
int	O
flag	int
=	O
0	int
;	O
while	O
(	O
symbol	int
==	O
S_COMMENT	int
)	O
{	O
if	O
(	O
!	O
(	O
token	array
[	O
k	int
-	O
1	int
]	O
.	O
code	int
==	O
T_DELIM	int
&&	O
(	O
token	array
[	O
k	int
-	O
1	int
]	O
.	O
delim	int
==	O
S_SEMICOLON	int
||	O
token	array
[	O
k	int
-	O
1	int
]	O
.	O
delim	int
==	O
S_BEGIN	int
)	O
)	O
)	O
{	O
if	O
(	O
token	array
[	O
k	int
-	O
1	int
]	O
.	O
code	int
==	O
T_DELIM	int
&&	O
token	array
[	O
k	int
-	O
1	int
]	O
.	O
delim	int
==	O
S_EOF	int
)	O
{	O
if	O
(	O
!	O
flag	int
)	O
{	O
warning	function
(	O
"no symbols preceding delimiter `comment'"	pointer
)	O
;	O
flag	int
=	O
1	int
;	O
}	O
}	O
else	O
error	function
(	O
"delimiter `comment' in invalid position"	pointer
)	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
skip_pad	function
(	O
)	O
;	O
if	O
(	O
line	pointer
[	O
pos	int
]	O
==	O
0x1A	int
)	O
{	O
error	function
(	O
"comment sequence following `comment' terminate"	pointer
"d by eof"	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
line	pointer
[	O
pos	int
++	O
]	O
==	O
';'	O
)	O
break	O
;	O
}	O
scan_symbol	function
(	O
)	O
;	O
}	O
}	O
token	array
[	O
k	int
]	O
.	O
ssn	int
=	O
l_count	int
;	O
token	array
[	O
k	int
]	O
.	O
code	int
=	O
T_UNDEF	int
;	O
token	array
[	O
k	int
]	O
.	O
delim	int
=	O
0	int
;	O
token	array
[	O
k	int
]	O
.	O
len	int
=	O
0	int
;	O
token	array
[	O
k	int
]	O
.	O
image	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
symbol	int
==	O
S_LETTER	int
)	O
{	O
token	array
[	O
k	int
]	O
.	O
code	int
=	O
T_IDENT	int
;	O
while	O
(	O
symbol	int
==	O
S_LETTER	int
||	O
symbol	int
==	O
S_DIGIT	int
)	O
add_char	function
(	O
k	int
,	O
s_char	int
)	O
,	O
scan_symbol	function
(	O
)	O
;	O
if	O
(	O
strlen	function
(	O
token	array
[	O
k	int
]	O
.	O
image	pointer
)	O
>	O
T_MAXLEN	int
)	O
{	O
token	array
[	O
k	int
]	O
.	O
image	pointer
[	O
T_MAXLEN	int
]	O
=	O
'\0'	O
;	O
error	function
(	O
"identifier `%s...' too long"	pointer
,	O
token	array
[	O
k	int
]	O
.	O
image	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
symbol	int
==	O
S_DIGIT	int
)	O
{	O
token	array
[	O
k	int
]	O
.	O
code	int
=	O
T_INT	int
;	O
while	O
(	O
symbol	int
==	O
S_DIGIT	int
)	O
add_char	function
(	O
k	int
,	O
s_char	int
)	O
,	O
scan_symbol	function
(	O
)	O
;	O
if	O
(	O
symbol	int
==	O
S_POINT	int
)	O
{	O
token	array
[	O
k	int
]	O
.	O
code	int
=	O
T_REAL	int
;	O
add_char	function
(	O
k	int
,	O
'.'	O
)	O
,	O
scan_symbol	function
(	O
)	O
;	O
if	O
(	O
symbol	int
!=	O
S_DIGIT	int
)	O
error	function
(	O
"real constant `%s' incomplete"	pointer
,	O
token	array
[	O
k	int
]	O
.	O
image	pointer
)	O
;	O
frac	O
:	O
while	O
(	O
symbol	int
==	O
S_DIGIT	int
)	O
add_char	function
(	O
k	int
,	O
s_char	int
)	O
,	O
scan_symbol	function
(	O
)	O
;	O
}	O
if	O
(	O
symbol	int
==	O
S_TEN	int
)	O
{	O
token	array
[	O
k	int
]	O
.	O
code	int
=	O
T_REAL	int
;	O
add_char	function
(	O
k	int
,	O
TEN_CHAR	char
)	O
,	O
scan_symbol	function
(	O
)	O
;	O
dexp	O
:	O
if	O
(	O
symbol	int
==	O
S_PLUS	int
)	O
add_char	function
(	O
k	int
,	O
'+'	O
)	O
,	O
scan_symbol	function
(	O
)	O
;	O
else	O
if	O
(	O
symbol	int
==	O
S_MINUS	int
)	O
add_char	function
(	O
k	int
,	O
'-'	O
)	O
,	O
scan_symbol	function
(	O
)	O
;	O
if	O
(	O
symbol	int
!=	O
S_DIGIT	int
)	O
error	function
(	O
"real constant `%s' incomplete"	pointer
,	O
token	array
[	O
k	int
]	O
.	O
image	pointer
)	O
;	O
while	O
(	O
symbol	int
==	O
S_DIGIT	int
)	O
add_char	function
(	O
k	int
,	O
s_char	int
)	O
,	O
scan_symbol	function
(	O
)	O
;	O
}	O
if	O
(	O
strlen	function
(	O
token	array
[	O
k	int
]	O
.	O
image	pointer
)	O
>	O
T_MAXLEN	int
)	O
{	O
token	array
[	O
k	int
]	O
.	O
image	pointer
[	O
T_MAXLEN	int
]	O
=	O
'\0'	O
;	O
error	function
(	O
"constant `%s...' too long"	pointer
,	O
token	array
[	O
k	int
]	O
.	O
image	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
symbol	int
==	O
S_FALSE	int
)	O
{	O
token	array
[	O
k	int
]	O
.	O
code	int
=	O
T_FALSE	int
;	O
strcpy	function
(	O
token	array
[	O
k	int
]	O
.	O
image	pointer
,	O
"false"	pointer
)	O
,	O
scan_symbol	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
symbol	int
==	O
S_TRUE	int
)	O
{	O
token	array
[	O
k	int
]	O
.	O
code	int
=	O
T_TRUE	int
;	O
strcpy	function
(	O
token	array
[	O
k	int
]	O
.	O
image	pointer
,	O
"true"	pointer
)	O
,	O
scan_symbol	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
symbol	int
==	O
S_OPEN	int
)	O
{	O
token	array
[	O
k	int
]	O
.	O
code	int
=	O
T_STRING	int
;	O
add_char	function
(	O
k	int
,	O
'"'	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
line	pointer
[	O
pos	int
]	O
==	O
0x1A	int
)	O
{	O
error	function
(	O
"unexpected eof within string"	pointer
)	O
;	O
goto	O
clos	O
;	O
}	O
if	O
(	O
line	pointer
[	O
pos	int
]	O
==	O
'\0'	O
)	O
{	O
error	function
(	O
"string incomplete"	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
iscntrl	function
(	O
line	pointer
[	O
pos	int
]	O
)	O
)	O
{	O
error	function
(	O
"invalid use of control character 0x%02X within"	pointer
" string"	pointer
,	O
line	pointer
[	O
pos	int
]	O
)	O
;	O
pos	int
++	O
;	O
continue	O
;	O
}	O
if	O
(	O
line	pointer
[	O
pos	int
]	O
==	O
'\\'	O
)	O
{	O
pos	int
++	O
;	O
if	O
(	O
line	pointer
[	O
pos	int
]	O
==	O
0x1A	int
||	O
line	pointer
[	O
pos	int
]	O
==	O
'\0'	O
)	O
{	O
error	function
(	O
"invalid use of backslash within string"	pointer
)	O
;	O
continue	O
;	O
}	O
add_char	function
(	O
k	int
,	O
'\\'	O
)	O
;	O
}	O
else	O
if	O
(	O
line	pointer
[	O
pos	int
]	O
==	O
'"'	O
)	O
{	O
pos	int
++	O
;	O
break	O
;	O
}	O
add_char	function
(	O
k	int
,	O
line	pointer
[	O
pos	int
++	O
]	O
)	O
;	O
}	O
skip_pad	function
(	O
)	O
;	O
if	O
(	O
line	pointer
[	O
pos	int
]	O
!=	O
'"'	O
)	O
break	O
;	O
pos	int
++	O
;	O
}	O
clos	O
:	O
add_char	function
(	O
k	int
,	O
'"'	O
)	O
;	O
scan_symbol	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
symbol	int
==	O
S_POINT	int
)	O
{	O
token	array
[	O
k	int
]	O
.	O
code	int
=	O
T_REAL	int
;	O
add_char	function
(	O
k	int
,	O
'.'	O
)	O
,	O
scan_symbol	function
(	O
)	O
;	O
if	O
(	O
symbol	int
!=	O
S_DIGIT	int
)	O
{	O
error	function
(	O
"invalid use of period"	pointer
)	O
;	O
goto	O
scan	O
;	O
}	O
goto	O
frac	O
;	O
}	O
else	O
if	O
(	O
symbol	int
==	O
S_TEN	int
)	O
{	O
token	array
[	O
k	int
]	O
.	O
code	int
=	O
T_REAL	int
;	O
add_char	function
(	O
k	int
,	O
TEN_CHAR	char
)	O
,	O
scan_symbol	function
(	O
)	O
;	O
if	O
(	O
!	O
(	O
symbol	int
==	O
S_PLUS	int
||	O
symbol	int
==	O
S_MINUS	int
||	O
symbol	int
==	O
S_DIGIT	int
)	O
)	O
{	O
error	function
(	O
"invalid use of subscripted ten"	pointer
)	O
;	O
goto	O
scan	O
;	O
}	O
goto	O
dexp	O
;	O
}	O
else	O
{	O
char	O
*	O
image	pointer
;	O
token	array
[	O
k	int
]	O
.	O
code	int
=	O
T_DELIM	int
;	O
token	array
[	O
k	int
]	O
.	O
delim	int
=	O
symbol	int
;	O
switch	O
(	O
symbol	int
)	O
{	O
case	O
S_EOF	int
:	O
image	pointer
=	O
"eof"	pointer
;	O
break	O
;	O
case	O
S_PLUS	int
:	O
image	pointer
=	O
"+"	pointer
;	O
break	O
;	O
case	O
S_MINUS	int
:	O
image	pointer
=	O
"-"	pointer
;	O
break	O
;	O
case	O
S_TIMES	int
:	O
image	pointer
=	O
"*"	pointer
;	O
break	O
;	O
case	O
S_SLASH	int
:	O
image	pointer
=	O
"/"	pointer
;	O
break	O
;	O
case	O
S_INTDIV	int
:	O
image	pointer
=	O
"%"	pointer
;	O
break	O
;	O
case	O
S_POWER	int
:	O
image	pointer
=	O
"^"	pointer
;	O
break	O
;	O
case	O
S_LESS	int
:	O
image	pointer
=	O
"<"	pointer
;	O
break	O
;	O
case	O
S_NOTGREATER	int
:	O
image	pointer
=	O
"<="	pointer
;	O
break	O
;	O
case	O
S_EQUAL	int
:	O
image	pointer
=	O
"="	pointer
;	O
break	O
;	O
case	O
S_NOTLESS	int
:	O
image	pointer
=	O
">="	pointer
;	O
break	O
;	O
case	O
S_GREATER	int
:	O
image	pointer
=	O
">"	pointer
;	O
break	O
;	O
case	O
S_NOTEQUAL	int
:	O
image	pointer
=	O
"!="	pointer
;	O
break	O
;	O
case	O
S_EQUIV	int
:	O
image	pointer
=	O
"=="	pointer
;	O
break	O
;	O
case	O
S_IMPL	int
:	O
image	pointer
=	O
"->"	pointer
;	O
break	O
;	O
case	O
S_OR	int
:	O
image	pointer
=	O
"|"	pointer
;	O
break	O
;	O
case	O
S_AND	int
:	O
image	pointer
=	O
"&"	pointer
;	O
break	O
;	O
case	O
S_NOT	int
:	O
image	pointer
=	O
"!"	pointer
;	O
break	O
;	O
case	O
S_COMMA	int
:	O
image	pointer
=	O
","	pointer
;	O
break	O
;	O
case	O
S_COLON	int
:	O
image	pointer
=	O
":"	pointer
;	O
break	O
;	O
case	O
S_SEMICOLON	int
:	O
image	pointer
=	O
";"	pointer
;	O
break	O
;	O
case	O
S_ASSIGN	int
:	O
image	pointer
=	O
":="	pointer
;	O
break	O
;	O
case	O
S_LEFT	int
:	O
image	pointer
=	O
"("	pointer
;	O
break	O
;	O
case	O
S_RIGHT	int
:	O
image	pointer
=	O
")"	pointer
;	O
break	O
;	O
case	O
S_BEGSUB	int
:	O
image	pointer
=	O
"["	pointer
;	O
break	O
;	O
case	O
S_ENDSUB	int
:	O
image	pointer
=	O
"]"	pointer
;	O
break	O
;	O
case	O
S_ARRAY	int
:	O
image	pointer
=	O
"array"	pointer
;	O
break	O
;	O
case	O
S_BEGIN	int
:	O
image	pointer
=	O
"begin"	pointer
;	O
break	O
;	O
case	O
S_BOOLEAN	int
:	O
image	pointer
=	O
"Boolean"	pointer
;	O
break	O
;	O
case	O
S_CODE	int
:	O
image	pointer
=	O
"code"	pointer
;	O
break	O
;	O
case	O
S_DO	int
:	O
image	pointer
=	O
"do"	pointer
;	O
break	O
;	O
case	O
S_ELSE	int
:	O
image	pointer
=	O
"else"	pointer
;	O
break	O
;	O
case	O
S_END	int
:	O
image	pointer
=	O
"end"	pointer
;	O
break	O
;	O
case	O
S_FOR	int
:	O
image	pointer
=	O
"for"	pointer
;	O
break	O
;	O
case	O
S_GOTO	int
:	O
image	pointer
=	O
"go to"	pointer
;	O
break	O
;	O
case	O
S_IF	int
:	O
image	pointer
=	O
"if"	pointer
;	O
break	O
;	O
case	O
S_INTEGER	int
:	O
image	pointer
=	O
"integer"	pointer
;	O
break	O
;	O
case	O
S_LABEL	int
:	O
image	pointer
=	O
"label"	pointer
;	O
break	O
;	O
case	O
S_OWN	int
:	O
image	pointer
=	O
"own"	pointer
;	O
break	O
;	O
case	O
S_PROCEDURE	int
:	O
image	pointer
=	O
"procedure"	pointer
;	O
break	O
;	O
case	O
S_REAL	int
:	O
image	pointer
=	O
"real"	pointer
;	O
break	O
;	O
case	O
S_STEP	int
:	O
image	pointer
=	O
"step"	pointer
;	O
break	O
;	O
case	O
S_STRING	int
:	O
image	pointer
=	O
"string"	pointer
;	O
break	O
;	O
case	O
S_SWITCH	int
:	O
image	pointer
=	O
"switch"	pointer
;	O
break	O
;	O
case	O
S_THEN	int
:	O
image	pointer
=	O
"then"	pointer
;	O
break	O
;	O
case	O
S_UNTIL	int
:	O
image	pointer
=	O
"until"	pointer
;	O
break	O
;	O
case	O
S_VALUE	int
:	O
image	pointer
=	O
"value"	pointer
;	O
break	O
;	O
case	O
S_WHILE	int
:	O
image	pointer
=	O
"while"	pointer
;	O
break	O
;	O
default	O
:	O
assert	O
(	O
symbol	int
!=	O
symbol	int
)	O
;	O
}	O
strcpy	function
(	O
token	array
[	O
k	int
]	O
.	O
image	pointer
,	O
image	pointer
)	O
,	O
scan_symbol	function
(	O
)	O
;	O
}	O
if	O
(	O
debug	int
&&	O
first_pass	int
)	O
{	O
fprintf	function
(	O
outfile	pointer
,	O
"%6d: %-6s |%s|\n"	pointer
,	O
token	array
[	O
k	int
]	O
.	O
ssn	int
,	O
token	array
[	O
k	int
]	O
.	O
code	int
==	O
T_IDENT	int
?	O
"ident"	pointer
:	O
token	array
[	O
k	int
]	O
.	O
code	int
==	O
T_INT	int
?	O
"int"	pointer
:	O
token	array
[	O
k	int
]	O
.	O
code	int
==	O
T_REAL	int
?	O
"real"	pointer
:	O
token	array
[	O
k	int
]	O
.	O
code	int
==	O
T_FALSE	int
?	O
"false"	pointer
:	O
token	array
[	O
k	int
]	O
.	O
code	int
==	O
T_TRUE	int
?	O
"true"	pointer
:	O
token	array
[	O
k	int
]	O
.	O
code	int
==	O
T_STRING	int
?	O
"string"	pointer
:	O
token	array
[	O
k	int
]	O
.	O
code	int
==	O
T_DELIM	int
?	O
"delim"	pointer
:	O
"???"	pointer
,	O
token	array
[	O
k	int
]	O
.	O
image	pointer
)	O
;	O
}	O
return	O
;	O
}	O
;	O
static	O
void	O
get_token	function
(	O
void	O
)	O
{	O
token	array
[	O
0	int
]	O
.	O
ssn	int
=	O
token	array
[	O
1	int
]	O
.	O
ssn	int
;	O
token	array
[	O
0	int
]	O
.	O
code	int
=	O
token	array
[	O
1	int
]	O
.	O
code	int
;	O
token	array
[	O
0	int
]	O
.	O
delim	int
=	O
token	array
[	O
1	int
]	O
.	O
delim	int
;	O
token	array
[	O
0	int
]	O
.	O
len	int
=	O
token	array
[	O
1	int
]	O
.	O
len	int
;	O
strcpy	function
(	O
token	array
[	O
0	int
]	O
.	O
image	pointer
,	O
token	array
[	O
1	int
]	O
.	O
image	pointer
)	O
;	O
if	O
(	O
token	array
[	O
2	int
]	O
.	O
code	int
==	O
T_UNDEF	int
)	O
scan_token	function
(	O
1	int
)	O
;	O
else	O
{	O
token	array
[	O
1	int
]	O
.	O
ssn	int
=	O
token	array
[	O
2	int
]	O
.	O
ssn	int
;	O
token	array
[	O
1	int
]	O
.	O
code	int
=	O
token	array
[	O
2	int
]	O
.	O
code	int
;	O
token	array
[	O
1	int
]	O
.	O
delim	int
=	O
token	array
[	O
2	int
]	O
.	O
delim	int
;	O
token	array
[	O
1	int
]	O
.	O
len	int
=	O
token	array
[	O
2	int
]	O
.	O
len	int
;	O
strcpy	function
(	O
token	array
[	O
1	int
]	O
.	O
image	pointer
,	O
token	array
[	O
2	int
]	O
.	O
image	pointer
)	O
;	O
token	array
[	O
2	int
]	O
.	O
code	int
=	O
T_UNDEF	int
;	O
}	O
return	O
;	O
}	O
static	O
void	O
get_token2	function
(	O
void	O
)	O
{	O
if	O
(	O
token	array
[	O
2	int
]	O
.	O
code	int
==	O
T_UNDEF	int
)	O
scan_token	function
(	O
2	int
)	O
;	O
return	O
;	O
}	O
typedef	O
struct	O
CODE	struct
CODE	struct
;	O
typedef	O
struct	O
CSQE	struct
CSQE	struct
;	O
struct	O
CODE	struct
{	O
int	O
lval	int
;	O
int	O
type	int
;	O
CSQE	struct
*	O
head	pointer
;	O
CSQE	struct
*	O
tail	pointer
;	O
}	O
;	O
struct	O
CSQE	struct
{	O
char	O
*	O
str	pointer
;	O
CSQE	struct
*	O
next	pointer
;	O
}	O
;	O
static	O
char	O
codebuf	array
[	O
4000	int
]	O
;	O
static	O
CODE	struct
*	O
new_code	function
(	O
void	O
)	O
{	O
if	O
(	O
first_pass	int
)	O
return	O
NULL	O
;	O
else	O
{	O
CODE	struct
*	O
code	int
=	O
my_malloc	function
(	O
sizeof	O
(	O
CODE	struct
)	O
)	O
;	O
code	int
->	O
lval	int
=	O
code	int
->	O
type	int
=	O
0	int
;	O
code	int
->	O
head	pointer
=	O
code	int
->	O
tail	pointer
=	O
NULL	O
;	O
return	O
code	int
;	O
}	O
}	O
static	O
void	O
prepend	function
(	O
CODE	struct
*	O
code	int
,	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
if	O
(	O
second_pass	int
)	O
{	O
va_list	array
arg	array
;	O
CSQE	struct
*	O
sqe	pointer
;	O
va_start	O
(	O
arg	array
,	O
fmt	pointer
)	O
;	O
vsprintf	function
(	O
codebuf	array
,	O
fmt	pointer
,	O
arg	array
)	O
;	O
assert	O
(	O
strlen	function
(	O
codebuf	array
)	O
<	O
sizeof	O
(	O
codebuf	array
)	O
)	O
;	O
va_end	O
(	O
arg	array
)	O
;	O
sqe	pointer
=	O
my_malloc	function
(	O
sizeof	O
(	O
CSQE	struct
)	O
)	O
;	O
sqe	pointer
->	O
str	pointer
=	O
my_malloc	function
(	O
strlen	function
(	O
codebuf	array
)	O
+	O
1	int
)	O
;	O
strcpy	function
(	O
sqe	pointer
->	O
str	pointer
,	O
codebuf	array
)	O
;	O
sqe	pointer
->	O
next	pointer
=	O
code	int
->	O
head	pointer
;	O
code	int
->	O
head	pointer
=	O
sqe	pointer
;	O
if	O
(	O
code	int
->	O
tail	pointer
==	O
NULL	O
)	O
code	int
->	O
tail	pointer
=	O
sqe	pointer
;	O
}	O
return	O
;	O
}	O
static	O
void	O
append	function
(	O
CODE	struct
*	O
code	int
,	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
if	O
(	O
second_pass	int
)	O
{	O
va_list	array
arg	array
;	O
CSQE	struct
*	O
sqe	pointer
;	O
va_start	O
(	O
arg	array
,	O
fmt	pointer
)	O
;	O
vsprintf	function
(	O
codebuf	array
,	O
fmt	pointer
,	O
arg	array
)	O
;	O
assert	O
(	O
strlen	function
(	O
codebuf	array
)	O
<	O
sizeof	O
(	O
codebuf	array
)	O
)	O
;	O
va_end	O
(	O
arg	array
)	O
;	O
sqe	pointer
=	O
my_malloc	function
(	O
sizeof	O
(	O
CSQE	struct
)	O
)	O
;	O
sqe	pointer
->	O
str	pointer
=	O
my_malloc	function
(	O
strlen	function
(	O
codebuf	array
)	O
+	O
1	int
)	O
;	O
strcpy	function
(	O
sqe	pointer
->	O
str	pointer
,	O
codebuf	array
)	O
;	O
sqe	pointer
->	O
next	pointer
=	O
NULL	O
;	O
if	O
(	O
code	int
->	O
head	pointer
==	O
NULL	O
)	O
code	int
->	O
head	pointer
=	O
sqe	pointer
;	O
else	O
code	int
->	O
tail	pointer
->	O
next	pointer
=	O
sqe	pointer
;	O
code	int
->	O
tail	pointer
=	O
sqe	pointer
;	O
}	O
return	O
;	O
}	O
static	O
void	O
catenate	function
(	O
CODE	struct
*	O
x	pointer
,	O
CODE	struct
*	O
y	pointer
)	O
{	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
x	pointer
->	O
head	pointer
==	O
NULL	O
)	O
x	pointer
->	O
head	pointer
=	O
y	pointer
->	O
head	pointer
;	O
else	O
x	pointer
->	O
tail	pointer
->	O
next	pointer
=	O
y	pointer
->	O
head	pointer
;	O
if	O
(	O
y	pointer
->	O
tail	pointer
!=	O
NULL	O
)	O
x	pointer
->	O
tail	pointer
=	O
y	pointer
->	O
tail	pointer
;	O
my_free	function
(	O
y	pointer
)	O
;	O
}	O
return	O
;	O
}	O
static	O
void	O
free_code	function
(	O
CODE	struct
*	O
code	int
)	O
{	O
if	O
(	O
second_pass	int
)	O
{	O
CSQE	struct
*	O
sqe	pointer
;	O
while	O
(	O
code	int
->	O
head	pointer
!=	O
NULL	O
)	O
{	O
sqe	pointer
=	O
code	int
->	O
head	pointer
;	O
code	int
->	O
head	pointer
=	O
sqe	pointer
->	O
next	pointer
;	O
my_free	function
(	O
sqe	pointer
->	O
str	pointer
)	O
;	O
my_free	function
(	O
sqe	pointer
)	O
;	O
}	O
my_free	function
(	O
code	int
)	O
;	O
}	O
return	O
;	O
}	O
typedef	O
struct	O
BLOCK	struct
BLOCK	struct
;	O
typedef	O
struct	O
IDENT	struct
IDENT	struct
;	O
struct	O
BLOCK	struct
{	O
int	O
seqn	int
;	O
int	O
ssn	int
;	O
IDENT	struct
*	O
proc	pointer
;	O
IDENT	struct
*	O
first	pointer
,	O
*	O
last	pointer
;	O
BLOCK	struct
*	O
surr	pointer
;	O
BLOCK	struct
*	O
next	pointer
;	O
}	O
;	O
static	O
BLOCK	struct
*	O
first_b	pointer
,	O
*	O
last_b	pointer
;	O
static	O
BLOCK	struct
*	O
current	pointer
=	O
NULL	O
;	O
struct	O
IDENT	struct
{	O
char	O
*	O
name	pointer
;	O
int	O
ssn_decl	int
;	O
int	O
ssn_used	int
;	O
int	O
flags	int
;	O
int	O
dim	int
;	O
BLOCK	struct
*	O
block	pointer
;	O
IDENT	struct
*	O
next	pointer
;	O
}	O
;	O
static	O
int	O
array_decl_flag	int
=	O
0	int
;	O
static	O
IDENT	struct
*	O
look_up	function
(	O
char	O
*	O
name	pointer
,	O
int	O
decl	int
,	O
int	O
ssn	int
)	O
{	O
IDENT	struct
*	O
id	pointer
;	O
if	O
(	O
first_pass	int
)	O
{	O
for	O
(	O
id	pointer
=	O
current	pointer
->	O
first	pointer
;	O
id	pointer
!=	O
NULL	O
;	O
id	pointer
=	O
id	pointer
->	O
next	pointer
)	O
if	O
(	O
strcmp	function
(	O
id	pointer
->	O
name	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
decl	int
&&	O
id	pointer
!=	O
NULL	O
&&	O
id	pointer
->	O
flags	int
!=	O
0	int
)	O
{	O
error	function
(	O
"identifier `%s' multiply declared (see line %d)"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
id	pointer
->	O
ssn_decl	int
)	O
;	O
id	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
id	pointer
==	O
NULL	O
)	O
{	O
id	pointer
=	O
my_malloc	function
(	O
sizeof	O
(	O
IDENT	struct
)	O
)	O
;	O
id	pointer
->	O
name	pointer
=	O
my_malloc	function
(	O
strlen	function
(	O
name	pointer
)	O
+	O
1	int
)	O
;	O
strcpy	function
(	O
id	pointer
->	O
name	pointer
,	O
name	pointer
)	O
;	O
id	pointer
->	O
ssn_decl	int
=	O
id	pointer
->	O
ssn_used	int
=	O
0	int
;	O
id	pointer
->	O
flags	int
=	O
0	int
;	O
id	pointer
->	O
dim	int
=	O
-	O
1	int
;	O
id	pointer
->	O
block	pointer
=	O
current	pointer
;	O
id	pointer
->	O
next	pointer
=	O
NULL	O
;	O
if	O
(	O
current	pointer
->	O
first	pointer
==	O
NULL	O
)	O
current	pointer
->	O
first	pointer
=	O
id	pointer
;	O
else	O
current	pointer
->	O
last	pointer
->	O
next	pointer
=	O
id	pointer
;	O
current	pointer
->	O
last	pointer
=	O
id	pointer
;	O
}	O
if	O
(	O
decl	int
)	O
id	pointer
->	O
ssn_decl	int
=	O
ssn	int
;	O
else	O
if	O
(	O
id	pointer
->	O
ssn_used	int
==	O
0	int
)	O
id	pointer
->	O
ssn_used	int
=	O
ssn	int
;	O
}	O
else	O
{	O
BLOCK	struct
*	O
b	pointer
;	O
for	O
(	O
b	pointer
=	O
current	pointer
;	O
;	O
b	pointer
=	O
b	pointer
->	O
surr	pointer
)	O
{	O
assert	O
(	O
b	pointer
!=	O
NULL	O
)	O
;	O
for	O
(	O
id	pointer
=	O
b	pointer
->	O
first	pointer
;	O
id	pointer
!=	O
NULL	O
;	O
id	pointer
=	O
id	pointer
->	O
next	pointer
)	O
if	O
(	O
strcmp	function
(	O
id	pointer
->	O
name	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
id	pointer
!=	O
NULL	O
)	O
break	O
;	O
}	O
if	O
(	O
array_decl_flag	int
&&	O
!	O
decl	int
&&	O
id	pointer
->	O
block	pointer
==	O
current	pointer
)	O
error	function
(	O
"identifier `%s' in bound expression declared in same"	pointer
" program block as array"	pointer
,	O
id	pointer
->	O
name	pointer
)	O
;	O
}	O
return	O
id	pointer
;	O
}	O
static	O
void	O
to_real	function
(	O
CODE	struct
*	O
x	pointer
)	O
{	O
if	O
(	O
second_pass	int
&&	O
x	pointer
->	O
type	int
==	O
F_INT	int
)	O
{	O
x	pointer
->	O
lval	int
=	O
0	int
;	O
x	pointer
->	O
type	int
=	O
F_REAL	int
;	O
prepend	function
(	O
x	pointer
,	O
a_int2real	pointer
"("	pointer
)	O
;	O
append	function
(	O
x	pointer
,	O
")"	pointer
)	O
;	O
}	O
return	O
;	O
}	O
static	O
void	O
to_int	function
(	O
CODE	struct
*	O
x	pointer
)	O
{	O
if	O
(	O
second_pass	int
&&	O
x	pointer
->	O
type	int
==	O
F_REAL	int
)	O
{	O
x	pointer
->	O
lval	int
=	O
0	int
;	O
x	pointer
->	O
type	int
=	O
F_INT	int
;	O
prepend	function
(	O
x	pointer
,	O
a_real2int	pointer
"("	pointer
)	O
;	O
append	function
(	O
x	pointer
,	O
")"	pointer
)	O
;	O
}	O
return	O
;	O
}	O
static	O
int	O
dsa_level	function
(	O
IDENT	struct
*	O
id	pointer
)	O
{	O
BLOCK	struct
*	O
b	pointer
;	O
int	O
level	int
=	O
-	O
1	int
;	O
for	O
(	O
b	pointer
=	O
id	pointer
->	O
block	pointer
;	O
b	pointer
!=	O
NULL	O
;	O
b	pointer
=	O
b	pointer
->	O
surr	pointer
)	O
if	O
(	O
b	pointer
->	O
proc	pointer
!=	O
NULL	O
)	O
level	int
++	O
;	O
return	O
level	int
;	O
}	O
static	O
int	O
current_level	function
(	O
void	O
)	O
{	O
BLOCK	struct
*	O
b	pointer
;	O
int	O
level	int
=	O
-	O
1	int
;	O
for	O
(	O
b	pointer
=	O
current	pointer
;	O
b	pointer
!=	O
NULL	O
;	O
b	pointer
=	O
b	pointer
->	O
surr	pointer
)	O
if	O
(	O
b	pointer
->	O
proc	pointer
!=	O
NULL	O
)	O
level	int
++	O
;	O
return	O
level	int
;	O
}	O
static	O
CODE	struct
*	O
expression	function
(	O
void	O
)	O
;	O
static	O
CODE	struct
*	O
subscripted_variable	function
(	O
void	O
)	O
{	O
CODE	struct
*	O
code	int
=	O
new_code	function
(	O
)	O
;	O
IDENT	struct
*	O
arr	pointer
;	O
int	O
dim	int
=	O
0	int
;	O
char	O
*	O
place	pointer
;	O
assert	O
(	O
t_code	O
==	O
T_IDENT	int
)	O
;	O
arr	pointer
=	O
look_up	function
(	O
t_image	O
,	O
0	int
,	O
t_ssn	O
)	O
;	O
if	O
(	O
second_pass	int
&&	O
!	O
(	O
arr	pointer
->	O
flags	int
&	O
F_ARRAY	int
)	O
)	O
error	function
(	O
"invalid use of `%s' as array identifier"	pointer
,	O
arr	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
code	int
->	O
lval	int
=	O
1	int
;	O
code	int
->	O
type	int
=	O
arr	pointer
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
)	O
;	O
append	function
(	O
code	int
,	O
"(*%s("	pointer
,	O
code	int
->	O
type	int
==	O
F_REAL	int
?	O
a_loc_real	pointer
:	O
code	int
->	O
type	int
==	O
F_INT	int
?	O
a_loc_int	pointer
:	O
a_loc_bool	pointer
)	O
;	O
if	O
(	O
arr	pointer
->	O
flags	int
&	O
F_OWN	int
)	O
{	O
append	function
(	O
code	int
,	O
"%s_%d, ?, "	pointer
,	O
arr	pointer
->	O
name	pointer
,	O
arr	pointer
->	O
block	pointer
->	O
seqn	int
)	O
;	O
}	O
else	O
{	O
append	function
(	O
code	int
,	O
"dsa_%d->%s_%d, ?, "	pointer
,	O
dsa_level	function
(	O
arr	pointer
)	O
,	O
arr	pointer
->	O
name	pointer
,	O
arr	pointer
->	O
block	pointer
->	O
seqn	int
)	O
;	O
}	O
place	pointer
=	O
strchr	function
(	O
code	int
->	O
tail	pointer
->	O
str	pointer
,	O
'?'	O
)	O
;	O
assert	O
(	O
place	pointer
)	O
;	O
}	O
get_token	function
(	O
)	O
;	O
assert	O
(	O
t_delim	O
(	O
S_BEGSUB	int
)	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
CODE	struct
*	O
expr	pointer
;	O
if	O
(	O
dim	int
==	O
9	int
)	O
{	O
error	function
(	O
"number of subscripts exceeds allowable maximum"	pointer
)	O
;	O
dim	int
=	O
0	int
;	O
}	O
get_token	function
(	O
)	O
;	O
expr	pointer
=	O
expression	function
(	O
)	O
,	O
to_int	function
(	O
expr	pointer
)	O
;	O
if	O
(	O
second_pass	int
&&	O
expr	pointer
->	O
type	int
!=	O
F_INT	int
)	O
{	O
error	function
(	O
"invalid type of subscript expression"	pointer
)	O
;	O
expr	pointer
->	O
type	int
=	O
F_INT	int
;	O
}	O
catenate	function
(	O
code	int
,	O
expr	pointer
)	O
;	O
dim	int
++	O
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_COMMA	int
)	O
)	O
break	O
;	O
append	function
(	O
code	int
,	O
", "	pointer
)	O
;	O
}	O
if	O
(	O
!	O
t_delim	O
(	O
S_ENDSUB	int
)	O
)	O
error	function
(	O
"missing right parenthesis in subscripted variable"	pointer
)	O
;	O
if	O
(	O
arr	pointer
->	O
dim	int
<	O
0	int
)	O
arr	pointer
->	O
dim	int
=	O
dim	int
;	O
if	O
(	O
second_pass	int
&&	O
(	O
arr	pointer
->	O
flags	int
&	O
F_ARRAY	int
)	O
&&	O
arr	pointer
->	O
dim	int
!=	O
dim	int
)	O
{	O
if	O
(	O
arr	pointer
->	O
flags	int
&	O
(	O
F_BYVAL	int
|	O
F_BYNAME	int
)	O
)	O
error	function
(	O
"number of subscripts in subscripted variable conflic"	pointer
"ts with earlier use of array `%s'"	pointer
,	O
arr	pointer
->	O
name	pointer
)	O
;	O
else	O
error	function
(	O
"number of subscripts in subscripted variable conflic"	pointer
"ts with declaration of array `%s' at line %d"	pointer
,	O
arr	pointer
->	O
name	pointer
,	O
arr	pointer
->	O
ssn_decl	int
)	O
;	O
}	O
if	O
(	O
t_delim	O
(	O
S_ENDSUB	int
)	O
)	O
get_token	function
(	O
)	O
;	O
assert	O
(	O
1	int
<=	O
dim	int
&&	O
dim	int
<=	O
9	int
)	O
;	O
if	O
(	O
second_pass	int
)	O
*	O
place	pointer
=	O
(	O
char	O
)	O
(	O
dim	int
+	O
'0'	O
)	O
;	O
append	function
(	O
code	int
,	O
"))"	pointer
)	O
;	O
return	O
code	int
;	O
}	O
static	O
CODE	struct
*	O
switch_designator	function
(	O
void	O
)	O
{	O
CODE	struct
*	O
code	int
;	O
IDENT	struct
*	O
swit	pointer
;	O
int	O
dim	int
=	O
0	int
;	O
assert	O
(	O
second_pass	int
)	O
;	O
assert	O
(	O
t_code	O
==	O
T_IDENT	int
)	O
;	O
swit	pointer
=	O
look_up	function
(	O
t_image	O
,	O
0	int
,	O
t_ssn	O
)	O
;	O
assert	O
(	O
swit	pointer
->	O
flags	int
&	O
F_SWITCH	int
)	O
;	O
get_token	function
(	O
)	O
;	O
assert	O
(	O
t_delim	O
(	O
S_BEGSUB	int
)	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
dim	int
==	O
1	int
)	O
error	function
(	O
"invalid number of subscripts in switch designator fo"	pointer
"r `%s'"	pointer
,	O
swit	pointer
->	O
name	pointer
)	O
;	O
get_token	function
(	O
)	O
;	O
code	int
=	O
expression	function
(	O
)	O
,	O
to_int	function
(	O
code	int
)	O
;	O
if	O
(	O
code	int
->	O
type	int
!=	O
F_INT	int
)	O
{	O
error	function
(	O
"invalid type of subscript expression"	pointer
)	O
;	O
code	int
->	O
type	int
=	O
F_INT	int
;	O
}	O
dim	int
++	O
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_COMMA	int
)	O
)	O
break	O
;	O
}	O
assert	O
(	O
t_delim	O
(	O
S_ENDSUB	int
)	O
)	O
;	O
get_token	function
(	O
)	O
;	O
code	int
->	O
lval	int
=	O
0	int
;	O
code	int
->	O
type	int
=	O
F_LABEL	int
;	O
if	O
(	O
swit	pointer
->	O
flags	int
&	O
F_BYNAME	int
)	O
{	O
prepend	function
(	O
code	int
,	O
"("	pointer
a_global_dsa	pointer
" = dsa_%d->%s_%d.arg2, (*(stru"	pointer
"ct label (*)(int))dsa_%d->%s_%d.arg1)("	pointer
,	O
dsa_level	function
(	O
swit	pointer
)	O
,	O
swit	pointer
->	O
name	pointer
,	O
swit	pointer
->	O
block	pointer
->	O
seqn	int
,	O
dsa_level	function
(	O
swit	pointer
)	O
,	O
swit	pointer
->	O
name	pointer
,	O
swit	pointer
->	O
block	pointer
->	O
seqn	int
)	O
;	O
}	O
else	O
{	O
prepend	function
(	O
code	int
,	O
"("	pointer
a_global_dsa	pointer
" = (void *)dsa_%d, %s_%d("	pointer
,	O
current_level	function
(	O
)	O
,	O
swit	pointer
->	O
name	pointer
,	O
swit	pointer
->	O
block	pointer
->	O
seqn	int
)	O
;	O
}	O
append	function
(	O
code	int
,	O
"))"	pointer
)	O
;	O
return	O
code	int
;	O
}	O
static	O
CODE	struct
*	O
emit	pointer
=	O
NULL	O
;	O
static	O
void	O
emit_dsa_pointers	function
(	O
void	O
)	O
{	O
BLOCK	struct
*	O
b	pointer
;	O
int	O
level	int
=	O
current_level	function
(	O
)	O
;	O
for	O
(	O
b	pointer
=	O
current	pointer
;	O
b	pointer
!=	O
NULL	O
;	O
b	pointer
=	O
b	pointer
->	O
surr	pointer
)	O
{	O
if	O
(	O
b	pointer
->	O
proc	pointer
==	O
NULL	O
)	O
continue	O
;	O
append	function
(	O
emit	pointer
,	O
"      register struct dsa_%s_%d *dsa_%d = (vo"	pointer
"id *)"	pointer
a_global_dsa	pointer
"->vector[%d];\n"	pointer
,	O
b	pointer
->	O
proc	pointer
->	O
name	pointer
,	O
b	pointer
->	O
proc	pointer
->	O
block	pointer
->	O
seqn	int
,	O
level	int
,	O
level	int
)	O
;	O
level	int
--	O
;	O
}	O
return	O
;	O
}	O
static	O
int	O
thunk_count	int
=	O
0	int
;	O
static	O
int	O
thunk_real0	int
=	O
0	int
;	O
static	O
int	O
thunk_real1	int
=	O
0	int
;	O
static	O
int	O
thunk_int0	int
=	O
0	int
;	O
static	O
int	O
thunk_int1	int
=	O
0	int
;	O
static	O
int	O
thunk_false	int
=	O
0	int
;	O
static	O
int	O
thunk_true	int
=	O
0	int
;	O
static	O
CODE	struct
*	O
emit_ssn	function
(	O
int	O
ssn	int
)	O
;	O
static	O
CODE	struct
*	O
actual_parameter	function
(	O
IDENT	struct
*	O
arg	array
)	O
{	O
CODE	struct
*	O
code	int
=	O
new_code	function
(	O
)	O
;	O
if	O
(	O
t_code	O
==	O
T_STRING	int
)	O
{	O
if	O
(	O
second_pass	int
&&	O
arg	array
!=	O
NULL	O
&&	O
!	O
(	O
arg	array
->	O
flags	int
&	O
F_STRING	int
)	O
)	O
{	O
error	function
(	O
"string passed as actual parameter conflicts with kin"	pointer
"d of formal parameter `%s' as specified in declaration "	pointer
"of procedure `%s' beginning at line %d"	pointer
,	O
arg	array
->	O
name	pointer
,	O
arg	array
->	O
block	pointer
->	O
proc	pointer
->	O
name	pointer
,	O
arg	array
->	O
block	pointer
->	O
proc	pointer
->	O
ssn_decl	int
)	O
;	O
goto	O
skip1	O
;	O
}	O
append	function
(	O
code	int
,	O
a_make_arg	pointer
"("	pointer
)	O
;	O
append	function
(	O
code	int
,	O
t_image	O
)	O
;	O
append	function
(	O
code	int
,	O
", NULL)"	pointer
)	O
;	O
skip1	O
:	O
get_token	function
(	O
)	O
;	O
goto	O
done	O
;	O
}	O
get_token2	function
(	O
)	O
;	O
if	O
(	O
t_code	O
==	O
T_IDENT	int
&&	O
token	array
[	O
2	int
]	O
.	O
code	int
==	O
T_DELIM	int
&&	O
(	O
token	array
[	O
2	int
]	O
.	O
delim	int
==	O
S_COMMA	int
||	O
token	array
[	O
2	int
]	O
.	O
delim	int
==	O
S_RIGHT	int
)	O
)	O
{	O
IDENT	struct
*	O
id	pointer
=	O
look_up	function
(	O
t_image	O
,	O
0	int
,	O
t_ssn	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
id	pointer
->	O
flags	int
==	O
(	O
F_REAL	int
|	O
F_BYNAME	int
)	O
||	O
id	pointer
->	O
flags	int
==	O
(	O
F_INT	int
|	O
F_BYNAME	int
)	O
||	O
id	pointer
->	O
flags	int
==	O
(	O
F_BOOL	int
|	O
F_BYNAME	int
)	O
)	O
{	O
if	O
(	O
arg	array
!=	O
NULL	O
)	O
{	O
int	O
actual_type	int
,	O
formal_type	int
;	O
if	O
(	O
arg	array
->	O
flags	int
&	O
~	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
|	O
F_BYVAL	int
|	O
F_BYNAME	int
)	O
)	O
{	O
error	function
(	O
"formal parameter `%s' called by name and pa"	pointer
"ssed as actual parameter conflicts with kind o"	pointer
"f formal parameter `%s' as specified in declar"	pointer
"ation of procedure `%s' beginning at line %d"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
arg	array
->	O
name	pointer
,	O
arg	array
->	O
block	pointer
->	O
proc	pointer
->	O
name	pointer
,	O
arg	array
->	O
block	pointer
->	O
proc	pointer
->	O
ssn_decl	int
)	O
;	O
goto	O
skip1a	O
;	O
}	O
actual_type	int
=	O
id	pointer
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
)	O
;	O
formal_type	int
=	O
arg	array
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
)	O
;	O
if	O
(	O
actual_type	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
)	O
)	O
{	O
actual_type	int
&=	O
~	O
(	O
F_REAL	int
|	O
F_INT	int
)	O
;	O
formal_type	int
&=	O
~	O
(	O
F_REAL	int
|	O
F_INT	int
)	O
;	O
}	O
if	O
(	O
actual_type	int
!=	O
formal_type	int
)	O
{	O
error	function
(	O
"type of formal parameter `%s' called by nam"	pointer
"e and passed as actual parameter conflicts wit"	pointer
"h type of formal parameter `%s' as specified i"	pointer
"n declaration of procedure `%s' beginning at l"	pointer
"ine %d"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
arg	array
->	O
name	pointer
,	O
arg	array
->	O
block	pointer
->	O
proc	pointer
->	O
name	pointer
,	O
arg	array
->	O
block	pointer
->	O
proc	pointer
->	O
ssn_decl	int
)	O
;	O
goto	O
skip1a	O
;	O
}	O
}	O
append	function
(	O
code	int
,	O
"dsa_%d->%s_%d"	pointer
,	O
dsa_level	function
(	O
id	pointer
)	O
,	O
id	pointer
->	O
name	pointer
,	O
id	pointer
->	O
block	pointer
->	O
seqn	int
)	O
;	O
skip1a	O
:	O
get_token	function
(	O
)	O
;	O
goto	O
done	O
;	O
}	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_ARRAY	int
)	O
{	O
if	O
(	O
arg	array
!=	O
NULL	O
)	O
{	O
int	O
actual_type	int
,	O
formal_type	int
;	O
if	O
(	O
!	O
(	O
arg	array
->	O
flags	int
&	O
F_ARRAY	int
)	O
)	O
{	O
error	function
(	O
"array `%s' passed as actual parameter confl"	pointer
"icts with kind of formal parameter `%s' as spe"	pointer
"cified in declaration of procedure `%s' beginn"	pointer
"ing at line %d"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
arg	array
->	O
name	pointer
,	O
arg	array
->	O
block	pointer
->	O
proc	pointer
->	O
name	pointer
,	O
arg	array
->	O
block	pointer
->	O
proc	pointer
->	O
ssn_decl	int
)	O
;	O
goto	O
skip2	O
;	O
}	O
actual_type	int
=	O
id	pointer
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
)	O
;	O
formal_type	int
=	O
arg	array
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
)	O
;	O
if	O
(	O
arg	array
->	O
flags	int
&	O
F_BYVAL	int
)	O
{	O
actual_type	int
&=	O
~	O
(	O
F_REAL	int
|	O
F_INT	int
)	O
;	O
formal_type	int
&=	O
~	O
(	O
F_REAL	int
|	O
F_INT	int
)	O
;	O
}	O
if	O
(	O
actual_type	int
!=	O
formal_type	int
)	O
{	O
error	function
(	O
"type of array `%s' passed as actual paramet"	pointer
"er conflicts with type of formal array `%s' as"	pointer
" specified in declaration of procedure `%s' be"	pointer
"ginning at line %d"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
arg	array
->	O
name	pointer
,	O
arg	array
->	O
block	pointer
->	O
proc	pointer
->	O
name	pointer
,	O
arg	array
->	O
block	pointer
->	O
proc	pointer
->	O
ssn_decl	int
)	O
;	O
goto	O
skip2	O
;	O
}	O
if	O
(	O
id	pointer
->	O
dim	int
>=	O
0	int
&&	O
arg	array
->	O
dim	int
>=	O
0	int
&&	O
id	pointer
->	O
dim	int
!=	O
arg	array
->	O
dim	int
)	O
{	O
error	function
(	O
"dimension of array `%s' passed as actual pa"	pointer
"rameter not equal to dimension of formal array"	pointer
" `%s' as implied in declaration of procedure `"	pointer
"%s' beginning at line %d"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
arg	array
->	O
name	pointer
,	O
arg	array
->	O
block	pointer
->	O
proc	pointer
->	O
name	pointer
,	O
arg	array
->	O
block	pointer
->	O
proc	pointer
->	O
ssn_decl	int
)	O
;	O
goto	O
skip2	O
;	O
}	O
}	O
if	O
(	O
!	O
(	O
id	pointer
->	O
flags	int
&	O
F_OWN	int
)	O
)	O
{	O
append	function
(	O
code	int
,	O
a_make_arg	pointer
"(dsa_%d->%s_%d"	pointer
,	O
dsa_level	function
(	O
id	pointer
)	O
,	O
id	pointer
->	O
name	pointer
,	O
id	pointer
->	O
block	pointer
->	O
seqn	int
)	O
;	O
}	O
else	O
{	O
append	function
(	O
code	int
,	O
a_make_arg	pointer
"(%s_%d"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
id	pointer
->	O
block	pointer
->	O
seqn	int
)	O
;	O
}	O
append	function
(	O
code	int
,	O
", (void *)'%c')"	pointer
,	O
(	O
id	pointer
->	O
flags	int
&	O
F_REAL	int
)	O
?	O
'r'	O
:	O
(	O
id	pointer
->	O
flags	int
&	O
F_INT	int
)	O
?	O
'i'	O
:	O
(	O
id	pointer
->	O
flags	int
&	O
F_BOOL	int
)	O
?	O
'b'	O
:	O
'?'	O
)	O
;	O
skip2	O
:	O
get_token	function
(	O
)	O
;	O
goto	O
done	O
;	O
}	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_SWITCH	int
)	O
{	O
if	O
(	O
arg	array
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
(	O
arg	array
->	O
flags	int
&	O
F_SWITCH	int
)	O
)	O
{	O
error	function
(	O
"switch `%s' passed as actual parameter conf"	pointer
"licts with kind of formal parameter `%s' as sp"	pointer
"ecified in declaration of procedure `%s' begin"	pointer
"ning at line %d"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
arg	array
->	O
name	pointer
,	O
arg	array
->	O
block	pointer
->	O
proc	pointer
->	O
name	pointer
,	O
arg	array
->	O
block	pointer
->	O
proc	pointer
->	O
ssn_decl	int
)	O
;	O
goto	O
skip3	O
;	O
}	O
}	O
if	O
(	O
!	O
(	O
id	pointer
->	O
flags	int
&	O
F_BYNAME	int
)	O
)	O
{	O
append	function
(	O
code	int
,	O
a_make_arg	pointer
"((void *)%s_%d, dsa_%d)"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
id	pointer
->	O
block	pointer
->	O
seqn	int
,	O
current_level	function
(	O
)	O
)	O
;	O
}	O
else	O
{	O
append	function
(	O
code	int
,	O
"dsa_%d->%s_%d"	pointer
,	O
dsa_level	function
(	O
id	pointer
)	O
,	O
id	pointer
->	O
name	pointer
,	O
id	pointer
->	O
block	pointer
->	O
seqn	int
)	O
;	O
}	O
skip3	O
:	O
get_token	function
(	O
)	O
;	O
goto	O
done	O
;	O
}	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_PROC	int
)	O
{	O
if	O
(	O
arg	array
!=	O
NULL	O
)	O
{	O
int	O
simple	int
=	O
!	O
(	O
arg	array
->	O
flags	int
&	O
~	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
|	O
F_BYVAL	int
|	O
F_BYNAME	int
)	O
)	O
;	O
int	O
actual_type	int
,	O
formal_type	int
;	O
if	O
(	O
!	O
(	O
simple	int
||	O
(	O
arg	array
->	O
flags	int
&	O
F_PROC	int
)	O
)	O
)	O
{	O
error	function
(	O
"procedure `%s' passed as actual parameter c"	pointer
"onflicts with kind of formal parameter `%s' as"	pointer
" specified in declaration of procedure `%s' be"	pointer
"ginning at line %d"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
arg	array
->	O
name	pointer
,	O
arg	array
->	O
block	pointer
->	O
proc	pointer
->	O
name	pointer
,	O
arg	array
->	O
block	pointer
->	O
proc	pointer
->	O
ssn_decl	int
)	O
;	O
goto	O
skip4	O
;	O
}	O
actual_type	int
=	O
id	pointer
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
)	O
;	O
formal_type	int
=	O
arg	array
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
)	O
;	O
if	O
(	O
actual_type	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
)	O
)	O
{	O
actual_type	int
&=	O
~	O
(	O
F_REAL	int
|	O
F_INT	int
)	O
;	O
formal_type	int
&=	O
~	O
(	O
F_REAL	int
|	O
F_INT	int
)	O
;	O
}	O
if	O
(	O
!	O
simple	int
)	O
goto	O
proc	pointer
;	O
if	O
(	O
!	O
(	O
id	pointer
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
)	O
)	O
||	O
id	pointer
->	O
dim	int
>	O
0	int
)	O
{	O
error	function
(	O
"procedure identifier `%s' that is not in it"	pointer
"self a complete expression and passed as actua"	pointer
"l parameter conflicts with kind of formal para"	pointer
"meter `%s' as specified in declaration of proc"	pointer
"edure `%s' beginning at line %d"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
arg	array
->	O
name	pointer
,	O
arg	array
->	O
block	pointer
->	O
proc	pointer
->	O
name	pointer
,	O
arg	array
->	O
block	pointer
->	O
proc	pointer
->	O
ssn_decl	int
)	O
;	O
goto	O
skip4	O
;	O
}	O
if	O
(	O
actual_type	int
!=	O
formal_type	int
)	O
{	O
error	function
(	O
"procedure identifier `%s' that is in itself"	pointer
" a complete expression and passed as actual pa"	pointer
"rameter conflicts with type of formal paramete"	pointer
"r `%s' as specified in declaration of procedur"	pointer
"e `%s' beginning at line %d"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
arg	array
->	O
name	pointer
,	O
arg	array
->	O
block	pointer
->	O
proc	pointer
->	O
name	pointer
,	O
arg	array
->	O
block	pointer
->	O
proc	pointer
->	O
ssn_decl	int
)	O
;	O
goto	O
skip4	O
;	O
}	O
goto	O
gen1	O
;	O
proc	pointer
:	O
if	O
(	O
actual_type	int
!=	O
formal_type	int
&&	O
formal_type	int
)	O
{	O
error	function
(	O
"type of procedure `%s' passed as actual par"	pointer
"ameter conflicts with type of formal procedure"	pointer
" `%s' as specified in declaration of procedure"	pointer
" `%s' beginning at line %d"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
arg	array
->	O
name	pointer
,	O
arg	array
->	O
block	pointer
->	O
proc	pointer
->	O
name	pointer
,	O
arg	array
->	O
block	pointer
->	O
proc	pointer
->	O
ssn_decl	int
)	O
;	O
goto	O
skip4	O
;	O
}	O
if	O
(	O
id	pointer
->	O
dim	int
>=	O
0	int
&&	O
arg	array
->	O
dim	int
>=	O
0	int
&&	O
id	pointer
->	O
dim	int
!=	O
arg	array
->	O
dim	int
)	O
{	O
error	function
(	O
"number of parameters of procedure `%s' pass"	pointer
"ed as actual parameter not equal to number of "	pointer
"parameters of formal procedure `%s' as implied"	pointer
" in declaration of procedure `%s' beginning at"	pointer
" line %d"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
arg	array
->	O
name	pointer
,	O
arg	array
->	O
block	pointer
->	O
proc	pointer
->	O
name	pointer
,	O
arg	array
->	O
block	pointer
->	O
proc	pointer
->	O
ssn_decl	int
)	O
;	O
goto	O
skip4	O
;	O
}	O
}	O
gen1	O
:	O
if	O
(	O
!	O
(	O
id	pointer
->	O
flags	int
&	O
F_BYNAME	int
)	O
)	O
{	O
append	function
(	O
code	int
,	O
a_make_arg	pointer
"((void *)%s_%d, dsa_%d)"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
id	pointer
->	O
block	pointer
->	O
seqn	int
,	O
current_level	function
(	O
)	O
)	O
;	O
}	O
else	O
{	O
append	function
(	O
code	int
,	O
"dsa_%d->%s_%d"	pointer
,	O
dsa_level	function
(	O
id	pointer
)	O
,	O
id	pointer
->	O
name	pointer
,	O
id	pointer
->	O
block	pointer
->	O
seqn	int
)	O
;	O
}	O
skip4	O
:	O
get_token	function
(	O
)	O
;	O
goto	O
done	O
;	O
}	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_STRING	int
)	O
{	O
if	O
(	O
arg	array
!=	O
NULL	O
&&	O
!	O
(	O
arg	array
->	O
flags	int
&	O
F_STRING	int
)	O
)	O
{	O
error	function
(	O
"formal string passed as actual parameter confl"	pointer
"icts with kind of formal parameter `%s' as specif"	pointer
"ied in declaration of procedure `%s' beginning at"	pointer
" line %d"	pointer
,	O
arg	array
->	O
name	pointer
,	O
arg	array
->	O
block	pointer
->	O
proc	pointer
->	O
name	pointer
,	O
arg	array
->	O
block	pointer
->	O
proc	pointer
->	O
ssn_decl	int
)	O
;	O
goto	O
skip5	O
;	O
}	O
append	function
(	O
code	int
,	O
a_make_arg	pointer
"(dsa_%d->%s_%d, NULL)"	pointer
,	O
dsa_level	function
(	O
id	pointer
)	O
,	O
id	pointer
->	O
name	pointer
,	O
id	pointer
->	O
block	pointer
->	O
seqn	int
)	O
;	O
skip5	O
:	O
get_token	function
(	O
)	O
;	O
goto	O
done	O
;	O
}	O
}	O
}	O
{	O
CODE	struct
*	O
expr	pointer
;	O
int	O
need_dsa	int
=	O
1	int
,	O
thunk	int
,	O
ssn	int
;	O
if	O
(	O
(	O
t_code	O
==	O
T_REAL	int
||	O
t_code	O
==	O
T_INT	int
||	O
t_code	O
==	O
T_FALSE	int
||	O
t_code	O
==	O
T_TRUE	int
)	O
&&	O
token	array
[	O
2	int
]	O
.	O
code	int
==	O
T_DELIM	int
&&	O
(	O
token	array
[	O
2	int
]	O
.	O
delim	int
==	O
S_COMMA	int
||	O
token	array
[	O
2	int
]	O
.	O
delim	int
==	O
S_RIGHT	int
)	O
)	O
{	O
need_dsa	int
=	O
0	int
;	O
if	O
(	O
second_pass	int
&&	O
t_code	O
==	O
T_REAL	int
)	O
{	O
if	O
(	O
strcmp	function
(	O
t_image	O
,	O
"0.0"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
t_image	O
,	O
".0"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
thunk_real0	int
!=	O
0	int
)	O
{	O
thunk	int
=	O
thunk_real0	int
,	O
get_token	function
(	O
)	O
;	O
goto	O
gen2	O
;	O
}	O
else	O
thunk_real0	int
=	O
thunk_count	int
+	O
1	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
t_image	O
,	O
"1.0"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
thunk_real1	int
!=	O
0	int
)	O
{	O
thunk	int
=	O
thunk_real1	int
,	O
get_token	function
(	O
)	O
;	O
goto	O
gen2	O
;	O
}	O
else	O
thunk_real1	int
=	O
thunk_count	int
+	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
second_pass	int
&&	O
t_code	O
==	O
T_INT	int
)	O
{	O
if	O
(	O
strcmp	function
(	O
t_image	O
,	O
"0"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
thunk_int0	int
!=	O
0	int
)	O
{	O
thunk	int
=	O
thunk_int0	int
,	O
get_token	function
(	O
)	O
;	O
goto	O
gen2	O
;	O
}	O
else	O
thunk_int0	int
=	O
thunk_count	int
+	O
1	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
t_image	O
,	O
"1"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
thunk_int1	int
!=	O
0	int
)	O
{	O
thunk	int
=	O
thunk_int1	int
,	O
get_token	function
(	O
)	O
;	O
goto	O
gen2	O
;	O
}	O
else	O
thunk_int1	int
=	O
thunk_count	int
+	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
second_pass	int
&&	O
t_code	O
==	O
T_FALSE	int
)	O
{	O
if	O
(	O
thunk_false	int
!=	O
0	int
)	O
{	O
thunk	int
=	O
thunk_false	int
,	O
get_token	function
(	O
)	O
;	O
goto	O
gen2	O
;	O
}	O
else	O
thunk_false	int
=	O
thunk_count	int
+	O
1	int
;	O
}	O
else	O
if	O
(	O
second_pass	int
&&	O
t_code	O
==	O
T_TRUE	int
)	O
{	O
if	O
(	O
thunk_true	int
!=	O
0	int
)	O
{	O
thunk	int
=	O
thunk_true	int
,	O
get_token	function
(	O
)	O
;	O
goto	O
gen2	O
;	O
}	O
else	O
thunk_true	int
=	O
thunk_count	int
+	O
1	int
;	O
}	O
}	O
ssn	int
=	O
t_ssn	O
;	O
expr	pointer
=	O
expression	function
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
arg	array
!=	O
NULL	O
)	O
{	O
int	O
actual_type	int
,	O
formal_type	int
;	O
if	O
(	O
arg	array
->	O
flags	int
&	O
~	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
|	O
F_LABEL	int
|	O
F_BYVAL	int
|	O
F_BYNAME	int
)	O
)	O
{	O
error	function
(	O
"expression passed as actual parameter conflict"	pointer
"s with kind of formal parameter `%s' as specified"	pointer
" in declaration of procedure `%s' beginning at li"	pointer
"ne %d"	pointer
,	O
arg	array
->	O
name	pointer
,	O
arg	array
->	O
block	pointer
->	O
proc	pointer
->	O
name	pointer
,	O
arg	array
->	O
block	pointer
->	O
proc	pointer
->	O
ssn_decl	int
)	O
;	O
goto	O
skip6	O
;	O
}	O
actual_type	int
=	O
expr	pointer
->	O
type	int
;	O
formal_type	int
=	O
arg	array
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
|	O
F_LABEL	int
)	O
;	O
if	O
(	O
actual_type	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
)	O
)	O
{	O
actual_type	int
&=	O
~	O
(	O
F_REAL	int
|	O
F_INT	int
)	O
;	O
formal_type	int
&=	O
~	O
(	O
F_REAL	int
|	O
F_INT	int
)	O
;	O
}	O
if	O
(	O
actual_type	int
!=	O
formal_type	int
)	O
{	O
error	function
(	O
"type of expression passed as actual parameter "	pointer
"conflicts with type of formal parameter `%s' as s"	pointer
"pecified in declaration of procedure `%s' beginni"	pointer
"ng at line %d"	pointer
,	O
arg	array
->	O
name	pointer
,	O
arg	array
->	O
block	pointer
->	O
proc	pointer
->	O
name	pointer
,	O
arg	array
->	O
block	pointer
->	O
proc	pointer
->	O
ssn_decl	int
)	O
;	O
goto	O
skip6	O
;	O
}	O
}	O
thunk_count	int
++	O
;	O
append	function
(	O
emit	pointer
,	O
"static struct desc _thunk_%d(void)\n"	pointer
,	O
thunk_count	int
)	O
;	O
append	function
(	O
emit	pointer
,	O
"{     /* actual parameter at line %d */\n"	pointer
,	O
ssn	int
)	O
;	O
append	function
(	O
emit	pointer
,	O
"      struct desc res;\n"	pointer
)	O
;	O
if	O
(	O
need_dsa	int
)	O
{	O
emit_dsa_pointers	function
(	O
)	O
;	O
catenate	function
(	O
emit	pointer
,	O
emit_ssn	function
(	O
ssn	int
)	O
)	O
;	O
}	O
append	function
(	O
emit	pointer
,	O
"      res.lval = %d;\n"	pointer
,	O
expr	pointer
->	O
lval	int
)	O
;	O
switch	O
(	O
expr	pointer
->	O
type	int
)	O
{	O
case	O
F_REAL	int
:	O
append	function
(	O
emit	pointer
,	O
"      res.type = 'r';\n"	pointer
)	O
;	O
if	O
(	O
expr	pointer
->	O
lval	int
)	O
append	function
(	O
emit	pointer
,	O
"      res.u.real_ptr = "	pointer
)	O
;	O
else	O
append	function
(	O
emit	pointer
,	O
"      res.u.real_val = "	pointer
)	O
;	O
break	O
;	O
case	O
F_INT	int
:	O
append	function
(	O
emit	pointer
,	O
"      res.type = 'i';\n"	pointer
)	O
;	O
if	O
(	O
expr	pointer
->	O
lval	int
)	O
append	function
(	O
emit	pointer
,	O
"      res.u.int_ptr = "	pointer
)	O
;	O
else	O
append	function
(	O
emit	pointer
,	O
"      res.u.int_val = "	pointer
)	O
;	O
break	O
;	O
case	O
F_BOOL	int
:	O
append	function
(	O
emit	pointer
,	O
"      res.type = 'b';\n"	pointer
)	O
;	O
if	O
(	O
expr	pointer
->	O
lval	int
)	O
append	function
(	O
emit	pointer
,	O
"      res.u.bool_ptr = "	pointer
)	O
;	O
else	O
append	function
(	O
emit	pointer
,	O
"      res.u.bool_val = "	pointer
)	O
;	O
break	O
;	O
case	O
F_LABEL	int
:	O
append	function
(	O
emit	pointer
,	O
"      res.type = 'l';\n"	pointer
)	O
;	O
append	function
(	O
emit	pointer
,	O
"      res.u.label = "	pointer
)	O
;	O
break	O
;	O
default	O
:	O
assert	O
(	O
expr	pointer
->	O
type	int
!=	O
expr	pointer
->	O
type	int
)	O
;	O
}	O
if	O
(	O
expr	pointer
->	O
lval	int
)	O
{	O
append	function
(	O
emit	pointer
,	O
"&("	pointer
)	O
;	O
catenate	function
(	O
emit	pointer
,	O
expr	pointer
)	O
;	O
append	function
(	O
emit	pointer
,	O
")"	pointer
)	O
;	O
}	O
else	O
catenate	function
(	O
emit	pointer
,	O
expr	pointer
)	O
;	O
append	function
(	O
emit	pointer
,	O
";\n"	pointer
)	O
;	O
append	function
(	O
emit	pointer
,	O
"      return res;\n"	pointer
)	O
;	O
append	function
(	O
emit	pointer
,	O
"}\n"	pointer
)	O
;	O
append	function
(	O
emit	pointer
,	O
"\n"	pointer
)	O
;	O
thunk	int
=	O
thunk_count	int
;	O
gen2	O
:	O
append	function
(	O
code	int
,	O
a_make_arg	pointer
"((void *)_thunk_%d, dsa_%d)"	pointer
,	O
thunk	int
,	O
current_level	function
(	O
)	O
)	O
;	O
skip6	O
:	O
;	O
}	O
}	O
done	O
:	O
return	O
code	int
;	O
}	O
static	O
int	O
ext_comma	function
(	O
void	O
)	O
{	O
if	O
(	O
t_delim	O
(	O
S_COMMA	int
)	O
)	O
{	O
get_token	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
t_delim	O
(	O
S_RIGHT	int
)	O
)	O
{	O
get_token2	function
(	O
)	O
;	O
if	O
(	O
token	array
[	O
2	int
]	O
.	O
code	int
!=	O
T_IDENT	int
)	O
return	O
0	int
;	O
get_token	function
(	O
)	O
;	O
assert	O
(	O
t_code	O
==	O
T_IDENT	int
)	O
;	O
{	O
char	O
*	O
t	pointer
;	O
for	O
(	O
t	pointer
=	O
t_image	O
;	O
*	O
t	pointer
;	O
t	pointer
++	O
)	O
{	O
if	O
(	O
!	O
isalpha	function
(	O
*	O
t	pointer
)	O
)	O
{	O
error	function
(	O
"invalid letter string in parameter delimiter"	pointer
)	O
;	O
break	O
;	O
}	O
}	O
}	O
get_token	function
(	O
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_COLON	int
)	O
)	O
get_token	function
(	O
)	O
;	O
else	O
error	function
(	O
"missing colon in parameter delimiter"	pointer
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_LEFT	int
)	O
)	O
get_token	function
(	O
)	O
;	O
else	O
error	function
(	O
"missing left parenthesis in parameter delimiter"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
CODE	struct
*	O
function_designator	function
(	O
int	O
stmt	int
)	O
{	O
IDENT	struct
*	O
proc	pointer
;	O
IDENT	struct
*	O
arg	array
=	O
NULL	O
;	O
CODE	struct
*	O
code	int
=	O
new_code	function
(	O
)	O
;	O
int	O
list	int
;	O
int	O
dim	int
=	O
0	int
;	O
assert	O
(	O
t_code	O
==	O
T_IDENT	int
)	O
;	O
proc	pointer
=	O
look_up	function
(	O
t_image	O
,	O
0	int
,	O
t_ssn	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
!	O
(	O
proc	pointer
->	O
flags	int
&	O
F_PROC	int
)	O
)	O
error	function
(	O
"invalid use of `%s' as procedure identifier"	pointer
,	O
proc	pointer
->	O
name	pointer
)	O
;	O
code	int
->	O
lval	int
=	O
0	int
;	O
code	int
->	O
type	int
=	O
proc	pointer
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
)	O
;	O
if	O
(	O
(	O
proc	pointer
->	O
flags	int
&	O
F_BLTIN	int
)	O
&&	O
(	O
strcmp	function
(	O
proc	pointer
->	O
name	pointer
,	O
"inline"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
proc	pointer
->	O
name	pointer
,	O
"print"	pointer
)	O
==	O
0	int
)	O
)	O
{	O
error	function
(	O
"invalid use of pseudo procedure `%s' in function des"	pointer
"ignator"	pointer
,	O
proc	pointer
->	O
name	pointer
)	O
;	O
}	O
else	O
if	O
(	O
(	O
proc	pointer
->	O
flags	int
&	O
F_PROC	int
)	O
&&	O
code	int
->	O
type	int
==	O
0	int
&&	O
!	O
stmt	int
)	O
{	O
error	function
(	O
"invalid use of typeless procedure `%s' in function d"	pointer
"esignator"	pointer
,	O
proc	pointer
->	O
name	pointer
)	O
;	O
}	O
append	function
(	O
code	int
,	O
"%s("	pointer
,	O
(	O
code	int
->	O
type	int
&	O
F_REAL	int
)	O
?	O
a_get_real	pointer
:	O
(	O
code	int
->	O
type	int
&	O
F_INT	int
)	O
?	O
a_get_int	pointer
:	O
(	O
code	int
->	O
type	int
&	O
F_BOOL	int
)	O
?	O
a_get_bool	pointer
:	O
""	pointer
)	O
;	O
if	O
(	O
proc	pointer
->	O
flags	int
&	O
F_BYNAME	int
)	O
{	O
append	function
(	O
code	int
,	O
"("	pointer
a_global_dsa	pointer
" = dsa_%d->%s_%d.arg2, (*(st"	pointer
"ruct desc (*)())dsa_%d->%s_%d.arg1)("	pointer
,	O
dsa_level	function
(	O
proc	pointer
)	O
,	O
proc	pointer
->	O
name	pointer
,	O
proc	pointer
->	O
block	pointer
->	O
seqn	int
,	O
dsa_level	function
(	O
proc	pointer
)	O
,	O
proc	pointer
->	O
name	pointer
,	O
proc	pointer
->	O
block	pointer
->	O
seqn	int
)	O
;	O
}	O
else	O
{	O
append	function
(	O
code	int
,	O
"("	pointer
a_global_dsa	pointer
" = (void *)dsa_%d, %s_%d("	pointer
,	O
current_level	function
(	O
)	O
,	O
proc	pointer
->	O
name	pointer
,	O
proc	pointer
->	O
block	pointer
->	O
seqn	int
)	O
;	O
}	O
}	O
get_token	function
(	O
)	O
;	O
list	int
=	O
t_delim	O
(	O
S_LEFT	int
)	O
;	O
if	O
(	O
!	O
list	int
)	O
goto	O
skip	O
;	O
if	O
(	O
second_pass	int
&&	O
(	O
proc	pointer
->	O
flags	int
&	O
F_PROC	int
)	O
&&	O
!	O
(	O
proc	pointer
->	O
flags	int
&	O
F_BYNAME	int
)	O
)	O
{	O
BLOCK	struct
*	O
b	pointer
;	O
for	O
(	O
b	pointer
=	O
first_b	pointer
;	O
b	pointer
!=	O
NULL	O
;	O
b	pointer
=	O
b	pointer
->	O
next	pointer
)	O
if	O
(	O
b	pointer
->	O
proc	pointer
==	O
proc	pointer
)	O
break	O
;	O
assert	O
(	O
b	pointer
!=	O
NULL	O
)	O
;	O
arg	array
=	O
b	pointer
->	O
first	pointer
;	O
}	O
get_token	function
(	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
catenate	function
(	O
code	int
,	O
actual_parameter	function
(	O
arg	array
)	O
)	O
;	O
dim	int
++	O
;	O
if	O
(	O
!	O
ext_comma	function
(	O
)	O
)	O
break	O
;	O
append	function
(	O
code	int
,	O
", "	pointer
)	O
;	O
if	O
(	O
second_pass	int
&&	O
arg	array
!=	O
NULL	O
)	O
arg	array
=	O
arg	array
->	O
next	pointer
;	O
}	O
if	O
(	O
!	O
t_delim	O
(	O
S_RIGHT	int
)	O
)	O
error	function
(	O
"missing right parenthesis after actual parameter list"	pointer
)	O
;	O
skip	O
:	O
if	O
(	O
proc	pointer
->	O
dim	int
<	O
0	int
)	O
proc	pointer
->	O
dim	int
=	O
dim	int
;	O
if	O
(	O
second_pass	int
&&	O
(	O
proc	pointer
->	O
flags	int
&	O
F_PROC	int
)	O
&&	O
proc	pointer
->	O
dim	int
!=	O
dim	int
)	O
{	O
if	O
(	O
proc	pointer
->	O
flags	int
&	O
F_BYNAME	int
)	O
error	function
(	O
"number of parameters in function designator or proce"	pointer
"dure statement conflicts with earlier use of procedure "	pointer
"`%s'"	pointer
,	O
proc	pointer
->	O
name	pointer
)	O
;	O
else	O
error	function
(	O
"number of parameters in function designator or proce"	pointer
"dure statement conflicts with declaration of procedure "	pointer
"`%s' beginning at line %d"	pointer
,	O
proc	pointer
->	O
name	pointer
,	O
proc	pointer
->	O
ssn_decl	int
)	O
;	O
}	O
if	O
(	O
list	int
&&	O
t_delim	O
(	O
S_RIGHT	int
)	O
)	O
get_token	function
(	O
)	O
;	O
append	function
(	O
code	int
,	O
")))"	pointer
)	O
;	O
return	O
code	int
;	O
}	O
static	O
int	O
block_level	function
(	O
BLOCK	struct
*	O
b	pointer
)	O
{	O
int	O
level	int
=	O
-	O
1	int
;	O
for	O
(	O
b	pointer
=	O
b	pointer
;	O
b	pointer
!=	O
NULL	O
;	O
b	pointer
=	O
b	pointer
->	O
surr	pointer
)	O
{	O
level	int
++	O
;	O
if	O
(	O
b	pointer
->	O
proc	pointer
!=	O
NULL	O
)	O
break	O
;	O
}	O
assert	O
(	O
level	int
>=	O
0	int
)	O
;	O
return	O
level	int
;	O
}	O
static	O
CODE	struct
*	O
call_by_name	function
(	O
IDENT	struct
*	O
id	pointer
)	O
{	O
CODE	struct
*	O
code	int
=	O
new_code	function
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
append	function
(	O
code	int
,	O
"("	pointer
a_global_dsa	pointer
" = dsa_%d->%s_%d.arg2, (*(struct desc (*)"	pointer
"(void))dsa_%d->%s_%d.arg1)())"	pointer
,	O
dsa_level	function
(	O
id	pointer
)	O
,	O
id	pointer
->	O
name	pointer
,	O
id	pointer
->	O
block	pointer
->	O
seqn	int
,	O
dsa_level	function
(	O
id	pointer
)	O
,	O
id	pointer
->	O
name	pointer
,	O
id	pointer
->	O
block	pointer
->	O
seqn	int
)	O
;	O
}	O
return	O
code	int
;	O
}	O
static	O
CODE	struct
*	O
primary	function
(	O
void	O
)	O
{	O
CODE	struct
*	O
code	int
;	O
if	O
(	O
t_code	O
==	O
T_REAL	int
)	O
{	O
code	int
=	O
new_code	function
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
code	int
->	O
lval	int
=	O
0	int
;	O
code	int
->	O
type	int
=	O
F_REAL	int
;	O
{	O
char	O
*	O
ptr	pointer
,	O
*	O
ten	pointer
;	O
for	O
(	O
ptr	pointer
=	O
t_image	O
;	O
*	O
ptr	pointer
!=	O
'\0'	O
;	O
ptr	pointer
++	O
)	O
if	O
(	O
*	O
ptr	pointer
!=	O
'0'	O
)	O
break	O
;	O
assert	O
(	O
*	O
ptr	pointer
!=	O
'\0'	O
)	O
;	O
if	O
(	O
*	O
ptr	pointer
==	O
TEN_CHAR	char
&&	O
ptr	pointer
!=	O
t_image	O
)	O
ptr	pointer
--	O
;	O
ten	pointer
=	O
strchr	function
(	O
ptr	pointer
,	O
TEN_CHAR	char
)	O
;	O
if	O
(	O
ten	pointer
!=	O
NULL	O
)	O
*	O
ten	pointer
=	O
'e'	O
;	O
append	function
(	O
code	int
,	O
"%s%s"	pointer
,	O
ten	pointer
==	O
ptr	pointer
?	O
"1"	pointer
:	O
""	pointer
,	O
ptr	pointer
)	O
;	O
}	O
}	O
get_token	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
t_code	O
==	O
T_INT	int
)	O
{	O
code	int
=	O
new_code	function
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
code	int
->	O
lval	int
=	O
0	int
;	O
code	int
->	O
type	int
=	O
F_INT	int
;	O
{	O
char	O
*	O
ptr	pointer
;	O
for	O
(	O
ptr	pointer
=	O
t_image	O
;	O
*	O
ptr	pointer
!=	O
'\0'	O
;	O
ptr	pointer
++	O
)	O
if	O
(	O
*	O
ptr	pointer
!=	O
'0'	O
)	O
break	O
;	O
if	O
(	O
*	O
ptr	pointer
==	O
'\0'	O
)	O
ptr	pointer
--	O
;	O
append	function
(	O
code	int
,	O
"%s"	pointer
,	O
ptr	pointer
)	O
;	O
}	O
}	O
get_token	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
t_code	O
==	O
T_FALSE	int
||	O
t_code	O
==	O
T_TRUE	int
)	O
{	O
code	int
=	O
new_code	function
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
code	int
->	O
lval	int
=	O
0	int
;	O
code	int
->	O
type	int
=	O
F_BOOL	int
;	O
append	function
(	O
code	int
,	O
"%s"	pointer
,	O
t_code	O
==	O
T_FALSE	int
?	O
a_false	pointer
:	O
a_true	pointer
)	O
;	O
}	O
get_token	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
t_code	O
==	O
T_IDENT	int
)	O
{	O
IDENT	struct
*	O
id	pointer
=	O
look_up	function
(	O
t_image	O
,	O
0	int
,	O
t_ssn	O
)	O
;	O
get_token2	function
(	O
)	O
;	O
if	O
(	O
token	array
[	O
2	int
]	O
.	O
code	int
==	O
T_DELIM	int
&&	O
token	array
[	O
2	int
]	O
.	O
delim	int
==	O
S_BEGSUB	int
)	O
{	O
if	O
(	O
first_pass	int
||	O
!	O
(	O
id	pointer
->	O
flags	int
&	O
F_SWITCH	int
)	O
)	O
code	int
=	O
subscripted_variable	function
(	O
)	O
;	O
else	O
code	int
=	O
switch_designator	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
token	array
[	O
2	int
]	O
.	O
code	int
==	O
T_DELIM	int
&&	O
token	array
[	O
2	int
]	O
.	O
delim	int
==	O
S_LEFT	int
)	O
{	O
proc	pointer
:	O
code	int
=	O
function_designator	function
(	O
0	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
second_pass	int
&&	O
(	O
id	pointer
->	O
flags	int
&	O
F_PROC	int
)	O
)	O
goto	O
proc	pointer
;	O
code	int
=	O
new_code	function
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
switch	O
(	O
id	pointer
->	O
flags	int
)	O
{	O
case	O
F_REAL	int
:	O
case	O
F_REAL	int
|	O
F_OWN	int
:	O
case	O
F_REAL	int
|	O
F_BYVAL	int
:	O
case	O
F_INT	int
:	O
case	O
F_INT	int
|	O
F_OWN	int
:	O
case	O
F_INT	int
|	O
F_BYVAL	int
:	O
case	O
F_BOOL	int
:	O
case	O
F_BOOL	int
|	O
F_OWN	int
:	O
case	O
F_BOOL	int
|	O
F_BYVAL	int
:	O
code	int
->	O
lval	int
=	O
1	int
;	O
code	int
->	O
type	int
=	O
id	pointer
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
)	O
;	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_OWN	int
)	O
append	function
(	O
code	int
,	O
"%s_%d"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
id	pointer
->	O
block	pointer
->	O
seqn	int
)	O
;	O
else	O
append	function
(	O
code	int
,	O
"dsa_%d->%s_%d"	pointer
,	O
dsa_level	function
(	O
id	pointer
)	O
,	O
id	pointer
->	O
name	pointer
,	O
id	pointer
->	O
block	pointer
->	O
seqn	int
)	O
;	O
break	O
;	O
case	O
F_REAL	int
|	O
F_BYNAME	int
:	O
code	int
->	O
lval	int
=	O
0	int
;	O
code	int
->	O
type	int
=	O
F_REAL	int
;	O
append	function
(	O
code	int
,	O
a_get_real	pointer
"("	pointer
)	O
;	O
catenate	function
(	O
code	int
,	O
call_by_name	function
(	O
id	pointer
)	O
)	O
;	O
append	function
(	O
code	int
,	O
")"	pointer
)	O
;	O
break	O
;	O
case	O
F_INT	int
|	O
F_BYNAME	int
:	O
code	int
->	O
lval	int
=	O
0	int
;	O
code	int
->	O
type	int
=	O
F_INT	int
;	O
append	function
(	O
code	int
,	O
a_get_int	pointer
"("	pointer
)	O
;	O
catenate	function
(	O
code	int
,	O
call_by_name	function
(	O
id	pointer
)	O
)	O
;	O
append	function
(	O
code	int
,	O
")"	pointer
)	O
;	O
break	O
;	O
case	O
F_BOOL	int
|	O
F_BYNAME	int
:	O
code	int
->	O
lval	int
=	O
0	int
;	O
code	int
->	O
type	int
=	O
F_BOOL	int
;	O
append	function
(	O
code	int
,	O
a_get_bool	pointer
"("	pointer
)	O
;	O
catenate	function
(	O
code	int
,	O
call_by_name	function
(	O
id	pointer
)	O
)	O
;	O
append	function
(	O
code	int
,	O
")"	pointer
)	O
;	O
break	O
;	O
case	O
F_LABEL	int
:	O
code	int
->	O
lval	int
=	O
0	int
;	O
code	int
->	O
type	int
=	O
F_LABEL	int
;	O
append	function
(	O
code	int
,	O
a_make_label	pointer
"(dsa_%d->jump_%d, %d)"	pointer
,	O
dsa_level	function
(	O
id	pointer
)	O
,	O
block_level	function
(	O
id	pointer
->	O
block	pointer
)	O
,	O
id	pointer
->	O
dim	int
)	O
;	O
break	O
;	O
case	O
F_LABEL	int
|	O
F_BYVAL	int
:	O
code	int
->	O
lval	int
=	O
0	int
;	O
code	int
->	O
type	int
=	O
F_LABEL	int
;	O
append	function
(	O
code	int
,	O
"dsa_%d->%s_%d"	pointer
,	O
dsa_level	function
(	O
id	pointer
)	O
,	O
id	pointer
->	O
name	pointer
,	O
id	pointer
->	O
block	pointer
->	O
seqn	int
)	O
;	O
break	O
;	O
case	O
F_LABEL	int
|	O
F_BYNAME	int
:	O
code	int
->	O
lval	int
=	O
0	int
;	O
code	int
->	O
type	int
=	O
F_LABEL	int
;	O
append	function
(	O
code	int
,	O
a_get_label	pointer
"("	pointer
)	O
;	O
catenate	function
(	O
code	int
,	O
call_by_name	function
(	O
id	pointer
)	O
)	O
;	O
append	function
(	O
code	int
,	O
")"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
error	function
(	O
"invalid use of identifier `%s' as expressio"	pointer
"n operand"	pointer
,	O
id	pointer
->	O
name	pointer
)	O
;	O
code	int
->	O
lval	int
=	O
0	int
;	O
code	int
->	O
type	int
=	O
F_INT	int
;	O
break	O
;	O
}	O
}	O
get_token	function
(	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
t_delim	O
(	O
S_LEFT	int
)	O
)	O
{	O
get_token	function
(	O
)	O
;	O
code	int
=	O
expression	function
(	O
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_RIGHT	int
)	O
)	O
get_token	function
(	O
)	O
;	O
else	O
error	function
(	O
"missing right parenthesis after expression"	pointer
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
code	int
->	O
lval	int
=	O
0	int
;	O
prepend	function
(	O
code	int
,	O
"("	pointer
)	O
;	O
append	function
(	O
code	int
,	O
")"	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
t_code	O
==	O
T_STRING	int
)	O
{	O
error	function
(	O
"invalid use of string as expression operand"	pointer
)	O
;	O
get_token	function
(	O
)	O
;	O
code	int
=	O
new_code	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
t_code	O
==	O
T_DELIM	int
)	O
{	O
error	function
(	O
"invalid use of delimiter `%s' as expression operand"	pointer
,	O
t_image	O
)	O
;	O
get_token	function
(	O
)	O
;	O
code	int
=	O
new_code	function
(	O
)	O
;	O
}	O
else	O
assert	O
(	O
t_code	O
!=	O
t_code	O
)	O
;	O
return	O
code	int
;	O
}	O
static	O
CODE	struct
*	O
factor	function
(	O
void	O
)	O
{	O
CODE	struct
*	O
x	pointer
,	O
*	O
y	pointer
;	O
x	pointer
=	O
primary	function
(	O
)	O
;	O
while	O
(	O
t_delim	O
(	O
S_POWER	int
)	O
)	O
{	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
!	O
(	O
x	pointer
->	O
type	int
==	O
F_INT	int
||	O
x	pointer
->	O
type	int
==	O
F_REAL	int
)	O
)	O
{	O
error	function
(	O
"operand preceding `^' is not of arithmetic type"	pointer
)	O
;	O
x	pointer
->	O
type	int
=	O
F_INT	int
;	O
}	O
}	O
get_token	function
(	O
)	O
;	O
y	pointer
=	O
primary	function
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
!	O
(	O
y	pointer
->	O
type	int
==	O
F_INT	int
||	O
y	pointer
->	O
type	int
==	O
F_REAL	int
)	O
)	O
{	O
error	function
(	O
"operand following `^' is not of arithmetic type"	pointer
)	O
;	O
y	pointer
->	O
type	int
=	O
F_INT	int
;	O
}	O
x	pointer
->	O
lval	int
=	O
0	int
;	O
if	O
(	O
y	pointer
->	O
type	int
==	O
F_REAL	int
)	O
to_real	function
(	O
x	pointer
)	O
,	O
prepend	function
(	O
x	pointer
,	O
a_expr	pointer
"("	pointer
)	O
;	O
else	O
if	O
(	O
x	pointer
->	O
type	int
==	O
F_REAL	int
)	O
prepend	function
(	O
x	pointer
,	O
a_expn	pointer
"("	pointer
)	O
;	O
else	O
prepend	function
(	O
x	pointer
,	O
a_expi	pointer
"("	pointer
)	O
;	O
append	function
(	O
x	pointer
,	O
", "	pointer
)	O
;	O
catenate	function
(	O
x	pointer
,	O
y	pointer
)	O
;	O
append	function
(	O
x	pointer
,	O
")"	pointer
)	O
;	O
}	O
}	O
return	O
x	pointer
;	O
}	O
static	O
CODE	struct
*	O
term	function
(	O
void	O
)	O
{	O
CODE	struct
*	O
x	pointer
,	O
*	O
y	pointer
;	O
x	pointer
=	O
factor	function
(	O
)	O
;	O
while	O
(	O
t_delim	O
(	O
S_TIMES	int
)	O
||	O
t_delim	O
(	O
S_SLASH	int
)	O
||	O
t_delim	O
(	O
S_INTDIV	int
)	O
)	O
{	O
int	O
op	int
=	O
token	array
[	O
1	int
]	O
.	O
delim	int
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
!	O
(	O
x	pointer
->	O
type	int
==	O
F_INT	int
||	O
x	pointer
->	O
type	int
==	O
F_REAL	int
)	O
)	O
{	O
error	function
(	O
"operand preceding `*', `/', or `%%' is not of ari"	pointer
"thmetic type"	pointer
)	O
;	O
x	pointer
->	O
type	int
=	O
F_INT	int
;	O
}	O
if	O
(	O
op	int
==	O
S_INTDIV	int
&&	O
x	pointer
->	O
type	int
!=	O
F_INT	int
)	O
{	O
error	function
(	O
"operand preceding `%%' is not of integer type"	pointer
)	O
;	O
x	pointer
->	O
type	int
=	O
F_INT	int
;	O
}	O
}	O
get_token	function
(	O
)	O
;	O
y	pointer
=	O
factor	function
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
!	O
(	O
y	pointer
->	O
type	int
==	O
F_INT	int
||	O
y	pointer
->	O
type	int
==	O
F_REAL	int
)	O
)	O
{	O
error	function
(	O
"operand following `*', `/', or `%%' is not of ari"	pointer
"thmetic type"	pointer
)	O
;	O
y	pointer
->	O
type	int
=	O
F_INT	int
;	O
}	O
if	O
(	O
op	int
==	O
S_INTDIV	int
&&	O
y	pointer
->	O
type	int
!=	O
F_INT	int
)	O
{	O
error	function
(	O
"operand following `%%' is not of integer type"	pointer
)	O
;	O
y	pointer
->	O
type	int
=	O
F_INT	int
;	O
}	O
x	pointer
->	O
lval	int
=	O
0	int
;	O
if	O
(	O
x	pointer
->	O
type	int
==	O
F_REAL	int
||	O
op	int
==	O
S_SLASH	int
||	O
y	pointer
->	O
type	int
==	O
F_REAL	int
)	O
to_real	function
(	O
x	pointer
)	O
,	O
to_real	function
(	O
y	pointer
)	O
;	O
append	function
(	O
x	pointer
,	O
" %c "	pointer
,	O
op	int
==	O
S_TIMES	int
?	O
'*'	O
:	O
'/'	O
)	O
;	O
catenate	function
(	O
x	pointer
,	O
y	pointer
)	O
;	O
}	O
}	O
return	O
x	pointer
;	O
}	O
static	O
CODE	struct
*	O
arith_expression	function
(	O
void	O
)	O
{	O
CODE	struct
*	O
x	pointer
,	O
*	O
y	pointer
;	O
if	O
(	O
t_delim	O
(	O
S_PLUS	int
)	O
||	O
t_delim	O
(	O
S_MINUS	int
)	O
)	O
{	O
int	O
op	int
=	O
token	array
[	O
1	int
]	O
.	O
delim	int
;	O
get_token	function
(	O
)	O
;	O
x	pointer
=	O
term	function
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
!	O
(	O
x	pointer
->	O
type	int
==	O
F_INT	int
||	O
x	pointer
->	O
type	int
==	O
F_REAL	int
)	O
)	O
{	O
error	function
(	O
"operand following unary `+' or `-' is not of arit"	pointer
"hmetic type"	pointer
)	O
;	O
x	pointer
->	O
type	int
=	O
F_INT	int
;	O
}	O
x	pointer
->	O
lval	int
=	O
0	int
;	O
prepend	function
(	O
x	pointer
,	O
"%c"	pointer
,	O
op	int
==	O
S_PLUS	int
?	O
'+'	O
:	O
'-'	O
)	O
;	O
}	O
}	O
else	O
x	pointer
=	O
term	function
(	O
)	O
;	O
while	O
(	O
t_delim	O
(	O
S_PLUS	int
)	O
||	O
t_delim	O
(	O
S_MINUS	int
)	O
)	O
{	O
int	O
op	int
=	O
token	array
[	O
1	int
]	O
.	O
delim	int
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
!	O
(	O
x	pointer
->	O
type	int
==	O
F_INT	int
||	O
x	pointer
->	O
type	int
==	O
F_REAL	int
)	O
)	O
{	O
error	function
(	O
"operand preceding `+' or `-' is not of arithmetic"	pointer
" type"	pointer
)	O
;	O
x	pointer
->	O
type	int
=	O
F_INT	int
;	O
}	O
}	O
get_token	function
(	O
)	O
;	O
y	pointer
=	O
term	function
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
!	O
(	O
y	pointer
->	O
type	int
==	O
F_INT	int
||	O
y	pointer
->	O
type	int
==	O
F_REAL	int
)	O
)	O
{	O
error	function
(	O
"operand following `+' or `-' is not of arithmetic"	pointer
" type"	pointer
)	O
;	O
y	pointer
->	O
type	int
=	O
F_INT	int
;	O
}	O
x	pointer
->	O
lval	int
=	O
0	int
;	O
if	O
(	O
x	pointer
->	O
type	int
==	O
F_REAL	int
||	O
y	pointer
->	O
type	int
==	O
F_REAL	int
)	O
to_real	function
(	O
x	pointer
)	O
,	O
to_real	function
(	O
y	pointer
)	O
;	O
append	function
(	O
x	pointer
,	O
" %c "	pointer
,	O
op	int
==	O
S_PLUS	int
?	O
'+'	O
:	O
'-'	O
)	O
;	O
catenate	function
(	O
x	pointer
,	O
y	pointer
)	O
;	O
}	O
}	O
return	O
x	pointer
;	O
}	O
static	O
CODE	struct
*	O
relation	function
(	O
void	O
)	O
{	O
CODE	struct
*	O
x	pointer
,	O
*	O
y	pointer
;	O
int	O
flag	int
=	O
0	int
;	O
x	pointer
=	O
arith_expression	function
(	O
)	O
;	O
while	O
(	O
t_delim	O
(	O
S_LESS	int
)	O
||	O
t_delim	O
(	O
S_NOTGREATER	int
)	O
||	O
t_delim	O
(	O
S_EQUAL	int
)	O
||	O
t_delim	O
(	O
S_NOTLESS	int
)	O
||	O
t_delim	O
(	O
S_GREATER	int
)	O
||	O
t_delim	O
(	O
S_NOTEQUAL	int
)	O
)	O
{	O
int	O
op	int
=	O
token	array
[	O
1	int
]	O
.	O
delim	int
;	O
if	O
(	O
flag	int
)	O
error	function
(	O
"invalid use of relational operator"	pointer
)	O
;	O
flag	int
=	O
1	int
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
!	O
(	O
x	pointer
->	O
type	int
==	O
F_INT	int
||	O
x	pointer
->	O
type	int
==	O
F_REAL	int
)	O
)	O
{	O
error	function
(	O
"operand preceding relational operator is not of a"	pointer
"rithmetic type"	pointer
)	O
;	O
x	pointer
->	O
type	int
=	O
F_INT	int
;	O
}	O
}	O
get_token	function
(	O
)	O
;	O
y	pointer
=	O
arith_expression	function
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
!	O
(	O
y	pointer
->	O
type	int
==	O
F_INT	int
||	O
y	pointer
->	O
type	int
==	O
F_REAL	int
)	O
)	O
{	O
error	function
(	O
"operand following relational operator is not of a"	pointer
"rithmetic type"	pointer
)	O
;	O
y	pointer
->	O
type	int
=	O
F_INT	int
;	O
}	O
if	O
(	O
x	pointer
->	O
type	int
==	O
F_REAL	int
||	O
y	pointer
->	O
type	int
==	O
F_REAL	int
)	O
to_real	function
(	O
x	pointer
)	O
,	O
to_real	function
(	O
y	pointer
)	O
;	O
x	pointer
->	O
lval	int
=	O
0	int
;	O
x	pointer
->	O
type	int
=	O
F_BOOL	int
;	O
prepend	function
(	O
x	pointer
,	O
"%s("	pointer
,	O
op	int
==	O
S_LESS	int
?	O
a_less	pointer
:	O
op	int
==	O
S_NOTGREATER	int
?	O
a_notgreater	pointer
:	O
op	int
==	O
S_EQUAL	int
?	O
a_equal	pointer
:	O
op	int
==	O
S_NOTLESS	int
?	O
a_notless	pointer
:	O
op	int
==	O
S_GREATER	int
?	O
a_greater	pointer
:	O
op	int
==	O
S_NOTEQUAL	int
?	O
a_notequal	pointer
:	O
"???"	pointer
)	O
;	O
append	function
(	O
x	pointer
,	O
", "	pointer
)	O
;	O
catenate	function
(	O
x	pointer
,	O
y	pointer
)	O
;	O
append	function
(	O
x	pointer
,	O
")"	pointer
)	O
;	O
}	O
}	O
return	O
x	pointer
;	O
}	O
static	O
CODE	struct
*	O
bool_primary	function
(	O
void	O
)	O
{	O
CODE	struct
*	O
x	pointer
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_NOT	int
)	O
)	O
x	pointer
=	O
relation	function
(	O
)	O
;	O
else	O
{	O
get_token	function
(	O
)	O
;	O
x	pointer
=	O
relation	function
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
x	pointer
->	O
type	int
!=	O
F_BOOL	int
)	O
{	O
error	function
(	O
"operand following `!' is not of Boolean type"	pointer
)	O
;	O
x	pointer
->	O
type	int
=	O
F_BOOL	int
;	O
}	O
x	pointer
->	O
lval	int
=	O
0	int
;	O
prepend	function
(	O
x	pointer
,	O
a_not	pointer
"("	pointer
)	O
;	O
append	function
(	O
x	pointer
,	O
")"	pointer
)	O
;	O
}	O
}	O
return	O
x	pointer
;	O
}	O
static	O
CODE	struct
*	O
bool_factor	function
(	O
void	O
)	O
{	O
CODE	struct
*	O
x	pointer
,	O
*	O
y	pointer
;	O
x	pointer
=	O
bool_primary	function
(	O
)	O
;	O
while	O
(	O
t_delim	O
(	O
S_AND	int
)	O
)	O
{	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
x	pointer
->	O
type	int
!=	O
F_BOOL	int
)	O
{	O
error	function
(	O
"operand preceding `&' is not of Boolean type"	pointer
)	O
;	O
x	pointer
->	O
type	int
=	O
F_BOOL	int
;	O
}	O
}	O
get_token	function
(	O
)	O
;	O
y	pointer
=	O
bool_primary	function
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
y	pointer
->	O
type	int
!=	O
F_BOOL	int
)	O
{	O
error	function
(	O
"operand following `&' is not of Boolean type"	pointer
)	O
;	O
y	pointer
->	O
type	int
=	O
F_BOOL	int
;	O
}	O
x	pointer
->	O
lval	int
=	O
0	int
;	O
prepend	function
(	O
x	pointer
,	O
a_and	pointer
"("	pointer
)	O
;	O
append	function
(	O
x	pointer
,	O
", "	pointer
)	O
;	O
catenate	function
(	O
x	pointer
,	O
y	pointer
)	O
;	O
append	function
(	O
x	pointer
,	O
")"	pointer
)	O
;	O
}	O
}	O
return	O
x	pointer
;	O
}	O
static	O
CODE	struct
*	O
bool_term	function
(	O
void	O
)	O
{	O
CODE	struct
*	O
x	pointer
,	O
*	O
y	pointer
;	O
x	pointer
=	O
bool_factor	function
(	O
)	O
;	O
while	O
(	O
t_delim	O
(	O
S_OR	int
)	O
)	O
{	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
x	pointer
->	O
type	int
!=	O
F_BOOL	int
)	O
{	O
error	function
(	O
"operand preceding `|' is not of Boolean type"	pointer
)	O
;	O
x	pointer
->	O
type	int
=	O
F_BOOL	int
;	O
}	O
}	O
get_token	function
(	O
)	O
;	O
y	pointer
=	O
bool_factor	function
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
y	pointer
->	O
type	int
!=	O
F_BOOL	int
)	O
{	O
error	function
(	O
"operand following `|' is not of Boolean type"	pointer
)	O
;	O
y	pointer
->	O
type	int
=	O
F_BOOL	int
;	O
}	O
x	pointer
->	O
lval	int
=	O
0	int
;	O
prepend	function
(	O
x	pointer
,	O
a_or	pointer
"("	pointer
)	O
;	O
append	function
(	O
x	pointer
,	O
", "	pointer
)	O
;	O
catenate	function
(	O
x	pointer
,	O
y	pointer
)	O
;	O
append	function
(	O
x	pointer
,	O
")"	pointer
)	O
;	O
}	O
}	O
return	O
x	pointer
;	O
}	O
static	O
CODE	struct
*	O
implication	function
(	O
void	O
)	O
{	O
CODE	struct
*	O
x	pointer
,	O
*	O
y	pointer
;	O
x	pointer
=	O
bool_term	function
(	O
)	O
;	O
while	O
(	O
t_delim	O
(	O
S_IMPL	int
)	O
)	O
{	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
x	pointer
->	O
type	int
!=	O
F_BOOL	int
)	O
{	O
error	function
(	O
"operand preceding `->' is not of Boolean type"	pointer
)	O
;	O
x	pointer
->	O
type	int
=	O
F_BOOL	int
;	O
}	O
}	O
get_token	function
(	O
)	O
;	O
y	pointer
=	O
bool_term	function
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
y	pointer
->	O
type	int
!=	O
F_BOOL	int
)	O
{	O
error	function
(	O
"operand following `->' is not of Boolean type"	pointer
)	O
;	O
y	pointer
->	O
type	int
=	O
F_BOOL	int
;	O
}	O
x	pointer
->	O
lval	int
=	O
0	int
;	O
prepend	function
(	O
x	pointer
,	O
a_impl	pointer
"("	pointer
)	O
;	O
append	function
(	O
x	pointer
,	O
", "	pointer
)	O
;	O
catenate	function
(	O
x	pointer
,	O
y	pointer
)	O
;	O
append	function
(	O
x	pointer
,	O
")"	pointer
)	O
;	O
}	O
}	O
return	O
x	pointer
;	O
}	O
static	O
CODE	struct
*	O
simple_expr	function
(	O
void	O
)	O
{	O
CODE	struct
*	O
x	pointer
,	O
*	O
y	pointer
;	O
x	pointer
=	O
implication	function
(	O
)	O
;	O
while	O
(	O
t_delim	O
(	O
S_EQUIV	int
)	O
)	O
{	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
x	pointer
->	O
type	int
!=	O
F_BOOL	int
)	O
{	O
error	function
(	O
"operand preceding `==' is not of Boolean type"	pointer
)	O
;	O
x	pointer
->	O
type	int
=	O
F_BOOL	int
;	O
}	O
}	O
get_token	function
(	O
)	O
;	O
y	pointer
=	O
implication	function
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
y	pointer
->	O
type	int
!=	O
F_BOOL	int
)	O
{	O
error	function
(	O
"operand following `==' is not of Boolean type"	pointer
)	O
;	O
y	pointer
->	O
type	int
=	O
F_BOOL	int
;	O
}	O
x	pointer
->	O
lval	int
=	O
0	int
;	O
prepend	function
(	O
x	pointer
,	O
a_equiv	pointer
"("	pointer
)	O
;	O
append	function
(	O
x	pointer
,	O
", "	pointer
)	O
;	O
catenate	function
(	O
x	pointer
,	O
y	pointer
)	O
;	O
append	function
(	O
x	pointer
,	O
")"	pointer
)	O
;	O
}	O
}	O
return	O
x	pointer
;	O
}	O
static	O
CODE	struct
*	O
expression	function
(	O
void	O
)	O
{	O
CODE	struct
*	O
x	pointer
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_IF	int
)	O
)	O
x	pointer
=	O
simple_expr	function
(	O
)	O
;	O
else	O
{	O
CODE	struct
*	O
sae	pointer
,	O
*	O
ae	pointer
;	O
get_token	function
(	O
)	O
;	O
x	pointer
=	O
expression	function
(	O
)	O
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_THEN	int
)	O
)	O
error	function
(	O
"missing `then' delimiter"	pointer
)	O
;	O
if	O
(	O
second_pass	int
&&	O
x	pointer
->	O
type	int
!=	O
F_BOOL	int
)	O
error	function
(	O
"expression following `if' is not of Boolean type"	pointer
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_THEN	int
)	O
)	O
get_token	function
(	O
)	O
;	O
sae	pointer
=	O
simple_expr	function
(	O
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_ELSE	int
)	O
)	O
get_token	function
(	O
)	O
;	O
else	O
error	function
(	O
"missing `else' delimiter"	pointer
)	O
;	O
ae	pointer
=	O
expression	function
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
sae	pointer
->	O
type	int
==	O
F_INT	int
&&	O
ae	pointer
->	O
type	int
==	O
F_REAL	int
)	O
to_real	function
(	O
sae	pointer
)	O
;	O
if	O
(	O
sae	pointer
->	O
type	int
==	O
F_REAL	int
&&	O
ae	pointer
->	O
type	int
==	O
F_INT	int
)	O
to_real	function
(	O
ae	pointer
)	O
;	O
if	O
(	O
sae	pointer
->	O
type	int
!=	O
ae	pointer
->	O
type	int
)	O
error	function
(	O
"expressions before and after 'else' incompatible"	pointer
)	O
;	O
x	pointer
->	O
lval	int
=	O
0	int
;	O
x	pointer
->	O
type	int
=	O
sae	pointer
->	O
type	int
;	O
prepend	function
(	O
x	pointer
,	O
"(("	pointer
)	O
;	O
append	function
(	O
x	pointer
,	O
") ? ("	pointer
)	O
;	O
catenate	function
(	O
x	pointer
,	O
sae	pointer
)	O
;	O
append	function
(	O
x	pointer
,	O
") : ("	pointer
)	O
;	O
catenate	function
(	O
x	pointer
,	O
ae	pointer
)	O
;	O
append	function
(	O
x	pointer
,	O
"))"	pointer
)	O
;	O
}	O
}	O
return	O
x	pointer
;	O
}	O
static	O
CODE	struct
*	O
assignment_statement	function
(	O
int	O
flag	int
)	O
{	O
CODE	struct
*	O
x	pointer
;	O
if	O
(	O
t_code	O
==	O
T_IDENT	int
)	O
get_token2	function
(	O
)	O
;	O
if	O
(	O
t_code	O
==	O
T_IDENT	int
&&	O
token	array
[	O
2	int
]	O
.	O
code	int
==	O
T_DELIM	int
&&	O
token	array
[	O
2	int
]	O
.	O
delim	int
==	O
S_ASSIGN	int
)	O
{	O
IDENT	struct
*	O
id	pointer
=	O
look_up	function
(	O
t_image	O
,	O
0	int
,	O
t_ssn	O
)	O
;	O
if	O
(	O
first_pass	int
)	O
{	O
get_token	function
(	O
)	O
,	O
get_token	function
(	O
)	O
;	O
assignment_statement	function
(	O
1	int
)	O
;	O
goto	O
skip1	O
;	O
}	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_LABEL	int
)	O
error	function
(	O
"invalid use of label `%s' in left part of assignment"	pointer
" statement"	pointer
,	O
id	pointer
->	O
name	pointer
)	O
;	O
else	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_ARRAY	int
)	O
error	function
(	O
"invalid use of array identifier `%s' in left part of"	pointer
" assignment statement"	pointer
,	O
id	pointer
->	O
name	pointer
)	O
;	O
else	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_SWITCH	int
)	O
error	function
(	O
"invalid use of switch identifier `%s' in left part o"	pointer
"f assignment statement"	pointer
,	O
id	pointer
->	O
name	pointer
)	O
;	O
else	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_STRING	int
)	O
error	function
(	O
"invalid use of formal string `%s' in left part of as"	pointer
"signment statement"	pointer
,	O
id	pointer
->	O
name	pointer
)	O
;	O
else	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_PROC	int
)	O
{	O
BLOCK	struct
*	O
b	pointer
;	O
for	O
(	O
b	pointer
=	O
current	pointer
;	O
b	pointer
!=	O
NULL	O
;	O
b	pointer
=	O
b	pointer
->	O
surr	pointer
)	O
if	O
(	O
b	pointer
->	O
proc	pointer
==	O
id	pointer
)	O
break	O
;	O
if	O
(	O
b	pointer
==	O
NULL	O
)	O
error	function
(	O
"invalid assignment to procedure identifier `%s' o"	pointer
"utside procedure declaration body"	pointer
,	O
id	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
!	O
(	O
id	pointer
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
)	O
)	O
)	O
error	function
(	O
"invalid use of typeless procedure identifier `%s'"	pointer
" in left part of assignment statement"	pointer
,	O
id	pointer
->	O
name	pointer
)	O
;	O
}	O
get_token	function
(	O
)	O
,	O
get_token	function
(	O
)	O
;	O
x	pointer
=	O
assignment_statement	function
(	O
1	int
)	O
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_ASSIGN	int
)	O
)	O
x	pointer
->	O
lval	int
=	O
0	int
;	O
if	O
(	O
x	pointer
->	O
lval	int
==	O
0	int
)	O
{	O
if	O
(	O
(	O
id	pointer
->	O
flags	int
&	O
F_REAL	int
)	O
&&	O
x	pointer
->	O
type	int
==	O
F_INT	int
)	O
to_real	function
(	O
x	pointer
)	O
;	O
if	O
(	O
(	O
id	pointer
->	O
flags	int
&	O
F_INT	int
)	O
&&	O
x	pointer
->	O
type	int
==	O
F_REAL	int
)	O
to_int	function
(	O
x	pointer
)	O
;	O
if	O
(	O
(	O
id	pointer
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
)	O
)	O
!=	O
x	pointer
->	O
type	int
)	O
error	function
(	O
"type of identifier `%s' in left part of assignmen"	pointer
"t statement incompatible with type of assigned expre"	pointer
"ssion"	pointer
,	O
id	pointer
->	O
name	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
id	pointer
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
)	O
)	O
!=	O
x	pointer
->	O
type	int
)	O
error	function
(	O
"different types in left part list of assignment s"	pointer
"tatement"	pointer
)	O
;	O
}	O
switch	O
(	O
id	pointer
->	O
flags	int
)	O
{	O
case	O
F_REAL	int
:	O
case	O
F_REAL	int
|	O
F_OWN	int
:	O
case	O
F_REAL	int
|	O
F_BYVAL	int
:	O
case	O
F_INT	int
:	O
case	O
F_INT	int
|	O
F_OWN	int
:	O
case	O
F_INT	int
|	O
F_BYVAL	int
:	O
case	O
F_BOOL	int
:	O
case	O
F_BOOL	int
|	O
F_OWN	int
:	O
case	O
F_BOOL	int
|	O
F_BYVAL	int
:	O
x	pointer
->	O
lval	int
=	O
1	int
;	O
x	pointer
->	O
type	int
=	O
id	pointer
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
)	O
;	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_OWN	int
)	O
prepend	function
(	O
x	pointer
,	O
"%s_%d = "	pointer
,	O
id	pointer
->	O
name	pointer
,	O
id	pointer
->	O
block	pointer
->	O
seqn	int
)	O
;	O
else	O
prepend	function
(	O
x	pointer
,	O
"dsa_%d->%s_%d = "	pointer
,	O
dsa_level	function
(	O
id	pointer
)	O
,	O
id	pointer
->	O
name	pointer
,	O
id	pointer
->	O
block	pointer
->	O
seqn	int
)	O
;	O
break	O
;	O
case	O
F_REAL	int
|	O
F_BYNAME	int
:	O
{	O
CODE	struct
*	O
code	int
=	O
call_by_name	function
(	O
id	pointer
)	O
;	O
prepend	function
(	O
code	int
,	O
a_set_real	pointer
"("	pointer
)	O
;	O
append	function
(	O
code	int
,	O
", "	pointer
)	O
;	O
catenate	function
(	O
code	int
,	O
x	pointer
)	O
;	O
append	function
(	O
code	int
,	O
")"	pointer
)	O
;	O
x	pointer
=	O
code	int
;	O
x	pointer
->	O
lval	int
=	O
1	int
;	O
x	pointer
->	O
type	int
=	O
F_REAL	int
;	O
}	O
break	O
;	O
case	O
F_INT	int
|	O
F_BYNAME	int
:	O
{	O
CODE	struct
*	O
code	int
=	O
call_by_name	function
(	O
id	pointer
)	O
;	O
prepend	function
(	O
code	int
,	O
a_set_int	pointer
"("	pointer
)	O
;	O
append	function
(	O
code	int
,	O
", "	pointer
)	O
;	O
catenate	function
(	O
code	int
,	O
x	pointer
)	O
;	O
append	function
(	O
code	int
,	O
")"	pointer
)	O
;	O
x	pointer
=	O
code	int
;	O
x	pointer
->	O
lval	int
=	O
1	int
;	O
x	pointer
->	O
type	int
=	O
F_INT	int
;	O
}	O
break	O
;	O
case	O
F_BOOL	int
|	O
F_BYNAME	int
:	O
{	O
CODE	struct
*	O
code	int
=	O
call_by_name	function
(	O
id	pointer
)	O
;	O
prepend	function
(	O
code	int
,	O
a_set_bool	pointer
"("	pointer
)	O
;	O
append	function
(	O
code	int
,	O
", "	pointer
)	O
;	O
catenate	function
(	O
code	int
,	O
x	pointer
)	O
;	O
append	function
(	O
code	int
,	O
")"	pointer
)	O
;	O
x	pointer
=	O
code	int
;	O
x	pointer
->	O
lval	int
=	O
1	int
;	O
x	pointer
->	O
type	int
=	O
F_BOOL	int
;	O
}	O
break	O
;	O
case	O
F_REAL	int
|	O
F_PROC	int
:	O
case	O
F_INT	int
|	O
F_PROC	int
:	O
case	O
F_BOOL	int
|	O
F_PROC	int
:	O
x	pointer
->	O
lval	int
=	O
1	int
;	O
x	pointer
->	O
type	int
=	O
id	pointer
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
)	O
;	O
prepend	function
(	O
x	pointer
,	O
"dsa_%d->retval.u.%s = "	pointer
,	O
dsa_level	function
(	O
id	pointer
)	O
+	O
1	int
,	O
x	pointer
->	O
type	int
==	O
F_REAL	int
?	O
"real_val"	pointer
:	O
x	pointer
->	O
type	int
==	O
F_INT	int
?	O
"int_val"	pointer
:	O
x	pointer
->	O
type	int
==	O
F_BOOL	int
?	O
"bool_val"	pointer
:	O
"???"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
skip1	O
:	O
;	O
}	O
else	O
{	O
CODE	struct
*	O
y	pointer
;	O
x	pointer
=	O
expression	function
(	O
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_ASSIGN	int
)	O
)	O
{	O
if	O
(	O
second_pass	int
&&	O
!	O
x	pointer
->	O
lval	int
)	O
error	function
(	O
"invalid use of delimiter `:=' after expression in"	pointer
" assignment statement"	pointer
)	O
;	O
get_token	function
(	O
)	O
;	O
y	pointer
=	O
assignment_statement	function
(	O
1	int
)	O
;	O
if	O
(	O
first_pass	int
)	O
goto	O
skip2	O
;	O
if	O
(	O
y	pointer
->	O
lval	int
==	O
0	int
)	O
{	O
if	O
(	O
x	pointer
->	O
type	int
==	O
F_REAL	int
&&	O
y	pointer
->	O
type	int
==	O
F_INT	int
)	O
to_real	function
(	O
y	pointer
)	O
;	O
if	O
(	O
x	pointer
->	O
type	int
==	O
F_INT	int
&&	O
y	pointer
->	O
type	int
==	O
F_REAL	int
)	O
to_int	function
(	O
y	pointer
)	O
;	O
if	O
(	O
x	pointer
->	O
type	int
!=	O
y	pointer
->	O
type	int
)	O
error	function
(	O
"type of destination in left part of assignment"	pointer
" statement incompatible with type of assigned exp"	pointer
"ression"	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
x	pointer
->	O
type	int
!=	O
y	pointer
->	O
type	int
)	O
error	function
(	O
"different types in left part list of assignmen"	pointer
"t statement"	pointer
)	O
;	O
}	O
x	pointer
->	O
lval	int
=	O
1	int
;	O
append	function
(	O
x	pointer
,	O
" = "	pointer
)	O
;	O
catenate	function
(	O
x	pointer
,	O
y	pointer
)	O
;	O
skip2	O
:	O
;	O
}	O
else	O
{	O
if	O
(	O
first_pass	int
)	O
goto	O
skip3	O
;	O
if	O
(	O
!	O
flag	int
)	O
{	O
error	function
(	O
"invalid use of expression"	pointer
)	O
;	O
goto	O
skip3	O
;	O
}	O
if	O
(	O
!	O
(	O
x	pointer
->	O
type	int
==	O
F_REAL	int
||	O
x	pointer
->	O
type	int
==	O
F_INT	int
||	O
x	pointer
->	O
type	int
==	O
F_BOOL	int
)	O
)	O
{	O
error	function
(	O
"invalid type of assigned expression in assignment"	pointer
" statement"	pointer
)	O
;	O
x	pointer
->	O
type	int
=	O
F_REAL	int
;	O
}	O
x	pointer
->	O
lval	int
=	O
0	int
;	O
skip3	O
:	O
;	O
}	O
}	O
if	O
(	O
!	O
flag	int
)	O
{	O
prepend	function
(	O
x	pointer
,	O
"      "	pointer
)	O
;	O
append	function
(	O
x	pointer
,	O
";\n"	pointer
)	O
;	O
}	O
return	O
x	pointer
;	O
}	O
static	O
CODE	struct
*	O
go_to_statement	function
(	O
void	O
)	O
{	O
CODE	struct
*	O
code	int
;	O
assert	O
(	O
t_delim	O
(	O
S_GOTO	int
)	O
)	O
;	O
get_token	function
(	O
)	O
;	O
if	O
(	O
second_pass	int
&&	O
t_code	O
==	O
T_IDENT	int
)	O
{	O
get_token2	function
(	O
)	O
;	O
if	O
(	O
token	array
[	O
2	int
]	O
.	O
code	int
==	O
T_DELIM	int
&&	O
(	O
token	array
[	O
2	int
]	O
.	O
delim	int
==	O
S_SEMICOLON	int
||	O
token	array
[	O
2	int
]	O
.	O
delim	int
==	O
S_ELSE	int
||	O
token	array
[	O
2	int
]	O
.	O
delim	int
==	O
S_END	int
)	O
)	O
{	O
IDENT	struct
*	O
id	pointer
=	O
look_up	function
(	O
t_image	O
,	O
0	int
,	O
t_ssn	O
)	O
;	O
if	O
(	O
!	O
(	O
id	pointer
->	O
flags	int
&	O
F_LABEL	int
)	O
)	O
error	function
(	O
"invalid use identifier `%s' as a label in go to s"	pointer
"tatement"	pointer
,	O
id	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
id	pointer
->	O
flags	int
==	O
F_LABEL	int
&&	O
id	pointer
->	O
block	pointer
==	O
current	pointer
)	O
{	O
code	int
=	O
new_code	function
(	O
)	O
;	O
append	function
(	O
code	int
,	O
"      goto %s_%d;\n"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
id	pointer
->	O
block	pointer
->	O
seqn	int
)	O
;	O
get_token	function
(	O
)	O
;	O
goto	O
done	O
;	O
}	O
}	O
}	O
code	int
=	O
expression	function
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
code	int
->	O
type	int
!=	O
F_LABEL	int
)	O
error	function
(	O
"expression following `go to' is not of label type"	pointer
)	O
;	O
prepend	function
(	O
code	int
,	O
"      "	pointer
a_go_to	pointer
"("	pointer
)	O
;	O
append	function
(	O
code	int
,	O
");\n"	pointer
)	O
;	O
}	O
done	O
:	O
return	O
code	int
;	O
}	O
static	O
CODE	struct
*	O
dummy_statement	function
(	O
void	O
)	O
{	O
CODE	struct
*	O
code	int
=	O
new_code	function
(	O
)	O
;	O
append	function
(	O
code	int
,	O
"      /* <dummy statement> */;\n"	pointer
)	O
;	O
return	O
code	int
;	O
}	O
static	O
CODE	struct
*	O
emit_ssn	function
(	O
int	O
ssn	int
)	O
{	O
CODE	struct
*	O
code	int
=	O
new_code	function
(	O
)	O
;	O
append	function
(	O
code	int
,	O
"      dsa_%d->line = %d;\n"	pointer
,	O
current_level	function
(	O
)	O
,	O
ssn	int
)	O
;	O
return	O
code	int
;	O
}	O
static	O
CODE	struct
*	O
label_list	function
(	O
void	O
)	O
{	O
CODE	struct
*	O
code	int
=	O
new_code	function
(	O
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_ELSE	int
)	O
||	O
t_delim	O
(	O
S_END	int
)	O
||	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
warning	function
(	O
"unlabelled dummy statement"	pointer
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
t_code	O
==	O
T_IDENT	int
||	O
t_code	O
==	O
T_INT	int
)	O
get_token2	function
(	O
)	O
;	O
if	O
(	O
t_code	O
==	O
T_IDENT	int
&&	O
(	O
token	array
[	O
2	int
]	O
.	O
code	int
==	O
T_DELIM	int
&&	O
token	array
[	O
2	int
]	O
.	O
delim	int
==	O
S_COLON	int
)	O
)	O
{	O
IDENT	struct
*	O
label	pointer
;	O
label	pointer
=	O
look_up	function
(	O
t_image	O
,	O
1	int
,	O
t_ssn	O
)	O
;	O
label	pointer
->	O
flags	int
=	O
F_LABEL	int
;	O
append	function
(	O
code	int
,	O
"%s_%d:\n"	pointer
,	O
label	pointer
->	O
name	pointer
,	O
label	pointer
->	O
block	pointer
->	O
seqn	int
)	O
;	O
get_token	function
(	O
)	O
,	O
get_token	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
t_code	O
==	O
T_INT	int
&&	O
(	O
token	array
[	O
2	int
]	O
.	O
code	int
==	O
T_DELIM	int
&&	O
token	array
[	O
2	int
]	O
.	O
delim	int
==	O
S_COLON	int
)	O
)	O
{	O
error	function
(	O
"invalid use unsigned integer `%s' as a label"	pointer
,	O
t_image	O
)	O
;	O
get_token	function
(	O
)	O
,	O
get_token	function
(	O
)	O
;	O
}	O
else	O
break	O
;	O
}	O
catenate	function
(	O
code	int
,	O
emit_ssn	function
(	O
t_ssn	O
)	O
)	O
;	O
return	O
code	int
;	O
}	O
static	O
CODE	struct
*	O
statement	function
(	O
void	O
)	O
;	O
static	O
int	O
label_count	int
=	O
0	int
;	O
static	O
CODE	struct
*	O
conditional_statement	function
(	O
void	O
)	O
{	O
CODE	struct
*	O
code	int
,	O
*	O
then_part	pointer
,	O
*	O
else_part	pointer
;	O
int	O
no_else	int
;	O
assert	O
(	O
t_delim	O
(	O
S_IF	int
)	O
)	O
;	O
get_token	function
(	O
)	O
;	O
code	int
=	O
expression	function
(	O
)	O
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_THEN	int
)	O
)	O
error	function
(	O
"missing `then' delimiter"	pointer
)	O
;	O
if	O
(	O
second_pass	int
&&	O
code	int
->	O
type	int
!=	O
F_BOOL	int
)	O
error	function
(	O
"expression following `if' is not of Boolean type"	pointer
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_THEN	int
)	O
)	O
get_token	function
(	O
)	O
;	O
then_part	pointer
=	O
label_list	function
(	O
)	O
;	O
no_else	int
=	O
(	O
t_delim	O
(	O
S_IF	int
)	O
||	O
t_delim	O
(	O
S_FOR	int
)	O
)	O
;	O
catenate	function
(	O
then_part	pointer
,	O
statement	function
(	O
)	O
)	O
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_ELSE	int
)	O
)	O
{	O
if	O
(	O
second_pass	int
)	O
{	O
prepend	function
(	O
code	int
,	O
"      if (!("	pointer
)	O
;	O
label_count	int
++	O
;	O
append	function
(	O
code	int
,	O
")) goto _omega_%d;\n"	pointer
,	O
label_count	int
)	O
;	O
catenate	function
(	O
code	int
,	O
then_part	pointer
)	O
;	O
append	function
(	O
code	int
,	O
"_omega_%d:\n"	pointer
,	O
label_count	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
no_else	int
)	O
error	function
(	O
"invalid use of delimiter `else' after if or for stat"	pointer
"ement"	pointer
)	O
;	O
get_token	function
(	O
)	O
;	O
else_part	pointer
=	O
label_list	function
(	O
)	O
;	O
catenate	function
(	O
else_part	pointer
,	O
statement	function
(	O
)	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
prepend	function
(	O
code	int
,	O
"      if (!("	pointer
)	O
;	O
if	O
(	O
second_pass	int
)	O
label_count	int
++	O
;	O
append	function
(	O
code	int
,	O
")) goto _gamma_%d;\n"	pointer
,	O
label_count	int
)	O
;	O
catenate	function
(	O
code	int
,	O
then_part	pointer
)	O
;	O
append	function
(	O
code	int
,	O
"      goto _omega_%d;\n_gamma_%d:\n"	pointer
,	O
label_count	int
,	O
label_count	int
)	O
;	O
catenate	function
(	O
code	int
,	O
else_part	pointer
)	O
;	O
append	function
(	O
code	int
,	O
"_omega_%d:\n"	pointer
,	O
label_count	int
)	O
;	O
}	O
}	O
return	O
code	int
;	O
}	O
static	O
CODE	struct
*	O
get_variable	function
(	O
IDENT	struct
*	O
id	pointer
)	O
{	O
CODE	struct
*	O
expr	pointer
=	O
new_code	function
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
switch	O
(	O
id	pointer
->	O
flags	int
)	O
{	O
case	O
F_REAL	int
:	O
case	O
F_REAL	int
|	O
F_OWN	int
:	O
case	O
F_REAL	int
|	O
F_BYVAL	int
:	O
case	O
F_INT	int
:	O
case	O
F_INT	int
|	O
F_OWN	int
:	O
case	O
F_INT	int
|	O
F_BYVAL	int
:	O
expr	pointer
->	O
lval	int
=	O
0	int
;	O
expr	pointer
->	O
type	int
=	O
id	pointer
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
)	O
;	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_OWN	int
)	O
append	function
(	O
expr	pointer
,	O
"%s_%d"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
id	pointer
->	O
block	pointer
->	O
seqn	int
)	O
;	O
else	O
append	function
(	O
expr	pointer
,	O
"dsa_%d->%s_%d"	pointer
,	O
dsa_level	function
(	O
id	pointer
)	O
,	O
id	pointer
->	O
name	pointer
,	O
id	pointer
->	O
block	pointer
->	O
seqn	int
)	O
;	O
break	O
;	O
case	O
F_REAL	int
|	O
F_BYNAME	int
:	O
expr	pointer
->	O
lval	int
=	O
0	int
;	O
expr	pointer
->	O
type	int
=	O
F_REAL	int
;	O
append	function
(	O
expr	pointer
,	O
a_get_real	pointer
"("	pointer
)	O
;	O
catenate	function
(	O
expr	pointer
,	O
call_by_name	function
(	O
id	pointer
)	O
)	O
;	O
append	function
(	O
expr	pointer
,	O
")"	pointer
)	O
;	O
break	O
;	O
case	O
F_INT	int
|	O
F_BYNAME	int
:	O
expr	pointer
->	O
lval	int
=	O
0	int
;	O
expr	pointer
->	O
type	int
=	O
F_INT	int
;	O
append	function
(	O
expr	pointer
,	O
a_get_int	pointer
"("	pointer
)	O
;	O
catenate	function
(	O
expr	pointer
,	O
call_by_name	function
(	O
id	pointer
)	O
)	O
;	O
append	function
(	O
expr	pointer
,	O
")"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
append	function
(	O
expr	pointer
,	O
"???"	pointer
)	O
;	O
break	O
;	O
}	O
}	O
return	O
expr	pointer
;	O
}	O
static	O
CODE	struct
*	O
set_variable	function
(	O
IDENT	struct
*	O
id	pointer
,	O
CODE	struct
*	O
expr	pointer
)	O
{	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
(	O
id	pointer
->	O
flags	int
&	O
F_REAL	int
)	O
&&	O
expr	pointer
->	O
type	int
==	O
F_INT	int
)	O
to_real	function
(	O
expr	pointer
)	O
;	O
if	O
(	O
(	O
id	pointer
->	O
flags	int
&	O
F_INT	int
)	O
&&	O
expr	pointer
->	O
type	int
==	O
F_REAL	int
)	O
to_int	function
(	O
expr	pointer
)	O
;	O
switch	O
(	O
id	pointer
->	O
flags	int
)	O
{	O
case	O
F_REAL	int
:	O
case	O
F_REAL	int
|	O
F_OWN	int
:	O
case	O
F_REAL	int
|	O
F_BYVAL	int
:	O
case	O
F_INT	int
:	O
case	O
F_INT	int
|	O
F_OWN	int
:	O
case	O
F_INT	int
|	O
F_BYVAL	int
:	O
expr	pointer
->	O
type	int
=	O
id	pointer
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
)	O
;	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_OWN	int
)	O
prepend	function
(	O
expr	pointer
,	O
"%s_%d = "	pointer
,	O
id	pointer
->	O
name	pointer
,	O
id	pointer
->	O
block	pointer
->	O
seqn	int
)	O
;	O
else	O
prepend	function
(	O
expr	pointer
,	O
"dsa_%d->%s_%d = "	pointer
,	O
dsa_level	function
(	O
id	pointer
)	O
,	O
id	pointer
->	O
name	pointer
,	O
id	pointer
->	O
block	pointer
->	O
seqn	int
)	O
;	O
break	O
;	O
case	O
F_REAL	int
|	O
F_BYNAME	int
:	O
{	O
CODE	struct
*	O
code	int
=	O
call_by_name	function
(	O
id	pointer
)	O
;	O
prepend	function
(	O
code	int
,	O
a_set_real	pointer
"("	pointer
)	O
;	O
append	function
(	O
code	int
,	O
", "	pointer
)	O
;	O
catenate	function
(	O
code	int
,	O
expr	pointer
)	O
;	O
append	function
(	O
code	int
,	O
")"	pointer
)	O
;	O
expr	pointer
=	O
code	int
;	O
expr	pointer
->	O
lval	int
=	O
1	int
;	O
expr	pointer
->	O
type	int
=	O
F_REAL	int
;	O
}	O
break	O
;	O
case	O
F_INT	int
|	O
F_BYNAME	int
:	O
{	O
CODE	struct
*	O
code	int
=	O
call_by_name	function
(	O
id	pointer
)	O
;	O
prepend	function
(	O
code	int
,	O
a_set_int	pointer
"("	pointer
)	O
;	O
append	function
(	O
code	int
,	O
", "	pointer
)	O
;	O
catenate	function
(	O
code	int
,	O
expr	pointer
)	O
;	O
append	function
(	O
code	int
,	O
")"	pointer
)	O
;	O
expr	pointer
=	O
code	int
;	O
expr	pointer
->	O
lval	int
=	O
1	int
;	O
expr	pointer
->	O
type	int
=	O
F_INT	int
;	O
}	O
break	O
;	O
default	O
:	O
append	function
(	O
expr	pointer
,	O
"???"	pointer
)	O
;	O
break	O
;	O
}	O
prepend	function
(	O
expr	pointer
,	O
"      "	pointer
)	O
;	O
append	function
(	O
expr	pointer
,	O
";\n"	pointer
)	O
;	O
}	O
return	O
expr	pointer
;	O
}	O
static	O
CODE	struct
*	O
enter_block	function
(	O
IDENT	struct
*	O
proc	pointer
,	O
int	O
ssn	int
)	O
;	O
static	O
CODE	struct
*	O
leave_block	function
(	O
void	O
)	O
;	O
static	O
int	O
for_count	int
=	O
0	int
;	O
static	O
CODE	struct
*	O
for_statement	function
(	O
void	O
)	O
{	O
IDENT	struct
*	O
id	pointer
;	O
CODE	struct
*	O
code	int
=	O
new_code	function
(	O
)	O
;	O
int	O
count	int
=	O
first_pass	int
?	O
0	int
:	O
++	O
for_count	int
;	O
assert	O
(	O
t_delim	O
(	O
S_FOR	int
)	O
)	O
;	O
get_token	function
(	O
)	O
;	O
if	O
(	O
t_code	O
==	O
T_IDENT	int
)	O
{	O
id	pointer
=	O
look_up	function
(	O
t_image	O
,	O
0	int
,	O
t_ssn	O
)	O
;	O
get_token	function
(	O
)	O
;	O
}	O
else	O
{	O
char	O
str	pointer
[	O
50	int
]	O
;	O
sprintf	function
(	O
str	pointer
,	O
"i_%d"	pointer
,	O
t_ssn	O
)	O
;	O
error	function
(	O
"missing controlled variable identifier after `for'; dum"	pointer
"my identifier `%s' used"	pointer
,	O
str	pointer
)	O
;	O
id	pointer
=	O
look_up	function
(	O
t_image	O
,	O
1	int
,	O
t_ssn	O
)	O
;	O
id	pointer
->	O
ssn_decl	int
=	O
id	pointer
->	O
ssn_used	int
=	O
t_ssn	O
;	O
id	pointer
->	O
flags	int
=	O
F_REAL	int
;	O
}	O
if	O
(	O
t_delim	O
(	O
S_BEGSUB	int
)	O
)	O
error	function
(	O
"subscripted controlled variable not allowed"	pointer
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_ASSIGN	int
)	O
)	O
get_token	function
(	O
)	O
;	O
else	O
error	function
(	O
"missing ':=' after controlled variable identifier"	pointer
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
(	O
F_LABEL	int
|	O
F_ARRAY	int
|	O
F_SWITCH	int
|	O
F_PROC	int
|	O
F_STRING	int
)	O
)	O
error	function
(	O
"invalid use of identifier `%s' as controlled variabl"	pointer
"e"	pointer
,	O
id	pointer
->	O
name	pointer
)	O
;	O
else	O
if	O
(	O
!	O
(	O
id	pointer
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
)	O
)	O
)	O
error	function
(	O
"invalid type of controlled variable `%s'"	pointer
,	O
id	pointer
->	O
name	pointer
)	O
;	O
}	O
loop	O
:	O
catenate	function
(	O
code	int
,	O
emit_ssn	function
(	O
t_ssn	O
)	O
)	O
;	O
{	O
CODE	struct
*	O
expr	pointer
=	O
expression	function
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
!	O
(	O
expr	pointer
->	O
type	int
==	O
F_REAL	int
||	O
expr	pointer
->	O
type	int
==	O
F_INT	int
)	O
)	O
{	O
error	function
(	O
"invalid type of expression assigned to controlled"	pointer
" variable"	pointer
)	O
;	O
expr	pointer
->	O
type	int
=	O
F_REAL	int
;	O
}	O
if	O
(	O
t_delim	O
(	O
S_WHILE	int
)	O
)	O
{	O
label_count	int
++	O
;	O
append	function
(	O
code	int
,	O
"_gamma_%d:\n"	pointer
,	O
label_count	int
)	O
;	O
catenate	function
(	O
code	int
,	O
emit_ssn	function
(	O
t_ssn	O
)	O
)	O
;	O
}	O
catenate	function
(	O
code	int
,	O
set_variable	function
(	O
id	pointer
,	O
expr	pointer
)	O
)	O
;	O
}	O
}	O
if	O
(	O
t_delim	O
(	O
S_COMMA	int
)	O
||	O
t_delim	O
(	O
S_DO	int
)	O
)	O
{	O
append	function
(	O
code	int
,	O
"      "	pointer
a_global_dsa	pointer
" = (void *)dsa_%d, _sigma_%d();\n"	pointer
,	O
current_level	function
(	O
)	O
,	O
count	int
)	O
;	O
}	O
else	O
if	O
(	O
t_delim	O
(	O
S_STEP	int
)	O
)	O
{	O
IDENT	struct
*	O
teta	pointer
;	O
CODE	struct
*	O
expr	pointer
;	O
if	O
(	O
first_pass	int
)	O
{	O
teta	pointer
=	O
look_up	function
(	O
"teta_r"	pointer
,	O
0	int
,	O
t_ssn	O
)	O
;	O
if	O
(	O
teta	pointer
->	O
ssn_decl	int
==	O
0	int
)	O
teta	pointer
->	O
ssn_decl	int
=	O
t_ssn	O
;	O
teta	pointer
->	O
flags	int
=	O
F_REAL	int
;	O
teta	pointer
=	O
look_up	function
(	O
"teta_i"	pointer
,	O
0	int
,	O
t_ssn	O
)	O
;	O
if	O
(	O
teta	pointer
->	O
ssn_decl	int
==	O
0	int
)	O
teta	pointer
->	O
ssn_decl	int
=	O
t_ssn	O
;	O
teta	pointer
->	O
flags	int
=	O
F_INT	int
;	O
}	O
get_token	function
(	O
)	O
;	O
expr	pointer
=	O
expression	function
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
expr	pointer
->	O
type	int
==	O
F_REAL	int
)	O
teta	pointer
=	O
look_up	function
(	O
"teta_r"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
else	O
if	O
(	O
expr	pointer
->	O
type	int
==	O
F_INT	int
)	O
teta	pointer
=	O
look_up	function
(	O
"teta_i"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
else	O
{	O
error	function
(	O
"expression following `step' is not of arithmetic "	pointer
"type"	pointer
)	O
;	O
teta	pointer
=	O
look_up	function
(	O
"teta_r"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
}	O
assert	O
(	O
teta	pointer
!=	O
NULL	O
&&	O
teta	pointer
->	O
block	pointer
==	O
current	pointer
)	O
;	O
}	O
if	O
(	O
second_pass	int
)	O
{	O
append	function
(	O
code	int
,	O
"      dsa_%d->%s_%d = "	pointer
,	O
current_level	function
(	O
)	O
,	O
teta	pointer
->	O
name	pointer
,	O
teta	pointer
->	O
block	pointer
->	O
seqn	int
)	O
;	O
catenate	function
(	O
code	int
,	O
expr	pointer
)	O
;	O
append	function
(	O
code	int
,	O
";\n"	pointer
)	O
;	O
}	O
if	O
(	O
second_pass	int
)	O
{	O
label_count	int
++	O
;	O
append	function
(	O
code	int
,	O
"_gamma_%d:\n"	pointer
,	O
label_count	int
)	O
;	O
catenate	function
(	O
code	int
,	O
emit_ssn	function
(	O
t_ssn	O
)	O
)	O
;	O
}	O
if	O
(	O
t_delim	O
(	O
S_UNTIL	int
)	O
)	O
get_token	function
(	O
)	O
;	O
else	O
error	function
(	O
"missing `until' delimiter"	pointer
)	O
;	O
expr	pointer
=	O
expression	function
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
(	O
id	pointer
->	O
flags	int
&	O
F_REAL	int
)	O
&&	O
expr	pointer
->	O
type	int
==	O
F_INT	int
)	O
to_real	function
(	O
expr	pointer
)	O
;	O
if	O
(	O
(	O
id	pointer
->	O
flags	int
&	O
F_INT	int
)	O
&&	O
expr	pointer
->	O
type	int
==	O
F_REAL	int
)	O
to_int	function
(	O
expr	pointer
)	O
;	O
if	O
(	O
!	O
(	O
expr	pointer
->	O
type	int
==	O
F_REAL	int
||	O
expr	pointer
->	O
type	int
==	O
F_INT	int
)	O
)	O
{	O
error	function
(	O
"expression following `until' is not of arithmetic"	pointer
" type"	pointer
)	O
;	O
expr	pointer
->	O
type	int
=	O
F_REAL	int
;	O
}	O
}	O
if	O
(	O
second_pass	int
)	O
{	O
append	function
(	O
code	int
,	O
"      if (("	pointer
)	O
;	O
catenate	function
(	O
code	int
,	O
get_variable	function
(	O
id	pointer
)	O
)	O
;	O
append	function
(	O
code	int
,	O
" - ("	pointer
)	O
;	O
catenate	function
(	O
code	int
,	O
expr	pointer
)	O
;	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_REAL	int
)	O
append	function
(	O
code	int
,	O
")) * (double)("	pointer
)	O
;	O
else	O
append	function
(	O
code	int
,	O
")) * ("	pointer
)	O
;	O
if	O
(	O
teta	pointer
->	O
flags	int
&	O
F_REAL	int
)	O
append	function
(	O
code	int
,	O
"dsa_%d->%s_%d < 0.0 ? -1 : dsa_%d->%s_%d >"	pointer
" 0.0 ? +1 : 0"	pointer
,	O
current_level	function
(	O
)	O
,	O
teta	pointer
->	O
name	pointer
,	O
teta	pointer
->	O
block	pointer
->	O
seqn	int
,	O
current_level	function
(	O
)	O
,	O
teta	pointer
->	O
name	pointer
,	O
teta	pointer
->	O
block	pointer
->	O
seqn	int
)	O
;	O
else	O
append	function
(	O
code	int
,	O
"dsa_%d->%s_%d < 0 ? -1 : dsa_%d->%s_%d > 0"	pointer
" ? +1 : 0"	pointer
,	O
current_level	function
(	O
)	O
,	O
teta	pointer
->	O
name	pointer
,	O
teta	pointer
->	O
block	pointer
->	O
seqn	int
,	O
current_level	function
(	O
)	O
,	O
teta	pointer
->	O
name	pointer
,	O
teta	pointer
->	O
block	pointer
->	O
seqn	int
)	O
;	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_REAL	int
)	O
append	function
(	O
code	int
,	O
") > 0.0) "	pointer
)	O
;	O
else	O
append	function
(	O
code	int
,	O
") > 0) "	pointer
)	O
;	O
append	function
(	O
code	int
,	O
"goto _omega_%d;\n"	pointer
,	O
label_count	int
)	O
;	O
}	O
append	function
(	O
code	int
,	O
"      "	pointer
a_global_dsa	pointer
" = (void *)dsa_%d, _sigma_%d();\n"	pointer
,	O
current_level	function
(	O
)	O
,	O
count	int
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
expr	pointer
=	O
new_code	function
(	O
)	O
;	O
expr	pointer
->	O
lval	int
=	O
0	int
;	O
expr	pointer
->	O
type	int
=	O
(	O
teta	pointer
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
)	O
)	O
;	O
append	function
(	O
expr	pointer
,	O
"dsa_%d->%s_%d"	pointer
,	O
current_level	function
(	O
)	O
,	O
teta	pointer
->	O
name	pointer
,	O
teta	pointer
->	O
block	pointer
->	O
seqn	int
)	O
;	O
if	O
(	O
(	O
id	pointer
->	O
flags	int
&	O
F_REAL	int
)	O
&&	O
(	O
teta	pointer
->	O
flags	int
&	O
F_INT	int
)	O
)	O
to_real	function
(	O
expr	pointer
)	O
;	O
if	O
(	O
(	O
id	pointer
->	O
flags	int
&	O
F_INT	int
)	O
&&	O
(	O
teta	pointer
->	O
flags	int
&	O
F_REAL	int
)	O
)	O
to_int	function
(	O
expr	pointer
)	O
;	O
append	function
(	O
expr	pointer
,	O
" + "	pointer
)	O
;	O
catenate	function
(	O
expr	pointer
,	O
get_variable	function
(	O
id	pointer
)	O
)	O
;	O
catenate	function
(	O
code	int
,	O
set_variable	function
(	O
id	pointer
,	O
expr	pointer
)	O
)	O
;	O
}	O
append	function
(	O
code	int
,	O
"      goto _gamma_%d;\n"	pointer
,	O
label_count	int
)	O
;	O
append	function
(	O
code	int
,	O
"_omega_%d: /* element exhausted */\n"	pointer
,	O
label_count	int
)	O
;	O
}	O
else	O
if	O
(	O
t_delim	O
(	O
S_WHILE	int
)	O
)	O
{	O
CODE	struct
*	O
expr	pointer
;	O
get_token	function
(	O
)	O
;	O
expr	pointer
=	O
expression	function
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
expr	pointer
->	O
type	int
!=	O
F_BOOL	int
)	O
{	O
error	function
(	O
"expression following `while' is not of Boolean ty"	pointer
"pe"	pointer
)	O
;	O
expr	pointer
->	O
type	int
=	O
F_BOOL	int
;	O
}	O
append	function
(	O
code	int
,	O
"      if (!("	pointer
)	O
;	O
catenate	function
(	O
code	int
,	O
expr	pointer
)	O
;	O
append	function
(	O
code	int
,	O
")) goto _omega_%d;\n"	pointer
,	O
label_count	int
)	O
;	O
}	O
append	function
(	O
code	int
,	O
"      "	pointer
a_global_dsa	pointer
" = (void *)dsa_%d, _sigma_%d();\n"	pointer
,	O
current_level	function
(	O
)	O
,	O
count	int
)	O
;	O
append	function
(	O
code	int
,	O
"      goto _gamma_%d;\n"	pointer
,	O
label_count	int
)	O
;	O
append	function
(	O
code	int
,	O
"_omega_%d:\n"	pointer
,	O
label_count	int
)	O
;	O
}	O
if	O
(	O
t_delim	O
(	O
S_COMMA	int
)	O
)	O
{	O
get_token	function
(	O
)	O
;	O
goto	O
loop	O
;	O
}	O
if	O
(	O
!	O
t_delim	O
(	O
S_DO	int
)	O
)	O
error	function
(	O
"missing `do' delimiter after for list"	pointer
)	O
;	O
{	O
CODE	struct
*	O
stmt	int
;	O
int	O
ssn	int
=	O
t_ssn	O
;	O
stmt	int
=	O
enter_block	function
(	O
NULL	O
,	O
t_ssn	O
)	O
;	O
append	function
(	O
stmt	int
,	O
"      dsa_%d->new_top_%d = "	pointer
a_stack_top	pointer
";\n"	pointer
,	O
current_level	function
(	O
)	O
,	O
block_level	function
(	O
current	pointer
)	O
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_DO	int
)	O
)	O
get_token	function
(	O
)	O
;	O
catenate	function
(	O
stmt	int
,	O
label_list	function
(	O
)	O
)	O
;	O
catenate	function
(	O
stmt	int
,	O
statement	function
(	O
)	O
)	O
;	O
catenate	function
(	O
stmt	int
,	O
leave_block	function
(	O
)	O
)	O
;	O
append	function
(	O
emit	pointer
,	O
"static void _sigma_%d(void)\n"	pointer
,	O
count	int
)	O
;	O
append	function
(	O
emit	pointer
,	O
"{     /* statement following 'do' at line %d */\n"	pointer
,	O
ssn	int
)	O
;	O
emit_dsa_pointers	function
(	O
)	O
;	O
catenate	function
(	O
emit	pointer
,	O
stmt	int
)	O
;	O
append	function
(	O
emit	pointer
,	O
"      return;\n"	pointer
)	O
;	O
append	function
(	O
emit	pointer
,	O
"}\n"	pointer
)	O
;	O
append	function
(	O
emit	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
return	O
code	int
;	O
}	O
static	O
CODE	struct
*	O
procedure_statement	function
(	O
void	O
)	O
{	O
CODE	struct
*	O
code	int
;	O
IDENT	struct
*	O
proc	pointer
;	O
assert	O
(	O
t_code	O
==	O
T_IDENT	int
)	O
;	O
proc	pointer
=	O
look_up	function
(	O
t_image	O
,	O
0	int
,	O
t_ssn	O
)	O
;	O
if	O
(	O
second_pass	int
&&	O
strcmp	function
(	O
proc	pointer
->	O
name	pointer
,	O
"inline"	pointer
)	O
==	O
0	int
&&	O
(	O
proc	pointer
->	O
flags	int
&	O
F_BLTIN	int
)	O
)	O
{	O
get_token	function
(	O
)	O
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_LEFT	int
)	O
)	O
err	O
:	O
{	O
error	function
(	O
"invalid use of pseudo procedure `inline'; translatio"	pointer
"n terminated"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
get_token	function
(	O
)	O
;	O
if	O
(	O
t_code	O
!=	O
T_STRING	int
)	O
goto	O
err	O
;	O
code	int
=	O
new_code	function
(	O
)	O
;	O
append	function
(	O
code	int
,	O
"      /* inline code */\n      "	pointer
)	O
;	O
{	O
char	O
*	O
p	pointer
=	O
t_image	O
,	O
*	O
q	pointer
=	O
t_image	O
+	O
1	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
*	O
q	pointer
==	O
'"'	O
)	O
break	O
;	O
if	O
(	O
*	O
q	pointer
==	O
'\\'	O
)	O
q	pointer
++	O
;	O
assert	O
(	O
*	O
q	pointer
)	O
;	O
*	O
p	pointer
++	O
=	O
*	O
q	pointer
++	O
;	O
}	O
*	O
p	pointer
=	O
'\0'	O
;	O
}	O
append	function
(	O
code	int
,	O
"%s\n"	pointer
,	O
t_image	O
)	O
;	O
get_token	function
(	O
)	O
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_RIGHT	int
)	O
||	O
ext_comma	function
(	O
)	O
)	O
goto	O
err	O
;	O
get_token	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
second_pass	int
&&	O
strcmp	function
(	O
proc	pointer
->	O
name	pointer
,	O
"print"	pointer
)	O
==	O
0	int
&&	O
(	O
proc	pointer
->	O
flags	int
&	O
F_BLTIN	int
)	O
)	O
{	O
int	O
count	int
=	O
0	int
;	O
char	O
*	O
place	pointer
;	O
get_token	function
(	O
)	O
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_LEFT	int
)	O
)	O
{	O
error	function
(	O
"invalid use of pseudo procedure `print'"	pointer
)	O
;	O
code	int
=	O
new_code	function
(	O
)	O
;	O
goto	O
done	O
;	O
}	O
get_token	function
(	O
)	O
;	O
code	int
=	O
new_code	function
(	O
)	O
;	O
append	function
(	O
code	int
,	O
"      "	pointer
a_print	pointer
"(???"	pointer
)	O
;	O
place	pointer
=	O
strchr	function
(	O
code	int
->	O
tail	pointer
->	O
str	pointer
,	O
'?'	O
)	O
;	O
assert	O
(	O
place	pointer
!=	O
NULL	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
IDENT	struct
*	O
id	pointer
;	O
CODE	struct
*	O
expr	pointer
;	O
if	O
(	O
t_code	O
==	O
T_IDENT	int
)	O
get_token2	function
(	O
)	O
;	O
if	O
(	O
t_code	O
==	O
T_IDENT	int
&&	O
token	array
[	O
2	int
]	O
.	O
code	int
==	O
T_DELIM	int
&&	O
(	O
token	array
[	O
2	int
]	O
.	O
delim	int
==	O
S_COMMA	int
||	O
token	array
[	O
2	int
]	O
.	O
delim	int
==	O
S_RIGHT	int
)	O
)	O
{	O
id	pointer
=	O
look_up	function
(	O
t_image	O
,	O
0	int
,	O
t_ssn	O
)	O
;	O
}	O
else	O
{	O
id	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
id	pointer
!=	O
NULL	O
&&	O
(	O
id	pointer
->	O
flags	int
&	O
F_ARRAY	int
)	O
)	O
{	O
expr	pointer
=	O
actual_parameter	function
(	O
NULL	O
)	O
;	O
append	function
(	O
code	int
,	O
", 0x%04X, "	pointer
,	O
F_ARRAY	int
)	O
;	O
}	O
else	O
if	O
(	O
id	pointer
!=	O
NULL	O
&&	O
(	O
id	pointer
->	O
flags	int
&	O
F_STRING	int
)	O
)	O
{	O
expr	pointer
=	O
actual_parameter	function
(	O
NULL	O
)	O
;	O
append	function
(	O
code	int
,	O
", 0x%04X, "	pointer
,	O
F_STRING	int
)	O
;	O
}	O
else	O
if	O
(	O
t_code	O
==	O
T_STRING	int
)	O
{	O
expr	pointer
=	O
new_code	function
(	O
)	O
;	O
append	function
(	O
expr	pointer
,	O
a_make_arg	pointer
"("	pointer
)	O
;	O
append	function
(	O
expr	pointer
,	O
"%s"	pointer
,	O
t_image	O
)	O
;	O
append	function
(	O
expr	pointer
,	O
", NULL)"	pointer
)	O
;	O
append	function
(	O
code	int
,	O
", 0x%04X, "	pointer
,	O
F_STRING	int
)	O
;	O
get_token	function
(	O
)	O
;	O
}	O
else	O
{	O
expr	pointer
=	O
expression	function
(	O
)	O
;	O
append	function
(	O
code	int
,	O
", 0x%04X, "	pointer
,	O
expr	pointer
->	O
type	int
)	O
;	O
}	O
if	O
(	O
id	pointer
!=	O
NULL	O
)	O
append	function
(	O
code	int
,	O
"\"%s\", "	pointer
,	O
id	pointer
->	O
name	pointer
)	O
;	O
else	O
append	function
(	O
code	int
,	O
"NULL, "	pointer
)	O
;	O
catenate	function
(	O
code	int
,	O
expr	pointer
)	O
;	O
count	int
++	O
;	O
if	O
(	O
!	O
ext_comma	function
(	O
)	O
)	O
break	O
;	O
}	O
assert	O
(	O
t_delim	O
(	O
S_RIGHT	int
)	O
)	O
;	O
get_token	function
(	O
)	O
;	O
append	function
(	O
code	int
,	O
");\n"	pointer
)	O
;	O
assert	O
(	O
count	int
<=	O
255	int
)	O
;	O
sprintf	function
(	O
place	pointer
,	O
"%3d"	pointer
,	O
count	int
)	O
;	O
}	O
else	O
{	O
code	int
=	O
function_designator	function
(	O
1	int
)	O
;	O
prepend	function
(	O
code	int
,	O
"      "	pointer
)	O
;	O
append	function
(	O
code	int
,	O
";\n"	pointer
)	O
;	O
}	O
done	O
:	O
return	O
code	int
;	O
}	O
static	O
int	O
is_declaration	function
(	O
void	O
)	O
;	O
static	O
CODE	struct
*	O
block_or_compound_statement	function
(	O
void	O
)	O
;	O
static	O
CODE	struct
*	O
statement	function
(	O
void	O
)	O
{	O
CODE	struct
*	O
code	int
;	O
if	O
(	O
t_code	O
==	O
T_IDENT	int
)	O
get_token2	function
(	O
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_BEGIN	int
)	O
)	O
{	O
code	int
=	O
block_or_compound_statement	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
t_code	O
==	O
T_IDENT	int
&&	O
token	array
[	O
2	int
]	O
.	O
code	int
==	O
T_DELIM	int
&&	O
(	O
token	array
[	O
2	int
]	O
.	O
delim	int
==	O
S_ASSIGN	int
||	O
token	array
[	O
2	int
]	O
.	O
delim	int
==	O
S_BEGSUB	int
)	O
)	O
{	O
code	int
=	O
assignment_statement	function
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
t_delim	O
(	O
S_GOTO	int
)	O
)	O
{	O
code	int
=	O
go_to_statement	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
t_delim	O
(	O
S_ELSE	int
)	O
||	O
t_delim	O
(	O
S_END	int
)	O
||	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
{	O
code	int
=	O
dummy_statement	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
t_delim	O
(	O
S_IF	int
)	O
)	O
{	O
code	int
=	O
conditional_statement	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
t_delim	O
(	O
S_FOR	int
)	O
)	O
{	O
code	int
=	O
for_statement	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
t_code	O
==	O
T_IDENT	int
&&	O
token	array
[	O
2	int
]	O
.	O
code	int
==	O
T_DELIM	int
&&	O
(	O
token	array
[	O
2	int
]	O
.	O
delim	int
==	O
S_LEFT	int
||	O
token	array
[	O
2	int
]	O
.	O
delim	int
==	O
S_ELSE	int
||	O
token	array
[	O
2	int
]	O
.	O
delim	int
==	O
S_END	int
||	O
token	array
[	O
2	int
]	O
.	O
delim	int
==	O
S_SEMICOLON	int
)	O
)	O
{	O
code	int
=	O
procedure_statement	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
t_delim	O
(	O
S_EOF	int
)	O
)	O
error	function
(	O
"unexpected eof"	pointer
)	O
;	O
else	O
{	O
if	O
(	O
t_code	O
==	O
T_IDENT	int
)	O
error	function
(	O
"invalid use of identifier `%s'"	pointer
,	O
t_image	O
)	O
;	O
else	O
if	O
(	O
t_code	O
==	O
T_INT	int
||	O
t_code	O
==	O
T_REAL	int
||	O
t_code	O
==	O
T_FALSE	int
||	O
t_code	O
==	O
T_TRUE	int
)	O
error	function
(	O
"invalid use of constant `%s'"	pointer
,	O
t_image	O
)	O
;	O
else	O
if	O
(	O
t_code	O
==	O
T_STRING	int
)	O
error	function
(	O
"invalid use of string"	pointer
)	O
;	O
else	O
if	O
(	O
is_declaration	function
(	O
)	O
)	O
error	function
(	O
"declarator `%s' in invalid position"	pointer
,	O
t_image	O
)	O
;	O
else	O
error	function
(	O
"invalid use of delimiter `%s'"	pointer
,	O
t_image	O
)	O
;	O
while	O
(	O
!	O
(	O
t_delim	O
(	O
S_EOF	int
)	O
||	O
t_delim	O
(	O
S_ELSE	int
)	O
||	O
t_delim	O
(	O
S_END	int
)	O
||	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
)	O
get_token	function
(	O
)	O
;	O
}	O
if	O
(	O
!	O
(	O
t_delim	O
(	O
S_EOF	int
)	O
||	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
||	O
t_delim	O
(	O
S_ELSE	int
)	O
||	O
t_delim	O
(	O
S_END	int
)	O
)	O
)	O
{	O
error	function
(	O
"missing semicolon, `else', or `end' after statement"	pointer
)	O
;	O
while	O
(	O
!	O
(	O
t_delim	O
(	O
S_EOF	int
)	O
||	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
||	O
t_delim	O
(	O
S_ELSE	int
)	O
||	O
t_delim	O
(	O
S_END	int
)	O
)	O
)	O
get_token	function
(	O
)	O
;	O
}	O
return	O
code	int
;	O
}	O
static	O
int	O
has_labels	function
(	O
BLOCK	struct
*	O
b	pointer
)	O
{	O
IDENT	struct
*	O
id	pointer
;	O
assert	O
(	O
second_pass	int
)	O
;	O
for	O
(	O
id	pointer
=	O
b	pointer
->	O
first	pointer
;	O
id	pointer
!=	O
NULL	O
;	O
id	pointer
=	O
id	pointer
->	O
next	pointer
)	O
if	O
(	O
id	pointer
->	O
flags	int
==	O
F_LABEL	int
&&	O
id	pointer
->	O
ssn_used	int
!=	O
0	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
CODE	struct
*	O
enter_block	function
(	O
IDENT	struct
*	O
proc	pointer
,	O
int	O
ssn	int
)	O
{	O
BLOCK	struct
*	O
b	pointer
;	O
CODE	struct
*	O
code	int
=	O
new_code	function
(	O
)	O
;	O
if	O
(	O
first_pass	int
)	O
{	O
b	pointer
=	O
my_malloc	function
(	O
sizeof	O
(	O
BLOCK	struct
)	O
)	O
;	O
b	pointer
->	O
seqn	int
=	O
(	O
last_b	pointer
==	O
NULL	O
?	O
0	int
:	O
last_b	pointer
->	O
seqn	int
+	O
1	int
)	O
;	O
b	pointer
->	O
ssn	int
=	O
ssn	int
;	O
b	pointer
->	O
proc	pointer
=	O
proc	pointer
;	O
b	pointer
->	O
first	pointer
=	O
b	pointer
->	O
last	pointer
=	O
NULL	O
;	O
b	pointer
->	O
surr	pointer
=	O
current	pointer
;	O
b	pointer
->	O
next	pointer
=	O
NULL	O
;	O
if	O
(	O
first_b	pointer
==	O
NULL	O
)	O
first_b	pointer
=	O
b	pointer
;	O
else	O
last_b	pointer
->	O
next	pointer
=	O
b	pointer
;	O
current	pointer
=	O
last_b	pointer
=	O
b	pointer
;	O
}	O
else	O
{	O
if	O
(	O
last_b	pointer
==	O
NULL	O
)	O
last_b	pointer
=	O
first_b	pointer
;	O
else	O
last_b	pointer
=	O
last_b	pointer
->	O
next	pointer
;	O
current	pointer
=	O
last_b	pointer
;	O
assert	O
(	O
current	pointer
!=	O
NULL	O
)	O
;	O
append	function
(	O
code	int
,	O
"      /* start of %s block %d (level %d) at line"	pointer
" %d */\n"	pointer
,	O
proc	pointer
!=	O
NULL	O
?	O
"procedure"	pointer
:	O
"local"	pointer
,	O
current	pointer
->	O
seqn	int
,	O
block_level	function
(	O
current	pointer
)	O
,	O
current	pointer
->	O
ssn	int
)	O
;	O
append	function
(	O
code	int
,	O
"      dsa_%d->old_top_%d = "	pointer
a_stack_top	pointer
";\n"	pointer
,	O
current_level	function
(	O
)	O
,	O
block_level	function
(	O
current	pointer
)	O
)	O
;	O
if	O
(	O
has_labels	function
(	O
current	pointer
)	O
)	O
{	O
IDENT	struct
*	O
id	pointer
;	O
append	function
(	O
code	int
,	O
"      /* jmp_buf must be of array type (ISO) "	pointer
"*/\n"	pointer
)	O
;	O
append	function
(	O
code	int
,	O
"      switch (setjmp(&dsa_%d->jump_%d[0]))\n"	pointer
,	O
current_level	function
(	O
)	O
,	O
block_level	function
(	O
current	pointer
)	O
)	O
;	O
append	function
(	O
code	int
,	O
"      {  case 0: break;\n"	pointer
)	O
;	O
for	O
(	O
id	pointer
=	O
current	pointer
->	O
first	pointer
;	O
id	pointer
!=	O
NULL	O
;	O
id	pointer
=	O
id	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
!	O
(	O
id	pointer
->	O
flags	int
==	O
F_LABEL	int
&&	O
id	pointer
->	O
ssn_used	int
!=	O
0	int
)	O
)	O
continue	O
;	O
assert	O
(	O
id	pointer
->	O
dim	int
>	O
0	int
)	O
;	O
append	function
(	O
code	int
,	O
"         case %d: "	pointer
a_pop_stack	pointer
"(dsa_%d->"	pointer
"new_top_%d); "	pointer
a_active_dsa	pointer
" = (struct dsa *)dsa_%d"	pointer
"; goto %s_%d;\n"	pointer
,	O
id	pointer
->	O
dim	int
,	O
current_level	function
(	O
)	O
,	O
block_level	function
(	O
current	pointer
)	O
,	O
current_level	function
(	O
)	O
,	O
id	pointer
->	O
name	pointer
,	O
current	pointer
->	O
seqn	int
)	O
;	O
}	O
append	function
(	O
code	int
,	O
"         default: "	pointer
a_fault	pointer
"(\"internal erro"	pointer
"r on global go to\");\n"	pointer
)	O
;	O
append	function
(	O
code	int
,	O
"      }\n"	pointer
)	O
;	O
}	O
}	O
return	O
code	int
;	O
}	O
static	O
CODE	struct
*	O
leave_block	function
(	O
void	O
)	O
{	O
BLOCK	struct
*	O
old	pointer
=	O
current	pointer
;	O
CODE	struct
*	O
code	int
=	O
new_code	function
(	O
)	O
;	O
assert	O
(	O
current	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
append	function
(	O
code	int
,	O
"      "	pointer
a_pop_stack	pointer
"(dsa_%d->old_top_%d);\n"	pointer
,	O
current_level	function
(	O
)	O
,	O
block_level	function
(	O
current	pointer
)	O
)	O
;	O
append	function
(	O
code	int
,	O
"      /* end of block %d */\n"	pointer
,	O
current	pointer
->	O
seqn	int
)	O
;	O
}	O
current	pointer
=	O
current	pointer
->	O
surr	pointer
;	O
if	O
(	O
first_pass	int
&&	O
current	pointer
!=	O
NULL	O
)	O
{	O
IDENT	struct
*	O
pred	pointer
,	O
*	O
id	pointer
,	O
*	O
it	pointer
;	O
pred	pointer
=	O
NULL	O
;	O
id	pointer
=	O
old	pointer
->	O
first	pointer
;	O
while	O
(	O
id	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
id	pointer
->	O
flags	int
==	O
0	int
)	O
{	O
if	O
(	O
pred	pointer
==	O
NULL	O
)	O
old	pointer
->	O
first	pointer
=	O
id	pointer
->	O
next	pointer
;	O
else	O
pred	pointer
->	O
next	pointer
=	O
id	pointer
->	O
next	pointer
;	O
if	O
(	O
old	pointer
->	O
last	pointer
==	O
id	pointer
)	O
old	pointer
->	O
last	pointer
=	O
pred	pointer
;	O
it	pointer
=	O
look_up	function
(	O
id	pointer
->	O
name	pointer
,	O
0	int
,	O
id	pointer
->	O
ssn_used	int
)	O
;	O
if	O
(	O
it	pointer
->	O
dim	int
<	O
0	int
)	O
it	pointer
->	O
dim	int
=	O
id	pointer
->	O
dim	int
;	O
it	pointer
=	O
id	pointer
,	O
id	pointer
=	O
id	pointer
->	O
next	pointer
;	O
my_free	function
(	O
it	pointer
)	O
;	O
}	O
else	O
pred	pointer
=	O
id	pointer
,	O
id	pointer
=	O
id	pointer
->	O
next	pointer
;	O
}	O
}	O
return	O
code	int
;	O
}	O
static	O
int	O
is_declaration	function
(	O
void	O
)	O
{	O
if	O
(	O
t_delim	O
(	O
S_ARRAY	int
)	O
||	O
t_delim	O
(	O
S_BOOLEAN	int
)	O
||	O
t_delim	O
(	O
S_INTEGER	int
)	O
||	O
t_delim	O
(	O
S_OWN	int
)	O
||	O
t_delim	O
(	O
S_PROCEDURE	int
)	O
||	O
t_delim	O
(	O
S_REAL	int
)	O
||	O
t_delim	O
(	O
S_SWITCH	int
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
CODE	struct
*	O
declaration	function
(	O
void	O
)	O
;	O
static	O
CODE	struct
*	O
block_or_compound_statement	function
(	O
void	O
)	O
{	O
CODE	struct
*	O
code	int
;	O
int	O
is_block	int
;	O
assert	O
(	O
t_delim	O
(	O
S_BEGIN	int
)	O
)	O
;	O
get_token	function
(	O
)	O
;	O
is_block	int
=	O
is_declaration	function
(	O
)	O
;	O
if	O
(	O
is_block	int
)	O
{	O
code	int
=	O
enter_block	function
(	O
NULL	O
,	O
t_ssn	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
!	O
is_declaration	function
(	O
)	O
)	O
break	O
;	O
catenate	function
(	O
code	int
,	O
declaration	function
(	O
)	O
)	O
;	O
assert	O
(	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
||	O
t_delim	O
(	O
S_EOF	int
)	O
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
get_token	function
(	O
)	O
;	O
}	O
append	function
(	O
code	int
,	O
"      dsa_%d->new_top_%d = "	pointer
a_stack_top	pointer
";\n"	pointer
,	O
current_level	function
(	O
)	O
,	O
block_level	function
(	O
current	pointer
)	O
)	O
;	O
}	O
else	O
{	O
code	int
=	O
new_code	function
(	O
)	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
catenate	function
(	O
code	int
,	O
label_list	function
(	O
)	O
)	O
;	O
catenate	function
(	O
code	int
,	O
statement	function
(	O
)	O
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_EOF	int
)	O
)	O
{	O
error	function
(	O
"missing `end' bracket"	pointer
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
t_delim	O
(	O
S_ELSE	int
)	O
)	O
{	O
error	function
(	O
"invalid use of delimiter `else' outside if statement"	pointer
)	O
;	O
get_token	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
t_delim	O
(	O
S_END	int
)	O
)	O
break	O
;	O
else	O
if	O
(	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
{	O
get_token	function
(	O
)	O
;	O
}	O
else	O
assert	O
(	O
2	int
+	O
2	int
==	O
5	int
)	O
;	O
}	O
if	O
(	O
is_block	int
)	O
catenate	function
(	O
code	int
,	O
leave_block	function
(	O
)	O
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_END	int
)	O
)	O
get_token	function
(	O
)	O
;	O
return	O
code	int
;	O
}	O
static	O
void	O
type_declaration	function
(	O
int	O
flags	int
)	O
{	O
IDENT	struct
*	O
id	pointer
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
t_code	O
!=	O
T_IDENT	int
)	O
{	O
error	function
(	O
"missing simple variable identifier"	pointer
)	O
;	O
break	O
;	O
}	O
id	pointer
=	O
look_up	function
(	O
t_image	O
,	O
1	int
,	O
t_ssn	O
)	O
;	O
id	pointer
->	O
flags	int
=	O
flags	int
;	O
if	O
(	O
flags	int
&	O
F_OWN	int
)	O
{	O
if	O
(	O
flags	int
&	O
F_REAL	int
)	O
append	function
(	O
emit	pointer
,	O
"static double %s_%d = 0.0;\n\n"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
id	pointer
->	O
block	pointer
->	O
seqn	int
)	O
;	O
else	O
if	O
(	O
flags	int
&	O
F_INT	int
)	O
append	function
(	O
emit	pointer
,	O
"static int %s_%d = 0;\n\n"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
id	pointer
->	O
block	pointer
->	O
seqn	int
)	O
;	O
else	O
if	O
(	O
flags	int
&	O
F_BOOL	int
)	O
append	function
(	O
emit	pointer
,	O
"static bool %s_%d = false;\n\n"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
id	pointer
->	O
block	pointer
->	O
seqn	int
)	O
;	O
else	O
assert	O
(	O
flags	int
!=	O
flags	int
)	O
;	O
}	O
get_token	function
(	O
)	O
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_COMMA	int
)	O
)	O
break	O
;	O
get_token	function
(	O
)	O
;	O
}	O
if	O
(	O
!	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
{	O
error	function
(	O
"missing semicolon after type declaration"	pointer
)	O
;	O
while	O
(	O
!	O
(	O
t_delim	O
(	O
S_EOF	int
)	O
||	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
)	O
get_token	function
(	O
)	O
;	O
}	O
return	O
;	O
}	O
static	O
CODE	struct
*	O
own_bound	function
(	O
void	O
)	O
{	O
CODE	struct
*	O
code	int
=	O
new_code	function
(	O
)	O
,	O
*	O
expr	pointer
;	O
if	O
(	O
t_delim	O
(	O
S_PLUS	int
)	O
)	O
append	function
(	O
code	int
,	O
"+"	pointer
)	O
,	O
get_token	function
(	O
)	O
;	O
else	O
if	O
(	O
t_delim	O
(	O
S_MINUS	int
)	O
)	O
append	function
(	O
code	int
,	O
"-"	pointer
)	O
,	O
get_token	function
(	O
)	O
;	O
if	O
(	O
t_code	O
==	O
T_INT	int
)	O
get_token2	function
(	O
)	O
;	O
if	O
(	O
!	O
(	O
t_code	O
==	O
T_INT	int
&&	O
token	array
[	O
2	int
]	O
.	O
code	int
==	O
T_DELIM	int
&&	O
(	O
token	array
[	O
2	int
]	O
.	O
delim	int
==	O
S_COLON	int
||	O
token	array
[	O
2	int
]	O
.	O
delim	int
==	O
S_COMMA	int
||	O
token	array
[	O
2	int
]	O
.	O
delim	int
==	O
S_ENDSUB	int
)	O
)	O
)	O
error	function
(	O
"invalid bound expression for own array"	pointer
)	O
;	O
expr	pointer
=	O
expression	function
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
code	int
->	O
type	int
=	O
expr	pointer
->	O
type	int
;	O
catenate	function
(	O
code	int
,	O
expr	pointer
)	O
;	O
return	O
code	int
;	O
}	O
static	O
CODE	struct
*	O
array_declaration	function
(	O
int	O
flags	int
)	O
{	O
CODE	struct
*	O
code	int
=	O
new_code	function
(	O
)	O
;	O
IDENT	struct
*	O
id	pointer
[	O
1	int
+	O
100	int
]	O
;	O
int	O
n	int
,	O
dim	int
;	O
char	O
*	O
place	pointer
;	O
array_decl_flag	int
=	O
1	int
;	O
loop	O
:	O
for	O
(	O
n	int
=	O
1	int
;	O
;	O
n	int
++	O
)	O
{	O
if	O
(	O
t_code	O
!=	O
T_IDENT	int
)	O
{	O
error	function
(	O
"missing array identifier"	pointer
)	O
;	O
goto	O
skip	O
;	O
}	O
if	O
(	O
n	int
>	O
100	int
)	O
{	O
error	function
(	O
"too many identifiers in array segment"	pointer
)	O
;	O
n	int
=	O
1	int
;	O
}	O
id	pointer
[	O
n	int
]	O
=	O
look_up	function
(	O
t_image	O
,	O
1	int
,	O
t_ssn	O
)	O
;	O
id	pointer
[	O
n	int
]	O
->	O
flags	int
=	O
flags	int
;	O
get_token	function
(	O
)	O
;	O
if	O
(	O
flags	int
&	O
F_OWN	int
)	O
append	function
(	O
emit	pointer
,	O
"static struct dv *%s_%d = NULL;\n\n"	pointer
,	O
id	pointer
[	O
n	int
]	O
->	O
name	pointer
,	O
id	pointer
[	O
n	int
]	O
->	O
block	pointer
->	O
seqn	int
)	O
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_COMMA	int
)	O
)	O
break	O
;	O
get_token	function
(	O
)	O
;	O
}	O
if	O
(	O
!	O
t_delim	O
(	O
S_BEGSUB	int
)	O
)	O
{	O
error	function
(	O
"missing left parenthesis after array segment"	pointer
)	O
;	O
goto	O
skip	O
;	O
}	O
catenate	function
(	O
code	int
,	O
emit_ssn	function
(	O
id	pointer
[	O
n	int
]	O
->	O
ssn_decl	int
)	O
)	O
;	O
if	O
(	O
flags	int
&	O
F_OWN	int
)	O
append	function
(	O
code	int
,	O
"      if (%s_%d == NULL) %s_%d = "	pointer
a_own_array	pointer
,	O
id	pointer
[	O
n	int
]	O
->	O
name	pointer
,	O
id	pointer
[	O
n	int
]	O
->	O
block	pointer
->	O
seqn	int
,	O
id	pointer
[	O
n	int
]	O
->	O
name	pointer
,	O
id	pointer
[	O
n	int
]	O
->	O
block	pointer
->	O
seqn	int
)	O
;	O
else	O
append	function
(	O
code	int
,	O
"      dsa_%d->%s_%d = "	pointer
a_alloc_array	pointer
,	O
current_level	function
(	O
)	O
,	O
id	pointer
[	O
n	int
]	O
->	O
name	pointer
,	O
id	pointer
[	O
n	int
]	O
->	O
block	pointer
->	O
seqn	int
)	O
;	O
append	function
(	O
code	int
,	O
"('%s', ?, "	pointer
,	O
(	O
flags	int
&	O
F_REAL	int
)	O
?	O
"r"	pointer
:	O
(	O
flags	int
&	O
F_INT	int
)	O
?	O
"i"	pointer
:	O
"b"	pointer
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
place	pointer
=	O
strchr	function
(	O
code	int
->	O
tail	pointer
->	O
str	pointer
,	O
'?'	O
)	O
;	O
assert	O
(	O
place	pointer
!=	O
NULL	O
)	O
;	O
}	O
get_token	function
(	O
)	O
;	O
dim	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
CODE	struct
*	O
bound	pointer
;	O
if	O
(	O
dim	int
==	O
9	int
)	O
{	O
error	function
(	O
"array dimension exceeds allowable maximum"	pointer
)	O
;	O
dim	int
=	O
0	int
;	O
}	O
dim	int
++	O
;	O
bound	pointer
=	O
flags	int
&	O
F_OWN	int
?	O
own_bound	function
(	O
)	O
:	O
expression	function
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
bound	pointer
->	O
type	int
==	O
F_REAL	int
)	O
to_int	function
(	O
bound	pointer
)	O
;	O
if	O
(	O
bound	pointer
->	O
type	int
!=	O
F_INT	int
)	O
{	O
error	function
(	O
"bound expression is not of arithmetic type"	pointer
)	O
;	O
bound	pointer
->	O
type	int
=	O
F_INT	int
;	O
}	O
catenate	function
(	O
code	int
,	O
bound	pointer
)	O
;	O
append	function
(	O
code	int
,	O
", "	pointer
)	O
;	O
}	O
if	O
(	O
!	O
t_delim	O
(	O
S_COLON	int
)	O
)	O
{	O
error	function
(	O
"missing colon between bound expressions"	pointer
)	O
;	O
goto	O
skip	O
;	O
}	O
get_token	function
(	O
)	O
;	O
bound	pointer
=	O
flags	int
&	O
F_OWN	int
?	O
own_bound	function
(	O
)	O
:	O
expression	function
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
if	O
(	O
bound	pointer
->	O
type	int
==	O
F_REAL	int
)	O
to_int	function
(	O
bound	pointer
)	O
;	O
if	O
(	O
bound	pointer
->	O
type	int
!=	O
F_INT	int
)	O
{	O
error	function
(	O
"bound expression is not of arithmetic type"	pointer
)	O
;	O
bound	pointer
->	O
type	int
=	O
F_INT	int
;	O
}	O
catenate	function
(	O
code	int
,	O
bound	pointer
)	O
;	O
append	function
(	O
code	int
,	O
t_delim	O
(	O
S_COMMA	int
)	O
?	O
", "	pointer
:	O
");\n"	pointer
)	O
;	O
}	O
if	O
(	O
!	O
t_delim	O
(	O
S_COMMA	int
)	O
)	O
break	O
;	O
get_token	function
(	O
)	O
;	O
}	O
if	O
(	O
!	O
t_delim	O
(	O
S_ENDSUB	int
)	O
)	O
{	O
error	function
(	O
"missing right parenthesis after bound list"	pointer
)	O
;	O
goto	O
skip	O
;	O
}	O
get_token	function
(	O
)	O
;	O
{	O
int	O
k	int
;	O
assert	O
(	O
1	int
<=	O
dim	int
&&	O
dim	int
<=	O
9	int
)	O
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<=	O
n	int
;	O
k	int
++	O
)	O
id	pointer
[	O
k	int
]	O
->	O
dim	int
=	O
dim	int
;	O
if	O
(	O
second_pass	int
)	O
*	O
place	pointer
=	O
(	O
char	O
)	O
(	O
dim	int
+	O
'0'	O
)	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
--	O
n	int
<	O
1	int
)	O
break	O
;	O
catenate	function
(	O
code	int
,	O
emit_ssn	function
(	O
id	pointer
[	O
n	int
]	O
->	O
ssn_decl	int
)	O
)	O
;	O
if	O
(	O
flags	int
&	O
F_OWN	int
)	O
append	function
(	O
code	int
,	O
"      if (%s_%d == NULL) %s_%d = "	pointer
a_own_same	pointer
,	O
id	pointer
[	O
n	int
]	O
->	O
name	pointer
,	O
id	pointer
[	O
n	int
]	O
->	O
block	pointer
->	O
seqn	int
,	O
id	pointer
[	O
n	int
]	O
->	O
name	pointer
,	O
id	pointer
[	O
n	int
]	O
->	O
block	pointer
->	O
seqn	int
)	O
;	O
else	O
append	function
(	O
code	int
,	O
"      dsa_%d->%s_%d = "	pointer
a_alloc_same	pointer
,	O
current_level	function
(	O
)	O
,	O
id	pointer
[	O
n	int
]	O
->	O
name	pointer
,	O
id	pointer
[	O
n	int
]	O
->	O
block	pointer
->	O
seqn	int
)	O
;	O
append	function
(	O
code	int
,	O
"('%s', "	pointer
,	O
(	O
flags	int
&	O
F_REAL	int
)	O
?	O
"r"	pointer
:	O
(	O
flags	int
&	O
F_INT	int
)	O
?	O
"i"	pointer
:	O
"b"	pointer
)	O
;	O
if	O
(	O
flags	int
&	O
F_OWN	int
)	O
append	function
(	O
code	int
,	O
"%s_%d);\n"	pointer
,	O
id	pointer
[	O
n	int
+	O
1	int
]	O
->	O
name	pointer
,	O
id	pointer
[	O
n	int
+	O
1	int
]	O
->	O
block	pointer
->	O
seqn	int
)	O
;	O
else	O
append	function
(	O
code	int
,	O
"dsa_%d->%s_%d);\n"	pointer
,	O
current_level	function
(	O
)	O
,	O
id	pointer
[	O
n	int
+	O
1	int
]	O
->	O
name	pointer
,	O
id	pointer
[	O
n	int
+	O
1	int
]	O
->	O
block	pointer
->	O
seqn	int
)	O
;	O
}	O
if	O
(	O
t_delim	O
(	O
S_COMMA	int
)	O
)	O
{	O
get_token	function
(	O
)	O
;	O
goto	O
loop	O
;	O
}	O
array_decl_flag	int
=	O
0	int
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
{	O
error	function
(	O
"missing semicolon after array declaration"	pointer
)	O
;	O
skip	O
:	O
while	O
(	O
!	O
(	O
t_delim	O
(	O
S_EOF	int
)	O
||	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
)	O
get_token	function
(	O
)	O
;	O
}	O
return	O
code	int
;	O
}	O
static	O
void	O
switch_declaration	function
(	O
void	O
)	O
{	O
IDENT	struct
*	O
id	pointer
;	O
int	O
dim	int
;	O
if	O
(	O
t_code	O
!=	O
T_IDENT	int
)	O
{	O
error	function
(	O
"missing switch identifier"	pointer
)	O
;	O
goto	O
skip	O
;	O
}	O
id	pointer
=	O
look_up	function
(	O
t_image	O
,	O
1	int
,	O
t_ssn	O
)	O
;	O
id	pointer
->	O
flags	int
=	O
F_SWITCH	int
;	O
get_token	function
(	O
)	O
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_ASSIGN	int
)	O
)	O
{	O
error	function
(	O
"missing `:=' after switch identifier"	pointer
)	O
;	O
goto	O
skip	O
;	O
}	O
get_token	function
(	O
)	O
;	O
append	function
(	O
emit	pointer
,	O
"static struct label %s_%d(int kase)\n"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
id	pointer
->	O
block	pointer
->	O
seqn	int
)	O
;	O
append	function
(	O
emit	pointer
,	O
"{     /* switch declaration at line %d */\n"	pointer
,	O
id	pointer
->	O
ssn_decl	int
)	O
;	O
emit_dsa_pointers	function
(	O
)	O
;	O
catenate	function
(	O
emit	pointer
,	O
emit_ssn	function
(	O
id	pointer
->	O
ssn_decl	int
)	O
)	O
;	O
append	function
(	O
emit	pointer
,	O
"      switch (kase)\n"	pointer
)	O
;	O
dim	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
CODE	struct
*	O
expr	pointer
=	O
expression	function
(	O
)	O
;	O
dim	int
++	O
;	O
if	O
(	O
second_pass	int
&&	O
expr	pointer
->	O
type	int
!=	O
F_LABEL	int
)	O
{	O
error	function
(	O
"expression in switch list is not of label type"	pointer
)	O
;	O
expr	pointer
->	O
type	int
=	O
F_LABEL	int
;	O
}	O
append	function
(	O
emit	pointer
,	O
"      %s  case %d: dsa_%d->line = %d; return "	pointer
,	O
dim	int
==	O
1	int
?	O
"{"	pointer
:	O
" "	pointer
,	O
dim	int
,	O
current_level	function
(	O
)	O
,	O
t_ssn	O
)	O
;	O
catenate	function
(	O
emit	pointer
,	O
expr	pointer
)	O
;	O
append	function
(	O
emit	pointer
,	O
";\n"	pointer
)	O
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_COMMA	int
)	O
)	O
break	O
;	O
get_token	function
(	O
)	O
;	O
}	O
append	function
(	O
emit	pointer
,	O
"         default: "	pointer
a_fault	pointer
"(\"switch designator u"	pointer
"ndefined\");\n"	pointer
)	O
;	O
append	function
(	O
emit	pointer
,	O
"      }\n"	pointer
)	O
;	O
append	function
(	O
emit	pointer
,	O
"      return "	pointer
a_make_label	pointer
"(NULL, 0);\n"	pointer
)	O
;	O
append	function
(	O
emit	pointer
,	O
"}\n\n"	pointer
)	O
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
{	O
error	function
(	O
"missing semicolon after switch declaration"	pointer
)	O
;	O
skip	O
:	O
while	O
(	O
!	O
(	O
t_delim	O
(	O
S_EOF	int
)	O
||	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
)	O
get_token	function
(	O
)	O
;	O
}	O
return	O
;	O
}	O
static	O
void	O
emit_proc_head	function
(	O
IDENT	struct
*	O
proc	pointer
,	O
int	O
flag	int
)	O
{	O
BLOCK	struct
*	O
b	pointer
;	O
IDENT	struct
*	O
id	pointer
;	O
if	O
(	O
first_pass	int
)	O
goto	O
skip	O
;	O
if	O
(	O
(	O
proc	pointer
->	O
flags	int
&	O
F_BLTIN	int
)	O
&&	O
(	O
strcmp	function
(	O
proc	pointer
->	O
name	pointer
,	O
"inline"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
proc	pointer
->	O
name	pointer
,	O
"print"	pointer
)	O
==	O
0	int
)	O
)	O
goto	O
skip	O
;	O
for	O
(	O
b	pointer
=	O
first_b	pointer
;	O
b	pointer
!=	O
NULL	O
;	O
b	pointer
=	O
b	pointer
->	O
next	pointer
)	O
if	O
(	O
b	pointer
->	O
proc	pointer
==	O
proc	pointer
)	O
break	O
;	O
assert	O
(	O
b	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
flag	int
)	O
{	O
if	O
(	O
proc	pointer
->	O
block	pointer
->	O
seqn	int
==	O
0	int
)	O
append	function
(	O
emit	pointer
,	O
"extern "	pointer
)	O
;	O
else	O
append	function
(	O
emit	pointer
,	O
"static "	pointer
)	O
;	O
}	O
append	function
(	O
emit	pointer
,	O
"struct desc %s_%d"	pointer
,	O
proc	pointer
->	O
name	pointer
,	O
proc	pointer
->	O
block	pointer
->	O
seqn	int
)	O
;	O
if	O
(	O
strcmp	function
(	O
proc	pointer
->	O
name	pointer
,	O
"main_program"	pointer
)	O
==	O
0	int
)	O
append	function
(	O
emit	pointer
,	O
" /* program */"	pointer
)	O
;	O
else	O
append	function
(	O
emit	pointer
,	O
" /* %s %s procedure */"	pointer
,	O
proc	pointer
->	O
flags	int
&	O
F_CODE	int
?	O
"code"	pointer
:	O
proc	pointer
->	O
flags	int
&	O
F_BLTIN	int
?	O
"builtin"	pointer
:	O
proc	pointer
->	O
block	pointer
->	O
seqn	int
==	O
0	int
?	O
"precompiled"	pointer
:	O
"local"	pointer
,	O
proc	pointer
->	O
flags	int
&	O
F_REAL	int
?	O
"real"	pointer
:	O
proc	pointer
->	O
flags	int
&	O
F_INT	int
?	O
"integer"	pointer
:	O
proc	pointer
->	O
flags	int
&	O
F_BOOL	int
?	O
"Boolean"	pointer
:	O
"void"	pointer
)	O
;	O
if	O
(	O
proc	pointer
->	O
dim	int
==	O
0	int
)	O
{	O
append	function
(	O
emit	pointer
,	O
" (void)"	pointer
)	O
;	O
goto	O
done	O
;	O
}	O
append	function
(	O
emit	pointer
,	O
"\n"	pointer
)	O
;	O
for	O
(	O
id	pointer
=	O
b	pointer
->	O
first	pointer
;	O
id	pointer
!=	O
NULL	O
;	O
id	pointer
=	O
id	pointer
->	O
next	pointer
)	O
{	O
append	function
(	O
emit	pointer
,	O
"%s     struct arg "	pointer
,	O
id	pointer
==	O
b	pointer
->	O
first	pointer
?	O
"("	pointer
:	O
" "	pointer
)	O
;	O
if	O
(	O
flag	int
)	O
append	function
(	O
emit	pointer
,	O
"/* %s:"	pointer
,	O
id	pointer
->	O
name	pointer
)	O
;	O
else	O
append	function
(	O
emit	pointer
,	O
"%s_%d /*"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
b	pointer
->	O
seqn	int
)	O
;	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_BYVAL	int
)	O
append	function
(	O
emit	pointer
,	O
" by value"	pointer
)	O
;	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_BYNAME	int
)	O
append	function
(	O
emit	pointer
,	O
" by name"	pointer
)	O
;	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_REAL	int
)	O
append	function
(	O
emit	pointer
,	O
" real"	pointer
)	O
;	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_INT	int
)	O
append	function
(	O
emit	pointer
,	O
" integer"	pointer
)	O
;	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_BOOL	int
)	O
append	function
(	O
emit	pointer
,	O
" Boolean"	pointer
)	O
;	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_LABEL	int
)	O
append	function
(	O
emit	pointer
,	O
" label"	pointer
)	O
;	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_ARRAY	int
)	O
append	function
(	O
emit	pointer
,	O
" array"	pointer
)	O
;	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_SWITCH	int
)	O
append	function
(	O
emit	pointer
,	O
" switch"	pointer
)	O
;	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_PROC	int
)	O
append	function
(	O
emit	pointer
,	O
" procedure"	pointer
)	O
;	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_STRING	int
)	O
append	function
(	O
emit	pointer
,	O
" string"	pointer
)	O
;	O
append	function
(	O
emit	pointer
,	O
" */%s"	pointer
,	O
id	pointer
->	O
next	pointer
==	O
NULL	O
?	O
"\n)"	pointer
:	O
",\n"	pointer
)	O
;	O
}	O
done	O
:	O
append	function
(	O
emit	pointer
,	O
flag	int
?	O
";\n\n"	pointer
:	O
"\n"	pointer
)	O
;	O
skip	O
:	O
return	O
;	O
}	O
static	O
void	O
procedure_declaration	function
(	O
int	O
flags	int
)	O
{	O
CODE	struct
*	O
code	int
,	O
*	O
prolog	pointer
;	O
IDENT	struct
*	O
proc	pointer
;	O
int	O
is_main	int
;	O
int	O
dim	int
;	O
if	O
(	O
token	array
[	O
0	int
]	O
.	O
code	int
==	O
T_DELIM	int
&&	O
token	array
[	O
0	int
]	O
.	O
delim	int
==	O
S_PROCEDURE	int
)	O
{	O
is_main	int
=	O
0	int
;	O
}	O
else	O
{	O
is_main	int
=	O
1	int
;	O
}	O
if	O
(	O
!	O
is_main	int
)	O
{	O
if	O
(	O
t_code	O
==	O
T_IDENT	int
)	O
{	O
proc	pointer
=	O
look_up	function
(	O
t_image	O
,	O
1	int
,	O
t_ssn	O
)	O
;	O
get_token	function
(	O
)	O
;	O
}	O
else	O
{	O
char	O
str	pointer
[	O
50	int
]	O
;	O
sprintf	function
(	O
str	pointer
,	O
"p_%d"	pointer
,	O
t_ssn	O
)	O
;	O
error	function
(	O
"missing procedure identifier after `procedure'; dumm"	pointer
"y identifier `%s' used"	pointer
,	O
str	pointer
)	O
;	O
proc	pointer
=	O
look_up	function
(	O
str	pointer
,	O
1	int
,	O
t_ssn	O
)	O
;	O
}	O
}	O
else	O
{	O
assert	O
(	O
current	pointer
->	O
seqn	int
==	O
0	int
)	O
;	O
proc	pointer
=	O
look_up	function
(	O
"main_program"	pointer
,	O
1	int
,	O
t_ssn	O
)	O
;	O
}	O
proc	pointer
->	O
flags	int
=	O
flags	int
;	O
prolog	pointer
=	O
enter_block	function
(	O
proc	pointer
,	O
t_ssn	O
)	O
;	O
dim	int
=	O
0	int
;	O
if	O
(	O
is_main	int
)	O
goto	O
skip	O
;	O
if	O
(	O
t_delim	O
(	O
S_LEFT	int
)	O
)	O
{	O
get_token	function
(	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
t_code	O
!=	O
T_IDENT	int
)	O
{	O
error	function
(	O
"missing formal parameter identifier"	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
first_pass	int
)	O
{	O
IDENT	struct
*	O
id	pointer
=	O
look_up	function
(	O
t_image	O
,	O
0	int
,	O
t_ssn	O
)	O
;	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_BYNAME	int
)	O
error	function
(	O
"formal parameter `%s' repeated in formal param"	pointer
"eter list"	pointer
,	O
id	pointer
->	O
name	pointer
)	O
;	O
id	pointer
->	O
flags	int
=	O
F_BYNAME	int
;	O
if	O
(	O
strcmp	function
(	O
id	pointer
->	O
name	pointer
,	O
proc	pointer
->	O
name	pointer
)	O
==	O
0	int
)	O
error	function
(	O
"formal parameter identifier `%s' is the same a"	pointer
"s procedure identifier"	pointer
,	O
id	pointer
->	O
name	pointer
)	O
;	O
}	O
dim	int
++	O
;	O
get_token	function
(	O
)	O
;	O
if	O
(	O
!	O
ext_comma	function
(	O
)	O
)	O
break	O
;	O
}	O
if	O
(	O
t_delim	O
(	O
S_RIGHT	int
)	O
)	O
get_token	function
(	O
)	O
;	O
else	O
error	function
(	O
"missing right parenthesis after formal parameter lis"	pointer
"t"	pointer
)	O
;	O
}	O
if	O
(	O
!	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
{	O
error	function
(	O
"missing semicolon after formal parameter part"	pointer
)	O
;	O
while	O
(	O
!	O
(	O
t_delim	O
(	O
S_EOF	int
)	O
||	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
)	O
get_token	function
(	O
)	O
;	O
}	O
get_token	function
(	O
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_VALUE	int
)	O
)	O
valp	O
:	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
get_token	function
(	O
)	O
;	O
if	O
(	O
t_code	O
!=	O
T_IDENT	int
)	O
{	O
error	function
(	O
"missing formal parameter identifier"	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
first_pass	int
)	O
{	O
IDENT	struct
*	O
id	pointer
=	O
look_up	function
(	O
t_image	O
,	O
0	int
,	O
t_ssn	O
)	O
;	O
if	O
(	O
!	O
id	pointer
->	O
flags	int
)	O
error	function
(	O
"identifier `%s' missing from formal parameter "	pointer
"list"	pointer
,	O
id	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_BYVAL	int
)	O
error	function
(	O
"formal parameter `%s' repeated in value part"	pointer
,	O
id	pointer
->	O
name	pointer
)	O
;	O
id	pointer
->	O
flags	int
=	O
F_BYVAL	int
;	O
}	O
get_token	function
(	O
)	O
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_COMMA	int
)	O
)	O
break	O
;	O
}	O
if	O
(	O
!	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
{	O
error	function
(	O
"missing semicolon after value part"	pointer
)	O
;	O
while	O
(	O
!	O
(	O
t_delim	O
(	O
S_EOF	int
)	O
||	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
)	O
get_token	function
(	O
)	O
;	O
}	O
get_token	function
(	O
)	O
;	O
}	O
while	O
(	O
t_delim	O
(	O
S_ARRAY	int
)	O
||	O
t_delim	O
(	O
S_BOOLEAN	int
)	O
||	O
t_delim	O
(	O
S_INTEGER	int
)	O
||	O
t_delim	O
(	O
S_LABEL	int
)	O
||	O
t_delim	O
(	O
S_PROCEDURE	int
)	O
||	O
t_delim	O
(	O
S_REAL	int
)	O
||	O
t_delim	O
(	O
S_STRING	int
)	O
||	O
t_delim	O
(	O
S_SWITCH	int
)	O
)	O
{	O
int	O
flags	int
;	O
if	O
(	O
t_delim	O
(	O
S_REAL	int
)	O
||	O
t_delim	O
(	O
S_INTEGER	int
)	O
||	O
t_delim	O
(	O
S_BOOLEAN	int
)	O
)	O
{	O
flags	int
=	O
t_delim	O
(	O
S_REAL	int
)	O
?	O
F_REAL	int
:	O
t_delim	O
(	O
S_INTEGER	int
)	O
?	O
F_INT	int
:	O
F_BOOL	int
;	O
get_token	function
(	O
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_ARRAY	int
)	O
)	O
flags	int
|=	O
F_ARRAY	int
,	O
get_token	function
(	O
)	O
;	O
else	O
if	O
(	O
t_delim	O
(	O
S_PROCEDURE	int
)	O
)	O
flags	int
|=	O
F_PROC	int
,	O
get_token	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
t_delim	O
(	O
S_LABEL	int
)	O
)	O
flags	int
=	O
F_LABEL	int
,	O
get_token	function
(	O
)	O
;	O
else	O
if	O
(	O
t_delim	O
(	O
S_ARRAY	int
)	O
)	O
flags	int
=	O
F_REAL	int
|	O
F_ARRAY	int
,	O
get_token	function
(	O
)	O
;	O
else	O
if	O
(	O
t_delim	O
(	O
S_SWITCH	int
)	O
)	O
flags	int
=	O
F_SWITCH	int
,	O
get_token	function
(	O
)	O
;	O
else	O
if	O
(	O
t_delim	O
(	O
S_PROCEDURE	int
)	O
)	O
flags	int
=	O
F_PROC	int
,	O
get_token	function
(	O
)	O
;	O
else	O
if	O
(	O
t_delim	O
(	O
S_STRING	int
)	O
)	O
flags	int
=	O
F_STRING	int
,	O
get_token	function
(	O
)	O
;	O
else	O
assert	O
(	O
2	int
+	O
2	int
==	O
5	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
t_code	O
!=	O
T_IDENT	int
)	O
{	O
error	function
(	O
"missing formal parameter identifier"	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
first_pass	int
)	O
{	O
IDENT	struct
*	O
id	pointer
=	O
look_up	function
(	O
t_image	O
,	O
0	int
,	O
t_ssn	O
)	O
;	O
if	O
(	O
!	O
id	pointer
->	O
flags	int
)	O
error	function
(	O
"identifier `%s' missing from formal parameter "	pointer
"list"	pointer
,	O
id	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
~	O
(	O
F_BYNAME	int
|	O
F_BYVAL	int
)	O
)	O
error	function
(	O
"formal parameter `%s' multiply specified"	pointer
,	O
id	pointer
->	O
name	pointer
)	O
;	O
id	pointer
->	O
ssn_decl	int
=	O
t_ssn	O
;	O
id	pointer
->	O
ssn_used	int
=	O
0	int
;	O
id	pointer
->	O
flags	int
|=	O
flags	int
;	O
if	O
(	O
(	O
id	pointer
->	O
flags	int
&	O
F_BYVAL	int
)	O
&&	O
(	O
id	pointer
->	O
flags	int
&	O
(	O
F_SWITCH	int
|	O
F_PROC	int
|	O
F_STRING	int
)	O
)	O
)	O
error	function
(	O
"invalid call by value of switch, procedure, or"	pointer
" string `%s'"	pointer
,	O
id	pointer
->	O
name	pointer
)	O
;	O
}	O
get_token	function
(	O
)	O
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_COMMA	int
)	O
)	O
break	O
;	O
get_token	function
(	O
)	O
;	O
}	O
if	O
(	O
!	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
{	O
error	function
(	O
"missing semicolon after specification"	pointer
)	O
;	O
while	O
(	O
!	O
(	O
t_delim	O
(	O
S_EOF	int
)	O
||	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
)	O
get_token	function
(	O
)	O
;	O
}	O
get_token	function
(	O
)	O
;	O
}	O
if	O
(	O
t_delim	O
(	O
S_VALUE	int
)	O
)	O
{	O
error	function
(	O
"specification part precedes value part"	pointer
)	O
;	O
goto	O
valp	O
;	O
}	O
{	O
IDENT	struct
*	O
id	pointer
;	O
int	O
ok	int
=	O
1	int
;	O
for	O
(	O
id	pointer
=	O
current	pointer
->	O
first	pointer
;	O
id	pointer
!=	O
NULL	O
;	O
id	pointer
=	O
id	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
!	O
(	O
id	pointer
->	O
flags	int
&	O
~	O
(	O
F_BYNAME	int
|	O
F_BYVAL	int
)	O
)	O
)	O
{	O
error	function
(	O
"formal parameter `%s' not specified"	pointer
,	O
id	pointer
->	O
name	pointer
)	O
;	O
ok	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
!	O
ok	int
)	O
error	function
(	O
"specification part of procedure `%s' incomplete"	pointer
,	O
proc	pointer
->	O
name	pointer
)	O
;	O
}	O
skip	O
:	O
proc	pointer
->	O
dim	int
=	O
dim	int
;	O
if	O
(	O
t_delim	O
(	O
S_CODE	int
)	O
)	O
{	O
assert	O
(	O
!	O
is_main	int
)	O
;	O
if	O
(	O
current	pointer
->	O
surr	pointer
->	O
seqn	int
!=	O
0	int
)	O
error	function
(	O
"invalid declaration of code procedure inside block"	pointer
)	O
;	O
proc	pointer
->	O
flags	int
|=	O
F_CODE	int
;	O
free_code	function
(	O
prolog	pointer
)	O
;	O
free_code	function
(	O
leave_block	function
(	O
)	O
)	O
;	O
get_token	function
(	O
)	O
;	O
if	O
(	O
!	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
{	O
error	function
(	O
"missing semicolon after 'code'"	pointer
)	O
;	O
while	O
(	O
!	O
(	O
t_delim	O
(	O
S_EOF	int
)	O
||	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
)	O
get_token	function
(	O
)	O
;	O
}	O
goto	O
done	O
;	O
}	O
code	int
=	O
new_code	function
(	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
append	function
(	O
code	int
,	O
"{     struct dsa_%s_%d my_dsa;\n"	pointer
,	O
proc	pointer
->	O
name	pointer
,	O
proc	pointer
->	O
block	pointer
->	O
seqn	int
)	O
;	O
{	O
int	O
level	int
=	O
dsa_level	function
(	O
proc	pointer
)	O
+	O
1	int
;	O
BLOCK	struct
*	O
b	pointer
;	O
for	O
(	O
b	pointer
=	O
current	pointer
;	O
b	pointer
;	O
b	pointer
=	O
b	pointer
->	O
surr	pointer
)	O
{	O
if	O
(	O
b	pointer
->	O
proc	pointer
==	O
NULL	O
)	O
continue	O
;	O
append	function
(	O
code	int
,	O
"      register struct dsa_%s_%d *dsa_%d = "	pointer
,	O
b	pointer
->	O
proc	pointer
->	O
name	pointer
,	O
b	pointer
->	O
proc	pointer
->	O
block	pointer
->	O
seqn	int
,	O
level	int
)	O
;	O
if	O
(	O
b	pointer
->	O
proc	pointer
==	O
proc	pointer
)	O
append	function
(	O
code	int
,	O
"&my_dsa;\n"	pointer
)	O
;	O
else	O
append	function
(	O
code	int
,	O
"(void *)"	pointer
a_global_dsa	pointer
"->vector[%d];\n"	pointer
,	O
level	int
)	O
;	O
level	int
--	O
;	O
}	O
}	O
append	function
(	O
code	int
,	O
"      my_dsa.proc = \"%s\";\n"	pointer
,	O
proc	pointer
->	O
name	pointer
)	O
;	O
{	O
char	O
str	pointer
[	O
100	int
+	O
10	int
]	O
,	O
*	O
t	pointer
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
,	O
t	pointer
=	O
infilename	pointer
;	O
k	int
<	O
100	int
&&	O
*	O
t	pointer
;	O
t	pointer
++	O
)	O
{	O
if	O
(	O
*	O
t	pointer
==	O
'\\'	O
||	O
*	O
t	pointer
==	O
'\"'	O
)	O
str	pointer
[	O
k	int
++	O
]	O
=	O
'\\'	O
;	O
str	pointer
[	O
k	int
++	O
]	O
=	O
*	O
t	pointer
;	O
}	O
str	pointer
[	O
k	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
*	O
t	pointer
)	O
strcat	function
(	O
str	pointer
,	O
"..."	pointer
)	O
;	O
append	function
(	O
code	int
,	O
"      my_dsa.file = \"%s\";\n"	pointer
,	O
str	pointer
)	O
;	O
}	O
append	function
(	O
code	int
,	O
"      my_dsa.line = %d;\n"	pointer
,	O
proc	pointer
->	O
ssn_decl	int
)	O
;	O
append	function
(	O
code	int
,	O
"      my_dsa.parent = "	pointer
a_active_dsa	pointer
", "	pointer
a_active_dsa	pointer
" = (struct dsa *)&my_dsa;\n"	pointer
)	O
;	O
{	O
int	O
level	int
=	O
dsa_level	function
(	O
proc	pointer
)	O
+	O
1	int
,	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<=	O
level	int
;	O
k	int
++	O
)	O
append	function
(	O
code	int
,	O
"      my_dsa.vector[%d] = (void *)dsa_%d;\n"	pointer
,	O
k	int
,	O
k	int
)	O
;	O
}	O
catenate	function
(	O
code	int
,	O
prolog	pointer
)	O
;	O
}	O
if	O
(	O
second_pass	int
)	O
{	O
IDENT	struct
*	O
id	pointer
;	O
for	O
(	O
id	pointer
=	O
current	pointer
->	O
first	pointer
;	O
id	pointer
!=	O
NULL	O
;	O
id	pointer
=	O
id	pointer
->	O
next	pointer
)	O
{	O
switch	O
(	O
id	pointer
->	O
flags	int
)	O
{	O
case	O
F_REAL	int
|	O
F_BYVAL	int
:	O
case	O
F_INT	int
|	O
F_BYVAL	int
:	O
case	O
F_BOOL	int
|	O
F_BYVAL	int
:	O
case	O
F_LABEL	int
|	O
F_BYVAL	int
:	O
append	function
(	O
code	int
,	O
"      my_dsa.line = %d;\n"	pointer
,	O
id	pointer
->	O
ssn_decl	int
)	O
;	O
append	function
(	O
code	int
,	O
"      my_dsa.%s_%d = %s(("	pointer
a_global_dsa	pointer
" = %s_%d.arg2, (*(struct desc (*)(void))%s_%d.arg"	pointer
"1)()));\n"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
current	pointer
->	O
seqn	int
,	O
(	O
id	pointer
->	O
flags	int
&	O
F_REAL	int
)	O
?	O
"get_real"	pointer
:	O
(	O
id	pointer
->	O
flags	int
&	O
F_INT	int
)	O
?	O
"get_int"	pointer
:	O
(	O
id	pointer
->	O
flags	int
&	O
F_BOOL	int
)	O
?	O
"get_bool"	pointer
:	O
(	O
id	pointer
->	O
flags	int
&	O
F_LABEL	int
)	O
?	O
"get_label"	pointer
:	O
"???"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
current	pointer
->	O
seqn	int
,	O
id	pointer
->	O
name	pointer
,	O
current	pointer
->	O
seqn	int
)	O
;	O
break	O
;	O
case	O
F_REAL	int
|	O
F_ARRAY	int
|	O
F_BYVAL	int
:	O
case	O
F_INT	int
|	O
F_ARRAY	int
|	O
F_BYVAL	int
:	O
case	O
F_BOOL	int
|	O
F_ARRAY	int
|	O
F_BYVAL	int
:	O
append	function
(	O
code	int
,	O
"      my_dsa.line = %d;\n"	pointer
,	O
id	pointer
->	O
ssn_decl	int
)	O
;	O
append	function
(	O
code	int
,	O
"      my_dsa.%s_%d = %s(%s_%d);\n"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
current	pointer
->	O
seqn	int
,	O
(	O
id	pointer
->	O
flags	int
&	O
F_REAL	int
)	O
?	O
a_copy_real	pointer
:	O
(	O
id	pointer
->	O
flags	int
&	O
F_INT	int
)	O
?	O
a_copy_int	pointer
:	O
(	O
id	pointer
->	O
flags	int
&	O
F_BOOL	int
)	O
?	O
a_copy_bool	pointer
:	O
"???"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
current	pointer
->	O
seqn	int
)	O
;	O
break	O
;	O
case	O
F_REAL	int
|	O
F_BYNAME	int
:	O
case	O
F_INT	int
|	O
F_BYNAME	int
:	O
case	O
F_BOOL	int
|	O
F_BYNAME	int
:	O
case	O
F_LABEL	int
|	O
F_BYNAME	int
:	O
case	O
F_SWITCH	int
|	O
F_BYNAME	int
:	O
case	O
F_REAL	int
|	O
F_PROC	int
|	O
F_BYNAME	int
:	O
case	O
F_INT	int
|	O
F_PROC	int
|	O
F_BYNAME	int
:	O
case	O
F_BOOL	int
|	O
F_PROC	int
|	O
F_BYNAME	int
:	O
case	O
F_PROC	int
|	O
F_BYNAME	int
:	O
append	function
(	O
code	int
,	O
"      my_dsa.%s_%d = %s_%d;\n"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
current	pointer
->	O
seqn	int
,	O
id	pointer
->	O
name	pointer
,	O
current	pointer
->	O
seqn	int
)	O
;	O
break	O
;	O
case	O
F_REAL	int
|	O
F_ARRAY	int
|	O
F_BYNAME	int
:	O
case	O
F_INT	int
|	O
F_ARRAY	int
|	O
F_BYNAME	int
:	O
case	O
F_BOOL	int
|	O
F_ARRAY	int
|	O
F_BYNAME	int
:	O
case	O
F_STRING	int
|	O
F_BYNAME	int
:	O
append	function
(	O
code	int
,	O
"      my_dsa.%s_%d = %s_%d.arg1;\n"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
current	pointer
->	O
seqn	int
,	O
id	pointer
->	O
name	pointer
,	O
current	pointer
->	O
seqn	int
)	O
;	O
break	O
;	O
default	O
:	O
assert	O
(	O
id	pointer
->	O
flags	int
!=	O
id	pointer
->	O
flags	int
)	O
;	O
}	O
}	O
append	function
(	O
code	int
,	O
"      dsa_%d->new_top_%d = "	pointer
a_stack_top	pointer
";\n"	pointer
,	O
current_level	function
(	O
)	O
,	O
block_level	function
(	O
current	pointer
)	O
)	O
;	O
}	O
catenate	function
(	O
code	int
,	O
enter_block	function
(	O
NULL	O
,	O
t_ssn	O
)	O
)	O
;	O
append	function
(	O
code	int
,	O
"      dsa_%d->new_top_%d = "	pointer
a_stack_top	pointer
";\n"	pointer
,	O
current_level	function
(	O
)	O
,	O
block_level	function
(	O
current	pointer
)	O
)	O
;	O
catenate	function
(	O
code	int
,	O
label_list	function
(	O
)	O
)	O
;	O
if	O
(	O
is_main	int
&&	O
!	O
t_delim	O
(	O
S_BEGIN	int
)	O
)	O
error	function
(	O
"missing bracket 'begin'"	pointer
)	O
;	O
catenate	function
(	O
code	int
,	O
statement	function
(	O
)	O
)	O
;	O
catenate	function
(	O
code	int
,	O
leave_block	function
(	O
)	O
)	O
;	O
catenate	function
(	O
code	int
,	O
leave_block	function
(	O
)	O
)	O
;	O
if	O
(	O
second_pass	int
)	O
{	O
append	function
(	O
code	int
,	O
"      my_dsa.retval.lval = 0;\n"	pointer
)	O
;	O
switch	O
(	O
proc	pointer
->	O
flags	int
&	O
(	O
F_REAL	int
|	O
F_INT	int
|	O
F_BOOL	int
)	O
)	O
{	O
case	O
F_REAL	int
:	O
append	function
(	O
code	int
,	O
"      my_dsa.retval.type = 'r';\n"	pointer
)	O
;	O
break	O
;	O
case	O
F_INT	int
:	O
append	function
(	O
code	int
,	O
"      my_dsa.retval.type = 'i';\n"	pointer
)	O
;	O
break	O
;	O
case	O
F_BOOL	int
:	O
append	function
(	O
code	int
,	O
"      my_dsa.retval.type = 'b';\n"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
append	function
(	O
code	int
,	O
"      my_dsa.retval.type = 0;\n"	pointer
)	O
;	O
break	O
;	O
}	O
append	function
(	O
code	int
,	O
"      "	pointer
a_active_dsa	pointer
" = my_dsa.parent;\n"	pointer
)	O
;	O
append	function
(	O
code	int
,	O
"      return my_dsa.retval;\n"	pointer
)	O
;	O
append	function
(	O
code	int
,	O
"}\n\n"	pointer
)	O
;	O
}	O
if	O
(	O
second_pass	int
)	O
{	O
emit_proc_head	function
(	O
proc	pointer
,	O
0	int
)	O
;	O
catenate	function
(	O
emit	pointer
,	O
code	int
)	O
;	O
}	O
if	O
(	O
!	O
is_main	int
&&	O
!	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
{	O
error	function
(	O
"missing semicolon after procedure declaration"	pointer
)	O
;	O
while	O
(	O
!	O
(	O
t_delim	O
(	O
S_EOF	int
)	O
||	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
)	O
get_token	function
(	O
)	O
;	O
}	O
if	O
(	O
is_main	int
&&	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
warning	function
(	O
"semicolon found after program"	pointer
)	O
;	O
done	O
:	O
return	O
;	O
}	O
static	O
CODE	struct
*	O
declaration	function
(	O
void	O
)	O
{	O
CODE	struct
*	O
code	int
;	O
int	O
flags	int
;	O
assert	O
(	O
is_declaration	function
(	O
)	O
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_REAL	int
)	O
||	O
t_delim	O
(	O
S_INTEGER	int
)	O
||	O
t_delim	O
(	O
S_BOOLEAN	int
)	O
)	O
{	O
flags	int
=	O
t_delim	O
(	O
S_REAL	int
)	O
?	O
F_REAL	int
:	O
t_delim	O
(	O
S_INTEGER	int
)	O
?	O
F_INT	int
:	O
F_BOOL	int
;	O
get_token	function
(	O
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_ARRAY	int
)	O
)	O
flags	int
|=	O
F_ARRAY	int
,	O
get_token	function
(	O
)	O
;	O
else	O
if	O
(	O
t_delim	O
(	O
S_PROCEDURE	int
)	O
)	O
flags	int
|=	O
F_PROC	int
,	O
get_token	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
t_delim	O
(	O
S_ARRAY	int
)	O
)	O
flags	int
=	O
F_REAL	int
|	O
F_ARRAY	int
,	O
get_token	function
(	O
)	O
;	O
else	O
if	O
(	O
t_delim	O
(	O
S_OWN	int
)	O
)	O
{	O
flags	int
=	O
F_OWN	int
,	O
get_token	function
(	O
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_REAL	int
)	O
)	O
flags	int
|=	O
F_REAL	int
,	O
get_token	function
(	O
)	O
;	O
else	O
if	O
(	O
t_delim	O
(	O
S_INTEGER	int
)	O
)	O
flags	int
|=	O
F_INT	int
,	O
get_token	function
(	O
)	O
;	O
else	O
if	O
(	O
t_delim	O
(	O
S_BOOLEAN	int
)	O
)	O
flags	int
|=	O
F_BOOL	int
,	O
get_token	function
(	O
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_ARRAY	int
)	O
)	O
{	O
if	O
(	O
flags	int
==	O
F_OWN	int
)	O
flags	int
|=	O
F_REAL	int
;	O
flags	int
|=	O
F_ARRAY	int
,	O
get_token	function
(	O
)	O
;	O
}	O
if	O
(	O
flags	int
==	O
F_OWN	int
)	O
{	O
error	function
(	O
"missing declarator after 'own'"	pointer
)	O
;	O
flags	int
|=	O
F_REAL	int
;	O
}	O
}	O
else	O
if	O
(	O
t_delim	O
(	O
S_SWITCH	int
)	O
)	O
flags	int
=	O
F_SWITCH	int
,	O
get_token	function
(	O
)	O
;	O
else	O
if	O
(	O
t_delim	O
(	O
S_PROCEDURE	int
)	O
)	O
flags	int
=	O
F_PROC	int
,	O
get_token	function
(	O
)	O
;	O
else	O
assert	O
(	O
2	int
+	O
2	int
==	O
5	int
)	O
;	O
if	O
(	O
flags	int
&	O
F_ARRAY	int
)	O
code	int
=	O
array_declaration	function
(	O
flags	int
)	O
;	O
else	O
if	O
(	O
flags	int
&	O
F_SWITCH	int
)	O
switch_declaration	function
(	O
)	O
,	O
code	int
=	O
new_code	function
(	O
)	O
;	O
else	O
if	O
(	O
flags	int
&	O
F_PROC	int
)	O
procedure_declaration	function
(	O
flags	int
)	O
,	O
code	int
=	O
new_code	function
(	O
)	O
;	O
else	O
type_declaration	function
(	O
flags	int
)	O
,	O
code	int
=	O
new_code	function
(	O
)	O
;	O
return	O
code	int
;	O
}	O
static	O
void	O
resolving	function
(	O
void	O
)	O
{	O
IDENT	struct
*	O
id	pointer
,	O
*	O
arg	array
;	O
assert	O
(	O
first_pass	int
)	O
;	O
for	O
(	O
id	pointer
=	O
first_b	pointer
->	O
first	pointer
;	O
id	pointer
!=	O
NULL	O
;	O
id	pointer
=	O
id	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
id	pointer
->	O
flags	int
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
id	pointer
->	O
name	pointer
,	O
"abs"	pointer
)	O
==	O
0	int
)	O
{	O
id	pointer
->	O
ssn_decl	int
=	O
0	int
;	O
id	pointer
->	O
flags	int
=	O
F_REAL	int
|	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	pointer
->	O
dim	int
=	O
1	int
;	O
free_code	function
(	O
enter_block	function
(	O
id	pointer
,	O
1	int
)	O
)	O
;	O
current	pointer
->	O
proc	pointer
=	O
id	pointer
;	O
arg	array
=	O
look_up	function
(	O
"E"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
arg	array
->	O
ssn_decl	int
=	O
arg	array
->	O
ssn_used	int
=	O
1	int
;	O
arg	array
->	O
flags	int
=	O
F_REAL	int
|	O
F_BYVAL	int
;	O
free_code	function
(	O
leave_block	function
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
id	pointer
->	O
name	pointer
,	O
"iabs"	pointer
)	O
==	O
0	int
)	O
{	O
id	pointer
->	O
ssn_decl	int
=	O
0	int
;	O
id	pointer
->	O
flags	int
=	O
F_INT	int
|	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	pointer
->	O
dim	int
=	O
1	int
;	O
free_code	function
(	O
enter_block	function
(	O
id	pointer
,	O
1	int
)	O
)	O
;	O
current	pointer
->	O
proc	pointer
=	O
id	pointer
;	O
arg	array
=	O
look_up	function
(	O
"E"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
arg	array
->	O
ssn_decl	int
=	O
arg	array
->	O
ssn_used	int
=	O
1	int
;	O
arg	array
->	O
flags	int
=	O
F_INT	int
|	O
F_BYVAL	int
;	O
free_code	function
(	O
leave_block	function
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
id	pointer
->	O
name	pointer
,	O
"sign"	pointer
)	O
==	O
0	int
)	O
{	O
id	pointer
->	O
ssn_decl	int
=	O
0	int
;	O
id	pointer
->	O
flags	int
=	O
F_INT	int
|	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	pointer
->	O
dim	int
=	O
1	int
;	O
free_code	function
(	O
enter_block	function
(	O
id	pointer
,	O
1	int
)	O
)	O
;	O
current	pointer
->	O
proc	pointer
=	O
id	pointer
;	O
arg	array
=	O
look_up	function
(	O
"E"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
arg	array
->	O
ssn_decl	int
=	O
arg	array
->	O
ssn_used	int
=	O
1	int
;	O
arg	array
->	O
flags	int
=	O
F_REAL	int
|	O
F_BYVAL	int
;	O
free_code	function
(	O
leave_block	function
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
id	pointer
->	O
name	pointer
,	O
"entier"	pointer
)	O
==	O
0	int
)	O
{	O
id	pointer
->	O
ssn_decl	int
=	O
0	int
;	O
id	pointer
->	O
flags	int
=	O
F_INT	int
|	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	pointer
->	O
dim	int
=	O
1	int
;	O
free_code	function
(	O
enter_block	function
(	O
id	pointer
,	O
1	int
)	O
)	O
;	O
current	pointer
->	O
proc	pointer
=	O
id	pointer
;	O
arg	array
=	O
look_up	function
(	O
"E"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
arg	array
->	O
ssn_decl	int
=	O
arg	array
->	O
ssn_used	int
=	O
1	int
;	O
arg	array
->	O
flags	int
=	O
F_REAL	int
|	O
F_BYVAL	int
;	O
free_code	function
(	O
leave_block	function
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
id	pointer
->	O
name	pointer
,	O
"sqrt"	pointer
)	O
==	O
0	int
)	O
{	O
id	pointer
->	O
ssn_decl	int
=	O
0	int
;	O
id	pointer
->	O
flags	int
=	O
F_REAL	int
|	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	pointer
->	O
dim	int
=	O
1	int
;	O
free_code	function
(	O
enter_block	function
(	O
id	pointer
,	O
1	int
)	O
)	O
;	O
current	pointer
->	O
proc	pointer
=	O
id	pointer
;	O
arg	array
=	O
look_up	function
(	O
"E"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
arg	array
->	O
ssn_decl	int
=	O
arg	array
->	O
ssn_used	int
=	O
1	int
;	O
arg	array
->	O
flags	int
=	O
F_REAL	int
|	O
F_BYVAL	int
;	O
free_code	function
(	O
leave_block	function
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
id	pointer
->	O
name	pointer
,	O
"sin"	pointer
)	O
==	O
0	int
)	O
{	O
id	pointer
->	O
ssn_decl	int
=	O
0	int
;	O
id	pointer
->	O
flags	int
=	O
F_REAL	int
|	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	pointer
->	O
dim	int
=	O
1	int
;	O
free_code	function
(	O
enter_block	function
(	O
id	pointer
,	O
1	int
)	O
)	O
;	O
current	pointer
->	O
proc	pointer
=	O
id	pointer
;	O
arg	array
=	O
look_up	function
(	O
"E"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
arg	array
->	O
ssn_decl	int
=	O
arg	array
->	O
ssn_used	int
=	O
1	int
;	O
arg	array
->	O
flags	int
=	O
F_REAL	int
|	O
F_BYVAL	int
;	O
free_code	function
(	O
leave_block	function
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
id	pointer
->	O
name	pointer
,	O
"cos"	pointer
)	O
==	O
0	int
)	O
{	O
id	pointer
->	O
ssn_decl	int
=	O
0	int
;	O
id	pointer
->	O
flags	int
=	O
F_REAL	int
|	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	pointer
->	O
dim	int
=	O
1	int
;	O
free_code	function
(	O
enter_block	function
(	O
id	pointer
,	O
1	int
)	O
)	O
;	O
current	pointer
->	O
proc	pointer
=	O
id	pointer
;	O
arg	array
=	O
look_up	function
(	O
"E"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
arg	array
->	O
ssn_decl	int
=	O
arg	array
->	O
ssn_used	int
=	O
1	int
;	O
arg	array
->	O
flags	int
=	O
F_REAL	int
|	O
F_BYVAL	int
;	O
free_code	function
(	O
leave_block	function
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
id	pointer
->	O
name	pointer
,	O
"arctan"	pointer
)	O
==	O
0	int
)	O
{	O
id	pointer
->	O
ssn_decl	int
=	O
0	int
;	O
id	pointer
->	O
flags	int
=	O
F_REAL	int
|	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	pointer
->	O
dim	int
=	O
1	int
;	O
free_code	function
(	O
enter_block	function
(	O
id	pointer
,	O
1	int
)	O
)	O
;	O
current	pointer
->	O
proc	pointer
=	O
id	pointer
;	O
arg	array
=	O
look_up	function
(	O
"E"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
arg	array
->	O
ssn_decl	int
=	O
arg	array
->	O
ssn_used	int
=	O
1	int
;	O
arg	array
->	O
flags	int
=	O
F_REAL	int
|	O
F_BYVAL	int
;	O
free_code	function
(	O
leave_block	function
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
id	pointer
->	O
name	pointer
,	O
"ln"	pointer
)	O
==	O
0	int
)	O
{	O
id	pointer
->	O
ssn_decl	int
=	O
0	int
;	O
id	pointer
->	O
flags	int
=	O
F_REAL	int
|	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	pointer
->	O
dim	int
=	O
1	int
;	O
free_code	function
(	O
enter_block	function
(	O
id	pointer
,	O
1	int
)	O
)	O
;	O
current	pointer
->	O
proc	pointer
=	O
id	pointer
;	O
arg	array
=	O
look_up	function
(	O
"E"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
arg	array
->	O
ssn_decl	int
=	O
arg	array
->	O
ssn_used	int
=	O
1	int
;	O
arg	array
->	O
flags	int
=	O
F_REAL	int
|	O
F_BYVAL	int
;	O
free_code	function
(	O
leave_block	function
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
id	pointer
->	O
name	pointer
,	O
"exp"	pointer
)	O
==	O
0	int
)	O
{	O
id	pointer
->	O
ssn_decl	int
=	O
0	int
;	O
id	pointer
->	O
flags	int
=	O
F_REAL	int
|	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	pointer
->	O
dim	int
=	O
1	int
;	O
free_code	function
(	O
enter_block	function
(	O
id	pointer
,	O
1	int
)	O
)	O
;	O
current	pointer
->	O
proc	pointer
=	O
id	pointer
;	O
arg	array
=	O
look_up	function
(	O
"E"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
arg	array
->	O
ssn_decl	int
=	O
arg	array
->	O
ssn_used	int
=	O
1	int
;	O
arg	array
->	O
flags	int
=	O
F_REAL	int
|	O
F_BYVAL	int
;	O
free_code	function
(	O
leave_block	function
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
id	pointer
->	O
name	pointer
,	O
"stop"	pointer
)	O
==	O
0	int
)	O
{	O
id	pointer
->	O
ssn_decl	int
=	O
0	int
;	O
id	pointer
->	O
flags	int
=	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	pointer
->	O
dim	int
=	O
0	int
;	O
free_code	function
(	O
enter_block	function
(	O
id	pointer
,	O
1	int
)	O
)	O
;	O
current	pointer
->	O
proc	pointer
=	O
id	pointer
;	O
free_code	function
(	O
leave_block	function
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
id	pointer
->	O
name	pointer
,	O
"fault"	pointer
)	O
==	O
0	int
)	O
{	O
id	pointer
->	O
ssn_decl	int
=	O
0	int
;	O
id	pointer
->	O
flags	int
=	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	pointer
->	O
dim	int
=	O
2	int
;	O
free_code	function
(	O
enter_block	function
(	O
id	pointer
,	O
1	int
)	O
)	O
;	O
current	pointer
->	O
proc	pointer
=	O
id	pointer
;	O
arg	array
=	O
look_up	function
(	O
"str"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
arg	array
->	O
ssn_decl	int
=	O
arg	array
->	O
ssn_used	int
=	O
1	int
;	O
arg	array
->	O
flags	int
=	O
F_STRING	int
|	O
F_BYNAME	int
;	O
arg	array
=	O
look_up	function
(	O
"r"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
arg	array
->	O
ssn_decl	int
=	O
arg	array
->	O
ssn_used	int
=	O
1	int
;	O
arg	array
->	O
flags	int
=	O
F_REAL	int
|	O
F_BYVAL	int
;	O
free_code	function
(	O
leave_block	function
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
id	pointer
->	O
name	pointer
,	O
"inchar"	pointer
)	O
==	O
0	int
)	O
{	O
id	pointer
->	O
ssn_decl	int
=	O
0	int
;	O
id	pointer
->	O
flags	int
=	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	pointer
->	O
dim	int
=	O
3	int
;	O
free_code	function
(	O
enter_block	function
(	O
id	pointer
,	O
1	int
)	O
)	O
;	O
current	pointer
->	O
proc	pointer
=	O
id	pointer
;	O
arg	array
=	O
look_up	function
(	O
"channel"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
arg	array
->	O
ssn_decl	int
=	O
arg	array
->	O
ssn_used	int
=	O
1	int
;	O
arg	array
->	O
flags	int
=	O
F_INT	int
|	O
F_BYVAL	int
;	O
arg	array
=	O
look_up	function
(	O
"str"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
arg	array
->	O
ssn_decl	int
=	O
arg	array
->	O
ssn_used	int
=	O
1	int
;	O
arg	array
->	O
flags	int
=	O
F_STRING	int
|	O
F_BYNAME	int
;	O
arg	array
=	O
look_up	function
(	O
"int"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
arg	array
->	O
ssn_decl	int
=	O
arg	array
->	O
ssn_used	int
=	O
1	int
;	O
arg	array
->	O
flags	int
=	O
F_INT	int
|	O
F_BYNAME	int
;	O
free_code	function
(	O
leave_block	function
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
id	pointer
->	O
name	pointer
,	O
"outchar"	pointer
)	O
==	O
0	int
)	O
{	O
id	pointer
->	O
ssn_decl	int
=	O
0	int
;	O
id	pointer
->	O
flags	int
=	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	pointer
->	O
dim	int
=	O
3	int
;	O
free_code	function
(	O
enter_block	function
(	O
id	pointer
,	O
1	int
)	O
)	O
;	O
current	pointer
->	O
proc	pointer
=	O
id	pointer
;	O
arg	array
=	O
look_up	function
(	O
"channel"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
arg	array
->	O
ssn_decl	int
=	O
arg	array
->	O
ssn_used	int
=	O
1	int
;	O
arg	array
->	O
flags	int
=	O
F_INT	int
|	O
F_BYVAL	int
;	O
arg	array
=	O
look_up	function
(	O
"str"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
arg	array
->	O
ssn_decl	int
=	O
arg	array
->	O
ssn_used	int
=	O
1	int
;	O
arg	array
->	O
flags	int
=	O
F_STRING	int
|	O
F_BYNAME	int
;	O
arg	array
=	O
look_up	function
(	O
"int"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
arg	array
->	O
ssn_decl	int
=	O
arg	array
->	O
ssn_used	int
=	O
1	int
;	O
arg	array
->	O
flags	int
=	O
F_INT	int
|	O
F_BYVAL	int
;	O
free_code	function
(	O
leave_block	function
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
id	pointer
->	O
name	pointer
,	O
"length"	pointer
)	O
==	O
0	int
)	O
{	O
id	pointer
->	O
ssn_decl	int
=	O
0	int
;	O
id	pointer
->	O
flags	int
=	O
F_INT	int
|	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	pointer
->	O
dim	int
=	O
1	int
;	O
free_code	function
(	O
enter_block	function
(	O
id	pointer
,	O
1	int
)	O
)	O
;	O
current	pointer
->	O
proc	pointer
=	O
id	pointer
;	O
arg	array
=	O
look_up	function
(	O
"str"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
arg	array
->	O
ssn_decl	int
=	O
arg	array
->	O
ssn_used	int
=	O
1	int
;	O
arg	array
->	O
flags	int
=	O
F_STRING	int
|	O
F_BYNAME	int
;	O
free_code	function
(	O
leave_block	function
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
id	pointer
->	O
name	pointer
,	O
"outstring"	pointer
)	O
==	O
0	int
)	O
{	O
id	pointer
->	O
ssn_decl	int
=	O
0	int
;	O
id	pointer
->	O
flags	int
=	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	pointer
->	O
dim	int
=	O
2	int
;	O
free_code	function
(	O
enter_block	function
(	O
id	pointer
,	O
1	int
)	O
)	O
;	O
current	pointer
->	O
proc	pointer
=	O
id	pointer
;	O
arg	array
=	O
look_up	function
(	O
"channel"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
arg	array
->	O
ssn_decl	int
=	O
arg	array
->	O
ssn_used	int
=	O
1	int
;	O
arg	array
->	O
flags	int
=	O
F_INT	int
|	O
F_BYVAL	int
;	O
arg	array
=	O
look_up	function
(	O
"str"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
arg	array
->	O
ssn_decl	int
=	O
arg	array
->	O
ssn_used	int
=	O
1	int
;	O
arg	array
->	O
flags	int
=	O
F_STRING	int
|	O
F_BYNAME	int
;	O
free_code	function
(	O
leave_block	function
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
id	pointer
->	O
name	pointer
,	O
"outterminator"	pointer
)	O
==	O
0	int
)	O
{	O
id	pointer
->	O
ssn_decl	int
=	O
0	int
;	O
id	pointer
->	O
flags	int
=	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	pointer
->	O
dim	int
=	O
1	int
;	O
free_code	function
(	O
enter_block	function
(	O
id	pointer
,	O
1	int
)	O
)	O
;	O
current	pointer
->	O
proc	pointer
=	O
id	pointer
;	O
arg	array
=	O
look_up	function
(	O
"channel"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
arg	array
->	O
ssn_decl	int
=	O
arg	array
->	O
ssn_used	int
=	O
1	int
;	O
arg	array
->	O
flags	int
=	O
F_INT	int
|	O
F_BYVAL	int
;	O
free_code	function
(	O
leave_block	function
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
id	pointer
->	O
name	pointer
,	O
"ininteger"	pointer
)	O
==	O
0	int
)	O
{	O
id	pointer
->	O
ssn_decl	int
=	O
0	int
;	O
id	pointer
->	O
flags	int
=	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	pointer
->	O
dim	int
=	O
2	int
;	O
free_code	function
(	O
enter_block	function
(	O
id	pointer
,	O
1	int
)	O
)	O
;	O
current	pointer
->	O
proc	pointer
=	O
id	pointer
;	O
arg	array
=	O
look_up	function
(	O
"channel"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
arg	array
->	O
ssn_decl	int
=	O
arg	array
->	O
ssn_used	int
=	O
1	int
;	O
arg	array
->	O
flags	int
=	O
F_INT	int
|	O
F_BYVAL	int
;	O
arg	array
=	O
look_up	function
(	O
"int"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
arg	array
->	O
ssn_decl	int
=	O
arg	array
->	O
ssn_used	int
=	O
1	int
;	O
arg	array
->	O
flags	int
=	O
F_INT	int
|	O
F_BYNAME	int
;	O
free_code	function
(	O
leave_block	function
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
id	pointer
->	O
name	pointer
,	O
"outinteger"	pointer
)	O
==	O
0	int
)	O
{	O
id	pointer
->	O
ssn_decl	int
=	O
0	int
;	O
id	pointer
->	O
flags	int
=	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	pointer
->	O
dim	int
=	O
2	int
;	O
free_code	function
(	O
enter_block	function
(	O
id	pointer
,	O
1	int
)	O
)	O
;	O
current	pointer
->	O
proc	pointer
=	O
id	pointer
;	O
arg	array
=	O
look_up	function
(	O
"channel"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
arg	array
->	O
ssn_decl	int
=	O
arg	array
->	O
ssn_used	int
=	O
1	int
;	O
arg	array
->	O
flags	int
=	O
F_INT	int
|	O
F_BYVAL	int
;	O
arg	array
=	O
look_up	function
(	O
"int"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
arg	array
->	O
ssn_decl	int
=	O
arg	array
->	O
ssn_used	int
=	O
1	int
;	O
arg	array
->	O
flags	int
=	O
F_INT	int
|	O
F_BYVAL	int
;	O
free_code	function
(	O
leave_block	function
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
id	pointer
->	O
name	pointer
,	O
"inreal"	pointer
)	O
==	O
0	int
)	O
{	O
id	pointer
->	O
ssn_decl	int
=	O
0	int
;	O
id	pointer
->	O
flags	int
=	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	pointer
->	O
dim	int
=	O
2	int
;	O
free_code	function
(	O
enter_block	function
(	O
id	pointer
,	O
1	int
)	O
)	O
;	O
current	pointer
->	O
proc	pointer
=	O
id	pointer
;	O
arg	array
=	O
look_up	function
(	O
"channel"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
arg	array
->	O
ssn_decl	int
=	O
arg	array
->	O
ssn_used	int
=	O
1	int
;	O
arg	array
->	O
flags	int
=	O
F_INT	int
|	O
F_BYVAL	int
;	O
arg	array
=	O
look_up	function
(	O
"re"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
arg	array
->	O
ssn_decl	int
=	O
arg	array
->	O
ssn_used	int
=	O
1	int
;	O
arg	array
->	O
flags	int
=	O
F_REAL	int
|	O
F_BYNAME	int
;	O
free_code	function
(	O
leave_block	function
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
id	pointer
->	O
name	pointer
,	O
"outreal"	pointer
)	O
==	O
0	int
)	O
{	O
id	pointer
->	O
ssn_decl	int
=	O
0	int
;	O
id	pointer
->	O
flags	int
=	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	pointer
->	O
dim	int
=	O
2	int
;	O
free_code	function
(	O
enter_block	function
(	O
id	pointer
,	O
1	int
)	O
)	O
;	O
current	pointer
->	O
proc	pointer
=	O
id	pointer
;	O
arg	array
=	O
look_up	function
(	O
"channel"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
arg	array
->	O
ssn_decl	int
=	O
arg	array
->	O
ssn_used	int
=	O
1	int
;	O
arg	array
->	O
flags	int
=	O
F_INT	int
|	O
F_BYVAL	int
;	O
arg	array
=	O
look_up	function
(	O
"re"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
arg	array
->	O
ssn_decl	int
=	O
arg	array
->	O
ssn_used	int
=	O
1	int
;	O
arg	array
->	O
flags	int
=	O
F_REAL	int
|	O
F_BYVAL	int
;	O
free_code	function
(	O
leave_block	function
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
id	pointer
->	O
name	pointer
,	O
"maxreal"	pointer
)	O
==	O
0	int
)	O
{	O
id	pointer
->	O
ssn_decl	int
=	O
0	int
;	O
id	pointer
->	O
flags	int
=	O
F_REAL	int
|	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	pointer
->	O
dim	int
=	O
0	int
;	O
free_code	function
(	O
enter_block	function
(	O
id	pointer
,	O
1	int
)	O
)	O
;	O
current	pointer
->	O
proc	pointer
=	O
id	pointer
;	O
free_code	function
(	O
leave_block	function
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
id	pointer
->	O
name	pointer
,	O
"minreal"	pointer
)	O
==	O
0	int
)	O
{	O
id	pointer
->	O
ssn_decl	int
=	O
0	int
;	O
id	pointer
->	O
flags	int
=	O
F_REAL	int
|	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	pointer
->	O
dim	int
=	O
0	int
;	O
free_code	function
(	O
enter_block	function
(	O
id	pointer
,	O
1	int
)	O
)	O
;	O
current	pointer
->	O
proc	pointer
=	O
id	pointer
;	O
free_code	function
(	O
leave_block	function
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
id	pointer
->	O
name	pointer
,	O
"maxint"	pointer
)	O
==	O
0	int
)	O
{	O
id	pointer
->	O
ssn_decl	int
=	O
0	int
;	O
id	pointer
->	O
flags	int
=	O
F_INT	int
|	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	pointer
->	O
dim	int
=	O
0	int
;	O
free_code	function
(	O
enter_block	function
(	O
id	pointer
,	O
1	int
)	O
)	O
;	O
current	pointer
->	O
proc	pointer
=	O
id	pointer
;	O
free_code	function
(	O
leave_block	function
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
id	pointer
->	O
name	pointer
,	O
"epsilon"	pointer
)	O
==	O
0	int
)	O
{	O
id	pointer
->	O
ssn_decl	int
=	O
0	int
;	O
id	pointer
->	O
flags	int
=	O
F_REAL	int
|	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	pointer
->	O
dim	int
=	O
0	int
;	O
free_code	function
(	O
enter_block	function
(	O
id	pointer
,	O
1	int
)	O
)	O
;	O
current	pointer
->	O
proc	pointer
=	O
id	pointer
;	O
free_code	function
(	O
leave_block	function
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
id	pointer
->	O
name	pointer
,	O
"inline"	pointer
)	O
==	O
0	int
)	O
{	O
id	pointer
->	O
ssn_decl	int
=	O
0	int
;	O
id	pointer
->	O
flags	int
=	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	pointer
->	O
dim	int
=	O
1	int
;	O
free_code	function
(	O
enter_block	function
(	O
id	pointer
,	O
1	int
)	O
)	O
;	O
current	pointer
->	O
proc	pointer
=	O
id	pointer
;	O
arg	array
=	O
look_up	function
(	O
"statement"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
arg	array
->	O
ssn_decl	int
=	O
arg	array
->	O
ssn_used	int
=	O
1	int
;	O
arg	array
->	O
flags	int
=	O
F_STRING	int
|	O
F_BYNAME	int
;	O
free_code	function
(	O
leave_block	function
(	O
)	O
)	O
;	O
warning	function
(	O
"pseudo procedure `inline' used"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
id	pointer
->	O
name	pointer
,	O
"print"	pointer
)	O
==	O
0	int
)	O
{	O
id	pointer
->	O
ssn_decl	int
=	O
0	int
;	O
id	pointer
->	O
flags	int
=	O
F_PROC	int
|	O
F_BLTIN	int
;	O
id	pointer
->	O
dim	int
=	O
0	int
;	O
free_code	function
(	O
enter_block	function
(	O
id	pointer
,	O
1	int
)	O
)	O
;	O
current	pointer
->	O
proc	pointer
=	O
id	pointer
;	O
free_code	function
(	O
leave_block	function
(	O
)	O
)	O
;	O
warning	function
(	O
"pseudo procedure `print' used"	pointer
)	O
;	O
}	O
else	O
error	function
(	O
"identifier `%s' not declared (see line %d)"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
id	pointer
->	O
ssn_used	int
)	O
;	O
}	O
return	O
;	O
}	O
static	O
int	O
entire_module	function
(	O
void	O
)	O
{	O
int	O
is_main	int
=	O
0	int
;	O
free_code	function
(	O
enter_block	function
(	O
NULL	O
,	O
0	int
)	O
)	O
;	O
l_count	int
=	O
0	int
;	O
if	O
(	O
first_pass	int
)	O
line	pointer
=	O
my_malloc	function
(	O
l_maxlen	int
+	O
1	int
)	O
;	O
line	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
read_line	function
(	O
)	O
;	O
pos	int
=	O
0	int
;	O
symbol	int
=	O
S_EOF	int
;	O
s_char	int
=	O
'?'	O
;	O
scan_symbol	function
(	O
)	O
;	O
token	array
[	O
0	int
]	O
.	O
ssn	int
=	O
0	int
;	O
token	array
[	O
0	int
]	O
.	O
code	int
=	O
T_DELIM	int
;	O
token	array
[	O
0	int
]	O
.	O
delim	int
=	O
S_EOF	int
;	O
token	array
[	O
0	int
]	O
.	O
len	int
=	O
0	int
;	O
if	O
(	O
first_pass	int
)	O
token	array
[	O
0	int
]	O
.	O
image	pointer
=	O
my_malloc	function
(	O
t_maxlen	int
+	O
1	int
)	O
;	O
token	array
[	O
0	int
]	O
.	O
image	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
token	array
[	O
1	int
]	O
.	O
ssn	int
=	O
0	int
;	O
token	array
[	O
1	int
]	O
.	O
code	int
=	O
T_DELIM	int
;	O
token	array
[	O
1	int
]	O
.	O
delim	int
=	O
S_EOF	int
;	O
token	array
[	O
1	int
]	O
.	O
len	int
=	O
0	int
;	O
if	O
(	O
first_pass	int
)	O
token	array
[	O
1	int
]	O
.	O
image	pointer
=	O
my_malloc	function
(	O
t_maxlen	int
+	O
1	int
)	O
;	O
token	array
[	O
1	int
]	O
.	O
image	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
token	array
[	O
2	int
]	O
.	O
ssn	int
=	O
0	int
;	O
token	array
[	O
2	int
]	O
.	O
code	int
=	O
T_UNDEF	int
;	O
token	array
[	O
2	int
]	O
.	O
delim	int
=	O
S_EOF	int
;	O
token	array
[	O
2	int
]	O
.	O
len	int
=	O
0	int
;	O
if	O
(	O
first_pass	int
)	O
token	array
[	O
2	int
]	O
.	O
image	pointer
=	O
my_malloc	function
(	O
t_maxlen	int
+	O
1	int
)	O
;	O
token	array
[	O
2	int
]	O
.	O
image	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
get_token	function
(	O
)	O
;	O
if	O
(	O
token	array
[	O
1	int
]	O
.	O
code	int
==	O
T_DELIM	int
&&	O
token	array
[	O
1	int
]	O
.	O
delim	int
==	O
S_EOF	int
)	O
{	O
error	function
(	O
"null program not allowed"	pointer
)	O
;	O
goto	O
skip	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
flags	int
;	O
if	O
(	O
t_delim	O
(	O
S_EOF	int
)	O
)	O
break	O
;	O
if	O
(	O
t_code	O
==	O
T_IDENT	int
)	O
get_token2	function
(	O
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_BEGIN	int
)	O
||	O
(	O
t_code	O
==	O
T_IDENT	int
&&	O
token	array
[	O
2	int
]	O
.	O
code	int
==	O
T_DELIM	int
&&	O
token	array
[	O
2	int
]	O
.	O
delim	int
==	O
S_COLON	int
)	O
)	O
{	O
if	O
(	O
is_main	int
)	O
error	function
(	O
"only one program allowed"	pointer
)	O
;	O
is_main	int
=	O
1	int
,	O
flags	int
=	O
F_PROC	int
;	O
}	O
else	O
{	O
if	O
(	O
t_delim	O
(	O
S_REAL	int
)	O
)	O
flags	int
=	O
F_REAL	int
,	O
get_token	function
(	O
)	O
;	O
else	O
if	O
(	O
t_delim	O
(	O
S_INTEGER	int
)	O
)	O
flags	int
=	O
F_INT	int
,	O
get_token	function
(	O
)	O
;	O
else	O
if	O
(	O
t_delim	O
(	O
S_BOOLEAN	int
)	O
)	O
flags	int
=	O
F_BOOL	int
,	O
get_token	function
(	O
)	O
;	O
else	O
flags	int
=	O
0	int
;	O
if	O
(	O
t_delim	O
(	O
S_PROCEDURE	int
)	O
)	O
flags	int
|=	O
F_PROC	int
,	O
get_token	function
(	O
)	O
;	O
}	O
if	O
(	O
!	O
(	O
flags	int
&	O
F_PROC	int
)	O
)	O
{	O
error	function
(	O
"invalid start of program or precompiled procedure"	pointer
)	O
;	O
err	O
:	O
while	O
(	O
!	O
(	O
t_delim	O
(	O
S_EOF	int
)	O
||	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
)	O
get_token	function
(	O
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
get_token	function
(	O
)	O
;	O
continue	O
;	O
}	O
procedure_declaration	function
(	O
flags	int
)	O
;	O
if	O
(	O
t_delim	O
(	O
S_SEMICOLON	int
)	O
)	O
get_token	function
(	O
)	O
;	O
else	O
if	O
(	O
!	O
t_delim	O
(	O
S_EOF	int
)	O
)	O
{	O
error	function
(	O
"equal number of 'begin' and 'end' brackets found"	pointer
)	O
;	O
goto	O
err	O
;	O
}	O
}	O
skip	O
:	O
if	O
(	O
first_pass	int
)	O
resolving	function
(	O
)	O
;	O
free_code	function
(	O
leave_block	function
(	O
)	O
)	O
;	O
assert	O
(	O
current	pointer
==	O
NULL	O
)	O
;	O
return	O
is_main	int
;	O
}	O
static	O
BLOCK	struct
*	O
proc_block	function
(	O
BLOCK	struct
*	O
b	pointer
)	O
{	O
for	O
(	O
;	O
b	pointer
!=	O
NULL	O
;	O
b	pointer
=	O
b	pointer
->	O
surr	pointer
)	O
if	O
(	O
b	pointer
->	O
proc	pointer
!=	O
NULL	O
)	O
break	O
;	O
return	O
b	pointer
;	O
}	O
static	O
void	O
emit_decl_code	function
(	O
IDENT	struct
*	O
id	pointer
)	O
{	O
int	O
seqn	int
=	O
id	pointer
->	O
block	pointer
->	O
seqn	int
;	O
switch	O
(	O
id	pointer
->	O
flags	int
)	O
{	O
case	O
F_REAL	int
:	O
case	O
F_REAL	int
|	O
F_BYVAL	int
:	O
append	function
(	O
emit	pointer
,	O
"      double %s_%d;\n"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
seqn	int
)	O
;	O
break	O
;	O
case	O
F_INT	int
:	O
case	O
F_INT	int
|	O
F_BYVAL	int
:	O
append	function
(	O
emit	pointer
,	O
"      int %s_%d;\n"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
seqn	int
)	O
;	O
break	O
;	O
case	O
F_BOOL	int
:	O
case	O
F_BOOL	int
|	O
F_BYVAL	int
:	O
append	function
(	O
emit	pointer
,	O
"      bool %s_%d;\n"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
seqn	int
)	O
;	O
break	O
;	O
case	O
F_LABEL	int
|	O
F_BYVAL	int
:	O
append	function
(	O
emit	pointer
,	O
"      struct label %s_%d;\n"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
seqn	int
)	O
;	O
break	O
;	O
case	O
F_REAL	int
|	O
F_ARRAY	int
:	O
case	O
F_REAL	int
|	O
F_ARRAY	int
|	O
F_BYVAL	int
:	O
case	O
F_REAL	int
|	O
F_ARRAY	int
|	O
F_BYNAME	int
:	O
case	O
F_INT	int
|	O
F_ARRAY	int
:	O
case	O
F_INT	int
|	O
F_ARRAY	int
|	O
F_BYVAL	int
:	O
case	O
F_INT	int
|	O
F_ARRAY	int
|	O
F_BYNAME	int
:	O
case	O
F_BOOL	int
|	O
F_ARRAY	int
:	O
case	O
F_BOOL	int
|	O
F_ARRAY	int
|	O
F_BYVAL	int
:	O
case	O
F_BOOL	int
|	O
F_ARRAY	int
|	O
F_BYNAME	int
:	O
append	function
(	O
emit	pointer
,	O
"      struct dv *%s_%d;\n"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
seqn	int
)	O
;	O
break	O
;	O
case	O
F_REAL	int
|	O
F_BYNAME	int
:	O
case	O
F_INT	int
|	O
F_BYNAME	int
:	O
case	O
F_BOOL	int
|	O
F_BYNAME	int
:	O
case	O
F_LABEL	int
|	O
F_BYNAME	int
:	O
case	O
F_SWITCH	int
|	O
F_BYNAME	int
:	O
case	O
F_REAL	int
|	O
F_PROC	int
|	O
F_BYNAME	int
:	O
case	O
F_INT	int
|	O
F_PROC	int
|	O
F_BYNAME	int
:	O
case	O
F_BOOL	int
|	O
F_PROC	int
|	O
F_BYNAME	int
:	O
case	O
F_PROC	int
|	O
F_BYNAME	int
:	O
append	function
(	O
emit	pointer
,	O
"      struct arg %s_%d;\n"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
seqn	int
)	O
;	O
break	O
;	O
case	O
F_STRING	int
|	O
F_BYNAME	int
:	O
append	function
(	O
emit	pointer
,	O
"      char *%s_%d;\n"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
seqn	int
)	O
;	O
break	O
;	O
case	O
F_REAL	int
|	O
F_OWN	int
:	O
case	O
F_INT	int
|	O
F_OWN	int
:	O
case	O
F_BOOL	int
|	O
F_OWN	int
:	O
case	O
F_REAL	int
|	O
F_ARRAY	int
|	O
F_OWN	int
:	O
case	O
F_INT	int
|	O
F_ARRAY	int
|	O
F_OWN	int
:	O
case	O
F_BOOL	int
|	O
F_ARRAY	int
|	O
F_OWN	int
:	O
case	O
F_LABEL	int
:	O
case	O
F_SWITCH	int
:	O
case	O
F_REAL	int
|	O
F_PROC	int
:	O
case	O
F_INT	int
|	O
F_PROC	int
:	O
case	O
F_BOOL	int
|	O
F_PROC	int
:	O
case	O
F_PROC	int
:	O
break	O
;	O
default	O
:	O
assert	O
(	O
id	pointer
->	O
flags	int
!=	O
id	pointer
->	O
flags	int
)	O
;	O
}	O
return	O
;	O
}	O
static	O
void	O
emit_dsa_code	function
(	O
void	O
)	O
{	O
BLOCK	struct
*	O
block	pointer
;	O
for	O
(	O
block	pointer
=	O
first_b	pointer
;	O
block	pointer
!=	O
NULL	O
;	O
block	pointer
=	O
block	pointer
->	O
next	pointer
)	O
{	O
IDENT	struct
*	O
proc	pointer
;	O
BLOCK	struct
*	O
b	pointer
;	O
proc	pointer
=	O
block	pointer
->	O
proc	pointer
;	O
if	O
(	O
proc	pointer
==	O
NULL	O
||	O
(	O
proc	pointer
->	O
flags	int
&	O
(	O
F_CODE	int
|	O
F_BLTIN	int
)	O
)	O
)	O
continue	O
;	O
append	function
(	O
emit	pointer
,	O
"struct dsa_%s_%d\n"	pointer
,	O
proc	pointer
->	O
name	pointer
,	O
proc	pointer
->	O
block	pointer
->	O
seqn	int
)	O
;	O
append	function
(	O
emit	pointer
,	O
"{     /* procedure %s (level %d) declared at line %d */\n"	pointer
,	O
proc	pointer
->	O
name	pointer
,	O
dsa_level	function
(	O
proc	pointer
)	O
+	O
1	int
,	O
proc	pointer
->	O
ssn_decl	int
)	O
;	O
append	function
(	O
emit	pointer
,	O
"      char *proc;\n"	pointer
)	O
;	O
append	function
(	O
emit	pointer
,	O
"      char *file;\n"	pointer
)	O
;	O
append	function
(	O
emit	pointer
,	O
"      int line;\n"	pointer
)	O
;	O
append	function
(	O
emit	pointer
,	O
"      struct dsa *parent;\n"	pointer
)	O
;	O
append	function
(	O
emit	pointer
,	O
"      struct dsa *vector[%d+1];\n"	pointer
,	O
dsa_level	function
(	O
proc	pointer
)	O
+	O
1	int
)	O
;	O
{	O
int	O
maxlev	int
=	O
0	int
,	O
k	int
,	O
need	int
;	O
for	O
(	O
b	pointer
=	O
first_b	pointer
;	O
b	pointer
!=	O
NULL	O
;	O
b	pointer
=	O
b	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
proc_block	function
(	O
b	pointer
)	O
==	O
block	pointer
&&	O
maxlev	int
<	O
block_level	function
(	O
b	pointer
)	O
)	O
maxlev	int
=	O
block_level	function
(	O
b	pointer
)	O
;	O
}	O
append	function
(	O
emit	pointer
,	O
"      /* level of innermost block = %d */\n"	pointer
,	O
maxlev	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<=	O
maxlev	int
;	O
k	int
++	O
)	O
{	O
append	function
(	O
emit	pointer
,	O
"      struct mem *old_top_%d;\n"	pointer
,	O
k	int
)	O
;	O
append	function
(	O
emit	pointer
,	O
"      struct mem *new_top_%d;\n"	pointer
,	O
k	int
)	O
;	O
need	int
=	O
0	int
;	O
for	O
(	O
b	pointer
=	O
first_b	pointer
;	O
b	pointer
!=	O
NULL	O
;	O
b	pointer
=	O
b	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
proc_block	function
(	O
b	pointer
)	O
==	O
block	pointer
&&	O
block_level	function
(	O
b	pointer
)	O
==	O
k	int
&&	O
has_labels	function
(	O
b	pointer
)	O
)	O
need	int
=	O
1	int
;	O
}	O
if	O
(	O
need	int
)	O
append	function
(	O
emit	pointer
,	O
"      jmp_buf jump_%d;\n"	pointer
,	O
k	int
)	O
;	O
}	O
}	O
for	O
(	O
b	pointer
=	O
first_b	pointer
;	O
b	pointer
!=	O
NULL	O
;	O
b	pointer
=	O
b	pointer
->	O
next	pointer
)	O
{	O
IDENT	struct
*	O
id	pointer
;	O
int	O
count	int
=	O
0	int
;	O
if	O
(	O
proc_block	function
(	O
b	pointer
)	O
!=	O
block	pointer
)	O
continue	O
;	O
append	function
(	O
emit	pointer
,	O
"      /* %s block %d (level %d) beginning at "	pointer
"line %d */\n"	pointer
,	O
b	pointer
->	O
proc	pointer
!=	O
NULL	O
?	O
"procedure"	pointer
:	O
"local"	pointer
,	O
b	pointer
->	O
seqn	int
,	O
block_level	function
(	O
b	pointer
)	O
,	O
b	pointer
->	O
ssn	int
)	O
;	O
if	O
(	O
b	pointer
->	O
proc	pointer
!=	O
NULL	O
)	O
{	O
assert	O
(	O
b	pointer
->	O
proc	pointer
==	O
proc	pointer
)	O
;	O
append	function
(	O
emit	pointer
,	O
"      struct desc retval;\n"	pointer
)	O
;	O
}	O
for	O
(	O
id	pointer
=	O
b	pointer
->	O
first	pointer
;	O
id	pointer
!=	O
NULL	O
;	O
id	pointer
=	O
id	pointer
->	O
next	pointer
)	O
{	O
append	function
(	O
emit	pointer
,	O
"      /* %s:"	pointer
,	O
id	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_OWN	int
)	O
append	function
(	O
emit	pointer
,	O
" own"	pointer
)	O
;	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_BYVAL	int
)	O
append	function
(	O
emit	pointer
,	O
" by value"	pointer
)	O
;	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_BYNAME	int
)	O
append	function
(	O
emit	pointer
,	O
" by name"	pointer
)	O
;	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_REAL	int
)	O
append	function
(	O
emit	pointer
,	O
" real"	pointer
)	O
;	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_INT	int
)	O
append	function
(	O
emit	pointer
,	O
" integer"	pointer
)	O
;	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_BOOL	int
)	O
append	function
(	O
emit	pointer
,	O
" Boolean"	pointer
)	O
;	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_LABEL	int
)	O
append	function
(	O
emit	pointer
,	O
" label"	pointer
)	O
;	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_ARRAY	int
)	O
append	function
(	O
emit	pointer
,	O
" array"	pointer
)	O
;	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_SWITCH	int
)	O
append	function
(	O
emit	pointer
,	O
" switch"	pointer
)	O
;	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_PROC	int
)	O
append	function
(	O
emit	pointer
,	O
" procedure"	pointer
)	O
;	O
if	O
(	O
id	pointer
->	O
flags	int
&	O
F_STRING	int
)	O
append	function
(	O
emit	pointer
,	O
" string"	pointer
)	O
;	O
assert	O
(	O
!	O
(	O
id	pointer
->	O
flags	int
&	O
(	O
F_CODE	int
|	O
F_BLTIN	int
)	O
)	O
)	O
;	O
append	function
(	O
emit	pointer
,	O
"\n         %s at line %d and "	pointer
,	O
id	pointer
->	O
flags	int
&	O
(	O
F_BYVAL	int
|	O
F_BYNAME	int
)	O
?	O
"specified"	pointer
:	O
"declared"	pointer
,	O
id	pointer
->	O
ssn_decl	int
)	O
;	O
if	O
(	O
id	pointer
->	O
ssn_used	int
==	O
0	int
)	O
append	function
(	O
emit	pointer
,	O
"never referenced */\n"	pointer
)	O
;	O
else	O
{	O
append	function
(	O
emit	pointer
,	O
"first referenced at line %d */\n"	pointer
,	O
id	pointer
->	O
ssn_used	int
)	O
;	O
if	O
(	O
id	pointer
->	O
flags	int
==	O
F_LABEL	int
)	O
id	pointer
->	O
dim	int
=	O
++	O
count	int
;	O
}	O
emit_decl_code	function
(	O
id	pointer
)	O
;	O
}	O
}	O
append	function
(	O
emit	pointer
,	O
"};\n\n"	pointer
)	O
;	O
}	O
return	O
;	O
}	O
static	O
void	O
emit_startup_code	function
(	O
void	O
)	O
{	O
append	function
(	O
emit	pointer
,	O
"int main(void)\n"	pointer
)	O
;	O
append	function
(	O
emit	pointer
,	O
"{     /* Algol program startup code */\n"	pointer
)	O
;	O
append	function
(	O
emit	pointer
,	O
"      main_program_0();\n"	pointer
)	O
;	O
append	function
(	O
emit	pointer
,	O
"      return 0;\n"	pointer
)	O
;	O
append	function
(	O
emit	pointer
,	O
"}\n\n"	pointer
)	O
;	O
return	O
;	O
}	O
static	O
CSQE	struct
*	O
sqe_ptr	pointer
;	O
static	O
int	O
sqe_pos	int
;	O
static	O
int	O
get_code_char	function
(	O
void	O
)	O
{	O
int	O
c	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
c	int
=	O
(	O
unsigned	O
char	O
)	O
sqe_ptr	pointer
->	O
str	pointer
[	O
sqe_pos	int
++	O
]	O
;	O
if	O
(	O
c	int
!=	O
'\0'	O
)	O
break	O
;	O
sqe_ptr	pointer
=	O
sqe_ptr	pointer
->	O
next	pointer
;	O
if	O
(	O
sqe_ptr	pointer
==	O
NULL	O
)	O
{	O
c	int
=	O
0x1A	int
;	O
break	O
;	O
}	O
sqe_pos	int
=	O
0	int
;	O
}	O
return	O
c	int
;	O
}	O
static	O
void	O
output_code	function
(	O
CODE	struct
*	O
code	int
)	O
{	O
int	O
size	int
;	O
int	O
len	int
;	O
char	O
str	pointer
[	O
255	int
+	O
1	int
]	O
;	O
int	O
c	int
;	O
assert	O
(	O
50	int
<=	O
width	int
&&	O
width	int
<=	O
255	int
)	O
;	O
sqe_ptr	pointer
=	O
code	int
->	O
head	pointer
;	O
sqe_pos	int
=	O
0	int
;	O
size	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
len	int
=	O
0	int
,	O
str	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
c	int
=	O
get_code_char	function
(	O
)	O
;	O
if	O
(	O
c	int
==	O
0x1A	int
)	O
break	O
;	O
assert	O
(	O
len	int
<	O
sizeof	O
(	O
str	pointer
)	O
-	O
1	int
)	O
;	O
str	pointer
[	O
len	int
++	O
]	O
=	O
(	O
char	O
)	O
c	int
,	O
str	pointer
[	O
len	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
||	O
c	int
==	O
' '	O
||	O
c	int
==	O
'('	O
||	O
c	int
==	O
')'	O
||	O
c	int
==	O
':'	O
||	O
c	int
==	O
','	O
||	O
c	int
==	O
';'	O
||	O
c	int
==	O
'"'	O
)	O
break	O
;	O
}	O
if	O
(	O
size	int
+	O
len	int
+	O
(	O
c	int
==	O
'\n'	O
?	O
-	O
1	int
:	O
c	int
==	O
'"'	O
?	O
6	int
:	O
0	int
)	O
>	O
width	int
)	O
{	O
if	O
(	O
size	int
>	O
0	int
)	O
{	O
fputc	function
(	O
'\n'	O
,	O
outfile	pointer
)	O
;	O
fputs	function
(	O
"         "	pointer
,	O
outfile	pointer
)	O
,	O
size	int
=	O
9	int
;	O
}	O
}	O
fputs	function
(	O
str	pointer
,	O
outfile	pointer
)	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
size	int
=	O
0	int
;	O
else	O
size	int
+=	O
len	int
;	O
if	O
(	O
c	int
==	O
0x1A	int
)	O
break	O
;	O
if	O
(	O
c	int
==	O
'"'	O
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
oldc	int
=	O
c	int
;	O
c	int
=	O
get_code_char	function
(	O
)	O
;	O
assert	O
(	O
c	int
!=	O
0x1A	int
)	O
;	O
if	O
(	O
size	int
+	O
2	int
>	O
width	int
&&	O
oldc	int
!=	O
'\\'	O
)	O
fputs	function
(	O
"\"\n         \""	pointer
,	O
outfile	pointer
)	O
,	O
size	int
=	O
10	int
;	O
fputc	function
(	O
c	int
,	O
outfile	pointer
)	O
,	O
size	int
++	O
;	O
if	O
(	O
oldc	int
!=	O
'\\'	O
&&	O
c	int
==	O
'"'	O
)	O
break	O
;	O
}	O
}	O
}	O
return	O
;	O
}	O
static	O
void	O
display_help	function
(	O
char	O
*	O
my_name	pointer
)	O
{	O
printf	function
(	O
"Usage: %s [options...] [filename]\n"	pointer
,	O
my_name	pointer
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
"Options:\n"	pointer
)	O
;	O
printf	function
(	O
"   -d, --debug          run translator in debug mode\n"	pointer
)	O
;	O
printf	function
(	O
"   -e nnn, --errormax nnn\n"	pointer
)	O
;	O
printf	function
(	O
"                        maximal error allowance (0 <= nnn"	pointer
" <= 255);\n"	pointer
)	O
;	O
printf	function
(	O
"                        default: -e 0 (continue translati"	pointer
"on in any case)\n"	pointer
)	O
;	O
printf	function
(	O
"   -h, --help           display this help information and"	pointer
" exit(0)\n"	pointer
)	O
;	O
printf	function
(	O
"   -l nnn, --linewidth nnn\n"	pointer
)	O
;	O
printf	function
(	O
"                        desirable output line width (50 <"	pointer
"= nnn <= 255);\n"	pointer
)	O
;	O
printf	function
(	O
"                        default: -l 72\n"	pointer
)	O
;	O
printf	function
(	O
"   -o filename, --output filename\n"	pointer
)	O
;	O
printf	function
(	O
"                        send output C code to filename\n"	pointer
)	O
;	O
printf	function
(	O
"   -t, --notimestamp    suppress time stamp in output C c"	pointer
"ode\n"	pointer
)	O
;	O
printf	function
(	O
"   -v, --version        display translator version and ex"	pointer
"it(0)\n"	pointer
)	O
;	O
printf	function
(	O
"   -w, --nowarn         suppress all warning messages\n"	pointer
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
"N.B.  The translator reads input file TWICE, therefore th"	pointer
"is file should\n"	pointer
)	O
;	O
printf	function
(	O
"      be assigned to regular file (but not to terminal, p"	pointer
"ipe, etc.)\n"	pointer
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
"Please, report bugs to <bug-marst@gnu.org>\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
static	O
void	O
display_version	function
(	O
void	O
)	O
{	O
printf	function
(	O
"                                 Was sich ueberhaupt sage"	pointer
"n laesst, laesst\n"	pointer
)	O
;	O
printf	function
(	O
"                                 sich klar sagen; und wov"	pointer
"on man nicht reden\n"	pointer
)	O
;	O
printf	function
(	O
"                                 kann, darueber muss man "	pointer
"schweigen.\n"	pointer
)	O
;	O
printf	function
(	O
"                                                         "	pointer
"Ludwig Wittgenstein\n"	pointer
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
"%s\n"	pointer
,	O
version	pointer
)	O
;	O
printf	function
(	O
"Copyright (C) 2000, 2001, 2002, 2007, 2013 Free Software "	pointer
"Foundation, Inc.\n"	pointer
)	O
;	O
printf	function
(	O
"This program is free software; you may redistribute it un"	pointer
"der the terms of\n"	pointer
)	O
;	O
printf	function
(	O
"the GNU General Public License. This program has absolute"	pointer
"ly no warranty.\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
static	O
void	O
process_cmdline	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array
[	O
]	O
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<	O
argc	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
argv	array
[	O
k	int
]	O
,	O
"-d"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	array
[	O
k	int
]	O
,	O
"--debug"	pointer
)	O
==	O
0	int
)	O
debug	int
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
argv	array
[	O
k	int
]	O
,	O
"-e"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	array
[	O
k	int
]	O
,	O
"--errormax"	pointer
)	O
==	O
0	int
)	O
{	O
char	O
*	O
endptr	pointer
;	O
k	int
++	O
;	O
if	O
(	O
k	int
==	O
argc	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"No error count specified\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
errmax	int
=	O
strtol	function
(	O
argv	array
[	O
k	int
]	O
,	O
&	O
endptr	pointer
,	O
10	int
)	O
;	O
if	O
(	O
!	O
(	O
*	O
endptr	pointer
==	O
'\0'	O
&&	O
0	int
<=	O
errmax	int
&&	O
errmax	int
<=	O
255	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Invalid error count `%s'"	pointer
,	O
argv	array
[	O
k	int
]	O
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	array
[	O
k	int
]	O
,	O
"-h"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	array
[	O
k	int
]	O
,	O
"--help"	pointer
)	O
==	O
0	int
)	O
display_help	function
(	O
argv	array
[	O
0	int
]	O
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
argv	array
[	O
k	int
]	O
,	O
"-l"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	array
[	O
k	int
]	O
,	O
"--linewidth"	pointer
)	O
==	O
0	int
)	O
{	O
char	O
*	O
endptr	pointer
;	O
k	int
++	O
;	O
if	O
(	O
k	int
==	O
argc	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"No line width specified\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
width	int
=	O
strtol	function
(	O
argv	array
[	O
k	int
]	O
,	O
&	O
endptr	pointer
,	O
10	int
)	O
;	O
if	O
(	O
!	O
(	O
*	O
endptr	pointer
==	O
'\0'	O
&&	O
50	int
<=	O
width	int
&&	O
width	int
<=	O
255	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Invalid line width `%s'"	pointer
,	O
argv	array
[	O
k	int
]	O
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	array
[	O
k	int
]	O
,	O
"-o"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	array
[	O
k	int
]	O
,	O
"--output"	pointer
)	O
==	O
0	int
)	O
{	O
k	int
++	O
;	O
if	O
(	O
k	int
==	O
argc	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"No output file name specified\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
outfilename	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Only one output file allowed\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
outfilename	pointer
=	O
argv	array
[	O
k	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	array
[	O
k	int
]	O
,	O
"-t"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	array
[	O
k	int
]	O
,	O
"--notimestamp"	pointer
)	O
==	O
0	int
)	O
time_stamp	int
=	O
0	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
argv	array
[	O
k	int
]	O
,	O
"-v"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	array
[	O
k	int
]	O
,	O
"--version"	pointer
)	O
==	O
0	int
)	O
display_version	function
(	O
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
argv	array
[	O
k	int
]	O
,	O
"-w"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	array
[	O
k	int
]	O
,	O
"--nowarn"	pointer
)	O
==	O
0	int
)	O
warn	int
=	O
0	int
;	O
else	O
if	O
(	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'-'	O
||	O
(	O
argv	array
[	O
k	int
]	O
[	O
0	int
]	O
==	O
'-'	O
&&	O
argv	array
[	O
k	int
]	O
[	O
1	int
]	O
==	O
'-'	O
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Invalid option `%s'; try %s --help\n"	pointer
,	O
argv	array
[	O
k	int
]	O
,	O
argv	array
[	O
0	int
]	O
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
infilename	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Only one input file allowed\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
infilename	pointer
=	O
argv	array
[	O
k	int
]	O
;	O
}	O
}	O
return	O
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array
[	O
]	O
)	O
{	O
process_cmdline	function
(	O
argc	int
,	O
argv	array
)	O
;	O
if	O
(	O
infilename	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
infilename	pointer
=	O
"(stdin)"	pointer
;	O
infile	pointer
=	O
stdin	pointer
;	O
}	O
else	O
{	O
infile	pointer
=	O
fopen	function
(	O
infilename	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
infile	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Unable to open input file `%s' - %s\n"	pointer
,	O
infilename	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
if	O
(	O
outfilename	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
outfilename	pointer
=	O
"(stdout)"	pointer
;	O
outfile	pointer
=	O
stdout	pointer
;	O
}	O
else	O
{	O
outfile	pointer
=	O
fopen	function
(	O
outfilename	pointer
,	O
"w"	pointer
)	O
;	O
if	O
(	O
outfile	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Unable to open output file `%s' - %s\n"	pointer
,	O
outfilename	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
first_pass	int
=	O
1	int
,	O
second_pass	int
=	O
0	int
;	O
first_b	pointer
=	O
last_b	pointer
=	O
current	pointer
=	O
NULL	O
;	O
if	O
(	O
debug	int
)	O
fprintf	function
(	O
outfile	pointer
,	O
"#if 0 /* start of translator debug output */"	pointer
"\n\n"	pointer
)	O
;	O
entire_module	function
(	O
)	O
;	O
if	O
(	O
debug	int
)	O
fprintf	function
(	O
outfile	pointer
,	O
"\n#endif /* end of translator debug output */\n\n"	pointer
)	O
;	O
if	O
(	O
e_count	int
)	O
{	O
if	O
(	O
e_count	int
==	O
1	int
)	O
error	function
(	O
"one error detected on the first pass; translation te"	pointer
"rminated"	pointer
)	O
;	O
else	O
error	function
(	O
"%d errors detected on the first pass; translation te"	pointer
"rminated"	pointer
,	O
e_count	int
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
first_pass	int
=	O
0	int
,	O
second_pass	int
=	O
1	int
;	O
emit	pointer
=	O
new_code	function
(	O
)	O
;	O
append	function
(	O
emit	pointer
,	O
"/* %s */\n"	pointer
,	O
outfilename	pointer
)	O
;	O
append	function
(	O
emit	pointer
,	O
"\n"	pointer
)	O
;	O
append	function
(	O
emit	pointer
,	O
"/* generated by GNU %s */\n"	pointer
,	O
version	pointer
)	O
;	O
if	O
(	O
time_stamp	int
)	O
{	O
time_t	long
zeit	long
=	O
time	function
(	O
NULL	O
)	O
;	O
char	O
stamp	array
[	O
25	int
]	O
;	O
memcpy	function
(	O
stamp	array
,	O
ctime	function
(	O
&	O
zeit	long
)	O
,	O
24	int
)	O
;	O
stamp	array
[	O
24	int
]	O
=	O
'\0'	O
;	O
append	function
(	O
emit	pointer
,	O
"/* %s */\n"	pointer
,	O
stamp	array
)	O
;	O
append	function
(	O
emit	pointer
,	O
"/* source file: %s */\n"	pointer
,	O
infilename	pointer
)	O
;	O
append	function
(	O
emit	pointer
,	O
"/* object file: %s */\n"	pointer
,	O
outfilename	pointer
)	O
;	O
}	O
append	function
(	O
emit	pointer
,	O
"\n"	pointer
)	O
;	O
append	function
(	O
emit	pointer
,	O
"#include \"algol.h\"\n"	pointer
)	O
;	O
append	function
(	O
emit	pointer
,	O
"\n"	pointer
)	O
;	O
{	O
BLOCK	struct
*	O
b	pointer
;	O
for	O
(	O
b	pointer
=	O
first_b	pointer
;	O
b	pointer
!=	O
NULL	O
;	O
b	pointer
=	O
b	pointer
->	O
next	pointer
)	O
{	O
IDENT	struct
*	O
id	pointer
;	O
if	O
(	O
b	pointer
->	O
proc	pointer
!=	O
NULL	O
)	O
emit_proc_head	function
(	O
b	pointer
->	O
proc	pointer
,	O
1	int
)	O
;	O
for	O
(	O
id	pointer
=	O
b	pointer
->	O
first	pointer
;	O
id	pointer
!=	O
NULL	O
;	O
id	pointer
=	O
id	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
id	pointer
->	O
flags	int
==	O
F_SWITCH	int
)	O
append	function
(	O
emit	pointer
,	O
"static struct label %s_%d /* local swit"	pointer
"ch */ (int);\n\n"	pointer
,	O
id	pointer
->	O
name	pointer
,	O
id	pointer
->	O
block	pointer
->	O
seqn	int
)	O
;	O
}	O
}	O
}	O
emit_dsa_code	function
(	O
)	O
;	O
last_b	pointer
=	O
NULL	O
;	O
rewind	function
(	O
infile	pointer
)	O
;	O
{	O
int	O
is_main	int
;	O
is_main	int
=	O
entire_module	function
(	O
)	O
;	O
if	O
(	O
is_main	int
)	O
emit_startup_code	function
(	O
)	O
;	O
}	O
if	O
(	O
e_count	int
)	O
{	O
if	O
(	O
e_count	int
==	O
1	int
)	O
error	function
(	O
"one error detected on the second pass; translation t"	pointer
"erminated"	pointer
)	O
;	O
else	O
error	function
(	O
"%d errors detected on the second pass; translation t"	pointer
"erminated"	pointer
,	O
e_count	int
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
append	function
(	O
emit	pointer
,	O
"/* eof */\n"	pointer
)	O
;	O
output_code	function
(	O
emit	pointer
)	O
;	O
fclose	function
(	O
infile	pointer
)	O
;	O
fflush	function
(	O
outfile	pointer
)	O
;	O
if	O
(	O
ferror	function
(	O
outfile	pointer
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Write error on `%s' - %s\n"	pointer
,	O
outfilename	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
fclose	function
(	O
outfile	pointer
)	O
;	O
return	O
0	int
;	O
}	O
