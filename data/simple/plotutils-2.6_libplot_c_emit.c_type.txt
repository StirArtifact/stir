static	O
void	O
cgm_emit_partition_control_word	function
(	O
plOutbuf	struct
*	O
outbuf	pointer
,	O
int	O
data_len	int
,	O
const	O
int	O
*	O
data_byte_count	pointer
,	O
int	O
*	O
byte_count	pointer
)	O
;	O
static	O
void	O
double_to_ieee_single_precision	function
(	O
double	O
d	double
,	O
unsigned	O
char	O
output	array
[	O
4	int
]	O
)	O
;	O
static	O
void	O
int_to_cgm_int	function
(	O
int	O
n	array
,	O
unsigned	O
char	O
*	O
cgm_int	pointer
,	O
int	O
octets_per_cgm_int	int
)	O
;	O
static	O
void	O
unsigned_int_to_cgm_unsigned_int	function
(	O
unsigned	O
int	O
n	array
,	O
unsigned	O
char	O
*	O
cgm_unsigned_int	pointer
,	O
int	O
octets_per_cgm_unsigned_int	int
)	O
;	O
void	O
_cgm_emit_command_header	function
(	O
plOutbuf	struct
*	O
outbuf	pointer
,	O
int	O
cgm_encoding	int
,	O
int	O
element_class	int
,	O
int	O
id	int
,	O
int	O
data_len	int
,	O
int	O
*	O
byte_count	pointer
,	O
const	O
char	O
*	O
op_code	pointer
)	O
{	O
switch	O
(	O
cgm_encoding	int
)	O
{	O
case	O
CGM_ENCODING_BINARY	int
:	O
default	O
:	O
{	O
int	O
temp	int
;	O
if	O
(	O
data_len	int
>	O
30	int
)	O
data_len	int
=	O
31	int
;	O
temp	int
=	O
(	O
element_class	int
&	O
017	int
)	O
<<	O
4	int
;	O
temp	int
|=	O
(	O
id	int
>>	O
3	int
)	O
&	O
017	int
;	O
outbuf	pointer
->	O
point	pointer
[	O
0	int
]	O
=	O
(	O
char	O
)	O
(	O
unsigned	O
char	O
)	O
temp	int
;	O
temp	int
=	O
(	O
id	int
&	O
0177	int
)	O
<<	O
5	int
;	O
temp	int
|=	O
(	O
data_len	int
&	O
037	int
)	O
;	O
outbuf	pointer
->	O
point	pointer
[	O
1	int
]	O
=	O
(	O
char	O
)	O
(	O
unsigned	O
char	O
)	O
temp	int
;	O
_update_buffer_by_added_bytes	function
(	O
outbuf	pointer
,	O
2	int
)	O
;	O
(	O
*	O
byte_count	pointer
)	O
+=	O
2	int
;	O
}	O
break	O
;	O
case	O
CGM_ENCODING_CHARACTER	int
:	O
break	O
;	O
case	O
CGM_ENCODING_CLEAR_TEXT	int
:	O
sprintf	function
(	O
outbuf	pointer
->	O
point	pointer
,	O
"%s"	pointer
,	O
op_code	pointer
)	O
;	O
_update_buffer	function
(	O
outbuf	pointer
)	O
;	O
break	O
;	O
}	O
}	O
static	O
void	O
cgm_emit_partition_control_word	function
(	O
plOutbuf	struct
*	O
outbuf	pointer
,	O
int	O
data_len	int
,	O
const	O
int	O
*	O
data_byte_count	pointer
,	O
int	O
*	O
byte_count	pointer
)	O
{	O
int	O
bytes_remaining	int
=	O
data_len	int
-	O
(	O
*	O
data_byte_count	pointer
)	O
;	O
int	O
bytes_in_partition	int
;	O
unsigned	O
int	O
control_word	int
;	O
if	O
(	O
bytes_remaining	int
>	O
CGM_BINARY_DATA_BYTES_PER_PARTITION	int
)	O
{	O
bytes_in_partition	int
=	O
CGM_BINARY_DATA_BYTES_PER_PARTITION	int
;	O
control_word	int
=	O
1	int
<<	O
15	int
;	O
}	O
else	O
{	O
bytes_in_partition	int
=	O
bytes_remaining	int
;	O
control_word	int
=	O
0	int
;	O
}	O
control_word	int
|=	O
(	O
unsigned	O
int	O
)	O
bytes_in_partition	int
;	O
outbuf	pointer
->	O
point	pointer
[	O
0	int
]	O
=	O
(	O
char	O
)	O
(	O
unsigned	O
char	O
)	O
(	O
(	O
control_word	int
>>	O
8	int
)	O
&	O
0377	int
)	O
;	O
outbuf	pointer
->	O
point	pointer
[	O
1	int
]	O
=	O
(	O
char	O
)	O
(	O
unsigned	O
char	O
)	O
(	O
control_word	int
&	O
0377	int
)	O
;	O
_update_buffer_by_added_bytes	function
(	O
outbuf	pointer
,	O
2	int
)	O
;	O
(	O
*	O
byte_count	pointer
)	O
+=	O
2	int
;	O
}	O
static	O
void	O
int_to_cgm_int	function
(	O
int	O
n	array
,	O
unsigned	O
char	O
*	O
cgm_int	pointer
,	O
int	O
octets_per_cgm_int	int
)	O
{	O
int	O
max_int	int
,	O
i	int
;	O
unsigned	O
int	O
u	int
;	O
bool	enum
negative	enum
=	O
false	int
;	O
max_int	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
(	O
8	int
*	O
octets_per_cgm_int	int
-	O
1	int
)	O
;	O
i	int
++	O
)	O
max_int	int
+=	O
(	O
1	int
<<	O
i	int
)	O
;	O
if	O
(	O
n	array
>	O
max_int	int
)	O
n	array
=	O
max_int	int
;	O
else	O
if	O
(	O
n	array
<	O
-	O
max_int	int
)	O
n	array
=	O
-	O
max_int	int
;	O
if	O
(	O
n	array
<	O
0	int
)	O
{	O
int	O
temp	int
;	O
negative	enum
=	O
true	int
;	O
temp	int
=	O
-	O
(	O
n	array
+	O
1	int
)	O
;	O
u	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
max_int	int
-	O
temp	int
)	O
;	O
}	O
else	O
u	int
=	O
(	O
unsigned	O
int	O
)	O
n	array
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
octets_per_cgm_int	int
;	O
i	int
++	O
)	O
{	O
unsigned	O
char	O
v	pointer
;	O
v	pointer
=	O
0xff	int
&	O
(	O
u	int
>>	O
(	O
8	int
*	O
(	O
(	O
octets_per_cgm_int	int
-	O
1	int
)	O
-	O
i	int
)	O
)	O
)	O
;	O
if	O
(	O
i	int
==	O
0	int
&&	O
negative	enum
)	O
v	pointer
|=	O
0x80	int
;	O
cgm_int	pointer
[	O
i	int
]	O
=	O
v	pointer
;	O
}	O
}	O
static	O
void	O
unsigned_int_to_cgm_unsigned_int	function
(	O
unsigned	O
int	O
n	array
,	O
unsigned	O
char	O
*	O
cgm_unsigned_int	pointer
,	O
int	O
octets_per_cgm_unsigned_int	int
)	O
{	O
unsigned	O
int	O
max_unsigned_int	int
;	O
int	O
i	int
;	O
max_unsigned_int	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
(	O
8	int
*	O
octets_per_cgm_unsigned_int	int
)	O
;	O
i	int
++	O
)	O
max_unsigned_int	int
+=	O
(	O
1	int
<<	O
i	int
)	O
;	O
if	O
(	O
n	array
>	O
max_unsigned_int	int
)	O
n	array
=	O
max_unsigned_int	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
octets_per_cgm_unsigned_int	int
;	O
i	int
++	O
)	O
{	O
unsigned	O
char	O
v	pointer
;	O
v	pointer
=	O
0xff	int
&	O
(	O
n	array
>>	O
(	O
8	int
*	O
(	O
(	O
octets_per_cgm_unsigned_int	int
-	O
1	int
)	O
-	O
i	int
)	O
)	O
)	O
;	O
cgm_unsigned_int	pointer
[	O
i	int
]	O
=	O
v	pointer
;	O
}	O
}	O
void	O
_cgm_emit_integer	function
(	O
plOutbuf	struct
*	O
outbuf	pointer
,	O
bool	enum
no_partitioning	enum
,	O
int	O
cgm_encoding	int
,	O
int	O
x	double
,	O
int	O
data_len	int
,	O
int	O
*	O
data_byte_count	pointer
,	O
int	O
*	O
byte_count	pointer
)	O
{	O
int	O
i	int
;	O
unsigned	O
char	O
cgm_int	pointer
[	O
CGM_BINARY_BYTES_PER_INTEGER	int
]	O
;	O
switch	O
(	O
cgm_encoding	int
)	O
{	O
case	O
CGM_ENCODING_BINARY	int
:	O
default	O
:	O
int_to_cgm_int	function
(	O
x	double
,	O
cgm_int	pointer
,	O
CGM_BINARY_BYTES_PER_INTEGER	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
CGM_BINARY_BYTES_PER_INTEGER	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
no_partitioning	enum
==	O
false	int
&&	O
CGM_BINARY_DATA_PARTITION_BEGINS	O
(	O
data_len	int
,	O
data_byte_count	pointer
)	O
)	O
cgm_emit_partition_control_word	function
(	O
outbuf	pointer
,	O
data_len	int
,	O
data_byte_count	pointer
,	O
byte_count	pointer
)	O
;	O
*	O
(	O
outbuf	pointer
->	O
point	pointer
)	O
=	O
(	O
char	O
)	O
(	O
cgm_int	pointer
[	O
i	int
]	O
)	O
;	O
_update_buffer_by_added_bytes	function
(	O
outbuf	pointer
,	O
1	int
)	O
;	O
(	O
*	O
data_byte_count	pointer
)	O
++	O
;	O
(	O
*	O
byte_count	pointer
)	O
++	O
;	O
}	O
break	O
;	O
case	O
CGM_ENCODING_CHARACTER	int
:	O
break	O
;	O
case	O
CGM_ENCODING_CLEAR_TEXT	int
:	O
sprintf	function
(	O
outbuf	pointer
->	O
point	pointer
,	O
" %d"	pointer
,	O
x	double
)	O
;	O
_update_buffer	function
(	O
outbuf	pointer
)	O
;	O
break	O
;	O
}	O
}	O
void	O
_cgm_emit_unsigned_integer	function
(	O
plOutbuf	struct
*	O
outbuf	pointer
,	O
bool	enum
no_partitioning	enum
,	O
int	O
cgm_encoding	int
,	O
unsigned	O
int	O
x	double
,	O
int	O
data_len	int
,	O
int	O
*	O
data_byte_count	pointer
,	O
int	O
*	O
byte_count	pointer
)	O
{	O
int	O
i	int
;	O
unsigned	O
char	O
cgm_unsigned_int	pointer
[	O
CGM_BINARY_BYTES_PER_INTEGER	int
]	O
;	O
switch	O
(	O
cgm_encoding	int
)	O
{	O
case	O
CGM_ENCODING_BINARY	int
:	O
default	O
:	O
unsigned_int_to_cgm_unsigned_int	function
(	O
x	double
,	O
cgm_unsigned_int	pointer
,	O
CGM_BINARY_BYTES_PER_INTEGER	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
CGM_BINARY_BYTES_PER_INTEGER	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
no_partitioning	enum
==	O
false	int
&&	O
CGM_BINARY_DATA_PARTITION_BEGINS	O
(	O
data_len	int
,	O
data_byte_count	pointer
)	O
)	O
cgm_emit_partition_control_word	function
(	O
outbuf	pointer
,	O
data_len	int
,	O
data_byte_count	pointer
,	O
byte_count	pointer
)	O
;	O
*	O
(	O
outbuf	pointer
->	O
point	pointer
)	O
=	O
(	O
char	O
)	O
(	O
cgm_unsigned_int	pointer
[	O
i	int
]	O
)	O
;	O
_update_buffer_by_added_bytes	function
(	O
outbuf	pointer
,	O
1	int
)	O
;	O
(	O
*	O
data_byte_count	pointer
)	O
++	O
;	O
(	O
*	O
byte_count	pointer
)	O
++	O
;	O
}	O
break	O
;	O
case	O
CGM_ENCODING_CHARACTER	int
:	O
break	O
;	O
case	O
CGM_ENCODING_CLEAR_TEXT	int
:	O
sprintf	function
(	O
outbuf	pointer
->	O
point	pointer
,	O
" %u"	pointer
,	O
x	double
)	O
;	O
_update_buffer	function
(	O
outbuf	pointer
)	O
;	O
break	O
;	O
}	O
}	O
void	O
_cgm_emit_unsigned_integer_8bit	function
(	O
plOutbuf	struct
*	O
outbuf	pointer
,	O
bool	enum
no_partitioning	enum
,	O
int	O
cgm_encoding	int
,	O
unsigned	O
int	O
x	double
,	O
int	O
data_len	int
,	O
int	O
*	O
data_byte_count	pointer
,	O
int	O
*	O
byte_count	pointer
)	O
{	O
if	O
(	O
x	double
>	O
(	O
unsigned	O
int	O
)	O
255	int
)	O
x	double
=	O
(	O
unsigned	O
int	O
)	O
255	int
;	O
switch	O
(	O
cgm_encoding	int
)	O
{	O
case	O
CGM_ENCODING_BINARY	int
:	O
default	O
:	O
if	O
(	O
no_partitioning	enum
==	O
false	int
&&	O
CGM_BINARY_DATA_PARTITION_BEGINS	O
(	O
data_len	int
,	O
data_byte_count	pointer
)	O
)	O
cgm_emit_partition_control_word	function
(	O
outbuf	pointer
,	O
data_len	int
,	O
data_byte_count	pointer
,	O
byte_count	pointer
)	O
;	O
*	O
(	O
outbuf	pointer
->	O
point	pointer
)	O
=	O
(	O
char	O
)	O
(	O
unsigned	O
char	O
)	O
x	double
;	O
_update_buffer_by_added_bytes	function
(	O
outbuf	pointer
,	O
1	int
)	O
;	O
(	O
*	O
data_byte_count	pointer
)	O
++	O
;	O
(	O
*	O
byte_count	pointer
)	O
++	O
;	O
break	O
;	O
case	O
CGM_ENCODING_CHARACTER	int
:	O
break	O
;	O
case	O
CGM_ENCODING_CLEAR_TEXT	int
:	O
sprintf	function
(	O
outbuf	pointer
->	O
point	pointer
,	O
" %u"	pointer
,	O
x	double
)	O
;	O
_update_buffer	function
(	O
outbuf	pointer
)	O
;	O
break	O
;	O
}	O
}	O
void	O
_cgm_emit_point	function
(	O
plOutbuf	struct
*	O
outbuf	pointer
,	O
bool	enum
no_partitioning	enum
,	O
int	O
cgm_encoding	int
,	O
int	O
x	double
,	O
int	O
y	double
,	O
int	O
data_len	int
,	O
int	O
*	O
data_byte_count	pointer
,	O
int	O
*	O
byte_count	pointer
)	O
{	O
int	O
i	int
;	O
unsigned	O
char	O
cgm_int	pointer
[	O
CGM_BINARY_BYTES_PER_INTEGER	int
]	O
;	O
switch	O
(	O
cgm_encoding	int
)	O
{	O
case	O
CGM_ENCODING_BINARY	int
:	O
default	O
:	O
int_to_cgm_int	function
(	O
x	double
,	O
cgm_int	pointer
,	O
CGM_BINARY_BYTES_PER_INTEGER	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
CGM_BINARY_BYTES_PER_INTEGER	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
no_partitioning	enum
==	O
false	int
&&	O
CGM_BINARY_DATA_PARTITION_BEGINS	O
(	O
data_len	int
,	O
data_byte_count	pointer
)	O
)	O
cgm_emit_partition_control_word	function
(	O
outbuf	pointer
,	O
data_len	int
,	O
data_byte_count	pointer
,	O
byte_count	pointer
)	O
;	O
*	O
(	O
outbuf	pointer
->	O
point	pointer
)	O
=	O
(	O
char	O
)	O
(	O
cgm_int	pointer
[	O
i	int
]	O
)	O
;	O
_update_buffer_by_added_bytes	function
(	O
outbuf	pointer
,	O
1	int
)	O
;	O
(	O
*	O
data_byte_count	pointer
)	O
++	O
;	O
(	O
*	O
byte_count	pointer
)	O
++	O
;	O
}	O
int_to_cgm_int	function
(	O
y	double
,	O
cgm_int	pointer
,	O
CGM_BINARY_BYTES_PER_INTEGER	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
CGM_BINARY_BYTES_PER_INTEGER	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
no_partitioning	enum
==	O
false	int
&&	O
CGM_BINARY_DATA_PARTITION_BEGINS	O
(	O
data_len	int
,	O
data_byte_count	pointer
)	O
)	O
cgm_emit_partition_control_word	function
(	O
outbuf	pointer
,	O
data_len	int
,	O
data_byte_count	pointer
,	O
byte_count	pointer
)	O
;	O
*	O
(	O
outbuf	pointer
->	O
point	pointer
)	O
=	O
(	O
char	O
)	O
(	O
cgm_int	pointer
[	O
i	int
]	O
)	O
;	O
_update_buffer_by_added_bytes	function
(	O
outbuf	pointer
,	O
1	int
)	O
;	O
(	O
*	O
data_byte_count	pointer
)	O
++	O
;	O
(	O
*	O
byte_count	pointer
)	O
++	O
;	O
}	O
break	O
;	O
case	O
CGM_ENCODING_CHARACTER	int
:	O
break	O
;	O
case	O
CGM_ENCODING_CLEAR_TEXT	int
:	O
sprintf	function
(	O
outbuf	pointer
->	O
point	pointer
,	O
" (%d, %d)"	pointer
,	O
x	double
,	O
y	double
)	O
;	O
_update_buffer	function
(	O
outbuf	pointer
)	O
;	O
break	O
;	O
}	O
}	O
void	O
_cgm_emit_points	function
(	O
plOutbuf	struct
*	O
outbuf	pointer
,	O
bool	enum
no_partitioning	enum
,	O
int	O
cgm_encoding	int
,	O
const	O
int	O
*	O
x	double
,	O
const	O
int	O
*	O
y	double
,	O
int	O
npoints	int
,	O
int	O
data_len	int
,	O
int	O
*	O
data_byte_count	pointer
,	O
int	O
*	O
byte_count	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
unsigned	O
char	O
cgm_int	pointer
[	O
CGM_BINARY_BYTES_PER_INTEGER	int
]	O
;	O
switch	O
(	O
cgm_encoding	int
)	O
{	O
case	O
CGM_ENCODING_BINARY	int
:	O
default	O
:	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
npoints	int
;	O
j	int
++	O
)	O
{	O
int_to_cgm_int	function
(	O
x	double
[	O
j	int
]	O
,	O
cgm_int	pointer
,	O
CGM_BINARY_BYTES_PER_INTEGER	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
CGM_BINARY_BYTES_PER_INTEGER	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
no_partitioning	enum
==	O
false	int
&&	O
CGM_BINARY_DATA_PARTITION_BEGINS	O
(	O
data_len	int
,	O
data_byte_count	pointer
)	O
)	O
cgm_emit_partition_control_word	function
(	O
outbuf	pointer
,	O
data_len	int
,	O
data_byte_count	pointer
,	O
byte_count	pointer
)	O
;	O
*	O
(	O
outbuf	pointer
->	O
point	pointer
)	O
=	O
(	O
char	O
)	O
(	O
cgm_int	pointer
[	O
i	int
]	O
)	O
;	O
_update_buffer_by_added_bytes	function
(	O
outbuf	pointer
,	O
1	int
)	O
;	O
(	O
*	O
data_byte_count	pointer
)	O
++	O
;	O
(	O
*	O
byte_count	pointer
)	O
++	O
;	O
}	O
int_to_cgm_int	function
(	O
y	double
[	O
j	int
]	O
,	O
cgm_int	pointer
,	O
CGM_BINARY_BYTES_PER_INTEGER	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
CGM_BINARY_BYTES_PER_INTEGER	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
no_partitioning	enum
==	O
false	int
&&	O
CGM_BINARY_DATA_PARTITION_BEGINS	O
(	O
data_len	int
,	O
data_byte_count	pointer
)	O
)	O
cgm_emit_partition_control_word	function
(	O
outbuf	pointer
,	O
data_len	int
,	O
data_byte_count	pointer
,	O
byte_count	pointer
)	O
;	O
*	O
(	O
outbuf	pointer
->	O
point	pointer
)	O
=	O
(	O
char	O
)	O
(	O
cgm_int	pointer
[	O
i	int
]	O
)	O
;	O
_update_buffer_by_added_bytes	function
(	O
outbuf	pointer
,	O
1	int
)	O
;	O
(	O
*	O
data_byte_count	pointer
)	O
++	O
;	O
(	O
*	O
byte_count	pointer
)	O
++	O
;	O
}	O
}	O
break	O
;	O
case	O
CGM_ENCODING_CHARACTER	int
:	O
break	O
;	O
case	O
CGM_ENCODING_CLEAR_TEXT	int
:	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
npoints	int
;	O
i	int
++	O
)	O
{	O
sprintf	function
(	O
outbuf	pointer
->	O
point	pointer
,	O
" (%d, %d)"	pointer
,	O
x	double
[	O
i	int
]	O
,	O
y	double
[	O
i	int
]	O
)	O
;	O
_update_buffer	function
(	O
outbuf	pointer
)	O
;	O
}	O
break	O
;	O
}	O
}	O
void	O
_cgm_emit_enum	function
(	O
plOutbuf	struct
*	O
outbuf	pointer
,	O
bool	enum
no_partitioning	enum
,	O
int	O
cgm_encoding	int
,	O
int	O
x	double
,	O
int	O
data_len	int
,	O
int	O
*	O
data_byte_count	pointer
,	O
int	O
*	O
byte_count	pointer
,	O
const	O
char	O
*	O
text_string	pointer
)	O
{	O
int	O
i	int
;	O
unsigned	O
char	O
cgm_int	pointer
[	O
2	int
]	O
;	O
switch	O
(	O
cgm_encoding	int
)	O
{	O
case	O
CGM_ENCODING_BINARY	int
:	O
default	O
:	O
int_to_cgm_int	function
(	O
x	double
,	O
cgm_int	pointer
,	O
2	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
2	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
no_partitioning	enum
==	O
false	int
&&	O
CGM_BINARY_DATA_PARTITION_BEGINS	O
(	O
data_len	int
,	O
data_byte_count	pointer
)	O
)	O
cgm_emit_partition_control_word	function
(	O
outbuf	pointer
,	O
data_len	int
,	O
data_byte_count	pointer
,	O
byte_count	pointer
)	O
;	O
*	O
(	O
outbuf	pointer
->	O
point	pointer
)	O
=	O
(	O
char	O
)	O
(	O
cgm_int	pointer
[	O
i	int
]	O
)	O
;	O
_update_buffer_by_added_bytes	function
(	O
outbuf	pointer
,	O
1	int
)	O
;	O
(	O
*	O
data_byte_count	pointer
)	O
++	O
;	O
(	O
*	O
byte_count	pointer
)	O
++	O
;	O
}	O
break	O
;	O
case	O
CGM_ENCODING_CHARACTER	int
:	O
break	O
;	O
case	O
CGM_ENCODING_CLEAR_TEXT	int
:	O
sprintf	function
(	O
outbuf	pointer
->	O
point	pointer
,	O
" %s"	pointer
,	O
text_string	pointer
)	O
;	O
_update_buffer	function
(	O
outbuf	pointer
)	O
;	O
break	O
;	O
}	O
}	O
void	O
_cgm_emit_index	function
(	O
plOutbuf	struct
*	O
outbuf	pointer
,	O
bool	enum
no_partitioning	enum
,	O
int	O
cgm_encoding	int
,	O
int	O
x	double
,	O
int	O
data_len	int
,	O
int	O
*	O
data_byte_count	pointer
,	O
int	O
*	O
byte_count	pointer
)	O
{	O
int	O
i	int
;	O
unsigned	O
char	O
cgm_int	pointer
[	O
2	int
]	O
;	O
switch	O
(	O
cgm_encoding	int
)	O
{	O
case	O
CGM_ENCODING_BINARY	int
:	O
default	O
:	O
int_to_cgm_int	function
(	O
x	double
,	O
cgm_int	pointer
,	O
2	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
2	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
no_partitioning	enum
==	O
false	int
&&	O
CGM_BINARY_DATA_PARTITION_BEGINS	O
(	O
data_len	int
,	O
data_byte_count	pointer
)	O
)	O
cgm_emit_partition_control_word	function
(	O
outbuf	pointer
,	O
data_len	int
,	O
data_byte_count	pointer
,	O
byte_count	pointer
)	O
;	O
*	O
(	O
outbuf	pointer
->	O
point	pointer
)	O
=	O
(	O
char	O
)	O
(	O
cgm_int	pointer
[	O
i	int
]	O
)	O
;	O
_update_buffer_by_added_bytes	function
(	O
outbuf	pointer
,	O
1	int
)	O
;	O
(	O
*	O
data_byte_count	pointer
)	O
++	O
;	O
(	O
*	O
byte_count	pointer
)	O
++	O
;	O
}	O
break	O
;	O
case	O
CGM_ENCODING_CHARACTER	int
:	O
break	O
;	O
case	O
CGM_ENCODING_CLEAR_TEXT	int
:	O
sprintf	function
(	O
outbuf	pointer
->	O
point	pointer
,	O
" %d"	pointer
,	O
x	double
)	O
;	O
_update_buffer	function
(	O
outbuf	pointer
)	O
;	O
break	O
;	O
}	O
}	O
void	O
_cgm_emit_color_component	function
(	O
plOutbuf	struct
*	O
outbuf	pointer
,	O
bool	enum
no_partitioning	enum
,	O
int	O
cgm_encoding	int
,	O
unsigned	O
int	O
x	double
,	O
int	O
data_len	int
,	O
int	O
*	O
data_byte_count	pointer
,	O
int	O
*	O
byte_count	pointer
)	O
{	O
int	O
i	int
;	O
unsigned	O
char	O
cgm_unsigned_int	pointer
[	O
CGM_BINARY_BYTES_PER_COLOR_COMPONENT	int
]	O
;	O
switch	O
(	O
cgm_encoding	int
)	O
{	O
case	O
CGM_ENCODING_BINARY	int
:	O
default	O
:	O
unsigned_int_to_cgm_unsigned_int	function
(	O
x	double
,	O
cgm_unsigned_int	pointer
,	O
CGM_BINARY_BYTES_PER_COLOR_COMPONENT	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
CGM_BINARY_BYTES_PER_COLOR_COMPONENT	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
no_partitioning	enum
==	O
false	int
&&	O
CGM_BINARY_DATA_PARTITION_BEGINS	O
(	O
data_len	int
,	O
data_byte_count	pointer
)	O
)	O
cgm_emit_partition_control_word	function
(	O
outbuf	pointer
,	O
data_len	int
,	O
data_byte_count	pointer
,	O
byte_count	pointer
)	O
;	O
*	O
(	O
outbuf	pointer
->	O
point	pointer
)	O
=	O
(	O
char	O
)	O
(	O
cgm_unsigned_int	pointer
[	O
i	int
]	O
)	O
;	O
_update_buffer_by_added_bytes	function
(	O
outbuf	pointer
,	O
1	int
)	O
;	O
(	O
*	O
data_byte_count	pointer
)	O
++	O
;	O
(	O
*	O
byte_count	pointer
)	O
++	O
;	O
}	O
break	O
;	O
case	O
CGM_ENCODING_CHARACTER	int
:	O
break	O
;	O
case	O
CGM_ENCODING_CLEAR_TEXT	int
:	O
sprintf	function
(	O
outbuf	pointer
->	O
point	pointer
,	O
" %u"	pointer
,	O
x	double
)	O
;	O
_update_buffer	function
(	O
outbuf	pointer
)	O
;	O
break	O
;	O
}	O
}	O
void	O
_cgm_emit_real_fixed_point	function
(	O
plOutbuf	struct
*	O
outbuf	pointer
,	O
bool	enum
no_partitioning	enum
,	O
int	O
cgm_encoding	int
,	O
double	O
x	double
,	O
int	O
data_len	int
,	O
int	O
*	O
data_byte_count	pointer
,	O
int	O
*	O
byte_count	pointer
)	O
{	O
int	O
x_floor	int
;	O
unsigned	O
int	O
x_frac	int
;	O
int	O
i	int
;	O
unsigned	O
char	O
cgm_int	pointer
[	O
2	int
]	O
,	O
cgm_unsigned_int	pointer
[	O
2	int
]	O
;	O
if	O
(	O
x	double
<	O
-	O
32767.0	int
)	O
x	double
=	O
-	O
32767.0	int
;	O
else	O
if	O
(	O
x	double
>	O
32767.0	int
)	O
x	double
=	O
32767.0	int
;	O
x_floor	int
=	O
(	O
x	double
>=	O
0.0	int
?	O
(	O
int	O
)	O
x	double
:	O
-	O
1	int
-	O
(	O
(	O
int	O
)	O
(	O
-	O
x	double
)	O
)	O
)	O
;	O
x_frac	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
65536	int
*	O
(	O
x	double
-	O
x_floor	int
)	O
)	O
;	O
switch	O
(	O
cgm_encoding	int
)	O
{	O
case	O
CGM_ENCODING_BINARY	int
:	O
default	O
:	O
int_to_cgm_int	function
(	O
x_floor	int
,	O
cgm_int	pointer
,	O
2	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
2	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
no_partitioning	enum
==	O
false	int
&&	O
CGM_BINARY_DATA_PARTITION_BEGINS	O
(	O
data_len	int
,	O
data_byte_count	pointer
)	O
)	O
cgm_emit_partition_control_word	function
(	O
outbuf	pointer
,	O
data_len	int
,	O
data_byte_count	pointer
,	O
byte_count	pointer
)	O
;	O
*	O
(	O
outbuf	pointer
->	O
point	pointer
)	O
=	O
(	O
char	O
)	O
(	O
cgm_int	pointer
[	O
i	int
]	O
)	O
;	O
_update_buffer_by_added_bytes	function
(	O
outbuf	pointer
,	O
1	int
)	O
;	O
(	O
*	O
data_byte_count	pointer
)	O
++	O
;	O
(	O
*	O
byte_count	pointer
)	O
++	O
;	O
}	O
unsigned_int_to_cgm_unsigned_int	function
(	O
x_frac	int
,	O
cgm_unsigned_int	pointer
,	O
2	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
2	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
no_partitioning	enum
==	O
false	int
&&	O
CGM_BINARY_DATA_PARTITION_BEGINS	O
(	O
data_len	int
,	O
data_byte_count	pointer
)	O
)	O
cgm_emit_partition_control_word	function
(	O
outbuf	pointer
,	O
data_len	int
,	O
data_byte_count	pointer
,	O
byte_count	pointer
)	O
;	O
*	O
(	O
outbuf	pointer
->	O
point	pointer
)	O
=	O
(	O
char	O
)	O
(	O
cgm_unsigned_int	pointer
[	O
i	int
]	O
)	O
;	O
_update_buffer_by_added_bytes	function
(	O
outbuf	pointer
,	O
1	int
)	O
;	O
(	O
*	O
data_byte_count	pointer
)	O
++	O
;	O
(	O
*	O
byte_count	pointer
)	O
++	O
;	O
}	O
break	O
;	O
case	O
CGM_ENCODING_CHARACTER	int
:	O
break	O
;	O
case	O
CGM_ENCODING_CLEAR_TEXT	int
:	O
if	O
(	O
x	double
!=	O
0.0	int
)	O
sprintf	function
(	O
outbuf	pointer
->	O
point	pointer
,	O
" %.8f"	pointer
,	O
x	double
)	O
;	O
else	O
sprintf	function
(	O
outbuf	pointer
->	O
point	pointer
,	O
" 0.0"	pointer
)	O
;	O
_update_buffer	function
(	O
outbuf	pointer
)	O
;	O
break	O
;	O
}	O
}	O
static	O
void	O
double_to_ieee_single_precision	function
(	O
double	O
d	double
,	O
unsigned	O
char	O
output	array
[	O
4	int
]	O
)	O
{	O
double	O
min_magnitude	double
,	O
max_magnitude	double
,	O
tmp_power	double
,	O
max_power	double
;	O
bool	enum
got_a_bit	enum
;	O
int	O
i	int
,	O
j	int
;	O
int	O
sign_bit	int
;	O
int	O
mantissa_bits	array
[	O
23	int
]	O
;	O
int	O
exponent_bits	array
[	O
8	int
]	O
;	O
int	O
biased_exponent	int
=	O
0	int
;	O
int	O
bits	array
[	O
256	int
]	O
;	O
int	O
output_bits	array
[	O
32	int
]	O
;	O
min_magnitude	double
=	O
1.0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
127	int
-	O
1	int
;	O
i	int
++	O
)	O
min_magnitude	double
/=	O
2	int
;	O
tmp_power	double
=	O
1.0	int
;	O
max_magnitude	double
=	O
0.0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
254	int
-	O
127	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
>=	O
104	int
)	O
max_magnitude	double
+=	O
tmp_power	double
;	O
tmp_power	double
*=	O
2	int
;	O
}	O
if	O
(	O
d	double
!=	O
d	double
)	O
d	double
=	O
max_magnitude	double
;	O
if	O
(	O
d	double
<	O
0.0	int
)	O
{	O
sign_bit	int
=	O
1	int
;	O
d	double
=	O
-	O
d	double
;	O
}	O
else	O
sign_bit	int
=	O
0	int
;	O
if	O
(	O
d	double
!=	O
0.0	int
&&	O
d	double
<	O
min_magnitude	double
)	O
d	double
=	O
min_magnitude	double
;	O
else	O
if	O
(	O
d	double
>	O
max_magnitude	double
)	O
d	double
=	O
max_magnitude	double
;	O
max_power	double
=	O
1.0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
254	int
-	O
127	int
;	O
i	int
++	O
)	O
max_power	double
*=	O
2	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
256	int
;	O
i	int
++	O
)	O
bits	array
[	O
i	int
]	O
=	O
0	int
;	O
got_a_bit	enum
=	O
false	int
;	O
for	O
(	O
i	int
=	O
254	int
,	O
tmp_power	double
=	O
max_power	double
;	O
i	int
>=	O
1	int
;	O
i	int
--	O
,	O
tmp_power	double
/=	O
2	int
)	O
if	O
(	O
d	double
>=	O
tmp_power	double
)	O
{	O
if	O
(	O
got_a_bit	enum
==	O
false	int
)	O
{	O
biased_exponent	int
=	O
i	int
;	O
got_a_bit	enum
=	O
true	int
;	O
}	O
bits	array
[	O
i	int
]	O
=	O
1	int
;	O
d	double
-=	O
tmp_power	double
;	O
}	O
if	O
(	O
got_a_bit	enum
==	O
false	int
)	O
biased_exponent	int
=	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
23	int
;	O
j	int
++	O
)	O
mantissa_bits	array
[	O
j	int
]	O
=	O
0	int
;	O
if	O
(	O
got_a_bit	enum
==	O
true	int
)	O
for	O
(	O
i	int
=	O
biased_exponent	int
-	O
1	int
,	O
j	int
=	O
0	int
;	O
i	int
>=	O
1	int
&&	O
j	int
<	O
23	int
;	O
i	int
--	O
,	O
j	int
++	O
)	O
mantissa_bits	array
[	O
j	int
]	O
=	O
bits	array
[	O
i	int
]	O
;	O
for	O
(	O
j	int
=	O
7	int
;	O
j	int
>=	O
0	int
;	O
j	int
--	O
)	O
{	O
exponent_bits	array
[	O
j	int
]	O
=	O
biased_exponent	int
%	O
2	int
;	O
biased_exponent	int
/=	O
2	int
;	O
}	O
output_bits	array
[	O
0	int
]	O
=	O
sign_bit	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
8	int
;	O
j	int
++	O
)	O
output_bits	array
[	O
j	int
+	O
1	int
]	O
=	O
exponent_bits	array
[	O
j	int
]	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
23	int
;	O
j	int
++	O
)	O
output_bits	array
[	O
j	int
+	O
9	int
]	O
=	O
mantissa_bits	array
[	O
j	int
]	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
4	int
;	O
j	int
++	O
)	O
output	array
[	O
j	int
]	O
=	O
(	O
unsigned	O
char	O
)	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
32	int
;	O
j	int
++	O
)	O
if	O
(	O
output_bits	array
[	O
j	int
]	O
==	O
1	int
)	O
output	array
[	O
j	int
/	O
8	int
]	O
|=	O
(	O
1	int
<<	O
(	O
(	O
31	int
-	O
j	int
)	O
%	O
8	int
)	O
)	O
;	O
}	O
void	O
_cgm_emit_real_floating_point	function
(	O
plOutbuf	struct
*	O
outbuf	pointer
,	O
bool	enum
no_partitioning	enum
,	O
int	O
cgm_encoding	int
,	O
double	O
x	double
,	O
int	O
data_len	int
,	O
int	O
*	O
data_byte_count	pointer
,	O
int	O
*	O
byte_count	pointer
)	O
{	O
int	O
i	int
;	O
unsigned	O
char	O
cp	array
[	O
4	int
]	O
;	O
switch	O
(	O
cgm_encoding	int
)	O
{	O
case	O
CGM_ENCODING_BINARY	int
:	O
default	O
:	O
double_to_ieee_single_precision	function
(	O
x	double
,	O
cp	array
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
no_partitioning	enum
==	O
false	int
&&	O
CGM_BINARY_DATA_PARTITION_BEGINS	O
(	O
data_len	int
,	O
data_byte_count	pointer
)	O
)	O
cgm_emit_partition_control_word	function
(	O
outbuf	pointer
,	O
data_len	int
,	O
data_byte_count	pointer
,	O
byte_count	pointer
)	O
;	O
*	O
(	O
outbuf	pointer
->	O
point	pointer
)	O
=	O
(	O
char	O
)	O
(	O
cp	array
[	O
i	int
]	O
)	O
;	O
_update_buffer_by_added_bytes	function
(	O
outbuf	pointer
,	O
1	int
)	O
;	O
(	O
*	O
data_byte_count	pointer
)	O
++	O
;	O
(	O
*	O
byte_count	pointer
)	O
++	O
;	O
}	O
break	O
;	O
case	O
CGM_ENCODING_CHARACTER	int
:	O
break	O
;	O
case	O
CGM_ENCODING_CLEAR_TEXT	int
:	O
sprintf	function
(	O
outbuf	pointer
->	O
point	pointer
,	O
" %.8f"	pointer
,	O
x	double
)	O
;	O
_update_buffer	function
(	O
outbuf	pointer
)	O
;	O
break	O
;	O
}	O
}	O
void	O
_cgm_emit_string	function
(	O
plOutbuf	struct
*	O
outbuf	pointer
,	O
bool	enum
no_partitioning	enum
,	O
int	O
cgm_encoding	int
,	O
const	O
char	O
*	O
s	pointer
,	O
int	O
string_length	int
,	O
bool	enum
use_double_quotes	enum
,	O
int	O
data_len	int
,	O
int	O
*	O
data_byte_count	pointer
,	O
int	O
*	O
byte_count	pointer
)	O
{	O
int	O
i	int
,	O
encoded_string_length	int
;	O
const	O
char	O
*	O
sp	pointer
=	O
s	pointer
;	O
char	O
*	O
t	pointer
,	O
*	O
tp	pointer
,	O
c	char
;	O
switch	O
(	O
cgm_encoding	int
)	O
{	O
case	O
CGM_ENCODING_BINARY	int
:	O
default	O
:	O
{	O
encoded_string_length	int
=	O
CGM_BINARY_BYTES_PER_STRING	O
(	O
string_length	int
)	O
;	O
tp	pointer
=	O
t	pointer
=	O
(	O
char	O
*	O
)	O
_pl_xmalloc	function
(	O
encoded_string_length	int
*	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
if	O
(	O
string_length	int
<=	O
254	int
)	O
{	O
*	O
tp	pointer
++	O
=	O
(	O
char	O
)	O
(	O
unsigned	O
char	O
)	O
string_length	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
string_length	int
;	O
i	int
++	O
)	O
*	O
tp	pointer
++	O
=	O
*	O
sp	pointer
++	O
;	O
}	O
else	O
{	O
*	O
tp	pointer
++	O
=	O
(	O
char	O
)	O
255	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
string_length	int
;	O
i	int
++	O
,	O
sp	pointer
++	O
)	O
{	O
if	O
(	O
i	int
%	O
CGM_STRING_PARTITION_SIZE	int
==	O
0	int
)	O
{	O
int	O
bytes_remaining	int
=	O
string_length	int
-	O
i	int
;	O
int	O
string_header_word	int
;	O
if	O
(	O
bytes_remaining	int
<=	O
CGM_STRING_PARTITION_SIZE	int
)	O
string_header_word	int
=	O
bytes_remaining	int
;	O
else	O
{	O
string_header_word	int
=	O
(	O
1	int
<<	O
15	int
)	O
;	O
string_header_word	int
|=	O
CGM_STRING_PARTITION_SIZE	int
;	O
}	O
*	O
tp	pointer
++	O
=	O
(	O
char	O
)	O
(	O
(	O
string_header_word	int
>>	O
8	int
)	O
&	O
0377	int
)	O
;	O
*	O
tp	pointer
++	O
=	O
(	O
char	O
)	O
(	O
string_header_word	int
&	O
0377	int
)	O
;	O
}	O
*	O
tp	pointer
++	O
=	O
*	O
sp	pointer
;	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
encoded_string_length	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
no_partitioning	enum
==	O
false	int
&&	O
CGM_BINARY_DATA_PARTITION_BEGINS	O
(	O
data_len	int
,	O
data_byte_count	pointer
)	O
)	O
cgm_emit_partition_control_word	function
(	O
outbuf	pointer
,	O
data_len	int
,	O
data_byte_count	pointer
,	O
byte_count	pointer
)	O
;	O
*	O
(	O
outbuf	pointer
->	O
point	pointer
)	O
=	O
t	pointer
[	O
i	int
]	O
;	O
_update_buffer_by_added_bytes	function
(	O
outbuf	pointer
,	O
1	int
)	O
;	O
(	O
*	O
data_byte_count	pointer
)	O
++	O
;	O
(	O
*	O
byte_count	pointer
)	O
++	O
;	O
}	O
free	function
(	O
t	pointer
)	O
;	O
}	O
break	O
;	O
case	O
CGM_ENCODING_CHARACTER	int
:	O
break	O
;	O
case	O
CGM_ENCODING_CLEAR_TEXT	int
:	O
{	O
encoded_string_length	int
=	O
2	int
*	O
string_length	int
+	O
3	int
;	O
tp	pointer
=	O
t	pointer
=	O
(	O
char	O
*	O
)	O
_pl_xmalloc	function
(	O
(	O
encoded_string_length	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
*	O
tp	pointer
++	O
=	O
' '	O
;	O
*	O
tp	pointer
++	O
=	O
(	O
use_double_quotes	enum
?	O
'"'	O
:	O
'\''	O
)	O
;	O
while	O
(	O
(	O
c	char
=	O
*	O
sp	pointer
++	O
)	O
!=	O
'\0'	O
)	O
{	O
if	O
(	O
(	O
(	O
use_double_quotes	enum
==	O
true	int
)	O
&&	O
c	char
==	O
'"'	O
)	O
||	O
(	O
(	O
use_double_quotes	enum
==	O
false	int
)	O
&&	O
c	char
==	O
'\''	O
)	O
)	O
*	O
tp	pointer
++	O
=	O
c	char
;	O
*	O
tp	pointer
++	O
=	O
c	char
;	O
}	O
*	O
tp	pointer
++	O
=	O
(	O
use_double_quotes	enum
?	O
'"'	O
:	O
'\''	O
)	O
;	O
*	O
tp	pointer
++	O
=	O
'\0'	O
;	O
strcpy	function
(	O
outbuf	pointer
->	O
point	pointer
,	O
t	pointer
)	O
;	O
_update_buffer	function
(	O
outbuf	pointer
)	O
;	O
free	function
(	O
t	pointer
)	O
;	O
}	O
break	O
;	O
}	O
}	O
void	O
_cgm_emit_command_terminator	function
(	O
plOutbuf	struct
*	O
outbuf	pointer
,	O
int	O
cgm_encoding	int
,	O
int	O
*	O
byte_count	pointer
)	O
{	O
switch	O
(	O
cgm_encoding	int
)	O
{	O
case	O
CGM_ENCODING_BINARY	int
:	O
default	O
:	O
if	O
(	O
(	O
*	O
byte_count	pointer
)	O
%	O
2	int
==	O
1	int
)	O
{	O
*	O
(	O
outbuf	pointer
->	O
point	pointer
)	O
=	O
'\0'	O
;	O
_update_buffer_by_added_bytes	function
(	O
outbuf	pointer
,	O
1	int
)	O
;	O
(	O
*	O
byte_count	pointer
)	O
++	O
;	O
}	O
break	O
;	O
case	O
CGM_ENCODING_CHARACTER	int
:	O
break	O
;	O
case	O
CGM_ENCODING_CLEAR_TEXT	int
:	O
strcpy	function
(	O
outbuf	pointer
->	O
point	pointer
,	O
";\n"	pointer
)	O
;	O
_update_buffer	function
(	O
outbuf	pointer
)	O
;	O
break	O
;	O
}	O
}	O
