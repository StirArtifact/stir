char	O
doopt	array
[	O
]	O
=	O
{	O
IAC	int
,	O
DO	int
,	O
'%'	O
,	O
'c'	O
,	O
0	int
}	O
;	O
char	O
dont	array
[	O
]	O
=	O
{	O
IAC	int
,	O
DONT	int
,	O
'%'	O
,	O
'c'	O
,	O
0	int
}	O
;	O
char	O
will	array
[	O
]	O
=	O
{	O
IAC	int
,	O
WILL	int
,	O
'%'	O
,	O
'c'	O
,	O
0	int
}	O
;	O
char	O
wont	array
[	O
]	O
=	O
{	O
IAC	int
,	O
WONT	int
,	O
'%'	O
,	O
'c'	O
,	O
0	int
}	O
;	O
int	O
not42	int
=	O
1	int
;	O
unsigned	O
char	O
subbuffer	array
[	O
512	int
]	O
,	O
*	O
subpointer	pointer
=	O
subbuffer	array
,	O
*	O
subend	pointer
=	O
subbuffer	array
;	O
static	O
void	O
send_eof	function
(	O
void	O
)	O
{	O
init_termbuf	function
(	O
)	O
;	O
term_send_eof	function
(	O
)	O
;	O
pty_output_byte	function
(	O
slctab	array
[	O
SLC_EOF	int
]	O
.	O
sptr	pointer
?	O
(	O
unsigned	O
char	O
)	O
*	O
slctab	array
[	O
SLC_EOF	int
]	O
.	O
sptr	pointer
:	O
'\004'	O
)	O
;	O
}	O
static	O
void	O
recv_ayt	function
(	O
void	O
)	O
{	O
net_output_data	function
(	O
"\r\n[Yes]\r\n"	pointer
)	O
;	O
}	O
static	O
void	O
send_susp	function
(	O
void	O
)	O
{	O
ptyflush	function
(	O
)	O
;	O
pty_output_byte	function
(	O
slctab	array
[	O
SLC_SUSP	int
]	O
.	O
sptr	pointer
?	O
(	O
unsigned	O
char	O
)	O
*	O
slctab	array
[	O
SLC_SUSP	int
]	O
.	O
sptr	pointer
:	O
'\032'	O
)	O
;	O
}	O
static	O
void	O
send_brk	function
(	O
void	O
)	O
{	O
ptyflush	function
(	O
)	O
;	O
init_termbuf	function
(	O
)	O
;	O
pty_output_byte	function
(	O
slctab	array
[	O
SLC_ABORT	int
]	O
.	O
sptr	pointer
?	O
(	O
unsigned	O
char	O
)	O
*	O
slctab	array
[	O
SLC_ABORT	int
]	O
.	O
sptr	pointer
:	O
'\034'	O
)	O
;	O
}	O
static	O
void	O
send_intr	function
(	O
void	O
)	O
{	O
ptyflush	function
(	O
)	O
;	O
init_termbuf	function
(	O
)	O
;	O
pty_output_byte	function
(	O
slctab	array
[	O
SLC_IP	int
]	O
.	O
sptr	pointer
?	O
(	O
unsigned	O
char	O
)	O
*	O
slctab	array
[	O
SLC_IP	int
]	O
.	O
sptr	pointer
:	O
'\177'	O
)	O
;	O
}	O
void	O
telrcv	function
(	O
void	O
)	O
{	O
register	O
int	O
c	int
;	O
static	O
int	O
state	pointer
=	O
TS_DATA	int
;	O
while	O
(	O
(	O
net_input_level	function
(	O
)	O
>	O
0	int
)	O
&	O
!	O
pty_buffer_is_full	function
(	O
)	O
)	O
{	O
c	int
=	O
net_get_char	function
(	O
0	int
)	O
;	O
switch	O
(	O
state	pointer
)	O
{	O
case	O
TS_CR	int
:	O
state	pointer
=	O
TS_DATA	int
;	O
if	O
(	O
(	O
c	int
==	O
0	int
)	O
||	O
(	O
c	int
==	O
'\n'	O
)	O
)	O
break	O
;	O
case	O
TS_DATA	int
:	O
if	O
(	O
c	int
==	O
IAC	int
)	O
{	O
state	pointer
=	O
TS_IAC	int
;	O
break	O
;	O
}	O
if	O
(	O
(	O
c	int
==	O
'\r'	O
)	O
&&	O
his_state_is_wont	O
(	O
TELOPT_BINARY	int
)	O
)	O
{	O
int	O
nc	int
=	O
net_get_char	function
(	O
1	int
)	O
;	O
if	O
(	O
linemode	int
&&	O
net_input_level	function
(	O
)	O
>	O
0	int
&&	O
(	O
(	O
'\n'	O
==	O
nc	int
)	O
||	O
(	O
!	O
nc	int
&&	O
tty_iscrnl	function
(	O
)	O
)	O
)	O
)	O
{	O
net_get_char	function
(	O
0	int
)	O
;	O
c	int
=	O
'\n'	O
;	O
}	O
else	O
{	O
state	pointer
=	O
TS_CR	int
;	O
}	O
}	O
pty_output_byte	function
(	O
c	int
)	O
;	O
break	O
;	O
case	O
TS_IAC	int
:	O
gotiac	O
:	O
switch	O
(	O
c	int
)	O
{	O
case	O
IP	int
:	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
printoption	function
(	O
"td: recv IAC"	pointer
,	O
c	int
)	O
)	O
;	O
send_intr	function
(	O
)	O
;	O
break	O
;	O
case	O
BREAK	int
:	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
printoption	function
(	O
"td: recv IAC"	pointer
,	O
c	int
)	O
)	O
;	O
send_brk	function
(	O
)	O
;	O
break	O
;	O
case	O
AYT	int
:	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
printoption	function
(	O
"td: recv IAC"	pointer
,	O
c	int
)	O
)	O
;	O
recv_ayt	function
(	O
)	O
;	O
break	O
;	O
case	O
AO	int
:	O
{	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
printoption	function
(	O
"td: recv IAC"	pointer
,	O
c	int
)	O
)	O
;	O
ptyflush	function
(	O
)	O
;	O
init_termbuf	function
(	O
)	O
;	O
if	O
(	O
slctab	array
[	O
SLC_AO	int
]	O
.	O
sptr	pointer
&&	O
*	O
slctab	array
[	O
SLC_AO	int
]	O
.	O
sptr	pointer
!=	O
(	O
cc_t	char
)	O
(	O
_POSIX_VDISABLE	char
)	O
)	O
pty_output_byte	function
(	O
*	O
slctab	array
[	O
SLC_AO	int
]	O
.	O
sptr	pointer
)	O
;	O
netclear	function
(	O
)	O
;	O
net_output_data	function
(	O
"%c%c"	pointer
,	O
IAC	int
,	O
DM	int
)	O
;	O
set_neturg	function
(	O
)	O
;	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
printoption	function
(	O
"td: send IAC"	pointer
,	O
DM	int
)	O
)	O
;	O
break	O
;	O
}	O
case	O
EC	int
:	O
case	O
EL	int
:	O
{	O
cc_t	char
ch	char
;	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
printoption	function
(	O
"td: recv IAC"	pointer
,	O
c	int
)	O
)	O
;	O
ptyflush	function
(	O
)	O
;	O
init_termbuf	function
(	O
)	O
;	O
if	O
(	O
c	int
==	O
EC	int
)	O
ch	char
=	O
*	O
slctab	array
[	O
SLC_EC	int
]	O
.	O
sptr	pointer
;	O
else	O
ch	char
=	O
*	O
slctab	array
[	O
SLC_EL	int
]	O
.	O
sptr	pointer
;	O
if	O
(	O
ch	char
!=	O
(	O
cc_t	char
)	O
(	O
_POSIX_VDISABLE	char
)	O
)	O
pty_output_byte	function
(	O
(	O
unsigned	O
char	O
)	O
ch	char
)	O
;	O
break	O
;	O
}	O
case	O
DM	int
:	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
printoption	function
(	O
"td: recv IAC"	pointer
,	O
c	int
)	O
)	O
;	O
SYNCHing	int
=	O
stilloob	function
(	O
net	int
)	O
;	O
settimer	O
(	O
gotDM	int
)	O
;	O
break	O
;	O
case	O
SB	int
:	O
state	pointer
=	O
TS_SB	int
;	O
SB_CLEAR	O
(	O
)	O
;	O
continue	O
;	O
case	O
WILL	int
:	O
state	pointer
=	O
TS_WILL	int
;	O
continue	O
;	O
case	O
WONT	int
:	O
state	pointer
=	O
TS_WONT	int
;	O
continue	O
;	O
case	O
DO	int
:	O
state	pointer
=	O
TS_DO	int
;	O
continue	O
;	O
case	O
DONT	int
:	O
state	pointer
=	O
TS_DONT	int
;	O
continue	O
;	O
case	O
EOR	int
:	O
if	O
(	O
his_state_is_will	O
(	O
TELOPT_EOR	int
)	O
)	O
send_eof	function
(	O
)	O
;	O
break	O
;	O
case	O
xEOF	int
:	O
send_eof	function
(	O
)	O
;	O
break	O
;	O
case	O
SUSP	int
:	O
send_susp	function
(	O
)	O
;	O
break	O
;	O
case	O
ABORT	int
:	O
send_brk	function
(	O
)	O
;	O
break	O
;	O
case	O
IAC	int
:	O
pty_output_byte	function
(	O
c	int
)	O
;	O
break	O
;	O
}	O
state	pointer
=	O
TS_DATA	int
;	O
break	O
;	O
case	O
TS_SB	int
:	O
if	O
(	O
c	int
==	O
IAC	int
)	O
state	pointer
=	O
TS_SE	int
;	O
else	O
SB_ACCUM	O
(	O
c	int
)	O
;	O
break	O
;	O
case	O
TS_SE	int
:	O
if	O
(	O
c	int
!=	O
SE	int
)	O
{	O
if	O
(	O
c	int
!=	O
IAC	int
)	O
{	O
SB_ACCUM	O
(	O
IAC	int
)	O
;	O
SB_ACCUM	O
(	O
c	int
)	O
;	O
subpointer	pointer
-=	O
2	int
;	O
SB_TERM	O
(	O
)	O
;	O
suboption	function
(	O
)	O
;	O
state	pointer
=	O
TS_IAC	int
;	O
goto	O
gotiac	O
;	O
}	O
SB_ACCUM	O
(	O
c	int
)	O
;	O
state	pointer
=	O
TS_SB	int
;	O
}	O
else	O
{	O
SB_ACCUM	O
(	O
IAC	int
)	O
;	O
SB_ACCUM	O
(	O
SE	int
)	O
;	O
subpointer	pointer
-=	O
2	int
;	O
SB_TERM	O
(	O
)	O
;	O
suboption	function
(	O
)	O
;	O
state	pointer
=	O
TS_DATA	int
;	O
}	O
break	O
;	O
case	O
TS_WILL	int
:	O
willoption	function
(	O
c	int
)	O
;	O
state	pointer
=	O
TS_DATA	int
;	O
continue	O
;	O
case	O
TS_WONT	int
:	O
wontoption	function
(	O
c	int
)	O
;	O
state	pointer
=	O
TS_DATA	int
;	O
continue	O
;	O
case	O
TS_DO	int
:	O
dooption	function
(	O
c	int
)	O
;	O
state	pointer
=	O
TS_DATA	int
;	O
continue	O
;	O
case	O
TS_DONT	int
:	O
dontoption	function
(	O
c	int
)	O
;	O
state	pointer
=	O
TS_DATA	int
;	O
continue	O
;	O
default	O
:	O
syslog	function
(	O
LOG_ERR	int
,	O
"telnetd: panic state=%d\n"	pointer
,	O
state	pointer
)	O
;	O
printf	function
(	O
"telnetd: panic state=%d\n"	pointer
,	O
state	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
}	O
void	O
send_do	function
(	O
int	O
option	int
,	O
int	O
init	pointer
)	O
{	O
if	O
(	O
init	pointer
)	O
{	O
if	O
(	O
(	O
do_dont_resp	array
[	O
option	int
]	O
==	O
0	int
&&	O
his_state_is_will	O
(	O
option	int
)	O
)	O
||	O
his_want_state_is_will	O
(	O
option	int
)	O
)	O
return	O
;	O
if	O
(	O
option	int
==	O
TELOPT_TM	int
)	O
set_his_want_state_wont	O
(	O
option	int
)	O
;	O
else	O
set_his_want_state_will	O
(	O
option	int
)	O
;	O
do_dont_resp	array
[	O
option	int
]	O
++	O
;	O
}	O
net_output_data	function
(	O
doopt	array
,	O
option	int
)	O
;	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
printoption	function
(	O
"td: send do"	pointer
,	O
option	int
)	O
)	O
;	O
}	O
extern	O
void	O
doclientstat	function
(	O
void	O
)	O
;	O
void	O
willoption	function
(	O
int	O
option	int
)	O
{	O
int	O
changeok	int
=	O
0	int
;	O
void	O
(	O
*	O
func	int
)	O
(	O
)	O
=	O
0	int
;	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
printoption	function
(	O
"td: recv will"	pointer
,	O
option	int
)	O
)	O
;	O
if	O
(	O
do_dont_resp	array
[	O
option	int
]	O
)	O
{	O
do_dont_resp	array
[	O
option	int
]	O
--	O
;	O
if	O
(	O
do_dont_resp	array
[	O
option	int
]	O
&&	O
his_state_is_will	O
(	O
option	int
)	O
)	O
do_dont_resp	array
[	O
option	int
]	O
--	O
;	O
}	O
if	O
(	O
do_dont_resp	array
[	O
option	int
]	O
==	O
0	int
)	O
{	O
if	O
(	O
his_want_state_is_wont	O
(	O
option	int
)	O
)	O
{	O
switch	O
(	O
option	int
)	O
{	O
case	O
TELOPT_BINARY	int
:	O
init_termbuf	function
(	O
)	O
;	O
tty_binaryin	function
(	O
1	int
)	O
;	O
set_termbuf	function
(	O
)	O
;	O
changeok	int
++	O
;	O
break	O
;	O
case	O
TELOPT_ECHO	int
:	O
not42	int
=	O
0	int
;	O
break	O
;	O
case	O
TELOPT_TM	int
:	O
if	O
(	O
lmodetype	int
<	O
KLUDGE_LINEMODE	int
)	O
{	O
lmodetype	int
=	O
KLUDGE_LINEMODE	int
;	O
clientstat	function
(	O
TELOPT_LINEMODE	int
,	O
WILL	int
,	O
0	int
)	O
;	O
send_wont	function
(	O
TELOPT_SGA	int
,	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
lmodetype	int
==	O
NO_AUTOKLUDGE	int
)	O
lmodetype	int
=	O
KLUDGE_OK	int
;	O
return	O
;	O
case	O
TELOPT_LFLOW	int
:	O
slctab	array
[	O
SLC_XON	int
]	O
.	O
defset	struct
.	O
flag	char
&=	O
~	O
SLC_LEVELBITS	int
;	O
slctab	array
[	O
SLC_XON	int
]	O
.	O
defset	struct
.	O
flag	char
|=	O
SLC_DEFAULT	int
;	O
slctab	array
[	O
SLC_XOFF	int
]	O
.	O
defset	struct
.	O
flag	char
&=	O
~	O
SLC_LEVELBITS	int
;	O
slctab	array
[	O
SLC_XOFF	int
]	O
.	O
defset	struct
.	O
flag	char
|=	O
SLC_DEFAULT	int
;	O
case	O
TELOPT_TTYPE	int
:	O
case	O
TELOPT_SGA	int
:	O
case	O
TELOPT_NAWS	int
:	O
case	O
TELOPT_TSPEED	int
:	O
case	O
TELOPT_XDISPLOC	int
:	O
case	O
TELOPT_NEW_ENVIRON	int
:	O
case	O
TELOPT_OLD_ENVIRON	int
:	O
changeok	int
++	O
;	O
break	O
;	O
case	O
TELOPT_LINEMODE	int
:	O
lmodetype	int
=	O
REAL_LINEMODE	int
;	O
func	int
=	O
doclientstat	function
;	O
changeok	int
++	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
changeok	int
)	O
{	O
set_his_want_state_will	O
(	O
option	int
)	O
;	O
send_do	function
(	O
option	int
,	O
0	int
)	O
;	O
}	O
else	O
{	O
do_dont_resp	array
[	O
option	int
]	O
++	O
;	O
send_dont	function
(	O
option	int
,	O
0	int
)	O
;	O
}	O
}	O
else	O
{	O
switch	O
(	O
option	int
)	O
{	O
case	O
TELOPT_ECHO	int
:	O
not42	int
=	O
0	int
;	O
send_dont	function
(	O
option	int
,	O
1	int
)	O
;	O
break	O
;	O
case	O
TELOPT_LINEMODE	int
:	O
lmodetype	int
=	O
REAL_LINEMODE	int
;	O
func	int
=	O
doclientstat	function
;	O
break	O
;	O
case	O
TELOPT_LFLOW	int
:	O
func	int
=	O
flowstat	function
;	O
break	O
;	O
}	O
}	O
}	O
set_his_state_will	O
(	O
option	int
)	O
;	O
if	O
(	O
func	int
)	O
(	O
*	O
func	int
)	O
(	O
)	O
;	O
}	O
void	O
send_dont	function
(	O
int	O
option	int
,	O
int	O
init	pointer
)	O
{	O
if	O
(	O
init	pointer
)	O
{	O
if	O
(	O
(	O
do_dont_resp	array
[	O
option	int
]	O
==	O
0	int
&&	O
his_state_is_wont	O
(	O
option	int
)	O
)	O
||	O
his_want_state_is_wont	O
(	O
option	int
)	O
)	O
return	O
;	O
set_his_want_state_wont	O
(	O
option	int
)	O
;	O
do_dont_resp	array
[	O
option	int
]	O
++	O
;	O
}	O
net_output_data	function
(	O
dont	array
,	O
option	int
)	O
;	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
printoption	function
(	O
"td: send dont"	pointer
,	O
option	int
)	O
)	O
;	O
}	O
void	O
wontoption	function
(	O
int	O
option	int
)	O
{	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
printoption	function
(	O
"td: recv wont"	pointer
,	O
option	int
)	O
)	O
;	O
if	O
(	O
do_dont_resp	array
[	O
option	int
]	O
)	O
{	O
do_dont_resp	array
[	O
option	int
]	O
--	O
;	O
if	O
(	O
do_dont_resp	array
[	O
option	int
]	O
&&	O
his_state_is_wont	O
(	O
option	int
)	O
)	O
do_dont_resp	array
[	O
option	int
]	O
--	O
;	O
}	O
if	O
(	O
do_dont_resp	array
[	O
option	int
]	O
==	O
0	int
)	O
{	O
if	O
(	O
his_want_state_is_will	O
(	O
option	int
)	O
)	O
{	O
switch	O
(	O
option	int
)	O
{	O
case	O
TELOPT_ECHO	int
:	O
not42	int
=	O
1	int
;	O
break	O
;	O
case	O
TELOPT_BINARY	int
:	O
init_termbuf	function
(	O
)	O
;	O
tty_binaryin	function
(	O
0	int
)	O
;	O
set_termbuf	function
(	O
)	O
;	O
break	O
;	O
case	O
TELOPT_LINEMODE	int
:	O
if	O
(	O
lmodetype	int
!=	O
REAL_LINEMODE	int
)	O
break	O
;	O
clientstat	function
(	O
TELOPT_LINEMODE	int
,	O
WONT	int
,	O
0	int
)	O
;	O
break	O
;	O
case	O
TELOPT_TM	int
:	O
set_his_want_state_wont	O
(	O
TELOPT_TM	int
)	O
;	O
return	O
;	O
case	O
TELOPT_LFLOW	int
:	O
slctab	array
[	O
SLC_XON	int
]	O
.	O
defset	struct
.	O
flag	char
&=	O
~	O
SLC_LEVELBITS	int
;	O
slctab	array
[	O
SLC_XON	int
]	O
.	O
defset	struct
.	O
flag	char
|=	O
SLC_CANTCHANGE	int
;	O
slctab	array
[	O
SLC_XOFF	int
]	O
.	O
defset	struct
.	O
flag	char
&=	O
~	O
SLC_LEVELBITS	int
;	O
slctab	array
[	O
SLC_XOFF	int
]	O
.	O
defset	struct
.	O
flag	char
|=	O
SLC_CANTCHANGE	int
;	O
break	O
;	O
case	O
TELOPT_TTYPE	int
:	O
settimer	O
(	O
ttypesubopt	int
)	O
;	O
break	O
;	O
case	O
TELOPT_TSPEED	int
:	O
settimer	O
(	O
tspeedsubopt	int
)	O
;	O
break	O
;	O
case	O
TELOPT_XDISPLOC	int
:	O
settimer	O
(	O
xdisplocsubopt	int
)	O
;	O
break	O
;	O
case	O
TELOPT_OLD_ENVIRON	int
:	O
settimer	O
(	O
oenvironsubopt	int
)	O
;	O
break	O
;	O
case	O
TELOPT_NEW_ENVIRON	int
:	O
settimer	O
(	O
environsubopt	int
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
set_his_want_state_wont	O
(	O
option	int
)	O
;	O
if	O
(	O
his_state_is_will	O
(	O
option	int
)	O
)	O
send_dont	function
(	O
option	int
,	O
0	int
)	O
;	O
}	O
else	O
{	O
switch	O
(	O
option	int
)	O
{	O
case	O
TELOPT_TM	int
:	O
if	O
(	O
lmodetype	int
<	O
NO_AUTOKLUDGE	int
)	O
{	O
lmodetype	int
=	O
NO_LINEMODE	int
;	O
clientstat	function
(	O
TELOPT_LINEMODE	int
,	O
WONT	int
,	O
0	int
)	O
;	O
send_will	function
(	O
TELOPT_SGA	int
,	O
1	int
)	O
;	O
send_will	function
(	O
TELOPT_ECHO	int
,	O
1	int
)	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
}	O
set_his_state_wont	O
(	O
option	int
)	O
;	O
}	O
void	O
send_will	function
(	O
int	O
option	int
,	O
int	O
init	pointer
)	O
{	O
if	O
(	O
init	pointer
)	O
{	O
if	O
(	O
(	O
will_wont_resp	array
[	O
option	int
]	O
==	O
0	int
&&	O
my_state_is_will	O
(	O
option	int
)	O
)	O
||	O
my_want_state_is_will	O
(	O
option	int
)	O
)	O
return	O
;	O
set_my_want_state_will	O
(	O
option	int
)	O
;	O
will_wont_resp	array
[	O
option	int
]	O
++	O
;	O
}	O
net_output_data	function
(	O
will	array
,	O
option	int
)	O
;	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
printoption	function
(	O
"td: send will"	pointer
,	O
option	int
)	O
)	O
;	O
}	O
void	O
dooption	function
(	O
int	O
option	int
)	O
{	O
int	O
changeok	int
=	O
0	int
;	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
printoption	function
(	O
"td: recv do"	pointer
,	O
option	int
)	O
)	O
;	O
if	O
(	O
will_wont_resp	array
[	O
option	int
]	O
)	O
{	O
will_wont_resp	array
[	O
option	int
]	O
--	O
;	O
if	O
(	O
will_wont_resp	array
[	O
option	int
]	O
&&	O
my_state_is_will	O
(	O
option	int
)	O
)	O
will_wont_resp	array
[	O
option	int
]	O
--	O
;	O
}	O
if	O
(	O
(	O
will_wont_resp	array
[	O
option	int
]	O
==	O
0	int
)	O
&&	O
(	O
my_want_state_is_wont	O
(	O
option	int
)	O
)	O
)	O
{	O
switch	O
(	O
option	int
)	O
{	O
case	O
TELOPT_ECHO	int
:	O
if	O
(	O
lmodetype	int
==	O
NO_LINEMODE	int
)	O
{	O
init_termbuf	function
(	O
)	O
;	O
tty_setecho	function
(	O
1	int
)	O
;	O
set_termbuf	function
(	O
)	O
;	O
}	O
changeok	int
++	O
;	O
break	O
;	O
case	O
TELOPT_BINARY	int
:	O
init_termbuf	function
(	O
)	O
;	O
tty_binaryout	function
(	O
1	int
)	O
;	O
set_termbuf	function
(	O
)	O
;	O
changeok	int
++	O
;	O
break	O
;	O
case	O
TELOPT_SGA	int
:	O
if	O
(	O
lmodetype	int
==	O
KLUDGE_LINEMODE	int
)	O
{	O
clientstat	function
(	O
TELOPT_LINEMODE	int
,	O
WONT	int
,	O
0	int
)	O
;	O
if	O
(	O
linemode	int
)	O
break	O
;	O
}	O
changeok	int
++	O
;	O
break	O
;	O
case	O
TELOPT_STATUS	int
:	O
changeok	int
++	O
;	O
break	O
;	O
case	O
TELOPT_TM	int
:	O
send_will	function
(	O
option	int
,	O
0	int
)	O
;	O
set_my_want_state_wont	O
(	O
option	int
)	O
;	O
set_my_state_wont	O
(	O
option	int
)	O
;	O
return	O
;	O
case	O
TELOPT_LOGOUT	int
:	O
set_my_want_state_will	O
(	O
TELOPT_LOGOUT	int
)	O
;	O
send_will	function
(	O
TELOPT_LOGOUT	int
,	O
0	int
)	O
;	O
set_my_state_will	O
(	O
TELOPT_LOGOUT	int
)	O
;	O
netflush	function
(	O
)	O
;	O
cleanup	pointer
(	O
0	int
)	O
;	O
break	O
;	O
case	O
TELOPT_LINEMODE	int
:	O
case	O
TELOPT_TTYPE	int
:	O
case	O
TELOPT_NAWS	int
:	O
case	O
TELOPT_TSPEED	int
:	O
case	O
TELOPT_LFLOW	int
:	O
case	O
TELOPT_XDISPLOC	int
:	O
case	O
TELOPT_OLD_ENVIRON	int
:	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
changeok	int
)	O
{	O
set_my_want_state_will	O
(	O
option	int
)	O
;	O
send_will	function
(	O
option	int
,	O
0	int
)	O
;	O
}	O
else	O
{	O
will_wont_resp	array
[	O
option	int
]	O
++	O
;	O
send_wont	function
(	O
option	int
,	O
0	int
)	O
;	O
}	O
}	O
set_my_state_will	O
(	O
option	int
)	O
;	O
}	O
void	O
send_wont	function
(	O
int	O
option	int
,	O
int	O
init	pointer
)	O
{	O
if	O
(	O
init	pointer
)	O
{	O
if	O
(	O
(	O
will_wont_resp	array
[	O
option	int
]	O
==	O
0	int
&&	O
my_state_is_wont	O
(	O
option	int
)	O
)	O
||	O
my_want_state_is_wont	O
(	O
option	int
)	O
)	O
return	O
;	O
set_my_want_state_wont	O
(	O
option	int
)	O
;	O
will_wont_resp	array
[	O
option	int
]	O
++	O
;	O
}	O
net_output_data	function
(	O
wont	array
,	O
option	int
)	O
;	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
printoption	function
(	O
"td: send wont"	pointer
,	O
option	int
)	O
)	O
;	O
}	O
void	O
dontoption	function
(	O
int	O
option	int
)	O
{	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
printoption	function
(	O
"td: recv dont"	pointer
,	O
option	int
)	O
)	O
;	O
if	O
(	O
will_wont_resp	array
[	O
option	int
]	O
)	O
{	O
will_wont_resp	array
[	O
option	int
]	O
--	O
;	O
if	O
(	O
will_wont_resp	array
[	O
option	int
]	O
&&	O
my_state_is_wont	O
(	O
option	int
)	O
)	O
will_wont_resp	array
[	O
option	int
]	O
--	O
;	O
}	O
if	O
(	O
(	O
will_wont_resp	array
[	O
option	int
]	O
==	O
0	int
)	O
&&	O
(	O
my_want_state_is_will	O
(	O
option	int
)	O
)	O
)	O
{	O
switch	O
(	O
option	int
)	O
{	O
case	O
TELOPT_BINARY	int
:	O
init_termbuf	function
(	O
)	O
;	O
tty_binaryout	function
(	O
0	int
)	O
;	O
set_termbuf	function
(	O
)	O
;	O
break	O
;	O
case	O
TELOPT_ECHO	int
:	O
if	O
(	O
(	O
lmodetype	int
!=	O
REAL_LINEMODE	int
)	O
&&	O
(	O
lmodetype	int
!=	O
KLUDGE_LINEMODE	int
)	O
)	O
{	O
init_termbuf	function
(	O
)	O
;	O
tty_setecho	function
(	O
0	int
)	O
;	O
set_termbuf	function
(	O
)	O
;	O
}	O
break	O
;	O
case	O
TELOPT_SGA	int
:	O
if	O
(	O
(	O
lmodetype	int
==	O
KLUDGE_LINEMODE	int
)	O
||	O
(	O
lmodetype	int
==	O
KLUDGE_OK	int
)	O
)	O
{	O
lmodetype	int
=	O
KLUDGE_LINEMODE	int
;	O
clientstat	function
(	O
TELOPT_LINEMODE	int
,	O
WILL	int
,	O
0	int
)	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
set_my_want_state_wont	O
(	O
option	int
)	O
;	O
if	O
(	O
my_state_is_will	O
(	O
option	int
)	O
)	O
send_wont	function
(	O
option	int
,	O
0	int
)	O
;	O
}	O
set_my_state_wont	O
(	O
option	int
)	O
;	O
}	O
void	O
suboption	function
(	O
void	O
)	O
{	O
register	O
int	O
subchar	int
;	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
printsub	pointer
(	O
'<'	O
,	O
subpointer	pointer
,	O
SB_LEN	O
(	O
)	O
+	O
2	int
)	O
)	O
;	O
subchar	int
=	O
SB_GET	O
(	O
)	O
;	O
switch	O
(	O
subchar	int
)	O
{	O
case	O
TELOPT_TSPEED	int
:	O
{	O
register	O
int	O
xspeed	int
,	O
rspeed	int
;	O
if	O
(	O
his_state_is_wont	O
(	O
TELOPT_TSPEED	int
)	O
)	O
break	O
;	O
settimer	O
(	O
tspeedsubopt	int
)	O
;	O
if	O
(	O
SB_EOF	O
(	O
)	O
||	O
SB_GET	O
(	O
)	O
!=	O
TELQUAL_IS	int
)	O
return	O
;	O
xspeed	int
=	O
atoi	function
(	O
(	O
char	O
*	O
)	O
subpointer	pointer
)	O
;	O
while	O
(	O
SB_GET	O
(	O
)	O
!=	O
','	O
&&	O
!	O
SB_EOF	O
(	O
)	O
)	O
;	O
if	O
(	O
SB_EOF	O
(	O
)	O
)	O
return	O
;	O
rspeed	int
=	O
atoi	function
(	O
(	O
char	O
*	O
)	O
subpointer	pointer
)	O
;	O
clientstat	function
(	O
TELOPT_TSPEED	int
,	O
xspeed	int
,	O
rspeed	int
)	O
;	O
break	O
;	O
}	O
case	O
TELOPT_TTYPE	int
:	O
{	O
static	O
struct	O
obstack	struct
stk	struct
;	O
char	O
*	O
p	pointer
;	O
if	O
(	O
his_state_is_wont	O
(	O
TELOPT_TTYPE	int
)	O
)	O
break	O
;	O
settimer	O
(	O
ttypesubopt	int
)	O
;	O
if	O
(	O
SB_EOF	O
(	O
)	O
||	O
SB_GET	O
(	O
)	O
!=	O
TELQUAL_IS	int
)	O
return	O
;	O
free	function
(	O
terminaltype	pointer
)	O
;	O
obstack_init	O
(	O
&	O
stk	struct
)	O
;	O
while	O
(	O
!	O
SB_EOF	O
(	O
)	O
)	O
{	O
int	O
c	int
=	O
tolower	function
(	O
SB_GET	O
(	O
)	O
)	O
;	O
obstack_1grow	O
(	O
&	O
stk	struct
,	O
c	int
)	O
;	O
}	O
obstack_1grow	O
(	O
&	O
stk	struct
,	O
0	int
)	O
;	O
p	pointer
=	O
obstack_finish	O
(	O
&	O
stk	struct
)	O
;	O
terminaltype	pointer
=	O
xstrdup	function
(	O
p	pointer
)	O
;	O
obstack_free	function
(	O
&	O
stk	struct
,	O
NULL	O
)	O
;	O
break	O
;	O
}	O
case	O
TELOPT_NAWS	int
:	O
{	O
register	O
int	O
xwinsize	int
,	O
ywinsize	int
;	O
if	O
(	O
his_state_is_wont	O
(	O
TELOPT_NAWS	int
)	O
)	O
break	O
;	O
if	O
(	O
SB_EOF	O
(	O
)	O
)	O
return	O
;	O
xwinsize	int
=	O
SB_GET	O
(	O
)	O
<<	O
8	int
;	O
if	O
(	O
SB_EOF	O
(	O
)	O
)	O
return	O
;	O
xwinsize	int
|=	O
SB_GET	O
(	O
)	O
;	O
if	O
(	O
SB_EOF	O
(	O
)	O
)	O
return	O
;	O
ywinsize	int
=	O
SB_GET	O
(	O
)	O
<<	O
8	int
;	O
if	O
(	O
SB_EOF	O
(	O
)	O
)	O
return	O
;	O
ywinsize	int
|=	O
SB_GET	O
(	O
)	O
;	O
clientstat	function
(	O
TELOPT_NAWS	int
,	O
xwinsize	int
,	O
ywinsize	int
)	O
;	O
break	O
;	O
}	O
case	O
TELOPT_LINEMODE	int
:	O
{	O
register	O
int	O
request	int
;	O
if	O
(	O
his_state_is_wont	O
(	O
TELOPT_LINEMODE	int
)	O
)	O
break	O
;	O
if	O
(	O
SB_EOF	O
(	O
)	O
)	O
break	O
;	O
request	int
=	O
SB_GET	O
(	O
)	O
;	O
if	O
(	O
SB_EOF	O
(	O
)	O
)	O
break	O
;	O
if	O
(	O
request	int
==	O
LM_SLC	int
)	O
{	O
start_slc	function
(	O
1	int
)	O
;	O
do_opt_slc	function
(	O
subpointer	pointer
,	O
subend	pointer
-	O
subpointer	pointer
)	O
;	O
end_slc	function
(	O
0	int
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
request	int
==	O
LM_MODE	int
)	O
{	O
if	O
(	O
SB_EOF	O
(	O
)	O
)	O
return	O
;	O
useeditmode	int
=	O
SB_GET	O
(	O
)	O
;	O
clientstat	function
(	O
LM_MODE	int
,	O
0	int
,	O
0	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
SB_EOF	O
(	O
)	O
)	O
break	O
;	O
switch	O
(	O
SB_GET	O
(	O
)	O
)	O
{	O
case	O
LM_FORWARDMASK	int
:	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
}	O
case	O
TELOPT_STATUS	int
:	O
{	O
int	O
mode	int
;	O
if	O
(	O
SB_EOF	O
(	O
)	O
)	O
break	O
;	O
mode	int
=	O
SB_GET	O
(	O
)	O
;	O
switch	O
(	O
mode	int
)	O
{	O
case	O
TELQUAL_SEND	int
:	O
if	O
(	O
my_state_is_will	O
(	O
TELOPT_STATUS	int
)	O
)	O
send_status	function
(	O
)	O
;	O
break	O
;	O
case	O
TELQUAL_IS	int
:	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
}	O
case	O
TELOPT_XDISPLOC	int
:	O
{	O
if	O
(	O
SB_EOF	O
(	O
)	O
||	O
SB_GET	O
(	O
)	O
!=	O
TELQUAL_IS	int
)	O
return	O
;	O
settimer	O
(	O
xdisplocsubopt	int
)	O
;	O
subpointer	pointer
[	O
SB_LEN	O
(	O
)	O
]	O
=	O
'\0'	O
;	O
setenv	function
(	O
"DISPLAY"	pointer
,	O
(	O
char	O
*	O
)	O
subpointer	pointer
,	O
1	int
)	O
;	O
break	O
;	O
}	O
case	O
TELOPT_NEW_ENVIRON	int
:	O
case	O
TELOPT_OLD_ENVIRON	int
:	O
{	O
register	O
int	O
c	int
;	O
register	O
char	O
*	O
cp	pointer
,	O
*	O
varp	pointer
,	O
*	O
valp	pointer
;	O
if	O
(	O
SB_EOF	O
(	O
)	O
)	O
return	O
;	O
c	int
=	O
SB_GET	O
(	O
)	O
;	O
if	O
(	O
c	int
==	O
TELQUAL_IS	int
)	O
{	O
if	O
(	O
subchar	int
==	O
TELOPT_OLD_ENVIRON	int
)	O
settimer	O
(	O
oenvironsubopt	int
)	O
;	O
else	O
settimer	O
(	O
environsubopt	int
)	O
;	O
}	O
else	O
if	O
(	O
c	int
!=	O
TELQUAL_INFO	int
)	O
return	O
;	O
if	O
(	O
subchar	int
==	O
TELOPT_NEW_ENVIRON	int
)	O
{	O
while	O
(	O
!	O
SB_EOF	O
(	O
)	O
)	O
{	O
c	int
=	O
SB_GET	O
(	O
)	O
;	O
if	O
(	O
(	O
c	int
==	O
NEW_ENV_VAR	int
)	O
||	O
(	O
c	int
==	O
ENV_USERVAR	int
)	O
)	O
break	O
;	O
}	O
}	O
else	O
{	O
while	O
(	O
!	O
SB_EOF	O
(	O
)	O
)	O
{	O
c	int
=	O
SB_GET	O
(	O
)	O
;	O
if	O
(	O
(	O
c	int
==	O
env_ovar	O
)	O
||	O
(	O
c	int
==	O
ENV_USERVAR	int
)	O
)	O
break	O
;	O
}	O
}	O
if	O
(	O
SB_EOF	O
(	O
)	O
)	O
return	O
;	O
cp	pointer
=	O
varp	pointer
=	O
(	O
char	O
*	O
)	O
subpointer	pointer
;	O
valp	pointer
=	O
0	int
;	O
while	O
(	O
!	O
SB_EOF	O
(	O
)	O
)	O
{	O
c	int
=	O
SB_GET	O
(	O
)	O
;	O
if	O
(	O
subchar	int
==	O
TELOPT_OLD_ENVIRON	int
)	O
{	O
if	O
(	O
c	int
==	O
env_ovar	O
)	O
c	int
=	O
NEW_ENV_VAR	int
;	O
else	O
if	O
(	O
c	int
==	O
env_ovalue	O
)	O
c	int
=	O
NEW_ENV_VALUE	int
;	O
}	O
switch	O
(	O
c	int
)	O
{	O
case	O
NEW_ENV_VALUE	int
:	O
*	O
cp	pointer
=	O
'\0'	O
;	O
cp	pointer
=	O
valp	pointer
=	O
(	O
char	O
*	O
)	O
subpointer	pointer
;	O
break	O
;	O
case	O
NEW_ENV_VAR	int
:	O
case	O
ENV_USERVAR	int
:	O
*	O
cp	pointer
=	O
'\0'	O
;	O
if	O
(	O
valp	pointer
)	O
setenv	function
(	O
varp	pointer
,	O
valp	pointer
,	O
1	int
)	O
;	O
else	O
unsetenv	function
(	O
varp	pointer
)	O
;	O
cp	pointer
=	O
varp	pointer
=	O
(	O
char	O
*	O
)	O
subpointer	pointer
;	O
valp	pointer
=	O
0	int
;	O
break	O
;	O
case	O
ENV_ESC	int
:	O
if	O
(	O
SB_EOF	O
(	O
)	O
)	O
break	O
;	O
c	int
=	O
SB_GET	O
(	O
)	O
;	O
default	O
:	O
*	O
cp	pointer
++	O
=	O
c	int
;	O
break	O
;	O
}	O
}	O
*	O
cp	pointer
=	O
'\0'	O
;	O
if	O
(	O
valp	pointer
)	O
setenv	function
(	O
varp	pointer
,	O
valp	pointer
,	O
1	int
)	O
;	O
else	O
unsetenv	function
(	O
varp	pointer
)	O
;	O
break	O
;	O
}	O
default	O
:	O
break	O
;	O
}	O
}	O
void	O
doclientstat	function
(	O
void	O
)	O
{	O
clientstat	function
(	O
TELOPT_LINEMODE	int
,	O
WILL	int
,	O
0	int
)	O
;	O
}	O
void	O
send_status	function
(	O
void	O
)	O
{	O
unsigned	O
char	O
statusbuf	array
[	O
256	int
]	O
;	O
unsigned	O
char	O
*	O
ep	pointer
;	O
register	O
unsigned	O
char	O
*	O
ncp	pointer
;	O
register	O
unsigned	O
char	O
i	char
;	O
ncp	pointer
=	O
statusbuf	array
;	O
ep	pointer
=	O
statusbuf	array
+	O
sizeof	O
(	O
statusbuf	array
)	O
;	O
netflush	function
(	O
)	O
;	O
ADD	O
(	O
IAC	int
)	O
;	O
ADD	O
(	O
SB	int
)	O
;	O
ADD	O
(	O
TELOPT_STATUS	int
)	O
;	O
ADD	O
(	O
TELQUAL_IS	int
)	O
;	O
for	O
(	O
i	char
=	O
0	int
;	O
i	char
<	O
(	O
unsigned	O
char	O
)	O
NTELOPTS	O
;	O
i	char
++	O
)	O
{	O
if	O
(	O
my_want_state_is_will	O
(	O
i	char
)	O
)	O
{	O
ADD	O
(	O
WILL	int
)	O
;	O
ADD_DATA	O
(	O
i	char
)	O
;	O
}	O
if	O
(	O
his_want_state_is_will	O
(	O
i	char
)	O
)	O
{	O
ADD	O
(	O
DO	int
)	O
;	O
ADD_DATA	O
(	O
i	char
)	O
;	O
}	O
}	O
if	O
(	O
his_want_state_is_will	O
(	O
TELOPT_LFLOW	int
)	O
)	O
{	O
ADD	O
(	O
SB	int
)	O
;	O
ADD	O
(	O
TELOPT_LFLOW	int
)	O
;	O
if	O
(	O
flowmode	int
)	O
ADD	O
(	O
LFLOW_ON	int
)	O
;	O
else	O
ADD	O
(	O
LFLOW_OFF	int
)	O
;	O
ADD	O
(	O
SE	int
)	O
;	O
if	O
(	O
restartany	int
>=	O
0	int
)	O
{	O
ADD	O
(	O
SB	int
)	O
;	O
ADD	O
(	O
TELOPT_LFLOW	int
)	O
;	O
if	O
(	O
restartany	int
)	O
ADD	O
(	O
LFLOW_RESTART_ANY	int
)	O
;	O
else	O
ADD	O
(	O
LFLOW_RESTART_XON	int
)	O
;	O
ADD	O
(	O
SE	int
)	O
;	O
}	O
}	O
if	O
(	O
his_want_state_is_will	O
(	O
TELOPT_LINEMODE	int
)	O
)	O
{	O
unsigned	O
char	O
*	O
cp	pointer
,	O
*	O
cpe	pointer
;	O
int	O
len	long
;	O
ADD	O
(	O
SB	int
)	O
;	O
ADD	O
(	O
TELOPT_LINEMODE	int
)	O
;	O
ADD	O
(	O
LM_MODE	int
)	O
;	O
ADD_DATA	O
(	O
editmode	int
)	O
;	O
ADD	O
(	O
SE	int
)	O
;	O
ADD	O
(	O
SB	int
)	O
;	O
ADD	O
(	O
TELOPT_LINEMODE	int
)	O
;	O
ADD	O
(	O
LM_SLC	int
)	O
;	O
start_slc	function
(	O
0	int
)	O
;	O
send_slc	function
(	O
)	O
;	O
len	long
=	O
end_slc	function
(	O
&	O
cp	pointer
)	O
;	O
for	O
(	O
cpe	pointer
=	O
cp	pointer
+	O
len	long
;	O
cp	pointer
<	O
cpe	pointer
;	O
cp	pointer
++	O
)	O
ADD_DATA	O
(	O
*	O
cp	pointer
)	O
;	O
ADD	O
(	O
SE	int
)	O
;	O
}	O
ADD	O
(	O
IAC	int
)	O
;	O
ADD	O
(	O
SE	int
)	O
;	O
net_output_datalen	function
(	O
statusbuf	array
,	O
ncp	pointer
-	O
statusbuf	array
)	O
;	O
netflush	function
(	O
)	O
;	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
printsub	pointer
(	O
'>'	O
,	O
statusbuf	array
,	O
ncp	pointer
-	O
statusbuf	array
)	O
)	O
;	O
return	O
;	O
trunc	O
:	O
return	O
;	O
}	O
