typedef	O
enum	O
eval_token	enum
{	O
ERROR	int
,	O
BADOP	int
,	O
PLUS	int
,	O
MINUS	int
,	O
EXPONENT	int
,	O
TIMES	int
,	O
DIVIDE	int
,	O
MODULO	int
,	O
ASSIGN	int
,	O
EQ	int
,	O
NOTEQ	int
,	O
GT	int
,	O
GTEQ	int
,	O
LS	int
,	O
LSEQ	int
,	O
LSHIFT	int
,	O
RSHIFT	int
,	O
LNOT	int
,	O
LAND	int
,	O
LOR	int
,	O
NOT	int
,	O
AND	int
,	O
OR	int
,	O
XOR	int
,	O
LEFTP	int
,	O
RIGHTP	int
,	O
NUMBER	int
,	O
EOTEXT	int
}	O
eval_token	enum
;	O
typedef	O
enum	O
eval_error	enum
{	O
NO_ERROR	int
,	O
DIVIDE_ZERO	int
,	O
MODULO_ZERO	int
,	O
NEGATIVE_EXPONENT	int
,	O
SYNTAX_ERROR	int
,	O
MISSING_RIGHT	int
,	O
UNKNOWN_INPUT	int
,	O
EXCESS_INPUT	int
,	O
INVALID_OPERATOR	int
}	O
eval_error	enum
;	O
static	O
eval_error	enum
logical_or_term	function
(	O
eval_token	enum
,	O
int32_t	int
*	O
)	O
;	O
static	O
eval_error	enum
logical_and_term	function
(	O
eval_token	enum
,	O
int32_t	int
*	O
)	O
;	O
static	O
eval_error	enum
or_term	function
(	O
eval_token	enum
,	O
int32_t	int
*	O
)	O
;	O
static	O
eval_error	enum
xor_term	function
(	O
eval_token	enum
,	O
int32_t	int
*	O
)	O
;	O
static	O
eval_error	enum
and_term	function
(	O
eval_token	enum
,	O
int32_t	int
*	O
)	O
;	O
static	O
eval_error	enum
equality_term	function
(	O
eval_token	enum
,	O
int32_t	int
*	O
)	O
;	O
static	O
eval_error	enum
cmp_term	function
(	O
eval_token	enum
,	O
int32_t	int
*	O
)	O
;	O
static	O
eval_error	enum
shift_term	function
(	O
eval_token	enum
,	O
int32_t	int
*	O
)	O
;	O
static	O
eval_error	enum
add_term	function
(	O
eval_token	enum
,	O
int32_t	int
*	O
)	O
;	O
static	O
eval_error	enum
mult_term	function
(	O
eval_token	enum
,	O
int32_t	int
*	O
)	O
;	O
static	O
eval_error	enum
exp_term	function
(	O
eval_token	enum
,	O
int32_t	int
*	O
)	O
;	O
static	O
eval_error	enum
unary_term	function
(	O
eval_token	enum
,	O
int32_t	int
*	O
)	O
;	O
static	O
eval_error	enum
simple_term	function
(	O
eval_token	enum
,	O
int32_t	int
*	O
)	O
;	O
static	O
const	O
char	O
*	O
eval_text	pointer
;	O
static	O
const	O
char	O
*	O
last_text	pointer
;	O
static	O
void	O
eval_init_lex	function
(	O
const	O
char	O
*	O
text	pointer
)	O
{	O
eval_text	pointer
=	O
text	pointer
;	O
last_text	pointer
=	O
NULL	O
;	O
}	O
static	O
void	O
eval_undo	function
(	O
void	O
)	O
{	O
eval_text	pointer
=	O
last_text	pointer
;	O
}	O
static	O
eval_token	enum
eval_lex	function
(	O
int32_t	int
*	O
val	array
)	O
{	O
while	O
(	O
isspace	function
(	O
to_uchar	O
(	O
*	O
eval_text	pointer
)	O
)	O
)	O
eval_text	pointer
++	O
;	O
last_text	pointer
=	O
eval_text	pointer
;	O
if	O
(	O
*	O
eval_text	pointer
==	O
'\0'	O
)	O
return	O
EOTEXT	int
;	O
if	O
(	O
isdigit	function
(	O
to_uchar	O
(	O
*	O
eval_text	pointer
)	O
)	O
)	O
{	O
int	O
base	pointer
,	O
digit	int
;	O
if	O
(	O
*	O
eval_text	pointer
==	O
'0'	O
)	O
{	O
eval_text	pointer
++	O
;	O
switch	O
(	O
*	O
eval_text	pointer
)	O
{	O
case	O
'x'	O
:	O
case	O
'X'	O
:	O
base	pointer
=	O
16	int
;	O
eval_text	pointer
++	O
;	O
break	O
;	O
case	O
'b'	O
:	O
case	O
'B'	O
:	O
base	pointer
=	O
2	int
;	O
eval_text	pointer
++	O
;	O
break	O
;	O
case	O
'r'	O
:	O
case	O
'R'	O
:	O
base	pointer
=	O
0	int
;	O
eval_text	pointer
++	O
;	O
while	O
(	O
isdigit	function
(	O
to_uchar	O
(	O
*	O
eval_text	pointer
)	O
)	O
&&	O
base	pointer
<=	O
36	int
)	O
base	pointer
=	O
10	int
*	O
base	pointer
+	O
*	O
eval_text	pointer
++	O
-	O
'0'	O
;	O
if	O
(	O
base	pointer
==	O
0	int
||	O
base	pointer
>	O
36	int
||	O
*	O
eval_text	pointer
!=	O
':'	O
)	O
return	O
ERROR	int
;	O
eval_text	pointer
++	O
;	O
break	O
;	O
default	O
:	O
base	pointer
=	O
8	int
;	O
}	O
}	O
else	O
base	pointer
=	O
10	int
;	O
*	O
val	array
=	O
0	int
;	O
for	O
(	O
;	O
*	O
eval_text	pointer
;	O
eval_text	pointer
++	O
)	O
{	O
if	O
(	O
isdigit	function
(	O
to_uchar	O
(	O
*	O
eval_text	pointer
)	O
)	O
)	O
digit	int
=	O
*	O
eval_text	pointer
-	O
'0'	O
;	O
else	O
if	O
(	O
islower	function
(	O
to_uchar	O
(	O
*	O
eval_text	pointer
)	O
)	O
)	O
digit	int
=	O
*	O
eval_text	pointer
-	O
'a'	O
+	O
10	int
;	O
else	O
if	O
(	O
isupper	function
(	O
to_uchar	O
(	O
*	O
eval_text	pointer
)	O
)	O
)	O
digit	int
=	O
*	O
eval_text	pointer
-	O
'A'	O
+	O
10	int
;	O
else	O
break	O
;	O
if	O
(	O
base	pointer
==	O
1	int
)	O
{	O
if	O
(	O
digit	int
==	O
1	int
)	O
(	O
*	O
val	array
)	O
++	O
;	O
else	O
if	O
(	O
digit	int
==	O
0	int
&&	O
!	O
*	O
val	array
)	O
continue	O
;	O
else	O
break	O
;	O
}	O
else	O
if	O
(	O
digit	int
>=	O
base	pointer
)	O
break	O
;	O
else	O
*	O
val	array
=	O
*	O
val	array
*	O
base	pointer
+	O
digit	int
;	O
}	O
return	O
NUMBER	int
;	O
}	O
switch	O
(	O
*	O
eval_text	pointer
++	O
)	O
{	O
case	O
'+'	O
:	O
if	O
(	O
*	O
eval_text	pointer
==	O
'+'	O
||	O
*	O
eval_text	pointer
==	O
'='	O
)	O
return	O
BADOP	int
;	O
return	O
PLUS	int
;	O
case	O
'-'	O
:	O
if	O
(	O
*	O
eval_text	pointer
==	O
'-'	O
||	O
*	O
eval_text	pointer
==	O
'='	O
)	O
return	O
BADOP	int
;	O
return	O
MINUS	int
;	O
case	O
'*'	O
:	O
if	O
(	O
*	O
eval_text	pointer
==	O
'*'	O
)	O
{	O
eval_text	pointer
++	O
;	O
return	O
EXPONENT	int
;	O
}	O
else	O
if	O
(	O
*	O
eval_text	pointer
==	O
'='	O
)	O
return	O
BADOP	int
;	O
return	O
TIMES	int
;	O
case	O
'/'	O
:	O
if	O
(	O
*	O
eval_text	pointer
==	O
'='	O
)	O
return	O
BADOP	int
;	O
return	O
DIVIDE	int
;	O
case	O
'%'	O
:	O
if	O
(	O
*	O
eval_text	pointer
==	O
'='	O
)	O
return	O
BADOP	int
;	O
return	O
MODULO	int
;	O
case	O
'='	O
:	O
if	O
(	O
*	O
eval_text	pointer
==	O
'='	O
)	O
{	O
eval_text	pointer
++	O
;	O
return	O
EQ	int
;	O
}	O
return	O
ASSIGN	int
;	O
case	O
'!'	O
:	O
if	O
(	O
*	O
eval_text	pointer
==	O
'='	O
)	O
{	O
eval_text	pointer
++	O
;	O
return	O
NOTEQ	int
;	O
}	O
return	O
LNOT	int
;	O
case	O
'>'	O
:	O
if	O
(	O
*	O
eval_text	pointer
==	O
'='	O
)	O
{	O
eval_text	pointer
++	O
;	O
return	O
GTEQ	int
;	O
}	O
else	O
if	O
(	O
*	O
eval_text	pointer
==	O
'>'	O
)	O
{	O
if	O
(	O
*	O
++	O
eval_text	pointer
==	O
'='	O
)	O
return	O
BADOP	int
;	O
return	O
RSHIFT	int
;	O
}	O
return	O
GT	int
;	O
case	O
'<'	O
:	O
if	O
(	O
*	O
eval_text	pointer
==	O
'='	O
)	O
{	O
eval_text	pointer
++	O
;	O
return	O
LSEQ	int
;	O
}	O
else	O
if	O
(	O
*	O
eval_text	pointer
==	O
'<'	O
)	O
{	O
if	O
(	O
*	O
++	O
eval_text	pointer
==	O
'='	O
)	O
return	O
BADOP	int
;	O
return	O
LSHIFT	int
;	O
}	O
return	O
LS	int
;	O
case	O
'^'	O
:	O
if	O
(	O
*	O
eval_text	pointer
==	O
'='	O
)	O
return	O
BADOP	int
;	O
return	O
XOR	int
;	O
case	O
'~'	O
:	O
return	O
NOT	int
;	O
case	O
'&'	O
:	O
if	O
(	O
*	O
eval_text	pointer
==	O
'&'	O
)	O
{	O
eval_text	pointer
++	O
;	O
return	O
LAND	int
;	O
}	O
else	O
if	O
(	O
*	O
eval_text	pointer
==	O
'='	O
)	O
return	O
BADOP	int
;	O
return	O
AND	int
;	O
case	O
'|'	O
:	O
if	O
(	O
*	O
eval_text	pointer
==	O
'|'	O
)	O
{	O
eval_text	pointer
++	O
;	O
return	O
LOR	int
;	O
}	O
else	O
if	O
(	O
*	O
eval_text	pointer
==	O
'='	O
)	O
return	O
BADOP	int
;	O
return	O
OR	int
;	O
case	O
'('	O
:	O
return	O
LEFTP	int
;	O
case	O
')'	O
:	O
return	O
RIGHTP	int
;	O
default	O
:	O
return	O
ERROR	int
;	O
}	O
}	O
bool	bool
evaluate	function
(	O
const	O
char	O
*	O
expr	pointer
,	O
int32_t	int
*	O
val	array
)	O
{	O
eval_token	enum
et	enum
;	O
eval_error	enum
err	enum
;	O
eval_init_lex	function
(	O
expr	pointer
)	O
;	O
et	enum
=	O
eval_lex	function
(	O
val	array
)	O
;	O
err	enum
=	O
logical_or_term	function
(	O
et	enum
,	O
val	array
)	O
;	O
if	O
(	O
err	enum
==	O
NO_ERROR	int
&&	O
*	O
eval_text	pointer
!=	O
'\0'	O
)	O
{	O
if	O
(	O
eval_lex	function
(	O
val	array
)	O
==	O
BADOP	int
)	O
err	enum
=	O
INVALID_OPERATOR	int
;	O
else	O
err	enum
=	O
EXCESS_INPUT	int
;	O
}	O
switch	O
(	O
err	enum
)	O
{	O
case	O
NO_ERROR	int
:	O
break	O
;	O
case	O
MISSING_RIGHT	int
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"bad expression in eval (missing right parenthesis): %s"	pointer
,	O
expr	pointer
)	O
)	O
;	O
break	O
;	O
case	O
SYNTAX_ERROR	int
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"bad expression in eval: %s"	pointer
,	O
expr	pointer
)	O
)	O
;	O
break	O
;	O
case	O
UNKNOWN_INPUT	int
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"bad expression in eval (bad input): %s"	pointer
,	O
expr	pointer
)	O
)	O
;	O
break	O
;	O
case	O
EXCESS_INPUT	int
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"bad expression in eval (excess input): %s"	pointer
,	O
expr	pointer
)	O
)	O
;	O
break	O
;	O
case	O
INVALID_OPERATOR	int
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"invalid operator in eval: %s"	pointer
,	O
expr	pointer
)	O
)	O
;	O
retcode	int
=	O
EXIT_FAILURE	int
;	O
break	O
;	O
case	O
DIVIDE_ZERO	int
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"divide by zero in eval: %s"	pointer
,	O
expr	pointer
)	O
)	O
;	O
break	O
;	O
case	O
MODULO_ZERO	int
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"modulo by zero in eval: %s"	pointer
,	O
expr	pointer
)	O
)	O
;	O
break	O
;	O
case	O
NEGATIVE_EXPONENT	int
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"negative exponent in eval: %s"	pointer
,	O
expr	pointer
)	O
)	O
;	O
break	O
;	O
default	O
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: bad error code in evaluate ()"	pointer
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
return	O
err	enum
!=	O
NO_ERROR	int
;	O
}	O
static	O
eval_error	enum
logical_or_term	function
(	O
eval_token	enum
et	enum
,	O
int32_t	int
*	O
v1	pointer
)	O
{	O
int32_t	int
v2	int
;	O
eval_error	enum
er	enum
;	O
if	O
(	O
(	O
er	enum
=	O
logical_and_term	function
(	O
et	enum
,	O
v1	pointer
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum
;	O
while	O
(	O
(	O
et	enum
=	O
eval_lex	function
(	O
&	O
v2	int
)	O
)	O
==	O
LOR	int
)	O
{	O
et	enum
=	O
eval_lex	function
(	O
&	O
v2	int
)	O
;	O
if	O
(	O
et	enum
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
er	enum
=	O
logical_and_term	function
(	O
et	enum
,	O
&	O
v2	int
)	O
;	O
if	O
(	O
er	enum
==	O
NO_ERROR	int
)	O
*	O
v1	pointer
=	O
*	O
v1	pointer
||	O
v2	int
;	O
else	O
if	O
(	O
*	O
v1	pointer
!=	O
0	int
&&	O
er	enum
<	O
SYNTAX_ERROR	int
)	O
*	O
v1	pointer
=	O
1	int
;	O
else	O
return	O
er	enum
;	O
}	O
if	O
(	O
et	enum
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
eval_undo	function
(	O
)	O
;	O
return	O
NO_ERROR	int
;	O
}	O
static	O
eval_error	enum
logical_and_term	function
(	O
eval_token	enum
et	enum
,	O
int32_t	int
*	O
v1	pointer
)	O
{	O
int32_t	int
v2	int
;	O
eval_error	enum
er	enum
;	O
if	O
(	O
(	O
er	enum
=	O
or_term	function
(	O
et	enum
,	O
v1	pointer
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum
;	O
while	O
(	O
(	O
et	enum
=	O
eval_lex	function
(	O
&	O
v2	int
)	O
)	O
==	O
LAND	int
)	O
{	O
et	enum
=	O
eval_lex	function
(	O
&	O
v2	int
)	O
;	O
if	O
(	O
et	enum
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
er	enum
=	O
or_term	function
(	O
et	enum
,	O
&	O
v2	int
)	O
;	O
if	O
(	O
er	enum
==	O
NO_ERROR	int
)	O
*	O
v1	pointer
=	O
*	O
v1	pointer
&&	O
v2	int
;	O
else	O
if	O
(	O
*	O
v1	pointer
==	O
0	int
&&	O
er	enum
<	O
SYNTAX_ERROR	int
)	O
;	O
else	O
return	O
er	enum
;	O
}	O
if	O
(	O
et	enum
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
eval_undo	function
(	O
)	O
;	O
return	O
NO_ERROR	int
;	O
}	O
static	O
eval_error	enum
or_term	function
(	O
eval_token	enum
et	enum
,	O
int32_t	int
*	O
v1	pointer
)	O
{	O
int32_t	int
v2	int
;	O
eval_error	enum
er	enum
;	O
if	O
(	O
(	O
er	enum
=	O
xor_term	function
(	O
et	enum
,	O
v1	pointer
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum
;	O
while	O
(	O
(	O
et	enum
=	O
eval_lex	function
(	O
&	O
v2	int
)	O
)	O
==	O
OR	int
)	O
{	O
et	enum
=	O
eval_lex	function
(	O
&	O
v2	int
)	O
;	O
if	O
(	O
et	enum
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
if	O
(	O
(	O
er	enum
=	O
xor_term	function
(	O
et	enum
,	O
&	O
v2	int
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum
;	O
*	O
v1	pointer
|=	O
v2	int
;	O
}	O
if	O
(	O
et	enum
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
eval_undo	function
(	O
)	O
;	O
return	O
NO_ERROR	int
;	O
}	O
static	O
eval_error	enum
xor_term	function
(	O
eval_token	enum
et	enum
,	O
int32_t	int
*	O
v1	pointer
)	O
{	O
int32_t	int
v2	int
;	O
eval_error	enum
er	enum
;	O
if	O
(	O
(	O
er	enum
=	O
and_term	function
(	O
et	enum
,	O
v1	pointer
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum
;	O
while	O
(	O
(	O
et	enum
=	O
eval_lex	function
(	O
&	O
v2	int
)	O
)	O
==	O
XOR	int
)	O
{	O
et	enum
=	O
eval_lex	function
(	O
&	O
v2	int
)	O
;	O
if	O
(	O
et	enum
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
if	O
(	O
(	O
er	enum
=	O
and_term	function
(	O
et	enum
,	O
&	O
v2	int
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum
;	O
*	O
v1	pointer
^=	O
v2	int
;	O
}	O
if	O
(	O
et	enum
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
eval_undo	function
(	O
)	O
;	O
return	O
NO_ERROR	int
;	O
}	O
static	O
eval_error	enum
and_term	function
(	O
eval_token	enum
et	enum
,	O
int32_t	int
*	O
v1	pointer
)	O
{	O
int32_t	int
v2	int
;	O
eval_error	enum
er	enum
;	O
if	O
(	O
(	O
er	enum
=	O
equality_term	function
(	O
et	enum
,	O
v1	pointer
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum
;	O
while	O
(	O
(	O
et	enum
=	O
eval_lex	function
(	O
&	O
v2	int
)	O
)	O
==	O
AND	int
)	O
{	O
et	enum
=	O
eval_lex	function
(	O
&	O
v2	int
)	O
;	O
if	O
(	O
et	enum
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
if	O
(	O
(	O
er	enum
=	O
equality_term	function
(	O
et	enum
,	O
&	O
v2	int
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum
;	O
*	O
v1	pointer
&=	O
v2	int
;	O
}	O
if	O
(	O
et	enum
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
eval_undo	function
(	O
)	O
;	O
return	O
NO_ERROR	int
;	O
}	O
static	O
eval_error	enum
equality_term	function
(	O
eval_token	enum
et	enum
,	O
int32_t	int
*	O
v1	pointer
)	O
{	O
eval_token	enum
op	enum
;	O
int32_t	int
v2	int
;	O
eval_error	enum
er	enum
;	O
if	O
(	O
(	O
er	enum
=	O
cmp_term	function
(	O
et	enum
,	O
v1	pointer
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum
;	O
while	O
(	O
(	O
op	enum
=	O
eval_lex	function
(	O
&	O
v2	int
)	O
)	O
==	O
EQ	int
||	O
op	enum
==	O
NOTEQ	int
||	O
op	enum
==	O
ASSIGN	int
)	O
{	O
et	enum
=	O
eval_lex	function
(	O
&	O
v2	int
)	O
;	O
if	O
(	O
et	enum
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
if	O
(	O
(	O
er	enum
=	O
cmp_term	function
(	O
et	enum
,	O
&	O
v2	int
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum
;	O
if	O
(	O
op	enum
==	O
ASSIGN	int
)	O
{	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"Warning: recommend ==, not =, for equality operator"	pointer
)	O
)	O
;	O
op	enum
=	O
EQ	int
;	O
}	O
*	O
v1	pointer
=	O
(	O
op	enum
==	O
EQ	int
)	O
==	O
(	O
*	O
v1	pointer
==	O
v2	int
)	O
;	O
}	O
if	O
(	O
op	enum
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
eval_undo	function
(	O
)	O
;	O
return	O
NO_ERROR	int
;	O
}	O
static	O
eval_error	enum
cmp_term	function
(	O
eval_token	enum
et	enum
,	O
int32_t	int
*	O
v1	pointer
)	O
{	O
eval_token	enum
op	enum
;	O
int32_t	int
v2	int
;	O
eval_error	enum
er	enum
;	O
if	O
(	O
(	O
er	enum
=	O
shift_term	function
(	O
et	enum
,	O
v1	pointer
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum
;	O
while	O
(	O
(	O
op	enum
=	O
eval_lex	function
(	O
&	O
v2	int
)	O
)	O
==	O
GT	int
||	O
op	enum
==	O
GTEQ	int
||	O
op	enum
==	O
LS	int
||	O
op	enum
==	O
LSEQ	int
)	O
{	O
et	enum
=	O
eval_lex	function
(	O
&	O
v2	int
)	O
;	O
if	O
(	O
et	enum
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
if	O
(	O
(	O
er	enum
=	O
shift_term	function
(	O
et	enum
,	O
&	O
v2	int
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum
;	O
switch	O
(	O
op	enum
)	O
{	O
case	O
GT	int
:	O
*	O
v1	pointer
=	O
*	O
v1	pointer
>	O
v2	int
;	O
break	O
;	O
case	O
GTEQ	int
:	O
*	O
v1	pointer
=	O
*	O
v1	pointer
>=	O
v2	int
;	O
break	O
;	O
case	O
LS	int
:	O
*	O
v1	pointer
=	O
*	O
v1	pointer
<	O
v2	int
;	O
break	O
;	O
case	O
LSEQ	int
:	O
*	O
v1	pointer
=	O
*	O
v1	pointer
<=	O
v2	int
;	O
break	O
;	O
default	O
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: bad comparison operator in cmp_term ()"	pointer
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
}	O
if	O
(	O
op	enum
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
eval_undo	function
(	O
)	O
;	O
return	O
NO_ERROR	int
;	O
}	O
static	O
eval_error	enum
shift_term	function
(	O
eval_token	enum
et	enum
,	O
int32_t	int
*	O
v1	pointer
)	O
{	O
eval_token	enum
op	enum
;	O
int32_t	int
v2	int
;	O
uint32_t	int
u1	int
;	O
eval_error	enum
er	enum
;	O
if	O
(	O
(	O
er	enum
=	O
add_term	function
(	O
et	enum
,	O
v1	pointer
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum
;	O
while	O
(	O
(	O
op	enum
=	O
eval_lex	function
(	O
&	O
v2	int
)	O
)	O
==	O
LSHIFT	int
||	O
op	enum
==	O
RSHIFT	int
)	O
{	O
et	enum
=	O
eval_lex	function
(	O
&	O
v2	int
)	O
;	O
if	O
(	O
et	enum
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
if	O
(	O
(	O
er	enum
=	O
add_term	function
(	O
et	enum
,	O
&	O
v2	int
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum
;	O
switch	O
(	O
op	enum
)	O
{	O
case	O
LSHIFT	int
:	O
u1	int
=	O
*	O
v1	pointer
;	O
u1	int
<<=	O
(	O
uint32_t	int
)	O
(	O
v2	int
&	O
0x1f	int
)	O
;	O
*	O
v1	pointer
=	O
u1	int
;	O
break	O
;	O
case	O
RSHIFT	int
:	O
u1	int
=	O
*	O
v1	pointer
<	O
0	int
?	O
~	O
*	O
v1	pointer
:	O
*	O
v1	pointer
;	O
u1	int
>>=	O
(	O
uint32_t	int
)	O
(	O
v2	int
&	O
0x1f	int
)	O
;	O
*	O
v1	pointer
=	O
*	O
v1	pointer
<	O
0	int
?	O
~	O
u1	int
:	O
u1	int
;	O
break	O
;	O
default	O
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: bad shift operator in shift_term ()"	pointer
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
}	O
if	O
(	O
op	enum
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
eval_undo	function
(	O
)	O
;	O
return	O
NO_ERROR	int
;	O
}	O
static	O
eval_error	enum
add_term	function
(	O
eval_token	enum
et	enum
,	O
int32_t	int
*	O
v1	pointer
)	O
{	O
eval_token	enum
op	enum
;	O
int32_t	int
v2	int
;	O
eval_error	enum
er	enum
;	O
if	O
(	O
(	O
er	enum
=	O
mult_term	function
(	O
et	enum
,	O
v1	pointer
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum
;	O
while	O
(	O
(	O
op	enum
=	O
eval_lex	function
(	O
&	O
v2	int
)	O
)	O
==	O
PLUS	int
||	O
op	enum
==	O
MINUS	int
)	O
{	O
et	enum
=	O
eval_lex	function
(	O
&	O
v2	int
)	O
;	O
if	O
(	O
et	enum
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
if	O
(	O
(	O
er	enum
=	O
mult_term	function
(	O
et	enum
,	O
&	O
v2	int
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum
;	O
if	O
(	O
op	enum
==	O
PLUS	int
)	O
*	O
v1	pointer
=	O
(	O
int32_t	int
)	O
(	O
(	O
uint32_t	int
)	O
*	O
v1	pointer
+	O
(	O
uint32_t	int
)	O
v2	int
)	O
;	O
else	O
*	O
v1	pointer
=	O
(	O
int32_t	int
)	O
(	O
(	O
uint32_t	int
)	O
*	O
v1	pointer
-	O
(	O
uint32_t	int
)	O
v2	int
)	O
;	O
}	O
if	O
(	O
op	enum
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
eval_undo	function
(	O
)	O
;	O
return	O
NO_ERROR	int
;	O
}	O
static	O
eval_error	enum
mult_term	function
(	O
eval_token	enum
et	enum
,	O
int32_t	int
*	O
v1	pointer
)	O
{	O
eval_token	enum
op	enum
;	O
int32_t	int
v2	int
;	O
eval_error	enum
er	enum
;	O
if	O
(	O
(	O
er	enum
=	O
exp_term	function
(	O
et	enum
,	O
v1	pointer
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum
;	O
while	O
(	O
(	O
op	enum
=	O
eval_lex	function
(	O
&	O
v2	int
)	O
)	O
==	O
TIMES	int
||	O
op	enum
==	O
DIVIDE	int
||	O
op	enum
==	O
MODULO	int
)	O
{	O
et	enum
=	O
eval_lex	function
(	O
&	O
v2	int
)	O
;	O
if	O
(	O
et	enum
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
if	O
(	O
(	O
er	enum
=	O
exp_term	function
(	O
et	enum
,	O
&	O
v2	int
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum
;	O
switch	O
(	O
op	enum
)	O
{	O
case	O
TIMES	int
:	O
*	O
v1	pointer
=	O
(	O
int32_t	int
)	O
(	O
(	O
uint32_t	int
)	O
*	O
v1	pointer
*	O
(	O
uint32_t	int
)	O
v2	int
)	O
;	O
break	O
;	O
case	O
DIVIDE	int
:	O
if	O
(	O
v2	int
==	O
0	int
)	O
return	O
DIVIDE_ZERO	int
;	O
else	O
if	O
(	O
v2	int
==	O
-	O
1	int
)	O
*	O
v1	pointer
=	O
(	O
int32_t	int
)	O
-	O
(	O
uint32_t	int
)	O
*	O
v1	pointer
;	O
else	O
*	O
v1	pointer
/=	O
v2	int
;	O
break	O
;	O
case	O
MODULO	int
:	O
if	O
(	O
v2	int
==	O
0	int
)	O
return	O
MODULO_ZERO	int
;	O
else	O
if	O
(	O
v2	int
==	O
-	O
1	int
)	O
*	O
v1	pointer
=	O
0	int
;	O
else	O
*	O
v1	pointer
%=	O
v2	int
;	O
break	O
;	O
default	O
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: bad operator in mult_term ()"	pointer
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
}	O
if	O
(	O
op	enum
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
eval_undo	function
(	O
)	O
;	O
return	O
NO_ERROR	int
;	O
}	O
static	O
eval_error	enum
exp_term	function
(	O
eval_token	enum
et	enum
,	O
int32_t	int
*	O
v1	pointer
)	O
{	O
uint32_t	int
result	pointer
;	O
int32_t	int
v2	int
;	O
eval_error	enum
er	enum
;	O
if	O
(	O
(	O
er	enum
=	O
unary_term	function
(	O
et	enum
,	O
v1	pointer
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum
;	O
while	O
(	O
(	O
et	enum
=	O
eval_lex	function
(	O
&	O
v2	int
)	O
)	O
==	O
EXPONENT	int
)	O
{	O
et	enum
=	O
eval_lex	function
(	O
&	O
v2	int
)	O
;	O
if	O
(	O
et	enum
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
if	O
(	O
(	O
er	enum
=	O
exp_term	function
(	O
et	enum
,	O
&	O
v2	int
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum
;	O
result	pointer
=	O
1	int
;	O
if	O
(	O
v2	int
<	O
0	int
)	O
return	O
NEGATIVE_EXPONENT	int
;	O
if	O
(	O
*	O
v1	pointer
==	O
0	int
&&	O
v2	int
==	O
0	int
)	O
return	O
DIVIDE_ZERO	int
;	O
while	O
(	O
v2	int
--	O
>	O
0	int
)	O
result	pointer
*=	O
(	O
uint32_t	int
)	O
*	O
v1	pointer
;	O
*	O
v1	pointer
=	O
result	pointer
;	O
}	O
if	O
(	O
et	enum
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
eval_undo	function
(	O
)	O
;	O
return	O
NO_ERROR	int
;	O
}	O
static	O
eval_error	enum
unary_term	function
(	O
eval_token	enum
et	enum
,	O
int32_t	int
*	O
v1	pointer
)	O
{	O
eval_error	enum
er	enum
;	O
if	O
(	O
et	enum
==	O
PLUS	int
||	O
et	enum
==	O
MINUS	int
||	O
et	enum
==	O
NOT	int
||	O
et	enum
==	O
LNOT	int
)	O
{	O
eval_token	enum
et2	enum
=	O
eval_lex	function
(	O
v1	pointer
)	O
;	O
if	O
(	O
et2	enum
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
if	O
(	O
(	O
er	enum
=	O
unary_term	function
(	O
et2	enum
,	O
v1	pointer
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum
;	O
if	O
(	O
et	enum
==	O
MINUS	int
)	O
*	O
v1	pointer
=	O
(	O
int32_t	int
)	O
-	O
(	O
uint32_t	int
)	O
*	O
v1	pointer
;	O
else	O
if	O
(	O
et	enum
==	O
NOT	int
)	O
*	O
v1	pointer
=	O
~	O
*	O
v1	pointer
;	O
else	O
if	O
(	O
et	enum
==	O
LNOT	int
)	O
*	O
v1	pointer
=	O
*	O
v1	pointer
==	O
0	int
?	O
1	int
:	O
0	int
;	O
}	O
else	O
if	O
(	O
(	O
er	enum
=	O
simple_term	function
(	O
et	enum
,	O
v1	pointer
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum
;	O
return	O
NO_ERROR	int
;	O
}	O
static	O
eval_error	enum
simple_term	function
(	O
eval_token	enum
et	enum
,	O
int32_t	int
*	O
v1	pointer
)	O
{	O
int32_t	int
v2	int
;	O
eval_error	enum
er	enum
;	O
switch	O
(	O
et	enum
)	O
{	O
case	O
LEFTP	int
:	O
et	enum
=	O
eval_lex	function
(	O
v1	pointer
)	O
;	O
if	O
(	O
et	enum
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
if	O
(	O
(	O
er	enum
=	O
logical_or_term	function
(	O
et	enum
,	O
v1	pointer
)	O
)	O
!=	O
NO_ERROR	int
)	O
return	O
er	enum
;	O
et	enum
=	O
eval_lex	function
(	O
&	O
v2	int
)	O
;	O
if	O
(	O
et	enum
==	O
ERROR	int
)	O
return	O
UNKNOWN_INPUT	int
;	O
if	O
(	O
et	enum
!=	O
RIGHTP	int
)	O
return	O
MISSING_RIGHT	int
;	O
break	O
;	O
case	O
NUMBER	int
:	O
break	O
;	O
case	O
BADOP	int
:	O
return	O
INVALID_OPERATOR	int
;	O
default	O
:	O
return	O
SYNTAX_ERROR	int
;	O
}	O
return	O
NO_ERROR	int
;	O
}	O
