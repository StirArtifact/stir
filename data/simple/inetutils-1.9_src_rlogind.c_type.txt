extern	O
int	O
__check_rhosts_file	int
;	O
struct	O
auth_data	struct
{	O
struct	O
sockaddr_in	struct
from	struct
;	O
char	O
*	O
hostname	pointer
;	O
char	O
*	O
lusername	pointer
;	O
char	O
*	O
rusername	pointer
;	O
char	O
*	O
term	pointer
;	O
char	O
*	O
env	array
[	O
2	int
]	O
;	O
}	O
;	O
int	O
mode	int
=	O
MODE_INETD	int
;	O
int	O
port	int
=	O
0	int
;	O
int	O
maxchildren	int
=	O
DEFMAXCHILDREN	int
;	O
int	O
allow_root	int
=	O
0	int
;	O
int	O
verify_hostname	int
=	O
0	int
;	O
int	O
keepalive	int
=	O
1	int
;	O
int	O
reverse_required	int
=	O
0	int
;	O
int	O
debug_level	int
=	O
0	int
;	O
int	O
numchildren	int
;	O
int	O
netf	int
;	O
char	O
line	pointer
[	O
1024	int
]	O
;	O
int	O
confirmed	int
;	O
const	O
char	O
*	O
path_login	pointer
=	O
PATH_LOGIN	O
;	O
char	O
*	O
local_domain_name	pointer
;	O
int	O
local_dot_count	int
;	O
struct	O
winsize	struct
win	struct
=	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
;	O
extern	O
int	O
iruserok	function
(	O
uint32_t	int
raddr	int
,	O
int	O
superuser	int
,	O
const	O
char	O
*	O
ruser	pointer
,	O
const	O
char	O
*	O
luser	pointer
)	O
;	O
void	O
rlogin_daemon	function
(	O
int	O
maxchildren	int
,	O
int	O
port	int
)	O
;	O
int	O
rlogind_auth	function
(	O
int	O
fd	int
,	O
struct	O
auth_data	struct
*	O
ap	pointer
)	O
;	O
void	O
setup_tty	function
(	O
int	O
fd	int
,	O
struct	O
auth_data	struct
*	O
ap	pointer
)	O
;	O
void	O
exec_login	function
(	O
int	O
authenticated	int
,	O
struct	O
auth_data	struct
*	O
ap	pointer
)	O
;	O
int	O
rlogind_mainloop	function
(	O
int	O
infd	int
,	O
int	O
outfd	int
)	O
;	O
int	O
do_rlogin	function
(	O
int	O
infd	int
,	O
struct	O
auth_data	struct
*	O
ap	pointer
)	O
;	O
int	O
do_krb_login	function
(	O
int	O
infd	int
,	O
struct	O
auth_data	struct
*	O
ap	pointer
,	O
const	O
char	O
*	O
*	O
msg	pointer
)	O
;	O
void	O
getstr	function
(	O
int	O
infd	int
,	O
char	O
*	O
*	O
ptr	char
,	O
const	O
char	O
*	O
prefix	pointer
)	O
;	O
void	O
protocol	char
(	O
int	O
f	int
,	O
int	O
p	int
,	O
struct	O
auth_data	struct
*	O
ap	pointer
)	O
;	O
int	O
control	function
(	O
int	O
pty	int
,	O
char	O
*	O
cp	pointer
,	O
size_t	long
n	long
)	O
;	O
void	O
cleanup	function
(	O
int	O
signo	int
)	O
;	O
void	O
fatal	function
(	O
int	O
f	int
,	O
const	O
char	O
*	O
msg	pointer
,	O
int	O
syserr	int
)	O
;	O
int	O
in_local_domain	function
(	O
char	O
*	O
hostname	pointer
)	O
;	O
char	O
*	O
topdomain	function
(	O
char	O
*	O
name	pointer
,	O
int	O
max_dots	int
)	O
;	O
void	O
rlogind_sigchld	function
(	O
int	O
sig	int
)	O
{	O
pid_t	int
pid	int
;	O
int	O
status	int
;	O
while	O
(	O
(	O
pid	int
=	O
waitpid	function
(	O
-	O
1	int
,	O
&	O
status	int
,	O
WNOHANG	int
)	O
)	O
>	O
0	int
)	O
--	O
numchildren	int
;	O
signal	function
(	O
sig	int
,	O
rlogind_sigchld	function
)	O
;	O
}	O
const	O
char	O
doc	pointer
[	O
]	O
=	O
"Remote login server"	pointer
;	O
const	O
char	O
*	O
program_authors	array
[	O
]	O
=	O
{	O
"Alain Magloire"	pointer
,	O
"Sergey Poznyakoff"	pointer
,	O
NULL	O
}	O
;	O
static	O
struct	O
argp_option	struct
options	pointer
[	O
]	O
=	O
{	O
{	O
"allow-root"	pointer
,	O
'o'	O
,	O
NULL	O
,	O
0	int
,	O
"allow uid == 0 to login, disabled by default"	pointer
}	O
,	O
{	O
"verify-hostname"	pointer
,	O
'a'	O
,	O
NULL	O
,	O
0	int
,	O
"ask hostname for verification"	pointer
}	O
,	O
{	O
"daemon"	pointer
,	O
'd'	O
,	O
NULL	O
,	O
0	int
,	O
"daemon mode"	pointer
}	O
,	O
{	O
"no-rhosts"	pointer
,	O
'l'	O
,	O
NULL	O
,	O
0	int
,	O
"ignore .rhosts file"	pointer
}	O
,	O
{	O
"no-keepalive"	pointer
,	O
'n'	O
,	O
NULL	O
,	O
0	int
,	O
"do not set SO_KEEPALIVE"	pointer
}	O
,	O
{	O
"local-domain"	pointer
,	O
'L'	O
,	O
"NAME"	pointer
,	O
0	int
,	O
"set local domain name"	pointer
}	O
,	O
{	O
"debug"	pointer
,	O
'D'	O
,	O
"LEVEL"	pointer
,	O
OPTION_ARG_OPTIONAL	int
,	O
"set debug level"	pointer
}	O
,	O
{	O
"port"	pointer
,	O
'p'	O
,	O
"PORT"	pointer
,	O
0	int
,	O
"listen on given port (valid only in daemon mode)"	pointer
}	O
,	O
{	O
"reverse-required"	pointer
,	O
'r'	O
,	O
NULL	O
,	O
0	int
,	O
"require reverse resolving of a remote host IP"	pointer
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
error_t	int
parse_opt	function
(	O
int	O
key	int
,	O
char	O
*	O
arg	pointer
,	O
struct	O
argp_state	struct
*	O
state	pointer
)	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
'a'	O
:	O
verify_hostname	int
=	O
1	int
;	O
break	O
;	O
case	O
'D'	O
:	O
if	O
(	O
arg	pointer
)	O
debug_level	int
=	O
strtoul	function
(	O
arg	pointer
,	O
NULL	O
,	O
10	int
)	O
;	O
break	O
;	O
case	O
'd'	O
:	O
mode	int
=	O
MODE_DAEMON	int
;	O
if	O
(	O
arg	pointer
)	O
maxchildren	int
=	O
strtoul	function
(	O
arg	pointer
,	O
NULL	O
,	O
10	int
)	O
;	O
if	O
(	O
maxchildren	int
==	O
0	int
)	O
maxchildren	int
=	O
DEFMAXCHILDREN	int
;	O
break	O
;	O
case	O
'l'	O
:	O
__check_rhosts_file	int
=	O
0	int
;	O
break	O
;	O
case	O
'L'	O
:	O
local_domain_name	pointer
=	O
arg	pointer
;	O
break	O
;	O
case	O
'n'	O
:	O
keepalive	int
=	O
0	int
;	O
break	O
;	O
case	O
'o'	O
:	O
allow_root	int
=	O
1	int
;	O
break	O
;	O
case	O
'p'	O
:	O
port	int
=	O
strtoul	function
(	O
arg	pointer
,	O
NULL	O
,	O
10	int
)	O
;	O
break	O
;	O
case	O
'r'	O
:	O
reverse_required	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
argp	struct
argp	struct
=	O
{	O
options	pointer
,	O
parse_opt	function
,	O
NULL	O
,	O
doc	pointer
}	O
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
int	O
index	function
;	O
set_program_name	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
iu_argp_init	O
(	O
"rlogind"	pointer
,	O
program_authors	array
)	O
;	O
argp_parse	function
(	O
&	O
argp	struct
,	O
argc	int
,	O
argv	pointer
,	O
0	int
,	O
&	O
index	function
,	O
NULL	O
)	O
;	O
openlog	function
(	O
"rlogind"	pointer
,	O
LOG_PID	int
|	O
LOG_CONS	int
,	O
LOG_AUTH	O
)	O
;	O
argc	int
-=	O
index	function
;	O
if	O
(	O
argc	int
>	O
0	int
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"%d extra arguments"	pointer
,	O
argc	int
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
signal	function
(	O
SIGHUP	int
,	O
SIG_IGN	O
)	O
;	O
if	O
(	O
!	O
local_domain_name	pointer
)	O
{	O
char	O
*	O
p	int
=	O
localhost	function
(	O
)	O
;	O
if	O
(	O
!	O
p	int
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"can't determine local hostname"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
local_dot_count	int
=	O
2	int
;	O
local_domain_name	pointer
=	O
topdomain	function
(	O
p	int
,	O
local_dot_count	int
)	O
;	O
}	O
else	O
{	O
char	O
*	O
p	int
;	O
local_dot_count	int
=	O
0	int
;	O
for	O
(	O
p	int
=	O
local_domain_name	pointer
;	O
*	O
p	int
;	O
p	int
++	O
)	O
if	O
(	O
*	O
p	int
==	O
'.'	O
)	O
local_dot_count	int
++	O
;	O
}	O
if	O
(	O
mode	int
==	O
MODE_DAEMON	int
)	O
rlogin_daemon	function
(	O
maxchildren	int
,	O
port	int
)	O
;	O
else	O
exit	function
(	O
rlogind_mainloop	function
(	O
fileno	function
(	O
stdin	pointer
)	O
,	O
fileno	function
(	O
stdout	pointer
)	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
void	O
rlogin_daemon	function
(	O
int	O
maxchildren	int
,	O
int	O
port	int
)	O
{	O
pid_t	int
pid	int
;	O
socklen_t	int
size	int
;	O
struct	O
sockaddr_in	struct
saddr	int
;	O
int	O
listenfd	int
,	O
fd	int
;	O
if	O
(	O
port	int
==	O
0	int
)	O
{	O
struct	O
servent	struct
*	O
svp	pointer
;	O
svp	pointer
=	O
getservbyname	function
(	O
"login"	pointer
,	O
"tcp"	pointer
)	O
;	O
if	O
(	O
svp	pointer
!=	O
NULL	O
)	O
port	int
=	O
ntohs	function
(	O
svp	pointer
->	O
s_port	int
)	O
;	O
else	O
port	int
=	O
DEFPORT	int
;	O
}	O
if	O
(	O
daemon	function
(	O
0	int
,	O
0	int
)	O
<	O
0	int
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"failed to become a daemon %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
fatal	function
(	O
fileno	function
(	O
stderr	pointer
)	O
,	O
"fork failed, exiting"	pointer
,	O
0	int
)	O
;	O
}	O
signal	function
(	O
SIGCHLD	int
,	O
rlogind_sigchld	function
)	O
;	O
listenfd	int
=	O
socket	function
(	O
AF_INET	O
,	O
SOCK_STREAM	int
,	O
0	int
)	O
;	O
if	O
(	O
listenfd	int
==	O
-	O
1	int
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"socket: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
{	O
int	O
on	int
=	O
1	int
;	O
setsockopt	function
(	O
listenfd	int
,	O
SOL_SOCKET	int
,	O
SO_REUSEADDR	int
,	O
&	O
on	int
,	O
sizeof	O
on	int
)	O
;	O
}	O
size	int
=	O
sizeof	O
saddr	int
;	O
memset	function
(	O
&	O
saddr	int
,	O
0	int
,	O
size	int
)	O
;	O
saddr	int
.	O
sin_family	short
=	O
AF_INET	O
;	O
saddr	int
.	O
sin_addr	struct
.	O
s_addr	int
=	O
htonl	function
(	O
INADDR_ANY	O
)	O
;	O
saddr	int
.	O
sin_port	short
=	O
htons	function
(	O
port	int
)	O
;	O
size	int
=	O
sizeof	O
saddr	int
;	O
if	O
(	O
bind	function
(	O
listenfd	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
saddr	int
,	O
size	int
)	O
==	O
-	O
1	int
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"bind: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
listen	function
(	O
listenfd	int
,	O
128	int
)	O
==	O
-	O
1	int
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"listen: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
numchildren	int
>	O
maxchildren	int
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"too many children (%d)"	pointer
,	O
numchildren	int
)	O
;	O
pause	function
(	O
)	O
;	O
continue	O
;	O
}	O
size	int
=	O
sizeof	O
saddr	int
;	O
fd	int
=	O
accept	function
(	O
listenfd	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
saddr	int
,	O
&	O
size	int
)	O
;	O
if	O
(	O
fd	int
==	O
-	O
1	int
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
syslog	function
(	O
LOG_ERR	int
,	O
"accept: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
pid	int
=	O
fork	function
(	O
)	O
;	O
if	O
(	O
pid	int
==	O
-	O
1	int
)	O
syslog	function
(	O
LOG_ERR	int
,	O
"fork: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
else	O
if	O
(	O
pid	int
==	O
0	int
)	O
{	O
close	pointer
(	O
listenfd	int
)	O
;	O
exit	function
(	O
rlogind_mainloop	function
(	O
fd	int
,	O
fd	int
)	O
)	O
;	O
}	O
else	O
numchildren	int
++	O
;	O
close	pointer
(	O
fd	int
)	O
;	O
}	O
}	O
int	O
rlogind_auth	function
(	O
int	O
fd	int
,	O
struct	O
auth_data	struct
*	O
ap	pointer
)	O
{	O
struct	O
hostent	struct
*	O
hp	pointer
;	O
char	O
*	O
hostname	pointer
;	O
int	O
authenticated	int
=	O
0	int
;	O
confirmed	int
=	O
0	int
;	O
hp	pointer
=	O
gethostbyaddr	function
(	O
(	O
char	O
*	O
)	O
&	O
ap	pointer
->	O
from	struct
.	O
sin_addr	struct
,	O
sizeof	O
(	O
struct	O
in_addr	struct
)	O
,	O
ap	pointer
->	O
from	struct
.	O
sin_family	short
)	O
;	O
if	O
(	O
hp	pointer
)	O
hostname	pointer
=	O
hp	pointer
->	O
h_name	pointer
;	O
else	O
if	O
(	O
reverse_required	int
)	O
{	O
syslog	function
(	O
LOG_CRIT	int
,	O
"can't resolve remote IP address"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
else	O
hostname	pointer
=	O
inet_ntoa	function
(	O
ap	pointer
->	O
from	struct
.	O
sin_addr	struct
)	O
;	O
ap	pointer
->	O
hostname	pointer
=	O
strdup	function
(	O
hostname	pointer
)	O
;	O
if	O
(	O
verify_hostname	int
||	O
in_local_domain	function
(	O
ap	pointer
->	O
hostname	pointer
)	O
)	O
{	O
int	O
match	int
=	O
0	int
;	O
for	O
(	O
hp	pointer
=	O
gethostbyname	function
(	O
ap	pointer
->	O
hostname	pointer
)	O
;	O
hp	pointer
&&	O
!	O
match	int
;	O
hp	pointer
->	O
h_addr_list	pointer
++	O
)	O
{	O
if	O
(	O
hp	pointer
->	O
h_addr_list	pointer
[	O
0	int
]	O
==	O
NULL	O
)	O
break	O
;	O
match	int
=	O
memcmp	function
(	O
hp	pointer
->	O
h_addr_list	pointer
[	O
0	int
]	O
,	O
&	O
ap	pointer
->	O
from	struct
.	O
sin_addr	struct
,	O
sizeof	O
(	O
ap	pointer
->	O
from	struct
.	O
sin_addr	struct
)	O
)	O
==	O
0	int
;	O
}	O
if	O
(	O
!	O
match	int
)	O
{	O
syslog	function
(	O
LOG_ERR	int
|	O
LOG_AUTH	O
,	O
"cannot find matching IP for %s (%s)"	pointer
,	O
ap	pointer
->	O
hostname	pointer
,	O
inet_ntoa	function
(	O
ap	pointer
->	O
from	struct
.	O
sin_addr	struct
)	O
)	O
;	O
fatal	function
(	O
fd	int
,	O
"Permission denied"	pointer
,	O
0	int
)	O
;	O
}	O
}	O
{	O
int	O
port	int
=	O
ntohs	function
(	O
ap	pointer
->	O
from	struct
.	O
sin_port	short
)	O
;	O
if	O
(	O
ap	pointer
->	O
from	struct
.	O
sin_family	short
!=	O
AF_INET	O
||	O
port	int
>=	O
IPPORT_RESERVED	int
||	O
port	int
<	O
IPPORT_RESERVED	int
/	O
2	int
)	O
{	O
syslog	function
(	O
LOG_NOTICE	int
,	O
"Connection from %s on illegal port %d"	pointer
,	O
inet_ntoa	function
(	O
ap	pointer
->	O
from	struct
.	O
sin_addr	struct
)	O
,	O
port	int
)	O
;	O
fatal	function
(	O
fd	int
,	O
"Permission denied"	pointer
,	O
0	int
)	O
;	O
}	O
{	O
unsigned	O
char	O
optbuf	array
[	O
BUFSIZ	int
/	O
3	int
]	O
,	O
*	O
cp	pointer
;	O
char	O
lbuf	array
[	O
BUFSIZ	int
]	O
,	O
*	O
lp	pointer
;	O
socklen_t	int
optsize	int
=	O
sizeof	O
(	O
optbuf	array
)	O
;	O
int	O
ipproto	int
;	O
struct	O
protoent	struct
*	O
ip	struct
;	O
if	O
(	O
(	O
ip	struct
=	O
getprotobyname	function
(	O
"ip"	pointer
)	O
)	O
!=	O
NULL	O
)	O
ipproto	int
=	O
ip	struct
->	O
p_proto	int
;	O
else	O
ipproto	int
=	O
IPPROTO_IP	int
;	O
if	O
(	O
getsockopt	function
(	O
0	int
,	O
ipproto	int
,	O
IP_OPTIONS	int
,	O
(	O
char	O
*	O
)	O
optbuf	array
,	O
&	O
optsize	int
)	O
==	O
0	int
&&	O
optsize	int
!=	O
0	int
)	O
{	O
lp	pointer
=	O
lbuf	array
;	O
for	O
(	O
cp	pointer
=	O
optbuf	array
;	O
optsize	int
>	O
0	int
;	O
)	O
{	O
sprintf	function
(	O
lp	pointer
,	O
" %2.2x"	pointer
,	O
*	O
cp	pointer
)	O
;	O
lp	pointer
+=	O
3	int
;	O
if	O
(	O
*	O
cp	pointer
==	O
IPOPT_SSRR	int
||	O
*	O
cp	pointer
==	O
IPOPT_LSRR	int
)	O
{	O
syslog	function
(	O
LOG_NOTICE	int
,	O
"Discarding connection from %s with set source routing"	pointer
,	O
inet_ntoa	function
(	O
ap	pointer
->	O
from	struct
.	O
sin_addr	struct
)	O
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
*	O
cp	pointer
==	O
IPOPT_EOL	int
)	O
break	O
;	O
if	O
(	O
*	O
cp	pointer
==	O
IPOPT_NOP	int
)	O
cp	pointer
++	O
,	O
optsize	int
--	O
;	O
else	O
{	O
int	O
inc	int
=	O
cp	pointer
[	O
1	int
]	O
;	O
optsize	int
-=	O
inc	int
;	O
cp	pointer
+=	O
inc	int
;	O
}	O
}	O
syslog	function
(	O
LOG_NOTICE	int
,	O
"Ignoring IP options: %s"	pointer
,	O
lbuf	array
)	O
;	O
if	O
(	O
setsockopt	function
(	O
0	int
,	O
ipproto	int
,	O
IP_OPTIONS	int
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
optsize	int
)	O
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"setsockopt IP_OPTIONS NULL: %m"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
do_rlogin	function
(	O
fd	int
,	O
ap	pointer
)	O
==	O
0	int
)	O
authenticated	int
++	O
;	O
}	O
if	O
(	O
confirmed	int
==	O
0	int
)	O
{	O
write	pointer
(	O
fd	int
,	O
""	pointer
,	O
1	int
)	O
;	O
confirmed	int
=	O
1	int
;	O
}	O
IF_ENCRYPT	O
(	O
des_write	O
(	O
fd	int
,	O
SECURE_MESSAGE	O
,	O
sizeof	O
(	O
SECURE_MESSAGE	O
)	O
-	O
1	int
)	O
)	O
;	O
return	O
authenticated	int
;	O
}	O
void	O
setup_tty	function
(	O
int	O
fd	int
,	O
struct	O
auth_data	struct
*	O
ap	pointer
)	O
{	O
register	O
char	O
*	O
cp	pointer
=	O
strchr	function
(	O
ap	pointer
->	O
term	pointer
+	O
ENVSIZE	O
,	O
'/'	O
)	O
;	O
char	O
*	O
speed	pointer
;	O
struct	O
termios	struct
tt	struct
;	O
tcgetattr	function
(	O
fd	int
,	O
&	O
tt	struct
)	O
;	O
if	O
(	O
cp	pointer
)	O
{	O
*	O
cp	pointer
++	O
=	O
'\0'	O
;	O
speed	pointer
=	O
cp	pointer
;	O
cp	pointer
=	O
strchr	function
(	O
speed	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
cp	pointer
)	O
*	O
cp	pointer
++	O
=	O
'\0'	O
;	O
cfsetspeed	function
(	O
&	O
tt	struct
,	O
strtoul	function
(	O
speed	pointer
,	O
NULL	O
,	O
10	int
)	O
)	O
;	O
}	O
tt	struct
.	O
c_iflag	int
=	O
TTYDEF_IFLAG	O
;	O
tt	struct
.	O
c_oflag	int
=	O
TTYDEF_OFLAG	O
;	O
tt	struct
.	O
c_lflag	int
=	O
TTYDEF_LFLAG	O
;	O
tcsetattr	function
(	O
fd	int
,	O
TCSAFLUSH	int
,	O
&	O
tt	struct
)	O
;	O
ap	pointer
->	O
env	array
[	O
0	int
]	O
=	O
ap	pointer
->	O
term	pointer
;	O
ap	pointer
->	O
env	array
[	O
1	int
]	O
=	O
0	int
;	O
}	O
void	O
exec_login	function
(	O
int	O
authenticated	int
,	O
struct	O
auth_data	struct
*	O
ap	pointer
)	O
{	O
if	O
(	O
authenticated	int
)	O
{	O
execle	function
(	O
path_login	pointer
,	O
"login"	pointer
,	O
"-p"	pointer
,	O
"-h"	pointer
,	O
ap	pointer
->	O
hostname	pointer
,	O
"-f"	pointer
,	O
ap	pointer
->	O
lusername	pointer
,	O
NULL	O
,	O
ap	pointer
->	O
env	array
)	O
;	O
}	O
else	O
{	O
execle	function
(	O
path_login	pointer
,	O
"login"	pointer
,	O
"-p"	pointer
,	O
"-h"	pointer
,	O
ap	pointer
->	O
hostname	pointer
,	O
ap	pointer
->	O
lusername	pointer
,	O
NULL	O
,	O
ap	pointer
->	O
env	array
)	O
;	O
}	O
syslog	function
(	O
LOG_ERR	int
,	O
"can't exec login: %m"	pointer
)	O
;	O
}	O
int	O
rlogind_mainloop	function
(	O
int	O
infd	int
,	O
int	O
outfd	int
)	O
{	O
socklen_t	int
size	int
;	O
struct	O
auth_data	struct
auth_data	struct
;	O
int	O
true	int
;	O
char	O
c	char
;	O
int	O
authenticated	int
;	O
pid_t	int
pid	int
;	O
int	O
master	int
;	O
memset	function
(	O
&	O
auth_data	struct
,	O
0	int
,	O
sizeof	O
auth_data	struct
)	O
;	O
size	int
=	O
sizeof	O
auth_data	struct
.	O
from	struct
;	O
if	O
(	O
getpeername	function
(	O
infd	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
auth_data	struct
.	O
from	struct
,	O
&	O
size	int
)	O
<	O
0	int
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"Can't get peer name of remote host: %m"	pointer
)	O
;	O
fatal	function
(	O
outfd	int
,	O
"Can't get peer name of remote host"	pointer
,	O
1	int
)	O
;	O
}	O
syslog	function
(	O
LOG_INFO	int
,	O
"Connect from %s:%d"	pointer
,	O
inet_ntoa	function
(	O
auth_data	struct
.	O
from	struct
.	O
sin_addr	struct
)	O
,	O
ntohs	function
(	O
auth_data	struct
.	O
from	struct
.	O
sin_port	short
)	O
)	O
;	O
true	int
=	O
1	int
;	O
if	O
(	O
keepalive	int
&&	O
setsockopt	function
(	O
infd	int
,	O
SOL_SOCKET	int
,	O
SO_KEEPALIVE	int
,	O
&	O
true	int
,	O
sizeof	O
true	int
)	O
<	O
0	int
)	O
syslog	function
(	O
LOG_WARNING	int
,	O
"setsockopt (SO_KEEPALIVE): %m"	pointer
)	O
;	O
true	int
=	O
IPTOS_LOWDELAY	int
;	O
if	O
(	O
setsockopt	function
(	O
infd	int
,	O
IPPROTO_IP	int
,	O
IP_TOS	int
,	O
(	O
char	O
*	O
)	O
&	O
true	int
,	O
sizeof	O
true	int
)	O
<	O
0	int
)	O
syslog	function
(	O
LOG_WARNING	int
,	O
"setsockopt (IP_TOS): %m"	pointer
)	O
;	O
alarm	function
(	O
60	int
)	O
;	O
if	O
(	O
read	pointer
(	O
infd	int
,	O
&	O
c	char
,	O
1	int
)	O
!=	O
1	int
||	O
c	char
!=	O
0	int
)	O
{	O
syslog	function
(	O
LOG_CRIT	int
,	O
"protocol error: expected 0 byte"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
alarm	function
(	O
0	int
)	O
;	O
authenticated	int
=	O
rlogind_auth	function
(	O
infd	int
,	O
&	O
auth_data	struct
)	O
;	O
pid	int
=	O
forkpty	function
(	O
&	O
master	int
,	O
line	pointer
,	O
NULL	O
,	O
&	O
win	struct
)	O
;	O
if	O
(	O
pid	int
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
ENOENT	int
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"Out of ptys"	pointer
)	O
;	O
fatal	function
(	O
infd	int
,	O
"Out of ptys"	pointer
,	O
0	int
)	O
;	O
}	O
else	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"forkpty: %m"	pointer
)	O
;	O
fatal	function
(	O
infd	int
,	O
"Forkpty"	pointer
,	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
pid	int
==	O
0	int
)	O
{	O
if	O
(	O
infd	int
>	O
2	int
)	O
close	pointer
(	O
infd	int
)	O
;	O
setup_tty	function
(	O
0	int
,	O
&	O
auth_data	struct
)	O
;	O
setup_utmp	O
(	O
line	pointer
)	O
;	O
exec_login	function
(	O
authenticated	int
,	O
&	O
auth_data	struct
)	O
;	O
fatal	function
(	O
infd	int
,	O
"can't execute login"	pointer
,	O
1	int
)	O
;	O
}	O
true	int
=	O
1	int
;	O
IF_NOT_ENCRYPT	O
(	O
ioctl	function
(	O
infd	int
,	O
FIONBIO	int
,	O
&	O
true	int
)	O
)	O
;	O
ioctl	function
(	O
master	int
,	O
FIONBIO	int
,	O
&	O
true	int
)	O
;	O
ioctl	function
(	O
master	int
,	O
TIOCPKT	int
,	O
&	O
true	int
)	O
;	O
netf	int
=	O
infd	int
;	O
signal	function
(	O
SIGCHLD	int
,	O
cleanup	function
)	O
;	O
protocol	char
(	O
infd	int
,	O
master	int
,	O
&	O
auth_data	struct
)	O
;	O
signal	function
(	O
SIGCHLD	int
,	O
SIG_IGN	O
)	O
;	O
cleanup	function
(	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
int	O
do_rlogin	function
(	O
int	O
infd	int
,	O
struct	O
auth_data	struct
*	O
ap	pointer
)	O
{	O
struct	O
passwd	struct
*	O
pwd	pointer
;	O
int	O
rc	int
;	O
getstr	function
(	O
infd	int
,	O
&	O
ap	pointer
->	O
rusername	pointer
,	O
NULL	O
)	O
;	O
getstr	function
(	O
infd	int
,	O
&	O
ap	pointer
->	O
lusername	pointer
,	O
NULL	O
)	O
;	O
getstr	function
(	O
infd	int
,	O
&	O
ap	pointer
->	O
term	pointer
,	O
"TERM="	pointer
)	O
;	O
pwd	pointer
=	O
getpwnam	function
(	O
ap	pointer
->	O
lusername	pointer
)	O
;	O
if	O
(	O
pwd	pointer
==	O
NULL	O
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"no passwd entry for %s"	pointer
,	O
ap	pointer
->	O
lusername	pointer
)	O
;	O
fatal	function
(	O
infd	int
,	O
"Permission denied"	pointer
,	O
0	int
)	O
;	O
}	O
if	O
(	O
!	O
allow_root	int
&&	O
pwd	pointer
->	O
pw_uid	int
==	O
0	int
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"root logins not permitted"	pointer
)	O
;	O
fatal	function
(	O
infd	int
,	O
"Permission denied"	pointer
,	O
0	int
)	O
;	O
}	O
rc	int
=	O
iruserok	function
(	O
ap	pointer
->	O
from	struct
.	O
sin_addr	struct
.	O
s_addr	int
,	O
0	int
,	O
ap	pointer
->	O
rusername	pointer
,	O
ap	pointer
->	O
lusername	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
syslog	function
(	O
LOG_ERR	int
,	O
"iruserok failed: rusername=%s, lusername=%s"	pointer
,	O
ap	pointer
->	O
rusername	pointer
,	O
ap	pointer
->	O
lusername	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
void	O
getstr	function
(	O
int	O
infd	int
,	O
char	O
*	O
*	O
ptr	char
,	O
const	O
char	O
*	O
prefix	pointer
)	O
{	O
char	O
c	char
;	O
char	O
*	O
buf	pointer
;	O
int	O
pos	int
;	O
int	O
size	int
=	O
BUFFER_SIZE	int
;	O
if	O
(	O
prefix	pointer
)	O
{	O
int	O
len	char
=	O
strlen	function
(	O
prefix	pointer
)	O
;	O
if	O
(	O
size	int
<	O
len	char
+	O
1	int
)	O
size	int
=	O
len	char
+	O
1	int
;	O
}	O
buf	pointer
=	O
malloc	function
(	O
size	int
)	O
;	O
if	O
(	O
!	O
buf	pointer
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"not enough memory"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
pos	int
=	O
0	int
;	O
if	O
(	O
prefix	pointer
)	O
{	O
strcpy	function
(	O
buf	pointer
,	O
prefix	pointer
)	O
;	O
pos	int
+=	O
strlen	function
(	O
buf	pointer
)	O
;	O
}	O
do	O
{	O
if	O
(	O
read	pointer
(	O
infd	int
,	O
&	O
c	char
,	O
1	int
)	O
!=	O
1	int
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"read error: %m"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
pos	int
==	O
size	int
)	O
{	O
size	int
+=	O
BUFFER_SIZE	int
;	O
buf	pointer
=	O
realloc	function
(	O
buf	pointer
,	O
size	int
)	O
;	O
if	O
(	O
!	O
buf	pointer
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"not enough memory"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
buf	pointer
[	O
pos	int
++	O
]	O
=	O
c	char
;	O
}	O
while	O
(	O
c	char
!=	O
0	int
)	O
;	O
*	O
ptr	char
=	O
buf	pointer
;	O
}	O
char	O
magic	array
[	O
2	int
]	O
=	O
{	O
0377	int
,	O
0377	int
}	O
;	O
char	O
oobdata	array
[	O
]	O
=	O
{	O
TIOCPKT_WINDOW	int
}	O
;	O
void	O
protocol	char
(	O
int	O
f	int
,	O
int	O
p	int
,	O
struct	O
auth_data	struct
*	O
ap	pointer
)	O
{	O
char	O
fibuf	array
[	O
1024	int
]	O
,	O
*	O
pbp	pointer
=	O
NULL	O
,	O
*	O
fbp	pointer
=	O
NULL	O
;	O
int	O
pcc	int
=	O
0	int
,	O
fcc	int
=	O
0	int
;	O
int	O
cc	int
,	O
nfd	int
,	O
n	long
;	O
char	O
cntl	char
;	O
signal	function
(	O
SIGTTOU	int
,	O
SIG_IGN	O
)	O
;	O
send	function
(	O
f	int
,	O
oobdata	array
,	O
1	int
,	O
MSG_OOB	int
)	O
;	O
if	O
(	O
f	int
>	O
p	int
)	O
nfd	int
=	O
f	int
+	O
1	int
;	O
else	O
nfd	int
=	O
p	int
+	O
1	int
;	O
if	O
(	O
nfd	int
>	O
FD_SETSIZE	O
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"select mask too small, increase FD_SETSIZE"	pointer
)	O
;	O
fatal	function
(	O
f	int
,	O
"internal error (select mask too small)"	pointer
,	O
0	int
)	O
;	O
}	O
while	O
(	O
1	int
)	O
{	O
fd_set	struct
ibits	struct
,	O
obits	struct
,	O
ebits	struct
,	O
*	O
omask	pointer
;	O
FD_ZERO	O
(	O
&	O
ebits	struct
)	O
;	O
FD_ZERO	O
(	O
&	O
ibits	struct
)	O
;	O
FD_ZERO	O
(	O
&	O
obits	struct
)	O
;	O
omask	pointer
=	O
(	O
fd_set	struct
*	O
)	O
NULL	O
;	O
if	O
(	O
fcc	int
)	O
{	O
FD_SET	O
(	O
p	int
,	O
&	O
obits	struct
)	O
;	O
omask	pointer
=	O
&	O
obits	struct
;	O
}	O
else	O
FD_SET	O
(	O
f	int
,	O
&	O
ibits	struct
)	O
;	O
if	O
(	O
pcc	int
>=	O
0	int
)	O
{	O
if	O
(	O
pcc	int
)	O
{	O
FD_SET	O
(	O
f	int
,	O
&	O
obits	struct
)	O
;	O
omask	pointer
=	O
&	O
obits	struct
;	O
}	O
else	O
FD_SET	O
(	O
p	int
,	O
&	O
ibits	struct
)	O
;	O
}	O
FD_SET	O
(	O
p	int
,	O
&	O
ebits	struct
)	O
;	O
if	O
(	O
(	O
n	long
=	O
select	function
(	O
nfd	int
,	O
&	O
ibits	struct
,	O
omask	pointer
,	O
&	O
ebits	struct
,	O
0	int
)	O
)	O
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
fatal	function
(	O
f	int
,	O
"select"	pointer
,	O
1	int
)	O
;	O
}	O
if	O
(	O
n	long
==	O
0	int
)	O
{	O
sleep	function
(	O
5	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
FD_ISSET	O
(	O
p	int
,	O
&	O
ebits	struct
)	O
)	O
{	O
cc	int
=	O
read	pointer
(	O
p	int
,	O
&	O
cntl	char
,	O
1	int
)	O
;	O
if	O
(	O
cc	int
==	O
1	int
&&	O
pkcontrol	O
(	O
cntl	char
)	O
)	O
{	O
cntl	char
|=	O
oobdata	array
[	O
0	int
]	O
;	O
send	function
(	O
f	int
,	O
&	O
cntl	char
,	O
1	int
,	O
MSG_OOB	int
)	O
;	O
if	O
(	O
cntl	char
&	O
TIOCPKT_FLUSHWRITE	int
)	O
{	O
pcc	int
=	O
0	int
;	O
FD_CLR	O
(	O
p	int
,	O
&	O
ibits	struct
)	O
;	O
}	O
}	O
}	O
if	O
(	O
FD_ISSET	O
(	O
f	int
,	O
&	O
ibits	struct
)	O
)	O
{	O
ENC_READ	O
(	O
fcc	int
,	O
f	int
,	O
fibuf	array
,	O
sizeof	O
(	O
fibuf	array
)	O
,	O
ap	pointer
)	O
;	O
if	O
(	O
fcc	int
<	O
0	int
&&	O
errno	O
==	O
EWOULDBLOCK	O
)	O
fcc	int
=	O
0	int
;	O
else	O
{	O
register	O
char	O
*	O
cp	pointer
;	O
int	O
left	int
;	O
if	O
(	O
fcc	int
<=	O
0	int
)	O
break	O
;	O
fbp	pointer
=	O
fibuf	array
;	O
for	O
(	O
cp	pointer
=	O
fibuf	array
;	O
cp	pointer
<	O
fibuf	array
+	O
fcc	int
-	O
1	int
;	O
cp	pointer
++	O
)	O
if	O
(	O
cp	pointer
[	O
0	int
]	O
==	O
magic	array
[	O
0	int
]	O
&&	O
cp	pointer
[	O
1	int
]	O
==	O
magic	array
[	O
1	int
]	O
)	O
{	O
int	O
len	char
;	O
left	int
=	O
fcc	int
-	O
(	O
cp	pointer
-	O
fibuf	array
)	O
;	O
len	char
=	O
control	function
(	O
p	int
,	O
cp	pointer
,	O
left	int
)	O
;	O
if	O
(	O
len	char
)	O
{	O
left	int
-=	O
len	char
;	O
if	O
(	O
left	int
>	O
0	int
)	O
memmove	function
(	O
cp	pointer
,	O
cp	pointer
+	O
len	char
,	O
left	int
)	O
;	O
fcc	int
-=	O
len	char
;	O
cp	pointer
--	O
;	O
}	O
}	O
FD_SET	O
(	O
p	int
,	O
&	O
obits	struct
)	O
;	O
}	O
}	O
if	O
(	O
FD_ISSET	O
(	O
p	int
,	O
&	O
obits	struct
)	O
&&	O
fcc	int
>	O
0	int
)	O
{	O
cc	int
=	O
write	pointer
(	O
p	int
,	O
fbp	pointer
,	O
fcc	int
)	O
;	O
if	O
(	O
cc	int
>	O
0	int
)	O
{	O
fcc	int
-=	O
cc	int
;	O
fbp	pointer
+=	O
cc	int
;	O
}	O
}	O
if	O
(	O
FD_ISSET	O
(	O
p	int
,	O
&	O
ibits	struct
)	O
)	O
{	O
char	O
dbuf	array
[	O
1024	int
+	O
1	int
]	O
;	O
pcc	int
=	O
read	pointer
(	O
p	int
,	O
dbuf	array
,	O
sizeof	O
dbuf	array
)	O
;	O
pbp	pointer
=	O
dbuf	array
;	O
if	O
(	O
pcc	int
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
EWOULDBLOCK	O
)	O
pcc	int
=	O
0	int
;	O
else	O
break	O
;	O
}	O
else	O
if	O
(	O
pcc	int
==	O
0	int
)	O
{	O
break	O
;	O
}	O
else	O
if	O
(	O
dbuf	array
[	O
0	int
]	O
==	O
0	int
)	O
{	O
pbp	pointer
++	O
;	O
pcc	int
--	O
;	O
IF_NOT_ENCRYPT	O
(	O
FD_SET	O
(	O
f	int
,	O
&	O
obits	struct
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
pkcontrol	O
(	O
dbuf	array
[	O
0	int
]	O
)	O
)	O
{	O
dbuf	array
[	O
0	int
]	O
|=	O
oobdata	array
[	O
0	int
]	O
;	O
send	function
(	O
f	int
,	O
&	O
dbuf	array
[	O
0	int
]	O
,	O
1	int
,	O
MSG_OOB	int
)	O
;	O
}	O
pcc	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
(	O
FD_ISSET	O
(	O
f	int
,	O
&	O
obits	struct
)	O
)	O
&&	O
pcc	int
>	O
0	int
)	O
{	O
ENC_WRITE	O
(	O
cc	int
,	O
f	int
,	O
pbp	pointer
,	O
pcc	int
,	O
ap	pointer
)	O
;	O
if	O
(	O
cc	int
<	O
0	int
&&	O
errno	O
==	O
EWOULDBLOCK	O
)	O
{	O
if	O
(	O
!	O
FD_ISSET	O
(	O
p	int
,	O
&	O
ibits	struct
)	O
)	O
sleep	function
(	O
5	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
cc	int
>	O
0	int
)	O
{	O
pcc	int
-=	O
cc	int
;	O
pbp	pointer
+=	O
cc	int
;	O
}	O
}	O
}	O
}	O
int	O
control	function
(	O
int	O
pty	int
,	O
char	O
*	O
cp	pointer
,	O
size_t	long
n	long
)	O
{	O
struct	O
winsize	struct
w	struct
;	O
if	O
(	O
n	long
<	O
4	int
+	O
sizeof	O
(	O
w	struct
)	O
||	O
cp	pointer
[	O
2	int
]	O
!=	O
's'	O
||	O
cp	pointer
[	O
3	int
]	O
!=	O
's'	O
)	O
return	O
(	O
0	int
)	O
;	O
oobdata	array
[	O
0	int
]	O
&=	O
~	O
TIOCPKT_WINDOW	int
;	O
memmove	function
(	O
&	O
w	struct
,	O
cp	pointer
+	O
4	int
,	O
sizeof	O
w	struct
)	O
;	O
w	struct
.	O
ws_row	short
=	O
ntohs	function
(	O
w	struct
.	O
ws_row	short
)	O
;	O
w	struct
.	O
ws_col	short
=	O
ntohs	function
(	O
w	struct
.	O
ws_col	short
)	O
;	O
w	struct
.	O
ws_xpixel	short
=	O
ntohs	function
(	O
w	struct
.	O
ws_xpixel	short
)	O
;	O
w	struct
.	O
ws_ypixel	short
=	O
ntohs	function
(	O
w	struct
.	O
ws_ypixel	short
)	O
;	O
ioctl	function
(	O
pty	int
,	O
TIOCSWINSZ	int
,	O
&	O
w	struct
)	O
;	O
return	O
(	O
4	int
+	O
sizeof	O
w	struct
)	O
;	O
}	O
void	O
cleanup	function
(	O
int	O
signo	int
_GL_UNUSED_PARAMETER	O
)	O
{	O
char	O
*	O
p	int
;	O
p	int
=	O
line	pointer
+	O
sizeof	O
(	O
PATH_DEV	O
)	O
-	O
1	int
;	O
if	O
(	O
logout	function
(	O
p	int
)	O
)	O
logwtmp	function
(	O
p	int
,	O
""	pointer
,	O
""	pointer
)	O
;	O
chmod	function
(	O
line	pointer
,	O
0666	int
)	O
;	O
chown	function
(	O
line	pointer
,	O
0	int
,	O
0	int
)	O
;	O
*	O
p	int
=	O
'p'	O
;	O
chmod	function
(	O
line	pointer
,	O
0666	int
)	O
;	O
chown	function
(	O
line	pointer
,	O
0	int
,	O
0	int
)	O
;	O
shutdown	function
(	O
netf	int
,	O
2	int
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
int	O
in_local_domain	function
(	O
char	O
*	O
hostname	pointer
)	O
{	O
char	O
*	O
p	int
=	O
topdomain	function
(	O
hostname	pointer
,	O
local_dot_count	int
)	O
;	O
return	O
p	int
&&	O
strcasecmp	function
(	O
p	int
,	O
local_domain_name	pointer
)	O
==	O
0	int
;	O
}	O
char	O
*	O
topdomain	function
(	O
char	O
*	O
name	pointer
,	O
int	O
max_dots	int
)	O
{	O
char	O
*	O
p	int
;	O
int	O
dot_count	int
=	O
0	int
;	O
for	O
(	O
p	int
=	O
name	pointer
+	O
strlen	function
(	O
name	pointer
)	O
-	O
1	int
;	O
p	int
>=	O
name	pointer
;	O
p	int
--	O
)	O
{	O
if	O
(	O
*	O
p	int
==	O
'.'	O
&&	O
++	O
dot_count	int
==	O
max_dots	int
)	O
return	O
p	int
+	O
1	int
;	O
}	O
return	O
name	pointer
;	O
}	O
void	O
fatal	function
(	O
int	O
f	int
,	O
const	O
char	O
*	O
msg	pointer
,	O
int	O
syserr	int
)	O
{	O
int	O
len	char
;	O
char	O
buf	pointer
[	O
BUFSIZ	int
]	O
,	O
*	O
bp	pointer
=	O
buf	pointer
;	O
if	O
(	O
!	O
confirmed	int
)	O
*	O
bp	pointer
++	O
=	O
'\01'	O
;	O
if	O
(	O
syserr	int
)	O
snprintf	function
(	O
bp	pointer
,	O
sizeof	O
buf	pointer
-	O
(	O
bp	pointer
-	O
buf	pointer
)	O
,	O
"rlogind: %s: %s.\r\n"	pointer
,	O
msg	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
else	O
snprintf	function
(	O
bp	pointer
,	O
sizeof	O
buf	pointer
-	O
(	O
bp	pointer
-	O
buf	pointer
)	O
,	O
"rlogind: %s.\r\n"	pointer
,	O
msg	pointer
)	O
;	O
len	char
=	O
strlen	function
(	O
bp	pointer
)	O
;	O
write	pointer
(	O
f	int
,	O
buf	pointer
,	O
bp	pointer
+	O
len	char
-	O
buf	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
