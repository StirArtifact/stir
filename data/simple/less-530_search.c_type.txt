extern	O
int	O
sigs	int
;	O
extern	O
int	O
how_search	int
;	O
extern	O
int	O
caseless	int
;	O
extern	O
int	O
linenums	int
;	O
extern	O
int	O
sc_height	int
;	O
extern	O
int	O
jump_sline	int
;	O
extern	O
int	O
bs_mode	int
;	O
extern	O
int	O
ctldisp	int
;	O
extern	O
int	O
status_col	int
;	O
extern	O
void	O
*	O
ml_search	pointer
;	O
extern	O
POSITION	long
start_attnpos	long
;	O
extern	O
POSITION	long
end_attnpos	long
;	O
extern	O
int	O
utf_mode	int
;	O
extern	O
int	O
screen_trashed	int
;	O
extern	O
int	O
hilite_search	int
;	O
extern	O
int	O
size_linebuf	int
;	O
extern	O
int	O
squished	int
;	O
extern	O
int	O
can_goto_line	int
;	O
static	O
int	O
hide_hilite	int
;	O
static	O
POSITION	long
prep_startpos	long
;	O
static	O
POSITION	long
prep_endpos	long
;	O
static	O
int	O
is_caseless	int
;	O
static	O
int	O
is_ucase_pattern	int
;	O
struct	O
hilite	struct
{	O
POSITION	long
hl_startpos	long
;	O
POSITION	long
hl_endpos	long
;	O
}	O
;	O
struct	O
hilite_node	struct
{	O
struct	O
hilite_node	struct
*	O
parent	pointer
;	O
struct	O
hilite_node	struct
*	O
left	pointer
;	O
struct	O
hilite_node	struct
*	O
right	pointer
;	O
struct	O
hilite_node	struct
*	O
prev	pointer
;	O
struct	O
hilite_node	struct
*	O
next	pointer
;	O
int	O
red	int
;	O
struct	O
hilite	struct
r	struct
;	O
}	O
;	O
struct	O
hilite_storage	struct
{	O
int	O
capacity	int
;	O
int	O
used	int
;	O
struct	O
hilite_storage	struct
*	O
next	pointer
;	O
struct	O
hilite_node	struct
*	O
nodes	pointer
;	O
}	O
;	O
struct	O
hilite_tree	struct
{	O
struct	O
hilite_storage	struct
*	O
first	long
;	O
struct	O
hilite_storage	struct
*	O
current	pointer
;	O
struct	O
hilite_node	struct
*	O
root	pointer
;	O
struct	O
hilite_node	struct
*	O
lookaside	pointer
;	O
}	O
;	O
static	O
struct	O
hilite_tree	struct
hilite_anchor	struct
=	O
HILITE_INITIALIZER	O
(	O
)	O
;	O
static	O
struct	O
hilite_tree	struct
filter_anchor	struct
=	O
HILITE_INITIALIZER	O
(	O
)	O
;	O
struct	O
pattern_info	struct
{	O
PATTERN_TYPE	O
compiled	pointer
;	O
char	O
*	O
text	pointer
;	O
int	O
search_type	int
;	O
}	O
;	O
static	O
struct	O
pattern_info	struct
search_info	struct
;	O
static	O
struct	O
pattern_info	struct
filter_info	struct
;	O
static	O
int	O
is_ucase	function
(	O
str	pointer
)	O
char	O
*	O
str	pointer
;	O
{	O
char	O
*	O
str_end	pointer
=	O
str	pointer
+	O
strlen	function
(	O
str	pointer
)	O
;	O
LWCHAR	long
ch	long
;	O
while	O
(	O
str	pointer
<	O
str_end	pointer
)	O
{	O
ch	long
=	O
step_char	function
(	O
&	O
str	pointer
,	O
+	O
1	int
,	O
str_end	pointer
)	O
;	O
if	O
(	O
IS_UPPER	O
(	O
ch	long
)	O
)	O
return	O
(	O
1	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
set_pattern	function
(	O
info	pointer
,	O
pattern	pointer
,	O
search_type	int
)	O
struct	O
pattern_info	struct
*	O
info	pointer
;	O
char	O
*	O
pattern	pointer
;	O
int	O
search_type	int
;	O
{	O
if	O
(	O
pattern	pointer
==	O
NULL	O
)	O
CLEAR_PATTERN	O
(	O
info	pointer
->	O
compiled	pointer
)	O
;	O
else	O
if	O
(	O
compile_pattern	function
(	O
pattern	pointer
,	O
search_type	int
,	O
&	O
info	pointer
->	O
compiled	pointer
)	O
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
info	pointer
->	O
text	pointer
!=	O
NULL	O
)	O
free	function
(	O
info	pointer
->	O
text	pointer
)	O
;	O
info	pointer
->	O
text	pointer
=	O
NULL	O
;	O
if	O
(	O
pattern	pointer
!=	O
NULL	O
)	O
{	O
info	pointer
->	O
text	pointer
=	O
(	O
char	O
*	O
)	O
ecalloc	function
(	O
1	int
,	O
strlen	function
(	O
pattern	pointer
)	O
+	O
1	int
)	O
;	O
strcpy	function
(	O
info	pointer
->	O
text	pointer
,	O
pattern	pointer
)	O
;	O
}	O
info	pointer
->	O
search_type	int
=	O
search_type	int
;	O
is_ucase_pattern	int
=	O
is_ucase	function
(	O
pattern	pointer
)	O
;	O
if	O
(	O
is_ucase_pattern	int
&&	O
caseless	int
!=	O
OPT_ONPLUS	int
)	O
is_caseless	int
=	O
0	int
;	O
else	O
is_caseless	int
=	O
caseless	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
clear_pattern	function
(	O
info	pointer
)	O
struct	O
pattern_info	struct
*	O
info	pointer
;	O
{	O
if	O
(	O
info	pointer
->	O
text	pointer
!=	O
NULL	O
)	O
free	function
(	O
info	pointer
->	O
text	pointer
)	O
;	O
info	pointer
->	O
text	pointer
=	O
NULL	O
;	O
uncompile_pattern	function
(	O
&	O
info	pointer
->	O
compiled	pointer
)	O
;	O
}	O
static	O
void	O
init_pattern	function
(	O
info	pointer
)	O
struct	O
pattern_info	struct
*	O
info	pointer
;	O
{	O
CLEAR_PATTERN	O
(	O
info	pointer
->	O
compiled	pointer
)	O
;	O
info	pointer
->	O
text	pointer
=	O
NULL	O
;	O
info	pointer
->	O
search_type	int
=	O
0	int
;	O
}	O
public	O
void	O
init_search	function
(	O
)	O
{	O
init_pattern	function
(	O
&	O
search_info	struct
)	O
;	O
init_pattern	function
(	O
&	O
filter_info	struct
)	O
;	O
}	O
static	O
int	O
get_cvt_ops	function
(	O
)	O
{	O
int	O
ops	int
=	O
0	int
;	O
if	O
(	O
is_caseless	int
||	O
bs_mode	int
==	O
BS_SPECIAL	int
)	O
{	O
if	O
(	O
is_caseless	int
)	O
ops	int
|=	O
CVT_TO_LC	int
;	O
if	O
(	O
bs_mode	int
==	O
BS_SPECIAL	int
)	O
ops	int
|=	O
CVT_BS	int
;	O
if	O
(	O
bs_mode	int
!=	O
BS_CONTROL	int
)	O
ops	int
|=	O
CVT_CRLF	int
;	O
}	O
else	O
if	O
(	O
bs_mode	int
!=	O
BS_CONTROL	int
)	O
{	O
ops	int
|=	O
CVT_CRLF	int
;	O
}	O
if	O
(	O
ctldisp	int
==	O
OPT_ONPLUS	int
)	O
ops	int
|=	O
CVT_ANSI	int
;	O
return	O
(	O
ops	int
)	O
;	O
}	O
static	O
int	O
prev_pattern	function
(	O
info	pointer
)	O
struct	O
pattern_info	struct
*	O
info	pointer
;	O
{	O
if	O
(	O
(	O
info	pointer
->	O
search_type	int
&	O
SRCH_NO_REGEX	O
)	O
==	O
0	int
)	O
return	O
(	O
!	O
is_null_pattern	function
(	O
info	pointer
->	O
compiled	pointer
)	O
)	O
;	O
return	O
(	O
info	pointer
->	O
text	pointer
!=	O
NULL	O
)	O
;	O
}	O
public	O
void	O
repaint_hilite	function
(	O
on	int
)	O
int	O
on	int
;	O
{	O
int	O
sindex	int
;	O
POSITION	long
pos	long
;	O
int	O
save_hide_hilite	int
;	O
if	O
(	O
squished	int
)	O
repaint	function
(	O
)	O
;	O
save_hide_hilite	int
=	O
hide_hilite	int
;	O
if	O
(	O
!	O
on	int
)	O
{	O
if	O
(	O
hide_hilite	int
)	O
return	O
;	O
hide_hilite	int
=	O
1	int
;	O
}	O
if	O
(	O
!	O
can_goto_line	int
)	O
{	O
repaint	function
(	O
)	O
;	O
hide_hilite	int
=	O
save_hide_hilite	int
;	O
return	O
;	O
}	O
for	O
(	O
sindex	int
=	O
TOP	O
;	O
sindex	int
<	O
TOP	O
+	O
sc_height	int
-	O
1	int
;	O
sindex	int
++	O
)	O
{	O
pos	long
=	O
position	function
(	O
sindex	int
)	O
;	O
if	O
(	O
pos	long
==	O
NULL_POSITION	O
)	O
continue	O
;	O
(	O
void	O
)	O
forw_line	function
(	O
pos	long
)	O
;	O
goto_line	function
(	O
sindex	int
)	O
;	O
put_line	function
(	O
)	O
;	O
}	O
lower_left	function
(	O
)	O
;	O
hide_hilite	int
=	O
save_hide_hilite	int
;	O
}	O
public	O
void	O
clear_attn	function
(	O
)	O
{	O
int	O
sindex	int
;	O
POSITION	long
old_start_attnpos	long
;	O
POSITION	long
old_end_attnpos	long
;	O
POSITION	long
pos	long
;	O
POSITION	long
epos	long
;	O
int	O
moved	int
=	O
0	int
;	O
if	O
(	O
start_attnpos	long
==	O
NULL_POSITION	O
)	O
return	O
;	O
old_start_attnpos	long
=	O
start_attnpos	long
;	O
old_end_attnpos	long
=	O
end_attnpos	long
;	O
start_attnpos	long
=	O
end_attnpos	long
=	O
NULL_POSITION	O
;	O
if	O
(	O
!	O
can_goto_line	int
)	O
{	O
repaint	function
(	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
squished	int
)	O
repaint	function
(	O
)	O
;	O
for	O
(	O
sindex	int
=	O
TOP	O
;	O
sindex	int
<	O
TOP	O
+	O
sc_height	int
-	O
1	int
;	O
sindex	int
++	O
)	O
{	O
pos	long
=	O
position	function
(	O
sindex	int
)	O
;	O
if	O
(	O
pos	long
==	O
NULL_POSITION	O
)	O
continue	O
;	O
epos	long
=	O
position	function
(	O
sindex	int
+	O
1	int
)	O
;	O
if	O
(	O
pos	long
<=	O
old_end_attnpos	long
&&	O
(	O
epos	long
==	O
NULL_POSITION	O
||	O
epos	long
>	O
old_start_attnpos	long
)	O
)	O
{	O
(	O
void	O
)	O
forw_line	function
(	O
pos	long
)	O
;	O
goto_line	function
(	O
sindex	int
)	O
;	O
put_line	function
(	O
)	O
;	O
moved	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
moved	int
)	O
lower_left	function
(	O
)	O
;	O
}	O
public	O
void	O
undo_search	function
(	O
)	O
{	O
if	O
(	O
!	O
prev_pattern	function
(	O
&	O
search_info	struct
)	O
)	O
{	O
if	O
(	O
hilite_anchor	struct
.	O
first	long
==	O
NULL	O
)	O
{	O
error	function
(	O
"No previous regular expression"	pointer
,	O
NULL_PARG	O
)	O
;	O
return	O
;	O
}	O
clr_hilite	function
(	O
)	O
;	O
}	O
clear_pattern	function
(	O
&	O
search_info	struct
)	O
;	O
hide_hilite	int
=	O
!	O
hide_hilite	int
;	O
repaint_hilite	function
(	O
1	int
)	O
;	O
}	O
public	O
void	O
clr_hlist	function
(	O
anchor	pointer
)	O
struct	O
hilite_tree	struct
*	O
anchor	pointer
;	O
{	O
struct	O
hilite_storage	struct
*	O
hls	pointer
;	O
struct	O
hilite_storage	struct
*	O
nexthls	pointer
;	O
for	O
(	O
hls	pointer
=	O
anchor	pointer
->	O
first	long
;	O
hls	pointer
!=	O
NULL	O
;	O
hls	pointer
=	O
nexthls	pointer
)	O
{	O
nexthls	pointer
=	O
hls	pointer
->	O
next	pointer
;	O
free	function
(	O
(	O
void	O
*	O
)	O
hls	pointer
->	O
nodes	pointer
)	O
;	O
free	function
(	O
(	O
void	O
*	O
)	O
hls	pointer
)	O
;	O
}	O
anchor	pointer
->	O
first	long
=	O
NULL	O
;	O
anchor	pointer
->	O
current	pointer
=	O
NULL	O
;	O
anchor	pointer
->	O
root	pointer
=	O
NULL	O
;	O
anchor	pointer
->	O
lookaside	pointer
=	O
NULL	O
;	O
prep_startpos	long
=	O
prep_endpos	long
=	O
NULL_POSITION	O
;	O
}	O
public	O
void	O
clr_hilite	function
(	O
)	O
{	O
clr_hlist	function
(	O
&	O
hilite_anchor	struct
)	O
;	O
}	O
public	O
void	O
clr_filter	function
(	O
)	O
{	O
clr_hlist	function
(	O
&	O
filter_anchor	struct
)	O
;	O
}	O
struct	O
hilite_node	struct
*	O
hlist_last	function
(	O
anchor	pointer
)	O
struct	O
hilite_tree	struct
*	O
anchor	pointer
;	O
{	O
struct	O
hilite_node	struct
*	O
n	int
=	O
anchor	pointer
->	O
root	pointer
;	O
while	O
(	O
n	int
!=	O
NULL	O
&&	O
n	int
->	O
right	pointer
!=	O
NULL	O
)	O
n	int
=	O
n	int
->	O
right	pointer
;	O
return	O
n	int
;	O
}	O
struct	O
hilite_node	struct
*	O
hlist_next	function
(	O
n	int
)	O
struct	O
hilite_node	struct
*	O
n	int
;	O
{	O
return	O
n	int
->	O
next	pointer
;	O
}	O
struct	O
hilite_node	struct
*	O
hlist_prev	function
(	O
n	int
)	O
struct	O
hilite_node	struct
*	O
n	int
;	O
{	O
return	O
n	int
->	O
prev	pointer
;	O
}	O
struct	O
hilite_node	struct
*	O
hlist_find	function
(	O
anchor	pointer
,	O
pos	long
)	O
struct	O
hilite_tree	struct
*	O
anchor	pointer
;	O
POSITION	long
pos	long
;	O
{	O
struct	O
hilite_node	struct
*	O
n	int
,	O
*	O
m	pointer
;	O
if	O
(	O
anchor	pointer
->	O
lookaside	pointer
)	O
{	O
int	O
steps	int
=	O
0	int
;	O
int	O
hit	int
=	O
0	int
;	O
n	int
=	O
anchor	pointer
->	O
lookaside	pointer
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
pos	long
<	O
n	int
->	O
r	struct
.	O
hl_endpos	long
)	O
{	O
if	O
(	O
n	int
->	O
prev	pointer
==	O
NULL	O
||	O
pos	long
>=	O
n	int
->	O
prev	pointer
->	O
r	struct
.	O
hl_endpos	long
)	O
{	O
hit	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
n	int
->	O
next	pointer
==	O
NULL	O
)	O
{	O
n	int
=	O
NULL	O
;	O
hit	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
steps	int
>=	O
HILITE_LOOKASIDE_STEPS	int
)	O
break	O
;	O
steps	int
++	O
;	O
if	O
(	O
pos	long
<	O
n	int
->	O
r	struct
.	O
hl_endpos	long
)	O
anchor	pointer
->	O
lookaside	pointer
=	O
n	int
=	O
n	int
->	O
prev	pointer
;	O
else	O
anchor	pointer
->	O
lookaside	pointer
=	O
n	int
=	O
n	int
->	O
next	pointer
;	O
}	O
if	O
(	O
hit	int
)	O
return	O
n	int
;	O
}	O
n	int
=	O
anchor	pointer
->	O
root	pointer
;	O
m	pointer
=	O
NULL	O
;	O
while	O
(	O
n	int
!=	O
NULL	O
)	O
{	O
if	O
(	O
pos	long
<	O
n	int
->	O
r	struct
.	O
hl_startpos	long
)	O
{	O
if	O
(	O
n	int
->	O
left	pointer
!=	O
NULL	O
)	O
{	O
m	pointer
=	O
n	int
;	O
n	int
=	O
n	int
->	O
left	pointer
;	O
continue	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
pos	long
>=	O
n	int
->	O
r	struct
.	O
hl_endpos	long
)	O
{	O
if	O
(	O
n	int
->	O
right	pointer
!=	O
NULL	O
)	O
{	O
n	int
=	O
n	int
->	O
right	pointer
;	O
continue	O
;	O
}	O
if	O
(	O
m	pointer
!=	O
NULL	O
)	O
{	O
n	int
=	O
m	pointer
;	O
}	O
else	O
{	O
m	pointer
=	O
n	int
;	O
n	int
=	O
NULL	O
;	O
}	O
}	O
break	O
;	O
}	O
if	O
(	O
n	int
!=	O
NULL	O
)	O
anchor	pointer
->	O
lookaside	pointer
=	O
n	int
;	O
else	O
if	O
(	O
m	pointer
!=	O
NULL	O
)	O
anchor	pointer
->	O
lookaside	pointer
=	O
m	pointer
;	O
return	O
n	int
;	O
}	O
static	O
int	O
is_hilited_range	function
(	O
pos	long
,	O
epos	long
)	O
POSITION	long
pos	long
;	O
POSITION	long
epos	long
;	O
{	O
struct	O
hilite_node	struct
*	O
n	int
=	O
hlist_find	function
(	O
&	O
hilite_anchor	struct
,	O
pos	long
)	O
;	O
return	O
(	O
n	int
!=	O
NULL	O
&&	O
(	O
epos	long
==	O
NULL_POSITION	O
||	O
epos	long
>	O
n	int
->	O
r	struct
.	O
hl_startpos	long
)	O
)	O
;	O
}	O
public	O
int	O
is_filtered	function
(	O
pos	long
)	O
POSITION	long
pos	long
;	O
{	O
struct	O
hilite_node	struct
*	O
n	int
;	O
if	O
(	O
ch_getflags	function
(	O
)	O
&	O
CH_HELPFILE	int
)	O
return	O
(	O
0	int
)	O
;	O
n	int
=	O
hlist_find	function
(	O
&	O
filter_anchor	struct
,	O
pos	long
)	O
;	O
return	O
(	O
n	int
!=	O
NULL	O
&&	O
pos	long
>=	O
n	int
->	O
r	struct
.	O
hl_startpos	long
)	O
;	O
}	O
public	O
POSITION	long
next_unfiltered	function
(	O
pos	long
)	O
POSITION	long
pos	long
;	O
{	O
struct	O
hilite_node	struct
*	O
n	int
;	O
if	O
(	O
ch_getflags	function
(	O
)	O
&	O
CH_HELPFILE	int
)	O
return	O
(	O
pos	long
)	O
;	O
n	int
=	O
hlist_find	function
(	O
&	O
filter_anchor	struct
,	O
pos	long
)	O
;	O
while	O
(	O
n	int
!=	O
NULL	O
&&	O
pos	long
>=	O
n	int
->	O
r	struct
.	O
hl_startpos	long
)	O
{	O
pos	long
=	O
n	int
->	O
r	struct
.	O
hl_endpos	long
;	O
n	int
=	O
n	int
->	O
next	pointer
;	O
}	O
return	O
(	O
pos	long
)	O
;	O
}	O
public	O
POSITION	long
prev_unfiltered	function
(	O
pos	long
)	O
POSITION	long
pos	long
;	O
{	O
struct	O
hilite_node	struct
*	O
n	int
;	O
if	O
(	O
ch_getflags	function
(	O
)	O
&	O
CH_HELPFILE	int
)	O
return	O
(	O
pos	long
)	O
;	O
n	int
=	O
hlist_find	function
(	O
&	O
filter_anchor	struct
,	O
pos	long
)	O
;	O
while	O
(	O
n	int
!=	O
NULL	O
&&	O
pos	long
>=	O
n	int
->	O
r	struct
.	O
hl_startpos	long
)	O
{	O
pos	long
=	O
n	int
->	O
r	struct
.	O
hl_startpos	long
;	O
if	O
(	O
pos	long
==	O
0	int
)	O
break	O
;	O
pos	long
--	O
;	O
n	int
=	O
n	int
->	O
prev	pointer
;	O
}	O
return	O
(	O
pos	long
)	O
;	O
}	O
public	O
int	O
is_hilited	function
(	O
pos	long
,	O
epos	long
,	O
nohide	int
,	O
p_matches	pointer
)	O
POSITION	long
pos	long
;	O
POSITION	long
epos	long
;	O
int	O
nohide	int
;	O
int	O
*	O
p_matches	pointer
;	O
{	O
int	O
match	int
;	O
if	O
(	O
p_matches	pointer
!=	O
NULL	O
)	O
*	O
p_matches	pointer
=	O
0	int
;	O
if	O
(	O
!	O
status_col	int
&&	O
start_attnpos	long
!=	O
NULL_POSITION	O
&&	O
pos	long
<	O
end_attnpos	long
&&	O
(	O
epos	long
==	O
NULL_POSITION	O
||	O
epos	long
>	O
start_attnpos	long
)	O
)	O
return	O
(	O
1	int
)	O
;	O
match	int
=	O
is_hilited_range	function
(	O
pos	long
,	O
epos	long
)	O
;	O
if	O
(	O
!	O
match	int
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
p_matches	pointer
==	O
NULL	O
)	O
return	O
(	O
1	int
)	O
;	O
*	O
p_matches	pointer
=	O
1	int
;	O
if	O
(	O
hilite_search	int
==	O
0	int
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
!	O
nohide	int
&&	O
hide_hilite	int
)	O
return	O
(	O
0	int
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
static	O
struct	O
hilite_storage	struct
*	O
hlist_getstorage	function
(	O
anchor	pointer
)	O
struct	O
hilite_tree	struct
*	O
anchor	pointer
;	O
{	O
int	O
capacity	int
=	O
1	int
;	O
struct	O
hilite_storage	struct
*	O
s	pointer
;	O
if	O
(	O
anchor	pointer
->	O
current	pointer
)	O
{	O
if	O
(	O
anchor	pointer
->	O
current	pointer
->	O
used	int
<	O
anchor	pointer
->	O
current	pointer
->	O
capacity	int
)	O
return	O
anchor	pointer
->	O
current	pointer
;	O
capacity	int
=	O
anchor	pointer
->	O
current	pointer
->	O
capacity	int
*	O
2	int
;	O
}	O
s	pointer
=	O
(	O
struct	O
hilite_storage	struct
*	O
)	O
ecalloc	function
(	O
1	int
,	O
sizeof	O
(	O
struct	O
hilite_storage	struct
)	O
)	O
;	O
s	pointer
->	O
nodes	pointer
=	O
(	O
struct	O
hilite_node	struct
*	O
)	O
ecalloc	function
(	O
capacity	int
,	O
sizeof	O
(	O
struct	O
hilite_node	struct
)	O
)	O
;	O
s	pointer
->	O
capacity	int
=	O
capacity	int
;	O
s	pointer
->	O
used	int
=	O
0	int
;	O
s	pointer
->	O
next	pointer
=	O
NULL	O
;	O
if	O
(	O
anchor	pointer
->	O
current	pointer
)	O
anchor	pointer
->	O
current	pointer
->	O
next	pointer
=	O
s	pointer
;	O
else	O
anchor	pointer
->	O
first	long
=	O
s	pointer
;	O
anchor	pointer
->	O
current	pointer
=	O
s	pointer
;	O
return	O
s	pointer
;	O
}	O
static	O
struct	O
hilite_node	struct
*	O
hlist_getnode	function
(	O
anchor	pointer
)	O
struct	O
hilite_tree	struct
*	O
anchor	pointer
;	O
{	O
struct	O
hilite_storage	struct
*	O
s	pointer
=	O
hlist_getstorage	function
(	O
anchor	pointer
)	O
;	O
return	O
&	O
s	pointer
->	O
nodes	pointer
[	O
s	pointer
->	O
used	int
++	O
]	O
;	O
}	O
static	O
void	O
hlist_rotate_left	function
(	O
anchor	pointer
,	O
n	int
)	O
struct	O
hilite_tree	struct
*	O
anchor	pointer
;	O
struct	O
hilite_node	struct
*	O
n	int
;	O
{	O
struct	O
hilite_node	struct
*	O
np	pointer
=	O
n	int
->	O
parent	pointer
;	O
struct	O
hilite_node	struct
*	O
nr	pointer
=	O
n	int
->	O
right	pointer
;	O
struct	O
hilite_node	struct
*	O
nrl	pointer
=	O
n	int
->	O
right	pointer
->	O
left	pointer
;	O
if	O
(	O
np	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
n	int
==	O
np	pointer
->	O
left	pointer
)	O
np	pointer
->	O
left	pointer
=	O
nr	pointer
;	O
else	O
np	pointer
->	O
right	pointer
=	O
nr	pointer
;	O
}	O
else	O
{	O
anchor	pointer
->	O
root	pointer
=	O
nr	pointer
;	O
}	O
nr	pointer
->	O
left	pointer
=	O
n	int
;	O
n	int
->	O
right	pointer
=	O
nrl	pointer
;	O
nr	pointer
->	O
parent	pointer
=	O
np	pointer
;	O
n	int
->	O
parent	pointer
=	O
nr	pointer
;	O
if	O
(	O
nrl	pointer
!=	O
NULL	O
)	O
nrl	pointer
->	O
parent	pointer
=	O
n	int
;	O
}	O
static	O
void	O
hlist_rotate_right	function
(	O
anchor	pointer
,	O
n	int
)	O
struct	O
hilite_tree	struct
*	O
anchor	pointer
;	O
struct	O
hilite_node	struct
*	O
n	int
;	O
{	O
struct	O
hilite_node	struct
*	O
np	pointer
=	O
n	int
->	O
parent	pointer
;	O
struct	O
hilite_node	struct
*	O
nl	pointer
=	O
n	int
->	O
left	pointer
;	O
struct	O
hilite_node	struct
*	O
nlr	pointer
=	O
n	int
->	O
left	pointer
->	O
right	pointer
;	O
if	O
(	O
np	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
n	int
==	O
np	pointer
->	O
right	pointer
)	O
np	pointer
->	O
right	pointer
=	O
nl	pointer
;	O
else	O
np	pointer
->	O
left	pointer
=	O
nl	pointer
;	O
}	O
else	O
{	O
anchor	pointer
->	O
root	pointer
=	O
nl	pointer
;	O
}	O
nl	pointer
->	O
right	pointer
=	O
n	int
;	O
n	int
->	O
left	pointer
=	O
nlr	pointer
;	O
nl	pointer
->	O
parent	pointer
=	O
np	pointer
;	O
n	int
->	O
parent	pointer
=	O
nl	pointer
;	O
if	O
(	O
nlr	pointer
!=	O
NULL	O
)	O
nlr	pointer
->	O
parent	pointer
=	O
n	int
;	O
}	O
static	O
void	O
add_hilite	function
(	O
anchor	pointer
,	O
hl	pointer
)	O
struct	O
hilite_tree	struct
*	O
anchor	pointer
;	O
struct	O
hilite	struct
*	O
hl	pointer
;	O
{	O
struct	O
hilite_node	struct
*	O
p	pointer
,	O
*	O
n	int
,	O
*	O
u	pointer
;	O
if	O
(	O
hl	pointer
->	O
hl_startpos	long
>=	O
hl	pointer
->	O
hl_endpos	long
)	O
return	O
;	O
p	pointer
=	O
anchor	pointer
->	O
root	pointer
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
{	O
n	int
=	O
hlist_getnode	function
(	O
anchor	pointer
)	O
;	O
n	int
->	O
r	struct
=	O
*	O
hl	pointer
;	O
anchor	pointer
->	O
root	pointer
=	O
n	int
;	O
anchor	pointer
->	O
lookaside	pointer
=	O
n	int
;	O
return	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
hl	pointer
->	O
hl_startpos	long
<	O
p	pointer
->	O
r	struct
.	O
hl_startpos	long
)	O
{	O
if	O
(	O
hl	pointer
->	O
hl_endpos	long
>	O
p	pointer
->	O
r	struct
.	O
hl_startpos	long
)	O
hl	pointer
->	O
hl_endpos	long
=	O
p	pointer
->	O
r	struct
.	O
hl_startpos	long
;	O
if	O
(	O
p	pointer
->	O
left	pointer
!=	O
NULL	O
)	O
{	O
p	pointer
=	O
p	pointer
->	O
left	pointer
;	O
continue	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
hl	pointer
->	O
hl_startpos	long
<	O
p	pointer
->	O
r	struct
.	O
hl_endpos	long
)	O
{	O
hl	pointer
->	O
hl_startpos	long
=	O
p	pointer
->	O
r	struct
.	O
hl_endpos	long
;	O
if	O
(	O
hl	pointer
->	O
hl_startpos	long
>=	O
hl	pointer
->	O
hl_endpos	long
)	O
return	O
;	O
}	O
if	O
(	O
p	pointer
->	O
right	pointer
!=	O
NULL	O
)	O
{	O
p	pointer
=	O
p	pointer
->	O
right	pointer
;	O
continue	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
hl	pointer
->	O
hl_startpos	long
<	O
p	pointer
->	O
r	struct
.	O
hl_startpos	long
)	O
{	O
if	O
(	O
hl	pointer
->	O
hl_endpos	long
==	O
p	pointer
->	O
r	struct
.	O
hl_startpos	long
)	O
{	O
p	pointer
->	O
r	struct
.	O
hl_startpos	long
=	O
hl	pointer
->	O
hl_startpos	long
;	O
return	O
;	O
}	O
if	O
(	O
p	pointer
->	O
prev	pointer
!=	O
NULL	O
&&	O
p	pointer
->	O
prev	pointer
->	O
r	struct
.	O
hl_endpos	long
==	O
hl	pointer
->	O
hl_startpos	long
)	O
{	O
p	pointer
->	O
prev	pointer
->	O
r	struct
.	O
hl_endpos	long
=	O
hl	pointer
->	O
hl_endpos	long
;	O
return	O
;	O
}	O
p	pointer
->	O
left	pointer
=	O
n	int
=	O
hlist_getnode	function
(	O
anchor	pointer
)	O
;	O
n	int
->	O
next	pointer
=	O
p	pointer
;	O
if	O
(	O
p	pointer
->	O
prev	pointer
!=	O
NULL	O
)	O
{	O
n	int
->	O
prev	pointer
=	O
p	pointer
->	O
prev	pointer
;	O
p	pointer
->	O
prev	pointer
->	O
next	pointer
=	O
n	int
;	O
}	O
p	pointer
->	O
prev	pointer
=	O
n	int
;	O
}	O
else	O
{	O
if	O
(	O
p	pointer
->	O
r	struct
.	O
hl_endpos	long
==	O
hl	pointer
->	O
hl_startpos	long
)	O
{	O
p	pointer
->	O
r	struct
.	O
hl_endpos	long
=	O
hl	pointer
->	O
hl_endpos	long
;	O
return	O
;	O
}	O
if	O
(	O
p	pointer
->	O
next	pointer
!=	O
NULL	O
&&	O
hl	pointer
->	O
hl_endpos	long
==	O
p	pointer
->	O
next	pointer
->	O
r	struct
.	O
hl_startpos	long
)	O
{	O
p	pointer
->	O
next	pointer
->	O
r	struct
.	O
hl_startpos	long
=	O
hl	pointer
->	O
hl_startpos	long
;	O
return	O
;	O
}	O
p	pointer
->	O
right	pointer
=	O
n	int
=	O
hlist_getnode	function
(	O
anchor	pointer
)	O
;	O
n	int
->	O
prev	pointer
=	O
p	pointer
;	O
if	O
(	O
p	pointer
->	O
next	pointer
!=	O
NULL	O
)	O
{	O
n	int
->	O
next	pointer
=	O
p	pointer
->	O
next	pointer
;	O
p	pointer
->	O
next	pointer
->	O
prev	pointer
=	O
n	int
;	O
}	O
p	pointer
->	O
next	pointer
=	O
n	int
;	O
}	O
n	int
->	O
parent	pointer
=	O
p	pointer
;	O
n	int
->	O
red	int
=	O
1	int
;	O
n	int
->	O
r	struct
=	O
*	O
hl	pointer
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
n	int
->	O
parent	pointer
==	O
NULL	O
)	O
{	O
n	int
->	O
red	int
=	O
0	int
;	O
break	O
;	O
}	O
if	O
(	O
!	O
n	int
->	O
parent	pointer
->	O
red	int
)	O
break	O
;	O
u	pointer
=	O
n	int
->	O
parent	pointer
->	O
parent	pointer
->	O
left	pointer
;	O
if	O
(	O
n	int
->	O
parent	pointer
==	O
u	pointer
)	O
u	pointer
=	O
n	int
->	O
parent	pointer
->	O
parent	pointer
->	O
right	pointer
;	O
if	O
(	O
u	pointer
!=	O
NULL	O
&&	O
u	pointer
->	O
red	int
)	O
{	O
n	int
->	O
parent	pointer
->	O
red	int
=	O
0	int
;	O
u	pointer
->	O
red	int
=	O
0	int
;	O
n	int
=	O
n	int
->	O
parent	pointer
->	O
parent	pointer
;	O
n	int
->	O
red	int
=	O
1	int
;	O
continue	O
;	O
}	O
if	O
(	O
n	int
==	O
n	int
->	O
parent	pointer
->	O
right	pointer
&&	O
n	int
->	O
parent	pointer
==	O
n	int
->	O
parent	pointer
->	O
parent	pointer
->	O
left	pointer
)	O
{	O
hlist_rotate_left	function
(	O
anchor	pointer
,	O
n	int
->	O
parent	pointer
)	O
;	O
n	int
=	O
n	int
->	O
left	pointer
;	O
}	O
else	O
if	O
(	O
n	int
==	O
n	int
->	O
parent	pointer
->	O
left	pointer
&&	O
n	int
->	O
parent	pointer
==	O
n	int
->	O
parent	pointer
->	O
parent	pointer
->	O
right	pointer
)	O
{	O
hlist_rotate_right	function
(	O
anchor	pointer
,	O
n	int
->	O
parent	pointer
)	O
;	O
n	int
=	O
n	int
->	O
right	pointer
;	O
}	O
n	int
->	O
parent	pointer
->	O
red	int
=	O
0	int
;	O
n	int
->	O
parent	pointer
->	O
parent	pointer
->	O
red	int
=	O
1	int
;	O
if	O
(	O
n	int
==	O
n	int
->	O
parent	pointer
->	O
left	pointer
)	O
hlist_rotate_right	function
(	O
anchor	pointer
,	O
n	int
->	O
parent	pointer
->	O
parent	pointer
)	O
;	O
else	O
hlist_rotate_left	function
(	O
anchor	pointer
,	O
n	int
->	O
parent	pointer
->	O
parent	pointer
)	O
;	O
break	O
;	O
}	O
}	O
static	O
void	O
create_hilites	function
(	O
linepos	long
,	O
start_index	int
,	O
end_index	int
,	O
chpos	pointer
)	O
POSITION	long
linepos	long
;	O
int	O
start_index	int
;	O
int	O
end_index	int
;	O
int	O
*	O
chpos	pointer
;	O
{	O
struct	O
hilite	struct
hl	pointer
;	O
int	O
i	int
;	O
hl	pointer
.	O
hl_startpos	long
=	O
linepos	long
+	O
chpos	pointer
[	O
start_index	int
]	O
;	O
for	O
(	O
i	int
=	O
start_index	int
+	O
1	int
;	O
i	int
<=	O
end_index	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
chpos	pointer
[	O
i	int
]	O
!=	O
chpos	pointer
[	O
i	int
-	O
1	int
]	O
+	O
1	int
||	O
i	int
==	O
end_index	int
)	O
{	O
hl	pointer
.	O
hl_endpos	long
=	O
linepos	long
+	O
chpos	pointer
[	O
i	int
-	O
1	int
]	O
+	O
1	int
;	O
add_hilite	function
(	O
&	O
hilite_anchor	struct
,	O
&	O
hl	pointer
)	O
;	O
if	O
(	O
i	int
<	O
end_index	int
)	O
{	O
hl	pointer
.	O
hl_startpos	long
=	O
linepos	long
+	O
chpos	pointer
[	O
i	int
]	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
hilite_line	function
(	O
linepos	long
,	O
line	pointer
,	O
line_len	int
,	O
chpos	pointer
,	O
sp	pointer
,	O
ep	pointer
,	O
cvt_ops	int
)	O
POSITION	long
linepos	long
;	O
char	O
*	O
line	pointer
;	O
int	O
line_len	int
;	O
int	O
*	O
chpos	pointer
;	O
char	O
*	O
sp	pointer
;	O
char	O
*	O
ep	pointer
;	O
int	O
cvt_ops	int
;	O
{	O
char	O
*	O
searchp	pointer
;	O
char	O
*	O
line_end	pointer
=	O
line	pointer
+	O
line_len	int
;	O
searchp	pointer
=	O
line	pointer
;	O
do	O
{	O
if	O
(	O
sp	pointer
==	O
NULL	O
||	O
ep	pointer
==	O
NULL	O
)	O
return	O
;	O
create_hilites	function
(	O
linepos	long
,	O
sp	pointer
-	O
line	pointer
,	O
ep	pointer
-	O
line	pointer
,	O
chpos	pointer
)	O
;	O
if	O
(	O
ep	pointer
>	O
searchp	pointer
)	O
searchp	pointer
=	O
ep	pointer
;	O
else	O
if	O
(	O
searchp	pointer
!=	O
line_end	pointer
)	O
searchp	pointer
++	O
;	O
else	O
break	O
;	O
}	O
while	O
(	O
match_pattern	function
(	O
info_compiled	O
(	O
&	O
search_info	struct
)	O
,	O
search_info	struct
.	O
text	pointer
,	O
searchp	pointer
,	O
line_end	pointer
-	O
searchp	pointer
,	O
&	O
sp	pointer
,	O
&	O
ep	pointer
,	O
1	int
,	O
search_info	struct
.	O
search_type	int
)	O
)	O
;	O
}	O
static	O
void	O
hilite_screen	function
(	O
)	O
{	O
struct	O
scrpos	struct
scrpos	struct
;	O
get_scrpos	function
(	O
&	O
scrpos	struct
,	O
TOP	O
)	O
;	O
if	O
(	O
scrpos	struct
.	O
pos	long
==	O
NULL_POSITION	O
)	O
return	O
;	O
prep_hilite	function
(	O
scrpos	struct
.	O
pos	long
,	O
position	function
(	O
BOTTOM_PLUS_ONE	O
)	O
,	O
-	O
1	int
)	O
;	O
repaint_hilite	function
(	O
1	int
)	O
;	O
}	O
public	O
void	O
chg_hilite	function
(	O
)	O
{	O
clr_hilite	function
(	O
)	O
;	O
hide_hilite	int
=	O
0	int
;	O
if	O
(	O
hilite_search	int
==	O
OPT_ONPLUS	int
)	O
hilite_screen	function
(	O
)	O
;	O
}	O
static	O
POSITION	long
search_pos	function
(	O
search_type	int
)	O
int	O
search_type	int
;	O
{	O
POSITION	long
pos	long
;	O
int	O
sindex	int
;	O
if	O
(	O
empty_screen	function
(	O
)	O
)	O
{	O
if	O
(	O
search_type	int
&	O
SRCH_FORW	O
)	O
{	O
pos	long
=	O
ch_zero	O
(	O
)	O
;	O
}	O
else	O
{	O
pos	long
=	O
ch_length	function
(	O
)	O
;	O
if	O
(	O
pos	long
==	O
NULL_POSITION	O
)	O
{	O
(	O
void	O
)	O
ch_end_seek	function
(	O
)	O
;	O
pos	long
=	O
ch_length	function
(	O
)	O
;	O
}	O
}	O
sindex	int
=	O
0	int
;	O
}	O
else	O
{	O
int	O
add_one	int
=	O
0	int
;	O
if	O
(	O
how_search	int
==	O
OPT_ON	int
)	O
{	O
if	O
(	O
search_type	int
&	O
SRCH_FORW	O
)	O
sindex	int
=	O
sc_height	int
-	O
1	int
;	O
else	O
sindex	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
how_search	int
==	O
OPT_ONPLUS	int
&&	O
!	O
(	O
search_type	int
&	O
SRCH_AFTER_TARGET	O
)	O
)	O
{	O
if	O
(	O
search_type	int
&	O
SRCH_FORW	O
)	O
sindex	int
=	O
0	int
;	O
else	O
sindex	int
=	O
sc_height	int
-	O
1	int
;	O
}	O
else	O
{	O
sindex	int
=	O
sindex_from_sline	function
(	O
jump_sline	int
)	O
;	O
if	O
(	O
search_type	int
&	O
SRCH_FORW	O
)	O
add_one	int
=	O
1	int
;	O
}	O
pos	long
=	O
position	function
(	O
sindex	int
)	O
;	O
if	O
(	O
add_one	int
)	O
pos	long
=	O
forw_raw_line	function
(	O
pos	long
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
;	O
}	O
if	O
(	O
search_type	int
&	O
SRCH_FORW	O
)	O
{	O
while	O
(	O
pos	long
==	O
NULL_POSITION	O
)	O
{	O
if	O
(	O
++	O
sindex	int
>=	O
sc_height	int
)	O
break	O
;	O
pos	long
=	O
position	function
(	O
sindex	int
)	O
;	O
}	O
}	O
else	O
{	O
while	O
(	O
pos	long
==	O
NULL_POSITION	O
)	O
{	O
if	O
(	O
--	O
sindex	int
<	O
0	int
)	O
break	O
;	O
pos	long
=	O
position	function
(	O
sindex	int
)	O
;	O
}	O
}	O
return	O
(	O
pos	long
)	O
;	O
}	O
static	O
int	O
search_range	function
(	O
pos	long
,	O
endpos	long
,	O
search_type	int
,	O
matches	int
,	O
maxlines	int
,	O
plinepos	pointer
,	O
pendpos	pointer
)	O
POSITION	long
pos	long
;	O
POSITION	long
endpos	long
;	O
int	O
search_type	int
;	O
int	O
matches	int
;	O
int	O
maxlines	int
;	O
POSITION	long
*	O
plinepos	pointer
;	O
POSITION	long
*	O
pendpos	pointer
;	O
{	O
char	O
*	O
line	pointer
;	O
char	O
*	O
cline	pointer
;	O
int	O
line_len	int
;	O
LINENUM	long
linenum	long
;	O
char	O
*	O
sp	pointer
,	O
*	O
ep	pointer
;	O
int	O
line_match	int
;	O
int	O
cvt_ops	int
;	O
int	O
cvt_len	int
;	O
int	O
*	O
chpos	pointer
;	O
POSITION	long
linepos	long
,	O
oldpos	long
;	O
linenum	long
=	O
find_linenum	function
(	O
pos	long
)	O
;	O
oldpos	long
=	O
pos	long
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
ABORT_SIGS	O
(	O
)	O
)	O
{	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
endpos	long
!=	O
NULL_POSITION	O
&&	O
pos	long
>=	O
endpos	long
)	O
||	O
maxlines	int
==	O
0	int
)	O
{	O
if	O
(	O
pendpos	pointer
!=	O
NULL	O
)	O
*	O
pendpos	pointer
=	O
pos	long
;	O
return	O
(	O
matches	int
)	O
;	O
}	O
if	O
(	O
maxlines	int
>	O
0	int
)	O
maxlines	int
--	O
;	O
if	O
(	O
search_type	int
&	O
SRCH_FORW	O
)	O
{	O
linepos	long
=	O
pos	long
;	O
pos	long
=	O
forw_raw_line	function
(	O
pos	long
,	O
&	O
line	pointer
,	O
&	O
line_len	int
)	O
;	O
if	O
(	O
linenum	long
!=	O
0	int
)	O
linenum	long
++	O
;	O
}	O
else	O
{	O
pos	long
=	O
back_raw_line	function
(	O
pos	long
,	O
&	O
line	pointer
,	O
&	O
line_len	int
)	O
;	O
linepos	long
=	O
pos	long
;	O
if	O
(	O
linenum	long
!=	O
0	int
)	O
linenum	long
--	O
;	O
}	O
if	O
(	O
pos	long
==	O
NULL_POSITION	O
)	O
{	O
if	O
(	O
pendpos	pointer
!=	O
NULL	O
)	O
*	O
pendpos	pointer
=	O
oldpos	long
;	O
return	O
(	O
matches	int
)	O
;	O
}	O
if	O
(	O
linenums	int
&&	O
abs	function
(	O
(	O
int	O
)	O
(	O
pos	long
-	O
oldpos	long
)	O
)	O
>	O
2048	int
)	O
add_lnum	function
(	O
linenum	long
,	O
pos	long
)	O
;	O
oldpos	long
=	O
pos	long
;	O
if	O
(	O
is_filtered	function
(	O
linepos	long
)	O
)	O
continue	O
;	O
cvt_ops	int
=	O
get_cvt_ops	function
(	O
)	O
;	O
cvt_len	int
=	O
cvt_length	function
(	O
line_len	int
,	O
cvt_ops	int
)	O
;	O
cline	pointer
=	O
(	O
char	O
*	O
)	O
ecalloc	function
(	O
1	int
,	O
cvt_len	int
)	O
;	O
chpos	pointer
=	O
cvt_alloc_chpos	function
(	O
cvt_len	int
)	O
;	O
cvt_text	function
(	O
cline	pointer
,	O
line	pointer
,	O
chpos	pointer
,	O
&	O
line_len	int
,	O
cvt_ops	int
)	O
;	O
if	O
(	O
(	O
(	O
search_type	int
&	O
SRCH_FIND_ALL	O
)	O
||	O
prep_startpos	long
==	O
NULL_POSITION	O
||	O
linepos	long
<	O
prep_startpos	long
||	O
linepos	long
>=	O
prep_endpos	long
)	O
&&	O
prev_pattern	function
(	O
&	O
filter_info	struct
)	O
)	O
{	O
int	O
line_filter	int
=	O
match_pattern	function
(	O
info_compiled	O
(	O
&	O
filter_info	struct
)	O
,	O
filter_info	struct
.	O
text	pointer
,	O
cline	pointer
,	O
line_len	int
,	O
&	O
sp	pointer
,	O
&	O
ep	pointer
,	O
0	int
,	O
filter_info	struct
.	O
search_type	int
)	O
;	O
if	O
(	O
line_filter	int
)	O
{	O
struct	O
hilite	struct
hl	pointer
;	O
hl	pointer
.	O
hl_startpos	long
=	O
linepos	long
;	O
hl	pointer
.	O
hl_endpos	long
=	O
pos	long
;	O
add_hilite	function
(	O
&	O
filter_anchor	struct
,	O
&	O
hl	pointer
)	O
;	O
free	function
(	O
cline	pointer
)	O
;	O
free	function
(	O
chpos	pointer
)	O
;	O
continue	O
;	O
}	O
}	O
if	O
(	O
prev_pattern	function
(	O
&	O
search_info	struct
)	O
)	O
{	O
line_match	int
=	O
match_pattern	function
(	O
info_compiled	O
(	O
&	O
search_info	struct
)	O
,	O
search_info	struct
.	O
text	pointer
,	O
cline	pointer
,	O
line_len	int
,	O
&	O
sp	pointer
,	O
&	O
ep	pointer
,	O
0	int
,	O
search_type	int
)	O
;	O
if	O
(	O
line_match	int
)	O
{	O
if	O
(	O
search_type	int
&	O
SRCH_FIND_ALL	O
)	O
{	O
hilite_line	function
(	O
linepos	long
,	O
cline	pointer
,	O
line_len	int
,	O
chpos	pointer
,	O
sp	pointer
,	O
ep	pointer
,	O
cvt_ops	int
)	O
;	O
}	O
else	O
if	O
(	O
--	O
matches	int
<=	O
0	int
)	O
{	O
if	O
(	O
hilite_search	int
==	O
OPT_ON	int
)	O
{	O
clr_hilite	function
(	O
)	O
;	O
hilite_line	function
(	O
linepos	long
,	O
cline	pointer
,	O
line_len	int
,	O
chpos	pointer
,	O
sp	pointer
,	O
ep	pointer
,	O
cvt_ops	int
)	O
;	O
}	O
free	function
(	O
cline	pointer
)	O
;	O
free	function
(	O
chpos	pointer
)	O
;	O
if	O
(	O
plinepos	pointer
!=	O
NULL	O
)	O
*	O
plinepos	pointer
=	O
linepos	long
;	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
}	O
free	function
(	O
cline	pointer
)	O
;	O
free	function
(	O
chpos	pointer
)	O
;	O
}	O
}	O
static	O
int	O
hist_pattern	function
(	O
search_type	int
)	O
int	O
search_type	int
;	O
{	O
char	O
*	O
pattern	pointer
;	O
set_mlist	function
(	O
ml_search	pointer
,	O
0	int
)	O
;	O
pattern	pointer
=	O
cmd_lastpattern	function
(	O
)	O
;	O
if	O
(	O
pattern	pointer
==	O
NULL	O
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
set_pattern	function
(	O
&	O
search_info	struct
,	O
pattern	pointer
,	O
search_type	int
)	O
<	O
0	int
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
hilite_search	int
==	O
OPT_ONPLUS	int
&&	O
!	O
hide_hilite	int
)	O
hilite_screen	function
(	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
public	O
void	O
chg_caseless	function
(	O
)	O
{	O
if	O
(	O
!	O
is_ucase_pattern	int
)	O
is_caseless	int
=	O
caseless	int
;	O
else	O
{	O
clear_pattern	function
(	O
&	O
search_info	struct
)	O
;	O
hist_pattern	function
(	O
search_info	struct
.	O
search_type	int
)	O
;	O
}	O
}	O
public	O
int	O
search	function
(	O
search_type	int
,	O
pattern	pointer
,	O
n	int
)	O
int	O
search_type	int
;	O
char	O
*	O
pattern	pointer
;	O
int	O
n	int
;	O
{	O
POSITION	long
pos	long
;	O
if	O
(	O
pattern	pointer
==	O
NULL	O
||	O
*	O
pattern	pointer
==	O
'\0'	O
)	O
{	O
search_type	int
|=	O
SRCH_AFTER_TARGET	O
;	O
if	O
(	O
!	O
prev_pattern	function
(	O
&	O
search_info	struct
)	O
&&	O
!	O
hist_pattern	function
(	O
search_type	int
)	O
)	O
{	O
error	function
(	O
"No previous regular expression"	pointer
,	O
NULL_PARG	O
)	O
;	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
search_type	int
&	O
SRCH_NO_REGEX	O
)	O
!=	O
(	O
search_info	struct
.	O
search_type	int
&	O
SRCH_NO_REGEX	O
)	O
)	O
{	O
error	function
(	O
"Please re-enter search pattern"	pointer
,	O
NULL_PARG	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
hilite_search	int
==	O
OPT_ON	int
||	O
status_col	int
)	O
{	O
repaint_hilite	function
(	O
0	int
)	O
;	O
}	O
if	O
(	O
hilite_search	int
==	O
OPT_ONPLUS	int
&&	O
hide_hilite	int
)	O
{	O
hide_hilite	int
=	O
0	int
;	O
hilite_screen	function
(	O
)	O
;	O
}	O
hide_hilite	int
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
set_pattern	function
(	O
&	O
search_info	struct
,	O
pattern	pointer
,	O
search_type	int
)	O
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
if	O
(	O
hilite_search	int
||	O
status_col	int
)	O
{	O
repaint_hilite	function
(	O
0	int
)	O
;	O
hide_hilite	int
=	O
0	int
;	O
clr_hilite	function
(	O
)	O
;	O
}	O
if	O
(	O
hilite_search	int
==	O
OPT_ONPLUS	int
||	O
status_col	int
)	O
{	O
hilite_screen	function
(	O
)	O
;	O
}	O
}	O
pos	long
=	O
search_pos	function
(	O
search_type	int
)	O
;	O
if	O
(	O
pos	long
==	O
NULL_POSITION	O
)	O
{	O
if	O
(	O
search_type	int
&	O
SRCH_PAST_EOF	O
)	O
return	O
(	O
n	int
)	O
;	O
if	O
(	O
hilite_search	int
==	O
OPT_ON	int
||	O
status_col	int
)	O
repaint_hilite	function
(	O
1	int
)	O
;	O
error	function
(	O
"Nothing to search"	pointer
,	O
NULL_PARG	O
)	O
;	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
n	int
=	O
search_range	function
(	O
pos	long
,	O
NULL_POSITION	O
,	O
search_type	int
,	O
n	int
,	O
-	O
1	int
,	O
&	O
pos	long
,	O
(	O
POSITION	long
*	O
)	O
NULL	O
)	O
;	O
if	O
(	O
n	int
!=	O
0	int
)	O
{	O
if	O
(	O
(	O
hilite_search	int
==	O
OPT_ON	int
||	O
status_col	int
)	O
&&	O
n	int
>	O
0	int
)	O
repaint_hilite	function
(	O
1	int
)	O
;	O
return	O
(	O
n	int
)	O
;	O
}	O
if	O
(	O
!	O
(	O
search_type	int
&	O
SRCH_NO_MOVE	O
)	O
)	O
{	O
jump_loc	function
(	O
pos	long
,	O
jump_sline	int
)	O
;	O
}	O
if	O
(	O
hilite_search	int
==	O
OPT_ON	int
||	O
status_col	int
)	O
repaint_hilite	function
(	O
1	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
public	O
void	O
prep_hilite	function
(	O
spos	long
,	O
epos	long
,	O
maxlines	int
)	O
POSITION	long
spos	long
;	O
POSITION	long
epos	long
;	O
int	O
maxlines	int
;	O
{	O
POSITION	long
nprep_startpos	long
=	O
prep_startpos	long
;	O
POSITION	long
nprep_endpos	long
=	O
prep_endpos	long
;	O
POSITION	long
new_epos	long
;	O
POSITION	long
max_epos	long
;	O
int	O
result	int
;	O
int	O
i	int
;	O
if	O
(	O
!	O
prev_pattern	function
(	O
&	O
search_info	struct
)	O
&&	O
!	O
is_filtering	function
(	O
)	O
)	O
return	O
;	O
spos	long
=	O
back_raw_line	function
(	O
spos	long
+	O
1	int
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
;	O
if	O
(	O
maxlines	int
<	O
0	int
)	O
max_epos	long
=	O
NULL_POSITION	O
;	O
else	O
{	O
max_epos	long
=	O
spos	long
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
maxlines	int
;	O
i	int
++	O
)	O
max_epos	long
=	O
forw_raw_line	function
(	O
max_epos	long
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
;	O
}	O
if	O
(	O
prep_startpos	long
==	O
NULL_POSITION	O
||	O
(	O
epos	long
!=	O
NULL_POSITION	O
&&	O
epos	long
<	O
prep_startpos	long
)	O
||	O
spos	long
>	O
prep_endpos	long
)	O
{	O
clr_hilite	function
(	O
)	O
;	O
clr_filter	function
(	O
)	O
;	O
if	O
(	O
epos	long
!=	O
NULL_POSITION	O
)	O
epos	long
+=	O
SEARCH_MORE	O
;	O
nprep_startpos	long
=	O
spos	long
;	O
}	O
else	O
{	O
if	O
(	O
epos	long
==	O
NULL_POSITION	O
)	O
{	O
;	O
}	O
else	O
if	O
(	O
epos	long
>	O
prep_endpos	long
)	O
{	O
epos	long
+=	O
SEARCH_MORE	O
;	O
}	O
else	O
{	O
epos	long
=	O
prep_startpos	long
;	O
}	O
if	O
(	O
spos	long
<	O
prep_startpos	long
)	O
{	O
if	O
(	O
spos	long
<	O
SEARCH_MORE	O
)	O
spos	long
=	O
0	int
;	O
else	O
spos	long
-=	O
SEARCH_MORE	O
;	O
nprep_startpos	long
=	O
spos	long
;	O
}	O
else	O
{	O
spos	long
=	O
prep_endpos	long
;	O
}	O
}	O
if	O
(	O
epos	long
!=	O
NULL_POSITION	O
&&	O
max_epos	long
!=	O
NULL_POSITION	O
&&	O
epos	long
>	O
max_epos	long
)	O
epos	long
=	O
max_epos	long
;	O
if	O
(	O
epos	long
==	O
NULL_POSITION	O
||	O
epos	long
>	O
spos	long
)	O
{	O
int	O
search_type	int
=	O
SRCH_FORW	O
|	O
SRCH_FIND_ALL	O
;	O
search_type	int
|=	O
(	O
search_info	struct
.	O
search_type	int
&	O
SRCH_NO_REGEX	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
result	int
=	O
search_range	function
(	O
spos	long
,	O
epos	long
,	O
search_type	int
,	O
0	int
,	O
maxlines	int
,	O
(	O
POSITION	long
*	O
)	O
NULL	O
,	O
&	O
new_epos	long
)	O
;	O
if	O
(	O
result	int
<	O
0	int
)	O
return	O
;	O
if	O
(	O
prep_endpos	long
==	O
NULL_POSITION	O
||	O
new_epos	long
>	O
prep_endpos	long
)	O
nprep_endpos	long
=	O
new_epos	long
;	O
if	O
(	O
prep_endpos	long
==	O
NULL_POSITION	O
||	O
nprep_endpos	long
>	O
prep_endpos	long
)	O
{	O
if	O
(	O
new_epos	long
>=	O
nprep_endpos	long
&&	O
is_filtered	function
(	O
new_epos	long
-	O
1	int
)	O
)	O
{	O
spos	long
=	O
nprep_endpos	long
;	O
epos	long
=	O
forw_raw_line	function
(	O
nprep_endpos	long
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
;	O
if	O
(	O
epos	long
==	O
NULL_POSITION	O
)	O
break	O
;	O
maxlines	int
=	O
1	int
;	O
continue	O
;	O
}	O
}	O
if	O
(	O
prep_startpos	long
==	O
NULL_POSITION	O
||	O
nprep_startpos	long
<	O
prep_startpos	long
)	O
{	O
if	O
(	O
nprep_startpos	long
>	O
0	int
&&	O
is_filtered	function
(	O
nprep_startpos	long
)	O
)	O
{	O
epos	long
=	O
nprep_startpos	long
;	O
spos	long
=	O
back_raw_line	function
(	O
nprep_startpos	long
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
;	O
if	O
(	O
spos	long
==	O
NULL_POSITION	O
)	O
break	O
;	O
nprep_startpos	long
=	O
spos	long
;	O
maxlines	int
=	O
1	int
;	O
continue	O
;	O
}	O
}	O
break	O
;	O
}	O
}	O
prep_startpos	long
=	O
nprep_startpos	long
;	O
prep_endpos	long
=	O
nprep_endpos	long
;	O
}	O
public	O
void	O
set_filter_pattern	function
(	O
pattern	pointer
,	O
search_type	int
)	O
char	O
*	O
pattern	pointer
;	O
int	O
search_type	int
;	O
{	O
clr_filter	function
(	O
)	O
;	O
if	O
(	O
pattern	pointer
==	O
NULL	O
||	O
*	O
pattern	pointer
==	O
'\0'	O
)	O
clear_pattern	function
(	O
&	O
filter_info	struct
)	O
;	O
else	O
set_pattern	function
(	O
&	O
filter_info	struct
,	O
pattern	pointer
,	O
search_type	int
)	O
;	O
screen_trashed	int
=	O
1	int
;	O
}	O
public	O
int	O
is_filtering	function
(	O
)	O
{	O
if	O
(	O
ch_getflags	function
(	O
)	O
&	O
CH_HELPFILE	int
)	O
return	O
(	O
0	int
)	O
;	O
return	O
prev_pattern	function
(	O
&	O
filter_info	struct
)	O
;	O
}	O
