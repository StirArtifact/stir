static	O
Node	struct
*	O
prim_print	function
___P	O
(	O
(	O
char	O
*	O
prim_name	pointer
,	O
List	struct
*	O
args	pointer
,	O
Environment	struct
*	O
env	pointer
,	O
char	O
*	O
filename	pointer
,	O
unsigned	O
int	O
linenum	int
)	O
)	O
;	O
static	O
Node	struct
*	O
match_arg	function
(	O
prim_name	pointer
,	O
type	enum
,	O
argp	pointer
,	O
env	pointer
,	O
filename	pointer
,	O
linenum	int
)	O
char	O
*	O
prim_name	pointer
;	O
NodeType	enum
type	enum
;	O
ListItem	struct
*	O
*	O
argp	pointer
;	O
Environment	struct
*	O
env	pointer
;	O
char	O
*	O
filename	pointer
;	O
unsigned	O
int	O
linenum	int
;	O
{	O
ListItem	struct
*	O
arg	pointer
=	O
*	O
argp	pointer
;	O
Node	struct
*	O
n	long
;	O
NEED_ARG	O
(	O
)	O
;	O
n	long
=	O
eval_expr	function
(	O
(	O
Expr	struct
*	O
)	O
arg	pointer
->	O
data	pointer
,	O
env	pointer
)	O
;	O
if	O
(	O
type	enum
!=	O
nVOID	int
&&	O
n	long
->	O
type	enum
!=	O
type	enum
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s:%d: %s: illegal argument type\n"	pointer
)	O
,	O
filename	pointer
,	O
linenum	int
,	O
prim_name	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
*	O
argp	pointer
=	O
arg	pointer
->	O
next	pointer
;	O
return	O
n	long
;	O
}	O
DEFUN	O
(	O
prim_call	function
)	O
{	O
ListItem	struct
*	O
arg	pointer
=	O
args	pointer
->	O
head	pointer
;	O
Expr	struct
*	O
e	pointer
;	O
char	O
*	O
cp	pointer
;	O
e	pointer
=	O
(	O
Expr	struct
*	O
)	O
arg	pointer
->	O
data	pointer
;	O
if	O
(	O
e	pointer
->	O
type	enum
!=	O
eSYMBOL	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s:%d: %s: illegal argument type\n"	pointer
)	O
,	O
filename	pointer
,	O
linenum	int
,	O
prim_name	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
cp	pointer
=	O
e	pointer
->	O
u	union
.	O
node	pointer
->	O
u	union
.	O
sym	pointer
;	O
arg	pointer
=	O
arg	pointer
->	O
next	pointer
;	O
LAST_ARG	O
(	O
)	O
;	O
return	O
execute_state	function
(	O
cp	pointer
)	O
;	O
}	O
DEFUN	O
(	O
prim_calln	function
)	O
{	O
ListItem	struct
*	O
arg	pointer
=	O
args	pointer
->	O
head	pointer
;	O
Node	struct
*	O
n	long
;	O
char	O
*	O
cp	pointer
;	O
n	long
=	O
MATCH_ARG	O
(	O
nSTRING	int
)	O
;	O
LAST_ARG	O
(	O
)	O
;	O
cp	pointer
=	O
xmalloc	function
(	O
n	long
->	O
u	union
.	O
str	struct
.	O
len	int
+	O
1	int
)	O
;	O
memcpy	function
(	O
cp	pointer
,	O
n	long
->	O
u	union
.	O
str	struct
.	O
data	pointer
,	O
n	long
->	O
u	union
.	O
str	struct
.	O
len	int
)	O
;	O
cp	pointer
[	O
n	long
->	O
u	union
.	O
str	struct
.	O
len	int
]	O
=	O
'\0'	O
;	O
node_free	function
(	O
n	long
)	O
;	O
n	long
=	O
execute_state	function
(	O
cp	pointer
)	O
;	O
xfree	function
(	O
cp	pointer
)	O
;	O
return	O
n	long
;	O
}	O
DEFUN	O
(	O
prim_check_namerules	function
)	O
{	O
ListItem	struct
*	O
arg	pointer
=	O
args	pointer
->	O
head	pointer
;	O
ListItem	struct
*	O
i	pointer
;	O
Cons	struct
*	O
c	pointer
;	O
Node	struct
*	O
n	long
;	O
LAST_ARG	O
(	O
)	O
;	O
if	O
(	O
start_state	pointer
)	O
goto	O
return_false	O
;	O
for	O
(	O
i	pointer
=	O
namerules	pointer
->	O
head	pointer
;	O
i	pointer
;	O
i	pointer
=	O
i	pointer
->	O
next	pointer
)	O
{	O
c	pointer
=	O
(	O
Cons	struct
*	O
)	O
i	pointer
->	O
data	pointer
;	O
n	long
=	O
(	O
Node	struct
*	O
)	O
c	pointer
->	O
car	pointer
;	O
if	O
(	O
re_search	function
(	O
REGEXP	O
(	O
n	long
)	O
,	O
current_fname	pointer
,	O
strlen	function
(	O
current_fname	pointer
)	O
,	O
0	int
,	O
strlen	function
(	O
current_fname	pointer
)	O
,	O
NULL	O
)	O
>=	O
0	int
)	O
{	O
n	long
=	O
(	O
Node	struct
*	O
)	O
c	pointer
->	O
cdr	pointer
;	O
start_state	pointer
=	O
n	long
->	O
u	union
.	O
sym	pointer
;	O
n	long
=	O
node_alloc	function
(	O
nINTEGER	int
)	O
;	O
n	long
->	O
u	union
.	O
integer	int
=	O
1	int
;	O
return	O
n	long
;	O
}	O
}	O
return_false	O
:	O
n	long
=	O
node_alloc	function
(	O
nINTEGER	int
)	O
;	O
n	long
->	O
u	union
.	O
integer	int
=	O
0	int
;	O
return	O
n	long
;	O
}	O
DEFUN	O
(	O
prim_check_startrules	function
)	O
{	O
ListItem	struct
*	O
arg	pointer
=	O
args	pointer
->	O
head	pointer
;	O
ListItem	struct
*	O
i	pointer
;	O
Cons	struct
*	O
c	pointer
;	O
Node	struct
*	O
n	long
;	O
LAST_ARG	O
(	O
)	O
;	O
if	O
(	O
start_state	pointer
)	O
goto	O
return_false	O
;	O
for	O
(	O
i	pointer
=	O
startrules	pointer
->	O
head	pointer
;	O
i	pointer
;	O
i	pointer
=	O
i	pointer
->	O
next	pointer
)	O
{	O
c	pointer
=	O
(	O
Cons	struct
*	O
)	O
i	pointer
->	O
data	pointer
;	O
n	long
=	O
(	O
Node	struct
*	O
)	O
c	pointer
->	O
car	pointer
;	O
if	O
(	O
re_search	function
(	O
REGEXP	O
(	O
n	long
)	O
,	O
inbuf	pointer
,	O
data_in_buffer	int
,	O
0	int
,	O
data_in_buffer	int
,	O
NULL	O
)	O
>=	O
0	int
)	O
{	O
n	long
=	O
(	O
Node	struct
*	O
)	O
c	pointer
->	O
cdr	pointer
;	O
start_state	pointer
=	O
n	long
->	O
u	union
.	O
sym	pointer
;	O
n	long
=	O
node_alloc	function
(	O
nINTEGER	int
)	O
;	O
n	long
->	O
u	union
.	O
integer	int
=	O
1	int
;	O
return	O
n	long
;	O
}	O
}	O
return_false	O
:	O
n	long
=	O
node_alloc	function
(	O
nINTEGER	int
)	O
;	O
n	long
->	O
u	union
.	O
integer	int
=	O
0	int
;	O
return	O
n	long
;	O
}	O
DEFUN	O
(	O
prim_concat	function
)	O
{	O
ListItem	struct
*	O
arg	pointer
=	O
args	pointer
->	O
head	pointer
;	O
Node	struct
*	O
n	long
;	O
int	O
len	int
=	O
0	int
;	O
char	O
*	O
data	pointer
=	O
NULL	O
;	O
NEED_ARG	O
(	O
)	O
;	O
for	O
(	O
;	O
arg	pointer
;	O
arg	pointer
=	O
arg	pointer
->	O
next	pointer
)	O
{	O
n	long
=	O
eval_expr	function
(	O
(	O
Expr	struct
*	O
)	O
arg	pointer
->	O
data	pointer
,	O
env	pointer
)	O
;	O
if	O
(	O
n	long
->	O
type	enum
!=	O
nSTRING	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s:%d: %s: illegal argument type\n"	pointer
)	O
,	O
filename	pointer
,	O
linenum	int
,	O
prim_name	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
n	long
->	O
u	union
.	O
str	struct
.	O
len	int
>	O
0	int
)	O
{	O
data	pointer
=	O
(	O
char	O
*	O
)	O
xrealloc	function
(	O
data	pointer
,	O
len	int
+	O
n	long
->	O
u	union
.	O
str	struct
.	O
len	int
)	O
;	O
memcpy	function
(	O
data	pointer
+	O
len	int
,	O
n	long
->	O
u	union
.	O
str	struct
.	O
data	pointer
,	O
n	long
->	O
u	union
.	O
str	struct
.	O
len	int
)	O
;	O
len	int
+=	O
n	long
->	O
u	union
.	O
str	struct
.	O
len	int
;	O
}	O
node_free	function
(	O
n	long
)	O
;	O
}	O
n	long
=	O
node_alloc	function
(	O
nSTRING	int
)	O
;	O
n	long
->	O
u	union
.	O
str	struct
.	O
data	pointer
=	O
data	pointer
;	O
n	long
->	O
u	union
.	O
str	struct
.	O
len	int
=	O
len	int
;	O
return	O
n	long
;	O
}	O
DEFUN	O
(	O
prim_float	function
)	O
{	O
ListItem	struct
*	O
arg	pointer
=	O
args	pointer
->	O
head	pointer
;	O
Node	struct
*	O
n	long
,	O
*	O
r	pointer
;	O
char	O
buf	array
[	O
512	int
]	O
;	O
n	long
=	O
MATCH_ARG	O
(	O
nVOID	int
)	O
;	O
LAST_ARG	O
(	O
)	O
;	O
r	pointer
=	O
node_alloc	function
(	O
nREAL	int
)	O
;	O
switch	O
(	O
n	long
->	O
type	enum
)	O
{	O
case	O
nVOID	int
:	O
case	O
nREGEXP	int
:	O
case	O
nSYMBOL	int
:	O
r	pointer
->	O
u	union
.	O
real	double
=	O
0.0	int
;	O
break	O
;	O
case	O
nARRAY	int
:	O
r	pointer
->	O
u	union
.	O
real	double
=	O
(	O
double	O
)	O
n	long
->	O
u	union
.	O
array	pointer
.	O
len	int
;	O
break	O
;	O
case	O
nSTRING	int
:	O
if	O
(	O
n	long
->	O
u	union
.	O
str	struct
.	O
len	int
>	O
sizeof	O
(	O
buf	array
)	O
-	O
1	int
)	O
r	pointer
->	O
u	union
.	O
real	double
=	O
0.0	int
;	O
else	O
{	O
memcpy	function
(	O
buf	array
,	O
n	long
->	O
u	union
.	O
str	struct
.	O
data	pointer
,	O
n	long
->	O
u	union
.	O
str	struct
.	O
len	int
)	O
;	O
buf	array
[	O
n	long
->	O
u	union
.	O
str	struct
.	O
len	int
]	O
=	O
'\0'	O
;	O
r	pointer
->	O
u	union
.	O
real	double
=	O
atof	function
(	O
buf	array
)	O
;	O
}	O
break	O
;	O
case	O
nINTEGER	int
:	O
r	pointer
->	O
u	union
.	O
real	double
=	O
(	O
double	O
)	O
n	long
->	O
u	union
.	O
integer	int
;	O
break	O
;	O
case	O
nREAL	int
:	O
r	pointer
->	O
u	union
.	O
real	double
=	O
n	long
->	O
u	union
.	O
real	double
;	O
break	O
;	O
}	O
node_free	function
(	O
n	long
)	O
;	O
return	O
r	pointer
;	O
}	O
DEFUN	O
(	O
prim_getenv	function
)	O
{	O
ListItem	struct
*	O
arg	pointer
=	O
args	pointer
->	O
head	pointer
;	O
Node	struct
*	O
var	pointer
,	O
*	O
n	long
;	O
char	O
*	O
key	pointer
;	O
char	O
*	O
cp	pointer
;	O
var	pointer
=	O
MATCH_ARG	O
(	O
nSTRING	int
)	O
;	O
LAST_ARG	O
(	O
)	O
;	O
key	pointer
=	O
(	O
char	O
*	O
)	O
xcalloc	function
(	O
1	int
,	O
var	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
+	O
1	int
)	O
;	O
memcpy	function
(	O
key	pointer
,	O
var	pointer
->	O
u	union
.	O
str	struct
.	O
data	pointer
,	O
var	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
)	O
;	O
cp	pointer
=	O
getenv	function
(	O
key	pointer
)	O
;	O
node_free	function
(	O
var	pointer
)	O
;	O
xfree	function
(	O
key	pointer
)	O
;	O
n	long
=	O
node_alloc	function
(	O
nSTRING	int
)	O
;	O
if	O
(	O
cp	pointer
==	O
NULL	O
)	O
{	O
n	long
->	O
u	union
.	O
str	struct
.	O
data	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
1	int
)	O
;	O
n	long
->	O
u	union
.	O
str	struct
.	O
len	int
=	O
0	int
;	O
}	O
else	O
{	O
n	long
->	O
u	union
.	O
str	struct
.	O
data	pointer
=	O
xstrdup	function
(	O
cp	pointer
)	O
;	O
n	long
->	O
u	union
.	O
str	struct
.	O
len	int
=	O
strlen	function
(	O
cp	pointer
)	O
;	O
}	O
return	O
n	long
;	O
}	O
DEFUN	O
(	O
prim_int	function
)	O
{	O
ListItem	struct
*	O
arg	pointer
=	O
args	pointer
->	O
head	pointer
;	O
Node	struct
*	O
n	long
,	O
*	O
r	pointer
;	O
char	O
buf	array
[	O
512	int
]	O
;	O
n	long
=	O
MATCH_ARG	O
(	O
nVOID	int
)	O
;	O
LAST_ARG	O
(	O
)	O
;	O
r	pointer
=	O
node_alloc	function
(	O
nINTEGER	int
)	O
;	O
switch	O
(	O
n	long
->	O
type	enum
)	O
{	O
case	O
nVOID	int
:	O
case	O
nREGEXP	int
:	O
case	O
nSYMBOL	int
:	O
r	pointer
->	O
u	union
.	O
integer	int
=	O
0	int
;	O
break	O
;	O
case	O
nARRAY	int
:	O
r	pointer
->	O
u	union
.	O
integer	int
=	O
n	long
->	O
u	union
.	O
array	pointer
.	O
len	int
;	O
break	O
;	O
case	O
nSTRING	int
:	O
if	O
(	O
n	long
->	O
u	union
.	O
str	struct
.	O
len	int
>	O
sizeof	O
(	O
buf	array
)	O
-	O
1	int
)	O
r	pointer
->	O
u	union
.	O
integer	int
=	O
0	int
;	O
else	O
{	O
memcpy	function
(	O
buf	array
,	O
n	long
->	O
u	union
.	O
str	struct
.	O
data	pointer
,	O
n	long
->	O
u	union
.	O
str	struct
.	O
len	int
)	O
;	O
buf	array
[	O
n	long
->	O
u	union
.	O
str	struct
.	O
len	int
]	O
=	O
'\0'	O
;	O
r	pointer
->	O
u	union
.	O
integer	int
=	O
atoi	function
(	O
buf	array
)	O
;	O
}	O
break	O
;	O
case	O
nINTEGER	int
:	O
r	pointer
->	O
u	union
.	O
integer	int
=	O
n	long
->	O
u	union
.	O
integer	int
;	O
break	O
;	O
case	O
nREAL	int
:	O
r	pointer
->	O
u	union
.	O
integer	int
=	O
(	O
int	O
)	O
n	long
->	O
u	union
.	O
real	double
;	O
break	O
;	O
}	O
node_free	function
(	O
n	long
)	O
;	O
return	O
r	pointer
;	O
}	O
DEFUN	O
(	O
prim_length	function
)	O
{	O
ListItem	struct
*	O
arg	pointer
=	O
args	pointer
->	O
head	pointer
;	O
Node	struct
*	O
n	long
;	O
int	O
result	int
=	O
0	int
;	O
NEED_ARG	O
(	O
)	O
;	O
for	O
(	O
;	O
arg	pointer
;	O
arg	pointer
=	O
arg	pointer
->	O
next	pointer
)	O
{	O
n	long
=	O
eval_expr	function
(	O
(	O
Expr	struct
*	O
)	O
arg	pointer
->	O
data	pointer
,	O
env	pointer
)	O
;	O
switch	O
(	O
n	long
->	O
type	enum
)	O
{	O
case	O
nSTRING	int
:	O
result	int
+=	O
n	long
->	O
u	union
.	O
str	struct
.	O
len	int
;	O
break	O
;	O
case	O
nARRAY	int
:	O
result	int
+=	O
n	long
->	O
u	union
.	O
array	pointer
.	O
len	int
;	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s:%d: %s: illegal argument type\n"	pointer
)	O
,	O
filename	pointer
,	O
linenum	int
,	O
prim_name	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
break	O
;	O
}	O
node_free	function
(	O
n	long
)	O
;	O
}	O
n	long
=	O
node_alloc	function
(	O
nINTEGER	int
)	O
;	O
n	long
->	O
u	union
.	O
integer	int
=	O
result	int
;	O
return	O
n	long
;	O
}	O
DEFUN	O
(	O
prim_list	function
)	O
{	O
ListItem	struct
*	O
arg	pointer
=	O
args	pointer
->	O
head	pointer
;	O
unsigned	O
int	O
len	int
;	O
Node	struct
*	O
n	long
;	O
for	O
(	O
len	int
=	O
0	int
;	O
arg	pointer
;	O
len	int
++	O
,	O
arg	pointer
=	O
arg	pointer
->	O
next	pointer
)	O
;	O
arg	pointer
=	O
args	pointer
->	O
head	pointer
;	O
n	long
=	O
node_alloc	function
(	O
nARRAY	int
)	O
;	O
n	long
->	O
u	union
.	O
array	pointer
.	O
array	pointer
=	O
(	O
Node	struct
*	O
*	O
)	O
xcalloc	function
(	O
len	int
+	O
1	int
,	O
sizeof	O
(	O
Node	struct
*	O
)	O
)	O
;	O
n	long
->	O
u	union
.	O
array	pointer
.	O
allocated	long
=	O
len	int
+	O
1	int
;	O
n	long
->	O
u	union
.	O
array	pointer
.	O
len	int
=	O
len	int
;	O
for	O
(	O
len	int
=	O
0	int
;	O
arg	pointer
;	O
len	int
++	O
,	O
arg	pointer
=	O
arg	pointer
->	O
next	pointer
)	O
n	long
->	O
u	union
.	O
array	pointer
.	O
array	pointer
[	O
len	int
]	O
=	O
eval_expr	function
(	O
(	O
Expr	struct
*	O
)	O
arg	pointer
->	O
data	pointer
,	O
env	pointer
)	O
;	O
return	O
n	long
;	O
}	O
DEFUN	O
(	O
prim_panic	function
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: panic: "	pointer
)	O
,	O
program	pointer
)	O
;	O
ofp	pointer
=	O
stderr	pointer
;	O
prim_print	function
(	O
prim_name	pointer
,	O
args	pointer
,	O
env	pointer
,	O
filename	pointer
,	O
linenum	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
return	O
nvoid	pointer
;	O
}	O
DEFUN	O
(	O
prim_prereq	function
)	O
{	O
ListItem	struct
*	O
arg	pointer
=	O
args	pointer
->	O
head	pointer
;	O
Node	struct
*	O
s	pointer
;	O
int	O
over	array
[	O
3	int
]	O
;	O
int	O
rver	array
[	O
3	int
]	O
;	O
char	O
*	O
cp	pointer
;	O
int	O
i	pointer
;	O
s	pointer
=	O
MATCH_ARG	O
(	O
nSTRING	int
)	O
;	O
LAST_ARG	O
(	O
)	O
;	O
sscanf	function
(	O
VERSION	pointer
,	O
"%d.%d.%d"	pointer
,	O
&	O
over	array
[	O
0	int
]	O
,	O
&	O
over	array
[	O
1	int
]	O
,	O
&	O
over	array
[	O
2	int
]	O
)	O
;	O
cp	pointer
=	O
(	O
char	O
*	O
)	O
xcalloc	function
(	O
1	int
,	O
s	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
+	O
1	int
)	O
;	O
memcpy	function
(	O
cp	pointer
,	O
s	pointer
->	O
u	union
.	O
str	struct
.	O
data	pointer
,	O
s	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
)	O
;	O
if	O
(	O
sscanf	function
(	O
cp	pointer
,	O
"%d.%d.%d"	pointer
,	O
&	O
rver	array
[	O
0	int
]	O
,	O
&	O
rver	array
[	O
1	int
]	O
,	O
&	O
rver	array
[	O
2	int
]	O
)	O
!=	O
3	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s:%d: %s: malformed version string `%s'\n"	pointer
)	O
,	O
filename	pointer
,	O
linenum	int
,	O
prim_name	pointer
,	O
cp	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
3	int
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
over	array
[	O
i	pointer
]	O
>	O
rver	array
[	O
i	pointer
]	O
)	O
break	O
;	O
if	O
(	O
over	array
[	O
i	pointer
]	O
<	O
rver	array
[	O
i	pointer
]	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: FATAL ERROR: States version %s or higher is required for this script\n"	pointer
)	O
,	O
program	pointer
,	O
cp	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
xfree	function
(	O
cp	pointer
)	O
;	O
return	O
nvoid	pointer
;	O
}	O
static	O
void	O
print_node	function
(	O
n	long
)	O
Node	struct
*	O
n	long
;	O
{	O
unsigned	O
int	O
i	pointer
;	O
switch	O
(	O
n	long
->	O
type	enum
)	O
{	O
case	O
nVOID	int
:	O
break	O
;	O
case	O
nSTRING	int
:	O
fwrite	function
(	O
n	long
->	O
u	union
.	O
str	struct
.	O
data	pointer
,	O
n	long
->	O
u	union
.	O
str	struct
.	O
len	int
,	O
1	int
,	O
ofp	pointer
)	O
;	O
break	O
;	O
case	O
nREGEXP	int
:	O
fputc	function
(	O
'/'	O
,	O
ofp	pointer
)	O
;	O
fwrite	function
(	O
n	long
->	O
u	union
.	O
re	struct
.	O
data	pointer
,	O
n	long
->	O
u	union
.	O
re	struct
.	O
len	int
,	O
1	int
,	O
ofp	pointer
)	O
;	O
fputc	function
(	O
'/'	O
,	O
ofp	pointer
)	O
;	O
break	O
;	O
case	O
nINTEGER	int
:	O
fprintf	function
(	O
ofp	pointer
,	O
"%d"	pointer
,	O
n	long
->	O
u	union
.	O
integer	int
)	O
;	O
break	O
;	O
case	O
nREAL	int
:	O
fprintf	function
(	O
ofp	pointer
,	O
"%f"	pointer
,	O
n	long
->	O
u	union
.	O
real	double
)	O
;	O
break	O
;	O
case	O
nSYMBOL	int
:	O
fprintf	function
(	O
ofp	pointer
,	O
"%s"	pointer
,	O
n	long
->	O
u	union
.	O
sym	pointer
)	O
;	O
break	O
;	O
case	O
nARRAY	int
:	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
n	long
->	O
u	union
.	O
array	pointer
.	O
len	int
;	O
i	pointer
++	O
)	O
{	O
print_node	function
(	O
n	long
->	O
u	union
.	O
array	pointer
.	O
array	pointer
[	O
i	pointer
]	O
)	O
;	O
if	O
(	O
i	pointer
+	O
1	int
<	O
n	long
->	O
u	union
.	O
array	pointer
.	O
len	int
)	O
fprintf	function
(	O
ofp	pointer
,	O
" "	pointer
)	O
;	O
}	O
}	O
}	O
DEFUN	O
(	O
prim_print	function
)	O
{	O
ListItem	struct
*	O
arg	pointer
=	O
args	pointer
->	O
head	pointer
;	O
Node	struct
*	O
n	long
;	O
NEED_ARG	O
(	O
)	O
;	O
for	O
(	O
;	O
arg	pointer
;	O
arg	pointer
=	O
arg	pointer
->	O
next	pointer
)	O
{	O
n	long
=	O
eval_expr	function
(	O
(	O
Expr	struct
*	O
)	O
arg	pointer
->	O
data	pointer
,	O
env	pointer
)	O
;	O
print_node	function
(	O
n	long
)	O
;	O
node_free	function
(	O
n	long
)	O
;	O
}	O
return	O
nvoid	pointer
;	O
}	O
DEFUN	O
(	O
prim_range	function
)	O
{	O
ListItem	struct
*	O
arg	pointer
=	O
args	pointer
->	O
head	pointer
;	O
Node	struct
*	O
from	pointer
,	O
*	O
start	pointer
,	O
*	O
end	pointer
,	O
*	O
n	long
;	O
int	O
i	pointer
;	O
NEED_ARG	O
(	O
)	O
;	O
from	pointer
=	O
eval_expr	function
(	O
(	O
Expr	struct
*	O
)	O
arg	pointer
->	O
data	pointer
,	O
env	pointer
)	O
;	O
arg	pointer
=	O
arg	pointer
->	O
next	pointer
;	O
start	pointer
=	O
MATCH_ARG	O
(	O
nINTEGER	int
)	O
;	O
end	pointer
=	O
MATCH_ARG	O
(	O
nINTEGER	int
)	O
;	O
LAST_ARG	O
(	O
)	O
;	O
if	O
(	O
start	pointer
->	O
u	union
.	O
integer	int
>	O
end	pointer
->	O
u	union
.	O
integer	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s:%d: %s: start offset is bigger than end offset\n"	pointer
)	O
,	O
filename	pointer
,	O
linenum	int
,	O
prim_name	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
from	pointer
->	O
type	enum
==	O
nSTRING	int
)	O
{	O
if	O
(	O
end	pointer
->	O
u	union
.	O
integer	int
>	O
from	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s:%d: %s: offset out of range\n"	pointer
)	O
,	O
filename	pointer
,	O
linenum	int
,	O
prim_name	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
n	long
=	O
node_alloc	function
(	O
nSTRING	int
)	O
;	O
n	long
->	O
u	union
.	O
str	struct
.	O
len	int
=	O
end	pointer
->	O
u	union
.	O
integer	int
-	O
start	pointer
->	O
u	union
.	O
integer	int
;	O
n	long
->	O
u	union
.	O
str	struct
.	O
data	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
n	long
->	O
u	union
.	O
str	struct
.	O
len	int
+	O
1	int
)	O
;	O
memcpy	function
(	O
n	long
->	O
u	union
.	O
str	struct
.	O
data	pointer
,	O
from	pointer
->	O
u	union
.	O
str	struct
.	O
data	pointer
+	O
start	pointer
->	O
u	union
.	O
integer	int
,	O
n	long
->	O
u	union
.	O
str	struct
.	O
len	int
)	O
;	O
}	O
else	O
if	O
(	O
from	pointer
->	O
type	enum
==	O
nARRAY	int
)	O
{	O
if	O
(	O
end	pointer
->	O
u	union
.	O
integer	int
>	O
from	pointer
->	O
u	union
.	O
array	pointer
.	O
len	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s:%d: %s: offset out of range\n"	pointer
)	O
,	O
filename	pointer
,	O
linenum	int
,	O
prim_name	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
n	long
=	O
node_alloc	function
(	O
nARRAY	int
)	O
;	O
n	long
->	O
u	union
.	O
array	pointer
.	O
len	int
=	O
end	pointer
->	O
u	union
.	O
integer	int
-	O
start	pointer
->	O
u	union
.	O
integer	int
;	O
n	long
->	O
u	union
.	O
array	pointer
.	O
allocated	long
=	O
n	long
->	O
u	union
.	O
array	pointer
.	O
len	int
+	O
1	int
;	O
n	long
->	O
u	union
.	O
array	pointer
.	O
array	pointer
=	O
(	O
Node	struct
*	O
*	O
)	O
xcalloc	function
(	O
n	long
->	O
u	union
.	O
array	pointer
.	O
allocated	long
,	O
sizeof	O
(	O
Node	struct
*	O
)	O
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
n	long
->	O
u	union
.	O
array	pointer
.	O
len	int
;	O
i	pointer
++	O
)	O
n	long
->	O
u	union
.	O
array	pointer
.	O
array	pointer
[	O
i	pointer
]	O
=	O
node_copy	function
(	O
from	pointer
->	O
u	union
.	O
array	pointer
.	O
array	pointer
[	O
i	pointer
+	O
start	pointer
->	O
u	union
.	O
integer	int
]	O
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s:%d: %s: illegal argument\n"	pointer
)	O
,	O
filename	pointer
,	O
linenum	int
,	O
prim_name	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
node_free	function
(	O
from	pointer
)	O
;	O
node_free	function
(	O
start	pointer
)	O
;	O
node_free	function
(	O
end	pointer
)	O
;	O
return	O
n	long
;	O
}	O
DEFUN	O
(	O
prim_regexp	function
)	O
{	O
ListItem	struct
*	O
arg	pointer
=	O
args	pointer
->	O
head	pointer
;	O
Node	struct
*	O
str	struct
,	O
*	O
n	long
;	O
str	struct
=	O
MATCH_ARG	O
(	O
nSTRING	int
)	O
;	O
LAST_ARG	O
(	O
)	O
;	O
n	long
=	O
node_alloc	function
(	O
nREGEXP	int
)	O
;	O
n	long
->	O
u	union
.	O
re	struct
.	O
data	pointer
=	O
xmalloc	function
(	O
str	struct
->	O
u	union
.	O
str	struct
.	O
len	int
+	O
1	int
)	O
;	O
n	long
->	O
u	union
.	O
re	struct
.	O
len	int
=	O
str	struct
->	O
u	union
.	O
str	struct
.	O
len	int
;	O
memcpy	function
(	O
n	long
->	O
u	union
.	O
re	struct
.	O
data	pointer
,	O
str	struct
->	O
u	union
.	O
str	struct
.	O
data	pointer
,	O
str	struct
->	O
u	union
.	O
str	struct
.	O
len	int
)	O
;	O
n	long
->	O
u	union
.	O
re	struct
.	O
data	pointer
[	O
str	struct
->	O
u	union
.	O
str	struct
.	O
len	int
]	O
=	O
'\0'	O
;	O
return	O
n	long
;	O
}	O
DEFUN	O
(	O
prim_regexp_syntax	function
)	O
{	O
ListItem	struct
*	O
arg	pointer
=	O
args	pointer
->	O
head	pointer
;	O
Node	struct
*	O
ch	char
,	O
*	O
st	pointer
;	O
char	O
syntax	long
;	O
ch	char
=	O
MATCH_ARG	O
(	O
nINTEGER	int
)	O
;	O
st	pointer
=	O
MATCH_ARG	O
(	O
nINTEGER	int
)	O
;	O
LAST_ARG	O
(	O
)	O
;	O
syntax	long
=	O
(	O
char	O
)	O
st	pointer
->	O
u	union
.	O
integer	int
;	O
if	O
(	O
syntax	long
!=	O
'w'	O
&&	O
syntax	long
!=	O
' '	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s:%d: %s: illegal regexp character syntax: %c\n"	pointer
)	O
,	O
filename	pointer
,	O
linenum	int
,	O
prim_name	pointer
,	O
syntax	long
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
re_set_character_syntax	function
(	O
(	O
unsigned	O
char	O
)	O
ch	char
->	O
u	union
.	O
integer	int
,	O
syntax	long
)	O
;	O
return	O
nvoid	pointer
;	O
}	O
DEFUN	O
(	O
prim_regmatch	function
)	O
{	O
ListItem	struct
*	O
arg	pointer
=	O
args	pointer
->	O
head	pointer
;	O
Node	struct
*	O
str	struct
,	O
*	O
re	struct
,	O
*	O
n	long
;	O
static	O
struct	O
re_registers	struct
matches	struct
=	O
{	O
0	int
,	O
NULL	O
,	O
NULL	O
}	O
;	O
static	O
Node	struct
*	O
current_match_node	pointer
=	O
NULL	O
;	O
int	O
i	pointer
;	O
str	struct
=	O
MATCH_ARG	O
(	O
nSTRING	int
)	O
;	O
re	struct
=	O
MATCH_ARG	O
(	O
nREGEXP	int
)	O
;	O
LAST_ARG	O
(	O
)	O
;	O
i	pointer
=	O
re_search	function
(	O
REGEXP	O
(	O
re	struct
)	O
,	O
str	struct
->	O
u	union
.	O
str	struct
.	O
data	pointer
,	O
str	struct
->	O
u	union
.	O
str	struct
.	O
len	int
,	O
0	int
,	O
str	struct
->	O
u	union
.	O
str	struct
.	O
len	int
,	O
&	O
matches	struct
)	O
;	O
if	O
(	O
i	pointer
<	O
0	int
)	O
{	O
current_match	pointer
=	O
NULL	O
;	O
node_free	function
(	O
str	struct
)	O
;	O
}	O
else	O
{	O
node_free	function
(	O
current_match_node	pointer
)	O
;	O
current_match_node	pointer
=	O
str	struct
;	O
current_match	pointer
=	O
&	O
matches	struct
;	O
current_match_buf	pointer
=	O
str	struct
->	O
u	union
.	O
str	struct
.	O
data	pointer
;	O
}	O
node_free	function
(	O
re	struct
)	O
;	O
n	long
=	O
node_alloc	function
(	O
nINTEGER	int
)	O
;	O
n	long
->	O
u	union
.	O
integer	int
=	O
(	O
i	pointer
>=	O
0	int
)	O
;	O
return	O
n	long
;	O
}	O
Node	struct
*	O
do_regsubsts	function
(	O
str	struct
,	O
re	struct
,	O
subst	pointer
,	O
allp	int
)	O
Node	struct
*	O
str	struct
;	O
Node	struct
*	O
re	struct
;	O
Node	struct
*	O
subst	pointer
;	O
int	O
allp	int
;	O
{	O
int	O
i	pointer
,	O
pos	int
,	O
j	int
;	O
static	O
struct	O
re_registers	struct
matches	struct
=	O
{	O
0	int
,	O
NULL	O
,	O
NULL	O
}	O
;	O
static	O
char	O
*	O
result	int
=	O
NULL	O
;	O
static	O
unsigned	O
int	O
result_len	int
=	O
0	int
;	O
unsigned	O
int	O
result_pos	int
=	O
0	int
;	O
int	O
num_matches	int
=	O
0	int
;	O
int	O
do_expansions_in_substs	int
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
subst	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
;	O
i	pointer
++	O
)	O
if	O
(	O
subst	pointer
->	O
u	union
.	O
str	struct
.	O
data	pointer
[	O
i	pointer
]	O
==	O
'$'	O
)	O
{	O
do_expansions_in_substs	int
=	O
1	int
;	O
break	O
;	O
}	O
pos	int
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
i	pointer
=	O
re_search	function
(	O
REGEXP	O
(	O
re	struct
)	O
,	O
str	struct
->	O
u	union
.	O
str	struct
.	O
data	pointer
,	O
str	struct
->	O
u	union
.	O
str	struct
.	O
len	int
,	O
pos	int
,	O
str	struct
->	O
u	union
.	O
str	struct
.	O
len	int
-	O
pos	int
,	O
&	O
matches	struct
)	O
;	O
if	O
(	O
i	pointer
<	O
0	int
)	O
goto	O
out	O
;	O
num_matches	int
++	O
;	O
APPEND	O
(	O
str	struct
->	O
u	union
.	O
str	struct
.	O
data	pointer
+	O
pos	int
,	O
matches	struct
.	O
start	pointer
[	O
0	int
]	O
-	O
pos	int
)	O
;	O
if	O
(	O
!	O
do_expansions_in_substs	int
)	O
APPEND	O
(	O
subst	pointer
->	O
u	union
.	O
str	struct
.	O
data	pointer
,	O
subst	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
)	O
;	O
else	O
{	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
subst	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
;	O
i	pointer
++	O
)	O
if	O
(	O
subst	pointer
->	O
u	union
.	O
str	struct
.	O
data	pointer
[	O
i	pointer
]	O
==	O
'$'	O
&&	O
i	pointer
+	O
1	int
<	O
subst	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
)	O
{	O
i	pointer
++	O
;	O
switch	O
(	O
subst	pointer
->	O
u	union
.	O
str	struct
.	O
data	pointer
[	O
i	pointer
]	O
)	O
{	O
case	O
'$'	O
:	O
APPEND	O
(	O
"$"	pointer
,	O
1	int
)	O
;	O
break	O
;	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
j	int
=	O
subst	pointer
->	O
u	union
.	O
str	struct
.	O
data	pointer
[	O
i	pointer
]	O
-	O
'0'	O
;	O
if	O
(	O
matches	struct
.	O
start	pointer
[	O
j	int
]	O
>=	O
0	int
)	O
APPEND	O
(	O
str	struct
->	O
u	union
.	O
str	struct
.	O
data	pointer
+	O
matches	struct
.	O
start	pointer
[	O
j	int
]	O
,	O
matches	struct
.	O
end	pointer
[	O
j	int
]	O
-	O
matches	struct
.	O
start	pointer
[	O
j	int
]	O
)	O
;	O
break	O
;	O
default	O
:	O
APPEND	O
(	O
"$"	pointer
,	O
1	int
)	O
;	O
APPEND	O
(	O
subst	pointer
->	O
u	union
.	O
str	struct
.	O
data	pointer
+	O
i	pointer
,	O
1	int
)	O
;	O
break	O
;	O
}	O
}	O
else	O
APPEND	O
(	O
subst	pointer
->	O
u	union
.	O
str	struct
.	O
data	pointer
+	O
i	pointer
,	O
1	int
)	O
;	O
}	O
pos	int
=	O
matches	struct
.	O
end	pointer
[	O
0	int
]	O
;	O
if	O
(	O
!	O
allp	int
)	O
break	O
;	O
}	O
out	O
:	O
if	O
(	O
num_matches	int
==	O
0	int
)	O
{	O
node_free	function
(	O
re	struct
)	O
;	O
node_free	function
(	O
subst	pointer
)	O
;	O
return	O
str	struct
;	O
}	O
APPEND	O
(	O
str	struct
->	O
u	union
.	O
str	struct
.	O
data	pointer
+	O
pos	int
,	O
str	struct
->	O
u	union
.	O
str	struct
.	O
len	int
-	O
pos	int
)	O
;	O
node_free	function
(	O
str	struct
)	O
;	O
node_free	function
(	O
re	struct
)	O
;	O
node_free	function
(	O
subst	pointer
)	O
;	O
str	struct
=	O
node_alloc	function
(	O
nSTRING	int
)	O
;	O
str	struct
->	O
u	union
.	O
str	struct
.	O
len	int
=	O
result_pos	int
;	O
str	struct
->	O
u	union
.	O
str	struct
.	O
data	pointer
=	O
xmalloc	function
(	O
result_pos	int
)	O
;	O
memcpy	function
(	O
str	struct
->	O
u	union
.	O
str	struct
.	O
data	pointer
,	O
result	int
,	O
result_pos	int
)	O
;	O
return	O
str	struct
;	O
}	O
DEFUN	O
(	O
prim_regsub	function
)	O
{	O
ListItem	struct
*	O
arg	pointer
=	O
args	pointer
->	O
head	pointer
;	O
Node	struct
*	O
str	struct
,	O
*	O
re	struct
,	O
*	O
subst	pointer
;	O
str	struct
=	O
MATCH_ARG	O
(	O
nSTRING	int
)	O
;	O
re	struct
=	O
MATCH_ARG	O
(	O
nREGEXP	int
)	O
;	O
subst	pointer
=	O
MATCH_ARG	O
(	O
nSTRING	int
)	O
;	O
LAST_ARG	O
(	O
)	O
;	O
return	O
do_regsubsts	function
(	O
str	struct
,	O
re	struct
,	O
subst	pointer
,	O
0	int
)	O
;	O
}	O
DEFUN	O
(	O
prim_regsuball	function
)	O
{	O
ListItem	struct
*	O
arg	pointer
=	O
args	pointer
->	O
head	pointer
;	O
Node	struct
*	O
str	struct
,	O
*	O
re	struct
,	O
*	O
subst	pointer
;	O
str	struct
=	O
MATCH_ARG	O
(	O
nSTRING	int
)	O
;	O
re	struct
=	O
MATCH_ARG	O
(	O
nREGEXP	int
)	O
;	O
subst	pointer
=	O
MATCH_ARG	O
(	O
nSTRING	int
)	O
;	O
LAST_ARG	O
(	O
)	O
;	O
return	O
do_regsubsts	function
(	O
str	struct
,	O
re	struct
,	O
subst	pointer
,	O
1	int
)	O
;	O
}	O
DEFUN	O
(	O
prim_require_state	function
)	O
{	O
ListItem	struct
*	O
arg	pointer
=	O
args	pointer
->	O
head	pointer
;	O
Expr	struct
*	O
e	pointer
;	O
char	O
*	O
cp	pointer
;	O
State	struct
*	O
state	pointer
;	O
e	pointer
=	O
(	O
Expr	struct
*	O
)	O
arg	pointer
->	O
data	pointer
;	O
if	O
(	O
e	pointer
->	O
type	enum
!=	O
eSYMBOL	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s:%d: %s: illegal argument type\n"	pointer
)	O
,	O
filename	pointer
,	O
linenum	int
,	O
prim_name	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
cp	pointer
=	O
e	pointer
->	O
u	union
.	O
node	pointer
->	O
u	union
.	O
sym	pointer
;	O
arg	pointer
=	O
arg	pointer
->	O
next	pointer
;	O
LAST_ARG	O
(	O
)	O
;	O
state	pointer
=	O
lookup_state	function
(	O
cp	pointer
)	O
;	O
if	O
(	O
state	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s:%d: %s: couldn't define state `%s'\n"	pointer
)	O
,	O
filename	pointer
,	O
linenum	int
,	O
prim_name	pointer
,	O
cp	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
return	O
nvoid	pointer
;	O
}	O
DEFUN	O
(	O
prim_split	function
)	O
{	O
ListItem	struct
*	O
arg	pointer
=	O
args	pointer
->	O
head	pointer
;	O
Node	struct
*	O
re	struct
,	O
*	O
str	struct
,	O
*	O
n	long
,	O
*	O
n2	pointer
;	O
int	O
pos	int
,	O
i	pointer
;	O
re	struct
=	O
MATCH_ARG	O
(	O
nREGEXP	int
)	O
;	O
str	struct
=	O
MATCH_ARG	O
(	O
nSTRING	int
)	O
;	O
LAST_ARG	O
(	O
)	O
;	O
n	long
=	O
node_alloc	function
(	O
nARRAY	int
)	O
;	O
n	long
->	O
u	union
.	O
array	pointer
.	O
allocated	long
=	O
100	int
;	O
n	long
->	O
u	union
.	O
array	pointer
.	O
array	pointer
=	O
(	O
Node	struct
*	O
*	O
)	O
xcalloc	function
(	O
n	long
->	O
u	union
.	O
array	pointer
.	O
allocated	long
,	O
sizeof	O
(	O
Node	struct
*	O
)	O
)	O
;	O
for	O
(	O
pos	int
=	O
0	int
;	O
pos	int
<	O
str	struct
->	O
u	union
.	O
str	struct
.	O
len	int
;	O
)	O
{	O
i	pointer
=	O
re_search	function
(	O
REGEXP	O
(	O
re	struct
)	O
,	O
str	struct
->	O
u	union
.	O
str	struct
.	O
data	pointer
,	O
str	struct
->	O
u	union
.	O
str	struct
.	O
len	int
,	O
pos	int
,	O
str	struct
->	O
u	union
.	O
str	struct
.	O
len	int
-	O
pos	int
,	O
&	O
re	struct
->	O
u	union
.	O
re	struct
.	O
matches	struct
)	O
;	O
if	O
(	O
i	pointer
<	O
0	int
)	O
break	O
;	O
n2	pointer
=	O
node_alloc	function
(	O
nSTRING	int
)	O
;	O
n2	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
=	O
i	pointer
-	O
pos	int
;	O
n2	pointer
->	O
u	union
.	O
str	struct
.	O
data	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
n2	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
+	O
1	int
)	O
;	O
memcpy	function
(	O
n2	pointer
->	O
u	union
.	O
str	struct
.	O
data	pointer
,	O
str	struct
->	O
u	union
.	O
str	struct
.	O
data	pointer
+	O
pos	int
,	O
n2	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
)	O
;	O
pos	int
=	O
re	struct
->	O
u	union
.	O
re	struct
.	O
matches	struct
.	O
end	pointer
[	O
0	int
]	O
;	O
if	O
(	O
n	long
->	O
u	union
.	O
array	pointer
.	O
len	int
+	O
1	int
>=	O
n	long
->	O
u	union
.	O
array	pointer
.	O
allocated	long
)	O
{	O
n	long
->	O
u	union
.	O
array	pointer
.	O
allocated	long
+=	O
100	int
;	O
n	long
->	O
u	union
.	O
array	pointer
.	O
array	pointer
=	O
(	O
Node	struct
*	O
*	O
)	O
xrealloc	function
(	O
n	long
->	O
u	union
.	O
array	pointer
.	O
array	pointer
,	O
n	long
->	O
u	union
.	O
array	pointer
.	O
allocated	long
*	O
sizeof	O
(	O
Node	struct
*	O
)	O
)	O
;	O
}	O
n	long
->	O
u	union
.	O
array	pointer
.	O
array	pointer
[	O
n	long
->	O
u	union
.	O
array	pointer
.	O
len	int
++	O
]	O
=	O
n2	pointer
;	O
}	O
n2	pointer
=	O
node_alloc	function
(	O
nSTRING	int
)	O
;	O
n2	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
=	O
str	struct
->	O
u	union
.	O
str	struct
.	O
len	int
-	O
pos	int
;	O
n2	pointer
->	O
u	union
.	O
str	struct
.	O
data	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
n2	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
+	O
1	int
)	O
;	O
memcpy	function
(	O
n2	pointer
->	O
u	union
.	O
str	struct
.	O
data	pointer
,	O
str	struct
->	O
u	union
.	O
str	struct
.	O
data	pointer
+	O
pos	int
,	O
n2	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
)	O
;	O
n	long
->	O
u	union
.	O
array	pointer
.	O
array	pointer
[	O
n	long
->	O
u	union
.	O
array	pointer
.	O
len	int
++	O
]	O
=	O
n2	pointer
;	O
return	O
n	long
;	O
}	O
DEFUN	O
(	O
prim_sprintf	function
)	O
{	O
ListItem	struct
*	O
arg	pointer
=	O
args	pointer
->	O
head	pointer
;	O
Node	struct
*	O
fmt	pointer
,	O
*	O
n	long
;	O
char	O
buf	array
[	O
512	int
]	O
;	O
char	O
ifmt	array
[	O
256	int
]	O
;	O
char	O
ifmtopts	array
[	O
256	int
]	O
;	O
char	O
*	O
result	int
=	O
NULL	O
;	O
unsigned	O
int	O
result_pos	int
=	O
0	int
;	O
unsigned	O
int	O
result_len	int
=	O
0	int
;	O
int	O
i	pointer
,	O
j	int
;	O
int	O
argument_count	int
=	O
0	int
;	O
char	O
*	O
cp	pointer
;	O
fmt	pointer
=	O
MATCH_ARG	O
(	O
nSTRING	int
)	O
;	O
cp	pointer
=	O
fmt	pointer
->	O
u	union
.	O
str	struct
.	O
data	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
fmt	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
cp	pointer
[	O
i	pointer
]	O
==	O
'%'	O
&&	O
(	O
i	pointer
+	O
1	int
>=	O
fmt	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
||	O
cp	pointer
[	O
i	pointer
+	O
1	int
]	O
==	O
'%'	O
)	O
)	O
{	O
i	pointer
++	O
;	O
APPEND	O
(	O
cp	pointer
+	O
i	pointer
,	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
cp	pointer
[	O
i	pointer
]	O
==	O
'%'	O
)	O
{	O
argument_count	int
++	O
;	O
if	O
(	O
arg	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: primitive `%s': too few arguments for format\n"	pointer
)	O
,	O
program	pointer
,	O
prim_name	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
n	long
=	O
eval_expr	function
(	O
(	O
Expr	struct
*	O
)	O
arg	pointer
->	O
data	pointer
,	O
env	pointer
)	O
;	O
arg	pointer
=	O
arg	pointer
->	O
next	pointer
;	O
for	O
(	O
i	pointer
++	O
,	O
j	int
=	O
0	int
;	O
i	pointer
<	O
fmt	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
&&	O
FMTSPECIAL	O
(	O
cp	pointer
[	O
i	pointer
]	O
)	O
;	O
i	pointer
++	O
,	O
j	int
++	O
)	O
ifmtopts	array
[	O
j	int
]	O
=	O
cp	pointer
[	O
i	pointer
]	O
;	O
ifmtopts	array
[	O
j	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
i	pointer
>=	O
fmt	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
)	O
{	O
APPEND	O
(	O
"%"	pointer
,	O
1	int
)	O
;	O
APPEND	O
(	O
ifmtopts	array
,	O
j	int
)	O
;	O
continue	O
;	O
}	O
switch	O
(	O
cp	pointer
[	O
i	pointer
]	O
)	O
{	O
case	O
'x'	O
:	O
case	O
'X'	O
:	O
case	O
'd'	O
:	O
if	O
(	O
n	long
->	O
type	enum
!=	O
nINTEGER	int
)	O
{	O
no_match	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s:%d: %s: argument %d doesn't match format\n"	pointer
)	O
,	O
filename	pointer
,	O
linenum	int
,	O
prim_name	pointer
,	O
argument_count	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
sprintf	function
(	O
ifmt	array
,	O
"%%%s%c"	pointer
,	O
ifmtopts	array
,	O
cp	pointer
[	O
i	pointer
]	O
)	O
;	O
sprintf	function
(	O
buf	array
,	O
ifmt	array
,	O
n	long
->	O
u	union
.	O
integer	int
)	O
;	O
APPEND	O
(	O
buf	array
,	O
strlen	function
(	O
buf	array
)	O
)	O
;	O
break	O
;	O
case	O
'c'	O
:	O
if	O
(	O
n	long
->	O
type	enum
!=	O
nINTEGER	int
)	O
goto	O
no_match	O
;	O
sprintf	function
(	O
ifmt	array
,	O
"%%%s%c"	pointer
,	O
ifmtopts	array
,	O
cp	pointer
[	O
i	pointer
]	O
)	O
;	O
sprintf	function
(	O
buf	array
,	O
ifmt	array
,	O
n	long
->	O
u	union
.	O
integer	int
)	O
;	O
APPEND	O
(	O
buf	array
,	O
strlen	function
(	O
buf	array
)	O
)	O
;	O
break	O
;	O
case	O
'f'	O
:	O
case	O
'g'	O
:	O
case	O
'e'	O
:	O
case	O
'E'	O
:	O
if	O
(	O
n	long
->	O
type	enum
!=	O
nREAL	int
)	O
goto	O
no_match	O
;	O
sprintf	function
(	O
ifmt	array
,	O
"%%%s%c"	pointer
,	O
ifmtopts	array
,	O
cp	pointer
[	O
i	pointer
]	O
)	O
;	O
sprintf	function
(	O
buf	array
,	O
ifmt	array
,	O
n	long
->	O
u	union
.	O
real	double
)	O
;	O
APPEND	O
(	O
buf	array
,	O
strlen	function
(	O
buf	array
)	O
)	O
;	O
break	O
;	O
case	O
's'	O
:	O
if	O
(	O
n	long
->	O
type	enum
!=	O
nSTRING	int
)	O
goto	O
no_match	O
;	O
if	O
(	O
ifmtopts	array
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s:%d: %s: no extra options can be specified for %%s\n"	pointer
)	O
,	O
filename	pointer
,	O
linenum	int
,	O
prim_name	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
APPEND	O
(	O
n	long
->	O
u	union
.	O
str	struct
.	O
data	pointer
,	O
n	long
->	O
u	union
.	O
str	struct
.	O
len	int
)	O
;	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s:%d: %s: illegal type specifier `%c'\n"	pointer
)	O
,	O
filename	pointer
,	O
linenum	int
,	O
prim_name	pointer
,	O
cp	pointer
[	O
i	pointer
]	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
break	O
;	O
}	O
}	O
else	O
APPEND	O
(	O
cp	pointer
+	O
i	pointer
,	O
1	int
)	O
;	O
}	O
node_free	function
(	O
fmt	pointer
)	O
;	O
n	long
=	O
node_alloc	function
(	O
nSTRING	int
)	O
;	O
n	long
->	O
u	union
.	O
str	struct
.	O
len	int
=	O
result_pos	int
;	O
n	long
->	O
u	union
.	O
str	struct
.	O
data	pointer
=	O
result	int
;	O
return	O
n	long
;	O
}	O
DEFUN	O
(	O
prim_strcmp	function
)	O
{	O
ListItem	struct
*	O
arg	pointer
=	O
args	pointer
->	O
head	pointer
;	O
Node	struct
*	O
s1	pointer
,	O
*	O
s2	pointer
;	O
Node	struct
*	O
n	long
;	O
int	O
i	pointer
,	O
result	int
;	O
char	O
*	O
cp1	pointer
,	O
*	O
cp2	pointer
;	O
s1	pointer
=	O
MATCH_ARG	O
(	O
nSTRING	int
)	O
;	O
s2	pointer
=	O
MATCH_ARG	O
(	O
nSTRING	int
)	O
;	O
LAST_ARG	O
(	O
)	O
;	O
cp1	pointer
=	O
s1	pointer
->	O
u	union
.	O
str	struct
.	O
data	pointer
;	O
cp2	pointer
=	O
s2	pointer
->	O
u	union
.	O
str	struct
.	O
data	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
s1	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
&&	O
i	pointer
<	O
s2	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
cp1	pointer
[	O
i	pointer
]	O
<	O
cp2	pointer
[	O
i	pointer
]	O
)	O
{	O
result	int
=	O
-	O
1	int
;	O
goto	O
out	O
;	O
}	O
if	O
(	O
cp1	pointer
[	O
i	pointer
]	O
>	O
cp2	pointer
[	O
i	pointer
]	O
)	O
{	O
result	int
=	O
1	int
;	O
goto	O
out	O
;	O
}	O
}	O
if	O
(	O
s1	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
<	O
s2	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
)	O
result	int
=	O
-	O
1	int
;	O
else	O
if	O
(	O
s1	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
>	O
s2	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
)	O
result	int
=	O
1	int
;	O
else	O
result	int
=	O
0	int
;	O
out	O
:	O
node_free	function
(	O
s1	pointer
)	O
;	O
node_free	function
(	O
s2	pointer
)	O
;	O
n	long
=	O
node_alloc	function
(	O
nINTEGER	int
)	O
;	O
n	long
->	O
u	union
.	O
integer	int
=	O
result	int
;	O
return	O
n	long
;	O
}	O
DEFUN	O
(	O
prim_string	function
)	O
{	O
ListItem	struct
*	O
arg	pointer
=	O
args	pointer
->	O
head	pointer
;	O
Node	struct
*	O
n	long
,	O
*	O
r	pointer
;	O
char	O
buf	array
[	O
512	int
]	O
;	O
n	long
=	O
MATCH_ARG	O
(	O
nVOID	int
)	O
;	O
LAST_ARG	O
(	O
)	O
;	O
r	pointer
=	O
node_alloc	function
(	O
nSTRING	int
)	O
;	O
switch	O
(	O
n	long
->	O
type	enum
)	O
{	O
case	O
nVOID	int
:	O
case	O
nREGEXP	int
:	O
case	O
nARRAY	int
:	O
r	pointer
->	O
u	union
.	O
str	struct
.	O
data	pointer
=	O
(	O
char	O
*	O
)	O
xcalloc	function
(	O
1	int
,	O
1	int
)	O
;	O
r	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
=	O
0	int
;	O
break	O
;	O
case	O
nSYMBOL	int
:	O
r	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
=	O
strlen	function
(	O
n	long
->	O
u	union
.	O
sym	pointer
)	O
;	O
r	pointer
->	O
u	union
.	O
str	struct
.	O
data	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
r	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
)	O
;	O
memcpy	function
(	O
r	pointer
->	O
u	union
.	O
str	struct
.	O
data	pointer
,	O
n	long
->	O
u	union
.	O
sym	pointer
,	O
r	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
)	O
;	O
break	O
;	O
case	O
nSTRING	int
:	O
r	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
=	O
n	long
->	O
u	union
.	O
str	struct
.	O
len	int
;	O
r	pointer
->	O
u	union
.	O
str	struct
.	O
data	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
n	long
->	O
u	union
.	O
str	struct
.	O
len	int
)	O
;	O
memcpy	function
(	O
r	pointer
->	O
u	union
.	O
str	struct
.	O
data	pointer
,	O
n	long
->	O
u	union
.	O
str	struct
.	O
data	pointer
,	O
n	long
->	O
u	union
.	O
str	struct
.	O
len	int
)	O
;	O
break	O
;	O
case	O
nINTEGER	int
:	O
sprintf	function
(	O
buf	array
,	O
"%d"	pointer
,	O
n	long
->	O
u	union
.	O
integer	int
)	O
;	O
r	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
=	O
strlen	function
(	O
buf	array
)	O
;	O
r	pointer
->	O
u	union
.	O
str	struct
.	O
data	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
r	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
)	O
;	O
memcpy	function
(	O
r	pointer
->	O
u	union
.	O
str	struct
.	O
data	pointer
,	O
buf	array
,	O
r	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
)	O
;	O
break	O
;	O
case	O
nREAL	int
:	O
sprintf	function
(	O
buf	array
,	O
"%f"	pointer
,	O
n	long
->	O
u	union
.	O
real	double
)	O
;	O
r	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
=	O
strlen	function
(	O
buf	array
)	O
;	O
r	pointer
->	O
u	union
.	O
str	struct
.	O
data	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
r	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
)	O
;	O
memcpy	function
(	O
r	pointer
->	O
u	union
.	O
str	struct
.	O
data	pointer
,	O
buf	array
,	O
r	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
)	O
;	O
break	O
;	O
}	O
node_free	function
(	O
n	long
)	O
;	O
return	O
r	pointer
;	O
}	O
DEFUN	O
(	O
prim_strncmp	function
)	O
{	O
ListItem	struct
*	O
arg	pointer
=	O
args	pointer
->	O
head	pointer
;	O
Node	struct
*	O
s1	pointer
,	O
*	O
s2	pointer
,	O
*	O
len	int
;	O
Node	struct
*	O
n	long
;	O
int	O
i	pointer
,	O
result	int
;	O
char	O
*	O
cp1	pointer
,	O
*	O
cp2	pointer
;	O
s1	pointer
=	O
MATCH_ARG	O
(	O
nSTRING	int
)	O
;	O
s2	pointer
=	O
MATCH_ARG	O
(	O
nSTRING	int
)	O
;	O
len	int
=	O
MATCH_ARG	O
(	O
nINTEGER	int
)	O
;	O
LAST_ARG	O
(	O
)	O
;	O
cp1	pointer
=	O
s1	pointer
->	O
u	union
.	O
str	struct
.	O
data	pointer
;	O
cp2	pointer
=	O
s2	pointer
->	O
u	union
.	O
str	struct
.	O
data	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
s1	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
&&	O
i	pointer
<	O
s2	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
&&	O
i	pointer
<	O
len	int
->	O
u	union
.	O
integer	int
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
cp1	pointer
[	O
i	pointer
]	O
<	O
cp2	pointer
[	O
i	pointer
]	O
)	O
{	O
result	int
=	O
-	O
1	int
;	O
goto	O
out	O
;	O
}	O
if	O
(	O
cp1	pointer
[	O
i	pointer
]	O
>	O
cp2	pointer
[	O
i	pointer
]	O
)	O
{	O
result	int
=	O
1	int
;	O
goto	O
out	O
;	O
}	O
}	O
if	O
(	O
i	pointer
>=	O
len	int
->	O
u	union
.	O
integer	int
)	O
{	O
result	int
=	O
0	int
;	O
goto	O
out	O
;	O
}	O
if	O
(	O
s1	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
<	O
s2	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
)	O
result	int
=	O
-	O
1	int
;	O
else	O
if	O
(	O
s1	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
>	O
s2	pointer
->	O
u	union
.	O
str	struct
.	O
len	int
)	O
result	int
=	O
1	int
;	O
else	O
result	int
=	O
0	int
;	O
out	O
:	O
node_free	function
(	O
s1	pointer
)	O
;	O
node_free	function
(	O
s2	pointer
)	O
;	O
node_free	function
(	O
len	int
)	O
;	O
n	long
=	O
node_alloc	function
(	O
nINTEGER	int
)	O
;	O
n	long
->	O
u	union
.	O
integer	int
=	O
result	int
;	O
return	O
n	long
;	O
}	O
DEFUN	O
(	O
prim_substring	function
)	O
{	O
ListItem	struct
*	O
arg	pointer
=	O
args	pointer
->	O
head	pointer
;	O
Node	struct
*	O
str	struct
,	O
*	O
start	pointer
,	O
*	O
end	pointer
,	O
*	O
n	long
;	O
str	struct
=	O
MATCH_ARG	O
(	O
nSTRING	int
)	O
;	O
start	pointer
=	O
MATCH_ARG	O
(	O
nINTEGER	int
)	O
;	O
end	pointer
=	O
MATCH_ARG	O
(	O
nINTEGER	int
)	O
;	O
LAST_ARG	O
(	O
)	O
;	O
if	O
(	O
start	pointer
->	O
u	union
.	O
integer	int
>	O
end	pointer
->	O
u	union
.	O
integer	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s:%d: %s: start offset is bigger than end offset\n"	pointer
)	O
,	O
filename	pointer
,	O
linenum	int
,	O
prim_name	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
end	pointer
->	O
u	union
.	O
integer	int
>	O
str	struct
->	O
u	union
.	O
str	struct
.	O
len	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s:%d: %s: offset out of range\n"	pointer
)	O
,	O
filename	pointer
,	O
linenum	int
,	O
prim_name	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
n	long
=	O
node_alloc	function
(	O
nSTRING	int
)	O
;	O
n	long
->	O
u	union
.	O
str	struct
.	O
len	int
=	O
end	pointer
->	O
u	union
.	O
integer	int
-	O
start	pointer
->	O
u	union
.	O
integer	int
;	O
n	long
->	O
u	union
.	O
str	struct
.	O
data	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
n	long
->	O
u	union
.	O
str	struct
.	O
len	int
+	O
1	int
)	O
;	O
memcpy	function
(	O
n	long
->	O
u	union
.	O
str	struct
.	O
data	pointer
,	O
str	struct
->	O
u	union
.	O
str	struct
.	O
data	pointer
+	O
start	pointer
->	O
u	union
.	O
integer	int
,	O
n	long
->	O
u	union
.	O
str	struct
.	O
len	int
)	O
;	O
node_free	function
(	O
str	struct
)	O
;	O
node_free	function
(	O
start	pointer
)	O
;	O
node_free	function
(	O
end	pointer
)	O
;	O
return	O
n	long
;	O
}	O
DEFUN	O
(	O
prim_system	function
)	O
{	O
ListItem	struct
*	O
arg	pointer
=	O
args	pointer
->	O
head	pointer
;	O
Node	struct
*	O
str	struct
,	O
*	O
n	long
;	O
char	O
*	O
cmd	pointer
;	O
int	O
result	int
;	O
str	struct
=	O
MATCH_ARG	O
(	O
nSTRING	int
)	O
;	O
LAST_ARG	O
(	O
)	O
;	O
cmd	pointer
=	O
(	O
char	O
*	O
)	O
xcalloc	function
(	O
1	int
,	O
str	struct
->	O
u	union
.	O
str	struct
.	O
len	int
+	O
1	int
)	O
;	O
memcpy	function
(	O
cmd	pointer
,	O
str	struct
->	O
u	union
.	O
str	struct
.	O
data	pointer
,	O
str	struct
->	O
u	union
.	O
str	struct
.	O
len	int
)	O
;	O
result	int
=	O
system	function
(	O
cmd	pointer
)	O
;	O
xfree	function
(	O
cmd	pointer
)	O
;	O
n	long
=	O
node_alloc	function
(	O
nINTEGER	int
)	O
;	O
n	long
->	O
u	union
.	O
integer	int
=	O
result	int
;	O
return	O
n	long
;	O
}	O
static	O
struct	O
{	O
char	O
*	O
name	pointer
;	O
Primitive	pointer
prim	pointer
;	O
}	O
prims	array
[	O
]	O
=	O
{	O
{	O
"call"	pointer
,	O
prim_call	function
}	O
,	O
{	O
"calln"	pointer
,	O
prim_calln	function
}	O
,	O
{	O
"check_namerules"	pointer
,	O
prim_check_namerules	function
}	O
,	O
{	O
"check_startrules"	pointer
,	O
prim_check_startrules	function
}	O
,	O
{	O
"concat"	pointer
,	O
prim_concat	function
}	O
,	O
{	O
"float"	pointer
,	O
prim_float	function
}	O
,	O
{	O
"getenv"	pointer
,	O
prim_getenv	function
}	O
,	O
{	O
"int"	pointer
,	O
prim_int	function
}	O
,	O
{	O
"length"	pointer
,	O
prim_length	function
}	O
,	O
{	O
"list"	pointer
,	O
prim_list	function
}	O
,	O
{	O
"panic"	pointer
,	O
prim_panic	function
}	O
,	O
{	O
"prereq"	pointer
,	O
prim_prereq	function
}	O
,	O
{	O
"print"	pointer
,	O
prim_print	function
}	O
,	O
{	O
"range"	pointer
,	O
prim_range	function
}	O
,	O
{	O
"regexp"	pointer
,	O
prim_regexp	function
}	O
,	O
{	O
"regexp_syntax"	pointer
,	O
prim_regexp_syntax	function
}	O
,	O
{	O
"regmatch"	pointer
,	O
prim_regmatch	function
}	O
,	O
{	O
"regsub"	pointer
,	O
prim_regsub	function
}	O
,	O
{	O
"regsuball"	pointer
,	O
prim_regsuball	function
}	O
,	O
{	O
"require_state"	pointer
,	O
prim_require_state	function
}	O
,	O
{	O
"split"	pointer
,	O
prim_split	function
}	O
,	O
{	O
"sprintf"	pointer
,	O
prim_sprintf	function
}	O
,	O
{	O
"strcmp"	pointer
,	O
prim_strcmp	function
}	O
,	O
{	O
"string"	pointer
,	O
prim_string	function
}	O
,	O
{	O
"strncmp"	pointer
,	O
prim_strncmp	function
}	O
,	O
{	O
"substring"	pointer
,	O
prim_substring	function
}	O
,	O
{	O
"system"	pointer
,	O
prim_system	function
}	O
,	O
{	O
NULL	O
,	O
NULL	O
}	O
,	O
}	O
;	O
void	O
init_primitives	function
(	O
)	O
{	O
void	O
*	O
old	pointer
;	O
int	O
i	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
prims	array
[	O
i	pointer
]	O
.	O
name	pointer
;	O
i	pointer
++	O
)	O
if	O
(	O
!	O
strhash_put	function
(	O
ns_prims	pointer
,	O
prims	array
[	O
i	pointer
]	O
.	O
name	pointer
,	O
strlen	function
(	O
prims	array
[	O
i	pointer
]	O
.	O
name	pointer
)	O
,	O
(	O
void	O
*	O
)	O
prims	array
[	O
i	pointer
]	O
.	O
prim	pointer
,	O
&	O
old	pointer
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: out of memory\n"	pointer
)	O
,	O
program	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
