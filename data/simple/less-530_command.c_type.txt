extern	O
int	O
erase_char	int
,	O
erase2_char	int
,	O
kill_char	int
;	O
extern	O
int	O
sigs	int
;	O
extern	O
int	O
quit_if_one_screen	int
;	O
extern	O
int	O
squished	int
;	O
extern	O
int	O
sc_width	int
;	O
extern	O
int	O
sc_height	int
;	O
extern	O
char	O
*	O
kent	pointer
;	O
extern	O
int	O
swindow	int
;	O
extern	O
int	O
jump_sline	int
;	O
extern	O
int	O
quitting	int
;	O
extern	O
int	O
wscroll	int
;	O
extern	O
int	O
top_scroll	int
;	O
extern	O
int	O
ignore_eoi	int
;	O
extern	O
int	O
secure	int
;	O
extern	O
int	O
hshift	int
;	O
extern	O
int	O
bs_mode	int
;	O
extern	O
int	O
show_attn	int
;	O
extern	O
int	O
status_col	int
;	O
extern	O
POSITION	long
highest_hilite	long
;	O
extern	O
POSITION	long
start_attnpos	long
;	O
extern	O
POSITION	long
end_attnpos	long
;	O
extern	O
char	O
*	O
every_first_cmd	pointer
;	O
extern	O
char	O
version	array
[	O
]	O
;	O
extern	O
struct	O
scrpos	struct
initial_scrpos	struct
;	O
extern	O
IFILE	O
curr_ifile	pointer
;	O
extern	O
void	O
*	O
ml_search	pointer
;	O
extern	O
void	O
*	O
ml_examine	pointer
;	O
extern	O
void	O
*	O
ml_shell	pointer
;	O
extern	O
char	O
*	O
editor	pointer
;	O
extern	O
char	O
*	O
editproto	pointer
;	O
extern	O
int	O
screen_trashed	int
;	O
extern	O
int	O
shift_count	int
;	O
extern	O
int	O
oldbot	int
;	O
extern	O
int	O
forw_prompt	int
;	O
static	O
char	O
*	O
shellcmd	pointer
=	O
NULL	O
;	O
static	O
int	O
mca	int
;	O
static	O
int	O
search_type	int
;	O
static	O
LINENUM	long
number	long
;	O
static	O
long	O
fraction	long
;	O
static	O
struct	O
loption	struct
*	O
curropt	pointer
;	O
static	O
int	O
opt_lower	int
;	O
static	O
int	O
optflag	int
;	O
static	O
int	O
optgetname	int
;	O
static	O
POSITION	long
bottompos	long
;	O
static	O
int	O
save_hshift	int
;	O
static	O
int	O
save_bs_mode	int
;	O
static	O
char	O
pipec	char
;	O
struct	O
ungot	struct
{	O
struct	O
ungot	struct
*	O
ug_next	pointer
;	O
LWCHAR	long
ug_char	long
;	O
}	O
;	O
static	O
struct	O
ungot	struct
*	O
ungot	struct
=	O
NULL	O
;	O
static	O
void	O
multi_search	function
(	O
)	O
;	O
static	O
void	O
cmd_exec	function
(	O
)	O
{	O
clear_attn	function
(	O
)	O
;	O
clear_bot	function
(	O
)	O
;	O
flush	function
(	O
)	O
;	O
}	O
static	O
void	O
start_mca	function
(	O
action	int
,	O
prompt	pointer
,	O
mlist	pointer
,	O
cmdflags	int
)	O
int	O
action	int
;	O
constant	O
char	O
*	O
prompt	pointer
;	O
void	O
*	O
mlist	pointer
;	O
int	O
cmdflags	int
;	O
{	O
mca	int
=	O
action	int
;	O
clear_bot	function
(	O
)	O
;	O
clear_cmd	function
(	O
)	O
;	O
cmd_putstr	function
(	O
prompt	pointer
)	O
;	O
set_mlist	function
(	O
mlist	pointer
,	O
cmdflags	int
)	O
;	O
}	O
public	O
int	O
in_mca	function
(	O
)	O
{	O
return	O
(	O
mca	int
!=	O
0	int
&&	O
mca	int
!=	O
A_PREFIX	int
)	O
;	O
}	O
static	O
void	O
mca_search	function
(	O
)	O
{	O
if	O
(	O
search_type	int
&	O
SRCH_FILTER	O
)	O
mca	int
=	O
A_FILTER	int
;	O
else	O
if	O
(	O
search_type	int
&	O
SRCH_FORW	O
)	O
mca	int
=	O
A_F_SEARCH	int
;	O
else	O
mca	int
=	O
A_B_SEARCH	int
;	O
clear_bot	function
(	O
)	O
;	O
clear_cmd	function
(	O
)	O
;	O
if	O
(	O
search_type	int
&	O
SRCH_NO_MATCH	O
)	O
cmd_putstr	function
(	O
"Non-match "	pointer
)	O
;	O
if	O
(	O
search_type	int
&	O
SRCH_FIRST_FILE	O
)	O
cmd_putstr	function
(	O
"First-file "	pointer
)	O
;	O
if	O
(	O
search_type	int
&	O
SRCH_PAST_EOF	O
)	O
cmd_putstr	function
(	O
"EOF-ignore "	pointer
)	O
;	O
if	O
(	O
search_type	int
&	O
SRCH_NO_MOVE	O
)	O
cmd_putstr	function
(	O
"Keep-pos "	pointer
)	O
;	O
if	O
(	O
search_type	int
&	O
SRCH_NO_REGEX	O
)	O
cmd_putstr	function
(	O
"Regex-off "	pointer
)	O
;	O
if	O
(	O
search_type	int
&	O
SRCH_FILTER	O
)	O
cmd_putstr	function
(	O
"&/"	pointer
)	O
;	O
else	O
if	O
(	O
search_type	int
&	O
SRCH_FORW	O
)	O
cmd_putstr	function
(	O
"/"	pointer
)	O
;	O
else	O
cmd_putstr	function
(	O
"?"	pointer
)	O
;	O
forw_prompt	int
=	O
0	int
;	O
set_mlist	function
(	O
ml_search	pointer
,	O
0	int
)	O
;	O
}	O
static	O
void	O
mca_opt_toggle	function
(	O
)	O
{	O
int	O
no_prompt	int
;	O
int	O
flag	int
;	O
char	O
*	O
dash	pointer
;	O
no_prompt	int
=	O
(	O
optflag	int
&	O
OPT_NO_PROMPT	int
)	O
;	O
flag	int
=	O
(	O
optflag	int
&	O
~	O
OPT_NO_PROMPT	int
)	O
;	O
dash	pointer
=	O
(	O
flag	int
==	O
OPT_NO_TOGGLE	int
)	O
?	O
"_"	pointer
:	O
"-"	pointer
;	O
mca	int
=	O
A_OPT_TOGGLE	int
;	O
clear_bot	function
(	O
)	O
;	O
clear_cmd	function
(	O
)	O
;	O
cmd_putstr	function
(	O
dash	pointer
)	O
;	O
if	O
(	O
optgetname	int
)	O
cmd_putstr	function
(	O
dash	pointer
)	O
;	O
if	O
(	O
no_prompt	int
)	O
cmd_putstr	function
(	O
"(P)"	pointer
)	O
;	O
switch	O
(	O
flag	int
)	O
{	O
case	O
OPT_UNSET	int
:	O
cmd_putstr	function
(	O
"+"	pointer
)	O
;	O
break	O
;	O
case	O
OPT_SET	int
:	O
cmd_putstr	function
(	O
"!"	pointer
)	O
;	O
break	O
;	O
}	O
forw_prompt	int
=	O
0	int
;	O
set_mlist	function
(	O
NULL	O
,	O
0	int
)	O
;	O
}	O
static	O
void	O
exec_mca	function
(	O
)	O
{	O
char	O
*	O
cbuf	pointer
;	O
cmd_exec	function
(	O
)	O
;	O
cbuf	pointer
=	O
get_cmdbuf	function
(	O
)	O
;	O
switch	O
(	O
mca	int
)	O
{	O
case	O
A_F_SEARCH	int
:	O
case	O
A_B_SEARCH	int
:	O
multi_search	function
(	O
cbuf	pointer
,	O
(	O
int	O
)	O
number	long
,	O
0	int
)	O
;	O
break	O
;	O
case	O
A_FILTER	int
:	O
search_type	int
^=	O
SRCH_NO_MATCH	O
;	O
set_filter_pattern	function
(	O
cbuf	pointer
,	O
search_type	int
)	O
;	O
break	O
;	O
case	O
A_FIRSTCMD	int
:	O
while	O
(	O
*	O
cbuf	pointer
==	O
'+'	O
||	O
*	O
cbuf	pointer
==	O
' '	O
)	O
cbuf	pointer
++	O
;	O
if	O
(	O
every_first_cmd	pointer
!=	O
NULL	O
)	O
free	function
(	O
every_first_cmd	pointer
)	O
;	O
if	O
(	O
*	O
cbuf	pointer
==	O
'\0'	O
)	O
every_first_cmd	pointer
=	O
NULL	O
;	O
else	O
every_first_cmd	pointer
=	O
save	function
(	O
cbuf	pointer
)	O
;	O
break	O
;	O
case	O
A_OPT_TOGGLE	int
:	O
toggle_option	function
(	O
curropt	pointer
,	O
opt_lower	int
,	O
cbuf	pointer
,	O
optflag	int
)	O
;	O
curropt	pointer
=	O
NULL	O
;	O
break	O
;	O
case	O
A_F_BRACKET	int
:	O
match_brac	function
(	O
cbuf	pointer
[	O
0	int
]	O
,	O
cbuf	pointer
[	O
1	int
]	O
,	O
1	int
,	O
(	O
int	O
)	O
number	long
)	O
;	O
break	O
;	O
case	O
A_B_BRACKET	int
:	O
match_brac	function
(	O
cbuf	pointer
[	O
1	int
]	O
,	O
cbuf	pointer
[	O
0	int
]	O
,	O
0	int
,	O
(	O
int	O
)	O
number	long
)	O
;	O
break	O
;	O
case	O
A_EXAMINE	int
:	O
if	O
(	O
secure	int
)	O
break	O
;	O
edit_list	function
(	O
cbuf	pointer
)	O
;	O
cleantags	function
(	O
)	O
;	O
break	O
;	O
case	O
A_SHELL	int
:	O
if	O
(	O
*	O
cbuf	pointer
!=	O
'!'	O
)	O
{	O
if	O
(	O
shellcmd	pointer
!=	O
NULL	O
)	O
free	function
(	O
shellcmd	pointer
)	O
;	O
shellcmd	pointer
=	O
fexpand	function
(	O
cbuf	pointer
)	O
;	O
}	O
if	O
(	O
secure	int
)	O
break	O
;	O
if	O
(	O
shellcmd	pointer
==	O
NULL	O
)	O
lsystem	function
(	O
""	pointer
,	O
"!done"	pointer
)	O
;	O
else	O
lsystem	function
(	O
shellcmd	pointer
,	O
"!done"	pointer
)	O
;	O
break	O
;	O
case	O
A_PIPE	int
:	O
if	O
(	O
secure	int
)	O
break	O
;	O
(	O
void	O
)	O
pipe_mark	function
(	O
pipec	char
,	O
cbuf	pointer
)	O
;	O
error	function
(	O
"|done"	pointer
,	O
NULL_PARG	O
)	O
;	O
break	O
;	O
}	O
}	O
static	O
int	O
is_erase_char	function
(	O
c	int
)	O
int	O
c	int
;	O
{	O
return	O
(	O
c	int
==	O
erase_char	int
||	O
c	int
==	O
erase2_char	int
||	O
c	int
==	O
kill_char	int
)	O
;	O
}	O
static	O
int	O
is_newline_char	function
(	O
c	int
)	O
int	O
c	int
;	O
{	O
return	O
(	O
c	int
==	O
'\n'	O
||	O
c	int
==	O
'\r'	O
)	O
;	O
}	O
static	O
int	O
mca_opt_first_char	function
(	O
c	int
)	O
int	O
c	int
;	O
{	O
int	O
flag	int
=	O
(	O
optflag	int
&	O
~	O
OPT_NO_PROMPT	int
)	O
;	O
if	O
(	O
flag	int
==	O
OPT_NO_TOGGLE	int
)	O
{	O
switch	O
(	O
c	int
)	O
{	O
case	O
'_'	O
:	O
optgetname	int
=	O
TRUE	int
;	O
mca_opt_toggle	function
(	O
)	O
;	O
return	O
(	O
MCA_MORE	int
)	O
;	O
}	O
}	O
else	O
{	O
switch	O
(	O
c	int
)	O
{	O
case	O
'+'	O
:	O
optflag	int
=	O
(	O
flag	int
==	O
OPT_UNSET	int
)	O
?	O
OPT_TOGGLE	int
:	O
OPT_UNSET	int
;	O
mca_opt_toggle	function
(	O
)	O
;	O
return	O
(	O
MCA_MORE	int
)	O
;	O
case	O
'!'	O
:	O
optflag	int
=	O
(	O
flag	int
==	O
OPT_SET	int
)	O
?	O
OPT_TOGGLE	int
:	O
OPT_SET	int
;	O
mca_opt_toggle	function
(	O
)	O
;	O
return	O
(	O
MCA_MORE	int
)	O
;	O
case	O
CONTROL	O
(	O
'P'	O
)	O
:	O
optflag	int
^=	O
OPT_NO_PROMPT	int
;	O
mca_opt_toggle	function
(	O
)	O
;	O
return	O
(	O
MCA_MORE	int
)	O
;	O
case	O
'-'	O
:	O
optgetname	int
=	O
TRUE	int
;	O
mca_opt_toggle	function
(	O
)	O
;	O
return	O
(	O
MCA_MORE	int
)	O
;	O
}	O
}	O
return	O
(	O
NO_MCA	int
)	O
;	O
}	O
static	O
int	O
mca_opt_nonfirst_char	function
(	O
c	int
)	O
int	O
c	int
;	O
{	O
char	O
*	O
p	pointer
;	O
char	O
*	O
oname	pointer
;	O
if	O
(	O
curropt	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
is_erase_char	function
(	O
c	int
)	O
)	O
return	O
(	O
MCA_DONE	int
)	O
;	O
return	O
(	O
MCA_MORE	int
)	O
;	O
}	O
if	O
(	O
cmd_char	function
(	O
c	int
)	O
==	O
CC_QUIT	int
)	O
return	O
(	O
MCA_DONE	int
)	O
;	O
p	pointer
=	O
get_cmdbuf	function
(	O
)	O
;	O
opt_lower	int
=	O
ASCII_IS_LOWER	O
(	O
p	pointer
[	O
0	int
]	O
)	O
;	O
curropt	pointer
=	O
findopt_name	function
(	O
&	O
p	pointer
,	O
&	O
oname	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
curropt	pointer
!=	O
NULL	O
)	O
{	O
cmd_reset	function
(	O
)	O
;	O
mca_opt_toggle	function
(	O
)	O
;	O
for	O
(	O
p	pointer
=	O
oname	pointer
;	O
*	O
p	pointer
!=	O
'\0'	O
;	O
p	pointer
++	O
)	O
{	O
c	int
=	O
*	O
p	pointer
;	O
if	O
(	O
!	O
opt_lower	int
&&	O
ASCII_IS_LOWER	O
(	O
c	int
)	O
)	O
c	int
=	O
ASCII_TO_UPPER	O
(	O
c	int
)	O
;	O
if	O
(	O
cmd_char	function
(	O
c	int
)	O
!=	O
CC_OK	int
)	O
return	O
(	O
MCA_DONE	int
)	O
;	O
}	O
}	O
return	O
(	O
MCA_MORE	int
)	O
;	O
}	O
static	O
int	O
mca_opt_char	function
(	O
c	int
)	O
int	O
c	int
;	O
{	O
PARG	union
parg	union
;	O
if	O
(	O
curropt	pointer
==	O
NULL	O
&&	O
len_cmdbuf	function
(	O
)	O
==	O
0	int
)	O
{	O
int	O
ret	int
=	O
mca_opt_first_char	function
(	O
c	int
)	O
;	O
if	O
(	O
ret	int
!=	O
NO_MCA	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
optgetname	int
)	O
{	O
if	O
(	O
!	O
is_newline_char	function
(	O
c	int
)	O
)	O
return	O
(	O
mca_opt_nonfirst_char	function
(	O
c	int
)	O
)	O
;	O
if	O
(	O
curropt	pointer
==	O
NULL	O
)	O
{	O
parg	union
.	O
p_string	pointer
=	O
get_cmdbuf	function
(	O
)	O
;	O
error	function
(	O
"There is no --%s option"	pointer
,	O
&	O
parg	union
)	O
;	O
return	O
(	O
MCA_DONE	int
)	O
;	O
}	O
optgetname	int
=	O
FALSE	int
;	O
cmd_reset	function
(	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
is_erase_char	function
(	O
c	int
)	O
)	O
return	O
(	O
NO_MCA	int
)	O
;	O
if	O
(	O
curropt	pointer
!=	O
NULL	O
)	O
return	O
(	O
NO_MCA	int
)	O
;	O
curropt	pointer
=	O
findopt	function
(	O
c	int
)	O
;	O
if	O
(	O
curropt	pointer
==	O
NULL	O
)	O
{	O
parg	union
.	O
p_string	pointer
=	O
propt	function
(	O
c	int
)	O
;	O
error	function
(	O
"There is no %s option"	pointer
,	O
&	O
parg	union
)	O
;	O
return	O
(	O
MCA_DONE	int
)	O
;	O
}	O
}	O
if	O
(	O
(	O
optflag	int
&	O
~	O
OPT_NO_PROMPT	int
)	O
!=	O
OPT_TOGGLE	int
||	O
!	O
opt_has_param	function
(	O
curropt	pointer
)	O
)	O
{	O
toggle_option	function
(	O
curropt	pointer
,	O
ASCII_IS_LOWER	O
(	O
c	int
)	O
,	O
""	pointer
,	O
optflag	int
)	O
;	O
return	O
(	O
MCA_DONE	int
)	O
;	O
}	O
start_mca	function
(	O
A_OPT_TOGGLE	int
,	O
opt_prompt	function
(	O
curropt	pointer
)	O
,	O
(	O
void	O
*	O
)	O
NULL	O
,	O
0	int
)	O
;	O
return	O
(	O
MCA_MORE	int
)	O
;	O
}	O
static	O
int	O
mca_search_char	function
(	O
c	int
)	O
int	O
c	int
;	O
{	O
int	O
flag	int
=	O
0	int
;	O
if	O
(	O
len_cmdbuf	function
(	O
)	O
>	O
0	int
)	O
return	O
(	O
NO_MCA	int
)	O
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
CONTROL	O
(	O
'E'	O
)	O
:	O
case	O
'*'	O
:	O
if	O
(	O
mca	int
!=	O
A_FILTER	int
)	O
flag	int
=	O
SRCH_PAST_EOF	O
;	O
break	O
;	O
case	O
CONTROL	O
(	O
'F'	O
)	O
:	O
case	O
'@'	O
:	O
if	O
(	O
mca	int
!=	O
A_FILTER	int
)	O
flag	int
=	O
SRCH_FIRST_FILE	O
;	O
break	O
;	O
case	O
CONTROL	O
(	O
'K'	O
)	O
:	O
if	O
(	O
mca	int
!=	O
A_FILTER	int
)	O
flag	int
=	O
SRCH_NO_MOVE	O
;	O
break	O
;	O
case	O
CONTROL	O
(	O
'R'	O
)	O
:	O
flag	int
=	O
SRCH_NO_REGEX	O
;	O
break	O
;	O
case	O
CONTROL	O
(	O
'N'	O
)	O
:	O
case	O
'!'	O
:	O
flag	int
=	O
SRCH_NO_MATCH	O
;	O
break	O
;	O
}	O
if	O
(	O
flag	int
!=	O
0	int
)	O
{	O
search_type	int
^=	O
flag	int
;	O
mca_search	function
(	O
)	O
;	O
return	O
(	O
MCA_MORE	int
)	O
;	O
}	O
return	O
(	O
NO_MCA	int
)	O
;	O
}	O
static	O
int	O
mca_char	function
(	O
c	int
)	O
int	O
c	int
;	O
{	O
int	O
ret	int
;	O
switch	O
(	O
mca	int
)	O
{	O
case	O
0	int
:	O
return	O
(	O
NO_MCA	int
)	O
;	O
case	O
A_PREFIX	int
:	O
return	O
(	O
NO_MCA	int
)	O
;	O
case	O
A_DIGIT	int
:	O
if	O
(	O
!	O
(	O
(	O
c	int
>=	O
'0'	O
&&	O
c	int
<=	O
'9'	O
)	O
||	O
c	int
==	O
'.'	O
)	O
&&	O
editchar	function
(	O
c	int
,	O
EC_PEEK	int
|	O
EC_NOHISTORY	int
|	O
EC_NOCOMPLETE	int
|	O
EC_NORIGHTLEFT	int
)	O
==	O
A_INVALID	int
)	O
{	O
number	long
=	O
cmd_int	function
(	O
&	O
fraction	long
)	O
;	O
mca	int
=	O
0	int
;	O
cmd_accept	function
(	O
)	O
;	O
return	O
(	O
NO_MCA	int
)	O
;	O
}	O
break	O
;	O
case	O
A_OPT_TOGGLE	int
:	O
ret	int
=	O
mca_opt_char	function
(	O
c	int
)	O
;	O
if	O
(	O
ret	int
!=	O
NO_MCA	int
)	O
return	O
(	O
ret	int
)	O
;	O
break	O
;	O
case	O
A_F_SEARCH	int
:	O
case	O
A_B_SEARCH	int
:	O
case	O
A_FILTER	int
:	O
ret	int
=	O
mca_search_char	function
(	O
c	int
)	O
;	O
if	O
(	O
ret	int
!=	O
NO_MCA	int
)	O
return	O
(	O
ret	int
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
is_newline_char	function
(	O
c	int
)	O
)	O
{	O
exec_mca	function
(	O
)	O
;	O
return	O
(	O
MCA_DONE	int
)	O
;	O
}	O
if	O
(	O
cmd_char	function
(	O
c	int
)	O
==	O
CC_QUIT	int
)	O
return	O
(	O
MCA_DONE	int
)	O
;	O
if	O
(	O
(	O
mca	int
==	O
A_F_BRACKET	int
||	O
mca	int
==	O
A_B_BRACKET	int
)	O
&&	O
len_cmdbuf	function
(	O
)	O
>=	O
2	int
)	O
{	O
exec_mca	function
(	O
)	O
;	O
return	O
(	O
MCA_DONE	int
)	O
;	O
}	O
return	O
(	O
MCA_MORE	int
)	O
;	O
}	O
static	O
void	O
clear_buffers	function
(	O
)	O
{	O
if	O
(	O
!	O
(	O
ch_getflags	function
(	O
)	O
&	O
CH_CANSEEK	int
)	O
)	O
return	O
;	O
ch_flush	function
(	O
)	O
;	O
clr_linenum	function
(	O
)	O
;	O
clr_hilite	function
(	O
)	O
;	O
}	O
static	O
void	O
make_display	function
(	O
)	O
{	O
if	O
(	O
empty_screen	function
(	O
)	O
)	O
{	O
if	O
(	O
initial_scrpos	struct
.	O
pos	long
==	O
NULL_POSITION	O
)	O
jump_loc	function
(	O
ch_zero	O
(	O
)	O
,	O
1	int
)	O
;	O
else	O
jump_loc	function
(	O
initial_scrpos	struct
.	O
pos	long
,	O
initial_scrpos	struct
.	O
ln	int
)	O
;	O
}	O
else	O
if	O
(	O
screen_trashed	int
)	O
{	O
int	O
save_top_scroll	int
=	O
top_scroll	int
;	O
int	O
save_ignore_eoi	int
=	O
ignore_eoi	int
;	O
top_scroll	int
=	O
1	int
;	O
ignore_eoi	int
=	O
0	int
;	O
if	O
(	O
screen_trashed	int
==	O
2	int
)	O
{	O
reopen_curr_ifile	function
(	O
)	O
;	O
jump_forw	function
(	O
)	O
;	O
}	O
repaint	function
(	O
)	O
;	O
top_scroll	int
=	O
save_top_scroll	int
;	O
ignore_eoi	int
=	O
save_ignore_eoi	int
;	O
}	O
}	O
static	O
void	O
prompt	pointer
(	O
)	O
{	O
constant	O
char	O
*	O
p	pointer
;	O
if	O
(	O
ungot	struct
!=	O
NULL	O
&&	O
ungot	struct
->	O
ug_char	long
!=	O
CHAR_END_COMMAND	int
)	O
{	O
return	O
;	O
}	O
make_display	function
(	O
)	O
;	O
bottompos	long
=	O
position	function
(	O
BOTTOM_PLUS_ONE	O
)	O
;	O
if	O
(	O
get_quit_at_eof	function
(	O
)	O
==	O
OPT_ONPLUS	int
&&	O
eof_displayed	function
(	O
)	O
&&	O
!	O
(	O
ch_getflags	function
(	O
)	O
&	O
CH_HELPFILE	int
)	O
&&	O
next_ifile	function
(	O
curr_ifile	pointer
)	O
==	O
NULL_IFILE	O
)	O
quit	function
(	O
QUIT_OK	int
)	O
;	O
if	O
(	O
quit_if_one_screen	int
&&	O
entire_file_displayed	function
(	O
)	O
&&	O
!	O
(	O
ch_getflags	function
(	O
)	O
&	O
CH_HELPFILE	int
)	O
&&	O
next_ifile	function
(	O
curr_ifile	pointer
)	O
==	O
NULL_IFILE	O
)	O
quit	function
(	O
QUIT_OK	int
)	O
;	O
if	O
(	O
!	O
forw_prompt	int
)	O
clear_bot	function
(	O
)	O
;	O
clear_cmd	function
(	O
)	O
;	O
forw_prompt	int
=	O
0	int
;	O
p	pointer
=	O
pr_string	function
(	O
)	O
;	O
if	O
(	O
is_filtering	function
(	O
)	O
)	O
putstr	function
(	O
"& "	pointer
)	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
||	O
*	O
p	pointer
==	O
'\0'	O
)	O
putchr	function
(	O
':'	O
)	O
;	O
else	O
{	O
at_enter	function
(	O
AT_STANDOUT	O
)	O
;	O
putstr	function
(	O
p	pointer
)	O
;	O
at_exit	function
(	O
)	O
;	O
}	O
clear_eol	function
(	O
)	O
;	O
}	O
public	O
void	O
dispversion	function
(	O
)	O
{	O
PARG	union
parg	union
;	O
parg	union
.	O
p_string	pointer
=	O
version	array
;	O
error	function
(	O
"less %s"	pointer
,	O
&	O
parg	union
)	O
;	O
}	O
static	O
LWCHAR	long
getcc_end_command	function
(	O
)	O
{	O
switch	O
(	O
mca	int
)	O
{	O
case	O
A_DIGIT	int
:	O
return	O
(	O
'g'	O
)	O
;	O
case	O
A_F_SEARCH	int
:	O
case	O
A_B_SEARCH	int
:	O
return	O
(	O
'\n'	O
)	O
;	O
default	O
:	O
return	O
(	O
getchr	function
(	O
)	O
)	O
;	O
}	O
}	O
static	O
LWCHAR	long
getccu	function
(	O
VOID_PARAM	void
)	O
{	O
LWCHAR	long
c	int
;	O
if	O
(	O
ungot	struct
==	O
NULL	O
)	O
{	O
c	int
=	O
getchr	function
(	O
)	O
;	O
}	O
else	O
{	O
struct	O
ungot	struct
*	O
ug	pointer
=	O
ungot	struct
;	O
c	int
=	O
ug	pointer
->	O
ug_char	long
;	O
ungot	struct
=	O
ug	pointer
->	O
ug_next	pointer
;	O
free	function
(	O
ug	pointer
)	O
;	O
if	O
(	O
c	int
==	O
CHAR_END_COMMAND	int
)	O
c	int
=	O
getcc_end_command	function
(	O
)	O
;	O
}	O
return	O
(	O
c	int
)	O
;	O
}	O
static	O
LWCHAR	long
getcc_repl	function
(	O
orig	pointer
,	O
repl	pointer
,	O
gr_getc	pointer
,	O
gr_ungetc	pointer
)	O
char	O
const	O
*	O
orig	pointer
;	O
char	O
const	O
*	O
repl	pointer
;	O
LWCHAR	long
(	O
*	O
gr_getc	pointer
)	O
(	O
VOID_PARAM	void
)	O
;	O
void	O
(	O
*	O
gr_ungetc	pointer
)	O
(	O
LWCHAR	long
)	O
;	O
{	O
LWCHAR	long
c	int
;	O
LWCHAR	long
keys	array
[	O
16	int
]	O
;	O
int	O
ki	int
=	O
0	int
;	O
c	int
=	O
(	O
*	O
gr_getc	pointer
)	O
(	O
)	O
;	O
if	O
(	O
orig	pointer
==	O
NULL	O
||	O
orig	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
return	O
c	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
keys	array
[	O
ki	int
]	O
=	O
c	int
;	O
if	O
(	O
c	int
!=	O
orig	pointer
[	O
ki	int
]	O
||	O
ki	int
>=	O
sizeof	O
(	O
keys	array
)	O
-	O
1	int
)	O
{	O
while	O
(	O
ki	int
>	O
0	int
)	O
(	O
*	O
gr_ungetc	pointer
)	O
(	O
keys	array
[	O
ki	int
--	O
]	O
)	O
;	O
return	O
keys	array
[	O
0	int
]	O
;	O
}	O
if	O
(	O
orig	pointer
[	O
++	O
ki	int
]	O
==	O
'\0'	O
)	O
{	O
ki	int
=	O
strlen	function
(	O
repl	pointer
)	O
-	O
1	int
;	O
while	O
(	O
ki	int
>	O
0	int
)	O
(	O
*	O
gr_ungetc	pointer
)	O
(	O
repl	pointer
[	O
ki	int
--	O
]	O
)	O
;	O
return	O
repl	pointer
[	O
0	int
]	O
;	O
}	O
c	int
=	O
(	O
*	O
gr_getc	pointer
)	O
(	O
)	O
;	O
}	O
}	O
public	O
int	O
getcc	function
(	O
)	O
{	O
return	O
getcc_repl	function
(	O
kent	pointer
,	O
"\n"	pointer
,	O
getccu	function
,	O
ungetcc	function
)	O
;	O
}	O
public	O
void	O
ungetcc	function
(	O
c	int
)	O
LWCHAR	long
c	int
;	O
{	O
struct	O
ungot	struct
*	O
ug	pointer
=	O
(	O
struct	O
ungot	struct
*	O
)	O
ecalloc	function
(	O
1	int
,	O
sizeof	O
(	O
struct	O
ungot	struct
)	O
)	O
;	O
ug	pointer
->	O
ug_char	long
=	O
c	int
;	O
ug	pointer
->	O
ug_next	pointer
=	O
ungot	struct
;	O
ungot	struct
=	O
ug	pointer
;	O
}	O
public	O
void	O
ungetsc	function
(	O
s	pointer
)	O
char	O
*	O
s	pointer
;	O
{	O
char	O
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
s	pointer
+	O
strlen	function
(	O
s	pointer
)	O
-	O
1	int
;	O
p	pointer
>=	O
s	pointer
;	O
p	pointer
--	O
)	O
ungetcc	function
(	O
*	O
p	pointer
)	O
;	O
}	O
public	O
LWCHAR	long
peekcc	function
(	O
)	O
{	O
LWCHAR	long
c	int
=	O
getcc	function
(	O
)	O
;	O
ungetcc	function
(	O
c	int
)	O
;	O
return	O
c	int
;	O
}	O
static	O
void	O
multi_search	function
(	O
pattern	pointer
,	O
n	int
,	O
silent	int
)	O
char	O
*	O
pattern	pointer
;	O
int	O
n	int
;	O
int	O
silent	int
;	O
{	O
int	O
nomore	int
;	O
IFILE	O
save_ifile	pointer
;	O
int	O
changed_file	int
;	O
changed_file	int
=	O
0	int
;	O
save_ifile	pointer
=	O
save_curr_ifile	function
(	O
)	O
;	O
if	O
(	O
search_type	int
&	O
SRCH_FIRST_FILE	O
)	O
{	O
if	O
(	O
search_type	int
&	O
SRCH_FORW	O
)	O
nomore	int
=	O
edit_first	function
(	O
)	O
;	O
else	O
nomore	int
=	O
edit_last	function
(	O
)	O
;	O
if	O
(	O
nomore	int
)	O
{	O
unsave_ifile	function
(	O
save_ifile	pointer
)	O
;	O
return	O
;	O
}	O
changed_file	int
=	O
1	int
;	O
search_type	int
&=	O
~	O
SRCH_FIRST_FILE	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
n	int
=	O
search	function
(	O
search_type	int
,	O
pattern	pointer
,	O
n	int
)	O
;	O
search_type	int
&=	O
~	O
SRCH_NO_MOVE	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
{	O
unsave_ifile	function
(	O
save_ifile	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
n	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
(	O
search_type	int
&	O
SRCH_PAST_EOF	O
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
search_type	int
&	O
SRCH_FORW	O
)	O
nomore	int
=	O
edit_next	function
(	O
1	int
)	O
;	O
else	O
nomore	int
=	O
edit_prev	function
(	O
1	int
)	O
;	O
if	O
(	O
nomore	int
)	O
break	O
;	O
changed_file	int
=	O
1	int
;	O
}	O
if	O
(	O
n	int
>	O
0	int
&&	O
!	O
silent	int
)	O
error	function
(	O
"Pattern not found"	pointer
,	O
NULL_PARG	O
)	O
;	O
if	O
(	O
changed_file	int
)	O
{	O
reedit_ifile	function
(	O
save_ifile	pointer
)	O
;	O
}	O
else	O
{	O
unsave_ifile	function
(	O
save_ifile	pointer
)	O
;	O
}	O
}	O
static	O
int	O
forw_loop	function
(	O
until_hilite	int
)	O
int	O
until_hilite	int
;	O
{	O
POSITION	long
curr_len	long
;	O
if	O
(	O
ch_getflags	function
(	O
)	O
&	O
CH_HELPFILE	int
)	O
return	O
(	O
A_NOACTION	int
)	O
;	O
cmd_exec	function
(	O
)	O
;	O
jump_forw_buffered	function
(	O
)	O
;	O
curr_len	long
=	O
ch_length	function
(	O
)	O
;	O
highest_hilite	long
=	O
until_hilite	int
?	O
curr_len	long
:	O
NULL_POSITION	O
;	O
ignore_eoi	int
=	O
1	int
;	O
while	O
(	O
!	O
sigs	int
)	O
{	O
if	O
(	O
until_hilite	int
&&	O
highest_hilite	long
>	O
curr_len	long
)	O
{	O
bell	function
(	O
)	O
;	O
break	O
;	O
}	O
make_display	function
(	O
)	O
;	O
forward	function
(	O
1	int
,	O
0	int
,	O
0	int
)	O
;	O
}	O
ignore_eoi	int
=	O
0	int
;	O
ch_set_eof	function
(	O
)	O
;	O
if	O
(	O
sigs	int
&&	O
!	O
ABORT_SIGS	O
(	O
)	O
)	O
return	O
(	O
until_hilite	int
?	O
A_F_UNTIL_HILITE	int
:	O
A_F_FOREVER	int
)	O
;	O
return	O
(	O
A_NOACTION	int
)	O
;	O
}	O
public	O
void	O
commands	function
(	O
)	O
{	O
int	O
c	int
;	O
int	O
action	int
;	O
char	O
*	O
cbuf	pointer
;	O
int	O
newaction	int
;	O
int	O
save_search_type	int
;	O
char	O
*	O
extra	pointer
;	O
char	O
tbuf	array
[	O
2	int
]	O
;	O
PARG	union
parg	union
;	O
IFILE	O
old_ifile	pointer
;	O
IFILE	O
new_ifile	pointer
;	O
char	O
*	O
tagfile	pointer
;	O
search_type	int
=	O
SRCH_FORW	O
;	O
wscroll	int
=	O
(	O
sc_height	int
+	O
1	int
)	O
/	O
2	int
;	O
newaction	int
=	O
A_NOACTION	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
mca	int
=	O
0	int
;	O
cmd_accept	function
(	O
)	O
;	O
number	long
=	O
0	int
;	O
curropt	pointer
=	O
NULL	O
;	O
if	O
(	O
sigs	int
)	O
{	O
psignals	function
(	O
)	O
;	O
if	O
(	O
quitting	int
)	O
quit	function
(	O
QUIT_SAVED_STATUS	O
)	O
;	O
}	O
check_winch	function
(	O
)	O
;	O
cmd_reset	function
(	O
)	O
;	O
prompt	pointer
(	O
)	O
;	O
if	O
(	O
sigs	int
)	O
continue	O
;	O
if	O
(	O
newaction	int
==	O
A_NOACTION	int
)	O
c	int
=	O
getcc	function
(	O
)	O
;	O
again	O
:	O
if	O
(	O
sigs	int
)	O
continue	O
;	O
if	O
(	O
newaction	int
!=	O
A_NOACTION	int
)	O
{	O
action	int
=	O
newaction	int
;	O
newaction	int
=	O
A_NOACTION	int
;	O
}	O
else	O
{	O
if	O
(	O
mca	int
)	O
switch	O
(	O
mca_char	function
(	O
c	int
)	O
)	O
{	O
case	O
MCA_MORE	int
:	O
c	int
=	O
getcc	function
(	O
)	O
;	O
goto	O
again	O
;	O
case	O
MCA_DONE	int
:	O
continue	O
;	O
case	O
NO_MCA	int
:	O
break	O
;	O
}	O
if	O
(	O
mca	int
)	O
{	O
if	O
(	O
cmd_char	function
(	O
c	int
)	O
==	O
CC_QUIT	int
||	O
len_cmdbuf	function
(	O
)	O
==	O
0	int
)	O
continue	O
;	O
cbuf	pointer
=	O
get_cmdbuf	function
(	O
)	O
;	O
}	O
else	O
{	O
tbuf	array
[	O
0	int
]	O
=	O
c	int
;	O
tbuf	array
[	O
1	int
]	O
=	O
'\0'	O
;	O
cbuf	pointer
=	O
tbuf	array
;	O
}	O
extra	pointer
=	O
NULL	O
;	O
action	int
=	O
fcmd_decode	function
(	O
cbuf	pointer
,	O
&	O
extra	pointer
)	O
;	O
if	O
(	O
extra	pointer
!=	O
NULL	O
)	O
ungetsc	function
(	O
extra	pointer
)	O
;	O
}	O
if	O
(	O
action	int
!=	O
A_PREFIX	int
)	O
cmd_reset	function
(	O
)	O
;	O
switch	O
(	O
action	int
)	O
{	O
case	O
A_DIGIT	int
:	O
start_mca	function
(	O
A_DIGIT	int
,	O
":"	pointer
,	O
(	O
void	O
*	O
)	O
NULL	O
,	O
CF_QUIT_ON_ERASE	int
)	O
;	O
goto	O
again	O
;	O
case	O
A_F_WINDOW	int
:	O
if	O
(	O
number	long
>	O
0	int
)	O
swindow	int
=	O
(	O
int	O
)	O
number	long
;	O
case	O
A_F_SCREEN	int
:	O
if	O
(	O
number	long
<=	O
0	int
)	O
number	long
=	O
get_swindow	function
(	O
)	O
;	O
cmd_exec	function
(	O
)	O
;	O
if	O
(	O
show_attn	int
)	O
set_attnpos	function
(	O
bottompos	long
)	O
;	O
forward	function
(	O
(	O
int	O
)	O
number	long
,	O
0	int
,	O
1	int
)	O
;	O
break	O
;	O
case	O
A_B_WINDOW	int
:	O
if	O
(	O
number	long
>	O
0	int
)	O
swindow	int
=	O
(	O
int	O
)	O
number	long
;	O
case	O
A_B_SCREEN	int
:	O
if	O
(	O
number	long
<=	O
0	int
)	O
number	long
=	O
get_swindow	function
(	O
)	O
;	O
cmd_exec	function
(	O
)	O
;	O
backward	function
(	O
(	O
int	O
)	O
number	long
,	O
0	int
,	O
1	int
)	O
;	O
break	O
;	O
case	O
A_F_LINE	int
:	O
if	O
(	O
number	long
<=	O
0	int
)	O
number	long
=	O
1	int
;	O
cmd_exec	function
(	O
)	O
;	O
if	O
(	O
show_attn	int
==	O
OPT_ONPLUS	int
&&	O
number	long
>	O
1	int
)	O
set_attnpos	function
(	O
bottompos	long
)	O
;	O
forward	function
(	O
(	O
int	O
)	O
number	long
,	O
0	int
,	O
0	int
)	O
;	O
break	O
;	O
case	O
A_B_LINE	int
:	O
if	O
(	O
number	long
<=	O
0	int
)	O
number	long
=	O
1	int
;	O
cmd_exec	function
(	O
)	O
;	O
backward	function
(	O
(	O
int	O
)	O
number	long
,	O
0	int
,	O
0	int
)	O
;	O
break	O
;	O
case	O
A_FF_LINE	int
:	O
if	O
(	O
number	long
<=	O
0	int
)	O
number	long
=	O
1	int
;	O
cmd_exec	function
(	O
)	O
;	O
if	O
(	O
show_attn	int
==	O
OPT_ONPLUS	int
&&	O
number	long
>	O
1	int
)	O
set_attnpos	function
(	O
bottompos	long
)	O
;	O
forward	function
(	O
(	O
int	O
)	O
number	long
,	O
1	int
,	O
0	int
)	O
;	O
break	O
;	O
case	O
A_BF_LINE	int
:	O
if	O
(	O
number	long
<=	O
0	int
)	O
number	long
=	O
1	int
;	O
cmd_exec	function
(	O
)	O
;	O
backward	function
(	O
(	O
int	O
)	O
number	long
,	O
1	int
,	O
0	int
)	O
;	O
break	O
;	O
case	O
A_FF_SCREEN	int
:	O
if	O
(	O
number	long
<=	O
0	int
)	O
number	long
=	O
get_swindow	function
(	O
)	O
;	O
cmd_exec	function
(	O
)	O
;	O
if	O
(	O
show_attn	int
==	O
OPT_ONPLUS	int
)	O
set_attnpos	function
(	O
bottompos	long
)	O
;	O
forward	function
(	O
(	O
int	O
)	O
number	long
,	O
1	int
,	O
0	int
)	O
;	O
break	O
;	O
case	O
A_F_FOREVER	int
:	O
if	O
(	O
show_attn	int
)	O
set_attnpos	function
(	O
bottompos	long
)	O
;	O
newaction	int
=	O
forw_loop	function
(	O
0	int
)	O
;	O
break	O
;	O
case	O
A_F_UNTIL_HILITE	int
:	O
newaction	int
=	O
forw_loop	function
(	O
1	int
)	O
;	O
break	O
;	O
case	O
A_F_SCROLL	int
:	O
if	O
(	O
number	long
>	O
0	int
)	O
wscroll	int
=	O
(	O
int	O
)	O
number	long
;	O
cmd_exec	function
(	O
)	O
;	O
if	O
(	O
show_attn	int
==	O
OPT_ONPLUS	int
)	O
set_attnpos	function
(	O
bottompos	long
)	O
;	O
forward	function
(	O
wscroll	int
,	O
0	int
,	O
0	int
)	O
;	O
break	O
;	O
case	O
A_B_SCROLL	int
:	O
if	O
(	O
number	long
>	O
0	int
)	O
wscroll	int
=	O
(	O
int	O
)	O
number	long
;	O
cmd_exec	function
(	O
)	O
;	O
backward	function
(	O
wscroll	int
,	O
0	int
,	O
0	int
)	O
;	O
break	O
;	O
case	O
A_FREPAINT	int
:	O
clear_buffers	function
(	O
)	O
;	O
case	O
A_REPAINT	int
:	O
cmd_exec	function
(	O
)	O
;	O
repaint	function
(	O
)	O
;	O
break	O
;	O
case	O
A_GOLINE	int
:	O
if	O
(	O
number	long
<=	O
0	int
)	O
number	long
=	O
1	int
;	O
cmd_exec	function
(	O
)	O
;	O
jump_back	function
(	O
number	long
)	O
;	O
break	O
;	O
case	O
A_PERCENT	int
:	O
if	O
(	O
number	long
<	O
0	int
)	O
{	O
number	long
=	O
0	int
;	O
fraction	long
=	O
0	int
;	O
}	O
if	O
(	O
number	long
>	O
100	int
)	O
{	O
number	long
=	O
100	int
;	O
fraction	long
=	O
0	int
;	O
}	O
cmd_exec	function
(	O
)	O
;	O
jump_percent	function
(	O
(	O
int	O
)	O
number	long
,	O
fraction	long
)	O
;	O
break	O
;	O
case	O
A_GOEND	int
:	O
cmd_exec	function
(	O
)	O
;	O
if	O
(	O
number	long
<=	O
0	int
)	O
jump_forw	function
(	O
)	O
;	O
else	O
jump_back	function
(	O
number	long
)	O
;	O
break	O
;	O
case	O
A_GOEND_BUF	int
:	O
cmd_exec	function
(	O
)	O
;	O
if	O
(	O
number	long
<=	O
0	int
)	O
jump_forw_buffered	function
(	O
)	O
;	O
else	O
jump_back	function
(	O
number	long
)	O
;	O
break	O
;	O
case	O
A_GOPOS	int
:	O
cmd_exec	function
(	O
)	O
;	O
if	O
(	O
number	long
<	O
0	int
)	O
number	long
=	O
0	int
;	O
jump_line_loc	function
(	O
(	O
POSITION	long
)	O
number	long
,	O
jump_sline	int
)	O
;	O
break	O
;	O
case	O
A_STAT	int
:	O
if	O
(	O
ch_getflags	function
(	O
)	O
&	O
CH_HELPFILE	int
)	O
break	O
;	O
cmd_exec	function
(	O
)	O
;	O
parg	union
.	O
p_string	pointer
=	O
eq_message	function
(	O
)	O
;	O
error	function
(	O
"%s"	pointer
,	O
&	O
parg	union
)	O
;	O
break	O
;	O
case	O
A_VERSION	int
:	O
cmd_exec	function
(	O
)	O
;	O
dispversion	function
(	O
)	O
;	O
break	O
;	O
case	O
A_QUIT	int
:	O
if	O
(	O
curr_ifile	pointer
!=	O
NULL_IFILE	O
&&	O
ch_getflags	function
(	O
)	O
&	O
CH_HELPFILE	int
)	O
{	O
hshift	int
=	O
save_hshift	int
;	O
bs_mode	int
=	O
save_bs_mode	int
;	O
if	O
(	O
edit_prev	function
(	O
1	int
)	O
==	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
extra	pointer
!=	O
NULL	O
)	O
quit	function
(	O
*	O
extra	pointer
)	O
;	O
quit	function
(	O
QUIT_OK	int
)	O
;	O
break	O
;	O
case	O
A_F_SEARCH	int
:	O
search_type	int
=	O
SRCH_FORW	O
;	O
if	O
(	O
number	long
<=	O
0	int
)	O
number	long
=	O
1	int
;	O
mca_search	function
(	O
)	O
;	O
c	int
=	O
getcc	function
(	O
)	O
;	O
goto	O
again	O
;	O
case	O
A_B_SEARCH	int
:	O
search_type	int
=	O
SRCH_BACK	O
;	O
if	O
(	O
number	long
<=	O
0	int
)	O
number	long
=	O
1	int
;	O
mca_search	function
(	O
)	O
;	O
c	int
=	O
getcc	function
(	O
)	O
;	O
goto	O
again	O
;	O
case	O
A_FILTER	int
:	O
search_type	int
=	O
SRCH_FORW	O
|	O
SRCH_FILTER	O
;	O
mca_search	function
(	O
)	O
;	O
c	int
=	O
getcc	function
(	O
)	O
;	O
goto	O
again	O
;	O
case	O
A_AGAIN_SEARCH	int
:	O
DO_SEARCH	O
(	O
)	O
;	O
break	O
;	O
case	O
A_T_AGAIN_SEARCH	int
:	O
search_type	int
|=	O
SRCH_PAST_EOF	O
;	O
DO_SEARCH	O
(	O
)	O
;	O
break	O
;	O
case	O
A_REVERSE_SEARCH	int
:	O
save_search_type	int
=	O
search_type	int
;	O
search_type	int
=	O
SRCH_REVERSE	O
(	O
search_type	int
)	O
;	O
DO_SEARCH	O
(	O
)	O
;	O
search_type	int
=	O
save_search_type	int
;	O
break	O
;	O
case	O
A_T_REVERSE_SEARCH	int
:	O
save_search_type	int
=	O
search_type	int
;	O
search_type	int
=	O
SRCH_REVERSE	O
(	O
search_type	int
)	O
;	O
search_type	int
|=	O
SRCH_PAST_EOF	O
;	O
DO_SEARCH	O
(	O
)	O
;	O
search_type	int
=	O
save_search_type	int
;	O
break	O
;	O
case	O
A_UNDO_SEARCH	int
:	O
undo_search	function
(	O
)	O
;	O
break	O
;	O
case	O
A_HELP	int
:	O
if	O
(	O
ch_getflags	function
(	O
)	O
&	O
CH_HELPFILE	int
)	O
break	O
;	O
cmd_exec	function
(	O
)	O
;	O
save_hshift	int
=	O
hshift	int
;	O
hshift	int
=	O
0	int
;	O
save_bs_mode	int
=	O
bs_mode	int
;	O
bs_mode	int
=	O
BS_SPECIAL	int
;	O
(	O
void	O
)	O
edit	function
(	O
FAKE_HELPFILE	pointer
)	O
;	O
break	O
;	O
case	O
A_EXAMINE	int
:	O
if	O
(	O
!	O
secure	int
)	O
{	O
start_mca	function
(	O
A_EXAMINE	int
,	O
"Examine: "	pointer
,	O
ml_examine	pointer
,	O
0	int
)	O
;	O
c	int
=	O
getcc	function
(	O
)	O
;	O
goto	O
again	O
;	O
}	O
error	function
(	O
"Command not available"	pointer
,	O
NULL_PARG	O
)	O
;	O
break	O
;	O
case	O
A_VISUAL	int
:	O
if	O
(	O
!	O
secure	int
)	O
{	O
if	O
(	O
ch_getflags	function
(	O
)	O
&	O
CH_HELPFILE	int
)	O
break	O
;	O
if	O
(	O
strcmp	function
(	O
get_filename	function
(	O
curr_ifile	pointer
)	O
,	O
"-"	pointer
)	O
==	O
0	int
)	O
{	O
error	function
(	O
"Cannot edit standard input"	pointer
,	O
NULL_PARG	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
get_altfilename	function
(	O
curr_ifile	pointer
)	O
!=	O
NULL	O
)	O
{	O
error	function
(	O
"WARNING: This file was viewed via LESSOPEN"	pointer
,	O
NULL_PARG	O
)	O
;	O
}	O
start_mca	function
(	O
A_SHELL	int
,	O
"!"	pointer
,	O
ml_shell	pointer
,	O
0	int
)	O
;	O
make_display	function
(	O
)	O
;	O
cmd_exec	function
(	O
)	O
;	O
lsystem	function
(	O
pr_expand	function
(	O
editproto	pointer
,	O
0	int
)	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
break	O
;	O
}	O
error	function
(	O
"Command not available"	pointer
,	O
NULL_PARG	O
)	O
;	O
break	O
;	O
case	O
A_NEXT_FILE	int
:	O
if	O
(	O
ntags	function
(	O
)	O
)	O
{	O
error	function
(	O
"No next file"	pointer
,	O
NULL_PARG	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
number	long
<=	O
0	int
)	O
number	long
=	O
1	int
;	O
if	O
(	O
edit_next	function
(	O
(	O
int	O
)	O
number	long
)	O
)	O
{	O
if	O
(	O
get_quit_at_eof	function
(	O
)	O
&&	O
eof_displayed	function
(	O
)	O
&&	O
!	O
(	O
ch_getflags	function
(	O
)	O
&	O
CH_HELPFILE	int
)	O
)	O
quit	function
(	O
QUIT_OK	int
)	O
;	O
parg	union
.	O
p_string	pointer
=	O
(	O
number	long
>	O
1	int
)	O
?	O
"(N-th) "	pointer
:	O
""	pointer
;	O
error	function
(	O
"No %snext file"	pointer
,	O
&	O
parg	union
)	O
;	O
}	O
break	O
;	O
case	O
A_PREV_FILE	int
:	O
if	O
(	O
ntags	function
(	O
)	O
)	O
{	O
error	function
(	O
"No previous file"	pointer
,	O
NULL_PARG	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
number	long
<=	O
0	int
)	O
number	long
=	O
1	int
;	O
if	O
(	O
edit_prev	function
(	O
(	O
int	O
)	O
number	long
)	O
)	O
{	O
parg	union
.	O
p_string	pointer
=	O
(	O
number	long
>	O
1	int
)	O
?	O
"(N-th) "	pointer
:	O
""	pointer
;	O
error	function
(	O
"No %sprevious file"	pointer
,	O
&	O
parg	union
)	O
;	O
}	O
break	O
;	O
case	O
A_NEXT_TAG	int
:	O
if	O
(	O
number	long
<=	O
0	int
)	O
number	long
=	O
1	int
;	O
tagfile	pointer
=	O
nexttag	function
(	O
(	O
int	O
)	O
number	long
)	O
;	O
if	O
(	O
tagfile	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
"No next tag"	pointer
,	O
NULL_PARG	O
)	O
;	O
break	O
;	O
}	O
cmd_exec	function
(	O
)	O
;	O
if	O
(	O
edit	function
(	O
tagfile	pointer
)	O
==	O
0	int
)	O
{	O
POSITION	long
pos	long
=	O
tagsearch	function
(	O
)	O
;	O
if	O
(	O
pos	long
!=	O
NULL_POSITION	O
)	O
jump_loc	function
(	O
pos	long
,	O
jump_sline	int
)	O
;	O
}	O
break	O
;	O
case	O
A_PREV_TAG	int
:	O
if	O
(	O
number	long
<=	O
0	int
)	O
number	long
=	O
1	int
;	O
tagfile	pointer
=	O
prevtag	function
(	O
(	O
int	O
)	O
number	long
)	O
;	O
if	O
(	O
tagfile	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
"No previous tag"	pointer
,	O
NULL_PARG	O
)	O
;	O
break	O
;	O
}	O
cmd_exec	function
(	O
)	O
;	O
if	O
(	O
edit	function
(	O
tagfile	pointer
)	O
==	O
0	int
)	O
{	O
POSITION	long
pos	long
=	O
tagsearch	function
(	O
)	O
;	O
if	O
(	O
pos	long
!=	O
NULL_POSITION	O
)	O
jump_loc	function
(	O
pos	long
,	O
jump_sline	int
)	O
;	O
}	O
break	O
;	O
case	O
A_INDEX_FILE	int
:	O
if	O
(	O
number	long
<=	O
0	int
)	O
number	long
=	O
1	int
;	O
if	O
(	O
edit_index	function
(	O
(	O
int	O
)	O
number	long
)	O
)	O
error	function
(	O
"No such file"	pointer
,	O
NULL_PARG	O
)	O
;	O
break	O
;	O
case	O
A_REMOVE_FILE	int
:	O
if	O
(	O
ch_getflags	function
(	O
)	O
&	O
CH_HELPFILE	int
)	O
break	O
;	O
old_ifile	pointer
=	O
curr_ifile	pointer
;	O
new_ifile	pointer
=	O
getoff_ifile	function
(	O
curr_ifile	pointer
)	O
;	O
if	O
(	O
new_ifile	pointer
==	O
NULL_IFILE	O
)	O
{	O
bell	function
(	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
edit_ifile	function
(	O
new_ifile	pointer
)	O
!=	O
0	int
)	O
{	O
reedit_ifile	function
(	O
old_ifile	pointer
)	O
;	O
break	O
;	O
}	O
del_ifile	function
(	O
old_ifile	pointer
)	O
;	O
break	O
;	O
case	O
A_OPT_TOGGLE	int
:	O
optflag	int
=	O
OPT_TOGGLE	int
;	O
optgetname	int
=	O
FALSE	int
;	O
mca_opt_toggle	function
(	O
)	O
;	O
c	int
=	O
getcc	function
(	O
)	O
;	O
goto	O
again	O
;	O
case	O
A_DISP_OPTION	int
:	O
optflag	int
=	O
OPT_NO_TOGGLE	int
;	O
optgetname	int
=	O
FALSE	int
;	O
mca_opt_toggle	function
(	O
)	O
;	O
c	int
=	O
getcc	function
(	O
)	O
;	O
goto	O
again	O
;	O
case	O
A_FIRSTCMD	int
:	O
start_mca	function
(	O
A_FIRSTCMD	int
,	O
"+"	pointer
,	O
(	O
void	O
*	O
)	O
NULL	O
,	O
0	int
)	O
;	O
c	int
=	O
getcc	function
(	O
)	O
;	O
goto	O
again	O
;	O
case	O
A_SHELL	int
:	O
if	O
(	O
!	O
secure	int
)	O
{	O
start_mca	function
(	O
A_SHELL	int
,	O
"!"	pointer
,	O
ml_shell	pointer
,	O
0	int
)	O
;	O
c	int
=	O
getcc	function
(	O
)	O
;	O
goto	O
again	O
;	O
}	O
error	function
(	O
"Command not available"	pointer
,	O
NULL_PARG	O
)	O
;	O
break	O
;	O
case	O
A_SETMARK	int
:	O
case	O
A_SETMARKBOT	int
:	O
if	O
(	O
ch_getflags	function
(	O
)	O
&	O
CH_HELPFILE	int
)	O
break	O
;	O
start_mca	function
(	O
A_SETMARK	int
,	O
"set mark: "	pointer
,	O
(	O
void	O
*	O
)	O
NULL	O
,	O
0	int
)	O
;	O
c	int
=	O
getcc	function
(	O
)	O
;	O
if	O
(	O
is_erase_char	function
(	O
c	int
)	O
||	O
is_newline_char	function
(	O
c	int
)	O
)	O
break	O
;	O
setmark	function
(	O
c	int
,	O
action	int
==	O
A_SETMARKBOT	int
?	O
BOTTOM	O
:	O
TOP	O
)	O
;	O
repaint	function
(	O
)	O
;	O
break	O
;	O
case	O
A_CLRMARK	int
:	O
start_mca	function
(	O
A_CLRMARK	int
,	O
"clear mark: "	pointer
,	O
(	O
void	O
*	O
)	O
NULL	O
,	O
0	int
)	O
;	O
c	int
=	O
getcc	function
(	O
)	O
;	O
if	O
(	O
is_erase_char	function
(	O
c	int
)	O
||	O
is_newline_char	function
(	O
c	int
)	O
)	O
break	O
;	O
clrmark	function
(	O
c	int
)	O
;	O
repaint	function
(	O
)	O
;	O
break	O
;	O
case	O
A_GOMARK	int
:	O
start_mca	function
(	O
A_GOMARK	int
,	O
"goto mark: "	pointer
,	O
(	O
void	O
*	O
)	O
NULL	O
,	O
0	int
)	O
;	O
c	int
=	O
getcc	function
(	O
)	O
;	O
if	O
(	O
is_erase_char	function
(	O
c	int
)	O
||	O
is_newline_char	function
(	O
c	int
)	O
)	O
break	O
;	O
cmd_exec	function
(	O
)	O
;	O
gomark	function
(	O
c	int
)	O
;	O
break	O
;	O
case	O
A_PIPE	int
:	O
if	O
(	O
!	O
secure	int
)	O
{	O
start_mca	function
(	O
A_PIPE	int
,	O
"|mark: "	pointer
,	O
(	O
void	O
*	O
)	O
NULL	O
,	O
0	int
)	O
;	O
c	int
=	O
getcc	function
(	O
)	O
;	O
if	O
(	O
is_erase_char	function
(	O
c	int
)	O
)	O
break	O
;	O
if	O
(	O
is_newline_char	function
(	O
c	int
)	O
)	O
c	int
=	O
'.'	O
;	O
if	O
(	O
badmark	function
(	O
c	int
)	O
)	O
break	O
;	O
pipec	char
=	O
c	int
;	O
start_mca	function
(	O
A_PIPE	int
,	O
"!"	pointer
,	O
ml_shell	pointer
,	O
0	int
)	O
;	O
c	int
=	O
getcc	function
(	O
)	O
;	O
goto	O
again	O
;	O
}	O
error	function
(	O
"Command not available"	pointer
,	O
NULL_PARG	O
)	O
;	O
break	O
;	O
case	O
A_B_BRACKET	int
:	O
case	O
A_F_BRACKET	int
:	O
start_mca	function
(	O
action	int
,	O
"Brackets: "	pointer
,	O
(	O
void	O
*	O
)	O
NULL	O
,	O
0	int
)	O
;	O
c	int
=	O
getcc	function
(	O
)	O
;	O
goto	O
again	O
;	O
case	O
A_LSHIFT	int
:	O
if	O
(	O
number	long
>	O
0	int
)	O
shift_count	int
=	O
number	long
;	O
else	O
number	long
=	O
(	O
shift_count	int
>	O
0	int
)	O
?	O
shift_count	int
:	O
sc_width	int
/	O
2	int
;	O
if	O
(	O
number	long
>	O
hshift	int
)	O
number	long
=	O
hshift	int
;	O
hshift	int
-=	O
number	long
;	O
screen_trashed	int
=	O
1	int
;	O
break	O
;	O
case	O
A_RSHIFT	int
:	O
if	O
(	O
number	long
>	O
0	int
)	O
shift_count	int
=	O
number	long
;	O
else	O
number	long
=	O
(	O
shift_count	int
>	O
0	int
)	O
?	O
shift_count	int
:	O
sc_width	int
/	O
2	int
;	O
hshift	int
+=	O
number	long
;	O
screen_trashed	int
=	O
1	int
;	O
break	O
;	O
case	O
A_LLSHIFT	int
:	O
hshift	int
=	O
0	int
;	O
screen_trashed	int
=	O
1	int
;	O
break	O
;	O
case	O
A_RRSHIFT	int
:	O
hshift	int
=	O
rrshift	function
(	O
)	O
;	O
screen_trashed	int
=	O
1	int
;	O
break	O
;	O
case	O
A_PREFIX	int
:	O
if	O
(	O
mca	int
!=	O
A_PREFIX	int
)	O
{	O
cmd_reset	function
(	O
)	O
;	O
start_mca	function
(	O
A_PREFIX	int
,	O
" "	pointer
,	O
(	O
void	O
*	O
)	O
NULL	O
,	O
CF_QUIT_ON_ERASE	int
)	O
;	O
(	O
void	O
)	O
cmd_char	function
(	O
c	int
)	O
;	O
}	O
c	int
=	O
getcc	function
(	O
)	O
;	O
goto	O
again	O
;	O
case	O
A_NOACTION	int
:	O
break	O
;	O
default	O
:	O
bell	function
(	O
)	O
;	O
break	O
;	O
}	O
}	O
}	O
