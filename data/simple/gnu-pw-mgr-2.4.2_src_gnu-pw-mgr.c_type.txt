static	O
char	O
*	O
dom_text	pointer
=	O
NULL	O
;	O
static	O
char	O
const	O
*	O
dom_file_name	pointer
=	O
NULL	O
;	O
static	O
struct	O
stat	struct
dom_file_stat	struct
=	O
{	O
.	O
st_size	long
=	O
0	int
}	O
;	O
static	O
off_t	long
dom_text_len	long
=	O
0	int
;	O
static	O
char	O
*	O
load_file	function
(	O
char	O
const	O
*	O
fname	pointer
)	O
{	O
char	O
*	O
txt	pointer
;	O
char	O
*	O
scn	pointer
;	O
size_t	long
sz	long
;	O
FILE	struct
*	O
fp	pointer
;	O
if	O
(	O
stat	struct
(	O
fname	pointer
,	O
&	O
dom_file_stat	struct
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
errno	O
!=	O
ENOENT	int
)	O
fserr	function
(	O
GNU_PW_MGR_EXIT_INVALID	int
,	O
"stat"	pointer
,	O
fname	pointer
)	O
;	O
dom_file_stat	struct
.	O
st_size	long
=	O
4096	int
;	O
txt	pointer
=	O
malloc	function
(	O
dom_file_stat	struct
.	O
st_size	long
)	O
;	O
txt	pointer
[	O
0	int
]	O
=	O
NUL	char
;	O
return	O
txt	pointer
;	O
}	O
if	O
(	O
!	O
S_ISREG	O
(	O
dom_file_stat	struct
.	O
st_mode	int
)	O
)	O
{	O
errno	O
=	O
EINVAL	int
;	O
fserr	function
(	O
GNU_PW_MGR_EXIT_INVALID	int
,	O
"stat"	pointer
,	O
fname	pointer
)	O
;	O
}	O
fp	pointer
=	O
fopen	function
(	O
fname	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
fp	pointer
==	O
NULL	O
)	O
fserr	function
(	O
GNU_PW_MGR_EXIT_INVALID	int
,	O
"fopen 'r'"	pointer
,	O
fname	pointer
)	O
;	O
sz	long
=	O
(	O
dom_file_stat	struct
.	O
st_size	long
+	O
4096	int
)	O
&	O
~	O
4096	int
;	O
txt	pointer
=	O
scn	pointer
=	O
malloc	function
(	O
sz	long
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
size_t	long
rdsz	long
=	O
fread	function
(	O
scn	pointer
,	O
1	int
,	O
dom_file_stat	struct
.	O
st_size	long
,	O
fp	pointer
)	O
;	O
if	O
(	O
rdsz	long
==	O
0	int
)	O
break	O
;	O
scn	pointer
+=	O
rdsz	long
;	O
dom_file_stat	struct
.	O
st_size	long
-=	O
rdsz	long
;	O
if	O
(	O
dom_file_stat	struct
.	O
st_size	long
==	O
0	int
)	O
break	O
;	O
}	O
*	O
scn	pointer
=	O
NUL	char
;	O
dom_file_stat	struct
.	O
st_size	long
=	O
sz	long
;	O
dom_text_len	long
=	O
(	O
scn	pointer
-	O
txt	pointer
)	O
;	O
dom_text	pointer
=	O
txt	pointer
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
return	O
txt	pointer
;	O
}	O
static	O
void	O
set_confirm_value	function
(	O
char	O
*	O
buf	array
,	O
size_t	long
bsz	long
,	O
unsigned	O
char	O
*	O
data	pointer
,	O
size_t	long
d_len	long
,	O
char	O
const	O
*	O
pwd_id_str	pointer
)	O
{	O
const	O
int	O
buf_off	int
=	O
CONFIRM_LEN	int
+	O
1	int
;	O
assert	O
(	O
bsz	long
>	O
(	O
buf_off	int
*	O
2	int
)	O
)	O
;	O
base64_encode	function
(	O
(	O
char	O
*	O
)	O
data	pointer
,	O
d_len	long
,	O
buf	array
,	O
buf_off	int
)	O
;	O
buf	array
[	O
buf_off	int
-	O
1	int
]	O
=	O
buf	array
[	O
buf_off	int
]	O
=	O
' '	O
;	O
{	O
union	O
{	O
uintptr_t	long
data	pointer
[	O
256	int
/	O
(	O
NBBY	int
*	O
sizeof	O
(	O
uintptr_t	long
)	O
)	O
]	O
;	O
unsigned	O
char	O
sha_buf	array
[	O
256	int
/	O
NBBY	int
]	O
;	O
}	O
sum	union
;	O
struct	O
sha256_ctx	struct
ctx	pointer
;	O
sha256_init_ctx	function
(	O
&	O
ctx	pointer
)	O
;	O
sha256_process_bytes	function
(	O
pwd_id_str	pointer
,	O
strlen	function
(	O
pwd_id_str	pointer
)	O
+	O
1	int
,	O
&	O
ctx	pointer
)	O
;	O
sha256_process_bytes	function
(	O
OPT_ARG	O
(	O
CONFIRM	O
)	O
,	O
strlen	function
(	O
OPT_ARG	O
(	O
CONFIRM	O
)	O
)	O
+	O
1	int
,	O
&	O
ctx	pointer
)	O
;	O
sha256_finish_ctx	function
(	O
&	O
ctx	pointer
,	O
sum	union
.	O
sha_buf	array
)	O
;	O
base64_encode	function
(	O
(	O
char	O
*	O
)	O
sum	union
.	O
sha_buf	array
,	O
sizeof	O
(	O
sum	union
.	O
sha_buf	array
)	O
,	O
buf	array
+	O
buf_off	int
+	O
1	int
,	O
bsz	long
-	O
buf_off	int
-	O
1	int
)	O
;	O
}	O
buf	array
[	O
buf_off	int
+	O
CONFIRM_LEN	int
+	O
1	int
]	O
=	O
NUL	char
;	O
fix_lower_only_pw	function
(	O
buf	array
)	O
;	O
buf	array
[	O
buf_off	int
-	O
1	int
]	O
=	O
buf	array
[	O
buf_off	int
]	O
=	O
' '	O
;	O
}	O
static	O
void	O
adjust_pw	function
(	O
char	O
*	O
buf	array
,	O
size_t	long
bsz	long
,	O
unsigned	O
char	O
*	O
data	pointer
,	O
size_t	long
d_len	long
,	O
char	O
const	O
*	O
pwd_id_str	pointer
)	O
{	O
char	O
*	O
dta	pointer
=	O
(	O
char	O
*	O
)	O
data	pointer
;	O
unsigned	O
int	O
cclass	int
=	O
OPT_VALUE_CCLASS	O
&	O
(	O
CCLASS_NO_ALPHA	int
|	O
CCLASS_NO_SPECIAL	int
)	O
;	O
if	O
(	O
cclass	int
==	O
(	O
CCLASS_NO_ALPHA	int
|	O
CCLASS_NO_SPECIAL	int
)	O
)	O
{	O
static	O
uint32_t	int
const	O
bytes_per_val	int
=	O
7	int
;	O
uint32_t	int
mx	int
=	O
(	O
d_len	long
/	O
sizeof	O
(	O
uintptr_t	long
)	O
)	O
*	O
bytes_per_val	int
;	O
if	O
(	O
OPT_VALUE_LENGTH	O
>	O
mx	int
)	O
die	function
(	O
GNU_PW_MGR_EXIT_INVALID	int
,	O
pin_too_big	O
,	O
(	O
uint32_t	int
)	O
OPT_VALUE_LENGTH	O
,	O
mx	int
)	O
;	O
fix_digit_pw	function
(	O
buf	array
,	O
(	O
uintptr_t	long
*	O
)	O
(	O
uintptr_t	long
)	O
data	pointer
)	O
;	O
}	O
else	O
{	O
base64_encode	function
(	O
dta	pointer
,	O
d_len	long
,	O
buf	array
,	O
bsz	long
)	O
;	O
buf	array
[	O
OPT_VALUE_LENGTH	O
]	O
=	O
NUL	char
;	O
if	O
(	O
cclass	int
==	O
CCLASS_NO_ALPHA	int
)	O
fix_no_alpha_pw	function
(	O
buf	array
)	O
;	O
else	O
fix_std_pw	function
(	O
buf	array
)	O
;	O
}	O
}	O
static	O
void	O
get_dft_pw	function
(	O
char	O
*	O
buf	array
,	O
size_t	long
bsz	long
,	O
char	O
const	O
*	O
tag	pointer
,	O
char	O
const	O
*	O
txt	pointer
,	O
char	O
const	O
*	O
pwd_id_str	pointer
)	O
{	O
union	O
{	O
uintptr_t	long
data	pointer
[	O
256	int
/	O
(	O
NBBY	int
*	O
sizeof	O
(	O
uintptr_t	long
)	O
)	O
]	O
;	O
unsigned	O
char	O
sha_buf	array
[	O
256	int
/	O
NBBY	int
]	O
;	O
}	O
sum	union
;	O
struct	O
sha256_ctx	struct
ctx	pointer
;	O
sha256_init_ctx	function
(	O
&	O
ctx	pointer
)	O
;	O
sha256_process_bytes	function
(	O
tag	pointer
,	O
strlen	function
(	O
tag	pointer
)	O
+	O
1	int
,	O
&	O
ctx	pointer
)	O
;	O
sha256_process_bytes	function
(	O
txt	pointer
,	O
strlen	function
(	O
txt	pointer
)	O
+	O
1	int
,	O
&	O
ctx	pointer
)	O
;	O
sha256_process_bytes	function
(	O
pwd_id_str	pointer
,	O
strlen	function
(	O
pwd_id_str	pointer
)	O
+	O
1	int
,	O
&	O
ctx	pointer
)	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
CONFIRM	O
)	O
)	O
sha256_process_bytes	function
(	O
OPT_ARG	O
(	O
CONFIRM	O
)	O
,	O
strlen	function
(	O
OPT_ARG	O
(	O
CONFIRM	O
)	O
)	O
+	O
1	int
,	O
&	O
ctx	pointer
)	O
;	O
sha256_finish_ctx	function
(	O
&	O
ctx	pointer
,	O
sum	union
.	O
sha_buf	array
)	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
CONFIRM	O
)	O
)	O
set_confirm_value	function
(	O
buf	array
,	O
bsz	long
,	O
sum	union
.	O
sha_buf	array
,	O
sizeof	O
(	O
sum	union
.	O
sha_buf	array
)	O
,	O
pwd_id_str	pointer
)	O
;	O
else	O
adjust_pw	function
(	O
buf	array
,	O
bsz	long
,	O
sum	union
.	O
sha_buf	array
,	O
sizeof	O
(	O
sum	union
.	O
sha_buf	array
)	O
,	O
pwd_id_str	pointer
)	O
;	O
}	O
static	O
void	O
get_pbkdf2_pw	function
(	O
char	O
*	O
buf	array
,	O
size_t	long
bsz	long
,	O
char	O
const	O
*	O
tag	pointer
,	O
char	O
const	O
*	O
salt	pointer
,	O
char	O
const	O
*	O
pwd_id_str	pointer
)	O
{	O
size_t	long
const	O
stag_len	long
=	O
strlen	function
(	O
tag	pointer
)	O
+	O
1	int
;	O
size_t	long
const	O
salt_len	long
=	O
strlen	function
(	O
salt	pointer
)	O
+	O
1	int
;	O
size_t	long
const	O
pwid_len	long
=	O
strlen	function
(	O
pwd_id_str	pointer
)	O
+	O
1	int
;	O
size_t	long
const	O
conf_len	long
=	O
HAVE_OPT	O
(	O
CONFIRM	O
)	O
?	O
(	O
strlen	function
(	O
OPT_ARG	O
(	O
CONFIRM	O
)	O
)	O
+	O
1	int
)	O
:	O
0	int
;	O
size_t	long
const	O
hash_src_len	long
=	O
stag_len	long
+	O
pwid_len	long
+	O
conf_len	long
;	O
size_t	long
const	O
hash_out_len	long
=	O
4	int
+	O
(	O
(	O
bsz	long
*	O
6	int
)	O
>>	O
3	int
)	O
;	O
char	O
*	O
hash_source	pointer
=	O
scribble_get	function
(	O
hash_src_len	long
)	O
;	O
char	O
*	O
hash_output	pointer
=	O
scribble_get	function
(	O
hash_out_len	long
)	O
;	O
Gc_rc	enum
rc	enum
;	O
memcpy	function
(	O
hash_source	pointer
,	O
tag	pointer
,	O
stag_len	long
)	O
;	O
memcpy	function
(	O
hash_source	pointer
+	O
stag_len	long
,	O
pwd_id_str	pointer
,	O
pwid_len	long
)	O
;	O
if	O
(	O
conf_len	long
>	O
0	int
)	O
memcpy	function
(	O
hash_source	pointer
+	O
stag_len	long
+	O
pwid_len	long
,	O
OPT_ARG	O
(	O
CONFIRM	O
)	O
,	O
conf_len	long
)	O
;	O
rc	enum
=	O
gc_pbkdf2_sha1	function
(	O
hash_source	pointer
,	O
hash_src_len	long
,	O
salt	pointer
,	O
salt_len	long
,	O
OPT_VALUE_PBKDF2	O
,	O
hash_output	pointer
,	O
hash_out_len	long
)	O
;	O
if	O
(	O
rc	enum
!=	O
GC_OK	int
)	O
die	function
(	O
GNU_PW_MGR_EXIT_INVALID	int
,	O
pbkdf2_err_fmt	O
,	O
rc	enum
)	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
CONFIRM	O
)	O
)	O
set_confirm_value	function
(	O
buf	array
,	O
bsz	long
,	O
(	O
unsigned	O
char	O
*	O
)	O
hash_output	pointer
,	O
hash_out_len	long
,	O
pwd_id_str	pointer
)	O
;	O
else	O
adjust_pw	function
(	O
buf	array
,	O
bsz	long
,	O
(	O
unsigned	O
char	O
*	O
)	O
hash_output	pointer
,	O
hash_out_len	long
,	O
pwd_id_str	pointer
)	O
;	O
}	O
static	O
void	O
print_pwid_header	function
(	O
char	O
const	O
*	O
pwd_id_str	pointer
)	O
{	O
printf	function
(	O
pwid_hdr_fmt	O
,	O
pwd_id_str	pointer
,	O
ENABLED_OPT	O
(	O
SHARED	O
)	O
?	O
pwid_shared	O
:	O
""	pointer
)	O
;	O
}	O
static	O
void	O
print_pwid_status	function
(	O
char	O
const	O
*	O
pwd_id_str	pointer
)	O
{	O
bool	bool
have_data	bool
=	O
false	int
;	O
if	O
(	O
HAVE_OPT	O
(	O
LOGIN_ID	O
)	O
)	O
{	O
have_data	bool
=	O
true	int
;	O
print_pwid_header	function
(	O
pwd_id_str	pointer
)	O
;	O
printf	function
(	O
pwst_str_fmt	O
,	O
"login-id"	pointer
,	O
OPT_ARG	O
(	O
LOGIN_ID	O
)	O
)	O
;	O
}	O
if	O
(	O
HAVE_OPT	O
(	O
LENGTH	O
)	O
)	O
{	O
if	O
(	O
!	O
have_data	bool
)	O
{	O
print_pwid_header	function
(	O
pwd_id_str	pointer
)	O
;	O
have_data	bool
=	O
true	int
;	O
}	O
printf	function
(	O
pwst_dig_fmt	O
,	O
"length"	pointer
,	O
(	O
unsigned	O
int	O
)	O
OPT_VALUE_LENGTH	O
)	O
;	O
}	O
if	O
(	O
HAVE_OPT	O
(	O
PBKDF2	O
)	O
||	O
(	O
OPT_VALUE_LENGTH	O
>	O
(	O
MIN_BUF_LEN	O
-	O
8	int
)	O
)	O
)	O
{	O
if	O
(	O
!	O
have_data	bool
)	O
{	O
print_pwid_header	function
(	O
pwd_id_str	pointer
)	O
;	O
have_data	bool
=	O
true	int
;	O
}	O
if	O
(	O
ENABLED_OPT	O
(	O
PBKDF2	O
)	O
||	O
(	O
OPT_VALUE_LENGTH	O
>	O
(	O
MIN_BUF_LEN	O
-	O
8	int
)	O
)	O
)	O
printf	function
(	O
pwst_dig_fmt	O
,	O
"pbkdf2 ct"	pointer
,	O
(	O
unsigned	O
int	O
)	O
OPT_VALUE_PBKDF2	O
)	O
;	O
else	O
printf	function
(	O
pwst_str_fmt	O
,	O
"pbkdf2"	pointer
,	O
"not used"	pointer
)	O
;	O
}	O
if	O
(	O
HAVE_OPT	O
(	O
SPECIALS	O
)	O
)	O
{	O
if	O
(	O
!	O
have_data	bool
)	O
{	O
print_pwid_header	function
(	O
pwd_id_str	pointer
)	O
;	O
have_data	bool
=	O
true	int
;	O
}	O
printf	function
(	O
pwst_str_fmt	O
,	O
"spec chars"	pointer
,	O
OPT_ARG	O
(	O
SPECIALS	O
)	O
)	O
;	O
}	O
if	O
(	O
HAVE_OPT	O
(	O
CCLASS	O
)	O
)	O
{	O
char	O
const	O
*	O
names	array
;	O
if	O
(	O
!	O
have_data	bool
)	O
{	O
print_pwid_header	function
(	O
pwd_id_str	pointer
)	O
;	O
have_data	bool
=	O
true	int
;	O
}	O
doOptCclass	function
(	O
OPTPROC_RETURN_VALNAME	O
,	O
&	O
DESC	O
(	O
CCLASS	O
)	O
)	O
;	O
names	array
=	O
DESC	O
(	O
CCLASS	O
)	O
.	O
optArg	union
.	O
argString	pointer
;	O
printf	function
(	O
pwst_str_fmt	O
,	O
"ch-class"	pointer
,	O
names	array
)	O
;	O
free	function
(	O
(	O
void	O
*	O
)	O
names	array
)	O
;	O
}	O
if	O
(	O
!	O
have_data	bool
)	O
printf	function
(	O
"The %s password id has all default settings\n"	pointer
,	O
pwd_id_str	pointer
)	O
;	O
else	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
PBKDF2	O
)	O
)	O
printf	function
(	O
pwst_dig_dft	O
,	O
"pbkdf2 ct"	pointer
,	O
(	O
unsigned	O
int	O
)	O
OPT_VALUE_PBKDF2	O
)	O
;	O
}	O
static	O
void	O
select_chars	function
(	O
unsigned	O
char	O
*	O
txtbuf	pointer
)	O
{	O
int	O
const	O
len	long
=	O
strlen	function
(	O
(	O
char	O
*	O
)	O
txtbuf	pointer
)	O
;	O
char	O
*	O
pn	pointer
=	O
NULL	O
;	O
char	O
const	O
*	O
p	pointer
=	O
OPT_ARG	O
(	O
SELECT_CHARS	O
)	O
;	O
char	O
buf	array
[	O
64	int
]	O
,	O
*	O
pd	pointer
=	O
buf	array
;	O
int	O
const	O
lim	int
=	O
(	O
len	long
>	O
sizeof	O
(	O
buf	array
)	O
)	O
?	O
sizeof	O
(	O
buf	array
)	O
:	O
len	long
;	O
errno	O
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
long	O
v	union
=	O
strtol	function
(	O
p	pointer
,	O
&	O
pn	pointer
,	O
0	int
)	O
;	O
if	O
(	O
(	O
errno	O
!=	O
0	int
)	O
||	O
(	O
v	union
<	O
1	int
)	O
||	O
(	O
v	union
>	O
len	long
)	O
)	O
die	function
(	O
GNU_PW_MGR_EXIT_BAD_SELECT_CHARS	int
,	O
OPT_ARG	O
(	O
SELECT_CHARS	O
)	O
)	O
;	O
*	O
(	O
pd	pointer
++	O
)	O
=	O
txtbuf	pointer
[	O
v	union
-	O
1	int
]	O
;	O
if	O
(	O
pd	pointer
>=	O
buf	array
+	O
lim	int
)	O
die	function
(	O
GNU_PW_MGR_EXIT_BAD_SELECT_CHARS	int
,	O
OPT_ARG	O
(	O
SELECT_CHARS	O
)	O
)	O
;	O
p	pointer
=	O
pn	pointer
+	O
strspn	function
(	O
pn	pointer
,	O
" ,"	pointer
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
NUL	char
)	O
break	O
;	O
}	O
*	O
pd	pointer
=	O
NUL	char
;	O
strcpy	function
(	O
(	O
char	O
*	O
)	O
txtbuf	pointer
,	O
buf	array
)	O
;	O
}	O
static	O
bool	bool
print_one_pwid	function
(	O
tOptionValue	struct
const	O
*	O
seed_opt	pointer
,	O
char	O
const	O
*	O
pwd_id_str	pointer
)	O
{	O
if	O
(	O
seed_opt	pointer
->	O
valType	enum
!=	O
OPARG_TYPE_HIERARCHY	int
)	O
die	function
(	O
GNU_PW_MGR_EXIT_BAD_SEED	int
,	O
bad_seed	O
)	O
;	O
{	O
tOptionValue	struct
const	O
*	O
ver	pointer
=	O
optionGetValue	function
(	O
seed_opt	pointer
,	O
s_ver_z	O
)	O
;	O
if	O
(	O
(	O
ver	pointer
==	O
NULL	O
)	O
||	O
(	O
ver	pointer
->	O
valType	enum
!=	O
OPARG_TYPE_NUMERIC	int
)	O
)	O
{	O
tOptionValue	struct
const	O
*	O
tag	pointer
=	O
optionGetValue	function
(	O
seed_opt	pointer
,	O
tag_z	O
)	O
;	O
warning_msg	function
(	O
too_old_z	O
,	O
tag	pointer
->	O
v	union
.	O
strVal	array
)	O
;	O
return	O
false	int
;	O
}	O
}	O
{	O
tOptionValue	struct
const	O
*	O
sec	pointer
=	O
optionGetValue	function
(	O
seed_opt	pointer
,	O
sec_pw_id	O
)	O
;	O
if	O
(	O
(	O
sec	pointer
==	O
NULL	O
)	O
!=	O
(	O
!	O
HAVE_OPT	O
(	O
SHARED	O
)	O
)	O
)	O
return	O
false	int
;	O
}	O
tOptionValue	struct
const	O
*	O
tag	pointer
=	O
optionGetValue	function
(	O
seed_opt	pointer
,	O
tag_z	O
)	O
;	O
tOptionValue	struct
const	O
*	O
txt	pointer
=	O
optionGetValue	function
(	O
seed_opt	pointer
,	O
text_z	O
)	O
;	O
if	O
(	O
(	O
tag	pointer
->	O
valType	enum
!=	O
OPARG_TYPE_STRING	int
)	O
||	O
(	O
tag	pointer
->	O
valType	enum
!=	O
OPARG_TYPE_STRING	int
)	O
)	O
die	function
(	O
GNU_PW_MGR_EXIT_BAD_SEED	int
,	O
bad_seed	O
)	O
;	O
size_t	long
buf_len	long
=	O
(	O
OPT_VALUE_LENGTH	O
>	O
(	O
MIN_BUF_LEN	O
-	O
8	int
)	O
)	O
?	O
OPT_VALUE_LENGTH	O
+	O
16	int
:	O
MIN_BUF_LEN	O
;	O
unsigned	O
char	O
*	O
txtbuf	pointer
=	O
scribble_get	function
(	O
buf_len	long
)	O
;	O
if	O
(	O
(	O
OPT_VALUE_PBKDF2	O
==	O
0	int
)	O
||	O
!	O
ENABLED_OPT	O
(	O
PBKDF2	O
)	O
||	O
(	O
OPT_VALUE_LENGTH	O
>	O
(	O
MIN_BUF_LEN	O
-	O
8	int
)	O
)	O
)	O
get_dft_pw	function
(	O
(	O
char	O
*	O
)	O
txtbuf	pointer
,	O
buf_len	long
,	O
tag	pointer
->	O
v	union
.	O
strVal	array
,	O
txt	pointer
->	O
v	union
.	O
strVal	array
,	O
pwd_id_str	pointer
)	O
;	O
else	O
get_pbkdf2_pw	function
(	O
(	O
char	O
*	O
)	O
txtbuf	pointer
,	O
buf_len	long
,	O
tag	pointer
->	O
v	union
.	O
strVal	array
,	O
txt	pointer
->	O
v	union
.	O
strVal	array
,	O
pwd_id_str	pointer
)	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
SELECT_CHARS	O
)	O
)	O
select_chars	function
(	O
txtbuf	pointer
)	O
;	O
printf	function
(	O
pw_fmt	O
,	O
tag	pointer
->	O
v	union
.	O
strVal	array
,	O
txtbuf	pointer
)	O
;	O
return	O
true	int
;	O
}	O
static	O
void	O
print_pwid	function
(	O
char	O
const	O
*	O
pwd_id_str	pointer
)	O
{	O
tOptionValue	struct
const	O
*	O
ov	pointer
=	O
optionFindValue	function
(	O
&	O
DESC	O
(	O
SEED	O
)	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
bool	bool
printed_pw	bool
=	O
false	int
;	O
if	O
(	O
*	O
pwd_id_str	pointer
==	O
NUL	char
)	O
die	function
(	O
GNU_PW_MGR_EXIT_NO_PWID	int
,	O
no_pwid	O
)	O
;	O
set_pwid_opts	function
(	O
pwd_id_str	pointer
)	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
STATUS	O
)	O
)	O
{	O
print_pwid_status	function
(	O
pwd_id_str	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
HAVE_OPT	O
(	O
DELETE	O
)	O
)	O
{	O
remove_pwid	function
(	O
pwd_id_str	pointer
)	O
;	O
return	O
;	O
}	O
scribble_free	function
(	O
)	O
;	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
NO_HEADER	O
)	O
)	O
{	O
char	O
const	O
*	O
hdr_type	pointer
=	O
hdr_normal	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
CONFIRM	O
)	O
)	O
{	O
pbkdf2_date	pointer
=	O
""	pointer
;	O
hdr_type	pointer
=	O
hdr_confirm	O
;	O
}	O
if	O
(	O
HAVE_OPT	O
(	O
LOGIN_ID	O
)	O
)	O
printf	function
(	O
hdr_hint	O
,	O
OPT_ARG	O
(	O
LOGIN_ID	O
)	O
)	O
;	O
printf	function
(	O
pw_hdr_fmt	O
,	O
hdr_type	pointer
,	O
pbkdf2_date	pointer
)	O
;	O
}	O
do	O
{	O
printed_pw	bool
|=	O
print_one_pwid	function
(	O
ov	pointer
,	O
pwd_id_str	pointer
)	O
;	O
ov	pointer
=	O
optionFindNextValue	function
(	O
&	O
DESC	O
(	O
SEED	O
)	O
,	O
ov	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
while	O
(	O
ov	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
!	O
printed_pw	bool
)	O
die	function
(	O
GNU_PW_MGR_EXIT_NO_SEED	int
,	O
no_passwords	O
,	O
ENABLED_OPT	O
(	O
SHARED	O
)	O
?	O
sec_pw_type	O
:	O
""	pointer
)	O
;	O
update_pwid_opts	function
(	O
pwd_id_str	pointer
)	O
;	O
}	O
static	O
char	O
const	O
*	O
assemble_arg	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
char	O
*	O
res	pointer
,	O
*	O
scan	pointer
;	O
size_t	long
len	long
=	O
argc	int
;	O
int	O
ct	int
=	O
argc	int
;	O
while	O
(	O
--	O
ct	int
>=	O
0	int
)	O
len	long
+=	O
strlen	function
(	O
argv	pointer
[	O
ct	int
]	O
)	O
;	O
scan	pointer
=	O
res	pointer
=	O
malloc	function
(	O
len	long
)	O
;	O
if	O
(	O
res	pointer
==	O
NULL	O
)	O
nomem_err	function
(	O
len	long
,	O
"password id"	pointer
)	O
;	O
ct	int
=	O
argc	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
len	long
=	O
strlen	function
(	O
*	O
argv	pointer
)	O
;	O
memcpy	function
(	O
scan	pointer
,	O
*	O
(	O
argv	pointer
++	O
)	O
,	O
len	long
)	O
;	O
scan	pointer
+=	O
len	long
;	O
if	O
(	O
--	O
ct	int
<=	O
0	int
)	O
break	O
;	O
*	O
(	O
scan	pointer
++	O
)	O
=	O
' '	O
;	O
}	O
*	O
scan	pointer
=	O
NUL	char
;	O
return	O
res	pointer
;	O
}	O
static	O
char	O
*	O
trim	function
(	O
char	O
*	O
in	pointer
)	O
{	O
char	O
*	O
res	pointer
;	O
while	O
(	O
isspace	function
(	O
(	O
unsigned	O
int	O
)	O
*	O
in	pointer
)	O
)	O
in	pointer
++	O
;	O
res	pointer
=	O
in	pointer
;	O
in	pointer
+=	O
strlen	function
(	O
in	pointer
)	O
;	O
while	O
(	O
(	O
in	pointer
>	O
res	pointer
)	O
&&	O
isspace	function
(	O
(	O
unsigned	O
int	O
)	O
(	O
in	pointer
[	O
-	O
1	int
]	O
)	O
)	O
)	O
in	pointer
--	O
;	O
*	O
in	pointer
=	O
NUL	char
;	O
return	O
res	pointer
;	O
}	O
static	O
void	O
stdin_pwid	function
(	O
void	O
)	O
{	O
struct	O
termios	struct
orig_term	struct
;	O
bool	bool
restore_stdin	bool
=	O
false	int
;	O
static	O
char	O
const	O
stdio_funs	array
[	O
]	O
=	O
"tcgetattr/tcsetattr/fputs/fflush/fread"	pointer
;	O
char	O
pwid	array
[	O
4096	int
]	O
;	O
do	O
{	O
if	O
(	O
isatty	function
(	O
STDIN_FILENO	int
)	O
&&	O
isatty	function
(	O
STDOUT_FILENO	int
)	O
)	O
{	O
struct	O
termios	struct
noecho_term	struct
;	O
if	O
(	O
tcgetattr	function
(	O
STDIN_FILENO	int
,	O
&	O
orig_term	struct
)	O
!=	O
0	int
)	O
break	O
;	O
noecho_term	struct
=	O
orig_term	struct
;	O
noecho_term	struct
.	O
c_lflag	int
&=	O
~	O
ECHO	int
;	O
if	O
(	O
tcsetattr	function
(	O
STDIN_FILENO	int
,	O
TCSAFLUSH	int
,	O
&	O
noecho_term	struct
)	O
!=	O
0	int
)	O
break	O
;	O
restore_stdin	bool
=	O
true	int
;	O
if	O
(	O
fputs	function
(	O
pw_prompt	O
,	O
stdout	pointer
)	O
<	O
0	int
)	O
break	O
;	O
if	O
(	O
fflush	function
(	O
stdout	pointer
)	O
!=	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
fgets	function
(	O
pwid	array
,	O
sizeof	O
(	O
pwid	array
)	O
,	O
stdin	pointer
)	O
!=	O
pwid	array
)	O
break	O
;	O
print_pwid	function
(	O
trim	function
(	O
pwid	array
)	O
)	O
;	O
if	O
(	O
restore_stdin	bool
)	O
(	O
void	O
)	O
tcsetattr	function
(	O
STDIN_FILENO	int
,	O
TCSAFLUSH	int
,	O
&	O
orig_term	struct
)	O
;	O
return	O
;	O
}	O
while	O
(	O
0	int
)	O
;	O
if	O
(	O
restore_stdin	bool
)	O
(	O
void	O
)	O
tcsetattr	function
(	O
STDIN_FILENO	int
,	O
TCSAFLUSH	int
,	O
&	O
orig_term	struct
)	O
;	O
fserr	function
(	O
GNU_PW_MGR_EXIT_INVALID	int
,	O
stdio_funs	array
,	O
stdin_out_z	O
)	O
;	O
}	O
static	O
void	O
list_domains	function
(	O
void	O
)	O
{	O
if	O
(	O
dom_text	pointer
==	O
NULL	O
)	O
(	O
void	O
)	O
load_file	function
(	O
dom_file_name	pointer
)	O
;	O
fwrite	function
(	O
dom_text	pointer
,	O
1	int
,	O
dom_text_len	long
,	O
stdout	pointer
)	O
;	O
}	O
static	O
void	O
write_dom_file	function
(	O
void	O
)	O
{	O
FILE	struct
*	O
fp	pointer
;	O
if	O
(	O
dom_text_len	long
==	O
0	int
)	O
return	O
;	O
fp	pointer
=	O
fopen	function
(	O
dom_file_name	pointer
,	O
"w"	pointer
)	O
;	O
if	O
(	O
fp	pointer
==	O
NULL	O
)	O
fserr	function
(	O
GNU_PW_MGR_EXIT_INVALID	int
,	O
"fopen 'w'"	pointer
,	O
dom_file_name	pointer
)	O
;	O
size_t	long
wrlen	long
=	O
fwrite	function
(	O
dom_text	pointer
,	O
1	int
,	O
dom_text_len	long
,	O
fp	pointer
)	O
;	O
if	O
(	O
wrlen	long
!=	O
dom_text_len	long
)	O
fserr	function
(	O
GNU_PW_MGR_EXIT_INVALID	int
,	O
"fwrite"	pointer
,	O
dom_file_name	pointer
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
}	O
static	O
void	O
insert_domain	function
(	O
char	O
const	O
*	O
dom	pointer
)	O
{	O
static	O
char	O
const	O
end_dom_mark	array
[	O
]	O
=	O
"</domain>\n"	pointer
;	O
static	O
char	O
const	O
dom_entry_fmt	array
[	O
]	O
=	O
"<domain time=%-10.10lu%s"	pointer
;	O
static	O
unsigned	O
long	O
const	O
secs_per_day	long
=	O
60UL	int
*	O
60UL	int
*	O
24UL	int
;	O
static	O
size_t	long
base_size	long
=	O
sizeof	O
(	O
end_dom_mark	array
)	O
+	O
sizeof	O
(	O
dom_entry_fmt	array
)	O
;	O
char	O
buf	array
[	O
256	int
]	O
=	O
">"	pointer
;	O
size_t	long
dom_len	long
=	O
strlen	function
(	O
dom	pointer
)	O
;	O
unsigned	O
long	O
cap_time	long
=	O
(	O
unsigned	O
long	O
)	O
time	function
(	O
NULL	O
)	O
/	O
secs_per_day	long
;	O
if	O
(	O
dom_len	long
+	O
sizeof	O
(	O
end_dom_mark	array
)	O
+	O
1	int
>	O
sizeof	O
(	O
buf	array
)	O
)	O
return	O
;	O
if	O
(	O
dom_text	pointer
==	O
NULL	O
)	O
(	O
void	O
)	O
load_file	function
(	O
dom_file_name	pointer
)	O
;	O
memcpy	function
(	O
buf	array
+	O
1	int
,	O
dom	pointer
,	O
dom_len	long
)	O
;	O
memcpy	function
(	O
buf	array
+	O
1	int
+	O
dom_len	long
,	O
end_dom_mark	array
,	O
sizeof	O
(	O
end_dom_mark	array
)	O
)	O
;	O
char	O
*	O
dom_entry	pointer
=	O
strstr	function
(	O
dom_text	pointer
,	O
buf	array
)	O
;	O
if	O
(	O
dom_entry	pointer
!=	O
NULL	O
)	O
{	O
dom_entry	pointer
-=	O
10	int
;	O
int	O
ct	int
=	O
sprintf	function
(	O
dom_entry	pointer
,	O
"%-10.10lu"	pointer
,	O
cap_time	long
)	O
;	O
assert	O
(	O
ct	int
==	O
10	int
)	O
;	O
dom_entry	pointer
[	O
10	int
]	O
=	O
'>'	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
dom_text_len	long
+	O
dom_len	long
+	O
base_size	long
)	O
>=	O
dom_file_stat	struct
.	O
st_size	long
)	O
{	O
dom_file_stat	struct
.	O
st_size	long
+=	O
4096	int
;	O
dom_text	pointer
=	O
realloc	function
(	O
dom_text	pointer
,	O
dom_file_stat	struct
.	O
st_size	long
)	O
;	O
if	O
(	O
dom_text	pointer
==	O
NULL	O
)	O
{	O
sprintf	function
(	O
buf	array
,	O
"%lu"	pointer
,	O
(	O
unsigned	O
long	O
)	O
dom_file_stat	struct
.	O
st_size	long
)	O
;	O
fserr	function
(	O
GNU_PW_MGR_EXIT_NO_MEM	int
,	O
"realloc"	pointer
,	O
buf	array
)	O
;	O
}	O
}	O
dom_entry	pointer
=	O
dom_text	pointer
+	O
dom_text_len	long
;	O
dom_text_len	long
+=	O
sprintf	function
(	O
dom_entry	pointer
,	O
dom_entry_fmt	array
,	O
cap_time	long
,	O
buf	array
)	O
;	O
}	O
}	O
static	O
void	O
proc_dom_opts	function
(	O
int	O
rem_arg_ct	int
)	O
{	O
int	O
ct	int
=	O
STACKCT_OPT	O
(	O
DOMAIN	O
)	O
;	O
char	O
const	O
*	O
*	O
dom_list	pointer
=	O
STACKLST_OPT	O
(	O
DOMAIN	O
)	O
;	O
bool	bool
list_doms	bool
=	O
false	int
;	O
bool	bool
new_entry	bool
=	O
false	int
;	O
dom_file_name	pointer
=	O
find_dom_file	function
(	O
)	O
;	O
dom_text	pointer
=	O
load_file	function
(	O
dom_file_name	pointer
)	O
;	O
do	O
{	O
char	O
const	O
*	O
dom	pointer
=	O
*	O
(	O
dom_list	pointer
++	O
)	O
;	O
if	O
(	O
(	O
*	O
dom	pointer
==	O
'-'	O
)	O
&&	O
(	O
dom	pointer
[	O
1	int
]	O
==	O
NUL	char
)	O
)	O
list_doms	bool
=	O
true	int
;	O
else	O
{	O
insert_domain	function
(	O
dom	pointer
)	O
;	O
new_entry	bool
=	O
true	int
;	O
}	O
}	O
while	O
(	O
--	O
ct	int
>	O
0	int
)	O
;	O
if	O
(	O
new_entry	bool
)	O
write_dom_file	function
(	O
)	O
;	O
if	O
(	O
list_doms	bool
)	O
list_domains	function
(	O
)	O
;	O
if	O
(	O
rem_arg_ct	int
<=	O
0	int
)	O
exit	function
(	O
GNU_PW_MGR_EXIT_SUCCESS	int
)	O
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
scribble_init	function
(	O
)	O
;	O
fix_options	function
(	O
&	O
argc	int
,	O
&	O
argv	pointer
)	O
;	O
{	O
int	O
ct	int
=	O
optionProcess	function
(	O
&	O
gnu_pw_mgrOptions	struct
,	O
argc	int
,	O
argv	pointer
)	O
;	O
argc	int
-=	O
ct	int
;	O
argv	pointer
+=	O
ct	int
;	O
}	O
if	O
(	O
gnu_pw_mgrOptions	struct
.	O
pOptDesc	pointer
[	O
INDEX_OPT_LOAD_OPTS	int
]	O
.	O
optOccCt	short
!=	O
1	int
)	O
die	function
(	O
GNU_PW_MGR_EXIT_INVALID	int
,	O
had_load_opts	O
)	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
DOMAIN	O
)	O
)	O
proc_dom_opts	function
(	O
argc	int
)	O
;	O
if	O
(	O
argc	int
>	O
0	int
)	O
{	O
char	O
const	O
*	O
arg	pointer
;	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
SEED	O
)	O
)	O
die	function
(	O
GNU_PW_MGR_EXIT_NO_SEED	int
,	O
no_seeds	O
)	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
TEXT	O
)	O
||	O
HAVE_OPT	O
(	O
TAG	O
)	O
)	O
usage_message	function
(	O
tag_pwid_conflict	O
)	O
;	O
if	O
(	O
argc	int
==	O
1	int
)	O
arg	pointer
=	O
*	O
argv	pointer
;	O
else	O
arg	pointer
=	O
assemble_arg	function
(	O
argc	int
,	O
argv	pointer
)	O
;	O
print_pwid	function
(	O
arg	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
TAG	O
)	O
)	O
{	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
DOMAIN	O
)	O
)	O
stdin_pwid	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
HAVE_OPT	O
(	O
TEXT	O
)	O
)	O
{	O
if	O
(	O
HAVE_OPT	O
(	O
SHARED	O
)	O
&&	O
!	O
ENABLED_OPT	O
(	O
SHARED	O
)	O
)	O
usage_message	function
(	O
disable_second	O
)	O
;	O
add_seed	function
(	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
HAVE_OPT	O
(	O
SHARED	O
)	O
)	O
usage_message	function
(	O
shared_removal	O
)	O
;	O
rm_seed	function
(	O
)	O
;	O
}	O
secure_cfg_file	function
(	O
)	O
;	O
scribble_deinit	function
(	O
)	O
;	O
return	O
GNU_PW_MGR_EXIT_SUCCESS	int
;	O
}	O
