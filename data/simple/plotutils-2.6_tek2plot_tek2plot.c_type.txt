const	O
char	O
*	O
progname	pointer
=	O
"tek2plot"	pointer
;	O
const	O
char	O
*	O
written	pointer
=	O
"Written by Robert S. Maier."	pointer
;	O
const	O
char	O
*	O
copyright	pointer
=	O
"Copyright (C) 2009 Free Software Foundation, Inc."	pointer
;	O
const	O
char	O
*	O
usage_appendage	pointer
=	O
" [FILE]...\nWith no FILE, or when FILE is -, read standard input.\n"	pointer
;	O
extern	O
int	O
Talptable	array
[	O
]	O
;	O
extern	O
int	O
Tbestable	array
[	O
]	O
;	O
extern	O
int	O
Tbyptable	array
[	O
]	O
;	O
extern	O
int	O
Tesctable	array
[	O
]	O
;	O
extern	O
int	O
Tipltable	array
[	O
]	O
;	O
extern	O
int	O
Tplttable	array
[	O
]	O
;	O
extern	O
int	O
Tpttable	array
[	O
]	O
;	O
extern	O
int	O
Tspttable	array
[	O
]	O
;	O
struct	O
Tek_Char	struct
{	O
int	O
hsize	int
;	O
int	O
vsize	int
;	O
int	O
charsperline	int
;	O
int	O
nlines	int
;	O
}	O
;	O
static	O
const	O
struct	O
Tek_Char	struct
TekChar	array
[	O
4	int
]	O
=	O
{	O
{	O
56	int
,	O
88	int
,	O
74	int
,	O
35	int
}	O
,	O
{	O
51	int
,	O
82	int
,	O
81	int
,	O
38	int
}	O
,	O
{	O
34	int
,	O
53	int
,	O
121	int
,	O
58	int
}	O
,	O
{	O
31	int
,	O
48	int
,	O
133	int
,	O
64	int
}	O
,	O
}	O
;	O
const	O
char	O
*	O
linemodes	array
[	O
8	int
]	O
=	O
{	O
"solid"	pointer
,	O
"dotted"	pointer
,	O
"dotdashed"	pointer
,	O
"shortdashed"	pointer
,	O
"longdashed"	pointer
,	O
"solid"	pointer
,	O
"solid"	pointer
,	O
"solid"	pointer
}	O
;	O
enum	O
{	O
PENDOWN	int
,	O
PENUP	int
}	O
;	O
enum	O
{	O
NORTH	int
=	O
04	int
,	O
SOUTH	int
=	O
010	int
,	O
EAST	int
=	O
01	int
,	O
WEST	int
=	O
02	int
}	O
;	O
const	O
char	O
*	O
optstring	pointer
=	O
"Op:F:W:T:"	pointer
;	O
struct	O
option	struct
long_options	array
[	O
]	O
=	O
{	O
{	O
"output-format"	pointer
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'T'	O
}	O
,	O
{	O
"display-type"	pointer
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'T'	O
<<	O
8	int
}	O
,	O
{	O
"bg-color"	pointer
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'q'	O
<<	O
8	int
}	O
,	O
{	O
"bitmap-size"	pointer
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'B'	O
<<	O
8	int
}	O
,	O
{	O
"emulate-color"	pointer
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'e'	O
<<	O
8	int
}	O
,	O
{	O
"font-name"	pointer
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'F'	O
}	O
,	O
{	O
"line-width"	pointer
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'W'	O
}	O
,	O
{	O
"pen-color"	pointer
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'C'	O
<<	O
8	int
}	O
,	O
{	O
"max-line-length"	pointer
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'M'	O
<<	O
8	int
}	O
,	O
{	O
"page-number"	pointer
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'p'	O
}	O
,	O
{	O
"page-size"	pointer
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'P'	O
<<	O
8	int
}	O
,	O
{	O
"position-chars"	pointer
,	O
ARG_NONE	int
,	O
NULL	O
,	O
'S'	O
<<	O
8	int
}	O
,	O
{	O
"rotation"	pointer
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'r'	O
<<	O
8	int
}	O
,	O
{	O
"use-tek-fonts"	pointer
,	O
ARG_NONE	int
,	O
NULL	O
,	O
't'	O
<<	O
8	int
}	O
,	O
{	O
"portable-output"	pointer
,	O
ARG_NONE	int
,	O
NULL	O
,	O
'O'	O
}	O
,	O
{	O
"help-fonts"	pointer
,	O
ARG_NONE	int
,	O
NULL	O
,	O
'f'	O
<<	O
8	int
}	O
,	O
{	O
"list-fonts"	pointer
,	O
ARG_NONE	int
,	O
NULL	O
,	O
'l'	O
<<	O
8	int
}	O
,	O
{	O
"version"	pointer
,	O
ARG_NONE	int
,	O
NULL	O
,	O
'V'	O
<<	O
8	int
}	O
,	O
{	O
"help"	pointer
,	O
ARG_NONE	int
,	O
NULL	O
,	O
'h'	O
<<	O
8	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
const	O
int	O
hidden_options	array
[	O
]	O
=	O
{	O
(	O
int	O
)	O
(	O
'T'	O
<<	O
8	int
)	O
,	O
0	int
}	O
;	O
typedef	O
struct	O
{	O
int	O
red	int
;	O
int	O
green	int
;	O
int	O
blue	int
;	O
}	O
Color	struct
;	O
const	O
Color	struct
ansi_color	array
[	O
16	int
]	O
=	O
{	O
{	O
0x0000	int
,	O
0x0000	int
,	O
0x0000	int
}	O
,	O
{	O
0x8b8b	int
,	O
0x0000	int
,	O
0x0000	int
}	O
,	O
{	O
0x0000	int
,	O
0x8b8b	int
,	O
0x0000	int
}	O
,	O
{	O
0x8b8b	int
,	O
0x8b8b	int
,	O
0x0000	int
}	O
,	O
{	O
0x0000	int
,	O
0x0000	int
,	O
0x8b8b	int
}	O
,	O
{	O
0x8b8b	int
,	O
0x0000	int
,	O
0x8b8b	int
}	O
,	O
{	O
0x0000	int
,	O
0x8b8b	int
,	O
0x8b8b	int
}	O
,	O
{	O
0x8b8b	int
,	O
0x8b8b	int
,	O
0x8b8b	int
}	O
,	O
{	O
0x4d4d	int
,	O
0x4d4d	int
,	O
0x4d4d	int
}	O
,	O
{	O
0xffff	int
,	O
0x0000	int
,	O
0x0000	int
}	O
,	O
{	O
0x0000	int
,	O
0xffff	int
,	O
0x0000	int
}	O
,	O
{	O
0xffff	int
,	O
0xffff	int
,	O
0x0000	int
}	O
,	O
{	O
0x0000	int
,	O
0x0000	int
,	O
0xffff	int
}	O
,	O
{	O
0xffff	int
,	O
0x0000	int
,	O
0xffff	int
}	O
,	O
{	O
0x0000	int
,	O
0xffff	int
,	O
0xffff	int
}	O
,	O
{	O
0xffff	int
,	O
0xffff	int
,	O
0xffff	int
}	O
}	O
;	O
bool	enum
position_indiv_chars	enum
=	O
false	int
;	O
bool	enum
single_page_is_requested	enum
=	O
false	int
;	O
bool	enum
use_tek_fonts	enum
=	O
false	int
;	O
bool	enum
force_hershey_default	enum
=	O
false	int
;	O
char	O
*	O
font_name	pointer
=	O
NULL	O
;	O
char	O
*	O
pen_color	pointer
=	O
NULL	O
;	O
double	O
line_width	double
=	O
-	O
1.0	int
;	O
int	O
requested_page	int
=	O
0	int
;	O
bool	enum
plotter_open	enum
=	O
false	int
;	O
bool	enum
plotter_opened	enum
=	O
false	int
;	O
int	O
cur_X	int
=	O
0	int
,	O
cur_Y	int
=	O
0	int
;	O
int	O
current_page	int
=	O
0	int
;	O
bool	enum
getpoint	function
(	O
int	O
*	O
xcoor	pointer
,	O
int	O
*	O
ycoor	pointer
,	O
FILE	struct
*	O
stream	pointer
,	O
int	O
*	O
badstatus	pointer
,	O
int	O
*	O
margin	pointer
)	O
;	O
bool	enum
read_plot	function
(	O
plPlotter	struct
*	O
plotter	pointer
,	O
FILE	struct
*	O
in_stream	pointer
)	O
;	O
int	O
read_byte	function
(	O
FILE	struct
*	O
stream	pointer
,	O
int	O
*	O
badstatus	pointer
)	O
;	O
void	O
begin_page	function
(	O
plPlotter	struct
*	O
plotter	pointer
)	O
;	O
void	O
end_page	function
(	O
plPlotter	struct
*	O
plotter	pointer
)	O
;	O
void	O
set_font_size	function
(	O
plPlotter	struct
*	O
plotter	pointer
,	O
int	O
new_fontsize	int
)	O
;	O
void	O
unread_byte	function
(	O
int	O
byte	int
,	O
FILE	struct
*	O
in_stream	pointer
,	O
int	O
*	O
badstatus	pointer
)	O
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
plPlotter	struct
*	O
plotter	pointer
;	O
plPlotterParams	struct
*	O
plotter_params	pointer
;	O
bool	enum
do_list_fonts	enum
=	O
false	int
;	O
bool	enum
show_fonts	enum
=	O
false	int
;	O
bool	enum
show_usage	enum
=	O
false	int
;	O
bool	enum
show_version	enum
=	O
false	int
;	O
char	O
*	O
output_format	pointer
=	O
(	O
char	O
*	O
)	O
"meta"	pointer
;	O
double	O
local_line_width	double
;	O
int	O
errcnt	int
=	O
0	int
;	O
int	O
local_page_number	int
;	O
int	O
opt_index	int
;	O
int	O
option	struct
;	O
int	O
retval	int
;	O
plotter_params	pointer
=	O
pl_newplparams	function
(	O
)	O
;	O
while	O
(	O
(	O
option	struct
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
optstring	pointer
,	O
long_options	array
,	O
&	O
opt_index	int
)	O
)	O
!=	O
EOF	O
)	O
{	O
if	O
(	O
option	struct
==	O
0	int
)	O
option	struct
=	O
long_options	array
[	O
opt_index	int
]	O
.	O
val	int
;	O
switch	O
(	O
option	struct
)	O
{	O
case	O
'T'	O
:	O
case	O
'T'	O
<<	O
8	int
:	O
output_format	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
strlen	function
(	O
optarg	pointer
)	O
+	O
1	int
)	O
;	O
strcpy	function
(	O
output_format	pointer
,	O
optarg	pointer
)	O
;	O
if	O
(	O
strcasecmp	function
(	O
output_format	pointer
,	O
"hpgl"	pointer
)	O
==	O
0	int
)	O
force_hershey_default	enum
=	O
true	int
;	O
else	O
force_hershey_default	enum
=	O
false	int
;	O
break	O
;	O
case	O
'F'	O
:	O
font_name	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
strlen	function
(	O
optarg	pointer
)	O
+	O
1	int
)	O
;	O
strcpy	function
(	O
font_name	pointer
,	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'p'	O
:	O
if	O
(	O
sscanf	function
(	O
optarg	pointer
,	O
"%d"	pointer
,	O
&	O
local_page_number	int
)	O
<=	O
0	int
||	O
local_page_number	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: error: the page number `%s' is bad (it should be a nonnegative integer)\n"	pointer
,	O
progname	pointer
,	O
optarg	pointer
)	O
;	O
errcnt	int
++	O
;	O
}	O
else	O
{	O
requested_page	int
=	O
local_page_number	int
;	O
single_page_is_requested	enum
=	O
true	int
;	O
}	O
break	O
;	O
case	O
'W'	O
:	O
if	O
(	O
sscanf	function
(	O
optarg	pointer
,	O
"%lf"	pointer
,	O
&	O
local_line_width	double
)	O
<=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: error: the line thickness `%s' is bad (it should be a number)\n"	pointer
,	O
progname	pointer
,	O
optarg	pointer
)	O
;	O
errcnt	int
++	O
;	O
break	O
;	O
}	O
if	O
(	O
local_line_width	double
<	O
0.0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: the request for a negative line thickness `%f' is disregarded\n"	pointer
,	O
progname	pointer
,	O
local_line_width	double
)	O
;	O
else	O
line_width	double
=	O
local_line_width	double
;	O
break	O
;	O
case	O
'O'	O
:	O
pl_setplparam	function
(	O
plotter_params	pointer
,	O
"META_PORTABLE"	pointer
,	O
(	O
void	O
*	O
)	O
"yes"	pointer
)	O
;	O
break	O
;	O
case	O
'e'	O
<<	O
8	int
:	O
pl_setplparam	function
(	O
plotter_params	pointer
,	O
"EMULATE_COLOR"	pointer
,	O
(	O
void	O
*	O
)	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'q'	O
<<	O
8	int
:	O
pl_setplparam	function
(	O
plotter_params	pointer
,	O
"BG_COLOR"	pointer
,	O
(	O
void	O
*	O
)	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'B'	O
<<	O
8	int
:	O
pl_setplparam	function
(	O
plotter_params	pointer
,	O
"BITMAPSIZE"	pointer
,	O
(	O
void	O
*	O
)	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'C'	O
<<	O
8	int
:	O
pen_color	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
strlen	function
(	O
optarg	pointer
)	O
+	O
1	int
)	O
;	O
strcpy	function
(	O
pen_color	pointer
,	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'M'	O
<<	O
8	int
:	O
pl_setplparam	function
(	O
plotter_params	pointer
,	O
"MAX_LINE_LENGTH"	pointer
,	O
(	O
void	O
*	O
)	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'P'	O
<<	O
8	int
:	O
pl_setplparam	function
(	O
plotter_params	pointer
,	O
"PAGESIZE"	pointer
,	O
(	O
void	O
*	O
)	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'S'	O
<<	O
8	int
:	O
position_indiv_chars	enum
=	O
true	int
;	O
break	O
;	O
case	O
'r'	O
<<	O
8	int
:	O
pl_setplparam	function
(	O
plotter_params	pointer
,	O
"ROTATION"	pointer
,	O
(	O
void	O
*	O
)	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
't'	O
<<	O
8	int
:	O
if	O
(	O
strcmp	function
(	O
output_format	pointer
,	O
"X"	pointer
)	O
==	O
0	int
)	O
use_tek_fonts	enum
=	O
true	int
;	O
break	O
;	O
case	O
'f'	O
<<	O
8	int
:	O
show_fonts	enum
=	O
true	int
;	O
break	O
;	O
case	O
'l'	O
<<	O
8	int
:	O
do_list_fonts	enum
=	O
true	int
;	O
break	O
;	O
case	O
'h'	O
<<	O
8	int
:	O
show_usage	enum
=	O
true	int
;	O
break	O
;	O
case	O
'V'	O
<<	O
8	int
:	O
show_version	enum
=	O
true	int
;	O
break	O
;	O
default	O
:	O
errcnt	int
++	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
errcnt	int
>	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Try `%s --help' for more information\n"	pointer
,	O
progname	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
if	O
(	O
show_version	enum
)	O
{	O
display_version	function
(	O
progname	pointer
,	O
written	pointer
,	O
copyright	pointer
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
}	O
if	O
(	O
do_list_fonts	enum
)	O
{	O
int	O
success	int
;	O
success	int
=	O
list_fonts	function
(	O
output_format	pointer
,	O
progname	pointer
)	O
;	O
if	O
(	O
success	int
)	O
return	O
EXIT_SUCCESS	int
;	O
else	O
return	O
EXIT_FAILURE	int
;	O
}	O
if	O
(	O
show_fonts	enum
)	O
{	O
int	O
success	int
;	O
success	int
=	O
display_fonts	function
(	O
output_format	pointer
,	O
progname	pointer
)	O
;	O
if	O
(	O
success	int
)	O
return	O
EXIT_SUCCESS	int
;	O
else	O
return	O
EXIT_FAILURE	int
;	O
}	O
if	O
(	O
show_usage	enum
)	O
{	O
display_usage	function
(	O
progname	pointer
,	O
hidden_options	array
,	O
usage_appendage	pointer
,	O
2	int
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
}	O
pl_setplparam	function
(	O
plotter_params	pointer
,	O
"GIF_ANIMATION"	pointer
,	O
(	O
void	O
*	O
)	O
"no"	pointer
)	O
;	O
if	O
(	O
(	O
plotter	pointer
=	O
pl_newpl_r	function
(	O
output_format	pointer
,	O
NULL	O
,	O
stdout	pointer
,	O
stderr	pointer
,	O
plotter_params	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: error: the plot device could not be created\n"	pointer
,	O
progname	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
retval	int
=	O
EXIT_SUCCESS	int
;	O
if	O
(	O
optind	int
<	O
argc	int
)	O
{	O
for	O
(	O
;	O
optind	int
<	O
argc	int
;	O
optind	int
++	O
)	O
{	O
FILE	struct
*	O
data_file	pointer
;	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
optind	int
]	O
,	O
"-"	pointer
)	O
==	O
0	int
)	O
data_file	pointer
=	O
stdin	pointer
;	O
else	O
{	O
data_file	pointer
=	O
fopen	function
(	O
argv	pointer
[	O
optind	int
]	O
,	O
"r"	pointer
)	O
;	O
if	O
(	O
data_file	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: %s: %s\n"	pointer
,	O
progname	pointer
,	O
argv	pointer
[	O
optind	int
]	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: this file is ignored.\n"	pointer
,	O
progname	pointer
)	O
;	O
errno	O
=	O
0	int
;	O
retval	int
=	O
EXIT_FAILURE	int
;	O
continue	O
;	O
}	O
}	O
if	O
(	O
read_plot	function
(	O
plotter	pointer
,	O
data_file	pointer
)	O
==	O
false	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: the input file `%s' could not be parsed\n"	pointer
,	O
progname	pointer
,	O
argv	pointer
[	O
optind	int
]	O
)	O
;	O
retval	int
=	O
EXIT_FAILURE	int
;	O
continue	O
;	O
}	O
if	O
(	O
data_file	pointer
!=	O
stdin	pointer
)	O
if	O
(	O
fclose	function
(	O
data_file	pointer
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: error: the input file `%s' could not be closed\n"	pointer
,	O
progname	pointer
,	O
argv	pointer
[	O
optind	int
]	O
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
read_plot	function
(	O
plotter	pointer
,	O
stdin	pointer
)	O
==	O
false	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: the input could not be parsed\n"	pointer
,	O
progname	pointer
)	O
;	O
retval	int
=	O
EXIT_FAILURE	int
;	O
}	O
}	O
if	O
(	O
plotter_opened	enum
==	O
false	int
)	O
{	O
if	O
(	O
single_page_is_requested	enum
==	O
false	int
)	O
{	O
begin_page	function
(	O
plotter	pointer
)	O
;	O
end_page	function
(	O
plotter	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
requested_page	int
>=	O
current_page	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: the requested page does not exist\n"	pointer
,	O
progname	pointer
)	O
;	O
retval	int
=	O
EXIT_FAILURE	int
;	O
}	O
else	O
{	O
begin_page	function
(	O
plotter	pointer
)	O
;	O
end_page	function
(	O
plotter	pointer
)	O
;	O
}	O
}	O
}	O
if	O
(	O
pl_deletepl_r	function
(	O
plotter	pointer
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: error: the plot device could not be deleted\n"	pointer
,	O
progname	pointer
)	O
;	O
retval	int
=	O
EXIT_FAILURE	int
;	O
}	O
pl_deleteplparams	function
(	O
plotter_params	pointer
)	O
;	O
return	O
retval	int
;	O
}	O
void	O
unread_byte	function
(	O
int	O
c	int
,	O
FILE	struct
*	O
in_stream	pointer
,	O
int	O
*	O
badstatus	pointer
)	O
{	O
if	O
(	O
*	O
badstatus	pointer
==	O
0	int
)	O
{	O
if	O
(	O
ungetc	function
(	O
c	int
,	O
in_stream	pointer
)	O
==	O
EOF	O
)	O
*	O
badstatus	pointer
=	O
2	int
;	O
}	O
}	O
int	O
read_byte	function
(	O
FILE	struct
*	O
in_stream	pointer
,	O
int	O
*	O
badstatus	pointer
)	O
{	O
int	O
i	int
;	O
if	O
(	O
*	O
badstatus	pointer
==	O
1	int
)	O
return	O
0	int
;	O
i	int
=	O
getc	function
(	O
in_stream	pointer
)	O
;	O
if	O
(	O
i	int
==	O
EOF	O
)	O
{	O
*	O
badstatus	pointer
=	O
2	int
;	O
return	O
0	int
;	O
}	O
return	O
(	O
i	int
&	O
0x7f	int
)	O
;	O
}	O
bool	enum
getpoint	function
(	O
int	O
*	O
xcoor	pointer
,	O
int	O
*	O
ycoor	pointer
,	O
FILE	struct
*	O
in_stream	pointer
,	O
int	O
*	O
badstatus	pointer
,	O
int	O
*	O
margin	pointer
)	O
{	O
int	O
status_one	int
=	O
0	int
,	O
status_three	int
=	O
0	int
;	O
bool	enum
got_lo_y	enum
=	O
false	int
;	O
bool	enum
got_hi_x	enum
=	O
false	int
,	O
got_hi_y	enum
=	O
false	int
;	O
int	O
lo_x	int
=	O
0	int
,	O
lo_y	int
=	O
0	int
,	O
hi_x	int
=	O
0	int
,	O
hi_y	int
=	O
0	int
;	O
bool	enum
got_egm	enum
=	O
false	int
;	O
int	O
egm	int
=	O
0	int
;	O
int	O
temp_three	int
=	O
0	int
;	O
static	O
int	O
saved_lo_y	int
=	O
0	int
,	O
saved_hi_x	int
=	O
0	int
,	O
saved_hi_y	int
=	O
0	int
;	O
static	O
bool	enum
margin_reset	enum
=	O
false	int
;	O
int	O
byte_read	int
,	O
type	pointer
;	O
if	O
(	O
*	O
badstatus	pointer
)	O
return	O
false	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
byte_read	int
=	O
read_byte	function
(	O
in_stream	pointer
,	O
badstatus	pointer
)	O
;	O
if	O
(	O
*	O
badstatus	pointer
)	O
return	O
false	int
;	O
type	pointer
=	O
(	O
byte_read	int
>>	O
5	int
)	O
&	O
TWO_BITS	O
;	O
byte_read	int
&=	O
FIVE_BITS	O
;	O
switch	O
(	O
type	pointer
)	O
{	O
case	O
0	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: an incomplete point in the input is ignored\n"	pointer
,	O
progname	pointer
)	O
;	O
if	O
(	O
byte_read	int
==	O
'\n'	O
||	O
byte_read	int
==	O
'\r'	O
||	O
byte_read	int
==	O
'\0'	O
)	O
continue	O
;	O
else	O
unread_byte	function
(	O
byte_read	int
,	O
in_stream	pointer
,	O
badstatus	pointer
)	O
;	O
return	O
false	int
;	O
case	O
1	int
:	O
switch	O
(	O
status_one	int
)	O
{	O
case	O
0	int
:	O
if	O
(	O
status_three	int
)	O
{	O
hi_x	int
=	O
byte_read	int
;	O
got_hi_x	enum
=	O
true	int
;	O
if	O
(	O
status_three	int
==	O
1	int
)	O
{	O
lo_y	int
=	O
temp_three	int
;	O
got_lo_y	enum
=	O
true	int
;	O
}	O
status_one	int
=	O
2	int
;	O
status_three	int
=	O
2	int
;	O
}	O
else	O
{	O
hi_y	int
=	O
byte_read	int
;	O
got_hi_y	enum
=	O
true	int
;	O
status_one	int
=	O
1	int
;	O
}	O
break	O
;	O
case	O
1	int
:	O
if	O
(	O
status_three	int
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: error: a point in the input has Hi_Y, Hi_X bytes with no Lo_Y between\n"	pointer
,	O
progname	pointer
)	O
;	O
*	O
badstatus	pointer
=	O
1	int
;	O
return	O
false	int
;	O
}	O
if	O
(	O
status_three	int
==	O
1	int
)	O
{	O
lo_y	int
=	O
temp_three	int
;	O
got_lo_y	enum
=	O
true	int
;	O
}	O
hi_x	int
=	O
byte_read	int
;	O
got_hi_x	enum
=	O
true	int
;	O
status_one	int
=	O
2	int
;	O
status_three	int
=	O
2	int
;	O
break	O
;	O
case	O
2	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: error: a point in the input contains too many Hi_Y/Hi_X bytes\n"	pointer
,	O
progname	pointer
)	O
;	O
*	O
badstatus	pointer
=	O
1	int
;	O
return	O
false	int
;	O
}	O
break	O
;	O
case	O
3	int
:	O
switch	O
(	O
status_three	int
)	O
{	O
case	O
0	int
:	O
if	O
(	O
status_one	int
==	O
2	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: error: a point in the input has an EGM/Lo_Y byte after 2 Hi_X/Hi_Y bytes\n"	pointer
,	O
progname	pointer
)	O
;	O
*	O
badstatus	pointer
=	O
1	int
;	O
return	O
false	int
;	O
}	O
else	O
{	O
temp_three	int
=	O
byte_read	int
;	O
status_three	int
=	O
1	int
;	O
}	O
break	O
;	O
case	O
1	int
:	O
if	O
(	O
status_one	int
==	O
2	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: error: a point in the input has an EGM/Lo_Y byte after 2 Hi_X/Hi_Y bytes\n"	pointer
,	O
progname	pointer
)	O
;	O
*	O
badstatus	pointer
=	O
1	int
;	O
return	O
false	int
;	O
}	O
egm	int
=	O
temp_three	int
;	O
got_egm	enum
=	O
true	int
;	O
lo_y	int
=	O
byte_read	int
;	O
got_lo_y	enum
=	O
true	int
;	O
status_three	int
=	O
2	int
;	O
break	O
;	O
case	O
2	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: error: a point in the input has too many EGM/Lo_Y bytes\n"	pointer
,	O
progname	pointer
)	O
;	O
*	O
badstatus	pointer
=	O
1	int
;	O
return	O
false	int
;	O
}	O
break	O
;	O
case	O
2	int
:	O
{	O
int	O
low_res_x	int
,	O
low_res_y	int
;	O
int	O
x	int
,	O
y	int
;	O
if	O
(	O
status_three	int
==	O
1	int
)	O
{	O
lo_y	int
=	O
temp_three	int
;	O
got_lo_y	enum
=	O
true	int
;	O
}	O
lo_x	int
=	O
byte_read	int
;	O
lo_y	int
=	O
got_lo_y	enum
?	O
lo_y	int
:	O
saved_lo_y	int
;	O
hi_x	int
=	O
got_hi_x	enum
?	O
hi_x	int
:	O
saved_hi_x	int
;	O
hi_y	int
=	O
got_hi_y	enum
?	O
hi_y	int
:	O
saved_hi_y	int
;	O
saved_lo_y	int
=	O
lo_y	int
;	O
saved_hi_x	int
=	O
hi_x	int
;	O
saved_hi_y	int
=	O
hi_y	int
;	O
if	O
(	O
(	O
egm	int
>>	O
4	int
)	O
&	O
ONE_BIT	O
)	O
{	O
*	O
margin	pointer
=	O
MARGIN2	int
;	O
if	O
(	O
margin_reset	enum
==	O
false	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: the left margin of the Tektronix was reset by the input\n"	pointer
,	O
progname	pointer
)	O
;	O
margin_reset	enum
=	O
true	int
;	O
}	O
low_res_x	int
=	O
(	O
hi_x	int
<<	O
5	int
)	O
|	O
lo_x	int
;	O
low_res_y	int
=	O
(	O
hi_y	int
<<	O
5	int
)	O
|	O
lo_y	int
;	O
x	int
=	O
(	O
low_res_x	int
<<	O
2	int
)	O
|	O
(	O
egm	int
&	O
TWO_BITS	O
)	O
;	O
y	int
=	O
(	O
low_res_y	int
<<	O
2	int
)	O
|	O
(	O
(	O
egm	int
>>	O
2	int
)	O
&	O
TWO_BITS	O
)	O
;	O
*	O
xcoor	pointer
=	O
x	int
;	O
*	O
ycoor	pointer
=	O
y	int
;	O
return	O
true	int
;	O
}	O
}	O
}	O
}	O
bool	enum
read_plot	function
(	O
plPlotter	struct
*	O
plotter	pointer
,	O
FILE	struct
*	O
in_stream	pointer
)	O
{	O
int	O
*	O
Tparsestate	pointer
=	O
Talptable	array
;	O
int	O
*	O
curstate	pointer
=	O
Talptable	array
;	O
int	O
pen	int
=	O
PENUP	int
;	O
int	O
linetype	int
=	O
0	int
;	O
int	O
fontsize	int
=	O
0	int
;	O
int	O
margin	pointer
=	O
MARGIN1	int
;	O
char	O
text	array
[	O
TEXT_BUFFER_SIZE	int
]	O
;	O
int	O
badstatus	pointer
=	O
0	int
;	O
while	O
(	O
!	O
badstatus	pointer
)	O
{	O
int	O
c	int
;	O
int	O
x	int
,	O
y	int
;	O
c	int
=	O
read_byte	function
(	O
in_stream	pointer
,	O
&	O
badstatus	pointer
)	O
;	O
if	O
(	O
badstatus	pointer
)	O
break	O
;	O
switch	O
(	O
Tparsestate	pointer
[	O
c	int
]	O
)	O
{	O
case	O
CASE_ALP_STATE	O
:	O
Tparsestate	pointer
=	O
curstate	pointer
=	O
Talptable	array
;	O
break	O
;	O
case	O
CASE_PLT_STATE	O
:	O
Tparsestate	pointer
=	O
curstate	pointer
=	O
Tplttable	array
;	O
c	int
=	O
read_byte	function
(	O
in_stream	pointer
,	O
&	O
badstatus	pointer
)	O
;	O
if	O
(	O
c	int
==	O
BEL	int
)	O
pen	int
=	O
PENDOWN	int
;	O
else	O
{	O
pen	int
=	O
PENUP	int
;	O
unread_byte	function
(	O
c	int
,	O
in_stream	pointer
,	O
&	O
badstatus	pointer
)	O
;	O
}	O
break	O
;	O
case	O
CASE_PT_STATE	O
:	O
Tparsestate	pointer
=	O
curstate	pointer
=	O
Tpttable	array
;	O
break	O
;	O
case	O
CASE_SPT_STATE	O
:	O
Tparsestate	pointer
=	O
curstate	pointer
=	O
Tspttable	array
;	O
break	O
;	O
case	O
CASE_IPL_STATE	O
:	O
Tparsestate	pointer
=	O
curstate	pointer
=	O
Tipltable	array
;	O
break	O
;	O
case	O
CASE_PRINT	O
:	O
{	O
char	O
*	O
cp	pointer
=	O
text	array
;	O
int	O
x_here	int
,	O
y_here	int
,	O
n	int
;	O
x_here	int
=	O
cur_X	int
,	O
y_here	int
=	O
cur_Y	int
;	O
unread_byte	function
(	O
c	int
,	O
in_stream	pointer
,	O
&	O
badstatus	pointer
)	O
;	O
if	O
(	O
badstatus	pointer
)	O
break	O
;	O
n	int
=	O
(	O
position_indiv_chars	enum
?	O
1	int
:	O
TEXT_BUFFER_SIZE	int
-	O
1	int
)	O
;	O
y	int
=	O
cur_Y	int
;	O
while	O
(	O
!	O
badstatus	pointer
&&	O
n	int
--	O
>	O
0	int
&&	O
y	int
==	O
cur_Y	int
)	O
{	O
c	int
=	O
read_byte	function
(	O
in_stream	pointer
,	O
&	O
badstatus	pointer
)	O
;	O
if	O
(	O
badstatus	pointer
)	O
{	O
break	O
;	O
}	O
if	O
(	O
!	O
PRINTABLE_ASCII	O
(	O
c	int
)	O
)	O
{	O
unread_byte	function
(	O
c	int
,	O
in_stream	pointer
,	O
&	O
badstatus	pointer
)	O
;	O
break	O
;	O
}	O
*	O
cp	pointer
++	O
=	O
c	int
;	O
{	O
const	O
struct	O
Tek_Char	struct
*	O
t	pointer
=	O
&	O
TekChar	array
[	O
fontsize	int
]	O
;	O
int	O
l	int
;	O
cur_X	int
+=	O
t	pointer
->	O
hsize	int
;	O
if	O
(	O
cur_X	int
>	O
TEK_WIDTH	int
)	O
{	O
l	int
=	O
cur_Y	int
/	O
t	pointer
->	O
vsize	int
-	O
1	int
;	O
if	O
(	O
l	int
<	O
0	int
)	O
{	O
margin	pointer
=	O
!	O
margin	pointer
;	O
l	int
=	O
t	pointer
->	O
nlines	int
-	O
1	int
;	O
}	O
cur_Y	int
=	O
l	int
*	O
t	pointer
->	O
vsize	int
;	O
cur_X	int
=	O
(	O
margin	pointer
==	O
MARGIN1	int
?	O
0	int
:	O
TEK_WIDTH	int
/	O
2	int
)	O
;	O
}	O
}	O
}	O
*	O
cp	pointer
=	O
'\0'	O
;	O
if	O
(	O
current_page	int
==	O
requested_page	int
||	O
!	O
single_page_is_requested	enum
)	O
{	O
if	O
(	O
plotter_open	enum
==	O
false	int
)	O
begin_page	function
(	O
plotter	pointer
)	O
;	O
if	O
(	O
position_indiv_chars	enum
)	O
{	O
int	O
halfwidth	int
=	O
TekChar	array
[	O
fontsize	int
]	O
.	O
hsize	int
/	O
2	int
;	O
pl_move_r	function
(	O
plotter	pointer
,	O
x_here	int
+	O
halfwidth	int
,	O
y_here	int
+	O
YOFFSET	int
)	O
;	O
pl_alabel_r	function
(	O
plotter	pointer
,	O
'c'	O
,	O
'b'	O
,	O
text	array
)	O
;	O
}	O
else	O
{	O
pl_move_r	function
(	O
plotter	pointer
,	O
x_here	int
,	O
y_here	int
+	O
YOFFSET	int
)	O
;	O
pl_alabel_r	function
(	O
plotter	pointer
,	O
'l'	O
,	O
'b'	O
,	O
text	array
)	O
;	O
}	O
pl_move_r	function
(	O
plotter	pointer
,	O
cur_X	int
,	O
cur_Y	int
)	O
;	O
}	O
}	O
break	O
;	O
case	O
CASE_PLT_VEC	O
:	O
unread_byte	function
(	O
c	int
,	O
in_stream	pointer
,	O
&	O
badstatus	pointer
)	O
;	O
if	O
(	O
getpoint	function
(	O
&	O
x	int
,	O
&	O
y	int
,	O
in_stream	pointer
,	O
&	O
badstatus	pointer
,	O
&	O
margin	pointer
)	O
&&	O
!	O
badstatus	pointer
)	O
{	O
if	O
(	O
current_page	int
==	O
requested_page	int
||	O
!	O
single_page_is_requested	enum
)	O
{	O
if	O
(	O
pen	int
==	O
PENDOWN	int
)	O
{	O
if	O
(	O
plotter_open	enum
==	O
false	int
)	O
begin_page	function
(	O
plotter	pointer
)	O
;	O
pl_cont_r	function
(	O
plotter	pointer
,	O
x	int
,	O
y	int
+	O
YOFFSET	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
plotter_open	enum
==	O
true	int
)	O
pl_move_r	function
(	O
plotter	pointer
,	O
x	int
,	O
y	int
+	O
YOFFSET	int
)	O
;	O
}	O
}	O
cur_X	int
=	O
x	int
;	O
cur_Y	int
=	O
y	int
;	O
pen	int
=	O
PENDOWN	int
;	O
}	O
break	O
;	O
case	O
CASE_PT_POINT	O
:	O
unread_byte	function
(	O
c	int
,	O
in_stream	pointer
,	O
&	O
badstatus	pointer
)	O
;	O
if	O
(	O
getpoint	function
(	O
&	O
x	int
,	O
&	O
y	int
,	O
in_stream	pointer
,	O
&	O
badstatus	pointer
,	O
&	O
margin	pointer
)	O
&&	O
!	O
badstatus	pointer
)	O
{	O
if	O
(	O
current_page	int
==	O
requested_page	int
||	O
!	O
single_page_is_requested	enum
)	O
{	O
if	O
(	O
plotter_open	enum
==	O
false	int
)	O
begin_page	function
(	O
plotter	pointer
)	O
;	O
pl_fmarker_r	function
(	O
plotter	pointer
,	O
(	O
double	O
)	O
x	int
,	O
(	O
double	O
)	O
(	O
y	int
+	O
YOFFSET	int
)	O
,	O
M_DOT	int
,	O
(	O
double	O
)	O
DOT_SIZE	int
)	O
;	O
}	O
cur_X	int
=	O
x	int
;	O
cur_Y	int
=	O
y	int
;	O
}	O
break	O
;	O
case	O
CASE_SPT_POINT	O
:	O
if	O
(	O
getpoint	function
(	O
&	O
x	int
,	O
&	O
y	int
,	O
in_stream	pointer
,	O
&	O
badstatus	pointer
,	O
&	O
margin	pointer
)	O
&&	O
!	O
badstatus	pointer
)	O
{	O
if	O
(	O
current_page	int
==	O
requested_page	int
||	O
!	O
single_page_is_requested	enum
)	O
{	O
if	O
(	O
plotter_open	enum
==	O
false	int
)	O
begin_page	function
(	O
plotter	pointer
)	O
;	O
pl_fmarker_r	function
(	O
plotter	pointer
,	O
(	O
double	O
)	O
x	int
,	O
(	O
double	O
)	O
(	O
y	int
+	O
YOFFSET	int
)	O
,	O
M_DOT	int
,	O
(	O
double	O
)	O
(	O
DOT_SIZE	int
)	O
)	O
;	O
}	O
cur_X	int
=	O
x	int
;	O
cur_Y	int
=	O
y	int
;	O
}	O
break	O
;	O
case	O
CASE_PENUP	O
:	O
pen	int
=	O
PENUP	int
;	O
break	O
;	O
case	O
CASE_PENDOWN	O
:	O
pen	int
=	O
PENDOWN	int
;	O
break	O
;	O
case	O
CASE_IPL_POINT	O
:	O
x	int
=	O
cur_X	int
;	O
y	int
=	O
cur_Y	int
;	O
if	O
(	O
c	int
&	O
NORTH	int
)	O
y	int
++	O
;	O
else	O
if	O
(	O
c	int
&	O
SOUTH	int
)	O
y	int
--	O
;	O
if	O
(	O
c	int
&	O
EAST	int
)	O
x	int
++	O
;	O
else	O
if	O
(	O
c	int
&	O
WEST	int
)	O
x	int
--	O
;	O
if	O
(	O
current_page	int
==	O
requested_page	int
||	O
!	O
single_page_is_requested	enum
)	O
{	O
if	O
(	O
pen	int
==	O
PENDOWN	int
)	O
{	O
if	O
(	O
plotter_open	enum
==	O
false	int
)	O
begin_page	function
(	O
plotter	pointer
)	O
;	O
pl_cont_r	function
(	O
plotter	pointer
,	O
x	int
,	O
y	int
+	O
YOFFSET	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
plotter_open	enum
==	O
true	int
)	O
pl_move_r	function
(	O
plotter	pointer
,	O
x	int
,	O
y	int
+	O
YOFFSET	int
)	O
;	O
}	O
}	O
cur_X	int
=	O
x	int
;	O
cur_Y	int
=	O
y	int
;	O
break	O
;	O
case	O
CASE_BES_STATE	O
:	O
Tparsestate	pointer
=	O
Tbestable	array
;	O
break	O
;	O
case	O
CASE_BYP_STATE	O
:	O
Tparsestate	pointer
=	O
Tbyptable	array
;	O
break	O
;	O
case	O
CASE_ESC_STATE	O
:	O
Tparsestate	pointer
=	O
Tesctable	array
;	O
break	O
;	O
case	O
CASE_CR	O
:	O
cur_X	int
=	O
(	O
margin	pointer
==	O
MARGIN1	int
?	O
0	int
:	O
TEK_WIDTH	int
/	O
2	int
)	O
;	O
Tparsestate	pointer
=	O
curstate	pointer
=	O
Talptable	array
;	O
break	O
;	O
case	O
CASE_BS	O
:	O
Tparsestate	pointer
=	O
curstate	pointer
;	O
{	O
const	O
struct	O
Tek_Char	struct
*	O
t	pointer
;	O
int	O
x	int
,	O
l	int
;	O
x	int
=	O
(	O
cur_X	int
-=	O
(	O
t	pointer
=	O
&	O
TekChar	array
[	O
fontsize	int
]	O
)	O
->	O
hsize	int
)	O
;	O
if	O
(	O
(	O
margin	pointer
==	O
MARGIN1	int
&&	O
x	int
<	O
0	int
)	O
||	O
(	O
margin	pointer
==	O
MARGIN2	int
&&	O
x	int
<	O
TEK_WIDTH	int
/	O
2	int
)	O
)	O
{	O
if	O
(	O
(	O
l	int
=	O
(	O
cur_Y	int
+	O
(	O
t	pointer
->	O
vsize	int
-	O
1	int
)	O
)	O
/	O
t	pointer
->	O
vsize	int
+	O
1	int
)	O
>=	O
t	pointer
->	O
nlines	int
)	O
{	O
margin	pointer
=	O
!	O
margin	pointer
;	O
l	int
=	O
0	int
;	O
}	O
cur_Y	int
=	O
l	int
*	O
t	pointer
->	O
vsize	int
;	O
cur_X	int
=	O
(	O
t	pointer
->	O
charsperline	int
-	O
1	int
)	O
*	O
t	pointer
->	O
hsize	int
;	O
}	O
}	O
break	O
;	O
case	O
CASE_TAB	O
:	O
Tparsestate	pointer
=	O
curstate	pointer
;	O
case	O
CASE_SP	O
:	O
{	O
const	O
struct	O
Tek_Char	struct
*	O
t	pointer
=	O
&	O
TekChar	array
[	O
fontsize	int
]	O
;	O
int	O
l	int
;	O
cur_X	int
+=	O
t	pointer
->	O
hsize	int
;	O
if	O
(	O
cur_X	int
>	O
TEK_WIDTH	int
)	O
{	O
l	int
=	O
cur_Y	int
/	O
t	pointer
->	O
vsize	int
-	O
1	int
;	O
if	O
(	O
l	int
<	O
0	int
)	O
{	O
margin	pointer
=	O
!	O
margin	pointer
;	O
l	int
=	O
t	pointer
->	O
nlines	int
-	O
1	int
;	O
}	O
cur_Y	int
=	O
l	int
*	O
t	pointer
->	O
vsize	int
;	O
cur_X	int
=	O
(	O
margin	pointer
==	O
MARGIN1	int
?	O
0	int
:	O
TEK_WIDTH	int
/	O
2	int
)	O
;	O
}	O
}	O
break	O
;	O
case	O
CASE_LF	O
:	O
{	O
const	O
struct	O
Tek_Char	struct
*	O
t	pointer
;	O
int	O
l	int
;	O
t	pointer
=	O
&	O
TekChar	array
[	O
fontsize	int
]	O
;	O
if	O
(	O
(	O
l	int
=	O
cur_Y	int
/	O
t	pointer
->	O
vsize	int
-	O
1	int
)	O
<	O
0	int
)	O
{	O
l	int
=	O
t	pointer
->	O
nlines	int
-	O
1	int
;	O
if	O
(	O
(	O
margin	pointer
=	O
!	O
margin	pointer
)	O
!=	O
MARGIN1	int
)	O
{	O
if	O
(	O
cur_X	int
<	O
TEK_WIDTH	int
/	O
2	int
)	O
cur_X	int
+=	O
TEK_WIDTH	int
/	O
2	int
;	O
}	O
else	O
if	O
(	O
cur_X	int
>=	O
TEK_WIDTH	int
/	O
2	int
)	O
cur_X	int
-=	O
TEK_WIDTH	int
/	O
2	int
;	O
}	O
cur_Y	int
=	O
l	int
*	O
t	pointer
->	O
vsize	int
;	O
}	O
break	O
;	O
case	O
CASE_UP	O
:	O
Tparsestate	pointer
=	O
curstate	pointer
;	O
{	O
const	O
struct	O
Tek_Char	struct
*	O
t	pointer
;	O
int	O
l	int
;	O
t	pointer
=	O
&	O
TekChar	array
[	O
fontsize	int
]	O
;	O
if	O
(	O
(	O
l	int
=	O
(	O
cur_Y	int
+	O
(	O
t	pointer
->	O
vsize	int
-	O
1	int
)	O
)	O
/	O
t	pointer
->	O
vsize	int
+	O
1	int
)	O
>=	O
t	pointer
->	O
nlines	int
)	O
{	O
l	int
=	O
0	int
;	O
if	O
(	O
(	O
margin	pointer
=	O
!	O
margin	pointer
)	O
!=	O
MARGIN1	int
)	O
{	O
if	O
(	O
cur_X	int
<	O
TEK_WIDTH	int
/	O
2	int
)	O
cur_X	int
+=	O
TEK_WIDTH	int
/	O
2	int
;	O
}	O
else	O
if	O
(	O
cur_X	int
>=	O
TEK_WIDTH	int
/	O
2	int
)	O
cur_X	int
-=	O
TEK_WIDTH	int
/	O
2	int
;	O
}	O
cur_Y	int
=	O
l	int
*	O
t	pointer
->	O
vsize	int
;	O
}	O
break	O
;	O
case	O
CASE_PAGE	O
:	O
if	O
(	O
plotter_open	enum
==	O
true	int
)	O
end_page	function
(	O
plotter	pointer
)	O
;	O
if	O
(	O
single_page_is_requested	enum
&&	O
current_page	int
==	O
requested_page	int
)	O
{	O
badstatus	pointer
=	O
2	int
;	O
break	O
;	O
}	O
current_page	int
++	O
;	O
if	O
(	O
single_page_is_requested	enum
&&	O
current_page	int
==	O
requested_page	int
)	O
{	O
if	O
(	O
linetype	int
!=	O
0	int
)	O
{	O
if	O
(	O
plotter_open	enum
==	O
false	int
)	O
begin_page	function
(	O
plotter	pointer
)	O
;	O
pl_linemod_r	function
(	O
plotter	pointer
,	O
linemodes	array
[	O
linetype	int
]	O
)	O
;	O
}	O
if	O
(	O
fontsize	int
!=	O
0	int
)	O
{	O
if	O
(	O
plotter_open	enum
==	O
false	int
)	O
begin_page	function
(	O
plotter	pointer
)	O
;	O
set_font_size	function
(	O
plotter	pointer
,	O
fontsize	int
)	O
;	O
}	O
}	O
cur_X	int
=	O
0	int
;	O
cur_Y	int
=	O
TEKHOME	O
;	O
break	O
;	O
case	O
CASE_CHAR_SIZE	O
:	O
fontsize	int
=	O
c	int
&	O
03	int
;	O
if	O
(	O
current_page	int
==	O
requested_page	int
||	O
!	O
single_page_is_requested	enum
)	O
{	O
if	O
(	O
plotter_open	enum
==	O
false	int
)	O
begin_page	function
(	O
plotter	pointer
)	O
;	O
set_font_size	function
(	O
plotter	pointer
,	O
fontsize	int
)	O
;	O
}	O
Tparsestate	pointer
=	O
curstate	pointer
;	O
break	O
;	O
case	O
CASE_BEAM_VEC	O
:	O
c	int
&=	O
07	int
;	O
if	O
(	O
c	int
!=	O
linetype	int
)	O
if	O
(	O
current_page	int
==	O
requested_page	int
||	O
!	O
single_page_is_requested	enum
)	O
{	O
if	O
(	O
plotter_open	enum
==	O
false	int
)	O
begin_page	function
(	O
plotter	pointer
)	O
;	O
linetype	int
=	O
c	int
;	O
pl_linemod_r	function
(	O
plotter	pointer
,	O
linemodes	array
[	O
linetype	int
]	O
)	O
;	O
}	O
Tparsestate	pointer
=	O
curstate	pointer
;	O
break	O
;	O
case	O
CASE_OSC	O
:	O
do	O
c	int
=	O
read_byte	function
(	O
in_stream	pointer
,	O
&	O
badstatus	pointer
)	O
;	O
while	O
(	O
!	O
badstatus	pointer
&&	O
PRINTABLE_ASCII	O
(	O
c	int
)	O
)	O
;	O
Tparsestate	pointer
=	O
curstate	pointer
;	O
break	O
;	O
case	O
CASE_ANSI	O
:	O
{	O
char	O
ansi	array
[	O
BUFFER_SIZE	int
]	O
;	O
char	O
type	pointer
=	O
0	int
;	O
int	O
i	int
;	O
i	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
c	int
=	O
read_byte	function
(	O
in_stream	pointer
,	O
&	O
badstatus	pointer
)	O
;	O
if	O
(	O
badstatus	pointer
)	O
break	O
;	O
if	O
(	O
(	O
c	int
>=	O
'0'	O
&&	O
c	int
<=	O
'9'	O
)	O
||	O
c	int
==	O
';'	O
||	O
(	O
i	int
==	O
0	int
&&	O
c	int
==	O
'?'	O
)	O
)	O
ansi	array
[	O
i	int
++	O
]	O
=	O
c	int
;	O
else	O
{	O
type	pointer
=	O
c	int
;	O
if	O
(	O
!	O
(	O
PRINTABLE_ASCII	O
(	O
type	pointer
)	O
)	O
)	O
badstatus	pointer
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
i	int
==	O
BUFFER_SIZE	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: error: an overly long ANSI escape sequence was encountered\n"	pointer
,	O
progname	pointer
)	O
;	O
badstatus	pointer
=	O
1	int
;	O
break	O
;	O
}	O
}	O
Tparsestate	pointer
=	O
curstate	pointer
;	O
if	O
(	O
badstatus	pointer
)	O
break	O
;	O
if	O
(	O
i	int
==	O
3	int
&&	O
(	O
type	pointer
==	O
'h'	O
||	O
type	pointer
==	O
'l'	O
)	O
&&	O
(	O
ansi	array
[	O
0	int
]	O
==	O
'?'	O
&&	O
ansi	array
[	O
1	int
]	O
==	O
'3'	O
&&	O
ansi	array
[	O
2	int
]	O
==	O
'8'	O
)	O
)	O
break	O
;	O
if	O
(	O
i	int
==	O
4	int
&&	O
type	pointer
==	O
'm'	O
&&	O
(	O
ansi	array
[	O
0	int
]	O
==	O
'0'	O
||	O
ansi	array
[	O
0	int
]	O
==	O
'1'	O
)	O
&&	O
ansi	array
[	O
1	int
]	O
==	O
';'	O
&&	O
ansi	array
[	O
2	int
]	O
==	O
'3'	O
&&	O
ansi	array
[	O
3	int
]	O
>=	O
'0'	O
&&	O
ansi	array
[	O
3	int
]	O
<=	O
'7'	O
)	O
{	O
int	O
intensity	int
,	O
color_index	int
;	O
if	O
(	O
plotter_open	enum
==	O
false	int
)	O
begin_page	function
(	O
plotter	pointer
)	O
;	O
intensity	int
=	O
ansi	array
[	O
0	int
]	O
-	O
'0'	O
;	O
color_index	int
=	O
ansi	array
[	O
3	int
]	O
-	O
'0'	O
;	O
pl_pencolor_r	function
(	O
plotter	pointer
,	O
ansi_color	array
[	O
8	int
*	O
intensity	int
+	O
color_index	int
]	O
.	O
red	int
,	O
ansi_color	array
[	O
8	int
*	O
intensity	int
+	O
color_index	int
]	O
.	O
green	int
,	O
ansi_color	array
[	O
8	int
*	O
intensity	int
+	O
color_index	int
]	O
.	O
blue	int
)	O
;	O
break	O
;	O
}	O
}	O
break	O
;	O
case	O
CASE_IGNORE	O
:	O
break	O
;	O
case	O
CASE_REPORT	int
:	O
case	O
CASE_VT_MODE	O
:	O
case	O
CASE_BEL	O
:	O
case	O
CASE_COPY	O
:	O
case	O
CASE_CURSTATE	O
:	O
Tparsestate	pointer
=	O
curstate	pointer
;	O
break	O
;	O
case	O
CASE_ASCII	O
:	O
Tparsestate	pointer
=	O
curstate	pointer
;	O
break	O
;	O
case	O
CASE_APL	O
:	O
Tparsestate	pointer
=	O
curstate	pointer
;	O
break	O
;	O
case	O
CASE_GIN	O
:	O
Tparsestate	pointer
=	O
Tbyptable	array
;	O
break	O
;	O
}	O
}	O
if	O
(	O
plotter_open	enum
==	O
true	int
)	O
end_page	function
(	O
plotter	pointer
)	O
;	O
current_page	int
++	O
;	O
return	O
(	O
badstatus	pointer
==	O
2	int
?	O
true	int
:	O
false	int
)	O
;	O
}	O
void	O
set_font_size	function
(	O
plPlotter	struct
*	O
plotter	pointer
,	O
int	O
new_fontsize	int
)	O
{	O
if	O
(	O
use_tek_fonts	enum
)	O
{	O
switch	O
(	O
new_fontsize	int
)	O
{	O
case	O
0	int
:	O
default	O
:	O
pl_fontname_r	function
(	O
plotter	pointer
,	O
"tekfont0"	pointer
)	O
;	O
break	O
;	O
case	O
1	int
:	O
pl_fontname_r	function
(	O
plotter	pointer
,	O
"tekfont1"	pointer
)	O
;	O
break	O
;	O
case	O
2	int
:	O
pl_fontname_r	function
(	O
plotter	pointer
,	O
"tekfont2"	pointer
)	O
;	O
break	O
;	O
case	O
3	int
:	O
pl_fontname_r	function
(	O
plotter	pointer
,	O
"tekfont3"	pointer
)	O
;	O
break	O
;	O
}	O
}	O
else	O
pl_ffontsize_r	function
(	O
plotter	pointer
,	O
(	O
double	O
)	O
(	O
TekChar	array
[	O
new_fontsize	int
]	O
.	O
hsize	int
)	O
/	O
CHAR_WIDTH	int
)	O
;	O
}	O
void	O
begin_page	function
(	O
plPlotter	struct
*	O
plotter	pointer
)	O
{	O
if	O
(	O
pl_openpl_r	function
(	O
plotter	pointer
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: error: the plot device could not be opened\n"	pointer
,	O
progname	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
plotter_open	enum
=	O
true	int
;	O
plotter_opened	enum
=	O
true	int
;	O
pl_erase_r	function
(	O
plotter	pointer
)	O
;	O
pl_space_r	function
(	O
plotter	pointer
,	O
0	int
,	O
0	int
,	O
TEK_WIDTH	int
-	O
1	int
,	O
TEK_WIDTH	int
-	O
1	int
)	O
;	O
pl_joinmod_r	function
(	O
plotter	pointer
,	O
"round"	pointer
)	O
;	O
pl_capmod_r	function
(	O
plotter	pointer
,	O
"round"	pointer
)	O
;	O
if	O
(	O
pen_color	pointer
)	O
pl_pencolorname_r	function
(	O
plotter	pointer
,	O
pen_color	pointer
)	O
;	O
if	O
(	O
use_tek_fonts	enum
)	O
pl_fontname_r	function
(	O
plotter	pointer
,	O
"tekfont0"	pointer
)	O
;	O
else	O
{	O
if	O
(	O
font_name	pointer
)	O
pl_fontname_r	function
(	O
plotter	pointer
,	O
font_name	pointer
)	O
;	O
else	O
{	O
if	O
(	O
!	O
force_hershey_default	enum
)	O
{	O
if	O
(	O
pl_havecap_r	function
(	O
plotter	pointer
,	O
"PS_FONTS"	pointer
)	O
==	O
1	int
)	O
pl_fontname_r	function
(	O
plotter	pointer
,	O
DEFAULT_PS_FONT_NAME	pointer
)	O
;	O
else	O
if	O
(	O
pl_havecap_r	function
(	O
plotter	pointer
,	O
"PCL_FONTS"	pointer
)	O
==	O
1	int
)	O
pl_fontname_r	function
(	O
plotter	pointer
,	O
DEFAULT_PCL_FONT_NAME	pointer
)	O
;	O
else	O
pl_fontname_r	function
(	O
plotter	pointer
,	O
DEFAULT_HERSHEY_FONT_NAME	pointer
)	O
;	O
}	O
else	O
pl_fontname_r	function
(	O
plotter	pointer
,	O
DEFAULT_HERSHEY_FONT_NAME	pointer
)	O
;	O
}	O
pl_ffontsize_r	function
(	O
plotter	pointer
,	O
(	O
double	O
)	O
(	O
TekChar	array
[	O
0	int
]	O
.	O
hsize	int
)	O
/	O
CHAR_WIDTH	int
)	O
;	O
}	O
if	O
(	O
line_width	double
>=	O
0.0	int
)	O
pl_flinewidth_r	function
(	O
plotter	pointer
,	O
line_width	double
*	O
TEK_WIDTH	int
)	O
;	O
pl_move_r	function
(	O
plotter	pointer
,	O
cur_X	int
,	O
cur_Y	int
+	O
YOFFSET	int
)	O
;	O
}	O
void	O
end_page	function
(	O
plPlotter	struct
*	O
plotter	pointer
)	O
{	O
if	O
(	O
pl_closepl_r	function
(	O
plotter	pointer
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: error: the plot device could not be closed\n"	pointer
,	O
progname	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
plotter_open	enum
=	O
false	int
;	O
}	O
