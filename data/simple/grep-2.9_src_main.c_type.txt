struct	O
stats	struct
{	O
struct	O
stats	struct
const	O
*	O
parent	pointer
;	O
struct	O
stat	struct
stat	struct
;	O
}	O
;	O
static	O
struct	O
stats	struct
stats_base	struct
;	O
static	O
int	O
show_help	int
;	O
static	O
int	O
show_version	int
;	O
static	O
int	O
suppress_errors	int
;	O
static	O
int	O
color_option	int
;	O
static	O
int	O
only_matching	int
;	O
static	O
int	O
align_tabs	int
;	O
static	O
const	O
char	O
*	O
group_separator	pointer
=	O
SEP_STR_GROUP	pointer
;	O
static	O
const	O
char	O
*	O
selected_match_color	pointer
=	O
"01;31"	pointer
;	O
static	O
const	O
char	O
*	O
context_match_color	pointer
=	O
"01;31"	pointer
;	O
static	O
const	O
char	O
*	O
filename_color	pointer
=	O
"35"	pointer
;	O
static	O
const	O
char	O
*	O
line_num_color	pointer
=	O
"32"	pointer
;	O
static	O
const	O
char	O
*	O
byte_num_color	pointer
=	O
"32"	pointer
;	O
static	O
const	O
char	O
*	O
sep_color	pointer
=	O
"36"	pointer
;	O
static	O
const	O
char	O
*	O
selected_line_color	pointer
=	O
""	pointer
;	O
static	O
const	O
char	O
*	O
context_line_color	pointer
=	O
""	pointer
;	O
static	O
const	O
char	O
*	O
sgr_start	pointer
=	O
"\33[%sm\33[K"	pointer
;	O
static	O
const	O
char	O
*	O
sgr_end	pointer
=	O
"\33[m\33[K"	pointer
;	O
struct	O
color_cap	struct
{	O
const	O
char	O
*	O
name	pointer
;	O
const	O
char	O
*	O
*	O
var	pointer
;	O
const	O
char	O
*	O
(	O
*	O
fct	pointer
)	O
(	O
void	O
)	O
;	O
}	O
;	O
static	O
const	O
char	O
*	O
color_cap_mt_fct	function
(	O
void	O
)	O
{	O
context_match_color	pointer
=	O
selected_match_color	pointer
;	O
return	O
NULL	O
;	O
}	O
static	O
const	O
char	O
*	O
color_cap_rv_fct	function
(	O
void	O
)	O
{	O
color_option	int
=	O
-	O
1	int
;	O
return	O
NULL	O
;	O
}	O
static	O
const	O
char	O
*	O
color_cap_ne_fct	function
(	O
void	O
)	O
{	O
sgr_start	pointer
=	O
"\33[%sm"	pointer
;	O
sgr_end	pointer
=	O
"\33[m"	pointer
;	O
return	O
NULL	O
;	O
}	O
static	O
struct	O
color_cap	struct
color_dict	array
[	O
]	O
=	O
{	O
{	O
"mt"	pointer
,	O
&	O
selected_match_color	pointer
,	O
color_cap_mt_fct	function
}	O
,	O
{	O
"ms"	pointer
,	O
&	O
selected_match_color	pointer
,	O
NULL	O
}	O
,	O
{	O
"mc"	pointer
,	O
&	O
context_match_color	pointer
,	O
NULL	O
}	O
,	O
{	O
"fn"	pointer
,	O
&	O
filename_color	pointer
,	O
NULL	O
}	O
,	O
{	O
"ln"	pointer
,	O
&	O
line_num_color	pointer
,	O
NULL	O
}	O
,	O
{	O
"bn"	pointer
,	O
&	O
byte_num_color	pointer
,	O
NULL	O
}	O
,	O
{	O
"se"	pointer
,	O
&	O
sep_color	pointer
,	O
NULL	O
}	O
,	O
{	O
"sl"	pointer
,	O
&	O
selected_line_color	pointer
,	O
NULL	O
}	O
,	O
{	O
"cx"	pointer
,	O
&	O
context_line_color	pointer
,	O
NULL	O
}	O
,	O
{	O
"rv"	pointer
,	O
NULL	O
,	O
color_cap_rv_fct	function
}	O
,	O
{	O
"ne"	pointer
,	O
NULL	O
,	O
color_cap_ne_fct	function
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
}	O
;	O
static	O
struct	O
exclude	O
*	O
excluded_patterns	pointer
;	O
static	O
struct	O
exclude	O
*	O
included_patterns	pointer
;	O
static	O
struct	O
exclude	O
*	O
excluded_directory_patterns	pointer
;	O
static	O
char	O
const	O
short_options	array
[	O
]	O
=	O
"0123456789A:B:C:D:EFGHIPTUVX:abcd:e:f:hiKLlm:noqRrsuvwxyZz"	pointer
;	O
enum	O
{	O
BINARY_FILES_OPTION	int
=	O
CHAR_MAX	O
+	O
1	int
,	O
COLOR_OPTION	int
,	O
INCLUDE_OPTION	int
,	O
EXCLUDE_OPTION	int
,	O
EXCLUDE_FROM_OPTION	int
,	O
LINE_BUFFERED_OPTION	int
,	O
LABEL_OPTION	int
,	O
EXCLUDE_DIRECTORY_OPTION	int
,	O
GROUP_SEPARATOR_OPTION	int
,	O
MMAP_OPTION	int
}	O
;	O
static	O
struct	O
option	struct
const	O
long_options	array
[	O
]	O
=	O
{	O
{	O
"basic-regexp"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'G'	O
}	O
,	O
{	O
"extended-regexp"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'E'	O
}	O
,	O
{	O
"fixed-regexp"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'F'	O
}	O
,	O
{	O
"fixed-strings"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'F'	O
}	O
,	O
{	O
"perl-regexp"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'P'	O
}	O
,	O
{	O
"after-context"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'A'	O
}	O
,	O
{	O
"before-context"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'B'	O
}	O
,	O
{	O
"binary-files"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
BINARY_FILES_OPTION	int
}	O
,	O
{	O
"byte-offset"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'b'	O
}	O
,	O
{	O
"context"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'C'	O
}	O
,	O
{	O
"color"	pointer
,	O
optional_argument	int
,	O
NULL	O
,	O
COLOR_OPTION	int
}	O
,	O
{	O
"colour"	pointer
,	O
optional_argument	int
,	O
NULL	O
,	O
COLOR_OPTION	int
}	O
,	O
{	O
"count"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'c'	O
}	O
,	O
{	O
"devices"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'D'	O
}	O
,	O
{	O
"directories"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'd'	O
}	O
,	O
{	O
"exclude"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
EXCLUDE_OPTION	int
}	O
,	O
{	O
"exclude-from"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
EXCLUDE_FROM_OPTION	int
}	O
,	O
{	O
"exclude-dir"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
EXCLUDE_DIRECTORY_OPTION	int
}	O
,	O
{	O
"file"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'f'	O
}	O
,	O
{	O
"files-with-matches"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'l'	O
}	O
,	O
{	O
"files-without-match"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'L'	O
}	O
,	O
{	O
"group-separator"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
GROUP_SEPARATOR_OPTION	int
}	O
,	O
{	O
"help"	pointer
,	O
no_argument	int
,	O
&	O
show_help	int
,	O
1	int
}	O
,	O
{	O
"include"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
INCLUDE_OPTION	int
}	O
,	O
{	O
"ignore-case"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'i'	O
}	O
,	O
{	O
"initial-tab"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'T'	O
}	O
,	O
{	O
"label"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
LABEL_OPTION	int
}	O
,	O
{	O
"line-buffered"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
LINE_BUFFERED_OPTION	int
}	O
,	O
{	O
"line-number"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'n'	O
}	O
,	O
{	O
"line-regexp"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'x'	O
}	O
,	O
{	O
"max-count"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'm'	O
}	O
,	O
{	O
"mmap"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
MMAP_OPTION	int
}	O
,	O
{	O
"no-filename"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'h'	O
}	O
,	O
{	O
"no-group-separator"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
GROUP_SEPARATOR_OPTION	int
}	O
,	O
{	O
"no-messages"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
's'	O
}	O
,	O
{	O
"null"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'Z'	O
}	O
,	O
{	O
"null-data"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'z'	O
}	O
,	O
{	O
"only-matching"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'o'	O
}	O
,	O
{	O
"quiet"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'q'	O
}	O
,	O
{	O
"recursive"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'r'	O
}	O
,	O
{	O
"recursive"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'R'	O
}	O
,	O
{	O
"regexp"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'e'	O
}	O
,	O
{	O
"invert-match"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'v'	O
}	O
,	O
{	O
"silent"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'q'	O
}	O
,	O
{	O
"text"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'a'	O
}	O
,	O
{	O
"binary"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'U'	O
}	O
,	O
{	O
"unix-byte-offsets"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'u'	O
}	O
,	O
{	O
"version"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'V'	O
}	O
,	O
{	O
"with-filename"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'H'	O
}	O
,	O
{	O
"word-regexp"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'w'	O
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
int	O
match_icase	int
;	O
int	O
match_words	int
;	O
int	O
match_lines	int
;	O
unsigned	O
char	O
eolbyte	char
;	O
static	O
char	O
const	O
*	O
filename	pointer
;	O
static	O
int	O
errseen	int
;	O
enum	O
directories_type	enum
{	O
READ_DIRECTORIES	int
=	O
2	int
,	O
RECURSE_DIRECTORIES	int
,	O
SKIP_DIRECTORIES	int
}	O
;	O
static	O
char	O
const	O
*	O
const	O
directories_args	array
[	O
]	O
=	O
{	O
"read"	pointer
,	O
"recurse"	pointer
,	O
"skip"	pointer
,	O
NULL	O
}	O
;	O
static	O
enum	O
directories_type	enum
const	O
directories_types	array
[	O
]	O
=	O
{	O
READ_DIRECTORIES	int
,	O
RECURSE_DIRECTORIES	int
,	O
SKIP_DIRECTORIES	int
}	O
;	O
ARGMATCH_VERIFY	O
(	O
directories_args	array
,	O
directories_types	array
)	O
;	O
static	O
enum	O
directories_type	enum
directories	enum
=	O
READ_DIRECTORIES	int
;	O
static	O
enum	O
{	O
READ_DEVICES	int
,	O
SKIP_DEVICES	int
}	O
devices	enum
=	O
READ_DEVICES	int
;	O
static	O
int	O
grepdir	function
(	O
char	O
const	O
*	O
,	O
struct	O
stats	struct
const	O
*	O
)	O
;	O
static	O
compile_fp_t	pointer
compile	pointer
;	O
static	O
execute_fp_t	pointer
execute	pointer
;	O
static	O
void	O
suppressible_error	function
(	O
char	O
const	O
*	O
mesg	pointer
,	O
int	O
errnum	int
)	O
{	O
if	O
(	O
!	O
suppress_errors	int
)	O
error	function
(	O
0	int
,	O
errnum	int
,	O
"%s"	pointer
,	O
mesg	pointer
)	O
;	O
errseen	int
=	O
1	int
;	O
}	O
static	O
void	O
context_length_arg	function
(	O
char	O
const	O
*	O
str	pointer
,	O
int	O
*	O
out	pointer
)	O
{	O
uintmax_t	long
value	pointer
;	O
if	O
(	O
!	O
(	O
xstrtoumax	function
(	O
str	pointer
,	O
0	int
,	O
10	int
,	O
&	O
value	pointer
,	O
""	pointer
)	O
==	O
LONGINT_OK	int
&&	O
0	int
<=	O
(	O
*	O
out	pointer
=	O
value	pointer
)	O
&&	O
*	O
out	pointer
==	O
value	pointer
)	O
)	O
{	O
error	function
(	O
EXIT_TROUBLE	int
,	O
0	int
,	O
"%s: %s"	pointer
,	O
str	pointer
,	O
_	O
(	O
"invalid context length argument"	pointer
)	O
)	O
;	O
}	O
}	O
static	O
char	O
*	O
buffer	pointer
;	O
static	O
size_t	long
bufalloc	long
;	O
static	O
int	O
bufdesc	int
;	O
static	O
char	O
*	O
bufbeg	pointer
;	O
static	O
char	O
*	O
buflim	pointer
;	O
static	O
size_t	long
pagesize	long
;	O
static	O
off_t	long
bufoffset	long
;	O
static	O
off_t	long
after_last_match	long
;	O
static	O
int	O
reset	function
(	O
int	O
fd	int
,	O
char	O
const	O
*	O
file	pointer
,	O
struct	O
stats	struct
*	O
stats	struct
)	O
{	O
if	O
(	O
!	O
pagesize	long
)	O
{	O
pagesize	long
=	O
getpagesize	function
(	O
)	O
;	O
if	O
(	O
pagesize	long
==	O
0	int
||	O
2	int
*	O
pagesize	long
+	O
1	int
<=	O
pagesize	long
)	O
abort	function
(	O
)	O
;	O
bufalloc	long
=	O
ALIGN_TO	O
(	O
INITIAL_BUFSIZE	int
,	O
pagesize	long
)	O
+	O
pagesize	long
+	O
1	int
;	O
buffer	pointer
=	O
xmalloc	function
(	O
bufalloc	long
)	O
;	O
}	O
bufbeg	pointer
=	O
buflim	pointer
=	O
ALIGN_TO	O
(	O
buffer	pointer
+	O
1	int
,	O
pagesize	long
)	O
;	O
bufbeg	pointer
[	O
-	O
1	int
]	O
=	O
eolbyte	char
;	O
bufdesc	int
=	O
fd	int
;	O
if	O
(	O
S_ISREG	O
(	O
stats	struct
->	O
stat	struct
.	O
st_mode	int
)	O
)	O
{	O
if	O
(	O
file	pointer
)	O
bufoffset	long
=	O
0	int
;	O
else	O
{	O
bufoffset	long
=	O
lseek	function
(	O
fd	int
,	O
0	int
,	O
SEEK_CUR	int
)	O
;	O
if	O
(	O
bufoffset	long
<	O
0	int
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"lseek failed"	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
fillbuf	function
(	O
size_t	long
save	long
,	O
struct	O
stats	struct
const	O
*	O
stats	struct
)	O
{	O
size_t	long
fillsize	long
=	O
0	int
;	O
int	O
cc	int
=	O
1	int
;	O
char	O
*	O
readbuf	pointer
;	O
size_t	long
readsize	long
;	O
size_t	long
saved_offset	long
=	O
buflim	pointer
-	O
save	long
-	O
buffer	pointer
;	O
if	O
(	O
pagesize	long
<=	O
buffer	pointer
+	O
bufalloc	long
-	O
buflim	pointer
)	O
{	O
readbuf	pointer
=	O
buflim	pointer
;	O
bufbeg	pointer
=	O
buflim	pointer
-	O
save	long
;	O
}	O
else	O
{	O
size_t	long
minsize	long
=	O
save	long
+	O
pagesize	long
;	O
size_t	long
newsize	long
;	O
size_t	long
newalloc	long
;	O
char	O
*	O
newbuf	pointer
;	O
for	O
(	O
newsize	long
=	O
bufalloc	long
-	O
pagesize	long
-	O
1	int
;	O
newsize	long
<	O
minsize	long
;	O
newsize	long
*=	O
2	int
)	O
if	O
(	O
newsize	long
*	O
2	int
<	O
newsize	long
||	O
newsize	long
*	O
2	int
+	O
pagesize	long
+	O
1	int
<	O
newsize	long
*	O
2	int
)	O
xalloc_die	function
(	O
)	O
;	O
if	O
(	O
S_ISREG	O
(	O
stats	struct
->	O
stat	struct
.	O
st_mode	int
)	O
)	O
{	O
off_t	long
to_be_read	long
=	O
stats	struct
->	O
stat	struct
.	O
st_size	long
-	O
bufoffset	long
;	O
off_t	long
maxsize_off	long
=	O
save	long
+	O
to_be_read	long
;	O
if	O
(	O
0	int
<=	O
to_be_read	long
&&	O
to_be_read	long
<=	O
maxsize_off	long
&&	O
maxsize_off	long
==	O
(	O
size_t	long
)	O
maxsize_off	long
&&	O
minsize	long
<=	O
(	O
size_t	long
)	O
maxsize_off	long
&&	O
(	O
size_t	long
)	O
maxsize_off	long
<	O
newsize	long
)	O
newsize	long
=	O
maxsize_off	long
;	O
}	O
newalloc	long
=	O
newsize	long
+	O
pagesize	long
+	O
1	int
;	O
newbuf	pointer
=	O
bufalloc	long
<	O
newalloc	long
?	O
xmalloc	function
(	O
bufalloc	long
=	O
newalloc	long
)	O
:	O
buffer	pointer
;	O
readbuf	pointer
=	O
ALIGN_TO	O
(	O
newbuf	pointer
+	O
1	int
+	O
save	long
,	O
pagesize	long
)	O
;	O
bufbeg	pointer
=	O
readbuf	pointer
-	O
save	long
;	O
memmove	function
(	O
bufbeg	pointer
,	O
buffer	pointer
+	O
saved_offset	long
,	O
save	long
)	O
;	O
bufbeg	pointer
[	O
-	O
1	int
]	O
=	O
eolbyte	char
;	O
if	O
(	O
newbuf	pointer
!=	O
buffer	pointer
)	O
{	O
free	function
(	O
buffer	pointer
)	O
;	O
buffer	pointer
=	O
newbuf	pointer
;	O
}	O
}	O
readsize	long
=	O
buffer	pointer
+	O
bufalloc	long
-	O
readbuf	pointer
;	O
readsize	long
-=	O
readsize	long
%	O
pagesize	long
;	O
if	O
(	O
!	O
fillsize	long
)	O
{	O
ssize_t	long
bytesread	long
;	O
while	O
(	O
(	O
bytesread	long
=	O
read	pointer
(	O
bufdesc	int
,	O
readbuf	pointer
,	O
readsize	long
)	O
)	O
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
if	O
(	O
bytesread	long
<	O
0	int
)	O
cc	int
=	O
0	int
;	O
else	O
fillsize	long
=	O
bytesread	long
;	O
}	O
bufoffset	long
+=	O
fillsize	long
;	O
buflim	pointer
=	O
readbuf	pointer
+	O
fillsize	long
;	O
return	O
cc	int
;	O
}	O
static	O
enum	O
{	O
BINARY_BINARY_FILES	int
,	O
TEXT_BINARY_FILES	int
,	O
WITHOUT_MATCH_BINARY_FILES	int
}	O
binary_files	enum
;	O
static	O
int	O
filename_mask	int
;	O
static	O
int	O
out_quiet	int
;	O
static	O
int	O
out_invert	int
;	O
static	O
int	O
out_file	int
;	O
static	O
int	O
out_line	int
;	O
static	O
int	O
out_byte	int
;	O
static	O
int	O
out_before	int
;	O
static	O
int	O
out_after	int
;	O
static	O
int	O
count_matches	int
;	O
static	O
int	O
list_files	int
;	O
static	O
int	O
no_filenames	int
;	O
static	O
off_t	long
max_count	long
;	O
static	O
int	O
line_buffered	int
;	O
static	O
char	O
*	O
label	pointer
=	O
NULL	O
;	O
static	O
uintmax_t	long
totalcc	long
;	O
static	O
char	O
const	O
*	O
lastnl	pointer
;	O
static	O
char	O
const	O
*	O
lastout	pointer
;	O
static	O
uintmax_t	long
totalnl	long
;	O
static	O
off_t	long
outleft	long
;	O
static	O
int	O
pending	int
;	O
static	O
int	O
done_on_match	int
;	O
static	O
int	O
exit_on_match	int
;	O
static	O
uintmax_t	long
add_count	function
(	O
uintmax_t	long
a	long
,	O
uintmax_t	long
b	long
)	O
{	O
uintmax_t	long
sum	long
=	O
a	long
+	O
b	long
;	O
if	O
(	O
sum	long
<	O
a	long
)	O
error	function
(	O
EXIT_TROUBLE	int
,	O
0	int
,	O
_	O
(	O
"input is too large to count"	pointer
)	O
)	O
;	O
return	O
sum	long
;	O
}	O
static	O
void	O
nlscan	function
(	O
char	O
const	O
*	O
lim	pointer
)	O
{	O
size_t	long
newlines	long
=	O
0	int
;	O
char	O
const	O
*	O
beg	pointer
;	O
for	O
(	O
beg	pointer
=	O
lastnl	pointer
;	O
beg	pointer
<	O
lim	pointer
;	O
beg	pointer
++	O
)	O
{	O
beg	pointer
=	O
memchr	function
(	O
beg	pointer
,	O
eolbyte	char
,	O
lim	pointer
-	O
beg	pointer
)	O
;	O
if	O
(	O
!	O
beg	pointer
)	O
break	O
;	O
newlines	long
++	O
;	O
}	O
totalnl	long
=	O
add_count	function
(	O
totalnl	long
,	O
newlines	long
)	O
;	O
lastnl	pointer
=	O
lim	pointer
;	O
}	O
static	O
void	O
print_filename	function
(	O
void	O
)	O
{	O
PR_SGR_START_IF	O
(	O
filename_color	pointer
)	O
;	O
fputs	function
(	O
filename	pointer
,	O
stdout	pointer
)	O
;	O
PR_SGR_END_IF	O
(	O
filename_color	pointer
)	O
;	O
}	O
static	O
void	O
print_sep	function
(	O
char	O
sep	char
)	O
{	O
PR_SGR_START_IF	O
(	O
sep_color	pointer
)	O
;	O
fputc	function
(	O
sep	char
,	O
stdout	pointer
)	O
;	O
PR_SGR_END_IF	O
(	O
sep_color	pointer
)	O
;	O
}	O
static	O
void	O
print_offset	function
(	O
uintmax_t	long
pos	long
,	O
int	O
min_width	int
,	O
const	O
char	O
*	O
color	pointer
)	O
{	O
char	O
buf	array
[	O
sizeof	O
pos	long
*	O
CHAR_BIT	O
]	O
;	O
char	O
*	O
p	pointer
=	O
buf	array
+	O
sizeof	O
buf	array
;	O
do	O
{	O
*	O
--	O
p	pointer
=	O
'0'	O
+	O
pos	long
%	O
10	int
;	O
--	O
min_width	int
;	O
}	O
while	O
(	O
(	O
pos	long
/=	O
10	int
)	O
!=	O
0	int
)	O
;	O
if	O
(	O
align_tabs	int
)	O
while	O
(	O
--	O
min_width	int
>=	O
0	int
)	O
*	O
--	O
p	pointer
=	O
' '	O
;	O
PR_SGR_START_IF	O
(	O
color	pointer
)	O
;	O
fwrite	function
(	O
p	pointer
,	O
1	int
,	O
buf	array
+	O
sizeof	O
buf	array
-	O
p	pointer
,	O
stdout	pointer
)	O
;	O
PR_SGR_END_IF	O
(	O
color	pointer
)	O
;	O
}	O
static	O
void	O
print_line_head	function
(	O
char	O
const	O
*	O
beg	pointer
,	O
char	O
const	O
*	O
lim	pointer
,	O
int	O
sep	char
)	O
{	O
int	O
pending_sep	int
=	O
0	int
;	O
if	O
(	O
out_file	int
)	O
{	O
print_filename	function
(	O
)	O
;	O
if	O
(	O
filename_mask	int
)	O
pending_sep	int
=	O
1	int
;	O
else	O
fputc	function
(	O
0	int
,	O
stdout	pointer
)	O
;	O
}	O
if	O
(	O
out_line	int
)	O
{	O
if	O
(	O
lastnl	pointer
<	O
lim	pointer
)	O
{	O
nlscan	function
(	O
beg	pointer
)	O
;	O
totalnl	long
=	O
add_count	function
(	O
totalnl	long
,	O
1	int
)	O
;	O
lastnl	pointer
=	O
lim	pointer
;	O
}	O
if	O
(	O
pending_sep	int
)	O
print_sep	function
(	O
sep	char
)	O
;	O
print_offset	function
(	O
totalnl	long
,	O
4	int
,	O
line_num_color	pointer
)	O
;	O
pending_sep	int
=	O
1	int
;	O
}	O
if	O
(	O
out_byte	int
)	O
{	O
uintmax_t	long
pos	long
=	O
add_count	function
(	O
totalcc	long
,	O
beg	pointer
-	O
bufbeg	pointer
)	O
;	O
if	O
(	O
pending_sep	int
)	O
print_sep	function
(	O
sep	char
)	O
;	O
print_offset	function
(	O
pos	long
,	O
6	int
,	O
byte_num_color	pointer
)	O
;	O
pending_sep	int
=	O
1	int
;	O
}	O
if	O
(	O
pending_sep	int
)	O
{	O
if	O
(	O
align_tabs	int
)	O
fputs	function
(	O
"\t\b"	pointer
,	O
stdout	pointer
)	O
;	O
print_sep	function
(	O
sep	char
)	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
print_line_middle	function
(	O
const	O
char	O
*	O
beg	pointer
,	O
const	O
char	O
*	O
lim	pointer
,	O
const	O
char	O
*	O
line_color	pointer
,	O
const	O
char	O
*	O
match_color	pointer
)	O
{	O
size_t	long
match_size	long
;	O
size_t	long
match_offset	long
;	O
const	O
char	O
*	O
cur	pointer
=	O
beg	pointer
;	O
const	O
char	O
*	O
mid	pointer
=	O
NULL	O
;	O
while	O
(	O
cur	pointer
<	O
lim	pointer
&&	O
(	O
(	O
match_offset	long
=	O
execute	pointer
(	O
beg	pointer
,	O
lim	pointer
-	O
beg	pointer
,	O
&	O
match_size	long
,	O
beg	pointer
+	O
(	O
cur	pointer
-	O
beg	pointer
)	O
)	O
)	O
!=	O
(	O
size_t	long
)	O
-	O
1	int
)	O
)	O
{	O
char	O
const	O
*	O
b	long
=	O
beg	pointer
+	O
match_offset	long
;	O
if	O
(	O
b	long
==	O
lim	pointer
)	O
break	O
;	O
if	O
(	O
match_size	long
==	O
0	int
)	O
{	O
match_size	long
=	O
1	int
;	O
if	O
(	O
!	O
mid	pointer
)	O
mid	pointer
=	O
cur	pointer
;	O
}	O
else	O
{	O
if	O
(	O
only_matching	int
)	O
print_line_head	function
(	O
b	long
,	O
lim	pointer
,	O
out_invert	int
?	O
SEP_CHAR_REJECTED	char
:	O
SEP_CHAR_SELECTED	char
)	O
;	O
else	O
{	O
PR_SGR_START	O
(	O
line_color	pointer
)	O
;	O
if	O
(	O
mid	pointer
)	O
{	O
cur	pointer
=	O
mid	pointer
;	O
mid	pointer
=	O
NULL	O
;	O
}	O
fwrite	function
(	O
cur	pointer
,	O
sizeof	O
(	O
char	O
)	O
,	O
b	long
-	O
cur	pointer
,	O
stdout	pointer
)	O
;	O
}	O
PR_SGR_START_IF	O
(	O
match_color	pointer
)	O
;	O
fwrite	function
(	O
b	long
,	O
sizeof	O
(	O
char	O
)	O
,	O
match_size	long
,	O
stdout	pointer
)	O
;	O
PR_SGR_END_IF	O
(	O
match_color	pointer
)	O
;	O
if	O
(	O
only_matching	int
)	O
fputs	function
(	O
"\n"	pointer
,	O
stdout	pointer
)	O
;	O
}	O
cur	pointer
=	O
b	long
+	O
match_size	long
;	O
}	O
if	O
(	O
only_matching	int
)	O
cur	pointer
=	O
lim	pointer
;	O
else	O
if	O
(	O
mid	pointer
)	O
cur	pointer
=	O
mid	pointer
;	O
return	O
cur	pointer
;	O
}	O
static	O
const	O
char	O
*	O
print_line_tail	function
(	O
const	O
char	O
*	O
beg	pointer
,	O
const	O
char	O
*	O
lim	pointer
,	O
const	O
char	O
*	O
line_color	pointer
)	O
{	O
size_t	long
eol_size	long
;	O
size_t	long
tail_size	long
;	O
eol_size	long
=	O
(	O
lim	pointer
>	O
beg	pointer
&&	O
lim	pointer
[	O
-	O
1	int
]	O
==	O
eolbyte	char
)	O
;	O
eol_size	long
+=	O
(	O
lim	pointer
-	O
eol_size	long
>	O
beg	pointer
&&	O
lim	pointer
[	O
-	O
(	O
1	int
+	O
eol_size	long
)	O
]	O
==	O
'\r'	O
)	O
;	O
tail_size	long
=	O
lim	pointer
-	O
eol_size	long
-	O
beg	pointer
;	O
if	O
(	O
tail_size	long
>	O
0	int
)	O
{	O
PR_SGR_START	O
(	O
line_color	pointer
)	O
;	O
fwrite	function
(	O
beg	pointer
,	O
1	int
,	O
tail_size	long
,	O
stdout	pointer
)	O
;	O
beg	pointer
+=	O
tail_size	long
;	O
PR_SGR_END	O
(	O
line_color	pointer
)	O
;	O
}	O
return	O
beg	pointer
;	O
}	O
static	O
void	O
prline	function
(	O
char	O
const	O
*	O
beg	pointer
,	O
char	O
const	O
*	O
lim	pointer
,	O
int	O
sep	char
)	O
{	O
int	O
matching	int
;	O
const	O
char	O
*	O
line_color	pointer
;	O
const	O
char	O
*	O
match_color	pointer
;	O
if	O
(	O
!	O
only_matching	int
)	O
print_line_head	function
(	O
beg	pointer
,	O
lim	pointer
,	O
sep	char
)	O
;	O
matching	int
=	O
(	O
sep	char
==	O
SEP_CHAR_SELECTED	char
)	O
^	O
!	O
!	O
out_invert	int
;	O
if	O
(	O
color_option	int
)	O
{	O
line_color	pointer
=	O
(	O
(	O
sep	char
==	O
SEP_CHAR_SELECTED	char
)	O
^	O
(	O
out_invert	int
&&	O
(	O
color_option	int
<	O
0	int
)	O
)	O
)	O
?	O
selected_line_color	pointer
:	O
context_line_color	pointer
;	O
match_color	pointer
=	O
(	O
sep	char
==	O
SEP_CHAR_SELECTED	char
)	O
?	O
selected_match_color	pointer
:	O
context_match_color	pointer
;	O
}	O
else	O
line_color	pointer
=	O
match_color	pointer
=	O
NULL	O
;	O
if	O
(	O
(	O
only_matching	int
&&	O
matching	int
)	O
||	O
(	O
color_option	int
&&	O
(	O
*	O
line_color	pointer
||	O
*	O
match_color	pointer
)	O
)	O
)	O
{	O
if	O
(	O
matching	int
&&	O
(	O
only_matching	int
||	O
*	O
match_color	pointer
)	O
)	O
beg	pointer
=	O
print_line_middle	function
(	O
beg	pointer
,	O
lim	pointer
,	O
line_color	pointer
,	O
match_color	pointer
)	O
;	O
if	O
(	O
!	O
only_matching	int
&&	O
*	O
line_color	pointer
)	O
beg	pointer
=	O
print_line_tail	function
(	O
beg	pointer
,	O
lim	pointer
,	O
line_color	pointer
)	O
;	O
}	O
if	O
(	O
!	O
only_matching	int
&&	O
lim	pointer
>	O
beg	pointer
)	O
fwrite	function
(	O
beg	pointer
,	O
1	int
,	O
lim	pointer
-	O
beg	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
ferror	function
(	O
stdout	pointer
)	O
)	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"writing output"	pointer
)	O
)	O
;	O
lastout	pointer
=	O
lim	pointer
;	O
if	O
(	O
line_buffered	int
)	O
fflush	function
(	O
stdout	pointer
)	O
;	O
}	O
static	O
void	O
prpending	function
(	O
char	O
const	O
*	O
lim	pointer
)	O
{	O
if	O
(	O
!	O
lastout	pointer
)	O
lastout	pointer
=	O
bufbeg	pointer
;	O
while	O
(	O
pending	int
>	O
0	int
&&	O
lastout	pointer
<	O
lim	pointer
)	O
{	O
char	O
const	O
*	O
nl	pointer
=	O
memchr	function
(	O
lastout	pointer
,	O
eolbyte	char
,	O
lim	pointer
-	O
lastout	pointer
)	O
;	O
size_t	long
match_size	long
;	O
--	O
pending	int
;	O
if	O
(	O
outleft	long
||	O
(	O
(	O
execute	pointer
(	O
lastout	pointer
,	O
nl	pointer
+	O
1	int
-	O
lastout	pointer
,	O
&	O
match_size	long
,	O
NULL	O
)	O
==	O
(	O
size_t	long
)	O
-	O
1	int
)	O
==	O
!	O
out_invert	int
)	O
)	O
prline	function
(	O
lastout	pointer
,	O
nl	pointer
+	O
1	int
,	O
SEP_CHAR_REJECTED	char
)	O
;	O
else	O
pending	int
=	O
0	int
;	O
}	O
}	O
static	O
void	O
prtext	function
(	O
char	O
const	O
*	O
beg	pointer
,	O
char	O
const	O
*	O
lim	pointer
,	O
int	O
*	O
nlinesp	pointer
)	O
{	O
static	O
int	O
used	int
;	O
char	O
const	O
*	O
bp	pointer
,	O
*	O
p	pointer
;	O
char	O
eol	char
=	O
eolbyte	char
;	O
int	O
i	int
,	O
n	long
;	O
if	O
(	O
!	O
out_quiet	int
&&	O
pending	int
>	O
0	int
)	O
prpending	function
(	O
beg	pointer
)	O
;	O
p	pointer
=	O
beg	pointer
;	O
if	O
(	O
!	O
out_quiet	int
)	O
{	O
bp	pointer
=	O
lastout	pointer
?	O
lastout	pointer
:	O
bufbeg	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
out_before	int
;	O
++	O
i	int
)	O
if	O
(	O
p	pointer
>	O
bp	pointer
)	O
do	O
--	O
p	pointer
;	O
while	O
(	O
p	pointer
[	O
-	O
1	int
]	O
!=	O
eol	char
)	O
;	O
if	O
(	O
(	O
out_before	int
||	O
out_after	int
)	O
&&	O
used	int
&&	O
p	pointer
!=	O
lastout	pointer
&&	O
group_separator	pointer
)	O
{	O
PR_SGR_START_IF	O
(	O
sep_color	pointer
)	O
;	O
fputs	function
(	O
group_separator	pointer
,	O
stdout	pointer
)	O
;	O
PR_SGR_END_IF	O
(	O
sep_color	pointer
)	O
;	O
fputc	function
(	O
'\n'	O
,	O
stdout	pointer
)	O
;	O
}	O
while	O
(	O
p	pointer
<	O
beg	pointer
)	O
{	O
char	O
const	O
*	O
nl	pointer
=	O
memchr	function
(	O
p	pointer
,	O
eol	char
,	O
beg	pointer
-	O
p	pointer
)	O
;	O
nl	pointer
++	O
;	O
prline	function
(	O
p	pointer
,	O
nl	pointer
,	O
SEP_CHAR_REJECTED	char
)	O
;	O
p	pointer
=	O
nl	pointer
;	O
}	O
}	O
if	O
(	O
nlinesp	pointer
)	O
{	O
for	O
(	O
n	long
=	O
0	int
;	O
p	pointer
<	O
lim	pointer
&&	O
n	long
<	O
outleft	long
;	O
n	long
++	O
)	O
{	O
char	O
const	O
*	O
nl	pointer
=	O
memchr	function
(	O
p	pointer
,	O
eol	char
,	O
lim	pointer
-	O
p	pointer
)	O
;	O
nl	pointer
++	O
;	O
if	O
(	O
!	O
out_quiet	int
)	O
prline	function
(	O
p	pointer
,	O
nl	pointer
,	O
SEP_CHAR_SELECTED	char
)	O
;	O
p	pointer
=	O
nl	pointer
;	O
}	O
*	O
nlinesp	pointer
=	O
n	long
;	O
after_last_match	long
=	O
bufoffset	long
-	O
(	O
buflim	pointer
-	O
p	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
out_quiet	int
)	O
prline	function
(	O
beg	pointer
,	O
lim	pointer
,	O
SEP_CHAR_SELECTED	char
)	O
;	O
pending	int
=	O
out_quiet	int
?	O
0	int
:	O
out_after	int
;	O
used	int
=	O
1	int
;	O
}	O
static	O
size_t	long
do_execute	function
(	O
char	O
const	O
*	O
buf	array
,	O
size_t	long
size	long
,	O
size_t	long
*	O
match_size	long
,	O
char	O
const	O
*	O
start_ptr	pointer
)	O
{	O
size_t	long
result	long
;	O
const	O
char	O
*	O
line_next	pointer
;	O
if	O
(	O
MB_CUR_MAX	O
==	O
1	int
||	O
!	O
match_icase	int
)	O
return	O
execute	pointer
(	O
buf	array
,	O
size	long
,	O
match_size	long
,	O
start_ptr	pointer
)	O
;	O
for	O
(	O
line_next	pointer
=	O
buf	array
;	O
line_next	pointer
<	O
buf	array
+	O
size	long
;	O
)	O
{	O
const	O
char	O
*	O
line_buf	pointer
=	O
line_next	pointer
;	O
const	O
char	O
*	O
line_end	pointer
=	O
memchr	function
(	O
line_buf	pointer
,	O
eolbyte	char
,	O
(	O
buf	array
+	O
size	long
)	O
-	O
line_buf	pointer
)	O
;	O
if	O
(	O
line_end	pointer
==	O
NULL	O
)	O
line_next	pointer
=	O
line_end	pointer
=	O
buf	array
+	O
size	long
;	O
else	O
line_next	pointer
=	O
line_end	pointer
+	O
1	int
;	O
if	O
(	O
start_ptr	pointer
&&	O
start_ptr	pointer
>=	O
line_end	pointer
)	O
continue	O
;	O
result	long
=	O
execute	pointer
(	O
line_buf	pointer
,	O
line_next	pointer
-	O
line_buf	pointer
,	O
match_size	long
,	O
start_ptr	pointer
)	O
;	O
if	O
(	O
result	long
!=	O
(	O
size_t	long
)	O
-	O
1	int
)	O
return	O
(	O
line_buf	pointer
-	O
buf	array
)	O
+	O
result	long
;	O
}	O
return	O
(	O
size_t	long
)	O
-	O
1	int
;	O
}	O
static	O
int	O
grepbuf	function
(	O
char	O
const	O
*	O
beg	pointer
,	O
char	O
const	O
*	O
lim	pointer
)	O
{	O
int	O
nlines	int
,	O
n	long
;	O
char	O
const	O
*	O
p	pointer
;	O
size_t	long
match_offset	long
;	O
size_t	long
match_size	long
;	O
nlines	int
=	O
0	int
;	O
p	pointer
=	O
beg	pointer
;	O
while	O
(	O
(	O
match_offset	long
=	O
do_execute	function
(	O
p	pointer
,	O
lim	pointer
-	O
p	pointer
,	O
&	O
match_size	long
,	O
NULL	O
)	O
)	O
!=	O
(	O
size_t	long
)	O
-	O
1	int
)	O
{	O
char	O
const	O
*	O
b	long
=	O
p	pointer
+	O
match_offset	long
;	O
char	O
const	O
*	O
endp	pointer
=	O
b	long
+	O
match_size	long
;	O
if	O
(	O
b	long
==	O
lim	pointer
)	O
break	O
;	O
if	O
(	O
!	O
out_invert	int
)	O
{	O
prtext	function
(	O
b	long
,	O
endp	pointer
,	O
(	O
int	O
*	O
)	O
0	int
)	O
;	O
nlines	int
++	O
;	O
outleft	long
--	O
;	O
if	O
(	O
!	O
outleft	long
||	O
done_on_match	int
)	O
{	O
if	O
(	O
exit_on_match	int
)	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
after_last_match	long
=	O
bufoffset	long
-	O
(	O
buflim	pointer
-	O
endp	pointer
)	O
;	O
return	O
nlines	int
;	O
}	O
}	O
else	O
if	O
(	O
p	pointer
<	O
b	long
)	O
{	O
prtext	function
(	O
p	pointer
,	O
b	long
,	O
&	O
n	long
)	O
;	O
nlines	int
+=	O
n	long
;	O
outleft	long
-=	O
n	long
;	O
if	O
(	O
!	O
outleft	long
)	O
return	O
nlines	int
;	O
}	O
p	pointer
=	O
endp	pointer
;	O
}	O
if	O
(	O
out_invert	int
&&	O
p	pointer
<	O
lim	pointer
)	O
{	O
prtext	function
(	O
p	pointer
,	O
lim	pointer
,	O
&	O
n	long
)	O
;	O
nlines	int
+=	O
n	long
;	O
outleft	long
-=	O
n	long
;	O
}	O
return	O
nlines	int
;	O
}	O
static	O
int	O
grep	function
(	O
int	O
fd	int
,	O
char	O
const	O
*	O
file	pointer
,	O
struct	O
stats	struct
*	O
stats	struct
)	O
{	O
int	O
nlines	int
,	O
i	int
;	O
int	O
not_text	int
;	O
size_t	long
residue	long
,	O
save	long
;	O
char	O
oldc	char
;	O
char	O
*	O
beg	pointer
;	O
char	O
*	O
lim	pointer
;	O
char	O
eol	char
=	O
eolbyte	char
;	O
if	O
(	O
!	O
reset	function
(	O
fd	int
,	O
file	pointer
,	O
stats	struct
)	O
)	O
return	O
0	int
;	O
if	O
(	O
file	pointer
&&	O
directories	enum
==	O
RECURSE_DIRECTORIES	int
&&	O
S_ISDIR	O
(	O
stats	struct
->	O
stat	struct
.	O
st_mode	int
)	O
)	O
{	O
if	O
(	O
close	pointer
(	O
fd	int
)	O
!=	O
0	int
)	O
error	function
(	O
0	int
,	O
errno	O
,	O
"%s"	pointer
,	O
file	pointer
)	O
;	O
return	O
grepdir	function
(	O
file	pointer
,	O
stats	struct
)	O
-	O
2	int
;	O
}	O
totalcc	long
=	O
0	int
;	O
lastout	pointer
=	O
0	int
;	O
totalnl	long
=	O
0	int
;	O
outleft	long
=	O
max_count	long
;	O
after_last_match	long
=	O
0	int
;	O
pending	int
=	O
0	int
;	O
nlines	int
=	O
0	int
;	O
residue	long
=	O
0	int
;	O
save	long
=	O
0	int
;	O
if	O
(	O
!	O
fillbuf	function
(	O
save	long
,	O
stats	struct
)	O
)	O
{	O
if	O
(	O
!	O
is_EISDIR	O
(	O
errno	O
,	O
file	pointer
)	O
)	O
suppressible_error	function
(	O
filename	pointer
,	O
errno	O
)	O
;	O
return	O
0	int
;	O
}	O
not_text	int
=	O
(	O
(	O
(	O
binary_files	enum
==	O
BINARY_BINARY_FILES	int
&&	O
!	O
out_quiet	int
)	O
||	O
binary_files	enum
==	O
WITHOUT_MATCH_BINARY_FILES	int
)	O
&&	O
memchr	function
(	O
bufbeg	pointer
,	O
eol	char
?	O
'\0'	O
:	O
'\200'	O
,	O
buflim	pointer
-	O
bufbeg	pointer
)	O
)	O
;	O
if	O
(	O
not_text	int
&&	O
binary_files	enum
==	O
WITHOUT_MATCH_BINARY_FILES	int
)	O
return	O
0	int
;	O
done_on_match	int
+=	O
not_text	int
;	O
out_quiet	int
+=	O
not_text	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
lastnl	pointer
=	O
bufbeg	pointer
;	O
if	O
(	O
lastout	pointer
)	O
lastout	pointer
=	O
bufbeg	pointer
;	O
beg	pointer
=	O
bufbeg	pointer
+	O
save	long
;	O
if	O
(	O
beg	pointer
==	O
buflim	pointer
)	O
break	O
;	O
oldc	char
=	O
beg	pointer
[	O
-	O
1	int
]	O
;	O
beg	pointer
[	O
-	O
1	int
]	O
=	O
eol	char
;	O
for	O
(	O
lim	pointer
=	O
buflim	pointer
;	O
lim	pointer
[	O
-	O
1	int
]	O
!=	O
eol	char
;	O
lim	pointer
--	O
)	O
continue	O
;	O
beg	pointer
[	O
-	O
1	int
]	O
=	O
oldc	char
;	O
if	O
(	O
lim	pointer
==	O
beg	pointer
)	O
lim	pointer
=	O
beg	pointer
-	O
residue	long
;	O
beg	pointer
-=	O
residue	long
;	O
residue	long
=	O
buflim	pointer
-	O
lim	pointer
;	O
if	O
(	O
beg	pointer
<	O
lim	pointer
)	O
{	O
if	O
(	O
outleft	long
)	O
nlines	int
+=	O
grepbuf	function
(	O
beg	pointer
,	O
lim	pointer
)	O
;	O
if	O
(	O
pending	int
)	O
prpending	function
(	O
lim	pointer
)	O
;	O
if	O
(	O
(	O
!	O
outleft	long
&&	O
!	O
pending	int
)	O
||	O
(	O
nlines	int
&&	O
done_on_match	int
&&	O
!	O
out_invert	int
)	O
)	O
goto	O
finish_grep	O
;	O
}	O
i	int
=	O
0	int
;	O
beg	pointer
=	O
lim	pointer
;	O
while	O
(	O
i	int
<	O
out_before	int
&&	O
beg	pointer
>	O
bufbeg	pointer
&&	O
beg	pointer
!=	O
lastout	pointer
)	O
{	O
++	O
i	int
;	O
do	O
--	O
beg	pointer
;	O
while	O
(	O
beg	pointer
[	O
-	O
1	int
]	O
!=	O
eol	char
)	O
;	O
}	O
if	O
(	O
beg	pointer
!=	O
lastout	pointer
)	O
lastout	pointer
=	O
0	int
;	O
save	long
=	O
residue	long
+	O
lim	pointer
-	O
beg	pointer
;	O
if	O
(	O
out_byte	int
)	O
totalcc	long
=	O
add_count	function
(	O
totalcc	long
,	O
buflim	pointer
-	O
bufbeg	pointer
-	O
save	long
)	O
;	O
if	O
(	O
out_line	int
)	O
nlscan	function
(	O
beg	pointer
)	O
;	O
if	O
(	O
!	O
fillbuf	function
(	O
save	long
,	O
stats	struct
)	O
)	O
{	O
if	O
(	O
!	O
is_EISDIR	O
(	O
errno	O
,	O
file	pointer
)	O
)	O
suppressible_error	function
(	O
filename	pointer
,	O
errno	O
)	O
;	O
goto	O
finish_grep	O
;	O
}	O
}	O
if	O
(	O
residue	long
)	O
{	O
*	O
buflim	pointer
++	O
=	O
eol	char
;	O
if	O
(	O
outleft	long
)	O
nlines	int
+=	O
grepbuf	function
(	O
bufbeg	pointer
+	O
save	long
-	O
residue	long
,	O
buflim	pointer
)	O
;	O
if	O
(	O
pending	int
)	O
prpending	function
(	O
buflim	pointer
)	O
;	O
}	O
finish_grep	O
:	O
done_on_match	int
-=	O
not_text	int
;	O
out_quiet	int
-=	O
not_text	int
;	O
if	O
(	O
(	O
not_text	int
&	O
~	O
out_quiet	int
)	O
&&	O
nlines	int
!=	O
0	int
)	O
printf	function
(	O
_	O
(	O
"Binary file %s matches\n"	pointer
)	O
,	O
filename	pointer
)	O
;	O
return	O
nlines	int
;	O
}	O
static	O
int	O
grepfile	function
(	O
char	O
const	O
*	O
file	pointer
,	O
struct	O
stats	struct
*	O
stats	struct
)	O
{	O
int	O
desc	int
;	O
int	O
count	int
;	O
int	O
status	int
;	O
if	O
(	O
!	O
file	pointer
)	O
{	O
desc	int
=	O
0	int
;	O
filename	pointer
=	O
label	pointer
?	O
label	pointer
:	O
_	O
(	O
"(standard input)"	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
stat	struct
(	O
file	pointer
,	O
&	O
stats	struct
->	O
stat	struct
)	O
!=	O
0	int
)	O
{	O
suppressible_error	function
(	O
file	pointer
,	O
errno	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
directories	enum
==	O
SKIP_DIRECTORIES	int
&&	O
S_ISDIR	O
(	O
stats	struct
->	O
stat	struct
.	O
st_mode	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
devices	enum
==	O
SKIP_DEVICES	int
&&	O
(	O
S_ISCHR	O
(	O
stats	struct
->	O
stat	struct
.	O
st_mode	int
)	O
||	O
S_ISBLK	O
(	O
stats	struct
->	O
stat	struct
.	O
st_mode	int
)	O
||	O
S_ISSOCK	O
(	O
stats	struct
->	O
stat	struct
.	O
st_mode	int
)	O
||	O
S_ISFIFO	O
(	O
stats	struct
->	O
stat	struct
.	O
st_mode	int
)	O
)	O
)	O
return	O
1	int
;	O
while	O
(	O
(	O
desc	int
=	O
open	function
(	O
file	pointer
,	O
O_RDONLY	int
)	O
)	O
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
if	O
(	O
desc	int
<	O
0	int
)	O
{	O
int	O
e	int
=	O
errno	O
;	O
if	O
(	O
is_EISDIR	O
(	O
e	int
,	O
file	pointer
)	O
&&	O
directories	enum
==	O
RECURSE_DIRECTORIES	int
)	O
{	O
if	O
(	O
stat	struct
(	O
file	pointer
,	O
&	O
stats	struct
->	O
stat	struct
)	O
!=	O
0	int
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
"%s"	pointer
,	O
file	pointer
)	O
;	O
return	O
1	int
;	O
}	O
return	O
grepdir	function
(	O
file	pointer
,	O
stats	struct
)	O
;	O
}	O
if	O
(	O
!	O
suppress_errors	int
)	O
{	O
if	O
(	O
directories	enum
==	O
SKIP_DIRECTORIES	int
)	O
switch	O
(	O
e	int
)	O
{	O
case	O
EISDIR	int
:	O
return	O
1	int
;	O
case	O
EACCES	int
:	O
if	O
(	O
isdir	function
(	O
file	pointer
)	O
)	O
return	O
1	int
;	O
break	O
;	O
}	O
}	O
suppressible_error	function
(	O
file	pointer
,	O
e	int
)	O
;	O
return	O
1	int
;	O
}	O
filename	pointer
=	O
file	pointer
;	O
}	O
if	O
(	O
!	O
isatty	function
(	O
desc	int
)	O
)	O
SET_BINARY	O
(	O
desc	int
)	O
;	O
count	int
=	O
grep	function
(	O
desc	int
,	O
file	pointer
,	O
stats	struct
)	O
;	O
if	O
(	O
count	int
<	O
0	int
)	O
status	int
=	O
count	int
+	O
2	int
;	O
else	O
{	O
if	O
(	O
count_matches	int
)	O
{	O
if	O
(	O
out_file	int
)	O
{	O
print_filename	function
(	O
)	O
;	O
if	O
(	O
filename_mask	int
)	O
print_sep	function
(	O
SEP_CHAR_SELECTED	char
)	O
;	O
else	O
fputc	function
(	O
0	int
,	O
stdout	pointer
)	O
;	O
}	O
printf	function
(	O
"%d\n"	pointer
,	O
count	int
)	O
;	O
}	O
status	int
=	O
!	O
count	int
;	O
if	O
(	O
list_files	int
==	O
1	int
-	O
2	int
*	O
status	int
)	O
{	O
print_filename	function
(	O
)	O
;	O
fputc	function
(	O
'\n'	O
&	O
filename_mask	int
,	O
stdout	pointer
)	O
;	O
}	O
if	O
(	O
!	O
file	pointer
)	O
{	O
off_t	long
required_offset	long
=	O
outleft	long
?	O
bufoffset	long
:	O
after_last_match	long
;	O
if	O
(	O
required_offset	long
!=	O
bufoffset	long
&&	O
lseek	function
(	O
desc	int
,	O
required_offset	long
,	O
SEEK_SET	int
)	O
<	O
0	int
&&	O
S_ISREG	O
(	O
stats	struct
->	O
stat	struct
.	O
st_mode	int
)	O
)	O
error	function
(	O
0	int
,	O
errno	O
,	O
"%s"	pointer
,	O
filename	pointer
)	O
;	O
}	O
else	O
while	O
(	O
close	pointer
(	O
desc	int
)	O
!=	O
0	int
)	O
if	O
(	O
errno	O
!=	O
EINTR	int
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
"%s"	pointer
,	O
file	pointer
)	O
;	O
break	O
;	O
}	O
}	O
return	O
status	int
;	O
}	O
static	O
int	O
grepdir	function
(	O
char	O
const	O
*	O
dir	pointer
,	O
struct	O
stats	struct
const	O
*	O
stats	struct
)	O
{	O
struct	O
stats	struct
const	O
*	O
ancestor	pointer
;	O
char	O
*	O
name_space	pointer
;	O
int	O
status	int
=	O
1	int
;	O
if	O
(	O
excluded_directory_patterns	pointer
&&	O
excluded_file_name	function
(	O
excluded_directory_patterns	pointer
,	O
dir	pointer
)	O
)	O
{	O
return	O
1	int
;	O
}	O
if	O
(	O
stats	struct
->	O
stat	struct
.	O
st_ino	long
)	O
for	O
(	O
ancestor	pointer
=	O
stats	struct
;	O
(	O
ancestor	pointer
=	O
ancestor	pointer
->	O
parent	pointer
)	O
!=	O
0	int
;	O
)	O
if	O
(	O
ancestor	pointer
->	O
stat	struct
.	O
st_ino	long
==	O
stats	struct
->	O
stat	struct
.	O
st_ino	long
&&	O
ancestor	pointer
->	O
stat	struct
.	O
st_dev	long
==	O
stats	struct
->	O
stat	struct
.	O
st_dev	long
)	O
{	O
if	O
(	O
!	O
suppress_errors	int
)	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"warning: %s: %s"	pointer
)	O
,	O
dir	pointer
,	O
_	O
(	O
"recursive directory loop"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
name_space	pointer
=	O
savedir	function
(	O
dir	pointer
,	O
stats	struct
->	O
stat	struct
.	O
st_size	long
,	O
included_patterns	pointer
,	O
excluded_patterns	pointer
,	O
excluded_directory_patterns	pointer
)	O
;	O
if	O
(	O
!	O
name_space	pointer
)	O
{	O
if	O
(	O
errno	O
)	O
suppressible_error	function
(	O
dir	pointer
,	O
errno	O
)	O
;	O
else	O
xalloc_die	function
(	O
)	O
;	O
}	O
else	O
{	O
size_t	long
dirlen	long
=	O
strlen	function
(	O
dir	pointer
)	O
;	O
int	O
needs_slash	int
=	O
!	O
(	O
dirlen	long
==	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
dir	pointer
)	O
||	O
ISSLASH	O
(	O
dir	pointer
[	O
dirlen	long
-	O
1	int
]	O
)	O
)	O
;	O
char	O
*	O
file	pointer
=	O
NULL	O
;	O
char	O
const	O
*	O
namep	pointer
=	O
name_space	pointer
;	O
struct	O
stats	struct
child	struct
;	O
child	struct
.	O
parent	pointer
=	O
stats	struct
;	O
out_file	int
+=	O
!	O
no_filenames	int
;	O
while	O
(	O
*	O
namep	pointer
)	O
{	O
size_t	long
namelen	long
=	O
strlen	function
(	O
namep	pointer
)	O
;	O
file	pointer
=	O
xrealloc	function
(	O
file	pointer
,	O
dirlen	long
+	O
1	int
+	O
namelen	long
+	O
1	int
)	O
;	O
strcpy	function
(	O
file	pointer
,	O
dir	pointer
)	O
;	O
file	pointer
[	O
dirlen	long
]	O
=	O
'/'	O
;	O
strcpy	function
(	O
file	pointer
+	O
dirlen	long
+	O
needs_slash	int
,	O
namep	pointer
)	O
;	O
namep	pointer
+=	O
namelen	long
+	O
1	int
;	O
status	int
&=	O
grepfile	function
(	O
file	pointer
,	O
&	O
child	struct
)	O
;	O
}	O
out_file	int
-=	O
!	O
no_filenames	int
;	O
free	function
(	O
file	pointer
)	O
;	O
free	function
(	O
name_space	pointer
)	O
;	O
}	O
return	O
status	int
;	O
}	O
void	O
usage	function
(	O
int	O
status	int
)	O
__attribute__	O
(	O
(	O
noreturn	O
)	O
)	O
;	O
void	O
usage	function
(	O
int	O
status	int
)	O
{	O
if	O
(	O
status	int
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Usage: %s [OPTION]... PATTERN [FILE]...\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Try `%s --help' for more information.\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
}	O
else	O
{	O
printf	function
(	O
_	O
(	O
"Usage: %s [OPTION]... PATTERN [FILE]...\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Search for PATTERN in each FILE or standard input.\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"%s"	pointer
,	O
gettext	function
(	O
before_options	array
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"Example: %s -i 'hello world' menu.h main.c\n\nRegexp selection and interpretation:\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
if	O
(	O
matchers	array
[	O
1	int
]	O
.	O
name	pointer
)	O
printf	function
(	O
_	O
(	O
"  -E, --extended-regexp     PATTERN is an extended regular expression (ERE)\n  -F, --fixed-strings       PATTERN is a set of newline-separated fixed strings\n  -G, --basic-regexp        PATTERN is a basic regular expression (BRE)\n  -P, --perl-regexp         PATTERN is a Perl regular expression\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -e, --regexp=PATTERN      use PATTERN for matching\n  -f, --file=FILE           obtain PATTERN from FILE\n  -i, --ignore-case         ignore case distinctions\n  -w, --word-regexp         force PATTERN to match only whole words\n  -x, --line-regexp         force PATTERN to match only whole lines\n  -z, --null-data           a data line ends in 0 byte, not newline\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"\nMiscellaneous:\n  -s, --no-messages         suppress error messages\n  -v, --invert-match        select non-matching lines\n  -V, --version             print version information and exit\n      --help                display this help and exit\n      --mmap                ignored for backwards compatibility\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"\nOutput control:\n  -m, --max-count=NUM       stop after NUM matches\n  -b, --byte-offset         print the byte offset with output lines\n  -n, --line-number         print line number with output lines\n      --line-buffered       flush output on every line\n  -H, --with-filename       print the filename for each match\n  -h, --no-filename         suppress the prefixing filename on output\n      --label=LABEL         print LABEL as filename for standard input\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -o, --only-matching       show only the part of a line matching PATTERN\n  -q, --quiet, --silent     suppress all normal output\n      --binary-files=TYPE   assume that binary files are TYPE;\n                            TYPE is `binary', `text', or `without-match'\n  -a, --text                equivalent to --binary-files=text\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -I                        equivalent to --binary-files=without-match\n  -d, --directories=ACTION  how to handle directories;\n                            ACTION is `read', `recurse', or `skip'\n  -D, --devices=ACTION      how to handle devices, FIFOs and sockets;\n                            ACTION is `read' or `skip'\n  -R, -r, --recursive       equivalent to --directories=recurse\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --include=FILE_PATTERN  search only files that match FILE_PATTERN\n      --exclude=FILE_PATTERN  skip files and directories matching FILE_PATTERN\n      --exclude-from=FILE   skip files matching any file pattern from FILE\n      --exclude-dir=PATTERN  directories that match PATTERN will be skipped.\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -L, --files-without-match  print only names of FILEs containing no match\n  -l, --files-with-matches  print only names of FILEs containing matches\n  -c, --count               print only a count of matching lines per FILE\n  -T, --initial-tab         make tabs line up (if needed)\n  -Z, --null                print 0 byte after FILE name\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"\nContext control:\n  -B, --before-context=NUM  print NUM lines of leading context\n  -A, --after-context=NUM   print NUM lines of trailing context\n  -C, --context=NUM         print NUM lines of output context\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -NUM                      same as --context=NUM\n      --color[=WHEN],\n      --colour[=WHEN]       use markers to highlight the matching strings;\n                            WHEN is `always', `never', or `auto'\n  -U, --binary              do not strip CR characters at EOL (MSDOS)\n  -u, --unix-byte-offsets   report offsets as if CRs were not there (MSDOS)\n\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"%s"	pointer
,	O
_	O
(	O
after_options	array
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"With no FILE, or when FILE is -, read standard input.  If less than two FILEs\nare given, assume -h.  Exit status is 0 if any line was selected, 1 otherwise;\nif any error occurs and -q was not given, the exit status is 2.\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"\nReport bugs to: %s\n"	pointer
)	O
,	O
PACKAGE_BUGREPORT	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"GNU Grep home page: <%s>\n"	pointer
)	O
,	O
"http://www.gnu.org/software/grep/"	pointer
)	O
;	O
fputs	function
(	O
_	O
(	O
"General help using GNU software: <http://www.gnu.org/gethelp/>\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
}	O
exit	function
(	O
status	int
)	O
;	O
}	O
static	O
void	O
setmatcher	function
(	O
char	O
const	O
*	O
m	pointer
)	O
{	O
static	O
char	O
const	O
*	O
matcher	struct
;	O
unsigned	O
int	O
i	int
;	O
if	O
(	O
!	O
m	pointer
)	O
{	O
compile	pointer
=	O
matchers	array
[	O
0	int
]	O
.	O
compile	pointer
;	O
execute	pointer
=	O
matchers	array
[	O
0	int
]	O
.	O
execute	pointer
;	O
if	O
(	O
!	O
matchers	array
[	O
1	int
]	O
.	O
name	pointer
)	O
matcher	struct
=	O
matchers	array
[	O
0	int
]	O
.	O
name	pointer
;	O
}	O
else	O
if	O
(	O
matcher	struct
)	O
{	O
if	O
(	O
matcher	struct
&&	O
STREQ	O
(	O
matcher	struct
,	O
m	pointer
)	O
)	O
;	O
else	O
if	O
(	O
!	O
matchers	array
[	O
1	int
]	O
.	O
name	pointer
)	O
error	function
(	O
EXIT_TROUBLE	int
,	O
0	int
,	O
_	O
(	O
"%s can only use the %s pattern syntax"	pointer
)	O
,	O
program_name	pointer
,	O
matcher	struct
)	O
;	O
else	O
error	function
(	O
EXIT_TROUBLE	int
,	O
0	int
,	O
_	O
(	O
"conflicting matchers specified"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
matchers	array
[	O
i	int
]	O
.	O
name	pointer
;	O
i	int
++	O
)	O
if	O
(	O
STREQ	O
(	O
m	pointer
,	O
matchers	array
[	O
i	int
]	O
.	O
name	pointer
)	O
)	O
{	O
compile	pointer
=	O
matchers	array
[	O
i	int
]	O
.	O
compile	pointer
;	O
execute	pointer
=	O
matchers	array
[	O
i	int
]	O
.	O
execute	pointer
;	O
matcher	struct
=	O
m	pointer
;	O
return	O
;	O
}	O
error	function
(	O
EXIT_TROUBLE	int
,	O
0	int
,	O
_	O
(	O
"invalid matcher %s"	pointer
)	O
,	O
m	pointer
)	O
;	O
}	O
}	O
static	O
void	O
set_limits	function
(	O
void	O
)	O
{	O
}	O
static	O
int	O
prepend_args	function
(	O
char	O
const	O
*	O
options	int
,	O
char	O
*	O
buf	array
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
char	O
const	O
*	O
o	pointer
=	O
options	int
;	O
char	O
*	O
b	long
=	O
buf	array
;	O
int	O
n	long
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
while	O
(	O
c_isspace	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
o	pointer
)	O
)	O
o	pointer
++	O
;	O
if	O
(	O
!	O
*	O
o	pointer
)	O
return	O
n	long
;	O
if	O
(	O
argv	pointer
)	O
argv	pointer
[	O
n	long
]	O
=	O
b	long
;	O
n	long
++	O
;	O
do	O
if	O
(	O
(	O
*	O
b	long
++	O
=	O
*	O
o	pointer
++	O
)	O
==	O
'\\'	O
&&	O
*	O
o	pointer
)	O
b	long
[	O
-	O
1	int
]	O
=	O
*	O
o	pointer
++	O
;	O
while	O
(	O
*	O
o	pointer
&&	O
!	O
c_isspace	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
o	pointer
)	O
)	O
;	O
*	O
b	long
++	O
=	O
'\0'	O
;	O
}	O
}	O
static	O
void	O
prepend_default_options	function
(	O
char	O
const	O
*	O
options	int
,	O
int	O
*	O
pargc	pointer
,	O
char	O
*	O
*	O
*	O
pargv	pointer
)	O
{	O
if	O
(	O
options	int
&&	O
*	O
options	int
)	O
{	O
char	O
*	O
buf	array
=	O
xmalloc	function
(	O
strlen	function
(	O
options	int
)	O
+	O
1	int
)	O
;	O
int	O
prepended	int
=	O
prepend_args	function
(	O
options	int
,	O
buf	array
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
)	O
;	O
int	O
argc	int
=	O
*	O
pargc	pointer
;	O
char	O
*	O
const	O
*	O
argv	pointer
=	O
*	O
pargv	pointer
;	O
char	O
*	O
*	O
pp	pointer
=	O
xmalloc	function
(	O
(	O
prepended	int
+	O
argc	int
+	O
1	int
)	O
*	O
sizeof	O
*	O
pp	pointer
)	O
;	O
*	O
pargc	pointer
=	O
prepended	int
+	O
argc	int
;	O
*	O
pargv	pointer
=	O
pp	pointer
;	O
*	O
pp	pointer
++	O
=	O
*	O
argv	pointer
++	O
;	O
pp	pointer
+=	O
prepend_args	function
(	O
options	int
,	O
buf	array
,	O
pp	pointer
)	O
;	O
while	O
(	O
(	O
*	O
pp	pointer
++	O
=	O
*	O
argv	pointer
++	O
)	O
)	O
continue	O
;	O
}	O
}	O
static	O
int	O
get_nondigit_option	function
(	O
int	O
argc	int
,	O
char	O
*	O
const	O
*	O
argv	pointer
,	O
int	O
*	O
default_context	pointer
)	O
{	O
static	O
int	O
prev_digit_optind	int
=	O
-	O
1	int
;	O
int	O
opt	int
,	O
this_digit_optind	int
,	O
was_digit	int
;	O
char	O
buf	array
[	O
sizeof	O
(	O
uintmax_t	long
)	O
*	O
CHAR_BIT	O
+	O
4	int
]	O
;	O
char	O
*	O
p	pointer
=	O
buf	array
;	O
was_digit	int
=	O
0	int
;	O
this_digit_optind	int
=	O
optind	int
;	O
while	O
(	O
opt	int
=	O
getopt_long	function
(	O
argc	int
,	O
(	O
char	O
*	O
*	O
)	O
argv	pointer
,	O
short_options	array
,	O
long_options	array
,	O
NULL	O
)	O
,	O
'0'	O
<=	O
opt	int
&&	O
opt	int
<=	O
'9'	O
)	O
{	O
if	O
(	O
prev_digit_optind	int
!=	O
this_digit_optind	int
||	O
!	O
was_digit	int
)	O
{	O
p	pointer
=	O
buf	array
;	O
}	O
else	O
{	O
p	pointer
-=	O
buf	array
[	O
0	int
]	O
==	O
'0'	O
;	O
}	O
if	O
(	O
p	pointer
==	O
buf	array
+	O
sizeof	O
buf	array
-	O
4	int
)	O
{	O
strcpy	function
(	O
p	pointer
,	O
"..."	pointer
)	O
;	O
p	pointer
+=	O
3	int
;	O
break	O
;	O
}	O
*	O
p	pointer
++	O
=	O
opt	int
;	O
was_digit	int
=	O
1	int
;	O
prev_digit_optind	int
=	O
this_digit_optind	int
;	O
this_digit_optind	int
=	O
optind	int
;	O
}	O
if	O
(	O
p	pointer
!=	O
buf	array
)	O
{	O
*	O
p	pointer
=	O
'\0'	O
;	O
context_length_arg	function
(	O
buf	array
,	O
default_context	pointer
)	O
;	O
}	O
return	O
opt	int
;	O
}	O
static	O
void	O
parse_grep_colors	function
(	O
void	O
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
char	O
*	O
q	pointer
;	O
char	O
*	O
name	pointer
;	O
char	O
*	O
val	array
;	O
p	pointer
=	O
getenv	function
(	O
"GREP_COLORS"	pointer
)	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
||	O
*	O
p	pointer
==	O
'\0'	O
)	O
return	O
;	O
q	pointer
=	O
xstrdup	function
(	O
p	pointer
)	O
;	O
name	pointer
=	O
q	pointer
;	O
val	array
=	O
NULL	O
;	O
for	O
(	O
;	O
;	O
)	O
if	O
(	O
*	O
q	pointer
==	O
':'	O
||	O
*	O
q	pointer
==	O
'\0'	O
)	O
{	O
char	O
c	int
=	O
*	O
q	pointer
;	O
struct	O
color_cap	struct
*	O
cap	pointer
;	O
*	O
q	pointer
++	O
=	O
'\0'	O
;	O
for	O
(	O
cap	pointer
=	O
color_dict	array
;	O
cap	pointer
->	O
name	pointer
;	O
cap	pointer
++	O
)	O
if	O
(	O
STREQ	O
(	O
cap	pointer
->	O
name	pointer
,	O
name	pointer
)	O
)	O
break	O
;	O
if	O
(	O
cap	pointer
->	O
name	pointer
)	O
{	O
if	O
(	O
cap	pointer
->	O
var	pointer
)	O
{	O
if	O
(	O
val	array
)	O
*	O
(	O
cap	pointer
->	O
var	pointer
)	O
=	O
val	array
;	O
else	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"in GREP_COLORS=\"%s\", the \"%s\" capacity "	pointer
"needs a value (\"=...\"); skipped"	pointer
)	O
,	O
p	pointer
,	O
name	pointer
)	O
;	O
}	O
else	O
if	O
(	O
val	array
)	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"in GREP_COLORS=\"%s\", the \"%s\" capacity "	pointer
"is boolean and cannot take a value (\"=%s\"); skipped"	pointer
)	O
,	O
p	pointer
,	O
name	pointer
,	O
val	array
)	O
;	O
}	O
if	O
(	O
cap	pointer
->	O
fct	pointer
)	O
{	O
const	O
char	O
*	O
err_str	pointer
=	O
cap	pointer
->	O
fct	pointer
(	O
)	O
;	O
if	O
(	O
err_str	pointer
)	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"in GREP_COLORS=\"%s\", the \"%s\" capacity %s"	pointer
)	O
,	O
p	pointer
,	O
name	pointer
,	O
err_str	pointer
)	O
;	O
}	O
if	O
(	O
c	int
==	O
'\0'	O
)	O
return	O
;	O
name	pointer
=	O
q	pointer
;	O
val	array
=	O
NULL	O
;	O
}	O
else	O
if	O
(	O
*	O
q	pointer
==	O
'='	O
)	O
{	O
if	O
(	O
q	pointer
==	O
name	pointer
||	O
val	array
)	O
goto	O
ill_formed	O
;	O
*	O
q	pointer
++	O
=	O
'\0'	O
;	O
val	array
=	O
q	pointer
;	O
}	O
else	O
if	O
(	O
val	array
==	O
NULL	O
)	O
q	pointer
++	O
;	O
else	O
if	O
(	O
*	O
q	pointer
==	O
';'	O
||	O
(	O
*	O
q	pointer
>=	O
'0'	O
&&	O
*	O
q	pointer
<=	O
'9'	O
)	O
)	O
q	pointer
++	O
;	O
else	O
goto	O
ill_formed	O
;	O
ill_formed	O
:	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"stopped processing of ill-formed GREP_COLORS=\"%s\" "	pointer
"at remaining substring \"%s\""	pointer
)	O
,	O
p	pointer
,	O
q	pointer
)	O
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
char	O
*	O
keys	pointer
;	O
size_t	long
keycc	long
,	O
oldcc	long
,	O
keyalloc	long
;	O
int	O
with_filenames	int
;	O
int	O
opt	int
,	O
cc	int
,	O
status	int
;	O
int	O
default_context	pointer
;	O
FILE	struct
*	O
fp	pointer
;	O
exit_failure	int
=	O
EXIT_TROUBLE	int
;	O
initialize_main	O
(	O
&	O
argc	int
,	O
&	O
argv	pointer
)	O
;	O
set_program_name	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
program_name	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
keys	pointer
=	O
NULL	O
;	O
keycc	long
=	O
0	int
;	O
with_filenames	int
=	O
0	int
;	O
eolbyte	char
=	O
'\n'	O
;	O
filename_mask	int
=	O
~	O
0	int
;	O
max_count	long
=	O
TYPE_MAXIMUM	O
(	O
off_t	long
)	O
;	O
out_after	int
=	O
out_before	int
=	O
-	O
1	int
;	O
default_context	pointer
=	O
0	int
;	O
only_matching	int
=	O
0	int
;	O
setlocale	function
(	O
LC_ALL	O
,	O
""	pointer
)	O
;	O
bindtextdomain	function
(	O
PACKAGE	pointer
,	O
LOCALEDIR	pointer
)	O
;	O
textdomain	function
(	O
PACKAGE	pointer
)	O
;	O
exit_failure	int
=	O
EXIT_TROUBLE	int
;	O
atexit	function
(	O
close_stdout	function
)	O
;	O
prepend_default_options	function
(	O
getenv	function
(	O
"GREP_OPTIONS"	pointer
)	O
,	O
&	O
argc	int
,	O
&	O
argv	pointer
)	O
;	O
setmatcher	function
(	O
NULL	O
)	O
;	O
while	O
(	O
(	O
opt	int
=	O
get_nondigit_option	function
(	O
argc	int
,	O
argv	pointer
,	O
&	O
default_context	pointer
)	O
)	O
!=	O
-	O
1	int
)	O
switch	O
(	O
opt	int
)	O
{	O
case	O
'A'	O
:	O
context_length_arg	function
(	O
optarg	pointer
,	O
&	O
out_after	int
)	O
;	O
break	O
;	O
case	O
'B'	O
:	O
context_length_arg	function
(	O
optarg	pointer
,	O
&	O
out_before	int
)	O
;	O
break	O
;	O
case	O
'C'	O
:	O
context_length_arg	function
(	O
optarg	pointer
,	O
&	O
default_context	pointer
)	O
;	O
break	O
;	O
case	O
'D'	O
:	O
if	O
(	O
STREQ	O
(	O
optarg	pointer
,	O
"read"	pointer
)	O
)	O
devices	enum
=	O
READ_DEVICES	int
;	O
else	O
if	O
(	O
STREQ	O
(	O
optarg	pointer
,	O
"skip"	pointer
)	O
)	O
devices	enum
=	O
SKIP_DEVICES	int
;	O
else	O
error	function
(	O
EXIT_TROUBLE	int
,	O
0	int
,	O
_	O
(	O
"unknown devices method"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
'E'	O
:	O
setmatcher	function
(	O
"egrep"	pointer
)	O
;	O
break	O
;	O
case	O
'F'	O
:	O
setmatcher	function
(	O
"fgrep"	pointer
)	O
;	O
break	O
;	O
case	O
'P'	O
:	O
setmatcher	function
(	O
"perl"	pointer
)	O
;	O
break	O
;	O
case	O
'G'	O
:	O
setmatcher	function
(	O
"grep"	pointer
)	O
;	O
break	O
;	O
case	O
'X'	O
:	O
setmatcher	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'H'	O
:	O
with_filenames	int
=	O
1	int
;	O
no_filenames	int
=	O
0	int
;	O
break	O
;	O
case	O
'I'	O
:	O
binary_files	enum
=	O
WITHOUT_MATCH_BINARY_FILES	int
;	O
break	O
;	O
case	O
'T'	O
:	O
align_tabs	int
=	O
1	int
;	O
break	O
;	O
case	O
'U'	O
:	O
break	O
;	O
case	O
'u'	O
:	O
break	O
;	O
case	O
'V'	O
:	O
show_version	int
=	O
1	int
;	O
break	O
;	O
case	O
'a'	O
:	O
binary_files	enum
=	O
TEXT_BINARY_FILES	int
;	O
break	O
;	O
case	O
'b'	O
:	O
out_byte	int
=	O
1	int
;	O
break	O
;	O
case	O
'c'	O
:	O
count_matches	int
=	O
1	int
;	O
break	O
;	O
case	O
'd'	O
:	O
directories	enum
=	O
XARGMATCH	O
(	O
"--directories"	pointer
,	O
optarg	pointer
,	O
directories_args	array
,	O
directories_types	array
)	O
;	O
break	O
;	O
case	O
'e'	O
:	O
cc	int
=	O
strlen	function
(	O
optarg	pointer
)	O
;	O
keys	pointer
=	O
xrealloc	function
(	O
keys	pointer
,	O
keycc	long
+	O
cc	int
+	O
1	int
)	O
;	O
strcpy	function
(	O
&	O
keys	pointer
[	O
keycc	long
]	O
,	O
optarg	pointer
)	O
;	O
keycc	long
+=	O
cc	int
;	O
keys	pointer
[	O
keycc	long
++	O
]	O
=	O
'\n'	O
;	O
break	O
;	O
case	O
'f'	O
:	O
fp	pointer
=	O
STREQ	O
(	O
optarg	pointer
,	O
"-"	pointer
)	O
?	O
stdin	pointer
:	O
fopen	function
(	O
optarg	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
!	O
fp	pointer
)	O
error	function
(	O
EXIT_TROUBLE	int
,	O
errno	O
,	O
"%s"	pointer
,	O
optarg	pointer
)	O
;	O
for	O
(	O
keyalloc	long
=	O
1	int
;	O
keyalloc	long
<=	O
keycc	long
+	O
1	int
;	O
keyalloc	long
*=	O
2	int
)	O
;	O
keys	pointer
=	O
xrealloc	function
(	O
keys	pointer
,	O
keyalloc	long
)	O
;	O
oldcc	long
=	O
keycc	long
;	O
while	O
(	O
!	O
feof	function
(	O
fp	pointer
)	O
&&	O
(	O
cc	int
=	O
fread	function
(	O
keys	pointer
+	O
keycc	long
,	O
1	int
,	O
keyalloc	long
-	O
1	int
-	O
keycc	long
,	O
fp	pointer
)	O
)	O
>	O
0	int
)	O
{	O
keycc	long
+=	O
cc	int
;	O
if	O
(	O
keycc	long
==	O
keyalloc	long
-	O
1	int
)	O
keys	pointer
=	O
xrealloc	function
(	O
keys	pointer
,	O
keyalloc	long
*=	O
2	int
)	O
;	O
}	O
if	O
(	O
fp	pointer
!=	O
stdin	pointer
)	O
fclose	function
(	O
fp	pointer
)	O
;	O
if	O
(	O
oldcc	long
!=	O
keycc	long
&&	O
keys	pointer
[	O
keycc	long
-	O
1	int
]	O
!=	O
'\n'	O
)	O
keys	pointer
[	O
keycc	long
++	O
]	O
=	O
'\n'	O
;	O
break	O
;	O
case	O
'h'	O
:	O
with_filenames	int
=	O
0	int
;	O
no_filenames	int
=	O
1	int
;	O
break	O
;	O
case	O
'i'	O
:	O
case	O
'y'	O
:	O
match_icase	int
=	O
1	int
;	O
break	O
;	O
case	O
'L'	O
:	O
list_files	int
=	O
-	O
1	int
;	O
break	O
;	O
case	O
'l'	O
:	O
list_files	int
=	O
1	int
;	O
break	O
;	O
case	O
'm'	O
:	O
{	O
uintmax_t	long
value	pointer
;	O
switch	O
(	O
xstrtoumax	function
(	O
optarg	pointer
,	O
0	int
,	O
10	int
,	O
&	O
value	pointer
,	O
""	pointer
)	O
)	O
{	O
case	O
LONGINT_OK	int
:	O
max_count	long
=	O
value	pointer
;	O
if	O
(	O
0	int
<=	O
max_count	long
&&	O
max_count	long
==	O
value	pointer
)	O
break	O
;	O
case	O
LONGINT_OVERFLOW	int
:	O
max_count	long
=	O
TYPE_MAXIMUM	O
(	O
off_t	long
)	O
;	O
break	O
;	O
default	O
:	O
error	function
(	O
EXIT_TROUBLE	int
,	O
0	int
,	O
_	O
(	O
"invalid max count"	pointer
)	O
)	O
;	O
}	O
}	O
break	O
;	O
case	O
'n'	O
:	O
out_line	int
=	O
1	int
;	O
break	O
;	O
case	O
'o'	O
:	O
only_matching	int
=	O
1	int
;	O
break	O
;	O
case	O
'q'	O
:	O
exit_on_match	int
=	O
1	int
;	O
exit_failure	int
=	O
0	int
;	O
break	O
;	O
case	O
'R'	O
:	O
case	O
'r'	O
:	O
directories	enum
=	O
RECURSE_DIRECTORIES	int
;	O
break	O
;	O
case	O
's'	O
:	O
suppress_errors	int
=	O
1	int
;	O
break	O
;	O
case	O
'v'	O
:	O
out_invert	int
=	O
1	int
;	O
break	O
;	O
case	O
'w'	O
:	O
match_words	int
=	O
1	int
;	O
break	O
;	O
case	O
'x'	O
:	O
match_lines	int
=	O
1	int
;	O
break	O
;	O
case	O
'Z'	O
:	O
filename_mask	int
=	O
0	int
;	O
break	O
;	O
case	O
'z'	O
:	O
eolbyte	char
=	O
'\0'	O
;	O
break	O
;	O
case	O
BINARY_FILES_OPTION	int
:	O
if	O
(	O
STREQ	O
(	O
optarg	pointer
,	O
"binary"	pointer
)	O
)	O
binary_files	enum
=	O
BINARY_BINARY_FILES	int
;	O
else	O
if	O
(	O
STREQ	O
(	O
optarg	pointer
,	O
"text"	pointer
)	O
)	O
binary_files	enum
=	O
TEXT_BINARY_FILES	int
;	O
else	O
if	O
(	O
STREQ	O
(	O
optarg	pointer
,	O
"without-match"	pointer
)	O
)	O
binary_files	enum
=	O
WITHOUT_MATCH_BINARY_FILES	int
;	O
else	O
error	function
(	O
EXIT_TROUBLE	int
,	O
0	int
,	O
_	O
(	O
"unknown binary-files type"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
COLOR_OPTION	int
:	O
if	O
(	O
optarg	pointer
)	O
{	O
if	O
(	O
!	O
strcasecmp	function
(	O
optarg	pointer
,	O
"always"	pointer
)	O
||	O
!	O
strcasecmp	function
(	O
optarg	pointer
,	O
"yes"	pointer
)	O
||	O
!	O
strcasecmp	function
(	O
optarg	pointer
,	O
"force"	pointer
)	O
)	O
color_option	int
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strcasecmp	function
(	O
optarg	pointer
,	O
"never"	pointer
)	O
||	O
!	O
strcasecmp	function
(	O
optarg	pointer
,	O
"no"	pointer
)	O
||	O
!	O
strcasecmp	function
(	O
optarg	pointer
,	O
"none"	pointer
)	O
)	O
color_option	int
=	O
0	int
;	O
else	O
if	O
(	O
!	O
strcasecmp	function
(	O
optarg	pointer
,	O
"auto"	pointer
)	O
||	O
!	O
strcasecmp	function
(	O
optarg	pointer
,	O
"tty"	pointer
)	O
||	O
!	O
strcasecmp	function
(	O
optarg	pointer
,	O
"if-tty"	pointer
)	O
)	O
color_option	int
=	O
2	int
;	O
else	O
show_help	int
=	O
1	int
;	O
}	O
else	O
color_option	int
=	O
2	int
;	O
if	O
(	O
color_option	int
==	O
2	int
)	O
{	O
char	O
const	O
*	O
t	pointer
;	O
if	O
(	O
isatty	function
(	O
STDOUT_FILENO	int
)	O
&&	O
(	O
t	pointer
=	O
getenv	function
(	O
"TERM"	pointer
)	O
)	O
&&	O
!	O
STREQ	O
(	O
t	pointer
,	O
"dumb"	pointer
)	O
)	O
color_option	int
=	O
1	int
;	O
else	O
color_option	int
=	O
0	int
;	O
}	O
break	O
;	O
case	O
EXCLUDE_OPTION	int
:	O
if	O
(	O
!	O
excluded_patterns	pointer
)	O
excluded_patterns	pointer
=	O
new_exclude	function
(	O
)	O
;	O
add_exclude	function
(	O
excluded_patterns	pointer
,	O
optarg	pointer
,	O
EXCLUDE_WILDCARDS	O
)	O
;	O
break	O
;	O
case	O
EXCLUDE_FROM_OPTION	int
:	O
if	O
(	O
!	O
excluded_patterns	pointer
)	O
excluded_patterns	pointer
=	O
new_exclude	function
(	O
)	O
;	O
if	O
(	O
add_exclude_file	function
(	O
add_exclude	function
,	O
excluded_patterns	pointer
,	O
optarg	pointer
,	O
EXCLUDE_WILDCARDS	O
,	O
'\n'	O
)	O
!=	O
0	int
)	O
{	O
error	function
(	O
EXIT_TROUBLE	int
,	O
errno	O
,	O
"%s"	pointer
,	O
optarg	pointer
)	O
;	O
}	O
break	O
;	O
case	O
EXCLUDE_DIRECTORY_OPTION	int
:	O
if	O
(	O
!	O
excluded_directory_patterns	pointer
)	O
excluded_directory_patterns	pointer
=	O
new_exclude	function
(	O
)	O
;	O
add_exclude	function
(	O
excluded_directory_patterns	pointer
,	O
optarg	pointer
,	O
EXCLUDE_WILDCARDS	O
)	O
;	O
break	O
;	O
case	O
INCLUDE_OPTION	int
:	O
if	O
(	O
!	O
included_patterns	pointer
)	O
included_patterns	pointer
=	O
new_exclude	function
(	O
)	O
;	O
add_exclude	function
(	O
included_patterns	pointer
,	O
optarg	pointer
,	O
EXCLUDE_WILDCARDS	O
|	O
EXCLUDE_INCLUDE	O
)	O
;	O
break	O
;	O
case	O
GROUP_SEPARATOR_OPTION	int
:	O
group_separator	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
LINE_BUFFERED_OPTION	int
:	O
line_buffered	int
=	O
1	int
;	O
break	O
;	O
case	O
LABEL_OPTION	int
:	O
label	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
MMAP_OPTION	int
:	O
case	O
0	int
:	O
break	O
;	O
default	O
:	O
usage	function
(	O
EXIT_TROUBLE	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
exit_on_match	int
)	O
list_files	int
=	O
0	int
;	O
if	O
(	O
exit_on_match	int
|	O
list_files	int
)	O
{	O
count_matches	int
=	O
0	int
;	O
done_on_match	int
=	O
1	int
;	O
}	O
out_quiet	int
=	O
count_matches	int
|	O
done_on_match	int
;	O
if	O
(	O
out_after	int
<	O
0	int
)	O
out_after	int
=	O
default_context	pointer
;	O
if	O
(	O
out_before	int
<	O
0	int
)	O
out_before	int
=	O
default_context	pointer
;	O
if	O
(	O
color_option	int
)	O
{	O
char	O
*	O
userval	pointer
=	O
getenv	function
(	O
"GREP_COLOR"	pointer
)	O
;	O
if	O
(	O
userval	pointer
!=	O
NULL	O
&&	O
*	O
userval	pointer
!=	O
'\0'	O
)	O
selected_match_color	pointer
=	O
context_match_color	pointer
=	O
userval	pointer
;	O
parse_grep_colors	function
(	O
)	O
;	O
}	O
if	O
(	O
show_version	int
)	O
{	O
version_etc	function
(	O
stdout	pointer
,	O
program_name	pointer
,	O
PACKAGE_NAME	pointer
,	O
VERSION	pointer
,	O
AUTHORS	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
if	O
(	O
show_help	int
)	O
usage	function
(	O
EXIT_SUCCESS	int
)	O
;	O
if	O
(	O
keys	pointer
)	O
{	O
if	O
(	O
keycc	long
==	O
0	int
)	O
{	O
out_invert	int
^=	O
1	int
;	O
match_lines	int
=	O
match_words	int
=	O
0	int
;	O
}	O
else	O
--	O
keycc	long
;	O
}	O
else	O
if	O
(	O
optind	int
<	O
argc	int
)	O
{	O
keycc	long
=	O
strlen	function
(	O
argv	pointer
[	O
optind	int
]	O
)	O
;	O
keys	pointer
=	O
xmalloc	function
(	O
keycc	long
+	O
1	int
)	O
;	O
strcpy	function
(	O
keys	pointer
,	O
argv	pointer
[	O
optind	int
++	O
]	O
)	O
;	O
}	O
else	O
usage	function
(	O
EXIT_TROUBLE	int
)	O
;	O
set_limits	function
(	O
)	O
;	O
compile	pointer
(	O
keys	pointer
,	O
keycc	long
)	O
;	O
free	function
(	O
keys	pointer
)	O
;	O
if	O
(	O
(	O
argc	int
-	O
optind	int
>	O
1	int
&&	O
!	O
no_filenames	int
)	O
||	O
with_filenames	int
)	O
out_file	int
=	O
1	int
;	O
if	O
(	O
!	O
isatty	function
(	O
1	int
)	O
)	O
SET_BINARY	O
(	O
1	int
)	O
;	O
if	O
(	O
max_count	long
==	O
0	int
)	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
if	O
(	O
optind	int
<	O
argc	int
)	O
{	O
status	int
=	O
1	int
;	O
do	O
{	O
char	O
*	O
file	pointer
=	O
argv	pointer
[	O
optind	int
]	O
;	O
if	O
(	O
(	O
included_patterns	pointer
||	O
excluded_patterns	pointer
)	O
&&	O
!	O
isdir	function
(	O
file	pointer
)	O
)	O
{	O
if	O
(	O
included_patterns	pointer
&&	O
excluded_file_name	function
(	O
included_patterns	pointer
,	O
file	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
excluded_patterns	pointer
&&	O
excluded_file_name	function
(	O
excluded_patterns	pointer
,	O
file	pointer
)	O
)	O
continue	O
;	O
}	O
status	int
&=	O
grepfile	function
(	O
STREQ	O
(	O
file	pointer
,	O
"-"	pointer
)	O
?	O
(	O
char	O
*	O
)	O
NULL	O
:	O
file	pointer
,	O
&	O
stats_base	struct
)	O
;	O
}	O
while	O
(	O
++	O
optind	int
<	O
argc	int
)	O
;	O
}	O
else	O
status	int
=	O
grepfile	function
(	O
(	O
char	O
*	O
)	O
NULL	O
,	O
&	O
stats_base	struct
)	O
;	O
exit	function
(	O
errseen	int
?	O
EXIT_TROUBLE	int
:	O
status	int
)	O
;	O
}	O
