static	O
char	O
rcsid	array
[	O
]	O
=	O
"$Id: rpc_util.c,v 1.1.1.1 2005/10/28 14:46:46 k0ro Exp $"	pointer
;	O
char	O
curline	array
[	O
MAXLINESIZE	int
]	O
;	O
char	O
*	O
where	pointer
=	O
curline	array
;	O
int	O
linenum	int
=	O
0	int
;	O
char	O
*	O
infilename	pointer
;	O
char	O
*	O
outfiles	array
[	O
NFILES	int
]	O
;	O
int	O
nfiles	int
;	O
FILE	struct
*	O
fout	pointer
;	O
FILE	struct
*	O
fin	pointer
;	O
list	struct
*	O
defined	pointer
;	O
static	O
void	O
printwhere	function
(	O
)	O
;	O
void	O
crash	function
(	O
)	O
;	O
void	O
reinitialize	function
(	O
)	O
{	O
memset	O
(	O
curline	array
,	O
0	int
,	O
MAXLINESIZE	int
)	O
;	O
where	pointer
=	O
curline	array
;	O
linenum	int
=	O
0	int
;	O
defined	pointer
=	O
NULL	O
;	O
}	O
streq	function
(	O
a	pointer
,	O
b	pointer
)	O
char	O
*	O
a	pointer
;	O
char	O
*	O
b	pointer
;	O
{	O
return	O
(	O
strcmp	O
(	O
a	pointer
,	O
b	pointer
)	O
==	O
0	int
)	O
;	O
}	O
char	O
*	O
findval	function
(	O
lst	pointer
,	O
val	pointer
,	O
cmp	pointer
)	O
list	struct
*	O
lst	pointer
;	O
char	O
*	O
val	pointer
;	O
int	O
(	O
*	O
cmp	pointer
)	O
(	O
)	O
;	O
{	O
for	O
(	O
;	O
lst	pointer
!=	O
NULL	O
;	O
lst	pointer
=	O
lst	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
(	O
*	O
cmp	pointer
)	O
(	O
lst	pointer
->	O
val	pointer
,	O
val	pointer
)	O
)	O
{	O
return	O
(	O
lst	pointer
->	O
val	pointer
)	O
;	O
}	O
}	O
return	O
(	O
NULL	O
)	O
;	O
}	O
void	O
storeval	function
(	O
lstp	pointer
,	O
val	pointer
)	O
list	struct
*	O
*	O
lstp	pointer
;	O
char	O
*	O
val	pointer
;	O
{	O
list	struct
*	O
*	O
l	pointer
;	O
list	struct
*	O
lst	pointer
;	O
for	O
(	O
l	pointer
=	O
lstp	pointer
;	O
*	O
l	pointer
!=	O
NULL	O
;	O
l	pointer
=	O
(	O
list	struct
*	O
*	O
)	O
&	O
(	O
*	O
l	pointer
)	O
->	O
next	pointer
)	O
;	O
lst	pointer
=	O
ALLOC	O
(	O
list	struct
)	O
;	O
lst	pointer
->	O
val	pointer
=	O
val	pointer
;	O
lst	pointer
->	O
next	pointer
=	O
NULL	O
;	O
*	O
l	pointer
=	O
lst	pointer
;	O
}	O
static	O
findit	function
(	O
def	union
,	O
type	pointer
)	O
definition	struct
*	O
def	union
;	O
char	O
*	O
type	pointer
;	O
{	O
return	O
(	O
streq	function
(	O
def	union
->	O
def_name	pointer
,	O
type	pointer
)	O
)	O
;	O
}	O
static	O
char	O
*	O
fixit	function
(	O
type	pointer
,	O
orig	pointer
)	O
char	O
*	O
type	pointer
;	O
char	O
*	O
orig	pointer
;	O
{	O
definition	struct
*	O
def	union
;	O
def	union
=	O
(	O
definition	struct
*	O
)	O
FINDVAL	O
(	O
defined	pointer
,	O
type	pointer
,	O
findit	function
)	O
;	O
if	O
(	O
def	union
==	O
NULL	O
||	O
def	union
->	O
def_kind	enum
!=	O
DEF_TYPEDEF	int
)	O
{	O
return	O
(	O
orig	pointer
)	O
;	O
}	O
switch	O
(	O
def	union
->	O
def	union
.	O
ty	struct
.	O
rel	enum
)	O
{	O
case	O
REL_VECTOR	int
:	O
return	O
(	O
def	union
->	O
def	union
.	O
ty	struct
.	O
old_type	pointer
)	O
;	O
case	O
REL_ALIAS	int
:	O
return	O
(	O
fixit	function
(	O
def	union
->	O
def	union
.	O
ty	struct
.	O
old_type	pointer
,	O
orig	pointer
)	O
)	O
;	O
default	O
:	O
return	O
(	O
orig	pointer
)	O
;	O
}	O
}	O
char	O
*	O
fixtype	function
(	O
type	pointer
)	O
char	O
*	O
type	pointer
;	O
{	O
return	O
(	O
fixit	function
(	O
type	pointer
,	O
type	pointer
)	O
)	O
;	O
}	O
char	O
*	O
stringfix	function
(	O
type	pointer
)	O
char	O
*	O
type	pointer
;	O
{	O
if	O
(	O
streq	function
(	O
type	pointer
,	O
"string"	pointer
)	O
)	O
{	O
return	O
(	O
"wrapstring"	pointer
)	O
;	O
}	O
else	O
{	O
return	O
(	O
type	pointer
)	O
;	O
}	O
}	O
void	O
ptype	function
(	O
prefix	pointer
,	O
type	pointer
,	O
follow	int
)	O
char	O
*	O
prefix	pointer
;	O
char	O
*	O
type	pointer
;	O
int	O
follow	int
;	O
{	O
if	O
(	O
prefix	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
streq	function
(	O
prefix	pointer
,	O
"enum"	pointer
)	O
)	O
{	O
f_print	O
(	O
fout	pointer
,	O
"enum "	pointer
)	O
;	O
}	O
else	O
{	O
f_print	O
(	O
fout	pointer
,	O
"struct "	pointer
)	O
;	O
}	O
}	O
if	O
(	O
streq	function
(	O
type	pointer
,	O
"bool"	pointer
)	O
)	O
{	O
f_print	O
(	O
fout	pointer
,	O
"bool_t "	pointer
)	O
;	O
}	O
else	O
if	O
(	O
streq	function
(	O
type	pointer
,	O
"string"	pointer
)	O
)	O
{	O
f_print	O
(	O
fout	pointer
,	O
"char *"	pointer
)	O
;	O
}	O
else	O
{	O
f_print	O
(	O
fout	pointer
,	O
"%s "	pointer
,	O
follow	int
?	O
fixtype	function
(	O
type	pointer
)	O
:	O
type	pointer
)	O
;	O
}	O
}	O
static	O
typedefed	function
(	O
def	union
,	O
type	pointer
)	O
definition	struct
*	O
def	union
;	O
char	O
*	O
type	pointer
;	O
{	O
if	O
(	O
def	union
->	O
def_kind	enum
!=	O
DEF_TYPEDEF	int
||	O
def	union
->	O
def	union
.	O
ty	struct
.	O
old_prefix	pointer
!=	O
NULL	O
)	O
{	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
{	O
return	O
(	O
streq	function
(	O
def	union
->	O
def_name	pointer
,	O
type	pointer
)	O
)	O
;	O
}	O
}	O
isvectordef	function
(	O
type	pointer
,	O
rel	enum
)	O
char	O
*	O
type	pointer
;	O
relation	enum
rel	enum
;	O
{	O
definition	struct
*	O
def	union
;	O
for	O
(	O
;	O
;	O
)	O
{	O
switch	O
(	O
rel	enum
)	O
{	O
case	O
REL_VECTOR	int
:	O
return	O
(	O
!	O
streq	function
(	O
type	pointer
,	O
"string"	pointer
)	O
)	O
;	O
case	O
REL_ARRAY	int
:	O
case	O
REL_ARRAY2	int
:	O
return	O
(	O
0	int
)	O
;	O
case	O
REL_POINTER	int
:	O
return	O
(	O
0	int
)	O
;	O
case	O
REL_ALIAS	int
:	O
def	union
=	O
(	O
definition	struct
*	O
)	O
FINDVAL	O
(	O
defined	pointer
,	O
type	pointer
,	O
typedefed	function
)	O
;	O
if	O
(	O
def	union
==	O
NULL	O
)	O
{	O
return	O
(	O
0	int
)	O
;	O
}	O
type	pointer
=	O
def	union
->	O
def	union
.	O
ty	struct
.	O
old_type	pointer
;	O
rel	enum
=	O
def	union
->	O
def	union
.	O
ty	struct
.	O
rel	enum
;	O
}	O
}	O
}	O
static	O
char	O
*	O
locase	function
(	O
str	pointer
)	O
char	O
*	O
str	pointer
;	O
{	O
char	O
c	char
;	O
static	O
char	O
buf	array
[	O
100	int
]	O
;	O
char	O
*	O
p	pointer
=	O
buf	array
;	O
while	O
(	O
c	char
=	O
*	O
str	pointer
++	O
)	O
{	O
*	O
p	pointer
++	O
=	O
(	O
c	char
>=	O
'A'	O
&&	O
c	char
<=	O
'Z'	O
)	O
?	O
(	O
c	char
-	O
'A'	O
+	O
'a'	O
)	O
:	O
c	char
;	O
}	O
*	O
p	pointer
=	O
0	int
;	O
return	O
(	O
buf	array
)	O
;	O
}	O
void	O
pvname	function
(	O
pname	pointer
,	O
vnum	pointer
)	O
char	O
*	O
pname	pointer
;	O
char	O
*	O
vnum	pointer
;	O
{	O
f_print	O
(	O
fout	pointer
,	O
"%s_%s"	pointer
,	O
locase	function
(	O
pname	pointer
)	O
,	O
vnum	pointer
)	O
;	O
}	O
void	O
error	function
(	O
msg	pointer
)	O
char	O
*	O
msg	pointer
;	O
{	O
printwhere	function
(	O
)	O
;	O
f_print	O
(	O
stderr	pointer
,	O
"%s, line %d: "	pointer
,	O
infilename	pointer
,	O
linenum	int
)	O
;	O
f_print	O
(	O
stderr	pointer
,	O
"%s\n"	pointer
,	O
msg	pointer
)	O
;	O
crash	function
(	O
)	O
;	O
}	O
void	O
crash	function
(	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nfiles	int
;	O
i	int
++	O
)	O
{	O
(	O
void	O
)	O
unlink	function
(	O
outfiles	array
[	O
i	int
]	O
)	O
;	O
}	O
exit	function
(	O
1	int
)	O
;	O
}	O
void	O
record_open	function
(	O
file	pointer
)	O
char	O
*	O
file	pointer
;	O
{	O
if	O
(	O
nfiles	int
<	O
NFILES	int
)	O
{	O
outfiles	array
[	O
nfiles	int
++	O
]	O
=	O
file	pointer
;	O
}	O
else	O
{	O
f_print	O
(	O
stderr	pointer
,	O
"too many files!\n"	pointer
)	O
;	O
crash	function
(	O
)	O
;	O
}	O
}	O
static	O
char	O
expectbuf	array
[	O
100	int
]	O
;	O
static	O
char	O
*	O
toktostr	function
(	O
)	O
;	O
void	O
expected1	function
(	O
exp1	enum
)	O
tok_kind	enum
exp1	enum
;	O
{	O
s_print	O
(	O
expectbuf	array
,	O
"expected '%s'"	pointer
,	O
toktostr	function
(	O
exp1	enum
)	O
)	O
;	O
error	function
(	O
expectbuf	array
)	O
;	O
}	O
void	O
expected2	function
(	O
exp1	enum
,	O
exp2	enum
)	O
tok_kind	enum
exp1	enum
,	O
exp2	enum
;	O
{	O
s_print	O
(	O
expectbuf	array
,	O
"expected '%s' or '%s'"	pointer
,	O
toktostr	function
(	O
exp1	enum
)	O
,	O
toktostr	function
(	O
exp2	enum
)	O
)	O
;	O
error	function
(	O
expectbuf	array
)	O
;	O
}	O
void	O
expected3	function
(	O
exp1	enum
,	O
exp2	enum
,	O
exp3	enum
)	O
tok_kind	enum
exp1	enum
,	O
exp2	enum
,	O
exp3	enum
;	O
{	O
s_print	O
(	O
expectbuf	array
,	O
"expected '%s', '%s' or '%s'"	pointer
,	O
toktostr	function
(	O
exp1	enum
)	O
,	O
toktostr	function
(	O
exp2	enum
)	O
,	O
toktostr	function
(	O
exp3	enum
)	O
)	O
;	O
error	function
(	O
expectbuf	array
)	O
;	O
}	O
void	O
tabify	function
(	O
f	pointer
,	O
tab	int
)	O
FILE	struct
*	O
f	pointer
;	O
int	O
tab	int
;	O
{	O
while	O
(	O
tab	int
--	O
)	O
{	O
(	O
void	O
)	O
fputc	function
(	O
'\t'	O
,	O
f	pointer
)	O
;	O
}	O
}	O
static	O
token	struct
tokstrings	array
[	O
]	O
=	O
{	O
{	O
TOK_IDENT	int
,	O
"identifier"	pointer
}	O
,	O
{	O
TOK_CONST	int
,	O
"const"	pointer
}	O
,	O
{	O
TOK_RPAREN	int
,	O
")"	pointer
}	O
,	O
{	O
TOK_LPAREN	int
,	O
"("	pointer
}	O
,	O
{	O
TOK_RBRACE	int
,	O
"}"	pointer
}	O
,	O
{	O
TOK_LBRACE	int
,	O
"{"	pointer
}	O
,	O
{	O
TOK_LBRACKET	int
,	O
"["	pointer
}	O
,	O
{	O
TOK_RBRACKET	int
,	O
"]"	pointer
}	O
,	O
{	O
TOK_STAR	int
,	O
"*"	pointer
}	O
,	O
{	O
TOK_COMMA	int
,	O
","	pointer
}	O
,	O
{	O
TOK_EQUAL	int
,	O
"="	pointer
}	O
,	O
{	O
TOK_COLON	int
,	O
":"	pointer
}	O
,	O
{	O
TOK_SEMICOLON	int
,	O
";"	pointer
}	O
,	O
{	O
TOK_UNION	int
,	O
"union"	pointer
}	O
,	O
{	O
TOK_STRUCT	int
,	O
"struct"	pointer
}	O
,	O
{	O
TOK_SWITCH	int
,	O
"switch"	pointer
}	O
,	O
{	O
TOK_CASE	int
,	O
"case"	pointer
}	O
,	O
{	O
TOK_DEFAULT	int
,	O
"default"	pointer
}	O
,	O
{	O
TOK_ENUM	int
,	O
"enum"	pointer
}	O
,	O
{	O
TOK_TYPEDEF	int
,	O
"typedef"	pointer
}	O
,	O
{	O
TOK_INT	int
,	O
"int"	pointer
}	O
,	O
{	O
TOK_SHORT	int
,	O
"short"	pointer
}	O
,	O
{	O
TOK_LONG	int
,	O
"long"	pointer
}	O
,	O
{	O
TOK_UNSIGNED	int
,	O
"unsigned"	pointer
}	O
,	O
{	O
TOK_DOUBLE	int
,	O
"double"	pointer
}	O
,	O
{	O
TOK_FLOAT	int
,	O
"float"	pointer
}	O
,	O
{	O
TOK_CHAR	int
,	O
"char"	pointer
}	O
,	O
{	O
TOK_STRING	int
,	O
"string"	pointer
}	O
,	O
{	O
TOK_OPAQUE	int
,	O
"opaque"	pointer
}	O
,	O
{	O
TOK_BOOL	int
,	O
"bool"	pointer
}	O
,	O
{	O
TOK_VOID	int
,	O
"void"	pointer
}	O
,	O
{	O
TOK_PROGRAM	int
,	O
"program"	pointer
}	O
,	O
{	O
TOK_VERSION	int
,	O
"version"	pointer
}	O
,	O
{	O
TOK_EOF	int
,	O
"??????"	pointer
}	O
}	O
;	O
static	O
char	O
*	O
toktostr	function
(	O
kind	enum
)	O
tok_kind	enum
kind	enum
;	O
{	O
token	struct
*	O
sp	pointer
;	O
for	O
(	O
sp	pointer
=	O
tokstrings	array
;	O
sp	pointer
->	O
kind	enum
!=	O
TOK_EOF	int
&&	O
sp	pointer
->	O
kind	enum
!=	O
kind	enum
;	O
sp	pointer
++	O
)	O
;	O
return	O
(	O
sp	pointer
->	O
str	pointer
)	O
;	O
}	O
static	O
void	O
printbuf	function
(	O
)	O
{	O
char	O
c	char
;	O
int	O
i	int
;	O
int	O
cnt	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
c	char
=	O
curline	array
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
c	char
==	O
'\t'	O
)	O
{	O
cnt	int
=	O
8	int
-	O
(	O
i	int
%	O
TABSIZE	int
)	O
;	O
c	char
=	O
' '	O
;	O
}	O
else	O
{	O
cnt	int
=	O
1	int
;	O
}	O
while	O
(	O
cnt	int
--	O
)	O
{	O
(	O
void	O
)	O
fputc	function
(	O
c	char
,	O
stderr	pointer
)	O
;	O
}	O
}	O
}	O
static	O
void	O
printwhere	function
(	O
)	O
{	O
int	O
i	int
;	O
char	O
c	char
;	O
int	O
cnt	int
;	O
printbuf	function
(	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
where	pointer
-	O
curline	array
;	O
i	int
++	O
)	O
{	O
c	char
=	O
curline	array
[	O
i	int
]	O
;	O
if	O
(	O
c	char
==	O
'\t'	O
)	O
{	O
cnt	int
=	O
8	int
-	O
(	O
i	int
%	O
TABSIZE	int
)	O
;	O
}	O
else	O
{	O
cnt	int
=	O
1	int
;	O
}	O
while	O
(	O
cnt	int
--	O
)	O
{	O
(	O
void	O
)	O
fputc	function
(	O
'^'	O
,	O
stderr	pointer
)	O
;	O
}	O
}	O
(	O
void	O
)	O
fputc	function
(	O
'\n'	O
,	O
stderr	pointer
)	O
;	O
}	O
