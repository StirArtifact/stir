bfd_boolean	int
report_plugin_symbols	int
;	O
typedef	O
struct	O
plugin_arg	struct
{	O
struct	O
plugin_arg	struct
*	O
next	pointer
;	O
const	O
char	O
*	O
arg	pointer
;	O
}	O
plugin_arg_t	struct
;	O
typedef	O
struct	O
plugin	pointer
{	O
struct	O
plugin	pointer
*	O
next	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
void	O
*	O
dlhandle	pointer
;	O
plugin_arg_t	struct
*	O
args	pointer
;	O
size_t	long
n_args	long
;	O
ld_plugin_claim_file_handler	pointer
claim_file_handler	pointer
;	O
ld_plugin_all_symbols_read_handler	pointer
all_symbols_read_handler	pointer
;	O
ld_plugin_cleanup_handler	pointer
cleanup_handler	pointer
;	O
bfd_boolean	int
cleanup_done	int
;	O
}	O
plugin_t	struct
;	O
typedef	O
struct	O
view_buffer	struct
{	O
char	O
*	O
addr	pointer
;	O
size_t	long
filesize	long
;	O
off_t	long
offset	long
;	O
}	O
view_buffer_t	struct
;	O
typedef	O
struct	O
plugin_input_file	struct
{	O
bfd	struct
*	O
abfd	pointer
;	O
view_buffer_t	struct
view_buffer	struct
;	O
char	O
*	O
name	pointer
;	O
int	O
fd	int
;	O
bfd_boolean	int
use_mmap	int
;	O
off_t	long
offset	long
;	O
off_t	long
filesize	long
;	O
}	O
plugin_input_file_t	struct
;	O
static	O
plugin_t	struct
*	O
plugins_list	pointer
=	O
NULL	O
;	O
static	O
plugin_t	struct
*	O
*	O
plugins_tail_chain_ptr	pointer
=	O
&	O
plugins_list	pointer
;	O
static	O
plugin_t	struct
*	O
last_plugin	pointer
=	O
NULL	O
;	O
static	O
plugin_arg_t	struct
*	O
*	O
last_plugin_args_tail_chain_ptr	pointer
=	O
NULL	O
;	O
static	O
plugin_t	struct
*	O
called_plugin	pointer
=	O
NULL	O
;	O
static	O
const	O
char	O
*	O
error_plugin	pointer
=	O
NULL	O
;	O
static	O
bfd_boolean	int
orig_notice_all	int
;	O
static	O
const	O
struct	O
bfd_link_callbacks	struct
*	O
orig_callbacks	pointer
;	O
static	O
struct	O
bfd_link_callbacks	struct
plugin_callbacks	struct
;	O
bfd_boolean	int
no_more_claiming	int
=	O
FALSE	int
;	O
static	O
off_t	long
plugin_pagesize	long
;	O
static	O
const	O
enum	O
ld_plugin_tag	enum
tv_header_tags	array
[	O
]	O
=	O
{	O
LDPT_MESSAGE	int
,	O
LDPT_API_VERSION	int
,	O
LDPT_GNU_LD_VERSION	int
,	O
LDPT_LINKER_OUTPUT	int
,	O
LDPT_OUTPUT_NAME	int
,	O
LDPT_REGISTER_CLAIM_FILE_HOOK	int
,	O
LDPT_REGISTER_ALL_SYMBOLS_READ_HOOK	int
,	O
LDPT_REGISTER_CLEANUP_HOOK	int
,	O
LDPT_ADD_SYMBOLS	int
,	O
LDPT_GET_INPUT_FILE	int
,	O
LDPT_GET_VIEW	int
,	O
LDPT_RELEASE_INPUT_FILE	int
,	O
LDPT_GET_SYMBOLS	int
,	O
LDPT_GET_SYMBOLS_V2	int
,	O
LDPT_ADD_INPUT_FILE	int
,	O
LDPT_ADD_INPUT_LIBRARY	int
,	O
LDPT_SET_EXTRA_LIBRARY_PATH	int
}	O
;	O
static	O
const	O
size_t	long
tv_header_size	long
=	O
ARRAY_SIZE	O
(	O
tv_header_tags	array
)	O
;	O
static	O
bfd_boolean	int
plugin_notice	function
(	O
struct	O
bfd_link_info	struct
*	O
,	O
struct	O
bfd_link_hash_entry	struct
*	O
,	O
struct	O
bfd_link_hash_entry	struct
*	O
,	O
bfd	struct
*	O
,	O
asection	struct
*	O
,	O
bfd_vma	long
,	O
flagword	int
)	O
;	O
static	O
const	O
bfd_target	struct
*	O
plugin_object_p	function
(	O
bfd	struct
*	O
)	O
;	O
static	O
int	O
set_plugin_error	function
(	O
const	O
char	O
*	O
plugin	pointer
)	O
{	O
error_plugin	pointer
=	O
plugin	pointer
;	O
return	O
-	O
1	int
;	O
}	O
static	O
bfd_boolean	int
plugin_error_p	function
(	O
void	O
)	O
{	O
return	O
error_plugin	pointer
!=	O
NULL	O
;	O
}	O
const	O
char	O
*	O
plugin_error_plugin	function
(	O
void	O
)	O
{	O
return	O
error_plugin	pointer
?	O
error_plugin	pointer
:	O
_	O
(	O
"<no plugin>"	pointer
)	O
;	O
}	O
void	O
plugin_opt_plugin	function
(	O
const	O
char	O
*	O
plugin	pointer
)	O
{	O
plugin_t	struct
*	O
newplug	pointer
;	O
plugin_t	struct
*	O
curplug	pointer
=	O
plugins_list	pointer
;	O
newplug	pointer
=	O
xmalloc	function
(	O
sizeof	O
*	O
newplug	pointer
)	O
;	O
memset	function
(	O
newplug	pointer
,	O
0	int
,	O
sizeof	O
*	O
newplug	pointer
)	O
;	O
newplug	pointer
->	O
name	pointer
=	O
plugin	pointer
;	O
newplug	pointer
->	O
dlhandle	pointer
=	O
dlopen	function
(	O
plugin	pointer
,	O
RTLD_NOW	int
)	O
;	O
if	O
(	O
!	O
newplug	pointer
->	O
dlhandle	pointer
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: %s: error loading plugin: %s\n"	pointer
)	O
,	O
plugin	pointer
,	O
dlerror	function
(	O
)	O
)	O
;	O
while	O
(	O
curplug	pointer
)	O
{	O
if	O
(	O
newplug	pointer
->	O
dlhandle	pointer
==	O
curplug	pointer
->	O
dlhandle	pointer
)	O
{	O
einfo	pointer
(	O
_	O
(	O
"%P: %s: duplicated plugin\n"	pointer
)	O
,	O
plugin	pointer
)	O
;	O
free	function
(	O
newplug	pointer
)	O
;	O
return	O
;	O
}	O
curplug	pointer
=	O
curplug	pointer
->	O
next	pointer
;	O
}	O
*	O
plugins_tail_chain_ptr	pointer
=	O
newplug	pointer
;	O
plugins_tail_chain_ptr	pointer
=	O
&	O
newplug	pointer
->	O
next	pointer
;	O
last_plugin	pointer
=	O
newplug	pointer
;	O
last_plugin_args_tail_chain_ptr	pointer
=	O
&	O
newplug	pointer
->	O
args	pointer
;	O
}	O
int	O
plugin_opt_plugin_arg	function
(	O
const	O
char	O
*	O
arg	pointer
)	O
{	O
plugin_arg_t	struct
*	O
newarg	pointer
;	O
if	O
(	O
!	O
last_plugin	pointer
)	O
return	O
set_plugin_error	function
(	O
_	O
(	O
"<no plugin>"	pointer
)	O
)	O
;	O
if	O
(	O
*	O
arg	pointer
==	O
'-'	O
)	O
{	O
const	O
char	O
*	O
p	pointer
=	O
arg	pointer
+	O
1	int
;	O
if	O
(	O
*	O
p	pointer
==	O
'-'	O
)	O
++	O
p	pointer
;	O
if	O
(	O
strncmp	function
(	O
p	pointer
,	O
"pass-through="	pointer
,	O
13	int
)	O
==	O
0	int
)	O
return	O
0	int
;	O
}	O
newarg	pointer
=	O
xmalloc	function
(	O
sizeof	O
*	O
newarg	pointer
)	O
;	O
newarg	pointer
->	O
arg	pointer
=	O
arg	pointer
;	O
newarg	pointer
->	O
next	pointer
=	O
NULL	O
;	O
*	O
last_plugin_args_tail_chain_ptr	pointer
=	O
newarg	pointer
;	O
last_plugin_args_tail_chain_ptr	pointer
=	O
&	O
newarg	pointer
->	O
next	pointer
;	O
last_plugin	pointer
->	O
n_args	long
++	O
;	O
return	O
0	int
;	O
}	O
static	O
bfd	struct
*	O
plugin_get_ir_dummy_bfd	function
(	O
const	O
char	O
*	O
name	pointer
,	O
bfd	struct
*	O
srctemplate	pointer
)	O
{	O
bfd	struct
*	O
abfd	pointer
;	O
bfd_boolean	int
bfd_plugin_target	int
;	O
bfd_use_reserved_id	int
=	O
1	int
;	O
bfd_plugin_target	int
=	O
bfd_plugin_target_p	function
(	O
srctemplate	pointer
->	O
xvec	pointer
)	O
;	O
abfd	pointer
=	O
bfd_create	function
(	O
concat	function
(	O
name	pointer
,	O
IRONLY_SUFFIX	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
)	O
,	O
bfd_plugin_target	int
?	O
link_info	struct
.	O
output_bfd	pointer
:	O
srctemplate	pointer
)	O
;	O
if	O
(	O
abfd	pointer
!=	O
NULL	O
)	O
{	O
abfd	pointer
->	O
flags	int
|=	O
BFD_LINKER_CREATED	int
|	O
BFD_PLUGIN	int
;	O
if	O
(	O
!	O
bfd_make_writable	function
(	O
abfd	pointer
)	O
)	O
goto	O
report_error	O
;	O
if	O
(	O
!	O
bfd_plugin_target	int
)	O
{	O
bfd_set_arch_info	function
(	O
abfd	pointer
,	O
bfd_get_arch_info	function
(	O
srctemplate	pointer
)	O
)	O
;	O
bfd_set_gp_size	function
(	O
abfd	pointer
,	O
bfd_get_gp_size	function
(	O
srctemplate	pointer
)	O
)	O
;	O
if	O
(	O
!	O
bfd_copy_private_bfd_data	function
(	O
srctemplate	pointer
,	O
abfd	pointer
)	O
)	O
goto	O
report_error	O
;	O
}	O
{	O
flagword	int
flags	int
;	O
flags	int
=	O
(	O
SEC_CODE	int
|	O
SEC_HAS_CONTENTS	int
|	O
SEC_READONLY	int
|	O
SEC_ALLOC	int
|	O
SEC_LOAD	int
|	O
SEC_KEEP	int
|	O
SEC_EXCLUDE	int
)	O
;	O
if	O
(	O
bfd_make_section_anyway_with_flags	function
(	O
abfd	pointer
,	O
".text"	pointer
,	O
flags	int
)	O
)	O
return	O
abfd	pointer
;	O
}	O
}	O
report_error	O
:	O
einfo	pointer
(	O
_	O
(	O
"%F%P: could not create dummy IR bfd: %E\n"	pointer
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
static	O
inline	O
bfd_boolean	int
is_ir_dummy_bfd	function
(	O
const	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
return	O
abfd	pointer
!=	O
NULL	O
&&	O
(	O
abfd	pointer
->	O
flags	int
&	O
BFD_PLUGIN	int
)	O
!=	O
0	int
;	O
}	O
static	O
enum	O
ld_plugin_status	enum
asymbol_from_plugin_symbol	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asymbol	struct
*	O
asym	pointer
,	O
const	O
struct	O
ld_plugin_symbol	struct
*	O
ldsym	pointer
)	O
{	O
flagword	int
flags	int
=	O
BSF_NO_FLAGS	int
;	O
struct	O
bfd_section	struct
*	O
section	pointer
;	O
asym	pointer
->	O
the_bfd	pointer
=	O
abfd	pointer
;	O
asym	pointer
->	O
name	pointer
=	O
(	O
ldsym	pointer
->	O
version	pointer
?	O
concat	function
(	O
ldsym	pointer
->	O
name	pointer
,	O
"@"	pointer
,	O
ldsym	pointer
->	O
version	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
)	O
:	O
ldsym	pointer
->	O
name	pointer
)	O
;	O
asym	pointer
->	O
value	long
=	O
0	int
;	O
switch	O
(	O
ldsym	pointer
->	O
def	struct
)	O
{	O
case	O
LDPK_WEAKDEF	int
:	O
flags	int
=	O
BSF_WEAK	O
;	O
case	O
LDPK_DEF	int
:	O
flags	int
|=	O
BSF_GLOBAL	O
;	O
if	O
(	O
ldsym	pointer
->	O
comdat_key	pointer
)	O
{	O
char	O
*	O
name	pointer
=	O
concat	function
(	O
".gnu.linkonce.t."	pointer
,	O
ldsym	pointer
->	O
comdat_key	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
)	O
;	O
section	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
section	pointer
!=	O
NULL	O
)	O
free	function
(	O
name	pointer
)	O
;	O
else	O
{	O
flagword	int
sflags	int
;	O
sflags	int
=	O
(	O
SEC_CODE	int
|	O
SEC_HAS_CONTENTS	int
|	O
SEC_READONLY	int
|	O
SEC_ALLOC	int
|	O
SEC_LOAD	int
|	O
SEC_KEEP	int
|	O
SEC_EXCLUDE	int
|	O
SEC_LINK_ONCE	int
|	O
SEC_LINK_DUPLICATES_DISCARD	int
)	O
;	O
section	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
abfd	pointer
,	O
name	pointer
,	O
sflags	int
)	O
;	O
if	O
(	O
section	pointer
==	O
NULL	O
)	O
return	O
LDPS_ERR	int
;	O
}	O
}	O
else	O
section	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".text"	pointer
)	O
;	O
break	O
;	O
case	O
LDPK_WEAKUNDEF	int
:	O
flags	int
=	O
BSF_WEAK	O
;	O
case	O
LDPK_UNDEF	int
:	O
section	pointer
=	O
bfd_und_section_ptr	O
;	O
break	O
;	O
case	O
LDPK_COMMON	int
:	O
flags	int
=	O
BSF_GLOBAL	O
;	O
section	pointer
=	O
bfd_com_section_ptr	O
;	O
asym	pointer
->	O
value	long
=	O
ldsym	pointer
->	O
size	int
;	O
break	O
;	O
default	O
:	O
return	O
LDPS_ERR	int
;	O
}	O
asym	pointer
->	O
flags	int
=	O
flags	int
;	O
asym	pointer
->	O
section	pointer
=	O
section	pointer
;	O
if	O
(	O
bfd_get_flavour	function
(	O
abfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
)	O
{	O
elf_symbol_type	struct
*	O
elfsym	pointer
=	O
elf_symbol_from	O
(	O
abfd	pointer
,	O
asym	pointer
)	O
;	O
unsigned	O
char	O
visibility	int
;	O
if	O
(	O
!	O
elfsym	pointer
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: %s: non-ELF symbol in ELF BFD!\n"	pointer
)	O
,	O
asym	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
ldsym	pointer
->	O
def	struct
==	O
LDPK_COMMON	int
)	O
{	O
elfsym	pointer
->	O
internal_elf_sym	struct
.	O
st_shndx	int
=	O
SHN_COMMON	O
;	O
elfsym	pointer
->	O
internal_elf_sym	struct
.	O
st_value	int
=	O
1	int
;	O
}	O
switch	O
(	O
ldsym	pointer
->	O
visibility	int
)	O
{	O
default	O
:	O
einfo	pointer
(	O
_	O
(	O
"%F%P: unknown ELF symbol visibility: %d!\n"	pointer
)	O
,	O
ldsym	pointer
->	O
visibility	int
)	O
;	O
return	O
LDPS_ERR	int
;	O
case	O
LDPV_DEFAULT	int
:	O
visibility	int
=	O
STV_DEFAULT	int
;	O
break	O
;	O
case	O
LDPV_PROTECTED	int
:	O
visibility	int
=	O
STV_PROTECTED	int
;	O
break	O
;	O
case	O
LDPV_INTERNAL	int
:	O
visibility	int
=	O
STV_INTERNAL	int
;	O
break	O
;	O
case	O
LDPV_HIDDEN	int
:	O
visibility	int
=	O
STV_HIDDEN	int
;	O
break	O
;	O
}	O
elfsym	pointer
->	O
internal_elf_sym	struct
.	O
st_other	array
|=	O
visibility	int
;	O
}	O
return	O
LDPS_OK	int
;	O
}	O
static	O
enum	O
ld_plugin_status	enum
register_claim_file	function
(	O
ld_plugin_claim_file_handler	pointer
handler	pointer
)	O
{	O
ASSERT	O
(	O
called_plugin	pointer
)	O
;	O
called_plugin	pointer
->	O
claim_file_handler	pointer
=	O
handler	pointer
;	O
return	O
LDPS_OK	int
;	O
}	O
static	O
enum	O
ld_plugin_status	enum
register_all_symbols_read	function
(	O
ld_plugin_all_symbols_read_handler	pointer
handler	pointer
)	O
{	O
ASSERT	O
(	O
called_plugin	pointer
)	O
;	O
called_plugin	pointer
->	O
all_symbols_read_handler	pointer
=	O
handler	pointer
;	O
return	O
LDPS_OK	int
;	O
}	O
static	O
enum	O
ld_plugin_status	enum
register_cleanup	function
(	O
ld_plugin_cleanup_handler	pointer
handler	pointer
)	O
{	O
ASSERT	O
(	O
called_plugin	pointer
)	O
;	O
called_plugin	pointer
->	O
cleanup_handler	pointer
=	O
handler	pointer
;	O
return	O
LDPS_OK	int
;	O
}	O
static	O
enum	O
ld_plugin_status	enum
add_symbols	function
(	O
void	O
*	O
handle	pointer
,	O
int	O
nsyms	int
,	O
const	O
struct	O
ld_plugin_symbol	struct
*	O
syms	pointer
)	O
{	O
asymbol	struct
*	O
*	O
symptrs	pointer
;	O
plugin_input_file_t	struct
*	O
input	pointer
=	O
handle	pointer
;	O
bfd	struct
*	O
abfd	pointer
=	O
input	pointer
->	O
abfd	pointer
;	O
int	O
n	int
;	O
ASSERT	O
(	O
called_plugin	pointer
)	O
;	O
symptrs	pointer
=	O
xmalloc	function
(	O
nsyms	int
*	O
sizeof	O
*	O
symptrs	pointer
)	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
nsyms	int
;	O
n	int
++	O
)	O
{	O
enum	O
ld_plugin_status	enum
rv	enum
;	O
asymbol	struct
*	O
bfdsym	pointer
;	O
bfdsym	pointer
=	O
bfd_make_empty_symbol	O
(	O
abfd	pointer
)	O
;	O
symptrs	pointer
[	O
n	int
]	O
=	O
bfdsym	pointer
;	O
rv	enum
=	O
asymbol_from_plugin_symbol	function
(	O
abfd	pointer
,	O
bfdsym	pointer
,	O
syms	pointer
+	O
n	int
)	O
;	O
if	O
(	O
rv	enum
!=	O
LDPS_OK	int
)	O
return	O
rv	enum
;	O
}	O
bfd_set_symtab	function
(	O
abfd	pointer
,	O
symptrs	pointer
,	O
nsyms	int
)	O
;	O
return	O
LDPS_OK	int
;	O
}	O
static	O
enum	O
ld_plugin_status	enum
get_input_file	function
(	O
const	O
void	O
*	O
handle	pointer
,	O
struct	O
ld_plugin_input_file	struct
*	O
file	pointer
)	O
{	O
const	O
plugin_input_file_t	struct
*	O
input	pointer
=	O
handle	pointer
;	O
ASSERT	O
(	O
called_plugin	pointer
)	O
;	O
file	pointer
->	O
name	pointer
=	O
input	pointer
->	O
name	pointer
;	O
file	pointer
->	O
offset	long
=	O
input	pointer
->	O
offset	long
;	O
file	pointer
->	O
filesize	long
=	O
input	pointer
->	O
filesize	long
;	O
file	pointer
->	O
handle	pointer
=	O
(	O
void	O
*	O
)	O
handle	pointer
;	O
return	O
LDPS_OK	int
;	O
}	O
static	O
enum	O
ld_plugin_status	enum
get_view	function
(	O
const	O
void	O
*	O
handle	pointer
,	O
const	O
void	O
*	O
*	O
viewp	pointer
)	O
{	O
plugin_input_file_t	struct
*	O
input	pointer
=	O
(	O
plugin_input_file_t	struct
*	O
)	O
handle	pointer
;	O
char	O
*	O
buffer	pointer
;	O
size_t	long
size	int
=	O
input	pointer
->	O
filesize	long
;	O
off_t	long
offset	long
=	O
input	pointer
->	O
offset	long
;	O
off_t	long
bias	long
;	O
ASSERT	O
(	O
called_plugin	pointer
)	O
;	O
if	O
(	O
(	O
off_t	long
)	O
size	int
!=	O
input	pointer
->	O
filesize	long
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: unsupported input file size: %s (%ld bytes)\n"	pointer
)	O
,	O
input	pointer
->	O
name	pointer
,	O
(	O
long	O
)	O
input	pointer
->	O
filesize	long
)	O
;	O
if	O
(	O
input	pointer
->	O
view_buffer	struct
.	O
addr	pointer
!=	O
NULL	O
&&	O
input	pointer
->	O
view_buffer	struct
.	O
filesize	long
==	O
size	int
&&	O
input	pointer
->	O
view_buffer	struct
.	O
offset	long
==	O
offset	long
)	O
{	O
*	O
viewp	pointer
=	O
input	pointer
->	O
view_buffer	struct
.	O
addr	pointer
;	O
return	O
LDPS_OK	int
;	O
}	O
input	pointer
->	O
view_buffer	struct
.	O
filesize	long
=	O
size	int
;	O
input	pointer
->	O
view_buffer	struct
.	O
offset	long
=	O
offset	long
;	O
bias	long
=	O
offset	long
%	O
plugin_pagesize	long
;	O
offset	long
-=	O
bias	long
;	O
size	int
+=	O
bias	long
;	O
buffer	pointer
=	O
mmap	function
(	O
NULL	O
,	O
size	int
,	O
PROT_READ	int
,	O
MAP_PRIVATE	int
,	O
input	pointer
->	O
fd	int
,	O
offset	long
)	O
;	O
if	O
(	O
buffer	pointer
!=	O
MAP_FAILED	O
)	O
{	O
input	pointer
->	O
use_mmap	int
=	O
TRUE	int
;	O
buffer	pointer
+=	O
bias	long
;	O
}	O
else	O
{	O
char	O
*	O
p	pointer
;	O
input	pointer
->	O
use_mmap	int
=	O
FALSE	int
;	O
if	O
(	O
lseek	function
(	O
input	pointer
->	O
fd	int
,	O
offset	long
,	O
SEEK_SET	int
)	O
<	O
0	int
)	O
return	O
LDPS_ERR	int
;	O
buffer	pointer
=	O
bfd_alloc	function
(	O
input	pointer
->	O
abfd	pointer
,	O
size	int
)	O
;	O
if	O
(	O
buffer	pointer
==	O
NULL	O
)	O
return	O
LDPS_ERR	int
;	O
p	pointer
=	O
buffer	pointer
;	O
do	O
{	O
ssize_t	long
got	union
=	O
read	pointer
(	O
input	pointer
->	O
fd	int
,	O
p	pointer
,	O
size	int
)	O
;	O
if	O
(	O
got	union
==	O
0	int
)	O
break	O
;	O
else	O
if	O
(	O
got	union
>	O
0	int
)	O
{	O
p	pointer
+=	O
got	union
;	O
size	int
-=	O
got	union
;	O
}	O
else	O
if	O
(	O
errno	O
!=	O
EINTR	int
)	O
return	O
LDPS_ERR	int
;	O
}	O
while	O
(	O
size	int
>	O
0	int
)	O
;	O
}	O
input	pointer
->	O
view_buffer	struct
.	O
addr	pointer
=	O
buffer	pointer
;	O
*	O
viewp	pointer
=	O
buffer	pointer
;	O
return	O
LDPS_OK	int
;	O
}	O
static	O
enum	O
ld_plugin_status	enum
release_input_file	function
(	O
const	O
void	O
*	O
handle	pointer
)	O
{	O
plugin_input_file_t	struct
*	O
input	pointer
=	O
(	O
plugin_input_file_t	struct
*	O
)	O
handle	pointer
;	O
ASSERT	O
(	O
called_plugin	pointer
)	O
;	O
if	O
(	O
input	pointer
->	O
fd	int
!=	O
-	O
1	int
)	O
{	O
close	pointer
(	O
input	pointer
->	O
fd	int
)	O
;	O
input	pointer
->	O
fd	int
=	O
-	O
1	int
;	O
}	O
return	O
LDPS_OK	int
;	O
}	O
static	O
inline	O
bfd_boolean	int
is_visible_from_outside	function
(	O
struct	O
ld_plugin_symbol	struct
*	O
lsym	pointer
,	O
struct	O
bfd_link_hash_entry	struct
*	O
blhe	pointer
)	O
{	O
if	O
(	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
blhe	pointer
->	O
non_ir_ref_dynamic	int
||	O
link_info	struct
.	O
export_dynamic	int
||	O
bfd_link_dll	O
(	O
&	O
link_info	struct
)	O
)	O
{	O
if	O
(	O
bfd_hide_sym_by_version	function
(	O
link_info	struct
.	O
version_info	pointer
,	O
blhe	pointer
->	O
root	struct
.	O
string	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
bfd_get_flavour	function
(	O
link_info	struct
.	O
output_bfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
el	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
blhe	pointer
;	O
int	O
vis	int
=	O
ELF_ST_VISIBILITY	O
(	O
el	pointer
->	O
other	int
)	O
;	O
return	O
vis	int
==	O
STV_DEFAULT	int
||	O
vis	int
==	O
STV_PROTECTED	int
;	O
}	O
return	O
(	O
lsym	pointer
->	O
visibility	int
==	O
LDPV_DEFAULT	int
||	O
lsym	pointer
->	O
visibility	int
==	O
LDPV_PROTECTED	int
)	O
;	O
}	O
return	O
FALSE	int
;	O
}	O
static	O
const	O
char	O
*	O
get_lto_kind	function
(	O
unsigned	O
int	O
idx	int
)	O
{	O
static	O
char	O
buffer	pointer
[	O
64	int
]	O
;	O
const	O
char	O
*	O
lto_kind_str	array
[	O
5	int
]	O
=	O
{	O
"DEF"	pointer
,	O
"WEAKDEF"	pointer
,	O
"UNDEF"	pointer
,	O
"WEAKUNDEF"	pointer
,	O
"COMMON"	pointer
}	O
;	O
if	O
(	O
idx	int
<	O
ARRAY_SIZE	O
(	O
lto_kind_str	array
)	O
)	O
return	O
lto_kind_str	array
[	O
idx	int
]	O
;	O
sprintf	function
(	O
buffer	pointer
,	O
_	O
(	O
"unknown LTO kind value %x"	pointer
)	O
,	O
idx	int
)	O
;	O
return	O
buffer	pointer
;	O
}	O
static	O
const	O
char	O
*	O
get_lto_resolution	function
(	O
unsigned	O
int	O
idx	int
)	O
{	O
static	O
char	O
buffer	pointer
[	O
64	int
]	O
;	O
static	O
const	O
char	O
*	O
lto_resolution_str	array
[	O
10	int
]	O
=	O
{	O
"UNKNOWN"	pointer
,	O
"UNDEF"	pointer
,	O
"PREVAILING_DEF"	pointer
,	O
"PREVAILING_DEF_IRONLY"	pointer
,	O
"PREEMPTED_REG"	pointer
,	O
"PREEMPTED_IR"	pointer
,	O
"RESOLVED_IR"	pointer
,	O
"RESOLVED_EXEC"	pointer
,	O
"RESOLVED_DYN"	pointer
,	O
"PREVAILING_DEF_IRONLY_EXP"	pointer
,	O
}	O
;	O
if	O
(	O
idx	int
<	O
ARRAY_SIZE	O
(	O
lto_resolution_str	array
)	O
)	O
return	O
lto_resolution_str	array
[	O
idx	int
]	O
;	O
sprintf	function
(	O
buffer	pointer
,	O
_	O
(	O
"unknown LTO resolution value %x"	pointer
)	O
,	O
idx	int
)	O
;	O
return	O
buffer	pointer
;	O
}	O
static	O
const	O
char	O
*	O
get_lto_visibility	function
(	O
unsigned	O
int	O
idx	int
)	O
{	O
static	O
char	O
buffer	pointer
[	O
64	int
]	O
;	O
const	O
char	O
*	O
lto_visibility_str	array
[	O
4	int
]	O
=	O
{	O
"DEFAULT"	pointer
,	O
"PROTECTED"	pointer
,	O
"INTERNAL"	pointer
,	O
"HIDDEN"	pointer
}	O
;	O
if	O
(	O
idx	int
<	O
ARRAY_SIZE	O
(	O
lto_visibility_str	array
)	O
)	O
return	O
lto_visibility_str	array
[	O
idx	int
]	O
;	O
sprintf	function
(	O
buffer	pointer
,	O
_	O
(	O
"unknown LTO visibility value %x"	pointer
)	O
,	O
idx	int
)	O
;	O
return	O
buffer	pointer
;	O
}	O
static	O
enum	O
ld_plugin_status	enum
get_symbols	function
(	O
const	O
void	O
*	O
handle	pointer
,	O
int	O
nsyms	int
,	O
struct	O
ld_plugin_symbol	struct
*	O
syms	pointer
,	O
int	O
def_ironly_exp	int
)	O
{	O
const	O
plugin_input_file_t	struct
*	O
input	pointer
=	O
handle	pointer
;	O
const	O
bfd	struct
*	O
abfd	pointer
=	O
(	O
const	O
bfd	struct
*	O
)	O
input	pointer
->	O
abfd	pointer
;	O
int	O
n	int
;	O
ASSERT	O
(	O
called_plugin	pointer
)	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
nsyms	int
;	O
n	int
++	O
)	O
{	O
struct	O
bfd_link_hash_entry	struct
*	O
blhe	pointer
;	O
asection	struct
*	O
owner_sec	pointer
;	O
int	O
res	int
;	O
struct	O
bfd_link_hash_entry	struct
*	O
h	pointer
=	O
bfd_link_hash_lookup	function
(	O
link_info	struct
.	O
hash	long
,	O
syms	pointer
[	O
n	int
]	O
.	O
name	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
;	O
enum	O
{	O
wrap_none	int
,	O
wrapper	int
,	O
wrapped	int
}	O
wrap_status	enum
=	O
wrap_none	int
;	O
if	O
(	O
syms	pointer
[	O
n	int
]	O
.	O
def	struct
!=	O
LDPK_UNDEF	int
&&	O
syms	pointer
[	O
n	int
]	O
.	O
def	struct
!=	O
LDPK_WEAKUNDEF	int
)	O
{	O
blhe	pointer
=	O
h	pointer
;	O
if	O
(	O
blhe	pointer
&&	O
link_info	struct
.	O
wrap_hash	pointer
!=	O
NULL	O
)	O
{	O
struct	O
bfd_link_hash_entry	struct
*	O
unwrap	pointer
=	O
unwrap_hash_lookup	function
(	O
&	O
link_info	struct
,	O
(	O
bfd	struct
*	O
)	O
abfd	pointer
,	O
blhe	pointer
)	O
;	O
if	O
(	O
unwrap	pointer
&&	O
unwrap	pointer
!=	O
h	pointer
)	O
wrap_status	enum
=	O
wrapper	int
;	O
}	O
}	O
else	O
{	O
blhe	pointer
=	O
bfd_wrapped_link_hash_lookup	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
&	O
link_info	struct
,	O
syms	pointer
[	O
n	int
]	O
.	O
name	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
;	O
if	O
(	O
blhe	pointer
&&	O
blhe	pointer
!=	O
h	pointer
)	O
wrap_status	enum
=	O
wrapped	int
;	O
}	O
if	O
(	O
!	O
blhe	pointer
)	O
{	O
switch	O
(	O
syms	pointer
[	O
n	int
]	O
.	O
def	struct
)	O
{	O
default	O
:	O
abort	function
(	O
)	O
;	O
case	O
LDPK_UNDEF	int
:	O
case	O
LDPK_WEAKUNDEF	int
:	O
res	int
=	O
LDPR_UNDEF	int
;	O
break	O
;	O
case	O
LDPK_DEF	int
:	O
case	O
LDPK_WEAKDEF	int
:	O
case	O
LDPK_COMMON	int
:	O
res	int
=	O
LDPR_PREVAILING_DEF_IRONLY	int
;	O
break	O
;	O
}	O
goto	O
report_symbol	O
;	O
}	O
if	O
(	O
blhe	pointer
->	O
type	enum
==	O
bfd_link_hash_undefined	int
||	O
blhe	pointer
->	O
type	enum
==	O
bfd_link_hash_undefweak	int
)	O
{	O
res	int
=	O
LDPR_UNDEF	int
;	O
goto	O
report_symbol	O
;	O
}	O
if	O
(	O
blhe	pointer
->	O
type	enum
!=	O
bfd_link_hash_defined	int
&&	O
blhe	pointer
->	O
type	enum
!=	O
bfd_link_hash_defweak	int
&&	O
blhe	pointer
->	O
type	enum
!=	O
bfd_link_hash_common	int
)	O
{	O
einfo	pointer
(	O
_	O
(	O
"%F%P: %s: plugin symbol table corrupt (sym type %d)\n"	pointer
)	O
,	O
called_plugin	pointer
->	O
name	pointer
,	O
blhe	pointer
->	O
type	enum
)	O
;	O
}	O
owner_sec	pointer
=	O
(	O
blhe	pointer
->	O
type	enum
==	O
bfd_link_hash_common	int
?	O
blhe	pointer
->	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
section	pointer
:	O
blhe	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
)	O
;	O
if	O
(	O
syms	pointer
[	O
n	int
]	O
.	O
def	struct
==	O
LDPK_UNDEF	int
||	O
syms	pointer
[	O
n	int
]	O
.	O
def	struct
==	O
LDPK_WEAKUNDEF	int
||	O
syms	pointer
[	O
n	int
]	O
.	O
def	struct
==	O
LDPK_COMMON	int
)	O
{	O
if	O
(	O
owner_sec	pointer
->	O
owner	pointer
==	O
link_info	struct
.	O
output_bfd	pointer
)	O
res	int
=	O
LDPR_RESOLVED_EXEC	int
;	O
else	O
if	O
(	O
owner_sec	pointer
->	O
owner	pointer
==	O
abfd	pointer
)	O
res	int
=	O
LDPR_PREVAILING_DEF_IRONLY	int
;	O
else	O
if	O
(	O
is_ir_dummy_bfd	function
(	O
owner_sec	pointer
->	O
owner	pointer
)	O
)	O
res	int
=	O
LDPR_RESOLVED_IR	int
;	O
else	O
if	O
(	O
owner_sec	pointer
->	O
owner	pointer
!=	O
NULL	O
&&	O
(	O
owner_sec	pointer
->	O
owner	pointer
->	O
flags	int
&	O
DYNAMIC	int
)	O
!=	O
0	int
)	O
res	int
=	O
LDPR_RESOLVED_DYN	int
;	O
else	O
res	int
=	O
LDPR_RESOLVED_EXEC	int
;	O
}	O
else	O
if	O
(	O
owner_sec	pointer
->	O
owner	pointer
==	O
link_info	struct
.	O
output_bfd	pointer
)	O
res	int
=	O
LDPR_PREEMPTED_REG	int
;	O
else	O
if	O
(	O
owner_sec	pointer
->	O
owner	pointer
==	O
abfd	pointer
)	O
res	int
=	O
LDPR_PREVAILING_DEF_IRONLY	int
;	O
else	O
if	O
(	O
is_ir_dummy_bfd	function
(	O
owner_sec	pointer
->	O
owner	pointer
)	O
)	O
res	int
=	O
LDPR_PREEMPTED_IR	int
;	O
else	O
res	int
=	O
LDPR_PREEMPTED_REG	int
;	O
if	O
(	O
res	int
==	O
LDPR_PREVAILING_DEF_IRONLY	int
)	O
{	O
if	O
(	O
blhe	pointer
->	O
non_ir_ref_regular	int
||	O
wrap_status	enum
==	O
wrapper	int
)	O
res	int
=	O
LDPR_PREVAILING_DEF	int
;	O
else	O
if	O
(	O
wrap_status	enum
==	O
wrapped	int
)	O
res	int
=	O
LDPR_RESOLVED_IR	int
;	O
else	O
if	O
(	O
is_visible_from_outside	function
(	O
&	O
syms	pointer
[	O
n	int
]	O
,	O
blhe	pointer
)	O
)	O
res	int
=	O
def_ironly_exp	int
;	O
}	O
report_symbol	O
:	O
syms	pointer
[	O
n	int
]	O
.	O
resolution	int
=	O
res	int
;	O
if	O
(	O
report_plugin_symbols	int
)	O
einfo	pointer
(	O
_	O
(	O
"%P: %pB: symbol `%s' "	pointer
"definition: %s, visibility: %s, resolution: %s\n"	pointer
)	O
,	O
abfd	pointer
,	O
syms	pointer
[	O
n	int
]	O
.	O
name	pointer
,	O
get_lto_kind	function
(	O
syms	pointer
[	O
n	int
]	O
.	O
def	struct
)	O
,	O
get_lto_visibility	function
(	O
syms	pointer
[	O
n	int
]	O
.	O
visibility	int
)	O
,	O
get_lto_resolution	function
(	O
res	int
)	O
)	O
;	O
}	O
return	O
LDPS_OK	int
;	O
}	O
static	O
enum	O
ld_plugin_status	enum
get_symbols_v1	function
(	O
const	O
void	O
*	O
handle	pointer
,	O
int	O
nsyms	int
,	O
struct	O
ld_plugin_symbol	struct
*	O
syms	pointer
)	O
{	O
return	O
get_symbols	function
(	O
handle	pointer
,	O
nsyms	int
,	O
syms	pointer
,	O
LDPR_PREVAILING_DEF	int
)	O
;	O
}	O
static	O
enum	O
ld_plugin_status	enum
get_symbols_v2	function
(	O
const	O
void	O
*	O
handle	pointer
,	O
int	O
nsyms	int
,	O
struct	O
ld_plugin_symbol	struct
*	O
syms	pointer
)	O
{	O
return	O
get_symbols	function
(	O
handle	pointer
,	O
nsyms	int
,	O
syms	pointer
,	O
LDPR_PREVAILING_DEF_IRONLY_EXP	int
)	O
;	O
}	O
static	O
enum	O
ld_plugin_status	enum
add_input_file	function
(	O
const	O
char	O
*	O
pathname	pointer
)	O
{	O
lang_input_statement_type	struct
*	O
is	pointer
;	O
ASSERT	O
(	O
called_plugin	pointer
)	O
;	O
is	pointer
=	O
lang_add_input_file	function
(	O
xstrdup	function
(	O
pathname	pointer
)	O
,	O
lang_input_file_is_file_enum	int
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
is	pointer
)	O
return	O
LDPS_ERR	int
;	O
is	pointer
->	O
flags	int
.	O
lto_output	int
=	O
1	int
;	O
return	O
LDPS_OK	int
;	O
}	O
static	O
enum	O
ld_plugin_status	enum
add_input_library	function
(	O
const	O
char	O
*	O
pathname	pointer
)	O
{	O
lang_input_statement_type	struct
*	O
is	pointer
;	O
ASSERT	O
(	O
called_plugin	pointer
)	O
;	O
is	pointer
=	O
lang_add_input_file	function
(	O
xstrdup	function
(	O
pathname	pointer
)	O
,	O
lang_input_file_is_l_enum	int
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
is	pointer
)	O
return	O
LDPS_ERR	int
;	O
is	pointer
->	O
flags	int
.	O
lto_output	int
=	O
1	int
;	O
return	O
LDPS_OK	int
;	O
}	O
static	O
enum	O
ld_plugin_status	enum
set_extra_library_path	function
(	O
const	O
char	O
*	O
path	pointer
)	O
{	O
ASSERT	O
(	O
called_plugin	pointer
)	O
;	O
ldfile_add_library_path	function
(	O
xstrdup	function
(	O
path	pointer
)	O
,	O
FALSE	int
)	O
;	O
return	O
LDPS_OK	int
;	O
}	O
static	O
enum	O
ld_plugin_status	enum
message	pointer
(	O
int	O
level	int
,	O
const	O
char	O
*	O
format	enum
,	O
...	O
)	O
{	O
va_list	array
args	pointer
;	O
va_start	O
(	O
args	pointer
,	O
format	enum
)	O
;	O
switch	O
(	O
level	int
)	O
{	O
case	O
LDPL_INFO	int
:	O
vfinfo	function
(	O
stdout	pointer
,	O
format	enum
,	O
args	pointer
,	O
FALSE	int
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
break	O
;	O
case	O
LDPL_WARNING	int
:	O
{	O
char	O
*	O
newfmt	pointer
=	O
concat	function
(	O
_	O
(	O
"%P: warning: "	pointer
)	O
,	O
format	enum
,	O
"\n"	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
)	O
;	O
vfinfo	function
(	O
stdout	pointer
,	O
newfmt	pointer
,	O
args	pointer
,	O
TRUE	int
)	O
;	O
free	function
(	O
newfmt	pointer
)	O
;	O
}	O
break	O
;	O
case	O
LDPL_FATAL	int
:	O
case	O
LDPL_ERROR	int
:	O
default	O
:	O
{	O
char	O
*	O
newfmt	pointer
=	O
concat	function
(	O
level	int
==	O
LDPL_FATAL	int
?	O
"%F"	pointer
:	O
"%X"	pointer
,	O
_	O
(	O
"%P: error: "	pointer
)	O
,	O
format	enum
,	O
"\n"	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
vfinfo	function
(	O
stderr	pointer
,	O
newfmt	pointer
,	O
args	pointer
,	O
TRUE	int
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
free	function
(	O
newfmt	pointer
)	O
;	O
}	O
break	O
;	O
}	O
va_end	O
(	O
args	pointer
)	O
;	O
return	O
LDPS_OK	int
;	O
}	O
static	O
void	O
set_tv_header	function
(	O
struct	O
ld_plugin_tv	struct
*	O
tv	pointer
)	O
{	O
size_t	long
i	pointer
;	O
static	O
const	O
unsigned	O
int	O
major	int
=	O
(	O
unsigned	O
)	O
(	O
BFD_VERSION	int
/	O
100000000UL	int
)	O
;	O
static	O
const	O
unsigned	O
int	O
minor	int
=	O
(	O
unsigned	O
)	O
(	O
BFD_VERSION	int
/	O
1000000UL	int
)	O
%	O
100	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
tv_header_size	long
;	O
i	pointer
++	O
)	O
{	O
tv	pointer
[	O
i	pointer
]	O
.	O
tv_tag	enum
=	O
tv_header_tags	array
[	O
i	pointer
]	O
;	O
switch	O
(	O
tv	pointer
[	O
i	pointer
]	O
.	O
tv_tag	enum
)	O
{	O
case	O
LDPT_MESSAGE	int
:	O
TVU	O
(	O
message	pointer
)	O
=	O
message	pointer
;	O
break	O
;	O
case	O
LDPT_API_VERSION	int
:	O
TVU	O
(	O
val	array
)	O
=	O
LD_PLUGIN_API_VERSION	int
;	O
break	O
;	O
case	O
LDPT_GNU_LD_VERSION	int
:	O
TVU	O
(	O
val	array
)	O
=	O
major	int
*	O
100	int
+	O
minor	int
;	O
break	O
;	O
case	O
LDPT_LINKER_OUTPUT	int
:	O
TVU	O
(	O
val	array
)	O
=	O
(	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
?	O
LDPO_REL	int
:	O
bfd_link_pde	O
(	O
&	O
link_info	struct
)	O
?	O
LDPO_EXEC	int
:	O
bfd_link_pie	O
(	O
&	O
link_info	struct
)	O
?	O
LDPO_PIE	int
:	O
LDPO_DYN	int
)	O
;	O
break	O
;	O
case	O
LDPT_OUTPUT_NAME	int
:	O
TVU	O
(	O
string	pointer
)	O
=	O
output_filename	pointer
;	O
break	O
;	O
case	O
LDPT_REGISTER_CLAIM_FILE_HOOK	int
:	O
TVU	O
(	O
register_claim_file	function
)	O
=	O
register_claim_file	function
;	O
break	O
;	O
case	O
LDPT_REGISTER_ALL_SYMBOLS_READ_HOOK	int
:	O
TVU	O
(	O
register_all_symbols_read	function
)	O
=	O
register_all_symbols_read	function
;	O
break	O
;	O
case	O
LDPT_REGISTER_CLEANUP_HOOK	int
:	O
TVU	O
(	O
register_cleanup	function
)	O
=	O
register_cleanup	function
;	O
break	O
;	O
case	O
LDPT_ADD_SYMBOLS	int
:	O
TVU	O
(	O
add_symbols	function
)	O
=	O
add_symbols	function
;	O
break	O
;	O
case	O
LDPT_GET_INPUT_FILE	int
:	O
TVU	O
(	O
get_input_file	function
)	O
=	O
get_input_file	function
;	O
break	O
;	O
case	O
LDPT_GET_VIEW	int
:	O
TVU	O
(	O
get_view	function
)	O
=	O
get_view	function
;	O
break	O
;	O
case	O
LDPT_RELEASE_INPUT_FILE	int
:	O
TVU	O
(	O
release_input_file	function
)	O
=	O
release_input_file	function
;	O
break	O
;	O
case	O
LDPT_GET_SYMBOLS	int
:	O
TVU	O
(	O
get_symbols	function
)	O
=	O
get_symbols_v1	function
;	O
break	O
;	O
case	O
LDPT_GET_SYMBOLS_V2	int
:	O
TVU	O
(	O
get_symbols	function
)	O
=	O
get_symbols_v2	function
;	O
break	O
;	O
case	O
LDPT_ADD_INPUT_FILE	int
:	O
TVU	O
(	O
add_input_file	function
)	O
=	O
add_input_file	function
;	O
break	O
;	O
case	O
LDPT_ADD_INPUT_LIBRARY	int
:	O
TVU	O
(	O
add_input_library	function
)	O
=	O
add_input_library	function
;	O
break	O
;	O
case	O
LDPT_SET_EXTRA_LIBRARY_PATH	int
:	O
TVU	O
(	O
set_extra_library_path	function
)	O
=	O
set_extra_library_path	function
;	O
break	O
;	O
default	O
:	O
FAIL	O
(	O
)	O
;	O
}	O
}	O
}	O
static	O
void	O
set_tv_plugin_args	function
(	O
plugin_t	struct
*	O
plugin	pointer
,	O
struct	O
ld_plugin_tv	struct
*	O
tv	pointer
)	O
{	O
plugin_arg_t	struct
*	O
arg	pointer
=	O
plugin	pointer
->	O
args	pointer
;	O
while	O
(	O
arg	pointer
)	O
{	O
tv	pointer
->	O
tv_tag	enum
=	O
LDPT_OPTION	int
;	O
tv	pointer
->	O
tv_u	union
.	O
tv_string	pointer
=	O
arg	pointer
->	O
arg	pointer
;	O
arg	pointer
=	O
arg	pointer
->	O
next	pointer
;	O
tv	pointer
++	O
;	O
}	O
tv	pointer
->	O
tv_tag	enum
=	O
LDPT_NULL	int
;	O
tv	pointer
->	O
tv_u	union
.	O
tv_val	int
=	O
0	int
;	O
}	O
void	O
plugin_load_plugins	function
(	O
void	O
)	O
{	O
struct	O
ld_plugin_tv	struct
*	O
my_tv	pointer
;	O
unsigned	O
int	O
max_args	int
=	O
0	int
;	O
plugin_t	struct
*	O
curplug	pointer
=	O
plugins_list	pointer
;	O
if	O
(	O
!	O
curplug	pointer
)	O
return	O
;	O
while	O
(	O
curplug	pointer
)	O
{	O
if	O
(	O
curplug	pointer
->	O
n_args	long
>	O
max_args	int
)	O
max_args	int
=	O
curplug	pointer
->	O
n_args	long
;	O
curplug	pointer
=	O
curplug	pointer
->	O
next	pointer
;	O
}	O
my_tv	pointer
=	O
xmalloc	function
(	O
(	O
max_args	int
+	O
1	int
+	O
tv_header_size	long
)	O
*	O
sizeof	O
*	O
my_tv	pointer
)	O
;	O
set_tv_header	function
(	O
my_tv	pointer
)	O
;	O
curplug	pointer
=	O
plugins_list	pointer
;	O
while	O
(	O
curplug	pointer
)	O
{	O
enum	O
ld_plugin_status	enum
rv	enum
;	O
ld_plugin_onload	pointer
onloadfn	pointer
;	O
onloadfn	pointer
=	O
(	O
ld_plugin_onload	pointer
)	O
dlsym	function
(	O
curplug	pointer
->	O
dlhandle	pointer
,	O
"onload"	pointer
)	O
;	O
if	O
(	O
!	O
onloadfn	pointer
)	O
onloadfn	pointer
=	O
(	O
ld_plugin_onload	pointer
)	O
dlsym	function
(	O
curplug	pointer
->	O
dlhandle	pointer
,	O
"_onload"	pointer
)	O
;	O
if	O
(	O
!	O
onloadfn	pointer
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: %s: error loading plugin: %s\n"	pointer
)	O
,	O
curplug	pointer
->	O
name	pointer
,	O
dlerror	function
(	O
)	O
)	O
;	O
set_tv_plugin_args	function
(	O
curplug	pointer
,	O
&	O
my_tv	pointer
[	O
tv_header_size	long
]	O
)	O
;	O
called_plugin	pointer
=	O
curplug	pointer
;	O
rv	enum
=	O
(	O
*	O
onloadfn	pointer
)	O
(	O
my_tv	pointer
)	O
;	O
called_plugin	pointer
=	O
NULL	O
;	O
if	O
(	O
rv	enum
!=	O
LDPS_OK	int
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: %s: plugin error: %d\n"	pointer
)	O
,	O
curplug	pointer
->	O
name	pointer
,	O
rv	enum
)	O
;	O
curplug	pointer
=	O
curplug	pointer
->	O
next	pointer
;	O
}	O
orig_notice_all	int
=	O
link_info	struct
.	O
notice_all	int
;	O
orig_callbacks	pointer
=	O
link_info	struct
.	O
callbacks	pointer
;	O
plugin_callbacks	struct
=	O
*	O
orig_callbacks	pointer
;	O
plugin_callbacks	struct
.	O
notice	pointer
=	O
&	O
plugin_notice	function
;	O
link_info	struct
.	O
notice_all	int
=	O
TRUE	int
;	O
link_info	struct
.	O
lto_plugin_active	int
=	O
TRUE	int
;	O
link_info	struct
.	O
callbacks	pointer
=	O
&	O
plugin_callbacks	struct
;	O
register_ld_plugin_object_p	function
(	O
plugin_object_p	function
)	O
;	O
plugin_pagesize	long
=	O
getpagesize	function
(	O
)	O
;	O
}	O
static	O
int	O
plugin_call_claim_file	function
(	O
const	O
struct	O
ld_plugin_input_file	struct
*	O
file	pointer
,	O
int	O
*	O
claimed	int
)	O
{	O
plugin_t	struct
*	O
curplug	pointer
=	O
plugins_list	pointer
;	O
*	O
claimed	int
=	O
FALSE	int
;	O
while	O
(	O
curplug	pointer
&&	O
!	O
*	O
claimed	int
)	O
{	O
if	O
(	O
curplug	pointer
->	O
claim_file_handler	pointer
)	O
{	O
enum	O
ld_plugin_status	enum
rv	enum
;	O
called_plugin	pointer
=	O
curplug	pointer
;	O
rv	enum
=	O
(	O
*	O
curplug	pointer
->	O
claim_file_handler	pointer
)	O
(	O
file	pointer
,	O
claimed	int
)	O
;	O
called_plugin	pointer
=	O
NULL	O
;	O
if	O
(	O
rv	enum
!=	O
LDPS_OK	int
)	O
set_plugin_error	function
(	O
curplug	pointer
->	O
name	pointer
)	O
;	O
}	O
curplug	pointer
=	O
curplug	pointer
->	O
next	pointer
;	O
}	O
return	O
plugin_error_p	function
(	O
)	O
?	O
-	O
1	int
:	O
0	int
;	O
}	O
static	O
char	O
*	O
plugin_strdup	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
char	O
*	O
str	pointer
)	O
{	O
size_t	long
strlength	long
;	O
char	O
*	O
copy	int
;	O
strlength	long
=	O
strlen	function
(	O
str	pointer
)	O
+	O
1	int
;	O
copy	int
=	O
bfd_alloc	function
(	O
abfd	pointer
,	O
strlength	long
)	O
;	O
if	O
(	O
copy	int
==	O
NULL	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: plugin_strdup failed to allocate memory: %s\n"	pointer
)	O
,	O
bfd_get_error	function
(	O
)	O
)	O
;	O
memcpy	function
(	O
copy	int
,	O
str	pointer
,	O
strlength	long
)	O
;	O
return	O
copy	int
;	O
}	O
static	O
const	O
bfd_target	struct
*	O
plugin_object_p	function
(	O
bfd	struct
*	O
ibfd	pointer
)	O
{	O
int	O
claimed	int
;	O
plugin_input_file_t	struct
*	O
input	pointer
;	O
struct	O
ld_plugin_input_file	struct
file	pointer
;	O
bfd	struct
*	O
abfd	pointer
;	O
if	O
(	O
(	O
ibfd	pointer
->	O
flags	int
&	O
BFD_PLUGIN	int
)	O
!=	O
0	int
)	O
return	O
NULL	O
;	O
if	O
(	O
ibfd	pointer
->	O
plugin_format	enum
!=	O
bfd_plugin_unknown	int
)	O
{	O
if	O
(	O
ibfd	pointer
->	O
plugin_format	enum
==	O
bfd_plugin_yes	int
)	O
return	O
ibfd	pointer
->	O
plugin_dummy_bfd	pointer
->	O
xvec	pointer
;	O
else	O
return	O
NULL	O
;	O
}	O
abfd	pointer
=	O
plugin_get_ir_dummy_bfd	function
(	O
ibfd	pointer
->	O
filename	pointer
,	O
ibfd	pointer
)	O
;	O
input	pointer
=	O
bfd_alloc	function
(	O
abfd	pointer
,	O
sizeof	O
(	O
*	O
input	pointer
)	O
)	O
;	O
if	O
(	O
input	pointer
==	O
NULL	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: plugin failed to allocate memory for input: %s\n"	pointer
)	O
,	O
bfd_get_error	function
(	O
)	O
)	O
;	O
if	O
(	O
!	O
bfd_plugin_open_input	function
(	O
ibfd	pointer
,	O
&	O
file	pointer
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
file	pointer
.	O
name	pointer
==	O
ibfd	pointer
->	O
filename	pointer
)	O
{	O
file	pointer
.	O
name	pointer
=	O
plugin_strdup	function
(	O
abfd	pointer
,	O
file	pointer
.	O
name	pointer
)	O
;	O
}	O
file	pointer
.	O
handle	pointer
=	O
input	pointer
;	O
input	pointer
->	O
abfd	pointer
=	O
abfd	pointer
;	O
input	pointer
->	O
view_buffer	struct
.	O
addr	pointer
=	O
NULL	O
;	O
input	pointer
->	O
view_buffer	struct
.	O
filesize	long
=	O
0	int
;	O
input	pointer
->	O
view_buffer	struct
.	O
offset	long
=	O
0	int
;	O
input	pointer
->	O
fd	int
=	O
file	pointer
.	O
fd	int
;	O
input	pointer
->	O
use_mmap	int
=	O
FALSE	int
;	O
input	pointer
->	O
offset	long
=	O
file	pointer
.	O
offset	long
;	O
input	pointer
->	O
filesize	long
=	O
file	pointer
.	O
filesize	long
;	O
input	pointer
->	O
name	pointer
=	O
plugin_strdup	function
(	O
abfd	pointer
,	O
ibfd	pointer
->	O
filename	pointer
)	O
;	O
claimed	int
=	O
0	int
;	O
if	O
(	O
plugin_call_claim_file	function
(	O
&	O
file	pointer
,	O
&	O
claimed	int
)	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: %s: plugin reported error claiming file\n"	pointer
)	O
,	O
plugin_error_plugin	function
(	O
)	O
)	O
;	O
if	O
(	O
input	pointer
->	O
fd	int
!=	O
-	O
1	int
&&	O
!	O
bfd_plugin_target_p	function
(	O
ibfd	pointer
->	O
xvec	pointer
)	O
)	O
{	O
close	pointer
(	O
input	pointer
->	O
fd	int
)	O
;	O
input	pointer
->	O
fd	int
=	O
-	O
1	int
;	O
}	O
if	O
(	O
claimed	int
)	O
{	O
ibfd	pointer
->	O
plugin_format	enum
=	O
bfd_plugin_yes	int
;	O
ibfd	pointer
->	O
plugin_dummy_bfd	pointer
=	O
abfd	pointer
;	O
bfd_make_readable	function
(	O
abfd	pointer
)	O
;	O
return	O
abfd	pointer
->	O
xvec	pointer
;	O
}	O
else	O
{	O
if	O
(	O
input	pointer
->	O
use_mmap	int
)	O
{	O
char	O
*	O
addr	pointer
=	O
input	pointer
->	O
view_buffer	struct
.	O
addr	pointer
;	O
off_t	long
size	int
=	O
input	pointer
->	O
view_buffer	struct
.	O
filesize	long
;	O
off_t	long
bias	long
=	O
input	pointer
->	O
view_buffer	struct
.	O
offset	long
%	O
plugin_pagesize	long
;	O
size	int
+=	O
bias	long
;	O
addr	pointer
-=	O
bias	long
;	O
munmap	function
(	O
addr	pointer
,	O
size	int
)	O
;	O
}	O
ibfd	pointer
->	O
plugin_format	enum
=	O
bfd_plugin_no	int
;	O
bfd_close_all_done	function
(	O
abfd	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
void	O
plugin_maybe_claim	function
(	O
lang_input_statement_type	struct
*	O
entry	pointer
)	O
{	O
ASSERT	O
(	O
entry	pointer
->	O
header	struct
.	O
type	enum
==	O
lang_input_statement_enum	int
)	O
;	O
if	O
(	O
plugin_object_p	function
(	O
entry	pointer
->	O
the_bfd	pointer
)	O
)	O
{	O
bfd	struct
*	O
abfd	pointer
=	O
entry	pointer
->	O
the_bfd	pointer
->	O
plugin_dummy_bfd	pointer
;	O
if	O
(	O
entry	pointer
->	O
the_bfd	pointer
->	O
my_archive	pointer
==	O
NULL	O
)	O
bfd_close	function
(	O
entry	pointer
->	O
the_bfd	pointer
)	O
;	O
entry	pointer
->	O
the_bfd	pointer
=	O
abfd	pointer
;	O
entry	pointer
->	O
flags	int
.	O
claimed	int
=	O
1	int
;	O
}	O
}	O
int	O
plugin_call_all_symbols_read	function
(	O
void	O
)	O
{	O
plugin_t	struct
*	O
curplug	pointer
=	O
plugins_list	pointer
;	O
no_more_claiming	int
=	O
TRUE	int
;	O
while	O
(	O
curplug	pointer
)	O
{	O
if	O
(	O
curplug	pointer
->	O
all_symbols_read_handler	pointer
)	O
{	O
enum	O
ld_plugin_status	enum
rv	enum
;	O
called_plugin	pointer
=	O
curplug	pointer
;	O
rv	enum
=	O
(	O
*	O
curplug	pointer
->	O
all_symbols_read_handler	pointer
)	O
(	O
)	O
;	O
called_plugin	pointer
=	O
NULL	O
;	O
if	O
(	O
rv	enum
!=	O
LDPS_OK	int
)	O
set_plugin_error	function
(	O
curplug	pointer
->	O
name	pointer
)	O
;	O
}	O
curplug	pointer
=	O
curplug	pointer
->	O
next	pointer
;	O
}	O
return	O
plugin_error_p	function
(	O
)	O
?	O
-	O
1	int
:	O
0	int
;	O
}	O
void	O
plugin_call_cleanup	function
(	O
void	O
)	O
{	O
plugin_t	struct
*	O
curplug	pointer
=	O
plugins_list	pointer
;	O
while	O
(	O
curplug	pointer
)	O
{	O
if	O
(	O
curplug	pointer
->	O
cleanup_handler	pointer
&&	O
!	O
curplug	pointer
->	O
cleanup_done	int
)	O
{	O
enum	O
ld_plugin_status	enum
rv	enum
;	O
curplug	pointer
->	O
cleanup_done	int
=	O
TRUE	int
;	O
called_plugin	pointer
=	O
curplug	pointer
;	O
rv	enum
=	O
(	O
*	O
curplug	pointer
->	O
cleanup_handler	pointer
)	O
(	O
)	O
;	O
called_plugin	pointer
=	O
NULL	O
;	O
if	O
(	O
rv	enum
!=	O
LDPS_OK	int
)	O
info_msg	function
(	O
_	O
(	O
"%P: %s: error in plugin cleanup: %d (ignored)\n"	pointer
)	O
,	O
curplug	pointer
->	O
name	pointer
,	O
rv	enum
)	O
;	O
dlclose	function
(	O
curplug	pointer
->	O
dlhandle	pointer
)	O
;	O
}	O
curplug	pointer
=	O
curplug	pointer
->	O
next	pointer
;	O
}	O
}	O
static	O
bfd_boolean	int
plugin_notice	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
struct	O
bfd_link_hash_entry	struct
*	O
h	pointer
,	O
struct	O
bfd_link_hash_entry	struct
*	O
inh	pointer
,	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
section	pointer
,	O
bfd_vma	long
value	long
,	O
flagword	int
flags	int
)	O
{	O
struct	O
bfd_link_hash_entry	struct
*	O
orig_h	pointer
=	O
h	pointer
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
{	O
bfd	struct
*	O
sym_bfd	pointer
;	O
bfd_boolean	int
ref	pointer
=	O
FALSE	int
;	O
if	O
(	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_warning	int
)	O
h	pointer
=	O
h	pointer
->	O
u	union
.	O
i	pointer
.	O
link	function
;	O
if	O
(	O
is_ir_dummy_bfd	function
(	O
abfd	pointer
)	O
)	O
;	O
else	O
if	O
(	O
bfd_is_ind_section	function
(	O
section	pointer
)	O
||	O
(	O
flags	int
&	O
BSF_INDIRECT	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
h	pointer
->	O
type	enum
!=	O
bfd_link_hash_new	int
||	O
inh	pointer
->	O
type	enum
==	O
bfd_link_hash_new	int
)	O
{	O
if	O
(	O
(	O
abfd	pointer
->	O
flags	int
&	O
DYNAMIC	int
)	O
==	O
0	int
)	O
inh	pointer
->	O
non_ir_ref_regular	int
=	O
TRUE	int
;	O
else	O
inh	pointer
->	O
non_ir_ref_dynamic	int
=	O
TRUE	int
;	O
}	O
if	O
(	O
h	pointer
->	O
type	enum
!=	O
bfd_link_hash_new	int
)	O
ref	pointer
=	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
(	O
flags	int
&	O
BSF_WARNING	O
)	O
!=	O
0	int
)	O
;	O
else	O
if	O
(	O
(	O
flags	int
&	O
BSF_CONSTRUCTOR	O
)	O
!=	O
0	int
)	O
;	O
else	O
if	O
(	O
bfd_is_und_section	function
(	O
section	pointer
)	O
)	O
{	O
if	O
(	O
(	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_undefined	int
||	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_undefweak	int
)	O
&&	O
(	O
h	pointer
->	O
u	union
.	O
undef	struct
.	O
abfd	pointer
==	O
NULL	O
||	O
(	O
h	pointer
->	O
u	union
.	O
undef	struct
.	O
abfd	pointer
->	O
flags	int
&	O
BFD_PLUGIN	int
)	O
!=	O
0	int
)	O
)	O
h	pointer
->	O
u	union
.	O
undef	struct
.	O
abfd	pointer
=	O
abfd	pointer
;	O
ref	pointer
=	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
bfd_is_com_section	function
(	O
section	pointer
)	O
)	O
{	O
if	O
(	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_common	int
&&	O
is_ir_dummy_bfd	function
(	O
sym_bfd	pointer
=	O
h	pointer
->	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
section	pointer
->	O
owner	pointer
)	O
)	O
{	O
h	pointer
->	O
type	enum
=	O
bfd_link_hash_undefweak	int
;	O
h	pointer
->	O
u	union
.	O
undef	struct
.	O
abfd	pointer
=	O
sym_bfd	pointer
;	O
}	O
ref	pointer
=	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
(	O
(	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_defweak	int
||	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_defined	int
)	O
&&	O
is_ir_dummy_bfd	function
(	O
sym_bfd	pointer
=	O
h	pointer
->	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
)	O
)	O
||	O
(	O
h	pointer
->	O
type	enum
==	O
bfd_link_hash_common	int
&&	O
is_ir_dummy_bfd	function
(	O
sym_bfd	pointer
=	O
h	pointer
->	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
section	pointer
->	O
owner	pointer
)	O
)	O
)	O
{	O
h	pointer
->	O
type	enum
=	O
bfd_link_hash_undefweak	int
;	O
h	pointer
->	O
u	union
.	O
undef	struct
.	O
abfd	pointer
=	O
sym_bfd	pointer
;	O
}	O
if	O
(	O
ref	pointer
)	O
{	O
if	O
(	O
(	O
abfd	pointer
->	O
flags	int
&	O
DYNAMIC	int
)	O
==	O
0	int
)	O
h	pointer
->	O
non_ir_ref_regular	int
=	O
TRUE	int
;	O
else	O
h	pointer
->	O
non_ir_ref_dynamic	int
=	O
TRUE	int
;	O
}	O
}	O
if	O
(	O
orig_h	pointer
==	O
NULL	O
||	O
orig_notice_all	int
||	O
(	O
info	pointer
->	O
notice_hash	pointer
!=	O
NULL	O
&&	O
bfd_hash_lookup	function
(	O
info	pointer
->	O
notice_hash	pointer
,	O
orig_h	pointer
->	O
root	struct
.	O
string	pointer
,	O
FALSE	int
,	O
FALSE	int
)	O
!=	O
NULL	O
)	O
)	O
return	O
(	O
*	O
orig_callbacks	pointer
->	O
notice	pointer
)	O
(	O
info	pointer
,	O
orig_h	pointer
,	O
inh	pointer
,	O
abfd	pointer
,	O
section	pointer
,	O
value	long
,	O
flags	int
)	O
;	O
return	O
TRUE	int
;	O
}	O
