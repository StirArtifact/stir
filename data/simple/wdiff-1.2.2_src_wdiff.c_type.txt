static	O
void	O
complete_input_program	function
(	O
void	O
)	O
;	O
struct	O
option	struct
const	O
longopts	array
[	O
]	O
=	O
{	O
{	O
"auto-pager"	pointer
,	O
0	int
,	O
NULL	O
,	O
'a'	O
}	O
,	O
{	O
"avoid-wraps"	pointer
,	O
0	int
,	O
NULL	O
,	O
'n'	O
}	O
,	O
{	O
"copyright"	pointer
,	O
0	int
,	O
NULL	O
,	O
'C'	O
}	O
,	O
{	O
"end-delete"	pointer
,	O
1	int
,	O
NULL	O
,	O
'x'	O
}	O
,	O
{	O
"end-insert"	pointer
,	O
1	int
,	O
NULL	O
,	O
'z'	O
}	O
,	O
{	O
"help"	pointer
,	O
0	int
,	O
NULL	O
,	O
'h'	O
}	O
,	O
{	O
"ignore-case"	pointer
,	O
0	int
,	O
NULL	O
,	O
'i'	O
}	O
,	O
{	O
"less-mode"	pointer
,	O
0	int
,	O
NULL	O
,	O
'l'	O
}	O
,	O
{	O
"no-common"	pointer
,	O
0	int
,	O
NULL	O
,	O
'3'	O
}	O
,	O
{	O
"no-deleted"	pointer
,	O
0	int
,	O
NULL	O
,	O
'1'	O
}	O
,	O
{	O
"no-init-term"	pointer
,	O
0	int
,	O
NULL	O
,	O
'K'	O
}	O
,	O
{	O
"no-inserted"	pointer
,	O
0	int
,	O
NULL	O
,	O
'2'	O
}	O
,	O
{	O
"printer"	pointer
,	O
0	int
,	O
NULL	O
,	O
'p'	O
}	O
,	O
{	O
"start-delete"	pointer
,	O
1	int
,	O
NULL	O
,	O
'w'	O
}	O
,	O
{	O
"start-insert"	pointer
,	O
1	int
,	O
NULL	O
,	O
'y'	O
}	O
,	O
{	O
"statistics"	pointer
,	O
0	int
,	O
NULL	O
,	O
's'	O
}	O
,	O
{	O
"terminal"	pointer
,	O
0	int
,	O
NULL	O
,	O
't'	O
}	O
,	O
{	O
"version"	pointer
,	O
0	int
,	O
NULL	O
,	O
'v'	O
}	O
,	O
{	O
"diff-input"	pointer
,	O
0	int
,	O
NULL	O
,	O
'd'	O
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
const	O
char	O
*	O
program_name	pointer
;	O
int	O
inhibit_left	int
;	O
int	O
inhibit_right	int
;	O
int	O
inhibit_common	int
;	O
int	O
diff_input	int
;	O
int	O
ignore_case	int
;	O
int	O
show_statistics	int
;	O
int	O
no_wrapping	int
;	O
int	O
autopager	int
;	O
int	O
overstrike	int
;	O
int	O
overstrike_for_less	int
;	O
const	O
char	O
*	O
user_delete_start	pointer
;	O
const	O
char	O
*	O
user_delete_end	pointer
;	O
const	O
char	O
*	O
user_insert_start	pointer
;	O
const	O
char	O
*	O
user_insert_end	pointer
;	O
int	O
find_termcap	int
;	O
const	O
char	O
*	O
term_delete_start	pointer
;	O
const	O
char	O
*	O
term_delete_end	pointer
;	O
const	O
char	O
*	O
term_insert_start	pointer
;	O
const	O
char	O
*	O
term_insert_end	pointer
;	O
enum	O
copy_mode	enum
{	O
COPY_NORMAL	int
,	O
COPY_DELETED	int
,	O
COPY_INSERTED	int
}	O
copy_mode	enum
;	O
jmp_buf	array
signal_label	array
;	O
int	O
interrupted	int
;	O
typedef	O
struct	O
side	struct
SIDE	struct
;	O
struct	O
side	struct
{	O
const	O
char	O
*	O
filename	pointer
;	O
FILE	struct
*	O
file	pointer
;	O
int	O
position	int
;	O
int	O
character	int
;	O
char	O
*	O
temp_name	pointer
;	O
FILE	struct
*	O
temp_file	pointer
;	O
}	O
;	O
SIDE	struct
side_array	array
[	O
2	int
]	O
;	O
SIDE	struct
*	O
left_side	pointer
=	O
&	O
side_array	array
[	O
0	int
]	O
;	O
SIDE	struct
*	O
right_side	pointer
=	O
&	O
side_array	array
[	O
1	int
]	O
;	O
FILE	struct
*	O
input_file	pointer
;	O
int	O
character	int
;	O
char	O
directive	char
;	O
int	O
argument	array
[	O
4	int
]	O
;	O
FILE	struct
*	O
output_file	pointer
;	O
int	O
count_total_left	int
;	O
int	O
count_total_right	int
;	O
int	O
count_isolated_left	int
;	O
int	O
count_isolated_right	int
;	O
int	O
count_changed_left	int
;	O
int	O
count_changed_right	int
;	O
static	O
RETSIGTYPE	void
signal_handler	function
(	O
int	O
number	int
)	O
{	O
interrupted	int
=	O
1	int
;	O
signal	function
(	O
number	int
,	O
signal_handler	function
)	O
;	O
}	O
static	O
void	O
setup_signals	function
(	O
void	O
)	O
{	O
interrupted	int
=	O
0	int
;	O
signal	function
(	O
SIGINT	int
,	O
signal_handler	function
)	O
;	O
signal	function
(	O
SIGPIPE	int
,	O
signal_handler	function
)	O
;	O
signal	function
(	O
SIGTERM	int
,	O
signal_handler	function
)	O
;	O
}	O
static	O
void	O
initialize_strings	function
(	O
void	O
)	O
{	O
if	O
(	O
find_termcap	int
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
char	O
term_buffer	array
[	O
2048	int
]	O
;	O
static	O
char	O
*	O
buffer	pointer
;	O
char	O
*	O
filler	pointer
;	O
int	O
success	int
;	O
name	pointer
=	O
getenv	function
(	O
"TERM"	pointer
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
error	function
(	O
EXIT_ERROR	int
,	O
0	int
,	O
_	O
(	O
"select a terminal through the TERM environment variable"	pointer
)	O
)	O
;	O
success	int
=	O
tgetent	function
(	O
term_buffer	array
,	O
name	pointer
)	O
;	O
if	O
(	O
success	int
<	O
0	int
)	O
error	function
(	O
EXIT_ERROR	int
,	O
0	int
,	O
_	O
(	O
"could not access the termcap data base"	pointer
)	O
)	O
;	O
if	O
(	O
success	int
==	O
0	int
)	O
error	function
(	O
EXIT_ERROR	int
,	O
0	int
,	O
_	O
(	O
"terminal type `%s' is not defined"	pointer
)	O
,	O
name	pointer
)	O
;	O
buffer	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
strlen	function
(	O
term_buffer	array
)	O
)	O
;	O
filler	pointer
=	O
buffer	pointer
;	O
term_delete_start	pointer
=	O
tgetstr	function
(	O
"us"	pointer
,	O
&	O
filler	pointer
)	O
;	O
term_delete_end	pointer
=	O
tgetstr	function
(	O
"ue"	pointer
,	O
&	O
filler	pointer
)	O
;	O
term_insert_start	pointer
=	O
tgetstr	function
(	O
"so"	pointer
,	O
&	O
filler	pointer
)	O
;	O
term_insert_end	pointer
=	O
tgetstr	function
(	O
"se"	pointer
,	O
&	O
filler	pointer
)	O
;	O
}	O
if	O
(	O
!	O
overstrike	int
)	O
{	O
if	O
(	O
!	O
term_delete_start	pointer
&&	O
!	O
user_delete_start	pointer
)	O
user_delete_start	pointer
=	O
"[-"	pointer
;	O
if	O
(	O
!	O
term_delete_end	pointer
&&	O
!	O
user_delete_end	pointer
)	O
user_delete_end	pointer
=	O
"-]"	pointer
;	O
if	O
(	O
!	O
term_insert_start	pointer
&&	O
!	O
user_insert_start	pointer
)	O
user_insert_start	pointer
=	O
"{+"	pointer
;	O
if	O
(	O
!	O
term_insert_end	pointer
&&	O
!	O
user_insert_end	pointer
)	O
user_insert_end	pointer
=	O
"+}"	pointer
;	O
}	O
}	O
static	O
int	O
putc_for_tputs	function
(	O
int	O
chr	int
)	O
{	O
return	O
putc	function
(	O
chr	int
,	O
output_file	pointer
)	O
;	O
}	O
static	O
void	O
start_of_delete	function
(	O
void	O
)	O
{	O
if	O
(	O
inhibit_common	int
&&	O
(	O
inhibit_right	int
||	O
inhibit_left	int
)	O
)	O
return	O
;	O
copy_mode	enum
=	O
COPY_DELETED	int
;	O
if	O
(	O
term_delete_start	pointer
)	O
tputs	function
(	O
term_delete_start	pointer
,	O
0	int
,	O
putc_for_tputs	function
)	O
;	O
if	O
(	O
user_delete_start	pointer
)	O
fprintf	function
(	O
output_file	pointer
,	O
"%s"	pointer
,	O
user_delete_start	pointer
)	O
;	O
}	O
static	O
void	O
end_of_delete	function
(	O
void	O
)	O
{	O
if	O
(	O
inhibit_common	int
&&	O
(	O
inhibit_right	int
||	O
inhibit_left	int
)	O
)	O
return	O
;	O
if	O
(	O
user_delete_end	pointer
)	O
fprintf	function
(	O
output_file	pointer
,	O
"%s"	pointer
,	O
user_delete_end	pointer
)	O
;	O
if	O
(	O
term_delete_end	pointer
)	O
tputs	function
(	O
term_delete_end	pointer
,	O
0	int
,	O
putc_for_tputs	function
)	O
;	O
copy_mode	enum
=	O
COPY_NORMAL	int
;	O
}	O
static	O
void	O
start_of_insert	function
(	O
void	O
)	O
{	O
if	O
(	O
inhibit_common	int
&&	O
(	O
inhibit_right	int
||	O
inhibit_left	int
)	O
)	O
return	O
;	O
copy_mode	enum
=	O
COPY_INSERTED	int
;	O
if	O
(	O
term_insert_start	pointer
)	O
tputs	function
(	O
term_insert_start	pointer
,	O
0	int
,	O
putc_for_tputs	function
)	O
;	O
if	O
(	O
user_insert_start	pointer
)	O
fprintf	function
(	O
output_file	pointer
,	O
"%s"	pointer
,	O
user_insert_start	pointer
)	O
;	O
}	O
static	O
void	O
end_of_insert	function
(	O
void	O
)	O
{	O
if	O
(	O
inhibit_common	int
&&	O
(	O
inhibit_right	int
||	O
inhibit_left	int
)	O
)	O
return	O
;	O
if	O
(	O
user_insert_end	pointer
)	O
fprintf	function
(	O
output_file	pointer
,	O
"%s"	pointer
,	O
user_insert_end	pointer
)	O
;	O
if	O
(	O
term_insert_end	pointer
)	O
tputs	function
(	O
term_insert_end	pointer
,	O
0	int
,	O
putc_for_tputs	function
)	O
;	O
copy_mode	enum
=	O
COPY_NORMAL	int
;	O
}	O
static	O
void	O
skip_whitespace	function
(	O
SIDE	struct
*	O
side	struct
)	O
{	O
if	O
(	O
interrupted	int
)	O
longjmp	function
(	O
signal_label	array
,	O
1	int
)	O
;	O
while	O
(	O
isspace	function
(	O
side	struct
->	O
character	int
)	O
)	O
side	struct
->	O
character	int
=	O
getc	function
(	O
side	struct
->	O
file	pointer
)	O
;	O
}	O
static	O
void	O
skip_word	function
(	O
SIDE	struct
*	O
side	struct
)	O
{	O
if	O
(	O
interrupted	int
)	O
longjmp	function
(	O
signal_label	array
,	O
1	int
)	O
;	O
while	O
(	O
side	struct
->	O
character	int
!=	O
EOF	O
&&	O
!	O
isspace	function
(	O
side	struct
->	O
character	int
)	O
)	O
side	struct
->	O
character	int
=	O
getc	function
(	O
side	struct
->	O
file	pointer
)	O
;	O
side	struct
->	O
position	int
++	O
;	O
}	O
static	O
void	O
copy_whitespace	function
(	O
SIDE	struct
*	O
side	struct
,	O
FILE	struct
*	O
file	pointer
)	O
{	O
if	O
(	O
interrupted	int
)	O
longjmp	function
(	O
signal_label	array
,	O
1	int
)	O
;	O
while	O
(	O
isspace	function
(	O
side	struct
->	O
character	int
)	O
)	O
{	O
switch	O
(	O
copy_mode	enum
)	O
{	O
case	O
COPY_NORMAL	int
:	O
putc	function
(	O
side	struct
->	O
character	int
,	O
file	pointer
)	O
;	O
break	O
;	O
case	O
COPY_DELETED	int
:	O
if	O
(	O
side	struct
->	O
character	int
==	O
'\n'	O
)	O
{	O
if	O
(	O
no_wrapping	int
&&	O
user_delete_end	pointer
)	O
fprintf	function
(	O
output_file	pointer
,	O
"%s"	pointer
,	O
user_delete_end	pointer
)	O
;	O
if	O
(	O
term_delete_end	pointer
)	O
tputs	function
(	O
term_delete_end	pointer
,	O
0	int
,	O
putc_for_tputs	function
)	O
;	O
putc	function
(	O
'\n'	O
,	O
output_file	pointer
)	O
;	O
if	O
(	O
term_delete_start	pointer
)	O
tputs	function
(	O
term_delete_start	pointer
,	O
0	int
,	O
putc_for_tputs	function
)	O
;	O
if	O
(	O
no_wrapping	int
&&	O
user_delete_start	pointer
)	O
fprintf	function
(	O
output_file	pointer
,	O
"%s"	pointer
,	O
user_delete_start	pointer
)	O
;	O
}	O
else	O
if	O
(	O
overstrike_for_less	int
)	O
{	O
putc	function
(	O
'_'	O
,	O
output_file	pointer
)	O
;	O
putc	function
(	O
'\b'	O
,	O
output_file	pointer
)	O
;	O
putc	function
(	O
side	struct
->	O
character	int
,	O
output_file	pointer
)	O
;	O
}	O
else	O
putc	function
(	O
side	struct
->	O
character	int
,	O
output_file	pointer
)	O
;	O
break	O
;	O
case	O
COPY_INSERTED	int
:	O
if	O
(	O
side	struct
->	O
character	int
==	O
'\n'	O
)	O
{	O
if	O
(	O
no_wrapping	int
&&	O
user_insert_end	pointer
)	O
fprintf	function
(	O
output_file	pointer
,	O
"%s"	pointer
,	O
user_insert_end	pointer
)	O
;	O
if	O
(	O
term_insert_end	pointer
)	O
tputs	function
(	O
term_insert_end	pointer
,	O
0	int
,	O
putc_for_tputs	function
)	O
;	O
putc	function
(	O
'\n'	O
,	O
output_file	pointer
)	O
;	O
if	O
(	O
term_insert_start	pointer
)	O
tputs	function
(	O
term_insert_start	pointer
,	O
0	int
,	O
putc_for_tputs	function
)	O
;	O
if	O
(	O
no_wrapping	int
&&	O
user_insert_start	pointer
)	O
fprintf	function
(	O
output_file	pointer
,	O
"%s"	pointer
,	O
user_insert_start	pointer
)	O
;	O
}	O
else	O
if	O
(	O
overstrike_for_less	int
)	O
{	O
putc	function
(	O
side	struct
->	O
character	int
,	O
output_file	pointer
)	O
;	O
putc	function
(	O
'\b'	O
,	O
output_file	pointer
)	O
;	O
putc	function
(	O
side	struct
->	O
character	int
,	O
output_file	pointer
)	O
;	O
}	O
else	O
putc	function
(	O
side	struct
->	O
character	int
,	O
output_file	pointer
)	O
;	O
break	O
;	O
}	O
side	struct
->	O
character	int
=	O
getc	function
(	O
side	struct
->	O
file	pointer
)	O
;	O
}	O
}	O
static	O
void	O
copy_word	function
(	O
SIDE	struct
*	O
side	struct
,	O
FILE	struct
*	O
file	pointer
)	O
{	O
if	O
(	O
interrupted	int
)	O
longjmp	function
(	O
signal_label	array
,	O
1	int
)	O
;	O
while	O
(	O
side	struct
->	O
character	int
!=	O
EOF	O
&&	O
!	O
isspace	function
(	O
side	struct
->	O
character	int
)	O
)	O
{	O
if	O
(	O
overstrike	int
)	O
switch	O
(	O
copy_mode	enum
)	O
{	O
case	O
COPY_NORMAL	int
:	O
putc	function
(	O
side	struct
->	O
character	int
,	O
file	pointer
)	O
;	O
break	O
;	O
case	O
COPY_DELETED	int
:	O
putc	function
(	O
'_'	O
,	O
output_file	pointer
)	O
;	O
if	O
(	O
side	struct
->	O
character	int
!=	O
'_'	O
)	O
{	O
putc	function
(	O
'\b'	O
,	O
output_file	pointer
)	O
;	O
putc	function
(	O
side	struct
->	O
character	int
,	O
output_file	pointer
)	O
;	O
}	O
break	O
;	O
case	O
COPY_INSERTED	int
:	O
putc	function
(	O
side	struct
->	O
character	int
,	O
output_file	pointer
)	O
;	O
putc	function
(	O
'\b'	O
,	O
output_file	pointer
)	O
;	O
putc	function
(	O
side	struct
->	O
character	int
,	O
output_file	pointer
)	O
;	O
break	O
;	O
}	O
else	O
putc	function
(	O
side	struct
->	O
character	int
,	O
file	pointer
)	O
;	O
side	struct
->	O
character	int
=	O
getc	function
(	O
side	struct
->	O
file	pointer
)	O
;	O
}	O
side	struct
->	O
position	int
++	O
;	O
}	O
static	O
char	O
*	O
create_template_filename	function
(	O
)	O
{	O
struct	O
stat	struct
stat_buffer	struct
;	O
const	O
char	O
*	O
dir	pointer
;	O
size_t	long
dirlen	long
;	O
char	O
*	O
tmpl	pointer
;	O
dir	pointer
=	O
getenv	function
(	O
"TMPDIR"	pointer
)	O
;	O
if	O
(	O
dir	pointer
&&	O
(	O
stat	struct
(	O
dir	pointer
,	O
&	O
stat_buffer	struct
)	O
==	O
0	int
)	O
&&	O
(	O
(	O
stat_buffer	struct
.	O
st_mode	int
&	O
S_IFMT	O
)	O
==	O
S_IFDIR	O
)	O
)	O
;	O
else	O
if	O
(	O
(	O
stat	struct
(	O
P_tmpdir	pointer
,	O
&	O
stat_buffer	struct
)	O
==	O
0	int
)	O
&&	O
(	O
(	O
stat_buffer	struct
.	O
st_mode	int
&	O
S_IFMT	O
)	O
==	O
S_IFDIR	O
)	O
)	O
dir	pointer
=	O
P_tmpdir	pointer
;	O
else	O
if	O
(	O
(	O
stat	struct
(	O
"/tmp"	pointer
,	O
&	O
stat_buffer	struct
)	O
==	O
0	int
)	O
&&	O
(	O
(	O
stat_buffer	struct
.	O
st_mode	int
&	O
S_IFMT	O
)	O
==	O
S_IFDIR	O
)	O
)	O
dir	pointer
=	O
"/tmp"	pointer
;	O
else	O
{	O
errno	O
=	O
ENOENT	int
;	O
return	O
NULL	O
;	O
}	O
dirlen	long
=	O
strlen	function
(	O
dir	pointer
)	O
;	O
while	O
(	O
dirlen	long
>	O
1	int
&&	O
dir	pointer
[	O
dirlen	long
-	O
1	int
]	O
==	O
'/'	O
)	O
dirlen	long
--	O
;	O
tmpl	pointer
=	O
xmalloc	function
(	O
dirlen	long
+	O
1	int
+	O
12	int
+	O
1	int
)	O
;	O
sprintf	function
(	O
tmpl	pointer
,	O
"%.*s/wdiff.XXXXXX"	pointer
,	O
(	O
int	O
)	O
dirlen	long
,	O
dir	pointer
)	O
;	O
return	O
tmpl	pointer
;	O
}	O
static	O
void	O
create_temporary_side	function
(	O
SIDE	struct
*	O
side	struct
)	O
{	O
int	O
fd	int
;	O
if	O
(	O
(	O
side	struct
->	O
temp_name	pointer
=	O
create_template_filename	function
(	O
)	O
)	O
==	O
NULL	O
)	O
error	function
(	O
EXIT_ERROR	int
,	O
errno	O
,	O
_	O
(	O
"no suitable temporary directory exists"	pointer
)	O
)	O
;	O
if	O
(	O
(	O
fd	int
=	O
mkstemp	function
(	O
side	struct
->	O
temp_name	pointer
)	O
)	O
==	O
-	O
1	int
)	O
error	function
(	O
EXIT_ERROR	int
,	O
errno	O
,	O
"%s"	pointer
,	O
side	struct
->	O
temp_name	pointer
)	O
;	O
side	struct
->	O
file	pointer
=	O
fdopen	function
(	O
fd	int
,	O
"w+"	pointer
)	O
;	O
if	O
(	O
side	struct
->	O
file	pointer
==	O
NULL	O
)	O
error	function
(	O
EXIT_ERROR	int
,	O
errno	O
,	O
"%s"	pointer
,	O
side	struct
->	O
temp_name	pointer
)	O
;	O
if	O
(	O
unlink	function
(	O
side	struct
->	O
temp_name	pointer
)	O
!=	O
0	int
)	O
error	function
(	O
EXIT_ERROR	int
,	O
errno	O
,	O
"%s"	pointer
,	O
side	struct
->	O
temp_name	pointer
)	O
;	O
}	O
static	O
void	O
split_diff	function
(	O
const	O
char	O
*	O
path	pointer
)	O
{	O
FILE	struct
*	O
input	pointer
;	O
int	O
character	int
;	O
int	O
start_of_line	int
=	O
1	int
;	O
int	O
output_to	int
=	O
3	int
;	O
if	O
(	O
path	pointer
==	O
NULL	O
)	O
{	O
input	pointer
=	O
stdin	pointer
;	O
}	O
else	O
{	O
input	pointer
=	O
fopen	function
(	O
path	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
input	pointer
==	O
NULL	O
)	O
error	function
(	O
EXIT_ERROR	int
,	O
errno	O
,	O
"%s"	pointer
,	O
path	pointer
)	O
;	O
}	O
create_temporary_side	function
(	O
left_side	pointer
)	O
;	O
create_temporary_side	function
(	O
right_side	pointer
)	O
;	O
while	O
(	O
(	O
character	int
=	O
getc	function
(	O
input	pointer
)	O
)	O
!=	O
EOF	O
)	O
{	O
if	O
(	O
start_of_line	int
)	O
{	O
start_of_line	int
=	O
0	int
;	O
switch	O
(	O
character	int
)	O
{	O
case	O
'-'	O
:	O
output_to	int
=	O
1	int
;	O
continue	O
;	O
case	O
'+'	O
:	O
output_to	int
=	O
2	int
;	O
continue	O
;	O
case	O
' '	O
:	O
output_to	int
=	O
3	int
;	O
continue	O
;	O
default	O
:	O
output_to	int
=	O
3	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
output_to	int
&	O
1	int
)	O
putc	function
(	O
character	int
,	O
left_side	pointer
->	O
file	pointer
)	O
;	O
if	O
(	O
output_to	int
&	O
2	int
)	O
putc	function
(	O
character	int
,	O
right_side	pointer
->	O
file	pointer
)	O
;	O
start_of_line	int
=	O
(	O
character	int
==	O
'\n'	O
||	O
character	int
==	O
'\r'	O
)	O
;	O
}	O
rewind	function
(	O
left_side	pointer
->	O
file	pointer
)	O
;	O
rewind	function
(	O
right_side	pointer
->	O
file	pointer
)	O
;	O
}	O
static	O
void	O
split_file_into_words	function
(	O
SIDE	struct
*	O
side	struct
)	O
{	O
struct	O
stat	struct
stat_buffer	struct
;	O
int	O
fd	int
;	O
FILE	struct
*	O
input	pointer
;	O
if	O
(	O
!	O
diff_input	int
)	O
{	O
if	O
(	O
side	struct
->	O
filename	pointer
==	O
NULL	O
)	O
{	O
side	struct
->	O
file	pointer
=	O
stdin	pointer
;	O
}	O
else	O
{	O
if	O
(	O
stat	struct
(	O
side	struct
->	O
filename	pointer
,	O
&	O
stat_buffer	struct
)	O
!=	O
0	int
)	O
error	function
(	O
EXIT_ERROR	int
,	O
errno	O
,	O
"%s"	pointer
,	O
side	struct
->	O
filename	pointer
)	O
;	O
if	O
(	O
(	O
stat_buffer	struct
.	O
st_mode	int
&	O
S_IFMT	O
)	O
==	O
S_IFDIR	O
)	O
error	function
(	O
EXIT_ERROR	int
,	O
0	int
,	O
_	O
(	O
"directories not supported"	pointer
)	O
)	O
;	O
side	struct
->	O
file	pointer
=	O
fopen	function
(	O
side	struct
->	O
filename	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
side	struct
->	O
file	pointer
==	O
NULL	O
)	O
error	function
(	O
EXIT_ERROR	int
,	O
errno	O
,	O
"%s"	pointer
,	O
side	struct
->	O
filename	pointer
)	O
;	O
}	O
if	O
(	O
fseek	function
(	O
side	struct
->	O
file	pointer
,	O
0L	int
,	O
SEEK_CUR	int
)	O
!=	O
0	int
)	O
{	O
input	pointer
=	O
side	struct
->	O
file	pointer
;	O
create_temporary_side	function
(	O
side	struct
)	O
;	O
while	O
(	O
side	struct
->	O
character	int
=	O
getc	function
(	O
input	pointer
)	O
,	O
side	struct
->	O
character	int
!=	O
EOF	O
)	O
putc	function
(	O
side	struct
->	O
character	int
,	O
side	struct
->	O
file	pointer
)	O
;	O
rewind	function
(	O
side	struct
->	O
file	pointer
)	O
;	O
}	O
}	O
side	struct
->	O
character	int
=	O
getc	function
(	O
side	struct
->	O
file	pointer
)	O
;	O
side	struct
->	O
position	int
=	O
0	int
;	O
if	O
(	O
(	O
side	struct
->	O
temp_name	pointer
=	O
create_template_filename	function
(	O
)	O
)	O
==	O
NULL	O
)	O
error	function
(	O
EXIT_ERROR	int
,	O
errno	O
,	O
_	O
(	O
"no suitable temporary directory exists"	pointer
)	O
)	O
;	O
if	O
(	O
(	O
fd	int
=	O
mkstemp	function
(	O
side	struct
->	O
temp_name	pointer
)	O
)	O
==	O
-	O
1	int
)	O
error	function
(	O
EXIT_ERROR	int
,	O
errno	O
,	O
"%s"	pointer
,	O
side	struct
->	O
temp_name	pointer
)	O
;	O
side	struct
->	O
temp_file	pointer
=	O
fdopen	function
(	O
fd	int
,	O
"w"	pointer
)	O
;	O
if	O
(	O
side	struct
->	O
temp_file	pointer
==	O
NULL	O
)	O
error	function
(	O
EXIT_ERROR	int
,	O
errno	O
,	O
"%s"	pointer
,	O
side	struct
->	O
temp_name	pointer
)	O
;	O
while	O
(	O
side	struct
->	O
character	int
!=	O
EOF	O
)	O
{	O
if	O
(	O
interrupted	int
)	O
longjmp	function
(	O
signal_label	array
,	O
1	int
)	O
;	O
skip_whitespace	function
(	O
side	struct
)	O
;	O
if	O
(	O
side	struct
->	O
character	int
==	O
EOF	O
)	O
break	O
;	O
copy_word	function
(	O
side	struct
,	O
side	struct
->	O
temp_file	pointer
)	O
;	O
putc	function
(	O
'\n'	O
,	O
side	struct
->	O
temp_file	pointer
)	O
;	O
}	O
fclose	function
(	O
side	struct
->	O
temp_file	pointer
)	O
;	O
}	O
static	O
int	O
decode_directive_line	function
(	O
void	O
)	O
{	O
int	O
value	int
;	O
int	O
state	pointer
;	O
int	O
error	function
;	O
error	function
=	O
0	int
;	O
state	pointer
=	O
0	int
;	O
value	int
=	O
0	int
;	O
while	O
(	O
!	O
error	function
&&	O
state	pointer
<	O
4	int
)	O
{	O
if	O
(	O
isdigit	function
(	O
character	int
)	O
)	O
{	O
value	int
=	O
0	int
;	O
while	O
(	O
isdigit	function
(	O
character	int
)	O
)	O
{	O
value	int
=	O
10	int
*	O
value	int
+	O
character	int
-	O
'0'	O
;	O
character	int
=	O
getc	function
(	O
input_file	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
state	pointer
!=	O
1	int
&&	O
state	pointer
!=	O
3	int
)	O
error	function
=	O
1	int
;	O
argument	array
[	O
state	pointer
]	O
=	O
value	int
;	O
switch	O
(	O
state	pointer
)	O
{	O
case	O
0	int
:	O
case	O
2	int
:	O
if	O
(	O
character	int
==	O
','	O
)	O
character	int
=	O
getc	function
(	O
input_file	pointer
)	O
;	O
break	O
;	O
case	O
1	int
:	O
if	O
(	O
character	int
==	O
'a'	O
||	O
character	int
==	O
'd'	O
||	O
character	int
==	O
'c'	O
)	O
{	O
directive	char
=	O
character	int
;	O
character	int
=	O
getc	function
(	O
input_file	pointer
)	O
;	O
}	O
else	O
error	function
=	O
1	int
;	O
break	O
;	O
case	O
3	int
:	O
if	O
(	O
character	int
!=	O
'\n'	O
)	O
error	function
=	O
1	int
;	O
break	O
;	O
}	O
state	pointer
++	O
;	O
}	O
while	O
(	O
character	int
!=	O
EOF	O
&&	O
character	int
!=	O
'\n'	O
)	O
character	int
=	O
getc	function
(	O
input_file	pointer
)	O
;	O
if	O
(	O
character	int
==	O
'\n'	O
)	O
character	int
=	O
getc	function
(	O
input_file	pointer
)	O
;	O
return	O
!	O
error	function
;	O
}	O
static	O
void	O
skip_until_ordinal	function
(	O
SIDE	struct
*	O
side	struct
,	O
int	O
ordinal	int
)	O
{	O
while	O
(	O
side	struct
->	O
position	int
<	O
ordinal	int
)	O
{	O
skip_whitespace	function
(	O
side	struct
)	O
;	O
skip_word	function
(	O
side	struct
)	O
;	O
}	O
}	O
static	O
void	O
copy_until_ordinal	function
(	O
SIDE	struct
*	O
side	struct
,	O
int	O
ordinal	int
)	O
{	O
while	O
(	O
side	struct
->	O
position	int
<	O
ordinal	int
)	O
{	O
copy_whitespace	function
(	O
side	struct
,	O
output_file	pointer
)	O
;	O
copy_word	function
(	O
side	struct
,	O
output_file	pointer
)	O
;	O
}	O
}	O
static	O
void	O
reformat_diff_output	function
(	O
void	O
)	O
{	O
int	O
resync_left	int
;	O
int	O
resync_right	int
;	O
rewind	function
(	O
left_side	pointer
->	O
file	pointer
)	O
;	O
left_side	pointer
->	O
character	int
=	O
getc	function
(	O
left_side	pointer
->	O
file	pointer
)	O
;	O
left_side	pointer
->	O
position	int
=	O
0	int
;	O
rewind	function
(	O
right_side	pointer
->	O
file	pointer
)	O
;	O
right_side	pointer
->	O
character	int
=	O
getc	function
(	O
right_side	pointer
->	O
file	pointer
)	O
;	O
right_side	pointer
->	O
position	int
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
interrupted	int
)	O
longjmp	function
(	O
signal_label	array
,	O
1	int
)	O
;	O
while	O
(	O
character	int
!=	O
EOF	O
&&	O
!	O
isdigit	function
(	O
character	int
)	O
)	O
{	O
while	O
(	O
character	int
!=	O
EOF	O
&&	O
character	int
!=	O
'\n'	O
)	O
character	int
=	O
getc	function
(	O
input_file	pointer
)	O
;	O
if	O
(	O
character	int
==	O
'\n'	O
)	O
character	int
=	O
getc	function
(	O
input_file	pointer
)	O
;	O
}	O
if	O
(	O
character	int
==	O
EOF	O
)	O
break	O
;	O
if	O
(	O
decode_directive_line	function
(	O
)	O
)	O
{	O
switch	O
(	O
directive	char
)	O
{	O
case	O
'a'	O
:	O
count_isolated_right	int
+=	O
argument	array
[	O
3	int
]	O
-	O
argument	array
[	O
2	int
]	O
+	O
1	int
;	O
resync_left	int
=	O
argument	array
[	O
0	int
]	O
;	O
resync_right	int
=	O
argument	array
[	O
2	int
]	O
-	O
1	int
;	O
break	O
;	O
case	O
'd'	O
:	O
count_isolated_left	int
+=	O
argument	array
[	O
1	int
]	O
-	O
argument	array
[	O
0	int
]	O
+	O
1	int
;	O
resync_left	int
=	O
argument	array
[	O
0	int
]	O
-	O
1	int
;	O
resync_right	int
=	O
argument	array
[	O
2	int
]	O
;	O
break	O
;	O
case	O
'c'	O
:	O
count_changed_left	int
+=	O
argument	array
[	O
1	int
]	O
-	O
argument	array
[	O
0	int
]	O
+	O
1	int
;	O
count_changed_right	int
+=	O
argument	array
[	O
3	int
]	O
-	O
argument	array
[	O
2	int
]	O
+	O
1	int
;	O
resync_left	int
=	O
argument	array
[	O
0	int
]	O
-	O
1	int
;	O
resync_right	int
=	O
argument	array
[	O
2	int
]	O
-	O
1	int
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
if	O
(	O
!	O
inhibit_left	int
)	O
{	O
if	O
(	O
!	O
inhibit_common	int
&&	O
inhibit_right	int
)	O
copy_until_ordinal	function
(	O
left_side	pointer
,	O
resync_left	int
)	O
;	O
else	O
skip_until_ordinal	function
(	O
left_side	pointer
,	O
resync_left	int
)	O
;	O
}	O
if	O
(	O
!	O
inhibit_right	int
)	O
{	O
if	O
(	O
inhibit_common	int
)	O
skip_until_ordinal	function
(	O
right_side	pointer
,	O
resync_right	int
)	O
;	O
else	O
copy_until_ordinal	function
(	O
right_side	pointer
,	O
resync_right	int
)	O
;	O
}	O
if	O
(	O
!	O
inhibit_common	int
&&	O
inhibit_left	int
&&	O
inhibit_right	int
)	O
copy_until_ordinal	function
(	O
right_side	pointer
,	O
resync_right	int
)	O
;	O
if	O
(	O
inhibit_left	int
&&	O
inhibit_right	int
)	O
{	O
if	O
(	O
!	O
inhibit_common	int
)	O
fprintf	function
(	O
output_file	pointer
,	O
"\n%s\n"	pointer
,	O
SEPARATOR_LINE	pointer
)	O
;	O
}	O
else	O
if	O
(	O
inhibit_common	int
)	O
fprintf	function
(	O
output_file	pointer
,	O
"\n%s\n"	pointer
,	O
SEPARATOR_LINE	pointer
)	O
;	O
if	O
(	O
(	O
directive	char
==	O
'd'	O
||	O
directive	char
==	O
'c'	O
)	O
&&	O
!	O
inhibit_left	int
)	O
{	O
copy_whitespace	function
(	O
left_side	pointer
,	O
output_file	pointer
)	O
;	O
start_of_delete	function
(	O
)	O
;	O
copy_word	function
(	O
left_side	pointer
,	O
output_file	pointer
)	O
;	O
copy_until_ordinal	function
(	O
left_side	pointer
,	O
argument	array
[	O
1	int
]	O
)	O
;	O
end_of_delete	function
(	O
)	O
;	O
}	O
if	O
(	O
directive	char
==	O
'a'	O
||	O
directive	char
==	O
'c'	O
)	O
if	O
(	O
inhibit_right	int
)	O
{	O
if	O
(	O
!	O
inhibit_common	int
&&	O
inhibit_left	int
)	O
skip_until_ordinal	function
(	O
right_side	pointer
,	O
argument	array
[	O
3	int
]	O
)	O
;	O
}	O
else	O
{	O
copy_whitespace	function
(	O
right_side	pointer
,	O
output_file	pointer
)	O
;	O
start_of_insert	function
(	O
)	O
;	O
copy_word	function
(	O
right_side	pointer
,	O
output_file	pointer
)	O
;	O
copy_until_ordinal	function
(	O
right_side	pointer
,	O
argument	array
[	O
3	int
]	O
)	O
;	O
end_of_insert	function
(	O
)	O
;	O
}	O
}	O
}	O
complete_input_program	function
(	O
)	O
;	O
input_file	pointer
=	O
0	int
;	O
if	O
(	O
inhibit_common	int
)	O
{	O
if	O
(	O
!	O
inhibit_left	int
||	O
!	O
inhibit_right	int
)	O
fprintf	function
(	O
output_file	pointer
,	O
"\n%s\n"	pointer
,	O
SEPARATOR_LINE	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
inhibit_left	int
&&	O
inhibit_right	int
)	O
{	O
copy_until_ordinal	function
(	O
left_side	pointer
,	O
count_total_left	int
)	O
;	O
copy_whitespace	function
(	O
left_side	pointer
,	O
output_file	pointer
)	O
;	O
}	O
else	O
{	O
copy_until_ordinal	function
(	O
right_side	pointer
,	O
count_total_right	int
)	O
;	O
copy_whitespace	function
(	O
right_side	pointer
,	O
output_file	pointer
)	O
;	O
}	O
fclose	function
(	O
left_side	pointer
->	O
file	pointer
)	O
;	O
fclose	function
(	O
right_side	pointer
->	O
file	pointer
)	O
;	O
}	O
static	O
void	O
launch_input_program	function
(	O
void	O
)	O
{	O
if	O
(	O
ignore_case	int
)	O
input_file	pointer
=	O
readpipe	function
(	O
DIFF_PROGRAM	pointer
,	O
"-i"	pointer
,	O
left_side	pointer
->	O
temp_name	pointer
,	O
right_side	pointer
->	O
temp_name	pointer
,	O
NULL	O
)	O
;	O
else	O
input_file	pointer
=	O
readpipe	function
(	O
DIFF_PROGRAM	pointer
,	O
left_side	pointer
->	O
temp_name	pointer
,	O
right_side	pointer
->	O
temp_name	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
input_file	pointer
)	O
error	function
(	O
EXIT_ERROR	int
,	O
errno	O
,	O
"%s"	pointer
,	O
DIFF_PROGRAM	pointer
)	O
;	O
character	int
=	O
getc	function
(	O
input_file	pointer
)	O
;	O
}	O
static	O
void	O
complete_input_program	function
(	O
void	O
)	O
{	O
int	O
status	int
;	O
fclose	function
(	O
input_file	pointer
)	O
;	O
wait	function
(	O
&	O
status	int
)	O
;	O
if	O
(	O
WIFEXITED	O
(	O
status	int
)	O
)	O
{	O
status	int
=	O
WEXITSTATUS	O
(	O
status	int
)	O
;	O
if	O
(	O
status	int
==	O
0	int
||	O
status	int
==	O
1	int
)	O
return	O
;	O
}	O
else	O
if	O
(	O
WIFSIGNALED	O
(	O
status	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: input program killed by signal %d\n"	pointer
)	O
,	O
program_name	pointer
,	O
(	O
int	O
)	O
WTERMSIG	O
(	O
status	int
)	O
)	O
;	O
}	O
exit	function
(	O
EXIT_ERROR	int
)	O
;	O
}	O
static	O
void	O
launch_output_program	function
(	O
void	O
)	O
{	O
char	O
*	O
program	pointer
;	O
if	O
(	O
autopager	int
&&	O
isatty	function
(	O
fileno	function
(	O
stdout	pointer
)	O
)	O
&&	O
!	O
(	O
inhibit_left	int
&&	O
inhibit_right	int
&&	O
inhibit_common	int
)	O
)	O
{	O
program	pointer
=	O
getenv	function
(	O
"WDIFF_PAGER"	pointer
)	O
;	O
if	O
(	O
program	pointer
==	O
NULL	O
)	O
program	pointer
=	O
getenv	function
(	O
"PAGER"	pointer
)	O
;	O
}	O
else	O
program	pointer
=	O
NULL	O
;	O
output_file	pointer
=	O
stdout	pointer
;	O
if	O
(	O
program	pointer
&&	O
*	O
program	pointer
)	O
{	O
char	O
*	O
lessenv	pointer
;	O
lessenv	pointer
=	O
getenv	function
(	O
"LESS"	pointer
)	O
;	O
if	O
(	O
lessenv	pointer
==	O
NULL	O
)	O
{	O
setenv	function
(	O
"LESS"	pointer
,	O
LESS_DEFAULT_OPTS	pointer
,	O
0	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
asprintf	function
(	O
&	O
lessenv	pointer
,	O
"%s %s"	pointer
,	O
LESS_DEFAULT_OPTS	pointer
,	O
lessenv	pointer
)	O
==	O
-	O
1	int
)	O
{	O
xalloc_die	function
(	O
)	O
;	O
return	O
;	O
}	O
else	O
{	O
setenv	function
(	O
"LESS"	pointer
,	O
lessenv	pointer
,	O
1	int
)	O
;	O
}	O
}	O
output_file	pointer
=	O
writepipe	function
(	O
program	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
output_file	pointer
)	O
error	function
(	O
EXIT_ERROR	int
,	O
errno	O
,	O
"%s"	pointer
,	O
program	pointer
)	O
;	O
}	O
}	O
static	O
void	O
complete_output_program	function
(	O
void	O
)	O
{	O
switch	O
(	O
copy_mode	enum
)	O
{	O
case	O
COPY_DELETED	int
:	O
end_of_delete	function
(	O
)	O
;	O
break	O
;	O
case	O
COPY_INSERTED	int
:	O
end_of_insert	function
(	O
)	O
;	O
break	O
;	O
case	O
COPY_NORMAL	int
:	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
if	O
(	O
output_file	pointer
&&	O
output_file	pointer
!=	O
stdout	pointer
)	O
{	O
int	O
status	int
;	O
fclose	function
(	O
output_file	pointer
)	O
;	O
wait	function
(	O
&	O
status	int
)	O
;	O
if	O
(	O
WIFSIGNALED	O
(	O
status	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: output program killed by signal %d\n"	pointer
)	O
,	O
program_name	pointer
,	O
(	O
int	O
)	O
WTERMSIG	O
(	O
status	int
)	O
)	O
;	O
exit	function
(	O
EXIT_ERROR	int
)	O
;	O
}	O
}	O
}	O
static	O
void	O
print_statistics	function
(	O
void	O
)	O
{	O
int	O
count_common_left	int
;	O
int	O
count_common_right	int
;	O
count_common_left	int
=	O
count_total_left	int
-	O
count_isolated_left	int
-	O
count_changed_left	int
;	O
count_common_right	int
=	O
count_total_right	int
-	O
count_isolated_right	int
-	O
count_changed_right	int
;	O
printf	function
(	O
ngettext	function
(	O
"%s: %d word"	pointer
,	O
"%s: %d words"	pointer
,	O
count_total_left	int
)	O
,	O
left_side	pointer
->	O
filename	pointer
,	O
count_total_left	int
)	O
;	O
if	O
(	O
count_total_left	int
>	O
0	int
)	O
{	O
printf	function
(	O
ngettext	function
(	O
"  %d %.0f%% common"	pointer
,	O
"  %d %.0f%% common"	pointer
,	O
count_common_left	int
)	O
,	O
count_common_left	int
,	O
count_common_left	int
*	O
100.	int
/	O
count_total_left	int
)	O
;	O
printf	function
(	O
ngettext	function
(	O
"  %d %.0f%% deleted"	pointer
,	O
"  %d %.0f%% deleted"	pointer
,	O
count_isolated_left	int
)	O
,	O
count_isolated_left	int
,	O
count_isolated_left	int
*	O
100.	int
/	O
count_total_left	int
)	O
;	O
printf	function
(	O
ngettext	function
(	O
"  %d %.0f%% changed"	pointer
,	O
"  %d %.0f%% changed"	pointer
,	O
count_changed_left	int
)	O
,	O
count_changed_left	int
,	O
count_changed_left	int
*	O
100.	int
/	O
count_total_left	int
)	O
;	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
ngettext	function
(	O
"%s: %d word"	pointer
,	O
"%s: %d words"	pointer
,	O
count_total_right	int
)	O
,	O
right_side	pointer
->	O
filename	pointer
,	O
count_total_right	int
)	O
;	O
if	O
(	O
count_total_right	int
>	O
0	int
)	O
{	O
printf	function
(	O
ngettext	function
(	O
"  %d %.0f%% common"	pointer
,	O
"  %d %.0f%% common"	pointer
,	O
count_common_right	int
)	O
,	O
count_common_right	int
,	O
count_common_right	int
*	O
100.	int
/	O
count_total_right	int
)	O
;	O
printf	function
(	O
ngettext	function
(	O
"  %d %.0f%% inserted"	pointer
,	O
"  %d %.0f%% inserted"	pointer
,	O
count_isolated_right	int
)	O
,	O
count_isolated_right	int
,	O
count_isolated_right	int
*	O
100.	int
/	O
count_total_right	int
)	O
;	O
printf	function
(	O
ngettext	function
(	O
"  %d %.0f%% changed"	pointer
,	O
"  %d %.0f%% changed"	pointer
,	O
count_changed_right	int
)	O
,	O
count_changed_right	int
,	O
count_changed_right	int
*	O
100.	int
/	O
count_total_right	int
)	O
;	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
static	O
void	O
print_copyright	function
(	O
void	O
)	O
{	O
fputs	function
(	O
_	O
(	O
"This program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
}	O
static	O
void	O
usage	function
(	O
int	O
status	int
)	O
{	O
if	O
(	O
status	int
!=	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Try `%s --help' for more information.\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
else	O
{	O
fputs	function
(	O
_	O
(	O
"wdiff - Compares words in two files and report differences.\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
stdout	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Usage: %s [OPTION]... FILE1 FILE2\n   or: %s -d [OPTION]... [FILE]\n"	pointer
)	O
,	O
program_name	pointer
,	O
program_name	pointer
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
stdout	pointer
)	O
;	O
fputs	function
(	O
_	O
(	O
"Mandatory arguments to long options are mandatory for short options too.\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
fputs	function
(	O
_	O
(	O
"  -C, --copyright            display copyright then exit\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
fputs	function
(	O
_	O
(	O
"  -1, --no-deleted           inhibit output of deleted words\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
fputs	function
(	O
_	O
(	O
"  -2, --no-inserted          inhibit output of inserted words\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
fputs	function
(	O
_	O
(	O
"  -3, --no-common            inhibit output of common words\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
fputs	function
(	O
_	O
(	O
"  -a, --auto-pager           automatically calls a pager\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
fputs	function
(	O
_	O
(	O
"  -d, --diff-input           use single unified diff as input\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
fputs	function
(	O
_	O
(	O
"  -h, --help                 display this help then exit\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
fputs	function
(	O
_	O
(	O
"  -i, --ignore-case          fold character case while comparing\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
fputs	function
(	O
_	O
(	O
"  -l, --less-mode            variation of printer mode for \"less\"\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
fputs	function
(	O
_	O
(	O
"  -n, --avoid-wraps          do not extend fields through newlines\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
fputs	function
(	O
_	O
(	O
"  -p, --printer              overstrike as for printers\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
fputs	function
(	O
_	O
(	O
"  -s, --statistics           say how many words deleted, inserted etc.\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
fputs	function
(	O
_	O
(	O
"  -t, --terminal             use termcap as for terminal displays\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
fputs	function
(	O
_	O
(	O
"  -v, --version              display program version then exit\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
fputs	function
(	O
_	O
(	O
"  -w, --start-delete=STRING  string to mark beginning of delete region\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
fputs	function
(	O
_	O
(	O
"  -x, --end-delete=STRING    string to mark end of delete region\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
fputs	function
(	O
_	O
(	O
"  -y, --start-insert=STRING  string to mark beginning of insert region\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
fputs	function
(	O
_	O
(	O
"  -z, --end-insert=STRING    string to mark end of insert region\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
stdout	pointer
)	O
;	O
fputs	function
(	O
_	O
(	O
"Report bugs to <wdiff-bugs@gnu.org>.\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
}	O
exit	function
(	O
status	int
)	O
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
const	O
argv	array
[	O
]	O
)	O
{	O
int	O
option_char	int
;	O
program_name	pointer
=	O
argv	array
[	O
0	int
]	O
;	O
setlocale	function
(	O
LC_ALL	O
,	O
""	pointer
)	O
;	O
bindtextdomain	function
(	O
PACKAGE	pointer
,	O
LOCALEDIR	O
)	O
;	O
textdomain	function
(	O
PACKAGE	pointer
)	O
;	O
inhibit_left	int
=	O
0	int
;	O
inhibit_right	int
=	O
0	int
;	O
inhibit_common	int
=	O
0	int
;	O
diff_input	int
=	O
0	int
;	O
ignore_case	int
=	O
0	int
;	O
show_statistics	int
=	O
0	int
;	O
no_wrapping	int
=	O
0	int
;	O
autopager	int
=	O
0	int
;	O
overstrike	int
=	O
0	int
;	O
overstrike_for_less	int
=	O
0	int
;	O
user_delete_start	pointer
=	O
NULL	O
;	O
user_delete_end	pointer
=	O
NULL	O
;	O
user_insert_start	pointer
=	O
NULL	O
;	O
user_insert_end	pointer
=	O
NULL	O
;	O
find_termcap	int
=	O
-	O
1	int
;	O
term_delete_start	pointer
=	O
NULL	O
;	O
term_delete_end	pointer
=	O
NULL	O
;	O
term_insert_start	pointer
=	O
NULL	O
;	O
term_insert_end	pointer
=	O
NULL	O
;	O
copy_mode	enum
=	O
COPY_NORMAL	int
;	O
count_total_left	int
=	O
0	int
;	O
count_total_right	int
=	O
0	int
;	O
count_isolated_left	int
=	O
0	int
;	O
count_isolated_right	int
=	O
0	int
;	O
count_changed_left	int
=	O
0	int
;	O
count_changed_right	int
=	O
0	int
;	O
while	O
(	O
option_char	int
=	O
getopt_long	function
(	O
argc	int
,	O
(	O
char	O
*	O
*	O
)	O
argv	array
,	O
"123CKadhilnpstvw:x:y:z:"	pointer
,	O
longopts	array
,	O
NULL	O
)	O
,	O
option_char	int
!=	O
EOF	O
)	O
switch	O
(	O
option_char	int
)	O
{	O
case	O
'1'	O
:	O
inhibit_left	int
=	O
1	int
;	O
break	O
;	O
case	O
'2'	O
:	O
inhibit_right	int
=	O
1	int
;	O
break	O
;	O
case	O
'3'	O
:	O
inhibit_common	int
=	O
1	int
;	O
break	O
;	O
case	O
'C'	O
:	O
print_copyright	function
(	O
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
case	O
'a'	O
:	O
autopager	int
=	O
1	int
;	O
break	O
;	O
case	O
'd'	O
:	O
diff_input	int
=	O
1	int
;	O
break	O
;	O
case	O
'h'	O
:	O
usage	function
(	O
EXIT_SUCCESS	int
)	O
;	O
case	O
'i'	O
:	O
ignore_case	int
=	O
1	int
;	O
break	O
;	O
case	O
'l'	O
:	O
if	O
(	O
find_termcap	int
<	O
0	int
)	O
find_termcap	int
=	O
0	int
;	O
overstrike	int
=	O
1	int
;	O
overstrike_for_less	int
=	O
1	int
;	O
break	O
;	O
case	O
'n'	O
:	O
no_wrapping	int
=	O
1	int
;	O
break	O
;	O
case	O
'p'	O
:	O
overstrike	int
=	O
1	int
;	O
break	O
;	O
case	O
's'	O
:	O
show_statistics	int
=	O
1	int
;	O
break	O
;	O
case	O
'K'	O
:	O
case	O
't'	O
:	O
if	O
(	O
find_termcap	int
<	O
0	int
)	O
find_termcap	int
=	O
1	int
;	O
break	O
;	O
case	O
'v'	O
:	O
printf	function
(	O
"wdiff (GNU %s) %s\n"	pointer
,	O
PACKAGE	pointer
,	O
VERSION	pointer
)	O
;	O
fputs	function
(	O
_	O
(	O
"\nCopyright (C) 1992, 1997, 1998, 1999, 2009, 2010, 2011, 2012 Free Software\nFoundation, Inc.\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
fputs	function
(	O
_	O
(	O
"This is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
fputs	function
(	O
_	O
(	O
"\nWritten by Franc,ois Pinard <pinard@iro.umontreal.ca>.\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
case	O
'w'	O
:	O
user_delete_start	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'x'	O
:	O
user_delete_end	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'y'	O
:	O
user_insert_start	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'z'	O
:	O
user_insert_end	pointer
=	O
optarg	pointer
;	O
break	O
;	O
default	O
:	O
usage	function
(	O
EXIT_ERROR	int
)	O
;	O
}	O
if	O
(	O
find_termcap	int
<	O
0	int
)	O
find_termcap	int
=	O
autopager	int
&&	O
isatty	function
(	O
fileno	function
(	O
stdout	pointer
)	O
)	O
;	O
if	O
(	O
diff_input	int
)	O
{	O
if	O
(	O
optind	int
+	O
1	int
<	O
argc	int
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"too many file arguments"	pointer
)	O
)	O
;	O
usage	function
(	O
EXIT_ERROR	int
)	O
;	O
}	O
if	O
(	O
optind	int
==	O
argc	int
||	O
strcmp	function
(	O
argv	array
[	O
optind	int
]	O
,	O
""	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	array
[	O
optind	int
]	O
,	O
"-"	pointer
)	O
==	O
0	int
)	O
split_diff	function
(	O
NULL	O
)	O
;	O
else	O
split_diff	function
(	O
argv	array
[	O
optind	int
]	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
optind	int
+	O
2	int
>	O
argc	int
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"missing file arguments"	pointer
)	O
)	O
;	O
usage	function
(	O
EXIT_ERROR	int
)	O
;	O
}	O
if	O
(	O
optind	int
+	O
2	int
<	O
argc	int
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"too many file arguments"	pointer
)	O
)	O
;	O
usage	function
(	O
EXIT_ERROR	int
)	O
;	O
}	O
if	O
(	O
strcmp	function
(	O
argv	array
[	O
optind	int
]	O
,	O
""	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	array
[	O
optind	int
]	O
,	O
"-"	pointer
)	O
==	O
0	int
)	O
left_side	pointer
->	O
filename	pointer
=	O
NULL	O
;	O
else	O
left_side	pointer
->	O
filename	pointer
=	O
argv	array
[	O
optind	int
]	O
;	O
optind	int
++	O
;	O
left_side	pointer
->	O
temp_name	pointer
=	O
NULL	O
;	O
if	O
(	O
strcmp	function
(	O
argv	array
[	O
optind	int
]	O
,	O
""	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
argv	array
[	O
optind	int
]	O
,	O
"-"	pointer
)	O
==	O
0	int
)	O
right_side	pointer
->	O
filename	pointer
=	O
NULL	O
;	O
else	O
right_side	pointer
->	O
filename	pointer
=	O
argv	array
[	O
optind	int
]	O
;	O
optind	int
++	O
;	O
right_side	pointer
->	O
temp_name	pointer
=	O
NULL	O
;	O
if	O
(	O
left_side	pointer
->	O
filename	pointer
==	O
NULL	O
&&	O
right_side	pointer
->	O
filename	pointer
==	O
NULL	O
)	O
error	function
(	O
EXIT_ERROR	int
,	O
0	int
,	O
_	O
(	O
"only one file may be standard input"	pointer
)	O
)	O
;	O
}	O
setup_signals	function
(	O
)	O
;	O
input_file	pointer
=	O
NULL	O
;	O
output_file	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
setjmp	function
(	O
signal_label	array
)	O
)	O
{	O
split_file_into_words	function
(	O
left_side	pointer
)	O
;	O
count_total_left	int
=	O
left_side	pointer
->	O
position	int
;	O
split_file_into_words	function
(	O
right_side	pointer
)	O
;	O
count_total_right	int
=	O
right_side	pointer
->	O
position	int
;	O
launch_input_program	function
(	O
)	O
;	O
launch_output_program	function
(	O
)	O
;	O
initialize_strings	function
(	O
)	O
;	O
reformat_diff_output	function
(	O
)	O
;	O
}	O
if	O
(	O
input_file	pointer
)	O
complete_input_program	function
(	O
)	O
;	O
if	O
(	O
left_side	pointer
->	O
temp_name	pointer
)	O
unlink	function
(	O
left_side	pointer
->	O
temp_name	pointer
)	O
;	O
if	O
(	O
right_side	pointer
->	O
temp_name	pointer
)	O
unlink	function
(	O
right_side	pointer
->	O
temp_name	pointer
)	O
;	O
if	O
(	O
output_file	pointer
)	O
complete_output_program	function
(	O
)	O
;	O
if	O
(	O
interrupted	int
)	O
exit	function
(	O
EXIT_ERROR	int
)	O
;	O
if	O
(	O
show_statistics	int
)	O
print_statistics	function
(	O
)	O
;	O
if	O
(	O
count_isolated_left	int
||	O
count_isolated_right	int
||	O
count_changed_left	int
||	O
count_changed_right	int
)	O
exit	function
(	O
EXIT_DIFFERENCE	int
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
