static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: db_meta.c,v 1.4 2000/06/28 16:47:01 loic Exp $"	pointer
;	O
int	O
CDB___db_new	function
(	O
dbc	pointer
,	O
type	enum
,	O
pagepp	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
u_int32_t	int
type	enum
;	O
PAGE	struct
*	O
*	O
pagepp	pointer
;	O
{	O
DBMETA	struct
*	O
meta	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
DB_LOCK	struct
metalock	struct
;	O
PAGE	struct
*	O
h	pointer
;	O
db_pgno_t	int
pgno	int
;	O
int	O
ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
meta	pointer
=	O
NULL	O
;	O
h	pointer
=	O
NULL	O
;	O
pgno	int
=	O
PGNO_BASE_MD	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_lget	function
(	O
dbc	pointer
,	O
LCK_ALWAYS	int
,	O
pgno	int
,	O
DB_LOCK_WRITE	int
,	O
0	int
,	O
&	O
metalock	struct
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pgno	int
,	O
0	int
,	O
(	O
PAGE	struct
*	O
*	O
)	O
&	O
meta	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
meta	pointer
->	O
free	int
==	O
PGNO_INVALID	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pgno	int
,	O
DB_MPOOL_NEW	int
,	O
&	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
ZERO_LSN	O
(	O
h	pointer
->	O
lsn	struct
)	O
;	O
h	pointer
->	O
pgno	int
=	O
pgno	int
;	O
}	O
else	O
{	O
pgno	int
=	O
meta	pointer
->	O
free	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pgno	int
,	O
0	int
,	O
&	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
meta	pointer
->	O
free	int
=	O
h	pointer
->	O
next_pgno	int
;	O
(	O
void	O
)	O
CDB_memp_fset	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
(	O
PAGE	struct
*	O
)	O
meta	pointer
,	O
DB_MPOOL_DIRTY	int
)	O
;	O
}	O
if	O
(	O
DB_LOGGING	O
(	O
dbc	pointer
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
__db_pg_alloc_log	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbc	pointer
->	O
txn	pointer
,	O
&	O
LSN	O
(	O
meta	pointer
)	O
,	O
0	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
&	O
LSN	O
(	O
meta	pointer
)	O
,	O
&	O
meta	pointer
->	O
alloc_lsn	struct
,	O
&	O
h	pointer
->	O
lsn	struct
,	O
h	pointer
->	O
pgno	int
,	O
(	O
u_int32_t	int
)	O
type	enum
,	O
meta	pointer
->	O
free	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
LSN	O
(	O
h	pointer
)	O
=	O
LSN	O
(	O
meta	pointer
)	O
;	O
meta	pointer
->	O
alloc_lsn	struct
=	O
LSN	O
(	O
meta	pointer
)	O
;	O
}	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
(	O
PAGE	struct
*	O
)	O
meta	pointer
,	O
DB_MPOOL_DIRTY	int
)	O
;	O
(	O
void	O
)	O
__TLPUT	O
(	O
dbc	pointer
,	O
metalock	struct
)	O
;	O
P_INIT	O
(	O
h	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
h	pointer
->	O
pgno	int
,	O
PGNO_INVALID	int
,	O
PGNO_INVALID	int
,	O
0	int
,	O
type	enum
,	O
0	int
)	O
;	O
*	O
pagepp	pointer
=	O
h	pointer
;	O
return	O
(	O
0	int
)	O
;	O
err	pointer
:	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
;	O
if	O
(	O
meta	pointer
!=	O
NULL	O
)	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
meta	pointer
,	O
0	int
)	O
;	O
(	O
void	O
)	O
__TLPUT	O
(	O
dbc	pointer
,	O
metalock	struct
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___db_free	function
(	O
dbc	pointer
,	O
h	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
PAGE	struct
*	O
h	pointer
;	O
{	O
DBMETA	struct
*	O
meta	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
DBT	struct
ldbt	struct
;	O
DB_LOCK	struct
metalock	struct
;	O
db_pgno_t	int
pgno	int
;	O
u_int32_t	int
dirty_flag	int
;	O
int	O
ret	int
,	O
t_ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
dirty_flag	int
=	O
0	int
;	O
pgno	int
=	O
PGNO_BASE_MD	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_lget	function
(	O
dbc	pointer
,	O
LCK_ALWAYS	int
,	O
pgno	int
,	O
DB_LOCK_WRITE	int
,	O
0	int
,	O
&	O
metalock	struct
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pgno	int
,	O
0	int
,	O
(	O
PAGE	struct
*	O
*	O
)	O
&	O
meta	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
(	O
void	O
)	O
__TLPUT	O
(	O
dbc	pointer
,	O
metalock	struct
)	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
DB_LOGGING	O
(	O
dbc	pointer
)	O
)	O
{	O
memset	function
(	O
&	O
ldbt	struct
,	O
0	int
,	O
sizeof	O
(	O
ldbt	struct
)	O
)	O
;	O
ldbt	struct
.	O
data	pointer
=	O
h	pointer
;	O
ldbt	struct
.	O
size	int
=	O
P_OVERHEAD	O
;	O
if	O
(	O
(	O
ret	int
=	O
__db_pg_free_log	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbc	pointer
->	O
txn	pointer
,	O
&	O
LSN	O
(	O
meta	pointer
)	O
,	O
0	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
h	pointer
->	O
pgno	int
,	O
&	O
LSN	O
(	O
meta	pointer
)	O
,	O
&	O
meta	pointer
->	O
alloc_lsn	struct
,	O
&	O
ldbt	struct
,	O
meta	pointer
->	O
free	int
)	O
)	O
!=	O
0	int
)	O
{	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
(	O
PAGE	struct
*	O
)	O
meta	pointer
,	O
0	int
)	O
;	O
(	O
void	O
)	O
__TLPUT	O
(	O
dbc	pointer
,	O
metalock	struct
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
LSN	O
(	O
h	pointer
)	O
=	O
LSN	O
(	O
meta	pointer
)	O
;	O
meta	pointer
->	O
alloc_lsn	struct
=	O
LSN	O
(	O
meta	pointer
)	O
;	O
}	O
P_INIT	O
(	O
h	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
h	pointer
->	O
pgno	int
,	O
PGNO_INVALID	int
,	O
meta	pointer
->	O
free	int
,	O
0	int
,	O
P_INVALID	int
,	O
0	int
)	O
;	O
meta	pointer
->	O
free	int
=	O
h	pointer
->	O
pgno	int
;	O
ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
(	O
PAGE	struct
*	O
)	O
meta	pointer
,	O
DB_MPOOL_DIRTY	int
)	O
;	O
if	O
(	O
(	O
t_ret	int
=	O
__TLPUT	O
(	O
dbc	pointer
,	O
metalock	struct
)	O
)	O
!=	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
dirty_flag	int
=	O
DB_MPOOL_DIRTY	int
;	O
err	pointer
:	O
if	O
(	O
(	O
t_ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
dirty_flag	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___db_lget	function
(	O
dbc	pointer
,	O
flags	int
,	O
pgno	int
,	O
mode	enum
,	O
lkflags	int
,	O
lockp	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
int	O
flags	int
,	O
lkflags	int
;	O
db_pgno_t	int
pgno	int
;	O
db_lockmode_t	enum
mode	enum
;	O
DB_LOCK	struct
*	O
lockp	pointer
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_LOCKREQ	struct
couple	array
[	O
2	int
]	O
;	O
int	O
ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
dbenv	pointer
=	O
dbp	pointer
->	O
dbenv	pointer
;	O
if	O
(	O
LOCKING	O
(	O
dbenv	pointer
)	O
||	O
!	O
LOCKING_ON	O
(	O
dbenv	pointer
)	O
||	O
(	O
!	O
LF_ISSET	O
(	O
LCK_ROLLBACK	int
)	O
&&	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_RECOVER	int
)	O
)	O
||	O
(	O
!	O
LF_ISSET	O
(	O
LCK_ALWAYS	int
)	O
&&	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_OPD	int
)	O
)	O
)	O
{	O
lockp	pointer
->	O
off	long
=	O
LOCK_INVALID	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
dbc	pointer
->	O
lock	struct
.	O
pgno	int
=	O
pgno	int
;	O
if	O
(	O
lkflags	int
&	O
DB_LOCK_RECORD	int
)	O
dbc	pointer
->	O
lock	struct
.	O
type	enum
=	O
DB_RECORD_LOCK	int
;	O
else	O
dbc	pointer
->	O
lock	struct
.	O
type	enum
=	O
DB_PAGE_LOCK	int
;	O
lkflags	int
&=	O
~	O
DB_LOCK_RECORD	int
;	O
if	O
(	O
DB_NONBLOCK	O
(	O
dbc	pointer
)	O
)	O
lkflags	int
|=	O
DB_LOCK_NOWAIT	int
;	O
if	O
(	O
LF_ISSET	O
(	O
LCK_COUPLE	int
)	O
)	O
{	O
couple	array
[	O
0	int
]	O
.	O
op	enum
=	O
DB_LOCK_GET	int
;	O
couple	array
[	O
0	int
]	O
.	O
obj	pointer
=	O
&	O
dbc	pointer
->	O
lock_dbt	struct
;	O
couple	array
[	O
0	int
]	O
.	O
mode	enum
=	O
mode	enum
;	O
couple	array
[	O
1	int
]	O
.	O
op	enum
=	O
DB_LOCK_PUT	int
;	O
couple	array
[	O
1	int
]	O
.	O
lock	struct
=	O
*	O
lockp	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_lock_vec	function
(	O
dbenv	pointer
,	O
dbc	pointer
->	O
locker	int
,	O
lkflags	int
,	O
couple	array
,	O
2	int
,	O
NULL	O
)	O
)	O
==	O
0	int
)	O
*	O
lockp	pointer
=	O
couple	array
[	O
0	int
]	O
.	O
lock	struct
;	O
}	O
else	O
ret	int
=	O
CDB_lock_get	function
(	O
dbenv	pointer
,	O
dbc	pointer
->	O
locker	int
,	O
lkflags	int
,	O
&	O
dbc	pointer
->	O
lock_dbt	struct
,	O
mode	enum
,	O
lockp	pointer
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
lockp	pointer
->	O
off	long
=	O
LOCK_INVALID	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
