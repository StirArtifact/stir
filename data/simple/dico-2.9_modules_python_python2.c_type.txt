static	O
char	O
*	O
init_script	pointer
;	O
static	O
char	O
*	O
load_path	pointer
;	O
static	O
char	O
*	O
root_class	pointer
=	O
"DicoModule"	pointer
;	O
static	O
struct	O
dico_option	O
init_option	int
[	O
]	O
=	O
{	O
{	O
DICO_OPTSTR	function
(	O
init	O
-	O
script	O
)	O
,	O
dico_opt_string	O
,	O
&	O
init_script	pointer
}	O
,	O
{	O
DICO_OPTSTR	function
(	O
load	O
-	O
path	O
)	O
,	O
dico_opt_string	O
,	O
&	O
load_path	pointer
}	O
,	O
{	O
DICO_OPTSTR	function
(	O
root	O
-	O
class	O
)	O
,	O
dico_opt_string	O
,	O
&	O
root_class	pointer
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
struct	O
_python_database	struct
{	O
const	O
char	O
*	O
dbname	pointer
;	O
int	O
argc	int
;	O
char	O
*	O
*	O
argv	pointer
;	O
PyThreadState	O
*	O
py_ths	pointer
;	O
PyObject	O
*	O
py_instance	pointer
;	O
}	O
;	O
typedef	O
struct	O
{	O
PyObject_HEAD	int
;	O
struct	O
dico_key	O
*	O
key	pointer
;	O
}	O
PySelectionKey	struct
;	O
static	O
void	O
_PySelectionKey_dealloc	function
(	O
PyObject	O
*	O
self	pointer
)	O
{	O
}	O
static	O
PyMethodDef	O
selection_key_methods	array
[	O
]	O
=	O
{	O
{	O
NULL	O
,	O
NULL	O
,	O
0	int
,	O
NULL	O
}	O
}	O
;	O
static	O
PyObject	O
*	O
_PySelectionKey_getattr	function
(	O
PyObject	O
*	O
self	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
PySelectionKey	struct
*	O
py_key	pointer
=	O
(	O
PySelectionKey	struct
*	O
)	O
self	pointer
;	O
if	O
(	O
strcmp	O
(	O
name	pointer
,	O
"word"	pointer
)	O
==	O
0	int
)	O
return	O
PyString_FromString	function
(	O
py_key	pointer
->	O
key	pointer
->	O
word	pointer
)	O
;	O
return	O
Py_FindMethod	function
(	O
selection_key_methods	array
,	O
self	pointer
,	O
name	pointer
)	O
;	O
}	O
static	O
PyObject	O
*	O
_PySelectionKey_repr	function
(	O
PyObject	O
*	O
self	pointer
)	O
{	O
PySelectionKey	struct
*	O
py_key	pointer
=	O
(	O
PySelectionKey	struct
*	O
)	O
self	pointer
;	O
char	O
buf	array
[	O
80	int
]	O
;	O
snprintf	O
(	O
buf	array
,	O
sizeof	O
buf	array
,	O
"<DicoSelectionKey %s>"	pointer
,	O
py_key	pointer
->	O
key	pointer
->	O
word	pointer
)	O
;	O
return	O
PyString_FromString	function
(	O
buf	array
)	O
;	O
}	O
static	O
PyObject	O
*	O
_PySelectionKey_str	function
(	O
PyObject	O
*	O
self	pointer
)	O
{	O
PySelectionKey	struct
*	O
py_key	pointer
=	O
(	O
PySelectionKey	struct
*	O
)	O
self	pointer
;	O
return	O
PyString_FromString	function
(	O
py_key	pointer
->	O
key	pointer
->	O
word	pointer
)	O
;	O
}	O
static	O
PyTypeObject	O
PySelectionKeyType	int
=	O
{	O
PyObject_HEAD_INIT	function
(	O
&	O
PyType_Type	O
)	O
0	int
,	O
"DicoSelectionKey"	pointer
,	O
sizeof	O
(	O
PySelectionKey	struct
)	O
,	O
0	int
,	O
_PySelectionKey_dealloc	function
,	O
NULL	O
,	O
_PySelectionKey_getattr	function
,	O
NULL	O
,	O
NULL	O
,	O
_PySelectionKey_repr	function
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
_PySelectionKey_str	function
,	O
}	O
;	O
typedef	O
struct	O
{	O
PyObject_HEAD	int
;	O
dico_strategy_t	O
strat	int
;	O
}	O
PyStrategy	struct
;	O
static	O
inline	O
PyObject	O
*	O
_ro	function
(	O
PyObject	O
*	O
obj	pointer
)	O
{	O
Py_INCREF	function
(	O
obj	pointer
)	O
;	O
return	O
obj	pointer
;	O
}	O
static	O
PyObject	O
*	O
strat_select_method	function
(	O
PyObject	O
*	O
self	pointer
,	O
PyObject	O
*	O
args	pointer
)	O
{	O
PyStrategy	struct
*	O
py_strat	pointer
=	O
(	O
PyStrategy	struct
*	O
)	O
self	pointer
;	O
PySelectionKey	struct
*	O
py_key	pointer
;	O
char	O
*	O
word	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
PyArg_ParseTuple	function
(	O
args	pointer
,	O
"sO!"	pointer
,	O
&	O
word	pointer
,	O
&	O
PySelectionKeyType	int
,	O
&	O
py_key	pointer
)	O
)	O
return	O
_ro	function
(	O
Py_False	O
)	O
;	O
return	O
_ro	function
(	O
py_strat	pointer
->	O
strat	int
->	O
sel	O
(	O
DICO_SELECT_RUN	O
,	O
py_key	pointer
->	O
key	pointer
,	O
word	pointer
)	O
?	O
Py_True	O
:	O
Py_False	O
)	O
;	O
}	O
static	O
PyMethodDef	O
strategy_methods	array
[	O
]	O
=	O
{	O
{	O
"select"	pointer
,	O
strat_select_method	function
,	O
METH_VARARGS	O
,	O
"Return True if KEY matches WORD as per this strategy."	pointer
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
0	int
,	O
NULL	O
}	O
}	O
;	O
static	O
void	O
_PyStrategy_dealloc	function
(	O
PyObject	O
*	O
self	pointer
)	O
{	O
}	O
static	O
PyObject	O
*	O
_PyStrategy_getattr	function
(	O
PyObject	O
*	O
self	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
PyStrategy	struct
*	O
py_strat	pointer
=	O
(	O
PyStrategy	struct
*	O
)	O
self	pointer
;	O
dico_strategy_t	O
strat	int
=	O
py_strat	pointer
->	O
strat	int
;	O
if	O
(	O
strcmp	O
(	O
name	pointer
,	O
"name"	pointer
)	O
==	O
0	int
)	O
{	O
return	O
PyString_FromString	function
(	O
strat	int
->	O
name	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	O
(	O
name	pointer
,	O
"descr"	pointer
)	O
==	O
0	int
)	O
{	O
return	O
PyString_FromString	function
(	O
strat	int
->	O
descr	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	O
(	O
name	pointer
,	O
"has_selector"	pointer
)	O
==	O
0	int
)	O
{	O
return	O
_ro	function
(	O
strat	int
->	O
sel	O
?	O
Py_True	O
:	O
Py_False	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	O
(	O
name	pointer
,	O
"is_default"	pointer
)	O
==	O
0	int
)	O
{	O
return	O
_ro	function
(	O
dico_strategy_is_default_p	function
(	O
strat	int
)	O
?	O
Py_True	O
:	O
Py_False	O
)	O
;	O
}	O
return	O
Py_FindMethod	function
(	O
strategy_methods	array
,	O
self	pointer
,	O
name	pointer
)	O
;	O
}	O
static	O
PyObject	O
*	O
_PyStrategy_repr	function
(	O
PyObject	O
*	O
self	pointer
)	O
{	O
PyStrategy	struct
*	O
py_strat	pointer
=	O
(	O
PyStrategy	struct
*	O
)	O
self	pointer
;	O
char	O
buf	array
[	O
80	int
]	O
;	O
snprintf	O
(	O
buf	array
,	O
sizeof	O
buf	array
,	O
"<DicoStrategy %s>"	pointer
,	O
py_strat	pointer
->	O
strat	int
->	O
name	pointer
)	O
;	O
return	O
PyString_FromString	function
(	O
buf	array
)	O
;	O
}	O
static	O
PyObject	O
*	O
_PyStrategy_str	function
(	O
PyObject	O
*	O
self	pointer
)	O
{	O
PyStrategy	struct
*	O
py_strat	pointer
=	O
(	O
PyStrategy	struct
*	O
)	O
self	pointer
;	O
return	O
PyString_FromString	function
(	O
py_strat	pointer
->	O
strat	int
->	O
name	pointer
)	O
;	O
}	O
static	O
PyTypeObject	O
PyStrategyType	int
=	O
{	O
PyObject_HEAD_INIT	function
(	O
&	O
PyType_Type	O
)	O
0	int
,	O
"DicoStrategy"	pointer
,	O
sizeof	O
(	O
PyStrategy	struct
)	O
,	O
0	int
,	O
_PyStrategy_dealloc	function
,	O
NULL	O
,	O
_PyStrategy_getattr	function
,	O
NULL	O
,	O
NULL	O
,	O
_PyStrategy_repr	function
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
_PyStrategy_str	function
,	O
}	O
;	O
static	O
dico_stream_t	O
dico_stream_output	int
;	O
static	O
dico_stream_t	O
dico_stream_log_err	int
;	O
static	O
dico_stream_t	O
dico_stream_log_info	int
;	O
static	O
PyObject	O
*	O
_capture_stdout_result	function
(	O
PyObject	O
*	O
self	pointer
,	O
PyObject	O
*	O
args	pointer
)	O
{	O
char	O
*	O
buf	array
=	O
""	pointer
;	O
if	O
(	O
!	O
PyArg_ParseTuple	function
(	O
args	pointer
,	O
"s"	pointer
,	O
&	O
buf	array
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
dico_stream_output	int
)	O
dico_stream_write	function
(	O
dico_stream_output	int
,	O
buf	array
,	O
strlen	O
(	O
buf	array
)	O
)	O
;	O
return	O
_ro	function
(	O
Py_None	O
)	O
;	O
}	O
static	O
PyObject	O
*	O
_capture_stdout_info	function
(	O
PyObject	O
*	O
self	pointer
,	O
PyObject	O
*	O
args	pointer
)	O
{	O
char	O
*	O
buf	array
=	O
""	pointer
;	O
if	O
(	O
!	O
PyArg_ParseTuple	function
(	O
args	pointer
,	O
"s"	pointer
,	O
&	O
buf	array
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
dico_stream_log_info	int
)	O
dico_stream_write	function
(	O
dico_stream_log_info	int
,	O
buf	array
,	O
strlen	O
(	O
buf	array
)	O
)	O
;	O
return	O
_ro	function
(	O
Py_None	O
)	O
;	O
}	O
static	O
PyObject	O
*	O
_capture_stderr	function
(	O
PyObject	O
*	O
self	pointer
,	O
PyObject	O
*	O
args	pointer
)	O
{	O
char	O
*	O
buf	array
=	O
""	pointer
;	O
if	O
(	O
!	O
PyArg_ParseTuple	function
(	O
args	pointer
,	O
"s"	pointer
,	O
&	O
buf	array
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
dico_stream_log_err	int
)	O
dico_stream_write	function
(	O
dico_stream_log_err	int
,	O
buf	array
,	O
strlen	O
(	O
buf	array
)	O
)	O
;	O
return	O
_ro	function
(	O
Py_None	O
)	O
;	O
}	O
static	O
PyMethodDef	O
capture_stdout_result_method	array
[	O
]	O
=	O
{	O
{	O
"write"	pointer
,	O
_capture_stdout_result	function
,	O
1	int
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
0	int
,	O
NULL	O
}	O
}	O
;	O
static	O
PyMethodDef	O
capture_stdout_info_method	array
[	O
]	O
=	O
{	O
{	O
"write"	pointer
,	O
_capture_stdout_info	function
,	O
1	int
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
0	int
,	O
NULL	O
}	O
}	O
;	O
static	O
PyMethodDef	O
capture_stderr_method	array
[	O
]	O
=	O
{	O
{	O
"write"	pointer
,	O
_capture_stderr	function
,	O
1	int
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
0	int
,	O
NULL	O
}	O
}	O
;	O
static	O
int	O
_python_selector	function
(	O
int	O
cmd	int
,	O
struct	O
dico_key	O
*	O
key	pointer
,	O
const	O
char	O
*	O
dict_word	pointer
)	O
{	O
PyObject	O
*	O
py_args	pointer
,	O
*	O
py_res	O
;	O
PySelectionKey	struct
*	O
py_key	pointer
;	O
void	O
*	O
closure	pointer
=	O
key	pointer
->	O
strat	int
->	O
closure	pointer
;	O
py_args	pointer
=	O
PyTuple_New	function
(	O
3	int
)	O
;	O
PyTuple_SetItem	function
(	O
py_args	pointer
,	O
0	int
,	O
PyInt_FromLong	function
(	O
cmd	int
)	O
)	O
;	O
py_key	pointer
=	O
PyObject_NEW	function
(	O
PySelectionKey	struct
,	O
&	O
PySelectionKeyType	int
)	O
;	O
py_key	pointer
->	O
key	pointer
=	O
key	pointer
;	O
PyTuple_SetItem	function
(	O
py_args	pointer
,	O
1	int
,	O
(	O
PyObject	O
*	O
)	O
py_key	pointer
)	O
;	O
PyTuple_SetItem	function
(	O
py_args	pointer
,	O
2	int
,	O
PyString_FromString	function
(	O
dict_word	pointer
)	O
)	O
;	O
if	O
(	O
closure	pointer
&&	O
PyCallable_Check	function
(	O
closure	pointer
)	O
)	O
{	O
py_res	O
=	O
PyObject_CallObject	function
(	O
closure	pointer
,	O
py_args	pointer
)	O
;	O
if	O
(	O
py_res	O
)	O
{	O
if	O
(	O
PyBool_Check	function
(	O
py_res	O
)	O
)	O
return	O
py_res	O
==	O
Py_True	O
?	O
1	int
:	O
0	int
;	O
}	O
else	O
if	O
(	O
PyErr_Occurred	function
(	O
)	O
)	O
PyErr_Print	function
(	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
PyObject	O
*	O
dico_register_strat	function
(	O
PyObject	O
*	O
self	pointer
,	O
PyObject	O
*	O
args	pointer
)	O
{	O
struct	O
dico_strategy	O
strat	int
;	O
char	O
*	O
name	pointer
=	O
NULL	O
;	O
char	O
*	O
descr	pointer
=	O
NULL	O
;	O
char	O
*	O
fnc	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
PyArg_ParseTuple	function
(	O
args	pointer
,	O
"ss|s"	pointer
,	O
&	O
name	pointer
,	O
&	O
descr	pointer
,	O
&	O
fnc	pointer
)	O
)	O
return	O
NULL	O
;	O
strat	int
.	O
name	pointer
=	O
name	pointer
;	O
strat	int
.	O
descr	pointer
=	O
descr	pointer
;	O
if	O
(	O
!	O
fnc	pointer
)	O
{	O
strat	int
.	O
sel	O
=	O
NULL	O
;	O
strat	int
.	O
closure	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
strat	int
.	O
sel	O
=	O
_python_selector	function
;	O
strat	int
.	O
closure	pointer
=	O
fnc	pointer
;	O
}	O
dico_strategy_add	function
(	O
&	O
strat	int
)	O
;	O
return	O
_ro	function
(	O
Py_None	O
)	O
;	O
}	O
static	O
PyObject	O
*	O
dico_register_markup	function
(	O
PyObject	O
*	O
self	pointer
,	O
PyObject	O
*	O
py_obj	pointer
)	O
{	O
int	O
rc	int
;	O
char	O
*	O
type	pointer
;	O
if	O
(	O
!	O
PyString_Check	function
(	O
py_obj	pointer
)	O
)	O
{	O
PyErr_SetString	function
(	O
PyExc_TypeError	O
,	O
_	function
(	O
"This parameter must be a string"	pointer
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
type	pointer
=	O
strdup	O
(	O
PyString_AsString	function
(	O
py_obj	pointer
)	O
)	O
;	O
rc	int
=	O
dico_markup_register	function
(	O
type	pointer
)	O
;	O
free	function
(	O
type	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
NULL	O
;	O
return	O
_ro	function
(	O
Py_None	O
)	O
;	O
}	O
static	O
PyObject	O
*	O
dico_current_markup	function
(	O
PyObject	O
*	O
self	pointer
)	O
{	O
return	O
_ro	function
(	O
PyString_FromString	function
(	O
dico_markup_type	O
)	O
)	O
;	O
}	O
static	O
PyMethodDef	O
dico_methods	array
[	O
]	O
=	O
{	O
{	O
"register_strat"	pointer
,	O
dico_register_strat	function
,	O
METH_VARARGS	O
,	O
"Register a new strategy."	pointer
}	O
,	O
{	O
"register_markup"	pointer
,	O
dico_register_markup	function
,	O
METH_O	O
,	O
"Register a new markup type."	pointer
}	O
,	O
{	O
"current_markup"	pointer
,	O
(	O
PyCFunction	O
)	O
dico_current_markup	function
,	O
METH_NOARGS	O
,	O
"Return current dico markup type."	pointer
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
0	int
,	O
NULL	O
}	O
}	O
;	O
static	O
PyObject	O
*	O
_argv_to_tuple	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
i	int
;	O
PyObject	O
*	O
py_args	pointer
=	O
PyTuple_New	function
(	O
argc	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
argc	int
;	O
argc	int
--	O
,	O
argv	pointer
++	O
,	O
i	int
++	O
)	O
{	O
PyTuple_SetItem	function
(	O
py_args	pointer
,	O
i	int
,	O
PyString_FromString	function
(	O
*	O
argv	pointer
)	O
)	O
;	O
}	O
return	O
py_args	pointer
;	O
}	O
static	O
int	O
mod_init	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
if	O
(	O
dico_parseopt	function
(	O
init_option	int
,	O
argc	int
,	O
argv	pointer
,	O
0	int
,	O
NULL	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
!	O
Py_IsInitialized	function
(	O
)	O
)	O
Py_Initialize	function
(	O
)	O
;	O
dico_stream_log_err	int
=	O
dico_log_stream_create	function
(	O
L_ERR	O
)	O
;	O
dico_stream_log_info	int
=	O
dico_log_stream_create	function
(	O
L_INFO	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
insert_load_path	function
(	O
const	O
char	O
*	O
dir	pointer
)	O
{	O
PyObject	O
*	O
py_sys	O
,	O
*	O
py_path	O
,	O
*	O
py_dirstr	O
;	O
const	O
char	O
*	O
p	pointer
;	O
py_sys	O
=	O
PyImport_ImportModule	function
(	O
"sys"	pointer
)	O
;	O
py_path	O
=	O
PyObject_GetAttrString	function
(	O
py_sys	O
,	O
"path"	pointer
)	O
;	O
p	pointer
=	O
dir	pointer
+	O
strlen	O
(	O
dir	pointer
)	O
;	O
do	O
{	O
size_t	O
len	O
;	O
for	O
(	O
len	O
=	O
0	int
;	O
p	pointer
>	O
dir	pointer
&&	O
p	pointer
[	O
-	O
1	int
]	O
!=	O
':'	O
;	O
p	pointer
--	O
,	O
len	O
++	O
)	O
;	O
py_dirstr	O
=	O
PyString_FromStringAndSize	function
(	O
p	pointer
,	O
len	O
)	O
;	O
if	O
(	O
PySequence_Index	function
(	O
py_path	O
,	O
py_dirstr	O
)	O
==	O
-	O
1	int
)	O
{	O
PyObject	O
*	O
py_list	O
;	O
PyErr_Clear	function
(	O
)	O
;	O
py_list	O
=	O
Py_BuildValue	function
(	O
"[O]"	pointer
,	O
py_dirstr	O
)	O
;	O
PyList_SetSlice	function
(	O
py_path	O
,	O
0	int
,	O
0	int
,	O
py_list	O
)	O
;	O
Py_DECREF	function
(	O
py_list	O
)	O
;	O
}	O
Py_DECREF	function
(	O
py_dirstr	O
)	O
;	O
}	O
while	O
(	O
p	pointer
--	O
>	O
dir	pointer
)	O
;	O
Py_DECREF	function
(	O
py_path	O
)	O
;	O
Py_DECREF	function
(	O
py_sys	O
)	O
;	O
}	O
static	O
struct	O
{	O
char	O
*	O
name	pointer
;	O
int	O
value	int
;	O
}	O
constab	array
[	O
]	O
=	O
{	O
{	O
"DICO_SELECT_BEGIN"	pointer
,	O
DICO_SELECT_BEGIN	O
}	O
,	O
{	O
"DICO_SELECT_RUN"	pointer
,	O
DICO_SELECT_RUN	O
}	O
,	O
{	O
"DICO_SELECT_END"	pointer
,	O
DICO_SELECT_END	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
void	O
declare_constants	function
(	O
PyObject	O
*	O
module	pointer
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
constab	array
[	O
i	int
]	O
.	O
name	pointer
;	O
i	int
++	O
)	O
PyModule_AddIntConstant	function
(	O
module	pointer
,	O
constab	array
[	O
i	int
]	O
.	O
name	pointer
,	O
constab	array
[	O
i	int
]	O
.	O
value	int
)	O
;	O
}	O
static	O
dico_handle_t	O
mod_init_db	function
(	O
const	O
char	O
*	O
dbname	pointer
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
pindex	int
;	O
struct	O
_python_database	struct
*	O
db	pointer
;	O
PyObject	O
*	O
py_err	O
,	O
*	O
py_out	O
,	O
*	O
py_name	O
,	O
*	O
py_module	O
,	O
*	O
py_class	O
;	O
PyThreadState	O
*	O
py_ths	pointer
;	O
if	O
(	O
dico_parseopt	function
(	O
init_option	int
,	O
argc	int
,	O
argv	pointer
,	O
DICO_PARSEOPT_PERMUTE	O
,	O
&	O
pindex	int
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
!	O
init_script	pointer
)	O
return	O
NULL	O
;	O
argv	pointer
+=	O
pindex	int
;	O
argc	int
-=	O
pindex	int
;	O
db	pointer
=	O
malloc	O
(	O
sizeof	O
(	O
*	O
db	pointer
)	O
)	O
;	O
if	O
(	O
!	O
db	pointer
)	O
{	O
DICO_LOG_ERRNO	function
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
db	pointer
->	O
dbname	pointer
=	O
dbname	pointer
;	O
db	pointer
->	O
argc	int
=	O
argc	int
;	O
db	pointer
->	O
argv	pointer
=	O
argv	pointer
;	O
py_ths	pointer
=	O
Py_NewInterpreter	function
(	O
)	O
;	O
if	O
(	O
!	O
py_ths	pointer
)	O
{	O
dico_log	function
(	O
L_ERR	O
,	O
0	int
,	O
_	function
(	O
"mod_init_db: cannot create new interpreter: %s"	pointer
)	O
,	O
init_script	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
PyThreadState_Swap	function
(	O
py_ths	pointer
)	O
;	O
db	pointer
->	O
py_ths	pointer
=	O
py_ths	pointer
;	O
declare_constants	function
(	O
Py_InitModule	function
(	O
"dico"	pointer
,	O
dico_methods	array
)	O
)	O
;	O
PyRun_SimpleString	function
(	O
"import sys"	pointer
)	O
;	O
if	O
(	O
load_path	pointer
)	O
insert_load_path	function
(	O
load_path	pointer
)	O
;	O
insert_load_path	function
(	O
""	pointer
)	O
;	O
py_err	O
=	O
Py_InitModule	function
(	O
"stderr"	pointer
,	O
capture_stderr_method	array
)	O
;	O
if	O
(	O
py_err	O
)	O
PySys_SetObject	function
(	O
"stderr"	pointer
,	O
py_err	O
)	O
;	O
py_out	O
=	O
Py_InitModule	function
(	O
"stdout"	pointer
,	O
capture_stdout_info_method	array
)	O
;	O
if	O
(	O
py_out	O
)	O
PySys_SetObject	function
(	O
"stdout"	pointer
,	O
py_out	O
)	O
;	O
py_name	O
=	O
PyString_FromString	function
(	O
init_script	pointer
)	O
;	O
py_module	O
=	O
PyImport_Import	function
(	O
py_name	O
)	O
;	O
Py_DECREF	function
(	O
py_name	O
)	O
;	O
if	O
(	O
!	O
py_module	O
)	O
{	O
dico_log	function
(	O
L_ERR	O
,	O
0	int
,	O
_	function
(	O
"mod_init_db: cannot load init script: %s"	pointer
)	O
,	O
init_script	pointer
)	O
;	O
if	O
(	O
PyErr_Occurred	function
(	O
)	O
)	O
PyErr_Print	function
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
py_class	O
=	O
PyObject_GetAttrString	function
(	O
py_module	O
,	O
root_class	pointer
)	O
;	O
if	O
(	O
py_class	O
&&	O
PyClass_Check	function
(	O
py_class	O
)	O
)	O
{	O
PyObject	O
*	O
py_instance	pointer
=	O
PyInstance_New	function
(	O
py_class	O
,	O
_argv_to_tuple	function
(	O
argc	int
,	O
argv	pointer
)	O
,	O
NULL	O
)	O
;	O
if	O
(	O
py_instance	pointer
&&	O
PyInstance_Check	function
(	O
py_instance	pointer
)	O
)	O
db	pointer
->	O
py_instance	pointer
=	O
py_instance	pointer
;	O
else	O
if	O
(	O
PyErr_Occurred	function
(	O
)	O
)	O
{	O
PyErr_Print	function
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
else	O
{	O
dico_log	function
(	O
L_ERR	O
,	O
0	int
,	O
_	function
(	O
"mod_init_db: cannot create class instance: %s"	pointer
)	O
,	O
root_class	pointer
)	O
;	O
if	O
(	O
PyErr_Occurred	function
(	O
)	O
)	O
PyErr_Print	function
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
(	O
dico_handle_t	O
)	O
db	pointer
;	O
}	O
static	O
int	O
mod_free_db	function
(	O
dico_handle_t	O
hp	int
)	O
{	O
struct	O
_python_database	struct
*	O
db	pointer
=	O
(	O
struct	O
_python_database	struct
*	O
)	O
hp	int
;	O
PyThreadState_Swap	function
(	O
NULL	O
)	O
;	O
PyThreadState_Delete	function
(	O
db	pointer
->	O
py_ths	pointer
)	O
;	O
free	function
(	O
db	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
mod_open	function
(	O
dico_handle_t	O
hp	int
)	O
{	O
PyObject	O
*	O
py_args	pointer
,	O
*	O
py_value	O
,	O
*	O
py_fnc	O
,	O
*	O
py_res	O
;	O
struct	O
_python_database	struct
*	O
db	pointer
=	O
(	O
struct	O
_python_database	struct
*	O
)	O
hp	int
;	O
PyThreadState_Swap	function
(	O
db	pointer
->	O
py_ths	pointer
)	O
;	O
py_value	O
=	O
PyString_FromString	function
(	O
db	pointer
->	O
dbname	pointer
)	O
;	O
py_args	pointer
=	O
PyTuple_New	function
(	O
1	int
)	O
;	O
PyTuple_SetItem	function
(	O
py_args	pointer
,	O
0	int
,	O
py_value	O
)	O
;	O
py_fnc	O
=	O
PyObject_GetAttrString	function
(	O
db	pointer
->	O
py_instance	pointer
,	O
"open"	pointer
)	O
;	O
if	O
(	O
py_fnc	O
&&	O
PyCallable_Check	function
(	O
py_fnc	O
)	O
)	O
{	O
py_res	O
=	O
PyObject_CallObject	function
(	O
py_fnc	O
,	O
py_args	pointer
)	O
;	O
Py_DECREF	function
(	O
py_args	pointer
)	O
;	O
Py_DECREF	function
(	O
py_fnc	O
)	O
;	O
if	O
(	O
py_res	O
&&	O
PyBool_Check	function
(	O
py_res	O
)	O
&&	O
py_res	O
==	O
Py_False	O
)	O
{	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
PyErr_Occurred	function
(	O
)	O
)	O
{	O
PyErr_Print	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
mod_close	function
(	O
dico_handle_t	O
hp	int
)	O
{	O
PyObject	O
*	O
py_fnc	O
,	O
*	O
py_res	O
;	O
struct	O
_python_database	struct
*	O
db	pointer
=	O
(	O
struct	O
_python_database	struct
*	O
)	O
hp	int
;	O
PyThreadState_Swap	function
(	O
db	pointer
->	O
py_ths	pointer
)	O
;	O
py_fnc	O
=	O
PyObject_GetAttrString	function
(	O
db	pointer
->	O
py_instance	pointer
,	O
"close"	pointer
)	O
;	O
if	O
(	O
py_fnc	O
&&	O
PyCallable_Check	function
(	O
py_fnc	O
)	O
)	O
{	O
py_res	O
=	O
PyObject_CallObject	function
(	O
py_fnc	O
,	O
NULL	O
)	O
;	O
Py_DECREF	function
(	O
py_fnc	O
)	O
;	O
if	O
(	O
py_res	O
&&	O
PyBool_Check	function
(	O
py_res	O
)	O
&&	O
py_res	O
==	O
Py_False	O
)	O
{	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
PyErr_Occurred	function
(	O
)	O
)	O
{	O
PyErr_Print	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
_mod_get_text	function
(	O
PyObject	O
*	O
py_instance	pointer
,	O
const	O
char	O
*	O
method	pointer
)	O
{	O
PyObject	O
*	O
py_fnc	O
,	O
*	O
py_res	O
;	O
if	O
(	O
!	O
py_instance	pointer
)	O
return	O
NULL	O
;	O
else	O
if	O
(	O
!	O
PyObject_HasAttrString	function
(	O
py_instance	pointer
,	O
method	pointer
)	O
)	O
return	O
NULL	O
;	O
py_fnc	O
=	O
PyObject_GetAttrString	function
(	O
py_instance	pointer
,	O
method	pointer
)	O
;	O
if	O
(	O
py_fnc	O
&&	O
PyCallable_Check	function
(	O
py_fnc	O
)	O
)	O
{	O
py_res	O
=	O
PyObject_CallObject	function
(	O
py_fnc	O
,	O
NULL	O
)	O
;	O
Py_DECREF	function
(	O
py_fnc	O
)	O
;	O
if	O
(	O
py_res	O
&&	O
PyString_Check	function
(	O
py_res	O
)	O
)	O
{	O
char	O
*	O
text	pointer
=	O
strdup	O
(	O
PyString_AsString	function
(	O
py_res	O
)	O
)	O
;	O
Py_DECREF	function
(	O
py_res	O
)	O
;	O
return	O
text	pointer
;	O
}	O
else	O
if	O
(	O
PyErr_Occurred	function
(	O
)	O
)	O
PyErr_Print	function
(	O
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
char	O
*	O
mod_info	function
(	O
dico_handle_t	O
hp	int
)	O
{	O
struct	O
_python_database	struct
*	O
db	pointer
=	O
(	O
struct	O
_python_database	struct
*	O
)	O
hp	int
;	O
PyThreadState_Swap	function
(	O
db	pointer
->	O
py_ths	pointer
)	O
;	O
return	O
_mod_get_text	function
(	O
db	pointer
->	O
py_instance	pointer
,	O
"info"	pointer
)	O
;	O
}	O
static	O
char	O
*	O
mod_descr	function
(	O
dico_handle_t	O
hp	int
)	O
{	O
struct	O
_python_database	struct
*	O
db	pointer
=	O
(	O
struct	O
_python_database	struct
*	O
)	O
hp	int
;	O
PyThreadState_Swap	function
(	O
db	pointer
->	O
py_ths	pointer
)	O
;	O
return	O
_mod_get_text	function
(	O
db	pointer
->	O
py_instance	pointer
,	O
"descr"	pointer
)	O
;	O
}	O
static	O
dico_list_t	O
_tuple_to_langlist	function
(	O
PyObject	O
*	O
py_obj	pointer
)	O
{	O
dico_list_t	O
list	array
=	O
NULL	O
;	O
if	O
(	O
!	O
py_obj	pointer
)	O
return	O
NULL	O
;	O
if	O
(	O
PyString_Check	function
(	O
py_obj	pointer
)	O
)	O
{	O
char	O
*	O
text	pointer
=	O
strdup	O
(	O
PyString_AsString	function
(	O
py_obj	pointer
)	O
)	O
;	O
list	array
=	O
dico_list_create	function
(	O
)	O
;	O
dico_list_append	function
(	O
list	array
,	O
text	pointer
)	O
;	O
}	O
else	O
if	O
(	O
PyTuple_Check	function
(	O
py_obj	pointer
)	O
||	O
PyList_Check	function
(	O
py_obj	pointer
)	O
)	O
{	O
PyObject	O
*	O
py_item	O
;	O
PyObject	O
*	O
py_iterator	O
=	O
PyObject_GetIter	function
(	O
py_obj	pointer
)	O
;	O
list	array
=	O
dico_list_create	function
(	O
)	O
;	O
if	O
(	O
py_iterator	O
)	O
{	O
while	O
(	O
(	O
py_item	O
=	O
PyIter_Next	function
(	O
py_iterator	O
)	O
)	O
)	O
{	O
if	O
(	O
PyString_Check	function
(	O
py_item	O
)	O
)	O
{	O
char	O
*	O
text	pointer
=	O
strdup	O
(	O
PyString_AsString	function
(	O
py_item	O
)	O
)	O
;	O
dico_list_append	function
(	O
list	array
,	O
text	pointer
)	O
;	O
}	O
Py_DECREF	function
(	O
py_item	O
)	O
;	O
}	O
Py_DECREF	function
(	O
py_iterator	O
)	O
;	O
if	O
(	O
PyErr_Occurred	function
(	O
)	O
)	O
{	O
PyErr_Print	function
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
}	O
return	O
list	array
;	O
}	O
static	O
int	O
mod_lang	function
(	O
dico_handle_t	O
hp	int
,	O
dico_list_t	O
list	array
[	O
2	int
]	O
)	O
{	O
PyObject	O
*	O
py_fnc	O
,	O
*	O
py_res	O
;	O
struct	O
_python_database	struct
*	O
db	pointer
=	O
(	O
struct	O
_python_database	struct
*	O
)	O
hp	int
;	O
list	array
[	O
0	int
]	O
=	O
list	array
[	O
1	int
]	O
=	O
NULL	O
;	O
PyThreadState_Swap	function
(	O
db	pointer
->	O
py_ths	pointer
)	O
;	O
if	O
(	O
!	O
PyObject_HasAttrString	function
(	O
db	pointer
->	O
py_instance	pointer
,	O
"lang"	pointer
)	O
)	O
return	O
1	int
;	O
py_fnc	O
=	O
PyObject_GetAttrString	function
(	O
db	pointer
->	O
py_instance	pointer
,	O
"lang"	pointer
)	O
;	O
if	O
(	O
py_fnc	O
&&	O
PyCallable_Check	function
(	O
py_fnc	O
)	O
)	O
{	O
py_res	O
=	O
PyObject_CallObject	function
(	O
py_fnc	O
,	O
NULL	O
)	O
;	O
Py_DECREF	function
(	O
py_fnc	O
)	O
;	O
if	O
(	O
py_res	O
)	O
{	O
if	O
(	O
PyString_Check	function
(	O
py_res	O
)	O
)	O
{	O
char	O
*	O
text	pointer
=	O
strdup	O
(	O
PyString_AsString	function
(	O
py_res	O
)	O
)	O
;	O
Py_DECREF	function
(	O
py_res	O
)	O
;	O
list	array
[	O
0	int
]	O
=	O
dico_list_create	function
(	O
)	O
;	O
dico_list_append	function
(	O
list	array
[	O
0	int
]	O
,	O
text	pointer
)	O
;	O
}	O
else	O
if	O
(	O
PyTuple_Check	function
(	O
py_res	O
)	O
)	O
{	O
switch	O
(	O
PyTuple_Size	function
(	O
py_res	O
)	O
)	O
{	O
case	O
2	int
:	O
list	array
[	O
0	int
]	O
=	O
_tuple_to_langlist	function
(	O
PyTuple_GetItem	function
(	O
py_res	O
,	O
0	int
)	O
)	O
;	O
list	array
[	O
1	int
]	O
=	O
_tuple_to_langlist	function
(	O
PyTuple_GetItem	function
(	O
py_res	O
,	O
1	int
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
list	array
[	O
0	int
]	O
=	O
_tuple_to_langlist	function
(	O
PyTuple_GetItem	function
(	O
py_res	O
,	O
0	int
)	O
)	O
;	O
break	O
;	O
default	O
:	O
dico_log	function
(	O
L_ERR	O
,	O
0	int
,	O
_	function
(	O
"Method `lang' must return at most"	pointer
" 2 elements"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
Py_DECREF	function
(	O
py_res	O
)	O
;	O
}	O
else	O
if	O
(	O
PyList_Check	function
(	O
py_res	O
)	O
)	O
{	O
switch	O
(	O
PyList_Size	function
(	O
py_res	O
)	O
)	O
{	O
case	O
2	int
:	O
list	array
[	O
0	int
]	O
=	O
_tuple_to_langlist	function
(	O
PyList_GetItem	function
(	O
py_res	O
,	O
0	int
)	O
)	O
;	O
list	array
[	O
1	int
]	O
=	O
_tuple_to_langlist	function
(	O
PyList_GetItem	function
(	O
py_res	O
,	O
1	int
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
list	array
[	O
0	int
]	O
=	O
_tuple_to_langlist	function
(	O
PyList_GetItem	function
(	O
py_res	O
,	O
0	int
)	O
)	O
;	O
break	O
;	O
default	O
:	O
dico_log	function
(	O
L_ERR	O
,	O
0	int
,	O
_	function
(	O
"Method `lang' must return at most"	pointer
" 2 elements"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
Py_DECREF	function
(	O
py_res	O
)	O
;	O
}	O
else	O
{	O
dico_log	function
(	O
L_ERR	O
,	O
0	int
,	O
_	function
(	O
"Method `lang' must return a tuple or "	pointer
"a list"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
PyErr_Occurred	function
(	O
)	O
)	O
{	O
PyErr_Print	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
struct	O
python_result	struct
{	O
struct	O
_python_database	struct
*	O
db	pointer
;	O
PyObject	O
*	O
result	pointer
;	O
}	O
;	O
static	O
dico_result_t	O
_make_python_result	function
(	O
struct	O
_python_database	struct
*	O
db	pointer
,	O
PyObject	O
*	O
res	pointer
)	O
{	O
struct	O
python_result	struct
*	O
rp	pointer
=	O
malloc	O
(	O
sizeof	O
(	O
*	O
rp	pointer
)	O
)	O
;	O
if	O
(	O
rp	pointer
)	O
{	O
rp	pointer
->	O
db	pointer
=	O
db	pointer
;	O
rp	pointer
->	O
result	pointer
=	O
res	pointer
;	O
}	O
return	O
(	O
dico_result_t	O
)	O
rp	pointer
;	O
}	O
dico_result_t	O
do_match	function
(	O
struct	O
_python_database	struct
*	O
db	pointer
,	O
const	O
dico_strategy_t	O
strat	int
,	O
struct	O
dico_key	O
*	O
key	pointer
)	O
{	O
PyStrategy	struct
*	O
py_strat	pointer
;	O
PySelectionKey	struct
*	O
py_key	pointer
;	O
PyObject	O
*	O
py_args	pointer
,	O
*	O
py_fnc	O
,	O
*	O
py_res	O
;	O
py_key	pointer
=	O
PyObject_NEW	function
(	O
PySelectionKey	struct
,	O
&	O
PySelectionKeyType	int
)	O
;	O
if	O
(	O
!	O
py_key	pointer
)	O
return	O
NULL	O
;	O
py_key	pointer
->	O
key	pointer
=	O
key	pointer
;	O
py_strat	pointer
=	O
PyObject_NEW	function
(	O
PyStrategy	struct
,	O
&	O
PyStrategyType	int
)	O
;	O
if	O
(	O
py_strat	pointer
)	O
{	O
py_strat	pointer
->	O
strat	int
=	O
strat	int
;	O
py_args	pointer
=	O
PyTuple_New	function
(	O
2	int
)	O
;	O
PyTuple_SetItem	function
(	O
py_args	pointer
,	O
0	int
,	O
(	O
PyObject	O
*	O
)	O
py_strat	pointer
)	O
;	O
PyTuple_SetItem	function
(	O
py_args	pointer
,	O
1	int
,	O
(	O
PyObject	O
*	O
)	O
py_key	pointer
)	O
;	O
py_fnc	O
=	O
PyObject_GetAttrString	function
(	O
db	pointer
->	O
py_instance	pointer
,	O
"match_word"	pointer
)	O
;	O
if	O
(	O
py_fnc	O
&&	O
PyCallable_Check	function
(	O
py_fnc	O
)	O
)	O
{	O
py_res	O
=	O
PyObject_CallObject	function
(	O
py_fnc	O
,	O
py_args	pointer
)	O
;	O
Py_DECREF	function
(	O
py_args	pointer
)	O
;	O
Py_DECREF	function
(	O
py_fnc	O
)	O
;	O
if	O
(	O
py_res	O
)	O
{	O
if	O
(	O
PyBool_Check	function
(	O
py_res	O
)	O
&&	O
py_res	O
==	O
Py_False	O
)	O
return	O
NULL	O
;	O
else	O
return	O
_make_python_result	function
(	O
db	pointer
,	O
py_res	O
)	O
;	O
}	O
else	O
if	O
(	O
PyErr_Occurred	function
(	O
)	O
)	O
PyErr_Print	function
(	O
)	O
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
static	O
dico_result_t	O
mod_match	function
(	O
dico_handle_t	O
hp	int
,	O
const	O
dico_strategy_t	O
strat	int
,	O
const	O
char	O
*	O
word	pointer
)	O
{	O
struct	O
_python_database	struct
*	O
db	pointer
=	O
(	O
struct	O
_python_database	struct
*	O
)	O
hp	int
;	O
struct	O
dico_key	O
key	pointer
;	O
dico_result_t	O
res	pointer
;	O
PyThreadState_Swap	function
(	O
db	pointer
->	O
py_ths	pointer
)	O
;	O
if	O
(	O
dico_key_init	function
(	O
&	O
key	pointer
,	O
strat	int
,	O
word	pointer
)	O
)	O
{	O
dico_log	function
(	O
L_ERR	O
,	O
0	int
,	O
_	function
(	O
"mod_match: key initialization failed"	pointer
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
res	pointer
=	O
do_match	function
(	O
db	pointer
,	O
strat	int
,	O
&	O
key	pointer
)	O
;	O
dico_key_deinit	function
(	O
&	O
key	pointer
)	O
;	O
return	O
res	pointer
;	O
}	O
static	O
dico_result_t	O
mod_define	function
(	O
dico_handle_t	O
hp	int
,	O
const	O
char	O
*	O
word	pointer
)	O
{	O
PyObject	O
*	O
py_args	pointer
,	O
*	O
py_fnc	O
,	O
*	O
py_res	O
;	O
struct	O
_python_database	struct
*	O
db	pointer
=	O
(	O
struct	O
_python_database	struct
*	O
)	O
hp	int
;	O
PyThreadState_Swap	function
(	O
db	pointer
->	O
py_ths	pointer
)	O
;	O
py_args	pointer
=	O
PyTuple_New	function
(	O
1	int
)	O
;	O
PyTuple_SetItem	function
(	O
py_args	pointer
,	O
0	int
,	O
PyString_FromString	function
(	O
word	pointer
)	O
)	O
;	O
py_fnc	O
=	O
PyObject_GetAttrString	function
(	O
db	pointer
->	O
py_instance	pointer
,	O
"define_word"	pointer
)	O
;	O
if	O
(	O
py_fnc	O
&&	O
PyCallable_Check	function
(	O
py_fnc	O
)	O
)	O
{	O
py_res	O
=	O
PyObject_CallObject	function
(	O
py_fnc	O
,	O
py_args	pointer
)	O
;	O
Py_DECREF	function
(	O
py_args	pointer
)	O
;	O
Py_DECREF	function
(	O
py_fnc	O
)	O
;	O
if	O
(	O
py_res	O
)	O
{	O
if	O
(	O
PyBool_Check	function
(	O
py_res	O
)	O
&&	O
py_res	O
==	O
Py_False	O
)	O
return	O
NULL	O
;	O
else	O
return	O
_make_python_result	function
(	O
db	pointer
,	O
py_res	O
)	O
;	O
}	O
else	O
if	O
(	O
PyErr_Occurred	function
(	O
)	O
)	O
PyErr_Print	function
(	O
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
int	O
mod_output_result	function
(	O
dico_result_t	O
rp	pointer
,	O
size_t	O
n	int
,	O
dico_stream_t	O
str	int
)	O
{	O
PyObject	O
*	O
py_args	pointer
,	O
*	O
py_fnc	O
,	O
*	O
py_out	O
;	O
struct	O
python_result	struct
*	O
gres	pointer
=	O
(	O
struct	O
python_result	struct
*	O
)	O
rp	pointer
;	O
struct	O
_python_database	struct
*	O
db	pointer
=	O
(	O
struct	O
_python_database	struct
*	O
)	O
gres	pointer
->	O
db	pointer
;	O
PyThreadState_Swap	function
(	O
db	pointer
->	O
py_ths	pointer
)	O
;	O
dico_stream_output	int
=	O
str	int
;	O
py_out	O
=	O
Py_InitModule	function
(	O
"stdout"	pointer
,	O
capture_stdout_result_method	array
)	O
;	O
if	O
(	O
py_out	O
)	O
PySys_SetObject	function
(	O
"stdout"	pointer
,	O
py_out	O
)	O
;	O
else	O
{	O
dico_log	function
(	O
L_ERR	O
,	O
0	int
,	O
_	function
(	O
"mod_output_result: cannot capture stdout"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
py_args	pointer
=	O
PyTuple_New	function
(	O
2	int
)	O
;	O
PyTuple_SetItem	function
(	O
py_args	pointer
,	O
0	int
,	O
gres	pointer
->	O
result	pointer
)	O
;	O
Py_INCREF	function
(	O
gres	pointer
->	O
result	pointer
)	O
;	O
PyTuple_SetItem	function
(	O
py_args	pointer
,	O
1	int
,	O
PyLong_FromLong	function
(	O
n	int
)	O
)	O
;	O
py_fnc	O
=	O
PyObject_GetAttrString	function
(	O
db	pointer
->	O
py_instance	pointer
,	O
"output"	pointer
)	O
;	O
if	O
(	O
py_fnc	O
&&	O
PyCallable_Check	function
(	O
py_fnc	O
)	O
)	O
{	O
PyObject_CallObject	function
(	O
py_fnc	O
,	O
py_args	pointer
)	O
;	O
Py_DECREF	function
(	O
py_args	pointer
)	O
;	O
Py_DECREF	function
(	O
py_fnc	O
)	O
;	O
if	O
(	O
PyErr_Occurred	function
(	O
)	O
)	O
PyErr_Print	function
(	O
)	O
;	O
}	O
py_out	O
=	O
Py_InitModule	function
(	O
"stdout"	pointer
,	O
capture_stdout_info_method	array
)	O
;	O
if	O
(	O
py_out	O
)	O
PySys_SetObject	function
(	O
"stdout"	pointer
,	O
py_out	O
)	O
;	O
dico_stream_output	int
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
static	O
size_t	O
_mod_get_size_t	function
(	O
PyObject	O
*	O
py_instance	pointer
,	O
PyObject	O
*	O
py_args	pointer
,	O
const	O
char	O
*	O
method	pointer
)	O
{	O
PyObject	O
*	O
py_fnc	O
,	O
*	O
py_res	O
;	O
if	O
(	O
!	O
py_instance	pointer
)	O
return	O
0	int
;	O
py_fnc	O
=	O
PyObject_GetAttrString	function
(	O
py_instance	pointer
,	O
method	pointer
)	O
;	O
if	O
(	O
py_fnc	O
&&	O
PyCallable_Check	function
(	O
py_fnc	O
)	O
)	O
{	O
py_res	O
=	O
PyObject_CallObject	function
(	O
py_fnc	O
,	O
py_args	pointer
)	O
;	O
Py_DECREF	function
(	O
py_fnc	O
)	O
;	O
if	O
(	O
py_res	O
&&	O
PyInt_Check	function
(	O
py_res	O
)	O
)	O
{	O
size_t	O
s	O
=	O
(	O
size_t	O
)	O
PyInt_AsSsize_t	O
(	O
py_res	O
)	O
;	O
Py_DECREF	function
(	O
py_res	O
)	O
;	O
return	O
s	O
;	O
}	O
else	O
if	O
(	O
PyErr_Occurred	function
(	O
)	O
)	O
PyErr_Print	function
(	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
size_t	O
mod_result_count	function
(	O
dico_result_t	O
rp	pointer
)	O
{	O
PyObject	O
*	O
py_args	pointer
;	O
struct	O
python_result	struct
*	O
gres	pointer
=	O
(	O
struct	O
python_result	struct
*	O
)	O
rp	pointer
;	O
struct	O
_python_database	struct
*	O
db	pointer
=	O
(	O
struct	O
_python_database	struct
*	O
)	O
gres	pointer
->	O
db	pointer
;	O
size_t	O
ret	O
;	O
PyThreadState_Swap	function
(	O
db	pointer
->	O
py_ths	pointer
)	O
;	O
py_args	pointer
=	O
PyTuple_New	function
(	O
1	int
)	O
;	O
PyTuple_SetItem	function
(	O
py_args	pointer
,	O
0	int
,	O
gres	pointer
->	O
result	pointer
)	O
;	O
Py_INCREF	function
(	O
gres	pointer
->	O
result	pointer
)	O
;	O
ret	O
=	O
_mod_get_size_t	function
(	O
db	pointer
->	O
py_instance	pointer
,	O
py_args	pointer
,	O
"result_count"	pointer
)	O
;	O
Py_DECREF	function
(	O
py_args	pointer
)	O
;	O
return	O
ret	O
;	O
}	O
static	O
size_t	O
mod_compare_count	function
(	O
dico_result_t	O
rp	pointer
)	O
{	O
PyObject	O
*	O
py_args	pointer
;	O
struct	O
python_result	struct
*	O
gres	pointer
=	O
(	O
struct	O
python_result	struct
*	O
)	O
rp	pointer
;	O
struct	O
_python_database	struct
*	O
db	pointer
=	O
(	O
struct	O
_python_database	struct
*	O
)	O
gres	pointer
->	O
db	pointer
;	O
size_t	O
ret	O
;	O
PyThreadState_Swap	function
(	O
db	pointer
->	O
py_ths	pointer
)	O
;	O
if	O
(	O
!	O
PyObject_HasAttrString	function
(	O
db	pointer
->	O
py_instance	pointer
,	O
"compare_count"	pointer
)	O
)	O
return	O
0	int
;	O
py_args	pointer
=	O
PyTuple_New	function
(	O
1	int
)	O
;	O
PyTuple_SetItem	function
(	O
py_args	pointer
,	O
0	int
,	O
gres	pointer
->	O
result	pointer
)	O
;	O
Py_INCREF	function
(	O
gres	pointer
->	O
result	pointer
)	O
;	O
ret	O
=	O
_mod_get_size_t	function
(	O
db	pointer
->	O
py_instance	pointer
,	O
py_args	pointer
,	O
"compare_count"	pointer
)	O
;	O
Py_DECREF	function
(	O
py_args	pointer
)	O
;	O
return	O
ret	O
;	O
}	O
static	O
void	O
mod_free_result	function
(	O
dico_result_t	O
rp	pointer
)	O
{	O
PyObject	O
*	O
py_args	pointer
,	O
*	O
py_fnc	O
;	O
struct	O
python_result	struct
*	O
gres	pointer
=	O
(	O
struct	O
python_result	struct
*	O
)	O
rp	pointer
;	O
struct	O
_python_database	struct
*	O
db	pointer
=	O
(	O
struct	O
_python_database	struct
*	O
)	O
gres	pointer
->	O
db	pointer
;	O
PyThreadState_Swap	function
(	O
db	pointer
->	O
py_ths	pointer
)	O
;	O
if	O
(	O
!	O
PyObject_HasAttrString	function
(	O
db	pointer
->	O
py_instance	pointer
,	O
"free_result"	pointer
)	O
)	O
return	O
;	O
py_args	pointer
=	O
PyTuple_New	function
(	O
1	int
)	O
;	O
PyTuple_SetItem	function
(	O
py_args	pointer
,	O
0	int
,	O
gres	pointer
->	O
result	pointer
)	O
;	O
Py_INCREF	function
(	O
gres	pointer
->	O
result	pointer
)	O
;	O
py_fnc	O
=	O
PyObject_GetAttrString	function
(	O
db	pointer
->	O
py_instance	pointer
,	O
"free_result"	pointer
)	O
;	O
if	O
(	O
py_fnc	O
&&	O
PyCallable_Check	function
(	O
py_fnc	O
)	O
)	O
{	O
PyObject_CallObject	function
(	O
py_fnc	O
,	O
py_args	pointer
)	O
;	O
Py_DECREF	function
(	O
py_args	pointer
)	O
;	O
Py_DECREF	function
(	O
py_fnc	O
)	O
;	O
if	O
(	O
PyErr_Occurred	function
(	O
)	O
)	O
PyErr_Print	function
(	O
)	O
;	O
}	O
Py_DECREF	function
(	O
gres	pointer
->	O
result	pointer
)	O
;	O
free	function
(	O
gres	pointer
)	O
;	O
}	O
static	O
PyObject	O
*	O
_assoc_to_dict	function
(	O
dico_assoc_list_t	O
assoc	int
)	O
{	O
PyObject	O
*	O
py_dict	pointer
;	O
dico_iterator_t	O
itr	O
;	O
struct	O
dico_assoc	O
*	O
p	pointer
;	O
py_dict	pointer
=	O
PyDict_New	function
(	O
)	O
;	O
if	O
(	O
py_dict	pointer
)	O
{	O
itr	O
=	O
dico_assoc_iterator	function
(	O
assoc	int
)	O
;	O
for	O
(	O
p	pointer
=	O
dico_iterator_first	function
(	O
itr	O
)	O
;	O
p	pointer
;	O
p	pointer
=	O
dico_iterator_next	function
(	O
itr	O
)	O
)	O
{	O
PyDict_SetItemString	function
(	O
py_dict	pointer
,	O
p	pointer
->	O
key	pointer
,	O
PyString_FromString	function
(	O
p	pointer
->	O
value	int
)	O
)	O
;	O
}	O
dico_iterator_destroy	function
(	O
&	O
itr	O
)	O
;	O
return	O
_ro	function
(	O
py_dict	pointer
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
void	O
_dict_to_assoc	function
(	O
dico_assoc_list_t	O
assoc	int
,	O
PyObject	O
*	O
py_dict	pointer
)	O
{	O
PyObject	O
*	O
py_key	pointer
,	O
*	O
py_value	O
;	O
Py_ssize_t	O
py_pos	O
=	O
0	int
;	O
dico_assoc_clear	function
(	O
assoc	int
)	O
;	O
while	O
(	O
PyDict_Next	function
(	O
py_dict	pointer
,	O
&	O
py_pos	O
,	O
&	O
py_key	pointer
,	O
&	O
py_value	O
)	O
)	O
{	O
char	O
*	O
key	pointer
,	O
*	O
val	pointer
;	O
key	pointer
=	O
strdup	O
(	O
PyString_AsString	function
(	O
py_key	pointer
)	O
)	O
;	O
val	pointer
=	O
strdup	O
(	O
PyString_AsString	function
(	O
py_value	O
)	O
)	O
;	O
dico_assoc_append	function
(	O
assoc	int
,	O
key	pointer
,	O
val	pointer
)	O
;	O
}	O
}	O
static	O
int	O
mod_result_headers	function
(	O
dico_result_t	O
rp	pointer
,	O
dico_assoc_list_t	O
hdr	int
)	O
{	O
PyObject	O
*	O
py_dict	pointer
,	O
*	O
py_args	pointer
,	O
*	O
py_fnc	O
,	O
*	O
py_res	O
;	O
struct	O
python_result	struct
*	O
gres	pointer
=	O
(	O
struct	O
python_result	struct
*	O
)	O
rp	pointer
;	O
struct	O
_python_database	struct
*	O
db	pointer
=	O
(	O
struct	O
_python_database	struct
*	O
)	O
gres	pointer
->	O
db	pointer
;	O
PyThreadState_Swap	function
(	O
db	pointer
->	O
py_ths	pointer
)	O
;	O
if	O
(	O
!	O
PyObject_HasAttrString	function
(	O
db	pointer
->	O
py_instance	pointer
,	O
"result_headers"	pointer
)	O
)	O
return	O
0	int
;	O
py_dict	pointer
=	O
_assoc_to_dict	function
(	O
hdr	int
)	O
;	O
py_args	pointer
=	O
PyTuple_New	function
(	O
2	int
)	O
;	O
PyTuple_SetItem	function
(	O
py_args	pointer
,	O
0	int
,	O
gres	pointer
->	O
result	pointer
)	O
;	O
PyTuple_SetItem	function
(	O
py_args	pointer
,	O
1	int
,	O
py_dict	pointer
)	O
;	O
Py_INCREF	function
(	O
gres	pointer
->	O
result	pointer
)	O
;	O
py_fnc	O
=	O
PyObject_GetAttrString	function
(	O
db	pointer
->	O
py_instance	pointer
,	O
"result_headers"	pointer
)	O
;	O
if	O
(	O
py_fnc	O
&&	O
PyCallable_Check	function
(	O
py_fnc	O
)	O
)	O
{	O
py_res	O
=	O
PyObject_CallObject	function
(	O
py_fnc	O
,	O
py_args	pointer
)	O
;	O
Py_DECREF	function
(	O
py_args	pointer
)	O
;	O
Py_DECREF	function
(	O
py_fnc	O
)	O
;	O
if	O
(	O
py_res	O
&&	O
PyDict_Check	function
(	O
py_res	O
)	O
)	O
{	O
_dict_to_assoc	function
(	O
hdr	int
,	O
py_res	O
)	O
;	O
Py_DECREF	function
(	O
py_res	O
)	O
;	O
}	O
else	O
if	O
(	O
PyErr_Occurred	function
(	O
)	O
)	O
{	O
PyErr_Print	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
Py_DECREF	function
(	O
py_dict	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
mod_db_mime_header	function
(	O
dico_handle_t	O
hp	int
)	O
{	O
struct	O
_python_database	struct
*	O
db	pointer
=	O
(	O
struct	O
_python_database	struct
*	O
)	O
hp	int
;	O
PyThreadState_Swap	function
(	O
db	pointer
->	O
py_ths	pointer
)	O
;	O
return	O
_mod_get_text	function
(	O
db	pointer
->	O
py_instance	pointer
,	O
"db_mime_header"	pointer
)	O
;	O
}	O
struct	O
dico_database_module	O
DICO_EXPORT	function
(	O
python	O
,	O
module	pointer
)	O
=	O
{	O
.	O
dico_version	O
=	O
DICO_MODULE_VERSION	O
,	O
.	O
dico_capabilities	O
=	O
DICO_CAPA_NONE	O
,	O
.	O
dico_init	O
=	O
mod_init	function
,	O
.	O
dico_init_db	O
=	O
mod_init_db	function
,	O
.	O
dico_free_db	O
=	O
mod_free_db	function
,	O
.	O
dico_open	O
=	O
mod_open	function
,	O
.	O
dico_close	O
=	O
mod_close	function
,	O
.	O
dico_db_info	O
=	O
mod_info	function
,	O
.	O
dico_db_descr	O
=	O
mod_descr	function
,	O
.	O
dico_db_lang	O
=	O
mod_lang	function
,	O
.	O
dico_match	O
=	O
mod_match	function
,	O
.	O
dico_define	O
=	O
mod_define	function
,	O
.	O
dico_output_result	O
=	O
mod_output_result	function
,	O
.	O
dico_result_count	O
=	O
mod_result_count	function
,	O
.	O
dico_compare_count	O
=	O
mod_compare_count	function
,	O
.	O
dico_free_result	O
=	O
mod_free_result	function
,	O
.	O
dico_result_headers	O
=	O
mod_result_headers	function
,	O
.	O
dico_db_mime_header	O
=	O
mod_db_mime_header	function
}	O
;	O
