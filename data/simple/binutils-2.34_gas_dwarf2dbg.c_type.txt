struct	O
line_entry	struct
{	O
struct	O
line_entry	struct
*	O
next	pointer
;	O
symbolS	struct
*	O
label	long
;	O
struct	O
dwarf2_line_info	struct
loc	pointer
;	O
}	O
;	O
static	O
char	O
unused	int
[	O
offsetof	O
(	O
struct	O
line_entry	struct
,	O
next	pointer
)	O
?	O
-	O
1	int
:	O
1	int
]	O
ATTRIBUTE_UNUSED	O
;	O
struct	O
line_subseg	struct
{	O
struct	O
line_subseg	struct
*	O
next	pointer
;	O
subsegT	int
subseg	int
;	O
struct	O
line_entry	struct
*	O
head	pointer
;	O
struct	O
line_entry	struct
*	O
*	O
ptail	pointer
;	O
struct	O
line_entry	struct
*	O
*	O
pmove_tail	pointer
;	O
}	O
;	O
struct	O
line_seg	struct
{	O
struct	O
line_seg	struct
*	O
next	pointer
;	O
segT	pointer
seg	pointer
;	O
struct	O
line_subseg	struct
*	O
head	pointer
;	O
symbolS	struct
*	O
text_start	pointer
;	O
symbolS	struct
*	O
text_end	pointer
;	O
}	O
;	O
static	O
struct	O
line_seg	struct
*	O
all_segs	pointer
;	O
static	O
struct	O
line_seg	struct
*	O
*	O
last_seg_ptr	pointer
;	O
struct	O
file_entry	struct
{	O
const	O
char	O
*	O
filename	pointer
;	O
unsigned	O
int	O
dir	pointer
;	O
}	O
;	O
static	O
struct	O
file_entry	struct
*	O
files	pointer
;	O
static	O
unsigned	O
int	O
files_in_use	int
;	O
static	O
unsigned	O
int	O
files_allocated	int
;	O
static	O
char	O
*	O
*	O
dirs	pointer
;	O
static	O
unsigned	O
int	O
dirs_in_use	int
;	O
static	O
unsigned	O
int	O
dirs_allocated	int
;	O
bfd_boolean	int
dwarf2_loc_directive_seen	int
;	O
bfd_boolean	int
dwarf2_loc_mark_labels	int
;	O
static	O
struct	O
dwarf2_line_info	struct
current	struct
=	O
{	O
1	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
DWARF2_LINE_DEFAULT_IS_STMT	int
?	O
DWARF2_FLAG_IS_STMT	O
:	O
0	int
,	O
0	int
,	O
NULL	O
}	O
;	O
static	O
symbolS	struct
*	O
force_reset_view	pointer
;	O
static	O
symbolS	struct
*	O
view_assert_failed	pointer
;	O
static	O
unsigned	O
int	O
sizeof_address	int
;	O
static	O
unsigned	O
int	O
get_filenum	function
(	O
const	O
char	O
*	O
,	O
unsigned	O
int	O
)	O
;	O
static	O
void	O
generic_dwarf2_emit_offset	function
(	O
symbolS	struct
*	O
symbol	pointer
,	O
unsigned	O
int	O
size	int
)	O
{	O
expressionS	struct
exp	pointer
;	O
memset	function
(	O
&	O
exp	pointer
,	O
0	int
,	O
sizeof	O
exp	pointer
)	O
;	O
exp	pointer
.	O
X_op	enum
=	O
O_symbol	int
;	O
exp	pointer
.	O
X_add_symbol	pointer
=	O
symbol	pointer
;	O
exp	pointer
.	O
X_add_number	long
=	O
0	int
;	O
emit_expr	function
(	O
&	O
exp	pointer
,	O
size	int
)	O
;	O
}	O
static	O
struct	O
line_subseg	struct
*	O
get_line_subseg	function
(	O
segT	pointer
seg	pointer
,	O
subsegT	int
subseg	int
,	O
bfd_boolean	int
create_p	int
)	O
{	O
struct	O
line_seg	struct
*	O
s	pointer
=	O
seg_info	O
(	O
seg	pointer
)	O
->	O
dwarf2_line_seg	pointer
;	O
struct	O
line_subseg	struct
*	O
*	O
pss	pointer
,	O
*	O
lss	pointer
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
!	O
create_p	int
)	O
return	O
NULL	O
;	O
s	pointer
=	O
XNEW	O
(	O
struct	O
line_seg	struct
)	O
;	O
s	pointer
->	O
next	pointer
=	O
NULL	O
;	O
s	pointer
->	O
seg	pointer
=	O
seg	pointer
;	O
s	pointer
->	O
head	pointer
=	O
NULL	O
;	O
*	O
last_seg_ptr	pointer
=	O
s	pointer
;	O
last_seg_ptr	pointer
=	O
&	O
s	pointer
->	O
next	pointer
;	O
seg_info	O
(	O
seg	pointer
)	O
->	O
dwarf2_line_seg	pointer
=	O
s	pointer
;	O
}	O
gas_assert	O
(	O
seg	pointer
==	O
s	pointer
->	O
seg	pointer
)	O
;	O
for	O
(	O
pss	pointer
=	O
&	O
s	pointer
->	O
head	pointer
;	O
(	O
lss	pointer
=	O
*	O
pss	pointer
)	O
!=	O
NULL	O
;	O
pss	pointer
=	O
&	O
lss	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
lss	pointer
->	O
subseg	int
==	O
subseg	int
)	O
goto	O
found_subseg	O
;	O
if	O
(	O
lss	pointer
->	O
subseg	int
>	O
subseg	int
)	O
break	O
;	O
}	O
lss	pointer
=	O
XNEW	O
(	O
struct	O
line_subseg	struct
)	O
;	O
lss	pointer
->	O
next	pointer
=	O
*	O
pss	pointer
;	O
lss	pointer
->	O
subseg	int
=	O
subseg	int
;	O
lss	pointer
->	O
head	pointer
=	O
NULL	O
;	O
lss	pointer
->	O
ptail	pointer
=	O
&	O
lss	pointer
->	O
head	pointer
;	O
lss	pointer
->	O
pmove_tail	pointer
=	O
&	O
lss	pointer
->	O
head	pointer
;	O
*	O
pss	pointer
=	O
lss	pointer
;	O
found_subseg	O
:	O
return	O
lss	pointer
;	O
}	O
static	O
struct	O
line_entry	struct
*	O
reverse_line_entry_list	function
(	O
struct	O
line_entry	struct
*	O
h	pointer
)	O
{	O
struct	O
line_entry	struct
*	O
p	pointer
=	O
NULL	O
,	O
*	O
e	pointer
,	O
*	O
n	int
;	O
for	O
(	O
e	pointer
=	O
h	pointer
;	O
e	pointer
;	O
e	pointer
=	O
n	int
)	O
{	O
n	int
=	O
e	pointer
->	O
next	pointer
;	O
e	pointer
->	O
next	pointer
=	O
p	pointer
;	O
p	pointer
=	O
e	pointer
;	O
}	O
return	O
p	pointer
;	O
}	O
static	O
void	O
set_or_check_view	function
(	O
struct	O
line_entry	struct
*	O
e	pointer
,	O
struct	O
line_entry	struct
*	O
p	pointer
,	O
struct	O
line_entry	struct
*	O
h	pointer
)	O
{	O
expressionS	struct
viewx	struct
;	O
memset	function
(	O
&	O
viewx	struct
,	O
0	int
,	O
sizeof	O
(	O
viewx	struct
)	O
)	O
;	O
viewx	struct
.	O
X_unsigned	int
=	O
1	int
;	O
if	O
(	O
!	O
p	pointer
||	O
(	O
e	pointer
->	O
loc	pointer
.	O
view	pointer
==	O
force_reset_view	pointer
&&	O
force_reset_view	pointer
)	O
)	O
{	O
viewx	struct
.	O
X_op	enum
=	O
O_constant	int
;	O
viewx	struct
.	O
X_add_number	long
=	O
0	int
;	O
viewx	struct
.	O
X_add_symbol	pointer
=	O
NULL	O
;	O
viewx	struct
.	O
X_op_symbol	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
viewx	struct
.	O
X_op	enum
=	O
O_gt	int
;	O
viewx	struct
.	O
X_add_number	long
=	O
0	int
;	O
viewx	struct
.	O
X_add_symbol	pointer
=	O
e	pointer
->	O
label	long
;	O
viewx	struct
.	O
X_op_symbol	pointer
=	O
p	pointer
->	O
label	long
;	O
resolve_expression	function
(	O
&	O
viewx	struct
)	O
;	O
if	O
(	O
viewx	struct
.	O
X_op	enum
==	O
O_constant	int
)	O
viewx	struct
.	O
X_add_number	long
=	O
!	O
viewx	struct
.	O
X_add_number	long
;	O
else	O
{	O
viewx	struct
.	O
X_add_symbol	pointer
=	O
make_expr_symbol	function
(	O
&	O
viewx	struct
)	O
;	O
viewx	struct
.	O
X_add_number	long
=	O
0	int
;	O
viewx	struct
.	O
X_op_symbol	pointer
=	O
NULL	O
;	O
viewx	struct
.	O
X_op	enum
=	O
O_logical_not	int
;	O
}	O
}	O
if	O
(	O
S_IS_DEFINED	function
(	O
e	pointer
->	O
loc	pointer
.	O
view	pointer
)	O
&&	O
symbol_constant_p	function
(	O
e	pointer
->	O
loc	pointer
.	O
view	pointer
)	O
)	O
{	O
expressionS	struct
*	O
value	long
=	O
symbol_get_value_expression	function
(	O
e	pointer
->	O
loc	pointer
.	O
view	pointer
)	O
;	O
if	O
(	O
viewx	struct
.	O
X_op	enum
==	O
O_constant	int
)	O
{	O
if	O
(	O
!	O
value	long
->	O
X_add_number	long
!=	O
!	O
viewx	struct
.	O
X_add_number	long
)	O
as_bad	function
(	O
_	O
(	O
"view number mismatch"	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
value	long
->	O
X_add_number	long
)	O
{	O
symbolS	struct
*	O
deferred	pointer
=	O
make_expr_symbol	function
(	O
&	O
viewx	struct
)	O
;	O
if	O
(	O
view_assert_failed	pointer
)	O
{	O
expressionS	struct
chk	struct
;	O
memset	function
(	O
&	O
chk	struct
,	O
0	int
,	O
sizeof	O
(	O
chk	struct
)	O
)	O
;	O
chk	struct
.	O
X_unsigned	int
=	O
1	int
;	O
chk	struct
.	O
X_op	enum
=	O
O_add	int
;	O
chk	struct
.	O
X_add_number	long
=	O
0	int
;	O
chk	struct
.	O
X_add_symbol	pointer
=	O
view_assert_failed	pointer
;	O
chk	struct
.	O
X_op_symbol	pointer
=	O
deferred	pointer
;	O
deferred	pointer
=	O
make_expr_symbol	function
(	O
&	O
chk	struct
)	O
;	O
}	O
view_assert_failed	pointer
=	O
deferred	pointer
;	O
}	O
}	O
if	O
(	O
viewx	struct
.	O
X_op	enum
!=	O
O_constant	int
||	O
viewx	struct
.	O
X_add_number	long
)	O
{	O
expressionS	struct
incv	struct
;	O
if	O
(	O
!	O
p	pointer
->	O
loc	pointer
.	O
view	pointer
)	O
{	O
p	pointer
->	O
loc	pointer
.	O
view	pointer
=	O
symbol_temp_make	function
(	O
)	O
;	O
gas_assert	O
(	O
!	O
S_IS_DEFINED	function
(	O
p	pointer
->	O
loc	pointer
.	O
view	pointer
)	O
)	O
;	O
}	O
memset	function
(	O
&	O
incv	struct
,	O
0	int
,	O
sizeof	O
(	O
incv	struct
)	O
)	O
;	O
incv	struct
.	O
X_unsigned	int
=	O
1	int
;	O
incv	struct
.	O
X_op	enum
=	O
O_symbol	int
;	O
incv	struct
.	O
X_add_symbol	pointer
=	O
p	pointer
->	O
loc	pointer
.	O
view	pointer
;	O
incv	struct
.	O
X_add_number	long
=	O
1	int
;	O
if	O
(	O
viewx	struct
.	O
X_op	enum
==	O
O_constant	int
)	O
{	O
gas_assert	O
(	O
viewx	struct
.	O
X_add_number	long
==	O
1	int
)	O
;	O
viewx	struct
=	O
incv	struct
;	O
}	O
else	O
{	O
viewx	struct
.	O
X_add_symbol	pointer
=	O
make_expr_symbol	function
(	O
&	O
viewx	struct
)	O
;	O
viewx	struct
.	O
X_add_number	long
=	O
0	int
;	O
viewx	struct
.	O
X_op_symbol	pointer
=	O
make_expr_symbol	function
(	O
&	O
incv	struct
)	O
;	O
viewx	struct
.	O
X_op	enum
=	O
O_multiply	int
;	O
}	O
}	O
if	O
(	O
!	O
S_IS_DEFINED	function
(	O
e	pointer
->	O
loc	pointer
.	O
view	pointer
)	O
)	O
{	O
symbol_set_value_expression	function
(	O
e	pointer
->	O
loc	pointer
.	O
view	pointer
,	O
&	O
viewx	struct
)	O
;	O
S_SET_SEGMENT	function
(	O
e	pointer
->	O
loc	pointer
.	O
view	pointer
,	O
expr_section	pointer
)	O
;	O
symbol_set_frag	function
(	O
e	pointer
->	O
loc	pointer
.	O
view	pointer
,	O
&	O
zero_address_frag	struct
)	O
;	O
}	O
if	O
(	O
h	pointer
&&	O
p	pointer
&&	O
p	pointer
->	O
loc	pointer
.	O
view	pointer
&&	O
!	O
S_IS_DEFINED	function
(	O
p	pointer
->	O
loc	pointer
.	O
view	pointer
)	O
)	O
{	O
struct	O
line_entry	struct
*	O
h2	pointer
;	O
struct	O
line_entry	struct
*	O
r	struct
=	O
reverse_line_entry_list	function
(	O
h	pointer
)	O
;	O
gas_assert	O
(	O
r	struct
==	O
p	pointer
)	O
;	O
do	O
{	O
if	O
(	O
r	struct
==	O
h	pointer
)	O
break	O
;	O
set_or_check_view	function
(	O
r	struct
,	O
r	struct
->	O
next	pointer
,	O
NULL	O
)	O
;	O
}	O
while	O
(	O
r	struct
->	O
next	pointer
&&	O
r	struct
->	O
next	pointer
->	O
loc	pointer
.	O
view	pointer
&&	O
!	O
S_IS_DEFINED	function
(	O
r	struct
->	O
next	pointer
->	O
loc	pointer
.	O
view	pointer
)	O
&&	O
(	O
r	struct
=	O
r	struct
->	O
next	pointer
)	O
)	O
;	O
h2	pointer
=	O
reverse_line_entry_list	function
(	O
p	pointer
)	O
;	O
gas_assert	O
(	O
h2	pointer
==	O
h	pointer
)	O
;	O
do	O
{	O
if	O
(	O
r	struct
==	O
h	pointer
)	O
continue	O
;	O
gas_assert	O
(	O
S_IS_DEFINED	function
(	O
r	struct
->	O
loc	pointer
.	O
view	pointer
)	O
)	O
;	O
resolve_expression	function
(	O
symbol_get_value_expression	function
(	O
r	struct
->	O
loc	pointer
.	O
view	pointer
)	O
)	O
;	O
}	O
while	O
(	O
r	struct
!=	O
p	pointer
&&	O
(	O
r	struct
=	O
r	struct
->	O
next	pointer
)	O
)	O
;	O
resolve_expression	function
(	O
symbol_get_value_expression	function
(	O
e	pointer
->	O
loc	pointer
.	O
view	pointer
)	O
)	O
;	O
}	O
}	O
static	O
void	O
dwarf2_gen_line_info_1	function
(	O
symbolS	struct
*	O
label	long
,	O
struct	O
dwarf2_line_info	struct
*	O
loc	pointer
)	O
{	O
struct	O
line_subseg	struct
*	O
lss	pointer
;	O
struct	O
line_entry	struct
*	O
e	pointer
;	O
e	pointer
=	O
XNEW	O
(	O
struct	O
line_entry	struct
)	O
;	O
e	pointer
->	O
next	pointer
=	O
NULL	O
;	O
e	pointer
->	O
label	long
=	O
label	long
;	O
e	pointer
->	O
loc	pointer
=	O
*	O
loc	pointer
;	O
lss	pointer
=	O
get_line_subseg	function
(	O
now_seg	pointer
,	O
now_subseg	int
,	O
TRUE	int
)	O
;	O
if	O
(	O
loc	pointer
->	O
view	pointer
&&	O
lss	pointer
->	O
head	pointer
)	O
set_or_check_view	function
(	O
e	pointer
,	O
(	O
struct	O
line_entry	struct
*	O
)	O
lss	pointer
->	O
ptail	pointer
,	O
lss	pointer
->	O
head	pointer
)	O
;	O
*	O
lss	pointer
->	O
ptail	pointer
=	O
e	pointer
;	O
lss	pointer
->	O
ptail	pointer
=	O
&	O
e	pointer
->	O
next	pointer
;	O
}	O
void	O
dwarf2_gen_line_info	function
(	O
addressT	long
ofs	long
,	O
struct	O
dwarf2_line_info	struct
*	O
loc	pointer
)	O
{	O
static	O
unsigned	O
int	O
line	int
=	O
-	O
1	int
;	O
static	O
unsigned	O
int	O
filenum	int
=	O
-	O
1	int
;	O
symbolS	struct
*	O
sym	pointer
;	O
if	O
(	O
loc	pointer
->	O
filenum	int
==	O
0	int
||	O
loc	pointer
->	O
line	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
debug_type	enum
==	O
DEBUG_DWARF2	int
&&	O
line	int
==	O
loc	pointer
->	O
line	int
&&	O
filenum	int
==	O
loc	pointer
->	O
filenum	int
)	O
return	O
;	O
line	int
=	O
loc	pointer
->	O
line	int
;	O
filenum	int
=	O
loc	pointer
->	O
filenum	int
;	O
if	O
(	O
linkrelax	int
)	O
{	O
char	O
name	pointer
[	O
120	int
]	O
;	O
sprintf	function
(	O
name	pointer
,	O
".Loc.%u.%u"	pointer
,	O
line	int
,	O
filenum	int
)	O
;	O
sym	pointer
=	O
symbol_new	function
(	O
name	pointer
,	O
now_seg	pointer
,	O
ofs	long
,	O
frag_now	pointer
)	O
;	O
}	O
else	O
sym	pointer
=	O
symbol_temp_new	function
(	O
now_seg	pointer
,	O
ofs	long
,	O
frag_now	pointer
)	O
;	O
dwarf2_gen_line_info_1	function
(	O
sym	pointer
,	O
loc	pointer
)	O
;	O
}	O
void	O
dwarf2_where	function
(	O
struct	O
dwarf2_line_info	struct
*	O
line	int
)	O
{	O
if	O
(	O
debug_type	enum
==	O
DEBUG_DWARF2	int
)	O
{	O
const	O
char	O
*	O
filename	pointer
;	O
memset	function
(	O
line	int
,	O
0	int
,	O
sizeof	O
(	O
*	O
line	int
)	O
)	O
;	O
filename	pointer
=	O
as_where	function
(	O
&	O
line	int
->	O
line	int
)	O
;	O
line	int
->	O
filenum	int
=	O
get_filenum	function
(	O
filename	pointer
,	O
0	int
)	O
;	O
line	int
->	O
column	int
=	O
0	int
;	O
line	int
->	O
flags	int
=	O
DWARF2_FLAG_IS_STMT	O
;	O
line	int
->	O
isa	enum
=	O
current	struct
.	O
isa	enum
;	O
line	int
->	O
discriminator	int
=	O
current	struct
.	O
discriminator	int
;	O
line	int
->	O
view	pointer
=	O
NULL	O
;	O
}	O
else	O
*	O
line	int
=	O
current	struct
;	O
}	O
void	O
dwarf2_set_isa	function
(	O
unsigned	O
int	O
isa	enum
)	O
{	O
current	struct
.	O
isa	enum
=	O
isa	enum
;	O
}	O
void	O
dwarf2_emit_insn	function
(	O
int	O
size	int
)	O
{	O
struct	O
dwarf2_line_info	struct
loc	pointer
;	O
if	O
(	O
debug_type	enum
!=	O
DEBUG_DWARF2	int
?	O
!	O
dwarf2_loc_directive_seen	int
:	O
!	O
seen_at_least_1_file	function
(	O
)	O
)	O
return	O
;	O
dwarf2_where	function
(	O
&	O
loc	pointer
)	O
;	O
dwarf2_gen_line_info	function
(	O
(	O
frag_now_fix_octets	function
(	O
)	O
-	O
size	int
)	O
/	O
OCTETS_PER_BYTE	O
,	O
&	O
loc	pointer
)	O
;	O
dwarf2_consume_line_info	function
(	O
)	O
;	O
}	O
void	O
dwarf2_move_insn	function
(	O
int	O
delta	int
)	O
{	O
struct	O
line_subseg	struct
*	O
lss	pointer
;	O
struct	O
line_entry	struct
*	O
e	pointer
;	O
valueT	long
now	long
;	O
if	O
(	O
delta	int
==	O
0	int
)	O
return	O
;	O
lss	pointer
=	O
get_line_subseg	function
(	O
now_seg	pointer
,	O
now_subseg	int
,	O
FALSE	int
)	O
;	O
if	O
(	O
!	O
lss	pointer
)	O
return	O
;	O
now	long
=	O
frag_now_fix	function
(	O
)	O
;	O
while	O
(	O
(	O
e	pointer
=	O
*	O
lss	pointer
->	O
pmove_tail	pointer
)	O
)	O
{	O
if	O
(	O
S_GET_VALUE	function
(	O
e	pointer
->	O
label	long
)	O
==	O
now	long
)	O
S_SET_VALUE	function
(	O
e	pointer
->	O
label	long
,	O
now	long
+	O
delta	int
)	O
;	O
lss	pointer
->	O
pmove_tail	pointer
=	O
&	O
e	pointer
->	O
next	pointer
;	O
}	O
}	O
void	O
dwarf2_consume_line_info	function
(	O
void	O
)	O
{	O
dwarf2_loc_directive_seen	int
=	O
FALSE	int
;	O
current	struct
.	O
flags	int
&=	O
~	O
(	O
DWARF2_FLAG_BASIC_BLOCK	O
|	O
DWARF2_FLAG_PROLOGUE_END	O
|	O
DWARF2_FLAG_EPILOGUE_BEGIN	O
)	O
;	O
current	struct
.	O
discriminator	int
=	O
0	int
;	O
current	struct
.	O
view	pointer
=	O
NULL	O
;	O
}	O
void	O
dwarf2_emit_label	function
(	O
symbolS	struct
*	O
label	long
)	O
{	O
struct	O
dwarf2_line_info	struct
loc	pointer
;	O
if	O
(	O
!	O
dwarf2_loc_mark_labels	int
)	O
return	O
;	O
if	O
(	O
S_GET_SEGMENT	function
(	O
label	long
)	O
!=	O
now_seg	pointer
)	O
return	O
;	O
if	O
(	O
!	O
(	O
bfd_section_flags	function
(	O
now_seg	pointer
)	O
&	O
SEC_CODE	int
)	O
)	O
return	O
;	O
if	O
(	O
files_in_use	int
==	O
0	int
&&	O
debug_type	enum
!=	O
DEBUG_DWARF2	int
)	O
return	O
;	O
dwarf2_where	function
(	O
&	O
loc	pointer
)	O
;	O
loc	pointer
.	O
flags	int
|=	O
DWARF2_FLAG_BASIC_BLOCK	O
;	O
dwarf2_gen_line_info_1	function
(	O
label	long
,	O
&	O
loc	pointer
)	O
;	O
dwarf2_consume_line_info	function
(	O
)	O
;	O
}	O
static	O
unsigned	O
int	O
get_filenum	function
(	O
const	O
char	O
*	O
filename	pointer
,	O
unsigned	O
int	O
num	int
)	O
{	O
static	O
unsigned	O
int	O
last_used	int
,	O
last_used_dir_len	int
;	O
const	O
char	O
*	O
file	pointer
;	O
size_t	long
dir_len	long
;	O
unsigned	O
int	O
i	pointer
,	O
dir	pointer
;	O
if	O
(	O
num	int
==	O
0	int
&&	O
last_used	int
)	O
{	O
if	O
(	O
!	O
files	pointer
[	O
last_used	int
]	O
.	O
dir	pointer
&&	O
filename_cmp	function
(	O
filename	pointer
,	O
files	pointer
[	O
last_used	int
]	O
.	O
filename	pointer
)	O
==	O
0	int
)	O
return	O
last_used	int
;	O
if	O
(	O
files	pointer
[	O
last_used	int
]	O
.	O
dir	pointer
&&	O
filename_ncmp	function
(	O
filename	pointer
,	O
dirs	pointer
[	O
files	pointer
[	O
last_used	int
]	O
.	O
dir	pointer
]	O
,	O
last_used_dir_len	int
)	O
==	O
0	int
&&	O
IS_DIR_SEPARATOR	O
(	O
filename	pointer
[	O
last_used_dir_len	int
]	O
)	O
&&	O
filename_cmp	function
(	O
filename	pointer
+	O
last_used_dir_len	int
+	O
1	int
,	O
files	pointer
[	O
last_used	int
]	O
.	O
filename	pointer
)	O
==	O
0	int
)	O
return	O
last_used	int
;	O
}	O
file	pointer
=	O
lbasename	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
file	pointer
==	O
filename	pointer
+	O
1	int
)	O
file	pointer
=	O
filename	pointer
;	O
dir_len	long
=	O
file	pointer
-	O
filename	pointer
;	O
dir	pointer
=	O
0	int
;	O
if	O
(	O
dir_len	long
)	O
{	O
--	O
dir_len	long
;	O
for	O
(	O
dir	pointer
=	O
1	int
;	O
dir	pointer
<	O
dirs_in_use	int
;	O
++	O
dir	pointer
)	O
if	O
(	O
filename_ncmp	function
(	O
filename	pointer
,	O
dirs	pointer
[	O
dir	pointer
]	O
,	O
dir_len	long
)	O
==	O
0	int
&&	O
dirs	pointer
[	O
dir	pointer
]	O
[	O
dir_len	long
]	O
==	O
'\0'	O
)	O
break	O
;	O
if	O
(	O
dir	pointer
>=	O
dirs_in_use	int
)	O
{	O
if	O
(	O
dir	pointer
>=	O
dirs_allocated	int
)	O
{	O
dirs_allocated	int
=	O
dir	pointer
+	O
32	int
;	O
dirs	pointer
=	O
XRESIZEVEC	O
(	O
char	O
*	O
,	O
dirs	pointer
,	O
dirs_allocated	int
)	O
;	O
}	O
dirs	pointer
[	O
dir	pointer
]	O
=	O
xmemdup0	function
(	O
filename	pointer
,	O
dir_len	long
)	O
;	O
dirs_in_use	int
=	O
dir	pointer
+	O
1	int
;	O
}	O
}	O
if	O
(	O
num	int
==	O
0	int
)	O
{	O
for	O
(	O
i	pointer
=	O
1	int
;	O
i	pointer
<	O
files_in_use	int
;	O
++	O
i	pointer
)	O
if	O
(	O
files	pointer
[	O
i	pointer
]	O
.	O
dir	pointer
==	O
dir	pointer
&&	O
files	pointer
[	O
i	pointer
]	O
.	O
filename	pointer
&&	O
filename_cmp	function
(	O
file	pointer
,	O
files	pointer
[	O
i	pointer
]	O
.	O
filename	pointer
)	O
==	O
0	int
)	O
{	O
last_used	int
=	O
i	pointer
;	O
last_used_dir_len	int
=	O
dir_len	long
;	O
return	O
i	pointer
;	O
}	O
}	O
else	O
i	pointer
=	O
num	int
;	O
if	O
(	O
i	pointer
>=	O
files_allocated	int
)	O
{	O
unsigned	O
int	O
old	pointer
=	O
files_allocated	int
;	O
files_allocated	int
=	O
i	pointer
+	O
32	int
;	O
if	O
(	O
files_allocated	int
<=	O
old	pointer
)	O
{	O
as_bad	function
(	O
_	O
(	O
"file number %lu is too big"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
i	pointer
)	O
;	O
return	O
0	int
;	O
}	O
files	pointer
=	O
XRESIZEVEC	O
(	O
struct	O
file_entry	struct
,	O
files	pointer
,	O
files_allocated	int
)	O
;	O
memset	function
(	O
files	pointer
+	O
old	pointer
,	O
0	int
,	O
(	O
i	pointer
+	O
32	int
-	O
old	pointer
)	O
*	O
sizeof	O
(	O
struct	O
file_entry	struct
)	O
)	O
;	O
}	O
files	pointer
[	O
i	pointer
]	O
.	O
filename	pointer
=	O
file	pointer
;	O
files	pointer
[	O
i	pointer
]	O
.	O
dir	pointer
=	O
dir	pointer
;	O
if	O
(	O
files_in_use	int
<	O
i	pointer
+	O
1	int
)	O
files_in_use	int
=	O
i	pointer
+	O
1	int
;	O
last_used	int
=	O
i	pointer
;	O
last_used_dir_len	int
=	O
dir_len	long
;	O
return	O
i	pointer
;	O
}	O
char	O
*	O
dwarf2_directive_filename	function
(	O
void	O
)	O
{	O
valueT	long
num	int
;	O
char	O
*	O
filename	pointer
;	O
int	O
filename_len	int
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	pointer
==	O
'"'	O
)	O
{	O
s_app_file	function
(	O
0	int
)	O
;	O
return	O
NULL	O
;	O
}	O
num	int
=	O
get_absolute_expression	function
(	O
)	O
;	O
filename	pointer
=	O
demand_copy_C_string	function
(	O
&	O
filename_len	int
)	O
;	O
if	O
(	O
filename	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
if	O
(	O
(	O
offsetT	long
)	O
num	int
<	O
1	int
)	O
{	O
as_bad	function
(	O
_	O
(	O
"file number less than one"	pointer
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
debug_type	enum
=	O
DEBUG_NONE	int
;	O
if	O
(	O
num	int
!=	O
(	O
unsigned	O
int	O
)	O
num	int
||	O
num	int
>=	O
(	O
size_t	long
)	O
-	O
1	int
/	O
sizeof	O
(	O
struct	O
file_entry	struct
)	O
-	O
32	int
)	O
{	O
as_bad	function
(	O
_	O
(	O
"file number %lu is too big"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
num	int
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
num	int
<	O
files_in_use	int
&&	O
files	pointer
[	O
num	int
]	O
.	O
filename	pointer
!=	O
0	int
)	O
{	O
as_bad	function
(	O
_	O
(	O
"file number %u already allocated"	pointer
)	O
,	O
(	O
unsigned	O
int	O
)	O
num	int
)	O
;	O
return	O
NULL	O
;	O
}	O
get_filenum	function
(	O
filename	pointer
,	O
(	O
unsigned	O
int	O
)	O
num	int
)	O
;	O
return	O
filename	pointer
;	O
}	O
void	O
dwarf2_directive_file	function
(	O
int	O
dummy	int
ATTRIBUTE_UNUSED	O
)	O
{	O
(	O
void	O
)	O
dwarf2_directive_filename	function
(	O
)	O
;	O
}	O
void	O
dwarf2_directive_loc	function
(	O
int	O
dummy	int
ATTRIBUTE_UNUSED	O
)	O
{	O
offsetT	long
filenum	int
,	O
line	int
;	O
if	O
(	O
dwarf2_loc_directive_seen	int
)	O
dwarf2_emit_insn	function
(	O
0	int
)	O
;	O
filenum	int
=	O
get_absolute_expression	function
(	O
)	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
line	int
=	O
get_absolute_expression	function
(	O
)	O
;	O
if	O
(	O
filenum	int
<	O
1	int
)	O
{	O
as_bad	function
(	O
_	O
(	O
"file number less than one"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
filenum	int
>=	O
(	O
int	O
)	O
files_in_use	int
||	O
files	pointer
[	O
filenum	int
]	O
.	O
filename	pointer
==	O
0	int
)	O
{	O
as_bad	function
(	O
_	O
(	O
"unassigned file number %ld"	pointer
)	O
,	O
(	O
long	O
)	O
filenum	int
)	O
;	O
return	O
;	O
}	O
current	struct
.	O
filenum	int
=	O
filenum	int
;	O
current	struct
.	O
line	int
=	O
line	int
;	O
current	struct
.	O
discriminator	int
=	O
0	int
;	O
if	O
(	O
listing	int
)	O
{	O
if	O
(	O
files	pointer
[	O
filenum	int
]	O
.	O
dir	pointer
)	O
{	O
size_t	long
dir_len	long
=	O
strlen	function
(	O
dirs	pointer
[	O
files	pointer
[	O
filenum	int
]	O
.	O
dir	pointer
]	O
)	O
;	O
size_t	long
file_len	long
=	O
strlen	function
(	O
files	pointer
[	O
filenum	int
]	O
.	O
filename	pointer
)	O
;	O
char	O
*	O
cp	pointer
=	O
XNEWVEC	O
(	O
char	O
,	O
dir_len	long
+	O
1	int
+	O
file_len	long
+	O
1	int
)	O
;	O
memcpy	function
(	O
cp	pointer
,	O
dirs	pointer
[	O
files	pointer
[	O
filenum	int
]	O
.	O
dir	pointer
]	O
,	O
dir_len	long
)	O
;	O
INSERT_DIR_SEPARATOR	O
(	O
cp	pointer
,	O
dir_len	long
)	O
;	O
memcpy	function
(	O
cp	pointer
+	O
dir_len	long
+	O
1	int
,	O
files	pointer
[	O
filenum	int
]	O
.	O
filename	pointer
,	O
file_len	long
)	O
;	O
cp	pointer
[	O
dir_len	long
+	O
file_len	long
+	O
1	int
]	O
=	O
'\0'	O
;	O
listing_source_file	function
(	O
cp	pointer
)	O
;	O
free	function
(	O
cp	pointer
)	O
;	O
}	O
else	O
listing_source_file	function
(	O
files	pointer
[	O
filenum	int
]	O
.	O
filename	pointer
)	O
;	O
listing_source_line	function
(	O
line	int
)	O
;	O
}	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
ISDIGIT	O
(	O
*	O
input_line_pointer	pointer
)	O
)	O
{	O
current	struct
.	O
column	int
=	O
get_absolute_expression	function
(	O
)	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
}	O
while	O
(	O
ISALPHA	O
(	O
*	O
input_line_pointer	pointer
)	O
)	O
{	O
char	O
*	O
p	pointer
,	O
c	struct
;	O
offsetT	long
value	long
;	O
c	struct
=	O
get_symbol_name	function
(	O
&	O
p	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"basic_block"	pointer
)	O
==	O
0	int
)	O
{	O
current	struct
.	O
flags	int
|=	O
DWARF2_FLAG_BASIC_BLOCK	O
;	O
*	O
input_line_pointer	pointer
=	O
c	struct
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"prologue_end"	pointer
)	O
==	O
0	int
)	O
{	O
current	struct
.	O
flags	int
|=	O
DWARF2_FLAG_PROLOGUE_END	O
;	O
*	O
input_line_pointer	pointer
=	O
c	struct
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"epilogue_begin"	pointer
)	O
==	O
0	int
)	O
{	O
current	struct
.	O
flags	int
|=	O
DWARF2_FLAG_EPILOGUE_BEGIN	O
;	O
*	O
input_line_pointer	pointer
=	O
c	struct
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"is_stmt"	pointer
)	O
==	O
0	int
)	O
{	O
(	O
void	O
)	O
restore_line_pointer	function
(	O
c	struct
)	O
;	O
value	long
=	O
get_absolute_expression	function
(	O
)	O
;	O
if	O
(	O
value	long
==	O
0	int
)	O
current	struct
.	O
flags	int
&=	O
~	O
DWARF2_FLAG_IS_STMT	O
;	O
else	O
if	O
(	O
value	long
==	O
1	int
)	O
current	struct
.	O
flags	int
|=	O
DWARF2_FLAG_IS_STMT	O
;	O
else	O
{	O
as_bad	function
(	O
_	O
(	O
"is_stmt value not 0 or 1"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"isa"	pointer
)	O
==	O
0	int
)	O
{	O
(	O
void	O
)	O
restore_line_pointer	function
(	O
c	struct
)	O
;	O
value	long
=	O
get_absolute_expression	function
(	O
)	O
;	O
if	O
(	O
value	long
>=	O
0	int
)	O
current	struct
.	O
isa	enum
=	O
value	long
;	O
else	O
{	O
as_bad	function
(	O
_	O
(	O
"isa number less than zero"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"discriminator"	pointer
)	O
==	O
0	int
)	O
{	O
(	O
void	O
)	O
restore_line_pointer	function
(	O
c	struct
)	O
;	O
value	long
=	O
get_absolute_expression	function
(	O
)	O
;	O
if	O
(	O
value	long
>=	O
0	int
)	O
current	struct
.	O
discriminator	int
=	O
value	long
;	O
else	O
{	O
as_bad	function
(	O
_	O
(	O
"discriminator less than zero"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"view"	pointer
)	O
==	O
0	int
)	O
{	O
symbolS	struct
*	O
sym	pointer
;	O
(	O
void	O
)	O
restore_line_pointer	function
(	O
c	struct
)	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
ISDIGIT	O
(	O
*	O
input_line_pointer	pointer
)	O
||	O
*	O
input_line_pointer	pointer
==	O
'-'	O
)	O
{	O
bfd_boolean	int
force_reset	int
=	O
*	O
input_line_pointer	pointer
==	O
'-'	O
;	O
value	long
=	O
get_absolute_expression	function
(	O
)	O
;	O
if	O
(	O
value	long
!=	O
0	int
)	O
{	O
as_bad	function
(	O
_	O
(	O
"numeric view can only be asserted to zero"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
force_reset	int
&&	O
force_reset_view	pointer
)	O
sym	pointer
=	O
force_reset_view	pointer
;	O
else	O
{	O
sym	pointer
=	O
symbol_temp_new	function
(	O
absolute_section	O
,	O
value	long
,	O
&	O
zero_address_frag	struct
)	O
;	O
if	O
(	O
force_reset	int
)	O
force_reset_view	pointer
=	O
sym	pointer
;	O
}	O
}	O
else	O
{	O
char	O
*	O
name	pointer
=	O
read_symbol_name	function
(	O
)	O
;	O
if	O
(	O
!	O
name	pointer
)	O
return	O
;	O
sym	pointer
=	O
symbol_find_or_make	function
(	O
name	pointer
)	O
;	O
if	O
(	O
S_IS_DEFINED	function
(	O
sym	pointer
)	O
||	O
symbol_equated_p	function
(	O
sym	pointer
)	O
)	O
{	O
if	O
(	O
S_IS_VOLATILE	function
(	O
sym	pointer
)	O
)	O
sym	pointer
=	O
symbol_clone	function
(	O
sym	pointer
,	O
1	int
)	O
;	O
else	O
if	O
(	O
!	O
S_CAN_BE_REDEFINED	function
(	O
sym	pointer
)	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"symbol `%s' is already defined"	pointer
)	O
,	O
name	pointer
)	O
;	O
return	O
;	O
}	O
}	O
S_SET_SEGMENT	function
(	O
sym	pointer
,	O
undefined_section	O
)	O
;	O
S_SET_VALUE	function
(	O
sym	pointer
,	O
0	int
)	O
;	O
symbol_set_frag	function
(	O
sym	pointer
,	O
&	O
zero_address_frag	struct
)	O
;	O
}	O
current	struct
.	O
view	pointer
=	O
sym	pointer
;	O
}	O
else	O
{	O
as_bad	function
(	O
_	O
(	O
"unknown .loc sub-directive `%s'"	pointer
)	O
,	O
p	pointer
)	O
;	O
(	O
void	O
)	O
restore_line_pointer	function
(	O
c	struct
)	O
;	O
return	O
;	O
}	O
SKIP_WHITESPACE_AFTER_NAME	O
(	O
)	O
;	O
}	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
dwarf2_loc_directive_seen	int
=	O
TRUE	int
;	O
debug_type	enum
=	O
DEBUG_NONE	int
;	O
if	O
(	O
current	struct
.	O
view	pointer
)	O
dwarf2_emit_insn	function
(	O
0	int
)	O
;	O
}	O
void	O
dwarf2_directive_loc_mark_labels	function
(	O
int	O
dummy	int
ATTRIBUTE_UNUSED	O
)	O
{	O
offsetT	long
value	long
=	O
get_absolute_expression	function
(	O
)	O
;	O
if	O
(	O
value	long
!=	O
0	int
&&	O
value	long
!=	O
1	int
)	O
{	O
as_bad	function
(	O
_	O
(	O
"expected 0 or 1"	pointer
)	O
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
}	O
else	O
{	O
dwarf2_loc_mark_labels	int
=	O
value	long
!=	O
0	int
;	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
}	O
}	O
static	O
struct	O
frag	struct
*	O
first_frag_for_seg	function
(	O
segT	pointer
seg	pointer
)	O
{	O
return	O
seg_info	O
(	O
seg	pointer
)	O
->	O
frchainP	pointer
->	O
frch_root	pointer
;	O
}	O
static	O
struct	O
frag	struct
*	O
last_frag_for_seg	function
(	O
segT	pointer
seg	pointer
)	O
{	O
frchainS	struct
*	O
f	pointer
=	O
seg_info	O
(	O
seg	pointer
)	O
->	O
frchainP	pointer
;	O
while	O
(	O
f	pointer
->	O
frch_next	pointer
!=	O
NULL	O
)	O
f	pointer
=	O
f	pointer
->	O
frch_next	pointer
;	O
return	O
f	pointer
->	O
frch_last	pointer
;	O
}	O
static	O
inline	O
void	O
out_byte	function
(	O
int	O
byte	int
)	O
{	O
FRAG_APPEND_1_CHAR	O
(	O
byte	int
)	O
;	O
}	O
static	O
inline	O
void	O
out_opcode	function
(	O
int	O
opc	int
)	O
{	O
out_byte	function
(	O
opc	int
)	O
;	O
}	O
static	O
inline	O
void	O
out_two	function
(	O
int	O
data	pointer
)	O
{	O
md_number_to_chars	O
(	O
frag_more	function
(	O
2	int
)	O
,	O
data	pointer
,	O
2	int
)	O
;	O
}	O
static	O
inline	O
void	O
out_four	function
(	O
int	O
data	pointer
)	O
{	O
md_number_to_chars	O
(	O
frag_more	function
(	O
4	int
)	O
,	O
data	pointer
,	O
4	int
)	O
;	O
}	O
static	O
void	O
out_uleb128	function
(	O
addressT	long
value	long
)	O
{	O
output_leb128	function
(	O
frag_more	function
(	O
sizeof_leb128	function
(	O
value	long
,	O
0	int
)	O
)	O
,	O
value	long
,	O
0	int
)	O
;	O
}	O
static	O
void	O
out_leb128	function
(	O
addressT	long
value	long
)	O
{	O
output_leb128	function
(	O
frag_more	function
(	O
sizeof_leb128	function
(	O
value	long
,	O
1	int
)	O
)	O
,	O
value	long
,	O
1	int
)	O
;	O
}	O
static	O
inline	O
void	O
out_abbrev	function
(	O
int	O
name	pointer
,	O
int	O
form	int
)	O
{	O
out_uleb128	function
(	O
name	pointer
)	O
;	O
out_uleb128	function
(	O
form	int
)	O
;	O
}	O
static	O
offsetT	long
get_frag_fix	function
(	O
fragS	struct
*	O
frag	struct
,	O
segT	pointer
seg	pointer
)	O
{	O
frchainS	struct
*	O
fr	pointer
;	O
if	O
(	O
frag	struct
->	O
fr_next	pointer
)	O
return	O
frag	struct
->	O
fr_fix	long
;	O
for	O
(	O
fr	pointer
=	O
seg_info	O
(	O
seg	pointer
)	O
->	O
frchainP	pointer
;	O
fr	pointer
;	O
fr	pointer
=	O
fr	pointer
->	O
frch_next	pointer
)	O
if	O
(	O
fr	pointer
->	O
frch_last	pointer
==	O
frag	struct
)	O
return	O
(	O
char	O
*	O
)	O
obstack_next_free	O
(	O
&	O
fr	pointer
->	O
frch_obstack	struct
)	O
-	O
frag	struct
->	O
fr_literal	array
;	O
abort	function
(	O
)	O
;	O
}	O
static	O
void	O
out_set_addr	function
(	O
symbolS	struct
*	O
sym	pointer
)	O
{	O
expressionS	struct
exp	pointer
;	O
memset	function
(	O
&	O
exp	pointer
,	O
0	int
,	O
sizeof	O
exp	pointer
)	O
;	O
out_opcode	function
(	O
DW_LNS_extended_op	int
)	O
;	O
out_uleb128	function
(	O
sizeof_address	int
+	O
1	int
)	O
;	O
out_opcode	function
(	O
DW_LNE_set_address	int
)	O
;	O
exp	pointer
.	O
X_op	enum
=	O
O_symbol	int
;	O
exp	pointer
.	O
X_add_symbol	pointer
=	O
sym	pointer
;	O
exp	pointer
.	O
X_add_number	long
=	O
0	int
;	O
emit_expr	function
(	O
&	O
exp	pointer
,	O
sizeof_address	int
)	O
;	O
}	O
static	O
void	O
scale_addr_delta	function
(	O
addressT	long
*	O
)	O
;	O
static	O
void	O
scale_addr_delta	function
(	O
addressT	long
*	O
addr_delta	pointer
)	O
{	O
static	O
int	O
printed_this	int
=	O
0	int
;	O
if	O
(	O
DWARF2_LINE_MIN_INSN_LENGTH	int
>	O
1	int
)	O
{	O
if	O
(	O
*	O
addr_delta	pointer
%	O
DWARF2_LINE_MIN_INSN_LENGTH	int
!=	O
0	int
&&	O
!	O
printed_this	int
)	O
{	O
as_bad	function
(	O
"unaligned opcodes detected in executable segment"	pointer
)	O
;	O
printed_this	int
=	O
1	int
;	O
}	O
*	O
addr_delta	pointer
/=	O
DWARF2_LINE_MIN_INSN_LENGTH	int
;	O
}	O
}	O
static	O
int	O
size_inc_line_addr	function
(	O
int	O
line_delta	int
,	O
addressT	long
addr_delta	pointer
)	O
{	O
unsigned	O
int	O
tmp	int
,	O
opcode	pointer
;	O
int	O
len	long
=	O
0	int
;	O
scale_addr_delta	function
(	O
&	O
addr_delta	pointer
)	O
;	O
if	O
(	O
line_delta	int
==	O
INT_MAX	O
)	O
{	O
if	O
(	O
addr_delta	pointer
==	O
MAX_SPECIAL_ADDR_DELTA	O
)	O
len	long
=	O
1	int
;	O
else	O
if	O
(	O
addr_delta	pointer
)	O
len	long
=	O
1	int
+	O
sizeof_leb128	function
(	O
addr_delta	pointer
,	O
0	int
)	O
;	O
return	O
len	long
+	O
3	int
;	O
}	O
tmp	int
=	O
line_delta	int
-	O
DWARF2_LINE_BASE	O
;	O
if	O
(	O
tmp	int
>=	O
DWARF2_LINE_RANGE	int
)	O
{	O
len	long
=	O
1	int
+	O
sizeof_leb128	function
(	O
line_delta	int
,	O
1	int
)	O
;	O
line_delta	int
=	O
0	int
;	O
tmp	int
=	O
0	int
-	O
DWARF2_LINE_BASE	O
;	O
}	O
tmp	int
+=	O
DWARF2_LINE_OPCODE_BASE	int
;	O
if	O
(	O
addr_delta	pointer
<	O
256	int
+	O
MAX_SPECIAL_ADDR_DELTA	O
)	O
{	O
opcode	pointer
=	O
tmp	int
+	O
addr_delta	pointer
*	O
DWARF2_LINE_RANGE	int
;	O
if	O
(	O
opcode	pointer
<=	O
255	int
)	O
return	O
len	long
+	O
1	int
;	O
opcode	pointer
=	O
tmp	int
+	O
(	O
addr_delta	pointer
-	O
MAX_SPECIAL_ADDR_DELTA	O
)	O
*	O
DWARF2_LINE_RANGE	int
;	O
if	O
(	O
opcode	pointer
<=	O
255	int
)	O
return	O
len	long
+	O
2	int
;	O
}	O
len	long
+=	O
1	int
+	O
sizeof_leb128	function
(	O
addr_delta	pointer
,	O
0	int
)	O
;	O
len	long
+=	O
1	int
;	O
return	O
len	long
;	O
}	O
static	O
void	O
emit_inc_line_addr	function
(	O
int	O
line_delta	int
,	O
addressT	long
addr_delta	pointer
,	O
char	O
*	O
p	pointer
,	O
int	O
len	long
)	O
{	O
unsigned	O
int	O
tmp	int
,	O
opcode	pointer
;	O
int	O
need_copy	int
=	O
0	int
;	O
char	O
*	O
end	pointer
=	O
p	pointer
+	O
len	long
;	O
gas_assert	O
(	O
(	O
offsetT	long
)	O
addr_delta	pointer
>=	O
0	int
)	O
;	O
scale_addr_delta	function
(	O
&	O
addr_delta	pointer
)	O
;	O
if	O
(	O
line_delta	int
==	O
INT_MAX	O
)	O
{	O
if	O
(	O
addr_delta	pointer
==	O
MAX_SPECIAL_ADDR_DELTA	O
)	O
*	O
p	pointer
++	O
=	O
DW_LNS_const_add_pc	int
;	O
else	O
if	O
(	O
addr_delta	pointer
)	O
{	O
*	O
p	pointer
++	O
=	O
DW_LNS_advance_pc	int
;	O
p	pointer
+=	O
output_leb128	function
(	O
p	pointer
,	O
addr_delta	pointer
,	O
0	int
)	O
;	O
}	O
*	O
p	pointer
++	O
=	O
DW_LNS_extended_op	int
;	O
*	O
p	pointer
++	O
=	O
1	int
;	O
*	O
p	pointer
++	O
=	O
DW_LNE_end_sequence	int
;	O
goto	O
done	O
;	O
}	O
tmp	int
=	O
line_delta	int
-	O
DWARF2_LINE_BASE	O
;	O
if	O
(	O
tmp	int
>=	O
DWARF2_LINE_RANGE	int
)	O
{	O
*	O
p	pointer
++	O
=	O
DW_LNS_advance_line	int
;	O
p	pointer
+=	O
output_leb128	function
(	O
p	pointer
,	O
line_delta	int
,	O
1	int
)	O
;	O
line_delta	int
=	O
0	int
;	O
tmp	int
=	O
0	int
-	O
DWARF2_LINE_BASE	O
;	O
need_copy	int
=	O
1	int
;	O
}	O
if	O
(	O
line_delta	int
==	O
0	int
&&	O
addr_delta	pointer
==	O
0	int
)	O
{	O
*	O
p	pointer
++	O
=	O
DW_LNS_copy	int
;	O
goto	O
done	O
;	O
}	O
tmp	int
+=	O
DWARF2_LINE_OPCODE_BASE	int
;	O
if	O
(	O
addr_delta	pointer
<	O
256	int
+	O
MAX_SPECIAL_ADDR_DELTA	O
)	O
{	O
opcode	pointer
=	O
tmp	int
+	O
addr_delta	pointer
*	O
DWARF2_LINE_RANGE	int
;	O
if	O
(	O
opcode	pointer
<=	O
255	int
)	O
{	O
*	O
p	pointer
++	O
=	O
opcode	pointer
;	O
goto	O
done	O
;	O
}	O
opcode	pointer
=	O
tmp	int
+	O
(	O
addr_delta	pointer
-	O
MAX_SPECIAL_ADDR_DELTA	O
)	O
*	O
DWARF2_LINE_RANGE	int
;	O
if	O
(	O
opcode	pointer
<=	O
255	int
)	O
{	O
*	O
p	pointer
++	O
=	O
DW_LNS_const_add_pc	int
;	O
*	O
p	pointer
++	O
=	O
opcode	pointer
;	O
goto	O
done	O
;	O
}	O
}	O
*	O
p	pointer
++	O
=	O
DW_LNS_advance_pc	int
;	O
p	pointer
+=	O
output_leb128	function
(	O
p	pointer
,	O
addr_delta	pointer
,	O
0	int
)	O
;	O
if	O
(	O
need_copy	int
)	O
*	O
p	pointer
++	O
=	O
DW_LNS_copy	int
;	O
else	O
*	O
p	pointer
++	O
=	O
tmp	int
;	O
done	O
:	O
gas_assert	O
(	O
p	pointer
==	O
end	pointer
)	O
;	O
}	O
static	O
void	O
out_inc_line_addr	function
(	O
int	O
line_delta	int
,	O
addressT	long
addr_delta	pointer
)	O
{	O
int	O
len	long
=	O
size_inc_line_addr	function
(	O
line_delta	int
,	O
addr_delta	pointer
)	O
;	O
emit_inc_line_addr	function
(	O
line_delta	int
,	O
addr_delta	pointer
,	O
frag_more	function
(	O
len	long
)	O
,	O
len	long
)	O
;	O
}	O
static	O
int	O
size_fixed_inc_line_addr	function
(	O
int	O
line_delta	int
,	O
addressT	long
addr_delta	pointer
)	O
{	O
int	O
len	long
=	O
0	int
;	O
if	O
(	O
line_delta	int
!=	O
INT_MAX	O
)	O
len	long
=	O
1	int
+	O
sizeof_leb128	function
(	O
line_delta	int
,	O
1	int
)	O
;	O
if	O
(	O
addr_delta	pointer
>	O
ADDR_DELTA_LIMIT	int
)	O
{	O
len	long
+=	O
1	int
+	O
sizeof_leb128	function
(	O
sizeof_address	int
+	O
1	int
,	O
0	int
)	O
;	O
len	long
+=	O
1	int
+	O
sizeof_address	int
;	O
}	O
else	O
len	long
+=	O
3	int
;	O
if	O
(	O
line_delta	int
==	O
INT_MAX	O
)	O
len	long
+=	O
3	int
;	O
else	O
len	long
+=	O
1	int
;	O
return	O
len	long
;	O
}	O
static	O
void	O
emit_fixed_inc_line_addr	function
(	O
int	O
line_delta	int
,	O
addressT	long
addr_delta	pointer
,	O
fragS	struct
*	O
frag	struct
,	O
char	O
*	O
p	pointer
,	O
int	O
len	long
)	O
{	O
expressionS	struct
*	O
pexp	pointer
;	O
char	O
*	O
end	pointer
=	O
p	pointer
+	O
len	long
;	O
gas_assert	O
(	O
(	O
offsetT	long
)	O
addr_delta	pointer
>=	O
0	int
)	O
;	O
gas_assert	O
(	O
len	long
==	O
size_fixed_inc_line_addr	function
(	O
line_delta	int
,	O
addr_delta	pointer
)	O
)	O
;	O
if	O
(	O
line_delta	int
!=	O
INT_MAX	O
)	O
{	O
*	O
p	pointer
++	O
=	O
DW_LNS_advance_line	int
;	O
p	pointer
+=	O
output_leb128	function
(	O
p	pointer
,	O
line_delta	int
,	O
1	int
)	O
;	O
}	O
pexp	pointer
=	O
symbol_get_value_expression	function
(	O
frag	struct
->	O
fr_symbol	pointer
)	O
;	O
if	O
(	O
addr_delta	pointer
>	O
ADDR_DELTA_LIMIT	int
)	O
{	O
symbolS	struct
*	O
to_sym	pointer
;	O
expressionS	struct
exp	pointer
;	O
memset	function
(	O
&	O
exp	pointer
,	O
0	int
,	O
sizeof	O
exp	pointer
)	O
;	O
gas_assert	O
(	O
pexp	pointer
->	O
X_op	enum
==	O
O_subtract	int
)	O
;	O
to_sym	pointer
=	O
pexp	pointer
->	O
X_add_symbol	pointer
;	O
*	O
p	pointer
++	O
=	O
DW_LNS_extended_op	int
;	O
p	pointer
+=	O
output_leb128	function
(	O
p	pointer
,	O
sizeof_address	int
+	O
1	int
,	O
0	int
)	O
;	O
*	O
p	pointer
++	O
=	O
DW_LNE_set_address	int
;	O
exp	pointer
.	O
X_op	enum
=	O
O_symbol	int
;	O
exp	pointer
.	O
X_add_symbol	pointer
=	O
to_sym	pointer
;	O
exp	pointer
.	O
X_add_number	long
=	O
0	int
;	O
emit_expr_fix	function
(	O
&	O
exp	pointer
,	O
sizeof_address	int
,	O
frag	struct
,	O
p	pointer
,	O
TC_PARSE_CONS_RETURN_NONE	O
)	O
;	O
p	pointer
+=	O
sizeof_address	int
;	O
}	O
else	O
{	O
*	O
p	pointer
++	O
=	O
DW_LNS_fixed_advance_pc	int
;	O
emit_expr_fix	function
(	O
pexp	pointer
,	O
2	int
,	O
frag	struct
,	O
p	pointer
,	O
TC_PARSE_CONS_RETURN_NONE	O
)	O
;	O
p	pointer
+=	O
2	int
;	O
}	O
if	O
(	O
line_delta	int
==	O
INT_MAX	O
)	O
{	O
*	O
p	pointer
++	O
=	O
DW_LNS_extended_op	int
;	O
*	O
p	pointer
++	O
=	O
1	int
;	O
*	O
p	pointer
++	O
=	O
DW_LNE_end_sequence	int
;	O
}	O
else	O
*	O
p	pointer
++	O
=	O
DW_LNS_copy	int
;	O
gas_assert	O
(	O
p	pointer
==	O
end	pointer
)	O
;	O
}	O
static	O
void	O
relax_inc_line_addr	function
(	O
int	O
line_delta	int
,	O
symbolS	struct
*	O
to_sym	pointer
,	O
symbolS	struct
*	O
from_sym	pointer
)	O
{	O
expressionS	struct
exp	pointer
;	O
int	O
max_chars	long
;	O
memset	function
(	O
&	O
exp	pointer
,	O
0	int
,	O
sizeof	O
exp	pointer
)	O
;	O
exp	pointer
.	O
X_op	enum
=	O
O_subtract	int
;	O
exp	pointer
.	O
X_add_symbol	pointer
=	O
to_sym	pointer
;	O
exp	pointer
.	O
X_op_symbol	pointer
=	O
from_sym	pointer
;	O
exp	pointer
.	O
X_add_number	long
=	O
0	int
;	O
if	O
(	O
DWARF2_USE_FIXED_ADVANCE_PC	O
)	O
max_chars	long
=	O
size_fixed_inc_line_addr	function
(	O
line_delta	int
,	O
-	O
DWARF2_LINE_MIN_INSN_LENGTH	int
)	O
;	O
else	O
max_chars	long
=	O
size_inc_line_addr	function
(	O
line_delta	int
,	O
-	O
DWARF2_LINE_MIN_INSN_LENGTH	int
)	O
;	O
frag_var	function
(	O
rs_dwarf2dbg	int
,	O
max_chars	long
,	O
max_chars	long
,	O
1	int
,	O
make_expr_symbol	function
(	O
&	O
exp	pointer
)	O
,	O
line_delta	int
,	O
NULL	O
)	O
;	O
}	O
int	O
dwarf2dbg_estimate_size_before_relax	function
(	O
fragS	struct
*	O
frag	struct
)	O
{	O
offsetT	long
addr_delta	pointer
;	O
int	O
size	int
;	O
addr_delta	pointer
=	O
resolve_symbol_value	function
(	O
frag	struct
->	O
fr_symbol	pointer
)	O
;	O
if	O
(	O
DWARF2_USE_FIXED_ADVANCE_PC	O
)	O
size	int
=	O
size_fixed_inc_line_addr	function
(	O
frag	struct
->	O
fr_offset	long
,	O
addr_delta	pointer
)	O
;	O
else	O
size	int
=	O
size_inc_line_addr	function
(	O
frag	struct
->	O
fr_offset	long
,	O
addr_delta	pointer
)	O
;	O
frag	struct
->	O
fr_subtype	int
=	O
size	int
;	O
return	O
size	int
;	O
}	O
int	O
dwarf2dbg_relax_frag	function
(	O
fragS	struct
*	O
frag	struct
)	O
{	O
int	O
old_size	int
,	O
new_size	int
;	O
old_size	int
=	O
frag	struct
->	O
fr_subtype	int
;	O
new_size	int
=	O
dwarf2dbg_estimate_size_before_relax	function
(	O
frag	struct
)	O
;	O
return	O
new_size	int
-	O
old_size	int
;	O
}	O
void	O
dwarf2dbg_convert_frag	function
(	O
fragS	struct
*	O
frag	struct
)	O
{	O
offsetT	long
addr_diff	long
;	O
if	O
(	O
DWARF2_USE_FIXED_ADVANCE_PC	O
)	O
{	O
int	O
saved_finalize_syms	int
=	O
finalize_syms	int
;	O
finalize_syms	int
=	O
0	int
;	O
addr_diff	long
=	O
resolve_symbol_value	function
(	O
frag	struct
->	O
fr_symbol	pointer
)	O
;	O
finalize_syms	int
=	O
saved_finalize_syms	int
;	O
}	O
else	O
addr_diff	long
=	O
resolve_symbol_value	function
(	O
frag	struct
->	O
fr_symbol	pointer
)	O
;	O
gas_assert	O
(	O
frag	struct
->	O
fr_var	long
>=	O
(	O
int	O
)	O
frag	struct
->	O
fr_subtype	int
)	O
;	O
if	O
(	O
DWARF2_USE_FIXED_ADVANCE_PC	O
)	O
emit_fixed_inc_line_addr	function
(	O
frag	struct
->	O
fr_offset	long
,	O
addr_diff	long
,	O
frag	struct
,	O
frag	struct
->	O
fr_literal	array
+	O
frag	struct
->	O
fr_fix	long
,	O
frag	struct
->	O
fr_subtype	int
)	O
;	O
else	O
emit_inc_line_addr	function
(	O
frag	struct
->	O
fr_offset	long
,	O
addr_diff	long
,	O
frag	struct
->	O
fr_literal	array
+	O
frag	struct
->	O
fr_fix	long
,	O
frag	struct
->	O
fr_subtype	int
)	O
;	O
frag	struct
->	O
fr_fix	long
+=	O
frag	struct
->	O
fr_subtype	int
;	O
frag	struct
->	O
fr_type	enum
=	O
rs_fill	int
;	O
frag	struct
->	O
fr_var	long
=	O
0	int
;	O
frag	struct
->	O
fr_offset	long
=	O
0	int
;	O
}	O
static	O
void	O
process_entries	function
(	O
segT	pointer
seg	pointer
,	O
struct	O
line_entry	struct
*	O
e	pointer
)	O
{	O
unsigned	O
filenum	int
=	O
1	int
;	O
unsigned	O
line	int
=	O
1	int
;	O
unsigned	O
column	int
=	O
0	int
;	O
unsigned	O
isa	enum
=	O
0	int
;	O
unsigned	O
flags	int
=	O
DWARF2_LINE_DEFAULT_IS_STMT	int
?	O
DWARF2_FLAG_IS_STMT	O
:	O
0	int
;	O
fragS	struct
*	O
last_frag	pointer
=	O
NULL	O
,	O
*	O
frag	struct
;	O
addressT	long
last_frag_ofs	long
=	O
0	int
,	O
frag_ofs	long
;	O
symbolS	struct
*	O
last_lab	pointer
=	O
NULL	O
,	O
*	O
lab	pointer
;	O
struct	O
line_entry	struct
*	O
next	pointer
;	O
if	O
(	O
flag_dwarf_sections	int
)	O
{	O
char	O
*	O
name	pointer
;	O
const	O
char	O
*	O
sec_name	pointer
;	O
sec_name	pointer
=	O
bfd_section_name	function
(	O
seg	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
sec_name	pointer
,	O
".text"	pointer
)	O
!=	O
0	int
)	O
{	O
name	pointer
=	O
concat	function
(	O
".debug_line"	pointer
,	O
sec_name	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
subseg_set	function
(	O
subseg_get	function
(	O
name	pointer
,	O
FALSE	int
)	O
,	O
0	int
)	O
;	O
}	O
else	O
subseg_set	function
(	O
subseg_get	function
(	O
".debug_line"	pointer
,	O
FALSE	int
)	O
,	O
0	int
)	O
;	O
}	O
do	O
{	O
int	O
line_delta	int
;	O
if	O
(	O
filenum	int
!=	O
e	pointer
->	O
loc	pointer
.	O
filenum	int
)	O
{	O
filenum	int
=	O
e	pointer
->	O
loc	pointer
.	O
filenum	int
;	O
out_opcode	function
(	O
DW_LNS_set_file	int
)	O
;	O
out_uleb128	function
(	O
filenum	int
)	O
;	O
}	O
if	O
(	O
column	int
!=	O
e	pointer
->	O
loc	pointer
.	O
column	int
)	O
{	O
column	int
=	O
e	pointer
->	O
loc	pointer
.	O
column	int
;	O
out_opcode	function
(	O
DW_LNS_set_column	int
)	O
;	O
out_uleb128	function
(	O
column	int
)	O
;	O
}	O
if	O
(	O
e	pointer
->	O
loc	pointer
.	O
discriminator	int
!=	O
0	int
)	O
{	O
out_opcode	function
(	O
DW_LNS_extended_op	int
)	O
;	O
out_leb128	function
(	O
1	int
+	O
sizeof_leb128	function
(	O
e	pointer
->	O
loc	pointer
.	O
discriminator	int
,	O
0	int
)	O
)	O
;	O
out_opcode	function
(	O
DW_LNE_set_discriminator	int
)	O
;	O
out_uleb128	function
(	O
e	pointer
->	O
loc	pointer
.	O
discriminator	int
)	O
;	O
}	O
if	O
(	O
isa	enum
!=	O
e	pointer
->	O
loc	pointer
.	O
isa	enum
)	O
{	O
isa	enum
=	O
e	pointer
->	O
loc	pointer
.	O
isa	enum
;	O
out_opcode	function
(	O
DW_LNS_set_isa	int
)	O
;	O
out_uleb128	function
(	O
isa	enum
)	O
;	O
}	O
if	O
(	O
(	O
e	pointer
->	O
loc	pointer
.	O
flags	int
^	O
flags	int
)	O
&	O
DWARF2_FLAG_IS_STMT	O
)	O
{	O
flags	int
=	O
e	pointer
->	O
loc	pointer
.	O
flags	int
;	O
out_opcode	function
(	O
DW_LNS_negate_stmt	int
)	O
;	O
}	O
if	O
(	O
e	pointer
->	O
loc	pointer
.	O
flags	int
&	O
DWARF2_FLAG_BASIC_BLOCK	O
)	O
out_opcode	function
(	O
DW_LNS_set_basic_block	int
)	O
;	O
if	O
(	O
e	pointer
->	O
loc	pointer
.	O
flags	int
&	O
DWARF2_FLAG_PROLOGUE_END	O
)	O
out_opcode	function
(	O
DW_LNS_set_prologue_end	int
)	O
;	O
if	O
(	O
e	pointer
->	O
loc	pointer
.	O
flags	int
&	O
DWARF2_FLAG_EPILOGUE_BEGIN	O
)	O
out_opcode	function
(	O
DW_LNS_set_epilogue_begin	int
)	O
;	O
line_delta	int
=	O
e	pointer
->	O
loc	pointer
.	O
line	int
-	O
line	int
;	O
lab	pointer
=	O
e	pointer
->	O
label	long
;	O
frag	struct
=	O
symbol_get_frag	function
(	O
lab	pointer
)	O
;	O
frag_ofs	long
=	O
S_GET_VALUE	function
(	O
lab	pointer
)	O
;	O
if	O
(	O
last_frag	pointer
==	O
NULL	O
||	O
(	O
e	pointer
->	O
loc	pointer
.	O
view	pointer
==	O
force_reset_view	pointer
&&	O
force_reset_view	pointer
&&	O
(	O
frag	struct
==	O
last_frag	pointer
?	O
(	O
last_frag_ofs	long
==	O
frag_ofs	long
)	O
:	O
(	O
frag_ofs	long
==	O
0	int
&&	O
(	O
(	O
offsetT	long
)	O
last_frag_ofs	long
>=	O
get_frag_fix	function
(	O
last_frag	pointer
,	O
seg	pointer
)	O
)	O
)	O
)	O
)	O
)	O
{	O
out_set_addr	function
(	O
lab	pointer
)	O
;	O
out_inc_line_addr	function
(	O
line_delta	int
,	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
frag	struct
==	O
last_frag	pointer
&&	O
!	O
DWARF2_USE_FIXED_ADVANCE_PC	O
)	O
out_inc_line_addr	function
(	O
line_delta	int
,	O
frag_ofs	long
-	O
last_frag_ofs	long
)	O
;	O
else	O
relax_inc_line_addr	function
(	O
line_delta	int
,	O
lab	pointer
,	O
last_lab	pointer
)	O
;	O
line	int
=	O
e	pointer
->	O
loc	pointer
.	O
line	int
;	O
last_lab	pointer
=	O
lab	pointer
;	O
last_frag	pointer
=	O
frag	struct
;	O
last_frag_ofs	long
=	O
frag_ofs	long
;	O
next	pointer
=	O
e	pointer
->	O
next	pointer
;	O
free	function
(	O
e	pointer
)	O
;	O
e	pointer
=	O
next	pointer
;	O
}	O
while	O
(	O
e	pointer
)	O
;	O
frag	struct
=	O
last_frag_for_seg	function
(	O
seg	pointer
)	O
;	O
frag_ofs	long
=	O
get_frag_fix	function
(	O
frag	struct
,	O
seg	pointer
)	O
;	O
if	O
(	O
frag	struct
==	O
last_frag	pointer
&&	O
!	O
DWARF2_USE_FIXED_ADVANCE_PC	O
)	O
out_inc_line_addr	function
(	O
INT_MAX	O
,	O
frag_ofs	long
-	O
last_frag_ofs	long
)	O
;	O
else	O
{	O
lab	pointer
=	O
symbol_temp_new	function
(	O
seg	pointer
,	O
frag_ofs	long
,	O
frag	struct
)	O
;	O
relax_inc_line_addr	function
(	O
INT_MAX	O
,	O
lab	pointer
,	O
last_lab	pointer
)	O
;	O
}	O
}	O
static	O
void	O
out_file_list	function
(	O
void	O
)	O
{	O
size_t	long
size	int
;	O
const	O
char	O
*	O
dir	pointer
;	O
char	O
*	O
cp	pointer
;	O
unsigned	O
int	O
i	pointer
;	O
for	O
(	O
i	pointer
=	O
1	int
;	O
i	pointer
<	O
dirs_in_use	int
;	O
++	O
i	pointer
)	O
{	O
dir	pointer
=	O
remap_debug_filename	function
(	O
dirs	pointer
[	O
i	pointer
]	O
)	O
;	O
size	int
=	O
strlen	function
(	O
dir	pointer
)	O
+	O
1	int
;	O
cp	pointer
=	O
frag_more	function
(	O
size	int
)	O
;	O
memcpy	function
(	O
cp	pointer
,	O
dir	pointer
,	O
size	int
)	O
;	O
}	O
out_byte	function
(	O
'\0'	O
)	O
;	O
for	O
(	O
i	pointer
=	O
1	int
;	O
i	pointer
<	O
files_in_use	int
;	O
++	O
i	pointer
)	O
{	O
const	O
char	O
*	O
fullfilename	pointer
;	O
if	O
(	O
files	pointer
[	O
i	pointer
]	O
.	O
filename	pointer
==	O
NULL	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"unassigned file number %ld"	pointer
)	O
,	O
(	O
long	O
)	O
i	pointer
)	O
;	O
files	pointer
[	O
i	pointer
]	O
.	O
filename	pointer
=	O
""	pointer
;	O
continue	O
;	O
}	O
fullfilename	pointer
=	O
DWARF2_FILE_NAME	O
(	O
files	pointer
[	O
i	pointer
]	O
.	O
filename	pointer
,	O
files	pointer
[	O
i	pointer
]	O
.	O
dir	pointer
?	O
dirs	pointer
[	O
files	pointer
[	O
i	pointer
]	O
.	O
dir	pointer
]	O
:	O
""	pointer
)	O
;	O
size	int
=	O
strlen	function
(	O
fullfilename	pointer
)	O
+	O
1	int
;	O
cp	pointer
=	O
frag_more	function
(	O
size	int
)	O
;	O
memcpy	function
(	O
cp	pointer
,	O
fullfilename	pointer
,	O
size	int
)	O
;	O
out_uleb128	function
(	O
files	pointer
[	O
i	pointer
]	O
.	O
dir	pointer
)	O
;	O
out_uleb128	function
(	O
DWARF2_FILE_TIME_NAME	int
(	O
files	pointer
[	O
i	pointer
]	O
.	O
filename	pointer
,	O
files	pointer
[	O
i	pointer
]	O
.	O
dir	pointer
?	O
dirs	pointer
[	O
files	pointer
[	O
i	pointer
]	O
.	O
dir	pointer
]	O
:	O
""	pointer
)	O
)	O
;	O
out_uleb128	function
(	O
DWARF2_FILE_SIZE_NAME	int
(	O
files	pointer
[	O
i	pointer
]	O
.	O
filename	pointer
,	O
files	pointer
[	O
i	pointer
]	O
.	O
dir	pointer
?	O
dirs	pointer
[	O
files	pointer
[	O
i	pointer
]	O
.	O
dir	pointer
]	O
:	O
""	pointer
)	O
)	O
;	O
}	O
out_byte	function
(	O
0	int
)	O
;	O
}	O
static	O
int	O
out_header	function
(	O
asection	struct
*	O
sec	pointer
,	O
expressionS	struct
*	O
exp	pointer
)	O
{	O
symbolS	struct
*	O
start_sym	pointer
;	O
symbolS	struct
*	O
end_sym	pointer
;	O
subseg_set	function
(	O
sec	pointer
,	O
0	int
)	O
;	O
if	O
(	O
flag_dwarf_sections	int
)	O
{	O
frag_now_fix	function
(	O
)	O
;	O
start_sym	pointer
=	O
symbol_make	function
(	O
".Ldebug_line_start"	pointer
)	O
;	O
end_sym	pointer
=	O
symbol_make	function
(	O
".Ldebug_line_end"	pointer
)	O
;	O
symbol_set_value_now	function
(	O
start_sym	pointer
)	O
;	O
}	O
else	O
{	O
start_sym	pointer
=	O
symbol_temp_new_now_octets	function
(	O
)	O
;	O
end_sym	pointer
=	O
symbol_temp_make	function
(	O
)	O
;	O
}	O
exp	pointer
->	O
X_op	enum
=	O
O_subtract	int
;	O
exp	pointer
->	O
X_add_symbol	pointer
=	O
end_sym	pointer
;	O
exp	pointer
->	O
X_op_symbol	pointer
=	O
start_sym	pointer
;	O
switch	O
(	O
DWARF2_FORMAT	O
(	O
sec	pointer
)	O
)	O
{	O
case	O
dwarf2_format_32bit	int
:	O
exp	pointer
->	O
X_add_number	long
=	O
-	O
4	int
;	O
emit_expr	function
(	O
exp	pointer
,	O
4	int
)	O
;	O
return	O
4	int
;	O
case	O
dwarf2_format_64bit	int
:	O
exp	pointer
->	O
X_add_number	long
=	O
-	O
12	int
;	O
out_four	function
(	O
-	O
1	int
)	O
;	O
emit_expr	function
(	O
exp	pointer
,	O
8	int
)	O
;	O
return	O
8	int
;	O
case	O
dwarf2_format_64bit_irix	int
:	O
exp	pointer
->	O
X_add_number	long
=	O
-	O
8	int
;	O
emit_expr	function
(	O
exp	pointer
,	O
8	int
)	O
;	O
return	O
8	int
;	O
}	O
as_fatal	function
(	O
_	O
(	O
"internal error: unknown dwarf2 format"	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
out_debug_line	function
(	O
segT	pointer
line_seg	struct
)	O
{	O
expressionS	struct
exp	pointer
;	O
symbolS	struct
*	O
prologue_start	pointer
,	O
*	O
prologue_end	pointer
;	O
symbolS	struct
*	O
line_end	pointer
;	O
struct	O
line_seg	struct
*	O
s	pointer
;	O
int	O
sizeof_offset	int
;	O
memset	function
(	O
&	O
exp	pointer
,	O
0	int
,	O
sizeof	O
exp	pointer
)	O
;	O
sizeof_offset	int
=	O
out_header	function
(	O
line_seg	struct
,	O
&	O
exp	pointer
)	O
;	O
line_end	pointer
=	O
exp	pointer
.	O
X_add_symbol	pointer
;	O
out_two	function
(	O
DWARF2_LINE_VERSION	int
)	O
;	O
prologue_start	pointer
=	O
symbol_temp_make	function
(	O
)	O
;	O
prologue_end	pointer
=	O
symbol_temp_make	function
(	O
)	O
;	O
exp	pointer
.	O
X_op	enum
=	O
O_subtract	int
;	O
exp	pointer
.	O
X_add_symbol	pointer
=	O
prologue_end	pointer
;	O
exp	pointer
.	O
X_op_symbol	pointer
=	O
prologue_start	pointer
;	O
exp	pointer
.	O
X_add_number	long
=	O
0	int
;	O
emit_expr	function
(	O
&	O
exp	pointer
,	O
sizeof_offset	int
)	O
;	O
symbol_set_value_now	function
(	O
prologue_start	pointer
)	O
;	O
out_byte	function
(	O
DWARF2_LINE_MIN_INSN_LENGTH	int
)	O
;	O
out_byte	function
(	O
DWARF2_LINE_DEFAULT_IS_STMT	int
)	O
;	O
out_byte	function
(	O
DWARF2_LINE_BASE	O
)	O
;	O
out_byte	function
(	O
DWARF2_LINE_RANGE	int
)	O
;	O
out_byte	function
(	O
DWARF2_LINE_OPCODE_BASE	int
)	O
;	O
out_byte	function
(	O
0	int
)	O
;	O
out_byte	function
(	O
1	int
)	O
;	O
out_byte	function
(	O
1	int
)	O
;	O
out_byte	function
(	O
1	int
)	O
;	O
out_byte	function
(	O
1	int
)	O
;	O
out_byte	function
(	O
0	int
)	O
;	O
out_byte	function
(	O
0	int
)	O
;	O
out_byte	function
(	O
0	int
)	O
;	O
out_byte	function
(	O
1	int
)	O
;	O
out_byte	function
(	O
0	int
)	O
;	O
out_byte	function
(	O
0	int
)	O
;	O
out_byte	function
(	O
1	int
)	O
;	O
out_file_list	function
(	O
)	O
;	O
symbol_set_value_now	function
(	O
prologue_end	pointer
)	O
;	O
for	O
(	O
s	pointer
=	O
all_segs	pointer
;	O
s	pointer
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
if	O
(	O
SEG_NORMAL	O
(	O
s	pointer
->	O
seg	pointer
)	O
)	O
process_entries	function
(	O
s	pointer
->	O
seg	pointer
,	O
s	pointer
->	O
head	pointer
->	O
head	pointer
)	O
;	O
else	O
as_warn	function
(	O
"dwarf line number information for %s ignored"	pointer
,	O
segment_name	O
(	O
s	pointer
->	O
seg	pointer
)	O
)	O
;	O
if	O
(	O
flag_dwarf_sections	int
)	O
subseg_set	function
(	O
subseg_get	function
(	O
".debug_line_end"	pointer
,	O
FALSE	int
)	O
,	O
0	int
)	O
;	O
symbol_set_value_now	function
(	O
line_end	pointer
)	O
;	O
}	O
static	O
void	O
out_debug_ranges	function
(	O
segT	pointer
ranges_seg	pointer
)	O
{	O
unsigned	O
int	O
addr_size	int
=	O
sizeof_address	int
;	O
struct	O
line_seg	struct
*	O
s	pointer
;	O
expressionS	struct
exp	pointer
;	O
unsigned	O
int	O
i	pointer
;	O
memset	function
(	O
&	O
exp	pointer
,	O
0	int
,	O
sizeof	O
exp	pointer
)	O
;	O
subseg_set	function
(	O
ranges_seg	pointer
,	O
0	int
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
addr_size	int
;	O
i	pointer
++	O
)	O
out_byte	function
(	O
0xff	int
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
addr_size	int
;	O
i	pointer
++	O
)	O
out_byte	function
(	O
0	int
)	O
;	O
for	O
(	O
s	pointer
=	O
all_segs	pointer
;	O
s	pointer
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
{	O
fragS	struct
*	O
frag	struct
;	O
symbolS	struct
*	O
beg	pointer
,	O
*	O
end	pointer
;	O
frag	struct
=	O
first_frag_for_seg	function
(	O
s	pointer
->	O
seg	pointer
)	O
;	O
beg	pointer
=	O
symbol_temp_new	function
(	O
s	pointer
->	O
seg	pointer
,	O
0	int
,	O
frag	struct
)	O
;	O
s	pointer
->	O
text_start	pointer
=	O
beg	pointer
;	O
frag	struct
=	O
last_frag_for_seg	function
(	O
s	pointer
->	O
seg	pointer
)	O
;	O
end	pointer
=	O
symbol_temp_new	function
(	O
s	pointer
->	O
seg	pointer
,	O
get_frag_fix	function
(	O
frag	struct
,	O
s	pointer
->	O
seg	pointer
)	O
,	O
frag	struct
)	O
;	O
s	pointer
->	O
text_end	pointer
=	O
end	pointer
;	O
exp	pointer
.	O
X_op	enum
=	O
O_symbol	int
;	O
exp	pointer
.	O
X_add_symbol	pointer
=	O
beg	pointer
;	O
exp	pointer
.	O
X_add_number	long
=	O
0	int
;	O
emit_expr	function
(	O
&	O
exp	pointer
,	O
addr_size	int
)	O
;	O
exp	pointer
.	O
X_op	enum
=	O
O_symbol	int
;	O
exp	pointer
.	O
X_add_symbol	pointer
=	O
end	pointer
;	O
exp	pointer
.	O
X_add_number	long
=	O
0	int
;	O
emit_expr	function
(	O
&	O
exp	pointer
,	O
addr_size	int
)	O
;	O
}	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
addr_size	int
;	O
i	pointer
++	O
)	O
out_byte	function
(	O
0	int
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
addr_size	int
;	O
i	pointer
++	O
)	O
out_byte	function
(	O
0	int
)	O
;	O
}	O
static	O
void	O
out_debug_aranges	function
(	O
segT	pointer
aranges_seg	pointer
,	O
segT	pointer
info_seg	pointer
)	O
{	O
unsigned	O
int	O
addr_size	int
=	O
sizeof_address	int
;	O
offsetT	long
size	int
;	O
struct	O
line_seg	struct
*	O
s	pointer
;	O
expressionS	struct
exp	pointer
;	O
symbolS	struct
*	O
aranges_end	pointer
;	O
char	O
*	O
p	pointer
;	O
int	O
sizeof_offset	int
;	O
memset	function
(	O
&	O
exp	pointer
,	O
0	int
,	O
sizeof	O
exp	pointer
)	O
;	O
sizeof_offset	int
=	O
out_header	function
(	O
aranges_seg	pointer
,	O
&	O
exp	pointer
)	O
;	O
aranges_end	pointer
=	O
exp	pointer
.	O
X_add_symbol	pointer
;	O
size	int
=	O
-	O
exp	pointer
.	O
X_add_number	long
;	O
out_two	function
(	O
DWARF2_ARANGES_VERSION	int
)	O
;	O
size	int
+=	O
2	int
;	O
TC_DWARF2_EMIT_OFFSET	O
(	O
section_symbol	function
(	O
info_seg	pointer
)	O
,	O
sizeof_offset	int
)	O
;	O
size	int
+=	O
sizeof_offset	int
;	O
out_byte	function
(	O
addr_size	int
)	O
;	O
size	int
++	O
;	O
out_byte	function
(	O
0	int
)	O
;	O
size	int
++	O
;	O
while	O
(	O
(	O
size	int
++	O
%	O
(	O
2	int
*	O
addr_size	int
)	O
)	O
>	O
0	int
)	O
out_byte	function
(	O
0	int
)	O
;	O
for	O
(	O
s	pointer
=	O
all_segs	pointer
;	O
s	pointer
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
{	O
fragS	struct
*	O
frag	struct
;	O
symbolS	struct
*	O
beg	pointer
,	O
*	O
end	pointer
;	O
frag	struct
=	O
first_frag_for_seg	function
(	O
s	pointer
->	O
seg	pointer
)	O
;	O
beg	pointer
=	O
symbol_temp_new	function
(	O
s	pointer
->	O
seg	pointer
,	O
0	int
,	O
frag	struct
)	O
;	O
s	pointer
->	O
text_start	pointer
=	O
beg	pointer
;	O
frag	struct
=	O
last_frag_for_seg	function
(	O
s	pointer
->	O
seg	pointer
)	O
;	O
end	pointer
=	O
symbol_temp_new	function
(	O
s	pointer
->	O
seg	pointer
,	O
get_frag_fix	function
(	O
frag	struct
,	O
s	pointer
->	O
seg	pointer
)	O
,	O
frag	struct
)	O
;	O
s	pointer
->	O
text_end	pointer
=	O
end	pointer
;	O
exp	pointer
.	O
X_op	enum
=	O
O_symbol	int
;	O
exp	pointer
.	O
X_add_symbol	pointer
=	O
beg	pointer
;	O
exp	pointer
.	O
X_add_number	long
=	O
0	int
;	O
emit_expr	function
(	O
&	O
exp	pointer
,	O
addr_size	int
)	O
;	O
exp	pointer
.	O
X_op	enum
=	O
O_subtract	int
;	O
exp	pointer
.	O
X_add_symbol	pointer
=	O
end	pointer
;	O
exp	pointer
.	O
X_op_symbol	pointer
=	O
beg	pointer
;	O
exp	pointer
.	O
X_add_number	long
=	O
0	int
;	O
emit_expr	function
(	O
&	O
exp	pointer
,	O
addr_size	int
)	O
;	O
}	O
p	pointer
=	O
frag_more	function
(	O
2	int
*	O
addr_size	int
)	O
;	O
md_number_to_chars	O
(	O
p	pointer
,	O
0	int
,	O
addr_size	int
)	O
;	O
md_number_to_chars	O
(	O
p	pointer
+	O
addr_size	int
,	O
0	int
,	O
addr_size	int
)	O
;	O
symbol_set_value_now	function
(	O
aranges_end	pointer
)	O
;	O
}	O
static	O
void	O
out_debug_abbrev	function
(	O
segT	pointer
abbrev_seg	pointer
,	O
segT	pointer
info_seg	pointer
ATTRIBUTE_UNUSED	O
,	O
segT	pointer
line_seg	struct
ATTRIBUTE_UNUSED	O
)	O
{	O
subseg_set	function
(	O
abbrev_seg	pointer
,	O
0	int
)	O
;	O
out_uleb128	function
(	O
1	int
)	O
;	O
out_uleb128	function
(	O
DW_TAG_compile_unit	int
)	O
;	O
out_byte	function
(	O
DW_CHILDREN_no	int
)	O
;	O
if	O
(	O
DWARF2_FORMAT	O
(	O
line_seg	struct
)	O
==	O
dwarf2_format_32bit	int
)	O
out_abbrev	function
(	O
DW_AT_stmt_list	int
,	O
DW_FORM_data4	int
)	O
;	O
else	O
out_abbrev	function
(	O
DW_AT_stmt_list	int
,	O
DW_FORM_data8	int
)	O
;	O
if	O
(	O
all_segs	pointer
->	O
next	pointer
==	O
NULL	O
)	O
{	O
out_abbrev	function
(	O
DW_AT_low_pc	int
,	O
DW_FORM_addr	int
)	O
;	O
if	O
(	O
DWARF2_VERSION	int
<	O
4	int
)	O
out_abbrev	function
(	O
DW_AT_high_pc	int
,	O
DW_FORM_addr	int
)	O
;	O
else	O
out_abbrev	function
(	O
DW_AT_high_pc	int
,	O
(	O
sizeof_address	int
==	O
4	int
?	O
DW_FORM_data4	int
:	O
DW_FORM_data8	int
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
DWARF2_FORMAT	O
(	O
info_seg	pointer
)	O
==	O
dwarf2_format_32bit	int
)	O
out_abbrev	function
(	O
DW_AT_ranges	int
,	O
DW_FORM_data4	int
)	O
;	O
else	O
out_abbrev	function
(	O
DW_AT_ranges	int
,	O
DW_FORM_data8	int
)	O
;	O
}	O
out_abbrev	function
(	O
DW_AT_name	int
,	O
DW_FORM_strp	int
)	O
;	O
out_abbrev	function
(	O
DW_AT_comp_dir	int
,	O
DW_FORM_strp	int
)	O
;	O
out_abbrev	function
(	O
DW_AT_producer	int
,	O
DW_FORM_strp	int
)	O
;	O
out_abbrev	function
(	O
DW_AT_language	int
,	O
DW_FORM_data2	int
)	O
;	O
out_abbrev	function
(	O
0	int
,	O
0	int
)	O
;	O
out_byte	function
(	O
0	int
)	O
;	O
}	O
static	O
void	O
out_debug_info	function
(	O
segT	pointer
info_seg	pointer
,	O
segT	pointer
abbrev_seg	pointer
,	O
segT	pointer
line_seg	struct
,	O
segT	pointer
ranges_seg	pointer
,	O
symbolS	struct
*	O
name_sym	pointer
,	O
symbolS	struct
*	O
comp_dir_sym	pointer
,	O
symbolS	struct
*	O
producer_sym	pointer
)	O
{	O
expressionS	struct
exp	pointer
;	O
symbolS	struct
*	O
info_end	pointer
;	O
int	O
sizeof_offset	int
;	O
memset	function
(	O
&	O
exp	pointer
,	O
0	int
,	O
sizeof	O
exp	pointer
)	O
;	O
sizeof_offset	int
=	O
out_header	function
(	O
info_seg	pointer
,	O
&	O
exp	pointer
)	O
;	O
info_end	pointer
=	O
exp	pointer
.	O
X_add_symbol	pointer
;	O
out_two	function
(	O
DWARF2_VERSION	int
)	O
;	O
TC_DWARF2_EMIT_OFFSET	O
(	O
section_symbol	function
(	O
abbrev_seg	pointer
)	O
,	O
sizeof_offset	int
)	O
;	O
out_byte	function
(	O
sizeof_address	int
)	O
;	O
out_uleb128	function
(	O
1	int
)	O
;	O
TC_DWARF2_EMIT_OFFSET	O
(	O
section_symbol	function
(	O
line_seg	struct
)	O
,	O
(	O
DWARF2_FORMAT	O
(	O
line_seg	struct
)	O
==	O
dwarf2_format_32bit	int
?	O
4	int
:	O
8	int
)	O
)	O
;	O
if	O
(	O
all_segs	pointer
->	O
next	pointer
==	O
NULL	O
)	O
{	O
exp	pointer
.	O
X_op	enum
=	O
O_symbol	int
;	O
exp	pointer
.	O
X_add_symbol	pointer
=	O
all_segs	pointer
->	O
text_start	pointer
;	O
exp	pointer
.	O
X_add_number	long
=	O
0	int
;	O
emit_expr	function
(	O
&	O
exp	pointer
,	O
sizeof_address	int
)	O
;	O
if	O
(	O
DWARF2_VERSION	int
<	O
4	int
)	O
exp	pointer
.	O
X_op	enum
=	O
O_symbol	int
;	O
else	O
{	O
exp	pointer
.	O
X_op	enum
=	O
O_subtract	int
;	O
exp	pointer
.	O
X_op_symbol	pointer
=	O
all_segs	pointer
->	O
text_start	pointer
;	O
}	O
exp	pointer
.	O
X_add_symbol	pointer
=	O
all_segs	pointer
->	O
text_end	pointer
;	O
exp	pointer
.	O
X_add_number	long
=	O
0	int
;	O
emit_expr	function
(	O
&	O
exp	pointer
,	O
sizeof_address	int
)	O
;	O
}	O
else	O
{	O
TC_DWARF2_EMIT_OFFSET	O
(	O
section_symbol	function
(	O
ranges_seg	pointer
)	O
,	O
sizeof_offset	int
)	O
;	O
}	O
TC_DWARF2_EMIT_OFFSET	O
(	O
name_sym	pointer
,	O
sizeof_offset	int
)	O
;	O
TC_DWARF2_EMIT_OFFSET	O
(	O
comp_dir_sym	pointer
,	O
sizeof_offset	int
)	O
;	O
TC_DWARF2_EMIT_OFFSET	O
(	O
producer_sym	pointer
,	O
sizeof_offset	int
)	O
;	O
out_two	function
(	O
DW_LANG_Mips_Assembler	int
)	O
;	O
symbol_set_value_now	function
(	O
info_end	pointer
)	O
;	O
}	O
static	O
void	O
out_debug_str	function
(	O
segT	pointer
str_seg	pointer
,	O
symbolS	struct
*	O
*	O
name_sym	pointer
,	O
symbolS	struct
*	O
*	O
comp_dir_sym	pointer
,	O
symbolS	struct
*	O
*	O
producer_sym	pointer
)	O
{	O
char	O
producer	array
[	O
128	int
]	O
;	O
const	O
char	O
*	O
comp_dir	pointer
;	O
const	O
char	O
*	O
dirname	pointer
;	O
char	O
*	O
p	pointer
;	O
int	O
len	long
;	O
subseg_set	function
(	O
str_seg	pointer
,	O
0	int
)	O
;	O
*	O
name_sym	pointer
=	O
symbol_temp_new_now_octets	function
(	O
)	O
;	O
if	O
(	O
files_in_use	int
==	O
0	int
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
files	pointer
[	O
1	int
]	O
.	O
dir	pointer
)	O
{	O
dirname	pointer
=	O
remap_debug_filename	function
(	O
dirs	pointer
[	O
files	pointer
[	O
1	int
]	O
.	O
dir	pointer
]	O
)	O
;	O
len	long
=	O
strlen	function
(	O
dirname	pointer
)	O
;	O
p	pointer
=	O
frag_more	function
(	O
len	long
+	O
1	int
)	O
;	O
memcpy	function
(	O
p	pointer
,	O
dirname	pointer
,	O
len	long
)	O
;	O
INSERT_DIR_SEPARATOR	O
(	O
p	pointer
,	O
len	long
)	O
;	O
}	O
len	long
=	O
strlen	function
(	O
files	pointer
[	O
1	int
]	O
.	O
filename	pointer
)	O
+	O
1	int
;	O
p	pointer
=	O
frag_more	function
(	O
len	long
)	O
;	O
memcpy	function
(	O
p	pointer
,	O
files	pointer
[	O
1	int
]	O
.	O
filename	pointer
,	O
len	long
)	O
;	O
*	O
comp_dir_sym	pointer
=	O
symbol_temp_new_now_octets	function
(	O
)	O
;	O
comp_dir	pointer
=	O
remap_debug_filename	function
(	O
getpwd	function
(	O
)	O
)	O
;	O
len	long
=	O
strlen	function
(	O
comp_dir	pointer
)	O
+	O
1	int
;	O
p	pointer
=	O
frag_more	function
(	O
len	long
)	O
;	O
memcpy	function
(	O
p	pointer
,	O
comp_dir	pointer
,	O
len	long
)	O
;	O
*	O
producer_sym	pointer
=	O
symbol_temp_new_now_octets	function
(	O
)	O
;	O
sprintf	function
(	O
producer	array
,	O
"GNU AS %s"	pointer
,	O
VERSION	pointer
)	O
;	O
len	long
=	O
strlen	function
(	O
producer	array
)	O
+	O
1	int
;	O
p	pointer
=	O
frag_more	function
(	O
len	long
)	O
;	O
memcpy	function
(	O
p	pointer
,	O
producer	array
,	O
len	long
)	O
;	O
}	O
void	O
dwarf2_init	function
(	O
void	O
)	O
{	O
last_seg_ptr	pointer
=	O
&	O
all_segs	pointer
;	O
if	O
(	O
flag_dwarf_cie_version	int
==	O
-	O
1	int
)	O
flag_dwarf_cie_version	int
=	O
1	int
;	O
}	O
void	O
dwarf2_finish	function
(	O
void	O
)	O
{	O
segT	pointer
line_seg	struct
;	O
struct	O
line_seg	struct
*	O
s	pointer
;	O
segT	pointer
info_seg	pointer
;	O
int	O
emit_other_sections	int
=	O
0	int
;	O
int	O
empty_debug_line	int
=	O
0	int
;	O
info_seg	pointer
=	O
bfd_get_section_by_name	function
(	O
stdoutput	pointer
,	O
".debug_info"	pointer
)	O
;	O
emit_other_sections	int
=	O
info_seg	pointer
==	O
NULL	O
||	O
!	O
seg_not_empty_p	function
(	O
info_seg	pointer
)	O
;	O
line_seg	struct
=	O
bfd_get_section_by_name	function
(	O
stdoutput	pointer
,	O
".debug_line"	pointer
)	O
;	O
empty_debug_line	int
=	O
line_seg	struct
==	O
NULL	O
||	O
!	O
seg_not_empty_p	function
(	O
line_seg	struct
)	O
;	O
if	O
(	O
all_segs	pointer
&&	O
!	O
empty_debug_line	int
)	O
as_fatal	function
(	O
"duplicate .debug_line sections"	pointer
)	O
;	O
if	O
(	O
(	O
!	O
all_segs	pointer
&&	O
emit_other_sections	int
)	O
||	O
(	O
!	O
emit_other_sections	int
&&	O
!	O
empty_debug_line	int
)	O
)	O
return	O
;	O
sizeof_address	int
=	O
DWARF2_ADDR_SIZE	O
(	O
stdoutput	pointer
)	O
;	O
line_seg	struct
=	O
subseg_new	function
(	O
".debug_line"	pointer
,	O
0	int
)	O
;	O
bfd_set_section_flags	function
(	O
line_seg	struct
,	O
SEC_READONLY	int
|	O
SEC_DEBUGGING	int
|	O
SEC_OCTETS	O
)	O
;	O
for	O
(	O
s	pointer
=	O
all_segs	pointer
;	O
s	pointer
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
{	O
struct	O
line_subseg	struct
*	O
lss	pointer
=	O
s	pointer
->	O
head	pointer
;	O
struct	O
line_entry	struct
*	O
*	O
ptail	pointer
=	O
lss	pointer
->	O
ptail	pointer
;	O
if	O
(	O
lss	pointer
->	O
head	pointer
&&	O
lss	pointer
->	O
head	pointer
->	O
loc	pointer
.	O
view	pointer
)	O
set_or_check_view	function
(	O
lss	pointer
->	O
head	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
while	O
(	O
(	O
lss	pointer
=	O
lss	pointer
->	O
next	pointer
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
lss	pointer
->	O
head	pointer
&&	O
lss	pointer
->	O
head	pointer
->	O
loc	pointer
.	O
view	pointer
)	O
set_or_check_view	function
(	O
lss	pointer
->	O
head	pointer
,	O
!	O
s	pointer
->	O
head	pointer
?	O
NULL	O
:	O
(	O
struct	O
line_entry	struct
*	O
)	O
ptail	pointer
,	O
s	pointer
->	O
head	pointer
?	O
s	pointer
->	O
head	pointer
->	O
head	pointer
:	O
NULL	O
)	O
;	O
*	O
ptail	pointer
=	O
lss	pointer
->	O
head	pointer
;	O
ptail	pointer
=	O
lss	pointer
->	O
ptail	pointer
;	O
}	O
}	O
out_debug_line	function
(	O
line_seg	struct
)	O
;	O
if	O
(	O
emit_other_sections	int
)	O
{	O
segT	pointer
abbrev_seg	pointer
;	O
segT	pointer
aranges_seg	pointer
;	O
segT	pointer
ranges_seg	pointer
;	O
segT	pointer
str_seg	pointer
;	O
symbolS	struct
*	O
name_sym	pointer
,	O
*	O
comp_dir_sym	pointer
,	O
*	O
producer_sym	pointer
;	O
gas_assert	O
(	O
all_segs	pointer
)	O
;	O
info_seg	pointer
=	O
subseg_new	function
(	O
".debug_info"	pointer
,	O
0	int
)	O
;	O
abbrev_seg	pointer
=	O
subseg_new	function
(	O
".debug_abbrev"	pointer
,	O
0	int
)	O
;	O
aranges_seg	pointer
=	O
subseg_new	function
(	O
".debug_aranges"	pointer
,	O
0	int
)	O
;	O
str_seg	pointer
=	O
subseg_new	function
(	O
".debug_str"	pointer
,	O
0	int
)	O
;	O
bfd_set_section_flags	function
(	O
info_seg	pointer
,	O
SEC_READONLY	int
|	O
SEC_DEBUGGING	int
|	O
SEC_OCTETS	O
)	O
;	O
bfd_set_section_flags	function
(	O
abbrev_seg	pointer
,	O
SEC_READONLY	int
|	O
SEC_DEBUGGING	int
|	O
SEC_OCTETS	O
)	O
;	O
bfd_set_section_flags	function
(	O
aranges_seg	pointer
,	O
SEC_READONLY	int
|	O
SEC_DEBUGGING	int
|	O
SEC_OCTETS	O
)	O
;	O
bfd_set_section_flags	function
(	O
str_seg	pointer
,	O
SEC_READONLY	int
|	O
SEC_DEBUGGING	int
|	O
SEC_OCTETS	O
|	O
SEC_MERGE	int
|	O
SEC_STRINGS	int
)	O
;	O
str_seg	pointer
->	O
entsize	int
=	O
1	int
;	O
record_alignment	function
(	O
aranges_seg	pointer
,	O
ffs	function
(	O
2	int
*	O
sizeof_address	int
)	O
-	O
1	int
)	O
;	O
if	O
(	O
all_segs	pointer
->	O
next	pointer
==	O
NULL	O
)	O
ranges_seg	pointer
=	O
NULL	O
;	O
else	O
{	O
ranges_seg	pointer
=	O
subseg_new	function
(	O
".debug_ranges"	pointer
,	O
0	int
)	O
;	O
bfd_set_section_flags	function
(	O
ranges_seg	pointer
,	O
SEC_READONLY	int
|	O
SEC_DEBUGGING	int
|	O
SEC_OCTETS	O
)	O
;	O
record_alignment	function
(	O
ranges_seg	pointer
,	O
ffs	function
(	O
2	int
*	O
sizeof_address	int
)	O
-	O
1	int
)	O
;	O
out_debug_ranges	function
(	O
ranges_seg	pointer
)	O
;	O
}	O
out_debug_aranges	function
(	O
aranges_seg	pointer
,	O
info_seg	pointer
)	O
;	O
out_debug_abbrev	function
(	O
abbrev_seg	pointer
,	O
info_seg	pointer
,	O
line_seg	struct
)	O
;	O
out_debug_str	function
(	O
str_seg	pointer
,	O
&	O
name_sym	pointer
,	O
&	O
comp_dir_sym	pointer
,	O
&	O
producer_sym	pointer
)	O
;	O
out_debug_info	function
(	O
info_seg	pointer
,	O
abbrev_seg	pointer
,	O
line_seg	struct
,	O
ranges_seg	pointer
,	O
name_sym	pointer
,	O
comp_dir_sym	pointer
,	O
producer_sym	pointer
)	O
;	O
}	O
}	O
void	O
dwarf2dbg_final_check	function
(	O
void	O
)	O
{	O
while	O
(	O
view_assert_failed	pointer
)	O
{	O
expressionS	struct
*	O
exp	pointer
;	O
symbolS	struct
*	O
sym	pointer
;	O
offsetT	long
failed	long
;	O
gas_assert	O
(	O
!	O
symbol_resolved_p	function
(	O
view_assert_failed	pointer
)	O
)	O
;	O
exp	pointer
=	O
symbol_get_value_expression	function
(	O
view_assert_failed	pointer
)	O
;	O
sym	pointer
=	O
view_assert_failed	pointer
;	O
if	O
(	O
exp	pointer
->	O
X_op	enum
==	O
O_add	int
&&	O
exp	pointer
->	O
X_add_number	long
==	O
0	int
&&	O
exp	pointer
->	O
X_unsigned	int
)	O
{	O
view_assert_failed	pointer
=	O
exp	pointer
->	O
X_add_symbol	pointer
;	O
sym	pointer
=	O
exp	pointer
->	O
X_op_symbol	pointer
;	O
}	O
else	O
view_assert_failed	pointer
=	O
NULL	O
;	O
failed	long
=	O
resolve_symbol_value	function
(	O
sym	pointer
)	O
;	O
if	O
(	O
!	O
symbol_resolved_p	function
(	O
sym	pointer
)	O
||	O
failed	long
)	O
{	O
as_bad	function
(	O
_	O
(	O
"view number mismatch"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
}	O
}	O
