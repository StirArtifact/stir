static	O
void	O
open_output_file	function
(	O
)	O
;	O
static	O
void	O
close_output_file	function
(	O
)	O
;	O
static	O
void	O
handle_env_options	function
___P	O
(	O
(	O
char	O
*	O
var	pointer
)	O
)	O
;	O
static	O
void	O
handle_options	function
___P	O
(	O
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
)	O
;	O
static	O
void	O
usage	function
(	O
)	O
;	O
static	O
void	O
version	double
(	O
)	O
;	O
char	O
*	O
program	pointer
;	O
FILE	struct
*	O
ofp	pointer
=	O
NULL	O
;	O
void	O
*	O
printer_context	pointer
;	O
char	O
*	O
date_string	pointer
=	O
NULL	O
;	O
struct	O
tm	struct
run_tm	struct
;	O
struct	O
tm	struct
mod_tm	struct
;	O
struct	O
passwd	struct
*	O
passwd	struct
;	O
char	O
*	O
enscript_library	pointer
=	O
LIBRARY	O
;	O
char	O
*	O
libpath	pointer
=	O
NULL	O
;	O
char	O
*	O
afm_path	pointer
=	O
NULL	O
;	O
MediaEntry	struct
*	O
media_names	pointer
=	O
NULL	O
;	O
MediaEntry	struct
*	O
media	pointer
=	O
NULL	O
;	O
int	O
bs	int
=	O
8	int
;	O
int	O
total_pages	int
=	O
0	int
;	O
int	O
num_truncated_lines	int
=	O
0	int
;	O
int	O
num_missing_chars	int
=	O
0	int
;	O
int	O
missing_chars	array
[	O
256	int
]	O
=	O
{	O
0	int
}	O
;	O
int	O
num_non_printable_chars	int
=	O
0	int
;	O
int	O
non_printable_chars	array
[	O
256	int
]	O
=	O
{	O
0	int
}	O
;	O
int	O
d_page_w	int
=	O
0	int
;	O
int	O
d_page_h	int
=	O
0	int
;	O
int	O
d_header_w	int
=	O
0	int
;	O
int	O
d_header_h	int
=	O
0	int
;	O
int	O
d_footer_h	int
=	O
0	int
;	O
int	O
d_output_w	int
=	O
0	int
;	O
int	O
d_output_h	int
=	O
0	int
;	O
int	O
d_output_x_margin	int
=	O
5	int
;	O
int	O
d_output_y_margin	int
=	O
2	int
;	O
StringHashPtr	pointer
res_fonts	pointer
;	O
StringHashPtr	pointer
download_fonts	pointer
;	O
StringHashPtr	pointer
pagedevice	pointer
;	O
StringHashPtr	pointer
statusdict	pointer
;	O
StringHashPtr	pointer
user_strings	pointer
;	O
StringHashPtr	pointer
afm_cache	pointer
=	O
NULL	O
;	O
StringHashPtr	pointer
afm_info_cache	pointer
=	O
NULL	O
;	O
AFMHandle	pointer
afm	pointer
=	O
NULL	O
;	O
int	O
num_columns	int
=	O
1	int
;	O
PageRange	struct
*	O
page_ranges	pointer
=	O
NULL	O
;	O
unsigned	O
int	O
file_align	int
=	O
1	int
;	O
char	O
*	O
page_header	pointer
=	O
NULL	O
;	O
LineEndType	enum
line_end	enum
=	O
LE_CHAR_WRAP	int
;	O
int	O
line_numbers	int
=	O
0	int
;	O
unsigned	O
int	O
start_line_number	int
=	O
1	int
;	O
char	O
*	O
printer	pointer
=	O
NULL	O
;	O
int	O
special_escapes	int
=	O
0	int
;	O
int	O
escape_char	int
=	O
'\0'	O
;	O
int	O
default_escape_char	int
;	O
int	O
highlight	int
=	O
0	int
;	O
char	O
*	O
hl_start_state	pointer
=	O
NULL	O
;	O
char	O
*	O
Fname	pointer
=	O
"Courier"	pointer
;	O
FontPoint	struct
Fpt	struct
=	O
{	O
10.0	int
,	O
10.0	int
}	O
;	O
FontPoint	struct
default_Fpt	struct
;	O
char	O
*	O
default_Fname	pointer
;	O
InputEncoding	enum
default_Fencoding	enum
;	O
int	O
user_body_font_defined	int
=	O
0	int
;	O
double	O
font_widths	array
[	O
256	int
]	O
;	O
char	O
font_ctype	array
[	O
256	int
]	O
;	O
int	O
font_is_fixed	enum
;	O
double	O
font_bbox_lly	double
;	O
char	O
*	O
HFname	pointer
=	O
"Courier-Bold"	pointer
;	O
FontPoint	struct
HFpt	struct
=	O
{	O
10.0	int
,	O
10.0	int
}	O
;	O
HeaderType	enum
header	enum
=	O
HDR_SIMPLE	int
;	O
char	O
*	O
fancy_header_name	pointer
=	O
NULL	O
;	O
char	O
*	O
fancy_header_default	pointer
=	O
NULL	O
;	O
static	O
int	O
no_job_header	int
=	O
0	int
;	O
unsigned	O
int	O
highlight_bars	int
=	O
0	int
;	O
double	O
line_indent	double
=	O
0.0	int
;	O
char	O
*	O
line_indent_spec	pointer
=	O
"0"	pointer
;	O
char	O
*	O
input_filter	pointer
=	O
NULL	O
;	O
int	O
borders	int
=	O
0	int
;	O
int	O
page_prefeed	int
=	O
0	int
;	O
unsigned	O
int	O
lines_per_page	int
=	O
(	O
unsigned	O
int	O
)	O
-	O
1	int
;	O
int	O
mail	int
=	O
0	int
;	O
char	O
*	O
media_name	pointer
=	O
NULL	O
;	O
int	O
num_copies	int
=	O
1	int
;	O
int	O
nl	int
=	O
-	O
1	int
;	O
char	O
*	O
output_file	pointer
=	O
OUTPUT_FILE_NONE	O
;	O
int	O
list_missing_characters	int
=	O
0	int
;	O
int	O
quiet	int
=	O
0	int
;	O
int	O
landscape	int
=	O
0	int
;	O
double	O
baselineskip	double
=	O
1.0	int
;	O
char	O
*	O
title	pointer
=	O
"Enscript Output"	pointer
;	O
int	O
title_given	int
=	O
0	int
;	O
int	O
tabsize	int
=	O
8	int
;	O
double	O
ul_gray	double
=	O
.8	int
;	O
FontPoint	struct
ul_ptsize	struct
=	O
{	O
200.0	int
,	O
200.0	int
}	O
;	O
char	O
*	O
ul_font	pointer
=	O
"Times-Roman"	pointer
;	O
char	O
*	O
underlay	pointer
=	O
NULL	O
;	O
char	O
*	O
ul_position	pointer
=	O
NULL	O
;	O
double	O
ul_x	double
;	O
double	O
ul_y	double
;	O
double	O
ul_angle	double
;	O
unsigned	O
int	O
ul_style	int
=	O
UL_STYLE_OUTLINE	int
;	O
char	O
*	O
ul_style_str	pointer
=	O
NULL	O
;	O
int	O
ul_position_p	int
=	O
0	int
;	O
int	O
ul_angle_p	int
=	O
0	int
;	O
unsigned	O
int	O
nup	int
=	O
1	int
;	O
unsigned	O
int	O
nup_exp	int
=	O
0	int
;	O
unsigned	O
int	O
nup_rows	int
=	O
1	int
;	O
unsigned	O
int	O
nup_columns	int
=	O
1	int
;	O
int	O
nup_landscape	int
=	O
0	int
;	O
unsigned	O
int	O
nup_width	int
;	O
unsigned	O
int	O
nup_height	int
;	O
double	O
nup_scale	double
;	O
int	O
verbose	int
=	O
0	int
;	O
char	O
*	O
output_language	pointer
=	O
"PostScript"	pointer
;	O
int	O
output_language_pass_through	int
=	O
0	int
;	O
Buffer	struct
*	O
helper_options	array
[	O
256	int
]	O
=	O
{	O
0	int
}	O
;	O
InputEncoding	enum
encoding	array
=	O
ENC_ISO_8859_1	int
;	O
char	O
*	O
encoding_name	pointer
=	O
NULL	O
;	O
int	O
interpret_formfeed	int
=	O
1	int
;	O
int	O
pass_through	int
=	O
0	int
;	O
int	O
continuous_page_numbers	int
=	O
0	int
;	O
int	O
extended_return_values	int
=	O
0	int
;	O
char	O
*	O
input_filter_stdin	pointer
=	O
""	pointer
;	O
char	O
*	O
page_footer	pointer
=	O
NULL	O
;	O
double	O
horizontal_column_height	double
=	O
283465.0	int
;	O
int	O
help_highlight	int
=	O
0	int
;	O
double	O
highlight_bar_gray	double
=	O
.97	int
;	O
int	O
list_media	int
=	O
0	int
;	O
char	O
*	O
margins_spec	pointer
=	O
NULL	O
;	O
char	O
*	O
mark_wrapped_lines_style_name	pointer
=	O
NULL	O
;	O
MarkWrappedLinesStyle	enum
mark_wrapped_lines_style	enum
=	O
MWLS_NONE	int
;	O
char	O
*	O
npf_name	pointer
=	O
NULL	O
;	O
NonPrintableFormat	enum
non_printable_format	enum
=	O
NPF_OCTAL	int
;	O
int	O
nup_columnwise	int
=	O
0	int
;	O
unsigned	O
int	O
nup_xpad	int
=	O
10	int
;	O
unsigned	O
int	O
nup_ypad	int
=	O
10	int
;	O
char	O
*	O
page_label_format	pointer
=	O
NULL	O
;	O
PageLabelFormat	enum
page_label	enum
;	O
unsigned	O
int	O
pslevel	int
=	O
2	int
;	O
char	O
*	O
printer_options	pointer
=	O
NULL	O
;	O
int	O
rotate_even_pages	int
=	O
0	int
;	O
int	O
slicing	int
=	O
0	int
;	O
unsigned	O
int	O
slice	int
=	O
1	int
;	O
int	O
swap_even_page_margins	int
=	O
0	int
;	O
int	O
toc	int
=	O
0	int
;	O
FILE	struct
*	O
toc_fp	pointer
;	O
char	O
*	O
toc_fmt_string	pointer
;	O
int	O
accept_composites	int
=	O
0	int
;	O
int	O
append_ctrl_D	int
=	O
0	int
;	O
int	O
clean_7bit	int
=	O
1	int
;	O
FormFeedType	enum
formfeed_type	enum
=	O
FORMFEED_COLUMN	int
;	O
int	O
generate_PageSize	int
=	O
1	int
;	O
char	O
*	O
no_job_header_switch	pointer
=	O
NULL	O
;	O
char	O
*	O
output_first_line	pointer
=	O
NULL	O
;	O
char	O
*	O
queue_param	pointer
=	O
NULL	O
;	O
char	O
*	O
spooler_command	pointer
=	O
NULL	O
;	O
char	O
*	O
states_binary	pointer
=	O
NULL	O
;	O
int	O
states_color	int
=	O
0	int
;	O
char	O
*	O
states_config_file	pointer
=	O
NULL	O
;	O
char	O
*	O
states_highlight_style	pointer
=	O
NULL	O
;	O
char	O
*	O
states_path	pointer
=	O
NULL	O
;	O
double	O
line_highlight_gray	double
=	O
1.0	int
;	O
double	O
bggray	double
=	O
1.0	int
;	O
EncodingRegistry	struct
encodings	array
[	O
]	O
=	O
{	O
{	O
{	O
"88591"	pointer
,	O
"latin1"	pointer
,	O
NULL	O
}	O
,	O
ENC_ISO_8859_1	int
,	O
'\n'	O
,	O
8	int
}	O
,	O
{	O
{	O
"88592"	pointer
,	O
"latin2"	pointer
,	O
NULL	O
}	O
,	O
ENC_ISO_8859_2	int
,	O
'\n'	O
,	O
8	int
}	O
,	O
{	O
{	O
"88593"	pointer
,	O
"latin3"	pointer
,	O
NULL	O
}	O
,	O
ENC_ISO_8859_3	int
,	O
'\n'	O
,	O
8	int
}	O
,	O
{	O
{	O
"88594"	pointer
,	O
"latin4"	pointer
,	O
NULL	O
}	O
,	O
ENC_ISO_8859_4	int
,	O
'\n'	O
,	O
8	int
}	O
,	O
{	O
{	O
"88595"	pointer
,	O
"cyrillic"	pointer
,	O
NULL	O
}	O
,	O
ENC_ISO_8859_5	int
,	O
'\n'	O
,	O
8	int
}	O
,	O
{	O
{	O
"88597"	pointer
,	O
"greek"	pointer
,	O
NULL	O
}	O
,	O
ENC_ISO_8859_7	int
,	O
'\n'	O
,	O
8	int
}	O
,	O
{	O
{	O
"88599"	pointer
,	O
"latin5"	pointer
,	O
NULL	O
}	O
,	O
ENC_ISO_8859_9	int
,	O
'\n'	O
,	O
8	int
}	O
,	O
{	O
{	O
"885910"	pointer
,	O
"latin6"	pointer
,	O
NULL	O
}	O
,	O
ENC_ISO_8859_10	int
,	O
'\n'	O
,	O
8	int
}	O
,	O
{	O
{	O
"ascii"	pointer
,	O
NULL	O
,	O
NULL	O
}	O
,	O
ENC_ASCII	int
,	O
'\n'	O
,	O
8	int
}	O
,	O
{	O
{	O
"asciifise"	pointer
,	O
"asciifi"	pointer
,	O
"asciise"	pointer
}	O
,	O
ENC_ASCII_FISE	int
,	O
'\n'	O
,	O
8	int
}	O
,	O
{	O
{	O
"asciidkno"	pointer
,	O
"asciidk"	pointer
,	O
"asciino"	pointer
}	O
,	O
ENC_ASCII_DKNO	int
,	O
'\n'	O
,	O
8	int
}	O
,	O
{	O
{	O
"ibmpc"	pointer
,	O
"pc"	pointer
,	O
"dos"	pointer
}	O
,	O
ENC_IBMPC	int
,	O
'\n'	O
,	O
8	int
}	O
,	O
{	O
{	O
"mac"	pointer
,	O
NULL	O
,	O
NULL	O
}	O
,	O
ENC_MAC	int
,	O
'\r'	O
,	O
8	int
}	O
,	O
{	O
{	O
"vms"	pointer
,	O
NULL	O
,	O
NULL	O
}	O
,	O
ENC_VMS	int
,	O
'\n'	O
,	O
8	int
}	O
,	O
{	O
{	O
"hp8"	pointer
,	O
NULL	O
,	O
NULL	O
}	O
,	O
ENC_HP8	int
,	O
'\n'	O
,	O
8	int
}	O
,	O
{	O
{	O
"koi8"	pointer
,	O
NULL	O
,	O
NULL	O
}	O
,	O
ENC_KOI8	int
,	O
'\n'	O
,	O
8	int
}	O
,	O
{	O
{	O
"ps"	pointer
,	O
"PS"	pointer
,	O
NULL	O
}	O
,	O
ENC_PS	int
,	O
'\n'	O
,	O
8	int
}	O
,	O
{	O
{	O
"pslatin1"	pointer
,	O
"ISOLatin1Encoding"	pointer
,	O
NULL	O
}	O
,	O
ENC_ISO_8859_1	int
,	O
'\n'	O
,	O
8	int
}	O
,	O
{	O
{	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
}	O
;	O
static	O
struct	O
option	struct
long_options	array
[	O
]	O
=	O
{	O
{	O
"columns"	pointer
,	O
required_argument	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"pages"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'a'	O
}	O
,	O
{	O
"file-align"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'A'	O
}	O
,	O
{	O
"header"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'b'	O
}	O
,	O
{	O
"no-header"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'B'	O
}	O
,	O
{	O
"truncate-lines"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'c'	O
}	O
,	O
{	O
"line-numbers"	pointer
,	O
optional_argument	int
,	O
0	int
,	O
'C'	O
}	O
,	O
{	O
"printer"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'd'	O
}	O
,	O
{	O
"setpagedevice"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'D'	O
}	O
,	O
{	O
"escapes"	pointer
,	O
optional_argument	int
,	O
0	int
,	O
'e'	O
}	O
,	O
{	O
"highlight"	pointer
,	O
optional_argument	int
,	O
0	int
,	O
'E'	O
}	O
,	O
{	O
"font"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'f'	O
}	O
,	O
{	O
"header-font"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'F'	O
}	O
,	O
{	O
"print-anyway"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'g'	O
}	O
,	O
{	O
"fancy-header"	pointer
,	O
optional_argument	int
,	O
0	int
,	O
'G'	O
}	O
,	O
{	O
"no-job-header"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'h'	O
}	O
,	O
{	O
"highlight-bars"	pointer
,	O
optional_argument	int
,	O
0	int
,	O
'H'	O
}	O
,	O
{	O
"indent"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'i'	O
}	O
,	O
{	O
"filter"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'I'	O
}	O
,	O
{	O
"borders"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'j'	O
}	O
,	O
{	O
"page-prefeed"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'k'	O
}	O
,	O
{	O
"no-page-prefeed"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'K'	O
}	O
,	O
{	O
"lineprinter"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'l'	O
}	O
,	O
{	O
"lines-per-page"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'L'	O
}	O
,	O
{	O
"mail"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'm'	O
}	O
,	O
{	O
"media"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'M'	O
}	O
,	O
{	O
"copies"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'n'	O
}	O
,	O
{	O
"newline"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'N'	O
}	O
,	O
{	O
"output"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'p'	O
}	O
,	O
{	O
"missing-characters"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'O'	O
}	O
,	O
{	O
"quiet"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'q'	O
}	O
,	O
{	O
"silent"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'q'	O
}	O
,	O
{	O
"landscape"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'r'	O
}	O
,	O
{	O
"portrait"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'R'	O
}	O
,	O
{	O
"baselineskip"	pointer
,	O
required_argument	int
,	O
0	int
,	O
's'	O
}	O
,	O
{	O
"statusdict"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'S'	O
}	O
,	O
{	O
"title"	pointer
,	O
required_argument	int
,	O
0	int
,	O
't'	O
}	O
,	O
{	O
"tabsize"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'T'	O
}	O
,	O
{	O
"underlay"	pointer
,	O
optional_argument	int
,	O
0	int
,	O
'u'	O
}	O
,	O
{	O
"nup"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'U'	O
}	O
,	O
{	O
"verbose"	pointer
,	O
optional_argument	int
,	O
0	int
,	O
'v'	O
}	O
,	O
{	O
"version"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'V'	O
}	O
,	O
{	O
"language"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'w'	O
}	O
,	O
{	O
"option"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'W'	O
}	O
,	O
{	O
"encoding"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'X'	O
}	O
,	O
{	O
"no-formfeed"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'z'	O
}	O
,	O
{	O
"pass-through"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'Z'	O
}	O
,	O
{	O
"color"	pointer
,	O
optional_argument	int
,	O
0	int
,	O
142	int
}	O
,	O
{	O
"continuous-page-numbers"	pointer
,	O
no_argument	int
,	O
0	int
,	O
156	int
}	O
,	O
{	O
"download-font"	pointer
,	O
required_argument	int
,	O
0	int
,	O
131	int
}	O
,	O
{	O
"extended-return-values"	pointer
,	O
no_argument	int
,	O
0	int
,	O
154	int
}	O
,	O
{	O
"filter-stdin"	pointer
,	O
required_argument	int
,	O
0	int
,	O
138	int
}	O
,	O
{	O
"footer"	pointer
,	O
required_argument	int
,	O
0	int
,	O
155	int
}	O
,	O
{	O
"h-column-height"	pointer
,	O
required_argument	int
,	O
0	int
,	O
148	int
}	O
,	O
{	O
"help"	pointer
,	O
no_argument	int
,	O
0	int
,	O
135	int
}	O
,	O
{	O
"help-highlight"	pointer
,	O
no_argument	int
,	O
0	int
,	O
141	int
}	O
,	O
{	O
"highlight-bar-gray"	pointer
,	O
required_argument	int
,	O
0	int
,	O
136	int
}	O
,	O
{	O
"list-media"	pointer
,	O
no_argument	int
,	O
&	O
list_media	int
,	O
1	int
}	O
,	O
{	O
"margins"	pointer
,	O
required_argument	int
,	O
0	int
,	O
144	int
}	O
,	O
{	O
"mark-wrapped-lines"	pointer
,	O
optional_argument	int
,	O
0	int
,	O
143	int
}	O
,	O
{	O
"non-printable-format"	pointer
,	O
required_argument	int
,	O
0	int
,	O
134	int
}	O
,	O
{	O
"nup-columnwise"	pointer
,	O
no_argument	int
,	O
0	int
,	O
152	int
}	O
,	O
{	O
"nup-xpad"	pointer
,	O
required_argument	int
,	O
0	int
,	O
145	int
}	O
,	O
{	O
"nup-ypad"	pointer
,	O
required_argument	int
,	O
0	int
,	O
146	int
}	O
,	O
{	O
"page-label-format"	pointer
,	O
required_argument	int
,	O
0	int
,	O
130	int
}	O
,	O
{	O
"ps-level"	pointer
,	O
required_argument	int
,	O
0	int
,	O
149	int
}	O
,	O
{	O
"printer-options"	pointer
,	O
required_argument	int
,	O
0	int
,	O
139	int
}	O
,	O
{	O
"rotate-even-pages"	pointer
,	O
no_argument	int
,	O
0	int
,	O
150	int
}	O
,	O
{	O
"slice"	pointer
,	O
required_argument	int
,	O
0	int
,	O
140	int
}	O
,	O
{	O
"style"	pointer
,	O
required_argument	int
,	O
0	int
,	O
151	int
}	O
,	O
{	O
"swap-even-page-margins"	pointer
,	O
no_argument	int
,	O
0	int
,	O
153	int
}	O
,	O
{	O
"toc"	pointer
,	O
no_argument	int
,	O
&	O
toc	int
,	O
1	int
}	O
,	O
{	O
"word-wrap"	pointer
,	O
no_argument	int
,	O
0	int
,	O
147	int
}	O
,	O
{	O
"ul-angle"	pointer
,	O
required_argument	int
,	O
0	int
,	O
132	int
}	O
,	O
{	O
"ul-font"	pointer
,	O
required_argument	int
,	O
0	int
,	O
128	int
}	O
,	O
{	O
"ul-gray"	pointer
,	O
required_argument	int
,	O
0	int
,	O
129	int
}	O
,	O
{	O
"ul-position"	pointer
,	O
required_argument	int
,	O
0	int
,	O
133	int
}	O
,	O
{	O
"ul-style"	pointer
,	O
required_argument	int
,	O
0	int
,	O
137	int
}	O
,	O
{	O
"pretty-print"	pointer
,	O
optional_argument	int
,	O
0	int
,	O
'E'	O
}	O
,	O
{	O
"help-pretty-print"	pointer
,	O
no_argument	int
,	O
0	int
,	O
141	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
}	O
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
InputStream	struct
is	pointer
;	O
time_t	long
tim	long
;	O
struct	O
tm	struct
*	O
tm	struct
;	O
int	O
i	int
,	O
j	int
,	O
found	int
;	O
unsigned	O
int	O
ui	int
;	O
MediaEntry	struct
*	O
mentry	pointer
;	O
AFMError	int
afm_error	int
;	O
char	O
*	O
cp	pointer
,	O
*	O
cp2	pointer
;	O
int	O
retval	int
=	O
0	int
;	O
Buffer	struct
buffer	pointer
;	O
buffer_init	function
(	O
&	O
buffer	pointer
)	O
;	O
program	pointer
=	O
strrchr	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
'/'	O
)	O
;	O
if	O
(	O
program	pointer
==	O
NULL	O
)	O
program	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
else	O
program	pointer
++	O
;	O
argv	pointer
[	O
0	int
]	O
=	O
program	pointer
;	O
toc_fmt_string	pointer
=	O
_	O
(	O
"$3v $-40N $3% pages $4L lines  $E $C"	pointer
)	O
;	O
setlocale	function
(	O
LC_MESSAGES	O
,	O
""	pointer
)	O
;	O
bindtextdomain	function
(	O
PACKAGE	pointer
,	O
LOCALEDIR	O
)	O
;	O
textdomain	function
(	O
PACKAGE	pointer
)	O
;	O
tim	long
=	O
time	struct
(	O
NULL	O
)	O
;	O
tm	struct
=	O
localtime	function
(	O
&	O
tim	long
)	O
;	O
memcpy	function
(	O
&	O
run_tm	struct
,	O
tm	struct
,	O
sizeof	O
(	O
*	O
tm	struct
)	O
)	O
;	O
date_string	pointer
=	O
xstrdup	function
(	O
asctime	function
(	O
&	O
run_tm	struct
)	O
)	O
;	O
i	int
=	O
strlen	function
(	O
date_string	pointer
)	O
;	O
date_string	pointer
[	O
i	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
passwd	struct
=	O
getpwuid	function
(	O
getuid	function
(	O
)	O
)	O
;	O
if	O
(	O
passwd	struct
==	O
NULL	O
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"couldn't get passwd entry for uid=%d: %s"	pointer
)	O
,	O
getuid	function
(	O
)	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
)	O
;	O
media_name	pointer
=	O
xstrdup	function
(	O
"A4"	pointer
)	O
;	O
encoding_name	pointer
=	O
xstrdup	function
(	O
"88591"	pointer
)	O
;	O
npf_name	pointer
=	O
xstrdup	function
(	O
"octal"	pointer
)	O
;	O
page_label_format	pointer
=	O
xstrdup	function
(	O
"short"	pointer
)	O
;	O
ul_style_str	pointer
=	O
xstrdup	function
(	O
"outline"	pointer
)	O
;	O
ul_position	pointer
=	O
xstrdup	function
(	O
"+0-0"	pointer
)	O
;	O
spooler_command	pointer
=	O
xstrdup	function
(	O
"lpr"	pointer
)	O
;	O
queue_param	pointer
=	O
xstrdup	function
(	O
"-P"	pointer
)	O
;	O
no_job_header_switch	pointer
=	O
xstrdup	function
(	O
"-h"	pointer
)	O
;	O
fancy_header_default	pointer
=	O
xstrdup	function
(	O
"enscript"	pointer
)	O
;	O
output_first_line	pointer
=	O
xstrdup	function
(	O
"%!PS-Adobe-3.0"	pointer
)	O
;	O
cp	pointer
=	O
getenv	function
(	O
"ENSCRIPT_LIBRARY"	pointer
)	O
;	O
if	O
(	O
cp	pointer
)	O
enscript_library	pointer
=	O
cp	pointer
;	O
cp	pointer
=	O
getenv	function
(	O
"HOME"	pointer
)	O
;	O
if	O
(	O
cp	pointer
==	O
NULL	O
)	O
cp	pointer
=	O
passwd	struct
->	O
pw_dir	pointer
;	O
buffer_clear	function
(	O
&	O
buffer	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
enscript_library	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
PATH_SEPARATOR_STR	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
cp	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
"/.enscript"	pointer
)	O
;	O
libpath	pointer
=	O
buffer_copy	function
(	O
&	O
buffer	pointer
)	O
;	O
states_binary	pointer
=	O
xstrdup	function
(	O
"states"	pointer
)	O
;	O
buffer_clear	function
(	O
&	O
buffer	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
enscript_library	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
"/hl/enscript.st"	pointer
)	O
;	O
states_config_file	pointer
=	O
buffer_copy	function
(	O
&	O
buffer	pointer
)	O
;	O
states_highlight_style	pointer
=	O
xstrdup	function
(	O
"emacs"	pointer
)	O
;	O
buffer_clear	function
(	O
&	O
buffer	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
cp	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
"/.enscript"	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
PATH_SEPARATOR_STR	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
enscript_library	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
"/hl"	pointer
)	O
;	O
states_path	pointer
=	O
buffer_copy	function
(	O
&	O
buffer	pointer
)	O
;	O
res_fonts	pointer
=	O
strhash_init	function
(	O
)	O
;	O
download_fonts	pointer
=	O
strhash_init	function
(	O
)	O
;	O
pagedevice	pointer
=	O
strhash_init	function
(	O
)	O
;	O
statusdict	pointer
=	O
strhash_init	function
(	O
)	O
;	O
user_strings	pointer
=	O
strhash_init	function
(	O
)	O
;	O
if	O
(	O
!	O
read_config	function
(	O
SYSCONFDIR	O
,	O
CFG_FILE_NAME	pointer
)	O
)	O
{	O
int	O
saved_errno	int
=	O
errno	O
;	O
if	O
(	O
!	O
read_config	function
(	O
enscript_library	pointer
,	O
CFG_FILE_NAME	pointer
)	O
)	O
{	O
buffer_clear	function
(	O
&	O
buffer	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
enscript_library	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
"/../../etc"	pointer
)	O
;	O
if	O
(	O
!	O
read_config	function
(	O
buffer_ptr	function
(	O
&	O
buffer	pointer
)	O
,	O
CFG_FILE_NAME	pointer
)	O
)	O
{	O
if	O
(	O
!	O
read_config	function
(	O
"../lib"	pointer
,	O
CFG_FILE_NAME	pointer
)	O
&&	O
!	O
read_config	function
(	O
"../../lib"	pointer
,	O
CFG_FILE_NAME	pointer
)	O
)	O
{	O
ERROR	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"couldn't read config file \"%s/%s\": %s"	pointer
)	O
,	O
enscript_library	pointer
,	O
CFG_FILE_NAME	pointer
,	O
strerror	function
(	O
saved_errno	int
)	O
)	O
)	O
;	O
ERROR	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"I did also try the following directories:"	pointer
)	O
)	O
)	O
;	O
ERROR	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"\t%s"	pointer
)	O
,	O
SYSCONFDIR	O
)	O
)	O
;	O
ERROR	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"\t%s"	pointer
)	O
,	O
enscript_library	pointer
)	O
)	O
;	O
ERROR	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"\t%s"	pointer
)	O
,	O
buffer_ptr	function
(	O
&	O
buffer	pointer
)	O
)	O
)	O
;	O
ERROR	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"\t../lib"	pointer
)	O
)	O
)	O
;	O
ERROR	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"\t../../lib"	pointer
)	O
)	O
)	O
;	O
ERROR	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"This is probably an installation error.  Please, try to rebuild:"	pointer
)	O
)	O
)	O
;	O
ERROR	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"\tmake distclean"	pointer
)	O
)	O
)	O
;	O
ERROR	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"\t./configure --prefix=PREFIX"	pointer
)	O
)	O
)	O
;	O
ERROR	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"\tmake"	pointer
)	O
)	O
)	O
;	O
ERROR	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"\tmake check"	pointer
)	O
)	O
)	O
;	O
ERROR	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"\tmake install"	pointer
)	O
)	O
)	O
;	O
ERROR	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"or set the environment variable `ENSCRIPT_LIBRARY'"	pointer
" to point to your library directory."	pointer
)	O
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
buffer_clear	function
(	O
&	O
buffer	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
libpath	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
PATH_SEPARATOR_STR	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
"../lib"	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
PATH_SEPARATOR_STR	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
"../../lib"	pointer
)	O
;	O
xfree	function
(	O
libpath	pointer
)	O
;	O
libpath	pointer
=	O
buffer_copy	function
(	O
&	O
buffer	pointer
)	O
;	O
}	O
}	O
}	O
read_config	function
(	O
SYSCONFDIR	O
,	O
"enscriptsite.cfg"	pointer
)	O
;	O
read_config	function
(	O
cp	pointer
,	O
".enscriptrc"	pointer
)	O
;	O
handle_env_options	function
(	O
"ENSCRIPT"	pointer
)	O
;	O
handle_env_options	function
(	O
"GENSCRIPT"	pointer
)	O
;	O
handle_options	function
(	O
argc	int
,	O
argv	pointer
)	O
;	O
default_escape_char	int
=	O
escape_char	int
;	O
found	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
!	O
found	int
&&	O
encodings	array
[	O
i	int
]	O
.	O
names	array
[	O
0	int
]	O
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
3	int
;	O
j	int
++	O
)	O
if	O
(	O
encodings	array
[	O
i	int
]	O
.	O
names	array
[	O
j	int
]	O
!=	O
NULL	O
&&	O
MATCH	O
(	O
encodings	array
[	O
i	int
]	O
.	O
names	array
[	O
j	int
]	O
,	O
encoding_name	pointer
)	O
)	O
{	O
encoding	array
=	O
encodings	array
[	O
i	int
]	O
.	O
encoding	array
;	O
xfree	function
(	O
encoding_name	pointer
)	O
;	O
encoding_name	pointer
=	O
xstrdup	function
(	O
encodings	array
[	O
i	int
]	O
.	O
names	array
[	O
0	int
]	O
)	O
;	O
if	O
(	O
nl	int
<	O
0	int
)	O
nl	int
=	O
encodings	array
[	O
i	int
]	O
.	O
nl	int
;	O
bs	int
=	O
encodings	array
[	O
i	int
]	O
.	O
bs	int
;	O
found	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
!	O
found	int
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"unknown encoding: %s"	pointer
)	O
,	O
encoding_name	pointer
)	O
)	O
;	O
if	O
(	O
!	O
user_body_font_defined	int
&&	O
landscape	int
&&	O
num_columns	int
>	O
1	int
)	O
Fpt	struct
.	O
w	int
=	O
Fpt	struct
.	O
h	int
=	O
7.0	int
;	O
afm_cache	pointer
=	O
strhash_init	function
(	O
)	O
;	O
afm_info_cache	pointer
=	O
strhash_init	function
(	O
)	O
;	O
afm_error	int
=	O
afm_create	function
(	O
afm_path	pointer
,	O
verbose	int
,	O
&	O
afm	pointer
)	O
;	O
if	O
(	O
afm_error	int
!=	O
AFM_SUCCESS	int
)	O
{	O
char	O
buf	pointer
[	O
256	int
]	O
;	O
afm_error_to_string	function
(	O
afm_error	int
,	O
buf	pointer
)	O
;	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"couldn't open AFM library: %s"	pointer
)	O
,	O
buf	pointer
)	O
)	O
;	O
}	O
default_Fpt	struct
.	O
w	int
=	O
Fpt	struct
.	O
w	int
;	O
default_Fpt	struct
.	O
h	int
=	O
Fpt	struct
.	O
h	int
;	O
default_Fname	pointer
=	O
Fname	pointer
;	O
default_Fencoding	enum
=	O
encoding	array
;	O
strhash_put	function
(	O
res_fonts	pointer
,	O
Fname	pointer
,	O
strlen	function
(	O
Fname	pointer
)	O
+	O
1	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
strhash_put	function
(	O
res_fonts	pointer
,	O
HFname	pointer
,	O
strlen	function
(	O
HFname	pointer
)	O
+	O
1	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
strhash_put	function
(	O
download_fonts	pointer
,	O
Fname	pointer
,	O
strlen	function
(	O
Fname	pointer
)	O
+	O
1	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
strhash_put	function
(	O
download_fonts	pointer
,	O
HFname	pointer
,	O
strlen	function
(	O
HFname	pointer
)	O
+	O
1	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
read_font_info	function
(	O
)	O
;	O
line_indent	double
=	O
parse_float	function
(	O
line_indent_spec	pointer
,	O
1	int
,	O
1	int
)	O
;	O
if	O
(	O
list_media	int
)	O
{	O
printf	function
(	O
_	O
(	O
"known media:\nname             width\theight\tllx\tlly\turx\tury\n------------------------------------------------------------\n"	pointer
)	O
)	O
;	O
for	O
(	O
mentry	pointer
=	O
media_names	pointer
;	O
mentry	pointer
;	O
mentry	pointer
=	O
mentry	pointer
->	O
next	pointer
)	O
printf	function
(	O
"%-16s %d\t%d\t%d\t%d\t%d\t%d\n"	pointer
,	O
mentry	pointer
->	O
name	pointer
,	O
mentry	pointer
->	O
w	int
,	O
mentry	pointer
->	O
h	int
,	O
mentry	pointer
->	O
llx	double
,	O
mentry	pointer
->	O
lly	double
,	O
mentry	pointer
->	O
urx	double
,	O
mentry	pointer
->	O
ury	double
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
for	O
(	O
mentry	pointer
=	O
media_names	pointer
;	O
mentry	pointer
;	O
mentry	pointer
=	O
mentry	pointer
->	O
next	pointer
)	O
if	O
(	O
strcmp	function
(	O
media_name	pointer
,	O
mentry	pointer
->	O
name	pointer
)	O
==	O
0	int
)	O
{	O
media	pointer
=	O
mentry	pointer
;	O
break	O
;	O
}	O
if	O
(	O
media	pointer
==	O
NULL	O
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"do not know anything about media \"%s\""	pointer
)	O
,	O
media_name	pointer
)	O
)	O
;	O
if	O
(	O
margins_spec	pointer
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
*	O
margins_spec	pointer
==	O
'\0'	O
)	O
break	O
;	O
if	O
(	O
*	O
margins_spec	pointer
==	O
':'	O
)	O
{	O
margins_spec	pointer
++	O
;	O
continue	O
;	O
}	O
j	int
=	O
atoi	function
(	O
margins_spec	pointer
)	O
;	O
for	O
(	O
;	O
*	O
margins_spec	pointer
!=	O
':'	O
&&	O
*	O
margins_spec	pointer
!=	O
'\0'	O
;	O
margins_spec	pointer
++	O
)	O
;	O
if	O
(	O
*	O
margins_spec	pointer
==	O
':'	O
)	O
margins_spec	pointer
++	O
;	O
switch	O
(	O
i	int
)	O
{	O
case	O
0	int
:	O
media	pointer
->	O
llx	double
=	O
j	int
;	O
break	O
;	O
case	O
1	int
:	O
media	pointer
->	O
urx	double
=	O
media	pointer
->	O
w	int
-	O
j	int
;	O
break	O
;	O
case	O
2	int
:	O
media	pointer
->	O
ury	double
=	O
media	pointer
->	O
h	int
-	O
j	int
;	O
break	O
;	O
case	O
3	int
:	O
media	pointer
->	O
lly	double
=	O
j	int
;	O
break	O
;	O
}	O
}	O
MESSAGE	O
(	O
1	int
,	O
(	O
stderr	pointer
,	O
_	O
(	O
"set new marginals for media `%s' (%dx%d): llx=%d, lly=%d, urx=%d, ury=%d\n"	pointer
)	O
,	O
media	pointer
->	O
name	pointer
,	O
media	pointer
->	O
w	int
,	O
media	pointer
->	O
h	int
,	O
media	pointer
->	O
llx	double
,	O
media	pointer
->	O
lly	double
,	O
media	pointer
->	O
urx	double
,	O
media	pointer
->	O
ury	double
)	O
)	O
;	O
}	O
if	O
(	O
MATCH	O
(	O
page_label_format	pointer
,	O
"short"	pointer
)	O
)	O
page_label	enum
=	O
LABEL_SHORT	int
;	O
else	O
if	O
(	O
MATCH	O
(	O
page_label_format	pointer
,	O
"long"	pointer
)	O
)	O
page_label	enum
=	O
LABEL_LONG	int
;	O
else	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"illegal page label format \"%s\""	pointer
)	O
,	O
page_label_format	pointer
)	O
)	O
;	O
if	O
(	O
MATCH	O
(	O
npf_name	pointer
,	O
"space"	pointer
)	O
)	O
non_printable_format	enum
=	O
NPF_SPACE	int
;	O
else	O
if	O
(	O
MATCH	O
(	O
npf_name	pointer
,	O
"questionmark"	pointer
)	O
)	O
non_printable_format	enum
=	O
NPF_QUESTIONMARK	int
;	O
else	O
if	O
(	O
MATCH	O
(	O
npf_name	pointer
,	O
"caret"	pointer
)	O
)	O
non_printable_format	enum
=	O
NPF_CARET	int
;	O
else	O
if	O
(	O
MATCH	O
(	O
npf_name	pointer
,	O
"octal"	pointer
)	O
)	O
non_printable_format	enum
=	O
NPF_OCTAL	int
;	O
else	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"illegal non-printable format \"%s\""	pointer
)	O
,	O
npf_name	pointer
)	O
)	O
;	O
if	O
(	O
mark_wrapped_lines_style_name	pointer
)	O
{	O
if	O
(	O
MATCH	O
(	O
mark_wrapped_lines_style_name	pointer
,	O
"none"	pointer
)	O
)	O
mark_wrapped_lines_style	enum
=	O
MWLS_NONE	int
;	O
else	O
if	O
(	O
MATCH	O
(	O
mark_wrapped_lines_style_name	pointer
,	O
"plus"	pointer
)	O
)	O
mark_wrapped_lines_style	enum
=	O
MWLS_PLUS	int
;	O
else	O
if	O
(	O
MATCH	O
(	O
mark_wrapped_lines_style_name	pointer
,	O
"box"	pointer
)	O
)	O
mark_wrapped_lines_style	enum
=	O
MWLS_BOX	int
;	O
else	O
if	O
(	O
MATCH	O
(	O
mark_wrapped_lines_style_name	pointer
,	O
"arrow"	pointer
)	O
)	O
mark_wrapped_lines_style	enum
=	O
MWLS_ARROW	int
;	O
else	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"illegal style for wrapped line marker: \"%s\""	pointer
)	O
,	O
mark_wrapped_lines_style_name	pointer
)	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
;	O
i	int
++	O
)	O
{	O
ui	int
=	O
nup	int
>>	O
i	int
;	O
if	O
(	O
ui	int
==	O
0	int
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"illegal N-up argument: %d"	pointer
)	O
,	O
nup	int
)	O
)	O
;	O
if	O
(	O
ui	int
&	O
0x1	int
)	O
{	O
if	O
(	O
ui	int
!=	O
1	int
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"N-up argument must be power of 2: %d"	pointer
)	O
,	O
nup	int
)	O
)	O
;	O
nup_exp	int
=	O
i	int
;	O
break	O
;	O
}	O
}	O
nup_rows	int
=	O
nup_exp	int
/	O
2	int
*	O
2	int
;	O
if	O
(	O
nup_rows	int
==	O
0	int
)	O
nup_rows	int
=	O
1	int
;	O
nup_columns	int
=	O
(	O
nup_exp	int
+	O
1	int
)	O
/	O
2	int
*	O
2	int
;	O
if	O
(	O
nup_columns	int
==	O
0	int
)	O
nup_columns	int
=	O
1	int
;	O
nup_landscape	int
=	O
nup_exp	int
&	O
0x1	int
;	O
if	O
(	O
landscape	int
)	O
{	O
d_page_w	int
=	O
media	pointer
->	O
ury	double
-	O
media	pointer
->	O
lly	double
;	O
d_page_h	int
=	O
media	pointer
->	O
urx	double
-	O
media	pointer
->	O
llx	double
;	O
}	O
else	O
{	O
d_page_w	int
=	O
media	pointer
->	O
urx	double
-	O
media	pointer
->	O
llx	double
;	O
d_page_h	int
=	O
media	pointer
->	O
ury	double
-	O
media	pointer
->	O
lly	double
;	O
}	O
if	O
(	O
nup_landscape	int
)	O
{	O
nup_width	int
=	O
media	pointer
->	O
ury	double
-	O
media	pointer
->	O
lly	double
;	O
nup_height	int
=	O
media	pointer
->	O
urx	double
-	O
media	pointer
->	O
llx	double
;	O
}	O
else	O
{	O
nup_width	int
=	O
media	pointer
->	O
urx	double
-	O
media	pointer
->	O
llx	double
;	O
nup_height	int
=	O
media	pointer
->	O
ury	double
-	O
media	pointer
->	O
lly	double
;	O
}	O
{	O
double	O
w	int
,	O
h	int
;	O
w	int
=	O
(	O
(	O
double	O
)	O
nup_width	int
-	O
(	O
nup_columns	int
-	O
1	int
)	O
*	O
nup_xpad	int
)	O
/	O
nup_columns	int
;	O
h	int
=	O
(	O
(	O
double	O
)	O
nup_height	int
-	O
(	O
nup_rows	int
-	O
1	int
)	O
*	O
nup_ypad	int
)	O
/	O
nup_rows	int
;	O
nup_width	int
=	O
w	int
;	O
nup_height	int
=	O
h	int
;	O
w	int
=	O
w	int
/	O
(	O
media	pointer
->	O
urx	double
-	O
media	pointer
->	O
llx	double
)	O
;	O
h	int
=	O
h	int
/	O
(	O
media	pointer
->	O
ury	double
-	O
media	pointer
->	O
lly	double
)	O
;	O
nup_scale	double
=	O
w	int
<	O
h	int
?	O
w	int
:	O
h	int
;	O
}	O
if	O
(	O
underlay	pointer
!=	O
NULL	O
)	O
{	O
strhash_put	function
(	O
res_fonts	pointer
,	O
ul_font	pointer
,	O
strlen	function
(	O
ul_font	pointer
)	O
+	O
1	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
underlay	pointer
=	O
escape_string	function
(	O
underlay	pointer
)	O
;	O
}	O
ul_x	double
=	O
strtod	function
(	O
ul_position	pointer
,	O
&	O
cp	pointer
)	O
;	O
if	O
(	O
cp	pointer
==	O
ul_position	pointer
)	O
{	O
malformed_position	O
:	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"malformed underlay position: %s"	pointer
)	O
,	O
ul_position	pointer
)	O
)	O
;	O
}	O
if	O
(	O
ul_position	pointer
[	O
0	int
]	O
==	O
'-'	O
)	O
ul_x	double
+=	O
d_page_w	int
;	O
ul_y	double
=	O
strtod	function
(	O
cp	pointer
,	O
&	O
cp2	pointer
)	O
;	O
if	O
(	O
cp2	pointer
==	O
cp	pointer
)	O
goto	O
malformed_position	O
;	O
if	O
(	O
cp	pointer
[	O
0	int
]	O
==	O
'-'	O
)	O
ul_y	double
+=	O
d_page_h	int
;	O
if	O
(	O
!	O
ul_angle_p	int
)	O
ul_angle	double
=	O
(	O
atan2	function
(	O
-	O
d_page_h	int
,	O
d_page_w	int
)	O
/	O
3.14159265	int
*	O
180	int
)	O
;	O
if	O
(	O
strcmp	function
(	O
ul_style_str	pointer
,	O
"outline"	pointer
)	O
==	O
0	int
)	O
ul_style	int
=	O
UL_STYLE_OUTLINE	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
ul_style_str	pointer
,	O
"filled"	pointer
)	O
==	O
0	int
)	O
ul_style	int
=	O
UL_STYLE_FILLED	int
;	O
else	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"illegal underlay style: %s"	pointer
)	O
,	O
ul_style_str	pointer
)	O
)	O
;	O
d_header_w	int
=	O
d_page_w	int
;	O
switch	O
(	O
header	enum
)	O
{	O
case	O
HDR_NONE	int
:	O
d_header_h	int
=	O
0	int
;	O
break	O
;	O
case	O
HDR_SIMPLE	int
:	O
d_header_h	int
=	O
HFpt	struct
.	O
h	int
*	O
1.5	int
;	O
break	O
;	O
case	O
HDR_FANCY	int
:	O
d_header_h	int
=	O
36	int
;	O
break	O
;	O
}	O
if	O
(	O
help_highlight	int
)	O
{	O
printf	function
(	O
_	O
(	O
"Highlighting is supported for the following languages and file formats:\n\n"	pointer
)	O
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
buffer_clear	function
(	O
&	O
buffer	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
states_binary	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
" -f \""	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
states_config_file	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
"\" -p \""	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
states_path	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
"\" -s describe_languages "	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
enscript_library	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
"/hl/*.st"	pointer
)	O
;	O
system	function
(	O
buffer_ptr	function
(	O
&	O
buffer	pointer
)	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
if	O
(	O
output_language_pass_through	int
)	O
{	O
char	O
*	O
start_state	pointer
;	O
Buffer	struct
cmd	pointer
;	O
char	O
intbuf	array
[	O
256	int
]	O
;	O
if	O
(	O
hl_start_state	pointer
)	O
start_state	pointer
=	O
hl_start_state	pointer
;	O
else	O
if	O
(	O
highlight	int
)	O
start_state	pointer
=	O
NULL	O
;	O
else	O
start_state	pointer
=	O
"passthrough"	pointer
;	O
buffer_init	function
(	O
&	O
cmd	pointer
)	O
;	O
buffer_append	function
(	O
&	O
cmd	pointer
,	O
states_binary	pointer
)	O
;	O
buffer_append	function
(	O
&	O
cmd	pointer
,	O
" -f \""	pointer
)	O
;	O
buffer_append	function
(	O
&	O
cmd	pointer
,	O
states_config_file	pointer
)	O
;	O
buffer_append	function
(	O
&	O
cmd	pointer
,	O
"\" -p \""	pointer
)	O
;	O
buffer_append	function
(	O
&	O
cmd	pointer
,	O
states_path	pointer
)	O
;	O
buffer_append	function
(	O
&	O
cmd	pointer
,	O
"\" "	pointer
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
buffer_append	function
(	O
&	O
cmd	pointer
,	O
"-v "	pointer
)	O
;	O
if	O
(	O
start_state	pointer
)	O
{	O
buffer_append	function
(	O
&	O
cmd	pointer
,	O
"-s"	pointer
)	O
;	O
buffer_append	function
(	O
&	O
cmd	pointer
,	O
start_state	pointer
)	O
;	O
buffer_append	function
(	O
&	O
cmd	pointer
,	O
" "	pointer
)	O
;	O
}	O
buffer_append	function
(	O
&	O
cmd	pointer
,	O
"-Dcolor="	pointer
)	O
;	O
buffer_append	function
(	O
&	O
cmd	pointer
,	O
states_color	int
?	O
"1"	pointer
:	O
"0"	pointer
)	O
;	O
buffer_append	function
(	O
&	O
cmd	pointer
,	O
" "	pointer
)	O
;	O
buffer_append	function
(	O
&	O
cmd	pointer
,	O
"-Dstyle="	pointer
)	O
;	O
buffer_append	function
(	O
&	O
cmd	pointer
,	O
states_highlight_style	pointer
)	O
;	O
buffer_append	function
(	O
&	O
cmd	pointer
,	O
" "	pointer
)	O
;	O
buffer_append	function
(	O
&	O
cmd	pointer
,	O
"-Dlanguage="	pointer
)	O
;	O
buffer_append	function
(	O
&	O
cmd	pointer
,	O
output_language	pointer
)	O
;	O
buffer_append	function
(	O
&	O
cmd	pointer
,	O
" "	pointer
)	O
;	O
buffer_append	function
(	O
&	O
cmd	pointer
,	O
"-Dnum_input_files="	pointer
)	O
;	O
sprintf	function
(	O
intbuf	array
,	O
"%d"	pointer
,	O
optind	int
==	O
argc	int
?	O
1	int
:	O
argc	int
-	O
optind	int
)	O
;	O
buffer_append	function
(	O
&	O
cmd	pointer
,	O
intbuf	array
)	O
;	O
buffer_append	function
(	O
&	O
cmd	pointer
,	O
" "	pointer
)	O
;	O
buffer_append	function
(	O
&	O
cmd	pointer
,	O
"-Ddocument_title=\'"	pointer
)	O
;	O
if	O
(	O
(	O
cp	pointer
=	O
shell_escape	function
(	O
title	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
buffer_append	function
(	O
&	O
cmd	pointer
,	O
cp	pointer
)	O
;	O
free	function
(	O
cp	pointer
)	O
;	O
}	O
buffer_append	function
(	O
&	O
cmd	pointer
,	O
"\' "	pointer
)	O
;	O
buffer_append	function
(	O
&	O
cmd	pointer
,	O
"-Dtoc="	pointer
)	O
;	O
buffer_append	function
(	O
&	O
cmd	pointer
,	O
toc	int
?	O
"1"	pointer
:	O
"0"	pointer
)	O
;	O
if	O
(	O
helper_options	array
[	O
's'	O
]	O
)	O
{	O
Buffer	struct
*	O
opts	pointer
=	O
helper_options	array
[	O
's'	O
]	O
;	O
buffer_append	function
(	O
&	O
cmd	pointer
,	O
" "	pointer
)	O
;	O
buffer_append_len	function
(	O
&	O
cmd	pointer
,	O
buffer_ptr	function
(	O
opts	pointer
)	O
,	O
buffer_len	function
(	O
opts	pointer
)	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
optind	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
char	O
*	O
cp	pointer
;	O
if	O
(	O
(	O
cp	pointer
=	O
shell_escape	function
(	O
argv	pointer
[	O
i	int
]	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
buffer_append	function
(	O
&	O
cmd	pointer
,	O
" \'"	pointer
)	O
;	O
buffer_append	function
(	O
&	O
cmd	pointer
,	O
cp	pointer
)	O
;	O
buffer_append	function
(	O
&	O
cmd	pointer
,	O
"\'"	pointer
)	O
;	O
free	function
(	O
cp	pointer
)	O
;	O
}	O
}	O
if	O
(	O
is_open	function
(	O
&	O
is	pointer
,	O
stdin	pointer
,	O
NULL	O
,	O
buffer_ptr	function
(	O
&	O
cmd	pointer
)	O
)	O
)	O
{	O
open_output_file	function
(	O
)	O
;	O
process_file	function
(	O
"unused"	pointer
,	O
&	O
is	pointer
,	O
0	int
)	O
;	O
is_close	function
(	O
&	O
is	pointer
)	O
;	O
}	O
buffer_uninit	function
(	O
&	O
cmd	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
highlight	int
)	O
{	O
char	O
fbuf	array
[	O
256	int
]	O
;	O
buffer_clear	function
(	O
&	O
buffer	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
states_binary	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
" -f \""	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
states_config_file	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
"\" -p \""	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
states_path	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
"\""	pointer
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
" -v"	pointer
)	O
;	O
if	O
(	O
hl_start_state	pointer
)	O
{	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
" -s "	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
hl_start_state	pointer
)	O
;	O
}	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
" -Dcolor="	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
states_color	int
?	O
"1"	pointer
:	O
"0"	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
" -Dstyle="	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
states_highlight_style	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
" -Dfont_spec="	pointer
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
Fname	pointer
)	O
;	O
sprintf	function
(	O
fbuf	array
,	O
"@%g/%g"	pointer
,	O
Fpt	struct
.	O
w	int
,	O
Fpt	struct
.	O
h	int
)	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
fbuf	array
)	O
;	O
if	O
(	O
helper_options	array
[	O
's'	O
]	O
)	O
{	O
Buffer	struct
*	O
opts	pointer
=	O
helper_options	array
[	O
's'	O
]	O
;	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
" "	pointer
)	O
;	O
buffer_append_len	function
(	O
&	O
buffer	pointer
,	O
buffer_ptr	function
(	O
opts	pointer
)	O
,	O
buffer_len	function
(	O
opts	pointer
)	O
)	O
;	O
}	O
buffer_append	function
(	O
&	O
buffer	pointer
,	O
" \'%s\'"	pointer
)	O
;	O
input_filter	pointer
=	O
buffer_copy	function
(	O
&	O
buffer	pointer
)	O
;	O
input_filter_stdin	pointer
=	O
"-"	pointer
;	O
}	O
if	O
(	O
toc	int
)	O
{	O
toc_fp	pointer
=	O
tmpfile	function
(	O
)	O
;	O
if	O
(	O
toc_fp	pointer
==	O
NULL	O
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"couldn't create temporary toc file: %s"	pointer
)	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
)	O
;	O
}	O
if	O
(	O
optind	int
==	O
argc	int
)	O
{	O
memcpy	function
(	O
&	O
mod_tm	struct
,	O
&	O
run_tm	struct
,	O
sizeof	O
(	O
run_tm	struct
)	O
)	O
;	O
if	O
(	O
is_open	function
(	O
&	O
is	pointer
,	O
stdin	pointer
,	O
NULL	O
,	O
input_filter	pointer
)	O
)	O
{	O
open_output_file	function
(	O
)	O
;	O
process_file	function
(	O
title_given	int
?	O
title	pointer
:	O
""	pointer
,	O
&	O
is	pointer
,	O
0	int
)	O
;	O
is_close	function
(	O
&	O
is	pointer
)	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
;	O
optind	int
<	O
argc	int
;	O
optind	int
++	O
)	O
{	O
if	O
(	O
is_open	function
(	O
&	O
is	pointer
,	O
NULL	O
,	O
argv	pointer
[	O
optind	int
]	O
,	O
input_filter	pointer
)	O
)	O
{	O
struct	O
stat	struct
stat_st	struct
;	O
if	O
(	O
stat	struct
(	O
argv	pointer
[	O
optind	int
]	O
,	O
&	O
stat_st	struct
)	O
==	O
0	int
)	O
{	O
tim	long
=	O
stat_st	struct
.	O
st_mtime	O
;	O
tm	struct
=	O
localtime	function
(	O
&	O
tim	long
)	O
;	O
memcpy	function
(	O
&	O
mod_tm	struct
,	O
tm	struct
,	O
sizeof	O
(	O
*	O
tm	struct
)	O
)	O
;	O
open_output_file	function
(	O
)	O
;	O
process_file	function
(	O
argv	pointer
[	O
optind	int
]	O
,	O
&	O
is	pointer
,	O
0	int
)	O
;	O
}	O
else	O
ERROR	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"couldn't stat input file \"%s\": %s"	pointer
)	O
,	O
argv	pointer
[	O
optind	int
]	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
)	O
;	O
is_close	function
(	O
&	O
is	pointer
)	O
;	O
}	O
}	O
}	O
if	O
(	O
toc	int
)	O
{	O
toc	int
=	O
0	int
;	O
special_escapes	int
=	O
1	int
;	O
line_numbers	int
=	O
0	int
;	O
if	O
(	O
fseek	function
(	O
toc_fp	pointer
,	O
0	int
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"couldn't rewind toc file: %s"	pointer
)	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
)	O
;	O
memcpy	function
(	O
&	O
mod_tm	struct
,	O
&	O
run_tm	struct
,	O
sizeof	O
(	O
run_tm	struct
)	O
)	O
;	O
if	O
(	O
is_open	function
(	O
&	O
is	pointer
,	O
toc_fp	pointer
,	O
NULL	O
,	O
NULL	O
)	O
)	O
{	O
process_file	function
(	O
_	O
(	O
"Table of Contents"	pointer
)	O
,	O
&	O
is	pointer
,	O
1	int
)	O
;	O
is_close	function
(	O
&	O
is	pointer
)	O
;	O
}	O
}	O
dump_ps_trailer	function
(	O
)	O
;	O
if	O
(	O
ofp	pointer
!=	O
NULL	O
&&	O
append_ctrl_D	int
)	O
fprintf	function
(	O
ofp	pointer
,	O
"\004\n"	pointer
)	O
;	O
}	O
close_output_file	function
(	O
)	O
;	O
if	O
(	O
ofp	pointer
==	O
NULL	O
)	O
{	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	pointer
,	O
_	O
(	O
"no output generated\n"	pointer
)	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
output_language_pass_through	int
)	O
{	O
if	O
(	O
output_file	pointer
==	O
OUTPUT_FILE_NONE	O
)	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	pointer
,	O
_	O
(	O
"output sent to %s\n"	pointer
)	O
,	O
printer	pointer
?	O
printer	pointer
:	O
_	O
(	O
"printer"	pointer
)	O
)	O
)	O
;	O
else	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	pointer
,	O
_	O
(	O
"output left in %s\n"	pointer
)	O
,	O
output_file	pointer
==	O
OUTPUT_FILE_STDOUT	O
?	O
"-"	pointer
:	O
output_file	pointer
)	O
)	O
;	O
}	O
else	O
{	O
unsigned	O
int	O
real_total_pages	int
;	O
if	O
(	O
nup	int
>	O
1	int
)	O
{	O
if	O
(	O
total_pages	int
>	O
0	int
)	O
real_total_pages	int
=	O
(	O
total_pages	int
-	O
1	int
)	O
/	O
nup	int
+	O
1	int
;	O
else	O
real_total_pages	int
=	O
0	int
;	O
}	O
else	O
real_total_pages	int
=	O
total_pages	int
;	O
char	O
message	array
[	O
80	int
]	O
;	O
snprintf	function
(	O
message	array
,	O
sizeof	O
message	array
,	O
"%s%s%s%s%s"	pointer
,	O
"[ "	pointer
,	O
ngettext	function
(	O
"%d page"	pointer
,	O
"%d pages"	pointer
,	O
real_total_pages	int
)	O
,	O
" * "	pointer
,	O
ngettext	function
(	O
"%d copy"	pointer
,	O
"%d copies"	pointer
,	O
num_copies	int
)	O
,	O
" ]"	pointer
)	O
;	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	pointer
,	O
message	array
,	O
real_total_pages	int
,	O
num_copies	int
)	O
)	O
;	O
if	O
(	O
output_file	pointer
==	O
OUTPUT_FILE_NONE	O
)	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	pointer
,	O
_	O
(	O
" sent to %s\n"	pointer
)	O
,	O
printer	pointer
?	O
printer	pointer
:	O
_	O
(	O
"printer"	pointer
)	O
)	O
)	O
;	O
else	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	pointer
,	O
_	O
(	O
" left in %s\n"	pointer
)	O
,	O
output_file	pointer
==	O
OUTPUT_FILE_STDOUT	O
?	O
"-"	pointer
:	O
output_file	pointer
)	O
)	O
;	O
if	O
(	O
num_truncated_lines	int
)	O
{	O
retval	int
|=	O
2	int
;	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	pointer
,	O
ngettext	function
(	O
"%d line was %s\n"	pointer
,	O
"%d lines were %s\n"	pointer
,	O
num_truncated_lines	int
)	O
,	O
num_truncated_lines	int
,	O
line_end	enum
==	O
LE_TRUNCATE	int
?	O
_	O
(	O
"truncated"	pointer
)	O
:	O
_	O
(	O
"wrapped"	pointer
)	O
)	O
)	O
;	O
}	O
if	O
(	O
num_missing_chars	int
)	O
{	O
retval	int
|=	O
4	int
;	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	pointer
,	O
ngettext	function
(	O
"%d character was missing\n"	pointer
,	O
"%d characters were missing\n"	pointer
,	O
num_missing_chars	int
)	O
,	O
num_missing_chars	int
)	O
)	O
;	O
if	O
(	O
list_missing_characters	int
)	O
{	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	pointer
,	O
_	O
(	O
"missing character codes (decimal):\n"	pointer
)	O
)	O
)	O
;	O
do_list_missing_characters	function
(	O
missing_chars	array
)	O
;	O
}	O
}	O
if	O
(	O
num_non_printable_chars	int
)	O
{	O
retval	int
|=	O
8	int
;	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	pointer
,	O
ngettext	function
(	O
"%d non-printable character\n"	pointer
,	O
"%d non-printable characters\n"	pointer
,	O
num_non_printable_chars	int
)	O
,	O
num_non_printable_chars	int
)	O
)	O
;	O
if	O
(	O
list_missing_characters	int
)	O
{	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	pointer
,	O
_	O
(	O
"non-printable character codes (decimal):\n"	pointer
)	O
)	O
)	O
;	O
do_list_missing_characters	function
(	O
non_printable_chars	array
)	O
;	O
}	O
}	O
}	O
buffer_uninit	function
(	O
&	O
buffer	pointer
)	O
;	O
if	O
(	O
!	O
extended_return_values	int
)	O
retval	int
=	O
0	int
;	O
return	O
retval	int
;	O
}	O
static	O
void	O
open_output_file	function
(	O
)	O
{	O
if	O
(	O
ofp	pointer
)	O
return	O
;	O
if	O
(	O
output_file	pointer
==	O
OUTPUT_FILE_NONE	O
)	O
{	O
char	O
spooler_options	array
[	O
512	int
]	O
;	O
spooler_options	array
[	O
0	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
mail	int
)	O
strcat	function
(	O
spooler_options	array
,	O
"-m "	pointer
)	O
;	O
if	O
(	O
no_job_header	int
)	O
{	O
strcat	function
(	O
spooler_options	array
,	O
no_job_header_switch	pointer
)	O
;	O
strcat	function
(	O
spooler_options	array
,	O
" "	pointer
)	O
;	O
}	O
if	O
(	O
printer_options	pointer
)	O
strcat	function
(	O
spooler_options	array
,	O
printer_options	pointer
)	O
;	O
ofp	pointer
=	O
printer_open	function
(	O
spooler_command	pointer
,	O
spooler_options	array
,	O
queue_param	pointer
,	O
printer	pointer
,	O
&	O
printer_context	pointer
)	O
;	O
if	O
(	O
ofp	pointer
==	O
NULL	O
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"couldn't open printer `%s': %s"	pointer
)	O
,	O
printer	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
output_file	pointer
==	O
OUTPUT_FILE_STDOUT	O
)	O
ofp	pointer
=	O
stdout	pointer
;	O
else	O
{	O
ofp	pointer
=	O
fopen	function
(	O
output_file	pointer
,	O
"w"	pointer
)	O
;	O
if	O
(	O
ofp	pointer
==	O
NULL	O
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"couldn't create output file \"%s\": %s"	pointer
)	O
,	O
output_file	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
)	O
;	O
}	O
}	O
static	O
void	O
close_output_file	function
(	O
)	O
{	O
if	O
(	O
ofp	pointer
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
output_file	pointer
==	O
OUTPUT_FILE_NONE	O
)	O
printer_close	function
(	O
printer_context	pointer
)	O
;	O
else	O
if	O
(	O
output_file	pointer
!=	O
OUTPUT_FILE_STDOUT	O
)	O
if	O
(	O
fclose	function
(	O
ofp	pointer
)	O
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"couldn't close output file \"%s\": %s"	pointer
)	O
,	O
output_file	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
)	O
;	O
}	O
static	O
void	O
handle_env_options	function
(	O
char	O
*	O
var	pointer
)	O
{	O
int	O
argc	int
;	O
char	O
*	O
*	O
argv	pointer
;	O
char	O
*	O
string	pointer
;	O
char	O
*	O
str	pointer
;	O
int	O
i	int
;	O
string	pointer
=	O
getenv	function
(	O
var	pointer
)	O
;	O
if	O
(	O
string	pointer
==	O
NULL	O
)	O
return	O
;	O
MESSAGE	O
(	O
2	int
,	O
(	O
stderr	pointer
,	O
"handle_env_options(): %s=\"%s\"\n"	pointer
,	O
var	pointer
,	O
string	pointer
)	O
)	O
;	O
str	pointer
=	O
xstrdup	function
(	O
string	pointer
)	O
;	O
argc	int
=	O
(	O
strlen	function
(	O
str	pointer
)	O
+	O
1	int
)	O
/	O
2	int
+	O
2	int
;	O
argv	pointer
=	O
xcalloc	function
(	O
argc	int
,	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
argc	int
=	O
0	int
;	O
argv	pointer
[	O
argc	int
++	O
]	O
=	O
program	pointer
;	O
i	int
=	O
0	int
;	O
while	O
(	O
str	pointer
[	O
i	int
]	O
)	O
{	O
for	O
(	O
;	O
str	pointer
[	O
i	int
]	O
&&	O
isspace	function
(	O
str	pointer
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
;	O
if	O
(	O
!	O
str	pointer
[	O
i	int
]	O
)	O
break	O
;	O
if	O
(	O
str	pointer
[	O
i	int
]	O
==	O
'"'	O
||	O
str	pointer
[	O
i	int
]	O
==	O
'\''	O
)	O
{	O
int	O
endch	int
=	O
str	pointer
[	O
i	int
++	O
]	O
;	O
argv	pointer
[	O
argc	int
++	O
]	O
=	O
str	pointer
+	O
i	int
;	O
for	O
(	O
;	O
str	pointer
[	O
i	int
]	O
&&	O
str	pointer
[	O
i	int
]	O
!=	O
endch	int
;	O
i	int
++	O
)	O
;	O
if	O
(	O
!	O
str	pointer
[	O
i	int
]	O
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"syntax error in option string %s=\"%s\":\nmissing end of quotation: %c"	pointer
)	O
,	O
var	pointer
,	O
string	pointer
,	O
endch	int
)	O
)	O
;	O
str	pointer
[	O
i	int
++	O
]	O
=	O
'\0'	O
;	O
}	O
else	O
{	O
argv	pointer
[	O
argc	int
++	O
]	O
=	O
str	pointer
+	O
i	int
;	O
for	O
(	O
;	O
str	pointer
[	O
i	int
]	O
&&	O
!	O
isspace	function
(	O
str	pointer
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
;	O
if	O
(	O
str	pointer
[	O
i	int
]	O
)	O
str	pointer
[	O
i	int
++	O
]	O
=	O
'\0'	O
;	O
}	O
}	O
argv	pointer
[	O
argc	int
]	O
=	O
NULL	O
;	O
MESSAGE	O
(	O
2	int
,	O
(	O
stderr	pointer
,	O
"found following options (argc=%d):\n"	pointer
,	O
argc	int
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
MESSAGE	O
(	O
2	int
,	O
(	O
stderr	pointer
,	O
"%3d = \"%s\"\n"	pointer
,	O
i	int
,	O
argv	pointer
[	O
i	int
]	O
)	O
)	O
;	O
handle_options	function
(	O
argc	int
,	O
argv	pointer
)	O
;	O
if	O
(	O
optind	int
!=	O
argc	int
)	O
{	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	pointer
,	O
_	O
(	O
"warning: didn't process following options from environment variable %s:\n"	pointer
)	O
,	O
var	pointer
)	O
)	O
;	O
for	O
(	O
;	O
optind	int
<	O
argc	int
;	O
optind	int
++	O
)	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	pointer
,	O
_	O
(	O
"  option %d = \"%s\"\n"	pointer
)	O
,	O
optind	int
,	O
argv	pointer
[	O
optind	int
]	O
)	O
)	O
;	O
}	O
xfree	function
(	O
argv	pointer
)	O
;	O
}	O
static	O
void	O
handle_options	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
int	O
c	int
;	O
PageRange	struct
*	O
prange	pointer
;	O
optind	int
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
int	O
option_index	int
=	O
0	int
;	O
const	O
char	O
*	O
cp	pointer
;	O
int	O
i	int
;	O
c	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
"#:123456789a:A:b:BcC::d:D:e::E::f:F:gGhH::i:I:jJ:kKlL:mM:n:N:o:Op:P:qrRs:S:t:T:u::U:vVw:W:X:zZ"	pointer
,	O
long_options	array
,	O
&	O
option_index	int
)	O
;	O
if	O
(	O
c	int
==	O
-	O
1	int
)	O
break	O
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
0	int
:	O
cp	pointer
=	O
long_options	array
[	O
option_index	int
]	O
.	O
name	pointer
;	O
if	O
(	O
strcmp	function
(	O
cp	pointer
,	O
"columns"	pointer
)	O
==	O
0	int
)	O
{	O
num_columns	int
=	O
atoi	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
num_columns	int
<	O
1	int
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"number of columns must be larger than zero"	pointer
)	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
num_columns	int
=	O
c	int
-	O
'0'	O
;	O
break	O
;	O
case	O
'a'	O
:	O
prange	pointer
=	O
(	O
PageRange	struct
*	O
)	O
xcalloc	function
(	O
1	int
,	O
sizeof	O
(	O
PageRange	struct
)	O
)	O
;	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"odd"	pointer
)	O
==	O
0	int
)	O
prange	pointer
->	O
odd	int
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"even"	pointer
)	O
==	O
0	int
)	O
prange	pointer
->	O
even	int
=	O
1	int
;	O
else	O
{	O
cp	pointer
=	O
strchr	function
(	O
optarg	pointer
,	O
'-'	O
)	O
;	O
if	O
(	O
cp	pointer
)	O
{	O
if	O
(	O
optarg	pointer
[	O
0	int
]	O
==	O
'-'	O
)	O
prange	pointer
->	O
end	int
=	O
atoi	function
(	O
optarg	pointer
+	O
1	int
)	O
;	O
else	O
if	O
(	O
cp	pointer
[	O
1	int
]	O
==	O
'\0'	O
)	O
{	O
prange	pointer
->	O
start	int
=	O
atoi	function
(	O
optarg	pointer
)	O
;	O
prange	pointer
->	O
end	int
=	O
(	O
unsigned	O
int	O
)	O
-	O
1	int
;	O
}	O
else	O
{	O
prange	pointer
->	O
start	int
=	O
atoi	function
(	O
optarg	pointer
)	O
;	O
prange	pointer
->	O
end	int
=	O
atoi	function
(	O
cp	pointer
+	O
1	int
)	O
;	O
}	O
}	O
else	O
prange	pointer
->	O
start	int
=	O
prange	pointer
->	O
end	int
=	O
atoi	function
(	O
optarg	pointer
)	O
;	O
}	O
prange	pointer
->	O
next	pointer
=	O
page_ranges	pointer
;	O
page_ranges	pointer
=	O
prange	pointer
;	O
break	O
;	O
case	O
'A'	O
:	O
file_align	int
=	O
atoi	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
file_align	int
==	O
0	int
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"file alignment must be larger than zero"	pointer
)	O
)	O
)	O
;	O
break	O
;	O
case	O
'b'	O
:	O
page_header	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'B'	O
:	O
header	enum
=	O
HDR_NONE	int
;	O
break	O
;	O
case	O
'c'	O
:	O
line_end	enum
=	O
LE_TRUNCATE	int
;	O
break	O
;	O
case	O
'C'	O
:	O
line_numbers	int
=	O
1	int
;	O
if	O
(	O
optarg	pointer
)	O
start_line_number	int
=	O
atoi	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'd'	O
:	O
case	O
'P'	O
:	O
xfree	function
(	O
printer	pointer
)	O
;	O
printer	pointer
=	O
xstrdup	function
(	O
optarg	pointer
)	O
;	O
output_file	pointer
=	O
OUTPUT_FILE_NONE	O
;	O
break	O
;	O
case	O
'D'	O
:	O
parse_key_value_pair	function
(	O
pagedevice	pointer
,	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'e'	O
:	O
special_escapes	int
=	O
1	int
;	O
if	O
(	O
optarg	pointer
)	O
{	O
if	O
(	O
isdigit	function
(	O
optarg	pointer
[	O
0	int
]	O
)	O
)	O
escape_char	int
=	O
(	O
int	O
)	O
strtoul	function
(	O
optarg	pointer
,	O
NULL	O
,	O
0	int
)	O
;	O
else	O
escape_char	int
=	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
optarg	pointer
)	O
[	O
0	int
]	O
;	O
}	O
break	O
;	O
case	O
'E'	O
:	O
highlight	int
=	O
1	int
;	O
special_escapes	int
=	O
1	int
;	O
escape_char	int
=	O
'\0'	O
;	O
hl_start_state	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'f'	O
:	O
if	O
(	O
!	O
parse_font_spec	function
(	O
optarg	pointer
,	O
&	O
Fname	pointer
,	O
&	O
Fpt	struct
,	O
NULL	O
)	O
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"malformed font spec: %s"	pointer
)	O
,	O
optarg	pointer
)	O
)	O
;	O
user_body_font_defined	int
=	O
1	int
;	O
break	O
;	O
case	O
'F'	O
:	O
if	O
(	O
!	O
parse_font_spec	function
(	O
optarg	pointer
,	O
&	O
HFname	pointer
,	O
&	O
HFpt	struct
,	O
NULL	O
)	O
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"malformed font spec: %s"	pointer
)	O
,	O
optarg	pointer
)	O
)	O
;	O
break	O
;	O
case	O
'g'	O
:	O
break	O
;	O
case	O
'G'	O
:	O
header	enum
=	O
HDR_FANCY	int
;	O
if	O
(	O
optarg	pointer
)	O
fancy_header_name	pointer
=	O
optarg	pointer
;	O
else	O
fancy_header_name	pointer
=	O
fancy_header_default	pointer
;	O
if	O
(	O
!	O
file_existsp	function
(	O
fancy_header_name	pointer
,	O
".hdr"	pointer
)	O
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"couldn't find header definition file \"%s.hdr\""	pointer
)	O
,	O
fancy_header_name	pointer
)	O
)	O
;	O
break	O
;	O
case	O
'h'	O
:	O
no_job_header	int
=	O
1	int
;	O
break	O
;	O
case	O
'H'	O
:	O
if	O
(	O
optarg	pointer
)	O
highlight_bars	int
=	O
atoi	function
(	O
optarg	pointer
)	O
;	O
else	O
highlight_bars	int
=	O
2	int
;	O
break	O
;	O
case	O
'i'	O
:	O
line_indent_spec	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'I'	O
:	O
input_filter	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'j'	O
:	O
borders	int
=	O
1	int
;	O
break	O
;	O
case	O
'k'	O
:	O
page_prefeed	int
=	O
1	int
;	O
break	O
;	O
case	O
'K'	O
:	O
page_prefeed	int
=	O
0	int
;	O
break	O
;	O
case	O
'l'	O
:	O
lines_per_page	int
=	O
66	int
;	O
header	enum
=	O
HDR_NONE	int
;	O
break	O
;	O
case	O
'L'	O
:	O
lines_per_page	int
=	O
atoi	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
lines_per_page	int
<=	O
0	int
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"must print at least one line per each page: %s"	pointer
)	O
,	O
argv	pointer
[	O
optind	int
]	O
)	O
)	O
;	O
break	O
;	O
case	O
'm'	O
:	O
mail	int
=	O
1	int
;	O
break	O
;	O
case	O
'M'	O
:	O
media_name	pointer
=	O
xstrdup	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'n'	O
:	O
case	O
'#'	O
:	O
num_copies	int
=	O
atoi	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'N'	O
:	O
if	O
(	O
!	O
(	O
optarg	pointer
[	O
0	int
]	O
==	O
'n'	O
||	O
optarg	pointer
[	O
0	int
]	O
==	O
'r'	O
)	O
||	O
optarg	pointer
[	O
1	int
]	O
!=	O
'\0'	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: illegal newline character specifier: '%s': expected 'n' or 'r'\n"	pointer
)	O
,	O
program	pointer
,	O
optarg	pointer
)	O
;	O
goto	O
option_error	O
;	O
}	O
if	O
(	O
optarg	pointer
[	O
0	int
]	O
==	O
'n'	O
)	O
nl	int
=	O
'\n'	O
;	O
else	O
nl	int
=	O
'\r'	O
;	O
break	O
;	O
case	O
'o'	O
:	O
case	O
'p'	O
:	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"-"	pointer
)	O
==	O
0	int
)	O
output_file	pointer
=	O
OUTPUT_FILE_STDOUT	O
;	O
else	O
output_file	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'O'	O
:	O
list_missing_characters	int
=	O
1	int
;	O
break	O
;	O
case	O
'q'	O
:	O
quiet	int
=	O
1	int
;	O
verbose	int
=	O
0	int
;	O
break	O
;	O
case	O
'r'	O
:	O
landscape	int
=	O
1	int
;	O
break	O
;	O
case	O
'R'	O
:	O
landscape	int
=	O
0	int
;	O
break	O
;	O
case	O
's'	O
:	O
baselineskip	double
=	O
atof	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'S'	O
:	O
parse_key_value_pair	function
(	O
statusdict	pointer
,	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
't'	O
:	O
case	O
'J'	O
:	O
title	pointer
=	O
optarg	pointer
;	O
title_given	int
=	O
1	int
;	O
break	O
;	O
case	O
'T'	O
:	O
tabsize	int
=	O
atoi	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
tabsize	int
<=	O
0	int
)	O
tabsize	int
=	O
1	int
;	O
break	O
;	O
case	O
'u'	O
:	O
underlay	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'U'	O
:	O
nup	int
=	O
atoi	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'v'	O
:	O
if	O
(	O
optarg	pointer
)	O
verbose	int
=	O
atoi	function
(	O
optarg	pointer
)	O
;	O
else	O
verbose	int
++	O
;	O
quiet	int
=	O
0	int
;	O
break	O
;	O
case	O
'V'	O
:	O
version	double
(	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
break	O
;	O
case	O
'w'	O
:	O
output_language	pointer
=	O
optarg	pointer
;	O
if	O
(	O
strcmp	function
(	O
output_language	pointer
,	O
"PostScript"	pointer
)	O
!=	O
0	int
)	O
output_language_pass_through	int
=	O
1	int
;	O
break	O
;	O
case	O
'W'	O
:	O
cp	pointer
=	O
strchr	function
(	O
optarg	pointer
,	O
','	O
)	O
;	O
if	O
(	O
cp	pointer
==	O
NULL	O
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"malformed argument `%s' for option -W, --option: no comma found"	pointer
)	O
,	O
optarg	pointer
)	O
)	O
;	O
if	O
(	O
cp	pointer
-	O
optarg	pointer
!=	O
1	int
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"helper application specification must be single character: %s"	pointer
)	O
,	O
optarg	pointer
)	O
)	O
;	O
i	int
=	O
*	O
optarg	pointer
;	O
cp	pointer
++	O
;	O
if	O
(	O
helper_options	array
[	O
i	int
]	O
==	O
NULL	O
)	O
helper_options	array
[	O
i	int
]	O
=	O
buffer_alloc	function
(	O
)	O
;	O
else	O
{	O
buffer_append	function
(	O
helper_options	array
[	O
i	int
]	O
,	O
" "	pointer
)	O
;	O
}	O
buffer_append	function
(	O
helper_options	array
[	O
i	int
]	O
,	O
cp	pointer
)	O
;	O
break	O
;	O
case	O
'X'	O
:	O
xfree	function
(	O
encoding_name	pointer
)	O
;	O
encoding_name	pointer
=	O
xstrdup	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'z'	O
:	O
interpret_formfeed	int
=	O
0	int
;	O
break	O
;	O
case	O
'Z'	O
:	O
pass_through	int
=	O
1	int
;	O
break	O
;	O
case	O
128	int
:	O
if	O
(	O
!	O
parse_font_spec	function
(	O
optarg	pointer
,	O
&	O
ul_font	pointer
,	O
&	O
ul_ptsize	struct
,	O
NULL	O
)	O
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"malformed font spec: %s"	pointer
)	O
,	O
optarg	pointer
)	O
)	O
;	O
break	O
;	O
case	O
129	int
:	O
ul_gray	double
=	O
atof	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
130	int
:	O
xfree	function
(	O
page_label_format	pointer
)	O
;	O
page_label_format	pointer
=	O
xstrdup	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
131	int
:	O
strhash_put	function
(	O
download_fonts	pointer
,	O
optarg	pointer
,	O
strlen	function
(	O
optarg	pointer
)	O
+	O
1	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
132	int
:	O
ul_angle	double
=	O
atof	function
(	O
optarg	pointer
)	O
;	O
ul_angle_p	int
=	O
1	int
;	O
break	O
;	O
case	O
133	int
:	O
xfree	function
(	O
ul_position	pointer
)	O
;	O
ul_position	pointer
=	O
xstrdup	function
(	O
optarg	pointer
)	O
;	O
ul_position_p	int
=	O
1	int
;	O
break	O
;	O
case	O
134	int
:	O
xfree	function
(	O
npf_name	pointer
)	O
;	O
npf_name	pointer
=	O
xstrdup	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
135	int
:	O
usage	function
(	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
break	O
;	O
case	O
136	int
:	O
highlight_bar_gray	double
=	O
atof	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
137	int
:	O
xfree	function
(	O
ul_style_str	pointer
)	O
;	O
ul_style_str	pointer
=	O
xstrdup	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
138	int
:	O
input_filter_stdin	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
139	int
:	O
printer_options	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
140	int
:	O
slicing	int
=	O
1	int
;	O
slice	int
=	O
atoi	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
slice	int
<=	O
0	int
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"slice must be greater than zero"	pointer
)	O
)	O
)	O
;	O
break	O
;	O
case	O
141	int
:	O
help_highlight	int
=	O
1	int
;	O
break	O
;	O
case	O
142	int
:	O
if	O
(	O
optarg	pointer
==	O
NULL	O
)	O
states_color	int
=	O
1	int
;	O
else	O
states_color	int
=	O
atoi	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
143	int
:	O
if	O
(	O
optarg	pointer
)	O
{	O
xfree	function
(	O
mark_wrapped_lines_style_name	pointer
)	O
;	O
mark_wrapped_lines_style_name	pointer
=	O
xstrdup	function
(	O
optarg	pointer
)	O
;	O
}	O
else	O
mark_wrapped_lines_style	enum
=	O
MWLS_BOX	int
;	O
break	O
;	O
case	O
144	int
:	O
margins_spec	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
145	int
:	O
nup_xpad	int
=	O
atoi	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
146	int
:	O
nup_ypad	int
=	O
atoi	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
147	int
:	O
line_end	enum
=	O
LE_WORD_WRAP	int
;	O
break	O
;	O
case	O
148	int
:	O
horizontal_column_height	double
=	O
atof	function
(	O
optarg	pointer
)	O
;	O
formfeed_type	enum
=	O
FORMFEED_HCOLUMN	int
;	O
break	O
;	O
case	O
149	int
:	O
pslevel	int
=	O
atoi	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
150	int
:	O
rotate_even_pages	int
=	O
1	int
;	O
break	O
;	O
case	O
151	int
:	O
xfree	function
(	O
states_highlight_style	pointer
)	O
;	O
states_highlight_style	pointer
=	O
xstrdup	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
152	int
:	O
nup_columnwise	int
=	O
1	int
;	O
break	O
;	O
case	O
153	int
:	O
swap_even_page_margins	int
=	O
1	int
;	O
break	O
;	O
case	O
154	int
:	O
extended_return_values	int
=	O
1	int
;	O
break	O
;	O
case	O
155	int
:	O
page_footer	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
156	int
:	O
continuous_page_numbers	int
=	O
1	int
;	O
break	O
;	O
case	O
'?'	O
:	O
option_error	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Try `%s --help' for more information.\n"	pointer
)	O
,	O
program	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
"Hey!  main() didn't handle option \"%c\" (%d)"	pointer
,	O
c	int
,	O
c	int
)	O
;	O
if	O
(	O
optarg	pointer
)	O
printf	function
(	O
" with arg %s"	pointer
,	O
optarg	pointer
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
"This is a bug!"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
}	O
}	O
static	O
void	O
usage	function
(	O
)	O
{	O
printf	function
(	O
_	O
(	O
"Usage: %s [OPTION]... [FILE]...\nMandatory arguments to long options are mandatory for short options too.\n  -#                         an alias for option -n, --copies\n  -1                         same as --columns=1\n  -2                         same as --columns=2\n      --columns=NUM          specify the number of columns per page\n  -a, --pages=PAGES          specify which pages are printed\n  -A, --file-align=ALIGN     align separate input files to ALIGN\n  -b, --header=HEADER        set page header\n  -B, --no-header            no page headers\n  -c, --truncate-lines       cut long lines (default is to wrap)\n  -C[START], --line-numbers[=START]\n                             precede each line with its line number\n  -d                         an alias for option --printer\n  -D, --setpagedevice=KEY[:VALUE]\n                             pass a page device definition to output\n  -e[CHAR], --escapes[=CHAR]       enable special escape interpretation\n"	pointer
)	O
,	O
program	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"  -E[LANG], --highlight[=LANG]     highlight source code\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -f, --font=NAME            use font NAME for body text\n  -F, --header-font=NAME     use font NAME for header texts\n  -g, --print-anyway         nothing (compatibility option)\n  -G                         same as --fancy-header\n      --fancy-header[=NAME]  select fancy page header\n  -h, --no-job-header        suppress the job header page\n  -H[NUM], --highlight-bars[=NUM]  specify how high highlight bars are\n  -i, --indent=NUM           set line indent to NUM characters\n  -I, --filter=CMD           read input files through input filter CMD\n  -j, --borders              print borders around columns\n  -J,                        an alias for option --title\n  -k, --page-prefeed         enable page prefeed\n  -K, --no-page-prefeed      disable page prefeed\n  -l, --lineprinter          simulate lineprinter, this is an alias for:\n                               --lines-per-page=66, --no-header, --portrait,\n                               --columns=1\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -L, --lines-per-page=NUM   specify how many lines are printed on each page\n  -m, --mail                 send mail upon completion\n  -M, --media=NAME           use output media NAME\n  -n, --copies=NUM           print NUM copies of each page\n  -N, --newline=NL           select the newline character.  Possible\n                             values for NL are: n (`\\n') and r (`\\r').\n  -o                         an alias for option --output\n  -O, --missing-characters   list missing characters\n  -p, --output=FILE          leave output to file FILE.  If FILE is `-',\n                             leave output to stdout.\n  -P, --printer=NAME         print output to printer NAME\n  -q, --quiet, --silent      be really quiet\n  -r, --landscape            print in landscape mode\n  -R, --portrait             print in portrait mode\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -s, --baselineskip=NUM     set baselineskip to NUM\n  -S, --statusdict=KEY[:VALUE]\n                             pass a statusdict definition to the output\n  -t, --title=TITLE          set banner page's job title to TITLE.  Option\n                             sets also the name of the input file stdin.\n  -T, --tabsize=NUM          set tabulator size to NUM\n  -u[TEXT], --underlay[=TEXT]      print TEXT under every page\n  -U, --nup=NUM              print NUM logical pages on each output page\n  -v, --verbose              tell what we are doing\n  -V, --version              print version number\n  -w, --language=LANG        set output language to LANG\n  -W, --options=APP,OPTION   pass option OPTION to helper application APP\n  -X, --encoding=NAME        use input encoding NAME\n  -z, --no-formfeed          do not interpret form feed characters\n  -Z, --pass-through         pass through PostScript and PCL files\n                             without any modifications\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"Long-only options:\n  --color[=bool]             create color outputs with states\n  --continuous-page-numbers  count page numbers across input files.  Don't\n                             restart numbering at beginning of each file.\n  --download-font=NAME       download font NAME\n  --extended-return-values   enable extended return values\n  --filter-stdin=NAME        specify how stdin is shown to the input filter\n  --footer=FOOTER            set page footer\n  --h-column-height=HEIGHT   set the horizontal column height to HEIGHT\n  --help                     print this help and exit\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  --help-highlight           describe all supported --highlight languages\n                             and file formats\n  --highlight-bar-gray=NUM   print highlight bars with gray NUM (0 - 1)\n  --list-media               list names of all known media\n  --margins=LEFT:RIGHT:TOP:BOTTOM\n                             adjust page marginals\n  --mark-wrapped-lines[STYLE]\n                             mark wrapped lines in the output with STYLE\n  --non-printable-format=FMT specify how non-printable chars are printed\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  --nup-columnwise           layout pages in the N-up printing columnwise\n  --nup-xpad=NUM             set the page x-padding of N-up printing to NUM\n  --nup-ypad=NUM             set the page y-padding of N-up printing to NUM\n  --page-label-format=FMT    set page label format to FMT\n  --ps-level=LEVEL           set the PostScript language level that enscript\n                             should use\n  --printer-options=OPTIONS  pass extra options to the printer command\n  --rotate-even-pages        rotate even-numbered pages 180 degrees\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  --slice=NUM                print vertical slice NUM\n  --style=STYLE              use highlight style STYLE\n  --swap-even-page-margins   swap left and right side margins for each even\n                             numbered page\n  --toc                      print table of contents\n  --ul-angle=ANGLE           set underlay text's angle to ANGLE\n  --ul-font=NAME             print underlays with font NAME\n  --ul-gray=NUM              print underlays with gray value NUM\n  --ul-position=POS          set underlay's starting position to POS\n  --ul-style=STYLE           print underlays with style STYLE\n  --word-wrap                wrap long lines from word boundaries\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"\nReport bugs to <%s>.\n"	pointer
)	O
,	O
PACKAGE_BUGREPORT	pointer
)	O
;	O
}	O
static	O
void	O
version	double
(	O
)	O
{	O
printf	function
(	O
"%s\nCopyright (C) 1995-2003, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n%s comes with NO WARRANTY, to the extent permitted by law.\nYou may redistribute copies of %s under the terms of the GNU\nGeneral Public License, version 3 or, at your option, any later version.\nFor more information about these matters, see the files named COPYING.\n"	pointer
,	O
PACKAGE_STRING	pointer
,	O
PACKAGE_NAME	pointer
,	O
PACKAGE_NAME	pointer
)	O
;	O
}	O
