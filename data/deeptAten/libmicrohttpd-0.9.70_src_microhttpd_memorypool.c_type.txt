static	O
size_t	long
MHD_sys_page_size_	long
=	O
MHD_DEF_PAGE_SIZE_	O
;	O
void	O
MHD_init_mem_pools_	function
(	O
void	O
)	O
{	O
MHD_sys_page_size_	long
=	O
MHD_DEF_PAGE_SIZE_	O
;	O
}	O
struct	O
MemoryPool	struct
{	O
uint8_t	char
*	O
memory	pointer
;	O
size_t	long
size	long
;	O
size_t	long
pos	long
;	O
size_t	long
end	long
;	O
bool	bool
is_mmap	bool
;	O
}	O
;	O
struct	O
MemoryPool	struct
*	O
MHD_pool_create	function
(	O
size_t	long
max	long
)	O
{	O
struct	O
MemoryPool	struct
*	O
pool	pointer
;	O
size_t	long
alloc_size	long
;	O
pool	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
struct	O
MemoryPool	struct
)	O
)	O
;	O
if	O
(	O
NULL	O
==	O
pool	pointer
)	O
return	O
NULL	O
;	O
if	O
(	O
(	O
max	long
<=	O
32	int
*	O
1024	int
)	O
||	O
(	O
max	long
<	O
MHD_sys_page_size_	long
*	O
4	int
/	O
3	int
)	O
)	O
{	O
pool	pointer
->	O
memory	pointer
=	O
MAP_FAILED	O
;	O
}	O
else	O
{	O
alloc_size	long
=	O
max	long
+	O
MHD_sys_page_size_	long
-	O
1	int
;	O
alloc_size	long
-=	O
alloc_size	long
%	O
MHD_sys_page_size_	long
;	O
pool	pointer
->	O
memory	pointer
=	O
mmap	function
(	O
NULL	O
,	O
alloc_size	long
,	O
PROT_READ	int
|	O
PROT_WRITE	int
,	O
MAP_PRIVATE	int
|	O
MAP_ANONYMOUS	int
,	O
-	O
1	int
,	O
0	int
)	O
;	O
}	O
if	O
(	O
MAP_FAILED	O
==	O
pool	pointer
->	O
memory	pointer
)	O
{	O
alloc_size	long
=	O
ROUND_TO_ALIGN	O
(	O
max	long
)	O
;	O
pool	pointer
->	O
memory	pointer
=	O
malloc	function
(	O
alloc_size	long
)	O
;	O
if	O
(	O
NULL	O
==	O
pool	pointer
->	O
memory	pointer
)	O
{	O
free	function
(	O
pool	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
pool	pointer
->	O
is_mmap	bool
=	O
false	int
;	O
}	O
else	O
{	O
pool	pointer
->	O
is_mmap	bool
=	O
true	int
;	O
}	O
pool	pointer
->	O
pos	long
=	O
0	int
;	O
pool	pointer
->	O
end	long
=	O
alloc_size	long
;	O
pool	pointer
->	O
size	long
=	O
alloc_size	long
;	O
return	O
pool	pointer
;	O
}	O
void	O
MHD_pool_destroy	function
(	O
struct	O
MemoryPool	struct
*	O
pool	pointer
)	O
{	O
if	O
(	O
NULL	O
==	O
pool	pointer
)	O
return	O
;	O
mhd_assert	O
(	O
pool	pointer
->	O
end	long
>=	O
pool	pointer
->	O
pos	long
)	O
;	O
mhd_assert	O
(	O
pool	pointer
->	O
size	long
>=	O
pool	pointer
->	O
end	long
-	O
pool	pointer
->	O
pos	long
)	O
;	O
if	O
(	O
!	O
pool	pointer
->	O
is_mmap	bool
)	O
free	function
(	O
pool	pointer
->	O
memory	pointer
)	O
;	O
else	O
munmap	function
(	O
pool	pointer
->	O
memory	pointer
,	O
pool	pointer
->	O
size	long
)	O
;	O
free	function
(	O
pool	pointer
)	O
;	O
}	O
size_t	long
MHD_pool_get_free	function
(	O
struct	O
MemoryPool	struct
*	O
pool	pointer
)	O
{	O
mhd_assert	O
(	O
pool	pointer
->	O
end	long
>=	O
pool	pointer
->	O
pos	long
)	O
;	O
mhd_assert	O
(	O
pool	pointer
->	O
size	long
>=	O
pool	pointer
->	O
end	long
-	O
pool	pointer
->	O
pos	long
)	O
;	O
return	O
(	O
pool	pointer
->	O
end	long
-	O
pool	pointer
->	O
pos	long
)	O
;	O
}	O
void	O
*	O
MHD_pool_allocate	function
(	O
struct	O
MemoryPool	struct
*	O
pool	pointer
,	O
size_t	long
size	long
,	O
bool	bool
from_end	bool
)	O
{	O
void	O
*	O
ret	pointer
;	O
size_t	long
asize	long
;	O
mhd_assert	O
(	O
pool	pointer
->	O
end	long
>=	O
pool	pointer
->	O
pos	long
)	O
;	O
mhd_assert	O
(	O
pool	pointer
->	O
size	long
>=	O
pool	pointer
->	O
end	long
-	O
pool	pointer
->	O
pos	long
)	O
;	O
asize	long
=	O
ROUND_TO_ALIGN	O
(	O
size	long
)	O
;	O
if	O
(	O
(	O
0	int
==	O
asize	long
)	O
&&	O
(	O
0	int
!=	O
size	long
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
(	O
pool	pointer
->	O
pos	long
+	O
asize	long
>	O
pool	pointer
->	O
end	long
)	O
||	O
(	O
pool	pointer
->	O
pos	long
+	O
asize	long
<	O
pool	pointer
->	O
pos	long
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
from_end	bool
)	O
{	O
ret	pointer
=	O
&	O
pool	pointer
->	O
memory	pointer
[	O
pool	pointer
->	O
end	long
-	O
asize	long
]	O
;	O
pool	pointer
->	O
end	long
-=	O
asize	long
;	O
}	O
else	O
{	O
ret	pointer
=	O
&	O
pool	pointer
->	O
memory	pointer
[	O
pool	pointer
->	O
pos	long
]	O
;	O
pool	pointer
->	O
pos	long
+=	O
asize	long
;	O
}	O
return	O
ret	pointer
;	O
}	O
void	O
*	O
MHD_pool_reallocate	function
(	O
struct	O
MemoryPool	struct
*	O
pool	pointer
,	O
void	O
*	O
old	pointer
,	O
size_t	long
old_size	long
,	O
size_t	long
new_size	long
)	O
{	O
size_t	long
asize	long
;	O
uint8_t	char
*	O
new_blc	pointer
;	O
mhd_assert	O
(	O
pool	pointer
->	O
end	long
>=	O
pool	pointer
->	O
pos	long
)	O
;	O
mhd_assert	O
(	O
pool	pointer
->	O
size	long
>=	O
pool	pointer
->	O
end	long
-	O
pool	pointer
->	O
pos	long
)	O
;	O
mhd_assert	O
(	O
old	pointer
!=	O
NULL	O
||	O
old_size	long
==	O
0	int
)	O
;	O
mhd_assert	O
(	O
old	pointer
==	O
NULL	O
||	O
pool	pointer
->	O
memory	pointer
<=	O
(	O
uint8_t	char
*	O
)	O
old	pointer
)	O
;	O
mhd_assert	O
(	O
old	pointer
==	O
NULL	O
||	O
pool	pointer
->	O
memory	pointer
+	O
pool	pointer
->	O
size	long
>=	O
(	O
uint8_t	char
*	O
)	O
old	pointer
+	O
old_size	long
)	O
;	O
mhd_assert	O
(	O
old	pointer
==	O
NULL	O
||	O
pool	pointer
->	O
memory	pointer
+	O
pool	pointer
->	O
pos	long
>	O
(	O
uint8_t	char
*	O
)	O
old	pointer
)	O
;	O
if	O
(	O
0	int
!=	O
old_size	long
)	O
{	O
const	O
size_t	long
old_offset	long
=	O
(	O
uint8_t	char
*	O
)	O
old	pointer
-	O
pool	pointer
->	O
memory	pointer
;	O
const	O
bool	bool
shrinking	bool
=	O
(	O
old_size	long
>	O
new_size	long
)	O
;	O
if	O
(	O
shrinking	bool
)	O
{	O
memset	function
(	O
(	O
uint8_t	char
*	O
)	O
old	pointer
+	O
new_size	long
,	O
0	int
,	O
old_size	long
-	O
new_size	long
)	O
;	O
}	O
if	O
(	O
pool	pointer
->	O
pos	long
==	O
ROUND_TO_ALIGN	O
(	O
old_offset	long
+	O
old_size	long
)	O
)	O
{	O
const	O
size_t	long
new_apos	long
=	O
ROUND_TO_ALIGN	O
(	O
old_offset	long
+	O
new_size	long
)	O
;	O
if	O
(	O
!	O
shrinking	bool
)	O
{	O
if	O
(	O
(	O
new_apos	long
>	O
pool	pointer
->	O
end	long
)	O
||	O
(	O
new_apos	long
<	O
pool	pointer
->	O
pos	long
)	O
)	O
return	O
NULL	O
;	O
}	O
pool	pointer
->	O
pos	long
=	O
new_apos	long
;	O
return	O
old	pointer
;	O
}	O
if	O
(	O
shrinking	bool
)	O
return	O
old	pointer
;	O
}	O
asize	long
=	O
ROUND_TO_ALIGN	O
(	O
new_size	long
)	O
;	O
if	O
(	O
(	O
(	O
0	int
==	O
asize	long
)	O
&&	O
(	O
0	int
!=	O
new_size	long
)	O
)	O
||	O
(	O
asize	long
>	O
pool	pointer
->	O
end	long
-	O
pool	pointer
->	O
pos	long
)	O
)	O
return	O
NULL	O
;	O
new_blc	pointer
=	O
pool	pointer
->	O
memory	pointer
+	O
pool	pointer
->	O
pos	long
;	O
pool	pointer
->	O
pos	long
+=	O
asize	long
;	O
if	O
(	O
0	int
!=	O
old_size	long
)	O
{	O
memcpy	function
(	O
new_blc	pointer
,	O
old	pointer
,	O
old_size	long
)	O
;	O
memset	function
(	O
old	pointer
,	O
0	int
,	O
old_size	long
)	O
;	O
}	O
return	O
new_blc	pointer
;	O
}	O
void	O
*	O
MHD_pool_reset	function
(	O
struct	O
MemoryPool	struct
*	O
pool	pointer
,	O
void	O
*	O
keep	pointer
,	O
size_t	long
copy_bytes	long
,	O
size_t	long
new_size	long
)	O
{	O
mhd_assert	O
(	O
pool	pointer
->	O
end	long
>=	O
pool	pointer
->	O
pos	long
)	O
;	O
mhd_assert	O
(	O
pool	pointer
->	O
size	long
>=	O
pool	pointer
->	O
end	long
-	O
pool	pointer
->	O
pos	long
)	O
;	O
mhd_assert	O
(	O
copy_bytes	long
<	O
new_size	long
)	O
;	O
mhd_assert	O
(	O
keep	pointer
!=	O
NULL	O
||	O
copy_bytes	long
==	O
0	int
)	O
;	O
mhd_assert	O
(	O
keep	pointer
==	O
NULL	O
||	O
pool	pointer
->	O
memory	pointer
<=	O
(	O
uint8_t	char
*	O
)	O
keep	pointer
)	O
;	O
mhd_assert	O
(	O
keep	pointer
==	O
NULL	O
||	O
pool	pointer
->	O
memory	pointer
+	O
pool	pointer
->	O
size	long
>=	O
(	O
uint8_t	char
*	O
)	O
keep	pointer
+	O
copy_bytes	long
)	O
;	O
if	O
(	O
(	O
NULL	O
!=	O
keep	pointer
)	O
&&	O
(	O
keep	pointer
!=	O
pool	pointer
->	O
memory	pointer
)	O
)	O
{	O
if	O
(	O
0	int
!=	O
copy_bytes	long
)	O
memmove	function
(	O
pool	pointer
->	O
memory	pointer
,	O
keep	pointer
,	O
copy_bytes	long
)	O
;	O
}	O
if	O
(	O
pool	pointer
->	O
size	long
>	O
copy_bytes	long
)	O
{	O
size_t	long
to_zero	long
;	O
to_zero	long
=	O
pool	pointer
->	O
size	long
-	O
copy_bytes	long
;	O
memset	function
(	O
&	O
pool	pointer
->	O
memory	pointer
[	O
copy_bytes	long
]	O
,	O
0	int
,	O
to_zero	long
)	O
;	O
}	O
pool	pointer
->	O
pos	long
=	O
ROUND_TO_ALIGN	O
(	O
new_size	long
)	O
;	O
pool	pointer
->	O
end	long
=	O
pool	pointer
->	O
size	long
;	O
return	O
pool	pointer
->	O
memory	pointer
;	O
}	O
