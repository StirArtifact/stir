enum	O
PP_State	enum
{	O
PP_Error	int
,	O
PP_Done	int
,	O
PP_Init	int
,	O
PP_NextBoundary	int
,	O
PP_ProcessValue	int
,	O
PP_Callback	int
,	O
PP_ExpectNewLine	int
,	O
PP_ProcessEntryHeaders	int
,	O
PP_PerformCheckMultipart	int
,	O
PP_ProcessValueToBoundary	int
,	O
PP_PerformCleanup	int
,	O
PP_Nested_Init	int
,	O
PP_Nested_PerformMarking	int
,	O
PP_Nested_ProcessEntryHeaders	int
,	O
PP_Nested_ProcessValueToBoundary	int
,	O
PP_Nested_PerformCleanup	int
}	O
;	O
enum	O
RN_State	enum
{	O
RN_Inactive	int
=	O
0	int
,	O
RN_OptN	int
=	O
1	int
,	O
RN_Full	int
=	O
2	int
,	O
RN_Dash	int
=	O
3	int
,	O
RN_Dash2	int
=	O
4	int
}	O
;	O
enum	O
NE_State	enum
{	O
NE_none	int
=	O
0	int
,	O
NE_content_name	int
=	O
1	int
,	O
NE_content_type	int
=	O
2	int
,	O
NE_content_filename	int
=	O
4	int
,	O
NE_content_transfer_encoding	int
=	O
8	int
}	O
;	O
struct	O
MHD_PostProcessor	struct
{	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
;	O
MHD_PostDataIterator	pointer
ikvi	pointer
;	O
void	O
*	O
cls	pointer
;	O
const	O
char	O
*	O
encoding	pointer
;	O
const	O
char	O
*	O
boundary	pointer
;	O
char	O
*	O
nested_boundary	pointer
;	O
char	O
*	O
content_name	pointer
;	O
char	O
*	O
content_type	pointer
;	O
char	O
*	O
content_filename	pointer
;	O
char	O
*	O
content_transfer_encoding	pointer
;	O
char	O
xbuf	array
[	O
2	int
]	O
;	O
size_t	long
buffer_size	long
;	O
size_t	long
buffer_pos	long
;	O
size_t	long
xbuf_pos	long
;	O
uint64_t	long
value_offset	long
;	O
size_t	long
blen	long
;	O
size_t	long
nlen	long
;	O
bool	bool
must_ikvi	bool
;	O
bool	bool
must_unescape_key	bool
;	O
enum	O
PP_State	enum
state	pointer
;	O
enum	O
RN_State	enum
skip_rn	enum
;	O
enum	O
PP_State	enum
dash_state	enum
;	O
enum	O
NE_State	enum
have	enum
;	O
}	O
;	O
struct	O
MHD_PostProcessor	struct
*	O
MHD_create_post_processor	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
,	O
size_t	long
buffer_size	long
,	O
MHD_PostDataIterator	pointer
iter	pointer
,	O
void	O
*	O
iter_cls	pointer
)	O
{	O
struct	O
MHD_PostProcessor	struct
*	O
ret	pointer
;	O
const	O
char	O
*	O
encoding	pointer
;	O
const	O
char	O
*	O
boundary	pointer
;	O
size_t	long
blen	long
;	O
if	O
(	O
(	O
buffer_size	long
<	O
256	int
)	O
||	O
(	O
NULL	O
==	O
connection	pointer
)	O
||	O
(	O
NULL	O
==	O
iter	pointer
)	O
)	O
mhd_panic	pointer
(	O
mhd_panic_cls	pointer
,	O
__FILE__	O
,	O
__LINE__	O
,	O
NULL	O
)	O
;	O
if	O
(	O
MHD_NO	int
==	O
MHD_lookup_connection_value_n	function
(	O
connection	pointer
,	O
MHD_HEADER_KIND	int
,	O
MHD_HTTP_HEADER_CONTENT_TYPE	pointer
,	O
MHD_STATICSTR_LEN_	O
(	O
MHD_HTTP_HEADER_CONTENT_TYPE	pointer
)	O
,	O
&	O
encoding	pointer
,	O
NULL	O
)	O
)	O
return	O
NULL	O
;	O
boundary	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
MHD_str_equal_caseless_n_	function
(	O
MHD_HTTP_POST_ENCODING_FORM_URLENCODED	pointer
,	O
encoding	pointer
,	O
MHD_STATICSTR_LEN_	O
(	O
MHD_HTTP_POST_ENCODING_FORM_URLENCODED	pointer
)	O
)	O
)	O
{	O
if	O
(	O
!	O
MHD_str_equal_caseless_n_	function
(	O
MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA	pointer
,	O
encoding	pointer
,	O
MHD_STATICSTR_LEN_	O
(	O
MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA	pointer
)	O
)	O
)	O
return	O
NULL	O
;	O
boundary	pointer
=	O
&	O
encoding	pointer
[	O
MHD_STATICSTR_LEN_	O
(	O
MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA	pointer
)	O
]	O
;	O
boundary	pointer
=	O
strstr	function
(	O
boundary	pointer
,	O
"boundary="	pointer
)	O
;	O
if	O
(	O
NULL	O
==	O
boundary	pointer
)	O
return	O
NULL	O
;	O
boundary	pointer
+=	O
MHD_STATICSTR_LEN_	O
(	O
"boundary="	pointer
)	O
;	O
blen	long
=	O
strlen	function
(	O
boundary	pointer
)	O
;	O
if	O
(	O
(	O
blen	long
==	O
0	int
)	O
||	O
(	O
blen	long
*	O
2	int
+	O
2	int
>	O
buffer_size	long
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
(	O
boundary	pointer
[	O
0	int
]	O
==	O
'"'	O
)	O
&&	O
(	O
boundary	pointer
[	O
blen	long
-	O
1	int
]	O
==	O
'"'	O
)	O
)	O
{	O
++	O
boundary	pointer
;	O
blen	long
-=	O
2	int
;	O
}	O
}	O
else	O
blen	long
=	O
0	int
;	O
buffer_size	long
+=	O
4	int
;	O
if	O
(	O
NULL	O
==	O
(	O
ret	pointer
=	O
MHD_calloc_	O
(	O
1	int
,	O
sizeof	O
(	O
struct	O
MHD_PostProcessor	struct
)	O
+	O
buffer_size	long
+	O
1	int
)	O
)	O
)	O
return	O
NULL	O
;	O
ret	pointer
->	O
connection	pointer
=	O
connection	pointer
;	O
ret	pointer
->	O
ikvi	pointer
=	O
iter	pointer
;	O
ret	pointer
->	O
cls	pointer
=	O
iter_cls	pointer
;	O
ret	pointer
->	O
encoding	pointer
=	O
encoding	pointer
;	O
ret	pointer
->	O
buffer_size	long
=	O
buffer_size	long
;	O
ret	pointer
->	O
state	pointer
=	O
PP_Init	int
;	O
ret	pointer
->	O
blen	long
=	O
blen	long
;	O
ret	pointer
->	O
boundary	pointer
=	O
boundary	pointer
;	O
ret	pointer
->	O
skip_rn	enum
=	O
RN_Inactive	int
;	O
return	O
ret	pointer
;	O
}	O
static	O
void	O
process_value	function
(	O
struct	O
MHD_PostProcessor	struct
*	O
pp	pointer
,	O
const	O
char	O
*	O
value_start	pointer
,	O
const	O
char	O
*	O
value_end	pointer
,	O
const	O
char	O
*	O
last_escape	pointer
)	O
{	O
char	O
xbuf	array
[	O
XBUF_SIZE	int
+	O
1	int
]	O
;	O
size_t	long
xoff	long
;	O
mhd_assert	O
(	O
pp	pointer
->	O
xbuf_pos	long
<	O
sizeof	O
(	O
xbuf	array
)	O
)	O
;	O
memcpy	function
(	O
xbuf	array
,	O
pp	pointer
->	O
xbuf	array
,	O
pp	pointer
->	O
xbuf_pos	long
)	O
;	O
xoff	long
=	O
pp	pointer
->	O
xbuf_pos	long
;	O
pp	pointer
->	O
xbuf_pos	long
=	O
0	int
;	O
if	O
(	O
NULL	O
!=	O
last_escape	pointer
)	O
{	O
if	O
(	O
value_end	pointer
-	O
last_escape	pointer
<	O
sizeof	O
(	O
pp	pointer
->	O
xbuf	array
)	O
)	O
{	O
pp	pointer
->	O
xbuf_pos	long
=	O
value_end	pointer
-	O
last_escape	pointer
;	O
memcpy	function
(	O
pp	pointer
->	O
xbuf	array
,	O
last_escape	pointer
,	O
value_end	pointer
-	O
last_escape	pointer
)	O
;	O
value_end	pointer
=	O
last_escape	pointer
;	O
}	O
}	O
while	O
(	O
(	O
value_start	pointer
!=	O
value_end	pointer
)	O
||	O
(	O
pp	pointer
->	O
must_ikvi	bool
)	O
||	O
(	O
xoff	long
>	O
0	int
)	O
)	O
{	O
size_t	long
delta	long
=	O
value_end	pointer
-	O
value_start	pointer
;	O
if	O
(	O
delta	long
>	O
XBUF_SIZE	int
-	O
xoff	long
)	O
delta	long
=	O
XBUF_SIZE	int
-	O
xoff	long
;	O
memcpy	function
(	O
&	O
xbuf	array
[	O
xoff	long
]	O
,	O
value_start	pointer
,	O
delta	long
)	O
;	O
if	O
(	O
delta	long
>=	O
XBUF_SIZE	int
-	O
2	int
)	O
{	O
if	O
(	O
(	O
xoff	long
+	O
delta	long
>	O
0	int
)	O
&&	O
(	O
'%'	O
==	O
xbuf	array
[	O
xoff	long
+	O
delta	long
-	O
1	int
]	O
)	O
)	O
delta	long
--	O
;	O
else	O
if	O
(	O
(	O
xoff	long
+	O
delta	long
>	O
1	int
)	O
&&	O
(	O
'%'	O
==	O
xbuf	array
[	O
xoff	long
+	O
delta	long
-	O
2	int
]	O
)	O
)	O
delta	long
-=	O
2	int
;	O
}	O
xoff	long
+=	O
delta	long
;	O
value_start	pointer
+=	O
delta	long
;	O
mhd_assert	O
(	O
xoff	long
<	O
sizeof	O
(	O
xbuf	array
)	O
)	O
;	O
xbuf	array
[	O
xoff	long
]	O
=	O
'\0'	O
;	O
MHD_unescape_plus	function
(	O
xbuf	array
)	O
;	O
xoff	long
=	O
MHD_http_unescape	function
(	O
xbuf	array
)	O
;	O
pp	pointer
->	O
must_ikvi	bool
=	O
false	int
;	O
if	O
(	O
MHD_NO	int
==	O
pp	pointer
->	O
ikvi	pointer
(	O
pp	pointer
->	O
cls	pointer
,	O
MHD_POSTDATA_KIND	int
,	O
(	O
const	O
char	O
*	O
)	O
&	O
pp	pointer
[	O
1	int
]	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
xbuf	array
,	O
pp	pointer
->	O
value_offset	long
,	O
xoff	long
)	O
)	O
{	O
pp	pointer
->	O
state	pointer
=	O
PP_Error	int
;	O
return	O
;	O
}	O
pp	pointer
->	O
value_offset	long
+=	O
xoff	long
;	O
xoff	long
=	O
0	int
;	O
}	O
}	O
static	O
int	O
post_process_urlencoded	function
(	O
struct	O
MHD_PostProcessor	struct
*	O
pp	pointer
,	O
const	O
char	O
*	O
post_data	pointer
,	O
size_t	long
post_data_len	long
)	O
{	O
char	O
*	O
kbuf	pointer
=	O
(	O
char	O
*	O
)	O
&	O
pp	pointer
[	O
1	int
]	O
;	O
size_t	long
poff	long
;	O
const	O
char	O
*	O
start_key	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
end_key	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
start_value	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
end_value	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
last_escape	pointer
=	O
NULL	O
;	O
poff	long
=	O
0	int
;	O
while	O
(	O
(	O
(	O
poff	long
<	O
post_data_len	long
)	O
||	O
(	O
pp	pointer
->	O
state	pointer
==	O
PP_Callback	int
)	O
)	O
&&	O
(	O
pp	pointer
->	O
state	pointer
!=	O
PP_Error	int
)	O
)	O
{	O
switch	O
(	O
pp	pointer
->	O
state	pointer
)	O
{	O
case	O
PP_Error	int
:	O
abort	function
(	O
)	O
;	O
break	O
;	O
case	O
PP_Init	int
:	O
if	O
(	O
NULL	O
==	O
start_key	pointer
)	O
start_key	pointer
=	O
&	O
post_data	pointer
[	O
poff	long
]	O
;	O
pp	pointer
->	O
must_ikvi	bool
=	O
true	int
;	O
switch	O
(	O
post_data	pointer
[	O
poff	long
]	O
)	O
{	O
case	O
'='	O
:	O
end_key	pointer
=	O
&	O
post_data	pointer
[	O
poff	long
]	O
;	O
poff	long
++	O
;	O
pp	pointer
->	O
state	pointer
=	O
PP_ProcessValue	int
;	O
break	O
;	O
case	O
'&'	O
:	O
end_key	pointer
=	O
&	O
post_data	pointer
[	O
poff	long
]	O
;	O
mhd_assert	O
(	O
NULL	O
==	O
start_value	pointer
)	O
;	O
mhd_assert	O
(	O
NULL	O
==	O
end_value	pointer
)	O
;	O
poff	long
++	O
;	O
pp	pointer
->	O
state	pointer
=	O
PP_Callback	int
;	O
break	O
;	O
case	O
'\n'	O
:	O
case	O
'\r'	O
:	O
end_key	pointer
=	O
&	O
post_data	pointer
[	O
poff	long
]	O
;	O
poff	long
++	O
;	O
pp	pointer
->	O
state	pointer
=	O
PP_Done	int
;	O
break	O
;	O
default	O
:	O
poff	long
++	O
;	O
continue	O
;	O
}	O
break	O
;	O
case	O
PP_ProcessValue	int
:	O
if	O
(	O
NULL	O
==	O
start_value	pointer
)	O
start_value	pointer
=	O
&	O
post_data	pointer
[	O
poff	long
]	O
;	O
switch	O
(	O
post_data	pointer
[	O
poff	long
]	O
)	O
{	O
case	O
'='	O
:	O
pp	pointer
->	O
state	pointer
=	O
PP_Error	int
;	O
continue	O
;	O
case	O
'&'	O
:	O
end_value	pointer
=	O
&	O
post_data	pointer
[	O
poff	long
]	O
;	O
poff	long
++	O
;	O
if	O
(	O
pp	pointer
->	O
must_ikvi	bool
||	O
(	O
start_value	pointer
!=	O
end_value	pointer
)	O
)	O
{	O
pp	pointer
->	O
state	pointer
=	O
PP_Callback	int
;	O
}	O
else	O
{	O
pp	pointer
->	O
buffer_pos	long
=	O
0	int
;	O
pp	pointer
->	O
value_offset	long
=	O
0	int
;	O
pp	pointer
->	O
state	pointer
=	O
PP_Init	int
;	O
}	O
continue	O
;	O
case	O
'\n'	O
:	O
case	O
'\r'	O
:	O
end_value	pointer
=	O
&	O
post_data	pointer
[	O
poff	long
]	O
;	O
poff	long
++	O
;	O
if	O
(	O
pp	pointer
->	O
must_ikvi	bool
)	O
pp	pointer
->	O
state	pointer
=	O
PP_Callback	int
;	O
else	O
pp	pointer
->	O
state	pointer
=	O
PP_Done	int
;	O
break	O
;	O
case	O
'%'	O
:	O
last_escape	pointer
=	O
&	O
post_data	pointer
[	O
poff	long
]	O
;	O
poff	long
++	O
;	O
break	O
;	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
poff	long
++	O
;	O
continue	O
;	O
default	O
:	O
last_escape	pointer
=	O
NULL	O
;	O
poff	long
++	O
;	O
continue	O
;	O
}	O
break	O
;	O
case	O
PP_Done	int
:	O
switch	O
(	O
post_data	pointer
[	O
poff	long
]	O
)	O
{	O
case	O
'\n'	O
:	O
case	O
'\r'	O
:	O
poff	long
++	O
;	O
continue	O
;	O
}	O
pp	pointer
->	O
state	pointer
=	O
PP_Error	int
;	O
break	O
;	O
case	O
PP_Callback	int
:	O
if	O
(	O
(	O
pp	pointer
->	O
buffer_pos	long
+	O
(	O
end_key	pointer
-	O
start_key	pointer
)	O
>	O
pp	pointer
->	O
buffer_size	long
)	O
||	O
(	O
pp	pointer
->	O
buffer_pos	long
+	O
(	O
end_key	pointer
-	O
start_key	pointer
)	O
<	O
pp	pointer
->	O
buffer_pos	long
)	O
)	O
{	O
pp	pointer
->	O
state	pointer
=	O
PP_Error	int
;	O
continue	O
;	O
}	O
if	O
(	O
NULL	O
!=	O
start_key	pointer
)	O
{	O
memcpy	function
(	O
&	O
kbuf	pointer
[	O
pp	pointer
->	O
buffer_pos	long
]	O
,	O
start_key	pointer
,	O
end_key	pointer
-	O
start_key	pointer
)	O
;	O
pp	pointer
->	O
buffer_pos	long
+=	O
end_key	pointer
-	O
start_key	pointer
;	O
start_key	pointer
=	O
NULL	O
;	O
end_key	pointer
=	O
NULL	O
;	O
pp	pointer
->	O
must_unescape_key	bool
=	O
true	int
;	O
}	O
if	O
(	O
pp	pointer
->	O
must_unescape_key	bool
)	O
{	O
kbuf	pointer
[	O
pp	pointer
->	O
buffer_pos	long
]	O
=	O
'\0'	O
;	O
MHD_unescape_plus	function
(	O
kbuf	pointer
)	O
;	O
MHD_http_unescape	function
(	O
kbuf	pointer
)	O
;	O
pp	pointer
->	O
must_unescape_key	bool
=	O
false	int
;	O
}	O
process_value	function
(	O
pp	pointer
,	O
start_value	pointer
,	O
end_value	pointer
,	O
NULL	O
)	O
;	O
pp	pointer
->	O
value_offset	long
=	O
0	int
;	O
start_value	pointer
=	O
NULL	O
;	O
end_value	pointer
=	O
NULL	O
;	O
pp	pointer
->	O
buffer_pos	long
=	O
0	int
;	O
pp	pointer
->	O
state	pointer
=	O
PP_Init	int
;	O
break	O
;	O
default	O
:	O
mhd_panic	pointer
(	O
mhd_panic_cls	pointer
,	O
__FILE__	O
,	O
__LINE__	O
,	O
NULL	O
)	O
;	O
}	O
}	O
if	O
(	O
NULL	O
!=	O
start_key	pointer
)	O
{	O
if	O
(	O
NULL	O
==	O
end_key	pointer
)	O
end_key	pointer
=	O
&	O
post_data	pointer
[	O
poff	long
]	O
;	O
memcpy	function
(	O
&	O
kbuf	pointer
[	O
pp	pointer
->	O
buffer_pos	long
]	O
,	O
start_key	pointer
,	O
end_key	pointer
-	O
start_key	pointer
)	O
;	O
pp	pointer
->	O
buffer_pos	long
+=	O
end_key	pointer
-	O
start_key	pointer
;	O
pp	pointer
->	O
must_unescape_key	bool
=	O
true	int
;	O
start_key	pointer
=	O
NULL	O
;	O
end_key	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
(	O
NULL	O
!=	O
start_value	pointer
)	O
&&	O
(	O
PP_ProcessValue	int
==	O
pp	pointer
->	O
state	pointer
)	O
)	O
{	O
if	O
(	O
pp	pointer
->	O
must_unescape_key	bool
)	O
{	O
kbuf	pointer
[	O
pp	pointer
->	O
buffer_pos	long
]	O
=	O
'\0'	O
;	O
MHD_unescape_plus	function
(	O
kbuf	pointer
)	O
;	O
MHD_http_unescape	function
(	O
kbuf	pointer
)	O
;	O
pp	pointer
->	O
must_unescape_key	bool
=	O
false	int
;	O
}	O
if	O
(	O
NULL	O
==	O
end_value	pointer
)	O
end_value	pointer
=	O
&	O
post_data	pointer
[	O
poff	long
]	O
;	O
process_value	function
(	O
pp	pointer
,	O
start_value	pointer
,	O
end_value	pointer
,	O
last_escape	pointer
)	O
;	O
pp	pointer
->	O
must_ikvi	bool
=	O
false	int
;	O
}	O
return	O
MHD_YES	int
;	O
}	O
static	O
int	O
try_match_header	function
(	O
const	O
char	O
*	O
prefix	pointer
,	O
size_t	long
prefix_len	long
,	O
char	O
*	O
line	int
,	O
char	O
*	O
*	O
suffix	pointer
)	O
{	O
if	O
(	O
NULL	O
!=	O
*	O
suffix	pointer
)	O
return	O
MHD_NO	int
;	O
while	O
(	O
0	int
!=	O
*	O
line	int
)	O
{	O
if	O
(	O
MHD_str_equal_caseless_n_	function
(	O
prefix	pointer
,	O
line	int
,	O
prefix_len	long
)	O
)	O
{	O
*	O
suffix	pointer
=	O
strdup	function
(	O
&	O
line	int
[	O
prefix_len	long
]	O
)	O
;	O
return	O
MHD_YES	int
;	O
}	O
++	O
line	int
;	O
}	O
return	O
MHD_NO	int
;	O
}	O
static	O
int	O
find_boundary	function
(	O
struct	O
MHD_PostProcessor	struct
*	O
pp	pointer
,	O
const	O
char	O
*	O
boundary	pointer
,	O
size_t	long
blen	long
,	O
size_t	long
*	O
ioffptr	pointer
,	O
enum	O
PP_State	enum
next_state	enum
,	O
enum	O
PP_State	enum
next_dash_state	enum
)	O
{	O
char	O
*	O
buf	pointer
=	O
(	O
char	O
*	O
)	O
&	O
pp	pointer
[	O
1	int
]	O
;	O
const	O
char	O
*	O
dash	pointer
;	O
if	O
(	O
pp	pointer
->	O
buffer_pos	long
<	O
2	int
+	O
blen	long
)	O
{	O
if	O
(	O
pp	pointer
->	O
buffer_pos	long
==	O
pp	pointer
->	O
buffer_size	long
)	O
pp	pointer
->	O
state	pointer
=	O
PP_Error	int
;	O
return	O
MHD_NO	int
;	O
}	O
if	O
(	O
(	O
0	int
!=	O
memcmp	function
(	O
"--"	pointer
,	O
buf	pointer
,	O
2	int
)	O
)	O
||	O
(	O
0	int
!=	O
memcmp	function
(	O
&	O
buf	pointer
[	O
2	int
]	O
,	O
boundary	pointer
,	O
blen	long
)	O
)	O
)	O
{	O
if	O
(	O
pp	pointer
->	O
state	pointer
!=	O
PP_Init	int
)	O
{	O
pp	pointer
->	O
state	pointer
=	O
PP_Error	int
;	O
}	O
else	O
{	O
dash	pointer
=	O
memchr	function
(	O
buf	pointer
,	O
'-'	O
,	O
pp	pointer
->	O
buffer_pos	long
)	O
;	O
if	O
(	O
NULL	O
==	O
dash	pointer
)	O
(	O
*	O
ioffptr	pointer
)	O
+=	O
pp	pointer
->	O
buffer_pos	long
;	O
else	O
if	O
(	O
dash	pointer
==	O
buf	pointer
)	O
(	O
*	O
ioffptr	pointer
)	O
++	O
;	O
else	O
(	O
*	O
ioffptr	pointer
)	O
+=	O
dash	pointer
-	O
buf	pointer
;	O
}	O
return	O
MHD_NO	int
;	O
}	O
(	O
*	O
ioffptr	pointer
)	O
+=	O
2	int
+	O
blen	long
;	O
pp	pointer
->	O
skip_rn	enum
=	O
RN_Dash	int
;	O
pp	pointer
->	O
state	pointer
=	O
next_state	enum
;	O
pp	pointer
->	O
dash_state	enum
=	O
next_dash_state	enum
;	O
return	O
MHD_YES	int
;	O
}	O
static	O
void	O
try_get_value	function
(	O
const	O
char	O
*	O
buf	pointer
,	O
const	O
char	O
*	O
key	pointer
,	O
char	O
*	O
*	O
destination	pointer
)	O
{	O
const	O
char	O
*	O
spos	pointer
;	O
const	O
char	O
*	O
bpos	pointer
;	O
const	O
char	O
*	O
endv	pointer
;	O
size_t	long
klen	long
;	O
size_t	long
vlen	long
;	O
if	O
(	O
NULL	O
!=	O
*	O
destination	pointer
)	O
return	O
;	O
bpos	pointer
=	O
buf	pointer
;	O
klen	long
=	O
strlen	function
(	O
key	pointer
)	O
;	O
while	O
(	O
NULL	O
!=	O
(	O
spos	pointer
=	O
strstr	function
(	O
bpos	pointer
,	O
key	pointer
)	O
)	O
)	O
{	O
if	O
(	O
(	O
spos	pointer
[	O
klen	long
]	O
!=	O
'='	O
)	O
||	O
(	O
(	O
spos	pointer
!=	O
buf	pointer
)	O
&&	O
(	O
spos	pointer
[	O
-	O
1	int
]	O
!=	O
' '	O
)	O
)	O
)	O
{	O
bpos	pointer
=	O
spos	pointer
+	O
1	int
;	O
continue	O
;	O
}	O
if	O
(	O
spos	pointer
[	O
klen	long
+	O
1	int
]	O
!=	O
'"'	O
)	O
return	O
;	O
if	O
(	O
NULL	O
==	O
(	O
endv	pointer
=	O
strchr	function
(	O
&	O
spos	pointer
[	O
klen	long
+	O
2	int
]	O
,	O
'\"'	O
)	O
)	O
)	O
return	O
;	O
vlen	long
=	O
endv	pointer
-	O
spos	pointer
-	O
klen	long
-	O
1	int
;	O
*	O
destination	pointer
=	O
malloc	function
(	O
vlen	long
)	O
;	O
if	O
(	O
NULL	O
==	O
*	O
destination	pointer
)	O
return	O
;	O
(	O
*	O
destination	pointer
)	O
[	O
vlen	long
-	O
1	int
]	O
=	O
'\0'	O
;	O
memcpy	function
(	O
*	O
destination	pointer
,	O
&	O
spos	pointer
[	O
klen	long
+	O
2	int
]	O
,	O
vlen	long
-	O
1	int
)	O
;	O
return	O
;	O
}	O
}	O
static	O
int	O
process_multipart_headers	function
(	O
struct	O
MHD_PostProcessor	struct
*	O
pp	pointer
,	O
size_t	long
*	O
ioffptr	pointer
,	O
enum	O
PP_State	enum
next_state	enum
)	O
{	O
char	O
*	O
buf	pointer
=	O
(	O
char	O
*	O
)	O
&	O
pp	pointer
[	O
1	int
]	O
;	O
size_t	long
newline	long
;	O
newline	long
=	O
0	int
;	O
while	O
(	O
(	O
newline	long
<	O
pp	pointer
->	O
buffer_pos	long
)	O
&&	O
(	O
buf	pointer
[	O
newline	long
]	O
!=	O
'\r'	O
)	O
&&	O
(	O
buf	pointer
[	O
newline	long
]	O
!=	O
'\n'	O
)	O
)	O
newline	long
++	O
;	O
if	O
(	O
newline	long
==	O
pp	pointer
->	O
buffer_size	long
)	O
{	O
pp	pointer
->	O
state	pointer
=	O
PP_Error	int
;	O
return	O
MHD_NO	int
;	O
}	O
if	O
(	O
newline	long
==	O
pp	pointer
->	O
buffer_pos	long
)	O
return	O
MHD_NO	int
;	O
if	O
(	O
0	int
==	O
newline	long
)	O
{	O
pp	pointer
->	O
skip_rn	enum
=	O
RN_Full	int
;	O
pp	pointer
->	O
state	pointer
=	O
next_state	enum
;	O
return	O
MHD_YES	int
;	O
}	O
if	O
(	O
buf	pointer
[	O
newline	long
]	O
==	O
'\r'	O
)	O
pp	pointer
->	O
skip_rn	enum
=	O
RN_OptN	int
;	O
buf	pointer
[	O
newline	long
]	O
=	O
'\0'	O
;	O
if	O
(	O
MHD_str_equal_caseless_n_	function
(	O
"Content-disposition: "	pointer
,	O
buf	pointer
,	O
MHD_STATICSTR_LEN_	O
(	O
"Content-disposition: "	pointer
)	O
)	O
)	O
{	O
try_get_value	function
(	O
&	O
buf	pointer
[	O
MHD_STATICSTR_LEN_	O
(	O
"Content-disposition: "	pointer
)	O
]	O
,	O
"name"	pointer
,	O
&	O
pp	pointer
->	O
content_name	pointer
)	O
;	O
try_get_value	function
(	O
&	O
buf	pointer
[	O
MHD_STATICSTR_LEN_	O
(	O
"Content-disposition: "	pointer
)	O
]	O
,	O
"filename"	pointer
,	O
&	O
pp	pointer
->	O
content_filename	pointer
)	O
;	O
}	O
else	O
{	O
try_match_header	function
(	O
"Content-type: "	pointer
,	O
MHD_STATICSTR_LEN_	O
(	O
"Content-type: "	pointer
)	O
,	O
buf	pointer
,	O
&	O
pp	pointer
->	O
content_type	pointer
)	O
;	O
try_match_header	function
(	O
"Content-Transfer-Encoding: "	pointer
,	O
MHD_STATICSTR_LEN_	O
(	O
"Content-Transfer-Encoding: "	pointer
)	O
,	O
buf	pointer
,	O
&	O
pp	pointer
->	O
content_transfer_encoding	pointer
)	O
;	O
}	O
(	O
*	O
ioffptr	pointer
)	O
+=	O
newline	long
+	O
1	int
;	O
return	O
MHD_YES	int
;	O
}	O
static	O
int	O
process_value_to_boundary	function
(	O
struct	O
MHD_PostProcessor	struct
*	O
pp	pointer
,	O
size_t	long
*	O
ioffptr	pointer
,	O
const	O
char	O
*	O
boundary	pointer
,	O
size_t	long
blen	long
,	O
enum	O
PP_State	enum
next_state	enum
,	O
enum	O
PP_State	enum
next_dash_state	enum
)	O
{	O
char	O
*	O
buf	pointer
=	O
(	O
char	O
*	O
)	O
&	O
pp	pointer
[	O
1	int
]	O
;	O
size_t	long
newline	long
;	O
const	O
char	O
*	O
r	pointer
;	O
newline	long
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
while	O
(	O
newline	long
+	O
4	int
<	O
pp	pointer
->	O
buffer_pos	long
)	O
{	O
r	pointer
=	O
memchr	function
(	O
&	O
buf	pointer
[	O
newline	long
]	O
,	O
'\r'	O
,	O
pp	pointer
->	O
buffer_pos	long
-	O
newline	long
-	O
4	int
)	O
;	O
if	O
(	O
NULL	O
==	O
r	pointer
)	O
{	O
newline	long
=	O
pp	pointer
->	O
buffer_pos	long
-	O
4	int
;	O
break	O
;	O
}	O
newline	long
=	O
r	pointer
-	O
buf	pointer
;	O
if	O
(	O
0	int
==	O
memcmp	function
(	O
"\r\n--"	pointer
,	O
&	O
buf	pointer
[	O
newline	long
]	O
,	O
4	int
)	O
)	O
break	O
;	O
newline	long
++	O
;	O
}	O
if	O
(	O
newline	long
+	O
blen	long
+	O
4	int
<=	O
pp	pointer
->	O
buffer_pos	long
)	O
{	O
if	O
(	O
0	int
!=	O
memcmp	function
(	O
&	O
buf	pointer
[	O
newline	long
+	O
4	int
]	O
,	O
boundary	pointer
,	O
blen	long
)	O
)	O
{	O
newline	long
+=	O
4	int
;	O
continue	O
;	O
}	O
else	O
{	O
pp	pointer
->	O
skip_rn	enum
=	O
RN_Dash	int
;	O
pp	pointer
->	O
state	pointer
=	O
next_state	enum
;	O
pp	pointer
->	O
dash_state	enum
=	O
next_dash_state	enum
;	O
(	O
*	O
ioffptr	pointer
)	O
+=	O
blen	long
+	O
4	int
;	O
buf	pointer
[	O
newline	long
]	O
=	O
'\0'	O
;	O
break	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
(	O
0	int
==	O
newline	long
)	O
&&	O
(	O
pp	pointer
->	O
buffer_pos	long
==	O
pp	pointer
->	O
buffer_size	long
)	O
)	O
{	O
pp	pointer
->	O
state	pointer
=	O
PP_Error	int
;	O
return	O
MHD_NO	int
;	O
}	O
break	O
;	O
}	O
}	O
if	O
(	O
(	O
(	O
pp	pointer
->	O
must_ikvi	bool
)	O
||	O
(	O
0	int
!=	O
newline	long
)	O
)	O
&&	O
(	O
MHD_NO	int
==	O
pp	pointer
->	O
ikvi	pointer
(	O
pp	pointer
->	O
cls	pointer
,	O
MHD_POSTDATA_KIND	int
,	O
pp	pointer
->	O
content_name	pointer
,	O
pp	pointer
->	O
content_filename	pointer
,	O
pp	pointer
->	O
content_type	pointer
,	O
pp	pointer
->	O
content_transfer_encoding	pointer
,	O
buf	pointer
,	O
pp	pointer
->	O
value_offset	long
,	O
newline	long
)	O
)	O
)	O
{	O
pp	pointer
->	O
state	pointer
=	O
PP_Error	int
;	O
return	O
MHD_NO	int
;	O
}	O
pp	pointer
->	O
must_ikvi	bool
=	O
false	int
;	O
pp	pointer
->	O
value_offset	long
+=	O
newline	long
;	O
(	O
*	O
ioffptr	pointer
)	O
+=	O
newline	long
;	O
return	O
MHD_YES	int
;	O
}	O
static	O
void	O
free_unmarked	function
(	O
struct	O
MHD_PostProcessor	struct
*	O
pp	pointer
)	O
{	O
if	O
(	O
(	O
NULL	O
!=	O
pp	pointer
->	O
content_name	pointer
)	O
&&	O
(	O
0	int
==	O
(	O
pp	pointer
->	O
have	enum
&	O
NE_content_name	int
)	O
)	O
)	O
{	O
free	function
(	O
pp	pointer
->	O
content_name	pointer
)	O
;	O
pp	pointer
->	O
content_name	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
(	O
NULL	O
!=	O
pp	pointer
->	O
content_type	pointer
)	O
&&	O
(	O
0	int
==	O
(	O
pp	pointer
->	O
have	enum
&	O
NE_content_type	int
)	O
)	O
)	O
{	O
free	function
(	O
pp	pointer
->	O
content_type	pointer
)	O
;	O
pp	pointer
->	O
content_type	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
(	O
NULL	O
!=	O
pp	pointer
->	O
content_filename	pointer
)	O
&&	O
(	O
0	int
==	O
(	O
pp	pointer
->	O
have	enum
&	O
NE_content_filename	int
)	O
)	O
)	O
{	O
free	function
(	O
pp	pointer
->	O
content_filename	pointer
)	O
;	O
pp	pointer
->	O
content_filename	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
(	O
NULL	O
!=	O
pp	pointer
->	O
content_transfer_encoding	pointer
)	O
&&	O
(	O
0	int
==	O
(	O
pp	pointer
->	O
have	enum
&	O
NE_content_transfer_encoding	int
)	O
)	O
)	O
{	O
free	function
(	O
pp	pointer
->	O
content_transfer_encoding	pointer
)	O
;	O
pp	pointer
->	O
content_transfer_encoding	pointer
=	O
NULL	O
;	O
}	O
}	O
static	O
int	O
post_process_multipart	function
(	O
struct	O
MHD_PostProcessor	struct
*	O
pp	pointer
,	O
const	O
char	O
*	O
post_data	pointer
,	O
size_t	long
post_data_len	long
)	O
{	O
char	O
*	O
buf	pointer
;	O
size_t	long
max	long
;	O
size_t	long
ioff	long
;	O
size_t	long
poff	long
;	O
int	O
state_changed	int
;	O
buf	pointer
=	O
(	O
char	O
*	O
)	O
&	O
pp	pointer
[	O
1	int
]	O
;	O
ioff	long
=	O
0	int
;	O
poff	long
=	O
0	int
;	O
state_changed	int
=	O
1	int
;	O
while	O
(	O
(	O
poff	long
<	O
post_data_len	long
)	O
||	O
(	O
(	O
pp	pointer
->	O
buffer_pos	long
>	O
0	int
)	O
&&	O
(	O
0	int
!=	O
state_changed	int
)	O
)	O
)	O
{	O
max	long
=	O
pp	pointer
->	O
buffer_size	long
-	O
pp	pointer
->	O
buffer_pos	long
;	O
if	O
(	O
max	long
>	O
post_data_len	long
-	O
poff	long
)	O
max	long
=	O
post_data_len	long
-	O
poff	long
;	O
memcpy	function
(	O
&	O
buf	pointer
[	O
pp	pointer
->	O
buffer_pos	long
]	O
,	O
&	O
post_data	pointer
[	O
poff	long
]	O
,	O
max	long
)	O
;	O
poff	long
+=	O
max	long
;	O
pp	pointer
->	O
buffer_pos	long
+=	O
max	long
;	O
if	O
(	O
(	O
0	int
==	O
max	long
)	O
&&	O
(	O
0	int
==	O
state_changed	int
)	O
&&	O
(	O
poff	long
<	O
post_data_len	long
)	O
)	O
{	O
pp	pointer
->	O
state	pointer
=	O
PP_Error	int
;	O
return	O
MHD_NO	int
;	O
}	O
state_changed	int
=	O
0	int
;	O
switch	O
(	O
pp	pointer
->	O
skip_rn	enum
)	O
{	O
case	O
RN_Inactive	int
:	O
break	O
;	O
case	O
RN_OptN	int
:	O
if	O
(	O
buf	pointer
[	O
0	int
]	O
==	O
'\n'	O
)	O
{	O
ioff	long
++	O
;	O
pp	pointer
->	O
skip_rn	enum
=	O
RN_Inactive	int
;	O
goto	O
AGAIN	O
;	O
}	O
case	O
RN_Dash	int
:	O
if	O
(	O
buf	pointer
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
ioff	long
++	O
;	O
pp	pointer
->	O
skip_rn	enum
=	O
RN_Dash2	int
;	O
goto	O
AGAIN	O
;	O
}	O
pp	pointer
->	O
skip_rn	enum
=	O
RN_Full	int
;	O
case	O
RN_Full	int
:	O
if	O
(	O
buf	pointer
[	O
0	int
]	O
==	O
'\r'	O
)	O
{	O
if	O
(	O
(	O
pp	pointer
->	O
buffer_pos	long
>	O
1	int
)	O
&&	O
(	O
'\n'	O
==	O
buf	pointer
[	O
1	int
]	O
)	O
)	O
{	O
pp	pointer
->	O
skip_rn	enum
=	O
RN_Inactive	int
;	O
ioff	long
+=	O
2	int
;	O
}	O
else	O
{	O
pp	pointer
->	O
skip_rn	enum
=	O
RN_OptN	int
;	O
ioff	long
++	O
;	O
}	O
goto	O
AGAIN	O
;	O
}	O
if	O
(	O
buf	pointer
[	O
0	int
]	O
==	O
'\n'	O
)	O
{	O
ioff	long
++	O
;	O
pp	pointer
->	O
skip_rn	enum
=	O
RN_Inactive	int
;	O
goto	O
AGAIN	O
;	O
}	O
pp	pointer
->	O
skip_rn	enum
=	O
RN_Inactive	int
;	O
pp	pointer
->	O
state	pointer
=	O
PP_Error	int
;	O
return	O
MHD_NO	int
;	O
case	O
RN_Dash2	int
:	O
if	O
(	O
buf	pointer
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
ioff	long
++	O
;	O
pp	pointer
->	O
skip_rn	enum
=	O
RN_Full	int
;	O
pp	pointer
->	O
state	pointer
=	O
pp	pointer
->	O
dash_state	enum
;	O
goto	O
AGAIN	O
;	O
}	O
pp	pointer
->	O
state	pointer
=	O
PP_Error	int
;	O
break	O
;	O
}	O
switch	O
(	O
pp	pointer
->	O
state	pointer
)	O
{	O
case	O
PP_Error	int
:	O
return	O
MHD_NO	int
;	O
case	O
PP_Done	int
:	O
pp	pointer
->	O
state	pointer
=	O
PP_Error	int
;	O
return	O
MHD_NO	int
;	O
case	O
PP_Init	int
:	O
(	O
void	O
)	O
find_boundary	function
(	O
pp	pointer
,	O
pp	pointer
->	O
boundary	pointer
,	O
pp	pointer
->	O
blen	long
,	O
&	O
ioff	long
,	O
PP_ProcessEntryHeaders	int
,	O
PP_Done	int
)	O
;	O
break	O
;	O
case	O
PP_NextBoundary	int
:	O
if	O
(	O
MHD_NO	int
==	O
find_boundary	function
(	O
pp	pointer
,	O
pp	pointer
->	O
boundary	pointer
,	O
pp	pointer
->	O
blen	long
,	O
&	O
ioff	long
,	O
PP_ProcessEntryHeaders	int
,	O
PP_Done	int
)	O
)	O
{	O
if	O
(	O
pp	pointer
->	O
state	pointer
==	O
PP_Error	int
)	O
return	O
MHD_NO	int
;	O
goto	O
END	O
;	O
}	O
break	O
;	O
case	O
PP_ProcessEntryHeaders	int
:	O
pp	pointer
->	O
must_ikvi	bool
=	O
true	int
;	O
if	O
(	O
MHD_NO	int
==	O
process_multipart_headers	function
(	O
pp	pointer
,	O
&	O
ioff	long
,	O
PP_PerformCheckMultipart	int
)	O
)	O
{	O
if	O
(	O
pp	pointer
->	O
state	pointer
==	O
PP_Error	int
)	O
return	O
MHD_NO	int
;	O
else	O
goto	O
END	O
;	O
}	O
state_changed	int
=	O
1	int
;	O
break	O
;	O
case	O
PP_PerformCheckMultipart	int
:	O
if	O
(	O
(	O
NULL	O
!=	O
pp	pointer
->	O
content_type	pointer
)	O
&&	O
(	O
MHD_str_equal_caseless_n_	function
(	O
pp	pointer
->	O
content_type	pointer
,	O
"multipart/mixed"	pointer
,	O
MHD_STATICSTR_LEN_	O
(	O
"multipart/mixed"	pointer
)	O
)	O
)	O
)	O
{	O
pp	pointer
->	O
nested_boundary	pointer
=	O
strstr	function
(	O
pp	pointer
->	O
content_type	pointer
,	O
"boundary="	pointer
)	O
;	O
if	O
(	O
NULL	O
==	O
pp	pointer
->	O
nested_boundary	pointer
)	O
{	O
pp	pointer
->	O
state	pointer
=	O
PP_Error	int
;	O
return	O
MHD_NO	int
;	O
}	O
pp	pointer
->	O
nested_boundary	pointer
=	O
strdup	function
(	O
&	O
pp	pointer
->	O
nested_boundary	pointer
[	O
MHD_STATICSTR_LEN_	O
(	O
"boundary="	pointer
)	O
]	O
)	O
;	O
if	O
(	O
NULL	O
==	O
pp	pointer
->	O
nested_boundary	pointer
)	O
{	O
pp	pointer
->	O
state	pointer
=	O
PP_Error	int
;	O
return	O
MHD_NO	int
;	O
}	O
free	function
(	O
pp	pointer
->	O
content_type	pointer
)	O
;	O
pp	pointer
->	O
content_type	pointer
=	O
NULL	O
;	O
pp	pointer
->	O
nlen	long
=	O
strlen	function
(	O
pp	pointer
->	O
nested_boundary	pointer
)	O
;	O
pp	pointer
->	O
state	pointer
=	O
PP_Nested_Init	int
;	O
state_changed	int
=	O
1	int
;	O
break	O
;	O
}	O
pp	pointer
->	O
state	pointer
=	O
PP_ProcessValueToBoundary	int
;	O
pp	pointer
->	O
value_offset	long
=	O
0	int
;	O
state_changed	int
=	O
1	int
;	O
break	O
;	O
case	O
PP_ProcessValueToBoundary	int
:	O
if	O
(	O
MHD_NO	int
==	O
process_value_to_boundary	function
(	O
pp	pointer
,	O
&	O
ioff	long
,	O
pp	pointer
->	O
boundary	pointer
,	O
pp	pointer
->	O
blen	long
,	O
PP_PerformCleanup	int
,	O
PP_Done	int
)	O
)	O
{	O
if	O
(	O
pp	pointer
->	O
state	pointer
==	O
PP_Error	int
)	O
return	O
MHD_NO	int
;	O
break	O
;	O
}	O
break	O
;	O
case	O
PP_PerformCleanup	int
:	O
pp	pointer
->	O
have	enum
=	O
NE_none	int
;	O
free_unmarked	function
(	O
pp	pointer
)	O
;	O
if	O
(	O
NULL	O
!=	O
pp	pointer
->	O
nested_boundary	pointer
)	O
{	O
free	function
(	O
pp	pointer
->	O
nested_boundary	pointer
)	O
;	O
pp	pointer
->	O
nested_boundary	pointer
=	O
NULL	O
;	O
}	O
pp	pointer
->	O
state	pointer
=	O
PP_ProcessEntryHeaders	int
;	O
state_changed	int
=	O
1	int
;	O
break	O
;	O
case	O
PP_Nested_Init	int
:	O
if	O
(	O
NULL	O
==	O
pp	pointer
->	O
nested_boundary	pointer
)	O
{	O
pp	pointer
->	O
state	pointer
=	O
PP_Error	int
;	O
return	O
MHD_NO	int
;	O
}	O
if	O
(	O
MHD_NO	int
==	O
find_boundary	function
(	O
pp	pointer
,	O
pp	pointer
->	O
nested_boundary	pointer
,	O
pp	pointer
->	O
nlen	long
,	O
&	O
ioff	long
,	O
PP_Nested_PerformMarking	int
,	O
PP_NextBoundary	int
)	O
)	O
{	O
if	O
(	O
pp	pointer
->	O
state	pointer
==	O
PP_Error	int
)	O
return	O
MHD_NO	int
;	O
goto	O
END	O
;	O
}	O
break	O
;	O
case	O
PP_Nested_PerformMarking	int
:	O
pp	pointer
->	O
have	enum
=	O
NE_none	int
;	O
if	O
(	O
NULL	O
!=	O
pp	pointer
->	O
content_name	pointer
)	O
pp	pointer
->	O
have	enum
|=	O
NE_content_name	int
;	O
if	O
(	O
NULL	O
!=	O
pp	pointer
->	O
content_type	pointer
)	O
pp	pointer
->	O
have	enum
|=	O
NE_content_type	int
;	O
if	O
(	O
NULL	O
!=	O
pp	pointer
->	O
content_filename	pointer
)	O
pp	pointer
->	O
have	enum
|=	O
NE_content_filename	int
;	O
if	O
(	O
NULL	O
!=	O
pp	pointer
->	O
content_transfer_encoding	pointer
)	O
pp	pointer
->	O
have	enum
|=	O
NE_content_transfer_encoding	int
;	O
pp	pointer
->	O
state	pointer
=	O
PP_Nested_ProcessEntryHeaders	int
;	O
state_changed	int
=	O
1	int
;	O
break	O
;	O
case	O
PP_Nested_ProcessEntryHeaders	int
:	O
pp	pointer
->	O
value_offset	long
=	O
0	int
;	O
if	O
(	O
MHD_NO	int
==	O
process_multipart_headers	function
(	O
pp	pointer
,	O
&	O
ioff	long
,	O
PP_Nested_ProcessValueToBoundary	int
)	O
)	O
{	O
if	O
(	O
pp	pointer
->	O
state	pointer
==	O
PP_Error	int
)	O
return	O
MHD_NO	int
;	O
else	O
goto	O
END	O
;	O
}	O
state_changed	int
=	O
1	int
;	O
break	O
;	O
case	O
PP_Nested_ProcessValueToBoundary	int
:	O
if	O
(	O
MHD_NO	int
==	O
process_value_to_boundary	function
(	O
pp	pointer
,	O
&	O
ioff	long
,	O
pp	pointer
->	O
nested_boundary	pointer
,	O
pp	pointer
->	O
nlen	long
,	O
PP_Nested_PerformCleanup	int
,	O
PP_NextBoundary	int
)	O
)	O
{	O
if	O
(	O
pp	pointer
->	O
state	pointer
==	O
PP_Error	int
)	O
return	O
MHD_NO	int
;	O
break	O
;	O
}	O
break	O
;	O
case	O
PP_Nested_PerformCleanup	int
:	O
free_unmarked	function
(	O
pp	pointer
)	O
;	O
pp	pointer
->	O
state	pointer
=	O
PP_Nested_ProcessEntryHeaders	int
;	O
state_changed	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
mhd_panic	pointer
(	O
mhd_panic_cls	pointer
,	O
__FILE__	O
,	O
__LINE__	O
,	O
NULL	O
)	O
;	O
}	O
AGAIN	O
:	O
if	O
(	O
ioff	long
>	O
0	int
)	O
{	O
memmove	function
(	O
buf	pointer
,	O
&	O
buf	pointer
[	O
ioff	long
]	O
,	O
pp	pointer
->	O
buffer_pos	long
-	O
ioff	long
)	O
;	O
pp	pointer
->	O
buffer_pos	long
-=	O
ioff	long
;	O
ioff	long
=	O
0	int
;	O
state_changed	int
=	O
1	int
;	O
}	O
}	O
END	O
:	O
if	O
(	O
0	int
!=	O
ioff	long
)	O
{	O
memmove	function
(	O
buf	pointer
,	O
&	O
buf	pointer
[	O
ioff	long
]	O
,	O
pp	pointer
->	O
buffer_pos	long
-	O
ioff	long
)	O
;	O
pp	pointer
->	O
buffer_pos	long
-=	O
ioff	long
;	O
}	O
if	O
(	O
poff	long
<	O
post_data_len	long
)	O
{	O
pp	pointer
->	O
state	pointer
=	O
PP_Error	int
;	O
return	O
MHD_NO	int
;	O
}	O
return	O
MHD_YES	int
;	O
}	O
int	O
MHD_post_process	function
(	O
struct	O
MHD_PostProcessor	struct
*	O
pp	pointer
,	O
const	O
char	O
*	O
post_data	pointer
,	O
size_t	long
post_data_len	long
)	O
{	O
if	O
(	O
0	int
==	O
post_data_len	long
)	O
return	O
MHD_YES	int
;	O
if	O
(	O
NULL	O
==	O
pp	pointer
)	O
return	O
MHD_NO	int
;	O
if	O
(	O
MHD_str_equal_caseless_n_	function
(	O
MHD_HTTP_POST_ENCODING_FORM_URLENCODED	pointer
,	O
pp	pointer
->	O
encoding	pointer
,	O
MHD_STATICSTR_LEN_	O
(	O
MHD_HTTP_POST_ENCODING_FORM_URLENCODED	pointer
)	O
)	O
)	O
return	O
post_process_urlencoded	function
(	O
pp	pointer
,	O
post_data	pointer
,	O
post_data_len	long
)	O
;	O
if	O
(	O
MHD_str_equal_caseless_n_	function
(	O
MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA	pointer
,	O
pp	pointer
->	O
encoding	pointer
,	O
MHD_STATICSTR_LEN_	O
(	O
MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA	pointer
)	O
)	O
)	O
return	O
post_process_multipart	function
(	O
pp	pointer
,	O
post_data	pointer
,	O
post_data_len	long
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
int	O
MHD_destroy_post_processor	function
(	O
struct	O
MHD_PostProcessor	struct
*	O
pp	pointer
)	O
{	O
int	O
ret	pointer
;	O
if	O
(	O
NULL	O
==	O
pp	pointer
)	O
return	O
MHD_YES	int
;	O
if	O
(	O
PP_ProcessValue	int
==	O
pp	pointer
->	O
state	pointer
)	O
{	O
post_process_urlencoded	function
(	O
pp	pointer
,	O
"\n"	pointer
,	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
pp	pointer
->	O
xbuf_pos	long
>	O
0	int
)	O
||	O
(	O
pp	pointer
->	O
state	pointer
!=	O
PP_Done	int
)	O
)	O
ret	pointer
=	O
MHD_NO	int
;	O
else	O
ret	pointer
=	O
MHD_YES	int
;	O
pp	pointer
->	O
have	enum
=	O
NE_none	int
;	O
free_unmarked	function
(	O
pp	pointer
)	O
;	O
if	O
(	O
NULL	O
!=	O
pp	pointer
->	O
nested_boundary	pointer
)	O
free	function
(	O
pp	pointer
->	O
nested_boundary	pointer
)	O
;	O
free	function
(	O
pp	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
