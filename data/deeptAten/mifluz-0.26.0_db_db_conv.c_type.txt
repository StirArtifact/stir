static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: db_conv.c,v 1.5 2014/04/17 20:27:26 sebdiaz Exp $"	pointer
;	O
int	O
CDB___db_pgin	function
(	O
dbenv	pointer
,	O
pg	struct
,	O
pp	pointer
,	O
cookie	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
db_pgno_t	int
pg	struct
;	O
void	O
*	O
pp	pointer
;	O
DBT	struct
*	O
cookie	pointer
;	O
{	O
switch	O
(	O
TYPE	O
(	O
pp	pointer
)	O
)	O
{	O
case	O
P_HASH	int
:	O
case	O
P_HASHMETA	int
:	O
case	O
P_INVALID	int
:	O
return	O
(	O
CDB___ham_pgin	function
(	O
dbenv	pointer
,	O
pg	struct
,	O
pp	pointer
,	O
cookie	pointer
)	O
)	O
;	O
case	O
P_BTREEMETA	int
:	O
case	O
P_IBTREE	int
:	O
case	O
P_IRECNO	int
:	O
case	O
P_LBTREE	int
:	O
case	O
P_LDUP	int
:	O
case	O
P_LRECNO	int
:	O
case	O
P_OVERFLOW	int
:	O
return	O
(	O
CDB___bam_pgin	function
(	O
dbenv	pointer
,	O
pg	struct
,	O
pp	pointer
,	O
cookie	pointer
)	O
)	O
;	O
case	O
P_QAMMETA	int
:	O
case	O
P_QAMDATA	int
:	O
return	O
(	O
CDB___qam_pgin_out	function
(	O
dbenv	pointer
,	O
pg	struct
,	O
pp	pointer
,	O
cookie	pointer
)	O
)	O
;	O
default	O
:	O
break	O
;	O
}	O
return	O
(	O
CDB___db_unknown_type	function
(	O
dbenv	pointer
,	O
"CDB___db_pgin"	pointer
,	O
(	O
(	O
PAGE	struct
*	O
)	O
pp	pointer
)	O
->	O
type	enum
)	O
)	O
;	O
}	O
int	O
CDB___db_pgout	function
(	O
dbenv	pointer
,	O
pg	struct
,	O
pp	pointer
,	O
cookie	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
db_pgno_t	int
pg	struct
;	O
void	O
*	O
pp	pointer
;	O
DBT	struct
*	O
cookie	pointer
;	O
{	O
switch	O
(	O
TYPE	O
(	O
pp	pointer
)	O
)	O
{	O
case	O
P_HASH	int
:	O
case	O
P_HASHMETA	int
:	O
case	O
P_INVALID	int
:	O
return	O
(	O
CDB___ham_pgout	function
(	O
dbenv	pointer
,	O
pg	struct
,	O
pp	pointer
,	O
cookie	pointer
)	O
)	O
;	O
case	O
P_BTREEMETA	int
:	O
case	O
P_IBTREE	int
:	O
case	O
P_IRECNO	int
:	O
case	O
P_LBTREE	int
:	O
case	O
P_LDUP	int
:	O
case	O
P_LRECNO	int
:	O
case	O
P_OVERFLOW	int
:	O
return	O
(	O
CDB___bam_pgout	function
(	O
dbenv	pointer
,	O
pg	struct
,	O
pp	pointer
,	O
cookie	pointer
)	O
)	O
;	O
case	O
P_QAMMETA	int
:	O
case	O
P_QAMDATA	int
:	O
return	O
(	O
CDB___qam_pgin_out	function
(	O
dbenv	pointer
,	O
pg	struct
,	O
pp	pointer
,	O
cookie	pointer
)	O
)	O
;	O
default	O
:	O
break	O
;	O
}	O
return	O
(	O
CDB___db_unknown_type	function
(	O
dbenv	pointer
,	O
"CDB___db_pgout"	pointer
,	O
(	O
(	O
PAGE	struct
*	O
)	O
pp	pointer
)	O
->	O
type	enum
)	O
)	O
;	O
}	O
void	O
CDB___db_metaswap	function
(	O
pg	struct
)	O
PAGE	struct
*	O
pg	struct
;	O
{	O
u_int8_t	char
*	O
p	pointer
;	O
p	pointer
=	O
(	O
u_int8_t	char
*	O
)	O
pg	struct
;	O
SWAP32	O
(	O
p	pointer
)	O
;	O
SWAP32	O
(	O
p	pointer
)	O
;	O
SWAP32	O
(	O
p	pointer
)	O
;	O
SWAP32	O
(	O
p	pointer
)	O
;	O
SWAP32	O
(	O
p	pointer
)	O
;	O
SWAP32	O
(	O
p	pointer
)	O
;	O
p	pointer
+=	O
4	int
;	O
SWAP32	O
(	O
p	pointer
)	O
;	O
SWAP32	O
(	O
p	pointer
)	O
;	O
SWAP32	O
(	O
p	pointer
)	O
;	O
SWAP32	O
(	O
p	pointer
)	O
;	O
SWAP32	O
(	O
p	pointer
)	O
;	O
SWAP32	O
(	O
p	pointer
)	O
;	O
}	O
int	O
CDB___db_byteswap	function
(	O
dbenv	pointer
,	O
pg	struct
,	O
h	pointer
,	O
pagesize	long
,	O
pgin	int
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
db_pgno_t	int
pg	struct
;	O
PAGE	struct
*	O
h	pointer
;	O
size_t	long
pagesize	long
;	O
int	O
pgin	int
;	O
{	O
if	O
(	O
pg	struct
)	O
{	O
}	O
BINTERNAL	struct
*	O
bi	pointer
;	O
BKEYDATA	struct
*	O
bk	pointer
;	O
BOVERFLOW	struct
*	O
bo	pointer
;	O
RINTERNAL	struct
*	O
ri	pointer
;	O
db_indx_t	short
i	short
,	O
len	short
,	O
tmp	short
;	O
u_int8_t	char
*	O
p	pointer
,	O
*	O
end	pointer
;	O
COMPQUIET	O
(	O
pg	struct
,	O
0	int
)	O
;	O
if	O
(	O
pgin	int
)	O
{	O
M_32_SWAP	O
(	O
h	pointer
->	O
lsn	struct
.	O
file	int
)	O
;	O
M_32_SWAP	O
(	O
h	pointer
->	O
lsn	struct
.	O
offset	int
)	O
;	O
M_32_SWAP	O
(	O
h	pointer
->	O
pgno	int
)	O
;	O
M_32_SWAP	O
(	O
h	pointer
->	O
prev_pgno	int
)	O
;	O
M_32_SWAP	O
(	O
h	pointer
->	O
next_pgno	int
)	O
;	O
M_16_SWAP	O
(	O
h	pointer
->	O
entries	short
)	O
;	O
M_16_SWAP	O
(	O
h	pointer
->	O
hf_offset	short
)	O
;	O
}	O
switch	O
(	O
TYPE	O
(	O
h	pointer
)	O
)	O
{	O
case	O
P_HASH	int
:	O
for	O
(	O
i	short
=	O
0	int
;	O
i	short
<	O
NUM_ENT	O
(	O
h	pointer
)	O
;	O
i	short
++	O
)	O
{	O
if	O
(	O
pgin	int
)	O
M_16_SWAP	O
(	O
h	pointer
->	O
inp	array
[	O
i	short
]	O
)	O
;	O
switch	O
(	O
HPAGE_TYPE	O
(	O
h	pointer
,	O
i	short
)	O
)	O
{	O
case	O
H_KEYDATA	int
:	O
break	O
;	O
case	O
H_DUPLICATE	int
:	O
len	short
=	O
LEN_HKEYDATA	O
(	O
h	pointer
,	O
pagesize	long
,	O
i	short
)	O
;	O
p	pointer
=	O
HKEYDATA_DATA	O
(	O
P_ENTRY	O
(	O
h	pointer
,	O
i	short
)	O
)	O
;	O
for	O
(	O
end	pointer
=	O
p	pointer
+	O
len	short
;	O
p	pointer
<	O
end	pointer
;	O
)	O
{	O
if	O
(	O
pgin	int
)	O
{	O
P_16_SWAP	O
(	O
p	pointer
)	O
;	O
memcpy	function
(	O
&	O
tmp	short
,	O
p	pointer
,	O
sizeof	O
(	O
db_indx_t	short
)	O
)	O
;	O
p	pointer
+=	O
sizeof	O
(	O
db_indx_t	short
)	O
;	O
}	O
else	O
{	O
memcpy	function
(	O
&	O
tmp	short
,	O
p	pointer
,	O
sizeof	O
(	O
db_indx_t	short
)	O
)	O
;	O
SWAP16	O
(	O
p	pointer
)	O
;	O
}	O
p	pointer
+=	O
tmp	short
;	O
SWAP16	O
(	O
p	pointer
)	O
;	O
}	O
break	O
;	O
case	O
H_OFFDUP	int
:	O
p	pointer
=	O
HOFFPAGE_PGNO	O
(	O
P_ENTRY	O
(	O
h	pointer
,	O
i	short
)	O
)	O
;	O
SWAP32	O
(	O
p	pointer
)	O
;	O
break	O
;	O
case	O
H_OFFPAGE	int
:	O
p	pointer
=	O
HOFFPAGE_PGNO	O
(	O
P_ENTRY	O
(	O
h	pointer
,	O
i	short
)	O
)	O
;	O
SWAP32	O
(	O
p	pointer
)	O
;	O
SWAP32	O
(	O
p	pointer
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
pgin	int
)	O
for	O
(	O
i	short
=	O
0	int
;	O
i	short
<	O
NUM_ENT	O
(	O
h	pointer
)	O
;	O
i	short
++	O
)	O
M_16_SWAP	O
(	O
h	pointer
->	O
inp	array
[	O
i	short
]	O
)	O
;	O
break	O
;	O
case	O
P_LBTREE	int
:	O
case	O
P_LDUP	int
:	O
case	O
P_LRECNO	int
:	O
for	O
(	O
i	short
=	O
0	int
;	O
i	short
<	O
NUM_ENT	O
(	O
h	pointer
)	O
;	O
i	short
++	O
)	O
{	O
if	O
(	O
pgin	int
)	O
M_16_SWAP	O
(	O
h	pointer
->	O
inp	array
[	O
i	short
]	O
)	O
;	O
if	O
(	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_LBTREE	int
&&	O
i	short
>	O
1	int
)	O
{	O
if	O
(	O
pgin	int
)	O
{	O
if	O
(	O
h	pointer
->	O
inp	array
[	O
i	short
]	O
==	O
h	pointer
->	O
inp	array
[	O
i	short
-	O
2	int
]	O
)	O
continue	O
;	O
}	O
else	O
{	O
M_16_SWAP	O
(	O
h	pointer
->	O
inp	array
[	O
i	short
]	O
)	O
;	O
if	O
(	O
h	pointer
->	O
inp	array
[	O
i	short
]	O
==	O
h	pointer
->	O
inp	array
[	O
i	short
-	O
2	int
]	O
)	O
continue	O
;	O
M_16_SWAP	O
(	O
h	pointer
->	O
inp	array
[	O
i	short
]	O
)	O
;	O
}	O
}	O
bk	pointer
=	O
GET_BKEYDATA	O
(	O
h	pointer
,	O
i	short
)	O
;	O
switch	O
(	O
B_TYPE	O
(	O
bk	pointer
->	O
type	enum
)	O
)	O
{	O
case	O
B_KEYDATA	int
:	O
M_16_SWAP	O
(	O
bk	pointer
->	O
len	short
)	O
;	O
break	O
;	O
case	O
B_DUPLICATE	int
:	O
case	O
B_OVERFLOW	int
:	O
bo	pointer
=	O
(	O
BOVERFLOW	struct
*	O
)	O
bk	pointer
;	O
M_32_SWAP	O
(	O
bo	pointer
->	O
pgno	int
)	O
;	O
M_32_SWAP	O
(	O
bo	pointer
->	O
tlen	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
pgin	int
)	O
M_16_SWAP	O
(	O
h	pointer
->	O
inp	array
[	O
i	short
]	O
)	O
;	O
}	O
break	O
;	O
case	O
P_IBTREE	int
:	O
for	O
(	O
i	short
=	O
0	int
;	O
i	short
<	O
NUM_ENT	O
(	O
h	pointer
)	O
;	O
i	short
++	O
)	O
{	O
if	O
(	O
pgin	int
)	O
M_16_SWAP	O
(	O
h	pointer
->	O
inp	array
[	O
i	short
]	O
)	O
;	O
bi	pointer
=	O
GET_BINTERNAL	O
(	O
h	pointer
,	O
i	short
)	O
;	O
M_16_SWAP	O
(	O
bi	pointer
->	O
len	short
)	O
;	O
M_32_SWAP	O
(	O
bi	pointer
->	O
pgno	int
)	O
;	O
M_32_SWAP	O
(	O
bi	pointer
->	O
nrecs	int
)	O
;	O
switch	O
(	O
B_TYPE	O
(	O
bi	pointer
->	O
type	enum
)	O
)	O
{	O
case	O
B_KEYDATA	int
:	O
break	O
;	O
case	O
B_DUPLICATE	int
:	O
case	O
B_OVERFLOW	int
:	O
bo	pointer
=	O
(	O
BOVERFLOW	struct
*	O
)	O
bi	pointer
->	O
data	pointer
;	O
M_32_SWAP	O
(	O
bo	pointer
->	O
pgno	int
)	O
;	O
M_32_SWAP	O
(	O
bo	pointer
->	O
tlen	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
pgin	int
)	O
M_16_SWAP	O
(	O
h	pointer
->	O
inp	array
[	O
i	short
]	O
)	O
;	O
}	O
break	O
;	O
case	O
P_IRECNO	int
:	O
for	O
(	O
i	short
=	O
0	int
;	O
i	short
<	O
NUM_ENT	O
(	O
h	pointer
)	O
;	O
i	short
++	O
)	O
{	O
if	O
(	O
pgin	int
)	O
M_16_SWAP	O
(	O
h	pointer
->	O
inp	array
[	O
i	short
]	O
)	O
;	O
ri	pointer
=	O
GET_RINTERNAL	O
(	O
h	pointer
,	O
i	short
)	O
;	O
M_32_SWAP	O
(	O
ri	pointer
->	O
pgno	int
)	O
;	O
M_32_SWAP	O
(	O
ri	pointer
->	O
nrecs	int
)	O
;	O
if	O
(	O
!	O
pgin	int
)	O
M_16_SWAP	O
(	O
h	pointer
->	O
inp	array
[	O
i	short
]	O
)	O
;	O
}	O
break	O
;	O
case	O
P_OVERFLOW	int
:	O
case	O
P_INVALID	int
:	O
break	O
;	O
default	O
:	O
return	O
(	O
CDB___db_unknown_type	function
(	O
dbenv	pointer
,	O
"CDB___db_byteswap"	pointer
,	O
h	pointer
->	O
type	enum
)	O
)	O
;	O
}	O
if	O
(	O
!	O
pgin	int
)	O
{	O
M_32_SWAP	O
(	O
h	pointer
->	O
lsn	struct
.	O
file	int
)	O
;	O
M_32_SWAP	O
(	O
h	pointer
->	O
lsn	struct
.	O
offset	int
)	O
;	O
M_32_SWAP	O
(	O
h	pointer
->	O
pgno	int
)	O
;	O
M_32_SWAP	O
(	O
h	pointer
->	O
prev_pgno	int
)	O
;	O
M_32_SWAP	O
(	O
h	pointer
->	O
next_pgno	int
)	O
;	O
M_16_SWAP	O
(	O
h	pointer
->	O
entries	short
)	O
;	O
M_16_SWAP	O
(	O
h	pointer
->	O
hf_offset	short
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
