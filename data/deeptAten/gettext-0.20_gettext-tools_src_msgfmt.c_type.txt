static	O
int	O
exit_status	int
;	O
static	O
bool	bool
include_fuzzies	bool
=	O
false	int
;	O
static	O
bool	bool
include_untranslated	bool
=	O
false	int
;	O
static	O
const	O
char	O
*	O
output_file_name	pointer
;	O
static	O
bool	bool
java_mode	bool
;	O
static	O
bool	bool
assume_java2	bool
;	O
static	O
const	O
char	O
*	O
java_resource_name	pointer
;	O
static	O
const	O
char	O
*	O
java_locale_name	pointer
;	O
static	O
const	O
char	O
*	O
java_class_directory	pointer
;	O
static	O
bool	bool
java_output_source	bool
;	O
static	O
bool	bool
csharp_mode	bool
;	O
static	O
const	O
char	O
*	O
csharp_resource_name	pointer
;	O
static	O
const	O
char	O
*	O
csharp_locale_name	pointer
;	O
static	O
const	O
char	O
*	O
csharp_base_directory	pointer
;	O
static	O
bool	bool
csharp_resources_mode	bool
;	O
static	O
bool	bool
tcl_mode	bool
;	O
static	O
const	O
char	O
*	O
tcl_locale_name	pointer
;	O
static	O
const	O
char	O
*	O
tcl_base_directory	pointer
;	O
static	O
bool	bool
qt_mode	bool
;	O
static	O
bool	bool
desktop_mode	bool
;	O
static	O
const	O
char	O
*	O
desktop_locale_name	pointer
;	O
static	O
const	O
char	O
*	O
desktop_template_name	pointer
;	O
static	O
const	O
char	O
*	O
desktop_base_directory	pointer
;	O
static	O
hash_table	struct
desktop_keywords	struct
;	O
static	O
bool	bool
desktop_default_keywords	bool
=	O
true	int
;	O
static	O
bool	bool
xml_mode	bool
;	O
static	O
const	O
char	O
*	O
xml_locale_name	pointer
;	O
static	O
const	O
char	O
*	O
xml_template_name	pointer
;	O
static	O
const	O
char	O
*	O
xml_base_directory	pointer
;	O
static	O
const	O
char	O
*	O
xml_language	pointer
;	O
static	O
its_rule_list_ty	struct
*	O
xml_its_rules	pointer
;	O
struct	O
msg_domain	struct
{	O
message_list_ty	struct
*	O
mlp	pointer
;	O
const	O
char	O
*	O
domain_name	pointer
;	O
const	O
char	O
*	O
file_name	pointer
;	O
struct	O
msg_domain	struct
*	O
next	pointer
;	O
}	O
;	O
static	O
struct	O
msg_domain	struct
*	O
domain_list	pointer
;	O
static	O
struct	O
msg_domain	struct
*	O
current_domain	pointer
;	O
int	O
verbose	int
=	O
0	int
;	O
static	O
bool	bool
check_format_strings	int
=	O
false	int
;	O
static	O
bool	bool
check_header	int
=	O
false	int
;	O
static	O
bool	bool
check_domain	bool
=	O
false	int
;	O
static	O
bool	bool
check_compatibility	int
=	O
false	int
;	O
static	O
bool	bool
check_accelerators	int
=	O
false	int
;	O
static	O
char	O
accelerator_char	char
=	O
'&'	O
;	O
static	O
int	O
msgs_translated	int
;	O
static	O
int	O
msgs_untranslated	int
;	O
static	O
int	O
msgs_fuzzy	int
;	O
static	O
int	O
do_statistics	int
;	O
static	O
const	O
struct	O
option	struct
long_options	array
[	O
]	O
=	O
{	O
{	O
"alignment"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'a'	O
}	O
,	O
{	O
"check"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'c'	O
}	O
,	O
{	O
"check-accelerators"	pointer
,	O
optional_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
1	int
}	O
,	O
{	O
"check-compatibility"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'C'	O
}	O
,	O
{	O
"check-domain"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
2	int
}	O
,	O
{	O
"check-format"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
3	int
}	O
,	O
{	O
"check-header"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
4	int
}	O
,	O
{	O
"csharp"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
10	int
}	O
,	O
{	O
"csharp-resources"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
11	int
}	O
,	O
{	O
"desktop"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
15	int
}	O
,	O
{	O
"directory"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'D'	O
}	O
,	O
{	O
"endianness"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
13	int
}	O
,	O
{	O
"help"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'h'	O
}	O
,	O
{	O
"java"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'j'	O
}	O
,	O
{	O
"java2"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
5	int
}	O
,	O
{	O
"keyword"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'k'	O
}	O
,	O
{	O
"language"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'L'	O
}	O
,	O
{	O
"locale"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'l'	O
}	O
,	O
{	O
"no-hash"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
6	int
}	O
,	O
{	O
"output-file"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'o'	O
}	O
,	O
{	O
"properties-input"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'P'	O
}	O
,	O
{	O
"qt"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
9	int
}	O
,	O
{	O
"resource"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'r'	O
}	O
,	O
{	O
"source"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
14	int
}	O
,	O
{	O
"statistics"	pointer
,	O
no_argument	int
,	O
&	O
do_statistics	int
,	O
1	int
}	O
,	O
{	O
"strict"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'S'	O
}	O
,	O
{	O
"stringtable-input"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
8	int
}	O
,	O
{	O
"tcl"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
7	int
}	O
,	O
{	O
"template"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
16	int
}	O
,	O
{	O
"use-fuzzy"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'f'	O
}	O
,	O
{	O
"use-untranslated"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
12	int
}	O
,	O
{	O
"verbose"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'v'	O
}	O
,	O
{	O
"version"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'V'	O
}	O
,	O
{	O
"xml"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'x'	O
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
void	O
usage	function
(	O
int	O
status	int
)	O
__attribute__	O
(	O
(	O
noreturn	O
)	O
)	O
;	O
static	O
const	O
char	O
*	O
add_mo_suffix	function
(	O
const	O
char	O
*	O
)	O
;	O
static	O
struct	O
msg_domain	struct
*	O
new_domain	function
(	O
const	O
char	O
*	O
name	pointer
,	O
const	O
char	O
*	O
file_name	pointer
)	O
;	O
static	O
bool	bool
is_nonobsolete	function
(	O
const	O
message_ty	struct
*	O
mp	pointer
)	O
;	O
static	O
void	O
read_catalog_file_msgfmt	function
(	O
char	O
*	O
filename	pointer
,	O
catalog_input_format_ty	pointer
input_syntax	pointer
)	O
;	O
static	O
int	O
msgfmt_desktop_bulk	function
(	O
const	O
char	O
*	O
directory	pointer
,	O
const	O
char	O
*	O
template_file_name	pointer
,	O
hash_table	struct
*	O
keywords	pointer
,	O
const	O
char	O
*	O
file_name	pointer
)	O
;	O
static	O
int	O
msgfmt_xml_bulk	function
(	O
const	O
char	O
*	O
directory	pointer
,	O
const	O
char	O
*	O
template_file_name	pointer
,	O
its_rule_list_ty	struct
*	O
its_rules	pointer
,	O
const	O
char	O
*	O
file_name	pointer
)	O
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array
[	O
]	O
)	O
{	O
int	O
opt	int
;	O
bool	bool
do_help	bool
=	O
false	int
;	O
bool	bool
do_version	bool
=	O
false	int
;	O
bool	bool
strict_uniforum	bool
=	O
false	int
;	O
catalog_input_format_ty	pointer
input_syntax	pointer
=	O
&	O
input_format_po	struct
;	O
int	O
arg_i	int
;	O
const	O
char	O
*	O
canon_encoding	pointer
;	O
struct	O
msg_domain	struct
*	O
domain	pointer
;	O
alignment	long
=	O
DEFAULT_OUTPUT_ALIGNMENT	int
;	O
byteswap	bool
=	O
0	int
^	O
ENDIANNESS	int
;	O
set_program_name	function
(	O
argv	array
[	O
0	int
]	O
)	O
;	O
error_print_progname	pointer
=	O
maybe_print_progname	function
;	O
error_one_per_line	int
=	O
1	int
;	O
exit_status	int
=	O
EXIT_SUCCESS	int
;	O
setlocale	function
(	O
LC_ALL	O
,	O
""	pointer
)	O
;	O
bindtextdomain	function
(	O
PACKAGE	pointer
,	O
relocate	O
(	O
LOCALEDIR	O
)	O
)	O
;	O
bindtextdomain	function
(	O
"bison-runtime"	pointer
,	O
relocate	O
(	O
BISON_LOCALEDIR	O
)	O
)	O
;	O
textdomain	function
(	O
PACKAGE	pointer
)	O
;	O
atexit	function
(	O
close_stdout	function
)	O
;	O
while	O
(	O
(	O
opt	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	array
,	O
"a:cCd:D:fhjl:L:o:Pr:vVx"	pointer
,	O
long_options	array
,	O
NULL	O
)	O
)	O
!=	O
EOF	O
)	O
switch	O
(	O
opt	int
)	O
{	O
case	O
'\0'	O
:	O
break	O
;	O
case	O
'a'	O
:	O
{	O
char	O
*	O
endp	pointer
;	O
size_t	long
new_align	long
=	O
strtoul	function
(	O
optarg	pointer
,	O
&	O
endp	pointer
,	O
0	int
)	O
;	O
if	O
(	O
endp	pointer
!=	O
optarg	pointer
)	O
alignment	long
=	O
new_align	long
;	O
}	O
break	O
;	O
case	O
'c'	O
:	O
check_domain	bool
=	O
true	int
;	O
check_format_strings	int
=	O
true	int
;	O
check_header	int
=	O
true	int
;	O
break	O
;	O
case	O
'C'	O
:	O
check_compatibility	int
=	O
true	int
;	O
break	O
;	O
case	O
'd'	O
:	O
java_class_directory	pointer
=	O
optarg	pointer
;	O
csharp_base_directory	pointer
=	O
optarg	pointer
;	O
tcl_base_directory	pointer
=	O
optarg	pointer
;	O
desktop_base_directory	pointer
=	O
optarg	pointer
;	O
xml_base_directory	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'D'	O
:	O
dir_list_append	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'f'	O
:	O
include_fuzzies	bool
=	O
true	int
;	O
break	O
;	O
case	O
'h'	O
:	O
do_help	bool
=	O
true	int
;	O
break	O
;	O
case	O
'j'	O
:	O
java_mode	bool
=	O
true	int
;	O
break	O
;	O
case	O
'k'	O
:	O
if	O
(	O
optarg	pointer
==	O
NULL	O
)	O
desktop_default_keywords	bool
=	O
false	int
;	O
else	O
{	O
if	O
(	O
desktop_keywords	struct
.	O
table	pointer
==	O
NULL	O
)	O
{	O
hash_init	function
(	O
&	O
desktop_keywords	struct
,	O
100	int
)	O
;	O
desktop_default_keywords	bool
=	O
false	int
;	O
}	O
desktop_add_keyword	function
(	O
&	O
desktop_keywords	struct
,	O
optarg	pointer
,	O
false	int
)	O
;	O
}	O
break	O
;	O
case	O
'l'	O
:	O
java_locale_name	pointer
=	O
optarg	pointer
;	O
csharp_locale_name	pointer
=	O
optarg	pointer
;	O
tcl_locale_name	pointer
=	O
optarg	pointer
;	O
desktop_locale_name	pointer
=	O
optarg	pointer
;	O
xml_locale_name	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'L'	O
:	O
xml_language	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'o'	O
:	O
output_file_name	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'P'	O
:	O
input_syntax	pointer
=	O
&	O
input_format_properties	struct
;	O
break	O
;	O
case	O
'r'	O
:	O
java_resource_name	pointer
=	O
optarg	pointer
;	O
csharp_resource_name	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'S'	O
:	O
strict_uniforum	bool
=	O
true	int
;	O
break	O
;	O
case	O
'v'	O
:	O
verbose	int
++	O
;	O
break	O
;	O
case	O
'V'	O
:	O
do_version	bool
=	O
true	int
;	O
break	O
;	O
case	O
'x'	O
:	O
xml_mode	bool
=	O
true	int
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
1	int
:	O
check_accelerators	int
=	O
true	int
;	O
if	O
(	O
optarg	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
optarg	pointer
[	O
0	int
]	O
!=	O
'\0'	O
&&	O
ispunct	function
(	O
(	O
unsigned	O
char	O
)	O
optarg	pointer
[	O
0	int
]	O
)	O
&&	O
optarg	pointer
[	O
1	int
]	O
==	O
'\0'	O
)	O
accelerator_char	char
=	O
optarg	pointer
[	O
0	int
]	O
;	O
else	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"the argument to %s should be a single punctuation character"	pointer
)	O
,	O
"--check-accelerators"	pointer
)	O
;	O
}	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
2	int
:	O
check_domain	bool
=	O
true	int
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
3	int
:	O
check_format_strings	int
=	O
true	int
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
4	int
:	O
check_header	int
=	O
true	int
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
5	int
:	O
java_mode	bool
=	O
true	int
;	O
assume_java2	bool
=	O
true	int
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
6	int
:	O
no_hash_table	bool
=	O
true	int
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
7	int
:	O
tcl_mode	bool
=	O
true	int
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
8	int
:	O
input_syntax	pointer
=	O
&	O
input_format_stringtable	struct
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
9	int
:	O
qt_mode	bool
=	O
true	int
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
10	int
:	O
csharp_mode	bool
=	O
true	int
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
11	int
:	O
csharp_resources_mode	bool
=	O
true	int
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
12	int
:	O
include_untranslated	bool
=	O
true	int
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
13	int
:	O
{	O
int	O
endianness	int
;	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"big"	pointer
)	O
==	O
0	int
)	O
endianness	int
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"little"	pointer
)	O
==	O
0	int
)	O
endianness	int
=	O
0	int
;	O
else	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"invalid endianness: %s"	pointer
)	O
,	O
optarg	pointer
)	O
;	O
byteswap	bool
=	O
endianness	int
^	O
ENDIANNESS	int
;	O
}	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
14	int
:	O
java_output_source	bool
=	O
true	int
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
15	int
:	O
desktop_mode	bool
=	O
true	int
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
16	int
:	O
desktop_template_name	pointer
=	O
optarg	pointer
;	O
xml_template_name	pointer
=	O
optarg	pointer
;	O
break	O
;	O
default	O
:	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
do_version	bool
)	O
{	O
printf	function
(	O
"%s (GNU %s) %s\n"	pointer
,	O
basename	function
(	O
program_name	pointer
)	O
,	O
PACKAGE	pointer
,	O
VERSION	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Copyright (C) %s Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n"	pointer
)	O
,	O
"1995-2019"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Written by %s.\n"	pointer
)	O
,	O
proper_name	function
(	O
"Ulrich Drepper"	pointer
)	O
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
if	O
(	O
do_help	bool
)	O
usage	function
(	O
EXIT_SUCCESS	int
)	O
;	O
if	O
(	O
optind	int
>=	O
argc	int
&&	O
!	O
(	O
desktop_mode	bool
&&	O
desktop_base_directory	pointer
)	O
&&	O
!	O
(	O
xml_mode	bool
&&	O
xml_base_directory	pointer
)	O
)	O
{	O
error	function
(	O
EXIT_SUCCESS	int
,	O
0	int
,	O
_	O
(	O
"no input file given"	pointer
)	O
)	O
;	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
optind	int
<	O
argc	int
&&	O
(	O
(	O
desktop_mode	bool
&&	O
desktop_base_directory	pointer
)	O
||	O
(	O
xml_mode	bool
&&	O
xml_base_directory	pointer
)	O
)	O
)	O
{	O
error	function
(	O
EXIT_SUCCESS	int
,	O
0	int
,	O
_	O
(	O
"no input file should be given if %s and %s are specified"	pointer
)	O
,	O
desktop_mode	bool
?	O
"--desktop"	pointer
:	O
"--xml"	pointer
,	O
"-d"	pointer
)	O
;	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
{	O
unsigned	O
int	O
modes	int
=	O
(	O
java_mode	bool
?	O
1	int
:	O
0	int
)	O
|	O
(	O
csharp_mode	bool
?	O
2	int
:	O
0	int
)	O
|	O
(	O
csharp_resources_mode	bool
?	O
4	int
:	O
0	int
)	O
|	O
(	O
tcl_mode	bool
?	O
8	int
:	O
0	int
)	O
|	O
(	O
qt_mode	bool
?	O
16	int
:	O
0	int
)	O
|	O
(	O
desktop_mode	bool
?	O
32	int
:	O
0	int
)	O
|	O
(	O
xml_mode	bool
?	O
64	int
:	O
0	int
)	O
;	O
static	O
const	O
char	O
*	O
mode_options	array
[	O
]	O
=	O
{	O
"--java"	pointer
,	O
"--csharp"	pointer
,	O
"--csharp-resources"	pointer
,	O
"--tcl"	pointer
,	O
"--qt"	pointer
,	O
"--desktop"	pointer
,	O
"--xml"	pointer
}	O
;	O
if	O
(	O
modes	int
&	O
(	O
modes	int
-	O
1	int
)	O
)	O
{	O
const	O
char	O
*	O
first_option	pointer
;	O
const	O
char	O
*	O
second_option	pointer
;	O
unsigned	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
;	O
i	long
++	O
)	O
if	O
(	O
modes	int
&	O
(	O
1	int
<<	O
i	long
)	O
)	O
break	O
;	O
first_option	pointer
=	O
mode_options	array
[	O
i	long
]	O
;	O
for	O
(	O
i	long
=	O
i	long
+	O
1	int
;	O
;	O
i	long
++	O
)	O
if	O
(	O
modes	int
&	O
(	O
1	int
<<	O
i	long
)	O
)	O
break	O
;	O
second_option	pointer
=	O
mode_options	array
[	O
i	long
]	O
;	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"%s and %s are mutually exclusive"	pointer
)	O
,	O
first_option	pointer
,	O
second_option	pointer
)	O
;	O
}	O
}	O
if	O
(	O
java_mode	bool
)	O
{	O
if	O
(	O
output_file_name	pointer
!=	O
NULL	O
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"%s and %s are mutually exclusive"	pointer
)	O
,	O
"--java"	pointer
,	O
"--output-file"	pointer
)	O
;	O
}	O
if	O
(	O
java_class_directory	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
EXIT_SUCCESS	int
,	O
0	int
,	O
_	O
(	O
"%s requires a \"-d directory\" specification"	pointer
)	O
,	O
"--java"	pointer
)	O
;	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
csharp_mode	bool
)	O
{	O
if	O
(	O
output_file_name	pointer
!=	O
NULL	O
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"%s and %s are mutually exclusive"	pointer
)	O
,	O
"--csharp"	pointer
,	O
"--output-file"	pointer
)	O
;	O
}	O
if	O
(	O
csharp_locale_name	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
EXIT_SUCCESS	int
,	O
0	int
,	O
_	O
(	O
"%s requires a \"-l locale\" specification"	pointer
)	O
,	O
"--csharp"	pointer
)	O
;	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
csharp_base_directory	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
EXIT_SUCCESS	int
,	O
0	int
,	O
_	O
(	O
"%s requires a \"-d directory\" specification"	pointer
)	O
,	O
"--csharp"	pointer
)	O
;	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
tcl_mode	bool
)	O
{	O
if	O
(	O
output_file_name	pointer
!=	O
NULL	O
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"%s and %s are mutually exclusive"	pointer
)	O
,	O
"--tcl"	pointer
,	O
"--output-file"	pointer
)	O
;	O
}	O
if	O
(	O
tcl_locale_name	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
EXIT_SUCCESS	int
,	O
0	int
,	O
_	O
(	O
"%s requires a \"-l locale\" specification"	pointer
)	O
,	O
"--tcl"	pointer
)	O
;	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
tcl_base_directory	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
EXIT_SUCCESS	int
,	O
0	int
,	O
_	O
(	O
"%s requires a \"-d directory\" specification"	pointer
)	O
,	O
"--tcl"	pointer
)	O
;	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
desktop_mode	bool
)	O
{	O
if	O
(	O
desktop_template_name	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
EXIT_SUCCESS	int
,	O
0	int
,	O
_	O
(	O
"%s requires a \"--template template\" specification"	pointer
)	O
,	O
"--desktop"	pointer
)	O
;	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
output_file_name	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
EXIT_SUCCESS	int
,	O
0	int
,	O
_	O
(	O
"%s requires a \"-o file\" specification"	pointer
)	O
,	O
"--desktop"	pointer
)	O
;	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
desktop_base_directory	pointer
!=	O
NULL	O
&&	O
desktop_locale_name	pointer
!=	O
NULL	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"%s and %s are mutually exclusive in %s"	pointer
)	O
,	O
"-d"	pointer
,	O
"-l"	pointer
,	O
"--desktop"	pointer
)	O
;	O
if	O
(	O
desktop_base_directory	pointer
==	O
NULL	O
&&	O
desktop_locale_name	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
EXIT_SUCCESS	int
,	O
0	int
,	O
_	O
(	O
"%s requires a \"-l locale\" specification"	pointer
)	O
,	O
"--desktop"	pointer
)	O
;	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
xml_mode	bool
)	O
{	O
if	O
(	O
xml_template_name	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
EXIT_SUCCESS	int
,	O
0	int
,	O
_	O
(	O
"%s requires a \"--template template\" specification"	pointer
)	O
,	O
"--xml"	pointer
)	O
;	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
output_file_name	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
EXIT_SUCCESS	int
,	O
0	int
,	O
_	O
(	O
"%s requires a \"-o file\" specification"	pointer
)	O
,	O
"--xml"	pointer
)	O
;	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
xml_base_directory	pointer
!=	O
NULL	O
&&	O
xml_locale_name	pointer
!=	O
NULL	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"%s and %s are mutually exclusive in %s"	pointer
)	O
,	O
"-d"	pointer
,	O
"-l"	pointer
,	O
"--xml"	pointer
)	O
;	O
if	O
(	O
xml_base_directory	pointer
==	O
NULL	O
&&	O
xml_locale_name	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
EXIT_SUCCESS	int
,	O
0	int
,	O
_	O
(	O
"%s requires a \"-l locale\" specification"	pointer
)	O
,	O
"--xml"	pointer
)	O
;	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
java_resource_name	pointer
!=	O
NULL	O
)	O
{	O
error	function
(	O
EXIT_SUCCESS	int
,	O
0	int
,	O
_	O
(	O
"%s is only valid with %s or %s"	pointer
)	O
,	O
"--resource"	pointer
,	O
"--java"	pointer
,	O
"--csharp"	pointer
)	O
;	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
java_locale_name	pointer
!=	O
NULL	O
)	O
{	O
error	function
(	O
EXIT_SUCCESS	int
,	O
0	int
,	O
_	O
(	O
"%s is only valid with %s, %s or %s"	pointer
)	O
,	O
"--locale"	pointer
,	O
"--java"	pointer
,	O
"--csharp"	pointer
,	O
"--tcl"	pointer
)	O
;	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
java_class_directory	pointer
!=	O
NULL	O
)	O
{	O
error	function
(	O
EXIT_SUCCESS	int
,	O
0	int
,	O
_	O
(	O
"%s is only valid with %s, %s or %s"	pointer
)	O
,	O
"-d"	pointer
,	O
"--java"	pointer
,	O
"--csharp"	pointer
,	O
"--tcl"	pointer
)	O
;	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
if	O
(	O
desktop_mode	bool
&&	O
desktop_default_keywords	bool
)	O
{	O
if	O
(	O
desktop_keywords	struct
.	O
table	pointer
==	O
NULL	O
)	O
hash_init	function
(	O
&	O
desktop_keywords	struct
,	O
100	int
)	O
;	O
desktop_add_default_keywords	function
(	O
&	O
desktop_keywords	struct
)	O
;	O
}	O
if	O
(	O
desktop_mode	bool
&&	O
desktop_base_directory	pointer
)	O
{	O
exit_status	int
=	O
msgfmt_desktop_bulk	function
(	O
desktop_base_directory	pointer
,	O
desktop_template_name	pointer
,	O
&	O
desktop_keywords	struct
,	O
output_file_name	pointer
)	O
;	O
if	O
(	O
desktop_keywords	struct
.	O
table	pointer
!=	O
NULL	O
)	O
hash_destroy	function
(	O
&	O
desktop_keywords	struct
)	O
;	O
exit	function
(	O
exit_status	int
)	O
;	O
}	O
if	O
(	O
xml_mode	bool
)	O
{	O
char	O
*	O
*	O
its_dirs	pointer
;	O
char	O
*	O
*	O
dirs	pointer
;	O
locating_rule_list_ty	struct
*	O
its_locating_rules	pointer
;	O
const	O
char	O
*	O
its_basename	pointer
;	O
its_dirs	pointer
=	O
get_search_path	function
(	O
"its"	pointer
)	O
;	O
its_locating_rules	pointer
=	O
locating_rule_list_alloc	function
(	O
)	O
;	O
for	O
(	O
dirs	pointer
=	O
its_dirs	pointer
;	O
*	O
dirs	pointer
!=	O
NULL	O
;	O
dirs	pointer
++	O
)	O
locating_rule_list_add_from_directory	function
(	O
its_locating_rules	pointer
,	O
*	O
dirs	pointer
)	O
;	O
its_basename	pointer
=	O
locating_rule_list_locate	function
(	O
its_locating_rules	pointer
,	O
xml_template_name	pointer
,	O
xml_language	pointer
)	O
;	O
if	O
(	O
its_basename	pointer
!=	O
NULL	O
)	O
{	O
size_t	long
j	long
;	O
xml_its_rules	pointer
=	O
its_rule_list_alloc	function
(	O
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
its_dirs	pointer
[	O
j	long
]	O
!=	O
NULL	O
;	O
j	long
++	O
)	O
{	O
char	O
*	O
its_filename	pointer
=	O
xconcatenated_filename	function
(	O
its_dirs	pointer
[	O
j	long
]	O
,	O
its_basename	pointer
,	O
NULL	O
)	O
;	O
struct	O
stat	struct
statbuf	struct
;	O
bool	bool
ok	bool
=	O
false	int
;	O
if	O
(	O
stat	struct
(	O
its_filename	pointer
,	O
&	O
statbuf	struct
)	O
==	O
0	int
)	O
ok	bool
=	O
its_rule_list_add_from_file	function
(	O
xml_its_rules	pointer
,	O
its_filename	pointer
)	O
;	O
free	function
(	O
its_filename	pointer
)	O
;	O
if	O
(	O
ok	bool
)	O
break	O
;	O
}	O
if	O
(	O
its_dirs	pointer
[	O
j	long
]	O
==	O
NULL	O
)	O
{	O
its_rule_list_free	function
(	O
xml_its_rules	pointer
)	O
;	O
xml_its_rules	pointer
=	O
NULL	O
;	O
}	O
}	O
locating_rule_list_free	function
(	O
its_locating_rules	pointer
)	O
;	O
for	O
(	O
dirs	pointer
=	O
its_dirs	pointer
;	O
*	O
dirs	pointer
!=	O
NULL	O
;	O
dirs	pointer
++	O
)	O
free	function
(	O
*	O
dirs	pointer
)	O
;	O
free	function
(	O
its_dirs	pointer
)	O
;	O
if	O
(	O
xml_its_rules	pointer
==	O
NULL	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"cannot locate ITS rules for %s"	pointer
)	O
,	O
xml_template_name	pointer
)	O
;	O
}	O
if	O
(	O
xml_mode	bool
&&	O
xml_base_directory	pointer
)	O
{	O
exit_status	int
=	O
msgfmt_xml_bulk	function
(	O
xml_base_directory	pointer
,	O
xml_template_name	pointer
,	O
xml_its_rules	pointer
,	O
output_file_name	pointer
)	O
;	O
exit	function
(	O
exit_status	int
)	O
;	O
}	O
if	O
(	O
output_file_name	pointer
!=	O
NULL	O
)	O
current_domain	pointer
=	O
new_domain	function
(	O
output_file_name	pointer
,	O
strict_uniforum	bool
&&	O
!	O
csharp_resources_mode	bool
&&	O
!	O
qt_mode	bool
?	O
add_mo_suffix	function
(	O
output_file_name	pointer
)	O
:	O
output_file_name	pointer
)	O
;	O
for	O
(	O
arg_i	int
=	O
optind	int
;	O
arg_i	int
<	O
argc	int
;	O
arg_i	int
++	O
)	O
{	O
if	O
(	O
output_file_name	pointer
==	O
NULL	O
)	O
current_domain	pointer
=	O
NULL	O
;	O
read_catalog_file_msgfmt	function
(	O
argv	array
[	O
arg_i	int
]	O
,	O
input_syntax	pointer
)	O
;	O
}	O
canon_encoding	pointer
=	O
(	O
input_syntax	pointer
->	O
produces_utf8	bool
?	O
po_charset_utf8	pointer
:	O
NULL	O
)	O
;	O
for	O
(	O
domain	pointer
=	O
domain_list	pointer
;	O
domain	pointer
!=	O
NULL	O
;	O
domain	pointer
=	O
domain	pointer
->	O
next	pointer
)	O
message_list_remove_if_not	function
(	O
domain	pointer
->	O
mlp	pointer
,	O
is_nonobsolete	function
)	O
;	O
{	O
int	O
nerrors	int
=	O
0	int
;	O
for	O
(	O
domain	pointer
=	O
domain_list	pointer
;	O
domain	pointer
!=	O
NULL	O
;	O
domain	pointer
=	O
domain	pointer
->	O
next	pointer
)	O
nerrors	int
+=	O
check_message_list	function
(	O
domain	pointer
->	O
mlp	pointer
,	O
0	int
,	O
0	int
,	O
1	int
,	O
check_format_strings	int
,	O
check_header	int
,	O
check_compatibility	int
,	O
check_accelerators	int
,	O
accelerator_char	char
)	O
;	O
if	O
(	O
nerrors	int
>	O
0	int
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
ngettext	function
(	O
"found %d fatal error"	pointer
,	O
"found %d fatal errors"	pointer
,	O
nerrors	int
)	O
,	O
nerrors	int
)	O
;	O
exit_status	int
=	O
EXIT_FAILURE	int
;	O
}	O
}	O
for	O
(	O
domain	pointer
=	O
domain_list	pointer
;	O
domain	pointer
!=	O
NULL	O
;	O
domain	pointer
=	O
domain	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
java_mode	bool
)	O
{	O
if	O
(	O
msgdomain_write_java	function
(	O
domain	pointer
->	O
mlp	pointer
,	O
canon_encoding	pointer
,	O
java_resource_name	pointer
,	O
java_locale_name	pointer
,	O
java_class_directory	pointer
,	O
assume_java2	bool
,	O
java_output_source	bool
)	O
)	O
exit_status	int
=	O
EXIT_FAILURE	int
;	O
}	O
else	O
if	O
(	O
csharp_mode	bool
)	O
{	O
if	O
(	O
msgdomain_write_csharp	function
(	O
domain	pointer
->	O
mlp	pointer
,	O
canon_encoding	pointer
,	O
csharp_resource_name	pointer
,	O
csharp_locale_name	pointer
,	O
csharp_base_directory	pointer
)	O
)	O
exit_status	int
=	O
EXIT_FAILURE	int
;	O
}	O
else	O
if	O
(	O
csharp_resources_mode	bool
)	O
{	O
if	O
(	O
msgdomain_write_csharp_resources	function
(	O
domain	pointer
->	O
mlp	pointer
,	O
canon_encoding	pointer
,	O
domain	pointer
->	O
domain_name	pointer
,	O
domain	pointer
->	O
file_name	pointer
)	O
)	O
exit_status	int
=	O
EXIT_FAILURE	int
;	O
}	O
else	O
if	O
(	O
tcl_mode	bool
)	O
{	O
if	O
(	O
msgdomain_write_tcl	function
(	O
domain	pointer
->	O
mlp	pointer
,	O
canon_encoding	pointer
,	O
tcl_locale_name	pointer
,	O
tcl_base_directory	pointer
)	O
)	O
exit_status	int
=	O
EXIT_FAILURE	int
;	O
}	O
else	O
if	O
(	O
qt_mode	bool
)	O
{	O
if	O
(	O
msgdomain_write_qt	function
(	O
domain	pointer
->	O
mlp	pointer
,	O
canon_encoding	pointer
,	O
domain	pointer
->	O
domain_name	pointer
,	O
domain	pointer
->	O
file_name	pointer
)	O
)	O
exit_status	int
=	O
EXIT_FAILURE	int
;	O
}	O
else	O
if	O
(	O
desktop_mode	bool
)	O
{	O
if	O
(	O
msgdomain_write_desktop	function
(	O
domain	pointer
->	O
mlp	pointer
,	O
canon_encoding	pointer
,	O
desktop_locale_name	pointer
,	O
desktop_template_name	pointer
,	O
&	O
desktop_keywords	struct
,	O
domain	pointer
->	O
file_name	pointer
)	O
)	O
exit_status	int
=	O
EXIT_FAILURE	int
;	O
if	O
(	O
desktop_keywords	struct
.	O
table	pointer
!=	O
NULL	O
)	O
hash_destroy	function
(	O
&	O
desktop_keywords	struct
)	O
;	O
}	O
else	O
if	O
(	O
xml_mode	bool
)	O
{	O
if	O
(	O
msgdomain_write_xml	function
(	O
domain	pointer
->	O
mlp	pointer
,	O
canon_encoding	pointer
,	O
xml_locale_name	pointer
,	O
xml_template_name	pointer
,	O
xml_its_rules	pointer
,	O
domain	pointer
->	O
file_name	pointer
)	O
)	O
exit_status	int
=	O
EXIT_FAILURE	int
;	O
}	O
else	O
{	O
if	O
(	O
msgdomain_write_mo	function
(	O
domain	pointer
->	O
mlp	pointer
,	O
domain	pointer
->	O
domain_name	pointer
,	O
domain	pointer
->	O
file_name	pointer
)	O
)	O
exit_status	int
=	O
EXIT_FAILURE	int
;	O
}	O
message_list_free	function
(	O
domain	pointer
->	O
mlp	pointer
,	O
0	int
)	O
;	O
}	O
if	O
(	O
verbose	int
||	O
do_statistics	int
)	O
{	O
if	O
(	O
do_statistics	int
+	O
verbose	int
>=	O
2	int
&&	O
optind	int
<	O
argc	int
)	O
{	O
char	O
*	O
all_input_file_names	pointer
;	O
{	O
string_list_ty	struct
input_file_names	struct
;	O
string_list_init	function
(	O
&	O
input_file_names	struct
)	O
;	O
;	O
for	O
(	O
arg_i	int
=	O
optind	int
;	O
arg_i	int
<	O
argc	int
;	O
arg_i	int
++	O
)	O
string_list_append	function
(	O
&	O
input_file_names	struct
,	O
argv	array
[	O
arg_i	int
]	O
)	O
;	O
all_input_file_names	pointer
=	O
string_list_join	function
(	O
&	O
input_file_names	struct
,	O
", "	pointer
,	O
'\0'	O
,	O
false	int
)	O
;	O
string_list_destroy	function
(	O
&	O
input_file_names	struct
)	O
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: "	pointer
)	O
,	O
all_input_file_names	pointer
)	O
;	O
free	function
(	O
all_input_file_names	pointer
)	O
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
ngettext	function
(	O
"%d translated message"	pointer
,	O
"%d translated messages"	pointer
,	O
msgs_translated	int
)	O
,	O
msgs_translated	int
)	O
;	O
if	O
(	O
msgs_fuzzy	int
>	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
ngettext	function
(	O
", %d fuzzy translation"	pointer
,	O
", %d fuzzy translations"	pointer
,	O
msgs_fuzzy	int
)	O
,	O
msgs_fuzzy	int
)	O
;	O
if	O
(	O
msgs_untranslated	int
>	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
ngettext	function
(	O
", %d untranslated message"	pointer
,	O
", %d untranslated messages"	pointer
,	O
msgs_untranslated	int
)	O
,	O
msgs_untranslated	int
)	O
;	O
fputs	function
(	O
".\n"	pointer
,	O
stderr	pointer
)	O
;	O
}	O
exit	function
(	O
exit_status	int
)	O
;	O
}	O
static	O
void	O
usage	function
(	O
int	O
status	int
)	O
{	O
if	O
(	O
status	int
!=	O
EXIT_SUCCESS	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Try '%s --help' for more information.\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
else	O
{	O
printf	function
(	O
_	O
(	O
"Usage: %s [OPTION] filename.po ...\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Generate binary message catalog from textual translation description.\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Mandatory arguments to long options are mandatory for short options too.\nSimilarly for optional arguments.\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Input file location:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  filename.po ...             input files\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -D, --directory=DIRECTORY   add DIRECTORY to list for input files search\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"If input file is -, standard input is read.\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Operation mode:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -j, --java                  Java mode: generate a Java ResourceBundle class\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --java2                 like --java, and assume Java2 (JDK 1.2 or higher)\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --csharp                C# mode: generate a .NET .dll file\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --csharp-resources      C# resources mode: generate a .NET .resources file\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --tcl                   Tcl mode: generate a tcl/msgcat .msg file\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --qt                    Qt mode: generate a Qt .qm file\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --desktop               Desktop Entry mode: generate a .desktop file\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --xml                   XML mode: generate XML file\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Output file location:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -o, --output-file=FILE      write output to specified file\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --strict                enable strict Uniforum mode\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"If output file is -, output is written to standard output.\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Output file location in Java mode:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -r, --resource=RESOURCE     resource name\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -l, --locale=LOCALE         locale name, either language or language_COUNTRY\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --source                produce a .java file, instead of a .class file\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -d DIRECTORY                base directory of classes directory hierarchy\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"The class name is determined by appending the locale name to the resource name,\nseparated with an underscore.  The -d option is mandatory.  The class is\nwritten under the specified directory.\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Output file location in C# mode:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -r, --resource=RESOURCE     resource name\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -l, --locale=LOCALE         locale name, either language or language_COUNTRY\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -d DIRECTORY                base directory for locale dependent .dll files\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"The -l and -d options are mandatory.  The .dll file is written in a\nsubdirectory of the specified directory whose name depends on the locale.\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Output file location in Tcl mode:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -l, --locale=LOCALE         locale name, either language or language_COUNTRY\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -d DIRECTORY                base directory of .msg message catalogs\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"The -l and -d options are mandatory.  The .msg file is written in the\nspecified directory.\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Desktop Entry mode options:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -l, --locale=LOCALE         locale name, either language or language_COUNTRY\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -o, --output-file=FILE      write output to specified file\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  --template=TEMPLATE         a .desktop file used as a template\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -d DIRECTORY                base directory of .po files\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -kWORD, --keyword=WORD      look for WORD as an additional keyword\n  -k, --keyword               do not to use default keywords\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"The -l, -o, and --template options are mandatory.  If -D is specified, input\nfiles are read from the directory instead of the command line arguments.\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"XML mode options:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -l, --locale=LOCALE         locale name, either language or language_COUNTRY\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -L, --language=NAME         recognise the specified XML language\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -o, --output-file=FILE      write output to specified file\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  --template=TEMPLATE         an XML file used as a template\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -d DIRECTORY                base directory of .po files\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"The -l, -o, and --template options are mandatory.  If -D is specified, input\nfiles are read from the directory instead of the command line arguments.\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Input file syntax:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -P, --properties-input      input files are in Java .properties syntax\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --stringtable-input     input files are in NeXTstep/GNUstep .strings\n                              syntax\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Input file interpretation:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -c, --check                 perform all the checks implied by\n                                --check-format, --check-header, --check-domain\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --check-format          check language dependent format strings\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --check-header          verify presence and contents of the header entry\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --check-domain          check for conflicts between domain directives\n                                and the --output-file option\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -C, --check-compatibility   check that GNU msgfmt behaves like X/Open msgfmt\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --check-accelerators[=CHAR]  check presence of keyboard accelerators for\n                                menu items\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -f, --use-fuzzy             use fuzzy entries in output\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Output details:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -a, --alignment=NUMBER      align strings to NUMBER bytes (default: %d)\n"	pointer
)	O
,	O
DEFAULT_OUTPUT_ALIGNMENT	int
)	O
;	O
printf	function
(	O
_	O
(	O
"      --endianness=BYTEORDER  write out 32-bit numbers in the given byte order\n                                (big or little, default depends on platform)\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --no-hash               binary file will not include the hash table\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Informative output:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -h, --help                  display this help and exit\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -V, --version               output version information and exit\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --statistics            print statistics about translations\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -v, --verbose               increase verbosity level\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
fputs	function
(	O
_	O
(	O
"Report bugs to <bug-gnu-gettext@gnu.org>.\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
}	O
exit	function
(	O
status	int
)	O
;	O
}	O
static	O
const	O
char	O
*	O
add_mo_suffix	function
(	O
const	O
char	O
*	O
fname	pointer
)	O
{	O
size_t	long
len	long
;	O
char	O
*	O
result	pointer
;	O
len	long
=	O
strlen	function
(	O
fname	pointer
)	O
;	O
if	O
(	O
len	long
>	O
3	int
&&	O
memcmp	function
(	O
fname	pointer
+	O
len	long
-	O
3	int
,	O
".mo"	pointer
,	O
3	int
)	O
==	O
0	int
)	O
return	O
fname	pointer
;	O
if	O
(	O
len	long
>	O
4	int
&&	O
memcmp	function
(	O
fname	pointer
+	O
len	long
-	O
4	int
,	O
".gmo"	pointer
,	O
4	int
)	O
==	O
0	int
)	O
return	O
fname	pointer
;	O
result	pointer
=	O
XNMALLOC	O
(	O
len	long
+	O
4	int
,	O
char	O
)	O
;	O
stpcpy	function
(	O
stpcpy	function
(	O
result	pointer
,	O
fname	pointer
)	O
,	O
".mo"	pointer
)	O
;	O
return	O
result	pointer
;	O
}	O
static	O
struct	O
msg_domain	struct
*	O
new_domain	function
(	O
const	O
char	O
*	O
name	pointer
,	O
const	O
char	O
*	O
file_name	pointer
)	O
{	O
struct	O
msg_domain	struct
*	O
*	O
p_dom	pointer
=	O
&	O
domain_list	pointer
;	O
while	O
(	O
*	O
p_dom	pointer
!=	O
NULL	O
&&	O
strcmp	function
(	O
name	pointer
,	O
(	O
*	O
p_dom	pointer
)	O
->	O
domain_name	pointer
)	O
!=	O
0	int
)	O
p_dom	pointer
=	O
&	O
(	O
*	O
p_dom	pointer
)	O
->	O
next	pointer
;	O
if	O
(	O
*	O
p_dom	pointer
==	O
NULL	O
)	O
{	O
struct	O
msg_domain	struct
*	O
domain	pointer
;	O
domain	pointer
=	O
XMALLOC	O
(	O
struct	O
msg_domain	struct
)	O
;	O
domain	pointer
->	O
mlp	pointer
=	O
message_list_alloc	function
(	O
true	int
)	O
;	O
domain	pointer
->	O
domain_name	pointer
=	O
name	pointer
;	O
domain	pointer
->	O
file_name	pointer
=	O
file_name	pointer
;	O
domain	pointer
->	O
next	pointer
=	O
NULL	O
;	O
*	O
p_dom	pointer
=	O
domain	pointer
;	O
}	O
return	O
*	O
p_dom	pointer
;	O
}	O
static	O
bool	bool
is_nonobsolete	function
(	O
const	O
message_ty	struct
*	O
mp	pointer
)	O
{	O
return	O
!	O
mp	pointer
->	O
obsolete	bool
;	O
}	O
typedef	O
struct	O
msgfmt_catalog_reader_ty	struct
msgfmt_catalog_reader_ty	struct
;	O
struct	O
msgfmt_catalog_reader_ty	struct
{	O
DEFAULT_CATALOG_READER_TY	O
bool	bool
has_header_entry	bool
;	O
}	O
;	O
static	O
void	O
msgfmt_constructor	function
(	O
abstract_catalog_reader_ty	struct
*	O
that	pointer
)	O
{	O
msgfmt_catalog_reader_ty	struct
*	O
this	pointer
=	O
(	O
msgfmt_catalog_reader_ty	struct
*	O
)	O
that	pointer
;	O
default_constructor	function
(	O
that	pointer
)	O
;	O
this	pointer
->	O
has_header_entry	bool
=	O
false	int
;	O
}	O
static	O
void	O
msgfmt_parse_debrief	function
(	O
abstract_catalog_reader_ty	struct
*	O
that	pointer
)	O
{	O
msgfmt_catalog_reader_ty	struct
*	O
this	pointer
=	O
(	O
msgfmt_catalog_reader_ty	struct
*	O
)	O
that	pointer
;	O
default_parse_debrief	function
(	O
that	pointer
)	O
;	O
if	O
(	O
check_header	int
)	O
{	O
if	O
(	O
!	O
this	pointer
->	O
has_header_entry	bool
)	O
{	O
multiline_error	function
(	O
xasprintf	function
(	O
"%s: "	pointer
,	O
this	pointer
->	O
file_name	pointer
)	O
,	O
xasprintf	function
(	O
_	O
(	O
"warning: PO file header missing or invalid\n"	pointer
)	O
)	O
)	O
;	O
multiline_error	function
(	O
NULL	O
,	O
xasprintf	function
(	O
_	O
(	O
"warning: charset conversion will not work\n"	pointer
)	O
)	O
)	O
;	O
}	O
}	O
}	O
static	O
void	O
msgfmt_set_domain	function
(	O
default_catalog_reader_ty	struct
*	O
this	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
if	O
(	O
!	O
java_mode	bool
&&	O
!	O
csharp_mode	bool
&&	O
!	O
csharp_resources_mode	bool
&&	O
!	O
tcl_mode	bool
&&	O
!	O
qt_mode	bool
&&	O
!	O
desktop_mode	bool
&&	O
!	O
xml_mode	bool
&&	O
output_file_name	pointer
==	O
NULL	O
)	O
{	O
size_t	long
correct	long
;	O
correct	long
=	O
strcspn	function
(	O
name	pointer
,	O
INVALID_PATH_CHAR	pointer
)	O
;	O
if	O
(	O
name	pointer
[	O
correct	long
]	O
!=	O
'\0'	O
)	O
{	O
exit_status	int
=	O
EXIT_FAILURE	int
;	O
if	O
(	O
correct	long
==	O
0	int
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"domain name \"%s\" not suitable as file name"	pointer
)	O
,	O
name	pointer
)	O
;	O
return	O
;	O
}	O
else	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"domain name \"%s\" not suitable as file name: will use prefix"	pointer
)	O
,	O
name	pointer
)	O
;	O
name	pointer
[	O
correct	long
]	O
=	O
'\0'	O
;	O
}	O
current_domain	pointer
=	O
new_domain	function
(	O
name	pointer
,	O
add_mo_suffix	function
(	O
name	pointer
)	O
)	O
;	O
this	pointer
->	O
domain	pointer
=	O
current_domain	pointer
->	O
domain_name	pointer
;	O
this	pointer
->	O
mlp	pointer
=	O
current_domain	pointer
->	O
mlp	pointer
;	O
}	O
else	O
{	O
if	O
(	O
check_domain	bool
)	O
po_gram_error_at_line	function
(	O
&	O
gram_pos	struct
,	O
_	O
(	O
"'domain %s' directive ignored"	pointer
)	O
,	O
name	pointer
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
}	O
}	O
static	O
void	O
msgfmt_add_message	function
(	O
default_catalog_reader_ty	struct
*	O
this	pointer
,	O
char	O
*	O
msgctxt	pointer
,	O
char	O
*	O
msgid	pointer
,	O
lex_pos_ty	struct
*	O
msgid_pos	pointer
,	O
char	O
*	O
msgid_plural	pointer
,	O
char	O
*	O
msgstr	pointer
,	O
size_t	long
msgstr_len	long
,	O
lex_pos_ty	struct
*	O
msgstr_pos	pointer
,	O
char	O
*	O
prev_msgctxt	pointer
,	O
char	O
*	O
prev_msgid	pointer
,	O
char	O
*	O
prev_msgid_plural	pointer
,	O
bool	bool
force_fuzzy	bool
,	O
bool	bool
obsolete	bool
)	O
{	O
if	O
(	O
current_domain	pointer
==	O
NULL	O
)	O
{	O
current_domain	pointer
=	O
new_domain	function
(	O
MESSAGE_DOMAIN_DEFAULT	pointer
,	O
add_mo_suffix	function
(	O
MESSAGE_DOMAIN_DEFAULT	pointer
)	O
)	O
;	O
this	pointer
->	O
domain	pointer
=	O
current_domain	pointer
->	O
domain_name	pointer
;	O
this	pointer
->	O
mlp	pointer
=	O
current_domain	pointer
->	O
mlp	pointer
;	O
}	O
default_add_message	function
(	O
this	pointer
,	O
msgctxt	pointer
,	O
msgid	pointer
,	O
msgid_pos	pointer
,	O
msgid_plural	pointer
,	O
msgstr	pointer
,	O
msgstr_len	long
,	O
msgstr_pos	pointer
,	O
prev_msgctxt	pointer
,	O
prev_msgid	pointer
,	O
prev_msgid_plural	pointer
,	O
force_fuzzy	bool
,	O
obsolete	bool
)	O
;	O
}	O
static	O
void	O
msgfmt_frob_new_message	function
(	O
default_catalog_reader_ty	struct
*	O
that	pointer
,	O
message_ty	struct
*	O
mp	pointer
,	O
const	O
lex_pos_ty	struct
*	O
msgid_pos	pointer
,	O
const	O
lex_pos_ty	struct
*	O
msgstr_pos	pointer
)	O
{	O
msgfmt_catalog_reader_ty	struct
*	O
this	pointer
=	O
(	O
msgfmt_catalog_reader_ty	struct
*	O
)	O
that	pointer
;	O
if	O
(	O
!	O
mp	pointer
->	O
obsolete	bool
)	O
{	O
if	O
(	O
(	O
!	O
include_untranslated	bool
&&	O
mp	pointer
->	O
msgstr	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
||	O
(	O
!	O
include_fuzzies	bool
&&	O
mp	pointer
->	O
is_fuzzy	bool
&&	O
!	O
is_header	O
(	O
mp	pointer
)	O
)	O
)	O
{	O
if	O
(	O
check_compatibility	int
)	O
{	O
error_with_progname	bool
=	O
false	int
;	O
error_at_line	function
(	O
0	int
,	O
0	int
,	O
mp	pointer
->	O
pos	struct
.	O
file_name	pointer
,	O
mp	pointer
->	O
pos	struct
.	O
line_number	long
,	O
(	O
mp	pointer
->	O
msgstr	pointer
[	O
0	int
]	O
==	O
'\0'	O
?	O
_	O
(	O
"empty 'msgstr' entry ignored"	pointer
)	O
:	O
_	O
(	O
"fuzzy 'msgstr' entry ignored"	pointer
)	O
)	O
)	O
;	O
error_with_progname	bool
=	O
true	int
;	O
}	O
if	O
(	O
mp	pointer
->	O
msgstr	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
++	O
msgs_untranslated	int
;	O
else	O
++	O
msgs_fuzzy	int
;	O
mp	pointer
->	O
obsolete	bool
=	O
true	int
;	O
}	O
else	O
{	O
if	O
(	O
is_header	O
(	O
mp	pointer
)	O
)	O
{	O
this	pointer
->	O
has_header_entry	bool
=	O
true	int
;	O
}	O
else	O
if	O
(	O
mp	pointer
->	O
is_fuzzy	bool
)	O
++	O
msgs_fuzzy	int
;	O
else	O
++	O
msgs_translated	int
;	O
}	O
}	O
}	O
static	O
void	O
msgfmt_comment_special	function
(	O
abstract_catalog_reader_ty	struct
*	O
that	pointer
,	O
const	O
char	O
*	O
s	pointer
)	O
{	O
msgfmt_catalog_reader_ty	struct
*	O
this	pointer
=	O
(	O
msgfmt_catalog_reader_ty	struct
*	O
)	O
that	pointer
;	O
default_comment_special	function
(	O
that	pointer
,	O
s	pointer
)	O
;	O
if	O
(	O
this	pointer
->	O
is_fuzzy	bool
)	O
{	O
static	O
bool	bool
warned	bool
=	O
false	int
;	O
if	O
(	O
!	O
include_fuzzies	bool
&&	O
check_compatibility	int
&&	O
!	O
warned	bool
)	O
{	O
warned	bool
=	O
true	int
;	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s: warning: source file contains fuzzy translation"	pointer
)	O
,	O
gram_pos	struct
.	O
file_name	pointer
)	O
;	O
}	O
}	O
}	O
static	O
default_catalog_reader_class_ty	struct
msgfmt_methods	struct
=	O
{	O
{	O
sizeof	O
(	O
msgfmt_catalog_reader_ty	struct
)	O
,	O
msgfmt_constructor	function
,	O
default_destructor	function
,	O
default_parse_brief	function
,	O
msgfmt_parse_debrief	function
,	O
default_directive_domain	function
,	O
default_directive_message	function
,	O
default_comment	function
,	O
default_comment_dot	function
,	O
default_comment_filepos	function
,	O
msgfmt_comment_special	function
}	O
,	O
msgfmt_set_domain	function
,	O
msgfmt_add_message	function
,	O
msgfmt_frob_new_message	function
}	O
;	O
static	O
void	O
read_catalog_file_msgfmt	function
(	O
char	O
*	O
filename	pointer
,	O
catalog_input_format_ty	pointer
input_syntax	pointer
)	O
{	O
char	O
*	O
real_filename	pointer
;	O
FILE	struct
*	O
fp	pointer
=	O
open_catalog_file	function
(	O
filename	pointer
,	O
&	O
real_filename	pointer
,	O
true	int
)	O
;	O
default_catalog_reader_ty	struct
*	O
pop	pointer
;	O
pop	pointer
=	O
default_catalog_reader_alloc	function
(	O
&	O
msgfmt_methods	struct
)	O
;	O
pop	pointer
->	O
handle_comments	bool
=	O
false	int
;	O
pop	pointer
->	O
allow_domain_directives	bool
=	O
true	int
;	O
pop	pointer
->	O
allow_duplicates	bool
=	O
false	int
;	O
pop	pointer
->	O
allow_duplicates_if_same_msgstr	bool
=	O
false	int
;	O
pop	pointer
->	O
file_name	pointer
=	O
real_filename	pointer
;	O
pop	pointer
->	O
mdlp	pointer
=	O
NULL	O
;	O
pop	pointer
->	O
mlp	pointer
=	O
NULL	O
;	O
if	O
(	O
current_domain	pointer
!=	O
NULL	O
)	O
{	O
pop	pointer
->	O
domain	pointer
=	O
current_domain	pointer
->	O
domain_name	pointer
;	O
pop	pointer
->	O
mlp	pointer
=	O
current_domain	pointer
->	O
mlp	pointer
;	O
}	O
po_lex_pass_obsolete_entries	function
(	O
true	int
)	O
;	O
catalog_reader_parse	function
(	O
(	O
abstract_catalog_reader_ty	struct
*	O
)	O
pop	pointer
,	O
fp	pointer
,	O
real_filename	pointer
,	O
filename	pointer
,	O
input_syntax	pointer
)	O
;	O
catalog_reader_free	function
(	O
(	O
abstract_catalog_reader_ty	struct
*	O
)	O
pop	pointer
)	O
;	O
if	O
(	O
fp	pointer
!=	O
stdin	pointer
)	O
fclose	function
(	O
fp	pointer
)	O
;	O
}	O
static	O
void	O
add_languages	function
(	O
string_list_ty	struct
*	O
languages	pointer
,	O
string_list_ty	struct
*	O
desired_languages	pointer
,	O
const	O
char	O
*	O
line	long
,	O
size_t	long
length	long
)	O
{	O
char	O
*	O
start	pointer
;	O
for	O
(	O
start	pointer
=	O
(	O
char	O
*	O
)	O
line	long
;	O
start	pointer
-	O
line	long
<	O
length	long
;	O
)	O
{	O
char	O
*	O
p	pointer
;	O
while	O
(	O
*	O
start	pointer
==	O
' '	O
||	O
*	O
start	pointer
==	O
'\t'	O
)	O
start	pointer
++	O
;	O
p	pointer
=	O
start	pointer
;	O
while	O
(	O
*	O
p	pointer
!=	O
'\0'	O
&&	O
*	O
p	pointer
!=	O
' '	O
&&	O
*	O
p	pointer
!=	O
'\t'	O
)	O
p	pointer
++	O
;	O
*	O
p	pointer
=	O
'\0'	O
;	O
if	O
(	O
desired_languages	pointer
==	O
NULL	O
||	O
string_list_member	function
(	O
desired_languages	pointer
,	O
start	pointer
)	O
)	O
string_list_append_unique	function
(	O
languages	pointer
,	O
start	pointer
)	O
;	O
start	pointer
=	O
p	pointer
+	O
1	int
;	O
}	O
}	O
static	O
void	O
get_languages	function
(	O
string_list_ty	struct
*	O
languages	pointer
,	O
const	O
char	O
*	O
directory	pointer
)	O
{	O
char	O
*	O
envval	pointer
;	O
string_list_ty	struct
real_desired_languages	struct
,	O
*	O
desired_languages	pointer
=	O
NULL	O
;	O
char	O
*	O
linguas_file_name	pointer
=	O
NULL	O
;	O
struct	O
stat	struct
statbuf	struct
;	O
FILE	struct
*	O
fp	pointer
;	O
size_t	long
line_len	long
=	O
0	int
;	O
char	O
*	O
line_buf	pointer
=	O
NULL	O
;	O
envval	pointer
=	O
getenv	function
(	O
"LINGUAS"	pointer
)	O
;	O
if	O
(	O
envval	pointer
)	O
{	O
string_list_init	function
(	O
&	O
real_desired_languages	struct
)	O
;	O
add_languages	function
(	O
&	O
real_desired_languages	struct
,	O
NULL	O
,	O
envval	pointer
,	O
strlen	function
(	O
envval	pointer
)	O
)	O
;	O
desired_languages	pointer
=	O
&	O
real_desired_languages	struct
;	O
}	O
linguas_file_name	pointer
=	O
xconcatenated_filename	function
(	O
directory	pointer
,	O
"LINGUAS"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
stat	struct
(	O
linguas_file_name	pointer
,	O
&	O
statbuf	struct
)	O
<	O
0	int
)	O
{	O
error	function
(	O
EXIT_SUCCESS	int
,	O
0	int
,	O
_	O
(	O
"%s does not exist"	pointer
)	O
,	O
linguas_file_name	pointer
)	O
;	O
goto	O
out	O
;	O
}	O
fp	pointer
=	O
fopen	function
(	O
linguas_file_name	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
fp	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
EXIT_SUCCESS	int
,	O
0	int
,	O
_	O
(	O
"%s exists but cannot read"	pointer
)	O
,	O
linguas_file_name	pointer
)	O
;	O
goto	O
out	O
;	O
}	O
while	O
(	O
!	O
feof	function
(	O
fp	pointer
)	O
)	O
{	O
int	O
len	long
=	O
getline	function
(	O
&	O
line_buf	pointer
,	O
&	O
line_len	long
,	O
fp	pointer
)	O
;	O
if	O
(	O
len	long
<	O
0	int
)	O
break	O
;	O
if	O
(	O
len	long
>	O
0	int
&&	O
line_buf	pointer
[	O
len	long
-	O
1	int
]	O
==	O
'\n'	O
)	O
line_buf	pointer
[	O
--	O
len	long
]	O
=	O
'\0'	O
;	O
while	O
(	O
len	long
>	O
0	int
&&	O
(	O
line_buf	pointer
[	O
len	long
-	O
1	int
]	O
==	O
' '	O
||	O
line_buf	pointer
[	O
len	long
-	O
1	int
]	O
==	O
'\t'	O
||	O
line_buf	pointer
[	O
len	long
-	O
1	int
]	O
==	O
'\r'	O
)	O
)	O
line_buf	pointer
[	O
--	O
len	long
]	O
=	O
'\0'	O
;	O
if	O
(	O
*	O
line_buf	pointer
==	O
'\0'	O
||	O
*	O
line_buf	pointer
==	O
'#'	O
)	O
continue	O
;	O
add_languages	function
(	O
languages	pointer
,	O
desired_languages	pointer
,	O
line_buf	pointer
,	O
len	long
)	O
;	O
}	O
free	function
(	O
line_buf	pointer
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
out	O
:	O
if	O
(	O
desired_languages	pointer
!=	O
NULL	O
)	O
string_list_destroy	function
(	O
desired_languages	pointer
)	O
;	O
free	function
(	O
linguas_file_name	pointer
)	O
;	O
}	O
static	O
void	O
msgfmt_operand_list_init	function
(	O
msgfmt_operand_list_ty	struct
*	O
operands	pointer
)	O
{	O
operands	pointer
->	O
items	pointer
=	O
NULL	O
;	O
operands	pointer
->	O
nitems	long
=	O
0	int
;	O
operands	pointer
->	O
nitems_max	long
=	O
0	int
;	O
}	O
static	O
void	O
msgfmt_operand_list_destroy	function
(	O
msgfmt_operand_list_ty	struct
*	O
operands	pointer
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
operands	pointer
->	O
nitems	long
;	O
i	long
++	O
)	O
{	O
free	function
(	O
operands	pointer
->	O
items	pointer
[	O
i	long
]	O
.	O
language	pointer
)	O
;	O
message_list_free	function
(	O
operands	pointer
->	O
items	pointer
[	O
i	long
]	O
.	O
mlp	pointer
,	O
0	int
)	O
;	O
}	O
free	function
(	O
operands	pointer
->	O
items	pointer
)	O
;	O
}	O
static	O
void	O
msgfmt_operand_list_append	function
(	O
msgfmt_operand_list_ty	struct
*	O
operands	pointer
,	O
const	O
char	O
*	O
language	pointer
,	O
message_list_ty	struct
*	O
messages	pointer
)	O
{	O
msgfmt_operand_ty	struct
*	O
operand	pointer
;	O
if	O
(	O
operands	pointer
->	O
nitems	long
==	O
operands	pointer
->	O
nitems_max	long
)	O
{	O
operands	pointer
->	O
nitems_max	long
=	O
operands	pointer
->	O
nitems_max	long
*	O
2	int
+	O
1	int
;	O
operands	pointer
->	O
items	pointer
=	O
xrealloc	function
(	O
operands	pointer
->	O
items	pointer
,	O
sizeof	O
(	O
msgfmt_operand_ty	struct
)	O
*	O
operands	pointer
->	O
nitems_max	long
)	O
;	O
}	O
operand	pointer
=	O
&	O
operands	pointer
->	O
items	pointer
[	O
operands	pointer
->	O
nitems	long
++	O
]	O
;	O
operand	pointer
->	O
language	pointer
=	O
xstrdup	function
(	O
language	pointer
)	O
;	O
operand	pointer
->	O
mlp	pointer
=	O
messages	pointer
;	O
}	O
static	O
int	O
msgfmt_operand_list_add_from_directory	function
(	O
msgfmt_operand_list_ty	struct
*	O
operands	pointer
,	O
const	O
char	O
*	O
directory	pointer
)	O
{	O
string_list_ty	struct
languages	pointer
;	O
void	O
*	O
saved_dir_list	pointer
;	O
int	O
retval	int
=	O
0	int
;	O
size_t	long
i	long
;	O
string_list_init	function
(	O
&	O
languages	pointer
)	O
;	O
get_languages	function
(	O
&	O
languages	pointer
,	O
directory	pointer
)	O
;	O
if	O
(	O
languages	pointer
.	O
nitems	long
==	O
0	int
)	O
return	O
0	int
;	O
saved_dir_list	pointer
=	O
dir_list_save_reset	function
(	O
)	O
;	O
dir_list_append	function
(	O
directory	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
languages	pointer
.	O
nitems	long
;	O
i	long
++	O
)	O
{	O
const	O
char	O
*	O
language	pointer
=	O
languages	pointer
.	O
item	pointer
[	O
i	long
]	O
;	O
message_list_ty	struct
*	O
mlp	pointer
;	O
char	O
*	O
input_file_name	pointer
;	O
int	O
nerrors	int
;	O
current_domain	pointer
=	O
new_domain	function
(	O
MESSAGE_DOMAIN_DEFAULT	pointer
,	O
add_mo_suffix	function
(	O
MESSAGE_DOMAIN_DEFAULT	pointer
)	O
)	O
;	O
input_file_name	pointer
=	O
xconcatenated_filename	function
(	O
""	pointer
,	O
language	pointer
,	O
".po"	pointer
)	O
;	O
read_catalog_file_msgfmt	function
(	O
input_file_name	pointer
,	O
&	O
input_format_po	struct
)	O
;	O
free	function
(	O
input_file_name	pointer
)	O
;	O
assert	O
(	O
current_domain	pointer
==	O
domain_list	pointer
&&	O
domain_list	pointer
->	O
next	pointer
==	O
NULL	O
)	O
;	O
mlp	pointer
=	O
current_domain	pointer
->	O
mlp	pointer
;	O
free	function
(	O
current_domain	pointer
)	O
;	O
current_domain	pointer
=	O
domain_list	pointer
=	O
NULL	O
;	O
message_list_remove_if_not	function
(	O
mlp	pointer
,	O
is_nonobsolete	function
)	O
;	O
nerrors	int
=	O
check_message_list	function
(	O
mlp	pointer
,	O
0	int
,	O
0	int
,	O
1	int
,	O
check_format_strings	int
,	O
check_header	int
,	O
check_compatibility	int
,	O
check_accelerators	int
,	O
accelerator_char	char
)	O
;	O
retval	int
+=	O
nerrors	int
;	O
if	O
(	O
nerrors	int
>	O
0	int
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
ngettext	function
(	O
"found %d fatal error"	pointer
,	O
"found %d fatal errors"	pointer
,	O
nerrors	int
)	O
,	O
nerrors	int
)	O
;	O
continue	O
;	O
}	O
iconv_message_list	function
(	O
mlp	pointer
,	O
NULL	O
,	O
po_charset_utf8	pointer
,	O
NULL	O
)	O
;	O
msgfmt_operand_list_append	function
(	O
operands	pointer
,	O
language	pointer
,	O
mlp	pointer
)	O
;	O
}	O
string_list_destroy	function
(	O
&	O
languages	pointer
)	O
;	O
dir_list_restore	function
(	O
saved_dir_list	pointer
)	O
;	O
return	O
retval	int
;	O
}	O
static	O
int	O
msgfmt_desktop_bulk	function
(	O
const	O
char	O
*	O
directory	pointer
,	O
const	O
char	O
*	O
template_file_name	pointer
,	O
hash_table	struct
*	O
keywords	pointer
,	O
const	O
char	O
*	O
file_name	pointer
)	O
{	O
msgfmt_operand_list_ty	struct
operands	pointer
;	O
int	O
nerrors	int
,	O
status	int
;	O
msgfmt_operand_list_init	function
(	O
&	O
operands	pointer
)	O
;	O
nerrors	int
=	O
msgfmt_operand_list_add_from_directory	function
(	O
&	O
operands	pointer
,	O
directory	pointer
)	O
;	O
if	O
(	O
nerrors	int
>	O
0	int
)	O
{	O
msgfmt_operand_list_destroy	function
(	O
&	O
operands	pointer
)	O
;	O
return	O
1	int
;	O
}	O
status	int
=	O
msgdomain_write_desktop_bulk	function
(	O
&	O
operands	pointer
,	O
template_file_name	pointer
,	O
keywords	pointer
,	O
file_name	pointer
)	O
;	O
msgfmt_operand_list_destroy	function
(	O
&	O
operands	pointer
)	O
;	O
return	O
status	int
;	O
}	O
static	O
int	O
msgfmt_xml_bulk	function
(	O
const	O
char	O
*	O
directory	pointer
,	O
const	O
char	O
*	O
template_file_name	pointer
,	O
its_rule_list_ty	struct
*	O
its_rules	pointer
,	O
const	O
char	O
*	O
file_name	pointer
)	O
{	O
msgfmt_operand_list_ty	struct
operands	pointer
;	O
int	O
nerrors	int
,	O
status	int
;	O
msgfmt_operand_list_init	function
(	O
&	O
operands	pointer
)	O
;	O
nerrors	int
=	O
msgfmt_operand_list_add_from_directory	function
(	O
&	O
operands	pointer
,	O
directory	pointer
)	O
;	O
if	O
(	O
nerrors	int
>	O
0	int
)	O
{	O
msgfmt_operand_list_destroy	function
(	O
&	O
operands	pointer
)	O
;	O
return	O
1	int
;	O
}	O
status	int
=	O
msgdomain_write_xml_bulk	function
(	O
&	O
operands	pointer
,	O
template_file_name	pointer
,	O
its_rules	pointer
,	O
file_name	pointer
)	O
;	O
msgfmt_operand_list_destroy	function
(	O
&	O
operands	pointer
)	O
;	O
return	O
status	int
;	O
}	O
