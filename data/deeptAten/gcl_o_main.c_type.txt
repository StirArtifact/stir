static	O
void	O
init_main	function
(	O
void	O
)	O
;	O
static	O
void	O
initlisp	function
(	O
void	O
)	O
;	O
static	O
int	O
multiply_stacks	function
(	O
int	O
)	O
;	O
bool	O
saving_system	int
=	O
FALSE	O
;	O
char	O
*	O
system_directory	pointer
;	O
char	O
stdin_buf	char
[	O
BUFSIZ	O
+	O
EXTRA_BUFSIZE	int
]	O
;	O
char	O
stdout_buf	char
[	O
BUFSIZ	O
+	O
EXTRA_BUFSIZE	int
]	O
;	O
int	O
debug	int
;	O
int	O
raw_image	int
=	O
TRUE	O
;	O
bool	O
GBC_enable	int
=	O
FALSE	O
;	O
long	O
real_maxpage	long
;	O
object	O
sSAlisp_maxpagesA	int
;	O
object	O
siClisp_pagesize	int
;	O
object	O
sStop_level	int
;	O
object	O
sSAmultiply_stacksA	int
;	O
int	O
stack_multiple	int
=	O
1	int
;	O
static	O
object	O
stack_space	int
;	O
void	O
install_segmentation_catcher	function
(	O
void	O
)	O
;	O
int	O
cstack_dir	function
(	O
fixnum	O
j	int
)	O
{	O
static	O
fixnum	O
n	int
;	O
if	O
(	O
!	O
n	int
)	O
{	O
n	int
=	O
1	int
;	O
return	O
cstack_dir	function
(	O
(	O
fixnum	O
)	O
&	O
j	int
)	O
;	O
}	O
return	O
(	O
fixnum	O
)	O
&	O
j	int
<	O
j	int
?	O
-	O
1	int
:	O
1	int
;	O
}	O
fixnum	O
log_maxpage_bound	int
=	O
sizeof	O
(	O
fixnum	O
)	O
*	O
8	int
-	O
1	int
;	O
inline	O
int	O
mbrk	function
(	O
void	O
*	O
v	pointer
)	O
{	O
ufixnum	O
uv	O
=	O
(	O
ufixnum	O
)	O
v	pointer
,	O
uc	O
=	O
(	O
ufixnum	O
)	O
sbrk	function
(	O
0	int
)	O
,	O
ux	O
,	O
um	O
;	O
fixnum	O
m	int
=	O
(	O
(	O
1UL	int
<<	O
(	O
sizeof	O
(	O
fixnum	O
)	O
*	O
8	int
-	O
1	int
)	O
)	O
-	O
1	int
)	O
;	O
if	O
(	O
uv	O
<	O
uc	O
)	O
{	O
um	O
=	O
uv	O
;	O
ux	O
=	O
uc	O
;	O
}	O
else	O
{	O
um	O
=	O
uc	O
;	O
ux	O
=	O
uv	O
;	O
}	O
if	O
(	O
(	O
(	O
fixnum	O
)	O
(	O
ux	O
-	O
um	O
)	O
)	O
<	O
0	int
)	O
return	O
mbrk	function
(	O
(	O
void	O
*	O
)	O
uc	O
+	O
(	O
uv	O
<	O
uc	O
?	O
-	O
m	int
:	O
m	int
)	O
)	O
||	O
mbrk	function
(	O
v	pointer
)	O
;	O
return	O
uc	O
==	O
(	O
ufixnum	O
)	O
sbrk	function
(	O
uv	O
-	O
uc	O
)	O
?	O
0	int
:	O
-	O
1	int
;	O
}	O
ufixnum	O
get_phys_pages_no_malloc	function
(	O
void	O
)	O
{	O
int	O
l	int
;	O
char	O
b	char
[	O
PAGESIZE	O
]	O
,	O
*	O
c	O
;	O
const	O
char	O
*	O
k	pointer
=	O
"MemTotal:"	pointer
,	O
*	O
f	pointer
=	O
"/proc/meminfo"	pointer
;	O
ufixnum	O
res	O
=	O
0	int
,	O
n	int
;	O
if	O
(	O
(	O
l	int
=	O
open	function
(	O
f	pointer
,	O
O_RDONLY	int
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
(	O
n	int
=	O
read	function
(	O
l	int
,	O
b	char
,	O
sizeof	O
(	O
b	char
)	O
)	O
)	O
<	O
sizeof	O
(	O
b	char
)	O
&&	O
!	O
(	O
b	char
[	O
n	int
]	O
=	O
0	int
)	O
&&	O
(	O
c	O
=	O
strstr	function
(	O
b	char
,	O
k	pointer
)	O
)	O
&&	O
sscanf	O
(	O
c	O
+	O
strlen	function
(	O
k	pointer
)	O
,	O
"%lu"	pointer
,	O
&	O
n	int
)	O
==	O
1	int
)	O
res	O
=	O
n	int
;	O
close	function
(	O
l	int
)	O
;	O
}	O
return	O
res	O
>>	O
(	O
PAGEWIDTH	O
-	O
10	int
)	O
;	O
}	O
int	O
update_real_maxpage	function
(	O
void	O
)	O
{	O
ufixnum	O
i	int
,	O
j	int
,	O
k	pointer
;	O
void	O
*	O
end	pointer
,	O
*	O
cur	pointer
,	O
*	O
beg	pointer
;	O
massert	function
(	O
cur	pointer
=	O
sbrk	function
(	O
0	int
)	O
)	O
;	O
beg	pointer
=	O
data_start	O
?	O
data_start	O
:	O
cur	pointer
;	O
for	O
(	O
i	int
=	O
0	int
,	O
j	int
=	O
(	O
1L	int
<<	O
log_maxpage_bound	int
)	O
;	O
j	int
>	O
PAGESIZE	O
;	O
j	int
>>=	O
1	int
)	O
if	O
(	O
(	O
end	pointer
=	O
beg	pointer
+	O
i	int
+	O
j	int
-	O
PAGESIZE	O
)	O
>	O
cur	pointer
)	O
if	O
(	O
!	O
mbrk	function
(	O
end	pointer
)	O
)	O
{	O
real_maxpage	long
=	O
page	function
(	O
end	pointer
)	O
;	O
i	int
+=	O
j	int
;	O
}	O
massert	function
(	O
!	O
mbrk	function
(	O
cur	pointer
)	O
)	O
;	O
phys_pages	O
=	O
get_phys_pages_no_malloc	function
(	O
)	O
;	O
available_pages	O
=	O
real_maxpage	long
-	O
page	function
(	O
beg	pointer
)	O
;	O
for	O
(	O
i	int
=	O
t_start	O
,	O
j	int
=	O
0	int
;	O
i	int
<	O
t_other	O
;	O
i	int
++	O
)	O
{	O
k	pointer
=	O
tm_table	O
[	O
i	int
]	O
.	O
tm_maxpage	O
;	O
if	O
(	O
tm_table	O
[	O
i	int
]	O
.	O
tm_type	O
==	O
t_relocatable	O
)	O
k	pointer
*=	O
2	int
;	O
else	O
j	int
+=	O
k	pointer
;	O
available_pages	O
-=	O
k	pointer
;	O
}	O
resv_pages	O
=	O
40	int
<	O
available_pages	O
?	O
40	int
:	O
available_pages	O
;	O
available_pages	O
-=	O
resv_pages	O
;	O
new_holepage	long
=	O
available_pages	O
/	O
starting_hole_div	O
;	O
k	pointer
=	O
available_pages	O
/	O
20	int
;	O
j	int
*=	O
starting_relb_heap_mult	O
;	O
j	int
=	O
j	int
<	O
k	pointer
?	O
j	int
:	O
k	pointer
;	O
if	O
(	O
maxrbpage	O
<	O
j	int
)	O
set_tm_maxpage	function
(	O
tm_table	O
+	O
t_relocatable	O
,	O
j	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
minimize_image	function
(	O
void	O
)	O
{	O
int	O
in_sgc	int
=	O
0	int
;	O
extern	O
long	O
new_holepage	long
;	O
fixnum	O
old_holepage	O
=	O
new_holepage	long
,	O
i	int
;	O
void	O
*	O
new	pointer
;	O
if	O
(	O
in_sgc	int
)	O
sgc_quit	function
(	O
)	O
;	O
holepage	O
=	O
new_holepage	long
=	O
1	int
;	O
GBC	function
(	O
t_relocatable	O
)	O
;	O
if	O
(	O
in_sgc	int
)	O
sgc_start	function
(	O
)	O
;	O
new	pointer
=	O
(	O
void	O
*	O
)	O
(	O
(	O
(	O
(	O
(	O
ufixnum	O
)	O
rb_pointer	O
)	O
+	O
PAGESIZE	O
-	O
1	int
)	O
/	O
PAGESIZE	O
)	O
*	O
PAGESIZE	O
)	O
;	O
core_end	O
=	O
new	pointer
;	O
rb_end	O
=	O
rb_limit	O
=	O
new	pointer
;	O
set_tm_maxpage	function
(	O
tm_table	O
+	O
t_relocatable	O
,	O
(	O
nrbpage	O
=	O
(	O
(	O
char	O
*	O
)	O
new	pointer
-	O
REAL_RB_START	O
)	O
/	O
PAGESIZE	O
)	O
)	O
;	O
new_holepage	long
=	O
old_holepage	O
;	O
cbgbccount	O
=	O
tm_table	O
[	O
t_contiguous	O
]	O
.	O
tm_adjgbccnt	O
=	O
tm_table	O
[	O
t_contiguous	O
]	O
.	O
tm_opt_maxpage	O
=	O
0	int
;	O
rbgbccount	O
=	O
tm_table	O
[	O
t_relocatable	O
]	O
.	O
tm_adjgbccnt	O
=	O
tm_table	O
[	O
t_relocatable	O
]	O
.	O
tm_opt_maxpage	O
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
(	O
int	O
)	O
t_end	O
;	O
i	int
++	O
)	O
tm_table	O
[	O
i	int
]	O
.	O
tm_gbccount	O
=	O
tm_table	O
[	O
i	int
]	O
.	O
tm_adjgbccnt	O
=	O
tm_table	O
[	O
i	int
]	O
.	O
tm_opt_maxpage	O
=	O
0	int
;	O
return	O
0	int
;	O
}	O
DEFUN_NEW	function
(	O
"SET-LOG-MAXPAGE-BOUND"	pointer
,	O
object	O
,	O
fSset_log_maxpage_bound	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
II	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
fixnum	O
l	int
)	O
,	O
""	pointer
)	O
{	O
void	O
*	O
end	pointer
,	O
*	O
dend	pointer
;	O
fixnum	O
def	O
=	O
sizeof	O
(	O
fixnum	O
)	O
*	O
8	int
-	O
1	int
;	O
l	int
=	O
l	int
<	O
def	O
?	O
l	int
:	O
def	O
;	O
end	pointer
=	O
data_start	O
+	O
(	O
1L	int
<<	O
l	int
)	O
-	O
PAGESIZE	O
;	O
GBC	function
(	O
t_relocatable	O
)	O
;	O
dend	pointer
=	O
heap_end	O
+	O
PAGESIZE	O
+	O
(	O
(	O
(	O
rb_pointer	O
-	O
REAL_RB_START	O
)	O
+	O
PAGESIZE	O
-	O
1	int
)	O
&	O
(	O
-	O
PAGESIZE	O
)	O
)	O
;	O
if	O
(	O
end	pointer
>=	O
dend	pointer
)	O
{	O
minimize_image	function
(	O
)	O
;	O
log_maxpage_bound	int
=	O
l	int
;	O
update_real_maxpage	function
(	O
)	O
;	O
}	O
return	O
(	O
object	O
)	O
log_maxpage_bound	int
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
char	O
*	O
*	O
envp	pointer
)	O
{	O
gcl_init_alloc	function
(	O
&	O
argv	pointer
)	O
;	O
kcl_self	O
=	O
argv	pointer
[	O
0	int
]	O
;	O
*	O
argv	pointer
=	O
kcl_self	O
;	O
setbuf	function
(	O
stdin	O
,	O
stdin_buf	char
)	O
;	O
setbuf	function
(	O
stdout	O
,	O
stdout_buf	char
)	O
;	O
ARGC	O
=	O
argc	int
;	O
ARGV	O
=	O
argv	pointer
;	O
ENVP	O
=	O
envp	pointer
;	O
vs_top	O
=	O
vs_base	O
=	O
vs_org	O
;	O
ihs_top	O
=	O
ihs_org	O
-	O
1	int
;	O
bds_top	O
=	O
bds_org	O
-	O
1	int
;	O
frs_top	O
=	O
frs_org	O
-	O
1	int
;	O
if	O
(	O
raw_image	int
)	O
{	O
printf	O
(	O
"GCL (GNU Common Lisp)  %s  %ld pages\n"	pointer
,	O
LISP_IMPLEMENTATION_VERSION	pointer
,	O
real_maxpage	long
)	O
;	O
fflush	function
(	O
stdout	O
)	O
;	O
if	O
(	O
argc	int
>	O
1	int
)	O
{	O
massert	function
(	O
argv	pointer
[	O
1	int
]	O
[	O
strlen	function
(	O
argv	pointer
[	O
1	int
]	O
)	O
-	O
1	int
]	O
==	O
'/'	O
)	O
;	O
system_directory	pointer
=	O
argv	pointer
[	O
1	int
]	O
;	O
}	O
initlisp	function
(	O
)	O
;	O
lex_new	function
(	O
)	O
;	O
GBC_enable	int
=	O
TRUE	O
;	O
gcl_init_init	function
(	O
)	O
;	O
sLApackageA	O
->	O
s	pointer
.	O
s_dbind	O
=	O
user_package	O
;	O
}	O
else	O
{	O
terminal_io	O
->	O
sm	O
.	O
sm_object0	O
->	O
sm	O
.	O
sm_fp	O
=	O
stdin	O
;	O
terminal_io	O
->	O
sm	O
.	O
sm_object1	O
->	O
sm	O
.	O
sm_fp	O
=	O
stdout	O
;	O
gcl_init_big1	function
(	O
)	O
;	O
}	O
sSAlisp_maxpagesA	int
->	O
s	pointer
.	O
s_dbind	O
=	O
make_fixnum	function
(	O
real_maxpage	long
)	O
;	O
ihs_push	function
(	O
Cnil	O
)	O
;	O
lex_new	function
(	O
)	O
;	O
vs_base	O
=	O
vs_top	O
;	O
interrupt_enable	O
=	O
TRUE	O
;	O
install_default_signals	function
(	O
)	O
;	O
do	O
super_funcall	function
(	O
sStop_level	int
)	O
;	O
while	O
(	O
type_of	function
(	O
sSAmultiply_stacksA	int
->	O
s	pointer
.	O
s_dbind	O
)	O
==	O
t_fixnum	O
&&	O
multiply_stacks	function
(	O
fix	function
(	O
sSAmultiply_stacksA	int
->	O
s	pointer
.	O
s_dbind	O
)	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
void	O
install_segmentation_catcher	function
(	O
void	O
)	O
{	O
unblock_signals	function
(	O
SIGSEGV	O
,	O
SIGSEGV	O
)	O
;	O
unblock_signals	function
(	O
SIGBUS	O
,	O
SIGBUS	O
)	O
;	O
(	O
void	O
)	O
gcl_signal	function
(	O
SIGSEGV	O
,	O
segmentation_catcher	function
)	O
;	O
(	O
void	O
)	O
gcl_signal	function
(	O
SIGBUS	O
,	O
segmentation_catcher	function
)	O
;	O
}	O
int	O
catch_fatal	int
=	O
1	int
;	O
void	O
error	function
(	O
char	O
*	O
s	pointer
)	O
{	O
if	O
(	O
catch_fatal	int
>	O
0	int
&&	O
interrupt_enable	O
)	O
{	O
catch_fatal	int
=	O
-	O
1	int
;	O
{	O
install_segmentation_catcher	function
(	O
)	O
;	O
}	O
FEerror	function
(	O
"Caught fatal error [memory may be damaged]"	pointer
,	O
0	int
)	O
;	O
}	O
printf	O
(	O
"\nUnrecoverable error: %s.\n"	pointer
,	O
s	pointer
)	O
;	O
fflush	function
(	O
stdout	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
static	O
void	O
initlisp	function
(	O
void	O
)	O
{	O
void	O
*	O
v	pointer
=	O
&	O
v	pointer
;	O
if	O
(	O
NULL_OR_ON_C_STACK	function
(	O
v	pointer
)	O
==	O
0	int
||	O
NULL_OR_ON_C_STACK	function
(	O
pagetoinfo	function
(	O
first_data_page	O
)	O
)	O
||	O
NULL_OR_ON_C_STACK	function
(	O
core_end	O
-	O
1	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"%p %d "	pointer
"%p %d %p %d\n"	pointer
,	O
v	pointer
,	O
NULL_OR_ON_C_STACK	function
(	O
v	pointer
)	O
,	O
pagetoinfo	function
(	O
first_data_page	O
)	O
,	O
NULL_OR_ON_C_STACK	function
(	O
pagetoinfo	function
(	O
first_data_page	O
)	O
)	O
,	O
core_end	O
-	O
1	int
,	O
NULL_OR_ON_C_STACK	function
(	O
core_end	O
-	O
1	int
)	O
)	O
;	O
error	function
(	O
"NULL_OR_ON_C_STACK macro invalid"	pointer
)	O
;	O
}	O
Cnil	O
->	O
fw	O
=	O
0	int
;	O
set_type_of	function
(	O
Cnil	O
,	O
t_symbol	O
)	O
;	O
Cnil	O
->	O
c	O
.	O
c_cdr	O
=	O
Cnil	O
;	O
Cnil_body	O
.	O
s	pointer
.	O
s_dbind	O
=	O
Cnil	O
;	O
Cnil_body	O
.	O
s	pointer
.	O
s_sfdef	O
=	O
NOT_SPECIAL	O
;	O
Cnil_body	O
.	O
s	pointer
.	O
s_fillp	O
=	O
3	int
;	O
Cnil_body	O
.	O
s	pointer
.	O
s_self	O
=	O
"NIL"	pointer
;	O
Cnil_body	O
.	O
s	pointer
.	O
s_gfdef	O
=	O
OBJNULL	O
;	O
Cnil_body	O
.	O
s	pointer
.	O
s_plist	O
=	O
Cnil	O
;	O
Cnil_body	O
.	O
s	pointer
.	O
s_hpack	O
=	O
Cnil	O
;	O
Cnil_body	O
.	O
s	pointer
.	O
s_stype	O
=	O
(	O
short	O
)	O
stp_constant	O
;	O
Cnil_body	O
.	O
s	pointer
.	O
s_mflag	O
=	O
FALSE	O
;	O
Ct	O
->	O
fw	O
=	O
0	int
;	O
set_type_of	function
(	O
Ct	O
,	O
t_symbol	O
)	O
;	O
Ct_body	O
.	O
s	pointer
.	O
s_dbind	O
=	O
Ct	O
;	O
Ct_body	O
.	O
s	pointer
.	O
s_sfdef	O
=	O
NOT_SPECIAL	O
;	O
Ct_body	O
.	O
s	pointer
.	O
s_fillp	O
=	O
1	int
;	O
Ct_body	O
.	O
s	pointer
.	O
s_self	O
=	O
"T"	pointer
;	O
Ct_body	O
.	O
s	pointer
.	O
s_gfdef	O
=	O
OBJNULL	O
;	O
Ct_body	O
.	O
s	pointer
.	O
s_plist	O
=	O
Cnil	O
;	O
Ct_body	O
.	O
s	pointer
.	O
s_hpack	O
=	O
Cnil	O
;	O
Ct_body	O
.	O
s	pointer
.	O
s_stype	O
=	O
(	O
short	O
)	O
stp_constant	O
;	O
Ct_body	O
.	O
s	pointer
.	O
s_mflag	O
=	O
FALSE	O
;	O
gcl_init_symbol	function
(	O
)	O
;	O
gcl_init_package	function
(	O
)	O
;	O
Cnil	O
->	O
s	pointer
.	O
s_hpack	O
=	O
lisp_package	O
;	O
import	function
(	O
Cnil	O
,	O
lisp_package	O
)	O
;	O
export	function
(	O
Cnil	O
,	O
lisp_package	O
)	O
;	O
Ct	O
->	O
s	pointer
.	O
s_hpack	O
=	O
lisp_package	O
;	O
import	function
(	O
Ct	O
,	O
lisp_package	O
)	O
;	O
export	function
(	O
Ct	O
,	O
lisp_package	O
)	O
;	O
sLlambda	O
=	O
make_ordinary	function
(	O
"LAMBDA"	pointer
)	O
;	O
sLlambda_block	O
=	O
make_ordinary	function
(	O
"LAMBDA-BLOCK"	pointer
)	O
;	O
sLlambda_closure	O
=	O
make_ordinary	function
(	O
"LAMBDA-CLOSURE"	pointer
)	O
;	O
sLlambda_block_closure	O
=	O
make_ordinary	function
(	O
"LAMBDA-BLOCK-CLOSURE"	pointer
)	O
;	O
sLspecial	O
=	O
make_ordinary	function
(	O
"SPECIAL"	pointer
)	O
;	O
NewInit	function
(	O
)	O
;	O
gcl_init_typespec	function
(	O
)	O
;	O
gcl_init_number	function
(	O
)	O
;	O
gcl_init_character	function
(	O
)	O
;	O
gcl_init_read	function
(	O
)	O
;	O
gcl_init_bind	function
(	O
)	O
;	O
gcl_init_pathname	function
(	O
)	O
;	O
gcl_init_print	function
(	O
)	O
;	O
gcl_init_GBC	function
(	O
)	O
;	O
gcl_init_unixfasl	function
(	O
)	O
;	O
gcl_init_unixsys	function
(	O
)	O
;	O
gcl_init_unixsave	function
(	O
)	O
;	O
gcl_init_alloc_function	function
(	O
)	O
;	O
gcl_init_array_function	function
(	O
)	O
;	O
gcl_init_character_function	function
(	O
)	O
;	O
gcl_init_file_function	function
(	O
)	O
;	O
gcl_init_list_function	function
(	O
)	O
;	O
gcl_init_package_function	function
(	O
)	O
;	O
gcl_init_pathname_function	function
(	O
)	O
;	O
gcl_init_predicate_function	function
(	O
)	O
;	O
gcl_init_print_function	function
(	O
)	O
;	O
gcl_init_read_function	function
(	O
)	O
;	O
gcl_init_sequence_function	function
(	O
)	O
;	O
gcl_init_structure_function	function
(	O
)	O
;	O
gcl_init_string_function	function
(	O
)	O
;	O
gcl_init_symbol_function	function
(	O
)	O
;	O
gcl_init_typespec_function	function
(	O
)	O
;	O
gcl_init_hash	function
(	O
)	O
;	O
gcl_init_cfun	function
(	O
)	O
;	O
gcl_init_unixfsys	function
(	O
)	O
;	O
gcl_init_unixtime	function
(	O
)	O
;	O
gcl_init_eval	function
(	O
)	O
;	O
gcl_init_lex	function
(	O
)	O
;	O
gcl_init_prog	function
(	O
)	O
;	O
gcl_init_catch	function
(	O
)	O
;	O
gcl_init_block	function
(	O
)	O
;	O
gcl_init_macros	function
(	O
)	O
;	O
gcl_init_conditional	function
(	O
)	O
;	O
gcl_init_reference	function
(	O
)	O
;	O
gcl_init_assignment	function
(	O
)	O
;	O
gcl_init_multival	function
(	O
)	O
;	O
gcl_init_error	function
(	O
)	O
;	O
gcl_init_let	function
(	O
)	O
;	O
gcl_init_mapfun	function
(	O
)	O
;	O
gcl_init_iteration	function
(	O
)	O
;	O
gcl_init_toplevel	function
(	O
)	O
;	O
gcl_init_cmpaux	function
(	O
)	O
;	O
init_main	function
(	O
)	O
;	O
gcl_init_format	function
(	O
)	O
;	O
gcl_init_links	function
(	O
)	O
;	O
gcl_init_fat_string	function
(	O
)	O
;	O
gcl_init_sfasl	function
(	O
)	O
;	O
gcl_init_cmac	function
(	O
)	O
;	O
}	O
object	O
vs_overflow	function
(	O
void	O
)	O
{	O
if	O
(	O
vs_limit	O
>	O
vs_org	O
+	O
stack_multiple	int
*	O
VSSIZE	O
)	O
error	function
(	O
"value stack overflow"	pointer
)	O
;	O
vs_limit	O
+=	O
STACK_OVER	int
*	O
VSGETA	O
;	O
FEerror	function
(	O
"Value stack overflow."	pointer
,	O
0	int
)	O
;	O
return	O
Cnil	O
;	O
}	O
void	O
bds_overflow	function
(	O
void	O
)	O
{	O
--	O
bds_top	O
;	O
if	O
(	O
bds_limit	O
>	O
bds_org	O
+	O
stack_multiple	int
*	O
BDSSIZE	O
)	O
{	O
error	function
(	O
"bind stack overflow"	pointer
)	O
;	O
}	O
bds_limit	O
+=	O
STACK_OVER	int
*	O
BDSGETA	O
;	O
FEerror	function
(	O
"Bind stack overflow."	pointer
,	O
0	int
)	O
;	O
}	O
void	O
frs_overflow	function
(	O
void	O
)	O
{	O
--	O
frs_top	O
;	O
if	O
(	O
frs_limit	O
>	O
frs_org	O
+	O
stack_multiple	int
*	O
FRSSIZE	O
)	O
error	function
(	O
"frame stack overflow"	pointer
)	O
;	O
frs_limit	O
+=	O
STACK_OVER	int
*	O
FRSGETA	O
;	O
FEerror	function
(	O
"Frame stack overflow."	pointer
,	O
0	int
)	O
;	O
}	O
void	O
ihs_overflow	function
(	O
void	O
)	O
{	O
--	O
ihs_top	O
;	O
if	O
(	O
ihs_limit	O
>	O
ihs_org	O
+	O
stack_multiple	int
*	O
IHSSIZE	O
)	O
error	function
(	O
"invocation history stack overflow"	pointer
)	O
;	O
ihs_limit	O
+=	O
STACK_OVER	int
*	O
IHSGETA	O
;	O
FEerror	function
(	O
"Invocation history stack overflow."	pointer
,	O
0	int
)	O
;	O
}	O
void	O
segmentation_catcher	function
(	O
int	O
i	int
)	O
{	O
error	function
(	O
"Segmentation violation."	pointer
)	O
;	O
}	O
DEFUNO_NEW	function
(	O
"BYE"	pointer
,	O
object	O
,	O
fLbye	O
,	O
LISP	O
,	O
0	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lby	O
,	O
(	O
object	O
exitc	O
)	O
,	O
""	pointer
)	O
{	O
int	O
n	int
=	O
VFUN_NARGS	O
;	O
int	O
exit_code	int
;	O
if	O
(	O
n	int
>=	O
1	int
)	O
exit_code	int
=	O
fix	function
(	O
exitc	O
)	O
;	O
else	O
exit_code	int
=	O
0	int
;	O
exit	function
(	O
exit_code	int
)	O
;	O
}	O
DEFUN_NEW	function
(	O
"QUIT"	pointer
,	O
object	O
,	O
fLquit	O
,	O
LISP	O
,	O
0	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
exitc	O
)	O
,	O
""	pointer
)	O
{	O
return	O
FFN	function
(	O
fLbye	O
)	O
(	O
exitc	O
)	O
;	O
}	O
static	O
void	O
FFN	function
(	O
siLargc	int
)	O
(	O
void	O
)	O
{	O
check_arg	function
(	O
0	int
)	O
;	O
vs_push	function
(	O
make_fixnum	function
(	O
ARGC	O
)	O
)	O
;	O
}	O
static	O
void	O
FFN	function
(	O
siLargv	int
)	O
(	O
void	O
)	O
{	O
int	O
i	int
=	O
0	int
;	O
check_arg	function
(	O
1	int
)	O
;	O
if	O
(	O
type_of	function
(	O
vs_base	O
[	O
0	int
]	O
)	O
!=	O
t_fixnum	O
||	O
(	O
i	int
=	O
fix	function
(	O
vs_base	O
[	O
0	int
]	O
)	O
)	O
<	O
0	int
||	O
i	int
>=	O
ARGC	O
)	O
FEerror	function
(	O
"Illegal argument index: ~S."	pointer
,	O
1	int
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
make_simple_string	function
(	O
ARGV	O
[	O
i	int
]	O
)	O
;	O
}	O
static	O
void	O
FFN	function
(	O
siLgetenv	int
)	O
(	O
void	O
)	O
{	O
char	O
name	array
[	O
256	int
]	O
;	O
int	O
i	int
;	O
char	O
*	O
value	pointer
;	O
extern	O
char	O
*	O
getenv	function
(	O
const	O
char	O
*	O
)	O
;	O
check_arg	function
(	O
1	int
)	O
;	O
check_type_string	function
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
vs_base	O
[	O
0	int
]	O
->	O
st	O
.	O
st_fillp	O
>=	O
256	int
)	O
FEerror	function
(	O
"Too long name: ~S."	pointer
,	O
1	int
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
vs_base	O
[	O
0	int
]	O
->	O
st	O
.	O
st_fillp	O
;	O
i	int
++	O
)	O
name	array
[	O
i	int
]	O
=	O
vs_base	O
[	O
0	int
]	O
->	O
st	O
.	O
st_self	O
[	O
i	int
]	O
;	O
name	array
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
(	O
value	pointer
=	O
getenv	function
(	O
name	array
)	O
)	O
!=	O
NULL	O
)	O
{	O
vs_base	O
[	O
0	int
]	O
=	O
make_simple_string	function
(	O
value	pointer
)	O
;	O
}	O
else	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
}	O
object	O
*	O
vs_marker	pointer
;	O
static	O
void	O
FFN	function
(	O
siLmark_vs	int
)	O
(	O
void	O
)	O
{	O
check_arg	function
(	O
0	int
)	O
;	O
vs_marker	pointer
=	O
vs_base	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
}	O
static	O
void	O
FFN	function
(	O
siLcheck_vs	int
)	O
(	O
void	O
)	O
{	O
check_arg	function
(	O
0	int
)	O
;	O
if	O
(	O
vs_base	O
!=	O
vs_marker	pointer
)	O
FEerror	function
(	O
"Value stack is flawed."	pointer
,	O
0	int
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
}	O
static	O
object	O
FFN	function
(	O
siLcatch_fatal	int
)	O
(	O
int	O
i	int
)	O
{	O
catch_fatal	int
=	O
i	int
;	O
return	O
Cnil	O
;	O
}	O
LFD	function
(	O
siLreset_stack_limits	int
)	O
(	O
void	O
)	O
{	O
long	O
i	int
=	O
0	int
;	O
check_arg	function
(	O
0	int
)	O
;	O
if	O
(	O
catch_fatal	int
<	O
0	int
)	O
catch_fatal	int
=	O
1	int
;	O
if	O
(	O
vs_top	O
<	O
vs_org	O
+	O
stack_multiple	int
*	O
VSSIZE	O
)	O
vs_limit	O
=	O
vs_org	O
+	O
stack_multiple	int
*	O
VSSIZE	O
;	O
else	O
error	function
(	O
"can't reset vs_limit"	pointer
)	O
;	O
if	O
(	O
bds_top	O
<	O
bds_org	O
+	O
stack_multiple	int
*	O
BDSSIZE	O
)	O
bds_limit	O
=	O
bds_org	O
+	O
stack_multiple	int
*	O
BDSSIZE	O
;	O
else	O
error	function
(	O
"can't reset bds_limit"	pointer
)	O
;	O
if	O
(	O
frs_top	O
<	O
frs_org	O
+	O
stack_multiple	int
*	O
FRSSIZE	O
)	O
frs_limit	O
=	O
frs_org	O
+	O
stack_multiple	int
*	O
FRSSIZE	O
;	O
else	O
error	function
(	O
"can't reset frs_limit"	pointer
)	O
;	O
if	O
(	O
ihs_top	O
<	O
ihs_org	O
+	O
stack_multiple	int
*	O
IHSSIZE	O
)	O
ihs_limit	O
=	O
ihs_org	O
+	O
stack_multiple	int
*	O
IHSSIZE	O
;	O
else	O
error	function
(	O
"can't reset ihs_limit"	pointer
)	O
;	O
if	O
(	O
cs_base	O
==	O
cs_org	O
)	O
cs_org	O
=	O
(	O
void	O
*	O
)	O
&	O
i	int
;	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
}	O
static	O
int	O
multiply_stacks	function
(	O
int	O
m	int
)	O
{	O
void	O
*	O
p	pointer
;	O
int	O
vs	int
,	O
bd	int
,	O
frs	int
,	O
ihs	int
;	O
stack_multiple	int
=	O
stack_multiple	int
*	O
m	int
;	O
vs	int
=	O
(	O
stack_multiple	int
*	O
VSSIZE	O
+	O
(	O
STACK_OVER	int
+	O
1	int
)	O
*	O
VSGETA	O
)	O
*	O
ELTSIZE	O
(	O
vs_org	O
)	O
;	O
bd	int
=	O
(	O
stack_multiple	int
*	O
BDSSIZE	O
+	O
(	O
STACK_OVER	int
+	O
1	int
)	O
*	O
BDSGETA	O
)	O
*	O
ELTSIZE	O
(	O
bds_org	O
)	O
;	O
frs	int
=	O
(	O
stack_multiple	int
*	O
FRSSIZE	O
+	O
(	O
STACK_OVER	int
+	O
1	int
)	O
*	O
FRSGETA	O
)	O
*	O
ELTSIZE	O
(	O
frs_org	O
)	O
;	O
ihs	int
=	O
(	O
stack_multiple	int
*	O
IHSSIZE	O
+	O
(	O
STACK_OVER	int
+	O
1	int
)	O
*	O
IHSGETA	O
)	O
*	O
ELTSIZE	O
(	O
ihs_org	O
)	O
;	O
if	O
(	O
stack_space	int
==	O
0	int
)	O
{	O
enter_mark_origin	function
(	O
&	O
stack_space	int
)	O
;	O
}	O
stack_space	int
=	O
alloc_simple_string	function
(	O
vs	int
+	O
bd	int
+	O
frs	int
+	O
ihs	int
)	O
;	O
array_allocself	function
(	O
stack_space	int
,	O
1	int
,	O
code_char	function
(	O
0	int
)	O
)	O
;	O
p	pointer
=	O
stack_space	int
->	O
st	O
.	O
st_self	O
;	O
COPYSTACK	O
(	O
vs_org	O
,	O
p	pointer
,	O
object	O
,	O
vs_limit	O
,	O
vs_top	O
,	O
VSGETA	O
,	O
VSSIZE	O
)	O
;	O
COPYSTACK	O
(	O
bds_org	O
,	O
p	pointer
,	O
struct	O
bds_bd	O
,	O
bds_limit	O
,	O
bds_top	O
,	O
BDSGETA	O
,	O
BDSSIZE	O
)	O
;	O
COPYSTACK	O
(	O
frs_org	O
,	O
p	pointer
,	O
struct	O
frame	O
,	O
frs_limit	O
,	O
frs_top	O
,	O
FRSGETA	O
,	O
FRSSIZE	O
)	O
;	O
COPYSTACK	O
(	O
ihs_org	O
,	O
p	pointer
,	O
struct	O
invocation_history	O
,	O
ihs_limit	O
,	O
ihs_top	O
,	O
IHSGETA	O
,	O
IHSSIZE	O
)	O
;	O
vs_base	O
=	O
vs_top	O
;	O
return	O
stack_multiple	int
;	O
}	O
DEFVAR	function
(	O
"*NO-INIT*"	pointer
,	O
sSAno_initA	O
,	O
SI	O
,	O
Cnil	O
,	O
""	pointer
)	O
;	O
LFD	function
(	O
siLinit_system	int
)	O
(	O
void	O
)	O
{	O
check_arg	function
(	O
0	int
)	O
;	O
gcl_init_system	function
(	O
sSAno_initA	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
}	O
static	O
void	O
FFN	function
(	O
siLuser_init	int
)	O
(	O
void	O
)	O
{	O
check_arg	function
(	O
0	int
)	O
;	O
sLApackageA	O
->	O
s	pointer
.	O
s_dbind	O
=	O
user_package	O
;	O
user_init	function
(	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
}	O
DEFUN_NEW	function
(	O
"NANI"	pointer
,	O
object	O
,	O
fSnani	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OI	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
fixnum	O
address	O
)	O
,	O
""	pointer
)	O
{	O
RETURN1	function
(	O
(	O
object	O
)	O
address	O
)	O
;	O
}	O
DEFUN_NEW	function
(	O
"ADDRESS"	pointer
,	O
object	O
,	O
fSaddress	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
IO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
x	O
)	O
,	O
""	pointer
)	O
{	O
RETURN1	function
(	O
x	O
)	O
;	O
}	O
static	O
void	O
FFN	function
(	O
siLinitialization_failure	int
)	O
(	O
void	O
)	O
{	O
check_arg	function
(	O
0	int
)	O
;	O
printf	O
(	O
"lisp initialization failed\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
DEFUNO_NEW	function
(	O
"IDENTITY"	pointer
,	O
object	O
,	O
fLidentity	O
,	O
LISP	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lidentity	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	pointer
)	O
{	O
RETURN1	function
(	O
x0	O
)	O
;	O
}	O
DEFUNO_NEW	function
(	O
"GCL-COMPILE-TIME"	pointer
,	O
object	O
,	O
fSgcl_compile_time	O
,	O
SI	O
,	O
0	int
,	O
0	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lgcl_compile_time	O
,	O
(	O
void	O
)	O
,	O
""	pointer
)	O
{	O
RETURN1	function
(	O
make_simple_string	function
(	O
__DATE__	O
" "	pointer
__TIME__	O
)	O
)	O
;	O
}	O
DEFUNO_NEW	function
(	O
"LDB1"	pointer
,	O
object	O
,	O
fSldb1	O
,	O
SI	O
,	O
3	int
,	O
3	int
,	O
NONE	O
,	O
OI	O
,	O
II	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lldb1	O
,	O
(	O
fixnum	O
a	O
,	O
fixnum	O
b	char
,	O
fixnum	O
c	O
)	O
,	O
""	pointer
)	O
{	O
RETURN1	function
(	O
make_fixnum	function
(	O
(	O
(	O
(	O
(	O
~	O
(	O
-	O
1	int
<<	O
(	O
a	O
)	O
)	O
)	O
<<	O
(	O
b	char
)	O
)	O
&	O
(	O
c	O
)	O
)	O
>>	O
(	O
b	char
)	O
)	O
)	O
)	O
;	O
}	O
DEFUN_NEW	function
(	O
"LISP-IMPLEMENTATION-VERSION"	pointer
,	O
object	O
,	O
fLlisp_implementation_version	O
,	O
LISP	O
,	O
0	int
,	O
0	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
void	O
)	O
,	O
""	pointer
)	O
{	O
RETURN1	function
(	O
(	O
make_simple_string	function
(	O
LISP_IMPLEMENTATION_VERSION	pointer
)	O
)	O
)	O
;	O
}	O
static	O
void	O
FFN	function
(	O
siLsave_system	int
)	O
(	O
void	O
)	O
{	O
saving_system	int
=	O
TRUE	O
;	O
minimize_image	function
(	O
)	O
;	O
saving_system	int
=	O
FALSE	O
;	O
Lsave	function
(	O
)	O
;	O
alloc_page	function
(	O
-	O
(	O
holepage	O
+	O
nrbpage	O
)	O
)	O
;	O
}	O
DEFVAR	function
(	O
"*LISP-MAXPAGES*"	pointer
,	O
sSAlisp_maxpagesA	int
,	O
SI	O
,	O
make_fixnum	function
(	O
real_maxpage	long
)	O
,	O
""	pointer
)	O
;	O
DEFVAR	function
(	O
"*SYSTEM-DIRECTORY*"	pointer
,	O
sSAsystem_directoryA	O
,	O
SI	O
,	O
make_simple_string	function
(	O
system_directory	pointer
)	O
,	O
""	pointer
)	O
;	O
DEFVAR	function
(	O
"*MULTIPLY-STACKS*"	pointer
,	O
sSAmultiply_stacksA	int
,	O
SI	O
,	O
Cnil	O
,	O
""	pointer
)	O
;	O
DEF_ORDINARY	function
(	O
"TOP-LEVEL"	pointer
,	O
sStop_level	int
,	O
SI	O
,	O
""	pointer
)	O
;	O
DEFVAR	function
(	O
"*COMMAND-ARGS*"	pointer
,	O
sSAcommand_argsA	O
,	O
SI	O
,	O
sLnil	O
,	O
""	pointer
)	O
;	O
static	O
void	O
init_main	function
(	O
void	O
)	O
{	O
make_function	function
(	O
"BY"	pointer
,	O
Lby	O
)	O
;	O
make_si_function	function
(	O
"ARGC"	pointer
,	O
siLargc	int
)	O
;	O
make_si_function	function
(	O
"ARGV"	pointer
,	O
siLargv	int
)	O
;	O
make_si_function	function
(	O
"GETENV"	pointer
,	O
siLgetenv	int
)	O
;	O
make_si_function	function
(	O
"MARK-VS"	pointer
,	O
siLmark_vs	int
)	O
;	O
make_si_function	function
(	O
"CHECK-VS"	pointer
,	O
siLcheck_vs	int
)	O
;	O
make_si_function	function
(	O
"RESET-STACK-LIMITS"	pointer
,	O
siLreset_stack_limits	int
)	O
;	O
make_si_function	function
(	O
"INIT-SYSTEM"	pointer
,	O
siLinit_system	int
)	O
;	O
make_si_function	function
(	O
"USER-INIT"	pointer
,	O
siLuser_init	int
)	O
;	O
make_si_function	function
(	O
"INITIALIZATION-FAILURE"	pointer
,	O
siLinitialization_failure	int
)	O
;	O
siClisp_pagesize	int
=	O
make_si_constant	function
(	O
"LISP-PAGESIZE"	pointer
,	O
make_fixnum	function
(	O
PAGESIZE	O
)	O
)	O
;	O
{	O
object	O
features	O
;	O
features	O
=	O
make_cons	function
(	O
make_keyword	function
(	O
"COMMON"	pointer
)	O
,	O
make_cons	function
(	O
make_keyword	function
(	O
"KCL"	pointer
)	O
,	O
Cnil	O
)	O
)	O
;	O
ADD_FEATURE	O
(	O
"AKCL"	pointer
)	O
;	O
ADD_FEATURE	O
(	O
"GCL"	pointer
)	O
;	O
ADD_FEATURE	O
(	O
"UNIX"	pointer
)	O
;	O
ADD_FEATURE	O
(	O
HOST_CPU	O
)	O
;	O
ADD_FEATURE	O
(	O
HOST_KERNEL	O
)	O
;	O
ADD_FEATURE	O
(	O
"CLX-LITTLE-ENDIAN"	pointer
)	O
;	O
{	O
int	O
Bigm	int
=	O
BIGM	O
;	O
int	O
Smallm	int
=	O
-	O
BIGM	O
-	O
1	int
;	O
int	O
Seven	int
=	O
7	int
;	O
int	O
Three	int
=	O
3	int
;	O
if	O
(	O
(	O
Smallm	int
/	O
Seven	int
)	O
<	O
0	int
&&	O
(	O
Smallm	int
/	O
(	O
-	O
Seven	int
)	O
)	O
>	O
0	int
&&	O
(	O
Bigm	int
/	O
(	O
-	O
Seven	int
)	O
)	O
<	O
0	int
&&	O
(	O
(	O
-	O
Seven	int
)	O
/	O
Three	int
)	O
==	O
-	O
2	int
&&	O
(	O
Seven	int
/	O
(	O
-	O
Three	int
)	O
)	O
==	O
-	O
2	int
&&	O
(	O
(	O
-	O
Seven	int
)	O
/	O
(	O
-	O
Three	int
)	O
)	O
==	O
2	int
)	O
{	O
ADD_FEATURE	O
(	O
"TRUNCATE_USE_C"	pointer
)	O
;	O
}	O
}	O
ADD_FEATURE	O
(	O
"NATIVE-RELOC"	pointer
)	O
;	O
ADD_FEATURE	O
(	O
"UNEXEC"	pointer
)	O
;	O
make_special	function
(	O
"*FEATURES*"	pointer
,	O
features	O
)	O
;	O
}	O
make_si_function	function
(	O
"SAVE-SYSTEM"	pointer
,	O
siLsave_system	int
)	O
;	O
make_si_sfun	function
(	O
"CATCH-FATAL"	pointer
,	O
siLcatch_fatal	int
,	O
ARGTYPE1	function
(	O
f_fixnum	O
)	O
)	O
;	O
make_si_function	function
(	O
"WARN-VERSION"	pointer
,	O
Lidentity	O
)	O
;	O
}	O
DEFUN_NEW	function
(	O
"DISASSEMBLE-INSTRUCTION"	pointer
,	O
object	O
,	O
fSdisassemble_instruction	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OI	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
fixnum	O
addr	O
)	O
,	O
""	pointer
)	O
{	O
return	O
MMcons	function
(	O
make_simple_string	function
(	O
"fnop ;"	pointer
)	O
,	O
make_fixnum	function
(	O
0	int
)	O
)	O
;	O
}	O
typedef	O
struct	O
{	O
enum	O
type	O
tt	enum
;	O
struct	O
typemanager	O
*	O
tp	pointer
;	O
}	O
Tbl	struct
;	O
DEFUN_NEW	function
(	O
"FUNCTION-BY-ADDRESS"	pointer
,	O
object	O
,	O
fSfunction_by_address	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OI	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
fixnum	O
ad	O
)	O
,	O
""	pointer
)	O
{	O
ufixnum	O
m	int
=	O
-	O
1	int
,	O
mm	O
,	O
j	int
;	O
void	O
*	O
o	pointer
;	O
object	O
x	O
,	O
xx	O
=	O
Cnil	O
;	O
Tbl	struct
tb1	array
[	O
]	O
=	O
{	O
Tblof	O
(	O
t_sfun	O
)	O
,	O
Tblof	O
(	O
t_cfun	O
)	O
,	O
Tblof	O
(	O
t_vfun	O
)	O
,	O
Tblof	O
(	O
t_afun	O
)	O
,	O
Tblof	O
(	O
t_gfun	O
)	O
,	O
Tblof	O
(	O
t_closure	O
)	O
,	O
Tblof	O
(	O
t_cclosure	O
)	O
,	O
{	O
0	int
}	O
}	O
;	O
struct	O
typemanager	O
*	O
tp	pointer
;	O
enum	O
type	O
tt	enum
;	O
struct	O
pageinfo	O
*	O
v	pointer
;	O
if	O
(	O
VALID_DATA_ADDRESS_P	function
(	O
ad	O
)	O
)	O
for	O
(	O
v	pointer
=	O
cell_list_head	O
;	O
v	pointer
;	O
v	pointer
=	O
v	pointer
->	O
next	O
)	O
if	O
(	O
tblookup	O
(	O
mtm_of	O
(	O
v	pointer
->	O
type	O
)	O
,	O
tp	pointer
)	O
)	O
for	O
(	O
o	pointer
=	O
pagetochar	function
(	O
page	function
(	O
v	pointer
)	O
)	O
,	O
j	int
=	O
tp	pointer
->	O
tm_nppage	O
;	O
j	int
--	O
;	O
o	pointer
+=	O
tp	pointer
->	O
tm_size	O
)	O
if	O
(	O
tblookup	O
(	O
type_of	function
(	O
(	O
x	O
=	O
o	pointer
)	O
)	O
,	O
tt	enum
)	O
)	O
if	O
(	O
!	O
is_free	function
(	O
x	O
)	O
&&	O
(	O
mm	O
=	O
ad	O
-	O
(	O
ufixnum	O
)	O
x	O
->	O
sfn	O
.	O
sfn_self	O
)	O
<	O
m	int
)	O
{	O
m	int
=	O
mm	O
;	O
xx	O
=	O
x	O
;	O
}	O
return	O
xx	O
;	O
}	O
