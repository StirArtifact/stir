static	O
int	O
is_letter	function
__P	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
nextword	function
__P	O
(	O
(	O
int	O
*	O
,	O
int	O
*	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
int	O
linestart	function
__P	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
int	O
lineend	function
__P	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
int	O
rem	int
__P	O
(	O
(	O
int	O
,	O
int	O
,	O
int	O
,	O
int	O
,	O
int	O
,	O
char	O
*	O
,	O
int	O
)	O
)	O
;	O
static	O
int	O
eq	function
__P	O
(	O
(	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
int	O
MarkScrollDownDisplay	function
__P	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
int	O
MarkScrollUpDisplay	function
__P	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
MarkProcess	function
__P	O
(	O
(	O
char	O
*	O
*	O
,	O
int	O
*	O
)	O
)	O
;	O
static	O
void	O
MarkAbort	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
MarkRedisplayLine	function
__P	O
(	O
(	O
int	O
,	O
int	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
int	O
MarkRewrite	function
__P	O
(	O
(	O
int	O
,	O
int	O
,	O
int	O
,	O
struct	O
mchar	struct
*	O
,	O
int	O
)	O
)	O
;	O
extern	O
struct	O
layer	struct
*	O
flayer	pointer
;	O
extern	O
struct	O
display	struct
*	O
display	struct
,	O
*	O
displays	pointer
;	O
extern	O
struct	O
win	struct
*	O
fore	pointer
;	O
extern	O
struct	O
mline	struct
mline_blank	struct
,	O
mline_null	struct
;	O
extern	O
struct	O
mchar	struct
mchar_so	struct
;	O
int	O
pastefont	int
=	O
1	int
;	O
struct	O
LayFuncs	struct
MarkLf	struct
=	O
{	O
MarkProcess	function
,	O
MarkAbort	function
,	O
MarkRedisplayLine	function
,	O
DefClearLine	function
,	O
MarkRewrite	function
,	O
DefResize	function
,	O
DefRestore	function
,	O
0	int
}	O
;	O
int	O
join_with_cr	int
=	O
0	int
;	O
int	O
compacthist	int
=	O
0	int
;	O
unsigned	O
char	O
mark_key_tab	array
[	O
256	int
]	O
;	O
static	O
struct	O
markdata	struct
*	O
markdata	struct
;	O
static	O
int	O
is_letter	function
(	O
c	char
)	O
char	O
c	char
;	O
{	O
if	O
(	O
(	O
c	char
>=	O
'a'	O
&&	O
c	char
<=	O
'z'	O
)	O
||	O
(	O
c	char
>=	O
'A'	O
&&	O
c	char
<=	O
'Z'	O
)	O
||	O
(	O
c	char
>=	O
'0'	O
&&	O
c	char
<=	O
'9'	O
)	O
||	O
c	char
==	O
'_'	O
||	O
c	char
==	O
'.'	O
||	O
c	char
==	O
'@'	O
||	O
c	char
==	O
':'	O
||	O
c	char
==	O
'%'	O
||	O
c	char
==	O
'!'	O
||	O
c	char
==	O
'-'	O
||	O
c	char
==	O
'+'	O
)	O
return	O
1	int
;	O
else	O
if	O
(	O
c	char
!=	O
' '	O
)	O
return	O
2	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
linestart	function
(	O
y	int
)	O
int	O
y	int
;	O
{	O
register	O
int	O
x	int
;	O
register	O
unsigned	O
char	O
*	O
i	pointer
;	O
for	O
(	O
x	int
=	O
markdata	struct
->	O
left_mar	int
,	O
i	pointer
=	O
WIN	O
(	O
y	int
)	O
->	O
image	char
+	O
x	int
;	O
x	int
<	O
fore	pointer
->	O
w_width	O
-	O
1	int
;	O
x	int
++	O
)	O
if	O
(	O
*	O
i	pointer
++	O
!=	O
' '	O
)	O
break	O
;	O
if	O
(	O
x	int
==	O
fore	pointer
->	O
w_width	O
-	O
1	int
)	O
x	int
=	O
markdata	struct
->	O
left_mar	int
;	O
return	O
x	int
;	O
}	O
static	O
int	O
lineend	function
(	O
y	int
)	O
int	O
y	int
;	O
{	O
register	O
int	O
x	int
;	O
register	O
unsigned	O
char	O
*	O
i	pointer
;	O
for	O
(	O
x	int
=	O
markdata	struct
->	O
right_mar	int
,	O
i	pointer
=	O
WIN	O
(	O
y	int
)	O
->	O
image	char
+	O
x	int
;	O
x	int
>=	O
0	int
;	O
x	int
--	O
)	O
if	O
(	O
*	O
i	pointer
--	O
!=	O
' '	O
)	O
break	O
;	O
if	O
(	O
x	int
<	O
0	int
)	O
x	int
=	O
markdata	struct
->	O
left_mar	int
;	O
return	O
x	int
;	O
}	O
static	O
int	O
nextchar	function
(	O
int	O
*	O
xp	pointer
,	O
int	O
*	O
yp	pointer
,	O
int	O
direction	int
,	O
char	O
target	int
,	O
int	O
num	int
)	O
{	O
int	O
width	int
;	O
int	O
x	int
;	O
int	O
step	int
;	O
int	O
adjust	int
;	O
char	O
*	O
displayed_line	pointer
;	O
debug	O
(	O
"nextchar\n"	pointer
)	O
;	O
x	int
=	O
*	O
xp	pointer
;	O
step	int
=	O
1	int
;	O
adjust	int
=	O
0	int
;	O
width	int
=	O
fore	pointer
->	O
w_width	O
;	O
displayed_line	pointer
=	O
(	O
char	O
*	O
)	O
WIN	O
(	O
*	O
yp	pointer
)	O
->	O
image	char
;	O
switch	O
(	O
direction	int
)	O
{	O
case	O
't'	O
:	O
adjust	int
=	O
-	O
1	int
;	O
case	O
'f'	O
:	O
step	int
=	O
1	int
;	O
break	O
;	O
case	O
'T'	O
:	O
adjust	int
=	O
1	int
;	O
case	O
'F'	O
:	O
step	int
=	O
-	O
1	int
;	O
break	O
;	O
default	O
:	O
ASSERT	O
(	O
0	int
)	O
;	O
}	O
x	int
+=	O
step	int
;	O
debug1	O
(	O
"ml->image = %s\n"	pointer
,	O
displayed_line	pointer
)	O
;	O
debug2	O
(	O
"num = %d, width = %d\n"	pointer
,	O
num	int
,	O
width	int
)	O
;	O
debug2	O
(	O
"x = %d target = %c\n"	pointer
,	O
x	int
,	O
target	int
)	O
;	O
for	O
(	O
;	O
x	int
>=	O
0	int
&&	O
x	int
<=	O
width	int
;	O
x	int
+=	O
step	int
)	O
{	O
if	O
(	O
displayed_line	pointer
[	O
x	int
]	O
==	O
target	int
)	O
{	O
if	O
(	O
--	O
num	int
==	O
0	int
)	O
{	O
*	O
xp	pointer
=	O
x	int
+	O
adjust	int
;	O
return	O
0	int
;	O
}	O
}	O
}	O
return	O
-	O
1	int
;	O
}	O
static	O
void	O
nextword	function
(	O
xp	pointer
,	O
yp	pointer
,	O
flags	int
,	O
num	int
)	O
int	O
*	O
xp	pointer
,	O
*	O
yp	pointer
,	O
flags	int
,	O
num	int
;	O
{	O
int	O
xx	int
=	O
fore	pointer
->	O
w_width	O
,	O
yy	int
=	O
fore	pointer
->	O
w_histheight	int
+	O
fore	pointer
->	O
w_height	O
;	O
register	O
int	O
sx	int
,	O
oq	int
,	O
q	int
,	O
x	int
,	O
y	int
;	O
struct	O
mline	struct
*	O
ml	pointer
;	O
x	int
=	O
*	O
xp	pointer
;	O
y	int
=	O
*	O
yp	pointer
;	O
sx	int
=	O
(	O
flags	int
&	O
NW_BACK	O
)	O
?	O
-	O
1	int
:	O
1	int
;	O
if	O
(	O
(	O
flags	int
&	O
NW_ENDOFWORD	O
)	O
&&	O
(	O
flags	int
&	O
NW_MUSTMOVE	O
)	O
)	O
x	int
+=	O
sx	int
;	O
ml	pointer
=	O
WIN	O
(	O
y	int
)	O
;	O
for	O
(	O
oq	int
=	O
-	O
1	int
;	O
;	O
x	int
+=	O
sx	int
,	O
oq	int
=	O
q	int
)	O
{	O
if	O
(	O
x	int
>=	O
xx	int
||	O
x	int
<	O
0	int
)	O
q	int
=	O
0	int
;	O
else	O
if	O
(	O
flags	int
&	O
NW_BIG	O
)	O
q	int
=	O
ml	pointer
->	O
image	char
[	O
x	int
]	O
==	O
' '	O
;	O
else	O
q	int
=	O
is_letter	function
(	O
ml	pointer
->	O
image	char
[	O
x	int
]	O
)	O
;	O
if	O
(	O
oq	int
>=	O
0	int
&&	O
oq	int
!=	O
q	int
)	O
{	O
if	O
(	O
oq	int
==	O
0	int
||	O
!	O
(	O
flags	int
&	O
NW_ENDOFWORD	O
)	O
)	O
*	O
xp	pointer
=	O
x	int
;	O
else	O
*	O
xp	pointer
=	O
x	int
-	O
sx	int
;	O
*	O
yp	pointer
=	O
y	int
;	O
if	O
(	O
(	O
!	O
(	O
flags	int
&	O
NW_ENDOFWORD	O
)	O
&&	O
q	int
)	O
||	O
(	O
(	O
flags	int
&	O
NW_ENDOFWORD	O
)	O
&&	O
oq	int
)	O
)	O
{	O
if	O
(	O
--	O
num	int
<=	O
0	int
)	O
return	O
;	O
}	O
}	O
if	O
(	O
x	int
==	O
xx	int
)	O
{	O
x	int
=	O
-	O
1	int
;	O
if	O
(	O
++	O
y	int
>=	O
yy	int
)	O
return	O
;	O
ml	pointer
=	O
WIN	O
(	O
y	int
)	O
;	O
}	O
else	O
if	O
(	O
x	int
<	O
0	int
)	O
{	O
x	int
=	O
xx	int
;	O
if	O
(	O
--	O
y	int
<	O
0	int
)	O
return	O
;	O
ml	pointer
=	O
WIN	O
(	O
y	int
)	O
;	O
}	O
}	O
}	O
static	O
int	O
rem	int
(	O
x1	int
,	O
y1	int
,	O
x2	int
,	O
y2	int
,	O
redisplay	int
,	O
pt	pointer
,	O
yend	int
)	O
int	O
x1	int
,	O
y1	int
,	O
x2	int
,	O
y2	int
,	O
redisplay	int
,	O
yend	int
;	O
char	O
*	O
pt	pointer
;	O
{	O
int	O
i	pointer
,	O
j	int
,	O
from	int
,	O
to	int
,	O
ry	int
,	O
c	char
;	O
int	O
l	int
=	O
0	int
;	O
unsigned	O
char	O
*	O
im	pointer
;	O
struct	O
mline	struct
*	O
ml	pointer
;	O
int	O
cf	int
,	O
cfx	int
,	O
font	char
;	O
unsigned	O
char	O
*	O
fo	pointer
,	O
*	O
fox	pointer
;	O
markdata	struct
->	O
second	int
=	O
0	int
;	O
if	O
(	O
y2	int
<	O
y1	int
||	O
(	O
(	O
y2	int
==	O
y1	int
)	O
&&	O
(	O
x2	int
<	O
x1	int
)	O
)	O
)	O
{	O
i	pointer
=	O
y2	int
;	O
y2	int
=	O
y1	int
;	O
y1	int
=	O
i	pointer
;	O
i	pointer
=	O
x2	int
;	O
x2	int
=	O
x1	int
;	O
x1	int
=	O
i	pointer
;	O
}	O
ry	int
=	O
y1	int
-	O
markdata	struct
->	O
hist_offset	int
;	O
i	pointer
=	O
y1	int
;	O
if	O
(	O
redisplay	int
!=	O
2	int
&&	O
pt	pointer
==	O
0	int
&&	O
ry	int
<	O
0	int
)	O
{	O
i	pointer
-=	O
ry	int
;	O
ry	int
=	O
0	int
;	O
}	O
for	O
(	O
;	O
i	pointer
<=	O
y2	int
;	O
i	pointer
++	O
,	O
ry	int
++	O
)	O
{	O
if	O
(	O
redisplay	int
!=	O
2	int
&&	O
pt	pointer
==	O
0	int
&&	O
ry	int
>	O
yend	int
)	O
break	O
;	O
ml	pointer
=	O
WIN	O
(	O
i	pointer
)	O
;	O
from	int
=	O
(	O
i	pointer
==	O
y1	int
)	O
?	O
x1	int
:	O
0	int
;	O
if	O
(	O
from	int
<	O
markdata	struct
->	O
left_mar	int
)	O
from	int
=	O
markdata	struct
->	O
left_mar	int
;	O
for	O
(	O
to	int
=	O
fore	pointer
->	O
w_width	O
,	O
im	pointer
=	O
ml	pointer
->	O
image	char
+	O
to	int
;	O
to	int
>=	O
0	int
;	O
to	int
--	O
)	O
if	O
(	O
*	O
im	pointer
--	O
!=	O
' '	O
)	O
break	O
;	O
if	O
(	O
i	pointer
==	O
y2	int
&&	O
x2	int
<	O
to	int
)	O
to	int
=	O
x2	int
;	O
if	O
(	O
to	int
>	O
markdata	struct
->	O
right_mar	int
)	O
to	int
=	O
markdata	struct
->	O
right_mar	int
;	O
if	O
(	O
redisplay	int
==	O
1	int
&&	O
from	int
<=	O
to	int
&&	O
ry	int
>=	O
0	int
&&	O
ry	int
<=	O
yend	int
)	O
MarkRedisplayLine	function
(	O
ry	int
,	O
from	int
,	O
to	int
,	O
0	int
)	O
;	O
if	O
(	O
redisplay	int
!=	O
2	int
&&	O
pt	pointer
==	O
0	int
)	O
continue	O
;	O
j	int
=	O
from	int
;	O
if	O
(	O
dw_right	O
(	O
ml	pointer
,	O
j	int
,	O
fore	pointer
->	O
w_encoding	O
)	O
)	O
j	int
--	O
;	O
im	pointer
=	O
ml	pointer
->	O
image	char
+	O
j	int
;	O
fo	pointer
=	O
ml	pointer
->	O
font	char
+	O
j	int
;	O
fox	pointer
=	O
ml	pointer
->	O
fontx	char
+	O
j	int
;	O
font	char
=	O
ASCII	int
;	O
for	O
(	O
;	O
j	int
<=	O
to	int
;	O
j	int
++	O
)	O
{	O
c	char
=	O
(	O
unsigned	O
char	O
)	O
*	O
im	pointer
++	O
;	O
cf	int
=	O
(	O
unsigned	O
char	O
)	O
*	O
fo	pointer
++	O
;	O
cfx	int
=	O
(	O
unsigned	O
char	O
)	O
*	O
fox	pointer
++	O
;	O
if	O
(	O
fore	pointer
->	O
w_encoding	O
==	O
UTF8	int
)	O
{	O
c	char
|=	O
cf	int
<<	O
8	int
|	O
cfx	int
<<	O
16	int
;	O
if	O
(	O
c	char
==	O
UCS_HIDDEN	int
)	O
continue	O
;	O
c	char
=	O
ToUtf8_comb	function
(	O
pt	pointer
,	O
c	char
)	O
;	O
l	int
+=	O
c	char
;	O
if	O
(	O
pt	pointer
)	O
pt	pointer
+=	O
c	char
;	O
continue	O
;	O
}	O
if	O
(	O
is_dw_font	O
(	O
cf	int
)	O
)	O
{	O
c	char
=	O
c	char
<<	O
8	int
|	O
(	O
unsigned	O
char	O
)	O
*	O
im	pointer
++	O
;	O
fo	pointer
++	O
;	O
j	int
++	O
;	O
}	O
if	O
(	O
pastefont	int
)	O
{	O
c	char
=	O
EncodeChar	function
(	O
pt	pointer
,	O
c	char
|	O
cf	int
<<	O
16	int
,	O
fore	pointer
->	O
w_encoding	O
,	O
&	O
font	char
)	O
;	O
l	int
+=	O
c	char
;	O
if	O
(	O
pt	pointer
)	O
pt	pointer
+=	O
c	char
;	O
continue	O
;	O
}	O
if	O
(	O
pt	pointer
)	O
*	O
pt	pointer
++	O
=	O
c	char
;	O
l	int
++	O
;	O
}	O
if	O
(	O
pastefont	int
&&	O
font	char
!=	O
ASCII	int
)	O
{	O
if	O
(	O
pt	pointer
)	O
{	O
strcpy	function
(	O
pt	pointer
,	O
"\033(B"	pointer
)	O
;	O
pt	pointer
+=	O
3	int
;	O
}	O
l	int
+=	O
3	int
;	O
}	O
if	O
(	O
i	pointer
!=	O
y2	int
&&	O
(	O
to	int
!=	O
fore	pointer
->	O
w_width	O
-	O
1	int
||	O
ml	pointer
->	O
image	char
[	O
to	int
+	O
1	int
]	O
==	O
' '	O
)	O
)	O
{	O
switch	O
(	O
markdata	struct
->	O
nonl	int
)	O
{	O
case	O
0	int
:	O
if	O
(	O
pt	pointer
)	O
*	O
pt	pointer
++	O
=	O
'\r'	O
;	O
l	int
++	O
;	O
if	O
(	O
join_with_cr	int
)	O
{	O
if	O
(	O
pt	pointer
)	O
*	O
pt	pointer
++	O
=	O
'\n'	O
;	O
l	int
++	O
;	O
}	O
break	O
;	O
case	O
1	int
:	O
break	O
;	O
case	O
2	int
:	O
if	O
(	O
pt	pointer
)	O
*	O
pt	pointer
++	O
=	O
' '	O
;	O
l	int
++	O
;	O
break	O
;	O
case	O
3	int
:	O
if	O
(	O
pt	pointer
)	O
*	O
pt	pointer
++	O
=	O
','	O
;	O
l	int
++	O
;	O
break	O
;	O
}	O
}	O
}	O
return	O
l	int
;	O
}	O
static	O
int	O
eq	function
(	O
a	int
,	O
b	int
)	O
int	O
a	int
,	O
b	int
;	O
{	O
if	O
(	O
a	int
==	O
b	int
)	O
return	O
1	int
;	O
if	O
(	O
a	int
==	O
0	int
||	O
b	int
==	O
0	int
)	O
return	O
1	int
;	O
if	O
(	O
a	int
<=	O
'9'	O
&&	O
a	int
>=	O
'0'	O
&&	O
b	int
<=	O
'9'	O
&&	O
b	int
>=	O
'0'	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
GetHistory	function
(	O
)	O
{	O
int	O
i	pointer
=	O
0	int
,	O
q	int
=	O
0	int
,	O
xx	int
,	O
yy	int
,	O
x	int
,	O
y	int
;	O
unsigned	O
char	O
*	O
linep	pointer
;	O
struct	O
mline	struct
*	O
ml	pointer
;	O
ASSERT	O
(	O
display	struct
&&	O
fore	pointer
)	O
;	O
x	int
=	O
fore	pointer
->	O
w_x	O
;	O
if	O
(	O
x	int
>=	O
fore	pointer
->	O
w_width	O
)	O
x	int
=	O
fore	pointer
->	O
w_width	O
-	O
1	int
;	O
y	int
=	O
fore	pointer
->	O
w_y	O
+	O
fore	pointer
->	O
w_histheight	int
;	O
debug2	O
(	O
"cursor is at x=%d, y=%d\n"	pointer
,	O
x	int
,	O
y	int
)	O
;	O
ml	pointer
=	O
WIN	O
(	O
y	int
)	O
;	O
for	O
(	O
xx	int
=	O
x	int
-	O
1	int
,	O
linep	pointer
=	O
ml	pointer
->	O
image	char
+	O
xx	int
;	O
xx	int
>=	O
0	int
;	O
xx	int
--	O
)	O
if	O
(	O
(	O
q	int
=	O
*	O
linep	pointer
--	O
)	O
!=	O
' '	O
)	O
break	O
;	O
debug3	O
(	O
"%c at (%d,%d)\n"	pointer
,	O
q	int
,	O
xx	int
,	O
y	int
)	O
;	O
for	O
(	O
yy	int
=	O
y	int
-	O
1	int
;	O
yy	int
>=	O
0	int
;	O
yy	int
--	O
)	O
{	O
ml	pointer
=	O
WIN	O
(	O
yy	int
)	O
;	O
linep	pointer
=	O
ml	pointer
->	O
image	char
;	O
if	O
(	O
xx	int
<	O
0	int
||	O
eq	function
(	O
linep	pointer
[	O
xx	int
]	O
,	O
q	int
)	O
)	O
{	O
for	O
(	O
i	pointer
=	O
fore	pointer
->	O
w_width	O
-	O
1	int
,	O
linep	pointer
+=	O
i	pointer
;	O
i	pointer
>=	O
x	int
;	O
i	pointer
--	O
)	O
if	O
(	O
*	O
linep	pointer
--	O
!=	O
' '	O
)	O
break	O
;	O
if	O
(	O
i	pointer
>=	O
x	int
)	O
break	O
;	O
}	O
}	O
if	O
(	O
yy	int
<	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
D_user	O
->	O
u_plop	struct
.	O
buf	pointer
)	O
UserFreeCopyBuffer	function
(	O
D_user	O
)	O
;	O
if	O
(	O
(	O
D_user	O
->	O
u_plop	struct
.	O
buf	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
(	O
unsigned	O
)	O
(	O
i	pointer
-	O
x	int
+	O
2	int
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
LMsg	function
(	O
0	int
,	O
"Not enough memory... Sorry."	pointer
)	O
;	O
return	O
0	int
;	O
}	O
bcopy	function
(	O
(	O
char	O
*	O
)	O
linep	pointer
-	O
i	pointer
+	O
x	int
+	O
1	int
,	O
D_user	O
->	O
u_plop	struct
.	O
buf	pointer
,	O
i	pointer
-	O
x	int
+	O
1	int
)	O
;	O
D_user	O
->	O
u_plop	struct
.	O
len	int
=	O
i	pointer
-	O
x	int
+	O
1	int
;	O
D_user	O
->	O
u_plop	struct
.	O
enc	int
=	O
fore	pointer
->	O
w_encoding	O
;	O
return	O
1	int
;	O
}	O
void	O
MarkRoutine	function
(	O
)	O
{	O
int	O
x	int
,	O
y	int
;	O
ASSERT	O
(	O
fore	pointer
&&	O
display	struct
&&	O
D_user	O
)	O
;	O
debug2	O
(	O
"MarkRoutine called: fore nr %d, display %s\n"	pointer
,	O
fore	pointer
->	O
w_number	int
,	O
D_usertty	O
)	O
;	O
if	O
(	O
InitOverlayPage	function
(	O
sizeof	O
(	O
*	O
markdata	struct
)	O
,	O
&	O
MarkLf	struct
,	O
1	int
)	O
)	O
return	O
;	O
flayer	pointer
->	O
l_encoding	int
=	O
fore	pointer
->	O
w_encoding	O
;	O
flayer	pointer
->	O
l_mode	int
=	O
1	int
;	O
markdata	struct
=	O
(	O
struct	O
markdata	struct
*	O
)	O
flayer	pointer
->	O
l_data	pointer
;	O
markdata	struct
->	O
md_user	pointer
=	O
D_user	O
;	O
markdata	struct
->	O
md_window	pointer
=	O
fore	pointer
;	O
markdata	struct
->	O
second	int
=	O
0	int
;	O
markdata	struct
->	O
rep_cnt	int
=	O
0	int
;	O
markdata	struct
->	O
append_mode	int
=	O
0	int
;	O
markdata	struct
->	O
write_buffer	int
=	O
0	int
;	O
markdata	struct
->	O
nonl	int
=	O
0	int
;	O
markdata	struct
->	O
left_mar	int
=	O
0	int
;	O
markdata	struct
->	O
right_mar	int
=	O
fore	pointer
->	O
w_width	O
-	O
1	int
;	O
markdata	struct
->	O
hist_offset	int
=	O
fore	pointer
->	O
w_histheight	int
;	O
x	int
=	O
fore	pointer
->	O
w_x	O
;	O
y	int
=	O
D2W	O
(	O
fore	pointer
->	O
w_y	O
)	O
;	O
if	O
(	O
x	int
>=	O
fore	pointer
->	O
w_width	O
)	O
x	int
=	O
fore	pointer
->	O
w_width	O
-	O
1	int
;	O
LGotoPos	function
(	O
flayer	pointer
,	O
x	int
,	O
W2D	O
(	O
y	int
)	O
)	O
;	O
LMsg	function
(	O
0	int
,	O
"Copy mode - Column %d Line %d(+%d) (%d,%d)"	pointer
,	O
x	int
+	O
1	int
,	O
W2D	O
(	O
y	int
+	O
1	int
)	O
,	O
fore	pointer
->	O
w_histheight	int
,	O
fore	pointer
->	O
w_width	O
,	O
fore	pointer
->	O
w_height	O
)	O
;	O
markdata	struct
->	O
cx	int
=	O
markdata	struct
->	O
x1	int
=	O
x	int
;	O
markdata	struct
->	O
cy	int
=	O
markdata	struct
->	O
y1	int
=	O
y	int
;	O
flayer	pointer
->	O
l_x	int
=	O
x	int
;	O
flayer	pointer
->	O
l_y	int
=	O
W2D	O
(	O
y	int
)	O
;	O
}	O
static	O
void	O
MarkProcess	function
(	O
inbufp	pointer
,	O
inlenp	pointer
)	O
char	O
*	O
*	O
inbufp	pointer
;	O
int	O
*	O
inlenp	pointer
;	O
{	O
char	O
*	O
inbuf	pointer
,	O
*	O
pt	pointer
;	O
int	O
inlen	int
;	O
int	O
cx	int
,	O
cy	int
,	O
x2	int
,	O
y2	int
,	O
j	int
,	O
yend	int
;	O
int	O
newcopylen	int
=	O
0	int
,	O
od	int
;	O
int	O
in_mark	int
;	O
int	O
rep_cnt	int
;	O
struct	O
acluser	struct
*	O
md_user	pointer
;	O
markdata	struct
=	O
(	O
struct	O
markdata	struct
*	O
)	O
flayer	pointer
->	O
l_data	pointer
;	O
fore	pointer
=	O
markdata	struct
->	O
md_window	pointer
;	O
md_user	pointer
=	O
markdata	struct
->	O
md_user	pointer
;	O
if	O
(	O
inbufp	pointer
==	O
0	int
)	O
{	O
MarkAbort	function
(	O
)	O
;	O
return	O
;	O
}	O
LGotoPos	function
(	O
flayer	pointer
,	O
markdata	struct
->	O
cx	int
,	O
W2D	O
(	O
markdata	struct
->	O
cy	int
)	O
)	O
;	O
inbuf	pointer
=	O
*	O
inbufp	pointer
;	O
inlen	int
=	O
*	O
inlenp	pointer
;	O
pt	pointer
=	O
inbuf	pointer
;	O
in_mark	int
=	O
1	int
;	O
while	O
(	O
in_mark	int
&&	O
(	O
inlen	int
)	O
)	O
{	O
unsigned	O
char	O
ch	char
=	O
(	O
unsigned	O
char	O
)	O
*	O
pt	pointer
++	O
;	O
inlen	int
--	O
;	O
if	O
(	O
flayer	pointer
->	O
l_mouseevent	struct
.	O
start	int
)	O
{	O
int	O
r	int
=	O
LayProcessMouse	function
(	O
flayer	pointer
,	O
ch	char
)	O
;	O
if	O
(	O
r	int
==	O
-	O
1	int
)	O
LayProcessMouseSwitch	function
(	O
flayer	pointer
,	O
0	int
)	O
;	O
else	O
{	O
if	O
(	O
r	int
)	O
ch	char
=	O
0222	int
;	O
else	O
continue	O
;	O
}	O
}	O
od	int
=	O
mark_key_tab	array
[	O
(	O
int	O
)	O
ch	char
]	O
;	O
rep_cnt	int
=	O
markdata	struct
->	O
rep_cnt	int
;	O
if	O
(	O
od	int
>=	O
'0'	O
&&	O
od	int
<=	O
'9'	O
&&	O
!	O
markdata	struct
->	O
f_cmd	struct
.	O
flag	int
)	O
{	O
if	O
(	O
rep_cnt	int
<	O
1001	int
&&	O
(	O
od	int
!=	O
'0'	O
||	O
rep_cnt	int
!=	O
0	int
)	O
)	O
{	O
markdata	struct
->	O
rep_cnt	int
=	O
10	int
*	O
rep_cnt	int
+	O
od	int
-	O
'0'	O
;	O
continue	O
;	O
}	O
}	O
cx	int
=	O
markdata	struct
->	O
cx	int
;	O
cy	int
=	O
markdata	struct
->	O
cy	int
;	O
if	O
(	O
markdata	struct
->	O
f_cmd	struct
.	O
flag	int
)	O
{	O
debug2	O
(	O
"searching for %c:%d\n"	pointer
,	O
od	int
,	O
rep_cnt	int
)	O
;	O
markdata	struct
->	O
f_cmd	struct
.	O
flag	int
=	O
0	int
;	O
markdata	struct
->	O
rep_cnt	int
=	O
0	int
;	O
if	O
(	O
isgraph	function
(	O
od	int
)	O
)	O
{	O
markdata	struct
->	O
f_cmd	struct
.	O
target	int
=	O
od	int
;	O
rep_cnt	int
=	O
(	O
rep_cnt	int
)	O
?	O
rep_cnt	int
:	O
1	int
;	O
nextchar	function
(	O
&	O
cx	int
,	O
&	O
cy	int
,	O
markdata	struct
->	O
f_cmd	struct
.	O
direction	int
,	O
od	int
,	O
rep_cnt	int
)	O
;	O
revto	function
(	O
cx	int
,	O
cy	int
)	O
;	O
continue	O
;	O
}	O
}	O
processchar	O
:	O
switch	O
(	O
od	int
)	O
{	O
case	O
'f'	O
:	O
case	O
'F'	O
:	O
case	O
't'	O
:	O
case	O
'T'	O
:	O
markdata	struct
->	O
f_cmd	struct
.	O
flag	int
=	O
1	int
;	O
markdata	struct
->	O
f_cmd	struct
.	O
direction	int
=	O
od	int
;	O
debug	O
(	O
"entering char search\n"	pointer
)	O
;	O
continue	O
;	O
case	O
';'	O
:	O
case	O
','	O
:	O
if	O
(	O
!	O
markdata	struct
->	O
f_cmd	struct
.	O
target	int
)	O
break	O
;	O
if	O
(	O
!	O
rep_cnt	int
)	O
rep_cnt	int
=	O
1	int
;	O
nextchar	function
(	O
&	O
cx	int
,	O
&	O
cy	int
,	O
od	int
==	O
';'	O
?	O
markdata	struct
->	O
f_cmd	struct
.	O
direction	int
:	O
(	O
markdata	struct
->	O
f_cmd	struct
.	O
direction	int
^	O
0x20	int
)	O
,	O
markdata	struct
->	O
f_cmd	struct
.	O
target	int
,	O
rep_cnt	int
)	O
;	O
revto	function
(	O
cx	int
,	O
cy	int
)	O
;	O
break	O
;	O
case	O
'o'	O
:	O
case	O
'x'	O
:	O
if	O
(	O
!	O
markdata	struct
->	O
second	int
)	O
break	O
;	O
markdata	struct
->	O
cx	int
=	O
markdata	struct
->	O
x1	int
;	O
markdata	struct
->	O
cy	int
=	O
markdata	struct
->	O
y1	int
;	O
markdata	struct
->	O
x1	int
=	O
cx	int
;	O
markdata	struct
->	O
y1	int
=	O
cy	int
;	O
revto	function
(	O
markdata	struct
->	O
cx	int
,	O
markdata	struct
->	O
cy	int
)	O
;	O
break	O
;	O
case	O
'\014'	O
:	O
Redisplay	function
(	O
0	int
)	O
;	O
LGotoPos	function
(	O
flayer	pointer
,	O
cx	int
,	O
W2D	O
(	O
cy	int
)	O
)	O
;	O
break	O
;	O
case	O
0202	int
:	O
case	O
'\010'	O
:	O
case	O
'h'	O
:	O
if	O
(	O
rep_cnt	int
==	O
0	int
)	O
rep_cnt	int
=	O
1	int
;	O
revto	function
(	O
cx	int
-	O
rep_cnt	int
,	O
cy	int
)	O
;	O
break	O
;	O
case	O
0216	int
:	O
case	O
'\016'	O
:	O
case	O
'j'	O
:	O
if	O
(	O
rep_cnt	int
==	O
0	int
)	O
rep_cnt	int
=	O
1	int
;	O
revto	function
(	O
cx	int
,	O
cy	int
+	O
rep_cnt	int
)	O
;	O
break	O
;	O
case	O
'+'	O
:	O
if	O
(	O
rep_cnt	int
==	O
0	int
)	O
rep_cnt	int
=	O
1	int
;	O
j	int
=	O
cy	int
+	O
rep_cnt	int
;	O
if	O
(	O
j	int
>	O
fore	pointer
->	O
w_histheight	int
+	O
fore	pointer
->	O
w_height	O
-	O
1	int
)	O
j	int
=	O
fore	pointer
->	O
w_histheight	int
+	O
fore	pointer
->	O
w_height	O
-	O
1	int
;	O
revto	function
(	O
linestart	function
(	O
j	int
)	O
,	O
j	int
)	O
;	O
break	O
;	O
case	O
'-'	O
:	O
if	O
(	O
rep_cnt	int
==	O
0	int
)	O
rep_cnt	int
=	O
1	int
;	O
cy	int
-=	O
rep_cnt	int
;	O
if	O
(	O
cy	int
<	O
0	int
)	O
cy	int
=	O
0	int
;	O
revto	function
(	O
linestart	function
(	O
cy	int
)	O
,	O
cy	int
)	O
;	O
break	O
;	O
case	O
'^'	O
:	O
revto	function
(	O
linestart	function
(	O
cy	int
)	O
,	O
cy	int
)	O
;	O
break	O
;	O
case	O
'\n'	O
:	O
revto	function
(	O
markdata	struct
->	O
left_mar	int
,	O
cy	int
+	O
1	int
)	O
;	O
break	O
;	O
case	O
0220	int
:	O
case	O
'\020'	O
:	O
case	O
'k'	O
:	O
if	O
(	O
rep_cnt	int
==	O
0	int
)	O
rep_cnt	int
=	O
1	int
;	O
revto	function
(	O
cx	int
,	O
cy	int
-	O
rep_cnt	int
)	O
;	O
break	O
;	O
case	O
0206	int
:	O
case	O
'l'	O
:	O
if	O
(	O
rep_cnt	int
==	O
0	int
)	O
rep_cnt	int
=	O
1	int
;	O
revto	function
(	O
cx	int
+	O
rep_cnt	int
,	O
cy	int
)	O
;	O
break	O
;	O
case	O
'\001'	O
:	O
case	O
'0'	O
:	O
revto	function
(	O
markdata	struct
->	O
left_mar	int
,	O
cy	int
)	O
;	O
break	O
;	O
case	O
'\004'	O
:	O
if	O
(	O
rep_cnt	int
==	O
0	int
)	O
rep_cnt	int
=	O
(	O
fore	pointer
->	O
w_height	O
+	O
1	int
)	O
>>	O
1	int
;	O
revto_line	function
(	O
cx	int
,	O
cy	int
+	O
rep_cnt	int
,	O
W2D	O
(	O
cy	int
)	O
)	O
;	O
break	O
;	O
case	O
'$'	O
:	O
revto	function
(	O
lineend	function
(	O
cy	int
)	O
,	O
cy	int
)	O
;	O
break	O
;	O
case	O
'\022'	O
:	O
ISearch	function
(	O
-	O
1	int
)	O
;	O
in_mark	int
=	O
0	int
;	O
break	O
;	O
case	O
'\023'	O
:	O
ISearch	function
(	O
1	int
)	O
;	O
in_mark	int
=	O
0	int
;	O
break	O
;	O
case	O
'\025'	O
:	O
if	O
(	O
rep_cnt	int
==	O
0	int
)	O
rep_cnt	int
=	O
(	O
fore	pointer
->	O
w_height	O
+	O
1	int
)	O
>>	O
1	int
;	O
revto_line	function
(	O
cx	int
,	O
cy	int
-	O
rep_cnt	int
,	O
W2D	O
(	O
cy	int
)	O
)	O
;	O
break	O
;	O
case	O
'\007'	O
:	O
if	O
(	O
markdata	struct
->	O
left_mar	int
==	O
0	int
&&	O
markdata	struct
->	O
right_mar	int
==	O
fore	pointer
->	O
w_width	O
-	O
1	int
)	O
LMsg	function
(	O
0	int
,	O
"Column %d Line %d(+%d)"	pointer
,	O
cx	int
+	O
1	int
,	O
W2D	O
(	O
cy	int
)	O
+	O
1	int
,	O
markdata	struct
->	O
hist_offset	int
)	O
;	O
else	O
LMsg	function
(	O
0	int
,	O
"Column %d(%d..%d) Line %d(+%d)"	pointer
,	O
cx	int
+	O
1	int
,	O
markdata	struct
->	O
left_mar	int
+	O
1	int
,	O
markdata	struct
->	O
right_mar	int
+	O
1	int
,	O
W2D	O
(	O
cy	int
)	O
+	O
1	int
,	O
markdata	struct
->	O
hist_offset	int
)	O
;	O
break	O
;	O
case	O
'\002'	O
:	O
if	O
(	O
rep_cnt	int
==	O
0	int
)	O
rep_cnt	int
=	O
1	int
;	O
rep_cnt	int
*=	O
fore	pointer
->	O
w_height	O
;	O
revto	function
(	O
cx	int
,	O
cy	int
-	O
rep_cnt	int
)	O
;	O
break	O
;	O
case	O
'\006'	O
:	O
if	O
(	O
rep_cnt	int
==	O
0	int
)	O
rep_cnt	int
=	O
1	int
;	O
rep_cnt	int
*=	O
fore	pointer
->	O
w_height	O
;	O
revto	function
(	O
cx	int
,	O
cy	int
+	O
rep_cnt	int
)	O
;	O
break	O
;	O
case	O
'\005'	O
:	O
if	O
(	O
rep_cnt	int
==	O
0	int
)	O
rep_cnt	int
=	O
1	int
;	O
rep_cnt	int
=	O
MarkScrollUpDisplay	function
(	O
rep_cnt	int
)	O
;	O
if	O
(	O
cy	int
<	O
D2W	O
(	O
0	int
)	O
)	O
revto	function
(	O
cx	int
,	O
D2W	O
(	O
0	int
)	O
)	O
;	O
else	O
LGotoPos	function
(	O
flayer	pointer
,	O
cx	int
,	O
W2D	O
(	O
cy	int
)	O
)	O
;	O
break	O
;	O
case	O
'\031'	O
:	O
if	O
(	O
rep_cnt	int
==	O
0	int
)	O
rep_cnt	int
=	O
1	int
;	O
rep_cnt	int
=	O
MarkScrollDownDisplay	function
(	O
rep_cnt	int
)	O
;	O
if	O
(	O
cy	int
>	O
D2W	O
(	O
fore	pointer
->	O
w_height	O
-	O
1	int
)	O
)	O
revto	function
(	O
cx	int
,	O
D2W	O
(	O
fore	pointer
->	O
w_height	O
-	O
1	int
)	O
)	O
;	O
else	O
LGotoPos	function
(	O
flayer	pointer
,	O
cx	int
,	O
W2D	O
(	O
cy	int
)	O
)	O
;	O
break	O
;	O
case	O
'@'	O
:	O
break	O
;	O
case	O
'%'	O
:	O
if	O
(	O
rep_cnt	int
<	O
0	int
)	O
rep_cnt	int
=	O
0	int
;	O
if	O
(	O
rep_cnt	int
>	O
100	int
)	O
rep_cnt	int
=	O
100	int
;	O
revto_line	function
(	O
markdata	struct
->	O
left_mar	int
,	O
fore	pointer
->	O
w_histheight	int
-	O
fore	pointer
->	O
w_scrollback_height	int
+	O
(	O
int	O
)	O
(	O
rep_cnt	int
*	O
(	O
fore	pointer
->	O
w_scrollback_height	int
+	O
fore	pointer
->	O
w_height	O
)	O
/	O
100.0	int
)	O
,	O
(	O
fore	pointer
->	O
w_height	O
-	O
1	int
)	O
/	O
2	int
)	O
;	O
break	O
;	O
case	O
0201	int
:	O
case	O
'g'	O
:	O
rep_cnt	int
=	O
1	int
;	O
case	O
0205	int
:	O
case	O
'G'	O
:	O
if	O
(	O
rep_cnt	int
==	O
0	int
)	O
rep_cnt	int
=	O
fore	pointer
->	O
w_histheight	int
+	O
fore	pointer
->	O
w_height	O
;	O
revto_line	function
(	O
markdata	struct
->	O
left_mar	int
,	O
--	O
rep_cnt	int
,	O
(	O
fore	pointer
->	O
w_height	O
-	O
1	int
)	O
/	O
2	int
)	O
;	O
break	O
;	O
case	O
'H'	O
:	O
revto	function
(	O
markdata	struct
->	O
left_mar	int
,	O
D2W	O
(	O
0	int
)	O
)	O
;	O
break	O
;	O
case	O
'M'	O
:	O
revto	function
(	O
markdata	struct
->	O
left_mar	int
,	O
D2W	O
(	O
(	O
fore	pointer
->	O
w_height	O
-	O
1	int
)	O
/	O
2	int
)	O
)	O
;	O
break	O
;	O
case	O
'L'	O
:	O
revto	function
(	O
markdata	struct
->	O
left_mar	int
,	O
D2W	O
(	O
fore	pointer
->	O
w_height	O
-	O
1	int
)	O
)	O
;	O
break	O
;	O
case	O
'|'	O
:	O
revto	function
(	O
--	O
rep_cnt	int
,	O
cy	int
)	O
;	O
break	O
;	O
case	O
'w'	O
:	O
if	O
(	O
rep_cnt	int
==	O
0	int
)	O
rep_cnt	int
=	O
1	int
;	O
nextword	function
(	O
&	O
cx	int
,	O
&	O
cy	int
,	O
NW_MUSTMOVE	O
,	O
rep_cnt	int
)	O
;	O
revto	function
(	O
cx	int
,	O
cy	int
)	O
;	O
break	O
;	O
case	O
'e'	O
:	O
case	O
'E'	O
:	O
if	O
(	O
rep_cnt	int
==	O
0	int
)	O
rep_cnt	int
=	O
1	int
;	O
nextword	function
(	O
&	O
cx	int
,	O
&	O
cy	int
,	O
NW_ENDOFWORD	O
|	O
NW_MUSTMOVE	O
|	O
(	O
od	int
==	O
'E'	O
?	O
NW_BIG	O
:	O
0	int
)	O
,	O
rep_cnt	int
)	O
;	O
revto	function
(	O
cx	int
,	O
cy	int
)	O
;	O
break	O
;	O
case	O
'b'	O
:	O
case	O
'B'	O
:	O
if	O
(	O
rep_cnt	int
==	O
0	int
)	O
rep_cnt	int
=	O
1	int
;	O
nextword	function
(	O
&	O
cx	int
,	O
&	O
cy	int
,	O
NW_BACK	O
|	O
NW_ENDOFWORD	O
|	O
NW_MUSTMOVE	O
|	O
(	O
od	int
==	O
'B'	O
?	O
NW_BIG	O
:	O
0	int
)	O
,	O
rep_cnt	int
)	O
;	O
revto	function
(	O
cx	int
,	O
cy	int
)	O
;	O
break	O
;	O
case	O
'a'	O
:	O
markdata	struct
->	O
append_mode	int
=	O
1	int
-	O
markdata	struct
->	O
append_mode	int
;	O
debug1	O
(	O
"append mode %d--\n"	pointer
,	O
markdata	struct
->	O
append_mode	int
)	O
;	O
LMsg	function
(	O
0	int
,	O
(	O
markdata	struct
->	O
append_mode	int
)	O
?	O
":set append"	pointer
:	O
":set noappend"	pointer
)	O
;	O
break	O
;	O
case	O
'v'	O
:	O
case	O
'V'	O
:	O
if	O
(	O
markdata	struct
->	O
left_mar	int
==	O
8	int
)	O
rep_cnt	int
=	O
1	int
;	O
else	O
rep_cnt	int
=	O
9	int
;	O
case	O
'c'	O
:	O
case	O
'C'	O
:	O
if	O
(	O
markdata	struct
->	O
second	int
)	O
{	O
rem	int
(	O
markdata	struct
->	O
x1	int
,	O
markdata	struct
->	O
y1	int
,	O
cx	int
,	O
cy	int
,	O
1	int
,	O
(	O
char	O
*	O
)	O
0	int
,	O
fore	pointer
->	O
w_height	O
-	O
1	int
)	O
;	O
markdata	struct
->	O
second	int
=	O
1	int
;	O
}	O
rep_cnt	int
--	O
;	O
if	O
(	O
rep_cnt	int
<	O
0	int
)	O
rep_cnt	int
=	O
cx	int
;	O
if	O
(	O
od	int
!=	O
'C'	O
)	O
{	O
markdata	struct
->	O
left_mar	int
=	O
rep_cnt	int
;	O
if	O
(	O
markdata	struct
->	O
left_mar	int
>	O
markdata	struct
->	O
right_mar	int
)	O
markdata	struct
->	O
left_mar	int
=	O
markdata	struct
->	O
right_mar	int
;	O
}	O
else	O
{	O
markdata	struct
->	O
right_mar	int
=	O
rep_cnt	int
;	O
if	O
(	O
markdata	struct
->	O
left_mar	int
>	O
markdata	struct
->	O
right_mar	int
)	O
markdata	struct
->	O
right_mar	int
=	O
markdata	struct
->	O
left_mar	int
;	O
}	O
if	O
(	O
markdata	struct
->	O
second	int
)	O
{	O
markdata	struct
->	O
cx	int
=	O
markdata	struct
->	O
x1	int
;	O
markdata	struct
->	O
cy	int
=	O
markdata	struct
->	O
y1	int
;	O
revto	function
(	O
cx	int
,	O
cy	int
)	O
;	O
}	O
if	O
(	O
od	int
==	O
'v'	O
||	O
od	int
==	O
'V'	O
)	O
LMsg	function
(	O
0	int
,	O
(	O
markdata	struct
->	O
left_mar	int
!=	O
8	int
)	O
?	O
":set nonu"	pointer
:	O
":set nu"	pointer
)	O
;	O
break	O
;	O
case	O
'J'	O
:	O
markdata	struct
->	O
nonl	int
=	O
(	O
markdata	struct
->	O
nonl	int
+	O
1	int
)	O
%	O
4	int
;	O
switch	O
(	O
markdata	struct
->	O
nonl	int
)	O
{	O
case	O
0	int
:	O
if	O
(	O
join_with_cr	int
)	O
LMsg	function
(	O
0	int
,	O
"Multiple lines (CR/LF)"	pointer
)	O
;	O
else	O
LMsg	function
(	O
0	int
,	O
"Multiple lines (LF)"	pointer
)	O
;	O
break	O
;	O
case	O
1	int
:	O
LMsg	function
(	O
0	int
,	O
"Lines joined"	pointer
)	O
;	O
break	O
;	O
case	O
2	int
:	O
LMsg	function
(	O
0	int
,	O
"Lines joined with blanks"	pointer
)	O
;	O
break	O
;	O
case	O
3	int
:	O
LMsg	function
(	O
0	int
,	O
"Lines joined with comma"	pointer
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
'/'	O
:	O
Search	function
(	O
1	int
)	O
;	O
in_mark	int
=	O
0	int
;	O
break	O
;	O
case	O
'?'	O
:	O
Search	function
(	O
-	O
1	int
)	O
;	O
in_mark	int
=	O
0	int
;	O
break	O
;	O
case	O
'n'	O
:	O
Search	function
(	O
0	int
)	O
;	O
break	O
;	O
case	O
'N'	O
:	O
markdata	struct
->	O
isdir	int
=	O
-	O
markdata	struct
->	O
isdir	int
;	O
Search	function
(	O
0	int
)	O
;	O
markdata	struct
->	O
isdir	int
=	O
-	O
markdata	struct
->	O
isdir	int
;	O
break	O
;	O
case	O
'y'	O
:	O
case	O
'Y'	O
:	O
if	O
(	O
markdata	struct
->	O
second	int
==	O
0	int
)	O
{	O
revto	function
(	O
linestart	function
(	O
cy	int
)	O
,	O
cy	int
)	O
;	O
markdata	struct
->	O
second	int
++	O
;	O
cx	int
=	O
markdata	struct
->	O
x1	int
=	O
markdata	struct
->	O
cx	int
;	O
cy	int
=	O
markdata	struct
->	O
y1	int
=	O
markdata	struct
->	O
cy	int
;	O
}	O
if	O
(	O
--	O
rep_cnt	int
>	O
0	int
)	O
revto	function
(	O
cx	int
,	O
cy	int
+	O
rep_cnt	int
)	O
;	O
revto	function
(	O
lineend	function
(	O
markdata	struct
->	O
cy	int
)	O
,	O
markdata	struct
->	O
cy	int
)	O
;	O
if	O
(	O
od	int
==	O
'y'	O
)	O
break	O
;	O
case	O
'W'	O
:	O
if	O
(	O
od	int
==	O
'W'	O
)	O
{	O
if	O
(	O
rep_cnt	int
==	O
0	int
)	O
rep_cnt	int
=	O
1	int
;	O
if	O
(	O
!	O
markdata	struct
->	O
second	int
)	O
{	O
nextword	function
(	O
&	O
cx	int
,	O
&	O
cy	int
,	O
NW_BACK	O
|	O
NW_ENDOFWORD	O
,	O
1	int
)	O
;	O
revto	function
(	O
cx	int
,	O
cy	int
)	O
;	O
markdata	struct
->	O
second	int
++	O
;	O
cx	int
=	O
markdata	struct
->	O
x1	int
=	O
markdata	struct
->	O
cx	int
;	O
cy	int
=	O
markdata	struct
->	O
y1	int
=	O
markdata	struct
->	O
cy	int
;	O
}	O
nextword	function
(	O
&	O
cx	int
,	O
&	O
cy	int
,	O
NW_ENDOFWORD	O
,	O
rep_cnt	int
)	O
;	O
revto	function
(	O
cx	int
,	O
cy	int
)	O
;	O
}	O
cx	int
=	O
markdata	struct
->	O
cx	int
;	O
cy	int
=	O
markdata	struct
->	O
cy	int
;	O
case	O
'A'	O
:	O
if	O
(	O
od	int
==	O
'A'	O
)	O
markdata	struct
->	O
append_mode	int
=	O
1	int
;	O
case	O
'>'	O
:	O
if	O
(	O
od	int
==	O
'>'	O
)	O
markdata	struct
->	O
write_buffer	int
=	O
1	int
;	O
case	O
' '	O
:	O
case	O
'\r'	O
:	O
if	O
(	O
!	O
markdata	struct
->	O
second	int
)	O
{	O
markdata	struct
->	O
second	int
++	O
;	O
markdata	struct
->	O
x1	int
=	O
cx	int
;	O
markdata	struct
->	O
y1	int
=	O
cy	int
;	O
revto	function
(	O
cx	int
,	O
cy	int
)	O
;	O
LMsg	function
(	O
0	int
,	O
"First mark set - Column %d Line %d"	pointer
,	O
cx	int
+	O
1	int
,	O
W2D	O
(	O
cy	int
)	O
+	O
1	int
)	O
;	O
break	O
;	O
}	O
else	O
{	O
int	O
append_mode	int
=	O
markdata	struct
->	O
append_mode	int
;	O
int	O
write_buffer	int
=	O
markdata	struct
->	O
write_buffer	int
;	O
x2	int
=	O
cx	int
;	O
y2	int
=	O
cy	int
;	O
newcopylen	int
=	O
rem	int
(	O
markdata	struct
->	O
x1	int
,	O
markdata	struct
->	O
y1	int
,	O
x2	int
,	O
y2	int
,	O
2	int
,	O
(	O
char	O
*	O
)	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
md_user	pointer
->	O
u_plop	struct
.	O
buf	pointer
&&	O
!	O
append_mode	int
)	O
UserFreeCopyBuffer	function
(	O
md_user	pointer
)	O
;	O
yend	int
=	O
fore	pointer
->	O
w_height	O
-	O
1	int
;	O
if	O
(	O
fore	pointer
->	O
w_histheight	int
-	O
markdata	struct
->	O
hist_offset	int
<	O
fore	pointer
->	O
w_height	O
)	O
{	O
markdata	struct
->	O
second	int
=	O
0	int
;	O
yend	int
-=	O
MarkScrollUpDisplay	function
(	O
fore	pointer
->	O
w_histheight	int
-	O
markdata	struct
->	O
hist_offset	int
)	O
;	O
}	O
if	O
(	O
newcopylen	int
>	O
0	int
)	O
{	O
if	O
(	O
md_user	pointer
->	O
u_plop	struct
.	O
buf	pointer
)	O
md_user	pointer
->	O
u_plop	struct
.	O
buf	pointer
=	O
realloc	function
(	O
md_user	pointer
->	O
u_plop	struct
.	O
buf	pointer
,	O
(	O
unsigned	O
)	O
(	O
md_user	pointer
->	O
u_plop	struct
.	O
len	int
+	O
newcopylen	int
+	O
3	int
)	O
)	O
;	O
else	O
{	O
md_user	pointer
->	O
u_plop	struct
.	O
len	int
=	O
0	int
;	O
md_user	pointer
->	O
u_plop	struct
.	O
buf	pointer
=	O
malloc	function
(	O
(	O
unsigned	O
)	O
(	O
newcopylen	int
+	O
3	int
)	O
)	O
;	O
}	O
if	O
(	O
!	O
md_user	pointer
->	O
u_plop	struct
.	O
buf	pointer
)	O
{	O
MarkAbort	function
(	O
)	O
;	O
in_mark	int
=	O
0	int
;	O
LMsg	function
(	O
0	int
,	O
"Not enough memory... Sorry."	pointer
)	O
;	O
md_user	pointer
->	O
u_plop	struct
.	O
len	int
=	O
0	int
;	O
md_user	pointer
->	O
u_plop	struct
.	O
buf	pointer
=	O
0	int
;	O
break	O
;	O
}	O
if	O
(	O
append_mode	int
)	O
{	O
switch	O
(	O
markdata	struct
->	O
nonl	int
)	O
{	O
case	O
0	int
:	O
if	O
(	O
join_with_cr	int
)	O
{	O
md_user	pointer
->	O
u_plop	struct
.	O
buf	pointer
[	O
md_user	pointer
->	O
u_plop	struct
.	O
len	int
]	O
=	O
'\r'	O
;	O
md_user	pointer
->	O
u_plop	struct
.	O
len	int
++	O
;	O
}	O
md_user	pointer
->	O
u_plop	struct
.	O
buf	pointer
[	O
md_user	pointer
->	O
u_plop	struct
.	O
len	int
]	O
=	O
'\n'	O
;	O
md_user	pointer
->	O
u_plop	struct
.	O
len	int
++	O
;	O
break	O
;	O
case	O
1	int
:	O
break	O
;	O
case	O
2	int
:	O
md_user	pointer
->	O
u_plop	struct
.	O
buf	pointer
[	O
md_user	pointer
->	O
u_plop	struct
.	O
len	int
]	O
=	O
' '	O
;	O
md_user	pointer
->	O
u_plop	struct
.	O
len	int
++	O
;	O
break	O
;	O
case	O
3	int
:	O
md_user	pointer
->	O
u_plop	struct
.	O
buf	pointer
[	O
md_user	pointer
->	O
u_plop	struct
.	O
len	int
]	O
=	O
','	O
;	O
md_user	pointer
->	O
u_plop	struct
.	O
len	int
++	O
;	O
break	O
;	O
}	O
}	O
md_user	pointer
->	O
u_plop	struct
.	O
len	int
+=	O
rem	int
(	O
markdata	struct
->	O
x1	int
,	O
markdata	struct
->	O
y1	int
,	O
x2	int
,	O
y2	int
,	O
markdata	struct
->	O
hist_offset	int
==	O
fore	pointer
->	O
w_histheight	int
,	O
md_user	pointer
->	O
u_plop	struct
.	O
buf	pointer
+	O
md_user	pointer
->	O
u_plop	struct
.	O
len	int
,	O
yend	int
)	O
;	O
md_user	pointer
->	O
u_plop	struct
.	O
enc	int
=	O
fore	pointer
->	O
w_encoding	O
;	O
}	O
if	O
(	O
markdata	struct
->	O
hist_offset	int
!=	O
fore	pointer
->	O
w_histheight	int
)	O
{	O
LAY_CALL_UP	O
(	O
LRefreshAll	function
(	O
flayer	pointer
,	O
0	int
)	O
)	O
;	O
}	O
ExitOverlayPage	function
(	O
)	O
;	O
WindowChanged	function
(	O
fore	pointer
,	O
'P'	O
)	O
;	O
if	O
(	O
append_mode	int
)	O
LMsg	function
(	O
0	int
,	O
"Appended %d characters to buffer"	pointer
,	O
newcopylen	int
)	O
;	O
else	O
LMsg	function
(	O
0	int
,	O
"Copied %d characters into buffer"	pointer
,	O
md_user	pointer
->	O
u_plop	struct
.	O
len	int
)	O
;	O
if	O
(	O
write_buffer	int
)	O
WriteFile	function
(	O
md_user	pointer
,	O
(	O
char	O
*	O
)	O
0	int
,	O
DUMP_EXCHANGE	int
)	O
;	O
in_mark	int
=	O
0	int
;	O
break	O
;	O
}	O
case	O
0222	int
:	O
if	O
(	O
flayer	pointer
->	O
l_mouseevent	struct
.	O
start	int
)	O
{	O
int	O
button	int
=	O
flayer	pointer
->	O
l_mouseevent	struct
.	O
buffer	array
[	O
0	int
]	O
;	O
if	O
(	O
button	int
==	O
'a'	O
)	O
{	O
od	int
=	O
'j'	O
;	O
}	O
else	O
if	O
(	O
button	int
==	O
'`'	O
)	O
{	O
od	int
=	O
'k'	O
;	O
}	O
else	O
if	O
(	O
button	int
==	O
' '	O
)	O
{	O
cx	int
=	O
flayer	pointer
->	O
l_mouseevent	struct
.	O
buffer	array
[	O
1	int
]	O
;	O
cy	int
=	O
D2W	O
(	O
flayer	pointer
->	O
l_mouseevent	struct
.	O
buffer	array
[	O
2	int
]	O
)	O
;	O
revto	function
(	O
cx	int
,	O
cy	int
)	O
;	O
od	int
=	O
' '	O
;	O
}	O
else	O
od	int
=	O
0	int
;	O
LayProcessMouseSwitch	function
(	O
flayer	pointer
,	O
0	int
)	O
;	O
if	O
(	O
od	int
)	O
goto	O
processchar	O
;	O
}	O
else	O
LayProcessMouseSwitch	function
(	O
flayer	pointer
,	O
1	int
)	O
;	O
break	O
;	O
default	O
:	O
MarkAbort	function
(	O
)	O
;	O
LMsg	function
(	O
0	int
,	O
"Copy mode aborted"	pointer
)	O
;	O
in_mark	int
=	O
0	int
;	O
break	O
;	O
}	O
if	O
(	O
in_mark	int
)	O
markdata	struct
->	O
rep_cnt	int
=	O
0	int
;	O
}	O
if	O
(	O
in_mark	int
)	O
{	O
flayer	pointer
->	O
l_x	int
=	O
markdata	struct
->	O
cx	int
;	O
flayer	pointer
->	O
l_y	int
=	O
W2D	O
(	O
markdata	struct
->	O
cy	int
)	O
;	O
}	O
*	O
inbufp	pointer
=	O
pt	pointer
;	O
*	O
inlenp	pointer
=	O
inlen	int
;	O
}	O
void	O
revto	function
(	O
tx	int
,	O
ty	int
)	O
int	O
tx	int
,	O
ty	int
;	O
{	O
revto_line	function
(	O
tx	int
,	O
ty	int
,	O
-	O
1	int
)	O
;	O
}	O
void	O
revto_line	function
(	O
tx	int
,	O
ty	int
,	O
line	array
)	O
int	O
tx	int
,	O
ty	int
,	O
line	array
;	O
{	O
int	O
fx	int
,	O
fy	int
;	O
int	O
x	int
,	O
y	int
,	O
t	int
,	O
revst	int
,	O
reven	int
,	O
qq	int
,	O
ff	int
,	O
tt	int
,	O
st	int
,	O
en	int
,	O
ce	int
=	O
0	int
;	O
int	O
ystart	int
=	O
0	int
,	O
yend	int
=	O
fore	pointer
->	O
w_height	O
-	O
1	int
;	O
int	O
i	pointer
,	O
ry	int
;	O
unsigned	O
char	O
*	O
wi	pointer
;	O
struct	O
mline	struct
*	O
ml	pointer
;	O
struct	O
mchar	struct
mc	struct
;	O
if	O
(	O
tx	int
<	O
0	int
)	O
tx	int
=	O
0	int
;	O
else	O
if	O
(	O
tx	int
>	O
fore	pointer
->	O
w_width	O
-	O
1	int
)	O
tx	int
=	O
fore	pointer
->	O
w_width	O
-	O
1	int
;	O
if	O
(	O
ty	int
<	O
fore	pointer
->	O
w_histheight	int
-	O
fore	pointer
->	O
w_scrollback_height	int
)	O
ty	int
=	O
fore	pointer
->	O
w_histheight	int
-	O
fore	pointer
->	O
w_scrollback_height	int
;	O
else	O
if	O
(	O
ty	int
>	O
fore	pointer
->	O
w_histheight	int
+	O
fore	pointer
->	O
w_height	O
-	O
1	int
)	O
ty	int
=	O
fore	pointer
->	O
w_histheight	int
+	O
fore	pointer
->	O
w_height	O
-	O
1	int
;	O
fx	int
=	O
markdata	struct
->	O
cx	int
;	O
fy	int
=	O
markdata	struct
->	O
cy	int
;	O
ml	pointer
=	O
WIN	O
(	O
ty	int
)	O
;	O
if	O
(	O
ty	int
==	O
fy	int
&&	O
fx	int
+	O
1	int
==	O
tx	int
&&	O
dw_right	O
(	O
ml	pointer
,	O
tx	int
,	O
fore	pointer
->	O
w_encoding	O
)	O
&&	O
tx	int
<	O
D_width	O
-	O
1	int
)	O
tx	int
++	O
;	O
if	O
(	O
ty	int
==	O
fy	int
&&	O
fx	int
-	O
1	int
==	O
tx	int
&&	O
dw_right	O
(	O
ml	pointer
,	O
fx	int
,	O
fore	pointer
->	O
w_encoding	O
)	O
&&	O
tx	int
)	O
tx	int
--	O
;	O
markdata	struct
->	O
cx	int
=	O
tx	int
;	O
markdata	struct
->	O
cy	int
=	O
ty	int
;	O
i	pointer
=	O
0	int
;	O
if	O
(	O
line	array
>=	O
0	int
&&	O
line	array
<	O
fore	pointer
->	O
w_height	O
)	O
i	pointer
=	O
W2D	O
(	O
ty	int
)	O
-	O
line	array
;	O
else	O
if	O
(	O
ty	int
<	O
markdata	struct
->	O
hist_offset	int
)	O
i	pointer
=	O
ty	int
-	O
markdata	struct
->	O
hist_offset	int
;	O
else	O
if	O
(	O
ty	int
>	O
markdata	struct
->	O
hist_offset	int
+	O
(	O
fore	pointer
->	O
w_height	O
-	O
1	int
)	O
)	O
i	pointer
=	O
ty	int
-	O
markdata	struct
->	O
hist_offset	int
-	O
(	O
fore	pointer
->	O
w_height	O
-	O
1	int
)	O
;	O
if	O
(	O
i	pointer
>	O
0	int
)	O
yend	int
-=	O
MarkScrollUpDisplay	function
(	O
i	pointer
)	O
;	O
else	O
if	O
(	O
i	pointer
<	O
0	int
)	O
ystart	int
+=	O
MarkScrollDownDisplay	function
(	O
-	O
i	pointer
)	O
;	O
if	O
(	O
markdata	struct
->	O
second	int
==	O
0	int
)	O
{	O
flayer	pointer
->	O
l_x	int
=	O
tx	int
;	O
flayer	pointer
->	O
l_y	int
=	O
W2D	O
(	O
ty	int
)	O
;	O
LGotoPos	function
(	O
flayer	pointer
,	O
tx	int
,	O
W2D	O
(	O
ty	int
)	O
)	O
;	O
return	O
;	O
}	O
qq	int
=	O
markdata	struct
->	O
x1	int
+	O
markdata	struct
->	O
y1	int
*	O
fore	pointer
->	O
w_width	O
;	O
ff	int
=	O
fx	int
+	O
fy	int
*	O
fore	pointer
->	O
w_width	O
;	O
tt	int
=	O
tx	int
+	O
ty	int
*	O
fore	pointer
->	O
w_width	O
;	O
if	O
(	O
ff	int
>	O
tt	int
)	O
{	O
st	int
=	O
tt	int
;	O
en	int
=	O
ff	int
;	O
x	int
=	O
tx	int
;	O
y	int
=	O
ty	int
;	O
}	O
else	O
{	O
st	int
=	O
ff	int
;	O
en	int
=	O
tt	int
;	O
x	int
=	O
fx	int
;	O
y	int
=	O
fy	int
;	O
}	O
if	O
(	O
st	int
>	O
qq	int
)	O
{	O
st	int
++	O
;	O
x	int
++	O
;	O
}	O
if	O
(	O
en	int
<	O
qq	int
)	O
en	int
--	O
;	O
if	O
(	O
tt	int
>	O
qq	int
)	O
{	O
revst	int
=	O
qq	int
;	O
reven	int
=	O
tt	int
;	O
}	O
else	O
{	O
revst	int
=	O
tt	int
;	O
reven	int
=	O
qq	int
;	O
}	O
ry	int
=	O
y	int
-	O
markdata	struct
->	O
hist_offset	int
;	O
if	O
(	O
ry	int
<	O
ystart	int
)	O
{	O
y	int
+=	O
(	O
ystart	int
-	O
ry	int
)	O
;	O
x	int
=	O
0	int
;	O
st	int
=	O
y	int
*	O
fore	pointer
->	O
w_width	O
;	O
ry	int
=	O
ystart	int
;	O
}	O
ml	pointer
=	O
WIN	O
(	O
y	int
)	O
;	O
for	O
(	O
t	int
=	O
st	int
;	O
t	int
<=	O
en	int
;	O
t	int
++	O
,	O
x	int
++	O
)	O
{	O
if	O
(	O
x	int
>=	O
fore	pointer
->	O
w_width	O
)	O
{	O
x	int
=	O
0	int
;	O
y	int
++	O
,	O
ry	int
++	O
;	O
ml	pointer
=	O
WIN	O
(	O
y	int
)	O
;	O
}	O
if	O
(	O
ry	int
>	O
yend	int
)	O
break	O
;	O
if	O
(	O
t	int
==	O
st	int
||	O
x	int
==	O
0	int
)	O
{	O
wi	pointer
=	O
ml	pointer
->	O
image	char
+	O
fore	pointer
->	O
w_width	O
;	O
for	O
(	O
ce	int
=	O
fore	pointer
->	O
w_width	O
;	O
ce	int
>=	O
0	int
;	O
ce	int
--	O
,	O
wi	pointer
--	O
)	O
if	O
(	O
*	O
wi	pointer
!=	O
' '	O
)	O
break	O
;	O
}	O
if	O
(	O
x	int
<=	O
ce	int
&&	O
x	int
>=	O
markdata	struct
->	O
left_mar	int
&&	O
x	int
<=	O
markdata	struct
->	O
right_mar	int
)	O
{	O
if	O
(	O
dw_right	O
(	O
ml	pointer
,	O
x	int
,	O
fore	pointer
->	O
w_encoding	O
)	O
)	O
{	O
if	O
(	O
t	int
==	O
revst	int
)	O
revst	int
--	O
;	O
t	int
--	O
;	O
x	int
--	O
;	O
}	O
if	O
(	O
t	int
>=	O
revst	int
&&	O
t	int
<=	O
reven	int
)	O
{	O
mc	struct
=	O
mchar_so	struct
;	O
if	O
(	O
pastefont	int
)	O
{	O
mc	struct
.	O
font	char
=	O
ml	pointer
->	O
font	char
[	O
x	int
]	O
;	O
mc	struct
.	O
fontx	char
=	O
ml	pointer
->	O
fontx	char
[	O
x	int
]	O
;	O
}	O
mc	struct
.	O
image	char
=	O
ml	pointer
->	O
image	char
[	O
x	int
]	O
;	O
}	O
else	O
copy_mline2mchar	O
(	O
&	O
mc	struct
,	O
ml	pointer
,	O
x	int
)	O
;	O
if	O
(	O
dw_left	O
(	O
ml	pointer
,	O
x	int
,	O
fore	pointer
->	O
w_encoding	O
)	O
)	O
{	O
mc	struct
.	O
mbcs	char
=	O
ml	pointer
->	O
image	char
[	O
x	int
+	O
1	int
]	O
;	O
LPutChar	function
(	O
flayer	pointer
,	O
&	O
mc	struct
,	O
x	int
,	O
W2D	O
(	O
y	int
)	O
)	O
;	O
t	int
++	O
;	O
}	O
LPutChar	function
(	O
flayer	pointer
,	O
&	O
mc	struct
,	O
x	int
,	O
W2D	O
(	O
y	int
)	O
)	O
;	O
if	O
(	O
dw_left	O
(	O
ml	pointer
,	O
x	int
,	O
fore	pointer
->	O
w_encoding	O
)	O
)	O
x	int
++	O
;	O
}	O
}	O
flayer	pointer
->	O
l_x	int
=	O
tx	int
;	O
flayer	pointer
->	O
l_y	int
=	O
W2D	O
(	O
ty	int
)	O
;	O
LGotoPos	function
(	O
flayer	pointer
,	O
tx	int
,	O
W2D	O
(	O
ty	int
)	O
)	O
;	O
}	O
static	O
void	O
MarkAbort	function
(	O
)	O
{	O
int	O
yend	int
,	O
redisp	int
;	O
debug	O
(	O
"MarkAbort\n"	pointer
)	O
;	O
markdata	struct
=	O
(	O
struct	O
markdata	struct
*	O
)	O
flayer	pointer
->	O
l_data	pointer
;	O
fore	pointer
=	O
markdata	struct
->	O
md_window	pointer
;	O
yend	int
=	O
fore	pointer
->	O
w_height	O
-	O
1	int
;	O
redisp	int
=	O
markdata	struct
->	O
second	int
;	O
if	O
(	O
fore	pointer
->	O
w_histheight	int
-	O
markdata	struct
->	O
hist_offset	int
<	O
fore	pointer
->	O
w_height	O
)	O
{	O
markdata	struct
->	O
second	int
=	O
0	int
;	O
yend	int
-=	O
MarkScrollUpDisplay	function
(	O
fore	pointer
->	O
w_histheight	int
-	O
markdata	struct
->	O
hist_offset	int
)	O
;	O
}	O
if	O
(	O
markdata	struct
->	O
hist_offset	int
!=	O
fore	pointer
->	O
w_histheight	int
)	O
{	O
LAY_CALL_UP	O
(	O
LRefreshAll	function
(	O
flayer	pointer
,	O
0	int
)	O
)	O
;	O
}	O
else	O
{	O
rem	int
(	O
markdata	struct
->	O
x1	int
,	O
markdata	struct
->	O
y1	int
,	O
markdata	struct
->	O
cx	int
,	O
markdata	struct
->	O
cy	int
,	O
redisp	int
,	O
(	O
char	O
*	O
)	O
0	int
,	O
yend	int
)	O
;	O
}	O
ExitOverlayPage	function
(	O
)	O
;	O
WindowChanged	function
(	O
fore	pointer
,	O
'P'	O
)	O
;	O
}	O
static	O
void	O
MarkRedisplayLine	function
(	O
y	int
,	O
xs	int
,	O
xe	int
,	O
isblank	function
)	O
int	O
y	int
;	O
int	O
xs	int
,	O
xe	int
;	O
int	O
isblank	function
;	O
{	O
int	O
wy	int
,	O
x	int
,	O
i	pointer
,	O
rm	int
;	O
int	O
sta	int
,	O
sto	int
,	O
cp	int
;	O
unsigned	O
char	O
*	O
wi	pointer
;	O
struct	O
mline	struct
*	O
ml	pointer
;	O
struct	O
mchar	struct
mchar_marked	struct
;	O
if	O
(	O
y	int
<	O
0	int
)	O
return	O
;	O
markdata	struct
=	O
(	O
struct	O
markdata	struct
*	O
)	O
flayer	pointer
->	O
l_data	pointer
;	O
fore	pointer
=	O
markdata	struct
->	O
md_window	pointer
;	O
mchar_marked	struct
=	O
mchar_so	struct
;	O
wy	int
=	O
D2W	O
(	O
y	int
)	O
;	O
ml	pointer
=	O
WIN	O
(	O
wy	int
)	O
;	O
if	O
(	O
markdata	struct
->	O
second	int
==	O
0	int
)	O
{	O
if	O
(	O
dw_right	O
(	O
ml	pointer
,	O
xs	int
,	O
fore	pointer
->	O
w_encoding	O
)	O
&&	O
xs	int
>	O
0	int
)	O
xs	int
--	O
;	O
if	O
(	O
dw_left	O
(	O
ml	pointer
,	O
xe	int
,	O
fore	pointer
->	O
w_encoding	O
)	O
&&	O
xe	int
<	O
fore	pointer
->	O
w_width	O
-	O
1	int
)	O
xe	int
++	O
;	O
if	O
(	O
xs	int
==	O
0	int
&&	O
y	int
>	O
0	int
&&	O
wy	int
>	O
0	int
&&	O
WIN	O
(	O
wy	int
-	O
1	int
)	O
->	O
image	char
[	O
flayer	pointer
->	O
l_width	int
]	O
==	O
0	int
)	O
LCDisplayLineWrap	function
(	O
flayer	pointer
,	O
ml	pointer
,	O
y	int
,	O
xs	int
,	O
xe	int
,	O
isblank	function
)	O
;	O
else	O
LCDisplayLine	function
(	O
flayer	pointer
,	O
ml	pointer
,	O
y	int
,	O
xs	int
,	O
xe	int
,	O
isblank	function
)	O
;	O
return	O
;	O
}	O
sta	int
=	O
markdata	struct
->	O
y1	int
*	O
fore	pointer
->	O
w_width	O
+	O
markdata	struct
->	O
x1	int
;	O
sto	int
=	O
markdata	struct
->	O
cy	int
*	O
fore	pointer
->	O
w_width	O
+	O
markdata	struct
->	O
cx	int
;	O
if	O
(	O
sta	int
>	O
sto	int
)	O
{	O
i	pointer
=	O
sta	int
;	O
sta	int
=	O
sto	int
;	O
sto	int
=	O
i	pointer
;	O
}	O
cp	int
=	O
wy	int
*	O
fore	pointer
->	O
w_width	O
+	O
xs	int
;	O
rm	int
=	O
markdata	struct
->	O
right_mar	int
;	O
for	O
(	O
x	int
=	O
fore	pointer
->	O
w_width	O
,	O
wi	pointer
=	O
ml	pointer
->	O
image	char
+	O
fore	pointer
->	O
w_width	O
;	O
x	int
>=	O
0	int
;	O
x	int
--	O
,	O
wi	pointer
--	O
)	O
if	O
(	O
*	O
wi	pointer
!=	O
' '	O
)	O
break	O
;	O
if	O
(	O
x	int
<	O
rm	int
)	O
rm	int
=	O
x	int
;	O
for	O
(	O
x	int
=	O
xs	int
;	O
x	int
<=	O
xe	int
;	O
x	int
++	O
,	O
cp	int
++	O
)	O
if	O
(	O
cp	int
>=	O
sta	int
&&	O
x	int
>=	O
markdata	struct
->	O
left_mar	int
)	O
break	O
;	O
if	O
(	O
dw_right	O
(	O
ml	pointer
,	O
x	int
,	O
fore	pointer
->	O
w_encoding	O
)	O
)	O
x	int
--	O
;	O
if	O
(	O
x	int
>	O
xs	int
)	O
LCDisplayLine	function
(	O
flayer	pointer
,	O
ml	pointer
,	O
y	int
,	O
xs	int
,	O
x	int
-	O
1	int
,	O
isblank	function
)	O
;	O
for	O
(	O
;	O
x	int
<=	O
xe	int
;	O
x	int
++	O
,	O
cp	int
++	O
)	O
{	O
if	O
(	O
cp	int
>	O
sto	int
||	O
x	int
>	O
rm	int
)	O
break	O
;	O
if	O
(	O
pastefont	int
)	O
{	O
mchar_marked	struct
.	O
font	char
=	O
ml	pointer
->	O
font	char
[	O
x	int
]	O
;	O
mchar_marked	struct
.	O
fontx	char
=	O
ml	pointer
->	O
fontx	char
[	O
x	int
]	O
;	O
}	O
mchar_marked	struct
.	O
image	char
=	O
ml	pointer
->	O
image	char
[	O
x	int
]	O
;	O
mchar_marked	struct
.	O
mbcs	char
=	O
0	int
;	O
if	O
(	O
dw_left	O
(	O
ml	pointer
,	O
x	int
,	O
fore	pointer
->	O
w_encoding	O
)	O
)	O
{	O
mchar_marked	struct
.	O
mbcs	char
=	O
ml	pointer
->	O
image	char
[	O
x	int
+	O
1	int
]	O
;	O
cp	int
++	O
;	O
}	O
LPutChar	function
(	O
flayer	pointer
,	O
&	O
mchar_marked	struct
,	O
x	int
,	O
y	int
)	O
;	O
if	O
(	O
dw_left	O
(	O
ml	pointer
,	O
x	int
,	O
fore	pointer
->	O
w_encoding	O
)	O
)	O
x	int
++	O
;	O
}	O
if	O
(	O
x	int
<=	O
xe	int
)	O
LCDisplayLine	function
(	O
flayer	pointer
,	O
ml	pointer
,	O
y	int
,	O
x	int
,	O
xe	int
,	O
isblank	function
)	O
;	O
}	O
static	O
int	O
MarkRewrite	function
(	O
ry	int
,	O
xs	int
,	O
xe	int
,	O
rend	pointer
,	O
doit	int
)	O
int	O
ry	int
,	O
xs	int
,	O
xe	int
,	O
doit	int
;	O
struct	O
mchar	struct
*	O
rend	pointer
;	O
{	O
int	O
dx	int
,	O
x	int
,	O
y	int
,	O
st	int
,	O
en	int
,	O
t	int
,	O
rm	int
;	O
unsigned	O
char	O
*	O
i	pointer
;	O
struct	O
mline	struct
*	O
ml	pointer
;	O
struct	O
mchar	struct
mchar_marked	struct
;	O
mchar_marked	struct
=	O
mchar_so	struct
;	O
debug3	O
(	O
"MarkRewrite %d, %d-%d\n"	pointer
,	O
ry	int
,	O
xs	int
,	O
xe	int
)	O
;	O
markdata	struct
=	O
(	O
struct	O
markdata	struct
*	O
)	O
flayer	pointer
->	O
l_data	pointer
;	O
fore	pointer
=	O
markdata	struct
->	O
md_window	pointer
;	O
y	int
=	O
D2W	O
(	O
ry	int
)	O
;	O
ml	pointer
=	O
WIN	O
(	O
y	int
)	O
;	O
if	O
(	O
fore	pointer
->	O
w_encoding	O
&&	O
fore	pointer
->	O
w_encoding	O
!=	O
UTF8	int
&&	O
D_encoding	O
==	O
UTF8	int
&&	O
ContainsSpecialDeffont	function
(	O
ml	pointer
,	O
xs	int
,	O
xe	int
,	O
fore	pointer
->	O
w_encoding	O
)	O
)	O
return	O
EXPENSIVE	int
;	O
dx	int
=	O
xe	int
-	O
xs	int
+	O
1	int
;	O
if	O
(	O
doit	int
)	O
{	O
i	pointer
=	O
ml	pointer
->	O
image	char
+	O
xs	int
;	O
while	O
(	O
dx	int
--	O
)	O
PUTCHAR	function
(	O
*	O
i	pointer
++	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
markdata	struct
->	O
second	int
==	O
0	int
)	O
st	int
=	O
en	int
=	O
-	O
1	int
;	O
else	O
{	O
st	int
=	O
markdata	struct
->	O
y1	int
*	O
fore	pointer
->	O
w_width	O
+	O
markdata	struct
->	O
x1	int
;	O
en	int
=	O
markdata	struct
->	O
cy	int
*	O
fore	pointer
->	O
w_width	O
+	O
markdata	struct
->	O
cx	int
;	O
if	O
(	O
st	int
>	O
en	int
)	O
{	O
t	int
=	O
st	int
;	O
st	int
=	O
en	int
;	O
en	int
=	O
t	int
;	O
}	O
}	O
t	int
=	O
y	int
*	O
fore	pointer
->	O
w_width	O
+	O
xs	int
;	O
for	O
(	O
rm	int
=	O
fore	pointer
->	O
w_width	O
,	O
i	pointer
=	O
ml	pointer
->	O
image	char
+	O
fore	pointer
->	O
w_width	O
;	O
rm	int
>=	O
0	int
;	O
rm	int
--	O
)	O
if	O
(	O
*	O
i	pointer
--	O
!=	O
' '	O
)	O
break	O
;	O
if	O
(	O
rm	int
>	O
markdata	struct
->	O
right_mar	int
)	O
rm	int
=	O
markdata	struct
->	O
right_mar	int
;	O
x	int
=	O
xs	int
;	O
while	O
(	O
dx	int
--	O
)	O
{	O
if	O
(	O
t	int
>=	O
st	int
&&	O
t	int
<=	O
en	int
&&	O
x	int
>=	O
markdata	struct
->	O
left_mar	int
&&	O
x	int
<=	O
rm	int
)	O
{	O
if	O
(	O
pastefont	int
)	O
{	O
mchar_marked	struct
.	O
font	char
=	O
ml	pointer
->	O
font	char
[	O
x	int
]	O
;	O
mchar_marked	struct
.	O
fontx	char
=	O
ml	pointer
->	O
fontx	char
[	O
x	int
]	O
;	O
}	O
rend	pointer
->	O
image	char
=	O
mchar_marked	struct
.	O
image	char
;	O
if	O
(	O
!	O
cmp_mchar	O
(	O
rend	pointer
,	O
&	O
mchar_marked	struct
)	O
)	O
return	O
EXPENSIVE	int
;	O
}	O
else	O
{	O
rend	pointer
->	O
image	char
=	O
ml	pointer
->	O
image	char
[	O
x	int
]	O
;	O
if	O
(	O
!	O
cmp_mchar_mline	O
(	O
rend	pointer
,	O
ml	pointer
,	O
x	int
)	O
)	O
return	O
EXPENSIVE	int
;	O
}	O
x	int
++	O
;	O
}	O
return	O
xe	int
-	O
xs	int
+	O
1	int
;	O
}	O
static	O
int	O
MarkScrollUpDisplay	function
(	O
n	int
)	O
int	O
n	int
;	O
{	O
int	O
i	pointer
;	O
debug1	O
(	O
"MarkScrollUpDisplay(%d)\n"	pointer
,	O
n	int
)	O
;	O
if	O
(	O
n	int
<=	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
n	int
>	O
fore	pointer
->	O
w_histheight	int
-	O
markdata	struct
->	O
hist_offset	int
)	O
n	int
=	O
fore	pointer
->	O
w_histheight	int
-	O
markdata	struct
->	O
hist_offset	int
;	O
markdata	struct
->	O
hist_offset	int
+=	O
n	int
;	O
i	pointer
=	O
(	O
n	int
<	O
flayer	pointer
->	O
l_height	int
)	O
?	O
n	int
:	O
(	O
flayer	pointer
->	O
l_height	int
)	O
;	O
LScrollV	function
(	O
flayer	pointer
,	O
i	pointer
,	O
0	int
,	O
flayer	pointer
->	O
l_height	int
-	O
1	int
,	O
0	int
)	O
;	O
while	O
(	O
i	pointer
--	O
>	O
0	int
)	O
MarkRedisplayLine	function
(	O
flayer	pointer
->	O
l_height	int
-	O
i	pointer
-	O
1	int
,	O
0	int
,	O
flayer	pointer
->	O
l_width	int
-	O
1	int
,	O
1	int
)	O
;	O
return	O
n	int
;	O
}	O
static	O
int	O
MarkScrollDownDisplay	function
(	O
n	int
)	O
int	O
n	int
;	O
{	O
int	O
i	pointer
;	O
debug1	O
(	O
"MarkScrollDownDisplay(%d)\n"	pointer
,	O
n	int
)	O
;	O
if	O
(	O
n	int
<=	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
n	int
>	O
markdata	struct
->	O
hist_offset	int
)	O
n	int
=	O
markdata	struct
->	O
hist_offset	int
;	O
markdata	struct
->	O
hist_offset	int
-=	O
n	int
;	O
i	pointer
=	O
(	O
n	int
<	O
flayer	pointer
->	O
l_height	int
)	O
?	O
n	int
:	O
(	O
flayer	pointer
->	O
l_height	int
)	O
;	O
LScrollV	function
(	O
flayer	pointer
,	O
-	O
i	pointer
,	O
0	int
,	O
fore	pointer
->	O
w_height	O
-	O
1	int
,	O
0	int
)	O
;	O
while	O
(	O
i	pointer
--	O
>	O
0	int
)	O
MarkRedisplayLine	function
(	O
i	pointer
,	O
0	int
,	O
flayer	pointer
->	O
l_width	int
-	O
1	int
,	O
1	int
)	O
;	O
return	O
n	int
;	O
}	O
void	O
MakePaster	function
(	O
pa	pointer
,	O
buf	pointer
,	O
len	int
,	O
bufiscopy	int
)	O
struct	O
paster	struct
*	O
pa	pointer
;	O
char	O
*	O
buf	pointer
;	O
int	O
len	int
;	O
int	O
bufiscopy	int
;	O
{	O
FreePaster	function
(	O
pa	pointer
)	O
;	O
pa	pointer
->	O
pa_pasteptr	pointer
=	O
buf	pointer
;	O
pa	pointer
->	O
pa_pastelen	int
=	O
len	int
;	O
if	O
(	O
bufiscopy	int
)	O
pa	pointer
->	O
pa_pastebuf	pointer
=	O
buf	pointer
;	O
pa	pointer
->	O
pa_pastelayer	pointer
=	O
flayer	pointer
;	O
DoProcess	function
(	O
Layer2Window	O
(	O
flayer	pointer
)	O
,	O
&	O
pa	pointer
->	O
pa_pasteptr	pointer
,	O
&	O
pa	pointer
->	O
pa_pastelen	int
,	O
pa	pointer
)	O
;	O
}	O
void	O
FreePaster	function
(	O
pa	pointer
)	O
struct	O
paster	struct
*	O
pa	pointer
;	O
{	O
if	O
(	O
pa	pointer
->	O
pa_pastebuf	pointer
)	O
free	function
(	O
pa	pointer
->	O
pa_pastebuf	pointer
)	O
;	O
pa	pointer
->	O
pa_pastebuf	pointer
=	O
0	int
;	O
pa	pointer
->	O
pa_pasteptr	pointer
=	O
0	int
;	O
pa	pointer
->	O
pa_pastelen	int
=	O
0	int
;	O
pa	pointer
->	O
pa_pastelayer	pointer
=	O
0	int
;	O
evdeq	function
(	O
&	O
pa	pointer
->	O
pa_slowev	struct
)	O
;	O
}	O
