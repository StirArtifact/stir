typedef	O
RETSIGTYPE	void
(	O
*	O
mu_sig_handler_t	pointer
)	O
(	O
int	O
)	O
;	O
static	O
mu_sig_handler_t	pointer
set_signal	function
(	O
int	O
sig	int
,	O
mu_sig_handler_t	pointer
handler	pointer
)	O
{	O
{	O
struct	O
sigaction	struct
act	enum
,	O
oldact	struct
;	O
act	enum
.	O
sa_handler	pointer
=	O
handler	pointer
;	O
sigemptyset	function
(	O
&	O
act	enum
.	O
sa_mask	struct
)	O
;	O
act	enum
.	O
sa_flags	int
=	O
0	int
;	O
sigaction	struct
(	O
sig	int
,	O
&	O
act	enum
,	O
&	O
oldact	struct
)	O
;	O
return	O
oldact	struct
.	O
sa_handler	pointer
;	O
}	O
}	O
struct	O
_mu_m_server	struct
{	O
char	O
*	O
ident	pointer
;	O
int	O
deftype	int
;	O
mu_server_t	pointer
server	pointer
;	O
mu_list_t	pointer
srvlist	pointer
;	O
mu_m_server_preflight_fp	pointer
preflight	pointer
;	O
mu_m_server_handler_fp	pointer
conn	pointer
;	O
mu_m_server_handler_fp	pointer
prefork	pointer
;	O
void	O
*	O
data	pointer
;	O
size_t	long
app_data_size	long
;	O
int	O
mode	int
;	O
int	O
foreground	int
;	O
size_t	long
max_children	long
;	O
size_t	long
num_children	long
;	O
pid_t	int
*	O
child_pid	pointer
;	O
char	O
*	O
pidfile	pointer
;	O
struct	O
mu_sockaddr_hints	struct
hints	pointer
;	O
time_t	long
timeout	long
;	O
mu_acl_t	pointer
acl	pointer
;	O
sigset_t	struct
sigmask	struct
;	O
mu_sig_handler_t	pointer
sigtab	array
[	O
NSIG	O
]	O
;	O
const	O
char	O
*	O
(	O
*	O
strexit	pointer
)	O
(	O
int	O
)	O
;	O
}	O
;	O
static	O
int	O
need_cleanup	int
=	O
0	int
;	O
static	O
int	O
stop	int
=	O
0	int
;	O
static	O
mu_list_t	pointer
m_server_list	pointer
;	O
static	O
void	O
alloc_children	function
(	O
mu_m_server_t	pointer
srv	pointer
)	O
{	O
int	O
i	int
;	O
size_t	long
size	long
=	O
srv	pointer
->	O
max_children	long
*	O
sizeof	O
(	O
srv	pointer
->	O
child_pid	pointer
[	O
0	int
]	O
)	O
;	O
srv	pointer
->	O
child_pid	pointer
=	O
malloc	function
(	O
size	long
)	O
;	O
if	O
(	O
!	O
srv	pointer
->	O
child_pid	pointer
)	O
{	O
mu_error	function
(	O
"%s"	pointer
,	O
mu_strerror	function
(	O
ENOMEM	int
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
srv	pointer
->	O
max_children	long
;	O
i	int
++	O
)	O
srv	pointer
->	O
child_pid	pointer
[	O
i	int
]	O
=	O
UNUSED_PID	O
;	O
}	O
static	O
void	O
register_child	function
(	O
mu_m_server_t	pointer
msrv	pointer
,	O
pid_t	int
pid	int
)	O
{	O
int	O
i	int
;	O
msrv	pointer
->	O
num_children	long
++	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
msrv	pointer
->	O
max_children	long
;	O
i	int
++	O
)	O
if	O
(	O
msrv	pointer
->	O
child_pid	pointer
[	O
i	int
]	O
==	O
UNUSED_PID	O
)	O
{	O
msrv	pointer
->	O
child_pid	pointer
[	O
i	int
]	O
=	O
pid	int
;	O
return	O
;	O
}	O
mu_error	function
(	O
"%s:%d: cannot find free PID slot (internal error?)"	pointer
,	O
__FILE__	O
,	O
__LINE__	O
)	O
;	O
}	O
static	O
int	O
unregister_child	function
(	O
mu_m_server_t	pointer
msrv	pointer
,	O
pid_t	int
pid	int
)	O
{	O
int	O
i	int
;	O
msrv	pointer
->	O
num_children	long
--	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
msrv	pointer
->	O
max_children	long
;	O
i	int
++	O
)	O
if	O
(	O
msrv	pointer
->	O
child_pid	pointer
[	O
i	int
]	O
==	O
pid	int
)	O
{	O
msrv	pointer
->	O
child_pid	pointer
[	O
i	int
]	O
=	O
UNUSED_PID	O
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
void	O
terminate_children	function
(	O
mu_m_server_t	pointer
msrv	pointer
)	O
{	O
if	O
(	O
msrv	pointer
->	O
child_pid	pointer
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
msrv	pointer
->	O
max_children	long
;	O
i	int
++	O
)	O
if	O
(	O
msrv	pointer
->	O
child_pid	pointer
[	O
i	int
]	O
!=	O
UNUSED_PID	O
)	O
kill	function
(	O
msrv	pointer
->	O
child_pid	pointer
[	O
i	int
]	O
,	O
SIGTERM	int
)	O
;	O
}	O
}	O
void	O
mu_m_server_stop	function
(	O
int	O
code	int
)	O
{	O
stop	int
=	O
code	int
;	O
}	O
struct	O
exit_data	struct
{	O
pid_t	int
pid	int
;	O
int	O
status	int
;	O
}	O
;	O
static	O
int	O
m_server_cleanup	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
mu_m_server_t	pointer
msrv	pointer
=	O
item	pointer
;	O
struct	O
exit_data	struct
*	O
datp	pointer
=	O
data	pointer
;	O
if	O
(	O
unregister_child	function
(	O
msrv	pointer
,	O
datp	pointer
->	O
pid	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
WIFEXITED	O
(	O
datp	pointer
->	O
status	int
)	O
)	O
{	O
int	O
prio	int
=	O
MU_DIAG_INFO	O
;	O
int	O
code	int
=	O
WEXITSTATUS	O
(	O
datp	pointer
->	O
status	int
)	O
;	O
if	O
(	O
code	int
==	O
0	int
)	O
prio	int
=	O
MU_DIAG_DEBUG	O
;	O
if	O
(	O
msrv	pointer
->	O
strexit	pointer
)	O
mu_diag_output	function
(	O
prio	int
,	O
_	O
(	O
"process %lu finished with code %d (%s)"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
datp	pointer
->	O
pid	int
,	O
code	int
,	O
msrv	pointer
->	O
strexit	pointer
(	O
code	int
)	O
)	O
;	O
else	O
mu_diag_output	function
(	O
prio	int
,	O
_	O
(	O
"process %lu finished with code %d"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
datp	pointer
->	O
pid	int
,	O
code	int
)	O
;	O
}	O
else	O
if	O
(	O
WIFSIGNALED	O
(	O
datp	pointer
->	O
status	int
)	O
)	O
mu_diag_output	function
(	O
MU_DIAG_ERR	O
,	O
"process %lu terminated on signal %d"	pointer
,	O
(	O
unsigned	O
long	O
)	O
datp	pointer
->	O
pid	int
,	O
WTERMSIG	O
(	O
datp	pointer
->	O
status	int
)	O
)	O
;	O
else	O
mu_diag_output	function
(	O
MU_DIAG_ERR	O
,	O
"process %lu terminated (cause unknown)"	pointer
,	O
(	O
unsigned	O
long	O
)	O
datp	pointer
->	O
pid	int
)	O
;	O
return	O
MU_ERR_USER0	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
mu_m_server_idle	function
(	O
void	O
*	O
server_data	pointer
MU_ARG_UNUSED	O
)	O
{	O
if	O
(	O
need_cleanup	int
)	O
{	O
struct	O
exit_data	struct
ex	struct
;	O
need_cleanup	int
=	O
0	int
;	O
while	O
(	O
(	O
ex	struct
.	O
pid	int
=	O
waitpid	function
(	O
-	O
1	int
,	O
&	O
ex	struct
.	O
status	int
,	O
WNOHANG	int
)	O
)	O
>	O
0	int
)	O
mu_list_foreach	function
(	O
m_server_list	pointer
,	O
m_server_cleanup	function
,	O
&	O
ex	struct
)	O
;	O
}	O
return	O
stop	int
;	O
}	O
static	O
RETSIGTYPE	void
m_srv_signal	function
(	O
int	O
signo	int
)	O
{	O
switch	O
(	O
signo	int
)	O
{	O
case	O
SIGCHLD	int
:	O
need_cleanup	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
stop	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
void	O
mu_m_server_create	function
(	O
mu_m_server_t	pointer
*	O
psrv	pointer
,	O
const	O
char	O
*	O
ident	pointer
)	O
{	O
mu_m_server_t	pointer
srv	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
*	O
srv	pointer
)	O
;	O
if	O
(	O
!	O
srv	pointer
)	O
{	O
mu_error	function
(	O
"%s"	pointer
,	O
mu_strerror	function
(	O
ENOMEM	int
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
ident	pointer
)	O
{	O
srv	pointer
->	O
ident	pointer
=	O
strdup	function
(	O
ident	pointer
)	O
;	O
if	O
(	O
!	O
srv	pointer
->	O
ident	pointer
)	O
{	O
mu_error	function
(	O
"%s"	pointer
,	O
mu_strerror	function
(	O
ENOMEM	int
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
srv	pointer
->	O
deftype	int
=	O
MU_IP_TCP	int
;	O
MU_ASSERT	O
(	O
mu_server_create	function
(	O
&	O
srv	pointer
->	O
server	pointer
)	O
)	O
;	O
mu_server_set_idle	function
(	O
srv	pointer
->	O
server	pointer
,	O
mu_m_server_idle	function
)	O
;	O
sigemptyset	function
(	O
&	O
srv	pointer
->	O
sigmask	struct
)	O
;	O
sigaddset	function
(	O
&	O
srv	pointer
->	O
sigmask	struct
,	O
SIGCHLD	int
)	O
;	O
sigaddset	function
(	O
&	O
srv	pointer
->	O
sigmask	struct
,	O
SIGINT	int
)	O
;	O
sigaddset	function
(	O
&	O
srv	pointer
->	O
sigmask	struct
,	O
SIGTERM	int
)	O
;	O
sigaddset	function
(	O
&	O
srv	pointer
->	O
sigmask	struct
,	O
SIGQUIT	int
)	O
;	O
sigaddset	function
(	O
&	O
srv	pointer
->	O
sigmask	struct
,	O
SIGHUP	int
)	O
;	O
*	O
psrv	pointer
=	O
srv	pointer
;	O
if	O
(	O
!	O
m_server_list	pointer
)	O
mu_list_create	function
(	O
&	O
m_server_list	pointer
)	O
;	O
mu_list_append	function
(	O
m_server_list	pointer
,	O
srv	pointer
)	O
;	O
}	O
void	O
mu_m_server_set_type	function
(	O
mu_m_server_t	pointer
srv	pointer
,	O
int	O
type	int
)	O
{	O
srv	pointer
->	O
deftype	int
=	O
type	int
;	O
}	O
void	O
mu_m_server_get_type	function
(	O
mu_m_server_t	pointer
srv	pointer
,	O
int	O
*	O
type	int
)	O
{	O
*	O
type	int
=	O
srv	pointer
->	O
deftype	int
;	O
}	O
void	O
mu_m_server_set_sigset	function
(	O
mu_m_server_t	pointer
srv	pointer
,	O
sigset_t	struct
*	O
sigset	function
)	O
{	O
srv	pointer
->	O
sigmask	struct
=	O
*	O
sigset	function
;	O
sigaddset	function
(	O
&	O
srv	pointer
->	O
sigmask	struct
,	O
SIGCHLD	int
)	O
;	O
}	O
void	O
mu_m_server_get_sigset	function
(	O
mu_m_server_t	pointer
srv	pointer
,	O
sigset_t	struct
*	O
sigset	function
)	O
{	O
*	O
sigset	function
=	O
srv	pointer
->	O
sigmask	struct
;	O
}	O
void	O
mu_m_server_set_mode	function
(	O
mu_m_server_t	pointer
srv	pointer
,	O
int	O
mode	int
)	O
{	O
srv	pointer
->	O
mode	int
=	O
mode	int
;	O
}	O
void	O
mu_m_server_set_conn	function
(	O
mu_m_server_t	pointer
srv	pointer
,	O
mu_m_server_handler_fp	pointer
conn	pointer
)	O
{	O
srv	pointer
->	O
conn	pointer
=	O
conn	pointer
;	O
}	O
void	O
mu_m_server_set_prefork	function
(	O
mu_m_server_t	pointer
srv	pointer
,	O
mu_m_server_handler_fp	pointer
fun	pointer
)	O
{	O
srv	pointer
->	O
prefork	pointer
=	O
fun	pointer
;	O
}	O
void	O
mu_m_server_set_data	function
(	O
mu_m_server_t	pointer
srv	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
srv	pointer
->	O
data	pointer
=	O
data	pointer
;	O
}	O
void	O
mu_m_server_set_max_children	function
(	O
mu_m_server_t	pointer
srv	pointer
,	O
size_t	long
num	long
)	O
{	O
srv	pointer
->	O
max_children	long
=	O
num	long
;	O
}	O
int	O
mu_m_server_set_pidfile	function
(	O
mu_m_server_t	pointer
srv	pointer
,	O
const	O
char	O
*	O
pidfile	pointer
)	O
{	O
char	O
*	O
p	pointer
=	O
strdup	function
(	O
pidfile	pointer
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
errno	O
;	O
free	function
(	O
srv	pointer
->	O
pidfile	pointer
)	O
;	O
srv	pointer
->	O
pidfile	pointer
=	O
p	pointer
;	O
return	O
0	int
;	O
}	O
int	O
mu_m_server_set_foreground	function
(	O
mu_m_server_t	pointer
srv	pointer
,	O
int	O
enable	int
)	O
{	O
srv	pointer
->	O
foreground	int
=	O
enable	int
;	O
return	O
0	int
;	O
}	O
void	O
mu_m_server_set_strexit	function
(	O
mu_m_server_t	pointer
srv	pointer
,	O
const	O
char	O
*	O
(	O
*	O
fun	pointer
)	O
(	O
int	O
)	O
)	O
{	O
srv	pointer
->	O
strexit	pointer
=	O
fun	pointer
;	O
}	O
void	O
mu_m_server_set_preflight	function
(	O
mu_m_server_t	pointer
srv	pointer
,	O
mu_m_server_preflight_fp	pointer
fun	pointer
)	O
{	O
srv	pointer
->	O
preflight	pointer
=	O
fun	pointer
;	O
}	O
int	O
mu_m_server_get_srvlist	function
(	O
mu_m_server_t	pointer
srv	pointer
,	O
mu_list_t	pointer
*	O
plist	pointer
)	O
{	O
*	O
plist	pointer
=	O
srv	pointer
->	O
srvlist	pointer
;	O
return	O
0	int
;	O
}	O
const	O
char	O
*	O
mu_m_server_pidfile	function
(	O
mu_m_server_t	pointer
srv	pointer
)	O
{	O
return	O
srv	pointer
->	O
pidfile	pointer
;	O
}	O
void	O
mu_m_server_set_hints	function
(	O
mu_m_server_t	pointer
srv	pointer
,	O
struct	O
mu_sockaddr_hints	struct
*	O
hints	pointer
)	O
{	O
if	O
(	O
!	O
hints	pointer
)	O
memset	function
(	O
&	O
srv	pointer
->	O
hints	pointer
,	O
0	int
,	O
sizeof	O
(	O
srv	pointer
->	O
hints	pointer
)	O
)	O
;	O
else	O
memcpy	function
(	O
&	O
srv	pointer
->	O
hints	pointer
,	O
hints	pointer
,	O
sizeof	O
(	O
srv	pointer
->	O
hints	pointer
)	O
)	O
;	O
}	O
int	O
mu_m_server_get_hints	function
(	O
mu_m_server_t	pointer
srv	pointer
,	O
struct	O
mu_sockaddr_hints	struct
*	O
hints	pointer
)	O
{	O
if	O
(	O
!	O
hints	pointer
)	O
return	O
EINVAL	int
;	O
memcpy	function
(	O
hints	pointer
,	O
&	O
srv	pointer
->	O
hints	pointer
,	O
sizeof	O
(	O
*	O
hints	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
void	O
mu_m_server_set_default_port	function
(	O
mu_m_server_t	pointer
srv	pointer
,	O
int	O
num	long
)	O
{	O
srv	pointer
->	O
hints	pointer
.	O
port	int
=	O
num	long
;	O
}	O
void	O
mu_m_server_set_timeout	function
(	O
mu_m_server_t	pointer
srv	pointer
,	O
time_t	long
t	long
)	O
{	O
srv	pointer
->	O
timeout	long
=	O
t	long
;	O
}	O
int	O
mu_m_server_mode	function
(	O
mu_m_server_t	pointer
srv	pointer
)	O
{	O
return	O
srv	pointer
->	O
mode	int
;	O
}	O
time_t	long
mu_m_server_timeout	function
(	O
mu_m_server_t	pointer
srv	pointer
)	O
{	O
return	O
srv	pointer
->	O
timeout	long
;	O
}	O
int	O
mu_m_server_foreground	function
(	O
mu_m_server_t	pointer
srv	pointer
)	O
{	O
return	O
srv	pointer
->	O
foreground	int
;	O
}	O
void	O
mu_m_server_set_app_data_size	function
(	O
mu_m_server_t	pointer
srv	pointer
,	O
size_t	long
size	long
)	O
{	O
srv	pointer
->	O
app_data_size	long
=	O
size	long
;	O
}	O
int	O
mu_m_server_set_config_size	function
(	O
mu_m_server_t	pointer
srv	pointer
,	O
size_t	long
size	long
)	O
{	O
if	O
(	O
size	long
<	O
sizeof	O
(	O
struct	O
mu_srv_config	struct
)	O
)	O
return	O
EINVAL	int
;	O
srv	pointer
->	O
app_data_size	long
=	O
size	long
-	O
sizeof	O
(	O
struct	O
mu_srv_config	struct
)	O
;	O
return	O
0	int
;	O
}	O
void	O
mu_srv_config_free	function
(	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
mu_srv_config	struct
*	O
pconf	pointer
=	O
data	pointer
;	O
free	function
(	O
pconf	pointer
)	O
;	O
}	O
static	O
int	O
m_srv_conn	function
(	O
int	O
fd	int
,	O
struct	O
sockaddr	struct
*	O
sa	pointer
,	O
int	O
salen	int
,	O
void	O
*	O
server_data	pointer
,	O
void	O
*	O
call_data	pointer
,	O
mu_ip_server_t	pointer
srv	pointer
)	O
;	O
struct	O
mu_srv_config	struct
*	O
mu_m_server_listen	function
(	O
mu_m_server_t	pointer
msrv	pointer
,	O
struct	O
mu_sockaddr	struct
*	O
s	pointer
,	O
int	O
type	int
)	O
{	O
mu_ip_server_t	pointer
tcpsrv	pointer
;	O
struct	O
mu_srv_config	struct
*	O
pconf	pointer
;	O
MU_ASSERT	O
(	O
mu_ip_server_create	function
(	O
&	O
tcpsrv	pointer
,	O
s	pointer
,	O
type	int
)	O
)	O
;	O
MU_ASSERT	O
(	O
mu_ip_server_set_conn	function
(	O
tcpsrv	pointer
,	O
m_srv_conn	function
)	O
)	O
;	O
pconf	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
pconf	pointer
)	O
+	O
msrv	pointer
->	O
app_data_size	long
)	O
;	O
if	O
(	O
!	O
pconf	pointer
)	O
{	O
mu_error	function
(	O
"%s"	pointer
,	O
mu_strerror	function
(	O
ENOMEM	int
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
pconf	pointer
->	O
msrv	pointer
=	O
msrv	pointer
;	O
pconf	pointer
->	O
tcpsrv	pointer
=	O
tcpsrv	pointer
;	O
pconf	pointer
->	O
single_process	int
=	O
0	int
;	O
pconf	pointer
->	O
timeout	long
=	O
msrv	pointer
->	O
timeout	long
;	O
MU_ASSERT	O
(	O
mu_ip_server_set_data	function
(	O
tcpsrv	pointer
,	O
pconf	pointer
,	O
mu_srv_config_free	function
)	O
)	O
;	O
if	O
(	O
!	O
msrv	pointer
->	O
srvlist	pointer
)	O
MU_ASSERT	O
(	O
mu_list_create	function
(	O
&	O
msrv	pointer
->	O
srvlist	pointer
)	O
)	O
;	O
MU_ASSERT	O
(	O
mu_list_append	function
(	O
msrv	pointer
->	O
srvlist	pointer
,	O
tcpsrv	pointer
)	O
)	O
;	O
return	O
pconf	pointer
;	O
}	O
void	O
mu_m_server_configured_count	function
(	O
mu_m_server_t	pointer
msrv	pointer
,	O
size_t	long
*	O
count	pointer
)	O
{	O
mu_list_count	function
(	O
msrv	pointer
->	O
srvlist	pointer
,	O
count	pointer
)	O
;	O
}	O
void	O
mu_m_server_begin	function
(	O
mu_m_server_t	pointer
msrv	pointer
)	O
{	O
int	O
i	int
,	O
rc	int
;	O
size_t	long
count	pointer
=	O
0	int
;	O
if	O
(	O
!	O
msrv	pointer
->	O
child_pid	pointer
)	O
alloc_children	function
(	O
msrv	pointer
)	O
;	O
mu_list_count	function
(	O
msrv	pointer
->	O
srvlist	pointer
,	O
&	O
count	pointer
)	O
;	O
if	O
(	O
count	pointer
==	O
0	int
)	O
{	O
struct	O
mu_sockaddr	struct
*	O
ta	pointer
;	O
msrv	pointer
->	O
hints	pointer
.	O
flags	int
=	O
MU_AH_PASSIVE	int
;	O
rc	int
=	O
mu_sockaddr_from_node	function
(	O
&	O
ta	pointer
,	O
NULL	O
,	O
NULL	O
,	O
&	O
msrv	pointer
->	O
hints	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
while	O
(	O
ta	pointer
)	O
{	O
struct	O
mu_sockaddr	struct
*	O
next	pointer
=	O
ta	pointer
->	O
next	pointer
;	O
ta	pointer
->	O
next	pointer
=	O
ta	pointer
->	O
prev	pointer
=	O
NULL	O
;	O
mu_m_server_listen	function
(	O
msrv	pointer
,	O
ta	pointer
,	O
msrv	pointer
->	O
deftype	int
)	O
;	O
ta	pointer
=	O
next	pointer
;	O
}	O
}	O
if	O
(	O
!	O
msrv	pointer
->	O
foreground	int
)	O
{	O
if	O
(	O
daemon	function
(	O
0	int
,	O
0	int
)	O
<	O
0	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"failed to become a daemon: %s"	pointer
)	O
,	O
mu_strerror	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
mu_onexit_reset	function
(	O
)	O
;	O
}	O
if	O
(	O
msrv	pointer
->	O
pidfile	pointer
)	O
switch	O
(	O
rc	int
=	O
mu_daemon_create_pidfile	function
(	O
msrv	pointer
->	O
pidfile	pointer
)	O
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
EINVAL	int
:	O
mu_error	function
(	O
_	O
(	O
"%s: invalid name for a pidfile"	pointer
)	O
,	O
msrv	pointer
->	O
pidfile	pointer
)	O
;	O
break	O
;	O
default	O
:	O
mu_error	function
(	O
_	O
(	O
"cannot create pidfile `%s': %s"	pointer
)	O
,	O
msrv	pointer
->	O
pidfile	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NSIG	O
;	O
i	int
++	O
)	O
if	O
(	O
sigismember	function
(	O
&	O
msrv	pointer
->	O
sigmask	struct
,	O
i	int
)	O
)	O
msrv	pointer
->	O
sigtab	array
[	O
i	int
]	O
=	O
set_signal	function
(	O
i	int
,	O
m_srv_signal	function
)	O
;	O
}	O
void	O
mu_m_server_restore_signals	function
(	O
mu_m_server_t	pointer
msrv	pointer
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NSIG	O
;	O
i	int
++	O
)	O
if	O
(	O
sigismember	function
(	O
&	O
msrv	pointer
->	O
sigmask	struct
,	O
i	int
)	O
)	O
set_signal	function
(	O
i	int
,	O
msrv	pointer
->	O
sigtab	array
[	O
i	int
]	O
)	O
;	O
}	O
void	O
mu_m_server_end	function
(	O
mu_m_server_t	pointer
msrv	pointer
)	O
{	O
mu_m_server_restore_signals	function
(	O
msrv	pointer
)	O
;	O
}	O
void	O
mu_m_server_destroy	function
(	O
mu_m_server_t	pointer
*	O
pmsrv	pointer
)	O
{	O
mu_m_server_t	pointer
msrv	pointer
=	O
*	O
pmsrv	pointer
;	O
mu_list_remove	function
(	O
m_server_list	pointer
,	O
msrv	pointer
)	O
;	O
mu_list_destroy	function
(	O
&	O
msrv	pointer
->	O
srvlist	pointer
)	O
;	O
mu_server_destroy	function
(	O
&	O
msrv	pointer
->	O
server	pointer
)	O
;	O
free	function
(	O
msrv	pointer
->	O
child_pid	pointer
)	O
;	O
free	function
(	O
msrv	pointer
->	O
ident	pointer
)	O
;	O
free	function
(	O
msrv	pointer
)	O
;	O
*	O
pmsrv	pointer
=	O
NULL	O
;	O
}	O
static	O
int	O
tcp_conn_handler	function
(	O
int	O
fd	int
,	O
void	O
*	O
conn_data	pointer
,	O
void	O
*	O
server_data	pointer
)	O
{	O
mu_ip_server_t	pointer
tcpsrv	pointer
=	O
(	O
mu_ip_server_t	pointer
)	O
conn_data	pointer
;	O
int	O
rc	int
=	O
mu_ip_server_accept	function
(	O
tcpsrv	pointer
,	O
server_data	pointer
)	O
;	O
if	O
(	O
rc	int
&&	O
rc	int
!=	O
EINTR	int
)	O
{	O
mu_ip_server_shutdown	function
(	O
tcpsrv	pointer
)	O
;	O
return	O
MU_SERVER_CLOSE_CONN	int
;	O
}	O
return	O
stop	int
?	O
MU_SERVER_SHUTDOWN	int
:	O
MU_SERVER_SUCCESS	int
;	O
}	O
static	O
void	O
tcp_conn_free	function
(	O
void	O
*	O
conn_data	pointer
,	O
void	O
*	O
server_data	pointer
)	O
{	O
mu_ip_server_t	pointer
tcpsrv	pointer
=	O
(	O
mu_ip_server_t	pointer
)	O
conn_data	pointer
;	O
mu_ip_server_destroy	function
(	O
&	O
tcpsrv	pointer
)	O
;	O
}	O
static	O
int	O
open_connection	function
(	O
mu_ip_server_t	pointer
tcpsrv	pointer
,	O
mu_m_server_t	pointer
msrv	pointer
)	O
{	O
int	O
rc	int
=	O
mu_ip_server_open	function
(	O
tcpsrv	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"cannot open connection on %s: %s"	pointer
)	O
,	O
mu_ip_server_addrstr	function
(	O
tcpsrv	pointer
)	O
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
rc	int
=	O
mu_server_add_connection	function
(	O
msrv	pointer
->	O
server	pointer
,	O
mu_ip_server_get_fd	function
(	O
tcpsrv	pointer
)	O
,	O
tcpsrv	pointer
,	O
tcp_conn_handler	function
,	O
tcp_conn_free	function
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"cannot add connection %s: %s"	pointer
)	O
,	O
mu_ip_server_addrstr	function
(	O
tcpsrv	pointer
)	O
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
mu_ip_server_shutdown	function
(	O
tcpsrv	pointer
)	O
;	O
}	O
return	O
rc	int
;	O
}	O
int	O
mu_m_server_run	function
(	O
mu_m_server_t	pointer
msrv	pointer
)	O
{	O
int	O
rc	int
;	O
size_t	long
count	pointer
;	O
mode_t	int
saved_umask	int
;	O
mu_iterator_t	pointer
itr	pointer
;	O
saved_umask	int
=	O
umask	function
(	O
0117	int
)	O
;	O
mu_list_get_iterator	function
(	O
msrv	pointer
->	O
srvlist	pointer
,	O
&	O
itr	pointer
)	O
;	O
for	O
(	O
mu_iterator_first	function
(	O
itr	pointer
)	O
;	O
!	O
mu_iterator_is_done	function
(	O
itr	pointer
)	O
;	O
mu_iterator_next	function
(	O
itr	pointer
)	O
)	O
{	O
mu_ip_server_t	pointer
tcpsrv	pointer
;	O
mu_iterator_current	function
(	O
itr	pointer
,	O
(	O
void	O
*	O
*	O
)	O
&	O
tcpsrv	pointer
)	O
;	O
if	O
(	O
open_connection	function
(	O
tcpsrv	pointer
,	O
msrv	pointer
)	O
)	O
{	O
mu_iterator_ctl	function
(	O
itr	pointer
,	O
mu_itrctl_delete_nd	int
,	O
NULL	O
)	O
;	O
mu_ip_server_destroy	function
(	O
&	O
tcpsrv	pointer
)	O
;	O
}	O
}	O
umask	function
(	O
saved_umask	int
)	O
;	O
mu_iterator_destroy	function
(	O
&	O
itr	pointer
)	O
;	O
MU_ASSERT	O
(	O
mu_server_count	function
(	O
msrv	pointer
->	O
server	pointer
,	O
&	O
count	pointer
)	O
)	O
;	O
if	O
(	O
count	pointer
==	O
0	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"no servers configured: exiting"	pointer
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
msrv	pointer
->	O
preflight	pointer
&&	O
msrv	pointer
->	O
preflight	pointer
(	O
msrv	pointer
)	O
)	O
{	O
mu_error	function
(	O
_	O
(	O
"%s: preflight check failed"	pointer
)	O
,	O
msrv	pointer
->	O
ident	pointer
)	O
;	O
return	O
MU_ERR_FAILURE	O
;	O
}	O
if	O
(	O
msrv	pointer
->	O
ident	pointer
)	O
mu_diag_output	function
(	O
MU_DIAG_INFO	O
,	O
_	O
(	O
"%s started"	pointer
)	O
,	O
msrv	pointer
->	O
ident	pointer
)	O
;	O
rc	int
=	O
mu_server_run	function
(	O
msrv	pointer
->	O
server	pointer
)	O
;	O
terminate_children	function
(	O
msrv	pointer
)	O
;	O
if	O
(	O
msrv	pointer
->	O
ident	pointer
)	O
mu_diag_output	function
(	O
MU_DIAG_INFO	O
,	O
_	O
(	O
"%s terminated"	pointer
)	O
,	O
msrv	pointer
->	O
ident	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mu_m_server_check_acl	function
(	O
mu_m_server_t	pointer
msrv	pointer
,	O
struct	O
sockaddr	struct
*	O
s	pointer
,	O
int	O
salen	int
)	O
{	O
if	O
(	O
msrv	pointer
->	O
acl	pointer
)	O
{	O
mu_acl_result_t	enum
res	pointer
;	O
int	O
rc	int
;	O
rc	int
=	O
mu_acl_check_sockaddr	function
(	O
msrv	pointer
->	O
acl	pointer
,	O
s	pointer
,	O
salen	int
,	O
&	O
res	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
char	O
*	O
p	pointer
=	O
mu_sys_sockaddr_to_astr	function
(	O
s	pointer
,	O
salen	int
)	O
;	O
mu_error	function
(	O
_	O
(	O
"access from %s blocked: cannot check ACLs: %s"	pointer
)	O
,	O
p	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
free	function
(	O
p	pointer
)	O
;	O
return	O
1	int
;	O
}	O
switch	O
(	O
res	pointer
)	O
{	O
case	O
mu_acl_result_undefined	int
:	O
{	O
char	O
*	O
p	pointer
=	O
mu_sys_sockaddr_to_astr	function
(	O
s	pointer
,	O
salen	int
)	O
;	O
mu_diag_output	function
(	O
MU_DIAG_INFO	O
,	O
_	O
(	O
"%s: undefined ACL result; access allowed"	pointer
)	O
,	O
p	pointer
)	O
;	O
free	function
(	O
p	pointer
)	O
;	O
}	O
break	O
;	O
case	O
mu_acl_result_accept	int
:	O
break	O
;	O
case	O
mu_acl_result_deny	int
:	O
{	O
char	O
*	O
p	pointer
=	O
mu_sys_sockaddr_to_astr	function
(	O
s	pointer
,	O
salen	int
)	O
;	O
mu_error	function
(	O
_	O
(	O
"access from %s blocked"	pointer
)	O
,	O
p	pointer
)	O
;	O
free	function
(	O
p	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
int	O
m_srv_conn	function
(	O
int	O
fd	int
,	O
struct	O
sockaddr	struct
*	O
sa	pointer
,	O
int	O
salen	int
,	O
void	O
*	O
server_data	pointer
,	O
void	O
*	O
call_data	pointer
,	O
mu_ip_server_t	pointer
srv	pointer
)	O
{	O
int	O
status	int
;	O
struct	O
mu_srv_config	struct
*	O
pconf	pointer
=	O
server_data	pointer
;	O
if	O
(	O
mu_m_server_check_acl	function
(	O
pconf	pointer
->	O
msrv	pointer
,	O
sa	pointer
,	O
salen	int
)	O
)	O
return	O
0	int
;	O
if	O
(	O
!	O
pconf	pointer
->	O
single_process	int
)	O
{	O
pid_t	int
pid	int
;	O
if	O
(	O
mu_m_server_idle	function
(	O
server_data	pointer
)	O
)	O
return	O
MU_SERVER_SHUTDOWN	int
;	O
if	O
(	O
pconf	pointer
->	O
msrv	pointer
->	O
max_children	long
&&	O
pconf	pointer
->	O
msrv	pointer
->	O
num_children	long
>=	O
pconf	pointer
->	O
msrv	pointer
->	O
max_children	long
)	O
{	O
mu_diag_output	function
(	O
MU_DIAG_ERROR	O
,	O
_	O
(	O
"too many children (%lu)"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
pconf	pointer
->	O
msrv	pointer
->	O
num_children	long
)	O
;	O
pause	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
pconf	pointer
->	O
msrv	pointer
->	O
prefork	pointer
&&	O
pconf	pointer
->	O
msrv	pointer
->	O
prefork	pointer
(	O
fd	int
,	O
sa	pointer
,	O
salen	int
,	O
pconf	pointer
,	O
pconf	pointer
->	O
msrv	pointer
->	O
data	pointer
)	O
)	O
return	O
0	int
;	O
pid	int
=	O
fork	function
(	O
)	O
;	O
if	O
(	O
pid	int
==	O
-	O
1	int
)	O
mu_diag_output	function
(	O
MU_DIAG_ERROR	O
,	O
"fork: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
else	O
if	O
(	O
pid	int
==	O
0	int
)	O
{	O
mu_ip_server_shutdown	function
(	O
srv	pointer
)	O
;	O
mu_m_server_restore_signals	function
(	O
pconf	pointer
->	O
msrv	pointer
)	O
;	O
status	int
=	O
pconf	pointer
->	O
msrv	pointer
->	O
conn	pointer
(	O
fd	int
,	O
sa	pointer
,	O
salen	int
,	O
pconf	pointer
,	O
pconf	pointer
->	O
msrv	pointer
->	O
data	pointer
)	O
;	O
closelog	function
(	O
)	O
;	O
exit	function
(	O
status	int
)	O
;	O
}	O
else	O
{	O
register_child	function
(	O
pconf	pointer
->	O
msrv	pointer
,	O
pid	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
pconf	pointer
->	O
msrv	pointer
->	O
prefork	pointer
||	O
pconf	pointer
->	O
msrv	pointer
->	O
prefork	pointer
(	O
fd	int
,	O
sa	pointer
,	O
salen	int
,	O
pconf	pointer
,	O
pconf	pointer
->	O
msrv	pointer
->	O
data	pointer
)	O
==	O
0	int
)	O
pconf	pointer
->	O
msrv	pointer
->	O
conn	pointer
(	O
fd	int
,	O
sa	pointer
,	O
salen	int
,	O
pconf	pointer
,	O
pconf	pointer
->	O
msrv	pointer
->	O
data	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
mu_m_server_parse_url	function
(	O
mu_m_server_t	pointer
msrv	pointer
,	O
const	O
char	O
*	O
arg	pointer
,	O
struct	O
mu_sockaddr	struct
*	O
*	O
psa	pointer
)	O
{	O
int	O
rc	int
;	O
mu_url_t	pointer
url	pointer
,	O
url_hint	pointer
;	O
if	O
(	O
arg	pointer
[	O
0	int
]	O
==	O
'/'	O
)	O
url_hint	pointer
=	O
NULL	O
;	O
else	O
{	O
rc	int
=	O
mu_url_create	function
(	O
&	O
url_hint	pointer
,	O
"inet://"	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
}	O
rc	int
=	O
mu_url_create_hint	function
(	O
&	O
url	pointer
,	O
arg	pointer
,	O
MU_URL_PARSE_DEFAULT	O
,	O
url_hint	pointer
)	O
;	O
mu_url_destroy	function
(	O
&	O
url_hint	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"cannot parse URL `%s': %s"	pointer
)	O
,	O
arg	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
msrv	pointer
->	O
hints	pointer
.	O
flags	int
=	O
MU_AH_PASSIVE	int
;	O
rc	int
=	O
mu_sockaddr_from_url	function
(	O
psa	pointer
,	O
url	pointer
,	O
&	O
msrv	pointer
->	O
hints	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
mu_error	function
(	O
_	O
(	O
"cannot create sockaddr for URL `%s': %s"	pointer
)	O
,	O
arg	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
mu_url_destroy	function
(	O
&	O
url	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
server_block_begin	function
(	O
const	O
char	O
*	O
arg	pointer
,	O
mu_m_server_t	pointer
msrv	pointer
,	O
void	O
*	O
*	O
pdata	pointer
)	O
{	O
struct	O
mu_sockaddr	struct
*	O
s	pointer
;	O
if	O
(	O
mu_m_server_parse_url	function
(	O
msrv	pointer
,	O
arg	pointer
,	O
&	O
s	pointer
)	O
)	O
return	O
1	int
;	O
if	O
(	O
s	pointer
->	O
next	pointer
)	O
{	O
mu_diag_output	function
(	O
MU_DIAG_WARNING	O
,	O
_	O
(	O
"%s resolves to several addresses, "	pointer
"only the first is used"	pointer
)	O
,	O
arg	pointer
)	O
;	O
mu_sockaddr_free	function
(	O
s	pointer
->	O
next	pointer
)	O
;	O
}	O
*	O
pdata	pointer
=	O
mu_m_server_listen	function
(	O
msrv	pointer
,	O
s	pointer
,	O
msrv	pointer
->	O
deftype	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
server_section_parser	function
(	O
enum	O
mu_cfg_section_stage	enum
stage	enum
,	O
const	O
mu_cfg_node_t	struct
*	O
node	pointer
,	O
const	O
char	O
*	O
section_label	pointer
,	O
void	O
*	O
*	O
section_data	pointer
,	O
void	O
*	O
call_data	pointer
,	O
mu_cfg_tree_t	struct
*	O
tree	pointer
)	O
{	O
switch	O
(	O
stage	enum
)	O
{	O
case	O
mu_cfg_section_start	int
:	O
{	O
if	O
(	O
node	pointer
->	O
label	pointer
==	O
NULL	O
||	O
node	pointer
->	O
label	pointer
->	O
type	int
!=	O
MU_CFG_STRING	int
)	O
return	O
1	int
;	O
return	O
server_block_begin	function
(	O
node	pointer
->	O
label	pointer
->	O
v	pointer
.	O
string	pointer
,	O
*	O
section_data	pointer
,	O
section_data	pointer
)	O
;	O
}	O
break	O
;	O
case	O
mu_cfg_section_end	int
:	O
{	O
struct	O
mu_srv_config	struct
*	O
pconf	pointer
=	O
*	O
section_data	pointer
;	O
if	O
(	O
pconf	pointer
->	O
acl	pointer
)	O
mu_ip_server_set_acl	function
(	O
pconf	pointer
->	O
tcpsrv	pointer
,	O
pconf	pointer
->	O
acl	pointer
)	O
;	O
}	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
_cb_daemon_mode	function
(	O
void	O
*	O
data	pointer
,	O
mu_config_value_t	struct
*	O
val	array
)	O
{	O
int	O
*	O
pmode	pointer
=	O
data	pointer
;	O
if	O
(	O
mu_cfg_assert_value_type	function
(	O
val	array
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
strcmp	function
(	O
val	array
->	O
v	pointer
.	O
string	pointer
,	O
"inetd"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
val	array
->	O
v	pointer
.	O
string	pointer
,	O
"interactive"	pointer
)	O
==	O
0	int
)	O
*	O
pmode	pointer
=	O
MODE_INTERACTIVE	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
val	array
->	O
v	pointer
.	O
string	pointer
,	O
"daemon"	pointer
)	O
==	O
0	int
)	O
*	O
pmode	pointer
=	O
MODE_DAEMON	int
;	O
else	O
{	O
mu_error	function
(	O
_	O
(	O
"unknown daemon mode"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
unsigned	O
short	O
get_port	function
(	O
const	O
char	O
*	O
p	pointer
)	O
{	O
if	O
(	O
p	pointer
)	O
{	O
char	O
*	O
q	pointer
;	O
unsigned	O
long	O
n	int
=	O
strtoul	function
(	O
p	pointer
,	O
&	O
q	pointer
,	O
0	int
)	O
;	O
if	O
(	O
*	O
q	pointer
==	O
0	int
)	O
{	O
if	O
(	O
n	int
>	O
USHRT_MAX	O
)	O
{	O
mu_error	function
(	O
_	O
(	O
"invalid port number: %s"	pointer
)	O
,	O
p	pointer
)	O
;	O
return	O
1	int
;	O
}	O
return	O
n	int
;	O
}	O
else	O
{	O
struct	O
servent	struct
*	O
sp	pointer
=	O
getservbyname	function
(	O
p	pointer
,	O
"tcp"	pointer
)	O
;	O
if	O
(	O
!	O
sp	pointer
)	O
return	O
0	int
;	O
return	O
ntohs	function
(	O
sp	pointer
->	O
s_port	int
)	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
_cb_port	function
(	O
void	O
*	O
data	pointer
,	O
mu_config_value_t	struct
*	O
val	array
)	O
{	O
struct	O
mu_sockaddr_hints	struct
*	O
hp	pointer
=	O
data	pointer
;	O
unsigned	O
short	O
num	long
;	O
if	O
(	O
mu_cfg_assert_value_type	function
(	O
val	array
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
num	long
=	O
get_port	function
(	O
val	array
->	O
v	pointer
.	O
string	pointer
)	O
;	O
if	O
(	O
!	O
num	long
)	O
return	O
1	int
;	O
hp	pointer
->	O
port	int
=	O
num	long
;	O
return	O
0	int
;	O
}	O
static	O
struct	O
mu_cfg_param	struct
dot_server_cfg_param	array
[	O
]	O
=	O
{	O
{	O
"max-children"	pointer
,	O
mu_c_size	int
,	O
NULL	O
,	O
mu_offsetof	O
(	O
struct	O
_mu_m_server	struct
,	O
max_children	long
)	O
,	O
NULL	O
,	O
N_	O
(	O
"Maximum number of children processes to run simultaneously."	pointer
)	O
}	O
,	O
{	O
"mode"	pointer
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
mu_offsetof	O
(	O
struct	O
_mu_m_server	struct
,	O
mode	int
)	O
,	O
_cb_daemon_mode	function
,	O
N_	O
(	O
"Set operation mode."	pointer
)	O
,	O
N_	O
(	O
"mode: inetd|interactive|daemon"	pointer
)	O
}	O
,	O
{	O
"foreground"	pointer
,	O
mu_c_bool	int
,	O
NULL	O
,	O
mu_offsetof	O
(	O
struct	O
_mu_m_server	struct
,	O
foreground	int
)	O
,	O
NULL	O
,	O
N_	O
(	O
"Run in foreground."	pointer
)	O
}	O
,	O
{	O
"pidfile"	pointer
,	O
mu_c_string	int
,	O
NULL	O
,	O
mu_offsetof	O
(	O
struct	O
_mu_m_server	struct
,	O
pidfile	pointer
)	O
,	O
NULL	O
,	O
N_	O
(	O
"Store PID of the master process in this file."	pointer
)	O
,	O
N_	O
(	O
"file"	pointer
)	O
}	O
,	O
{	O
"port"	pointer
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
mu_offsetof	O
(	O
struct	O
_mu_m_server	struct
,	O
hints	pointer
)	O
,	O
_cb_port	function
,	O
N_	O
(	O
"Default port number."	pointer
)	O
,	O
N_	O
(	O
"arg: port number or service name"	pointer
)	O
}	O
,	O
{	O
"timeout"	pointer
,	O
mu_c_time	int
,	O
NULL	O
,	O
mu_offsetof	O
(	O
struct	O
_mu_m_server	struct
,	O
timeout	long
)	O
,	O
NULL	O
,	O
N_	O
(	O
"Set idle timeout."	pointer
)	O
}	O
,	O
{	O
"server"	pointer
,	O
mu_cfg_section	int
,	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"Server configuration."	pointer
)	O
}	O
,	O
{	O
"acl"	pointer
,	O
mu_cfg_section	int
,	O
NULL	O
,	O
mu_offsetof	O
(	O
struct	O
_mu_m_server	struct
,	O
acl	pointer
)	O
,	O
NULL	O
,	O
N_	O
(	O
"Per-server access control list"	pointer
)	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
struct	O
mu_cfg_param	struct
server_cfg_param	array
[	O
]	O
=	O
{	O
{	O
"single-process"	pointer
,	O
mu_c_bool	int
,	O
NULL	O
,	O
mu_offsetof	O
(	O
struct	O
mu_srv_config	struct
,	O
single_process	int
)	O
,	O
NULL	O
,	O
N_	O
(	O
"Do not spawn sub-process to handle requests in this server."	pointer
)	O
}	O
,	O
{	O
"transcript"	pointer
,	O
mu_c_bool	int
,	O
NULL	O
,	O
mu_offsetof	O
(	O
struct	O
mu_srv_config	struct
,	O
transcript	int
)	O
,	O
NULL	O
,	O
N_	O
(	O
"Log the session transcript."	pointer
)	O
}	O
,	O
{	O
"timeout"	pointer
,	O
mu_c_time	int
,	O
NULL	O
,	O
mu_offsetof	O
(	O
struct	O
mu_srv_config	struct
,	O
timeout	long
)	O
,	O
NULL	O
,	O
N_	O
(	O
"Set idle timeout."	pointer
)	O
}	O
,	O
{	O
"acl"	pointer
,	O
mu_cfg_section	int
,	O
NULL	O
,	O
mu_offsetof	O
(	O
struct	O
mu_srv_config	struct
,	O
acl	pointer
)	O
,	O
NULL	O
,	O
N_	O
(	O
"Global access control list."	pointer
)	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
int	O
_cb_backlog	function
(	O
void	O
*	O
data	pointer
,	O
mu_config_value_t	struct
*	O
val	array
)	O
{	O
mu_ip_server_t	pointer
*	O
psrv	pointer
=	O
data	pointer
;	O
int	O
backlog	int
;	O
if	O
(	O
mu_cfg_assert_value_type	function
(	O
val	array
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
sscanf	function
(	O
val	array
->	O
v	pointer
.	O
string	pointer
,	O
"%d"	pointer
,	O
&	O
backlog	int
)	O
!=	O
1	int
||	O
backlog	int
<=	O
0	int
||	O
mu_tcp_server_set_backlog	function
(	O
*	O
psrv	pointer
,	O
backlog	int
)	O
)	O
{	O
mu_error	function
(	O
_	O
(	O
"invalid argument"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
mu_cfg_param	struct
server_tcp_param	array
[	O
]	O
=	O
{	O
{	O
"backlog"	pointer
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
mu_offsetof	O
(	O
struct	O
mu_srv_config	struct
,	O
tcpsrv	pointer
)	O
,	O
_cb_backlog	function
,	O
N_	O
(	O
"Size of the queue of pending connections"	pointer
)	O
,	O
N_	O
(	O
"number"	pointer
)	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
void	O
mu_m_server_cfg_init	function
(	O
mu_m_server_t	pointer
srv	pointer
,	O
struct	O
mu_cfg_param	struct
*	O
app_param	pointer
)	O
{	O
struct	O
mu_cfg_section	int
*	O
section	struct
;	O
if	O
(	O
mu_create_canned_section	function
(	O
"server"	pointer
,	O
&	O
section	struct
)	O
==	O
0	int
)	O
{	O
section	struct
->	O
parser	pointer
=	O
server_section_parser	function
;	O
section	struct
->	O
label	pointer
=	O
N_	O
(	O
"ipaddr[:port]"	pointer
)	O
;	O
mu_cfg_section_add_params	function
(	O
section	struct
,	O
server_cfg_param	array
)	O
;	O
if	O
(	O
srv	pointer
->	O
deftype	int
==	O
MU_IP_TCP	int
)	O
mu_cfg_section_add_params	function
(	O
section	struct
,	O
server_tcp_param	array
)	O
;	O
if	O
(	O
app_param	pointer
)	O
mu_cfg_section_add_params	function
(	O
section	struct
,	O
app_param	pointer
)	O
;	O
}	O
if	O
(	O
mu_create_canned_section	function
(	O
".server"	pointer
,	O
&	O
section	struct
)	O
==	O
0	int
)	O
{	O
mu_cfg_section_add_params	function
(	O
section	struct
,	O
dot_server_cfg_param	array
)	O
;	O
}	O
}	O
