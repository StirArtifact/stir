static	O
const	O
char	O
sccsid	array
[	O
]	O
=	O
"@(#)mp_cmpr.c	1.1 (Senga) 01/08/99"	pointer
;	O
static	O
int	O
__memp_cmpr_page	function
__P	O
(	O
(	O
DB_MPOOLFILE	struct
*	O
,	O
CMPR	struct
*	O
,	O
DB_IO	struct
*	O
,	O
ssize_t	long
*	O
)	O
)	O
;	O
static	O
DB_CMPR_INFO	struct
default_cmpr_info	struct
=	O
{	O
CDB___memp_cmpr_deflate	function
,	O
CDB___memp_cmpr_inflate	function
,	O
1	int
,	O
3	int
,	O
NULL	O
}	O
;	O
int	O
CDB___memp_cmpr	function
(	O
dbmfp	pointer
,	O
bhp	pointer
,	O
db_io	pointer
,	O
flag	int
,	O
niop	pointer
)	O
DB_MPOOLFILE	struct
*	O
dbmfp	pointer
;	O
BH	struct
*	O
bhp	pointer
;	O
DB_IO	struct
*	O
db_io	pointer
;	O
int	O
flag	int
;	O
ssize_t	long
*	O
niop	pointer
;	O
{	O
size_t	long
orig_pagesize	long
=	O
db_io	pointer
->	O
pagesize	long
;	O
db_pgno_t	int
orig_pgno	int
=	O
db_io	pointer
->	O
pgno	int
;	O
size_t	long
orig_bytes	long
=	O
db_io	pointer
->	O
bytes	long
;	O
DB_ENV	struct
*	O
dbenv	pointer
=	O
dbmfp	pointer
->	O
dbmp	pointer
->	O
dbenv	pointer
;	O
int	O
ret	int
=	O
0	int
;	O
db_io	pointer
->	O
pagesize	long
=	O
CMPR_DIVIDE	O
(	O
db_io	pointer
->	O
pagesize	long
)	O
;	O
db_io	pointer
->	O
bytes	long
=	O
CMPR_DIVIDE	O
(	O
db_io	pointer
->	O
bytes	long
)	O
;	O
switch	O
(	O
flag	int
)	O
{	O
case	O
DB_IO_READ	int
:	O
if	O
(	O
db_io	pointer
->	O
pgno	int
==	O
PGNO_BASE_MD	int
)	O
{	O
ret	int
=	O
CDB___os_io	function
(	O
dbenv	pointer
,	O
db_io	pointer
,	O
DB_IO_READ	int
,	O
(	O
size_t	long
*	O
)	O
niop	pointer
)	O
;	O
*	O
niop	pointer
=	O
CMPR_MULTIPLY	O
(	O
*	O
niop	pointer
)	O
;	O
}	O
else	O
ret	int
=	O
CDB___memp_cmpr_read	function
(	O
dbmfp	pointer
,	O
bhp	pointer
,	O
db_io	pointer
,	O
niop	pointer
)	O
;	O
break	O
;	O
case	O
DB_IO_WRITE	int
:	O
if	O
(	O
db_io	pointer
->	O
pgno	int
==	O
PGNO_BASE_MD	int
)	O
{	O
size_t	long
required	long
=	O
db_io	pointer
->	O
pagesize	long
;	O
size_t	long
orig_bytes	long
=	O
db_io	pointer
->	O
bytes	long
;	O
db_io	pointer
->	O
bytes	long
=	O
DBMETASIZE	int
;	O
for	O
(	O
db_io	pointer
->	O
pagesize	long
=	O
DBMETASIZE	int
;	O
db_io	pointer
->	O
pagesize	long
<	O
required	long
;	O
db_io	pointer
->	O
pagesize	long
<<=	O
1	int
)	O
{	O
ret	int
=	O
CDB___os_io	function
(	O
dbenv	pointer
,	O
db_io	pointer
,	O
DB_IO_WRITE	int
,	O
(	O
size_t	long
*	O
)	O
niop	pointer
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
||	O
*	O
niop	pointer
!=	O
DBMETASIZE	int
)	O
break	O
;	O
}	O
db_io	pointer
->	O
bytes	long
=	O
orig_bytes	long
;	O
db_io	pointer
->	O
pagesize	long
=	O
required	long
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
ret	int
=	O
CDB___os_io	function
(	O
dbenv	pointer
,	O
db_io	pointer
,	O
DB_IO_WRITE	int
,	O
(	O
size_t	long
*	O
)	O
niop	pointer
)	O
;	O
*	O
niop	pointer
=	O
CMPR_MULTIPLY	O
(	O
*	O
niop	pointer
)	O
;	O
}	O
else	O
ret	int
=	O
CDB___memp_cmpr_write	function
(	O
dbmfp	pointer
,	O
bhp	pointer
,	O
db_io	pointer
,	O
niop	pointer
)	O
;	O
break	O
;	O
}	O
db_io	pointer
->	O
pgno	int
=	O
orig_pgno	int
;	O
db_io	pointer
->	O
pagesize	long
=	O
orig_pagesize	long
;	O
db_io	pointer
->	O
bytes	long
=	O
orig_bytes	long
;	O
return	O
ret	int
;	O
}	O
int	O
CDB___memp_cmpr_read_meta	function
(	O
dbenv	pointer
,	O
fhp	pointer
,	O
buff	pointer
,	O
buff_length	long
,	O
nrp	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_FH	struct
*	O
fhp	pointer
;	O
void	O
*	O
buff	pointer
;	O
size_t	long
buff_length	long
;	O
ssize_t	long
*	O
nrp	pointer
;	O
{	O
CMPR	struct
cmpr	struct
;	O
int	O
ret	int
;	O
size_t	long
i	long
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_read	function
(	O
dbenv	pointer
,	O
fhp	pointer
,	O
buff	pointer
,	O
buff_length	long
,	O
(	O
size_t	long
*	O
)	O
nrp	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
size_t	long
)	O
*	O
nrp	pointer
!=	O
buff_length	long
)	O
goto	O
err	pointer
;	O
memcpy	function
(	O
&	O
cmpr	struct
,	O
buff	pointer
,	O
sizeof	O
(	O
CMPR	struct
)	O
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
&	O
cmpr	struct
,	O
DB_CMPR_FREE	int
)	O
||	O
F_ISSET	O
(	O
&	O
cmpr	struct
,	O
DB_CMPR_INTERNAL	int
)	O
)	O
{	O
ret	int
=	O
CDB___db_panic	function
(	O
dbenv	pointer
,	O
EINVAL	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
buff_length	long
-	O
(	O
DB_CMPR_OVERHEAD	O
+	O
1	int
)	O
;	O
i	long
++	O
)	O
(	O
(	O
char	O
*	O
)	O
buff	pointer
)	O
[	O
i	long
]	O
=	O
(	O
(	O
char	O
*	O
)	O
buff	pointer
)	O
[	O
i	long
+	O
(	O
DB_CMPR_OVERHEAD	O
+	O
1	int
)	O
]	O
;	O
err	pointer
:	O
return	O
ret	int
;	O
}	O
int	O
CDB___memp_cmpr_read	function
(	O
dbmfp	pointer
,	O
bhp	pointer
,	O
db_io	pointer
,	O
niop	pointer
)	O
DB_MPOOLFILE	struct
*	O
dbmfp	pointer
;	O
BH	struct
*	O
bhp	pointer
;	O
DB_IO	struct
*	O
db_io	pointer
;	O
ssize_t	long
*	O
niop	pointer
;	O
{	O
CMPR	struct
cmpr	struct
;	O
int	O
ret	int
;	O
int	O
chain	pointer
=	O
0	int
;	O
u_int8_t	char
*	O
buffcmpr	pointer
=	O
0	int
;	O
int	O
buffcmpr_length	int
=	O
0	int
;	O
int	O
chain_length	int
=	O
0	int
;	O
db_pgno_t	int
first_pgno	int
=	O
db_io	pointer
->	O
pgno	int
;	O
DB_ENV	struct
*	O
dbenv	pointer
=	O
dbmfp	pointer
->	O
dbmp	pointer
->	O
dbenv	pointer
;	O
DB_CMPR_INFO	struct
*	O
cmpr_info	pointer
=	O
dbenv	pointer
->	O
mp_cmpr_info	pointer
;	O
F_CLR	O
(	O
bhp	pointer
,	O
BH_CMPR	int
)	O
;	O
ret	int
=	O
CDB___os_io	function
(	O
dbenv	pointer
,	O
db_io	pointer
,	O
DB_IO_READ	int
,	O
(	O
size_t	long
*	O
)	O
niop	pointer
)	O
;	O
if	O
(	O
ret	int
||	O
(	O
size_t	long
)	O
*	O
niop	pointer
<	O
db_io	pointer
->	O
pagesize	long
)	O
goto	O
err	pointer
;	O
memcpy	function
(	O
&	O
cmpr	struct
,	O
db_io	pointer
->	O
buf	pointer
,	O
sizeof	O
(	O
CMPR	struct
)	O
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
&	O
cmpr	struct
,	O
DB_CMPR_FREE	int
)	O
||	O
F_ISSET	O
(	O
&	O
cmpr	struct
,	O
DB_CMPR_INTERNAL	int
)	O
)	O
{	O
ret	int
=	O
__memp_cmpr_page	function
(	O
dbmfp	pointer
,	O
&	O
cmpr	struct
,	O
db_io	pointer
,	O
niop	pointer
)	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
!	O
F_ISSET	O
(	O
&	O
cmpr	struct
,	O
DB_CMPR_FIRST	int
)	O
)	O
{	O
CDB___db_err	function
(	O
dbmfp	pointer
->	O
dbmp	pointer
->	O
dbenv	pointer
,	O
"CDB___memp_cmpr_read: expected DB_CMPR_FIRST flag set at pgno = %ld"	pointer
,	O
db_io	pointer
->	O
pgno	int
)	O
;	O
ret	int
=	O
CDB___db_panic	function
(	O
dbmfp	pointer
->	O
dbmp	pointer
->	O
dbenv	pointer
,	O
EINVAL	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbenv	pointer
,	O
db_io	pointer
->	O
pagesize	long
*	O
CMPR_MAX	O
,	O
NULL	O
,	O
&	O
buffcmpr	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
do	O
{	O
memcpy	function
(	O
buffcmpr	pointer
+	O
buffcmpr_length	int
,	O
DB_CMPR_DATA	O
(	O
db_io	pointer
)	O
,	O
DB_CMPR_PAGESIZE	O
(	O
db_io	pointer
)	O
)	O
;	O
buffcmpr_length	int
+=	O
DB_CMPR_PAGESIZE	O
(	O
db_io	pointer
)	O
;	O
F_CLR	O
(	O
&	O
cmpr	struct
,	O
DB_CMPR_FIRST	int
|	O
DB_CMPR_INTERNAL	int
)	O
;	O
chain	pointer
=	O
cmpr	struct
.	O
flags	int
;	O
if	O
(	O
chain	pointer
==	O
DB_CMPR_CHAIN	int
)	O
{	O
chain_length	int
++	O
;	O
if	O
(	O
chain_length	int
>=	O
CMPR_MAX	O
)	O
{	O
CDB___db_err	function
(	O
dbmfp	pointer
->	O
dbmp	pointer
->	O
dbenv	pointer
,	O
"CDB___memp_cmpr_read: compression chain too long at pgno = %ld"	pointer
,	O
db_io	pointer
->	O
pgno	int
)	O
;	O
ret	int
=	O
CDB___db_panic	function
(	O
dbmfp	pointer
->	O
dbmp	pointer
->	O
dbenv	pointer
,	O
EINVAL	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
cmpr	struct
.	O
next	int
==	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbmfp	pointer
->	O
dbmp	pointer
->	O
dbenv	pointer
,	O
"CDB___memp_cmpr_read: cmpr.next is null at pgno = %ld"	pointer
,	O
chain	pointer
,	O
db_io	pointer
->	O
pgno	int
)	O
;	O
ret	int
=	O
CDB___db_panic	function
(	O
dbmfp	pointer
->	O
dbmp	pointer
->	O
dbenv	pointer
,	O
EINVAL	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
CDB___memp_cmpr_alloc_chain	function
(	O
dbmfp	pointer
->	O
dbmp	pointer
,	O
bhp	pointer
,	O
BH_CMPR_POOL	int
)	O
;	O
bhp	pointer
->	O
chain	pointer
[	O
chain_length	int
-	O
1	int
]	O
=	O
cmpr	struct
.	O
next	int
;	O
db_io	pointer
->	O
pgno	int
=	O
cmpr	struct
.	O
next	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_io	function
(	O
dbenv	pointer
,	O
db_io	pointer
,	O
DB_IO_READ	int
,	O
(	O
size_t	long
*	O
)	O
niop	pointer
)	O
)	O
!=	O
0	int
||	O
(	O
size_t	long
)	O
*	O
niop	pointer
!=	O
db_io	pointer
->	O
pagesize	long
)	O
{	O
ret	int
=	O
EIO	int
;	O
goto	O
err	pointer
;	O
}	O
memcpy	function
(	O
&	O
cmpr	struct
,	O
db_io	pointer
->	O
buf	pointer
,	O
sizeof	O
(	O
CMPR	struct
)	O
)	O
;	O
}	O
else	O
if	O
(	O
chain	pointer
!=	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbmfp	pointer
->	O
dbmp	pointer
->	O
dbenv	pointer
,	O
"CDB___memp_cmpr_read: unexpected compression flag value 0x%x at pgno = %ld"	pointer
,	O
chain	pointer
,	O
db_io	pointer
->	O
pgno	int
)	O
;	O
ret	int
=	O
CDB___db_panic	function
(	O
dbmfp	pointer
->	O
dbmp	pointer
->	O
dbenv	pointer
,	O
ret	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
else	O
if	O
(	O
cmpr	struct
.	O
next	int
!=	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbmfp	pointer
->	O
dbmp	pointer
->	O
dbenv	pointer
,	O
"CDB___memp_cmpr_read: cmpr.next is not null at pgno = %ld"	pointer
,	O
chain	pointer
,	O
db_io	pointer
->	O
pgno	int
)	O
;	O
ret	int
=	O
CDB___db_panic	function
(	O
dbmfp	pointer
->	O
dbmp	pointer
->	O
dbenv	pointer
,	O
ret	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
}	O
while	O
(	O
chain	pointer
)	O
;	O
{	O
switch	O
(	O
(	O
*	O
buffcmpr	pointer
)	O
&	O
TYPE_MASK	int
)	O
{	O
case	O
P_HASHMETA	int
:	O
case	O
P_BTREEMETA	int
:	O
case	O
P_QAMMETA	int
:	O
case	O
P_INVALID	int
:	O
memcpy	function
(	O
db_io	pointer
->	O
buf	pointer
,	O
buffcmpr	pointer
+	O
sizeof	O
(	O
char	O
)	O
,	O
255	int
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
(	O
ret	int
=	O
(	O
*	O
cmpr_info	pointer
->	O
uncompress	pointer
)	O
(	O
dbenv	pointer
,	O
buffcmpr	pointer
,	O
buffcmpr_length	int
,	O
db_io	pointer
->	O
buf	pointer
,	O
CMPR_MULTIPLY	O
(	O
db_io	pointer
->	O
pagesize	long
)	O
,	O
cmpr_info	pointer
->	O
user_data	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbmfp	pointer
->	O
dbmp	pointer
->	O
dbenv	pointer
,	O
"CDB___memp_cmpr_read: unable to uncompress page at pgno = %ld"	pointer
,	O
first_pgno	int
)	O
;	O
ret	int
=	O
CDB___db_panic	function
(	O
dbmfp	pointer
->	O
dbmp	pointer
->	O
dbenv	pointer
,	O
ret	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
break	O
;	O
}	O
}	O
*	O
niop	pointer
=	O
CMPR_MULTIPLY	O
(	O
db_io	pointer
->	O
pagesize	long
)	O
;	O
err	pointer
:	O
if	O
(	O
buffcmpr	pointer
)	O
CDB___os_free	function
(	O
buffcmpr	pointer
,	O
0	int
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
CDB___memp_cmpr_write	function
(	O
dbmfp	pointer
,	O
bhp	pointer
,	O
db_io	pointer
,	O
niop	pointer
)	O
DB_MPOOLFILE	struct
*	O
dbmfp	pointer
;	O
BH	struct
*	O
bhp	pointer
;	O
DB_IO	struct
*	O
db_io	pointer
;	O
ssize_t	long
*	O
niop	pointer
;	O
{	O
CMPR	struct
cmpr	struct
;	O
int	O
chain_length	int
=	O
0	int
;	O
int	O
first_nonreused_chain_pos	int
=	O
0	int
;	O
int	O
ret	int
;	O
u_int8_t	char
*	O
buffcmpr	pointer
=	O
0	int
;	O
u_int8_t	char
*	O
buffp	pointer
;	O
int	O
buffcmpr_length	int
;	O
u_int8_t	char
*	O
orig_buff	pointer
=	O
db_io	pointer
->	O
buf	pointer
;	O
DB_ENV	struct
*	O
dbenv	pointer
=	O
dbmfp	pointer
->	O
dbmp	pointer
->	O
dbenv	pointer
;	O
DB_CMPR_INFO	struct
*	O
cmpr_info	pointer
=	O
dbenv	pointer
->	O
mp_cmpr_info	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbenv	pointer
,	O
CMPR_MULTIPLY	O
(	O
db_io	pointer
->	O
bytes	long
)	O
,	O
NULL	O
,	O
&	O
db_io	pointer
->	O
buf	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
{	O
PAGE	struct
*	O
pp	pointer
=	O
(	O
PAGE	struct
*	O
)	O
orig_buff	pointer
;	O
switch	O
(	O
TYPE	O
(	O
pp	pointer
)	O
)	O
{	O
case	O
P_HASHMETA	int
:	O
case	O
P_BTREEMETA	int
:	O
case	O
P_QAMMETA	int
:	O
case	O
P_INVALID	int
:	O
buffcmpr_length	int
=	O
256	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbenv	pointer
,	O
buffcmpr_length	int
,	O
NULL	O
,	O
&	O
buffcmpr	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
buffcmpr	pointer
[	O
0	int
]	O
=	O
TYPE_TAGS	O
(	O
pp	pointer
)	O
;	O
memcpy	function
(	O
buffcmpr	pointer
+	O
1	int
,	O
orig_buff	pointer
,	O
255	int
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
(	O
ret	int
=	O
(	O
*	O
cmpr_info	pointer
->	O
compress	pointer
)	O
(	O
dbenv	pointer
,	O
orig_buff	pointer
,	O
CMPR_MULTIPLY	O
(	O
db_io	pointer
->	O
pagesize	long
)	O
,	O
&	O
buffcmpr	pointer
,	O
&	O
buffcmpr_length	int
,	O
cmpr_info	pointer
->	O
user_data	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbmfp	pointer
->	O
dbmp	pointer
->	O
dbenv	pointer
,	O
"CDB___memp_cmpr_write: unable to compress page at pgno = %ld"	pointer
,	O
db_io	pointer
->	O
pgno	int
)	O
;	O
ret	int
=	O
CDB___db_panic	function
(	O
dbmfp	pointer
->	O
dbmp	pointer
->	O
dbenv	pointer
,	O
ret	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
}	O
}	O
if	O
(	O
(	O
size_t	long
)	O
buffcmpr_length	int
>	O
(	O
size_t	long
)	O
(	O
DB_CMPR_PAGESIZE	O
(	O
db_io	pointer
)	O
*	O
CMPR_MAX	O
)	O
)	O
{	O
CDB___db_err	function
(	O
dbmfp	pointer
->	O
dbmp	pointer
->	O
dbenv	pointer
,	O
"CDB___memp_cmpr_write: compressed data is too big at pgno = %ld"	pointer
,	O
db_io	pointer
->	O
pgno	int
)	O
;	O
ret	int
=	O
CDB___db_panic	function
(	O
dbmfp	pointer
->	O
dbmp	pointer
->	O
dbenv	pointer
,	O
EINVAL	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
buffp	pointer
=	O
buffcmpr	pointer
;	O
cmpr	struct
.	O
flags	int
=	O
DB_CMPR_FIRST	int
;	O
cmpr	struct
.	O
next	int
=	O
0	int
;	O
do	O
{	O
size_t	long
length	long
=	O
buffcmpr_length	int
-	O
(	O
buffp	pointer
-	O
buffcmpr	pointer
)	O
;	O
size_t	long
copy_length	long
=	O
(	O
size_t	long
)	O
length	long
>	O
DB_CMPR_PAGESIZE	O
(	O
db_io	pointer
)	O
?	O
DB_CMPR_PAGESIZE	O
(	O
db_io	pointer
)	O
:	O
length	long
;	O
if	O
(	O
length	long
>	O
copy_length	long
)	O
{	O
chain_length	int
++	O
;	O
if	O
(	O
chain_length	int
>=	O
CMPR_MAX	O
)	O
{	O
CDB___db_err	function
(	O
dbmfp	pointer
->	O
dbmp	pointer
->	O
dbenv	pointer
,	O
"CDB___memp_cmpr_write: chain_length overflow"	pointer
)	O
;	O
ret	int
=	O
CDB___db_panic	function
(	O
dbmfp	pointer
->	O
dbmp	pointer
->	O
dbenv	pointer
,	O
EINVAL	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
F_SET	O
(	O
&	O
cmpr	struct
,	O
DB_CMPR_CHAIN	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___memp_cmpr_alloc	function
(	O
dbmfp	pointer
,	O
&	O
cmpr	struct
.	O
next	int
,	O
db_io	pointer
->	O
pagesize	long
,	O
bhp	pointer
,	O
&	O
first_nonreused_chain_pos	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
CDB___memp_cmpr_alloc_chain	function
(	O
dbmfp	pointer
->	O
dbmp	pointer
,	O
bhp	pointer
,	O
BH_CMPR_OS	int
)	O
;	O
bhp	pointer
->	O
chain	pointer
[	O
chain_length	int
-	O
1	int
]	O
=	O
cmpr	struct
.	O
next	int
;	O
}	O
memcpy	function
(	O
db_io	pointer
->	O
buf	pointer
,	O
&	O
cmpr	struct
,	O
DB_CMPR_OVERHEAD	O
)	O
;	O
memcpy	function
(	O
db_io	pointer
->	O
buf	pointer
+	O
DB_CMPR_OVERHEAD	O
,	O
buffp	pointer
,	O
copy_length	long
)	O
;	O
buffp	pointer
+=	O
copy_length	long
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_io	function
(	O
dbenv	pointer
,	O
db_io	pointer
,	O
DB_IO_WRITE	int
,	O
(	O
size_t	long
*	O
)	O
niop	pointer
)	O
)	O
!=	O
0	int
||	O
(	O
size_t	long
)	O
*	O
niop	pointer
!=	O
db_io	pointer
->	O
pagesize	long
)	O
{	O
ret	int
=	O
EIO	int
;	O
goto	O
err	pointer
;	O
}	O
db_io	pointer
->	O
pgno	int
=	O
cmpr	struct
.	O
next	int
;	O
cmpr	struct
.	O
flags	int
=	O
DB_CMPR_INTERNAL	int
;	O
cmpr	struct
.	O
next	int
=	O
0	int
;	O
}	O
while	O
(	O
buffp	pointer
-	O
buffcmpr	pointer
<	O
buffcmpr_length	int
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
bhp	pointer
,	O
BH_CMPR	int
)	O
&&	O
first_nonreused_chain_pos	int
>=	O
0	int
)	O
{	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
first_nonreused_chain_pos	int
;	O
i	long
<	O
(	O
CMPR_MAX	O
-	O
1	int
)	O
&&	O
bhp	pointer
->	O
chain	pointer
[	O
i	long
]	O
;	O
i	long
++	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___memp_cmpr_free	function
(	O
dbmfp	pointer
,	O
bhp	pointer
->	O
chain	pointer
[	O
i	long
]	O
,	O
db_io	pointer
->	O
pagesize	long
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
bhp	pointer
->	O
chain	pointer
[	O
i	long
]	O
=	O
0	int
;	O
}	O
}	O
CDB___memp_cmpr_free_chain	function
(	O
dbmfp	pointer
->	O
dbmp	pointer
,	O
bhp	pointer
)	O
;	O
*	O
niop	pointer
=	O
CMPR_MULTIPLY	O
(	O
db_io	pointer
->	O
pagesize	long
)	O
;	O
err	pointer
:	O
CDB___os_free	function
(	O
db_io	pointer
->	O
buf	pointer
,	O
0	int
)	O
;	O
db_io	pointer
->	O
buf	pointer
=	O
orig_buff	pointer
;	O
if	O
(	O
buffcmpr	pointer
)	O
CDB___os_free	function
(	O
buffcmpr	pointer
,	O
0	int
)	O
;	O
return	O
ret	int
;	O
}	O
static	O
int	O
__memp_cmpr_page	function
(	O
dbmfp	pointer
,	O
cmpr	struct
,	O
db_io	pointer
,	O
niop	pointer
)	O
DB_MPOOLFILE	struct
*	O
dbmfp	pointer
;	O
CMPR	struct
*	O
cmpr	struct
;	O
DB_IO	struct
*	O
db_io	pointer
;	O
ssize_t	long
*	O
niop	pointer
;	O
{	O
DB_ENV	struct
*	O
dbenv	pointer
=	O
dbmfp	pointer
->	O
dbmp	pointer
->	O
dbenv	pointer
;	O
int	O
ret	int
=	O
0	int
;	O
PAGE	struct
page	pointer
;	O
memset	function
(	O
(	O
char	O
*	O
)	O
&	O
page	pointer
,	O
'\0'	O
,	O
sizeof	O
(	O
PAGE	struct
)	O
)	O
;	O
page	pointer
.	O
pgno	int
=	O
db_io	pointer
->	O
pgno	int
;	O
page	pointer
.	O
type	enum
=	O
F_ISSET	O
(	O
cmpr	struct
,	O
DB_CMPR_FREE	int
)	O
?	O
P_CMPR_FREE	int
:	O
P_CMPR_INTERNAL	int
;	O
if	O
(	O
db_io	pointer
->	O
pagesize	long
<	O
sizeof	O
(	O
PAGE	struct
)	O
)	O
{	O
ret	int
=	O
ENOMEM	int
;	O
goto	O
err	pointer
;	O
}	O
memcpy	function
(	O
db_io	pointer
->	O
buf	pointer
,	O
(	O
char	O
*	O
)	O
&	O
page	pointer
,	O
sizeof	O
(	O
PAGE	struct
)	O
)	O
;	O
*	O
niop	pointer
=	O
CMPR_MULTIPLY	O
(	O
db_io	pointer
->	O
pagesize	long
)	O
;	O
err	pointer
:	O
return	O
ret	int
;	O
}	O
int	O
CDB___memp_cmpr_inflate	function
(	O
dbenv	pointer
,	O
inbuff	pointer
,	O
inbuff_length	int
,	O
outbuff	pointer
,	O
outbuff_length	int
,	O
user_data	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
const	O
u_int8_t	char
*	O
inbuff	pointer
;	O
int	O
inbuff_length	int
;	O
u_int8_t	char
*	O
outbuff	pointer
;	O
int	O
outbuff_length	int
;	O
void	O
*	O
user_data	pointer
;	O
{	O
if	O
(	O
dbenv	pointer
||	O
user_data	pointer
)	O
{	O
}	O
int	O
ret	int
=	O
0	int
;	O
z_stream	struct
c_stream	struct
;	O
c_stream	struct
.	O
zalloc	pointer
=	O
(	O
alloc_func	pointer
)	O
0	int
;	O
c_stream	struct
.	O
zfree	pointer
=	O
(	O
free_func	pointer
)	O
0	int
;	O
c_stream	struct
.	O
opaque	pointer
=	O
(	O
voidpf	pointer
)	O
0	int
;	O
c_stream	struct
.	O
next_in	pointer
=	O
(	O
Bytef	char
*	O
)	O
inbuff	pointer
;	O
c_stream	struct
.	O
avail_in	int
=	O
inbuff_length	int
;	O
c_stream	struct
.	O
next_out	pointer
=	O
outbuff	pointer
;	O
c_stream	struct
.	O
avail_out	int
=	O
outbuff_length	int
;	O
if	O
(	O
inflateInit	O
(	O
&	O
c_stream	struct
)	O
!=	O
Z_OK	int
||	O
inflate	function
(	O
&	O
c_stream	struct
,	O
Z_FINISH	int
)	O
!=	O
Z_STREAM_END	int
||	O
inflateEnd	function
(	O
&	O
c_stream	struct
)	O
!=	O
Z_OK	int
)	O
ret	int
=	O
EIO	int
;	O
if	O
(	O
c_stream	struct
.	O
avail_out	int
!=	O
0	int
)	O
ret	int
=	O
EIO	int
;	O
return	O
ret	int
;	O
}	O
int	O
CDB___memp_cmpr_deflate	function
(	O
dbenv	pointer
,	O
inbuff	pointer
,	O
inbuff_length	int
,	O
outbuffp	pointer
,	O
outbuff_lengthp	pointer
,	O
user_data	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
const	O
u_int8_t	char
*	O
inbuff	pointer
;	O
int	O
inbuff_length	int
;	O
u_int8_t	char
*	O
*	O
outbuffp	pointer
;	O
int	O
*	O
outbuff_lengthp	pointer
;	O
void	O
*	O
user_data	pointer
;	O
{	O
if	O
(	O
dbenv	pointer
||	O
user_data	pointer
)	O
{	O
}	O
int	O
ret	int
=	O
0	int
;	O
int	O
r	int
;	O
z_stream	struct
c_stream	struct
;	O
u_int8_t	char
*	O
outbuff	pointer
;	O
int	O
outbuff_length	int
=	O
inbuff_length	int
+	O
(	O
inbuff_length	int
>>	O
9	int
)	O
+	O
12	int
;	O
*	O
outbuffp	pointer
=	O
0	int
;	O
*	O
outbuff_lengthp	pointer
=	O
0	int
;	O
if	O
(	O
CDB___os_malloc	function
(	O
dbenv	pointer
,	O
outbuff_length	int
,	O
NULL	O
,	O
&	O
outbuff	pointer
)	O
!=	O
0	int
)	O
{	O
ret	int
=	O
ENOMEM	int
;	O
goto	O
err	pointer
;	O
}	O
{	O
PAGE	struct
*	O
pg	pointer
=	O
(	O
PAGE	struct
*	O
)	O
inbuff	pointer
;	O
switch	O
(	O
TYPE	O
(	O
pg	pointer
)	O
)	O
{	O
case	O
P_IBTREE	int
:	O
case	O
P_LBTREE	int
:	O
memset	function
(	O
(	O
char	O
*	O
)	O
(	O
inbuff	pointer
+	O
LOFFSET	O
(	O
pg	pointer
)	O
)	O
,	O
'\0'	O
,	O
P_FREESPACE	O
(	O
pg	pointer
)	O
)	O
;	O
break	O
;	O
}	O
}	O
c_stream	struct
.	O
zalloc	pointer
=	O
(	O
alloc_func	pointer
)	O
0	int
;	O
c_stream	struct
.	O
zfree	pointer
=	O
(	O
free_func	pointer
)	O
0	int
;	O
c_stream	struct
.	O
opaque	pointer
=	O
(	O
voidpf	pointer
)	O
0	int
;	O
if	O
(	O
deflateInit	O
(	O
&	O
c_stream	struct
,	O
Z_DEFAULT_COMPRESSION	O
)	O
!=	O
Z_OK	int
)	O
{	O
ret	int
=	O
EIO	int
;	O
goto	O
err	pointer
;	O
}	O
c_stream	struct
.	O
next_in	pointer
=	O
(	O
Bytef	char
*	O
)	O
inbuff	pointer
;	O
c_stream	struct
.	O
avail_in	int
=	O
inbuff_length	int
;	O
c_stream	struct
.	O
next_out	pointer
=	O
outbuff	pointer
;	O
c_stream	struct
.	O
avail_out	int
=	O
outbuff_length	int
;	O
while	O
(	O
(	O
r	int
=	O
deflate	function
(	O
&	O
c_stream	struct
,	O
Z_FINISH	int
)	O
)	O
!=	O
Z_STREAM_END	int
&&	O
r	int
==	O
Z_OK	int
)	O
;	O
if	O
(	O
r	int
!=	O
Z_STREAM_END	int
)	O
ret	int
=	O
EIO	int
;	O
if	O
(	O
deflateEnd	function
(	O
&	O
c_stream	struct
)	O
!=	O
Z_OK	int
)	O
ret	int
=	O
EIO	int
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
{	O
*	O
outbuffp	pointer
=	O
outbuff	pointer
;	O
*	O
outbuff_lengthp	pointer
=	O
outbuff_length	int
-	O
c_stream	struct
.	O
avail_out	int
;	O
}	O
else	O
{	O
CDB___os_free	function
(	O
outbuff	pointer
,	O
outbuff_length	int
)	O
;	O
}	O
err	pointer
:	O
return	O
ret	int
;	O
}	O
static	O
int	O
__memp_cmpr_info_valid	function
(	O
dbenv	pointer
,	O
cmpr_info	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_CMPR_INFO	struct
*	O
cmpr_info	pointer
;	O
{	O
int	O
ret	int
=	O
0	int
;	O
if	O
(	O
!	O
cmpr_info	pointer
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"__memp_cmpr_info_valid: cmpr_info == NULL"	pointer
)	O
;	O
ret	int
=	O
CDB___db_panic	function
(	O
dbenv	pointer
,	O
EINVAL	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
!	O
cmpr_info	pointer
->	O
compress	pointer
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"__memp_cmpr_info_valid: compress == NULL!"	pointer
)	O
;	O
ret	int
=	O
CDB___db_panic	function
(	O
dbenv	pointer
,	O
EINVAL	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
!	O
cmpr_info	pointer
->	O
uncompress	pointer
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"__memp_cmpr_info_valid: uncompress == NULL!"	pointer
)	O
;	O
ret	int
=	O
CDB___db_panic	function
(	O
dbenv	pointer
,	O
EINVAL	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
cmpr_info	pointer
->	O
coefficient	char
==	O
0	int
||	O
cmpr_info	pointer
->	O
coefficient	char
>	O
5	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"__memp_cmpr_info_valid:  coefficient should be > 0 and < 5 coefficient=%d "	pointer
,	O
cmpr_info	pointer
->	O
coefficient	char
)	O
;	O
ret	int
=	O
CDB___db_panic	function
(	O
dbenv	pointer
,	O
EINVAL	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
cmpr_info	pointer
->	O
max_npages	char
==	O
0	int
||	O
cmpr_info	pointer
->	O
max_npages	char
>	O
128	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"__memp_cmpr_info_valid:  max_npages should be > 0 and < 128 max_npages=%d "	pointer
,	O
cmpr_info	pointer
->	O
max_npages	char
)	O
;	O
ret	int
=	O
CDB___db_panic	function
(	O
dbenv	pointer
,	O
EINVAL	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
err	pointer
:	O
return	O
ret	int
;	O
}	O
u_int8_t	char
CDB___memp_cmpr_coefficient	function
(	O
dbenv	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
{	O
u_int8_t	char
ret	int
=	O
0	int
;	O
if	O
(	O
!	O
dbenv	pointer
||	O
!	O
dbenv	pointer
->	O
mp_cmpr_info	pointer
)	O
{	O
ret	int
=	O
default_cmpr_info	struct
.	O
coefficient	char
;	O
}	O
else	O
{	O
__memp_cmpr_info_valid	function
(	O
dbenv	pointer
,	O
dbenv	pointer
->	O
mp_cmpr_info	pointer
)	O
;	O
ret	int
=	O
dbenv	pointer
->	O
mp_cmpr_info	pointer
->	O
coefficient	char
;	O
}	O
return	O
(	O
ret	int
)	O
;	O
}	O
typedef	O
struct	O
_cmprmeta	struct
{	O
u_int32_t	int
magic	int
;	O
db_pgno_t	int
free	int
;	O
}	O
CMPRMETA	struct
;	O
int	O
CDB___memp_cmpr_create	function
(	O
dbenv	pointer
,	O
fhp	pointer
,	O
pgsize	int
,	O
flags	int
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_FH	struct
*	O
fhp	pointer
;	O
size_t	long
pgsize	int
;	O
int	O
flags	int
;	O
{	O
int	O
ret	int
;	O
int	O
count	int
=	O
0	int
;	O
CMPRMETA	struct
meta	struct
;	O
char	O
*	O
buffer	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbenv	pointer
,	O
pgsize	int
,	O
NULL	O
,	O
&	O
buffer	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB___memp_cmpr_create: os_malloc %d bytes failed:%d"	pointer
,	O
pgsize	int
,	O
ret	int
)	O
;	O
ret	int
=	O
CDB___db_panic	function
(	O
dbenv	pointer
,	O
EINVAL	int
)	O
;	O
return	O
ret	int
;	O
}	O
meta	struct
.	O
magic	int
=	O
flags	int
==	O
MP_CMPR	int
?	O
CMPR_META_COMPRESSED	int
:	O
CMPR_META_NORMAL	int
;	O
meta	struct
.	O
free	int
=	O
PGNO_INVALID	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_seek	function
(	O
dbenv	pointer
,	O
fhp	pointer
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
DB_OS_SEEK_SET	int
)	O
)	O
!=	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB___memp_cmpr_create: seek to 0 error"	pointer
)	O
;	O
return	O
CDB___db_panic	function
(	O
dbenv	pointer
,	O
ret	int
)	O
;	O
}	O
memcpy	function
(	O
buffer	pointer
,	O
(	O
char	O
*	O
)	O
&	O
meta	struct
,	O
sizeof	O
(	O
CMPRMETA	struct
)	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_write	function
(	O
dbenv	pointer
,	O
fhp	pointer
,	O
buffer	pointer
,	O
pgsize	int
,	O
(	O
size_t	long
*	O
)	O
&	O
count	int
)	O
)	O
<	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB___memp_cmpr_create: write error at 0"	pointer
)	O
;	O
return	O
CDB___db_panic	function
(	O
dbenv	pointer
,	O
ret	int
)	O
;	O
}	O
if	O
(	O
(	O
size_t	long
)	O
count	int
!=	O
pgsize	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB___memp_cmpr_create: write error %d bytes instead of %d bytes"	pointer
,	O
count	int
,	O
pgsize	int
)	O
;	O
return	O
CDB___db_panic	function
(	O
dbenv	pointer
,	O
EINVAL	int
)	O
;	O
}	O
CDB___os_free	function
(	O
buffer	pointer
,	O
pgsize	int
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
CDB___memp_cmpr_open	function
(	O
dbenv	pointer
,	O
mfp	pointer
,	O
path	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
MPOOLFILE	struct
*	O
mfp	pointer
;	O
const	O
char	O
*	O
path	pointer
;	O
{	O
int	O
ret	int
;	O
DB_FH	struct
fh	struct
;	O
ssize_t	long
count	int
;	O
CMPRMETA	struct
meta	struct
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_open	function
(	O
dbenv	pointer
,	O
path	pointer
,	O
DB_OSO_RDONLY	int
,	O
0	int
,	O
&	O
fh	struct
)	O
)	O
!=	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB___memp_cmpr_open: cannot open %s readonly"	pointer
,	O
path	pointer
)	O
;	O
return	O
CDB___db_panic	function
(	O
dbenv	pointer
,	O
ret	int
)	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_read	function
(	O
dbenv	pointer
,	O
&	O
fh	struct
,	O
(	O
void	O
*	O
)	O
&	O
meta	struct
,	O
sizeof	O
(	O
CMPRMETA	struct
)	O
,	O
(	O
size_t	long
*	O
)	O
&	O
count	int
)	O
)	O
!=	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB___memp_cmpr_open: cannot read page 0"	pointer
)	O
;	O
ret	int
=	O
CDB___db_panic	function
(	O
dbenv	pointer
,	O
ret	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
count	int
!=	O
sizeof	O
(	O
CMPRMETA	struct
)	O
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB___memp_cmpr_open: read error %d bytes instead of %d bytes"	pointer
,	O
count	int
,	O
sizeof	O
(	O
CMPRMETA	struct
)	O
)	O
;	O
ret	int
=	O
CDB___db_panic	function
(	O
dbenv	pointer
,	O
EINVAL	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
meta	struct
.	O
magic	int
==	O
CMPR_META_COMPRESSED	int
)	O
{	O
mfp	pointer
->	O
flags	int
|=	O
MP_CMPR	int
;	O
mfp	pointer
->	O
cmpr_free	int
=	O
meta	struct
.	O
free	int
;	O
if	O
(	O
!	O
dbenv	pointer
->	O
mp_cmpr_info	pointer
)	O
{	O
if	O
(	O
default_cmpr_info	struct
.	O
compress	pointer
==	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB___memp_cmpr_open: zlib compression not available, re-compile --with-zlib=DIR"	pointer
)	O
;	O
ret	int
=	O
CDB___db_panic	function
(	O
dbenv	pointer
,	O
EINVAL	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
dbenv	pointer
->	O
mp_cmpr_info	pointer
=	O
&	O
default_cmpr_info	struct
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
__memp_cmpr_info_valid	function
(	O
dbenv	pointer
,	O
dbenv	pointer
->	O
mp_cmpr_info	pointer
)	O
)	O
)	O
goto	O
err	pointer
;	O
}	O
err	pointer
:	O
CDB___os_closehandle	function
(	O
&	O
fh	struct
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
CDB___memp_cmpr_close	function
(	O
dbenv	pointer
,	O
dbmfp	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_MPOOLFILE	struct
*	O
dbmfp	pointer
;	O
{	O
if	O
(	O
dbmfp	pointer
->	O
flags	int
&	O
MP_UPGRADE	int
)	O
{	O
MPOOLFILE	struct
*	O
mfp	pointer
=	O
dbmfp	pointer
->	O
mfp	pointer
;	O
DB_FH	struct
*	O
fhp	pointer
=	O
&	O
dbmfp	pointer
->	O
fh	struct
;	O
size_t	long
count	int
=	O
0	int
;	O
int	O
ret	int
;	O
CMPRMETA	struct
meta	struct
;	O
memset	function
(	O
(	O
char	O
*	O
)	O
&	O
meta	struct
,	O
'\0'	O
,	O
sizeof	O
(	O
CMPRMETA	struct
)	O
)	O
;	O
meta	struct
.	O
magic	int
=	O
mfp	pointer
->	O
flags	int
&	O
MP_CMPR	int
?	O
CMPR_META_COMPRESSED	int
:	O
CMPR_META_NORMAL	int
;	O
if	O
(	O
mfp	pointer
->	O
flags	int
&	O
MP_CMPR	int
)	O
meta	struct
.	O
free	int
=	O
mfp	pointer
->	O
cmpr_free	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_seek	function
(	O
dbenv	pointer
,	O
fhp	pointer
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
DB_OS_SEEK_SET	int
)	O
)	O
!=	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB___memp_cmpr_close: seek to 0 error"	pointer
)	O
;	O
return	O
CDB___db_panic	function
(	O
dbenv	pointer
,	O
ret	int
)	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_write	function
(	O
dbenv	pointer
,	O
fhp	pointer
,	O
(	O
void	O
*	O
)	O
&	O
meta	struct
,	O
sizeof	O
(	O
CMPRMETA	struct
)	O
,	O
&	O
count	int
)	O
)	O
<	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB___memp_cmpr_close: write error at 0"	pointer
)	O
;	O
return	O
CDB___db_panic	function
(	O
dbenv	pointer
,	O
ret	int
)	O
;	O
}	O
if	O
(	O
count	int
!=	O
sizeof	O
(	O
CMPRMETA	struct
)	O
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB___memp_cmpr_close: write error %d bytes instead of %d bytes"	pointer
,	O
count	int
,	O
sizeof	O
(	O
CMPRMETA	struct
)	O
)	O
;	O
return	O
CDB___db_panic	function
(	O
dbenv	pointer
,	O
EINVAL	int
)	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
int	O
CDB___memp_cmpr_alloc	function
(	O
dbmfp	pointer
,	O
pgnop	pointer
,	O
pagesize	long
,	O
bhp	pointer
,	O
first_nonreused_chain_posp	pointer
)	O
DB_MPOOLFILE	struct
*	O
dbmfp	pointer
;	O
db_pgno_t	int
*	O
pgnop	pointer
;	O
size_t	long
pagesize	long
;	O
BH	struct
*	O
bhp	pointer
;	O
int	O
*	O
first_nonreused_chain_posp	pointer
;	O
{	O
DB_ENV	struct
*	O
dbenv	pointer
=	O
dbmfp	pointer
->	O
dbmp	pointer
->	O
dbenv	pointer
;	O
int	O
ret	int
=	O
0	int
;	O
if	O
(	O
F_ISSET	O
(	O
bhp	pointer
,	O
BH_CMPR	int
)	O
&&	O
bhp	pointer
->	O
chain	pointer
==	O
NULL	O
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB___memp_cmpr_alloc: BH_CMPR set and bhp->chain == NULL"	pointer
)	O
;	O
ret	int
=	O
CDB___db_panic	function
(	O
dbenv	pointer
,	O
EINVAL	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
(	O
*	O
first_nonreused_chain_posp	pointer
)	O
>=	O
(	O
CMPR_MAX	O
-	O
1	int
)	O
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB___memp_cmpr_alloc: first_nonreused_chain_pos >= (CMPR_MAX - 1)"	pointer
)	O
;	O
ret	int
=	O
CDB___db_panic	function
(	O
dbenv	pointer
,	O
EINVAL	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
(	O
*	O
first_nonreused_chain_posp	pointer
)	O
>=	O
0	int
&&	O
F_ISSET	O
(	O
bhp	pointer
,	O
BH_CMPR	int
)	O
&&	O
bhp	pointer
->	O
chain	pointer
[	O
*	O
first_nonreused_chain_posp	pointer
]	O
)	O
{	O
*	O
pgnop	pointer
=	O
bhp	pointer
->	O
chain	pointer
[	O
*	O
first_nonreused_chain_posp	pointer
]	O
;	O
(	O
*	O
first_nonreused_chain_posp	pointer
)	O
++	O
;	O
}	O
else	O
{	O
MPOOLFILE	struct
*	O
mfp	pointer
=	O
dbmfp	pointer
->	O
mfp	pointer
;	O
DB_MPOOL	struct
*	O
dbmp	pointer
=	O
dbmfp	pointer
->	O
dbmp	pointer
;	O
(	O
*	O
first_nonreused_chain_posp	pointer
)	O
=	O
-	O
1	int
;	O
R_LOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
if	O
(	O
mfp	pointer
->	O
cmpr_free	int
==	O
PGNO_INVALID	int
)	O
{	O
ret	int
=	O
0	int
;	O
++	O
dbmfp	pointer
->	O
mfp	pointer
->	O
last_pgno	int
;	O
*	O
pgnop	pointer
=	O
dbmfp	pointer
->	O
mfp	pointer
->	O
last_pgno	int
;	O
}	O
else	O
{	O
CMPR	struct
cmpr	struct
;	O
size_t	long
count	int
;	O
DB_FH	struct
*	O
fhp	pointer
=	O
&	O
dbmfp	pointer
->	O
fh	struct
;	O
*	O
pgnop	pointer
=	O
mfp	pointer
->	O
cmpr_free	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_seek	function
(	O
dbenv	pointer
,	O
fhp	pointer
,	O
pagesize	long
,	O
*	O
pgnop	pointer
,	O
0	int
,	O
0	int
,	O
DB_OS_SEEK_SET	int
)	O
)	O
!=	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB___memp_cmpr_alloc: seek error at %d"	pointer
,	O
*	O
pgnop	pointer
)	O
;	O
ret	int
=	O
CDB___db_panic	function
(	O
dbenv	pointer
,	O
ret	int
)	O
;	O
goto	O
oops	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_read	function
(	O
dbenv	pointer
,	O
fhp	pointer
,	O
(	O
void	O
*	O
)	O
&	O
cmpr	struct
,	O
sizeof	O
(	O
CMPR	struct
)	O
,	O
&	O
count	int
)	O
)	O
!=	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB___memp_cmpr_alloc: read error at %d"	pointer
,	O
*	O
pgnop	pointer
)	O
;	O
ret	int
=	O
CDB___db_panic	function
(	O
dbenv	pointer
,	O
ret	int
)	O
;	O
goto	O
oops	O
;	O
}	O
if	O
(	O
count	int
!=	O
sizeof	O
(	O
CMPR	struct
)	O
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB___memp_cmpr_alloc: read error %d bytes instead of %d bytes"	pointer
,	O
count	int
,	O
sizeof	O
(	O
CMPR	struct
)	O
)	O
;	O
ret	int
=	O
CDB___db_panic	function
(	O
dbenv	pointer
,	O
ret	int
)	O
;	O
goto	O
oops	O
;	O
}	O
if	O
(	O
cmpr	struct
.	O
flags	int
!=	O
DB_CMPR_FREE	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB___memp_cmpr_alloc: got %d flags instead of DB_CMPR_FREE"	pointer
,	O
cmpr	struct
.	O
flags	int
)	O
;	O
ret	int
=	O
CDB___db_panic	function
(	O
dbenv	pointer
,	O
ret	int
)	O
;	O
goto	O
oops	O
;	O
}	O
mfp	pointer
->	O
cmpr_free	int
=	O
cmpr	struct
.	O
next	int
;	O
if	O
(	O
*	O
pgnop	pointer
==	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB___memp_cmpr_alloc: unexpected pgno == 0"	pointer
)	O
;	O
ret	int
=	O
CDB___db_panic	function
(	O
dbenv	pointer
,	O
ret	int
)	O
;	O
goto	O
oops	O
;	O
}	O
}	O
oops	O
:	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
}	O
err	pointer
:	O
return	O
ret	int
;	O
}	O
int	O
CDB___memp_cmpr_free	function
(	O
dbmfp	pointer
,	O
pgno	int
,	O
pagesize	long
)	O
DB_MPOOLFILE	struct
*	O
dbmfp	pointer
;	O
db_pgno_t	int
pgno	int
;	O
size_t	long
pagesize	long
;	O
{	O
int	O
ret	int
=	O
0	int
;	O
DB_ENV	struct
*	O
dbenv	pointer
=	O
dbmfp	pointer
->	O
dbmp	pointer
->	O
dbenv	pointer
;	O
MPOOLFILE	struct
*	O
mfp	pointer
=	O
dbmfp	pointer
->	O
mfp	pointer
;	O
DB_MPOOL	struct
*	O
dbmp	pointer
=	O
dbmfp	pointer
->	O
dbmp	pointer
;	O
DB_FH	struct
*	O
fhp	pointer
=	O
&	O
dbmfp	pointer
->	O
fh	struct
;	O
CMPR	struct
cmpr	struct
;	O
size_t	long
count	int
;	O
R_LOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
cmpr	struct
.	O
flags	int
=	O
DB_CMPR_FREE	int
;	O
cmpr	struct
.	O
next	int
=	O
mfp	pointer
->	O
cmpr_free	int
;	O
mfp	pointer
->	O
cmpr_free	int
=	O
pgno	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_seek	function
(	O
dbenv	pointer
,	O
fhp	pointer
,	O
pagesize	long
,	O
pgno	int
,	O
0	int
,	O
0	int
,	O
DB_OS_SEEK_SET	int
)	O
)	O
!=	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB___memp_cmpr_free: seek error at %d"	pointer
,	O
pgno	int
)	O
;	O
ret	int
=	O
CDB___db_panic	function
(	O
dbenv	pointer
,	O
ret	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_write	function
(	O
dbenv	pointer
,	O
fhp	pointer
,	O
(	O
void	O
*	O
)	O
&	O
cmpr	struct
,	O
sizeof	O
(	O
CMPR	struct
)	O
,	O
&	O
count	int
)	O
)	O
<	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB___memp_cmpr_free: write error at %d"	pointer
,	O
pgno	int
)	O
;	O
ret	int
=	O
CDB___db_panic	function
(	O
dbenv	pointer
,	O
ret	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
count	int
!=	O
sizeof	O
(	O
CMPR	struct
)	O
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB___memp_cmpr_free: write error %d bytes instead of %d bytes"	pointer
,	O
count	int
,	O
sizeof	O
(	O
CMPR	struct
)	O
)	O
;	O
ret	int
=	O
CDB___db_panic	function
(	O
dbenv	pointer
,	O
ret	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
err	pointer
:	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
CDB___memp_cmpr_alloc_chain	function
(	O
dbmp	pointer
,	O
bhp	pointer
,	O
alloc_type	int
)	O
DB_MPOOL	struct
*	O
dbmp	pointer
;	O
BH	struct
*	O
bhp	pointer
;	O
int	O
alloc_type	int
;	O
{	O
DB_ENV	struct
*	O
dbenv	pointer
=	O
dbmp	pointer
->	O
dbenv	pointer
;	O
int	O
ret	int
=	O
0	int
;	O
if	O
(	O
!	O
bhp	pointer
->	O
chain	pointer
)	O
{	O
int	O
alloc_ret	int
;	O
int	O
alloc_length	int
=	O
sizeof	O
(	O
db_pgno_t	int
)	O
*	O
(	O
CMPR_MAX	O
-	O
1	int
)	O
;	O
switch	O
(	O
alloc_type	int
)	O
{	O
case	O
BH_CMPR_POOL	int
:	O
{	O
MPOOL	struct
*	O
mp	pointer
=	O
dbmp	pointer
->	O
reginfo	pointer
[	O
0	int
]	O
.	O
primary	int
;	O
int	O
n_cache	int
=	O
NCACHE	O
(	O
mp	pointer
,	O
bhp	pointer
->	O
pgno	int
)	O
;	O
alloc_ret	int
=	O
CDB___memp_alloc	function
(	O
dbmp	pointer
,	O
&	O
dbmp	pointer
->	O
reginfo	pointer
[	O
n_cache	int
]	O
,	O
NULL	O
,	O
alloc_length	int
,	O
NULL	O
,	O
(	O
void	O
*	O
)	O
(	O
&	O
bhp	pointer
->	O
chain	pointer
)	O
)	O
;	O
F_SET	O
(	O
bhp	pointer
,	O
BH_CMPR_POOL	int
)	O
;	O
}	O
break	O
;	O
case	O
BH_CMPR_OS	int
:	O
alloc_ret	int
=	O
CDB___os_malloc	function
(	O
dbenv	pointer
,	O
alloc_length	int
,	O
NULL	O
,	O
&	O
bhp	pointer
->	O
chain	pointer
)	O
;	O
F_SET	O
(	O
bhp	pointer
,	O
BH_CMPR_OS	int
)	O
;	O
break	O
;	O
default	O
:	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB___memp_cmpr_alloc_chain: unknown alloc type :%d"	pointer
,	O
alloc_type	int
)	O
;	O
ret	int
=	O
CDB___db_panic	function
(	O
dbenv	pointer
,	O
EINVAL	int
)	O
;	O
goto	O
err	pointer
;	O
break	O
;	O
}	O
if	O
(	O
alloc_ret	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB___memp_cmpr_alloc_chain: memp_alloc %d bytes failed:%d"	pointer
,	O
alloc_length	int
,	O
alloc_ret	int
)	O
;	O
ret	int
=	O
CDB___db_panic	function
(	O
dbenv	pointer
,	O
EINVAL	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
memset	function
(	O
(	O
void	O
*	O
)	O
bhp	pointer
->	O
chain	pointer
,	O
0	int
,	O
alloc_length	int
)	O
;	O
}	O
else	O
{	O
}	O
F_SET	O
(	O
bhp	pointer
,	O
BH_CMPR	int
)	O
;	O
err	pointer
:	O
return	O
ret	int
;	O
}	O
int	O
CDB___memp_cmpr_free_chain	function
(	O
dbmp	pointer
,	O
bhp	pointer
)	O
DB_MPOOL	struct
*	O
dbmp	pointer
;	O
BH	struct
*	O
bhp	pointer
;	O
{	O
DB_ENV	struct
*	O
dbenv	pointer
=	O
dbmp	pointer
->	O
dbenv	pointer
;	O
if	O
(	O
F_ISSET	O
(	O
bhp	pointer
,	O
BH_CMPR	int
)	O
)	O
{	O
if	O
(	O
bhp	pointer
->	O
chain	pointer
)	O
{	O
int	O
alloc_length	int
=	O
sizeof	O
(	O
db_pgno_t	int
)	O
*	O
(	O
CMPR_MAX	O
-	O
1	int
)	O
;	O
int	O
alloc_type	int
=	O
bhp	pointer
->	O
flags	int
&	O
(	O
BH_CMPR_POOL	int
|	O
BH_CMPR_OS	int
)	O
;	O
switch	O
(	O
alloc_type	int
)	O
{	O
case	O
BH_CMPR_POOL	int
:	O
{	O
MPOOL	struct
*	O
mp	pointer
=	O
dbmp	pointer
->	O
reginfo	pointer
[	O
0	int
]	O
.	O
primary	int
;	O
int	O
n_cache	int
=	O
NCACHE	O
(	O
mp	pointer
,	O
bhp	pointer
->	O
pgno	int
)	O
;	O
CDB___db_shalloc_free	function
(	O
dbmp	pointer
->	O
reginfo	pointer
[	O
n_cache	int
]	O
.	O
addr	pointer
,	O
bhp	pointer
->	O
chain	pointer
)	O
;	O
}	O
break	O
;	O
case	O
BH_CMPR_OS	int
:	O
CDB___os_free	function
(	O
bhp	pointer
->	O
chain	pointer
,	O
alloc_length	int
)	O
;	O
break	O
;	O
default	O
:	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB___memp_cmpr_free_chain: unknown alloc type :%d"	pointer
,	O
alloc_type	int
)	O
;	O
return	O
CDB___db_panic	function
(	O
dbenv	pointer
,	O
EINVAL	int
)	O
;	O
break	O
;	O
}	O
bhp	pointer
->	O
chain	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB___memp_cmpr_free_chain: BH_CMPR set but null bhp->chain"	pointer
)	O
;	O
return	O
CDB___db_panic	function
(	O
dbenv	pointer
,	O
EINVAL	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
bhp	pointer
->	O
chain	pointer
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB___memp_cmpr_free_chain: BH_CMPR not set but bhp->chain not null"	pointer
)	O
;	O
return	O
CDB___db_panic	function
(	O
dbenv	pointer
,	O
EINVAL	int
)	O
;	O
}	O
F_CLR	O
(	O
bhp	pointer
,	O
BH_CMPR	int
|	O
BH_CMPR_OS	int
|	O
BH_CMPR_POOL	int
)	O
;	O
return	O
0	int
;	O
}	O
