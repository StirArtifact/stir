char	O
ackbuf	array
[	O
PKTSIZE	O
]	O
;	O
int	O
timeout	int
;	O
jmp_buf	array
timeoutbuf	array
;	O
static	O
void	O
nak	function
(	O
int	O
)	O
;	O
static	O
int	O
makerequest	function
(	O
int	O
,	O
const	O
char	O
*	O
,	O
struct	O
tftphdr	struct
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
void	O
printstats	function
(	O
const	O
char	O
*	O
,	O
unsigned	O
long	O
)	O
;	O
static	O
void	O
startclock	function
(	O
void	O
)	O
;	O
static	O
void	O
stopclock	function
(	O
void	O
)	O
;	O
static	O
void	O
timer	function
(	O
int	O
)	O
;	O
static	O
void	O
tpacket	function
(	O
const	O
char	O
*	O
,	O
struct	O
tftphdr	struct
*	O
,	O
int	O
)	O
;	O
static	O
int	O
rexmtval	int
=	O
TIMEOUT	int
;	O
static	O
int	O
maxtimeout	int
=	O
5	int
*	O
TIMEOUT	int
;	O
static	O
struct	O
sockaddr_storage	struct
peeraddr	struct
;	O
static	O
socklen_t	int
peerlen	int
;	O
static	O
int	O
f	int
=	O
-	O
1	int
;	O
static	O
int	O
port	int
;	O
static	O
int	O
trace	int
;	O
static	O
int	O
verbose	int
;	O
static	O
int	O
connected	int
;	O
char	O
mode	array
[	O
32	int
]	O
;	O
char	O
line	pointer
[	O
200	int
]	O
;	O
int	O
margc	int
;	O
char	O
*	O
margv	array
[	O
20	int
]	O
;	O
char	O
*	O
prompt	pointer
=	O
"tftp"	pointer
;	O
jmp_buf	array
toplevel	array
;	O
void	O
intr	function
(	O
int	O
signo	int
)	O
;	O
void	O
get	function
(	O
int	O
,	O
char	O
*	O
*	O
)	O
;	O
void	O
help	function
(	O
int	O
,	O
char	O
*	O
*	O
)	O
;	O
void	O
modecmd	function
(	O
int	O
,	O
char	O
*	O
*	O
)	O
;	O
void	O
put	function
(	O
int	O
,	O
char	O
*	O
*	O
)	O
;	O
void	O
quit	function
(	O
int	O
,	O
char	O
*	O
*	O
)	O
;	O
void	O
setascii	function
(	O
int	O
,	O
char	O
*	O
*	O
)	O
;	O
void	O
setbinary	function
(	O
int	O
,	O
char	O
*	O
*	O
)	O
;	O
void	O
setpeer	function
(	O
int	O
,	O
char	O
*	O
*	O
)	O
;	O
void	O
setrexmt	function
(	O
int	O
,	O
char	O
*	O
*	O
)	O
;	O
void	O
settimeout	function
(	O
int	O
,	O
char	O
*	O
*	O
)	O
;	O
void	O
settrace	function
(	O
int	O
,	O
char	O
*	O
*	O
)	O
;	O
void	O
setverbose	function
(	O
int	O
,	O
char	O
*	O
*	O
)	O
;	O
void	O
status	int
(	O
int	O
,	O
char	O
*	O
*	O
)	O
;	O
static	O
void	O
command	function
(	O
void	O
)	O
;	O
static	O
void	O
getusage	function
(	O
char	O
*	O
)	O
;	O
static	O
void	O
makeargv	function
(	O
void	O
)	O
;	O
static	O
void	O
putusage	function
(	O
char	O
*	O
)	O
;	O
static	O
void	O
settftpmode	function
(	O
char	O
*	O
)	O
;	O
static	O
in_port_t	short
get_port	function
(	O
struct	O
sockaddr_storage	struct
*	O
)	O
;	O
static	O
void	O
set_port	function
(	O
struct	O
sockaddr_storage	struct
*	O
,	O
in_port_t	short
)	O
;	O
struct	O
cmd	struct
{	O
char	O
*	O
name	pointer
;	O
char	O
*	O
help	function
;	O
void	O
(	O
*	O
handler	pointer
)	O
(	O
int	O
,	O
char	O
*	O
*	O
)	O
;	O
}	O
;	O
char	O
vhelp	array
[	O
]	O
=	O
"toggle verbose mode"	pointer
;	O
char	O
thelp	array
[	O
]	O
=	O
"toggle packet tracing"	pointer
;	O
char	O
chelp	array
[	O
]	O
=	O
"connect to remote tftp"	pointer
;	O
char	O
qhelp	array
[	O
]	O
=	O
"exit tftp"	pointer
;	O
char	O
hhelp	array
[	O
]	O
=	O
"print help information"	pointer
;	O
char	O
shelp	array
[	O
]	O
=	O
"send file"	pointer
;	O
char	O
rhelp	array
[	O
]	O
=	O
"receive file"	pointer
;	O
char	O
mhelp	array
[	O
]	O
=	O
"set file transfer mode"	pointer
;	O
char	O
sthelp	array
[	O
]	O
=	O
"show current status"	pointer
;	O
char	O
xhelp	array
[	O
]	O
=	O
"set per-packet retransmission timeout"	pointer
;	O
char	O
ihelp	array
[	O
]	O
=	O
"set total retransmission timeout"	pointer
;	O
char	O
ashelp	array
[	O
]	O
=	O
"set mode to netascii"	pointer
;	O
char	O
bnhelp	array
[	O
]	O
=	O
"set mode to octet"	pointer
;	O
struct	O
cmd	struct
cmdtab	array
[	O
]	O
=	O
{	O
{	O
"connect"	pointer
,	O
chelp	array
,	O
setpeer	function
}	O
,	O
{	O
"mode"	pointer
,	O
mhelp	array
,	O
modecmd	function
}	O
,	O
{	O
"put"	pointer
,	O
shelp	array
,	O
put	function
}	O
,	O
{	O
"get"	pointer
,	O
rhelp	array
,	O
get	function
}	O
,	O
{	O
"quit"	pointer
,	O
qhelp	array
,	O
quit	function
}	O
,	O
{	O
"verbose"	pointer
,	O
vhelp	array
,	O
setverbose	function
}	O
,	O
{	O
"trace"	pointer
,	O
thelp	array
,	O
settrace	function
}	O
,	O
{	O
"status"	pointer
,	O
sthelp	array
,	O
status	int
}	O
,	O
{	O
"binary"	pointer
,	O
bnhelp	array
,	O
setbinary	function
}	O
,	O
{	O
"ascii"	pointer
,	O
ashelp	array
,	O
setascii	function
}	O
,	O
{	O
"rexmt"	pointer
,	O
xhelp	array
,	O
setrexmt	function
}	O
,	O
{	O
"timeout"	pointer
,	O
ihelp	array
,	O
settimeout	function
}	O
,	O
{	O
"?"	pointer
,	O
hhelp	array
,	O
help	function
}	O
,	O
{	O
0	int
}	O
}	O
;	O
struct	O
cmd	struct
*	O
getcmd	function
(	O
register	O
char	O
*	O
name	pointer
)	O
;	O
char	O
*	O
tail	function
(	O
char	O
*	O
filename	pointer
)	O
;	O
const	O
char	O
args_doc	pointer
[	O
]	O
=	O
"[HOST [PORT]]"	pointer
;	O
const	O
char	O
doc	pointer
[	O
]	O
=	O
"Trivial file transfer protocol client"	pointer
;	O
static	O
struct	O
argp_option	struct
argp_options	array
[	O
]	O
=	O
{	O
{	O
"verbose"	pointer
,	O
'v'	O
,	O
NULL	O
,	O
0	int
,	O
"verbose output"	pointer
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
char	O
*	O
hostport_argv	array
[	O
3	int
]	O
=	O
{	O
"connect"	pointer
}	O
;	O
int	O
hostport_argc	int
=	O
1	int
;	O
static	O
in_port_t	short
get_port	function
(	O
struct	O
sockaddr_storage	struct
*	O
ss	pointer
)	O
{	O
switch	O
(	O
ss	pointer
->	O
ss_family	short
)	O
{	O
case	O
AF_INET6	O
:	O
return	O
ntohs	function
(	O
(	O
(	O
struct	O
sockaddr_in6	struct
*	O
)	O
ss	pointer
)	O
->	O
sin6_port	short
)	O
;	O
break	O
;	O
case	O
AF_INET	O
:	O
default	O
:	O
return	O
ntohs	function
(	O
(	O
(	O
struct	O
sockaddr_in	struct
*	O
)	O
ss	pointer
)	O
->	O
sin_port	short
)	O
;	O
break	O
;	O
}	O
}	O
static	O
void	O
set_port	function
(	O
struct	O
sockaddr_storage	struct
*	O
ss	pointer
,	O
in_port_t	short
port	int
)	O
{	O
switch	O
(	O
ss	pointer
->	O
ss_family	short
)	O
{	O
case	O
AF_INET6	O
:	O
(	O
(	O
struct	O
sockaddr_in6	struct
*	O
)	O
ss	pointer
)	O
->	O
sin6_port	short
=	O
htons	function
(	O
port	int
)	O
;	O
break	O
;	O
case	O
AF_INET	O
:	O
default	O
:	O
(	O
(	O
struct	O
sockaddr_in	struct
*	O
)	O
ss	pointer
)	O
->	O
sin_port	short
=	O
htons	function
(	O
port	int
)	O
;	O
break	O
;	O
}	O
}	O
void	O
recvfile	function
(	O
int	O
,	O
char	O
*	O
,	O
char	O
*	O
)	O
;	O
void	O
send_file	function
(	O
int	O
,	O
char	O
*	O
,	O
char	O
*	O
)	O
;	O
static	O
error_t	int
parse_opt	function
(	O
int	O
key	int
,	O
char	O
*	O
arg	pointer
,	O
struct	O
argp_state	struct
*	O
state	pointer
)	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
'v'	O
:	O
verbose	int
++	O
;	O
break	O
;	O
case	O
ARGP_KEY_ARG	int
:	O
if	O
(	O
state	pointer
->	O
arg_num	int
>=	O
2	int
||	O
hostport_argc	int
>=	O
3	int
)	O
argp_usage	function
(	O
state	pointer
)	O
;	O
hostport_argv	array
[	O
hostport_argc	int
++	O
]	O
=	O
arg	pointer
;	O
break	O
;	O
default	O
:	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
argp	struct
argp	struct
=	O
{	O
argp_options	array
,	O
parse_opt	function
,	O
args_doc	pointer
,	O
doc	pointer
}	O
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
struct	O
servent	struct
*	O
sp	pointer
;	O
set_program_name	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
iu_argp_init	O
(	O
"tftp"	pointer
,	O
default_program_authors	array
)	O
;	O
argp_parse	function
(	O
&	O
argp	struct
,	O
argc	int
,	O
argv	pointer
,	O
0	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
sp	pointer
=	O
getservbyname	function
(	O
"tftp"	pointer
,	O
"udp"	pointer
)	O
;	O
if	O
(	O
sp	pointer
==	O
0	int
)	O
port	int
=	O
69	int
;	O
else	O
port	int
=	O
ntohs	function
(	O
sp	pointer
->	O
s_port	int
)	O
;	O
strcpy	function
(	O
mode	array
,	O
"netascii"	pointer
)	O
;	O
signal	function
(	O
SIGINT	int
,	O
intr	function
)	O
;	O
if	O
(	O
hostport_argc	int
>	O
1	int
)	O
{	O
if	O
(	O
setjmp	function
(	O
toplevel	array
)	O
!=	O
0	int
)	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
setpeer	function
(	O
hostport_argc	int
,	O
hostport_argv	array
)	O
;	O
}	O
if	O
(	O
setjmp	function
(	O
toplevel	array
)	O
!=	O
0	int
)	O
putchar	function
(	O
'\n'	O
)	O
;	O
command	function
(	O
)	O
;	O
}	O
char	O
*	O
hostname	pointer
;	O
static	O
int	O
resolve_name	function
(	O
char	O
*	O
name	pointer
)	O
{	O
int	O
err	long
;	O
struct	O
sockaddr_storage	struct
ss	pointer
;	O
struct	O
addrinfo	struct
hints	struct
,	O
*	O
ai	pointer
,	O
*	O
aiptr	pointer
;	O
memset	function
(	O
&	O
hints	struct
,	O
0	int
,	O
sizeof	O
(	O
hints	struct
)	O
)	O
;	O
hints	struct
.	O
ai_family	int
=	O
AF_UNSPEC	O
;	O
hints	struct
.	O
ai_socktype	int
=	O
SOCK_DGRAM	int
;	O
hints	struct
.	O
ai_flags	int
=	O
AI_CANONNAME	int
;	O
hints	struct
.	O
ai_flags	int
+=	O
AI_ADDRCONFIG	int
;	O
err	long
=	O
getaddrinfo	function
(	O
name	pointer
,	O
"tftp"	pointer
,	O
&	O
hints	struct
,	O
&	O
aiptr	pointer
)	O
;	O
if	O
(	O
err	long
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"tftp: %s: %s\n"	pointer
,	O
name	pointer
,	O
gai_strerror	function
(	O
err	long
)	O
)	O
;	O
return	O
RESOLVE_FAIL	O
;	O
}	O
if	O
(	O
f	int
>=	O
0	int
)	O
{	O
close	pointer
(	O
f	int
)	O
;	O
f	int
=	O
-	O
1	int
;	O
}	O
for	O
(	O
ai	pointer
=	O
aiptr	pointer
;	O
ai	pointer
;	O
ai	pointer
=	O
ai	pointer
->	O
ai_next	pointer
)	O
{	O
f	int
=	O
socket	function
(	O
ai	pointer
->	O
ai_family	int
,	O
ai	pointer
->	O
ai_socktype	int
,	O
ai	pointer
->	O
ai_protocol	int
)	O
;	O
if	O
(	O
f	int
<	O
0	int
)	O
continue	O
;	O
memset	function
(	O
&	O
ss	pointer
,	O
0	int
,	O
sizeof	O
(	O
ss	pointer
)	O
)	O
;	O
ss	pointer
.	O
ss_family	short
=	O
ai	pointer
->	O
ai_family	int
;	O
if	O
(	O
bind	function
(	O
f	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
ss	pointer
,	O
ai	pointer
->	O
ai_addrlen	int
)	O
)	O
{	O
close	pointer
(	O
f	int
)	O
;	O
f	int
=	O
-	O
1	int
;	O
continue	O
;	O
}	O
peerlen	int
=	O
ai	pointer
->	O
ai_addrlen	int
;	O
memcpy	function
(	O
&	O
peeraddr	struct
,	O
ai	pointer
->	O
ai_addr	pointer
,	O
ai	pointer
->	O
ai_addrlen	int
)	O
;	O
connected	int
=	O
1	int
;	O
free	function
(	O
hostname	pointer
)	O
;	O
hostname	pointer
=	O
xstrdup	function
(	O
ai	pointer
->	O
ai_canonname	pointer
)	O
;	O
break	O
;	O
}	O
freeaddrinfo	function
(	O
aiptr	pointer
)	O
;	O
if	O
(	O
ai	pointer
==	O
NULL	O
)	O
return	O
RESOLVE_FAIL	O
;	O
else	O
return	O
RESOLVE_OK	int
;	O
}	O
static	O
void	O
get_args	function
(	O
char	O
*	O
arg0	pointer
,	O
char	O
*	O
prompt	pointer
,	O
int	O
*	O
argc	int
,	O
char	O
*	O
*	O
*	O
argv	pointer
)	O
{	O
size_t	long
arg0_len	long
=	O
strlen	function
(	O
arg0	pointer
)	O
;	O
strcpy	function
(	O
line	pointer
,	O
arg0	pointer
)	O
;	O
strcat	function
(	O
line	pointer
,	O
" "	pointer
)	O
;	O
printf	function
(	O
"%s"	pointer
,	O
prompt	pointer
)	O
;	O
fgets	function
(	O
line	pointer
+	O
arg0_len	long
+	O
1	int
,	O
sizeof	O
line	pointer
-	O
arg0_len	long
-	O
1	int
,	O
stdin	pointer
)	O
;	O
makeargv	function
(	O
)	O
;	O
*	O
argc	int
=	O
margc	int
;	O
*	O
argv	pointer
=	O
margv	array
;	O
}	O
void	O
setpeer	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
if	O
(	O
argc	int
<	O
2	int
)	O
get_args	function
(	O
"Connect"	pointer
,	O
"(to) "	pointer
,	O
&	O
argc	int
,	O
&	O
argv	pointer
)	O
;	O
if	O
(	O
argc	int
<	O
2	int
||	O
argc	int
>	O
3	int
)	O
{	O
printf	function
(	O
"usage: %s host-name [port]\n"	pointer
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
resolve_name	function
(	O
argv	pointer
[	O
1	int
]	O
)	O
)	O
{	O
case	O
RESOLVE_OK	int
:	O
break	O
;	O
case	O
RESOLVE_FAIL	O
:	O
return	O
;	O
}	O
if	O
(	O
argc	int
==	O
3	int
)	O
{	O
port	int
=	O
atoi	function
(	O
argv	pointer
[	O
2	int
]	O
)	O
;	O
if	O
(	O
port	int
<=	O
0	int
)	O
{	O
printf	function
(	O
"%s: bad port number\n"	pointer
,	O
argv	pointer
[	O
2	int
]	O
)	O
;	O
connected	int
=	O
0	int
;	O
return	O
;	O
}	O
}	O
else	O
{	O
struct	O
servent	struct
*	O
sp	pointer
;	O
sp	pointer
=	O
getservbyname	function
(	O
"tftp"	pointer
,	O
"udp"	pointer
)	O
;	O
if	O
(	O
sp	pointer
==	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"udp/tftp: unknown service\n"	pointer
)	O
;	O
port	int
=	O
ntohs	function
(	O
sp	pointer
->	O
s_port	int
)	O
;	O
}	O
connected	int
=	O
1	int
;	O
}	O
struct	O
modes	int
{	O
char	O
*	O
m_name	pointer
;	O
char	O
*	O
m_mode	pointer
;	O
}	O
modes	int
[	O
]	O
=	O
{	O
{	O
"ascii"	pointer
,	O
"netascii"	pointer
}	O
,	O
{	O
"netascii"	pointer
,	O
"netascii"	pointer
}	O
,	O
{	O
"binary"	pointer
,	O
"octet"	pointer
}	O
,	O
{	O
"image"	pointer
,	O
"octet"	pointer
}	O
,	O
{	O
"octet"	pointer
,	O
"octet"	pointer
}	O
,	O
{	O
0	int
,	O
0	int
}	O
}	O
;	O
void	O
modecmd	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
register	O
struct	O
modes	int
*	O
p	pointer
;	O
char	O
*	O
sep	pointer
;	O
if	O
(	O
argc	int
<	O
2	int
)	O
{	O
printf	function
(	O
"Using %s mode to transfer files.\n"	pointer
,	O
mode	array
)	O
;	O
return	O
;	O
}	O
if	O
(	O
argc	int
==	O
2	int
)	O
{	O
for	O
(	O
p	pointer
=	O
modes	int
;	O
p	pointer
->	O
m_name	pointer
;	O
p	pointer
++	O
)	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
1	int
]	O
,	O
p	pointer
->	O
m_name	pointer
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
p	pointer
->	O
m_name	pointer
)	O
{	O
settftpmode	function
(	O
p	pointer
->	O
m_mode	pointer
)	O
;	O
return	O
;	O
}	O
printf	function
(	O
"%s: unknown mode\n"	pointer
,	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
}	O
printf	function
(	O
"usage: %s ["	pointer
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
sep	pointer
=	O
" "	pointer
;	O
for	O
(	O
p	pointer
=	O
modes	int
;	O
p	pointer
->	O
m_name	pointer
;	O
p	pointer
++	O
)	O
{	O
printf	function
(	O
"%s%s"	pointer
,	O
sep	pointer
,	O
p	pointer
->	O
m_name	pointer
)	O
;	O
if	O
(	O
*	O
sep	pointer
==	O
' '	O
)	O
sep	pointer
=	O
" | "	pointer
;	O
}	O
printf	function
(	O
" ]\n"	pointer
)	O
;	O
return	O
;	O
}	O
void	O
setbinary	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
settftpmode	function
(	O
"octet"	pointer
)	O
;	O
}	O
void	O
setascii	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
settftpmode	function
(	O
"netascii"	pointer
)	O
;	O
}	O
static	O
void	O
settftpmode	function
(	O
char	O
*	O
newmode	pointer
)	O
{	O
strcpy	function
(	O
mode	array
,	O
newmode	pointer
)	O
;	O
if	O
(	O
verbose	int
)	O
printf	function
(	O
"mode set to %s\n"	pointer
,	O
mode	array
)	O
;	O
}	O
void	O
put	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
int	O
fd	int
;	O
register	O
int	O
n	long
;	O
register	O
char	O
*	O
cp	pointer
,	O
*	O
targ	pointer
;	O
if	O
(	O
argc	int
<	O
2	int
)	O
get_args	function
(	O
"send"	pointer
,	O
"(file) "	pointer
,	O
&	O
argc	int
,	O
&	O
argv	pointer
)	O
;	O
if	O
(	O
argc	int
<	O
2	int
)	O
{	O
putusage	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
targ	pointer
=	O
argv	pointer
[	O
argc	int
-	O
1	int
]	O
;	O
if	O
(	O
strchr	function
(	O
argv	pointer
[	O
argc	int
-	O
1	int
]	O
,	O
':'	O
)	O
)	O
{	O
char	O
*	O
cp	pointer
;	O
for	O
(	O
n	long
=	O
1	int
;	O
n	long
<	O
argc	int
-	O
1	int
;	O
n	long
++	O
)	O
if	O
(	O
strchr	function
(	O
argv	pointer
[	O
n	long
]	O
,	O
':'	O
)	O
)	O
{	O
putusage	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
cp	pointer
=	O
argv	pointer
[	O
argc	int
-	O
1	int
]	O
;	O
if	O
(	O
cp	pointer
[	O
0	int
]	O
==	O
'['	O
)	O
{	O
cp	pointer
=	O
strchr	function
(	O
cp	pointer
,	O
']'	O
)	O
;	O
if	O
(	O
cp	pointer
==	O
NULL	O
)	O
return	O
;	O
*	O
cp	pointer
=	O
0	int
;	O
targ	pointer
=	O
cp	pointer
+	O
1	int
;	O
cp	pointer
=	O
argv	pointer
[	O
argc	int
-	O
1	int
]	O
+	O
1	int
;	O
if	O
(	O
targ	pointer
[	O
0	int
]	O
==	O
':'	O
)	O
++	O
targ	pointer
;	O
else	O
{	O
targ	pointer
=	O
argv	pointer
[	O
argc	int
-	O
1	int
]	O
;	O
cp	pointer
=	O
NULL	O
;	O
}	O
}	O
else	O
{	O
targ	pointer
=	O
strchr	function
(	O
cp	pointer
,	O
':'	O
)	O
;	O
*	O
targ	pointer
++	O
=	O
0	int
;	O
if	O
(	O
strlen	function
(	O
cp	pointer
)	O
==	O
0	int
)	O
cp	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
cp	pointer
!=	O
NULL	O
&&	O
resolve_name	function
(	O
cp	pointer
)	O
!=	O
RESOLVE_OK	int
)	O
return	O
;	O
}	O
if	O
(	O
!	O
connected	int
)	O
{	O
printf	function
(	O
"No target machine specified.\n"	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
argc	int
<	O
4	int
)	O
{	O
cp	pointer
=	O
argc	int
==	O
2	int
?	O
tail	function
(	O
targ	pointer
)	O
:	O
argv	pointer
[	O
1	int
]	O
;	O
fd	int
=	O
open	function
(	O
cp	pointer
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"tftp: "	pointer
)	O
;	O
perror	function
(	O
cp	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
verbose	int
)	O
printf	function
(	O
"putting %s to %s:%s [%s]\n"	pointer
,	O
cp	pointer
,	O
hostname	pointer
,	O
targ	pointer
,	O
mode	array
)	O
;	O
set_port	function
(	O
&	O
peeraddr	struct
,	O
port	int
)	O
;	O
send_file	function
(	O
fd	int
,	O
targ	pointer
,	O
mode	array
)	O
;	O
return	O
;	O
}	O
cp	pointer
=	O
strchr	function
(	O
targ	pointer
,	O
'\0'	O
)	O
;	O
*	O
cp	pointer
++	O
=	O
'/'	O
;	O
for	O
(	O
n	long
=	O
1	int
;	O
n	long
<	O
argc	int
-	O
1	int
;	O
n	long
++	O
)	O
{	O
strcpy	function
(	O
cp	pointer
,	O
tail	function
(	O
argv	pointer
[	O
n	long
]	O
)	O
)	O
;	O
fd	int
=	O
open	function
(	O
argv	pointer
[	O
n	long
]	O
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"tftp: "	pointer
)	O
;	O
perror	function
(	O
argv	pointer
[	O
n	long
]	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
verbose	int
)	O
printf	function
(	O
"putting %s to %s:%s [%s]\n"	pointer
,	O
argv	pointer
[	O
n	long
]	O
,	O
hostname	pointer
,	O
targ	pointer
,	O
mode	array
)	O
;	O
set_port	function
(	O
&	O
peeraddr	struct
,	O
port	int
)	O
;	O
send_file	function
(	O
fd	int
,	O
targ	pointer
,	O
mode	array
)	O
;	O
}	O
}	O
static	O
void	O
putusage	function
(	O
char	O
*	O
s	long
)	O
{	O
printf	function
(	O
"usage: %s file ... host:target, or\n"	pointer
,	O
s	long
)	O
;	O
printf	function
(	O
"       %s file ... target (when already connected)\n"	pointer
,	O
s	long
)	O
;	O
}	O
void	O
get	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
int	O
fd	int
;	O
register	O
int	O
n	long
;	O
register	O
char	O
*	O
cp	pointer
;	O
char	O
*	O
src	pointer
;	O
if	O
(	O
argc	int
<	O
2	int
)	O
get_args	function
(	O
"get"	pointer
,	O
"(files) "	pointer
,	O
&	O
argc	int
,	O
&	O
argv	pointer
)	O
;	O
if	O
(	O
argc	int
<	O
2	int
)	O
{	O
getusage	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
connected	int
)	O
{	O
for	O
(	O
n	long
=	O
1	int
;	O
n	long
<	O
argc	int
;	O
n	long
++	O
)	O
if	O
(	O
strchr	function
(	O
argv	pointer
[	O
n	long
]	O
,	O
':'	O
)	O
==	O
0	int
)	O
{	O
getusage	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
}	O
for	O
(	O
n	long
=	O
1	int
;	O
n	long
<	O
argc	int
;	O
n	long
++	O
)	O
{	O
src	pointer
=	O
strchr	function
(	O
argv	pointer
[	O
n	long
]	O
,	O
':'	O
)	O
;	O
if	O
(	O
src	pointer
==	O
NULL	O
)	O
src	pointer
=	O
argv	pointer
[	O
n	long
]	O
;	O
else	O
if	O
(	O
src	pointer
==	O
argv	pointer
[	O
n	long
]	O
)	O
{	O
++	O
src	pointer
;	O
}	O
else	O
{	O
cp	pointer
=	O
argv	pointer
[	O
n	long
]	O
;	O
if	O
(	O
cp	pointer
[	O
0	int
]	O
==	O
'['	O
)	O
{	O
cp	pointer
=	O
strchr	function
(	O
argv	pointer
[	O
n	long
]	O
,	O
']'	O
)	O
;	O
if	O
(	O
cp	pointer
)	O
{	O
src	pointer
=	O
cp	pointer
+	O
1	int
;	O
*	O
cp	pointer
=	O
0	int
;	O
if	O
(	O
*	O
src	pointer
==	O
':'	O
)	O
++	O
src	pointer
;	O
cp	pointer
=	O
argv	pointer
[	O
n	long
]	O
+	O
1	int
;	O
}	O
}	O
else	O
{	O
*	O
src	pointer
++	O
=	O
0	int
;	O
}	O
if	O
(	O
cp	pointer
!=	O
NULL	O
&&	O
resolve_name	function
(	O
cp	pointer
)	O
!=	O
RESOLVE_OK	int
)	O
continue	O
;	O
}	O
if	O
(	O
argc	int
<	O
4	int
)	O
{	O
cp	pointer
=	O
argc	int
==	O
3	int
?	O
argv	pointer
[	O
2	int
]	O
:	O
tail	function
(	O
src	pointer
)	O
;	O
fd	int
=	O
creat	function
(	O
cp	pointer
,	O
0644	int
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"tftp: "	pointer
)	O
;	O
perror	function
(	O
cp	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
verbose	int
)	O
printf	function
(	O
"getting from %s:%s to %s [%s]\n"	pointer
,	O
hostname	pointer
,	O
src	pointer
,	O
cp	pointer
,	O
mode	array
)	O
;	O
set_port	function
(	O
&	O
peeraddr	struct
,	O
port	int
)	O
;	O
recvfile	function
(	O
fd	int
,	O
src	pointer
,	O
mode	array
)	O
;	O
break	O
;	O
}	O
cp	pointer
=	O
tail	function
(	O
src	pointer
)	O
;	O
fd	int
=	O
creat	function
(	O
cp	pointer
,	O
0644	int
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"tftp: "	pointer
)	O
;	O
perror	function
(	O
cp	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
verbose	int
)	O
printf	function
(	O
"getting from %s:%s to %s [%s]\n"	pointer
,	O
hostname	pointer
,	O
src	pointer
,	O
cp	pointer
,	O
mode	array
)	O
;	O
set_port	function
(	O
&	O
peeraddr	struct
,	O
port	int
)	O
;	O
recvfile	function
(	O
fd	int
,	O
src	pointer
,	O
mode	array
)	O
;	O
}	O
}	O
static	O
void	O
getusage	function
(	O
char	O
*	O
s	long
)	O
{	O
printf	function
(	O
"usage: %s host:file host:file ... file, or\n"	pointer
,	O
s	long
)	O
;	O
printf	function
(	O
"       %s file file ... file if connected\n"	pointer
,	O
s	long
)	O
;	O
}	O
void	O
setrexmt	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
int	O
t	int
;	O
if	O
(	O
argc	int
<	O
2	int
)	O
get_args	function
(	O
"Rexmt-timeout"	pointer
,	O
"(value) "	pointer
,	O
&	O
argc	int
,	O
&	O
argv	pointer
)	O
;	O
if	O
(	O
argc	int
!=	O
2	int
)	O
{	O
printf	function
(	O
"usage: %s value\n"	pointer
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
t	int
=	O
atoi	function
(	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
if	O
(	O
t	int
<	O
0	int
)	O
printf	function
(	O
"%s: bad value\n"	pointer
,	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
else	O
rexmtval	int
=	O
t	int
;	O
}	O
void	O
settimeout	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
int	O
t	int
;	O
if	O
(	O
argc	int
<	O
2	int
)	O
get_args	function
(	O
"Maximum-timeout"	pointer
,	O
"(value) "	pointer
,	O
&	O
argc	int
,	O
&	O
argv	pointer
)	O
;	O
if	O
(	O
argc	int
!=	O
2	int
)	O
{	O
printf	function
(	O
"usage: %s value\n"	pointer
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
t	int
=	O
atoi	function
(	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
if	O
(	O
t	int
<	O
0	int
)	O
printf	function
(	O
"%s: bad value\n"	pointer
,	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
else	O
maxtimeout	int
=	O
t	int
;	O
}	O
void	O
status	int
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
if	O
(	O
connected	int
)	O
printf	function
(	O
"Connected to %s.\n"	pointer
,	O
hostname	pointer
)	O
;	O
else	O
printf	function
(	O
"Not connected.\n"	pointer
)	O
;	O
printf	function
(	O
"Mode: %s Verbose: %s Tracing: %s\n"	pointer
,	O
mode	array
,	O
verbose	int
?	O
"on"	pointer
:	O
"off"	pointer
,	O
trace	int
?	O
"on"	pointer
:	O
"off"	pointer
)	O
;	O
printf	function
(	O
"Rexmt-interval: %d seconds, Max-timeout: %d seconds\n"	pointer
,	O
rexmtval	int
,	O
maxtimeout	int
)	O
;	O
}	O
void	O
intr	function
(	O
int	O
signo	int
)	O
{	O
signal	function
(	O
SIGALRM	int
,	O
SIG_IGN	O
)	O
;	O
alarm	function
(	O
0	int
)	O
;	O
longjmp	function
(	O
toplevel	array
,	O
-	O
1	int
)	O
;	O
}	O
char	O
*	O
tail	function
(	O
char	O
*	O
filename	pointer
)	O
{	O
register	O
char	O
*	O
s	long
;	O
while	O
(	O
*	O
filename	pointer
)	O
{	O
s	long
=	O
strrchr	function
(	O
filename	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
s	long
==	O
NULL	O
)	O
break	O
;	O
if	O
(	O
s	long
[	O
1	int
]	O
)	O
return	O
(	O
s	long
+	O
1	int
)	O
;	O
*	O
s	long
=	O
'\0'	O
;	O
}	O
return	O
filename	pointer
;	O
}	O
static	O
void	O
command	function
(	O
void	O
)	O
{	O
register	O
struct	O
cmd	struct
*	O
c	pointer
;	O
for	O
(	O
;	O
;	O
)	O
{	O
printf	function
(	O
"%s> "	pointer
,	O
prompt	pointer
)	O
;	O
if	O
(	O
fgets	function
(	O
line	pointer
,	O
sizeof	O
line	pointer
,	O
stdin	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
feof	function
(	O
stdin	pointer
)	O
)	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
else	O
continue	O
;	O
}	O
if	O
(	O
line	pointer
[	O
0	int
]	O
==	O
0	int
)	O
continue	O
;	O
makeargv	function
(	O
)	O
;	O
if	O
(	O
margc	int
==	O
0	int
)	O
continue	O
;	O
c	pointer
=	O
getcmd	function
(	O
margv	array
[	O
0	int
]	O
)	O
;	O
if	O
(	O
c	pointer
==	O
(	O
struct	O
cmd	struct
*	O
)	O
-	O
1	int
)	O
{	O
printf	function
(	O
"?Ambiguous command\n"	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
c	pointer
==	O
0	int
)	O
{	O
printf	function
(	O
"?Invalid command\n"	pointer
)	O
;	O
continue	O
;	O
}	O
(	O
*	O
c	pointer
->	O
handler	pointer
)	O
(	O
margc	int
,	O
margv	array
)	O
;	O
}	O
}	O
struct	O
cmd	struct
*	O
getcmd	function
(	O
register	O
char	O
*	O
name	pointer
)	O
{	O
register	O
char	O
*	O
p	pointer
,	O
*	O
q	pointer
;	O
register	O
struct	O
cmd	struct
*	O
c	pointer
,	O
*	O
found	pointer
;	O
register	O
int	O
nmatches	int
,	O
longest	int
;	O
longest	int
=	O
0	int
;	O
nmatches	int
=	O
0	int
;	O
found	pointer
=	O
0	int
;	O
for	O
(	O
c	pointer
=	O
cmdtab	array
;	O
(	O
p	pointer
=	O
c	pointer
->	O
name	pointer
)	O
!=	O
NULL	O
;	O
c	pointer
++	O
)	O
{	O
for	O
(	O
q	pointer
=	O
name	pointer
;	O
*	O
q	pointer
==	O
*	O
p	pointer
++	O
;	O
q	pointer
++	O
)	O
if	O
(	O
*	O
q	pointer
==	O
0	int
)	O
return	O
(	O
c	pointer
)	O
;	O
if	O
(	O
!	O
*	O
q	pointer
)	O
{	O
if	O
(	O
q	pointer
-	O
name	pointer
>	O
longest	int
)	O
{	O
longest	int
=	O
q	pointer
-	O
name	pointer
;	O
nmatches	int
=	O
1	int
;	O
found	pointer
=	O
c	pointer
;	O
}	O
else	O
if	O
(	O
q	pointer
-	O
name	pointer
==	O
longest	int
)	O
nmatches	int
++	O
;	O
}	O
}	O
if	O
(	O
nmatches	int
>	O
1	int
)	O
return	O
(	O
struct	O
cmd	struct
*	O
)	O
-	O
1	int
;	O
return	O
found	pointer
;	O
}	O
static	O
void	O
makeargv	function
(	O
void	O
)	O
{	O
register	O
char	O
*	O
cp	pointer
;	O
register	O
char	O
*	O
*	O
argp	struct
=	O
margv	array
;	O
margc	int
=	O
0	int
;	O
for	O
(	O
cp	pointer
=	O
line	pointer
;	O
*	O
cp	pointer
;	O
)	O
{	O
while	O
(	O
isspace	function
(	O
*	O
cp	pointer
)	O
)	O
cp	pointer
++	O
;	O
if	O
(	O
*	O
cp	pointer
==	O
'\0'	O
)	O
break	O
;	O
*	O
argp	struct
++	O
=	O
cp	pointer
;	O
margc	int
+=	O
1	int
;	O
while	O
(	O
*	O
cp	pointer
!=	O
'\0'	O
&&	O
!	O
isspace	function
(	O
*	O
cp	pointer
)	O
)	O
cp	pointer
++	O
;	O
if	O
(	O
*	O
cp	pointer
==	O
'\0'	O
)	O
break	O
;	O
*	O
cp	pointer
++	O
=	O
'\0'	O
;	O
}	O
*	O
argp	struct
++	O
=	O
0	int
;	O
}	O
void	O
quit	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
void	O
help	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
register	O
struct	O
cmd	struct
*	O
c	pointer
;	O
if	O
(	O
argc	int
==	O
1	int
)	O
{	O
printf	function
(	O
"Commands may be abbreviated.  Commands are:\n\n"	pointer
)	O
;	O
for	O
(	O
c	pointer
=	O
cmdtab	array
;	O
c	pointer
->	O
name	pointer
;	O
c	pointer
++	O
)	O
printf	function
(	O
"%-*s\t%s\n"	pointer
,	O
(	O
int	O
)	O
HELPINDENT	O
,	O
c	pointer
->	O
name	pointer
,	O
c	pointer
->	O
help	function
)	O
;	O
return	O
;	O
}	O
while	O
(	O
--	O
argc	int
>	O
0	int
)	O
{	O
register	O
char	O
*	O
arg	pointer
;	O
arg	pointer
=	O
*	O
++	O
argv	pointer
;	O
c	pointer
=	O
getcmd	function
(	O
arg	pointer
)	O
;	O
if	O
(	O
c	pointer
==	O
(	O
struct	O
cmd	struct
*	O
)	O
-	O
1	int
)	O
printf	function
(	O
"?Ambiguous help command %s\n"	pointer
,	O
arg	pointer
)	O
;	O
else	O
if	O
(	O
c	pointer
==	O
(	O
struct	O
cmd	struct
*	O
)	O
0	int
)	O
printf	function
(	O
"?Invalid help command %s\n"	pointer
,	O
arg	pointer
)	O
;	O
else	O
printf	function
(	O
"%s\n"	pointer
,	O
c	pointer
->	O
help	function
)	O
;	O
}	O
}	O
void	O
settrace	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
trace	int
=	O
!	O
trace	int
;	O
printf	function
(	O
"Packet tracing %s.\n"	pointer
,	O
trace	int
?	O
"on"	pointer
:	O
"off"	pointer
)	O
;	O
}	O
void	O
setverbose	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
verbose	int
=	O
!	O
verbose	int
;	O
printf	function
(	O
"Verbose mode %s.\n"	pointer
,	O
verbose	int
?	O
"on"	pointer
:	O
"off"	pointer
)	O
;	O
}	O
void	O
send_file	function
(	O
int	O
fd	int
,	O
char	O
*	O
name	pointer
,	O
char	O
*	O
mode	array
)	O
{	O
register	O
struct	O
tftphdr	struct
*	O
ap	pointer
;	O
struct	O
tftphdr	struct
*	O
r_init	function
(	O
void	O
)	O
,	O
*	O
dp	pointer
;	O
register	O
int	O
n	long
;	O
volatile	O
int	O
block	int
,	O
size	int
,	O
convert	int
;	O
volatile	O
unsigned	O
long	O
amount	long
;	O
struct	O
sockaddr_storage	struct
from	struct
;	O
socklen_t	int
fromlen	int
;	O
FILE	struct
*	O
file	pointer
;	O
startclock	function
(	O
)	O
;	O
dp	pointer
=	O
r_init	function
(	O
)	O
;	O
ap	pointer
=	O
(	O
struct	O
tftphdr	struct
*	O
)	O
ackbuf	array
;	O
file	pointer
=	O
fdopen	function
(	O
fd	int
,	O
"r"	pointer
)	O
;	O
convert	int
=	O
!	O
strcmp	function
(	O
mode	array
,	O
"netascii"	pointer
)	O
;	O
block	int
=	O
0	int
;	O
amount	long
=	O
0	int
;	O
signal	function
(	O
SIGALRM	int
,	O
timer	function
)	O
;	O
do	O
{	O
if	O
(	O
block	int
==	O
0	int
)	O
size	int
=	O
makerequest	function
(	O
WRQ	int
,	O
name	pointer
,	O
dp	pointer
,	O
mode	array
)	O
-	O
4	int
;	O
else	O
{	O
size	int
=	O
readit	function
(	O
file	pointer
,	O
&	O
dp	pointer
,	O
convert	int
)	O
;	O
if	O
(	O
size	int
<	O
0	int
)	O
{	O
nak	function
(	O
errno	O
+	O
100	int
)	O
;	O
break	O
;	O
}	O
dp	pointer
->	O
th_opcode	short
=	O
htons	function
(	O
(	O
unsigned	O
short	O
)	O
DATA	int
)	O
;	O
dp	pointer
->	O
th_block	O
=	O
htons	function
(	O
(	O
unsigned	O
short	O
)	O
block	int
)	O
;	O
}	O
timeout	int
=	O
0	int
;	O
setjmp	function
(	O
timeoutbuf	array
)	O
;	O
send_data	O
:	O
if	O
(	O
trace	int
)	O
tpacket	function
(	O
"sent"	pointer
,	O
dp	pointer
,	O
size	int
+	O
4	int
)	O
;	O
n	long
=	O
sendto	function
(	O
f	int
,	O
(	O
const	O
char	O
*	O
)	O
dp	pointer
,	O
size	int
+	O
4	int
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
peeraddr	struct
,	O
peerlen	int
)	O
;	O
if	O
(	O
n	long
!=	O
size	int
+	O
4	int
)	O
{	O
perror	function
(	O
"tftp: sendto"	pointer
)	O
;	O
goto	O
abort	function
;	O
}	O
read_ahead	function
(	O
file	pointer
,	O
convert	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
alarm	function
(	O
rexmtval	int
)	O
;	O
do	O
{	O
fromlen	int
=	O
sizeof	O
(	O
from	struct
)	O
;	O
n	long
=	O
recvfrom	function
(	O
f	int
,	O
ackbuf	array
,	O
sizeof	O
(	O
ackbuf	array
)	O
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
from	struct
,	O
&	O
fromlen	int
)	O
;	O
}	O
while	O
(	O
n	long
<=	O
0	int
)	O
;	O
alarm	function
(	O
0	int
)	O
;	O
if	O
(	O
n	long
<	O
0	int
)	O
{	O
perror	function
(	O
"tftp: recvfrom"	pointer
)	O
;	O
goto	O
abort	function
;	O
}	O
set_port	function
(	O
&	O
peeraddr	struct
,	O
get_port	function
(	O
&	O
from	struct
)	O
)	O
;	O
if	O
(	O
trace	int
)	O
tpacket	function
(	O
"received"	pointer
,	O
ap	pointer
,	O
n	long
)	O
;	O
ap	pointer
->	O
th_opcode	short
=	O
ntohs	function
(	O
ap	pointer
->	O
th_opcode	short
)	O
;	O
ap	pointer
->	O
th_block	O
=	O
ntohs	function
(	O
ap	pointer
->	O
th_block	O
)	O
;	O
if	O
(	O
ap	pointer
->	O
th_opcode	short
==	O
ERROR	int
)	O
{	O
printf	function
(	O
"Error code %d: %s\n"	pointer
,	O
ap	pointer
->	O
th_code	O
,	O
ap	pointer
->	O
th_msg	O
)	O
;	O
goto	O
abort	function
;	O
}	O
if	O
(	O
ap	pointer
->	O
th_opcode	short
==	O
ACK	int
)	O
{	O
int	O
j	int
;	O
if	O
(	O
ap	pointer
->	O
th_block	O
==	O
block	int
)	O
break	O
;	O
j	int
=	O
synchnet	function
(	O
f	int
)	O
;	O
if	O
(	O
j	int
&&	O
trace	int
)	O
printf	function
(	O
"discarded %d packets\n"	pointer
,	O
j	int
)	O
;	O
if	O
(	O
ap	pointer
->	O
th_block	O
==	O
(	O
block	int
-	O
1	int
)	O
)	O
goto	O
send_data	O
;	O
}	O
}	O
if	O
(	O
block	int
>	O
0	int
)	O
amount	long
+=	O
size	int
;	O
block	int
++	O
;	O
}	O
while	O
(	O
size	int
==	O
SEGSIZE	int
||	O
block	int
==	O
1	int
)	O
;	O
abort	function
:	O
fclose	function
(	O
file	pointer
)	O
;	O
stopclock	function
(	O
)	O
;	O
if	O
(	O
amount	long
>	O
0	int
)	O
printstats	function
(	O
"Sent"	pointer
,	O
amount	long
)	O
;	O
}	O
void	O
recvfile	function
(	O
int	O
fd	int
,	O
char	O
*	O
name	pointer
,	O
char	O
*	O
mode	array
)	O
{	O
register	O
struct	O
tftphdr	struct
*	O
ap	pointer
;	O
struct	O
tftphdr	struct
*	O
dp	pointer
,	O
*	O
w_init	function
(	O
void	O
)	O
;	O
register	O
int	O
n	long
;	O
volatile	O
int	O
block	int
,	O
size	int
,	O
firsttrip	int
;	O
volatile	O
unsigned	O
long	O
amount	long
;	O
struct	O
sockaddr_storage	struct
from	struct
;	O
socklen_t	int
fromlen	int
;	O
FILE	struct
*	O
file	pointer
;	O
volatile	O
int	O
convert	int
;	O
startclock	function
(	O
)	O
;	O
dp	pointer
=	O
w_init	function
(	O
)	O
;	O
ap	pointer
=	O
(	O
struct	O
tftphdr	struct
*	O
)	O
ackbuf	array
;	O
file	pointer
=	O
fdopen	function
(	O
fd	int
,	O
"w"	pointer
)	O
;	O
convert	int
=	O
!	O
strcmp	function
(	O
mode	array
,	O
"netascii"	pointer
)	O
;	O
block	int
=	O
1	int
;	O
firsttrip	int
=	O
1	int
;	O
amount	long
=	O
0	int
;	O
signal	function
(	O
SIGALRM	int
,	O
timer	function
)	O
;	O
do	O
{	O
if	O
(	O
firsttrip	int
)	O
{	O
size	int
=	O
makerequest	function
(	O
RRQ	int
,	O
name	pointer
,	O
ap	pointer
,	O
mode	array
)	O
;	O
firsttrip	int
=	O
0	int
;	O
}	O
else	O
{	O
ap	pointer
->	O
th_opcode	short
=	O
htons	function
(	O
(	O
unsigned	O
short	O
)	O
ACK	int
)	O
;	O
ap	pointer
->	O
th_block	O
=	O
htons	function
(	O
(	O
unsigned	O
short	O
)	O
(	O
block	int
)	O
)	O
;	O
size	int
=	O
4	int
;	O
block	int
++	O
;	O
}	O
timeout	int
=	O
0	int
;	O
setjmp	function
(	O
timeoutbuf	array
)	O
;	O
send_ack	O
:	O
if	O
(	O
trace	int
)	O
tpacket	function
(	O
"sent"	pointer
,	O
ap	pointer
,	O
size	int
)	O
;	O
if	O
(	O
sendto	function
(	O
f	int
,	O
ackbuf	array
,	O
size	int
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
peeraddr	struct
,	O
peerlen	int
)	O
!=	O
size	int
)	O
{	O
alarm	function
(	O
0	int
)	O
;	O
perror	function
(	O
"tftp: sendto"	pointer
)	O
;	O
goto	O
abort	function
;	O
}	O
write_behind	function
(	O
file	pointer
,	O
convert	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
alarm	function
(	O
rexmtval	int
)	O
;	O
do	O
{	O
fromlen	int
=	O
sizeof	O
(	O
from	struct
)	O
;	O
n	long
=	O
recvfrom	function
(	O
f	int
,	O
(	O
char	O
*	O
)	O
dp	pointer
,	O
PKTSIZE	O
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
from	struct
,	O
&	O
fromlen	int
)	O
;	O
}	O
while	O
(	O
n	long
<=	O
0	int
)	O
;	O
alarm	function
(	O
0	int
)	O
;	O
if	O
(	O
n	long
<	O
0	int
)	O
{	O
perror	function
(	O
"tftp: recvfrom"	pointer
)	O
;	O
goto	O
abort	function
;	O
}	O
set_port	function
(	O
&	O
peeraddr	struct
,	O
get_port	function
(	O
&	O
from	struct
)	O
)	O
;	O
if	O
(	O
trace	int
)	O
tpacket	function
(	O
"received"	pointer
,	O
dp	pointer
,	O
n	long
)	O
;	O
dp	pointer
->	O
th_opcode	short
=	O
ntohs	function
(	O
dp	pointer
->	O
th_opcode	short
)	O
;	O
dp	pointer
->	O
th_block	O
=	O
ntohs	function
(	O
dp	pointer
->	O
th_block	O
)	O
;	O
if	O
(	O
dp	pointer
->	O
th_opcode	short
==	O
ERROR	int
)	O
{	O
printf	function
(	O
"Error code %d: %s\n"	pointer
,	O
dp	pointer
->	O
th_code	O
,	O
dp	pointer
->	O
th_msg	O
)	O
;	O
goto	O
abort	function
;	O
}	O
if	O
(	O
dp	pointer
->	O
th_opcode	short
==	O
DATA	int
)	O
{	O
int	O
j	int
;	O
if	O
(	O
dp	pointer
->	O
th_block	O
==	O
block	int
)	O
break	O
;	O
j	int
=	O
synchnet	function
(	O
f	int
)	O
;	O
if	O
(	O
j	int
&&	O
trace	int
)	O
printf	function
(	O
"discarded %d packets\n"	pointer
,	O
j	int
)	O
;	O
if	O
(	O
dp	pointer
->	O
th_block	O
==	O
(	O
block	int
-	O
1	int
)	O
)	O
goto	O
send_ack	O
;	O
}	O
}	O
size	int
=	O
writeit	function
(	O
file	pointer
,	O
&	O
dp	pointer
,	O
n	long
-	O
4	int
,	O
convert	int
)	O
;	O
if	O
(	O
size	int
<	O
0	int
)	O
{	O
nak	function
(	O
errno	O
+	O
100	int
)	O
;	O
break	O
;	O
}	O
amount	long
+=	O
size	int
;	O
}	O
while	O
(	O
size	int
==	O
SEGSIZE	int
)	O
;	O
abort	function
:	O
ap	pointer
->	O
th_opcode	short
=	O
htons	function
(	O
(	O
unsigned	O
short	O
)	O
ACK	int
)	O
;	O
ap	pointer
->	O
th_block	O
=	O
htons	function
(	O
(	O
unsigned	O
short	O
)	O
block	int
)	O
;	O
sendto	function
(	O
f	int
,	O
ackbuf	array
,	O
4	int
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
peeraddr	struct
,	O
peerlen	int
)	O
;	O
write_behind	function
(	O
file	pointer
,	O
convert	int
)	O
;	O
fclose	function
(	O
file	pointer
)	O
;	O
stopclock	function
(	O
)	O
;	O
if	O
(	O
amount	long
>	O
0	int
)	O
printstats	function
(	O
"Received"	pointer
,	O
amount	long
)	O
;	O
}	O
static	O
int	O
makerequest	function
(	O
int	O
request	int
,	O
const	O
char	O
*	O
name	pointer
,	O
struct	O
tftphdr	struct
*	O
tp	pointer
,	O
const	O
char	O
*	O
mode	array
)	O
{	O
register	O
char	O
*	O
cp	pointer
;	O
tp	pointer
->	O
th_opcode	short
=	O
htons	function
(	O
(	O
unsigned	O
short	O
)	O
request	int
)	O
;	O
cp	pointer
=	O
(	O
char	O
*	O
)	O
&	O
(	O
tp	pointer
->	O
th_stuff	O
)	O
;	O
strcpy	function
(	O
cp	pointer
,	O
name	pointer
)	O
;	O
cp	pointer
+=	O
strlen	function
(	O
name	pointer
)	O
;	O
*	O
cp	pointer
++	O
=	O
'\0'	O
;	O
strcpy	function
(	O
cp	pointer
,	O
mode	array
)	O
;	O
cp	pointer
+=	O
strlen	function
(	O
mode	array
)	O
;	O
*	O
cp	pointer
++	O
=	O
'\0'	O
;	O
return	O
cp	pointer
-	O
(	O
char	O
*	O
)	O
tp	pointer
;	O
}	O
struct	O
errmsg	struct
{	O
int	O
e_code	int
;	O
const	O
char	O
*	O
e_msg	pointer
;	O
}	O
errmsgs	array
[	O
]	O
=	O
{	O
{	O
EUNDEF	int
,	O
"Undefined error code"	pointer
}	O
,	O
{	O
ENOTFOUND	int
,	O
"File not found"	pointer
}	O
,	O
{	O
EACCESS	int
,	O
"Access violation"	pointer
}	O
,	O
{	O
ENOSPACE	int
,	O
"Disk full or allocation exceeded"	pointer
}	O
,	O
{	O
EBADOP	int
,	O
"Illegal TFTP operation"	pointer
}	O
,	O
{	O
EBADID	int
,	O
"Unknown transfer ID"	pointer
}	O
,	O
{	O
EEXISTS	int
,	O
"File already exists"	pointer
}	O
,	O
{	O
ENOUSER	int
,	O
"No such user"	pointer
}	O
,	O
{	O
-	O
1	int
,	O
0	int
}	O
}	O
;	O
static	O
void	O
nak	function
(	O
int	O
error	function
)	O
{	O
register	O
struct	O
errmsg	struct
*	O
pe	pointer
;	O
register	O
struct	O
tftphdr	struct
*	O
tp	pointer
;	O
int	O
length	int
;	O
tp	pointer
=	O
(	O
struct	O
tftphdr	struct
*	O
)	O
ackbuf	array
;	O
tp	pointer
->	O
th_opcode	short
=	O
htons	function
(	O
(	O
unsigned	O
short	O
)	O
ERROR	int
)	O
;	O
tp	pointer
->	O
th_code	O
=	O
htons	function
(	O
(	O
unsigned	O
short	O
)	O
error	function
)	O
;	O
for	O
(	O
pe	pointer
=	O
errmsgs	array
;	O
pe	pointer
->	O
e_code	int
>=	O
0	int
;	O
pe	pointer
++	O
)	O
if	O
(	O
pe	pointer
->	O
e_code	int
==	O
error	function
)	O
break	O
;	O
if	O
(	O
pe	pointer
->	O
e_code	int
<	O
0	int
)	O
{	O
pe	pointer
->	O
e_msg	pointer
=	O
strerror	function
(	O
error	function
-	O
100	int
)	O
;	O
tp	pointer
->	O
th_code	O
=	O
EUNDEF	int
;	O
}	O
strcpy	function
(	O
tp	pointer
->	O
th_msg	O
,	O
pe	pointer
->	O
e_msg	pointer
)	O
;	O
length	int
=	O
strlen	function
(	O
pe	pointer
->	O
e_msg	pointer
)	O
+	O
4	int
;	O
if	O
(	O
trace	int
)	O
tpacket	function
(	O
"sent"	pointer
,	O
tp	pointer
,	O
length	int
)	O
;	O
if	O
(	O
sendto	function
(	O
f	int
,	O
ackbuf	array
,	O
length	int
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
peeraddr	struct
,	O
peerlen	int
)	O
!=	O
length	int
)	O
perror	function
(	O
"nak"	pointer
)	O
;	O
}	O
static	O
void	O
tpacket	function
(	O
const	O
char	O
*	O
s	long
,	O
struct	O
tftphdr	struct
*	O
tp	pointer
,	O
int	O
n	long
)	O
{	O
static	O
char	O
*	O
opcodes	array
[	O
]	O
=	O
{	O
"#0"	pointer
,	O
"RRQ"	pointer
,	O
"WRQ"	pointer
,	O
"DATA"	pointer
,	O
"ACK"	pointer
,	O
"ERROR"	pointer
}	O
;	O
register	O
char	O
*	O
cp	pointer
,	O
*	O
file	pointer
;	O
unsigned	O
short	O
op	short
=	O
ntohs	function
(	O
tp	pointer
->	O
th_opcode	short
)	O
;	O
if	O
(	O
op	short
<	O
RRQ	int
||	O
op	short
>	O
ERROR	int
)	O
printf	function
(	O
"%s opcode=%x "	pointer
,	O
s	long
,	O
op	short
)	O
;	O
else	O
printf	function
(	O
"%s %s "	pointer
,	O
s	long
,	O
opcodes	array
[	O
op	short
]	O
)	O
;	O
switch	O
(	O
op	short
)	O
{	O
case	O
RRQ	int
:	O
case	O
WRQ	int
:	O
n	long
-=	O
2	int
;	O
file	pointer
=	O
cp	pointer
=	O
(	O
char	O
*	O
)	O
&	O
(	O
tp	pointer
->	O
th_stuff	O
)	O
;	O
cp	pointer
=	O
strchr	function
(	O
cp	pointer
,	O
'\0'	O
)	O
;	O
printf	function
(	O
"<file=%s, mode=%s>\n"	pointer
,	O
file	pointer
,	O
cp	pointer
+	O
1	int
)	O
;	O
break	O
;	O
case	O
DATA	int
:	O
printf	function
(	O
"<block=%d, %d bytes>\n"	pointer
,	O
ntohs	function
(	O
tp	pointer
->	O
th_block	O
)	O
,	O
n	long
-	O
4	int
)	O
;	O
break	O
;	O
case	O
ACK	int
:	O
printf	function
(	O
"<block=%d>\n"	pointer
,	O
ntohs	function
(	O
tp	pointer
->	O
th_block	O
)	O
)	O
;	O
break	O
;	O
case	O
ERROR	int
:	O
printf	function
(	O
"<code=%d, msg=%s>\n"	pointer
,	O
ntohs	function
(	O
tp	pointer
->	O
th_code	O
)	O
,	O
tp	pointer
->	O
th_msg	O
)	O
;	O
break	O
;	O
}	O
}	O
struct	O
timeval	struct
tstart	struct
;	O
struct	O
timeval	struct
tstop	struct
;	O
static	O
void	O
startclock	function
(	O
void	O
)	O
{	O
gettimeofday	function
(	O
&	O
tstart	struct
,	O
NULL	O
)	O
;	O
}	O
static	O
void	O
stopclock	function
(	O
void	O
)	O
{	O
gettimeofday	function
(	O
&	O
tstop	struct
,	O
NULL	O
)	O
;	O
}	O
static	O
void	O
printstats	function
(	O
const	O
char	O
*	O
direction	pointer
,	O
unsigned	O
long	O
amount	long
)	O
{	O
double	O
delta	double
;	O
delta	double
=	O
(	O
(	O
tstop	struct
.	O
tv_sec	long
*	O
10.	int
)	O
+	O
(	O
tstop	struct
.	O
tv_usec	long
/	O
100000	int
)	O
)	O
-	O
(	O
(	O
tstart	struct
.	O
tv_sec	long
*	O
10.	int
)	O
+	O
(	O
tstart	struct
.	O
tv_usec	long
/	O
100000	int
)	O
)	O
;	O
delta	double
=	O
delta	double
/	O
10.	int
;	O
printf	function
(	O
"%s %d bytes in %.1f seconds"	pointer
,	O
direction	pointer
,	O
(	O
int	O
)	O
amount	long
,	O
delta	double
)	O
;	O
if	O
(	O
verbose	int
)	O
printf	function
(	O
" [%.0f bits/sec]"	pointer
,	O
(	O
amount	long
*	O
8.	int
)	O
/	O
delta	double
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
static	O
void	O
timer	function
(	O
int	O
sig	int
)	O
{	O
timeout	int
+=	O
rexmtval	int
;	O
if	O
(	O
timeout	int
>=	O
maxtimeout	int
)	O
{	O
printf	function
(	O
"Transfer timed out.\n"	pointer
)	O
;	O
longjmp	function
(	O
toplevel	array
,	O
-	O
1	int
)	O
;	O
}	O
longjmp	function
(	O
timeoutbuf	array
,	O
1	int
)	O
;	O
}	O
