static	O
int	O
gamma_inc_D	function
(	O
const	O
double	O
a	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
if	O
(	O
a	double
<	O
10.0	int
)	O
{	O
double	O
lnr	pointer
;	O
gsl_sf_result	struct
lg	struct
;	O
gsl_sf_lngamma_e	function
(	O
a	double
+	O
1.0	int
,	O
&	O
lg	struct
)	O
;	O
lnr	pointer
=	O
a	double
*	O
log	function
(	O
x	double
)	O
-	O
x	double
-	O
lg	struct
.	O
val	double
;	O
result	pointer
->	O
val	double
=	O
exp	function
(	O
lnr	pointer
)	O
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	function
(	O
lnr	pointer
)	O
+	O
1.0	int
)	O
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
gsl_sf_result	struct
gstar	struct
;	O
gsl_sf_result	struct
ln_term	struct
;	O
double	O
term1	double
;	O
if	O
(	O
x	double
<	O
0.5	int
*	O
a	double
)	O
{	O
double	O
u	double
=	O
x	double
/	O
a	double
;	O
double	O
ln_u	double
=	O
log	function
(	O
u	double
)	O
;	O
ln_term	struct
.	O
val	double
=	O
ln_u	double
-	O
u	double
+	O
1.0	int
;	O
ln_term	struct
.	O
err	double
=	O
(	O
fabs	function
(	O
ln_u	double
)	O
+	O
fabs	function
(	O
u	double
)	O
+	O
1.0	int
)	O
*	O
GSL_DBL_EPSILON	int
;	O
}	O
else	O
{	O
double	O
mu	double
=	O
(	O
x	double
-	O
a	double
)	O
/	O
a	double
;	O
gsl_sf_log_1plusx_mx_e	function
(	O
mu	double
,	O
&	O
ln_term	struct
)	O
;	O
ln_term	struct
.	O
err	double
+=	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
mu	double
)	O
;	O
}	O
;	O
gsl_sf_gammastar_e	function
(	O
a	double
,	O
&	O
gstar	struct
)	O
;	O
term1	double
=	O
exp	function
(	O
a	double
*	O
ln_term	struct
.	O
val	double
)	O
/	O
sqrt	function
(	O
2.0	int
*	O
M_PI	int
*	O
a	double
)	O
;	O
result	pointer
->	O
val	double
=	O
term1	double
/	O
gstar	struct
.	O
val	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	function
(	O
a	double
*	O
ln_term	struct
.	O
val	double
)	O
+	O
1.0	int
)	O
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
result	pointer
->	O
err	double
+=	O
fabs	function
(	O
a	double
)	O
*	O
ln_term	struct
.	O
err	double
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
result	pointer
->	O
err	double
+=	O
gstar	struct
.	O
err	double
/	O
fabs	function
(	O
gstar	struct
.	O
val	double
)	O
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
static	O
int	O
gamma_inc_P_series	function
(	O
const	O
double	O
a	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
const	O
int	O
nmax	int
=	O
10000	int
;	O
gsl_sf_result	struct
D	struct
;	O
int	O
stat_D	int
=	O
gamma_inc_D	function
(	O
a	double
,	O
x	double
,	O
&	O
D	struct
)	O
;	O
if	O
(	O
x	double
>	O
0.995	int
*	O
a	double
&&	O
a	double
>	O
1e5	int
)	O
{	O
gsl_sf_result	struct
cf_res	struct
;	O
int	O
status	int
=	O
gsl_sf_exprel_n_CF_e	function
(	O
a	double
,	O
x	double
,	O
&	O
cf_res	struct
)	O
;	O
result	pointer
->	O
val	double
=	O
D	struct
.	O
val	double
*	O
cf_res	struct
.	O
val	double
;	O
result	pointer
->	O
err	double
=	O
fabs	function
(	O
D	struct
.	O
val	double
*	O
cf_res	struct
.	O
err	double
)	O
+	O
fabs	function
(	O
D	struct
.	O
err	double
*	O
cf_res	struct
.	O
val	double
)	O
;	O
return	O
status	int
;	O
}	O
if	O
(	O
x	double
>	O
(	O
a	double
+	O
nmax	int
)	O
)	O
{	O
GSL_ERROR	O
(	O
"gamma_inc_P_series x>>a exceeds range"	pointer
,	O
GSL_EMAXITER	int
)	O
;	O
}	O
{	O
double	O
sum	double
=	O
1.0	int
;	O
double	O
term	double
=	O
1.0	int
;	O
double	O
remainder	function
;	O
int	O
n	int
;	O
int	O
nlow	int
=	O
(	O
x	double
>	O
a	double
)	O
?	O
(	O
x	double
-	O
a	double
)	O
:	O
0	int
;	O
for	O
(	O
n	int
=	O
1	int
;	O
n	int
<	O
nlow	int
;	O
n	int
++	O
)	O
{	O
term	double
*=	O
x	double
/	O
(	O
a	double
+	O
n	int
)	O
;	O
sum	double
+=	O
term	double
;	O
}	O
for	O
(	O
;	O
n	int
<	O
nmax	int
;	O
n	int
++	O
)	O
{	O
term	double
*=	O
x	double
/	O
(	O
a	double
+	O
n	int
)	O
;	O
sum	double
+=	O
term	double
;	O
if	O
(	O
fabs	function
(	O
term	double
/	O
sum	double
)	O
<	O
GSL_DBL_EPSILON	int
)	O
break	O
;	O
}	O
{	O
double	O
tnp1	double
=	O
(	O
x	double
/	O
(	O
a	double
+	O
n	int
)	O
)	O
*	O
term	double
;	O
remainder	function
=	O
tnp1	double
/	O
(	O
1.0	int
-	O
x	double
/	O
(	O
a	double
+	O
n	int
+	O
1.0	int
)	O
)	O
;	O
}	O
result	pointer
->	O
val	double
=	O
D	struct
.	O
val	double
*	O
sum	double
;	O
result	pointer
->	O
err	double
=	O
D	struct
.	O
err	double
*	O
fabs	function
(	O
sum	double
)	O
+	O
fabs	function
(	O
D	struct
.	O
val	double
*	O
remainder	function
)	O
;	O
result	pointer
->	O
err	double
+=	O
(	O
1.0	int
+	O
n	int
)	O
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
if	O
(	O
n	int
==	O
nmax	int
&&	O
fabs	function
(	O
remainder	function
/	O
sum	double
)	O
>	O
GSL_SQRT_DBL_EPSILON	int
)	O
GSL_ERROR	O
(	O
"gamma_inc_P_series failed to converge"	pointer
,	O
GSL_EMAXITER	int
)	O
;	O
else	O
return	O
stat_D	int
;	O
}	O
}	O
static	O
int	O
gamma_inc_Q_large_x	function
(	O
const	O
double	O
a	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
const	O
int	O
nmax	int
=	O
5000	int
;	O
gsl_sf_result	struct
D	struct
;	O
const	O
int	O
stat_D	int
=	O
gamma_inc_D	function
(	O
a	double
,	O
x	double
,	O
&	O
D	struct
)	O
;	O
double	O
sum	double
=	O
1.0	int
;	O
double	O
term	double
=	O
1.0	int
;	O
double	O
last	double
=	O
1.0	int
;	O
int	O
n	int
;	O
for	O
(	O
n	int
=	O
1	int
;	O
n	int
<	O
nmax	int
;	O
n	int
++	O
)	O
{	O
term	double
*=	O
(	O
a	double
-	O
n	int
)	O
/	O
x	double
;	O
if	O
(	O
fabs	function
(	O
term	double
/	O
last	double
)	O
>	O
1.0	int
)	O
break	O
;	O
if	O
(	O
fabs	function
(	O
term	double
/	O
sum	double
)	O
<	O
GSL_DBL_EPSILON	int
)	O
break	O
;	O
sum	double
+=	O
term	double
;	O
last	double
=	O
term	double
;	O
}	O
result	pointer
->	O
val	double
=	O
D	struct
.	O
val	double
*	O
(	O
a	double
/	O
x	double
)	O
*	O
sum	double
;	O
result	pointer
->	O
err	double
=	O
D	struct
.	O
err	double
*	O
fabs	function
(	O
(	O
a	double
/	O
x	double
)	O
*	O
sum	double
)	O
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
if	O
(	O
n	int
==	O
nmax	int
)	O
GSL_ERROR	O
(	O
"error in large x asymptotic"	pointer
,	O
GSL_EMAXITER	int
)	O
;	O
else	O
return	O
stat_D	int
;	O
}	O
static	O
int	O
gamma_inc_Q_asymp_unif	function
(	O
const	O
double	O
a	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
const	O
double	O
rta	double
=	O
sqrt	function
(	O
a	double
)	O
;	O
const	O
double	O
eps	double
=	O
(	O
x	double
-	O
a	double
)	O
/	O
a	double
;	O
gsl_sf_result	struct
ln_term	struct
;	O
const	O
int	O
stat_ln	int
=	O
gsl_sf_log_1plusx_mx_e	function
(	O
eps	double
,	O
&	O
ln_term	struct
)	O
;	O
const	O
double	O
eta	double
=	O
GSL_SIGN	O
(	O
eps	double
)	O
*	O
sqrt	function
(	O
-	O
2.0	int
*	O
ln_term	struct
.	O
val	double
)	O
;	O
gsl_sf_result	struct
erfc	function
;	O
double	O
R	double
;	O
double	O
c0	double
,	O
c1	double
;	O
gsl_sf_erfc_e	function
(	O
eta	double
*	O
rta	double
/	O
M_SQRT2	int
,	O
&	O
erfc	function
)	O
;	O
if	O
(	O
fabs	function
(	O
eps	double
)	O
<	O
GSL_ROOT5_DBL_EPSILON	int
)	O
{	O
c0	double
=	O
-	O
1.0	int
/	O
3.0	int
+	O
eps	double
*	O
(	O
1.0	int
/	O
12.0	int
-	O
eps	double
*	O
(	O
23.0	int
/	O
540.0	int
-	O
eps	double
*	O
(	O
353.0	int
/	O
12960.0	int
-	O
eps	double
*	O
589.0	int
/	O
30240.0	int
)	O
)	O
)	O
;	O
c1	double
=	O
-	O
1.0	int
/	O
540.0	int
-	O
eps	double
/	O
288.0	int
;	O
}	O
else	O
{	O
const	O
double	O
rt_term	double
=	O
sqrt	function
(	O
-	O
2.0	int
*	O
ln_term	struct
.	O
val	double
/	O
(	O
eps	double
*	O
eps	double
)	O
)	O
;	O
const	O
double	O
lam	double
=	O
x	double
/	O
a	double
;	O
c0	double
=	O
(	O
1.0	int
-	O
1.0	int
/	O
rt_term	double
)	O
/	O
eps	double
;	O
c1	double
=	O
-	O
(	O
eta	double
*	O
eta	double
*	O
eta	double
*	O
(	O
lam	double
*	O
lam	double
+	O
10.0	int
*	O
lam	double
+	O
1.0	int
)	O
-	O
12.0	int
*	O
eps	double
*	O
eps	double
*	O
eps	double
)	O
/	O
(	O
12.0	int
*	O
eta	double
*	O
eta	double
*	O
eta	double
*	O
eps	double
*	O
eps	double
*	O
eps	double
)	O
;	O
}	O
R	double
=	O
exp	function
(	O
-	O
0.5	int
*	O
a	double
*	O
eta	double
*	O
eta	double
)	O
/	O
(	O
M_SQRT2	int
*	O
M_SQRTPI	int
*	O
rta	double
)	O
*	O
(	O
c0	double
+	O
c1	double
/	O
a	double
)	O
;	O
result	pointer
->	O
val	double
=	O
0.5	int
*	O
erfc	function
.	O
val	double
+	O
R	double
;	O
result	pointer
->	O
err	double
=	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
R	double
*	O
0.5	int
*	O
a	double
*	O
eta	double
*	O
eta	double
)	O
+	O
0.5	int
*	O
erfc	function
.	O
err	double
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
stat_ln	int
;	O
}	O
static	O
int	O
gamma_inc_F_CF	function
(	O
const	O
double	O
a	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
const	O
int	O
nmax	int
=	O
5000	int
;	O
const	O
double	O
small	double
=	O
gsl_pow_3	function
(	O
GSL_DBL_EPSILON	int
)	O
;	O
double	O
hn	double
=	O
1.0	int
;	O
double	O
Cn	double
=	O
1.0	int
/	O
small	double
;	O
double	O
Dn	double
=	O
1.0	int
;	O
int	O
n	int
;	O
for	O
(	O
n	int
=	O
2	int
;	O
n	int
<	O
nmax	int
;	O
n	int
++	O
)	O
{	O
double	O
an	double
;	O
double	O
delta	double
;	O
if	O
(	O
GSL_IS_ODD	O
(	O
n	int
)	O
)	O
an	double
=	O
0.5	int
*	O
(	O
n	int
-	O
1	int
)	O
/	O
x	double
;	O
else	O
an	double
=	O
(	O
0.5	int
*	O
n	int
-	O
a	double
)	O
/	O
x	double
;	O
Dn	double
=	O
1.0	int
+	O
an	double
*	O
Dn	double
;	O
if	O
(	O
fabs	function
(	O
Dn	double
)	O
<	O
small	double
)	O
Dn	double
=	O
small	double
;	O
Cn	double
=	O
1.0	int
+	O
an	double
/	O
Cn	double
;	O
if	O
(	O
fabs	function
(	O
Cn	double
)	O
<	O
small	double
)	O
Cn	double
=	O
small	double
;	O
Dn	double
=	O
1.0	int
/	O
Dn	double
;	O
delta	double
=	O
Cn	double
*	O
Dn	double
;	O
hn	double
*=	O
delta	double
;	O
if	O
(	O
fabs	function
(	O
delta	double
-	O
1.0	int
)	O
<	O
GSL_DBL_EPSILON	int
)	O
break	O
;	O
}	O
result	pointer
->	O
val	double
=	O
hn	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
hn	double
)	O
;	O
result	pointer
->	O
err	double
+=	O
GSL_DBL_EPSILON	int
*	O
(	O
2.0	int
+	O
0.5	int
*	O
n	int
)	O
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
if	O
(	O
n	int
==	O
nmax	int
)	O
GSL_ERROR	O
(	O
"error in CF for F(a,x)"	pointer
,	O
GSL_EMAXITER	int
)	O
;	O
else	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
gamma_inc_Q_CF	function
(	O
const	O
double	O
a	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
gsl_sf_result	struct
D	struct
;	O
gsl_sf_result	struct
F	struct
;	O
const	O
int	O
stat_D	int
=	O
gamma_inc_D	function
(	O
a	double
,	O
x	double
,	O
&	O
D	struct
)	O
;	O
const	O
int	O
stat_F	int
=	O
gamma_inc_F_CF	function
(	O
a	double
,	O
x	double
,	O
&	O
F	struct
)	O
;	O
result	pointer
->	O
val	double
=	O
D	struct
.	O
val	double
*	O
(	O
a	double
/	O
x	double
)	O
*	O
F	struct
.	O
val	double
;	O
result	pointer
->	O
err	double
=	O
D	struct
.	O
err	double
*	O
fabs	function
(	O
(	O
a	double
/	O
x	double
)	O
*	O
F	struct
.	O
val	double
)	O
+	O
fabs	function
(	O
D	struct
.	O
val	double
*	O
a	double
/	O
x	double
*	O
F	struct
.	O
err	double
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_F	int
,	O
stat_D	int
)	O
;	O
}	O
static	O
int	O
gamma_inc_Q_series	function
(	O
const	O
double	O
a	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
double	O
term1	double
;	O
double	O
sum	double
;	O
int	O
stat_sum	int
;	O
double	O
term2	double
;	O
{	O
const	O
double	O
pg21	double
=	O
-	O
2.404113806319188570799476	int
;	O
const	O
double	O
lnx	double
=	O
log	function
(	O
x	double
)	O
;	O
const	O
double	O
el	double
=	O
M_EULER	int
+	O
lnx	double
;	O
const	O
double	O
c1	double
=	O
-	O
el	double
;	O
const	O
double	O
c2	double
=	O
M_PI	int
*	O
M_PI	int
/	O
12.0	int
-	O
0.5	int
*	O
el	double
*	O
el	double
;	O
const	O
double	O
c3	double
=	O
el	double
*	O
(	O
M_PI	int
*	O
M_PI	int
/	O
12.0	int
-	O
el	double
*	O
el	double
/	O
6.0	int
)	O
+	O
pg21	double
/	O
6.0	int
;	O
const	O
double	O
c4	double
=	O
-	O
0.04166666666666666667	int
*	O
(	O
-	O
1.758243446661483480	int
+	O
lnx	double
)	O
*	O
(	O
-	O
0.764428657272716373	int
+	O
lnx	double
)	O
*	O
(	O
0.723980571623507657	int
+	O
lnx	double
)	O
*	O
(	O
4.107554191916823640	int
+	O
lnx	double
)	O
;	O
const	O
double	O
c5	double
=	O
-	O
0.0083333333333333333	int
*	O
(	O
-	O
2.06563396085715900	int
+	O
lnx	double
)	O
*	O
(	O
-	O
1.28459889470864700	int
+	O
lnx	double
)	O
*	O
(	O
-	O
0.27583535756454143	int
+	O
lnx	double
)	O
*	O
(	O
1.33677371336239618	int
+	O
lnx	double
)	O
*	O
(	O
5.17537282427561550	int
+	O
lnx	double
)	O
;	O
const	O
double	O
c6	double
=	O
-	O
0.0013888888888888889	int
*	O
(	O
-	O
2.30814336454783200	int
+	O
lnx	double
)	O
*	O
(	O
-	O
1.65846557706987300	int
+	O
lnx	double
)	O
*	O
(	O
-	O
0.88768082560020400	int
+	O
lnx	double
)	O
*	O
(	O
0.17043847751371778	int
+	O
lnx	double
)	O
*	O
(	O
1.92135970115863890	int
+	O
lnx	double
)	O
*	O
(	O
6.22578557795474900	int
+	O
lnx	double
)	O
;	O
const	O
double	O
c7	double
=	O
-	O
0.00019841269841269841	int
*	O
(	O
-	O
2.5078657901291800	int
+	O
lnx	double
)	O
*	O
(	O
-	O
1.9478900888958200	int
+	O
lnx	double
)	O
*	O
(	O
-	O
1.3194837322612730	int
+	O
lnx	double
)	O
*	O
(	O
-	O
0.5281322700249279	int
+	O
lnx	double
)	O
*	O
(	O
0.5913834939078759	int
+	O
lnx	double
)	O
*	O
(	O
2.4876819633378140	int
+	O
lnx	double
)	O
*	O
(	O
7.2648160783762400	int
+	O
lnx	double
)	O
;	O
const	O
double	O
c8	double
=	O
-	O
0.00002480158730158730	int
*	O
(	O
-	O
2.677341544966400	int
+	O
lnx	double
)	O
*	O
(	O
-	O
2.182810448271700	int
+	O
lnx	double
)	O
*	O
(	O
-	O
1.649350342277400	int
+	O
lnx	double
)	O
*	O
(	O
-	O
1.014099048290790	int
+	O
lnx	double
)	O
*	O
(	O
-	O
0.191366955370652	int
+	O
lnx	double
)	O
*	O
(	O
0.995403817918724	int
+	O
lnx	double
)	O
*	O
(	O
3.041323283529310	int
+	O
lnx	double
)	O
*	O
(	O
8.295966556941250	int
+	O
lnx	double
)	O
;	O
const	O
double	O
c9	double
=	O
-	O
2.75573192239859e-6	int
*	O
(	O
-	O
2.8243487670469080	int
+	O
lnx	double
)	O
*	O
(	O
-	O
2.3798494322701120	int
+	O
lnx	double
)	O
*	O
(	O
-	O
1.9143674728689960	int
+	O
lnx	double
)	O
*	O
(	O
-	O
1.3814529102920370	int
+	O
lnx	double
)	O
*	O
(	O
-	O
0.7294312810261694	int
+	O
lnx	double
)	O
*	O
(	O
0.1299079285269565	int
+	O
lnx	double
)	O
*	O
(	O
1.3873333251885240	int
+	O
lnx	double
)	O
*	O
(	O
3.5857258865210760	int
+	O
lnx	double
)	O
*	O
(	O
9.3214237073814600	int
+	O
lnx	double
)	O
;	O
const	O
double	O
c10	double
=	O
-	O
2.75573192239859e-7	int
*	O
(	O
-	O
2.9540329644556910	int
+	O
lnx	double
)	O
*	O
(	O
-	O
2.5491366926991850	int
+	O
lnx	double
)	O
*	O
(	O
-	O
2.1348279229279880	int
+	O
lnx	double
)	O
*	O
(	O
-	O
1.6741881076349450	int
+	O
lnx	double
)	O
*	O
(	O
-	O
1.1325949616098420	int
+	O
lnx	double
)	O
*	O
(	O
-	O
0.4590034650618494	int
+	O
lnx	double
)	O
*	O
(	O
0.4399352987435699	int
+	O
lnx	double
)	O
*	O
(	O
1.7702236517651670	int
+	O
lnx	double
)	O
*	O
(	O
4.1231539047474080	int
+	O
lnx	double
)	O
*	O
(	O
10.342627908148680	int
+	O
lnx	double
)	O
;	O
term1	double
=	O
a	double
*	O
(	O
c1	double
+	O
a	double
*	O
(	O
c2	double
+	O
a	double
*	O
(	O
c3	double
+	O
a	double
*	O
(	O
c4	double
+	O
a	double
*	O
(	O
c5	double
+	O
a	double
*	O
(	O
c6	double
+	O
a	double
*	O
(	O
c7	double
+	O
a	double
*	O
(	O
c8	double
+	O
a	double
*	O
(	O
c9	double
+	O
a	double
*	O
c10	double
)	O
)	O
)	O
)	O
)	O
)	O
)	O
)	O
)	O
;	O
}	O
{	O
const	O
int	O
nmax	int
=	O
5000	int
;	O
double	O
t	double
=	O
1.0	int
;	O
int	O
n	int
;	O
sum	double
=	O
1.0	int
;	O
for	O
(	O
n	int
=	O
1	int
;	O
n	int
<	O
nmax	int
;	O
n	int
++	O
)	O
{	O
t	double
*=	O
-	O
x	double
/	O
(	O
n	int
+	O
1.0	int
)	O
;	O
sum	double
+=	O
(	O
a	double
+	O
1.0	int
)	O
/	O
(	O
a	double
+	O
n	int
+	O
1.0	int
)	O
*	O
t	double
;	O
if	O
(	O
fabs	function
(	O
t	double
/	O
sum	double
)	O
<	O
GSL_DBL_EPSILON	int
)	O
break	O
;	O
}	O
if	O
(	O
n	int
==	O
nmax	int
)	O
stat_sum	int
=	O
GSL_EMAXITER	int
;	O
else	O
stat_sum	int
=	O
GSL_SUCCESS	int
;	O
}	O
term2	double
=	O
(	O
1.0	int
-	O
term1	double
)	O
*	O
a	double
/	O
(	O
a	double
+	O
1.0	int
)	O
*	O
x	double
*	O
sum	double
;	O
result	pointer
->	O
val	double
=	O
term1	double
+	O
term2	double
;	O
result	pointer
->	O
err	double
=	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	function
(	O
term1	double
)	O
+	O
2.0	int
*	O
fabs	function
(	O
term2	double
)	O
)	O
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
stat_sum	int
;	O
}	O
static	O
int	O
gamma_inc_series	function
(	O
double	O
a	double
,	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
gsl_sf_result	struct
Q	struct
;	O
gsl_sf_result	struct
G	struct
;	O
const	O
int	O
stat_Q	int
=	O
gamma_inc_Q_series	function
(	O
a	double
,	O
x	double
,	O
&	O
Q	struct
)	O
;	O
const	O
int	O
stat_G	int
=	O
gsl_sf_gamma_e	function
(	O
a	double
,	O
&	O
G	struct
)	O
;	O
result	pointer
->	O
val	double
=	O
Q	struct
.	O
val	double
*	O
G	struct
.	O
val	double
;	O
result	pointer
->	O
err	double
=	O
fabs	function
(	O
Q	struct
.	O
val	double
*	O
G	struct
.	O
err	double
)	O
+	O
fabs	function
(	O
Q	struct
.	O
err	double
*	O
G	struct
.	O
val	double
)	O
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_Q	int
,	O
stat_G	int
)	O
;	O
}	O
static	O
int	O
gamma_inc_a_gt_0	function
(	O
double	O
a	double
,	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
gsl_sf_result	struct
Q	struct
;	O
gsl_sf_result	struct
G	struct
;	O
const	O
int	O
stat_Q	int
=	O
gsl_sf_gamma_inc_Q_e	function
(	O
a	double
,	O
x	double
,	O
&	O
Q	struct
)	O
;	O
const	O
int	O
stat_G	int
=	O
gsl_sf_gamma_e	function
(	O
a	double
,	O
&	O
G	struct
)	O
;	O
result	pointer
->	O
val	double
=	O
G	struct
.	O
val	double
*	O
Q	struct
.	O
val	double
;	O
result	pointer
->	O
err	double
=	O
fabs	function
(	O
G	struct
.	O
val	double
*	O
Q	struct
.	O
err	double
)	O
+	O
fabs	function
(	O
G	struct
.	O
err	double
*	O
Q	struct
.	O
val	double
)	O
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_G	int
,	O
stat_Q	int
)	O
;	O
}	O
static	O
int	O
gamma_inc_CF	function
(	O
double	O
a	double
,	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
gsl_sf_result	struct
F	struct
;	O
gsl_sf_result	struct
pre	struct
;	O
const	O
double	O
am1lgx	double
=	O
(	O
a	double
-	O
1.0	int
)	O
*	O
log	function
(	O
x	double
)	O
;	O
const	O
int	O
stat_F	int
=	O
gamma_inc_F_CF	function
(	O
a	double
,	O
x	double
,	O
&	O
F	struct
)	O
;	O
const	O
int	O
stat_E	int
=	O
gsl_sf_exp_err_e	function
(	O
am1lgx	double
-	O
x	double
,	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
am1lgx	double
)	O
,	O
&	O
pre	struct
)	O
;	O
result	pointer
->	O
val	double
=	O
F	struct
.	O
val	double
*	O
pre	struct
.	O
val	double
;	O
result	pointer
->	O
err	double
=	O
fabs	function
(	O
F	struct
.	O
err	double
*	O
pre	struct
.	O
val	double
)	O
+	O
fabs	function
(	O
F	struct
.	O
val	double
*	O
pre	struct
.	O
err	double
)	O
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_F	int
,	O
stat_E	int
)	O
;	O
}	O
int	O
gsl_sf_gamma_inc_Q_e	function
(	O
const	O
double	O
a	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
if	O
(	O
a	double
<	O
0.0	int
||	O
x	double
<	O
0.0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
x	double
==	O
0.0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
1.0	int
;	O
result	pointer
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
a	double
==	O
0.0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
0.0	int
;	O
result	pointer
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
<=	O
0.5	int
*	O
a	double
)	O
{	O
gsl_sf_result	struct
P	struct
;	O
int	O
stat_P	int
=	O
gamma_inc_P_series	function
(	O
a	double
,	O
x	double
,	O
&	O
P	struct
)	O
;	O
result	pointer
->	O
val	double
=	O
1.0	int
-	O
P	struct
.	O
val	double
;	O
result	pointer
->	O
err	double
=	O
P	struct
.	O
err	double
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
stat_P	int
;	O
}	O
else	O
if	O
(	O
a	double
>=	O
1.0e+06	int
&&	O
(	O
x	double
-	O
a	double
)	O
*	O
(	O
x	double
-	O
a	double
)	O
<	O
a	double
)	O
{	O
return	O
gamma_inc_Q_asymp_unif	function
(	O
a	double
,	O
x	double
,	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
a	double
<	O
0.2	int
&&	O
x	double
<	O
5.0	int
)	O
{	O
return	O
gamma_inc_Q_series	function
(	O
a	double
,	O
x	double
,	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
a	double
<=	O
x	double
)	O
{	O
if	O
(	O
x	double
<=	O
1.0e+06	int
)	O
{	O
return	O
gamma_inc_Q_CF	function
(	O
a	double
,	O
x	double
,	O
result	pointer
)	O
;	O
}	O
else	O
{	O
return	O
gamma_inc_Q_large_x	function
(	O
a	double
,	O
x	double
,	O
result	pointer
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
x	double
>	O
a	double
-	O
sqrt	function
(	O
a	double
)	O
)	O
{	O
return	O
gamma_inc_Q_CF	function
(	O
a	double
,	O
x	double
,	O
result	pointer
)	O
;	O
}	O
else	O
{	O
gsl_sf_result	struct
P	struct
;	O
int	O
stat_P	int
=	O
gamma_inc_P_series	function
(	O
a	double
,	O
x	double
,	O
&	O
P	struct
)	O
;	O
result	pointer
->	O
val	double
=	O
1.0	int
-	O
P	struct
.	O
val	double
;	O
result	pointer
->	O
err	double
=	O
P	struct
.	O
err	double
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
stat_P	int
;	O
}	O
}	O
}	O
int	O
gsl_sf_gamma_inc_P_e	function
(	O
const	O
double	O
a	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
if	O
(	O
a	double
<=	O
0.0	int
||	O
x	double
<	O
0.0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
x	double
==	O
0.0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
0.0	int
;	O
result	pointer
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
<	O
20.0	int
||	O
x	double
<	O
0.5	int
*	O
a	double
)	O
{	O
return	O
gamma_inc_P_series	function
(	O
a	double
,	O
x	double
,	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
a	double
>	O
1.0e+06	int
&&	O
(	O
x	double
-	O
a	double
)	O
*	O
(	O
x	double
-	O
a	double
)	O
<	O
a	double
)	O
{	O
gsl_sf_result	struct
Q	struct
;	O
int	O
stat_Q	int
=	O
gamma_inc_Q_asymp_unif	function
(	O
a	double
,	O
x	double
,	O
&	O
Q	struct
)	O
;	O
result	pointer
->	O
val	double
=	O
1.0	int
-	O
Q	struct
.	O
val	double
;	O
result	pointer
->	O
err	double
=	O
Q	struct
.	O
err	double
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
stat_Q	int
;	O
}	O
else	O
if	O
(	O
a	double
<=	O
x	double
)	O
{	O
gsl_sf_result	struct
Q	struct
;	O
int	O
stat_Q	int
;	O
if	O
(	O
a	double
>	O
0.2	int
*	O
x	double
)	O
{	O
stat_Q	int
=	O
gamma_inc_Q_CF	function
(	O
a	double
,	O
x	double
,	O
&	O
Q	struct
)	O
;	O
}	O
else	O
{	O
stat_Q	int
=	O
gamma_inc_Q_large_x	function
(	O
a	double
,	O
x	double
,	O
&	O
Q	struct
)	O
;	O
}	O
result	pointer
->	O
val	double
=	O
1.0	int
-	O
Q	struct
.	O
val	double
;	O
result	pointer
->	O
err	double
=	O
Q	struct
.	O
err	double
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
stat_Q	int
;	O
}	O
else	O
{	O
if	O
(	O
(	O
x	double
-	O
a	double
)	O
*	O
(	O
x	double
-	O
a	double
)	O
<	O
a	double
)	O
{	O
gsl_sf_result	struct
Q	struct
;	O
int	O
stat_Q	int
=	O
gamma_inc_Q_CF	function
(	O
a	double
,	O
x	double
,	O
&	O
Q	struct
)	O
;	O
result	pointer
->	O
val	double
=	O
1.0	int
-	O
Q	struct
.	O
val	double
;	O
result	pointer
->	O
err	double
=	O
Q	struct
.	O
err	double
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
stat_Q	int
;	O
}	O
else	O
{	O
return	O
gamma_inc_P_series	function
(	O
a	double
,	O
x	double
,	O
result	pointer
)	O
;	O
}	O
}	O
}	O
int	O
gsl_sf_gamma_inc_e	function
(	O
const	O
double	O
a	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
if	O
(	O
x	double
<	O
0.0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
x	double
==	O
0.0	int
)	O
{	O
return	O
gsl_sf_gamma_e	function
(	O
a	double
,	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
a	double
==	O
0.0	int
)	O
{	O
return	O
GAMMA_INC_A_0	O
(	O
x	double
,	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
a	double
>	O
0.0	int
)	O
{	O
return	O
gamma_inc_a_gt_0	function
(	O
a	double
,	O
x	double
,	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
x	double
>	O
0.25	int
)	O
{	O
return	O
gamma_inc_CF	function
(	O
a	double
,	O
x	double
,	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
fabs	function
(	O
a	double
)	O
<	O
0.5	int
)	O
{	O
return	O
gamma_inc_series	function
(	O
a	double
,	O
x	double
,	O
result	pointer
)	O
;	O
}	O
else	O
{	O
const	O
double	O
fa	double
=	O
floor	function
(	O
a	double
)	O
;	O
const	O
double	O
da	double
=	O
a	double
-	O
fa	double
;	O
gsl_sf_result	struct
g_da	struct
;	O
const	O
int	O
stat_g_da	int
=	O
(	O
da	double
>	O
0.0	int
?	O
gamma_inc_a_gt_0	function
(	O
da	double
,	O
x	double
,	O
&	O
g_da	struct
)	O
:	O
GAMMA_INC_A_0	O
(	O
x	double
,	O
&	O
g_da	struct
)	O
)	O
;	O
double	O
alpha	double
=	O
da	double
;	O
double	O
gax	double
=	O
g_da	struct
.	O
val	double
;	O
do	O
{	O
const	O
double	O
shift	double
=	O
exp	function
(	O
-	O
x	double
+	O
(	O
alpha	double
-	O
1.0	int
)	O
*	O
log	function
(	O
x	double
)	O
)	O
;	O
gax	double
=	O
(	O
gax	double
-	O
shift	double
)	O
/	O
(	O
alpha	double
-	O
1.0	int
)	O
;	O
alpha	double
-=	O
1.0	int
;	O
}	O
while	O
(	O
alpha	double
>	O
a	double
)	O
;	O
result	pointer
->	O
val	double
=	O
gax	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
(	O
1.0	int
+	O
fabs	function
(	O
a	double
)	O
)	O
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
gax	double
)	O
;	O
return	O
stat_g_da	int
;	O
}	O
}	O
double	O
gsl_sf_gamma_inc_P	function
(	O
const	O
double	O
a	double
,	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_gamma_inc_P_e	function
(	O
a	double
,	O
x	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
double	O
gsl_sf_gamma_inc_Q	function
(	O
const	O
double	O
a	double
,	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_gamma_inc_Q_e	function
(	O
a	double
,	O
x	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
double	O
gsl_sf_gamma_inc	function
(	O
const	O
double	O
a	double
,	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_gamma_inc_e	function
(	O
a	double
,	O
x	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
