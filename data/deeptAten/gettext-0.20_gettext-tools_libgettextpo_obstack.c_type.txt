static	O
void	O
*	O
call_chunkfun	O
(	O
struct	O
obstack	O
*	O
h	pointer
,	O
size_t	O
size	O
)	O
{	O
if	O
(	O
h	pointer
->	O
use_extra_arg	O
)	O
return	O
h	pointer
->	O
chunkfun	O
.	O
extra	O
(	O
h	pointer
->	O
extra_arg	O
,	O
size	O
)	O
;	O
else	O
return	O
h	pointer
->	O
chunkfun	O
.	O
plain	O
(	O
size	O
)	O
;	O
}	O
static	O
void	O
call_freefun	function
(	O
struct	O
obstack	O
*	O
h	pointer
,	O
void	O
*	O
old_chunk	O
)	O
{	O
if	O
(	O
h	pointer
->	O
use_extra_arg	O
)	O
h	pointer
->	O
freefun	O
.	O
extra	O
(	O
h	pointer
->	O
extra_arg	O
,	O
old_chunk	O
)	O
;	O
else	O
h	pointer
->	O
freefun	O
.	O
plain	O
(	O
old_chunk	O
)	O
;	O
}	O
static	O
int	O
_obstack_begin_worker	O
(	O
struct	O
obstack	O
*	O
h	pointer
,	O
_OBSTACK_SIZE_T	O
size	O
,	O
_OBSTACK_SIZE_T	O
alignment	O
)	O
{	O
struct	O
_obstack_chunk	O
*	O
chunk	O
;	O
if	O
(	O
alignment	O
==	O
0	int
)	O
alignment	O
=	O
DEFAULT_ALIGNMENT	O
;	O
if	O
(	O
size	O
==	O
0	int
)	O
{	O
int	O
extra	O
=	O
(	O
(	O
(	O
(	O
12	int
+	O
DEFAULT_ROUNDING	O
-	O
1	int
)	O
&	O
~	O
(	O
DEFAULT_ROUNDING	O
-	O
1	int
)	O
)	O
+	O
4	int
+	O
DEFAULT_ROUNDING	O
-	O
1	int
)	O
&	O
~	O
(	O
DEFAULT_ROUNDING	O
-	O
1	int
)	O
)	O
;	O
size	O
=	O
4096	int
-	O
extra	O
;	O
}	O
h	pointer
->	O
chunk_size	O
=	O
size	O
;	O
h	pointer
->	O
alignment_mask	O
=	O
alignment	O
-	O
1	int
;	O
chunk	O
=	O
h	pointer
->	O
chunk	O
=	O
call_chunkfun	O
(	O
h	pointer
,	O
h	pointer
->	O
chunk_size	O
)	O
;	O
if	O
(	O
!	O
chunk	O
)	O
(	O
*	O
obstack_alloc_failed_handler	O
)	O
(	O
)	O
;	O
h	pointer
->	O
next_free	O
=	O
h	pointer
->	O
object_base	O
=	O
__PTR_ALIGN	O
(	O
(	O
char	O
*	O
)	O
chunk	O
,	O
chunk	O
->	O
contents	O
,	O
alignment	O
-	O
1	int
)	O
;	O
h	pointer
->	O
chunk_limit	O
=	O
chunk	O
->	O
limit	O
=	O
(	O
char	O
*	O
)	O
chunk	O
+	O
h	pointer
->	O
chunk_size	O
;	O
chunk	O
->	O
prev	O
=	O
0	int
;	O
h	pointer
->	O
maybe_empty_object	O
=	O
0	int
;	O
h	pointer
->	O
alloc_failed	O
=	O
0	int
;	O
return	O
1	int
;	O
}	O
int	O
_obstack_begin	O
(	O
struct	O
obstack	O
*	O
h	pointer
,	O
_OBSTACK_SIZE_T	O
size	O
,	O
_OBSTACK_SIZE_T	O
alignment	O
,	O
void	O
*	O
(	O
*	O
chunkfun	O
)	O
(	O
size_t	O
)	O
,	O
void	O
(	O
*	O
freefun	O
)	O
(	O
void	O
*	O
)	O
)	O
{	O
h	pointer
->	O
chunkfun	O
.	O
plain	O
=	O
chunkfun	O
;	O
h	pointer
->	O
freefun	O
.	O
plain	O
=	O
freefun	O
;	O
h	pointer
->	O
use_extra_arg	O
=	O
0	int
;	O
return	O
_obstack_begin_worker	O
(	O
h	pointer
,	O
size	O
,	O
alignment	O
)	O
;	O
}	O
int	O
_obstack_begin_1	O
(	O
struct	O
obstack	O
*	O
h	pointer
,	O
_OBSTACK_SIZE_T	O
size	O
,	O
_OBSTACK_SIZE_T	O
alignment	O
,	O
void	O
*	O
(	O
*	O
chunkfun	O
)	O
(	O
void	O
*	O
,	O
size_t	O
)	O
,	O
void	O
(	O
*	O
freefun	O
)	O
(	O
void	O
*	O
,	O
void	O
*	O
)	O
,	O
void	O
*	O
arg	O
)	O
{	O
h	pointer
->	O
chunkfun	O
.	O
extra	O
=	O
chunkfun	O
;	O
h	pointer
->	O
freefun	O
.	O
extra	O
=	O
freefun	O
;	O
h	pointer
->	O
extra_arg	O
=	O
arg	O
;	O
h	pointer
->	O
use_extra_arg	O
=	O
1	int
;	O
return	O
_obstack_begin_worker	O
(	O
h	pointer
,	O
size	O
,	O
alignment	O
)	O
;	O
}	O
void	O
_obstack_newchunk	O
(	O
struct	O
obstack	O
*	O
h	pointer
,	O
_OBSTACK_SIZE_T	O
length	O
)	O
{	O
struct	O
_obstack_chunk	O
*	O
old_chunk	O
=	O
h	pointer
->	O
chunk	O
;	O
struct	O
_obstack_chunk	O
*	O
new_chunk	O
=	O
0	int
;	O
size_t	O
obj_size	O
=	O
h	pointer
->	O
next_free	O
-	O
h	pointer
->	O
object_base	O
;	O
char	O
*	O
object_base	O
;	O
size_t	O
sum1	O
=	O
obj_size	O
+	O
length	O
;	O
size_t	O
sum2	O
=	O
sum1	O
+	O
h	pointer
->	O
alignment_mask	O
;	O
size_t	O
new_size	O
=	O
sum2	O
+	O
(	O
obj_size	O
>>	O
3	int
)	O
+	O
100	int
;	O
if	O
(	O
new_size	O
<	O
sum2	O
)	O
new_size	O
=	O
sum2	O
;	O
if	O
(	O
new_size	O
<	O
h	pointer
->	O
chunk_size	O
)	O
new_size	O
=	O
h	pointer
->	O
chunk_size	O
;	O
if	O
(	O
obj_size	O
<=	O
sum1	O
&&	O
sum1	O
<=	O
sum2	O
)	O
new_chunk	O
=	O
call_chunkfun	O
(	O
h	pointer
,	O
new_size	O
)	O
;	O
if	O
(	O
!	O
new_chunk	O
)	O
(	O
*	O
obstack_alloc_failed_handler	O
)	O
(	O
)	O
;	O
h	pointer
->	O
chunk	O
=	O
new_chunk	O
;	O
new_chunk	O
->	O
prev	O
=	O
old_chunk	O
;	O
new_chunk	O
->	O
limit	O
=	O
h	pointer
->	O
chunk_limit	O
=	O
(	O
char	O
*	O
)	O
new_chunk	O
+	O
new_size	O
;	O
object_base	O
=	O
__PTR_ALIGN	O
(	O
(	O
char	O
*	O
)	O
new_chunk	O
,	O
new_chunk	O
->	O
contents	O
,	O
h	pointer
->	O
alignment_mask	O
)	O
;	O
memcpy	O
(	O
object_base	O
,	O
h	pointer
->	O
object_base	O
,	O
obj_size	O
)	O
;	O
if	O
(	O
!	O
h	pointer
->	O
maybe_empty_object	O
&&	O
(	O
h	pointer
->	O
object_base	O
==	O
__PTR_ALIGN	O
(	O
(	O
char	O
*	O
)	O
old_chunk	O
,	O
old_chunk	O
->	O
contents	O
,	O
h	pointer
->	O
alignment_mask	O
)	O
)	O
)	O
{	O
new_chunk	O
->	O
prev	O
=	O
old_chunk	O
->	O
prev	O
;	O
call_freefun	function
(	O
h	pointer
,	O
old_chunk	O
)	O
;	O
}	O
h	pointer
->	O
object_base	O
=	O
object_base	O
;	O
h	pointer
->	O
next_free	O
=	O
h	pointer
->	O
object_base	O
+	O
obj_size	O
;	O
h	pointer
->	O
maybe_empty_object	O
=	O
0	int
;	O
}	O
int	O
_obstack_allocated_p	O
(	O
struct	O
obstack	O
*	O
h	pointer
,	O
void	O
*	O
obj	pointer
)	O
__attribute_pure__	O
;	O
int	O
_obstack_allocated_p	O
(	O
struct	O
obstack	O
*	O
h	pointer
,	O
void	O
*	O
obj	pointer
)	O
{	O
struct	O
_obstack_chunk	O
*	O
lp	pointer
;	O
struct	O
_obstack_chunk	O
*	O
plp	pointer
;	O
lp	pointer
=	O
(	O
h	pointer
)	O
->	O
chunk	O
;	O
while	O
(	O
lp	pointer
!=	O
0	int
&&	O
(	O
(	O
void	O
*	O
)	O
lp	pointer
>=	O
obj	pointer
||	O
(	O
void	O
*	O
)	O
(	O
lp	pointer
)	O
->	O
limit	O
<	O
obj	pointer
)	O
)	O
{	O
plp	pointer
=	O
lp	pointer
->	O
prev	O
;	O
lp	pointer
=	O
plp	pointer
;	O
}	O
return	O
lp	pointer
!=	O
0	int
;	O
}	O
void	O
_obstack_free	O
(	O
struct	O
obstack	O
*	O
h	pointer
,	O
void	O
*	O
obj	pointer
)	O
{	O
struct	O
_obstack_chunk	O
*	O
lp	pointer
;	O
struct	O
_obstack_chunk	O
*	O
plp	pointer
;	O
lp	pointer
=	O
h	pointer
->	O
chunk	O
;	O
while	O
(	O
lp	pointer
!=	O
0	int
&&	O
(	O
(	O
void	O
*	O
)	O
lp	pointer
>=	O
obj	pointer
||	O
(	O
void	O
*	O
)	O
(	O
lp	pointer
)	O
->	O
limit	O
<	O
obj	pointer
)	O
)	O
{	O
plp	pointer
=	O
lp	pointer
->	O
prev	O
;	O
call_freefun	function
(	O
h	pointer
,	O
lp	pointer
)	O
;	O
lp	pointer
=	O
plp	pointer
;	O
h	pointer
->	O
maybe_empty_object	O
=	O
1	int
;	O
}	O
if	O
(	O
lp	pointer
)	O
{	O
h	pointer
->	O
object_base	O
=	O
h	pointer
->	O
next_free	O
=	O
(	O
char	O
*	O
)	O
(	O
obj	pointer
)	O
;	O
h	pointer
->	O
chunk_limit	O
=	O
lp	pointer
->	O
limit	O
;	O
h	pointer
->	O
chunk	O
=	O
lp	pointer
;	O
}	O
else	O
if	O
(	O
obj	pointer
!=	O
0	int
)	O
abort	O
(	O
)	O
;	O
}	O
_OBSTACK_SIZE_T	O
_obstack_memory_used	O
(	O
struct	O
obstack	O
*	O
h	pointer
)	O
{	O
struct	O
_obstack_chunk	O
*	O
lp	pointer
;	O
_OBSTACK_SIZE_T	O
nbytes	O
=	O
0	int
;	O
for	O
(	O
lp	pointer
=	O
h	pointer
->	O
chunk	O
;	O
lp	pointer
!=	O
0	int
;	O
lp	pointer
=	O
lp	pointer
->	O
prev	O
)	O
{	O
nbytes	O
+=	O
lp	pointer
->	O
limit	O
-	O
(	O
char	O
*	O
)	O
lp	pointer
;	O
}	O
return	O
nbytes	O
;	O
}	O
static	O
_Noreturn	O
void	O
print_and_abort	function
(	O
void	O
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"%s\n"	pointer
,	O
_	O
(	O
"memory exhausted"	pointer
)	O
)	O
;	O
exit	O
(	O
obstack_exit_failure	O
)	O
;	O
}	O
__attribute_noreturn__	O
void	O
(	O
*	O
obstack_alloc_failed_handler	O
)	O
(	O
void	O
)	O
=	O
print_and_abort	function
;	O
