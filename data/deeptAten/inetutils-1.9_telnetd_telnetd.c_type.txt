static	O
void	O
parse_authmode	function
(	O
char	O
*	O
str	pointer
)	O
;	O
static	O
void	O
parse_linemode	function
(	O
char	O
*	O
str	pointer
)	O
;	O
static	O
void	O
parse_debug_level	function
(	O
char	O
*	O
str	pointer
)	O
;	O
static	O
void	O
telnetd_setup	function
(	O
int	O
fd	int
)	O
;	O
static	O
int	O
telnetd_run	function
(	O
void	O
)	O
;	O
static	O
void	O
print_hostinfo	function
(	O
void	O
)	O
;	O
char	O
*	O
login_invocation	pointer
=	O
PATH_LOGIN	O
" -p -h %h %?u{-f %u}"	pointer
;	O
int	O
keepalive	int
=	O
1	int
;	O
int	O
reverse_lookup	int
=	O
0	int
;	O
int	O
alwayslinemode	int
;	O
int	O
lmodetype	int
;	O
int	O
hostinfo	int
=	O
1	int
;	O
int	O
auth_level	int
=	O
0	int
;	O
int	O
debug_level	array
[	O
debug_max_mode	int
]	O
;	O
int	O
debug_tcp	int
=	O
0	int
;	O
int	O
net	int
;	O
int	O
pty	int
;	O
char	O
*	O
remote_hostname	pointer
;	O
char	O
*	O
local_hostname	pointer
;	O
char	O
*	O
user_name	pointer
;	O
char	O
line	array
[	O
256	int
]	O
;	O
char	O
options	array
[	O
256	int
]	O
;	O
char	O
do_dont_resp	array
[	O
256	int
]	O
;	O
char	O
will_wont_resp	array
[	O
256	int
]	O
;	O
int	O
linemode	int
;	O
int	O
uselinemode	int
;	O
int	O
editmode	int
;	O
int	O
useeditmode	int
;	O
int	O
alwayslinemode	int
;	O
int	O
lmodetype	int
;	O
int	O
flowmode	int
;	O
int	O
restartany	int
;	O
int	O
diagnostic	int
;	O
slcfun	struct
slctab	array
[	O
NSLC	int
+	O
1	int
]	O
;	O
char	O
*	O
terminaltype	pointer
;	O
int	O
SYNCHing	int
;	O
struct	O
telnetd_clocks	struct
clocks	struct
;	O
static	O
struct	O
argp_option	struct
argp_options	array
[	O
]	O
=	O
{	O
{	O
"authmode"	pointer
,	O
'a'	O
,	O
"MODE"	pointer
,	O
0	int
,	O
"specify what mode to use for authentication"	pointer
}	O
,	O
{	O
"debug"	pointer
,	O
'D'	O
,	O
"LEVEL"	pointer
,	O
OPTION_ARG_OPTIONAL	int
,	O
"set debugging level"	pointer
}	O
,	O
{	O
"exec-login"	pointer
,	O
'E'	O
,	O
"STRING"	pointer
,	O
0	int
,	O
"set program to be executed instead of "	pointer
PATH_LOGIN	O
}	O
,	O
{	O
"no-hostinfo"	pointer
,	O
'h'	O
,	O
NULL	O
,	O
0	int
,	O
"do not print host information before login has been completed"	pointer
}	O
,	O
{	O
"linemode"	pointer
,	O
'l'	O
,	O
"MODE"	pointer
,	O
OPTION_ARG_OPTIONAL	int
,	O
"set line mode"	pointer
}	O
,	O
{	O
"no-keepalive"	pointer
,	O
'n'	O
,	O
NULL	O
,	O
0	int
,	O
"disable TCP keep-alives"	pointer
}	O
,	O
{	O
"reverse-lookup"	pointer
,	O
'U'	O
,	O
NULL	O
,	O
0	int
,	O
"refuse connections from addresses that "	pointer
"cannot be mapped back into a symbolic name"	pointer
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
error_t	int
parse_opt	function
(	O
int	O
key	int
,	O
char	O
*	O
arg	pointer
,	O
struct	O
argp_state	struct
*	O
state	pointer
)	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
'a'	O
:	O
parse_authmode	function
(	O
arg	pointer
)	O
;	O
break	O
;	O
case	O
'D'	O
:	O
parse_debug_level	function
(	O
arg	pointer
)	O
;	O
break	O
;	O
case	O
'E'	O
:	O
login_invocation	pointer
=	O
arg	pointer
;	O
break	O
;	O
case	O
'h'	O
:	O
hostinfo	int
=	O
0	int
;	O
break	O
;	O
case	O
'l'	O
:	O
parse_linemode	function
(	O
arg	pointer
)	O
;	O
break	O
;	O
case	O
'n'	O
:	O
keepalive	int
=	O
0	int
;	O
break	O
;	O
case	O
'U'	O
:	O
reverse_lookup	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
argp	struct
argp	struct
=	O
{	O
argp_options	array
,	O
parse_opt	function
,	O
NULL	O
,	O
"DARPA telnet protocol server"	pointer
}	O
;	O
int	O
main	function
(	O
int	O
argc	pointer
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
index	function
;	O
set_program_name	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
iu_argp_init	O
(	O
"telnetd"	pointer
,	O
default_program_authors	array
)	O
;	O
argp_parse	function
(	O
&	O
argp	struct
,	O
argc	pointer
,	O
argv	pointer
,	O
0	int
,	O
&	O
index	function
,	O
NULL	O
)	O
;	O
if	O
(	O
argc	pointer
!=	O
index	function
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"junk arguments in the command line"	pointer
)	O
;	O
openlog	function
(	O
"telnetd"	pointer
,	O
LOG_PID	int
|	O
LOG_ODELAY	int
,	O
LOG_DAEMON	O
)	O
;	O
telnetd_setup	function
(	O
0	int
)	O
;	O
return	O
telnetd_run	function
(	O
)	O
;	O
}	O
void	O
parse_linemode	function
(	O
char	O
*	O
str	pointer
)	O
{	O
if	O
(	O
!	O
str	pointer
)	O
alwayslinemode	int
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
"nokludge"	pointer
)	O
==	O
0	int
)	O
lmodetype	int
=	O
NO_AUTOKLUDGE	int
;	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
"telnetd: invalid argument to --linemode\n"	pointer
)	O
;	O
}	O
void	O
parse_authmode	function
(	O
char	O
*	O
str	pointer
)	O
{	O
if	O
(	O
strcasecmp	function
(	O
str	pointer
,	O
"none"	pointer
)	O
==	O
0	int
)	O
auth_level	int
=	O
0	int
;	O
else	O
if	O
(	O
strcasecmp	function
(	O
str	pointer
,	O
"other"	pointer
)	O
==	O
0	int
)	O
auth_level	int
=	O
AUTH_OTHER	int
;	O
else	O
if	O
(	O
strcasecmp	function
(	O
str	pointer
,	O
"user"	pointer
)	O
==	O
0	int
)	O
auth_level	int
=	O
AUTH_USER	int
;	O
else	O
if	O
(	O
strcasecmp	function
(	O
str	pointer
,	O
"valid"	pointer
)	O
==	O
0	int
)	O
auth_level	int
=	O
AUTH_VALID	int
;	O
else	O
if	O
(	O
strcasecmp	function
(	O
str	pointer
,	O
"off"	pointer
)	O
==	O
0	int
)	O
auth_level	int
=	O
-	O
1	int
;	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
"telnetd: unknown authorization level for -a\n"	pointer
)	O
;	O
}	O
static	O
struct	O
{	O
char	O
*	O
name	pointer
;	O
int	O
modnum	int
;	O
}	O
debug_mode	enum
[	O
debug_max_mode	int
]	O
=	O
{	O
{	O
"options"	pointer
,	O
debug_options	int
}	O
,	O
{	O
"report"	pointer
,	O
debug_report	int
}	O
,	O
{	O
"netdata"	pointer
,	O
debug_net_data	int
}	O
,	O
{	O
"ptydata"	pointer
,	O
debug_pty_data	int
}	O
,	O
{	O
"auth"	pointer
,	O
debug_auth	int
}	O
,	O
}	O
;	O
void	O
parse_debug_level	function
(	O
char	O
*	O
str	pointer
)	O
{	O
int	O
i	int
;	O
char	O
*	O
tok	pointer
;	O
if	O
(	O
!	O
str	pointer
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
debug_max_mode	int
;	O
i	int
++	O
)	O
debug_level	array
[	O
debug_mode	enum
[	O
i	int
]	O
.	O
modnum	int
]	O
=	O
MAX_DEBUG_LEVEL	int
;	O
return	O
;	O
}	O
for	O
(	O
tok	pointer
=	O
strtok	function
(	O
str	pointer
,	O
","	pointer
)	O
;	O
tok	pointer
;	O
tok	pointer
=	O
strtok	function
(	O
NULL	O
,	O
","	pointer
)	O
)	O
{	O
int	O
length	int
,	O
level	int
;	O
char	O
*	O
p	pointer
;	O
if	O
(	O
strcmp	function
(	O
tok	pointer
,	O
"tcp"	pointer
)	O
==	O
0	int
)	O
{	O
debug_tcp	int
=	O
1	int
;	O
continue	O
;	O
}	O
p	pointer
=	O
strchr	function
(	O
tok	pointer
,	O
'='	O
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
length	int
=	O
p	pointer
-	O
tok	pointer
;	O
level	int
=	O
strtoul	function
(	O
p	pointer
+	O
1	int
,	O
NULL	O
,	O
0	int
)	O
;	O
}	O
else	O
{	O
length	int
=	O
strlen	function
(	O
tok	pointer
)	O
;	O
level	int
=	O
MAX_DEBUG_LEVEL	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
debug_max_mode	int
;	O
i	int
++	O
)	O
if	O
(	O
strncmp	function
(	O
debug_mode	enum
[	O
i	int
]	O
.	O
name	pointer
,	O
tok	pointer
,	O
length	int
)	O
==	O
0	int
)	O
{	O
debug_level	array
[	O
debug_mode	enum
[	O
i	int
]	O
.	O
modnum	int
]	O
=	O
level	int
;	O
break	O
;	O
}	O
if	O
(	O
i	int
==	O
debug_max_mode	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"telnetd: unknown debug mode: %s"	pointer
,	O
tok	pointer
)	O
;	O
}	O
}	O
typedef	O
unsigned	O
int	O
ip_addr_t	int
;	O
void	O
telnetd_setup	function
(	O
int	O
fd	int
)	O
{	O
struct	O
sockaddr_storage	struct
saddr	struct
;	O
char	O
buf	pointer
[	O
256	int
]	O
,	O
buf2	array
[	O
256	int
]	O
;	O
int	O
err	long
;	O
int	O
true	int
=	O
1	int
;	O
socklen_t	int
len	long
;	O
char	O
uname	function
[	O
256	int
]	O
;	O
int	O
level	int
;	O
len	long
=	O
sizeof	O
(	O
saddr	struct
)	O
;	O
if	O
(	O
getpeername	function
(	O
fd	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
saddr	struct
,	O
&	O
len	long
)	O
<	O
0	int
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"getpeername: %m"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
err	long
=	O
getnameinfo	function
(	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
saddr	struct
,	O
len	long
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
NULL	O
,	O
0	int
,	O
NI_NUMERICHOST	int
)	O
;	O
if	O
(	O
err	long
)	O
{	O
const	O
char	O
*	O
errmsg	pointer
;	O
if	O
(	O
err	long
==	O
EAI_SYSTEM	O
)	O
errmsg	pointer
=	O
strerror	function
(	O
errno	O
)	O
;	O
else	O
errmsg	pointer
=	O
gai_strerror	function
(	O
err	long
)	O
;	O
syslog	function
(	O
LOG_AUTH	O
|	O
LOG_NOTICE	int
,	O
"Cannot get address: %s"	pointer
,	O
errmsg	pointer
)	O
;	O
fatal	function
(	O
fd	int
,	O
"Cannot get address."	pointer
)	O
;	O
}	O
err	long
=	O
getnameinfo	function
(	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
saddr	struct
,	O
len	long
,	O
buf2	array
,	O
sizeof	O
(	O
buf2	array
)	O
,	O
NULL	O
,	O
0	int
,	O
NI_NAMEREQD	int
)	O
;	O
if	O
(	O
reverse_lookup	int
)	O
{	O
struct	O
addrinfo	struct
*	O
result	pointer
,	O
*	O
aip	pointer
;	O
if	O
(	O
err	long
)	O
{	O
const	O
char	O
*	O
errmsg	pointer
;	O
if	O
(	O
err	long
==	O
EAI_SYSTEM	O
)	O
errmsg	pointer
=	O
strerror	function
(	O
errno	O
)	O
;	O
else	O
errmsg	pointer
=	O
gai_strerror	function
(	O
err	long
)	O
;	O
syslog	function
(	O
LOG_AUTH	O
|	O
LOG_NOTICE	int
,	O
"Can't resolve %s: %s"	pointer
,	O
buf	pointer
,	O
errmsg	pointer
)	O
;	O
fatal	function
(	O
fd	int
,	O
"Cannot resolve address."	pointer
)	O
;	O
}	O
remote_hostname	pointer
=	O
xstrdup	function
(	O
buf2	array
)	O
;	O
err	long
=	O
getaddrinfo	function
(	O
remote_hostname	pointer
,	O
NULL	O
,	O
NULL	O
,	O
&	O
result	pointer
)	O
;	O
if	O
(	O
err	long
)	O
{	O
const	O
char	O
*	O
errmsg	pointer
;	O
if	O
(	O
err	long
==	O
EAI_SYSTEM	O
)	O
errmsg	pointer
=	O
strerror	function
(	O
errno	O
)	O
;	O
else	O
errmsg	pointer
=	O
gai_strerror	function
(	O
err	long
)	O
;	O
syslog	function
(	O
LOG_AUTH	O
|	O
LOG_NOTICE	int
,	O
"Forward resolve of %s failed: %s"	pointer
,	O
remote_hostname	pointer
,	O
errmsg	pointer
)	O
;	O
fatal	function
(	O
fd	int
,	O
"Cannot resolve address."	pointer
)	O
;	O
}	O
for	O
(	O
aip	pointer
=	O
result	pointer
;	O
aip	pointer
;	O
aip	pointer
=	O
aip	pointer
->	O
ai_next	pointer
)	O
if	O
(	O
!	O
memcmp	function
(	O
aip	pointer
->	O
ai_addr	pointer
,	O
&	O
saddr	struct
,	O
aip	pointer
->	O
ai_addrlen	int
)	O
)	O
break	O
;	O
if	O
(	O
aip	pointer
==	O
NULL	O
)	O
{	O
syslog	function
(	O
LOG_AUTH	O
|	O
LOG_NOTICE	int
,	O
"None of addresses of %s matched %s"	pointer
,	O
remote_hostname	pointer
,	O
buf	pointer
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
freeaddrinfo	function
(	O
result	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
err	long
)	O
remote_hostname	pointer
=	O
xstrdup	function
(	O
buf2	array
)	O
;	O
else	O
remote_hostname	pointer
=	O
xstrdup	function
(	O
buf	pointer
)	O
;	O
}	O
if	O
(	O
keepalive	int
&&	O
setsockopt	function
(	O
fd	int
,	O
SOL_SOCKET	int
,	O
SO_KEEPALIVE	int
,	O
(	O
char	O
*	O
)	O
&	O
true	int
,	O
sizeof	O
(	O
true	int
)	O
)	O
<	O
0	int
)	O
syslog	function
(	O
LOG_WARNING	int
,	O
"setsockopt (SO_KEEPALIVE): %m"	pointer
)	O
;	O
if	O
(	O
debug_tcp	int
&&	O
setsockopt	function
(	O
fd	int
,	O
SOL_SOCKET	int
,	O
SO_DEBUG	int
,	O
(	O
char	O
*	O
)	O
&	O
true	int
,	O
sizeof	O
(	O
true	int
)	O
)	O
<	O
0	int
)	O
syslog	function
(	O
LOG_WARNING	int
,	O
"setsockopt (SO_DEBUG): %m"	pointer
)	O
;	O
net	int
=	O
fd	int
;	O
local_hostname	pointer
=	O
localhost	function
(	O
)	O
;	O
io_setup	function
(	O
)	O
;	O
uname	function
[	O
0	int
]	O
=	O
0	int
;	O
level	int
=	O
getterminaltype	function
(	O
uname	function
)	O
;	O
setenv	function
(	O
"TERM"	pointer
,	O
terminaltype	pointer
?	O
terminaltype	pointer
:	O
"network"	pointer
,	O
1	int
)	O
;	O
if	O
(	O
uname	function
[	O
0	int
]	O
)	O
user_name	pointer
=	O
xstrdup	function
(	O
uname	function
)	O
;	O
pty	int
=	O
startslave	function
(	O
remote_hostname	pointer
,	O
level	int
,	O
user_name	pointer
)	O
;	O
ioctl	function
(	O
pty	int
,	O
TIOCPKT	int
,	O
(	O
char	O
*	O
)	O
&	O
true	int
)	O
;	O
ioctl	function
(	O
pty	int
,	O
FIONBIO	int
,	O
(	O
char	O
*	O
)	O
&	O
true	int
)	O
;	O
ioctl	function
(	O
net	int
,	O
FIONBIO	int
,	O
(	O
char	O
*	O
)	O
&	O
true	int
)	O
;	O
setsockopt	function
(	O
net	int
,	O
SOL_SOCKET	int
,	O
SO_OOBINLINE	int
,	O
(	O
char	O
*	O
)	O
&	O
true	int
,	O
sizeof	O
true	int
)	O
;	O
signal	function
(	O
SIGTSTP	int
,	O
SIG_IGN	O
)	O
;	O
signal	function
(	O
SIGTTOU	int
,	O
SIG_IGN	O
)	O
;	O
signal	function
(	O
SIGCHLD	int
,	O
cleanup	pointer
)	O
;	O
}	O
int	O
telnetd_run	function
(	O
void	O
)	O
{	O
int	O
nfd	int
;	O
get_slc_defaults	function
(	O
)	O
;	O
if	O
(	O
my_state_is_wont	O
(	O
TELOPT_SGA	int
)	O
)	O
send_will	function
(	O
TELOPT_SGA	int
,	O
1	int
)	O
;	O
send_do	function
(	O
TELOPT_ECHO	int
,	O
1	int
)	O
;	O
if	O
(	O
his_state_is_wont	O
(	O
TELOPT_LINEMODE	int
)	O
)	O
{	O
linemode	int
=	O
0	int
;	O
editmode	int
=	O
0	int
;	O
send_do	function
(	O
TELOPT_LINEMODE	int
,	O
1	int
)	O
;	O
}	O
send_do	function
(	O
TELOPT_NAWS	int
,	O
1	int
)	O
;	O
send_will	function
(	O
TELOPT_STATUS	int
,	O
1	int
)	O
;	O
flowmode	int
=	O
1	int
;	O
restartany	int
=	O
-	O
1	int
;	O
send_do	function
(	O
TELOPT_LFLOW	int
,	O
1	int
)	O
;	O
ttloop	O
(	O
his_will_wont_is_changing	O
(	O
TELOPT_NAWS	int
)	O
)	O
;	O
if	O
(	O
his_want_state_is_will	O
(	O
TELOPT_ECHO	int
)	O
&&	O
his_state_is_will	O
(	O
TELOPT_NAWS	int
)	O
)	O
ttloop	O
(	O
his_will_wont_is_changing	O
(	O
TELOPT_ECHO	int
)	O
)	O
;	O
if	O
(	O
his_want_state_is_will	O
(	O
TELOPT_ECHO	int
)	O
)	O
{	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
debug_output_data	function
(	O
"td: simulating recv\r\n"	pointer
)	O
)	O
;	O
willoption	function
(	O
TELOPT_ECHO	int
)	O
;	O
}	O
if	O
(	O
my_state_is_wont	O
(	O
TELOPT_ECHO	int
)	O
)	O
send_will	function
(	O
TELOPT_ECHO	int
,	O
1	int
)	O
;	O
if	O
(	O
lmodetype	int
<	O
REAL_LINEMODE	int
)	O
send_do	function
(	O
TELOPT_TM	int
,	O
1	int
)	O
;	O
telrcv	function
(	O
)	O
;	O
if	O
(	O
hostinfo	int
)	O
print_hostinfo	function
(	O
)	O
;	O
init_termbuf	function
(	O
)	O
;	O
localstat	function
(	O
)	O
;	O
DEBUG	O
(	O
debug_report	int
,	O
1	int
,	O
debug_output_data	function
(	O
"td: Entering processing loop\r\n"	pointer
)	O
)	O
;	O
nfd	int
=	O
(	O
(	O
net	int
>	O
pty	int
)	O
?	O
net	int
:	O
pty	int
)	O
+	O
1	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
fd_set	struct
ibits	struct
,	O
obits	struct
,	O
xbits	struct
;	O
register	O
int	O
c	int
;	O
if	O
(	O
net_input_level	function
(	O
)	O
<	O
0	int
&&	O
pty_input_level	function
(	O
)	O
<	O
0	int
)	O
break	O
;	O
FD_ZERO	O
(	O
&	O
ibits	struct
)	O
;	O
FD_ZERO	O
(	O
&	O
obits	struct
)	O
;	O
FD_ZERO	O
(	O
&	O
xbits	struct
)	O
;	O
if	O
(	O
net_output_level	function
(	O
)	O
||	O
pty_input_level	function
(	O
)	O
>	O
0	int
)	O
FD_SET	O
(	O
net	int
,	O
&	O
obits	struct
)	O
;	O
else	O
FD_SET	O
(	O
pty	int
,	O
&	O
ibits	struct
)	O
;	O
if	O
(	O
pty_output_level	function
(	O
)	O
||	O
net_input_level	function
(	O
)	O
>	O
0	int
)	O
FD_SET	O
(	O
pty	int
,	O
&	O
obits	struct
)	O
;	O
else	O
FD_SET	O
(	O
net	int
,	O
&	O
ibits	struct
)	O
;	O
if	O
(	O
!	O
SYNCHing	int
)	O
FD_SET	O
(	O
net	int
,	O
&	O
xbits	struct
)	O
;	O
if	O
(	O
(	O
c	int
=	O
select	function
(	O
nfd	int
,	O
&	O
ibits	struct
,	O
&	O
obits	struct
,	O
&	O
xbits	struct
,	O
NULL	O
)	O
)	O
<=	O
0	int
)	O
{	O
if	O
(	O
c	int
==	O
-	O
1	int
&&	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
sleep	function
(	O
5	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
FD_ISSET	O
(	O
net	int
,	O
&	O
xbits	struct
)	O
)	O
SYNCHing	int
=	O
1	int
;	O
if	O
(	O
FD_ISSET	O
(	O
net	int
,	O
&	O
ibits	struct
)	O
)	O
{	O
net_read	function
(	O
)	O
;	O
}	O
if	O
(	O
FD_ISSET	O
(	O
pty	int
,	O
&	O
ibits	struct
)	O
)	O
{	O
if	O
(	O
pty_read	function
(	O
)	O
<	O
0	int
)	O
break	O
;	O
c	int
=	O
pty_get_char	function
(	O
1	int
)	O
;	O
if	O
(	O
c	int
&	O
TIOCPKT_IOCTL	int
)	O
{	O
pty_get_char	function
(	O
0	int
)	O
;	O
copy_termbuf	function
(	O
)	O
;	O
localstat	function
(	O
)	O
;	O
}	O
if	O
(	O
c	int
&	O
TIOCPKT_FLUSHWRITE	int
)	O
{	O
static	O
char	O
flushdata	array
[	O
]	O
=	O
{	O
IAC	int
,	O
DM	int
}	O
;	O
pty_get_char	function
(	O
0	int
)	O
;	O
netclear	function
(	O
)	O
;	O
net_output_datalen	function
(	O
flushdata	array
,	O
sizeof	O
(	O
flushdata	array
)	O
)	O
;	O
set_neturg	function
(	O
)	O
;	O
DEBUG	O
(	O
debug_options	int
,	O
1	int
,	O
printoption	function
(	O
"td: send IAC"	pointer
,	O
DM	int
)	O
)	O
;	O
}	O
if	O
(	O
his_state_is_will	O
(	O
TELOPT_LFLOW	int
)	O
&&	O
(	O
c	int
&	O
(	O
TIOCPKT_NOSTOP	int
|	O
TIOCPKT_DOSTOP	int
)	O
)	O
)	O
{	O
int	O
newflow	int
=	O
c	int
&	O
TIOCPKT_DOSTOP	int
?	O
1	int
:	O
0	int
;	O
if	O
(	O
newflow	int
!=	O
flowmode	int
)	O
{	O
net_output_data	function
(	O
"%c%c%c%c%c%c"	pointer
,	O
IAC	int
,	O
SB	int
,	O
TELOPT_LFLOW	int
,	O
flowmode	int
?	O
LFLOW_ON	int
:	O
LFLOW_OFF	int
,	O
IAC	int
,	O
SE	int
)	O
;	O
}	O
pty_get_char	function
(	O
0	int
)	O
;	O
}	O
}	O
while	O
(	O
pty_input_level	function
(	O
)	O
>	O
0	int
)	O
{	O
if	O
(	O
net_buffer_is_full	function
(	O
)	O
)	O
break	O
;	O
c	int
=	O
pty_get_char	function
(	O
0	int
)	O
;	O
if	O
(	O
c	int
==	O
IAC	int
)	O
net_output_byte	function
(	O
c	int
)	O
;	O
net_output_byte	function
(	O
c	int
)	O
;	O
if	O
(	O
c	int
==	O
'\r'	O
&&	O
my_state_is_wont	O
(	O
TELOPT_BINARY	int
)	O
)	O
{	O
if	O
(	O
pty_input_level	function
(	O
)	O
>	O
0	int
&&	O
pty_get_char	function
(	O
1	int
)	O
==	O
'\n'	O
)	O
net_output_byte	function
(	O
pty_get_char	function
(	O
0	int
)	O
)	O
;	O
else	O
net_output_byte	function
(	O
0	int
)	O
;	O
}	O
}	O
if	O
(	O
FD_ISSET	O
(	O
net	int
,	O
&	O
obits	struct
)	O
&&	O
net_output_level	function
(	O
)	O
>	O
0	int
)	O
netflush	function
(	O
)	O
;	O
if	O
(	O
net_input_level	function
(	O
)	O
>	O
0	int
)	O
telrcv	function
(	O
)	O
;	O
if	O
(	O
FD_ISSET	O
(	O
pty	int
,	O
&	O
obits	struct
)	O
&&	O
pty_output_level	function
(	O
)	O
>	O
0	int
)	O
ptyflush	function
(	O
)	O
;	O
}	O
cleanup	pointer
(	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
void	O
print_hostinfo	function
(	O
void	O
)	O
{	O
char	O
*	O
im	pointer
=	O
NULL	O
;	O
char	O
*	O
str	pointer
;	O
struct	O
utsname	struct
u	struct
;	O
if	O
(	O
uname	function
(	O
&	O
u	struct
)	O
==	O
0	int
)	O
{	O
im	pointer
=	O
malloc	function
(	O
strlen	function
(	O
UNAME_IM_PREFIX	pointer
)	O
+	O
strlen	function
(	O
u	struct
.	O
sysname	array
)	O
+	O
1	int
+	O
strlen	function
(	O
u	struct
.	O
release	array
)	O
+	O
strlen	function
(	O
UNAME_IM_SUFFIX	pointer
)	O
+	O
1	int
)	O
;	O
if	O
(	O
im	pointer
)	O
sprintf	function
(	O
im	pointer
,	O
"%s%s %s%s"	pointer
,	O
UNAME_IM_PREFIX	pointer
,	O
u	struct
.	O
sysname	array
,	O
u	struct
.	O
release	array
,	O
UNAME_IM_SUFFIX	pointer
)	O
;	O
}	O
if	O
(	O
!	O
im	pointer
)	O
im	pointer
=	O
xstrdup	function
(	O
"\r\n\nUNIX (%l) (%t)\r\n\n"	pointer
)	O
;	O
str	pointer
=	O
expand_line	function
(	O
im	pointer
)	O
;	O
free	function
(	O
im	pointer
)	O
;	O
DEBUG	O
(	O
debug_pty_data	int
,	O
1	int
,	O
debug_output_data	function
(	O
"sending %s"	pointer
,	O
str	pointer
)	O
)	O
;	O
pty_input_putback	function
(	O
str	pointer
,	O
strlen	function
(	O
str	pointer
)	O
)	O
;	O
free	function
(	O
str	pointer
)	O
;	O
}	O
