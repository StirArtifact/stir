grad_request_t	struct
*	O
grad_request_alloc	function
(	O
)	O
{	O
return	O
grad_emalloc	function
(	O
sizeof	O
(	O
grad_request_t	struct
)	O
)	O
;	O
}	O
void	O
grad_request_free	function
(	O
grad_request_t	struct
*	O
radreq	pointer
)	O
{	O
grad_avl_free	function
(	O
radreq	pointer
->	O
avlist	pointer
)	O
;	O
grad_free	function
(	O
radreq	pointer
)	O
;	O
}	O
static	O
char	O
*	O
months	array
[	O
]	O
=	O
{	O
"Jan"	pointer
,	O
"Feb"	pointer
,	O
"Mar"	pointer
,	O
"Apr"	pointer
,	O
"May"	pointer
,	O
"Jun"	pointer
,	O
"Jul"	pointer
,	O
"Aug"	pointer
,	O
"Sep"	pointer
,	O
"Oct"	pointer
,	O
"Nov"	pointer
,	O
"Dec"	pointer
}	O
;	O
int	O
grad_parse_time_string	function
(	O
char	O
*	O
valstr	pointer
,	O
struct	O
tm	struct
*	O
tm	struct
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
12	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
grad_c_strncasecmp	function
(	O
months	array
[	O
i	int
]	O
,	O
valstr	pointer
,	O
3	int
)	O
==	O
0	int
)	O
{	O
tm	struct
->	O
tm_mon	int
=	O
i	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
i	int
==	O
12	int
)	O
return	O
-	O
1	int
;	O
valstr	pointer
+=	O
3	int
;	O
while	O
(	O
*	O
valstr	pointer
&&	O
isspace	function
(	O
*	O
valstr	pointer
)	O
)	O
valstr	pointer
++	O
;	O
if	O
(	O
!	O
*	O
valstr	pointer
)	O
return	O
-	O
1	int
;	O
tm	struct
->	O
tm_mday	int
=	O
strtol	function
(	O
valstr	pointer
,	O
&	O
valstr	pointer
,	O
10	int
)	O
;	O
while	O
(	O
*	O
valstr	pointer
&&	O
isspace	function
(	O
*	O
valstr	pointer
)	O
)	O
valstr	pointer
++	O
;	O
if	O
(	O
!	O
*	O
valstr	pointer
)	O
return	O
-	O
1	int
;	O
tm	struct
->	O
tm_year	int
=	O
strtol	function
(	O
valstr	pointer
,	O
&	O
valstr	pointer
,	O
10	int
)	O
-	O
1900	int
;	O
return	O
0	int
;	O
}	O
void	O
grad_lock_file	function
(	O
int	O
fd	int
,	O
size_t	long
size	int
,	O
off_t	long
offset	long
,	O
int	O
whence	int
)	O
{	O
struct	O
flock	struct
fl	struct
;	O
fl	struct
.	O
l_type	short
=	O
F_WRLCK	int
;	O
fl	struct
.	O
l_whence	short
=	O
whence	int
;	O
fl	struct
.	O
l_start	long
=	O
offset	long
;	O
fl	struct
.	O
l_len	long
=	O
size	int
;	O
fcntl	function
(	O
fd	int
,	O
F_SETLKW	int
,	O
&	O
fl	struct
)	O
;	O
}	O
void	O
grad_unlock_file	function
(	O
int	O
fd	int
,	O
size_t	long
size	int
,	O
off_t	long
offset	long
,	O
int	O
whence	int
)	O
{	O
struct	O
flock	struct
fl	struct
;	O
fl	struct
.	O
l_type	short
=	O
F_UNLCK	int
;	O
fl	struct
.	O
l_whence	short
=	O
whence	int
;	O
fl	struct
.	O
l_start	long
=	O
offset	long
;	O
fl	struct
.	O
l_len	long
=	O
size	int
;	O
fcntl	function
(	O
fd	int
,	O
F_SETLKW	int
,	O
&	O
fl	struct
)	O
;	O
}	O
int	O
grad_xlat_keyword	function
(	O
grad_keyword_t	struct
*	O
kw	pointer
,	O
const	O
char	O
*	O
str	pointer
,	O
int	O
def	int
)	O
{	O
for	O
(	O
;	O
kw	pointer
->	O
name	pointer
;	O
kw	pointer
++	O
)	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
kw	pointer
->	O
name	pointer
)	O
==	O
0	int
)	O
return	O
kw	pointer
->	O
tok	int
;	O
return	O
def	int
;	O
}	O
char	O
*	O
grad_mkfilename	function
(	O
char	O
*	O
dir	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
int	O
len	int
=	O
strlen	function
(	O
dir	pointer
)	O
+	O
strlen	function
(	O
name	pointer
)	O
;	O
char	O
*	O
p	pointer
=	O
grad_emalloc	function
(	O
len	int
+	O
2	int
)	O
;	O
sprintf	function
(	O
p	pointer
,	O
"%s/%s"	pointer
,	O
dir	pointer
,	O
name	pointer
)	O
;	O
return	O
p	pointer
;	O
}	O
char	O
*	O
grad_mkfilename3	function
(	O
char	O
*	O
dir	pointer
,	O
char	O
*	O
subdir	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
int	O
len	int
=	O
strlen	function
(	O
dir	pointer
)	O
+	O
strlen	function
(	O
subdir	pointer
)	O
+	O
strlen	function
(	O
name	pointer
)	O
;	O
char	O
*	O
p	pointer
=	O
grad_emalloc	function
(	O
len	int
+	O
3	int
)	O
;	O
sprintf	function
(	O
p	pointer
,	O
"%s/%s/%s"	pointer
,	O
dir	pointer
,	O
subdir	pointer
,	O
name	pointer
)	O
;	O
return	O
p	pointer
;	O
}	O
int	O
grad_astrcat	function
(	O
char	O
*	O
*	O
pptr	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
size_t	long
size	int
=	O
0	int
;	O
char	O
*	O
s	pointer
,	O
*	O
p	pointer
;	O
va_start	O
(	O
ap	array
,	O
pptr	pointer
)	O
;	O
while	O
(	O
(	O
s	pointer
=	O
va_arg	O
(	O
ap	array
,	O
char	O
*	O
)	O
)	O
)	O
size	int
+=	O
strlen	function
(	O
s	pointer
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
size	int
++	O
;	O
p	pointer
=	O
malloc	function
(	O
size	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
1	int
;	O
*	O
p	pointer
=	O
0	int
;	O
va_start	O
(	O
ap	array
,	O
pptr	pointer
)	O
;	O
while	O
(	O
(	O
s	pointer
=	O
va_arg	O
(	O
ap	array
,	O
char	O
*	O
)	O
)	O
)	O
strcat	function
(	O
p	pointer
,	O
s	pointer
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
*	O
pptr	pointer
=	O
p	pointer
;	O
return	O
0	int
;	O
}	O
int	O
grad_decode_backslash	function
(	O
int	O
c	pointer
)	O
{	O
static	O
char	O
transtab	array
[	O
]	O
=	O
"a\ab\bf\fn\nr\rt\t"	pointer
;	O
char	O
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
transtab	array
;	O
*	O
p	pointer
;	O
p	pointer
+=	O
2	int
)	O
{	O
if	O
(	O
*	O
p	pointer
==	O
c	pointer
)	O
return	O
p	pointer
[	O
1	int
]	O
;	O
}	O
return	O
c	pointer
;	O
}	O
void	O
grad_string_copy	function
(	O
char	O
*	O
d	pointer
,	O
char	O
*	O
s	pointer
,	O
int	O
len	int
)	O
{	O
int	O
slen	int
=	O
strlen	function
(	O
s	pointer
)	O
;	O
if	O
(	O
slen	int
>	O
len	int
)	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"string too long: %s"	pointer
)	O
,	O
s	pointer
)	O
;	O
strncpy	function
(	O
d	pointer
,	O
s	pointer
,	O
len	int
)	O
;	O
d	pointer
[	O
len	int
]	O
=	O
0	int
;	O
}	O
char	O
*	O
grad_op_to_str	function
(	O
enum	O
grad_operator	enum
op	enum
)	O
{	O
switch	O
(	O
op	enum
)	O
{	O
case	O
grad_operator_equal	int
:	O
return	O
"="	pointer
;	O
case	O
grad_operator_not_equal	int
:	O
return	O
"!="	pointer
;	O
case	O
grad_operator_less_than	int
:	O
return	O
"<"	pointer
;	O
case	O
grad_operator_greater_than	int
:	O
return	O
">"	pointer
;	O
case	O
grad_operator_less_equal	int
:	O
return	O
"<="	pointer
;	O
case	O
grad_operator_greater_equal	int
:	O
return	O
">="	pointer
;	O
default	O
:	O
break	O
;	O
}	O
return	O
"?"	pointer
;	O
}	O
enum	O
grad_operator	enum
grad_str_to_op	function
(	O
char	O
*	O
str	pointer
)	O
{	O
int	O
op	enum
=	O
grad_operator_invalid	int
;	O
switch	O
(	O
*	O
str	pointer
++	O
)	O
{	O
case	O
'='	O
:	O
op	enum
=	O
grad_operator_equal	int
;	O
break	O
;	O
case	O
'!'	O
:	O
if	O
(	O
*	O
str	pointer
++	O
==	O
'='	O
)	O
op	enum
=	O
grad_operator_not_equal	int
;	O
break	O
;	O
case	O
'<'	O
:	O
if	O
(	O
*	O
str	pointer
==	O
0	int
)	O
op	enum
=	O
grad_operator_less_than	int
;	O
else	O
if	O
(	O
*	O
str	pointer
++	O
==	O
'='	O
)	O
op	enum
=	O
grad_operator_less_equal	int
;	O
break	O
;	O
case	O
'>'	O
:	O
if	O
(	O
*	O
str	pointer
==	O
0	int
)	O
op	enum
=	O
grad_operator_greater_than	int
;	O
else	O
if	O
(	O
*	O
str	pointer
++	O
==	O
'='	O
)	O
op	enum
=	O
grad_operator_greater_equal	int
;	O
break	O
;	O
}	O
if	O
(	O
*	O
str	pointer
)	O
op	enum
=	O
grad_operator_invalid	int
;	O
return	O
op	enum
;	O
}	O
static	O
int	O
flush_seg	function
(	O
char	O
*	O
*	O
bufp	pointer
,	O
char	O
*	O
seg	pointer
,	O
char	O
*	O
ptr	pointer
,	O
int	O
runlen	int
)	O
{	O
int	O
outbytes	int
=	O
0	int
;	O
char	O
*	O
buf	pointer
=	O
*	O
bufp	pointer
;	O
if	O
(	O
ptr	pointer
-	O
seg	pointer
>=	O
runlen	int
)	O
{	O
outbytes	int
+=	O
ptr	pointer
-	O
seg	pointer
;	O
if	O
(	O
buf	pointer
)	O
while	O
(	O
seg	pointer
<	O
ptr	pointer
)	O
*	O
buf	pointer
++	O
=	O
*	O
seg	pointer
++	O
;	O
}	O
else	O
{	O
outbytes	int
+=	O
4	int
*	O
(	O
ptr	pointer
-	O
seg	pointer
)	O
;	O
if	O
(	O
buf	pointer
)	O
while	O
(	O
seg	pointer
<	O
ptr	pointer
)	O
{	O
sprintf	function
(	O
buf	pointer
,	O
"\\%03o"	pointer
,	O
*	O
(	O
u_char	char
*	O
)	O
seg	pointer
)	O
;	O
seg	pointer
++	O
;	O
buf	pointer
+=	O
4	int
;	O
}	O
}	O
*	O
bufp	pointer
=	O
buf	pointer
;	O
return	O
outbytes	int
;	O
}	O
int	O
grad_format_string_visual	function
(	O
char	O
*	O
buf	pointer
,	O
int	O
runlen	int
,	O
char	O
*	O
str	pointer
,	O
int	O
len	int
)	O
{	O
char	O
*	O
seg	pointer
,	O
*	O
ptr	pointer
;	O
int	O
outbytes	int
=	O
0	int
;	O
seg	pointer
=	O
NULL	O
;	O
ptr	pointer
=	O
str	pointer
;	O
while	O
(	O
len	int
)	O
{	O
if	O
(	O
isprint	function
(	O
*	O
ptr	pointer
)	O
)	O
{	O
if	O
(	O
!	O
seg	pointer
)	O
seg	pointer
=	O
ptr	pointer
;	O
}	O
else	O
{	O
if	O
(	O
seg	pointer
)	O
{	O
outbytes	int
+=	O
flush_seg	function
(	O
&	O
buf	pointer
,	O
seg	pointer
,	O
ptr	pointer
,	O
runlen	int
)	O
;	O
seg	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
buf	pointer
)	O
{	O
sprintf	function
(	O
buf	pointer
,	O
"\\%03o"	pointer
,	O
*	O
(	O
u_char	char
*	O
)	O
ptr	pointer
)	O
;	O
buf	pointer
+=	O
4	int
;	O
}	O
outbytes	int
+=	O
4	int
;	O
}	O
len	int
--	O
;	O
ptr	pointer
++	O
;	O
}	O
if	O
(	O
seg	pointer
)	O
{	O
outbytes	int
+=	O
ptr	pointer
-	O
seg	pointer
;	O
if	O
(	O
buf	pointer
)	O
while	O
(	O
seg	pointer
<	O
ptr	pointer
)	O
*	O
buf	pointer
++	O
=	O
*	O
seg	pointer
++	O
;	O
}	O
if	O
(	O
buf	pointer
)	O
*	O
buf	pointer
++	O
=	O
0	int
;	O
return	O
outbytes	int
;	O
}	O
int	O
grad_format_vendor_pair	function
(	O
char	O
*	O
buf	pointer
,	O
grad_avp_t	struct
*	O
pair	pointer
)	O
{	O
int	O
n	long
;	O
grad_uint32_t	int
vendor	int
;	O
u_char	char
*	O
ptr	pointer
=	O
(	O
u_char	char
*	O
)	O
pair	pointer
->	O
avp_strvalue	O
;	O
char	O
buf1	array
[	O
64	int
]	O
;	O
char	O
*	O
bufp	pointer
=	O
buf	pointer
;	O
memcpy	function
(	O
&	O
vendor	int
,	O
ptr	pointer
,	O
4	int
)	O
;	O
ptr	pointer
+=	O
4	int
;	O
n	long
=	O
snprintf	function
(	O
buf1	array
,	O
sizeof	O
(	O
buf1	array
)	O
,	O
"V%d"	pointer
,	O
(	O
int	O
)	O
ntohl	function
(	O
vendor	int
)	O
)	O
;	O
if	O
(	O
n	long
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
bufp	pointer
)	O
{	O
memcpy	function
(	O
bufp	pointer
,	O
buf1	array
,	O
n	long
)	O
;	O
bufp	pointer
+=	O
n	long
;	O
}	O
return	O
n	long
+	O
grad_format_string_visual	function
(	O
bufp	pointer
,	O
4	int
,	O
ptr	pointer
,	O
pair	pointer
->	O
avp_strlength	O
-	O
4	int
)	O
;	O
}	O
char	O
*	O
grad_format_pair	function
(	O
grad_avp_t	struct
*	O
pair	pointer
,	O
int	O
typeflag	int
,	O
char	O
*	O
*	O
savep	pointer
)	O
{	O
char	O
*	O
buf1	array
=	O
NULL	O
;	O
char	O
*	O
buf2ptr	pointer
=	O
NULL	O
;	O
char	O
buf2	array
[	O
4	int
*	O
GRAD_STRING_LENGTH	int
+	O
1	int
]	O
;	O
grad_dict_value_t	struct
*	O
dval	pointer
;	O
struct	O
tm	struct
tm	struct
;	O
char	O
*	O
type	enum
=	O
""	pointer
;	O
*	O
savep	pointer
=	O
NULL	O
;	O
switch	O
(	O
pair	pointer
->	O
eval_type	enum
==	O
grad_eval_const	int
?	O
pair	pointer
->	O
type	enum
:	O
GRAD_TYPE_STRING	int
)	O
{	O
case	O
GRAD_TYPE_STRING	int
:	O
if	O
(	O
pair	pointer
->	O
attribute	int
!=	O
DA_VENDOR_SPECIFIC	int
)	O
{	O
int	O
len	int
=	O
strlen	function
(	O
pair	pointer
->	O
avp_strvalue	O
)	O
;	O
if	O
(	O
len	int
!=	O
pair	pointer
->	O
avp_strlength	O
-	O
1	int
)	O
len	int
=	O
pair	pointer
->	O
avp_strlength	O
;	O
grad_format_string_visual	function
(	O
buf2	array
,	O
4	int
,	O
pair	pointer
->	O
avp_strvalue	O
,	O
len	int
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
avp_strlength	O
<	O
6	int
)	O
snprintf	function
(	O
buf2	array
,	O
sizeof	O
(	O
buf2	array
)	O
,	O
"[invalid length: %d]"	pointer
,	O
pair	pointer
->	O
avp_strlength	O
)	O
;	O
else	O
{	O
int	O
len	int
=	O
grad_format_vendor_pair	function
(	O
NULL	O
,	O
pair	pointer
)	O
;	O
buf2ptr	pointer
=	O
malloc	function
(	O
len	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
buf2ptr	pointer
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
"%s:%d: can't alloc %d bytes"	pointer
,	O
__FILE__	O
,	O
__LINE__	O
,	O
len	int
+	O
1	int
)	O
;	O
buf2	array
[	O
0	int
]	O
=	O
0	int
;	O
}	O
else	O
grad_format_vendor_pair	function
(	O
buf2ptr	pointer
,	O
pair	pointer
)	O
;	O
}	O
break	O
;	O
case	O
GRAD_TYPE_INTEGER	int
:	O
if	O
(	O
pair	pointer
->	O
name	pointer
&&	O
(	O
pair	pointer
->	O
prop	int
&	O
GRAD_AP_TRANSLATE	int
)	O
)	O
dval	pointer
=	O
grad_value_lookup	function
(	O
pair	pointer
->	O
avp_lvalue	O
,	O
pair	pointer
->	O
name	pointer
)	O
;	O
else	O
dval	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
dval	pointer
)	O
snprintf	function
(	O
buf2	array
,	O
sizeof	O
(	O
buf2	array
)	O
,	O
"%lu"	pointer
,	O
pair	pointer
->	O
avp_lvalue	O
)	O
;	O
else	O
snprintf	function
(	O
buf2	array
,	O
sizeof	O
(	O
buf2	array
)	O
,	O
"%s"	pointer
,	O
dval	pointer
->	O
name	pointer
)	O
;	O
break	O
;	O
case	O
GRAD_TYPE_IPADDR	int
:	O
grad_ip_iptostr	function
(	O
pair	pointer
->	O
avp_lvalue	O
,	O
buf2	array
)	O
;	O
break	O
;	O
case	O
GRAD_TYPE_DATE	int
:	O
strftime	function
(	O
buf2	array
,	O
sizeof	O
(	O
buf2	array
)	O
,	O
"\"%b %e %Y\""	pointer
,	O
localtime_r	function
(	O
(	O
time_t	long
*	O
)	O
&	O
pair	pointer
->	O
avp_lvalue	O
,	O
&	O
tm	struct
)	O
)	O
;	O
break	O
;	O
default	O
:	O
strncpy	function
(	O
buf2	array
,	O
"[UNKNOWN DATATYPE]"	pointer
,	O
sizeof	O
(	O
buf2	array
)	O
)	O
;	O
}	O
if	O
(	O
typeflag	int
)	O
{	O
switch	O
(	O
pair	pointer
->	O
type	enum
)	O
{	O
case	O
GRAD_TYPE_STRING	int
:	O
type	enum
=	O
"(STRING) "	pointer
;	O
break	O
;	O
case	O
GRAD_TYPE_INTEGER	int
:	O
type	enum
=	O
"(INTEGER) "	pointer
;	O
break	O
;	O
case	O
GRAD_TYPE_IPADDR	int
:	O
type	enum
=	O
"(IPADDR) "	pointer
;	O
break	O
;	O
case	O
GRAD_TYPE_DATE	int
:	O
type	enum
=	O
"(DATE) "	pointer
;	O
break	O
;	O
}	O
}	O
if	O
(	O
pair	pointer
->	O
name	pointer
)	O
grad_astrcat	function
(	O
&	O
buf1	array
,	O
pair	pointer
->	O
name	pointer
,	O
" "	pointer
,	O
grad_op_to_str	function
(	O
pair	pointer
->	O
operator	enum
)	O
,	O
" "	pointer
,	O
type	enum
,	O
buf2ptr	pointer
?	O
buf2ptr	pointer
:	O
buf2	array
,	O
NULL	O
)	O
;	O
else	O
{	O
char	O
buf	pointer
[	O
INT_BUFSIZE_BOUND	O
(	O
int	O
)	O
]	O
;	O
grad_inttostr	function
(	O
pair	pointer
->	O
attribute	int
,	O
buf	pointer
,	O
sizeof	O
buf	pointer
)	O
;	O
grad_astrcat	function
(	O
&	O
buf1	array
,	O
buf	pointer
,	O
" "	pointer
,	O
grad_op_to_str	function
(	O
pair	pointer
->	O
operator	enum
)	O
,	O
" "	pointer
,	O
buf2ptr	pointer
?	O
buf2ptr	pointer
:	O
buf2	array
,	O
NULL	O
)	O
;	O
}	O
if	O
(	O
buf2ptr	pointer
)	O
free	function
(	O
buf2ptr	pointer
)	O
;	O
*	O
savep	pointer
=	O
buf1	array
;	O
return	O
buf1	array
;	O
}	O
int	O
grad_recompute_timeout	function
(	O
struct	O
timeval	struct
*	O
start	pointer
,	O
struct	O
timeval	struct
*	O
tval	pointer
)	O
{	O
struct	O
timeval	struct
now	struct
,	O
diff	struct
;	O
gettimeofday	function
(	O
&	O
now	struct
,	O
NULL	O
)	O
;	O
timersub	O
(	O
&	O
now	struct
,	O
start	pointer
,	O
&	O
diff	struct
)	O
;	O
if	O
(	O
timercmp	O
(	O
&	O
diff	struct
,	O
tval	pointer
,	O
<	O
)	O
)	O
{	O
struct	O
timeval	struct
tmp	struct
;	O
timersub	O
(	O
tval	pointer
,	O
&	O
diff	struct
,	O
&	O
tmp	struct
)	O
;	O
*	O
tval	pointer
=	O
tmp	struct
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
