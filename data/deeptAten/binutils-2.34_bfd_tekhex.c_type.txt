typedef	O
struct	O
{	O
bfd_vma	long
low	long
;	O
bfd_vma	long
high	long
;	O
}	O
addr_range_type	struct
;	O
typedef	O
struct	O
tekhex_symbol_struct	struct
{	O
asymbol	struct
symbol	pointer
;	O
struct	O
tekhex_symbol_struct	struct
*	O
prev	pointer
;	O
}	O
tekhex_symbol_type	struct
;	O
static	O
const	O
char	O
digs	array
[	O
]	O
=	O
"0123456789ABCDEF"	pointer
;	O
static	O
char	O
sum_block	array
[	O
256	int
]	O
;	O
static	O
void	O
tekhex_init	function
(	O
void	O
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
static	O
bfd_boolean	int
inited	int
=	O
FALSE	int
;	O
int	O
val	array
;	O
if	O
(	O
!	O
inited	int
)	O
{	O
inited	int
=	O
TRUE	int
;	O
hex_init	function
(	O
)	O
;	O
val	array
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
10	int
;	O
i	pointer
++	O
)	O
sum_block	array
[	O
i	pointer
+	O
'0'	O
]	O
=	O
val	array
++	O
;	O
for	O
(	O
i	pointer
=	O
'A'	O
;	O
i	pointer
<=	O
'Z'	O
;	O
i	pointer
++	O
)	O
sum_block	array
[	O
i	pointer
]	O
=	O
val	array
++	O
;	O
sum_block	array
[	O
'$'	O
]	O
=	O
val	array
++	O
;	O
sum_block	array
[	O
'%'	O
]	O
=	O
val	array
++	O
;	O
sum_block	array
[	O
'.'	O
]	O
=	O
val	array
++	O
;	O
sum_block	array
[	O
'_'	O
]	O
=	O
val	array
++	O
;	O
for	O
(	O
i	pointer
=	O
'a'	O
;	O
i	pointer
<=	O
'z'	O
;	O
i	pointer
++	O
)	O
sum_block	array
[	O
i	pointer
]	O
=	O
val	array
++	O
;	O
}	O
}	O
struct	O
tekhex_data_list_struct	struct
{	O
unsigned	O
char	O
*	O
data	pointer
;	O
bfd_vma	long
where	long
;	O
bfd_size_type	long
size	long
;	O
struct	O
tekhex_data_list_struct	struct
*	O
next	pointer
;	O
}	O
;	O
typedef	O
struct	O
tekhex_data_list_struct	struct
tekhex_data_list_type	struct
;	O
struct	O
data_struct	struct
{	O
unsigned	O
char	O
chunk_data	array
[	O
CHUNK_MASK	int
+	O
1	int
]	O
;	O
unsigned	O
char	O
chunk_init	array
[	O
(	O
CHUNK_MASK	int
+	O
1	int
+	O
CHUNK_SPAN	int
-	O
1	int
)	O
/	O
CHUNK_SPAN	int
]	O
;	O
bfd_vma	long
vma	long
;	O
struct	O
data_struct	struct
*	O
next	pointer
;	O
}	O
;	O
typedef	O
struct	O
tekhex_data_struct	struct
{	O
tekhex_data_list_type	struct
*	O
head	pointer
;	O
unsigned	O
int	O
type	enum
;	O
struct	O
tekhex_symbol_struct	struct
*	O
symbols	pointer
;	O
struct	O
data_struct	struct
*	O
data	pointer
;	O
}	O
tdata_type	struct
;	O
static	O
bfd_boolean	int
getvalue	function
(	O
char	O
*	O
*	O
srcp	pointer
,	O
bfd_vma	long
*	O
valuep	pointer
,	O
char	O
*	O
endp	pointer
)	O
{	O
char	O
*	O
src	pointer
=	O
*	O
srcp	pointer
;	O
bfd_vma	long
value	long
=	O
0	int
;	O
unsigned	O
int	O
len	long
;	O
if	O
(	O
src	pointer
>=	O
endp	pointer
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
ISHEX	O
(	O
*	O
src	pointer
)	O
)	O
return	O
FALSE	int
;	O
len	long
=	O
hex_value	O
(	O
*	O
src	pointer
++	O
)	O
;	O
if	O
(	O
len	long
==	O
0	int
)	O
len	long
=	O
16	int
;	O
while	O
(	O
len	long
--	O
&&	O
src	pointer
<	O
endp	pointer
)	O
{	O
if	O
(	O
!	O
ISHEX	O
(	O
*	O
src	pointer
)	O
)	O
return	O
FALSE	int
;	O
value	long
=	O
value	long
<<	O
4	int
|	O
hex_value	O
(	O
*	O
src	pointer
++	O
)	O
;	O
}	O
*	O
srcp	pointer
=	O
src	pointer
;	O
*	O
valuep	pointer
=	O
value	long
;	O
return	O
len	long
==	O
-	O
1U	int
;	O
}	O
static	O
bfd_boolean	int
getsym	function
(	O
char	O
*	O
dstp	pointer
,	O
char	O
*	O
*	O
srcp	pointer
,	O
unsigned	O
int	O
*	O
lenp	pointer
,	O
char	O
*	O
endp	pointer
)	O
{	O
char	O
*	O
src	pointer
=	O
*	O
srcp	pointer
;	O
unsigned	O
int	O
i	pointer
;	O
unsigned	O
int	O
len	long
;	O
if	O
(	O
!	O
ISHEX	O
(	O
*	O
src	pointer
)	O
)	O
return	O
FALSE	int
;	O
len	long
=	O
hex_value	O
(	O
*	O
src	pointer
++	O
)	O
;	O
if	O
(	O
len	long
==	O
0	int
)	O
len	long
=	O
16	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
len	long
&&	O
(	O
src	pointer
+	O
i	pointer
)	O
<	O
endp	pointer
;	O
i	pointer
++	O
)	O
dstp	pointer
[	O
i	pointer
]	O
=	O
src	pointer
[	O
i	pointer
]	O
;	O
dstp	pointer
[	O
i	pointer
]	O
=	O
0	int
;	O
*	O
srcp	pointer
=	O
src	pointer
+	O
i	pointer
;	O
*	O
lenp	pointer
=	O
len	long
;	O
return	O
i	pointer
==	O
len	long
;	O
}	O
static	O
struct	O
data_struct	struct
*	O
find_chunk	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
bfd_vma	long
vma	long
,	O
bfd_boolean	int
create	int
)	O
{	O
struct	O
data_struct	struct
*	O
d	pointer
=	O
abfd	pointer
->	O
tdata	union
.	O
tekhex_data	pointer
->	O
data	pointer
;	O
vma	long
&=	O
~	O
CHUNK_MASK	int
;	O
while	O
(	O
d	pointer
&&	O
(	O
d	pointer
->	O
vma	long
)	O
!=	O
vma	long
)	O
d	pointer
=	O
d	pointer
->	O
next	pointer
;	O
if	O
(	O
!	O
d	pointer
&&	O
create	int
)	O
{	O
d	pointer
=	O
(	O
struct	O
data_struct	struct
*	O
)	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
(	O
bfd_size_type	long
)	O
sizeof	O
(	O
struct	O
data_struct	struct
)	O
)	O
;	O
if	O
(	O
!	O
d	pointer
)	O
return	O
NULL	O
;	O
d	pointer
->	O
next	pointer
=	O
abfd	pointer
->	O
tdata	union
.	O
tekhex_data	pointer
->	O
data	pointer
;	O
d	pointer
->	O
vma	long
=	O
vma	long
;	O
abfd	pointer
->	O
tdata	union
.	O
tekhex_data	pointer
->	O
data	pointer
=	O
d	pointer
;	O
}	O
return	O
d	pointer
;	O
}	O
static	O
void	O
insert_byte	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
int	O
value	long
,	O
bfd_vma	long
addr	pointer
)	O
{	O
if	O
(	O
value	long
!=	O
0	int
)	O
{	O
struct	O
data_struct	struct
*	O
d	pointer
=	O
find_chunk	function
(	O
abfd	pointer
,	O
addr	pointer
,	O
TRUE	int
)	O
;	O
d	pointer
->	O
chunk_data	array
[	O
addr	pointer
&	O
CHUNK_MASK	int
]	O
=	O
value	long
;	O
d	pointer
->	O
chunk_init	array
[	O
(	O
addr	pointer
&	O
CHUNK_MASK	int
)	O
/	O
CHUNK_SPAN	int
]	O
=	O
1	int
;	O
}	O
}	O
static	O
bfd_boolean	int
first_phase	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
int	O
type	enum
,	O
char	O
*	O
src	pointer
,	O
char	O
*	O
src_end	pointer
)	O
{	O
asection	struct
*	O
section	pointer
,	O
*	O
alt_section	pointer
;	O
unsigned	O
int	O
len	long
;	O
bfd_vma	long
val	array
;	O
char	O
sym	pointer
[	O
17	int
]	O
;	O
switch	O
(	O
type	enum
)	O
{	O
case	O
'6'	O
:	O
{	O
bfd_vma	long
addr	pointer
;	O
if	O
(	O
!	O
getvalue	function
(	O
&	O
src	pointer
,	O
&	O
addr	pointer
,	O
src_end	pointer
)	O
)	O
return	O
FALSE	int
;	O
while	O
(	O
*	O
src	pointer
&&	O
src	pointer
<	O
src_end	pointer
-	O
1	int
)	O
{	O
insert_byte	function
(	O
abfd	pointer
,	O
HEX	O
(	O
src	pointer
)	O
,	O
addr	pointer
)	O
;	O
src	pointer
+=	O
2	int
;	O
addr	pointer
++	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
case	O
'3'	O
:	O
if	O
(	O
!	O
getsym	function
(	O
sym	pointer
,	O
&	O
src	pointer
,	O
&	O
len	long
,	O
src_end	pointer
)	O
)	O
return	O
FALSE	int
;	O
section	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
sym	pointer
)	O
;	O
if	O
(	O
section	pointer
==	O
NULL	O
)	O
{	O
char	O
*	O
n	long
=	O
(	O
char	O
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
(	O
bfd_size_type	long
)	O
len	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
n	long
)	O
return	O
FALSE	int
;	O
memcpy	function
(	O
n	long
,	O
sym	pointer
,	O
len	long
+	O
1	int
)	O
;	O
section	pointer
=	O
bfd_make_section	function
(	O
abfd	pointer
,	O
n	long
)	O
;	O
if	O
(	O
section	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
}	O
alt_section	pointer
=	O
NULL	O
;	O
while	O
(	O
src	pointer
<	O
src_end	pointer
&&	O
*	O
src	pointer
)	O
{	O
switch	O
(	O
*	O
src	pointer
)	O
{	O
case	O
'1'	O
:	O
src	pointer
++	O
;	O
if	O
(	O
!	O
getvalue	function
(	O
&	O
src	pointer
,	O
&	O
section	pointer
->	O
vma	long
,	O
src_end	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
getvalue	function
(	O
&	O
src	pointer
,	O
&	O
val	array
,	O
src_end	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
val	array
<	O
section	pointer
->	O
vma	long
)	O
val	array
=	O
section	pointer
->	O
vma	long
;	O
section	pointer
->	O
size	long
=	O
val	array
-	O
section	pointer
->	O
vma	long
;	O
if	O
(	O
section	pointer
->	O
size	long
&	O
0x80000000	int
)	O
return	O
FALSE	int
;	O
section	pointer
->	O
flags	int
=	O
SEC_HAS_CONTENTS	int
|	O
SEC_LOAD	int
|	O
SEC_ALLOC	int
;	O
break	O
;	O
case	O
'0'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
{	O
bfd_size_type	long
amt	long
=	O
sizeof	O
(	O
tekhex_symbol_type	struct
)	O
;	O
tekhex_symbol_type	struct
*	O
new_symbol	pointer
=	O
(	O
tekhex_symbol_type	struct
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
amt	long
)	O
;	O
char	O
stype	char
=	O
(	O
*	O
src	pointer
)	O
;	O
if	O
(	O
!	O
new_symbol	pointer
)	O
return	O
FALSE	int
;	O
new_symbol	pointer
->	O
symbol	pointer
.	O
the_bfd	pointer
=	O
abfd	pointer
;	O
src	pointer
++	O
;	O
abfd	pointer
->	O
symcount	int
++	O
;	O
abfd	pointer
->	O
flags	int
|=	O
HAS_SYMS	int
;	O
new_symbol	pointer
->	O
prev	pointer
=	O
abfd	pointer
->	O
tdata	union
.	O
tekhex_data	pointer
->	O
symbols	pointer
;	O
abfd	pointer
->	O
tdata	union
.	O
tekhex_data	pointer
->	O
symbols	pointer
=	O
new_symbol	pointer
;	O
if	O
(	O
!	O
getsym	function
(	O
sym	pointer
,	O
&	O
src	pointer
,	O
&	O
len	long
,	O
src_end	pointer
)	O
)	O
return	O
FALSE	int
;	O
new_symbol	pointer
->	O
symbol	pointer
.	O
name	pointer
=	O
(	O
const	O
char	O
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
(	O
bfd_size_type	long
)	O
len	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
new_symbol	pointer
->	O
symbol	pointer
.	O
name	pointer
)	O
return	O
FALSE	int
;	O
memcpy	function
(	O
(	O
char	O
*	O
)	O
(	O
new_symbol	pointer
->	O
symbol	pointer
.	O
name	pointer
)	O
,	O
sym	pointer
,	O
len	long
+	O
1	int
)	O
;	O
new_symbol	pointer
->	O
symbol	pointer
.	O
section	pointer
=	O
section	pointer
;	O
if	O
(	O
stype	char
<=	O
'4'	O
)	O
new_symbol	pointer
->	O
symbol	pointer
.	O
flags	int
=	O
(	O
BSF_GLOBAL	O
|	O
BSF_EXPORT	O
)	O
;	O
else	O
new_symbol	pointer
->	O
symbol	pointer
.	O
flags	int
=	O
BSF_LOCAL	O
;	O
if	O
(	O
stype	char
==	O
'2'	O
||	O
stype	char
==	O
'6'	O
)	O
new_symbol	pointer
->	O
symbol	pointer
.	O
section	pointer
=	O
bfd_abs_section_ptr	O
;	O
else	O
if	O
(	O
stype	char
==	O
'3'	O
||	O
stype	char
==	O
'7'	O
)	O
{	O
if	O
(	O
(	O
section	pointer
->	O
flags	int
&	O
SEC_DATA	int
)	O
==	O
0	int
)	O
section	pointer
->	O
flags	int
|=	O
SEC_CODE	int
;	O
else	O
{	O
if	O
(	O
alt_section	pointer
==	O
NULL	O
)	O
alt_section	pointer
=	O
bfd_get_next_section_by_name	function
(	O
NULL	O
,	O
section	pointer
)	O
;	O
if	O
(	O
alt_section	pointer
==	O
NULL	O
)	O
alt_section	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
abfd	pointer
,	O
section	pointer
->	O
name	pointer
,	O
(	O
section	pointer
->	O
flags	int
&	O
~	O
SEC_DATA	int
)	O
|	O
SEC_CODE	int
)	O
;	O
if	O
(	O
alt_section	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
new_symbol	pointer
->	O
symbol	pointer
.	O
section	pointer
=	O
alt_section	pointer
;	O
}	O
}	O
else	O
if	O
(	O
stype	char
==	O
'4'	O
||	O
stype	char
==	O
'8'	O
)	O
{	O
if	O
(	O
(	O
section	pointer
->	O
flags	int
&	O
SEC_CODE	int
)	O
==	O
0	int
)	O
section	pointer
->	O
flags	int
|=	O
SEC_DATA	int
;	O
else	O
{	O
if	O
(	O
alt_section	pointer
==	O
NULL	O
)	O
alt_section	pointer
=	O
bfd_get_next_section_by_name	function
(	O
NULL	O
,	O
section	pointer
)	O
;	O
if	O
(	O
alt_section	pointer
==	O
NULL	O
)	O
alt_section	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
abfd	pointer
,	O
section	pointer
->	O
name	pointer
,	O
(	O
section	pointer
->	O
flags	int
&	O
~	O
SEC_CODE	int
)	O
|	O
SEC_DATA	int
)	O
;	O
if	O
(	O
alt_section	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
new_symbol	pointer
->	O
symbol	pointer
.	O
section	pointer
=	O
alt_section	pointer
;	O
}	O
}	O
if	O
(	O
!	O
getvalue	function
(	O
&	O
src	pointer
,	O
&	O
val	array
,	O
src_end	pointer
)	O
)	O
return	O
FALSE	int
;	O
new_symbol	pointer
->	O
symbol	pointer
.	O
value	long
=	O
val	array
-	O
section	pointer
->	O
vma	long
;	O
break	O
;	O
}	O
default	O
:	O
return	O
FALSE	int
;	O
}	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
pass_over	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
bfd_boolean	int
(	O
*	O
func	pointer
)	O
(	O
bfd	struct
*	O
,	O
int	O
,	O
char	O
*	O
,	O
char	O
*	O
)	O
)	O
{	O
unsigned	O
int	O
chars_on_line	int
;	O
bfd_boolean	int
is_eof	int
=	O
FALSE	int
;	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
(	O
file_ptr	long
)	O
0	int
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
return	O
FALSE	int
;	O
while	O
(	O
!	O
is_eof	int
)	O
{	O
char	O
src	pointer
[	O
MAXCHUNK	int
]	O
;	O
char	O
type	enum
;	O
is_eof	int
=	O
(	O
bfd_boolean	int
)	O
(	O
bfd_bread	function
(	O
src	pointer
,	O
(	O
bfd_size_type	long
)	O
1	int
,	O
abfd	pointer
)	O
!=	O
1	int
)	O
;	O
while	O
(	O
*	O
src	pointer
!=	O
'%'	O
&&	O
!	O
is_eof	int
)	O
is_eof	int
=	O
(	O
bfd_boolean	int
)	O
(	O
bfd_bread	function
(	O
src	pointer
,	O
(	O
bfd_size_type	long
)	O
1	int
,	O
abfd	pointer
)	O
!=	O
1	int
)	O
;	O
if	O
(	O
is_eof	int
)	O
break	O
;	O
if	O
(	O
bfd_bread	function
(	O
src	pointer
,	O
(	O
bfd_size_type	long
)	O
5	int
,	O
abfd	pointer
)	O
!=	O
5	int
)	O
return	O
FALSE	int
;	O
type	enum
=	O
src	pointer
[	O
2	int
]	O
;	O
if	O
(	O
!	O
ISHEX	O
(	O
src	pointer
[	O
0	int
]	O
)	O
||	O
!	O
ISHEX	O
(	O
src	pointer
[	O
1	int
]	O
)	O
)	O
break	O
;	O
chars_on_line	int
=	O
HEX	O
(	O
src	pointer
)	O
-	O
5	int
;	O
if	O
(	O
chars_on_line	int
>=	O
MAXCHUNK	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
bfd_bread	function
(	O
src	pointer
,	O
(	O
bfd_size_type	long
)	O
chars_on_line	int
,	O
abfd	pointer
)	O
!=	O
chars_on_line	int
)	O
return	O
FALSE	int
;	O
src	pointer
[	O
chars_on_line	int
]	O
=	O
0	int
;	O
if	O
(	O
!	O
func	pointer
(	O
abfd	pointer
,	O
type	enum
,	O
src	pointer
,	O
src	pointer
+	O
chars_on_line	int
)	O
)	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
long	O
tekhex_canonicalize_symtab	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asymbol	struct
*	O
*	O
table	pointer
)	O
{	O
tekhex_symbol_type	struct
*	O
p	pointer
=	O
abfd	pointer
->	O
tdata	union
.	O
tekhex_data	pointer
->	O
symbols	pointer
;	O
unsigned	O
int	O
c	int
=	O
bfd_get_symcount	function
(	O
abfd	pointer
)	O
;	O
table	pointer
[	O
c	int
]	O
=	O
0	int
;	O
while	O
(	O
p	pointer
)	O
{	O
table	pointer
[	O
--	O
c	int
]	O
=	O
&	O
(	O
p	pointer
->	O
symbol	pointer
)	O
;	O
p	pointer
=	O
p	pointer
->	O
prev	pointer
;	O
}	O
return	O
bfd_get_symcount	function
(	O
abfd	pointer
)	O
;	O
}	O
static	O
long	O
tekhex_get_symtab_upper_bound	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
return	O
(	O
abfd	pointer
->	O
symcount	int
+	O
1	int
)	O
*	O
(	O
sizeof	O
(	O
struct	O
tekhex_asymbol_struct	O
*	O
)	O
)	O
;	O
}	O
static	O
bfd_boolean	int
tekhex_mkobject	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
tdata_type	struct
*	O
tdata	union
;	O
tdata	union
=	O
(	O
tdata_type	struct
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
(	O
bfd_size_type	long
)	O
sizeof	O
(	O
tdata_type	struct
)	O
)	O
;	O
if	O
(	O
!	O
tdata	union
)	O
return	O
FALSE	int
;	O
abfd	pointer
->	O
tdata	union
.	O
tekhex_data	pointer
=	O
tdata	union
;	O
tdata	union
->	O
type	enum
=	O
1	int
;	O
tdata	union
->	O
head	pointer
=	O
NULL	O
;	O
tdata	union
->	O
symbols	pointer
=	O
NULL	O
;	O
tdata	union
->	O
data	pointer
=	O
NULL	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
const	O
bfd_target	struct
*	O
tekhex_object_p	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
char	O
b	pointer
[	O
4	int
]	O
;	O
tekhex_init	function
(	O
)	O
;	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
(	O
file_ptr	long
)	O
0	int
,	O
SEEK_SET	int
)	O
!=	O
0	int
||	O
bfd_bread	function
(	O
b	pointer
,	O
(	O
bfd_size_type	long
)	O
4	int
,	O
abfd	pointer
)	O
!=	O
4	int
)	O
return	O
NULL	O
;	O
if	O
(	O
b	pointer
[	O
0	int
]	O
!=	O
'%'	O
||	O
!	O
ISHEX	O
(	O
b	pointer
[	O
1	int
]	O
)	O
||	O
!	O
ISHEX	O
(	O
b	pointer
[	O
2	int
]	O
)	O
||	O
!	O
ISHEX	O
(	O
b	pointer
[	O
3	int
]	O
)	O
)	O
return	O
NULL	O
;	O
tekhex_mkobject	function
(	O
abfd	pointer
)	O
;	O
if	O
(	O
!	O
pass_over	function
(	O
abfd	pointer
,	O
first_phase	function
)	O
)	O
return	O
NULL	O
;	O
return	O
abfd	pointer
->	O
xvec	pointer
;	O
}	O
static	O
void	O
move_section_contents	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
section	pointer
,	O
const	O
void	O
*	O
locationp	pointer
,	O
file_ptr	long
offset	long
,	O
bfd_size_type	long
count	int
,	O
bfd_boolean	int
get	int
)	O
{	O
bfd_vma	long
addr	pointer
;	O
char	O
*	O
location	pointer
=	O
(	O
char	O
*	O
)	O
locationp	pointer
;	O
bfd_vma	long
prev_number	long
=	O
1	int
;	O
struct	O
data_struct	struct
*	O
d	pointer
=	O
NULL	O
;	O
BFD_ASSERT	O
(	O
offset	long
==	O
0	int
)	O
;	O
for	O
(	O
addr	pointer
=	O
section	pointer
->	O
vma	long
;	O
count	int
!=	O
0	int
;	O
count	int
--	O
,	O
addr	pointer
++	O
)	O
{	O
bfd_vma	long
chunk_number	long
=	O
addr	pointer
&	O
~	O
(	O
bfd_vma	long
)	O
CHUNK_MASK	int
;	O
bfd_vma	long
low_bits	long
=	O
addr	pointer
&	O
CHUNK_MASK	int
;	O
bfd_boolean	int
must_write	int
=	O
!	O
get	int
&&	O
*	O
location	pointer
!=	O
0	int
;	O
if	O
(	O
chunk_number	long
!=	O
prev_number	long
||	O
(	O
!	O
d	pointer
&&	O
must_write	int
)	O
)	O
{	O
d	pointer
=	O
find_chunk	function
(	O
abfd	pointer
,	O
chunk_number	long
,	O
must_write	int
)	O
;	O
prev_number	long
=	O
chunk_number	long
;	O
}	O
if	O
(	O
get	int
)	O
{	O
if	O
(	O
d	pointer
)	O
*	O
location	pointer
=	O
d	pointer
->	O
chunk_data	array
[	O
low_bits	long
]	O
;	O
else	O
*	O
location	pointer
=	O
0	int
;	O
}	O
else	O
if	O
(	O
must_write	int
)	O
{	O
d	pointer
->	O
chunk_data	array
[	O
low_bits	long
]	O
=	O
*	O
location	pointer
;	O
d	pointer
->	O
chunk_init	array
[	O
low_bits	long
/	O
CHUNK_SPAN	int
]	O
=	O
1	int
;	O
}	O
location	pointer
++	O
;	O
}	O
}	O
static	O
bfd_boolean	int
tekhex_get_section_contents	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
section	pointer
,	O
void	O
*	O
locationp	pointer
,	O
file_ptr	long
offset	long
,	O
bfd_size_type	long
count	int
)	O
{	O
if	O
(	O
section	pointer
->	O
flags	int
&	O
(	O
SEC_LOAD	int
|	O
SEC_ALLOC	int
)	O
)	O
{	O
move_section_contents	function
(	O
abfd	pointer
,	O
section	pointer
,	O
locationp	pointer
,	O
offset	long
,	O
count	int
,	O
TRUE	int
)	O
;	O
return	O
TRUE	int
;	O
}	O
return	O
FALSE	int
;	O
}	O
static	O
bfd_boolean	int
tekhex_set_arch_mach	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
enum	O
bfd_architecture	enum
arch	enum
,	O
unsigned	O
long	O
machine	long
)	O
{	O
return	O
(	O
bfd_default_set_arch_mach	function
(	O
abfd	pointer
,	O
arch	enum
,	O
machine	long
)	O
||	O
arch	enum
==	O
bfd_arch_unknown	int
)	O
;	O
}	O
static	O
bfd_boolean	int
tekhex_set_section_contents	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
sec_ptr	pointer
section	pointer
,	O
const	O
void	O
*	O
locationp	pointer
,	O
file_ptr	long
offset	long
,	O
bfd_size_type	long
bytes_to_do	long
)	O
{	O
if	O
(	O
section	pointer
->	O
flags	int
&	O
(	O
SEC_LOAD	int
|	O
SEC_ALLOC	int
)	O
)	O
{	O
move_section_contents	function
(	O
abfd	pointer
,	O
section	pointer
,	O
locationp	pointer
,	O
offset	long
,	O
bytes_to_do	long
,	O
FALSE	int
)	O
;	O
return	O
TRUE	int
;	O
}	O
return	O
FALSE	int
;	O
}	O
static	O
void	O
writevalue	function
(	O
char	O
*	O
*	O
dst	pointer
,	O
bfd_vma	long
value	long
)	O
{	O
char	O
*	O
p	pointer
=	O
*	O
dst	pointer
;	O
int	O
len	long
;	O
int	O
shift	int
;	O
for	O
(	O
len	long
=	O
8	int
,	O
shift	int
=	O
28	int
;	O
shift	int
;	O
shift	int
-=	O
4	int
,	O
len	long
--	O
)	O
{	O
if	O
(	O
(	O
value	long
>>	O
shift	int
)	O
&	O
0xf	int
)	O
{	O
*	O
p	pointer
++	O
=	O
len	long
+	O
'0'	O
;	O
while	O
(	O
len	long
)	O
{	O
*	O
p	pointer
++	O
=	O
digs	array
[	O
(	O
value	long
>>	O
shift	int
)	O
&	O
0xf	int
]	O
;	O
shift	int
-=	O
4	int
;	O
len	long
--	O
;	O
}	O
*	O
dst	pointer
=	O
p	pointer
;	O
return	O
;	O
}	O
}	O
*	O
p	pointer
++	O
=	O
'1'	O
;	O
*	O
p	pointer
++	O
=	O
'0'	O
;	O
*	O
dst	pointer
=	O
p	pointer
;	O
}	O
static	O
void	O
writesym	function
(	O
char	O
*	O
*	O
dst	pointer
,	O
const	O
char	O
*	O
sym	pointer
)	O
{	O
char	O
*	O
p	pointer
=	O
*	O
dst	pointer
;	O
int	O
len	long
=	O
(	O
sym	pointer
?	O
strlen	function
(	O
sym	pointer
)	O
:	O
0	int
)	O
;	O
if	O
(	O
len	long
>=	O
16	int
)	O
{	O
*	O
p	pointer
++	O
=	O
'0'	O
;	O
len	long
=	O
16	int
;	O
}	O
else	O
{	O
if	O
(	O
len	long
==	O
0	int
)	O
{	O
*	O
p	pointer
++	O
=	O
'1'	O
;	O
sym	pointer
=	O
"$"	pointer
;	O
len	long
=	O
1	int
;	O
}	O
else	O
*	O
p	pointer
++	O
=	O
digs	array
[	O
len	long
]	O
;	O
}	O
while	O
(	O
len	long
--	O
)	O
*	O
p	pointer
++	O
=	O
*	O
sym	pointer
++	O
;	O
*	O
dst	pointer
=	O
p	pointer
;	O
}	O
static	O
void	O
out	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
int	O
type	enum
,	O
char	O
*	O
start	pointer
,	O
char	O
*	O
end	pointer
)	O
{	O
int	O
sum	int
=	O
0	int
;	O
char	O
*	O
s	pointer
;	O
char	O
front	array
[	O
6	int
]	O
;	O
bfd_size_type	long
wrlen	long
;	O
front	array
[	O
0	int
]	O
=	O
'%'	O
;	O
TOHEX	O
(	O
front	array
+	O
1	int
,	O
end	pointer
-	O
start	pointer
+	O
5	int
)	O
;	O
front	array
[	O
3	int
]	O
=	O
type	enum
;	O
for	O
(	O
s	pointer
=	O
start	pointer
;	O
s	pointer
<	O
end	pointer
;	O
s	pointer
++	O
)	O
sum	int
+=	O
sum_block	array
[	O
(	O
unsigned	O
char	O
)	O
*	O
s	pointer
]	O
;	O
sum	int
+=	O
sum_block	array
[	O
(	O
unsigned	O
char	O
)	O
front	array
[	O
1	int
]	O
]	O
;	O
sum	int
+=	O
sum_block	array
[	O
(	O
unsigned	O
char	O
)	O
front	array
[	O
2	int
]	O
]	O
;	O
sum	int
+=	O
sum_block	array
[	O
(	O
unsigned	O
char	O
)	O
front	array
[	O
3	int
]	O
]	O
;	O
TOHEX	O
(	O
front	array
+	O
4	int
,	O
sum	int
)	O
;	O
if	O
(	O
bfd_bwrite	function
(	O
front	array
,	O
(	O
bfd_size_type	long
)	O
6	int
,	O
abfd	pointer
)	O
!=	O
6	int
)	O
abort	function
(	O
)	O
;	O
end	pointer
[	O
0	int
]	O
=	O
'\n'	O
;	O
wrlen	long
=	O
end	pointer
-	O
start	pointer
+	O
1	int
;	O
if	O
(	O
bfd_bwrite	function
(	O
start	pointer
,	O
wrlen	long
,	O
abfd	pointer
)	O
!=	O
wrlen	long
)	O
abort	function
(	O
)	O
;	O
}	O
static	O
bfd_boolean	int
tekhex_write_object_contents	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
char	O
buffer	pointer
[	O
100	int
]	O
;	O
asymbol	struct
*	O
*	O
p	pointer
;	O
asection	struct
*	O
s	pointer
;	O
struct	O
data_struct	struct
*	O
d	pointer
;	O
tekhex_init	function
(	O
)	O
;	O
for	O
(	O
d	pointer
=	O
abfd	pointer
->	O
tdata	union
.	O
tekhex_data	pointer
->	O
data	pointer
;	O
d	pointer
!=	O
NULL	O
;	O
d	pointer
=	O
d	pointer
->	O
next	pointer
)	O
{	O
int	O
low	long
;	O
int	O
addr	pointer
;	O
for	O
(	O
addr	pointer
=	O
0	int
;	O
addr	pointer
<	O
CHUNK_MASK	int
+	O
1	int
;	O
addr	pointer
+=	O
CHUNK_SPAN	int
)	O
{	O
if	O
(	O
d	pointer
->	O
chunk_init	array
[	O
addr	pointer
/	O
CHUNK_SPAN	int
]	O
)	O
{	O
char	O
*	O
dst	pointer
=	O
buffer	pointer
;	O
writevalue	function
(	O
&	O
dst	pointer
,	O
addr	pointer
+	O
d	pointer
->	O
vma	long
)	O
;	O
for	O
(	O
low	long
=	O
0	int
;	O
low	long
<	O
CHUNK_SPAN	int
;	O
low	long
++	O
)	O
{	O
TOHEX	O
(	O
dst	pointer
,	O
d	pointer
->	O
chunk_data	array
[	O
addr	pointer
+	O
low	long
]	O
)	O
;	O
dst	pointer
+=	O
2	int
;	O
}	O
out	function
(	O
abfd	pointer
,	O
'6'	O
,	O
buffer	pointer
,	O
dst	pointer
)	O
;	O
}	O
}	O
}	O
for	O
(	O
s	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
{	O
char	O
*	O
dst	pointer
=	O
buffer	pointer
;	O
writesym	function
(	O
&	O
dst	pointer
,	O
s	pointer
->	O
name	pointer
)	O
;	O
*	O
dst	pointer
++	O
=	O
'1'	O
;	O
writevalue	function
(	O
&	O
dst	pointer
,	O
s	pointer
->	O
vma	long
)	O
;	O
writevalue	function
(	O
&	O
dst	pointer
,	O
s	pointer
->	O
vma	long
+	O
s	pointer
->	O
size	long
)	O
;	O
out	function
(	O
abfd	pointer
,	O
'3'	O
,	O
buffer	pointer
,	O
dst	pointer
)	O
;	O
}	O
if	O
(	O
abfd	pointer
->	O
outsymbols	pointer
)	O
{	O
for	O
(	O
p	pointer
=	O
abfd	pointer
->	O
outsymbols	pointer
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
{	O
int	O
section_code	int
=	O
bfd_decode_symclass	function
(	O
*	O
p	pointer
)	O
;	O
if	O
(	O
section_code	int
!=	O
'?'	O
)	O
{	O
asymbol	struct
*	O
sym	pointer
=	O
*	O
p	pointer
;	O
char	O
*	O
dst	pointer
=	O
buffer	pointer
;	O
writesym	function
(	O
&	O
dst	pointer
,	O
sym	pointer
->	O
section	pointer
->	O
name	pointer
)	O
;	O
switch	O
(	O
section_code	int
)	O
{	O
case	O
'A'	O
:	O
*	O
dst	pointer
++	O
=	O
'2'	O
;	O
break	O
;	O
case	O
'a'	O
:	O
*	O
dst	pointer
++	O
=	O
'6'	O
;	O
break	O
;	O
case	O
'D'	O
:	O
case	O
'B'	O
:	O
case	O
'O'	O
:	O
*	O
dst	pointer
++	O
=	O
'4'	O
;	O
break	O
;	O
case	O
'd'	O
:	O
case	O
'b'	O
:	O
case	O
'o'	O
:	O
*	O
dst	pointer
++	O
=	O
'8'	O
;	O
break	O
;	O
case	O
'T'	O
:	O
*	O
dst	pointer
++	O
=	O
'3'	O
;	O
break	O
;	O
case	O
't'	O
:	O
*	O
dst	pointer
++	O
=	O
'7'	O
;	O
break	O
;	O
case	O
'C'	O
:	O
case	O
'U'	O
:	O
bfd_set_error	function
(	O
bfd_error_wrong_format	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
writesym	function
(	O
&	O
dst	pointer
,	O
sym	pointer
->	O
name	pointer
)	O
;	O
writevalue	function
(	O
&	O
dst	pointer
,	O
sym	pointer
->	O
value	long
+	O
sym	pointer
->	O
section	pointer
->	O
vma	long
)	O
;	O
out	function
(	O
abfd	pointer
,	O
'3'	O
,	O
buffer	pointer
,	O
dst	pointer
)	O
;	O
}	O
}	O
}	O
if	O
(	O
bfd_bwrite	function
(	O
"%0781010\n"	pointer
,	O
(	O
bfd_size_type	long
)	O
9	int
,	O
abfd	pointer
)	O
!=	O
9	int
)	O
abort	function
(	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
int	O
tekhex_sizeof_headers	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
bfd_link_info	O
*	O
info	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
0	int
;	O
}	O
static	O
asymbol	struct
*	O
tekhex_make_empty_symbol	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
bfd_size_type	long
amt	long
=	O
sizeof	O
(	O
struct	O
tekhex_symbol_struct	struct
)	O
;	O
tekhex_symbol_type	struct
*	O
new_symbol	pointer
=	O
(	O
tekhex_symbol_type	struct
*	O
)	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
!	O
new_symbol	pointer
)	O
return	O
NULL	O
;	O
new_symbol	pointer
->	O
symbol	pointer
.	O
the_bfd	pointer
=	O
abfd	pointer
;	O
new_symbol	pointer
->	O
prev	pointer
=	O
NULL	O
;	O
return	O
&	O
(	O
new_symbol	pointer
->	O
symbol	pointer
)	O
;	O
}	O
static	O
void	O
tekhex_get_symbol_info	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
asymbol	struct
*	O
symbol	pointer
,	O
symbol_info	struct
*	O
ret	pointer
)	O
{	O
bfd_symbol_info	function
(	O
symbol	pointer
,	O
ret	pointer
)	O
;	O
}	O
static	O
void	O
tekhex_print_symbol	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
void	O
*	O
filep	pointer
,	O
asymbol	struct
*	O
symbol	pointer
,	O
bfd_print_symbol_type	enum
how	enum
)	O
{	O
FILE	struct
*	O
file	pointer
=	O
(	O
FILE	struct
*	O
)	O
filep	pointer
;	O
switch	O
(	O
how	enum
)	O
{	O
case	O
bfd_print_symbol_name	int
:	O
fprintf	function
(	O
file	pointer
,	O
"%s"	pointer
,	O
symbol	pointer
->	O
name	pointer
)	O
;	O
break	O
;	O
case	O
bfd_print_symbol_more	int
:	O
break	O
;	O
case	O
bfd_print_symbol_all	int
:	O
{	O
const	O
char	O
*	O
section_name	pointer
=	O
symbol	pointer
->	O
section	pointer
->	O
name	pointer
;	O
bfd_print_symbol_vandf	function
(	O
abfd	pointer
,	O
(	O
void	O
*	O
)	O
file	pointer
,	O
symbol	pointer
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
" %-5s %s"	pointer
,	O
section_name	pointer
,	O
symbol	pointer
->	O
name	pointer
)	O
;	O
}	O
}	O
}	O
const	O
bfd_target	struct
tekhex_vec	struct
=	O
{	O
"tekhex"	pointer
,	O
bfd_target_tekhex_flavour	int
,	O
BFD_ENDIAN_UNKNOWN	int
,	O
BFD_ENDIAN_UNKNOWN	int
,	O
(	O
EXEC_P	int
|	O
HAS_SYMS	int
|	O
HAS_LINENO	int
|	O
HAS_DEBUG	int
|	O
HAS_RELOC	int
|	O
HAS_LOCALS	int
|	O
WP_TEXT	int
|	O
D_PAGED	int
)	O
,	O
(	O
SEC_CODE	int
|	O
SEC_DATA	int
|	O
SEC_ROM	int
|	O
SEC_HAS_CONTENTS	int
|	O
SEC_ALLOC	int
|	O
SEC_LOAD	int
|	O
SEC_RELOC	int
)	O
,	O
0	int
,	O
' '	O
,	O
16	int
,	O
0	int
,	O
bfd_getb64	function
,	O
bfd_getb_signed_64	function
,	O
bfd_putb64	function
,	O
bfd_getb32	function
,	O
bfd_getb_signed_32	function
,	O
bfd_putb32	function
,	O
bfd_getb16	function
,	O
bfd_getb_signed_16	function
,	O
bfd_putb16	function
,	O
bfd_getb64	function
,	O
bfd_getb_signed_64	function
,	O
bfd_putb64	function
,	O
bfd_getb32	function
,	O
bfd_getb_signed_32	function
,	O
bfd_putb32	function
,	O
bfd_getb16	function
,	O
bfd_getb_signed_16	function
,	O
bfd_putb16	function
,	O
{	O
_bfd_dummy_target	function
,	O
tekhex_object_p	function
,	O
_bfd_dummy_target	function
,	O
_bfd_dummy_target	function
,	O
}	O
,	O
{	O
_bfd_bool_bfd_false_error	function
,	O
tekhex_mkobject	function
,	O
_bfd_generic_mkarchive	function
,	O
_bfd_bool_bfd_false_error	function
,	O
}	O
,	O
{	O
_bfd_bool_bfd_false_error	function
,	O
tekhex_write_object_contents	function
,	O
_bfd_write_archive_contents	function
,	O
_bfd_bool_bfd_false_error	function
,	O
}	O
,	O
BFD_JUMP_TABLE_GENERIC	O
(	O
tekhex	O
)	O
,	O
BFD_JUMP_TABLE_COPY	O
(	O
_bfd_generic	O
)	O
,	O
BFD_JUMP_TABLE_CORE	O
(	O
_bfd_nocore	O
)	O
,	O
BFD_JUMP_TABLE_ARCHIVE	O
(	O
_bfd_noarchive	O
)	O
,	O
BFD_JUMP_TABLE_SYMBOLS	O
(	O
tekhex	O
)	O
,	O
BFD_JUMP_TABLE_RELOCS	O
(	O
_bfd_norelocs	O
)	O
,	O
BFD_JUMP_TABLE_WRITE	O
(	O
tekhex	O
)	O
,	O
BFD_JUMP_TABLE_LINK	O
(	O
tekhex	O
)	O
,	O
BFD_JUMP_TABLE_DYNAMIC	O
(	O
_bfd_nodynamic	O
)	O
,	O
NULL	O
,	O
NULL	O
}	O
;	O
