enum	O
{	O
EXCEPTION_NONE	int
=	O
0x00	int
,	O
EXCEPTION_TRY	int
=	O
0x45	int
,	O
EXCEPTION_THROW	int
,	O
EXCEPTION_CATCH	int
}	O
;	O
struct	O
unwind_handler	struct
{	O
gnufdisk_exception_unwind_handler	function
*	O
handler	pointer
;	O
void	O
*	O
arg	pointer
;	O
}	O
;	O
struct	O
exception	struct
{	O
struct	O
exception	struct
*	O
prev	pointer
;	O
jmp_buf	array
*	O
jmp	pointer
;	O
gnufdisk_exception_handler	function
*	O
handler	pointer
;	O
void	O
*	O
handler_data	pointer
;	O
struct	O
gnufdisk_exception_info	struct
*	O
error_data	pointer
;	O
int	O
state	pointer
;	O
struct	O
unwind_handler	struct
*	O
*	O
unwind_handlers	pointer
;	O
int	O
nunwind_handlers	int
;	O
}	O
;	O
struct	O
context	struct
{	O
pthread_t	long
id	long
;	O
struct	O
exception	struct
*	O
current	pointer
;	O
}	O
;	O
struct	O
global_data	struct
{	O
struct	O
context	struct
*	O
*	O
threads	pointer
;	O
int	O
nthreads	int
;	O
}	O
;	O
struct	O
global_data	struct
gdata	struct
=	O
{	O
0	int
}	O
;	O
pthread_mutex_t	union
gmutex	union
=	O
PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP	O
;	O
static	O
void	O
fatal	function
(	O
const	O
char	O
*	O
_file	pointer
,	O
const	O
int	O
_line	int
,	O
const	O
char	O
*	O
_fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
args	array
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s:%d: "	pointer
,	O
_file	pointer
,	O
_line	int
)	O
;	O
va_start	O
(	O
args	array
,	O
_fmt	pointer
)	O
;	O
vfprintf	function
(	O
stderr	pointer
,	O
_fmt	pointer
,	O
args	array
)	O
;	O
va_end	O
(	O
args	array
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
" abort()\n"	pointer
)	O
;	O
pthread_kill	function
(	O
pthread_self	function
(	O
)	O
,	O
SIGABRT	int
)	O
;	O
}	O
static	O
void	O
*	O
xmalloc	function
(	O
size_t	long
_s	pointer
)	O
{	O
void	O
*	O
p	pointer
;	O
if	O
(	O
(	O
p	pointer
=	O
malloc	function
(	O
_s	pointer
)	O
)	O
==	O
NULL	O
)	O
FATAL	O
(	O
"dynamic memory allocation failure"	pointer
)	O
;	O
memset	function
(	O
p	pointer
,	O
0	int
,	O
_s	pointer
)	O
;	O
return	O
p	pointer
;	O
}	O
static	O
struct	O
exception	struct
*	O
exception_new	function
(	O
jmp_buf	array
*	O
_jmp	pointer
,	O
gnufdisk_exception_handler	function
*	O
_h	pointer
,	O
void	O
*	O
_data	pointer
)	O
{	O
struct	O
exception	struct
*	O
e	pointer
;	O
e	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
exception	struct
)	O
)	O
;	O
e	pointer
->	O
jmp	pointer
=	O
_jmp	pointer
;	O
e	pointer
->	O
handler	pointer
=	O
_h	pointer
;	O
e	pointer
->	O
handler_data	pointer
=	O
_data	pointer
;	O
e	pointer
->	O
state	pointer
=	O
EXCEPTION_NONE	int
;	O
return	O
e	pointer
;	O
}	O
static	O
void	O
exception_delete	function
(	O
struct	O
exception	struct
*	O
_e	pointer
)	O
{	O
if	O
(	O
_e	pointer
->	O
unwind_handlers	pointer
)	O
{	O
int	O
iter	int
;	O
for	O
(	O
iter	int
=	O
0	int
;	O
iter	int
<	O
_e	pointer
->	O
nunwind_handlers	int
;	O
iter	int
++	O
)	O
{	O
if	O
(	O
_e	pointer
->	O
unwind_handlers	pointer
[	O
iter	int
]	O
!=	O
NULL	O
)	O
free	function
(	O
_e	pointer
->	O
unwind_handlers	pointer
[	O
iter	int
]	O
)	O
;	O
}	O
free	function
(	O
_e	pointer
->	O
unwind_handlers	pointer
)	O
;	O
}	O
free	function
(	O
_e	pointer
)	O
;	O
}	O
static	O
struct	O
context	struct
*	O
find_context	function
(	O
void	O
)	O
{	O
struct	O
context	struct
*	O
ret	pointer
;	O
pthread_t	long
id	long
;	O
int	O
iter	int
;	O
ret	pointer
=	O
NULL	O
;	O
id	long
=	O
pthread_self	function
(	O
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
gmutex	union
)	O
;	O
for	O
(	O
iter	int
=	O
0	int
;	O
iter	int
<	O
gdata	struct
.	O
nthreads	int
;	O
iter	int
++	O
)	O
if	O
(	O
gdata	struct
.	O
threads	pointer
[	O
iter	int
]	O
!=	O
NULL	O
&&	O
pthread_equal	function
(	O
gdata	struct
.	O
threads	pointer
[	O
iter	int
]	O
->	O
id	long
,	O
id	long
)	O
)	O
{	O
ret	pointer
=	O
gdata	struct
.	O
threads	pointer
[	O
iter	int
]	O
;	O
break	O
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
gmutex	union
)	O
;	O
return	O
ret	pointer
;	O
}	O
static	O
struct	O
context	struct
*	O
get_context	function
(	O
void	O
)	O
{	O
struct	O
context	struct
*	O
ret	pointer
;	O
pthread_t	long
id	long
;	O
int	O
iter	int
;	O
id	long
=	O
pthread_self	function
(	O
)	O
;	O
ret	pointer
=	O
NULL	O
;	O
pthread_mutex_lock	function
(	O
&	O
gmutex	union
)	O
;	O
ret	pointer
=	O
find_context	function
(	O
)	O
;	O
if	O
(	O
ret	pointer
==	O
NULL	O
)	O
{	O
ret	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
context	struct
)	O
)	O
;	O
ret	pointer
->	O
id	long
=	O
id	long
;	O
for	O
(	O
iter	int
=	O
0	int
;	O
iter	int
<	O
gdata	struct
.	O
nthreads	int
;	O
iter	int
++	O
)	O
if	O
(	O
gdata	struct
.	O
threads	pointer
[	O
iter	int
]	O
==	O
NULL	O
)	O
break	O
;	O
if	O
(	O
iter	int
==	O
gdata	struct
.	O
nthreads	int
)	O
{	O
struct	O
context	struct
*	O
*	O
threads	pointer
;	O
int	O
nthreads	int
;	O
nthreads	int
=	O
gdata	struct
.	O
nthreads	int
+	O
4	int
;	O
threads	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
context	struct
*	O
)	O
*	O
nthreads	int
)	O
;	O
memset	function
(	O
threads	pointer
,	O
0	int
,	O
sizeof	O
(	O
struct	O
context	struct
*	O
)	O
*	O
nthreads	int
)	O
;	O
if	O
(	O
gdata	struct
.	O
threads	pointer
)	O
{	O
memcpy	function
(	O
threads	pointer
,	O
gdata	struct
.	O
threads	pointer
,	O
sizeof	O
(	O
struct	O
context	struct
)	O
*	O
gdata	struct
.	O
nthreads	int
)	O
;	O
free	function
(	O
gdata	struct
.	O
threads	pointer
)	O
;	O
}	O
gdata	struct
.	O
threads	pointer
=	O
threads	pointer
;	O
gdata	struct
.	O
nthreads	int
=	O
nthreads	int
;	O
}	O
gdata	struct
.	O
threads	pointer
[	O
iter	int
]	O
=	O
ret	pointer
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
gmutex	union
)	O
;	O
return	O
ret	pointer
;	O
}	O
static	O
void	O
context_delete	function
(	O
void	O
)	O
{	O
pthread_t	long
id	long
;	O
int	O
iter	int
;	O
id	long
=	O
pthread_self	function
(	O
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
gmutex	union
)	O
;	O
for	O
(	O
iter	int
=	O
0	int
;	O
iter	int
<	O
gdata	struct
.	O
nthreads	int
;	O
iter	int
++	O
)	O
if	O
(	O
gdata	struct
.	O
threads	pointer
[	O
iter	int
]	O
!=	O
NULL	O
&&	O
pthread_equal	function
(	O
gdata	struct
.	O
threads	pointer
[	O
iter	int
]	O
->	O
id	long
,	O
id	long
)	O
)	O
{	O
free	function
(	O
gdata	struct
.	O
threads	pointer
[	O
iter	int
]	O
)	O
;	O
gdata	struct
.	O
threads	pointer
[	O
iter	int
]	O
=	O
NULL	O
;	O
break	O
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
gmutex	union
)	O
;	O
}	O
static	O
void	O
call_unwind_handlers	function
(	O
struct	O
exception	struct
*	O
e	pointer
)	O
{	O
int	O
iter	int
;	O
for	O
(	O
iter	int
=	O
e	pointer
->	O
nunwind_handlers	int
-	O
1	int
;	O
iter	int
>=	O
0	int
;	O
iter	int
--	O
)	O
if	O
(	O
gnufdisk_check_memory	function
(	O
e	pointer
->	O
unwind_handlers	pointer
[	O
iter	int
]	O
,	O
sizeof	O
(	O
struct	O
unwind_handler	struct
)	O
,	O
0	int
)	O
==	O
0	int
&&	O
gnufdisk_check_memory	function
(	O
e	pointer
->	O
unwind_handlers	pointer
[	O
iter	int
]	O
->	O
handler	pointer
,	O
1	int
,	O
1	int
)	O
==	O
0	int
)	O
{	O
(	O
*	O
e	pointer
->	O
unwind_handlers	pointer
[	O
iter	int
]	O
->	O
handler	pointer
)	O
(	O
e	pointer
->	O
unwind_handlers	pointer
[	O
iter	int
]	O
->	O
arg	pointer
)	O
;	O
free	function
(	O
e	pointer
->	O
unwind_handlers	pointer
[	O
iter	int
]	O
)	O
;	O
e	pointer
->	O
unwind_handlers	pointer
[	O
iter	int
]	O
=	O
NULL	O
;	O
}	O
}	O
void	O
gnufdisk_exception_try	function
(	O
jmp_buf	array
*	O
_jmp	pointer
,	O
gnufdisk_exception_handler	function
*	O
_handler	pointer
,	O
void	O
*	O
_arg	pointer
)	O
{	O
struct	O
exception	struct
*	O
e	pointer
;	O
struct	O
context	struct
*	O
c	pointer
;	O
if	O
(	O
_handler	pointer
&&	O
gnufdisk_check_memory	function
(	O
_handler	pointer
,	O
1	int
,	O
1	int
)	O
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s:%d warning: invalid gnufdisk_exception_handler* %p\n"	pointer
,	O
__FILE__	O
,	O
__LINE__	O
,	O
_handler	pointer
)	O
;	O
_handler	pointer
=	O
NULL	O
;	O
_arg	pointer
=	O
NULL	O
;	O
}	O
else	O
if	O
(	O
_arg	pointer
&&	O
gnufdisk_check_memory	function
(	O
_arg	pointer
,	O
1	int
,	O
1	int
)	O
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s:%d warning: invalid handler agrument* %p\n"	pointer
,	O
__FILE__	O
,	O
__LINE__	O
,	O
_arg	pointer
)	O
;	O
_handler	pointer
=	O
NULL	O
;	O
_arg	pointer
=	O
NULL	O
;	O
}	O
c	pointer
=	O
get_context	function
(	O
)	O
;	O
e	pointer
=	O
exception_new	function
(	O
_jmp	pointer
,	O
_handler	pointer
,	O
_arg	pointer
)	O
;	O
e	pointer
->	O
prev	pointer
=	O
c	pointer
->	O
current	pointer
;	O
e	pointer
->	O
state	pointer
=	O
EXCEPTION_TRY	int
;	O
c	pointer
->	O
current	pointer
=	O
e	pointer
;	O
}	O
void	O
gnufdisk_exception_throw	function
(	O
const	O
char	O
*	O
_file	pointer
,	O
const	O
int	O
_line	int
,	O
int	O
_flags	int
,	O
jmp_buf	array
*	O
_retry	pointer
,	O
int	O
_error	int
,	O
void	O
*	O
_data	pointer
,	O
const	O
char	O
*	O
_fmt	pointer
,	O
...	O
)	O
{	O
struct	O
context	struct
*	O
c	pointer
;	O
struct	O
exception	struct
*	O
e	pointer
;	O
int	O
prev_state	int
;	O
printf	function
(	O
"%s:%s:%d: THROW FROM %s:%d, error: %d\n"	pointer
,	O
__FILE__	O
,	O
__FUNCTION__	O
,	O
__LINE__	O
,	O
_file	pointer
,	O
_line	int
,	O
_error	int
)	O
;	O
c	pointer
=	O
get_context	function
(	O
)	O
;	O
e	pointer
=	O
c	pointer
->	O
current	pointer
;	O
lb_continue	O
:	O
if	O
(	O
e	pointer
==	O
NULL	O
)	O
FATAL	O
(	O
"There is no try context in this thread. Can not raise the exception signaled by: %s:%d"	pointer
,	O
_file	pointer
,	O
_line	int
)	O
;	O
if	O
(	O
e	pointer
->	O
state	pointer
==	O
EXCEPTION_THROW	int
)	O
{	O
c	pointer
->	O
current	pointer
=	O
e	pointer
->	O
prev	pointer
;	O
if	O
(	O
c	pointer
->	O
current	pointer
)	O
c	pointer
->	O
current	pointer
->	O
error_data	pointer
=	O
e	pointer
->	O
error_data	pointer
;	O
else	O
if	O
(	O
e	pointer
->	O
error_data	pointer
)	O
{	O
free	function
(	O
e	pointer
->	O
error_data	pointer
->	O
message	pointer
)	O
;	O
free	function
(	O
e	pointer
->	O
error_data	pointer
->	O
file	pointer
)	O
;	O
free	function
(	O
e	pointer
->	O
error_data	pointer
)	O
;	O
}	O
call_unwind_handlers	function
(	O
e	pointer
)	O
;	O
exception_delete	function
(	O
e	pointer
)	O
;	O
e	pointer
=	O
c	pointer
->	O
current	pointer
;	O
goto	O
lb_continue	O
;	O
}	O
prev_state	int
=	O
e	pointer
->	O
state	pointer
;	O
e	pointer
->	O
state	pointer
=	O
EXCEPTION_THROW	int
;	O
if	O
(	O
e	pointer
->	O
error_data	pointer
==	O
NULL	O
)	O
{	O
struct	O
gnufdisk_exception_info	struct
*	O
d	pointer
;	O
va_list	array
args	array
;	O
int	O
err	long
;	O
d	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
gnufdisk_exception_info	struct
)	O
)	O
;	O
va_start	O
(	O
args	array
,	O
_fmt	pointer
)	O
;	O
err	long
=	O
gnufdisk_vasprintf	function
(	O
&	O
d	pointer
->	O
message	pointer
,	O
_fmt	pointer
,	O
args	array
)	O
;	O
va_end	O
(	O
args	array
)	O
;	O
if	O
(	O
err	long
==	O
-	O
1	int
)	O
FATAL	O
(	O
"Can not format exception message: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
if	O
(	O
(	O
d	pointer
->	O
file	pointer
=	O
strdup	function
(	O
_file	pointer
)	O
)	O
==	O
NULL	O
)	O
FATAL	O
(	O
"dynamic memory allocation failure"	pointer
)	O
;	O
d	pointer
->	O
line	int
=	O
_line	int
;	O
d	pointer
->	O
error	int
=	O
_error	int
;	O
e	pointer
->	O
error_data	pointer
=	O
d	pointer
;	O
}	O
if	O
(	O
(	O
_flags	int
&	O
GNUFDISK_EXCEPTION_MANAGEABLE	int
)	O
&&	O
e	pointer
->	O
handler	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
*	O
e	pointer
->	O
handler	pointer
)	O
(	O
e	pointer
->	O
handler_data	pointer
,	O
e	pointer
->	O
error_data	pointer
,	O
_data	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
_flags	int
&	O
GNUFDISK_EXCEPTION_LOCKABLE	int
)	O
{	O
e	pointer
->	O
state	pointer
=	O
prev_state	int
;	O
if	O
(	O
e	pointer
->	O
error_data	pointer
!=	O
NULL	O
)	O
{	O
free	function
(	O
e	pointer
->	O
error_data	pointer
->	O
message	pointer
)	O
;	O
free	function
(	O
e	pointer
->	O
error_data	pointer
->	O
file	pointer
)	O
;	O
free	function
(	O
e	pointer
->	O
error_data	pointer
)	O
;	O
e	pointer
->	O
error_data	pointer
=	O
NULL	O
;	O
}	O
longjmp	function
(	O
*	O
_retry	pointer
,	O
0xff	int
)	O
;	O
}	O
}	O
}	O
call_unwind_handlers	function
(	O
e	pointer
)	O
;	O
longjmp	function
(	O
*	O
e	pointer
->	O
jmp	pointer
,	O
e	pointer
->	O
error_data	pointer
->	O
error	int
)	O
;	O
}	O
void	O
gnufdisk_exception_catch	function
(	O
struct	O
gnufdisk_exception_info	struct
*	O
_info	pointer
)	O
{	O
struct	O
context	struct
*	O
c	pointer
;	O
struct	O
exception	struct
*	O
e	pointer
;	O
c	pointer
=	O
get_context	function
(	O
)	O
;	O
e	pointer
=	O
c	pointer
->	O
current	pointer
;	O
if	O
(	O
e	pointer
==	O
NULL	O
)	O
FATAL	O
(	O
"There are no try context on this thread"	pointer
)	O
;	O
else	O
if	O
(	O
e	pointer
->	O
state	pointer
!=	O
EXCEPTION_THROW	int
)	O
FATAL	O
(	O
"There is no exception to handle"	pointer
)	O
;	O
e	pointer
->	O
state	pointer
=	O
EXCEPTION_CATCH	int
;	O
if	O
(	O
_info	pointer
)	O
memcpy	function
(	O
_info	pointer
,	O
e	pointer
->	O
error_data	pointer
,	O
sizeof	O
(	O
struct	O
gnufdisk_exception_info	struct
)	O
)	O
;	O
}	O
void	O
gnufdisk_exception_end	function
(	O
void	O
)	O
{	O
struct	O
context	struct
*	O
c	pointer
;	O
struct	O
exception	struct
*	O
e	pointer
;	O
c	pointer
=	O
get_context	function
(	O
)	O
;	O
e	pointer
=	O
c	pointer
->	O
current	pointer
;	O
if	O
(	O
e	pointer
==	O
NULL	O
)	O
FATAL	O
(	O
"There are no try context on this thread."	pointer
)	O
;	O
if	O
(	O
e	pointer
->	O
state	pointer
==	O
EXCEPTION_THROW	int
)	O
{	O
c	pointer
->	O
current	pointer
=	O
e	pointer
->	O
prev	pointer
;	O
if	O
(	O
c	pointer
->	O
current	pointer
)	O
c	pointer
->	O
current	pointer
->	O
error_data	pointer
=	O
e	pointer
->	O
error_data	pointer
;	O
else	O
{	O
free	function
(	O
e	pointer
->	O
error_data	pointer
->	O
message	pointer
)	O
;	O
free	function
(	O
e	pointer
->	O
error_data	pointer
->	O
file	pointer
)	O
;	O
free	function
(	O
e	pointer
->	O
error_data	pointer
)	O
;	O
free	function
(	O
e	pointer
)	O
;	O
}	O
gnufdisk_exception_throw	function
(	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
c	pointer
->	O
current	pointer
=	O
e	pointer
->	O
prev	pointer
;	O
exception_delete	function
(	O
e	pointer
)	O
;	O
if	O
(	O
c	pointer
->	O
current	pointer
==	O
NULL	O
)	O
context_delete	function
(	O
)	O
;	O
}	O
int	O
gnufdisk_exception_register_unwind_handler	function
(	O
gnufdisk_exception_unwind_handler	function
*	O
_h	pointer
,	O
void	O
*	O
_a	pointer
)	O
{	O
struct	O
context	struct
*	O
c	pointer
;	O
struct	O
exception	struct
*	O
e	pointer
;	O
int	O
iter	int
;	O
int	O
err	long
;	O
if	O
(	O
(	O
err	long
=	O
gnufdisk_check_memory	function
(	O
_h	pointer
,	O
1	int
,	O
1	int
)	O
)	O
!=	O
0	int
)	O
{	O
errno	O
=	O
err	long
;	O
return	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
_a	pointer
!=	O
NULL	O
&&	O
(	O
err	long
=	O
gnufdisk_check_memory	function
(	O
_a	pointer
,	O
1	int
,	O
1	int
)	O
)	O
!=	O
0	int
)	O
{	O
errno	O
=	O
err	long
;	O
return	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
(	O
c	pointer
=	O
find_context	function
(	O
)	O
)	O
==	O
NULL	O
)	O
{	O
errno	O
=	O
ENXIO	int
;	O
return	O
-	O
1	int
;	O
}	O
e	pointer
=	O
c	pointer
->	O
current	pointer
;	O
for	O
(	O
iter	int
=	O
0	int
;	O
iter	int
<	O
e	pointer
->	O
nunwind_handlers	int
;	O
iter	int
++	O
)	O
if	O
(	O
e	pointer
->	O
unwind_handlers	pointer
[	O
iter	int
]	O
==	O
NULL	O
)	O
break	O
;	O
if	O
(	O
iter	int
==	O
e	pointer
->	O
nunwind_handlers	int
)	O
{	O
struct	O
unwind_handler	struct
*	O
*	O
handlers	pointer
;	O
int	O
nhandlers	int
;	O
nhandlers	int
=	O
e	pointer
->	O
nunwind_handlers	int
+	O
8	int
;	O
handlers	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
unwind_handler	struct
*	O
)	O
*	O
nhandlers	int
)	O
;	O
if	O
(	O
e	pointer
->	O
unwind_handlers	pointer
)	O
{	O
memcpy	function
(	O
handlers	pointer
,	O
e	pointer
->	O
unwind_handlers	pointer
,	O
sizeof	O
(	O
struct	O
unwind_handler	struct
*	O
)	O
*	O
e	pointer
->	O
nunwind_handlers	int
)	O
;	O
free	function
(	O
e	pointer
->	O
unwind_handlers	pointer
)	O
;	O
}	O
e	pointer
->	O
unwind_handlers	pointer
=	O
handlers	pointer
;	O
e	pointer
->	O
nunwind_handlers	int
=	O
nhandlers	int
;	O
}	O
e	pointer
->	O
unwind_handlers	pointer
[	O
iter	int
]	O
=	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
unwind_handler	struct
)	O
)	O
;	O
e	pointer
->	O
unwind_handlers	pointer
[	O
iter	int
]	O
->	O
handler	pointer
=	O
_h	pointer
;	O
e	pointer
->	O
unwind_handlers	pointer
[	O
iter	int
]	O
->	O
arg	pointer
=	O
_a	pointer
;	O
return	O
0	int
;	O
}	O
int	O
gnufdisk_exception_unregister_unwind_handler	function
(	O
gnufdisk_exception_unwind_handler	function
*	O
_h	pointer
,	O
void	O
*	O
_a	pointer
)	O
{	O
struct	O
context	struct
*	O
c	pointer
;	O
struct	O
exception	struct
*	O
e	pointer
;	O
int	O
iter	int
;	O
if	O
(	O
(	O
c	pointer
=	O
find_context	function
(	O
)	O
)	O
==	O
NULL	O
)	O
{	O
errno	O
=	O
ENXIO	int
;	O
return	O
-	O
1	int
;	O
}	O
e	pointer
=	O
c	pointer
->	O
current	pointer
;	O
for	O
(	O
iter	int
=	O
e	pointer
->	O
nunwind_handlers	int
-	O
1	int
;	O
iter	int
>=	O
0	int
;	O
iter	int
--	O
)	O
if	O
(	O
e	pointer
->	O
unwind_handlers	pointer
[	O
iter	int
]	O
!=	O
NULL	O
&&	O
e	pointer
->	O
unwind_handlers	pointer
[	O
iter	int
]	O
->	O
handler	pointer
==	O
_h	pointer
&&	O
e	pointer
->	O
unwind_handlers	pointer
[	O
iter	int
]	O
->	O
arg	pointer
==	O
_a	pointer
)	O
{	O
free	function
(	O
e	pointer
->	O
unwind_handlers	pointer
[	O
iter	int
]	O
)	O
;	O
while	O
(	O
iter	int
<	O
e	pointer
->	O
nunwind_handlers	int
-	O
1	int
)	O
{	O
e	pointer
->	O
unwind_handlers	pointer
[	O
iter	int
]	O
=	O
e	pointer
->	O
unwind_handlers	pointer
[	O
iter	int
+	O
1	int
]	O
;	O
iter	int
++	O
;	O
}	O
e	pointer
->	O
unwind_handlers	pointer
[	O
e	pointer
->	O
nunwind_handlers	int
-	O
1	int
]	O
=	O
NULL	O
;	O
errno	O
=	O
0	int
;	O
return	O
0	int
;	O
}	O
errno	O
=	O
ENXIO	int
;	O
return	O
-	O
1	int
;	O
}	O
