static	O
char	O
*	O
default_domain	pointer
;	O
int	O
multiple_delivery	int
;	O
static	O
char	O
*	O
sender_address	pointer
=	O
NULL	O
;	O
static	O
void	O
set_sender_address	function
(	O
struct	O
mu_parseopt	struct
*	O
po	pointer
,	O
struct	O
mu_option	struct
*	O
opt	pointer
,	O
char	O
const	O
*	O
arg	pointer
)	O
{	O
if	O
(	O
sender_address	pointer
!=	O
NULL	O
)	O
{	O
mu_parseopt_error	function
(	O
po	pointer
,	O
_	O
(	O
"multiple --from options"	pointer
)	O
)	O
;	O
exit	function
(	O
po	pointer
->	O
po_exit_error	int
)	O
;	O
}	O
else	O
{	O
char	O
*	O
errmsg	pointer
;	O
int	O
rc	int
=	O
mu_str_to_c	function
(	O
arg	pointer
,	O
opt	pointer
->	O
opt_type	enum
,	O
opt	pointer
->	O
opt_ptr	pointer
,	O
&	O
errmsg	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_parseopt_error	function
(	O
po	pointer
,	O
_	O
(	O
"can't set sender address: %s"	pointer
)	O
,	O
errmsg	pointer
?	O
errmsg	pointer
:	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
exit	function
(	O
po	pointer
->	O
po_exit_error	int
)	O
;	O
}	O
}	O
}	O
struct	O
mu_cfg_param	struct
mda_deliver_cfg	array
[	O
]	O
=	O
{	O
{	O
"domain"	pointer
,	O
mu_c_string	int
,	O
&	O
default_domain	pointer
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"Default email domain"	pointer
)	O
}	O
,	O
{	O
"exit-multiple-delivery-success"	pointer
,	O
mu_c_bool	int
,	O
&	O
multiple_delivery	int
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"In case of multiple delivery, exit with code 0 if at least one "	pointer
"delivery succeeded."	pointer
)	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
struct	O
mu_option	struct
mda_deliver_options	array
[	O
]	O
=	O
{	O
MU_OPTION_GROUP	O
(	O
N_	O
(	O
"Delivery options"	pointer
)	O
)	O
,	O
{	O
"from"	pointer
,	O
'f'	O
,	O
N_	O
(	O
"EMAIL"	pointer
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"specify the sender's name"	pointer
)	O
,	O
mu_c_string	int
,	O
&	O
sender_address	pointer
,	O
set_sender_address	function
}	O
,	O
{	O
NULL	O
,	O
'r'	O
,	O
NULL	O
,	O
MU_OPTION_ALIAS	int
}	O
,	O
MU_OPTION_END	O
}	O
;	O
static	O
mu_message_t	pointer
make_tmp	function
(	O
const	O
char	O
*	O
from	pointer
)	O
{	O
int	O
rc	int
;	O
mu_stream_t	pointer
in	pointer
,	O
out	pointer
;	O
char	O
*	O
buf	pointer
=	O
NULL	O
;	O
size_t	long
size	long
=	O
0	int
,	O
n	pointer
;	O
mu_message_t	pointer
mesg	pointer
;	O
rc	int
=	O
mu_stdio_stream_create	function
(	O
&	O
in	pointer
,	O
MU_STDIN_FD	int
,	O
MU_STREAM_READ	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_stdio_stream_create"	pointer
,	O
"MU_STDIN_FD"	pointer
,	O
rc	int
)	O
;	O
exit	function
(	O
EX_TEMPFAIL	int
)	O
;	O
}	O
rc	int
=	O
mu_temp_file_stream_create	function
(	O
&	O
out	pointer
,	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mda_error	function
(	O
_	O
(	O
"unable to open temporary file: %s"	pointer
)	O
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
exit	function
(	O
EX_TEMPFAIL	int
)	O
;	O
}	O
rc	int
=	O
mu_stream_getline	function
(	O
in	pointer
,	O
&	O
buf	pointer
,	O
&	O
size	long
,	O
&	O
n	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mda_error	function
(	O
_	O
(	O
"read error: %s"	pointer
)	O
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
mu_stream_destroy	function
(	O
&	O
in	pointer
)	O
;	O
mu_stream_destroy	function
(	O
&	O
out	pointer
)	O
;	O
exit	function
(	O
EX_TEMPFAIL	int
)	O
;	O
}	O
if	O
(	O
n	pointer
==	O
0	int
)	O
{	O
mda_error	function
(	O
_	O
(	O
"unexpected EOF on input"	pointer
)	O
)	O
;	O
mu_stream_destroy	function
(	O
&	O
in	pointer
)	O
;	O
mu_stream_destroy	function
(	O
&	O
out	pointer
)	O
;	O
exit	function
(	O
EX_TEMPFAIL	int
)	O
;	O
}	O
if	O
(	O
n	pointer
>=	O
5	int
&&	O
memcmp	function
(	O
buf	pointer
,	O
"From "	pointer
,	O
5	int
)	O
)	O
{	O
struct	O
mu_auth_data	struct
*	O
auth	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
from	pointer
)	O
{	O
auth	pointer
=	O
mu_get_auth_by_uid	function
(	O
getuid	function
(	O
)	O
)	O
;	O
if	O
(	O
auth	pointer
)	O
from	pointer
=	O
auth	pointer
->	O
name	pointer
;	O
}	O
if	O
(	O
from	pointer
)	O
{	O
time_t	long
t	long
;	O
struct	O
tm	struct
*	O
tm	struct
;	O
time	struct
(	O
&	O
t	long
)	O
;	O
tm	struct
=	O
gmtime	function
(	O
&	O
t	long
)	O
;	O
mu_stream_printf	function
(	O
out	pointer
,	O
"From %s "	pointer
,	O
from	pointer
)	O
;	O
mu_c_streamftime	function
(	O
out	pointer
,	O
"%c%n"	pointer
,	O
tm	struct
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
mda_error	function
(	O
_	O
(	O
"cannot determine sender address"	pointer
)	O
)	O
;	O
mu_stream_destroy	function
(	O
&	O
in	pointer
)	O
;	O
mu_stream_destroy	function
(	O
&	O
out	pointer
)	O
;	O
exit	function
(	O
EX_TEMPFAIL	int
)	O
;	O
}	O
if	O
(	O
auth	pointer
)	O
mu_auth_data_free	function
(	O
auth	pointer
)	O
;	O
}	O
mu_stream_write	function
(	O
out	pointer
,	O
buf	pointer
,	O
n	pointer
,	O
NULL	O
)	O
;	O
free	function
(	O
buf	pointer
)	O
;	O
rc	int
=	O
mu_stream_copy	function
(	O
out	pointer
,	O
in	pointer
,	O
0	int
,	O
NULL	O
)	O
;	O
mu_stream_destroy	function
(	O
&	O
in	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mda_error	function
(	O
_	O
(	O
"copy error: %s"	pointer
)	O
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
mu_stream_destroy	function
(	O
&	O
out	pointer
)	O
;	O
exit	function
(	O
EX_TEMPFAIL	int
)	O
;	O
}	O
rc	int
=	O
mu_stream_to_message	function
(	O
out	pointer
,	O
&	O
mesg	pointer
)	O
;	O
mu_stream_destroy	function
(	O
&	O
out	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mda_error	function
(	O
_	O
(	O
"error creating temporary message: %s"	pointer
)	O
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
exit	function
(	O
EX_TEMPFAIL	int
)	O
;	O
}	O
return	O
mesg	pointer
;	O
}	O
int	O
mda_run_delivery	function
(	O
mda_delivery_fn	pointer
delivery_fun	pointer
,	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
mu_message_t	pointer
mesg	pointer
=	O
make_tmp	function
(	O
sender_address	pointer
)	O
;	O
if	O
(	O
multiple_delivery	int
)	O
multiple_delivery	int
=	O
argc	long
>	O
1	int
;	O
for	O
(	O
;	O
*	O
argv	pointer
;	O
argv	pointer
++	O
)	O
{	O
delivery_fun	pointer
(	O
mesg	pointer
,	O
*	O
argv	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
multiple_delivery	int
)	O
exit_code	int
=	O
EX_OK	int
;	O
}	O
return	O
exit_code	int
;	O
}	O
static	O
int	O
deliver_to_mailbox	function
(	O
mu_mailbox_t	pointer
mbox	pointer
,	O
mu_message_t	pointer
msg	pointer
,	O
struct	O
mu_auth_data	struct
*	O
auth	pointer
,	O
char	O
*	O
*	O
errp	pointer
)	O
{	O
int	O
status	int
;	O
char	O
*	O
path	pointer
;	O
mu_url_t	pointer
url	pointer
=	O
NULL	O
;	O
mu_locker_t	pointer
lock	pointer
;	O
int	O
failed	int
=	O
0	int
;	O
int	O
exit_code	int
=	O
EX_OK	int
;	O
mu_mailbox_get_url	function
(	O
mbox	pointer
,	O
&	O
url	pointer
)	O
;	O
path	pointer
=	O
(	O
char	O
*	O
)	O
mu_url_to_string	function
(	O
url	pointer
)	O
;	O
status	int
=	O
mu_mailbox_open	function
(	O
mbox	pointer
,	O
MU_STREAM_APPEND	int
|	O
MU_STREAM_CREAT	int
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
{	O
mda_error	function
(	O
_	O
(	O
"cannot open mailbox %s: %s"	pointer
)	O
,	O
path	pointer
,	O
mu_strerror	function
(	O
status	int
)	O
)	O
;	O
return	O
EX_TEMPFAIL	int
;	O
}	O
mu_mailbox_get_locker	function
(	O
mbox	pointer
,	O
&	O
lock	pointer
)	O
;	O
if	O
(	O
lock	pointer
)	O
{	O
status	int
=	O
mu_locker_lock	function
(	O
lock	pointer
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mda_error	function
(	O
_	O
(	O
"cannot lock mailbox `%s': %s"	pointer
)	O
,	O
path	pointer
,	O
mu_strerror	function
(	O
status	int
)	O
)	O
;	O
return	O
EX_TEMPFAIL	int
;	O
}	O
}	O
if	O
(	O
auth	pointer
)	O
{	O
mu_off_t	long
n	pointer
;	O
size_t	long
msg_size	long
;	O
mu_off_t	long
mbsize	long
;	O
if	O
(	O
(	O
status	int
=	O
mu_mailbox_get_size	function
(	O
mbox	pointer
,	O
&	O
mbsize	long
)	O
)	O
)	O
{	O
mda_error	function
(	O
_	O
(	O
"cannot get size of mailbox %s: %s"	pointer
)	O
,	O
path	pointer
,	O
mu_strerror	function
(	O
status	int
)	O
)	O
;	O
if	O
(	O
status	int
==	O
ENOSYS	int
)	O
mbsize	long
=	O
0	int
;	O
else	O
return	O
EX_TEMPFAIL	int
;	O
}	O
switch	O
(	O
mda_check_quota	function
(	O
auth	pointer
,	O
mbsize	long
,	O
&	O
n	pointer
)	O
)	O
{	O
case	O
MQUOTA_EXCEEDED	int
:	O
mda_error	function
(	O
_	O
(	O
"%s: mailbox quota exceeded for this recipient"	pointer
)	O
,	O
auth	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
errp	pointer
)	O
mu_asprintf	function
(	O
errp	pointer
,	O
"%s: mailbox quota exceeded for this recipient"	pointer
,	O
auth	pointer
->	O
name	pointer
)	O
;	O
exit_code	int
=	O
EX_QUOTA	O
;	O
failed	int
++	O
;	O
break	O
;	O
case	O
MQUOTA_UNLIMITED	int
:	O
break	O
;	O
default	O
:	O
if	O
(	O
(	O
status	int
=	O
mu_message_size	function
(	O
msg	pointer
,	O
&	O
msg_size	long
)	O
)	O
)	O
{	O
mda_error	function
(	O
_	O
(	O
"cannot get message size (input message %s): %s"	pointer
)	O
,	O
path	pointer
,	O
mu_strerror	function
(	O
status	int
)	O
)	O
;	O
exit_code	int
=	O
EX_UNAVAILABLE	int
;	O
failed	int
++	O
;	O
}	O
else	O
if	O
(	O
msg_size	long
>	O
n	pointer
)	O
{	O
mda_error	function
(	O
_	O
(	O
"%s: message would exceed maximum mailbox size for "	pointer
"this recipient"	pointer
)	O
,	O
auth	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
errp	pointer
)	O
mu_asprintf	function
(	O
errp	pointer
,	O
"%s: message would exceed maximum mailbox size "	pointer
"for this recipient"	pointer
,	O
auth	pointer
->	O
name	pointer
)	O
;	O
exit_code	int
=	O
EX_QUOTA	O
;	O
failed	int
++	O
;	O
}	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
failed	int
)	O
{	O
status	int
=	O
mu_mailbox_append_message	function
(	O
mbox	pointer
,	O
msg	pointer
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mda_error	function
(	O
_	O
(	O
"error writing to mailbox %s: %s"	pointer
)	O
,	O
path	pointer
,	O
mu_strerror	function
(	O
status	int
)	O
)	O
;	O
failed	int
++	O
;	O
}	O
else	O
{	O
status	int
=	O
mu_mailbox_sync	function
(	O
mbox	pointer
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mda_error	function
(	O
_	O
(	O
"error flushing mailbox %s: %s"	pointer
)	O
,	O
path	pointer
,	O
mu_strerror	function
(	O
status	int
)	O
)	O
;	O
failed	int
++	O
;	O
}	O
}	O
}	O
mu_mailbox_close	function
(	O
mbox	pointer
)	O
;	O
mu_locker_unlock	function
(	O
lock	pointer
)	O
;	O
return	O
failed	int
?	O
exit_code	int
:	O
0	int
;	O
}	O
static	O
int	O
is_remote_url	function
(	O
mu_url_t	pointer
url	pointer
)	O
{	O
int	O
rc	int
,	O
res	pointer
;	O
if	O
(	O
!	O
url	pointer
)	O
return	O
0	int
;	O
rc	int
=	O
mu_registrar_test_local_url	function
(	O
url	pointer
,	O
&	O
res	pointer
)	O
;	O
return	O
rc	int
==	O
0	int
&&	O
res	pointer
==	O
0	int
;	O
}	O
static	O
int	O
do_delivery	function
(	O
mu_url_t	pointer
url	pointer
,	O
mu_message_t	pointer
msg	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
char	O
*	O
*	O
errp	pointer
)	O
{	O
struct	O
mu_auth_data	struct
*	O
auth	pointer
=	O
NULL	O
;	O
mu_mailbox_t	pointer
mbox	pointer
;	O
int	O
status	int
;	O
mu_set_user_email_domain	function
(	O
default_domain	pointer
)	O
;	O
if	O
(	O
name	pointer
&&	O
!	O
is_remote_url	function
(	O
url	pointer
)	O
)	O
{	O
auth	pointer
=	O
mu_get_auth_by_name	function
(	O
name	pointer
)	O
;	O
if	O
(	O
!	O
auth	pointer
)	O
{	O
mda_error	function
(	O
_	O
(	O
"%s: no such user"	pointer
)	O
,	O
name	pointer
)	O
;	O
if	O
(	O
errp	pointer
)	O
mu_asprintf	function
(	O
errp	pointer
,	O
"%s: no such user"	pointer
,	O
name	pointer
)	O
;	O
exit_code	int
=	O
EX_NOUSER	int
;	O
return	O
EX_NOUSER	int
;	O
}	O
status	int
=	O
mu_set_user_email	function
(	O
name	pointer
)	O
;	O
if	O
(	O
status	int
)	O
mu_error	function
(	O
_	O
(	O
"%s: invalid email: %s"	pointer
)	O
,	O
name	pointer
,	O
mu_strerror	function
(	O
status	int
)	O
)	O
;	O
if	O
(	O
getuid	function
(	O
)	O
)	O
auth	pointer
->	O
change_uid	int
=	O
0	int
;	O
switch	O
(	O
mda_filter_message	function
(	O
msg	pointer
,	O
auth	pointer
)	O
)	O
{	O
case	O
MDA_FILTER_OK	int
:	O
break	O
;	O
case	O
MDA_FILTER_FILTERED	int
:	O
exit_code	int
=	O
EX_OK	int
;	O
mu_auth_data_free	function
(	O
auth	pointer
)	O
;	O
return	O
0	int
;	O
case	O
MDA_FILTER_FAILURE	int
:	O
return	O
exit_code	int
=	O
EX_TEMPFAIL	int
;	O
}	O
switch	O
(	O
mda_forward	function
(	O
msg	pointer
,	O
auth	pointer
)	O
)	O
{	O
case	O
mda_forward_none	int
:	O
case	O
mda_forward_metoo	int
:	O
break	O
;	O
case	O
mda_forward_ok	int
:	O
mu_auth_data_free	function
(	O
auth	pointer
)	O
;	O
return	O
0	int
;	O
case	O
mda_forward_error	int
:	O
mu_auth_data_free	function
(	O
auth	pointer
)	O
;	O
return	O
exit_code	int
=	O
EX_TEMPFAIL	int
;	O
}	O
}	O
else	O
mu_set_user_email	function
(	O
NULL	O
)	O
;	O
if	O
(	O
!	O
url	pointer
)	O
{	O
status	int
=	O
mu_url_create	function
(	O
&	O
url	pointer
,	O
auth	pointer
->	O
mailbox	pointer
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mda_error	function
(	O
_	O
(	O
"cannot create URL for %s: %s"	pointer
)	O
,	O
auth	pointer
->	O
mailbox	pointer
,	O
mu_strerror	function
(	O
status	int
)	O
)	O
;	O
return	O
exit_code	int
=	O
EX_UNAVAILABLE	int
;	O
}	O
}	O
status	int
=	O
mu_mailbox_create_from_url	function
(	O
&	O
mbox	pointer
,	O
url	pointer
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mda_error	function
(	O
_	O
(	O
"cannot open mailbox %s: %s"	pointer
)	O
,	O
mu_url_to_string	function
(	O
url	pointer
)	O
,	O
mu_strerror	function
(	O
status	int
)	O
)	O
;	O
mu_url_destroy	function
(	O
&	O
url	pointer
)	O
;	O
mu_auth_data_free	function
(	O
auth	pointer
)	O
;	O
return	O
EX_TEMPFAIL	int
;	O
}	O
status	int
=	O
mu_mailbox_set_notify	function
(	O
mbox	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
status	int
)	O
mu_error	function
(	O
_	O
(	O
"failed to set notification on %s: %s"	pointer
)	O
,	O
mu_url_to_string	function
(	O
url	pointer
)	O
,	O
mu_strerror	function
(	O
status	int
)	O
)	O
;	O
if	O
(	O
mda_switch_user_id	function
(	O
auth	pointer
,	O
1	int
)	O
)	O
return	O
EX_TEMPFAIL	int
;	O
status	int
=	O
deliver_to_mailbox	function
(	O
mbox	pointer
,	O
msg	pointer
,	O
auth	pointer
,	O
errp	pointer
)	O
;	O
if	O
(	O
mda_switch_user_id	function
(	O
auth	pointer
,	O
0	int
)	O
)	O
return	O
EX_TEMPFAIL	int
;	O
mu_auth_data_free	function
(	O
auth	pointer
)	O
;	O
mu_mailbox_destroy	function
(	O
&	O
mbox	pointer
)	O
;	O
return	O
status	int
;	O
}	O
int	O
mda_deliver_to_url	function
(	O
mu_message_t	pointer
msg	pointer
,	O
char	O
*	O
dest_id	pointer
,	O
char	O
*	O
*	O
errp	pointer
)	O
{	O
int	O
status	int
;	O
const	O
char	O
*	O
name	pointer
;	O
mu_url_t	pointer
url	pointer
=	O
NULL	O
;	O
status	int
=	O
mu_url_create	function
(	O
&	O
url	pointer
,	O
dest_id	pointer
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mda_error	function
(	O
_	O
(	O
"%s: cannot create url: %s"	pointer
)	O
,	O
dest_id	pointer
,	O
mu_strerror	function
(	O
status	int
)	O
)	O
;	O
return	O
EX_NOUSER	int
;	O
}	O
status	int
=	O
mu_url_sget_user	function
(	O
url	pointer
,	O
&	O
name	pointer
)	O
;	O
if	O
(	O
status	int
==	O
MU_ERR_NOENT	O
)	O
name	pointer
=	O
NULL	O
;	O
else	O
if	O
(	O
status	int
)	O
{	O
mda_error	function
(	O
_	O
(	O
"%s: cannot get user name from url: %s"	pointer
)	O
,	O
dest_id	pointer
,	O
mu_strerror	function
(	O
status	int
)	O
)	O
;	O
mu_url_destroy	function
(	O
&	O
url	pointer
)	O
;	O
return	O
EX_NOUSER	int
;	O
}	O
return	O
do_delivery	function
(	O
url	pointer
,	O
msg	pointer
,	O
name	pointer
,	O
errp	pointer
)	O
;	O
}	O
int	O
mda_deliver_to_user	function
(	O
mu_message_t	pointer
msg	pointer
,	O
char	O
*	O
dest_id	pointer
,	O
char	O
*	O
*	O
errp	pointer
)	O
{	O
return	O
do_delivery	function
(	O
NULL	O
,	O
msg	pointer
,	O
dest_id	pointer
,	O
errp	pointer
)	O
;	O
}	O
