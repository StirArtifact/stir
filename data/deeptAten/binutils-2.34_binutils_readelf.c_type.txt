typedef	O
struct	O
elf_section_list	struct
{	O
Elf_Internal_Shdr	struct
*	O
hdr	pointer
;	O
struct	O
elf_section_list	struct
*	O
next	pointer
;	O
}	O
elf_section_list	struct
;	O
typedef	O
unsigned	O
char	O
dump_type	char
;	O
struct	O
dump_list_entry	struct
{	O
char	O
*	O
name	pointer
;	O
dump_type	char
type	enum
;	O
struct	O
dump_list_entry	struct
*	O
next	pointer
;	O
}	O
;	O
typedef	O
struct	O
filedata	struct
{	O
const	O
char	O
*	O
file_name	pointer
;	O
FILE	struct
*	O
handle	pointer
;	O
bfd_size_type	long
file_size	long
;	O
Elf_Internal_Ehdr	struct
file_header	struct
;	O
Elf_Internal_Shdr	struct
*	O
section_headers	pointer
;	O
Elf_Internal_Phdr	struct
*	O
program_headers	pointer
;	O
char	O
*	O
string_table	pointer
;	O
unsigned	O
long	O
string_table_length	long
;	O
dump_type	char
*	O
dump_sects	pointer
;	O
unsigned	O
int	O
num_dump_sects	int
;	O
}	O
Filedata	struct
;	O
char	O
*	O
program_name	pointer
=	O
"readelf"	pointer
;	O
static	O
unsigned	O
long	O
archive_file_offset	long
;	O
static	O
unsigned	O
long	O
archive_file_size	long
;	O
static	O
unsigned	O
long	O
dynamic_addr	long
;	O
static	O
bfd_size_type	long
dynamic_size	long
;	O
static	O
size_t	long
dynamic_nent	long
;	O
static	O
char	O
*	O
dynamic_strings	pointer
;	O
static	O
unsigned	O
long	O
dynamic_strings_length	long
;	O
static	O
unsigned	O
long	O
num_dynamic_syms	long
;	O
static	O
Elf_Internal_Sym	struct
*	O
dynamic_symbols	pointer
;	O
static	O
Elf_Internal_Syminfo	struct
*	O
dynamic_syminfo	pointer
;	O
static	O
unsigned	O
long	O
dynamic_syminfo_offset	long
;	O
static	O
unsigned	O
int	O
dynamic_syminfo_nent	int
;	O
static	O
char	O
program_interpreter	array
[	O
PATH_MAX	int
]	O
;	O
static	O
bfd_vma	long
dynamic_info	array
[	O
DT_ENCODING	int
]	O
;	O
static	O
bfd_vma	long
dynamic_info_DT_GNU_HASH	long
;	O
static	O
bfd_vma	long
dynamic_info_DT_MIPS_XHASH	long
;	O
static	O
bfd_vma	long
version_info	array
[	O
16	int
]	O
;	O
static	O
Elf_Internal_Dyn	struct
*	O
dynamic_section	pointer
;	O
static	O
elf_section_list	struct
*	O
symtab_shndx_list	pointer
;	O
static	O
bfd_boolean	int
show_name	int
=	O
FALSE	int
;	O
static	O
bfd_boolean	int
do_dynamic	int
=	O
FALSE	int
;	O
static	O
bfd_boolean	int
do_syms	int
=	O
FALSE	int
;	O
static	O
bfd_boolean	int
do_dyn_syms	int
=	O
FALSE	int
;	O
static	O
bfd_boolean	int
do_reloc	int
=	O
FALSE	int
;	O
static	O
bfd_boolean	int
do_sections	int
=	O
FALSE	int
;	O
static	O
bfd_boolean	int
do_section_groups	int
=	O
FALSE	int
;	O
static	O
bfd_boolean	int
do_section_details	int
=	O
FALSE	int
;	O
static	O
bfd_boolean	int
do_segments	int
=	O
FALSE	int
;	O
static	O
bfd_boolean	int
do_unwind	int
=	O
FALSE	int
;	O
static	O
bfd_boolean	int
do_using_dynamic	int
=	O
FALSE	int
;	O
static	O
bfd_boolean	int
do_header	int
=	O
FALSE	int
;	O
static	O
bfd_boolean	int
do_dump	int
=	O
FALSE	int
;	O
static	O
bfd_boolean	int
do_version	int
=	O
FALSE	int
;	O
static	O
bfd_boolean	int
do_histogram	int
=	O
FALSE	int
;	O
static	O
bfd_boolean	int
do_debugging	int
=	O
FALSE	int
;	O
static	O
bfd_boolean	int
do_ctf	int
=	O
FALSE	int
;	O
static	O
bfd_boolean	int
do_arch	int
=	O
FALSE	int
;	O
static	O
bfd_boolean	int
do_notes	int
=	O
FALSE	int
;	O
static	O
bfd_boolean	int
do_archive_index	int
=	O
FALSE	int
;	O
static	O
bfd_boolean	int
is_32bit_elf	int
=	O
FALSE	int
;	O
static	O
bfd_boolean	int
decompress_dumps	int
=	O
FALSE	int
;	O
static	O
char	O
*	O
dump_ctf_parent_name	pointer
;	O
static	O
char	O
*	O
dump_ctf_symtab_name	pointer
;	O
static	O
char	O
*	O
dump_ctf_strtab_name	pointer
;	O
struct	O
group_list	struct
{	O
struct	O
group_list	struct
*	O
next	pointer
;	O
unsigned	O
int	O
section_index	int
;	O
}	O
;	O
struct	O
group	pointer
{	O
struct	O
group_list	struct
*	O
root	pointer
;	O
unsigned	O
int	O
group_index	int
;	O
}	O
;	O
static	O
size_t	long
group_count	long
;	O
static	O
struct	O
group	pointer
*	O
section_groups	pointer
;	O
static	O
struct	O
group	pointer
*	O
*	O
section_headers_groups	pointer
;	O
static	O
Filedata	struct
cmdline	struct
;	O
static	O
struct	O
dump_list_entry	struct
*	O
dump_sects_byname	pointer
;	O
typedef	O
enum	O
print_mode	enum
{	O
HEX	int
,	O
DEC	int
,	O
DEC_5	int
,	O
UNSIGNED	int
,	O
PREFIX_HEX	int
,	O
FULL_HEX	int
,	O
LONG_HEX	int
}	O
print_mode	enum
;	O
enum	O
versioned_symbol_info	enum
{	O
symbol_undefined	int
,	O
symbol_hidden	int
,	O
symbol_public	int
}	O
;	O
static	O
const	O
char	O
*	O
get_symbol_version_string	function
(	O
Filedata	struct
*	O
,	O
bfd_boolean	int
,	O
const	O
char	O
*	O
,	O
unsigned	O
long	O
,	O
unsigned	O
,	O
Elf_Internal_Sym	struct
*	O
,	O
enum	O
versioned_symbol_info	enum
*	O
,	O
unsigned	O
short	O
*	O
)	O
;	O
static	O
const	O
char	O
*	O
bfd_vmatoa	function
(	O
char	O
*	O
fmtch	pointer
,	O
bfd_vma	long
value	int
)	O
{	O
static	O
int	O
buf_pos	int
=	O
0	int
;	O
static	O
struct	O
bfd_vmatoa_buf	struct
{	O
char	O
place	array
[	O
64	int
]	O
;	O
}	O
buf	pointer
[	O
4	int
]	O
;	O
char	O
*	O
ret	pointer
;	O
char	O
fmt	pointer
[	O
32	int
]	O
;	O
ret	pointer
=	O
buf	pointer
[	O
buf_pos	int
++	O
]	O
.	O
place	array
;	O
buf_pos	int
%=	O
ARRAY_SIZE	O
(	O
buf	pointer
)	O
;	O
sprintf	function
(	O
fmt	pointer
,	O
"%%%s%s"	pointer
,	O
BFD_VMA_FMT	pointer
,	O
fmtch	pointer
)	O
;	O
snprintf	function
(	O
ret	pointer
,	O
sizeof	O
(	O
buf	pointer
[	O
0	int
]	O
.	O
place	array
)	O
,	O
fmt	pointer
,	O
value	int
)	O
;	O
return	O
ret	pointer
;	O
}	O
static	O
void	O
*	O
get_data	function
(	O
void	O
*	O
var	pointer
,	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
long	O
offset	long
,	O
bfd_size_type	long
size	int
,	O
bfd_size_type	long
nmemb	long
,	O
const	O
char	O
*	O
reason	pointer
)	O
{	O
void	O
*	O
mvar	pointer
;	O
bfd_size_type	long
amt	long
=	O
size	int
*	O
nmemb	long
;	O
if	O
(	O
size	int
==	O
0	int
||	O
nmemb	long
==	O
0	int
)	O
return	O
NULL	O
;	O
if	O
(	O
(	O
size_t	long
)	O
size	int
!=	O
size	int
||	O
(	O
size_t	long
)	O
nmemb	long
!=	O
nmemb	long
||	O
(	O
size_t	long
)	O
amt	long
!=	O
amt	long
)	O
{	O
if	O
(	O
reason	pointer
)	O
error	function
(	O
_	O
(	O
"Size truncation prevents reading %s"	pointer
" elements of size %s for %s\n"	pointer
)	O
,	O
bfd_vmatoa	function
(	O
"u"	pointer
,	O
nmemb	long
)	O
,	O
bfd_vmatoa	function
(	O
"u"	pointer
,	O
size	int
)	O
,	O
reason	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
amt	long
/	O
size	int
!=	O
nmemb	long
||	O
(	O
size_t	long
)	O
amt	long
+	O
1	int
==	O
0	int
)	O
{	O
if	O
(	O
reason	pointer
)	O
error	function
(	O
_	O
(	O
"Size overflow prevents reading %s"	pointer
" elements of size %s for %s\n"	pointer
)	O
,	O
bfd_vmatoa	function
(	O
"u"	pointer
,	O
nmemb	long
)	O
,	O
bfd_vmatoa	function
(	O
"u"	pointer
,	O
size	int
)	O
,	O
reason	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
archive_file_offset	long
>	O
filedata	struct
->	O
file_size	long
||	O
offset	long
>	O
filedata	struct
->	O
file_size	long
-	O
archive_file_offset	long
||	O
amt	long
>	O
filedata	struct
->	O
file_size	long
-	O
archive_file_offset	long
-	O
offset	long
)	O
{	O
if	O
(	O
reason	pointer
)	O
error	function
(	O
_	O
(	O
"Reading %s bytes extends past end of file for %s\n"	pointer
)	O
,	O
bfd_vmatoa	function
(	O
"u"	pointer
,	O
amt	long
)	O
,	O
reason	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
fseek	function
(	O
filedata	struct
->	O
handle	pointer
,	O
archive_file_offset	long
+	O
offset	long
,	O
SEEK_SET	int
)	O
)	O
{	O
if	O
(	O
reason	pointer
)	O
error	function
(	O
_	O
(	O
"Unable to seek to 0x%lx for %s\n"	pointer
)	O
,	O
archive_file_offset	long
+	O
offset	long
,	O
reason	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
mvar	pointer
=	O
var	pointer
;	O
if	O
(	O
mvar	pointer
==	O
NULL	O
)	O
{	O
mvar	pointer
=	O
malloc	function
(	O
(	O
size_t	long
)	O
amt	long
+	O
1	int
)	O
;	O
if	O
(	O
mvar	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
reason	pointer
)	O
error	function
(	O
_	O
(	O
"Out of memory allocating %s bytes for %s\n"	pointer
)	O
,	O
bfd_vmatoa	function
(	O
"u"	pointer
,	O
amt	long
)	O
,	O
reason	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
(	O
(	O
char	O
*	O
)	O
mvar	pointer
)	O
[	O
amt	long
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
fread	function
(	O
mvar	pointer
,	O
(	O
size_t	long
)	O
size	int
,	O
(	O
size_t	long
)	O
nmemb	long
,	O
filedata	struct
->	O
handle	pointer
)	O
!=	O
nmemb	long
)	O
{	O
if	O
(	O
reason	pointer
)	O
error	function
(	O
_	O
(	O
"Unable to read in %s bytes of %s\n"	pointer
)	O
,	O
bfd_vmatoa	function
(	O
"u"	pointer
,	O
amt	long
)	O
,	O
reason	pointer
)	O
;	O
if	O
(	O
mvar	pointer
!=	O
var	pointer
)	O
free	function
(	O
mvar	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
mvar	pointer
;	O
}	O
static	O
unsigned	O
int	O
print_vma	function
(	O
bfd_vma	long
vma	long
,	O
print_mode	enum
mode	pointer
)	O
{	O
unsigned	O
int	O
nc	int
=	O
0	int
;	O
switch	O
(	O
mode	pointer
)	O
{	O
case	O
FULL_HEX	int
:	O
nc	int
=	O
printf	function
(	O
"0x"	pointer
)	O
;	O
case	O
LONG_HEX	int
:	O
if	O
(	O
is_32bit_elf	int
)	O
return	O
nc	int
+	O
printf	function
(	O
"%8.8"	pointer
BFD_VMA_FMT	pointer
"x"	pointer
,	O
vma	long
)	O
;	O
printf_vma	O
(	O
vma	long
)	O
;	O
return	O
nc	int
+	O
16	int
;	O
case	O
DEC_5	int
:	O
if	O
(	O
vma	long
<=	O
99999	int
)	O
return	O
printf	function
(	O
"%5"	pointer
BFD_VMA_FMT	pointer
"d"	pointer
,	O
vma	long
)	O
;	O
case	O
PREFIX_HEX	int
:	O
nc	int
=	O
printf	function
(	O
"0x"	pointer
)	O
;	O
case	O
HEX	int
:	O
return	O
nc	int
+	O
printf	function
(	O
"%"	pointer
BFD_VMA_FMT	pointer
"x"	pointer
,	O
vma	long
)	O
;	O
case	O
DEC	int
:	O
return	O
printf	function
(	O
"%"	pointer
BFD_VMA_FMT	pointer
"d"	pointer
,	O
vma	long
)	O
;	O
case	O
UNSIGNED	int
:	O
return	O
printf	function
(	O
"%"	pointer
BFD_VMA_FMT	pointer
"u"	pointer
,	O
vma	long
)	O
;	O
default	O
:	O
return	O
0	int
;	O
}	O
}	O
static	O
unsigned	O
int	O
print_symbol	function
(	O
signed	O
int	O
width	int
,	O
const	O
char	O
*	O
symbol	pointer
)	O
{	O
bfd_boolean	int
extra_padding	int
=	O
FALSE	int
;	O
signed	O
int	O
num_printed	int
=	O
0	int
;	O
mbstate_t	struct
state	pointer
;	O
unsigned	O
int	O
width_remaining	int
;	O
if	O
(	O
width	int
<	O
0	int
)	O
{	O
width	int
=	O
-	O
width	int
;	O
extra_padding	int
=	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
width	int
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
do_wide	int
)	O
width_remaining	int
=	O
INT_MAX	O
;	O
else	O
width_remaining	int
=	O
width	int
;	O
memset	function
(	O
&	O
state	pointer
,	O
0	int
,	O
sizeof	O
(	O
state	pointer
)	O
)	O
;	O
while	O
(	O
width_remaining	int
)	O
{	O
size_t	long
n	long
;	O
const	O
char	O
c	int
=	O
*	O
symbol	pointer
++	O
;	O
if	O
(	O
c	int
==	O
0	int
)	O
break	O
;	O
if	O
(	O
ISCNTRL	O
(	O
c	int
)	O
)	O
{	O
if	O
(	O
width_remaining	int
<	O
2	int
)	O
break	O
;	O
printf	function
(	O
"^%c"	pointer
,	O
c	int
+	O
0x40	int
)	O
;	O
width_remaining	int
-=	O
2	int
;	O
num_printed	int
+=	O
2	int
;	O
}	O
else	O
if	O
(	O
ISPRINT	O
(	O
c	int
)	O
)	O
{	O
putchar	function
(	O
c	int
)	O
;	O
width_remaining	int
--	O
;	O
num_printed	int
++	O
;	O
}	O
else	O
{	O
wchar_t	int
w	int
;	O
printf	function
(	O
"%.1s"	pointer
,	O
symbol	pointer
-	O
1	int
)	O
;	O
width_remaining	int
--	O
;	O
num_printed	int
++	O
;	O
n	long
=	O
mbrtowc	function
(	O
&	O
w	int
,	O
symbol	pointer
-	O
1	int
,	O
MB_CUR_MAX	O
,	O
&	O
state	pointer
)	O
;	O
if	O
(	O
n	long
!=	O
(	O
size_t	long
)	O
-	O
1	int
&&	O
n	long
!=	O
(	O
size_t	long
)	O
-	O
2	int
&&	O
n	long
>	O
0	int
)	O
symbol	pointer
+=	O
(	O
n	long
-	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
extra_padding	int
&&	O
num_printed	int
<	O
width	int
)	O
{	O
printf	function
(	O
"%-*s"	pointer
,	O
width	int
-	O
num_printed	int
,	O
" "	pointer
)	O
;	O
num_printed	int
=	O
width	int
;	O
}	O
return	O
num_printed	int
;	O
}	O
static	O
const	O
char	O
*	O
printable_section_name	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
const	O
Elf_Internal_Shdr	struct
*	O
sec	pointer
)	O
{	O
static	O
char	O
sec_name_buf	array
[	O
MAX_PRINT_SEC_NAME_LEN	int
+	O
1	int
]	O
;	O
const	O
char	O
*	O
name	pointer
=	O
SECTION_NAME	O
(	O
sec	pointer
)	O
;	O
char	O
*	O
buf	pointer
=	O
sec_name_buf	array
;	O
char	O
c	int
;	O
unsigned	O
int	O
remaining	int
=	O
MAX_PRINT_SEC_NAME_LEN	int
;	O
while	O
(	O
(	O
c	int
=	O
*	O
name	pointer
++	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
ISCNTRL	O
(	O
c	int
)	O
)	O
{	O
if	O
(	O
remaining	int
<	O
2	int
)	O
break	O
;	O
*	O
buf	pointer
++	O
=	O
'^'	O
;	O
*	O
buf	pointer
++	O
=	O
c	int
+	O
0x40	int
;	O
remaining	int
-=	O
2	int
;	O
}	O
else	O
if	O
(	O
ISPRINT	O
(	O
c	int
)	O
)	O
{	O
*	O
buf	pointer
++	O
=	O
c	int
;	O
remaining	int
-=	O
1	int
;	O
}	O
else	O
{	O
static	O
char	O
hex	array
[	O
17	int
]	O
=	O
"0123456789ABCDEF"	pointer
;	O
if	O
(	O
remaining	int
<	O
4	int
)	O
break	O
;	O
*	O
buf	pointer
++	O
=	O
'<'	O
;	O
*	O
buf	pointer
++	O
=	O
hex	array
[	O
(	O
c	int
&	O
0xf0	int
)	O
>>	O
4	int
]	O
;	O
*	O
buf	pointer
++	O
=	O
hex	array
[	O
c	int
&	O
0x0f	int
]	O
;	O
*	O
buf	pointer
++	O
=	O
'>'	O
;	O
remaining	int
-=	O
4	int
;	O
}	O
if	O
(	O
remaining	int
==	O
0	int
)	O
break	O
;	O
}	O
*	O
buf	pointer
=	O
0	int
;	O
return	O
sec_name_buf	array
;	O
}	O
static	O
const	O
char	O
*	O
printable_section_name_from_index	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
long	O
ndx	long
)	O
{	O
if	O
(	O
ndx	long
>=	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
)	O
return	O
_	O
(	O
"<corrupt>"	pointer
)	O
;	O
return	O
printable_section_name	function
(	O
filedata	struct
,	O
filedata	struct
->	O
section_headers	pointer
+	O
ndx	long
)	O
;	O
}	O
static	O
Elf_Internal_Shdr	struct
*	O
find_section	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
if	O
(	O
filedata	struct
->	O
section_headers	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
;	O
i	pointer
++	O
)	O
if	O
(	O
streq	O
(	O
SECTION_NAME	O
(	O
filedata	struct
->	O
section_headers	pointer
+	O
i	pointer
)	O
,	O
name	pointer
)	O
)	O
return	O
filedata	struct
->	O
section_headers	pointer
+	O
i	pointer
;	O
return	O
NULL	O
;	O
}	O
static	O
Elf_Internal_Shdr	struct
*	O
find_section_by_address	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
bfd_vma	long
addr	pointer
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
if	O
(	O
filedata	struct
->	O
section_headers	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
;	O
i	pointer
++	O
)	O
{	O
Elf_Internal_Shdr	struct
*	O
sec	pointer
=	O
filedata	struct
->	O
section_headers	pointer
+	O
i	pointer
;	O
if	O
(	O
addr	pointer
>=	O
sec	pointer
->	O
sh_addr	array
&&	O
addr	pointer
<	O
sec	pointer
->	O
sh_addr	array
+	O
sec	pointer
->	O
sh_size	array
)	O
return	O
sec	pointer
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
Elf_Internal_Shdr	struct
*	O
find_section_by_type	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
int	O
type	enum
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
if	O
(	O
filedata	struct
->	O
section_headers	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
;	O
i	pointer
++	O
)	O
{	O
Elf_Internal_Shdr	struct
*	O
sec	pointer
=	O
filedata	struct
->	O
section_headers	pointer
+	O
i	pointer
;	O
if	O
(	O
sec	pointer
->	O
sh_type	array
==	O
type	enum
)	O
return	O
sec	pointer
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
Elf_Internal_Shdr	struct
*	O
find_section_in_set	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
const	O
char	O
*	O
name	pointer
,	O
unsigned	O
int	O
*	O
set	pointer
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
if	O
(	O
filedata	struct
->	O
section_headers	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
set	pointer
!=	O
NULL	O
)	O
{	O
while	O
(	O
(	O
i	pointer
=	O
*	O
set	pointer
++	O
)	O
>	O
0	int
)	O
{	O
if	O
(	O
i	pointer
>=	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
)	O
continue	O
;	O
if	O
(	O
streq	O
(	O
SECTION_NAME	O
(	O
filedata	struct
->	O
section_headers	pointer
+	O
i	pointer
)	O
,	O
name	pointer
)	O
)	O
return	O
filedata	struct
->	O
section_headers	pointer
+	O
i	pointer
;	O
}	O
}	O
return	O
find_section	function
(	O
filedata	struct
,	O
name	pointer
)	O
;	O
}	O
static	O
inline	O
bfd_boolean	int
is_ia64_vms	function
(	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
return	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_IA_64	int
&&	O
filedata	struct
->	O
file_header	struct
.	O
e_ident	array
[	O
EI_OSABI	int
]	O
==	O
ELFOSABI_OPENVMS	int
;	O
}	O
static	O
bfd_boolean	int
guess_is_rela	function
(	O
unsigned	O
int	O
e_machine	array
)	O
{	O
switch	O
(	O
e_machine	array
)	O
{	O
case	O
EM_386	int
:	O
case	O
EM_IAMCU	int
:	O
case	O
EM_960	int
:	O
case	O
EM_ARM	int
:	O
case	O
EM_D10V	int
:	O
case	O
EM_CYGNUS_D10V	int
:	O
case	O
EM_DLX	int
:	O
case	O
EM_MIPS	int
:	O
case	O
EM_MIPS_RS3_LE	int
:	O
case	O
EM_CYGNUS_M32R	int
:	O
case	O
EM_SCORE	int
:	O
case	O
EM_XGATE	int
:	O
case	O
EM_NFP	int
:	O
case	O
EM_BPF	int
:	O
return	O
FALSE	int
;	O
case	O
EM_68K	int
:	O
case	O
EM_860	int
:	O
case	O
EM_AARCH64	int
:	O
case	O
EM_ADAPTEVA_EPIPHANY	int
:	O
case	O
EM_ALPHA	int
:	O
case	O
EM_ALTERA_NIOS2	int
:	O
case	O
EM_ARC	int
:	O
case	O
EM_ARC_COMPACT	int
:	O
case	O
EM_ARC_COMPACT2	int
:	O
case	O
EM_AVR	int
:	O
case	O
EM_AVR_OLD	int
:	O
case	O
EM_BLACKFIN	int
:	O
case	O
EM_CR16	int
:	O
case	O
EM_CRIS	int
:	O
case	O
EM_CRX	int
:	O
case	O
EM_CSKY	int
:	O
case	O
EM_D30V	int
:	O
case	O
EM_CYGNUS_D30V	int
:	O
case	O
EM_FR30	int
:	O
case	O
EM_FT32	int
:	O
case	O
EM_CYGNUS_FR30	int
:	O
case	O
EM_CYGNUS_FRV	int
:	O
case	O
EM_H8S	int
:	O
case	O
EM_H8_300	int
:	O
case	O
EM_H8_300H	int
:	O
case	O
EM_IA_64	int
:	O
case	O
EM_IP2K	int
:	O
case	O
EM_IP2K_OLD	int
:	O
case	O
EM_IQ2000	int
:	O
case	O
EM_LATTICEMICO32	int
:	O
case	O
EM_M32C_OLD	int
:	O
case	O
EM_M32C	int
:	O
case	O
EM_M32R	int
:	O
case	O
EM_MCORE	int
:	O
case	O
EM_CYGNUS_MEP	int
:	O
case	O
EM_METAG	int
:	O
case	O
EM_MMIX	int
:	O
case	O
EM_MN10200	int
:	O
case	O
EM_CYGNUS_MN10200	int
:	O
case	O
EM_MN10300	int
:	O
case	O
EM_CYGNUS_MN10300	int
:	O
case	O
EM_MOXIE	int
:	O
case	O
EM_MSP430	int
:	O
case	O
EM_MSP430_OLD	int
:	O
case	O
EM_MT	int
:	O
case	O
EM_NDS32	int
:	O
case	O
EM_NIOS32	int
:	O
case	O
EM_OR1K	int
:	O
case	O
EM_PPC64	int
:	O
case	O
EM_PPC	int
:	O
case	O
EM_TI_PRU	int
:	O
case	O
EM_RISCV	int
:	O
case	O
EM_RL78	int
:	O
case	O
EM_RX	int
:	O
case	O
EM_S390	int
:	O
case	O
EM_S390_OLD	int
:	O
case	O
EM_SH	int
:	O
case	O
EM_SPARC	int
:	O
case	O
EM_SPARC32PLUS	int
:	O
case	O
EM_SPARCV9	int
:	O
case	O
EM_SPU	int
:	O
case	O
EM_TI_C6000	int
:	O
case	O
EM_TILEGX	int
:	O
case	O
EM_TILEPRO	int
:	O
case	O
EM_V800	int
:	O
case	O
EM_V850	int
:	O
case	O
EM_CYGNUS_V850	int
:	O
case	O
EM_VAX	int
:	O
case	O
EM_VISIUM	int
:	O
case	O
EM_X86_64	int
:	O
case	O
EM_L1OM	int
:	O
case	O
EM_K1OM	int
:	O
case	O
EM_XSTORMY16	int
:	O
case	O
EM_XTENSA	int
:	O
case	O
EM_XTENSA_OLD	int
:	O
case	O
EM_MICROBLAZE	int
:	O
case	O
EM_MICROBLAZE_OLD	int
:	O
case	O
EM_WEBASSEMBLY	int
:	O
return	O
TRUE	int
;	O
case	O
EM_68HC05	int
:	O
case	O
EM_68HC08	int
:	O
case	O
EM_68HC11	int
:	O
case	O
EM_68HC16	int
:	O
case	O
EM_FX66	int
:	O
case	O
EM_ME16	int
:	O
case	O
EM_MMA	int
:	O
case	O
EM_NCPU	int
:	O
case	O
EM_NDR1	int
:	O
case	O
EM_PCP	int
:	O
case	O
EM_ST100	int
:	O
case	O
EM_ST19	int
:	O
case	O
EM_ST7	int
:	O
case	O
EM_ST9PLUS	int
:	O
case	O
EM_STARCORE	int
:	O
case	O
EM_SVX	int
:	O
case	O
EM_TINYJ	int
:	O
default	O
:	O
warn	function
(	O
_	O
(	O
"Don't know about relocations on this machine architecture\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
static	O
bfd_boolean	int
slurp_rela_relocs	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
long	O
rel_offset	long
,	O
unsigned	O
long	O
rel_size	long
,	O
Elf_Internal_Rela	struct
*	O
*	O
relasp	pointer
,	O
unsigned	O
long	O
*	O
nrelasp	pointer
)	O
{	O
Elf_Internal_Rela	struct
*	O
relas	pointer
;	O
size_t	long
nrelas	long
;	O
unsigned	O
int	O
i	pointer
;	O
if	O
(	O
is_32bit_elf	int
)	O
{	O
Elf32_External_Rela	struct
*	O
erelas	pointer
;	O
erelas	pointer
=	O
(	O
Elf32_External_Rela	struct
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
rel_offset	long
,	O
1	int
,	O
rel_size	long
,	O
_	O
(	O
"32-bit relocation data"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
erelas	pointer
)	O
return	O
FALSE	int
;	O
nrelas	long
=	O
rel_size	long
/	O
sizeof	O
(	O
Elf32_External_Rela	struct
)	O
;	O
relas	pointer
=	O
(	O
Elf_Internal_Rela	struct
*	O
)	O
cmalloc	function
(	O
nrelas	long
,	O
sizeof	O
(	O
Elf_Internal_Rela	struct
)	O
)	O
;	O
if	O
(	O
relas	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
erelas	pointer
)	O
;	O
error	function
(	O
_	O
(	O
"out of memory parsing relocs\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
nrelas	long
;	O
i	pointer
++	O
)	O
{	O
relas	pointer
[	O
i	pointer
]	O
.	O
r_offset	array
=	O
BYTE_GET	O
(	O
erelas	pointer
[	O
i	pointer
]	O
.	O
r_offset	array
)	O
;	O
relas	pointer
[	O
i	pointer
]	O
.	O
r_info	array
=	O
BYTE_GET	O
(	O
erelas	pointer
[	O
i	pointer
]	O
.	O
r_info	array
)	O
;	O
relas	pointer
[	O
i	pointer
]	O
.	O
r_addend	array
=	O
BYTE_GET_SIGNED	O
(	O
erelas	pointer
[	O
i	pointer
]	O
.	O
r_addend	array
)	O
;	O
}	O
free	function
(	O
erelas	pointer
)	O
;	O
}	O
else	O
{	O
Elf64_External_Rela	struct
*	O
erelas	pointer
;	O
erelas	pointer
=	O
(	O
Elf64_External_Rela	struct
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
rel_offset	long
,	O
1	int
,	O
rel_size	long
,	O
_	O
(	O
"64-bit relocation data"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
erelas	pointer
)	O
return	O
FALSE	int
;	O
nrelas	long
=	O
rel_size	long
/	O
sizeof	O
(	O
Elf64_External_Rela	struct
)	O
;	O
relas	pointer
=	O
(	O
Elf_Internal_Rela	struct
*	O
)	O
cmalloc	function
(	O
nrelas	long
,	O
sizeof	O
(	O
Elf_Internal_Rela	struct
)	O
)	O
;	O
if	O
(	O
relas	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
erelas	pointer
)	O
;	O
error	function
(	O
_	O
(	O
"out of memory parsing relocs\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
nrelas	long
;	O
i	pointer
++	O
)	O
{	O
relas	pointer
[	O
i	pointer
]	O
.	O
r_offset	array
=	O
BYTE_GET	O
(	O
erelas	pointer
[	O
i	pointer
]	O
.	O
r_offset	array
)	O
;	O
relas	pointer
[	O
i	pointer
]	O
.	O
r_info	array
=	O
BYTE_GET	O
(	O
erelas	pointer
[	O
i	pointer
]	O
.	O
r_info	array
)	O
;	O
relas	pointer
[	O
i	pointer
]	O
.	O
r_addend	array
=	O
BYTE_GET_SIGNED	O
(	O
erelas	pointer
[	O
i	pointer
]	O
.	O
r_addend	array
)	O
;	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_MIPS	int
&&	O
filedata	struct
->	O
file_header	struct
.	O
e_ident	array
[	O
EI_DATA	int
]	O
!=	O
ELFDATA2MSB	int
)	O
{	O
bfd_vma	long
inf	long
=	O
relas	pointer
[	O
i	pointer
]	O
.	O
r_info	array
;	O
inf	long
=	O
(	O
(	O
(	O
inf	long
&	O
0xffffffff	int
)	O
<<	O
32	int
)	O
|	O
(	O
(	O
inf	long
>>	O
56	int
)	O
&	O
0xff	int
)	O
|	O
(	O
(	O
inf	long
>>	O
40	int
)	O
&	O
0xff00	int
)	O
|	O
(	O
(	O
inf	long
>>	O
24	int
)	O
&	O
0xff0000	int
)	O
|	O
(	O
(	O
inf	long
>>	O
8	int
)	O
&	O
0xff000000	int
)	O
)	O
;	O
relas	pointer
[	O
i	pointer
]	O
.	O
r_info	array
=	O
inf	long
;	O
}	O
}	O
free	function
(	O
erelas	pointer
)	O
;	O
}	O
*	O
relasp	pointer
=	O
relas	pointer
;	O
*	O
nrelasp	pointer
=	O
nrelas	long
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
slurp_rel_relocs	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
long	O
rel_offset	long
,	O
unsigned	O
long	O
rel_size	long
,	O
Elf_Internal_Rela	struct
*	O
*	O
relsp	pointer
,	O
unsigned	O
long	O
*	O
nrelsp	pointer
)	O
{	O
Elf_Internal_Rela	struct
*	O
rels	pointer
;	O
size_t	long
nrels	long
;	O
unsigned	O
int	O
i	pointer
;	O
if	O
(	O
is_32bit_elf	int
)	O
{	O
Elf32_External_Rel	struct
*	O
erels	pointer
;	O
erels	pointer
=	O
(	O
Elf32_External_Rel	struct
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
rel_offset	long
,	O
1	int
,	O
rel_size	long
,	O
_	O
(	O
"32-bit relocation data"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
erels	pointer
)	O
return	O
FALSE	int
;	O
nrels	long
=	O
rel_size	long
/	O
sizeof	O
(	O
Elf32_External_Rel	struct
)	O
;	O
rels	pointer
=	O
(	O
Elf_Internal_Rela	struct
*	O
)	O
cmalloc	function
(	O
nrels	long
,	O
sizeof	O
(	O
Elf_Internal_Rela	struct
)	O
)	O
;	O
if	O
(	O
rels	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
erels	pointer
)	O
;	O
error	function
(	O
_	O
(	O
"out of memory parsing relocs\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
nrels	long
;	O
i	pointer
++	O
)	O
{	O
rels	pointer
[	O
i	pointer
]	O
.	O
r_offset	array
=	O
BYTE_GET	O
(	O
erels	pointer
[	O
i	pointer
]	O
.	O
r_offset	array
)	O
;	O
rels	pointer
[	O
i	pointer
]	O
.	O
r_info	array
=	O
BYTE_GET	O
(	O
erels	pointer
[	O
i	pointer
]	O
.	O
r_info	array
)	O
;	O
rels	pointer
[	O
i	pointer
]	O
.	O
r_addend	array
=	O
0	int
;	O
}	O
free	function
(	O
erels	pointer
)	O
;	O
}	O
else	O
{	O
Elf64_External_Rel	struct
*	O
erels	pointer
;	O
erels	pointer
=	O
(	O
Elf64_External_Rel	struct
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
rel_offset	long
,	O
1	int
,	O
rel_size	long
,	O
_	O
(	O
"64-bit relocation data"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
erels	pointer
)	O
return	O
FALSE	int
;	O
nrels	long
=	O
rel_size	long
/	O
sizeof	O
(	O
Elf64_External_Rel	struct
)	O
;	O
rels	pointer
=	O
(	O
Elf_Internal_Rela	struct
*	O
)	O
cmalloc	function
(	O
nrels	long
,	O
sizeof	O
(	O
Elf_Internal_Rela	struct
)	O
)	O
;	O
if	O
(	O
rels	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
erels	pointer
)	O
;	O
error	function
(	O
_	O
(	O
"out of memory parsing relocs\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
nrels	long
;	O
i	pointer
++	O
)	O
{	O
rels	pointer
[	O
i	pointer
]	O
.	O
r_offset	array
=	O
BYTE_GET	O
(	O
erels	pointer
[	O
i	pointer
]	O
.	O
r_offset	array
)	O
;	O
rels	pointer
[	O
i	pointer
]	O
.	O
r_info	array
=	O
BYTE_GET	O
(	O
erels	pointer
[	O
i	pointer
]	O
.	O
r_info	array
)	O
;	O
rels	pointer
[	O
i	pointer
]	O
.	O
r_addend	array
=	O
0	int
;	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_MIPS	int
&&	O
filedata	struct
->	O
file_header	struct
.	O
e_ident	array
[	O
EI_DATA	int
]	O
!=	O
ELFDATA2MSB	int
)	O
{	O
bfd_vma	long
inf	long
=	O
rels	pointer
[	O
i	pointer
]	O
.	O
r_info	array
;	O
inf	long
=	O
(	O
(	O
(	O
inf	long
&	O
0xffffffff	int
)	O
<<	O
32	int
)	O
|	O
(	O
(	O
inf	long
>>	O
56	int
)	O
&	O
0xff	int
)	O
|	O
(	O
(	O
inf	long
>>	O
40	int
)	O
&	O
0xff00	int
)	O
|	O
(	O
(	O
inf	long
>>	O
24	int
)	O
&	O
0xff0000	int
)	O
|	O
(	O
(	O
inf	long
>>	O
8	int
)	O
&	O
0xff000000	int
)	O
)	O
;	O
rels	pointer
[	O
i	pointer
]	O
.	O
r_info	array
=	O
inf	long
;	O
}	O
}	O
free	function
(	O
erels	pointer
)	O
;	O
}	O
*	O
relsp	pointer
=	O
rels	pointer
;	O
*	O
nrelsp	pointer
=	O
nrels	long
;	O
return	O
TRUE	int
;	O
}	O
static	O
unsigned	O
int	O
get_reloc_type	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
bfd_vma	long
reloc_info	pointer
)	O
{	O
if	O
(	O
is_32bit_elf	int
)	O
return	O
ELF32_R_TYPE	O
(	O
reloc_info	pointer
)	O
;	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
case	O
EM_MIPS	int
:	O
return	O
ELF64_MIPS_R_TYPE	O
(	O
reloc_info	pointer
)	O
;	O
case	O
EM_SPARCV9	int
:	O
return	O
ELF64_R_TYPE_ID	O
(	O
reloc_info	pointer
)	O
;	O
default	O
:	O
return	O
ELF64_R_TYPE	O
(	O
reloc_info	pointer
)	O
;	O
}	O
}	O
static	O
bfd_vma	long
get_reloc_symindex	function
(	O
bfd_vma	long
reloc_info	pointer
)	O
{	O
return	O
is_32bit_elf	int
?	O
ELF32_R_SYM	O
(	O
reloc_info	pointer
)	O
:	O
ELF64_R_SYM	O
(	O
reloc_info	pointer
)	O
;	O
}	O
static	O
inline	O
bfd_boolean	int
uses_msp430x_relocs	function
(	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
return	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_MSP430	int
&&	O
(	O
(	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_flags	array
&	O
EF_MSP430_MACH	int
)	O
==	O
E_MSP430_MACH_MSP430X	int
)	O
||	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_ident	array
[	O
EI_OSABI	int
]	O
==	O
ELFOSABI_NONE	int
)	O
)	O
;	O
}	O
static	O
bfd_boolean	int
dump_relocations	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
long	O
rel_offset	long
,	O
unsigned	O
long	O
rel_size	long
,	O
Elf_Internal_Sym	struct
*	O
symtab	pointer
,	O
unsigned	O
long	O
nsyms	long
,	O
char	O
*	O
strtab	pointer
,	O
unsigned	O
long	O
strtablen	long
,	O
int	O
is_rela	int
,	O
bfd_boolean	int
is_dynsym	int
)	O
{	O
unsigned	O
long	O
i	pointer
;	O
Elf_Internal_Rela	struct
*	O
rels	pointer
;	O
bfd_boolean	int
res	int
=	O
TRUE	int
;	O
if	O
(	O
is_rela	int
==	O
UNKNOWN	O
)	O
is_rela	int
=	O
guess_is_rela	function
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
;	O
if	O
(	O
is_rela	int
)	O
{	O
if	O
(	O
!	O
slurp_rela_relocs	function
(	O
filedata	struct
,	O
rel_offset	long
,	O
rel_size	long
,	O
&	O
rels	pointer
,	O
&	O
rel_size	long
)	O
)	O
return	O
FALSE	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
slurp_rel_relocs	function
(	O
filedata	struct
,	O
rel_offset	long
,	O
rel_size	long
,	O
&	O
rels	pointer
,	O
&	O
rel_size	long
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
is_32bit_elf	int
)	O
{	O
if	O
(	O
is_rela	int
)	O
{	O
if	O
(	O
do_wide	int
)	O
printf	function
(	O
_	O
(	O
" Offset     Info    Type                Sym. Value  Symbol's Name + Addend\n"	pointer
)	O
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
" Offset     Info    Type            Sym.Value  Sym. Name + Addend\n"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
do_wide	int
)	O
printf	function
(	O
_	O
(	O
" Offset     Info    Type                Sym. Value  Symbol's Name\n"	pointer
)	O
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
" Offset     Info    Type            Sym.Value  Sym. Name\n"	pointer
)	O
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
is_rela	int
)	O
{	O
if	O
(	O
do_wide	int
)	O
printf	function
(	O
_	O
(	O
"    Offset             Info             Type               Symbol's Value  Symbol's Name + Addend\n"	pointer
)	O
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"  Offset          Info           Type           Sym. Value    Sym. Name + Addend\n"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
do_wide	int
)	O
printf	function
(	O
_	O
(	O
"    Offset             Info             Type               Symbol's Value  Symbol's Name\n"	pointer
)	O
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"  Offset          Info           Type           Sym. Value    Sym. Name\n"	pointer
)	O
)	O
;	O
}	O
}	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
rel_size	long
;	O
i	pointer
++	O
)	O
{	O
const	O
char	O
*	O
rtype	long
;	O
bfd_vma	long
offset	long
;	O
bfd_vma	long
inf	long
;	O
bfd_vma	long
symtab_index	long
;	O
bfd_vma	long
type	enum
;	O
offset	long
=	O
rels	pointer
[	O
i	pointer
]	O
.	O
r_offset	array
;	O
inf	long
=	O
rels	pointer
[	O
i	pointer
]	O
.	O
r_info	array
;	O
type	enum
=	O
get_reloc_type	function
(	O
filedata	struct
,	O
inf	long
)	O
;	O
symtab_index	long
=	O
get_reloc_symindex	function
(	O
inf	long
)	O
;	O
if	O
(	O
is_32bit_elf	int
)	O
{	O
printf	function
(	O
"%8.8lx  %8.8lx "	pointer
,	O
(	O
unsigned	O
long	O
)	O
offset	long
&	O
0xffffffff	int
,	O
(	O
unsigned	O
long	O
)	O
inf	long
&	O
0xffffffff	int
)	O
;	O
}	O
else	O
{	O
printf	function
(	O
do_wide	int
?	O
"%16.16lx  %16.16lx "	pointer
:	O
"%12.12lx  %12.12lx "	pointer
,	O
offset	long
,	O
inf	long
)	O
;	O
}	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
default	O
:	O
rtype	long
=	O
NULL	O
;	O
break	O
;	O
case	O
EM_AARCH64	int
:	O
rtype	long
=	O
elf_aarch64_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_M32R	int
:	O
case	O
EM_CYGNUS_M32R	int
:	O
rtype	long
=	O
elf_m32r_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_386	int
:	O
case	O
EM_IAMCU	int
:	O
rtype	long
=	O
elf_i386_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_68HC11	int
:	O
case	O
EM_68HC12	int
:	O
rtype	long
=	O
elf_m68hc11_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_S12Z	int
:	O
rtype	long
=	O
elf_s12z_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_68K	int
:	O
rtype	long
=	O
elf_m68k_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_960	int
:	O
rtype	long
=	O
elf_i960_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_AVR	int
:	O
case	O
EM_AVR_OLD	int
:	O
rtype	long
=	O
elf_avr_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_OLD_SPARCV9	int
:	O
case	O
EM_SPARC32PLUS	int
:	O
case	O
EM_SPARCV9	int
:	O
case	O
EM_SPARC	int
:	O
rtype	long
=	O
elf_sparc_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_SPU	int
:	O
rtype	long
=	O
elf_spu_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_V800	int
:	O
rtype	long
=	O
v800_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_V850	int
:	O
case	O
EM_CYGNUS_V850	int
:	O
rtype	long
=	O
v850_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_D10V	int
:	O
case	O
EM_CYGNUS_D10V	int
:	O
rtype	long
=	O
elf_d10v_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_D30V	int
:	O
case	O
EM_CYGNUS_D30V	int
:	O
rtype	long
=	O
elf_d30v_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_DLX	int
:	O
rtype	long
=	O
elf_dlx_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_SH	int
:	O
rtype	long
=	O
elf_sh_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_MN10300	int
:	O
case	O
EM_CYGNUS_MN10300	int
:	O
rtype	long
=	O
elf_mn10300_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_MN10200	int
:	O
case	O
EM_CYGNUS_MN10200	int
:	O
rtype	long
=	O
elf_mn10200_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_FR30	int
:	O
case	O
EM_CYGNUS_FR30	int
:	O
rtype	long
=	O
elf_fr30_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_CYGNUS_FRV	int
:	O
rtype	long
=	O
elf_frv_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_CSKY	int
:	O
rtype	long
=	O
elf_csky_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_FT32	int
:	O
rtype	long
=	O
elf_ft32_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_MCORE	int
:	O
rtype	long
=	O
elf_mcore_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_MMIX	int
:	O
rtype	long
=	O
elf_mmix_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_MOXIE	int
:	O
rtype	long
=	O
elf_moxie_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_MSP430	int
:	O
if	O
(	O
uses_msp430x_relocs	function
(	O
filedata	struct
)	O
)	O
{	O
rtype	long
=	O
elf_msp430x_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
}	O
case	O
EM_MSP430_OLD	int
:	O
rtype	long
=	O
elf_msp430_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_NDS32	int
:	O
rtype	long
=	O
elf_nds32_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_PPC	int
:	O
rtype	long
=	O
elf_ppc_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_PPC64	int
:	O
rtype	long
=	O
elf_ppc64_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_MIPS	int
:	O
case	O
EM_MIPS_RS3_LE	int
:	O
rtype	long
=	O
elf_mips_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_RISCV	int
:	O
rtype	long
=	O
elf_riscv_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_ALPHA	int
:	O
rtype	long
=	O
elf_alpha_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_ARM	int
:	O
rtype	long
=	O
elf_arm_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_ARC	int
:	O
case	O
EM_ARC_COMPACT	int
:	O
case	O
EM_ARC_COMPACT2	int
:	O
rtype	long
=	O
elf_arc_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_PARISC	int
:	O
rtype	long
=	O
elf_hppa_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_H8_300	int
:	O
case	O
EM_H8_300H	int
:	O
case	O
EM_H8S	int
:	O
rtype	long
=	O
elf_h8_reloc_type	enum
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_OR1K	int
:	O
rtype	long
=	O
elf_or1k_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_PJ	int
:	O
case	O
EM_PJ_OLD	int
:	O
rtype	long
=	O
elf_pj_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_IA_64	int
:	O
rtype	long
=	O
elf_ia64_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_CRIS	int
:	O
rtype	long
=	O
elf_cris_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_860	int
:	O
rtype	long
=	O
elf_i860_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_X86_64	int
:	O
case	O
EM_L1OM	int
:	O
case	O
EM_K1OM	int
:	O
rtype	long
=	O
elf_x86_64_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_S370	int
:	O
rtype	long
=	O
i370_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_S390_OLD	int
:	O
case	O
EM_S390	int
:	O
rtype	long
=	O
elf_s390_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_SCORE	int
:	O
rtype	long
=	O
elf_score_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_XSTORMY16	int
:	O
rtype	long
=	O
elf_xstormy16_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_CRX	int
:	O
rtype	long
=	O
elf_crx_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_VAX	int
:	O
rtype	long
=	O
elf_vax_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_VISIUM	int
:	O
rtype	long
=	O
elf_visium_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_BPF	int
:	O
rtype	long
=	O
elf_bpf_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_ADAPTEVA_EPIPHANY	int
:	O
rtype	long
=	O
elf_epiphany_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_IP2K	int
:	O
case	O
EM_IP2K_OLD	int
:	O
rtype	long
=	O
elf_ip2k_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_IQ2000	int
:	O
rtype	long
=	O
elf_iq2000_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_XTENSA_OLD	int
:	O
case	O
EM_XTENSA	int
:	O
rtype	long
=	O
elf_xtensa_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_LATTICEMICO32	int
:	O
rtype	long
=	O
elf_lm32_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_M32C_OLD	int
:	O
case	O
EM_M32C	int
:	O
rtype	long
=	O
elf_m32c_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_MT	int
:	O
rtype	long
=	O
elf_mt_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_BLACKFIN	int
:	O
rtype	long
=	O
elf_bfin_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_CYGNUS_MEP	int
:	O
rtype	long
=	O
elf_mep_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_CR16	int
:	O
rtype	long
=	O
elf_cr16_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_MICROBLAZE	int
:	O
case	O
EM_MICROBLAZE_OLD	int
:	O
rtype	long
=	O
elf_microblaze_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_RL78	int
:	O
rtype	long
=	O
elf_rl78_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_RX	int
:	O
rtype	long
=	O
elf_rx_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_METAG	int
:	O
rtype	long
=	O
elf_metag_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_XC16X	int
:	O
case	O
EM_C166	int
:	O
rtype	long
=	O
elf_xc16x_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_TI_C6000	int
:	O
rtype	long
=	O
elf_tic6x_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_TILEGX	int
:	O
rtype	long
=	O
elf_tilegx_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_TILEPRO	int
:	O
rtype	long
=	O
elf_tilepro_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_WEBASSEMBLY	int
:	O
rtype	long
=	O
elf_wasm32_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_XGATE	int
:	O
rtype	long
=	O
elf_xgate_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_ALTERA_NIOS2	int
:	O
rtype	long
=	O
elf_nios2_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_TI_PRU	int
:	O
rtype	long
=	O
elf_pru_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_NFP	int
:	O
if	O
(	O
EF_NFP_MACH	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_flags	array
)	O
==	O
E_NFP_MACH_3200	int
)	O
rtype	long
=	O
elf_nfp3200_reloc_type	function
(	O
type	enum
)	O
;	O
else	O
rtype	long
=	O
elf_nfp_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_Z80	int
:	O
rtype	long
=	O
elf_z80_reloc_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
}	O
if	O
(	O
rtype	long
==	O
NULL	O
)	O
printf	function
(	O
_	O
(	O
"unrecognized: %-7lx"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
type	enum
&	O
0xffffffff	int
)	O
;	O
else	O
printf	function
(	O
do_wide	int
?	O
"%-22s"	pointer
:	O
"%-17.17s"	pointer
,	O
rtype	long
)	O
;	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_ALPHA	int
&&	O
rtype	long
!=	O
NULL	O
&&	O
streq	O
(	O
rtype	long
,	O
"R_ALPHA_LITUSE"	pointer
)	O
&&	O
is_rela	int
)	O
{	O
switch	O
(	O
rels	pointer
[	O
i	pointer
]	O
.	O
r_addend	array
)	O
{	O
case	O
LITUSE_ALPHA_ADDR	int
:	O
rtype	long
=	O
"ADDR"	pointer
;	O
break	O
;	O
case	O
LITUSE_ALPHA_BASE	int
:	O
rtype	long
=	O
"BASE"	pointer
;	O
break	O
;	O
case	O
LITUSE_ALPHA_BYTOFF	int
:	O
rtype	long
=	O
"BYTOFF"	pointer
;	O
break	O
;	O
case	O
LITUSE_ALPHA_JSR	int
:	O
rtype	long
=	O
"JSR"	pointer
;	O
break	O
;	O
case	O
LITUSE_ALPHA_TLSGD	int
:	O
rtype	long
=	O
"TLSGD"	pointer
;	O
break	O
;	O
case	O
LITUSE_ALPHA_TLSLDM	int
:	O
rtype	long
=	O
"TLSLDM"	pointer
;	O
break	O
;	O
case	O
LITUSE_ALPHA_JSRDIRECT	int
:	O
rtype	long
=	O
"JSRDIRECT"	pointer
;	O
break	O
;	O
default	O
:	O
rtype	long
=	O
NULL	O
;	O
}	O
if	O
(	O
rtype	long
)	O
printf	function
(	O
" (%s)"	pointer
,	O
rtype	long
)	O
;	O
else	O
{	O
putchar	function
(	O
' '	O
)	O
;	O
printf	function
(	O
_	O
(	O
"<unknown addend: %lx>"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
rels	pointer
[	O
i	pointer
]	O
.	O
r_addend	array
)	O
;	O
res	int
=	O
FALSE	int
;	O
}	O
}	O
else	O
if	O
(	O
symtab_index	long
)	O
{	O
if	O
(	O
symtab	pointer
==	O
NULL	O
||	O
symtab_index	long
>=	O
nsyms	long
)	O
{	O
error	function
(	O
_	O
(	O
" bad symbol index: %08lx in reloc"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
symtab_index	long
)	O
;	O
res	int
=	O
FALSE	int
;	O
}	O
else	O
{	O
Elf_Internal_Sym	struct
*	O
psym	pointer
;	O
const	O
char	O
*	O
version_string	pointer
;	O
enum	O
versioned_symbol_info	enum
sym_info	enum
;	O
unsigned	O
short	O
vna_other	array
;	O
psym	pointer
=	O
symtab	pointer
+	O
symtab_index	long
;	O
version_string	pointer
=	O
get_symbol_version_string	function
(	O
filedata	struct
,	O
is_dynsym	int
,	O
strtab	pointer
,	O
strtablen	long
,	O
symtab_index	long
,	O
psym	pointer
,	O
&	O
sym_info	enum
,	O
&	O
vna_other	array
)	O
;	O
printf	function
(	O
" "	pointer
)	O
;	O
if	O
(	O
ELF_ST_TYPE	O
(	O
psym	pointer
->	O
st_info	array
)	O
==	O
STT_GNU_IFUNC	int
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
unsigned	O
int	O
len	int
;	O
unsigned	O
int	O
width	int
=	O
is_32bit_elf	int
?	O
8	int
:	O
14	int
;	O
if	O
(	O
strtab	pointer
==	O
NULL	O
||	O
psym	pointer
->	O
st_name	pointer
==	O
0	int
||	O
psym	pointer
->	O
st_name	pointer
>=	O
strtablen	long
)	O
name	pointer
=	O
"??"	pointer
;	O
else	O
name	pointer
=	O
strtab	pointer
+	O
psym	pointer
->	O
st_name	pointer
;	O
len	int
=	O
print_symbol	function
(	O
width	int
,	O
name	pointer
)	O
;	O
if	O
(	O
version_string	pointer
)	O
printf	function
(	O
sym_info	enum
==	O
symbol_public	int
?	O
"@@%s"	pointer
:	O
"@%s"	pointer
,	O
version_string	pointer
)	O
;	O
printf	function
(	O
"()%-*s"	pointer
,	O
len	int
<=	O
width	int
?	O
(	O
width	int
+	O
1	int
)	O
-	O
len	int
:	O
1	int
,	O
" "	pointer
)	O
;	O
}	O
else	O
{	O
print_vma	function
(	O
psym	pointer
->	O
st_value	int
,	O
LONG_HEX	int
)	O
;	O
printf	function
(	O
is_32bit_elf	int
?	O
"   "	pointer
:	O
" "	pointer
)	O
;	O
}	O
if	O
(	O
psym	pointer
->	O
st_name	pointer
==	O
0	int
)	O
{	O
const	O
char	O
*	O
sec_name	pointer
=	O
"<null>"	pointer
;	O
char	O
name_buf	array
[	O
40	int
]	O
;	O
if	O
(	O
ELF_ST_TYPE	O
(	O
psym	pointer
->	O
st_info	array
)	O
==	O
STT_SECTION	int
)	O
{	O
if	O
(	O
psym	pointer
->	O
st_shndx	int
<	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
)	O
sec_name	pointer
=	O
SECTION_NAME	O
(	O
filedata	struct
->	O
section_headers	pointer
+	O
psym	pointer
->	O
st_shndx	int
)	O
;	O
else	O
if	O
(	O
psym	pointer
->	O
st_shndx	int
==	O
SHN_ABS	O
)	O
sec_name	pointer
=	O
"ABS"	pointer
;	O
else	O
if	O
(	O
psym	pointer
->	O
st_shndx	int
==	O
SHN_COMMON	O
)	O
sec_name	pointer
=	O
"COMMON"	pointer
;	O
else	O
if	O
(	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_MIPS	int
&&	O
psym	pointer
->	O
st_shndx	int
==	O
SHN_MIPS_SCOMMON	O
)	O
||	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_TI_C6000	int
&&	O
psym	pointer
->	O
st_shndx	int
==	O
SHN_TIC6X_SCOMMON	O
)	O
)	O
sec_name	pointer
=	O
"SCOMMON"	pointer
;	O
else	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_MIPS	int
&&	O
psym	pointer
->	O
st_shndx	int
==	O
SHN_MIPS_SUNDEFINED	O
)	O
sec_name	pointer
=	O
"SUNDEF"	pointer
;	O
else	O
if	O
(	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_X86_64	int
||	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_L1OM	int
||	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_K1OM	int
)	O
&&	O
psym	pointer
->	O
st_shndx	int
==	O
SHN_X86_64_LCOMMON	O
)	O
sec_name	pointer
=	O
"LARGE_COMMON"	pointer
;	O
else	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_IA_64	int
&&	O
filedata	struct
->	O
file_header	struct
.	O
e_ident	array
[	O
EI_OSABI	int
]	O
==	O
ELFOSABI_HPUX	int
&&	O
psym	pointer
->	O
st_shndx	int
==	O
SHN_IA_64_ANSI_COMMON	O
)	O
sec_name	pointer
=	O
"ANSI_COM"	pointer
;	O
else	O
if	O
(	O
is_ia64_vms	function
(	O
filedata	struct
)	O
&&	O
psym	pointer
->	O
st_shndx	int
==	O
SHN_IA_64_VMS_SYMVEC	O
)	O
sec_name	pointer
=	O
"VMS_SYMVEC"	pointer
;	O
else	O
{	O
sprintf	function
(	O
name_buf	array
,	O
"<section 0x%x>"	pointer
,	O
(	O
unsigned	O
int	O
)	O
psym	pointer
->	O
st_shndx	int
)	O
;	O
sec_name	pointer
=	O
name_buf	array
;	O
}	O
}	O
print_symbol	function
(	O
22	int
,	O
sec_name	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strtab	pointer
==	O
NULL	O
)	O
printf	function
(	O
_	O
(	O
"<string table index: %3ld>"	pointer
)	O
,	O
psym	pointer
->	O
st_name	pointer
)	O
;	O
else	O
if	O
(	O
psym	pointer
->	O
st_name	pointer
>=	O
strtablen	long
)	O
{	O
error	function
(	O
_	O
(	O
"<corrupt string table index: %3ld>"	pointer
)	O
,	O
psym	pointer
->	O
st_name	pointer
)	O
;	O
res	int
=	O
FALSE	int
;	O
}	O
else	O
{	O
print_symbol	function
(	O
22	int
,	O
strtab	pointer
+	O
psym	pointer
->	O
st_name	pointer
)	O
;	O
if	O
(	O
version_string	pointer
)	O
printf	function
(	O
sym_info	enum
==	O
symbol_public	int
?	O
"@@%s"	pointer
:	O
"@%s"	pointer
,	O
version_string	pointer
)	O
;	O
}	O
if	O
(	O
is_rela	int
)	O
{	O
bfd_vma	long
off	long
=	O
rels	pointer
[	O
i	pointer
]	O
.	O
r_addend	array
;	O
if	O
(	O
(	O
bfd_signed_vma	long
)	O
off	long
<	O
0	int
)	O
printf	function
(	O
" - %"	pointer
BFD_VMA_FMT	pointer
"x"	pointer
,	O
-	O
off	long
)	O
;	O
else	O
printf	function
(	O
" + %"	pointer
BFD_VMA_FMT	pointer
"x"	pointer
,	O
off	long
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
is_rela	int
)	O
{	O
bfd_vma	long
off	long
=	O
rels	pointer
[	O
i	pointer
]	O
.	O
r_addend	array
;	O
printf	function
(	O
"%*c"	pointer
,	O
is_32bit_elf	int
?	O
12	int
:	O
20	int
,	O
' '	O
)	O
;	O
if	O
(	O
(	O
bfd_signed_vma	long
)	O
off	long
<	O
0	int
)	O
printf	function
(	O
"-%"	pointer
BFD_VMA_FMT	pointer
"x"	pointer
,	O
-	O
off	long
)	O
;	O
else	O
printf	function
(	O
"%"	pointer
BFD_VMA_FMT	pointer
"x"	pointer
,	O
off	long
)	O
;	O
}	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_SPARCV9	int
&&	O
rtype	long
!=	O
NULL	O
&&	O
streq	O
(	O
rtype	long
,	O
"R_SPARC_OLO10"	pointer
)	O
)	O
printf	function
(	O
" + %lx"	pointer
,	O
(	O
unsigned	O
long	O
)	O
ELF64_R_TYPE_DATA	O
(	O
inf	long
)	O
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
if	O
(	O
!	O
is_32bit_elf	int
&&	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_MIPS	int
)	O
{	O
bfd_vma	long
type2	long
=	O
ELF64_MIPS_R_TYPE2	O
(	O
inf	long
)	O
;	O
bfd_vma	long
type3	long
=	O
ELF64_MIPS_R_TYPE3	O
(	O
inf	long
)	O
;	O
const	O
char	O
*	O
rtype2	pointer
=	O
elf_mips_reloc_type	function
(	O
type2	long
)	O
;	O
const	O
char	O
*	O
rtype3	pointer
=	O
elf_mips_reloc_type	function
(	O
type3	long
)	O
;	O
printf	function
(	O
"                    Type2: "	pointer
)	O
;	O
if	O
(	O
rtype2	pointer
==	O
NULL	O
)	O
printf	function
(	O
_	O
(	O
"unrecognized: %-7lx"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
type2	long
&	O
0xffffffff	int
)	O
;	O
else	O
printf	function
(	O
"%-17.17s"	pointer
,	O
rtype2	pointer
)	O
;	O
printf	function
(	O
"\n                    Type3: "	pointer
)	O
;	O
if	O
(	O
rtype3	pointer
==	O
NULL	O
)	O
printf	function
(	O
_	O
(	O
"unrecognized: %-7lx"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
type3	long
&	O
0xffffffff	int
)	O
;	O
else	O
printf	function
(	O
"%-17.17s"	pointer
,	O
rtype3	pointer
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
}	O
free	function
(	O
rels	pointer
)	O
;	O
return	O
res	int
;	O
}	O
static	O
const	O
char	O
*	O
get_aarch64_dynamic_type	function
(	O
unsigned	O
long	O
type	enum
)	O
{	O
switch	O
(	O
type	enum
)	O
{	O
case	O
DT_AARCH64_BTI_PLT	O
:	O
return	O
"AARCH64_BTI_PLT"	pointer
;	O
case	O
DT_AARCH64_PAC_PLT	O
:	O
return	O
"AARCH64_PAC_PLT"	pointer
;	O
case	O
DT_AARCH64_VARIANT_PCS	O
:	O
return	O
"AARCH64_VARIANT_PCS"	pointer
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_mips_dynamic_type	function
(	O
unsigned	O
long	O
type	enum
)	O
{	O
switch	O
(	O
type	enum
)	O
{	O
case	O
DT_MIPS_RLD_VERSION	int
:	O
return	O
"MIPS_RLD_VERSION"	pointer
;	O
case	O
DT_MIPS_TIME_STAMP	int
:	O
return	O
"MIPS_TIME_STAMP"	pointer
;	O
case	O
DT_MIPS_ICHECKSUM	int
:	O
return	O
"MIPS_ICHECKSUM"	pointer
;	O
case	O
DT_MIPS_IVERSION	int
:	O
return	O
"MIPS_IVERSION"	pointer
;	O
case	O
DT_MIPS_FLAGS	int
:	O
return	O
"MIPS_FLAGS"	pointer
;	O
case	O
DT_MIPS_BASE_ADDRESS	int
:	O
return	O
"MIPS_BASE_ADDRESS"	pointer
;	O
case	O
DT_MIPS_MSYM	int
:	O
return	O
"MIPS_MSYM"	pointer
;	O
case	O
DT_MIPS_CONFLICT	int
:	O
return	O
"MIPS_CONFLICT"	pointer
;	O
case	O
DT_MIPS_LIBLIST	int
:	O
return	O
"MIPS_LIBLIST"	pointer
;	O
case	O
DT_MIPS_LOCAL_GOTNO	int
:	O
return	O
"MIPS_LOCAL_GOTNO"	pointer
;	O
case	O
DT_MIPS_CONFLICTNO	int
:	O
return	O
"MIPS_CONFLICTNO"	pointer
;	O
case	O
DT_MIPS_LIBLISTNO	int
:	O
return	O
"MIPS_LIBLISTNO"	pointer
;	O
case	O
DT_MIPS_SYMTABNO	int
:	O
return	O
"MIPS_SYMTABNO"	pointer
;	O
case	O
DT_MIPS_UNREFEXTNO	int
:	O
return	O
"MIPS_UNREFEXTNO"	pointer
;	O
case	O
DT_MIPS_GOTSYM	int
:	O
return	O
"MIPS_GOTSYM"	pointer
;	O
case	O
DT_MIPS_HIPAGENO	int
:	O
return	O
"MIPS_HIPAGENO"	pointer
;	O
case	O
DT_MIPS_RLD_MAP	int
:	O
return	O
"MIPS_RLD_MAP"	pointer
;	O
case	O
DT_MIPS_RLD_MAP_REL	int
:	O
return	O
"MIPS_RLD_MAP_REL"	pointer
;	O
case	O
DT_MIPS_DELTA_CLASS	int
:	O
return	O
"MIPS_DELTA_CLASS"	pointer
;	O
case	O
DT_MIPS_DELTA_CLASS_NO	int
:	O
return	O
"MIPS_DELTA_CLASS_NO"	pointer
;	O
case	O
DT_MIPS_DELTA_INSTANCE	int
:	O
return	O
"MIPS_DELTA_INSTANCE"	pointer
;	O
case	O
DT_MIPS_DELTA_INSTANCE_NO	int
:	O
return	O
"MIPS_DELTA_INSTANCE_NO"	pointer
;	O
case	O
DT_MIPS_DELTA_RELOC	int
:	O
return	O
"MIPS_DELTA_RELOC"	pointer
;	O
case	O
DT_MIPS_DELTA_RELOC_NO	int
:	O
return	O
"MIPS_DELTA_RELOC_NO"	pointer
;	O
case	O
DT_MIPS_DELTA_SYM	int
:	O
return	O
"MIPS_DELTA_SYM"	pointer
;	O
case	O
DT_MIPS_DELTA_SYM_NO	int
:	O
return	O
"MIPS_DELTA_SYM_NO"	pointer
;	O
case	O
DT_MIPS_DELTA_CLASSSYM	int
:	O
return	O
"MIPS_DELTA_CLASSSYM"	pointer
;	O
case	O
DT_MIPS_DELTA_CLASSSYM_NO	int
:	O
return	O
"MIPS_DELTA_CLASSSYM_NO"	pointer
;	O
case	O
DT_MIPS_CXX_FLAGS	int
:	O
return	O
"MIPS_CXX_FLAGS"	pointer
;	O
case	O
DT_MIPS_PIXIE_INIT	int
:	O
return	O
"MIPS_PIXIE_INIT"	pointer
;	O
case	O
DT_MIPS_SYMBOL_LIB	int
:	O
return	O
"MIPS_SYMBOL_LIB"	pointer
;	O
case	O
DT_MIPS_LOCALPAGE_GOTIDX	int
:	O
return	O
"MIPS_LOCALPAGE_GOTIDX"	pointer
;	O
case	O
DT_MIPS_LOCAL_GOTIDX	int
:	O
return	O
"MIPS_LOCAL_GOTIDX"	pointer
;	O
case	O
DT_MIPS_HIDDEN_GOTIDX	int
:	O
return	O
"MIPS_HIDDEN_GOTIDX"	pointer
;	O
case	O
DT_MIPS_PROTECTED_GOTIDX	int
:	O
return	O
"MIPS_PROTECTED_GOTIDX"	pointer
;	O
case	O
DT_MIPS_OPTIONS	int
:	O
return	O
"MIPS_OPTIONS"	pointer
;	O
case	O
DT_MIPS_INTERFACE	int
:	O
return	O
"MIPS_INTERFACE"	pointer
;	O
case	O
DT_MIPS_DYNSTR_ALIGN	int
:	O
return	O
"MIPS_DYNSTR_ALIGN"	pointer
;	O
case	O
DT_MIPS_INTERFACE_SIZE	int
:	O
return	O
"MIPS_INTERFACE_SIZE"	pointer
;	O
case	O
DT_MIPS_RLD_TEXT_RESOLVE_ADDR	int
:	O
return	O
"MIPS_RLD_TEXT_RESOLVE_ADDR"	pointer
;	O
case	O
DT_MIPS_PERF_SUFFIX	int
:	O
return	O
"MIPS_PERF_SUFFIX"	pointer
;	O
case	O
DT_MIPS_COMPACT_SIZE	int
:	O
return	O
"MIPS_COMPACT_SIZE"	pointer
;	O
case	O
DT_MIPS_GP_VALUE	int
:	O
return	O
"MIPS_GP_VALUE"	pointer
;	O
case	O
DT_MIPS_AUX_DYNAMIC	int
:	O
return	O
"MIPS_AUX_DYNAMIC"	pointer
;	O
case	O
DT_MIPS_PLTGOT	int
:	O
return	O
"MIPS_PLTGOT"	pointer
;	O
case	O
DT_MIPS_RWPLT	int
:	O
return	O
"MIPS_RWPLT"	pointer
;	O
case	O
DT_MIPS_XHASH	int
:	O
return	O
"MIPS_XHASH"	pointer
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_sparc64_dynamic_type	function
(	O
unsigned	O
long	O
type	enum
)	O
{	O
switch	O
(	O
type	enum
)	O
{	O
case	O
DT_SPARC_REGISTER	int
:	O
return	O
"SPARC_REGISTER"	pointer
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_ppc_dynamic_type	function
(	O
unsigned	O
long	O
type	enum
)	O
{	O
switch	O
(	O
type	enum
)	O
{	O
case	O
DT_PPC_GOT	O
:	O
return	O
"PPC_GOT"	pointer
;	O
case	O
DT_PPC_OPT	O
:	O
return	O
"PPC_OPT"	pointer
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_ppc64_dynamic_type	function
(	O
unsigned	O
long	O
type	enum
)	O
{	O
switch	O
(	O
type	enum
)	O
{	O
case	O
DT_PPC64_GLINK	O
:	O
return	O
"PPC64_GLINK"	pointer
;	O
case	O
DT_PPC64_OPD	O
:	O
return	O
"PPC64_OPD"	pointer
;	O
case	O
DT_PPC64_OPDSZ	O
:	O
return	O
"PPC64_OPDSZ"	pointer
;	O
case	O
DT_PPC64_OPT	O
:	O
return	O
"PPC64_OPT"	pointer
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_parisc_dynamic_type	function
(	O
unsigned	O
long	O
type	enum
)	O
{	O
switch	O
(	O
type	enum
)	O
{	O
case	O
DT_HP_LOAD_MAP	O
:	O
return	O
"HP_LOAD_MAP"	pointer
;	O
case	O
DT_HP_DLD_FLAGS	O
:	O
return	O
"HP_DLD_FLAGS"	pointer
;	O
case	O
DT_HP_DLD_HOOK	O
:	O
return	O
"HP_DLD_HOOK"	pointer
;	O
case	O
DT_HP_UX10_INIT	O
:	O
return	O
"HP_UX10_INIT"	pointer
;	O
case	O
DT_HP_UX10_INITSZ	O
:	O
return	O
"HP_UX10_INITSZ"	pointer
;	O
case	O
DT_HP_PREINIT	O
:	O
return	O
"HP_PREINIT"	pointer
;	O
case	O
DT_HP_PREINITSZ	O
:	O
return	O
"HP_PREINITSZ"	pointer
;	O
case	O
DT_HP_NEEDED	O
:	O
return	O
"HP_NEEDED"	pointer
;	O
case	O
DT_HP_TIME_STAMP	O
:	O
return	O
"HP_TIME_STAMP"	pointer
;	O
case	O
DT_HP_CHECKSUM	O
:	O
return	O
"HP_CHECKSUM"	pointer
;	O
case	O
DT_HP_GST_SIZE	O
:	O
return	O
"HP_GST_SIZE"	pointer
;	O
case	O
DT_HP_GST_VERSION	O
:	O
return	O
"HP_GST_VERSION"	pointer
;	O
case	O
DT_HP_GST_HASHVAL	O
:	O
return	O
"HP_GST_HASHVAL"	pointer
;	O
case	O
DT_HP_EPLTREL	O
:	O
return	O
"HP_GST_EPLTREL"	pointer
;	O
case	O
DT_HP_EPLTRELSZ	O
:	O
return	O
"HP_GST_EPLTRELSZ"	pointer
;	O
case	O
DT_HP_FILTERED	O
:	O
return	O
"HP_FILTERED"	pointer
;	O
case	O
DT_HP_FILTER_TLS	O
:	O
return	O
"HP_FILTER_TLS"	pointer
;	O
case	O
DT_HP_COMPAT_FILTERED	O
:	O
return	O
"HP_COMPAT_FILTERED"	pointer
;	O
case	O
DT_HP_LAZYLOAD	O
:	O
return	O
"HP_LAZYLOAD"	pointer
;	O
case	O
DT_HP_BIND_NOW_COUNT	O
:	O
return	O
"HP_BIND_NOW_COUNT"	pointer
;	O
case	O
DT_PLT	O
:	O
return	O
"PLT"	pointer
;	O
case	O
DT_PLT_SIZE	O
:	O
return	O
"PLT_SIZE"	pointer
;	O
case	O
DT_DLT	O
:	O
return	O
"DLT"	pointer
;	O
case	O
DT_DLT_SIZE	O
:	O
return	O
"DLT_SIZE"	pointer
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_ia64_dynamic_type	function
(	O
unsigned	O
long	O
type	enum
)	O
{	O
switch	O
(	O
type	enum
)	O
{	O
case	O
DT_IA_64_PLT_RESERVE	O
:	O
return	O
"IA_64_PLT_RESERVE"	pointer
;	O
case	O
DT_IA_64_VMS_SUBTYPE	O
:	O
return	O
"VMS_SUBTYPE"	pointer
;	O
case	O
DT_IA_64_VMS_IMGIOCNT	O
:	O
return	O
"VMS_IMGIOCNT"	pointer
;	O
case	O
DT_IA_64_VMS_LNKFLAGS	O
:	O
return	O
"VMS_LNKFLAGS"	pointer
;	O
case	O
DT_IA_64_VMS_VIR_MEM_BLK_SIZ	O
:	O
return	O
"VMS_VIR_MEM_BLK_SIZ"	pointer
;	O
case	O
DT_IA_64_VMS_IDENT	O
:	O
return	O
"VMS_IDENT"	pointer
;	O
case	O
DT_IA_64_VMS_NEEDED_IDENT	O
:	O
return	O
"VMS_NEEDED_IDENT"	pointer
;	O
case	O
DT_IA_64_VMS_IMG_RELA_CNT	O
:	O
return	O
"VMS_IMG_RELA_CNT"	pointer
;	O
case	O
DT_IA_64_VMS_SEG_RELA_CNT	O
:	O
return	O
"VMS_SEG_RELA_CNT"	pointer
;	O
case	O
DT_IA_64_VMS_FIXUP_RELA_CNT	O
:	O
return	O
"VMS_FIXUP_RELA_CNT"	pointer
;	O
case	O
DT_IA_64_VMS_FIXUP_NEEDED	O
:	O
return	O
"VMS_FIXUP_NEEDED"	pointer
;	O
case	O
DT_IA_64_VMS_SYMVEC_CNT	O
:	O
return	O
"VMS_SYMVEC_CNT"	pointer
;	O
case	O
DT_IA_64_VMS_XLATED	O
:	O
return	O
"VMS_XLATED"	pointer
;	O
case	O
DT_IA_64_VMS_STACKSIZE	O
:	O
return	O
"VMS_STACKSIZE"	pointer
;	O
case	O
DT_IA_64_VMS_UNWINDSZ	O
:	O
return	O
"VMS_UNWINDSZ"	pointer
;	O
case	O
DT_IA_64_VMS_UNWIND_CODSEG	O
:	O
return	O
"VMS_UNWIND_CODSEG"	pointer
;	O
case	O
DT_IA_64_VMS_UNWIND_INFOSEG	O
:	O
return	O
"VMS_UNWIND_INFOSEG"	pointer
;	O
case	O
DT_IA_64_VMS_LINKTIME	O
:	O
return	O
"VMS_LINKTIME"	pointer
;	O
case	O
DT_IA_64_VMS_SEG_NO	O
:	O
return	O
"VMS_SEG_NO"	pointer
;	O
case	O
DT_IA_64_VMS_SYMVEC_OFFSET	O
:	O
return	O
"VMS_SYMVEC_OFFSET"	pointer
;	O
case	O
DT_IA_64_VMS_SYMVEC_SEG	O
:	O
return	O
"VMS_SYMVEC_SEG"	pointer
;	O
case	O
DT_IA_64_VMS_UNWIND_OFFSET	O
:	O
return	O
"VMS_UNWIND_OFFSET"	pointer
;	O
case	O
DT_IA_64_VMS_UNWIND_SEG	O
:	O
return	O
"VMS_UNWIND_SEG"	pointer
;	O
case	O
DT_IA_64_VMS_STRTAB_OFFSET	O
:	O
return	O
"VMS_STRTAB_OFFSET"	pointer
;	O
case	O
DT_IA_64_VMS_SYSVER_OFFSET	O
:	O
return	O
"VMS_SYSVER_OFFSET"	pointer
;	O
case	O
DT_IA_64_VMS_IMG_RELA_OFF	O
:	O
return	O
"VMS_IMG_RELA_OFF"	pointer
;	O
case	O
DT_IA_64_VMS_SEG_RELA_OFF	O
:	O
return	O
"VMS_SEG_RELA_OFF"	pointer
;	O
case	O
DT_IA_64_VMS_FIXUP_RELA_OFF	O
:	O
return	O
"VMS_FIXUP_RELA_OFF"	pointer
;	O
case	O
DT_IA_64_VMS_PLTGOT_OFFSET	O
:	O
return	O
"VMS_PLTGOT_OFFSET"	pointer
;	O
case	O
DT_IA_64_VMS_PLTGOT_SEG	O
:	O
return	O
"VMS_PLTGOT_SEG"	pointer
;	O
case	O
DT_IA_64_VMS_FPMODE	O
:	O
return	O
"VMS_FPMODE"	pointer
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_solaris_section_type	function
(	O
unsigned	O
long	O
type	enum
)	O
{	O
switch	O
(	O
type	enum
)	O
{	O
case	O
0x6fffffee	int
:	O
return	O
"SUNW_ancillary"	pointer
;	O
case	O
0x6fffffef	int
:	O
return	O
"SUNW_capchain"	pointer
;	O
case	O
0x6ffffff0	int
:	O
return	O
"SUNW_capinfo"	pointer
;	O
case	O
0x6ffffff1	int
:	O
return	O
"SUNW_symsort"	pointer
;	O
case	O
0x6ffffff2	int
:	O
return	O
"SUNW_tlssort"	pointer
;	O
case	O
0x6ffffff3	int
:	O
return	O
"SUNW_LDYNSYM"	pointer
;	O
case	O
0x6ffffff4	int
:	O
return	O
"SUNW_dof"	pointer
;	O
case	O
0x6ffffff5	int
:	O
return	O
"SUNW_cap"	pointer
;	O
case	O
0x6ffffff6	int
:	O
return	O
"SUNW_SIGNATURE"	pointer
;	O
case	O
0x6ffffff7	int
:	O
return	O
"SUNW_ANNOTATE"	pointer
;	O
case	O
0x6ffffff8	int
:	O
return	O
"SUNW_DEBUGSTR"	pointer
;	O
case	O
0x6ffffff9	int
:	O
return	O
"SUNW_DEBUG"	pointer
;	O
case	O
0x6ffffffa	int
:	O
return	O
"SUNW_move"	pointer
;	O
case	O
0x6ffffffb	int
:	O
return	O
"SUNW_COMDAT"	pointer
;	O
case	O
0x6ffffffc	int
:	O
return	O
"SUNW_syminfo"	pointer
;	O
case	O
0x6ffffffd	int
:	O
return	O
"SUNW_verdef"	pointer
;	O
case	O
0x6ffffffe	int
:	O
return	O
"SUNW_verneed"	pointer
;	O
case	O
0x6fffffff	int
:	O
return	O
"SUNW_versym"	pointer
;	O
case	O
0x70000000	int
:	O
return	O
"SPARC_GOTDATA"	pointer
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_alpha_dynamic_type	function
(	O
unsigned	O
long	O
type	enum
)	O
{	O
switch	O
(	O
type	enum
)	O
{	O
case	O
DT_ALPHA_PLTRO	O
:	O
return	O
"ALPHA_PLTRO"	pointer
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_score_dynamic_type	function
(	O
unsigned	O
long	O
type	enum
)	O
{	O
switch	O
(	O
type	enum
)	O
{	O
case	O
DT_SCORE_BASE_ADDRESS	int
:	O
return	O
"SCORE_BASE_ADDRESS"	pointer
;	O
case	O
DT_SCORE_LOCAL_GOTNO	int
:	O
return	O
"SCORE_LOCAL_GOTNO"	pointer
;	O
case	O
DT_SCORE_SYMTABNO	int
:	O
return	O
"SCORE_SYMTABNO"	pointer
;	O
case	O
DT_SCORE_GOTSYM	int
:	O
return	O
"SCORE_GOTSYM"	pointer
;	O
case	O
DT_SCORE_UNREFEXTNO	int
:	O
return	O
"SCORE_UNREFEXTNO"	pointer
;	O
case	O
DT_SCORE_HIPAGENO	int
:	O
return	O
"SCORE_HIPAGENO"	pointer
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_tic6x_dynamic_type	function
(	O
unsigned	O
long	O
type	enum
)	O
{	O
switch	O
(	O
type	enum
)	O
{	O
case	O
DT_C6000_GSYM_OFFSET	int
:	O
return	O
"C6000_GSYM_OFFSET"	pointer
;	O
case	O
DT_C6000_GSTR_OFFSET	int
:	O
return	O
"C6000_GSTR_OFFSET"	pointer
;	O
case	O
DT_C6000_DSBT_BASE	int
:	O
return	O
"C6000_DSBT_BASE"	pointer
;	O
case	O
DT_C6000_DSBT_SIZE	int
:	O
return	O
"C6000_DSBT_SIZE"	pointer
;	O
case	O
DT_C6000_PREEMPTMAP	int
:	O
return	O
"C6000_PREEMPTMAP"	pointer
;	O
case	O
DT_C6000_DSBT_INDEX	int
:	O
return	O
"C6000_DSBT_INDEX"	pointer
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_nios2_dynamic_type	function
(	O
unsigned	O
long	O
type	enum
)	O
{	O
switch	O
(	O
type	enum
)	O
{	O
case	O
DT_NIOS2_GP	int
:	O
return	O
"NIOS2_GP"	pointer
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_solaris_dynamic_type	function
(	O
unsigned	O
long	O
type	enum
)	O
{	O
switch	O
(	O
type	enum
)	O
{	O
case	O
0x6000000d	int
:	O
return	O
"SUNW_AUXILIARY"	pointer
;	O
case	O
0x6000000e	int
:	O
return	O
"SUNW_RTLDINF"	pointer
;	O
case	O
0x6000000f	int
:	O
return	O
"SUNW_FILTER"	pointer
;	O
case	O
0x60000010	int
:	O
return	O
"SUNW_CAP"	pointer
;	O
case	O
0x60000011	int
:	O
return	O
"SUNW_SYMTAB"	pointer
;	O
case	O
0x60000012	int
:	O
return	O
"SUNW_SYMSZ"	pointer
;	O
case	O
0x60000013	int
:	O
return	O
"SUNW_SORTENT"	pointer
;	O
case	O
0x60000014	int
:	O
return	O
"SUNW_SYMSORT"	pointer
;	O
case	O
0x60000015	int
:	O
return	O
"SUNW_SYMSORTSZ"	pointer
;	O
case	O
0x60000016	int
:	O
return	O
"SUNW_TLSSORT"	pointer
;	O
case	O
0x60000017	int
:	O
return	O
"SUNW_TLSSORTSZ"	pointer
;	O
case	O
0x60000018	int
:	O
return	O
"SUNW_CAPINFO"	pointer
;	O
case	O
0x60000019	int
:	O
return	O
"SUNW_STRPAD"	pointer
;	O
case	O
0x6000001a	int
:	O
return	O
"SUNW_CAPCHAIN"	pointer
;	O
case	O
0x6000001b	int
:	O
return	O
"SUNW_LDMACH"	pointer
;	O
case	O
0x6000001d	int
:	O
return	O
"SUNW_CAPCHAINENT"	pointer
;	O
case	O
0x6000001f	int
:	O
return	O
"SUNW_CAPCHAINSZ"	pointer
;	O
case	O
0x60000021	int
:	O
return	O
"SUNW_PARENT"	pointer
;	O
case	O
0x60000023	int
:	O
return	O
"SUNW_ASLR"	pointer
;	O
case	O
0x60000025	int
:	O
return	O
"SUNW_RELAX"	pointer
;	O
case	O
0x60000029	int
:	O
return	O
"SUNW_NXHEAP"	pointer
;	O
case	O
0x6000002b	int
:	O
return	O
"SUNW_NXSTACK"	pointer
;	O
case	O
0x70000001	int
:	O
return	O
"SPARC_REGISTER"	pointer
;	O
case	O
0x7ffffffd	int
:	O
return	O
"AUXILIARY"	pointer
;	O
case	O
0x7ffffffe	int
:	O
return	O
"USED"	pointer
;	O
case	O
0x7fffffff	int
:	O
return	O
"FILTER"	pointer
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_dynamic_type	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
long	O
type	enum
)	O
{	O
static	O
char	O
buff	array
[	O
64	int
]	O
;	O
switch	O
(	O
type	enum
)	O
{	O
case	O
DT_NULL	int
:	O
return	O
"NULL"	pointer
;	O
case	O
DT_NEEDED	int
:	O
return	O
"NEEDED"	pointer
;	O
case	O
DT_PLTRELSZ	int
:	O
return	O
"PLTRELSZ"	pointer
;	O
case	O
DT_PLTGOT	int
:	O
return	O
"PLTGOT"	pointer
;	O
case	O
DT_HASH	int
:	O
return	O
"HASH"	pointer
;	O
case	O
DT_STRTAB	int
:	O
return	O
"STRTAB"	pointer
;	O
case	O
DT_SYMTAB	int
:	O
return	O
"SYMTAB"	pointer
;	O
case	O
DT_RELA	int
:	O
return	O
"RELA"	pointer
;	O
case	O
DT_RELASZ	int
:	O
return	O
"RELASZ"	pointer
;	O
case	O
DT_RELAENT	int
:	O
return	O
"RELAENT"	pointer
;	O
case	O
DT_STRSZ	int
:	O
return	O
"STRSZ"	pointer
;	O
case	O
DT_SYMENT	int
:	O
return	O
"SYMENT"	pointer
;	O
case	O
DT_INIT	int
:	O
return	O
"INIT"	pointer
;	O
case	O
DT_FINI	int
:	O
return	O
"FINI"	pointer
;	O
case	O
DT_SONAME	int
:	O
return	O
"SONAME"	pointer
;	O
case	O
DT_RPATH	int
:	O
return	O
"RPATH"	pointer
;	O
case	O
DT_SYMBOLIC	int
:	O
return	O
"SYMBOLIC"	pointer
;	O
case	O
DT_REL	int
:	O
return	O
"REL"	pointer
;	O
case	O
DT_RELSZ	int
:	O
return	O
"RELSZ"	pointer
;	O
case	O
DT_RELENT	int
:	O
return	O
"RELENT"	pointer
;	O
case	O
DT_PLTREL	int
:	O
return	O
"PLTREL"	pointer
;	O
case	O
DT_DEBUG	int
:	O
return	O
"DEBUG"	pointer
;	O
case	O
DT_TEXTREL	int
:	O
return	O
"TEXTREL"	pointer
;	O
case	O
DT_JMPREL	int
:	O
return	O
"JMPREL"	pointer
;	O
case	O
DT_BIND_NOW	int
:	O
return	O
"BIND_NOW"	pointer
;	O
case	O
DT_INIT_ARRAY	int
:	O
return	O
"INIT_ARRAY"	pointer
;	O
case	O
DT_FINI_ARRAY	int
:	O
return	O
"FINI_ARRAY"	pointer
;	O
case	O
DT_INIT_ARRAYSZ	int
:	O
return	O
"INIT_ARRAYSZ"	pointer
;	O
case	O
DT_FINI_ARRAYSZ	int
:	O
return	O
"FINI_ARRAYSZ"	pointer
;	O
case	O
DT_RUNPATH	int
:	O
return	O
"RUNPATH"	pointer
;	O
case	O
DT_FLAGS	int
:	O
return	O
"FLAGS"	pointer
;	O
case	O
DT_PREINIT_ARRAY	int
:	O
return	O
"PREINIT_ARRAY"	pointer
;	O
case	O
DT_PREINIT_ARRAYSZ	int
:	O
return	O
"PREINIT_ARRAYSZ"	pointer
;	O
case	O
DT_SYMTAB_SHNDX	int
:	O
return	O
"SYMTAB_SHNDX"	pointer
;	O
case	O
DT_CHECKSUM	int
:	O
return	O
"CHECKSUM"	pointer
;	O
case	O
DT_PLTPADSZ	int
:	O
return	O
"PLTPADSZ"	pointer
;	O
case	O
DT_MOVEENT	int
:	O
return	O
"MOVEENT"	pointer
;	O
case	O
DT_MOVESZ	int
:	O
return	O
"MOVESZ"	pointer
;	O
case	O
DT_FEATURE	int
:	O
return	O
"FEATURE"	pointer
;	O
case	O
DT_POSFLAG_1	int
:	O
return	O
"POSFLAG_1"	pointer
;	O
case	O
DT_SYMINSZ	int
:	O
return	O
"SYMINSZ"	pointer
;	O
case	O
DT_SYMINENT	int
:	O
return	O
"SYMINENT"	pointer
;	O
case	O
DT_ADDRRNGLO	int
:	O
return	O
"ADDRRNGLO"	pointer
;	O
case	O
DT_CONFIG	int
:	O
return	O
"CONFIG"	pointer
;	O
case	O
DT_DEPAUDIT	int
:	O
return	O
"DEPAUDIT"	pointer
;	O
case	O
DT_AUDIT	int
:	O
return	O
"AUDIT"	pointer
;	O
case	O
DT_PLTPAD	int
:	O
return	O
"PLTPAD"	pointer
;	O
case	O
DT_MOVETAB	int
:	O
return	O
"MOVETAB"	pointer
;	O
case	O
DT_SYMINFO	int
:	O
return	O
"SYMINFO"	pointer
;	O
case	O
DT_VERSYM	int
:	O
return	O
"VERSYM"	pointer
;	O
case	O
DT_TLSDESC_GOT	int
:	O
return	O
"TLSDESC_GOT"	pointer
;	O
case	O
DT_TLSDESC_PLT	int
:	O
return	O
"TLSDESC_PLT"	pointer
;	O
case	O
DT_RELACOUNT	int
:	O
return	O
"RELACOUNT"	pointer
;	O
case	O
DT_RELCOUNT	int
:	O
return	O
"RELCOUNT"	pointer
;	O
case	O
DT_FLAGS_1	int
:	O
return	O
"FLAGS_1"	pointer
;	O
case	O
DT_VERDEF	int
:	O
return	O
"VERDEF"	pointer
;	O
case	O
DT_VERDEFNUM	int
:	O
return	O
"VERDEFNUM"	pointer
;	O
case	O
DT_VERNEED	int
:	O
return	O
"VERNEED"	pointer
;	O
case	O
DT_VERNEEDNUM	int
:	O
return	O
"VERNEEDNUM"	pointer
;	O
case	O
DT_AUXILIARY	int
:	O
return	O
"AUXILIARY"	pointer
;	O
case	O
DT_USED	int
:	O
return	O
"USED"	pointer
;	O
case	O
DT_FILTER	int
:	O
return	O
"FILTER"	pointer
;	O
case	O
DT_GNU_PRELINKED	int
:	O
return	O
"GNU_PRELINKED"	pointer
;	O
case	O
DT_GNU_CONFLICT	int
:	O
return	O
"GNU_CONFLICT"	pointer
;	O
case	O
DT_GNU_CONFLICTSZ	int
:	O
return	O
"GNU_CONFLICTSZ"	pointer
;	O
case	O
DT_GNU_LIBLIST	int
:	O
return	O
"GNU_LIBLIST"	pointer
;	O
case	O
DT_GNU_LIBLISTSZ	int
:	O
return	O
"GNU_LIBLISTSZ"	pointer
;	O
case	O
DT_GNU_HASH	int
:	O
return	O
"GNU_HASH"	pointer
;	O
default	O
:	O
if	O
(	O
(	O
type	enum
>=	O
DT_LOPROC	int
)	O
&&	O
(	O
type	enum
<=	O
DT_HIPROC	int
)	O
)	O
{	O
const	O
char	O
*	O
result	pointer
;	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
case	O
EM_AARCH64	int
:	O
result	pointer
=	O
get_aarch64_dynamic_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_MIPS	int
:	O
case	O
EM_MIPS_RS3_LE	int
:	O
result	pointer
=	O
get_mips_dynamic_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_SPARCV9	int
:	O
result	pointer
=	O
get_sparc64_dynamic_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_PPC	int
:	O
result	pointer
=	O
get_ppc_dynamic_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_PPC64	int
:	O
result	pointer
=	O
get_ppc64_dynamic_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_IA_64	int
:	O
result	pointer
=	O
get_ia64_dynamic_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_ALPHA	int
:	O
result	pointer
=	O
get_alpha_dynamic_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_SCORE	int
:	O
result	pointer
=	O
get_score_dynamic_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_TI_C6000	int
:	O
result	pointer
=	O
get_tic6x_dynamic_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_ALTERA_NIOS2	int
:	O
result	pointer
=	O
get_nios2_dynamic_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_ident	array
[	O
EI_OSABI	int
]	O
==	O
ELFOSABI_SOLARIS	int
)	O
result	pointer
=	O
get_solaris_dynamic_type	function
(	O
type	enum
)	O
;	O
else	O
result	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
if	O
(	O
result	pointer
!=	O
NULL	O
)	O
return	O
result	pointer
;	O
snprintf	function
(	O
buff	array
,	O
sizeof	O
(	O
buff	array
)	O
,	O
_	O
(	O
"Processor Specific: %lx"	pointer
)	O
,	O
type	enum
)	O
;	O
}	O
else	O
if	O
(	O
(	O
(	O
type	enum
>=	O
DT_LOOS	int
)	O
&&	O
(	O
type	enum
<=	O
DT_HIOS	int
)	O
)	O
||	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_PARISC	int
&&	O
(	O
type	enum
>=	O
OLD_DT_LOOS	int
)	O
&&	O
(	O
type	enum
<=	O
OLD_DT_HIOS	int
)	O
)	O
)	O
{	O
const	O
char	O
*	O
result	pointer
;	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
case	O
EM_PARISC	int
:	O
result	pointer
=	O
get_parisc_dynamic_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
case	O
EM_IA_64	int
:	O
result	pointer
=	O
get_ia64_dynamic_type	function
(	O
type	enum
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_ident	array
[	O
EI_OSABI	int
]	O
==	O
ELFOSABI_SOLARIS	int
)	O
result	pointer
=	O
get_solaris_dynamic_type	function
(	O
type	enum
)	O
;	O
else	O
result	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
if	O
(	O
result	pointer
!=	O
NULL	O
)	O
return	O
result	pointer
;	O
snprintf	function
(	O
buff	array
,	O
sizeof	O
(	O
buff	array
)	O
,	O
_	O
(	O
"Operating System specific: %lx"	pointer
)	O
,	O
type	enum
)	O
;	O
}	O
else	O
snprintf	function
(	O
buff	array
,	O
sizeof	O
(	O
buff	array
)	O
,	O
_	O
(	O
"<unknown>: %lx"	pointer
)	O
,	O
type	enum
)	O
;	O
return	O
buff	array
;	O
}	O
}	O
static	O
char	O
*	O
get_file_type	function
(	O
unsigned	O
e_type	array
)	O
{	O
static	O
char	O
buff	array
[	O
32	int
]	O
;	O
switch	O
(	O
e_type	array
)	O
{	O
case	O
ET_NONE	int
:	O
return	O
_	O
(	O
"NONE (None)"	pointer
)	O
;	O
case	O
ET_REL	int
:	O
return	O
_	O
(	O
"REL (Relocatable file)"	pointer
)	O
;	O
case	O
ET_EXEC	int
:	O
return	O
_	O
(	O
"EXEC (Executable file)"	pointer
)	O
;	O
case	O
ET_DYN	int
:	O
return	O
_	O
(	O
"DYN (Shared object file)"	pointer
)	O
;	O
case	O
ET_CORE	int
:	O
return	O
_	O
(	O
"CORE (Core file)"	pointer
)	O
;	O
default	O
:	O
if	O
(	O
(	O
e_type	array
>=	O
ET_LOPROC	int
)	O
&&	O
(	O
e_type	array
<=	O
ET_HIPROC	int
)	O
)	O
snprintf	function
(	O
buff	array
,	O
sizeof	O
(	O
buff	array
)	O
,	O
_	O
(	O
"Processor Specific: (%x)"	pointer
)	O
,	O
e_type	array
)	O
;	O
else	O
if	O
(	O
(	O
e_type	array
>=	O
ET_LOOS	int
)	O
&&	O
(	O
e_type	array
<=	O
ET_HIOS	int
)	O
)	O
snprintf	function
(	O
buff	array
,	O
sizeof	O
(	O
buff	array
)	O
,	O
_	O
(	O
"OS Specific: (%x)"	pointer
)	O
,	O
e_type	array
)	O
;	O
else	O
snprintf	function
(	O
buff	array
,	O
sizeof	O
(	O
buff	array
)	O
,	O
_	O
(	O
"<unknown>: %x"	pointer
)	O
,	O
e_type	array
)	O
;	O
return	O
buff	array
;	O
}	O
}	O
static	O
char	O
*	O
get_machine_name	function
(	O
unsigned	O
e_machine	array
)	O
{	O
static	O
char	O
buff	array
[	O
64	int
]	O
;	O
switch	O
(	O
e_machine	array
)	O
{	O
case	O
EM_NONE	int
:	O
return	O
_	O
(	O
"None"	pointer
)	O
;	O
case	O
EM_M32	int
:	O
return	O
"WE32100"	pointer
;	O
case	O
EM_SPARC	int
:	O
return	O
"Sparc"	pointer
;	O
case	O
EM_386	int
:	O
return	O
"Intel 80386"	pointer
;	O
case	O
EM_68K	int
:	O
return	O
"MC68000"	pointer
;	O
case	O
EM_88K	int
:	O
return	O
"MC88000"	pointer
;	O
case	O
EM_IAMCU	int
:	O
return	O
"Intel MCU"	pointer
;	O
case	O
EM_860	int
:	O
return	O
"Intel 80860"	pointer
;	O
case	O
EM_MIPS	int
:	O
return	O
"MIPS R3000"	pointer
;	O
case	O
EM_S370	int
:	O
return	O
"IBM System/370"	pointer
;	O
case	O
EM_MIPS_RS3_LE	int
:	O
return	O
"MIPS R4000 big-endian"	pointer
;	O
case	O
EM_OLD_SPARCV9	int
:	O
return	O
"Sparc v9 (old)"	pointer
;	O
case	O
EM_PARISC	int
:	O
return	O
"HPPA"	pointer
;	O
case	O
EM_VPP550	int
:	O
return	O
"Fujitsu VPP500"	pointer
;	O
case	O
EM_SPARC32PLUS	int
:	O
return	O
"Sparc v8+"	pointer
;	O
case	O
EM_960	int
:	O
return	O
"Intel 80960"	pointer
;	O
case	O
EM_PPC	int
:	O
return	O
"PowerPC"	pointer
;	O
case	O
EM_PPC64	int
:	O
return	O
"PowerPC64"	pointer
;	O
case	O
EM_S390_OLD	int
:	O
case	O
EM_S390	int
:	O
return	O
"IBM S/390"	pointer
;	O
case	O
EM_SPU	int
:	O
return	O
"SPU"	pointer
;	O
case	O
EM_V800	int
:	O
return	O
"Renesas V850 (using RH850 ABI)"	pointer
;	O
case	O
EM_FR20	int
:	O
return	O
"Fujitsu FR20"	pointer
;	O
case	O
EM_RH32	int
:	O
return	O
"TRW RH32"	pointer
;	O
case	O
EM_MCORE	int
:	O
return	O
"MCORE"	pointer
;	O
case	O
EM_ARM	int
:	O
return	O
"ARM"	pointer
;	O
case	O
EM_OLD_ALPHA	int
:	O
return	O
"Digital Alpha (old)"	pointer
;	O
case	O
EM_SH	int
:	O
return	O
"Renesas / SuperH SH"	pointer
;	O
case	O
EM_SPARCV9	int
:	O
return	O
"Sparc v9"	pointer
;	O
case	O
EM_TRICORE	int
:	O
return	O
"Siemens Tricore"	pointer
;	O
case	O
EM_ARC	int
:	O
return	O
"ARC"	pointer
;	O
case	O
EM_H8_300	int
:	O
return	O
"Renesas H8/300"	pointer
;	O
case	O
EM_H8_300H	int
:	O
return	O
"Renesas H8/300H"	pointer
;	O
case	O
EM_H8S	int
:	O
return	O
"Renesas H8S"	pointer
;	O
case	O
EM_H8_500	int
:	O
return	O
"Renesas H8/500"	pointer
;	O
case	O
EM_IA_64	int
:	O
return	O
"Intel IA-64"	pointer
;	O
case	O
EM_MIPS_X	int
:	O
return	O
"Stanford MIPS-X"	pointer
;	O
case	O
EM_COLDFIRE	int
:	O
return	O
"Motorola Coldfire"	pointer
;	O
case	O
EM_68HC12	int
:	O
return	O
"Motorola MC68HC12 Microcontroller"	pointer
;	O
case	O
EM_MMA	int
:	O
return	O
"Fujitsu Multimedia Accelerator"	pointer
;	O
case	O
EM_PCP	int
:	O
return	O
"Siemens PCP"	pointer
;	O
case	O
EM_NCPU	int
:	O
return	O
"Sony nCPU embedded RISC processor"	pointer
;	O
case	O
EM_NDR1	int
:	O
return	O
"Denso NDR1 microprocesspr"	pointer
;	O
case	O
EM_STARCORE	int
:	O
return	O
"Motorola Star*Core processor"	pointer
;	O
case	O
EM_ME16	int
:	O
return	O
"Toyota ME16 processor"	pointer
;	O
case	O
EM_ST100	int
:	O
return	O
"STMicroelectronics ST100 processor"	pointer
;	O
case	O
EM_TINYJ	int
:	O
return	O
"Advanced Logic Corp. TinyJ embedded processor"	pointer
;	O
case	O
EM_X86_64	int
:	O
return	O
"Advanced Micro Devices X86-64"	pointer
;	O
case	O
EM_PDSP	int
:	O
return	O
"Sony DSP processor"	pointer
;	O
case	O
EM_PDP10	int
:	O
return	O
"Digital Equipment Corp. PDP-10"	pointer
;	O
case	O
EM_PDP11	int
:	O
return	O
"Digital Equipment Corp. PDP-11"	pointer
;	O
case	O
EM_FX66	int
:	O
return	O
"Siemens FX66 microcontroller"	pointer
;	O
case	O
EM_ST9PLUS	int
:	O
return	O
"STMicroelectronics ST9+ 8/16 bit microcontroller"	pointer
;	O
case	O
EM_ST7	int
:	O
return	O
"STMicroelectronics ST7 8-bit microcontroller"	pointer
;	O
case	O
EM_68HC16	int
:	O
return	O
"Motorola MC68HC16 Microcontroller"	pointer
;	O
case	O
EM_68HC11	int
:	O
return	O
"Motorola MC68HC11 Microcontroller"	pointer
;	O
case	O
EM_68HC08	int
:	O
return	O
"Motorola MC68HC08 Microcontroller"	pointer
;	O
case	O
EM_68HC05	int
:	O
return	O
"Motorola MC68HC05 Microcontroller"	pointer
;	O
case	O
EM_SVX	int
:	O
return	O
"Silicon Graphics SVx"	pointer
;	O
case	O
EM_ST19	int
:	O
return	O
"STMicroelectronics ST19 8-bit microcontroller"	pointer
;	O
case	O
EM_VAX	int
:	O
return	O
"Digital VAX"	pointer
;	O
case	O
EM_CRIS	int
:	O
return	O
"Axis Communications 32-bit embedded processor"	pointer
;	O
case	O
EM_JAVELIN	int
:	O
return	O
"Infineon Technologies 32-bit embedded cpu"	pointer
;	O
case	O
EM_FIREPATH	int
:	O
return	O
"Element 14 64-bit DSP processor"	pointer
;	O
case	O
EM_ZSP	int
:	O
return	O
"LSI Logic's 16-bit DSP processor"	pointer
;	O
case	O
EM_MMIX	int
:	O
return	O
"Donald Knuth's educational 64-bit processor"	pointer
;	O
case	O
EM_HUANY	int
:	O
return	O
"Harvard Universitys's machine-independent object format"	pointer
;	O
case	O
EM_PRISM	int
:	O
return	O
"Vitesse Prism"	pointer
;	O
case	O
EM_AVR_OLD	int
:	O
case	O
EM_AVR	int
:	O
return	O
"Atmel AVR 8-bit microcontroller"	pointer
;	O
case	O
EM_CYGNUS_FR30	int
:	O
case	O
EM_FR30	int
:	O
return	O
"Fujitsu FR30"	pointer
;	O
case	O
EM_CYGNUS_D10V	int
:	O
case	O
EM_D10V	int
:	O
return	O
"d10v"	pointer
;	O
case	O
EM_CYGNUS_D30V	int
:	O
case	O
EM_D30V	int
:	O
return	O
"d30v"	pointer
;	O
case	O
EM_CYGNUS_V850	int
:	O
case	O
EM_V850	int
:	O
return	O
"Renesas V850"	pointer
;	O
case	O
EM_CYGNUS_M32R	int
:	O
case	O
EM_M32R	int
:	O
return	O
"Renesas M32R (formerly Mitsubishi M32r)"	pointer
;	O
case	O
EM_CYGNUS_MN10300	int
:	O
case	O
EM_MN10300	int
:	O
return	O
"mn10300"	pointer
;	O
case	O
EM_CYGNUS_MN10200	int
:	O
case	O
EM_MN10200	int
:	O
return	O
"mn10200"	pointer
;	O
case	O
EM_PJ	int
:	O
return	O
"picoJava"	pointer
;	O
case	O
EM_OR1K	int
:	O
return	O
"OpenRISC 1000"	pointer
;	O
case	O
EM_ARC_COMPACT	int
:	O
return	O
"ARCompact"	pointer
;	O
case	O
EM_XTENSA_OLD	int
:	O
case	O
EM_XTENSA	int
:	O
return	O
"Tensilica Xtensa Processor"	pointer
;	O
case	O
EM_VIDEOCORE	int
:	O
return	O
"Alphamosaic VideoCore processor"	pointer
;	O
case	O
EM_TMM_GPP	int
:	O
return	O
"Thompson Multimedia General Purpose Processor"	pointer
;	O
case	O
EM_NS32K	int
:	O
return	O
"National Semiconductor 32000 series"	pointer
;	O
case	O
EM_TPC	int
:	O
return	O
"Tenor Network TPC processor"	pointer
;	O
case	O
EM_SNP1K	int
:	O
return	O
"Trebia SNP 1000 processor"	pointer
;	O
case	O
EM_ST200	int
:	O
return	O
"STMicroelectronics ST200 microcontroller"	pointer
;	O
case	O
EM_IP2K_OLD	int
:	O
case	O
EM_IP2K	int
:	O
return	O
"Ubicom IP2xxx 8-bit microcontrollers"	pointer
;	O
case	O
EM_MAX	int
:	O
return	O
"MAX Processor"	pointer
;	O
case	O
EM_CR	int
:	O
return	O
"National Semiconductor CompactRISC"	pointer
;	O
case	O
EM_F2MC16	int
:	O
return	O
"Fujitsu F2MC16"	pointer
;	O
case	O
EM_MSP430	int
:	O
return	O
"Texas Instruments msp430 microcontroller"	pointer
;	O
case	O
EM_BLACKFIN	int
:	O
return	O
"Analog Devices Blackfin"	pointer
;	O
case	O
EM_SE_C33	int
:	O
return	O
"S1C33 Family of Seiko Epson processors"	pointer
;	O
case	O
EM_SEP	int
:	O
return	O
"Sharp embedded microprocessor"	pointer
;	O
case	O
EM_ARCA	int
:	O
return	O
"Arca RISC microprocessor"	pointer
;	O
case	O
EM_UNICORE	int
:	O
return	O
"Unicore"	pointer
;	O
case	O
EM_EXCESS	int
:	O
return	O
"eXcess 16/32/64-bit configurable embedded CPU"	pointer
;	O
case	O
EM_DXP	int
:	O
return	O
"Icera Semiconductor Inc. Deep Execution Processor"	pointer
;	O
case	O
EM_ALTERA_NIOS2	int
:	O
return	O
"Altera Nios II"	pointer
;	O
case	O
EM_CRX	int
:	O
return	O
"National Semiconductor CRX microprocessor"	pointer
;	O
case	O
EM_XGATE	int
:	O
return	O
"Motorola XGATE embedded processor"	pointer
;	O
case	O
EM_C166	int
:	O
case	O
EM_XC16X	int
:	O
return	O
"Infineon Technologies xc16x"	pointer
;	O
case	O
EM_M16C	int
:	O
return	O
"Renesas M16C series microprocessors"	pointer
;	O
case	O
EM_DSPIC30F	int
:	O
return	O
"Microchip Technology dsPIC30F Digital Signal Controller"	pointer
;	O
case	O
EM_CE	int
:	O
return	O
"Freescale Communication Engine RISC core"	pointer
;	O
case	O
EM_M32C	int
:	O
return	O
"Renesas M32c"	pointer
;	O
case	O
EM_TSK3000	int
:	O
return	O
"Altium TSK3000 core"	pointer
;	O
case	O
EM_RS08	int
:	O
return	O
"Freescale RS08 embedded processor"	pointer
;	O
case	O
EM_ECOG2	int
:	O
return	O
"Cyan Technology eCOG2 microprocessor"	pointer
;	O
case	O
EM_SCORE	int
:	O
return	O
"SUNPLUS S+Core"	pointer
;	O
case	O
EM_DSP24	int
:	O
return	O
"New Japan Radio (NJR) 24-bit DSP Processor"	pointer
;	O
case	O
EM_VIDEOCORE3	int
:	O
return	O
"Broadcom VideoCore III processor"	pointer
;	O
case	O
EM_LATTICEMICO32	int
:	O
return	O
"Lattice Mico32"	pointer
;	O
case	O
EM_SE_C17	int
:	O
return	O
"Seiko Epson C17 family"	pointer
;	O
case	O
EM_TI_C6000	int
:	O
return	O
"Texas Instruments TMS320C6000 DSP family"	pointer
;	O
case	O
EM_TI_C2000	int
:	O
return	O
"Texas Instruments TMS320C2000 DSP family"	pointer
;	O
case	O
EM_TI_C5500	int
:	O
return	O
"Texas Instruments TMS320C55x DSP family"	pointer
;	O
case	O
EM_TI_PRU	int
:	O
return	O
"TI PRU I/O processor"	pointer
;	O
case	O
EM_MMDSP_PLUS	int
:	O
return	O
"STMicroelectronics 64bit VLIW Data Signal Processor"	pointer
;	O
case	O
EM_CYPRESS_M8C	int
:	O
return	O
"Cypress M8C microprocessor"	pointer
;	O
case	O
EM_R32C	int
:	O
return	O
"Renesas R32C series microprocessors"	pointer
;	O
case	O
EM_TRIMEDIA	int
:	O
return	O
"NXP Semiconductors TriMedia architecture family"	pointer
;	O
case	O
EM_QDSP6	int
:	O
return	O
"QUALCOMM DSP6 Processor"	pointer
;	O
case	O
EM_8051	int
:	O
return	O
"Intel 8051 and variants"	pointer
;	O
case	O
EM_STXP7X	int
:	O
return	O
"STMicroelectronics STxP7x family"	pointer
;	O
case	O
EM_NDS32	int
:	O
return	O
"Andes Technology compact code size embedded RISC processor family"	pointer
;	O
case	O
EM_ECOG1X	int
:	O
return	O
"Cyan Technology eCOG1X family"	pointer
;	O
case	O
EM_MAXQ30	int
:	O
return	O
"Dallas Semiconductor MAXQ30 Core microcontrollers"	pointer
;	O
case	O
EM_XIMO16	int
:	O
return	O
"New Japan Radio (NJR) 16-bit DSP Processor"	pointer
;	O
case	O
EM_MANIK	int
:	O
return	O
"M2000 Reconfigurable RISC Microprocessor"	pointer
;	O
case	O
EM_CRAYNV2	int
:	O
return	O
"Cray Inc. NV2 vector architecture"	pointer
;	O
case	O
EM_RX	int
:	O
return	O
"Renesas RX"	pointer
;	O
case	O
EM_METAG	int
:	O
return	O
"Imagination Technologies Meta processor architecture"	pointer
;	O
case	O
EM_MCST_ELBRUS	int
:	O
return	O
"MCST Elbrus general purpose hardware architecture"	pointer
;	O
case	O
EM_ECOG16	int
:	O
return	O
"Cyan Technology eCOG16 family"	pointer
;	O
case	O
EM_CR16	int
:	O
case	O
EM_MICROBLAZE	int
:	O
case	O
EM_MICROBLAZE_OLD	int
:	O
return	O
"Xilinx MicroBlaze"	pointer
;	O
case	O
EM_ETPU	int
:	O
return	O
"Freescale Extended Time Processing Unit"	pointer
;	O
case	O
EM_SLE9X	int
:	O
return	O
"Infineon Technologies SLE9X core"	pointer
;	O
case	O
EM_L1OM	int
:	O
return	O
"Intel L1OM"	pointer
;	O
case	O
EM_K1OM	int
:	O
return	O
"Intel K1OM"	pointer
;	O
case	O
EM_INTEL182	int
:	O
return	O
"Intel (reserved)"	pointer
;	O
case	O
EM_AARCH64	int
:	O
return	O
"AArch64"	pointer
;	O
case	O
EM_ARM184	int
:	O
return	O
"ARM (reserved)"	pointer
;	O
case	O
EM_AVR32	int
:	O
return	O
"Atmel Corporation 32-bit microprocessor"	pointer
;	O
case	O
EM_STM8	int
:	O
return	O
"STMicroeletronics STM8 8-bit microcontroller"	pointer
;	O
case	O
EM_TILE64	int
:	O
return	O
"Tilera TILE64 multicore architecture family"	pointer
;	O
case	O
EM_TILEPRO	int
:	O
return	O
"Tilera TILEPro multicore architecture family"	pointer
;	O
case	O
EM_CUDA	int
:	O
return	O
"NVIDIA CUDA architecture"	pointer
;	O
case	O
EM_TILEGX	int
:	O
return	O
"Tilera TILE-Gx multicore architecture family"	pointer
;	O
case	O
EM_CLOUDSHIELD	int
:	O
return	O
"CloudShield architecture family"	pointer
;	O
case	O
EM_COREA_1ST	int
:	O
return	O
"KIPO-KAIST Core-A 1st generation processor family"	pointer
;	O
case	O
EM_COREA_2ND	int
:	O
return	O
"KIPO-KAIST Core-A 2nd generation processor family"	pointer
;	O
case	O
EM_ARC_COMPACT2	int
:	O
return	O
"ARCv2"	pointer
;	O
case	O
EM_OPEN8	int
:	O
return	O
"Open8 8-bit RISC soft processor core"	pointer
;	O
case	O
EM_RL78	int
:	O
return	O
"Renesas RL78"	pointer
;	O
case	O
EM_VIDEOCORE5	int
:	O
return	O
"Broadcom VideoCore V processor"	pointer
;	O
case	O
EM_78K0R	int
:	O
return	O
"Renesas 78K0R"	pointer
;	O
case	O
EM_56800EX	int
:	O
return	O
"Freescale 56800EX Digital Signal Controller (DSC)"	pointer
;	O
case	O
EM_BA1	int
:	O
return	O
"Beyond BA1 CPU architecture"	pointer
;	O
case	O
EM_BA2	int
:	O
return	O
"Beyond BA2 CPU architecture"	pointer
;	O
case	O
EM_XCORE	int
:	O
return	O
"XMOS xCORE processor family"	pointer
;	O
case	O
EM_MCHP_PIC	int
:	O
return	O
"Microchip 8-bit PIC(r) family"	pointer
;	O
case	O
EM_KM32	int
:	O
return	O
"KM211 KM32 32-bit processor"	pointer
;	O
case	O
EM_KMX32	int
:	O
return	O
"KM211 KMX32 32-bit processor"	pointer
;	O
case	O
EM_KMX16	int
:	O
return	O
"KM211 KMX16 16-bit processor"	pointer
;	O
case	O
EM_KMX8	int
:	O
return	O
"KM211 KMX8 8-bit processor"	pointer
;	O
case	O
EM_KVARC	int
:	O
return	O
"KM211 KVARC processor"	pointer
;	O
case	O
EM_CDP	int
:	O
return	O
"Paneve CDP architecture family"	pointer
;	O
case	O
EM_COGE	int
:	O
return	O
"Cognitive Smart Memory Processor"	pointer
;	O
case	O
EM_COOL	int
:	O
return	O
"Bluechip Systems CoolEngine"	pointer
;	O
case	O
EM_NORC	int
:	O
return	O
"Nanoradio Optimized RISC"	pointer
;	O
case	O
EM_CSR_KALIMBA	int
:	O
return	O
"CSR Kalimba architecture family"	pointer
;	O
case	O
EM_Z80	int
:	O
return	O
"Zilog Z80"	pointer
;	O
case	O
EM_VISIUM	int
:	O
return	O
"CDS VISIUMcore processor"	pointer
;	O
case	O
EM_FT32	int
:	O
return	O
"FTDI Chip FT32"	pointer
;	O
case	O
EM_MOXIE	int
:	O
return	O
"Moxie"	pointer
;	O
case	O
EM_AMDGPU	int
:	O
return	O
"AMD GPU"	pointer
;	O
case	O
EM_RISCV	int
:	O
return	O
"RISC-V"	pointer
;	O
case	O
EM_LANAI	int
:	O
return	O
"Lanai 32-bit processor"	pointer
;	O
case	O
EM_BPF	int
:	O
return	O
"Linux BPF"	pointer
;	O
case	O
EM_NFP	int
:	O
return	O
"Netronome Flow Processor"	pointer
;	O
case	O
EM_MT	int
:	O
return	O
"Morpho Techologies MT processor"	pointer
;	O
case	O
EM_ALPHA	int
:	O
return	O
"Alpha"	pointer
;	O
case	O
EM_WEBASSEMBLY	int
:	O
return	O
"Web Assembly"	pointer
;	O
case	O
EM_DLX	int
:	O
return	O
"OpenDLX"	pointer
;	O
case	O
EM_XSTORMY16	int
:	O
return	O
"Sanyo XStormy16 CPU core"	pointer
;	O
case	O
EM_IQ2000	int
:	O
return	O
"Vitesse IQ2000"	pointer
;	O
case	O
EM_M32C_OLD	int
:	O
case	O
EM_NIOS32	int
:	O
return	O
"Altera Nios"	pointer
;	O
case	O
EM_CYGNUS_MEP	int
:	O
return	O
"Toshiba MeP Media Engine"	pointer
;	O
case	O
EM_ADAPTEVA_EPIPHANY	int
:	O
return	O
"Adapteva EPIPHANY"	pointer
;	O
case	O
EM_CYGNUS_FRV	int
:	O
return	O
"Fujitsu FR-V"	pointer
;	O
case	O
EM_S12Z	int
:	O
return	O
"Freescale S12Z"	pointer
;	O
case	O
EM_CSKY	int
:	O
return	O
"C-SKY"	pointer
;	O
default	O
:	O
snprintf	function
(	O
buff	array
,	O
sizeof	O
(	O
buff	array
)	O
,	O
_	O
(	O
"<unknown>: 0x%x"	pointer
)	O
,	O
e_machine	array
)	O
;	O
return	O
buff	array
;	O
}	O
}	O
static	O
void	O
decode_ARC_machine_flags	function
(	O
unsigned	O
e_flags	array
,	O
unsigned	O
e_machine	array
,	O
char	O
buf	pointer
[	O
]	O
)	O
{	O
switch	O
(	O
e_flags	array
&	O
EF_ARC_MACH_MSK	int
)	O
{	O
case	O
EF_ARC_CPU_ARCV2EM	int
:	O
strcat	function
(	O
buf	pointer
,	O
", ARC EM"	pointer
)	O
;	O
break	O
;	O
case	O
EF_ARC_CPU_ARCV2HS	int
:	O
strcat	function
(	O
buf	pointer
,	O
", ARC HS"	pointer
)	O
;	O
break	O
;	O
case	O
E_ARC_MACH_ARC600	int
:	O
strcat	function
(	O
buf	pointer
,	O
", ARC600"	pointer
)	O
;	O
break	O
;	O
case	O
E_ARC_MACH_ARC601	int
:	O
strcat	function
(	O
buf	pointer
,	O
", ARC601"	pointer
)	O
;	O
break	O
;	O
case	O
E_ARC_MACH_ARC700	int
:	O
strcat	function
(	O
buf	pointer
,	O
", ARC700"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
e_machine	array
==	O
EM_ARC_COMPACT	int
)	O
strcat	function
(	O
buf	pointer
,	O
", Unknown ARCompact"	pointer
)	O
;	O
else	O
strcat	function
(	O
buf	pointer
,	O
", Unknown ARC"	pointer
)	O
;	O
break	O
;	O
}	O
switch	O
(	O
e_flags	array
&	O
EF_ARC_OSABI_MSK	int
)	O
{	O
case	O
E_ARC_OSABI_ORIG	int
:	O
strcat	function
(	O
buf	pointer
,	O
", (ABI:legacy)"	pointer
)	O
;	O
break	O
;	O
case	O
E_ARC_OSABI_V2	int
:	O
strcat	function
(	O
buf	pointer
,	O
", (ABI:v2)"	pointer
)	O
;	O
break	O
;	O
case	O
E_ARC_OSABI_V3	int
:	O
strcat	function
(	O
buf	pointer
,	O
", v3 no-legacy-syscalls ABI"	pointer
)	O
;	O
break	O
;	O
case	O
E_ARC_OSABI_V4	int
:	O
strcat	function
(	O
buf	pointer
,	O
", v4 ABI"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
strcat	function
(	O
buf	pointer
,	O
", unrecognised ARC OSABI flag"	pointer
)	O
;	O
break	O
;	O
}	O
}	O
static	O
void	O
decode_ARM_machine_flags	function
(	O
unsigned	O
e_flags	array
,	O
char	O
buf	pointer
[	O
]	O
)	O
{	O
unsigned	O
eabi	int
;	O
bfd_boolean	int
unknown	int
=	O
FALSE	int
;	O
eabi	int
=	O
EF_ARM_EABI_VERSION	O
(	O
e_flags	array
)	O
;	O
e_flags	array
&=	O
~	O
EF_ARM_EABIMASK	int
;	O
if	O
(	O
e_flags	array
&	O
EF_ARM_RELEXEC	int
)	O
{	O
strcat	function
(	O
buf	pointer
,	O
", relocatable executable"	pointer
)	O
;	O
e_flags	array
&=	O
~	O
EF_ARM_RELEXEC	int
;	O
}	O
if	O
(	O
e_flags	array
&	O
EF_ARM_PIC	int
)	O
{	O
strcat	function
(	O
buf	pointer
,	O
", position independent"	pointer
)	O
;	O
e_flags	array
&=	O
~	O
EF_ARM_PIC	int
;	O
}	O
switch	O
(	O
eabi	int
)	O
{	O
default	O
:	O
strcat	function
(	O
buf	pointer
,	O
", <unrecognized EABI>"	pointer
)	O
;	O
if	O
(	O
e_flags	array
)	O
unknown	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
EF_ARM_EABI_VER1	int
:	O
strcat	function
(	O
buf	pointer
,	O
", Version1 EABI"	pointer
)	O
;	O
while	O
(	O
e_flags	array
)	O
{	O
unsigned	O
flag	int
;	O
flag	int
=	O
e_flags	array
&	O
-	O
e_flags	array
;	O
e_flags	array
&=	O
~	O
flag	int
;	O
switch	O
(	O
flag	int
)	O
{	O
case	O
EF_ARM_SYMSARESORTED	int
:	O
strcat	function
(	O
buf	pointer
,	O
", sorted symbol tables"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
unknown	int
=	O
TRUE	int
;	O
break	O
;	O
}	O
}	O
break	O
;	O
case	O
EF_ARM_EABI_VER2	int
:	O
strcat	function
(	O
buf	pointer
,	O
", Version2 EABI"	pointer
)	O
;	O
while	O
(	O
e_flags	array
)	O
{	O
unsigned	O
flag	int
;	O
flag	int
=	O
e_flags	array
&	O
-	O
e_flags	array
;	O
e_flags	array
&=	O
~	O
flag	int
;	O
switch	O
(	O
flag	int
)	O
{	O
case	O
EF_ARM_SYMSARESORTED	int
:	O
strcat	function
(	O
buf	pointer
,	O
", sorted symbol tables"	pointer
)	O
;	O
break	O
;	O
case	O
EF_ARM_DYNSYMSUSESEGIDX	int
:	O
strcat	function
(	O
buf	pointer
,	O
", dynamic symbols use segment index"	pointer
)	O
;	O
break	O
;	O
case	O
EF_ARM_MAPSYMSFIRST	int
:	O
strcat	function
(	O
buf	pointer
,	O
", mapping symbols precede others"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
unknown	int
=	O
TRUE	int
;	O
break	O
;	O
}	O
}	O
break	O
;	O
case	O
EF_ARM_EABI_VER3	int
:	O
strcat	function
(	O
buf	pointer
,	O
", Version3 EABI"	pointer
)	O
;	O
break	O
;	O
case	O
EF_ARM_EABI_VER4	int
:	O
strcat	function
(	O
buf	pointer
,	O
", Version4 EABI"	pointer
)	O
;	O
while	O
(	O
e_flags	array
)	O
{	O
unsigned	O
flag	int
;	O
flag	int
=	O
e_flags	array
&	O
-	O
e_flags	array
;	O
e_flags	array
&=	O
~	O
flag	int
;	O
switch	O
(	O
flag	int
)	O
{	O
case	O
EF_ARM_BE8	int
:	O
strcat	function
(	O
buf	pointer
,	O
", BE8"	pointer
)	O
;	O
break	O
;	O
case	O
EF_ARM_LE8	int
:	O
strcat	function
(	O
buf	pointer
,	O
", LE8"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
unknown	int
=	O
TRUE	int
;	O
break	O
;	O
}	O
}	O
break	O
;	O
case	O
EF_ARM_EABI_VER5	int
:	O
strcat	function
(	O
buf	pointer
,	O
", Version5 EABI"	pointer
)	O
;	O
while	O
(	O
e_flags	array
)	O
{	O
unsigned	O
flag	int
;	O
flag	int
=	O
e_flags	array
&	O
-	O
e_flags	array
;	O
e_flags	array
&=	O
~	O
flag	int
;	O
switch	O
(	O
flag	int
)	O
{	O
case	O
EF_ARM_BE8	int
:	O
strcat	function
(	O
buf	pointer
,	O
", BE8"	pointer
)	O
;	O
break	O
;	O
case	O
EF_ARM_LE8	int
:	O
strcat	function
(	O
buf	pointer
,	O
", LE8"	pointer
)	O
;	O
break	O
;	O
case	O
EF_ARM_ABI_FLOAT_SOFT	int
:	O
strcat	function
(	O
buf	pointer
,	O
", soft-float ABI"	pointer
)	O
;	O
break	O
;	O
case	O
EF_ARM_ABI_FLOAT_HARD	int
:	O
strcat	function
(	O
buf	pointer
,	O
", hard-float ABI"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
unknown	int
=	O
TRUE	int
;	O
break	O
;	O
}	O
}	O
break	O
;	O
case	O
EF_ARM_EABI_UNKNOWN	int
:	O
strcat	function
(	O
buf	pointer
,	O
", GNU EABI"	pointer
)	O
;	O
while	O
(	O
e_flags	array
)	O
{	O
unsigned	O
flag	int
;	O
flag	int
=	O
e_flags	array
&	O
-	O
e_flags	array
;	O
e_flags	array
&=	O
~	O
flag	int
;	O
switch	O
(	O
flag	int
)	O
{	O
case	O
EF_ARM_INTERWORK	int
:	O
strcat	function
(	O
buf	pointer
,	O
", interworking enabled"	pointer
)	O
;	O
break	O
;	O
case	O
EF_ARM_APCS_26	int
:	O
strcat	function
(	O
buf	pointer
,	O
", uses APCS/26"	pointer
)	O
;	O
break	O
;	O
case	O
EF_ARM_APCS_FLOAT	int
:	O
strcat	function
(	O
buf	pointer
,	O
", uses APCS/float"	pointer
)	O
;	O
break	O
;	O
case	O
EF_ARM_PIC	int
:	O
strcat	function
(	O
buf	pointer
,	O
", position independent"	pointer
)	O
;	O
break	O
;	O
case	O
EF_ARM_ALIGN8	int
:	O
strcat	function
(	O
buf	pointer
,	O
", 8 bit structure alignment"	pointer
)	O
;	O
break	O
;	O
case	O
EF_ARM_NEW_ABI	int
:	O
strcat	function
(	O
buf	pointer
,	O
", uses new ABI"	pointer
)	O
;	O
break	O
;	O
case	O
EF_ARM_OLD_ABI	int
:	O
strcat	function
(	O
buf	pointer
,	O
", uses old ABI"	pointer
)	O
;	O
break	O
;	O
case	O
EF_ARM_SOFT_FLOAT	int
:	O
strcat	function
(	O
buf	pointer
,	O
", software FP"	pointer
)	O
;	O
break	O
;	O
case	O
EF_ARM_VFP_FLOAT	int
:	O
strcat	function
(	O
buf	pointer
,	O
", VFP"	pointer
)	O
;	O
break	O
;	O
case	O
EF_ARM_MAVERICK_FLOAT	int
:	O
strcat	function
(	O
buf	pointer
,	O
", Maverick FP"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
unknown	int
=	O
TRUE	int
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
unknown	int
)	O
strcat	function
(	O
buf	pointer
,	O
_	O
(	O
", <unknown>"	pointer
)	O
)	O
;	O
}	O
static	O
void	O
decode_AVR_machine_flags	function
(	O
unsigned	O
e_flags	array
,	O
char	O
buf	pointer
[	O
]	O
,	O
size_t	long
size	int
)	O
{	O
--	O
size	int
;	O
switch	O
(	O
e_flags	array
&	O
EF_AVR_MACH	int
)	O
{	O
case	O
E_AVR_MACH_AVR1	int
:	O
strncat	function
(	O
buf	pointer
,	O
", avr:1"	pointer
,	O
size	int
)	O
;	O
break	O
;	O
case	O
E_AVR_MACH_AVR2	int
:	O
strncat	function
(	O
buf	pointer
,	O
", avr:2"	pointer
,	O
size	int
)	O
;	O
break	O
;	O
case	O
E_AVR_MACH_AVR25	int
:	O
strncat	function
(	O
buf	pointer
,	O
", avr:25"	pointer
,	O
size	int
)	O
;	O
break	O
;	O
case	O
E_AVR_MACH_AVR3	int
:	O
strncat	function
(	O
buf	pointer
,	O
", avr:3"	pointer
,	O
size	int
)	O
;	O
break	O
;	O
case	O
E_AVR_MACH_AVR31	int
:	O
strncat	function
(	O
buf	pointer
,	O
", avr:31"	pointer
,	O
size	int
)	O
;	O
break	O
;	O
case	O
E_AVR_MACH_AVR35	int
:	O
strncat	function
(	O
buf	pointer
,	O
", avr:35"	pointer
,	O
size	int
)	O
;	O
break	O
;	O
case	O
E_AVR_MACH_AVR4	int
:	O
strncat	function
(	O
buf	pointer
,	O
", avr:4"	pointer
,	O
size	int
)	O
;	O
break	O
;	O
case	O
E_AVR_MACH_AVR5	int
:	O
strncat	function
(	O
buf	pointer
,	O
", avr:5"	pointer
,	O
size	int
)	O
;	O
break	O
;	O
case	O
E_AVR_MACH_AVR51	int
:	O
strncat	function
(	O
buf	pointer
,	O
", avr:51"	pointer
,	O
size	int
)	O
;	O
break	O
;	O
case	O
E_AVR_MACH_AVR6	int
:	O
strncat	function
(	O
buf	pointer
,	O
", avr:6"	pointer
,	O
size	int
)	O
;	O
break	O
;	O
case	O
E_AVR_MACH_AVRTINY	int
:	O
strncat	function
(	O
buf	pointer
,	O
", avr:100"	pointer
,	O
size	int
)	O
;	O
break	O
;	O
case	O
E_AVR_MACH_XMEGA1	int
:	O
strncat	function
(	O
buf	pointer
,	O
", avr:101"	pointer
,	O
size	int
)	O
;	O
break	O
;	O
case	O
E_AVR_MACH_XMEGA2	int
:	O
strncat	function
(	O
buf	pointer
,	O
", avr:102"	pointer
,	O
size	int
)	O
;	O
break	O
;	O
case	O
E_AVR_MACH_XMEGA3	int
:	O
strncat	function
(	O
buf	pointer
,	O
", avr:103"	pointer
,	O
size	int
)	O
;	O
break	O
;	O
case	O
E_AVR_MACH_XMEGA4	int
:	O
strncat	function
(	O
buf	pointer
,	O
", avr:104"	pointer
,	O
size	int
)	O
;	O
break	O
;	O
case	O
E_AVR_MACH_XMEGA5	int
:	O
strncat	function
(	O
buf	pointer
,	O
", avr:105"	pointer
,	O
size	int
)	O
;	O
break	O
;	O
case	O
E_AVR_MACH_XMEGA6	int
:	O
strncat	function
(	O
buf	pointer
,	O
", avr:106"	pointer
,	O
size	int
)	O
;	O
break	O
;	O
case	O
E_AVR_MACH_XMEGA7	int
:	O
strncat	function
(	O
buf	pointer
,	O
", avr:107"	pointer
,	O
size	int
)	O
;	O
break	O
;	O
default	O
:	O
strncat	function
(	O
buf	pointer
,	O
", avr:<unknown>"	pointer
,	O
size	int
)	O
;	O
break	O
;	O
}	O
size	int
-=	O
strlen	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
e_flags	array
&	O
EF_AVR_LINKRELAX_PREPARED	int
)	O
strncat	function
(	O
buf	pointer
,	O
", link-relax"	pointer
,	O
size	int
)	O
;	O
}	O
static	O
void	O
decode_NDS32_machine_flags	function
(	O
unsigned	O
e_flags	array
,	O
char	O
buf	pointer
[	O
]	O
,	O
size_t	long
size	int
)	O
{	O
unsigned	O
abi	int
;	O
unsigned	O
arch	enum
;	O
unsigned	O
config	int
;	O
unsigned	O
version	pointer
;	O
bfd_boolean	int
has_fpu	int
=	O
FALSE	int
;	O
unsigned	O
int	O
r	int
=	O
0	int
;	O
static	O
const	O
char	O
*	O
ABI_STRINGS	array
[	O
]	O
=	O
{	O
"ABI v0"	pointer
,	O
"ABI v1"	pointer
,	O
"ABI v2"	pointer
,	O
"ABI v2fp"	pointer
,	O
"AABI"	pointer
,	O
"ABI2 FP+"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
VER_STRINGS	array
[	O
]	O
=	O
{	O
"Andes ELF V1.3 or older"	pointer
,	O
"Andes ELF V1.3.1"	pointer
,	O
"Andes ELF V1.4"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
ARCH_STRINGS	array
[	O
]	O
=	O
{	O
""	pointer
,	O
"Andes Star v1.0"	pointer
,	O
"Andes Star v2.0"	pointer
,	O
"Andes Star v3.0"	pointer
,	O
"Andes Star v3.0m"	pointer
}	O
;	O
abi	int
=	O
EF_NDS_ABI	int
&	O
e_flags	array
;	O
arch	enum
=	O
EF_NDS_ARCH	int
&	O
e_flags	array
;	O
config	int
=	O
EF_NDS_INST	int
&	O
e_flags	array
;	O
version	pointer
=	O
EF_NDS32_ELF_VERSION	int
&	O
e_flags	array
;	O
memset	function
(	O
buf	pointer
,	O
0	int
,	O
size	int
)	O
;	O
switch	O
(	O
abi	int
)	O
{	O
case	O
E_NDS_ABI_V0	int
:	O
case	O
E_NDS_ABI_V1	int
:	O
case	O
E_NDS_ABI_V2	int
:	O
case	O
E_NDS_ABI_V2FP	int
:	O
case	O
E_NDS_ABI_AABI	int
:	O
case	O
E_NDS_ABI_V2FP_PLUS	int
:	O
r	int
+=	O
snprintf	function
(	O
buf	pointer
+	O
r	int
,	O
size	int
-	O
r	int
,	O
", %s"	pointer
,	O
ABI_STRINGS	array
[	O
abi	int
>>	O
EF_NDS_ABI_SHIFT	int
]	O
)	O
;	O
break	O
;	O
default	O
:	O
r	int
+=	O
snprintf	function
(	O
buf	pointer
+	O
r	int
,	O
size	int
-	O
r	int
,	O
", <unrecognized ABI>"	pointer
)	O
;	O
break	O
;	O
}	O
switch	O
(	O
version	pointer
)	O
{	O
case	O
E_NDS32_ELF_VER_1_2	int
:	O
case	O
E_NDS32_ELF_VER_1_3	int
:	O
case	O
E_NDS32_ELF_VER_1_4	int
:	O
r	int
+=	O
snprintf	function
(	O
buf	pointer
+	O
r	int
,	O
size	int
-	O
r	int
,	O
", %s"	pointer
,	O
VER_STRINGS	array
[	O
version	pointer
>>	O
EF_NDS32_ELF_VERSION_SHIFT	int
]	O
)	O
;	O
break	O
;	O
default	O
:	O
r	int
+=	O
snprintf	function
(	O
buf	pointer
+	O
r	int
,	O
size	int
-	O
r	int
,	O
", <unrecognized ELF version number>"	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
E_NDS_ABI_V0	int
==	O
abi	int
)	O
{	O
r	int
+=	O
snprintf	function
(	O
buf	pointer
+	O
r	int
,	O
size	int
-	O
r	int
,	O
", Andes Star v1.0, N1213HC, MAC, PERF1"	pointer
)	O
;	O
if	O
(	O
arch	enum
==	O
E_NDS_ARCH_STAR_V1_0	int
)	O
r	int
+=	O
snprintf	function
(	O
buf	pointer
+	O
r	int
,	O
size	int
-	O
r	int
,	O
", 16b"	pointer
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
arch	enum
)	O
{	O
case	O
E_NDS_ARCH_STAR_V1_0	int
:	O
case	O
E_NDS_ARCH_STAR_V2_0	int
:	O
case	O
E_NDS_ARCH_STAR_V3_0	int
:	O
case	O
E_NDS_ARCH_STAR_V3_M	int
:	O
r	int
+=	O
snprintf	function
(	O
buf	pointer
+	O
r	int
,	O
size	int
-	O
r	int
,	O
", %s"	pointer
,	O
ARCH_STRINGS	array
[	O
arch	enum
>>	O
EF_NDS_ARCH_SHIFT	int
]	O
)	O
;	O
break	O
;	O
default	O
:	O
r	int
+=	O
snprintf	function
(	O
buf	pointer
+	O
r	int
,	O
size	int
-	O
r	int
,	O
", <unrecognized architecture>"	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
arch	enum
==	O
E_NDS_ARCH_STAR_V1_0	int
)	O
{	O
if	O
(	O
config	int
&	O
E_NDS32_HAS_MFUSR_PC_INST	int
)	O
r	int
+=	O
snprintf	function
(	O
buf	pointer
+	O
r	int
,	O
size	int
-	O
r	int
,	O
", MFUSR_PC"	pointer
)	O
;	O
if	O
(	O
!	O
(	O
config	int
&	O
E_NDS32_HAS_NO_MAC_INST	int
)	O
)	O
r	int
+=	O
snprintf	function
(	O
buf	pointer
+	O
r	int
,	O
size	int
-	O
r	int
,	O
", MAC"	pointer
)	O
;	O
if	O
(	O
config	int
&	O
E_NDS32_HAS_DIV_INST	int
)	O
r	int
+=	O
snprintf	function
(	O
buf	pointer
+	O
r	int
,	O
size	int
-	O
r	int
,	O
", DIV"	pointer
)	O
;	O
if	O
(	O
config	int
&	O
E_NDS32_HAS_16BIT_INST	int
)	O
r	int
+=	O
snprintf	function
(	O
buf	pointer
+	O
r	int
,	O
size	int
-	O
r	int
,	O
", 16b"	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
config	int
&	O
E_NDS32_HAS_MFUSR_PC_INST	int
)	O
{	O
if	O
(	O
version	pointer
<=	O
E_NDS32_ELF_VER_1_3	int
)	O
r	int
+=	O
snprintf	function
(	O
buf	pointer
+	O
r	int
,	O
size	int
-	O
r	int
,	O
", [B8]"	pointer
)	O
;	O
else	O
r	int
+=	O
snprintf	function
(	O
buf	pointer
+	O
r	int
,	O
size	int
-	O
r	int
,	O
", EX9"	pointer
)	O
;	O
}	O
if	O
(	O
config	int
&	O
E_NDS32_HAS_MAC_DX_INST	int
)	O
r	int
+=	O
snprintf	function
(	O
buf	pointer
+	O
r	int
,	O
size	int
-	O
r	int
,	O
", MAC_DX"	pointer
)	O
;	O
if	O
(	O
config	int
&	O
E_NDS32_HAS_DIV_DX_INST	int
)	O
r	int
+=	O
snprintf	function
(	O
buf	pointer
+	O
r	int
,	O
size	int
-	O
r	int
,	O
", DIV_DX"	pointer
)	O
;	O
if	O
(	O
config	int
&	O
E_NDS32_HAS_16BIT_INST	int
)	O
{	O
if	O
(	O
version	pointer
<=	O
E_NDS32_ELF_VER_1_3	int
)	O
r	int
+=	O
snprintf	function
(	O
buf	pointer
+	O
r	int
,	O
size	int
-	O
r	int
,	O
", 16b"	pointer
)	O
;	O
else	O
r	int
+=	O
snprintf	function
(	O
buf	pointer
+	O
r	int
,	O
size	int
-	O
r	int
,	O
", IFC"	pointer
)	O
;	O
}	O
}	O
if	O
(	O
config	int
&	O
E_NDS32_HAS_EXT_INST	int
)	O
r	int
+=	O
snprintf	function
(	O
buf	pointer
+	O
r	int
,	O
size	int
-	O
r	int
,	O
", PERF1"	pointer
)	O
;	O
if	O
(	O
config	int
&	O
E_NDS32_HAS_EXT2_INST	int
)	O
r	int
+=	O
snprintf	function
(	O
buf	pointer
+	O
r	int
,	O
size	int
-	O
r	int
,	O
", PERF2"	pointer
)	O
;	O
if	O
(	O
config	int
&	O
E_NDS32_HAS_FPU_INST	int
)	O
{	O
has_fpu	int
=	O
TRUE	int
;	O
r	int
+=	O
snprintf	function
(	O
buf	pointer
+	O
r	int
,	O
size	int
-	O
r	int
,	O
", FPU_SP"	pointer
)	O
;	O
}	O
if	O
(	O
config	int
&	O
E_NDS32_HAS_FPU_DP_INST	int
)	O
{	O
has_fpu	int
=	O
TRUE	int
;	O
r	int
+=	O
snprintf	function
(	O
buf	pointer
+	O
r	int
,	O
size	int
-	O
r	int
,	O
", FPU_DP"	pointer
)	O
;	O
}	O
if	O
(	O
config	int
&	O
E_NDS32_HAS_FPU_MAC_INST	int
)	O
{	O
has_fpu	int
=	O
TRUE	int
;	O
r	int
+=	O
snprintf	function
(	O
buf	pointer
+	O
r	int
,	O
size	int
-	O
r	int
,	O
", FPU_MAC"	pointer
)	O
;	O
}	O
if	O
(	O
has_fpu	int
)	O
{	O
switch	O
(	O
(	O
config	int
&	O
E_NDS32_FPU_REG_CONF	O
)	O
>>	O
E_NDS32_FPU_REG_CONF_SHIFT	int
)	O
{	O
case	O
E_NDS32_FPU_REG_8SP_4DP	int
:	O
r	int
+=	O
snprintf	function
(	O
buf	pointer
+	O
r	int
,	O
size	int
-	O
r	int
,	O
", FPU_REG:8/4"	pointer
)	O
;	O
break	O
;	O
case	O
E_NDS32_FPU_REG_16SP_8DP	int
:	O
r	int
+=	O
snprintf	function
(	O
buf	pointer
+	O
r	int
,	O
size	int
-	O
r	int
,	O
", FPU_REG:16/8"	pointer
)	O
;	O
break	O
;	O
case	O
E_NDS32_FPU_REG_32SP_16DP	int
:	O
r	int
+=	O
snprintf	function
(	O
buf	pointer
+	O
r	int
,	O
size	int
-	O
r	int
,	O
", FPU_REG:32/16"	pointer
)	O
;	O
break	O
;	O
case	O
E_NDS32_FPU_REG_32SP_32DP	int
:	O
r	int
+=	O
snprintf	function
(	O
buf	pointer
+	O
r	int
,	O
size	int
-	O
r	int
,	O
", FPU_REG:32/32"	pointer
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
config	int
&	O
E_NDS32_HAS_AUDIO_INST	int
)	O
r	int
+=	O
snprintf	function
(	O
buf	pointer
+	O
r	int
,	O
size	int
-	O
r	int
,	O
", AUDIO"	pointer
)	O
;	O
if	O
(	O
config	int
&	O
E_NDS32_HAS_STRING_INST	int
)	O
r	int
+=	O
snprintf	function
(	O
buf	pointer
+	O
r	int
,	O
size	int
-	O
r	int
,	O
", STR"	pointer
)	O
;	O
if	O
(	O
config	int
&	O
E_NDS32_HAS_REDUCED_REGS	int
)	O
r	int
+=	O
snprintf	function
(	O
buf	pointer
+	O
r	int
,	O
size	int
-	O
r	int
,	O
", 16REG"	pointer
)	O
;	O
if	O
(	O
config	int
&	O
E_NDS32_HAS_VIDEO_INST	int
)	O
{	O
if	O
(	O
version	pointer
<=	O
E_NDS32_ELF_VER_1_3	int
)	O
r	int
+=	O
snprintf	function
(	O
buf	pointer
+	O
r	int
,	O
size	int
-	O
r	int
,	O
", VIDEO"	pointer
)	O
;	O
else	O
r	int
+=	O
snprintf	function
(	O
buf	pointer
+	O
r	int
,	O
size	int
-	O
r	int
,	O
", SATURATION"	pointer
)	O
;	O
}	O
if	O
(	O
config	int
&	O
E_NDS32_HAS_ENCRIPT_INST	int
)	O
r	int
+=	O
snprintf	function
(	O
buf	pointer
+	O
r	int
,	O
size	int
-	O
r	int
,	O
", ENCRP"	pointer
)	O
;	O
if	O
(	O
config	int
&	O
E_NDS32_HAS_L2C_INST	int
)	O
r	int
+=	O
snprintf	function
(	O
buf	pointer
+	O
r	int
,	O
size	int
-	O
r	int
,	O
", L2C"	pointer
)	O
;	O
}	O
static	O
char	O
*	O
get_machine_flags	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
e_flags	array
,	O
unsigned	O
e_machine	array
)	O
{	O
static	O
char	O
buf	pointer
[	O
1024	int
]	O
;	O
buf	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
e_flags	array
)	O
{	O
switch	O
(	O
e_machine	array
)	O
{	O
default	O
:	O
break	O
;	O
case	O
EM_ARC_COMPACT2	int
:	O
case	O
EM_ARC_COMPACT	int
:	O
decode_ARC_machine_flags	function
(	O
e_flags	array
,	O
e_machine	array
,	O
buf	pointer
)	O
;	O
break	O
;	O
case	O
EM_ARM	int
:	O
decode_ARM_machine_flags	function
(	O
e_flags	array
,	O
buf	pointer
)	O
;	O
break	O
;	O
case	O
EM_AVR	int
:	O
decode_AVR_machine_flags	function
(	O
e_flags	array
,	O
buf	pointer
,	O
sizeof	O
buf	pointer
)	O
;	O
break	O
;	O
case	O
EM_BLACKFIN	int
:	O
if	O
(	O
e_flags	array
&	O
EF_BFIN_PIC	int
)	O
strcat	function
(	O
buf	pointer
,	O
", PIC"	pointer
)	O
;	O
if	O
(	O
e_flags	array
&	O
EF_BFIN_FDPIC	int
)	O
strcat	function
(	O
buf	pointer
,	O
", FDPIC"	pointer
)	O
;	O
if	O
(	O
e_flags	array
&	O
EF_BFIN_CODE_IN_L1	int
)	O
strcat	function
(	O
buf	pointer
,	O
", code in L1"	pointer
)	O
;	O
if	O
(	O
e_flags	array
&	O
EF_BFIN_DATA_IN_L1	int
)	O
strcat	function
(	O
buf	pointer
,	O
", data in L1"	pointer
)	O
;	O
break	O
;	O
case	O
EM_CYGNUS_FRV	int
:	O
switch	O
(	O
e_flags	array
&	O
EF_FRV_CPU_MASK	int
)	O
{	O
case	O
EF_FRV_CPU_GENERIC	int
:	O
break	O
;	O
default	O
:	O
strcat	function
(	O
buf	pointer
,	O
", fr???"	pointer
)	O
;	O
break	O
;	O
case	O
EF_FRV_CPU_FR300	int
:	O
strcat	function
(	O
buf	pointer
,	O
", fr300"	pointer
)	O
;	O
break	O
;	O
case	O
EF_FRV_CPU_FR400	int
:	O
strcat	function
(	O
buf	pointer
,	O
", fr400"	pointer
)	O
;	O
break	O
;	O
case	O
EF_FRV_CPU_FR405	int
:	O
strcat	function
(	O
buf	pointer
,	O
", fr405"	pointer
)	O
;	O
break	O
;	O
case	O
EF_FRV_CPU_FR450	int
:	O
strcat	function
(	O
buf	pointer
,	O
", fr450"	pointer
)	O
;	O
break	O
;	O
case	O
EF_FRV_CPU_FR500	int
:	O
strcat	function
(	O
buf	pointer
,	O
", fr500"	pointer
)	O
;	O
break	O
;	O
case	O
EF_FRV_CPU_FR550	int
:	O
strcat	function
(	O
buf	pointer
,	O
", fr550"	pointer
)	O
;	O
break	O
;	O
case	O
EF_FRV_CPU_SIMPLE	int
:	O
strcat	function
(	O
buf	pointer
,	O
", simple"	pointer
)	O
;	O
break	O
;	O
case	O
EF_FRV_CPU_TOMCAT	int
:	O
strcat	function
(	O
buf	pointer
,	O
", tomcat"	pointer
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
EM_68K	int
:	O
if	O
(	O
(	O
e_flags	array
&	O
EF_M68K_ARCH_MASK	O
)	O
==	O
EF_M68K_M68000	int
)	O
strcat	function
(	O
buf	pointer
,	O
", m68000"	pointer
)	O
;	O
else	O
if	O
(	O
(	O
e_flags	array
&	O
EF_M68K_ARCH_MASK	O
)	O
==	O
EF_M68K_CPU32	int
)	O
strcat	function
(	O
buf	pointer
,	O
", cpu32"	pointer
)	O
;	O
else	O
if	O
(	O
(	O
e_flags	array
&	O
EF_M68K_ARCH_MASK	O
)	O
==	O
EF_M68K_FIDO	int
)	O
strcat	function
(	O
buf	pointer
,	O
", fido_a"	pointer
)	O
;	O
else	O
{	O
char	O
const	O
*	O
isa	pointer
=	O
_	O
(	O
"unknown"	pointer
)	O
;	O
char	O
const	O
*	O
mac	pointer
=	O
_	O
(	O
"unknown mac"	pointer
)	O
;	O
char	O
const	O
*	O
additional	pointer
=	O
NULL	O
;	O
switch	O
(	O
e_flags	array
&	O
EF_M68K_CF_ISA_MASK	int
)	O
{	O
case	O
EF_M68K_CF_ISA_A_NODIV	int
:	O
isa	pointer
=	O
"A"	pointer
;	O
additional	pointer
=	O
", nodiv"	pointer
;	O
break	O
;	O
case	O
EF_M68K_CF_ISA_A	int
:	O
isa	pointer
=	O
"A"	pointer
;	O
break	O
;	O
case	O
EF_M68K_CF_ISA_A_PLUS	int
:	O
isa	pointer
=	O
"A+"	pointer
;	O
break	O
;	O
case	O
EF_M68K_CF_ISA_B_NOUSP	int
:	O
isa	pointer
=	O
"B"	pointer
;	O
additional	pointer
=	O
", nousp"	pointer
;	O
break	O
;	O
case	O
EF_M68K_CF_ISA_B	int
:	O
isa	pointer
=	O
"B"	pointer
;	O
break	O
;	O
case	O
EF_M68K_CF_ISA_C	int
:	O
isa	pointer
=	O
"C"	pointer
;	O
break	O
;	O
case	O
EF_M68K_CF_ISA_C_NODIV	int
:	O
isa	pointer
=	O
"C"	pointer
;	O
additional	pointer
=	O
", nodiv"	pointer
;	O
break	O
;	O
}	O
strcat	function
(	O
buf	pointer
,	O
", cf, isa "	pointer
)	O
;	O
strcat	function
(	O
buf	pointer
,	O
isa	pointer
)	O
;	O
if	O
(	O
additional	pointer
)	O
strcat	function
(	O
buf	pointer
,	O
additional	pointer
)	O
;	O
if	O
(	O
e_flags	array
&	O
EF_M68K_CF_FLOAT	int
)	O
strcat	function
(	O
buf	pointer
,	O
", float"	pointer
)	O
;	O
switch	O
(	O
e_flags	array
&	O
EF_M68K_CF_MAC_MASK	int
)	O
{	O
case	O
0	int
:	O
mac	pointer
=	O
NULL	O
;	O
break	O
;	O
case	O
EF_M68K_CF_MAC	int
:	O
mac	pointer
=	O
"mac"	pointer
;	O
break	O
;	O
case	O
EF_M68K_CF_EMAC	int
:	O
mac	pointer
=	O
"emac"	pointer
;	O
break	O
;	O
case	O
EF_M68K_CF_EMAC_B	int
:	O
mac	pointer
=	O
"emac_b"	pointer
;	O
break	O
;	O
}	O
if	O
(	O
mac	pointer
)	O
{	O
strcat	function
(	O
buf	pointer
,	O
", "	pointer
)	O
;	O
strcat	function
(	O
buf	pointer
,	O
mac	pointer
)	O
;	O
}	O
}	O
break	O
;	O
case	O
EM_CYGNUS_MEP	int
:	O
switch	O
(	O
e_flags	array
&	O
EF_MEP_CPU_MASK	int
)	O
{	O
case	O
EF_MEP_CPU_MEP	int
:	O
strcat	function
(	O
buf	pointer
,	O
", generic MeP"	pointer
)	O
;	O
break	O
;	O
case	O
EF_MEP_CPU_C2	int
:	O
strcat	function
(	O
buf	pointer
,	O
", MeP C2"	pointer
)	O
;	O
break	O
;	O
case	O
EF_MEP_CPU_C3	int
:	O
strcat	function
(	O
buf	pointer
,	O
", MeP C3"	pointer
)	O
;	O
break	O
;	O
case	O
EF_MEP_CPU_C4	int
:	O
strcat	function
(	O
buf	pointer
,	O
", MeP C4"	pointer
)	O
;	O
break	O
;	O
case	O
EF_MEP_CPU_C5	int
:	O
strcat	function
(	O
buf	pointer
,	O
", MeP C5"	pointer
)	O
;	O
break	O
;	O
case	O
EF_MEP_CPU_H1	int
:	O
strcat	function
(	O
buf	pointer
,	O
", MeP H1"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
strcat	function
(	O
buf	pointer
,	O
_	O
(	O
", <unknown MeP cpu type>"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
switch	O
(	O
e_flags	array
&	O
EF_MEP_COP_MASK	int
)	O
{	O
case	O
EF_MEP_COP_NONE	int
:	O
break	O
;	O
case	O
EF_MEP_COP_AVC	int
:	O
strcat	function
(	O
buf	pointer
,	O
", AVC coprocessor"	pointer
)	O
;	O
break	O
;	O
case	O
EF_MEP_COP_AVC2	int
:	O
strcat	function
(	O
buf	pointer
,	O
", AVC2 coprocessor"	pointer
)	O
;	O
break	O
;	O
case	O
EF_MEP_COP_FMAX	int
:	O
strcat	function
(	O
buf	pointer
,	O
", FMAX coprocessor"	pointer
)	O
;	O
break	O
;	O
case	O
EF_MEP_COP_IVC2	int
:	O
strcat	function
(	O
buf	pointer
,	O
", IVC2 coprocessor"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
strcat	function
(	O
buf	pointer
,	O
_	O
(	O
"<unknown MeP copro type>"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
e_flags	array
&	O
EF_MEP_LIBRARY	int
)	O
strcat	function
(	O
buf	pointer
,	O
", Built for Library"	pointer
)	O
;	O
if	O
(	O
e_flags	array
&	O
EF_MEP_INDEX_MASK	int
)	O
sprintf	function
(	O
buf	pointer
+	O
strlen	function
(	O
buf	pointer
)	O
,	O
", Configuration Index: %#x"	pointer
,	O
e_flags	array
&	O
EF_MEP_INDEX_MASK	int
)	O
;	O
if	O
(	O
e_flags	array
&	O
~	O
EF_MEP_ALL_FLAGS	int
)	O
sprintf	function
(	O
buf	pointer
+	O
strlen	function
(	O
buf	pointer
)	O
,	O
_	O
(	O
", unknown flags bits: %#x"	pointer
)	O
,	O
e_flags	array
&	O
~	O
EF_MEP_ALL_FLAGS	int
)	O
;	O
break	O
;	O
case	O
EM_PPC	int
:	O
if	O
(	O
e_flags	array
&	O
EF_PPC_EMB	int
)	O
strcat	function
(	O
buf	pointer
,	O
", emb"	pointer
)	O
;	O
if	O
(	O
e_flags	array
&	O
EF_PPC_RELOCATABLE	int
)	O
strcat	function
(	O
buf	pointer
,	O
_	O
(	O
", relocatable"	pointer
)	O
)	O
;	O
if	O
(	O
e_flags	array
&	O
EF_PPC_RELOCATABLE_LIB	int
)	O
strcat	function
(	O
buf	pointer
,	O
_	O
(	O
", relocatable-lib"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
EM_PPC64	int
:	O
if	O
(	O
e_flags	array
&	O
EF_PPC64_ABI	int
)	O
{	O
char	O
abi	int
[	O
]	O
=	O
", abiv0"	pointer
;	O
abi	int
[	O
6	int
]	O
+=	O
e_flags	array
&	O
EF_PPC64_ABI	int
;	O
strcat	function
(	O
buf	pointer
,	O
abi	int
)	O
;	O
}	O
break	O
;	O
case	O
EM_V800	int
:	O
if	O
(	O
(	O
e_flags	array
&	O
EF_RH850_ABI	int
)	O
==	O
EF_RH850_ABI	int
)	O
strcat	function
(	O
buf	pointer
,	O
", RH850 ABI"	pointer
)	O
;	O
if	O
(	O
e_flags	array
&	O
EF_V800_850E3	int
)	O
strcat	function
(	O
buf	pointer
,	O
", V3 architecture"	pointer
)	O
;	O
if	O
(	O
(	O
e_flags	array
&	O
(	O
EF_RH850_FPU_DOUBLE	int
|	O
EF_RH850_FPU_SINGLE	int
)	O
)	O
==	O
0	int
)	O
strcat	function
(	O
buf	pointer
,	O
", FPU not used"	pointer
)	O
;	O
if	O
(	O
(	O
e_flags	array
&	O
(	O
EF_RH850_REGMODE22	int
|	O
EF_RH850_REGMODE32	int
)	O
)	O
==	O
0	int
)	O
strcat	function
(	O
buf	pointer
,	O
", regmode: COMMON"	pointer
)	O
;	O
if	O
(	O
(	O
e_flags	array
&	O
(	O
EF_RH850_GP_FIX	int
|	O
EF_RH850_GP_NOFIX	int
)	O
)	O
==	O
0	int
)	O
strcat	function
(	O
buf	pointer
,	O
", r4 not used"	pointer
)	O
;	O
if	O
(	O
(	O
e_flags	array
&	O
(	O
EF_RH850_EP_FIX	int
|	O
EF_RH850_EP_NOFIX	int
)	O
)	O
==	O
0	int
)	O
strcat	function
(	O
buf	pointer
,	O
", r30 not used"	pointer
)	O
;	O
if	O
(	O
(	O
e_flags	array
&	O
(	O
EF_RH850_TP_FIX	int
|	O
EF_RH850_TP_NOFIX	int
)	O
)	O
==	O
0	int
)	O
strcat	function
(	O
buf	pointer
,	O
", r5 not used"	pointer
)	O
;	O
if	O
(	O
(	O
e_flags	array
&	O
(	O
EF_RH850_REG2_RESERVE	int
|	O
EF_RH850_REG2_NORESERVE	int
)	O
)	O
==	O
0	int
)	O
strcat	function
(	O
buf	pointer
,	O
", r2 not used"	pointer
)	O
;	O
for	O
(	O
e_flags	array
&=	O
0xFFFF	int
;	O
e_flags	array
;	O
e_flags	array
&=	O
~	O
(	O
e_flags	array
&	O
-	O
e_flags	array
)	O
)	O
{	O
switch	O
(	O
e_flags	array
&	O
-	O
e_flags	array
)	O
{	O
case	O
EF_RH850_FPU_DOUBLE	int
:	O
strcat	function
(	O
buf	pointer
,	O
", double precision FPU"	pointer
)	O
;	O
break	O
;	O
case	O
EF_RH850_FPU_SINGLE	int
:	O
strcat	function
(	O
buf	pointer
,	O
", single precision FPU"	pointer
)	O
;	O
break	O
;	O
case	O
EF_RH850_REGMODE22	int
:	O
strcat	function
(	O
buf	pointer
,	O
", regmode:22"	pointer
)	O
;	O
break	O
;	O
case	O
EF_RH850_REGMODE32	int
:	O
strcat	function
(	O
buf	pointer
,	O
", regmode:23"	pointer
)	O
;	O
break	O
;	O
case	O
EF_RH850_GP_FIX	int
:	O
strcat	function
(	O
buf	pointer
,	O
", r4 fixed"	pointer
)	O
;	O
break	O
;	O
case	O
EF_RH850_GP_NOFIX	int
:	O
strcat	function
(	O
buf	pointer
,	O
", r4 free"	pointer
)	O
;	O
break	O
;	O
case	O
EF_RH850_EP_FIX	int
:	O
strcat	function
(	O
buf	pointer
,	O
", r30 fixed"	pointer
)	O
;	O
break	O
;	O
case	O
EF_RH850_EP_NOFIX	int
:	O
strcat	function
(	O
buf	pointer
,	O
", r30 free"	pointer
)	O
;	O
break	O
;	O
case	O
EF_RH850_TP_FIX	int
:	O
strcat	function
(	O
buf	pointer
,	O
", r5 fixed"	pointer
)	O
;	O
break	O
;	O
case	O
EF_RH850_TP_NOFIX	int
:	O
strcat	function
(	O
buf	pointer
,	O
", r5 free"	pointer
)	O
;	O
break	O
;	O
case	O
EF_RH850_REG2_RESERVE	int
:	O
strcat	function
(	O
buf	pointer
,	O
", r2 fixed"	pointer
)	O
;	O
break	O
;	O
case	O
EF_RH850_REG2_NORESERVE	int
:	O
strcat	function
(	O
buf	pointer
,	O
", r2 free"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
break	O
;	O
case	O
EM_V850	int
:	O
case	O
EM_CYGNUS_V850	int
:	O
switch	O
(	O
e_flags	array
&	O
EF_V850_ARCH	int
)	O
{	O
case	O
E_V850E3V5_ARCH	int
:	O
strcat	function
(	O
buf	pointer
,	O
", v850e3v5"	pointer
)	O
;	O
break	O
;	O
case	O
E_V850E2V3_ARCH	int
:	O
strcat	function
(	O
buf	pointer
,	O
", v850e2v3"	pointer
)	O
;	O
break	O
;	O
case	O
E_V850E2_ARCH	int
:	O
strcat	function
(	O
buf	pointer
,	O
", v850e2"	pointer
)	O
;	O
break	O
;	O
case	O
E_V850E1_ARCH	int
:	O
strcat	function
(	O
buf	pointer
,	O
", v850e1"	pointer
)	O
;	O
break	O
;	O
case	O
E_V850E_ARCH	int
:	O
strcat	function
(	O
buf	pointer
,	O
", v850e"	pointer
)	O
;	O
break	O
;	O
case	O
E_V850_ARCH	int
:	O
strcat	function
(	O
buf	pointer
,	O
", v850"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
strcat	function
(	O
buf	pointer
,	O
_	O
(	O
", unknown v850 architecture variant"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
EM_M32R	int
:	O
case	O
EM_CYGNUS_M32R	int
:	O
if	O
(	O
(	O
e_flags	array
&	O
EF_M32R_ARCH	int
)	O
==	O
E_M32R_ARCH	int
)	O
strcat	function
(	O
buf	pointer
,	O
", m32r"	pointer
)	O
;	O
break	O
;	O
case	O
EM_MIPS	int
:	O
case	O
EM_MIPS_RS3_LE	int
:	O
if	O
(	O
e_flags	array
&	O
EF_MIPS_NOREORDER	int
)	O
strcat	function
(	O
buf	pointer
,	O
", noreorder"	pointer
)	O
;	O
if	O
(	O
e_flags	array
&	O
EF_MIPS_PIC	int
)	O
strcat	function
(	O
buf	pointer
,	O
", pic"	pointer
)	O
;	O
if	O
(	O
e_flags	array
&	O
EF_MIPS_CPIC	int
)	O
strcat	function
(	O
buf	pointer
,	O
", cpic"	pointer
)	O
;	O
if	O
(	O
e_flags	array
&	O
EF_MIPS_UCODE	int
)	O
strcat	function
(	O
buf	pointer
,	O
", ugen_reserved"	pointer
)	O
;	O
if	O
(	O
e_flags	array
&	O
EF_MIPS_ABI2	int
)	O
strcat	function
(	O
buf	pointer
,	O
", abi2"	pointer
)	O
;	O
if	O
(	O
e_flags	array
&	O
EF_MIPS_OPTIONS_FIRST	int
)	O
strcat	function
(	O
buf	pointer
,	O
", odk first"	pointer
)	O
;	O
if	O
(	O
e_flags	array
&	O
EF_MIPS_32BITMODE	int
)	O
strcat	function
(	O
buf	pointer
,	O
", 32bitmode"	pointer
)	O
;	O
if	O
(	O
e_flags	array
&	O
EF_MIPS_NAN2008	int
)	O
strcat	function
(	O
buf	pointer
,	O
", nan2008"	pointer
)	O
;	O
if	O
(	O
e_flags	array
&	O
EF_MIPS_FP64	int
)	O
strcat	function
(	O
buf	pointer
,	O
", fp64"	pointer
)	O
;	O
switch	O
(	O
(	O
e_flags	array
&	O
EF_MIPS_MACH	int
)	O
)	O
{	O
case	O
E_MIPS_MACH_3900	int
:	O
strcat	function
(	O
buf	pointer
,	O
", 3900"	pointer
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_4010	int
:	O
strcat	function
(	O
buf	pointer
,	O
", 4010"	pointer
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_4100	int
:	O
strcat	function
(	O
buf	pointer
,	O
", 4100"	pointer
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_4111	int
:	O
strcat	function
(	O
buf	pointer
,	O
", 4111"	pointer
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_4120	int
:	O
strcat	function
(	O
buf	pointer
,	O
", 4120"	pointer
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_4650	int
:	O
strcat	function
(	O
buf	pointer
,	O
", 4650"	pointer
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_5400	int
:	O
strcat	function
(	O
buf	pointer
,	O
", 5400"	pointer
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_5500	int
:	O
strcat	function
(	O
buf	pointer
,	O
", 5500"	pointer
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_5900	int
:	O
strcat	function
(	O
buf	pointer
,	O
", 5900"	pointer
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_SB1	int
:	O
strcat	function
(	O
buf	pointer
,	O
", sb1"	pointer
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_9000	int
:	O
strcat	function
(	O
buf	pointer
,	O
", 9000"	pointer
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_LS2E	int
:	O
strcat	function
(	O
buf	pointer
,	O
", loongson-2e"	pointer
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_LS2F	int
:	O
strcat	function
(	O
buf	pointer
,	O
", loongson-2f"	pointer
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_GS464	int
:	O
strcat	function
(	O
buf	pointer
,	O
", gs464"	pointer
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_GS464E	int
:	O
strcat	function
(	O
buf	pointer
,	O
", gs464e"	pointer
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_GS264E	int
:	O
strcat	function
(	O
buf	pointer
,	O
", gs264e"	pointer
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_OCTEON	int
:	O
strcat	function
(	O
buf	pointer
,	O
", octeon"	pointer
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_OCTEON2	int
:	O
strcat	function
(	O
buf	pointer
,	O
", octeon2"	pointer
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_OCTEON3	int
:	O
strcat	function
(	O
buf	pointer
,	O
", octeon3"	pointer
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_XLR	int
:	O
strcat	function
(	O
buf	pointer
,	O
", xlr"	pointer
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_IAMR2	int
:	O
strcat	function
(	O
buf	pointer
,	O
", interaptiv-mr2"	pointer
)	O
;	O
break	O
;	O
case	O
0	int
:	O
break	O
;	O
default	O
:	O
strcat	function
(	O
buf	pointer
,	O
_	O
(	O
", unknown CPU"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
switch	O
(	O
(	O
e_flags	array
&	O
EF_MIPS_ABI	int
)	O
)	O
{	O
case	O
E_MIPS_ABI_O32	int
:	O
strcat	function
(	O
buf	pointer
,	O
", o32"	pointer
)	O
;	O
break	O
;	O
case	O
E_MIPS_ABI_O64	int
:	O
strcat	function
(	O
buf	pointer
,	O
", o64"	pointer
)	O
;	O
break	O
;	O
case	O
E_MIPS_ABI_EABI32	int
:	O
strcat	function
(	O
buf	pointer
,	O
", eabi32"	pointer
)	O
;	O
break	O
;	O
case	O
E_MIPS_ABI_EABI64	int
:	O
strcat	function
(	O
buf	pointer
,	O
", eabi64"	pointer
)	O
;	O
break	O
;	O
case	O
0	int
:	O
break	O
;	O
default	O
:	O
strcat	function
(	O
buf	pointer
,	O
_	O
(	O
", unknown ABI"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
e_flags	array
&	O
EF_MIPS_ARCH_ASE_MDMX	int
)	O
strcat	function
(	O
buf	pointer
,	O
", mdmx"	pointer
)	O
;	O
if	O
(	O
e_flags	array
&	O
EF_MIPS_ARCH_ASE_M16	int
)	O
strcat	function
(	O
buf	pointer
,	O
", mips16"	pointer
)	O
;	O
if	O
(	O
e_flags	array
&	O
EF_MIPS_ARCH_ASE_MICROMIPS	int
)	O
strcat	function
(	O
buf	pointer
,	O
", micromips"	pointer
)	O
;	O
switch	O
(	O
(	O
e_flags	array
&	O
EF_MIPS_ARCH	int
)	O
)	O
{	O
case	O
E_MIPS_ARCH_1	int
:	O
strcat	function
(	O
buf	pointer
,	O
", mips1"	pointer
)	O
;	O
break	O
;	O
case	O
E_MIPS_ARCH_2	int
:	O
strcat	function
(	O
buf	pointer
,	O
", mips2"	pointer
)	O
;	O
break	O
;	O
case	O
E_MIPS_ARCH_3	int
:	O
strcat	function
(	O
buf	pointer
,	O
", mips3"	pointer
)	O
;	O
break	O
;	O
case	O
E_MIPS_ARCH_4	int
:	O
strcat	function
(	O
buf	pointer
,	O
", mips4"	pointer
)	O
;	O
break	O
;	O
case	O
E_MIPS_ARCH_5	int
:	O
strcat	function
(	O
buf	pointer
,	O
", mips5"	pointer
)	O
;	O
break	O
;	O
case	O
E_MIPS_ARCH_32	int
:	O
strcat	function
(	O
buf	pointer
,	O
", mips32"	pointer
)	O
;	O
break	O
;	O
case	O
E_MIPS_ARCH_32R2	int
:	O
strcat	function
(	O
buf	pointer
,	O
", mips32r2"	pointer
)	O
;	O
break	O
;	O
case	O
E_MIPS_ARCH_32R6	int
:	O
strcat	function
(	O
buf	pointer
,	O
", mips32r6"	pointer
)	O
;	O
break	O
;	O
case	O
E_MIPS_ARCH_64	int
:	O
strcat	function
(	O
buf	pointer
,	O
", mips64"	pointer
)	O
;	O
break	O
;	O
case	O
E_MIPS_ARCH_64R2	int
:	O
strcat	function
(	O
buf	pointer
,	O
", mips64r2"	pointer
)	O
;	O
break	O
;	O
case	O
E_MIPS_ARCH_64R6	int
:	O
strcat	function
(	O
buf	pointer
,	O
", mips64r6"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
strcat	function
(	O
buf	pointer
,	O
_	O
(	O
", unknown ISA"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
EM_NDS32	int
:	O
decode_NDS32_machine_flags	function
(	O
e_flags	array
,	O
buf	pointer
,	O
sizeof	O
buf	pointer
)	O
;	O
break	O
;	O
case	O
EM_NFP	int
:	O
switch	O
(	O
EF_NFP_MACH	O
(	O
e_flags	array
)	O
)	O
{	O
case	O
E_NFP_MACH_3200	int
:	O
strcat	function
(	O
buf	pointer
,	O
", NFP-32xx"	pointer
)	O
;	O
break	O
;	O
case	O
E_NFP_MACH_6000	int
:	O
strcat	function
(	O
buf	pointer
,	O
", NFP-6xxx"	pointer
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
EM_RISCV	int
:	O
if	O
(	O
e_flags	array
&	O
EF_RISCV_RVC	int
)	O
strcat	function
(	O
buf	pointer
,	O
", RVC"	pointer
)	O
;	O
if	O
(	O
e_flags	array
&	O
EF_RISCV_RVE	int
)	O
strcat	function
(	O
buf	pointer
,	O
", RVE"	pointer
)	O
;	O
switch	O
(	O
e_flags	array
&	O
EF_RISCV_FLOAT_ABI	int
)	O
{	O
case	O
EF_RISCV_FLOAT_ABI_SOFT	int
:	O
strcat	function
(	O
buf	pointer
,	O
", soft-float ABI"	pointer
)	O
;	O
break	O
;	O
case	O
EF_RISCV_FLOAT_ABI_SINGLE	int
:	O
strcat	function
(	O
buf	pointer
,	O
", single-float ABI"	pointer
)	O
;	O
break	O
;	O
case	O
EF_RISCV_FLOAT_ABI_DOUBLE	int
:	O
strcat	function
(	O
buf	pointer
,	O
", double-float ABI"	pointer
)	O
;	O
break	O
;	O
case	O
EF_RISCV_FLOAT_ABI_QUAD	int
:	O
strcat	function
(	O
buf	pointer
,	O
", quad-float ABI"	pointer
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
EM_SH	int
:	O
switch	O
(	O
(	O
e_flags	array
&	O
EF_SH_MACH_MASK	int
)	O
)	O
{	O
case	O
EF_SH1	int
:	O
strcat	function
(	O
buf	pointer
,	O
", sh1"	pointer
)	O
;	O
break	O
;	O
case	O
EF_SH2	int
:	O
strcat	function
(	O
buf	pointer
,	O
", sh2"	pointer
)	O
;	O
break	O
;	O
case	O
EF_SH3	int
:	O
strcat	function
(	O
buf	pointer
,	O
", sh3"	pointer
)	O
;	O
break	O
;	O
case	O
EF_SH_DSP	int
:	O
strcat	function
(	O
buf	pointer
,	O
", sh-dsp"	pointer
)	O
;	O
break	O
;	O
case	O
EF_SH3_DSP	int
:	O
strcat	function
(	O
buf	pointer
,	O
", sh3-dsp"	pointer
)	O
;	O
break	O
;	O
case	O
EF_SH4AL_DSP	int
:	O
strcat	function
(	O
buf	pointer
,	O
", sh4al-dsp"	pointer
)	O
;	O
break	O
;	O
case	O
EF_SH3E	int
:	O
strcat	function
(	O
buf	pointer
,	O
", sh3e"	pointer
)	O
;	O
break	O
;	O
case	O
EF_SH4	int
:	O
strcat	function
(	O
buf	pointer
,	O
", sh4"	pointer
)	O
;	O
break	O
;	O
case	O
EF_SH5	int
:	O
strcat	function
(	O
buf	pointer
,	O
", sh5"	pointer
)	O
;	O
break	O
;	O
case	O
EF_SH2E	int
:	O
strcat	function
(	O
buf	pointer
,	O
", sh2e"	pointer
)	O
;	O
break	O
;	O
case	O
EF_SH4A	int
:	O
strcat	function
(	O
buf	pointer
,	O
", sh4a"	pointer
)	O
;	O
break	O
;	O
case	O
EF_SH2A	int
:	O
strcat	function
(	O
buf	pointer
,	O
", sh2a"	pointer
)	O
;	O
break	O
;	O
case	O
EF_SH4_NOFPU	int
:	O
strcat	function
(	O
buf	pointer
,	O
", sh4-nofpu"	pointer
)	O
;	O
break	O
;	O
case	O
EF_SH4A_NOFPU	int
:	O
strcat	function
(	O
buf	pointer
,	O
", sh4a-nofpu"	pointer
)	O
;	O
break	O
;	O
case	O
EF_SH2A_NOFPU	int
:	O
strcat	function
(	O
buf	pointer
,	O
", sh2a-nofpu"	pointer
)	O
;	O
break	O
;	O
case	O
EF_SH3_NOMMU	int
:	O
strcat	function
(	O
buf	pointer
,	O
", sh3-nommu"	pointer
)	O
;	O
break	O
;	O
case	O
EF_SH4_NOMMU_NOFPU	int
:	O
strcat	function
(	O
buf	pointer
,	O
", sh4-nommu-nofpu"	pointer
)	O
;	O
break	O
;	O
case	O
EF_SH2A_SH4_NOFPU	int
:	O
strcat	function
(	O
buf	pointer
,	O
", sh2a-nofpu-or-sh4-nommu-nofpu"	pointer
)	O
;	O
break	O
;	O
case	O
EF_SH2A_SH3_NOFPU	int
:	O
strcat	function
(	O
buf	pointer
,	O
", sh2a-nofpu-or-sh3-nommu"	pointer
)	O
;	O
break	O
;	O
case	O
EF_SH2A_SH4	int
:	O
strcat	function
(	O
buf	pointer
,	O
", sh2a-or-sh4"	pointer
)	O
;	O
break	O
;	O
case	O
EF_SH2A_SH3E	int
:	O
strcat	function
(	O
buf	pointer
,	O
", sh2a-or-sh3e"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
strcat	function
(	O
buf	pointer
,	O
_	O
(	O
", unknown ISA"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
e_flags	array
&	O
EF_SH_PIC	int
)	O
strcat	function
(	O
buf	pointer
,	O
", pic"	pointer
)	O
;	O
if	O
(	O
e_flags	array
&	O
EF_SH_FDPIC	int
)	O
strcat	function
(	O
buf	pointer
,	O
", fdpic"	pointer
)	O
;	O
break	O
;	O
case	O
EM_OR1K	int
:	O
if	O
(	O
e_flags	array
&	O
EF_OR1K_NODELAY	O
)	O
strcat	function
(	O
buf	pointer
,	O
", no delay"	pointer
)	O
;	O
break	O
;	O
case	O
EM_SPARCV9	int
:	O
if	O
(	O
e_flags	array
&	O
EF_SPARC_32PLUS	int
)	O
strcat	function
(	O
buf	pointer
,	O
", v8+"	pointer
)	O
;	O
if	O
(	O
e_flags	array
&	O
EF_SPARC_SUN_US1	int
)	O
strcat	function
(	O
buf	pointer
,	O
", ultrasparcI"	pointer
)	O
;	O
if	O
(	O
e_flags	array
&	O
EF_SPARC_SUN_US3	int
)	O
strcat	function
(	O
buf	pointer
,	O
", ultrasparcIII"	pointer
)	O
;	O
if	O
(	O
e_flags	array
&	O
EF_SPARC_HAL_R1	int
)	O
strcat	function
(	O
buf	pointer
,	O
", halr1"	pointer
)	O
;	O
if	O
(	O
e_flags	array
&	O
EF_SPARC_LEDATA	int
)	O
strcat	function
(	O
buf	pointer
,	O
", ledata"	pointer
)	O
;	O
if	O
(	O
(	O
e_flags	array
&	O
EF_SPARCV9_MM	int
)	O
==	O
EF_SPARCV9_TSO	int
)	O
strcat	function
(	O
buf	pointer
,	O
", tso"	pointer
)	O
;	O
if	O
(	O
(	O
e_flags	array
&	O
EF_SPARCV9_MM	int
)	O
==	O
EF_SPARCV9_PSO	int
)	O
strcat	function
(	O
buf	pointer
,	O
", pso"	pointer
)	O
;	O
if	O
(	O
(	O
e_flags	array
&	O
EF_SPARCV9_MM	int
)	O
==	O
EF_SPARCV9_RMO	int
)	O
strcat	function
(	O
buf	pointer
,	O
", rmo"	pointer
)	O
;	O
break	O
;	O
case	O
EM_PARISC	int
:	O
switch	O
(	O
e_flags	array
&	O
EF_PARISC_ARCH	int
)	O
{	O
case	O
EFA_PARISC_1_0	int
:	O
strcpy	function
(	O
buf	pointer
,	O
", PA-RISC 1.0"	pointer
)	O
;	O
break	O
;	O
case	O
EFA_PARISC_1_1	int
:	O
strcpy	function
(	O
buf	pointer
,	O
", PA-RISC 1.1"	pointer
)	O
;	O
break	O
;	O
case	O
EFA_PARISC_2_0	int
:	O
strcpy	function
(	O
buf	pointer
,	O
", PA-RISC 2.0"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
e_flags	array
&	O
EF_PARISC_TRAPNIL	int
)	O
strcat	function
(	O
buf	pointer
,	O
", trapnil"	pointer
)	O
;	O
if	O
(	O
e_flags	array
&	O
EF_PARISC_EXT	int
)	O
strcat	function
(	O
buf	pointer
,	O
", ext"	pointer
)	O
;	O
if	O
(	O
e_flags	array
&	O
EF_PARISC_LSB	int
)	O
strcat	function
(	O
buf	pointer
,	O
", lsb"	pointer
)	O
;	O
if	O
(	O
e_flags	array
&	O
EF_PARISC_WIDE	int
)	O
strcat	function
(	O
buf	pointer
,	O
", wide"	pointer
)	O
;	O
if	O
(	O
e_flags	array
&	O
EF_PARISC_NO_KABP	int
)	O
strcat	function
(	O
buf	pointer
,	O
", no kabp"	pointer
)	O
;	O
if	O
(	O
e_flags	array
&	O
EF_PARISC_LAZYSWAP	int
)	O
strcat	function
(	O
buf	pointer
,	O
", lazyswap"	pointer
)	O
;	O
break	O
;	O
case	O
EM_PJ	int
:	O
case	O
EM_PJ_OLD	int
:	O
if	O
(	O
(	O
e_flags	array
&	O
EF_PICOJAVA_NEWCALLS	int
)	O
==	O
EF_PICOJAVA_NEWCALLS	int
)	O
strcat	function
(	O
buf	pointer
,	O
", new calling convention"	pointer
)	O
;	O
if	O
(	O
(	O
e_flags	array
&	O
EF_PICOJAVA_GNUCALLS	int
)	O
==	O
EF_PICOJAVA_GNUCALLS	int
)	O
strcat	function
(	O
buf	pointer
,	O
", gnu calling convention"	pointer
)	O
;	O
break	O
;	O
case	O
EM_IA_64	int
:	O
if	O
(	O
(	O
e_flags	array
&	O
EF_IA_64_ABI64	O
)	O
)	O
strcat	function
(	O
buf	pointer
,	O
", 64-bit"	pointer
)	O
;	O
else	O
strcat	function
(	O
buf	pointer
,	O
", 32-bit"	pointer
)	O
;	O
if	O
(	O
(	O
e_flags	array
&	O
EF_IA_64_REDUCEDFP	O
)	O
)	O
strcat	function
(	O
buf	pointer
,	O
", reduced fp model"	pointer
)	O
;	O
if	O
(	O
(	O
e_flags	array
&	O
EF_IA_64_NOFUNCDESC_CONS_GP	O
)	O
)	O
strcat	function
(	O
buf	pointer
,	O
", no function descriptors, constant gp"	pointer
)	O
;	O
else	O
if	O
(	O
(	O
e_flags	array
&	O
EF_IA_64_CONS_GP	O
)	O
)	O
strcat	function
(	O
buf	pointer
,	O
", constant gp"	pointer
)	O
;	O
if	O
(	O
(	O
e_flags	array
&	O
EF_IA_64_ABSOLUTE	O
)	O
)	O
strcat	function
(	O
buf	pointer
,	O
", absolute"	pointer
)	O
;	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_ident	array
[	O
EI_OSABI	int
]	O
==	O
ELFOSABI_OPENVMS	int
)	O
{	O
if	O
(	O
(	O
e_flags	array
&	O
EF_IA_64_VMS_LINKAGES	int
)	O
)	O
strcat	function
(	O
buf	pointer
,	O
", vms_linkages"	pointer
)	O
;	O
switch	O
(	O
(	O
e_flags	array
&	O
EF_IA_64_VMS_COMCOD	int
)	O
)	O
{	O
case	O
EF_IA_64_VMS_COMCOD_SUCCESS	int
:	O
break	O
;	O
case	O
EF_IA_64_VMS_COMCOD_WARNING	int
:	O
strcat	function
(	O
buf	pointer
,	O
", warning"	pointer
)	O
;	O
break	O
;	O
case	O
EF_IA_64_VMS_COMCOD_ERROR	int
:	O
strcat	function
(	O
buf	pointer
,	O
", error"	pointer
)	O
;	O
break	O
;	O
case	O
EF_IA_64_VMS_COMCOD_ABORT	int
:	O
strcat	function
(	O
buf	pointer
,	O
", abort"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
warn	function
(	O
_	O
(	O
"Unrecognised IA64 VMS Command Code: %x\n"	pointer
)	O
,	O
e_flags	array
&	O
EF_IA_64_VMS_COMCOD	int
)	O
;	O
strcat	function
(	O
buf	pointer
,	O
", <unknown>"	pointer
)	O
;	O
}	O
}	O
break	O
;	O
case	O
EM_VAX	int
:	O
if	O
(	O
(	O
e_flags	array
&	O
EF_VAX_NONPIC	int
)	O
)	O
strcat	function
(	O
buf	pointer
,	O
", non-PIC"	pointer
)	O
;	O
if	O
(	O
(	O
e_flags	array
&	O
EF_VAX_DFLOAT	int
)	O
)	O
strcat	function
(	O
buf	pointer
,	O
", D-Float"	pointer
)	O
;	O
if	O
(	O
(	O
e_flags	array
&	O
EF_VAX_GFLOAT	int
)	O
)	O
strcat	function
(	O
buf	pointer
,	O
", G-Float"	pointer
)	O
;	O
break	O
;	O
case	O
EM_VISIUM	int
:	O
if	O
(	O
e_flags	array
&	O
EF_VISIUM_ARCH_MCM	int
)	O
strcat	function
(	O
buf	pointer
,	O
", mcm"	pointer
)	O
;	O
else	O
if	O
(	O
e_flags	array
&	O
EF_VISIUM_ARCH_MCM24	int
)	O
strcat	function
(	O
buf	pointer
,	O
", mcm24"	pointer
)	O
;	O
if	O
(	O
e_flags	array
&	O
EF_VISIUM_ARCH_GR6	int
)	O
strcat	function
(	O
buf	pointer
,	O
", gr6"	pointer
)	O
;	O
break	O
;	O
case	O
EM_RL78	int
:	O
switch	O
(	O
e_flags	array
&	O
E_FLAG_RL78_CPU_MASK	int
)	O
{	O
case	O
E_FLAG_RL78_ANY_CPU	int
:	O
break	O
;	O
case	O
E_FLAG_RL78_G10	int
:	O
strcat	function
(	O
buf	pointer
,	O
", G10"	pointer
)	O
;	O
break	O
;	O
case	O
E_FLAG_RL78_G13	int
:	O
strcat	function
(	O
buf	pointer
,	O
", G13"	pointer
)	O
;	O
break	O
;	O
case	O
E_FLAG_RL78_G14	int
:	O
strcat	function
(	O
buf	pointer
,	O
", G14"	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
e_flags	array
&	O
E_FLAG_RL78_64BIT_DOUBLES	O
)	O
strcat	function
(	O
buf	pointer
,	O
", 64-bit doubles"	pointer
)	O
;	O
break	O
;	O
case	O
EM_RX	int
:	O
if	O
(	O
e_flags	array
&	O
E_FLAG_RX_64BIT_DOUBLES	O
)	O
strcat	function
(	O
buf	pointer
,	O
", 64-bit doubles"	pointer
)	O
;	O
if	O
(	O
e_flags	array
&	O
E_FLAG_RX_DSP	O
)	O
strcat	function
(	O
buf	pointer
,	O
", dsp"	pointer
)	O
;	O
if	O
(	O
e_flags	array
&	O
E_FLAG_RX_PID	O
)	O
strcat	function
(	O
buf	pointer
,	O
", pid"	pointer
)	O
;	O
if	O
(	O
e_flags	array
&	O
E_FLAG_RX_ABI	O
)	O
strcat	function
(	O
buf	pointer
,	O
", RX ABI"	pointer
)	O
;	O
if	O
(	O
e_flags	array
&	O
E_FLAG_RX_SINSNS_SET	O
)	O
strcat	function
(	O
buf	pointer
,	O
e_flags	array
&	O
E_FLAG_RX_SINSNS_YES	O
?	O
", uses String instructions"	pointer
:	O
", bans String instructions"	pointer
)	O
;	O
if	O
(	O
e_flags	array
&	O
E_FLAG_RX_V2	O
)	O
strcat	function
(	O
buf	pointer
,	O
", V2"	pointer
)	O
;	O
if	O
(	O
e_flags	array
&	O
E_FLAG_RX_V3	O
)	O
strcat	function
(	O
buf	pointer
,	O
", V3"	pointer
)	O
;	O
break	O
;	O
case	O
EM_S390	int
:	O
if	O
(	O
e_flags	array
&	O
EF_S390_HIGH_GPRS	int
)	O
strcat	function
(	O
buf	pointer
,	O
", highgprs"	pointer
)	O
;	O
break	O
;	O
case	O
EM_TI_C6000	int
:	O
if	O
(	O
(	O
e_flags	array
&	O
EF_C6000_REL	int
)	O
)	O
strcat	function
(	O
buf	pointer
,	O
", relocatable module"	pointer
)	O
;	O
break	O
;	O
case	O
EM_MSP430	int
:	O
strcat	function
(	O
buf	pointer
,	O
_	O
(	O
": architecture variant: "	pointer
)	O
)	O
;	O
switch	O
(	O
e_flags	array
&	O
EF_MSP430_MACH	int
)	O
{	O
case	O
E_MSP430_MACH_MSP430x11	int
:	O
strcat	function
(	O
buf	pointer
,	O
"MSP430x11"	pointer
)	O
;	O
break	O
;	O
case	O
E_MSP430_MACH_MSP430x11x1	int
:	O
strcat	function
(	O
buf	pointer
,	O
"MSP430x11x1 "	pointer
)	O
;	O
break	O
;	O
case	O
E_MSP430_MACH_MSP430x12	int
:	O
strcat	function
(	O
buf	pointer
,	O
"MSP430x12"	pointer
)	O
;	O
break	O
;	O
case	O
E_MSP430_MACH_MSP430x13	int
:	O
strcat	function
(	O
buf	pointer
,	O
"MSP430x13"	pointer
)	O
;	O
break	O
;	O
case	O
E_MSP430_MACH_MSP430x14	int
:	O
strcat	function
(	O
buf	pointer
,	O
"MSP430x14"	pointer
)	O
;	O
break	O
;	O
case	O
E_MSP430_MACH_MSP430x15	int
:	O
strcat	function
(	O
buf	pointer
,	O
"MSP430x15"	pointer
)	O
;	O
break	O
;	O
case	O
E_MSP430_MACH_MSP430x16	int
:	O
strcat	function
(	O
buf	pointer
,	O
"MSP430x16"	pointer
)	O
;	O
break	O
;	O
case	O
E_MSP430_MACH_MSP430x31	int
:	O
strcat	function
(	O
buf	pointer
,	O
"MSP430x31"	pointer
)	O
;	O
break	O
;	O
case	O
E_MSP430_MACH_MSP430x32	int
:	O
strcat	function
(	O
buf	pointer
,	O
"MSP430x32"	pointer
)	O
;	O
break	O
;	O
case	O
E_MSP430_MACH_MSP430x33	int
:	O
strcat	function
(	O
buf	pointer
,	O
"MSP430x33"	pointer
)	O
;	O
break	O
;	O
case	O
E_MSP430_MACH_MSP430x41	int
:	O
strcat	function
(	O
buf	pointer
,	O
"MSP430x41"	pointer
)	O
;	O
break	O
;	O
case	O
E_MSP430_MACH_MSP430x42	int
:	O
strcat	function
(	O
buf	pointer
,	O
"MSP430x42"	pointer
)	O
;	O
break	O
;	O
case	O
E_MSP430_MACH_MSP430x43	int
:	O
strcat	function
(	O
buf	pointer
,	O
"MSP430x43"	pointer
)	O
;	O
break	O
;	O
case	O
E_MSP430_MACH_MSP430x44	int
:	O
strcat	function
(	O
buf	pointer
,	O
"MSP430x44"	pointer
)	O
;	O
break	O
;	O
case	O
E_MSP430_MACH_MSP430X	int
:	O
strcat	function
(	O
buf	pointer
,	O
"MSP430X"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
strcat	function
(	O
buf	pointer
,	O
_	O
(	O
": unknown"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
e_flags	array
&	O
~	O
EF_MSP430_MACH	int
)	O
strcat	function
(	O
buf	pointer
,	O
_	O
(	O
": unknown extra flag bits also present"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
EM_Z80	int
:	O
switch	O
(	O
e_flags	array
&	O
EF_Z80_MACH_MSK	int
)	O
{	O
case	O
EF_Z80_MACH_Z80	int
:	O
strcat	function
(	O
buf	pointer
,	O
", Z80"	pointer
)	O
;	O
break	O
;	O
case	O
EF_Z80_MACH_Z180	int
:	O
strcat	function
(	O
buf	pointer
,	O
", Z180"	pointer
)	O
;	O
break	O
;	O
case	O
EF_Z80_MACH_R800	int
:	O
strcat	function
(	O
buf	pointer
,	O
", R800"	pointer
)	O
;	O
break	O
;	O
case	O
EF_Z80_MACH_EZ80_Z80	int
:	O
strcat	function
(	O
buf	pointer
,	O
", EZ80"	pointer
)	O
;	O
break	O
;	O
case	O
EF_Z80_MACH_EZ80_ADL	int
:	O
strcat	function
(	O
buf	pointer
,	O
", EZ80, ADL"	pointer
)	O
;	O
break	O
;	O
case	O
EF_Z80_MACH_GBZ80	int
:	O
strcat	function
(	O
buf	pointer
,	O
", GBZ80"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
strcat	function
(	O
buf	pointer
,	O
_	O
(	O
", unknown"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
}	O
}	O
return	O
buf	pointer
;	O
}	O
static	O
const	O
char	O
*	O
get_osabi_name	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
int	O
osabi	int
)	O
{	O
static	O
char	O
buff	array
[	O
32	int
]	O
;	O
switch	O
(	O
osabi	int
)	O
{	O
case	O
ELFOSABI_NONE	int
:	O
return	O
"UNIX - System V"	pointer
;	O
case	O
ELFOSABI_HPUX	int
:	O
return	O
"UNIX - HP-UX"	pointer
;	O
case	O
ELFOSABI_NETBSD	int
:	O
return	O
"UNIX - NetBSD"	pointer
;	O
case	O
ELFOSABI_GNU	int
:	O
return	O
"UNIX - GNU"	pointer
;	O
case	O
ELFOSABI_SOLARIS	int
:	O
return	O
"UNIX - Solaris"	pointer
;	O
case	O
ELFOSABI_AIX	int
:	O
return	O
"UNIX - AIX"	pointer
;	O
case	O
ELFOSABI_IRIX	int
:	O
return	O
"UNIX - IRIX"	pointer
;	O
case	O
ELFOSABI_FREEBSD	int
:	O
return	O
"UNIX - FreeBSD"	pointer
;	O
case	O
ELFOSABI_TRU64	int
:	O
return	O
"UNIX - TRU64"	pointer
;	O
case	O
ELFOSABI_MODESTO	int
:	O
return	O
"Novell - Modesto"	pointer
;	O
case	O
ELFOSABI_OPENBSD	int
:	O
return	O
"UNIX - OpenBSD"	pointer
;	O
case	O
ELFOSABI_OPENVMS	int
:	O
return	O
"VMS - OpenVMS"	pointer
;	O
case	O
ELFOSABI_NSK	int
:	O
return	O
"HP - Non-Stop Kernel"	pointer
;	O
case	O
ELFOSABI_AROS	int
:	O
return	O
"AROS"	pointer
;	O
case	O
ELFOSABI_FENIXOS	int
:	O
return	O
"FenixOS"	pointer
;	O
case	O
ELFOSABI_CLOUDABI	int
:	O
return	O
"Nuxi CloudABI"	pointer
;	O
case	O
ELFOSABI_OPENVOS	int
:	O
return	O
"Stratus Technologies OpenVOS"	pointer
;	O
default	O
:	O
if	O
(	O
osabi	int
>=	O
64	int
)	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
case	O
EM_ARM	int
:	O
switch	O
(	O
osabi	int
)	O
{	O
case	O
ELFOSABI_ARM	int
:	O
return	O
"ARM"	pointer
;	O
case	O
ELFOSABI_ARM_FDPIC	int
:	O
return	O
"ARM FDPIC"	pointer
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
case	O
EM_MSP430	int
:	O
case	O
EM_MSP430_OLD	int
:	O
case	O
EM_VISIUM	int
:	O
switch	O
(	O
osabi	int
)	O
{	O
case	O
ELFOSABI_STANDALONE	int
:	O
return	O
_	O
(	O
"Standalone App"	pointer
)	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
case	O
EM_TI_C6000	int
:	O
switch	O
(	O
osabi	int
)	O
{	O
case	O
ELFOSABI_C6000_ELFABI	int
:	O
return	O
_	O
(	O
"Bare-metal C6000"	pointer
)	O
;	O
case	O
ELFOSABI_C6000_LINUX	int
:	O
return	O
"Linux C6000"	pointer
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
snprintf	function
(	O
buff	array
,	O
sizeof	O
(	O
buff	array
)	O
,	O
_	O
(	O
"<unknown: %x>"	pointer
)	O
,	O
osabi	int
)	O
;	O
return	O
buff	array
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_aarch64_segment_type	function
(	O
unsigned	O
long	O
type	enum
)	O
{	O
switch	O
(	O
type	enum
)	O
{	O
case	O
PT_AARCH64_ARCHEXT	O
:	O
return	O
"AARCH64_ARCHEXT"	pointer
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_arm_segment_type	function
(	O
unsigned	O
long	O
type	enum
)	O
{	O
switch	O
(	O
type	enum
)	O
{	O
case	O
PT_ARM_EXIDX	O
:	O
return	O
"EXIDX"	pointer
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_s390_segment_type	function
(	O
unsigned	O
long	O
type	enum
)	O
{	O
switch	O
(	O
type	enum
)	O
{	O
case	O
PT_S390_PGSTE	O
:	O
return	O
"S390_PGSTE"	pointer
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_mips_segment_type	function
(	O
unsigned	O
long	O
type	enum
)	O
{	O
switch	O
(	O
type	enum
)	O
{	O
case	O
PT_MIPS_REGINFO	int
:	O
return	O
"REGINFO"	pointer
;	O
case	O
PT_MIPS_RTPROC	int
:	O
return	O
"RTPROC"	pointer
;	O
case	O
PT_MIPS_OPTIONS	int
:	O
return	O
"OPTIONS"	pointer
;	O
case	O
PT_MIPS_ABIFLAGS	int
:	O
return	O
"ABIFLAGS"	pointer
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_parisc_segment_type	function
(	O
unsigned	O
long	O
type	enum
)	O
{	O
switch	O
(	O
type	enum
)	O
{	O
case	O
PT_PARISC_ARCHEXT	int
:	O
return	O
"PARISC_ARCHEXT"	pointer
;	O
case	O
PT_PARISC_UNWIND	int
:	O
return	O
"PARISC_UNWIND"	pointer
;	O
case	O
PT_PARISC_WEAKORDER	int
:	O
return	O
"PARISC_WEAKORDER"	pointer
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_ia64_segment_type	function
(	O
unsigned	O
long	O
type	enum
)	O
{	O
switch	O
(	O
type	enum
)	O
{	O
case	O
PT_IA_64_ARCHEXT	O
:	O
return	O
"IA_64_ARCHEXT"	pointer
;	O
case	O
PT_IA_64_UNWIND	O
:	O
return	O
"IA_64_UNWIND"	pointer
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_tic6x_segment_type	function
(	O
unsigned	O
long	O
type	enum
)	O
{	O
switch	O
(	O
type	enum
)	O
{	O
case	O
PT_C6000_PHATTR	int
:	O
return	O
"C6000_PHATTR"	pointer
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_hpux_segment_type	function
(	O
unsigned	O
long	O
type	enum
,	O
unsigned	O
e_machine	array
)	O
{	O
if	O
(	O
e_machine	array
==	O
EM_PARISC	int
)	O
switch	O
(	O
type	enum
)	O
{	O
case	O
PT_HP_TLS	O
:	O
return	O
"HP_TLS"	pointer
;	O
case	O
PT_HP_CORE_NONE	O
:	O
return	O
"HP_CORE_NONE"	pointer
;	O
case	O
PT_HP_CORE_VERSION	O
:	O
return	O
"HP_CORE_VERSION"	pointer
;	O
case	O
PT_HP_CORE_KERNEL	O
:	O
return	O
"HP_CORE_KERNEL"	pointer
;	O
case	O
PT_HP_CORE_COMM	O
:	O
return	O
"HP_CORE_COMM"	pointer
;	O
case	O
PT_HP_CORE_PROC	O
:	O
return	O
"HP_CORE_PROC"	pointer
;	O
case	O
PT_HP_CORE_LOADABLE	O
:	O
return	O
"HP_CORE_LOADABLE"	pointer
;	O
case	O
PT_HP_CORE_STACK	O
:	O
return	O
"HP_CORE_STACK"	pointer
;	O
case	O
PT_HP_CORE_SHM	O
:	O
return	O
"HP_CORE_SHM"	pointer
;	O
case	O
PT_HP_CORE_MMF	O
:	O
return	O
"HP_CORE_MMF"	pointer
;	O
case	O
PT_HP_PARALLEL	O
:	O
return	O
"HP_PARALLEL"	pointer
;	O
case	O
PT_HP_FASTBIND	O
:	O
return	O
"HP_FASTBIND"	pointer
;	O
case	O
PT_HP_OPT_ANNOT	O
:	O
return	O
"HP_OPT_ANNOT"	pointer
;	O
case	O
PT_HP_HSL_ANNOT	O
:	O
return	O
"HP_HSL_ANNOT"	pointer
;	O
case	O
PT_HP_STACK	O
:	O
return	O
"HP_STACK"	pointer
;	O
case	O
PT_HP_CORE_UTSNAME	O
:	O
return	O
"HP_CORE_UTSNAME"	pointer
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
if	O
(	O
e_machine	array
==	O
EM_IA_64	int
)	O
switch	O
(	O
type	enum
)	O
{	O
case	O
PT_HP_TLS	O
:	O
return	O
"HP_TLS"	pointer
;	O
case	O
PT_IA_64_HP_OPT_ANOT	O
:	O
return	O
"HP_OPT_ANNOT"	pointer
;	O
case	O
PT_IA_64_HP_HSL_ANOT	O
:	O
return	O
"HP_HSL_ANNOT"	pointer
;	O
case	O
PT_IA_64_HP_STACK	O
:	O
return	O
"HP_STACK"	pointer
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
const	O
char	O
*	O
get_solaris_segment_type	function
(	O
unsigned	O
long	O
type	enum
)	O
{	O
switch	O
(	O
type	enum
)	O
{	O
case	O
0x6464e550	int
:	O
return	O
"PT_SUNW_UNWIND"	pointer
;	O
case	O
0x6474e550	int
:	O
return	O
"PT_SUNW_EH_FRAME"	pointer
;	O
case	O
0x6ffffff7	int
:	O
return	O
"PT_LOSUNW"	pointer
;	O
case	O
0x6ffffffa	int
:	O
return	O
"PT_SUNWBSS"	pointer
;	O
case	O
0x6ffffffb	int
:	O
return	O
"PT_SUNWSTACK"	pointer
;	O
case	O
0x6ffffffc	int
:	O
return	O
"PT_SUNWDTRACE"	pointer
;	O
case	O
0x6ffffffd	int
:	O
return	O
"PT_SUNWCAP"	pointer
;	O
case	O
0x6fffffff	int
:	O
return	O
"PT_HISUNW"	pointer
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_segment_type	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
long	O
p_type	array
)	O
{	O
static	O
char	O
buff	array
[	O
32	int
]	O
;	O
switch	O
(	O
p_type	array
)	O
{	O
case	O
PT_NULL	int
:	O
return	O
"NULL"	pointer
;	O
case	O
PT_LOAD	int
:	O
return	O
"LOAD"	pointer
;	O
case	O
PT_DYNAMIC	int
:	O
return	O
"DYNAMIC"	pointer
;	O
case	O
PT_INTERP	int
:	O
return	O
"INTERP"	pointer
;	O
case	O
PT_NOTE	int
:	O
return	O
"NOTE"	pointer
;	O
case	O
PT_SHLIB	int
:	O
return	O
"SHLIB"	pointer
;	O
case	O
PT_PHDR	int
:	O
return	O
"PHDR"	pointer
;	O
case	O
PT_TLS	int
:	O
return	O
"TLS"	pointer
;	O
case	O
PT_GNU_EH_FRAME	O
:	O
return	O
"GNU_EH_FRAME"	pointer
;	O
case	O
PT_GNU_STACK	O
:	O
return	O
"GNU_STACK"	pointer
;	O
case	O
PT_GNU_RELRO	O
:	O
return	O
"GNU_RELRO"	pointer
;	O
case	O
PT_GNU_PROPERTY	O
:	O
return	O
"GNU_PROPERTY"	pointer
;	O
default	O
:	O
if	O
(	O
(	O
p_type	array
>=	O
PT_LOPROC	int
)	O
&&	O
(	O
p_type	array
<=	O
PT_HIPROC	int
)	O
)	O
{	O
const	O
char	O
*	O
result	pointer
;	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
case	O
EM_AARCH64	int
:	O
result	pointer
=	O
get_aarch64_segment_type	function
(	O
p_type	array
)	O
;	O
break	O
;	O
case	O
EM_ARM	int
:	O
result	pointer
=	O
get_arm_segment_type	function
(	O
p_type	array
)	O
;	O
break	O
;	O
case	O
EM_MIPS	int
:	O
case	O
EM_MIPS_RS3_LE	int
:	O
result	pointer
=	O
get_mips_segment_type	function
(	O
p_type	array
)	O
;	O
break	O
;	O
case	O
EM_PARISC	int
:	O
result	pointer
=	O
get_parisc_segment_type	function
(	O
p_type	array
)	O
;	O
break	O
;	O
case	O
EM_IA_64	int
:	O
result	pointer
=	O
get_ia64_segment_type	function
(	O
p_type	array
)	O
;	O
break	O
;	O
case	O
EM_TI_C6000	int
:	O
result	pointer
=	O
get_tic6x_segment_type	function
(	O
p_type	array
)	O
;	O
break	O
;	O
case	O
EM_S390	int
:	O
case	O
EM_S390_OLD	int
:	O
result	pointer
=	O
get_s390_segment_type	function
(	O
p_type	array
)	O
;	O
break	O
;	O
default	O
:	O
result	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
if	O
(	O
result	pointer
!=	O
NULL	O
)	O
return	O
result	pointer
;	O
sprintf	function
(	O
buff	array
,	O
"LOPROC+%#lx"	pointer
,	O
p_type	array
-	O
PT_LOPROC	int
)	O
;	O
}	O
else	O
if	O
(	O
(	O
p_type	array
>=	O
PT_LOOS	int
)	O
&&	O
(	O
p_type	array
<=	O
PT_HIOS	int
)	O
)	O
{	O
const	O
char	O
*	O
result	pointer
=	O
NULL	O
;	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_ident	array
[	O
EI_OSABI	int
]	O
)	O
{	O
case	O
ELFOSABI_GNU	int
:	O
case	O
ELFOSABI_FREEBSD	int
:	O
if	O
(	O
p_type	array
>=	O
PT_GNU_MBIND_LO	O
&&	O
p_type	array
<=	O
PT_GNU_MBIND_HI	O
)	O
{	O
sprintf	function
(	O
buff	array
,	O
"GNU_MBIND+%#lx"	pointer
,	O
p_type	array
-	O
PT_GNU_MBIND_LO	O
)	O
;	O
result	pointer
=	O
buff	array
;	O
}	O
break	O
;	O
case	O
ELFOSABI_HPUX	int
:	O
result	pointer
=	O
get_hpux_segment_type	function
(	O
p_type	array
,	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
;	O
break	O
;	O
case	O
ELFOSABI_SOLARIS	int
:	O
result	pointer
=	O
get_solaris_segment_type	function
(	O
p_type	array
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
result	pointer
!=	O
NULL	O
)	O
return	O
result	pointer
;	O
sprintf	function
(	O
buff	array
,	O
"LOOS+%#lx"	pointer
,	O
p_type	array
-	O
PT_LOOS	int
)	O
;	O
}	O
else	O
snprintf	function
(	O
buff	array
,	O
sizeof	O
(	O
buff	array
)	O
,	O
_	O
(	O
"<unknown>: %lx"	pointer
)	O
,	O
p_type	array
)	O
;	O
return	O
buff	array
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_arc_section_type_name	function
(	O
unsigned	O
int	O
sh_type	array
)	O
{	O
switch	O
(	O
sh_type	array
)	O
{	O
case	O
SHT_ARC_ATTRIBUTES	int
:	O
return	O
"ARC_ATTRIBUTES"	pointer
;	O
default	O
:	O
break	O
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
const	O
char	O
*	O
get_mips_section_type_name	function
(	O
unsigned	O
int	O
sh_type	array
)	O
{	O
switch	O
(	O
sh_type	array
)	O
{	O
case	O
SHT_MIPS_LIBLIST	int
:	O
return	O
"MIPS_LIBLIST"	pointer
;	O
case	O
SHT_MIPS_MSYM	int
:	O
return	O
"MIPS_MSYM"	pointer
;	O
case	O
SHT_MIPS_CONFLICT	int
:	O
return	O
"MIPS_CONFLICT"	pointer
;	O
case	O
SHT_MIPS_GPTAB	int
:	O
return	O
"MIPS_GPTAB"	pointer
;	O
case	O
SHT_MIPS_UCODE	int
:	O
return	O
"MIPS_UCODE"	pointer
;	O
case	O
SHT_MIPS_DEBUG	int
:	O
return	O
"MIPS_DEBUG"	pointer
;	O
case	O
SHT_MIPS_REGINFO	int
:	O
return	O
"MIPS_REGINFO"	pointer
;	O
case	O
SHT_MIPS_PACKAGE	int
:	O
return	O
"MIPS_PACKAGE"	pointer
;	O
case	O
SHT_MIPS_PACKSYM	int
:	O
return	O
"MIPS_PACKSYM"	pointer
;	O
case	O
SHT_MIPS_RELD	int
:	O
return	O
"MIPS_RELD"	pointer
;	O
case	O
SHT_MIPS_IFACE	int
:	O
return	O
"MIPS_IFACE"	pointer
;	O
case	O
SHT_MIPS_CONTENT	int
:	O
return	O
"MIPS_CONTENT"	pointer
;	O
case	O
SHT_MIPS_OPTIONS	int
:	O
return	O
"MIPS_OPTIONS"	pointer
;	O
case	O
SHT_MIPS_SHDR	int
:	O
return	O
"MIPS_SHDR"	pointer
;	O
case	O
SHT_MIPS_FDESC	int
:	O
return	O
"MIPS_FDESC"	pointer
;	O
case	O
SHT_MIPS_EXTSYM	int
:	O
return	O
"MIPS_EXTSYM"	pointer
;	O
case	O
SHT_MIPS_DENSE	int
:	O
return	O
"MIPS_DENSE"	pointer
;	O
case	O
SHT_MIPS_PDESC	int
:	O
return	O
"MIPS_PDESC"	pointer
;	O
case	O
SHT_MIPS_LOCSYM	int
:	O
return	O
"MIPS_LOCSYM"	pointer
;	O
case	O
SHT_MIPS_AUXSYM	int
:	O
return	O
"MIPS_AUXSYM"	pointer
;	O
case	O
SHT_MIPS_OPTSYM	int
:	O
return	O
"MIPS_OPTSYM"	pointer
;	O
case	O
SHT_MIPS_LOCSTR	int
:	O
return	O
"MIPS_LOCSTR"	pointer
;	O
case	O
SHT_MIPS_LINE	int
:	O
return	O
"MIPS_LINE"	pointer
;	O
case	O
SHT_MIPS_RFDESC	int
:	O
return	O
"MIPS_RFDESC"	pointer
;	O
case	O
SHT_MIPS_DELTASYM	int
:	O
return	O
"MIPS_DELTASYM"	pointer
;	O
case	O
SHT_MIPS_DELTAINST	int
:	O
return	O
"MIPS_DELTAINST"	pointer
;	O
case	O
SHT_MIPS_DELTACLASS	int
:	O
return	O
"MIPS_DELTACLASS"	pointer
;	O
case	O
SHT_MIPS_DWARF	int
:	O
return	O
"MIPS_DWARF"	pointer
;	O
case	O
SHT_MIPS_DELTADECL	int
:	O
return	O
"MIPS_DELTADECL"	pointer
;	O
case	O
SHT_MIPS_SYMBOL_LIB	int
:	O
return	O
"MIPS_SYMBOL_LIB"	pointer
;	O
case	O
SHT_MIPS_EVENTS	int
:	O
return	O
"MIPS_EVENTS"	pointer
;	O
case	O
SHT_MIPS_TRANSLATE	int
:	O
return	O
"MIPS_TRANSLATE"	pointer
;	O
case	O
SHT_MIPS_PIXIE	int
:	O
return	O
"MIPS_PIXIE"	pointer
;	O
case	O
SHT_MIPS_XLATE	int
:	O
return	O
"MIPS_XLATE"	pointer
;	O
case	O
SHT_MIPS_XLATE_DEBUG	int
:	O
return	O
"MIPS_XLATE_DEBUG"	pointer
;	O
case	O
SHT_MIPS_WHIRL	int
:	O
return	O
"MIPS_WHIRL"	pointer
;	O
case	O
SHT_MIPS_EH_REGION	int
:	O
return	O
"MIPS_EH_REGION"	pointer
;	O
case	O
SHT_MIPS_XLATE_OLD	int
:	O
return	O
"MIPS_XLATE_OLD"	pointer
;	O
case	O
SHT_MIPS_PDR_EXCEPTION	int
:	O
return	O
"MIPS_PDR_EXCEPTION"	pointer
;	O
case	O
SHT_MIPS_ABIFLAGS	int
:	O
return	O
"MIPS_ABIFLAGS"	pointer
;	O
case	O
SHT_MIPS_XHASH	int
:	O
return	O
"MIPS_XHASH"	pointer
;	O
default	O
:	O
break	O
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
const	O
char	O
*	O
get_parisc_section_type_name	function
(	O
unsigned	O
int	O
sh_type	array
)	O
{	O
switch	O
(	O
sh_type	array
)	O
{	O
case	O
SHT_PARISC_EXT	int
:	O
return	O
"PARISC_EXT"	pointer
;	O
case	O
SHT_PARISC_UNWIND	int
:	O
return	O
"PARISC_UNWIND"	pointer
;	O
case	O
SHT_PARISC_DOC	int
:	O
return	O
"PARISC_DOC"	pointer
;	O
case	O
SHT_PARISC_ANNOT	int
:	O
return	O
"PARISC_ANNOT"	pointer
;	O
case	O
SHT_PARISC_SYMEXTN	O
:	O
return	O
"PARISC_SYMEXTN"	pointer
;	O
case	O
SHT_PARISC_STUBS	O
:	O
return	O
"PARISC_STUBS"	pointer
;	O
case	O
SHT_PARISC_DLKM	int
:	O
return	O
"PARISC_DLKM"	pointer
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_ia64_section_type_name	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
int	O
sh_type	array
)	O
{	O
if	O
(	O
(	O
sh_type	array
&	O
0xFF000000	int
)	O
==	O
SHT_IA_64_LOPSREG	O
)	O
return	O
get_osabi_name	function
(	O
filedata	struct
,	O
(	O
sh_type	array
&	O
0x00FF0000	int
)	O
>>	O
16	int
)	O
;	O
switch	O
(	O
sh_type	array
)	O
{	O
case	O
SHT_IA_64_EXT	O
:	O
return	O
"IA_64_EXT"	pointer
;	O
case	O
SHT_IA_64_UNWIND	O
:	O
return	O
"IA_64_UNWIND"	pointer
;	O
case	O
SHT_IA_64_PRIORITY_INIT	O
:	O
return	O
"IA_64_PRIORITY_INIT"	pointer
;	O
case	O
SHT_IA_64_VMS_TRACE	int
:	O
return	O
"VMS_TRACE"	pointer
;	O
case	O
SHT_IA_64_VMS_TIE_SIGNATURES	int
:	O
return	O
"VMS_TIE_SIGNATURES"	pointer
;	O
case	O
SHT_IA_64_VMS_DEBUG	int
:	O
return	O
"VMS_DEBUG"	pointer
;	O
case	O
SHT_IA_64_VMS_DEBUG_STR	int
:	O
return	O
"VMS_DEBUG_STR"	pointer
;	O
case	O
SHT_IA_64_VMS_LINKAGES	int
:	O
return	O
"VMS_LINKAGES"	pointer
;	O
case	O
SHT_IA_64_VMS_SYMBOL_VECTOR	int
:	O
return	O
"VMS_SYMBOL_VECTOR"	pointer
;	O
case	O
SHT_IA_64_VMS_FIXUP	int
:	O
return	O
"VMS_FIXUP"	pointer
;	O
default	O
:	O
break	O
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
const	O
char	O
*	O
get_x86_64_section_type_name	function
(	O
unsigned	O
int	O
sh_type	array
)	O
{	O
switch	O
(	O
sh_type	array
)	O
{	O
case	O
SHT_X86_64_UNWIND	int
:	O
return	O
"X86_64_UNWIND"	pointer
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_aarch64_section_type_name	function
(	O
unsigned	O
int	O
sh_type	array
)	O
{	O
switch	O
(	O
sh_type	array
)	O
{	O
case	O
SHT_AARCH64_ATTRIBUTES	int
:	O
return	O
"AARCH64_ATTRIBUTES"	pointer
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_arm_section_type_name	function
(	O
unsigned	O
int	O
sh_type	array
)	O
{	O
switch	O
(	O
sh_type	array
)	O
{	O
case	O
SHT_ARM_EXIDX	int
:	O
return	O
"ARM_EXIDX"	pointer
;	O
case	O
SHT_ARM_PREEMPTMAP	int
:	O
return	O
"ARM_PREEMPTMAP"	pointer
;	O
case	O
SHT_ARM_ATTRIBUTES	int
:	O
return	O
"ARM_ATTRIBUTES"	pointer
;	O
case	O
SHT_ARM_DEBUGOVERLAY	int
:	O
return	O
"ARM_DEBUGOVERLAY"	pointer
;	O
case	O
SHT_ARM_OVERLAYSECTION	int
:	O
return	O
"ARM_OVERLAYSECTION"	pointer
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_tic6x_section_type_name	function
(	O
unsigned	O
int	O
sh_type	array
)	O
{	O
switch	O
(	O
sh_type	array
)	O
{	O
case	O
SHT_C6000_UNWIND	int
:	O
return	O
"C6000_UNWIND"	pointer
;	O
case	O
SHT_C6000_PREEMPTMAP	int
:	O
return	O
"C6000_PREEMPTMAP"	pointer
;	O
case	O
SHT_C6000_ATTRIBUTES	int
:	O
return	O
"C6000_ATTRIBUTES"	pointer
;	O
case	O
SHT_TI_ICODE	int
:	O
return	O
"TI_ICODE"	pointer
;	O
case	O
SHT_TI_XREF	int
:	O
return	O
"TI_XREF"	pointer
;	O
case	O
SHT_TI_HANDLER	int
:	O
return	O
"TI_HANDLER"	pointer
;	O
case	O
SHT_TI_INITINFO	int
:	O
return	O
"TI_INITINFO"	pointer
;	O
case	O
SHT_TI_PHATTRS	int
:	O
return	O
"TI_PHATTRS"	pointer
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_msp430x_section_type_name	function
(	O
unsigned	O
int	O
sh_type	array
)	O
{	O
switch	O
(	O
sh_type	array
)	O
{	O
case	O
SHT_MSP430_SEC_FLAGS	int
:	O
return	O
"MSP430_SEC_FLAGS"	pointer
;	O
case	O
SHT_MSP430_SYM_ALIASES	int
:	O
return	O
"MSP430_SYM_ALIASES"	pointer
;	O
case	O
SHT_MSP430_ATTRIBUTES	int
:	O
return	O
"MSP430_ATTRIBUTES"	pointer
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_nfp_section_type_name	function
(	O
unsigned	O
int	O
sh_type	array
)	O
{	O
switch	O
(	O
sh_type	array
)	O
{	O
case	O
SHT_NFP_MECONFIG	O
:	O
return	O
"NFP_MECONFIG"	pointer
;	O
case	O
SHT_NFP_INITREG	O
:	O
return	O
"NFP_INITREG"	pointer
;	O
case	O
SHT_NFP_UDEBUG	O
:	O
return	O
"NFP_UDEBUG"	pointer
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_v850_section_type_name	function
(	O
unsigned	O
int	O
sh_type	array
)	O
{	O
switch	O
(	O
sh_type	array
)	O
{	O
case	O
SHT_V850_SCOMMON	int
:	O
return	O
"V850 Small Common"	pointer
;	O
case	O
SHT_V850_TCOMMON	int
:	O
return	O
"V850 Tiny Common"	pointer
;	O
case	O
SHT_V850_ZCOMMON	int
:	O
return	O
"V850 Zero Common"	pointer
;	O
case	O
SHT_RENESAS_IOP	O
:	O
return	O
"RENESAS IOP"	pointer
;	O
case	O
SHT_RENESAS_INFO	int
:	O
return	O
"RENESAS INFO"	pointer
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_riscv_section_type_name	function
(	O
unsigned	O
int	O
sh_type	array
)	O
{	O
switch	O
(	O
sh_type	array
)	O
{	O
case	O
SHT_RISCV_ATTRIBUTES	int
:	O
return	O
"RISCV_ATTRIBUTES"	pointer
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_section_type_name	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
int	O
sh_type	array
)	O
{	O
static	O
char	O
buff	array
[	O
32	int
]	O
;	O
const	O
char	O
*	O
result	pointer
;	O
switch	O
(	O
sh_type	array
)	O
{	O
case	O
SHT_NULL	int
:	O
return	O
"NULL"	pointer
;	O
case	O
SHT_PROGBITS	int
:	O
return	O
"PROGBITS"	pointer
;	O
case	O
SHT_SYMTAB	int
:	O
return	O
"SYMTAB"	pointer
;	O
case	O
SHT_STRTAB	int
:	O
return	O
"STRTAB"	pointer
;	O
case	O
SHT_RELA	int
:	O
return	O
"RELA"	pointer
;	O
case	O
SHT_HASH	int
:	O
return	O
"HASH"	pointer
;	O
case	O
SHT_DYNAMIC	int
:	O
return	O
"DYNAMIC"	pointer
;	O
case	O
SHT_NOTE	int
:	O
return	O
"NOTE"	pointer
;	O
case	O
SHT_NOBITS	int
:	O
return	O
"NOBITS"	pointer
;	O
case	O
SHT_REL	int
:	O
return	O
"REL"	pointer
;	O
case	O
SHT_SHLIB	int
:	O
return	O
"SHLIB"	pointer
;	O
case	O
SHT_DYNSYM	int
:	O
return	O
"DYNSYM"	pointer
;	O
case	O
SHT_INIT_ARRAY	int
:	O
return	O
"INIT_ARRAY"	pointer
;	O
case	O
SHT_FINI_ARRAY	int
:	O
return	O
"FINI_ARRAY"	pointer
;	O
case	O
SHT_PREINIT_ARRAY	int
:	O
return	O
"PREINIT_ARRAY"	pointer
;	O
case	O
SHT_GNU_HASH	int
:	O
return	O
"GNU_HASH"	pointer
;	O
case	O
SHT_GROUP	int
:	O
return	O
"GROUP"	pointer
;	O
case	O
SHT_SYMTAB_SHNDX	int
:	O
return	O
"SYMTAB SECTION INDICES"	pointer
;	O
case	O
SHT_GNU_verdef	O
:	O
return	O
"VERDEF"	pointer
;	O
case	O
SHT_GNU_verneed	O
:	O
return	O
"VERNEED"	pointer
;	O
case	O
SHT_GNU_versym	O
:	O
return	O
"VERSYM"	pointer
;	O
case	O
0x6ffffff0	int
:	O
return	O
"VERSYM"	pointer
;	O
case	O
0x6ffffffc	int
:	O
return	O
"VERDEF"	pointer
;	O
case	O
0x7ffffffd	int
:	O
return	O
"AUXILIARY"	pointer
;	O
case	O
0x7fffffff	int
:	O
return	O
"FILTER"	pointer
;	O
case	O
SHT_GNU_LIBLIST	int
:	O
return	O
"GNU_LIBLIST"	pointer
;	O
default	O
:	O
if	O
(	O
(	O
sh_type	array
>=	O
SHT_LOPROC	int
)	O
&&	O
(	O
sh_type	array
<=	O
SHT_HIPROC	int
)	O
)	O
{	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
case	O
EM_ARC	int
:	O
case	O
EM_ARC_COMPACT	int
:	O
case	O
EM_ARC_COMPACT2	int
:	O
result	pointer
=	O
get_arc_section_type_name	function
(	O
sh_type	array
)	O
;	O
break	O
;	O
case	O
EM_MIPS	int
:	O
case	O
EM_MIPS_RS3_LE	int
:	O
result	pointer
=	O
get_mips_section_type_name	function
(	O
sh_type	array
)	O
;	O
break	O
;	O
case	O
EM_PARISC	int
:	O
result	pointer
=	O
get_parisc_section_type_name	function
(	O
sh_type	array
)	O
;	O
break	O
;	O
case	O
EM_IA_64	int
:	O
result	pointer
=	O
get_ia64_section_type_name	function
(	O
filedata	struct
,	O
sh_type	array
)	O
;	O
break	O
;	O
case	O
EM_X86_64	int
:	O
case	O
EM_L1OM	int
:	O
case	O
EM_K1OM	int
:	O
result	pointer
=	O
get_x86_64_section_type_name	function
(	O
sh_type	array
)	O
;	O
break	O
;	O
case	O
EM_AARCH64	int
:	O
result	pointer
=	O
get_aarch64_section_type_name	function
(	O
sh_type	array
)	O
;	O
break	O
;	O
case	O
EM_ARM	int
:	O
result	pointer
=	O
get_arm_section_type_name	function
(	O
sh_type	array
)	O
;	O
break	O
;	O
case	O
EM_TI_C6000	int
:	O
result	pointer
=	O
get_tic6x_section_type_name	function
(	O
sh_type	array
)	O
;	O
break	O
;	O
case	O
EM_MSP430	int
:	O
result	pointer
=	O
get_msp430x_section_type_name	function
(	O
sh_type	array
)	O
;	O
break	O
;	O
case	O
EM_NFP	int
:	O
result	pointer
=	O
get_nfp_section_type_name	function
(	O
sh_type	array
)	O
;	O
break	O
;	O
case	O
EM_V800	int
:	O
case	O
EM_V850	int
:	O
case	O
EM_CYGNUS_V850	int
:	O
result	pointer
=	O
get_v850_section_type_name	function
(	O
sh_type	array
)	O
;	O
break	O
;	O
case	O
EM_RISCV	int
:	O
result	pointer
=	O
get_riscv_section_type_name	function
(	O
sh_type	array
)	O
;	O
break	O
;	O
default	O
:	O
result	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
if	O
(	O
result	pointer
!=	O
NULL	O
)	O
return	O
result	pointer
;	O
sprintf	function
(	O
buff	array
,	O
"LOPROC+%#x"	pointer
,	O
sh_type	array
-	O
SHT_LOPROC	int
)	O
;	O
}	O
else	O
if	O
(	O
(	O
sh_type	array
>=	O
SHT_LOOS	int
)	O
&&	O
(	O
sh_type	array
<=	O
SHT_HIOS	int
)	O
)	O
{	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
case	O
EM_IA_64	int
:	O
result	pointer
=	O
get_ia64_section_type_name	function
(	O
filedata	struct
,	O
sh_type	array
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_ident	array
[	O
EI_OSABI	int
]	O
==	O
ELFOSABI_SOLARIS	int
)	O
result	pointer
=	O
get_solaris_section_type	function
(	O
sh_type	array
)	O
;	O
else	O
{	O
switch	O
(	O
sh_type	array
)	O
{	O
case	O
SHT_GNU_INCREMENTAL_INPUTS	int
:	O
result	pointer
=	O
"GNU_INCREMENTAL_INPUTS"	pointer
;	O
break	O
;	O
case	O
SHT_GNU_ATTRIBUTES	int
:	O
result	pointer
=	O
"GNU_ATTRIBUTES"	pointer
;	O
break	O
;	O
case	O
SHT_GNU_HASH	int
:	O
result	pointer
=	O
"GNU_HASH"	pointer
;	O
break	O
;	O
case	O
SHT_GNU_LIBLIST	int
:	O
result	pointer
=	O
"GNU_LIBLIST"	pointer
;	O
break	O
;	O
default	O
:	O
result	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
}	O
break	O
;	O
}	O
if	O
(	O
result	pointer
!=	O
NULL	O
)	O
return	O
result	pointer
;	O
sprintf	function
(	O
buff	array
,	O
"LOOS+%#x"	pointer
,	O
sh_type	array
-	O
SHT_LOOS	int
)	O
;	O
}	O
else	O
if	O
(	O
(	O
sh_type	array
>=	O
SHT_LOUSER	int
)	O
&&	O
(	O
sh_type	array
<=	O
SHT_HIUSER	int
)	O
)	O
{	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
case	O
EM_V800	int
:	O
case	O
EM_V850	int
:	O
case	O
EM_CYGNUS_V850	int
:	O
result	pointer
=	O
get_v850_section_type_name	function
(	O
sh_type	array
)	O
;	O
break	O
;	O
default	O
:	O
result	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
if	O
(	O
result	pointer
!=	O
NULL	O
)	O
return	O
result	pointer
;	O
sprintf	function
(	O
buff	array
,	O
"LOUSER+%#x"	pointer
,	O
sh_type	array
-	O
SHT_LOUSER	int
)	O
;	O
}	O
else	O
snprintf	function
(	O
buff	array
,	O
sizeof	O
(	O
buff	array
)	O
,	O
_	O
(	O
"%08x: <unknown>"	pointer
)	O
,	O
sh_type	array
)	O
;	O
return	O
buff	array
;	O
}	O
}	O
static	O
struct	O
option	struct
options	array
[	O
]	O
=	O
{	O
{	O
"all"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'a'	O
}	O
,	O
{	O
"file-header"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'h'	O
}	O
,	O
{	O
"program-headers"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'l'	O
}	O
,	O
{	O
"headers"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'e'	O
}	O
,	O
{	O
"histogram"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'I'	O
}	O
,	O
{	O
"segments"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'l'	O
}	O
,	O
{	O
"sections"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'S'	O
}	O
,	O
{	O
"section-headers"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'S'	O
}	O
,	O
{	O
"section-groups"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'g'	O
}	O
,	O
{	O
"section-details"	pointer
,	O
no_argument	int
,	O
0	int
,	O
't'	O
}	O
,	O
{	O
"full-section-name"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'N'	O
}	O
,	O
{	O
"symbols"	pointer
,	O
no_argument	int
,	O
0	int
,	O
's'	O
}	O
,	O
{	O
"syms"	pointer
,	O
no_argument	int
,	O
0	int
,	O
's'	O
}	O
,	O
{	O
"dyn-syms"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_DYN_SYMS	int
}	O
,	O
{	O
"relocs"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'r'	O
}	O
,	O
{	O
"notes"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'n'	O
}	O
,	O
{	O
"dynamic"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'd'	O
}	O
,	O
{	O
"arch-specific"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'A'	O
}	O
,	O
{	O
"version-info"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'V'	O
}	O
,	O
{	O
"use-dynamic"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'D'	O
}	O
,	O
{	O
"unwind"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'u'	O
}	O
,	O
{	O
"archive-index"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'c'	O
}	O
,	O
{	O
"hex-dump"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'x'	O
}	O
,	O
{	O
"relocated-dump"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'R'	O
}	O
,	O
{	O
"string-dump"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'p'	O
}	O
,	O
{	O
"decompress"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'z'	O
}	O
,	O
{	O
"debug-dump"	pointer
,	O
optional_argument	int
,	O
0	int
,	O
OPTION_DEBUG_DUMP	int
}	O
,	O
{	O
"dwarf-depth"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_DWARF_DEPTH	int
}	O
,	O
{	O
"dwarf-start"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_DWARF_START	int
}	O
,	O
{	O
"dwarf-check"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_DWARF_CHECK	int
}	O
,	O
{	O
"ctf"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_CTF_DUMP	int
}	O
,	O
{	O
"ctf-symbols"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_CTF_SYMBOLS	int
}	O
,	O
{	O
"ctf-strings"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_CTF_STRINGS	int
}	O
,	O
{	O
"ctf-parent"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_CTF_PARENT	int
}	O
,	O
{	O
"version"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'v'	O
}	O
,	O
{	O
"wide"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'W'	O
}	O
,	O
{	O
"help"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'H'	O
}	O
,	O
{	O
0	int
,	O
no_argument	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
void	O
usage	function
(	O
FILE	struct
*	O
stream	pointer
)	O
{	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"Usage: readelf <option(s)> elf-file(s)\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
" Display information about the contents of ELF format files\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
" Options are:\n  -a --all               Equivalent to: -h -l -S -s -r -d -V -A -I\n  -h --file-header       Display the ELF file header\n  -l --program-headers   Display the program headers\n     --segments          An alias for --program-headers\n  -S --section-headers   Display the sections' header\n     --sections          An alias for --section-headers\n  -g --section-groups    Display the section groups\n  -t --section-details   Display the section details\n  -e --headers           Equivalent to: -h -l -S\n  -s --syms              Display the symbol table\n     --symbols           An alias for --syms\n  --dyn-syms             Display the dynamic symbol table\n  -n --notes             Display the core notes (if present)\n  -r --relocs            Display the relocations (if present)\n  -u --unwind            Display the unwind info (if present)\n  -d --dynamic           Display the dynamic section (if present)\n  -V --version-info      Display the version sections (if present)\n  -A --arch-specific     Display architecture specific information (if any)\n  -c --archive-index     Display the symbol/file index in an archive\n  -D --use-dynamic       Use the dynamic section info when displaying symbols\n  -x --hex-dump=<number|name>\n                         Dump the contents of section <number|name> as bytes\n  -p --string-dump=<number|name>\n                         Dump the contents of section <number|name> as strings\n  -R --relocated-dump=<number|name>\n                         Dump the contents of section <number|name> as relocated bytes\n  -z --decompress        Decompress section before dumping it\n  -w[lLiaprmfFsoRtUuTgAckK] or\n  --debug-dump[=rawline,=decodedline,=info,=abbrev,=pubnames,=aranges,=macro,=frames,\n               =frames-interp,=str,=loc,=Ranges,=pubtypes,\n               =gdb_index,=trace_info,=trace_abbrev,=trace_aranges,\n               =addr,=cu_index,=links,=follow-links]\n                         Display the contents of DWARF debug sections\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"  --dwarf-depth=N        Do not display DIEs at depth N or greater\n  --dwarf-start=N        Display DIEs starting with N, at the same depth\n                         or deeper\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"  --ctf=<number|name>    Display CTF info from section <number|name>\n  --ctf-parent=<number|name>\n                         Use section <number|name> as the CTF parent\n\n  --ctf-symbols=<number|name>\n                         Use section <number|name> as the CTF external symtab\n\n  --ctf-strings=<number|name>\n                         Use section <number|name> as the CTF external strtab\n\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"  -I --histogram         Display histogram of bucket list lengths\n  -W --wide              Allow output width to exceed 80 characters\n  @<file>                Read options from <file>\n  -H --help              Display this information\n  -v --version           Display the version number of readelf\n"	pointer
)	O
)	O
;	O
if	O
(	O
REPORT_BUGS_TO	pointer
[	O
0	int
]	O
&&	O
stream	pointer
==	O
stdout	pointer
)	O
fprintf	function
(	O
stdout	pointer
,	O
_	O
(	O
"Report bugs to %s\n"	pointer
)	O
,	O
REPORT_BUGS_TO	pointer
)	O
;	O
exit	function
(	O
stream	pointer
==	O
stdout	pointer
?	O
0	int
:	O
1	int
)	O
;	O
}	O
static	O
void	O
request_dump_bynumber	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
int	O
section	pointer
,	O
dump_type	char
type	enum
)	O
{	O
if	O
(	O
section	pointer
>=	O
filedata	struct
->	O
num_dump_sects	int
)	O
{	O
dump_type	char
*	O
new_dump_sects	pointer
;	O
new_dump_sects	pointer
=	O
(	O
dump_type	char
*	O
)	O
calloc	function
(	O
section	pointer
+	O
1	int
,	O
sizeof	O
(	O
*	O
new_dump_sects	pointer
)	O
)	O
;	O
if	O
(	O
new_dump_sects	pointer
==	O
NULL	O
)	O
error	function
(	O
_	O
(	O
"Out of memory allocating dump request table.\n"	pointer
)	O
)	O
;	O
else	O
{	O
if	O
(	O
filedata	struct
->	O
dump_sects	pointer
)	O
{	O
memcpy	function
(	O
new_dump_sects	pointer
,	O
filedata	struct
->	O
dump_sects	pointer
,	O
filedata	struct
->	O
num_dump_sects	int
*	O
sizeof	O
(	O
*	O
new_dump_sects	pointer
)	O
)	O
;	O
free	function
(	O
filedata	struct
->	O
dump_sects	pointer
)	O
;	O
}	O
filedata	struct
->	O
dump_sects	pointer
=	O
new_dump_sects	pointer
;	O
filedata	struct
->	O
num_dump_sects	int
=	O
section	pointer
+	O
1	int
;	O
}	O
}	O
if	O
(	O
filedata	struct
->	O
dump_sects	pointer
)	O
filedata	struct
->	O
dump_sects	pointer
[	O
section	pointer
]	O
|=	O
type	enum
;	O
}	O
static	O
void	O
request_dump_byname	function
(	O
const	O
char	O
*	O
section	pointer
,	O
dump_type	char
type	enum
)	O
{	O
struct	O
dump_list_entry	struct
*	O
new_request	pointer
;	O
new_request	pointer
=	O
(	O
struct	O
dump_list_entry	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
struct	O
dump_list_entry	struct
)	O
)	O
;	O
if	O
(	O
!	O
new_request	pointer
)	O
error	function
(	O
_	O
(	O
"Out of memory allocating dump request table.\n"	pointer
)	O
)	O
;	O
new_request	pointer
->	O
name	pointer
=	O
strdup	function
(	O
section	pointer
)	O
;	O
if	O
(	O
!	O
new_request	pointer
->	O
name	pointer
)	O
error	function
(	O
_	O
(	O
"Out of memory allocating dump request table.\n"	pointer
)	O
)	O
;	O
new_request	pointer
->	O
type	enum
=	O
type	enum
;	O
new_request	pointer
->	O
next	pointer
=	O
dump_sects_byname	pointer
;	O
dump_sects_byname	pointer
=	O
new_request	pointer
;	O
}	O
static	O
inline	O
void	O
request_dump	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
dump_type	char
type	enum
)	O
{	O
int	O
section	pointer
;	O
char	O
*	O
cp	pointer
;	O
do_dump	int
++	O
;	O
section	pointer
=	O
strtoul	function
(	O
optarg	pointer
,	O
&	O
cp	pointer
,	O
0	int
)	O
;	O
if	O
(	O
!	O
*	O
cp	pointer
&&	O
section	pointer
>=	O
0	int
)	O
request_dump_bynumber	function
(	O
filedata	struct
,	O
section	pointer
,	O
type	enum
)	O
;	O
else	O
request_dump_byname	function
(	O
optarg	pointer
,	O
type	enum
)	O
;	O
}	O
static	O
void	O
parse_args	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
c	int
;	O
if	O
(	O
argc	int
<	O
2	int
)	O
usage	function
(	O
stderr	pointer
)	O
;	O
while	O
(	O
(	O
c	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
"ADHINR:SVWacdeghi:lnp:rstuvw::x:z"	pointer
,	O
options	array
,	O
NULL	O
)	O
)	O
!=	O
EOF	O
)	O
{	O
switch	O
(	O
c	int
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
'H'	O
:	O
usage	function
(	O
stdout	pointer
)	O
;	O
break	O
;	O
case	O
'a'	O
:	O
do_syms	int
=	O
TRUE	int
;	O
do_reloc	int
=	O
TRUE	int
;	O
do_unwind	int
=	O
TRUE	int
;	O
do_dynamic	int
=	O
TRUE	int
;	O
do_header	int
=	O
TRUE	int
;	O
do_sections	int
=	O
TRUE	int
;	O
do_section_groups	int
=	O
TRUE	int
;	O
do_segments	int
=	O
TRUE	int
;	O
do_version	int
=	O
TRUE	int
;	O
do_histogram	int
=	O
TRUE	int
;	O
do_arch	int
=	O
TRUE	int
;	O
do_notes	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'g'	O
:	O
do_section_groups	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
't'	O
:	O
case	O
'N'	O
:	O
do_sections	int
=	O
TRUE	int
;	O
do_section_details	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'e'	O
:	O
do_header	int
=	O
TRUE	int
;	O
do_sections	int
=	O
TRUE	int
;	O
do_segments	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'A'	O
:	O
do_arch	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'D'	O
:	O
do_using_dynamic	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'r'	O
:	O
do_reloc	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'u'	O
:	O
do_unwind	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'h'	O
:	O
do_header	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'l'	O
:	O
do_segments	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
's'	O
:	O
do_syms	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'S'	O
:	O
do_sections	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'd'	O
:	O
do_dynamic	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'I'	O
:	O
do_histogram	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'n'	O
:	O
do_notes	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'c'	O
:	O
do_archive_index	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'x'	O
:	O
request_dump	function
(	O
filedata	struct
,	O
HEX_DUMP	O
)	O
;	O
break	O
;	O
case	O
'p'	O
:	O
request_dump	function
(	O
filedata	struct
,	O
STRING_DUMP	O
)	O
;	O
break	O
;	O
case	O
'R'	O
:	O
request_dump	function
(	O
filedata	struct
,	O
RELOC_DUMP	O
)	O
;	O
break	O
;	O
case	O
'z'	O
:	O
decompress_dumps	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'w'	O
:	O
do_dump	int
=	O
TRUE	int
;	O
if	O
(	O
optarg	pointer
==	O
0	int
)	O
{	O
do_debugging	int
=	O
TRUE	int
;	O
dwarf_select_sections_all	function
(	O
)	O
;	O
}	O
else	O
{	O
do_debugging	int
=	O
FALSE	int
;	O
dwarf_select_sections_by_letters	function
(	O
optarg	pointer
)	O
;	O
}	O
break	O
;	O
case	O
OPTION_DEBUG_DUMP	int
:	O
do_dump	int
=	O
TRUE	int
;	O
if	O
(	O
optarg	pointer
==	O
0	int
)	O
do_debugging	int
=	O
TRUE	int
;	O
else	O
{	O
do_debugging	int
=	O
FALSE	int
;	O
dwarf_select_sections_by_names	function
(	O
optarg	pointer
)	O
;	O
}	O
break	O
;	O
case	O
OPTION_DWARF_DEPTH	int
:	O
{	O
char	O
*	O
cp	pointer
;	O
dwarf_cutoff_level	int
=	O
strtoul	function
(	O
optarg	pointer
,	O
&	O
cp	pointer
,	O
0	int
)	O
;	O
}	O
break	O
;	O
case	O
OPTION_DWARF_START	int
:	O
{	O
char	O
*	O
cp	pointer
;	O
dwarf_start_die	long
=	O
strtoul	function
(	O
optarg	pointer
,	O
&	O
cp	pointer
,	O
0	int
)	O
;	O
}	O
break	O
;	O
case	O
OPTION_DWARF_CHECK	int
:	O
dwarf_check	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_CTF_DUMP	int
:	O
do_ctf	int
=	O
TRUE	int
;	O
request_dump	function
(	O
filedata	struct
,	O
CTF_DUMP	O
)	O
;	O
break	O
;	O
case	O
OPTION_CTF_SYMBOLS	int
:	O
dump_ctf_symtab_name	pointer
=	O
strdup	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_CTF_STRINGS	int
:	O
dump_ctf_strtab_name	pointer
=	O
strdup	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_CTF_PARENT	int
:	O
dump_ctf_parent_name	pointer
=	O
strdup	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_DYN_SYMS	int
:	O
do_dyn_syms	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'v'	O
:	O
print_version	function
(	O
program_name	pointer
)	O
;	O
break	O
;	O
case	O
'V'	O
:	O
do_version	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'W'	O
:	O
do_wide	int
=	O
TRUE	int
;	O
break	O
;	O
default	O
:	O
error	function
(	O
_	O
(	O
"Invalid option '-%c'\n"	pointer
)	O
,	O
c	int
)	O
;	O
case	O
'?'	O
:	O
usage	function
(	O
stderr	pointer
)	O
;	O
}	O
}	O
if	O
(	O
!	O
do_dynamic	int
&&	O
!	O
do_syms	int
&&	O
!	O
do_reloc	int
&&	O
!	O
do_unwind	int
&&	O
!	O
do_sections	int
&&	O
!	O
do_segments	int
&&	O
!	O
do_header	int
&&	O
!	O
do_dump	int
&&	O
!	O
do_version	int
&&	O
!	O
do_histogram	int
&&	O
!	O
do_debugging	int
&&	O
!	O
do_arch	int
&&	O
!	O
do_notes	int
&&	O
!	O
do_section_groups	int
&&	O
!	O
do_archive_index	int
&&	O
!	O
do_dyn_syms	int
)	O
usage	function
(	O
stderr	pointer
)	O
;	O
}	O
static	O
const	O
char	O
*	O
get_elf_class	function
(	O
unsigned	O
int	O
elf_class	int
)	O
{	O
static	O
char	O
buff	array
[	O
32	int
]	O
;	O
switch	O
(	O
elf_class	int
)	O
{	O
case	O
ELFCLASSNONE	int
:	O
return	O
_	O
(	O
"none"	pointer
)	O
;	O
case	O
ELFCLASS32	int
:	O
return	O
"ELF32"	pointer
;	O
case	O
ELFCLASS64	int
:	O
return	O
"ELF64"	pointer
;	O
default	O
:	O
snprintf	function
(	O
buff	array
,	O
sizeof	O
(	O
buff	array
)	O
,	O
_	O
(	O
"<unknown: %x>"	pointer
)	O
,	O
elf_class	int
)	O
;	O
return	O
buff	array
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_data_encoding	function
(	O
unsigned	O
int	O
encoding	int
)	O
{	O
static	O
char	O
buff	array
[	O
32	int
]	O
;	O
switch	O
(	O
encoding	int
)	O
{	O
case	O
ELFDATANONE	int
:	O
return	O
_	O
(	O
"none"	pointer
)	O
;	O
case	O
ELFDATA2LSB	int
:	O
return	O
_	O
(	O
"2's complement, little endian"	pointer
)	O
;	O
case	O
ELFDATA2MSB	int
:	O
return	O
_	O
(	O
"2's complement, big endian"	pointer
)	O
;	O
default	O
:	O
snprintf	function
(	O
buff	array
,	O
sizeof	O
(	O
buff	array
)	O
,	O
_	O
(	O
"<unknown: %x>"	pointer
)	O
,	O
encoding	int
)	O
;	O
return	O
buff	array
;	O
}	O
}	O
static	O
bfd_boolean	int
process_file_header	function
(	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
Elf_Internal_Ehdr	struct
*	O
header	pointer
=	O
&	O
filedata	struct
->	O
file_header	struct
;	O
if	O
(	O
header	pointer
->	O
e_ident	array
[	O
EI_MAG0	int
]	O
!=	O
ELFMAG0	int
||	O
header	pointer
->	O
e_ident	array
[	O
EI_MAG1	int
]	O
!=	O
ELFMAG1	char
||	O
header	pointer
->	O
e_ident	array
[	O
EI_MAG2	int
]	O
!=	O
ELFMAG2	char
||	O
header	pointer
->	O
e_ident	array
[	O
EI_MAG3	int
]	O
!=	O
ELFMAG3	char
)	O
{	O
error	function
(	O
_	O
(	O
"Not an ELF file - it has the wrong magic bytes at the start\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
init_dwarf_regnames_by_elf_machine_code	function
(	O
header	pointer
->	O
e_machine	array
)	O
;	O
if	O
(	O
do_header	int
)	O
{	O
unsigned	O
i	pointer
;	O
printf	function
(	O
_	O
(	O
"ELF Header:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  Magic:   "	pointer
)	O
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
EI_NIDENT	int
;	O
i	pointer
++	O
)	O
printf	function
(	O
"%2.2x "	pointer
,	O
header	pointer
->	O
e_ident	array
[	O
i	pointer
]	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"  Class:                             %s\n"	pointer
)	O
,	O
get_elf_class	function
(	O
header	pointer
->	O
e_ident	array
[	O
EI_CLASS	int
]	O
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  Data:                              %s\n"	pointer
)	O
,	O
get_data_encoding	function
(	O
header	pointer
->	O
e_ident	array
[	O
EI_DATA	int
]	O
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  Version:                           %d%s\n"	pointer
)	O
,	O
header	pointer
->	O
e_ident	array
[	O
EI_VERSION	int
]	O
,	O
(	O
header	pointer
->	O
e_ident	array
[	O
EI_VERSION	int
]	O
==	O
EV_CURRENT	int
?	O
_	O
(	O
" (current)"	pointer
)	O
:	O
(	O
header	pointer
->	O
e_ident	array
[	O
EI_VERSION	int
]	O
!=	O
EV_NONE	int
?	O
_	O
(	O
" <unknown>"	pointer
)	O
:	O
""	pointer
)	O
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  OS/ABI:                            %s\n"	pointer
)	O
,	O
get_osabi_name	function
(	O
filedata	struct
,	O
header	pointer
->	O
e_ident	array
[	O
EI_OSABI	int
]	O
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  ABI Version:                       %d\n"	pointer
)	O
,	O
header	pointer
->	O
e_ident	array
[	O
EI_ABIVERSION	int
]	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  Type:                              %s\n"	pointer
)	O
,	O
get_file_type	function
(	O
header	pointer
->	O
e_type	array
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  Machine:                           %s\n"	pointer
)	O
,	O
get_machine_name	function
(	O
header	pointer
->	O
e_machine	array
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  Version:                           0x%lx\n"	pointer
)	O
,	O
header	pointer
->	O
e_version	array
)	O
;	O
printf	function
(	O
_	O
(	O
"  Entry point address:               "	pointer
)	O
)	O
;	O
print_vma	function
(	O
header	pointer
->	O
e_entry	array
,	O
PREFIX_HEX	int
)	O
;	O
printf	function
(	O
_	O
(	O
"\n  Start of program headers:          "	pointer
)	O
)	O
;	O
print_vma	function
(	O
header	pointer
->	O
e_phoff	array
,	O
DEC	int
)	O
;	O
printf	function
(	O
_	O
(	O
" (bytes into file)\n  Start of section headers:          "	pointer
)	O
)	O
;	O
print_vma	function
(	O
header	pointer
->	O
e_shoff	array
,	O
DEC	int
)	O
;	O
printf	function
(	O
_	O
(	O
" (bytes into file)\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  Flags:                             0x%lx%s\n"	pointer
)	O
,	O
header	pointer
->	O
e_flags	array
,	O
get_machine_flags	function
(	O
filedata	struct
,	O
header	pointer
->	O
e_flags	array
,	O
header	pointer
->	O
e_machine	array
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  Size of this header:               %u (bytes)\n"	pointer
)	O
,	O
header	pointer
->	O
e_ehsize	array
)	O
;	O
printf	function
(	O
_	O
(	O
"  Size of program headers:           %u (bytes)\n"	pointer
)	O
,	O
header	pointer
->	O
e_phentsize	array
)	O
;	O
printf	function
(	O
_	O
(	O
"  Number of program headers:         %u"	pointer
)	O
,	O
header	pointer
->	O
e_phnum	array
)	O
;	O
if	O
(	O
filedata	struct
->	O
section_headers	pointer
!=	O
NULL	O
&&	O
header	pointer
->	O
e_phnum	array
==	O
PN_XNUM	int
&&	O
filedata	struct
->	O
section_headers	pointer
[	O
0	int
]	O
.	O
sh_info	array
!=	O
0	int
)	O
{	O
header	pointer
->	O
e_phnum	array
=	O
filedata	struct
->	O
section_headers	pointer
[	O
0	int
]	O
.	O
sh_info	array
;	O
printf	function
(	O
" (%u)"	pointer
,	O
header	pointer
->	O
e_phnum	array
)	O
;	O
}	O
putc	function
(	O
'\n'	O
,	O
stdout	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"  Size of section headers:           %u (bytes)\n"	pointer
)	O
,	O
header	pointer
->	O
e_shentsize	array
)	O
;	O
printf	function
(	O
_	O
(	O
"  Number of section headers:         %u"	pointer
)	O
,	O
header	pointer
->	O
e_shnum	array
)	O
;	O
if	O
(	O
filedata	struct
->	O
section_headers	pointer
!=	O
NULL	O
&&	O
header	pointer
->	O
e_shnum	array
==	O
SHN_UNDEF	int
)	O
{	O
header	pointer
->	O
e_shnum	array
=	O
filedata	struct
->	O
section_headers	pointer
[	O
0	int
]	O
.	O
sh_size	array
;	O
printf	function
(	O
" (%u)"	pointer
,	O
header	pointer
->	O
e_shnum	array
)	O
;	O
}	O
putc	function
(	O
'\n'	O
,	O
stdout	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"  Section header string table index: %u"	pointer
)	O
,	O
header	pointer
->	O
e_shstrndx	array
)	O
;	O
if	O
(	O
filedata	struct
->	O
section_headers	pointer
!=	O
NULL	O
&&	O
header	pointer
->	O
e_shstrndx	array
==	O
(	O
SHN_XINDEX	O
&	O
0xffff	int
)	O
)	O
{	O
header	pointer
->	O
e_shstrndx	array
=	O
filedata	struct
->	O
section_headers	pointer
[	O
0	int
]	O
.	O
sh_link	array
;	O
printf	function
(	O
" (%u)"	pointer
,	O
header	pointer
->	O
e_shstrndx	array
)	O
;	O
}	O
if	O
(	O
header	pointer
->	O
e_shstrndx	array
!=	O
SHN_UNDEF	int
&&	O
header	pointer
->	O
e_shstrndx	array
>=	O
header	pointer
->	O
e_shnum	array
)	O
{	O
header	pointer
->	O
e_shstrndx	array
=	O
SHN_UNDEF	int
;	O
printf	function
(	O
_	O
(	O
" <corrupt: out of range>"	pointer
)	O
)	O
;	O
}	O
putc	function
(	O
'\n'	O
,	O
stdout	pointer
)	O
;	O
}	O
if	O
(	O
filedata	struct
->	O
section_headers	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
header	pointer
->	O
e_phnum	array
==	O
PN_XNUM	int
&&	O
filedata	struct
->	O
section_headers	pointer
[	O
0	int
]	O
.	O
sh_info	array
!=	O
0	int
)	O
header	pointer
->	O
e_phnum	array
=	O
filedata	struct
->	O
section_headers	pointer
[	O
0	int
]	O
.	O
sh_info	array
;	O
if	O
(	O
header	pointer
->	O
e_shnum	array
==	O
SHN_UNDEF	int
)	O
header	pointer
->	O
e_shnum	array
=	O
filedata	struct
->	O
section_headers	pointer
[	O
0	int
]	O
.	O
sh_size	array
;	O
if	O
(	O
header	pointer
->	O
e_shstrndx	array
==	O
(	O
SHN_XINDEX	O
&	O
0xffff	int
)	O
)	O
header	pointer
->	O
e_shstrndx	array
=	O
filedata	struct
->	O
section_headers	pointer
[	O
0	int
]	O
.	O
sh_link	array
;	O
if	O
(	O
header	pointer
->	O
e_shstrndx	array
>=	O
header	pointer
->	O
e_shnum	array
)	O
header	pointer
->	O
e_shstrndx	array
=	O
SHN_UNDEF	int
;	O
free	function
(	O
filedata	struct
->	O
section_headers	pointer
)	O
;	O
filedata	struct
->	O
section_headers	pointer
=	O
NULL	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
get_32bit_program_headers	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
Elf_Internal_Phdr	struct
*	O
pheaders	pointer
)	O
{	O
Elf32_External_Phdr	struct
*	O
phdrs	pointer
;	O
Elf32_External_Phdr	struct
*	O
external	pointer
;	O
Elf_Internal_Phdr	struct
*	O
internal	pointer
;	O
unsigned	O
int	O
i	pointer
;	O
unsigned	O
int	O
size	int
=	O
filedata	struct
->	O
file_header	struct
.	O
e_phentsize	array
;	O
unsigned	O
int	O
num	int
=	O
filedata	struct
->	O
file_header	struct
.	O
e_phnum	array
;	O
if	O
(	O
size	int
==	O
0	int
||	O
num	int
==	O
0	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
size	int
<	O
sizeof	O
*	O
phdrs	pointer
)	O
{	O
error	function
(	O
_	O
(	O
"The e_phentsize field in the ELF header is less than the size of an ELF program header\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
size	int
>	O
sizeof	O
*	O
phdrs	pointer
)	O
warn	function
(	O
_	O
(	O
"The e_phentsize field in the ELF header is larger than the size of an ELF program header\n"	pointer
)	O
)	O
;	O
phdrs	pointer
=	O
(	O
Elf32_External_Phdr	struct
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
filedata	struct
->	O
file_header	struct
.	O
e_phoff	array
,	O
size	int
,	O
num	int
,	O
_	O
(	O
"program headers"	pointer
)	O
)	O
;	O
if	O
(	O
phdrs	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
for	O
(	O
i	pointer
=	O
0	int
,	O
internal	pointer
=	O
pheaders	pointer
,	O
external	pointer
=	O
phdrs	pointer
;	O
i	pointer
<	O
filedata	struct
->	O
file_header	struct
.	O
e_phnum	array
;	O
i	pointer
++	O
,	O
internal	pointer
++	O
,	O
external	pointer
++	O
)	O
{	O
internal	pointer
->	O
p_type	array
=	O
BYTE_GET	O
(	O
external	pointer
->	O
p_type	array
)	O
;	O
internal	pointer
->	O
p_offset	array
=	O
BYTE_GET	O
(	O
external	pointer
->	O
p_offset	array
)	O
;	O
internal	pointer
->	O
p_vaddr	array
=	O
BYTE_GET	O
(	O
external	pointer
->	O
p_vaddr	array
)	O
;	O
internal	pointer
->	O
p_paddr	array
=	O
BYTE_GET	O
(	O
external	pointer
->	O
p_paddr	array
)	O
;	O
internal	pointer
->	O
p_filesz	array
=	O
BYTE_GET	O
(	O
external	pointer
->	O
p_filesz	array
)	O
;	O
internal	pointer
->	O
p_memsz	array
=	O
BYTE_GET	O
(	O
external	pointer
->	O
p_memsz	array
)	O
;	O
internal	pointer
->	O
p_flags	array
=	O
BYTE_GET	O
(	O
external	pointer
->	O
p_flags	array
)	O
;	O
internal	pointer
->	O
p_align	array
=	O
BYTE_GET	O
(	O
external	pointer
->	O
p_align	array
)	O
;	O
}	O
free	function
(	O
phdrs	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
get_64bit_program_headers	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
Elf_Internal_Phdr	struct
*	O
pheaders	pointer
)	O
{	O
Elf64_External_Phdr	struct
*	O
phdrs	pointer
;	O
Elf64_External_Phdr	struct
*	O
external	pointer
;	O
Elf_Internal_Phdr	struct
*	O
internal	pointer
;	O
unsigned	O
int	O
i	pointer
;	O
unsigned	O
int	O
size	int
=	O
filedata	struct
->	O
file_header	struct
.	O
e_phentsize	array
;	O
unsigned	O
int	O
num	int
=	O
filedata	struct
->	O
file_header	struct
.	O
e_phnum	array
;	O
if	O
(	O
size	int
==	O
0	int
||	O
num	int
==	O
0	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
size	int
<	O
sizeof	O
*	O
phdrs	pointer
)	O
{	O
error	function
(	O
_	O
(	O
"The e_phentsize field in the ELF header is less than the size of an ELF program header\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
size	int
>	O
sizeof	O
*	O
phdrs	pointer
)	O
warn	function
(	O
_	O
(	O
"The e_phentsize field in the ELF header is larger than the size of an ELF program header\n"	pointer
)	O
)	O
;	O
phdrs	pointer
=	O
(	O
Elf64_External_Phdr	struct
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
filedata	struct
->	O
file_header	struct
.	O
e_phoff	array
,	O
size	int
,	O
num	int
,	O
_	O
(	O
"program headers"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
phdrs	pointer
)	O
return	O
FALSE	int
;	O
for	O
(	O
i	pointer
=	O
0	int
,	O
internal	pointer
=	O
pheaders	pointer
,	O
external	pointer
=	O
phdrs	pointer
;	O
i	pointer
<	O
filedata	struct
->	O
file_header	struct
.	O
e_phnum	array
;	O
i	pointer
++	O
,	O
internal	pointer
++	O
,	O
external	pointer
++	O
)	O
{	O
internal	pointer
->	O
p_type	array
=	O
BYTE_GET	O
(	O
external	pointer
->	O
p_type	array
)	O
;	O
internal	pointer
->	O
p_flags	array
=	O
BYTE_GET	O
(	O
external	pointer
->	O
p_flags	array
)	O
;	O
internal	pointer
->	O
p_offset	array
=	O
BYTE_GET	O
(	O
external	pointer
->	O
p_offset	array
)	O
;	O
internal	pointer
->	O
p_vaddr	array
=	O
BYTE_GET	O
(	O
external	pointer
->	O
p_vaddr	array
)	O
;	O
internal	pointer
->	O
p_paddr	array
=	O
BYTE_GET	O
(	O
external	pointer
->	O
p_paddr	array
)	O
;	O
internal	pointer
->	O
p_filesz	array
=	O
BYTE_GET	O
(	O
external	pointer
->	O
p_filesz	array
)	O
;	O
internal	pointer
->	O
p_memsz	array
=	O
BYTE_GET	O
(	O
external	pointer
->	O
p_memsz	array
)	O
;	O
internal	pointer
->	O
p_align	array
=	O
BYTE_GET	O
(	O
external	pointer
->	O
p_align	array
)	O
;	O
}	O
free	function
(	O
phdrs	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
get_program_headers	function
(	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
Elf_Internal_Phdr	struct
*	O
phdrs	pointer
;	O
if	O
(	O
filedata	struct
->	O
program_headers	pointer
!=	O
NULL	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_phnum	array
*	O
(	O
is_32bit_elf	int
?	O
sizeof	O
(	O
Elf32_External_Phdr	struct
)	O
:	O
sizeof	O
(	O
Elf64_External_Phdr	struct
)	O
)	O
>=	O
filedata	struct
->	O
file_size	long
)	O
{	O
error	function
(	O
_	O
(	O
"Too many program headers - %#x - the file is not that big\n"	pointer
)	O
,	O
filedata	struct
->	O
file_header	struct
.	O
e_phnum	array
)	O
;	O
return	O
FALSE	int
;	O
}	O
phdrs	pointer
=	O
(	O
Elf_Internal_Phdr	struct
*	O
)	O
cmalloc	function
(	O
filedata	struct
->	O
file_header	struct
.	O
e_phnum	array
,	O
sizeof	O
(	O
Elf_Internal_Phdr	struct
)	O
)	O
;	O
if	O
(	O
phdrs	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Out of memory reading %u program headers\n"	pointer
)	O
,	O
filedata	struct
->	O
file_header	struct
.	O
e_phnum	array
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
is_32bit_elf	int
?	O
get_32bit_program_headers	function
(	O
filedata	struct
,	O
phdrs	pointer
)	O
:	O
get_64bit_program_headers	function
(	O
filedata	struct
,	O
phdrs	pointer
)	O
)	O
{	O
filedata	struct
->	O
program_headers	pointer
=	O
phdrs	pointer
;	O
return	O
TRUE	int
;	O
}	O
free	function
(	O
phdrs	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
static	O
bfd_boolean	int
process_program_headers	function
(	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
Elf_Internal_Phdr	struct
*	O
segment	pointer
;	O
unsigned	O
int	O
i	pointer
;	O
Elf_Internal_Phdr	struct
*	O
previous_load	pointer
=	O
NULL	O
;	O
dynamic_addr	long
=	O
0	int
;	O
dynamic_size	long
=	O
0	int
;	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_phnum	array
==	O
0	int
)	O
{	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_phoff	array
!=	O
0	int
)	O
{	O
warn	function
(	O
_	O
(	O
"possibly corrupt ELF header - it has a non-zero program"	pointer
" header offset, but no program headers\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
else	O
if	O
(	O
do_segments	int
)	O
printf	function
(	O
_	O
(	O
"\nThere are no program headers in this file.\n"	pointer
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
do_segments	int
&&	O
!	O
do_header	int
)	O
{	O
printf	function
(	O
_	O
(	O
"\nElf file type is %s\n"	pointer
)	O
,	O
get_file_type	function
(	O
filedata	struct
->	O
file_header	struct
.	O
e_type	array
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"Entry point 0x%s\n"	pointer
)	O
,	O
bfd_vmatoa	function
(	O
"x"	pointer
,	O
filedata	struct
->	O
file_header	struct
.	O
e_entry	array
)	O
)	O
;	O
printf	function
(	O
ngettext	function
(	O
"There is %d program header, starting at offset %s\n"	pointer
,	O
"There are %d program headers, starting at offset %s\n"	pointer
,	O
filedata	struct
->	O
file_header	struct
.	O
e_phnum	array
)	O
,	O
filedata	struct
->	O
file_header	struct
.	O
e_phnum	array
,	O
bfd_vmatoa	function
(	O
"u"	pointer
,	O
filedata	struct
->	O
file_header	struct
.	O
e_phoff	array
)	O
)	O
;	O
}	O
if	O
(	O
!	O
get_program_headers	function
(	O
filedata	struct
)	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
do_segments	int
)	O
{	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_phnum	array
>	O
1	int
)	O
printf	function
(	O
_	O
(	O
"\nProgram Headers:\n"	pointer
)	O
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"\nProgram Headers:\n"	pointer
)	O
)	O
;	O
if	O
(	O
is_32bit_elf	int
)	O
printf	function
(	O
_	O
(	O
"  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align\n"	pointer
)	O
)	O
;	O
else	O
if	O
(	O
do_wide	int
)	O
printf	function
(	O
_	O
(	O
"  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align\n"	pointer
)	O
)	O
;	O
else	O
{	O
printf	function
(	O
_	O
(	O
"  Type           Offset             VirtAddr           PhysAddr\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"                 FileSiz            MemSiz              Flags  Align\n"	pointer
)	O
)	O
;	O
}	O
}	O
for	O
(	O
i	pointer
=	O
0	int
,	O
segment	pointer
=	O
filedata	struct
->	O
program_headers	pointer
;	O
i	pointer
<	O
filedata	struct
->	O
file_header	struct
.	O
e_phnum	array
;	O
i	pointer
++	O
,	O
segment	pointer
++	O
)	O
{	O
if	O
(	O
do_segments	int
)	O
{	O
printf	function
(	O
"  %-14.14s "	pointer
,	O
get_segment_type	function
(	O
filedata	struct
,	O
segment	pointer
->	O
p_type	array
)	O
)	O
;	O
if	O
(	O
is_32bit_elf	int
)	O
{	O
printf	function
(	O
"0x%6.6lx "	pointer
,	O
(	O
unsigned	O
long	O
)	O
segment	pointer
->	O
p_offset	array
)	O
;	O
printf	function
(	O
"0x%8.8lx "	pointer
,	O
(	O
unsigned	O
long	O
)	O
segment	pointer
->	O
p_vaddr	array
)	O
;	O
printf	function
(	O
"0x%8.8lx "	pointer
,	O
(	O
unsigned	O
long	O
)	O
segment	pointer
->	O
p_paddr	array
)	O
;	O
printf	function
(	O
"0x%5.5lx "	pointer
,	O
(	O
unsigned	O
long	O
)	O
segment	pointer
->	O
p_filesz	array
)	O
;	O
printf	function
(	O
"0x%5.5lx "	pointer
,	O
(	O
unsigned	O
long	O
)	O
segment	pointer
->	O
p_memsz	array
)	O
;	O
printf	function
(	O
"%c%c%c "	pointer
,	O
(	O
segment	pointer
->	O
p_flags	array
&	O
PF_R	O
?	O
'R'	O
:	O
' '	O
)	O
,	O
(	O
segment	pointer
->	O
p_flags	array
&	O
PF_W	O
?	O
'W'	O
:	O
' '	O
)	O
,	O
(	O
segment	pointer
->	O
p_flags	array
&	O
PF_X	O
?	O
'E'	O
:	O
' '	O
)	O
)	O
;	O
printf	function
(	O
"%#lx"	pointer
,	O
(	O
unsigned	O
long	O
)	O
segment	pointer
->	O
p_align	array
)	O
;	O
}	O
else	O
if	O
(	O
do_wide	int
)	O
{	O
if	O
(	O
(	O
unsigned	O
long	O
)	O
segment	pointer
->	O
p_offset	array
==	O
segment	pointer
->	O
p_offset	array
)	O
printf	function
(	O
"0x%6.6lx "	pointer
,	O
(	O
unsigned	O
long	O
)	O
segment	pointer
->	O
p_offset	array
)	O
;	O
else	O
{	O
print_vma	function
(	O
segment	pointer
->	O
p_offset	array
,	O
FULL_HEX	int
)	O
;	O
putchar	function
(	O
' '	O
)	O
;	O
}	O
print_vma	function
(	O
segment	pointer
->	O
p_vaddr	array
,	O
FULL_HEX	int
)	O
;	O
putchar	function
(	O
' '	O
)	O
;	O
print_vma	function
(	O
segment	pointer
->	O
p_paddr	array
,	O
FULL_HEX	int
)	O
;	O
putchar	function
(	O
' '	O
)	O
;	O
if	O
(	O
(	O
unsigned	O
long	O
)	O
segment	pointer
->	O
p_filesz	array
==	O
segment	pointer
->	O
p_filesz	array
)	O
printf	function
(	O
"0x%6.6lx "	pointer
,	O
(	O
unsigned	O
long	O
)	O
segment	pointer
->	O
p_filesz	array
)	O
;	O
else	O
{	O
print_vma	function
(	O
segment	pointer
->	O
p_filesz	array
,	O
FULL_HEX	int
)	O
;	O
putchar	function
(	O
' '	O
)	O
;	O
}	O
if	O
(	O
(	O
unsigned	O
long	O
)	O
segment	pointer
->	O
p_memsz	array
==	O
segment	pointer
->	O
p_memsz	array
)	O
printf	function
(	O
"0x%6.6lx"	pointer
,	O
(	O
unsigned	O
long	O
)	O
segment	pointer
->	O
p_memsz	array
)	O
;	O
else	O
{	O
print_vma	function
(	O
segment	pointer
->	O
p_memsz	array
,	O
FULL_HEX	int
)	O
;	O
}	O
printf	function
(	O
" %c%c%c "	pointer
,	O
(	O
segment	pointer
->	O
p_flags	array
&	O
PF_R	O
?	O
'R'	O
:	O
' '	O
)	O
,	O
(	O
segment	pointer
->	O
p_flags	array
&	O
PF_W	O
?	O
'W'	O
:	O
' '	O
)	O
,	O
(	O
segment	pointer
->	O
p_flags	array
&	O
PF_X	O
?	O
'E'	O
:	O
' '	O
)	O
)	O
;	O
if	O
(	O
(	O
unsigned	O
long	O
)	O
segment	pointer
->	O
p_align	array
==	O
segment	pointer
->	O
p_align	array
)	O
printf	function
(	O
"%#lx"	pointer
,	O
(	O
unsigned	O
long	O
)	O
segment	pointer
->	O
p_align	array
)	O
;	O
else	O
{	O
print_vma	function
(	O
segment	pointer
->	O
p_align	array
,	O
PREFIX_HEX	int
)	O
;	O
}	O
}	O
else	O
{	O
print_vma	function
(	O
segment	pointer
->	O
p_offset	array
,	O
FULL_HEX	int
)	O
;	O
putchar	function
(	O
' '	O
)	O
;	O
print_vma	function
(	O
segment	pointer
->	O
p_vaddr	array
,	O
FULL_HEX	int
)	O
;	O
putchar	function
(	O
' '	O
)	O
;	O
print_vma	function
(	O
segment	pointer
->	O
p_paddr	array
,	O
FULL_HEX	int
)	O
;	O
printf	function
(	O
"\n                 "	pointer
)	O
;	O
print_vma	function
(	O
segment	pointer
->	O
p_filesz	array
,	O
FULL_HEX	int
)	O
;	O
putchar	function
(	O
' '	O
)	O
;	O
print_vma	function
(	O
segment	pointer
->	O
p_memsz	array
,	O
FULL_HEX	int
)	O
;	O
printf	function
(	O
"  %c%c%c    "	pointer
,	O
(	O
segment	pointer
->	O
p_flags	array
&	O
PF_R	O
?	O
'R'	O
:	O
' '	O
)	O
,	O
(	O
segment	pointer
->	O
p_flags	array
&	O
PF_W	O
?	O
'W'	O
:	O
' '	O
)	O
,	O
(	O
segment	pointer
->	O
p_flags	array
&	O
PF_X	O
?	O
'E'	O
:	O
' '	O
)	O
)	O
;	O
print_vma	function
(	O
segment	pointer
->	O
p_align	array
,	O
PREFIX_HEX	int
)	O
;	O
}	O
putc	function
(	O
'\n'	O
,	O
stdout	pointer
)	O
;	O
}	O
switch	O
(	O
segment	pointer
->	O
p_type	array
)	O
{	O
case	O
PT_LOAD	int
:	O
if	O
(	O
segment	pointer
->	O
p_memsz	array
<	O
segment	pointer
->	O
p_filesz	array
)	O
error	function
(	O
_	O
(	O
"the segment's file size is larger than its memory size\n"	pointer
)	O
)	O
;	O
previous_load	pointer
=	O
segment	pointer
;	O
break	O
;	O
case	O
PT_PHDR	int
:	O
if	O
(	O
i	pointer
>	O
0	int
&&	O
previous_load	pointer
!=	O
NULL	O
)	O
error	function
(	O
_	O
(	O
"the PHDR segment must occur before any LOAD segment\n"	pointer
)	O
)	O
;	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
!=	O
EM_PARISC	int
)	O
{	O
unsigned	O
int	O
j	int
;	O
for	O
(	O
j	int
=	O
1	int
;	O
j	int
<	O
filedata	struct
->	O
file_header	struct
.	O
e_phnum	array
;	O
j	int
++	O
)	O
{	O
Elf_Internal_Phdr	struct
*	O
load	pointer
=	O
filedata	struct
->	O
program_headers	pointer
+	O
j	int
;	O
if	O
(	O
load	pointer
->	O
p_type	array
==	O
PT_LOAD	int
&&	O
load	pointer
->	O
p_offset	array
<=	O
segment	pointer
->	O
p_offset	array
&&	O
(	O
load	pointer
->	O
p_offset	array
+	O
load	pointer
->	O
p_filesz	array
>=	O
segment	pointer
->	O
p_offset	array
+	O
segment	pointer
->	O
p_filesz	array
)	O
&&	O
load	pointer
->	O
p_vaddr	array
<=	O
segment	pointer
->	O
p_vaddr	array
&&	O
(	O
load	pointer
->	O
p_vaddr	array
+	O
load	pointer
->	O
p_filesz	array
>=	O
segment	pointer
->	O
p_vaddr	array
+	O
segment	pointer
->	O
p_filesz	array
)	O
)	O
break	O
;	O
}	O
if	O
(	O
j	int
==	O
filedata	struct
->	O
file_header	struct
.	O
e_phnum	array
)	O
error	function
(	O
_	O
(	O
"the PHDR segment is not covered by a LOAD segment\n"	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
PT_DYNAMIC	int
:	O
if	O
(	O
dynamic_addr	long
)	O
error	function
(	O
_	O
(	O
"more than one dynamic segment\n"	pointer
)	O
)	O
;	O
dynamic_addr	long
=	O
segment	pointer
->	O
p_offset	array
;	O
dynamic_size	long
=	O
segment	pointer
->	O
p_filesz	array
;	O
if	O
(	O
filedata	struct
->	O
section_headers	pointer
!=	O
NULL	O
)	O
{	O
Elf_Internal_Shdr	struct
*	O
sec	pointer
;	O
sec	pointer
=	O
find_section	function
(	O
filedata	struct
,	O
".dynamic"	pointer
)	O
;	O
if	O
(	O
sec	pointer
==	O
NULL	O
||	O
sec	pointer
->	O
sh_size	array
==	O
0	int
)	O
{	O
if	O
(	O
!	O
is_ia64_vms	function
(	O
filedata	struct
)	O
)	O
error	function
(	O
_	O
(	O
"no .dynamic section in the dynamic segment\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
sec	pointer
->	O
sh_type	array
==	O
SHT_NOBITS	int
)	O
{	O
dynamic_size	long
=	O
0	int
;	O
break	O
;	O
}	O
dynamic_addr	long
=	O
sec	pointer
->	O
sh_offset	array
;	O
dynamic_size	long
=	O
sec	pointer
->	O
sh_size	array
;	O
if	O
(	O
dynamic_addr	long
<	O
segment	pointer
->	O
p_offset	array
||	O
dynamic_addr	long
>	O
segment	pointer
->	O
p_offset	array
+	O
segment	pointer
->	O
p_filesz	array
)	O
warn	function
(	O
_	O
(	O
"the .dynamic section is not contained"	pointer
" within the dynamic segment\n"	pointer
)	O
)	O
;	O
else	O
if	O
(	O
dynamic_addr	long
>	O
segment	pointer
->	O
p_offset	array
)	O
warn	function
(	O
_	O
(	O
"the .dynamic section is not the first section"	pointer
" in the dynamic segment.\n"	pointer
)	O
)	O
;	O
}	O
if	O
(	O
dynamic_addr	long
>	O
filedata	struct
->	O
file_size	long
||	O
dynamic_size	long
>	O
filedata	struct
->	O
file_size	long
-	O
dynamic_addr	long
)	O
{	O
error	function
(	O
_	O
(	O
"the dynamic segment offset + size exceeds the size of the file\n"	pointer
)	O
)	O
;	O
dynamic_addr	long
=	O
dynamic_size	long
=	O
0	int
;	O
}	O
break	O
;	O
case	O
PT_INTERP	int
:	O
if	O
(	O
fseek	function
(	O
filedata	struct
->	O
handle	pointer
,	O
archive_file_offset	long
+	O
(	O
long	O
)	O
segment	pointer
->	O
p_offset	array
,	O
SEEK_SET	int
)	O
)	O
error	function
(	O
_	O
(	O
"Unable to find program interpreter name\n"	pointer
)	O
)	O
;	O
else	O
{	O
char	O
fmt	pointer
[	O
32	int
]	O
;	O
int	O
ret	pointer
=	O
snprintf	function
(	O
fmt	pointer
,	O
sizeof	O
(	O
fmt	pointer
)	O
,	O
"%%%ds"	pointer
,	O
PATH_MAX	int
-	O
1	int
)	O
;	O
if	O
(	O
ret	pointer
>=	O
(	O
int	O
)	O
sizeof	O
(	O
fmt	pointer
)	O
||	O
ret	pointer
<	O
0	int
)	O
error	function
(	O
_	O
(	O
"Internal error: failed to create format string to display program interpreter\n"	pointer
)	O
)	O
;	O
program_interpreter	array
[	O
0	int
]	O
=	O
0	int
;	O
if	O
(	O
fscanf	function
(	O
filedata	struct
->	O
handle	pointer
,	O
fmt	pointer
,	O
program_interpreter	array
)	O
<=	O
0	int
)	O
error	function
(	O
_	O
(	O
"Unable to read program interpreter name\n"	pointer
)	O
)	O
;	O
if	O
(	O
do_segments	int
)	O
printf	function
(	O
_	O
(	O
"      [Requesting program interpreter: %s]\n"	pointer
)	O
,	O
program_interpreter	array
)	O
;	O
}	O
break	O
;	O
}	O
}	O
if	O
(	O
do_segments	int
&&	O
filedata	struct
->	O
section_headers	pointer
!=	O
NULL	O
&&	O
filedata	struct
->	O
string_table	pointer
!=	O
NULL	O
)	O
{	O
printf	function
(	O
_	O
(	O
"\n Section to Segment mapping:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  Segment Sections...\n"	pointer
)	O
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
filedata	struct
->	O
file_header	struct
.	O
e_phnum	array
;	O
i	pointer
++	O
)	O
{	O
unsigned	O
int	O
j	int
;	O
Elf_Internal_Shdr	struct
*	O
section	pointer
;	O
segment	pointer
=	O
filedata	struct
->	O
program_headers	pointer
+	O
i	pointer
;	O
section	pointer
=	O
filedata	struct
->	O
section_headers	pointer
+	O
1	int
;	O
printf	function
(	O
"   %2.2d     "	pointer
,	O
i	pointer
)	O
;	O
for	O
(	O
j	int
=	O
1	int
;	O
j	int
<	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
;	O
j	int
++	O
,	O
section	pointer
++	O
)	O
{	O
if	O
(	O
!	O
ELF_TBSS_SPECIAL	O
(	O
section	pointer
,	O
segment	pointer
)	O
&&	O
ELF_SECTION_IN_SEGMENT_STRICT	O
(	O
section	pointer
,	O
segment	pointer
)	O
)	O
printf	function
(	O
"%s "	pointer
,	O
printable_section_name	function
(	O
filedata	struct
,	O
section	pointer
)	O
)	O
;	O
}	O
putc	function
(	O
'\n'	O
,	O
stdout	pointer
)	O
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
long	O
offset_from_vma	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
bfd_vma	long
vma	long
,	O
bfd_size_type	long
size	int
)	O
{	O
Elf_Internal_Phdr	struct
*	O
seg	pointer
;	O
if	O
(	O
!	O
get_program_headers	function
(	O
filedata	struct
)	O
)	O
{	O
warn	function
(	O
_	O
(	O
"Cannot interpret virtual addresses without program headers.\n"	pointer
)	O
)	O
;	O
return	O
(	O
long	O
)	O
vma	long
;	O
}	O
for	O
(	O
seg	pointer
=	O
filedata	struct
->	O
program_headers	pointer
;	O
seg	pointer
<	O
filedata	struct
->	O
program_headers	pointer
+	O
filedata	struct
->	O
file_header	struct
.	O
e_phnum	array
;	O
++	O
seg	pointer
)	O
{	O
if	O
(	O
seg	pointer
->	O
p_type	array
!=	O
PT_LOAD	int
)	O
continue	O
;	O
if	O
(	O
vma	long
>=	O
(	O
seg	pointer
->	O
p_vaddr	array
&	O
-	O
seg	pointer
->	O
p_align	array
)	O
&&	O
vma	long
+	O
size	int
<=	O
seg	pointer
->	O
p_vaddr	array
+	O
seg	pointer
->	O
p_filesz	array
)	O
return	O
vma	long
-	O
seg	pointer
->	O
p_vaddr	array
+	O
seg	pointer
->	O
p_offset	array
;	O
}	O
warn	function
(	O
_	O
(	O
"Virtual address 0x%lx not located in any PT_LOAD segment.\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
vma	long
)	O
;	O
return	O
(	O
long	O
)	O
vma	long
;	O
}	O
static	O
bfd_boolean	int
get_32bit_section_headers	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
bfd_boolean	int
probe	int
)	O
{	O
Elf32_External_Shdr	struct
*	O
shdrs	pointer
;	O
Elf_Internal_Shdr	struct
*	O
internal	pointer
;	O
unsigned	O
int	O
i	pointer
;	O
unsigned	O
int	O
size	int
=	O
filedata	struct
->	O
file_header	struct
.	O
e_shentsize	array
;	O
unsigned	O
int	O
num	int
=	O
probe	int
?	O
1	int
:	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
;	O
if	O
(	O
size	int
==	O
0	int
||	O
num	int
==	O
0	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
size	int
<	O
sizeof	O
*	O
shdrs	pointer
)	O
{	O
if	O
(	O
!	O
probe	int
)	O
error	function
(	O
_	O
(	O
"The e_shentsize field in the ELF header is less than the size of an ELF section header\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
!	O
probe	int
&&	O
size	int
>	O
sizeof	O
*	O
shdrs	pointer
)	O
warn	function
(	O
_	O
(	O
"The e_shentsize field in the ELF header is larger than the size of an ELF section header\n"	pointer
)	O
)	O
;	O
shdrs	pointer
=	O
(	O
Elf32_External_Shdr	struct
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
filedata	struct
->	O
file_header	struct
.	O
e_shoff	array
,	O
size	int
,	O
num	int
,	O
probe	int
?	O
NULL	O
:	O
_	O
(	O
"section headers"	pointer
)	O
)	O
;	O
if	O
(	O
shdrs	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
free	function
(	O
filedata	struct
->	O
section_headers	pointer
)	O
;	O
filedata	struct
->	O
section_headers	pointer
=	O
(	O
Elf_Internal_Shdr	struct
*	O
)	O
cmalloc	function
(	O
num	int
,	O
sizeof	O
(	O
Elf_Internal_Shdr	struct
)	O
)	O
;	O
if	O
(	O
filedata	struct
->	O
section_headers	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
!	O
probe	int
)	O
error	function
(	O
_	O
(	O
"Out of memory reading %u section headers\n"	pointer
)	O
,	O
num	int
)	O
;	O
free	function
(	O
shdrs	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
for	O
(	O
i	pointer
=	O
0	int
,	O
internal	pointer
=	O
filedata	struct
->	O
section_headers	pointer
;	O
i	pointer
<	O
num	int
;	O
i	pointer
++	O
,	O
internal	pointer
++	O
)	O
{	O
internal	pointer
->	O
sh_name	array
=	O
BYTE_GET	O
(	O
shdrs	pointer
[	O
i	pointer
]	O
.	O
sh_name	array
)	O
;	O
internal	pointer
->	O
sh_type	array
=	O
BYTE_GET	O
(	O
shdrs	pointer
[	O
i	pointer
]	O
.	O
sh_type	array
)	O
;	O
internal	pointer
->	O
sh_flags	array
=	O
BYTE_GET	O
(	O
shdrs	pointer
[	O
i	pointer
]	O
.	O
sh_flags	array
)	O
;	O
internal	pointer
->	O
sh_addr	array
=	O
BYTE_GET	O
(	O
shdrs	pointer
[	O
i	pointer
]	O
.	O
sh_addr	array
)	O
;	O
internal	pointer
->	O
sh_offset	array
=	O
BYTE_GET	O
(	O
shdrs	pointer
[	O
i	pointer
]	O
.	O
sh_offset	array
)	O
;	O
internal	pointer
->	O
sh_size	array
=	O
BYTE_GET	O
(	O
shdrs	pointer
[	O
i	pointer
]	O
.	O
sh_size	array
)	O
;	O
internal	pointer
->	O
sh_link	array
=	O
BYTE_GET	O
(	O
shdrs	pointer
[	O
i	pointer
]	O
.	O
sh_link	array
)	O
;	O
internal	pointer
->	O
sh_info	array
=	O
BYTE_GET	O
(	O
shdrs	pointer
[	O
i	pointer
]	O
.	O
sh_info	array
)	O
;	O
internal	pointer
->	O
sh_addralign	array
=	O
BYTE_GET	O
(	O
shdrs	pointer
[	O
i	pointer
]	O
.	O
sh_addralign	array
)	O
;	O
internal	pointer
->	O
sh_entsize	array
=	O
BYTE_GET	O
(	O
shdrs	pointer
[	O
i	pointer
]	O
.	O
sh_entsize	array
)	O
;	O
if	O
(	O
!	O
probe	int
&&	O
internal	pointer
->	O
sh_link	array
>	O
num	int
)	O
warn	function
(	O
_	O
(	O
"Section %u has an out of range sh_link value of %u\n"	pointer
)	O
,	O
i	pointer
,	O
internal	pointer
->	O
sh_link	array
)	O
;	O
if	O
(	O
!	O
probe	int
&&	O
internal	pointer
->	O
sh_flags	array
&	O
SHF_INFO_LINK	O
&&	O
internal	pointer
->	O
sh_info	array
>	O
num	int
)	O
warn	function
(	O
_	O
(	O
"Section %u has an out of range sh_info value of %u\n"	pointer
)	O
,	O
i	pointer
,	O
internal	pointer
->	O
sh_info	array
)	O
;	O
}	O
free	function
(	O
shdrs	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
get_64bit_section_headers	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
bfd_boolean	int
probe	int
)	O
{	O
Elf64_External_Shdr	struct
*	O
shdrs	pointer
;	O
Elf_Internal_Shdr	struct
*	O
internal	pointer
;	O
unsigned	O
int	O
i	pointer
;	O
unsigned	O
int	O
size	int
=	O
filedata	struct
->	O
file_header	struct
.	O
e_shentsize	array
;	O
unsigned	O
int	O
num	int
=	O
probe	int
?	O
1	int
:	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
;	O
if	O
(	O
size	int
==	O
0	int
||	O
num	int
==	O
0	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
size	int
<	O
sizeof	O
*	O
shdrs	pointer
)	O
{	O
if	O
(	O
!	O
probe	int
)	O
error	function
(	O
_	O
(	O
"The e_shentsize field in the ELF header is less than the size of an ELF section header\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
!	O
probe	int
&&	O
size	int
>	O
sizeof	O
*	O
shdrs	pointer
)	O
warn	function
(	O
_	O
(	O
"The e_shentsize field in the ELF header is larger than the size of an ELF section header\n"	pointer
)	O
)	O
;	O
shdrs	pointer
=	O
(	O
Elf64_External_Shdr	struct
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
filedata	struct
->	O
file_header	struct
.	O
e_shoff	array
,	O
size	int
,	O
num	int
,	O
probe	int
?	O
NULL	O
:	O
_	O
(	O
"section headers"	pointer
)	O
)	O
;	O
if	O
(	O
shdrs	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
free	function
(	O
filedata	struct
->	O
section_headers	pointer
)	O
;	O
filedata	struct
->	O
section_headers	pointer
=	O
(	O
Elf_Internal_Shdr	struct
*	O
)	O
cmalloc	function
(	O
num	int
,	O
sizeof	O
(	O
Elf_Internal_Shdr	struct
)	O
)	O
;	O
if	O
(	O
filedata	struct
->	O
section_headers	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
!	O
probe	int
)	O
error	function
(	O
_	O
(	O
"Out of memory reading %u section headers\n"	pointer
)	O
,	O
num	int
)	O
;	O
free	function
(	O
shdrs	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
for	O
(	O
i	pointer
=	O
0	int
,	O
internal	pointer
=	O
filedata	struct
->	O
section_headers	pointer
;	O
i	pointer
<	O
num	int
;	O
i	pointer
++	O
,	O
internal	pointer
++	O
)	O
{	O
internal	pointer
->	O
sh_name	array
=	O
BYTE_GET	O
(	O
shdrs	pointer
[	O
i	pointer
]	O
.	O
sh_name	array
)	O
;	O
internal	pointer
->	O
sh_type	array
=	O
BYTE_GET	O
(	O
shdrs	pointer
[	O
i	pointer
]	O
.	O
sh_type	array
)	O
;	O
internal	pointer
->	O
sh_flags	array
=	O
BYTE_GET	O
(	O
shdrs	pointer
[	O
i	pointer
]	O
.	O
sh_flags	array
)	O
;	O
internal	pointer
->	O
sh_addr	array
=	O
BYTE_GET	O
(	O
shdrs	pointer
[	O
i	pointer
]	O
.	O
sh_addr	array
)	O
;	O
internal	pointer
->	O
sh_size	array
=	O
BYTE_GET	O
(	O
shdrs	pointer
[	O
i	pointer
]	O
.	O
sh_size	array
)	O
;	O
internal	pointer
->	O
sh_entsize	array
=	O
BYTE_GET	O
(	O
shdrs	pointer
[	O
i	pointer
]	O
.	O
sh_entsize	array
)	O
;	O
internal	pointer
->	O
sh_link	array
=	O
BYTE_GET	O
(	O
shdrs	pointer
[	O
i	pointer
]	O
.	O
sh_link	array
)	O
;	O
internal	pointer
->	O
sh_info	array
=	O
BYTE_GET	O
(	O
shdrs	pointer
[	O
i	pointer
]	O
.	O
sh_info	array
)	O
;	O
internal	pointer
->	O
sh_offset	array
=	O
BYTE_GET	O
(	O
shdrs	pointer
[	O
i	pointer
]	O
.	O
sh_offset	array
)	O
;	O
internal	pointer
->	O
sh_addralign	array
=	O
BYTE_GET	O
(	O
shdrs	pointer
[	O
i	pointer
]	O
.	O
sh_addralign	array
)	O
;	O
if	O
(	O
!	O
probe	int
&&	O
internal	pointer
->	O
sh_link	array
>	O
num	int
)	O
warn	function
(	O
_	O
(	O
"Section %u has an out of range sh_link value of %u\n"	pointer
)	O
,	O
i	pointer
,	O
internal	pointer
->	O
sh_link	array
)	O
;	O
if	O
(	O
!	O
probe	int
&&	O
internal	pointer
->	O
sh_flags	array
&	O
SHF_INFO_LINK	O
&&	O
internal	pointer
->	O
sh_info	array
>	O
num	int
)	O
warn	function
(	O
_	O
(	O
"Section %u has an out of range sh_info value of %u\n"	pointer
)	O
,	O
i	pointer
,	O
internal	pointer
->	O
sh_info	array
)	O
;	O
}	O
free	function
(	O
shdrs	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
Elf_Internal_Sym	struct
*	O
get_32bit_elf_symbols	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
Elf_Internal_Shdr	struct
*	O
section	pointer
,	O
unsigned	O
long	O
*	O
num_syms_return	pointer
)	O
{	O
unsigned	O
long	O
number	long
=	O
0	int
;	O
Elf32_External_Sym	struct
*	O
esyms	pointer
=	O
NULL	O
;	O
Elf_External_Sym_Shndx	struct
*	O
shndx	pointer
=	O
NULL	O
;	O
Elf_Internal_Sym	struct
*	O
isyms	pointer
=	O
NULL	O
;	O
Elf_Internal_Sym	struct
*	O
psym	pointer
;	O
unsigned	O
int	O
j	int
;	O
elf_section_list	struct
*	O
entry	int
;	O
if	O
(	O
section	pointer
->	O
sh_size	array
==	O
0	int
)	O
{	O
if	O
(	O
num_syms_return	pointer
!=	O
NULL	O
)	O
*	O
num_syms_return	pointer
=	O
0	int
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
section	pointer
->	O
sh_entsize	array
==	O
0	int
||	O
section	pointer
->	O
sh_entsize	array
>	O
section	pointer
->	O
sh_size	array
)	O
{	O
error	function
(	O
_	O
(	O
"Section %s has an invalid sh_entsize of 0x%lx\n"	pointer
)	O
,	O
printable_section_name	function
(	O
filedata	struct
,	O
section	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
section	pointer
->	O
sh_entsize	array
)	O
;	O
goto	O
exit_point	O
;	O
}	O
if	O
(	O
section	pointer
->	O
sh_size	array
>	O
filedata	struct
->	O
file_size	long
)	O
{	O
error	function
(	O
_	O
(	O
"Section %s has an invalid sh_size of 0x%lx\n"	pointer
)	O
,	O
printable_section_name	function
(	O
filedata	struct
,	O
section	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
section	pointer
->	O
sh_size	array
)	O
;	O
goto	O
exit_point	O
;	O
}	O
number	long
=	O
section	pointer
->	O
sh_size	array
/	O
section	pointer
->	O
sh_entsize	array
;	O
if	O
(	O
number	long
*	O
sizeof	O
(	O
Elf32_External_Sym	struct
)	O
>	O
section	pointer
->	O
sh_size	array
+	O
1	int
)	O
{	O
error	function
(	O
_	O
(	O
"Size (0x%lx) of section %s is not a multiple of its sh_entsize (0x%lx)\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
section	pointer
->	O
sh_size	array
,	O
printable_section_name	function
(	O
filedata	struct
,	O
section	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
section	pointer
->	O
sh_entsize	array
)	O
;	O
goto	O
exit_point	O
;	O
}	O
esyms	pointer
=	O
(	O
Elf32_External_Sym	struct
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
section	pointer
->	O
sh_offset	array
,	O
1	int
,	O
section	pointer
->	O
sh_size	array
,	O
_	O
(	O
"symbols"	pointer
)	O
)	O
;	O
if	O
(	O
esyms	pointer
==	O
NULL	O
)	O
goto	O
exit_point	O
;	O
shndx	pointer
=	O
NULL	O
;	O
for	O
(	O
entry	int
=	O
symtab_shndx_list	pointer
;	O
entry	int
!=	O
NULL	O
;	O
entry	int
=	O
entry	int
->	O
next	pointer
)	O
{	O
if	O
(	O
entry	int
->	O
hdr	pointer
->	O
sh_link	array
!=	O
(	O
unsigned	O
long	O
)	O
(	O
section	pointer
-	O
filedata	struct
->	O
section_headers	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
shndx	pointer
!=	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Multiple symbol table index sections associated with the same symbol section\n"	pointer
)	O
)	O
;	O
free	function
(	O
shndx	pointer
)	O
;	O
}	O
shndx	pointer
=	O
(	O
Elf_External_Sym_Shndx	struct
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
entry	int
->	O
hdr	pointer
->	O
sh_offset	array
,	O
1	int
,	O
entry	int
->	O
hdr	pointer
->	O
sh_size	array
,	O
_	O
(	O
"symbol table section indices"	pointer
)	O
)	O
;	O
if	O
(	O
shndx	pointer
==	O
NULL	O
)	O
goto	O
exit_point	O
;	O
if	O
(	O
entry	int
->	O
hdr	pointer
->	O
sh_size	array
/	O
sizeof	O
(	O
Elf_External_Sym_Shndx	struct
)	O
<	O
number	long
)	O
{	O
error	function
(	O
_	O
(	O
"Index section %s has an sh_size of 0x%lx - expected 0x%lx\n"	pointer
)	O
,	O
printable_section_name	function
(	O
filedata	struct
,	O
entry	int
->	O
hdr	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
entry	int
->	O
hdr	pointer
->	O
sh_size	array
,	O
(	O
unsigned	O
long	O
)	O
section	pointer
->	O
sh_size	array
)	O
;	O
goto	O
exit_point	O
;	O
}	O
}	O
isyms	pointer
=	O
(	O
Elf_Internal_Sym	struct
*	O
)	O
cmalloc	function
(	O
number	long
,	O
sizeof	O
(	O
Elf_Internal_Sym	struct
)	O
)	O
;	O
if	O
(	O
isyms	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Out of memory reading %lu symbols\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
number	long
)	O
;	O
goto	O
exit_point	O
;	O
}	O
for	O
(	O
j	int
=	O
0	int
,	O
psym	pointer
=	O
isyms	pointer
;	O
j	int
<	O
number	long
;	O
j	int
++	O
,	O
psym	pointer
++	O
)	O
{	O
psym	pointer
->	O
st_name	pointer
=	O
BYTE_GET	O
(	O
esyms	pointer
[	O
j	int
]	O
.	O
st_name	pointer
)	O
;	O
psym	pointer
->	O
st_value	int
=	O
BYTE_GET	O
(	O
esyms	pointer
[	O
j	int
]	O
.	O
st_value	int
)	O
;	O
psym	pointer
->	O
st_size	long
=	O
BYTE_GET	O
(	O
esyms	pointer
[	O
j	int
]	O
.	O
st_size	long
)	O
;	O
psym	pointer
->	O
st_shndx	int
=	O
BYTE_GET	O
(	O
esyms	pointer
[	O
j	int
]	O
.	O
st_shndx	int
)	O
;	O
if	O
(	O
psym	pointer
->	O
st_shndx	int
==	O
(	O
SHN_XINDEX	O
&	O
0xffff	int
)	O
&&	O
shndx	pointer
!=	O
NULL	O
)	O
psym	pointer
->	O
st_shndx	int
=	O
byte_get	pointer
(	O
(	O
unsigned	O
char	O
*	O
)	O
&	O
shndx	pointer
[	O
j	int
]	O
,	O
sizeof	O
(	O
shndx	pointer
[	O
j	int
]	O
)	O
)	O
;	O
else	O
if	O
(	O
psym	pointer
->	O
st_shndx	int
>=	O
(	O
SHN_LORESERVE	O
&	O
0xffff	int
)	O
)	O
psym	pointer
->	O
st_shndx	int
+=	O
SHN_LORESERVE	O
-	O
(	O
SHN_LORESERVE	O
&	O
0xffff	int
)	O
;	O
psym	pointer
->	O
st_info	array
=	O
BYTE_GET	O
(	O
esyms	pointer
[	O
j	int
]	O
.	O
st_info	array
)	O
;	O
psym	pointer
->	O
st_other	array
=	O
BYTE_GET	O
(	O
esyms	pointer
[	O
j	int
]	O
.	O
st_other	array
)	O
;	O
}	O
exit_point	O
:	O
free	function
(	O
shndx	pointer
)	O
;	O
free	function
(	O
esyms	pointer
)	O
;	O
if	O
(	O
num_syms_return	pointer
!=	O
NULL	O
)	O
*	O
num_syms_return	pointer
=	O
isyms	pointer
==	O
NULL	O
?	O
0	int
:	O
number	long
;	O
return	O
isyms	pointer
;	O
}	O
static	O
Elf_Internal_Sym	struct
*	O
get_64bit_elf_symbols	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
Elf_Internal_Shdr	struct
*	O
section	pointer
,	O
unsigned	O
long	O
*	O
num_syms_return	pointer
)	O
{	O
unsigned	O
long	O
number	long
=	O
0	int
;	O
Elf64_External_Sym	struct
*	O
esyms	pointer
=	O
NULL	O
;	O
Elf_External_Sym_Shndx	struct
*	O
shndx	pointer
=	O
NULL	O
;	O
Elf_Internal_Sym	struct
*	O
isyms	pointer
=	O
NULL	O
;	O
Elf_Internal_Sym	struct
*	O
psym	pointer
;	O
unsigned	O
int	O
j	int
;	O
elf_section_list	struct
*	O
entry	int
;	O
if	O
(	O
section	pointer
->	O
sh_size	array
==	O
0	int
)	O
{	O
if	O
(	O
num_syms_return	pointer
!=	O
NULL	O
)	O
*	O
num_syms_return	pointer
=	O
0	int
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
section	pointer
->	O
sh_entsize	array
==	O
0	int
||	O
section	pointer
->	O
sh_entsize	array
>	O
section	pointer
->	O
sh_size	array
)	O
{	O
error	function
(	O
_	O
(	O
"Section %s has an invalid sh_entsize of 0x%lx\n"	pointer
)	O
,	O
printable_section_name	function
(	O
filedata	struct
,	O
section	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
section	pointer
->	O
sh_entsize	array
)	O
;	O
goto	O
exit_point	O
;	O
}	O
if	O
(	O
section	pointer
->	O
sh_size	array
>	O
filedata	struct
->	O
file_size	long
)	O
{	O
error	function
(	O
_	O
(	O
"Section %s has an invalid sh_size of 0x%lx\n"	pointer
)	O
,	O
printable_section_name	function
(	O
filedata	struct
,	O
section	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
section	pointer
->	O
sh_size	array
)	O
;	O
goto	O
exit_point	O
;	O
}	O
number	long
=	O
section	pointer
->	O
sh_size	array
/	O
section	pointer
->	O
sh_entsize	array
;	O
if	O
(	O
number	long
*	O
sizeof	O
(	O
Elf64_External_Sym	struct
)	O
>	O
section	pointer
->	O
sh_size	array
+	O
1	int
)	O
{	O
error	function
(	O
_	O
(	O
"Size (0x%lx) of section %s is not a multiple of its sh_entsize (0x%lx)\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
section	pointer
->	O
sh_size	array
,	O
printable_section_name	function
(	O
filedata	struct
,	O
section	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
section	pointer
->	O
sh_entsize	array
)	O
;	O
goto	O
exit_point	O
;	O
}	O
esyms	pointer
=	O
(	O
Elf64_External_Sym	struct
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
section	pointer
->	O
sh_offset	array
,	O
1	int
,	O
section	pointer
->	O
sh_size	array
,	O
_	O
(	O
"symbols"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
esyms	pointer
)	O
goto	O
exit_point	O
;	O
shndx	pointer
=	O
NULL	O
;	O
for	O
(	O
entry	int
=	O
symtab_shndx_list	pointer
;	O
entry	int
!=	O
NULL	O
;	O
entry	int
=	O
entry	int
->	O
next	pointer
)	O
{	O
if	O
(	O
entry	int
->	O
hdr	pointer
->	O
sh_link	array
!=	O
(	O
unsigned	O
long	O
)	O
(	O
section	pointer
-	O
filedata	struct
->	O
section_headers	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
shndx	pointer
!=	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Multiple symbol table index sections associated with the same symbol section\n"	pointer
)	O
)	O
;	O
free	function
(	O
shndx	pointer
)	O
;	O
}	O
shndx	pointer
=	O
(	O
Elf_External_Sym_Shndx	struct
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
entry	int
->	O
hdr	pointer
->	O
sh_offset	array
,	O
1	int
,	O
entry	int
->	O
hdr	pointer
->	O
sh_size	array
,	O
_	O
(	O
"symbol table section indices"	pointer
)	O
)	O
;	O
if	O
(	O
shndx	pointer
==	O
NULL	O
)	O
goto	O
exit_point	O
;	O
if	O
(	O
entry	int
->	O
hdr	pointer
->	O
sh_size	array
/	O
sizeof	O
(	O
Elf_External_Sym_Shndx	struct
)	O
<	O
number	long
)	O
{	O
error	function
(	O
_	O
(	O
"Index section %s has an sh_size of 0x%lx - expected 0x%lx\n"	pointer
)	O
,	O
printable_section_name	function
(	O
filedata	struct
,	O
entry	int
->	O
hdr	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
entry	int
->	O
hdr	pointer
->	O
sh_size	array
,	O
(	O
unsigned	O
long	O
)	O
section	pointer
->	O
sh_size	array
)	O
;	O
goto	O
exit_point	O
;	O
}	O
}	O
isyms	pointer
=	O
(	O
Elf_Internal_Sym	struct
*	O
)	O
cmalloc	function
(	O
number	long
,	O
sizeof	O
(	O
Elf_Internal_Sym	struct
)	O
)	O
;	O
if	O
(	O
isyms	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Out of memory reading %lu symbols\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
number	long
)	O
;	O
goto	O
exit_point	O
;	O
}	O
for	O
(	O
j	int
=	O
0	int
,	O
psym	pointer
=	O
isyms	pointer
;	O
j	int
<	O
number	long
;	O
j	int
++	O
,	O
psym	pointer
++	O
)	O
{	O
psym	pointer
->	O
st_name	pointer
=	O
BYTE_GET	O
(	O
esyms	pointer
[	O
j	int
]	O
.	O
st_name	pointer
)	O
;	O
psym	pointer
->	O
st_info	array
=	O
BYTE_GET	O
(	O
esyms	pointer
[	O
j	int
]	O
.	O
st_info	array
)	O
;	O
psym	pointer
->	O
st_other	array
=	O
BYTE_GET	O
(	O
esyms	pointer
[	O
j	int
]	O
.	O
st_other	array
)	O
;	O
psym	pointer
->	O
st_shndx	int
=	O
BYTE_GET	O
(	O
esyms	pointer
[	O
j	int
]	O
.	O
st_shndx	int
)	O
;	O
if	O
(	O
psym	pointer
->	O
st_shndx	int
==	O
(	O
SHN_XINDEX	O
&	O
0xffff	int
)	O
&&	O
shndx	pointer
!=	O
NULL	O
)	O
psym	pointer
->	O
st_shndx	int
=	O
byte_get	pointer
(	O
(	O
unsigned	O
char	O
*	O
)	O
&	O
shndx	pointer
[	O
j	int
]	O
,	O
sizeof	O
(	O
shndx	pointer
[	O
j	int
]	O
)	O
)	O
;	O
else	O
if	O
(	O
psym	pointer
->	O
st_shndx	int
>=	O
(	O
SHN_LORESERVE	O
&	O
0xffff	int
)	O
)	O
psym	pointer
->	O
st_shndx	int
+=	O
SHN_LORESERVE	O
-	O
(	O
SHN_LORESERVE	O
&	O
0xffff	int
)	O
;	O
psym	pointer
->	O
st_value	int
=	O
BYTE_GET	O
(	O
esyms	pointer
[	O
j	int
]	O
.	O
st_value	int
)	O
;	O
psym	pointer
->	O
st_size	long
=	O
BYTE_GET	O
(	O
esyms	pointer
[	O
j	int
]	O
.	O
st_size	long
)	O
;	O
}	O
exit_point	O
:	O
free	function
(	O
shndx	pointer
)	O
;	O
free	function
(	O
esyms	pointer
)	O
;	O
if	O
(	O
num_syms_return	pointer
!=	O
NULL	O
)	O
*	O
num_syms_return	pointer
=	O
isyms	pointer
==	O
NULL	O
?	O
0	int
:	O
number	long
;	O
return	O
isyms	pointer
;	O
}	O
static	O
const	O
char	O
*	O
get_elf_section_flags	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
bfd_vma	long
sh_flags	array
)	O
{	O
static	O
char	O
buff	array
[	O
1024	int
]	O
;	O
char	O
*	O
p	pointer
=	O
buff	array
;	O
unsigned	O
int	O
field_size	int
=	O
is_32bit_elf	int
?	O
8	int
:	O
16	int
;	O
signed	O
int	O
sindex	int
;	O
unsigned	O
int	O
size	int
=	O
sizeof	O
(	O
buff	array
)	O
-	O
(	O
field_size	int
+	O
4	int
+	O
1	int
)	O
;	O
bfd_vma	long
os_flags	long
=	O
0	int
;	O
bfd_vma	long
proc_flags	long
=	O
0	int
;	O
bfd_vma	long
unknown_flags	long
=	O
0	int
;	O
static	O
const	O
struct	O
{	O
const	O
char	O
*	O
str	int
;	O
unsigned	O
int	O
len	int
;	O
}	O
flags	int
[	O
]	O
=	O
{	O
{	O
STRING_COMMA_LEN	O
(	O
"WRITE"	pointer
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"ALLOC"	pointer
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"EXEC"	pointer
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"MERGE"	pointer
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"STRINGS"	pointer
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"INFO LINK"	pointer
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"LINK ORDER"	pointer
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"OS NONCONF"	pointer
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"GROUP"	pointer
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"TLS"	pointer
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"SHORT"	pointer
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"NORECOV"	pointer
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"VMS_GLOBAL"	pointer
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"VMS_OVERLAID"	pointer
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"VMS_SHARED"	pointer
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"VMS_VECTOR"	pointer
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"VMS_ALLOC_64BIT"	pointer
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"VMS_PROTECTED"	pointer
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"EXCLUDE"	pointer
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"ORDERED"	pointer
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"COMPRESSED"	pointer
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"ENTRYSECT"	pointer
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"ARM_PURECODE"	pointer
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"COMDEF"	pointer
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"GNU_MBIND"	pointer
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"VLE"	pointer
)	O
}	O
,	O
}	O
;	O
if	O
(	O
do_section_details	int
)	O
{	O
sprintf	function
(	O
buff	array
,	O
"[%*.*lx]: "	pointer
,	O
field_size	int
,	O
field_size	int
,	O
(	O
unsigned	O
long	O
)	O
sh_flags	array
)	O
;	O
p	pointer
+=	O
field_size	int
+	O
4	int
;	O
}	O
while	O
(	O
sh_flags	array
)	O
{	O
bfd_vma	long
flag	int
;	O
flag	int
=	O
sh_flags	array
&	O
-	O
sh_flags	array
;	O
sh_flags	array
&=	O
~	O
flag	int
;	O
if	O
(	O
do_section_details	int
)	O
{	O
switch	O
(	O
flag	int
)	O
{	O
case	O
SHF_WRITE	O
:	O
sindex	int
=	O
0	int
;	O
break	O
;	O
case	O
SHF_ALLOC	O
:	O
sindex	int
=	O
1	int
;	O
break	O
;	O
case	O
SHF_EXECINSTR	O
:	O
sindex	int
=	O
2	int
;	O
break	O
;	O
case	O
SHF_MERGE	O
:	O
sindex	int
=	O
3	int
;	O
break	O
;	O
case	O
SHF_STRINGS	O
:	O
sindex	int
=	O
4	int
;	O
break	O
;	O
case	O
SHF_INFO_LINK	O
:	O
sindex	int
=	O
5	int
;	O
break	O
;	O
case	O
SHF_LINK_ORDER	O
:	O
sindex	int
=	O
6	int
;	O
break	O
;	O
case	O
SHF_OS_NONCONFORMING	O
:	O
sindex	int
=	O
7	int
;	O
break	O
;	O
case	O
SHF_GROUP	O
:	O
sindex	int
=	O
8	int
;	O
break	O
;	O
case	O
SHF_TLS	O
:	O
sindex	int
=	O
9	int
;	O
break	O
;	O
case	O
SHF_EXCLUDE	int
:	O
sindex	int
=	O
18	int
;	O
break	O
;	O
case	O
SHF_COMPRESSED	O
:	O
sindex	int
=	O
20	int
;	O
break	O
;	O
case	O
SHF_GNU_MBIND	int
:	O
sindex	int
=	O
24	int
;	O
break	O
;	O
default	O
:	O
sindex	int
=	O
-	O
1	int
;	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
case	O
EM_IA_64	int
:	O
if	O
(	O
flag	int
==	O
SHF_IA_64_SHORT	int
)	O
sindex	int
=	O
10	int
;	O
else	O
if	O
(	O
flag	int
==	O
SHF_IA_64_NORECOV	int
)	O
sindex	int
=	O
11	int
;	O
else	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_ident	array
[	O
EI_OSABI	int
]	O
==	O
ELFOSABI_OPENVMS	int
)	O
switch	O
(	O
flag	int
)	O
{	O
case	O
SHF_IA_64_VMS_GLOBAL	int
:	O
sindex	int
=	O
12	int
;	O
break	O
;	O
case	O
SHF_IA_64_VMS_OVERLAID	int
:	O
sindex	int
=	O
13	int
;	O
break	O
;	O
case	O
SHF_IA_64_VMS_SHARED	int
:	O
sindex	int
=	O
14	int
;	O
break	O
;	O
case	O
SHF_IA_64_VMS_VECTOR	int
:	O
sindex	int
=	O
15	int
;	O
break	O
;	O
case	O
SHF_IA_64_VMS_ALLOC_64BIT	int
:	O
sindex	int
=	O
16	int
;	O
break	O
;	O
case	O
SHF_IA_64_VMS_PROTECTED	int
:	O
sindex	int
=	O
17	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
case	O
EM_386	int
:	O
case	O
EM_IAMCU	int
:	O
case	O
EM_X86_64	int
:	O
case	O
EM_L1OM	int
:	O
case	O
EM_K1OM	int
:	O
case	O
EM_OLD_SPARCV9	int
:	O
case	O
EM_SPARC32PLUS	int
:	O
case	O
EM_SPARCV9	int
:	O
case	O
EM_SPARC	int
:	O
if	O
(	O
flag	int
==	O
SHF_ORDERED	int
)	O
sindex	int
=	O
19	int
;	O
break	O
;	O
case	O
EM_ARM	int
:	O
switch	O
(	O
flag	int
)	O
{	O
case	O
SHF_ENTRYSECT	int
:	O
sindex	int
=	O
21	int
;	O
break	O
;	O
case	O
SHF_ARM_PURECODE	int
:	O
sindex	int
=	O
22	int
;	O
break	O
;	O
case	O
SHF_COMDEF	int
:	O
sindex	int
=	O
23	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
case	O
EM_PPC	int
:	O
if	O
(	O
flag	int
==	O
SHF_PPC_VLE	int
)	O
sindex	int
=	O
25	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
if	O
(	O
sindex	int
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
p	pointer
!=	O
buff	array
+	O
field_size	int
+	O
4	int
)	O
{	O
if	O
(	O
size	int
<	O
(	O
10	int
+	O
2	int
)	O
)	O
{	O
warn	function
(	O
_	O
(	O
"Internal error: not enough buffer room for section flag info"	pointer
)	O
)	O
;	O
return	O
_	O
(	O
"<unknown>"	pointer
)	O
;	O
}	O
size	int
-=	O
2	int
;	O
*	O
p	pointer
++	O
=	O
','	O
;	O
*	O
p	pointer
++	O
=	O
' '	O
;	O
}	O
size	int
-=	O
flags	int
[	O
sindex	int
]	O
.	O
len	int
;	O
p	pointer
=	O
stpcpy	function
(	O
p	pointer
,	O
flags	int
[	O
sindex	int
]	O
.	O
str	int
)	O
;	O
}	O
else	O
if	O
(	O
flag	int
&	O
SHF_MASKOS	int
)	O
os_flags	long
|=	O
flag	int
;	O
else	O
if	O
(	O
flag	int
&	O
SHF_MASKPROC	int
)	O
proc_flags	long
|=	O
flag	int
;	O
else	O
unknown_flags	long
|=	O
flag	int
;	O
}	O
else	O
{	O
switch	O
(	O
flag	int
)	O
{	O
case	O
SHF_WRITE	O
:	O
*	O
p	pointer
=	O
'W'	O
;	O
break	O
;	O
case	O
SHF_ALLOC	O
:	O
*	O
p	pointer
=	O
'A'	O
;	O
break	O
;	O
case	O
SHF_EXECINSTR	O
:	O
*	O
p	pointer
=	O
'X'	O
;	O
break	O
;	O
case	O
SHF_MERGE	O
:	O
*	O
p	pointer
=	O
'M'	O
;	O
break	O
;	O
case	O
SHF_STRINGS	O
:	O
*	O
p	pointer
=	O
'S'	O
;	O
break	O
;	O
case	O
SHF_INFO_LINK	O
:	O
*	O
p	pointer
=	O
'I'	O
;	O
break	O
;	O
case	O
SHF_LINK_ORDER	O
:	O
*	O
p	pointer
=	O
'L'	O
;	O
break	O
;	O
case	O
SHF_OS_NONCONFORMING	O
:	O
*	O
p	pointer
=	O
'O'	O
;	O
break	O
;	O
case	O
SHF_GROUP	O
:	O
*	O
p	pointer
=	O
'G'	O
;	O
break	O
;	O
case	O
SHF_TLS	O
:	O
*	O
p	pointer
=	O
'T'	O
;	O
break	O
;	O
case	O
SHF_EXCLUDE	int
:	O
*	O
p	pointer
=	O
'E'	O
;	O
break	O
;	O
case	O
SHF_COMPRESSED	O
:	O
*	O
p	pointer
=	O
'C'	O
;	O
break	O
;	O
case	O
SHF_GNU_MBIND	int
:	O
*	O
p	pointer
=	O
'D'	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_X86_64	int
||	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_L1OM	int
||	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_K1OM	int
)	O
&&	O
flag	int
==	O
SHF_X86_64_LARGE	int
)	O
*	O
p	pointer
=	O
'l'	O
;	O
else	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_ARM	int
&&	O
flag	int
==	O
SHF_ARM_PURECODE	int
)	O
*	O
p	pointer
=	O
'y'	O
;	O
else	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_PPC	int
&&	O
flag	int
==	O
SHF_PPC_VLE	int
)	O
*	O
p	pointer
=	O
'v'	O
;	O
else	O
if	O
(	O
flag	int
&	O
SHF_MASKOS	int
)	O
{	O
*	O
p	pointer
=	O
'o'	O
;	O
sh_flags	array
&=	O
~	O
SHF_MASKOS	int
;	O
}	O
else	O
if	O
(	O
flag	int
&	O
SHF_MASKPROC	int
)	O
{	O
*	O
p	pointer
=	O
'p'	O
;	O
sh_flags	array
&=	O
~	O
SHF_MASKPROC	int
;	O
}	O
else	O
*	O
p	pointer
=	O
'x'	O
;	O
break	O
;	O
}	O
p	pointer
++	O
;	O
}	O
}	O
if	O
(	O
do_section_details	int
)	O
{	O
if	O
(	O
os_flags	long
)	O
{	O
size	int
-=	O
5	int
+	O
field_size	int
;	O
if	O
(	O
p	pointer
!=	O
buff	array
+	O
field_size	int
+	O
4	int
)	O
{	O
if	O
(	O
size	int
<	O
(	O
2	int
+	O
1	int
)	O
)	O
{	O
warn	function
(	O
_	O
(	O
"Internal error: not enough buffer room for section flag info"	pointer
)	O
)	O
;	O
return	O
_	O
(	O
"<unknown>"	pointer
)	O
;	O
}	O
size	int
-=	O
2	int
;	O
*	O
p	pointer
++	O
=	O
','	O
;	O
*	O
p	pointer
++	O
=	O
' '	O
;	O
}	O
sprintf	function
(	O
p	pointer
,	O
"OS (%*.*lx)"	pointer
,	O
field_size	int
,	O
field_size	int
,	O
(	O
unsigned	O
long	O
)	O
os_flags	long
)	O
;	O
p	pointer
+=	O
5	int
+	O
field_size	int
;	O
}	O
if	O
(	O
proc_flags	long
)	O
{	O
size	int
-=	O
7	int
+	O
field_size	int
;	O
if	O
(	O
p	pointer
!=	O
buff	array
+	O
field_size	int
+	O
4	int
)	O
{	O
if	O
(	O
size	int
<	O
(	O
2	int
+	O
1	int
)	O
)	O
{	O
warn	function
(	O
_	O
(	O
"Internal error: not enough buffer room for section flag info"	pointer
)	O
)	O
;	O
return	O
_	O
(	O
"<unknown>"	pointer
)	O
;	O
}	O
size	int
-=	O
2	int
;	O
*	O
p	pointer
++	O
=	O
','	O
;	O
*	O
p	pointer
++	O
=	O
' '	O
;	O
}	O
sprintf	function
(	O
p	pointer
,	O
"PROC (%*.*lx)"	pointer
,	O
field_size	int
,	O
field_size	int
,	O
(	O
unsigned	O
long	O
)	O
proc_flags	long
)	O
;	O
p	pointer
+=	O
7	int
+	O
field_size	int
;	O
}	O
if	O
(	O
unknown_flags	long
)	O
{	O
size	int
-=	O
10	int
+	O
field_size	int
;	O
if	O
(	O
p	pointer
!=	O
buff	array
+	O
field_size	int
+	O
4	int
)	O
{	O
if	O
(	O
size	int
<	O
(	O
2	int
+	O
1	int
)	O
)	O
{	O
warn	function
(	O
_	O
(	O
"Internal error: not enough buffer room for section flag info"	pointer
)	O
)	O
;	O
return	O
_	O
(	O
"<unknown>"	pointer
)	O
;	O
}	O
size	int
-=	O
2	int
;	O
*	O
p	pointer
++	O
=	O
','	O
;	O
*	O
p	pointer
++	O
=	O
' '	O
;	O
}	O
sprintf	function
(	O
p	pointer
,	O
_	O
(	O
"UNKNOWN (%*.*lx)"	pointer
)	O
,	O
field_size	int
,	O
field_size	int
,	O
(	O
unsigned	O
long	O
)	O
unknown_flags	long
)	O
;	O
p	pointer
+=	O
10	int
+	O
field_size	int
;	O
}	O
}	O
*	O
p	pointer
=	O
'\0'	O
;	O
return	O
buff	array
;	O
}	O
static	O
unsigned	O
int	O
get_compression_header	function
(	O
Elf_Internal_Chdr	struct
*	O
chdr	pointer
,	O
unsigned	O
char	O
*	O
buf	pointer
,	O
bfd_size_type	long
size	int
)	O
{	O
if	O
(	O
is_32bit_elf	int
)	O
{	O
Elf32_External_Chdr	struct
*	O
echdr	pointer
=	O
(	O
Elf32_External_Chdr	struct
*	O
)	O
buf	pointer
;	O
if	O
(	O
size	int
<	O
sizeof	O
(	O
*	O
echdr	pointer
)	O
)	O
{	O
error	function
(	O
_	O
(	O
"Compressed section is too small even for a compression header\n"	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
chdr	pointer
->	O
ch_type	array
=	O
BYTE_GET	O
(	O
echdr	pointer
->	O
ch_type	array
)	O
;	O
chdr	pointer
->	O
ch_size	array
=	O
BYTE_GET	O
(	O
echdr	pointer
->	O
ch_size	array
)	O
;	O
chdr	pointer
->	O
ch_addralign	array
=	O
BYTE_GET	O
(	O
echdr	pointer
->	O
ch_addralign	array
)	O
;	O
return	O
sizeof	O
(	O
*	O
echdr	pointer
)	O
;	O
}	O
else	O
{	O
Elf64_External_Chdr	struct
*	O
echdr	pointer
=	O
(	O
Elf64_External_Chdr	struct
*	O
)	O
buf	pointer
;	O
if	O
(	O
size	int
<	O
sizeof	O
(	O
*	O
echdr	pointer
)	O
)	O
{	O
error	function
(	O
_	O
(	O
"Compressed section is too small even for a compression header\n"	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
chdr	pointer
->	O
ch_type	array
=	O
BYTE_GET	O
(	O
echdr	pointer
->	O
ch_type	array
)	O
;	O
chdr	pointer
->	O
ch_size	array
=	O
BYTE_GET	O
(	O
echdr	pointer
->	O
ch_size	array
)	O
;	O
chdr	pointer
->	O
ch_addralign	array
=	O
BYTE_GET	O
(	O
echdr	pointer
->	O
ch_addralign	array
)	O
;	O
return	O
sizeof	O
(	O
*	O
echdr	pointer
)	O
;	O
}	O
}	O
static	O
bfd_boolean	int
process_section_headers	function
(	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
Elf_Internal_Shdr	struct
*	O
section	pointer
;	O
unsigned	O
int	O
i	pointer
;	O
filedata	struct
->	O
section_headers	pointer
=	O
NULL	O
;	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
==	O
0	int
)	O
{	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_shoff	array
!=	O
0	int
)	O
{	O
warn	function
(	O
_	O
(	O
"possibly corrupt ELF file header - it has a non-zero"	pointer
" section header offset, but no section headers\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
else	O
if	O
(	O
do_sections	int
)	O
printf	function
(	O
_	O
(	O
"\nThere are no sections in this file.\n"	pointer
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
do_sections	int
&&	O
!	O
do_header	int
)	O
printf	function
(	O
ngettext	function
(	O
"There is %d section header, "	pointer
"starting at offset 0x%lx:\n"	pointer
,	O
"There are %d section headers, "	pointer
"starting at offset 0x%lx:\n"	pointer
,	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
)	O
,	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
,	O
(	O
unsigned	O
long	O
)	O
filedata	struct
->	O
file_header	struct
.	O
e_shoff	array
)	O
;	O
if	O
(	O
is_32bit_elf	int
)	O
{	O
if	O
(	O
!	O
get_32bit_section_headers	function
(	O
filedata	struct
,	O
FALSE	int
)	O
)	O
return	O
FALSE	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
get_64bit_section_headers	function
(	O
filedata	struct
,	O
FALSE	int
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_shstrndx	array
!=	O
SHN_UNDEF	int
&&	O
filedata	struct
->	O
file_header	struct
.	O
e_shstrndx	array
<	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
)	O
{	O
section	pointer
=	O
filedata	struct
->	O
section_headers	pointer
+	O
filedata	struct
->	O
file_header	struct
.	O
e_shstrndx	array
;	O
if	O
(	O
section	pointer
->	O
sh_size	array
!=	O
0	int
)	O
{	O
filedata	struct
->	O
string_table	pointer
=	O
(	O
char	O
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
section	pointer
->	O
sh_offset	array
,	O
1	int
,	O
section	pointer
->	O
sh_size	array
,	O
_	O
(	O
"string table"	pointer
)	O
)	O
;	O
filedata	struct
->	O
string_table_length	long
=	O
filedata	struct
->	O
string_table	pointer
!=	O
NULL	O
?	O
section	pointer
->	O
sh_size	array
:	O
0	int
;	O
}	O
}	O
dynamic_symbols	pointer
=	O
NULL	O
;	O
dynamic_strings	pointer
=	O
NULL	O
;	O
dynamic_syminfo	pointer
=	O
NULL	O
;	O
symtab_shndx_list	pointer
=	O
NULL	O
;	O
eh_addr_size	int
=	O
is_32bit_elf	int
?	O
4	int
:	O
8	int
;	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
case	O
EM_MIPS	int
:	O
case	O
EM_MIPS_RS3_LE	int
:	O
if	O
(	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_flags	array
&	O
EF_MIPS_ABI	int
)	O
==	O
E_MIPS_ABI_EABI64	int
&&	O
find_section	function
(	O
filedata	struct
,	O
".gcc_compiled_long32"	pointer
)	O
==	O
NULL	O
)	O
eh_addr_size	int
=	O
8	int
;	O
break	O
;	O
case	O
EM_H8_300	int
:	O
case	O
EM_H8_300H	int
:	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_flags	array
&	O
EF_H8_MACH	int
)	O
{	O
case	O
E_H8_MACH_H8300	int
:	O
case	O
E_H8_MACH_H8300HN	int
:	O
case	O
E_H8_MACH_H8300SN	int
:	O
case	O
E_H8_MACH_H8300SXN	int
:	O
eh_addr_size	int
=	O
2	int
;	O
break	O
;	O
case	O
E_H8_MACH_H8300H	int
:	O
case	O
E_H8_MACH_H8300S	int
:	O
case	O
E_H8_MACH_H8300SX	int
:	O
eh_addr_size	int
=	O
4	int
;	O
break	O
;	O
}	O
break	O
;	O
case	O
EM_M32C_OLD	int
:	O
case	O
EM_M32C	int
:	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_flags	array
&	O
EF_M32C_CPU_MASK	int
)	O
{	O
case	O
EF_M32C_CPU_M16C	int
:	O
eh_addr_size	int
=	O
2	int
;	O
break	O
;	O
}	O
break	O
;	O
}	O
for	O
(	O
i	pointer
=	O
0	int
,	O
section	pointer
=	O
filedata	struct
->	O
section_headers	pointer
;	O
i	pointer
<	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
;	O
i	pointer
++	O
,	O
section	pointer
++	O
)	O
{	O
char	O
*	O
name	pointer
=	O
SECTION_NAME	O
(	O
section	pointer
)	O
;	O
if	O
(	O
section	pointer
->	O
sh_type	array
==	O
SHT_DYNSYM	int
)	O
{	O
if	O
(	O
dynamic_symbols	pointer
!=	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"File contains multiple dynamic symbol tables\n"	pointer
)	O
)	O
;	O
continue	O
;	O
}	O
CHECK_ENTSIZE	O
(	O
section	pointer
,	O
i	pointer
,	O
Sym	O
)	O
;	O
dynamic_symbols	pointer
=	O
GET_ELF_SYMBOLS	O
(	O
filedata	struct
,	O
section	pointer
,	O
&	O
num_dynamic_syms	long
)	O
;	O
}	O
else	O
if	O
(	O
section	pointer
->	O
sh_type	array
==	O
SHT_STRTAB	int
&&	O
streq	O
(	O
name	pointer
,	O
".dynstr"	pointer
)	O
)	O
{	O
if	O
(	O
dynamic_strings	pointer
!=	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"File contains multiple dynamic string tables\n"	pointer
)	O
)	O
;	O
continue	O
;	O
}	O
dynamic_strings	pointer
=	O
(	O
char	O
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
section	pointer
->	O
sh_offset	array
,	O
1	int
,	O
section	pointer
->	O
sh_size	array
,	O
_	O
(	O
"dynamic strings"	pointer
)	O
)	O
;	O
dynamic_strings_length	long
=	O
dynamic_strings	pointer
==	O
NULL	O
?	O
0	int
:	O
section	pointer
->	O
sh_size	array
;	O
}	O
else	O
if	O
(	O
section	pointer
->	O
sh_type	array
==	O
SHT_SYMTAB_SHNDX	int
)	O
{	O
elf_section_list	struct
*	O
entry	int
=	O
xmalloc	function
(	O
sizeof	O
*	O
entry	int
)	O
;	O
entry	int
->	O
hdr	pointer
=	O
section	pointer
;	O
entry	int
->	O
next	pointer
=	O
symtab_shndx_list	pointer
;	O
symtab_shndx_list	pointer
=	O
entry	int
;	O
}	O
else	O
if	O
(	O
section	pointer
->	O
sh_type	array
==	O
SHT_SYMTAB	int
)	O
CHECK_ENTSIZE	O
(	O
section	pointer
,	O
i	pointer
,	O
Sym	O
)	O
;	O
else	O
if	O
(	O
section	pointer
->	O
sh_type	array
==	O
SHT_GROUP	int
)	O
CHECK_ENTSIZE_VALUES	O
(	O
section	pointer
,	O
i	pointer
,	O
GRP_ENTRY_SIZE	int
,	O
GRP_ENTRY_SIZE	int
)	O
;	O
else	O
if	O
(	O
section	pointer
->	O
sh_type	array
==	O
SHT_REL	int
)	O
CHECK_ENTSIZE	O
(	O
section	pointer
,	O
i	pointer
,	O
Rel	O
)	O
;	O
else	O
if	O
(	O
section	pointer
->	O
sh_type	array
==	O
SHT_RELA	int
)	O
CHECK_ENTSIZE	O
(	O
section	pointer
,	O
i	pointer
,	O
Rela	O
)	O
;	O
else	O
if	O
(	O
(	O
do_debugging	int
||	O
do_debug_info	int
||	O
do_debug_abbrevs	int
||	O
do_debug_lines	int
||	O
do_debug_pubnames	int
||	O
do_debug_pubtypes	int
||	O
do_debug_aranges	int
||	O
do_debug_frames	int
||	O
do_debug_macinfo	int
||	O
do_debug_str	int
||	O
do_debug_loc	int
||	O
do_debug_ranges	int
||	O
do_debug_addr	int
||	O
do_debug_cu_index	int
||	O
do_debug_links	int
)	O
&&	O
(	O
const_strneq	O
(	O
name	pointer
,	O
".debug_"	pointer
)	O
||	O
const_strneq	O
(	O
name	pointer
,	O
".zdebug_"	pointer
)	O
)	O
)	O
{	O
if	O
(	O
name	pointer
[	O
1	int
]	O
==	O
'z'	O
)	O
name	pointer
+=	O
sizeof	O
(	O
".zdebug_"	pointer
)	O
-	O
1	int
;	O
else	O
name	pointer
+=	O
sizeof	O
(	O
".debug_"	pointer
)	O
-	O
1	int
;	O
if	O
(	O
do_debugging	int
||	O
(	O
do_debug_info	int
&&	O
const_strneq	O
(	O
name	pointer
,	O
"info"	pointer
)	O
)	O
||	O
(	O
do_debug_info	int
&&	O
const_strneq	O
(	O
name	pointer
,	O
"types"	pointer
)	O
)	O
||	O
(	O
do_debug_abbrevs	int
&&	O
const_strneq	O
(	O
name	pointer
,	O
"abbrev"	pointer
)	O
)	O
||	O
(	O
do_debug_lines	int
&&	O
strcmp	function
(	O
name	pointer
,	O
"line"	pointer
)	O
==	O
0	int
)	O
||	O
(	O
do_debug_lines	int
&&	O
const_strneq	O
(	O
name	pointer
,	O
"line."	pointer
)	O
)	O
||	O
(	O
do_debug_pubnames	int
&&	O
const_strneq	O
(	O
name	pointer
,	O
"pubnames"	pointer
)	O
)	O
||	O
(	O
do_debug_pubtypes	int
&&	O
const_strneq	O
(	O
name	pointer
,	O
"pubtypes"	pointer
)	O
)	O
||	O
(	O
do_debug_pubnames	int
&&	O
const_strneq	O
(	O
name	pointer
,	O
"gnu_pubnames"	pointer
)	O
)	O
||	O
(	O
do_debug_pubtypes	int
&&	O
const_strneq	O
(	O
name	pointer
,	O
"gnu_pubtypes"	pointer
)	O
)	O
||	O
(	O
do_debug_aranges	int
&&	O
const_strneq	O
(	O
name	pointer
,	O
"aranges"	pointer
)	O
)	O
||	O
(	O
do_debug_ranges	int
&&	O
const_strneq	O
(	O
name	pointer
,	O
"ranges"	pointer
)	O
)	O
||	O
(	O
do_debug_ranges	int
&&	O
const_strneq	O
(	O
name	pointer
,	O
"rnglists"	pointer
)	O
)	O
||	O
(	O
do_debug_frames	int
&&	O
const_strneq	O
(	O
name	pointer
,	O
"frame"	pointer
)	O
)	O
||	O
(	O
do_debug_macinfo	int
&&	O
const_strneq	O
(	O
name	pointer
,	O
"macinfo"	pointer
)	O
)	O
||	O
(	O
do_debug_macinfo	int
&&	O
const_strneq	O
(	O
name	pointer
,	O
"macro"	pointer
)	O
)	O
||	O
(	O
do_debug_str	int
&&	O
const_strneq	O
(	O
name	pointer
,	O
"str"	pointer
)	O
)	O
||	O
(	O
do_debug_loc	int
&&	O
const_strneq	O
(	O
name	pointer
,	O
"loc"	pointer
)	O
)	O
||	O
(	O
do_debug_loc	int
&&	O
const_strneq	O
(	O
name	pointer
,	O
"loclists"	pointer
)	O
)	O
||	O
(	O
do_debug_addr	int
&&	O
const_strneq	O
(	O
name	pointer
,	O
"addr"	pointer
)	O
)	O
||	O
(	O
do_debug_cu_index	int
&&	O
const_strneq	O
(	O
name	pointer
,	O
"cu_index"	pointer
)	O
)	O
||	O
(	O
do_debug_cu_index	int
&&	O
const_strneq	O
(	O
name	pointer
,	O
"tu_index"	pointer
)	O
)	O
)	O
request_dump_bynumber	function
(	O
filedata	struct
,	O
i	pointer
,	O
DEBUG_DUMP	O
)	O
;	O
}	O
else	O
if	O
(	O
(	O
do_debugging	int
||	O
do_debug_info	int
)	O
&&	O
const_strneq	O
(	O
name	pointer
,	O
".gnu.linkonce.wi."	pointer
)	O
)	O
request_dump_bynumber	function
(	O
filedata	struct
,	O
i	pointer
,	O
DEBUG_DUMP	O
)	O
;	O
else	O
if	O
(	O
do_debug_frames	int
&&	O
streq	O
(	O
name	pointer
,	O
".eh_frame"	pointer
)	O
)	O
request_dump_bynumber	function
(	O
filedata	struct
,	O
i	pointer
,	O
DEBUG_DUMP	O
)	O
;	O
else	O
if	O
(	O
do_gdb_index	int
&&	O
(	O
streq	O
(	O
name	pointer
,	O
".gdb_index"	pointer
)	O
||	O
streq	O
(	O
name	pointer
,	O
".debug_names"	pointer
)	O
)	O
)	O
request_dump_bynumber	function
(	O
filedata	struct
,	O
i	pointer
,	O
DEBUG_DUMP	O
)	O
;	O
else	O
if	O
(	O
(	O
do_debugging	int
||	O
do_trace_info	int
||	O
do_trace_abbrevs	int
||	O
do_trace_aranges	int
)	O
&&	O
const_strneq	O
(	O
name	pointer
,	O
".trace_"	pointer
)	O
)	O
{	O
name	pointer
+=	O
sizeof	O
(	O
".trace_"	pointer
)	O
-	O
1	int
;	O
if	O
(	O
do_debugging	int
||	O
(	O
do_trace_info	int
&&	O
streq	O
(	O
name	pointer
,	O
"info"	pointer
)	O
)	O
||	O
(	O
do_trace_abbrevs	int
&&	O
streq	O
(	O
name	pointer
,	O
"abbrev"	pointer
)	O
)	O
||	O
(	O
do_trace_aranges	int
&&	O
streq	O
(	O
name	pointer
,	O
"aranges"	pointer
)	O
)	O
)	O
request_dump_bynumber	function
(	O
filedata	struct
,	O
i	pointer
,	O
DEBUG_DUMP	O
)	O
;	O
}	O
else	O
if	O
(	O
(	O
do_debugging	int
||	O
do_debug_links	int
)	O
&&	O
(	O
const_strneq	O
(	O
name	pointer
,	O
".gnu_debuglink"	pointer
)	O
||	O
const_strneq	O
(	O
name	pointer
,	O
".gnu_debugaltlink"	pointer
)	O
)	O
)	O
request_dump_bynumber	function
(	O
filedata	struct
,	O
i	pointer
,	O
DEBUG_DUMP	O
)	O
;	O
}	O
if	O
(	O
!	O
do_sections	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
>	O
1	int
)	O
printf	function
(	O
_	O
(	O
"\nSection Headers:\n"	pointer
)	O
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"\nSection Header:\n"	pointer
)	O
)	O
;	O
if	O
(	O
is_32bit_elf	int
)	O
{	O
if	O
(	O
do_section_details	int
)	O
{	O
printf	function
(	O
_	O
(	O
"  [Nr] Name\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"       Type            Addr     Off    Size   ES   Lk Inf Al\n"	pointer
)	O
)	O
;	O
}	O
else	O
printf	function
(	O
_	O
(	O
"  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al\n"	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
do_wide	int
)	O
{	O
if	O
(	O
do_section_details	int
)	O
{	O
printf	function
(	O
_	O
(	O
"  [Nr] Name\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"       Type            Address          Off    Size   ES   Lk Inf Al\n"	pointer
)	O
)	O
;	O
}	O
else	O
printf	function
(	O
_	O
(	O
"  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al\n"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
do_section_details	int
)	O
{	O
printf	function
(	O
_	O
(	O
"  [Nr] Name\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"       Type              Address          Offset            Link\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"       Size              EntSize          Info              Align\n"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
printf	function
(	O
_	O
(	O
"  [Nr] Name              Type             Address           Offset\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"       Size              EntSize          Flags  Link  Info  Align\n"	pointer
)	O
)	O
;	O
}	O
}	O
if	O
(	O
do_section_details	int
)	O
printf	function
(	O
_	O
(	O
"       Flags\n"	pointer
)	O
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
,	O
section	pointer
=	O
filedata	struct
->	O
section_headers	pointer
;	O
i	pointer
<	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
;	O
i	pointer
++	O
,	O
section	pointer
++	O
)	O
{	O
switch	O
(	O
section	pointer
->	O
sh_type	array
)	O
{	O
case	O
SHT_REL	int
:	O
case	O
SHT_RELA	int
:	O
if	O
(	O
section	pointer
->	O
sh_link	array
==	O
0	int
&&	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_type	array
==	O
ET_EXEC	int
||	O
filedata	struct
->	O
file_header	struct
.	O
e_type	array
==	O
ET_DYN	int
)	O
)	O
break	O
;	O
case	O
SHT_SYMTAB_SHNDX	int
:	O
case	O
SHT_GROUP	int
:	O
case	O
SHT_HASH	int
:	O
case	O
SHT_GNU_HASH	int
:	O
case	O
SHT_GNU_versym	O
:	O
if	O
(	O
section	pointer
->	O
sh_link	array
==	O
0	int
||	O
section	pointer
->	O
sh_link	array
>=	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
||	O
(	O
filedata	struct
->	O
section_headers	pointer
[	O
section	pointer
->	O
sh_link	array
]	O
.	O
sh_type	array
!=	O
SHT_SYMTAB	int
&&	O
filedata	struct
->	O
section_headers	pointer
[	O
section	pointer
->	O
sh_link	array
]	O
.	O
sh_type	array
!=	O
SHT_DYNSYM	int
)	O
)	O
warn	function
(	O
_	O
(	O
"[%2u]: Link field (%u) should index a symtab section.\n"	pointer
)	O
,	O
i	pointer
,	O
section	pointer
->	O
sh_link	array
)	O
;	O
break	O
;	O
case	O
SHT_DYNAMIC	int
:	O
case	O
SHT_SYMTAB	int
:	O
case	O
SHT_DYNSYM	int
:	O
case	O
SHT_GNU_verneed	O
:	O
case	O
SHT_GNU_verdef	O
:	O
case	O
SHT_GNU_LIBLIST	int
:	O
if	O
(	O
section	pointer
->	O
sh_link	array
==	O
0	int
||	O
section	pointer
->	O
sh_link	array
>=	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
||	O
filedata	struct
->	O
section_headers	pointer
[	O
section	pointer
->	O
sh_link	array
]	O
.	O
sh_type	array
!=	O
SHT_STRTAB	int
)	O
warn	function
(	O
_	O
(	O
"[%2u]: Link field (%u) should index a string section.\n"	pointer
)	O
,	O
i	pointer
,	O
section	pointer
->	O
sh_link	array
)	O
;	O
break	O
;	O
case	O
SHT_INIT_ARRAY	int
:	O
case	O
SHT_FINI_ARRAY	int
:	O
case	O
SHT_PREINIT_ARRAY	int
:	O
if	O
(	O
section	pointer
->	O
sh_type	array
<	O
SHT_LOOS	int
&&	O
section	pointer
->	O
sh_link	array
!=	O
0	int
)	O
warn	function
(	O
_	O
(	O
"[%2u]: Unexpected value (%u) in link field.\n"	pointer
)	O
,	O
i	pointer
,	O
section	pointer
->	O
sh_link	array
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
switch	O
(	O
section	pointer
->	O
sh_type	array
)	O
{	O
case	O
SHT_REL	int
:	O
case	O
SHT_RELA	int
:	O
if	O
(	O
section	pointer
->	O
sh_info	array
==	O
0	int
&&	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_type	array
==	O
ET_EXEC	int
||	O
filedata	struct
->	O
file_header	struct
.	O
e_type	array
==	O
ET_DYN	int
)	O
)	O
break	O
;	O
if	O
(	O
section	pointer
->	O
sh_info	array
==	O
0	int
||	O
section	pointer
->	O
sh_info	array
>=	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
||	O
(	O
filedata	struct
->	O
section_headers	pointer
[	O
section	pointer
->	O
sh_info	array
]	O
.	O
sh_type	array
!=	O
SHT_PROGBITS	int
&&	O
filedata	struct
->	O
section_headers	pointer
[	O
section	pointer
->	O
sh_info	array
]	O
.	O
sh_type	array
!=	O
SHT_NOBITS	int
&&	O
filedata	struct
->	O
section_headers	pointer
[	O
section	pointer
->	O
sh_info	array
]	O
.	O
sh_type	array
!=	O
SHT_NOTE	int
&&	O
filedata	struct
->	O
section_headers	pointer
[	O
section	pointer
->	O
sh_info	array
]	O
.	O
sh_type	array
!=	O
SHT_INIT_ARRAY	int
&&	O
filedata	struct
->	O
section_headers	pointer
[	O
section	pointer
->	O
sh_info	array
]	O
.	O
sh_type	array
!=	O
SHT_FINI_ARRAY	int
&&	O
filedata	struct
->	O
section_headers	pointer
[	O
section	pointer
->	O
sh_info	array
]	O
.	O
sh_type	array
!=	O
SHT_PREINIT_ARRAY	int
&&	O
filedata	struct
->	O
section_headers	pointer
[	O
section	pointer
->	O
sh_info	array
]	O
.	O
sh_type	array
<	O
SHT_LOOS	int
)	O
)	O
warn	function
(	O
_	O
(	O
"[%2u]: Info field (%u) should index a relocatable section.\n"	pointer
)	O
,	O
i	pointer
,	O
section	pointer
->	O
sh_info	array
)	O
;	O
break	O
;	O
case	O
SHT_DYNAMIC	int
:	O
case	O
SHT_HASH	int
:	O
case	O
SHT_SYMTAB_SHNDX	int
:	O
case	O
SHT_INIT_ARRAY	int
:	O
case	O
SHT_FINI_ARRAY	int
:	O
case	O
SHT_PREINIT_ARRAY	int
:	O
if	O
(	O
section	pointer
->	O
sh_info	array
!=	O
0	int
)	O
warn	function
(	O
_	O
(	O
"[%2u]: Unexpected value (%u) in info field.\n"	pointer
)	O
,	O
i	pointer
,	O
section	pointer
->	O
sh_info	array
)	O
;	O
break	O
;	O
case	O
SHT_GROUP	int
:	O
case	O
SHT_SYMTAB	int
:	O
case	O
SHT_DYNSYM	int
:	O
break	O
;	O
default	O
:	O
if	O
(	O
section	pointer
->	O
sh_type	array
==	O
SHT_NOBITS	int
)	O
;	O
else	O
if	O
(	O
section	pointer
->	O
sh_flags	array
&	O
SHF_INFO_LINK	O
)	O
{	O
if	O
(	O
section	pointer
->	O
sh_info	array
<	O
1	int
||	O
section	pointer
->	O
sh_info	array
>=	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
)	O
warn	function
(	O
_	O
(	O
"[%2u]: Expected link to another section in info field"	pointer
)	O
,	O
i	pointer
)	O
;	O
}	O
else	O
if	O
(	O
section	pointer
->	O
sh_type	array
<	O
SHT_LOOS	int
&&	O
(	O
section	pointer
->	O
sh_flags	array
&	O
SHF_GNU_MBIND	int
)	O
==	O
0	int
&&	O
section	pointer
->	O
sh_info	array
!=	O
0	int
)	O
warn	function
(	O
_	O
(	O
"[%2u]: Unexpected value (%u) in info field.\n"	pointer
)	O
,	O
i	pointer
,	O
section	pointer
->	O
sh_info	array
)	O
;	O
break	O
;	O
}	O
if	O
(	O
section	pointer
->	O
sh_size	array
>	O
filedata	struct
->	O
file_size	long
&&	O
section	pointer
->	O
sh_type	array
!=	O
SHT_NOBITS	int
&&	O
section	pointer
->	O
sh_type	array
!=	O
SHT_NULL	int
&&	O
section	pointer
->	O
sh_type	array
<	O
SHT_LOOS	int
)	O
warn	function
(	O
_	O
(	O
"Size of section %u is larger than the entire file!\n"	pointer
)	O
,	O
i	pointer
)	O
;	O
printf	function
(	O
"  [%2u] "	pointer
,	O
i	pointer
)	O
;	O
if	O
(	O
do_section_details	int
)	O
printf	function
(	O
"%s\n      "	pointer
,	O
printable_section_name	function
(	O
filedata	struct
,	O
section	pointer
)	O
)	O
;	O
else	O
print_symbol	function
(	O
-	O
17	int
,	O
SECTION_NAME	O
(	O
section	pointer
)	O
)	O
;	O
printf	function
(	O
do_wide	int
?	O
" %-15s "	pointer
:	O
" %-15.15s "	pointer
,	O
get_section_type_name	function
(	O
filedata	struct
,	O
section	pointer
->	O
sh_type	array
)	O
)	O
;	O
if	O
(	O
is_32bit_elf	int
)	O
{	O
const	O
char	O
*	O
link_too_big	pointer
=	O
NULL	O
;	O
print_vma	function
(	O
section	pointer
->	O
sh_addr	array
,	O
LONG_HEX	int
)	O
;	O
printf	function
(	O
" %6.6lx %6.6lx %2.2lx"	pointer
,	O
(	O
unsigned	O
long	O
)	O
section	pointer
->	O
sh_offset	array
,	O
(	O
unsigned	O
long	O
)	O
section	pointer
->	O
sh_size	array
,	O
(	O
unsigned	O
long	O
)	O
section	pointer
->	O
sh_entsize	array
)	O
;	O
if	O
(	O
do_section_details	int
)	O
fputs	function
(	O
"  "	pointer
,	O
stdout	pointer
)	O
;	O
else	O
printf	function
(	O
" %3s "	pointer
,	O
get_elf_section_flags	function
(	O
filedata	struct
,	O
section	pointer
->	O
sh_flags	array
)	O
)	O
;	O
if	O
(	O
section	pointer
->	O
sh_link	array
>=	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
)	O
{	O
link_too_big	pointer
=	O
""	pointer
;	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
case	O
EM_386	int
:	O
case	O
EM_IAMCU	int
:	O
case	O
EM_X86_64	int
:	O
case	O
EM_L1OM	int
:	O
case	O
EM_K1OM	int
:	O
case	O
EM_OLD_SPARCV9	int
:	O
case	O
EM_SPARC32PLUS	int
:	O
case	O
EM_SPARCV9	int
:	O
case	O
EM_SPARC	int
:	O
if	O
(	O
section	pointer
->	O
sh_link	array
==	O
(	O
SHN_BEFORE	O
&	O
0xffff	int
)	O
)	O
link_too_big	pointer
=	O
"BEFORE"	pointer
;	O
else	O
if	O
(	O
section	pointer
->	O
sh_link	array
==	O
(	O
SHN_AFTER	O
&	O
0xffff	int
)	O
)	O
link_too_big	pointer
=	O
"AFTER"	pointer
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
if	O
(	O
do_section_details	int
)	O
{	O
if	O
(	O
link_too_big	pointer
!=	O
NULL	O
&&	O
*	O
link_too_big	pointer
)	O
printf	function
(	O
"<%s> "	pointer
,	O
link_too_big	pointer
)	O
;	O
else	O
printf	function
(	O
"%2u "	pointer
,	O
section	pointer
->	O
sh_link	array
)	O
;	O
printf	function
(	O
"%3u %2lu\n"	pointer
,	O
section	pointer
->	O
sh_info	array
,	O
(	O
unsigned	O
long	O
)	O
section	pointer
->	O
sh_addralign	array
)	O
;	O
}	O
else	O
printf	function
(	O
"%2u %3u %2lu\n"	pointer
,	O
section	pointer
->	O
sh_link	array
,	O
section	pointer
->	O
sh_info	array
,	O
(	O
unsigned	O
long	O
)	O
section	pointer
->	O
sh_addralign	array
)	O
;	O
if	O
(	O
link_too_big	pointer
&&	O
!	O
*	O
link_too_big	pointer
)	O
warn	function
(	O
_	O
(	O
"section %u: sh_link value of %u is larger than the number of sections\n"	pointer
)	O
,	O
i	pointer
,	O
section	pointer
->	O
sh_link	array
)	O
;	O
}	O
else	O
if	O
(	O
do_wide	int
)	O
{	O
print_vma	function
(	O
section	pointer
->	O
sh_addr	array
,	O
LONG_HEX	int
)	O
;	O
if	O
(	O
(	O
long	O
)	O
section	pointer
->	O
sh_offset	array
==	O
section	pointer
->	O
sh_offset	array
)	O
printf	function
(	O
" %6.6lx"	pointer
,	O
(	O
unsigned	O
long	O
)	O
section	pointer
->	O
sh_offset	array
)	O
;	O
else	O
{	O
putchar	function
(	O
' '	O
)	O
;	O
print_vma	function
(	O
section	pointer
->	O
sh_offset	array
,	O
LONG_HEX	int
)	O
;	O
}	O
if	O
(	O
(	O
unsigned	O
long	O
)	O
section	pointer
->	O
sh_size	array
==	O
section	pointer
->	O
sh_size	array
)	O
printf	function
(	O
" %6.6lx"	pointer
,	O
(	O
unsigned	O
long	O
)	O
section	pointer
->	O
sh_size	array
)	O
;	O
else	O
{	O
putchar	function
(	O
' '	O
)	O
;	O
print_vma	function
(	O
section	pointer
->	O
sh_size	array
,	O
LONG_HEX	int
)	O
;	O
}	O
if	O
(	O
(	O
unsigned	O
long	O
)	O
section	pointer
->	O
sh_entsize	array
==	O
section	pointer
->	O
sh_entsize	array
)	O
printf	function
(	O
" %2.2lx"	pointer
,	O
(	O
unsigned	O
long	O
)	O
section	pointer
->	O
sh_entsize	array
)	O
;	O
else	O
{	O
putchar	function
(	O
' '	O
)	O
;	O
print_vma	function
(	O
section	pointer
->	O
sh_entsize	array
,	O
LONG_HEX	int
)	O
;	O
}	O
if	O
(	O
do_section_details	int
)	O
fputs	function
(	O
"  "	pointer
,	O
stdout	pointer
)	O
;	O
else	O
printf	function
(	O
" %3s "	pointer
,	O
get_elf_section_flags	function
(	O
filedata	struct
,	O
section	pointer
->	O
sh_flags	array
)	O
)	O
;	O
printf	function
(	O
"%2u %3u "	pointer
,	O
section	pointer
->	O
sh_link	array
,	O
section	pointer
->	O
sh_info	array
)	O
;	O
if	O
(	O
(	O
unsigned	O
long	O
)	O
section	pointer
->	O
sh_addralign	array
==	O
section	pointer
->	O
sh_addralign	array
)	O
printf	function
(	O
"%2lu\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
section	pointer
->	O
sh_addralign	array
)	O
;	O
else	O
{	O
print_vma	function
(	O
section	pointer
->	O
sh_addralign	array
,	O
DEC	int
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
do_section_details	int
)	O
{	O
putchar	function
(	O
' '	O
)	O
;	O
print_vma	function
(	O
section	pointer
->	O
sh_addr	array
,	O
LONG_HEX	int
)	O
;	O
if	O
(	O
(	O
long	O
)	O
section	pointer
->	O
sh_offset	array
==	O
section	pointer
->	O
sh_offset	array
)	O
printf	function
(	O
"  %16.16lx"	pointer
,	O
(	O
unsigned	O
long	O
)	O
section	pointer
->	O
sh_offset	array
)	O
;	O
else	O
{	O
printf	function
(	O
"  "	pointer
)	O
;	O
print_vma	function
(	O
section	pointer
->	O
sh_offset	array
,	O
LONG_HEX	int
)	O
;	O
}	O
printf	function
(	O
"  %u\n       "	pointer
,	O
section	pointer
->	O
sh_link	array
)	O
;	O
print_vma	function
(	O
section	pointer
->	O
sh_size	array
,	O
LONG_HEX	int
)	O
;	O
putchar	function
(	O
' '	O
)	O
;	O
print_vma	function
(	O
section	pointer
->	O
sh_entsize	array
,	O
LONG_HEX	int
)	O
;	O
printf	function
(	O
"  %-16u  %lu\n"	pointer
,	O
section	pointer
->	O
sh_info	array
,	O
(	O
unsigned	O
long	O
)	O
section	pointer
->	O
sh_addralign	array
)	O
;	O
}	O
else	O
{	O
putchar	function
(	O
' '	O
)	O
;	O
print_vma	function
(	O
section	pointer
->	O
sh_addr	array
,	O
LONG_HEX	int
)	O
;	O
if	O
(	O
(	O
long	O
)	O
section	pointer
->	O
sh_offset	array
==	O
section	pointer
->	O
sh_offset	array
)	O
printf	function
(	O
"  %8.8lx"	pointer
,	O
(	O
unsigned	O
long	O
)	O
section	pointer
->	O
sh_offset	array
)	O
;	O
else	O
{	O
printf	function
(	O
"  "	pointer
)	O
;	O
print_vma	function
(	O
section	pointer
->	O
sh_offset	array
,	O
LONG_HEX	int
)	O
;	O
}	O
printf	function
(	O
"\n       "	pointer
)	O
;	O
print_vma	function
(	O
section	pointer
->	O
sh_size	array
,	O
LONG_HEX	int
)	O
;	O
printf	function
(	O
"  "	pointer
)	O
;	O
print_vma	function
(	O
section	pointer
->	O
sh_entsize	array
,	O
LONG_HEX	int
)	O
;	O
printf	function
(	O
" %3s "	pointer
,	O
get_elf_section_flags	function
(	O
filedata	struct
,	O
section	pointer
->	O
sh_flags	array
)	O
)	O
;	O
printf	function
(	O
"     %2u   %3u     %lu\n"	pointer
,	O
section	pointer
->	O
sh_link	array
,	O
section	pointer
->	O
sh_info	array
,	O
(	O
unsigned	O
long	O
)	O
section	pointer
->	O
sh_addralign	array
)	O
;	O
}	O
if	O
(	O
do_section_details	int
)	O
{	O
printf	function
(	O
"       %s\n"	pointer
,	O
get_elf_section_flags	function
(	O
filedata	struct
,	O
section	pointer
->	O
sh_flags	array
)	O
)	O
;	O
if	O
(	O
(	O
section	pointer
->	O
sh_flags	array
&	O
SHF_COMPRESSED	O
)	O
!=	O
0	int
)	O
{	O
unsigned	O
char	O
buf	pointer
[	O
24	int
]	O
;	O
assert	O
(	O
sizeof	O
(	O
buf	pointer
)	O
>=	O
sizeof	O
(	O
Elf64_External_Chdr	struct
)	O
)	O
;	O
if	O
(	O
get_data	function
(	O
&	O
buf	pointer
,	O
filedata	struct
,	O
section	pointer
->	O
sh_offset	array
,	O
1	int
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
_	O
(	O
"compression header"	pointer
)	O
)	O
)	O
{	O
Elf_Internal_Chdr	struct
chdr	pointer
;	O
(	O
void	O
)	O
get_compression_header	function
(	O
&	O
chdr	pointer
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
;	O
if	O
(	O
chdr	pointer
.	O
ch_type	array
==	O
ELFCOMPRESS_ZLIB	int
)	O
printf	function
(	O
"       ZLIB, "	pointer
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"       [<unknown>: 0x%x], "	pointer
)	O
,	O
chdr	pointer
.	O
ch_type	array
)	O
;	O
print_vma	function
(	O
chdr	pointer
.	O
ch_size	array
,	O
LONG_HEX	int
)	O
;	O
printf	function
(	O
", %lu\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
chdr	pointer
.	O
ch_addralign	array
)	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
!	O
do_section_details	int
)	O
{	O
printf	function
(	O
_	O
(	O
"Key to Flags:\n  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),\n  L (link order), O (extra OS processing required), G (group), T (TLS),\n  C (compressed), x (unknown), o (OS specific), E (exclude),\n  "	pointer
)	O
)	O
;	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_X86_64	int
||	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_L1OM	int
||	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_K1OM	int
)	O
printf	function
(	O
_	O
(	O
"l (large), "	pointer
)	O
)	O
;	O
else	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_ARM	int
)	O
printf	function
(	O
_	O
(	O
"y (purecode), "	pointer
)	O
)	O
;	O
else	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_PPC	int
)	O
printf	function
(	O
_	O
(	O
"v (VLE), "	pointer
)	O
)	O
;	O
printf	function
(	O
"p (processor specific)\n"	pointer
)	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
const	O
char	O
*	O
get_group_flags	function
(	O
unsigned	O
int	O
flags	int
)	O
{	O
static	O
char	O
buff	array
[	O
128	int
]	O
;	O
if	O
(	O
flags	int
==	O
0	int
)	O
return	O
""	pointer
;	O
else	O
if	O
(	O
flags	int
==	O
GRP_COMDAT	int
)	O
return	O
"COMDAT "	pointer
;	O
snprintf	function
(	O
buff	array
,	O
14	int
,	O
_	O
(	O
"[0x%x: "	pointer
)	O
,	O
flags	int
)	O
;	O
flags	int
&=	O
~	O
GRP_COMDAT	int
;	O
if	O
(	O
flags	int
&	O
GRP_MASKOS	int
)	O
{	O
strcat	function
(	O
buff	array
,	O
"<OS specific>"	pointer
)	O
;	O
flags	int
&=	O
~	O
GRP_MASKOS	int
;	O
}	O
if	O
(	O
flags	int
&	O
GRP_MASKPROC	int
)	O
{	O
strcat	function
(	O
buff	array
,	O
"<PROC specific>"	pointer
)	O
;	O
flags	int
&=	O
~	O
GRP_MASKPROC	int
;	O
}	O
if	O
(	O
flags	int
)	O
strcat	function
(	O
buff	array
,	O
"<unknown>"	pointer
)	O
;	O
strcat	function
(	O
buff	array
,	O
"]"	pointer
)	O
;	O
return	O
buff	array
;	O
}	O
static	O
bfd_boolean	int
process_section_groups	function
(	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
Elf_Internal_Shdr	struct
*	O
section	pointer
;	O
unsigned	O
int	O
i	pointer
;	O
struct	O
group	pointer
*	O
group	pointer
;	O
Elf_Internal_Shdr	struct
*	O
symtab_sec	pointer
;	O
Elf_Internal_Shdr	struct
*	O
strtab_sec	pointer
;	O
Elf_Internal_Sym	struct
*	O
symtab	pointer
;	O
unsigned	O
long	O
num_syms	long
;	O
char	O
*	O
strtab	pointer
;	O
size_t	long
strtab_size	long
;	O
if	O
(	O
!	O
do_unwind	int
&&	O
!	O
do_section_groups	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
==	O
0	int
)	O
{	O
if	O
(	O
do_section_groups	int
)	O
printf	function
(	O
_	O
(	O
"\nThere are no sections to group in this file.\n"	pointer
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
filedata	struct
->	O
section_headers	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Section headers are not available!\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
section_headers_groups	pointer
=	O
(	O
struct	O
group	pointer
*	O
*	O
)	O
calloc	function
(	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
,	O
sizeof	O
(	O
struct	O
group	pointer
*	O
)	O
)	O
;	O
if	O
(	O
section_headers_groups	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Out of memory reading %u section group headers\n"	pointer
)	O
,	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
)	O
;	O
return	O
FALSE	int
;	O
}	O
group_count	long
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
0	int
,	O
section	pointer
=	O
filedata	struct
->	O
section_headers	pointer
;	O
i	pointer
<	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
;	O
i	pointer
++	O
,	O
section	pointer
++	O
)	O
if	O
(	O
section	pointer
->	O
sh_type	array
==	O
SHT_GROUP	int
)	O
group_count	long
++	O
;	O
if	O
(	O
group_count	long
==	O
0	int
)	O
{	O
if	O
(	O
do_section_groups	int
)	O
printf	function
(	O
_	O
(	O
"\nThere are no section groups in this file.\n"	pointer
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
section_groups	pointer
=	O
(	O
struct	O
group	pointer
*	O
)	O
calloc	function
(	O
group_count	long
,	O
sizeof	O
(	O
struct	O
group	pointer
)	O
)	O
;	O
if	O
(	O
section_groups	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Out of memory reading %lu groups\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
group_count	long
)	O
;	O
return	O
FALSE	int
;	O
}	O
symtab_sec	pointer
=	O
NULL	O
;	O
strtab_sec	pointer
=	O
NULL	O
;	O
symtab	pointer
=	O
NULL	O
;	O
num_syms	long
=	O
0	int
;	O
strtab	pointer
=	O
NULL	O
;	O
strtab_size	long
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
0	int
,	O
section	pointer
=	O
filedata	struct
->	O
section_headers	pointer
,	O
group	pointer
=	O
section_groups	pointer
;	O
i	pointer
<	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
;	O
i	pointer
++	O
,	O
section	pointer
++	O
)	O
{	O
if	O
(	O
section	pointer
->	O
sh_type	array
==	O
SHT_GROUP	int
)	O
{	O
const	O
char	O
*	O
name	pointer
=	O
printable_section_name	function
(	O
filedata	struct
,	O
section	pointer
)	O
;	O
const	O
char	O
*	O
group_name	pointer
;	O
unsigned	O
char	O
*	O
start	pointer
;	O
unsigned	O
char	O
*	O
indices	pointer
;	O
unsigned	O
int	O
entry	int
,	O
j	int
,	O
size	int
;	O
Elf_Internal_Shdr	struct
*	O
sec	pointer
;	O
Elf_Internal_Sym	struct
*	O
sym	pointer
;	O
if	O
(	O
section	pointer
->	O
sh_link	array
>=	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
||	O
(	O
(	O
sec	pointer
=	O
filedata	struct
->	O
section_headers	pointer
+	O
section	pointer
->	O
sh_link	array
)	O
->	O
sh_type	array
!=	O
SHT_SYMTAB	int
)	O
)	O
{	O
error	function
(	O
_	O
(	O
"Bad sh_link in group section `%s'\n"	pointer
)	O
,	O
name	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
symtab_sec	pointer
!=	O
sec	pointer
)	O
{	O
symtab_sec	pointer
=	O
sec	pointer
;	O
if	O
(	O
symtab	pointer
)	O
free	function
(	O
symtab	pointer
)	O
;	O
symtab	pointer
=	O
GET_ELF_SYMBOLS	O
(	O
filedata	struct
,	O
symtab_sec	pointer
,	O
&	O
num_syms	long
)	O
;	O
}	O
if	O
(	O
symtab	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Corrupt header in group section `%s'\n"	pointer
)	O
,	O
name	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
section	pointer
->	O
sh_info	array
>=	O
num_syms	long
)	O
{	O
error	function
(	O
_	O
(	O
"Bad sh_info in group section `%s'\n"	pointer
)	O
,	O
name	pointer
)	O
;	O
continue	O
;	O
}	O
sym	pointer
=	O
symtab	pointer
+	O
section	pointer
->	O
sh_info	array
;	O
if	O
(	O
ELF_ST_TYPE	O
(	O
sym	pointer
->	O
st_info	array
)	O
==	O
STT_SECTION	int
)	O
{	O
if	O
(	O
sym	pointer
->	O
st_shndx	int
==	O
0	int
||	O
sym	pointer
->	O
st_shndx	int
>=	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
)	O
{	O
error	function
(	O
_	O
(	O
"Bad sh_info in group section `%s'\n"	pointer
)	O
,	O
name	pointer
)	O
;	O
continue	O
;	O
}	O
group_name	pointer
=	O
SECTION_NAME	O
(	O
filedata	struct
->	O
section_headers	pointer
+	O
sym	pointer
->	O
st_shndx	int
)	O
;	O
strtab_sec	pointer
=	O
NULL	O
;	O
if	O
(	O
strtab	pointer
)	O
free	function
(	O
strtab	pointer
)	O
;	O
strtab	pointer
=	O
NULL	O
;	O
strtab_size	long
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
symtab_sec	pointer
->	O
sh_link	array
>=	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
)	O
{	O
strtab_sec	pointer
=	O
NULL	O
;	O
if	O
(	O
strtab	pointer
)	O
free	function
(	O
strtab	pointer
)	O
;	O
strtab	pointer
=	O
NULL	O
;	O
strtab_size	long
=	O
0	int
;	O
}	O
else	O
if	O
(	O
strtab_sec	pointer
!=	O
(	O
sec	pointer
=	O
filedata	struct
->	O
section_headers	pointer
+	O
symtab_sec	pointer
->	O
sh_link	array
)	O
)	O
{	O
strtab_sec	pointer
=	O
sec	pointer
;	O
if	O
(	O
strtab	pointer
)	O
free	function
(	O
strtab	pointer
)	O
;	O
strtab	pointer
=	O
(	O
char	O
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
strtab_sec	pointer
->	O
sh_offset	array
,	O
1	int
,	O
strtab_sec	pointer
->	O
sh_size	array
,	O
_	O
(	O
"string table"	pointer
)	O
)	O
;	O
strtab_size	long
=	O
strtab	pointer
!=	O
NULL	O
?	O
strtab_sec	pointer
->	O
sh_size	array
:	O
0	int
;	O
}	O
group_name	pointer
=	O
sym	pointer
->	O
st_name	pointer
<	O
strtab_size	long
?	O
strtab	pointer
+	O
sym	pointer
->	O
st_name	pointer
:	O
_	O
(	O
"<corrupt>"	pointer
)	O
;	O
}	O
if	O
(	O
section	pointer
->	O
sh_entsize	array
>	O
section	pointer
->	O
sh_size	array
)	O
{	O
error	function
(	O
_	O
(	O
"Section %s has sh_entsize (0x%lx) which is larger than its size (0x%lx)\n"	pointer
)	O
,	O
printable_section_name	function
(	O
filedata	struct
,	O
section	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
section	pointer
->	O
sh_entsize	array
,	O
(	O
unsigned	O
long	O
)	O
section	pointer
->	O
sh_size	array
)	O
;	O
continue	O
;	O
}	O
start	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
section	pointer
->	O
sh_offset	array
,	O
1	int
,	O
section	pointer
->	O
sh_size	array
,	O
_	O
(	O
"section data"	pointer
)	O
)	O
;	O
if	O
(	O
start	pointer
==	O
NULL	O
)	O
continue	O
;	O
indices	pointer
=	O
start	pointer
;	O
size	int
=	O
(	O
section	pointer
->	O
sh_size	array
/	O
section	pointer
->	O
sh_entsize	array
)	O
-	O
1	int
;	O
entry	int
=	O
byte_get	pointer
(	O
indices	pointer
,	O
4	int
)	O
;	O
indices	pointer
+=	O
4	int
;	O
if	O
(	O
do_section_groups	int
)	O
{	O
printf	function
(	O
_	O
(	O
"\n%sgroup section [%5u] `%s' [%s] contains %u sections:\n"	pointer
)	O
,	O
get_group_flags	function
(	O
entry	int
)	O
,	O
i	pointer
,	O
name	pointer
,	O
group_name	pointer
,	O
size	int
)	O
;	O
printf	function
(	O
_	O
(	O
"   [Index]    Name\n"	pointer
)	O
)	O
;	O
}	O
group	pointer
->	O
group_index	int
=	O
i	pointer
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
size	int
;	O
j	int
++	O
)	O
{	O
struct	O
group_list	struct
*	O
g	pointer
;	O
entry	int
=	O
byte_get	pointer
(	O
indices	pointer
,	O
4	int
)	O
;	O
indices	pointer
+=	O
4	int
;	O
if	O
(	O
entry	int
>=	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
)	O
{	O
static	O
unsigned	O
num_group_errors	int
=	O
0	int
;	O
if	O
(	O
num_group_errors	int
++	O
<	O
10	int
)	O
{	O
error	function
(	O
_	O
(	O
"section [%5u] in group section [%5u] > maximum section [%5u]\n"	pointer
)	O
,	O
entry	int
,	O
i	pointer
,	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
-	O
1	int
)	O
;	O
if	O
(	O
num_group_errors	int
==	O
10	int
)	O
warn	function
(	O
_	O
(	O
"Further error messages about overlarge group section indices suppressed\n"	pointer
)	O
)	O
;	O
}	O
continue	O
;	O
}	O
if	O
(	O
section_headers_groups	pointer
[	O
entry	int
]	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
entry	int
)	O
{	O
static	O
unsigned	O
num_errs	int
=	O
0	int
;	O
if	O
(	O
num_errs	int
++	O
<	O
10	int
)	O
{	O
error	function
(	O
_	O
(	O
"section [%5u] in group section [%5u] already in group section [%5u]\n"	pointer
)	O
,	O
entry	int
,	O
i	pointer
,	O
section_headers_groups	pointer
[	O
entry	int
]	O
->	O
group_index	int
)	O
;	O
if	O
(	O
num_errs	int
==	O
10	int
)	O
warn	function
(	O
_	O
(	O
"Further error messages about already contained group sections suppressed\n"	pointer
)	O
)	O
;	O
}	O
continue	O
;	O
}	O
else	O
{	O
static	O
bfd_boolean	int
warned	int
=	O
FALSE	int
;	O
if	O
(	O
!	O
warned	int
)	O
{	O
error	function
(	O
_	O
(	O
"section 0 in group section [%5u]\n"	pointer
)	O
,	O
section_headers_groups	pointer
[	O
entry	int
]	O
->	O
group_index	int
)	O
;	O
warned	int
=	O
TRUE	int
;	O
}	O
}	O
}	O
section_headers_groups	pointer
[	O
entry	int
]	O
=	O
group	pointer
;	O
if	O
(	O
do_section_groups	int
)	O
{	O
sec	pointer
=	O
filedata	struct
->	O
section_headers	pointer
+	O
entry	int
;	O
printf	function
(	O
"   [%5u]   %s\n"	pointer
,	O
entry	int
,	O
printable_section_name	function
(	O
filedata	struct
,	O
sec	pointer
)	O
)	O
;	O
}	O
g	pointer
=	O
(	O
struct	O
group_list	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
group_list	struct
)	O
)	O
;	O
g	pointer
->	O
section_index	int
=	O
entry	int
;	O
g	pointer
->	O
next	pointer
=	O
group	pointer
->	O
root	pointer
;	O
group	pointer
->	O
root	pointer
=	O
g	pointer
;	O
}	O
if	O
(	O
start	pointer
)	O
free	function
(	O
start	pointer
)	O
;	O
group	pointer
++	O
;	O
}	O
}	O
if	O
(	O
symtab	pointer
)	O
free	function
(	O
symtab	pointer
)	O
;	O
if	O
(	O
strtab	pointer
)	O
free	function
(	O
strtab	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
struct	O
ia64_vms_dynfixup	struct
{	O
bfd_vma	long
needed_ident	long
;	O
bfd_vma	long
needed	long
;	O
bfd_vma	long
fixup_needed	long
;	O
bfd_vma	long
fixup_rela_cnt	long
;	O
bfd_vma	long
fixup_rela_off	long
;	O
}	O
;	O
struct	O
ia64_vms_dynimgrela	struct
{	O
bfd_vma	long
img_rela_cnt	long
;	O
bfd_vma	long
img_rela_off	long
;	O
}	O
;	O
static	O
bfd_boolean	int
dump_ia64_vms_dynamic_fixups	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
struct	O
ia64_vms_dynfixup	struct
*	O
fixup	pointer
,	O
const	O
char	O
*	O
strtab	pointer
,	O
unsigned	O
int	O
strtab_sz	int
)	O
{	O
Elf64_External_VMS_IMAGE_FIXUP	struct
*	O
imfs	pointer
;	O
long	O
i	pointer
;	O
const	O
char	O
*	O
lib_name	pointer
;	O
imfs	pointer
=	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
dynamic_addr	long
+	O
fixup	pointer
->	O
fixup_rela_off	long
,	O
1	int
,	O
fixup	pointer
->	O
fixup_rela_cnt	long
*	O
sizeof	O
(	O
*	O
imfs	pointer
)	O
,	O
_	O
(	O
"dynamic section image fixups"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
imfs	pointer
)	O
return	O
FALSE	int
;	O
if	O
(	O
fixup	pointer
->	O
needed	long
<	O
strtab_sz	int
)	O
lib_name	pointer
=	O
strtab	pointer
+	O
fixup	pointer
->	O
needed	long
;	O
else	O
{	O
warn	function
(	O
_	O
(	O
"corrupt library name index of 0x%lx found in dynamic entry"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
fixup	pointer
->	O
needed	long
)	O
;	O
lib_name	pointer
=	O
"???"	pointer
;	O
}	O
printf	function
(	O
_	O
(	O
"\nImage fixups for needed library #%d: %s - ident: %lx\n"	pointer
)	O
,	O
(	O
int	O
)	O
fixup	pointer
->	O
fixup_needed	long
,	O
lib_name	pointer
,	O
(	O
long	O
)	O
fixup	pointer
->	O
needed_ident	long
)	O
;	O
printf	function
(	O
_	O
(	O
"Seg Offset           Type                             SymVec DataType\n"	pointer
)	O
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
(	O
long	O
)	O
fixup	pointer
->	O
fixup_rela_cnt	long
;	O
i	pointer
++	O
)	O
{	O
unsigned	O
int	O
type	enum
;	O
const	O
char	O
*	O
rtype	long
;	O
printf	function
(	O
"%3u "	pointer
,	O
(	O
unsigned	O
)	O
BYTE_GET	O
(	O
imfs	pointer
[	O
i	pointer
]	O
.	O
fixup_seg	array
)	O
)	O
;	O
printf_vma	O
(	O
(	O
bfd_vma	long
)	O
BYTE_GET	O
(	O
imfs	pointer
[	O
i	pointer
]	O
.	O
fixup_offset	array
)	O
)	O
;	O
type	enum
=	O
BYTE_GET	O
(	O
imfs	pointer
[	O
i	pointer
]	O
.	O
type	enum
)	O
;	O
rtype	long
=	O
elf_ia64_reloc_type	function
(	O
type	enum
)	O
;	O
if	O
(	O
rtype	long
==	O
NULL	O
)	O
printf	function
(	O
" 0x%08x                       "	pointer
,	O
type	enum
)	O
;	O
else	O
printf	function
(	O
" %-32s "	pointer
,	O
rtype	long
)	O
;	O
printf	function
(	O
"%6u "	pointer
,	O
(	O
unsigned	O
)	O
BYTE_GET	O
(	O
imfs	pointer
[	O
i	pointer
]	O
.	O
symvec_index	array
)	O
)	O
;	O
printf	function
(	O
"0x%08x\n"	pointer
,	O
(	O
unsigned	O
)	O
BYTE_GET	O
(	O
imfs	pointer
[	O
i	pointer
]	O
.	O
data_type	int
)	O
)	O
;	O
}	O
free	function
(	O
imfs	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
dump_ia64_vms_dynamic_relocs	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
struct	O
ia64_vms_dynimgrela	struct
*	O
imgrela	pointer
)	O
{	O
Elf64_External_VMS_IMAGE_RELA	struct
*	O
imrs	pointer
;	O
long	O
i	pointer
;	O
imrs	pointer
=	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
dynamic_addr	long
+	O
imgrela	pointer
->	O
img_rela_off	long
,	O
1	int
,	O
imgrela	pointer
->	O
img_rela_cnt	long
*	O
sizeof	O
(	O
*	O
imrs	pointer
)	O
,	O
_	O
(	O
"dynamic section image relocations"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
imrs	pointer
)	O
return	O
FALSE	int
;	O
printf	function
(	O
_	O
(	O
"\nImage relocs\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"Seg Offset   Type                            Addend            Seg Sym Off\n"	pointer
)	O
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
(	O
long	O
)	O
imgrela	pointer
->	O
img_rela_cnt	long
;	O
i	pointer
++	O
)	O
{	O
unsigned	O
int	O
type	enum
;	O
const	O
char	O
*	O
rtype	long
;	O
printf	function
(	O
"%3u "	pointer
,	O
(	O
unsigned	O
)	O
BYTE_GET	O
(	O
imrs	pointer
[	O
i	pointer
]	O
.	O
rela_seg	array
)	O
)	O
;	O
printf	function
(	O
"%08"	pointer
BFD_VMA_FMT	pointer
"x "	pointer
,	O
(	O
bfd_vma	long
)	O
BYTE_GET	O
(	O
imrs	pointer
[	O
i	pointer
]	O
.	O
rela_offset	array
)	O
)	O
;	O
type	enum
=	O
BYTE_GET	O
(	O
imrs	pointer
[	O
i	pointer
]	O
.	O
type	enum
)	O
;	O
rtype	long
=	O
elf_ia64_reloc_type	function
(	O
type	enum
)	O
;	O
if	O
(	O
rtype	long
==	O
NULL	O
)	O
printf	function
(	O
"0x%08x                      "	pointer
,	O
type	enum
)	O
;	O
else	O
printf	function
(	O
"%-31s "	pointer
,	O
rtype	long
)	O
;	O
print_vma	function
(	O
BYTE_GET	O
(	O
imrs	pointer
[	O
i	pointer
]	O
.	O
addend	long
)	O
,	O
FULL_HEX	int
)	O
;	O
printf	function
(	O
"%3u "	pointer
,	O
(	O
unsigned	O
)	O
BYTE_GET	O
(	O
imrs	pointer
[	O
i	pointer
]	O
.	O
sym_seg	array
)	O
)	O
;	O
printf	function
(	O
"%08"	pointer
BFD_VMA_FMT	pointer
"x\n"	pointer
,	O
(	O
bfd_vma	long
)	O
BYTE_GET	O
(	O
imrs	pointer
[	O
i	pointer
]	O
.	O
sym_offset	array
)	O
)	O
;	O
}	O
free	function
(	O
imrs	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
process_ia64_vms_dynamic_relocs	function
(	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
struct	O
ia64_vms_dynfixup	struct
fixup	pointer
;	O
struct	O
ia64_vms_dynimgrela	struct
imgrela	pointer
;	O
Elf_Internal_Dyn	struct
*	O
entry	int
;	O
bfd_vma	long
strtab_off	long
=	O
0	int
;	O
bfd_vma	long
strtab_sz	int
=	O
0	int
;	O
char	O
*	O
strtab	pointer
=	O
NULL	O
;	O
bfd_boolean	int
res	int
=	O
TRUE	int
;	O
memset	function
(	O
&	O
fixup	pointer
,	O
0	int
,	O
sizeof	O
(	O
fixup	pointer
)	O
)	O
;	O
memset	function
(	O
&	O
imgrela	pointer
,	O
0	int
,	O
sizeof	O
(	O
imgrela	pointer
)	O
)	O
;	O
for	O
(	O
entry	int
=	O
dynamic_section	pointer
;	O
entry	int
<	O
dynamic_section	pointer
+	O
dynamic_nent	long
;	O
entry	int
++	O
)	O
{	O
switch	O
(	O
entry	int
->	O
d_tag	array
)	O
{	O
case	O
DT_IA_64_VMS_STRTAB_OFFSET	O
:	O
strtab_off	long
=	O
entry	int
->	O
d_un	union
.	O
d_val	array
;	O
break	O
;	O
case	O
DT_STRSZ	int
:	O
strtab_sz	int
=	O
entry	int
->	O
d_un	union
.	O
d_val	array
;	O
if	O
(	O
strtab	pointer
==	O
NULL	O
)	O
strtab	pointer
=	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
dynamic_addr	long
+	O
strtab_off	long
,	O
1	int
,	O
strtab_sz	int
,	O
_	O
(	O
"dynamic string section"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
DT_IA_64_VMS_NEEDED_IDENT	O
:	O
fixup	pointer
.	O
needed_ident	long
=	O
entry	int
->	O
d_un	union
.	O
d_val	array
;	O
break	O
;	O
case	O
DT_NEEDED	int
:	O
fixup	pointer
.	O
needed	long
=	O
entry	int
->	O
d_un	union
.	O
d_val	array
;	O
break	O
;	O
case	O
DT_IA_64_VMS_FIXUP_NEEDED	O
:	O
fixup	pointer
.	O
fixup_needed	long
=	O
entry	int
->	O
d_un	union
.	O
d_val	array
;	O
break	O
;	O
case	O
DT_IA_64_VMS_FIXUP_RELA_CNT	O
:	O
fixup	pointer
.	O
fixup_rela_cnt	long
=	O
entry	int
->	O
d_un	union
.	O
d_val	array
;	O
break	O
;	O
case	O
DT_IA_64_VMS_FIXUP_RELA_OFF	O
:	O
fixup	pointer
.	O
fixup_rela_off	long
=	O
entry	int
->	O
d_un	union
.	O
d_val	array
;	O
if	O
(	O
!	O
dump_ia64_vms_dynamic_fixups	function
(	O
filedata	struct
,	O
&	O
fixup	pointer
,	O
strtab	pointer
,	O
strtab_sz	int
)	O
)	O
res	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
DT_IA_64_VMS_IMG_RELA_CNT	O
:	O
imgrela	pointer
.	O
img_rela_cnt	long
=	O
entry	int
->	O
d_un	union
.	O
d_val	array
;	O
break	O
;	O
case	O
DT_IA_64_VMS_IMG_RELA_OFF	O
:	O
imgrela	pointer
.	O
img_rela_off	long
=	O
entry	int
->	O
d_un	union
.	O
d_val	array
;	O
if	O
(	O
!	O
dump_ia64_vms_dynamic_relocs	function
(	O
filedata	struct
,	O
&	O
imgrela	pointer
)	O
)	O
res	int
=	O
FALSE	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
if	O
(	O
strtab	pointer
!=	O
NULL	O
)	O
free	function
(	O
strtab	pointer
)	O
;	O
return	O
res	int
;	O
}	O
static	O
struct	O
{	O
const	O
char	O
*	O
name	pointer
;	O
int	O
reloc	int
;	O
int	O
size	int
;	O
int	O
rela	int
;	O
}	O
dynamic_relocations	array
[	O
]	O
=	O
{	O
{	O
"REL"	pointer
,	O
DT_REL	int
,	O
DT_RELSZ	int
,	O
FALSE	int
}	O
,	O
{	O
"RELA"	pointer
,	O
DT_RELA	int
,	O
DT_RELASZ	int
,	O
TRUE	int
}	O
,	O
{	O
"PLT"	pointer
,	O
DT_JMPREL	int
,	O
DT_PLTRELSZ	int
,	O
UNKNOWN	O
}	O
}	O
;	O
static	O
bfd_boolean	int
process_relocs	function
(	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
unsigned	O
long	O
rel_size	long
;	O
unsigned	O
long	O
rel_offset	long
;	O
if	O
(	O
!	O
do_reloc	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
do_using_dynamic	int
)	O
{	O
int	O
is_rela	int
;	O
const	O
char	O
*	O
name	pointer
;	O
bfd_boolean	int
has_dynamic_reloc	int
;	O
unsigned	O
int	O
i	pointer
;	O
has_dynamic_reloc	int
=	O
FALSE	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
ARRAY_SIZE	O
(	O
dynamic_relocations	array
)	O
;	O
i	pointer
++	O
)	O
{	O
is_rela	int
=	O
dynamic_relocations	array
[	O
i	pointer
]	O
.	O
rela	int
;	O
name	pointer
=	O
dynamic_relocations	array
[	O
i	pointer
]	O
.	O
name	pointer
;	O
rel_size	long
=	O
dynamic_info	array
[	O
dynamic_relocations	array
[	O
i	pointer
]	O
.	O
size	int
]	O
;	O
rel_offset	long
=	O
dynamic_info	array
[	O
dynamic_relocations	array
[	O
i	pointer
]	O
.	O
reloc	int
]	O
;	O
if	O
(	O
rel_size	long
)	O
has_dynamic_reloc	int
=	O
TRUE	int
;	O
if	O
(	O
is_rela	int
==	O
UNKNOWN	O
)	O
{	O
if	O
(	O
dynamic_relocations	array
[	O
i	pointer
]	O
.	O
reloc	int
==	O
DT_JMPREL	int
)	O
switch	O
(	O
dynamic_info	array
[	O
DT_PLTREL	int
]	O
)	O
{	O
case	O
DT_REL	int
:	O
is_rela	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
DT_RELA	int
:	O
is_rela	int
=	O
TRUE	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
rel_size	long
)	O
{	O
printf	function
(	O
_	O
(	O
"\n'%s' relocation section at offset 0x%lx contains %ld bytes:\n"	pointer
)	O
,	O
name	pointer
,	O
rel_offset	long
,	O
rel_size	long
)	O
;	O
dump_relocations	function
(	O
filedata	struct
,	O
offset_from_vma	function
(	O
filedata	struct
,	O
rel_offset	long
,	O
rel_size	long
)	O
,	O
rel_size	long
,	O
dynamic_symbols	pointer
,	O
num_dynamic_syms	long
,	O
dynamic_strings	pointer
,	O
dynamic_strings_length	long
,	O
is_rela	int
,	O
TRUE	int
)	O
;	O
}	O
}	O
if	O
(	O
is_ia64_vms	function
(	O
filedata	struct
)	O
)	O
if	O
(	O
process_ia64_vms_dynamic_relocs	function
(	O
filedata	struct
)	O
)	O
has_dynamic_reloc	int
=	O
TRUE	int
;	O
if	O
(	O
!	O
has_dynamic_reloc	int
)	O
printf	function
(	O
_	O
(	O
"\nThere are no dynamic relocations in this file.\n"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
Elf_Internal_Shdr	struct
*	O
section	pointer
;	O
unsigned	O
long	O
i	pointer
;	O
bfd_boolean	int
found	int
=	O
FALSE	int
;	O
for	O
(	O
i	pointer
=	O
0	int
,	O
section	pointer
=	O
filedata	struct
->	O
section_headers	pointer
;	O
i	pointer
<	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
;	O
i	pointer
++	O
,	O
section	pointer
++	O
)	O
{	O
if	O
(	O
section	pointer
->	O
sh_type	array
!=	O
SHT_RELA	int
&&	O
section	pointer
->	O
sh_type	array
!=	O
SHT_REL	int
)	O
continue	O
;	O
rel_offset	long
=	O
section	pointer
->	O
sh_offset	array
;	O
rel_size	long
=	O
section	pointer
->	O
sh_size	array
;	O
if	O
(	O
rel_size	long
)	O
{	O
Elf_Internal_Shdr	struct
*	O
strsec	pointer
;	O
int	O
is_rela	int
;	O
unsigned	O
long	O
num_rela	long
;	O
printf	function
(	O
_	O
(	O
"\nRelocation section "	pointer
)	O
)	O
;	O
if	O
(	O
filedata	struct
->	O
string_table	pointer
==	O
NULL	O
)	O
printf	function
(	O
"%d"	pointer
,	O
section	pointer
->	O
sh_name	array
)	O
;	O
else	O
printf	function
(	O
"'%s'"	pointer
,	O
printable_section_name	function
(	O
filedata	struct
,	O
section	pointer
)	O
)	O
;	O
num_rela	long
=	O
rel_size	long
/	O
section	pointer
->	O
sh_entsize	array
;	O
printf	function
(	O
ngettext	function
(	O
" at offset 0x%lx contains %lu entry:\n"	pointer
,	O
" at offset 0x%lx contains %lu entries:\n"	pointer
,	O
num_rela	long
)	O
,	O
rel_offset	long
,	O
num_rela	long
)	O
;	O
is_rela	int
=	O
section	pointer
->	O
sh_type	array
==	O
SHT_RELA	int
;	O
if	O
(	O
section	pointer
->	O
sh_link	array
!=	O
0	int
&&	O
section	pointer
->	O
sh_link	array
<	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
)	O
{	O
Elf_Internal_Shdr	struct
*	O
symsec	pointer
;	O
Elf_Internal_Sym	struct
*	O
symtab	pointer
;	O
unsigned	O
long	O
nsyms	long
;	O
unsigned	O
long	O
strtablen	long
=	O
0	int
;	O
char	O
*	O
strtab	pointer
=	O
NULL	O
;	O
symsec	pointer
=	O
filedata	struct
->	O
section_headers	pointer
+	O
section	pointer
->	O
sh_link	array
;	O
if	O
(	O
symsec	pointer
->	O
sh_type	array
!=	O
SHT_SYMTAB	int
&&	O
symsec	pointer
->	O
sh_type	array
!=	O
SHT_DYNSYM	int
)	O
continue	O
;	O
symtab	pointer
=	O
GET_ELF_SYMBOLS	O
(	O
filedata	struct
,	O
symsec	pointer
,	O
&	O
nsyms	long
)	O
;	O
if	O
(	O
symtab	pointer
==	O
NULL	O
)	O
continue	O
;	O
if	O
(	O
symsec	pointer
->	O
sh_link	array
!=	O
0	int
&&	O
symsec	pointer
->	O
sh_link	array
<	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
)	O
{	O
strsec	pointer
=	O
filedata	struct
->	O
section_headers	pointer
+	O
symsec	pointer
->	O
sh_link	array
;	O
strtab	pointer
=	O
(	O
char	O
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
strsec	pointer
->	O
sh_offset	array
,	O
1	int
,	O
strsec	pointer
->	O
sh_size	array
,	O
_	O
(	O
"string table"	pointer
)	O
)	O
;	O
strtablen	long
=	O
strtab	pointer
==	O
NULL	O
?	O
0	int
:	O
strsec	pointer
->	O
sh_size	array
;	O
}	O
dump_relocations	function
(	O
filedata	struct
,	O
rel_offset	long
,	O
rel_size	long
,	O
symtab	pointer
,	O
nsyms	long
,	O
strtab	pointer
,	O
strtablen	long
,	O
is_rela	int
,	O
symsec	pointer
->	O
sh_type	array
==	O
SHT_DYNSYM	int
)	O
;	O
if	O
(	O
strtab	pointer
)	O
free	function
(	O
strtab	pointer
)	O
;	O
free	function
(	O
symtab	pointer
)	O
;	O
}	O
else	O
dump_relocations	function
(	O
filedata	struct
,	O
rel_offset	long
,	O
rel_size	long
,	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
is_rela	int
,	O
FALSE	int
)	O
;	O
found	int
=	O
TRUE	int
;	O
}	O
}	O
if	O
(	O
!	O
found	int
)	O
{	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
ARRAY_SIZE	O
(	O
dynamic_relocations	array
)	O
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
dynamic_info	array
[	O
dynamic_relocations	array
[	O
i	pointer
]	O
.	O
size	int
]	O
)	O
{	O
printf	function
(	O
_	O
(	O
"\nThere are no static relocations in this file."	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"\nTo see the dynamic relocations add --use-dynamic to the command line.\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
i	pointer
==	O
ARRAY_SIZE	O
(	O
dynamic_relocations	array
)	O
)	O
printf	function
(	O
_	O
(	O
"\nThere are no relocations in this file.\n"	pointer
)	O
)	O
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
struct	O
absaddr	struct
{	O
unsigned	O
short	O
section	pointer
;	O
bfd_vma	long
offset	long
;	O
}	O
;	O
static	O
void	O
find_symbol_for_address	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
Elf_Internal_Sym	struct
*	O
symtab	pointer
,	O
unsigned	O
long	O
nsyms	long
,	O
const	O
char	O
*	O
strtab	pointer
,	O
unsigned	O
long	O
strtab_size	long
,	O
struct	O
absaddr	struct
addr	pointer
,	O
const	O
char	O
*	O
*	O
symname	pointer
,	O
bfd_vma	long
*	O
offset	long
)	O
{	O
bfd_vma	long
dist	long
=	O
0x100000	int
;	O
Elf_Internal_Sym	struct
*	O
sym	pointer
;	O
Elf_Internal_Sym	struct
*	O
beg	pointer
;	O
Elf_Internal_Sym	struct
*	O
end	pointer
;	O
Elf_Internal_Sym	struct
*	O
best	pointer
=	O
NULL	O
;	O
REMOVE_ARCH_BITS	O
(	O
addr	pointer
.	O
offset	long
)	O
;	O
beg	pointer
=	O
symtab	pointer
;	O
end	pointer
=	O
symtab	pointer
+	O
nsyms	long
;	O
while	O
(	O
beg	pointer
<	O
end	pointer
)	O
{	O
bfd_vma	long
value	int
;	O
sym	pointer
=	O
beg	pointer
+	O
(	O
end	pointer
-	O
beg	pointer
)	O
/	O
2	int
;	O
value	int
=	O
sym	pointer
->	O
st_value	int
;	O
REMOVE_ARCH_BITS	O
(	O
value	int
)	O
;	O
if	O
(	O
sym	pointer
->	O
st_name	pointer
!=	O
0	int
&&	O
(	O
addr	pointer
.	O
section	pointer
==	O
SHN_UNDEF	int
||	O
addr	pointer
.	O
section	pointer
==	O
sym	pointer
->	O
st_shndx	int
)	O
&&	O
addr	pointer
.	O
offset	long
>=	O
value	int
&&	O
addr	pointer
.	O
offset	long
-	O
value	int
<	O
dist	long
)	O
{	O
best	pointer
=	O
sym	pointer
;	O
dist	long
=	O
addr	pointer
.	O
offset	long
-	O
value	int
;	O
if	O
(	O
!	O
dist	long
)	O
break	O
;	O
}	O
if	O
(	O
addr	pointer
.	O
offset	long
<	O
value	int
)	O
end	pointer
=	O
sym	pointer
;	O
else	O
beg	pointer
=	O
sym	pointer
+	O
1	int
;	O
}	O
if	O
(	O
best	pointer
)	O
{	O
*	O
symname	pointer
=	O
(	O
best	pointer
->	O
st_name	pointer
>=	O
strtab_size	long
?	O
_	O
(	O
"<corrupt>"	pointer
)	O
:	O
strtab	pointer
+	O
best	pointer
->	O
st_name	pointer
)	O
;	O
*	O
offset	long
=	O
dist	long
;	O
return	O
;	O
}	O
*	O
symname	pointer
=	O
NULL	O
;	O
*	O
offset	long
=	O
addr	pointer
.	O
offset	long
;	O
}	O
static	O
int	O
symcmp	function
(	O
const	O
void	O
*	O
p	pointer
,	O
const	O
void	O
*	O
q	pointer
)	O
{	O
Elf_Internal_Sym	struct
*	O
sp	pointer
=	O
(	O
Elf_Internal_Sym	struct
*	O
)	O
p	pointer
;	O
Elf_Internal_Sym	struct
*	O
sq	pointer
=	O
(	O
Elf_Internal_Sym	struct
*	O
)	O
q	pointer
;	O
return	O
sp	pointer
->	O
st_value	int
>	O
sq	pointer
->	O
st_value	int
?	O
1	int
:	O
(	O
sp	pointer
->	O
st_value	int
<	O
sq	pointer
->	O
st_value	int
?	O
-	O
1	int
:	O
0	int
)	O
;	O
}	O
struct	O
ia64_unw_table_entry	struct
{	O
struct	O
absaddr	struct
start	pointer
;	O
struct	O
absaddr	struct
end	pointer
;	O
struct	O
absaddr	struct
info	pointer
;	O
}	O
;	O
struct	O
ia64_unw_aux_info	struct
{	O
struct	O
ia64_unw_table_entry	struct
*	O
table	pointer
;	O
unsigned	O
long	O
table_len	long
;	O
unsigned	O
char	O
*	O
info	pointer
;	O
unsigned	O
long	O
info_size	long
;	O
bfd_vma	long
info_addr	long
;	O
bfd_vma	long
seg_base	long
;	O
Elf_Internal_Sym	struct
*	O
symtab	pointer
;	O
unsigned	O
long	O
nsyms	long
;	O
Elf_Internal_Sym	struct
*	O
funtab	pointer
;	O
unsigned	O
long	O
nfuns	long
;	O
char	O
*	O
strtab	pointer
;	O
unsigned	O
long	O
strtab_size	long
;	O
}	O
;	O
static	O
bfd_boolean	int
dump_ia64_unwind	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
struct	O
ia64_unw_aux_info	struct
*	O
aux	pointer
)	O
{	O
struct	O
ia64_unw_table_entry	struct
*	O
tp	pointer
;	O
unsigned	O
long	O
j	int
,	O
nfuns	long
;	O
int	O
in_body	int
;	O
bfd_boolean	int
res	int
=	O
TRUE	int
;	O
aux	pointer
->	O
funtab	pointer
=	O
xmalloc	function
(	O
aux	pointer
->	O
nsyms	long
*	O
sizeof	O
(	O
Elf_Internal_Sym	struct
)	O
)	O
;	O
for	O
(	O
nfuns	long
=	O
0	int
,	O
j	int
=	O
0	int
;	O
j	int
<	O
aux	pointer
->	O
nsyms	long
;	O
j	int
++	O
)	O
if	O
(	O
aux	pointer
->	O
symtab	pointer
[	O
j	int
]	O
.	O
st_value	int
&&	O
ELF_ST_TYPE	O
(	O
aux	pointer
->	O
symtab	pointer
[	O
j	int
]	O
.	O
st_info	array
)	O
==	O
STT_FUNC	int
)	O
aux	pointer
->	O
funtab	pointer
[	O
nfuns	long
++	O
]	O
=	O
aux	pointer
->	O
symtab	pointer
[	O
j	int
]	O
;	O
aux	pointer
->	O
nfuns	long
=	O
nfuns	long
;	O
qsort	function
(	O
aux	pointer
->	O
funtab	pointer
,	O
aux	pointer
->	O
nfuns	long
,	O
sizeof	O
(	O
Elf_Internal_Sym	struct
)	O
,	O
symcmp	function
)	O
;	O
for	O
(	O
tp	pointer
=	O
aux	pointer
->	O
table	pointer
;	O
tp	pointer
<	O
aux	pointer
->	O
table	pointer
+	O
aux	pointer
->	O
table_len	long
;	O
++	O
tp	pointer
)	O
{	O
bfd_vma	long
stamp	long
;	O
bfd_vma	long
offset	long
;	O
const	O
unsigned	O
char	O
*	O
dp	pointer
;	O
const	O
unsigned	O
char	O
*	O
head	pointer
;	O
const	O
unsigned	O
char	O
*	O
end	pointer
;	O
const	O
char	O
*	O
procname	pointer
;	O
find_symbol_for_address	function
(	O
filedata	struct
,	O
aux	pointer
->	O
funtab	pointer
,	O
aux	pointer
->	O
nfuns	long
,	O
aux	pointer
->	O
strtab	pointer
,	O
aux	pointer
->	O
strtab_size	long
,	O
tp	pointer
->	O
start	pointer
,	O
&	O
procname	pointer
,	O
&	O
offset	long
)	O
;	O
fputs	function
(	O
"\n<"	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
procname	pointer
)	O
{	O
fputs	function
(	O
procname	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
offset	long
)	O
printf	function
(	O
"+%lx"	pointer
,	O
(	O
unsigned	O
long	O
)	O
offset	long
)	O
;	O
}	O
fputs	function
(	O
">: ["	pointer
,	O
stdout	pointer
)	O
;	O
print_vma	function
(	O
tp	pointer
->	O
start	pointer
.	O
offset	long
,	O
PREFIX_HEX	int
)	O
;	O
fputc	function
(	O
'-'	O
,	O
stdout	pointer
)	O
;	O
print_vma	function
(	O
tp	pointer
->	O
end	pointer
.	O
offset	long
,	O
PREFIX_HEX	int
)	O
;	O
printf	function
(	O
"], info at +0x%lx\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
(	O
tp	pointer
->	O
info	pointer
.	O
offset	long
-	O
aux	pointer
->	O
seg_base	long
)	O
)	O
;	O
if	O
(	O
aux	pointer
->	O
info	pointer
==	O
NULL	O
)	O
continue	O
;	O
offset	long
=	O
tp	pointer
->	O
info	pointer
.	O
offset	long
;	O
if	O
(	O
tp	pointer
->	O
info	pointer
.	O
section	pointer
)	O
{	O
if	O
(	O
tp	pointer
->	O
info	pointer
.	O
section	pointer
>=	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
)	O
{	O
warn	function
(	O
_	O
(	O
"Invalid section %u in table entry %ld\n"	pointer
)	O
,	O
tp	pointer
->	O
info	pointer
.	O
section	pointer
,	O
(	O
long	O
)	O
(	O
tp	pointer
-	O
aux	pointer
->	O
table	pointer
)	O
)	O
;	O
res	int
=	O
FALSE	int
;	O
continue	O
;	O
}	O
offset	long
+=	O
filedata	struct
->	O
section_headers	pointer
[	O
tp	pointer
->	O
info	pointer
.	O
section	pointer
]	O
.	O
sh_addr	array
;	O
}	O
offset	long
-=	O
aux	pointer
->	O
info_addr	long
;	O
if	O
(	O
offset	long
>=	O
aux	pointer
->	O
info_size	long
||	O
aux	pointer
->	O
info_size	long
-	O
offset	long
<	O
8	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Invalid offset %lx in table entry %ld\n"	pointer
)	O
,	O
(	O
long	O
)	O
tp	pointer
->	O
info	pointer
.	O
offset	long
,	O
(	O
long	O
)	O
(	O
tp	pointer
-	O
aux	pointer
->	O
table	pointer
)	O
)	O
;	O
res	int
=	O
FALSE	int
;	O
continue	O
;	O
}	O
head	pointer
=	O
aux	pointer
->	O
info	pointer
+	O
offset	long
;	O
stamp	long
=	O
byte_get	pointer
(	O
(	O
unsigned	O
char	O
*	O
)	O
head	pointer
,	O
sizeof	O
(	O
stamp	long
)	O
)	O
;	O
printf	function
(	O
"  v%u, flags=0x%lx (%s%s), len=%lu bytes\n"	pointer
,	O
(	O
unsigned	O
)	O
UNW_VER	O
(	O
stamp	long
)	O
,	O
(	O
unsigned	O
long	O
)	O
(	O
(	O
stamp	long
&	O
UNW_FLAG_MASK	int
)	O
>>	O
32	int
)	O
,	O
UNW_FLAG_EHANDLER	O
(	O
stamp	long
)	O
?	O
" ehandler"	pointer
:	O
""	pointer
,	O
UNW_FLAG_UHANDLER	O
(	O
stamp	long
)	O
?	O
" uhandler"	pointer
:	O
""	pointer
,	O
(	O
unsigned	O
long	O
)	O
(	O
eh_addr_size	int
*	O
UNW_LENGTH	O
(	O
stamp	long
)	O
)	O
)	O
;	O
if	O
(	O
UNW_VER	O
(	O
stamp	long
)	O
!=	O
1	int
)	O
{	O
printf	function
(	O
_	O
(	O
"\tUnknown version.\n"	pointer
)	O
)	O
;	O
continue	O
;	O
}	O
in_body	int
=	O
0	int
;	O
end	pointer
=	O
head	pointer
+	O
8	int
+	O
eh_addr_size	int
*	O
UNW_LENGTH	O
(	O
stamp	long
)	O
;	O
if	O
(	O
end	pointer
>	O
aux	pointer
->	O
info	pointer
+	O
aux	pointer
->	O
info_size	long
)	O
end	pointer
=	O
aux	pointer
->	O
info	pointer
+	O
aux	pointer
->	O
info_size	long
;	O
for	O
(	O
dp	pointer
=	O
head	pointer
+	O
8	int
;	O
dp	pointer
<	O
end	pointer
;	O
)	O
dp	pointer
=	O
unw_decode	function
(	O
dp	pointer
,	O
in_body	int
,	O
&	O
in_body	int
,	O
end	pointer
)	O
;	O
}	O
free	function
(	O
aux	pointer
->	O
funtab	pointer
)	O
;	O
return	O
res	int
;	O
}	O
static	O
bfd_boolean	int
slurp_ia64_unwind_table	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
struct	O
ia64_unw_aux_info	struct
*	O
aux	pointer
,	O
Elf_Internal_Shdr	struct
*	O
sec	pointer
)	O
{	O
unsigned	O
long	O
size	int
,	O
nrelas	long
,	O
i	pointer
;	O
Elf_Internal_Phdr	struct
*	O
seg	pointer
;	O
struct	O
ia64_unw_table_entry	struct
*	O
tep	pointer
;	O
Elf_Internal_Shdr	struct
*	O
relsec	pointer
;	O
Elf_Internal_Rela	struct
*	O
rela	int
;	O
Elf_Internal_Rela	struct
*	O
rp	pointer
;	O
unsigned	O
char	O
*	O
table	pointer
;	O
unsigned	O
char	O
*	O
tp	pointer
;	O
Elf_Internal_Sym	struct
*	O
sym	pointer
;	O
const	O
char	O
*	O
relname	pointer
;	O
aux	pointer
->	O
table_len	long
=	O
0	int
;	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_phnum	array
)	O
{	O
if	O
(	O
!	O
get_program_headers	function
(	O
filedata	struct
)	O
)	O
return	O
FALSE	int
;	O
for	O
(	O
seg	pointer
=	O
filedata	struct
->	O
program_headers	pointer
;	O
seg	pointer
<	O
filedata	struct
->	O
program_headers	pointer
+	O
filedata	struct
->	O
file_header	struct
.	O
e_phnum	array
;	O
++	O
seg	pointer
)	O
{	O
if	O
(	O
seg	pointer
->	O
p_type	array
!=	O
PT_LOAD	int
)	O
continue	O
;	O
if	O
(	O
sec	pointer
->	O
sh_addr	array
>=	O
seg	pointer
->	O
p_vaddr	array
&&	O
(	O
sec	pointer
->	O
sh_addr	array
+	O
sec	pointer
->	O
sh_size	array
<=	O
seg	pointer
->	O
p_vaddr	array
+	O
seg	pointer
->	O
p_memsz	array
)	O
)	O
{	O
aux	pointer
->	O
seg_base	long
=	O
seg	pointer
->	O
p_vaddr	array
;	O
break	O
;	O
}	O
}	O
}	O
size	int
=	O
sec	pointer
->	O
sh_size	array
;	O
table	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
sec	pointer
->	O
sh_offset	array
,	O
1	int
,	O
size	int
,	O
_	O
(	O
"unwind table"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
table	pointer
)	O
return	O
FALSE	int
;	O
aux	pointer
->	O
table_len	long
=	O
size	int
/	O
(	O
3	int
*	O
eh_addr_size	int
)	O
;	O
aux	pointer
->	O
table	pointer
=	O
(	O
struct	O
ia64_unw_table_entry	struct
*	O
)	O
xcmalloc	function
(	O
aux	pointer
->	O
table_len	long
,	O
sizeof	O
(	O
aux	pointer
->	O
table	pointer
[	O
0	int
]	O
)	O
)	O
;	O
tep	pointer
=	O
aux	pointer
->	O
table	pointer
;	O
for	O
(	O
tp	pointer
=	O
table	pointer
;	O
tp	pointer
<=	O
table	pointer
+	O
size	int
-	O
(	O
3	int
*	O
eh_addr_size	int
)	O
;	O
++	O
tep	pointer
)	O
{	O
tep	pointer
->	O
start	pointer
.	O
section	pointer
=	O
SHN_UNDEF	int
;	O
tep	pointer
->	O
end	pointer
.	O
section	pointer
=	O
SHN_UNDEF	int
;	O
tep	pointer
->	O
info	pointer
.	O
section	pointer
=	O
SHN_UNDEF	int
;	O
tep	pointer
->	O
start	pointer
.	O
offset	long
=	O
byte_get	pointer
(	O
tp	pointer
,	O
eh_addr_size	int
)	O
;	O
tp	pointer
+=	O
eh_addr_size	int
;	O
tep	pointer
->	O
end	pointer
.	O
offset	long
=	O
byte_get	pointer
(	O
tp	pointer
,	O
eh_addr_size	int
)	O
;	O
tp	pointer
+=	O
eh_addr_size	int
;	O
tep	pointer
->	O
info	pointer
.	O
offset	long
=	O
byte_get	pointer
(	O
tp	pointer
,	O
eh_addr_size	int
)	O
;	O
tp	pointer
+=	O
eh_addr_size	int
;	O
tep	pointer
->	O
start	pointer
.	O
offset	long
+=	O
aux	pointer
->	O
seg_base	long
;	O
tep	pointer
->	O
end	pointer
.	O
offset	long
+=	O
aux	pointer
->	O
seg_base	long
;	O
tep	pointer
->	O
info	pointer
.	O
offset	long
+=	O
aux	pointer
->	O
seg_base	long
;	O
}	O
free	function
(	O
table	pointer
)	O
;	O
for	O
(	O
relsec	pointer
=	O
filedata	struct
->	O
section_headers	pointer
;	O
relsec	pointer
<	O
filedata	struct
->	O
section_headers	pointer
+	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
;	O
++	O
relsec	pointer
)	O
{	O
if	O
(	O
relsec	pointer
->	O
sh_type	array
!=	O
SHT_RELA	int
||	O
relsec	pointer
->	O
sh_info	array
>=	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
||	O
filedata	struct
->	O
section_headers	pointer
+	O
relsec	pointer
->	O
sh_info	array
!=	O
sec	pointer
)	O
continue	O
;	O
if	O
(	O
!	O
slurp_rela_relocs	function
(	O
filedata	struct
,	O
relsec	pointer
->	O
sh_offset	array
,	O
relsec	pointer
->	O
sh_size	array
,	O
&	O
rela	int
,	O
&	O
nrelas	long
)	O
)	O
{	O
free	function
(	O
aux	pointer
->	O
table	pointer
)	O
;	O
aux	pointer
->	O
table	pointer
=	O
NULL	O
;	O
aux	pointer
->	O
table_len	long
=	O
0	int
;	O
return	O
FALSE	int
;	O
}	O
for	O
(	O
rp	pointer
=	O
rela	int
;	O
rp	pointer
<	O
rela	int
+	O
nrelas	long
;	O
++	O
rp	pointer
)	O
{	O
unsigned	O
int	O
sym_ndx	int
;	O
unsigned	O
int	O
r_type	array
=	O
get_reloc_type	function
(	O
filedata	struct
,	O
rp	pointer
->	O
r_info	array
)	O
;	O
relname	pointer
=	O
elf_ia64_reloc_type	function
(	O
r_type	array
)	O
;	O
if	O
(	O
relname	pointer
==	O
NULL	O
)	O
{	O
warn	function
(	O
_	O
(	O
"Skipping unknown relocation type: %u\n"	pointer
)	O
,	O
r_type	array
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
const_strneq	O
(	O
relname	pointer
,	O
"R_IA64_SEGREL"	pointer
)	O
)	O
{	O
warn	function
(	O
_	O
(	O
"Skipping unexpected relocation type: %s\n"	pointer
)	O
,	O
relname	pointer
)	O
;	O
continue	O
;	O
}	O
i	pointer
=	O
rp	pointer
->	O
r_offset	array
/	O
(	O
3	int
*	O
eh_addr_size	int
)	O
;	O
if	O
(	O
i	pointer
>=	O
aux	pointer
->	O
table_len	long
)	O
{	O
warn	function
(	O
_	O
(	O
"Skipping reloc with overlarge offset: %lx\n"	pointer
)	O
,	O
i	pointer
)	O
;	O
continue	O
;	O
}	O
sym_ndx	int
=	O
get_reloc_symindex	function
(	O
rp	pointer
->	O
r_info	array
)	O
;	O
if	O
(	O
sym_ndx	int
>=	O
aux	pointer
->	O
nsyms	long
)	O
{	O
warn	function
(	O
_	O
(	O
"Skipping reloc with invalid symbol index: %u\n"	pointer
)	O
,	O
sym_ndx	int
)	O
;	O
continue	O
;	O
}	O
sym	pointer
=	O
aux	pointer
->	O
symtab	pointer
+	O
sym_ndx	int
;	O
switch	O
(	O
rp	pointer
->	O
r_offset	array
/	O
eh_addr_size	int
%	O
3	int
)	O
{	O
case	O
0	int
:	O
aux	pointer
->	O
table	pointer
[	O
i	pointer
]	O
.	O
start	pointer
.	O
section	pointer
=	O
sym	pointer
->	O
st_shndx	int
;	O
aux	pointer
->	O
table	pointer
[	O
i	pointer
]	O
.	O
start	pointer
.	O
offset	long
=	O
rp	pointer
->	O
r_addend	array
+	O
sym	pointer
->	O
st_value	int
;	O
break	O
;	O
case	O
1	int
:	O
aux	pointer
->	O
table	pointer
[	O
i	pointer
]	O
.	O
end	pointer
.	O
section	pointer
=	O
sym	pointer
->	O
st_shndx	int
;	O
aux	pointer
->	O
table	pointer
[	O
i	pointer
]	O
.	O
end	pointer
.	O
offset	long
=	O
rp	pointer
->	O
r_addend	array
+	O
sym	pointer
->	O
st_value	int
;	O
break	O
;	O
case	O
2	int
:	O
aux	pointer
->	O
table	pointer
[	O
i	pointer
]	O
.	O
info	pointer
.	O
section	pointer
=	O
sym	pointer
->	O
st_shndx	int
;	O
aux	pointer
->	O
table	pointer
[	O
i	pointer
]	O
.	O
info	pointer
.	O
offset	long
=	O
rp	pointer
->	O
r_addend	array
+	O
sym	pointer
->	O
st_value	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
free	function
(	O
rela	int
)	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
ia64_process_unwind	function
(	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
Elf_Internal_Shdr	struct
*	O
sec	pointer
;	O
Elf_Internal_Shdr	struct
*	O
unwsec	pointer
=	O
NULL	O
;	O
Elf_Internal_Shdr	struct
*	O
strsec	pointer
;	O
unsigned	O
long	O
i	pointer
,	O
unwcount	long
=	O
0	int
,	O
unwstart	long
=	O
0	int
;	O
struct	O
ia64_unw_aux_info	struct
aux	pointer
;	O
bfd_boolean	int
res	int
=	O
TRUE	int
;	O
memset	function
(	O
&	O
aux	pointer
,	O
0	int
,	O
sizeof	O
(	O
aux	pointer
)	O
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
,	O
sec	pointer
=	O
filedata	struct
->	O
section_headers	pointer
;	O
i	pointer
<	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
;	O
++	O
i	pointer
,	O
++	O
sec	pointer
)	O
{	O
if	O
(	O
sec	pointer
->	O
sh_type	array
==	O
SHT_SYMTAB	int
&&	O
sec	pointer
->	O
sh_link	array
<	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
)	O
{	O
aux	pointer
.	O
symtab	pointer
=	O
GET_ELF_SYMBOLS	O
(	O
filedata	struct
,	O
sec	pointer
,	O
&	O
aux	pointer
.	O
nsyms	long
)	O
;	O
strsec	pointer
=	O
filedata	struct
->	O
section_headers	pointer
+	O
sec	pointer
->	O
sh_link	array
;	O
if	O
(	O
aux	pointer
.	O
strtab	pointer
!=	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Multiple auxillary string tables encountered\n"	pointer
)	O
)	O
;	O
free	function
(	O
aux	pointer
.	O
strtab	pointer
)	O
;	O
res	int
=	O
FALSE	int
;	O
}	O
aux	pointer
.	O
strtab	pointer
=	O
(	O
char	O
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
strsec	pointer
->	O
sh_offset	array
,	O
1	int
,	O
strsec	pointer
->	O
sh_size	array
,	O
_	O
(	O
"string table"	pointer
)	O
)	O
;	O
aux	pointer
.	O
strtab_size	long
=	O
aux	pointer
.	O
strtab	pointer
!=	O
NULL	O
?	O
strsec	pointer
->	O
sh_size	array
:	O
0	int
;	O
}	O
else	O
if	O
(	O
sec	pointer
->	O
sh_type	array
==	O
SHT_IA_64_UNWIND	O
)	O
unwcount	long
++	O
;	O
}	O
if	O
(	O
!	O
unwcount	long
)	O
printf	function
(	O
_	O
(	O
"\nThere are no unwind sections in this file.\n"	pointer
)	O
)	O
;	O
while	O
(	O
unwcount	long
--	O
>	O
0	int
)	O
{	O
char	O
*	O
suffix	pointer
;	O
size_t	long
len	int
,	O
len2	long
;	O
for	O
(	O
i	pointer
=	O
unwstart	long
,	O
sec	pointer
=	O
filedata	struct
->	O
section_headers	pointer
+	O
unwstart	long
,	O
unwsec	pointer
=	O
NULL	O
;	O
i	pointer
<	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
;	O
++	O
i	pointer
,	O
++	O
sec	pointer
)	O
if	O
(	O
sec	pointer
->	O
sh_type	array
==	O
SHT_IA_64_UNWIND	O
)	O
{	O
unwsec	pointer
=	O
sec	pointer
;	O
break	O
;	O
}	O
assert	O
(	O
unwsec	pointer
!=	O
NULL	O
)	O
;	O
unwstart	long
=	O
i	pointer
+	O
1	int
;	O
len	int
=	O
sizeof	O
(	O
ELF_STRING_ia64_unwind_once	pointer
)	O
-	O
1	int
;	O
if	O
(	O
(	O
unwsec	pointer
->	O
sh_flags	array
&	O
SHF_GROUP	O
)	O
!=	O
0	int
)	O
{	O
struct	O
group_list	struct
*	O
g	pointer
;	O
if	O
(	O
section_headers_groups	pointer
==	O
NULL	O
||	O
section_headers_groups	pointer
[	O
i	pointer
]	O
==	O
NULL	O
)	O
i	pointer
=	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
;	O
else	O
{	O
g	pointer
=	O
section_headers_groups	pointer
[	O
i	pointer
]	O
->	O
root	pointer
;	O
for	O
(	O
;	O
g	pointer
!=	O
NULL	O
;	O
g	pointer
=	O
g	pointer
->	O
next	pointer
)	O
{	O
sec	pointer
=	O
filedata	struct
->	O
section_headers	pointer
+	O
g	pointer
->	O
section_index	int
;	O
if	O
(	O
streq	O
(	O
SECTION_NAME	O
(	O
sec	pointer
)	O
,	O
ELF_STRING_ia64_unwind_info	pointer
)	O
)	O
break	O
;	O
}	O
if	O
(	O
g	pointer
==	O
NULL	O
)	O
i	pointer
=	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
;	O
}	O
}	O
else	O
if	O
(	O
strneq	O
(	O
SECTION_NAME	O
(	O
unwsec	pointer
)	O
,	O
ELF_STRING_ia64_unwind_once	pointer
,	O
len	int
)	O
)	O
{	O
len2	long
=	O
sizeof	O
(	O
ELF_STRING_ia64_unwind_info_once	pointer
)	O
-	O
1	int
;	O
suffix	pointer
=	O
SECTION_NAME	O
(	O
unwsec	pointer
)	O
+	O
len	int
;	O
for	O
(	O
i	pointer
=	O
0	int
,	O
sec	pointer
=	O
filedata	struct
->	O
section_headers	pointer
;	O
i	pointer
<	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
;	O
++	O
i	pointer
,	O
++	O
sec	pointer
)	O
if	O
(	O
strneq	O
(	O
SECTION_NAME	O
(	O
sec	pointer
)	O
,	O
ELF_STRING_ia64_unwind_info_once	pointer
,	O
len2	long
)	O
&&	O
streq	O
(	O
SECTION_NAME	O
(	O
sec	pointer
)	O
+	O
len2	long
,	O
suffix	pointer
)	O
)	O
break	O
;	O
}	O
else	O
{	O
len	int
=	O
sizeof	O
(	O
ELF_STRING_ia64_unwind	pointer
)	O
-	O
1	int
;	O
len2	long
=	O
sizeof	O
(	O
ELF_STRING_ia64_unwind_info	pointer
)	O
-	O
1	int
;	O
suffix	pointer
=	O
""	pointer
;	O
if	O
(	O
strneq	O
(	O
SECTION_NAME	O
(	O
unwsec	pointer
)	O
,	O
ELF_STRING_ia64_unwind	pointer
,	O
len	int
)	O
)	O
suffix	pointer
=	O
SECTION_NAME	O
(	O
unwsec	pointer
)	O
+	O
len	int
;	O
for	O
(	O
i	pointer
=	O
0	int
,	O
sec	pointer
=	O
filedata	struct
->	O
section_headers	pointer
;	O
i	pointer
<	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
;	O
++	O
i	pointer
,	O
++	O
sec	pointer
)	O
if	O
(	O
strneq	O
(	O
SECTION_NAME	O
(	O
sec	pointer
)	O
,	O
ELF_STRING_ia64_unwind_info	pointer
,	O
len2	long
)	O
&&	O
streq	O
(	O
SECTION_NAME	O
(	O
sec	pointer
)	O
+	O
len2	long
,	O
suffix	pointer
)	O
)	O
break	O
;	O
}	O
if	O
(	O
i	pointer
==	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
)	O
{	O
printf	function
(	O
_	O
(	O
"\nCould not find unwind info section for "	pointer
)	O
)	O
;	O
if	O
(	O
filedata	struct
->	O
string_table	pointer
==	O
NULL	O
)	O
printf	function
(	O
"%d"	pointer
,	O
unwsec	pointer
->	O
sh_name	array
)	O
;	O
else	O
printf	function
(	O
"'%s'"	pointer
,	O
printable_section_name	function
(	O
filedata	struct
,	O
unwsec	pointer
)	O
)	O
;	O
}	O
else	O
{	O
aux	pointer
.	O
info_addr	long
=	O
sec	pointer
->	O
sh_addr	array
;	O
aux	pointer
.	O
info	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
sec	pointer
->	O
sh_offset	array
,	O
1	int
,	O
sec	pointer
->	O
sh_size	array
,	O
_	O
(	O
"unwind info"	pointer
)	O
)	O
;	O
aux	pointer
.	O
info_size	long
=	O
aux	pointer
.	O
info	pointer
==	O
NULL	O
?	O
0	int
:	O
sec	pointer
->	O
sh_size	array
;	O
printf	function
(	O
_	O
(	O
"\nUnwind section "	pointer
)	O
)	O
;	O
if	O
(	O
filedata	struct
->	O
string_table	pointer
==	O
NULL	O
)	O
printf	function
(	O
"%d"	pointer
,	O
unwsec	pointer
->	O
sh_name	array
)	O
;	O
else	O
printf	function
(	O
"'%s'"	pointer
,	O
printable_section_name	function
(	O
filedata	struct
,	O
unwsec	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
" at offset 0x%lx contains %lu entries:\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
unwsec	pointer
->	O
sh_offset	array
,	O
(	O
unsigned	O
long	O
)	O
(	O
unwsec	pointer
->	O
sh_size	array
/	O
(	O
3	int
*	O
eh_addr_size	int
)	O
)	O
)	O
;	O
if	O
(	O
slurp_ia64_unwind_table	function
(	O
filedata	struct
,	O
&	O
aux	pointer
,	O
unwsec	pointer
)	O
&&	O
aux	pointer
.	O
table_len	long
>	O
0	int
)	O
dump_ia64_unwind	function
(	O
filedata	struct
,	O
&	O
aux	pointer
)	O
;	O
if	O
(	O
aux	pointer
.	O
table	pointer
)	O
free	function
(	O
(	O
char	O
*	O
)	O
aux	pointer
.	O
table	pointer
)	O
;	O
if	O
(	O
aux	pointer
.	O
info	pointer
)	O
free	function
(	O
(	O
char	O
*	O
)	O
aux	pointer
.	O
info	pointer
)	O
;	O
aux	pointer
.	O
table	pointer
=	O
NULL	O
;	O
aux	pointer
.	O
info	pointer
=	O
NULL	O
;	O
}	O
}	O
if	O
(	O
aux	pointer
.	O
symtab	pointer
)	O
free	function
(	O
aux	pointer
.	O
symtab	pointer
)	O
;	O
if	O
(	O
aux	pointer
.	O
strtab	pointer
)	O
free	function
(	O
(	O
char	O
*	O
)	O
aux	pointer
.	O
strtab	pointer
)	O
;	O
return	O
res	int
;	O
}	O
struct	O
hppa_unw_table_entry	struct
{	O
struct	O
absaddr	struct
start	pointer
;	O
struct	O
absaddr	struct
end	pointer
;	O
unsigned	O
int	O
Cannot_unwind	int
:	O
1	int
;	O
unsigned	O
int	O
Millicode	int
:	O
1	int
;	O
unsigned	O
int	O
Millicode_save_sr0	int
:	O
1	int
;	O
unsigned	O
int	O
Region_description	int
:	O
2	int
;	O
unsigned	O
int	O
reserved1	int
:	O
1	int
;	O
unsigned	O
int	O
Entry_SR	int
:	O
1	int
;	O
unsigned	O
int	O
Entry_FR	int
:	O
4	int
;	O
unsigned	O
int	O
Entry_GR	int
:	O
5	int
;	O
unsigned	O
int	O
Args_stored	int
:	O
1	int
;	O
unsigned	O
int	O
Variable_Frame	int
:	O
1	int
;	O
unsigned	O
int	O
Separate_Package_Body	int
:	O
1	int
;	O
unsigned	O
int	O
Frame_Extension_Millicode	int
:	O
1	int
;	O
unsigned	O
int	O
Stack_Overflow_Check	int
:	O
1	int
;	O
unsigned	O
int	O
Two_Instruction_SP_Increment	int
:	O
1	int
;	O
unsigned	O
int	O
Ada_Region	int
:	O
1	int
;	O
unsigned	O
int	O
cxx_info	int
:	O
1	int
;	O
unsigned	O
int	O
cxx_try_catch	int
:	O
1	int
;	O
unsigned	O
int	O
sched_entry_seq	int
:	O
1	int
;	O
unsigned	O
int	O
reserved2	int
:	O
1	int
;	O
unsigned	O
int	O
Save_SP	int
:	O
1	int
;	O
unsigned	O
int	O
Save_RP	int
:	O
1	int
;	O
unsigned	O
int	O
Save_MRP_in_frame	int
:	O
1	int
;	O
unsigned	O
int	O
extn_ptr_defined	int
:	O
1	int
;	O
unsigned	O
int	O
Cleanup_defined	int
:	O
1	int
;	O
unsigned	O
int	O
MPE_XL_interrupt_marker	int
:	O
1	int
;	O
unsigned	O
int	O
HP_UX_interrupt_marker	int
:	O
1	int
;	O
unsigned	O
int	O
Large_frame	int
:	O
1	int
;	O
unsigned	O
int	O
Pseudo_SP_Set	int
:	O
1	int
;	O
unsigned	O
int	O
reserved4	int
:	O
1	int
;	O
unsigned	O
int	O
Total_frame_size	int
:	O
27	int
;	O
}	O
;	O
struct	O
hppa_unw_aux_info	struct
{	O
struct	O
hppa_unw_table_entry	struct
*	O
table	pointer
;	O
unsigned	O
long	O
table_len	long
;	O
bfd_vma	long
seg_base	long
;	O
Elf_Internal_Sym	struct
*	O
symtab	pointer
;	O
unsigned	O
long	O
nsyms	long
;	O
Elf_Internal_Sym	struct
*	O
funtab	pointer
;	O
unsigned	O
long	O
nfuns	long
;	O
char	O
*	O
strtab	pointer
;	O
unsigned	O
long	O
strtab_size	long
;	O
}	O
;	O
static	O
bfd_boolean	int
dump_hppa_unwind	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
struct	O
hppa_unw_aux_info	struct
*	O
aux	pointer
)	O
{	O
struct	O
hppa_unw_table_entry	struct
*	O
tp	pointer
;	O
unsigned	O
long	O
j	int
,	O
nfuns	long
;	O
bfd_boolean	int
res	int
=	O
TRUE	int
;	O
aux	pointer
->	O
funtab	pointer
=	O
xmalloc	function
(	O
aux	pointer
->	O
nsyms	long
*	O
sizeof	O
(	O
Elf_Internal_Sym	struct
)	O
)	O
;	O
for	O
(	O
nfuns	long
=	O
0	int
,	O
j	int
=	O
0	int
;	O
j	int
<	O
aux	pointer
->	O
nsyms	long
;	O
j	int
++	O
)	O
if	O
(	O
aux	pointer
->	O
symtab	pointer
[	O
j	int
]	O
.	O
st_value	int
&&	O
ELF_ST_TYPE	O
(	O
aux	pointer
->	O
symtab	pointer
[	O
j	int
]	O
.	O
st_info	array
)	O
==	O
STT_FUNC	int
)	O
aux	pointer
->	O
funtab	pointer
[	O
nfuns	long
++	O
]	O
=	O
aux	pointer
->	O
symtab	pointer
[	O
j	int
]	O
;	O
aux	pointer
->	O
nfuns	long
=	O
nfuns	long
;	O
qsort	function
(	O
aux	pointer
->	O
funtab	pointer
,	O
aux	pointer
->	O
nfuns	long
,	O
sizeof	O
(	O
Elf_Internal_Sym	struct
)	O
,	O
symcmp	function
)	O
;	O
for	O
(	O
tp	pointer
=	O
aux	pointer
->	O
table	pointer
;	O
tp	pointer
<	O
aux	pointer
->	O
table	pointer
+	O
aux	pointer
->	O
table_len	long
;	O
++	O
tp	pointer
)	O
{	O
bfd_vma	long
offset	long
;	O
const	O
char	O
*	O
procname	pointer
;	O
find_symbol_for_address	function
(	O
filedata	struct
,	O
aux	pointer
->	O
funtab	pointer
,	O
aux	pointer
->	O
nfuns	long
,	O
aux	pointer
->	O
strtab	pointer
,	O
aux	pointer
->	O
strtab_size	long
,	O
tp	pointer
->	O
start	pointer
,	O
&	O
procname	pointer
,	O
&	O
offset	long
)	O
;	O
fputs	function
(	O
"\n<"	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
procname	pointer
)	O
{	O
fputs	function
(	O
procname	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
offset	long
)	O
printf	function
(	O
"+%lx"	pointer
,	O
(	O
unsigned	O
long	O
)	O
offset	long
)	O
;	O
}	O
fputs	function
(	O
">: ["	pointer
,	O
stdout	pointer
)	O
;	O
print_vma	function
(	O
tp	pointer
->	O
start	pointer
.	O
offset	long
,	O
PREFIX_HEX	int
)	O
;	O
fputc	function
(	O
'-'	O
,	O
stdout	pointer
)	O
;	O
print_vma	function
(	O
tp	pointer
->	O
end	pointer
.	O
offset	long
,	O
PREFIX_HEX	int
)	O
;	O
printf	function
(	O
"]\n\t"	pointer
)	O
;	O
PF	O
(	O
Cannot_unwind	int
)	O
;	O
PF	O
(	O
Millicode	int
)	O
;	O
PF	O
(	O
Millicode_save_sr0	int
)	O
;	O
PF	O
(	O
Entry_SR	int
)	O
;	O
PV	O
(	O
Entry_FR	int
)	O
;	O
PV	O
(	O
Entry_GR	int
)	O
;	O
PF	O
(	O
Args_stored	int
)	O
;	O
PF	O
(	O
Variable_Frame	int
)	O
;	O
PF	O
(	O
Separate_Package_Body	int
)	O
;	O
PF	O
(	O
Frame_Extension_Millicode	int
)	O
;	O
PF	O
(	O
Stack_Overflow_Check	int
)	O
;	O
PF	O
(	O
Two_Instruction_SP_Increment	int
)	O
;	O
PF	O
(	O
Ada_Region	int
)	O
;	O
PF	O
(	O
cxx_info	int
)	O
;	O
PF	O
(	O
cxx_try_catch	int
)	O
;	O
PF	O
(	O
sched_entry_seq	int
)	O
;	O
PF	O
(	O
Save_SP	int
)	O
;	O
PF	O
(	O
Save_RP	int
)	O
;	O
PF	O
(	O
Save_MRP_in_frame	int
)	O
;	O
PF	O
(	O
extn_ptr_defined	int
)	O
;	O
PF	O
(	O
Cleanup_defined	int
)	O
;	O
PF	O
(	O
MPE_XL_interrupt_marker	int
)	O
;	O
PF	O
(	O
HP_UX_interrupt_marker	int
)	O
;	O
PF	O
(	O
Large_frame	int
)	O
;	O
PF	O
(	O
Pseudo_SP_Set	int
)	O
;	O
PV	O
(	O
Total_frame_size	int
)	O
;	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
free	function
(	O
aux	pointer
->	O
funtab	pointer
)	O
;	O
return	O
res	int
;	O
}	O
static	O
bfd_boolean	int
slurp_hppa_unwind_table	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
struct	O
hppa_unw_aux_info	struct
*	O
aux	pointer
,	O
Elf_Internal_Shdr	struct
*	O
sec	pointer
)	O
{	O
unsigned	O
long	O
size	int
,	O
unw_ent_size	long
,	O
nentries	long
,	O
nrelas	long
,	O
i	pointer
;	O
Elf_Internal_Phdr	struct
*	O
seg	pointer
;	O
struct	O
hppa_unw_table_entry	struct
*	O
tep	pointer
;	O
Elf_Internal_Shdr	struct
*	O
relsec	pointer
;	O
Elf_Internal_Rela	struct
*	O
rela	int
;	O
Elf_Internal_Rela	struct
*	O
rp	pointer
;	O
unsigned	O
char	O
*	O
table	pointer
;	O
unsigned	O
char	O
*	O
tp	pointer
;	O
Elf_Internal_Sym	struct
*	O
sym	pointer
;	O
const	O
char	O
*	O
relname	pointer
;	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_phnum	array
)	O
{	O
if	O
(	O
!	O
get_program_headers	function
(	O
filedata	struct
)	O
)	O
return	O
FALSE	int
;	O
for	O
(	O
seg	pointer
=	O
filedata	struct
->	O
program_headers	pointer
;	O
seg	pointer
<	O
filedata	struct
->	O
program_headers	pointer
+	O
filedata	struct
->	O
file_header	struct
.	O
e_phnum	array
;	O
++	O
seg	pointer
)	O
{	O
if	O
(	O
seg	pointer
->	O
p_type	array
!=	O
PT_LOAD	int
)	O
continue	O
;	O
if	O
(	O
sec	pointer
->	O
sh_addr	array
>=	O
seg	pointer
->	O
p_vaddr	array
&&	O
(	O
sec	pointer
->	O
sh_addr	array
+	O
sec	pointer
->	O
sh_size	array
<=	O
seg	pointer
->	O
p_vaddr	array
+	O
seg	pointer
->	O
p_memsz	array
)	O
)	O
{	O
aux	pointer
->	O
seg_base	long
=	O
seg	pointer
->	O
p_vaddr	array
;	O
break	O
;	O
}	O
}	O
}	O
size	int
=	O
sec	pointer
->	O
sh_size	array
;	O
table	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
sec	pointer
->	O
sh_offset	array
,	O
1	int
,	O
size	int
,	O
_	O
(	O
"unwind table"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
table	pointer
)	O
return	O
FALSE	int
;	O
unw_ent_size	long
=	O
16	int
;	O
nentries	long
=	O
size	int
/	O
unw_ent_size	long
;	O
size	int
=	O
unw_ent_size	long
*	O
nentries	long
;	O
tep	pointer
=	O
aux	pointer
->	O
table	pointer
=	O
(	O
struct	O
hppa_unw_table_entry	struct
*	O
)	O
xcmalloc	function
(	O
nentries	long
,	O
sizeof	O
(	O
aux	pointer
->	O
table	pointer
[	O
0	int
]	O
)	O
)	O
;	O
for	O
(	O
tp	pointer
=	O
table	pointer
;	O
tp	pointer
<	O
table	pointer
+	O
size	int
;	O
tp	pointer
+=	O
unw_ent_size	long
,	O
++	O
tep	pointer
)	O
{	O
unsigned	O
int	O
tmp1	int
,	O
tmp2	int
;	O
tep	pointer
->	O
start	pointer
.	O
section	pointer
=	O
SHN_UNDEF	int
;	O
tep	pointer
->	O
end	pointer
.	O
section	pointer
=	O
SHN_UNDEF	int
;	O
tep	pointer
->	O
start	pointer
.	O
offset	long
=	O
byte_get	pointer
(	O
(	O
unsigned	O
char	O
*	O
)	O
tp	pointer
+	O
0	int
,	O
4	int
)	O
;	O
tep	pointer
->	O
end	pointer
.	O
offset	long
=	O
byte_get	pointer
(	O
(	O
unsigned	O
char	O
*	O
)	O
tp	pointer
+	O
4	int
,	O
4	int
)	O
;	O
tmp1	int
=	O
byte_get	pointer
(	O
(	O
unsigned	O
char	O
*	O
)	O
tp	pointer
+	O
8	int
,	O
4	int
)	O
;	O
tmp2	int
=	O
byte_get	pointer
(	O
(	O
unsigned	O
char	O
*	O
)	O
tp	pointer
+	O
12	int
,	O
4	int
)	O
;	O
tep	pointer
->	O
start	pointer
.	O
offset	long
+=	O
aux	pointer
->	O
seg_base	long
;	O
tep	pointer
->	O
end	pointer
.	O
offset	long
+=	O
aux	pointer
->	O
seg_base	long
;	O
tep	pointer
->	O
Cannot_unwind	int
=	O
(	O
tmp1	int
>>	O
31	int
)	O
&	O
0x1	int
;	O
tep	pointer
->	O
Millicode	int
=	O
(	O
tmp1	int
>>	O
30	int
)	O
&	O
0x1	int
;	O
tep	pointer
->	O
Millicode_save_sr0	int
=	O
(	O
tmp1	int
>>	O
29	int
)	O
&	O
0x1	int
;	O
tep	pointer
->	O
Region_description	int
=	O
(	O
tmp1	int
>>	O
27	int
)	O
&	O
0x3	int
;	O
tep	pointer
->	O
reserved1	int
=	O
(	O
tmp1	int
>>	O
26	int
)	O
&	O
0x1	int
;	O
tep	pointer
->	O
Entry_SR	int
=	O
(	O
tmp1	int
>>	O
25	int
)	O
&	O
0x1	int
;	O
tep	pointer
->	O
Entry_FR	int
=	O
(	O
tmp1	int
>>	O
21	int
)	O
&	O
0xf	int
;	O
tep	pointer
->	O
Entry_GR	int
=	O
(	O
tmp1	int
>>	O
16	int
)	O
&	O
0x1f	int
;	O
tep	pointer
->	O
Args_stored	int
=	O
(	O
tmp1	int
>>	O
15	int
)	O
&	O
0x1	int
;	O
tep	pointer
->	O
Variable_Frame	int
=	O
(	O
tmp1	int
>>	O
14	int
)	O
&	O
0x1	int
;	O
tep	pointer
->	O
Separate_Package_Body	int
=	O
(	O
tmp1	int
>>	O
13	int
)	O
&	O
0x1	int
;	O
tep	pointer
->	O
Frame_Extension_Millicode	int
=	O
(	O
tmp1	int
>>	O
12	int
)	O
&	O
0x1	int
;	O
tep	pointer
->	O
Stack_Overflow_Check	int
=	O
(	O
tmp1	int
>>	O
11	int
)	O
&	O
0x1	int
;	O
tep	pointer
->	O
Two_Instruction_SP_Increment	int
=	O
(	O
tmp1	int
>>	O
10	int
)	O
&	O
0x1	int
;	O
tep	pointer
->	O
Ada_Region	int
=	O
(	O
tmp1	int
>>	O
9	int
)	O
&	O
0x1	int
;	O
tep	pointer
->	O
cxx_info	int
=	O
(	O
tmp1	int
>>	O
8	int
)	O
&	O
0x1	int
;	O
tep	pointer
->	O
cxx_try_catch	int
=	O
(	O
tmp1	int
>>	O
7	int
)	O
&	O
0x1	int
;	O
tep	pointer
->	O
sched_entry_seq	int
=	O
(	O
tmp1	int
>>	O
6	int
)	O
&	O
0x1	int
;	O
tep	pointer
->	O
reserved2	int
=	O
(	O
tmp1	int
>>	O
5	int
)	O
&	O
0x1	int
;	O
tep	pointer
->	O
Save_SP	int
=	O
(	O
tmp1	int
>>	O
4	int
)	O
&	O
0x1	int
;	O
tep	pointer
->	O
Save_RP	int
=	O
(	O
tmp1	int
>>	O
3	int
)	O
&	O
0x1	int
;	O
tep	pointer
->	O
Save_MRP_in_frame	int
=	O
(	O
tmp1	int
>>	O
2	int
)	O
&	O
0x1	int
;	O
tep	pointer
->	O
extn_ptr_defined	int
=	O
(	O
tmp1	int
>>	O
1	int
)	O
&	O
0x1	int
;	O
tep	pointer
->	O
Cleanup_defined	int
=	O
tmp1	int
&	O
0x1	int
;	O
tep	pointer
->	O
MPE_XL_interrupt_marker	int
=	O
(	O
tmp2	int
>>	O
31	int
)	O
&	O
0x1	int
;	O
tep	pointer
->	O
HP_UX_interrupt_marker	int
=	O
(	O
tmp2	int
>>	O
30	int
)	O
&	O
0x1	int
;	O
tep	pointer
->	O
Large_frame	int
=	O
(	O
tmp2	int
>>	O
29	int
)	O
&	O
0x1	int
;	O
tep	pointer
->	O
Pseudo_SP_Set	int
=	O
(	O
tmp2	int
>>	O
28	int
)	O
&	O
0x1	int
;	O
tep	pointer
->	O
reserved4	int
=	O
(	O
tmp2	int
>>	O
27	int
)	O
&	O
0x1	int
;	O
tep	pointer
->	O
Total_frame_size	int
=	O
tmp2	int
&	O
0x7ffffff	int
;	O
}	O
free	function
(	O
table	pointer
)	O
;	O
for	O
(	O
relsec	pointer
=	O
filedata	struct
->	O
section_headers	pointer
;	O
relsec	pointer
<	O
filedata	struct
->	O
section_headers	pointer
+	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
;	O
++	O
relsec	pointer
)	O
{	O
if	O
(	O
relsec	pointer
->	O
sh_type	array
!=	O
SHT_RELA	int
||	O
relsec	pointer
->	O
sh_info	array
>=	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
||	O
filedata	struct
->	O
section_headers	pointer
+	O
relsec	pointer
->	O
sh_info	array
!=	O
sec	pointer
)	O
continue	O
;	O
if	O
(	O
!	O
slurp_rela_relocs	function
(	O
filedata	struct
,	O
relsec	pointer
->	O
sh_offset	array
,	O
relsec	pointer
->	O
sh_size	array
,	O
&	O
rela	int
,	O
&	O
nrelas	long
)	O
)	O
return	O
FALSE	int
;	O
for	O
(	O
rp	pointer
=	O
rela	int
;	O
rp	pointer
<	O
rela	int
+	O
nrelas	long
;	O
++	O
rp	pointer
)	O
{	O
unsigned	O
int	O
sym_ndx	int
;	O
unsigned	O
int	O
r_type	array
=	O
get_reloc_type	function
(	O
filedata	struct
,	O
rp	pointer
->	O
r_info	array
)	O
;	O
relname	pointer
=	O
elf_hppa_reloc_type	function
(	O
r_type	array
)	O
;	O
if	O
(	O
relname	pointer
==	O
NULL	O
)	O
{	O
warn	function
(	O
_	O
(	O
"Skipping unknown relocation type: %u\n"	pointer
)	O
,	O
r_type	array
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
const_strneq	O
(	O
relname	pointer
,	O
"R_PARISC_SEGREL"	pointer
)	O
)	O
{	O
warn	function
(	O
_	O
(	O
"Skipping unexpected relocation type: %s\n"	pointer
)	O
,	O
relname	pointer
)	O
;	O
continue	O
;	O
}	O
i	pointer
=	O
rp	pointer
->	O
r_offset	array
/	O
unw_ent_size	long
;	O
if	O
(	O
i	pointer
>=	O
aux	pointer
->	O
table_len	long
)	O
{	O
warn	function
(	O
_	O
(	O
"Skipping reloc with overlarge offset: %lx\n"	pointer
)	O
,	O
i	pointer
)	O
;	O
continue	O
;	O
}	O
sym_ndx	int
=	O
get_reloc_symindex	function
(	O
rp	pointer
->	O
r_info	array
)	O
;	O
if	O
(	O
sym_ndx	int
>=	O
aux	pointer
->	O
nsyms	long
)	O
{	O
warn	function
(	O
_	O
(	O
"Skipping reloc with invalid symbol index: %u\n"	pointer
)	O
,	O
sym_ndx	int
)	O
;	O
continue	O
;	O
}	O
sym	pointer
=	O
aux	pointer
->	O
symtab	pointer
+	O
sym_ndx	int
;	O
switch	O
(	O
(	O
rp	pointer
->	O
r_offset	array
%	O
unw_ent_size	long
)	O
/	O
4	int
)	O
{	O
case	O
0	int
:	O
aux	pointer
->	O
table	pointer
[	O
i	pointer
]	O
.	O
start	pointer
.	O
section	pointer
=	O
sym	pointer
->	O
st_shndx	int
;	O
aux	pointer
->	O
table	pointer
[	O
i	pointer
]	O
.	O
start	pointer
.	O
offset	long
=	O
sym	pointer
->	O
st_value	int
+	O
rp	pointer
->	O
r_addend	array
;	O
break	O
;	O
case	O
1	int
:	O
aux	pointer
->	O
table	pointer
[	O
i	pointer
]	O
.	O
end	pointer
.	O
section	pointer
=	O
sym	pointer
->	O
st_shndx	int
;	O
aux	pointer
->	O
table	pointer
[	O
i	pointer
]	O
.	O
end	pointer
.	O
offset	long
=	O
sym	pointer
->	O
st_value	int
+	O
rp	pointer
->	O
r_addend	array
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
free	function
(	O
rela	int
)	O
;	O
}	O
aux	pointer
->	O
table_len	long
=	O
nentries	long
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
hppa_process_unwind	function
(	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
struct	O
hppa_unw_aux_info	struct
aux	pointer
;	O
Elf_Internal_Shdr	struct
*	O
unwsec	pointer
=	O
NULL	O
;	O
Elf_Internal_Shdr	struct
*	O
strsec	pointer
;	O
Elf_Internal_Shdr	struct
*	O
sec	pointer
;	O
unsigned	O
long	O
i	pointer
;	O
bfd_boolean	int
res	int
=	O
TRUE	int
;	O
if	O
(	O
filedata	struct
->	O
string_table	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
memset	function
(	O
&	O
aux	pointer
,	O
0	int
,	O
sizeof	O
(	O
aux	pointer
)	O
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
,	O
sec	pointer
=	O
filedata	struct
->	O
section_headers	pointer
;	O
i	pointer
<	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
;	O
++	O
i	pointer
,	O
++	O
sec	pointer
)	O
{	O
if	O
(	O
sec	pointer
->	O
sh_type	array
==	O
SHT_SYMTAB	int
&&	O
sec	pointer
->	O
sh_link	array
<	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
)	O
{	O
aux	pointer
.	O
symtab	pointer
=	O
GET_ELF_SYMBOLS	O
(	O
filedata	struct
,	O
sec	pointer
,	O
&	O
aux	pointer
.	O
nsyms	long
)	O
;	O
strsec	pointer
=	O
filedata	struct
->	O
section_headers	pointer
+	O
sec	pointer
->	O
sh_link	array
;	O
if	O
(	O
aux	pointer
.	O
strtab	pointer
!=	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Multiple auxillary string tables encountered\n"	pointer
)	O
)	O
;	O
free	function
(	O
aux	pointer
.	O
strtab	pointer
)	O
;	O
res	int
=	O
FALSE	int
;	O
}	O
aux	pointer
.	O
strtab	pointer
=	O
(	O
char	O
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
strsec	pointer
->	O
sh_offset	array
,	O
1	int
,	O
strsec	pointer
->	O
sh_size	array
,	O
_	O
(	O
"string table"	pointer
)	O
)	O
;	O
aux	pointer
.	O
strtab_size	long
=	O
aux	pointer
.	O
strtab	pointer
!=	O
NULL	O
?	O
strsec	pointer
->	O
sh_size	array
:	O
0	int
;	O
}	O
else	O
if	O
(	O
streq	O
(	O
SECTION_NAME	O
(	O
sec	pointer
)	O
,	O
".PARISC.unwind"	pointer
)	O
)	O
unwsec	pointer
=	O
sec	pointer
;	O
}	O
if	O
(	O
!	O
unwsec	pointer
)	O
printf	function
(	O
_	O
(	O
"\nThere are no unwind sections in this file.\n"	pointer
)	O
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
,	O
sec	pointer
=	O
filedata	struct
->	O
section_headers	pointer
;	O
i	pointer
<	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
;	O
++	O
i	pointer
,	O
++	O
sec	pointer
)	O
{	O
if	O
(	O
streq	O
(	O
SECTION_NAME	O
(	O
sec	pointer
)	O
,	O
".PARISC.unwind"	pointer
)	O
)	O
{	O
unsigned	O
long	O
num_unwind	long
=	O
sec	pointer
->	O
sh_size	array
/	O
16	int
;	O
printf	function
(	O
ngettext	function
(	O
"\nUnwind section '%s' at offset 0x%lx "	pointer
"contains %lu entry:\n"	pointer
,	O
"\nUnwind section '%s' at offset 0x%lx "	pointer
"contains %lu entries:\n"	pointer
,	O
num_unwind	long
)	O
,	O
printable_section_name	function
(	O
filedata	struct
,	O
sec	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
sec	pointer
->	O
sh_offset	array
,	O
num_unwind	long
)	O
;	O
if	O
(	O
!	O
slurp_hppa_unwind_table	function
(	O
filedata	struct
,	O
&	O
aux	pointer
,	O
sec	pointer
)	O
)	O
res	int
=	O
FALSE	int
;	O
if	O
(	O
res	int
&&	O
aux	pointer
.	O
table_len	long
>	O
0	int
)	O
{	O
if	O
(	O
!	O
dump_hppa_unwind	function
(	O
filedata	struct
,	O
&	O
aux	pointer
)	O
)	O
res	int
=	O
FALSE	int
;	O
}	O
if	O
(	O
aux	pointer
.	O
table	pointer
)	O
free	function
(	O
(	O
char	O
*	O
)	O
aux	pointer
.	O
table	pointer
)	O
;	O
aux	pointer
.	O
table	pointer
=	O
NULL	O
;	O
}	O
}	O
if	O
(	O
aux	pointer
.	O
symtab	pointer
)	O
free	function
(	O
aux	pointer
.	O
symtab	pointer
)	O
;	O
if	O
(	O
aux	pointer
.	O
strtab	pointer
)	O
free	function
(	O
(	O
char	O
*	O
)	O
aux	pointer
.	O
strtab	pointer
)	O
;	O
return	O
res	int
;	O
}	O
struct	O
arm_section	struct
{	O
unsigned	O
char	O
*	O
data	pointer
;	O
Elf_Internal_Shdr	struct
*	O
sec	pointer
;	O
Elf_Internal_Rela	struct
*	O
rela	int
;	O
unsigned	O
long	O
nrelas	long
;	O
unsigned	O
int	O
rel_type	int
;	O
Elf_Internal_Rela	struct
*	O
next_rela	pointer
;	O
}	O
;	O
struct	O
arm_unw_aux_info	struct
{	O
Filedata	struct
*	O
filedata	struct
;	O
Elf_Internal_Sym	struct
*	O
symtab	pointer
;	O
unsigned	O
long	O
nsyms	long
;	O
Elf_Internal_Sym	struct
*	O
funtab	pointer
;	O
unsigned	O
long	O
nfuns	long
;	O
char	O
*	O
strtab	pointer
;	O
unsigned	O
long	O
strtab_size	long
;	O
}	O
;	O
static	O
const	O
char	O
*	O
arm_print_vma_and_name	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
struct	O
arm_unw_aux_info	struct
*	O
aux	pointer
,	O
bfd_vma	long
fn	pointer
,	O
struct	O
absaddr	struct
addr	pointer
)	O
{	O
const	O
char	O
*	O
procname	pointer
;	O
bfd_vma	long
sym_offset	array
;	O
if	O
(	O
addr	pointer
.	O
section	pointer
==	O
SHN_UNDEF	int
)	O
addr	pointer
.	O
offset	long
=	O
fn	pointer
;	O
find_symbol_for_address	function
(	O
filedata	struct
,	O
aux	pointer
->	O
funtab	pointer
,	O
aux	pointer
->	O
nfuns	long
,	O
aux	pointer
->	O
strtab	pointer
,	O
aux	pointer
->	O
strtab_size	long
,	O
addr	pointer
,	O
&	O
procname	pointer
,	O
&	O
sym_offset	array
)	O
;	O
print_vma	function
(	O
fn	pointer
,	O
PREFIX_HEX	int
)	O
;	O
if	O
(	O
procname	pointer
)	O
{	O
fputs	function
(	O
" <"	pointer
,	O
stdout	pointer
)	O
;	O
fputs	function
(	O
procname	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
sym_offset	array
)	O
printf	function
(	O
"+0x%lx"	pointer
,	O
(	O
unsigned	O
long	O
)	O
sym_offset	array
)	O
;	O
fputc	function
(	O
'>'	O
,	O
stdout	pointer
)	O
;	O
}	O
return	O
procname	pointer
;	O
}	O
static	O
void	O
arm_free_section	function
(	O
struct	O
arm_section	struct
*	O
arm_sec	pointer
)	O
{	O
if	O
(	O
arm_sec	pointer
->	O
data	pointer
!=	O
NULL	O
)	O
free	function
(	O
arm_sec	pointer
->	O
data	pointer
)	O
;	O
if	O
(	O
arm_sec	pointer
->	O
rela	int
!=	O
NULL	O
)	O
free	function
(	O
arm_sec	pointer
->	O
rela	int
)	O
;	O
}	O
static	O
bfd_boolean	int
get_unwind_section_word	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
struct	O
arm_unw_aux_info	struct
*	O
aux	pointer
,	O
struct	O
arm_section	struct
*	O
arm_sec	pointer
,	O
Elf_Internal_Shdr	struct
*	O
sec	pointer
,	O
bfd_vma	long
word_offset	long
,	O
unsigned	O
int	O
*	O
wordp	pointer
,	O
struct	O
absaddr	struct
*	O
addr	pointer
,	O
bfd_vma	long
*	O
sym_name	pointer
)	O
{	O
Elf_Internal_Rela	struct
*	O
rp	pointer
;	O
Elf_Internal_Sym	struct
*	O
sym	pointer
;	O
const	O
char	O
*	O
relname	pointer
;	O
unsigned	O
int	O
word	int
;	O
bfd_boolean	int
wrapped	int
;	O
if	O
(	O
sec	pointer
==	O
NULL	O
||	O
arm_sec	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
addr	pointer
->	O
section	pointer
=	O
SHN_UNDEF	int
;	O
addr	pointer
->	O
offset	long
=	O
0	int
;	O
if	O
(	O
sym_name	pointer
!=	O
NULL	O
)	O
*	O
sym_name	pointer
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
if	O
(	O
sec	pointer
!=	O
arm_sec	pointer
->	O
sec	pointer
)	O
{	O
Elf_Internal_Shdr	struct
*	O
relsec	pointer
;	O
arm_free_section	function
(	O
arm_sec	pointer
)	O
;	O
arm_sec	pointer
->	O
sec	pointer
=	O
sec	pointer
;	O
arm_sec	pointer
->	O
data	pointer
=	O
get_data	function
(	O
NULL	O
,	O
aux	pointer
->	O
filedata	struct
,	O
sec	pointer
->	O
sh_offset	array
,	O
1	int
,	O
sec	pointer
->	O
sh_size	array
,	O
_	O
(	O
"unwind data"	pointer
)	O
)	O
;	O
arm_sec	pointer
->	O
rela	int
=	O
NULL	O
;	O
arm_sec	pointer
->	O
nrelas	long
=	O
0	int
;	O
for	O
(	O
relsec	pointer
=	O
filedata	struct
->	O
section_headers	pointer
;	O
relsec	pointer
<	O
filedata	struct
->	O
section_headers	pointer
+	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
;	O
++	O
relsec	pointer
)	O
{	O
if	O
(	O
relsec	pointer
->	O
sh_info	array
>=	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
||	O
filedata	struct
->	O
section_headers	pointer
+	O
relsec	pointer
->	O
sh_info	array
!=	O
sec	pointer
||	O
(	O
relsec	pointer
->	O
sh_type	array
!=	O
SHT_REL	int
&&	O
relsec	pointer
->	O
sh_type	array
!=	O
SHT_RELA	int
)	O
)	O
continue	O
;	O
arm_sec	pointer
->	O
rel_type	int
=	O
relsec	pointer
->	O
sh_type	array
;	O
if	O
(	O
relsec	pointer
->	O
sh_type	array
==	O
SHT_REL	int
)	O
{	O
if	O
(	O
!	O
slurp_rel_relocs	function
(	O
aux	pointer
->	O
filedata	struct
,	O
relsec	pointer
->	O
sh_offset	array
,	O
relsec	pointer
->	O
sh_size	array
,	O
&	O
arm_sec	pointer
->	O
rela	int
,	O
&	O
arm_sec	pointer
->	O
nrelas	long
)	O
)	O
return	O
FALSE	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
slurp_rela_relocs	function
(	O
aux	pointer
->	O
filedata	struct
,	O
relsec	pointer
->	O
sh_offset	array
,	O
relsec	pointer
->	O
sh_size	array
,	O
&	O
arm_sec	pointer
->	O
rela	int
,	O
&	O
arm_sec	pointer
->	O
nrelas	long
)	O
)	O
return	O
FALSE	int
;	O
}	O
break	O
;	O
}	O
arm_sec	pointer
->	O
next_rela	pointer
=	O
arm_sec	pointer
->	O
rela	int
;	O
}	O
if	O
(	O
arm_sec	pointer
->	O
data	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
sec	pointer
->	O
sh_size	array
<	O
4	int
||	O
word_offset	long
>	O
(	O
sec	pointer
->	O
sh_size	array
-	O
4	int
)	O
||	O
(	O
(	O
bfd_signed_vma	long
)	O
word_offset	long
)	O
<	O
0	int
)	O
return	O
FALSE	int
;	O
word	int
=	O
byte_get	pointer
(	O
arm_sec	pointer
->	O
data	pointer
+	O
word_offset	long
,	O
4	int
)	O
;	O
if	O
(	O
arm_sec	pointer
->	O
rela	int
==	O
NULL	O
)	O
{	O
*	O
wordp	pointer
=	O
word	int
;	O
return	O
TRUE	int
;	O
}	O
wrapped	int
=	O
FALSE	int
;	O
for	O
(	O
rp	pointer
=	O
arm_sec	pointer
->	O
next_rela	pointer
;	O
rp	pointer
!=	O
arm_sec	pointer
->	O
rela	int
+	O
arm_sec	pointer
->	O
nrelas	long
;	O
rp	pointer
++	O
)	O
{	O
bfd_vma	long
prelval	long
,	O
offset	long
;	O
if	O
(	O
rp	pointer
->	O
r_offset	array
>	O
word_offset	long
&&	O
!	O
wrapped	int
)	O
{	O
rp	pointer
=	O
arm_sec	pointer
->	O
rela	int
;	O
wrapped	int
=	O
TRUE	int
;	O
}	O
if	O
(	O
rp	pointer
->	O
r_offset	array
>	O
word_offset	long
)	O
break	O
;	O
if	O
(	O
rp	pointer
->	O
r_offset	array
&	O
3	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Skipping unexpected relocation at offset 0x%lx\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
rp	pointer
->	O
r_offset	array
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
rp	pointer
->	O
r_offset	array
<	O
word_offset	long
)	O
continue	O
;	O
if	O
(	O
aux	pointer
->	O
symtab	pointer
==	O
NULL	O
)	O
continue	O
;	O
if	O
(	O
arm_sec	pointer
->	O
rel_type	int
==	O
SHT_REL	int
)	O
{	O
offset	long
=	O
word	int
&	O
0x7fffffff	int
;	O
if	O
(	O
offset	long
&	O
0x40000000	int
)	O
offset	long
|=	O
~	O
(	O
bfd_vma	long
)	O
0x7fffffff	int
;	O
}	O
else	O
if	O
(	O
arm_sec	pointer
->	O
rel_type	int
==	O
SHT_RELA	int
)	O
offset	long
=	O
rp	pointer
->	O
r_addend	array
;	O
else	O
{	O
error	function
(	O
_	O
(	O
"Unknown section relocation type %d encountered\n"	pointer
)	O
,	O
arm_sec	pointer
->	O
rel_type	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
ELF32_R_SYM	O
(	O
rp	pointer
->	O
r_info	array
)	O
>=	O
aux	pointer
->	O
nsyms	long
)	O
{	O
error	function
(	O
_	O
(	O
"Bad symbol index in unwind relocation (%lu > %lu)\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
ELF32_R_SYM	O
(	O
rp	pointer
->	O
r_info	array
)	O
,	O
aux	pointer
->	O
nsyms	long
)	O
;	O
break	O
;	O
}	O
sym	pointer
=	O
aux	pointer
->	O
symtab	pointer
+	O
ELF32_R_SYM	O
(	O
rp	pointer
->	O
r_info	array
)	O
;	O
offset	long
+=	O
sym	pointer
->	O
st_value	int
;	O
prelval	long
=	O
offset	long
-	O
(	O
arm_sec	pointer
->	O
sec	pointer
->	O
sh_addr	array
+	O
rp	pointer
->	O
r_offset	array
)	O
;	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_ARM	int
)	O
{	O
relname	pointer
=	O
elf_arm_reloc_type	function
(	O
ELF32_R_TYPE	O
(	O
rp	pointer
->	O
r_info	array
)	O
)	O
;	O
if	O
(	O
relname	pointer
==	O
NULL	O
)	O
{	O
warn	function
(	O
_	O
(	O
"Skipping unknown ARM relocation type: %d\n"	pointer
)	O
,	O
(	O
int	O
)	O
ELF32_R_TYPE	O
(	O
rp	pointer
->	O
r_info	array
)	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
streq	O
(	O
relname	pointer
,	O
"R_ARM_NONE"	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
!	O
streq	O
(	O
relname	pointer
,	O
"R_ARM_PREL31"	pointer
)	O
)	O
{	O
warn	function
(	O
_	O
(	O
"Skipping unexpected ARM relocation type %s\n"	pointer
)	O
,	O
relname	pointer
)	O
;	O
continue	O
;	O
}	O
}	O
else	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_TI_C6000	int
)	O
{	O
relname	pointer
=	O
elf_tic6x_reloc_type	function
(	O
ELF32_R_TYPE	O
(	O
rp	pointer
->	O
r_info	array
)	O
)	O
;	O
if	O
(	O
relname	pointer
==	O
NULL	O
)	O
{	O
warn	function
(	O
_	O
(	O
"Skipping unknown C6000 relocation type: %d\n"	pointer
)	O
,	O
(	O
int	O
)	O
ELF32_R_TYPE	O
(	O
rp	pointer
->	O
r_info	array
)	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
streq	O
(	O
relname	pointer
,	O
"R_C6000_NONE"	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
!	O
streq	O
(	O
relname	pointer
,	O
"R_C6000_PREL31"	pointer
)	O
)	O
{	O
warn	function
(	O
_	O
(	O
"Skipping unexpected C6000 relocation type %s\n"	pointer
)	O
,	O
relname	pointer
)	O
;	O
continue	O
;	O
}	O
prelval	long
>>=	O
1	int
;	O
}	O
else	O
{	O
warn	function
(	O
_	O
(	O
"Only TI and ARM unwinders are currently supported\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
word	int
=	O
(	O
word	int
&	O
~	O
(	O
bfd_vma	long
)	O
0x7fffffff	int
)	O
|	O
(	O
prelval	long
&	O
0x7fffffff	int
)	O
;	O
addr	pointer
->	O
section	pointer
=	O
sym	pointer
->	O
st_shndx	int
;	O
addr	pointer
->	O
offset	long
=	O
offset	long
;	O
if	O
(	O
sym_name	pointer
)	O
*	O
sym_name	pointer
=	O
sym	pointer
->	O
st_name	pointer
;	O
break	O
;	O
}	O
*	O
wordp	pointer
=	O
word	int
;	O
arm_sec	pointer
->	O
next_rela	pointer
=	O
rp	pointer
;	O
return	O
TRUE	int
;	O
}	O
static	O
const	O
char	O
*	O
tic6x_unwind_regnames	array
[	O
16	int
]	O
=	O
{	O
"A15"	pointer
,	O
"B15"	pointer
,	O
"B14"	pointer
,	O
"B13"	pointer
,	O
"B12"	pointer
,	O
"B11"	pointer
,	O
"B10"	pointer
,	O
"B3"	pointer
,	O
"A14"	pointer
,	O
"A13"	pointer
,	O
"A12"	pointer
,	O
"A11"	pointer
,	O
"A10"	pointer
,	O
"[invalid reg 13]"	pointer
,	O
"[invalid reg 14]"	pointer
,	O
"[invalid reg 15]"	pointer
}	O
;	O
static	O
void	O
decode_tic6x_unwind_regmask	function
(	O
unsigned	O
int	O
mask	int
)	O
{	O
int	O
i	pointer
;	O
for	O
(	O
i	pointer
=	O
12	int
;	O
mask	int
;	O
mask	int
>>=	O
1	int
,	O
i	pointer
--	O
)	O
{	O
if	O
(	O
mask	int
&	O
1	int
)	O
{	O
fputs	function
(	O
tic6x_unwind_regnames	array
[	O
i	pointer
]	O
,	O
stdout	pointer
)	O
;	O
if	O
(	O
mask	int
>	O
1	int
)	O
fputs	function
(	O
", "	pointer
,	O
stdout	pointer
)	O
;	O
}	O
}	O
}	O
static	O
bfd_boolean	int
decode_arm_unwind_bytecode	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
struct	O
arm_unw_aux_info	struct
*	O
aux	pointer
,	O
unsigned	O
int	O
word	int
,	O
unsigned	O
int	O
remaining	int
,	O
unsigned	O
int	O
more_words	int
,	O
bfd_vma	long
data_offset	long
,	O
Elf_Internal_Shdr	struct
*	O
data_sec	pointer
,	O
struct	O
arm_section	struct
*	O
data_arm_sec	pointer
)	O
{	O
struct	O
absaddr	struct
addr	pointer
;	O
bfd_boolean	int
res	int
=	O
TRUE	int
;	O
while	O
(	O
1	int
)	O
{	O
unsigned	O
int	O
op	int
,	O
op2	int
;	O
ADVANCE	O
;	O
if	O
(	O
remaining	int
==	O
0	int
)	O
break	O
;	O
remaining	int
--	O
;	O
op	int
=	O
word	int
>>	O
24	int
;	O
word	int
<<=	O
8	int
;	O
printf	function
(	O
"  0x%02x "	pointer
,	O
op	int
)	O
;	O
if	O
(	O
(	O
op	int
&	O
0xc0	int
)	O
==	O
0x00	int
)	O
{	O
int	O
offset	long
=	O
(	O
(	O
op	int
&	O
0x3f	int
)	O
<<	O
2	int
)	O
+	O
4	int
;	O
printf	function
(	O
"     vsp = vsp + %d"	pointer
,	O
offset	long
)	O
;	O
}	O
else	O
if	O
(	O
(	O
op	int
&	O
0xc0	int
)	O
==	O
0x40	int
)	O
{	O
int	O
offset	long
=	O
(	O
(	O
op	int
&	O
0x3f	int
)	O
<<	O
2	int
)	O
+	O
4	int
;	O
printf	function
(	O
"     vsp = vsp - %d"	pointer
,	O
offset	long
)	O
;	O
}	O
else	O
if	O
(	O
(	O
op	int
&	O
0xf0	int
)	O
==	O
0x80	int
)	O
{	O
GET_OP	O
(	O
op2	int
)	O
;	O
if	O
(	O
op	int
==	O
0x80	int
&&	O
op2	int
==	O
0	int
)	O
printf	function
(	O
_	O
(	O
"Refuse to unwind"	pointer
)	O
)	O
;	O
else	O
{	O
unsigned	O
int	O
mask	int
=	O
(	O
(	O
op	int
&	O
0x0f	int
)	O
<<	O
8	int
)	O
|	O
op2	int
;	O
bfd_boolean	int
first	int
=	O
TRUE	int
;	O
int	O
i	pointer
;	O
printf	function
(	O
"pop {"	pointer
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
12	int
;	O
i	pointer
++	O
)	O
if	O
(	O
mask	int
&	O
(	O
1	int
<<	O
i	pointer
)	O
)	O
{	O
if	O
(	O
first	int
)	O
first	int
=	O
FALSE	int
;	O
else	O
printf	function
(	O
", "	pointer
)	O
;	O
printf	function
(	O
"r%d"	pointer
,	O
4	int
+	O
i	pointer
)	O
;	O
}	O
printf	function
(	O
"}"	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
(	O
op	int
&	O
0xf0	int
)	O
==	O
0x90	int
)	O
{	O
if	O
(	O
op	int
==	O
0x9d	int
||	O
op	int
==	O
0x9f	int
)	O
printf	function
(	O
_	O
(	O
"     [Reserved]"	pointer
)	O
)	O
;	O
else	O
printf	function
(	O
"     vsp = r%d"	pointer
,	O
op	int
&	O
0x0f	int
)	O
;	O
}	O
else	O
if	O
(	O
(	O
op	int
&	O
0xf0	int
)	O
==	O
0xa0	int
)	O
{	O
int	O
end	pointer
=	O
4	int
+	O
(	O
op	int
&	O
0x07	int
)	O
;	O
bfd_boolean	int
first	int
=	O
TRUE	int
;	O
int	O
i	pointer
;	O
printf	function
(	O
"     pop {"	pointer
)	O
;	O
for	O
(	O
i	pointer
=	O
4	int
;	O
i	pointer
<=	O
end	pointer
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
first	int
)	O
first	int
=	O
FALSE	int
;	O
else	O
printf	function
(	O
", "	pointer
)	O
;	O
printf	function
(	O
"r%d"	pointer
,	O
i	pointer
)	O
;	O
}	O
if	O
(	O
op	int
&	O
0x08	int
)	O
{	O
if	O
(	O
!	O
first	int
)	O
printf	function
(	O
", "	pointer
)	O
;	O
printf	function
(	O
"r14"	pointer
)	O
;	O
}	O
printf	function
(	O
"}"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
op	int
==	O
0xb0	int
)	O
printf	function
(	O
_	O
(	O
"     finish"	pointer
)	O
)	O
;	O
else	O
if	O
(	O
op	int
==	O
0xb1	int
)	O
{	O
GET_OP	O
(	O
op2	int
)	O
;	O
if	O
(	O
op2	int
==	O
0	int
||	O
(	O
op2	int
&	O
0xf0	int
)	O
!=	O
0	int
)	O
printf	function
(	O
_	O
(	O
"[Spare]"	pointer
)	O
)	O
;	O
else	O
{	O
unsigned	O
int	O
mask	int
=	O
op2	int
&	O
0x0f	int
;	O
bfd_boolean	int
first	int
=	O
TRUE	int
;	O
int	O
i	pointer
;	O
printf	function
(	O
"pop {"	pointer
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
12	int
;	O
i	pointer
++	O
)	O
if	O
(	O
mask	int
&	O
(	O
1	int
<<	O
i	pointer
)	O
)	O
{	O
if	O
(	O
first	int
)	O
first	int
=	O
FALSE	int
;	O
else	O
printf	function
(	O
", "	pointer
)	O
;	O
printf	function
(	O
"r%d"	pointer
,	O
i	pointer
)	O
;	O
}	O
printf	function
(	O
"}"	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
op	int
==	O
0xb2	int
)	O
{	O
unsigned	O
char	O
buf	pointer
[	O
9	int
]	O
;	O
unsigned	O
int	O
i	pointer
,	O
len	int
;	O
unsigned	O
long	O
offset	long
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
sizeof	O
(	O
buf	pointer
)	O
;	O
i	pointer
++	O
)	O
{	O
GET_OP	O
(	O
buf	pointer
[	O
i	pointer
]	O
)	O
;	O
if	O
(	O
(	O
buf	pointer
[	O
i	pointer
]	O
&	O
0x80	int
)	O
==	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
i	pointer
==	O
sizeof	O
(	O
buf	pointer
)	O
)	O
{	O
error	function
(	O
_	O
(	O
"corrupt change to vsp"	pointer
)	O
)	O
;	O
res	int
=	O
FALSE	int
;	O
}	O
else	O
{	O
offset	long
=	O
read_leb128	function
(	O
buf	pointer
,	O
buf	pointer
+	O
i	pointer
+	O
1	int
,	O
FALSE	int
,	O
&	O
len	int
,	O
NULL	O
)	O
;	O
assert	O
(	O
len	int
==	O
i	pointer
+	O
1	int
)	O
;	O
offset	long
=	O
offset	long
*	O
4	int
+	O
0x204	int
;	O
printf	function
(	O
"vsp = vsp + %ld"	pointer
,	O
offset	long
)	O
;	O
}	O
}	O
else	O
if	O
(	O
op	int
==	O
0xb3	int
||	O
op	int
==	O
0xc8	int
||	O
op	int
==	O
0xc9	int
)	O
{	O
unsigned	O
int	O
first	int
,	O
last	int
;	O
GET_OP	O
(	O
op2	int
)	O
;	O
first	int
=	O
op2	int
>>	O
4	int
;	O
last	int
=	O
op2	int
&	O
0x0f	int
;	O
if	O
(	O
op	int
==	O
0xc8	int
)	O
first	int
=	O
first	int
+	O
16	int
;	O
printf	function
(	O
"pop {D%d"	pointer
,	O
first	int
)	O
;	O
if	O
(	O
last	int
)	O
printf	function
(	O
"-D%d"	pointer
,	O
first	int
+	O
last	int
)	O
;	O
printf	function
(	O
"}"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
(	O
op	int
&	O
0xf8	int
)	O
==	O
0xb8	int
||	O
(	O
op	int
&	O
0xf8	int
)	O
==	O
0xd0	int
)	O
{	O
unsigned	O
int	O
count	int
=	O
op	int
&	O
0x07	int
;	O
printf	function
(	O
"pop {D8"	pointer
)	O
;	O
if	O
(	O
count	int
)	O
printf	function
(	O
"-D%d"	pointer
,	O
8	int
+	O
count	int
)	O
;	O
printf	function
(	O
"}"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
op	int
>=	O
0xc0	int
&&	O
op	int
<=	O
0xc5	int
)	O
{	O
unsigned	O
int	O
count	int
=	O
op	int
&	O
0x07	int
;	O
printf	function
(	O
"     pop {wR10"	pointer
)	O
;	O
if	O
(	O
count	int
)	O
printf	function
(	O
"-wR%d"	pointer
,	O
10	int
+	O
count	int
)	O
;	O
printf	function
(	O
"}"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
op	int
==	O
0xc6	int
)	O
{	O
unsigned	O
int	O
first	int
,	O
last	int
;	O
GET_OP	O
(	O
op2	int
)	O
;	O
first	int
=	O
op2	int
>>	O
4	int
;	O
last	int
=	O
op2	int
&	O
0x0f	int
;	O
printf	function
(	O
"pop {wR%d"	pointer
,	O
first	int
)	O
;	O
if	O
(	O
last	int
)	O
printf	function
(	O
"-wR%d"	pointer
,	O
first	int
+	O
last	int
)	O
;	O
printf	function
(	O
"}"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
op	int
==	O
0xc7	int
)	O
{	O
GET_OP	O
(	O
op2	int
)	O
;	O
if	O
(	O
op2	int
==	O
0	int
||	O
(	O
op2	int
&	O
0xf0	int
)	O
!=	O
0	int
)	O
printf	function
(	O
_	O
(	O
"[Spare]"	pointer
)	O
)	O
;	O
else	O
{	O
unsigned	O
int	O
mask	int
=	O
op2	int
&	O
0x0f	int
;	O
bfd_boolean	int
first	int
=	O
TRUE	int
;	O
int	O
i	pointer
;	O
printf	function
(	O
"pop {"	pointer
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
4	int
;	O
i	pointer
++	O
)	O
if	O
(	O
mask	int
&	O
(	O
1	int
<<	O
i	pointer
)	O
)	O
{	O
if	O
(	O
first	int
)	O
first	int
=	O
FALSE	int
;	O
else	O
printf	function
(	O
", "	pointer
)	O
;	O
printf	function
(	O
"wCGR%d"	pointer
,	O
i	pointer
)	O
;	O
}	O
printf	function
(	O
"}"	pointer
)	O
;	O
}	O
}	O
else	O
{	O
printf	function
(	O
_	O
(	O
"     [unsupported opcode]"	pointer
)	O
)	O
;	O
res	int
=	O
FALSE	int
;	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
return	O
res	int
;	O
}	O
static	O
bfd_boolean	int
decode_tic6x_unwind_bytecode	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
struct	O
arm_unw_aux_info	struct
*	O
aux	pointer
,	O
unsigned	O
int	O
word	int
,	O
unsigned	O
int	O
remaining	int
,	O
unsigned	O
int	O
more_words	int
,	O
bfd_vma	long
data_offset	long
,	O
Elf_Internal_Shdr	struct
*	O
data_sec	pointer
,	O
struct	O
arm_section	struct
*	O
data_arm_sec	pointer
)	O
{	O
struct	O
absaddr	struct
addr	pointer
;	O
while	O
(	O
1	int
)	O
{	O
unsigned	O
int	O
op	int
,	O
op2	int
;	O
ADVANCE	O
;	O
if	O
(	O
remaining	int
==	O
0	int
)	O
break	O
;	O
remaining	int
--	O
;	O
op	int
=	O
word	int
>>	O
24	int
;	O
word	int
<<=	O
8	int
;	O
printf	function
(	O
"  0x%02x "	pointer
,	O
op	int
)	O
;	O
if	O
(	O
(	O
op	int
&	O
0xc0	int
)	O
==	O
0x00	int
)	O
{	O
int	O
offset	long
=	O
(	O
(	O
op	int
&	O
0x3f	int
)	O
<<	O
3	int
)	O
+	O
8	int
;	O
printf	function
(	O
"     sp = sp + %d"	pointer
,	O
offset	long
)	O
;	O
}	O
else	O
if	O
(	O
(	O
op	int
&	O
0xc0	int
)	O
==	O
0x80	int
)	O
{	O
GET_OP	O
(	O
op2	int
)	O
;	O
if	O
(	O
op	int
==	O
0x80	int
&&	O
op2	int
==	O
0	int
)	O
printf	function
(	O
_	O
(	O
"Refuse to unwind"	pointer
)	O
)	O
;	O
else	O
{	O
unsigned	O
int	O
mask	int
=	O
(	O
(	O
op	int
&	O
0x1f	int
)	O
<<	O
8	int
)	O
|	O
op2	int
;	O
if	O
(	O
op	int
&	O
0x20	int
)	O
printf	function
(	O
"pop compact {"	pointer
)	O
;	O
else	O
printf	function
(	O
"pop {"	pointer
)	O
;	O
decode_tic6x_unwind_regmask	function
(	O
mask	int
)	O
;	O
printf	function
(	O
"}"	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
(	O
op	int
&	O
0xf0	int
)	O
==	O
0xc0	int
)	O
{	O
unsigned	O
int	O
reg	int
;	O
unsigned	O
int	O
nregs	int
;	O
unsigned	O
int	O
i	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
struct	O
{	O
unsigned	O
int	O
offset	long
;	O
unsigned	O
int	O
reg	int
;	O
}	O
regpos	array
[	O
16	int
]	O
;	O
nregs	int
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
nregs	int
<	O
(	O
op	int
&	O
0xf	int
)	O
;	O
i	pointer
++	O
)	O
{	O
GET_OP	O
(	O
op2	int
)	O
;	O
reg	int
=	O
op2	int
>>	O
4	int
;	O
if	O
(	O
reg	int
!=	O
0xf	int
)	O
{	O
regpos	array
[	O
nregs	int
]	O
.	O
offset	long
=	O
i	pointer
*	O
2	int
;	O
regpos	array
[	O
nregs	int
]	O
.	O
reg	int
=	O
reg	int
;	O
nregs	int
++	O
;	O
}	O
reg	int
=	O
op2	int
&	O
0xf	int
;	O
if	O
(	O
reg	int
!=	O
0xf	int
)	O
{	O
regpos	array
[	O
nregs	int
]	O
.	O
offset	long
=	O
i	pointer
*	O
2	int
+	O
1	int
;	O
regpos	array
[	O
nregs	int
]	O
.	O
reg	int
=	O
reg	int
;	O
nregs	int
++	O
;	O
}	O
}	O
printf	function
(	O
_	O
(	O
"pop frame {"	pointer
)	O
)	O
;	O
if	O
(	O
nregs	int
==	O
0	int
)	O
{	O
printf	function
(	O
_	O
(	O
"*corrupt* - no registers specified"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
reg	int
=	O
nregs	int
-	O
1	int
;	O
for	O
(	O
i	pointer
=	O
i	pointer
*	O
2	int
;	O
i	pointer
>	O
0	int
;	O
i	pointer
--	O
)	O
{	O
if	O
(	O
regpos	array
[	O
reg	int
]	O
.	O
offset	long
==	O
i	pointer
-	O
1	int
)	O
{	O
name	pointer
=	O
tic6x_unwind_regnames	array
[	O
regpos	array
[	O
reg	int
]	O
.	O
reg	int
]	O
;	O
if	O
(	O
reg	int
>	O
0	int
)	O
reg	int
--	O
;	O
}	O
else	O
name	pointer
=	O
_	O
(	O
"[pad]"	pointer
)	O
;	O
fputs	function
(	O
name	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
i	pointer
>	O
1	int
)	O
printf	function
(	O
", "	pointer
)	O
;	O
}	O
}	O
printf	function
(	O
"}"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
op	int
==	O
0xd0	int
)	O
printf	function
(	O
"     MOV FP, SP"	pointer
)	O
;	O
else	O
if	O
(	O
op	int
==	O
0xd1	int
)	O
printf	function
(	O
"     __c6xabi_pop_rts"	pointer
)	O
;	O
else	O
if	O
(	O
op	int
==	O
0xd2	int
)	O
{	O
unsigned	O
char	O
buf	pointer
[	O
9	int
]	O
;	O
unsigned	O
int	O
i	pointer
,	O
len	int
;	O
unsigned	O
long	O
offset	long
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
sizeof	O
(	O
buf	pointer
)	O
;	O
i	pointer
++	O
)	O
{	O
GET_OP	O
(	O
buf	pointer
[	O
i	pointer
]	O
)	O
;	O
if	O
(	O
(	O
buf	pointer
[	O
i	pointer
]	O
&	O
0x80	int
)	O
==	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
i	pointer
==	O
sizeof	O
(	O
buf	pointer
)	O
)	O
{	O
warn	function
(	O
_	O
(	O
"Corrupt stack pointer adjustment detected\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
offset	long
=	O
read_leb128	function
(	O
buf	pointer
,	O
buf	pointer
+	O
i	pointer
+	O
1	int
,	O
FALSE	int
,	O
&	O
len	int
,	O
NULL	O
)	O
;	O
assert	O
(	O
len	int
==	O
i	pointer
+	O
1	int
)	O
;	O
offset	long
=	O
offset	long
*	O
8	int
+	O
0x408	int
;	O
printf	function
(	O
_	O
(	O
"sp = sp + %ld"	pointer
)	O
,	O
offset	long
)	O
;	O
}	O
else	O
if	O
(	O
(	O
op	int
&	O
0xf0	int
)	O
==	O
0xe0	int
)	O
{	O
if	O
(	O
(	O
op	int
&	O
0x0f	int
)	O
==	O
7	int
)	O
printf	function
(	O
"     RETURN"	pointer
)	O
;	O
else	O
printf	function
(	O
"     MV %s, B3"	pointer
,	O
tic6x_unwind_regnames	array
[	O
op	int
&	O
0x0f	int
]	O
)	O
;	O
}	O
else	O
{	O
printf	function
(	O
_	O
(	O
"     [unsupported opcode]"	pointer
)	O
)	O
;	O
}	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_vma	long
arm_expand_prel31	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
bfd_vma	long
word	int
,	O
bfd_vma	long
where	long
)	O
{	O
bfd_vma	long
offset	long
;	O
offset	long
=	O
word	int
&	O
0x7fffffff	int
;	O
if	O
(	O
offset	long
&	O
0x40000000	int
)	O
offset	long
|=	O
~	O
(	O
bfd_vma	long
)	O
0x7fffffff	int
;	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_TI_C6000	int
)	O
offset	long
<<=	O
1	int
;	O
return	O
offset	long
+	O
where	long
;	O
}	O
static	O
bfd_boolean	int
decode_arm_unwind	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
struct	O
arm_unw_aux_info	struct
*	O
aux	pointer
,	O
unsigned	O
int	O
word	int
,	O
unsigned	O
int	O
remaining	int
,	O
bfd_vma	long
data_offset	long
,	O
Elf_Internal_Shdr	struct
*	O
data_sec	pointer
,	O
struct	O
arm_section	struct
*	O
data_arm_sec	pointer
)	O
{	O
int	O
per_index	int
;	O
unsigned	O
int	O
more_words	int
=	O
0	int
;	O
struct	O
absaddr	struct
addr	pointer
;	O
bfd_vma	long
sym_name	pointer
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
bfd_boolean	int
res	int
=	O
TRUE	int
;	O
if	O
(	O
remaining	int
==	O
0	int
)	O
{	O
if	O
(	O
!	O
get_unwind_section_word	function
(	O
filedata	struct
,	O
aux	pointer
,	O
data_arm_sec	pointer
,	O
data_sec	pointer
,	O
data_offset	long
,	O
&	O
word	int
,	O
&	O
addr	pointer
,	O
&	O
sym_name	pointer
)	O
)	O
return	O
FALSE	int
;	O
remaining	int
=	O
4	int
;	O
}	O
else	O
{	O
addr	pointer
.	O
section	pointer
=	O
SHN_UNDEF	int
;	O
addr	pointer
.	O
offset	long
=	O
0	int
;	O
}	O
if	O
(	O
(	O
word	int
&	O
0x80000000	int
)	O
==	O
0	int
)	O
{	O
bfd_vma	long
fn	pointer
;	O
const	O
char	O
*	O
procname	pointer
;	O
fn	pointer
=	O
arm_expand_prel31	function
(	O
filedata	struct
,	O
word	int
,	O
data_sec	pointer
->	O
sh_addr	array
+	O
data_offset	long
)	O
;	O
printf	function
(	O
_	O
(	O
"  Personality routine: "	pointer
)	O
)	O
;	O
if	O
(	O
fn	pointer
==	O
0	int
&&	O
addr	pointer
.	O
section	pointer
==	O
SHN_UNDEF	int
&&	O
addr	pointer
.	O
offset	long
==	O
0	int
&&	O
sym_name	pointer
!=	O
(	O
bfd_vma	long
)	O
-	O
1	int
&&	O
sym_name	pointer
<	O
aux	pointer
->	O
strtab_size	long
)	O
{	O
procname	pointer
=	O
aux	pointer
->	O
strtab	pointer
+	O
sym_name	pointer
;	O
print_vma	function
(	O
fn	pointer
,	O
PREFIX_HEX	int
)	O
;	O
if	O
(	O
procname	pointer
)	O
{	O
fputs	function
(	O
" <"	pointer
,	O
stdout	pointer
)	O
;	O
fputs	function
(	O
procname	pointer
,	O
stdout	pointer
)	O
;	O
fputc	function
(	O
'>'	O
,	O
stdout	pointer
)	O
;	O
}	O
}	O
else	O
procname	pointer
=	O
arm_print_vma_and_name	function
(	O
filedata	struct
,	O
aux	pointer
,	O
fn	pointer
,	O
addr	pointer
)	O
;	O
fputc	function
(	O
'\n'	O
,	O
stdout	pointer
)	O
;	O
if	O
(	O
procname	pointer
!=	O
NULL	O
&&	O
(	O
const_strneq	O
(	O
procname	pointer
,	O
"__gcc_personality_v0"	pointer
)	O
||	O
const_strneq	O
(	O
procname	pointer
,	O
"__gxx_personality_v0"	pointer
)	O
||	O
const_strneq	O
(	O
procname	pointer
,	O
"__gcj_personality_v0"	pointer
)	O
||	O
const_strneq	O
(	O
procname	pointer
,	O
"__gnu_objc_personality_v0"	pointer
)	O
)	O
)	O
{	O
remaining	int
=	O
0	int
;	O
more_words	int
=	O
1	int
;	O
ADVANCE	O
;	O
if	O
(	O
!	O
remaining	int
)	O
{	O
printf	function
(	O
_	O
(	O
"  [Truncated data]\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
more_words	int
=	O
word	int
>>	O
24	int
;	O
word	int
<<=	O
8	int
;	O
remaining	int
--	O
;	O
per_index	int
=	O
-	O
1	int
;	O
}	O
else	O
return	O
TRUE	int
;	O
}	O
else	O
{	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_ARM	int
&&	O
(	O
word	int
&	O
0x70000000	int
)	O
)	O
{	O
warn	function
(	O
_	O
(	O
"Corrupt ARM compact model table entry: %x \n"	pointer
)	O
,	O
word	int
)	O
;	O
res	int
=	O
FALSE	int
;	O
}	O
per_index	int
=	O
(	O
word	int
>>	O
24	int
)	O
&	O
0x7f	int
;	O
printf	function
(	O
_	O
(	O
"  Compact model index: %d\n"	pointer
)	O
,	O
per_index	int
)	O
;	O
if	O
(	O
per_index	int
==	O
0	int
)	O
{	O
more_words	int
=	O
0	int
;	O
word	int
<<=	O
8	int
;	O
remaining	int
--	O
;	O
}	O
else	O
if	O
(	O
per_index	int
<	O
3	int
)	O
{	O
more_words	int
=	O
(	O
word	int
>>	O
16	int
)	O
&	O
0xff	int
;	O
word	int
<<=	O
16	int
;	O
remaining	int
-=	O
2	int
;	O
}	O
}	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
case	O
EM_ARM	int
:	O
if	O
(	O
per_index	int
<	O
3	int
)	O
{	O
if	O
(	O
!	O
decode_arm_unwind_bytecode	function
(	O
filedata	struct
,	O
aux	pointer
,	O
word	int
,	O
remaining	int
,	O
more_words	int
,	O
data_offset	long
,	O
data_sec	pointer
,	O
data_arm_sec	pointer
)	O
)	O
res	int
=	O
FALSE	int
;	O
}	O
else	O
{	O
warn	function
(	O
_	O
(	O
"Unknown ARM compact model index encountered\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  [reserved]\n"	pointer
)	O
)	O
;	O
res	int
=	O
FALSE	int
;	O
}	O
break	O
;	O
case	O
EM_TI_C6000	int
:	O
if	O
(	O
per_index	int
<	O
3	int
)	O
{	O
if	O
(	O
!	O
decode_tic6x_unwind_bytecode	function
(	O
filedata	struct
,	O
aux	pointer
,	O
word	int
,	O
remaining	int
,	O
more_words	int
,	O
data_offset	long
,	O
data_sec	pointer
,	O
data_arm_sec	pointer
)	O
)	O
res	int
=	O
FALSE	int
;	O
}	O
else	O
if	O
(	O
per_index	int
<	O
5	int
)	O
{	O
if	O
(	O
(	O
(	O
word	int
>>	O
17	int
)	O
&	O
0x7f	int
)	O
==	O
0x7f	int
)	O
printf	function
(	O
_	O
(	O
"  Restore stack from frame pointer\n"	pointer
)	O
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"  Stack increment %d\n"	pointer
)	O
,	O
(	O
word	int
>>	O
14	int
)	O
&	O
0x1fc	int
)	O
;	O
printf	function
(	O
_	O
(	O
"  Registers restored: "	pointer
)	O
)	O
;	O
if	O
(	O
per_index	int
==	O
4	int
)	O
printf	function
(	O
" (compact) "	pointer
)	O
;	O
decode_tic6x_unwind_regmask	function
(	O
(	O
word	int
>>	O
4	int
)	O
&	O
0x1fff	int
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  Return register: %s\n"	pointer
)	O
,	O
tic6x_unwind_regnames	array
[	O
word	int
&	O
0xf	int
]	O
)	O
;	O
}	O
else	O
printf	function
(	O
_	O
(	O
"  [reserved (%d)]\n"	pointer
)	O
,	O
per_index	int
)	O
;	O
break	O
;	O
default	O
:	O
error	function
(	O
_	O
(	O
"Unsupported architecture type %d encountered when decoding unwind table\n"	pointer
)	O
,	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
;	O
res	int
=	O
FALSE	int
;	O
}	O
return	O
res	int
;	O
}	O
static	O
bfd_boolean	int
dump_arm_unwind	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
struct	O
arm_unw_aux_info	struct
*	O
aux	pointer
,	O
Elf_Internal_Shdr	struct
*	O
exidx_sec	pointer
)	O
{	O
struct	O
arm_section	struct
exidx_arm_sec	struct
,	O
extab_arm_sec	struct
;	O
unsigned	O
int	O
i	pointer
,	O
exidx_len	int
;	O
unsigned	O
long	O
j	int
,	O
nfuns	long
;	O
bfd_boolean	int
res	int
=	O
TRUE	int
;	O
memset	function
(	O
&	O
exidx_arm_sec	struct
,	O
0	int
,	O
sizeof	O
(	O
exidx_arm_sec	struct
)	O
)	O
;	O
memset	function
(	O
&	O
extab_arm_sec	struct
,	O
0	int
,	O
sizeof	O
(	O
extab_arm_sec	struct
)	O
)	O
;	O
exidx_len	int
=	O
exidx_sec	pointer
->	O
sh_size	array
/	O
8	int
;	O
aux	pointer
->	O
funtab	pointer
=	O
xmalloc	function
(	O
aux	pointer
->	O
nsyms	long
*	O
sizeof	O
(	O
Elf_Internal_Sym	struct
)	O
)	O
;	O
for	O
(	O
nfuns	long
=	O
0	int
,	O
j	int
=	O
0	int
;	O
j	int
<	O
aux	pointer
->	O
nsyms	long
;	O
j	int
++	O
)	O
if	O
(	O
aux	pointer
->	O
symtab	pointer
[	O
j	int
]	O
.	O
st_value	int
&&	O
ELF_ST_TYPE	O
(	O
aux	pointer
->	O
symtab	pointer
[	O
j	int
]	O
.	O
st_info	array
)	O
==	O
STT_FUNC	int
)	O
aux	pointer
->	O
funtab	pointer
[	O
nfuns	long
++	O
]	O
=	O
aux	pointer
->	O
symtab	pointer
[	O
j	int
]	O
;	O
aux	pointer
->	O
nfuns	long
=	O
nfuns	long
;	O
qsort	function
(	O
aux	pointer
->	O
funtab	pointer
,	O
aux	pointer
->	O
nfuns	long
,	O
sizeof	O
(	O
Elf_Internal_Sym	struct
)	O
,	O
symcmp	function
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
exidx_len	int
;	O
i	pointer
++	O
)	O
{	O
unsigned	O
int	O
exidx_fn	int
,	O
exidx_entry	int
;	O
struct	O
absaddr	struct
fn_addr	struct
,	O
entry_addr	struct
;	O
bfd_vma	long
fn	pointer
;	O
fputc	function
(	O
'\n'	O
,	O
stdout	pointer
)	O
;	O
if	O
(	O
!	O
get_unwind_section_word	function
(	O
filedata	struct
,	O
aux	pointer
,	O
&	O
exidx_arm_sec	struct
,	O
exidx_sec	pointer
,	O
8	int
*	O
i	pointer
,	O
&	O
exidx_fn	int
,	O
&	O
fn_addr	struct
,	O
NULL	O
)	O
||	O
!	O
get_unwind_section_word	function
(	O
filedata	struct
,	O
aux	pointer
,	O
&	O
exidx_arm_sec	struct
,	O
exidx_sec	pointer
,	O
8	int
*	O
i	pointer
+	O
4	int
,	O
&	O
exidx_entry	int
,	O
&	O
entry_addr	struct
,	O
NULL	O
)	O
)	O
{	O
free	function
(	O
aux	pointer
->	O
funtab	pointer
)	O
;	O
arm_free_section	function
(	O
&	O
exidx_arm_sec	struct
)	O
;	O
arm_free_section	function
(	O
&	O
extab_arm_sec	struct
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
exidx_fn	int
&	O
0x80000000	int
)	O
{	O
warn	function
(	O
_	O
(	O
"corrupt index table entry: %x\n"	pointer
)	O
,	O
exidx_fn	int
)	O
;	O
res	int
=	O
FALSE	int
;	O
}	O
fn	pointer
=	O
arm_expand_prel31	function
(	O
filedata	struct
,	O
exidx_fn	int
,	O
exidx_sec	pointer
->	O
sh_addr	array
+	O
8	int
*	O
i	pointer
)	O
;	O
arm_print_vma_and_name	function
(	O
filedata	struct
,	O
aux	pointer
,	O
fn	pointer
,	O
fn_addr	struct
)	O
;	O
fputs	function
(	O
": "	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
exidx_entry	int
==	O
1	int
)	O
{	O
print_vma	function
(	O
exidx_entry	int
,	O
PREFIX_HEX	int
)	O
;	O
fputs	function
(	O
" [cantunwind]\n"	pointer
,	O
stdout	pointer
)	O
;	O
}	O
else	O
if	O
(	O
exidx_entry	int
&	O
0x80000000	int
)	O
{	O
print_vma	function
(	O
exidx_entry	int
,	O
PREFIX_HEX	int
)	O
;	O
fputc	function
(	O
'\n'	O
,	O
stdout	pointer
)	O
;	O
decode_arm_unwind	function
(	O
filedata	struct
,	O
aux	pointer
,	O
exidx_entry	int
,	O
4	int
,	O
0	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
bfd_vma	long
table	pointer
,	O
table_offset	long
=	O
0	int
;	O
Elf_Internal_Shdr	struct
*	O
table_sec	pointer
;	O
fputs	function
(	O
"@"	pointer
,	O
stdout	pointer
)	O
;	O
table	pointer
=	O
arm_expand_prel31	function
(	O
filedata	struct
,	O
exidx_entry	int
,	O
exidx_sec	pointer
->	O
sh_addr	array
+	O
8	int
*	O
i	pointer
+	O
4	int
)	O
;	O
print_vma	function
(	O
table	pointer
,	O
PREFIX_HEX	int
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
if	O
(	O
entry_addr	struct
.	O
section	pointer
!=	O
SHN_UNDEF	int
&&	O
entry_addr	struct
.	O
section	pointer
<	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
)	O
{	O
table_sec	pointer
=	O
filedata	struct
->	O
section_headers	pointer
+	O
entry_addr	struct
.	O
section	pointer
;	O
table_offset	long
=	O
entry_addr	struct
.	O
offset	long
;	O
if	O
(	O
table_offset	long
>	O
table_sec	pointer
->	O
sh_size	array
||	O
(	O
(	O
bfd_signed_vma	long
)	O
table_offset	long
)	O
<	O
0	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Unwind entry contains corrupt offset (0x%lx) into section %s\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
table_offset	long
,	O
printable_section_name	function
(	O
filedata	struct
,	O
table_sec	pointer
)	O
)	O
;	O
res	int
=	O
FALSE	int
;	O
continue	O
;	O
}	O
}	O
else	O
{	O
table_sec	pointer
=	O
find_section_by_address	function
(	O
filedata	struct
,	O
table	pointer
)	O
;	O
if	O
(	O
table_sec	pointer
!=	O
NULL	O
)	O
table_offset	long
=	O
table	pointer
-	O
table_sec	pointer
->	O
sh_addr	array
;	O
}	O
if	O
(	O
table_sec	pointer
==	O
NULL	O
)	O
{	O
warn	function
(	O
_	O
(	O
"Could not locate .ARM.extab section containing 0x%lx.\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
table	pointer
)	O
;	O
res	int
=	O
FALSE	int
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
decode_arm_unwind	function
(	O
filedata	struct
,	O
aux	pointer
,	O
0	int
,	O
0	int
,	O
table_offset	long
,	O
table_sec	pointer
,	O
&	O
extab_arm_sec	struct
)	O
)	O
res	int
=	O
FALSE	int
;	O
}	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
free	function
(	O
aux	pointer
->	O
funtab	pointer
)	O
;	O
arm_free_section	function
(	O
&	O
exidx_arm_sec	struct
)	O
;	O
arm_free_section	function
(	O
&	O
extab_arm_sec	struct
)	O
;	O
return	O
res	int
;	O
}	O
static	O
bfd_boolean	int
arm_process_unwind	function
(	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
struct	O
arm_unw_aux_info	struct
aux	pointer
;	O
Elf_Internal_Shdr	struct
*	O
unwsec	pointer
=	O
NULL	O
;	O
Elf_Internal_Shdr	struct
*	O
strsec	pointer
;	O
Elf_Internal_Shdr	struct
*	O
sec	pointer
;	O
unsigned	O
long	O
i	pointer
;	O
unsigned	O
int	O
sec_type	int
;	O
bfd_boolean	int
res	int
=	O
TRUE	int
;	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
case	O
EM_ARM	int
:	O
sec_type	int
=	O
SHT_ARM_EXIDX	int
;	O
break	O
;	O
case	O
EM_TI_C6000	int
:	O
sec_type	int
=	O
SHT_C6000_UNWIND	int
;	O
break	O
;	O
default	O
:	O
error	function
(	O
_	O
(	O
"Unsupported architecture type %d encountered when processing unwind table\n"	pointer
)	O
,	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
filedata	struct
->	O
string_table	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
memset	function
(	O
&	O
aux	pointer
,	O
0	int
,	O
sizeof	O
(	O
aux	pointer
)	O
)	O
;	O
aux	pointer
.	O
filedata	struct
=	O
filedata	struct
;	O
for	O
(	O
i	pointer
=	O
0	int
,	O
sec	pointer
=	O
filedata	struct
->	O
section_headers	pointer
;	O
i	pointer
<	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
;	O
++	O
i	pointer
,	O
++	O
sec	pointer
)	O
{	O
if	O
(	O
sec	pointer
->	O
sh_type	array
==	O
SHT_SYMTAB	int
&&	O
sec	pointer
->	O
sh_link	array
<	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
)	O
{	O
aux	pointer
.	O
symtab	pointer
=	O
GET_ELF_SYMBOLS	O
(	O
filedata	struct
,	O
sec	pointer
,	O
&	O
aux	pointer
.	O
nsyms	long
)	O
;	O
strsec	pointer
=	O
filedata	struct
->	O
section_headers	pointer
+	O
sec	pointer
->	O
sh_link	array
;	O
if	O
(	O
aux	pointer
.	O
strtab	pointer
!=	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Multiple string tables found in file.\n"	pointer
)	O
)	O
;	O
free	function
(	O
aux	pointer
.	O
strtab	pointer
)	O
;	O
res	int
=	O
FALSE	int
;	O
}	O
aux	pointer
.	O
strtab	pointer
=	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
strsec	pointer
->	O
sh_offset	array
,	O
1	int
,	O
strsec	pointer
->	O
sh_size	array
,	O
_	O
(	O
"string table"	pointer
)	O
)	O
;	O
aux	pointer
.	O
strtab_size	long
=	O
aux	pointer
.	O
strtab	pointer
!=	O
NULL	O
?	O
strsec	pointer
->	O
sh_size	array
:	O
0	int
;	O
}	O
else	O
if	O
(	O
sec	pointer
->	O
sh_type	array
==	O
sec_type	int
)	O
unwsec	pointer
=	O
sec	pointer
;	O
}	O
if	O
(	O
unwsec	pointer
==	O
NULL	O
)	O
printf	function
(	O
_	O
(	O
"\nThere are no unwind sections in this file.\n"	pointer
)	O
)	O
;	O
else	O
for	O
(	O
i	pointer
=	O
0	int
,	O
sec	pointer
=	O
filedata	struct
->	O
section_headers	pointer
;	O
i	pointer
<	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
;	O
++	O
i	pointer
,	O
++	O
sec	pointer
)	O
{	O
if	O
(	O
sec	pointer
->	O
sh_type	array
==	O
sec_type	int
)	O
{	O
unsigned	O
long	O
num_unwind	long
=	O
sec	pointer
->	O
sh_size	array
/	O
(	O
2	int
*	O
eh_addr_size	int
)	O
;	O
printf	function
(	O
ngettext	function
(	O
"\nUnwind section '%s' at offset 0x%lx "	pointer
"contains %lu entry:\n"	pointer
,	O
"\nUnwind section '%s' at offset 0x%lx "	pointer
"contains %lu entries:\n"	pointer
,	O
num_unwind	long
)	O
,	O
printable_section_name	function
(	O
filedata	struct
,	O
sec	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
sec	pointer
->	O
sh_offset	array
,	O
num_unwind	long
)	O
;	O
if	O
(	O
!	O
dump_arm_unwind	function
(	O
filedata	struct
,	O
&	O
aux	pointer
,	O
sec	pointer
)	O
)	O
res	int
=	O
FALSE	int
;	O
}	O
}	O
if	O
(	O
aux	pointer
.	O
symtab	pointer
)	O
free	function
(	O
aux	pointer
.	O
symtab	pointer
)	O
;	O
if	O
(	O
aux	pointer
.	O
strtab	pointer
)	O
free	function
(	O
(	O
char	O
*	O
)	O
aux	pointer
.	O
strtab	pointer
)	O
;	O
return	O
res	int
;	O
}	O
static	O
bfd_boolean	int
process_unwind	function
(	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
struct	O
unwind_handler	struct
{	O
unsigned	O
int	O
machtype	int
;	O
bfd_boolean	int
(	O
*	O
handler	pointer
)	O
(	O
Filedata	struct
*	O
)	O
;	O
}	O
handlers	array
[	O
]	O
=	O
{	O
{	O
EM_ARM	int
,	O
arm_process_unwind	function
}	O
,	O
{	O
EM_IA_64	int
,	O
ia64_process_unwind	function
}	O
,	O
{	O
EM_PARISC	int
,	O
hppa_process_unwind	function
}	O
,	O
{	O
EM_TI_C6000	int
,	O
arm_process_unwind	function
}	O
,	O
{	O
0	int
,	O
NULL	O
}	O
}	O
;	O
int	O
i	pointer
;	O
if	O
(	O
!	O
do_unwind	int
)	O
return	O
TRUE	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
handlers	array
[	O
i	pointer
]	O
.	O
handler	pointer
!=	O
NULL	O
;	O
i	pointer
++	O
)	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
handlers	array
[	O
i	pointer
]	O
.	O
machtype	int
)	O
return	O
handlers	array
[	O
i	pointer
]	O
.	O
handler	pointer
(	O
filedata	struct
)	O
;	O
printf	function
(	O
_	O
(	O
"\nThe decoding of unwind sections for machine type %s is not currently supported.\n"	pointer
)	O
,	O
get_machine_name	function
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
void	O
dynamic_section_aarch64_val	function
(	O
Elf_Internal_Dyn	struct
*	O
entry	int
)	O
{	O
switch	O
(	O
entry	int
->	O
d_tag	array
)	O
{	O
case	O
DT_AARCH64_BTI_PLT	O
:	O
case	O
DT_AARCH64_PAC_PLT	O
:	O
break	O
;	O
default	O
:	O
print_vma	function
(	O
entry	int
->	O
d_un	union
.	O
d_ptr	array
,	O
PREFIX_HEX	int
)	O
;	O
break	O
;	O
}	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
static	O
void	O
dynamic_section_mips_val	function
(	O
Elf_Internal_Dyn	struct
*	O
entry	int
)	O
{	O
switch	O
(	O
entry	int
->	O
d_tag	array
)	O
{	O
case	O
DT_MIPS_FLAGS	int
:	O
if	O
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
==	O
0	int
)	O
printf	function
(	O
_	O
(	O
"NONE"	pointer
)	O
)	O
;	O
else	O
{	O
static	O
const	O
char	O
*	O
opts	array
[	O
]	O
=	O
{	O
"QUICKSTART"	pointer
,	O
"NOTPOT"	pointer
,	O
"NO_LIBRARY_REPLACEMENT"	pointer
,	O
"NO_MOVE"	pointer
,	O
"SGI_ONLY"	pointer
,	O
"GUARANTEE_INIT"	pointer
,	O
"DELTA_C_PLUS_PLUS"	pointer
,	O
"GUARANTEE_START_INIT"	pointer
,	O
"PIXIE"	pointer
,	O
"DEFAULT_DELAY_LOAD"	pointer
,	O
"REQUICKSTART"	pointer
,	O
"REQUICKSTARTED"	pointer
,	O
"CORD"	pointer
,	O
"NO_UNRES_UNDEF"	pointer
,	O
"RLD_ORDER_SAFE"	pointer
}	O
;	O
unsigned	O
int	O
cnt	int
;	O
bfd_boolean	int
first	int
=	O
TRUE	int
;	O
for	O
(	O
cnt	int
=	O
0	int
;	O
cnt	int
<	O
ARRAY_SIZE	O
(	O
opts	array
)	O
;	O
++	O
cnt	int
)	O
if	O
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
&	O
(	O
1	int
<<	O
cnt	int
)	O
)	O
{	O
printf	function
(	O
"%s%s"	pointer
,	O
first	int
?	O
""	pointer
:	O
" "	pointer
,	O
opts	array
[	O
cnt	int
]	O
)	O
;	O
first	int
=	O
FALSE	int
;	O
}	O
}	O
break	O
;	O
case	O
DT_MIPS_IVERSION	int
:	O
if	O
(	O
VALID_DYNAMIC_NAME	O
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
)	O
)	O
printf	function
(	O
_	O
(	O
"Interface Version: %s"	pointer
)	O
,	O
GET_DYNAMIC_NAME	O
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
)	O
)	O
;	O
else	O
{	O
char	O
buf	pointer
[	O
40	int
]	O
;	O
sprintf_vma	O
(	O
buf	pointer
,	O
entry	int
->	O
d_un	union
.	O
d_ptr	array
)	O
;	O
printf	function
(	O
_	O
(	O
"<corrupt: %s>"	pointer
)	O
,	O
buf	pointer
)	O
;	O
}	O
break	O
;	O
case	O
DT_MIPS_TIME_STAMP	int
:	O
{	O
char	O
timebuf	array
[	O
128	int
]	O
;	O
struct	O
tm	struct
*	O
tmp	pointer
;	O
time_t	long
atime	long
=	O
entry	int
->	O
d_un	union
.	O
d_val	array
;	O
tmp	pointer
=	O
gmtime	function
(	O
&	O
atime	long
)	O
;	O
if	O
(	O
tmp	pointer
==	O
NULL	O
)	O
snprintf	function
(	O
timebuf	array
,	O
sizeof	O
(	O
timebuf	array
)	O
,	O
_	O
(	O
"<corrupt>"	pointer
)	O
)	O
;	O
else	O
snprintf	function
(	O
timebuf	array
,	O
sizeof	O
(	O
timebuf	array
)	O
,	O
"%04u-%02u-%02uT%02u:%02u:%02u"	pointer
,	O
tmp	pointer
->	O
tm_year	int
+	O
1900	int
,	O
tmp	pointer
->	O
tm_mon	int
+	O
1	int
,	O
tmp	pointer
->	O
tm_mday	int
,	O
tmp	pointer
->	O
tm_hour	int
,	O
tmp	pointer
->	O
tm_min	int
,	O
tmp	pointer
->	O
tm_sec	int
)	O
;	O
printf	function
(	O
_	O
(	O
"Time Stamp: %s"	pointer
)	O
,	O
timebuf	array
)	O
;	O
}	O
break	O
;	O
case	O
DT_MIPS_RLD_VERSION	int
:	O
case	O
DT_MIPS_LOCAL_GOTNO	int
:	O
case	O
DT_MIPS_CONFLICTNO	int
:	O
case	O
DT_MIPS_LIBLISTNO	int
:	O
case	O
DT_MIPS_SYMTABNO	int
:	O
case	O
DT_MIPS_UNREFEXTNO	int
:	O
case	O
DT_MIPS_HIPAGENO	int
:	O
case	O
DT_MIPS_DELTA_CLASS_NO	int
:	O
case	O
DT_MIPS_DELTA_INSTANCE_NO	int
:	O
case	O
DT_MIPS_DELTA_RELOC_NO	int
:	O
case	O
DT_MIPS_DELTA_SYM_NO	int
:	O
case	O
DT_MIPS_DELTA_CLASSSYM_NO	int
:	O
case	O
DT_MIPS_COMPACT_SIZE	int
:	O
print_vma	function
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
,	O
DEC	int
)	O
;	O
break	O
;	O
case	O
DT_MIPS_XHASH	int
:	O
dynamic_info_DT_MIPS_XHASH	long
=	O
entry	int
->	O
d_un	union
.	O
d_val	array
;	O
dynamic_info_DT_GNU_HASH	long
=	O
entry	int
->	O
d_un	union
.	O
d_val	array
;	O
default	O
:	O
print_vma	function
(	O
entry	int
->	O
d_un	union
.	O
d_ptr	array
,	O
PREFIX_HEX	int
)	O
;	O
}	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
static	O
void	O
dynamic_section_parisc_val	function
(	O
Elf_Internal_Dyn	struct
*	O
entry	int
)	O
{	O
switch	O
(	O
entry	int
->	O
d_tag	array
)	O
{	O
case	O
DT_HP_DLD_FLAGS	O
:	O
{	O
static	O
struct	O
{	O
long	O
int	O
bit	long
;	O
const	O
char	O
*	O
str	int
;	O
}	O
flags	int
[	O
]	O
=	O
{	O
{	O
DT_HP_DEBUG_PRIVATE	int
,	O
"HP_DEBUG_PRIVATE"	pointer
}	O
,	O
{	O
DT_HP_DEBUG_CALLBACK	int
,	O
"HP_DEBUG_CALLBACK"	pointer
}	O
,	O
{	O
DT_HP_DEBUG_CALLBACK_BOR	int
,	O
"HP_DEBUG_CALLBACK_BOR"	pointer
}	O
,	O
{	O
DT_HP_NO_ENVVAR	int
,	O
"HP_NO_ENVVAR"	pointer
}	O
,	O
{	O
DT_HP_BIND_NOW	int
,	O
"HP_BIND_NOW"	pointer
}	O
,	O
{	O
DT_HP_BIND_NONFATAL	int
,	O
"HP_BIND_NONFATAL"	pointer
}	O
,	O
{	O
DT_HP_BIND_VERBOSE	int
,	O
"HP_BIND_VERBOSE"	pointer
}	O
,	O
{	O
DT_HP_BIND_RESTRICTED	int
,	O
"HP_BIND_RESTRICTED"	pointer
}	O
,	O
{	O
DT_HP_BIND_SYMBOLIC	int
,	O
"HP_BIND_SYMBOLIC"	pointer
}	O
,	O
{	O
DT_HP_RPATH_FIRST	int
,	O
"HP_RPATH_FIRST"	pointer
}	O
,	O
{	O
DT_HP_BIND_DEPTH_FIRST	int
,	O
"HP_BIND_DEPTH_FIRST"	pointer
}	O
,	O
{	O
DT_HP_GST	int
,	O
"HP_GST"	pointer
}	O
,	O
{	O
DT_HP_SHLIB_FIXED	int
,	O
"HP_SHLIB_FIXED"	pointer
}	O
,	O
{	O
DT_HP_MERGE_SHLIB_SEG	int
,	O
"HP_MERGE_SHLIB_SEG"	pointer
}	O
,	O
{	O
DT_HP_NODELETE	int
,	O
"HP_NODELETE"	pointer
}	O
,	O
{	O
DT_HP_GROUP	int
,	O
"HP_GROUP"	pointer
}	O
,	O
{	O
DT_HP_PROTECT_LINKAGE_TABLE	int
,	O
"HP_PROTECT_LINKAGE_TABLE"	pointer
}	O
}	O
;	O
bfd_boolean	int
first	int
=	O
TRUE	int
;	O
size_t	long
cnt	int
;	O
bfd_vma	long
val	array
=	O
entry	int
->	O
d_un	union
.	O
d_val	array
;	O
for	O
(	O
cnt	int
=	O
0	int
;	O
cnt	int
<	O
ARRAY_SIZE	O
(	O
flags	int
)	O
;	O
++	O
cnt	int
)	O
if	O
(	O
val	array
&	O
flags	int
[	O
cnt	int
]	O
.	O
bit	long
)	O
{	O
if	O
(	O
!	O
first	int
)	O
putchar	function
(	O
' '	O
)	O
;	O
fputs	function
(	O
flags	int
[	O
cnt	int
]	O
.	O
str	int
,	O
stdout	pointer
)	O
;	O
first	int
=	O
FALSE	int
;	O
val	array
^=	O
flags	int
[	O
cnt	int
]	O
.	O
bit	long
;	O
}	O
if	O
(	O
val	array
!=	O
0	int
||	O
first	int
)	O
{	O
if	O
(	O
!	O
first	int
)	O
putchar	function
(	O
' '	O
)	O
;	O
print_vma	function
(	O
val	array
,	O
HEX	int
)	O
;	O
}	O
}	O
break	O
;	O
default	O
:	O
print_vma	function
(	O
entry	int
->	O
d_un	union
.	O
d_ptr	array
,	O
PREFIX_HEX	int
)	O
;	O
break	O
;	O
}	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
static	O
void	O
print_vms_time	function
(	O
bfd_int64_t	long
vmstime	long
)	O
{	O
struct	O
tm	struct
*	O
tm	struct
;	O
time_t	long
unxtime	long
;	O
unxtime	long
=	O
(	O
vmstime	long
-	O
VMS_EPOCH_OFFSET	int
)	O
/	O
VMS_GRANULARITY_FACTOR	int
;	O
tm	struct
=	O
gmtime	function
(	O
&	O
unxtime	long
)	O
;	O
printf	function
(	O
"%04u-%02u-%02uT%02u:%02u:%02u"	pointer
,	O
tm	struct
->	O
tm_year	int
+	O
1900	int
,	O
tm	struct
->	O
tm_mon	int
+	O
1	int
,	O
tm	struct
->	O
tm_mday	int
,	O
tm	struct
->	O
tm_hour	int
,	O
tm	struct
->	O
tm_min	int
,	O
tm	struct
->	O
tm_sec	int
)	O
;	O
}	O
static	O
void	O
dynamic_section_ia64_val	function
(	O
Elf_Internal_Dyn	struct
*	O
entry	int
)	O
{	O
switch	O
(	O
entry	int
->	O
d_tag	array
)	O
{	O
case	O
DT_IA_64_PLT_RESERVE	O
:	O
print_vma	function
(	O
entry	int
->	O
d_un	union
.	O
d_ptr	array
,	O
PREFIX_HEX	int
)	O
;	O
printf	function
(	O
" -- "	pointer
)	O
;	O
print_vma	function
(	O
entry	int
->	O
d_un	union
.	O
d_ptr	array
+	O
(	O
3	int
*	O
8	int
)	O
,	O
PREFIX_HEX	int
)	O
;	O
break	O
;	O
case	O
DT_IA_64_VMS_LINKTIME	O
:	O
print_vms_time	function
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
)	O
;	O
break	O
;	O
case	O
DT_IA_64_VMS_LNKFLAGS	O
:	O
print_vma	function
(	O
entry	int
->	O
d_un	union
.	O
d_ptr	array
,	O
PREFIX_HEX	int
)	O
;	O
if	O
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
&	O
VMS_LF_CALL_DEBUG	int
)	O
printf	function
(	O
" CALL_DEBUG"	pointer
)	O
;	O
if	O
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
&	O
VMS_LF_NOP0BUFS	int
)	O
printf	function
(	O
" NOP0BUFS"	pointer
)	O
;	O
if	O
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
&	O
VMS_LF_P0IMAGE	int
)	O
printf	function
(	O
" P0IMAGE"	pointer
)	O
;	O
if	O
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
&	O
VMS_LF_MKTHREADS	int
)	O
printf	function
(	O
" MKTHREADS"	pointer
)	O
;	O
if	O
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
&	O
VMS_LF_UPCALLS	int
)	O
printf	function
(	O
" UPCALLS"	pointer
)	O
;	O
if	O
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
&	O
VMS_LF_IMGSTA	int
)	O
printf	function
(	O
" IMGSTA"	pointer
)	O
;	O
if	O
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
&	O
VMS_LF_INITIALIZE	int
)	O
printf	function
(	O
" INITIALIZE"	pointer
)	O
;	O
if	O
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
&	O
VMS_LF_MAIN	int
)	O
printf	function
(	O
" MAIN"	pointer
)	O
;	O
if	O
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
&	O
VMS_LF_EXE_INIT	int
)	O
printf	function
(	O
" EXE_INIT"	pointer
)	O
;	O
if	O
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
&	O
VMS_LF_TBK_IN_IMG	int
)	O
printf	function
(	O
" TBK_IN_IMG"	pointer
)	O
;	O
if	O
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
&	O
VMS_LF_DBG_IN_IMG	int
)	O
printf	function
(	O
" DBG_IN_IMG"	pointer
)	O
;	O
if	O
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
&	O
VMS_LF_TBK_IN_DSF	int
)	O
printf	function
(	O
" TBK_IN_DSF"	pointer
)	O
;	O
if	O
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
&	O
VMS_LF_DBG_IN_DSF	int
)	O
printf	function
(	O
" DBG_IN_DSF"	pointer
)	O
;	O
if	O
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
&	O
VMS_LF_SIGNATURES	int
)	O
printf	function
(	O
" SIGNATURES"	pointer
)	O
;	O
if	O
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
&	O
VMS_LF_REL_SEG_OFF	int
)	O
printf	function
(	O
" REL_SEG_OFF"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
print_vma	function
(	O
entry	int
->	O
d_un	union
.	O
d_ptr	array
,	O
PREFIX_HEX	int
)	O
;	O
break	O
;	O
}	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
static	O
bfd_boolean	int
get_32bit_dynamic_section	function
(	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
Elf32_External_Dyn	struct
*	O
edyn	pointer
;	O
Elf32_External_Dyn	struct
*	O
ext	pointer
;	O
Elf_Internal_Dyn	struct
*	O
entry	int
;	O
edyn	pointer
=	O
(	O
Elf32_External_Dyn	struct
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
dynamic_addr	long
,	O
1	int
,	O
dynamic_size	long
,	O
_	O
(	O
"dynamic section"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
edyn	pointer
)	O
return	O
FALSE	int
;	O
for	O
(	O
ext	pointer
=	O
edyn	pointer
,	O
dynamic_nent	long
=	O
0	int
;	O
(	O
char	O
*	O
)	O
(	O
ext	pointer
+	O
1	int
)	O
<=	O
(	O
char	O
*	O
)	O
edyn	pointer
+	O
dynamic_size	long
;	O
ext	pointer
++	O
)	O
{	O
dynamic_nent	long
++	O
;	O
if	O
(	O
BYTE_GET	O
(	O
ext	pointer
->	O
d_tag	array
)	O
==	O
DT_NULL	int
)	O
break	O
;	O
}	O
dynamic_section	pointer
=	O
(	O
Elf_Internal_Dyn	struct
*	O
)	O
cmalloc	function
(	O
dynamic_nent	long
,	O
sizeof	O
(	O
*	O
entry	int
)	O
)	O
;	O
if	O
(	O
dynamic_section	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Out of memory allocating space for %lu dynamic entries\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
dynamic_nent	long
)	O
;	O
free	function
(	O
edyn	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
for	O
(	O
ext	pointer
=	O
edyn	pointer
,	O
entry	int
=	O
dynamic_section	pointer
;	O
entry	int
<	O
dynamic_section	pointer
+	O
dynamic_nent	long
;	O
ext	pointer
++	O
,	O
entry	int
++	O
)	O
{	O
entry	int
->	O
d_tag	array
=	O
BYTE_GET	O
(	O
ext	pointer
->	O
d_tag	array
)	O
;	O
entry	int
->	O
d_un	union
.	O
d_val	array
=	O
BYTE_GET	O
(	O
ext	pointer
->	O
d_un	union
.	O
d_val	array
)	O
;	O
}	O
free	function
(	O
edyn	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
get_64bit_dynamic_section	function
(	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
Elf64_External_Dyn	struct
*	O
edyn	pointer
;	O
Elf64_External_Dyn	struct
*	O
ext	pointer
;	O
Elf_Internal_Dyn	struct
*	O
entry	int
;	O
edyn	pointer
=	O
(	O
Elf64_External_Dyn	struct
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
dynamic_addr	long
,	O
1	int
,	O
dynamic_size	long
,	O
_	O
(	O
"dynamic section"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
edyn	pointer
)	O
return	O
FALSE	int
;	O
for	O
(	O
ext	pointer
=	O
edyn	pointer
,	O
dynamic_nent	long
=	O
0	int
;	O
(	O
char	O
*	O
)	O
(	O
ext	pointer
+	O
1	int
)	O
<=	O
(	O
char	O
*	O
)	O
edyn	pointer
+	O
dynamic_size	long
;	O
ext	pointer
++	O
)	O
{	O
dynamic_nent	long
++	O
;	O
if	O
(	O
BYTE_GET	O
(	O
ext	pointer
->	O
d_tag	array
)	O
==	O
DT_NULL	int
)	O
break	O
;	O
}	O
dynamic_section	pointer
=	O
(	O
Elf_Internal_Dyn	struct
*	O
)	O
cmalloc	function
(	O
dynamic_nent	long
,	O
sizeof	O
(	O
*	O
entry	int
)	O
)	O
;	O
if	O
(	O
dynamic_section	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Out of memory allocating space for %lu dynamic entries\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
dynamic_nent	long
)	O
;	O
free	function
(	O
edyn	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
for	O
(	O
ext	pointer
=	O
edyn	pointer
,	O
entry	int
=	O
dynamic_section	pointer
;	O
entry	int
<	O
dynamic_section	pointer
+	O
dynamic_nent	long
;	O
ext	pointer
++	O
,	O
entry	int
++	O
)	O
{	O
entry	int
->	O
d_tag	array
=	O
BYTE_GET	O
(	O
ext	pointer
->	O
d_tag	array
)	O
;	O
entry	int
->	O
d_un	union
.	O
d_val	array
=	O
BYTE_GET	O
(	O
ext	pointer
->	O
d_un	union
.	O
d_val	array
)	O
;	O
}	O
free	function
(	O
edyn	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
void	O
print_dynamic_flags	function
(	O
bfd_vma	long
flags	int
)	O
{	O
bfd_boolean	int
first	int
=	O
TRUE	int
;	O
while	O
(	O
flags	int
)	O
{	O
bfd_vma	long
flag	int
;	O
flag	int
=	O
flags	int
&	O
-	O
flags	int
;	O
flags	int
&=	O
~	O
flag	int
;	O
if	O
(	O
first	int
)	O
first	int
=	O
FALSE	int
;	O
else	O
putc	function
(	O
' '	O
,	O
stdout	pointer
)	O
;	O
switch	O
(	O
flag	int
)	O
{	O
case	O
DF_ORIGIN	O
:	O
fputs	function
(	O
"ORIGIN"	pointer
,	O
stdout	pointer
)	O
;	O
break	O
;	O
case	O
DF_SYMBOLIC	O
:	O
fputs	function
(	O
"SYMBOLIC"	pointer
,	O
stdout	pointer
)	O
;	O
break	O
;	O
case	O
DF_TEXTREL	O
:	O
fputs	function
(	O
"TEXTREL"	pointer
,	O
stdout	pointer
)	O
;	O
break	O
;	O
case	O
DF_BIND_NOW	O
:	O
fputs	function
(	O
"BIND_NOW"	pointer
,	O
stdout	pointer
)	O
;	O
break	O
;	O
case	O
DF_STATIC_TLS	O
:	O
fputs	function
(	O
"STATIC_TLS"	pointer
,	O
stdout	pointer
)	O
;	O
break	O
;	O
default	O
:	O
fputs	function
(	O
_	O
(	O
"unknown"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
break	O
;	O
}	O
}	O
puts	function
(	O
""	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
process_dynamic_section	function
(	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
Elf_Internal_Dyn	struct
*	O
entry	int
;	O
if	O
(	O
dynamic_size	long
==	O
0	int
)	O
{	O
if	O
(	O
do_dynamic	int
)	O
printf	function
(	O
_	O
(	O
"\nThere is no dynamic section in this file.\n"	pointer
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
is_32bit_elf	int
)	O
{	O
if	O
(	O
!	O
get_32bit_dynamic_section	function
(	O
filedata	struct
)	O
)	O
return	O
FALSE	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
get_64bit_dynamic_section	function
(	O
filedata	struct
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
dynamic_symbols	pointer
==	O
NULL	O
)	O
{	O
for	O
(	O
entry	int
=	O
dynamic_section	pointer
;	O
entry	int
<	O
dynamic_section	pointer
+	O
dynamic_nent	long
;	O
++	O
entry	int
)	O
{	O
Elf_Internal_Shdr	struct
section	pointer
;	O
if	O
(	O
entry	int
->	O
d_tag	array
!=	O
DT_SYMTAB	int
)	O
continue	O
;	O
dynamic_info	array
[	O
DT_SYMTAB	int
]	O
=	O
entry	int
->	O
d_un	union
.	O
d_val	array
;	O
section	pointer
.	O
sh_offset	array
=	O
offset_from_vma	function
(	O
filedata	struct
,	O
entry	int
->	O
d_un	union
.	O
d_val	array
,	O
0	int
)	O
;	O
if	O
(	O
(	O
bfd_size_type	long
)	O
section	pointer
.	O
sh_offset	array
>	O
filedata	struct
->	O
file_size	long
)	O
{	O
error	function
(	O
_	O
(	O
"Invalid DT_SYMTAB entry: %lx"	pointer
)	O
,	O
(	O
long	O
)	O
section	pointer
.	O
sh_offset	array
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
archive_file_offset	long
!=	O
0	int
)	O
section	pointer
.	O
sh_size	array
=	O
archive_file_size	long
-	O
section	pointer
.	O
sh_offset	array
;	O
else	O
section	pointer
.	O
sh_size	array
=	O
filedata	struct
->	O
file_size	long
-	O
section	pointer
.	O
sh_offset	array
;	O
if	O
(	O
is_32bit_elf	int
)	O
section	pointer
.	O
sh_entsize	array
=	O
sizeof	O
(	O
Elf32_External_Sym	struct
)	O
;	O
else	O
section	pointer
.	O
sh_entsize	array
=	O
sizeof	O
(	O
Elf64_External_Sym	struct
)	O
;	O
section	pointer
.	O
sh_name	array
=	O
filedata	struct
->	O
string_table_length	long
;	O
if	O
(	O
dynamic_symbols	pointer
!=	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Multiple dynamic symbol table sections found\n"	pointer
)	O
)	O
;	O
free	function
(	O
dynamic_symbols	pointer
)	O
;	O
}	O
dynamic_symbols	pointer
=	O
GET_ELF_SYMBOLS	O
(	O
filedata	struct
,	O
&	O
section	pointer
,	O
&	O
num_dynamic_syms	long
)	O
;	O
if	O
(	O
num_dynamic_syms	long
<	O
1	int
)	O
{	O
error	function
(	O
_	O
(	O
"Unable to determine the number of symbols to load\n"	pointer
)	O
)	O
;	O
continue	O
;	O
}	O
}	O
}	O
if	O
(	O
dynamic_strings	pointer
==	O
NULL	O
)	O
{	O
for	O
(	O
entry	int
=	O
dynamic_section	pointer
;	O
entry	int
<	O
dynamic_section	pointer
+	O
dynamic_nent	long
;	O
++	O
entry	int
)	O
{	O
unsigned	O
long	O
offset	long
;	O
long	O
str_tab_len	long
;	O
if	O
(	O
entry	int
->	O
d_tag	array
!=	O
DT_STRTAB	int
)	O
continue	O
;	O
dynamic_info	array
[	O
DT_STRTAB	int
]	O
=	O
entry	int
->	O
d_un	union
.	O
d_val	array
;	O
offset	long
=	O
offset_from_vma	function
(	O
filedata	struct
,	O
entry	int
->	O
d_un	union
.	O
d_val	array
,	O
0	int
)	O
;	O
if	O
(	O
archive_file_offset	long
!=	O
0	int
)	O
str_tab_len	long
=	O
archive_file_size	long
-	O
offset	long
;	O
else	O
str_tab_len	long
=	O
filedata	struct
->	O
file_size	long
-	O
offset	long
;	O
if	O
(	O
str_tab_len	long
<	O
1	int
)	O
{	O
error	function
(	O
_	O
(	O
"Unable to determine the length of the dynamic string table\n"	pointer
)	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
dynamic_strings	pointer
!=	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Multiple dynamic string tables found\n"	pointer
)	O
)	O
;	O
free	function
(	O
dynamic_strings	pointer
)	O
;	O
}	O
dynamic_strings	pointer
=	O
(	O
char	O
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
offset	long
,	O
1	int
,	O
str_tab_len	long
,	O
_	O
(	O
"dynamic string table"	pointer
)	O
)	O
;	O
dynamic_strings_length	long
=	O
dynamic_strings	pointer
==	O
NULL	O
?	O
0	int
:	O
str_tab_len	long
;	O
}	O
}	O
if	O
(	O
dynamic_syminfo	pointer
==	O
NULL	O
)	O
{	O
unsigned	O
long	O
syminsz	long
=	O
0	int
;	O
for	O
(	O
entry	int
=	O
dynamic_section	pointer
;	O
entry	int
<	O
dynamic_section	pointer
+	O
dynamic_nent	long
;	O
++	O
entry	int
)	O
{	O
if	O
(	O
entry	int
->	O
d_tag	array
==	O
DT_SYMINENT	int
)	O
{	O
if	O
(	O
sizeof	O
(	O
Elf_External_Syminfo	struct
)	O
!=	O
entry	int
->	O
d_un	union
.	O
d_val	array
)	O
error	function
(	O
_	O
(	O
"Bad value (%d) for SYMINENT entry\n"	pointer
)	O
,	O
(	O
int	O
)	O
entry	int
->	O
d_un	union
.	O
d_val	array
)	O
;	O
}	O
else	O
if	O
(	O
entry	int
->	O
d_tag	array
==	O
DT_SYMINSZ	int
)	O
syminsz	long
=	O
entry	int
->	O
d_un	union
.	O
d_val	array
;	O
else	O
if	O
(	O
entry	int
->	O
d_tag	array
==	O
DT_SYMINFO	int
)	O
dynamic_syminfo_offset	long
=	O
offset_from_vma	function
(	O
filedata	struct
,	O
entry	int
->	O
d_un	union
.	O
d_val	array
,	O
syminsz	long
)	O
;	O
}	O
if	O
(	O
dynamic_syminfo_offset	long
!=	O
0	int
&&	O
syminsz	long
!=	O
0	int
)	O
{	O
Elf_External_Syminfo	struct
*	O
extsyminfo	pointer
;	O
Elf_External_Syminfo	struct
*	O
extsym	pointer
;	O
Elf_Internal_Syminfo	struct
*	O
syminfo	pointer
;	O
extsyminfo	pointer
=	O
(	O
Elf_External_Syminfo	struct
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
dynamic_syminfo_offset	long
,	O
1	int
,	O
syminsz	long
,	O
_	O
(	O
"symbol information"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
extsyminfo	pointer
)	O
return	O
FALSE	int
;	O
if	O
(	O
dynamic_syminfo	pointer
!=	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Multiple dynamic symbol information sections found\n"	pointer
)	O
)	O
;	O
free	function
(	O
dynamic_syminfo	pointer
)	O
;	O
}	O
dynamic_syminfo	pointer
=	O
(	O
Elf_Internal_Syminfo	struct
*	O
)	O
malloc	function
(	O
syminsz	long
)	O
;	O
if	O
(	O
dynamic_syminfo	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Out of memory allocating %lu byte for dynamic symbol info\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
syminsz	long
)	O
;	O
return	O
FALSE	int
;	O
}	O
dynamic_syminfo_nent	int
=	O
syminsz	long
/	O
sizeof	O
(	O
Elf_External_Syminfo	struct
)	O
;	O
for	O
(	O
syminfo	pointer
=	O
dynamic_syminfo	pointer
,	O
extsym	pointer
=	O
extsyminfo	pointer
;	O
syminfo	pointer
<	O
dynamic_syminfo	pointer
+	O
dynamic_syminfo_nent	int
;	O
++	O
syminfo	pointer
,	O
++	O
extsym	pointer
)	O
{	O
syminfo	pointer
->	O
si_boundto	array
=	O
BYTE_GET	O
(	O
extsym	pointer
->	O
si_boundto	array
)	O
;	O
syminfo	pointer
->	O
si_flags	array
=	O
BYTE_GET	O
(	O
extsym	pointer
->	O
si_flags	array
)	O
;	O
}	O
free	function
(	O
extsyminfo	pointer
)	O
;	O
}	O
}	O
if	O
(	O
do_dynamic	int
&&	O
dynamic_addr	long
)	O
printf	function
(	O
ngettext	function
(	O
"\nDynamic section at offset 0x%lx "	pointer
"contains %lu entry:\n"	pointer
,	O
"\nDynamic section at offset 0x%lx "	pointer
"contains %lu entries:\n"	pointer
,	O
dynamic_nent	long
)	O
,	O
dynamic_addr	long
,	O
(	O
unsigned	O
long	O
)	O
dynamic_nent	long
)	O
;	O
if	O
(	O
do_dynamic	int
)	O
printf	function
(	O
_	O
(	O
"  Tag        Type                         Name/Value\n"	pointer
)	O
)	O
;	O
for	O
(	O
entry	int
=	O
dynamic_section	pointer
;	O
entry	int
<	O
dynamic_section	pointer
+	O
dynamic_nent	long
;	O
entry	int
++	O
)	O
{	O
if	O
(	O
do_dynamic	int
)	O
{	O
const	O
char	O
*	O
dtype	pointer
;	O
putchar	function
(	O
' '	O
)	O
;	O
print_vma	function
(	O
entry	int
->	O
d_tag	array
,	O
FULL_HEX	int
)	O
;	O
dtype	pointer
=	O
get_dynamic_type	function
(	O
filedata	struct
,	O
entry	int
->	O
d_tag	array
)	O
;	O
printf	function
(	O
" (%s)%*s"	pointer
,	O
dtype	pointer
,	O
(	O
(	O
is_32bit_elf	int
?	O
27	int
:	O
19	int
)	O
-	O
(	O
int	O
)	O
strlen	function
(	O
dtype	pointer
)	O
)	O
,	O
" "	pointer
)	O
;	O
}	O
switch	O
(	O
entry	int
->	O
d_tag	array
)	O
{	O
case	O
DT_FLAGS	int
:	O
if	O
(	O
do_dynamic	int
)	O
print_dynamic_flags	function
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
)	O
;	O
break	O
;	O
case	O
DT_AUXILIARY	int
:	O
case	O
DT_FILTER	int
:	O
case	O
DT_CONFIG	int
:	O
case	O
DT_DEPAUDIT	int
:	O
case	O
DT_AUDIT	int
:	O
if	O
(	O
do_dynamic	int
)	O
{	O
switch	O
(	O
entry	int
->	O
d_tag	array
)	O
{	O
case	O
DT_AUXILIARY	int
:	O
printf	function
(	O
_	O
(	O
"Auxiliary library"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
DT_FILTER	int
:	O
printf	function
(	O
_	O
(	O
"Filter library"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
DT_CONFIG	int
:	O
printf	function
(	O
_	O
(	O
"Configuration file"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
DT_DEPAUDIT	int
:	O
printf	function
(	O
_	O
(	O
"Dependency audit library"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
DT_AUDIT	int
:	O
printf	function
(	O
_	O
(	O
"Audit library"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
VALID_DYNAMIC_NAME	O
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
)	O
)	O
printf	function
(	O
": [%s]\n"	pointer
,	O
GET_DYNAMIC_NAME	O
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
)	O
)	O
;	O
else	O
{	O
printf	function
(	O
": "	pointer
)	O
;	O
print_vma	function
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
,	O
PREFIX_HEX	int
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
}	O
break	O
;	O
case	O
DT_FEATURE	int
:	O
if	O
(	O
do_dynamic	int
)	O
{	O
printf	function
(	O
_	O
(	O
"Flags:"	pointer
)	O
)	O
;	O
if	O
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
==	O
0	int
)	O
printf	function
(	O
_	O
(	O
" None\n"	pointer
)	O
)	O
;	O
else	O
{	O
unsigned	O
long	O
int	O
val	array
=	O
entry	int
->	O
d_un	union
.	O
d_val	array
;	O
if	O
(	O
val	array
&	O
DTF_1_PARINIT	int
)	O
{	O
printf	function
(	O
" PARINIT"	pointer
)	O
;	O
val	array
^=	O
DTF_1_PARINIT	int
;	O
}	O
if	O
(	O
val	array
&	O
DTF_1_CONFEXP	int
)	O
{	O
printf	function
(	O
" CONFEXP"	pointer
)	O
;	O
val	array
^=	O
DTF_1_CONFEXP	int
;	O
}	O
if	O
(	O
val	array
!=	O
0	int
)	O
printf	function
(	O
" %lx"	pointer
,	O
val	array
)	O
;	O
puts	function
(	O
""	pointer
)	O
;	O
}	O
}	O
break	O
;	O
case	O
DT_POSFLAG_1	int
:	O
if	O
(	O
do_dynamic	int
)	O
{	O
printf	function
(	O
_	O
(	O
"Flags:"	pointer
)	O
)	O
;	O
if	O
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
==	O
0	int
)	O
printf	function
(	O
_	O
(	O
" None\n"	pointer
)	O
)	O
;	O
else	O
{	O
unsigned	O
long	O
int	O
val	array
=	O
entry	int
->	O
d_un	union
.	O
d_val	array
;	O
if	O
(	O
val	array
&	O
DF_P1_LAZYLOAD	int
)	O
{	O
printf	function
(	O
" LAZYLOAD"	pointer
)	O
;	O
val	array
^=	O
DF_P1_LAZYLOAD	int
;	O
}	O
if	O
(	O
val	array
&	O
DF_P1_GROUPPERM	int
)	O
{	O
printf	function
(	O
" GROUPPERM"	pointer
)	O
;	O
val	array
^=	O
DF_P1_GROUPPERM	int
;	O
}	O
if	O
(	O
val	array
!=	O
0	int
)	O
printf	function
(	O
" %lx"	pointer
,	O
val	array
)	O
;	O
puts	function
(	O
""	pointer
)	O
;	O
}	O
}	O
break	O
;	O
case	O
DT_FLAGS_1	int
:	O
if	O
(	O
do_dynamic	int
)	O
{	O
printf	function
(	O
_	O
(	O
"Flags:"	pointer
)	O
)	O
;	O
if	O
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
==	O
0	int
)	O
printf	function
(	O
_	O
(	O
" None\n"	pointer
)	O
)	O
;	O
else	O
{	O
unsigned	O
long	O
int	O
val	array
=	O
entry	int
->	O
d_un	union
.	O
d_val	array
;	O
if	O
(	O
val	array
&	O
DF_1_NOW	int
)	O
{	O
printf	function
(	O
" NOW"	pointer
)	O
;	O
val	array
^=	O
DF_1_NOW	int
;	O
}	O
if	O
(	O
val	array
&	O
DF_1_GLOBAL	int
)	O
{	O
printf	function
(	O
" GLOBAL"	pointer
)	O
;	O
val	array
^=	O
DF_1_GLOBAL	int
;	O
}	O
if	O
(	O
val	array
&	O
DF_1_GROUP	int
)	O
{	O
printf	function
(	O
" GROUP"	pointer
)	O
;	O
val	array
^=	O
DF_1_GROUP	int
;	O
}	O
if	O
(	O
val	array
&	O
DF_1_NODELETE	int
)	O
{	O
printf	function
(	O
" NODELETE"	pointer
)	O
;	O
val	array
^=	O
DF_1_NODELETE	int
;	O
}	O
if	O
(	O
val	array
&	O
DF_1_LOADFLTR	int
)	O
{	O
printf	function
(	O
" LOADFLTR"	pointer
)	O
;	O
val	array
^=	O
DF_1_LOADFLTR	int
;	O
}	O
if	O
(	O
val	array
&	O
DF_1_INITFIRST	int
)	O
{	O
printf	function
(	O
" INITFIRST"	pointer
)	O
;	O
val	array
^=	O
DF_1_INITFIRST	int
;	O
}	O
if	O
(	O
val	array
&	O
DF_1_NOOPEN	int
)	O
{	O
printf	function
(	O
" NOOPEN"	pointer
)	O
;	O
val	array
^=	O
DF_1_NOOPEN	int
;	O
}	O
if	O
(	O
val	array
&	O
DF_1_ORIGIN	int
)	O
{	O
printf	function
(	O
" ORIGIN"	pointer
)	O
;	O
val	array
^=	O
DF_1_ORIGIN	int
;	O
}	O
if	O
(	O
val	array
&	O
DF_1_DIRECT	int
)	O
{	O
printf	function
(	O
" DIRECT"	pointer
)	O
;	O
val	array
^=	O
DF_1_DIRECT	int
;	O
}	O
if	O
(	O
val	array
&	O
DF_1_TRANS	int
)	O
{	O
printf	function
(	O
" TRANS"	pointer
)	O
;	O
val	array
^=	O
DF_1_TRANS	int
;	O
}	O
if	O
(	O
val	array
&	O
DF_1_INTERPOSE	int
)	O
{	O
printf	function
(	O
" INTERPOSE"	pointer
)	O
;	O
val	array
^=	O
DF_1_INTERPOSE	int
;	O
}	O
if	O
(	O
val	array
&	O
DF_1_NODEFLIB	int
)	O
{	O
printf	function
(	O
" NODEFLIB"	pointer
)	O
;	O
val	array
^=	O
DF_1_NODEFLIB	int
;	O
}	O
if	O
(	O
val	array
&	O
DF_1_NODUMP	int
)	O
{	O
printf	function
(	O
" NODUMP"	pointer
)	O
;	O
val	array
^=	O
DF_1_NODUMP	int
;	O
}	O
if	O
(	O
val	array
&	O
DF_1_CONFALT	int
)	O
{	O
printf	function
(	O
" CONFALT"	pointer
)	O
;	O
val	array
^=	O
DF_1_CONFALT	int
;	O
}	O
if	O
(	O
val	array
&	O
DF_1_ENDFILTEE	int
)	O
{	O
printf	function
(	O
" ENDFILTEE"	pointer
)	O
;	O
val	array
^=	O
DF_1_ENDFILTEE	int
;	O
}	O
if	O
(	O
val	array
&	O
DF_1_DISPRELDNE	int
)	O
{	O
printf	function
(	O
" DISPRELDNE"	pointer
)	O
;	O
val	array
^=	O
DF_1_DISPRELDNE	int
;	O
}	O
if	O
(	O
val	array
&	O
DF_1_DISPRELPND	int
)	O
{	O
printf	function
(	O
" DISPRELPND"	pointer
)	O
;	O
val	array
^=	O
DF_1_DISPRELPND	int
;	O
}	O
if	O
(	O
val	array
&	O
DF_1_NODIRECT	int
)	O
{	O
printf	function
(	O
" NODIRECT"	pointer
)	O
;	O
val	array
^=	O
DF_1_NODIRECT	int
;	O
}	O
if	O
(	O
val	array
&	O
DF_1_IGNMULDEF	int
)	O
{	O
printf	function
(	O
" IGNMULDEF"	pointer
)	O
;	O
val	array
^=	O
DF_1_IGNMULDEF	int
;	O
}	O
if	O
(	O
val	array
&	O
DF_1_NOKSYMS	int
)	O
{	O
printf	function
(	O
" NOKSYMS"	pointer
)	O
;	O
val	array
^=	O
DF_1_NOKSYMS	int
;	O
}	O
if	O
(	O
val	array
&	O
DF_1_NOHDR	int
)	O
{	O
printf	function
(	O
" NOHDR"	pointer
)	O
;	O
val	array
^=	O
DF_1_NOHDR	int
;	O
}	O
if	O
(	O
val	array
&	O
DF_1_EDITED	int
)	O
{	O
printf	function
(	O
" EDITED"	pointer
)	O
;	O
val	array
^=	O
DF_1_EDITED	int
;	O
}	O
if	O
(	O
val	array
&	O
DF_1_NORELOC	int
)	O
{	O
printf	function
(	O
" NORELOC"	pointer
)	O
;	O
val	array
^=	O
DF_1_NORELOC	int
;	O
}	O
if	O
(	O
val	array
&	O
DF_1_SYMINTPOSE	int
)	O
{	O
printf	function
(	O
" SYMINTPOSE"	pointer
)	O
;	O
val	array
^=	O
DF_1_SYMINTPOSE	int
;	O
}	O
if	O
(	O
val	array
&	O
DF_1_GLOBAUDIT	int
)	O
{	O
printf	function
(	O
" GLOBAUDIT"	pointer
)	O
;	O
val	array
^=	O
DF_1_GLOBAUDIT	int
;	O
}	O
if	O
(	O
val	array
&	O
DF_1_SINGLETON	int
)	O
{	O
printf	function
(	O
" SINGLETON"	pointer
)	O
;	O
val	array
^=	O
DF_1_SINGLETON	int
;	O
}	O
if	O
(	O
val	array
&	O
DF_1_STUB	int
)	O
{	O
printf	function
(	O
" STUB"	pointer
)	O
;	O
val	array
^=	O
DF_1_STUB	int
;	O
}	O
if	O
(	O
val	array
&	O
DF_1_PIE	int
)	O
{	O
printf	function
(	O
" PIE"	pointer
)	O
;	O
val	array
^=	O
DF_1_PIE	int
;	O
}	O
if	O
(	O
val	array
&	O
DF_1_KMOD	int
)	O
{	O
printf	function
(	O
" KMOD"	pointer
)	O
;	O
val	array
^=	O
DF_1_KMOD	int
;	O
}	O
if	O
(	O
val	array
&	O
DF_1_WEAKFILTER	int
)	O
{	O
printf	function
(	O
" WEAKFILTER"	pointer
)	O
;	O
val	array
^=	O
DF_1_WEAKFILTER	int
;	O
}	O
if	O
(	O
val	array
&	O
DF_1_NOCOMMON	int
)	O
{	O
printf	function
(	O
" NOCOMMON"	pointer
)	O
;	O
val	array
^=	O
DF_1_NOCOMMON	int
;	O
}	O
if	O
(	O
val	array
!=	O
0	int
)	O
printf	function
(	O
" %lx"	pointer
,	O
val	array
)	O
;	O
puts	function
(	O
""	pointer
)	O
;	O
}	O
}	O
break	O
;	O
case	O
DT_PLTREL	int
:	O
dynamic_info	array
[	O
entry	int
->	O
d_tag	array
]	O
=	O
entry	int
->	O
d_un	union
.	O
d_val	array
;	O
if	O
(	O
do_dynamic	int
)	O
puts	function
(	O
get_dynamic_type	function
(	O
filedata	struct
,	O
entry	int
->	O
d_un	union
.	O
d_val	array
)	O
)	O
;	O
break	O
;	O
case	O
DT_NULL	int
:	O
case	O
DT_NEEDED	int
:	O
case	O
DT_PLTGOT	int
:	O
case	O
DT_HASH	int
:	O
case	O
DT_STRTAB	int
:	O
case	O
DT_SYMTAB	int
:	O
case	O
DT_RELA	int
:	O
case	O
DT_INIT	int
:	O
case	O
DT_FINI	int
:	O
case	O
DT_SONAME	int
:	O
case	O
DT_RPATH	int
:	O
case	O
DT_SYMBOLIC	int
:	O
case	O
DT_REL	int
:	O
case	O
DT_DEBUG	int
:	O
case	O
DT_TEXTREL	int
:	O
case	O
DT_JMPREL	int
:	O
case	O
DT_RUNPATH	int
:	O
dynamic_info	array
[	O
entry	int
->	O
d_tag	array
]	O
=	O
entry	int
->	O
d_un	union
.	O
d_val	array
;	O
if	O
(	O
do_dynamic	int
)	O
{	O
char	O
*	O
name	pointer
;	O
if	O
(	O
VALID_DYNAMIC_NAME	O
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
)	O
)	O
name	pointer
=	O
GET_DYNAMIC_NAME	O
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
)	O
;	O
else	O
name	pointer
=	O
NULL	O
;	O
if	O
(	O
name	pointer
)	O
{	O
switch	O
(	O
entry	int
->	O
d_tag	array
)	O
{	O
case	O
DT_NEEDED	int
:	O
printf	function
(	O
_	O
(	O
"Shared library: [%s]"	pointer
)	O
,	O
name	pointer
)	O
;	O
if	O
(	O
streq	O
(	O
name	pointer
,	O
program_interpreter	array
)	O
)	O
printf	function
(	O
_	O
(	O
" program interpreter"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
DT_SONAME	int
:	O
printf	function
(	O
_	O
(	O
"Library soname: [%s]"	pointer
)	O
,	O
name	pointer
)	O
;	O
break	O
;	O
case	O
DT_RPATH	int
:	O
printf	function
(	O
_	O
(	O
"Library rpath: [%s]"	pointer
)	O
,	O
name	pointer
)	O
;	O
break	O
;	O
case	O
DT_RUNPATH	int
:	O
printf	function
(	O
_	O
(	O
"Library runpath: [%s]"	pointer
)	O
,	O
name	pointer
)	O
;	O
break	O
;	O
default	O
:	O
print_vma	function
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
,	O
PREFIX_HEX	int
)	O
;	O
break	O
;	O
}	O
}	O
else	O
print_vma	function
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
,	O
PREFIX_HEX	int
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
break	O
;	O
case	O
DT_PLTRELSZ	int
:	O
case	O
DT_RELASZ	int
:	O
case	O
DT_STRSZ	int
:	O
case	O
DT_RELSZ	int
:	O
case	O
DT_RELAENT	int
:	O
case	O
DT_SYMENT	int
:	O
case	O
DT_RELENT	int
:	O
dynamic_info	array
[	O
entry	int
->	O
d_tag	array
]	O
=	O
entry	int
->	O
d_un	union
.	O
d_val	array
;	O
case	O
DT_PLTPADSZ	int
:	O
case	O
DT_MOVEENT	int
:	O
case	O
DT_MOVESZ	int
:	O
case	O
DT_INIT_ARRAYSZ	int
:	O
case	O
DT_FINI_ARRAYSZ	int
:	O
case	O
DT_GNU_CONFLICTSZ	int
:	O
case	O
DT_GNU_LIBLISTSZ	int
:	O
if	O
(	O
do_dynamic	int
)	O
{	O
print_vma	function
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
,	O
UNSIGNED	int
)	O
;	O
printf	function
(	O
_	O
(	O
" (bytes)\n"	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
DT_VERDEFNUM	int
:	O
case	O
DT_VERNEEDNUM	int
:	O
case	O
DT_RELACOUNT	int
:	O
case	O
DT_RELCOUNT	int
:	O
if	O
(	O
do_dynamic	int
)	O
{	O
print_vma	function
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
,	O
UNSIGNED	int
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
break	O
;	O
case	O
DT_SYMINSZ	int
:	O
case	O
DT_SYMINENT	int
:	O
case	O
DT_SYMINFO	int
:	O
case	O
DT_USED	int
:	O
case	O
DT_INIT_ARRAY	int
:	O
case	O
DT_FINI_ARRAY	int
:	O
if	O
(	O
do_dynamic	int
)	O
{	O
if	O
(	O
entry	int
->	O
d_tag	array
==	O
DT_USED	int
&&	O
VALID_DYNAMIC_NAME	O
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
)	O
)	O
{	O
char	O
*	O
name	pointer
=	O
GET_DYNAMIC_NAME	O
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
)	O
;	O
if	O
(	O
*	O
name	pointer
)	O
{	O
printf	function
(	O
_	O
(	O
"Not needed object: [%s]\n"	pointer
)	O
,	O
name	pointer
)	O
;	O
break	O
;	O
}	O
}	O
print_vma	function
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
,	O
PREFIX_HEX	int
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
break	O
;	O
case	O
DT_BIND_NOW	int
:	O
if	O
(	O
do_dynamic	int
)	O
putchar	function
(	O
'\n'	O
)	O
;	O
break	O
;	O
case	O
DT_GNU_PRELINKED	int
:	O
if	O
(	O
do_dynamic	int
)	O
{	O
struct	O
tm	struct
*	O
tmp	pointer
;	O
time_t	long
atime	long
=	O
entry	int
->	O
d_un	union
.	O
d_val	array
;	O
tmp	pointer
=	O
gmtime	function
(	O
&	O
atime	long
)	O
;	O
if	O
(	O
tmp	pointer
==	O
NULL	O
)	O
printf	function
(	O
_	O
(	O
"<corrupt time val: %lx"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
atime	long
)	O
;	O
else	O
printf	function
(	O
"%04u-%02u-%02uT%02u:%02u:%02u\n"	pointer
,	O
tmp	pointer
->	O
tm_year	int
+	O
1900	int
,	O
tmp	pointer
->	O
tm_mon	int
+	O
1	int
,	O
tmp	pointer
->	O
tm_mday	int
,	O
tmp	pointer
->	O
tm_hour	int
,	O
tmp	pointer
->	O
tm_min	int
,	O
tmp	pointer
->	O
tm_sec	int
)	O
;	O
}	O
break	O
;	O
case	O
DT_GNU_HASH	int
:	O
dynamic_info_DT_GNU_HASH	long
=	O
entry	int
->	O
d_un	union
.	O
d_val	array
;	O
if	O
(	O
do_dynamic	int
)	O
{	O
print_vma	function
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
,	O
PREFIX_HEX	int
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
if	O
(	O
(	O
entry	int
->	O
d_tag	array
>=	O
DT_VERSYM	int
)	O
&&	O
(	O
entry	int
->	O
d_tag	array
<=	O
DT_VERNEEDNUM	int
)	O
)	O
version_info	array
[	O
DT_VERSIONTAGIDX	O
(	O
entry	int
->	O
d_tag	array
)	O
]	O
=	O
entry	int
->	O
d_un	union
.	O
d_val	array
;	O
if	O
(	O
do_dynamic	int
)	O
{	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
case	O
EM_AARCH64	int
:	O
dynamic_section_aarch64_val	function
(	O
entry	int
)	O
;	O
break	O
;	O
case	O
EM_MIPS	int
:	O
case	O
EM_MIPS_RS3_LE	int
:	O
dynamic_section_mips_val	function
(	O
entry	int
)	O
;	O
break	O
;	O
case	O
EM_PARISC	int
:	O
dynamic_section_parisc_val	function
(	O
entry	int
)	O
;	O
break	O
;	O
case	O
EM_IA_64	int
:	O
dynamic_section_ia64_val	function
(	O
entry	int
)	O
;	O
break	O
;	O
default	O
:	O
print_vma	function
(	O
entry	int
->	O
d_un	union
.	O
d_val	array
,	O
PREFIX_HEX	int
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
}	O
break	O
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
char	O
*	O
get_ver_flags	function
(	O
unsigned	O
int	O
flags	int
)	O
{	O
static	O
char	O
buff	array
[	O
128	int
]	O
;	O
buff	array
[	O
0	int
]	O
=	O
0	int
;	O
if	O
(	O
flags	int
==	O
0	int
)	O
return	O
_	O
(	O
"none"	pointer
)	O
;	O
if	O
(	O
flags	int
&	O
VER_FLG_BASE	int
)	O
strcat	function
(	O
buff	array
,	O
"BASE"	pointer
)	O
;	O
if	O
(	O
flags	int
&	O
VER_FLG_WEAK	int
)	O
{	O
if	O
(	O
flags	int
&	O
VER_FLG_BASE	int
)	O
strcat	function
(	O
buff	array
,	O
" | "	pointer
)	O
;	O
strcat	function
(	O
buff	array
,	O
"WEAK"	pointer
)	O
;	O
}	O
if	O
(	O
flags	int
&	O
VER_FLG_INFO	int
)	O
{	O
if	O
(	O
flags	int
&	O
(	O
VER_FLG_BASE	int
|	O
VER_FLG_WEAK	int
)	O
)	O
strcat	function
(	O
buff	array
,	O
" | "	pointer
)	O
;	O
strcat	function
(	O
buff	array
,	O
"INFO"	pointer
)	O
;	O
}	O
if	O
(	O
flags	int
&	O
~	O
(	O
VER_FLG_BASE	int
|	O
VER_FLG_WEAK	int
|	O
VER_FLG_INFO	int
)	O
)	O
{	O
if	O
(	O
flags	int
&	O
(	O
VER_FLG_BASE	int
|	O
VER_FLG_WEAK	int
|	O
VER_FLG_INFO	int
)	O
)	O
strcat	function
(	O
buff	array
,	O
" | "	pointer
)	O
;	O
strcat	function
(	O
buff	array
,	O
_	O
(	O
"<unknown>"	pointer
)	O
)	O
;	O
}	O
return	O
buff	array
;	O
}	O
static	O
bfd_boolean	int
process_version_sections	function
(	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
Elf_Internal_Shdr	struct
*	O
section	pointer
;	O
unsigned	O
i	pointer
;	O
bfd_boolean	int
found	int
=	O
FALSE	int
;	O
if	O
(	O
!	O
do_version	int
)	O
return	O
TRUE	int
;	O
for	O
(	O
i	pointer
=	O
0	int
,	O
section	pointer
=	O
filedata	struct
->	O
section_headers	pointer
;	O
i	pointer
<	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
;	O
i	pointer
++	O
,	O
section	pointer
++	O
)	O
{	O
switch	O
(	O
section	pointer
->	O
sh_type	array
)	O
{	O
case	O
SHT_GNU_verdef	O
:	O
{	O
Elf_External_Verdef	struct
*	O
edefs	pointer
;	O
unsigned	O
long	O
idx	int
;	O
unsigned	O
long	O
cnt	int
;	O
char	O
*	O
endbuf	pointer
;	O
found	int
=	O
TRUE	int
;	O
printf	function
(	O
ngettext	function
(	O
"\nVersion definition section '%s' "	pointer
"contains %u entry:\n"	pointer
,	O
"\nVersion definition section '%s' "	pointer
"contains %u entries:\n"	pointer
,	O
section	pointer
->	O
sh_info	array
)	O
,	O
printable_section_name	function
(	O
filedata	struct
,	O
section	pointer
)	O
,	O
section	pointer
->	O
sh_info	array
)	O
;	O
printf	function
(	O
_	O
(	O
" Addr: 0x"	pointer
)	O
)	O
;	O
printf_vma	O
(	O
section	pointer
->	O
sh_addr	array
)	O
;	O
printf	function
(	O
_	O
(	O
"  Offset: %#08lx  Link: %u (%s)\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
section	pointer
->	O
sh_offset	array
,	O
section	pointer
->	O
sh_link	array
,	O
printable_section_name_from_index	function
(	O
filedata	struct
,	O
section	pointer
->	O
sh_link	array
)	O
)	O
;	O
edefs	pointer
=	O
(	O
Elf_External_Verdef	struct
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
section	pointer
->	O
sh_offset	array
,	O
1	int
,	O
section	pointer
->	O
sh_size	array
,	O
_	O
(	O
"version definition section"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
edefs	pointer
)	O
break	O
;	O
endbuf	pointer
=	O
(	O
char	O
*	O
)	O
edefs	pointer
+	O
section	pointer
->	O
sh_size	array
;	O
for	O
(	O
idx	int
=	O
cnt	int
=	O
0	int
;	O
cnt	int
<	O
section	pointer
->	O
sh_info	array
;	O
++	O
cnt	int
)	O
{	O
char	O
*	O
vstart	pointer
;	O
Elf_External_Verdef	struct
*	O
edef	pointer
;	O
Elf_Internal_Verdef	struct
ent	struct
;	O
Elf_External_Verdaux	struct
*	O
eaux	pointer
;	O
Elf_Internal_Verdaux	struct
aux	pointer
;	O
unsigned	O
long	O
isum	long
;	O
int	O
j	int
;	O
vstart	pointer
=	O
(	O
(	O
char	O
*	O
)	O
edefs	pointer
)	O
+	O
idx	int
;	O
if	O
(	O
vstart	pointer
+	O
sizeof	O
(	O
*	O
edef	pointer
)	O
>	O
endbuf	pointer
)	O
break	O
;	O
edef	pointer
=	O
(	O
Elf_External_Verdef	struct
*	O
)	O
vstart	pointer
;	O
ent	struct
.	O
vd_version	array
=	O
BYTE_GET	O
(	O
edef	pointer
->	O
vd_version	array
)	O
;	O
ent	struct
.	O
vd_flags	array
=	O
BYTE_GET	O
(	O
edef	pointer
->	O
vd_flags	array
)	O
;	O
ent	struct
.	O
vd_ndx	array
=	O
BYTE_GET	O
(	O
edef	pointer
->	O
vd_ndx	array
)	O
;	O
ent	struct
.	O
vd_cnt	array
=	O
BYTE_GET	O
(	O
edef	pointer
->	O
vd_cnt	array
)	O
;	O
ent	struct
.	O
vd_hash	array
=	O
BYTE_GET	O
(	O
edef	pointer
->	O
vd_hash	array
)	O
;	O
ent	struct
.	O
vd_aux	array
=	O
BYTE_GET	O
(	O
edef	pointer
->	O
vd_aux	array
)	O
;	O
ent	struct
.	O
vd_next	array
=	O
BYTE_GET	O
(	O
edef	pointer
->	O
vd_next	array
)	O
;	O
printf	function
(	O
_	O
(	O
"  %#06lx: Rev: %d  Flags: %s"	pointer
)	O
,	O
idx	int
,	O
ent	struct
.	O
vd_version	array
,	O
get_ver_flags	function
(	O
ent	struct
.	O
vd_flags	array
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  Index: %d  Cnt: %d  "	pointer
)	O
,	O
ent	struct
.	O
vd_ndx	array
,	O
ent	struct
.	O
vd_cnt	array
)	O
;	O
if	O
(	O
ent	struct
.	O
vd_aux	array
>	O
(	O
size_t	long
)	O
(	O
endbuf	pointer
-	O
vstart	pointer
)	O
)	O
break	O
;	O
vstart	pointer
+=	O
ent	struct
.	O
vd_aux	array
;	O
if	O
(	O
vstart	pointer
+	O
sizeof	O
(	O
*	O
eaux	pointer
)	O
>	O
endbuf	pointer
)	O
break	O
;	O
eaux	pointer
=	O
(	O
Elf_External_Verdaux	struct
*	O
)	O
vstart	pointer
;	O
aux	pointer
.	O
vda_name	array
=	O
BYTE_GET	O
(	O
eaux	pointer
->	O
vda_name	array
)	O
;	O
aux	pointer
.	O
vda_next	array
=	O
BYTE_GET	O
(	O
eaux	pointer
->	O
vda_next	array
)	O
;	O
if	O
(	O
VALID_DYNAMIC_NAME	O
(	O
aux	pointer
.	O
vda_name	array
)	O
)	O
printf	function
(	O
_	O
(	O
"Name: %s\n"	pointer
)	O
,	O
GET_DYNAMIC_NAME	O
(	O
aux	pointer
.	O
vda_name	array
)	O
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"Name index: %ld\n"	pointer
)	O
,	O
aux	pointer
.	O
vda_name	array
)	O
;	O
isum	long
=	O
idx	int
+	O
ent	struct
.	O
vd_aux	array
;	O
for	O
(	O
j	int
=	O
1	int
;	O
j	int
<	O
ent	struct
.	O
vd_cnt	array
;	O
j	int
++	O
)	O
{	O
if	O
(	O
aux	pointer
.	O
vda_next	array
<	O
sizeof	O
(	O
*	O
eaux	pointer
)	O
&&	O
!	O
(	O
j	int
==	O
ent	struct
.	O
vd_cnt	array
-	O
1	int
&&	O
aux	pointer
.	O
vda_next	array
==	O
0	int
)	O
)	O
{	O
warn	function
(	O
_	O
(	O
"Invalid vda_next field of %lx\n"	pointer
)	O
,	O
aux	pointer
.	O
vda_next	array
)	O
;	O
j	int
=	O
ent	struct
.	O
vd_cnt	array
;	O
break	O
;	O
}	O
if	O
(	O
aux	pointer
.	O
vda_next	array
>	O
(	O
size_t	long
)	O
(	O
endbuf	pointer
-	O
vstart	pointer
)	O
)	O
break	O
;	O
isum	long
+=	O
aux	pointer
.	O
vda_next	array
;	O
vstart	pointer
+=	O
aux	pointer
.	O
vda_next	array
;	O
if	O
(	O
vstart	pointer
+	O
sizeof	O
(	O
*	O
eaux	pointer
)	O
>	O
endbuf	pointer
)	O
break	O
;	O
eaux	pointer
=	O
(	O
Elf_External_Verdaux	struct
*	O
)	O
vstart	pointer
;	O
aux	pointer
.	O
vda_name	array
=	O
BYTE_GET	O
(	O
eaux	pointer
->	O
vda_name	array
)	O
;	O
aux	pointer
.	O
vda_next	array
=	O
BYTE_GET	O
(	O
eaux	pointer
->	O
vda_next	array
)	O
;	O
if	O
(	O
VALID_DYNAMIC_NAME	O
(	O
aux	pointer
.	O
vda_name	array
)	O
)	O
printf	function
(	O
_	O
(	O
"  %#06lx: Parent %d: %s\n"	pointer
)	O
,	O
isum	long
,	O
j	int
,	O
GET_DYNAMIC_NAME	O
(	O
aux	pointer
.	O
vda_name	array
)	O
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"  %#06lx: Parent %d, name index: %ld\n"	pointer
)	O
,	O
isum	long
,	O
j	int
,	O
aux	pointer
.	O
vda_name	array
)	O
;	O
}	O
if	O
(	O
j	int
<	O
ent	struct
.	O
vd_cnt	array
)	O
printf	function
(	O
_	O
(	O
"  Version def aux past end of section\n"	pointer
)	O
)	O
;	O
if	O
(	O
ent	struct
.	O
vd_next	array
<	O
sizeof	O
(	O
*	O
edef	pointer
)	O
&&	O
!	O
(	O
cnt	int
==	O
section	pointer
->	O
sh_info	array
-	O
1	int
&&	O
ent	struct
.	O
vd_next	array
==	O
0	int
)	O
)	O
{	O
warn	function
(	O
_	O
(	O
"Invalid vd_next field of %lx\n"	pointer
)	O
,	O
ent	struct
.	O
vd_next	array
)	O
;	O
cnt	int
=	O
section	pointer
->	O
sh_info	array
;	O
break	O
;	O
}	O
if	O
(	O
ent	struct
.	O
vd_next	array
>	O
(	O
size_t	long
)	O
(	O
endbuf	pointer
-	O
(	O
(	O
char	O
*	O
)	O
edefs	pointer
+	O
idx	int
)	O
)	O
)	O
break	O
;	O
idx	int
+=	O
ent	struct
.	O
vd_next	array
;	O
}	O
if	O
(	O
cnt	int
<	O
section	pointer
->	O
sh_info	array
)	O
printf	function
(	O
_	O
(	O
"  Version definition past end of section\n"	pointer
)	O
)	O
;	O
free	function
(	O
edefs	pointer
)	O
;	O
}	O
break	O
;	O
case	O
SHT_GNU_verneed	O
:	O
{	O
Elf_External_Verneed	struct
*	O
eneed	pointer
;	O
unsigned	O
long	O
idx	int
;	O
unsigned	O
long	O
cnt	int
;	O
char	O
*	O
endbuf	pointer
;	O
found	int
=	O
TRUE	int
;	O
printf	function
(	O
ngettext	function
(	O
"\nVersion needs section '%s' "	pointer
"contains %u entry:\n"	pointer
,	O
"\nVersion needs section '%s' "	pointer
"contains %u entries:\n"	pointer
,	O
section	pointer
->	O
sh_info	array
)	O
,	O
printable_section_name	function
(	O
filedata	struct
,	O
section	pointer
)	O
,	O
section	pointer
->	O
sh_info	array
)	O
;	O
printf	function
(	O
_	O
(	O
" Addr: 0x"	pointer
)	O
)	O
;	O
printf_vma	O
(	O
section	pointer
->	O
sh_addr	array
)	O
;	O
printf	function
(	O
_	O
(	O
"  Offset: %#08lx  Link: %u (%s)\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
section	pointer
->	O
sh_offset	array
,	O
section	pointer
->	O
sh_link	array
,	O
printable_section_name_from_index	function
(	O
filedata	struct
,	O
section	pointer
->	O
sh_link	array
)	O
)	O
;	O
eneed	pointer
=	O
(	O
Elf_External_Verneed	struct
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
section	pointer
->	O
sh_offset	array
,	O
1	int
,	O
section	pointer
->	O
sh_size	array
,	O
_	O
(	O
"Version Needs section"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
eneed	pointer
)	O
break	O
;	O
endbuf	pointer
=	O
(	O
char	O
*	O
)	O
eneed	pointer
+	O
section	pointer
->	O
sh_size	array
;	O
for	O
(	O
idx	int
=	O
cnt	int
=	O
0	int
;	O
cnt	int
<	O
section	pointer
->	O
sh_info	array
;	O
++	O
cnt	int
)	O
{	O
Elf_External_Verneed	struct
*	O
entry	int
;	O
Elf_Internal_Verneed	struct
ent	struct
;	O
unsigned	O
long	O
isum	long
;	O
int	O
j	int
;	O
char	O
*	O
vstart	pointer
;	O
vstart	pointer
=	O
(	O
(	O
char	O
*	O
)	O
eneed	pointer
)	O
+	O
idx	int
;	O
if	O
(	O
vstart	pointer
+	O
sizeof	O
(	O
*	O
entry	int
)	O
>	O
endbuf	pointer
)	O
break	O
;	O
entry	int
=	O
(	O
Elf_External_Verneed	struct
*	O
)	O
vstart	pointer
;	O
ent	struct
.	O
vn_version	array
=	O
BYTE_GET	O
(	O
entry	int
->	O
vn_version	array
)	O
;	O
ent	struct
.	O
vn_cnt	array
=	O
BYTE_GET	O
(	O
entry	int
->	O
vn_cnt	array
)	O
;	O
ent	struct
.	O
vn_file	array
=	O
BYTE_GET	O
(	O
entry	int
->	O
vn_file	array
)	O
;	O
ent	struct
.	O
vn_aux	array
=	O
BYTE_GET	O
(	O
entry	int
->	O
vn_aux	array
)	O
;	O
ent	struct
.	O
vn_next	array
=	O
BYTE_GET	O
(	O
entry	int
->	O
vn_next	array
)	O
;	O
printf	function
(	O
_	O
(	O
"  %#06lx: Version: %d"	pointer
)	O
,	O
idx	int
,	O
ent	struct
.	O
vn_version	array
)	O
;	O
if	O
(	O
VALID_DYNAMIC_NAME	O
(	O
ent	struct
.	O
vn_file	array
)	O
)	O
printf	function
(	O
_	O
(	O
"  File: %s"	pointer
)	O
,	O
GET_DYNAMIC_NAME	O
(	O
ent	struct
.	O
vn_file	array
)	O
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"  File: %lx"	pointer
)	O
,	O
ent	struct
.	O
vn_file	array
)	O
;	O
printf	function
(	O
_	O
(	O
"  Cnt: %d\n"	pointer
)	O
,	O
ent	struct
.	O
vn_cnt	array
)	O
;	O
if	O
(	O
ent	struct
.	O
vn_aux	array
>	O
(	O
size_t	long
)	O
(	O
endbuf	pointer
-	O
vstart	pointer
)	O
)	O
break	O
;	O
vstart	pointer
+=	O
ent	struct
.	O
vn_aux	array
;	O
for	O
(	O
j	int
=	O
0	int
,	O
isum	long
=	O
idx	int
+	O
ent	struct
.	O
vn_aux	array
;	O
j	int
<	O
ent	struct
.	O
vn_cnt	array
;	O
++	O
j	int
)	O
{	O
Elf_External_Vernaux	struct
*	O
eaux	pointer
;	O
Elf_Internal_Vernaux	struct
aux	pointer
;	O
if	O
(	O
vstart	pointer
+	O
sizeof	O
(	O
*	O
eaux	pointer
)	O
>	O
endbuf	pointer
)	O
break	O
;	O
eaux	pointer
=	O
(	O
Elf_External_Vernaux	struct
*	O
)	O
vstart	pointer
;	O
aux	pointer
.	O
vna_hash	array
=	O
BYTE_GET	O
(	O
eaux	pointer
->	O
vna_hash	array
)	O
;	O
aux	pointer
.	O
vna_flags	array
=	O
BYTE_GET	O
(	O
eaux	pointer
->	O
vna_flags	array
)	O
;	O
aux	pointer
.	O
vna_other	array
=	O
BYTE_GET	O
(	O
eaux	pointer
->	O
vna_other	array
)	O
;	O
aux	pointer
.	O
vna_name	array
=	O
BYTE_GET	O
(	O
eaux	pointer
->	O
vna_name	array
)	O
;	O
aux	pointer
.	O
vna_next	array
=	O
BYTE_GET	O
(	O
eaux	pointer
->	O
vna_next	array
)	O
;	O
if	O
(	O
VALID_DYNAMIC_NAME	O
(	O
aux	pointer
.	O
vna_name	array
)	O
)	O
printf	function
(	O
_	O
(	O
"  %#06lx:   Name: %s"	pointer
)	O
,	O
isum	long
,	O
GET_DYNAMIC_NAME	O
(	O
aux	pointer
.	O
vna_name	array
)	O
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"  %#06lx:   Name index: %lx"	pointer
)	O
,	O
isum	long
,	O
aux	pointer
.	O
vna_name	array
)	O
;	O
printf	function
(	O
_	O
(	O
"  Flags: %s  Version: %d\n"	pointer
)	O
,	O
get_ver_flags	function
(	O
aux	pointer
.	O
vna_flags	array
)	O
,	O
aux	pointer
.	O
vna_other	array
)	O
;	O
if	O
(	O
aux	pointer
.	O
vna_next	array
<	O
sizeof	O
(	O
*	O
eaux	pointer
)	O
&&	O
!	O
(	O
j	int
==	O
ent	struct
.	O
vn_cnt	array
-	O
1	int
&&	O
aux	pointer
.	O
vna_next	array
==	O
0	int
)	O
)	O
{	O
warn	function
(	O
_	O
(	O
"Invalid vna_next field of %lx\n"	pointer
)	O
,	O
aux	pointer
.	O
vna_next	array
)	O
;	O
j	int
=	O
ent	struct
.	O
vn_cnt	array
;	O
break	O
;	O
}	O
if	O
(	O
aux	pointer
.	O
vna_next	array
>	O
(	O
size_t	long
)	O
(	O
endbuf	pointer
-	O
vstart	pointer
)	O
)	O
break	O
;	O
isum	long
+=	O
aux	pointer
.	O
vna_next	array
;	O
vstart	pointer
+=	O
aux	pointer
.	O
vna_next	array
;	O
}	O
if	O
(	O
j	int
<	O
ent	struct
.	O
vn_cnt	array
)	O
warn	function
(	O
_	O
(	O
"Missing Version Needs auxillary information\n"	pointer
)	O
)	O
;	O
if	O
(	O
ent	struct
.	O
vn_next	array
<	O
sizeof	O
(	O
*	O
entry	int
)	O
&&	O
!	O
(	O
cnt	int
==	O
section	pointer
->	O
sh_info	array
-	O
1	int
&&	O
ent	struct
.	O
vn_next	array
==	O
0	int
)	O
)	O
{	O
warn	function
(	O
_	O
(	O
"Invalid vn_next field of %lx\n"	pointer
)	O
,	O
ent	struct
.	O
vn_next	array
)	O
;	O
cnt	int
=	O
section	pointer
->	O
sh_info	array
;	O
break	O
;	O
}	O
if	O
(	O
ent	struct
.	O
vn_next	array
>	O
(	O
size_t	long
)	O
(	O
endbuf	pointer
-	O
(	O
(	O
char	O
*	O
)	O
eneed	pointer
+	O
idx	int
)	O
)	O
)	O
break	O
;	O
idx	int
+=	O
ent	struct
.	O
vn_next	array
;	O
}	O
if	O
(	O
cnt	int
<	O
section	pointer
->	O
sh_info	array
)	O
warn	function
(	O
_	O
(	O
"Missing Version Needs information\n"	pointer
)	O
)	O
;	O
free	function
(	O
eneed	pointer
)	O
;	O
}	O
break	O
;	O
case	O
SHT_GNU_versym	O
:	O
{	O
Elf_Internal_Shdr	struct
*	O
link_section	pointer
;	O
size_t	long
total	long
;	O
unsigned	O
int	O
cnt	int
;	O
unsigned	O
char	O
*	O
edata	pointer
;	O
unsigned	O
short	O
*	O
data	pointer
;	O
char	O
*	O
strtab	pointer
;	O
Elf_Internal_Sym	struct
*	O
symbols	pointer
;	O
Elf_Internal_Shdr	struct
*	O
string_sec	pointer
;	O
unsigned	O
long	O
num_syms	long
;	O
long	O
off	long
;	O
if	O
(	O
section	pointer
->	O
sh_link	array
>=	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
)	O
break	O
;	O
link_section	pointer
=	O
filedata	struct
->	O
section_headers	pointer
+	O
section	pointer
->	O
sh_link	array
;	O
total	long
=	O
section	pointer
->	O
sh_size	array
/	O
sizeof	O
(	O
Elf_External_Versym	struct
)	O
;	O
if	O
(	O
link_section	pointer
->	O
sh_link	array
>=	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
)	O
break	O
;	O
found	int
=	O
TRUE	int
;	O
symbols	pointer
=	O
GET_ELF_SYMBOLS	O
(	O
filedata	struct
,	O
link_section	pointer
,	O
&	O
num_syms	long
)	O
;	O
if	O
(	O
symbols	pointer
==	O
NULL	O
)	O
break	O
;	O
string_sec	pointer
=	O
filedata	struct
->	O
section_headers	pointer
+	O
link_section	pointer
->	O
sh_link	array
;	O
strtab	pointer
=	O
(	O
char	O
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
string_sec	pointer
->	O
sh_offset	array
,	O
1	int
,	O
string_sec	pointer
->	O
sh_size	array
,	O
_	O
(	O
"version string table"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
strtab	pointer
)	O
{	O
free	function
(	O
symbols	pointer
)	O
;	O
break	O
;	O
}	O
printf	function
(	O
ngettext	function
(	O
"\nVersion symbols section '%s' "	pointer
"contains %lu entry:\n"	pointer
,	O
"\nVersion symbols section '%s' "	pointer
"contains %lu entries:\n"	pointer
,	O
total	long
)	O
,	O
printable_section_name	function
(	O
filedata	struct
,	O
section	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
total	long
)	O
;	O
printf	function
(	O
_	O
(	O
" Addr: 0x"	pointer
)	O
)	O
;	O
printf_vma	O
(	O
section	pointer
->	O
sh_addr	array
)	O
;	O
printf	function
(	O
_	O
(	O
"  Offset: %#08lx  Link: %u (%s)\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
section	pointer
->	O
sh_offset	array
,	O
section	pointer
->	O
sh_link	array
,	O
printable_section_name	function
(	O
filedata	struct
,	O
link_section	pointer
)	O
)	O
;	O
off	long
=	O
offset_from_vma	function
(	O
filedata	struct
,	O
version_info	array
[	O
DT_VERSIONTAGIDX	O
(	O
DT_VERSYM	int
)	O
]	O
,	O
total	long
*	O
sizeof	O
(	O
short	O
)	O
)	O
;	O
edata	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
off	long
,	O
total	long
,	O
sizeof	O
(	O
short	O
)	O
,	O
_	O
(	O
"version symbol data"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
edata	pointer
)	O
{	O
free	function
(	O
strtab	pointer
)	O
;	O
free	function
(	O
symbols	pointer
)	O
;	O
break	O
;	O
}	O
data	pointer
=	O
(	O
short	O
unsigned	O
int	O
*	O
)	O
cmalloc	function
(	O
total	long
,	O
sizeof	O
(	O
short	O
)	O
)	O
;	O
for	O
(	O
cnt	int
=	O
total	long
;	O
cnt	int
--	O
;	O
)	O
data	pointer
[	O
cnt	int
]	O
=	O
byte_get	pointer
(	O
edata	pointer
+	O
cnt	int
*	O
sizeof	O
(	O
short	O
)	O
,	O
sizeof	O
(	O
short	O
)	O
)	O
;	O
free	function
(	O
edata	pointer
)	O
;	O
for	O
(	O
cnt	int
=	O
0	int
;	O
cnt	int
<	O
total	long
;	O
cnt	int
+=	O
4	int
)	O
{	O
int	O
j	int
,	O
nn	int
;	O
char	O
*	O
name	pointer
;	O
char	O
*	O
invalid	pointer
=	O
_	O
(	O
"*invalid*"	pointer
)	O
;	O
printf	function
(	O
"  %03x:"	pointer
,	O
cnt	int
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
(	O
j	int
<	O
4	int
)	O
&&	O
(	O
cnt	int
+	O
j	int
)	O
<	O
total	long
;	O
++	O
j	int
)	O
switch	O
(	O
data	pointer
[	O
cnt	int
+	O
j	int
]	O
)	O
{	O
case	O
0	int
:	O
fputs	function
(	O
_	O
(	O
"   0 (*local*)    "	pointer
)	O
,	O
stdout	pointer
)	O
;	O
break	O
;	O
case	O
1	int
:	O
fputs	function
(	O
_	O
(	O
"   1 (*global*)   "	pointer
)	O
,	O
stdout	pointer
)	O
;	O
break	O
;	O
default	O
:	O
nn	int
=	O
printf	function
(	O
"%4x%c"	pointer
,	O
data	pointer
[	O
cnt	int
+	O
j	int
]	O
&	O
VERSYM_VERSION	int
,	O
data	pointer
[	O
cnt	int
+	O
j	int
]	O
&	O
VERSYM_HIDDEN	int
?	O
'h'	O
:	O
' '	O
)	O
;	O
if	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
cnt	int
+	O
j	int
)	O
>=	O
num_syms	long
)	O
{	O
warn	function
(	O
_	O
(	O
"invalid index into symbol array\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
name	pointer
=	O
NULL	O
;	O
if	O
(	O
version_info	array
[	O
DT_VERSIONTAGIDX	O
(	O
DT_VERNEED	int
)	O
]	O
)	O
{	O
Elf_Internal_Verneed	struct
ivn	struct
;	O
unsigned	O
long	O
offset	long
;	O
offset	long
=	O
offset_from_vma	function
(	O
filedata	struct
,	O
version_info	array
[	O
DT_VERSIONTAGIDX	O
(	O
DT_VERNEED	int
)	O
]	O
,	O
sizeof	O
(	O
Elf_External_Verneed	struct
)	O
)	O
;	O
do	O
{	O
Elf_Internal_Vernaux	struct
ivna	struct
;	O
Elf_External_Verneed	struct
evn	struct
;	O
Elf_External_Vernaux	struct
evna	struct
;	O
unsigned	O
long	O
a_off	long
;	O
if	O
(	O
get_data	function
(	O
&	O
evn	struct
,	O
filedata	struct
,	O
offset	long
,	O
sizeof	O
(	O
evn	struct
)	O
,	O
1	int
,	O
_	O
(	O
"version need"	pointer
)	O
)	O
==	O
NULL	O
)	O
break	O
;	O
ivn	struct
.	O
vn_aux	array
=	O
BYTE_GET	O
(	O
evn	struct
.	O
vn_aux	array
)	O
;	O
ivn	struct
.	O
vn_next	array
=	O
BYTE_GET	O
(	O
evn	struct
.	O
vn_next	array
)	O
;	O
a_off	long
=	O
offset	long
+	O
ivn	struct
.	O
vn_aux	array
;	O
do	O
{	O
if	O
(	O
get_data	function
(	O
&	O
evna	struct
,	O
filedata	struct
,	O
a_off	long
,	O
sizeof	O
(	O
evna	struct
)	O
,	O
1	int
,	O
_	O
(	O
"version need aux (2)"	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
ivna	struct
.	O
vna_next	array
=	O
0	int
;	O
ivna	struct
.	O
vna_other	array
=	O
0	int
;	O
}	O
else	O
{	O
ivna	struct
.	O
vna_next	array
=	O
BYTE_GET	O
(	O
evna	struct
.	O
vna_next	array
)	O
;	O
ivna	struct
.	O
vna_other	array
=	O
BYTE_GET	O
(	O
evna	struct
.	O
vna_other	array
)	O
;	O
}	O
a_off	long
+=	O
ivna	struct
.	O
vna_next	array
;	O
}	O
while	O
(	O
ivna	struct
.	O
vna_other	array
!=	O
data	pointer
[	O
cnt	int
+	O
j	int
]	O
&&	O
ivna	struct
.	O
vna_next	array
!=	O
0	int
)	O
;	O
if	O
(	O
ivna	struct
.	O
vna_other	array
==	O
data	pointer
[	O
cnt	int
+	O
j	int
]	O
)	O
{	O
ivna	struct
.	O
vna_name	array
=	O
BYTE_GET	O
(	O
evna	struct
.	O
vna_name	array
)	O
;	O
if	O
(	O
ivna	struct
.	O
vna_name	array
>=	O
string_sec	pointer
->	O
sh_size	array
)	O
name	pointer
=	O
invalid	pointer
;	O
else	O
name	pointer
=	O
strtab	pointer
+	O
ivna	struct
.	O
vna_name	array
;	O
break	O
;	O
}	O
offset	long
+=	O
ivn	struct
.	O
vn_next	array
;	O
}	O
while	O
(	O
ivn	struct
.	O
vn_next	array
)	O
;	O
}	O
if	O
(	O
data	pointer
[	O
cnt	int
+	O
j	int
]	O
!=	O
0x8001	int
&&	O
version_info	array
[	O
DT_VERSIONTAGIDX	O
(	O
DT_VERDEF	int
)	O
]	O
)	O
{	O
Elf_Internal_Verdef	struct
ivd	struct
;	O
Elf_External_Verdef	struct
evd	struct
;	O
unsigned	O
long	O
offset	long
;	O
offset	long
=	O
offset_from_vma	function
(	O
filedata	struct
,	O
version_info	array
[	O
DT_VERSIONTAGIDX	O
(	O
DT_VERDEF	int
)	O
]	O
,	O
sizeof	O
evd	struct
)	O
;	O
do	O
{	O
if	O
(	O
get_data	function
(	O
&	O
evd	struct
,	O
filedata	struct
,	O
offset	long
,	O
sizeof	O
(	O
evd	struct
)	O
,	O
1	int
,	O
_	O
(	O
"version def"	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
ivd	struct
.	O
vd_next	array
=	O
0	int
;	O
ivd	struct
.	O
vd_ndx	array
=	O
(	O
data	pointer
[	O
cnt	int
+	O
j	int
]	O
&	O
VERSYM_VERSION	int
)	O
+	O
1	int
;	O
break	O
;	O
}	O
else	O
{	O
ivd	struct
.	O
vd_next	array
=	O
BYTE_GET	O
(	O
evd	struct
.	O
vd_next	array
)	O
;	O
ivd	struct
.	O
vd_ndx	array
=	O
BYTE_GET	O
(	O
evd	struct
.	O
vd_ndx	array
)	O
;	O
}	O
offset	long
+=	O
ivd	struct
.	O
vd_next	array
;	O
}	O
while	O
(	O
ivd	struct
.	O
vd_ndx	array
!=	O
(	O
data	pointer
[	O
cnt	int
+	O
j	int
]	O
&	O
VERSYM_VERSION	int
)	O
&&	O
ivd	struct
.	O
vd_next	array
!=	O
0	int
)	O
;	O
if	O
(	O
ivd	struct
.	O
vd_ndx	array
==	O
(	O
data	pointer
[	O
cnt	int
+	O
j	int
]	O
&	O
VERSYM_VERSION	int
)	O
)	O
{	O
Elf_External_Verdaux	struct
evda	struct
;	O
Elf_Internal_Verdaux	struct
ivda	struct
;	O
ivd	struct
.	O
vd_aux	array
=	O
BYTE_GET	O
(	O
evd	struct
.	O
vd_aux	array
)	O
;	O
if	O
(	O
get_data	function
(	O
&	O
evda	struct
,	O
filedata	struct
,	O
offset	long
-	O
ivd	struct
.	O
vd_next	array
+	O
ivd	struct
.	O
vd_aux	array
,	O
sizeof	O
(	O
evda	struct
)	O
,	O
1	int
,	O
_	O
(	O
"version def aux"	pointer
)	O
)	O
==	O
NULL	O
)	O
break	O
;	O
ivda	struct
.	O
vda_name	array
=	O
BYTE_GET	O
(	O
evda	struct
.	O
vda_name	array
)	O
;	O
if	O
(	O
ivda	struct
.	O
vda_name	array
>=	O
string_sec	pointer
->	O
sh_size	array
)	O
name	pointer
=	O
invalid	pointer
;	O
else	O
if	O
(	O
name	pointer
!=	O
NULL	O
&&	O
name	pointer
!=	O
invalid	pointer
)	O
name	pointer
=	O
_	O
(	O
"*both*"	pointer
)	O
;	O
else	O
name	pointer
=	O
strtab	pointer
+	O
ivda	struct
.	O
vda_name	array
;	O
}	O
}	O
if	O
(	O
name	pointer
!=	O
NULL	O
)	O
nn	int
+=	O
printf	function
(	O
"(%s%-*s"	pointer
,	O
name	pointer
,	O
12	int
-	O
(	O
int	O
)	O
strlen	function
(	O
name	pointer
)	O
,	O
")"	pointer
)	O
;	O
if	O
(	O
nn	int
<	O
18	int
)	O
printf	function
(	O
"%*c"	pointer
,	O
18	int
-	O
nn	int
,	O
' '	O
)	O
;	O
}	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
free	function
(	O
data	pointer
)	O
;	O
free	function
(	O
strtab	pointer
)	O
;	O
free	function
(	O
symbols	pointer
)	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
found	int
)	O
printf	function
(	O
_	O
(	O
"\nNo version information found in this file.\n"	pointer
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
const	O
char	O
*	O
get_symbol_binding	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
int	O
binding	int
)	O
{	O
static	O
char	O
buff	array
[	O
32	int
]	O
;	O
switch	O
(	O
binding	int
)	O
{	O
case	O
STB_LOCAL	int
:	O
return	O
"LOCAL"	pointer
;	O
case	O
STB_GLOBAL	int
:	O
return	O
"GLOBAL"	pointer
;	O
case	O
STB_WEAK	int
:	O
return	O
"WEAK"	pointer
;	O
default	O
:	O
if	O
(	O
binding	int
>=	O
STB_LOPROC	int
&&	O
binding	int
<=	O
STB_HIPROC	int
)	O
snprintf	function
(	O
buff	array
,	O
sizeof	O
(	O
buff	array
)	O
,	O
_	O
(	O
"<processor specific>: %d"	pointer
)	O
,	O
binding	int
)	O
;	O
else	O
if	O
(	O
binding	int
>=	O
STB_LOOS	int
&&	O
binding	int
<=	O
STB_HIOS	int
)	O
{	O
if	O
(	O
binding	int
==	O
STB_GNU_UNIQUE	int
&&	O
filedata	struct
->	O
file_header	struct
.	O
e_ident	array
[	O
EI_OSABI	int
]	O
==	O
ELFOSABI_GNU	int
)	O
return	O
"UNIQUE"	pointer
;	O
snprintf	function
(	O
buff	array
,	O
sizeof	O
(	O
buff	array
)	O
,	O
_	O
(	O
"<OS specific>: %d"	pointer
)	O
,	O
binding	int
)	O
;	O
}	O
else	O
snprintf	function
(	O
buff	array
,	O
sizeof	O
(	O
buff	array
)	O
,	O
_	O
(	O
"<unknown>: %d"	pointer
)	O
,	O
binding	int
)	O
;	O
return	O
buff	array
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_symbol_type	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
int	O
type	enum
)	O
{	O
static	O
char	O
buff	array
[	O
32	int
]	O
;	O
switch	O
(	O
type	enum
)	O
{	O
case	O
STT_NOTYPE	int
:	O
return	O
"NOTYPE"	pointer
;	O
case	O
STT_OBJECT	int
:	O
return	O
"OBJECT"	pointer
;	O
case	O
STT_FUNC	int
:	O
return	O
"FUNC"	pointer
;	O
case	O
STT_SECTION	int
:	O
return	O
"SECTION"	pointer
;	O
case	O
STT_FILE	int
:	O
return	O
"FILE"	pointer
;	O
case	O
STT_COMMON	int
:	O
return	O
"COMMON"	pointer
;	O
case	O
STT_TLS	int
:	O
return	O
"TLS"	pointer
;	O
case	O
STT_RELC	int
:	O
return	O
"RELC"	pointer
;	O
case	O
STT_SRELC	int
:	O
return	O
"SRELC"	pointer
;	O
default	O
:	O
if	O
(	O
type	enum
>=	O
STT_LOPROC	int
&&	O
type	enum
<=	O
STT_HIPROC	int
)	O
{	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_ARM	int
&&	O
type	enum
==	O
STT_ARM_TFUNC	O
)	O
return	O
"THUMB_FUNC"	pointer
;	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_SPARCV9	int
&&	O
type	enum
==	O
STT_REGISTER	int
)	O
return	O
"REGISTER"	pointer
;	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_PARISC	int
&&	O
type	enum
==	O
STT_PARISC_MILLI	int
)	O
return	O
"PARISC_MILLI"	pointer
;	O
snprintf	function
(	O
buff	array
,	O
sizeof	O
(	O
buff	array
)	O
,	O
_	O
(	O
"<processor specific>: %d"	pointer
)	O
,	O
type	enum
)	O
;	O
}	O
else	O
if	O
(	O
type	enum
>=	O
STT_LOOS	int
&&	O
type	enum
<=	O
STT_HIOS	int
)	O
{	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_PARISC	int
)	O
{	O
if	O
(	O
type	enum
==	O
STT_HP_OPAQUE	O
)	O
return	O
"HP_OPAQUE"	pointer
;	O
if	O
(	O
type	enum
==	O
STT_HP_STUB	O
)	O
return	O
"HP_STUB"	pointer
;	O
}	O
if	O
(	O
type	enum
==	O
STT_GNU_IFUNC	int
&&	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_ident	array
[	O
EI_OSABI	int
]	O
==	O
ELFOSABI_GNU	int
||	O
filedata	struct
->	O
file_header	struct
.	O
e_ident	array
[	O
EI_OSABI	int
]	O
==	O
ELFOSABI_FREEBSD	int
)	O
)	O
return	O
"IFUNC"	pointer
;	O
snprintf	function
(	O
buff	array
,	O
sizeof	O
(	O
buff	array
)	O
,	O
_	O
(	O
"<OS specific>: %d"	pointer
)	O
,	O
type	enum
)	O
;	O
}	O
else	O
snprintf	function
(	O
buff	array
,	O
sizeof	O
(	O
buff	array
)	O
,	O
_	O
(	O
"<unknown>: %d"	pointer
)	O
,	O
type	enum
)	O
;	O
return	O
buff	array
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_symbol_visibility	function
(	O
unsigned	O
int	O
visibility	int
)	O
{	O
switch	O
(	O
visibility	int
)	O
{	O
case	O
STV_DEFAULT	int
:	O
return	O
"DEFAULT"	pointer
;	O
case	O
STV_INTERNAL	int
:	O
return	O
"INTERNAL"	pointer
;	O
case	O
STV_HIDDEN	int
:	O
return	O
"HIDDEN"	pointer
;	O
case	O
STV_PROTECTED	int
:	O
return	O
"PROTECTED"	pointer
;	O
default	O
:	O
error	function
(	O
_	O
(	O
"Unrecognized visibility value: %u"	pointer
)	O
,	O
visibility	int
)	O
;	O
return	O
_	O
(	O
"<unknown>"	pointer
)	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_alpha_symbol_other	function
(	O
unsigned	O
int	O
other	int
)	O
{	O
switch	O
(	O
other	int
)	O
{	O
case	O
STO_ALPHA_NOPV	int
:	O
return	O
"NOPV"	pointer
;	O
case	O
STO_ALPHA_STD_GPLOAD	int
:	O
return	O
"STD GPLOAD"	pointer
;	O
default	O
:	O
error	function
(	O
_	O
(	O
"Unrecognized alpah specific other value: %u"	pointer
)	O
,	O
other	int
)	O
;	O
return	O
_	O
(	O
"<unknown>"	pointer
)	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_solaris_symbol_visibility	function
(	O
unsigned	O
int	O
visibility	int
)	O
{	O
switch	O
(	O
visibility	int
)	O
{	O
case	O
4	int
:	O
return	O
"EXPORTED"	pointer
;	O
case	O
5	int
:	O
return	O
"SINGLETON"	pointer
;	O
case	O
6	int
:	O
return	O
"ELIMINATE"	pointer
;	O
default	O
:	O
return	O
get_symbol_visibility	function
(	O
visibility	int
)	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_aarch64_symbol_other	function
(	O
unsigned	O
int	O
other	int
)	O
{	O
static	O
char	O
buf	pointer
[	O
32	int
]	O
;	O
if	O
(	O
other	int
&	O
STO_AARCH64_VARIANT_PCS	int
)	O
{	O
other	int
&=	O
~	O
STO_AARCH64_VARIANT_PCS	int
;	O
if	O
(	O
other	int
==	O
0	int
)	O
return	O
"VARIANT_PCS"	pointer
;	O
snprintf	function
(	O
buf	pointer
,	O
sizeof	O
buf	pointer
,	O
"VARIANT_PCS | %x"	pointer
,	O
other	int
)	O
;	O
return	O
buf	pointer
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
const	O
char	O
*	O
get_mips_symbol_other	function
(	O
unsigned	O
int	O
other	int
)	O
{	O
switch	O
(	O
other	int
)	O
{	O
case	O
STO_OPTIONAL	O
:	O
return	O
"OPTIONAL"	pointer
;	O
case	O
STO_MIPS_PLT	int
:	O
return	O
"MIPS PLT"	pointer
;	O
case	O
STO_MIPS_PIC	int
:	O
return	O
"MIPS PIC"	pointer
;	O
case	O
STO_MICROMIPS	O
:	O
return	O
"MICROMIPS"	pointer
;	O
case	O
STO_MICROMIPS	O
|	O
STO_MIPS_PIC	int
:	O
return	O
"MICROMIPS, MIPS PIC"	pointer
;	O
case	O
STO_MIPS16	int
:	O
return	O
"MIPS16"	pointer
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_ia64_symbol_other	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
int	O
other	int
)	O
{	O
if	O
(	O
is_ia64_vms	function
(	O
filedata	struct
)	O
)	O
{	O
static	O
char	O
res	int
[	O
32	int
]	O
;	O
res	int
[	O
0	int
]	O
=	O
0	int
;	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_type	array
)	O
{	O
case	O
ET_DYN	int
:	O
case	O
ET_EXEC	int
:	O
switch	O
(	O
VMS_ST_FUNC_TYPE	O
(	O
other	int
)	O
)	O
{	O
case	O
VMS_SFT_CODE_ADDR	int
:	O
strcat	function
(	O
res	int
,	O
" CA"	pointer
)	O
;	O
break	O
;	O
case	O
VMS_SFT_SYMV_IDX	int
:	O
strcat	function
(	O
res	int
,	O
" VEC"	pointer
)	O
;	O
break	O
;	O
case	O
VMS_SFT_FD	int
:	O
strcat	function
(	O
res	int
,	O
" FD"	pointer
)	O
;	O
break	O
;	O
case	O
VMS_SFT_RESERVE	int
:	O
strcat	function
(	O
res	int
,	O
" RSV"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
warn	function
(	O
_	O
(	O
"Unrecognized IA64 VMS ST Function type: %d\n"	pointer
)	O
,	O
VMS_ST_FUNC_TYPE	O
(	O
other	int
)	O
)	O
;	O
strcat	function
(	O
res	int
,	O
" <unknown>"	pointer
)	O
;	O
break	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
switch	O
(	O
VMS_ST_LINKAGE	O
(	O
other	int
)	O
)	O
{	O
case	O
VMS_STL_IGNORE	int
:	O
strcat	function
(	O
res	int
,	O
" IGN"	pointer
)	O
;	O
break	O
;	O
case	O
VMS_STL_RESERVE	int
:	O
strcat	function
(	O
res	int
,	O
" RSV"	pointer
)	O
;	O
break	O
;	O
case	O
VMS_STL_STD	int
:	O
strcat	function
(	O
res	int
,	O
" STD"	pointer
)	O
;	O
break	O
;	O
case	O
VMS_STL_LNK	int
:	O
strcat	function
(	O
res	int
,	O
" LNK"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
warn	function
(	O
_	O
(	O
"Unrecognized IA64 VMS ST Linkage: %d\n"	pointer
)	O
,	O
VMS_ST_LINKAGE	O
(	O
other	int
)	O
)	O
;	O
strcat	function
(	O
res	int
,	O
" <unknown>"	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
res	int
[	O
0	int
]	O
!=	O
0	int
)	O
return	O
res	int
+	O
1	int
;	O
else	O
return	O
res	int
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
const	O
char	O
*	O
get_ppc64_symbol_other	function
(	O
unsigned	O
int	O
other	int
)	O
{	O
if	O
(	O
(	O
other	int
&	O
~	O
STO_PPC64_LOCAL_MASK	O
)	O
!=	O
0	int
)	O
return	O
NULL	O
;	O
other	int
>>=	O
STO_PPC64_LOCAL_BIT	int
;	O
if	O
(	O
other	int
<=	O
6	int
)	O
{	O
static	O
char	O
buf	pointer
[	O
32	int
]	O
;	O
if	O
(	O
other	int
>=	O
2	int
)	O
other	int
=	O
ppc64_decode_local_entry	function
(	O
other	int
)	O
;	O
snprintf	function
(	O
buf	pointer
,	O
sizeof	O
buf	pointer
,	O
_	O
(	O
"<localentry>: %d"	pointer
)	O
,	O
other	int
)	O
;	O
return	O
buf	pointer
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
const	O
char	O
*	O
get_symbol_other	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
int	O
other	int
)	O
{	O
const	O
char	O
*	O
result	pointer
=	O
NULL	O
;	O
static	O
char	O
buff	array
[	O
32	int
]	O
;	O
if	O
(	O
other	int
==	O
0	int
)	O
return	O
""	pointer
;	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
case	O
EM_ALPHA	int
:	O
result	pointer
=	O
get_alpha_symbol_other	function
(	O
other	int
)	O
;	O
break	O
;	O
case	O
EM_AARCH64	int
:	O
result	pointer
=	O
get_aarch64_symbol_other	function
(	O
other	int
)	O
;	O
break	O
;	O
case	O
EM_MIPS	int
:	O
result	pointer
=	O
get_mips_symbol_other	function
(	O
other	int
)	O
;	O
break	O
;	O
case	O
EM_IA_64	int
:	O
result	pointer
=	O
get_ia64_symbol_other	function
(	O
filedata	struct
,	O
other	int
)	O
;	O
break	O
;	O
case	O
EM_PPC64	int
:	O
result	pointer
=	O
get_ppc64_symbol_other	function
(	O
other	int
)	O
;	O
break	O
;	O
default	O
:	O
result	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
if	O
(	O
result	pointer
)	O
return	O
result	pointer
;	O
snprintf	function
(	O
buff	array
,	O
sizeof	O
buff	array
,	O
_	O
(	O
"<other>: %x"	pointer
)	O
,	O
other	int
)	O
;	O
return	O
buff	array
;	O
}	O
static	O
const	O
char	O
*	O
get_symbol_index_type	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
int	O
type	enum
)	O
{	O
static	O
char	O
buff	array
[	O
32	int
]	O
;	O
switch	O
(	O
type	enum
)	O
{	O
case	O
SHN_UNDEF	int
:	O
return	O
"UND"	pointer
;	O
case	O
SHN_ABS	O
:	O
return	O
"ABS"	pointer
;	O
case	O
SHN_COMMON	O
:	O
return	O
"COM"	pointer
;	O
default	O
:	O
if	O
(	O
type	enum
==	O
SHN_IA_64_ANSI_COMMON	O
&&	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_IA_64	int
&&	O
filedata	struct
->	O
file_header	struct
.	O
e_ident	array
[	O
EI_OSABI	int
]	O
==	O
ELFOSABI_HPUX	int
)	O
return	O
"ANSI_COM"	pointer
;	O
else	O
if	O
(	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_X86_64	int
||	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_L1OM	int
||	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_K1OM	int
)	O
&&	O
type	enum
==	O
SHN_X86_64_LCOMMON	O
)	O
return	O
"LARGE_COM"	pointer
;	O
else	O
if	O
(	O
(	O
type	enum
==	O
SHN_MIPS_SCOMMON	O
&&	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_MIPS	int
)	O
||	O
(	O
type	enum
==	O
SHN_TIC6X_SCOMMON	O
&&	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_TI_C6000	int
)	O
)	O
return	O
"SCOM"	pointer
;	O
else	O
if	O
(	O
type	enum
==	O
SHN_MIPS_SUNDEFINED	O
&&	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_MIPS	int
)	O
return	O
"SUND"	pointer
;	O
else	O
if	O
(	O
type	enum
>=	O
SHN_LOPROC	O
&&	O
type	enum
<=	O
SHN_HIPROC	O
)	O
sprintf	function
(	O
buff	array
,	O
"PRC[0x%04x]"	pointer
,	O
type	enum
&	O
0xffff	int
)	O
;	O
else	O
if	O
(	O
type	enum
>=	O
SHN_LOOS	O
&&	O
type	enum
<=	O
SHN_HIOS	O
)	O
sprintf	function
(	O
buff	array
,	O
"OS [0x%04x]"	pointer
,	O
type	enum
&	O
0xffff	int
)	O
;	O
else	O
if	O
(	O
type	enum
>=	O
SHN_LORESERVE	O
)	O
sprintf	function
(	O
buff	array
,	O
"RSV[0x%04x]"	pointer
,	O
type	enum
&	O
0xffff	int
)	O
;	O
else	O
if	O
(	O
type	enum
>=	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
)	O
sprintf	function
(	O
buff	array
,	O
_	O
(	O
"bad section index[%3d]"	pointer
)	O
,	O
type	enum
)	O
;	O
else	O
sprintf	function
(	O
buff	array
,	O
"%3d"	pointer
,	O
type	enum
)	O
;	O
break	O
;	O
}	O
return	O
buff	array
;	O
}	O
static	O
bfd_vma	long
*	O
get_dynamic_data	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
bfd_size_type	long
number	long
,	O
unsigned	O
int	O
ent_size	int
)	O
{	O
unsigned	O
char	O
*	O
e_data	pointer
;	O
bfd_vma	long
*	O
i_data	pointer
;	O
if	O
(	O
sizeof	O
(	O
size_t	long
)	O
<	O
sizeof	O
(	O
bfd_size_type	long
)	O
&&	O
(	O
bfd_size_type	long
)	O
(	O
(	O
size_t	long
)	O
number	long
)	O
!=	O
number	long
)	O
{	O
error	function
(	O
_	O
(	O
"Size truncation prevents reading %s elements of size %u\n"	pointer
)	O
,	O
bfd_vmatoa	function
(	O
"u"	pointer
,	O
number	long
)	O
,	O
ent_size	int
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
ent_size	int
*	O
number	long
>	O
filedata	struct
->	O
file_size	long
)	O
{	O
error	function
(	O
_	O
(	O
"Invalid number of dynamic entries: %s\n"	pointer
)	O
,	O
bfd_vmatoa	function
(	O
"u"	pointer
,	O
number	long
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
e_data	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
cmalloc	function
(	O
(	O
size_t	long
)	O
number	long
,	O
ent_size	int
)	O
;	O
if	O
(	O
e_data	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Out of memory reading %s dynamic entries\n"	pointer
)	O
,	O
bfd_vmatoa	function
(	O
"u"	pointer
,	O
number	long
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
fread	function
(	O
e_data	pointer
,	O
ent_size	int
,	O
(	O
size_t	long
)	O
number	long
,	O
filedata	struct
->	O
handle	pointer
)	O
!=	O
number	long
)	O
{	O
error	function
(	O
_	O
(	O
"Unable to read in %s bytes of dynamic data\n"	pointer
)	O
,	O
bfd_vmatoa	function
(	O
"u"	pointer
,	O
number	long
*	O
ent_size	int
)	O
)	O
;	O
free	function
(	O
e_data	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
i_data	pointer
=	O
(	O
bfd_vma	long
*	O
)	O
cmalloc	function
(	O
(	O
size_t	long
)	O
number	long
,	O
sizeof	O
(	O
*	O
i_data	pointer
)	O
)	O
;	O
if	O
(	O
i_data	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Out of memory allocating space for %s dynamic entries\n"	pointer
)	O
,	O
bfd_vmatoa	function
(	O
"u"	pointer
,	O
number	long
)	O
)	O
;	O
free	function
(	O
e_data	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
while	O
(	O
number	long
--	O
)	O
i_data	pointer
[	O
number	long
]	O
=	O
byte_get	pointer
(	O
e_data	pointer
+	O
number	long
*	O
ent_size	int
,	O
ent_size	int
)	O
;	O
free	function
(	O
e_data	pointer
)	O
;	O
return	O
i_data	pointer
;	O
}	O
static	O
void	O
print_dynamic_symbol	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
bfd_vma	long
si	long
,	O
unsigned	O
long	O
hn	long
)	O
{	O
Elf_Internal_Sym	struct
*	O
psym	pointer
;	O
int	O
n	long
;	O
n	long
=	O
print_vma	function
(	O
si	long
,	O
DEC_5	int
)	O
;	O
if	O
(	O
n	long
<	O
5	int
)	O
fputs	function
(	O
&	O
"     "	pointer
[	O
n	long
]	O
,	O
stdout	pointer
)	O
;	O
printf	function
(	O
" %3lu: "	pointer
,	O
hn	long
)	O
;	O
if	O
(	O
dynamic_symbols	pointer
==	O
NULL	O
||	O
si	long
>=	O
num_dynamic_syms	long
)	O
{	O
printf	function
(	O
_	O
(	O
"<No info available for dynamic symbol number %lu>\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
si	long
)	O
;	O
return	O
;	O
}	O
psym	pointer
=	O
dynamic_symbols	pointer
+	O
si	long
;	O
print_vma	function
(	O
psym	pointer
->	O
st_value	int
,	O
LONG_HEX	int
)	O
;	O
putchar	function
(	O
' '	O
)	O
;	O
print_vma	function
(	O
psym	pointer
->	O
st_size	long
,	O
DEC_5	int
)	O
;	O
printf	function
(	O
" %-7s"	pointer
,	O
get_symbol_type	function
(	O
filedata	struct
,	O
ELF_ST_TYPE	O
(	O
psym	pointer
->	O
st_info	array
)	O
)	O
)	O
;	O
printf	function
(	O
" %-6s"	pointer
,	O
get_symbol_binding	function
(	O
filedata	struct
,	O
ELF_ST_BIND	O
(	O
psym	pointer
->	O
st_info	array
)	O
)	O
)	O
;	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_ident	array
[	O
EI_OSABI	int
]	O
==	O
ELFOSABI_SOLARIS	int
)	O
printf	function
(	O
" %-7s"	pointer
,	O
get_solaris_symbol_visibility	function
(	O
psym	pointer
->	O
st_other	array
)	O
)	O
;	O
else	O
{	O
unsigned	O
int	O
vis	int
=	O
ELF_ST_VISIBILITY	O
(	O
psym	pointer
->	O
st_other	array
)	O
;	O
printf	function
(	O
" %-7s"	pointer
,	O
get_symbol_visibility	function
(	O
vis	int
)	O
)	O
;	O
if	O
(	O
psym	pointer
->	O
st_other	array
^	O
vis	int
)	O
printf	function
(	O
" [%s] "	pointer
,	O
get_symbol_other	function
(	O
filedata	struct
,	O
psym	pointer
->	O
st_other	array
^	O
vis	int
)	O
)	O
;	O
}	O
printf	function
(	O
" %3.3s "	pointer
,	O
get_symbol_index_type	function
(	O
filedata	struct
,	O
psym	pointer
->	O
st_shndx	int
)	O
)	O
;	O
if	O
(	O
VALID_DYNAMIC_NAME	O
(	O
psym	pointer
->	O
st_name	pointer
)	O
)	O
print_symbol	function
(	O
25	int
,	O
GET_DYNAMIC_NAME	O
(	O
psym	pointer
->	O
st_name	pointer
)	O
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
" <corrupt: %14ld>"	pointer
)	O
,	O
psym	pointer
->	O
st_name	pointer
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
static	O
const	O
char	O
*	O
get_symbol_version_string	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
bfd_boolean	int
is_dynsym	int
,	O
const	O
char	O
*	O
strtab	pointer
,	O
unsigned	O
long	O
int	O
strtab_size	long
,	O
unsigned	O
int	O
si	long
,	O
Elf_Internal_Sym	struct
*	O
psym	pointer
,	O
enum	O
versioned_symbol_info	enum
*	O
sym_info	enum
,	O
unsigned	O
short	O
*	O
vna_other	array
)	O
{	O
unsigned	O
char	O
data	pointer
[	O
2	int
]	O
;	O
unsigned	O
short	O
vers_data	short
;	O
unsigned	O
long	O
offset	long
;	O
unsigned	O
short	O
max_vd_ndx	short
;	O
if	O
(	O
!	O
is_dynsym	int
||	O
version_info	array
[	O
DT_VERSIONTAGIDX	O
(	O
DT_VERSYM	int
)	O
]	O
==	O
0	int
)	O
return	O
NULL	O
;	O
offset	long
=	O
offset_from_vma	function
(	O
filedata	struct
,	O
version_info	array
[	O
DT_VERSIONTAGIDX	O
(	O
DT_VERSYM	int
)	O
]	O
,	O
sizeof	O
data	pointer
+	O
si	long
*	O
sizeof	O
(	O
vers_data	short
)	O
)	O
;	O
if	O
(	O
get_data	function
(	O
&	O
data	pointer
,	O
filedata	struct
,	O
offset	long
+	O
si	long
*	O
sizeof	O
(	O
vers_data	short
)	O
,	O
sizeof	O
(	O
data	pointer
)	O
,	O
1	int
,	O
_	O
(	O
"version data"	pointer
)	O
)	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
vers_data	short
=	O
byte_get	pointer
(	O
data	pointer
,	O
2	int
)	O
;	O
if	O
(	O
(	O
vers_data	short
&	O
VERSYM_HIDDEN	int
)	O
==	O
0	int
&&	O
vers_data	short
==	O
0	int
)	O
return	O
NULL	O
;	O
*	O
sym_info	enum
=	O
(	O
vers_data	short
&	O
VERSYM_HIDDEN	int
)	O
!=	O
0	int
?	O
symbol_hidden	int
:	O
symbol_public	int
;	O
max_vd_ndx	short
=	O
0	int
;	O
if	O
(	O
psym	pointer
->	O
st_shndx	int
!=	O
SHN_UNDEF	int
&&	O
vers_data	short
!=	O
0x8001	int
&&	O
version_info	array
[	O
DT_VERSIONTAGIDX	O
(	O
DT_VERDEF	int
)	O
]	O
)	O
{	O
Elf_Internal_Verdef	struct
ivd	struct
;	O
Elf_Internal_Verdaux	struct
ivda	struct
;	O
Elf_External_Verdaux	struct
evda	struct
;	O
unsigned	O
long	O
off	long
;	O
off	long
=	O
offset_from_vma	function
(	O
filedata	struct
,	O
version_info	array
[	O
DT_VERSIONTAGIDX	O
(	O
DT_VERDEF	int
)	O
]	O
,	O
sizeof	O
(	O
Elf_External_Verdef	struct
)	O
)	O
;	O
do	O
{	O
Elf_External_Verdef	struct
evd	struct
;	O
if	O
(	O
get_data	function
(	O
&	O
evd	struct
,	O
filedata	struct
,	O
off	long
,	O
sizeof	O
(	O
evd	struct
)	O
,	O
1	int
,	O
_	O
(	O
"version def"	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
ivd	struct
.	O
vd_ndx	array
=	O
0	int
;	O
ivd	struct
.	O
vd_aux	array
=	O
0	int
;	O
ivd	struct
.	O
vd_next	array
=	O
0	int
;	O
ivd	struct
.	O
vd_flags	array
=	O
0	int
;	O
}	O
else	O
{	O
ivd	struct
.	O
vd_ndx	array
=	O
BYTE_GET	O
(	O
evd	struct
.	O
vd_ndx	array
)	O
;	O
ivd	struct
.	O
vd_aux	array
=	O
BYTE_GET	O
(	O
evd	struct
.	O
vd_aux	array
)	O
;	O
ivd	struct
.	O
vd_next	array
=	O
BYTE_GET	O
(	O
evd	struct
.	O
vd_next	array
)	O
;	O
ivd	struct
.	O
vd_flags	array
=	O
BYTE_GET	O
(	O
evd	struct
.	O
vd_flags	array
)	O
;	O
}	O
if	O
(	O
(	O
ivd	struct
.	O
vd_ndx	array
&	O
VERSYM_VERSION	int
)	O
>	O
max_vd_ndx	short
)	O
max_vd_ndx	short
=	O
ivd	struct
.	O
vd_ndx	array
&	O
VERSYM_VERSION	int
;	O
off	long
+=	O
ivd	struct
.	O
vd_next	array
;	O
}	O
while	O
(	O
ivd	struct
.	O
vd_ndx	array
!=	O
(	O
vers_data	short
&	O
VERSYM_VERSION	int
)	O
&&	O
ivd	struct
.	O
vd_next	array
!=	O
0	int
)	O
;	O
if	O
(	O
ivd	struct
.	O
vd_ndx	array
==	O
(	O
vers_data	short
&	O
VERSYM_VERSION	int
)	O
)	O
{	O
if	O
(	O
ivd	struct
.	O
vd_ndx	array
==	O
1	int
&&	O
ivd	struct
.	O
vd_flags	array
==	O
VER_FLG_BASE	int
)	O
return	O
NULL	O
;	O
off	long
-=	O
ivd	struct
.	O
vd_next	array
;	O
off	long
+=	O
ivd	struct
.	O
vd_aux	array
;	O
if	O
(	O
get_data	function
(	O
&	O
evda	struct
,	O
filedata	struct
,	O
off	long
,	O
sizeof	O
(	O
evda	struct
)	O
,	O
1	int
,	O
_	O
(	O
"version def aux"	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
ivda	struct
.	O
vda_name	array
=	O
BYTE_GET	O
(	O
evda	struct
.	O
vda_name	array
)	O
;	O
if	O
(	O
psym	pointer
->	O
st_name	pointer
!=	O
ivda	struct
.	O
vda_name	array
)	O
return	O
(	O
ivda	struct
.	O
vda_name	array
<	O
strtab_size	long
?	O
strtab	pointer
+	O
ivda	struct
.	O
vda_name	array
:	O
_	O
(	O
"<corrupt>"	pointer
)	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
version_info	array
[	O
DT_VERSIONTAGIDX	O
(	O
DT_VERNEED	int
)	O
]	O
)	O
{	O
Elf_External_Verneed	struct
evn	struct
;	O
Elf_Internal_Verneed	struct
ivn	struct
;	O
Elf_Internal_Vernaux	struct
ivna	struct
;	O
offset	long
=	O
offset_from_vma	function
(	O
filedata	struct
,	O
version_info	array
[	O
DT_VERSIONTAGIDX	O
(	O
DT_VERNEED	int
)	O
]	O
,	O
sizeof	O
evn	struct
)	O
;	O
do	O
{	O
unsigned	O
long	O
vna_off	long
;	O
if	O
(	O
get_data	function
(	O
&	O
evn	struct
,	O
filedata	struct
,	O
offset	long
,	O
sizeof	O
(	O
evn	struct
)	O
,	O
1	int
,	O
_	O
(	O
"version need"	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
ivna	struct
.	O
vna_next	array
=	O
0	int
;	O
ivna	struct
.	O
vna_other	array
=	O
0	int
;	O
ivna	struct
.	O
vna_name	array
=	O
0	int
;	O
break	O
;	O
}	O
ivn	struct
.	O
vn_aux	array
=	O
BYTE_GET	O
(	O
evn	struct
.	O
vn_aux	array
)	O
;	O
ivn	struct
.	O
vn_next	array
=	O
BYTE_GET	O
(	O
evn	struct
.	O
vn_next	array
)	O
;	O
vna_off	long
=	O
offset	long
+	O
ivn	struct
.	O
vn_aux	array
;	O
do	O
{	O
Elf_External_Vernaux	struct
evna	struct
;	O
if	O
(	O
get_data	function
(	O
&	O
evna	struct
,	O
filedata	struct
,	O
vna_off	long
,	O
sizeof	O
(	O
evna	struct
)	O
,	O
1	int
,	O
_	O
(	O
"version need aux (3)"	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
ivna	struct
.	O
vna_next	array
=	O
0	int
;	O
ivna	struct
.	O
vna_other	array
=	O
0	int
;	O
ivna	struct
.	O
vna_name	array
=	O
0	int
;	O
}	O
else	O
{	O
ivna	struct
.	O
vna_other	array
=	O
BYTE_GET	O
(	O
evna	struct
.	O
vna_other	array
)	O
;	O
ivna	struct
.	O
vna_next	array
=	O
BYTE_GET	O
(	O
evna	struct
.	O
vna_next	array
)	O
;	O
ivna	struct
.	O
vna_name	array
=	O
BYTE_GET	O
(	O
evna	struct
.	O
vna_name	array
)	O
;	O
}	O
vna_off	long
+=	O
ivna	struct
.	O
vna_next	array
;	O
}	O
while	O
(	O
ivna	struct
.	O
vna_other	array
!=	O
vers_data	short
&&	O
ivna	struct
.	O
vna_next	array
!=	O
0	int
)	O
;	O
if	O
(	O
ivna	struct
.	O
vna_other	array
==	O
vers_data	short
)	O
break	O
;	O
offset	long
+=	O
ivn	struct
.	O
vn_next	array
;	O
}	O
while	O
(	O
ivn	struct
.	O
vn_next	array
!=	O
0	int
)	O
;	O
if	O
(	O
ivna	struct
.	O
vna_other	array
==	O
vers_data	short
)	O
{	O
*	O
sym_info	enum
=	O
symbol_undefined	int
;	O
*	O
vna_other	array
=	O
ivna	struct
.	O
vna_other	array
;	O
return	O
(	O
ivna	struct
.	O
vna_name	array
<	O
strtab_size	long
?	O
strtab	pointer
+	O
ivna	struct
.	O
vna_name	array
:	O
_	O
(	O
"<corrupt>"	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
(	O
max_vd_ndx	short
||	O
(	O
vers_data	short
&	O
VERSYM_VERSION	int
)	O
!=	O
1	int
)	O
&&	O
(	O
vers_data	short
&	O
VERSYM_VERSION	int
)	O
>	O
max_vd_ndx	short
)	O
return	O
_	O
(	O
"<corrupt>"	pointer
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
bfd_boolean	int
process_symbol_table	function
(	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
Elf_Internal_Shdr	struct
*	O
section	pointer
;	O
bfd_size_type	long
nbuckets	long
=	O
0	int
;	O
bfd_size_type	long
nchains	long
=	O
0	int
;	O
bfd_vma	long
*	O
buckets	pointer
=	O
NULL	O
;	O
bfd_vma	long
*	O
chains	pointer
=	O
NULL	O
;	O
bfd_vma	long
ngnubuckets	long
=	O
0	int
;	O
bfd_vma	long
*	O
gnubuckets	pointer
=	O
NULL	O
;	O
bfd_vma	long
*	O
gnuchains	pointer
=	O
NULL	O
;	O
bfd_vma	long
*	O
mipsxlat	pointer
=	O
NULL	O
;	O
bfd_vma	long
gnusymidx	long
=	O
0	int
;	O
bfd_size_type	long
ngnuchains	long
=	O
0	int
;	O
if	O
(	O
!	O
do_syms	int
&&	O
!	O
do_dyn_syms	int
&&	O
!	O
do_histogram	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
dynamic_info	array
[	O
DT_HASH	int
]	O
&&	O
(	O
do_histogram	int
||	O
(	O
do_using_dynamic	int
&&	O
!	O
do_dyn_syms	int
&&	O
dynamic_strings	pointer
!=	O
NULL	O
)	O
)	O
)	O
{	O
unsigned	O
char	O
nb	array
[	O
8	int
]	O
;	O
unsigned	O
char	O
nc	int
[	O
8	int
]	O
;	O
unsigned	O
int	O
hash_ent_size	int
=	O
4	int
;	O
if	O
(	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_ALPHA	int
||	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_S390	int
||	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_S390_OLD	int
)	O
&&	O
filedata	struct
->	O
file_header	struct
.	O
e_ident	array
[	O
EI_CLASS	int
]	O
==	O
ELFCLASS64	int
)	O
hash_ent_size	int
=	O
8	int
;	O
if	O
(	O
fseek	function
(	O
filedata	struct
->	O
handle	pointer
,	O
(	O
archive_file_offset	long
+	O
offset_from_vma	function
(	O
filedata	struct
,	O
dynamic_info	array
[	O
DT_HASH	int
]	O
,	O
sizeof	O
nb	array
+	O
sizeof	O
nc	int
)	O
)	O
,	O
SEEK_SET	int
)	O
)	O
{	O
error	function
(	O
_	O
(	O
"Unable to seek to start of dynamic information\n"	pointer
)	O
)	O
;	O
goto	O
no_hash	O
;	O
}	O
if	O
(	O
fread	function
(	O
nb	array
,	O
hash_ent_size	int
,	O
1	int
,	O
filedata	struct
->	O
handle	pointer
)	O
!=	O
1	int
)	O
{	O
error	function
(	O
_	O
(	O
"Failed to read in number of buckets\n"	pointer
)	O
)	O
;	O
goto	O
no_hash	O
;	O
}	O
if	O
(	O
fread	function
(	O
nc	int
,	O
hash_ent_size	int
,	O
1	int
,	O
filedata	struct
->	O
handle	pointer
)	O
!=	O
1	int
)	O
{	O
error	function
(	O
_	O
(	O
"Failed to read in number of chains\n"	pointer
)	O
)	O
;	O
goto	O
no_hash	O
;	O
}	O
nbuckets	long
=	O
byte_get	pointer
(	O
nb	array
,	O
hash_ent_size	int
)	O
;	O
nchains	long
=	O
byte_get	pointer
(	O
nc	int
,	O
hash_ent_size	int
)	O
;	O
buckets	pointer
=	O
get_dynamic_data	function
(	O
filedata	struct
,	O
nbuckets	long
,	O
hash_ent_size	int
)	O
;	O
chains	pointer
=	O
get_dynamic_data	function
(	O
filedata	struct
,	O
nchains	long
,	O
hash_ent_size	int
)	O
;	O
no_hash	O
:	O
if	O
(	O
buckets	pointer
==	O
NULL	O
||	O
chains	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
do_using_dynamic	int
)	O
return	O
FALSE	int
;	O
free	function
(	O
buckets	pointer
)	O
;	O
free	function
(	O
chains	pointer
)	O
;	O
buckets	pointer
=	O
NULL	O
;	O
chains	pointer
=	O
NULL	O
;	O
nbuckets	long
=	O
0	int
;	O
nchains	long
=	O
0	int
;	O
}	O
}	O
if	O
(	O
dynamic_info_DT_GNU_HASH	long
&&	O
(	O
do_histogram	int
||	O
(	O
do_using_dynamic	int
&&	O
!	O
do_dyn_syms	int
&&	O
dynamic_strings	pointer
!=	O
NULL	O
)	O
)	O
)	O
{	O
unsigned	O
char	O
nb	array
[	O
16	int
]	O
;	O
bfd_vma	long
i	pointer
,	O
maxchain	long
=	O
0xffffffff	int
,	O
bitmaskwords	long
;	O
bfd_vma	long
buckets_vma	long
;	O
if	O
(	O
fseek	function
(	O
filedata	struct
->	O
handle	pointer
,	O
(	O
archive_file_offset	long
+	O
offset_from_vma	function
(	O
filedata	struct
,	O
dynamic_info_DT_GNU_HASH	long
,	O
sizeof	O
nb	array
)	O
)	O
,	O
SEEK_SET	int
)	O
)	O
{	O
error	function
(	O
_	O
(	O
"Unable to seek to start of dynamic information\n"	pointer
)	O
)	O
;	O
goto	O
no_gnu_hash	O
;	O
}	O
if	O
(	O
fread	function
(	O
nb	array
,	O
16	int
,	O
1	int
,	O
filedata	struct
->	O
handle	pointer
)	O
!=	O
1	int
)	O
{	O
error	function
(	O
_	O
(	O
"Failed to read in number of buckets\n"	pointer
)	O
)	O
;	O
goto	O
no_gnu_hash	O
;	O
}	O
ngnubuckets	long
=	O
byte_get	pointer
(	O
nb	array
,	O
4	int
)	O
;	O
gnusymidx	long
=	O
byte_get	pointer
(	O
nb	array
+	O
4	int
,	O
4	int
)	O
;	O
bitmaskwords	long
=	O
byte_get	pointer
(	O
nb	array
+	O
8	int
,	O
4	int
)	O
;	O
buckets_vma	long
=	O
dynamic_info_DT_GNU_HASH	long
+	O
16	int
;	O
if	O
(	O
is_32bit_elf	int
)	O
buckets_vma	long
+=	O
bitmaskwords	long
*	O
4	int
;	O
else	O
buckets_vma	long
+=	O
bitmaskwords	long
*	O
8	int
;	O
if	O
(	O
fseek	function
(	O
filedata	struct
->	O
handle	pointer
,	O
(	O
archive_file_offset	long
+	O
offset_from_vma	function
(	O
filedata	struct
,	O
buckets_vma	long
,	O
4	int
)	O
)	O
,	O
SEEK_SET	int
)	O
)	O
{	O
error	function
(	O
_	O
(	O
"Unable to seek to start of dynamic information\n"	pointer
)	O
)	O
;	O
goto	O
no_gnu_hash	O
;	O
}	O
gnubuckets	pointer
=	O
get_dynamic_data	function
(	O
filedata	struct
,	O
ngnubuckets	long
,	O
4	int
)	O
;	O
if	O
(	O
gnubuckets	pointer
==	O
NULL	O
)	O
goto	O
no_gnu_hash	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
ngnubuckets	long
;	O
i	pointer
++	O
)	O
if	O
(	O
gnubuckets	pointer
[	O
i	pointer
]	O
!=	O
0	int
)	O
{	O
if	O
(	O
gnubuckets	pointer
[	O
i	pointer
]	O
<	O
gnusymidx	long
)	O
return	O
FALSE	int
;	O
if	O
(	O
maxchain	long
==	O
0xffffffff	int
||	O
gnubuckets	pointer
[	O
i	pointer
]	O
>	O
maxchain	long
)	O
maxchain	long
=	O
gnubuckets	pointer
[	O
i	pointer
]	O
;	O
}	O
if	O
(	O
maxchain	long
==	O
0xffffffff	int
)	O
goto	O
no_gnu_hash	O
;	O
maxchain	long
-=	O
gnusymidx	long
;	O
if	O
(	O
fseek	function
(	O
filedata	struct
->	O
handle	pointer
,	O
(	O
archive_file_offset	long
+	O
offset_from_vma	function
(	O
filedata	struct
,	O
buckets_vma	long
+	O
4	int
*	O
(	O
ngnubuckets	long
+	O
maxchain	long
)	O
,	O
4	int
)	O
)	O
,	O
SEEK_SET	int
)	O
)	O
{	O
error	function
(	O
_	O
(	O
"Unable to seek to start of dynamic information\n"	pointer
)	O
)	O
;	O
goto	O
no_gnu_hash	O
;	O
}	O
do	O
{	O
if	O
(	O
fread	function
(	O
nb	array
,	O
4	int
,	O
1	int
,	O
filedata	struct
->	O
handle	pointer
)	O
!=	O
1	int
)	O
{	O
error	function
(	O
_	O
(	O
"Failed to determine last chain length\n"	pointer
)	O
)	O
;	O
goto	O
no_gnu_hash	O
;	O
}	O
if	O
(	O
maxchain	long
+	O
1	int
==	O
0	int
)	O
goto	O
no_gnu_hash	O
;	O
++	O
maxchain	long
;	O
}	O
while	O
(	O
(	O
byte_get	pointer
(	O
nb	array
,	O
4	int
)	O
&	O
1	int
)	O
==	O
0	int
)	O
;	O
if	O
(	O
fseek	function
(	O
filedata	struct
->	O
handle	pointer
,	O
(	O
archive_file_offset	long
+	O
offset_from_vma	function
(	O
filedata	struct
,	O
buckets_vma	long
+	O
4	int
*	O
ngnubuckets	long
,	O
4	int
)	O
)	O
,	O
SEEK_SET	int
)	O
)	O
{	O
error	function
(	O
_	O
(	O
"Unable to seek to start of dynamic information\n"	pointer
)	O
)	O
;	O
goto	O
no_gnu_hash	O
;	O
}	O
gnuchains	pointer
=	O
get_dynamic_data	function
(	O
filedata	struct
,	O
maxchain	long
,	O
4	int
)	O
;	O
ngnuchains	long
=	O
maxchain	long
;	O
if	O
(	O
gnuchains	pointer
==	O
NULL	O
)	O
goto	O
no_gnu_hash	O
;	O
if	O
(	O
dynamic_info_DT_MIPS_XHASH	long
)	O
{	O
if	O
(	O
fseek	function
(	O
filedata	struct
->	O
handle	pointer
,	O
(	O
archive_file_offset	long
+	O
offset_from_vma	function
(	O
filedata	struct
,	O
(	O
buckets_vma	long
+	O
4	int
*	O
(	O
ngnubuckets	long
+	O
maxchain	long
)	O
)	O
,	O
4	int
)	O
)	O
,	O
SEEK_SET	int
)	O
)	O
{	O
error	function
(	O
_	O
(	O
"Unable to seek to start of dynamic information\n"	pointer
)	O
)	O
;	O
goto	O
no_gnu_hash	O
;	O
}	O
mipsxlat	pointer
=	O
get_dynamic_data	function
(	O
filedata	struct
,	O
maxchain	long
,	O
4	int
)	O
;	O
}	O
no_gnu_hash	O
:	O
if	O
(	O
dynamic_info_DT_MIPS_XHASH	long
&&	O
mipsxlat	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
gnuchains	pointer
)	O
;	O
gnuchains	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
gnuchains	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
gnubuckets	pointer
)	O
;	O
gnubuckets	pointer
=	O
NULL	O
;	O
ngnubuckets	long
=	O
0	int
;	O
if	O
(	O
do_using_dynamic	int
)	O
return	O
FALSE	int
;	O
}	O
}	O
if	O
(	O
(	O
dynamic_info	array
[	O
DT_HASH	int
]	O
||	O
dynamic_info_DT_GNU_HASH	long
)	O
&&	O
do_syms	int
&&	O
do_using_dynamic	int
&&	O
dynamic_strings	pointer
!=	O
NULL	O
&&	O
dynamic_symbols	pointer
!=	O
NULL	O
)	O
{	O
unsigned	O
long	O
hn	long
;	O
if	O
(	O
dynamic_info	array
[	O
DT_HASH	int
]	O
)	O
{	O
bfd_vma	long
si	long
;	O
char	O
*	O
visited	pointer
;	O
printf	function
(	O
_	O
(	O
"\nSymbol table for image:\n"	pointer
)	O
)	O
;	O
if	O
(	O
is_32bit_elf	int
)	O
printf	function
(	O
_	O
(	O
"  Num Buc:    Value  Size   Type   Bind Vis      Ndx Name\n"	pointer
)	O
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"  Num Buc:    Value          Size   Type   Bind Vis      Ndx Name\n"	pointer
)	O
)	O
;	O
visited	pointer
=	O
xcmalloc	function
(	O
nchains	long
,	O
1	int
)	O
;	O
memset	function
(	O
visited	pointer
,	O
0	int
,	O
nchains	long
)	O
;	O
for	O
(	O
hn	long
=	O
0	int
;	O
hn	long
<	O
nbuckets	long
;	O
hn	long
++	O
)	O
{	O
for	O
(	O
si	long
=	O
buckets	pointer
[	O
hn	long
]	O
;	O
si	long
>	O
0	int
;	O
si	long
=	O
chains	pointer
[	O
si	long
]	O
)	O
{	O
print_dynamic_symbol	function
(	O
filedata	struct
,	O
si	long
,	O
hn	long
)	O
;	O
if	O
(	O
si	long
>=	O
nchains	long
||	O
visited	pointer
[	O
si	long
]	O
)	O
{	O
error	function
(	O
_	O
(	O
"histogram chain is corrupt\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
visited	pointer
[	O
si	long
]	O
=	O
1	int
;	O
}	O
}	O
free	function
(	O
visited	pointer
)	O
;	O
}	O
if	O
(	O
dynamic_info_DT_GNU_HASH	long
)	O
{	O
printf	function
(	O
_	O
(	O
"\nSymbol table of `%s' for image:\n"	pointer
)	O
,	O
GNU_HASH_SECTION_NAME	O
)	O
;	O
if	O
(	O
is_32bit_elf	int
)	O
printf	function
(	O
_	O
(	O
"  Num Buc:    Value  Size   Type   Bind Vis      Ndx Name\n"	pointer
)	O
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"  Num Buc:    Value          Size   Type   Bind Vis      Ndx Name\n"	pointer
)	O
)	O
;	O
for	O
(	O
hn	long
=	O
0	int
;	O
hn	long
<	O
ngnubuckets	long
;	O
++	O
hn	long
)	O
if	O
(	O
gnubuckets	pointer
[	O
hn	long
]	O
!=	O
0	int
)	O
{	O
bfd_vma	long
si	long
=	O
gnubuckets	pointer
[	O
hn	long
]	O
;	O
bfd_vma	long
off	long
=	O
si	long
-	O
gnusymidx	long
;	O
do	O
{	O
if	O
(	O
dynamic_info_DT_MIPS_XHASH	long
)	O
print_dynamic_symbol	function
(	O
filedata	struct
,	O
mipsxlat	pointer
[	O
off	long
]	O
,	O
hn	long
)	O
;	O
else	O
print_dynamic_symbol	function
(	O
filedata	struct
,	O
si	long
,	O
hn	long
)	O
;	O
si	long
++	O
;	O
}	O
while	O
(	O
off	long
<	O
ngnuchains	long
&&	O
(	O
gnuchains	pointer
[	O
off	long
++	O
]	O
&	O
1	int
)	O
==	O
0	int
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
(	O
do_dyn_syms	int
||	O
(	O
do_syms	int
&&	O
!	O
do_using_dynamic	int
)	O
)	O
&&	O
filedata	struct
->	O
section_headers	pointer
!=	O
NULL	O
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
,	O
section	pointer
=	O
filedata	struct
->	O
section_headers	pointer
;	O
i	pointer
<	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
;	O
i	pointer
++	O
,	O
section	pointer
++	O
)	O
{	O
unsigned	O
int	O
si	long
;	O
char	O
*	O
strtab	pointer
=	O
NULL	O
;	O
unsigned	O
long	O
int	O
strtab_size	long
=	O
0	int
;	O
Elf_Internal_Sym	struct
*	O
symtab	pointer
;	O
Elf_Internal_Sym	struct
*	O
psym	pointer
;	O
unsigned	O
long	O
num_syms	long
;	O
if	O
(	O
(	O
section	pointer
->	O
sh_type	array
!=	O
SHT_SYMTAB	int
&&	O
section	pointer
->	O
sh_type	array
!=	O
SHT_DYNSYM	int
)	O
||	O
(	O
!	O
do_syms	int
&&	O
section	pointer
->	O
sh_type	array
==	O
SHT_SYMTAB	int
)	O
)	O
continue	O
;	O
if	O
(	O
section	pointer
->	O
sh_entsize	array
==	O
0	int
)	O
{	O
printf	function
(	O
_	O
(	O
"\nSymbol table '%s' has a sh_entsize of zero!\n"	pointer
)	O
,	O
printable_section_name	function
(	O
filedata	struct
,	O
section	pointer
)	O
)	O
;	O
continue	O
;	O
}	O
num_syms	long
=	O
section	pointer
->	O
sh_size	array
/	O
section	pointer
->	O
sh_entsize	array
;	O
printf	function
(	O
ngettext	function
(	O
"\nSymbol table '%s' contains %lu entry:\n"	pointer
,	O
"\nSymbol table '%s' contains %lu entries:\n"	pointer
,	O
num_syms	long
)	O
,	O
printable_section_name	function
(	O
filedata	struct
,	O
section	pointer
)	O
,	O
num_syms	long
)	O
;	O
if	O
(	O
is_32bit_elf	int
)	O
printf	function
(	O
_	O
(	O
"   Num:    Value  Size Type    Bind   Vis      Ndx Name\n"	pointer
)	O
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"   Num:    Value          Size Type    Bind   Vis      Ndx Name\n"	pointer
)	O
)	O
;	O
symtab	pointer
=	O
GET_ELF_SYMBOLS	O
(	O
filedata	struct
,	O
section	pointer
,	O
&	O
num_syms	long
)	O
;	O
if	O
(	O
symtab	pointer
==	O
NULL	O
)	O
continue	O
;	O
if	O
(	O
section	pointer
->	O
sh_link	array
==	O
filedata	struct
->	O
file_header	struct
.	O
e_shstrndx	array
)	O
{	O
strtab	pointer
=	O
filedata	struct
->	O
string_table	pointer
;	O
strtab_size	long
=	O
filedata	struct
->	O
string_table_length	long
;	O
}	O
else	O
if	O
(	O
section	pointer
->	O
sh_link	array
<	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
)	O
{	O
Elf_Internal_Shdr	struct
*	O
string_sec	pointer
;	O
string_sec	pointer
=	O
filedata	struct
->	O
section_headers	pointer
+	O
section	pointer
->	O
sh_link	array
;	O
strtab	pointer
=	O
(	O
char	O
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
string_sec	pointer
->	O
sh_offset	array
,	O
1	int
,	O
string_sec	pointer
->	O
sh_size	array
,	O
_	O
(	O
"string table"	pointer
)	O
)	O
;	O
strtab_size	long
=	O
strtab	pointer
!=	O
NULL	O
?	O
string_sec	pointer
->	O
sh_size	array
:	O
0	int
;	O
}	O
for	O
(	O
si	long
=	O
0	int
,	O
psym	pointer
=	O
symtab	pointer
;	O
si	long
<	O
num_syms	long
;	O
si	long
++	O
,	O
psym	pointer
++	O
)	O
{	O
const	O
char	O
*	O
version_string	pointer
;	O
enum	O
versioned_symbol_info	enum
sym_info	enum
;	O
unsigned	O
short	O
vna_other	array
;	O
printf	function
(	O
"%6d: "	pointer
,	O
si	long
)	O
;	O
print_vma	function
(	O
psym	pointer
->	O
st_value	int
,	O
LONG_HEX	int
)	O
;	O
putchar	function
(	O
' '	O
)	O
;	O
print_vma	function
(	O
psym	pointer
->	O
st_size	long
,	O
DEC_5	int
)	O
;	O
printf	function
(	O
" %-7s"	pointer
,	O
get_symbol_type	function
(	O
filedata	struct
,	O
ELF_ST_TYPE	O
(	O
psym	pointer
->	O
st_info	array
)	O
)	O
)	O
;	O
printf	function
(	O
" %-6s"	pointer
,	O
get_symbol_binding	function
(	O
filedata	struct
,	O
ELF_ST_BIND	O
(	O
psym	pointer
->	O
st_info	array
)	O
)	O
)	O
;	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_ident	array
[	O
EI_OSABI	int
]	O
==	O
ELFOSABI_SOLARIS	int
)	O
printf	function
(	O
" %-7s"	pointer
,	O
get_solaris_symbol_visibility	function
(	O
psym	pointer
->	O
st_other	array
)	O
)	O
;	O
else	O
{	O
unsigned	O
int	O
vis	int
=	O
ELF_ST_VISIBILITY	O
(	O
psym	pointer
->	O
st_other	array
)	O
;	O
printf	function
(	O
" %-7s"	pointer
,	O
get_symbol_visibility	function
(	O
vis	int
)	O
)	O
;	O
if	O
(	O
psym	pointer
->	O
st_other	array
^	O
vis	int
)	O
printf	function
(	O
" [%s] "	pointer
,	O
get_symbol_other	function
(	O
filedata	struct
,	O
psym	pointer
->	O
st_other	array
^	O
vis	int
)	O
)	O
;	O
}	O
printf	function
(	O
" %4s "	pointer
,	O
get_symbol_index_type	function
(	O
filedata	struct
,	O
psym	pointer
->	O
st_shndx	int
)	O
)	O
;	O
print_symbol	function
(	O
25	int
,	O
psym	pointer
->	O
st_name	pointer
<	O
strtab_size	long
?	O
strtab	pointer
+	O
psym	pointer
->	O
st_name	pointer
:	O
_	O
(	O
"<corrupt>"	pointer
)	O
)	O
;	O
version_string	pointer
=	O
get_symbol_version_string	function
(	O
filedata	struct
,	O
section	pointer
->	O
sh_type	array
==	O
SHT_DYNSYM	int
,	O
strtab	pointer
,	O
strtab_size	long
,	O
si	long
,	O
psym	pointer
,	O
&	O
sym_info	enum
,	O
&	O
vna_other	array
)	O
;	O
if	O
(	O
version_string	pointer
)	O
{	O
if	O
(	O
sym_info	enum
==	O
symbol_undefined	int
)	O
printf	function
(	O
"@%s (%d)"	pointer
,	O
version_string	pointer
,	O
vna_other	array
)	O
;	O
else	O
printf	function
(	O
sym_info	enum
==	O
symbol_hidden	int
?	O
"@%s"	pointer
:	O
"@@%s"	pointer
,	O
version_string	pointer
)	O
;	O
}	O
putchar	function
(	O
'\n'	O
)	O
;	O
if	O
(	O
ELF_ST_BIND	O
(	O
psym	pointer
->	O
st_info	array
)	O
==	O
STB_LOCAL	int
&&	O
si	long
>=	O
section	pointer
->	O
sh_info	array
&&	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
!=	O
EM_MIPS	int
&&	O
filedata	struct
->	O
file_header	struct
.	O
e_ident	array
[	O
EI_OSABI	int
]	O
!=	O
ELFOSABI_SOLARIS	int
)	O
warn	function
(	O
_	O
(	O
"local symbol %u found at index >= %s's sh_info value of %u\n"	pointer
)	O
,	O
si	long
,	O
printable_section_name	function
(	O
filedata	struct
,	O
section	pointer
)	O
,	O
section	pointer
->	O
sh_info	array
)	O
;	O
}	O
free	function
(	O
symtab	pointer
)	O
;	O
if	O
(	O
strtab	pointer
!=	O
filedata	struct
->	O
string_table	pointer
)	O
free	function
(	O
strtab	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
do_syms	int
)	O
printf	function
(	O
_	O
(	O
"\nDynamic symbol information is not available for displaying symbols.\n"	pointer
)	O
)	O
;	O
if	O
(	O
do_histogram	int
&&	O
buckets	pointer
!=	O
NULL	O
)	O
{	O
unsigned	O
long	O
*	O
lengths	pointer
;	O
unsigned	O
long	O
*	O
counts	pointer
;	O
unsigned	O
long	O
hn	long
;	O
bfd_vma	long
si	long
;	O
unsigned	O
long	O
maxlength	long
=	O
0	int
;	O
unsigned	O
long	O
nzero_counts	long
=	O
0	int
;	O
unsigned	O
long	O
nsyms	long
=	O
0	int
;	O
char	O
*	O
visited	pointer
;	O
printf	function
(	O
ngettext	function
(	O
"\nHistogram for bucket list length "	pointer
"(total of %lu bucket):\n"	pointer
,	O
"\nHistogram for bucket list length "	pointer
"(total of %lu buckets):\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
nbuckets	long
)	O
,	O
(	O
unsigned	O
long	O
)	O
nbuckets	long
)	O
;	O
lengths	pointer
=	O
(	O
unsigned	O
long	O
*	O
)	O
calloc	function
(	O
nbuckets	long
,	O
sizeof	O
(	O
*	O
lengths	pointer
)	O
)	O
;	O
if	O
(	O
lengths	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Out of memory allocating space for histogram buckets\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
visited	pointer
=	O
xcmalloc	function
(	O
nchains	long
,	O
1	int
)	O
;	O
memset	function
(	O
visited	pointer
,	O
0	int
,	O
nchains	long
)	O
;	O
printf	function
(	O
_	O
(	O
" Length  Number     %% of total  Coverage\n"	pointer
)	O
)	O
;	O
for	O
(	O
hn	long
=	O
0	int
;	O
hn	long
<	O
nbuckets	long
;	O
++	O
hn	long
)	O
{	O
for	O
(	O
si	long
=	O
buckets	pointer
[	O
hn	long
]	O
;	O
si	long
>	O
0	int
;	O
si	long
=	O
chains	pointer
[	O
si	long
]	O
)	O
{	O
++	O
nsyms	long
;	O
if	O
(	O
maxlength	long
<	O
++	O
lengths	pointer
[	O
hn	long
]	O
)	O
++	O
maxlength	long
;	O
if	O
(	O
si	long
>=	O
nchains	long
||	O
visited	pointer
[	O
si	long
]	O
)	O
{	O
error	function
(	O
_	O
(	O
"histogram chain is corrupt\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
visited	pointer
[	O
si	long
]	O
=	O
1	int
;	O
}	O
}	O
free	function
(	O
visited	pointer
)	O
;	O
counts	pointer
=	O
(	O
unsigned	O
long	O
*	O
)	O
calloc	function
(	O
maxlength	long
+	O
1	int
,	O
sizeof	O
(	O
*	O
counts	pointer
)	O
)	O
;	O
if	O
(	O
counts	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
lengths	pointer
)	O
;	O
error	function
(	O
_	O
(	O
"Out of memory allocating space for histogram counts\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
for	O
(	O
hn	long
=	O
0	int
;	O
hn	long
<	O
nbuckets	long
;	O
++	O
hn	long
)	O
++	O
counts	pointer
[	O
lengths	pointer
[	O
hn	long
]	O
]	O
;	O
if	O
(	O
nbuckets	long
>	O
0	int
)	O
{	O
unsigned	O
long	O
i	pointer
;	O
printf	function
(	O
"      0  %-10lu (%5.1f%%)\n"	pointer
,	O
counts	pointer
[	O
0	int
]	O
,	O
(	O
counts	pointer
[	O
0	int
]	O
*	O
100.0	int
)	O
/	O
nbuckets	long
)	O
;	O
for	O
(	O
i	pointer
=	O
1	int
;	O
i	pointer
<=	O
maxlength	long
;	O
++	O
i	pointer
)	O
{	O
nzero_counts	long
+=	O
counts	pointer
[	O
i	pointer
]	O
*	O
i	pointer
;	O
printf	function
(	O
"%7lu  %-10lu (%5.1f%%)    %5.1f%%\n"	pointer
,	O
i	pointer
,	O
counts	pointer
[	O
i	pointer
]	O
,	O
(	O
counts	pointer
[	O
i	pointer
]	O
*	O
100.0	int
)	O
/	O
nbuckets	long
,	O
(	O
nzero_counts	long
*	O
100.0	int
)	O
/	O
nsyms	long
)	O
;	O
}	O
}	O
free	function
(	O
counts	pointer
)	O
;	O
free	function
(	O
lengths	pointer
)	O
;	O
}	O
if	O
(	O
buckets	pointer
!=	O
NULL	O
)	O
{	O
free	function
(	O
buckets	pointer
)	O
;	O
free	function
(	O
chains	pointer
)	O
;	O
}	O
if	O
(	O
do_histogram	int
&&	O
gnubuckets	pointer
!=	O
NULL	O
)	O
{	O
unsigned	O
long	O
*	O
lengths	pointer
;	O
unsigned	O
long	O
*	O
counts	pointer
;	O
unsigned	O
long	O
hn	long
;	O
unsigned	O
long	O
maxlength	long
=	O
0	int
;	O
unsigned	O
long	O
nzero_counts	long
=	O
0	int
;	O
unsigned	O
long	O
nsyms	long
=	O
0	int
;	O
printf	function
(	O
ngettext	function
(	O
"\nHistogram for `%s' bucket list length "	pointer
"(total of %lu bucket):\n"	pointer
,	O
"\nHistogram for `%s' bucket list length "	pointer
"(total of %lu buckets):\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
ngnubuckets	long
)	O
,	O
GNU_HASH_SECTION_NAME	O
,	O
(	O
unsigned	O
long	O
)	O
ngnubuckets	long
)	O
;	O
lengths	pointer
=	O
(	O
unsigned	O
long	O
*	O
)	O
calloc	function
(	O
ngnubuckets	long
,	O
sizeof	O
(	O
*	O
lengths	pointer
)	O
)	O
;	O
if	O
(	O
lengths	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Out of memory allocating space for gnu histogram buckets\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
printf	function
(	O
_	O
(	O
" Length  Number     %% of total  Coverage\n"	pointer
)	O
)	O
;	O
for	O
(	O
hn	long
=	O
0	int
;	O
hn	long
<	O
ngnubuckets	long
;	O
++	O
hn	long
)	O
if	O
(	O
gnubuckets	pointer
[	O
hn	long
]	O
!=	O
0	int
)	O
{	O
bfd_vma	long
off	long
,	O
length	long
=	O
1	int
;	O
for	O
(	O
off	long
=	O
gnubuckets	pointer
[	O
hn	long
]	O
-	O
gnusymidx	long
;	O
off	long
<	O
ngnuchains	long
&&	O
(	O
gnuchains	pointer
[	O
off	long
]	O
&	O
1	int
)	O
==	O
0	int
;	O
++	O
off	long
)	O
++	O
length	long
;	O
lengths	pointer
[	O
hn	long
]	O
=	O
length	long
;	O
if	O
(	O
length	long
>	O
maxlength	long
)	O
maxlength	long
=	O
length	long
;	O
nsyms	long
+=	O
length	long
;	O
}	O
counts	pointer
=	O
(	O
unsigned	O
long	O
*	O
)	O
calloc	function
(	O
maxlength	long
+	O
1	int
,	O
sizeof	O
(	O
*	O
counts	pointer
)	O
)	O
;	O
if	O
(	O
counts	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
lengths	pointer
)	O
;	O
error	function
(	O
_	O
(	O
"Out of memory allocating space for gnu histogram counts\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
for	O
(	O
hn	long
=	O
0	int
;	O
hn	long
<	O
ngnubuckets	long
;	O
++	O
hn	long
)	O
++	O
counts	pointer
[	O
lengths	pointer
[	O
hn	long
]	O
]	O
;	O
if	O
(	O
ngnubuckets	long
>	O
0	int
)	O
{	O
unsigned	O
long	O
j	int
;	O
printf	function
(	O
"      0  %-10lu (%5.1f%%)\n"	pointer
,	O
counts	pointer
[	O
0	int
]	O
,	O
(	O
counts	pointer
[	O
0	int
]	O
*	O
100.0	int
)	O
/	O
ngnubuckets	long
)	O
;	O
for	O
(	O
j	int
=	O
1	int
;	O
j	int
<=	O
maxlength	long
;	O
++	O
j	int
)	O
{	O
nzero_counts	long
+=	O
counts	pointer
[	O
j	int
]	O
*	O
j	int
;	O
printf	function
(	O
"%7lu  %-10lu (%5.1f%%)    %5.1f%%\n"	pointer
,	O
j	int
,	O
counts	pointer
[	O
j	int
]	O
,	O
(	O
counts	pointer
[	O
j	int
]	O
*	O
100.0	int
)	O
/	O
ngnubuckets	long
,	O
(	O
nzero_counts	long
*	O
100.0	int
)	O
/	O
nsyms	long
)	O
;	O
}	O
}	O
free	function
(	O
counts	pointer
)	O
;	O
free	function
(	O
lengths	pointer
)	O
;	O
free	function
(	O
gnubuckets	pointer
)	O
;	O
free	function
(	O
gnuchains	pointer
)	O
;	O
free	function
(	O
mipsxlat	pointer
)	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
process_syminfo	function
(	O
Filedata	struct
*	O
filedata	struct
ATTRIBUTE_UNUSED	O
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
if	O
(	O
dynamic_syminfo	pointer
==	O
NULL	O
||	O
!	O
do_dynamic	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
dynamic_symbols	pointer
==	O
NULL	O
||	O
dynamic_strings	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
dynamic_addr	long
)	O
printf	function
(	O
ngettext	function
(	O
"\nDynamic info segment at offset 0x%lx "	pointer
"contains %d entry:\n"	pointer
,	O
"\nDynamic info segment at offset 0x%lx "	pointer
"contains %d entries:\n"	pointer
,	O
dynamic_syminfo_nent	int
)	O
,	O
dynamic_syminfo_offset	long
,	O
dynamic_syminfo_nent	int
)	O
;	O
printf	function
(	O
_	O
(	O
" Num: Name                           BoundTo     Flags\n"	pointer
)	O
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
dynamic_syminfo_nent	int
;	O
++	O
i	pointer
)	O
{	O
unsigned	O
short	O
int	O
flags	int
=	O
dynamic_syminfo	pointer
[	O
i	pointer
]	O
.	O
si_flags	array
;	O
printf	function
(	O
"%4d: "	pointer
,	O
i	pointer
)	O
;	O
if	O
(	O
i	pointer
>=	O
num_dynamic_syms	long
)	O
printf	function
(	O
_	O
(	O
"<corrupt index>"	pointer
)	O
)	O
;	O
else	O
if	O
(	O
VALID_DYNAMIC_NAME	O
(	O
dynamic_symbols	pointer
[	O
i	pointer
]	O
.	O
st_name	pointer
)	O
)	O
print_symbol	function
(	O
30	int
,	O
GET_DYNAMIC_NAME	O
(	O
dynamic_symbols	pointer
[	O
i	pointer
]	O
.	O
st_name	pointer
)	O
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"<corrupt: %19ld>"	pointer
)	O
,	O
dynamic_symbols	pointer
[	O
i	pointer
]	O
.	O
st_name	pointer
)	O
;	O
putchar	function
(	O
' '	O
)	O
;	O
switch	O
(	O
dynamic_syminfo	pointer
[	O
i	pointer
]	O
.	O
si_boundto	array
)	O
{	O
case	O
SYMINFO_BT_SELF	int
:	O
fputs	function
(	O
"SELF       "	pointer
,	O
stdout	pointer
)	O
;	O
break	O
;	O
case	O
SYMINFO_BT_PARENT	int
:	O
fputs	function
(	O
"PARENT     "	pointer
,	O
stdout	pointer
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
dynamic_syminfo	pointer
[	O
i	pointer
]	O
.	O
si_boundto	array
>	O
0	int
&&	O
dynamic_syminfo	pointer
[	O
i	pointer
]	O
.	O
si_boundto	array
<	O
dynamic_nent	long
&&	O
VALID_DYNAMIC_NAME	O
(	O
dynamic_section	pointer
[	O
dynamic_syminfo	pointer
[	O
i	pointer
]	O
.	O
si_boundto	array
]	O
.	O
d_un	union
.	O
d_val	array
)	O
)	O
{	O
print_symbol	function
(	O
10	int
,	O
GET_DYNAMIC_NAME	O
(	O
dynamic_section	pointer
[	O
dynamic_syminfo	pointer
[	O
i	pointer
]	O
.	O
si_boundto	array
]	O
.	O
d_un	union
.	O
d_val	array
)	O
)	O
;	O
putchar	function
(	O
' '	O
)	O
;	O
}	O
else	O
printf	function
(	O
"%-10d "	pointer
,	O
dynamic_syminfo	pointer
[	O
i	pointer
]	O
.	O
si_boundto	array
)	O
;	O
break	O
;	O
}	O
if	O
(	O
flags	int
&	O
SYMINFO_FLG_DIRECT	int
)	O
printf	function
(	O
" DIRECT"	pointer
)	O
;	O
if	O
(	O
flags	int
&	O
SYMINFO_FLG_PASSTHRU	int
)	O
printf	function
(	O
" PASSTHRU"	pointer
)	O
;	O
if	O
(	O
flags	int
&	O
SYMINFO_FLG_COPY	int
)	O
printf	function
(	O
" COPY"	pointer
)	O
;	O
if	O
(	O
flags	int
&	O
SYMINFO_FLG_LAZYLOAD	int
)	O
printf	function
(	O
" LAZYLOAD"	pointer
)	O
;	O
puts	function
(	O
""	pointer
)	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
target_specific_reloc_handling	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
Elf_Internal_Rela	struct
*	O
reloc	int
,	O
unsigned	O
char	O
*	O
start	pointer
,	O
unsigned	O
char	O
*	O
end	pointer
,	O
Elf_Internal_Sym	struct
*	O
symtab	pointer
,	O
unsigned	O
long	O
num_syms	long
)	O
{	O
unsigned	O
int	O
reloc_type	int
=	O
0	int
;	O
unsigned	O
long	O
sym_index	long
=	O
0	int
;	O
if	O
(	O
reloc	int
)	O
{	O
reloc_type	int
=	O
get_reloc_type	function
(	O
filedata	struct
,	O
reloc	int
->	O
r_info	array
)	O
;	O
sym_index	long
=	O
get_reloc_symindex	function
(	O
reloc	int
->	O
r_info	array
)	O
;	O
}	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
case	O
EM_MSP430	int
:	O
case	O
EM_MSP430_OLD	int
:	O
{	O
static	O
Elf_Internal_Sym	struct
*	O
saved_sym	pointer
=	O
NULL	O
;	O
if	O
(	O
reloc	int
==	O
NULL	O
)	O
{	O
saved_sym	pointer
=	O
NULL	O
;	O
return	O
TRUE	int
;	O
}	O
switch	O
(	O
reloc_type	int
)	O
{	O
case	O
10	int
:	O
if	O
(	O
uses_msp430x_relocs	function
(	O
filedata	struct
)	O
)	O
break	O
;	O
case	O
21	int
:	O
if	O
(	O
sym_index	long
>=	O
num_syms	long
)	O
error	function
(	O
_	O
(	O
"MSP430 SYM_DIFF reloc contains invalid symbol index %lu\n"	pointer
)	O
,	O
sym_index	long
)	O
;	O
else	O
saved_sym	pointer
=	O
symtab	pointer
+	O
sym_index	long
;	O
return	O
TRUE	int
;	O
case	O
1	int
:	O
case	O
3	int
:	O
goto	O
handle_sym_diff	O
;	O
case	O
5	int
:	O
case	O
9	int
:	O
if	O
(	O
uses_msp430x_relocs	function
(	O
filedata	struct
)	O
)	O
break	O
;	O
goto	O
handle_sym_diff	O
;	O
case	O
2	int
:	O
case	O
15	int
:	O
if	O
(	O
!	O
uses_msp430x_relocs	function
(	O
filedata	struct
)	O
)	O
break	O
;	O
goto	O
handle_sym_diff	O
;	O
handle_sym_diff	O
:	O
if	O
(	O
saved_sym	pointer
!=	O
NULL	O
)	O
{	O
int	O
reloc_size	int
=	O
reloc_type	int
==	O
1	int
?	O
4	int
:	O
2	int
;	O
bfd_vma	long
value	int
;	O
if	O
(	O
sym_index	long
>=	O
num_syms	long
)	O
error	function
(	O
_	O
(	O
"MSP430 reloc contains invalid symbol index %lu\n"	pointer
)	O
,	O
sym_index	long
)	O
;	O
else	O
{	O
value	int
=	O
reloc	int
->	O
r_addend	array
+	O
(	O
symtab	pointer
[	O
sym_index	long
]	O
.	O
st_value	int
-	O
saved_sym	pointer
->	O
st_value	int
)	O
;	O
if	O
(	O
IN_RANGE	O
(	O
start	pointer
,	O
end	pointer
,	O
start	pointer
+	O
reloc	int
->	O
r_offset	array
,	O
reloc_size	int
)	O
)	O
byte_put	pointer
(	O
start	pointer
+	O
reloc	int
->	O
r_offset	array
,	O
value	int
,	O
reloc_size	int
)	O
;	O
else	O
error	function
(	O
_	O
(	O
"MSP430 sym diff reloc contains invalid offset: 0x%lx\n"	pointer
)	O
,	O
(	O
long	O
)	O
reloc	int
->	O
r_offset	array
)	O
;	O
}	O
saved_sym	pointer
=	O
NULL	O
;	O
return	O
TRUE	int
;	O
}	O
break	O
;	O
default	O
:	O
if	O
(	O
saved_sym	pointer
!=	O
NULL	O
)	O
error	function
(	O
_	O
(	O
"Unhandled MSP430 reloc type found after SYM_DIFF reloc\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
}	O
case	O
EM_MN10300	int
:	O
case	O
EM_CYGNUS_MN10300	int
:	O
{	O
static	O
Elf_Internal_Sym	struct
*	O
saved_sym	pointer
=	O
NULL	O
;	O
if	O
(	O
reloc	int
==	O
NULL	O
)	O
{	O
saved_sym	pointer
=	O
NULL	O
;	O
return	O
TRUE	int
;	O
}	O
switch	O
(	O
reloc_type	int
)	O
{	O
case	O
34	int
:	O
return	O
TRUE	int
;	O
case	O
33	int
:	O
if	O
(	O
sym_index	long
>=	O
num_syms	long
)	O
error	function
(	O
_	O
(	O
"MN10300_SYM_DIFF reloc contains invalid symbol index %lu\n"	pointer
)	O
,	O
sym_index	long
)	O
;	O
else	O
saved_sym	pointer
=	O
symtab	pointer
+	O
sym_index	long
;	O
return	O
TRUE	int
;	O
case	O
1	int
:	O
case	O
2	int
:	O
if	O
(	O
saved_sym	pointer
!=	O
NULL	O
)	O
{	O
int	O
reloc_size	int
=	O
reloc_type	int
==	O
1	int
?	O
4	int
:	O
2	int
;	O
bfd_vma	long
value	int
;	O
if	O
(	O
sym_index	long
>=	O
num_syms	long
)	O
error	function
(	O
_	O
(	O
"MN10300 reloc contains invalid symbol index %lu\n"	pointer
)	O
,	O
sym_index	long
)	O
;	O
else	O
{	O
value	int
=	O
reloc	int
->	O
r_addend	array
+	O
(	O
symtab	pointer
[	O
sym_index	long
]	O
.	O
st_value	int
-	O
saved_sym	pointer
->	O
st_value	int
)	O
;	O
if	O
(	O
IN_RANGE	O
(	O
start	pointer
,	O
end	pointer
,	O
start	pointer
+	O
reloc	int
->	O
r_offset	array
,	O
reloc_size	int
)	O
)	O
byte_put	pointer
(	O
start	pointer
+	O
reloc	int
->	O
r_offset	array
,	O
value	int
,	O
reloc_size	int
)	O
;	O
else	O
error	function
(	O
_	O
(	O
"MN10300 sym diff reloc contains invalid offset: 0x%lx\n"	pointer
)	O
,	O
(	O
long	O
)	O
reloc	int
->	O
r_offset	array
)	O
;	O
}	O
saved_sym	pointer
=	O
NULL	O
;	O
return	O
TRUE	int
;	O
}	O
break	O
;	O
default	O
:	O
if	O
(	O
saved_sym	pointer
!=	O
NULL	O
)	O
error	function
(	O
_	O
(	O
"Unhandled MN10300 reloc type found after SYM_DIFF reloc\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
}	O
case	O
EM_RL78	int
:	O
{	O
static	O
bfd_vma	long
saved_sym1	long
=	O
0	int
;	O
static	O
bfd_vma	long
saved_sym2	long
=	O
0	int
;	O
static	O
bfd_vma	long
value	int
;	O
if	O
(	O
reloc	int
==	O
NULL	O
)	O
{	O
saved_sym1	long
=	O
saved_sym2	long
=	O
0	int
;	O
return	O
TRUE	int
;	O
}	O
switch	O
(	O
reloc_type	int
)	O
{	O
case	O
0x80	int
:	O
saved_sym1	long
=	O
saved_sym2	long
;	O
if	O
(	O
sym_index	long
>=	O
num_syms	long
)	O
error	function
(	O
_	O
(	O
"RL78_SYM reloc contains invalid symbol index %lu\n"	pointer
)	O
,	O
sym_index	long
)	O
;	O
else	O
{	O
saved_sym2	long
=	O
symtab	pointer
[	O
sym_index	long
]	O
.	O
st_value	int
;	O
saved_sym2	long
+=	O
reloc	int
->	O
r_addend	array
;	O
}	O
return	O
TRUE	int
;	O
case	O
0x83	int
:	O
value	int
=	O
saved_sym1	long
-	O
saved_sym2	long
;	O
saved_sym2	long
=	O
saved_sym1	long
=	O
0	int
;	O
return	O
TRUE	int
;	O
break	O
;	O
case	O
0x41	int
:	O
if	O
(	O
IN_RANGE	O
(	O
start	pointer
,	O
end	pointer
,	O
start	pointer
+	O
reloc	int
->	O
r_offset	array
,	O
4	int
)	O
)	O
byte_put	pointer
(	O
start	pointer
+	O
reloc	int
->	O
r_offset	array
,	O
value	int
,	O
4	int
)	O
;	O
else	O
error	function
(	O
_	O
(	O
"RL78 sym diff reloc contains invalid offset: 0x%lx\n"	pointer
)	O
,	O
(	O
long	O
)	O
reloc	int
->	O
r_offset	array
)	O
;	O
value	int
=	O
0	int
;	O
return	O
TRUE	int
;	O
case	O
0x43	int
:	O
if	O
(	O
IN_RANGE	O
(	O
start	pointer
,	O
end	pointer
,	O
start	pointer
+	O
reloc	int
->	O
r_offset	array
,	O
2	int
)	O
)	O
byte_put	pointer
(	O
start	pointer
+	O
reloc	int
->	O
r_offset	array
,	O
value	int
,	O
2	int
)	O
;	O
else	O
error	function
(	O
_	O
(	O
"RL78 sym diff reloc contains invalid offset: 0x%lx\n"	pointer
)	O
,	O
(	O
long	O
)	O
reloc	int
->	O
r_offset	array
)	O
;	O
value	int
=	O
0	int
;	O
return	O
TRUE	int
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
}	O
}	O
return	O
FALSE	int
;	O
}	O
static	O
bfd_boolean	int
is_32bit_abs_reloc	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
int	O
reloc_type	int
)	O
{	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
case	O
EM_386	int
:	O
case	O
EM_IAMCU	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
case	O
EM_68K	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
case	O
EM_860	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
case	O
EM_960	int
:	O
return	O
reloc_type	int
==	O
2	int
;	O
case	O
EM_AARCH64	int
:	O
return	O
(	O
reloc_type	int
==	O
258	int
||	O
reloc_type	int
==	O
1	int
)	O
;	O
case	O
EM_BPF	int
:	O
return	O
reloc_type	int
==	O
11	int
;	O
case	O
EM_ADAPTEVA_EPIPHANY	int
:	O
return	O
reloc_type	int
==	O
3	int
;	O
case	O
EM_ALPHA	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
case	O
EM_ARC	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
case	O
EM_ARC_COMPACT	int
:	O
case	O
EM_ARC_COMPACT2	int
:	O
return	O
reloc_type	int
==	O
4	int
;	O
case	O
EM_ARM	int
:	O
return	O
reloc_type	int
==	O
2	int
;	O
case	O
EM_AVR_OLD	int
:	O
case	O
EM_AVR	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
case	O
EM_BLACKFIN	int
:	O
return	O
reloc_type	int
==	O
0x12	int
;	O
case	O
EM_CRIS	int
:	O
return	O
reloc_type	int
==	O
3	int
;	O
case	O
EM_CR16	int
:	O
return	O
reloc_type	int
==	O
3	int
;	O
case	O
EM_CRX	int
:	O
return	O
reloc_type	int
==	O
15	int
;	O
case	O
EM_CSKY	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
case	O
EM_CYGNUS_FRV	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
case	O
EM_CYGNUS_D10V	int
:	O
case	O
EM_D10V	int
:	O
return	O
reloc_type	int
==	O
6	int
;	O
case	O
EM_CYGNUS_D30V	int
:	O
case	O
EM_D30V	int
:	O
return	O
reloc_type	int
==	O
12	int
;	O
case	O
EM_DLX	int
:	O
return	O
reloc_type	int
==	O
3	int
;	O
case	O
EM_CYGNUS_FR30	int
:	O
case	O
EM_FR30	int
:	O
return	O
reloc_type	int
==	O
3	int
;	O
case	O
EM_FT32	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
case	O
EM_H8S	int
:	O
case	O
EM_H8_300	int
:	O
case	O
EM_H8_300H	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
case	O
EM_IA_64	int
:	O
return	O
(	O
reloc_type	int
==	O
0x64	int
||	O
reloc_type	int
==	O
0x65	int
||	O
reloc_type	int
==	O
0x24	int
||	O
reloc_type	int
==	O
0x25	int
)	O
;	O
case	O
EM_IP2K_OLD	int
:	O
case	O
EM_IP2K	int
:	O
return	O
reloc_type	int
==	O
2	int
;	O
case	O
EM_IQ2000	int
:	O
return	O
reloc_type	int
==	O
2	int
;	O
case	O
EM_LATTICEMICO32	int
:	O
return	O
reloc_type	int
==	O
3	int
;	O
case	O
EM_M32C_OLD	int
:	O
case	O
EM_M32C	int
:	O
return	O
reloc_type	int
==	O
3	int
;	O
case	O
EM_M32R	int
:	O
return	O
reloc_type	int
==	O
34	int
;	O
case	O
EM_68HC11	int
:	O
case	O
EM_68HC12	int
:	O
return	O
reloc_type	int
==	O
6	int
;	O
case	O
EM_S12Z	int
:	O
return	O
reloc_type	int
==	O
7	int
||	O
reloc_type	int
==	O
6	int
;	O
case	O
EM_MCORE	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
case	O
EM_CYGNUS_MEP	int
:	O
return	O
reloc_type	int
==	O
4	int
;	O
case	O
EM_METAG	int
:	O
return	O
reloc_type	int
==	O
2	int
;	O
case	O
EM_MICROBLAZE	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
case	O
EM_MIPS	int
:	O
return	O
reloc_type	int
==	O
2	int
;	O
case	O
EM_MMIX	int
:	O
return	O
reloc_type	int
==	O
4	int
;	O
case	O
EM_CYGNUS_MN10200	int
:	O
case	O
EM_MN10200	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
case	O
EM_CYGNUS_MN10300	int
:	O
case	O
EM_MN10300	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
case	O
EM_MOXIE	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
case	O
EM_MSP430_OLD	int
:	O
case	O
EM_MSP430	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
case	O
EM_MT	int
:	O
return	O
reloc_type	int
==	O
2	int
;	O
case	O
EM_NDS32	int
:	O
return	O
reloc_type	int
==	O
20	int
;	O
case	O
EM_ALTERA_NIOS2	int
:	O
return	O
reloc_type	int
==	O
12	int
;	O
case	O
EM_NIOS32	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
case	O
EM_OR1K	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
case	O
EM_PARISC	int
:	O
return	O
(	O
reloc_type	int
==	O
1	int
||	O
reloc_type	int
==	O
2	int
||	O
reloc_type	int
==	O
41	int
)	O
;	O
case	O
EM_PJ	int
:	O
case	O
EM_PJ_OLD	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
case	O
EM_PPC64	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
case	O
EM_PPC	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
case	O
EM_TI_PRU	int
:	O
return	O
reloc_type	int
==	O
11	int
;	O
case	O
EM_RISCV	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
case	O
EM_RL78	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
case	O
EM_RX	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
case	O
EM_S370	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
case	O
EM_S390_OLD	int
:	O
case	O
EM_S390	int
:	O
return	O
reloc_type	int
==	O
4	int
;	O
case	O
EM_SCORE	int
:	O
return	O
reloc_type	int
==	O
8	int
;	O
case	O
EM_SH	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
case	O
EM_SPARC32PLUS	int
:	O
case	O
EM_SPARCV9	int
:	O
case	O
EM_SPARC	int
:	O
return	O
reloc_type	int
==	O
3	int
||	O
reloc_type	int
==	O
23	int
;	O
case	O
EM_SPU	int
:	O
return	O
reloc_type	int
==	O
6	int
;	O
case	O
EM_TI_C6000	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
case	O
EM_TILEGX	int
:	O
return	O
reloc_type	int
==	O
2	int
;	O
case	O
EM_TILEPRO	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
case	O
EM_CYGNUS_V850	int
:	O
case	O
EM_V850	int
:	O
return	O
reloc_type	int
==	O
6	int
;	O
case	O
EM_V800	int
:	O
return	O
reloc_type	int
==	O
0x33	int
;	O
case	O
EM_VAX	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
case	O
EM_VISIUM	int
:	O
return	O
reloc_type	int
==	O
3	int
;	O
case	O
EM_WEBASSEMBLY	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
case	O
EM_X86_64	int
:	O
case	O
EM_L1OM	int
:	O
case	O
EM_K1OM	int
:	O
return	O
reloc_type	int
==	O
10	int
;	O
case	O
EM_XC16X	int
:	O
case	O
EM_C166	int
:	O
return	O
reloc_type	int
==	O
3	int
;	O
case	O
EM_XGATE	int
:	O
return	O
reloc_type	int
==	O
4	int
;	O
case	O
EM_XSTORMY16	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
case	O
EM_XTENSA_OLD	int
:	O
case	O
EM_XTENSA	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
case	O
EM_Z80	int
:	O
return	O
reloc_type	int
==	O
6	int
;	O
default	O
:	O
{	O
static	O
unsigned	O
int	O
prev_warn	int
=	O
0	int
;	O
if	O
(	O
prev_warn	int
!=	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
error	function
(	O
_	O
(	O
"Missing knowledge of 32-bit reloc types used in DWARF sections of machine number %d\n"	pointer
)	O
,	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
;	O
prev_warn	int
=	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
;	O
return	O
FALSE	int
;	O
}	O
}	O
}	O
static	O
bfd_boolean	int
is_32bit_pcrel_reloc	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
int	O
reloc_type	int
)	O
{	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
case	O
EM_386	int
:	O
case	O
EM_IAMCU	int
:	O
return	O
reloc_type	int
==	O
2	int
;	O
case	O
EM_68K	int
:	O
return	O
reloc_type	int
==	O
4	int
;	O
case	O
EM_AARCH64	int
:	O
return	O
reloc_type	int
==	O
261	int
;	O
case	O
EM_ADAPTEVA_EPIPHANY	int
:	O
return	O
reloc_type	int
==	O
6	int
;	O
case	O
EM_ALPHA	int
:	O
return	O
reloc_type	int
==	O
10	int
;	O
case	O
EM_ARC_COMPACT	int
:	O
case	O
EM_ARC_COMPACT2	int
:	O
return	O
reloc_type	int
==	O
49	int
;	O
case	O
EM_ARM	int
:	O
return	O
reloc_type	int
==	O
3	int
;	O
case	O
EM_AVR_OLD	int
:	O
case	O
EM_AVR	int
:	O
return	O
reloc_type	int
==	O
36	int
;	O
case	O
EM_MICROBLAZE	int
:	O
return	O
reloc_type	int
==	O
2	int
;	O
case	O
EM_OR1K	int
:	O
return	O
reloc_type	int
==	O
9	int
;	O
case	O
EM_PARISC	int
:	O
return	O
reloc_type	int
==	O
9	int
;	O
case	O
EM_PPC	int
:	O
return	O
reloc_type	int
==	O
26	int
;	O
case	O
EM_PPC64	int
:	O
return	O
reloc_type	int
==	O
26	int
;	O
case	O
EM_RISCV	int
:	O
return	O
reloc_type	int
==	O
57	int
;	O
case	O
EM_S390_OLD	int
:	O
case	O
EM_S390	int
:	O
return	O
reloc_type	int
==	O
5	int
;	O
case	O
EM_SH	int
:	O
return	O
reloc_type	int
==	O
2	int
;	O
case	O
EM_SPARC32PLUS	int
:	O
case	O
EM_SPARCV9	int
:	O
case	O
EM_SPARC	int
:	O
return	O
reloc_type	int
==	O
6	int
;	O
case	O
EM_SPU	int
:	O
return	O
reloc_type	int
==	O
13	int
;	O
case	O
EM_TILEGX	int
:	O
return	O
reloc_type	int
==	O
6	int
;	O
case	O
EM_TILEPRO	int
:	O
return	O
reloc_type	int
==	O
4	int
;	O
case	O
EM_VISIUM	int
:	O
return	O
reloc_type	int
==	O
6	int
;	O
case	O
EM_X86_64	int
:	O
case	O
EM_L1OM	int
:	O
case	O
EM_K1OM	int
:	O
return	O
reloc_type	int
==	O
2	int
;	O
case	O
EM_VAX	int
:	O
return	O
reloc_type	int
==	O
4	int
;	O
case	O
EM_XTENSA_OLD	int
:	O
case	O
EM_XTENSA	int
:	O
return	O
reloc_type	int
==	O
14	int
;	O
default	O
:	O
return	O
FALSE	int
;	O
}	O
}	O
static	O
bfd_boolean	int
is_64bit_abs_reloc	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
int	O
reloc_type	int
)	O
{	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
case	O
EM_AARCH64	int
:	O
return	O
reloc_type	int
==	O
257	int
;	O
case	O
EM_ALPHA	int
:	O
return	O
reloc_type	int
==	O
2	int
;	O
case	O
EM_IA_64	int
:	O
return	O
(	O
reloc_type	int
==	O
0x26	int
||	O
reloc_type	int
==	O
0x27	int
)	O
;	O
case	O
EM_PARISC	int
:	O
return	O
reloc_type	int
==	O
80	int
;	O
case	O
EM_PPC64	int
:	O
return	O
reloc_type	int
==	O
38	int
;	O
case	O
EM_RISCV	int
:	O
return	O
reloc_type	int
==	O
2	int
;	O
case	O
EM_SPARC32PLUS	int
:	O
case	O
EM_SPARCV9	int
:	O
case	O
EM_SPARC	int
:	O
return	O
reloc_type	int
==	O
32	int
||	O
reloc_type	int
==	O
54	int
;	O
case	O
EM_X86_64	int
:	O
case	O
EM_L1OM	int
:	O
case	O
EM_K1OM	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
case	O
EM_S390_OLD	int
:	O
case	O
EM_S390	int
:	O
return	O
reloc_type	int
==	O
22	int
;	O
case	O
EM_TILEGX	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
case	O
EM_MIPS	int
:	O
return	O
reloc_type	int
==	O
18	int
;	O
default	O
:	O
return	O
FALSE	int
;	O
}	O
}	O
static	O
bfd_boolean	int
is_64bit_pcrel_reloc	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
int	O
reloc_type	int
)	O
{	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
case	O
EM_AARCH64	int
:	O
return	O
reloc_type	int
==	O
260	int
;	O
case	O
EM_ALPHA	int
:	O
return	O
reloc_type	int
==	O
11	int
;	O
case	O
EM_IA_64	int
:	O
return	O
(	O
reloc_type	int
==	O
0x4e	int
||	O
reloc_type	int
==	O
0x4f	int
)	O
;	O
case	O
EM_PARISC	int
:	O
return	O
reloc_type	int
==	O
72	int
;	O
case	O
EM_PPC64	int
:	O
return	O
reloc_type	int
==	O
44	int
;	O
case	O
EM_SPARC32PLUS	int
:	O
case	O
EM_SPARCV9	int
:	O
case	O
EM_SPARC	int
:	O
return	O
reloc_type	int
==	O
46	int
;	O
case	O
EM_X86_64	int
:	O
case	O
EM_L1OM	int
:	O
case	O
EM_K1OM	int
:	O
return	O
reloc_type	int
==	O
24	int
;	O
case	O
EM_S390_OLD	int
:	O
case	O
EM_S390	int
:	O
return	O
reloc_type	int
==	O
23	int
;	O
case	O
EM_TILEGX	int
:	O
return	O
reloc_type	int
==	O
5	int
;	O
default	O
:	O
return	O
FALSE	int
;	O
}	O
}	O
static	O
bfd_boolean	int
is_24bit_abs_reloc	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
int	O
reloc_type	int
)	O
{	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
case	O
EM_CYGNUS_MN10200	int
:	O
case	O
EM_MN10200	int
:	O
return	O
reloc_type	int
==	O
4	int
;	O
case	O
EM_FT32	int
:	O
return	O
reloc_type	int
==	O
5	int
;	O
case	O
EM_Z80	int
:	O
return	O
reloc_type	int
==	O
5	int
;	O
default	O
:	O
return	O
FALSE	int
;	O
}	O
}	O
static	O
bfd_boolean	int
is_16bit_abs_reloc	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
int	O
reloc_type	int
)	O
{	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
case	O
EM_ARC	int
:	O
case	O
EM_ARC_COMPACT	int
:	O
case	O
EM_ARC_COMPACT2	int
:	O
return	O
reloc_type	int
==	O
2	int
;	O
case	O
EM_ADAPTEVA_EPIPHANY	int
:	O
return	O
reloc_type	int
==	O
5	int
;	O
case	O
EM_AVR_OLD	int
:	O
case	O
EM_AVR	int
:	O
return	O
reloc_type	int
==	O
4	int
;	O
case	O
EM_CYGNUS_D10V	int
:	O
case	O
EM_D10V	int
:	O
return	O
reloc_type	int
==	O
3	int
;	O
case	O
EM_FT32	int
:	O
return	O
reloc_type	int
==	O
2	int
;	O
case	O
EM_H8S	int
:	O
case	O
EM_H8_300	int
:	O
case	O
EM_H8_300H	int
:	O
return	O
reloc_type	int
==	O
R_H8_DIR16	int
;	O
case	O
EM_IP2K_OLD	int
:	O
case	O
EM_IP2K	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
case	O
EM_M32C_OLD	int
:	O
case	O
EM_M32C	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
case	O
EM_CYGNUS_MN10200	int
:	O
case	O
EM_MN10200	int
:	O
return	O
reloc_type	int
==	O
2	int
;	O
case	O
EM_CYGNUS_MN10300	int
:	O
case	O
EM_MN10300	int
:	O
return	O
reloc_type	int
==	O
2	int
;	O
case	O
EM_MSP430	int
:	O
if	O
(	O
uses_msp430x_relocs	function
(	O
filedata	struct
)	O
)	O
return	O
reloc_type	int
==	O
2	int
;	O
case	O
EM_MSP430_OLD	int
:	O
return	O
reloc_type	int
==	O
5	int
;	O
case	O
EM_NDS32	int
:	O
return	O
reloc_type	int
==	O
19	int
;	O
case	O
EM_ALTERA_NIOS2	int
:	O
return	O
reloc_type	int
==	O
13	int
;	O
case	O
EM_NIOS32	int
:	O
return	O
reloc_type	int
==	O
9	int
;	O
case	O
EM_OR1K	int
:	O
return	O
reloc_type	int
==	O
2	int
;	O
case	O
EM_RISCV	int
:	O
return	O
reloc_type	int
==	O
55	int
;	O
case	O
EM_TI_PRU	int
:	O
return	O
reloc_type	int
==	O
8	int
;	O
case	O
EM_TI_C6000	int
:	O
return	O
reloc_type	int
==	O
2	int
;	O
case	O
EM_VISIUM	int
:	O
return	O
reloc_type	int
==	O
2	int
;	O
case	O
EM_XC16X	int
:	O
case	O
EM_C166	int
:	O
return	O
reloc_type	int
==	O
2	int
;	O
case	O
EM_XGATE	int
:	O
return	O
reloc_type	int
==	O
3	int
;	O
case	O
EM_Z80	int
:	O
return	O
reloc_type	int
==	O
4	int
;	O
default	O
:	O
return	O
FALSE	int
;	O
}	O
}	O
static	O
bfd_boolean	int
is_8bit_abs_reloc	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
int	O
reloc_type	int
)	O
{	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
case	O
EM_RISCV	int
:	O
return	O
reloc_type	int
==	O
54	int
;	O
case	O
EM_Z80	int
:	O
return	O
reloc_type	int
==	O
1	int
;	O
default	O
:	O
return	O
FALSE	int
;	O
}	O
}	O
static	O
bfd_boolean	int
is_6bit_abs_reloc	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
int	O
reloc_type	int
)	O
{	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
case	O
EM_RISCV	int
:	O
return	O
reloc_type	int
==	O
53	int
;	O
default	O
:	O
return	O
FALSE	int
;	O
}	O
}	O
static	O
bfd_boolean	int
is_32bit_inplace_add_reloc	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
int	O
reloc_type	int
)	O
{	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
case	O
EM_RISCV	int
:	O
return	O
reloc_type	int
==	O
35	int
;	O
default	O
:	O
return	O
FALSE	int
;	O
}	O
}	O
static	O
bfd_boolean	int
is_32bit_inplace_sub_reloc	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
int	O
reloc_type	int
)	O
{	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
case	O
EM_RISCV	int
:	O
return	O
reloc_type	int
==	O
39	int
;	O
default	O
:	O
return	O
FALSE	int
;	O
}	O
}	O
static	O
bfd_boolean	int
is_64bit_inplace_add_reloc	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
int	O
reloc_type	int
)	O
{	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
case	O
EM_RISCV	int
:	O
return	O
reloc_type	int
==	O
36	int
;	O
default	O
:	O
return	O
FALSE	int
;	O
}	O
}	O
static	O
bfd_boolean	int
is_64bit_inplace_sub_reloc	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
int	O
reloc_type	int
)	O
{	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
case	O
EM_RISCV	int
:	O
return	O
reloc_type	int
==	O
40	int
;	O
default	O
:	O
return	O
FALSE	int
;	O
}	O
}	O
static	O
bfd_boolean	int
is_16bit_inplace_add_reloc	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
int	O
reloc_type	int
)	O
{	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
case	O
EM_RISCV	int
:	O
return	O
reloc_type	int
==	O
34	int
;	O
default	O
:	O
return	O
FALSE	int
;	O
}	O
}	O
static	O
bfd_boolean	int
is_16bit_inplace_sub_reloc	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
int	O
reloc_type	int
)	O
{	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
case	O
EM_RISCV	int
:	O
return	O
reloc_type	int
==	O
38	int
;	O
default	O
:	O
return	O
FALSE	int
;	O
}	O
}	O
static	O
bfd_boolean	int
is_8bit_inplace_add_reloc	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
int	O
reloc_type	int
)	O
{	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
case	O
EM_RISCV	int
:	O
return	O
reloc_type	int
==	O
33	int
;	O
default	O
:	O
return	O
FALSE	int
;	O
}	O
}	O
static	O
bfd_boolean	int
is_8bit_inplace_sub_reloc	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
int	O
reloc_type	int
)	O
{	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
case	O
EM_RISCV	int
:	O
return	O
reloc_type	int
==	O
37	int
;	O
default	O
:	O
return	O
FALSE	int
;	O
}	O
}	O
static	O
bfd_boolean	int
is_6bit_inplace_sub_reloc	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
int	O
reloc_type	int
)	O
{	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
case	O
EM_RISCV	int
:	O
return	O
reloc_type	int
==	O
52	int
;	O
default	O
:	O
return	O
FALSE	int
;	O
}	O
}	O
static	O
bfd_boolean	int
is_none_reloc	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
int	O
reloc_type	int
)	O
{	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
case	O
EM_386	int
:	O
case	O
EM_68K	int
:	O
case	O
EM_ADAPTEVA_EPIPHANY	int
:	O
case	O
EM_ALPHA	int
:	O
case	O
EM_ALTERA_NIOS2	int
:	O
case	O
EM_ARC	int
:	O
case	O
EM_ARC_COMPACT2	int
:	O
case	O
EM_ARC_COMPACT	int
:	O
case	O
EM_ARM	int
:	O
case	O
EM_C166	int
:	O
case	O
EM_CRIS	int
:	O
case	O
EM_FT32	int
:	O
case	O
EM_IA_64	int
:	O
case	O
EM_K1OM	int
:	O
case	O
EM_L1OM	int
:	O
case	O
EM_M32R	int
:	O
case	O
EM_MIPS	int
:	O
case	O
EM_MN10300	int
:	O
case	O
EM_MOXIE	int
:	O
case	O
EM_NIOS32	int
:	O
case	O
EM_OR1K	int
:	O
case	O
EM_PARISC	int
:	O
case	O
EM_PPC64	int
:	O
case	O
EM_PPC	int
:	O
case	O
EM_RISCV	int
:	O
case	O
EM_S390	int
:	O
case	O
EM_S390_OLD	int
:	O
case	O
EM_SH	int
:	O
case	O
EM_SPARC32PLUS	int
:	O
case	O
EM_SPARC	int
:	O
case	O
EM_SPARCV9	int
:	O
case	O
EM_TILEGX	int
:	O
case	O
EM_TILEPRO	int
:	O
case	O
EM_TI_C6000	int
:	O
case	O
EM_X86_64	int
:	O
case	O
EM_XC16X	int
:	O
case	O
EM_Z80	int
:	O
case	O
EM_WEBASSEMBLY	int
:	O
return	O
reloc_type	int
==	O
0	int
;	O
case	O
EM_AARCH64	int
:	O
return	O
reloc_type	int
==	O
0	int
||	O
reloc_type	int
==	O
256	int
;	O
case	O
EM_AVR_OLD	int
:	O
case	O
EM_AVR	int
:	O
return	O
(	O
reloc_type	int
==	O
0	int
||	O
reloc_type	int
==	O
30	int
||	O
reloc_type	int
==	O
31	int
||	O
reloc_type	int
==	O
32	int
)	O
;	O
case	O
EM_METAG	int
:	O
return	O
reloc_type	int
==	O
3	int
;	O
case	O
EM_NDS32	int
:	O
return	O
(	O
reloc_type	int
==	O
0	int
||	O
reloc_type	int
==	O
204	int
||	O
reloc_type	int
==	O
205	int
||	O
reloc_type	int
==	O
206	int
||	O
reloc_type	int
==	O
207	int
)	O
;	O
case	O
EM_TI_PRU	int
:	O
return	O
(	O
reloc_type	int
==	O
0	int
||	O
reloc_type	int
==	O
65	int
||	O
reloc_type	int
==	O
66	int
||	O
reloc_type	int
==	O
67	int
)	O
;	O
case	O
EM_XTENSA_OLD	int
:	O
case	O
EM_XTENSA	int
:	O
return	O
(	O
reloc_type	int
==	O
0	int
||	O
reloc_type	int
==	O
17	int
||	O
reloc_type	int
==	O
18	int
||	O
reloc_type	int
==	O
19	int
)	O
;	O
}	O
return	O
FALSE	int
;	O
}	O
bfd_boolean	int
reloc_at	function
(	O
struct	O
dwarf_section	struct
*	O
dsec	pointer
,	O
dwarf_vma	long
offset	long
)	O
{	O
Elf_Internal_Rela	struct
*	O
relocs	pointer
;	O
Elf_Internal_Rela	struct
*	O
rp	pointer
;	O
if	O
(	O
dsec	pointer
==	O
NULL	O
||	O
dsec	pointer
->	O
reloc_info	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
relocs	pointer
=	O
(	O
Elf_Internal_Rela	struct
*	O
)	O
dsec	pointer
->	O
reloc_info	pointer
;	O
for	O
(	O
rp	pointer
=	O
relocs	pointer
;	O
rp	pointer
<	O
relocs	pointer
+	O
dsec	pointer
->	O
num_relocs	long
;	O
++	O
rp	pointer
)	O
if	O
(	O
rp	pointer
->	O
r_offset	array
==	O
offset	long
)	O
return	O
TRUE	int
;	O
return	O
FALSE	int
;	O
}	O
static	O
bfd_boolean	int
apply_relocations	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
const	O
Elf_Internal_Shdr	struct
*	O
section	pointer
,	O
unsigned	O
char	O
*	O
start	pointer
,	O
bfd_size_type	long
size	int
,	O
void	O
*	O
*	O
relocs_return	pointer
,	O
unsigned	O
long	O
*	O
num_relocs_return	pointer
)	O
{	O
Elf_Internal_Shdr	struct
*	O
relsec	pointer
;	O
unsigned	O
char	O
*	O
end	pointer
=	O
start	pointer
+	O
size	int
;	O
if	O
(	O
relocs_return	pointer
!=	O
NULL	O
)	O
{	O
*	O
(	O
Elf_Internal_Rela	struct
*	O
*	O
)	O
relocs_return	pointer
=	O
NULL	O
;	O
*	O
num_relocs_return	pointer
=	O
0	int
;	O
}	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_type	array
!=	O
ET_REL	int
)	O
return	O
TRUE	int
;	O
for	O
(	O
relsec	pointer
=	O
filedata	struct
->	O
section_headers	pointer
;	O
relsec	pointer
<	O
filedata	struct
->	O
section_headers	pointer
+	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
;	O
++	O
relsec	pointer
)	O
{	O
bfd_boolean	int
is_rela	int
;	O
unsigned	O
long	O
num_relocs	long
;	O
Elf_Internal_Rela	struct
*	O
relocs	pointer
;	O
Elf_Internal_Rela	struct
*	O
rp	pointer
;	O
Elf_Internal_Shdr	struct
*	O
symsec	pointer
;	O
Elf_Internal_Sym	struct
*	O
symtab	pointer
;	O
unsigned	O
long	O
num_syms	long
;	O
Elf_Internal_Sym	struct
*	O
sym	pointer
;	O
if	O
(	O
(	O
relsec	pointer
->	O
sh_type	array
!=	O
SHT_RELA	int
&&	O
relsec	pointer
->	O
sh_type	array
!=	O
SHT_REL	int
)	O
||	O
relsec	pointer
->	O
sh_info	array
>=	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
||	O
filedata	struct
->	O
section_headers	pointer
+	O
relsec	pointer
->	O
sh_info	array
!=	O
section	pointer
||	O
relsec	pointer
->	O
sh_size	array
==	O
0	int
||	O
relsec	pointer
->	O
sh_link	array
>=	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
)	O
continue	O
;	O
symsec	pointer
=	O
filedata	struct
->	O
section_headers	pointer
+	O
relsec	pointer
->	O
sh_link	array
;	O
if	O
(	O
symsec	pointer
->	O
sh_type	array
!=	O
SHT_SYMTAB	int
&&	O
symsec	pointer
->	O
sh_type	array
!=	O
SHT_DYNSYM	int
)	O
return	O
FALSE	int
;	O
is_rela	int
=	O
relsec	pointer
->	O
sh_type	array
==	O
SHT_RELA	int
;	O
if	O
(	O
is_rela	int
)	O
{	O
if	O
(	O
!	O
slurp_rela_relocs	function
(	O
filedata	struct
,	O
relsec	pointer
->	O
sh_offset	array
,	O
relsec	pointer
->	O
sh_size	array
,	O
&	O
relocs	pointer
,	O
&	O
num_relocs	long
)	O
)	O
return	O
FALSE	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
slurp_rel_relocs	function
(	O
filedata	struct
,	O
relsec	pointer
->	O
sh_offset	array
,	O
relsec	pointer
->	O
sh_size	array
,	O
&	O
relocs	pointer
,	O
&	O
num_relocs	long
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_SH	int
)	O
is_rela	int
=	O
FALSE	int
;	O
symtab	pointer
=	O
GET_ELF_SYMBOLS	O
(	O
filedata	struct
,	O
symsec	pointer
,	O
&	O
num_syms	long
)	O
;	O
for	O
(	O
rp	pointer
=	O
relocs	pointer
;	O
rp	pointer
<	O
relocs	pointer
+	O
num_relocs	long
;	O
++	O
rp	pointer
)	O
{	O
bfd_vma	long
addend	long
;	O
unsigned	O
int	O
reloc_type	int
;	O
unsigned	O
int	O
reloc_size	int
;	O
bfd_boolean	int
reloc_inplace	int
=	O
FALSE	int
;	O
bfd_boolean	int
reloc_subtract	int
=	O
FALSE	int
;	O
unsigned	O
char	O
*	O
rloc	pointer
;	O
unsigned	O
long	O
sym_index	long
;	O
reloc_type	int
=	O
get_reloc_type	function
(	O
filedata	struct
,	O
rp	pointer
->	O
r_info	array
)	O
;	O
if	O
(	O
target_specific_reloc_handling	function
(	O
filedata	struct
,	O
rp	pointer
,	O
start	pointer
,	O
end	pointer
,	O
symtab	pointer
,	O
num_syms	long
)	O
)	O
continue	O
;	O
else	O
if	O
(	O
is_none_reloc	function
(	O
filedata	struct
,	O
reloc_type	int
)	O
)	O
continue	O
;	O
else	O
if	O
(	O
is_32bit_abs_reloc	function
(	O
filedata	struct
,	O
reloc_type	int
)	O
||	O
is_32bit_pcrel_reloc	function
(	O
filedata	struct
,	O
reloc_type	int
)	O
)	O
reloc_size	int
=	O
4	int
;	O
else	O
if	O
(	O
is_64bit_abs_reloc	function
(	O
filedata	struct
,	O
reloc_type	int
)	O
||	O
is_64bit_pcrel_reloc	function
(	O
filedata	struct
,	O
reloc_type	int
)	O
)	O
reloc_size	int
=	O
8	int
;	O
else	O
if	O
(	O
is_24bit_abs_reloc	function
(	O
filedata	struct
,	O
reloc_type	int
)	O
)	O
reloc_size	int
=	O
3	int
;	O
else	O
if	O
(	O
is_16bit_abs_reloc	function
(	O
filedata	struct
,	O
reloc_type	int
)	O
)	O
reloc_size	int
=	O
2	int
;	O
else	O
if	O
(	O
is_8bit_abs_reloc	function
(	O
filedata	struct
,	O
reloc_type	int
)	O
||	O
is_6bit_abs_reloc	function
(	O
filedata	struct
,	O
reloc_type	int
)	O
)	O
reloc_size	int
=	O
1	int
;	O
else	O
if	O
(	O
(	O
reloc_subtract	int
=	O
is_32bit_inplace_sub_reloc	function
(	O
filedata	struct
,	O
reloc_type	int
)	O
)	O
||	O
is_32bit_inplace_add_reloc	function
(	O
filedata	struct
,	O
reloc_type	int
)	O
)	O
{	O
reloc_size	int
=	O
4	int
;	O
reloc_inplace	int
=	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
(	O
reloc_subtract	int
=	O
is_64bit_inplace_sub_reloc	function
(	O
filedata	struct
,	O
reloc_type	int
)	O
)	O
||	O
is_64bit_inplace_add_reloc	function
(	O
filedata	struct
,	O
reloc_type	int
)	O
)	O
{	O
reloc_size	int
=	O
8	int
;	O
reloc_inplace	int
=	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
(	O
reloc_subtract	int
=	O
is_16bit_inplace_sub_reloc	function
(	O
filedata	struct
,	O
reloc_type	int
)	O
)	O
||	O
is_16bit_inplace_add_reloc	function
(	O
filedata	struct
,	O
reloc_type	int
)	O
)	O
{	O
reloc_size	int
=	O
2	int
;	O
reloc_inplace	int
=	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
(	O
reloc_subtract	int
=	O
is_8bit_inplace_sub_reloc	function
(	O
filedata	struct
,	O
reloc_type	int
)	O
)	O
||	O
is_8bit_inplace_add_reloc	function
(	O
filedata	struct
,	O
reloc_type	int
)	O
)	O
{	O
reloc_size	int
=	O
1	int
;	O
reloc_inplace	int
=	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
(	O
reloc_subtract	int
=	O
is_6bit_inplace_sub_reloc	function
(	O
filedata	struct
,	O
reloc_type	int
)	O
)	O
)	O
{	O
reloc_size	int
=	O
1	int
;	O
reloc_inplace	int
=	O
TRUE	int
;	O
}	O
else	O
{	O
static	O
unsigned	O
int	O
prev_reloc	int
=	O
0	int
;	O
if	O
(	O
reloc_type	int
!=	O
prev_reloc	int
)	O
warn	function
(	O
_	O
(	O
"unable to apply unsupported reloc type %d to section %s\n"	pointer
)	O
,	O
reloc_type	int
,	O
printable_section_name	function
(	O
filedata	struct
,	O
section	pointer
)	O
)	O
;	O
prev_reloc	int
=	O
reloc_type	int
;	O
continue	O
;	O
}	O
rloc	pointer
=	O
start	pointer
+	O
rp	pointer
->	O
r_offset	array
;	O
if	O
(	O
!	O
IN_RANGE	O
(	O
start	pointer
,	O
end	pointer
,	O
rloc	pointer
,	O
reloc_size	int
)	O
)	O
{	O
warn	function
(	O
_	O
(	O
"skipping invalid relocation offset 0x%lx in section %s\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
rp	pointer
->	O
r_offset	array
,	O
printable_section_name	function
(	O
filedata	struct
,	O
section	pointer
)	O
)	O
;	O
continue	O
;	O
}	O
sym_index	long
=	O
(	O
unsigned	O
long	O
)	O
get_reloc_symindex	function
(	O
rp	pointer
->	O
r_info	array
)	O
;	O
if	O
(	O
sym_index	long
>=	O
num_syms	long
)	O
{	O
warn	function
(	O
_	O
(	O
"skipping invalid relocation symbol index 0x%lx in section %s\n"	pointer
)	O
,	O
sym_index	long
,	O
printable_section_name	function
(	O
filedata	struct
,	O
section	pointer
)	O
)	O
;	O
continue	O
;	O
}	O
sym	pointer
=	O
symtab	pointer
+	O
sym_index	long
;	O
if	O
(	O
sym	pointer
!=	O
symtab	pointer
&&	O
ELF_ST_TYPE	O
(	O
sym	pointer
->	O
st_info	array
)	O
!=	O
STT_COMMON	int
&&	O
ELF_ST_TYPE	O
(	O
sym	pointer
->	O
st_info	array
)	O
>	O
STT_SECTION	int
)	O
{	O
warn	function
(	O
_	O
(	O
"skipping unexpected symbol type %s in section %s relocation %ld\n"	pointer
)	O
,	O
get_symbol_type	function
(	O
filedata	struct
,	O
ELF_ST_TYPE	O
(	O
sym	pointer
->	O
st_info	array
)	O
)	O
,	O
printable_section_name	function
(	O
filedata	struct
,	O
relsec	pointer
)	O
,	O
(	O
long	O
int	O
)	O
(	O
rp	pointer
-	O
relocs	pointer
)	O
)	O
;	O
continue	O
;	O
}	O
addend	long
=	O
0	int
;	O
if	O
(	O
is_rela	int
)	O
addend	long
+=	O
rp	pointer
->	O
r_addend	array
;	O
if	O
(	O
!	O
is_rela	int
||	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_XTENSA	int
&&	O
reloc_type	int
==	O
1	int
)	O
||	O
(	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_PJ	int
||	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_PJ_OLD	int
)	O
&&	O
reloc_type	int
==	O
1	int
)	O
||	O
(	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_D30V	int
||	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_CYGNUS_D30V	int
)	O
&&	O
reloc_type	int
==	O
12	int
)	O
||	O
reloc_inplace	int
)	O
{	O
if	O
(	O
is_6bit_inplace_sub_reloc	function
(	O
filedata	struct
,	O
reloc_type	int
)	O
)	O
addend	long
+=	O
byte_get	pointer
(	O
rloc	pointer
,	O
reloc_size	int
)	O
&	O
0x3f	int
;	O
else	O
addend	long
+=	O
byte_get	pointer
(	O
rloc	pointer
,	O
reloc_size	int
)	O
;	O
}	O
if	O
(	O
is_32bit_pcrel_reloc	function
(	O
filedata	struct
,	O
reloc_type	int
)	O
||	O
is_64bit_pcrel_reloc	function
(	O
filedata	struct
,	O
reloc_type	int
)	O
)	O
{	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_PARISC	int
)	O
addend	long
-=	O
8	int
;	O
byte_put	pointer
(	O
rloc	pointer
,	O
(	O
addend	long
+	O
sym	pointer
->	O
st_value	int
)	O
-	O
rp	pointer
->	O
r_offset	array
,	O
reloc_size	int
)	O
;	O
}	O
else	O
if	O
(	O
is_6bit_abs_reloc	function
(	O
filedata	struct
,	O
reloc_type	int
)	O
||	O
is_6bit_inplace_sub_reloc	function
(	O
filedata	struct
,	O
reloc_type	int
)	O
)	O
{	O
if	O
(	O
reloc_subtract	int
)	O
addend	long
-=	O
sym	pointer
->	O
st_value	int
;	O
else	O
addend	long
+=	O
sym	pointer
->	O
st_value	int
;	O
addend	long
=	O
(	O
addend	long
&	O
0x3f	int
)	O
|	O
(	O
byte_get	pointer
(	O
rloc	pointer
,	O
reloc_size	int
)	O
&	O
0xc0	int
)	O
;	O
byte_put	pointer
(	O
rloc	pointer
,	O
addend	long
,	O
reloc_size	int
)	O
;	O
}	O
else	O
if	O
(	O
reloc_subtract	int
)	O
byte_put	pointer
(	O
rloc	pointer
,	O
addend	long
-	O
sym	pointer
->	O
st_value	int
,	O
reloc_size	int
)	O
;	O
else	O
byte_put	pointer
(	O
rloc	pointer
,	O
addend	long
+	O
sym	pointer
->	O
st_value	int
,	O
reloc_size	int
)	O
;	O
}	O
free	function
(	O
symtab	pointer
)	O
;	O
target_specific_reloc_handling	function
(	O
filedata	struct
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
relocs_return	pointer
)	O
{	O
*	O
(	O
Elf_Internal_Rela	struct
*	O
*	O
)	O
relocs_return	pointer
=	O
relocs	pointer
;	O
*	O
num_relocs_return	pointer
=	O
num_relocs	long
;	O
}	O
else	O
free	function
(	O
relocs	pointer
)	O
;	O
break	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
char	O
*	O
get_section_contents	function
(	O
Elf_Internal_Shdr	struct
*	O
section	pointer
,	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
bfd_size_type	long
num_bytes	long
=	O
section	pointer
->	O
sh_size	array
;	O
if	O
(	O
num_bytes	long
==	O
0	int
||	O
section	pointer
->	O
sh_type	array
==	O
SHT_NOBITS	int
)	O
{	O
printf	function
(	O
_	O
(	O
"Section '%s' has no data to dump.\n"	pointer
)	O
,	O
printable_section_name	function
(	O
filedata	struct
,	O
section	pointer
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
(	O
char	O
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
section	pointer
->	O
sh_offset	array
,	O
1	int
,	O
num_bytes	long
,	O
_	O
(	O
"section contents"	pointer
)	O
)	O
;	O
}	O
static	O
bfd_boolean	int
uncompress_section_contents	function
(	O
unsigned	O
char	O
*	O
*	O
buffer	pointer
,	O
dwarf_size_type	long
uncompressed_size	pointer
,	O
dwarf_size_type	long
*	O
size	int
)	O
{	O
dwarf_size_type	long
compressed_size	long
=	O
*	O
size	int
;	O
unsigned	O
char	O
*	O
compressed_buffer	pointer
=	O
*	O
buffer	pointer
;	O
unsigned	O
char	O
*	O
uncompressed_buffer	pointer
;	O
z_stream	struct
strm	pointer
;	O
int	O
rc	int
;	O
memset	function
(	O
&	O
strm	pointer
,	O
0	int
,	O
sizeof	O
strm	pointer
)	O
;	O
strm	pointer
.	O
avail_in	int
=	O
compressed_size	long
;	O
strm	pointer
.	O
next_in	pointer
=	O
(	O
Bytef	char
*	O
)	O
compressed_buffer	pointer
;	O
strm	pointer
.	O
avail_out	int
=	O
uncompressed_size	pointer
;	O
uncompressed_buffer	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
xmalloc	function
(	O
uncompressed_size	pointer
)	O
;	O
rc	int
=	O
inflateInit	O
(	O
&	O
strm	pointer
)	O
;	O
while	O
(	O
strm	pointer
.	O
avail_in	int
>	O
0	int
)	O
{	O
if	O
(	O
rc	int
!=	O
Z_OK	int
)	O
goto	O
fail	O
;	O
strm	pointer
.	O
next_out	pointer
=	O
(	O
(	O
Bytef	char
*	O
)	O
uncompressed_buffer	pointer
+	O
(	O
uncompressed_size	pointer
-	O
strm	pointer
.	O
avail_out	int
)	O
)	O
;	O
rc	int
=	O
inflate	function
(	O
&	O
strm	pointer
,	O
Z_FINISH	int
)	O
;	O
if	O
(	O
rc	int
!=	O
Z_STREAM_END	int
)	O
goto	O
fail	O
;	O
rc	int
=	O
inflateReset	function
(	O
&	O
strm	pointer
)	O
;	O
}	O
rc	int
=	O
inflateEnd	function
(	O
&	O
strm	pointer
)	O
;	O
if	O
(	O
rc	int
!=	O
Z_OK	int
||	O
strm	pointer
.	O
avail_out	int
!=	O
0	int
)	O
goto	O
fail	O
;	O
*	O
buffer	pointer
=	O
uncompressed_buffer	pointer
;	O
*	O
size	int
=	O
uncompressed_size	pointer
;	O
return	O
TRUE	int
;	O
fail	O
:	O
free	function
(	O
uncompressed_buffer	pointer
)	O
;	O
*	O
buffer	pointer
=	O
NULL	O
;	O
return	O
FALSE	int
;	O
}	O
static	O
bfd_boolean	int
dump_section_as_strings	function
(	O
Elf_Internal_Shdr	struct
*	O
section	pointer
,	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
Elf_Internal_Shdr	struct
*	O
relsec	pointer
;	O
bfd_size_type	long
num_bytes	long
;	O
unsigned	O
char	O
*	O
data	pointer
;	O
unsigned	O
char	O
*	O
end	pointer
;	O
unsigned	O
char	O
*	O
real_start	pointer
;	O
unsigned	O
char	O
*	O
start	pointer
;	O
bfd_boolean	int
some_strings_shown	int
;	O
real_start	pointer
=	O
start	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
get_section_contents	function
(	O
section	pointer
,	O
filedata	struct
)	O
;	O
if	O
(	O
start	pointer
==	O
NULL	O
)	O
return	O
(	O
section	pointer
->	O
sh_size	array
==	O
0	int
||	O
section	pointer
->	O
sh_type	array
==	O
SHT_NOBITS	int
)	O
?	O
TRUE	int
:	O
FALSE	int
;	O
num_bytes	long
=	O
section	pointer
->	O
sh_size	array
;	O
printf	function
(	O
_	O
(	O
"\nString dump of section '%s':\n"	pointer
)	O
,	O
printable_section_name	function
(	O
filedata	struct
,	O
section	pointer
)	O
)	O
;	O
if	O
(	O
decompress_dumps	int
)	O
{	O
dwarf_size_type	long
new_size	long
=	O
num_bytes	long
;	O
dwarf_size_type	long
uncompressed_size	pointer
=	O
0	int
;	O
if	O
(	O
(	O
section	pointer
->	O
sh_flags	array
&	O
SHF_COMPRESSED	O
)	O
!=	O
0	int
)	O
{	O
Elf_Internal_Chdr	struct
chdr	pointer
;	O
unsigned	O
int	O
compression_header_size	int
=	O
get_compression_header	function
(	O
&	O
chdr	pointer
,	O
(	O
unsigned	O
char	O
*	O
)	O
start	pointer
,	O
num_bytes	long
)	O
;	O
if	O
(	O
chdr	pointer
.	O
ch_type	array
!=	O
ELFCOMPRESS_ZLIB	int
)	O
{	O
warn	function
(	O
_	O
(	O
"section '%s' has unsupported compress type: %d\n"	pointer
)	O
,	O
printable_section_name	function
(	O
filedata	struct
,	O
section	pointer
)	O
,	O
chdr	pointer
.	O
ch_type	array
)	O
;	O
return	O
FALSE	int
;	O
}	O
uncompressed_size	pointer
=	O
chdr	pointer
.	O
ch_size	array
;	O
start	pointer
+=	O
compression_header_size	int
;	O
new_size	long
-=	O
compression_header_size	int
;	O
}	O
else	O
if	O
(	O
new_size	long
>	O
12	int
&&	O
streq	O
(	O
(	O
char	O
*	O
)	O
start	pointer
,	O
"ZLIB"	pointer
)	O
)	O
{	O
uncompressed_size	pointer
=	O
start	pointer
[	O
4	int
]	O
;	O
uncompressed_size	pointer
<<=	O
8	int
;	O
uncompressed_size	pointer
+=	O
start	pointer
[	O
5	int
]	O
;	O
uncompressed_size	pointer
<<=	O
8	int
;	O
uncompressed_size	pointer
+=	O
start	pointer
[	O
6	int
]	O
;	O
uncompressed_size	pointer
<<=	O
8	int
;	O
uncompressed_size	pointer
+=	O
start	pointer
[	O
7	int
]	O
;	O
uncompressed_size	pointer
<<=	O
8	int
;	O
uncompressed_size	pointer
+=	O
start	pointer
[	O
8	int
]	O
;	O
uncompressed_size	pointer
<<=	O
8	int
;	O
uncompressed_size	pointer
+=	O
start	pointer
[	O
9	int
]	O
;	O
uncompressed_size	pointer
<<=	O
8	int
;	O
uncompressed_size	pointer
+=	O
start	pointer
[	O
10	int
]	O
;	O
uncompressed_size	pointer
<<=	O
8	int
;	O
uncompressed_size	pointer
+=	O
start	pointer
[	O
11	int
]	O
;	O
start	pointer
+=	O
12	int
;	O
new_size	long
-=	O
12	int
;	O
}	O
if	O
(	O
uncompressed_size	pointer
)	O
{	O
if	O
(	O
uncompress_section_contents	function
(	O
&	O
start	pointer
,	O
uncompressed_size	pointer
,	O
&	O
new_size	long
)	O
)	O
num_bytes	long
=	O
new_size	long
;	O
else	O
{	O
error	function
(	O
_	O
(	O
"Unable to decompress section %s\n"	pointer
)	O
,	O
printable_section_name	function
(	O
filedata	struct
,	O
section	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
else	O
start	pointer
=	O
real_start	pointer
;	O
}	O
for	O
(	O
relsec	pointer
=	O
filedata	struct
->	O
section_headers	pointer
;	O
relsec	pointer
<	O
filedata	struct
->	O
section_headers	pointer
+	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
;	O
++	O
relsec	pointer
)	O
{	O
if	O
(	O
(	O
relsec	pointer
->	O
sh_type	array
!=	O
SHT_RELA	int
&&	O
relsec	pointer
->	O
sh_type	array
!=	O
SHT_REL	int
)	O
||	O
relsec	pointer
->	O
sh_info	array
>=	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
||	O
filedata	struct
->	O
section_headers	pointer
+	O
relsec	pointer
->	O
sh_info	array
!=	O
section	pointer
||	O
relsec	pointer
->	O
sh_size	array
==	O
0	int
||	O
relsec	pointer
->	O
sh_link	array
>=	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
)	O
continue	O
;	O
printf	function
(	O
_	O
(	O
"  Note: This section has relocations against it, but these have NOT been applied to this dump.\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
data	pointer
=	O
start	pointer
;	O
end	pointer
=	O
start	pointer
+	O
num_bytes	long
;	O
some_strings_shown	int
=	O
FALSE	int
;	O
while	O
(	O
data	pointer
<	O
end	pointer
)	O
{	O
while	O
(	O
!	O
ISPRINT	O
(	O
*	O
data	pointer
)	O
)	O
if	O
(	O
++	O
data	pointer
>=	O
end	pointer
)	O
break	O
;	O
if	O
(	O
data	pointer
<	O
end	pointer
)	O
{	O
size_t	long
maxlen	long
=	O
end	pointer
-	O
data	pointer
;	O
printf	function
(	O
"  [%6tx]  "	pointer
,	O
data	pointer
-	O
start	pointer
)	O
;	O
if	O
(	O
maxlen	long
>	O
0	int
)	O
{	O
print_symbol	function
(	O
(	O
int	O
)	O
maxlen	long
,	O
(	O
const	O
char	O
*	O
)	O
data	pointer
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
data	pointer
+=	O
strnlen	function
(	O
(	O
const	O
char	O
*	O
)	O
data	pointer
,	O
maxlen	long
)	O
;	O
}	O
else	O
{	O
printf	function
(	O
_	O
(	O
"<corrupt>\n"	pointer
)	O
)	O
;	O
data	pointer
=	O
end	pointer
;	O
}	O
some_strings_shown	int
=	O
TRUE	int
;	O
}	O
}	O
if	O
(	O
!	O
some_strings_shown	int
)	O
printf	function
(	O
_	O
(	O
"  No strings found in this section."	pointer
)	O
)	O
;	O
free	function
(	O
real_start	pointer
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
dump_section_as_bytes	function
(	O
Elf_Internal_Shdr	struct
*	O
section	pointer
,	O
Filedata	struct
*	O
filedata	struct
,	O
bfd_boolean	int
relocate	int
)	O
{	O
Elf_Internal_Shdr	struct
*	O
relsec	pointer
;	O
bfd_size_type	long
bytes	long
;	O
bfd_size_type	long
section_size	long
;	O
bfd_vma	long
addr	pointer
;	O
unsigned	O
char	O
*	O
data	pointer
;	O
unsigned	O
char	O
*	O
real_start	pointer
;	O
unsigned	O
char	O
*	O
start	pointer
;	O
real_start	pointer
=	O
start	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
get_section_contents	function
(	O
section	pointer
,	O
filedata	struct
)	O
;	O
if	O
(	O
start	pointer
==	O
NULL	O
)	O
return	O
(	O
section	pointer
->	O
sh_size	array
==	O
0	int
||	O
section	pointer
->	O
sh_type	array
==	O
SHT_NOBITS	int
)	O
?	O
TRUE	int
:	O
FALSE	int
;	O
section_size	long
=	O
section	pointer
->	O
sh_size	array
;	O
printf	function
(	O
_	O
(	O
"\nHex dump of section '%s':\n"	pointer
)	O
,	O
printable_section_name	function
(	O
filedata	struct
,	O
section	pointer
)	O
)	O
;	O
if	O
(	O
decompress_dumps	int
)	O
{	O
dwarf_size_type	long
new_size	long
=	O
section_size	long
;	O
dwarf_size_type	long
uncompressed_size	pointer
=	O
0	int
;	O
if	O
(	O
(	O
section	pointer
->	O
sh_flags	array
&	O
SHF_COMPRESSED	O
)	O
!=	O
0	int
)	O
{	O
Elf_Internal_Chdr	struct
chdr	pointer
;	O
unsigned	O
int	O
compression_header_size	int
=	O
get_compression_header	function
(	O
&	O
chdr	pointer
,	O
start	pointer
,	O
section_size	long
)	O
;	O
if	O
(	O
chdr	pointer
.	O
ch_type	array
!=	O
ELFCOMPRESS_ZLIB	int
)	O
{	O
warn	function
(	O
_	O
(	O
"section '%s' has unsupported compress type: %d\n"	pointer
)	O
,	O
printable_section_name	function
(	O
filedata	struct
,	O
section	pointer
)	O
,	O
chdr	pointer
.	O
ch_type	array
)	O
;	O
return	O
FALSE	int
;	O
}	O
uncompressed_size	pointer
=	O
chdr	pointer
.	O
ch_size	array
;	O
start	pointer
+=	O
compression_header_size	int
;	O
new_size	long
-=	O
compression_header_size	int
;	O
}	O
else	O
if	O
(	O
new_size	long
>	O
12	int
&&	O
streq	O
(	O
(	O
char	O
*	O
)	O
start	pointer
,	O
"ZLIB"	pointer
)	O
)	O
{	O
uncompressed_size	pointer
=	O
start	pointer
[	O
4	int
]	O
;	O
uncompressed_size	pointer
<<=	O
8	int
;	O
uncompressed_size	pointer
+=	O
start	pointer
[	O
5	int
]	O
;	O
uncompressed_size	pointer
<<=	O
8	int
;	O
uncompressed_size	pointer
+=	O
start	pointer
[	O
6	int
]	O
;	O
uncompressed_size	pointer
<<=	O
8	int
;	O
uncompressed_size	pointer
+=	O
start	pointer
[	O
7	int
]	O
;	O
uncompressed_size	pointer
<<=	O
8	int
;	O
uncompressed_size	pointer
+=	O
start	pointer
[	O
8	int
]	O
;	O
uncompressed_size	pointer
<<=	O
8	int
;	O
uncompressed_size	pointer
+=	O
start	pointer
[	O
9	int
]	O
;	O
uncompressed_size	pointer
<<=	O
8	int
;	O
uncompressed_size	pointer
+=	O
start	pointer
[	O
10	int
]	O
;	O
uncompressed_size	pointer
<<=	O
8	int
;	O
uncompressed_size	pointer
+=	O
start	pointer
[	O
11	int
]	O
;	O
start	pointer
+=	O
12	int
;	O
new_size	long
-=	O
12	int
;	O
}	O
if	O
(	O
uncompressed_size	pointer
)	O
{	O
if	O
(	O
uncompress_section_contents	function
(	O
&	O
start	pointer
,	O
uncompressed_size	pointer
,	O
&	O
new_size	long
)	O
)	O
{	O
section_size	long
=	O
new_size	long
;	O
}	O
else	O
{	O
error	function
(	O
_	O
(	O
"Unable to decompress section %s\n"	pointer
)	O
,	O
printable_section_name	function
(	O
filedata	struct
,	O
section	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
else	O
start	pointer
=	O
real_start	pointer
;	O
}	O
if	O
(	O
relocate	int
)	O
{	O
if	O
(	O
!	O
apply_relocations	function
(	O
filedata	struct
,	O
section	pointer
,	O
start	pointer
,	O
section_size	long
,	O
NULL	O
,	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
}	O
else	O
{	O
for	O
(	O
relsec	pointer
=	O
filedata	struct
->	O
section_headers	pointer
;	O
relsec	pointer
<	O
filedata	struct
->	O
section_headers	pointer
+	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
;	O
++	O
relsec	pointer
)	O
{	O
if	O
(	O
(	O
relsec	pointer
->	O
sh_type	array
!=	O
SHT_RELA	int
&&	O
relsec	pointer
->	O
sh_type	array
!=	O
SHT_REL	int
)	O
||	O
relsec	pointer
->	O
sh_info	array
>=	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
||	O
filedata	struct
->	O
section_headers	pointer
+	O
relsec	pointer
->	O
sh_info	array
!=	O
section	pointer
||	O
relsec	pointer
->	O
sh_size	array
==	O
0	int
||	O
relsec	pointer
->	O
sh_link	array
>=	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
)	O
continue	O
;	O
printf	function
(	O
_	O
(	O
" NOTE: This section has relocations against it, but these have NOT been applied to this dump.\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
}	O
addr	pointer
=	O
section	pointer
->	O
sh_addr	array
;	O
bytes	long
=	O
section_size	long
;	O
data	pointer
=	O
start	pointer
;	O
while	O
(	O
bytes	long
)	O
{	O
int	O
j	int
;	O
int	O
k	int
;	O
int	O
lbytes	int
;	O
lbytes	int
=	O
(	O
bytes	long
>	O
16	int
?	O
16	int
:	O
bytes	long
)	O
;	O
printf	function
(	O
"  0x%8.8lx "	pointer
,	O
(	O
unsigned	O
long	O
)	O
addr	pointer
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
16	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
j	int
<	O
lbytes	int
)	O
printf	function
(	O
"%2.2x"	pointer
,	O
data	pointer
[	O
j	int
]	O
)	O
;	O
else	O
printf	function
(	O
"  "	pointer
)	O
;	O
if	O
(	O
(	O
j	int
&	O
3	int
)	O
==	O
3	int
)	O
printf	function
(	O
" "	pointer
)	O
;	O
}	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
lbytes	int
;	O
j	int
++	O
)	O
{	O
k	int
=	O
data	pointer
[	O
j	int
]	O
;	O
if	O
(	O
k	int
>=	O
' '	O
&&	O
k	int
<	O
0x7f	int
)	O
printf	function
(	O
"%c"	pointer
,	O
k	int
)	O
;	O
else	O
printf	function
(	O
"."	pointer
)	O
;	O
}	O
putchar	function
(	O
'\n'	O
)	O
;	O
data	pointer
+=	O
lbytes	int
;	O
addr	pointer
+=	O
lbytes	int
;	O
bytes	long
-=	O
lbytes	int
;	O
}	O
free	function
(	O
real_start	pointer
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
ctf_sect_t	struct
*	O
shdr_to_ctf_sect	function
(	O
ctf_sect_t	struct
*	O
buf	pointer
,	O
Elf_Internal_Shdr	struct
*	O
shdr	pointer
,	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
buf	pointer
->	O
cts_name	pointer
=	O
SECTION_NAME	O
(	O
shdr	pointer
)	O
;	O
buf	pointer
->	O
cts_size	long
=	O
shdr	pointer
->	O
sh_size	array
;	O
buf	pointer
->	O
cts_entsize	long
=	O
shdr	pointer
->	O
sh_entsize	array
;	O
return	O
buf	pointer
;	O
}	O
static	O
char	O
*	O
dump_ctf_indent_lines	function
(	O
ctf_sect_names_t	enum
sect	pointer
ATTRIBUTE_UNUSED	O
,	O
char	O
*	O
s	pointer
,	O
void	O
*	O
arg	pointer
)	O
{	O
const	O
char	O
*	O
blanks	pointer
=	O
arg	pointer
;	O
char	O
*	O
new_s	pointer
;	O
if	O
(	O
asprintf	function
(	O
&	O
new_s	pointer
,	O
"%s%s"	pointer
,	O
blanks	pointer
,	O
s	pointer
)	O
<	O
0	int
)	O
return	O
s	pointer
;	O
return	O
new_s	pointer
;	O
}	O
static	O
bfd_boolean	int
dump_section_as_ctf	function
(	O
Elf_Internal_Shdr	struct
*	O
section	pointer
,	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
Elf_Internal_Shdr	struct
*	O
parent_sec	pointer
=	O
NULL	O
;	O
Elf_Internal_Shdr	struct
*	O
symtab_sec	pointer
=	O
NULL	O
;	O
Elf_Internal_Shdr	struct
*	O
strtab_sec	pointer
=	O
NULL	O
;	O
void	O
*	O
data	pointer
=	O
NULL	O
;	O
void	O
*	O
symdata	pointer
=	O
NULL	O
;	O
void	O
*	O
strdata	pointer
=	O
NULL	O
;	O
void	O
*	O
parentdata	pointer
=	O
NULL	O
;	O
ctf_sect_t	struct
ctfsect	struct
,	O
symsect	struct
,	O
strsect	struct
,	O
parentsect	struct
;	O
ctf_sect_t	struct
*	O
symsectp	pointer
=	O
NULL	O
;	O
ctf_sect_t	struct
*	O
strsectp	pointer
=	O
NULL	O
;	O
ctf_file_t	struct
*	O
ctf	pointer
=	O
NULL	O
;	O
ctf_file_t	struct
*	O
parent	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
things	array
[	O
]	O
=	O
{	O
"Header"	pointer
,	O
"Labels"	pointer
,	O
"Data objects"	pointer
,	O
"Function objects"	pointer
,	O
"Variables"	pointer
,	O
"Types"	pointer
,	O
"Strings"	pointer
,	O
""	pointer
}	O
;	O
const	O
char	O
*	O
*	O
thing	pointer
;	O
int	O
err	pointer
;	O
bfd_boolean	int
ret	pointer
=	O
FALSE	int
;	O
size_t	long
i	pointer
;	O
shdr_to_ctf_sect	function
(	O
&	O
ctfsect	struct
,	O
section	pointer
,	O
filedata	struct
)	O
;	O
data	pointer
=	O
get_section_contents	function
(	O
section	pointer
,	O
filedata	struct
)	O
;	O
ctfsect	struct
.	O
cts_data	pointer
=	O
data	pointer
;	O
if	O
(	O
!	O
dump_ctf_symtab_name	pointer
)	O
dump_ctf_symtab_name	pointer
=	O
strdup	function
(	O
".symtab"	pointer
)	O
;	O
if	O
(	O
!	O
dump_ctf_strtab_name	pointer
)	O
dump_ctf_strtab_name	pointer
=	O
strdup	function
(	O
".strtab"	pointer
)	O
;	O
if	O
(	O
dump_ctf_symtab_name	pointer
&&	O
dump_ctf_symtab_name	pointer
[	O
0	int
]	O
!=	O
0	int
)	O
{	O
if	O
(	O
(	O
symtab_sec	pointer
=	O
find_section	function
(	O
filedata	struct
,	O
dump_ctf_symtab_name	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"No symbol section named %s\n"	pointer
)	O
,	O
dump_ctf_symtab_name	pointer
)	O
;	O
goto	O
fail	O
;	O
}	O
if	O
(	O
(	O
symdata	pointer
=	O
(	O
void	O
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
symtab_sec	pointer
->	O
sh_offset	array
,	O
1	int
,	O
symtab_sec	pointer
->	O
sh_size	array
,	O
_	O
(	O
"symbols"	pointer
)	O
)	O
)	O
==	O
NULL	O
)	O
goto	O
fail	O
;	O
symsectp	pointer
=	O
shdr_to_ctf_sect	function
(	O
&	O
symsect	struct
,	O
symtab_sec	pointer
,	O
filedata	struct
)	O
;	O
symsect	struct
.	O
cts_data	pointer
=	O
symdata	pointer
;	O
}	O
if	O
(	O
dump_ctf_strtab_name	pointer
&&	O
dump_ctf_symtab_name	pointer
[	O
0	int
]	O
!=	O
0	int
)	O
{	O
if	O
(	O
(	O
strtab_sec	pointer
=	O
find_section	function
(	O
filedata	struct
,	O
dump_ctf_strtab_name	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"No string table section named %s\n"	pointer
)	O
,	O
dump_ctf_strtab_name	pointer
)	O
;	O
goto	O
fail	O
;	O
}	O
if	O
(	O
(	O
strdata	pointer
=	O
(	O
void	O
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
strtab_sec	pointer
->	O
sh_offset	array
,	O
1	int
,	O
strtab_sec	pointer
->	O
sh_size	array
,	O
_	O
(	O
"strings"	pointer
)	O
)	O
)	O
==	O
NULL	O
)	O
goto	O
fail	O
;	O
strsectp	pointer
=	O
shdr_to_ctf_sect	function
(	O
&	O
strsect	struct
,	O
strtab_sec	pointer
,	O
filedata	struct
)	O
;	O
strsect	struct
.	O
cts_data	pointer
=	O
strdata	pointer
;	O
}	O
if	O
(	O
dump_ctf_parent_name	pointer
)	O
{	O
if	O
(	O
(	O
parent_sec	pointer
=	O
find_section	function
(	O
filedata	struct
,	O
dump_ctf_parent_name	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"No CTF parent section named %s\n"	pointer
)	O
,	O
dump_ctf_parent_name	pointer
)	O
;	O
goto	O
fail	O
;	O
}	O
if	O
(	O
(	O
parentdata	pointer
=	O
(	O
void	O
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
parent_sec	pointer
->	O
sh_offset	array
,	O
1	int
,	O
parent_sec	pointer
->	O
sh_size	array
,	O
_	O
(	O
"CTF parent"	pointer
)	O
)	O
)	O
==	O
NULL	O
)	O
goto	O
fail	O
;	O
shdr_to_ctf_sect	function
(	O
&	O
parentsect	struct
,	O
parent_sec	pointer
,	O
filedata	struct
)	O
;	O
parentsect	struct
.	O
cts_data	pointer
=	O
parentdata	pointer
;	O
}	O
if	O
(	O
(	O
ctf	pointer
=	O
ctf_bufopen	function
(	O
&	O
ctfsect	struct
,	O
symsectp	pointer
,	O
strsectp	pointer
,	O
&	O
err	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"CTF open failure: %s\n"	pointer
)	O
,	O
ctf_errmsg	function
(	O
err	pointer
)	O
)	O
;	O
goto	O
fail	O
;	O
}	O
if	O
(	O
parentdata	pointer
)	O
{	O
if	O
(	O
(	O
parent	pointer
=	O
ctf_bufopen	function
(	O
&	O
parentsect	struct
,	O
symsectp	pointer
,	O
strsectp	pointer
,	O
&	O
err	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"CTF open failure: %s\n"	pointer
)	O
,	O
ctf_errmsg	function
(	O
err	pointer
)	O
)	O
;	O
goto	O
fail	O
;	O
}	O
ctf_import	function
(	O
ctf	pointer
,	O
parent	pointer
)	O
;	O
}	O
ret	pointer
=	O
TRUE	int
;	O
printf	function
(	O
_	O
(	O
"\nDump of CTF section '%s':\n"	pointer
)	O
,	O
printable_section_name	function
(	O
filedata	struct
,	O
section	pointer
)	O
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
,	O
thing	pointer
=	O
things	array
;	O
*	O
thing	pointer
[	O
0	int
]	O
;	O
thing	pointer
++	O
,	O
i	pointer
++	O
)	O
{	O
ctf_dump_state_t	struct
*	O
s	pointer
=	O
NULL	O
;	O
char	O
*	O
item	pointer
;	O
printf	function
(	O
"\n  %s:\n"	pointer
,	O
*	O
thing	pointer
)	O
;	O
while	O
(	O
(	O
item	pointer
=	O
ctf_dump	function
(	O
ctf	pointer
,	O
&	O
s	pointer
,	O
i	pointer
,	O
dump_ctf_indent_lines	function
,	O
(	O
void	O
*	O
)	O
"    "	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
printf	function
(	O
"%s\n"	pointer
,	O
item	pointer
)	O
;	O
free	function
(	O
item	pointer
)	O
;	O
}	O
if	O
(	O
ctf_errno	function
(	O
ctf	pointer
)	O
)	O
{	O
error	function
(	O
_	O
(	O
"Iteration failed: %s, %s\n"	pointer
)	O
,	O
*	O
thing	pointer
,	O
ctf_errmsg	function
(	O
ctf_errno	function
(	O
ctf	pointer
)	O
)	O
)	O
;	O
ret	pointer
=	O
FALSE	int
;	O
}	O
}	O
fail	O
:	O
ctf_file_close	function
(	O
ctf	pointer
)	O
;	O
ctf_file_close	function
(	O
parent	pointer
)	O
;	O
free	function
(	O
parentdata	pointer
)	O
;	O
free	function
(	O
data	pointer
)	O
;	O
free	function
(	O
symdata	pointer
)	O
;	O
free	function
(	O
strdata	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
static	O
bfd_boolean	int
load_specific_debug_section	function
(	O
enum	O
dwarf_section_display_enum	enum
debug	int
,	O
const	O
Elf_Internal_Shdr	struct
*	O
sec	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
dwarf_section	struct
*	O
section	pointer
=	O
&	O
debug_displays	array
[	O
debug	int
]	O
.	O
section	pointer
;	O
char	O
buf	pointer
[	O
64	int
]	O
;	O
Filedata	struct
*	O
filedata	struct
=	O
(	O
Filedata	struct
*	O
)	O
data	pointer
;	O
if	O
(	O
section	pointer
->	O
start	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
streq	O
(	O
section	pointer
->	O
filename	pointer
,	O
filedata	struct
->	O
file_name	pointer
)	O
)	O
return	O
TRUE	int
;	O
free	function
(	O
section	pointer
->	O
start	pointer
)	O
;	O
}	O
snprintf	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
_	O
(	O
"%s section data"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
)	O
;	O
section	pointer
->	O
address	pointer
=	O
sec	pointer
->	O
sh_addr	array
;	O
section	pointer
->	O
user_data	pointer
=	O
NULL	O
;	O
section	pointer
->	O
filename	pointer
=	O
filedata	struct
->	O
file_name	pointer
;	O
section	pointer
->	O
start	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
sec	pointer
->	O
sh_offset	array
,	O
1	int
,	O
sec	pointer
->	O
sh_size	array
,	O
buf	pointer
)	O
;	O
if	O
(	O
section	pointer
->	O
start	pointer
==	O
NULL	O
)	O
section	pointer
->	O
size	int
=	O
0	int
;	O
else	O
{	O
unsigned	O
char	O
*	O
start	pointer
=	O
section	pointer
->	O
start	pointer
;	O
dwarf_size_type	long
size	int
=	O
sec	pointer
->	O
sh_size	array
;	O
dwarf_size_type	long
uncompressed_size	pointer
=	O
0	int
;	O
if	O
(	O
(	O
sec	pointer
->	O
sh_flags	array
&	O
SHF_COMPRESSED	O
)	O
!=	O
0	int
)	O
{	O
Elf_Internal_Chdr	struct
chdr	pointer
;	O
unsigned	O
int	O
compression_header_size	int
;	O
if	O
(	O
size	int
<	O
(	O
is_32bit_elf	int
?	O
sizeof	O
(	O
Elf32_External_Chdr	struct
)	O
:	O
sizeof	O
(	O
Elf64_External_Chdr	struct
)	O
)	O
)	O
{	O
warn	function
(	O
_	O
(	O
"compressed section %s is too small to contain a compression header"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
compression_header_size	int
=	O
get_compression_header	function
(	O
&	O
chdr	pointer
,	O
start	pointer
,	O
size	int
)	O
;	O
if	O
(	O
chdr	pointer
.	O
ch_type	array
!=	O
ELFCOMPRESS_ZLIB	int
)	O
{	O
warn	function
(	O
_	O
(	O
"section '%s' has unsupported compress type: %d\n"	pointer
)	O
,	O
section	pointer
->	O
name	pointer
,	O
chdr	pointer
.	O
ch_type	array
)	O
;	O
return	O
FALSE	int
;	O
}	O
uncompressed_size	pointer
=	O
chdr	pointer
.	O
ch_size	array
;	O
start	pointer
+=	O
compression_header_size	int
;	O
size	int
-=	O
compression_header_size	int
;	O
}	O
else	O
if	O
(	O
size	int
>	O
12	int
&&	O
streq	O
(	O
(	O
char	O
*	O
)	O
start	pointer
,	O
"ZLIB"	pointer
)	O
)	O
{	O
uncompressed_size	pointer
=	O
start	pointer
[	O
4	int
]	O
;	O
uncompressed_size	pointer
<<=	O
8	int
;	O
uncompressed_size	pointer
+=	O
start	pointer
[	O
5	int
]	O
;	O
uncompressed_size	pointer
<<=	O
8	int
;	O
uncompressed_size	pointer
+=	O
start	pointer
[	O
6	int
]	O
;	O
uncompressed_size	pointer
<<=	O
8	int
;	O
uncompressed_size	pointer
+=	O
start	pointer
[	O
7	int
]	O
;	O
uncompressed_size	pointer
<<=	O
8	int
;	O
uncompressed_size	pointer
+=	O
start	pointer
[	O
8	int
]	O
;	O
uncompressed_size	pointer
<<=	O
8	int
;	O
uncompressed_size	pointer
+=	O
start	pointer
[	O
9	int
]	O
;	O
uncompressed_size	pointer
<<=	O
8	int
;	O
uncompressed_size	pointer
+=	O
start	pointer
[	O
10	int
]	O
;	O
uncompressed_size	pointer
<<=	O
8	int
;	O
uncompressed_size	pointer
+=	O
start	pointer
[	O
11	int
]	O
;	O
start	pointer
+=	O
12	int
;	O
size	int
-=	O
12	int
;	O
}	O
if	O
(	O
uncompressed_size	pointer
)	O
{	O
if	O
(	O
uncompress_section_contents	function
(	O
&	O
start	pointer
,	O
uncompressed_size	pointer
,	O
&	O
size	int
)	O
)	O
{	O
free	function
(	O
section	pointer
->	O
start	pointer
)	O
;	O
section	pointer
->	O
start	pointer
=	O
start	pointer
;	O
}	O
else	O
{	O
error	function
(	O
_	O
(	O
"Unable to decompress section %s\n"	pointer
)	O
,	O
printable_section_name	function
(	O
filedata	struct
,	O
sec	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
section	pointer
->	O
size	int
=	O
size	int
;	O
}	O
if	O
(	O
section	pointer
->	O
start	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
debug_displays	array
[	O
debug	int
]	O
.	O
relocate	int
)	O
{	O
if	O
(	O
!	O
apply_relocations	function
(	O
filedata	struct
,	O
sec	pointer
,	O
section	pointer
->	O
start	pointer
,	O
section	pointer
->	O
size	int
,	O
&	O
section	pointer
->	O
reloc_info	pointer
,	O
&	O
section	pointer
->	O
num_relocs	long
)	O
)	O
return	O
FALSE	int
;	O
}	O
else	O
{	O
section	pointer
->	O
reloc_info	pointer
=	O
NULL	O
;	O
section	pointer
->	O
num_relocs	long
=	O
0	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
unsigned	O
int	O
*	O
section_subset	pointer
=	O
NULL	O
;	O
bfd_boolean	int
load_debug_section	function
(	O
enum	O
dwarf_section_display_enum	enum
debug	int
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
dwarf_section	struct
*	O
section	pointer
=	O
&	O
debug_displays	array
[	O
debug	int
]	O
.	O
section	pointer
;	O
Elf_Internal_Shdr	struct
*	O
sec	pointer
;	O
Filedata	struct
*	O
filedata	struct
=	O
(	O
Filedata	struct
*	O
)	O
data	pointer
;	O
if	O
(	O
filedata	struct
->	O
section_headers	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
filedata	struct
->	O
string_table	pointer
==	O
NULL	O
&&	O
filedata	struct
->	O
file_header	struct
.	O
e_shstrndx	array
!=	O
SHN_UNDEF	int
&&	O
filedata	struct
->	O
file_header	struct
.	O
e_shstrndx	array
<	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
)	O
{	O
Elf_Internal_Shdr	struct
*	O
strs	pointer
;	O
strs	pointer
=	O
filedata	struct
->	O
section_headers	pointer
+	O
filedata	struct
->	O
file_header	struct
.	O
e_shstrndx	array
;	O
if	O
(	O
strs	pointer
!=	O
NULL	O
&&	O
strs	pointer
->	O
sh_size	array
!=	O
0	int
)	O
{	O
filedata	struct
->	O
string_table	pointer
=	O
(	O
char	O
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
strs	pointer
->	O
sh_offset	array
,	O
1	int
,	O
strs	pointer
->	O
sh_size	array
,	O
_	O
(	O
"string table"	pointer
)	O
)	O
;	O
filedata	struct
->	O
string_table_length	long
=	O
filedata	struct
->	O
string_table	pointer
!=	O
NULL	O
?	O
strs	pointer
->	O
sh_size	array
:	O
0	int
;	O
}	O
}	O
sec	pointer
=	O
find_section_in_set	function
(	O
filedata	struct
,	O
section	pointer
->	O
uncompressed_name	pointer
,	O
section_subset	pointer
)	O
;	O
if	O
(	O
sec	pointer
!=	O
NULL	O
)	O
section	pointer
->	O
name	pointer
=	O
section	pointer
->	O
uncompressed_name	pointer
;	O
else	O
{	O
sec	pointer
=	O
find_section_in_set	function
(	O
filedata	struct
,	O
section	pointer
->	O
compressed_name	pointer
,	O
section_subset	pointer
)	O
;	O
if	O
(	O
sec	pointer
!=	O
NULL	O
)	O
section	pointer
->	O
name	pointer
=	O
section	pointer
->	O
compressed_name	pointer
;	O
}	O
if	O
(	O
sec	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
section_subset	pointer
!=	O
NULL	O
)	O
free_debug_section	function
(	O
debug	int
)	O
;	O
return	O
load_specific_debug_section	function
(	O
debug	int
,	O
sec	pointer
,	O
data	pointer
)	O
;	O
}	O
void	O
free_debug_section	function
(	O
enum	O
dwarf_section_display_enum	enum
debug	int
)	O
{	O
struct	O
dwarf_section	struct
*	O
section	pointer
=	O
&	O
debug_displays	array
[	O
debug	int
]	O
.	O
section	pointer
;	O
if	O
(	O
section	pointer
->	O
start	pointer
==	O
NULL	O
)	O
return	O
;	O
free	function
(	O
(	O
char	O
*	O
)	O
section	pointer
->	O
start	pointer
)	O
;	O
section	pointer
->	O
start	pointer
=	O
NULL	O
;	O
section	pointer
->	O
address	pointer
=	O
0	int
;	O
section	pointer
->	O
size	int
=	O
0	int
;	O
if	O
(	O
section	pointer
->	O
reloc_info	pointer
!=	O
NULL	O
)	O
{	O
free	function
(	O
section	pointer
->	O
reloc_info	pointer
)	O
;	O
section	pointer
->	O
reloc_info	pointer
=	O
NULL	O
;	O
section	pointer
->	O
num_relocs	long
=	O
0	int
;	O
}	O
}	O
static	O
bfd_boolean	int
display_debug_section	function
(	O
int	O
shndx	pointer
,	O
Elf_Internal_Shdr	struct
*	O
section	pointer
,	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
char	O
*	O
name	pointer
=	O
SECTION_NAME	O
(	O
section	pointer
)	O
;	O
const	O
char	O
*	O
print_name	pointer
=	O
printable_section_name	function
(	O
filedata	struct
,	O
section	pointer
)	O
;	O
bfd_size_type	long
length	long
;	O
bfd_boolean	int
result	pointer
=	O
TRUE	int
;	O
int	O
i	pointer
;	O
length	long
=	O
section	pointer
->	O
sh_size	array
;	O
if	O
(	O
length	long
==	O
0	int
)	O
{	O
printf	function
(	O
_	O
(	O
"\nSection '%s' has no debugging data.\n"	pointer
)	O
,	O
print_name	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
section	pointer
->	O
sh_type	array
==	O
SHT_NOBITS	int
)	O
{	O
printf	function
(	O
_	O
(	O
"section '%s' has the NOBITS type - its contents are unreliable.\n"	pointer
)	O
,	O
print_name	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
const_strneq	O
(	O
name	pointer
,	O
".gnu.linkonce.wi."	pointer
)	O
)	O
name	pointer
=	O
".debug_info"	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
max	int
;	O
i	pointer
++	O
)	O
{	O
enum	O
dwarf_section_display_enum	enum
id	int
=	O
(	O
enum	O
dwarf_section_display_enum	enum
)	O
i	pointer
;	O
struct	O
dwarf_section_display	struct
*	O
display	pointer
=	O
debug_displays	array
+	O
i	pointer
;	O
struct	O
dwarf_section	struct
*	O
sec	pointer
=	O
&	O
display	pointer
->	O
section	pointer
;	O
if	O
(	O
streq	O
(	O
sec	pointer
->	O
uncompressed_name	pointer
,	O
name	pointer
)	O
||	O
(	O
id	int
==	O
line	int
&&	O
const_strneq	O
(	O
name	pointer
,	O
".debug_line."	pointer
)	O
)	O
||	O
streq	O
(	O
sec	pointer
->	O
compressed_name	pointer
,	O
name	pointer
)	O
)	O
{	O
bfd_boolean	int
secondary	int
=	O
(	O
section	pointer
!=	O
find_section	function
(	O
filedata	struct
,	O
name	pointer
)	O
)	O
;	O
if	O
(	O
secondary	int
)	O
free_debug_section	function
(	O
id	int
)	O
;	O
if	O
(	O
i	pointer
==	O
line	int
&&	O
const_strneq	O
(	O
name	pointer
,	O
".debug_line."	pointer
)	O
)	O
sec	pointer
->	O
name	pointer
=	O
name	pointer
;	O
else	O
if	O
(	O
streq	O
(	O
sec	pointer
->	O
uncompressed_name	pointer
,	O
name	pointer
)	O
)	O
sec	pointer
->	O
name	pointer
=	O
sec	pointer
->	O
uncompressed_name	pointer
;	O
else	O
sec	pointer
->	O
name	pointer
=	O
sec	pointer
->	O
compressed_name	pointer
;	O
if	O
(	O
load_specific_debug_section	function
(	O
id	int
,	O
section	pointer
,	O
filedata	struct
)	O
)	O
{	O
section_subset	pointer
=	O
find_cu_tu_set	function
(	O
filedata	struct
,	O
shndx	pointer
)	O
;	O
result	pointer
&=	O
display	pointer
->	O
display	pointer
(	O
sec	pointer
,	O
filedata	struct
)	O
;	O
section_subset	pointer
=	O
NULL	O
;	O
if	O
(	O
secondary	int
||	O
(	O
id	int
!=	O
info	pointer
&&	O
id	int
!=	O
abbrev	int
)	O
)	O
free_debug_section	function
(	O
id	int
)	O
;	O
}	O
break	O
;	O
}	O
}	O
if	O
(	O
i	pointer
==	O
max	int
)	O
{	O
printf	function
(	O
_	O
(	O
"Unrecognized debug section: %s\n"	pointer
)	O
,	O
print_name	pointer
)	O
;	O
result	pointer
=	O
FALSE	int
;	O
}	O
return	O
result	pointer
;	O
}	O
static	O
void	O
initialise_dumps_byname	function
(	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
struct	O
dump_list_entry	struct
*	O
cur	pointer
;	O
for	O
(	O
cur	pointer
=	O
dump_sects_byname	pointer
;	O
cur	pointer
;	O
cur	pointer
=	O
cur	pointer
->	O
next	pointer
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
bfd_boolean	int
any	pointer
=	O
FALSE	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
;	O
i	pointer
++	O
)	O
if	O
(	O
streq	O
(	O
SECTION_NAME	O
(	O
filedata	struct
->	O
section_headers	pointer
+	O
i	pointer
)	O
,	O
cur	pointer
->	O
name	pointer
)	O
)	O
{	O
request_dump_bynumber	function
(	O
filedata	struct
,	O
i	pointer
,	O
cur	pointer
->	O
type	enum
)	O
;	O
any	pointer
=	O
TRUE	int
;	O
}	O
if	O
(	O
!	O
any	pointer
)	O
warn	function
(	O
_	O
(	O
"Section '%s' was not dumped because it does not exist!\n"	pointer
)	O
,	O
cur	pointer
->	O
name	pointer
)	O
;	O
}	O
}	O
static	O
bfd_boolean	int
process_section_contents	function
(	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
Elf_Internal_Shdr	struct
*	O
section	pointer
;	O
unsigned	O
int	O
i	pointer
;	O
bfd_boolean	int
res	int
=	O
TRUE	int
;	O
if	O
(	O
!	O
do_dump	int
)	O
return	O
TRUE	int
;	O
initialise_dumps_byname	function
(	O
filedata	struct
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
,	O
section	pointer
=	O
filedata	struct
->	O
section_headers	pointer
;	O
i	pointer
<	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
&&	O
i	pointer
<	O
filedata	struct
->	O
num_dump_sects	int
;	O
i	pointer
++	O
,	O
section	pointer
++	O
)	O
{	O
dump_type	char
dump	char
=	O
filedata	struct
->	O
dump_sects	pointer
[	O
i	pointer
]	O
;	O
if	O
(	O
dump	char
&	O
HEX_DUMP	O
)	O
{	O
if	O
(	O
!	O
dump_section_as_bytes	function
(	O
section	pointer
,	O
filedata	struct
,	O
FALSE	int
)	O
)	O
res	int
=	O
FALSE	int
;	O
}	O
if	O
(	O
dump	char
&	O
RELOC_DUMP	O
)	O
{	O
if	O
(	O
!	O
dump_section_as_bytes	function
(	O
section	pointer
,	O
filedata	struct
,	O
TRUE	int
)	O
)	O
res	int
=	O
FALSE	int
;	O
}	O
if	O
(	O
dump	char
&	O
STRING_DUMP	O
)	O
{	O
if	O
(	O
!	O
dump_section_as_strings	function
(	O
section	pointer
,	O
filedata	struct
)	O
)	O
res	int
=	O
FALSE	int
;	O
}	O
if	O
(	O
dump	char
&	O
DEBUG_DUMP	O
)	O
{	O
if	O
(	O
!	O
display_debug_section	function
(	O
i	pointer
,	O
section	pointer
,	O
filedata	struct
)	O
)	O
res	int
=	O
FALSE	int
;	O
}	O
if	O
(	O
dump	char
&	O
CTF_DUMP	O
)	O
{	O
if	O
(	O
!	O
dump_section_as_ctf	function
(	O
section	pointer
,	O
filedata	struct
)	O
)	O
res	int
=	O
FALSE	int
;	O
}	O
}	O
while	O
(	O
i	pointer
<	O
filedata	struct
->	O
num_dump_sects	int
)	O
{	O
if	O
(	O
filedata	struct
->	O
dump_sects	pointer
[	O
i	pointer
]	O
)	O
{	O
warn	function
(	O
_	O
(	O
"Section %d was not dumped because it does not exist!\n"	pointer
)	O
,	O
i	pointer
)	O
;	O
res	int
=	O
FALSE	int
;	O
}	O
i	pointer
++	O
;	O
}	O
return	O
res	int
;	O
}	O
static	O
void	O
process_mips_fpe_exception	function
(	O
int	O
mask	int
)	O
{	O
if	O
(	O
mask	int
)	O
{	O
bfd_boolean	int
first	int
=	O
TRUE	int
;	O
if	O
(	O
mask	int
&	O
OEX_FPU_INEX	int
)	O
fputs	function
(	O
"INEX"	pointer
,	O
stdout	pointer
)	O
,	O
first	int
=	O
FALSE	int
;	O
if	O
(	O
mask	int
&	O
OEX_FPU_UFLO	int
)	O
printf	function
(	O
"%sUFLO"	pointer
,	O
first	int
?	O
""	pointer
:	O
"|"	pointer
)	O
,	O
first	int
=	O
FALSE	int
;	O
if	O
(	O
mask	int
&	O
OEX_FPU_OFLO	int
)	O
printf	function
(	O
"%sOFLO"	pointer
,	O
first	int
?	O
""	pointer
:	O
"|"	pointer
)	O
,	O
first	int
=	O
FALSE	int
;	O
if	O
(	O
mask	int
&	O
OEX_FPU_DIV0	int
)	O
printf	function
(	O
"%sDIV0"	pointer
,	O
first	int
?	O
""	pointer
:	O
"|"	pointer
)	O
,	O
first	int
=	O
FALSE	int
;	O
if	O
(	O
mask	int
&	O
OEX_FPU_INVAL	int
)	O
printf	function
(	O
"%sINVAL"	pointer
,	O
first	int
?	O
""	pointer
:	O
"|"	pointer
)	O
;	O
}	O
else	O
fputs	function
(	O
"0"	pointer
,	O
stdout	pointer
)	O
;	O
}	O
static	O
unsigned	O
char	O
*	O
display_tag_value	function
(	O
signed	O
int	O
tag	int
,	O
unsigned	O
char	O
*	O
p	pointer
,	O
const	O
unsigned	O
char	O
*	O
const	O
end	pointer
)	O
{	O
unsigned	O
long	O
val	array
;	O
if	O
(	O
tag	int
>	O
0	int
)	O
printf	function
(	O
"  Tag_unknown_%d: "	pointer
,	O
tag	int
)	O
;	O
if	O
(	O
p	pointer
>=	O
end	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"<corrupt tag>\n"	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
tag	int
&	O
1	int
)	O
{	O
size_t	long
maxlen	long
=	O
(	O
end	pointer
-	O
p	pointer
)	O
-	O
1	int
;	O
putchar	function
(	O
'"'	O
)	O
;	O
if	O
(	O
maxlen	long
>	O
0	int
)	O
{	O
print_symbol	function
(	O
(	O
int	O
)	O
maxlen	long
,	O
(	O
const	O
char	O
*	O
)	O
p	pointer
)	O
;	O
p	pointer
+=	O
strnlen	function
(	O
(	O
char	O
*	O
)	O
p	pointer
,	O
maxlen	long
)	O
+	O
1	int
;	O
}	O
else	O
{	O
printf	function
(	O
_	O
(	O
"<corrupt string tag>"	pointer
)	O
)	O
;	O
p	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
end	pointer
;	O
}	O
printf	function
(	O
"\"\n"	pointer
)	O
;	O
}	O
else	O
{	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"%ld (0x%lx)\n"	pointer
,	O
val	array
,	O
val	array
)	O
;	O
}	O
assert	O
(	O
p	pointer
<=	O
end	pointer
)	O
;	O
return	O
p	pointer
;	O
}	O
static	O
unsigned	O
char	O
*	O
display_arc_attribute	function
(	O
unsigned	O
char	O
*	O
p	pointer
,	O
const	O
unsigned	O
char	O
*	O
const	O
end	pointer
)	O
{	O
unsigned	O
int	O
tag	int
;	O
unsigned	O
int	O
val	array
;	O
READ_ULEB	O
(	O
tag	int
,	O
p	pointer
,	O
end	pointer
)	O
;	O
switch	O
(	O
tag	int
)	O
{	O
case	O
Tag_ARC_PCS_config	int
:	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"  Tag_ARC_PCS_config: "	pointer
)	O
;	O
switch	O
(	O
val	array
)	O
{	O
case	O
0	int
:	O
printf	function
(	O
_	O
(	O
"Absent/Non standard\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	function
(	O
_	O
(	O
"Bare metal/mwdt\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
printf	function
(	O
_	O
(	O
"Bare metal/newlib\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
3	int
:	O
printf	function
(	O
_	O
(	O
"Linux/uclibc\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
4	int
:	O
printf	function
(	O
_	O
(	O
"Linux/glibc\n"	pointer
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
_	O
(	O
"Unknown\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
Tag_ARC_CPU_base	int
:	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"  Tag_ARC_CPU_base: "	pointer
)	O
;	O
switch	O
(	O
val	array
)	O
{	O
default	O
:	O
case	O
TAG_CPU_NONE	int
:	O
printf	function
(	O
_	O
(	O
"Absent\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
TAG_CPU_ARC6xx	int
:	O
printf	function
(	O
"ARC6xx\n"	pointer
)	O
;	O
break	O
;	O
case	O
TAG_CPU_ARC7xx	int
:	O
printf	function
(	O
"ARC7xx\n"	pointer
)	O
;	O
break	O
;	O
case	O
TAG_CPU_ARCEM	int
:	O
printf	function
(	O
"ARCEM\n"	pointer
)	O
;	O
break	O
;	O
case	O
TAG_CPU_ARCHS	int
:	O
printf	function
(	O
"ARCHS\n"	pointer
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
Tag_ARC_CPU_variation	int
:	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"  Tag_ARC_CPU_variation: "	pointer
)	O
;	O
switch	O
(	O
val	array
)	O
{	O
default	O
:	O
if	O
(	O
val	array
>	O
0	int
&&	O
val	array
<	O
16	int
)	O
printf	function
(	O
"Core%d\n"	pointer
,	O
val	array
)	O
;	O
else	O
printf	function
(	O
"Unknown\n"	pointer
)	O
;	O
break	O
;	O
case	O
0	int
:	O
printf	function
(	O
_	O
(	O
"Absent\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
Tag_ARC_CPU_name	int
:	O
printf	function
(	O
"  Tag_ARC_CPU_name: "	pointer
)	O
;	O
p	pointer
=	O
display_tag_value	function
(	O
-	O
1	int
,	O
p	pointer
,	O
end	pointer
)	O
;	O
break	O
;	O
case	O
Tag_ARC_ABI_rf16	int
:	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"  Tag_ARC_ABI_rf16: %s\n"	pointer
,	O
val	array
?	O
_	O
(	O
"yes"	pointer
)	O
:	O
_	O
(	O
"no"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
Tag_ARC_ABI_osver	int
:	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"  Tag_ARC_ABI_osver: v%d\n"	pointer
,	O
val	array
)	O
;	O
break	O
;	O
case	O
Tag_ARC_ABI_pic	int
:	O
case	O
Tag_ARC_ABI_sda	int
:	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
tag	int
==	O
Tag_ARC_ABI_sda	int
?	O
"  Tag_ARC_ABI_sda: "	pointer
:	O
"  Tag_ARC_ABI_pic: "	pointer
)	O
;	O
switch	O
(	O
val	array
)	O
{	O
case	O
0	int
:	O
printf	function
(	O
_	O
(	O
"Absent\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	function
(	O
"MWDT\n"	pointer
)	O
;	O
break	O
;	O
case	O
2	int
:	O
printf	function
(	O
"GNU\n"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
_	O
(	O
"Unknown\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
Tag_ARC_ABI_tls	int
:	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"  Tag_ARC_ABI_tls: %s\n"	pointer
,	O
val	array
?	O
"r25"	pointer
:	O
"none"	pointer
)	O
;	O
break	O
;	O
case	O
Tag_ARC_ABI_enumsize	int
:	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"  Tag_ARC_ABI_enumsize: %s\n"	pointer
,	O
val	array
?	O
_	O
(	O
"default"	pointer
)	O
:	O
_	O
(	O
"smallest"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
Tag_ARC_ABI_exceptions	int
:	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"  Tag_ARC_ABI_exceptions: %s\n"	pointer
,	O
val	array
?	O
_	O
(	O
"OPTFP"	pointer
)	O
:	O
_	O
(	O
"default"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
Tag_ARC_ABI_double_size	int
:	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"  Tag_ARC_ABI_double_size: %d\n"	pointer
,	O
val	array
)	O
;	O
break	O
;	O
case	O
Tag_ARC_ISA_config	int
:	O
printf	function
(	O
"  Tag_ARC_ISA_config: "	pointer
)	O
;	O
p	pointer
=	O
display_tag_value	function
(	O
-	O
1	int
,	O
p	pointer
,	O
end	pointer
)	O
;	O
break	O
;	O
case	O
Tag_ARC_ISA_apex	int
:	O
printf	function
(	O
"  Tag_ARC_ISA_apex: "	pointer
)	O
;	O
p	pointer
=	O
display_tag_value	function
(	O
-	O
1	int
,	O
p	pointer
,	O
end	pointer
)	O
;	O
break	O
;	O
case	O
Tag_ARC_ISA_mpy_option	int
:	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"  Tag_ARC_ISA_mpy_option: %d\n"	pointer
,	O
val	array
)	O
;	O
break	O
;	O
case	O
Tag_ARC_ATR_version	int
:	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"  Tag_ARC_ATR_version: %d\n"	pointer
,	O
val	array
)	O
;	O
break	O
;	O
default	O
:	O
return	O
display_tag_value	function
(	O
tag	int
&	O
1	int
,	O
p	pointer
,	O
end	pointer
)	O
;	O
}	O
return	O
p	pointer
;	O
}	O
typedef	O
struct	O
{	O
unsigned	O
int	O
tag	int
;	O
const	O
char	O
*	O
name	pointer
;	O
unsigned	O
int	O
type	enum
;	O
const	O
char	O
*	O
*	O
table	pointer
;	O
}	O
arm_attr_public_tag	struct
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_CPU_arch	array
[	O
]	O
=	O
{	O
"Pre-v4"	pointer
,	O
"v4"	pointer
,	O
"v4T"	pointer
,	O
"v5T"	pointer
,	O
"v5TE"	pointer
,	O
"v5TEJ"	pointer
,	O
"v6"	pointer
,	O
"v6KZ"	pointer
,	O
"v6T2"	pointer
,	O
"v6K"	pointer
,	O
"v7"	pointer
,	O
"v6-M"	pointer
,	O
"v6S-M"	pointer
,	O
"v7E-M"	pointer
,	O
"v8"	pointer
,	O
"v8-R"	pointer
,	O
"v8-M.baseline"	pointer
,	O
"v8-M.mainline"	pointer
,	O
""	pointer
,	O
""	pointer
,	O
""	pointer
,	O
"v8.1-M.mainline"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_ARM_ISA_use	array
[	O
]	O
=	O
{	O
"No"	pointer
,	O
"Yes"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_THUMB_ISA_use	array
[	O
]	O
=	O
{	O
"No"	pointer
,	O
"Thumb-1"	pointer
,	O
"Thumb-2"	pointer
,	O
"Yes"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_FP_arch	array
[	O
]	O
=	O
{	O
"No"	pointer
,	O
"VFPv1"	pointer
,	O
"VFPv2"	pointer
,	O
"VFPv3"	pointer
,	O
"VFPv3-D16"	pointer
,	O
"VFPv4"	pointer
,	O
"VFPv4-D16"	pointer
,	O
"FP for ARMv8"	pointer
,	O
"FPv5/FP-D16 for ARMv8"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_WMMX_arch	array
[	O
]	O
=	O
{	O
"No"	pointer
,	O
"WMMXv1"	pointer
,	O
"WMMXv2"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_Advanced_SIMD_arch	array
[	O
]	O
=	O
{	O
"No"	pointer
,	O
"NEONv1"	pointer
,	O
"NEONv1 with Fused-MAC"	pointer
,	O
"NEON for ARMv8"	pointer
,	O
"NEON for ARMv8.1"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_PCS_config	array
[	O
]	O
=	O
{	O
"None"	pointer
,	O
"Bare platform"	pointer
,	O
"Linux application"	pointer
,	O
"Linux DSO"	pointer
,	O
"PalmOS 2004"	pointer
,	O
"PalmOS (reserved)"	pointer
,	O
"SymbianOS 2004"	pointer
,	O
"SymbianOS (reserved)"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_ABI_PCS_R9_use	array
[	O
]	O
=	O
{	O
"V6"	pointer
,	O
"SB"	pointer
,	O
"TLS"	pointer
,	O
"Unused"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_ABI_PCS_RW_data	array
[	O
]	O
=	O
{	O
"Absolute"	pointer
,	O
"PC-relative"	pointer
,	O
"SB-relative"	pointer
,	O
"None"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_ABI_PCS_RO_data	array
[	O
]	O
=	O
{	O
"Absolute"	pointer
,	O
"PC-relative"	pointer
,	O
"None"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_ABI_PCS_GOT_use	array
[	O
]	O
=	O
{	O
"None"	pointer
,	O
"direct"	pointer
,	O
"GOT-indirect"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_ABI_PCS_wchar_t	array
[	O
]	O
=	O
{	O
"None"	pointer
,	O
"??? 1"	pointer
,	O
"2"	pointer
,	O
"??? 3"	pointer
,	O
"4"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_ABI_FP_rounding	array
[	O
]	O
=	O
{	O
"Unused"	pointer
,	O
"Needed"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_ABI_FP_denormal	array
[	O
]	O
=	O
{	O
"Unused"	pointer
,	O
"Needed"	pointer
,	O
"Sign only"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_ABI_FP_exceptions	array
[	O
]	O
=	O
{	O
"Unused"	pointer
,	O
"Needed"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_ABI_FP_user_exceptions	array
[	O
]	O
=	O
{	O
"Unused"	pointer
,	O
"Needed"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_ABI_FP_number_model	array
[	O
]	O
=	O
{	O
"Unused"	pointer
,	O
"Finite"	pointer
,	O
"RTABI"	pointer
,	O
"IEEE 754"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_ABI_enum_size	array
[	O
]	O
=	O
{	O
"Unused"	pointer
,	O
"small"	pointer
,	O
"int"	pointer
,	O
"forced to int"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_ABI_HardFP_use	array
[	O
]	O
=	O
{	O
"As Tag_FP_arch"	pointer
,	O
"SP only"	pointer
,	O
"Reserved"	pointer
,	O
"Deprecated"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_ABI_VFP_args	array
[	O
]	O
=	O
{	O
"AAPCS"	pointer
,	O
"VFP registers"	pointer
,	O
"custom"	pointer
,	O
"compatible"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_ABI_WMMX_args	array
[	O
]	O
=	O
{	O
"AAPCS"	pointer
,	O
"WMMX registers"	pointer
,	O
"custom"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_ABI_optimization_goals	array
[	O
]	O
=	O
{	O
"None"	pointer
,	O
"Prefer Speed"	pointer
,	O
"Aggressive Speed"	pointer
,	O
"Prefer Size"	pointer
,	O
"Aggressive Size"	pointer
,	O
"Prefer Debug"	pointer
,	O
"Aggressive Debug"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_ABI_FP_optimization_goals	array
[	O
]	O
=	O
{	O
"None"	pointer
,	O
"Prefer Speed"	pointer
,	O
"Aggressive Speed"	pointer
,	O
"Prefer Size"	pointer
,	O
"Aggressive Size"	pointer
,	O
"Prefer Accuracy"	pointer
,	O
"Aggressive Accuracy"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_CPU_unaligned_access	array
[	O
]	O
=	O
{	O
"None"	pointer
,	O
"v6"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_FP_HP_extension	array
[	O
]	O
=	O
{	O
"Not Allowed"	pointer
,	O
"Allowed"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_ABI_FP_16bit_format	array
[	O
]	O
=	O
{	O
"None"	pointer
,	O
"IEEE 754"	pointer
,	O
"Alternative Format"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_DSP_extension	array
[	O
]	O
=	O
{	O
"Follow architecture"	pointer
,	O
"Allowed"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_MPextension_use	array
[	O
]	O
=	O
{	O
"Not Allowed"	pointer
,	O
"Allowed"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_DIV_use	array
[	O
]	O
=	O
{	O
"Allowed in Thumb-ISA, v7-R or v7-M"	pointer
,	O
"Not allowed"	pointer
,	O
"Allowed in v7-A with integer division extension"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_T2EE_use	array
[	O
]	O
=	O
{	O
"Not Allowed"	pointer
,	O
"Allowed"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_Virtualization_use	array
[	O
]	O
=	O
{	O
"Not Allowed"	pointer
,	O
"TrustZone"	pointer
,	O
"Virtualization Extensions"	pointer
,	O
"TrustZone and Virtualization Extensions"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_MPextension_use_legacy	array
[	O
]	O
=	O
{	O
"Not Allowed"	pointer
,	O
"Allowed"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_MVE_arch	array
[	O
]	O
=	O
{	O
"No MVE"	pointer
,	O
"MVE Integer only"	pointer
,	O
"MVE Integer and FP"	pointer
}	O
;	O
static	O
arm_attr_public_tag	struct
arm_attr_public_tags	array
[	O
]	O
=	O
{	O
{	O
4	int
,	O
"CPU_raw_name"	pointer
,	O
1	int
,	O
NULL	O
}	O
,	O
{	O
5	int
,	O
"CPU_name"	pointer
,	O
1	int
,	O
NULL	O
}	O
,	O
LOOKUP	O
(	O
6	int
,	O
CPU_arch	O
)	O
,	O
{	O
7	int
,	O
"CPU_arch_profile"	pointer
,	O
0	int
,	O
NULL	O
}	O
,	O
LOOKUP	O
(	O
8	int
,	O
ARM_ISA_use	O
)	O
,	O
LOOKUP	O
(	O
9	int
,	O
THUMB_ISA_use	O
)	O
,	O
LOOKUP	O
(	O
10	int
,	O
FP_arch	O
)	O
,	O
LOOKUP	O
(	O
11	int
,	O
WMMX_arch	O
)	O
,	O
LOOKUP	O
(	O
12	int
,	O
Advanced_SIMD_arch	O
)	O
,	O
LOOKUP	O
(	O
13	int
,	O
PCS_config	O
)	O
,	O
LOOKUP	O
(	O
14	int
,	O
ABI_PCS_R9_use	O
)	O
,	O
LOOKUP	O
(	O
15	int
,	O
ABI_PCS_RW_data	O
)	O
,	O
LOOKUP	O
(	O
16	int
,	O
ABI_PCS_RO_data	O
)	O
,	O
LOOKUP	O
(	O
17	int
,	O
ABI_PCS_GOT_use	O
)	O
,	O
LOOKUP	O
(	O
18	int
,	O
ABI_PCS_wchar_t	O
)	O
,	O
LOOKUP	O
(	O
19	int
,	O
ABI_FP_rounding	O
)	O
,	O
LOOKUP	O
(	O
20	int
,	O
ABI_FP_denormal	O
)	O
,	O
LOOKUP	O
(	O
21	int
,	O
ABI_FP_exceptions	O
)	O
,	O
LOOKUP	O
(	O
22	int
,	O
ABI_FP_user_exceptions	O
)	O
,	O
LOOKUP	O
(	O
23	int
,	O
ABI_FP_number_model	O
)	O
,	O
{	O
24	int
,	O
"ABI_align_needed"	pointer
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
25	int
,	O
"ABI_align_preserved"	pointer
,	O
0	int
,	O
NULL	O
}	O
,	O
LOOKUP	O
(	O
26	int
,	O
ABI_enum_size	O
)	O
,	O
LOOKUP	O
(	O
27	int
,	O
ABI_HardFP_use	O
)	O
,	O
LOOKUP	O
(	O
28	int
,	O
ABI_VFP_args	O
)	O
,	O
LOOKUP	O
(	O
29	int
,	O
ABI_WMMX_args	O
)	O
,	O
LOOKUP	O
(	O
30	int
,	O
ABI_optimization_goals	O
)	O
,	O
LOOKUP	O
(	O
31	int
,	O
ABI_FP_optimization_goals	O
)	O
,	O
{	O
32	int
,	O
"compatibility"	pointer
,	O
0	int
,	O
NULL	O
}	O
,	O
LOOKUP	O
(	O
34	int
,	O
CPU_unaligned_access	O
)	O
,	O
LOOKUP	O
(	O
36	int
,	O
FP_HP_extension	O
)	O
,	O
LOOKUP	O
(	O
38	int
,	O
ABI_FP_16bit_format	O
)	O
,	O
LOOKUP	O
(	O
42	int
,	O
MPextension_use	O
)	O
,	O
LOOKUP	O
(	O
44	int
,	O
DIV_use	O
)	O
,	O
LOOKUP	O
(	O
46	int
,	O
DSP_extension	O
)	O
,	O
LOOKUP	O
(	O
48	int
,	O
MVE_arch	O
)	O
,	O
{	O
64	int
,	O
"nodefaults"	pointer
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
65	int
,	O
"also_compatible_with"	pointer
,	O
0	int
,	O
NULL	O
}	O
,	O
LOOKUP	O
(	O
66	int
,	O
T2EE_use	O
)	O
,	O
{	O
67	int
,	O
"conformance"	pointer
,	O
1	int
,	O
NULL	O
}	O
,	O
LOOKUP	O
(	O
68	int
,	O
Virtualization_use	O
)	O
,	O
LOOKUP	O
(	O
70	int
,	O
MPextension_use_legacy	O
)	O
}	O
;	O
static	O
unsigned	O
char	O
*	O
display_arm_attribute	function
(	O
unsigned	O
char	O
*	O
p	pointer
,	O
const	O
unsigned	O
char	O
*	O
const	O
end	pointer
)	O
{	O
unsigned	O
int	O
tag	int
;	O
unsigned	O
int	O
val	array
;	O
arm_attr_public_tag	struct
*	O
attr	int
;	O
unsigned	O
i	pointer
;	O
unsigned	O
int	O
type	enum
;	O
READ_ULEB	O
(	O
tag	int
,	O
p	pointer
,	O
end	pointer
)	O
;	O
attr	int
=	O
NULL	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
ARRAY_SIZE	O
(	O
arm_attr_public_tags	array
)	O
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
arm_attr_public_tags	array
[	O
i	pointer
]	O
.	O
tag	int
==	O
tag	int
)	O
{	O
attr	int
=	O
&	O
arm_attr_public_tags	array
[	O
i	pointer
]	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
attr	int
)	O
{	O
printf	function
(	O
"  Tag_%s: "	pointer
,	O
attr	int
->	O
name	pointer
)	O
;	O
switch	O
(	O
attr	int
->	O
type	enum
)	O
{	O
case	O
0	int
:	O
switch	O
(	O
tag	int
)	O
{	O
case	O
7	int
:	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
switch	O
(	O
val	array
)	O
{	O
case	O
0	int
:	O
printf	function
(	O
_	O
(	O
"None\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
'A'	O
:	O
printf	function
(	O
_	O
(	O
"Application\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
'R'	O
:	O
printf	function
(	O
_	O
(	O
"Realtime\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
'M'	O
:	O
printf	function
(	O
_	O
(	O
"Microcontroller\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
'S'	O
:	O
printf	function
(	O
_	O
(	O
"Application or Realtime\n"	pointer
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
"??? (%d)\n"	pointer
,	O
val	array
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
24	int
:	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
switch	O
(	O
val	array
)	O
{	O
case	O
0	int
:	O
printf	function
(	O
_	O
(	O
"None\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	function
(	O
_	O
(	O
"8-byte\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
printf	function
(	O
_	O
(	O
"4-byte\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
3	int
:	O
printf	function
(	O
"??? 3\n"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
val	array
<=	O
12	int
)	O
printf	function
(	O
_	O
(	O
"8-byte and up to %d-byte extended\n"	pointer
)	O
,	O
1	int
<<	O
val	array
)	O
;	O
else	O
printf	function
(	O
"??? (%d)\n"	pointer
,	O
val	array
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
25	int
:	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
switch	O
(	O
val	array
)	O
{	O
case	O
0	int
:	O
printf	function
(	O
_	O
(	O
"None\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	function
(	O
_	O
(	O
"8-byte, except leaf SP\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
printf	function
(	O
_	O
(	O
"8-byte\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
3	int
:	O
printf	function
(	O
"??? 3\n"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
val	array
<=	O
12	int
)	O
printf	function
(	O
_	O
(	O
"8-byte and up to %d-byte extended\n"	pointer
)	O
,	O
1	int
<<	O
val	array
)	O
;	O
else	O
printf	function
(	O
"??? (%d)\n"	pointer
,	O
val	array
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
32	int
:	O
{	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"flag = %d, vendor = "	pointer
)	O
,	O
val	array
)	O
;	O
if	O
(	O
p	pointer
<	O
end	pointer
-	O
1	int
)	O
{	O
size_t	long
maxlen	long
=	O
(	O
end	pointer
-	O
p	pointer
)	O
-	O
1	int
;	O
print_symbol	function
(	O
(	O
int	O
)	O
maxlen	long
,	O
(	O
const	O
char	O
*	O
)	O
p	pointer
)	O
;	O
p	pointer
+=	O
strnlen	function
(	O
(	O
char	O
*	O
)	O
p	pointer
,	O
maxlen	long
)	O
+	O
1	int
;	O
}	O
else	O
{	O
printf	function
(	O
_	O
(	O
"<corrupt>"	pointer
)	O
)	O
;	O
p	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
end	pointer
;	O
}	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
break	O
;	O
case	O
64	int
:	O
if	O
(	O
p	pointer
<	O
end	pointer
)	O
p	pointer
++	O
;	O
printf	function
(	O
_	O
(	O
"True\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
65	int
:	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
val	array
==	O
6	int
)	O
{	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
(	O
unsigned	O
int	O
)	O
val	array
>=	O
ARRAY_SIZE	O
(	O
arm_attr_tag_CPU_arch	array
)	O
)	O
printf	function
(	O
"??? (%d)\n"	pointer
,	O
val	array
)	O
;	O
else	O
printf	function
(	O
"%s\n"	pointer
,	O
arm_attr_tag_CPU_arch	array
[	O
val	array
]	O
)	O
;	O
}	O
else	O
printf	function
(	O
"???\n"	pointer
)	O
;	O
while	O
(	O
p	pointer
<	O
end	pointer
&&	O
*	O
(	O
p	pointer
++	O
)	O
!=	O
'\0'	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
_	O
(	O
"<unknown: %d>\n"	pointer
)	O
,	O
tag	int
)	O
;	O
break	O
;	O
}	O
return	O
p	pointer
;	O
case	O
1	int
:	O
return	O
display_tag_value	function
(	O
-	O
1	int
,	O
p	pointer
,	O
end	pointer
)	O
;	O
case	O
2	int
:	O
return	O
display_tag_value	function
(	O
0	int
,	O
p	pointer
,	O
end	pointer
)	O
;	O
default	O
:	O
assert	O
(	O
attr	int
->	O
type	enum
&	O
0x80	int
)	O
;	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
type	enum
=	O
attr	int
->	O
type	enum
&	O
0x7f	int
;	O
if	O
(	O
val	array
>=	O
type	enum
)	O
printf	function
(	O
"??? (%d)\n"	pointer
,	O
val	array
)	O
;	O
else	O
printf	function
(	O
"%s\n"	pointer
,	O
attr	int
->	O
table	pointer
[	O
val	array
]	O
)	O
;	O
return	O
p	pointer
;	O
}	O
}	O
return	O
display_tag_value	function
(	O
tag	int
,	O
p	pointer
,	O
end	pointer
)	O
;	O
}	O
static	O
unsigned	O
char	O
*	O
display_gnu_attribute	function
(	O
unsigned	O
char	O
*	O
p	pointer
,	O
unsigned	O
char	O
*	O
(	O
*	O
display_proc_gnu_attribute	pointer
)	O
(	O
unsigned	O
char	O
*	O
,	O
unsigned	O
int	O
,	O
const	O
unsigned	O
char	O
*	O
const	O
)	O
,	O
const	O
unsigned	O
char	O
*	O
const	O
end	pointer
)	O
{	O
unsigned	O
int	O
tag	int
;	O
unsigned	O
int	O
val	array
;	O
READ_ULEB	O
(	O
tag	int
,	O
p	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
tag	int
==	O
32	int
)	O
{	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"flag = %d, vendor = "	pointer
)	O
,	O
val	array
)	O
;	O
if	O
(	O
p	pointer
==	O
end	pointer
)	O
{	O
printf	function
(	O
_	O
(	O
"<corrupt>\n"	pointer
)	O
)	O
;	O
warn	function
(	O
_	O
(	O
"corrupt vendor attribute\n"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
p	pointer
<	O
end	pointer
-	O
1	int
)	O
{	O
size_t	long
maxlen	long
=	O
(	O
end	pointer
-	O
p	pointer
)	O
-	O
1	int
;	O
print_symbol	function
(	O
(	O
int	O
)	O
maxlen	long
,	O
(	O
const	O
char	O
*	O
)	O
p	pointer
)	O
;	O
p	pointer
+=	O
strnlen	function
(	O
(	O
char	O
*	O
)	O
p	pointer
,	O
maxlen	long
)	O
+	O
1	int
;	O
}	O
else	O
{	O
printf	function
(	O
_	O
(	O
"<corrupt>"	pointer
)	O
)	O
;	O
p	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
end	pointer
;	O
}	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
return	O
p	pointer
;	O
}	O
if	O
(	O
(	O
tag	int
&	O
2	int
)	O
==	O
0	int
&&	O
display_proc_gnu_attribute	pointer
)	O
return	O
display_proc_gnu_attribute	pointer
(	O
p	pointer
,	O
tag	int
,	O
end	pointer
)	O
;	O
return	O
display_tag_value	function
(	O
tag	int
,	O
p	pointer
,	O
end	pointer
)	O
;	O
}	O
static	O
unsigned	O
char	O
*	O
display_power_gnu_attribute	function
(	O
unsigned	O
char	O
*	O
p	pointer
,	O
unsigned	O
int	O
tag	int
,	O
const	O
unsigned	O
char	O
*	O
const	O
end	pointer
)	O
{	O
unsigned	O
int	O
val	array
;	O
if	O
(	O
tag	int
==	O
Tag_GNU_Power_ABI_FP	int
)	O
{	O
printf	function
(	O
"  Tag_GNU_Power_ABI_FP: "	pointer
)	O
;	O
if	O
(	O
p	pointer
==	O
end	pointer
)	O
{	O
printf	function
(	O
_	O
(	O
"<corrupt>\n"	pointer
)	O
)	O
;	O
return	O
p	pointer
;	O
}	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
val	array
>	O
15	int
)	O
printf	function
(	O
"(%#x), "	pointer
,	O
val	array
)	O
;	O
switch	O
(	O
val	array
&	O
3	int
)	O
{	O
case	O
0	int
:	O
printf	function
(	O
_	O
(	O
"unspecified hard/soft float, "	pointer
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	function
(	O
_	O
(	O
"hard float, "	pointer
)	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
printf	function
(	O
_	O
(	O
"soft float, "	pointer
)	O
)	O
;	O
break	O
;	O
case	O
3	int
:	O
printf	function
(	O
_	O
(	O
"single-precision hard float, "	pointer
)	O
)	O
;	O
break	O
;	O
}	O
switch	O
(	O
val	array
&	O
0xC	int
)	O
{	O
case	O
0	int
:	O
printf	function
(	O
_	O
(	O
"unspecified long double\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
4	int
:	O
printf	function
(	O
_	O
(	O
"128-bit IBM long double\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
8	int
:	O
printf	function
(	O
_	O
(	O
"64-bit long double\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
12	int
:	O
printf	function
(	O
_	O
(	O
"128-bit IEEE long double\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
return	O
p	pointer
;	O
}	O
if	O
(	O
tag	int
==	O
Tag_GNU_Power_ABI_Vector	int
)	O
{	O
printf	function
(	O
"  Tag_GNU_Power_ABI_Vector: "	pointer
)	O
;	O
if	O
(	O
p	pointer
==	O
end	pointer
)	O
{	O
printf	function
(	O
_	O
(	O
"<corrupt>\n"	pointer
)	O
)	O
;	O
return	O
p	pointer
;	O
}	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
val	array
>	O
3	int
)	O
printf	function
(	O
"(%#x), "	pointer
,	O
val	array
)	O
;	O
switch	O
(	O
val	array
&	O
3	int
)	O
{	O
case	O
0	int
:	O
printf	function
(	O
_	O
(	O
"unspecified\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	function
(	O
_	O
(	O
"generic\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
printf	function
(	O
"AltiVec\n"	pointer
)	O
;	O
break	O
;	O
case	O
3	int
:	O
printf	function
(	O
"SPE\n"	pointer
)	O
;	O
break	O
;	O
}	O
return	O
p	pointer
;	O
}	O
if	O
(	O
tag	int
==	O
Tag_GNU_Power_ABI_Struct_Return	int
)	O
{	O
printf	function
(	O
"  Tag_GNU_Power_ABI_Struct_Return: "	pointer
)	O
;	O
if	O
(	O
p	pointer
==	O
end	pointer
)	O
{	O
printf	function
(	O
_	O
(	O
"<corrupt>\n"	pointer
)	O
)	O
;	O
return	O
p	pointer
;	O
}	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
val	array
>	O
2	int
)	O
printf	function
(	O
"(%#x), "	pointer
,	O
val	array
)	O
;	O
switch	O
(	O
val	array
&	O
3	int
)	O
{	O
case	O
0	int
:	O
printf	function
(	O
_	O
(	O
"unspecified\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	function
(	O
"r3/r4\n"	pointer
)	O
;	O
break	O
;	O
case	O
2	int
:	O
printf	function
(	O
_	O
(	O
"memory\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
3	int
:	O
printf	function
(	O
"???\n"	pointer
)	O
;	O
break	O
;	O
}	O
return	O
p	pointer
;	O
}	O
return	O
display_tag_value	function
(	O
tag	int
&	O
1	int
,	O
p	pointer
,	O
end	pointer
)	O
;	O
}	O
static	O
unsigned	O
char	O
*	O
display_s390_gnu_attribute	function
(	O
unsigned	O
char	O
*	O
p	pointer
,	O
unsigned	O
int	O
tag	int
,	O
const	O
unsigned	O
char	O
*	O
const	O
end	pointer
)	O
{	O
unsigned	O
int	O
val	array
;	O
if	O
(	O
tag	int
==	O
Tag_GNU_S390_ABI_Vector	int
)	O
{	O
printf	function
(	O
"  Tag_GNU_S390_ABI_Vector: "	pointer
)	O
;	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
switch	O
(	O
val	array
)	O
{	O
case	O
0	int
:	O
printf	function
(	O
_	O
(	O
"any\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	function
(	O
_	O
(	O
"software\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
printf	function
(	O
_	O
(	O
"hardware\n"	pointer
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
"??? (%d)\n"	pointer
,	O
val	array
)	O
;	O
break	O
;	O
}	O
return	O
p	pointer
;	O
}	O
return	O
display_tag_value	function
(	O
tag	int
&	O
1	int
,	O
p	pointer
,	O
end	pointer
)	O
;	O
}	O
static	O
void	O
display_sparc_hwcaps	function
(	O
unsigned	O
int	O
mask	int
)	O
{	O
if	O
(	O
mask	int
)	O
{	O
bfd_boolean	int
first	int
=	O
TRUE	int
;	O
if	O
(	O
mask	int
&	O
ELF_SPARC_HWCAP_MUL32	int
)	O
fputs	function
(	O
"mul32"	pointer
,	O
stdout	pointer
)	O
,	O
first	int
=	O
FALSE	int
;	O
if	O
(	O
mask	int
&	O
ELF_SPARC_HWCAP_DIV32	int
)	O
printf	function
(	O
"%sdiv32"	pointer
,	O
first	int
?	O
""	pointer
:	O
"|"	pointer
)	O
,	O
first	int
=	O
FALSE	int
;	O
if	O
(	O
mask	int
&	O
ELF_SPARC_HWCAP_FSMULD	int
)	O
printf	function
(	O
"%sfsmuld"	pointer
,	O
first	int
?	O
""	pointer
:	O
"|"	pointer
)	O
,	O
first	int
=	O
FALSE	int
;	O
if	O
(	O
mask	int
&	O
ELF_SPARC_HWCAP_V8PLUS	int
)	O
printf	function
(	O
"%sv8plus"	pointer
,	O
first	int
?	O
""	pointer
:	O
"|"	pointer
)	O
,	O
first	int
=	O
FALSE	int
;	O
if	O
(	O
mask	int
&	O
ELF_SPARC_HWCAP_POPC	int
)	O
printf	function
(	O
"%spopc"	pointer
,	O
first	int
?	O
""	pointer
:	O
"|"	pointer
)	O
,	O
first	int
=	O
FALSE	int
;	O
if	O
(	O
mask	int
&	O
ELF_SPARC_HWCAP_VIS	int
)	O
printf	function
(	O
"%svis"	pointer
,	O
first	int
?	O
""	pointer
:	O
"|"	pointer
)	O
,	O
first	int
=	O
FALSE	int
;	O
if	O
(	O
mask	int
&	O
ELF_SPARC_HWCAP_VIS2	int
)	O
printf	function
(	O
"%svis2"	pointer
,	O
first	int
?	O
""	pointer
:	O
"|"	pointer
)	O
,	O
first	int
=	O
FALSE	int
;	O
if	O
(	O
mask	int
&	O
ELF_SPARC_HWCAP_ASI_BLK_INIT	int
)	O
printf	function
(	O
"%sASIBlkInit"	pointer
,	O
first	int
?	O
""	pointer
:	O
"|"	pointer
)	O
,	O
first	int
=	O
FALSE	int
;	O
if	O
(	O
mask	int
&	O
ELF_SPARC_HWCAP_FMAF	int
)	O
printf	function
(	O
"%sfmaf"	pointer
,	O
first	int
?	O
""	pointer
:	O
"|"	pointer
)	O
,	O
first	int
=	O
FALSE	int
;	O
if	O
(	O
mask	int
&	O
ELF_SPARC_HWCAP_VIS3	int
)	O
printf	function
(	O
"%svis3"	pointer
,	O
first	int
?	O
""	pointer
:	O
"|"	pointer
)	O
,	O
first	int
=	O
FALSE	int
;	O
if	O
(	O
mask	int
&	O
ELF_SPARC_HWCAP_HPC	int
)	O
printf	function
(	O
"%shpc"	pointer
,	O
first	int
?	O
""	pointer
:	O
"|"	pointer
)	O
,	O
first	int
=	O
FALSE	int
;	O
if	O
(	O
mask	int
&	O
ELF_SPARC_HWCAP_RANDOM	int
)	O
printf	function
(	O
"%srandom"	pointer
,	O
first	int
?	O
""	pointer
:	O
"|"	pointer
)	O
,	O
first	int
=	O
FALSE	int
;	O
if	O
(	O
mask	int
&	O
ELF_SPARC_HWCAP_TRANS	int
)	O
printf	function
(	O
"%strans"	pointer
,	O
first	int
?	O
""	pointer
:	O
"|"	pointer
)	O
,	O
first	int
=	O
FALSE	int
;	O
if	O
(	O
mask	int
&	O
ELF_SPARC_HWCAP_FJFMAU	int
)	O
printf	function
(	O
"%sfjfmau"	pointer
,	O
first	int
?	O
""	pointer
:	O
"|"	pointer
)	O
,	O
first	int
=	O
FALSE	int
;	O
if	O
(	O
mask	int
&	O
ELF_SPARC_HWCAP_IMA	int
)	O
printf	function
(	O
"%sima"	pointer
,	O
first	int
?	O
""	pointer
:	O
"|"	pointer
)	O
,	O
first	int
=	O
FALSE	int
;	O
if	O
(	O
mask	int
&	O
ELF_SPARC_HWCAP_ASI_CACHE_SPARING	int
)	O
printf	function
(	O
"%scspare"	pointer
,	O
first	int
?	O
""	pointer
:	O
"|"	pointer
)	O
,	O
first	int
=	O
FALSE	int
;	O
}	O
else	O
fputc	function
(	O
'0'	O
,	O
stdout	pointer
)	O
;	O
fputc	function
(	O
'\n'	O
,	O
stdout	pointer
)	O
;	O
}	O
static	O
void	O
display_sparc_hwcaps2	function
(	O
unsigned	O
int	O
mask	int
)	O
{	O
if	O
(	O
mask	int
)	O
{	O
bfd_boolean	int
first	int
=	O
TRUE	int
;	O
if	O
(	O
mask	int
&	O
ELF_SPARC_HWCAP2_FJATHPLUS	int
)	O
fputs	function
(	O
"fjathplus"	pointer
,	O
stdout	pointer
)	O
,	O
first	int
=	O
FALSE	int
;	O
if	O
(	O
mask	int
&	O
ELF_SPARC_HWCAP2_VIS3B	int
)	O
printf	function
(	O
"%svis3b"	pointer
,	O
first	int
?	O
""	pointer
:	O
"|"	pointer
)	O
,	O
first	int
=	O
FALSE	int
;	O
if	O
(	O
mask	int
&	O
ELF_SPARC_HWCAP2_ADP	int
)	O
printf	function
(	O
"%sadp"	pointer
,	O
first	int
?	O
""	pointer
:	O
"|"	pointer
)	O
,	O
first	int
=	O
FALSE	int
;	O
if	O
(	O
mask	int
&	O
ELF_SPARC_HWCAP2_SPARC5	int
)	O
printf	function
(	O
"%ssparc5"	pointer
,	O
first	int
?	O
""	pointer
:	O
"|"	pointer
)	O
,	O
first	int
=	O
FALSE	int
;	O
if	O
(	O
mask	int
&	O
ELF_SPARC_HWCAP2_MWAIT	int
)	O
printf	function
(	O
"%smwait"	pointer
,	O
first	int
?	O
""	pointer
:	O
"|"	pointer
)	O
,	O
first	int
=	O
FALSE	int
;	O
if	O
(	O
mask	int
&	O
ELF_SPARC_HWCAP2_XMPMUL	int
)	O
printf	function
(	O
"%sxmpmul"	pointer
,	O
first	int
?	O
""	pointer
:	O
"|"	pointer
)	O
,	O
first	int
=	O
FALSE	int
;	O
if	O
(	O
mask	int
&	O
ELF_SPARC_HWCAP2_XMONT	int
)	O
printf	function
(	O
"%sxmont2"	pointer
,	O
first	int
?	O
""	pointer
:	O
"|"	pointer
)	O
,	O
first	int
=	O
FALSE	int
;	O
if	O
(	O
mask	int
&	O
ELF_SPARC_HWCAP2_NSEC	int
)	O
printf	function
(	O
"%snsec"	pointer
,	O
first	int
?	O
""	pointer
:	O
"|"	pointer
)	O
,	O
first	int
=	O
FALSE	int
;	O
if	O
(	O
mask	int
&	O
ELF_SPARC_HWCAP2_FJATHHPC	int
)	O
printf	function
(	O
"%sfjathhpc"	pointer
,	O
first	int
?	O
""	pointer
:	O
"|"	pointer
)	O
,	O
first	int
=	O
FALSE	int
;	O
if	O
(	O
mask	int
&	O
ELF_SPARC_HWCAP2_FJDES	int
)	O
printf	function
(	O
"%sfjdes"	pointer
,	O
first	int
?	O
""	pointer
:	O
"|"	pointer
)	O
,	O
first	int
=	O
FALSE	int
;	O
if	O
(	O
mask	int
&	O
ELF_SPARC_HWCAP2_FJAES	int
)	O
printf	function
(	O
"%sfjaes"	pointer
,	O
first	int
?	O
""	pointer
:	O
"|"	pointer
)	O
,	O
first	int
=	O
FALSE	int
;	O
}	O
else	O
fputc	function
(	O
'0'	O
,	O
stdout	pointer
)	O
;	O
fputc	function
(	O
'\n'	O
,	O
stdout	pointer
)	O
;	O
}	O
static	O
unsigned	O
char	O
*	O
display_sparc_gnu_attribute	function
(	O
unsigned	O
char	O
*	O
p	pointer
,	O
unsigned	O
int	O
tag	int
,	O
const	O
unsigned	O
char	O
*	O
const	O
end	pointer
)	O
{	O
unsigned	O
int	O
val	array
;	O
if	O
(	O
tag	int
==	O
Tag_GNU_Sparc_HWCAPS	int
)	O
{	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"  Tag_GNU_Sparc_HWCAPS: "	pointer
)	O
;	O
display_sparc_hwcaps	function
(	O
val	array
)	O
;	O
return	O
p	pointer
;	O
}	O
if	O
(	O
tag	int
==	O
Tag_GNU_Sparc_HWCAPS2	int
)	O
{	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"  Tag_GNU_Sparc_HWCAPS2: "	pointer
)	O
;	O
display_sparc_hwcaps2	function
(	O
val	array
)	O
;	O
return	O
p	pointer
;	O
}	O
return	O
display_tag_value	function
(	O
tag	int
,	O
p	pointer
,	O
end	pointer
)	O
;	O
}	O
static	O
void	O
print_mips_fp_abi_value	function
(	O
unsigned	O
int	O
val	array
)	O
{	O
switch	O
(	O
val	array
)	O
{	O
case	O
Val_GNU_MIPS_ABI_FP_ANY	int
:	O
printf	function
(	O
_	O
(	O
"Hard or soft float\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
Val_GNU_MIPS_ABI_FP_DOUBLE	int
:	O
printf	function
(	O
_	O
(	O
"Hard float (double precision)\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
Val_GNU_MIPS_ABI_FP_SINGLE	int
:	O
printf	function
(	O
_	O
(	O
"Hard float (single precision)\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
Val_GNU_MIPS_ABI_FP_SOFT	int
:	O
printf	function
(	O
_	O
(	O
"Soft float\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
Val_GNU_MIPS_ABI_FP_OLD_64	int
:	O
printf	function
(	O
_	O
(	O
"Hard float (MIPS32r2 64-bit FPU 12 callee-saved)\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
Val_GNU_MIPS_ABI_FP_XX	int
:	O
printf	function
(	O
_	O
(	O
"Hard float (32-bit CPU, Any FPU)\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
Val_GNU_MIPS_ABI_FP_64	int
:	O
printf	function
(	O
_	O
(	O
"Hard float (32-bit CPU, 64-bit FPU)\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
Val_GNU_MIPS_ABI_FP_64A	int
:	O
printf	function
(	O
_	O
(	O
"Hard float compat (32-bit CPU, 64-bit FPU)\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
Val_GNU_MIPS_ABI_FP_NAN2008	int
:	O
printf	function
(	O
_	O
(	O
"NaN 2008 compatibility\n"	pointer
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
"??? (%d)\n"	pointer
,	O
val	array
)	O
;	O
break	O
;	O
}	O
}	O
static	O
unsigned	O
char	O
*	O
display_mips_gnu_attribute	function
(	O
unsigned	O
char	O
*	O
p	pointer
,	O
unsigned	O
int	O
tag	int
,	O
const	O
unsigned	O
char	O
*	O
const	O
end	pointer
)	O
{	O
if	O
(	O
tag	int
==	O
Tag_GNU_MIPS_ABI_FP	int
)	O
{	O
unsigned	O
int	O
val	array
;	O
printf	function
(	O
"  Tag_GNU_MIPS_ABI_FP: "	pointer
)	O
;	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
print_mips_fp_abi_value	function
(	O
val	array
)	O
;	O
return	O
p	pointer
;	O
}	O
if	O
(	O
tag	int
==	O
Tag_GNU_MIPS_ABI_MSA	int
)	O
{	O
unsigned	O
int	O
val	array
;	O
printf	function
(	O
"  Tag_GNU_MIPS_ABI_MSA: "	pointer
)	O
;	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
switch	O
(	O
val	array
)	O
{	O
case	O
Val_GNU_MIPS_ABI_MSA_ANY	int
:	O
printf	function
(	O
_	O
(	O
"Any MSA or not\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
Val_GNU_MIPS_ABI_MSA_128	int
:	O
printf	function
(	O
_	O
(	O
"128-bit MSA\n"	pointer
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
"??? (%d)\n"	pointer
,	O
val	array
)	O
;	O
break	O
;	O
}	O
return	O
p	pointer
;	O
}	O
return	O
display_tag_value	function
(	O
tag	int
&	O
1	int
,	O
p	pointer
,	O
end	pointer
)	O
;	O
}	O
static	O
unsigned	O
char	O
*	O
display_tic6x_attribute	function
(	O
unsigned	O
char	O
*	O
p	pointer
,	O
const	O
unsigned	O
char	O
*	O
const	O
end	pointer
)	O
{	O
unsigned	O
int	O
tag	int
;	O
unsigned	O
int	O
val	array
;	O
READ_ULEB	O
(	O
tag	int
,	O
p	pointer
,	O
end	pointer
)	O
;	O
switch	O
(	O
tag	int
)	O
{	O
case	O
Tag_ISA	int
:	O
printf	function
(	O
"  Tag_ISA: "	pointer
)	O
;	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
switch	O
(	O
val	array
)	O
{	O
case	O
C6XABI_Tag_ISA_none	int
:	O
printf	function
(	O
_	O
(	O
"None\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
C6XABI_Tag_ISA_C62X	int
:	O
printf	function
(	O
"C62x\n"	pointer
)	O
;	O
break	O
;	O
case	O
C6XABI_Tag_ISA_C67X	int
:	O
printf	function
(	O
"C67x\n"	pointer
)	O
;	O
break	O
;	O
case	O
C6XABI_Tag_ISA_C67XP	int
:	O
printf	function
(	O
"C67x+\n"	pointer
)	O
;	O
break	O
;	O
case	O
C6XABI_Tag_ISA_C64X	int
:	O
printf	function
(	O
"C64x\n"	pointer
)	O
;	O
break	O
;	O
case	O
C6XABI_Tag_ISA_C64XP	int
:	O
printf	function
(	O
"C64x+\n"	pointer
)	O
;	O
break	O
;	O
case	O
C6XABI_Tag_ISA_C674X	int
:	O
printf	function
(	O
"C674x\n"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
"??? (%d)\n"	pointer
,	O
val	array
)	O
;	O
break	O
;	O
}	O
return	O
p	pointer
;	O
case	O
Tag_ABI_wchar_t	int
:	O
printf	function
(	O
"  Tag_ABI_wchar_t: "	pointer
)	O
;	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
switch	O
(	O
val	array
)	O
{	O
case	O
0	int
:	O
printf	function
(	O
_	O
(	O
"Not used\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	function
(	O
_	O
(	O
"2 bytes\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
printf	function
(	O
_	O
(	O
"4 bytes\n"	pointer
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
"??? (%d)\n"	pointer
,	O
val	array
)	O
;	O
break	O
;	O
}	O
return	O
p	pointer
;	O
case	O
Tag_ABI_stack_align_needed	int
:	O
printf	function
(	O
"  Tag_ABI_stack_align_needed: "	pointer
)	O
;	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
switch	O
(	O
val	array
)	O
{	O
case	O
0	int
:	O
printf	function
(	O
_	O
(	O
"8-byte\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	function
(	O
_	O
(	O
"16-byte\n"	pointer
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
"??? (%d)\n"	pointer
,	O
val	array
)	O
;	O
break	O
;	O
}	O
return	O
p	pointer
;	O
case	O
Tag_ABI_stack_align_preserved	int
:	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"  Tag_ABI_stack_align_preserved: "	pointer
)	O
;	O
switch	O
(	O
val	array
)	O
{	O
case	O
0	int
:	O
printf	function
(	O
_	O
(	O
"8-byte\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	function
(	O
_	O
(	O
"16-byte\n"	pointer
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
"??? (%d)\n"	pointer
,	O
val	array
)	O
;	O
break	O
;	O
}	O
return	O
p	pointer
;	O
case	O
Tag_ABI_DSBT	int
:	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"  Tag_ABI_DSBT: "	pointer
)	O
;	O
switch	O
(	O
val	array
)	O
{	O
case	O
0	int
:	O
printf	function
(	O
_	O
(	O
"DSBT addressing not used\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	function
(	O
_	O
(	O
"DSBT addressing used\n"	pointer
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
"??? (%d)\n"	pointer
,	O
val	array
)	O
;	O
break	O
;	O
}	O
return	O
p	pointer
;	O
case	O
Tag_ABI_PID	int
:	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"  Tag_ABI_PID: "	pointer
)	O
;	O
switch	O
(	O
val	array
)	O
{	O
case	O
0	int
:	O
printf	function
(	O
_	O
(	O
"Data addressing position-dependent\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	function
(	O
_	O
(	O
"Data addressing position-independent, GOT near DP\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
printf	function
(	O
_	O
(	O
"Data addressing position-independent, GOT far from DP\n"	pointer
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
"??? (%d)\n"	pointer
,	O
val	array
)	O
;	O
break	O
;	O
}	O
return	O
p	pointer
;	O
case	O
Tag_ABI_PIC	int
:	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"  Tag_ABI_PIC: "	pointer
)	O
;	O
switch	O
(	O
val	array
)	O
{	O
case	O
0	int
:	O
printf	function
(	O
_	O
(	O
"Code addressing position-dependent\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	function
(	O
_	O
(	O
"Code addressing position-independent\n"	pointer
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
"??? (%d)\n"	pointer
,	O
val	array
)	O
;	O
break	O
;	O
}	O
return	O
p	pointer
;	O
case	O
Tag_ABI_array_object_alignment	int
:	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"  Tag_ABI_array_object_alignment: "	pointer
)	O
;	O
switch	O
(	O
val	array
)	O
{	O
case	O
0	int
:	O
printf	function
(	O
_	O
(	O
"8-byte\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	function
(	O
_	O
(	O
"4-byte\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
printf	function
(	O
_	O
(	O
"16-byte\n"	pointer
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
"??? (%d)\n"	pointer
,	O
val	array
)	O
;	O
break	O
;	O
}	O
return	O
p	pointer
;	O
case	O
Tag_ABI_array_object_align_expected	int
:	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"  Tag_ABI_array_object_align_expected: "	pointer
)	O
;	O
switch	O
(	O
val	array
)	O
{	O
case	O
0	int
:	O
printf	function
(	O
_	O
(	O
"8-byte\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	function
(	O
_	O
(	O
"4-byte\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
printf	function
(	O
_	O
(	O
"16-byte\n"	pointer
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
"??? (%d)\n"	pointer
,	O
val	array
)	O
;	O
break	O
;	O
}	O
return	O
p	pointer
;	O
case	O
Tag_ABI_compatibility	int
:	O
{	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"  Tag_ABI_compatibility: "	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"flag = %d, vendor = "	pointer
)	O
,	O
val	array
)	O
;	O
if	O
(	O
p	pointer
<	O
end	pointer
-	O
1	int
)	O
{	O
size_t	long
maxlen	long
=	O
(	O
end	pointer
-	O
p	pointer
)	O
-	O
1	int
;	O
print_symbol	function
(	O
(	O
int	O
)	O
maxlen	long
,	O
(	O
const	O
char	O
*	O
)	O
p	pointer
)	O
;	O
p	pointer
+=	O
strnlen	function
(	O
(	O
char	O
*	O
)	O
p	pointer
,	O
maxlen	long
)	O
+	O
1	int
;	O
}	O
else	O
{	O
printf	function
(	O
_	O
(	O
"<corrupt>"	pointer
)	O
)	O
;	O
p	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
end	pointer
;	O
}	O
putchar	function
(	O
'\n'	O
)	O
;	O
return	O
p	pointer
;	O
}	O
case	O
Tag_ABI_conformance	int
:	O
{	O
printf	function
(	O
"  Tag_ABI_conformance: \""	pointer
)	O
;	O
if	O
(	O
p	pointer
<	O
end	pointer
-	O
1	int
)	O
{	O
size_t	long
maxlen	long
=	O
(	O
end	pointer
-	O
p	pointer
)	O
-	O
1	int
;	O
print_symbol	function
(	O
(	O
int	O
)	O
maxlen	long
,	O
(	O
const	O
char	O
*	O
)	O
p	pointer
)	O
;	O
p	pointer
+=	O
strnlen	function
(	O
(	O
char	O
*	O
)	O
p	pointer
,	O
maxlen	long
)	O
+	O
1	int
;	O
}	O
else	O
{	O
printf	function
(	O
_	O
(	O
"<corrupt>"	pointer
)	O
)	O
;	O
p	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
end	pointer
;	O
}	O
printf	function
(	O
"\"\n"	pointer
)	O
;	O
return	O
p	pointer
;	O
}	O
}	O
return	O
display_tag_value	function
(	O
tag	int
,	O
p	pointer
,	O
end	pointer
)	O
;	O
}	O
static	O
void	O
display_raw_attribute	function
(	O
unsigned	O
char	O
*	O
p	pointer
,	O
unsigned	O
char	O
const	O
*	O
const	O
end	pointer
)	O
{	O
unsigned	O
long	O
addr	pointer
=	O
0	int
;	O
size_t	long
bytes	long
=	O
end	pointer
-	O
p	pointer
;	O
assert	O
(	O
end	pointer
>=	O
p	pointer
)	O
;	O
while	O
(	O
bytes	long
)	O
{	O
int	O
j	int
;	O
int	O
k	int
;	O
int	O
lbytes	int
=	O
(	O
bytes	long
>	O
16	int
?	O
16	int
:	O
bytes	long
)	O
;	O
printf	function
(	O
"  0x%8.8lx "	pointer
,	O
addr	pointer
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
16	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
j	int
<	O
lbytes	int
)	O
printf	function
(	O
"%2.2x"	pointer
,	O
p	pointer
[	O
j	int
]	O
)	O
;	O
else	O
printf	function
(	O
"  "	pointer
)	O
;	O
if	O
(	O
(	O
j	int
&	O
3	int
)	O
==	O
3	int
)	O
printf	function
(	O
" "	pointer
)	O
;	O
}	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
lbytes	int
;	O
j	int
++	O
)	O
{	O
k	int
=	O
p	pointer
[	O
j	int
]	O
;	O
if	O
(	O
k	int
>=	O
' '	O
&&	O
k	int
<	O
0x7f	int
)	O
printf	function
(	O
"%c"	pointer
,	O
k	int
)	O
;	O
else	O
printf	function
(	O
"."	pointer
)	O
;	O
}	O
putchar	function
(	O
'\n'	O
)	O
;	O
p	pointer
+=	O
lbytes	int
;	O
bytes	long
-=	O
lbytes	int
;	O
addr	pointer
+=	O
lbytes	int
;	O
}	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
static	O
unsigned	O
char	O
*	O
display_msp430x_attribute	function
(	O
unsigned	O
char	O
*	O
p	pointer
,	O
const	O
unsigned	O
char	O
*	O
const	O
end	pointer
)	O
{	O
unsigned	O
int	O
val	array
;	O
unsigned	O
int	O
tag	int
;	O
READ_ULEB	O
(	O
tag	int
,	O
p	pointer
,	O
end	pointer
)	O
;	O
switch	O
(	O
tag	int
)	O
{	O
case	O
OFBA_MSPABI_Tag_ISA	int
:	O
printf	function
(	O
"  Tag_ISA: "	pointer
)	O
;	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
switch	O
(	O
val	array
)	O
{	O
case	O
0	int
:	O
printf	function
(	O
_	O
(	O
"None\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	function
(	O
_	O
(	O
"MSP430\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
printf	function
(	O
_	O
(	O
"MSP430X\n"	pointer
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
"??? (%d)\n"	pointer
,	O
val	array
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
OFBA_MSPABI_Tag_Code_Model	int
:	O
printf	function
(	O
"  Tag_Code_Model: "	pointer
)	O
;	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
switch	O
(	O
val	array
)	O
{	O
case	O
0	int
:	O
printf	function
(	O
_	O
(	O
"None\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	function
(	O
_	O
(	O
"Small\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
printf	function
(	O
_	O
(	O
"Large\n"	pointer
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
"??? (%d)\n"	pointer
,	O
val	array
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
OFBA_MSPABI_Tag_Data_Model	int
:	O
printf	function
(	O
"  Tag_Data_Model: "	pointer
)	O
;	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
switch	O
(	O
val	array
)	O
{	O
case	O
0	int
:	O
printf	function
(	O
_	O
(	O
"None\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	function
(	O
_	O
(	O
"Small\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
printf	function
(	O
_	O
(	O
"Large\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
3	int
:	O
printf	function
(	O
_	O
(	O
"Restricted Large\n"	pointer
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
"??? (%d)\n"	pointer
,	O
val	array
)	O
;	O
break	O
;	O
}	O
break	O
;	O
default	O
:	O
printf	function
(	O
_	O
(	O
"  <unknown tag %d>: "	pointer
)	O
,	O
tag	int
)	O
;	O
if	O
(	O
tag	int
&	O
1	int
)	O
{	O
putchar	function
(	O
'"'	O
)	O
;	O
if	O
(	O
p	pointer
<	O
end	pointer
-	O
1	int
)	O
{	O
size_t	long
maxlen	long
=	O
(	O
end	pointer
-	O
p	pointer
)	O
-	O
1	int
;	O
print_symbol	function
(	O
(	O
int	O
)	O
maxlen	long
,	O
(	O
const	O
char	O
*	O
)	O
p	pointer
)	O
;	O
p	pointer
+=	O
strnlen	function
(	O
(	O
char	O
*	O
)	O
p	pointer
,	O
maxlen	long
)	O
+	O
1	int
;	O
}	O
else	O
{	O
printf	function
(	O
_	O
(	O
"<corrupt>"	pointer
)	O
)	O
;	O
p	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
end	pointer
;	O
}	O
printf	function
(	O
"\"\n"	pointer
)	O
;	O
}	O
else	O
{	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"%d (0x%x)\n"	pointer
,	O
val	array
,	O
val	array
)	O
;	O
}	O
break	O
;	O
}	O
assert	O
(	O
p	pointer
<=	O
end	pointer
)	O
;	O
return	O
p	pointer
;	O
}	O
static	O
unsigned	O
char	O
*	O
display_msp430_gnu_attribute	function
(	O
unsigned	O
char	O
*	O
p	pointer
,	O
unsigned	O
int	O
tag	int
,	O
const	O
unsigned	O
char	O
*	O
const	O
end	pointer
)	O
{	O
if	O
(	O
tag	int
==	O
Tag_GNU_MSP430_Data_Region	int
)	O
{	O
unsigned	O
int	O
val	array
;	O
printf	function
(	O
"  Tag_GNU_MSP430_Data_Region: "	pointer
)	O
;	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
switch	O
(	O
val	array
)	O
{	O
case	O
Val_GNU_MSP430_Data_Region_Any	int
:	O
printf	function
(	O
_	O
(	O
"Any Region\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
Val_GNU_MSP430_Data_Region_Lower	int
:	O
printf	function
(	O
_	O
(	O
"Lower Region Only\n"	pointer
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
"??? (%u)\n"	pointer
,	O
val	array
)	O
;	O
}	O
return	O
p	pointer
;	O
}	O
return	O
display_tag_value	function
(	O
tag	int
&	O
1	int
,	O
p	pointer
,	O
end	pointer
)	O
;	O
}	O
struct	O
riscv_attr_tag_t	struct
{	O
const	O
char	O
*	O
name	pointer
;	O
unsigned	O
int	O
tag	int
;	O
}	O
;	O
static	O
struct	O
riscv_attr_tag_t	struct
riscv_attr_tag	array
[	O
]	O
=	O
{	O
T	O
(	O
arch	enum
)	O
,	O
T	O
(	O
priv_spec	O
)	O
,	O
T	O
(	O
priv_spec_minor	O
)	O
,	O
T	O
(	O
priv_spec_revision	O
)	O
,	O
T	O
(	O
unaligned_access	O
)	O
,	O
T	O
(	O
stack_align	O
)	O
,	O
}	O
;	O
static	O
unsigned	O
char	O
*	O
display_riscv_attribute	function
(	O
unsigned	O
char	O
*	O
p	pointer
,	O
const	O
unsigned	O
char	O
*	O
const	O
end	pointer
)	O
{	O
unsigned	O
int	O
val	array
;	O
unsigned	O
int	O
tag	int
;	O
struct	O
riscv_attr_tag_t	struct
*	O
attr	int
=	O
NULL	O
;	O
unsigned	O
i	pointer
;	O
READ_ULEB	O
(	O
tag	int
,	O
p	pointer
,	O
end	pointer
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
ARRAY_SIZE	O
(	O
riscv_attr_tag	array
)	O
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
riscv_attr_tag	array
[	O
i	pointer
]	O
.	O
tag	int
==	O
tag	int
)	O
{	O
attr	int
=	O
&	O
riscv_attr_tag	array
[	O
i	pointer
]	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
attr	int
)	O
printf	function
(	O
"  %s: "	pointer
,	O
attr	int
->	O
name	pointer
)	O
;	O
else	O
return	O
display_tag_value	function
(	O
tag	int
,	O
p	pointer
,	O
end	pointer
)	O
;	O
switch	O
(	O
tag	int
)	O
{	O
case	O
Tag_RISCV_priv_spec	int
:	O
case	O
Tag_RISCV_priv_spec_minor	int
:	O
case	O
Tag_RISCV_priv_spec_revision	int
:	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"%u\n"	pointer
)	O
,	O
val	array
)	O
;	O
break	O
;	O
case	O
Tag_RISCV_unaligned_access	int
:	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
switch	O
(	O
val	array
)	O
{	O
case	O
0	int
:	O
printf	function
(	O
_	O
(	O
"No unaligned access\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	function
(	O
_	O
(	O
"Unaligned access\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
Tag_RISCV_stack_align	int
:	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"%u-bytes\n"	pointer
)	O
,	O
val	array
)	O
;	O
break	O
;	O
case	O
Tag_RISCV_arch	int
:	O
p	pointer
=	O
display_tag_value	function
(	O
-	O
1	int
,	O
p	pointer
,	O
end	pointer
)	O
;	O
break	O
;	O
default	O
:	O
return	O
display_tag_value	function
(	O
tag	int
,	O
p	pointer
,	O
end	pointer
)	O
;	O
}	O
return	O
p	pointer
;	O
}	O
static	O
bfd_boolean	int
process_attributes	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
const	O
char	O
*	O
public_name	pointer
,	O
unsigned	O
int	O
proc_type	int
,	O
unsigned	O
char	O
*	O
(	O
*	O
display_pub_attribute	pointer
)	O
(	O
unsigned	O
char	O
*	O
,	O
const	O
unsigned	O
char	O
*	O
const	O
)	O
,	O
unsigned	O
char	O
*	O
(	O
*	O
display_proc_gnu_attribute	pointer
)	O
(	O
unsigned	O
char	O
*	O
,	O
unsigned	O
int	O
,	O
const	O
unsigned	O
char	O
*	O
const	O
)	O
)	O
{	O
Elf_Internal_Shdr	struct
*	O
sect	pointer
;	O
unsigned	O
i	pointer
;	O
bfd_boolean	int
res	int
=	O
TRUE	int
;	O
for	O
(	O
i	pointer
=	O
0	int
,	O
sect	pointer
=	O
filedata	struct
->	O
section_headers	pointer
;	O
i	pointer
<	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
;	O
i	pointer
++	O
,	O
sect	pointer
++	O
)	O
{	O
unsigned	O
char	O
*	O
contents	pointer
;	O
unsigned	O
char	O
*	O
p	pointer
;	O
if	O
(	O
sect	pointer
->	O
sh_type	array
!=	O
proc_type	int
&&	O
sect	pointer
->	O
sh_type	array
!=	O
SHT_GNU_ATTRIBUTES	int
)	O
continue	O
;	O
contents	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
sect	pointer
->	O
sh_offset	array
,	O
1	int
,	O
sect	pointer
->	O
sh_size	array
,	O
_	O
(	O
"attributes"	pointer
)	O
)	O
;	O
if	O
(	O
contents	pointer
==	O
NULL	O
)	O
{	O
res	int
=	O
FALSE	int
;	O
continue	O
;	O
}	O
p	pointer
=	O
contents	pointer
;	O
if	O
(	O
*	O
p	pointer
!=	O
'A'	O
)	O
{	O
printf	function
(	O
_	O
(	O
"Unknown attributes version '%c'(%d) - expecting 'A'\n"	pointer
)	O
,	O
*	O
p	pointer
,	O
*	O
p	pointer
)	O
;	O
res	int
=	O
FALSE	int
;	O
}	O
else	O
{	O
bfd_vma	long
section_len	long
;	O
section_len	long
=	O
sect	pointer
->	O
sh_size	array
-	O
1	int
;	O
p	pointer
++	O
;	O
while	O
(	O
section_len	long
>	O
0	int
)	O
{	O
bfd_vma	long
attr_len	long
;	O
unsigned	O
int	O
namelen	int
;	O
bfd_boolean	int
public_section	int
;	O
bfd_boolean	int
gnu_section	int
;	O
if	O
(	O
section_len	long
<=	O
4	int
)	O
{	O
error	function
(	O
_	O
(	O
"Tag section ends prematurely\n"	pointer
)	O
)	O
;	O
res	int
=	O
FALSE	int
;	O
break	O
;	O
}	O
attr_len	long
=	O
byte_get	pointer
(	O
p	pointer
,	O
4	int
)	O
;	O
p	pointer
+=	O
4	int
;	O
if	O
(	O
attr_len	long
>	O
section_len	long
)	O
{	O
error	function
(	O
_	O
(	O
"Bad attribute length (%u > %u)\n"	pointer
)	O
,	O
(	O
unsigned	O
)	O
attr_len	long
,	O
(	O
unsigned	O
)	O
section_len	long
)	O
;	O
attr_len	long
=	O
section_len	long
;	O
res	int
=	O
FALSE	int
;	O
}	O
else	O
if	O
(	O
attr_len	long
<	O
5	int
)	O
{	O
error	function
(	O
_	O
(	O
"Attribute length of %u is too small\n"	pointer
)	O
,	O
(	O
unsigned	O
)	O
attr_len	long
)	O
;	O
res	int
=	O
FALSE	int
;	O
break	O
;	O
}	O
section_len	long
-=	O
attr_len	long
;	O
attr_len	long
-=	O
4	int
;	O
namelen	int
=	O
strnlen	function
(	O
(	O
char	O
*	O
)	O
p	pointer
,	O
attr_len	long
)	O
+	O
1	int
;	O
if	O
(	O
namelen	int
==	O
0	int
||	O
namelen	int
>=	O
attr_len	long
)	O
{	O
error	function
(	O
_	O
(	O
"Corrupt attribute section name\n"	pointer
)	O
)	O
;	O
res	int
=	O
FALSE	int
;	O
break	O
;	O
}	O
printf	function
(	O
_	O
(	O
"Attribute Section: "	pointer
)	O
)	O
;	O
print_symbol	function
(	O
INT_MAX	O
,	O
(	O
const	O
char	O
*	O
)	O
p	pointer
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
if	O
(	O
public_name	pointer
&&	O
streq	O
(	O
(	O
char	O
*	O
)	O
p	pointer
,	O
public_name	pointer
)	O
)	O
public_section	int
=	O
TRUE	int
;	O
else	O
public_section	int
=	O
FALSE	int
;	O
if	O
(	O
streq	O
(	O
(	O
char	O
*	O
)	O
p	pointer
,	O
"gnu"	pointer
)	O
)	O
gnu_section	int
=	O
TRUE	int
;	O
else	O
gnu_section	int
=	O
FALSE	int
;	O
p	pointer
+=	O
namelen	int
;	O
attr_len	long
-=	O
namelen	int
;	O
while	O
(	O
attr_len	long
>	O
0	int
&&	O
p	pointer
<	O
contents	pointer
+	O
sect	pointer
->	O
sh_size	array
)	O
{	O
int	O
tag	int
;	O
unsigned	O
int	O
val	array
;	O
bfd_vma	long
size	int
;	O
unsigned	O
char	O
*	O
end	pointer
;	O
if	O
(	O
attr_len	long
<	O
6	int
)	O
{	O
error	function
(	O
_	O
(	O
"Unused bytes at end of section\n"	pointer
)	O
)	O
;	O
res	int
=	O
FALSE	int
;	O
section_len	long
=	O
0	int
;	O
break	O
;	O
}	O
tag	int
=	O
*	O
(	O
p	pointer
++	O
)	O
;	O
size	int
=	O
byte_get	pointer
(	O
p	pointer
,	O
4	int
)	O
;	O
if	O
(	O
size	int
>	O
attr_len	long
)	O
{	O
error	function
(	O
_	O
(	O
"Bad subsection length (%u > %u)\n"	pointer
)	O
,	O
(	O
unsigned	O
)	O
size	int
,	O
(	O
unsigned	O
)	O
attr_len	long
)	O
;	O
res	int
=	O
FALSE	int
;	O
size	int
=	O
attr_len	long
;	O
}	O
if	O
(	O
size	int
<	O
6	int
)	O
{	O
error	function
(	O
_	O
(	O
"Bad subsection length (%u < 6)\n"	pointer
)	O
,	O
(	O
unsigned	O
)	O
size	int
)	O
;	O
res	int
=	O
FALSE	int
;	O
section_len	long
=	O
0	int
;	O
break	O
;	O
}	O
attr_len	long
-=	O
size	int
;	O
end	pointer
=	O
p	pointer
+	O
size	int
-	O
1	int
;	O
assert	O
(	O
end	pointer
<=	O
contents	pointer
+	O
sect	pointer
->	O
sh_size	array
)	O
;	O
p	pointer
+=	O
4	int
;	O
switch	O
(	O
tag	int
)	O
{	O
case	O
1	int
:	O
printf	function
(	O
_	O
(	O
"File Attributes\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
printf	function
(	O
_	O
(	O
"Section Attributes:"	pointer
)	O
)	O
;	O
goto	O
do_numlist	O
;	O
case	O
3	int
:	O
printf	function
(	O
_	O
(	O
"Symbol Attributes:"	pointer
)	O
)	O
;	O
do_numlist	O
:	O
for	O
(	O
;	O
;	O
)	O
{	O
READ_ULEB	O
(	O
val	array
,	O
p	pointer
,	O
end	pointer
)	O
;	O
if	O
(	O
val	array
==	O
0	int
)	O
break	O
;	O
printf	function
(	O
" %d"	pointer
,	O
val	array
)	O
;	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
_	O
(	O
"Unknown tag: %d\n"	pointer
)	O
,	O
tag	int
)	O
;	O
public_section	int
=	O
FALSE	int
;	O
break	O
;	O
}	O
if	O
(	O
public_section	int
&&	O
display_pub_attribute	pointer
!=	O
NULL	O
)	O
{	O
while	O
(	O
p	pointer
<	O
end	pointer
)	O
p	pointer
=	O
display_pub_attribute	pointer
(	O
p	pointer
,	O
end	pointer
)	O
;	O
assert	O
(	O
p	pointer
==	O
end	pointer
)	O
;	O
}	O
else	O
if	O
(	O
gnu_section	int
&&	O
display_proc_gnu_attribute	pointer
!=	O
NULL	O
)	O
{	O
while	O
(	O
p	pointer
<	O
end	pointer
)	O
p	pointer
=	O
display_gnu_attribute	function
(	O
p	pointer
,	O
display_proc_gnu_attribute	pointer
,	O
end	pointer
)	O
;	O
assert	O
(	O
p	pointer
==	O
end	pointer
)	O
;	O
}	O
else	O
if	O
(	O
p	pointer
<	O
end	pointer
)	O
{	O
printf	function
(	O
_	O
(	O
"  Unknown attribute:\n"	pointer
)	O
)	O
;	O
display_raw_attribute	function
(	O
p	pointer
,	O
end	pointer
)	O
;	O
p	pointer
=	O
end	pointer
;	O
}	O
else	O
attr_len	long
=	O
0	int
;	O
}	O
}	O
}	O
free	function
(	O
contents	pointer
)	O
;	O
}	O
return	O
res	int
;	O
}	O
static	O
bfd_vma	long
print_mips_got_entry	function
(	O
unsigned	O
char	O
*	O
data	pointer
,	O
bfd_vma	long
pltgot	long
,	O
bfd_vma	long
addr	pointer
,	O
unsigned	O
char	O
*	O
data_end	pointer
)	O
{	O
printf	function
(	O
"  "	pointer
)	O
;	O
print_vma	function
(	O
addr	pointer
,	O
LONG_HEX	int
)	O
;	O
printf	function
(	O
" "	pointer
)	O
;	O
if	O
(	O
addr	pointer
<	O
pltgot	long
+	O
0xfff0	int
)	O
printf	function
(	O
"%6d(gp)"	pointer
,	O
(	O
int	O
)	O
(	O
addr	pointer
-	O
pltgot	long
-	O
0x7ff0	int
)	O
)	O
;	O
else	O
printf	function
(	O
"%10s"	pointer
,	O
""	pointer
)	O
;	O
printf	function
(	O
" "	pointer
)	O
;	O
if	O
(	O
data	pointer
==	O
NULL	O
)	O
printf	function
(	O
"%*s"	pointer
,	O
is_32bit_elf	int
?	O
8	int
:	O
16	int
,	O
_	O
(	O
"<unknown>"	pointer
)	O
)	O
;	O
else	O
{	O
bfd_vma	long
entry	int
;	O
unsigned	O
char	O
*	O
from	pointer
=	O
data	pointer
+	O
addr	pointer
-	O
pltgot	long
;	O
if	O
(	O
from	pointer
+	O
(	O
is_32bit_elf	int
?	O
4	int
:	O
8	int
)	O
>	O
data_end	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"MIPS GOT entry extends beyond the end of available data\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"%*s"	pointer
,	O
is_32bit_elf	int
?	O
8	int
:	O
16	int
,	O
_	O
(	O
"<corrupt>"	pointer
)	O
)	O
;	O
return	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
}	O
else	O
{	O
entry	int
=	O
byte_get	pointer
(	O
data	pointer
+	O
addr	pointer
-	O
pltgot	long
,	O
is_32bit_elf	int
?	O
4	int
:	O
8	int
)	O
;	O
print_vma	function
(	O
entry	int
,	O
LONG_HEX	int
)	O
;	O
}	O
}	O
return	O
addr	pointer
+	O
(	O
is_32bit_elf	int
?	O
4	int
:	O
8	int
)	O
;	O
}	O
static	O
bfd_vma	long
print_mips_pltgot_entry	function
(	O
unsigned	O
char	O
*	O
data	pointer
,	O
bfd_vma	long
pltgot	long
,	O
bfd_vma	long
addr	pointer
)	O
{	O
printf	function
(	O
"  "	pointer
)	O
;	O
print_vma	function
(	O
addr	pointer
,	O
LONG_HEX	int
)	O
;	O
printf	function
(	O
" "	pointer
)	O
;	O
if	O
(	O
data	pointer
==	O
NULL	O
)	O
printf	function
(	O
"%*s"	pointer
,	O
is_32bit_elf	int
?	O
8	int
:	O
16	int
,	O
_	O
(	O
"<unknown>"	pointer
)	O
)	O
;	O
else	O
{	O
bfd_vma	long
entry	int
;	O
entry	int
=	O
byte_get	pointer
(	O
data	pointer
+	O
addr	pointer
-	O
pltgot	long
,	O
is_32bit_elf	int
?	O
4	int
:	O
8	int
)	O
;	O
print_vma	function
(	O
entry	int
,	O
LONG_HEX	int
)	O
;	O
}	O
return	O
addr	pointer
+	O
(	O
is_32bit_elf	int
?	O
4	int
:	O
8	int
)	O
;	O
}	O
static	O
void	O
print_mips_ases	function
(	O
unsigned	O
int	O
mask	int
)	O
{	O
if	O
(	O
mask	int
&	O
AFL_ASE_DSP	int
)	O
fputs	function
(	O
"\n\tDSP ASE"	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
mask	int
&	O
AFL_ASE_DSPR2	int
)	O
fputs	function
(	O
"\n\tDSP R2 ASE"	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
mask	int
&	O
AFL_ASE_DSPR3	int
)	O
fputs	function
(	O
"\n\tDSP R3 ASE"	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
mask	int
&	O
AFL_ASE_EVA	int
)	O
fputs	function
(	O
"\n\tEnhanced VA Scheme"	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
mask	int
&	O
AFL_ASE_MCU	int
)	O
fputs	function
(	O
"\n\tMCU (MicroController) ASE"	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
mask	int
&	O
AFL_ASE_MDMX	int
)	O
fputs	function
(	O
"\n\tMDMX ASE"	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
mask	int
&	O
AFL_ASE_MIPS3D	int
)	O
fputs	function
(	O
"\n\tMIPS-3D ASE"	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
mask	int
&	O
AFL_ASE_MT	int
)	O
fputs	function
(	O
"\n\tMT ASE"	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
mask	int
&	O
AFL_ASE_SMARTMIPS	int
)	O
fputs	function
(	O
"\n\tSmartMIPS ASE"	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
mask	int
&	O
AFL_ASE_VIRT	int
)	O
fputs	function
(	O
"\n\tVZ ASE"	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
mask	int
&	O
AFL_ASE_MSA	int
)	O
fputs	function
(	O
"\n\tMSA ASE"	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
mask	int
&	O
AFL_ASE_MIPS16	int
)	O
fputs	function
(	O
"\n\tMIPS16 ASE"	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
mask	int
&	O
AFL_ASE_MICROMIPS	int
)	O
fputs	function
(	O
"\n\tMICROMIPS ASE"	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
mask	int
&	O
AFL_ASE_XPA	int
)	O
fputs	function
(	O
"\n\tXPA ASE"	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
mask	int
&	O
AFL_ASE_MIPS16E2	int
)	O
fputs	function
(	O
"\n\tMIPS16e2 ASE"	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
mask	int
&	O
AFL_ASE_CRC	int
)	O
fputs	function
(	O
"\n\tCRC ASE"	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
mask	int
&	O
AFL_ASE_GINV	int
)	O
fputs	function
(	O
"\n\tGINV ASE"	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
mask	int
&	O
AFL_ASE_LOONGSON_MMI	int
)	O
fputs	function
(	O
"\n\tLoongson MMI ASE"	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
mask	int
&	O
AFL_ASE_LOONGSON_CAM	int
)	O
fputs	function
(	O
"\n\tLoongson CAM ASE"	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
mask	int
&	O
AFL_ASE_LOONGSON_EXT	int
)	O
fputs	function
(	O
"\n\tLoongson EXT ASE"	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
mask	int
&	O
AFL_ASE_LOONGSON_EXT2	int
)	O
fputs	function
(	O
"\n\tLoongson EXT2 ASE"	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
mask	int
==	O
0	int
)	O
fprintf	function
(	O
stdout	pointer
,	O
"\n\t%s"	pointer
,	O
_	O
(	O
"None"	pointer
)	O
)	O
;	O
else	O
if	O
(	O
(	O
mask	int
&	O
~	O
AFL_ASE_MASK	int
)	O
!=	O
0	int
)	O
fprintf	function
(	O
stdout	pointer
,	O
"\n\t%s (%x)"	pointer
,	O
_	O
(	O
"Unknown"	pointer
)	O
,	O
mask	int
&	O
~	O
AFL_ASE_MASK	int
)	O
;	O
}	O
static	O
void	O
print_mips_isa_ext	function
(	O
unsigned	O
int	O
isa_ext	array
)	O
{	O
switch	O
(	O
isa_ext	array
)	O
{	O
case	O
0	int
:	O
fputs	function
(	O
_	O
(	O
"None"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
break	O
;	O
case	O
AFL_EXT_XLR	int
:	O
fputs	function
(	O
"RMI XLR"	pointer
,	O
stdout	pointer
)	O
;	O
break	O
;	O
case	O
AFL_EXT_OCTEON3	int
:	O
fputs	function
(	O
"Cavium Networks Octeon3"	pointer
,	O
stdout	pointer
)	O
;	O
break	O
;	O
case	O
AFL_EXT_OCTEON2	int
:	O
fputs	function
(	O
"Cavium Networks Octeon2"	pointer
,	O
stdout	pointer
)	O
;	O
break	O
;	O
case	O
AFL_EXT_OCTEONP	int
:	O
fputs	function
(	O
"Cavium Networks OcteonP"	pointer
,	O
stdout	pointer
)	O
;	O
break	O
;	O
case	O
AFL_EXT_OCTEON	int
:	O
fputs	function
(	O
"Cavium Networks Octeon"	pointer
,	O
stdout	pointer
)	O
;	O
break	O
;	O
case	O
AFL_EXT_5900	int
:	O
fputs	function
(	O
"Toshiba R5900"	pointer
,	O
stdout	pointer
)	O
;	O
break	O
;	O
case	O
AFL_EXT_4650	int
:	O
fputs	function
(	O
"MIPS R4650"	pointer
,	O
stdout	pointer
)	O
;	O
break	O
;	O
case	O
AFL_EXT_4010	int
:	O
fputs	function
(	O
"LSI R4010"	pointer
,	O
stdout	pointer
)	O
;	O
break	O
;	O
case	O
AFL_EXT_4100	int
:	O
fputs	function
(	O
"NEC VR4100"	pointer
,	O
stdout	pointer
)	O
;	O
break	O
;	O
case	O
AFL_EXT_3900	int
:	O
fputs	function
(	O
"Toshiba R3900"	pointer
,	O
stdout	pointer
)	O
;	O
break	O
;	O
case	O
AFL_EXT_10000	int
:	O
fputs	function
(	O
"MIPS R10000"	pointer
,	O
stdout	pointer
)	O
;	O
break	O
;	O
case	O
AFL_EXT_SB1	int
:	O
fputs	function
(	O
"Broadcom SB-1"	pointer
,	O
stdout	pointer
)	O
;	O
break	O
;	O
case	O
AFL_EXT_4111	int
:	O
fputs	function
(	O
"NEC VR4111/VR4181"	pointer
,	O
stdout	pointer
)	O
;	O
break	O
;	O
case	O
AFL_EXT_4120	int
:	O
fputs	function
(	O
"NEC VR4120"	pointer
,	O
stdout	pointer
)	O
;	O
break	O
;	O
case	O
AFL_EXT_5400	int
:	O
fputs	function
(	O
"NEC VR5400"	pointer
,	O
stdout	pointer
)	O
;	O
break	O
;	O
case	O
AFL_EXT_5500	int
:	O
fputs	function
(	O
"NEC VR5500"	pointer
,	O
stdout	pointer
)	O
;	O
break	O
;	O
case	O
AFL_EXT_LOONGSON_2E	int
:	O
fputs	function
(	O
"ST Microelectronics Loongson 2E"	pointer
,	O
stdout	pointer
)	O
;	O
break	O
;	O
case	O
AFL_EXT_LOONGSON_2F	int
:	O
fputs	function
(	O
"ST Microelectronics Loongson 2F"	pointer
,	O
stdout	pointer
)	O
;	O
break	O
;	O
case	O
AFL_EXT_INTERAPTIV_MR2	int
:	O
fputs	function
(	O
"Imagination interAptiv MR2"	pointer
,	O
stdout	pointer
)	O
;	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
stdout	pointer
,	O
"%s (%d)"	pointer
,	O
_	O
(	O
"Unknown"	pointer
)	O
,	O
isa_ext	array
)	O
;	O
}	O
}	O
static	O
signed	O
int	O
get_mips_reg_size	function
(	O
int	O
reg_size	int
)	O
{	O
return	O
(	O
reg_size	int
==	O
AFL_REG_NONE	int
)	O
?	O
0	int
:	O
(	O
reg_size	int
==	O
AFL_REG_32	int
)	O
?	O
32	int
:	O
(	O
reg_size	int
==	O
AFL_REG_64	int
)	O
?	O
64	int
:	O
(	O
reg_size	int
==	O
AFL_REG_128	int
)	O
?	O
128	int
:	O
-	O
1	int
;	O
}	O
static	O
bfd_boolean	int
process_mips_specific	function
(	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
Elf_Internal_Dyn	struct
*	O
entry	int
;	O
Elf_Internal_Shdr	struct
*	O
sect	pointer
=	O
NULL	O
;	O
size_t	long
liblist_offset	long
=	O
0	int
;	O
size_t	long
liblistno	long
=	O
0	int
;	O
size_t	long
conflictsno	long
=	O
0	int
;	O
size_t	long
options_offset	long
=	O
0	int
;	O
size_t	long
conflicts_offset	long
=	O
0	int
;	O
size_t	long
pltrelsz	long
=	O
0	int
;	O
size_t	long
pltrel	long
=	O
0	int
;	O
bfd_vma	long
pltgot	long
=	O
0	int
;	O
bfd_vma	long
mips_pltgot	long
=	O
0	int
;	O
bfd_vma	long
jmprel	long
=	O
0	int
;	O
bfd_vma	long
local_gotno	long
=	O
0	int
;	O
bfd_vma	long
gotsym	long
=	O
0	int
;	O
bfd_vma	long
symtabno	long
=	O
0	int
;	O
bfd_boolean	int
res	int
=	O
TRUE	int
;	O
if	O
(	O
!	O
process_attributes	function
(	O
filedata	struct
,	O
NULL	O
,	O
SHT_GNU_ATTRIBUTES	int
,	O
NULL	O
,	O
display_mips_gnu_attribute	function
)	O
)	O
res	int
=	O
FALSE	int
;	O
sect	pointer
=	O
find_section	function
(	O
filedata	struct
,	O
".MIPS.abiflags"	pointer
)	O
;	O
if	O
(	O
sect	pointer
!=	O
NULL	O
)	O
{	O
Elf_External_ABIFlags_v0	struct
*	O
abiflags_ext	pointer
;	O
Elf_Internal_ABIFlags_v0	struct
abiflags_in	struct
;	O
if	O
(	O
sizeof	O
(	O
Elf_External_ABIFlags_v0	struct
)	O
!=	O
sect	pointer
->	O
sh_size	array
)	O
{	O
error	function
(	O
_	O
(	O
"Corrupt MIPS ABI Flags section.\n"	pointer
)	O
)	O
;	O
res	int
=	O
FALSE	int
;	O
}	O
else	O
{	O
abiflags_ext	pointer
=	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
sect	pointer
->	O
sh_offset	array
,	O
1	int
,	O
sect	pointer
->	O
sh_size	array
,	O
_	O
(	O
"MIPS ABI Flags section"	pointer
)	O
)	O
;	O
if	O
(	O
abiflags_ext	pointer
)	O
{	O
abiflags_in	struct
.	O
version	pointer
=	O
BYTE_GET	O
(	O
abiflags_ext	pointer
->	O
version	pointer
)	O
;	O
abiflags_in	struct
.	O
isa_level	array
=	O
BYTE_GET	O
(	O
abiflags_ext	pointer
->	O
isa_level	array
)	O
;	O
abiflags_in	struct
.	O
isa_rev	array
=	O
BYTE_GET	O
(	O
abiflags_ext	pointer
->	O
isa_rev	array
)	O
;	O
abiflags_in	struct
.	O
gpr_size	array
=	O
BYTE_GET	O
(	O
abiflags_ext	pointer
->	O
gpr_size	array
)	O
;	O
abiflags_in	struct
.	O
cpr1_size	array
=	O
BYTE_GET	O
(	O
abiflags_ext	pointer
->	O
cpr1_size	array
)	O
;	O
abiflags_in	struct
.	O
cpr2_size	array
=	O
BYTE_GET	O
(	O
abiflags_ext	pointer
->	O
cpr2_size	array
)	O
;	O
abiflags_in	struct
.	O
fp_abi	array
=	O
BYTE_GET	O
(	O
abiflags_ext	pointer
->	O
fp_abi	array
)	O
;	O
abiflags_in	struct
.	O
isa_ext	array
=	O
BYTE_GET	O
(	O
abiflags_ext	pointer
->	O
isa_ext	array
)	O
;	O
abiflags_in	struct
.	O
ases	array
=	O
BYTE_GET	O
(	O
abiflags_ext	pointer
->	O
ases	array
)	O
;	O
abiflags_in	struct
.	O
flags1	array
=	O
BYTE_GET	O
(	O
abiflags_ext	pointer
->	O
flags1	array
)	O
;	O
abiflags_in	struct
.	O
flags2	array
=	O
BYTE_GET	O
(	O
abiflags_ext	pointer
->	O
flags2	array
)	O
;	O
printf	function
(	O
"\nMIPS ABI Flags Version: %d\n"	pointer
,	O
abiflags_in	struct
.	O
version	pointer
)	O
;	O
printf	function
(	O
"\nISA: MIPS%d"	pointer
,	O
abiflags_in	struct
.	O
isa_level	array
)	O
;	O
if	O
(	O
abiflags_in	struct
.	O
isa_rev	array
>	O
1	int
)	O
printf	function
(	O
"r%d"	pointer
,	O
abiflags_in	struct
.	O
isa_rev	array
)	O
;	O
printf	function
(	O
"\nGPR size: %d"	pointer
,	O
get_mips_reg_size	function
(	O
abiflags_in	struct
.	O
gpr_size	array
)	O
)	O
;	O
printf	function
(	O
"\nCPR1 size: %d"	pointer
,	O
get_mips_reg_size	function
(	O
abiflags_in	struct
.	O
cpr1_size	array
)	O
)	O
;	O
printf	function
(	O
"\nCPR2 size: %d"	pointer
,	O
get_mips_reg_size	function
(	O
abiflags_in	struct
.	O
cpr2_size	array
)	O
)	O
;	O
fputs	function
(	O
"\nFP ABI: "	pointer
,	O
stdout	pointer
)	O
;	O
print_mips_fp_abi_value	function
(	O
abiflags_in	struct
.	O
fp_abi	array
)	O
;	O
fputs	function
(	O
"ISA Extension: "	pointer
,	O
stdout	pointer
)	O
;	O
print_mips_isa_ext	function
(	O
abiflags_in	struct
.	O
isa_ext	array
)	O
;	O
fputs	function
(	O
"\nASEs:"	pointer
,	O
stdout	pointer
)	O
;	O
print_mips_ases	function
(	O
abiflags_in	struct
.	O
ases	array
)	O
;	O
printf	function
(	O
"\nFLAGS 1: %8.8lx"	pointer
,	O
abiflags_in	struct
.	O
flags1	array
)	O
;	O
printf	function
(	O
"\nFLAGS 2: %8.8lx"	pointer
,	O
abiflags_in	struct
.	O
flags2	array
)	O
;	O
fputc	function
(	O
'\n'	O
,	O
stdout	pointer
)	O
;	O
free	function
(	O
abiflags_ext	pointer
)	O
;	O
}	O
}	O
}	O
if	O
(	O
dynamic_section	pointer
==	O
NULL	O
)	O
{	O
sect	pointer
=	O
find_section	function
(	O
filedata	struct
,	O
".got"	pointer
)	O
;	O
if	O
(	O
sect	pointer
!=	O
NULL	O
)	O
{	O
unsigned	O
char	O
*	O
data_end	pointer
;	O
unsigned	O
char	O
*	O
data	pointer
;	O
bfd_vma	long
ent	struct
,	O
end	pointer
;	O
int	O
addr_size	int
;	O
pltgot	long
=	O
sect	pointer
->	O
sh_addr	array
;	O
ent	struct
=	O
pltgot	long
;	O
addr_size	int
=	O
(	O
is_32bit_elf	int
?	O
4	int
:	O
8	int
)	O
;	O
end	pointer
=	O
pltgot	long
+	O
sect	pointer
->	O
sh_size	array
;	O
data	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
sect	pointer
->	O
sh_offset	array
,	O
end	pointer
-	O
pltgot	long
,	O
1	int
,	O
_	O
(	O
"Global Offset Table data"	pointer
)	O
)	O
;	O
data_end	pointer
=	O
data	pointer
+	O
(	O
end	pointer
-	O
pltgot	long
)	O
;	O
printf	function
(	O
_	O
(	O
"\nStatic GOT:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
" Canonical gp value: "	pointer
)	O
)	O
;	O
print_vma	function
(	O
ent	struct
+	O
0x7ff0	int
,	O
LONG_HEX	int
)	O
;	O
printf	function
(	O
"\n\n"	pointer
)	O
;	O
if	O
(	O
data	pointer
&&	O
data	pointer
+	O
ent	struct
-	O
pltgot	long
+	O
addr_size	int
<=	O
data_end	pointer
&&	O
byte_get	pointer
(	O
data	pointer
+	O
ent	struct
-	O
pltgot	long
,	O
addr_size	int
)	O
==	O
0	int
)	O
{	O
printf	function
(	O
_	O
(	O
" Reserved entries:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  %*s %10s %*s\n"	pointer
)	O
,	O
addr_size	int
*	O
2	int
,	O
_	O
(	O
"Address"	pointer
)	O
,	O
_	O
(	O
"Access"	pointer
)	O
,	O
addr_size	int
*	O
2	int
,	O
_	O
(	O
"Value"	pointer
)	O
)	O
;	O
ent	struct
=	O
print_mips_got_entry	function
(	O
data	pointer
,	O
pltgot	long
,	O
ent	struct
,	O
data_end	pointer
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
if	O
(	O
ent	struct
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
goto	O
sgot_print_fail	O
;	O
if	O
(	O
data	pointer
&&	O
data	pointer
+	O
ent	struct
-	O
pltgot	long
+	O
addr_size	int
<=	O
data_end	pointer
&&	O
(	O
byte_get	pointer
(	O
data	pointer
+	O
ent	struct
-	O
pltgot	long
,	O
addr_size	int
)	O
>>	O
(	O
addr_size	int
*	O
8	int
-	O
1	int
)	O
)	O
!=	O
0	int
)	O
{	O
ent	struct
=	O
print_mips_got_entry	function
(	O
data	pointer
,	O
pltgot	long
,	O
ent	struct
,	O
data_end	pointer
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
if	O
(	O
ent	struct
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
goto	O
sgot_print_fail	O
;	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
if	O
(	O
data	pointer
!=	O
NULL	O
&&	O
ent	struct
<	O
end	pointer
)	O
{	O
printf	function
(	O
_	O
(	O
" Local entries:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"  %*s %10s %*s\n"	pointer
,	O
addr_size	int
*	O
2	int
,	O
_	O
(	O
"Address"	pointer
)	O
,	O
_	O
(	O
"Access"	pointer
)	O
,	O
addr_size	int
*	O
2	int
,	O
_	O
(	O
"Value"	pointer
)	O
)	O
;	O
while	O
(	O
ent	struct
<	O
end	pointer
)	O
{	O
ent	struct
=	O
print_mips_got_entry	function
(	O
data	pointer
,	O
pltgot	long
,	O
ent	struct
,	O
data_end	pointer
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
if	O
(	O
ent	struct
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
goto	O
sgot_print_fail	O
;	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
sgot_print_fail	O
:	O
if	O
(	O
data	pointer
)	O
free	function
(	O
data	pointer
)	O
;	O
}	O
return	O
res	int
;	O
}	O
for	O
(	O
entry	int
=	O
dynamic_section	pointer
;	O
entry	int
<	O
dynamic_section	pointer
+	O
dynamic_nent	long
&&	O
entry	int
->	O
d_tag	array
!=	O
DT_NULL	int
;	O
++	O
entry	int
)	O
switch	O
(	O
entry	int
->	O
d_tag	array
)	O
{	O
case	O
DT_MIPS_LIBLIST	int
:	O
liblist_offset	long
=	O
offset_from_vma	function
(	O
filedata	struct
,	O
entry	int
->	O
d_un	union
.	O
d_val	array
,	O
liblistno	long
*	O
sizeof	O
(	O
Elf32_External_Lib	struct
)	O
)	O
;	O
break	O
;	O
case	O
DT_MIPS_LIBLISTNO	int
:	O
liblistno	long
=	O
entry	int
->	O
d_un	union
.	O
d_val	array
;	O
break	O
;	O
case	O
DT_MIPS_OPTIONS	int
:	O
options_offset	long
=	O
offset_from_vma	function
(	O
filedata	struct
,	O
entry	int
->	O
d_un	union
.	O
d_val	array
,	O
0	int
)	O
;	O
break	O
;	O
case	O
DT_MIPS_CONFLICT	int
:	O
conflicts_offset	long
=	O
offset_from_vma	function
(	O
filedata	struct
,	O
entry	int
->	O
d_un	union
.	O
d_val	array
,	O
conflictsno	long
*	O
sizeof	O
(	O
Elf32_External_Conflict	array
)	O
)	O
;	O
break	O
;	O
case	O
DT_MIPS_CONFLICTNO	int
:	O
conflictsno	long
=	O
entry	int
->	O
d_un	union
.	O
d_val	array
;	O
break	O
;	O
case	O
DT_PLTGOT	int
:	O
pltgot	long
=	O
entry	int
->	O
d_un	union
.	O
d_ptr	array
;	O
break	O
;	O
case	O
DT_MIPS_LOCAL_GOTNO	int
:	O
local_gotno	long
=	O
entry	int
->	O
d_un	union
.	O
d_val	array
;	O
break	O
;	O
case	O
DT_MIPS_GOTSYM	int
:	O
gotsym	long
=	O
entry	int
->	O
d_un	union
.	O
d_val	array
;	O
break	O
;	O
case	O
DT_MIPS_SYMTABNO	int
:	O
symtabno	long
=	O
entry	int
->	O
d_un	union
.	O
d_val	array
;	O
break	O
;	O
case	O
DT_MIPS_PLTGOT	int
:	O
mips_pltgot	long
=	O
entry	int
->	O
d_un	union
.	O
d_ptr	array
;	O
break	O
;	O
case	O
DT_PLTREL	int
:	O
pltrel	long
=	O
entry	int
->	O
d_un	union
.	O
d_val	array
;	O
break	O
;	O
case	O
DT_PLTRELSZ	int
:	O
pltrelsz	long
=	O
entry	int
->	O
d_un	union
.	O
d_val	array
;	O
break	O
;	O
case	O
DT_JMPREL	int
:	O
jmprel	long
=	O
entry	int
->	O
d_un	union
.	O
d_ptr	array
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
liblist_offset	long
!=	O
0	int
&&	O
liblistno	long
!=	O
0	int
&&	O
do_dynamic	int
)	O
{	O
Elf32_External_Lib	struct
*	O
elib	pointer
;	O
size_t	long
cnt	int
;	O
elib	pointer
=	O
(	O
Elf32_External_Lib	struct
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
liblist_offset	long
,	O
liblistno	long
,	O
sizeof	O
(	O
Elf32_External_Lib	struct
)	O
,	O
_	O
(	O
"liblist section data"	pointer
)	O
)	O
;	O
if	O
(	O
elib	pointer
)	O
{	O
printf	function
(	O
ngettext	function
(	O
"\nSection '.liblist' contains %lu entry:\n"	pointer
,	O
"\nSection '.liblist' contains %lu entries:\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
liblistno	long
)	O
,	O
(	O
unsigned	O
long	O
)	O
liblistno	long
)	O
;	O
fputs	function
(	O
_	O
(	O
"     Library              Time Stamp          Checksum   Version Flags\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
for	O
(	O
cnt	int
=	O
0	int
;	O
cnt	int
<	O
liblistno	long
;	O
++	O
cnt	int
)	O
{	O
Elf32_Lib	struct
liblist	struct
;	O
time_t	long
atime	long
;	O
char	O
timebuf	array
[	O
128	int
]	O
;	O
struct	O
tm	struct
*	O
tmp	pointer
;	O
liblist	struct
.	O
l_name	long
=	O
BYTE_GET	O
(	O
elib	pointer
[	O
cnt	int
]	O
.	O
l_name	long
)	O
;	O
atime	long
=	O
BYTE_GET	O
(	O
elib	pointer
[	O
cnt	int
]	O
.	O
l_time_stamp	long
)	O
;	O
liblist	struct
.	O
l_checksum	long
=	O
BYTE_GET	O
(	O
elib	pointer
[	O
cnt	int
]	O
.	O
l_checksum	long
)	O
;	O
liblist	struct
.	O
l_version	long
=	O
BYTE_GET	O
(	O
elib	pointer
[	O
cnt	int
]	O
.	O
l_version	long
)	O
;	O
liblist	struct
.	O
l_flags	long
=	O
BYTE_GET	O
(	O
elib	pointer
[	O
cnt	int
]	O
.	O
l_flags	long
)	O
;	O
tmp	pointer
=	O
gmtime	function
(	O
&	O
atime	long
)	O
;	O
snprintf	function
(	O
timebuf	array
,	O
sizeof	O
(	O
timebuf	array
)	O
,	O
"%04u-%02u-%02uT%02u:%02u:%02u"	pointer
,	O
tmp	pointer
->	O
tm_year	int
+	O
1900	int
,	O
tmp	pointer
->	O
tm_mon	int
+	O
1	int
,	O
tmp	pointer
->	O
tm_mday	int
,	O
tmp	pointer
->	O
tm_hour	int
,	O
tmp	pointer
->	O
tm_min	int
,	O
tmp	pointer
->	O
tm_sec	int
)	O
;	O
printf	function
(	O
"%3lu: "	pointer
,	O
(	O
unsigned	O
long	O
)	O
cnt	int
)	O
;	O
if	O
(	O
VALID_DYNAMIC_NAME	O
(	O
liblist	struct
.	O
l_name	long
)	O
)	O
print_symbol	function
(	O
20	int
,	O
GET_DYNAMIC_NAME	O
(	O
liblist	struct
.	O
l_name	long
)	O
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"<corrupt: %9ld>"	pointer
)	O
,	O
liblist	struct
.	O
l_name	long
)	O
;	O
printf	function
(	O
" %s %#10lx %-7ld"	pointer
,	O
timebuf	array
,	O
liblist	struct
.	O
l_checksum	long
,	O
liblist	struct
.	O
l_version	long
)	O
;	O
if	O
(	O
liblist	struct
.	O
l_flags	long
==	O
0	int
)	O
puts	function
(	O
_	O
(	O
" NONE"	pointer
)	O
)	O
;	O
else	O
{	O
static	O
const	O
struct	O
{	O
const	O
char	O
*	O
name	pointer
;	O
int	O
bit	long
;	O
}	O
l_flags_vals	array
[	O
]	O
=	O
{	O
{	O
" EXACT_MATCH"	pointer
,	O
LL_EXACT_MATCH	int
}	O
,	O
{	O
" IGNORE_INT_VER"	pointer
,	O
LL_IGNORE_INT_VER	int
}	O
,	O
{	O
" REQUIRE_MINOR"	pointer
,	O
LL_REQUIRE_MINOR	int
}	O
,	O
{	O
" EXPORTS"	pointer
,	O
LL_EXPORTS	int
}	O
,	O
{	O
" DELAY_LOAD"	pointer
,	O
LL_DELAY_LOAD	int
}	O
,	O
{	O
" DELTA"	pointer
,	O
LL_DELTA	int
}	O
}	O
;	O
int	O
flags	int
=	O
liblist	struct
.	O
l_flags	long
;	O
size_t	long
fcnt	long
;	O
for	O
(	O
fcnt	long
=	O
0	int
;	O
fcnt	long
<	O
ARRAY_SIZE	O
(	O
l_flags_vals	array
)	O
;	O
++	O
fcnt	long
)	O
if	O
(	O
(	O
flags	int
&	O
l_flags_vals	array
[	O
fcnt	long
]	O
.	O
bit	long
)	O
!=	O
0	int
)	O
{	O
fputs	function
(	O
l_flags_vals	array
[	O
fcnt	long
]	O
.	O
name	pointer
,	O
stdout	pointer
)	O
;	O
flags	int
^=	O
l_flags_vals	array
[	O
fcnt	long
]	O
.	O
bit	long
;	O
}	O
if	O
(	O
flags	int
!=	O
0	int
)	O
printf	function
(	O
" %#x"	pointer
,	O
(	O
unsigned	O
int	O
)	O
flags	int
)	O
;	O
puts	function
(	O
""	pointer
)	O
;	O
}	O
}	O
free	function
(	O
elib	pointer
)	O
;	O
}	O
else	O
res	int
=	O
FALSE	int
;	O
}	O
if	O
(	O
options_offset	long
!=	O
0	int
)	O
{	O
Elf_External_Options	struct
*	O
eopt	pointer
;	O
size_t	long
offset	long
;	O
int	O
cnt	int
;	O
sect	pointer
=	O
filedata	struct
->	O
section_headers	pointer
;	O
sect	pointer
=	O
find_section_by_type	function
(	O
filedata	struct
,	O
SHT_MIPS_OPTIONS	int
)	O
;	O
if	O
(	O
sect	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"No MIPS_OPTIONS header found\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
sect	pointer
->	O
sh_size	array
<	O
sizeof	O
(	O
*	O
eopt	pointer
)	O
)	O
{	O
error	function
(	O
_	O
(	O
"The MIPS options section is too small.\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
eopt	pointer
=	O
(	O
Elf_External_Options	struct
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
options_offset	long
,	O
1	int
,	O
sect	pointer
->	O
sh_size	array
,	O
_	O
(	O
"options"	pointer
)	O
)	O
;	O
if	O
(	O
eopt	pointer
)	O
{	O
Elf_Internal_Options	struct
*	O
iopt	pointer
;	O
Elf_Internal_Options	struct
*	O
option	struct
;	O
Elf_Internal_Options	struct
*	O
iopt_end	pointer
;	O
iopt	pointer
=	O
(	O
Elf_Internal_Options	struct
*	O
)	O
cmalloc	function
(	O
(	O
sect	pointer
->	O
sh_size	array
/	O
sizeof	O
(	O
eopt	pointer
)	O
)	O
,	O
sizeof	O
(	O
*	O
iopt	pointer
)	O
)	O
;	O
if	O
(	O
iopt	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Out of memory allocating space for MIPS options\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
offset	long
=	O
cnt	int
=	O
0	int
;	O
option	struct
=	O
iopt	pointer
;	O
iopt_end	pointer
=	O
iopt	pointer
+	O
(	O
sect	pointer
->	O
sh_size	array
/	O
sizeof	O
(	O
eopt	pointer
)	O
)	O
;	O
while	O
(	O
offset	long
<=	O
sect	pointer
->	O
sh_size	array
-	O
sizeof	O
(	O
*	O
eopt	pointer
)	O
)	O
{	O
Elf_External_Options	struct
*	O
eoption	pointer
;	O
eoption	pointer
=	O
(	O
Elf_External_Options	struct
*	O
)	O
(	O
(	O
char	O
*	O
)	O
eopt	pointer
+	O
offset	long
)	O
;	O
option	struct
->	O
kind	array
=	O
BYTE_GET	O
(	O
eoption	pointer
->	O
kind	array
)	O
;	O
option	struct
->	O
size	int
=	O
BYTE_GET	O
(	O
eoption	pointer
->	O
size	int
)	O
;	O
option	struct
->	O
section	pointer
=	O
BYTE_GET	O
(	O
eoption	pointer
->	O
section	pointer
)	O
;	O
option	struct
->	O
info	pointer
=	O
BYTE_GET	O
(	O
eoption	pointer
->	O
info	pointer
)	O
;	O
if	O
(	O
option	struct
->	O
size	int
<	O
sizeof	O
(	O
*	O
eopt	pointer
)	O
||	O
offset	long
+	O
option	struct
->	O
size	int
>	O
sect	pointer
->	O
sh_size	array
)	O
{	O
error	function
(	O
_	O
(	O
"Invalid size (%u) for MIPS option\n"	pointer
)	O
,	O
option	struct
->	O
size	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
offset	long
+=	O
option	struct
->	O
size	int
;	O
++	O
option	struct
;	O
++	O
cnt	int
;	O
}	O
printf	function
(	O
ngettext	function
(	O
"\nSection '%s' contains %d entry:\n"	pointer
,	O
"\nSection '%s' contains %d entries:\n"	pointer
,	O
cnt	int
)	O
,	O
printable_section_name	function
(	O
filedata	struct
,	O
sect	pointer
)	O
,	O
cnt	int
)	O
;	O
option	struct
=	O
iopt	pointer
;	O
offset	long
=	O
0	int
;	O
while	O
(	O
cnt	int
--	O
>	O
0	int
)	O
{	O
size_t	long
len	int
;	O
switch	O
(	O
option	struct
->	O
kind	array
)	O
{	O
case	O
ODK_NULL	int
:	O
printf	function
(	O
" NULL       %d %lx"	pointer
,	O
option	struct
->	O
section	pointer
,	O
option	struct
->	O
info	pointer
)	O
;	O
break	O
;	O
case	O
ODK_REGINFO	int
:	O
printf	function
(	O
" REGINFO    "	pointer
)	O
;	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_MIPS	int
)	O
{	O
Elf32_External_RegInfo	struct
*	O
ereg	pointer
;	O
Elf32_RegInfo	struct
reginfo	struct
;	O
if	O
(	O
option	struct
+	O
2	int
>	O
iopt_end	pointer
)	O
{	O
printf	function
(	O
_	O
(	O
"<corrupt>\n"	pointer
)	O
)	O
;	O
error	function
(	O
_	O
(	O
"Truncated MIPS REGINFO option\n"	pointer
)	O
)	O
;	O
cnt	int
=	O
0	int
;	O
break	O
;	O
}	O
ereg	pointer
=	O
(	O
Elf32_External_RegInfo	struct
*	O
)	O
(	O
option	struct
+	O
1	int
)	O
;	O
reginfo	struct
.	O
ri_gprmask	long
=	O
BYTE_GET	O
(	O
ereg	pointer
->	O
ri_gprmask	long
)	O
;	O
reginfo	struct
.	O
ri_cprmask	array
[	O
0	int
]	O
=	O
BYTE_GET	O
(	O
ereg	pointer
->	O
ri_cprmask	array
[	O
0	int
]	O
)	O
;	O
reginfo	struct
.	O
ri_cprmask	array
[	O
1	int
]	O
=	O
BYTE_GET	O
(	O
ereg	pointer
->	O
ri_cprmask	array
[	O
1	int
]	O
)	O
;	O
reginfo	struct
.	O
ri_cprmask	array
[	O
2	int
]	O
=	O
BYTE_GET	O
(	O
ereg	pointer
->	O
ri_cprmask	array
[	O
2	int
]	O
)	O
;	O
reginfo	struct
.	O
ri_cprmask	array
[	O
3	int
]	O
=	O
BYTE_GET	O
(	O
ereg	pointer
->	O
ri_cprmask	array
[	O
3	int
]	O
)	O
;	O
reginfo	struct
.	O
ri_gp_value	long
=	O
BYTE_GET	O
(	O
ereg	pointer
->	O
ri_gp_value	long
)	O
;	O
printf	function
(	O
"GPR %08lx  GP 0x%lx\n"	pointer
,	O
reginfo	struct
.	O
ri_gprmask	long
,	O
(	O
unsigned	O
long	O
)	O
reginfo	struct
.	O
ri_gp_value	long
)	O
;	O
printf	function
(	O
"            CPR0 %08lx  CPR1 %08lx  CPR2 %08lx  CPR3 %08lx\n"	pointer
,	O
reginfo	struct
.	O
ri_cprmask	array
[	O
0	int
]	O
,	O
reginfo	struct
.	O
ri_cprmask	array
[	O
1	int
]	O
,	O
reginfo	struct
.	O
ri_cprmask	array
[	O
2	int
]	O
,	O
reginfo	struct
.	O
ri_cprmask	array
[	O
3	int
]	O
)	O
;	O
}	O
else	O
{	O
Elf64_External_RegInfo	struct
*	O
ereg	pointer
;	O
Elf64_Internal_RegInfo	struct
reginfo	struct
;	O
if	O
(	O
option	struct
+	O
2	int
>	O
iopt_end	pointer
)	O
{	O
printf	function
(	O
_	O
(	O
"<corrupt>\n"	pointer
)	O
)	O
;	O
error	function
(	O
_	O
(	O
"Truncated MIPS REGINFO option\n"	pointer
)	O
)	O
;	O
cnt	int
=	O
0	int
;	O
break	O
;	O
}	O
ereg	pointer
=	O
(	O
Elf64_External_RegInfo	struct
*	O
)	O
(	O
option	struct
+	O
1	int
)	O
;	O
reginfo	struct
.	O
ri_gprmask	long
=	O
BYTE_GET	O
(	O
ereg	pointer
->	O
ri_gprmask	long
)	O
;	O
reginfo	struct
.	O
ri_cprmask	array
[	O
0	int
]	O
=	O
BYTE_GET	O
(	O
ereg	pointer
->	O
ri_cprmask	array
[	O
0	int
]	O
)	O
;	O
reginfo	struct
.	O
ri_cprmask	array
[	O
1	int
]	O
=	O
BYTE_GET	O
(	O
ereg	pointer
->	O
ri_cprmask	array
[	O
1	int
]	O
)	O
;	O
reginfo	struct
.	O
ri_cprmask	array
[	O
2	int
]	O
=	O
BYTE_GET	O
(	O
ereg	pointer
->	O
ri_cprmask	array
[	O
2	int
]	O
)	O
;	O
reginfo	struct
.	O
ri_cprmask	array
[	O
3	int
]	O
=	O
BYTE_GET	O
(	O
ereg	pointer
->	O
ri_cprmask	array
[	O
3	int
]	O
)	O
;	O
reginfo	struct
.	O
ri_gp_value	long
=	O
BYTE_GET	O
(	O
ereg	pointer
->	O
ri_gp_value	long
)	O
;	O
printf	function
(	O
"GPR %08lx  GP 0x"	pointer
,	O
reginfo	struct
.	O
ri_gprmask	long
)	O
;	O
printf_vma	O
(	O
reginfo	struct
.	O
ri_gp_value	long
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
"            CPR0 %08lx  CPR1 %08lx  CPR2 %08lx  CPR3 %08lx\n"	pointer
,	O
reginfo	struct
.	O
ri_cprmask	array
[	O
0	int
]	O
,	O
reginfo	struct
.	O
ri_cprmask	array
[	O
1	int
]	O
,	O
reginfo	struct
.	O
ri_cprmask	array
[	O
2	int
]	O
,	O
reginfo	struct
.	O
ri_cprmask	array
[	O
3	int
]	O
)	O
;	O
}	O
++	O
option	struct
;	O
continue	O
;	O
case	O
ODK_EXCEPTIONS	int
:	O
fputs	function
(	O
" EXCEPTIONS fpe_min("	pointer
,	O
stdout	pointer
)	O
;	O
process_mips_fpe_exception	function
(	O
option	struct
->	O
info	pointer
&	O
OEX_FPU_MIN	int
)	O
;	O
fputs	function
(	O
") fpe_max("	pointer
,	O
stdout	pointer
)	O
;	O
process_mips_fpe_exception	function
(	O
(	O
option	struct
->	O
info	pointer
&	O
OEX_FPU_MAX	int
)	O
>>	O
8	int
)	O
;	O
fputs	function
(	O
")"	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
option	struct
->	O
info	pointer
&	O
OEX_PAGE0	int
)	O
fputs	function
(	O
" PAGE0"	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
option	struct
->	O
info	pointer
&	O
OEX_SMM	int
)	O
fputs	function
(	O
" SMM"	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
option	struct
->	O
info	pointer
&	O
OEX_FPDBUG	int
)	O
fputs	function
(	O
" FPDBUG"	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
option	struct
->	O
info	pointer
&	O
OEX_DISMISS	int
)	O
fputs	function
(	O
" DISMISS"	pointer
,	O
stdout	pointer
)	O
;	O
break	O
;	O
case	O
ODK_PAD	int
:	O
fputs	function
(	O
" PAD       "	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
option	struct
->	O
info	pointer
&	O
OPAD_PREFIX	int
)	O
fputs	function
(	O
" PREFIX"	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
option	struct
->	O
info	pointer
&	O
OPAD_POSTFIX	int
)	O
fputs	function
(	O
" POSTFIX"	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
option	struct
->	O
info	pointer
&	O
OPAD_SYMBOL	int
)	O
fputs	function
(	O
" SYMBOL"	pointer
,	O
stdout	pointer
)	O
;	O
break	O
;	O
case	O
ODK_HWPATCH	int
:	O
fputs	function
(	O
" HWPATCH   "	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
option	struct
->	O
info	pointer
&	O
OHW_R4KEOP	int
)	O
fputs	function
(	O
" R4KEOP"	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
option	struct
->	O
info	pointer
&	O
OHW_R8KPFETCH	int
)	O
fputs	function
(	O
" R8KPFETCH"	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
option	struct
->	O
info	pointer
&	O
OHW_R5KEOP	int
)	O
fputs	function
(	O
" R5KEOP"	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
option	struct
->	O
info	pointer
&	O
OHW_R5KCVTL	int
)	O
fputs	function
(	O
" R5KCVTL"	pointer
,	O
stdout	pointer
)	O
;	O
break	O
;	O
case	O
ODK_FILL	int
:	O
fputs	function
(	O
" FILL       "	pointer
,	O
stdout	pointer
)	O
;	O
break	O
;	O
case	O
ODK_TAGS	int
:	O
fputs	function
(	O
" TAGS       "	pointer
,	O
stdout	pointer
)	O
;	O
break	O
;	O
case	O
ODK_HWAND	int
:	O
fputs	function
(	O
" HWAND     "	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
option	struct
->	O
info	pointer
&	O
OHWA0_R4KEOP_CHECKED	int
)	O
fputs	function
(	O
" R4KEOP_CHECKED"	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
option	struct
->	O
info	pointer
&	O
OHWA0_R4KEOP_CLEAN	int
)	O
fputs	function
(	O
" R4KEOP_CLEAN"	pointer
,	O
stdout	pointer
)	O
;	O
break	O
;	O
case	O
ODK_HWOR	int
:	O
fputs	function
(	O
" HWOR      "	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
option	struct
->	O
info	pointer
&	O
OHWA0_R4KEOP_CHECKED	int
)	O
fputs	function
(	O
" R4KEOP_CHECKED"	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
option	struct
->	O
info	pointer
&	O
OHWA0_R4KEOP_CLEAN	int
)	O
fputs	function
(	O
" R4KEOP_CLEAN"	pointer
,	O
stdout	pointer
)	O
;	O
break	O
;	O
case	O
ODK_GP_GROUP	int
:	O
printf	function
(	O
" GP_GROUP  %#06lx  self-contained %#06lx"	pointer
,	O
option	struct
->	O
info	pointer
&	O
OGP_GROUP	int
,	O
(	O
option	struct
->	O
info	pointer
&	O
OGP_SELF	int
)	O
>>	O
16	int
)	O
;	O
break	O
;	O
case	O
ODK_IDENT	int
:	O
printf	function
(	O
" IDENT     %#06lx  self-contained %#06lx"	pointer
,	O
option	struct
->	O
info	pointer
&	O
OGP_GROUP	int
,	O
(	O
option	struct
->	O
info	pointer
&	O
OGP_SELF	int
)	O
>>	O
16	int
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
" %3d ???     %d %lx"	pointer
,	O
option	struct
->	O
kind	array
,	O
option	struct
->	O
section	pointer
,	O
option	struct
->	O
info	pointer
)	O
;	O
break	O
;	O
}	O
len	int
=	O
sizeof	O
(	O
*	O
eopt	pointer
)	O
;	O
while	O
(	O
len	int
<	O
option	struct
->	O
size	int
)	O
{	O
unsigned	O
char	O
datum	char
=	O
*	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
eopt	pointer
+	O
offset	long
+	O
len	int
)	O
;	O
if	O
(	O
ISPRINT	O
(	O
datum	char
)	O
)	O
printf	function
(	O
"%c"	pointer
,	O
datum	char
)	O
;	O
else	O
printf	function
(	O
"\\%03o"	pointer
,	O
datum	char
)	O
;	O
len	int
++	O
;	O
}	O
fputs	function
(	O
"\n"	pointer
,	O
stdout	pointer
)	O
;	O
offset	long
+=	O
option	struct
->	O
size	int
;	O
++	O
option	struct
;	O
}	O
free	function
(	O
eopt	pointer
)	O
;	O
}	O
else	O
res	int
=	O
FALSE	int
;	O
}	O
if	O
(	O
conflicts_offset	long
!=	O
0	int
&&	O
conflictsno	long
!=	O
0	int
)	O
{	O
Elf32_Conflict	long
*	O
iconf	pointer
;	O
size_t	long
cnt	int
;	O
if	O
(	O
dynamic_symbols	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"conflict list found without a dynamic symbol table\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
conflictsno	long
*	O
sizeof	O
(	O
*	O
iconf	pointer
)	O
>	O
filedata	struct
->	O
file_size	long
)	O
{	O
error	function
(	O
_	O
(	O
"Overlarge number of conflicts detected: %lx\n"	pointer
)	O
,	O
(	O
long	O
)	O
conflictsno	long
)	O
;	O
return	O
FALSE	int
;	O
}	O
iconf	pointer
=	O
(	O
Elf32_Conflict	long
*	O
)	O
cmalloc	function
(	O
conflictsno	long
,	O
sizeof	O
(	O
*	O
iconf	pointer
)	O
)	O
;	O
if	O
(	O
iconf	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Out of memory allocating space for dynamic conflicts\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
is_32bit_elf	int
)	O
{	O
Elf32_External_Conflict	array
*	O
econf32	pointer
;	O
econf32	pointer
=	O
(	O
Elf32_External_Conflict	array
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
conflicts_offset	long
,	O
conflictsno	long
,	O
sizeof	O
(	O
*	O
econf32	pointer
)	O
,	O
_	O
(	O
"conflict"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
econf32	pointer
)	O
return	O
FALSE	int
;	O
for	O
(	O
cnt	int
=	O
0	int
;	O
cnt	int
<	O
conflictsno	long
;	O
++	O
cnt	int
)	O
iconf	pointer
[	O
cnt	int
]	O
=	O
BYTE_GET	O
(	O
econf32	pointer
[	O
cnt	int
]	O
)	O
;	O
free	function
(	O
econf32	pointer
)	O
;	O
}	O
else	O
{	O
Elf64_External_Conflict	array
*	O
econf64	pointer
;	O
econf64	pointer
=	O
(	O
Elf64_External_Conflict	array
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
conflicts_offset	long
,	O
conflictsno	long
,	O
sizeof	O
(	O
*	O
econf64	pointer
)	O
,	O
_	O
(	O
"conflict"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
econf64	pointer
)	O
return	O
FALSE	int
;	O
for	O
(	O
cnt	int
=	O
0	int
;	O
cnt	int
<	O
conflictsno	long
;	O
++	O
cnt	int
)	O
iconf	pointer
[	O
cnt	int
]	O
=	O
BYTE_GET	O
(	O
econf64	pointer
[	O
cnt	int
]	O
)	O
;	O
free	function
(	O
econf64	pointer
)	O
;	O
}	O
printf	function
(	O
ngettext	function
(	O
"\nSection '.conflict' contains %lu entry:\n"	pointer
,	O
"\nSection '.conflict' contains %lu entries:\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
conflictsno	long
)	O
,	O
(	O
unsigned	O
long	O
)	O
conflictsno	long
)	O
;	O
puts	function
(	O
_	O
(	O
"  Num:    Index       Value  Name"	pointer
)	O
)	O
;	O
for	O
(	O
cnt	int
=	O
0	int
;	O
cnt	int
<	O
conflictsno	long
;	O
++	O
cnt	int
)	O
{	O
printf	function
(	O
"%5lu: %8lu  "	pointer
,	O
(	O
unsigned	O
long	O
)	O
cnt	int
,	O
iconf	pointer
[	O
cnt	int
]	O
)	O
;	O
if	O
(	O
iconf	pointer
[	O
cnt	int
]	O
>=	O
num_dynamic_syms	long
)	O
printf	function
(	O
_	O
(	O
"<corrupt symbol index>"	pointer
)	O
)	O
;	O
else	O
{	O
Elf_Internal_Sym	struct
*	O
psym	pointer
;	O
psym	pointer
=	O
&	O
dynamic_symbols	pointer
[	O
iconf	pointer
[	O
cnt	int
]	O
]	O
;	O
print_vma	function
(	O
psym	pointer
->	O
st_value	int
,	O
FULL_HEX	int
)	O
;	O
putchar	function
(	O
' '	O
)	O
;	O
if	O
(	O
VALID_DYNAMIC_NAME	O
(	O
psym	pointer
->	O
st_name	pointer
)	O
)	O
print_symbol	function
(	O
25	int
,	O
GET_DYNAMIC_NAME	O
(	O
psym	pointer
->	O
st_name	pointer
)	O
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"<corrupt: %14ld>"	pointer
)	O
,	O
psym	pointer
->	O
st_name	pointer
)	O
;	O
}	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
free	function
(	O
iconf	pointer
)	O
;	O
}	O
if	O
(	O
pltgot	long
!=	O
0	int
&&	O
local_gotno	long
!=	O
0	int
)	O
{	O
bfd_vma	long
ent	struct
,	O
local_end	long
,	O
global_end	long
;	O
size_t	long
i	pointer
,	O
offset	long
;	O
unsigned	O
char	O
*	O
data	pointer
;	O
unsigned	O
char	O
*	O
data_end	pointer
;	O
int	O
addr_size	int
;	O
ent	struct
=	O
pltgot	long
;	O
addr_size	int
=	O
(	O
is_32bit_elf	int
?	O
4	int
:	O
8	int
)	O
;	O
local_end	long
=	O
pltgot	long
+	O
local_gotno	long
*	O
addr_size	int
;	O
if	O
(	O
symtabno	long
<	O
gotsym	long
)	O
{	O
error	function
(	O
_	O
(	O
"The GOT symbol offset (%lu) is greater than the symbol table size (%lu)\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
gotsym	long
,	O
(	O
unsigned	O
long	O
)	O
symtabno	long
)	O
;	O
return	O
FALSE	int
;	O
}	O
global_end	long
=	O
local_end	long
+	O
(	O
symtabno	long
-	O
gotsym	long
)	O
*	O
addr_size	int
;	O
if	O
(	O
global_end	long
<	O
local_end	long
)	O
{	O
error	function
(	O
_	O
(	O
"Too many GOT symbols: %lu\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
symtabno	long
)	O
;	O
return	O
FALSE	int
;	O
}	O
offset	long
=	O
offset_from_vma	function
(	O
filedata	struct
,	O
pltgot	long
,	O
global_end	long
-	O
pltgot	long
)	O
;	O
data	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
offset	long
,	O
global_end	long
-	O
pltgot	long
,	O
1	int
,	O
_	O
(	O
"Global Offset Table data"	pointer
)	O
)	O
;	O
data_end	pointer
=	O
data	pointer
+	O
(	O
global_end	long
-	O
pltgot	long
)	O
;	O
printf	function
(	O
_	O
(	O
"\nPrimary GOT:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
" Canonical gp value: "	pointer
)	O
)	O
;	O
print_vma	function
(	O
pltgot	long
+	O
0x7ff0	int
,	O
LONG_HEX	int
)	O
;	O
printf	function
(	O
"\n\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
" Reserved entries:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  %*s %10s %*s Purpose\n"	pointer
)	O
,	O
addr_size	int
*	O
2	int
,	O
_	O
(	O
"Address"	pointer
)	O
,	O
_	O
(	O
"Access"	pointer
)	O
,	O
addr_size	int
*	O
2	int
,	O
_	O
(	O
"Initial"	pointer
)	O
)	O
;	O
ent	struct
=	O
print_mips_got_entry	function
(	O
data	pointer
,	O
pltgot	long
,	O
ent	struct
,	O
data_end	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
" Lazy resolver\n"	pointer
)	O
)	O
;	O
if	O
(	O
ent	struct
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
goto	O
got_print_fail	O
;	O
if	O
(	O
data	pointer
&&	O
data	pointer
+	O
ent	struct
-	O
pltgot	long
+	O
addr_size	int
<=	O
data_end	pointer
&&	O
(	O
byte_get	pointer
(	O
data	pointer
+	O
ent	struct
-	O
pltgot	long
,	O
addr_size	int
)	O
>>	O
(	O
addr_size	int
*	O
8	int
-	O
1	int
)	O
)	O
!=	O
0	int
)	O
{	O
ent	struct
=	O
print_mips_got_entry	function
(	O
data	pointer
,	O
pltgot	long
,	O
ent	struct
,	O
data_end	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
" Module pointer (GNU extension)\n"	pointer
)	O
)	O
;	O
if	O
(	O
ent	struct
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
goto	O
got_print_fail	O
;	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
if	O
(	O
data	pointer
!=	O
NULL	O
&&	O
ent	struct
<	O
local_end	long
)	O
{	O
printf	function
(	O
_	O
(	O
" Local entries:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"  %*s %10s %*s\n"	pointer
,	O
addr_size	int
*	O
2	int
,	O
_	O
(	O
"Address"	pointer
)	O
,	O
_	O
(	O
"Access"	pointer
)	O
,	O
addr_size	int
*	O
2	int
,	O
_	O
(	O
"Initial"	pointer
)	O
)	O
;	O
while	O
(	O
ent	struct
<	O
local_end	long
)	O
{	O
ent	struct
=	O
print_mips_got_entry	function
(	O
data	pointer
,	O
pltgot	long
,	O
ent	struct
,	O
data_end	pointer
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
if	O
(	O
ent	struct
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
goto	O
got_print_fail	O
;	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
if	O
(	O
data	pointer
!=	O
NULL	O
&&	O
gotsym	long
<	O
symtabno	long
)	O
{	O
int	O
sym_width	int
;	O
printf	function
(	O
_	O
(	O
" Global entries:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"  %*s %10s %*s %*s %-7s %3s %s\n"	pointer
,	O
addr_size	int
*	O
2	int
,	O
_	O
(	O
"Address"	pointer
)	O
,	O
_	O
(	O
"Access"	pointer
)	O
,	O
addr_size	int
*	O
2	int
,	O
_	O
(	O
"Initial"	pointer
)	O
,	O
addr_size	int
*	O
2	int
,	O
_	O
(	O
"Sym.Val."	pointer
)	O
,	O
_	O
(	O
"Type"	pointer
)	O
,	O
_	O
(	O
"Ndx"	pointer
)	O
,	O
_	O
(	O
"Name"	pointer
)	O
)	O
;	O
sym_width	int
=	O
(	O
is_32bit_elf	int
?	O
80	int
:	O
160	int
)	O
-	O
28	int
-	O
addr_size	int
*	O
6	int
-	O
1	int
;	O
for	O
(	O
i	pointer
=	O
gotsym	long
;	O
i	pointer
<	O
symtabno	long
;	O
i	pointer
++	O
)	O
{	O
ent	struct
=	O
print_mips_got_entry	function
(	O
data	pointer
,	O
pltgot	long
,	O
ent	struct
,	O
data_end	pointer
)	O
;	O
printf	function
(	O
" "	pointer
)	O
;	O
if	O
(	O
dynamic_symbols	pointer
==	O
NULL	O
)	O
printf	function
(	O
_	O
(	O
"<no dynamic symbols>"	pointer
)	O
)	O
;	O
else	O
if	O
(	O
i	pointer
<	O
num_dynamic_syms	long
)	O
{	O
Elf_Internal_Sym	struct
*	O
psym	pointer
=	O
dynamic_symbols	pointer
+	O
i	pointer
;	O
print_vma	function
(	O
psym	pointer
->	O
st_value	int
,	O
LONG_HEX	int
)	O
;	O
printf	function
(	O
" %-7s %3s "	pointer
,	O
get_symbol_type	function
(	O
filedata	struct
,	O
ELF_ST_TYPE	O
(	O
psym	pointer
->	O
st_info	array
)	O
)	O
,	O
get_symbol_index_type	function
(	O
filedata	struct
,	O
psym	pointer
->	O
st_shndx	int
)	O
)	O
;	O
if	O
(	O
VALID_DYNAMIC_NAME	O
(	O
psym	pointer
->	O
st_name	pointer
)	O
)	O
print_symbol	function
(	O
sym_width	int
,	O
GET_DYNAMIC_NAME	O
(	O
psym	pointer
->	O
st_name	pointer
)	O
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"<corrupt: %14ld>"	pointer
)	O
,	O
psym	pointer
->	O
st_name	pointer
)	O
;	O
}	O
else	O
printf	function
(	O
_	O
(	O
"<symbol index %lu exceeds number of dynamic symbols>"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
i	pointer
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
if	O
(	O
ent	struct
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
break	O
;	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
got_print_fail	O
:	O
if	O
(	O
data	pointer
)	O
free	function
(	O
data	pointer
)	O
;	O
}	O
if	O
(	O
mips_pltgot	long
!=	O
0	int
&&	O
jmprel	long
!=	O
0	int
&&	O
pltrel	long
!=	O
0	int
&&	O
pltrelsz	long
!=	O
0	int
)	O
{	O
bfd_vma	long
ent	struct
,	O
end	pointer
;	O
size_t	long
offset	long
,	O
rel_offset	long
;	O
unsigned	O
long	O
count	int
,	O
i	pointer
;	O
unsigned	O
char	O
*	O
data	pointer
;	O
int	O
addr_size	int
,	O
sym_width	int
;	O
Elf_Internal_Rela	struct
*	O
rels	pointer
;	O
rel_offset	long
=	O
offset_from_vma	function
(	O
filedata	struct
,	O
jmprel	long
,	O
pltrelsz	long
)	O
;	O
if	O
(	O
pltrel	long
==	O
DT_RELA	int
)	O
{	O
if	O
(	O
!	O
slurp_rela_relocs	function
(	O
filedata	struct
,	O
rel_offset	long
,	O
pltrelsz	long
,	O
&	O
rels	pointer
,	O
&	O
count	int
)	O
)	O
return	O
FALSE	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
slurp_rel_relocs	function
(	O
filedata	struct
,	O
rel_offset	long
,	O
pltrelsz	long
,	O
&	O
rels	pointer
,	O
&	O
count	int
)	O
)	O
return	O
FALSE	int
;	O
}	O
ent	struct
=	O
mips_pltgot	long
;	O
addr_size	int
=	O
(	O
is_32bit_elf	int
?	O
4	int
:	O
8	int
)	O
;	O
end	pointer
=	O
mips_pltgot	long
+	O
(	O
2	int
+	O
count	int
)	O
*	O
addr_size	int
;	O
offset	long
=	O
offset_from_vma	function
(	O
filedata	struct
,	O
mips_pltgot	long
,	O
end	pointer
-	O
mips_pltgot	long
)	O
;	O
data	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
offset	long
,	O
end	pointer
-	O
mips_pltgot	long
,	O
1	int
,	O
_	O
(	O
"Procedure Linkage Table data"	pointer
)	O
)	O
;	O
if	O
(	O
data	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
printf	function
(	O
"\nPLT GOT:\n\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
" Reserved entries:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  %*s %*s Purpose\n"	pointer
)	O
,	O
addr_size	int
*	O
2	int
,	O
_	O
(	O
"Address"	pointer
)	O
,	O
addr_size	int
*	O
2	int
,	O
_	O
(	O
"Initial"	pointer
)	O
)	O
;	O
ent	struct
=	O
print_mips_pltgot_entry	function
(	O
data	pointer
,	O
mips_pltgot	long
,	O
ent	struct
)	O
;	O
printf	function
(	O
_	O
(	O
" PLT lazy resolver\n"	pointer
)	O
)	O
;	O
ent	struct
=	O
print_mips_pltgot_entry	function
(	O
data	pointer
,	O
mips_pltgot	long
,	O
ent	struct
)	O
;	O
printf	function
(	O
_	O
(	O
" Module pointer\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
" Entries:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"  %*s %*s %*s %-7s %3s %s\n"	pointer
,	O
addr_size	int
*	O
2	int
,	O
_	O
(	O
"Address"	pointer
)	O
,	O
addr_size	int
*	O
2	int
,	O
_	O
(	O
"Initial"	pointer
)	O
,	O
addr_size	int
*	O
2	int
,	O
_	O
(	O
"Sym.Val."	pointer
)	O
,	O
_	O
(	O
"Type"	pointer
)	O
,	O
_	O
(	O
"Ndx"	pointer
)	O
,	O
_	O
(	O
"Name"	pointer
)	O
)	O
;	O
sym_width	int
=	O
(	O
is_32bit_elf	int
?	O
80	int
:	O
160	int
)	O
-	O
17	int
-	O
addr_size	int
*	O
6	int
-	O
1	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
count	int
;	O
i	pointer
++	O
)	O
{	O
unsigned	O
long	O
idx	int
=	O
get_reloc_symindex	function
(	O
rels	pointer
[	O
i	pointer
]	O
.	O
r_info	array
)	O
;	O
ent	struct
=	O
print_mips_pltgot_entry	function
(	O
data	pointer
,	O
mips_pltgot	long
,	O
ent	struct
)	O
;	O
printf	function
(	O
" "	pointer
)	O
;	O
if	O
(	O
idx	int
>=	O
num_dynamic_syms	long
)	O
printf	function
(	O
_	O
(	O
"<corrupt symbol index: %lu>"	pointer
)	O
,	O
idx	int
)	O
;	O
else	O
{	O
Elf_Internal_Sym	struct
*	O
psym	pointer
=	O
dynamic_symbols	pointer
+	O
idx	int
;	O
print_vma	function
(	O
psym	pointer
->	O
st_value	int
,	O
LONG_HEX	int
)	O
;	O
printf	function
(	O
" %-7s %3s "	pointer
,	O
get_symbol_type	function
(	O
filedata	struct
,	O
ELF_ST_TYPE	O
(	O
psym	pointer
->	O
st_info	array
)	O
)	O
,	O
get_symbol_index_type	function
(	O
filedata	struct
,	O
psym	pointer
->	O
st_shndx	int
)	O
)	O
;	O
if	O
(	O
VALID_DYNAMIC_NAME	O
(	O
psym	pointer
->	O
st_name	pointer
)	O
)	O
print_symbol	function
(	O
sym_width	int
,	O
GET_DYNAMIC_NAME	O
(	O
psym	pointer
->	O
st_name	pointer
)	O
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"<corrupt: %14ld>"	pointer
)	O
,	O
psym	pointer
->	O
st_name	pointer
)	O
;	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
if	O
(	O
data	pointer
)	O
free	function
(	O
data	pointer
)	O
;	O
free	function
(	O
rels	pointer
)	O
;	O
}	O
return	O
res	int
;	O
}	O
static	O
bfd_boolean	int
process_nds32_specific	function
(	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
Elf_Internal_Shdr	struct
*	O
sect	pointer
=	O
NULL	O
;	O
sect	pointer
=	O
find_section	function
(	O
filedata	struct
,	O
".nds32_e_flags"	pointer
)	O
;	O
if	O
(	O
sect	pointer
!=	O
NULL	O
)	O
{	O
unsigned	O
int	O
*	O
flag	int
;	O
printf	function
(	O
"\nNDS32 elf flags section:\n"	pointer
)	O
;	O
flag	int
=	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
sect	pointer
->	O
sh_offset	array
,	O
1	int
,	O
sect	pointer
->	O
sh_size	array
,	O
_	O
(	O
"NDS32 elf flags section"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
flag	int
)	O
return	O
FALSE	int
;	O
switch	O
(	O
(	O
*	O
flag	int
)	O
&	O
0x3	int
)	O
{	O
case	O
0	int
:	O
printf	function
(	O
"(VEC_SIZE):\tNo entry.\n"	pointer
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	function
(	O
"(VEC_SIZE):\t4 bytes\n"	pointer
)	O
;	O
break	O
;	O
case	O
2	int
:	O
printf	function
(	O
"(VEC_SIZE):\t16 bytes\n"	pointer
)	O
;	O
break	O
;	O
case	O
3	int
:	O
printf	function
(	O
"(VEC_SIZE):\treserved\n"	pointer
)	O
;	O
break	O
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
process_gnu_liblist	function
(	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
Elf_Internal_Shdr	struct
*	O
section	pointer
;	O
Elf_Internal_Shdr	struct
*	O
string_sec	pointer
;	O
Elf32_External_Lib	struct
*	O
elib	pointer
;	O
char	O
*	O
strtab	pointer
;	O
size_t	long
strtab_size	long
;	O
size_t	long
cnt	int
;	O
unsigned	O
long	O
num_liblist	long
;	O
unsigned	O
i	pointer
;	O
bfd_boolean	int
res	int
=	O
TRUE	int
;	O
if	O
(	O
!	O
do_arch	int
)	O
return	O
TRUE	int
;	O
for	O
(	O
i	pointer
=	O
0	int
,	O
section	pointer
=	O
filedata	struct
->	O
section_headers	pointer
;	O
i	pointer
<	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
;	O
i	pointer
++	O
,	O
section	pointer
++	O
)	O
{	O
switch	O
(	O
section	pointer
->	O
sh_type	array
)	O
{	O
case	O
SHT_GNU_LIBLIST	int
:	O
if	O
(	O
section	pointer
->	O
sh_link	array
>=	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
)	O
break	O
;	O
elib	pointer
=	O
(	O
Elf32_External_Lib	struct
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
section	pointer
->	O
sh_offset	array
,	O
1	int
,	O
section	pointer
->	O
sh_size	array
,	O
_	O
(	O
"liblist section data"	pointer
)	O
)	O
;	O
if	O
(	O
elib	pointer
==	O
NULL	O
)	O
{	O
res	int
=	O
FALSE	int
;	O
break	O
;	O
}	O
string_sec	pointer
=	O
filedata	struct
->	O
section_headers	pointer
+	O
section	pointer
->	O
sh_link	array
;	O
strtab	pointer
=	O
(	O
char	O
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
string_sec	pointer
->	O
sh_offset	array
,	O
1	int
,	O
string_sec	pointer
->	O
sh_size	array
,	O
_	O
(	O
"liblist string table"	pointer
)	O
)	O
;	O
if	O
(	O
strtab	pointer
==	O
NULL	O
||	O
section	pointer
->	O
sh_entsize	array
!=	O
sizeof	O
(	O
Elf32_External_Lib	struct
)	O
)	O
{	O
free	function
(	O
elib	pointer
)	O
;	O
free	function
(	O
strtab	pointer
)	O
;	O
res	int
=	O
FALSE	int
;	O
break	O
;	O
}	O
strtab_size	long
=	O
string_sec	pointer
->	O
sh_size	array
;	O
num_liblist	long
=	O
section	pointer
->	O
sh_size	array
/	O
sizeof	O
(	O
Elf32_External_Lib	struct
)	O
;	O
printf	function
(	O
ngettext	function
(	O
"\nLibrary list section '%s' contains %lu entries:\n"	pointer
,	O
"\nLibrary list section '%s' contains %lu entries:\n"	pointer
,	O
num_liblist	long
)	O
,	O
printable_section_name	function
(	O
filedata	struct
,	O
section	pointer
)	O
,	O
num_liblist	long
)	O
;	O
puts	function
(	O
_	O
(	O
"     Library              Time Stamp          Checksum   Version Flags"	pointer
)	O
)	O
;	O
for	O
(	O
cnt	int
=	O
0	int
;	O
cnt	int
<	O
section	pointer
->	O
sh_size	array
/	O
sizeof	O
(	O
Elf32_External_Lib	struct
)	O
;	O
++	O
cnt	int
)	O
{	O
Elf32_Lib	struct
liblist	struct
;	O
time_t	long
atime	long
;	O
char	O
timebuf	array
[	O
128	int
]	O
;	O
struct	O
tm	struct
*	O
tmp	pointer
;	O
liblist	struct
.	O
l_name	long
=	O
BYTE_GET	O
(	O
elib	pointer
[	O
cnt	int
]	O
.	O
l_name	long
)	O
;	O
atime	long
=	O
BYTE_GET	O
(	O
elib	pointer
[	O
cnt	int
]	O
.	O
l_time_stamp	long
)	O
;	O
liblist	struct
.	O
l_checksum	long
=	O
BYTE_GET	O
(	O
elib	pointer
[	O
cnt	int
]	O
.	O
l_checksum	long
)	O
;	O
liblist	struct
.	O
l_version	long
=	O
BYTE_GET	O
(	O
elib	pointer
[	O
cnt	int
]	O
.	O
l_version	long
)	O
;	O
liblist	struct
.	O
l_flags	long
=	O
BYTE_GET	O
(	O
elib	pointer
[	O
cnt	int
]	O
.	O
l_flags	long
)	O
;	O
tmp	pointer
=	O
gmtime	function
(	O
&	O
atime	long
)	O
;	O
snprintf	function
(	O
timebuf	array
,	O
sizeof	O
(	O
timebuf	array
)	O
,	O
"%04u-%02u-%02uT%02u:%02u:%02u"	pointer
,	O
tmp	pointer
->	O
tm_year	int
+	O
1900	int
,	O
tmp	pointer
->	O
tm_mon	int
+	O
1	int
,	O
tmp	pointer
->	O
tm_mday	int
,	O
tmp	pointer
->	O
tm_hour	int
,	O
tmp	pointer
->	O
tm_min	int
,	O
tmp	pointer
->	O
tm_sec	int
)	O
;	O
printf	function
(	O
"%3lu: "	pointer
,	O
(	O
unsigned	O
long	O
)	O
cnt	int
)	O
;	O
if	O
(	O
do_wide	int
)	O
printf	function
(	O
"%-20s"	pointer
,	O
liblist	struct
.	O
l_name	long
<	O
strtab_size	long
?	O
strtab	pointer
+	O
liblist	struct
.	O
l_name	long
:	O
_	O
(	O
"<corrupt>"	pointer
)	O
)	O
;	O
else	O
printf	function
(	O
"%-20.20s"	pointer
,	O
liblist	struct
.	O
l_name	long
<	O
strtab_size	long
?	O
strtab	pointer
+	O
liblist	struct
.	O
l_name	long
:	O
_	O
(	O
"<corrupt>"	pointer
)	O
)	O
;	O
printf	function
(	O
" %s %#010lx %-7ld %-7ld\n"	pointer
,	O
timebuf	array
,	O
liblist	struct
.	O
l_checksum	long
,	O
liblist	struct
.	O
l_version	long
,	O
liblist	struct
.	O
l_flags	long
)	O
;	O
}	O
free	function
(	O
elib	pointer
)	O
;	O
free	function
(	O
strtab	pointer
)	O
;	O
}	O
}	O
return	O
res	int
;	O
}	O
static	O
const	O
char	O
*	O
get_note_type	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
e_type	array
)	O
{	O
static	O
char	O
buff	array
[	O
64	int
]	O
;	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_type	array
==	O
ET_CORE	int
)	O
switch	O
(	O
e_type	array
)	O
{	O
case	O
NT_AUXV	int
:	O
return	O
_	O
(	O
"NT_AUXV (auxiliary vector)"	pointer
)	O
;	O
case	O
NT_PRSTATUS	int
:	O
return	O
_	O
(	O
"NT_PRSTATUS (prstatus structure)"	pointer
)	O
;	O
case	O
NT_FPREGSET	int
:	O
return	O
_	O
(	O
"NT_FPREGSET (floating point registers)"	pointer
)	O
;	O
case	O
NT_PRPSINFO	int
:	O
return	O
_	O
(	O
"NT_PRPSINFO (prpsinfo structure)"	pointer
)	O
;	O
case	O
NT_TASKSTRUCT	int
:	O
return	O
_	O
(	O
"NT_TASKSTRUCT (task structure)"	pointer
)	O
;	O
case	O
NT_PRXFPREG	int
:	O
return	O
_	O
(	O
"NT_PRXFPREG (user_xfpregs structure)"	pointer
)	O
;	O
case	O
NT_PPC_VMX	int
:	O
return	O
_	O
(	O
"NT_PPC_VMX (ppc Altivec registers)"	pointer
)	O
;	O
case	O
NT_PPC_VSX	int
:	O
return	O
_	O
(	O
"NT_PPC_VSX (ppc VSX registers)"	pointer
)	O
;	O
case	O
NT_PPC_TAR	int
:	O
return	O
_	O
(	O
"NT_PPC_TAR (ppc TAR register)"	pointer
)	O
;	O
case	O
NT_PPC_PPR	int
:	O
return	O
_	O
(	O
"NT_PPC_PPR (ppc PPR register)"	pointer
)	O
;	O
case	O
NT_PPC_DSCR	int
:	O
return	O
_	O
(	O
"NT_PPC_DSCR (ppc DSCR register)"	pointer
)	O
;	O
case	O
NT_PPC_EBB	int
:	O
return	O
_	O
(	O
"NT_PPC_EBB (ppc EBB registers)"	pointer
)	O
;	O
case	O
NT_PPC_PMU	int
:	O
return	O
_	O
(	O
"NT_PPC_PMU (ppc PMU registers)"	pointer
)	O
;	O
case	O
NT_PPC_TM_CGPR	int
:	O
return	O
_	O
(	O
"NT_PPC_TM_CGPR (ppc checkpointed GPR registers)"	pointer
)	O
;	O
case	O
NT_PPC_TM_CFPR	int
:	O
return	O
_	O
(	O
"NT_PPC_TM_CFPR (ppc checkpointed floating point registers)"	pointer
)	O
;	O
case	O
NT_PPC_TM_CVMX	int
:	O
return	O
_	O
(	O
"NT_PPC_TM_CVMX (ppc checkpointed Altivec registers)"	pointer
)	O
;	O
case	O
NT_PPC_TM_CVSX	int
:	O
return	O
_	O
(	O
"NT_PPC_TM_CVSX (ppc checkpointed VSX registers)"	pointer
)	O
;	O
case	O
NT_PPC_TM_SPR	int
:	O
return	O
_	O
(	O
"NT_PPC_TM_SPR (ppc TM special purpose registers)"	pointer
)	O
;	O
case	O
NT_PPC_TM_CTAR	int
:	O
return	O
_	O
(	O
"NT_PPC_TM_CTAR (ppc checkpointed TAR register)"	pointer
)	O
;	O
case	O
NT_PPC_TM_CPPR	int
:	O
return	O
_	O
(	O
"NT_PPC_TM_CPPR (ppc checkpointed PPR register)"	pointer
)	O
;	O
case	O
NT_PPC_TM_CDSCR	int
:	O
return	O
_	O
(	O
"NT_PPC_TM_CDSCR (ppc checkpointed DSCR register)"	pointer
)	O
;	O
case	O
NT_386_TLS	int
:	O
return	O
_	O
(	O
"NT_386_TLS (x86 TLS information)"	pointer
)	O
;	O
case	O
NT_386_IOPERM	int
:	O
return	O
_	O
(	O
"NT_386_IOPERM (x86 I/O permissions)"	pointer
)	O
;	O
case	O
NT_X86_XSTATE	int
:	O
return	O
_	O
(	O
"NT_X86_XSTATE (x86 XSAVE extended state)"	pointer
)	O
;	O
case	O
NT_S390_HIGH_GPRS	int
:	O
return	O
_	O
(	O
"NT_S390_HIGH_GPRS (s390 upper register halves)"	pointer
)	O
;	O
case	O
NT_S390_TIMER	int
:	O
return	O
_	O
(	O
"NT_S390_TIMER (s390 timer register)"	pointer
)	O
;	O
case	O
NT_S390_TODCMP	int
:	O
return	O
_	O
(	O
"NT_S390_TODCMP (s390 TOD comparator register)"	pointer
)	O
;	O
case	O
NT_S390_TODPREG	int
:	O
return	O
_	O
(	O
"NT_S390_TODPREG (s390 TOD programmable register)"	pointer
)	O
;	O
case	O
NT_S390_CTRS	int
:	O
return	O
_	O
(	O
"NT_S390_CTRS (s390 control registers)"	pointer
)	O
;	O
case	O
NT_S390_PREFIX	int
:	O
return	O
_	O
(	O
"NT_S390_PREFIX (s390 prefix register)"	pointer
)	O
;	O
case	O
NT_S390_LAST_BREAK	int
:	O
return	O
_	O
(	O
"NT_S390_LAST_BREAK (s390 last breaking event address)"	pointer
)	O
;	O
case	O
NT_S390_SYSTEM_CALL	int
:	O
return	O
_	O
(	O
"NT_S390_SYSTEM_CALL (s390 system call restart data)"	pointer
)	O
;	O
case	O
NT_S390_TDB	int
:	O
return	O
_	O
(	O
"NT_S390_TDB (s390 transaction diagnostic block)"	pointer
)	O
;	O
case	O
NT_S390_VXRS_LOW	int
:	O
return	O
_	O
(	O
"NT_S390_VXRS_LOW (s390 vector registers 0-15 upper half)"	pointer
)	O
;	O
case	O
NT_S390_VXRS_HIGH	int
:	O
return	O
_	O
(	O
"NT_S390_VXRS_HIGH (s390 vector registers 16-31)"	pointer
)	O
;	O
case	O
NT_S390_GS_CB	int
:	O
return	O
_	O
(	O
"NT_S390_GS_CB (s390 guarded-storage registers)"	pointer
)	O
;	O
case	O
NT_S390_GS_BC	int
:	O
return	O
_	O
(	O
"NT_S390_GS_BC (s390 guarded-storage broadcast control)"	pointer
)	O
;	O
case	O
NT_ARM_VFP	int
:	O
return	O
_	O
(	O
"NT_ARM_VFP (arm VFP registers)"	pointer
)	O
;	O
case	O
NT_ARM_TLS	int
:	O
return	O
_	O
(	O
"NT_ARM_TLS (AArch TLS registers)"	pointer
)	O
;	O
case	O
NT_ARM_HW_BREAK	int
:	O
return	O
_	O
(	O
"NT_ARM_HW_BREAK (AArch hardware breakpoint registers)"	pointer
)	O
;	O
case	O
NT_ARM_HW_WATCH	int
:	O
return	O
_	O
(	O
"NT_ARM_HW_WATCH (AArch hardware watchpoint registers)"	pointer
)	O
;	O
case	O
NT_PSTATUS	int
:	O
return	O
_	O
(	O
"NT_PSTATUS (pstatus structure)"	pointer
)	O
;	O
case	O
NT_FPREGS	int
:	O
return	O
_	O
(	O
"NT_FPREGS (floating point registers)"	pointer
)	O
;	O
case	O
NT_PSINFO	int
:	O
return	O
_	O
(	O
"NT_PSINFO (psinfo structure)"	pointer
)	O
;	O
case	O
NT_LWPSTATUS	int
:	O
return	O
_	O
(	O
"NT_LWPSTATUS (lwpstatus_t structure)"	pointer
)	O
;	O
case	O
NT_LWPSINFO	int
:	O
return	O
_	O
(	O
"NT_LWPSINFO (lwpsinfo_t structure)"	pointer
)	O
;	O
case	O
NT_WIN32PSTATUS	int
:	O
return	O
_	O
(	O
"NT_WIN32PSTATUS (win32_pstatus structure)"	pointer
)	O
;	O
case	O
NT_SIGINFO	int
:	O
return	O
_	O
(	O
"NT_SIGINFO (siginfo_t data)"	pointer
)	O
;	O
case	O
NT_FILE	int
:	O
return	O
_	O
(	O
"NT_FILE (mapped files)"	pointer
)	O
;	O
default	O
:	O
break	O
;	O
}	O
else	O
switch	O
(	O
e_type	array
)	O
{	O
case	O
NT_VERSION	int
:	O
return	O
_	O
(	O
"NT_VERSION (version)"	pointer
)	O
;	O
case	O
NT_ARCH	int
:	O
return	O
_	O
(	O
"NT_ARCH (architecture)"	pointer
)	O
;	O
case	O
NT_GNU_BUILD_ATTRIBUTE_OPEN	int
:	O
return	O
_	O
(	O
"OPEN"	pointer
)	O
;	O
case	O
NT_GNU_BUILD_ATTRIBUTE_FUNC	int
:	O
return	O
_	O
(	O
"func"	pointer
)	O
;	O
default	O
:	O
break	O
;	O
}	O
snprintf	function
(	O
buff	array
,	O
sizeof	O
(	O
buff	array
)	O
,	O
_	O
(	O
"Unknown note type: (0x%08x)"	pointer
)	O
,	O
e_type	array
)	O
;	O
return	O
buff	array
;	O
}	O
static	O
bfd_boolean	int
print_core_note	function
(	O
Elf_Internal_Note	struct
*	O
pnote	pointer
)	O
{	O
unsigned	O
int	O
addr_size	int
=	O
is_32bit_elf	int
?	O
4	int
:	O
8	int
;	O
bfd_vma	long
count	int
,	O
page_size	long
;	O
unsigned	O
char	O
*	O
descdata	pointer
,	O
*	O
filenames	pointer
,	O
*	O
descend	pointer
;	O
if	O
(	O
pnote	pointer
->	O
type	enum
!=	O
NT_FILE	int
)	O
{	O
if	O
(	O
do_wide	int
)	O
printf	function
(	O
"\n"	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
pnote	pointer
->	O
descsz	array
<	O
2	int
*	O
addr_size	int
)	O
{	O
error	function
(	O
_	O
(	O
"    Malformed note - too short for header\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
descdata	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	pointer
->	O
descdata	pointer
;	O
descend	pointer
=	O
descdata	pointer
+	O
pnote	pointer
->	O
descsz	array
;	O
if	O
(	O
descdata	pointer
[	O
pnote	pointer
->	O
descsz	array
-	O
1	int
]	O
!=	O
'\0'	O
)	O
{	O
error	function
(	O
_	O
(	O
"    Malformed note - does not end with \\0\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
count	int
=	O
byte_get	pointer
(	O
descdata	pointer
,	O
addr_size	int
)	O
;	O
descdata	pointer
+=	O
addr_size	int
;	O
page_size	long
=	O
byte_get	pointer
(	O
descdata	pointer
,	O
addr_size	int
)	O
;	O
descdata	pointer
+=	O
addr_size	int
;	O
if	O
(	O
count	int
>	O
(	O
(	O
bfd_vma	long
)	O
-	O
1	int
-	O
2	int
*	O
addr_size	int
)	O
/	O
(	O
3	int
*	O
addr_size	int
)	O
||	O
pnote	pointer
->	O
descsz	array
<	O
2	int
*	O
addr_size	int
+	O
count	int
*	O
3	int
*	O
addr_size	int
)	O
{	O
error	function
(	O
_	O
(	O
"    Malformed note - too short for supplied file count\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
printf	function
(	O
_	O
(	O
"    Page size: "	pointer
)	O
)	O
;	O
print_vma	function
(	O
page_size	long
,	O
DEC	int
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"    %*s%*s%*s\n"	pointer
)	O
,	O
(	O
int	O
)	O
(	O
2	int
+	O
2	int
*	O
addr_size	int
)	O
,	O
_	O
(	O
"Start"	pointer
)	O
,	O
(	O
int	O
)	O
(	O
4	int
+	O
2	int
*	O
addr_size	int
)	O
,	O
_	O
(	O
"End"	pointer
)	O
,	O
(	O
int	O
)	O
(	O
4	int
+	O
2	int
*	O
addr_size	int
)	O
,	O
_	O
(	O
"Page Offset"	pointer
)	O
)	O
;	O
filenames	pointer
=	O
descdata	pointer
+	O
count	int
*	O
3	int
*	O
addr_size	int
;	O
while	O
(	O
count	int
--	O
>	O
0	int
)	O
{	O
bfd_vma	long
start	pointer
,	O
end	pointer
,	O
file_ofs	long
;	O
if	O
(	O
filenames	pointer
==	O
descend	pointer
)	O
{	O
error	function
(	O
_	O
(	O
"    Malformed note - filenames end too early\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
start	pointer
=	O
byte_get	pointer
(	O
descdata	pointer
,	O
addr_size	int
)	O
;	O
descdata	pointer
+=	O
addr_size	int
;	O
end	pointer
=	O
byte_get	pointer
(	O
descdata	pointer
,	O
addr_size	int
)	O
;	O
descdata	pointer
+=	O
addr_size	int
;	O
file_ofs	long
=	O
byte_get	pointer
(	O
descdata	pointer
,	O
addr_size	int
)	O
;	O
descdata	pointer
+=	O
addr_size	int
;	O
printf	function
(	O
"    "	pointer
)	O
;	O
print_vma	function
(	O
start	pointer
,	O
FULL_HEX	int
)	O
;	O
printf	function
(	O
"  "	pointer
)	O
;	O
print_vma	function
(	O
end	pointer
,	O
FULL_HEX	int
)	O
;	O
printf	function
(	O
"  "	pointer
)	O
;	O
print_vma	function
(	O
file_ofs	long
,	O
FULL_HEX	int
)	O
;	O
printf	function
(	O
"\n        %s\n"	pointer
,	O
filenames	pointer
)	O
;	O
filenames	pointer
+=	O
1	int
+	O
strlen	function
(	O
(	O
char	O
*	O
)	O
filenames	pointer
)	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
const	O
char	O
*	O
get_gnu_elf_note_type	function
(	O
unsigned	O
e_type	array
)	O
{	O
switch	O
(	O
e_type	array
)	O
{	O
case	O
NT_GNU_ABI_TAG	int
:	O
return	O
_	O
(	O
"NT_GNU_ABI_TAG (ABI version tag)"	pointer
)	O
;	O
case	O
NT_GNU_HWCAP	int
:	O
return	O
_	O
(	O
"NT_GNU_HWCAP (DSO-supplied software HWCAP info)"	pointer
)	O
;	O
case	O
NT_GNU_BUILD_ID	int
:	O
return	O
_	O
(	O
"NT_GNU_BUILD_ID (unique build ID bitstring)"	pointer
)	O
;	O
case	O
NT_GNU_GOLD_VERSION	int
:	O
return	O
_	O
(	O
"NT_GNU_GOLD_VERSION (gold version)"	pointer
)	O
;	O
case	O
NT_GNU_PROPERTY_TYPE_0	int
:	O
return	O
_	O
(	O
"NT_GNU_PROPERTY_TYPE_0"	pointer
)	O
;	O
case	O
NT_GNU_BUILD_ATTRIBUTE_OPEN	int
:	O
return	O
_	O
(	O
"NT_GNU_BUILD_ATTRIBUTE_OPEN"	pointer
)	O
;	O
case	O
NT_GNU_BUILD_ATTRIBUTE_FUNC	int
:	O
return	O
_	O
(	O
"NT_GNU_BUILD_ATTRIBUTE_FUNC"	pointer
)	O
;	O
default	O
:	O
{	O
static	O
char	O
buff	array
[	O
64	int
]	O
;	O
snprintf	function
(	O
buff	array
,	O
sizeof	O
(	O
buff	array
)	O
,	O
_	O
(	O
"Unknown note type: (0x%08x)"	pointer
)	O
,	O
e_type	array
)	O
;	O
return	O
buff	array
;	O
}	O
}	O
}	O
static	O
void	O
decode_x86_compat_isa	function
(	O
unsigned	O
int	O
bitmask	int
)	O
{	O
while	O
(	O
bitmask	int
)	O
{	O
unsigned	O
int	O
bit	long
=	O
bitmask	int
&	O
(	O
-	O
bitmask	int
)	O
;	O
bitmask	int
&=	O
~	O
bit	long
;	O
switch	O
(	O
bit	long
)	O
{	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_486	O
:	O
printf	function
(	O
"i486"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_586	O
:	O
printf	function
(	O
"586"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_686	O
:	O
printf	function
(	O
"686"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_SSE	O
:	O
printf	function
(	O
"SSE"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_SSE2	O
:	O
printf	function
(	O
"SSE2"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_SSE3	O
:	O
printf	function
(	O
"SSE3"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_SSSE3	O
:	O
printf	function
(	O
"SSSE3"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_SSE4_1	O
:	O
printf	function
(	O
"SSE4_1"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_SSE4_2	O
:	O
printf	function
(	O
"SSE4_2"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_AVX	O
:	O
printf	function
(	O
"AVX"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_AVX2	O
:	O
printf	function
(	O
"AVX2"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_AVX512F	O
:	O
printf	function
(	O
"AVX512F"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_AVX512CD	O
:	O
printf	function
(	O
"AVX512CD"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_AVX512ER	O
:	O
printf	function
(	O
"AVX512ER"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_AVX512PF	O
:	O
printf	function
(	O
"AVX512PF"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_AVX512VL	O
:	O
printf	function
(	O
"AVX512VL"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_AVX512DQ	O
:	O
printf	function
(	O
"AVX512DQ"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_AVX512BW	O
:	O
printf	function
(	O
"AVX512BW"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
_	O
(	O
"<unknown: %x>"	pointer
)	O
,	O
bit	long
)	O
;	O
break	O
;	O
}	O
if	O
(	O
bitmask	int
)	O
printf	function
(	O
", "	pointer
)	O
;	O
}	O
}	O
static	O
void	O
decode_x86_isa	function
(	O
unsigned	O
int	O
bitmask	int
)	O
{	O
if	O
(	O
!	O
bitmask	int
)	O
{	O
printf	function
(	O
_	O
(	O
"<None>"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
while	O
(	O
bitmask	int
)	O
{	O
unsigned	O
int	O
bit	long
=	O
bitmask	int
&	O
(	O
-	O
bitmask	int
)	O
;	O
bitmask	int
&=	O
~	O
bit	long
;	O
switch	O
(	O
bit	long
)	O
{	O
case	O
GNU_PROPERTY_X86_ISA_1_CMOV	O
:	O
printf	function
(	O
"CMOV"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_SSE	O
:	O
printf	function
(	O
"SSE"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_SSE2	O
:	O
printf	function
(	O
"SSE2"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_SSE3	O
:	O
printf	function
(	O
"SSE3"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_SSSE3	O
:	O
printf	function
(	O
"SSSE3"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_SSE4_1	O
:	O
printf	function
(	O
"SSE4_1"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_SSE4_2	O
:	O
printf	function
(	O
"SSE4_2"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_AVX	O
:	O
printf	function
(	O
"AVX"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_AVX2	O
:	O
printf	function
(	O
"AVX2"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_FMA	O
:	O
printf	function
(	O
"FMA"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_AVX512F	O
:	O
printf	function
(	O
"AVX512F"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_AVX512CD	O
:	O
printf	function
(	O
"AVX512CD"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_AVX512ER	O
:	O
printf	function
(	O
"AVX512ER"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_AVX512PF	O
:	O
printf	function
(	O
"AVX512PF"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_AVX512VL	O
:	O
printf	function
(	O
"AVX512VL"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_AVX512DQ	O
:	O
printf	function
(	O
"AVX512DQ"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_AVX512BW	O
:	O
printf	function
(	O
"AVX512BW"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_AVX512_4FMAPS	O
:	O
printf	function
(	O
"AVX512_4FMAPS"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_AVX512_4VNNIW	O
:	O
printf	function
(	O
"AVX512_4VNNIW"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_AVX512_BITALG	O
:	O
printf	function
(	O
"AVX512_BITALG"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_AVX512_IFMA	O
:	O
printf	function
(	O
"AVX512_IFMA"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_AVX512_VBMI	O
:	O
printf	function
(	O
"AVX512_VBMI"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_AVX512_VBMI2	O
:	O
printf	function
(	O
"AVX512_VBMI2"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_AVX512_VNNI	O
:	O
printf	function
(	O
"AVX512_VNNI"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_AVX512_BF16	O
:	O
printf	function
(	O
"AVX512_BF16"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
_	O
(	O
"<unknown: %x>"	pointer
)	O
,	O
bit	long
)	O
;	O
break	O
;	O
}	O
if	O
(	O
bitmask	int
)	O
printf	function
(	O
", "	pointer
)	O
;	O
}	O
}	O
static	O
void	O
decode_x86_feature_1	function
(	O
unsigned	O
int	O
bitmask	int
)	O
{	O
if	O
(	O
!	O
bitmask	int
)	O
{	O
printf	function
(	O
_	O
(	O
"<None>"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
while	O
(	O
bitmask	int
)	O
{	O
unsigned	O
int	O
bit	long
=	O
bitmask	int
&	O
(	O
-	O
bitmask	int
)	O
;	O
bitmask	int
&=	O
~	O
bit	long
;	O
switch	O
(	O
bit	long
)	O
{	O
case	O
GNU_PROPERTY_X86_FEATURE_1_IBT	O
:	O
printf	function
(	O
"IBT"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_FEATURE_1_SHSTK	O
:	O
printf	function
(	O
"SHSTK"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
_	O
(	O
"<unknown: %x>"	pointer
)	O
,	O
bit	long
)	O
;	O
break	O
;	O
}	O
if	O
(	O
bitmask	int
)	O
printf	function
(	O
", "	pointer
)	O
;	O
}	O
}	O
static	O
void	O
decode_x86_feature_2	function
(	O
unsigned	O
int	O
bitmask	int
)	O
{	O
if	O
(	O
!	O
bitmask	int
)	O
{	O
printf	function
(	O
_	O
(	O
"<None>"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
while	O
(	O
bitmask	int
)	O
{	O
unsigned	O
int	O
bit	long
=	O
bitmask	int
&	O
(	O
-	O
bitmask	int
)	O
;	O
bitmask	int
&=	O
~	O
bit	long
;	O
switch	O
(	O
bit	long
)	O
{	O
case	O
GNU_PROPERTY_X86_FEATURE_2_X86	O
:	O
printf	function
(	O
"x86"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_FEATURE_2_X87	O
:	O
printf	function
(	O
"x87"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_FEATURE_2_MMX	O
:	O
printf	function
(	O
"MMX"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_FEATURE_2_XMM	O
:	O
printf	function
(	O
"XMM"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_FEATURE_2_YMM	O
:	O
printf	function
(	O
"YMM"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_FEATURE_2_ZMM	O
:	O
printf	function
(	O
"ZMM"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_FEATURE_2_FXSR	O
:	O
printf	function
(	O
"FXSR"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_FEATURE_2_XSAVE	O
:	O
printf	function
(	O
"XSAVE"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_FEATURE_2_XSAVEOPT	O
:	O
printf	function
(	O
"XSAVEOPT"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_FEATURE_2_XSAVEC	O
:	O
printf	function
(	O
"XSAVEC"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
_	O
(	O
"<unknown: %x>"	pointer
)	O
,	O
bit	long
)	O
;	O
break	O
;	O
}	O
if	O
(	O
bitmask	int
)	O
printf	function
(	O
", "	pointer
)	O
;	O
}	O
}	O
static	O
void	O
decode_aarch64_feature_1_and	function
(	O
unsigned	O
int	O
bitmask	int
)	O
{	O
while	O
(	O
bitmask	int
)	O
{	O
unsigned	O
int	O
bit	long
=	O
bitmask	int
&	O
(	O
-	O
bitmask	int
)	O
;	O
bitmask	int
&=	O
~	O
bit	long
;	O
switch	O
(	O
bit	long
)	O
{	O
case	O
GNU_PROPERTY_AARCH64_FEATURE_1_BTI	O
:	O
printf	function
(	O
"BTI"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_AARCH64_FEATURE_1_PAC	O
:	O
printf	function
(	O
"PAC"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
_	O
(	O
"<unknown: %x>"	pointer
)	O
,	O
bit	long
)	O
;	O
break	O
;	O
}	O
if	O
(	O
bitmask	int
)	O
printf	function
(	O
", "	pointer
)	O
;	O
}	O
}	O
static	O
void	O
print_gnu_property_note	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
Elf_Internal_Note	struct
*	O
pnote	pointer
)	O
{	O
unsigned	O
char	O
*	O
ptr	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	pointer
->	O
descdata	pointer
;	O
unsigned	O
char	O
*	O
ptr_end	pointer
=	O
ptr	pointer
+	O
pnote	pointer
->	O
descsz	array
;	O
unsigned	O
int	O
size	int
=	O
is_32bit_elf	int
?	O
4	int
:	O
8	int
;	O
printf	function
(	O
_	O
(	O
"      Properties: "	pointer
)	O
)	O
;	O
if	O
(	O
pnote	pointer
->	O
descsz	array
<	O
8	int
||	O
(	O
pnote	pointer
->	O
descsz	array
%	O
size	int
)	O
!=	O
0	int
)	O
{	O
printf	function
(	O
_	O
(	O
"<corrupt GNU_PROPERTY_TYPE, size = %#lx>\n"	pointer
)	O
,	O
pnote	pointer
->	O
descsz	array
)	O
;	O
return	O
;	O
}	O
while	O
(	O
ptr	pointer
<	O
ptr_end	pointer
)	O
{	O
unsigned	O
int	O
j	int
;	O
unsigned	O
int	O
type	enum
;	O
unsigned	O
int	O
datasz	int
;	O
if	O
(	O
(	O
size_t	long
)	O
(	O
ptr_end	pointer
-	O
ptr	pointer
)	O
<	O
8	int
)	O
{	O
printf	function
(	O
_	O
(	O
"<corrupt descsz: %#lx>\n"	pointer
)	O
,	O
pnote	pointer
->	O
descsz	array
)	O
;	O
break	O
;	O
}	O
type	enum
=	O
byte_get	pointer
(	O
ptr	pointer
,	O
4	int
)	O
;	O
datasz	int
=	O
byte_get	pointer
(	O
ptr	pointer
+	O
4	int
,	O
4	int
)	O
;	O
ptr	pointer
+=	O
8	int
;	O
if	O
(	O
datasz	int
>	O
(	O
size_t	long
)	O
(	O
ptr_end	pointer
-	O
ptr	pointer
)	O
)	O
{	O
printf	function
(	O
_	O
(	O
"<corrupt type (%#x) datasz: %#x>\n"	pointer
)	O
,	O
type	enum
,	O
datasz	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
type	enum
>=	O
GNU_PROPERTY_LOPROC	int
&&	O
type	enum
<=	O
GNU_PROPERTY_HIPROC	int
)	O
{	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_X86_64	int
||	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_IAMCU	int
||	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_386	int
)	O
{	O
unsigned	O
int	O
bitmask	int
;	O
if	O
(	O
datasz	int
==	O
4	int
)	O
bitmask	int
=	O
byte_get	pointer
(	O
ptr	pointer
,	O
4	int
)	O
;	O
else	O
bitmask	int
=	O
0	int
;	O
switch	O
(	O
type	enum
)	O
{	O
case	O
GNU_PROPERTY_X86_ISA_1_USED	O
:	O
if	O
(	O
datasz	int
!=	O
4	int
)	O
printf	function
(	O
_	O
(	O
"x86 ISA used: <corrupt length: %#x> "	pointer
)	O
,	O
datasz	int
)	O
;	O
else	O
{	O
printf	function
(	O
"x86 ISA used: "	pointer
)	O
;	O
decode_x86_isa	function
(	O
bitmask	int
)	O
;	O
}	O
goto	O
next	pointer
;	O
case	O
GNU_PROPERTY_X86_ISA_1_NEEDED	O
:	O
if	O
(	O
datasz	int
!=	O
4	int
)	O
printf	function
(	O
_	O
(	O
"x86 ISA needed: <corrupt length: %#x> "	pointer
)	O
,	O
datasz	int
)	O
;	O
else	O
{	O
printf	function
(	O
"x86 ISA needed: "	pointer
)	O
;	O
decode_x86_isa	function
(	O
bitmask	int
)	O
;	O
}	O
goto	O
next	pointer
;	O
case	O
GNU_PROPERTY_X86_FEATURE_1_AND	O
:	O
if	O
(	O
datasz	int
!=	O
4	int
)	O
printf	function
(	O
_	O
(	O
"x86 feature: <corrupt length: %#x> "	pointer
)	O
,	O
datasz	int
)	O
;	O
else	O
{	O
printf	function
(	O
"x86 feature: "	pointer
)	O
;	O
decode_x86_feature_1	function
(	O
bitmask	int
)	O
;	O
}	O
goto	O
next	pointer
;	O
case	O
GNU_PROPERTY_X86_FEATURE_2_USED	O
:	O
if	O
(	O
datasz	int
!=	O
4	int
)	O
printf	function
(	O
_	O
(	O
"x86 feature used: <corrupt length: %#x> "	pointer
)	O
,	O
datasz	int
)	O
;	O
else	O
{	O
printf	function
(	O
"x86 feature used: "	pointer
)	O
;	O
decode_x86_feature_2	function
(	O
bitmask	int
)	O
;	O
}	O
goto	O
next	pointer
;	O
case	O
GNU_PROPERTY_X86_FEATURE_2_NEEDED	O
:	O
if	O
(	O
datasz	int
!=	O
4	int
)	O
printf	function
(	O
_	O
(	O
"x86 feature needed: <corrupt length: %#x> "	pointer
)	O
,	O
datasz	int
)	O
;	O
else	O
{	O
printf	function
(	O
"x86 feature needed: "	pointer
)	O
;	O
decode_x86_feature_2	function
(	O
bitmask	int
)	O
;	O
}	O
goto	O
next	pointer
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_USED	int
:	O
if	O
(	O
datasz	int
!=	O
4	int
)	O
printf	function
(	O
_	O
(	O
"x86 ISA used: <corrupt length: %#x> "	pointer
)	O
,	O
datasz	int
)	O
;	O
else	O
{	O
printf	function
(	O
"x86 ISA used: "	pointer
)	O
;	O
decode_x86_compat_isa	function
(	O
bitmask	int
)	O
;	O
}	O
goto	O
next	pointer
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_NEEDED	int
:	O
if	O
(	O
datasz	int
!=	O
4	int
)	O
printf	function
(	O
_	O
(	O
"x86 ISA needed: <corrupt length: %#x> "	pointer
)	O
,	O
datasz	int
)	O
;	O
else	O
{	O
printf	function
(	O
"x86 ISA needed: "	pointer
)	O
;	O
decode_x86_compat_isa	function
(	O
bitmask	int
)	O
;	O
}	O
goto	O
next	pointer
;	O
default	O
:	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_AARCH64	int
)	O
{	O
if	O
(	O
type	enum
==	O
GNU_PROPERTY_AARCH64_FEATURE_1_AND	int
)	O
{	O
printf	function
(	O
"AArch64 feature: "	pointer
)	O
;	O
if	O
(	O
datasz	int
!=	O
4	int
)	O
printf	function
(	O
_	O
(	O
"<corrupt length: %#x> "	pointer
)	O
,	O
datasz	int
)	O
;	O
else	O
decode_aarch64_feature_1_and	function
(	O
byte_get	pointer
(	O
ptr	pointer
,	O
4	int
)	O
)	O
;	O
goto	O
next	pointer
;	O
}	O
}	O
}	O
else	O
{	O
switch	O
(	O
type	enum
)	O
{	O
case	O
GNU_PROPERTY_STACK_SIZE	int
:	O
printf	function
(	O
_	O
(	O
"stack size: "	pointer
)	O
)	O
;	O
if	O
(	O
datasz	int
!=	O
size	int
)	O
printf	function
(	O
_	O
(	O
"<corrupt length: %#x> "	pointer
)	O
,	O
datasz	int
)	O
;	O
else	O
printf	function
(	O
"%#lx"	pointer
,	O
(	O
unsigned	O
long	O
)	O
byte_get	pointer
(	O
ptr	pointer
,	O
size	int
)	O
)	O
;	O
goto	O
next	pointer
;	O
case	O
GNU_PROPERTY_NO_COPY_ON_PROTECTED	int
:	O
printf	function
(	O
"no copy on protected "	pointer
)	O
;	O
if	O
(	O
datasz	int
)	O
printf	function
(	O
_	O
(	O
"<corrupt length: %#x> "	pointer
)	O
,	O
datasz	int
)	O
;	O
goto	O
next	pointer
;	O
default	O
:	O
break	O
;	O
}	O
}	O
if	O
(	O
type	enum
<	O
GNU_PROPERTY_LOPROC	int
)	O
printf	function
(	O
_	O
(	O
"<unknown type %#x data: "	pointer
)	O
,	O
type	enum
)	O
;	O
else	O
if	O
(	O
type	enum
<	O
GNU_PROPERTY_LOUSER	int
)	O
printf	function
(	O
_	O
(	O
"<procesor-specific type %#x data: "	pointer
)	O
,	O
type	enum
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"<application-specific type %#x data: "	pointer
)	O
,	O
type	enum
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
datasz	int
;	O
++	O
j	int
)	O
printf	function
(	O
"%02x "	pointer
,	O
ptr	pointer
[	O
j	int
]	O
&	O
0xff	int
)	O
;	O
printf	function
(	O
">"	pointer
)	O
;	O
next	pointer
:	O
ptr	pointer
+=	O
(	O
(	O
datasz	int
+	O
(	O
size	int
-	O
1	int
)	O
)	O
&	O
~	O
(	O
size	int
-	O
1	int
)	O
)	O
;	O
if	O
(	O
ptr	pointer
==	O
ptr_end	pointer
)	O
break	O
;	O
if	O
(	O
do_wide	int
)	O
printf	function
(	O
", "	pointer
)	O
;	O
else	O
printf	function
(	O
"\n\t"	pointer
)	O
;	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
print_gnu_note	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
Elf_Internal_Note	struct
*	O
pnote	pointer
)	O
{	O
switch	O
(	O
pnote	pointer
->	O
type	enum
)	O
{	O
case	O
NT_GNU_BUILD_ID	int
:	O
{	O
unsigned	O
long	O
i	pointer
;	O
printf	function
(	O
_	O
(	O
"    Build ID: "	pointer
)	O
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
pnote	pointer
->	O
descsz	array
;	O
++	O
i	pointer
)	O
printf	function
(	O
"%02x"	pointer
,	O
pnote	pointer
->	O
descdata	pointer
[	O
i	pointer
]	O
&	O
0xff	int
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
break	O
;	O
case	O
NT_GNU_ABI_TAG	int
:	O
{	O
unsigned	O
long	O
os	int
,	O
major	long
,	O
minor	long
,	O
subminor	long
;	O
const	O
char	O
*	O
osname	pointer
;	O
if	O
(	O
pnote	pointer
->	O
descsz	array
<	O
16	int
)	O
{	O
printf	function
(	O
_	O
(	O
"    <corrupt GNU_ABI_TAG>\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
os	int
=	O
byte_get	pointer
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	pointer
->	O
descdata	pointer
,	O
4	int
)	O
;	O
major	long
=	O
byte_get	pointer
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	pointer
->	O
descdata	pointer
+	O
4	int
,	O
4	int
)	O
;	O
minor	long
=	O
byte_get	pointer
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	pointer
->	O
descdata	pointer
+	O
8	int
,	O
4	int
)	O
;	O
subminor	long
=	O
byte_get	pointer
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	pointer
->	O
descdata	pointer
+	O
12	int
,	O
4	int
)	O
;	O
switch	O
(	O
os	int
)	O
{	O
case	O
GNU_ABI_TAG_LINUX	int
:	O
osname	pointer
=	O
"Linux"	pointer
;	O
break	O
;	O
case	O
GNU_ABI_TAG_HURD	int
:	O
osname	pointer
=	O
"Hurd"	pointer
;	O
break	O
;	O
case	O
GNU_ABI_TAG_SOLARIS	int
:	O
osname	pointer
=	O
"Solaris"	pointer
;	O
break	O
;	O
case	O
GNU_ABI_TAG_FREEBSD	int
:	O
osname	pointer
=	O
"FreeBSD"	pointer
;	O
break	O
;	O
case	O
GNU_ABI_TAG_NETBSD	int
:	O
osname	pointer
=	O
"NetBSD"	pointer
;	O
break	O
;	O
case	O
GNU_ABI_TAG_SYLLABLE	int
:	O
osname	pointer
=	O
"Syllable"	pointer
;	O
break	O
;	O
case	O
GNU_ABI_TAG_NACL	int
:	O
osname	pointer
=	O
"NaCl"	pointer
;	O
break	O
;	O
default	O
:	O
osname	pointer
=	O
"Unknown"	pointer
;	O
break	O
;	O
}	O
printf	function
(	O
_	O
(	O
"    OS: %s, ABI: %ld.%ld.%ld\n"	pointer
)	O
,	O
osname	pointer
,	O
major	long
,	O
minor	long
,	O
subminor	long
)	O
;	O
}	O
break	O
;	O
case	O
NT_GNU_GOLD_VERSION	int
:	O
{	O
unsigned	O
long	O
i	pointer
;	O
printf	function
(	O
_	O
(	O
"    Version: "	pointer
)	O
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
pnote	pointer
->	O
descsz	array
&&	O
pnote	pointer
->	O
descdata	pointer
[	O
i	pointer
]	O
!=	O
'\0'	O
;	O
++	O
i	pointer
)	O
printf	function
(	O
"%c"	pointer
,	O
pnote	pointer
->	O
descdata	pointer
[	O
i	pointer
]	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
break	O
;	O
case	O
NT_GNU_HWCAP	int
:	O
{	O
unsigned	O
long	O
num_entries	long
,	O
mask	int
;	O
printf	function
(	O
_	O
(	O
"      Hardware Capabilities: "	pointer
)	O
)	O
;	O
if	O
(	O
pnote	pointer
->	O
descsz	array
<	O
8	int
)	O
{	O
error	function
(	O
_	O
(	O
"<corrupt GNU_HWCAP>\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
num_entries	long
=	O
byte_get	pointer
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	pointer
->	O
descdata	pointer
,	O
4	int
)	O
;	O
mask	int
=	O
byte_get	pointer
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	pointer
->	O
descdata	pointer
+	O
4	int
,	O
4	int
)	O
;	O
printf	function
(	O
_	O
(	O
"num entries: %ld, enabled mask: %lx\n"	pointer
)	O
,	O
num_entries	long
,	O
mask	int
)	O
;	O
}	O
break	O
;	O
case	O
NT_GNU_PROPERTY_TYPE_0	int
:	O
print_gnu_property_note	function
(	O
filedata	struct
,	O
pnote	pointer
)	O
;	O
break	O
;	O
default	O
:	O
{	O
unsigned	O
long	O
i	pointer
;	O
printf	function
(	O
_	O
(	O
"    Description data: "	pointer
)	O
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
pnote	pointer
->	O
descsz	array
;	O
++	O
i	pointer
)	O
printf	function
(	O
"%02x "	pointer
,	O
pnote	pointer
->	O
descdata	pointer
[	O
i	pointer
]	O
&	O
0xff	int
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
break	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
const	O
char	O
*	O
get_v850_elf_note_type	function
(	O
enum	O
v850_notes	enum
n_type	enum
)	O
{	O
static	O
char	O
buff	array
[	O
64	int
]	O
;	O
switch	O
(	O
n_type	enum
)	O
{	O
case	O
V850_NOTE_ALIGNMENT	int
:	O
return	O
_	O
(	O
"Alignment of 8-byte objects"	pointer
)	O
;	O
case	O
V850_NOTE_DATA_SIZE	int
:	O
return	O
_	O
(	O
"Sizeof double and long double"	pointer
)	O
;	O
case	O
V850_NOTE_FPU_INFO	int
:	O
return	O
_	O
(	O
"Type of FPU support needed"	pointer
)	O
;	O
case	O
V850_NOTE_SIMD_INFO	int
:	O
return	O
_	O
(	O
"Use of SIMD instructions"	pointer
)	O
;	O
case	O
V850_NOTE_CACHE_INFO	int
:	O
return	O
_	O
(	O
"Use of cache"	pointer
)	O
;	O
case	O
V850_NOTE_MMU_INFO	int
:	O
return	O
_	O
(	O
"Use of MMU"	pointer
)	O
;	O
default	O
:	O
snprintf	function
(	O
buff	array
,	O
sizeof	O
(	O
buff	array
)	O
,	O
_	O
(	O
"Unknown note type: (0x%08x)"	pointer
)	O
,	O
n_type	enum
)	O
;	O
return	O
buff	array
;	O
}	O
}	O
static	O
bfd_boolean	int
print_v850_note	function
(	O
Elf_Internal_Note	struct
*	O
pnote	pointer
)	O
{	O
unsigned	O
int	O
val	array
;	O
if	O
(	O
pnote	pointer
->	O
descsz	array
!=	O
4	int
)	O
return	O
FALSE	int
;	O
val	array
=	O
byte_get	pointer
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	pointer
->	O
descdata	pointer
,	O
pnote	pointer
->	O
descsz	array
)	O
;	O
if	O
(	O
val	array
==	O
0	int
)	O
{	O
printf	function
(	O
_	O
(	O
"not set\n"	pointer
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
switch	O
(	O
pnote	pointer
->	O
type	enum
)	O
{	O
case	O
V850_NOTE_ALIGNMENT	int
:	O
switch	O
(	O
val	array
)	O
{	O
case	O
EF_RH850_DATA_ALIGN4	int
:	O
printf	function
(	O
_	O
(	O
"4-byte\n"	pointer
)	O
)	O
;	O
return	O
TRUE	int
;	O
case	O
EF_RH850_DATA_ALIGN8	int
:	O
printf	function
(	O
_	O
(	O
"8-byte\n"	pointer
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
break	O
;	O
case	O
V850_NOTE_DATA_SIZE	int
:	O
switch	O
(	O
val	array
)	O
{	O
case	O
EF_RH850_DOUBLE32	int
:	O
printf	function
(	O
_	O
(	O
"4-bytes\n"	pointer
)	O
)	O
;	O
return	O
TRUE	int
;	O
case	O
EF_RH850_DOUBLE64	int
:	O
printf	function
(	O
_	O
(	O
"8-bytes\n"	pointer
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
break	O
;	O
case	O
V850_NOTE_FPU_INFO	int
:	O
switch	O
(	O
val	array
)	O
{	O
case	O
EF_RH850_FPU20	int
:	O
printf	function
(	O
_	O
(	O
"FPU-2.0\n"	pointer
)	O
)	O
;	O
return	O
TRUE	int
;	O
case	O
EF_RH850_FPU30	int
:	O
printf	function
(	O
_	O
(	O
"FPU-3.0\n"	pointer
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
break	O
;	O
case	O
V850_NOTE_MMU_INFO	int
:	O
case	O
V850_NOTE_CACHE_INFO	int
:	O
case	O
V850_NOTE_SIMD_INFO	int
:	O
if	O
(	O
val	array
==	O
EF_RH850_SIMD	int
)	O
{	O
printf	function
(	O
_	O
(	O
"yes\n"	pointer
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
printf	function
(	O
_	O
(	O
"unknown value: %x\n"	pointer
)	O
,	O
val	array
)	O
;	O
return	O
FALSE	int
;	O
}	O
static	O
bfd_boolean	int
process_netbsd_elf_note	function
(	O
Elf_Internal_Note	struct
*	O
pnote	pointer
)	O
{	O
unsigned	O
int	O
version	pointer
;	O
switch	O
(	O
pnote	pointer
->	O
type	enum
)	O
{	O
case	O
NT_NETBSD_IDENT	int
:	O
version	pointer
=	O
byte_get	pointer
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	pointer
->	O
descdata	pointer
,	O
sizeof	O
(	O
version	pointer
)	O
)	O
;	O
if	O
(	O
(	O
version	pointer
/	O
10000	int
)	O
%	O
100	int
)	O
printf	function
(	O
"  NetBSD\t\t0x%08lx\tIDENT %u (%u.%u%s%c)\n"	pointer
,	O
pnote	pointer
->	O
descsz	array
,	O
version	pointer
,	O
version	pointer
/	O
100000000	int
,	O
(	O
version	pointer
/	O
1000000	int
)	O
%	O
100	int
,	O
(	O
version	pointer
/	O
10000	int
)	O
%	O
100	int
>	O
26	int
?	O
"Z"	pointer
:	O
""	pointer
,	O
'A'	O
+	O
(	O
version	pointer
/	O
10000	int
)	O
%	O
26	int
)	O
;	O
else	O
printf	function
(	O
"  NetBSD\t\t0x%08lx\tIDENT %u (%u.%u.%u)\n"	pointer
,	O
pnote	pointer
->	O
descsz	array
,	O
version	pointer
,	O
version	pointer
/	O
100000000	int
,	O
(	O
version	pointer
/	O
1000000	int
)	O
%	O
100	int
,	O
(	O
version	pointer
/	O
100	int
)	O
%	O
100	int
)	O
;	O
return	O
TRUE	int
;	O
case	O
NT_NETBSD_MARCH	int
:	O
printf	function
(	O
"  NetBSD\t\t0x%08lx\tMARCH <%s>\n"	pointer
,	O
pnote	pointer
->	O
descsz	array
,	O
pnote	pointer
->	O
descdata	pointer
)	O
;	O
return	O
TRUE	int
;	O
default	O
:	O
printf	function
(	O
"  NetBSD\t0x%08lx\tUnknown note type: (0x%08lx)\n"	pointer
,	O
pnote	pointer
->	O
descsz	array
,	O
pnote	pointer
->	O
type	enum
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_freebsd_elfcore_note_type	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
e_type	array
)	O
{	O
switch	O
(	O
e_type	array
)	O
{	O
case	O
NT_FREEBSD_THRMISC	int
:	O
return	O
_	O
(	O
"NT_THRMISC (thrmisc structure)"	pointer
)	O
;	O
case	O
NT_FREEBSD_PROCSTAT_PROC	int
:	O
return	O
_	O
(	O
"NT_PROCSTAT_PROC (proc data)"	pointer
)	O
;	O
case	O
NT_FREEBSD_PROCSTAT_FILES	int
:	O
return	O
_	O
(	O
"NT_PROCSTAT_FILES (files data)"	pointer
)	O
;	O
case	O
NT_FREEBSD_PROCSTAT_VMMAP	int
:	O
return	O
_	O
(	O
"NT_PROCSTAT_VMMAP (vmmap data)"	pointer
)	O
;	O
case	O
NT_FREEBSD_PROCSTAT_GROUPS	int
:	O
return	O
_	O
(	O
"NT_PROCSTAT_GROUPS (groups data)"	pointer
)	O
;	O
case	O
NT_FREEBSD_PROCSTAT_UMASK	int
:	O
return	O
_	O
(	O
"NT_PROCSTAT_UMASK (umask data)"	pointer
)	O
;	O
case	O
NT_FREEBSD_PROCSTAT_RLIMIT	int
:	O
return	O
_	O
(	O
"NT_PROCSTAT_RLIMIT (rlimit data)"	pointer
)	O
;	O
case	O
NT_FREEBSD_PROCSTAT_OSREL	int
:	O
return	O
_	O
(	O
"NT_PROCSTAT_OSREL (osreldate data)"	pointer
)	O
;	O
case	O
NT_FREEBSD_PROCSTAT_PSSTRINGS	int
:	O
return	O
_	O
(	O
"NT_PROCSTAT_PSSTRINGS (ps_strings data)"	pointer
)	O
;	O
case	O
NT_FREEBSD_PROCSTAT_AUXV	int
:	O
return	O
_	O
(	O
"NT_PROCSTAT_AUXV (auxv data)"	pointer
)	O
;	O
case	O
NT_FREEBSD_PTLWPINFO	int
:	O
return	O
_	O
(	O
"NT_PTLWPINFO (ptrace_lwpinfo structure)"	pointer
)	O
;	O
}	O
return	O
get_note_type	function
(	O
filedata	struct
,	O
e_type	array
)	O
;	O
}	O
static	O
const	O
char	O
*	O
get_netbsd_elfcore_note_type	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
e_type	array
)	O
{	O
static	O
char	O
buff	array
[	O
64	int
]	O
;	O
switch	O
(	O
e_type	array
)	O
{	O
case	O
NT_NETBSDCORE_PROCINFO	int
:	O
return	O
_	O
(	O
"NetBSD procinfo structure"	pointer
)	O
;	O
default	O
:	O
if	O
(	O
e_type	array
<	O
NT_NETBSDCORE_FIRSTMACH	int
)	O
{	O
snprintf	function
(	O
buff	array
,	O
sizeof	O
(	O
buff	array
)	O
,	O
_	O
(	O
"Unknown note type: (0x%08x)"	pointer
)	O
,	O
e_type	array
)	O
;	O
return	O
buff	array
;	O
}	O
break	O
;	O
}	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
case	O
EM_OLD_ALPHA	int
:	O
case	O
EM_ALPHA	int
:	O
case	O
EM_SPARC	int
:	O
case	O
EM_SPARC32PLUS	int
:	O
case	O
EM_SPARCV9	int
:	O
switch	O
(	O
e_type	array
)	O
{	O
case	O
NT_NETBSDCORE_FIRSTMACH	int
+	O
0	int
:	O
return	O
_	O
(	O
"PT_GETREGS (reg structure)"	pointer
)	O
;	O
case	O
NT_NETBSDCORE_FIRSTMACH	int
+	O
2	int
:	O
return	O
_	O
(	O
"PT_GETFPREGS (fpreg structure)"	pointer
)	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
case	O
EM_SH	int
:	O
switch	O
(	O
e_type	array
)	O
{	O
case	O
NT_NETBSDCORE_FIRSTMACH	int
+	O
1	int
:	O
return	O
_	O
(	O
"PT___GETREGS40 (old reg structure)"	pointer
)	O
;	O
case	O
NT_NETBSDCORE_FIRSTMACH	int
+	O
3	int
:	O
return	O
_	O
(	O
"PT_GETREGS (reg structure)"	pointer
)	O
;	O
case	O
NT_NETBSDCORE_FIRSTMACH	int
+	O
5	int
:	O
return	O
_	O
(	O
"PT_GETFPREGS (fpreg structure)"	pointer
)	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
default	O
:	O
switch	O
(	O
e_type	array
)	O
{	O
case	O
NT_NETBSDCORE_FIRSTMACH	int
+	O
1	int
:	O
return	O
_	O
(	O
"PT_GETREGS (reg structure)"	pointer
)	O
;	O
case	O
NT_NETBSDCORE_FIRSTMACH	int
+	O
3	int
:	O
return	O
_	O
(	O
"PT_GETFPREGS (fpreg structure)"	pointer
)	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
snprintf	function
(	O
buff	array
,	O
sizeof	O
(	O
buff	array
)	O
,	O
"PT_FIRSTMACH+%d"	pointer
,	O
e_type	array
-	O
NT_NETBSDCORE_FIRSTMACH	int
)	O
;	O
return	O
buff	array
;	O
}	O
static	O
const	O
char	O
*	O
get_stapsdt_note_type	function
(	O
unsigned	O
e_type	array
)	O
{	O
static	O
char	O
buff	array
[	O
64	int
]	O
;	O
switch	O
(	O
e_type	array
)	O
{	O
case	O
NT_STAPSDT	int
:	O
return	O
_	O
(	O
"NT_STAPSDT (SystemTap probe descriptors)"	pointer
)	O
;	O
default	O
:	O
break	O
;	O
}	O
snprintf	function
(	O
buff	array
,	O
sizeof	O
(	O
buff	array
)	O
,	O
_	O
(	O
"Unknown note type: (0x%08x)"	pointer
)	O
,	O
e_type	array
)	O
;	O
return	O
buff	array
;	O
}	O
static	O
bfd_boolean	int
print_stapsdt_note	function
(	O
Elf_Internal_Note	struct
*	O
pnote	pointer
)	O
{	O
size_t	long
len	int
,	O
maxlen	long
;	O
unsigned	O
long	O
addr_size	int
=	O
is_32bit_elf	int
?	O
4	int
:	O
8	int
;	O
char	O
*	O
data	pointer
=	O
pnote	pointer
->	O
descdata	pointer
;	O
char	O
*	O
data_end	pointer
=	O
pnote	pointer
->	O
descdata	pointer
+	O
pnote	pointer
->	O
descsz	array
;	O
bfd_vma	long
pc	long
,	O
base_addr	long
,	O
semaphore	long
;	O
char	O
*	O
provider	pointer
,	O
*	O
probe	int
,	O
*	O
arg_fmt	pointer
;	O
if	O
(	O
pnote	pointer
->	O
descsz	array
<	O
(	O
addr_size	int
*	O
3	int
)	O
)	O
goto	O
stapdt_note_too_small	O
;	O
pc	long
=	O
byte_get	pointer
(	O
(	O
unsigned	O
char	O
*	O
)	O
data	pointer
,	O
addr_size	int
)	O
;	O
data	pointer
+=	O
addr_size	int
;	O
base_addr	long
=	O
byte_get	pointer
(	O
(	O
unsigned	O
char	O
*	O
)	O
data	pointer
,	O
addr_size	int
)	O
;	O
data	pointer
+=	O
addr_size	int
;	O
semaphore	long
=	O
byte_get	pointer
(	O
(	O
unsigned	O
char	O
*	O
)	O
data	pointer
,	O
addr_size	int
)	O
;	O
data	pointer
+=	O
addr_size	int
;	O
if	O
(	O
data	pointer
>=	O
data_end	pointer
)	O
goto	O
stapdt_note_too_small	O
;	O
maxlen	long
=	O
data_end	pointer
-	O
data	pointer
;	O
len	int
=	O
strnlen	function
(	O
data	pointer
,	O
maxlen	long
)	O
;	O
if	O
(	O
len	int
<	O
maxlen	long
)	O
{	O
provider	pointer
=	O
data	pointer
;	O
data	pointer
+=	O
len	int
+	O
1	int
;	O
}	O
else	O
goto	O
stapdt_note_too_small	O
;	O
if	O
(	O
data	pointer
>=	O
data_end	pointer
)	O
goto	O
stapdt_note_too_small	O
;	O
maxlen	long
=	O
data_end	pointer
-	O
data	pointer
;	O
len	int
=	O
strnlen	function
(	O
data	pointer
,	O
maxlen	long
)	O
;	O
if	O
(	O
len	int
<	O
maxlen	long
)	O
{	O
probe	int
=	O
data	pointer
;	O
data	pointer
+=	O
len	int
+	O
1	int
;	O
}	O
else	O
goto	O
stapdt_note_too_small	O
;	O
if	O
(	O
data	pointer
>=	O
data_end	pointer
)	O
goto	O
stapdt_note_too_small	O
;	O
maxlen	long
=	O
data_end	pointer
-	O
data	pointer
;	O
len	int
=	O
strnlen	function
(	O
data	pointer
,	O
maxlen	long
)	O
;	O
if	O
(	O
len	int
<	O
maxlen	long
)	O
{	O
arg_fmt	pointer
=	O
data	pointer
;	O
data	pointer
+=	O
len	int
+	O
1	int
;	O
}	O
else	O
goto	O
stapdt_note_too_small	O
;	O
printf	function
(	O
_	O
(	O
"    Provider: %s\n"	pointer
)	O
,	O
provider	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"    Name: %s\n"	pointer
)	O
,	O
probe	int
)	O
;	O
printf	function
(	O
_	O
(	O
"    Location: "	pointer
)	O
)	O
;	O
print_vma	function
(	O
pc	long
,	O
FULL_HEX	int
)	O
;	O
printf	function
(	O
_	O
(	O
", Base: "	pointer
)	O
)	O
;	O
print_vma	function
(	O
base_addr	long
,	O
FULL_HEX	int
)	O
;	O
printf	function
(	O
_	O
(	O
", Semaphore: "	pointer
)	O
)	O
;	O
print_vma	function
(	O
semaphore	long
,	O
FULL_HEX	int
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"    Arguments: %s\n"	pointer
)	O
,	O
arg_fmt	pointer
)	O
;	O
return	O
data	pointer
==	O
data_end	pointer
;	O
stapdt_note_too_small	O
:	O
printf	function
(	O
_	O
(	O
"  <corrupt - note is too small>\n"	pointer
)	O
)	O
;	O
error	function
(	O
_	O
(	O
"corrupt stapdt note - the data size is too small\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
static	O
const	O
char	O
*	O
get_ia64_vms_note_type	function
(	O
unsigned	O
e_type	array
)	O
{	O
static	O
char	O
buff	array
[	O
64	int
]	O
;	O
switch	O
(	O
e_type	array
)	O
{	O
case	O
NT_VMS_MHD	int
:	O
return	O
_	O
(	O
"NT_VMS_MHD (module header)"	pointer
)	O
;	O
case	O
NT_VMS_LNM	int
:	O
return	O
_	O
(	O
"NT_VMS_LNM (language name)"	pointer
)	O
;	O
case	O
NT_VMS_SRC	int
:	O
return	O
_	O
(	O
"NT_VMS_SRC (source files)"	pointer
)	O
;	O
case	O
NT_VMS_TITLE	int
:	O
return	O
"NT_VMS_TITLE"	pointer
;	O
case	O
NT_VMS_EIDC	int
:	O
return	O
_	O
(	O
"NT_VMS_EIDC (consistency check)"	pointer
)	O
;	O
case	O
NT_VMS_FPMODE	int
:	O
return	O
_	O
(	O
"NT_VMS_FPMODE (FP mode)"	pointer
)	O
;	O
case	O
NT_VMS_LINKTIME	int
:	O
return	O
"NT_VMS_LINKTIME"	pointer
;	O
case	O
NT_VMS_IMGNAM	int
:	O
return	O
_	O
(	O
"NT_VMS_IMGNAM (image name)"	pointer
)	O
;	O
case	O
NT_VMS_IMGID	int
:	O
return	O
_	O
(	O
"NT_VMS_IMGID (image id)"	pointer
)	O
;	O
case	O
NT_VMS_LINKID	int
:	O
return	O
_	O
(	O
"NT_VMS_LINKID (link id)"	pointer
)	O
;	O
case	O
NT_VMS_IMGBID	int
:	O
return	O
_	O
(	O
"NT_VMS_IMGBID (build id)"	pointer
)	O
;	O
case	O
NT_VMS_GSTNAM	int
:	O
return	O
_	O
(	O
"NT_VMS_GSTNAM (sym table name)"	pointer
)	O
;	O
case	O
NT_VMS_ORIG_DYN	int
:	O
return	O
"NT_VMS_ORIG_DYN"	pointer
;	O
case	O
NT_VMS_PATCHTIME	int
:	O
return	O
"NT_VMS_PATCHTIME"	pointer
;	O
default	O
:	O
snprintf	function
(	O
buff	array
,	O
sizeof	O
(	O
buff	array
)	O
,	O
_	O
(	O
"Unknown note type: (0x%08x)"	pointer
)	O
,	O
e_type	array
)	O
;	O
return	O
buff	array
;	O
}	O
}	O
static	O
bfd_boolean	int
print_ia64_vms_note	function
(	O
Elf_Internal_Note	struct
*	O
pnote	pointer
)	O
{	O
int	O
maxlen	long
=	O
pnote	pointer
->	O
descsz	array
;	O
if	O
(	O
maxlen	long
<	O
2	int
||	O
(	O
unsigned	O
long	O
)	O
maxlen	long
!=	O
pnote	pointer
->	O
descsz	array
)	O
goto	O
desc_size_fail	O
;	O
switch	O
(	O
pnote	pointer
->	O
type	enum
)	O
{	O
case	O
NT_VMS_MHD	int
:	O
if	O
(	O
maxlen	long
<=	O
36	int
)	O
goto	O
desc_size_fail	O
;	O
int	O
l	int
=	O
(	O
int	O
)	O
strnlen	function
(	O
pnote	pointer
->	O
descdata	pointer
+	O
34	int
,	O
maxlen	long
-	O
34	int
)	O
;	O
printf	function
(	O
_	O
(	O
"    Creation date  : %.17s\n"	pointer
)	O
,	O
pnote	pointer
->	O
descdata	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"    Last patch date: %.17s\n"	pointer
)	O
,	O
pnote	pointer
->	O
descdata	pointer
+	O
17	int
)	O
;	O
if	O
(	O
l	int
+	O
34	int
<	O
maxlen	long
)	O
{	O
printf	function
(	O
_	O
(	O
"    Module name    : %s\n"	pointer
)	O
,	O
pnote	pointer
->	O
descdata	pointer
+	O
34	int
)	O
;	O
if	O
(	O
l	int
+	O
35	int
<	O
maxlen	long
)	O
printf	function
(	O
_	O
(	O
"    Module version : %s\n"	pointer
)	O
,	O
pnote	pointer
->	O
descdata	pointer
+	O
34	int
+	O
l	int
+	O
1	int
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"    Module version : <missing>\n"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
printf	function
(	O
_	O
(	O
"    Module name    : <missing>\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"    Module version : <missing>\n"	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
NT_VMS_LNM	int
:	O
printf	function
(	O
_	O
(	O
"   Language: %.*s\n"	pointer
)	O
,	O
maxlen	long
,	O
pnote	pointer
->	O
descdata	pointer
)	O
;	O
break	O
;	O
case	O
NT_VMS_FPMODE	int
:	O
printf	function
(	O
_	O
(	O
"   Floating Point mode: "	pointer
)	O
)	O
;	O
if	O
(	O
maxlen	long
<	O
8	int
)	O
goto	O
desc_size_fail	O
;	O
printf	function
(	O
"0x%016"	pointer
BFD_VMA_FMT	pointer
"x\n"	pointer
,	O
(	O
bfd_vma	long
)	O
byte_get	pointer
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	pointer
->	O
descdata	pointer
,	O
8	int
)	O
)	O
;	O
break	O
;	O
case	O
NT_VMS_LINKTIME	int
:	O
printf	function
(	O
_	O
(	O
"   Link time: "	pointer
)	O
)	O
;	O
if	O
(	O
maxlen	long
<	O
8	int
)	O
goto	O
desc_size_fail	O
;	O
print_vms_time	function
(	O
(	O
bfd_int64_t	long
)	O
byte_get	pointer
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	pointer
->	O
descdata	pointer
,	O
8	int
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
break	O
;	O
case	O
NT_VMS_PATCHTIME	int
:	O
printf	function
(	O
_	O
(	O
"   Patch time: "	pointer
)	O
)	O
;	O
if	O
(	O
maxlen	long
<	O
8	int
)	O
goto	O
desc_size_fail	O
;	O
print_vms_time	function
(	O
(	O
bfd_int64_t	long
)	O
byte_get	pointer
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	pointer
->	O
descdata	pointer
,	O
8	int
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
break	O
;	O
case	O
NT_VMS_ORIG_DYN	int
:	O
if	O
(	O
maxlen	long
<	O
34	int
)	O
goto	O
desc_size_fail	O
;	O
printf	function
(	O
_	O
(	O
"   Major id: %u,  minor id: %u\n"	pointer
)	O
,	O
(	O
unsigned	O
)	O
byte_get	pointer
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	pointer
->	O
descdata	pointer
,	O
4	int
)	O
,	O
(	O
unsigned	O
)	O
byte_get	pointer
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	pointer
->	O
descdata	pointer
+	O
4	int
,	O
4	int
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"   Last modified  : "	pointer
)	O
)	O
;	O
print_vms_time	function
(	O
(	O
bfd_int64_t	long
)	O
byte_get	pointer
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	pointer
->	O
descdata	pointer
+	O
8	int
,	O
8	int
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"\n   Link flags  : "	pointer
)	O
)	O
;	O
printf	function
(	O
"0x%016"	pointer
BFD_VMA_FMT	pointer
"x\n"	pointer
,	O
(	O
bfd_vma	long
)	O
byte_get	pointer
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	pointer
->	O
descdata	pointer
+	O
16	int
,	O
8	int
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"   Header flags: 0x%08x\n"	pointer
)	O
,	O
(	O
unsigned	O
)	O
byte_get	pointer
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	pointer
->	O
descdata	pointer
+	O
24	int
,	O
4	int
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"   Image id    : %.*s\n"	pointer
)	O
,	O
maxlen	long
-	O
32	int
,	O
pnote	pointer
->	O
descdata	pointer
+	O
32	int
)	O
;	O
break	O
;	O
case	O
NT_VMS_IMGNAM	int
:	O
printf	function
(	O
_	O
(	O
"    Image name: %.*s\n"	pointer
)	O
,	O
maxlen	long
,	O
pnote	pointer
->	O
descdata	pointer
)	O
;	O
break	O
;	O
case	O
NT_VMS_GSTNAM	int
:	O
printf	function
(	O
_	O
(	O
"    Global symbol table name: %.*s\n"	pointer
)	O
,	O
maxlen	long
,	O
pnote	pointer
->	O
descdata	pointer
)	O
;	O
break	O
;	O
case	O
NT_VMS_IMGID	int
:	O
printf	function
(	O
_	O
(	O
"    Image id: %.*s\n"	pointer
)	O
,	O
maxlen	long
,	O
pnote	pointer
->	O
descdata	pointer
)	O
;	O
break	O
;	O
case	O
NT_VMS_LINKID	int
:	O
printf	function
(	O
_	O
(	O
"    Linker id: %.*s\n"	pointer
)	O
,	O
maxlen	long
,	O
pnote	pointer
->	O
descdata	pointer
)	O
;	O
break	O
;	O
default	O
:	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
desc_size_fail	O
:	O
printf	function
(	O
_	O
(	O
"  <corrupt - data size is too small>\n"	pointer
)	O
)	O
;	O
error	function
(	O
_	O
(	O
"corrupt IA64 note: data size is too small\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
static	O
Elf_Internal_Sym	struct
*	O
get_symbol_for_build_attribute	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
long	O
offset	long
,	O
bfd_boolean	int
is_open_attr	int
,	O
const	O
char	O
*	O
*	O
pname	pointer
)	O
{	O
static	O
Filedata	struct
*	O
saved_filedata	pointer
=	O
NULL	O
;	O
static	O
char	O
*	O
strtab	pointer
;	O
static	O
unsigned	O
long	O
strtablen	long
;	O
static	O
Elf_Internal_Sym	struct
*	O
symtab	pointer
;	O
static	O
unsigned	O
long	O
nsyms	long
;	O
Elf_Internal_Sym	struct
*	O
saved_sym	pointer
=	O
NULL	O
;	O
Elf_Internal_Sym	struct
*	O
sym	pointer
;	O
if	O
(	O
filedata	struct
->	O
section_headers	pointer
!=	O
NULL	O
&&	O
(	O
saved_filedata	pointer
==	O
NULL	O
||	O
filedata	struct
!=	O
saved_filedata	pointer
)	O
)	O
{	O
Elf_Internal_Shdr	struct
*	O
symsec	pointer
;	O
for	O
(	O
symsec	pointer
=	O
filedata	struct
->	O
section_headers	pointer
;	O
symsec	pointer
<	O
filedata	struct
->	O
section_headers	pointer
+	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
;	O
symsec	pointer
++	O
)	O
{	O
if	O
(	O
symsec	pointer
->	O
sh_type	array
==	O
SHT_SYMTAB	int
)	O
{	O
symtab	pointer
=	O
GET_ELF_SYMBOLS	O
(	O
filedata	struct
,	O
symsec	pointer
,	O
&	O
nsyms	long
)	O
;	O
if	O
(	O
symsec	pointer
->	O
sh_link	array
<	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
)	O
{	O
Elf_Internal_Shdr	struct
*	O
strtab_sec	pointer
=	O
filedata	struct
->	O
section_headers	pointer
+	O
symsec	pointer
->	O
sh_link	array
;	O
strtab	pointer
=	O
(	O
char	O
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
strtab_sec	pointer
->	O
sh_offset	array
,	O
1	int
,	O
strtab_sec	pointer
->	O
sh_size	array
,	O
_	O
(	O
"string table"	pointer
)	O
)	O
;	O
strtablen	long
=	O
strtab	pointer
!=	O
NULL	O
?	O
strtab_sec	pointer
->	O
sh_size	array
:	O
0	int
;	O
}	O
}	O
}	O
saved_filedata	pointer
=	O
filedata	struct
;	O
}	O
if	O
(	O
symtab	pointer
==	O
NULL	O
||	O
strtab	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
for	O
(	O
sym	pointer
=	O
symtab	pointer
;	O
sym	pointer
<	O
symtab	pointer
+	O
nsyms	long
;	O
sym	pointer
++	O
)	O
if	O
(	O
sym	pointer
->	O
st_value	int
==	O
offset	long
)	O
{	O
if	O
(	O
sym	pointer
->	O
st_name	pointer
>=	O
strtablen	long
)	O
continue	O
;	O
if	O
(	O
strtab	pointer
[	O
sym	pointer
->	O
st_name	pointer
]	O
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
strtab	pointer
[	O
sym	pointer
->	O
st_name	pointer
]	O
==	O
'$'	O
&&	O
strtab	pointer
[	O
sym	pointer
->	O
st_name	pointer
+	O
1	int
]	O
!=	O
0	int
&&	O
strtab	pointer
[	O
sym	pointer
->	O
st_name	pointer
+	O
2	int
]	O
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
is_open_attr	int
)	O
{	O
switch	O
(	O
ELF_ST_TYPE	O
(	O
sym	pointer
->	O
st_info	array
)	O
)	O
{	O
case	O
STT_OBJECT	int
:	O
case	O
STT_FILE	int
:	O
saved_sym	pointer
=	O
sym	pointer
;	O
if	O
(	O
sym	pointer
->	O
st_size	long
)	O
{	O
sym	pointer
=	O
symtab	pointer
+	O
nsyms	long
;	O
}	O
continue	O
;	O
case	O
STT_FUNC	int
:	O
continue	O
;	O
default	O
:	O
break	O
;	O
}	O
switch	O
(	O
ELF_ST_BIND	O
(	O
sym	pointer
->	O
st_info	array
)	O
)	O
{	O
case	O
STB_GLOBAL	int
:	O
if	O
(	O
saved_sym	pointer
==	O
NULL	O
||	O
ELF_ST_TYPE	O
(	O
saved_sym	pointer
->	O
st_info	array
)	O
!=	O
STT_OBJECT	int
)	O
saved_sym	pointer
=	O
sym	pointer
;	O
break	O
;	O
case	O
STB_LOCAL	int
:	O
if	O
(	O
saved_sym	pointer
==	O
NULL	O
)	O
saved_sym	pointer
=	O
sym	pointer
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
ELF_ST_TYPE	O
(	O
sym	pointer
->	O
st_info	array
)	O
!=	O
STT_FUNC	int
)	O
continue	O
;	O
saved_sym	pointer
=	O
sym	pointer
;	O
break	O
;	O
}	O
}	O
if	O
(	O
saved_sym	pointer
&&	O
pname	pointer
)	O
*	O
pname	pointer
=	O
strtab	pointer
+	O
saved_sym	pointer
->	O
st_name	pointer
;	O
return	O
saved_sym	pointer
;	O
}	O
static	O
bfd_boolean	int
same_section	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
unsigned	O
long	O
addr1	long
,	O
unsigned	O
long	O
addr2	long
)	O
{	O
Elf_Internal_Shdr	struct
*	O
a1	pointer
;	O
Elf_Internal_Shdr	struct
*	O
a2	pointer
;	O
a1	pointer
=	O
find_section_by_address	function
(	O
filedata	struct
,	O
addr1	long
)	O
;	O
a2	pointer
=	O
find_section_by_address	function
(	O
filedata	struct
,	O
addr2	long
)	O
;	O
return	O
a1	pointer
==	O
a2	pointer
&&	O
a1	pointer
!=	O
NULL	O
;	O
}	O
static	O
bfd_boolean	int
print_gnu_build_attribute_description	function
(	O
Elf_Internal_Note	struct
*	O
pnote	pointer
,	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
static	O
unsigned	O
long	O
global_offset	long
=	O
0	int
;	O
static	O
unsigned	O
long	O
global_end	long
=	O
0	int
;	O
static	O
unsigned	O
long	O
func_offset	long
=	O
0	int
;	O
static	O
unsigned	O
long	O
func_end	long
=	O
0	int
;	O
Elf_Internal_Sym	struct
*	O
sym	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
unsigned	O
long	O
start	pointer
;	O
unsigned	O
long	O
end	pointer
;	O
bfd_boolean	int
is_open_attr	int
=	O
pnote	pointer
->	O
type	enum
==	O
NT_GNU_BUILD_ATTRIBUTE_OPEN	int
;	O
switch	O
(	O
pnote	pointer
->	O
descsz	array
)	O
{	O
case	O
0	int
:	O
if	O
(	O
is_open_attr	int
)	O
{	O
if	O
(	O
global_end	long
>	O
global_offset	long
)	O
printf	function
(	O
_	O
(	O
"    Applies to region from %#lx to %#lx\n"	pointer
)	O
,	O
global_offset	long
,	O
global_end	long
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"    Applies to region from %#lx\n"	pointer
)	O
,	O
global_offset	long
)	O
;	O
}	O
else	O
{	O
if	O
(	O
func_end	long
>	O
func_offset	long
)	O
printf	function
(	O
_	O
(	O
"    Applies to region from %#lx to %#lx\n"	pointer
)	O
,	O
func_offset	long
,	O
func_end	long
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"    Applies to region from %#lx\n"	pointer
)	O
,	O
func_offset	long
)	O
;	O
}	O
return	O
TRUE	int
;	O
case	O
4	int
:	O
start	pointer
=	O
byte_get	pointer
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	pointer
->	O
descdata	pointer
,	O
4	int
)	O
;	O
end	pointer
=	O
0	int
;	O
break	O
;	O
case	O
8	int
:	O
if	O
(	O
is_32bit_elf	int
)	O
{	O
start	pointer
=	O
byte_get	pointer
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	pointer
->	O
descdata	pointer
,	O
4	int
)	O
;	O
end	pointer
=	O
byte_get	pointer
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	pointer
->	O
descdata	pointer
+	O
4	int
,	O
4	int
)	O
;	O
}	O
else	O
{	O
start	pointer
=	O
byte_get	pointer
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	pointer
->	O
descdata	pointer
,	O
8	int
)	O
;	O
end	pointer
=	O
0	int
;	O
}	O
break	O
;	O
case	O
16	int
:	O
start	pointer
=	O
byte_get	pointer
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	pointer
->	O
descdata	pointer
,	O
8	int
)	O
;	O
end	pointer
=	O
byte_get	pointer
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	pointer
->	O
descdata	pointer
+	O
8	int
,	O
8	int
)	O
;	O
break	O
;	O
default	O
:	O
error	function
(	O
_	O
(	O
"    <invalid description size: %lx>\n"	pointer
)	O
,	O
pnote	pointer
->	O
descsz	array
)	O
;	O
printf	function
(	O
_	O
(	O
"    <invalid descsz>"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
name	pointer
=	O
NULL	O
;	O
sym	pointer
=	O
get_symbol_for_build_attribute	function
(	O
filedata	struct
,	O
start	pointer
,	O
is_open_attr	int
,	O
&	O
name	pointer
)	O
;	O
if	O
(	O
sym	pointer
==	O
NULL	O
&&	O
is_open_attr	int
)	O
sym	pointer
=	O
get_symbol_for_build_attribute	function
(	O
filedata	struct
,	O
start	pointer
+	O
2	int
,	O
is_open_attr	int
,	O
&	O
name	pointer
)	O
;	O
if	O
(	O
end	pointer
==	O
0	int
&&	O
sym	pointer
!=	O
NULL	O
&&	O
sym	pointer
->	O
st_size	long
>	O
0	int
)	O
end	pointer
=	O
start	pointer
+	O
sym	pointer
->	O
st_size	long
;	O
if	O
(	O
is_open_attr	int
)	O
{	O
if	O
(	O
global_end	long
>	O
0	int
&&	O
start	pointer
>	O
BFD_ALIGN	O
(	O
global_end	long
,	O
16	int
)	O
&&	O
same_section	function
(	O
filedata	struct
,	O
start	pointer
,	O
global_end	long
)	O
)	O
warn	function
(	O
_	O
(	O
"Gap in build notes detected from %#lx to %#lx\n"	pointer
)	O
,	O
global_end	long
+	O
1	int
,	O
start	pointer
-	O
1	int
)	O
;	O
printf	function
(	O
_	O
(	O
"    Applies to region from %#lx"	pointer
)	O
,	O
start	pointer
)	O
;	O
global_offset	long
=	O
start	pointer
;	O
if	O
(	O
end	pointer
)	O
{	O
printf	function
(	O
_	O
(	O
" to %#lx"	pointer
)	O
,	O
end	pointer
)	O
;	O
global_end	long
=	O
end	pointer
;	O
}	O
}	O
else	O
{	O
printf	function
(	O
_	O
(	O
"    Applies to region from %#lx"	pointer
)	O
,	O
start	pointer
)	O
;	O
func_offset	long
=	O
start	pointer
;	O
if	O
(	O
end	pointer
)	O
{	O
printf	function
(	O
_	O
(	O
" to %#lx"	pointer
)	O
,	O
end	pointer
)	O
;	O
func_end	long
=	O
end	pointer
;	O
}	O
}	O
if	O
(	O
sym	pointer
&&	O
name	pointer
)	O
printf	function
(	O
_	O
(	O
" (%s)"	pointer
)	O
,	O
name	pointer
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
print_gnu_build_attribute_name	function
(	O
Elf_Internal_Note	struct
*	O
pnote	pointer
)	O
{	O
static	O
const	O
char	O
string_expected	array
[	O
2	int
]	O
=	O
{	O
GNU_BUILD_ATTRIBUTE_TYPE_STRING	char
,	O
0	int
}	O
;	O
static	O
const	O
char	O
number_expected	array
[	O
2	int
]	O
=	O
{	O
GNU_BUILD_ATTRIBUTE_TYPE_NUMERIC	char
,	O
0	int
}	O
;	O
static	O
const	O
char	O
bool_expected	array
[	O
3	int
]	O
=	O
{	O
GNU_BUILD_ATTRIBUTE_TYPE_BOOL_TRUE	char
,	O
GNU_BUILD_ATTRIBUTE_TYPE_BOOL_FALSE	char
,	O
0	int
}	O
;	O
char	O
name_type	char
;	O
char	O
name_attribute	char
;	O
const	O
char	O
*	O
expected_types	pointer
;	O
const	O
char	O
*	O
name	pointer
=	O
pnote	pointer
->	O
namedata	pointer
;	O
const	O
char	O
*	O
text	int
;	O
signed	O
int	O
left	int
;	O
if	O
(	O
name	pointer
==	O
NULL	O
||	O
pnote	pointer
->	O
namesz	array
<	O
2	int
)	O
{	O
error	function
(	O
_	O
(	O
"corrupt name field in GNU build attribute note: size = %ld\n"	pointer
)	O
,	O
pnote	pointer
->	O
namesz	array
)	O
;	O
print_symbol	function
(	O
-	O
20	int
,	O
_	O
(	O
"  <corrupt name>"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
do_wide	int
)	O
left	int
=	O
28	int
;	O
else	O
left	int
=	O
20	int
;	O
if	O
(	O
name	pointer
[	O
0	int
]	O
==	O
'G'	O
&&	O
name	pointer
[	O
1	int
]	O
==	O
'A'	O
)	O
{	O
if	O
(	O
pnote	pointer
->	O
namesz	array
<	O
4	int
)	O
{	O
error	function
(	O
_	O
(	O
"corrupt name field in GNU build attribute note: size = %ld\n"	pointer
)	O
,	O
pnote	pointer
->	O
namesz	array
)	O
;	O
print_symbol	function
(	O
-	O
20	int
,	O
_	O
(	O
"  <corrupt name>"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
printf	function
(	O
"GA"	pointer
)	O
;	O
name	pointer
+=	O
2	int
;	O
left	int
-=	O
2	int
;	O
}	O
switch	O
(	O
(	O
name_type	char
=	O
*	O
name	pointer
)	O
)	O
{	O
case	O
GNU_BUILD_ATTRIBUTE_TYPE_NUMERIC	char
:	O
case	O
GNU_BUILD_ATTRIBUTE_TYPE_STRING	char
:	O
case	O
GNU_BUILD_ATTRIBUTE_TYPE_BOOL_TRUE	char
:	O
case	O
GNU_BUILD_ATTRIBUTE_TYPE_BOOL_FALSE	char
:	O
printf	function
(	O
"%c"	pointer
,	O
*	O
name	pointer
)	O
;	O
left	int
--	O
;	O
break	O
;	O
default	O
:	O
error	function
(	O
_	O
(	O
"unrecognised attribute type in name field: %d\n"	pointer
)	O
,	O
name_type	char
)	O
;	O
print_symbol	function
(	O
-	O
20	int
,	O
_	O
(	O
"<unknown name type>"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
++	O
name	pointer
;	O
text	int
=	O
NULL	O
;	O
switch	O
(	O
(	O
name_attribute	char
=	O
*	O
name	pointer
)	O
)	O
{	O
case	O
GNU_BUILD_ATTRIBUTE_VERSION	int
:	O
text	int
=	O
_	O
(	O
"<version>"	pointer
)	O
;	O
expected_types	pointer
=	O
string_expected	array
;	O
++	O
name	pointer
;	O
break	O
;	O
case	O
GNU_BUILD_ATTRIBUTE_STACK_PROT	int
:	O
text	int
=	O
_	O
(	O
"<stack prot>"	pointer
)	O
;	O
expected_types	pointer
=	O
"!+*"	pointer
;	O
++	O
name	pointer
;	O
break	O
;	O
case	O
GNU_BUILD_ATTRIBUTE_RELRO	int
:	O
text	int
=	O
_	O
(	O
"<relro>"	pointer
)	O
;	O
expected_types	pointer
=	O
bool_expected	array
;	O
++	O
name	pointer
;	O
break	O
;	O
case	O
GNU_BUILD_ATTRIBUTE_STACK_SIZE	int
:	O
text	int
=	O
_	O
(	O
"<stack size>"	pointer
)	O
;	O
expected_types	pointer
=	O
number_expected	array
;	O
++	O
name	pointer
;	O
break	O
;	O
case	O
GNU_BUILD_ATTRIBUTE_TOOL	int
:	O
text	int
=	O
_	O
(	O
"<tool>"	pointer
)	O
;	O
expected_types	pointer
=	O
string_expected	array
;	O
++	O
name	pointer
;	O
break	O
;	O
case	O
GNU_BUILD_ATTRIBUTE_ABI	int
:	O
text	int
=	O
_	O
(	O
"<ABI>"	pointer
)	O
;	O
expected_types	pointer
=	O
"$*"	pointer
;	O
++	O
name	pointer
;	O
break	O
;	O
case	O
GNU_BUILD_ATTRIBUTE_PIC	int
:	O
text	int
=	O
_	O
(	O
"<PIC>"	pointer
)	O
;	O
expected_types	pointer
=	O
number_expected	array
;	O
++	O
name	pointer
;	O
break	O
;	O
case	O
GNU_BUILD_ATTRIBUTE_SHORT_ENUM	int
:	O
text	int
=	O
_	O
(	O
"<short enum>"	pointer
)	O
;	O
expected_types	pointer
=	O
bool_expected	array
;	O
++	O
name	pointer
;	O
break	O
;	O
default	O
:	O
if	O
(	O
ISPRINT	O
(	O
*	O
name	pointer
)	O
)	O
{	O
int	O
len	int
=	O
strnlen	function
(	O
name	pointer
,	O
pnote	pointer
->	O
namesz	array
-	O
(	O
name	pointer
-	O
pnote	pointer
->	O
namedata	pointer
)	O
)	O
+	O
1	int
;	O
if	O
(	O
len	int
>	O
left	int
&&	O
!	O
do_wide	int
)	O
len	int
=	O
left	int
;	O
printf	function
(	O
"%.*s:"	pointer
,	O
len	int
,	O
name	pointer
)	O
;	O
left	int
-=	O
len	int
;	O
name	pointer
+=	O
len	int
;	O
}	O
else	O
{	O
static	O
char	O
tmpbuf	array
[	O
128	int
]	O
;	O
error	function
(	O
_	O
(	O
"unrecognised byte in name field: %d\n"	pointer
)	O
,	O
*	O
name	pointer
)	O
;	O
sprintf	function
(	O
tmpbuf	array
,	O
_	O
(	O
"<unknown:_%d>"	pointer
)	O
,	O
*	O
name	pointer
)	O
;	O
text	int
=	O
tmpbuf	array
;	O
name	pointer
++	O
;	O
}	O
expected_types	pointer
=	O
"*$!+"	pointer
;	O
break	O
;	O
}	O
if	O
(	O
text	int
)	O
left	int
-=	O
printf	function
(	O
"%s"	pointer
,	O
text	int
)	O
;	O
if	O
(	O
strchr	function
(	O
expected_types	pointer
,	O
name_type	char
)	O
==	O
NULL	O
)	O
warn	function
(	O
_	O
(	O
"attribute does not have an expected type (%c)\n"	pointer
)	O
,	O
name_type	char
)	O
;	O
if	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
name	pointer
-	O
pnote	pointer
->	O
namedata	pointer
)	O
>	O
pnote	pointer
->	O
namesz	array
)	O
{	O
error	function
(	O
_	O
(	O
"corrupt name field: namesz: %lu but parsing gets to %ld\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
pnote	pointer
->	O
namesz	array
,	O
(	O
long	O
)	O
(	O
name	pointer
-	O
pnote	pointer
->	O
namedata	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
left	int
<	O
1	int
&&	O
!	O
do_wide	int
)	O
return	O
TRUE	int
;	O
switch	O
(	O
name_type	char
)	O
{	O
case	O
GNU_BUILD_ATTRIBUTE_TYPE_NUMERIC	char
:	O
{	O
unsigned	O
int	O
bytes	long
;	O
unsigned	O
long	O
long	O
val	array
=	O
0	int
;	O
unsigned	O
int	O
shift	int
=	O
0	int
;	O
char	O
*	O
decoded	pointer
=	O
NULL	O
;	O
bytes	long
=	O
pnote	pointer
->	O
namesz	array
-	O
(	O
name	pointer
-	O
pnote	pointer
->	O
namedata	pointer
)	O
;	O
if	O
(	O
bytes	long
>	O
0	int
)	O
--	O
bytes	long
;	O
if	O
(	O
bytes	long
>	O
sizeof	O
(	O
val	array
)	O
)	O
{	O
error	function
(	O
_	O
(	O
"corrupt numeric name field: too many bytes in the value: %x\n"	pointer
)	O
,	O
bytes	long
)	O
;	O
bytes	long
=	O
sizeof	O
(	O
val	array
)	O
;	O
}	O
while	O
(	O
bytes	long
--	O
)	O
{	O
unsigned	O
long	O
byte	long
=	O
(	O
*	O
name	pointer
++	O
)	O
&	O
0xff	int
;	O
val	array
|=	O
byte	long
<<	O
shift	int
;	O
shift	int
+=	O
8	int
;	O
}	O
switch	O
(	O
name_attribute	char
)	O
{	O
case	O
GNU_BUILD_ATTRIBUTE_PIC	int
:	O
switch	O
(	O
val	array
)	O
{	O
case	O
0	int
:	O
decoded	pointer
=	O
"static"	pointer
;	O
break	O
;	O
case	O
1	int
:	O
decoded	pointer
=	O
"pic"	pointer
;	O
break	O
;	O
case	O
2	int
:	O
decoded	pointer
=	O
"PIC"	pointer
;	O
break	O
;	O
case	O
3	int
:	O
decoded	pointer
=	O
"pie"	pointer
;	O
break	O
;	O
case	O
4	int
:	O
decoded	pointer
=	O
"PIE"	pointer
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
case	O
GNU_BUILD_ATTRIBUTE_STACK_PROT	int
:	O
switch	O
(	O
val	array
)	O
{	O
case	O
0	int
:	O
decoded	pointer
=	O
"off"	pointer
;	O
break	O
;	O
case	O
1	int
:	O
decoded	pointer
=	O
"on"	pointer
;	O
break	O
;	O
case	O
2	int
:	O
decoded	pointer
=	O
"all"	pointer
;	O
break	O
;	O
case	O
3	int
:	O
decoded	pointer
=	O
"strong"	pointer
;	O
break	O
;	O
case	O
4	int
:	O
decoded	pointer
=	O
"explicit"	pointer
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
decoded	pointer
!=	O
NULL	O
)	O
{	O
print_symbol	function
(	O
-	O
left	int
,	O
decoded	pointer
)	O
;	O
left	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
val	array
==	O
0	int
)	O
{	O
printf	function
(	O
"0x0"	pointer
)	O
;	O
left	int
-=	O
3	int
;	O
}	O
else	O
{	O
if	O
(	O
do_wide	int
)	O
left	int
-=	O
printf	function
(	O
"0x%llx"	pointer
,	O
val	array
)	O
;	O
else	O
left	int
-=	O
printf	function
(	O
"0x%-.*llx"	pointer
,	O
left	int
,	O
val	array
)	O
;	O
}	O
}	O
break	O
;	O
case	O
GNU_BUILD_ATTRIBUTE_TYPE_STRING	char
:	O
left	int
-=	O
print_symbol	function
(	O
-	O
left	int
,	O
name	pointer
)	O
;	O
break	O
;	O
case	O
GNU_BUILD_ATTRIBUTE_TYPE_BOOL_TRUE	char
:	O
left	int
-=	O
print_symbol	function
(	O
-	O
left	int
,	O
"true"	pointer
)	O
;	O
break	O
;	O
case	O
GNU_BUILD_ATTRIBUTE_TYPE_BOOL_FALSE	char
:	O
left	int
-=	O
print_symbol	function
(	O
-	O
left	int
,	O
"false"	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
do_wide	int
&&	O
left	int
>	O
0	int
)	O
printf	function
(	O
"%-*s"	pointer
,	O
left	int
,	O
" "	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
process_note	function
(	O
Elf_Internal_Note	struct
*	O
pnote	pointer
,	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
const	O
char	O
*	O
name	pointer
=	O
pnote	pointer
->	O
namesz	array
?	O
pnote	pointer
->	O
namedata	pointer
:	O
"(NONE)"	pointer
;	O
const	O
char	O
*	O
nt	pointer
;	O
if	O
(	O
pnote	pointer
->	O
namesz	array
==	O
0	int
)	O
nt	pointer
=	O
get_note_type	function
(	O
filedata	struct
,	O
pnote	pointer
->	O
type	enum
)	O
;	O
else	O
if	O
(	O
const_strneq	O
(	O
pnote	pointer
->	O
namedata	pointer
,	O
"GNU"	pointer
)	O
)	O
nt	pointer
=	O
get_gnu_elf_note_type	function
(	O
pnote	pointer
->	O
type	enum
)	O
;	O
else	O
if	O
(	O
const_strneq	O
(	O
pnote	pointer
->	O
namedata	pointer
,	O
"FreeBSD"	pointer
)	O
)	O
nt	pointer
=	O
get_freebsd_elfcore_note_type	function
(	O
filedata	struct
,	O
pnote	pointer
->	O
type	enum
)	O
;	O
else	O
if	O
(	O
const_strneq	O
(	O
pnote	pointer
->	O
namedata	pointer
,	O
"NetBSD-CORE"	pointer
)	O
)	O
nt	pointer
=	O
get_netbsd_elfcore_note_type	function
(	O
filedata	struct
,	O
pnote	pointer
->	O
type	enum
)	O
;	O
else	O
if	O
(	O
const_strneq	O
(	O
pnote	pointer
->	O
namedata	pointer
,	O
"NetBSD"	pointer
)	O
)	O
return	O
process_netbsd_elf_note	function
(	O
pnote	pointer
)	O
;	O
else	O
if	O
(	O
const_strneq	O
(	O
pnote	pointer
->	O
namedata	pointer
,	O
"PaX"	pointer
)	O
)	O
return	O
process_netbsd_elf_note	function
(	O
pnote	pointer
)	O
;	O
else	O
if	O
(	O
strneq	O
(	O
pnote	pointer
->	O
namedata	pointer
,	O
"SPU/"	pointer
,	O
4	int
)	O
)	O
{	O
nt	pointer
=	O
pnote	pointer
->	O
namedata	pointer
+	O
4	int
;	O
name	pointer
=	O
"SPU"	pointer
;	O
}	O
else	O
if	O
(	O
const_strneq	O
(	O
pnote	pointer
->	O
namedata	pointer
,	O
"IPF/VMS"	pointer
)	O
)	O
nt	pointer
=	O
get_ia64_vms_note_type	function
(	O
pnote	pointer
->	O
type	enum
)	O
;	O
else	O
if	O
(	O
const_strneq	O
(	O
pnote	pointer
->	O
namedata	pointer
,	O
"stapsdt"	pointer
)	O
)	O
nt	pointer
=	O
get_stapsdt_note_type	function
(	O
pnote	pointer
->	O
type	enum
)	O
;	O
else	O
nt	pointer
=	O
get_note_type	function
(	O
filedata	struct
,	O
pnote	pointer
->	O
type	enum
)	O
;	O
printf	function
(	O
"  "	pointer
)	O
;	O
if	O
(	O
(	O
(	O
const_strneq	O
(	O
pnote	pointer
->	O
namedata	pointer
,	O
"GA"	pointer
)	O
&&	O
strchr	function
(	O
"*$!+"	pointer
,	O
pnote	pointer
->	O
namedata	pointer
[	O
2	int
]	O
)	O
!=	O
NULL	O
)	O
||	O
strchr	function
(	O
"*$!+"	pointer
,	O
pnote	pointer
->	O
namedata	pointer
[	O
0	int
]	O
)	O
!=	O
NULL	O
)	O
&&	O
(	O
pnote	pointer
->	O
type	enum
==	O
NT_GNU_BUILD_ATTRIBUTE_OPEN	int
||	O
pnote	pointer
->	O
type	enum
==	O
NT_GNU_BUILD_ATTRIBUTE_FUNC	int
)	O
)	O
print_gnu_build_attribute_name	function
(	O
pnote	pointer
)	O
;	O
else	O
print_symbol	function
(	O
-	O
20	int
,	O
name	pointer
)	O
;	O
if	O
(	O
do_wide	int
)	O
printf	function
(	O
" 0x%08lx\t%s\t"	pointer
,	O
pnote	pointer
->	O
descsz	array
,	O
nt	pointer
)	O
;	O
else	O
printf	function
(	O
" 0x%08lx\t%s\n"	pointer
,	O
pnote	pointer
->	O
descsz	array
,	O
nt	pointer
)	O
;	O
if	O
(	O
const_strneq	O
(	O
pnote	pointer
->	O
namedata	pointer
,	O
"IPF/VMS"	pointer
)	O
)	O
return	O
print_ia64_vms_note	function
(	O
pnote	pointer
)	O
;	O
else	O
if	O
(	O
const_strneq	O
(	O
pnote	pointer
->	O
namedata	pointer
,	O
"GNU"	pointer
)	O
)	O
return	O
print_gnu_note	function
(	O
filedata	struct
,	O
pnote	pointer
)	O
;	O
else	O
if	O
(	O
const_strneq	O
(	O
pnote	pointer
->	O
namedata	pointer
,	O
"stapsdt"	pointer
)	O
)	O
return	O
print_stapsdt_note	function
(	O
pnote	pointer
)	O
;	O
else	O
if	O
(	O
const_strneq	O
(	O
pnote	pointer
->	O
namedata	pointer
,	O
"CORE"	pointer
)	O
)	O
return	O
print_core_note	function
(	O
pnote	pointer
)	O
;	O
else	O
if	O
(	O
(	O
(	O
const_strneq	O
(	O
pnote	pointer
->	O
namedata	pointer
,	O
"GA"	pointer
)	O
&&	O
strchr	function
(	O
"*$!+"	pointer
,	O
pnote	pointer
->	O
namedata	pointer
[	O
2	int
]	O
)	O
!=	O
NULL	O
)	O
||	O
strchr	function
(	O
"*$!+"	pointer
,	O
pnote	pointer
->	O
namedata	pointer
[	O
0	int
]	O
)	O
!=	O
NULL	O
)	O
&&	O
(	O
pnote	pointer
->	O
type	enum
==	O
NT_GNU_BUILD_ATTRIBUTE_OPEN	int
||	O
pnote	pointer
->	O
type	enum
==	O
NT_GNU_BUILD_ATTRIBUTE_FUNC	int
)	O
)	O
return	O
print_gnu_build_attribute_description	function
(	O
pnote	pointer
,	O
filedata	struct
)	O
;	O
if	O
(	O
pnote	pointer
->	O
descsz	array
)	O
{	O
unsigned	O
long	O
i	pointer
;	O
printf	function
(	O
_	O
(	O
"   description data: "	pointer
)	O
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
pnote	pointer
->	O
descsz	array
;	O
i	pointer
++	O
)	O
printf	function
(	O
"%02x "	pointer
,	O
pnote	pointer
->	O
descdata	pointer
[	O
i	pointer
]	O
&	O
0xff	int
)	O
;	O
if	O
(	O
!	O
do_wide	int
)	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
if	O
(	O
do_wide	int
)	O
printf	function
(	O
"\n"	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
process_notes_at	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
Elf_Internal_Shdr	struct
*	O
section	pointer
,	O
bfd_vma	long
offset	long
,	O
bfd_vma	long
length	long
,	O
bfd_vma	long
align	long
)	O
{	O
Elf_External_Note	struct
*	O
pnotes	pointer
;	O
Elf_External_Note	struct
*	O
external	pointer
;	O
char	O
*	O
end	pointer
;	O
bfd_boolean	int
res	int
=	O
TRUE	int
;	O
if	O
(	O
length	long
<=	O
0	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
section	pointer
)	O
{	O
pnotes	pointer
=	O
(	O
Elf_External_Note	struct
*	O
)	O
get_section_contents	function
(	O
section	pointer
,	O
filedata	struct
)	O
;	O
if	O
(	O
pnotes	pointer
)	O
{	O
if	O
(	O
!	O
apply_relocations	function
(	O
filedata	struct
,	O
section	pointer
,	O
(	O
unsigned	O
char	O
*	O
)	O
pnotes	pointer
,	O
length	long
,	O
NULL	O
,	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
}	O
}	O
else	O
pnotes	pointer
=	O
(	O
Elf_External_Note	struct
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
offset	long
,	O
1	int
,	O
length	long
,	O
_	O
(	O
"notes"	pointer
)	O
)	O
;	O
if	O
(	O
pnotes	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
external	pointer
=	O
pnotes	pointer
;	O
if	O
(	O
section	pointer
)	O
printf	function
(	O
_	O
(	O
"\nDisplaying notes found in: %s\n"	pointer
)	O
,	O
printable_section_name	function
(	O
filedata	struct
,	O
section	pointer
)	O
)	O
;	O
else	O
printf	function
(	O
_	O
(	O
"\nDisplaying notes found at file offset 0x%08lx with length 0x%08lx:\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
offset	long
,	O
(	O
unsigned	O
long	O
)	O
length	long
)	O
;	O
if	O
(	O
align	long
<	O
4	int
)	O
align	long
=	O
4	int
;	O
else	O
if	O
(	O
align	long
!=	O
4	int
&&	O
align	long
!=	O
8	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Corrupt note: alignment %ld, expecting 4 or 8\n"	pointer
)	O
,	O
(	O
long	O
)	O
align	long
)	O
;	O
free	function
(	O
pnotes	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
printf	function
(	O
_	O
(	O
"  %-20s %-10s\tDescription\n"	pointer
)	O
,	O
_	O
(	O
"Owner"	pointer
)	O
,	O
_	O
(	O
"Data size"	pointer
)	O
)	O
;	O
end	pointer
=	O
(	O
char	O
*	O
)	O
pnotes	pointer
+	O
length	long
;	O
while	O
(	O
(	O
char	O
*	O
)	O
external	pointer
<	O
end	pointer
)	O
{	O
Elf_Internal_Note	struct
inote	struct
;	O
size_t	long
min_notesz	long
;	O
char	O
*	O
next	pointer
;	O
char	O
*	O
temp	pointer
=	O
NULL	O
;	O
size_t	long
data_remaining	long
=	O
end	pointer
-	O
(	O
char	O
*	O
)	O
external	pointer
;	O
if	O
(	O
!	O
is_ia64_vms	function
(	O
filedata	struct
)	O
)	O
{	O
min_notesz	long
=	O
offsetof	O
(	O
Elf_External_Note	struct
,	O
name	pointer
)	O
;	O
if	O
(	O
data_remaining	long
<	O
min_notesz	long
)	O
{	O
warn	function
(	O
ngettext	function
(	O
"Corrupt note: only %ld byte remains, "	pointer
"not enough for a full note\n"	pointer
,	O
"Corrupt note: only %ld bytes remain, "	pointer
"not enough for a full note\n"	pointer
,	O
data_remaining	long
)	O
,	O
(	O
long	O
)	O
data_remaining	long
)	O
;	O
break	O
;	O
}	O
data_remaining	long
-=	O
min_notesz	long
;	O
inote	struct
.	O
type	enum
=	O
BYTE_GET	O
(	O
external	pointer
->	O
type	enum
)	O
;	O
inote	struct
.	O
namesz	array
=	O
BYTE_GET	O
(	O
external	pointer
->	O
namesz	array
)	O
;	O
inote	struct
.	O
namedata	pointer
=	O
external	pointer
->	O
name	pointer
;	O
inote	struct
.	O
descsz	array
=	O
BYTE_GET	O
(	O
external	pointer
->	O
descsz	array
)	O
;	O
inote	struct
.	O
descdata	pointer
=	O
(	O
(	O
char	O
*	O
)	O
external	pointer
+	O
ELF_NOTE_DESC_OFFSET	O
(	O
inote	struct
.	O
namesz	array
,	O
align	long
)	O
)	O
;	O
inote	struct
.	O
descpos	long
=	O
offset	long
+	O
(	O
inote	struct
.	O
descdata	pointer
-	O
(	O
char	O
*	O
)	O
pnotes	pointer
)	O
;	O
next	pointer
=	O
(	O
(	O
char	O
*	O
)	O
external	pointer
+	O
ELF_NOTE_NEXT_OFFSET	O
(	O
inote	struct
.	O
namesz	array
,	O
inote	struct
.	O
descsz	array
,	O
align	long
)	O
)	O
;	O
}	O
else	O
{	O
Elf64_External_VMS_Note	struct
*	O
vms_external	pointer
;	O
min_notesz	long
=	O
offsetof	O
(	O
Elf64_External_VMS_Note	struct
,	O
name	pointer
)	O
;	O
if	O
(	O
data_remaining	long
<	O
min_notesz	long
)	O
{	O
warn	function
(	O
ngettext	function
(	O
"Corrupt note: only %ld byte remains, "	pointer
"not enough for a full note\n"	pointer
,	O
"Corrupt note: only %ld bytes remain, "	pointer
"not enough for a full note\n"	pointer
,	O
data_remaining	long
)	O
,	O
(	O
long	O
)	O
data_remaining	long
)	O
;	O
break	O
;	O
}	O
data_remaining	long
-=	O
min_notesz	long
;	O
vms_external	pointer
=	O
(	O
Elf64_External_VMS_Note	struct
*	O
)	O
external	pointer
;	O
inote	struct
.	O
type	enum
=	O
BYTE_GET	O
(	O
vms_external	pointer
->	O
type	enum
)	O
;	O
inote	struct
.	O
namesz	array
=	O
BYTE_GET	O
(	O
vms_external	pointer
->	O
namesz	array
)	O
;	O
inote	struct
.	O
namedata	pointer
=	O
vms_external	pointer
->	O
name	pointer
;	O
inote	struct
.	O
descsz	array
=	O
BYTE_GET	O
(	O
vms_external	pointer
->	O
descsz	array
)	O
;	O
inote	struct
.	O
descdata	pointer
=	O
inote	struct
.	O
namedata	pointer
+	O
align_power	O
(	O
inote	struct
.	O
namesz	array
,	O
3	int
)	O
;	O
inote	struct
.	O
descpos	long
=	O
offset	long
+	O
(	O
inote	struct
.	O
descdata	pointer
-	O
(	O
char	O
*	O
)	O
pnotes	pointer
)	O
;	O
next	pointer
=	O
inote	struct
.	O
descdata	pointer
+	O
align_power	O
(	O
inote	struct
.	O
descsz	array
,	O
3	int
)	O
;	O
}	O
if	O
(	O
(	O
size_t	long
)	O
(	O
inote	struct
.	O
descdata	pointer
-	O
inote	struct
.	O
namedata	pointer
)	O
<	O
inote	struct
.	O
namesz	array
||	O
(	O
size_t	long
)	O
(	O
inote	struct
.	O
descdata	pointer
-	O
inote	struct
.	O
namedata	pointer
)	O
>	O
data_remaining	long
||	O
(	O
size_t	long
)	O
(	O
next	pointer
-	O
inote	struct
.	O
descdata	pointer
)	O
<	O
inote	struct
.	O
descsz	array
||	O
(	O
(	O
size_t	long
)	O
(	O
next	pointer
-	O
inote	struct
.	O
descdata	pointer
)	O
>	O
data_remaining	long
-	O
(	O
size_t	long
)	O
(	O
inote	struct
.	O
descdata	pointer
-	O
inote	struct
.	O
namedata	pointer
)	O
)	O
)	O
{	O
warn	function
(	O
_	O
(	O
"note with invalid namesz and/or descsz found at offset 0x%lx\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
(	O
(	O
char	O
*	O
)	O
external	pointer
-	O
(	O
char	O
*	O
)	O
pnotes	pointer
)	O
)	O
;	O
warn	function
(	O
_	O
(	O
" type: 0x%lx, namesize: 0x%08lx, descsize: 0x%08lx, alignment: %u\n"	pointer
)	O
,	O
inote	struct
.	O
type	enum
,	O
inote	struct
.	O
namesz	array
,	O
inote	struct
.	O
descsz	array
,	O
(	O
int	O
)	O
align	long
)	O
;	O
break	O
;	O
}	O
external	pointer
=	O
(	O
Elf_External_Note	struct
*	O
)	O
next	pointer
;	O
if	O
(	O
inote	struct
.	O
namesz	array
>	O
0	int
&&	O
inote	struct
.	O
namedata	pointer
[	O
inote	struct
.	O
namesz	array
-	O
1	int
]	O
!=	O
'\0'	O
)	O
{	O
if	O
(	O
(	O
size_t	long
)	O
(	O
inote	struct
.	O
descdata	pointer
-	O
inote	struct
.	O
namedata	pointer
)	O
==	O
inote	struct
.	O
namesz	array
)	O
{	O
temp	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
inote	struct
.	O
namesz	array
+	O
1	int
)	O
;	O
if	O
(	O
temp	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Out of memory allocating space for inote name\n"	pointer
)	O
)	O
;	O
res	int
=	O
FALSE	int
;	O
break	O
;	O
}	O
memcpy	function
(	O
temp	pointer
,	O
inote	struct
.	O
namedata	pointer
,	O
inote	struct
.	O
namesz	array
)	O
;	O
inote	struct
.	O
namedata	pointer
=	O
temp	pointer
;	O
}	O
inote	struct
.	O
namedata	pointer
[	O
inote	struct
.	O
namesz	array
]	O
=	O
0	int
;	O
}	O
if	O
(	O
!	O
process_note	function
(	O
&	O
inote	struct
,	O
filedata	struct
)	O
)	O
res	int
=	O
FALSE	int
;	O
if	O
(	O
temp	pointer
!=	O
NULL	O
)	O
{	O
free	function
(	O
temp	pointer
)	O
;	O
temp	pointer
=	O
NULL	O
;	O
}	O
}	O
free	function
(	O
pnotes	pointer
)	O
;	O
return	O
res	int
;	O
}	O
static	O
bfd_boolean	int
process_corefile_note_segments	function
(	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
Elf_Internal_Phdr	struct
*	O
segment	pointer
;	O
unsigned	O
int	O
i	pointer
;	O
bfd_boolean	int
res	int
=	O
TRUE	int
;	O
if	O
(	O
!	O
get_program_headers	function
(	O
filedata	struct
)	O
)	O
return	O
TRUE	int
;	O
for	O
(	O
i	pointer
=	O
0	int
,	O
segment	pointer
=	O
filedata	struct
->	O
program_headers	pointer
;	O
i	pointer
<	O
filedata	struct
->	O
file_header	struct
.	O
e_phnum	array
;	O
i	pointer
++	O
,	O
segment	pointer
++	O
)	O
{	O
if	O
(	O
segment	pointer
->	O
p_type	array
==	O
PT_NOTE	int
)	O
if	O
(	O
!	O
process_notes_at	function
(	O
filedata	struct
,	O
NULL	O
,	O
(	O
bfd_vma	long
)	O
segment	pointer
->	O
p_offset	array
,	O
(	O
bfd_vma	long
)	O
segment	pointer
->	O
p_filesz	array
,	O
(	O
bfd_vma	long
)	O
segment	pointer
->	O
p_align	array
)	O
)	O
res	int
=	O
FALSE	int
;	O
}	O
return	O
res	int
;	O
}	O
static	O
bfd_boolean	int
process_v850_notes	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
bfd_vma	long
offset	long
,	O
bfd_vma	long
length	long
)	O
{	O
Elf_External_Note	struct
*	O
pnotes	pointer
;	O
Elf_External_Note	struct
*	O
external	pointer
;	O
char	O
*	O
end	pointer
;	O
bfd_boolean	int
res	int
=	O
TRUE	int
;	O
if	O
(	O
length	long
<=	O
0	int
)	O
return	O
FALSE	int
;	O
pnotes	pointer
=	O
(	O
Elf_External_Note	struct
*	O
)	O
get_data	function
(	O
NULL	O
,	O
filedata	struct
,	O
offset	long
,	O
1	int
,	O
length	long
,	O
_	O
(	O
"v850 notes"	pointer
)	O
)	O
;	O
if	O
(	O
pnotes	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
external	pointer
=	O
pnotes	pointer
;	O
end	pointer
=	O
(	O
char	O
*	O
)	O
pnotes	pointer
+	O
length	long
;	O
printf	function
(	O
_	O
(	O
"\nDisplaying contents of Renesas V850 notes section at offset 0x%lx with length 0x%lx:\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
offset	long
,	O
(	O
unsigned	O
long	O
)	O
length	long
)	O
;	O
while	O
(	O
(	O
char	O
*	O
)	O
external	pointer
+	O
sizeof	O
(	O
Elf_External_Note	struct
)	O
<	O
end	pointer
)	O
{	O
Elf_External_Note	struct
*	O
next	pointer
;	O
Elf_Internal_Note	struct
inote	struct
;	O
inote	struct
.	O
type	enum
=	O
BYTE_GET	O
(	O
external	pointer
->	O
type	enum
)	O
;	O
inote	struct
.	O
namesz	array
=	O
BYTE_GET	O
(	O
external	pointer
->	O
namesz	array
)	O
;	O
inote	struct
.	O
namedata	pointer
=	O
external	pointer
->	O
name	pointer
;	O
inote	struct
.	O
descsz	array
=	O
BYTE_GET	O
(	O
external	pointer
->	O
descsz	array
)	O
;	O
inote	struct
.	O
descdata	pointer
=	O
inote	struct
.	O
namedata	pointer
+	O
align_power	O
(	O
inote	struct
.	O
namesz	array
,	O
2	int
)	O
;	O
inote	struct
.	O
descpos	long
=	O
offset	long
+	O
(	O
inote	struct
.	O
descdata	pointer
-	O
(	O
char	O
*	O
)	O
pnotes	pointer
)	O
;	O
if	O
(	O
inote	struct
.	O
descdata	pointer
<	O
(	O
char	O
*	O
)	O
pnotes	pointer
||	O
inote	struct
.	O
descdata	pointer
>=	O
end	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"Corrupt note: name size is too big: %lx\n"	pointer
)	O
,	O
inote	struct
.	O
namesz	array
)	O
;	O
inote	struct
.	O
descdata	pointer
=	O
inote	struct
.	O
namedata	pointer
;	O
inote	struct
.	O
namesz	array
=	O
0	int
;	O
}	O
next	pointer
=	O
(	O
Elf_External_Note	struct
*	O
)	O
(	O
inote	struct
.	O
descdata	pointer
+	O
align_power	O
(	O
inote	struct
.	O
descsz	array
,	O
2	int
)	O
)	O
;	O
if	O
(	O
(	O
(	O
char	O
*	O
)	O
next	pointer
>	O
end	pointer
)	O
||	O
(	O
(	O
char	O
*	O
)	O
next	pointer
<	O
(	O
char	O
*	O
)	O
pnotes	pointer
)	O
)	O
{	O
warn	function
(	O
_	O
(	O
"corrupt descsz found in note at offset 0x%lx\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
(	O
(	O
char	O
*	O
)	O
external	pointer
-	O
(	O
char	O
*	O
)	O
pnotes	pointer
)	O
)	O
;	O
warn	function
(	O
_	O
(	O
" type: 0x%lx, namesize: 0x%lx, descsize: 0x%lx\n"	pointer
)	O
,	O
inote	struct
.	O
type	enum
,	O
inote	struct
.	O
namesz	array
,	O
inote	struct
.	O
descsz	array
)	O
;	O
break	O
;	O
}	O
external	pointer
=	O
next	pointer
;	O
if	O
(	O
inote	struct
.	O
namedata	pointer
+	O
inote	struct
.	O
namesz	array
>	O
end	pointer
||	O
inote	struct
.	O
namedata	pointer
+	O
inote	struct
.	O
namesz	array
<	O
inote	struct
.	O
namedata	pointer
)	O
{	O
warn	function
(	O
_	O
(	O
"corrupt namesz found in note at offset 0x%lx\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
(	O
(	O
char	O
*	O
)	O
external	pointer
-	O
(	O
char	O
*	O
)	O
pnotes	pointer
)	O
)	O
;	O
warn	function
(	O
_	O
(	O
" type: 0x%lx, namesize: 0x%lx, descsize: 0x%lx\n"	pointer
)	O
,	O
inote	struct
.	O
type	enum
,	O
inote	struct
.	O
namesz	array
,	O
inote	struct
.	O
descsz	array
)	O
;	O
break	O
;	O
}	O
printf	function
(	O
"  %s: "	pointer
,	O
get_v850_elf_note_type	function
(	O
inote	struct
.	O
type	enum
)	O
)	O
;	O
if	O
(	O
!	O
print_v850_note	function
(	O
&	O
inote	struct
)	O
)	O
{	O
res	int
=	O
FALSE	int
;	O
printf	function
(	O
"<corrupt sizes: namesz: %lx, descsz: %lx>\n"	pointer
,	O
inote	struct
.	O
namesz	array
,	O
inote	struct
.	O
descsz	array
)	O
;	O
}	O
}	O
free	function
(	O
pnotes	pointer
)	O
;	O
return	O
res	int
;	O
}	O
static	O
bfd_boolean	int
process_note_sections	function
(	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
Elf_Internal_Shdr	struct
*	O
section	pointer
;	O
unsigned	O
long	O
i	pointer
;	O
unsigned	O
int	O
n	long
=	O
0	int
;	O
bfd_boolean	int
res	int
=	O
TRUE	int
;	O
for	O
(	O
i	pointer
=	O
0	int
,	O
section	pointer
=	O
filedata	struct
->	O
section_headers	pointer
;	O
i	pointer
<	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
&&	O
section	pointer
!=	O
NULL	O
;	O
i	pointer
++	O
,	O
section	pointer
++	O
)	O
{	O
if	O
(	O
section	pointer
->	O
sh_type	array
==	O
SHT_NOTE	int
)	O
{	O
if	O
(	O
!	O
process_notes_at	function
(	O
filedata	struct
,	O
section	pointer
,	O
(	O
bfd_vma	long
)	O
section	pointer
->	O
sh_offset	array
,	O
(	O
bfd_vma	long
)	O
section	pointer
->	O
sh_size	array
,	O
(	O
bfd_vma	long
)	O
section	pointer
->	O
sh_addralign	array
)	O
)	O
res	int
=	O
FALSE	int
;	O
n	long
++	O
;	O
}	O
if	O
(	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_V800	int
||	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_V850	int
||	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
==	O
EM_CYGNUS_V850	int
)	O
&&	O
section	pointer
->	O
sh_type	array
==	O
SHT_RENESAS_INFO	int
)	O
{	O
if	O
(	O
!	O
process_v850_notes	function
(	O
filedata	struct
,	O
(	O
bfd_vma	long
)	O
section	pointer
->	O
sh_offset	array
,	O
(	O
bfd_vma	long
)	O
section	pointer
->	O
sh_size	array
)	O
)	O
res	int
=	O
FALSE	int
;	O
n	long
++	O
;	O
}	O
}	O
if	O
(	O
n	long
==	O
0	int
)	O
return	O
process_corefile_note_segments	function
(	O
filedata	struct
)	O
;	O
return	O
res	int
;	O
}	O
static	O
bfd_boolean	int
process_notes	function
(	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
if	O
(	O
!	O
do_notes	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_type	array
!=	O
ET_CORE	int
)	O
return	O
process_note_sections	function
(	O
filedata	struct
)	O
;	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_phnum	array
>	O
0	int
)	O
return	O
process_corefile_note_segments	function
(	O
filedata	struct
)	O
;	O
printf	function
(	O
_	O
(	O
"No note segments present in the core file.\n"	pointer
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
unsigned	O
char	O
*	O
display_public_gnu_attributes	function
(	O
unsigned	O
char	O
*	O
start	pointer
,	O
const	O
unsigned	O
char	O
*	O
const	O
end	pointer
)	O
{	O
printf	function
(	O
_	O
(	O
"  Unknown GNU attribute: %s\n"	pointer
)	O
,	O
start	pointer
)	O
;	O
start	pointer
+=	O
strnlen	function
(	O
(	O
char	O
*	O
)	O
start	pointer
,	O
end	pointer
-	O
start	pointer
)	O
;	O
display_raw_attribute	function
(	O
start	pointer
,	O
end	pointer
)	O
;	O
return	O
(	O
unsigned	O
char	O
*	O
)	O
end	pointer
;	O
}	O
static	O
unsigned	O
char	O
*	O
display_generic_attribute	function
(	O
unsigned	O
char	O
*	O
start	pointer
,	O
unsigned	O
int	O
tag	int
,	O
const	O
unsigned	O
char	O
*	O
const	O
end	pointer
)	O
{	O
if	O
(	O
tag	int
==	O
0	int
)	O
return	O
(	O
unsigned	O
char	O
*	O
)	O
end	pointer
;	O
return	O
display_tag_value	function
(	O
tag	int
,	O
start	pointer
,	O
end	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
process_arch_specific	function
(	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
if	O
(	O
!	O
do_arch	int
)	O
return	O
TRUE	int
;	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
)	O
{	O
case	O
EM_ARC	int
:	O
case	O
EM_ARC_COMPACT	int
:	O
case	O
EM_ARC_COMPACT2	int
:	O
return	O
process_attributes	function
(	O
filedata	struct
,	O
"ARC"	pointer
,	O
SHT_ARC_ATTRIBUTES	int
,	O
display_arc_attribute	function
,	O
display_generic_attribute	function
)	O
;	O
case	O
EM_ARM	int
:	O
return	O
process_attributes	function
(	O
filedata	struct
,	O
"aeabi"	pointer
,	O
SHT_ARM_ATTRIBUTES	int
,	O
display_arm_attribute	function
,	O
display_generic_attribute	function
)	O
;	O
case	O
EM_MIPS	int
:	O
case	O
EM_MIPS_RS3_LE	int
:	O
return	O
process_mips_specific	function
(	O
filedata	struct
)	O
;	O
case	O
EM_MSP430	int
:	O
return	O
process_attributes	function
(	O
filedata	struct
,	O
"mspabi"	pointer
,	O
SHT_MSP430_ATTRIBUTES	int
,	O
display_msp430x_attribute	function
,	O
display_msp430_gnu_attribute	function
)	O
;	O
case	O
EM_RISCV	int
:	O
return	O
process_attributes	function
(	O
filedata	struct
,	O
"riscv"	pointer
,	O
SHT_RISCV_ATTRIBUTES	int
,	O
display_riscv_attribute	function
,	O
display_generic_attribute	function
)	O
;	O
case	O
EM_NDS32	int
:	O
return	O
process_nds32_specific	function
(	O
filedata	struct
)	O
;	O
case	O
EM_PPC	int
:	O
case	O
EM_PPC64	int
:	O
return	O
process_attributes	function
(	O
filedata	struct
,	O
NULL	O
,	O
SHT_GNU_ATTRIBUTES	int
,	O
NULL	O
,	O
display_power_gnu_attribute	function
)	O
;	O
case	O
EM_S390	int
:	O
case	O
EM_S390_OLD	int
:	O
return	O
process_attributes	function
(	O
filedata	struct
,	O
NULL	O
,	O
SHT_GNU_ATTRIBUTES	int
,	O
NULL	O
,	O
display_s390_gnu_attribute	function
)	O
;	O
case	O
EM_SPARC	int
:	O
case	O
EM_SPARC32PLUS	int
:	O
case	O
EM_SPARCV9	int
:	O
return	O
process_attributes	function
(	O
filedata	struct
,	O
NULL	O
,	O
SHT_GNU_ATTRIBUTES	int
,	O
NULL	O
,	O
display_sparc_gnu_attribute	function
)	O
;	O
case	O
EM_TI_C6000	int
:	O
return	O
process_attributes	function
(	O
filedata	struct
,	O
"c6xabi"	pointer
,	O
SHT_C6000_ATTRIBUTES	int
,	O
display_tic6x_attribute	function
,	O
display_generic_attribute	function
)	O
;	O
default	O
:	O
return	O
process_attributes	function
(	O
filedata	struct
,	O
"gnu"	pointer
,	O
SHT_GNU_ATTRIBUTES	int
,	O
display_public_gnu_attributes	function
,	O
display_generic_attribute	function
)	O
;	O
}	O
}	O
static	O
bfd_boolean	int
get_file_header	function
(	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
if	O
(	O
fread	function
(	O
filedata	struct
->	O
file_header	struct
.	O
e_ident	array
,	O
EI_NIDENT	int
,	O
1	int
,	O
filedata	struct
->	O
handle	pointer
)	O
!=	O
1	int
)	O
return	O
FALSE	int
;	O
switch	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_ident	array
[	O
EI_DATA	int
]	O
)	O
{	O
default	O
:	O
case	O
ELFDATANONE	int
:	O
case	O
ELFDATA2LSB	int
:	O
byte_get	pointer
=	O
byte_get_little_endian	function
;	O
byte_put	pointer
=	O
byte_put_little_endian	function
;	O
break	O
;	O
case	O
ELFDATA2MSB	int
:	O
byte_get	pointer
=	O
byte_get_big_endian	function
;	O
byte_put	pointer
=	O
byte_put_big_endian	function
;	O
break	O
;	O
}	O
is_32bit_elf	int
=	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_ident	array
[	O
EI_CLASS	int
]	O
!=	O
ELFCLASS64	int
)	O
;	O
if	O
(	O
is_32bit_elf	int
)	O
{	O
Elf32_External_Ehdr	struct
ehdr32	struct
;	O
if	O
(	O
fread	function
(	O
ehdr32	struct
.	O
e_type	array
,	O
sizeof	O
(	O
ehdr32	struct
)	O
-	O
EI_NIDENT	int
,	O
1	int
,	O
filedata	struct
->	O
handle	pointer
)	O
!=	O
1	int
)	O
return	O
FALSE	int
;	O
filedata	struct
->	O
file_header	struct
.	O
e_type	array
=	O
BYTE_GET	O
(	O
ehdr32	struct
.	O
e_type	array
)	O
;	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
=	O
BYTE_GET	O
(	O
ehdr32	struct
.	O
e_machine	array
)	O
;	O
filedata	struct
->	O
file_header	struct
.	O
e_version	array
=	O
BYTE_GET	O
(	O
ehdr32	struct
.	O
e_version	array
)	O
;	O
filedata	struct
->	O
file_header	struct
.	O
e_entry	array
=	O
BYTE_GET	O
(	O
ehdr32	struct
.	O
e_entry	array
)	O
;	O
filedata	struct
->	O
file_header	struct
.	O
e_phoff	array
=	O
BYTE_GET	O
(	O
ehdr32	struct
.	O
e_phoff	array
)	O
;	O
filedata	struct
->	O
file_header	struct
.	O
e_shoff	array
=	O
BYTE_GET	O
(	O
ehdr32	struct
.	O
e_shoff	array
)	O
;	O
filedata	struct
->	O
file_header	struct
.	O
e_flags	array
=	O
BYTE_GET	O
(	O
ehdr32	struct
.	O
e_flags	array
)	O
;	O
filedata	struct
->	O
file_header	struct
.	O
e_ehsize	array
=	O
BYTE_GET	O
(	O
ehdr32	struct
.	O
e_ehsize	array
)	O
;	O
filedata	struct
->	O
file_header	struct
.	O
e_phentsize	array
=	O
BYTE_GET	O
(	O
ehdr32	struct
.	O
e_phentsize	array
)	O
;	O
filedata	struct
->	O
file_header	struct
.	O
e_phnum	array
=	O
BYTE_GET	O
(	O
ehdr32	struct
.	O
e_phnum	array
)	O
;	O
filedata	struct
->	O
file_header	struct
.	O
e_shentsize	array
=	O
BYTE_GET	O
(	O
ehdr32	struct
.	O
e_shentsize	array
)	O
;	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
=	O
BYTE_GET	O
(	O
ehdr32	struct
.	O
e_shnum	array
)	O
;	O
filedata	struct
->	O
file_header	struct
.	O
e_shstrndx	array
=	O
BYTE_GET	O
(	O
ehdr32	struct
.	O
e_shstrndx	array
)	O
;	O
}	O
else	O
{	O
Elf64_External_Ehdr	struct
ehdr64	struct
;	O
if	O
(	O
sizeof	O
(	O
bfd_vma	long
)	O
<	O
8	int
)	O
{	O
error	function
(	O
_	O
(	O
"This instance of readelf has been built without support for a\n64 bit data type and so it cannot read 64 bit ELF files.\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
fread	function
(	O
ehdr64	struct
.	O
e_type	array
,	O
sizeof	O
(	O
ehdr64	struct
)	O
-	O
EI_NIDENT	int
,	O
1	int
,	O
filedata	struct
->	O
handle	pointer
)	O
!=	O
1	int
)	O
return	O
FALSE	int
;	O
filedata	struct
->	O
file_header	struct
.	O
e_type	array
=	O
BYTE_GET	O
(	O
ehdr64	struct
.	O
e_type	array
)	O
;	O
filedata	struct
->	O
file_header	struct
.	O
e_machine	array
=	O
BYTE_GET	O
(	O
ehdr64	struct
.	O
e_machine	array
)	O
;	O
filedata	struct
->	O
file_header	struct
.	O
e_version	array
=	O
BYTE_GET	O
(	O
ehdr64	struct
.	O
e_version	array
)	O
;	O
filedata	struct
->	O
file_header	struct
.	O
e_entry	array
=	O
BYTE_GET	O
(	O
ehdr64	struct
.	O
e_entry	array
)	O
;	O
filedata	struct
->	O
file_header	struct
.	O
e_phoff	array
=	O
BYTE_GET	O
(	O
ehdr64	struct
.	O
e_phoff	array
)	O
;	O
filedata	struct
->	O
file_header	struct
.	O
e_shoff	array
=	O
BYTE_GET	O
(	O
ehdr64	struct
.	O
e_shoff	array
)	O
;	O
filedata	struct
->	O
file_header	struct
.	O
e_flags	array
=	O
BYTE_GET	O
(	O
ehdr64	struct
.	O
e_flags	array
)	O
;	O
filedata	struct
->	O
file_header	struct
.	O
e_ehsize	array
=	O
BYTE_GET	O
(	O
ehdr64	struct
.	O
e_ehsize	array
)	O
;	O
filedata	struct
->	O
file_header	struct
.	O
e_phentsize	array
=	O
BYTE_GET	O
(	O
ehdr64	struct
.	O
e_phentsize	array
)	O
;	O
filedata	struct
->	O
file_header	struct
.	O
e_phnum	array
=	O
BYTE_GET	O
(	O
ehdr64	struct
.	O
e_phnum	array
)	O
;	O
filedata	struct
->	O
file_header	struct
.	O
e_shentsize	array
=	O
BYTE_GET	O
(	O
ehdr64	struct
.	O
e_shentsize	array
)	O
;	O
filedata	struct
->	O
file_header	struct
.	O
e_shnum	array
=	O
BYTE_GET	O
(	O
ehdr64	struct
.	O
e_shnum	array
)	O
;	O
filedata	struct
->	O
file_header	struct
.	O
e_shstrndx	array
=	O
BYTE_GET	O
(	O
ehdr64	struct
.	O
e_shstrndx	array
)	O
;	O
}	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_shoff	array
)	O
{	O
if	O
(	O
is_32bit_elf	int
)	O
get_32bit_section_headers	function
(	O
filedata	struct
,	O
TRUE	int
)	O
;	O
else	O
get_64bit_section_headers	function
(	O
filedata	struct
,	O
TRUE	int
)	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
void	O
close_file	function
(	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
if	O
(	O
filedata	struct
)	O
{	O
if	O
(	O
filedata	struct
->	O
handle	pointer
)	O
fclose	function
(	O
filedata	struct
->	O
handle	pointer
)	O
;	O
free	function
(	O
filedata	struct
)	O
;	O
}	O
}	O
void	O
close_debug_file	function
(	O
void	O
*	O
data	pointer
)	O
{	O
close_file	function
(	O
(	O
Filedata	struct
*	O
)	O
data	pointer
)	O
;	O
}	O
static	O
Filedata	struct
*	O
open_file	function
(	O
const	O
char	O
*	O
pathname	pointer
)	O
{	O
struct	O
stat	struct
statbuf	struct
;	O
Filedata	struct
*	O
filedata	struct
=	O
NULL	O
;	O
if	O
(	O
stat	struct
(	O
pathname	pointer
,	O
&	O
statbuf	struct
)	O
<	O
0	int
||	O
!	O
S_ISREG	O
(	O
statbuf	struct
.	O
st_mode	int
)	O
)	O
goto	O
fail	O
;	O
filedata	struct
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
*	O
filedata	struct
)	O
;	O
if	O
(	O
filedata	struct
==	O
NULL	O
)	O
goto	O
fail	O
;	O
filedata	struct
->	O
handle	pointer
=	O
fopen	function
(	O
pathname	pointer
,	O
"rb"	pointer
)	O
;	O
if	O
(	O
filedata	struct
->	O
handle	pointer
==	O
NULL	O
)	O
goto	O
fail	O
;	O
filedata	struct
->	O
file_size	long
=	O
(	O
bfd_size_type	long
)	O
statbuf	struct
.	O
st_size	long
;	O
filedata	struct
->	O
file_name	pointer
=	O
pathname	pointer
;	O
if	O
(	O
!	O
get_file_header	function
(	O
filedata	struct
)	O
)	O
goto	O
fail	O
;	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_shoff	array
)	O
{	O
bfd_boolean	int
res	int
;	O
if	O
(	O
is_32bit_elf	int
)	O
res	int
=	O
get_32bit_section_headers	function
(	O
filedata	struct
,	O
FALSE	int
)	O
;	O
else	O
res	int
=	O
get_64bit_section_headers	function
(	O
filedata	struct
,	O
FALSE	int
)	O
;	O
if	O
(	O
!	O
res	int
)	O
goto	O
fail	O
;	O
}	O
return	O
filedata	struct
;	O
fail	O
:	O
if	O
(	O
filedata	struct
)	O
{	O
if	O
(	O
filedata	struct
->	O
handle	pointer
)	O
fclose	function
(	O
filedata	struct
->	O
handle	pointer
)	O
;	O
free	function
(	O
filedata	struct
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
void	O
*	O
open_debug_file	function
(	O
const	O
char	O
*	O
pathname	pointer
)	O
{	O
return	O
open_file	function
(	O
pathname	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
process_object	function
(	O
Filedata	struct
*	O
filedata	struct
)	O
{	O
bfd_boolean	int
have_separate_files	int
;	O
unsigned	O
int	O
i	pointer
;	O
bfd_boolean	int
res	int
=	O
TRUE	int
;	O
if	O
(	O
!	O
get_file_header	function
(	O
filedata	struct
)	O
)	O
{	O
error	function
(	O
_	O
(	O
"%s: Failed to read file header\n"	pointer
)	O
,	O
filedata	struct
->	O
file_name	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
for	O
(	O
i	pointer
=	O
ARRAY_SIZE	O
(	O
version_info	array
)	O
;	O
i	pointer
--	O
;	O
)	O
version_info	array
[	O
i	pointer
]	O
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
ARRAY_SIZE	O
(	O
dynamic_info	array
)	O
;	O
i	pointer
--	O
;	O
)	O
dynamic_info	array
[	O
i	pointer
]	O
=	O
0	int
;	O
dynamic_info_DT_GNU_HASH	long
=	O
0	int
;	O
dynamic_info_DT_MIPS_XHASH	long
=	O
0	int
;	O
if	O
(	O
show_name	int
)	O
printf	function
(	O
_	O
(	O
"\nFile: %s\n"	pointer
)	O
,	O
filedata	struct
->	O
file_name	pointer
)	O
;	O
if	O
(	O
filedata	struct
->	O
num_dump_sects	int
>	O
cmdline	struct
.	O
num_dump_sects	int
)	O
memset	function
(	O
filedata	struct
->	O
dump_sects	pointer
,	O
0	int
,	O
filedata	struct
->	O
num_dump_sects	int
*	O
sizeof	O
(	O
*	O
filedata	struct
->	O
dump_sects	pointer
)	O
)	O
;	O
if	O
(	O
cmdline	struct
.	O
num_dump_sects	int
>	O
0	int
)	O
{	O
if	O
(	O
filedata	struct
->	O
num_dump_sects	int
==	O
0	int
)	O
request_dump_bynumber	function
(	O
filedata	struct
,	O
cmdline	struct
.	O
num_dump_sects	int
,	O
0	int
)	O
;	O
assert	O
(	O
filedata	struct
->	O
num_dump_sects	int
>=	O
cmdline	struct
.	O
num_dump_sects	int
)	O
;	O
memcpy	function
(	O
filedata	struct
->	O
dump_sects	pointer
,	O
cmdline	struct
.	O
dump_sects	pointer
,	O
cmdline	struct
.	O
num_dump_sects	int
*	O
sizeof	O
(	O
*	O
filedata	struct
->	O
dump_sects	pointer
)	O
)	O
;	O
}	O
if	O
(	O
!	O
process_file_header	function
(	O
filedata	struct
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
process_section_headers	function
(	O
filedata	struct
)	O
)	O
{	O
do_unwind	int
=	O
do_version	int
=	O
do_dump	int
=	O
do_arch	int
=	O
FALSE	int
;	O
if	O
(	O
!	O
do_using_dynamic	int
)	O
do_syms	int
=	O
do_dyn_syms	int
=	O
do_reloc	int
=	O
FALSE	int
;	O
}	O
if	O
(	O
!	O
process_section_groups	function
(	O
filedata	struct
)	O
)	O
do_unwind	int
=	O
FALSE	int
;	O
if	O
(	O
process_program_headers	function
(	O
filedata	struct
)	O
)	O
process_dynamic_section	function
(	O
filedata	struct
)	O
;	O
else	O
res	int
=	O
FALSE	int
;	O
if	O
(	O
!	O
process_relocs	function
(	O
filedata	struct
)	O
)	O
res	int
=	O
FALSE	int
;	O
if	O
(	O
!	O
process_unwind	function
(	O
filedata	struct
)	O
)	O
res	int
=	O
FALSE	int
;	O
if	O
(	O
!	O
process_symbol_table	function
(	O
filedata	struct
)	O
)	O
res	int
=	O
FALSE	int
;	O
if	O
(	O
!	O
process_syminfo	function
(	O
filedata	struct
)	O
)	O
res	int
=	O
FALSE	int
;	O
if	O
(	O
!	O
process_version_sections	function
(	O
filedata	struct
)	O
)	O
res	int
=	O
FALSE	int
;	O
if	O
(	O
filedata	struct
->	O
file_header	struct
.	O
e_shstrndx	array
!=	O
SHN_UNDEF	int
)	O
have_separate_files	int
=	O
load_separate_debug_files	function
(	O
filedata	struct
,	O
filedata	struct
->	O
file_name	pointer
)	O
;	O
else	O
have_separate_files	int
=	O
FALSE	int
;	O
if	O
(	O
!	O
process_section_contents	function
(	O
filedata	struct
)	O
)	O
res	int
=	O
FALSE	int
;	O
if	O
(	O
have_separate_files	int
)	O
{	O
separate_info	struct
*	O
d	pointer
;	O
for	O
(	O
d	pointer
=	O
first_separate_info	pointer
;	O
d	pointer
!=	O
NULL	O
;	O
d	pointer
=	O
d	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
!	O
process_section_headers	function
(	O
d	pointer
->	O
handle	pointer
)	O
)	O
res	int
=	O
FALSE	int
;	O
else	O
if	O
(	O
!	O
process_section_contents	function
(	O
d	pointer
->	O
handle	pointer
)	O
)	O
res	int
=	O
FALSE	int
;	O
}	O
}	O
if	O
(	O
!	O
process_notes	function
(	O
filedata	struct
)	O
)	O
res	int
=	O
FALSE	int
;	O
if	O
(	O
!	O
process_gnu_liblist	function
(	O
filedata	struct
)	O
)	O
res	int
=	O
FALSE	int
;	O
if	O
(	O
!	O
process_arch_specific	function
(	O
filedata	struct
)	O
)	O
res	int
=	O
FALSE	int
;	O
free	function
(	O
filedata	struct
->	O
program_headers	pointer
)	O
;	O
filedata	struct
->	O
program_headers	pointer
=	O
NULL	O
;	O
free	function
(	O
filedata	struct
->	O
section_headers	pointer
)	O
;	O
filedata	struct
->	O
section_headers	pointer
=	O
NULL	O
;	O
free	function
(	O
filedata	struct
->	O
string_table	pointer
)	O
;	O
filedata	struct
->	O
string_table	pointer
=	O
NULL	O
;	O
filedata	struct
->	O
string_table_length	long
=	O
0	int
;	O
if	O
(	O
filedata	struct
->	O
dump_sects	pointer
!=	O
NULL	O
)	O
{	O
free	function
(	O
filedata	struct
->	O
dump_sects	pointer
)	O
;	O
filedata	struct
->	O
dump_sects	pointer
=	O
NULL	O
;	O
filedata	struct
->	O
num_dump_sects	int
=	O
0	int
;	O
}	O
if	O
(	O
dynamic_strings	pointer
)	O
{	O
free	function
(	O
dynamic_strings	pointer
)	O
;	O
dynamic_strings	pointer
=	O
NULL	O
;	O
dynamic_strings_length	long
=	O
0	int
;	O
}	O
if	O
(	O
dynamic_symbols	pointer
)	O
{	O
free	function
(	O
dynamic_symbols	pointer
)	O
;	O
dynamic_symbols	pointer
=	O
NULL	O
;	O
num_dynamic_syms	long
=	O
0	int
;	O
}	O
if	O
(	O
dynamic_syminfo	pointer
)	O
{	O
free	function
(	O
dynamic_syminfo	pointer
)	O
;	O
dynamic_syminfo	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
dynamic_section	pointer
)	O
{	O
free	function
(	O
dynamic_section	pointer
)	O
;	O
dynamic_section	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
section_headers_groups	pointer
)	O
{	O
free	function
(	O
section_headers_groups	pointer
)	O
;	O
section_headers_groups	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
section_groups	pointer
)	O
{	O
struct	O
group_list	struct
*	O
g	pointer
;	O
struct	O
group_list	struct
*	O
next	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
group_count	long
;	O
i	pointer
++	O
)	O
{	O
for	O
(	O
g	pointer
=	O
section_groups	pointer
[	O
i	pointer
]	O
.	O
root	pointer
;	O
g	pointer
!=	O
NULL	O
;	O
g	pointer
=	O
next	pointer
)	O
{	O
next	pointer
=	O
g	pointer
->	O
next	pointer
;	O
free	function
(	O
g	pointer
)	O
;	O
}	O
}	O
free	function
(	O
section_groups	pointer
)	O
;	O
section_groups	pointer
=	O
NULL	O
;	O
}	O
free_debug_memory	function
(	O
)	O
;	O
return	O
res	int
;	O
}	O
static	O
bfd_boolean	int
process_archive	function
(	O
Filedata	struct
*	O
filedata	struct
,	O
bfd_boolean	int
is_thin_archive	int
)	O
{	O
struct	O
archive_info	struct
arch	enum
;	O
struct	O
archive_info	struct
nested_arch	struct
;	O
size_t	long
got	long
;	O
bfd_boolean	int
ret	pointer
=	O
TRUE	int
;	O
show_name	int
=	O
TRUE	int
;	O
arch	enum
.	O
file_name	pointer
=	O
NULL	O
;	O
arch	enum
.	O
file	pointer
=	O
NULL	O
;	O
arch	enum
.	O
index_array	pointer
=	O
NULL	O
;	O
arch	enum
.	O
sym_table	pointer
=	O
NULL	O
;	O
arch	enum
.	O
longnames	pointer
=	O
NULL	O
;	O
nested_arch	struct
.	O
file_name	pointer
=	O
NULL	O
;	O
nested_arch	struct
.	O
file	pointer
=	O
NULL	O
;	O
nested_arch	struct
.	O
index_array	pointer
=	O
NULL	O
;	O
nested_arch	struct
.	O
sym_table	pointer
=	O
NULL	O
;	O
nested_arch	struct
.	O
longnames	pointer
=	O
NULL	O
;	O
if	O
(	O
setup_archive	function
(	O
&	O
arch	enum
,	O
filedata	struct
->	O
file_name	pointer
,	O
filedata	struct
->	O
handle	pointer
,	O
is_thin_archive	int
,	O
do_archive_index	int
)	O
!=	O
0	int
)	O
{	O
ret	pointer
=	O
FALSE	int
;	O
goto	O
out	pointer
;	O
}	O
if	O
(	O
do_archive_index	int
)	O
{	O
if	O
(	O
arch	enum
.	O
sym_table	pointer
==	O
NULL	O
)	O
error	function
(	O
_	O
(	O
"%s: unable to dump the index as none was found\n"	pointer
)	O
,	O
filedata	struct
->	O
file_name	pointer
)	O
;	O
else	O
{	O
unsigned	O
long	O
i	pointer
,	O
l	int
;	O
unsigned	O
long	O
current_pos	long
;	O
printf	function
(	O
_	O
(	O
"Index of archive %s: (%lu entries, 0x%lx bytes in the symbol table)\n"	pointer
)	O
,	O
filedata	struct
->	O
file_name	pointer
,	O
(	O
unsigned	O
long	O
)	O
arch	enum
.	O
index_num	long
,	O
arch	enum
.	O
sym_size	long
)	O
;	O
current_pos	long
=	O
ftell	function
(	O
filedata	struct
->	O
handle	pointer
)	O
;	O
for	O
(	O
i	pointer
=	O
l	int
=	O
0	int
;	O
i	pointer
<	O
arch	enum
.	O
index_num	long
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
(	O
i	pointer
==	O
0	int
)	O
||	O
(	O
(	O
i	pointer
>	O
0	int
)	O
&&	O
(	O
arch	enum
.	O
index_array	pointer
[	O
i	pointer
]	O
!=	O
arch	enum
.	O
index_array	pointer
[	O
i	pointer
-	O
1	int
]	O
)	O
)	O
)	O
{	O
char	O
*	O
member_name	pointer
;	O
member_name	pointer
=	O
get_archive_member_name_at	function
(	O
&	O
arch	enum
,	O
arch	enum
.	O
index_array	pointer
[	O
i	pointer
]	O
,	O
&	O
nested_arch	struct
)	O
;	O
if	O
(	O
member_name	pointer
!=	O
NULL	O
)	O
{	O
char	O
*	O
qualified_name	pointer
=	O
make_qualified_name	function
(	O
&	O
arch	enum
,	O
&	O
nested_arch	struct
,	O
member_name	pointer
)	O
;	O
if	O
(	O
qualified_name	pointer
!=	O
NULL	O
)	O
{	O
printf	function
(	O
_	O
(	O
"Contents of binary %s at offset "	pointer
)	O
,	O
qualified_name	pointer
)	O
;	O
(	O
void	O
)	O
print_vma	function
(	O
arch	enum
.	O
index_array	pointer
[	O
i	pointer
]	O
,	O
PREFIX_HEX	int
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
free	function
(	O
qualified_name	pointer
)	O
;	O
}	O
}	O
}	O
if	O
(	O
l	int
>=	O
arch	enum
.	O
sym_size	long
)	O
{	O
error	function
(	O
_	O
(	O
"%s: end of the symbol table reached before the end of the index\n"	pointer
)	O
,	O
filedata	struct
->	O
file_name	pointer
)	O
;	O
ret	pointer
=	O
FALSE	int
;	O
break	O
;	O
}	O
printf	function
(	O
"\t%.*s\n"	pointer
,	O
(	O
int	O
)	O
(	O
arch	enum
.	O
sym_size	long
-	O
l	int
)	O
,	O
arch	enum
.	O
sym_table	pointer
+	O
l	int
)	O
;	O
l	int
+=	O
strnlen	function
(	O
arch	enum
.	O
sym_table	pointer
+	O
l	int
,	O
arch	enum
.	O
sym_size	long
-	O
l	int
)	O
+	O
1	int
;	O
}	O
if	O
(	O
arch	enum
.	O
uses_64bit_indices	int
)	O
l	int
=	O
(	O
l	int
+	O
7	int
)	O
&	O
~	O
7	int
;	O
else	O
l	int
+=	O
l	int
&	O
1	int
;	O
if	O
(	O
l	int
<	O
arch	enum
.	O
sym_size	long
)	O
{	O
error	function
(	O
ngettext	function
(	O
"%s: %ld byte remains in the symbol table, "	pointer
"but without corresponding entries in "	pointer
"the index table\n"	pointer
,	O
"%s: %ld bytes remain in the symbol table, "	pointer
"but without corresponding entries in "	pointer
"the index table\n"	pointer
,	O
arch	enum
.	O
sym_size	long
-	O
l	int
)	O
,	O
filedata	struct
->	O
file_name	pointer
,	O
arch	enum
.	O
sym_size	long
-	O
l	int
)	O
;	O
ret	pointer
=	O
FALSE	int
;	O
}	O
if	O
(	O
fseek	function
(	O
filedata	struct
->	O
handle	pointer
,	O
current_pos	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
{	O
error	function
(	O
_	O
(	O
"%s: failed to seek back to start of object files in the archive\n"	pointer
)	O
,	O
filedata	struct
->	O
file_name	pointer
)	O
;	O
ret	pointer
=	O
FALSE	int
;	O
goto	O
out	pointer
;	O
}	O
}	O
if	O
(	O
!	O
do_dynamic	int
&&	O
!	O
do_syms	int
&&	O
!	O
do_reloc	int
&&	O
!	O
do_unwind	int
&&	O
!	O
do_sections	int
&&	O
!	O
do_segments	int
&&	O
!	O
do_header	int
&&	O
!	O
do_dump	int
&&	O
!	O
do_version	int
&&	O
!	O
do_histogram	int
&&	O
!	O
do_debugging	int
&&	O
!	O
do_arch	int
&&	O
!	O
do_notes	int
&&	O
!	O
do_section_groups	int
&&	O
!	O
do_dyn_syms	int
)	O
{	O
ret	pointer
=	O
TRUE	int
;	O
goto	O
out	pointer
;	O
}	O
}	O
while	O
(	O
1	int
)	O
{	O
char	O
*	O
name	pointer
;	O
size_t	long
namelen	int
;	O
char	O
*	O
qualified_name	pointer
;	O
if	O
(	O
fseek	function
(	O
filedata	struct
->	O
handle	pointer
,	O
arch	enum
.	O
next_arhdr_offset	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
{	O
error	function
(	O
_	O
(	O
"%s: failed to seek to next archive header\n"	pointer
)	O
,	O
arch	enum
.	O
file_name	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
got	long
=	O
fread	function
(	O
&	O
arch	enum
.	O
arhdr	struct
,	O
1	int
,	O
sizeof	O
arch	enum
.	O
arhdr	struct
,	O
filedata	struct
->	O
handle	pointer
)	O
;	O
if	O
(	O
got	long
!=	O
sizeof	O
arch	enum
.	O
arhdr	struct
)	O
{	O
if	O
(	O
got	long
==	O
0	int
)	O
break	O
;	O
error	function
(	O
_	O
(	O
"%s: failed to read archive header\n"	pointer
)	O
,	O
arch	enum
.	O
file_name	pointer
)	O
;	O
ret	pointer
=	O
FALSE	int
;	O
break	O
;	O
}	O
if	O
(	O
memcmp	function
(	O
arch	enum
.	O
arhdr	struct
.	O
ar_fmag	array
,	O
ARFMAG	pointer
,	O
2	int
)	O
!=	O
0	int
)	O
{	O
error	function
(	O
_	O
(	O
"%s: did not find a valid archive header\n"	pointer
)	O
,	O
arch	enum
.	O
file_name	pointer
)	O
;	O
ret	pointer
=	O
FALSE	int
;	O
break	O
;	O
}	O
arch	enum
.	O
next_arhdr_offset	long
+=	O
sizeof	O
arch	enum
.	O
arhdr	struct
;	O
archive_file_size	long
=	O
strtoul	function
(	O
arch	enum
.	O
arhdr	struct
.	O
ar_size	array
,	O
NULL	O
,	O
10	int
)	O
;	O
if	O
(	O
archive_file_size	long
&	O
01	int
)	O
++	O
archive_file_size	long
;	O
name	pointer
=	O
get_archive_member_name	function
(	O
&	O
arch	enum
,	O
&	O
nested_arch	struct
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"%s: bad archive file name\n"	pointer
)	O
,	O
arch	enum
.	O
file_name	pointer
)	O
;	O
ret	pointer
=	O
FALSE	int
;	O
break	O
;	O
}	O
namelen	int
=	O
strlen	function
(	O
name	pointer
)	O
;	O
qualified_name	pointer
=	O
make_qualified_name	function
(	O
&	O
arch	enum
,	O
&	O
nested_arch	struct
,	O
name	pointer
)	O
;	O
if	O
(	O
qualified_name	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"%s: bad archive file name\n"	pointer
)	O
,	O
arch	enum
.	O
file_name	pointer
)	O
;	O
ret	pointer
=	O
FALSE	int
;	O
break	O
;	O
}	O
if	O
(	O
is_thin_archive	int
&&	O
arch	enum
.	O
nested_member_origin	long
==	O
0	int
)	O
{	O
Filedata	struct
*	O
member_filedata	pointer
;	O
char	O
*	O
member_file_name	pointer
=	O
adjust_relative_path	function
(	O
filedata	struct
->	O
file_name	pointer
,	O
name	pointer
,	O
namelen	int
)	O
;	O
if	O
(	O
member_file_name	pointer
==	O
NULL	O
)	O
{	O
ret	pointer
=	O
FALSE	int
;	O
break	O
;	O
}	O
member_filedata	pointer
=	O
open_file	function
(	O
member_file_name	pointer
)	O
;	O
if	O
(	O
member_filedata	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Input file '%s' is not readable.\n"	pointer
)	O
,	O
member_file_name	pointer
)	O
;	O
free	function
(	O
member_file_name	pointer
)	O
;	O
ret	pointer
=	O
FALSE	int
;	O
break	O
;	O
}	O
archive_file_offset	long
=	O
arch	enum
.	O
nested_member_origin	long
;	O
member_filedata	pointer
->	O
file_name	pointer
=	O
qualified_name	pointer
;	O
if	O
(	O
!	O
process_object	function
(	O
member_filedata	pointer
)	O
)	O
ret	pointer
=	O
FALSE	int
;	O
close_file	function
(	O
member_filedata	pointer
)	O
;	O
free	function
(	O
member_file_name	pointer
)	O
;	O
}	O
else	O
if	O
(	O
is_thin_archive	int
)	O
{	O
Filedata	struct
thin_filedata	struct
;	O
memset	function
(	O
&	O
thin_filedata	struct
,	O
0	int
,	O
sizeof	O
(	O
thin_filedata	struct
)	O
)	O
;	O
if	O
(	O
nested_arch	struct
.	O
file	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"%s: contains corrupt thin archive: %s\n"	pointer
)	O
,	O
qualified_name	pointer
,	O
name	pointer
)	O
;	O
ret	pointer
=	O
FALSE	int
;	O
break	O
;	O
}	O
archive_file_offset	long
=	O
arch	enum
.	O
nested_member_origin	long
+	O
sizeof	O
arch	enum
.	O
arhdr	struct
;	O
if	O
(	O
fseek	function
(	O
nested_arch	struct
.	O
file	pointer
,	O
archive_file_offset	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
{	O
error	function
(	O
_	O
(	O
"%s: failed to seek to archive member.\n"	pointer
)	O
,	O
nested_arch	struct
.	O
file_name	pointer
)	O
;	O
ret	pointer
=	O
FALSE	int
;	O
break	O
;	O
}	O
thin_filedata	struct
.	O
handle	pointer
=	O
nested_arch	struct
.	O
file	pointer
;	O
thin_filedata	struct
.	O
file_name	pointer
=	O
qualified_name	pointer
;	O
if	O
(	O
!	O
process_object	function
(	O
&	O
thin_filedata	struct
)	O
)	O
ret	pointer
=	O
FALSE	int
;	O
}	O
else	O
{	O
archive_file_offset	long
=	O
arch	enum
.	O
next_arhdr_offset	long
;	O
arch	enum
.	O
next_arhdr_offset	long
+=	O
archive_file_size	long
;	O
filedata	struct
->	O
file_name	pointer
=	O
qualified_name	pointer
;	O
if	O
(	O
!	O
process_object	function
(	O
filedata	struct
)	O
)	O
ret	pointer
=	O
FALSE	int
;	O
}	O
free	function
(	O
qualified_name	pointer
)	O
;	O
}	O
out	pointer
:	O
if	O
(	O
nested_arch	struct
.	O
file	pointer
!=	O
NULL	O
)	O
fclose	function
(	O
nested_arch	struct
.	O
file	pointer
)	O
;	O
release_archive	function
(	O
&	O
nested_arch	struct
)	O
;	O
release_archive	function
(	O
&	O
arch	enum
)	O
;	O
return	O
ret	pointer
;	O
}	O
static	O
bfd_boolean	int
process_file	function
(	O
char	O
*	O
file_name	pointer
)	O
{	O
Filedata	struct
*	O
filedata	struct
=	O
NULL	O
;	O
struct	O
stat	struct
statbuf	struct
;	O
char	O
armag	array
[	O
SARMAG	int
]	O
;	O
bfd_boolean	int
ret	pointer
=	O
TRUE	int
;	O
if	O
(	O
stat	struct
(	O
file_name	pointer
,	O
&	O
statbuf	struct
)	O
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
ENOENT	int
)	O
error	function
(	O
_	O
(	O
"'%s': No such file\n"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
else	O
error	function
(	O
_	O
(	O
"Could not locate '%s'.  System error message: %s\n"	pointer
)	O
,	O
file_name	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
!	O
S_ISREG	O
(	O
statbuf	struct
.	O
st_mode	int
)	O
)	O
{	O
error	function
(	O
_	O
(	O
"'%s' is not an ordinary file\n"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
filedata	struct
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
*	O
filedata	struct
)	O
;	O
if	O
(	O
filedata	struct
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Out of memory allocating file data structure\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
filedata	struct
->	O
file_name	pointer
=	O
file_name	pointer
;	O
filedata	struct
->	O
handle	pointer
=	O
fopen	function
(	O
file_name	pointer
,	O
"rb"	pointer
)	O
;	O
if	O
(	O
filedata	struct
->	O
handle	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Input file '%s' is not readable.\n"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
free	function
(	O
filedata	struct
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
fread	function
(	O
armag	array
,	O
SARMAG	int
,	O
1	int
,	O
filedata	struct
->	O
handle	pointer
)	O
!=	O
1	int
)	O
{	O
error	function
(	O
_	O
(	O
"%s: Failed to read file's magic number\n"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
fclose	function
(	O
filedata	struct
->	O
handle	pointer
)	O
;	O
free	function
(	O
filedata	struct
)	O
;	O
return	O
FALSE	int
;	O
}	O
filedata	struct
->	O
file_size	long
=	O
(	O
bfd_size_type	long
)	O
statbuf	struct
.	O
st_size	long
;	O
if	O
(	O
memcmp	function
(	O
armag	array
,	O
ARMAG	pointer
,	O
SARMAG	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
!	O
process_archive	function
(	O
filedata	struct
,	O
FALSE	int
)	O
)	O
ret	pointer
=	O
FALSE	int
;	O
}	O
else	O
if	O
(	O
memcmp	function
(	O
armag	array
,	O
ARMAGT	pointer
,	O
SARMAG	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
!	O
process_archive	function
(	O
filedata	struct
,	O
TRUE	int
)	O
)	O
ret	pointer
=	O
FALSE	int
;	O
}	O
else	O
{	O
if	O
(	O
do_archive_index	int
)	O
error	function
(	O
_	O
(	O
"File %s is not an archive so its index cannot be displayed.\n"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
rewind	function
(	O
filedata	struct
->	O
handle	pointer
)	O
;	O
archive_file_size	long
=	O
archive_file_offset	long
=	O
0	int
;	O
if	O
(	O
!	O
process_object	function
(	O
filedata	struct
)	O
)	O
ret	pointer
=	O
FALSE	int
;	O
}	O
fclose	function
(	O
filedata	struct
->	O
handle	pointer
)	O
;	O
free	function
(	O
filedata	struct
)	O
;	O
return	O
ret	pointer
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
err	pointer
;	O
setlocale	function
(	O
LC_MESSAGES	O
,	O
""	pointer
)	O
;	O
setlocale	function
(	O
LC_CTYPE	O
,	O
""	pointer
)	O
;	O
bindtextdomain	function
(	O
PACKAGE	pointer
,	O
LOCALEDIR	O
)	O
;	O
textdomain	function
(	O
PACKAGE	pointer
)	O
;	O
expandargv	function
(	O
&	O
argc	int
,	O
&	O
argv	pointer
)	O
;	O
cmdline	struct
.	O
file_name	pointer
=	O
"<cmdline>"	pointer
;	O
parse_args	function
(	O
&	O
cmdline	struct
,	O
argc	int
,	O
argv	pointer
)	O
;	O
if	O
(	O
optind	int
<	O
(	O
argc	int
-	O
1	int
)	O
)	O
show_name	int
=	O
TRUE	int
;	O
else	O
if	O
(	O
optind	int
>=	O
argc	int
)	O
{	O
warn	function
(	O
_	O
(	O
"Nothing to do.\n"	pointer
)	O
)	O
;	O
usage	function
(	O
stderr	pointer
)	O
;	O
}	O
err	pointer
=	O
FALSE	int
;	O
while	O
(	O
optind	int
<	O
argc	int
)	O
if	O
(	O
!	O
process_file	function
(	O
argv	pointer
[	O
optind	int
++	O
]	O
)	O
)	O
err	pointer
=	O
TRUE	int
;	O
if	O
(	O
cmdline	struct
.	O
dump_sects	pointer
!=	O
NULL	O
)	O
free	function
(	O
cmdline	struct
.	O
dump_sects	pointer
)	O
;	O
free	function
(	O
dump_ctf_symtab_name	pointer
)	O
;	O
free	function
(	O
dump_ctf_strtab_name	pointer
)	O
;	O
free	function
(	O
dump_ctf_parent_name	pointer
)	O
;	O
return	O
err	pointer
?	O
EXIT_FAILURE	int
:	O
EXIT_SUCCESS	int
;	O
}	O
