static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: mp_alloc.c,v 1.3 2000/06/28 16:47:02 loic Exp $"	pointer
;	O
int	O
CDB___memp_alloc	function
(	O
dbmp	pointer
,	O
memreg	pointer
,	O
mfp	pointer
,	O
len	long
,	O
offsetp	pointer
,	O
retp	pointer
)	O
DB_MPOOL	struct
*	O
dbmp	pointer
;	O
REGINFO	struct
*	O
memreg	pointer
;	O
MPOOLFILE	struct
*	O
mfp	pointer
;	O
size_t	long
len	long
;	O
roff_t	int
*	O
offsetp	pointer
;	O
void	O
*	O
retp	pointer
;	O
{	O
BH	struct
*	O
bhp	pointer
,	O
*	O
nbhp	pointer
;	O
MPOOL	struct
*	O
c_mp	pointer
;	O
MPOOLFILE	struct
*	O
bh_mfp	pointer
;	O
size_t	long
total	long
;	O
int	O
nomore	int
,	O
restart	int
,	O
ret	int
,	O
wrote	int
;	O
void	O
*	O
p	pointer
;	O
c_mp	pointer
=	O
memreg	pointer
->	O
primary	int
;	O
if	O
(	O
mfp	pointer
!=	O
NULL	O
)	O
len	long
=	O
(	O
sizeof	O
(	O
BH	struct
)	O
-	O
sizeof	O
(	O
u_int8_t	char
)	O
)	O
+	O
mfp	pointer
->	O
stat	pointer
.	O
st_pagesize	long
;	O
nomore	int
=	O
0	int
;	O
alloc	O
:	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_shalloc	function
(	O
memreg	pointer
->	O
addr	pointer
,	O
len	long
,	O
MUTEX_ALIGN	int
,	O
&	O
p	pointer
)	O
)	O
==	O
0	int
)	O
{	O
if	O
(	O
offsetp	pointer
!=	O
NULL	O
)	O
*	O
offsetp	pointer
=	O
R_OFFSET	O
(	O
memreg	pointer
,	O
p	pointer
)	O
;	O
*	O
(	O
void	O
*	O
*	O
)	O
retp	pointer
=	O
p	pointer
;	O
return	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
nomore	int
)	O
{	O
CDB___db_err	function
(	O
dbmp	pointer
->	O
dbenv	pointer
,	O
"Unable to allocate %lu bytes from mpool shared region: %s\n"	pointer
,	O
(	O
u_long	long
)	O
len	long
,	O
CDB_db_strerror	function
(	O
ret	int
)	O
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
retry	O
:	O
restart	int
=	O
total	long
=	O
0	int
;	O
for	O
(	O
bhp	pointer
=	O
SH_TAILQ_FIRST	O
(	O
&	O
c_mp	pointer
->	O
bhq	struct
,	O
__bh	struct
)	O
;	O
bhp	pointer
!=	O
NULL	O
;	O
bhp	pointer
=	O
nbhp	pointer
)	O
{	O
nbhp	pointer
=	O
SH_TAILQ_NEXT	O
(	O
bhp	pointer
,	O
q	struct
,	O
__bh	struct
)	O
;	O
if	O
(	O
bhp	pointer
->	O
ref	int
!=	O
0	int
||	O
F_ISSET	O
(	O
bhp	pointer
,	O
BH_LOCKED	int
)	O
)	O
continue	O
;	O
bh_mfp	pointer
=	O
R_ADDR	O
(	O
dbmp	pointer
->	O
reginfo	pointer
,	O
bhp	pointer
->	O
mf_offset	int
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
bhp	pointer
,	O
BH_DIRTY	int
)	O
)	O
{	O
++	O
bhp	pointer
->	O
ref	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___memp_bhwrite	function
(	O
dbmp	pointer
,	O
bh_mfp	pointer
,	O
bhp	pointer
,	O
&	O
restart	int
,	O
&	O
wrote	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
--	O
bhp	pointer
->	O
ref	int
;	O
if	O
(	O
bhp	pointer
->	O
ref	int
!=	O
0	int
)	O
goto	O
retry	O
;	O
if	O
(	O
wrote	int
)	O
++	O
c_mp	pointer
->	O
stat	pointer
.	O
st_rw_evict	int
;	O
else	O
{	O
if	O
(	O
restart	int
)	O
goto	O
retry	O
;	O
continue	O
;	O
}	O
}	O
else	O
++	O
c_mp	pointer
->	O
stat	pointer
.	O
st_ro_evict	int
;	O
if	O
(	O
mfp	pointer
!=	O
NULL	O
&&	O
mfp	pointer
->	O
stat	pointer
.	O
st_pagesize	long
==	O
bh_mfp	pointer
->	O
stat	pointer
.	O
st_pagesize	long
)	O
{	O
CDB___memp_bhfree	function
(	O
dbmp	pointer
,	O
bhp	pointer
,	O
0	int
)	O
;	O
if	O
(	O
offsetp	pointer
!=	O
NULL	O
)	O
*	O
offsetp	pointer
=	O
R_OFFSET	O
(	O
memreg	pointer
,	O
bhp	pointer
)	O
;	O
*	O
(	O
void	O
*	O
*	O
)	O
retp	pointer
=	O
bhp	pointer
;	O
return	O
(	O
0	int
)	O
;	O
}	O
total	long
+=	O
CDB___db_shsizeof	function
(	O
bhp	pointer
)	O
;	O
CDB___memp_bhfree	function
(	O
dbmp	pointer
,	O
bhp	pointer
,	O
1	int
)	O
;	O
if	O
(	O
total	long
>=	O
3	int
*	O
len	long
)	O
goto	O
alloc	O
;	O
if	O
(	O
restart	int
)	O
goto	O
retry	O
;	O
}	O
nomore	int
=	O
1	int
;	O
goto	O
alloc	O
;	O
}	O
