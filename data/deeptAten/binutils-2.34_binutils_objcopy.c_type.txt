static	O
bfd_vma	long
pe_file_alignment	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
static	O
bfd_vma	long
pe_heap_commit	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
static	O
bfd_vma	long
pe_heap_reserve	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
static	O
bfd_vma	long
pe_image_base	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
static	O
bfd_vma	long
pe_section_alignment	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
static	O
bfd_vma	long
pe_stack_commit	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
static	O
bfd_vma	long
pe_stack_reserve	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
static	O
short	O
pe_subsystem	short
=	O
-	O
1	int
;	O
static	O
short	O
pe_major_subsystem_version	short
=	O
-	O
1	int
;	O
static	O
short	O
pe_minor_subsystem_version	short
=	O
-	O
1	int
;	O
struct	O
is_specified_symbol_predicate_data	struct
{	O
const	O
char	O
*	O
name	pointer
;	O
bfd_boolean	int
found	int
;	O
}	O
;	O
struct	O
redefine_node	struct
{	O
char	O
*	O
source	pointer
;	O
char	O
*	O
target	pointer
;	O
}	O
;	O
struct	O
addsym_node	struct
{	O
struct	O
addsym_node	struct
*	O
next	pointer
;	O
char	O
*	O
symdef	pointer
;	O
long	O
symval	long
;	O
flagword	int
flags	int
;	O
char	O
*	O
section	pointer
;	O
const	O
char	O
*	O
othersym	pointer
;	O
}	O
;	O
typedef	O
struct	O
section_rename	struct
{	O
const	O
char	O
*	O
old_name	pointer
;	O
const	O
char	O
*	O
new_name	pointer
;	O
flagword	int
flags	int
;	O
struct	O
section_rename	struct
*	O
next	pointer
;	O
}	O
section_rename	struct
;	O
static	O
section_rename	struct
*	O
section_rename_list	pointer
;	O
static	O
asymbol	struct
*	O
*	O
isympp	pointer
=	O
NULL	O
;	O
static	O
asymbol	struct
*	O
*	O
osympp	pointer
=	O
NULL	O
;	O
static	O
int	O
copy_byte	int
=	O
-	O
1	int
;	O
static	O
int	O
interleave	int
=	O
0	int
;	O
static	O
int	O
copy_width	int
=	O
1	int
;	O
static	O
bfd_boolean	int
verbose	int
;	O
static	O
bfd_boolean	int
preserve_dates	int
;	O
static	O
int	O
deterministic	int
=	O
-	O
1	int
;	O
static	O
int	O
status	int
=	O
0	int
;	O
static	O
bfd_boolean	int
merge_notes	int
=	O
FALSE	int
;	O
typedef	O
struct	O
merged_note_section	struct
{	O
asection	struct
*	O
sec	pointer
;	O
bfd_byte	char
*	O
contents	pointer
;	O
bfd_size_type	long
size	int
;	O
struct	O
merged_note_section	struct
*	O
next	pointer
;	O
}	O
merged_note_section	struct
;	O
enum	O
strip_action	enum
{	O
STRIP_UNDEF	int
,	O
STRIP_NONE	int
,	O
STRIP_DEBUG	int
,	O
STRIP_UNNEEDED	int
,	O
STRIP_NONDEBUG	int
,	O
STRIP_DWO	int
,	O
STRIP_NONDWO	int
,	O
STRIP_ALL	int
}	O
;	O
static	O
enum	O
strip_action	enum
strip_symbols	enum
=	O
STRIP_UNDEF	int
;	O
enum	O
locals_action	enum
{	O
LOCALS_UNDEF	int
,	O
LOCALS_START_L	int
,	O
LOCALS_ALL	int
}	O
;	O
static	O
enum	O
locals_action	enum
discard_locals	enum
;	O
struct	O
section_list	struct
{	O
struct	O
section_list	struct
*	O
next	pointer
;	O
const	O
char	O
*	O
pattern	pointer
;	O
bfd_boolean	int
used	int
;	O
unsigned	O
int	O
context	int
;	O
bfd_vma	long
vma_val	long
;	O
bfd_vma	long
lma_val	long
;	O
flagword	int
flags	int
;	O
unsigned	O
int	O
alignment	int
;	O
}	O
;	O
static	O
struct	O
section_list	struct
*	O
change_sections	pointer
;	O
static	O
bfd_boolean	int
sections_removed	int
;	O
static	O
bfd_boolean	int
sections_copied	int
;	O
static	O
bfd_vma	long
change_start	long
=	O
0	int
;	O
static	O
bfd_boolean	int
set_start_set	int
=	O
FALSE	int
;	O
static	O
bfd_vma	long
set_start	long
;	O
static	O
bfd_vma	long
change_section_address	long
=	O
0	int
;	O
static	O
bfd_boolean	int
gap_fill_set	int
=	O
FALSE	int
;	O
static	O
bfd_byte	char
gap_fill	char
=	O
0	int
;	O
static	O
bfd_boolean	int
pad_to_set	int
=	O
FALSE	int
;	O
static	O
bfd_vma	long
pad_to	long
;	O
static	O
unsigned	O
long	O
use_alt_mach_code	long
=	O
0	int
;	O
static	O
flagword	int
bfd_flags_to_set	int
;	O
static	O
flagword	int
bfd_flags_to_clear	int
;	O
struct	O
section_add	struct
{	O
struct	O
section_add	struct
*	O
next	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
const	O
char	O
*	O
filename	pointer
;	O
size_t	long
size	int
;	O
bfd_byte	char
*	O
contents	pointer
;	O
asection	struct
*	O
section	pointer
;	O
}	O
;	O
static	O
struct	O
section_add	struct
*	O
add_sections	pointer
;	O
static	O
struct	O
section_add	struct
*	O
update_sections	pointer
;	O
static	O
struct	O
section_add	struct
*	O
dump_sections	pointer
;	O
static	O
const	O
char	O
*	O
gnu_debuglink_filename	pointer
=	O
NULL	O
;	O
static	O
bfd_boolean	int
convert_debugging	int
=	O
FALSE	int
;	O
static	O
enum	O
{	O
nothing	int
=	O
0	int
,	O
compress	int
=	O
1	int
<<	O
0	int
,	O
compress_zlib	int
=	O
compress	int
|	O
1	int
<<	O
1	int
,	O
compress_gnu_zlib	int
=	O
compress	int
|	O
1	int
<<	O
2	int
,	O
compress_gabi_zlib	int
=	O
compress	int
|	O
1	int
<<	O
3	int
,	O
decompress	int
=	O
1	int
<<	O
4	int
}	O
do_debug_sections	enum
=	O
nothing	int
;	O
static	O
enum	O
bfd_link_elf_stt_common	enum
do_elf_stt_common	enum
=	O
unchanged	int
;	O
static	O
bfd_boolean	int
change_leading_char	int
=	O
FALSE	int
;	O
static	O
bfd_boolean	int
remove_leading_char	int
=	O
FALSE	int
;	O
static	O
bfd_boolean	int
wildcard	int
=	O
FALSE	int
;	O
static	O
bfd_boolean	int
localize_hidden	int
=	O
FALSE	int
;	O
static	O
htab_t	pointer
strip_specific_htab	pointer
=	O
NULL	O
;	O
static	O
htab_t	pointer
strip_unneeded_htab	pointer
=	O
NULL	O
;	O
static	O
htab_t	pointer
keep_specific_htab	pointer
=	O
NULL	O
;	O
static	O
htab_t	pointer
localize_specific_htab	pointer
=	O
NULL	O
;	O
static	O
htab_t	pointer
globalize_specific_htab	pointer
=	O
NULL	O
;	O
static	O
htab_t	pointer
keepglobal_specific_htab	pointer
=	O
NULL	O
;	O
static	O
htab_t	pointer
weaken_specific_htab	pointer
=	O
NULL	O
;	O
static	O
htab_t	pointer
redefine_specific_htab	pointer
=	O
NULL	O
;	O
static	O
htab_t	pointer
redefine_specific_reverse_htab	pointer
=	O
NULL	O
;	O
static	O
struct	O
addsym_node	struct
*	O
add_sym_list	pointer
=	O
NULL	O
,	O
*	O
*	O
add_sym_tail	pointer
=	O
&	O
add_sym_list	pointer
;	O
static	O
int	O
add_symbols	int
=	O
0	int
;	O
static	O
char	O
*	O
strip_specific_buffer	pointer
=	O
NULL	O
;	O
static	O
char	O
*	O
strip_unneeded_buffer	pointer
=	O
NULL	O
;	O
static	O
char	O
*	O
keep_specific_buffer	pointer
=	O
NULL	O
;	O
static	O
char	O
*	O
localize_specific_buffer	pointer
=	O
NULL	O
;	O
static	O
char	O
*	O
globalize_specific_buffer	pointer
=	O
NULL	O
;	O
static	O
char	O
*	O
keepglobal_specific_buffer	pointer
=	O
NULL	O
;	O
static	O
char	O
*	O
weaken_specific_buffer	pointer
=	O
NULL	O
;	O
static	O
bfd_boolean	int
weaken	int
=	O
FALSE	int
;	O
static	O
bfd_boolean	int
keep_file_symbols	int
=	O
FALSE	int
;	O
static	O
char	O
*	O
prefix_symbols_string	pointer
=	O
0	int
;	O
static	O
char	O
*	O
prefix_sections_string	pointer
=	O
0	int
;	O
static	O
char	O
*	O
prefix_alloc_sections_string	pointer
=	O
0	int
;	O
static	O
bfd_boolean	int
extract_symbol	int
=	O
FALSE	int
;	O
static	O
int	O
reverse_bytes	int
=	O
0	int
;	O
enum	O
long_section_name_handling	enum
{	O
DISABLE	int
,	O
ENABLE	int
,	O
KEEP	int
}	O
;	O
static	O
enum	O
long_section_name_handling	enum
long_section_names	enum
=	O
KEEP	int
;	O
enum	O
command_line_switch	enum
{	O
OPTION_ADD_SECTION	int
=	O
150	int
,	O
OPTION_ADD_GNU_DEBUGLINK	int
,	O
OPTION_ADD_SYMBOL	int
,	O
OPTION_ALT_MACH_CODE	int
,	O
OPTION_CHANGE_ADDRESSES	int
,	O
OPTION_CHANGE_LEADING_CHAR	int
,	O
OPTION_CHANGE_SECTION_ADDRESS	int
,	O
OPTION_CHANGE_SECTION_LMA	int
,	O
OPTION_CHANGE_SECTION_VMA	int
,	O
OPTION_CHANGE_START	int
,	O
OPTION_CHANGE_WARNINGS	int
,	O
OPTION_COMPRESS_DEBUG_SECTIONS	int
,	O
OPTION_DEBUGGING	int
,	O
OPTION_DECOMPRESS_DEBUG_SECTIONS	int
,	O
OPTION_DUMP_SECTION	int
,	O
OPTION_ELF_STT_COMMON	int
,	O
OPTION_EXTRACT_DWO	int
,	O
OPTION_EXTRACT_SYMBOL	int
,	O
OPTION_FILE_ALIGNMENT	int
,	O
OPTION_FORMATS_INFO	int
,	O
OPTION_GAP_FILL	int
,	O
OPTION_GLOBALIZE_SYMBOL	int
,	O
OPTION_GLOBALIZE_SYMBOLS	int
,	O
OPTION_HEAP	int
,	O
OPTION_IMAGE_BASE	int
,	O
OPTION_IMPURE	int
,	O
OPTION_INTERLEAVE_WIDTH	int
,	O
OPTION_KEEPGLOBAL_SYMBOLS	int
,	O
OPTION_KEEP_FILE_SYMBOLS	int
,	O
OPTION_KEEP_SECTION	int
,	O
OPTION_KEEP_SYMBOLS	int
,	O
OPTION_LOCALIZE_HIDDEN	int
,	O
OPTION_LOCALIZE_SYMBOLS	int
,	O
OPTION_LONG_SECTION_NAMES	int
,	O
OPTION_MERGE_NOTES	int
,	O
OPTION_NO_MERGE_NOTES	int
,	O
OPTION_NO_CHANGE_WARNINGS	int
,	O
OPTION_ONLY_KEEP_DEBUG	int
,	O
OPTION_PAD_TO	int
,	O
OPTION_PREFIX_ALLOC_SECTIONS	int
,	O
OPTION_PREFIX_SECTIONS	int
,	O
OPTION_PREFIX_SYMBOLS	int
,	O
OPTION_PURE	int
,	O
OPTION_READONLY_TEXT	int
,	O
OPTION_REDEFINE_SYM	int
,	O
OPTION_REDEFINE_SYMS	int
,	O
OPTION_REMOVE_LEADING_CHAR	int
,	O
OPTION_REMOVE_RELOCS	int
,	O
OPTION_RENAME_SECTION	int
,	O
OPTION_REVERSE_BYTES	int
,	O
OPTION_PE_SECTION_ALIGNMENT	int
,	O
OPTION_SET_SECTION_FLAGS	int
,	O
OPTION_SET_SECTION_ALIGNMENT	int
,	O
OPTION_SET_START	int
,	O
OPTION_SREC_FORCES3	int
,	O
OPTION_SREC_LEN	int
,	O
OPTION_STACK	int
,	O
OPTION_STRIP_DWO	int
,	O
OPTION_STRIP_SYMBOLS	int
,	O
OPTION_STRIP_UNNEEDED	int
,	O
OPTION_STRIP_UNNEEDED_SYMBOL	int
,	O
OPTION_STRIP_UNNEEDED_SYMBOLS	int
,	O
OPTION_SUBSYSTEM	int
,	O
OPTION_UPDATE_SECTION	int
,	O
OPTION_VERILOG_DATA_WIDTH	int
,	O
OPTION_WEAKEN	int
,	O
OPTION_WEAKEN_SYMBOLS	int
,	O
OPTION_WRITABLE_TEXT	int
}	O
;	O
static	O
struct	O
option	struct
strip_options	array
[	O
]	O
=	O
{	O
{	O
"disable-deterministic-archives"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'U'	O
}	O
,	O
{	O
"discard-all"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'x'	O
}	O
,	O
{	O
"discard-locals"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'X'	O
}	O
,	O
{	O
"enable-deterministic-archives"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'D'	O
}	O
,	O
{	O
"format"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'F'	O
}	O
,	O
{	O
"help"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'h'	O
}	O
,	O
{	O
"info"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_FORMATS_INFO	int
}	O
,	O
{	O
"input-format"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'I'	O
}	O
,	O
{	O
"input-target"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'I'	O
}	O
,	O
{	O
"keep-file-symbols"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_KEEP_FILE_SYMBOLS	int
}	O
,	O
{	O
"keep-section"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_KEEP_SECTION	int
}	O
,	O
{	O
"keep-symbol"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'K'	O
}	O
,	O
{	O
"merge-notes"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'M'	O
}	O
,	O
{	O
"no-merge-notes"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_NO_MERGE_NOTES	int
}	O
,	O
{	O
"only-keep-debug"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_ONLY_KEEP_DEBUG	int
}	O
,	O
{	O
"output-file"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'o'	O
}	O
,	O
{	O
"output-format"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'O'	O
}	O
,	O
{	O
"output-target"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'O'	O
}	O
,	O
{	O
"preserve-dates"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'p'	O
}	O
,	O
{	O
"remove-section"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'R'	O
}	O
,	O
{	O
"remove-relocations"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_REMOVE_RELOCS	int
}	O
,	O
{	O
"strip-all"	pointer
,	O
no_argument	int
,	O
0	int
,	O
's'	O
}	O
,	O
{	O
"strip-debug"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'S'	O
}	O
,	O
{	O
"strip-dwo"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_STRIP_DWO	int
}	O
,	O
{	O
"strip-symbol"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'N'	O
}	O
,	O
{	O
"strip-unneeded"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_STRIP_UNNEEDED	int
}	O
,	O
{	O
"target"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'F'	O
}	O
,	O
{	O
"verbose"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'v'	O
}	O
,	O
{	O
"version"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'V'	O
}	O
,	O
{	O
"wildcard"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'w'	O
}	O
,	O
{	O
0	int
,	O
no_argument	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
struct	O
option	struct
copy_options	array
[	O
]	O
=	O
{	O
{	O
"add-gnu-debuglink"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_ADD_GNU_DEBUGLINK	int
}	O
,	O
{	O
"add-section"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_ADD_SECTION	int
}	O
,	O
{	O
"add-symbol"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_ADD_SYMBOL	int
}	O
,	O
{	O
"adjust-section-vma"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_CHANGE_SECTION_ADDRESS	int
}	O
,	O
{	O
"adjust-start"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_CHANGE_START	int
}	O
,	O
{	O
"adjust-vma"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_CHANGE_ADDRESSES	int
}	O
,	O
{	O
"adjust-warnings"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_CHANGE_WARNINGS	int
}	O
,	O
{	O
"alt-machine-code"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_ALT_MACH_CODE	int
}	O
,	O
{	O
"binary-architecture"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'B'	O
}	O
,	O
{	O
"byte"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'b'	O
}	O
,	O
{	O
"change-addresses"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_CHANGE_ADDRESSES	int
}	O
,	O
{	O
"change-leading-char"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_CHANGE_LEADING_CHAR	int
}	O
,	O
{	O
"change-section-address"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_CHANGE_SECTION_ADDRESS	int
}	O
,	O
{	O
"change-section-lma"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_CHANGE_SECTION_LMA	int
}	O
,	O
{	O
"change-section-vma"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_CHANGE_SECTION_VMA	int
}	O
,	O
{	O
"change-start"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_CHANGE_START	int
}	O
,	O
{	O
"change-warnings"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_CHANGE_WARNINGS	int
}	O
,	O
{	O
"compress-debug-sections"	pointer
,	O
optional_argument	int
,	O
0	int
,	O
OPTION_COMPRESS_DEBUG_SECTIONS	int
}	O
,	O
{	O
"debugging"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_DEBUGGING	int
}	O
,	O
{	O
"decompress-debug-sections"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_DECOMPRESS_DEBUG_SECTIONS	int
}	O
,	O
{	O
"disable-deterministic-archives"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'U'	O
}	O
,	O
{	O
"discard-all"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'x'	O
}	O
,	O
{	O
"discard-locals"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'X'	O
}	O
,	O
{	O
"dump-section"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_DUMP_SECTION	int
}	O
,	O
{	O
"elf-stt-common"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_ELF_STT_COMMON	int
}	O
,	O
{	O
"enable-deterministic-archives"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'D'	O
}	O
,	O
{	O
"extract-dwo"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_EXTRACT_DWO	int
}	O
,	O
{	O
"extract-symbol"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_EXTRACT_SYMBOL	int
}	O
,	O
{	O
"file-alignment"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_FILE_ALIGNMENT	int
}	O
,	O
{	O
"format"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'F'	O
}	O
,	O
{	O
"gap-fill"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_GAP_FILL	int
}	O
,	O
{	O
"globalize-symbol"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_GLOBALIZE_SYMBOL	int
}	O
,	O
{	O
"globalize-symbols"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_GLOBALIZE_SYMBOLS	int
}	O
,	O
{	O
"heap"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_HEAP	int
}	O
,	O
{	O
"help"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'h'	O
}	O
,	O
{	O
"image-base"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_IMAGE_BASE	int
}	O
,	O
{	O
"impure"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_IMPURE	int
}	O
,	O
{	O
"info"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_FORMATS_INFO	int
}	O
,	O
{	O
"input-format"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'I'	O
}	O
,	O
{	O
"input-target"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'I'	O
}	O
,	O
{	O
"interleave"	pointer
,	O
optional_argument	int
,	O
0	int
,	O
'i'	O
}	O
,	O
{	O
"interleave-width"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_INTERLEAVE_WIDTH	int
}	O
,	O
{	O
"keep-file-symbols"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_KEEP_FILE_SYMBOLS	int
}	O
,	O
{	O
"keep-global-symbol"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'G'	O
}	O
,	O
{	O
"keep-global-symbols"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_KEEPGLOBAL_SYMBOLS	int
}	O
,	O
{	O
"keep-section"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_KEEP_SECTION	int
}	O
,	O
{	O
"keep-symbol"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'K'	O
}	O
,	O
{	O
"keep-symbols"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_KEEP_SYMBOLS	int
}	O
,	O
{	O
"localize-hidden"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_LOCALIZE_HIDDEN	int
}	O
,	O
{	O
"localize-symbol"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'L'	O
}	O
,	O
{	O
"localize-symbols"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_LOCALIZE_SYMBOLS	int
}	O
,	O
{	O
"long-section-names"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_LONG_SECTION_NAMES	int
}	O
,	O
{	O
"merge-notes"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'M'	O
}	O
,	O
{	O
"no-merge-notes"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_NO_MERGE_NOTES	int
}	O
,	O
{	O
"no-adjust-warnings"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_NO_CHANGE_WARNINGS	int
}	O
,	O
{	O
"no-change-warnings"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_NO_CHANGE_WARNINGS	int
}	O
,	O
{	O
"only-keep-debug"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_ONLY_KEEP_DEBUG	int
}	O
,	O
{	O
"only-section"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'j'	O
}	O
,	O
{	O
"output-format"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'O'	O
}	O
,	O
{	O
"output-target"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'O'	O
}	O
,	O
{	O
"pad-to"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_PAD_TO	int
}	O
,	O
{	O
"prefix-alloc-sections"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_PREFIX_ALLOC_SECTIONS	int
}	O
,	O
{	O
"prefix-sections"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_PREFIX_SECTIONS	int
}	O
,	O
{	O
"prefix-symbols"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_PREFIX_SYMBOLS	int
}	O
,	O
{	O
"preserve-dates"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'p'	O
}	O
,	O
{	O
"pure"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_PURE	int
}	O
,	O
{	O
"readonly-text"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_READONLY_TEXT	int
}	O
,	O
{	O
"redefine-sym"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_REDEFINE_SYM	int
}	O
,	O
{	O
"redefine-syms"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_REDEFINE_SYMS	int
}	O
,	O
{	O
"remove-leading-char"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_REMOVE_LEADING_CHAR	int
}	O
,	O
{	O
"remove-section"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'R'	O
}	O
,	O
{	O
"remove-relocations"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_REMOVE_RELOCS	int
}	O
,	O
{	O
"rename-section"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_RENAME_SECTION	int
}	O
,	O
{	O
"reverse-bytes"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_REVERSE_BYTES	int
}	O
,	O
{	O
"section-alignment"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_PE_SECTION_ALIGNMENT	int
}	O
,	O
{	O
"set-section-flags"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_SET_SECTION_FLAGS	int
}	O
,	O
{	O
"set-section-alignment"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_SET_SECTION_ALIGNMENT	int
}	O
,	O
{	O
"set-start"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_SET_START	int
}	O
,	O
{	O
"srec-forceS3"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_SREC_FORCES3	int
}	O
,	O
{	O
"srec-len"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_SREC_LEN	int
}	O
,	O
{	O
"stack"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_STACK	int
}	O
,	O
{	O
"strip-all"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'S'	O
}	O
,	O
{	O
"strip-debug"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'g'	O
}	O
,	O
{	O
"strip-dwo"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_STRIP_DWO	int
}	O
,	O
{	O
"strip-symbol"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'N'	O
}	O
,	O
{	O
"strip-symbols"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_STRIP_SYMBOLS	int
}	O
,	O
{	O
"strip-unneeded"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_STRIP_UNNEEDED	int
}	O
,	O
{	O
"strip-unneeded-symbol"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_STRIP_UNNEEDED_SYMBOL	int
}	O
,	O
{	O
"strip-unneeded-symbols"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_STRIP_UNNEEDED_SYMBOLS	int
}	O
,	O
{	O
"subsystem"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_SUBSYSTEM	int
}	O
,	O
{	O
"target"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'F'	O
}	O
,	O
{	O
"update-section"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_UPDATE_SECTION	int
}	O
,	O
{	O
"verbose"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'v'	O
}	O
,	O
{	O
"verilog-data-width"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_VERILOG_DATA_WIDTH	int
}	O
,	O
{	O
"version"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'V'	O
}	O
,	O
{	O
"weaken"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_WEAKEN	int
}	O
,	O
{	O
"weaken-symbol"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'W'	O
}	O
,	O
{	O
"weaken-symbols"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_WEAKEN_SYMBOLS	int
}	O
,	O
{	O
"wildcard"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'w'	O
}	O
,	O
{	O
"writable-text"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPTION_WRITABLE_TEXT	int
}	O
,	O
{	O
0	int
,	O
no_argument	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
extern	O
char	O
*	O
program_name	pointer
;	O
extern	O
int	O
is_strip	int
;	O
extern	O
unsigned	O
int	O
_bfd_srec_len	int
;	O
extern	O
bfd_boolean	int
_bfd_srec_forceS3	int
;	O
extern	O
unsigned	O
int	O
VerilogDataWidth	int
;	O
static	O
void	O
setup_section	function
(	O
bfd	struct
*	O
,	O
asection	struct
*	O
,	O
void	O
*	O
)	O
;	O
static	O
void	O
setup_bfd_headers	function
(	O
bfd	struct
*	O
,	O
bfd	struct
*	O
)	O
;	O
static	O
void	O
copy_relocations_in_section	function
(	O
bfd	struct
*	O
,	O
asection	struct
*	O
,	O
void	O
*	O
)	O
;	O
static	O
void	O
copy_section	function
(	O
bfd	struct
*	O
,	O
asection	struct
*	O
,	O
void	O
*	O
)	O
;	O
static	O
void	O
get_sections	function
(	O
bfd	struct
*	O
,	O
asection	struct
*	O
,	O
void	O
*	O
)	O
;	O
static	O
int	O
compare_section_lma	function
(	O
const	O
void	O
*	O
,	O
const	O
void	O
*	O
)	O
;	O
static	O
void	O
mark_symbols_used_in_relocations	function
(	O
bfd	struct
*	O
,	O
asection	struct
*	O
,	O
void	O
*	O
)	O
;	O
static	O
bfd_boolean	int
write_debugging_info	function
(	O
bfd	struct
*	O
,	O
void	O
*	O
,	O
long	O
*	O
,	O
asymbol	struct
*	O
*	O
*	O
)	O
;	O
static	O
const	O
char	O
*	O
lookup_sym_redefinition	function
(	O
const	O
char	O
*	O
)	O
;	O
static	O
const	O
char	O
*	O
find_section_rename	function
(	O
const	O
char	O
*	O
,	O
flagword	int
*	O
)	O
;	O
ATTRIBUTE_NORETURN	O
static	O
void	O
copy_usage	function
(	O
FILE	struct
*	O
stream	pointer
,	O
int	O
exit_status	int
)	O
{	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"Usage: %s [option(s)] in-file [out-file]\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
" Copies a binary file, possibly transforming it in the process\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
" The options are:\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"  -I --input-target <bfdname>      Assume input file is in format <bfdname>\n  -O --output-target <bfdname>     Create an output file in format <bfdname>\n  -B --binary-architecture <arch>  Set output arch, when input is arch-less\n  -F --target <bfdname>            Set both input and output format to <bfdname>\n     --debugging                   Convert debugging information, if possible\n  -p --preserve-dates              Copy modified/access timestamps to the output\n"	pointer
)	O
)	O
;	O
if	O
(	O
DEFAULT_AR_DETERMINISTIC	int
)	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"  -D --enable-deterministic-archives\n                                   Produce deterministic output when stripping archives (default)\n  -U --disable-deterministic-archives\n                                   Disable -D behavior\n"	pointer
)	O
)	O
;	O
else	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"  -D --enable-deterministic-archives\n                                   Produce deterministic output when stripping archives\n  -U --disable-deterministic-archives\n                                   Disable -D behavior (default)\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"  -j --only-section <name>         Only copy section <name> into the output\n     --add-gnu-debuglink=<file>    Add section .gnu_debuglink linking to <file>\n  -R --remove-section <name>       Remove section <name> from the output\n     --remove-relocations <name>   Remove relocations from section <name>\n  -S --strip-all                   Remove all symbol and relocation information\n  -g --strip-debug                 Remove all debugging symbols & sections\n     --strip-dwo                   Remove all DWO sections\n     --strip-unneeded              Remove all symbols not needed by relocations\n  -N --strip-symbol <name>         Do not copy symbol <name>\n     --strip-unneeded-symbol <name>\n                                   Do not copy symbol <name> unless needed by\n                                     relocations\n     --only-keep-debug             Strip everything but the debug information\n     --extract-dwo                 Copy only DWO sections\n     --extract-symbol              Remove section contents but keep symbols\n     --keep-section <name>         Do not strip section <name>\n  -K --keep-symbol <name>          Do not strip symbol <name>\n     --keep-file-symbols           Do not strip file symbol(s)\n     --localize-hidden             Turn all ELF hidden symbols into locals\n  -L --localize-symbol <name>      Force symbol <name> to be marked as a local\n     --globalize-symbol <name>     Force symbol <name> to be marked as a global\n  -G --keep-global-symbol <name>   Localize all symbols except <name>\n  -W --weaken-symbol <name>        Force symbol <name> to be marked as a weak\n     --weaken                      Force all global symbols to be marked as weak\n  -w --wildcard                    Permit wildcard in symbol comparison\n  -x --discard-all                 Remove all non-global symbols\n  -X --discard-locals              Remove any compiler-generated symbols\n  -i --interleave[=<number>]       Only copy N out of every <number> bytes\n     --interleave-width <number>   Set N for --interleave\n  -b --byte <num>                  Select byte <num> in every interleaved block\n     --gap-fill <val>              Fill gaps between sections with <val>\n     --pad-to <addr>               Pad the last section up to address <addr>\n     --set-start <addr>            Set the start address to <addr>\n    {--change-start|--adjust-start} <incr>\n                                   Add <incr> to the start address\n    {--change-addresses|--adjust-vma} <incr>\n                                   Add <incr> to LMA, VMA and start addresses\n    {--change-section-address|--adjust-section-vma} <name>{=|+|-}<val>\n                                   Change LMA and VMA of section <name> by <val>\n     --change-section-lma <name>{=|+|-}<val>\n                                   Change the LMA of section <name> by <val>\n     --change-section-vma <name>{=|+|-}<val>\n                                   Change the VMA of section <name> by <val>\n    {--[no-]change-warnings|--[no-]adjust-warnings}\n                                   Warn if a named section does not exist\n     --set-section-flags <name>=<flags>\n                                   Set section <name>'s properties to <flags>\n     --set-section-alignment <name>=<align>\n                                   Set section <name>'s alignment to <align> bytes\n     --add-section <name>=<file>   Add section <name> found in <file> to output\n     --update-section <name>=<file>\n                                   Update contents of section <name> with\n                                   contents found in <file>\n     --dump-section <name>=<file>  Dump the contents of section <name> into <file>\n     --rename-section <old>=<new>[,<flags>] Rename section <old> to <new>\n     --long-section-names {enable|disable|keep}\n                                   Handle long section names in Coff objects.\n     --change-leading-char         Force output format's leading character style\n     --remove-leading-char         Remove leading character from global symbols\n     --reverse-bytes=<num>         Reverse <num> bytes at a time, in output sections with content\n     --redefine-sym <old>=<new>    Redefine symbol name <old> to <new>\n     --redefine-syms <file>        --redefine-sym for all symbol pairs \n                                     listed in <file>\n     --srec-len <number>           Restrict the length of generated Srecords\n     --srec-forceS3                Restrict the type of generated Srecords to S3\n     --strip-symbols <file>        -N for all symbols listed in <file>\n     --strip-unneeded-symbols <file>\n                                   --strip-unneeded-symbol for all symbols listed\n                                     in <file>\n     --keep-symbols <file>         -K for all symbols listed in <file>\n     --localize-symbols <file>     -L for all symbols listed in <file>\n     --globalize-symbols <file>    --globalize-symbol for all in <file>\n     --keep-global-symbols <file>  -G for all symbols listed in <file>\n     --weaken-symbols <file>       -W for all symbols listed in <file>\n     --add-symbol <name>=[<section>:]<value>[,<flags>]  Add a symbol\n     --alt-machine-code <index>    Use the target's <index>'th alternative machine\n     --writable-text               Mark the output text as writable\n     --readonly-text               Make the output text write protected\n     --pure                        Mark the output file as demand paged\n     --impure                      Mark the output file as impure\n     --prefix-symbols <prefix>     Add <prefix> to start of every symbol name\n     --prefix-sections <prefix>    Add <prefix> to start of every section name\n     --prefix-alloc-sections <prefix>\n                                   Add <prefix> to start of every allocatable\n                                     section name\n     --file-alignment <num>        Set PE file alignment to <num>\n     --heap <reserve>[,<commit>]   Set PE reserve/commit heap to <reserve>/\n                                   <commit>\n     --image-base <address>        Set PE image base to <address>\n     --section-alignment <num>     Set PE section alignment to <num>\n     --stack <reserve>[,<commit>]  Set PE reserve/commit stack to <reserve>/\n                                   <commit>\n     --subsystem <name>[:<version>]\n                                   Set PE subsystem to <name> [& <version>]\n     --compress-debug-sections[={none|zlib|zlib-gnu|zlib-gabi}]\n                                   Compress DWARF debug sections using zlib\n     --decompress-debug-sections   Decompress DWARF debug sections using zlib\n     --elf-stt-common=[yes|no]     Generate ELF common symbols with STT_COMMON\n                                     type\n     --verilog-data-width <number> Specifies data width, in bytes, for verilog output\n  -M  --merge-notes                Remove redundant entries in note sections\n      --no-merge-notes             Do not attempt to remove redundant notes (default)\n  -v --verbose                     List all object files modified\n  @<file>                          Read options from <file>\n  -V --version                     Display this program's version number\n  -h --help                        Display this output\n     --info                        List object formats & architectures supported\n"	pointer
)	O
)	O
;	O
list_supported_targets	function
(	O
program_name	pointer
,	O
stream	pointer
)	O
;	O
if	O
(	O
REPORT_BUGS_TO	pointer
[	O
0	int
]	O
&&	O
exit_status	int
==	O
0	int
)	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"Report bugs to %s\n"	pointer
)	O
,	O
REPORT_BUGS_TO	pointer
)	O
;	O
exit	function
(	O
exit_status	int
)	O
;	O
}	O
ATTRIBUTE_NORETURN	O
static	O
void	O
strip_usage	function
(	O
FILE	struct
*	O
stream	pointer
,	O
int	O
exit_status	int
)	O
{	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"Usage: %s <option(s)> in-file(s)\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
" Removes symbols and sections from files\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
" The options are:\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"  -I --input-target=<bfdname>      Assume input file is in format <bfdname>\n  -O --output-target=<bfdname>     Create an output file in format <bfdname>\n  -F --target=<bfdname>            Set both input and output format to <bfdname>\n  -p --preserve-dates              Copy modified/access timestamps to the output\n"	pointer
)	O
)	O
;	O
if	O
(	O
DEFAULT_AR_DETERMINISTIC	int
)	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"  -D --enable-deterministic-archives\n                                   Produce deterministic output when stripping archives (default)\n  -U --disable-deterministic-archives\n                                   Disable -D behavior\n"	pointer
)	O
)	O
;	O
else	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"  -D --enable-deterministic-archives\n                                   Produce deterministic output when stripping archives\n  -U --disable-deterministic-archives\n                                   Disable -D behavior (default)\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"  -R --remove-section=<name>       Also remove section <name> from the output\n     --remove-relocations <name>   Remove relocations from section <name>\n  -s --strip-all                   Remove all symbol and relocation information\n  -g -S -d --strip-debug           Remove all debugging symbols & sections\n     --strip-dwo                   Remove all DWO sections\n     --strip-unneeded              Remove all symbols not needed by relocations\n     --only-keep-debug             Strip everything but the debug information\n  -M  --merge-notes                Remove redundant entries in note sections (default)\n      --no-merge-notes             Do not attempt to remove redundant notes\n  -N --strip-symbol=<name>         Do not copy symbol <name>\n     --keep-section=<name>         Do not strip section <name>\n  -K --keep-symbol=<name>          Do not strip symbol <name>\n     --keep-file-symbols           Do not strip file symbol(s)\n  -w --wildcard                    Permit wildcard in symbol comparison\n  -x --discard-all                 Remove all non-global symbols\n  -X --discard-locals              Remove any compiler-generated symbols\n  -v --verbose                     List all object files modified\n  -V --version                     Display this program's version number\n  -h --help                        Display this output\n     --info                        List object formats & architectures supported\n  -o <file>                        Place stripped output into <file>\n"	pointer
)	O
)	O
;	O
list_supported_targets	function
(	O
program_name	pointer
,	O
stream	pointer
)	O
;	O
if	O
(	O
REPORT_BUGS_TO	pointer
[	O
0	int
]	O
&&	O
exit_status	int
==	O
0	int
)	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"Report bugs to %s\n"	pointer
)	O
,	O
REPORT_BUGS_TO	pointer
)	O
;	O
exit	function
(	O
exit_status	int
)	O
;	O
}	O
static	O
flagword	int
parse_flags	function
(	O
const	O
char	O
*	O
s	pointer
)	O
{	O
flagword	int
ret	pointer
;	O
const	O
char	O
*	O
snext	pointer
;	O
int	O
len	long
;	O
ret	pointer
=	O
SEC_NO_FLAGS	int
;	O
do	O
{	O
snext	pointer
=	O
strchr	function
(	O
s	pointer
,	O
','	O
)	O
;	O
if	O
(	O
snext	pointer
==	O
NULL	O
)	O
len	long
=	O
strlen	function
(	O
s	pointer
)	O
;	O
else	O
{	O
len	long
=	O
snext	pointer
-	O
s	pointer
;	O
++	O
snext	pointer
;	O
}	O
if	O
(	O
0	int
)	O
;	O
PARSE_FLAG	O
(	O
"alloc"	pointer
,	O
SEC_ALLOC	int
)	O
;	O
PARSE_FLAG	O
(	O
"load"	pointer
,	O
SEC_LOAD	int
)	O
;	O
PARSE_FLAG	O
(	O
"noload"	pointer
,	O
SEC_NEVER_LOAD	int
)	O
;	O
PARSE_FLAG	O
(	O
"readonly"	pointer
,	O
SEC_READONLY	int
)	O
;	O
PARSE_FLAG	O
(	O
"debug"	pointer
,	O
SEC_DEBUGGING	int
)	O
;	O
PARSE_FLAG	O
(	O
"code"	pointer
,	O
SEC_CODE	int
)	O
;	O
PARSE_FLAG	O
(	O
"data"	pointer
,	O
SEC_DATA	int
)	O
;	O
PARSE_FLAG	O
(	O
"rom"	pointer
,	O
SEC_ROM	int
)	O
;	O
PARSE_FLAG	O
(	O
"share"	pointer
,	O
SEC_COFF_SHARED	int
)	O
;	O
PARSE_FLAG	O
(	O
"contents"	pointer
,	O
SEC_HAS_CONTENTS	int
)	O
;	O
PARSE_FLAG	O
(	O
"merge"	pointer
,	O
SEC_MERGE	int
)	O
;	O
PARSE_FLAG	O
(	O
"strings"	pointer
,	O
SEC_STRINGS	int
)	O
;	O
else	O
{	O
char	O
*	O
copy	int
;	O
copy	int
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
len	long
+	O
1	int
)	O
;	O
strncpy	function
(	O
copy	int
,	O
s	pointer
,	O
len	long
)	O
;	O
copy	int
[	O
len	long
]	O
=	O
'\0'	O
;	O
non_fatal	function
(	O
_	O
(	O
"unrecognized section flag `%s'"	pointer
)	O
,	O
copy	int
)	O
;	O
fatal	function
(	O
_	O
(	O
"supported flags: %s"	pointer
)	O
,	O
"alloc, load, noload, readonly, debug, code, data, rom, share, contents, merge, strings"	pointer
)	O
;	O
}	O
s	pointer
=	O
snext	pointer
;	O
}	O
while	O
(	O
s	pointer
!=	O
NULL	O
)	O
;	O
return	O
ret	pointer
;	O
}	O
static	O
flagword	int
parse_symflags	function
(	O
const	O
char	O
*	O
s	pointer
,	O
const	O
char	O
*	O
*	O
other	int
)	O
{	O
flagword	int
ret	pointer
;	O
const	O
char	O
*	O
snext	pointer
;	O
size_t	long
len	long
;	O
ret	pointer
=	O
BSF_NO_FLAGS	int
;	O
do	O
{	O
snext	pointer
=	O
strchr	function
(	O
s	pointer
,	O
','	O
)	O
;	O
if	O
(	O
snext	pointer
==	O
NULL	O
)	O
len	long
=	O
strlen	function
(	O
s	pointer
)	O
;	O
else	O
{	O
len	long
=	O
snext	pointer
-	O
s	pointer
;	O
++	O
snext	pointer
;	O
}	O
if	O
(	O
0	int
)	O
;	O
PARSE_FLAG	O
(	O
"local"	pointer
,	O
BSF_LOCAL	O
)	O
;	O
PARSE_FLAG	O
(	O
"global"	pointer
,	O
BSF_GLOBAL	O
)	O
;	O
PARSE_FLAG	O
(	O
"export"	pointer
,	O
BSF_EXPORT	O
)	O
;	O
PARSE_FLAG	O
(	O
"debug"	pointer
,	O
BSF_DEBUGGING	O
)	O
;	O
PARSE_FLAG	O
(	O
"function"	pointer
,	O
BSF_FUNCTION	O
)	O
;	O
PARSE_FLAG	O
(	O
"weak"	pointer
,	O
BSF_WEAK	O
)	O
;	O
PARSE_FLAG	O
(	O
"section"	pointer
,	O
BSF_SECTION_SYM	O
)	O
;	O
PARSE_FLAG	O
(	O
"constructor"	pointer
,	O
BSF_CONSTRUCTOR	O
)	O
;	O
PARSE_FLAG	O
(	O
"warning"	pointer
,	O
BSF_WARNING	O
)	O
;	O
PARSE_FLAG	O
(	O
"indirect"	pointer
,	O
BSF_INDIRECT	O
)	O
;	O
PARSE_FLAG	O
(	O
"file"	pointer
,	O
BSF_FILE	O
)	O
;	O
PARSE_FLAG	O
(	O
"object"	pointer
,	O
BSF_OBJECT	O
)	O
;	O
PARSE_FLAG	O
(	O
"synthetic"	pointer
,	O
BSF_SYNTHETIC	O
)	O
;	O
PARSE_FLAG	O
(	O
"indirect-function"	pointer
,	O
BSF_GNU_INDIRECT_FUNCTION	O
|	O
BSF_FUNCTION	O
)	O
;	O
PARSE_FLAG	O
(	O
"unique-object"	pointer
,	O
BSF_GNU_UNIQUE	O
|	O
BSF_OBJECT	O
)	O
;	O
PARSE_OTHER	O
(	O
"before="	pointer
,	O
*	O
other	int
)	O
;	O
else	O
{	O
char	O
*	O
copy	int
;	O
copy	int
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
len	long
+	O
1	int
)	O
;	O
strncpy	function
(	O
copy	int
,	O
s	pointer
,	O
len	long
)	O
;	O
copy	int
[	O
len	long
]	O
=	O
'\0'	O
;	O
non_fatal	function
(	O
_	O
(	O
"unrecognized symbol flag `%s'"	pointer
)	O
,	O
copy	int
)	O
;	O
fatal	function
(	O
_	O
(	O
"supported flags: %s"	pointer
)	O
,	O
"local, global, export, debug, function, weak, section, "	pointer
"constructor, warning, indirect, file, object, synthetic, "	pointer
"indirect-function, unique-object, before=<othersym>"	pointer
)	O
;	O
}	O
s	pointer
=	O
snext	pointer
;	O
}	O
while	O
(	O
s	pointer
!=	O
NULL	O
)	O
;	O
return	O
ret	pointer
;	O
}	O
static	O
struct	O
section_list	struct
*	O
find_section_list	function
(	O
const	O
char	O
*	O
name	pointer
,	O
bfd_boolean	int
add	int
,	O
unsigned	O
int	O
context	int
)	O
{	O
struct	O
section_list	struct
*	O
p	pointer
,	O
*	O
match	pointer
=	O
NULL	O
;	O
for	O
(	O
p	pointer
=	O
change_sections	pointer
;	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
add	int
)	O
{	O
if	O
(	O
strcmp	function
(	O
p	pointer
->	O
pattern	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
(	O
p	pointer
->	O
context	int
&	O
SECTION_CONTEXT_REMOVE	O
)	O
&&	O
(	O
context	int
&	O
SECTION_CONTEXT_COPY	O
)	O
)	O
||	O
(	O
(	O
context	int
&	O
SECTION_CONTEXT_REMOVE	O
)	O
&&	O
(	O
p	pointer
->	O
context	int
&	O
SECTION_CONTEXT_COPY	O
)	O
)	O
)	O
fatal	function
(	O
_	O
(	O
"error: %s both copied and removed"	pointer
)	O
,	O
name	pointer
)	O
;	O
if	O
(	O
(	O
(	O
p	pointer
->	O
context	int
&	O
SECTION_CONTEXT_SET_VMA	O
)	O
&&	O
(	O
context	int
&	O
SECTION_CONTEXT_ALTER_VMA	O
)	O
)	O
||	O
(	O
(	O
context	int
&	O
SECTION_CONTEXT_SET_VMA	O
)	O
&&	O
(	O
context	int
&	O
SECTION_CONTEXT_ALTER_VMA	O
)	O
)	O
)	O
fatal	function
(	O
_	O
(	O
"error: %s both sets and alters VMA"	pointer
)	O
,	O
name	pointer
)	O
;	O
if	O
(	O
(	O
(	O
p	pointer
->	O
context	int
&	O
SECTION_CONTEXT_SET_LMA	O
)	O
&&	O
(	O
context	int
&	O
SECTION_CONTEXT_ALTER_LMA	O
)	O
)	O
||	O
(	O
(	O
context	int
&	O
SECTION_CONTEXT_SET_LMA	O
)	O
&&	O
(	O
context	int
&	O
SECTION_CONTEXT_ALTER_LMA	O
)	O
)	O
)	O
fatal	function
(	O
_	O
(	O
"error: %s both sets and alters LMA"	pointer
)	O
,	O
name	pointer
)	O
;	O
p	pointer
->	O
context	int
|=	O
context	int
;	O
return	O
p	pointer
;	O
}	O
}	O
else	O
if	O
(	O
p	pointer
->	O
context	int
&	O
context	int
)	O
{	O
if	O
(	O
p	pointer
->	O
pattern	pointer
[	O
0	int
]	O
==	O
'!'	O
)	O
{	O
if	O
(	O
fnmatch	function
(	O
p	pointer
->	O
pattern	pointer
+	O
1	int
,	O
name	pointer
,	O
0	int
)	O
==	O
0	int
)	O
{	O
p	pointer
->	O
used	int
=	O
TRUE	int
;	O
return	O
NULL	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
fnmatch	function
(	O
p	pointer
->	O
pattern	pointer
,	O
name	pointer
,	O
0	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
match	pointer
==	O
NULL	O
)	O
match	pointer
=	O
p	pointer
;	O
}	O
}	O
}	O
}	O
if	O
(	O
!	O
add	int
)	O
{	O
if	O
(	O
match	pointer
!=	O
NULL	O
)	O
match	pointer
->	O
used	int
=	O
TRUE	int
;	O
return	O
match	pointer
;	O
}	O
p	pointer
=	O
(	O
struct	O
section_list	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
section_list	struct
)	O
)	O
;	O
p	pointer
->	O
pattern	pointer
=	O
name	pointer
;	O
p	pointer
->	O
used	int
=	O
FALSE	int
;	O
p	pointer
->	O
context	int
=	O
context	int
;	O
p	pointer
->	O
vma_val	long
=	O
0	int
;	O
p	pointer
->	O
lma_val	long
=	O
0	int
;	O
p	pointer
->	O
flags	int
=	O
0	int
;	O
p	pointer
->	O
alignment	int
=	O
0	int
;	O
p	pointer
->	O
next	pointer
=	O
change_sections	pointer
;	O
change_sections	pointer
=	O
p	pointer
;	O
return	O
p	pointer
;	O
}	O
static	O
int	O
eq_string_redefnode	function
(	O
const	O
void	O
*	O
s1	pointer
,	O
const	O
void	O
*	O
s2	pointer
)	O
{	O
struct	O
redefine_node	struct
*	O
node1	pointer
=	O
(	O
struct	O
redefine_node	struct
*	O
)	O
s1	pointer
;	O
struct	O
redefine_node	struct
*	O
node2	pointer
=	O
(	O
struct	O
redefine_node	struct
*	O
)	O
s2	pointer
;	O
return	O
!	O
strcmp	function
(	O
(	O
const	O
char	O
*	O
)	O
node1	pointer
->	O
source	pointer
,	O
(	O
const	O
char	O
*	O
)	O
node2	pointer
->	O
source	pointer
)	O
;	O
}	O
static	O
hashval_t	int
htab_hash_redefnode	function
(	O
const	O
void	O
*	O
p	pointer
)	O
{	O
struct	O
redefine_node	struct
*	O
redefnode	pointer
=	O
(	O
struct	O
redefine_node	struct
*	O
)	O
p	pointer
;	O
return	O
htab_hash_string	function
(	O
redefnode	pointer
->	O
source	pointer
)	O
;	O
}	O
static	O
htab_t	pointer
create_symbol2redef_htab	function
(	O
void	O
)	O
{	O
return	O
htab_create_alloc	function
(	O
16	int
,	O
htab_hash_redefnode	function
,	O
eq_string_redefnode	function
,	O
NULL	O
,	O
xcalloc	function
,	O
free	function
)	O
;	O
}	O
static	O
int	O
eq_string	function
(	O
const	O
void	O
*	O
s1	pointer
,	O
const	O
void	O
*	O
s2	pointer
)	O
{	O
return	O
strcmp	function
(	O
(	O
const	O
char	O
*	O
)	O
s1	pointer
,	O
(	O
const	O
char	O
*	O
)	O
s2	pointer
)	O
==	O
0	int
;	O
}	O
static	O
htab_t	pointer
create_symbol_htab	function
(	O
void	O
)	O
{	O
return	O
htab_create_alloc	function
(	O
16	int
,	O
htab_hash_string	function
,	O
eq_string	function
,	O
NULL	O
,	O
xcalloc	function
,	O
free	function
)	O
;	O
}	O
static	O
void	O
create_symbol_htabs	function
(	O
void	O
)	O
{	O
strip_specific_htab	pointer
=	O
create_symbol_htab	function
(	O
)	O
;	O
strip_unneeded_htab	pointer
=	O
create_symbol_htab	function
(	O
)	O
;	O
keep_specific_htab	pointer
=	O
create_symbol_htab	function
(	O
)	O
;	O
localize_specific_htab	pointer
=	O
create_symbol_htab	function
(	O
)	O
;	O
globalize_specific_htab	pointer
=	O
create_symbol_htab	function
(	O
)	O
;	O
keepglobal_specific_htab	pointer
=	O
create_symbol_htab	function
(	O
)	O
;	O
weaken_specific_htab	pointer
=	O
create_symbol_htab	function
(	O
)	O
;	O
redefine_specific_htab	pointer
=	O
create_symbol2redef_htab	function
(	O
)	O
;	O
redefine_specific_reverse_htab	pointer
=	O
create_symbol_htab	function
(	O
)	O
;	O
}	O
static	O
void	O
add_specific_symbol	function
(	O
const	O
char	O
*	O
name	pointer
,	O
htab_t	pointer
htab	struct
)	O
{	O
*	O
htab_find_slot	function
(	O
htab	struct
,	O
name	pointer
,	O
INSERT	int
)	O
=	O
(	O
char	O
*	O
)	O
name	pointer
;	O
}	O
static	O
void	O
add_specific_symbol_node	function
(	O
const	O
void	O
*	O
node	pointer
,	O
htab_t	pointer
htab	struct
)	O
{	O
*	O
htab_find_slot	function
(	O
htab	struct
,	O
node	pointer
,	O
INSERT	int
)	O
=	O
(	O
void	O
*	O
)	O
node	pointer
;	O
}	O
static	O
void	O
add_specific_symbols	function
(	O
const	O
char	O
*	O
filename	pointer
,	O
htab_t	pointer
htab	struct
,	O
char	O
*	O
*	O
buffer_p	pointer
)	O
{	O
off_t	long
size	int
;	O
FILE	struct
*	O
f	pointer
;	O
char	O
*	O
line	pointer
;	O
char	O
*	O
buffer	pointer
;	O
unsigned	O
int	O
line_count	int
;	O
size	int
=	O
get_file_size	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
size	int
==	O
0	int
)	O
{	O
status	int
=	O
1	int
;	O
return	O
;	O
}	O
buffer	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
size	int
+	O
2	int
)	O
;	O
f	pointer
=	O
fopen	function
(	O
filename	pointer
,	O
FOPEN_RT	pointer
)	O
;	O
if	O
(	O
f	pointer
==	O
NULL	O
)	O
fatal	function
(	O
_	O
(	O
"cannot open '%s': %s"	pointer
)	O
,	O
filename	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
if	O
(	O
fread	function
(	O
buffer	pointer
,	O
1	int
,	O
size	int
,	O
f	pointer
)	O
==	O
0	int
||	O
ferror	function
(	O
f	pointer
)	O
)	O
fatal	function
(	O
_	O
(	O
"%s: fread failed"	pointer
)	O
,	O
filename	pointer
)	O
;	O
fclose	function
(	O
f	pointer
)	O
;	O
buffer	pointer
[	O
size	int
]	O
=	O
'\n'	O
;	O
buffer	pointer
[	O
size	int
+	O
1	int
]	O
=	O
'\0'	O
;	O
line_count	int
=	O
1	int
;	O
for	O
(	O
line	pointer
=	O
buffer	pointer
;	O
*	O
line	pointer
!=	O
'\0'	O
;	O
line	pointer
++	O
)	O
{	O
char	O
*	O
eol	pointer
;	O
char	O
*	O
name	pointer
;	O
char	O
*	O
name_end	pointer
;	O
int	O
finished	int
=	O
FALSE	int
;	O
for	O
(	O
eol	pointer
=	O
line	pointer
;	O
;	O
eol	pointer
++	O
)	O
{	O
switch	O
(	O
*	O
eol	pointer
)	O
{	O
case	O
'\n'	O
:	O
*	O
eol	pointer
=	O
'\0'	O
;	O
if	O
(	O
eol	pointer
[	O
1	int
]	O
==	O
'\r'	O
)	O
++	O
eol	pointer
;	O
finished	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'\r'	O
:	O
*	O
eol	pointer
=	O
'\0'	O
;	O
if	O
(	O
eol	pointer
[	O
1	int
]	O
==	O
'\n'	O
)	O
++	O
eol	pointer
;	O
finished	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
0	int
:	O
finished	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'#'	O
:	O
*	O
eol	pointer
=	O
'\0'	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
finished	int
)	O
break	O
;	O
}	O
for	O
(	O
name	pointer
=	O
line	pointer
;	O
IS_WHITESPACE	O
(	O
*	O
name	pointer
)	O
;	O
name	pointer
++	O
)	O
;	O
for	O
(	O
name_end	pointer
=	O
name	pointer
;	O
(	O
!	O
IS_WHITESPACE	O
(	O
*	O
name_end	pointer
)	O
)	O
&&	O
(	O
!	O
IS_LINE_TERMINATOR	O
(	O
*	O
name_end	pointer
)	O
)	O
;	O
name_end	pointer
++	O
)	O
;	O
if	O
(	O
!	O
IS_LINE_TERMINATOR	O
(	O
*	O
name_end	pointer
)	O
)	O
{	O
char	O
*	O
extra	pointer
;	O
for	O
(	O
extra	pointer
=	O
name_end	pointer
+	O
1	int
;	O
IS_WHITESPACE	O
(	O
*	O
extra	pointer
)	O
;	O
extra	pointer
++	O
)	O
;	O
if	O
(	O
!	O
IS_LINE_TERMINATOR	O
(	O
*	O
extra	pointer
)	O
)	O
non_fatal	function
(	O
_	O
(	O
"%s:%d: Ignoring rubbish found on this line"	pointer
)	O
,	O
filename	pointer
,	O
line_count	int
)	O
;	O
}	O
*	O
name_end	pointer
=	O
'\0'	O
;	O
if	O
(	O
name_end	pointer
>	O
name	pointer
)	O
add_specific_symbol	function
(	O
name	pointer
,	O
htab	struct
)	O
;	O
line	pointer
=	O
eol	pointer
;	O
line_count	int
++	O
;	O
}	O
*	O
buffer_p	pointer
=	O
buffer	pointer
;	O
}	O
static	O
int	O
is_specified_symbol_predicate	function
(	O
void	O
*	O
*	O
slot	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
is_specified_symbol_predicate_data	struct
*	O
d	pointer
=	O
(	O
struct	O
is_specified_symbol_predicate_data	struct
*	O
)	O
data	pointer
;	O
const	O
char	O
*	O
slot_name	pointer
=	O
(	O
char	O
*	O
)	O
*	O
slot	pointer
;	O
if	O
(	O
*	O
slot_name	pointer
!=	O
'!'	O
)	O
{	O
if	O
(	O
!	O
fnmatch	function
(	O
slot_name	pointer
,	O
d	pointer
->	O
name	pointer
,	O
0	int
)	O
)	O
{	O
d	pointer
->	O
found	int
=	O
TRUE	int
;	O
return	O
1	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
fnmatch	function
(	O
slot_name	pointer
+	O
1	int
,	O
d	pointer
->	O
name	pointer
,	O
0	int
)	O
)	O
{	O
d	pointer
->	O
found	int
=	O
FALSE	int
;	O
return	O
0	int
;	O
}	O
}	O
return	O
1	int
;	O
}	O
static	O
bfd_boolean	int
is_specified_symbol	function
(	O
const	O
char	O
*	O
name	pointer
,	O
htab_t	pointer
htab	struct
)	O
{	O
if	O
(	O
wildcard	int
)	O
{	O
struct	O
is_specified_symbol_predicate_data	struct
data	pointer
;	O
data	pointer
.	O
name	pointer
=	O
name	pointer
;	O
data	pointer
.	O
found	int
=	O
FALSE	int
;	O
htab_traverse	function
(	O
htab	struct
,	O
is_specified_symbol_predicate	function
,	O
&	O
data	pointer
)	O
;	O
return	O
data	pointer
.	O
found	int
;	O
}	O
return	O
htab_find	function
(	O
htab	struct
,	O
name	pointer
)	O
!=	O
NULL	O
;	O
}	O
static	O
asymbol	struct
*	O
group_signature	function
(	O
asection	struct
*	O
group	pointer
)	O
{	O
bfd	struct
*	O
abfd	pointer
=	O
group	pointer
->	O
owner	pointer
;	O
Elf_Internal_Shdr	struct
*	O
ghdr	pointer
;	O
if	O
(	O
isympp	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
bfd_get_flavour	function
(	O
abfd	pointer
)	O
!=	O
bfd_target_elf_flavour	int
)	O
return	O
NULL	O
;	O
ghdr	pointer
=	O
&	O
elf_section_data	O
(	O
group	pointer
)	O
->	O
this_hdr	struct
;	O
if	O
(	O
ghdr	pointer
->	O
sh_link	array
==	O
elf_onesymtab	O
(	O
abfd	pointer
)	O
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
Elf_Internal_Shdr	struct
*	O
symhdr	pointer
=	O
&	O
elf_symtab_hdr	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
ghdr	pointer
->	O
sh_info	array
>	O
0	int
&&	O
ghdr	pointer
->	O
sh_info	array
<	O
symhdr	pointer
->	O
sh_size	array
/	O
bed	pointer
->	O
s	pointer
->	O
sizeof_sym	char
)	O
return	O
isympp	pointer
[	O
ghdr	pointer
->	O
sh_info	array
-	O
1	int
]	O
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
bfd_boolean	int
is_dwo_section	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
asection	struct
*	O
sec	pointer
)	O
{	O
const	O
char	O
*	O
name	pointer
=	O
bfd_section_name	function
(	O
sec	pointer
)	O
;	O
int	O
len	long
=	O
strlen	function
(	O
name	pointer
)	O
;	O
return	O
strncmp	function
(	O
name	pointer
+	O
len	long
-	O
4	int
,	O
".dwo"	pointer
,	O
4	int
)	O
==	O
0	int
;	O
}	O
static	O
bfd_boolean	int
is_update_section	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
asection	struct
*	O
sec	pointer
)	O
{	O
if	O
(	O
update_sections	pointer
!=	O
NULL	O
)	O
{	O
struct	O
section_add	struct
*	O
pupdate	pointer
;	O
for	O
(	O
pupdate	pointer
=	O
update_sections	pointer
;	O
pupdate	pointer
!=	O
NULL	O
;	O
pupdate	pointer
=	O
pupdate	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
sec	pointer
->	O
name	pointer
,	O
pupdate	pointer
->	O
name	pointer
)	O
==	O
0	int
)	O
return	O
TRUE	int
;	O
}	O
}	O
return	O
FALSE	int
;	O
}	O
static	O
bfd_boolean	int
is_mergeable_note_section	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
sec	pointer
)	O
{	O
if	O
(	O
merge_notes	int
&&	O
bfd_get_flavour	function
(	O
abfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
&&	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
this_hdr	struct
.	O
sh_type	array
==	O
SHT_NOTE	int
&&	O
(	O
(	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
this_hdr	struct
.	O
sh_flags	array
&	O
SHF_GNU_BUILD_NOTE	O
)	O
!=	O
0	int
||	O
(	O
CONST_STRNEQ	O
(	O
sec	pointer
->	O
name	pointer
,	O
GNU_BUILD_ATTRS_SECTION_NAME	pointer
)	O
)	O
)	O
)	O
return	O
TRUE	int
;	O
return	O
FALSE	int
;	O
}	O
static	O
bfd_boolean	int
is_strip_section_1	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
asection	struct
*	O
sec	pointer
)	O
{	O
if	O
(	O
find_section_list	function
(	O
bfd_section_name	function
(	O
sec	pointer
)	O
,	O
FALSE	int
,	O
SECTION_CONTEXT_KEEP	O
)	O
!=	O
NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
sections_removed	int
||	O
sections_copied	int
)	O
{	O
struct	O
section_list	struct
*	O
p	pointer
;	O
struct	O
section_list	struct
*	O
q	pointer
;	O
p	pointer
=	O
find_section_list	function
(	O
bfd_section_name	function
(	O
sec	pointer
)	O
,	O
FALSE	int
,	O
SECTION_CONTEXT_REMOVE	O
)	O
;	O
q	pointer
=	O
find_section_list	function
(	O
bfd_section_name	function
(	O
sec	pointer
)	O
,	O
FALSE	int
,	O
SECTION_CONTEXT_COPY	O
)	O
;	O
if	O
(	O
p	pointer
&&	O
q	pointer
)	O
fatal	function
(	O
_	O
(	O
"error: section %s matches both remove and copy options"	pointer
)	O
,	O
bfd_section_name	function
(	O
sec	pointer
)	O
)	O
;	O
if	O
(	O
p	pointer
&&	O
is_update_section	function
(	O
abfd	pointer
,	O
sec	pointer
)	O
)	O
fatal	function
(	O
_	O
(	O
"error: section %s matches both update and remove options"	pointer
)	O
,	O
bfd_section_name	function
(	O
sec	pointer
)	O
)	O
;	O
if	O
(	O
p	pointer
!=	O
NULL	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
sections_copied	int
&&	O
q	pointer
==	O
NULL	O
)	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
(	O
bfd_section_flags	function
(	O
sec	pointer
)	O
&	O
SEC_DEBUGGING	int
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
strip_symbols	enum
==	O
STRIP_DEBUG	int
||	O
strip_symbols	enum
==	O
STRIP_UNNEEDED	int
||	O
strip_symbols	enum
==	O
STRIP_ALL	int
||	O
discard_locals	enum
==	O
LOCALS_ALL	int
||	O
convert_debugging	int
)	O
{	O
if	O
(	O
strcmp	function
(	O
bfd_section_name	function
(	O
sec	pointer
)	O
,	O
".reloc"	pointer
)	O
!=	O
0	int
)	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
strip_symbols	enum
==	O
STRIP_DWO	int
)	O
return	O
is_dwo_section	function
(	O
abfd	pointer
,	O
sec	pointer
)	O
;	O
if	O
(	O
strip_symbols	enum
==	O
STRIP_NONDEBUG	int
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
strip_symbols	enum
==	O
STRIP_NONDWO	int
)	O
return	O
!	O
is_dwo_section	function
(	O
abfd	pointer
,	O
sec	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
static	O
bfd_boolean	int
is_strip_section	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
asection	struct
*	O
sec	pointer
)	O
{	O
if	O
(	O
is_strip_section_1	function
(	O
abfd	pointer
,	O
sec	pointer
)	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
(	O
bfd_section_flags	function
(	O
sec	pointer
)	O
&	O
SEC_GROUP	int
)	O
!=	O
0	int
)	O
{	O
asymbol	struct
*	O
gsym	pointer
;	O
const	O
char	O
*	O
gname	pointer
;	O
asection	struct
*	O
elt	pointer
,	O
*	O
first	pointer
;	O
gsym	pointer
=	O
group_signature	function
(	O
sec	pointer
)	O
;	O
if	O
(	O
gsym	pointer
==	O
NULL	O
)	O
return	O
TRUE	int
;	O
gname	pointer
=	O
gsym	pointer
->	O
name	pointer
;	O
if	O
(	O
(	O
strip_symbols	enum
==	O
STRIP_ALL	int
&&	O
!	O
is_specified_symbol	function
(	O
gname	pointer
,	O
keep_specific_htab	pointer
)	O
)	O
||	O
is_specified_symbol	function
(	O
gname	pointer
,	O
strip_specific_htab	pointer
)	O
)	O
return	O
TRUE	int
;	O
first	pointer
=	O
elt	pointer
=	O
elf_next_in_group	O
(	O
sec	pointer
)	O
;	O
while	O
(	O
elt	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
is_strip_section_1	function
(	O
abfd	pointer
,	O
elt	pointer
)	O
)	O
return	O
FALSE	int
;	O
elt	pointer
=	O
elf_next_in_group	O
(	O
elt	pointer
)	O
;	O
if	O
(	O
elt	pointer
==	O
first	pointer
)	O
break	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
return	O
FALSE	int
;	O
}	O
static	O
bfd_boolean	int
is_nondebug_keep_contents_section	function
(	O
bfd	struct
*	O
ibfd	pointer
,	O
asection	struct
*	O
isection	pointer
)	O
{	O
if	O
(	O
bfd_get_flavour	function
(	O
ibfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
)	O
return	O
elf_section_type	O
(	O
isection	pointer
)	O
==	O
SHT_NOTE	int
;	O
if	O
(	O
bfd_get_flavour	function
(	O
ibfd	pointer
)	O
==	O
bfd_target_coff_flavour	int
)	O
return	O
strcmp	function
(	O
bfd_section_name	function
(	O
isection	pointer
)	O
,	O
".buildid"	pointer
)	O
==	O
0	int
;	O
return	O
FALSE	int
;	O
}	O
static	O
bfd_boolean	int
is_hidden_symbol	function
(	O
asymbol	struct
*	O
sym	pointer
)	O
{	O
elf_symbol_type	struct
*	O
elf_sym	pointer
;	O
elf_sym	pointer
=	O
elf_symbol_from	O
(	O
sym	pointer
->	O
the_bfd	pointer
,	O
sym	pointer
)	O
;	O
if	O
(	O
elf_sym	pointer
!=	O
NULL	O
)	O
switch	O
(	O
ELF_ST_VISIBILITY	O
(	O
elf_sym	pointer
->	O
internal_elf_sym	struct
.	O
st_other	array
)	O
)	O
{	O
case	O
STV_HIDDEN	int
:	O
case	O
STV_INTERNAL	int
:	O
return	O
TRUE	int
;	O
}	O
return	O
FALSE	int
;	O
}	O
static	O
const	O
char	O
*	O
empty_name	pointer
=	O
""	pointer
;	O
static	O
bfd_boolean	int
need_sym_before	function
(	O
struct	O
addsym_node	struct
*	O
*	O
node	pointer
,	O
const	O
char	O
*	O
sym	pointer
)	O
{	O
int	O
count	int
;	O
struct	O
addsym_node	struct
*	O
ptr	pointer
=	O
add_sym_list	pointer
;	O
for	O
(	O
count	int
=	O
0	int
;	O
count	int
<	O
add_symbols	int
;	O
count	int
++	O
)	O
{	O
if	O
(	O
!	O
ptr	pointer
->	O
othersym	pointer
)	O
break	O
;	O
if	O
(	O
ptr	pointer
->	O
othersym	pointer
==	O
empty_name	pointer
)	O
continue	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
ptr	pointer
->	O
othersym	pointer
,	O
sym	pointer
)	O
==	O
0	int
)	O
{	O
free	function
(	O
(	O
char	O
*	O
)	O
ptr	pointer
->	O
othersym	pointer
)	O
;	O
ptr	pointer
->	O
othersym	pointer
=	O
empty_name	pointer
;	O
*	O
node	pointer
=	O
ptr	pointer
;	O
return	O
TRUE	int
;	O
}	O
ptr	pointer
=	O
ptr	pointer
->	O
next	pointer
;	O
}	O
return	O
FALSE	int
;	O
}	O
static	O
asymbol	struct
*	O
create_new_symbol	function
(	O
struct	O
addsym_node	struct
*	O
ptr	pointer
,	O
bfd	struct
*	O
obfd	pointer
)	O
{	O
asymbol	struct
*	O
sym	pointer
=	O
bfd_make_empty_symbol	O
(	O
obfd	pointer
)	O
;	O
bfd_set_asymbol_name	function
(	O
sym	pointer
,	O
ptr	pointer
->	O
symdef	pointer
)	O
;	O
sym	pointer
->	O
value	long
=	O
ptr	pointer
->	O
symval	long
;	O
sym	pointer
->	O
flags	int
=	O
ptr	pointer
->	O
flags	int
;	O
if	O
(	O
ptr	pointer
->	O
section	pointer
)	O
{	O
asection	struct
*	O
sec	pointer
=	O
bfd_get_section_by_name	function
(	O
obfd	pointer
,	O
ptr	pointer
->	O
section	pointer
)	O
;	O
if	O
(	O
!	O
sec	pointer
)	O
fatal	function
(	O
_	O
(	O
"Section %s not found"	pointer
)	O
,	O
ptr	pointer
->	O
section	pointer
)	O
;	O
sym	pointer
->	O
section	pointer
=	O
sec	pointer
;	O
}	O
else	O
sym	pointer
->	O
section	pointer
=	O
bfd_abs_section_ptr	O
;	O
return	O
sym	pointer
;	O
}	O
static	O
unsigned	O
int	O
filter_symbols	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
bfd	struct
*	O
obfd	pointer
,	O
asymbol	struct
*	O
*	O
osyms	pointer
,	O
asymbol	struct
*	O
*	O
isyms	pointer
,	O
long	O
symcount	int
)	O
{	O
asymbol	struct
*	O
*	O
from	pointer
=	O
isyms	pointer
,	O
*	O
*	O
to	pointer
=	O
osyms	pointer
;	O
long	O
src_count	long
=	O
0	int
,	O
dst_count	long
=	O
0	int
;	O
int	O
relocatable	int
=	O
(	O
abfd	pointer
->	O
flags	int
&	O
(	O
EXEC_P	int
|	O
DYNAMIC	int
)	O
)	O
==	O
0	int
;	O
for	O
(	O
;	O
src_count	long
<	O
symcount	int
;	O
src_count	long
++	O
)	O
{	O
asymbol	struct
*	O
sym	pointer
=	O
from	pointer
[	O
src_count	long
]	O
;	O
flagword	int
flags	int
=	O
sym	pointer
->	O
flags	int
;	O
char	O
*	O
name	pointer
=	O
(	O
char	O
*	O
)	O
bfd_asymbol_name	function
(	O
sym	pointer
)	O
;	O
bfd_boolean	int
keep	int
;	O
bfd_boolean	int
used_in_reloc	int
=	O
FALSE	int
;	O
bfd_boolean	int
undefined	int
;	O
bfd_boolean	int
rem_leading_char	int
;	O
bfd_boolean	int
add_leading_char	int
;	O
undefined	int
=	O
bfd_is_und_section	function
(	O
bfd_asymbol_section	function
(	O
sym	pointer
)	O
)	O
;	O
if	O
(	O
add_sym_list	pointer
)	O
{	O
struct	O
addsym_node	struct
*	O
ptr	pointer
;	O
if	O
(	O
need_sym_before	function
(	O
&	O
ptr	pointer
,	O
name	pointer
)	O
)	O
to	pointer
[	O
dst_count	long
++	O
]	O
=	O
create_new_symbol	function
(	O
ptr	pointer
,	O
obfd	pointer
)	O
;	O
}	O
if	O
(	O
htab_elements	function
(	O
redefine_specific_htab	pointer
)	O
||	O
section_rename_list	pointer
)	O
{	O
char	O
*	O
new_name	pointer
;	O
new_name	pointer
=	O
(	O
char	O
*	O
)	O
lookup_sym_redefinition	function
(	O
name	pointer
)	O
;	O
if	O
(	O
new_name	pointer
==	O
name	pointer
&&	O
(	O
flags	int
&	O
BSF_SECTION_SYM	O
)	O
!=	O
0	int
)	O
new_name	pointer
=	O
(	O
char	O
*	O
)	O
find_section_rename	function
(	O
name	pointer
,	O
NULL	O
)	O
;	O
bfd_set_asymbol_name	function
(	O
sym	pointer
,	O
new_name	pointer
)	O
;	O
name	pointer
=	O
new_name	pointer
;	O
}	O
rem_leading_char	int
=	O
(	O
name	pointer
[	O
0	int
]	O
==	O
bfd_get_symbol_leading_char	function
(	O
abfd	pointer
)	O
)	O
&&	O
(	O
change_leading_char	int
||	O
(	O
remove_leading_char	int
&&	O
(	O
(	O
flags	int
&	O
(	O
BSF_GLOBAL	O
|	O
BSF_WEAK	O
)	O
)	O
!=	O
0	int
||	O
undefined	int
||	O
bfd_is_com_section	function
(	O
bfd_asymbol_section	function
(	O
sym	pointer
)	O
)	O
)	O
)	O
)	O
;	O
add_leading_char	int
=	O
change_leading_char	int
&&	O
(	O
bfd_get_symbol_leading_char	function
(	O
obfd	pointer
)	O
!=	O
'\0'	O
)	O
&&	O
(	O
bfd_get_symbol_leading_char	function
(	O
abfd	pointer
)	O
==	O
'\0'	O
||	O
(	O
name	pointer
[	O
0	int
]	O
==	O
bfd_get_symbol_leading_char	function
(	O
abfd	pointer
)	O
)	O
)	O
;	O
if	O
(	O
rem_leading_char	int
&&	O
add_leading_char	int
&&	O
!	O
prefix_symbols_string	pointer
)	O
{	O
name	pointer
[	O
0	int
]	O
=	O
bfd_get_symbol_leading_char	function
(	O
obfd	pointer
)	O
;	O
bfd_set_asymbol_name	function
(	O
sym	pointer
,	O
name	pointer
)	O
;	O
rem_leading_char	int
=	O
FALSE	int
;	O
add_leading_char	int
=	O
FALSE	int
;	O
}	O
if	O
(	O
rem_leading_char	int
)	O
bfd_set_asymbol_name	function
(	O
sym	pointer
,	O
++	O
name	pointer
)	O
;	O
if	O
(	O
add_leading_char	int
||	O
prefix_symbols_string	pointer
)	O
{	O
char	O
*	O
n	long
,	O
*	O
ptr	pointer
;	O
ptr	pointer
=	O
n	long
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
1	int
+	O
strlen	function
(	O
prefix_symbols_string	pointer
)	O
+	O
strlen	function
(	O
name	pointer
)	O
+	O
1	int
)	O
;	O
if	O
(	O
add_leading_char	int
)	O
*	O
ptr	pointer
++	O
=	O
bfd_get_symbol_leading_char	function
(	O
obfd	pointer
)	O
;	O
if	O
(	O
prefix_symbols_string	pointer
)	O
{	O
strcpy	function
(	O
ptr	pointer
,	O
prefix_symbols_string	pointer
)	O
;	O
ptr	pointer
+=	O
strlen	function
(	O
prefix_symbols_string	pointer
)	O
;	O
}	O
strcpy	function
(	O
ptr	pointer
,	O
name	pointer
)	O
;	O
bfd_set_asymbol_name	function
(	O
sym	pointer
,	O
n	long
)	O
;	O
name	pointer
=	O
n	long
;	O
}	O
if	O
(	O
strip_symbols	enum
==	O
STRIP_ALL	int
)	O
keep	int
=	O
FALSE	int
;	O
else	O
if	O
(	O
(	O
flags	int
&	O
BSF_KEEP	O
)	O
!=	O
0	int
||	O
(	O
(	O
flags	int
&	O
BSF_SECTION_SYM	O
)	O
!=	O
0	int
&&	O
(	O
(	O
*	O
bfd_asymbol_section	function
(	O
sym	pointer
)	O
->	O
symbol_ptr_ptr	pointer
)	O
->	O
flags	int
&	O
BSF_KEEP	O
)	O
!=	O
0	int
)	O
)	O
{	O
keep	int
=	O
TRUE	int
;	O
used_in_reloc	int
=	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
relocatable	int
&&	O
(	O
(	O
flags	int
&	O
(	O
BSF_GLOBAL	O
|	O
BSF_WEAK	O
)	O
)	O
!=	O
0	int
||	O
bfd_is_com_section	function
(	O
bfd_asymbol_section	function
(	O
sym	pointer
)	O
)	O
)	O
)	O
keep	int
=	O
TRUE	int
;	O
else	O
if	O
(	O
bfd_decode_symclass	function
(	O
sym	pointer
)	O
==	O
'I'	O
)	O
keep	int
=	O
TRUE	int
;	O
else	O
if	O
(	O
(	O
flags	int
&	O
BSF_GLOBAL	O
)	O
!=	O
0	int
||	O
(	O
flags	int
&	O
BSF_WEAK	O
)	O
!=	O
0	int
||	O
undefined	int
||	O
bfd_is_com_section	function
(	O
bfd_asymbol_section	function
(	O
sym	pointer
)	O
)	O
)	O
keep	int
=	O
strip_symbols	enum
!=	O
STRIP_UNNEEDED	int
;	O
else	O
if	O
(	O
(	O
flags	int
&	O
BSF_DEBUGGING	O
)	O
!=	O
0	int
)	O
keep	int
=	O
(	O
strip_symbols	enum
!=	O
STRIP_DEBUG	int
&&	O
strip_symbols	enum
!=	O
STRIP_UNNEEDED	int
&&	O
!	O
convert_debugging	int
)	O
;	O
else	O
if	O
(	O
bfd_coff_get_comdat_section	O
(	O
abfd	pointer
,	O
bfd_asymbol_section	function
(	O
sym	pointer
)	O
)	O
)	O
keep	int
=	O
TRUE	int
;	O
else	O
keep	int
=	O
(	O
strip_symbols	enum
!=	O
STRIP_UNNEEDED	int
&&	O
(	O
discard_locals	enum
!=	O
LOCALS_ALL	int
&&	O
(	O
discard_locals	enum
!=	O
LOCALS_START_L	int
||	O
!	O
bfd_is_local_label	function
(	O
abfd	pointer
,	O
sym	pointer
)	O
)	O
)	O
)	O
;	O
if	O
(	O
keep	int
&&	O
is_specified_symbol	function
(	O
name	pointer
,	O
strip_specific_htab	pointer
)	O
)	O
{	O
if	O
(	O
used_in_reloc	int
)	O
{	O
non_fatal	function
(	O
_	O
(	O
"not stripping symbol `%s' because it is named in a relocation"	pointer
)	O
,	O
name	pointer
)	O
;	O
status	int
=	O
1	int
;	O
}	O
else	O
keep	int
=	O
FALSE	int
;	O
}	O
if	O
(	O
keep	int
&&	O
!	O
(	O
flags	int
&	O
BSF_KEEP	O
)	O
&&	O
is_specified_symbol	function
(	O
name	pointer
,	O
strip_unneeded_htab	pointer
)	O
)	O
keep	int
=	O
FALSE	int
;	O
if	O
(	O
!	O
keep	int
&&	O
(	O
(	O
keep_file_symbols	int
&&	O
(	O
flags	int
&	O
BSF_FILE	O
)	O
)	O
||	O
is_specified_symbol	function
(	O
name	pointer
,	O
keep_specific_htab	pointer
)	O
)	O
)	O
keep	int
=	O
TRUE	int
;	O
if	O
(	O
keep	int
&&	O
is_strip_section	function
(	O
abfd	pointer
,	O
bfd_asymbol_section	function
(	O
sym	pointer
)	O
)	O
)	O
keep	int
=	O
FALSE	int
;	O
if	O
(	O
keep	int
)	O
{	O
if	O
(	O
(	O
flags	int
&	O
BSF_GLOBAL	O
)	O
!=	O
0	int
&&	O
(	O
weaken	int
||	O
is_specified_symbol	function
(	O
name	pointer
,	O
weaken_specific_htab	pointer
)	O
)	O
)	O
{	O
sym	pointer
->	O
flags	int
&=	O
~	O
BSF_GLOBAL	O
;	O
sym	pointer
->	O
flags	int
|=	O
BSF_WEAK	O
;	O
}	O
if	O
(	O
!	O
undefined	int
&&	O
(	O
flags	int
&	O
(	O
BSF_GLOBAL	O
|	O
BSF_WEAK	O
)	O
)	O
&&	O
(	O
is_specified_symbol	function
(	O
name	pointer
,	O
localize_specific_htab	pointer
)	O
||	O
(	O
htab_elements	function
(	O
keepglobal_specific_htab	pointer
)	O
!=	O
0	int
&&	O
!	O
is_specified_symbol	function
(	O
name	pointer
,	O
keepglobal_specific_htab	pointer
)	O
)	O
||	O
(	O
localize_hidden	int
&&	O
is_hidden_symbol	function
(	O
sym	pointer
)	O
)	O
)	O
)	O
{	O
sym	pointer
->	O
flags	int
&=	O
~	O
(	O
BSF_GLOBAL	O
|	O
BSF_WEAK	O
)	O
;	O
sym	pointer
->	O
flags	int
|=	O
BSF_LOCAL	O
;	O
}	O
if	O
(	O
!	O
undefined	int
&&	O
(	O
flags	int
&	O
BSF_LOCAL	O
)	O
&&	O
is_specified_symbol	function
(	O
name	pointer
,	O
globalize_specific_htab	pointer
)	O
)	O
{	O
sym	pointer
->	O
flags	int
&=	O
~	O
BSF_LOCAL	O
;	O
sym	pointer
->	O
flags	int
|=	O
BSF_GLOBAL	O
;	O
}	O
to	pointer
[	O
dst_count	long
++	O
]	O
=	O
sym	pointer
;	O
}	O
}	O
if	O
(	O
add_sym_list	pointer
)	O
{	O
struct	O
addsym_node	struct
*	O
ptr	pointer
=	O
add_sym_list	pointer
;	O
for	O
(	O
src_count	long
=	O
0	int
;	O
src_count	long
<	O
add_symbols	int
;	O
src_count	long
++	O
)	O
{	O
if	O
(	O
ptr	pointer
->	O
othersym	pointer
)	O
{	O
if	O
(	O
ptr	pointer
->	O
othersym	pointer
!=	O
empty_name	pointer
)	O
fatal	function
(	O
_	O
(	O
"'before=%s' not found"	pointer
)	O
,	O
ptr	pointer
->	O
othersym	pointer
)	O
;	O
}	O
else	O
to	pointer
[	O
dst_count	long
++	O
]	O
=	O
create_new_symbol	function
(	O
ptr	pointer
,	O
obfd	pointer
)	O
;	O
ptr	pointer
=	O
ptr	pointer
->	O
next	pointer
;	O
}	O
}	O
to	pointer
[	O
dst_count	long
]	O
=	O
NULL	O
;	O
return	O
dst_count	long
;	O
}	O
static	O
const	O
char	O
*	O
lookup_sym_redefinition	function
(	O
const	O
char	O
*	O
source	pointer
)	O
{	O
struct	O
redefine_node	struct
key_node	struct
=	O
{	O
(	O
char	O
*	O
)	O
source	pointer
,	O
NULL	O
}	O
;	O
struct	O
redefine_node	struct
*	O
redef_node	pointer
=	O
(	O
struct	O
redefine_node	struct
*	O
)	O
htab_find	function
(	O
redefine_specific_htab	pointer
,	O
&	O
key_node	struct
)	O
;	O
return	O
redef_node	pointer
==	O
NULL	O
?	O
source	pointer
:	O
redef_node	pointer
->	O
target	pointer
;	O
}	O
static	O
void	O
add_redefine_and_check	function
(	O
const	O
char	O
*	O
cause	pointer
,	O
const	O
char	O
*	O
source	pointer
,	O
const	O
char	O
*	O
target	pointer
)	O
{	O
struct	O
redefine_node	struct
*	O
new_node	pointer
=	O
(	O
struct	O
redefine_node	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
redefine_node	struct
)	O
)	O
;	O
new_node	pointer
->	O
source	pointer
=	O
strdup	function
(	O
source	pointer
)	O
;	O
new_node	pointer
->	O
target	pointer
=	O
strdup	function
(	O
target	pointer
)	O
;	O
if	O
(	O
htab_find	function
(	O
redefine_specific_htab	pointer
,	O
new_node	pointer
)	O
!=	O
HTAB_EMPTY_ENTRY	O
)	O
fatal	function
(	O
_	O
(	O
"%s: Multiple redefinition of symbol \"%s\""	pointer
)	O
,	O
cause	pointer
,	O
source	pointer
)	O
;	O
if	O
(	O
htab_find	function
(	O
redefine_specific_reverse_htab	pointer
,	O
target	pointer
)	O
!=	O
HTAB_EMPTY_ENTRY	O
)	O
fatal	function
(	O
_	O
(	O
"%s: Symbol \"%s\" is target of more than one redefinition"	pointer
)	O
,	O
cause	pointer
,	O
target	pointer
)	O
;	O
add_specific_symbol_node	function
(	O
new_node	pointer
,	O
redefine_specific_htab	pointer
)	O
;	O
add_specific_symbol	function
(	O
new_node	pointer
->	O
target	pointer
,	O
redefine_specific_reverse_htab	pointer
)	O
;	O
}	O
static	O
void	O
add_redefine_syms_file	function
(	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
FILE	struct
*	O
file	pointer
;	O
char	O
*	O
buf	pointer
;	O
size_t	long
bufsize	long
;	O
size_t	long
len	long
;	O
size_t	long
outsym_off	long
;	O
int	O
c	struct
,	O
lineno	pointer
;	O
file	pointer
=	O
fopen	function
(	O
filename	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
file	pointer
==	O
NULL	O
)	O
fatal	function
(	O
_	O
(	O
"couldn't open symbol redefinition file %s (error: %s)"	pointer
)	O
,	O
filename	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
bufsize	long
=	O
100	int
;	O
buf	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
bufsize	long
+	O
1	int
)	O
;	O
lineno	pointer
=	O
1	int
;	O
c	struct
=	O
getc	function
(	O
file	pointer
)	O
;	O
len	long
=	O
0	int
;	O
outsym_off	long
=	O
0	int
;	O
while	O
(	O
c	struct
!=	O
EOF	O
)	O
{	O
while	O
(	O
!	O
IS_WHITESPACE	O
(	O
c	struct
)	O
&&	O
!	O
IS_LINE_TERMINATOR	O
(	O
c	struct
)	O
&&	O
c	struct
!=	O
EOF	O
)	O
{	O
if	O
(	O
c	struct
==	O
'#'	O
)	O
goto	O
comment	O
;	O
buf	pointer
[	O
len	long
++	O
]	O
=	O
c	struct
;	O
if	O
(	O
len	long
>=	O
bufsize	long
)	O
{	O
bufsize	long
*=	O
2	int
;	O
buf	pointer
=	O
(	O
char	O
*	O
)	O
xrealloc	function
(	O
buf	pointer
,	O
bufsize	long
+	O
1	int
)	O
;	O
}	O
c	struct
=	O
getc	function
(	O
file	pointer
)	O
;	O
}	O
buf	pointer
[	O
len	long
++	O
]	O
=	O
'\0'	O
;	O
if	O
(	O
c	struct
==	O
EOF	O
)	O
break	O
;	O
while	O
(	O
IS_WHITESPACE	O
(	O
c	struct
)	O
)	O
c	struct
=	O
getc	function
(	O
file	pointer
)	O
;	O
if	O
(	O
c	struct
==	O
'#'	O
||	O
IS_LINE_TERMINATOR	O
(	O
c	struct
)	O
)	O
goto	O
comment	O
;	O
if	O
(	O
c	struct
==	O
EOF	O
)	O
break	O
;	O
outsym_off	long
=	O
len	long
;	O
while	O
(	O
!	O
IS_WHITESPACE	O
(	O
c	struct
)	O
&&	O
!	O
IS_LINE_TERMINATOR	O
(	O
c	struct
)	O
&&	O
c	struct
!=	O
EOF	O
)	O
{	O
if	O
(	O
c	struct
==	O
'#'	O
)	O
goto	O
comment	O
;	O
buf	pointer
[	O
len	long
++	O
]	O
=	O
c	struct
;	O
if	O
(	O
len	long
>=	O
bufsize	long
)	O
{	O
bufsize	long
*=	O
2	int
;	O
buf	pointer
=	O
(	O
char	O
*	O
)	O
xrealloc	function
(	O
buf	pointer
,	O
bufsize	long
+	O
1	int
)	O
;	O
}	O
c	struct
=	O
getc	function
(	O
file	pointer
)	O
;	O
}	O
buf	pointer
[	O
len	long
++	O
]	O
=	O
'\0'	O
;	O
if	O
(	O
c	struct
==	O
EOF	O
)	O
break	O
;	O
while	O
(	O
!	O
IS_LINE_TERMINATOR	O
(	O
c	struct
)	O
&&	O
c	struct
!=	O
EOF	O
&&	O
IS_WHITESPACE	O
(	O
c	struct
)	O
)	O
c	struct
=	O
getc	function
(	O
file	pointer
)	O
;	O
if	O
(	O
c	struct
==	O
'#'	O
)	O
goto	O
comment	O
;	O
if	O
(	O
(	O
c	struct
==	O
'\r'	O
&&	O
(	O
c	struct
=	O
getc	function
(	O
file	pointer
)	O
)	O
==	O
'\n'	O
)	O
||	O
c	struct
==	O
'\n'	O
||	O
c	struct
==	O
EOF	O
)	O
{	O
end_of_line	O
:	O
if	O
(	O
buf	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
add_redefine_and_check	function
(	O
filename	pointer
,	O
&	O
buf	pointer
[	O
0	int
]	O
,	O
&	O
buf	pointer
[	O
outsym_off	long
]	O
)	O
;	O
lineno	pointer
++	O
;	O
len	long
=	O
0	int
;	O
outsym_off	long
=	O
0	int
;	O
if	O
(	O
c	struct
==	O
EOF	O
)	O
break	O
;	O
c	struct
=	O
getc	function
(	O
file	pointer
)	O
;	O
continue	O
;	O
}	O
else	O
fatal	function
(	O
_	O
(	O
"%s:%d: garbage found at end of line"	pointer
)	O
,	O
filename	pointer
,	O
lineno	pointer
)	O
;	O
comment	O
:	O
if	O
(	O
len	long
!=	O
0	int
&&	O
(	O
outsym_off	long
==	O
0	int
||	O
outsym_off	long
==	O
len	long
)	O
)	O
fatal	function
(	O
_	O
(	O
"%s:%d: missing new symbol name"	pointer
)	O
,	O
filename	pointer
,	O
lineno	pointer
)	O
;	O
buf	pointer
[	O
len	long
++	O
]	O
=	O
'\0'	O
;	O
while	O
(	O
c	struct
!=	O
'\n'	O
&&	O
c	struct
!=	O
EOF	O
)	O
c	struct
=	O
getc	function
(	O
file	pointer
)	O
;	O
goto	O
end_of_line	O
;	O
}	O
if	O
(	O
len	long
!=	O
0	int
)	O
fatal	function
(	O
_	O
(	O
"%s:%d: premature end of file"	pointer
)	O
,	O
filename	pointer
,	O
lineno	pointer
)	O
;	O
free	function
(	O
buf	pointer
)	O
;	O
fclose	function
(	O
file	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
copy_unknown_object	function
(	O
bfd	struct
*	O
ibfd	pointer
,	O
bfd	struct
*	O
obfd	pointer
)	O
{	O
char	O
*	O
cbuf	pointer
;	O
int	O
tocopy	int
;	O
long	O
ncopied	long
;	O
long	O
size	int
;	O
struct	O
stat	struct
buf	pointer
;	O
if	O
(	O
bfd_stat_arch_elt	O
(	O
ibfd	pointer
,	O
&	O
buf	pointer
)	O
!=	O
0	int
)	O
{	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
ibfd	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
size	int
=	O
buf	pointer
.	O
st_size	long
;	O
if	O
(	O
size	int
<	O
0	int
)	O
{	O
non_fatal	function
(	O
_	O
(	O
"stat returns negative size for `%s'"	pointer
)	O
,	O
bfd_get_archive_filename	function
(	O
ibfd	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
bfd_seek	function
(	O
ibfd	pointer
,	O
(	O
file_ptr	long
)	O
0	int
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
{	O
bfd_nonfatal	function
(	O
bfd_get_archive_filename	function
(	O
ibfd	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
verbose	int
)	O
printf	function
(	O
_	O
(	O
"copy from `%s' [unknown] to `%s' [unknown]\n"	pointer
)	O
,	O
bfd_get_archive_filename	function
(	O
ibfd	pointer
)	O
,	O
bfd_get_filename	function
(	O
obfd	pointer
)	O
)	O
;	O
cbuf	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
BUFSIZE	int
)	O
;	O
ncopied	long
=	O
0	int
;	O
while	O
(	O
ncopied	long
<	O
size	int
)	O
{	O
tocopy	int
=	O
size	int
-	O
ncopied	long
;	O
if	O
(	O
tocopy	int
>	O
BUFSIZE	int
)	O
tocopy	int
=	O
BUFSIZE	int
;	O
if	O
(	O
bfd_bread	function
(	O
cbuf	pointer
,	O
(	O
bfd_size_type	long
)	O
tocopy	int
,	O
ibfd	pointer
)	O
!=	O
(	O
bfd_size_type	long
)	O
tocopy	int
)	O
{	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
ibfd	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
free	function
(	O
cbuf	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
bfd_bwrite	function
(	O
cbuf	pointer
,	O
(	O
bfd_size_type	long
)	O
tocopy	int
,	O
obfd	pointer
)	O
!=	O
(	O
bfd_size_type	long
)	O
tocopy	int
)	O
{	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
obfd	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
free	function
(	O
cbuf	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
ncopied	long
+=	O
tocopy	int
;	O
}	O
chmod	function
(	O
bfd_get_filename	function
(	O
obfd	pointer
)	O
,	O
buf	pointer
.	O
st_mode	int
|	O
S_IRUSR	O
)	O
;	O
free	function
(	O
cbuf	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
typedef	O
struct	O
objcopy_internal_note	struct
{	O
Elf_Internal_Note	struct
note	struct
;	O
unsigned	O
long	O
padded_namesz	long
;	O
bfd_vma	long
start	long
;	O
bfd_vma	long
end	pointer
;	O
}	O
objcopy_internal_note	struct
;	O
static	O
bfd_boolean	int
overlaps_or_adjoins	function
(	O
objcopy_internal_note	struct
*	O
pnote1	pointer
,	O
objcopy_internal_note	struct
*	O
pnote2	pointer
)	O
{	O
if	O
(	O
pnote1	pointer
->	O
end	pointer
<	O
pnote2	pointer
->	O
start	long
)	O
return	O
BFD_ALIGN	O
(	O
pnote1	pointer
->	O
end	pointer
,	O
16	int
)	O
<	O
pnote2	pointer
->	O
start	long
;	O
if	O
(	O
pnote2	pointer
->	O
end	pointer
<	O
pnote2	pointer
->	O
start	long
)	O
return	O
BFD_ALIGN	O
(	O
pnote2	pointer
->	O
end	pointer
,	O
16	int
)	O
<	O
pnote1	pointer
->	O
start	long
;	O
if	O
(	O
pnote1	pointer
->	O
end	pointer
<	O
pnote2	pointer
->	O
end	pointer
)	O
return	O
TRUE	int
;	O
if	O
(	O
pnote2	pointer
->	O
end	pointer
<	O
pnote1	pointer
->	O
end	pointer
)	O
return	O
TRUE	int
;	O
return	O
FALSE	int
;	O
}	O
static	O
bfd_boolean	int
contained_by	function
(	O
objcopy_internal_note	struct
*	O
needle	pointer
,	O
objcopy_internal_note	struct
*	O
haystack	pointer
)	O
{	O
return	O
needle	pointer
->	O
start	long
>=	O
haystack	pointer
->	O
start	long
&&	O
needle	pointer
->	O
end	pointer
<=	O
haystack	pointer
->	O
end	pointer
;	O
}	O
static	O
bfd_boolean	int
is_open_note	function
(	O
objcopy_internal_note	struct
*	O
pnote	pointer
)	O
{	O
return	O
pnote	pointer
->	O
note	struct
.	O
type	enum
==	O
NT_GNU_BUILD_ATTRIBUTE_OPEN	int
;	O
}	O
static	O
bfd_boolean	int
is_func_note	function
(	O
objcopy_internal_note	struct
*	O
pnote	pointer
)	O
{	O
return	O
pnote	pointer
->	O
note	struct
.	O
type	enum
==	O
NT_GNU_BUILD_ATTRIBUTE_FUNC	int
;	O
}	O
static	O
bfd_boolean	int
is_deleted_note	function
(	O
objcopy_internal_note	struct
*	O
pnote	pointer
)	O
{	O
return	O
pnote	pointer
->	O
note	struct
.	O
type	enum
==	O
0	int
;	O
}	O
static	O
bfd_boolean	int
is_version_note	function
(	O
objcopy_internal_note	struct
*	O
pnote	pointer
)	O
{	O
return	O
(	O
pnote	pointer
->	O
note	struct
.	O
namesz	array
>	O
4	int
&&	O
pnote	pointer
->	O
note	struct
.	O
namedata	pointer
[	O
0	int
]	O
==	O
'G'	O
&&	O
pnote	pointer
->	O
note	struct
.	O
namedata	pointer
[	O
1	int
]	O
==	O
'A'	O
&&	O
pnote	pointer
->	O
note	struct
.	O
namedata	pointer
[	O
2	int
]	O
==	O
'$'	O
&&	O
pnote	pointer
->	O
note	struct
.	O
namedata	pointer
[	O
3	int
]	O
==	O
GNU_BUILD_ATTRIBUTE_VERSION	int
)	O
;	O
}	O
static	O
bfd_boolean	int
is_64bit	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
if	O
(	O
bfd_get_flavour	function
(	O
abfd	pointer
)	O
!=	O
bfd_target_elf_flavour	int
)	O
return	O
FALSE	int
;	O
return	O
elf_elfheader	O
(	O
abfd	pointer
)	O
->	O
e_ident	array
[	O
EI_CLASS	int
]	O
==	O
ELFCLASS64	int
;	O
}	O
static	O
int	O
compare_gnu_build_notes	function
(	O
const	O
void	O
*	O
data1	pointer
,	O
const	O
void	O
*	O
data2	pointer
)	O
{	O
objcopy_internal_note	struct
*	O
pnote1	pointer
=	O
(	O
objcopy_internal_note	struct
*	O
)	O
data1	pointer
;	O
objcopy_internal_note	struct
*	O
pnote2	pointer
=	O
(	O
objcopy_internal_note	struct
*	O
)	O
data2	pointer
;	O
int	O
cmp	int
=	O
memcmp	function
(	O
pnote1	pointer
->	O
note	struct
.	O
namedata	pointer
+	O
3	int
,	O
pnote2	pointer
->	O
note	struct
.	O
namedata	pointer
+	O
3	int
,	O
pnote1	pointer
->	O
note	struct
.	O
namesz	array
<	O
pnote2	pointer
->	O
note	struct
.	O
namesz	array
?	O
pnote1	pointer
->	O
note	struct
.	O
namesz	array
-	O
3	int
:	O
pnote2	pointer
->	O
note	struct
.	O
namesz	array
-	O
3	int
)	O
;	O
if	O
(	O
cmp	int
)	O
return	O
cmp	int
;	O
if	O
(	O
pnote1	pointer
->	O
end	pointer
<	O
pnote2	pointer
->	O
start	long
)	O
return	O
-	O
1	int
;	O
if	O
(	O
pnote1	pointer
->	O
start	long
>	O
pnote2	pointer
->	O
end	pointer
)	O
return	O
1	int
;	O
if	O
(	O
pnote1	pointer
->	O
start	long
<	O
pnote2	pointer
->	O
start	long
)	O
return	O
-	O
1	int
;	O
if	O
(	O
pnote1	pointer
->	O
end	pointer
>	O
pnote2	pointer
->	O
end	pointer
)	O
return	O
1	int
;	O
if	O
(	O
pnote1	pointer
->	O
end	pointer
<	O
pnote2	pointer
->	O
end	pointer
)	O
return	O
-	O
1	int
;	O
if	O
(	O
is_open_note	function
(	O
pnote1	pointer
)	O
&&	O
!	O
is_open_note	function
(	O
pnote2	pointer
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
!	O
is_open_note	function
(	O
pnote1	pointer
)	O
&&	O
is_open_note	function
(	O
pnote2	pointer
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
sort_gnu_build_notes	function
(	O
const	O
void	O
*	O
data1	pointer
,	O
const	O
void	O
*	O
data2	pointer
)	O
{	O
objcopy_internal_note	struct
*	O
pnote1	pointer
=	O
(	O
objcopy_internal_note	struct
*	O
)	O
data1	pointer
;	O
objcopy_internal_note	struct
*	O
pnote2	pointer
=	O
(	O
objcopy_internal_note	struct
*	O
)	O
data2	pointer
;	O
if	O
(	O
pnote1	pointer
->	O
note	struct
.	O
type	enum
!=	O
pnote2	pointer
->	O
note	struct
.	O
type	enum
)	O
{	O
if	O
(	O
is_deleted_note	function
(	O
pnote1	pointer
)	O
)	O
return	O
1	int
;	O
if	O
(	O
is_open_note	function
(	O
pnote1	pointer
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
is_deleted_note	function
(	O
pnote2	pointer
)	O
)	O
return	O
-	O
1	int
;	O
return	O
1	int
;	O
}	O
if	O
(	O
pnote1	pointer
->	O
start	long
<	O
pnote2	pointer
->	O
start	long
)	O
return	O
-	O
1	int
;	O
if	O
(	O
pnote1	pointer
->	O
start	long
>	O
pnote2	pointer
->	O
start	long
)	O
return	O
1	int
;	O
if	O
(	O
pnote1	pointer
->	O
end	pointer
>	O
pnote2	pointer
->	O
end	pointer
)	O
return	O
-	O
1	int
;	O
if	O
(	O
pnote1	pointer
->	O
end	pointer
<	O
pnote2	pointer
->	O
end	pointer
)	O
return	O
1	int
;	O
if	O
(	O
pnote1	pointer
->	O
note	struct
.	O
namesz	array
>	O
4	int
&&	O
pnote2	pointer
->	O
note	struct
.	O
namesz	array
>	O
4	int
&&	O
pnote1	pointer
->	O
note	struct
.	O
namedata	pointer
[	O
3	int
]	O
!=	O
pnote2	pointer
->	O
note	struct
.	O
namedata	pointer
[	O
3	int
]	O
)	O
return	O
pnote1	pointer
->	O
note	struct
.	O
namedata	pointer
[	O
3	int
]	O
-	O
pnote2	pointer
->	O
note	struct
.	O
namedata	pointer
[	O
3	int
]	O
;	O
return	O
0	int
;	O
}	O
static	O
bfd_size_type	long
merge_gnu_build_notes	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
bfd_size_type	long
size	int
,	O
bfd_byte	char
*	O
contents	pointer
)	O
{	O
objcopy_internal_note	struct
*	O
pnotes_end	pointer
;	O
objcopy_internal_note	struct
*	O
pnotes	pointer
=	O
NULL	O
;	O
objcopy_internal_note	struct
*	O
pnote	pointer
;	O
bfd_size_type	long
remain	long
=	O
size	int
;	O
unsigned	O
version_1_seen	int
=	O
0	int
;	O
unsigned	O
version_2_seen	int
=	O
0	int
;	O
unsigned	O
version_3_seen	int
=	O
0	int
;	O
const	O
char	O
*	O
err	pointer
=	O
NULL	O
;	O
bfd_byte	char
*	O
in	pointer
=	O
contents	pointer
;	O
unsigned	O
long	O
previous_func_start	long
=	O
0	int
;	O
unsigned	O
long	O
previous_open_start	long
=	O
0	int
;	O
unsigned	O
long	O
previous_func_end	long
=	O
0	int
;	O
unsigned	O
long	O
previous_open_end	long
=	O
0	int
;	O
long	O
relsize	long
;	O
relsize	long
=	O
bfd_get_reloc_upper_bound	function
(	O
abfd	pointer
,	O
sec	pointer
)	O
;	O
if	O
(	O
relsize	long
>	O
0	int
)	O
{	O
arelent	struct
*	O
*	O
relpp	pointer
;	O
long	O
relcount	long
;	O
relpp	pointer
=	O
(	O
arelent	struct
*	O
*	O
)	O
xmalloc	function
(	O
relsize	long
)	O
;	O
relcount	long
=	O
bfd_canonicalize_reloc	function
(	O
abfd	pointer
,	O
sec	pointer
,	O
relpp	pointer
,	O
isympp	pointer
)	O
;	O
free	function
(	O
relpp	pointer
)	O
;	O
if	O
(	O
relcount	long
!=	O
0	int
)	O
{	O
if	O
(	O
!	O
is_strip	int
)	O
non_fatal	function
(	O
_	O
(	O
"%s[%s]: Cannot merge - there are relocations against this section"	pointer
)	O
,	O
bfd_get_filename	function
(	O
abfd	pointer
)	O
,	O
bfd_section_name	function
(	O
sec	pointer
)	O
)	O
;	O
goto	O
done	O
;	O
}	O
}	O
pnote	pointer
=	O
pnotes	pointer
=	O
(	O
objcopy_internal_note	struct
*	O
)	O
xcalloc	function
(	O
(	O
size	int
/	O
12	int
)	O
,	O
sizeof	O
(	O
*	O
pnote	pointer
)	O
)	O
;	O
while	O
(	O
remain	long
>=	O
12	int
)	O
{	O
bfd_vma	long
start	long
,	O
end	pointer
;	O
pnote	pointer
->	O
note	struct
.	O
namesz	array
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
in	pointer
)	O
;	O
pnote	pointer
->	O
note	struct
.	O
descsz	array
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
in	pointer
+	O
4	int
)	O
;	O
pnote	pointer
->	O
note	struct
.	O
type	enum
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
in	pointer
+	O
8	int
)	O
;	O
pnote	pointer
->	O
padded_namesz	long
=	O
(	O
pnote	pointer
->	O
note	struct
.	O
namesz	array
+	O
3	int
)	O
&	O
~	O
3	int
;	O
if	O
(	O
(	O
(	O
pnote	pointer
->	O
note	struct
.	O
descsz	array
+	O
3	int
)	O
&	O
~	O
3	int
)	O
!=	O
pnote	pointer
->	O
note	struct
.	O
descsz	array
)	O
{	O
err	pointer
=	O
_	O
(	O
"corrupt GNU build attribute note: description size not a factor of 4"	pointer
)	O
;	O
goto	O
done	O
;	O
}	O
if	O
(	O
pnote	pointer
->	O
note	struct
.	O
type	enum
!=	O
NT_GNU_BUILD_ATTRIBUTE_OPEN	int
&&	O
pnote	pointer
->	O
note	struct
.	O
type	enum
!=	O
NT_GNU_BUILD_ATTRIBUTE_FUNC	int
)	O
{	O
err	pointer
=	O
_	O
(	O
"corrupt GNU build attribute note: wrong note type"	pointer
)	O
;	O
goto	O
done	O
;	O
}	O
if	O
(	O
pnote	pointer
->	O
padded_namesz	long
+	O
pnote	pointer
->	O
note	struct
.	O
descsz	array
+	O
12	int
>	O
remain	long
)	O
{	O
err	pointer
=	O
_	O
(	O
"corrupt GNU build attribute note: note too big"	pointer
)	O
;	O
goto	O
done	O
;	O
}	O
if	O
(	O
pnote	pointer
->	O
note	struct
.	O
namesz	array
<	O
2	int
)	O
{	O
err	pointer
=	O
_	O
(	O
"corrupt GNU build attribute note: name too small"	pointer
)	O
;	O
goto	O
done	O
;	O
}	O
pnote	pointer
->	O
note	struct
.	O
namedata	pointer
=	O
(	O
char	O
*	O
)	O
(	O
in	pointer
+	O
12	int
)	O
;	O
pnote	pointer
->	O
note	struct
.	O
descdata	pointer
=	O
(	O
char	O
*	O
)	O
(	O
in	pointer
+	O
12	int
+	O
pnote	pointer
->	O
padded_namesz	long
)	O
;	O
remain	long
-=	O
12	int
+	O
pnote	pointer
->	O
padded_namesz	long
+	O
pnote	pointer
->	O
note	struct
.	O
descsz	array
;	O
in	pointer
+=	O
12	int
+	O
pnote	pointer
->	O
padded_namesz	long
+	O
pnote	pointer
->	O
note	struct
.	O
descsz	array
;	O
if	O
(	O
pnote	pointer
->	O
note	struct
.	O
namesz	array
>	O
2	int
&&	O
pnote	pointer
->	O
note	struct
.	O
namedata	pointer
[	O
0	int
]	O
==	O
'$'	O
&&	O
pnote	pointer
->	O
note	struct
.	O
namedata	pointer
[	O
1	int
]	O
==	O
GNU_BUILD_ATTRIBUTE_VERSION	int
&&	O
pnote	pointer
->	O
note	struct
.	O
namedata	pointer
[	O
2	int
]	O
==	O
'1'	O
)	O
++	O
version_1_seen	int
;	O
else	O
if	O
(	O
is_version_note	function
(	O
pnote	pointer
)	O
)	O
{	O
if	O
(	O
pnote	pointer
->	O
note	struct
.	O
namedata	pointer
[	O
4	int
]	O
==	O
'2'	O
)	O
++	O
version_2_seen	int
;	O
else	O
if	O
(	O
pnote	pointer
->	O
note	struct
.	O
namedata	pointer
[	O
4	int
]	O
==	O
'3'	O
)	O
++	O
version_3_seen	int
;	O
else	O
{	O
err	pointer
=	O
_	O
(	O
"corrupt GNU build attribute note: unsupported version"	pointer
)	O
;	O
goto	O
done	O
;	O
}	O
}	O
switch	O
(	O
pnote	pointer
->	O
note	struct
.	O
descsz	array
)	O
{	O
case	O
0	int
:	O
start	long
=	O
end	pointer
=	O
0	int
;	O
break	O
;	O
case	O
4	int
:	O
start	long
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
pnote	pointer
->	O
note	struct
.	O
descdata	pointer
)	O
;	O
end	pointer
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
break	O
;	O
case	O
8	int
:	O
if	O
(	O
!	O
is_64bit	function
(	O
abfd	pointer
)	O
)	O
{	O
start	long
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
pnote	pointer
->	O
note	struct
.	O
descdata	pointer
)	O
;	O
end	pointer
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
pnote	pointer
->	O
note	struct
.	O
descdata	pointer
+	O
4	int
)	O
;	O
}	O
else	O
{	O
start	long
=	O
bfd_get_64	O
(	O
abfd	pointer
,	O
pnote	pointer
->	O
note	struct
.	O
descdata	pointer
)	O
;	O
end	pointer
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
}	O
break	O
;	O
case	O
16	int
:	O
start	long
=	O
bfd_get_64	O
(	O
abfd	pointer
,	O
pnote	pointer
->	O
note	struct
.	O
descdata	pointer
)	O
;	O
end	pointer
=	O
bfd_get_64	O
(	O
abfd	pointer
,	O
pnote	pointer
->	O
note	struct
.	O
descdata	pointer
+	O
8	int
)	O
;	O
break	O
;	O
default	O
:	O
err	pointer
=	O
_	O
(	O
"corrupt GNU build attribute note: bad description size"	pointer
)	O
;	O
goto	O
done	O
;	O
}	O
if	O
(	O
is_open_note	function
(	O
pnote	pointer
)	O
)	O
{	O
if	O
(	O
start	long
)	O
previous_open_start	long
=	O
start	long
;	O
pnote	pointer
->	O
start	long
=	O
previous_open_start	long
;	O
if	O
(	O
end	pointer
)	O
previous_open_end	long
=	O
end	pointer
;	O
pnote	pointer
->	O
end	pointer
=	O
previous_open_end	long
;	O
}	O
else	O
{	O
if	O
(	O
start	long
)	O
previous_func_start	long
=	O
start	long
;	O
pnote	pointer
->	O
start	long
=	O
previous_func_start	long
;	O
if	O
(	O
end	pointer
)	O
previous_func_end	long
=	O
end	pointer
;	O
pnote	pointer
->	O
end	pointer
=	O
previous_func_end	long
;	O
}	O
if	O
(	O
pnote	pointer
->	O
note	struct
.	O
namedata	pointer
[	O
pnote	pointer
->	O
note	struct
.	O
namesz	array
-	O
1	int
]	O
!=	O
0	int
)	O
{	O
err	pointer
=	O
_	O
(	O
"corrupt GNU build attribute note: name not NUL terminated"	pointer
)	O
;	O
goto	O
done	O
;	O
}	O
pnote	pointer
++	O
;	O
}	O
pnotes_end	pointer
=	O
pnote	pointer
;	O
if	O
(	O
remain	long
!=	O
0	int
)	O
{	O
err	pointer
=	O
_	O
(	O
"corrupt GNU build attribute notes: excess data at end"	pointer
)	O
;	O
goto	O
done	O
;	O
}	O
if	O
(	O
version_1_seen	int
==	O
0	int
&&	O
version_2_seen	int
==	O
0	int
&&	O
version_3_seen	int
==	O
0	int
)	O
{	O
non_fatal	function
(	O
_	O
(	O
"%s[%s]: Warning: version note missing - assuming version 3"	pointer
)	O
,	O
bfd_get_filename	function
(	O
abfd	pointer
)	O
,	O
bfd_section_name	function
(	O
sec	pointer
)	O
)	O
;	O
version_3_seen	int
=	O
2	int
;	O
}	O
if	O
(	O
(	O
version_1_seen	int
>	O
0	int
&&	O
version_2_seen	int
>	O
0	int
)	O
||	O
(	O
version_1_seen	int
>	O
0	int
&&	O
version_3_seen	int
>	O
0	int
)	O
||	O
(	O
version_2_seen	int
>	O
0	int
&&	O
version_3_seen	int
>	O
0	int
)	O
)	O
{	O
err	pointer
=	O
_	O
(	O
"bad GNU build attribute notes: multiple different versions"	pointer
)	O
;	O
goto	O
done	O
;	O
}	O
if	O
(	O
version_3_seen	int
==	O
0	int
)	O
{	O
merge_debug	O
(	O
"%s: skipping merge - not using v3 notes"	pointer
,	O
bfd_section_name	function
(	O
sec	pointer
)	O
)	O
;	O
goto	O
done	O
;	O
}	O
merge_debug	O
(	O
"Merging section %s which contains %ld notes\n"	pointer
,	O
sec	pointer
->	O
name	pointer
,	O
pnotes_end	pointer
-	O
pnotes	pointer
)	O
;	O
qsort	function
(	O
pnotes	pointer
,	O
pnotes_end	pointer
-	O
pnotes	pointer
,	O
sizeof	O
(	O
*	O
pnotes	pointer
)	O
,	O
compare_gnu_build_notes	function
)	O
;	O
for	O
(	O
pnote	pointer
=	O
pnotes	pointer
;	O
pnote	pointer
<	O
pnotes_end	pointer
;	O
pnote	pointer
++	O
)	O
{	O
if	O
(	O
is_deleted_note	function
(	O
pnote	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
pnote	pointer
->	O
start	long
==	O
pnote	pointer
->	O
end	pointer
)	O
{	O
merge_debug	O
(	O
"Delete note at offset %#08lx - empty range\n"	pointer
,	O
(	O
pnote	pointer
->	O
note	struct
.	O
namedata	pointer
-	O
(	O
char	O
*	O
)	O
contents	pointer
)	O
-	O
12	int
)	O
;	O
pnote	pointer
->	O
note	struct
.	O
type	enum
=	O
0	int
;	O
continue	O
;	O
}	O
int	O
iter	int
;	O
objcopy_internal_note	struct
*	O
back	pointer
;	O
for	O
(	O
iter	int
=	O
0	int
,	O
back	pointer
=	O
pnote	pointer
-	O
1	int
;	O
back	pointer
>=	O
pnotes	pointer
;	O
back	pointer
--	O
)	O
{	O
if	O
(	O
is_deleted_note	function
(	O
back	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
back	pointer
->	O
note	struct
.	O
namesz	array
!=	O
pnote	pointer
->	O
note	struct
.	O
namesz	array
||	O
memcmp	function
(	O
back	pointer
->	O
note	struct
.	O
namedata	pointer
,	O
pnote	pointer
->	O
note	struct
.	O
namedata	pointer
,	O
pnote	pointer
->	O
note	struct
.	O
namesz	array
)	O
!=	O
0	int
)	O
break	O
;	O
if	O
(	O
back	pointer
->	O
start	long
==	O
pnote	pointer
->	O
start	long
&&	O
back	pointer
->	O
end	pointer
==	O
pnote	pointer
->	O
end	pointer
)	O
{	O
merge_debug	O
(	O
"Delete note at offset %#08lx - duplicate of note at offset %#08lx\n"	pointer
,	O
(	O
pnote	pointer
->	O
note	struct
.	O
namedata	pointer
-	O
(	O
char	O
*	O
)	O
contents	pointer
)	O
-	O
12	int
,	O
(	O
back	pointer
->	O
note	struct
.	O
namedata	pointer
-	O
(	O
char	O
*	O
)	O
contents	pointer
)	O
-	O
12	int
)	O
;	O
pnote	pointer
->	O
note	struct
.	O
type	enum
=	O
0	int
;	O
break	O
;	O
}	O
if	O
(	O
contained_by	function
(	O
pnote	pointer
,	O
back	pointer
)	O
)	O
{	O
merge_debug	O
(	O
"Delete note at offset %#08lx - fully contained by note at %#08lx\n"	pointer
,	O
(	O
pnote	pointer
->	O
note	struct
.	O
namedata	pointer
-	O
(	O
char	O
*	O
)	O
contents	pointer
)	O
-	O
12	int
,	O
(	O
back	pointer
->	O
note	struct
.	O
namedata	pointer
-	O
(	O
char	O
*	O
)	O
contents	pointer
)	O
-	O
12	int
)	O
;	O
pnote	pointer
->	O
note	struct
.	O
type	enum
=	O
0	int
;	O
break	O
;	O
}	O
if	O
(	O
overlaps_or_adjoins	function
(	O
back	pointer
,	O
pnote	pointer
)	O
&&	O
is_func_note	function
(	O
back	pointer
)	O
==	O
is_func_note	function
(	O
pnote	pointer
)	O
)	O
{	O
merge_debug	O
(	O
"Delete note at offset %#08lx - merge into note at %#08lx\n"	pointer
,	O
(	O
pnote	pointer
->	O
note	struct
.	O
namedata	pointer
-	O
(	O
char	O
*	O
)	O
contents	pointer
)	O
-	O
12	int
,	O
(	O
back	pointer
->	O
note	struct
.	O
namedata	pointer
-	O
(	O
char	O
*	O
)	O
contents	pointer
)	O
-	O
12	int
)	O
;	O
back	pointer
->	O
end	pointer
=	O
back	pointer
->	O
end	pointer
>	O
pnote	pointer
->	O
end	pointer
?	O
back	pointer
->	O
end	pointer
:	O
pnote	pointer
->	O
end	pointer
;	O
back	pointer
->	O
start	long
=	O
back	pointer
->	O
start	long
<	O
pnote	pointer
->	O
start	long
?	O
back	pointer
->	O
start	long
:	O
pnote	pointer
->	O
start	long
;	O
pnote	pointer
->	O
note	struct
.	O
type	enum
=	O
0	int
;	O
break	O
;	O
}	O
if	O
(	O
iter	int
++	O
>	O
16	int
)	O
{	O
merge_debug	O
(	O
"ITERATION LIMIT REACHED\n"	pointer
)	O
;	O
break	O
;	O
}	O
}	O
}	O
merge_debug	O
(	O
"Final sorting of notes\n"	pointer
)	O
;	O
qsort	function
(	O
pnotes	pointer
,	O
pnotes_end	pointer
-	O
pnotes	pointer
,	O
sizeof	O
(	O
*	O
pnotes	pointer
)	O
,	O
sort_gnu_build_notes	function
)	O
;	O
bfd_byte	char
*	O
new_contents	pointer
;	O
bfd_byte	char
*	O
old	pointer
;	O
bfd_byte	char
*	O
new	pointer
;	O
bfd_size_type	long
new_size	long
;	O
bfd_vma	long
prev_start	long
=	O
0	int
;	O
bfd_vma	long
prev_end	long
=	O
0	int
;	O
new	pointer
=	O
new_contents	pointer
=	O
xmalloc	function
(	O
size	int
*	O
2	int
)	O
;	O
for	O
(	O
pnote	pointer
=	O
pnotes	pointer
,	O
old	pointer
=	O
contents	pointer
;	O
pnote	pointer
<	O
pnotes_end	pointer
;	O
pnote	pointer
++	O
)	O
{	O
bfd_size_type	long
note_size	long
=	O
12	int
+	O
pnote	pointer
->	O
padded_namesz	long
+	O
pnote	pointer
->	O
note	struct
.	O
descsz	array
;	O
if	O
(	O
!	O
is_deleted_note	function
(	O
pnote	pointer
)	O
)	O
{	O
if	O
(	O
pnote	pointer
->	O
start	long
==	O
prev_start	long
&&	O
pnote	pointer
->	O
end	pointer
==	O
prev_end	long
)	O
{	O
bfd_put_32	O
(	O
abfd	pointer
,	O
pnote	pointer
->	O
note	struct
.	O
namesz	array
,	O
new	pointer
)	O
;	O
bfd_put_32	O
(	O
abfd	pointer
,	O
0	int
,	O
new	pointer
+	O
4	int
)	O
;	O
bfd_put_32	O
(	O
abfd	pointer
,	O
pnote	pointer
->	O
note	struct
.	O
type	enum
,	O
new	pointer
+	O
8	int
)	O
;	O
new	pointer
+=	O
12	int
;	O
memcpy	function
(	O
new	pointer
,	O
pnote	pointer
->	O
note	struct
.	O
namedata	pointer
,	O
pnote	pointer
->	O
note	struct
.	O
namesz	array
)	O
;	O
if	O
(	O
pnote	pointer
->	O
note	struct
.	O
namesz	array
<	O
pnote	pointer
->	O
padded_namesz	long
)	O
memset	function
(	O
new	pointer
+	O
pnote	pointer
->	O
note	struct
.	O
namesz	array
,	O
0	int
,	O
pnote	pointer
->	O
padded_namesz	long
-	O
pnote	pointer
->	O
note	struct
.	O
namesz	array
)	O
;	O
new	pointer
+=	O
pnote	pointer
->	O
padded_namesz	long
;	O
}	O
else	O
{	O
bfd_put_32	O
(	O
abfd	pointer
,	O
pnote	pointer
->	O
note	struct
.	O
namesz	array
,	O
new	pointer
)	O
;	O
bfd_put_32	O
(	O
abfd	pointer
,	O
is_64bit	function
(	O
abfd	pointer
)	O
?	O
16	int
:	O
8	int
,	O
new	pointer
+	O
4	int
)	O
;	O
bfd_put_32	O
(	O
abfd	pointer
,	O
pnote	pointer
->	O
note	struct
.	O
type	enum
,	O
new	pointer
+	O
8	int
)	O
;	O
new	pointer
+=	O
12	int
;	O
memcpy	function
(	O
new	pointer
,	O
pnote	pointer
->	O
note	struct
.	O
namedata	pointer
,	O
pnote	pointer
->	O
note	struct
.	O
namesz	array
)	O
;	O
if	O
(	O
pnote	pointer
->	O
note	struct
.	O
namesz	array
<	O
pnote	pointer
->	O
padded_namesz	long
)	O
memset	function
(	O
new	pointer
+	O
pnote	pointer
->	O
note	struct
.	O
namesz	array
,	O
0	int
,	O
pnote	pointer
->	O
padded_namesz	long
-	O
pnote	pointer
->	O
note	struct
.	O
namesz	array
)	O
;	O
new	pointer
+=	O
pnote	pointer
->	O
padded_namesz	long
;	O
if	O
(	O
is_64bit	function
(	O
abfd	pointer
)	O
)	O
{	O
bfd_put_64	O
(	O
abfd	pointer
,	O
pnote	pointer
->	O
start	long
,	O
new	pointer
)	O
;	O
bfd_put_64	O
(	O
abfd	pointer
,	O
pnote	pointer
->	O
end	pointer
,	O
new	pointer
+	O
8	int
)	O
;	O
new	pointer
+=	O
16	int
;	O
}	O
else	O
{	O
bfd_put_32	O
(	O
abfd	pointer
,	O
pnote	pointer
->	O
start	long
,	O
new	pointer
)	O
;	O
bfd_put_32	O
(	O
abfd	pointer
,	O
pnote	pointer
->	O
end	pointer
,	O
new	pointer
+	O
4	int
)	O
;	O
new	pointer
+=	O
8	int
;	O
}	O
prev_start	long
=	O
pnote	pointer
->	O
start	long
;	O
prev_end	long
=	O
pnote	pointer
->	O
end	pointer
;	O
}	O
}	O
old	pointer
+=	O
note_size	long
;	O
}	O
new_size	long
=	O
new	pointer
-	O
new_contents	pointer
;	O
if	O
(	O
new_size	long
<	O
size	int
)	O
{	O
memcpy	function
(	O
contents	pointer
,	O
new_contents	pointer
,	O
new_size	long
)	O
;	O
size	int
=	O
new_size	long
;	O
}	O
free	function
(	O
new_contents	pointer
)	O
;	O
done	O
:	O
if	O
(	O
err	pointer
)	O
{	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
abfd	pointer
,	O
sec	pointer
,	O
err	pointer
)	O
;	O
status	int
=	O
1	int
;	O
}	O
free	function
(	O
pnotes	pointer
)	O
;	O
return	O
size	int
;	O
}	O
static	O
bfd_boolean	int
copy_object	function
(	O
bfd	struct
*	O
ibfd	pointer
,	O
bfd	struct
*	O
obfd	pointer
,	O
const	O
bfd_arch_info_type	struct
*	O
input_arch	pointer
)	O
{	O
bfd_vma	long
start	long
;	O
long	O
symcount	int
;	O
asection	struct
*	O
*	O
osections	pointer
=	O
NULL	O
;	O
asection	struct
*	O
osec	pointer
;	O
asection	struct
*	O
gnu_debuglink_section	pointer
=	O
NULL	O
;	O
bfd_size_type	long
*	O
gaps	pointer
=	O
NULL	O
;	O
bfd_size_type	long
max_gap	long
=	O
0	int
;	O
long	O
symsize	long
;	O
void	O
*	O
dhandle	pointer
;	O
enum	O
bfd_architecture	enum
iarch	enum
;	O
unsigned	O
int	O
imach	int
;	O
unsigned	O
int	O
c	struct
,	O
i	pointer
;	O
if	O
(	O
ibfd	pointer
->	O
xvec	pointer
->	O
byteorder	enum
!=	O
obfd	pointer
->	O
xvec	pointer
->	O
byteorder	enum
&&	O
ibfd	pointer
->	O
xvec	pointer
->	O
byteorder	enum
!=	O
BFD_ENDIAN_UNKNOWN	int
&&	O
obfd	pointer
->	O
xvec	pointer
->	O
byteorder	enum
!=	O
BFD_ENDIAN_UNKNOWN	int
)	O
{	O
non_fatal	function
(	O
_	O
(	O
"Unable to change endianness of input file(s)"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
!	O
bfd_set_format	function
(	O
obfd	pointer
,	O
bfd_get_format	function
(	O
ibfd	pointer
)	O
)	O
)	O
{	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
obfd	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
ibfd	pointer
->	O
sections	pointer
==	O
NULL	O
)	O
{	O
non_fatal	function
(	O
_	O
(	O
"error: the input file '%s' has no sections"	pointer
)	O
,	O
bfd_get_archive_filename	function
(	O
ibfd	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
bfd_get_flavour	function
(	O
ibfd	pointer
)	O
!=	O
bfd_target_elf_flavour	int
)	O
{	O
if	O
(	O
(	O
do_debug_sections	enum
&	O
compress	int
)	O
!=	O
0	int
&&	O
do_debug_sections	enum
!=	O
compress	int
)	O
{	O
non_fatal	function
(	O
_	O
(	O
"--compress-debug-sections=[zlib|zlib-gnu|zlib-gabi] is unsupported on `%s'"	pointer
)	O
,	O
bfd_get_archive_filename	function
(	O
ibfd	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
do_elf_stt_common	enum
)	O
{	O
non_fatal	function
(	O
_	O
(	O
"--elf-stt-common=[yes|no] is unsupported on `%s'"	pointer
)	O
,	O
bfd_get_archive_filename	function
(	O
ibfd	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
if	O
(	O
verbose	int
)	O
printf	function
(	O
_	O
(	O
"copy from `%s' [%s] to `%s' [%s]\n"	pointer
)	O
,	O
bfd_get_archive_filename	function
(	O
ibfd	pointer
)	O
,	O
bfd_get_target	function
(	O
ibfd	pointer
)	O
,	O
bfd_get_filename	function
(	O
obfd	pointer
)	O
,	O
bfd_get_target	function
(	O
obfd	pointer
)	O
)	O
;	O
if	O
(	O
extract_symbol	int
)	O
start	long
=	O
0	int
;	O
else	O
{	O
if	O
(	O
set_start_set	int
)	O
start	long
=	O
set_start	long
;	O
else	O
start	long
=	O
bfd_get_start_address	function
(	O
ibfd	pointer
)	O
;	O
start	long
+=	O
change_start	long
;	O
}	O
if	O
(	O
bfd_get_format	function
(	O
obfd	pointer
)	O
!=	O
bfd_core	int
)	O
{	O
flagword	int
flags	int
;	O
flags	int
=	O
bfd_get_file_flags	function
(	O
ibfd	pointer
)	O
;	O
flags	int
|=	O
bfd_flags_to_set	int
;	O
flags	int
&=	O
~	O
bfd_flags_to_clear	int
;	O
flags	int
&=	O
bfd_applicable_file_flags	function
(	O
obfd	pointer
)	O
;	O
if	O
(	O
strip_symbols	enum
==	O
STRIP_ALL	int
)	O
flags	int
&=	O
~	O
HAS_RELOC	int
;	O
if	O
(	O
!	O
bfd_set_start_address	function
(	O
obfd	pointer
,	O
start	long
)	O
||	O
!	O
bfd_set_file_flags	function
(	O
obfd	pointer
,	O
flags	int
)	O
)	O
{	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
ibfd	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
iarch	enum
=	O
bfd_get_arch	function
(	O
ibfd	pointer
)	O
;	O
imach	int
=	O
bfd_get_mach	function
(	O
ibfd	pointer
)	O
;	O
if	O
(	O
input_arch	pointer
)	O
{	O
if	O
(	O
iarch	enum
==	O
bfd_arch_unknown	int
)	O
{	O
iarch	enum
=	O
input_arch	pointer
->	O
arch	enum
;	O
imach	int
=	O
input_arch	pointer
->	O
mach	long
;	O
}	O
else	O
non_fatal	function
(	O
_	O
(	O
"Input file `%s' ignores binary architecture parameter."	pointer
)	O
,	O
bfd_get_archive_filename	function
(	O
ibfd	pointer
)	O
)	O
;	O
}	O
if	O
(	O
iarch	enum
==	O
bfd_arch_unknown	int
&&	O
bfd_get_flavour	function
(	O
ibfd	pointer
)	O
!=	O
bfd_target_elf_flavour	int
&&	O
bfd_get_flavour	function
(	O
obfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
obfd	pointer
)	O
;	O
iarch	enum
=	O
bed	pointer
->	O
arch	enum
;	O
imach	int
=	O
0	int
;	O
}	O
if	O
(	O
!	O
bfd_set_arch_mach	O
(	O
obfd	pointer
,	O
iarch	enum
,	O
imach	int
)	O
&&	O
(	O
ibfd	pointer
->	O
target_defaulted	int
||	O
bfd_get_arch	function
(	O
ibfd	pointer
)	O
!=	O
bfd_get_arch	function
(	O
obfd	pointer
)	O
)	O
)	O
{	O
if	O
(	O
bfd_get_arch	function
(	O
ibfd	pointer
)	O
==	O
bfd_arch_unknown	int
)	O
non_fatal	function
(	O
_	O
(	O
"Unable to recognise the format of the input file `%s'"	pointer
)	O
,	O
bfd_get_archive_filename	function
(	O
ibfd	pointer
)	O
)	O
;	O
else	O
non_fatal	function
(	O
_	O
(	O
"Output file cannot represent architecture `%s'"	pointer
)	O
,	O
bfd_printable_arch_mach	function
(	O
bfd_get_arch	function
(	O
ibfd	pointer
)	O
,	O
bfd_get_mach	function
(	O
ibfd	pointer
)	O
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
!	O
bfd_set_format	function
(	O
obfd	pointer
,	O
bfd_get_format	function
(	O
ibfd	pointer
)	O
)	O
)	O
{	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
ibfd	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
bfd_get_flavour	function
(	O
obfd	pointer
)	O
==	O
bfd_target_coff_flavour	int
&&	O
bfd_pei_p	O
(	O
obfd	pointer
)	O
)	O
{	O
pe_data_type	struct
*	O
pe	struct
=	O
pe_data	O
(	O
obfd	pointer
)	O
;	O
if	O
(	O
bfd_get_flavour	function
(	O
ibfd	pointer
)	O
==	O
bfd_target_coff_flavour	int
&&	O
bfd_pei_p	O
(	O
ibfd	pointer
)	O
)	O
pe	struct
->	O
pe_opthdr	struct
=	O
pe_data	O
(	O
ibfd	pointer
)	O
->	O
pe_opthdr	struct
;	O
if	O
(	O
pe_file_alignment	long
!=	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
pe	struct
->	O
pe_opthdr	struct
.	O
FileAlignment	int
=	O
pe_file_alignment	long
;	O
else	O
pe_file_alignment	long
=	O
PE_DEF_FILE_ALIGNMENT	int
;	O
if	O
(	O
pe_heap_commit	long
!=	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
pe	struct
->	O
pe_opthdr	struct
.	O
SizeOfHeapCommit	long
=	O
pe_heap_commit	long
;	O
if	O
(	O
pe_heap_reserve	long
!=	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
pe	struct
->	O
pe_opthdr	struct
.	O
SizeOfHeapCommit	long
=	O
pe_heap_reserve	long
;	O
if	O
(	O
pe_image_base	long
!=	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
pe	struct
->	O
pe_opthdr	struct
.	O
ImageBase	long
=	O
pe_image_base	long
;	O
if	O
(	O
pe_section_alignment	long
!=	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
pe	struct
->	O
pe_opthdr	struct
.	O
SectionAlignment	int
=	O
pe_section_alignment	long
;	O
else	O
pe_section_alignment	long
=	O
PE_DEF_SECTION_ALIGNMENT	int
;	O
if	O
(	O
pe_stack_commit	long
!=	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
pe	struct
->	O
pe_opthdr	struct
.	O
SizeOfStackCommit	long
=	O
pe_stack_commit	long
;	O
if	O
(	O
pe_stack_reserve	long
!=	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
pe	struct
->	O
pe_opthdr	struct
.	O
SizeOfStackCommit	long
=	O
pe_stack_reserve	long
;	O
if	O
(	O
pe_subsystem	short
!=	O
-	O
1	int
)	O
pe	struct
->	O
pe_opthdr	struct
.	O
Subsystem	short
=	O
pe_subsystem	short
;	O
if	O
(	O
pe_major_subsystem_version	short
!=	O
-	O
1	int
)	O
pe	struct
->	O
pe_opthdr	struct
.	O
MajorSubsystemVersion	short
=	O
pe_major_subsystem_version	short
;	O
if	O
(	O
pe_minor_subsystem_version	short
!=	O
-	O
1	int
)	O
pe	struct
->	O
pe_opthdr	struct
.	O
MinorSubsystemVersion	short
=	O
pe_minor_subsystem_version	short
;	O
if	O
(	O
pe_file_alignment	long
>	O
pe_section_alignment	long
)	O
{	O
char	O
file_alignment	array
[	O
20	int
]	O
,	O
section_alignment	array
[	O
20	int
]	O
;	O
sprintf_vma	O
(	O
file_alignment	array
,	O
pe_file_alignment	long
)	O
;	O
sprintf_vma	O
(	O
section_alignment	array
,	O
pe_section_alignment	long
)	O
;	O
non_fatal	function
(	O
_	O
(	O
"warning: file alignment (0x%s) > section alignment (0x%s)"	pointer
)	O
,	O
file_alignment	array
,	O
section_alignment	array
)	O
;	O
}	O
}	O
if	O
(	O
isympp	pointer
)	O
free	function
(	O
isympp	pointer
)	O
;	O
if	O
(	O
osympp	pointer
!=	O
isympp	pointer
)	O
free	function
(	O
osympp	pointer
)	O
;	O
isympp	pointer
=	O
NULL	O
;	O
osympp	pointer
=	O
NULL	O
;	O
symsize	long
=	O
bfd_get_symtab_upper_bound	O
(	O
ibfd	pointer
)	O
;	O
if	O
(	O
symsize	long
<	O
0	int
)	O
{	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
ibfd	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
osympp	pointer
=	O
isympp	pointer
=	O
(	O
asymbol	struct
*	O
*	O
)	O
xmalloc	function
(	O
symsize	long
)	O
;	O
symcount	int
=	O
bfd_canonicalize_symtab	O
(	O
ibfd	pointer
,	O
isympp	pointer
)	O
;	O
if	O
(	O
symcount	int
<	O
0	int
)	O
{	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
ibfd	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
symcount	int
==	O
0	int
)	O
{	O
free	function
(	O
isympp	pointer
)	O
;	O
osympp	pointer
=	O
isympp	pointer
=	O
NULL	O
;	O
}	O
bfd_map_over_sections	function
(	O
ibfd	pointer
,	O
setup_section	function
,	O
obfd	pointer
)	O
;	O
if	O
(	O
!	O
extract_symbol	int
)	O
setup_bfd_headers	function
(	O
ibfd	pointer
,	O
obfd	pointer
)	O
;	O
if	O
(	O
add_sections	pointer
!=	O
NULL	O
)	O
{	O
struct	O
section_add	struct
*	O
padd	pointer
;	O
struct	O
section_list	struct
*	O
pset	pointer
;	O
for	O
(	O
padd	pointer
=	O
add_sections	pointer
;	O
padd	pointer
!=	O
NULL	O
;	O
padd	pointer
=	O
padd	pointer
->	O
next	pointer
)	O
{	O
flagword	int
flags	int
;	O
pset	pointer
=	O
find_section_list	function
(	O
padd	pointer
->	O
name	pointer
,	O
FALSE	int
,	O
SECTION_CONTEXT_SET_FLAGS	O
)	O
;	O
if	O
(	O
pset	pointer
!=	O
NULL	O
)	O
flags	int
=	O
pset	pointer
->	O
flags	int
|	O
SEC_HAS_CONTENTS	int
;	O
else	O
flags	int
=	O
SEC_HAS_CONTENTS	int
|	O
SEC_READONLY	int
|	O
SEC_DATA	int
;	O
if	O
(	O
bfd_get_section_by_name	function
(	O
obfd	pointer
,	O
padd	pointer
->	O
name	pointer
)	O
)	O
{	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
obfd	pointer
,	O
NULL	O
,	O
_	O
(	O
"can't add section '%s'"	pointer
)	O
,	O
padd	pointer
->	O
name	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
else	O
{	O
padd	pointer
->	O
section	pointer
=	O
bfd_make_section_with_flags	function
(	O
obfd	pointer
,	O
padd	pointer
->	O
name	pointer
,	O
flags	int
|	O
SEC_LINKER_CREATED	int
)	O
;	O
if	O
(	O
padd	pointer
->	O
section	pointer
==	O
NULL	O
)	O
{	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
obfd	pointer
,	O
NULL	O
,	O
_	O
(	O
"can't create section `%s'"	pointer
)	O
,	O
padd	pointer
->	O
name	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
if	O
(	O
!	O
bfd_set_section_size	function
(	O
padd	pointer
->	O
section	pointer
,	O
padd	pointer
->	O
size	int
)	O
)	O
{	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
obfd	pointer
,	O
padd	pointer
->	O
section	pointer
,	O
NULL	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
pset	pointer
=	O
find_section_list	function
(	O
padd	pointer
->	O
name	pointer
,	O
FALSE	int
,	O
SECTION_CONTEXT_SET_VMA	O
|	O
SECTION_CONTEXT_ALTER_VMA	O
)	O
;	O
if	O
(	O
pset	pointer
!=	O
NULL	O
&&	O
!	O
bfd_set_section_vma	function
(	O
padd	pointer
->	O
section	pointer
,	O
pset	pointer
->	O
vma_val	long
)	O
)	O
{	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
obfd	pointer
,	O
padd	pointer
->	O
section	pointer
,	O
NULL	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
pset	pointer
=	O
find_section_list	function
(	O
padd	pointer
->	O
name	pointer
,	O
FALSE	int
,	O
SECTION_CONTEXT_SET_LMA	O
|	O
SECTION_CONTEXT_ALTER_LMA	O
)	O
;	O
if	O
(	O
pset	pointer
!=	O
NULL	O
)	O
{	O
padd	pointer
->	O
section	pointer
->	O
lma	long
=	O
pset	pointer
->	O
lma_val	long
;	O
if	O
(	O
!	O
bfd_set_section_alignment	function
(	O
padd	pointer
->	O
section	pointer
,	O
bfd_section_alignment	function
(	O
padd	pointer
->	O
section	pointer
)	O
)	O
)	O
{	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
obfd	pointer
,	O
padd	pointer
->	O
section	pointer
,	O
NULL	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
update_sections	pointer
!=	O
NULL	O
)	O
{	O
struct	O
section_add	struct
*	O
pupdate	pointer
;	O
for	O
(	O
pupdate	pointer
=	O
update_sections	pointer
;	O
pupdate	pointer
!=	O
NULL	O
;	O
pupdate	pointer
=	O
pupdate	pointer
->	O
next	pointer
)	O
{	O
pupdate	pointer
->	O
section	pointer
=	O
bfd_get_section_by_name	function
(	O
ibfd	pointer
,	O
pupdate	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
pupdate	pointer
->	O
section	pointer
==	O
NULL	O
)	O
{	O
non_fatal	function
(	O
_	O
(	O
"error: %s not found, can't be updated"	pointer
)	O
,	O
pupdate	pointer
->	O
name	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
osec	pointer
=	O
pupdate	pointer
->	O
section	pointer
->	O
output_section	pointer
;	O
if	O
(	O
!	O
bfd_set_section_size	function
(	O
osec	pointer
,	O
pupdate	pointer
->	O
size	int
)	O
)	O
{	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
obfd	pointer
,	O
osec	pointer
,	O
NULL	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
}	O
merged_note_section	struct
*	O
merged_note_sections	pointer
=	O
NULL	O
;	O
if	O
(	O
merge_notes	int
)	O
{	O
for	O
(	O
osec	pointer
=	O
ibfd	pointer
->	O
sections	pointer
;	O
osec	pointer
!=	O
NULL	O
;	O
osec	pointer
=	O
osec	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
!	O
is_mergeable_note_section	function
(	O
ibfd	pointer
,	O
osec	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
osec	pointer
->	O
output_section	pointer
==	O
NULL	O
)	O
continue	O
;	O
bfd_size_type	long
size	int
=	O
bfd_section_size	function
(	O
osec	pointer
)	O
;	O
if	O
(	O
size	int
==	O
0	int
)	O
{	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
ibfd	pointer
,	O
osec	pointer
,	O
_	O
(	O
"warning: note section is empty"	pointer
)	O
)	O
;	O
continue	O
;	O
}	O
merged_note_section	struct
*	O
merged	int
=	O
xmalloc	function
(	O
sizeof	O
*	O
merged	int
)	O
;	O
merged	int
->	O
contents	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
bfd_get_full_section_contents	function
(	O
ibfd	pointer
,	O
osec	pointer
,	O
&	O
merged	int
->	O
contents	pointer
)	O
)	O
{	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
ibfd	pointer
,	O
osec	pointer
,	O
_	O
(	O
"warning: could not load note section"	pointer
)	O
)	O
;	O
free	function
(	O
merged	int
)	O
;	O
continue	O
;	O
}	O
merged	int
->	O
size	int
=	O
merge_gnu_build_notes	function
(	O
ibfd	pointer
,	O
osec	pointer
,	O
size	int
,	O
merged	int
->	O
contents	pointer
)	O
;	O
if	O
(	O
size	int
!=	O
merged	int
->	O
size	int
&&	O
!	O
bfd_set_section_size	function
(	O
osec	pointer
->	O
output_section	pointer
,	O
merged	int
->	O
size	int
)	O
)	O
{	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
obfd	pointer
,	O
osec	pointer
,	O
_	O
(	O
"warning: failed to set merged notes size"	pointer
)	O
)	O
;	O
free	function
(	O
merged	int
->	O
contents	pointer
)	O
;	O
free	function
(	O
merged	int
)	O
;	O
continue	O
;	O
}	O
merged	int
->	O
sec	pointer
=	O
osec	pointer
;	O
merged	int
->	O
next	pointer
=	O
merged_note_sections	pointer
;	O
merged_note_sections	pointer
=	O
merged	int
;	O
}	O
}	O
if	O
(	O
dump_sections	pointer
!=	O
NULL	O
)	O
{	O
struct	O
section_add	struct
*	O
pdump	pointer
;	O
for	O
(	O
pdump	pointer
=	O
dump_sections	pointer
;	O
pdump	pointer
!=	O
NULL	O
;	O
pdump	pointer
=	O
pdump	pointer
->	O
next	pointer
)	O
{	O
osec	pointer
=	O
bfd_get_section_by_name	function
(	O
ibfd	pointer
,	O
pdump	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
osec	pointer
==	O
NULL	O
)	O
{	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
ibfd	pointer
,	O
NULL	O
,	O
_	O
(	O
"can't dump section '%s' - it does not exist"	pointer
)	O
,	O
pdump	pointer
->	O
name	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
(	O
bfd_section_flags	function
(	O
osec	pointer
)	O
&	O
SEC_HAS_CONTENTS	int
)	O
==	O
0	int
)	O
{	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
ibfd	pointer
,	O
osec	pointer
,	O
_	O
(	O
"can't dump section - it has no contents"	pointer
)	O
)	O
;	O
continue	O
;	O
}	O
bfd_size_type	long
size	int
=	O
bfd_section_size	function
(	O
osec	pointer
)	O
;	O
if	O
(	O
size	int
==	O
0	int
)	O
{	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
ibfd	pointer
,	O
osec	pointer
,	O
_	O
(	O
"can't dump section - it is empty"	pointer
)	O
)	O
;	O
continue	O
;	O
}	O
FILE	struct
*	O
f	pointer
;	O
f	pointer
=	O
fopen	function
(	O
pdump	pointer
->	O
filename	pointer
,	O
FOPEN_WB	pointer
)	O
;	O
if	O
(	O
f	pointer
==	O
NULL	O
)	O
{	O
bfd_nonfatal_message	function
(	O
pdump	pointer
->	O
filename	pointer
,	O
NULL	O
,	O
NULL	O
,	O
_	O
(	O
"could not open section dump file"	pointer
)	O
)	O
;	O
continue	O
;	O
}	O
bfd_byte	char
*	O
contents	pointer
;	O
if	O
(	O
bfd_malloc_and_get_section	function
(	O
ibfd	pointer
,	O
osec	pointer
,	O
&	O
contents	pointer
)	O
)	O
{	O
if	O
(	O
fwrite	function
(	O
contents	pointer
,	O
1	int
,	O
size	int
,	O
f	pointer
)	O
!=	O
size	int
)	O
{	O
non_fatal	function
(	O
_	O
(	O
"error writing section contents to %s (error: %s)"	pointer
)	O
,	O
pdump	pointer
->	O
filename	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
free	function
(	O
contents	pointer
)	O
;	O
fclose	function
(	O
f	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
else	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
ibfd	pointer
,	O
osec	pointer
,	O
_	O
(	O
"could not retrieve section contents"	pointer
)	O
)	O
;	O
fclose	function
(	O
f	pointer
)	O
;	O
free	function
(	O
contents	pointer
)	O
;	O
}	O
}	O
if	O
(	O
gnu_debuglink_filename	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
bfd_get_section_by_name	function
(	O
obfd	pointer
,	O
".gnu_debuglink"	pointer
)	O
)	O
{	O
non_fatal	function
(	O
_	O
(	O
"%s: debuglink section already exists"	pointer
)	O
,	O
bfd_get_filename	function
(	O
obfd	pointer
)	O
)	O
;	O
gnu_debuglink_filename	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
gnu_debuglink_section	pointer
=	O
bfd_create_gnu_debuglink_section	function
(	O
obfd	pointer
,	O
gnu_debuglink_filename	pointer
)	O
;	O
if	O
(	O
gnu_debuglink_section	pointer
==	O
NULL	O
)	O
{	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
obfd	pointer
,	O
NULL	O
,	O
_	O
(	O
"cannot create debug link section `%s'"	pointer
)	O
,	O
gnu_debuglink_filename	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
bfd_get_flavour	function
(	O
obfd	pointer
)	O
==	O
bfd_target_coff_flavour	int
)	O
{	O
bfd_vma	long
debuglink_vma	long
;	O
asection	struct
*	O
highest_section	pointer
;	O
for	O
(	O
osec	pointer
=	O
obfd	pointer
->	O
sections	pointer
,	O
highest_section	pointer
=	O
NULL	O
;	O
osec	pointer
!=	O
NULL	O
;	O
osec	pointer
=	O
osec	pointer
->	O
next	pointer
)	O
if	O
(	O
osec	pointer
->	O
vma	long
>	O
0	int
&&	O
(	O
highest_section	pointer
==	O
NULL	O
||	O
osec	pointer
->	O
vma	long
>	O
highest_section	pointer
->	O
vma	long
)	O
)	O
highest_section	pointer
=	O
osec	pointer
;	O
if	O
(	O
highest_section	pointer
)	O
debuglink_vma	long
=	O
BFD_ALIGN	O
(	O
highest_section	pointer
->	O
vma	long
+	O
highest_section	pointer
->	O
size	int
,	O
0x1000	int
)	O
;	O
else	O
debuglink_vma	long
=	O
0x1000	int
;	O
bfd_set_section_vma	function
(	O
gnu_debuglink_section	pointer
,	O
debuglink_vma	long
)	O
;	O
}	O
}	O
}	O
c	struct
=	O
bfd_count_sections	function
(	O
obfd	pointer
)	O
;	O
if	O
(	O
c	struct
!=	O
0	int
&&	O
(	O
gap_fill_set	int
||	O
pad_to_set	int
)	O
)	O
{	O
asection	struct
*	O
*	O
set	pointer
;	O
osections	pointer
=	O
(	O
asection	struct
*	O
*	O
)	O
xmalloc	function
(	O
c	struct
*	O
sizeof	O
(	O
asection	struct
*	O
)	O
)	O
;	O
set	pointer
=	O
osections	pointer
;	O
bfd_map_over_sections	function
(	O
obfd	pointer
,	O
get_sections	function
,	O
&	O
set	pointer
)	O
;	O
qsort	function
(	O
osections	pointer
,	O
c	struct
,	O
sizeof	O
(	O
asection	struct
*	O
)	O
,	O
compare_section_lma	function
)	O
;	O
gaps	pointer
=	O
(	O
bfd_size_type	long
*	O
)	O
xmalloc	function
(	O
c	struct
*	O
sizeof	O
(	O
bfd_size_type	long
)	O
)	O
;	O
memset	function
(	O
gaps	pointer
,	O
0	int
,	O
c	struct
*	O
sizeof	O
(	O
bfd_size_type	long
)	O
)	O
;	O
if	O
(	O
gap_fill_set	int
)	O
{	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
c	struct
-	O
1	int
;	O
i	pointer
++	O
)	O
{	O
flagword	int
flags	int
;	O
bfd_size_type	long
size	int
;	O
bfd_vma	long
gap_start	long
,	O
gap_stop	long
;	O
flags	int
=	O
bfd_section_flags	function
(	O
osections	pointer
[	O
i	pointer
]	O
)	O
;	O
if	O
(	O
(	O
flags	int
&	O
SEC_HAS_CONTENTS	int
)	O
==	O
0	int
||	O
(	O
flags	int
&	O
SEC_LOAD	int
)	O
==	O
0	int
)	O
continue	O
;	O
size	int
=	O
bfd_section_size	function
(	O
osections	pointer
[	O
i	pointer
]	O
)	O
;	O
gap_start	long
=	O
bfd_section_lma	function
(	O
osections	pointer
[	O
i	pointer
]	O
)	O
+	O
size	int
;	O
gap_stop	long
=	O
bfd_section_lma	function
(	O
osections	pointer
[	O
i	pointer
+	O
1	int
]	O
)	O
;	O
if	O
(	O
gap_start	long
<	O
gap_stop	long
)	O
{	O
if	O
(	O
!	O
bfd_set_section_size	function
(	O
osections	pointer
[	O
i	pointer
]	O
,	O
size	int
+	O
(	O
gap_stop	long
-	O
gap_start	long
)	O
)	O
)	O
{	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
obfd	pointer
,	O
osections	pointer
[	O
i	pointer
]	O
,	O
_	O
(	O
"Can't fill gap after section"	pointer
)	O
)	O
;	O
status	int
=	O
1	int
;	O
break	O
;	O
}	O
gaps	pointer
[	O
i	pointer
]	O
=	O
gap_stop	long
-	O
gap_start	long
;	O
if	O
(	O
max_gap	long
<	O
gap_stop	long
-	O
gap_start	long
)	O
max_gap	long
=	O
gap_stop	long
-	O
gap_start	long
;	O
}	O
}	O
}	O
if	O
(	O
pad_to_set	int
)	O
{	O
bfd_vma	long
lma	long
;	O
bfd_size_type	long
size	int
;	O
lma	long
=	O
bfd_section_lma	function
(	O
osections	pointer
[	O
c	struct
-	O
1	int
]	O
)	O
;	O
size	int
=	O
bfd_section_size	function
(	O
osections	pointer
[	O
c	struct
-	O
1	int
]	O
)	O
;	O
if	O
(	O
lma	long
+	O
size	int
<	O
pad_to	long
)	O
{	O
if	O
(	O
!	O
bfd_set_section_size	function
(	O
osections	pointer
[	O
c	struct
-	O
1	int
]	O
,	O
pad_to	long
-	O
lma	long
)	O
)	O
{	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
obfd	pointer
,	O
osections	pointer
[	O
c	struct
-	O
1	int
]	O
,	O
_	O
(	O
"can't add padding"	pointer
)	O
)	O
;	O
status	int
=	O
1	int
;	O
}	O
else	O
{	O
gaps	pointer
[	O
c	struct
-	O
1	int
]	O
=	O
pad_to	long
-	O
(	O
lma	long
+	O
size	int
)	O
;	O
if	O
(	O
max_gap	long
<	O
pad_to	long
-	O
(	O
lma	long
+	O
size	int
)	O
)	O
max_gap	long
=	O
pad_to	long
-	O
(	O
lma	long
+	O
size	int
)	O
;	O
}	O
}	O
}	O
}	O
dhandle	pointer
=	O
NULL	O
;	O
if	O
(	O
convert_debugging	int
)	O
dhandle	pointer
=	O
read_debugging_info	function
(	O
ibfd	pointer
,	O
isympp	pointer
,	O
symcount	int
,	O
FALSE	int
)	O
;	O
if	O
(	O
strip_symbols	enum
==	O
STRIP_DEBUG	int
||	O
strip_symbols	enum
==	O
STRIP_ALL	int
||	O
strip_symbols	enum
==	O
STRIP_UNNEEDED	int
||	O
strip_symbols	enum
==	O
STRIP_NONDEBUG	int
||	O
strip_symbols	enum
==	O
STRIP_DWO	int
||	O
strip_symbols	enum
==	O
STRIP_NONDWO	int
||	O
discard_locals	enum
!=	O
LOCALS_UNDEF	int
||	O
localize_hidden	int
||	O
htab_elements	function
(	O
strip_specific_htab	pointer
)	O
!=	O
0	int
||	O
htab_elements	function
(	O
keep_specific_htab	pointer
)	O
!=	O
0	int
||	O
htab_elements	function
(	O
localize_specific_htab	pointer
)	O
!=	O
0	int
||	O
htab_elements	function
(	O
globalize_specific_htab	pointer
)	O
!=	O
0	int
||	O
htab_elements	function
(	O
keepglobal_specific_htab	pointer
)	O
!=	O
0	int
||	O
htab_elements	function
(	O
weaken_specific_htab	pointer
)	O
!=	O
0	int
||	O
htab_elements	function
(	O
redefine_specific_htab	pointer
)	O
!=	O
0	int
||	O
prefix_symbols_string	pointer
||	O
sections_removed	int
||	O
sections_copied	int
||	O
convert_debugging	int
||	O
change_leading_char	int
||	O
remove_leading_char	int
||	O
section_rename_list	pointer
||	O
weaken	int
||	O
add_symbols	int
)	O
{	O
if	O
(	O
strip_symbols	enum
!=	O
STRIP_ALL	int
)	O
{	O
bfd_set_error	function
(	O
bfd_error_no_error	int
)	O
;	O
bfd_map_over_sections	function
(	O
ibfd	pointer
,	O
mark_symbols_used_in_relocations	function
,	O
isympp	pointer
)	O
;	O
if	O
(	O
bfd_get_error	function
(	O
)	O
!=	O
bfd_error_no_error	int
)	O
{	O
status	int
=	O
1	int
;	O
return	O
FALSE	int
;	O
}	O
}	O
osympp	pointer
=	O
(	O
asymbol	struct
*	O
*	O
)	O
xmalloc	function
(	O
(	O
symcount	int
+	O
add_symbols	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
asymbol	struct
*	O
)	O
)	O
;	O
symcount	int
=	O
filter_symbols	function
(	O
ibfd	pointer
,	O
obfd	pointer
,	O
osympp	pointer
,	O
isympp	pointer
,	O
symcount	int
)	O
;	O
}	O
if	O
(	O
convert_debugging	int
&&	O
dhandle	pointer
!=	O
NULL	O
)	O
{	O
bfd_boolean	int
res	int
;	O
res	int
=	O
write_debugging_info	function
(	O
obfd	pointer
,	O
dhandle	pointer
,	O
&	O
symcount	int
,	O
&	O
osympp	pointer
)	O
;	O
free	function
(	O
dhandle	pointer
)	O
;	O
dhandle	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
res	int
)	O
{	O
status	int
=	O
1	int
;	O
return	O
FALSE	int
;	O
}	O
}	O
bfd_set_symtab	function
(	O
obfd	pointer
,	O
osympp	pointer
,	O
symcount	int
)	O
;	O
bfd_map_over_sections	function
(	O
ibfd	pointer
,	O
copy_relocations_in_section	function
,	O
obfd	pointer
)	O
;	O
bfd_map_over_sections	function
(	O
ibfd	pointer
,	O
copy_section	function
,	O
obfd	pointer
)	O
;	O
if	O
(	O
add_sections	pointer
!=	O
NULL	O
)	O
{	O
struct	O
section_add	struct
*	O
padd	pointer
;	O
for	O
(	O
padd	pointer
=	O
add_sections	pointer
;	O
padd	pointer
!=	O
NULL	O
;	O
padd	pointer
=	O
padd	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
!	O
bfd_set_section_contents	function
(	O
obfd	pointer
,	O
padd	pointer
->	O
section	pointer
,	O
padd	pointer
->	O
contents	pointer
,	O
0	int
,	O
padd	pointer
->	O
size	int
)	O
)	O
{	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
obfd	pointer
,	O
padd	pointer
->	O
section	pointer
,	O
NULL	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
}	O
if	O
(	O
update_sections	pointer
!=	O
NULL	O
)	O
{	O
struct	O
section_add	struct
*	O
pupdate	pointer
;	O
for	O
(	O
pupdate	pointer
=	O
update_sections	pointer
;	O
pupdate	pointer
!=	O
NULL	O
;	O
pupdate	pointer
=	O
pupdate	pointer
->	O
next	pointer
)	O
{	O
osec	pointer
=	O
pupdate	pointer
->	O
section	pointer
->	O
output_section	pointer
;	O
if	O
(	O
!	O
bfd_set_section_contents	function
(	O
obfd	pointer
,	O
osec	pointer
,	O
pupdate	pointer
->	O
contents	pointer
,	O
0	int
,	O
pupdate	pointer
->	O
size	int
)	O
)	O
{	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
obfd	pointer
,	O
osec	pointer
,	O
NULL	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
}	O
if	O
(	O
merged_note_sections	pointer
!=	O
NULL	O
)	O
{	O
merged_note_section	struct
*	O
merged	int
=	O
NULL	O
;	O
for	O
(	O
osec	pointer
=	O
obfd	pointer
->	O
sections	pointer
;	O
osec	pointer
!=	O
NULL	O
;	O
osec	pointer
=	O
osec	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
!	O
is_mergeable_note_section	function
(	O
obfd	pointer
,	O
osec	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
merged	int
==	O
NULL	O
)	O
merged	int
=	O
merged_note_sections	pointer
;	O
if	O
(	O
strcmp	function
(	O
bfd_section_name	function
(	O
merged	int
->	O
sec	pointer
)	O
,	O
bfd_section_name	function
(	O
osec	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
for	O
(	O
merged	int
=	O
merged_note_sections	pointer
;	O
merged	int
!=	O
NULL	O
;	O
merged	int
=	O
merged	int
->	O
next	pointer
)	O
if	O
(	O
strcmp	function
(	O
bfd_section_name	function
(	O
merged	int
->	O
sec	pointer
)	O
,	O
bfd_section_name	function
(	O
osec	pointer
)	O
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
merged	int
==	O
NULL	O
)	O
{	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
obfd	pointer
,	O
osec	pointer
,	O
_	O
(	O
"error: failed to locate merged notes"	pointer
)	O
)	O
;	O
continue	O
;	O
}	O
}	O
if	O
(	O
merged	int
->	O
contents	pointer
==	O
NULL	O
)	O
{	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
obfd	pointer
,	O
osec	pointer
,	O
_	O
(	O
"error: failed to merge notes"	pointer
)	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
bfd_set_section_contents	function
(	O
obfd	pointer
,	O
osec	pointer
,	O
merged	int
->	O
contents	pointer
,	O
0	int
,	O
merged	int
->	O
size	int
)	O
)	O
{	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
obfd	pointer
,	O
osec	pointer
,	O
_	O
(	O
"error: failed to copy merged notes into output"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
merged	int
=	O
merged	int
->	O
next	pointer
;	O
}	O
merged_note_section	struct
*	O
next	pointer
;	O
for	O
(	O
merged	int
=	O
merged_note_sections	pointer
;	O
merged	int
!=	O
NULL	O
;	O
merged	int
=	O
next	pointer
)	O
{	O
next	pointer
=	O
merged	int
->	O
next	pointer
;	O
free	function
(	O
merged	int
->	O
contents	pointer
)	O
;	O
free	function
(	O
merged	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
merge_notes	int
&&	O
!	O
is_strip	int
)	O
non_fatal	function
(	O
_	O
(	O
"%s: Could not find any mergeable note sections"	pointer
)	O
,	O
bfd_get_filename	function
(	O
ibfd	pointer
)	O
)	O
;	O
if	O
(	O
gnu_debuglink_filename	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
bfd_fill_in_gnu_debuglink_section	function
(	O
obfd	pointer
,	O
gnu_debuglink_section	pointer
,	O
gnu_debuglink_filename	pointer
)	O
)	O
{	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
obfd	pointer
,	O
NULL	O
,	O
_	O
(	O
"cannot fill debug link section `%s'"	pointer
)	O
,	O
gnu_debuglink_filename	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
if	O
(	O
gap_fill_set	int
||	O
pad_to_set	int
)	O
{	O
bfd_byte	char
*	O
buf	pointer
;	O
if	O
(	O
max_gap	long
>	O
8192	int
)	O
max_gap	long
=	O
8192	int
;	O
buf	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
xmalloc	function
(	O
max_gap	long
)	O
;	O
memset	function
(	O
buf	pointer
,	O
gap_fill	char
,	O
max_gap	long
)	O
;	O
c	struct
=	O
bfd_count_sections	function
(	O
obfd	pointer
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
c	struct
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
gaps	pointer
[	O
i	pointer
]	O
!=	O
0	int
)	O
{	O
bfd_size_type	long
left	long
;	O
file_ptr	long
off	long
;	O
left	long
=	O
gaps	pointer
[	O
i	pointer
]	O
;	O
off	long
=	O
bfd_section_size	function
(	O
osections	pointer
[	O
i	pointer
]	O
)	O
-	O
left	long
;	O
while	O
(	O
left	long
>	O
0	int
)	O
{	O
bfd_size_type	long
now	long
;	O
if	O
(	O
left	long
>	O
8192	int
)	O
now	long
=	O
8192	int
;	O
else	O
now	long
=	O
left	long
;	O
if	O
(	O
!	O
bfd_set_section_contents	function
(	O
obfd	pointer
,	O
osections	pointer
[	O
i	pointer
]	O
,	O
buf	pointer
,	O
off	long
,	O
now	long
)	O
)	O
{	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
obfd	pointer
,	O
osections	pointer
[	O
i	pointer
]	O
,	O
NULL	O
)	O
;	O
free	function
(	O
buf	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
left	long
-=	O
now	long
;	O
off	long
+=	O
now	long
;	O
}	O
}	O
}	O
free	function
(	O
buf	pointer
)	O
;	O
free	function
(	O
gaps	pointer
)	O
;	O
gaps	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
!	O
bfd_copy_private_bfd_data	function
(	O
ibfd	pointer
,	O
obfd	pointer
)	O
)	O
{	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
obfd	pointer
,	O
NULL	O
,	O
_	O
(	O
"error copying private BFD data"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
use_alt_mach_code	long
!=	O
0	int
)	O
{	O
if	O
(	O
!	O
bfd_alt_mach_code	function
(	O
obfd	pointer
,	O
use_alt_mach_code	long
)	O
)	O
{	O
non_fatal	function
(	O
_	O
(	O
"this target does not support %lu alternative machine codes"	pointer
)	O
,	O
use_alt_mach_code	long
)	O
;	O
if	O
(	O
bfd_get_flavour	function
(	O
obfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
)	O
{	O
non_fatal	function
(	O
_	O
(	O
"treating that number as an absolute e_machine value instead"	pointer
)	O
)	O
;	O
elf_elfheader	O
(	O
obfd	pointer
)	O
->	O
e_machine	array
=	O
use_alt_mach_code	long
;	O
}	O
else	O
non_fatal	function
(	O
_	O
(	O
"ignoring the alternative value"	pointer
)	O
)	O
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
void	O
copy_archive	function
(	O
bfd	struct
*	O
ibfd	pointer
,	O
bfd	struct
*	O
obfd	pointer
,	O
const	O
char	O
*	O
output_target	pointer
,	O
bfd_boolean	int
force_output_target	int
,	O
const	O
bfd_arch_info_type	struct
*	O
input_arch	pointer
)	O
{	O
struct	O
name_list	struct
{	O
struct	O
name_list	struct
*	O
next	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
bfd	struct
*	O
obfd	pointer
;	O
}	O
*	O
list	pointer
,	O
*	O
l	long
;	O
bfd	struct
*	O
*	O
ptr	pointer
=	O
&	O
obfd	pointer
->	O
archive_head	pointer
;	O
bfd	struct
*	O
this_element	pointer
;	O
char	O
*	O
dir	pointer
;	O
const	O
char	O
*	O
filename	pointer
;	O
if	O
(	O
ibfd	pointer
->	O
is_thin_archive	int
)	O
{	O
status	int
=	O
1	int
;	O
bfd_set_error	function
(	O
bfd_error_invalid_operation	int
)	O
;	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
ibfd	pointer
,	O
NULL	O
,	O
_	O
(	O
"sorry: copying thin archives is not currently supported"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
dir	pointer
=	O
make_tempdir	function
(	O
bfd_get_filename	function
(	O
obfd	pointer
)	O
)	O
;	O
if	O
(	O
dir	pointer
==	O
NULL	O
)	O
fatal	function
(	O
_	O
(	O
"cannot create tempdir for archive copying (error: %s)"	pointer
)	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
if	O
(	O
strip_symbols	enum
==	O
STRIP_ALL	int
)	O
obfd	pointer
->	O
has_armap	int
=	O
FALSE	int
;	O
else	O
obfd	pointer
->	O
has_armap	int
=	O
ibfd	pointer
->	O
has_armap	int
;	O
obfd	pointer
->	O
is_thin_archive	int
=	O
ibfd	pointer
->	O
is_thin_archive	int
;	O
if	O
(	O
deterministic	int
)	O
obfd	pointer
->	O
flags	int
|=	O
BFD_DETERMINISTIC_OUTPUT	int
;	O
list	pointer
=	O
NULL	O
;	O
this_element	pointer
=	O
bfd_openr_next_archived_file	function
(	O
ibfd	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
bfd_set_format	function
(	O
obfd	pointer
,	O
bfd_get_format	function
(	O
ibfd	pointer
)	O
)	O
)	O
{	O
status	int
=	O
1	int
;	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
obfd	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
goto	O
cleanup_and_exit	O
;	O
}	O
while	O
(	O
!	O
status	int
&&	O
this_element	pointer
!=	O
NULL	O
)	O
{	O
char	O
*	O
output_name	pointer
;	O
bfd	struct
*	O
output_bfd	pointer
;	O
bfd	struct
*	O
last_element	pointer
;	O
struct	O
stat	struct
buf	pointer
;	O
int	O
stat_status	int
=	O
0	int
;	O
bfd_boolean	int
del	int
=	O
TRUE	int
;	O
bfd_boolean	int
ok_object	int
;	O
if	O
(	O
!	O
is_valid_archive_path	function
(	O
bfd_get_filename	function
(	O
this_element	pointer
)	O
)	O
)	O
{	O
non_fatal	function
(	O
_	O
(	O
"illegal pathname found in archive member: %s"	pointer
)	O
,	O
bfd_get_filename	function
(	O
this_element	pointer
)	O
)	O
;	O
status	int
=	O
1	int
;	O
goto	O
cleanup_and_exit	O
;	O
}	O
output_name	pointer
=	O
concat	function
(	O
dir	pointer
,	O
"/"	pointer
,	O
bfd_get_filename	function
(	O
this_element	pointer
)	O
,	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
if	O
(	O
stat	struct
(	O
output_name	pointer
,	O
&	O
buf	pointer
)	O
>=	O
0	int
)	O
{	O
char	O
*	O
tmpdir	pointer
=	O
make_tempdir	function
(	O
output_name	pointer
)	O
;	O
free	function
(	O
output_name	pointer
)	O
;	O
if	O
(	O
tmpdir	pointer
==	O
NULL	O
)	O
{	O
non_fatal	function
(	O
_	O
(	O
"cannot create tempdir for archive copying (error: %s)"	pointer
)	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
status	int
=	O
1	int
;	O
goto	O
cleanup_and_exit	O
;	O
}	O
l	long
=	O
(	O
struct	O
name_list	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
name_list	struct
)	O
)	O
;	O
l	long
->	O
name	pointer
=	O
tmpdir	pointer
;	O
l	long
->	O
next	pointer
=	O
list	pointer
;	O
l	long
->	O
obfd	pointer
=	O
NULL	O
;	O
list	pointer
=	O
l	long
;	O
output_name	pointer
=	O
concat	function
(	O
tmpdir	pointer
,	O
"/"	pointer
,	O
bfd_get_filename	function
(	O
this_element	pointer
)	O
,	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
}	O
if	O
(	O
preserve_dates	int
)	O
{	O
stat_status	int
=	O
bfd_stat_arch_elt	O
(	O
this_element	pointer
,	O
&	O
buf	pointer
)	O
;	O
if	O
(	O
stat_status	int
!=	O
0	int
)	O
non_fatal	function
(	O
_	O
(	O
"internal stat error on %s"	pointer
)	O
,	O
bfd_get_filename	function
(	O
this_element	pointer
)	O
)	O
;	O
}	O
l	long
=	O
(	O
struct	O
name_list	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
name_list	struct
)	O
)	O
;	O
l	long
->	O
name	pointer
=	O
output_name	pointer
;	O
l	long
->	O
next	pointer
=	O
list	pointer
;	O
l	long
->	O
obfd	pointer
=	O
NULL	O
;	O
list	pointer
=	O
l	long
;	O
ok_object	int
=	O
bfd_check_format	function
(	O
this_element	pointer
,	O
bfd_object	int
)	O
;	O
if	O
(	O
!	O
ok_object	int
)	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
this_element	pointer
,	O
NULL	O
,	O
_	O
(	O
"Unable to recognise the format of file"	pointer
)	O
)	O
;	O
if	O
(	O
force_output_target	int
||	O
!	O
ok_object	int
)	O
output_bfd	pointer
=	O
bfd_openw	function
(	O
output_name	pointer
,	O
output_target	pointer
)	O
;	O
else	O
output_bfd	pointer
=	O
bfd_openw	function
(	O
output_name	pointer
,	O
bfd_get_target	function
(	O
this_element	pointer
)	O
)	O
;	O
if	O
(	O
output_bfd	pointer
==	O
NULL	O
)	O
{	O
bfd_nonfatal_message	function
(	O
output_name	pointer
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
status	int
=	O
1	int
;	O
goto	O
cleanup_and_exit	O
;	O
}	O
if	O
(	O
ok_object	int
)	O
{	O
del	int
=	O
!	O
copy_object	function
(	O
this_element	pointer
,	O
output_bfd	pointer
,	O
input_arch	pointer
)	O
;	O
if	O
(	O
del	int
&&	O
bfd_get_arch	function
(	O
this_element	pointer
)	O
==	O
bfd_arch_unknown	int
)	O
ok_object	int
=	O
FALSE	int
;	O
else	O
if	O
(	O
!	O
bfd_close	function
(	O
output_bfd	pointer
)	O
)	O
{	O
bfd_nonfatal_message	function
(	O
output_name	pointer
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
status	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
!	O
ok_object	int
)	O
{	O
del	int
=	O
!	O
copy_unknown_object	function
(	O
this_element	pointer
,	O
output_bfd	pointer
)	O
;	O
if	O
(	O
!	O
bfd_close_all_done	function
(	O
output_bfd	pointer
)	O
)	O
{	O
bfd_nonfatal_message	function
(	O
output_name	pointer
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
status	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
del	int
)	O
{	O
unlink	function
(	O
output_name	pointer
)	O
;	O
status	int
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
preserve_dates	int
&&	O
stat_status	int
==	O
0	int
)	O
set_times	function
(	O
output_name	pointer
,	O
&	O
buf	pointer
)	O
;	O
output_bfd	pointer
=	O
bfd_openr	function
(	O
output_name	pointer
,	O
output_target	pointer
)	O
;	O
l	long
->	O
obfd	pointer
=	O
output_bfd	pointer
;	O
*	O
ptr	pointer
=	O
output_bfd	pointer
;	O
ptr	pointer
=	O
&	O
output_bfd	pointer
->	O
archive_next	pointer
;	O
last_element	pointer
=	O
this_element	pointer
;	O
this_element	pointer
=	O
bfd_openr_next_archived_file	function
(	O
ibfd	pointer
,	O
last_element	pointer
)	O
;	O
bfd_close	function
(	O
last_element	pointer
)	O
;	O
}	O
}	O
*	O
ptr	pointer
=	O
NULL	O
;	O
filename	pointer
=	O
bfd_get_filename	function
(	O
obfd	pointer
)	O
;	O
if	O
(	O
!	O
bfd_close	function
(	O
obfd	pointer
)	O
)	O
{	O
status	int
=	O
1	int
;	O
bfd_nonfatal_message	function
(	O
filename	pointer
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
filename	pointer
=	O
bfd_get_filename	function
(	O
ibfd	pointer
)	O
;	O
if	O
(	O
!	O
bfd_close	function
(	O
ibfd	pointer
)	O
)	O
{	O
status	int
=	O
1	int
;	O
bfd_nonfatal_message	function
(	O
filename	pointer
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
cleanup_and_exit	O
:	O
{	O
struct	O
name_list	struct
*	O
next	pointer
;	O
for	O
(	O
l	long
=	O
list	pointer
;	O
l	long
!=	O
NULL	O
;	O
l	long
=	O
next	pointer
)	O
{	O
if	O
(	O
l	long
->	O
obfd	pointer
==	O
NULL	O
)	O
rmdir	function
(	O
l	long
->	O
name	pointer
)	O
;	O
else	O
{	O
bfd_close	function
(	O
l	long
->	O
obfd	pointer
)	O
;	O
unlink	function
(	O
l	long
->	O
name	pointer
)	O
;	O
}	O
next	pointer
=	O
l	long
->	O
next	pointer
;	O
free	function
(	O
l	long
)	O
;	O
}	O
}	O
rmdir	function
(	O
dir	pointer
)	O
;	O
}	O
static	O
void	O
set_long_section_mode	function
(	O
bfd	struct
*	O
output_bfd	pointer
,	O
bfd	struct
*	O
input_bfd	pointer
,	O
enum	O
long_section_name_handling	enum
style	pointer
)	O
{	O
if	O
(	O
bfd_get_flavour	function
(	O
output_bfd	pointer
)	O
==	O
bfd_target_coff_flavour	int
)	O
{	O
if	O
(	O
style	pointer
==	O
KEEP	int
&&	O
bfd_get_flavour	function
(	O
input_bfd	pointer
)	O
==	O
bfd_target_coff_flavour	int
)	O
style	pointer
=	O
bfd_coff_long_section_names	O
(	O
input_bfd	pointer
)	O
?	O
ENABLE	int
:	O
DISABLE	int
;	O
bfd_coff_set_long_section_names	O
(	O
output_bfd	pointer
,	O
style	pointer
!=	O
DISABLE	int
)	O
;	O
}	O
}	O
static	O
void	O
copy_file	function
(	O
const	O
char	O
*	O
input_filename	pointer
,	O
const	O
char	O
*	O
output_filename	pointer
,	O
const	O
char	O
*	O
input_target	pointer
,	O
const	O
char	O
*	O
output_target	pointer
,	O
const	O
bfd_arch_info_type	struct
*	O
input_arch	pointer
)	O
{	O
bfd	struct
*	O
ibfd	pointer
;	O
char	O
*	O
*	O
obj_matching	pointer
;	O
char	O
*	O
*	O
core_matching	pointer
;	O
off_t	long
size	int
=	O
get_file_size	function
(	O
input_filename	pointer
)	O
;	O
if	O
(	O
size	int
<	O
1	int
)	O
{	O
if	O
(	O
size	int
==	O
0	int
)	O
non_fatal	function
(	O
_	O
(	O
"error: the input file '%s' is empty"	pointer
)	O
,	O
input_filename	pointer
)	O
;	O
status	int
=	O
1	int
;	O
return	O
;	O
}	O
ibfd	pointer
=	O
bfd_openr	function
(	O
input_filename	pointer
,	O
input_target	pointer
)	O
;	O
if	O
(	O
ibfd	pointer
==	O
NULL	O
)	O
{	O
bfd_nonfatal_message	function
(	O
input_filename	pointer
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
status	int
=	O
1	int
;	O
return	O
;	O
}	O
switch	O
(	O
do_debug_sections	enum
)	O
{	O
case	O
compress	int
:	O
case	O
compress_zlib	int
:	O
case	O
compress_gnu_zlib	int
:	O
case	O
compress_gabi_zlib	int
:	O
ibfd	pointer
->	O
flags	int
|=	O
BFD_COMPRESS	int
;	O
if	O
(	O
do_debug_sections	enum
!=	O
compress_gnu_zlib	int
)	O
ibfd	pointer
->	O
flags	int
|=	O
BFD_COMPRESS_GABI	int
;	O
break	O
;	O
case	O
decompress	int
:	O
ibfd	pointer
->	O
flags	int
|=	O
BFD_DECOMPRESS	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
switch	O
(	O
do_elf_stt_common	enum
)	O
{	O
case	O
elf_stt_common	int
:	O
ibfd	pointer
->	O
flags	int
|=	O
BFD_CONVERT_ELF_COMMON	int
|	O
BFD_USE_ELF_STT_COMMON	int
;	O
break	O
;	O
break	O
;	O
case	O
no_elf_stt_common	int
:	O
ibfd	pointer
->	O
flags	int
|=	O
BFD_CONVERT_ELF_COMMON	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
bfd_check_format	function
(	O
ibfd	pointer
,	O
bfd_archive	int
)	O
)	O
{	O
bfd_boolean	int
force_output_target	int
;	O
bfd	struct
*	O
obfd	pointer
;	O
if	O
(	O
output_target	pointer
==	O
NULL	O
)	O
{	O
output_target	pointer
=	O
bfd_get_target	function
(	O
ibfd	pointer
)	O
;	O
force_output_target	int
=	O
FALSE	int
;	O
}	O
else	O
force_output_target	int
=	O
TRUE	int
;	O
obfd	pointer
=	O
bfd_openw	function
(	O
output_filename	pointer
,	O
output_target	pointer
)	O
;	O
if	O
(	O
obfd	pointer
==	O
NULL	O
)	O
{	O
bfd_nonfatal_message	function
(	O
output_filename	pointer
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
status	int
=	O
1	int
;	O
return	O
;	O
}	O
if	O
(	O
gnu_debuglink_filename	pointer
!=	O
NULL	O
)	O
{	O
non_fatal	function
(	O
_	O
(	O
"--add-gnu-debuglink ignored for archive %s"	pointer
)	O
,	O
bfd_get_filename	function
(	O
ibfd	pointer
)	O
)	O
;	O
gnu_debuglink_filename	pointer
=	O
NULL	O
;	O
}	O
set_long_section_mode	function
(	O
obfd	pointer
,	O
ibfd	pointer
,	O
long_section_names	enum
)	O
;	O
copy_archive	function
(	O
ibfd	pointer
,	O
obfd	pointer
,	O
output_target	pointer
,	O
force_output_target	int
,	O
input_arch	pointer
)	O
;	O
}	O
else	O
if	O
(	O
bfd_check_format_matches	function
(	O
ibfd	pointer
,	O
bfd_object	int
,	O
&	O
obj_matching	pointer
)	O
)	O
{	O
bfd	struct
*	O
obfd	pointer
;	O
do_copy	O
:	O
if	O
(	O
output_target	pointer
==	O
NULL	O
)	O
output_target	pointer
=	O
bfd_get_target	function
(	O
ibfd	pointer
)	O
;	O
obfd	pointer
=	O
bfd_openw	function
(	O
output_filename	pointer
,	O
output_target	pointer
)	O
;	O
if	O
(	O
obfd	pointer
==	O
NULL	O
)	O
{	O
bfd_nonfatal_message	function
(	O
output_filename	pointer
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
status	int
=	O
1	int
;	O
return	O
;	O
}	O
set_long_section_mode	function
(	O
obfd	pointer
,	O
ibfd	pointer
,	O
long_section_names	enum
)	O
;	O
if	O
(	O
!	O
copy_object	function
(	O
ibfd	pointer
,	O
obfd	pointer
,	O
input_arch	pointer
)	O
)	O
status	int
=	O
1	int
;	O
if	O
(	O
!	O
(	O
status	int
?	O
bfd_close_all_done	function
(	O
obfd	pointer
)	O
:	O
bfd_close	function
(	O
obfd	pointer
)	O
)	O
)	O
{	O
status	int
=	O
1	int
;	O
bfd_nonfatal_message	function
(	O
output_filename	pointer
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
bfd_close	function
(	O
ibfd	pointer
)	O
)	O
{	O
status	int
=	O
1	int
;	O
bfd_nonfatal_message	function
(	O
input_filename	pointer
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
return	O
;	O
}	O
}	O
else	O
{	O
bfd_error_type	enum
obj_error	enum
=	O
bfd_get_error	function
(	O
)	O
;	O
bfd_error_type	enum
core_error	enum
;	O
if	O
(	O
bfd_check_format_matches	function
(	O
ibfd	pointer
,	O
bfd_core	int
,	O
&	O
core_matching	pointer
)	O
)	O
{	O
if	O
(	O
obj_error	enum
==	O
bfd_error_file_ambiguously_recognized	int
)	O
free	function
(	O
obj_matching	pointer
)	O
;	O
goto	O
do_copy	O
;	O
}	O
core_error	enum
=	O
bfd_get_error	function
(	O
)	O
;	O
if	O
(	O
obj_error	enum
!=	O
core_error	enum
)	O
bfd_set_error	function
(	O
obj_error	enum
)	O
;	O
bfd_nonfatal_message	function
(	O
input_filename	pointer
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
obj_error	enum
==	O
bfd_error_file_ambiguously_recognized	int
)	O
{	O
list_matching_formats	function
(	O
obj_matching	pointer
)	O
;	O
free	function
(	O
obj_matching	pointer
)	O
;	O
}	O
if	O
(	O
core_error	enum
==	O
bfd_error_file_ambiguously_recognized	int
)	O
{	O
list_matching_formats	function
(	O
core_matching	pointer
)	O
;	O
free	function
(	O
core_matching	pointer
)	O
;	O
}	O
status	int
=	O
1	int
;	O
}	O
}	O
static	O
void	O
add_section_rename	function
(	O
const	O
char	O
*	O
old_name	pointer
,	O
const	O
char	O
*	O
new_name	pointer
,	O
flagword	int
flags	int
)	O
{	O
section_rename	struct
*	O
srename	pointer
;	O
for	O
(	O
srename	pointer
=	O
section_rename_list	pointer
;	O
srename	pointer
!=	O
NULL	O
;	O
srename	pointer
=	O
srename	pointer
->	O
next	pointer
)	O
if	O
(	O
strcmp	function
(	O
srename	pointer
->	O
old_name	pointer
,	O
old_name	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
strcmp	function
(	O
srename	pointer
->	O
new_name	pointer
,	O
new_name	pointer
)	O
==	O
0	int
&&	O
srename	pointer
->	O
flags	int
==	O
flags	int
)	O
return	O
;	O
fatal	function
(	O
_	O
(	O
"Multiple renames of section %s"	pointer
)	O
,	O
old_name	pointer
)	O
;	O
}	O
srename	pointer
=	O
(	O
section_rename	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
*	O
srename	pointer
)	O
)	O
;	O
srename	pointer
->	O
old_name	pointer
=	O
old_name	pointer
;	O
srename	pointer
->	O
new_name	pointer
=	O
new_name	pointer
;	O
srename	pointer
->	O
flags	int
=	O
flags	int
;	O
srename	pointer
->	O
next	pointer
=	O
section_rename_list	pointer
;	O
section_rename_list	pointer
=	O
srename	pointer
;	O
}	O
static	O
const	O
char	O
*	O
find_section_rename	function
(	O
const	O
char	O
*	O
old_name	pointer
,	O
flagword	int
*	O
returned_flags	pointer
)	O
{	O
const	O
section_rename	struct
*	O
srename	pointer
;	O
for	O
(	O
srename	pointer
=	O
section_rename_list	pointer
;	O
srename	pointer
!=	O
NULL	O
;	O
srename	pointer
=	O
srename	pointer
->	O
next	pointer
)	O
if	O
(	O
strcmp	function
(	O
srename	pointer
->	O
old_name	pointer
,	O
old_name	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
returned_flags	pointer
!=	O
NULL	O
&&	O
srename	pointer
->	O
flags	int
!=	O
(	O
flagword	int
)	O
-	O
1	int
)	O
*	O
returned_flags	pointer
=	O
srename	pointer
->	O
flags	int
;	O
return	O
srename	pointer
->	O
new_name	pointer
;	O
}	O
return	O
old_name	pointer
;	O
}	O
static	O
void	O
setup_bfd_headers	function
(	O
bfd	struct
*	O
ibfd	pointer
,	O
bfd	struct
*	O
obfd	pointer
)	O
{	O
if	O
(	O
!	O
bfd_copy_private_header_data	function
(	O
ibfd	pointer
,	O
obfd	pointer
)	O
)	O
{	O
status	int
=	O
1	int
;	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
ibfd	pointer
,	O
NULL	O
,	O
_	O
(	O
"error in private header data"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
return	O
;	O
}	O
static	O
void	O
setup_section	function
(	O
bfd	struct
*	O
ibfd	pointer
,	O
sec_ptr	pointer
isection	pointer
,	O
void	O
*	O
obfdarg	pointer
)	O
{	O
bfd	struct
*	O
obfd	pointer
=	O
(	O
bfd	struct
*	O
)	O
obfdarg	pointer
;	O
struct	O
section_list	struct
*	O
p	pointer
;	O
sec_ptr	pointer
osection	pointer
;	O
bfd_size_type	long
size	int
;	O
bfd_vma	long
vma	long
;	O
bfd_vma	long
lma	long
;	O
flagword	int
flags	int
;	O
const	O
char	O
*	O
err	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
char	O
*	O
prefix	pointer
=	O
NULL	O
;	O
bfd_boolean	int
make_nobits	int
;	O
unsigned	O
int	O
alignment	int
;	O
if	O
(	O
is_strip_section	function
(	O
ibfd	pointer
,	O
isection	pointer
)	O
)	O
return	O
;	O
name	pointer
=	O
bfd_section_name	function
(	O
isection	pointer
)	O
;	O
flags	int
=	O
bfd_section_flags	function
(	O
isection	pointer
)	O
;	O
if	O
(	O
bfd_get_flavour	function
(	O
ibfd	pointer
)	O
!=	O
bfd_get_flavour	function
(	O
obfd	pointer
)	O
)	O
{	O
flags	int
&=	O
bfd_applicable_section_flags	function
(	O
ibfd	pointer
)	O
;	O
flags	int
&=	O
bfd_applicable_section_flags	function
(	O
obfd	pointer
)	O
;	O
}	O
name	pointer
=	O
find_section_rename	function
(	O
name	pointer
,	O
&	O
flags	int
)	O
;	O
if	O
(	O
prefix_alloc_sections_string	pointer
&&	O
(	O
bfd_section_flags	function
(	O
isection	pointer
)	O
&	O
SEC_ALLOC	int
)	O
!=	O
0	int
)	O
prefix	pointer
=	O
prefix_alloc_sections_string	pointer
;	O
else	O
if	O
(	O
prefix_sections_string	pointer
)	O
prefix	pointer
=	O
prefix_sections_string	pointer
;	O
if	O
(	O
prefix	pointer
)	O
{	O
char	O
*	O
n	long
;	O
n	long
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
strlen	function
(	O
prefix	pointer
)	O
+	O
strlen	function
(	O
name	pointer
)	O
+	O
1	int
)	O
;	O
strcpy	function
(	O
n	long
,	O
prefix	pointer
)	O
;	O
strcat	function
(	O
n	long
,	O
name	pointer
)	O
;	O
name	pointer
=	O
n	long
;	O
}	O
make_nobits	int
=	O
FALSE	int
;	O
p	pointer
=	O
find_section_list	function
(	O
bfd_section_name	function
(	O
isection	pointer
)	O
,	O
FALSE	int
,	O
SECTION_CONTEXT_SET_FLAGS	O
)	O
;	O
if	O
(	O
p	pointer
!=	O
NULL	O
)	O
flags	int
=	O
p	pointer
->	O
flags	int
|	O
(	O
flags	int
&	O
(	O
SEC_HAS_CONTENTS	int
|	O
SEC_RELOC	int
)	O
)	O
;	O
else	O
if	O
(	O
strip_symbols	enum
==	O
STRIP_NONDEBUG	int
&&	O
(	O
flags	int
&	O
(	O
SEC_ALLOC	int
|	O
SEC_GROUP	int
)	O
)	O
!=	O
0	int
&&	O
!	O
is_nondebug_keep_contents_section	function
(	O
ibfd	pointer
,	O
isection	pointer
)	O
)	O
{	O
flags	int
&=	O
~	O
(	O
SEC_HAS_CONTENTS	int
|	O
SEC_LOAD	int
|	O
SEC_GROUP	int
)	O
;	O
if	O
(	O
bfd_get_flavour	function
(	O
obfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
)	O
{	O
make_nobits	int
=	O
TRUE	int
;	O
isection	pointer
->	O
flags	int
&=	O
~	O
(	O
SEC_HAS_CONTENTS	int
|	O
SEC_LOAD	int
|	O
SEC_GROUP	int
)	O
;	O
}	O
}	O
osection	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
obfd	pointer
,	O
name	pointer
,	O
flags	int
)	O
;	O
if	O
(	O
osection	pointer
==	O
NULL	O
)	O
{	O
err	pointer
=	O
_	O
(	O
"failed to create output section"	pointer
)	O
;	O
goto	O
loser	O
;	O
}	O
if	O
(	O
make_nobits	int
)	O
elf_section_type	O
(	O
osection	pointer
)	O
=	O
SHT_NOBITS	int
;	O
size	int
=	O
bfd_section_size	function
(	O
isection	pointer
)	O
;	O
size	int
=	O
bfd_convert_section_size	function
(	O
ibfd	pointer
,	O
isection	pointer
,	O
obfd	pointer
,	O
size	int
)	O
;	O
if	O
(	O
copy_byte	int
>=	O
0	int
)	O
size	int
=	O
(	O
size	int
+	O
interleave	int
-	O
1	int
)	O
/	O
interleave	int
*	O
copy_width	int
;	O
else	O
if	O
(	O
extract_symbol	int
)	O
size	int
=	O
0	int
;	O
if	O
(	O
!	O
bfd_set_section_size	function
(	O
osection	pointer
,	O
size	int
)	O
)	O
{	O
err	pointer
=	O
_	O
(	O
"failed to set size"	pointer
)	O
;	O
goto	O
loser	O
;	O
}	O
vma	long
=	O
bfd_section_vma	function
(	O
isection	pointer
)	O
;	O
p	pointer
=	O
find_section_list	function
(	O
bfd_section_name	function
(	O
isection	pointer
)	O
,	O
FALSE	int
,	O
SECTION_CONTEXT_ALTER_VMA	O
|	O
SECTION_CONTEXT_SET_VMA	O
)	O
;	O
if	O
(	O
p	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
p	pointer
->	O
context	int
&	O
SECTION_CONTEXT_SET_VMA	O
)	O
vma	long
=	O
p	pointer
->	O
vma_val	long
;	O
else	O
vma	long
+=	O
p	pointer
->	O
vma_val	long
;	O
}	O
else	O
vma	long
+=	O
change_section_address	long
;	O
if	O
(	O
!	O
bfd_set_section_vma	function
(	O
osection	pointer
,	O
vma	long
)	O
)	O
{	O
err	pointer
=	O
_	O
(	O
"failed to set vma"	pointer
)	O
;	O
goto	O
loser	O
;	O
}	O
lma	long
=	O
isection	pointer
->	O
lma	long
;	O
p	pointer
=	O
find_section_list	function
(	O
bfd_section_name	function
(	O
isection	pointer
)	O
,	O
FALSE	int
,	O
SECTION_CONTEXT_ALTER_LMA	O
|	O
SECTION_CONTEXT_SET_LMA	O
)	O
;	O
if	O
(	O
p	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
p	pointer
->	O
context	int
&	O
SECTION_CONTEXT_ALTER_LMA	O
)	O
lma	long
+=	O
p	pointer
->	O
lma_val	long
;	O
else	O
lma	long
=	O
p	pointer
->	O
lma_val	long
;	O
}	O
else	O
lma	long
+=	O
change_section_address	long
;	O
osection	pointer
->	O
lma	long
=	O
lma	long
;	O
p	pointer
=	O
find_section_list	function
(	O
bfd_section_name	function
(	O
isection	pointer
)	O
,	O
FALSE	int
,	O
SECTION_CONTEXT_SET_ALIGNMENT	O
)	O
;	O
if	O
(	O
p	pointer
!=	O
NULL	O
)	O
alignment	int
=	O
p	pointer
->	O
alignment	int
;	O
else	O
alignment	int
=	O
bfd_section_alignment	function
(	O
isection	pointer
)	O
;	O
if	O
(	O
!	O
bfd_set_section_alignment	function
(	O
osection	pointer
,	O
alignment	int
)	O
)	O
{	O
err	pointer
=	O
_	O
(	O
"failed to set alignment"	pointer
)	O
;	O
goto	O
loser	O
;	O
}	O
osection	pointer
->	O
entsize	int
=	O
isection	pointer
->	O
entsize	int
;	O
osection	pointer
->	O
compress_status	int
=	O
isection	pointer
->	O
compress_status	int
;	O
isection	pointer
->	O
output_section	pointer
=	O
osection	pointer
;	O
isection	pointer
->	O
output_offset	long
=	O
0	int
;	O
if	O
(	O
(	O
isection	pointer
->	O
flags	int
&	O
SEC_GROUP	int
)	O
!=	O
0	int
)	O
{	O
asymbol	struct
*	O
gsym	pointer
=	O
group_signature	function
(	O
isection	pointer
)	O
;	O
if	O
(	O
gsym	pointer
!=	O
NULL	O
)	O
{	O
gsym	pointer
->	O
flags	int
|=	O
BSF_KEEP	O
;	O
if	O
(	O
bfd_get_flavour	function
(	O
ibfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
)	O
elf_group_id	O
(	O
isection	pointer
)	O
=	O
gsym	pointer
;	O
}	O
}	O
if	O
(	O
!	O
bfd_copy_private_section_data	function
(	O
ibfd	pointer
,	O
isection	pointer
,	O
obfd	pointer
,	O
osection	pointer
)	O
)	O
{	O
err	pointer
=	O
_	O
(	O
"failed to copy private data"	pointer
)	O
;	O
goto	O
loser	O
;	O
}	O
return	O
;	O
loser	O
:	O
status	int
=	O
1	int
;	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
obfd	pointer
,	O
osection	pointer
,	O
err	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
skip_section	function
(	O
bfd	struct
*	O
ibfd	pointer
,	O
sec_ptr	pointer
isection	pointer
,	O
bfd_boolean	int
skip_copy	int
)	O
{	O
sec_ptr	pointer
osection	pointer
;	O
bfd_size_type	long
size	int
;	O
flagword	int
flags	int
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
extract_symbol	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
is_strip_section	function
(	O
ibfd	pointer
,	O
isection	pointer
)	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
is_update_section	function
(	O
ibfd	pointer
,	O
isection	pointer
)	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
skip_copy	int
&&	O
is_mergeable_note_section	function
(	O
ibfd	pointer
,	O
isection	pointer
)	O
)	O
return	O
TRUE	int
;	O
flags	int
=	O
bfd_section_flags	function
(	O
isection	pointer
)	O
;	O
if	O
(	O
(	O
flags	int
&	O
SEC_GROUP	int
)	O
!=	O
0	int
)	O
return	O
TRUE	int
;	O
osection	pointer
=	O
isection	pointer
->	O
output_section	pointer
;	O
size	int
=	O
bfd_section_size	function
(	O
isection	pointer
)	O
;	O
if	O
(	O
size	int
==	O
0	int
||	O
osection	pointer
==	O
0	int
)	O
return	O
TRUE	int
;	O
return	O
FALSE	int
;	O
}	O
static	O
void	O
handle_remove_relocations_option	function
(	O
const	O
char	O
*	O
section_pattern	pointer
)	O
{	O
find_section_list	function
(	O
section_pattern	pointer
,	O
TRUE	int
,	O
SECTION_CONTEXT_REMOVE_RELOCS	O
)	O
;	O
}	O
static	O
bfd_boolean	int
discard_relocations	function
(	O
bfd	struct
*	O
ibfd	pointer
ATTRIBUTE_UNUSED	O
,	O
asection	struct
*	O
isection	pointer
)	O
{	O
return	O
(	O
find_section_list	function
(	O
bfd_section_name	function
(	O
isection	pointer
)	O
,	O
FALSE	int
,	O
SECTION_CONTEXT_REMOVE_RELOCS	O
)	O
!=	O
NULL	O
)	O
;	O
}	O
static	O
void	O
handle_remove_section_option	function
(	O
const	O
char	O
*	O
section_pattern	pointer
)	O
{	O
find_section_list	function
(	O
section_pattern	pointer
,	O
TRUE	int
,	O
SECTION_CONTEXT_REMOVE	O
)	O
;	O
if	O
(	O
strncmp	function
(	O
section_pattern	pointer
,	O
".rel"	pointer
,	O
4	int
)	O
==	O
0	int
)	O
{	O
section_pattern	pointer
+=	O
4	int
;	O
if	O
(	O
*	O
section_pattern	pointer
==	O
'a'	O
)	O
section_pattern	pointer
++	O
;	O
if	O
(	O
*	O
section_pattern	pointer
)	O
handle_remove_relocations_option	function
(	O
section_pattern	pointer
)	O
;	O
}	O
sections_removed	int
=	O
TRUE	int
;	O
}	O
static	O
void	O
copy_relocations_in_section	function
(	O
bfd	struct
*	O
ibfd	pointer
,	O
sec_ptr	pointer
isection	pointer
,	O
void	O
*	O
obfdarg	pointer
)	O
{	O
bfd	struct
*	O
obfd	pointer
=	O
(	O
bfd	struct
*	O
)	O
obfdarg	pointer
;	O
long	O
relsize	long
;	O
arelent	struct
*	O
*	O
relpp	pointer
;	O
long	O
relcount	long
;	O
sec_ptr	pointer
osection	pointer
;	O
if	O
(	O
skip_section	function
(	O
ibfd	pointer
,	O
isection	pointer
,	O
FALSE	int
)	O
)	O
return	O
;	O
osection	pointer
=	O
isection	pointer
->	O
output_section	pointer
;	O
if	O
(	O
bfd_get_format	function
(	O
obfd	pointer
)	O
==	O
bfd_core	int
||	O
strip_symbols	enum
==	O
STRIP_NONDWO	int
||	O
discard_relocations	function
(	O
ibfd	pointer
,	O
isection	pointer
)	O
)	O
relsize	long
=	O
0	int
;	O
else	O
{	O
relsize	long
=	O
bfd_get_reloc_upper_bound	function
(	O
ibfd	pointer
,	O
isection	pointer
)	O
;	O
if	O
(	O
relsize	long
<	O
0	int
)	O
{	O
if	O
(	O
relsize	long
==	O
-	O
1	int
&&	O
bfd_get_error	function
(	O
)	O
==	O
bfd_error_invalid_operation	int
)	O
relsize	long
=	O
0	int
;	O
else	O
{	O
status	int
=	O
1	int
;	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
ibfd	pointer
,	O
isection	pointer
,	O
NULL	O
)	O
;	O
return	O
;	O
}	O
}	O
}	O
if	O
(	O
relsize	long
==	O
0	int
)	O
{	O
bfd_set_reloc	function
(	O
obfd	pointer
,	O
osection	pointer
,	O
NULL	O
,	O
0	int
)	O
;	O
osection	pointer
->	O
flags	int
&=	O
~	O
SEC_RELOC	int
;	O
}	O
else	O
{	O
if	O
(	O
isection	pointer
->	O
orelocation	pointer
!=	O
NULL	O
)	O
{	O
relcount	long
=	O
isection	pointer
->	O
reloc_count	int
;	O
relpp	pointer
=	O
isection	pointer
->	O
orelocation	pointer
;	O
}	O
else	O
{	O
relpp	pointer
=	O
(	O
arelent	struct
*	O
*	O
)	O
xmalloc	function
(	O
relsize	long
)	O
;	O
relcount	long
=	O
bfd_canonicalize_reloc	function
(	O
ibfd	pointer
,	O
isection	pointer
,	O
relpp	pointer
,	O
isympp	pointer
)	O
;	O
if	O
(	O
relcount	long
<	O
0	int
)	O
{	O
status	int
=	O
1	int
;	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
ibfd	pointer
,	O
isection	pointer
,	O
_	O
(	O
"relocation count is negative"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
}	O
if	O
(	O
strip_symbols	enum
==	O
STRIP_ALL	int
)	O
{	O
arelent	struct
*	O
*	O
temp_relpp	pointer
;	O
long	O
temp_relcount	long
=	O
0	int
;	O
long	O
i	pointer
;	O
temp_relpp	pointer
=	O
(	O
arelent	struct
*	O
*	O
)	O
xmalloc	function
(	O
relsize	long
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
relcount	long
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
relpp	pointer
[	O
i	pointer
]	O
->	O
sym_ptr_ptr	pointer
&&	O
*	O
relpp	pointer
[	O
i	pointer
]	O
->	O
sym_ptr_ptr	pointer
)	O
if	O
(	O
is_specified_symbol	function
(	O
bfd_asymbol_name	function
(	O
*	O
relpp	pointer
[	O
i	pointer
]	O
->	O
sym_ptr_ptr	pointer
)	O
,	O
keep_specific_htab	pointer
)	O
)	O
temp_relpp	pointer
[	O
temp_relcount	long
++	O
]	O
=	O
relpp	pointer
[	O
i	pointer
]	O
;	O
}	O
relcount	long
=	O
temp_relcount	long
;	O
if	O
(	O
isection	pointer
->	O
orelocation	pointer
==	O
NULL	O
)	O
free	function
(	O
relpp	pointer
)	O
;	O
relpp	pointer
=	O
temp_relpp	pointer
;	O
}	O
bfd_set_reloc	function
(	O
obfd	pointer
,	O
osection	pointer
,	O
relcount	long
==	O
0	int
?	O
NULL	O
:	O
relpp	pointer
,	O
relcount	long
)	O
;	O
if	O
(	O
relcount	long
==	O
0	int
)	O
{	O
osection	pointer
->	O
flags	int
&=	O
~	O
SEC_RELOC	int
;	O
free	function
(	O
relpp	pointer
)	O
;	O
}	O
}	O
}	O
static	O
void	O
copy_section	function
(	O
bfd	struct
*	O
ibfd	pointer
,	O
sec_ptr	pointer
isection	pointer
,	O
void	O
*	O
obfdarg	pointer
)	O
{	O
bfd	struct
*	O
obfd	pointer
=	O
(	O
bfd	struct
*	O
)	O
obfdarg	pointer
;	O
struct	O
section_list	struct
*	O
p	pointer
;	O
sec_ptr	pointer
osection	pointer
;	O
bfd_size_type	long
size	int
;	O
if	O
(	O
skip_section	function
(	O
ibfd	pointer
,	O
isection	pointer
,	O
TRUE	int
)	O
)	O
return	O
;	O
osection	pointer
=	O
isection	pointer
->	O
output_section	pointer
;	O
size	int
=	O
bfd_section_size	function
(	O
isection	pointer
)	O
;	O
if	O
(	O
bfd_section_flags	function
(	O
isection	pointer
)	O
&	O
SEC_HAS_CONTENTS	int
&&	O
bfd_section_flags	function
(	O
osection	pointer
)	O
&	O
SEC_HAS_CONTENTS	int
)	O
{	O
bfd_byte	char
*	O
memhunk	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
bfd_get_full_section_contents	function
(	O
ibfd	pointer
,	O
isection	pointer
,	O
&	O
memhunk	pointer
)	O
||	O
!	O
bfd_convert_section_contents	function
(	O
ibfd	pointer
,	O
isection	pointer
,	O
obfd	pointer
,	O
&	O
memhunk	pointer
,	O
&	O
size	int
)	O
)	O
{	O
status	int
=	O
1	int
;	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
ibfd	pointer
,	O
isection	pointer
,	O
NULL	O
)	O
;	O
free	function
(	O
memhunk	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
reverse_bytes	int
)	O
{	O
if	O
(	O
(	O
size	int
%	O
reverse_bytes	int
)	O
==	O
0	int
)	O
{	O
unsigned	O
long	O
i	pointer
,	O
j	long
;	O
bfd_byte	char
b	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
size	int
;	O
i	pointer
+=	O
reverse_bytes	int
)	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
(	O
unsigned	O
long	O
)	O
(	O
reverse_bytes	int
/	O
2	int
)	O
;	O
j	long
++	O
)	O
{	O
bfd_byte	char
*	O
m	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
memhunk	pointer
;	O
b	pointer
=	O
m	pointer
[	O
i	pointer
+	O
j	long
]	O
;	O
m	pointer
[	O
i	pointer
+	O
j	long
]	O
=	O
m	pointer
[	O
(	O
i	pointer
+	O
reverse_bytes	int
)	O
-	O
(	O
j	long
+	O
1	int
)	O
]	O
;	O
m	pointer
[	O
(	O
i	pointer
+	O
reverse_bytes	int
)	O
-	O
(	O
j	long
+	O
1	int
)	O
]	O
=	O
b	pointer
;	O
}	O
}	O
else	O
fatal	function
(	O
_	O
(	O
"cannot reverse bytes: length of section %s must be evenly divisible by %d"	pointer
)	O
,	O
bfd_section_name	function
(	O
isection	pointer
)	O
,	O
reverse_bytes	int
)	O
;	O
}	O
if	O
(	O
copy_byte	int
>=	O
0	int
)	O
{	O
char	O
*	O
from	pointer
=	O
(	O
char	O
*	O
)	O
memhunk	pointer
+	O
copy_byte	int
;	O
char	O
*	O
to	pointer
=	O
(	O
char	O
*	O
)	O
memhunk	pointer
;	O
char	O
*	O
end	pointer
=	O
(	O
char	O
*	O
)	O
memhunk	pointer
+	O
size	int
;	O
int	O
i	pointer
;	O
int	O
extra	pointer
=	O
isection	pointer
->	O
lma	long
%	O
interleave	int
;	O
from	pointer
-=	O
extra	pointer
;	O
if	O
(	O
copy_byte	int
<	O
extra	pointer
)	O
from	pointer
+=	O
interleave	int
;	O
for	O
(	O
;	O
from	pointer
<	O
end	pointer
;	O
from	pointer
+=	O
interleave	int
)	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
copy_width	int
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
&	O
from	pointer
[	O
i	pointer
]	O
>=	O
end	pointer
)	O
break	O
;	O
*	O
to	pointer
++	O
=	O
from	pointer
[	O
i	pointer
]	O
;	O
}	O
size	int
=	O
(	O
size	int
+	O
interleave	int
-	O
1	int
-	O
copy_byte	int
)	O
/	O
interleave	int
*	O
copy_width	int
;	O
osection	pointer
->	O
lma	long
/=	O
interleave	int
;	O
if	O
(	O
copy_byte	int
<	O
extra	pointer
)	O
osection	pointer
->	O
lma	long
++	O
;	O
}	O
if	O
(	O
!	O
bfd_set_section_contents	function
(	O
obfd	pointer
,	O
osection	pointer
,	O
memhunk	pointer
,	O
0	int
,	O
size	int
)	O
)	O
{	O
status	int
=	O
1	int
;	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
obfd	pointer
,	O
osection	pointer
,	O
NULL	O
)	O
;	O
free	function
(	O
memhunk	pointer
)	O
;	O
return	O
;	O
}	O
free	function
(	O
memhunk	pointer
)	O
;	O
}	O
else	O
if	O
(	O
(	O
p	pointer
=	O
find_section_list	function
(	O
bfd_section_name	function
(	O
isection	pointer
)	O
,	O
FALSE	int
,	O
SECTION_CONTEXT_SET_FLAGS	O
)	O
)	O
!=	O
NULL	O
&&	O
(	O
p	pointer
->	O
flags	int
&	O
SEC_HAS_CONTENTS	int
)	O
!=	O
0	int
)	O
{	O
void	O
*	O
memhunk	pointer
=	O
xmalloc	function
(	O
size	int
)	O
;	O
memset	function
(	O
memhunk	pointer
,	O
0	int
,	O
size	int
)	O
;	O
if	O
(	O
!	O
bfd_set_section_contents	function
(	O
obfd	pointer
,	O
osection	pointer
,	O
memhunk	pointer
,	O
0	int
,	O
size	int
)	O
)	O
{	O
status	int
=	O
1	int
;	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
obfd	pointer
,	O
osection	pointer
,	O
NULL	O
)	O
;	O
free	function
(	O
memhunk	pointer
)	O
;	O
return	O
;	O
}	O
free	function
(	O
memhunk	pointer
)	O
;	O
}	O
}	O
static	O
void	O
get_sections	function
(	O
bfd	struct
*	O
obfd	pointer
ATTRIBUTE_UNUSED	O
,	O
asection	struct
*	O
osection	pointer
,	O
void	O
*	O
secppparg	pointer
)	O
{	O
asection	struct
*	O
*	O
*	O
secppp	pointer
=	O
(	O
asection	struct
*	O
*	O
*	O
)	O
secppparg	pointer
;	O
*	O
*	O
secppp	pointer
=	O
osection	pointer
;	O
++	O
(	O
*	O
secppp	pointer
)	O
;	O
}	O
static	O
int	O
compare_section_lma	function
(	O
const	O
void	O
*	O
arg1	pointer
,	O
const	O
void	O
*	O
arg2	pointer
)	O
{	O
const	O
asection	struct
*	O
sec1	pointer
=	O
*	O
(	O
const	O
asection	struct
*	O
*	O
)	O
arg1	pointer
;	O
const	O
asection	struct
*	O
sec2	pointer
=	O
*	O
(	O
const	O
asection	struct
*	O
*	O
)	O
arg2	pointer
;	O
flagword	int
flags1	int
,	O
flags2	int
;	O
flags1	int
=	O
sec1	pointer
->	O
flags	int
;	O
flags2	int
=	O
sec2	pointer
->	O
flags	int
;	O
if	O
(	O
(	O
flags1	int
&	O
SEC_HAS_CONTENTS	int
)	O
==	O
0	int
||	O
(	O
flags1	int
&	O
SEC_LOAD	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
flags2	int
&	O
SEC_HAS_CONTENTS	int
)	O
!=	O
0	int
&&	O
(	O
flags2	int
&	O
SEC_LOAD	int
)	O
!=	O
0	int
)	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
(	O
flags2	int
&	O
SEC_HAS_CONTENTS	int
)	O
==	O
0	int
||	O
(	O
flags2	int
&	O
SEC_LOAD	int
)	O
==	O
0	int
)	O
return	O
1	int
;	O
}	O
if	O
(	O
sec1	pointer
->	O
lma	long
>	O
sec2	pointer
->	O
lma	long
)	O
return	O
1	int
;	O
if	O
(	O
sec1	pointer
->	O
lma	long
<	O
sec2	pointer
->	O
lma	long
)	O
return	O
-	O
1	int
;	O
if	O
(	O
bfd_section_size	function
(	O
sec1	pointer
)	O
>	O
bfd_section_size	function
(	O
sec2	pointer
)	O
)	O
return	O
1	int
;	O
if	O
(	O
bfd_section_size	function
(	O
sec1	pointer
)	O
<	O
bfd_section_size	function
(	O
sec2	pointer
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
sec1	pointer
->	O
id	int
>	O
sec2	pointer
->	O
id	int
)	O
return	O
1	int
;	O
if	O
(	O
sec1	pointer
->	O
id	int
<	O
sec2	pointer
->	O
id	int
)	O
return	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
mark_symbols_used_in_relocations	function
(	O
bfd	struct
*	O
ibfd	pointer
,	O
sec_ptr	pointer
isection	pointer
,	O
void	O
*	O
symbolsarg	pointer
)	O
{	O
asymbol	struct
*	O
*	O
symbols	pointer
=	O
(	O
asymbol	struct
*	O
*	O
)	O
symbolsarg	pointer
;	O
long	O
relsize	long
;	O
arelent	struct
*	O
*	O
relpp	pointer
;	O
long	O
relcount	long
,	O
i	pointer
;	O
if	O
(	O
isection	pointer
->	O
output_section	pointer
==	O
NULL	O
)	O
return	O
;	O
relsize	long
=	O
bfd_get_reloc_upper_bound	function
(	O
ibfd	pointer
,	O
isection	pointer
)	O
;	O
if	O
(	O
relsize	long
<	O
0	int
)	O
{	O
if	O
(	O
relsize	long
==	O
-	O
1	int
&&	O
bfd_get_error	function
(	O
)	O
==	O
bfd_error_invalid_operation	int
)	O
return	O
;	O
bfd_fatal	function
(	O
bfd_get_filename	function
(	O
ibfd	pointer
)	O
)	O
;	O
}	O
if	O
(	O
relsize	long
==	O
0	int
)	O
return	O
;	O
relpp	pointer
=	O
(	O
arelent	struct
*	O
*	O
)	O
xmalloc	function
(	O
relsize	long
)	O
;	O
relcount	long
=	O
bfd_canonicalize_reloc	function
(	O
ibfd	pointer
,	O
isection	pointer
,	O
relpp	pointer
,	O
symbols	pointer
)	O
;	O
if	O
(	O
relcount	long
<	O
0	int
)	O
bfd_fatal	function
(	O
bfd_get_filename	function
(	O
ibfd	pointer
)	O
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
relcount	long
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
relpp	pointer
[	O
i	pointer
]	O
->	O
sym_ptr_ptr	pointer
!=	O
NULL	O
&&	O
*	O
relpp	pointer
[	O
i	pointer
]	O
->	O
sym_ptr_ptr	pointer
!=	O
NULL	O
&&	O
*	O
relpp	pointer
[	O
i	pointer
]	O
->	O
sym_ptr_ptr	pointer
!=	O
bfd_com_section_ptr	O
->	O
symbol	pointer
&&	O
*	O
relpp	pointer
[	O
i	pointer
]	O
->	O
sym_ptr_ptr	pointer
!=	O
bfd_abs_section_ptr	O
->	O
symbol	pointer
&&	O
*	O
relpp	pointer
[	O
i	pointer
]	O
->	O
sym_ptr_ptr	pointer
!=	O
bfd_und_section_ptr	O
->	O
symbol	pointer
)	O
(	O
*	O
relpp	pointer
[	O
i	pointer
]	O
->	O
sym_ptr_ptr	pointer
)	O
->	O
flags	int
|=	O
BSF_KEEP	O
;	O
}	O
if	O
(	O
relpp	pointer
!=	O
NULL	O
)	O
free	function
(	O
relpp	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
write_debugging_info	function
(	O
bfd	struct
*	O
obfd	pointer
,	O
void	O
*	O
dhandle	pointer
,	O
long	O
*	O
symcountp	pointer
ATTRIBUTE_UNUSED	O
,	O
asymbol	struct
*	O
*	O
*	O
symppp	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
if	O
(	O
bfd_get_flavour	function
(	O
obfd	pointer
)	O
==	O
bfd_target_coff_flavour	int
||	O
bfd_get_flavour	function
(	O
obfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
)	O
{	O
bfd_byte	char
*	O
syms	pointer
,	O
*	O
strings	pointer
=	O
NULL	O
;	O
bfd_size_type	long
symsize	long
,	O
stringsize	long
;	O
asection	struct
*	O
stabsec	pointer
,	O
*	O
stabstrsec	pointer
;	O
flagword	int
flags	int
;	O
if	O
(	O
!	O
write_stabs_in_sections_debugging_info	function
(	O
obfd	pointer
,	O
dhandle	pointer
,	O
&	O
syms	pointer
,	O
&	O
symsize	long
,	O
&	O
strings	pointer
,	O
&	O
stringsize	long
)	O
)	O
return	O
FALSE	int
;	O
flags	int
=	O
SEC_HAS_CONTENTS	int
|	O
SEC_READONLY	int
|	O
SEC_DEBUGGING	int
;	O
stabsec	pointer
=	O
bfd_make_section_with_flags	function
(	O
obfd	pointer
,	O
".stab"	pointer
,	O
flags	int
)	O
;	O
stabstrsec	pointer
=	O
bfd_make_section_with_flags	function
(	O
obfd	pointer
,	O
".stabstr"	pointer
,	O
flags	int
)	O
;	O
if	O
(	O
stabsec	pointer
==	O
NULL	O
||	O
stabstrsec	pointer
==	O
NULL	O
||	O
!	O
bfd_set_section_size	function
(	O
stabsec	pointer
,	O
symsize	long
)	O
||	O
!	O
bfd_set_section_size	function
(	O
stabstrsec	pointer
,	O
stringsize	long
)	O
||	O
!	O
bfd_set_section_alignment	function
(	O
stabsec	pointer
,	O
2	int
)	O
||	O
!	O
bfd_set_section_alignment	function
(	O
stabstrsec	pointer
,	O
0	int
)	O
)	O
{	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
obfd	pointer
,	O
NULL	O
,	O
_	O
(	O
"can't create debugging section"	pointer
)	O
)	O
;	O
free	function
(	O
strings	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
!	O
bfd_set_section_contents	function
(	O
obfd	pointer
,	O
stabsec	pointer
,	O
syms	pointer
,	O
0	int
,	O
symsize	long
)	O
||	O
!	O
bfd_set_section_contents	function
(	O
obfd	pointer
,	O
stabstrsec	pointer
,	O
strings	pointer
,	O
0	int
,	O
stringsize	long
)	O
)	O
{	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
obfd	pointer
,	O
NULL	O
,	O
_	O
(	O
"can't set debugging section contents"	pointer
)	O
)	O
;	O
free	function
(	O
strings	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
bfd_nonfatal_message	function
(	O
NULL	O
,	O
obfd	pointer
,	O
NULL	O
,	O
_	O
(	O
"don't know how to write debugging information for %s"	pointer
)	O
,	O
bfd_get_target	function
(	O
obfd	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
static	O
void	O
default_deterministic	function
(	O
void	O
)	O
{	O
if	O
(	O
deterministic	int
<	O
0	int
)	O
deterministic	int
=	O
DEFAULT_AR_DETERMINISTIC	int
;	O
}	O
static	O
int	O
strip_main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
char	O
*	O
input_target	pointer
=	O
NULL	O
;	O
char	O
*	O
output_target	pointer
=	O
NULL	O
;	O
bfd_boolean	int
show_version	int
=	O
FALSE	int
;	O
bfd_boolean	int
formats_info	int
=	O
FALSE	int
;	O
int	O
c	struct
;	O
int	O
i	pointer
;	O
char	O
*	O
output_file	pointer
=	O
NULL	O
;	O
bfd_boolean	int
merge_notes_set	int
=	O
FALSE	int
;	O
while	O
(	O
(	O
c	struct
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
"I:O:F:K:MN:R:o:sSpdgxXHhVvwDU"	pointer
,	O
strip_options	array
,	O
(	O
int	O
*	O
)	O
0	int
)	O
)	O
!=	O
EOF	O
)	O
{	O
switch	O
(	O
c	struct
)	O
{	O
case	O
'I'	O
:	O
input_target	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'O'	O
:	O
output_target	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'F'	O
:	O
input_target	pointer
=	O
output_target	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'R'	O
:	O
handle_remove_section_option	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_KEEP_SECTION	int
:	O
find_section_list	function
(	O
optarg	pointer
,	O
TRUE	int
,	O
SECTION_CONTEXT_KEEP	O
)	O
;	O
break	O
;	O
case	O
OPTION_REMOVE_RELOCS	int
:	O
handle_remove_relocations_option	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
's'	O
:	O
strip_symbols	enum
=	O
STRIP_ALL	int
;	O
break	O
;	O
case	O
'S'	O
:	O
case	O
'g'	O
:	O
case	O
'd'	O
:	O
strip_symbols	enum
=	O
STRIP_DEBUG	int
;	O
break	O
;	O
case	O
OPTION_STRIP_DWO	int
:	O
strip_symbols	enum
=	O
STRIP_DWO	int
;	O
break	O
;	O
case	O
OPTION_STRIP_UNNEEDED	int
:	O
strip_symbols	enum
=	O
STRIP_UNNEEDED	int
;	O
break	O
;	O
case	O
'K'	O
:	O
add_specific_symbol	function
(	O
optarg	pointer
,	O
keep_specific_htab	pointer
)	O
;	O
break	O
;	O
case	O
'M'	O
:	O
merge_notes	int
=	O
TRUE	int
;	O
merge_notes_set	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_NO_MERGE_NOTES	int
:	O
merge_notes	int
=	O
FALSE	int
;	O
merge_notes_set	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'N'	O
:	O
add_specific_symbol	function
(	O
optarg	pointer
,	O
strip_specific_htab	pointer
)	O
;	O
break	O
;	O
case	O
'o'	O
:	O
output_file	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'p'	O
:	O
preserve_dates	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'D'	O
:	O
deterministic	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'U'	O
:	O
deterministic	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
'x'	O
:	O
discard_locals	enum
=	O
LOCALS_ALL	int
;	O
break	O
;	O
case	O
'X'	O
:	O
discard_locals	enum
=	O
LOCALS_START_L	int
;	O
break	O
;	O
case	O
'v'	O
:	O
verbose	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'V'	O
:	O
show_version	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_FORMATS_INFO	int
:	O
formats_info	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_ONLY_KEEP_DEBUG	int
:	O
strip_symbols	enum
=	O
STRIP_NONDEBUG	int
;	O
break	O
;	O
case	O
OPTION_KEEP_FILE_SYMBOLS	int
:	O
keep_file_symbols	int
=	O
1	int
;	O
break	O
;	O
case	O
0	int
:	O
break	O
;	O
case	O
'w'	O
:	O
wildcard	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'H'	O
:	O
case	O
'h'	O
:	O
strip_usage	function
(	O
stdout	pointer
,	O
0	int
)	O
;	O
default	O
:	O
strip_usage	function
(	O
stderr	pointer
,	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
merge_notes_set	int
&&	O
(	O
strip_symbols	enum
==	O
STRIP_UNDEF	int
||	O
strip_symbols	enum
==	O
STRIP_ALL	int
||	O
strip_symbols	enum
==	O
STRIP_UNNEEDED	int
||	O
strip_symbols	enum
==	O
STRIP_NONDEBUG	int
||	O
strip_symbols	enum
==	O
STRIP_NONDWO	int
)	O
)	O
merge_notes	int
=	O
TRUE	int
;	O
if	O
(	O
formats_info	int
)	O
{	O
display_info	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
show_version	int
)	O
print_version	function
(	O
"strip"	pointer
)	O
;	O
default_deterministic	function
(	O
)	O
;	O
if	O
(	O
strip_symbols	enum
==	O
STRIP_UNDEF	int
&&	O
discard_locals	enum
==	O
LOCALS_UNDEF	int
&&	O
htab_elements	function
(	O
strip_specific_htab	pointer
)	O
==	O
0	int
)	O
strip_symbols	enum
=	O
STRIP_ALL	int
;	O
if	O
(	O
output_target	pointer
==	O
NULL	O
)	O
output_target	pointer
=	O
input_target	pointer
;	O
i	pointer
=	O
optind	int
;	O
if	O
(	O
i	pointer
==	O
argc	int
||	O
(	O
output_file	pointer
!=	O
NULL	O
&&	O
(	O
i	pointer
+	O
1	int
)	O
<	O
argc	int
)	O
)	O
strip_usage	function
(	O
stderr	pointer
,	O
1	int
)	O
;	O
for	O
(	O
;	O
i	pointer
<	O
argc	int
;	O
i	pointer
++	O
)	O
{	O
int	O
hold_status	int
=	O
status	int
;	O
struct	O
stat	struct
statbuf	struct
;	O
char	O
*	O
tmpname	pointer
;	O
if	O
(	O
get_file_size	function
(	O
argv	pointer
[	O
i	pointer
]	O
)	O
<	O
1	int
)	O
{	O
status	int
=	O
1	int
;	O
continue	O
;	O
}	O
if	O
(	O
preserve_dates	int
)	O
stat	struct
(	O
argv	pointer
[	O
i	pointer
]	O
,	O
&	O
statbuf	struct
)	O
;	O
if	O
(	O
output_file	pointer
==	O
NULL	O
||	O
filename_cmp	function
(	O
argv	pointer
[	O
i	pointer
]	O
,	O
output_file	pointer
)	O
==	O
0	int
)	O
tmpname	pointer
=	O
make_tempname	function
(	O
argv	pointer
[	O
i	pointer
]	O
)	O
;	O
else	O
tmpname	pointer
=	O
output_file	pointer
;	O
if	O
(	O
tmpname	pointer
==	O
NULL	O
)	O
{	O
bfd_nonfatal_message	function
(	O
argv	pointer
[	O
i	pointer
]	O
,	O
NULL	O
,	O
NULL	O
,	O
_	O
(	O
"could not create temporary file to hold stripped copy"	pointer
)	O
)	O
;	O
status	int
=	O
1	int
;	O
continue	O
;	O
}	O
status	int
=	O
0	int
;	O
copy_file	function
(	O
argv	pointer
[	O
i	pointer
]	O
,	O
tmpname	pointer
,	O
input_target	pointer
,	O
output_target	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
{	O
if	O
(	O
preserve_dates	int
)	O
set_times	function
(	O
tmpname	pointer
,	O
&	O
statbuf	struct
)	O
;	O
if	O
(	O
output_file	pointer
!=	O
tmpname	pointer
)	O
status	int
=	O
(	O
smart_rename	function
(	O
tmpname	pointer
,	O
output_file	pointer
?	O
output_file	pointer
:	O
argv	pointer
[	O
i	pointer
]	O
,	O
preserve_dates	int
)	O
!=	O
0	int
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
status	int
=	O
hold_status	int
;	O
}	O
else	O
unlink_if_ordinary	function
(	O
tmpname	pointer
)	O
;	O
if	O
(	O
output_file	pointer
!=	O
tmpname	pointer
)	O
free	function
(	O
tmpname	pointer
)	O
;	O
}	O
return	O
status	int
;	O
}	O
static	O
void	O
set_pe_subsystem	function
(	O
const	O
char	O
*	O
s	pointer
)	O
{	O
const	O
char	O
*	O
version	short
,	O
*	O
subsystem	pointer
;	O
size_t	long
i	pointer
;	O
static	O
const	O
struct	O
{	O
const	O
char	O
*	O
name	pointer
;	O
const	O
char	O
set_def	char
;	O
const	O
short	O
value	long
;	O
}	O
v	array
[	O
]	O
=	O
{	O
{	O
"native"	pointer
,	O
0	int
,	O
IMAGE_SUBSYSTEM_NATIVE	int
}	O
,	O
{	O
"windows"	pointer
,	O
0	int
,	O
IMAGE_SUBSYSTEM_WINDOWS_GUI	int
}	O
,	O
{	O
"console"	pointer
,	O
0	int
,	O
IMAGE_SUBSYSTEM_WINDOWS_CUI	int
}	O
,	O
{	O
"posix"	pointer
,	O
0	int
,	O
IMAGE_SUBSYSTEM_POSIX_CUI	int
}	O
,	O
{	O
"wince"	pointer
,	O
0	int
,	O
IMAGE_SUBSYSTEM_WINDOWS_CE_GUI	int
}	O
,	O
{	O
"efi-app"	pointer
,	O
1	int
,	O
IMAGE_SUBSYSTEM_EFI_APPLICATION	int
}	O
,	O
{	O
"efi-bsd"	pointer
,	O
1	int
,	O
IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER	int
}	O
,	O
{	O
"efi-rtd"	pointer
,	O
1	int
,	O
IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER	int
}	O
,	O
{	O
"sal-rtd"	pointer
,	O
1	int
,	O
IMAGE_SUBSYSTEM_SAL_RUNTIME_DRIVER	int
}	O
,	O
{	O
"xbox"	pointer
,	O
0	int
,	O
IMAGE_SUBSYSTEM_XBOX	int
}	O
}	O
;	O
short	O
value	long
;	O
char	O
*	O
copy	int
;	O
int	O
set_def	char
=	O
-	O
1	int
;	O
version	short
=	O
strchr	function
(	O
s	pointer
,	O
':'	O
)	O
;	O
if	O
(	O
version	short
==	O
NULL	O
)	O
subsystem	pointer
=	O
s	pointer
;	O
else	O
{	O
int	O
len	long
=	O
version	short
-	O
s	pointer
;	O
copy	int
=	O
xstrdup	function
(	O
s	pointer
)	O
;	O
subsystem	pointer
=	O
copy	int
;	O
copy	int
[	O
len	long
]	O
=	O
'\0'	O
;	O
version	short
=	O
copy	int
+	O
1	int
+	O
len	long
;	O
pe_major_subsystem_version	short
=	O
strtoul	function
(	O
version	short
,	O
&	O
copy	int
,	O
0	int
)	O
;	O
if	O
(	O
*	O
copy	int
==	O
'.'	O
)	O
pe_minor_subsystem_version	short
=	O
strtoul	function
(	O
copy	int
+	O
1	int
,	O
&	O
copy	int
,	O
0	int
)	O
;	O
if	O
(	O
*	O
copy	int
!=	O
'\0'	O
)	O
non_fatal	function
(	O
_	O
(	O
"%s: bad version in PE subsystem"	pointer
)	O
,	O
s	pointer
)	O
;	O
}	O
value	long
=	O
(	O
short	O
)	O
strtol	function
(	O
subsystem	pointer
,	O
&	O
copy	int
,	O
0	int
)	O
;	O
if	O
(	O
*	O
copy	int
==	O
'\0'	O
)	O
{	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
ARRAY_SIZE	O
(	O
v	array
)	O
;	O
i	pointer
++	O
)	O
if	O
(	O
v	array
[	O
i	pointer
]	O
.	O
value	long
==	O
value	long
)	O
{	O
pe_subsystem	short
=	O
value	long
;	O
set_def	char
=	O
v	array
[	O
i	pointer
]	O
.	O
set_def	char
;	O
break	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
ARRAY_SIZE	O
(	O
v	array
)	O
;	O
i	pointer
++	O
)	O
if	O
(	O
strcmp	function
(	O
subsystem	pointer
,	O
v	array
[	O
i	pointer
]	O
.	O
name	pointer
)	O
==	O
0	int
)	O
{	O
pe_subsystem	short
=	O
v	array
[	O
i	pointer
]	O
.	O
value	long
;	O
set_def	char
=	O
v	array
[	O
i	pointer
]	O
.	O
set_def	char
;	O
break	O
;	O
}	O
}	O
switch	O
(	O
set_def	char
)	O
{	O
case	O
-	O
1	int
:	O
fatal	function
(	O
_	O
(	O
"unknown PE subsystem: %s"	pointer
)	O
,	O
s	pointer
)	O
;	O
break	O
;	O
case	O
0	int
:	O
break	O
;	O
default	O
:	O
if	O
(	O
pe_file_alignment	long
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
pe_file_alignment	long
=	O
PE_DEF_FILE_ALIGNMENT	int
;	O
if	O
(	O
pe_section_alignment	long
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
pe_section_alignment	long
=	O
PE_DEF_SECTION_ALIGNMENT	int
;	O
break	O
;	O
}	O
if	O
(	O
s	pointer
!=	O
subsystem	pointer
)	O
free	function
(	O
(	O
char	O
*	O
)	O
subsystem	pointer
)	O
;	O
}	O
static	O
void	O
convert_efi_target	function
(	O
char	O
*	O
efi	pointer
)	O
{	O
efi	pointer
[	O
0	int
]	O
=	O
'p'	O
;	O
efi	pointer
[	O
1	int
]	O
=	O
'e'	O
;	O
efi	pointer
[	O
2	int
]	O
=	O
'i'	O
;	O
if	O
(	O
strcmp	function
(	O
efi	pointer
+	O
4	int
,	O
"ia32"	pointer
)	O
==	O
0	int
)	O
{	O
efi	pointer
[	O
5	int
]	O
=	O
'3'	O
;	O
efi	pointer
[	O
6	int
]	O
=	O
'8'	O
;	O
efi	pointer
[	O
7	int
]	O
=	O
'6'	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
efi	pointer
+	O
4	int
,	O
"x86_64"	pointer
)	O
==	O
0	int
)	O
{	O
efi	pointer
[	O
7	int
]	O
=	O
'-'	O
;	O
}	O
}	O
static	O
struct	O
section_add	struct
*	O
init_section_add	function
(	O
const	O
char	O
*	O
arg	pointer
,	O
struct	O
section_add	struct
*	O
next	pointer
,	O
const	O
char	O
*	O
option	struct
)	O
{	O
struct	O
section_add	struct
*	O
pa	pointer
;	O
const	O
char	O
*	O
s	pointer
;	O
s	pointer
=	O
strchr	function
(	O
arg	pointer
,	O
'='	O
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
fatal	function
(	O
_	O
(	O
"bad format for %s"	pointer
)	O
,	O
option	struct
)	O
;	O
pa	pointer
=	O
(	O
struct	O
section_add	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
section_add	struct
)	O
)	O
;	O
pa	pointer
->	O
name	pointer
=	O
xstrndup	function
(	O
arg	pointer
,	O
s	pointer
-	O
arg	pointer
)	O
;	O
pa	pointer
->	O
filename	pointer
=	O
s	pointer
+	O
1	int
;	O
pa	pointer
->	O
next	pointer
=	O
next	pointer
;	O
pa	pointer
->	O
contents	pointer
=	O
NULL	O
;	O
pa	pointer
->	O
size	int
=	O
0	int
;	O
return	O
pa	pointer
;	O
}	O
static	O
void	O
section_add_load_file	function
(	O
struct	O
section_add	struct
*	O
pa	pointer
)	O
{	O
size_t	long
off	long
,	O
alloc	long
;	O
FILE	struct
*	O
f	pointer
;	O
f	pointer
=	O
fopen	function
(	O
pa	pointer
->	O
filename	pointer
,	O
FOPEN_RB	pointer
)	O
;	O
if	O
(	O
f	pointer
==	O
NULL	O
)	O
fatal	function
(	O
_	O
(	O
"cannot open: %s: %s"	pointer
)	O
,	O
pa	pointer
->	O
filename	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
off	long
=	O
0	int
;	O
alloc	long
=	O
4096	int
;	O
pa	pointer
->	O
contents	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
xmalloc	function
(	O
alloc	long
)	O
;	O
while	O
(	O
!	O
feof	function
(	O
f	pointer
)	O
)	O
{	O
off_t	long
got	union
;	O
if	O
(	O
off	long
==	O
alloc	long
)	O
{	O
alloc	long
<<=	O
1	int
;	O
pa	pointer
->	O
contents	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
xrealloc	function
(	O
pa	pointer
->	O
contents	pointer
,	O
alloc	long
)	O
;	O
}	O
got	union
=	O
fread	function
(	O
pa	pointer
->	O
contents	pointer
+	O
off	long
,	O
1	int
,	O
alloc	long
-	O
off	long
,	O
f	pointer
)	O
;	O
if	O
(	O
ferror	function
(	O
f	pointer
)	O
)	O
fatal	function
(	O
_	O
(	O
"%s: fread failed"	pointer
)	O
,	O
pa	pointer
->	O
filename	pointer
)	O
;	O
off	long
+=	O
got	union
;	O
}	O
pa	pointer
->	O
size	int
=	O
off	long
;	O
fclose	function
(	O
f	pointer
)	O
;	O
}	O
static	O
int	O
copy_main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
char	O
*	O
input_filename	pointer
=	O
NULL	O
;	O
char	O
*	O
output_filename	pointer
=	O
NULL	O
;	O
char	O
*	O
tmpname	pointer
;	O
char	O
*	O
input_target	pointer
=	O
NULL	O
;	O
char	O
*	O
output_target	pointer
=	O
NULL	O
;	O
bfd_boolean	int
show_version	int
=	O
FALSE	int
;	O
bfd_boolean	int
change_warn	int
=	O
TRUE	int
;	O
bfd_boolean	int
formats_info	int
=	O
FALSE	int
;	O
bfd_boolean	int
use_globalize	int
=	O
FALSE	int
;	O
bfd_boolean	int
use_keep_global	int
=	O
FALSE	int
;	O
int	O
c	struct
;	O
struct	O
stat	struct
statbuf	struct
;	O
const	O
bfd_arch_info_type	struct
*	O
input_arch	pointer
=	O
NULL	O
;	O
while	O
(	O
(	O
c	struct
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
"b:B:i:I:j:K:MN:s:O:d:F:L:G:R:SpgxXHhVvW:wDU"	pointer
,	O
copy_options	array
,	O
(	O
int	O
*	O
)	O
0	int
)	O
)	O
!=	O
EOF	O
)	O
{	O
switch	O
(	O
c	struct
)	O
{	O
case	O
'b'	O
:	O
copy_byte	int
=	O
atoi	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
copy_byte	int
<	O
0	int
)	O
fatal	function
(	O
_	O
(	O
"byte number must be non-negative"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
'B'	O
:	O
input_arch	pointer
=	O
bfd_scan_arch	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
input_arch	pointer
==	O
NULL	O
)	O
fatal	function
(	O
_	O
(	O
"architecture %s unknown"	pointer
)	O
,	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'i'	O
:	O
if	O
(	O
optarg	pointer
)	O
{	O
interleave	int
=	O
atoi	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
interleave	int
<	O
1	int
)	O
fatal	function
(	O
_	O
(	O
"interleave must be positive"	pointer
)	O
)	O
;	O
}	O
else	O
interleave	int
=	O
4	int
;	O
break	O
;	O
case	O
OPTION_INTERLEAVE_WIDTH	int
:	O
copy_width	int
=	O
atoi	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
copy_width	int
<	O
1	int
)	O
fatal	function
(	O
_	O
(	O
"interleave width must be positive"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
'I'	O
:	O
case	O
's'	O
:	O
input_target	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'O'	O
:	O
case	O
'd'	O
:	O
output_target	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'F'	O
:	O
input_target	pointer
=	O
output_target	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'j'	O
:	O
find_section_list	function
(	O
optarg	pointer
,	O
TRUE	int
,	O
SECTION_CONTEXT_COPY	O
)	O
;	O
sections_copied	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'R'	O
:	O
handle_remove_section_option	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_KEEP_SECTION	int
:	O
find_section_list	function
(	O
optarg	pointer
,	O
TRUE	int
,	O
SECTION_CONTEXT_KEEP	O
)	O
;	O
break	O
;	O
case	O
OPTION_REMOVE_RELOCS	int
:	O
handle_remove_relocations_option	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'S'	O
:	O
strip_symbols	enum
=	O
STRIP_ALL	int
;	O
break	O
;	O
case	O
'g'	O
:	O
strip_symbols	enum
=	O
STRIP_DEBUG	int
;	O
break	O
;	O
case	O
OPTION_STRIP_DWO	int
:	O
strip_symbols	enum
=	O
STRIP_DWO	int
;	O
break	O
;	O
case	O
OPTION_STRIP_UNNEEDED	int
:	O
strip_symbols	enum
=	O
STRIP_UNNEEDED	int
;	O
break	O
;	O
case	O
OPTION_ONLY_KEEP_DEBUG	int
:	O
strip_symbols	enum
=	O
STRIP_NONDEBUG	int
;	O
break	O
;	O
case	O
OPTION_KEEP_FILE_SYMBOLS	int
:	O
keep_file_symbols	int
=	O
1	int
;	O
break	O
;	O
case	O
OPTION_ADD_GNU_DEBUGLINK	int
:	O
long_section_names	enum
=	O
ENABLE	int
;	O
gnu_debuglink_filename	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'K'	O
:	O
add_specific_symbol	function
(	O
optarg	pointer
,	O
keep_specific_htab	pointer
)	O
;	O
break	O
;	O
case	O
'M'	O
:	O
merge_notes	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_NO_MERGE_NOTES	int
:	O
merge_notes	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
'N'	O
:	O
add_specific_symbol	function
(	O
optarg	pointer
,	O
strip_specific_htab	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_STRIP_UNNEEDED_SYMBOL	int
:	O
add_specific_symbol	function
(	O
optarg	pointer
,	O
strip_unneeded_htab	pointer
)	O
;	O
break	O
;	O
case	O
'L'	O
:	O
add_specific_symbol	function
(	O
optarg	pointer
,	O
localize_specific_htab	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_GLOBALIZE_SYMBOL	int
:	O
use_globalize	int
=	O
TRUE	int
;	O
add_specific_symbol	function
(	O
optarg	pointer
,	O
globalize_specific_htab	pointer
)	O
;	O
break	O
;	O
case	O
'G'	O
:	O
use_keep_global	int
=	O
TRUE	int
;	O
add_specific_symbol	function
(	O
optarg	pointer
,	O
keepglobal_specific_htab	pointer
)	O
;	O
break	O
;	O
case	O
'W'	O
:	O
add_specific_symbol	function
(	O
optarg	pointer
,	O
weaken_specific_htab	pointer
)	O
;	O
break	O
;	O
case	O
'p'	O
:	O
preserve_dates	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'D'	O
:	O
deterministic	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'U'	O
:	O
deterministic	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
'w'	O
:	O
wildcard	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'x'	O
:	O
discard_locals	enum
=	O
LOCALS_ALL	int
;	O
break	O
;	O
case	O
'X'	O
:	O
discard_locals	enum
=	O
LOCALS_START_L	int
;	O
break	O
;	O
case	O
'v'	O
:	O
verbose	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'V'	O
:	O
show_version	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_FORMATS_INFO	int
:	O
formats_info	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_WEAKEN	int
:	O
weaken	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_ADD_SECTION	int
:	O
add_sections	pointer
=	O
init_section_add	function
(	O
optarg	pointer
,	O
add_sections	pointer
,	O
"--add-section"	pointer
)	O
;	O
section_add_load_file	function
(	O
add_sections	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_UPDATE_SECTION	int
:	O
update_sections	pointer
=	O
init_section_add	function
(	O
optarg	pointer
,	O
update_sections	pointer
,	O
"--update-section"	pointer
)	O
;	O
section_add_load_file	function
(	O
update_sections	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_DUMP_SECTION	int
:	O
dump_sections	pointer
=	O
init_section_add	function
(	O
optarg	pointer
,	O
dump_sections	pointer
,	O
"--dump-section"	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_ADD_SYMBOL	int
:	O
{	O
char	O
*	O
s	pointer
,	O
*	O
t	pointer
;	O
struct	O
addsym_node	struct
*	O
newsym	pointer
=	O
xmalloc	function
(	O
sizeof	O
*	O
newsym	pointer
)	O
;	O
newsym	pointer
->	O
next	pointer
=	O
NULL	O
;	O
s	pointer
=	O
strchr	function
(	O
optarg	pointer
,	O
'='	O
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
fatal	function
(	O
_	O
(	O
"bad format for %s"	pointer
)	O
,	O
"--add-symbol"	pointer
)	O
;	O
t	pointer
=	O
strchr	function
(	O
s	pointer
+	O
1	int
,	O
':'	O
)	O
;	O
newsym	pointer
->	O
symdef	pointer
=	O
xstrndup	function
(	O
optarg	pointer
,	O
s	pointer
-	O
optarg	pointer
)	O
;	O
if	O
(	O
t	pointer
)	O
{	O
newsym	pointer
->	O
section	pointer
=	O
xstrndup	function
(	O
s	pointer
+	O
1	int
,	O
t	pointer
-	O
(	O
s	pointer
+	O
1	int
)	O
)	O
;	O
newsym	pointer
->	O
symval	long
=	O
strtol	function
(	O
t	pointer
+	O
1	int
,	O
NULL	O
,	O
0	int
)	O
;	O
}	O
else	O
{	O
newsym	pointer
->	O
section	pointer
=	O
NULL	O
;	O
newsym	pointer
->	O
symval	long
=	O
strtol	function
(	O
s	pointer
+	O
1	int
,	O
NULL	O
,	O
0	int
)	O
;	O
t	pointer
=	O
s	pointer
;	O
}	O
t	pointer
=	O
strchr	function
(	O
t	pointer
+	O
1	int
,	O
','	O
)	O
;	O
newsym	pointer
->	O
othersym	pointer
=	O
NULL	O
;	O
if	O
(	O
t	pointer
)	O
newsym	pointer
->	O
flags	int
=	O
parse_symflags	function
(	O
t	pointer
+	O
1	int
,	O
&	O
newsym	pointer
->	O
othersym	pointer
)	O
;	O
else	O
newsym	pointer
->	O
flags	int
=	O
BSF_GLOBAL	O
;	O
if	O
(	O
newsym	pointer
->	O
othersym	pointer
)	O
{	O
newsym	pointer
->	O
next	pointer
=	O
add_sym_list	pointer
;	O
if	O
(	O
!	O
add_sym_list	pointer
)	O
add_sym_tail	pointer
=	O
&	O
newsym	pointer
->	O
next	pointer
;	O
add_sym_list	pointer
=	O
newsym	pointer
;	O
}	O
else	O
{	O
*	O
add_sym_tail	pointer
=	O
newsym	pointer
;	O
add_sym_tail	pointer
=	O
&	O
newsym	pointer
->	O
next	pointer
;	O
}	O
add_symbols	int
++	O
;	O
}	O
break	O
;	O
case	O
OPTION_CHANGE_START	int
:	O
change_start	long
=	O
parse_vma	function
(	O
optarg	pointer
,	O
"--change-start"	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_CHANGE_SECTION_ADDRESS	int
:	O
case	O
OPTION_CHANGE_SECTION_LMA	int
:	O
case	O
OPTION_CHANGE_SECTION_VMA	int
:	O
{	O
struct	O
section_list	struct
*	O
p	pointer
;	O
unsigned	O
int	O
context	int
=	O
0	int
;	O
const	O
char	O
*	O
s	pointer
;	O
int	O
len	long
;	O
char	O
*	O
name	pointer
;	O
char	O
*	O
option	struct
=	O
NULL	O
;	O
bfd_vma	long
val	array
;	O
switch	O
(	O
c	struct
)	O
{	O
case	O
OPTION_CHANGE_SECTION_ADDRESS	int
:	O
option	struct
=	O
"--change-section-address"	pointer
;	O
context	int
=	O
SECTION_CONTEXT_ALTER_LMA	O
|	O
SECTION_CONTEXT_ALTER_VMA	O
;	O
break	O
;	O
case	O
OPTION_CHANGE_SECTION_LMA	int
:	O
option	struct
=	O
"--change-section-lma"	pointer
;	O
context	int
=	O
SECTION_CONTEXT_ALTER_LMA	O
;	O
break	O
;	O
case	O
OPTION_CHANGE_SECTION_VMA	int
:	O
option	struct
=	O
"--change-section-vma"	pointer
;	O
context	int
=	O
SECTION_CONTEXT_ALTER_VMA	O
;	O
break	O
;	O
}	O
s	pointer
=	O
strchr	function
(	O
optarg	pointer
,	O
'='	O
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
{	O
s	pointer
=	O
strchr	function
(	O
optarg	pointer
,	O
'+'	O
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
{	O
s	pointer
=	O
strchr	function
(	O
optarg	pointer
,	O
'-'	O
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
fatal	function
(	O
_	O
(	O
"bad format for %s"	pointer
)	O
,	O
option	struct
)	O
;	O
}	O
}	O
else	O
{	O
switch	O
(	O
c	struct
)	O
{	O
case	O
OPTION_CHANGE_SECTION_ADDRESS	int
:	O
context	int
=	O
SECTION_CONTEXT_SET_LMA	O
|	O
SECTION_CONTEXT_SET_VMA	O
;	O
break	O
;	O
case	O
OPTION_CHANGE_SECTION_LMA	int
:	O
context	int
=	O
SECTION_CONTEXT_SET_LMA	O
;	O
break	O
;	O
case	O
OPTION_CHANGE_SECTION_VMA	int
:	O
context	int
=	O
SECTION_CONTEXT_SET_VMA	O
;	O
break	O
;	O
}	O
}	O
len	long
=	O
s	pointer
-	O
optarg	pointer
;	O
name	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
len	long
+	O
1	int
)	O
;	O
strncpy	function
(	O
name	pointer
,	O
optarg	pointer
,	O
len	long
)	O
;	O
name	pointer
[	O
len	long
]	O
=	O
'\0'	O
;	O
p	pointer
=	O
find_section_list	function
(	O
name	pointer
,	O
TRUE	int
,	O
context	int
)	O
;	O
val	array
=	O
parse_vma	function
(	O
s	pointer
+	O
1	int
,	O
option	struct
)	O
;	O
if	O
(	O
*	O
s	pointer
==	O
'-'	O
)	O
val	array
=	O
-	O
val	array
;	O
switch	O
(	O
c	struct
)	O
{	O
case	O
OPTION_CHANGE_SECTION_ADDRESS	int
:	O
p	pointer
->	O
vma_val	long
=	O
val	array
;	O
case	O
OPTION_CHANGE_SECTION_LMA	int
:	O
p	pointer
->	O
lma_val	long
=	O
val	array
;	O
break	O
;	O
case	O
OPTION_CHANGE_SECTION_VMA	int
:	O
p	pointer
->	O
vma_val	long
=	O
val	array
;	O
break	O
;	O
}	O
}	O
break	O
;	O
case	O
OPTION_CHANGE_ADDRESSES	int
:	O
change_section_address	long
=	O
parse_vma	function
(	O
optarg	pointer
,	O
"--change-addresses"	pointer
)	O
;	O
change_start	long
=	O
change_section_address	long
;	O
break	O
;	O
case	O
OPTION_CHANGE_WARNINGS	int
:	O
change_warn	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_CHANGE_LEADING_CHAR	int
:	O
change_leading_char	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_COMPRESS_DEBUG_SECTIONS	int
:	O
if	O
(	O
optarg	pointer
)	O
{	O
if	O
(	O
strcasecmp	function
(	O
optarg	pointer
,	O
"none"	pointer
)	O
==	O
0	int
)	O
do_debug_sections	enum
=	O
decompress	int
;	O
else	O
if	O
(	O
strcasecmp	function
(	O
optarg	pointer
,	O
"zlib"	pointer
)	O
==	O
0	int
)	O
do_debug_sections	enum
=	O
compress_zlib	int
;	O
else	O
if	O
(	O
strcasecmp	function
(	O
optarg	pointer
,	O
"zlib-gnu"	pointer
)	O
==	O
0	int
)	O
do_debug_sections	enum
=	O
compress_gnu_zlib	int
;	O
else	O
if	O
(	O
strcasecmp	function
(	O
optarg	pointer
,	O
"zlib-gabi"	pointer
)	O
==	O
0	int
)	O
do_debug_sections	enum
=	O
compress_gabi_zlib	int
;	O
else	O
fatal	function
(	O
_	O
(	O
"unrecognized --compress-debug-sections type `%s'"	pointer
)	O
,	O
optarg	pointer
)	O
;	O
}	O
else	O
do_debug_sections	enum
=	O
compress	int
;	O
break	O
;	O
case	O
OPTION_DEBUGGING	int
:	O
convert_debugging	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_DECOMPRESS_DEBUG_SECTIONS	int
:	O
do_debug_sections	enum
=	O
decompress	int
;	O
break	O
;	O
case	O
OPTION_ELF_STT_COMMON	int
:	O
if	O
(	O
strcasecmp	function
(	O
optarg	pointer
,	O
"yes"	pointer
)	O
==	O
0	int
)	O
do_elf_stt_common	enum
=	O
elf_stt_common	int
;	O
else	O
if	O
(	O
strcasecmp	function
(	O
optarg	pointer
,	O
"no"	pointer
)	O
==	O
0	int
)	O
do_elf_stt_common	enum
=	O
no_elf_stt_common	int
;	O
else	O
fatal	function
(	O
_	O
(	O
"unrecognized --elf-stt-common= option `%s'"	pointer
)	O
,	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_GAP_FILL	int
:	O
{	O
bfd_vma	long
gap_fill_vma	long
;	O
gap_fill_vma	long
=	O
parse_vma	function
(	O
optarg	pointer
,	O
"--gap-fill"	pointer
)	O
;	O
gap_fill	char
=	O
(	O
bfd_byte	char
)	O
gap_fill_vma	long
;	O
if	O
(	O
(	O
bfd_vma	long
)	O
gap_fill	char
!=	O
gap_fill_vma	long
)	O
{	O
char	O
buff	array
[	O
20	int
]	O
;	O
sprintf_vma	O
(	O
buff	array
,	O
gap_fill_vma	long
)	O
;	O
non_fatal	function
(	O
_	O
(	O
"Warning: truncating gap-fill from 0x%s to 0x%x"	pointer
)	O
,	O
buff	array
,	O
gap_fill	char
)	O
;	O
}	O
gap_fill_set	int
=	O
TRUE	int
;	O
}	O
break	O
;	O
case	O
OPTION_NO_CHANGE_WARNINGS	int
:	O
change_warn	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
OPTION_PAD_TO	int
:	O
pad_to	long
=	O
parse_vma	function
(	O
optarg	pointer
,	O
"--pad-to"	pointer
)	O
;	O
pad_to_set	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_REMOVE_LEADING_CHAR	int
:	O
remove_leading_char	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_REDEFINE_SYM	int
:	O
{	O
int	O
len	long
;	O
const	O
char	O
*	O
s	pointer
;	O
const	O
char	O
*	O
nextarg	pointer
;	O
char	O
*	O
source	pointer
,	O
*	O
target	pointer
;	O
s	pointer
=	O
strchr	function
(	O
optarg	pointer
,	O
'='	O
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
fatal	function
(	O
_	O
(	O
"bad format for %s"	pointer
)	O
,	O
"--redefine-sym"	pointer
)	O
;	O
len	long
=	O
s	pointer
-	O
optarg	pointer
;	O
source	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
len	long
+	O
1	int
)	O
;	O
strncpy	function
(	O
source	pointer
,	O
optarg	pointer
,	O
len	long
)	O
;	O
source	pointer
[	O
len	long
]	O
=	O
'\0'	O
;	O
nextarg	pointer
=	O
s	pointer
+	O
1	int
;	O
len	long
=	O
strlen	function
(	O
nextarg	pointer
)	O
;	O
target	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
len	long
+	O
1	int
)	O
;	O
strcpy	function
(	O
target	pointer
,	O
nextarg	pointer
)	O
;	O
add_redefine_and_check	function
(	O
"--redefine-sym"	pointer
,	O
source	pointer
,	O
target	pointer
)	O
;	O
free	function
(	O
source	pointer
)	O
;	O
free	function
(	O
target	pointer
)	O
;	O
}	O
break	O
;	O
case	O
OPTION_REDEFINE_SYMS	int
:	O
add_redefine_syms_file	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_SET_SECTION_FLAGS	int
:	O
{	O
struct	O
section_list	struct
*	O
p	pointer
;	O
const	O
char	O
*	O
s	pointer
;	O
int	O
len	long
;	O
char	O
*	O
name	pointer
;	O
s	pointer
=	O
strchr	function
(	O
optarg	pointer
,	O
'='	O
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
fatal	function
(	O
_	O
(	O
"bad format for %s"	pointer
)	O
,	O
"--set-section-flags"	pointer
)	O
;	O
len	long
=	O
s	pointer
-	O
optarg	pointer
;	O
name	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
len	long
+	O
1	int
)	O
;	O
strncpy	function
(	O
name	pointer
,	O
optarg	pointer
,	O
len	long
)	O
;	O
name	pointer
[	O
len	long
]	O
=	O
'\0'	O
;	O
p	pointer
=	O
find_section_list	function
(	O
name	pointer
,	O
TRUE	int
,	O
SECTION_CONTEXT_SET_FLAGS	O
)	O
;	O
p	pointer
->	O
flags	int
=	O
parse_flags	function
(	O
s	pointer
+	O
1	int
)	O
;	O
}	O
break	O
;	O
case	O
OPTION_SET_SECTION_ALIGNMENT	int
:	O
{	O
struct	O
section_list	struct
*	O
p	pointer
;	O
const	O
char	O
*	O
s	pointer
;	O
int	O
len	long
;	O
char	O
*	O
name	pointer
;	O
int	O
palign	int
,	O
align	int
;	O
s	pointer
=	O
strchr	function
(	O
optarg	pointer
,	O
'='	O
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
fatal	function
(	O
_	O
(	O
"bad format for --set-section-alignment: argument needed"	pointer
)	O
)	O
;	O
align	int
=	O
atoi	function
(	O
s	pointer
+	O
1	int
)	O
;	O
if	O
(	O
align	int
<=	O
0	int
)	O
fatal	function
(	O
_	O
(	O
"bad format for --set-section-alignment: numeric argument needed"	pointer
)	O
)	O
;	O
palign	int
=	O
0	int
;	O
while	O
(	O
(	O
align	int
&	O
1	int
)	O
==	O
0	int
)	O
{	O
align	int
>>=	O
1	int
;	O
++	O
palign	int
;	O
}	O
if	O
(	O
align	int
!=	O
1	int
)	O
fatal	function
(	O
_	O
(	O
"bad format for --set-section-alignment: alignment is not a power of two"	pointer
)	O
)	O
;	O
len	long
=	O
s	pointer
-	O
optarg	pointer
;	O
name	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
len	long
+	O
1	int
)	O
;	O
strncpy	function
(	O
name	pointer
,	O
optarg	pointer
,	O
len	long
)	O
;	O
name	pointer
[	O
len	long
]	O
=	O
'\0'	O
;	O
p	pointer
=	O
find_section_list	function
(	O
name	pointer
,	O
TRUE	int
,	O
SECTION_CONTEXT_SET_ALIGNMENT	O
)	O
;	O
if	O
(	O
p	pointer
)	O
p	pointer
->	O
alignment	int
=	O
palign	int
;	O
}	O
break	O
;	O
case	O
OPTION_RENAME_SECTION	int
:	O
{	O
flagword	int
flags	int
;	O
const	O
char	O
*	O
eq	pointer
,	O
*	O
fl	pointer
;	O
char	O
*	O
old_name	pointer
;	O
char	O
*	O
new_name	pointer
;	O
unsigned	O
int	O
len	long
;	O
eq	pointer
=	O
strchr	function
(	O
optarg	pointer
,	O
'='	O
)	O
;	O
if	O
(	O
eq	pointer
==	O
NULL	O
)	O
fatal	function
(	O
_	O
(	O
"bad format for %s"	pointer
)	O
,	O
"--rename-section"	pointer
)	O
;	O
len	long
=	O
eq	pointer
-	O
optarg	pointer
;	O
if	O
(	O
len	long
==	O
0	int
)	O
fatal	function
(	O
_	O
(	O
"bad format for %s"	pointer
)	O
,	O
"--rename-section"	pointer
)	O
;	O
old_name	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
len	long
+	O
1	int
)	O
;	O
strncpy	function
(	O
old_name	pointer
,	O
optarg	pointer
,	O
len	long
)	O
;	O
old_name	pointer
[	O
len	long
]	O
=	O
0	int
;	O
eq	pointer
++	O
;	O
fl	pointer
=	O
strchr	function
(	O
eq	pointer
,	O
','	O
)	O
;	O
if	O
(	O
fl	pointer
)	O
{	O
flags	int
=	O
parse_flags	function
(	O
fl	pointer
+	O
1	int
)	O
;	O
len	long
=	O
fl	pointer
-	O
eq	pointer
;	O
}	O
else	O
{	O
flags	int
=	O
-	O
1	int
;	O
len	long
=	O
strlen	function
(	O
eq	pointer
)	O
;	O
}	O
if	O
(	O
len	long
==	O
0	int
)	O
fatal	function
(	O
_	O
(	O
"bad format for %s"	pointer
)	O
,	O
"--rename-section"	pointer
)	O
;	O
new_name	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
len	long
+	O
1	int
)	O
;	O
strncpy	function
(	O
new_name	pointer
,	O
eq	pointer
,	O
len	long
)	O
;	O
new_name	pointer
[	O
len	long
]	O
=	O
0	int
;	O
add_section_rename	function
(	O
old_name	pointer
,	O
new_name	pointer
,	O
flags	int
)	O
;	O
}	O
break	O
;	O
case	O
OPTION_SET_START	int
:	O
set_start	long
=	O
parse_vma	function
(	O
optarg	pointer
,	O
"--set-start"	pointer
)	O
;	O
set_start_set	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_SREC_LEN	int
:	O
_bfd_srec_len	int
=	O
parse_vma	function
(	O
optarg	pointer
,	O
"--srec-len"	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_SREC_FORCES3	int
:	O
_bfd_srec_forceS3	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_STRIP_SYMBOLS	int
:	O
add_specific_symbols	function
(	O
optarg	pointer
,	O
strip_specific_htab	pointer
,	O
&	O
strip_specific_buffer	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_STRIP_UNNEEDED_SYMBOLS	int
:	O
add_specific_symbols	function
(	O
optarg	pointer
,	O
strip_unneeded_htab	pointer
,	O
&	O
strip_unneeded_buffer	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_KEEP_SYMBOLS	int
:	O
add_specific_symbols	function
(	O
optarg	pointer
,	O
keep_specific_htab	pointer
,	O
&	O
keep_specific_buffer	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_LOCALIZE_HIDDEN	int
:	O
localize_hidden	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_LOCALIZE_SYMBOLS	int
:	O
add_specific_symbols	function
(	O
optarg	pointer
,	O
localize_specific_htab	pointer
,	O
&	O
localize_specific_buffer	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_LONG_SECTION_NAMES	int
:	O
if	O
(	O
!	O
strcmp	function
(	O
"enable"	pointer
,	O
optarg	pointer
)	O
)	O
long_section_names	enum
=	O
ENABLE	int
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
"disable"	pointer
,	O
optarg	pointer
)	O
)	O
long_section_names	enum
=	O
DISABLE	int
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
"keep"	pointer
,	O
optarg	pointer
)	O
)	O
long_section_names	enum
=	O
KEEP	int
;	O
else	O
fatal	function
(	O
_	O
(	O
"unknown long section names option '%s'"	pointer
)	O
,	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_GLOBALIZE_SYMBOLS	int
:	O
use_globalize	int
=	O
TRUE	int
;	O
add_specific_symbols	function
(	O
optarg	pointer
,	O
globalize_specific_htab	pointer
,	O
&	O
globalize_specific_buffer	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_KEEPGLOBAL_SYMBOLS	int
:	O
use_keep_global	int
=	O
TRUE	int
;	O
add_specific_symbols	function
(	O
optarg	pointer
,	O
keepglobal_specific_htab	pointer
,	O
&	O
keepglobal_specific_buffer	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_WEAKEN_SYMBOLS	int
:	O
add_specific_symbols	function
(	O
optarg	pointer
,	O
weaken_specific_htab	pointer
,	O
&	O
weaken_specific_buffer	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_ALT_MACH_CODE	int
:	O
use_alt_mach_code	long
=	O
strtoul	function
(	O
optarg	pointer
,	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
use_alt_mach_code	long
==	O
0	int
)	O
fatal	function
(	O
_	O
(	O
"unable to parse alternative machine code"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
OPTION_PREFIX_SYMBOLS	int
:	O
prefix_symbols_string	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
OPTION_PREFIX_SECTIONS	int
:	O
prefix_sections_string	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
OPTION_PREFIX_ALLOC_SECTIONS	int
:	O
prefix_alloc_sections_string	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
OPTION_READONLY_TEXT	int
:	O
bfd_flags_to_set	int
|=	O
WP_TEXT	int
;	O
bfd_flags_to_clear	int
&=	O
~	O
WP_TEXT	int
;	O
break	O
;	O
case	O
OPTION_WRITABLE_TEXT	int
:	O
bfd_flags_to_clear	int
|=	O
WP_TEXT	int
;	O
bfd_flags_to_set	int
&=	O
~	O
WP_TEXT	int
;	O
break	O
;	O
case	O
OPTION_PURE	int
:	O
bfd_flags_to_set	int
|=	O
D_PAGED	int
;	O
bfd_flags_to_clear	int
&=	O
~	O
D_PAGED	int
;	O
break	O
;	O
case	O
OPTION_IMPURE	int
:	O
bfd_flags_to_clear	int
|=	O
D_PAGED	int
;	O
bfd_flags_to_set	int
&=	O
~	O
D_PAGED	int
;	O
break	O
;	O
case	O
OPTION_EXTRACT_DWO	int
:	O
strip_symbols	enum
=	O
STRIP_NONDWO	int
;	O
break	O
;	O
case	O
OPTION_EXTRACT_SYMBOL	int
:	O
extract_symbol	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_REVERSE_BYTES	int
:	O
{	O
int	O
prev	pointer
=	O
reverse_bytes	int
;	O
reverse_bytes	int
=	O
atoi	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
(	O
reverse_bytes	int
<=	O
0	int
)	O
||	O
(	O
(	O
reverse_bytes	int
%	O
2	int
)	O
!=	O
0	int
)	O
)	O
fatal	function
(	O
_	O
(	O
"number of bytes to reverse must be positive and even"	pointer
)	O
)	O
;	O
if	O
(	O
prev	pointer
&&	O
prev	pointer
!=	O
reverse_bytes	int
)	O
non_fatal	function
(	O
_	O
(	O
"Warning: ignoring previous --reverse-bytes value of %d"	pointer
)	O
,	O
prev	pointer
)	O
;	O
break	O
;	O
}	O
case	O
OPTION_FILE_ALIGNMENT	int
:	O
pe_file_alignment	long
=	O
parse_vma	function
(	O
optarg	pointer
,	O
"--file-alignment"	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_HEAP	int
:	O
{	O
char	O
*	O
end	pointer
;	O
pe_heap_reserve	long
=	O
strtoul	function
(	O
optarg	pointer
,	O
&	O
end	pointer
,	O
0	int
)	O
;	O
if	O
(	O
end	pointer
==	O
optarg	pointer
||	O
(	O
*	O
end	pointer
!=	O
'.'	O
&&	O
*	O
end	pointer
!=	O
'\0'	O
)	O
)	O
non_fatal	function
(	O
_	O
(	O
"%s: invalid reserve value for --heap"	pointer
)	O
,	O
optarg	pointer
)	O
;	O
else	O
if	O
(	O
*	O
end	pointer
!=	O
'\0'	O
)	O
{	O
pe_heap_commit	long
=	O
strtoul	function
(	O
end	pointer
+	O
1	int
,	O
&	O
end	pointer
,	O
0	int
)	O
;	O
if	O
(	O
*	O
end	pointer
!=	O
'\0'	O
)	O
non_fatal	function
(	O
_	O
(	O
"%s: invalid commit value for --heap"	pointer
)	O
,	O
optarg	pointer
)	O
;	O
}	O
}	O
break	O
;	O
case	O
OPTION_IMAGE_BASE	int
:	O
pe_image_base	long
=	O
parse_vma	function
(	O
optarg	pointer
,	O
"--image-base"	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_PE_SECTION_ALIGNMENT	int
:	O
pe_section_alignment	long
=	O
parse_vma	function
(	O
optarg	pointer
,	O
"--section-alignment"	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_SUBSYSTEM	int
:	O
set_pe_subsystem	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_STACK	int
:	O
{	O
char	O
*	O
end	pointer
;	O
pe_stack_reserve	long
=	O
strtoul	function
(	O
optarg	pointer
,	O
&	O
end	pointer
,	O
0	int
)	O
;	O
if	O
(	O
end	pointer
==	O
optarg	pointer
||	O
(	O
*	O
end	pointer
!=	O
'.'	O
&&	O
*	O
end	pointer
!=	O
'\0'	O
)	O
)	O
non_fatal	function
(	O
_	O
(	O
"%s: invalid reserve value for --stack"	pointer
)	O
,	O
optarg	pointer
)	O
;	O
else	O
if	O
(	O
*	O
end	pointer
!=	O
'\0'	O
)	O
{	O
pe_stack_commit	long
=	O
strtoul	function
(	O
end	pointer
+	O
1	int
,	O
&	O
end	pointer
,	O
0	int
)	O
;	O
if	O
(	O
*	O
end	pointer
!=	O
'\0'	O
)	O
non_fatal	function
(	O
_	O
(	O
"%s: invalid commit value for --stack"	pointer
)	O
,	O
optarg	pointer
)	O
;	O
}	O
}	O
break	O
;	O
case	O
OPTION_VERILOG_DATA_WIDTH	int
:	O
VerilogDataWidth	int
=	O
parse_vma	function
(	O
optarg	pointer
,	O
"--verilog-data-width"	pointer
)	O
;	O
if	O
(	O
VerilogDataWidth	int
<	O
1	int
)	O
fatal	function
(	O
_	O
(	O
"verilog data width must be at least 1 byte"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
0	int
:	O
break	O
;	O
case	O
'H'	O
:	O
case	O
'h'	O
:	O
copy_usage	function
(	O
stdout	pointer
,	O
0	int
)	O
;	O
default	O
:	O
copy_usage	function
(	O
stderr	pointer
,	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
use_globalize	int
&&	O
use_keep_global	int
)	O
fatal	function
(	O
_	O
(	O
"--globalize-symbol(s) is incompatible with -G/--keep-global-symbol(s)"	pointer
)	O
)	O
;	O
if	O
(	O
formats_info	int
)	O
{	O
display_info	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
show_version	int
)	O
print_version	function
(	O
"objcopy"	pointer
)	O
;	O
if	O
(	O
interleave	int
&&	O
copy_byte	int
==	O
-	O
1	int
)	O
fatal	function
(	O
_	O
(	O
"interleave start byte must be set with --byte"	pointer
)	O
)	O
;	O
if	O
(	O
copy_byte	int
>=	O
interleave	int
)	O
fatal	function
(	O
_	O
(	O
"byte number must be less than interleave"	pointer
)	O
)	O
;	O
if	O
(	O
copy_width	int
>	O
interleave	int
-	O
copy_byte	int
)	O
fatal	function
(	O
_	O
(	O
"interleave width must be less than or equal to interleave - byte`"	pointer
)	O
)	O
;	O
if	O
(	O
optind	int
==	O
argc	int
||	O
optind	int
+	O
2	int
<	O
argc	int
)	O
copy_usage	function
(	O
stderr	pointer
,	O
1	int
)	O
;	O
input_filename	pointer
=	O
argv	pointer
[	O
optind	int
]	O
;	O
if	O
(	O
optind	int
+	O
1	int
<	O
argc	int
)	O
output_filename	pointer
=	O
argv	pointer
[	O
optind	int
+	O
1	int
]	O
;	O
default_deterministic	function
(	O
)	O
;	O
if	O
(	O
strip_symbols	enum
==	O
STRIP_UNDEF	int
&&	O
discard_locals	enum
==	O
LOCALS_UNDEF	int
)	O
strip_symbols	enum
=	O
STRIP_NONE	int
;	O
if	O
(	O
output_target	pointer
==	O
NULL	O
)	O
output_target	pointer
=	O
input_target	pointer
;	O
if	O
(	O
input_target	pointer
!=	O
NULL	O
&&	O
strncmp	function
(	O
input_target	pointer
,	O
"efi-"	pointer
,	O
4	int
)	O
==	O
0	int
)	O
{	O
char	O
*	O
efi	pointer
;	O
efi	pointer
=	O
xstrdup	function
(	O
output_target	pointer
+	O
4	int
)	O
;	O
if	O
(	O
strncmp	function
(	O
efi	pointer
,	O
"bsdrv-"	pointer
,	O
6	int
)	O
==	O
0	int
||	O
strncmp	function
(	O
efi	pointer
,	O
"rtdrv-"	pointer
,	O
6	int
)	O
==	O
0	int
)	O
efi	pointer
+=	O
2	int
;	O
else	O
if	O
(	O
strncmp	function
(	O
efi	pointer
,	O
"app-"	pointer
,	O
4	int
)	O
!=	O
0	int
)	O
fatal	function
(	O
_	O
(	O
"unknown input EFI target: %s"	pointer
)	O
,	O
input_target	pointer
)	O
;	O
input_target	pointer
=	O
efi	pointer
;	O
convert_efi_target	function
(	O
efi	pointer
)	O
;	O
}	O
if	O
(	O
output_target	pointer
!=	O
NULL	O
&&	O
strncmp	function
(	O
output_target	pointer
,	O
"efi-"	pointer
,	O
4	int
)	O
==	O
0	int
)	O
{	O
char	O
*	O
efi	pointer
;	O
efi	pointer
=	O
xstrdup	function
(	O
output_target	pointer
+	O
4	int
)	O
;	O
if	O
(	O
strncmp	function
(	O
efi	pointer
,	O
"app-"	pointer
,	O
4	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
pe_subsystem	short
==	O
-	O
1	int
)	O
pe_subsystem	short
=	O
IMAGE_SUBSYSTEM_EFI_APPLICATION	int
;	O
}	O
else	O
if	O
(	O
strncmp	function
(	O
efi	pointer
,	O
"bsdrv-"	pointer
,	O
6	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
pe_subsystem	short
==	O
-	O
1	int
)	O
pe_subsystem	short
=	O
IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER	int
;	O
efi	pointer
+=	O
2	int
;	O
}	O
else	O
if	O
(	O
strncmp	function
(	O
efi	pointer
,	O
"rtdrv-"	pointer
,	O
6	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
pe_subsystem	short
==	O
-	O
1	int
)	O
pe_subsystem	short
=	O
IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER	int
;	O
efi	pointer
+=	O
2	int
;	O
}	O
else	O
fatal	function
(	O
_	O
(	O
"unknown output EFI target: %s"	pointer
)	O
,	O
output_target	pointer
)	O
;	O
if	O
(	O
pe_file_alignment	long
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
pe_file_alignment	long
=	O
PE_DEF_FILE_ALIGNMENT	int
;	O
if	O
(	O
pe_section_alignment	long
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
pe_section_alignment	long
=	O
PE_DEF_SECTION_ALIGNMENT	int
;	O
output_target	pointer
=	O
efi	pointer
;	O
convert_efi_target	function
(	O
efi	pointer
)	O
;	O
}	O
if	O
(	O
preserve_dates	int
)	O
if	O
(	O
stat	struct
(	O
input_filename	pointer
,	O
&	O
statbuf	struct
)	O
<	O
0	int
)	O
fatal	function
(	O
_	O
(	O
"warning: could not locate '%s'.  System error message: %s"	pointer
)	O
,	O
input_filename	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
if	O
(	O
output_filename	pointer
==	O
NULL	O
||	O
filename_cmp	function
(	O
input_filename	pointer
,	O
output_filename	pointer
)	O
==	O
0	int
)	O
tmpname	pointer
=	O
make_tempname	function
(	O
input_filename	pointer
)	O
;	O
else	O
tmpname	pointer
=	O
output_filename	pointer
;	O
if	O
(	O
tmpname	pointer
==	O
NULL	O
)	O
fatal	function
(	O
_	O
(	O
"warning: could not create temporary file whilst copying '%s', (error: %s)"	pointer
)	O
,	O
input_filename	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
copy_file	function
(	O
input_filename	pointer
,	O
tmpname	pointer
,	O
input_target	pointer
,	O
output_target	pointer
,	O
input_arch	pointer
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
{	O
if	O
(	O
preserve_dates	int
)	O
set_times	function
(	O
tmpname	pointer
,	O
&	O
statbuf	struct
)	O
;	O
if	O
(	O
tmpname	pointer
!=	O
output_filename	pointer
)	O
status	int
=	O
(	O
smart_rename	function
(	O
tmpname	pointer
,	O
input_filename	pointer
,	O
preserve_dates	int
)	O
!=	O
0	int
)	O
;	O
}	O
else	O
unlink_if_ordinary	function
(	O
tmpname	pointer
)	O
;	O
if	O
(	O
tmpname	pointer
!=	O
output_filename	pointer
)	O
free	function
(	O
tmpname	pointer
)	O
;	O
if	O
(	O
change_warn	int
)	O
{	O
struct	O
section_list	struct
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
change_sections	pointer
;	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
!	O
p	pointer
->	O
used	int
)	O
{	O
if	O
(	O
p	pointer
->	O
context	int
&	O
(	O
SECTION_CONTEXT_SET_VMA	O
|	O
SECTION_CONTEXT_ALTER_VMA	O
)	O
)	O
{	O
char	O
buff	array
[	O
20	int
]	O
;	O
sprintf_vma	O
(	O
buff	array
,	O
p	pointer
->	O
vma_val	long
)	O
;	O
non_fatal	function
(	O
_	O
(	O
"%s %s%c0x%s never used"	pointer
)	O
,	O
"--change-section-vma"	pointer
,	O
p	pointer
->	O
pattern	pointer
,	O
p	pointer
->	O
context	int
&	O
SECTION_CONTEXT_SET_VMA	O
?	O
'='	O
:	O
'+'	O
,	O
buff	array
)	O
;	O
}	O
if	O
(	O
p	pointer
->	O
context	int
&	O
(	O
SECTION_CONTEXT_SET_LMA	O
|	O
SECTION_CONTEXT_ALTER_LMA	O
)	O
)	O
{	O
char	O
buff	array
[	O
20	int
]	O
;	O
sprintf_vma	O
(	O
buff	array
,	O
p	pointer
->	O
lma_val	long
)	O
;	O
non_fatal	function
(	O
_	O
(	O
"%s %s%c0x%s never used"	pointer
)	O
,	O
"--change-section-lma"	pointer
,	O
p	pointer
->	O
pattern	pointer
,	O
p	pointer
->	O
context	int
&	O
SECTION_CONTEXT_SET_LMA	O
?	O
'='	O
:	O
'+'	O
,	O
buff	array
)	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
strip_specific_buffer	pointer
)	O
free	function
(	O
strip_specific_buffer	pointer
)	O
;	O
if	O
(	O
strip_unneeded_buffer	pointer
)	O
free	function
(	O
strip_unneeded_buffer	pointer
)	O
;	O
if	O
(	O
keep_specific_buffer	pointer
)	O
free	function
(	O
keep_specific_buffer	pointer
)	O
;	O
if	O
(	O
localize_specific_buffer	pointer
)	O
free	function
(	O
globalize_specific_buffer	pointer
)	O
;	O
if	O
(	O
globalize_specific_buffer	pointer
)	O
free	function
(	O
globalize_specific_buffer	pointer
)	O
;	O
if	O
(	O
keepglobal_specific_buffer	pointer
)	O
free	function
(	O
keepglobal_specific_buffer	pointer
)	O
;	O
if	O
(	O
weaken_specific_buffer	pointer
)	O
free	function
(	O
weaken_specific_buffer	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
setlocale	function
(	O
LC_MESSAGES	O
,	O
""	pointer
)	O
;	O
setlocale	function
(	O
LC_CTYPE	O
,	O
""	pointer
)	O
;	O
bindtextdomain	function
(	O
PACKAGE	pointer
,	O
LOCALEDIR	O
)	O
;	O
textdomain	function
(	O
PACKAGE	pointer
)	O
;	O
program_name	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
xmalloc_set_program_name	function
(	O
program_name	pointer
)	O
;	O
START_PROGRESS	O
(	O
program_name	pointer
,	O
0	int
)	O
;	O
expandargv	function
(	O
&	O
argc	int
,	O
&	O
argv	pointer
)	O
;	O
strip_symbols	enum
=	O
STRIP_UNDEF	int
;	O
discard_locals	enum
=	O
LOCALS_UNDEF	int
;	O
if	O
(	O
bfd_init	function
(	O
)	O
!=	O
BFD_INIT_MAGIC	O
)	O
fatal	function
(	O
_	O
(	O
"fatal error: libbfd ABI mismatch"	pointer
)	O
)	O
;	O
set_default_bfd_target	function
(	O
)	O
;	O
if	O
(	O
is_strip	int
<	O
0	int
)	O
{	O
int	O
i	pointer
=	O
strlen	function
(	O
program_name	pointer
)	O
;	O
is_strip	int
=	O
(	O
i	pointer
>=	O
5	int
&&	O
FILENAME_CMP	O
(	O
program_name	pointer
+	O
i	pointer
-	O
5	int
,	O
"strip"	pointer
)	O
==	O
0	int
)	O
;	O
}	O
create_symbol_htabs	function
(	O
)	O
;	O
if	O
(	O
argv	pointer
!=	O
NULL	O
)	O
bfd_set_error_program_name	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
if	O
(	O
is_strip	int
)	O
strip_main	function
(	O
argc	int
,	O
argv	pointer
)	O
;	O
else	O
copy_main	function
(	O
argc	int
,	O
argv	pointer
)	O
;	O
END_PROGRESS	O
(	O
program_name	pointer
)	O
;	O
return	O
status	int
;	O
}	O
