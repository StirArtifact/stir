typedef	O
int	O
(	O
*	O
md5func	pointer
)	O
(	O
const	O
char	O
*	O
fn	pointer
,	O
unsigned	O
char	O
*	O
digest	array
)	O
;	O
int	O
rpmLookupSignatureType	function
(	O
int	O
action	int
)	O
{	O
static	O
int	O
disabled	int
=	O
0	int
;	O
int	O
rc	int
=	O
0	int
;	O
switch	O
(	O
action	int
)	O
{	O
case	O
RPMLOOKUPSIG_DISABLE	int
:	O
disabled	int
=	O
-	O
2	int
;	O
break	O
;	O
case	O
RPMLOOKUPSIG_ENABLE	int
:	O
disabled	int
=	O
0	int
;	O
case	O
RPMLOOKUPSIG_QUERY	int
:	O
if	O
(	O
disabled	int
)	O
break	O
;	O
{	O
const	O
char	O
*	O
name	pointer
=	O
rpmExpand	function
(	O
"%{_signature}"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
(	O
name	pointer
&&	O
*	O
name	pointer
!=	O
'%'	O
)	O
)	O
rc	int
=	O
0	int
;	O
else	O
if	O
(	O
!	O
strcasecmp	function
(	O
name	pointer
,	O
"none"	pointer
)	O
)	O
rc	int
=	O
0	int
;	O
else	O
if	O
(	O
!	O
strcasecmp	function
(	O
name	pointer
,	O
"pgp"	pointer
)	O
)	O
rc	int
=	O
RPMSIGTAG_PGP	int
;	O
else	O
if	O
(	O
!	O
strcasecmp	function
(	O
name	pointer
,	O
"pgp5"	pointer
)	O
)	O
rc	int
=	O
RPMSIGTAG_PGP	int
;	O
else	O
if	O
(	O
!	O
strcasecmp	function
(	O
name	pointer
,	O
"gpg"	pointer
)	O
)	O
rc	int
=	O
RPMSIGTAG_GPG	int
;	O
else	O
rc	int
=	O
-	O
1	int
;	O
xfree	O
(	O
name	pointer
)	O
;	O
}	O
break	O
;	O
}	O
return	O
rc	int
;	O
}	O
const	O
char	O
*	O
rpmDetectPGPVersion	function
(	O
pgpVersion	enum
*	O
pgpVer	pointer
)	O
{	O
static	O
pgpVersion	enum
saved_pgp_version	enum
=	O
PGP_UNKNOWN	int
;	O
const	O
char	O
*	O
pgpbin	pointer
=	O
rpmGetPath	function
(	O
"%{_pgpbin}"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
saved_pgp_version	enum
==	O
PGP_UNKNOWN	int
)	O
{	O
char	O
*	O
pgpvbin	pointer
;	O
struct	O
stat	struct
statbuf	struct
;	O
if	O
(	O
!	O
(	O
pgpbin	pointer
&&	O
pgpbin	pointer
[	O
0	int
]	O
!=	O
'%'	O
)	O
||	O
!	O
(	O
pgpvbin	pointer
=	O
(	O
char	O
*	O
)	O
alloca	function
(	O
strlen	function
(	O
pgpbin	pointer
)	O
+	O
2	int
)	O
)	O
)	O
{	O
if	O
(	O
pgpbin	pointer
)	O
xfree	O
(	O
pgpbin	pointer
)	O
;	O
saved_pgp_version	enum
=	O
-	O
1	int
;	O
return	O
NULL	O
;	O
}	O
sprintf	function
(	O
pgpvbin	pointer
,	O
"%sv"	pointer
,	O
pgpbin	pointer
)	O
;	O
if	O
(	O
stat	struct
(	O
pgpvbin	pointer
,	O
&	O
statbuf	struct
)	O
==	O
0	int
)	O
saved_pgp_version	enum
=	O
PGP_5	int
;	O
else	O
if	O
(	O
stat	struct
(	O
pgpbin	pointer
,	O
&	O
statbuf	struct
)	O
==	O
0	int
)	O
saved_pgp_version	enum
=	O
PGP_2	int
;	O
else	O
saved_pgp_version	enum
=	O
PGP_NOTDETECTED	int
;	O
}	O
if	O
(	O
pgpbin	pointer
&&	O
pgpVer	pointer
)	O
*	O
pgpVer	pointer
=	O
saved_pgp_version	enum
;	O
return	O
pgpbin	pointer
;	O
}	O
static	O
int	O
checkSize	function
(	O
FD_t	pointer
fd	pointer
,	O
int	O
size	long
,	O
int	O
sigsize	int
)	O
{	O
int	O
headerArchiveSize	int
;	O
struct	O
stat	struct
statbuf	struct
;	O
fstat	function
(	O
Fileno	function
(	O
fd	pointer
)	O
,	O
&	O
statbuf	struct
)	O
;	O
if	O
(	O
S_ISREG	O
(	O
statbuf	struct
.	O
st_mode	int
)	O
)	O
{	O
headerArchiveSize	int
=	O
statbuf	struct
.	O
st_size	long
-	O
sizeof	O
(	O
struct	O
rpmlead	struct
)	O
-	O
sigsize	int
;	O
rpmMessage	function
(	O
RPMMESS_DEBUG	int
,	O
_	O
(	O
"sigsize         : %d\n"	pointer
)	O
,	O
sigsize	int
)	O
;	O
rpmMessage	function
(	O
RPMMESS_DEBUG	int
,	O
_	O
(	O
"Header + Archive: %d\n"	pointer
)	O
,	O
headerArchiveSize	int
)	O
;	O
rpmMessage	function
(	O
RPMMESS_DEBUG	int
,	O
_	O
(	O
"expected size   : %d\n"	pointer
)	O
,	O
size	long
)	O
;	O
return	O
size	long
-	O
headerArchiveSize	int
;	O
}	O
else	O
{	O
rpmMessage	function
(	O
RPMMESS_DEBUG	int
,	O
_	O
(	O
"file is not regular -- skipping size check\n"	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
int	O
rpmReadSignature	function
(	O
FD_t	pointer
fd	pointer
,	O
Header	pointer
*	O
headerp	pointer
,	O
short	O
sig_type	short
)	O
{	O
unsigned	O
char	O
buf	pointer
[	O
2048	int
]	O
;	O
int	O
sigSize	int
,	O
pad	int
;	O
int_32	int
type	enum
,	O
count	long
;	O
int_32	int
*	O
archSize	pointer
;	O
Header	pointer
h	pointer
;	O
if	O
(	O
headerp	pointer
)	O
*	O
headerp	pointer
=	O
NULL	O
;	O
switch	O
(	O
sig_type	short
)	O
{	O
case	O
RPMSIG_NONE	int
:	O
rpmMessage	function
(	O
RPMMESS_DEBUG	int
,	O
_	O
(	O
"No signature\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
RPMSIG_PGP262_1024	int
:	O
rpmMessage	function
(	O
RPMMESS_DEBUG	int
,	O
_	O
(	O
"Old PGP signature\n"	pointer
)	O
)	O
;	O
if	O
(	O
timedRead	function
(	O
fd	pointer
,	O
buf	pointer
,	O
256	int
)	O
!=	O
256	int
)	O
return	O
1	int
;	O
if	O
(	O
headerp	pointer
)	O
{	O
*	O
headerp	pointer
=	O
headerNew	function
(	O
)	O
;	O
headerAddEntry	function
(	O
*	O
headerp	pointer
,	O
RPMSIGTAG_PGP	int
,	O
RPM_BIN_TYPE	int
,	O
buf	pointer
,	O
152	int
)	O
;	O
}	O
break	O
;	O
case	O
RPMSIG_MD5	int
:	O
case	O
RPMSIG_MD5_PGP	int
:	O
rpmError	function
(	O
RPMERR_BADSIGTYPE	O
,	O
_	O
(	O
"Old (internal-only) signature!  How did you get that!?"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
break	O
;	O
case	O
RPMSIG_HEADERSIG	int
:	O
rpmMessage	function
(	O
RPMMESS_DEBUG	int
,	O
_	O
(	O
"New Header signature\n"	pointer
)	O
)	O
;	O
h	pointer
=	O
headerRead	function
(	O
fd	pointer
,	O
HEADER_MAGIC_YES	int
)	O
;	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
return	O
1	int
;	O
sigSize	int
=	O
headerSizeof	function
(	O
h	pointer
,	O
HEADER_MAGIC_YES	int
)	O
;	O
pad	int
=	O
(	O
8	int
-	O
(	O
sigSize	int
%	O
8	int
)	O
)	O
%	O
8	int
;	O
rpmMessage	function
(	O
RPMMESS_DEBUG	int
,	O
_	O
(	O
"Signature size: %d\n"	pointer
)	O
,	O
sigSize	int
)	O
;	O
rpmMessage	function
(	O
RPMMESS_DEBUG	int
,	O
_	O
(	O
"Signature pad : %d\n"	pointer
)	O
,	O
pad	int
)	O
;	O
if	O
(	O
!	O
headerGetEntry	function
(	O
h	pointer
,	O
RPMSIGTAG_SIZE	int
,	O
&	O
type	enum
,	O
(	O
void	O
*	O
*	O
)	O
&	O
archSize	pointer
,	O
&	O
count	long
)	O
)	O
{	O
headerFree	function
(	O
h	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
checkSize	function
(	O
fd	pointer
,	O
*	O
archSize	pointer
,	O
sigSize	int
+	O
pad	int
)	O
)	O
{	O
headerFree	function
(	O
h	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
pad	int
)	O
{	O
if	O
(	O
timedRead	function
(	O
fd	pointer
,	O
buf	pointer
,	O
pad	int
)	O
!=	O
pad	int
)	O
{	O
headerFree	function
(	O
h	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
if	O
(	O
headerp	pointer
)	O
{	O
*	O
headerp	pointer
=	O
h	pointer
;	O
}	O
else	O
{	O
headerFree	function
(	O
h	pointer
)	O
;	O
}	O
break	O
;	O
default	O
:	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
rpmWriteSignature	function
(	O
FD_t	pointer
fd	pointer
,	O
Header	pointer
header	pointer
)	O
{	O
int	O
sigSize	int
,	O
pad	int
;	O
unsigned	O
char	O
buf	pointer
[	O
8	int
]	O
;	O
int	O
rc	int
=	O
0	int
;	O
rc	int
=	O
headerWrite	function
(	O
fd	pointer
,	O
header	pointer
,	O
HEADER_MAGIC_YES	int
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
sigSize	int
=	O
headerSizeof	function
(	O
header	pointer
,	O
HEADER_MAGIC_YES	int
)	O
;	O
pad	int
=	O
(	O
8	int
-	O
(	O
sigSize	int
%	O
8	int
)	O
)	O
%	O
8	int
;	O
if	O
(	O
pad	int
)	O
{	O
rpmMessage	function
(	O
RPMMESS_DEBUG	int
,	O
_	O
(	O
"Signature size: %d\n"	pointer
)	O
,	O
sigSize	int
)	O
;	O
rpmMessage	function
(	O
RPMMESS_DEBUG	int
,	O
_	O
(	O
"Signature pad : %d\n"	pointer
)	O
,	O
pad	int
)	O
;	O
memset	function
(	O
buf	pointer
,	O
0	int
,	O
pad	int
)	O
;	O
if	O
(	O
Fwrite	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
[	O
0	int
]	O
)	O
,	O
pad	int
,	O
fd	pointer
)	O
!=	O
pad	int
)	O
rc	int
=	O
1	int
;	O
}	O
return	O
rc	int
;	O
}	O
Header	pointer
rpmNewSignature	function
(	O
void	O
)	O
{	O
Header	pointer
h	pointer
=	O
headerNew	function
(	O
)	O
;	O
return	O
h	pointer
;	O
}	O
void	O
rpmFreeSignature	function
(	O
Header	pointer
h	pointer
)	O
{	O
headerFree	function
(	O
h	pointer
)	O
;	O
}	O
static	O
int	O
makePGPSignature	function
(	O
const	O
char	O
*	O
file	pointer
,	O
void	O
*	O
*	O
sig	pointer
,	O
int_32	int
*	O
size	long
,	O
const	O
char	O
*	O
passPhrase	pointer
)	O
{	O
char	O
sigfile	array
[	O
1024	int
]	O
;	O
int	O
pid	int
,	O
status	int
;	O
int	O
inpipe	array
[	O
2	int
]	O
;	O
struct	O
stat	struct
statbuf	struct
;	O
sprintf	function
(	O
sigfile	array
,	O
"%s.sig"	pointer
,	O
file	pointer
)	O
;	O
inpipe	array
[	O
0	int
]	O
=	O
inpipe	array
[	O
1	int
]	O
=	O
0	int
;	O
pipe	function
(	O
inpipe	array
)	O
;	O
if	O
(	O
!	O
(	O
pid	int
=	O
fork	function
(	O
)	O
)	O
)	O
{	O
const	O
char	O
*	O
pgp_path	pointer
=	O
rpmExpand	function
(	O
"%{_pgp_path}"	pointer
,	O
NULL	O
)	O
;	O
const	O
char	O
*	O
name	pointer
=	O
rpmExpand	function
(	O
"+myname=\"%{_pgp_name}\""	pointer
,	O
NULL	O
)	O
;	O
const	O
char	O
*	O
path	pointer
;	O
pgpVersion	enum
pgpVer	pointer
;	O
close	pointer
(	O
STDIN_FILENO	int
)	O
;	O
dup2	function
(	O
inpipe	array
[	O
0	int
]	O
,	O
3	int
)	O
;	O
close	pointer
(	O
inpipe	array
[	O
1	int
]	O
)	O
;	O
dosetenv	function
(	O
"PGPPASSFD"	pointer
,	O
"3"	pointer
,	O
1	int
)	O
;	O
if	O
(	O
pgp_path	pointer
&&	O
*	O
pgp_path	pointer
!=	O
'%'	O
)	O
dosetenv	function
(	O
"PGPPATH"	pointer
,	O
pgp_path	pointer
,	O
1	int
)	O
;	O
if	O
(	O
(	O
path	pointer
=	O
rpmDetectPGPVersion	function
(	O
&	O
pgpVer	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
switch	O
(	O
pgpVer	pointer
)	O
{	O
case	O
PGP_2	int
:	O
execlp	function
(	O
path	pointer
,	O
"pgp"	pointer
,	O
"+batchmode=on"	pointer
,	O
"+verbose=0"	pointer
,	O
"+armor=off"	pointer
,	O
name	pointer
,	O
"-sb"	pointer
,	O
file	pointer
,	O
sigfile	array
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
PGP_5	int
:	O
execlp	function
(	O
path	pointer
,	O
"pgps"	pointer
,	O
"+batchmode=on"	pointer
,	O
"+verbose=0"	pointer
,	O
"+armor=off"	pointer
,	O
name	pointer
,	O
"-b"	pointer
,	O
file	pointer
,	O
"-o"	pointer
,	O
sigfile	array
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
PGP_UNKNOWN	int
:	O
case	O
PGP_NOTDETECTED	int
:	O
break	O
;	O
}	O
}	O
rpmError	function
(	O
RPMERR_EXEC	O
,	O
_	O
(	O
"Couldn't exec pgp (%s)"	pointer
)	O
,	O
path	pointer
)	O
;	O
_exit	function
(	O
RPMERR_EXEC	O
)	O
;	O
}	O
close	pointer
(	O
inpipe	array
[	O
0	int
]	O
)	O
;	O
(	O
void	O
)	O
write	pointer
(	O
inpipe	array
[	O
1	int
]	O
,	O
passPhrase	pointer
,	O
strlen	function
(	O
passPhrase	pointer
)	O
)	O
;	O
(	O
void	O
)	O
write	pointer
(	O
inpipe	array
[	O
1	int
]	O
,	O
"\n"	pointer
,	O
1	int
)	O
;	O
close	pointer
(	O
inpipe	array
[	O
1	int
]	O
)	O
;	O
(	O
void	O
)	O
waitpid	function
(	O
pid	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
if	O
(	O
!	O
WIFEXITED	O
(	O
status	int
)	O
||	O
WEXITSTATUS	O
(	O
status	int
)	O
)	O
{	O
rpmError	function
(	O
RPMERR_SIGGEN	O
,	O
_	O
(	O
"pgp failed"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
stat	struct
(	O
sigfile	array
,	O
&	O
statbuf	struct
)	O
)	O
{	O
unlink	function
(	O
sigfile	array
)	O
;	O
rpmError	function
(	O
RPMERR_SIGGEN	O
,	O
_	O
(	O
"pgp failed to write signature"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
*	O
size	long
=	O
statbuf	struct
.	O
st_size	long
;	O
rpmMessage	function
(	O
RPMMESS_DEBUG	int
,	O
_	O
(	O
"PGP sig size: %d\n"	pointer
)	O
,	O
*	O
size	long
)	O
;	O
*	O
sig	pointer
=	O
xmalloc	function
(	O
*	O
size	long
)	O
;	O
{	O
FD_t	pointer
fd	pointer
;	O
int	O
rc	int
;	O
fd	pointer
=	O
Fopen	function
(	O
sigfile	array
,	O
"r.fdio"	pointer
)	O
;	O
rc	int
=	O
timedRead	function
(	O
fd	pointer
,	O
*	O
sig	pointer
,	O
*	O
size	long
)	O
;	O
unlink	function
(	O
sigfile	array
)	O
;	O
Fclose	function
(	O
fd	pointer
)	O
;	O
if	O
(	O
rc	int
!=	O
*	O
size	long
)	O
{	O
free	function
(	O
*	O
sig	pointer
)	O
;	O
rpmError	function
(	O
RPMERR_SIGGEN	O
,	O
_	O
(	O
"unable to read the signature"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
rpmMessage	function
(	O
RPMMESS_DEBUG	int
,	O
_	O
(	O
"Got %d bytes of PGP sig\n"	pointer
)	O
,	O
*	O
size	long
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
makeGPGSignature	function
(	O
const	O
char	O
*	O
file	pointer
,	O
void	O
*	O
*	O
sig	pointer
,	O
int_32	int
*	O
size	long
,	O
const	O
char	O
*	O
passPhrase	pointer
)	O
{	O
char	O
sigfile	array
[	O
1024	int
]	O
;	O
int	O
pid	int
,	O
status	int
;	O
int	O
inpipe	array
[	O
2	int
]	O
;	O
FILE	struct
*	O
fpipe	pointer
;	O
struct	O
stat	struct
statbuf	struct
;	O
sprintf	function
(	O
sigfile	array
,	O
"%s.sig"	pointer
,	O
file	pointer
)	O
;	O
inpipe	array
[	O
0	int
]	O
=	O
inpipe	array
[	O
1	int
]	O
=	O
0	int
;	O
pipe	function
(	O
inpipe	array
)	O
;	O
if	O
(	O
!	O
(	O
pid	int
=	O
fork	function
(	O
)	O
)	O
)	O
{	O
const	O
char	O
*	O
gpg_path	pointer
=	O
rpmExpand	function
(	O
"%{_gpg_path}"	pointer
,	O
NULL	O
)	O
;	O
const	O
char	O
*	O
name	pointer
=	O
rpmExpand	function
(	O
"%{_gpg_name}"	pointer
,	O
NULL	O
)	O
;	O
close	pointer
(	O
STDIN_FILENO	int
)	O
;	O
dup2	function
(	O
inpipe	array
[	O
0	int
]	O
,	O
3	int
)	O
;	O
close	pointer
(	O
inpipe	array
[	O
1	int
]	O
)	O
;	O
if	O
(	O
gpg_path	pointer
&&	O
*	O
gpg_path	pointer
!=	O
'%'	O
)	O
dosetenv	function
(	O
"GNUPGHOME"	pointer
,	O
gpg_path	pointer
,	O
1	int
)	O
;	O
execlp	function
(	O
"gpg"	pointer
,	O
"gpg"	pointer
,	O
"--batch"	pointer
,	O
"--no-verbose"	pointer
,	O
"--no-armor"	pointer
,	O
"--passphrase-fd"	pointer
,	O
"3"	pointer
,	O
"-u"	pointer
,	O
name	pointer
,	O
"-sbo"	pointer
,	O
sigfile	array
,	O
file	pointer
,	O
NULL	O
)	O
;	O
rpmError	function
(	O
RPMERR_EXEC	O
,	O
_	O
(	O
"Couldn't exec gpg"	pointer
)	O
)	O
;	O
_exit	function
(	O
RPMERR_EXEC	O
)	O
;	O
}	O
fpipe	pointer
=	O
fdopen	function
(	O
inpipe	array
[	O
1	int
]	O
,	O
"w"	pointer
)	O
;	O
close	pointer
(	O
inpipe	array
[	O
0	int
]	O
)	O
;	O
fprintf	function
(	O
fpipe	pointer
,	O
"%s\n"	pointer
,	O
passPhrase	pointer
)	O
;	O
fclose	function
(	O
fpipe	pointer
)	O
;	O
(	O
void	O
)	O
waitpid	function
(	O
pid	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
if	O
(	O
!	O
WIFEXITED	O
(	O
status	int
)	O
||	O
WEXITSTATUS	O
(	O
status	int
)	O
)	O
{	O
rpmError	function
(	O
RPMERR_SIGGEN	O
,	O
_	O
(	O
"gpg failed"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
stat	struct
(	O
sigfile	array
,	O
&	O
statbuf	struct
)	O
)	O
{	O
unlink	function
(	O
sigfile	array
)	O
;	O
rpmError	function
(	O
RPMERR_SIGGEN	O
,	O
_	O
(	O
"gpg failed to write signature"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
*	O
size	long
=	O
statbuf	struct
.	O
st_size	long
;	O
rpmMessage	function
(	O
RPMMESS_DEBUG	int
,	O
_	O
(	O
"GPG sig size: %d\n"	pointer
)	O
,	O
*	O
size	long
)	O
;	O
*	O
sig	pointer
=	O
xmalloc	function
(	O
*	O
size	long
)	O
;	O
{	O
FD_t	pointer
fd	pointer
;	O
int	O
rc	int
;	O
fd	pointer
=	O
Fopen	function
(	O
sigfile	array
,	O
"r.fdio"	pointer
)	O
;	O
rc	int
=	O
timedRead	function
(	O
fd	pointer
,	O
*	O
sig	pointer
,	O
*	O
size	long
)	O
;	O
unlink	function
(	O
sigfile	array
)	O
;	O
Fclose	function
(	O
fd	pointer
)	O
;	O
if	O
(	O
rc	int
!=	O
*	O
size	long
)	O
{	O
free	function
(	O
*	O
sig	pointer
)	O
;	O
rpmError	function
(	O
RPMERR_SIGGEN	O
,	O
_	O
(	O
"unable to read the signature"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
rpmMessage	function
(	O
RPMMESS_DEBUG	int
,	O
_	O
(	O
"Got %d bytes of GPG sig\n"	pointer
)	O
,	O
*	O
size	long
)	O
;	O
return	O
0	int
;	O
}	O
int	O
rpmAddSignature	function
(	O
Header	pointer
header	pointer
,	O
const	O
char	O
*	O
file	pointer
,	O
int_32	int
sigTag	int
,	O
const	O
char	O
*	O
passPhrase	pointer
)	O
{	O
struct	O
stat	struct
statbuf	struct
;	O
int_32	int
size	long
;	O
unsigned	O
char	O
buf	pointer
[	O
16	int
]	O
;	O
void	O
*	O
sig	pointer
;	O
int	O
ret	int
=	O
-	O
1	int
;	O
switch	O
(	O
sigTag	int
)	O
{	O
case	O
RPMSIGTAG_SIZE	int
:	O
stat	struct
(	O
file	pointer
,	O
&	O
statbuf	struct
)	O
;	O
size	long
=	O
statbuf	struct
.	O
st_size	long
;	O
ret	int
=	O
0	int
;	O
headerAddEntry	function
(	O
header	pointer
,	O
RPMSIGTAG_SIZE	int
,	O
RPM_INT32_TYPE	int
,	O
&	O
size	long
,	O
1	int
)	O
;	O
break	O
;	O
case	O
RPMSIGTAG_MD5	int
:	O
ret	int
=	O
mdbinfile	function
(	O
file	pointer
,	O
buf	pointer
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
headerAddEntry	function
(	O
header	pointer
,	O
sigTag	int
,	O
RPM_BIN_TYPE	int
,	O
buf	pointer
,	O
16	int
)	O
;	O
break	O
;	O
case	O
RPMSIGTAG_PGP5	int
:	O
case	O
RPMSIGTAG_PGP	int
:	O
rpmMessage	function
(	O
RPMMESS_VERBOSE	int
,	O
_	O
(	O
"Generating signature using PGP.\n"	pointer
)	O
)	O
;	O
ret	int
=	O
makePGPSignature	function
(	O
file	pointer
,	O
&	O
sig	pointer
,	O
&	O
size	long
,	O
passPhrase	pointer
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
headerAddEntry	function
(	O
header	pointer
,	O
sigTag	int
,	O
RPM_BIN_TYPE	int
,	O
sig	pointer
,	O
size	long
)	O
;	O
break	O
;	O
case	O
RPMSIGTAG_GPG	int
:	O
rpmMessage	function
(	O
RPMMESS_VERBOSE	int
,	O
_	O
(	O
"Generating signature using GPG.\n"	pointer
)	O
)	O
;	O
ret	int
=	O
makeGPGSignature	function
(	O
file	pointer
,	O
&	O
sig	pointer
,	O
&	O
size	long
,	O
passPhrase	pointer
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
headerAddEntry	function
(	O
header	pointer
,	O
sigTag	int
,	O
RPM_BIN_TYPE	int
,	O
sig	pointer
,	O
size	long
)	O
;	O
break	O
;	O
}	O
return	O
ret	int
;	O
}	O
static	O
int	O
verifySizeSignature	function
(	O
const	O
char	O
*	O
datafile	pointer
,	O
int_32	int
size	long
,	O
char	O
*	O
result	pointer
)	O
{	O
struct	O
stat	struct
statbuf	struct
;	O
stat	struct
(	O
datafile	pointer
,	O
&	O
statbuf	struct
)	O
;	O
if	O
(	O
size	long
!=	O
statbuf	struct
.	O
st_size	long
)	O
{	O
sprintf	function
(	O
result	pointer
,	O
"Header+Archive size mismatch.\n"	pointer
"Expected %d, saw %d.\n"	pointer
,	O
size	long
,	O
(	O
int	O
)	O
statbuf	struct
.	O
st_size	long
)	O
;	O
return	O
1	int
;	O
}	O
sprintf	function
(	O
result	pointer
,	O
"Header+Archive size OK: %d bytes\n"	pointer
,	O
size	long
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
verifyMD5Signature	function
(	O
const	O
char	O
*	O
datafile	pointer
,	O
unsigned	O
char	O
*	O
sig	pointer
,	O
char	O
*	O
result	pointer
,	O
md5func	pointer
fn	pointer
)	O
{	O
unsigned	O
char	O
md5sum	array
[	O
16	int
]	O
;	O
fn	pointer
(	O
datafile	pointer
,	O
md5sum	array
)	O
;	O
if	O
(	O
memcmp	function
(	O
md5sum	array
,	O
sig	pointer
,	O
16	int
)	O
)	O
{	O
sprintf	function
(	O
result	pointer
,	O
"MD5 sum mismatch\n"	pointer
"Expected: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"	pointer
"%02x%02x%02x%02x%02x\n"	pointer
"Saw     : %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"	pointer
"%02x%02x%02x%02x%02x\n"	pointer
,	O
X	O
(	O
sig	pointer
[	O
0	int
]	O
)	O
,	O
X	O
(	O
sig	pointer
[	O
1	int
]	O
)	O
,	O
X	O
(	O
sig	pointer
[	O
2	int
]	O
)	O
,	O
X	O
(	O
sig	pointer
[	O
3	int
]	O
)	O
,	O
X	O
(	O
sig	pointer
[	O
4	int
]	O
)	O
,	O
X	O
(	O
sig	pointer
[	O
5	int
]	O
)	O
,	O
X	O
(	O
sig	pointer
[	O
6	int
]	O
)	O
,	O
X	O
(	O
sig	pointer
[	O
7	int
]	O
)	O
,	O
X	O
(	O
sig	pointer
[	O
8	int
]	O
)	O
,	O
X	O
(	O
sig	pointer
[	O
9	int
]	O
)	O
,	O
X	O
(	O
sig	pointer
[	O
10	int
]	O
)	O
,	O
X	O
(	O
sig	pointer
[	O
11	int
]	O
)	O
,	O
X	O
(	O
sig	pointer
[	O
12	int
]	O
)	O
,	O
X	O
(	O
sig	pointer
[	O
13	int
]	O
)	O
,	O
X	O
(	O
sig	pointer
[	O
14	int
]	O
)	O
,	O
X	O
(	O
sig	pointer
[	O
15	int
]	O
)	O
,	O
X	O
(	O
md5sum	array
[	O
0	int
]	O
)	O
,	O
X	O
(	O
md5sum	array
[	O
1	int
]	O
)	O
,	O
X	O
(	O
md5sum	array
[	O
2	int
]	O
)	O
,	O
X	O
(	O
md5sum	array
[	O
3	int
]	O
)	O
,	O
X	O
(	O
md5sum	array
[	O
4	int
]	O
)	O
,	O
X	O
(	O
md5sum	array
[	O
5	int
]	O
)	O
,	O
X	O
(	O
md5sum	array
[	O
6	int
]	O
)	O
,	O
X	O
(	O
md5sum	array
[	O
7	int
]	O
)	O
,	O
X	O
(	O
md5sum	array
[	O
8	int
]	O
)	O
,	O
X	O
(	O
md5sum	array
[	O
9	int
]	O
)	O
,	O
X	O
(	O
md5sum	array
[	O
10	int
]	O
)	O
,	O
X	O
(	O
md5sum	array
[	O
11	int
]	O
)	O
,	O
X	O
(	O
md5sum	array
[	O
12	int
]	O
)	O
,	O
X	O
(	O
md5sum	array
[	O
13	int
]	O
)	O
,	O
X	O
(	O
md5sum	array
[	O
14	int
]	O
)	O
,	O
X	O
(	O
md5sum	array
[	O
15	int
]	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
sprintf	function
(	O
result	pointer
,	O
"MD5 sum OK: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"	pointer
"%02x%02x%02x%02x%02x\n"	pointer
,	O
X	O
(	O
md5sum	array
[	O
0	int
]	O
)	O
,	O
X	O
(	O
md5sum	array
[	O
1	int
]	O
)	O
,	O
X	O
(	O
md5sum	array
[	O
2	int
]	O
)	O
,	O
X	O
(	O
md5sum	array
[	O
3	int
]	O
)	O
,	O
X	O
(	O
md5sum	array
[	O
4	int
]	O
)	O
,	O
X	O
(	O
md5sum	array
[	O
5	int
]	O
)	O
,	O
X	O
(	O
md5sum	array
[	O
6	int
]	O
)	O
,	O
X	O
(	O
md5sum	array
[	O
7	int
]	O
)	O
,	O
X	O
(	O
md5sum	array
[	O
8	int
]	O
)	O
,	O
X	O
(	O
md5sum	array
[	O
9	int
]	O
)	O
,	O
X	O
(	O
md5sum	array
[	O
10	int
]	O
)	O
,	O
X	O
(	O
md5sum	array
[	O
11	int
]	O
)	O
,	O
X	O
(	O
md5sum	array
[	O
12	int
]	O
)	O
,	O
X	O
(	O
md5sum	array
[	O
13	int
]	O
)	O
,	O
X	O
(	O
md5sum	array
[	O
14	int
]	O
)	O
,	O
X	O
(	O
md5sum	array
[	O
15	int
]	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
verifyPGPSignature	function
(	O
const	O
char	O
*	O
datafile	pointer
,	O
void	O
*	O
sig	pointer
,	O
int	O
count	long
,	O
char	O
*	O
result	pointer
)	O
{	O
int	O
pid	int
,	O
status	int
,	O
outpipe	array
[	O
2	int
]	O
;	O
FD_t	pointer
sfd	pointer
;	O
char	O
*	O
sigfile	array
;	O
unsigned	O
char	O
buf	pointer
[	O
BUFSIZ	int
]	O
;	O
FILE	struct
*	O
file	pointer
;	O
int	O
res	int
=	O
RPMSIG_OK	int
;	O
const	O
char	O
*	O
path	pointer
;	O
pgpVersion	enum
pgpVer	pointer
;	O
if	O
(	O
(	O
path	pointer
=	O
rpmDetectPGPVersion	function
(	O
&	O
pgpVer	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
errno	O
=	O
ENOENT	int
;	O
rpmError	function
(	O
RPMERR_EXEC	O
,	O
_	O
(	O
"Could not run pgp.  Use --nopgp to skip PGP checks."	pointer
)	O
)	O
;	O
_exit	function
(	O
RPMERR_EXEC	O
)	O
;	O
}	O
if	O
(	O
pgpVer	pointer
==	O
PGP_5	int
)	O
res	int
=	O
RPMSIG_BAD	int
;	O
{	O
const	O
char	O
*	O
tmppath	pointer
=	O
rpmGetPath	function
(	O
"%{_tmppath}"	pointer
,	O
NULL	O
)	O
;	O
sigfile	array
=	O
tempnam	function
(	O
tmppath	pointer
,	O
"rpmsig"	pointer
)	O
;	O
xfree	O
(	O
tmppath	pointer
)	O
;	O
}	O
sfd	pointer
=	O
Fopen	function
(	O
sigfile	array
,	O
"w.fdio"	pointer
)	O
;	O
(	O
void	O
)	O
Fwrite	function
(	O
sig	pointer
,	O
sizeof	O
(	O
char	O
)	O
,	O
count	long
,	O
sfd	pointer
)	O
;	O
Fclose	function
(	O
sfd	pointer
)	O
;	O
outpipe	array
[	O
0	int
]	O
=	O
outpipe	array
[	O
1	int
]	O
=	O
0	int
;	O
pipe	function
(	O
outpipe	array
)	O
;	O
if	O
(	O
!	O
(	O
pid	int
=	O
fork	function
(	O
)	O
)	O
)	O
{	O
const	O
char	O
*	O
pgp_path	pointer
=	O
rpmExpand	function
(	O
"%{_pgp_path}"	pointer
,	O
NULL	O
)	O
;	O
close	pointer
(	O
outpipe	array
[	O
0	int
]	O
)	O
;	O
close	pointer
(	O
STDOUT_FILENO	int
)	O
;	O
dup2	function
(	O
outpipe	array
[	O
1	int
]	O
,	O
STDOUT_FILENO	int
)	O
;	O
if	O
(	O
pgp_path	pointer
&&	O
*	O
pgp_path	pointer
!=	O
'%'	O
)	O
dosetenv	function
(	O
"PGPPATH"	pointer
,	O
pgp_path	pointer
,	O
1	int
)	O
;	O
switch	O
(	O
pgpVer	pointer
)	O
{	O
case	O
PGP_5	int
:	O
{	O
int	O
save_stderr	int
=	O
dup	function
(	O
2	int
)	O
;	O
dup2	function
(	O
1	int
,	O
2	int
)	O
;	O
execlp	function
(	O
path	pointer
,	O
"pgpv"	pointer
,	O
"+batchmode=on"	pointer
,	O
"+verbose=0"	pointer
,	O
"+OutputInformationFD=1"	pointer
,	O
"+OutputWarningFD=1"	pointer
,	O
sigfile	array
,	O
"-o"	pointer
,	O
datafile	pointer
,	O
NULL	O
)	O
;	O
dup2	function
(	O
save_stderr	int
,	O
2	int
)	O
;	O
close	pointer
(	O
save_stderr	int
)	O
;	O
}	O
break	O
;	O
case	O
PGP_2	int
:	O
execlp	function
(	O
path	pointer
,	O
"pgp"	pointer
,	O
"+batchmode=on"	pointer
,	O
"+verbose=0"	pointer
,	O
sigfile	array
,	O
datafile	pointer
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
PGP_UNKNOWN	int
:	O
case	O
PGP_NOTDETECTED	int
:	O
break	O
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"exec failed!\n"	pointer
)	O
)	O
;	O
rpmError	function
(	O
RPMERR_EXEC	O
,	O
_	O
(	O
"Could not run pgp.  Use --nopgp to skip PGP checks."	pointer
)	O
)	O
;	O
_exit	function
(	O
RPMERR_EXEC	O
)	O
;	O
}	O
close	pointer
(	O
outpipe	array
[	O
1	int
]	O
)	O
;	O
file	pointer
=	O
fdopen	function
(	O
outpipe	array
[	O
0	int
]	O
,	O
"r"	pointer
)	O
;	O
result	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
while	O
(	O
fgets	function
(	O
buf	pointer
,	O
1024	int
,	O
file	pointer
)	O
)	O
{	O
if	O
(	O
strncmp	function
(	O
"File '"	pointer
,	O
buf	pointer
,	O
6	int
)	O
&&	O
strncmp	function
(	O
"Text is assu"	pointer
,	O
buf	pointer
,	O
12	int
)	O
&&	O
strncmp	function
(	O
"This signature applies to another message"	pointer
,	O
buf	pointer
,	O
41	int
)	O
&&	O
buf	pointer
[	O
0	int
]	O
!=	O
'\n'	O
)	O
{	O
strcat	function
(	O
result	pointer
,	O
buf	pointer
)	O
;	O
}	O
if	O
(	O
!	O
strncmp	function
(	O
"WARNING: Can't find the right public key"	pointer
,	O
buf	pointer
,	O
40	int
)	O
)	O
res	int
=	O
RPMSIG_NOKEY	int
;	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
"Signature by unknown keyid:"	pointer
,	O
buf	pointer
,	O
27	int
)	O
)	O
res	int
=	O
RPMSIG_NOKEY	int
;	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
"WARNING: The signing key is not trusted"	pointer
,	O
buf	pointer
,	O
39	int
)	O
)	O
res	int
=	O
RPMSIG_NOTTRUSTED	int
;	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
"Good signature"	pointer
,	O
buf	pointer
,	O
14	int
)	O
)	O
res	int
=	O
RPMSIG_OK	int
;	O
}	O
fclose	function
(	O
file	pointer
)	O
;	O
(	O
void	O
)	O
waitpid	function
(	O
pid	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
unlink	function
(	O
sigfile	array
)	O
;	O
if	O
(	O
!	O
res	int
&&	O
(	O
!	O
WIFEXITED	O
(	O
status	int
)	O
||	O
WEXITSTATUS	O
(	O
status	int
)	O
)	O
)	O
{	O
res	int
=	O
RPMSIG_BAD	int
;	O
}	O
return	O
res	int
;	O
}	O
static	O
int	O
verifyGPGSignature	function
(	O
const	O
char	O
*	O
datafile	pointer
,	O
void	O
*	O
sig	pointer
,	O
int	O
count	long
,	O
char	O
*	O
result	pointer
)	O
{	O
int	O
pid	int
,	O
status	int
,	O
outpipe	array
[	O
2	int
]	O
;	O
FD_t	pointer
sfd	pointer
;	O
char	O
*	O
sigfile	array
;	O
unsigned	O
char	O
buf	pointer
[	O
8192	int
]	O
;	O
FILE	struct
*	O
file	pointer
;	O
int	O
res	int
=	O
RPMSIG_OK	int
;	O
{	O
const	O
char	O
*	O
tmppath	pointer
=	O
rpmGetPath	function
(	O
"%{_tmppath}"	pointer
,	O
NULL	O
)	O
;	O
sigfile	array
=	O
tempnam	function
(	O
tmppath	pointer
,	O
"rpmsig"	pointer
)	O
;	O
xfree	O
(	O
tmppath	pointer
)	O
;	O
}	O
sfd	pointer
=	O
Fopen	function
(	O
sigfile	array
,	O
"w.fdio"	pointer
)	O
;	O
(	O
void	O
)	O
Fwrite	function
(	O
sig	pointer
,	O
sizeof	O
(	O
char	O
)	O
,	O
count	long
,	O
sfd	pointer
)	O
;	O
Fclose	function
(	O
sfd	pointer
)	O
;	O
outpipe	array
[	O
0	int
]	O
=	O
outpipe	array
[	O
1	int
]	O
=	O
0	int
;	O
pipe	function
(	O
outpipe	array
)	O
;	O
if	O
(	O
!	O
(	O
pid	int
=	O
fork	function
(	O
)	O
)	O
)	O
{	O
const	O
char	O
*	O
gpg_path	pointer
=	O
rpmExpand	function
(	O
"%{_gpg_path}"	pointer
,	O
NULL	O
)	O
;	O
close	pointer
(	O
outpipe	array
[	O
0	int
]	O
)	O
;	O
dup2	function
(	O
outpipe	array
[	O
1	int
]	O
,	O
STDERR_FILENO	int
)	O
;	O
if	O
(	O
gpg_path	pointer
&&	O
*	O
gpg_path	pointer
!=	O
'%'	O
)	O
dosetenv	function
(	O
"GNUPGHOME"	pointer
,	O
gpg_path	pointer
,	O
1	int
)	O
;	O
execlp	function
(	O
"gpg"	pointer
,	O
"gpg"	pointer
,	O
"--batch"	pointer
,	O
"--no-verbose"	pointer
,	O
"--verify"	pointer
,	O
sigfile	array
,	O
datafile	pointer
,	O
NULL	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"exec failed!\n"	pointer
)	O
)	O
;	O
rpmError	function
(	O
RPMERR_EXEC	O
,	O
_	O
(	O
"Could not run gpg.  Use --nogpg to skip GPG checks."	pointer
)	O
)	O
;	O
_exit	function
(	O
RPMERR_EXEC	O
)	O
;	O
}	O
close	pointer
(	O
outpipe	array
[	O
1	int
]	O
)	O
;	O
file	pointer
=	O
fdopen	function
(	O
outpipe	array
[	O
0	int
]	O
,	O
"r"	pointer
)	O
;	O
result	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
while	O
(	O
fgets	function
(	O
buf	pointer
,	O
1024	int
,	O
file	pointer
)	O
)	O
{	O
strcat	function
(	O
result	pointer
,	O
buf	pointer
)	O
;	O
if	O
(	O
!	O
strncmp	function
(	O
"gpg: Can't check signature: Public key not found"	pointer
,	O
buf	pointer
,	O
48	int
)	O
)	O
{	O
res	int
=	O
RPMSIG_NOKEY	int
;	O
}	O
}	O
fclose	function
(	O
file	pointer
)	O
;	O
(	O
void	O
)	O
waitpid	function
(	O
pid	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
unlink	function
(	O
sigfile	array
)	O
;	O
if	O
(	O
!	O
res	int
&&	O
(	O
!	O
WIFEXITED	O
(	O
status	int
)	O
||	O
WEXITSTATUS	O
(	O
status	int
)	O
)	O
)	O
{	O
res	int
=	O
RPMSIG_BAD	int
;	O
}	O
return	O
res	int
;	O
}	O
static	O
int	O
checkPassPhrase	function
(	O
const	O
char	O
*	O
passPhrase	pointer
,	O
const	O
int	O
sigTag	int
)	O
{	O
int	O
passPhrasePipe	array
[	O
2	int
]	O
;	O
int	O
pid	int
,	O
status	int
;	O
int	O
fd	pointer
;	O
passPhrasePipe	array
[	O
0	int
]	O
=	O
passPhrasePipe	array
[	O
1	int
]	O
=	O
0	int
;	O
pipe	function
(	O
passPhrasePipe	array
)	O
;	O
if	O
(	O
!	O
(	O
pid	int
=	O
fork	function
(	O
)	O
)	O
)	O
{	O
close	pointer
(	O
STDIN_FILENO	int
)	O
;	O
close	pointer
(	O
STDOUT_FILENO	int
)	O
;	O
close	pointer
(	O
passPhrasePipe	array
[	O
1	int
]	O
)	O
;	O
if	O
(	O
!	O
rpmIsVerbose	function
(	O
)	O
)	O
{	O
close	pointer
(	O
STDERR_FILENO	int
)	O
;	O
}	O
if	O
(	O
(	O
fd	pointer
=	O
open	function
(	O
"/dev/null"	pointer
,	O
O_RDONLY	int
)	O
)	O
!=	O
STDIN_FILENO	int
)	O
{	O
dup2	function
(	O
fd	pointer
,	O
STDIN_FILENO	int
)	O
;	O
close	pointer
(	O
fd	pointer
)	O
;	O
}	O
if	O
(	O
(	O
fd	pointer
=	O
open	function
(	O
"/dev/null"	pointer
,	O
O_WRONLY	int
)	O
)	O
!=	O
STDOUT_FILENO	int
)	O
{	O
dup2	function
(	O
fd	pointer
,	O
STDOUT_FILENO	int
)	O
;	O
close	pointer
(	O
fd	pointer
)	O
;	O
}	O
dup2	function
(	O
passPhrasePipe	array
[	O
0	int
]	O
,	O
3	int
)	O
;	O
switch	O
(	O
sigTag	int
)	O
{	O
case	O
RPMSIGTAG_GPG	int
:	O
{	O
const	O
char	O
*	O
gpg_path	pointer
=	O
rpmExpand	function
(	O
"%{_gpg_path}"	pointer
,	O
NULL	O
)	O
;	O
const	O
char	O
*	O
name	pointer
=	O
rpmExpand	function
(	O
"%{_gpg_name}"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
gpg_path	pointer
&&	O
*	O
gpg_path	pointer
!=	O
'%'	O
)	O
dosetenv	function
(	O
"GNUPGHOME"	pointer
,	O
gpg_path	pointer
,	O
1	int
)	O
;	O
execlp	function
(	O
"gpg"	pointer
,	O
"gpg"	pointer
,	O
"--batch"	pointer
,	O
"--no-verbose"	pointer
,	O
"--passphrase-fd"	pointer
,	O
"3"	pointer
,	O
"-u"	pointer
,	O
name	pointer
,	O
"-so"	pointer
,	O
"-"	pointer
,	O
NULL	O
)	O
;	O
rpmError	function
(	O
RPMERR_EXEC	O
,	O
_	O
(	O
"Couldn't exec gpg"	pointer
)	O
)	O
;	O
_exit	function
(	O
RPMERR_EXEC	O
)	O
;	O
}	O
break	O
;	O
case	O
RPMSIGTAG_PGP5	int
:	O
case	O
RPMSIGTAG_PGP	int
:	O
{	O
const	O
char	O
*	O
pgp_path	pointer
=	O
rpmExpand	function
(	O
"%{_pgp_path}"	pointer
,	O
NULL	O
)	O
;	O
const	O
char	O
*	O
name	pointer
=	O
rpmExpand	function
(	O
"+myname=\"%{_pgp_name}\""	pointer
,	O
NULL	O
)	O
;	O
const	O
char	O
*	O
path	pointer
;	O
pgpVersion	enum
pgpVer	pointer
;	O
dosetenv	function
(	O
"PGPPASSFD"	pointer
,	O
"3"	pointer
,	O
1	int
)	O
;	O
if	O
(	O
pgp_path	pointer
&&	O
*	O
pgp_path	pointer
!=	O
'%'	O
)	O
dosetenv	function
(	O
"PGPPATH"	pointer
,	O
pgp_path	pointer
,	O
1	int
)	O
;	O
if	O
(	O
(	O
path	pointer
=	O
rpmDetectPGPVersion	function
(	O
&	O
pgpVer	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
switch	O
(	O
pgpVer	pointer
)	O
{	O
case	O
PGP_2	int
:	O
execlp	function
(	O
path	pointer
,	O
"pgp"	pointer
,	O
"+batchmode=on"	pointer
,	O
"+verbose=0"	pointer
,	O
name	pointer
,	O
"-sf"	pointer
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
PGP_5	int
:	O
execlp	function
(	O
path	pointer
,	O
"pgps"	pointer
,	O
"+batchmode=on"	pointer
,	O
"+verbose=0"	pointer
,	O
name	pointer
,	O
"-f"	pointer
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
PGP_UNKNOWN	int
:	O
case	O
PGP_NOTDETECTED	int
:	O
break	O
;	O
}	O
}	O
rpmError	function
(	O
RPMERR_EXEC	O
,	O
_	O
(	O
"Couldn't exec pgp"	pointer
)	O
)	O
;	O
_exit	function
(	O
RPMERR_EXEC	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
rpmError	function
(	O
RPMERR_SIGGEN	O
,	O
_	O
(	O
"Invalid %%_signature spec in macro file"	pointer
)	O
)	O
;	O
_exit	function
(	O
RPMERR_SIGGEN	O
)	O
;	O
break	O
;	O
}	O
}	O
close	pointer
(	O
passPhrasePipe	array
[	O
0	int
]	O
)	O
;	O
(	O
void	O
)	O
write	pointer
(	O
passPhrasePipe	array
[	O
1	int
]	O
,	O
passPhrase	pointer
,	O
strlen	function
(	O
passPhrase	pointer
)	O
)	O
;	O
(	O
void	O
)	O
write	pointer
(	O
passPhrasePipe	array
[	O
1	int
]	O
,	O
"\n"	pointer
,	O
1	int
)	O
;	O
close	pointer
(	O
passPhrasePipe	array
[	O
1	int
]	O
)	O
;	O
(	O
void	O
)	O
waitpid	function
(	O
pid	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
if	O
(	O
!	O
WIFEXITED	O
(	O
status	int
)	O
||	O
WEXITSTATUS	O
(	O
status	int
)	O
)	O
{	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
char	O
*	O
rpmGetPassPhrase	function
(	O
const	O
char	O
*	O
prompt	pointer
,	O
const	O
int	O
sigTag	int
)	O
{	O
char	O
*	O
pass	pointer
;	O
int	O
aok	int
;	O
switch	O
(	O
sigTag	int
)	O
{	O
case	O
RPMSIGTAG_GPG	int
:	O
{	O
const	O
char	O
*	O
name	pointer
=	O
rpmExpand	function
(	O
"%{_gpg_name}"	pointer
,	O
NULL	O
)	O
;	O
aok	int
=	O
(	O
name	pointer
&&	O
*	O
name	pointer
!=	O
'%'	O
)	O
;	O
xfree	O
(	O
name	pointer
)	O
;	O
}	O
if	O
(	O
!	O
aok	int
)	O
{	O
rpmError	function
(	O
RPMERR_SIGGEN	O
,	O
_	O
(	O
"You must set \"%%_gpg_name\" in your macro file"	pointer
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
break	O
;	O
case	O
RPMSIGTAG_PGP5	int
:	O
case	O
RPMSIGTAG_PGP	int
:	O
{	O
const	O
char	O
*	O
name	pointer
=	O
rpmExpand	function
(	O
"%{_pgp_name}"	pointer
,	O
NULL	O
)	O
;	O
aok	int
=	O
(	O
name	pointer
&&	O
*	O
name	pointer
!=	O
'%'	O
)	O
;	O
xfree	O
(	O
name	pointer
)	O
;	O
}	O
if	O
(	O
!	O
aok	int
)	O
{	O
rpmError	function
(	O
RPMERR_SIGGEN	O
,	O
_	O
(	O
"You must set \"%%_pgp_name\" in your macro file"	pointer
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
break	O
;	O
default	O
:	O
rpmError	function
(	O
RPMERR_SIGGEN	O
,	O
_	O
(	O
"Invalid %%_signature spec in macro file"	pointer
)	O
)	O
;	O
return	O
NULL	O
;	O
break	O
;	O
}	O
pass	pointer
=	O
getpass	function
(	O
(	O
prompt	pointer
?	O
prompt	pointer
:	O
""	pointer
)	O
)	O
;	O
if	O
(	O
checkPassPhrase	function
(	O
pass	pointer
,	O
sigTag	int
)	O
)	O
return	O
NULL	O
;	O
return	O
pass	pointer
;	O
}	O
int	O
rpmVerifySignature	function
(	O
const	O
char	O
*	O
file	pointer
,	O
int_32	int
sigTag	int
,	O
void	O
*	O
sig	pointer
,	O
int	O
count	long
,	O
char	O
*	O
result	pointer
)	O
{	O
switch	O
(	O
sigTag	int
)	O
{	O
case	O
RPMSIGTAG_SIZE	int
:	O
if	O
(	O
verifySizeSignature	function
(	O
file	pointer
,	O
*	O
(	O
int_32	int
*	O
)	O
sig	pointer
,	O
result	pointer
)	O
)	O
{	O
return	O
RPMSIG_BAD	int
;	O
}	O
break	O
;	O
case	O
RPMSIGTAG_MD5	int
:	O
if	O
(	O
verifyMD5Signature	function
(	O
file	pointer
,	O
sig	pointer
,	O
result	pointer
,	O
mdbinfile	function
)	O
)	O
{	O
return	O
1	int
;	O
}	O
break	O
;	O
case	O
RPMSIGTAG_LEMD5_1	int
:	O
case	O
RPMSIGTAG_LEMD5_2	int
:	O
if	O
(	O
verifyMD5Signature	function
(	O
file	pointer
,	O
sig	pointer
,	O
result	pointer
,	O
mdbinfileBroken	function
)	O
)	O
{	O
return	O
1	int
;	O
}	O
break	O
;	O
case	O
RPMSIGTAG_PGP5	int
:	O
case	O
RPMSIGTAG_PGP	int
:	O
return	O
verifyPGPSignature	function
(	O
file	pointer
,	O
sig	pointer
,	O
count	long
,	O
result	pointer
)	O
;	O
break	O
;	O
case	O
RPMSIGTAG_GPG	int
:	O
return	O
verifyGPGSignature	function
(	O
file	pointer
,	O
sig	pointer
,	O
count	long
,	O
result	pointer
)	O
;	O
break	O
;	O
default	O
:	O
sprintf	function
(	O
result	pointer
,	O
"Do not know how to verify sig type %d\n"	pointer
,	O
sigTag	int
)	O
;	O
return	O
RPMSIG_UNKNOWN	int
;	O
}	O
return	O
RPMSIG_OK	int
;	O
}	O
