static	O
void	O
gdImageBrushApply	function
(	O
gdImagePtr	pointer
im	pointer
,	O
int	O
x	int
,	O
int	O
y	int
)	O
;	O
static	O
void	O
gdImageTileApply	function
(	O
gdImagePtr	pointer
im	pointer
,	O
int	O
x	int
,	O
int	O
y	int
)	O
;	O
gdImagePtr	pointer
gdImageCreate	function
(	O
int	O
sx	int
,	O
int	O
sy	int
)	O
{	O
int	O
i	int
;	O
gdImagePtr	pointer
im	pointer
;	O
im	pointer
=	O
(	O
gdImage	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
gdImage	struct
)	O
)	O
;	O
im	pointer
->	O
pixels	pointer
=	O
(	O
unsigned	O
char	O
*	O
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
unsigned	O
char	O
*	O
)	O
*	O
sy	int
)	O
;	O
im	pointer
->	O
polyInts	pointer
=	O
0	int
;	O
im	pointer
->	O
polyAllocated	int
=	O
0	int
;	O
im	pointer
->	O
brush	pointer
=	O
0	int
;	O
im	pointer
->	O
tile	pointer
=	O
0	int
;	O
im	pointer
->	O
style	pointer
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
i	int
<	O
sy	int
)	O
;	O
i	int
++	O
)	O
{	O
im	pointer
->	O
pixels	pointer
[	O
i	int
]	O
=	O
(	O
unsigned	O
char	O
*	O
)	O
calloc	function
(	O
sx	int
,	O
sizeof	O
(	O
unsigned	O
char	O
)	O
)	O
;	O
}	O
im	pointer
->	O
sx	int
=	O
sx	int
;	O
im	pointer
->	O
sy	int
=	O
sy	int
;	O
im	pointer
->	O
colorsTotal	int
=	O
0	int
;	O
im	pointer
->	O
transparent	int
=	O
(	O
-	O
1	int
)	O
;	O
im	pointer
->	O
interlace	int
=	O
0	int
;	O
return	O
im	pointer
;	O
}	O
void	O
gdImageDestroy	function
(	O
gdImagePtr	pointer
im	pointer
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
i	int
<	O
im	pointer
->	O
sy	int
)	O
;	O
i	int
++	O
)	O
{	O
free	function
(	O
im	pointer
->	O
pixels	pointer
[	O
i	int
]	O
)	O
;	O
}	O
free	function
(	O
im	pointer
->	O
pixels	pointer
)	O
;	O
if	O
(	O
im	pointer
->	O
polyInts	pointer
)	O
{	O
free	function
(	O
im	pointer
->	O
polyInts	pointer
)	O
;	O
}	O
if	O
(	O
im	pointer
->	O
style	pointer
)	O
{	O
free	function
(	O
im	pointer
->	O
style	pointer
)	O
;	O
}	O
free	function
(	O
im	pointer
)	O
;	O
}	O
int	O
gdImageColorClosest	function
(	O
gdImagePtr	pointer
im	pointer
,	O
int	O
r	int
,	O
int	O
g	int
,	O
int	O
b	int
)	O
{	O
int	O
i	int
;	O
long	O
rd	long
,	O
gd	long
,	O
bd	long
;	O
int	O
ct	int
=	O
(	O
-	O
1	int
)	O
;	O
long	O
mindist	long
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
i	int
<	O
(	O
im	pointer
->	O
colorsTotal	int
)	O
)	O
;	O
i	int
++	O
)	O
{	O
long	O
dist	long
;	O
if	O
(	O
im	pointer
->	O
open	array
[	O
i	int
]	O
)	O
{	O
continue	O
;	O
}	O
rd	long
=	O
(	O
im	pointer
->	O
red	array
[	O
i	int
]	O
-	O
r	int
)	O
;	O
gd	long
=	O
(	O
im	pointer
->	O
green	array
[	O
i	int
]	O
-	O
g	int
)	O
;	O
bd	long
=	O
(	O
im	pointer
->	O
blue	array
[	O
i	int
]	O
-	O
b	int
)	O
;	O
dist	long
=	O
rd	long
*	O
rd	long
+	O
gd	long
*	O
gd	long
+	O
bd	long
*	O
bd	long
;	O
if	O
(	O
(	O
i	int
==	O
0	int
)	O
||	O
(	O
dist	long
<	O
mindist	long
)	O
)	O
{	O
mindist	long
=	O
dist	long
;	O
ct	int
=	O
i	int
;	O
}	O
}	O
return	O
ct	int
;	O
}	O
int	O
gdImageColorExact	function
(	O
gdImagePtr	pointer
im	pointer
,	O
int	O
r	int
,	O
int	O
g	int
,	O
int	O
b	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
i	int
<	O
(	O
im	pointer
->	O
colorsTotal	int
)	O
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
im	pointer
->	O
open	array
[	O
i	int
]	O
)	O
{	O
continue	O
;	O
}	O
if	O
(	O
(	O
im	pointer
->	O
red	array
[	O
i	int
]	O
==	O
r	int
)	O
&&	O
(	O
im	pointer
->	O
green	array
[	O
i	int
]	O
==	O
g	int
)	O
&&	O
(	O
im	pointer
->	O
blue	array
[	O
i	int
]	O
==	O
b	int
)	O
)	O
{	O
return	O
i	int
;	O
}	O
}	O
return	O
-	O
1	int
;	O
}	O
int	O
gdImageColorAllocate	function
(	O
gdImagePtr	pointer
im	pointer
,	O
int	O
r	int
,	O
int	O
g	int
,	O
int	O
b	int
)	O
{	O
int	O
i	int
;	O
int	O
ct	int
=	O
(	O
-	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
i	int
<	O
(	O
im	pointer
->	O
colorsTotal	int
)	O
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
im	pointer
->	O
open	array
[	O
i	int
]	O
)	O
{	O
ct	int
=	O
i	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
ct	int
==	O
(	O
-	O
1	int
)	O
)	O
{	O
ct	int
=	O
im	pointer
->	O
colorsTotal	int
;	O
if	O
(	O
ct	int
==	O
gdMaxColors	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
im	pointer
->	O
colorsTotal	int
++	O
;	O
}	O
im	pointer
->	O
red	array
[	O
ct	int
]	O
=	O
r	int
;	O
im	pointer
->	O
green	array
[	O
ct	int
]	O
=	O
g	int
;	O
im	pointer
->	O
blue	array
[	O
ct	int
]	O
=	O
b	int
;	O
im	pointer
->	O
open	array
[	O
ct	int
]	O
=	O
0	int
;	O
return	O
ct	int
;	O
}	O
void	O
gdImageColorDeallocate	function
(	O
gdImagePtr	pointer
im	pointer
,	O
int	O
color	int
)	O
{	O
im	pointer
->	O
open	array
[	O
color	int
]	O
=	O
1	int
;	O
}	O
void	O
gdImageColorTransparent	function
(	O
gdImagePtr	pointer
im	pointer
,	O
int	O
color	int
)	O
{	O
im	pointer
->	O
transparent	int
=	O
color	int
;	O
}	O
void	O
gdImageSetPixel	function
(	O
gdImagePtr	pointer
im	pointer
,	O
int	O
x	int
,	O
int	O
y	int
,	O
int	O
color	int
)	O
{	O
int	O
p	pointer
;	O
switch	O
(	O
color	int
)	O
{	O
case	O
gdStyled	O
:	O
if	O
(	O
!	O
im	pointer
->	O
style	pointer
)	O
{	O
return	O
;	O
}	O
else	O
{	O
p	pointer
=	O
im	pointer
->	O
style	pointer
[	O
im	pointer
->	O
stylePos	int
++	O
]	O
;	O
}	O
if	O
(	O
p	pointer
!=	O
(	O
gdTransparent	O
)	O
)	O
{	O
gdImageSetPixel	function
(	O
im	pointer
,	O
x	int
,	O
y	int
,	O
p	pointer
)	O
;	O
}	O
im	pointer
->	O
stylePos	int
=	O
im	pointer
->	O
stylePos	int
%	O
im	pointer
->	O
styleLength	int
;	O
break	O
;	O
case	O
gdStyledBrushed	O
:	O
if	O
(	O
!	O
im	pointer
->	O
style	pointer
)	O
{	O
return	O
;	O
}	O
p	pointer
=	O
im	pointer
->	O
style	pointer
[	O
im	pointer
->	O
stylePos	int
++	O
]	O
;	O
if	O
(	O
(	O
p	pointer
!=	O
gdTransparent	O
)	O
&&	O
(	O
p	pointer
!=	O
0	int
)	O
)	O
{	O
gdImageSetPixel	function
(	O
im	pointer
,	O
x	int
,	O
y	int
,	O
gdBrushed	O
)	O
;	O
}	O
im	pointer
->	O
stylePos	int
=	O
im	pointer
->	O
stylePos	int
%	O
im	pointer
->	O
styleLength	int
;	O
break	O
;	O
case	O
gdBrushed	O
:	O
gdImageBrushApply	function
(	O
im	pointer
,	O
x	int
,	O
y	int
)	O
;	O
break	O
;	O
case	O
gdTiled	O
:	O
gdImageTileApply	function
(	O
im	pointer
,	O
x	int
,	O
y	int
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
gdImageBoundsSafe	function
(	O
im	pointer
,	O
x	int
,	O
y	int
)	O
)	O
{	O
im	pointer
->	O
pixels	pointer
[	O
y	int
]	O
[	O
x	int
]	O
=	O
color	int
;	O
}	O
break	O
;	O
}	O
}	O
static	O
void	O
gdImageBrushApply	function
(	O
gdImagePtr	pointer
im	pointer
,	O
int	O
x	int
,	O
int	O
y	int
)	O
{	O
int	O
lx	int
,	O
ly	int
;	O
int	O
hy	int
;	O
int	O
hx	int
;	O
int	O
x1	int
,	O
y1	function
,	O
x2	int
,	O
y2	int
;	O
int	O
srcx	int
,	O
srcy	int
;	O
if	O
(	O
!	O
im	pointer
->	O
brush	pointer
)	O
{	O
return	O
;	O
}	O
hy	int
=	O
gdImageSY	O
(	O
im	pointer
->	O
brush	pointer
)	O
/	O
2	int
;	O
y1	function
=	O
y	int
-	O
hy	int
;	O
y2	int
=	O
y1	function
+	O
gdImageSY	O
(	O
im	pointer
->	O
brush	pointer
)	O
;	O
hx	int
=	O
gdImageSX	O
(	O
im	pointer
->	O
brush	pointer
)	O
/	O
2	int
;	O
x1	int
=	O
x	int
-	O
hx	int
;	O
x2	int
=	O
x1	int
+	O
gdImageSX	O
(	O
im	pointer
->	O
brush	pointer
)	O
;	O
srcy	int
=	O
0	int
;	O
for	O
(	O
ly	int
=	O
y1	function
;	O
(	O
ly	int
<	O
y2	int
)	O
;	O
ly	int
++	O
)	O
{	O
srcx	int
=	O
0	int
;	O
for	O
(	O
lx	int
=	O
x1	int
;	O
(	O
lx	int
<	O
x2	int
)	O
;	O
lx	int
++	O
)	O
{	O
int	O
p	pointer
;	O
p	pointer
=	O
gdImageGetPixel	function
(	O
im	pointer
->	O
brush	pointer
,	O
srcx	int
,	O
srcy	int
)	O
;	O
if	O
(	O
p	pointer
!=	O
gdImageGetTransparent	O
(	O
im	pointer
->	O
brush	pointer
)	O
)	O
{	O
gdImageSetPixel	function
(	O
im	pointer
,	O
lx	int
,	O
ly	int
,	O
im	pointer
->	O
brushColorMap	array
[	O
p	pointer
]	O
)	O
;	O
}	O
srcx	int
++	O
;	O
}	O
srcy	int
++	O
;	O
}	O
}	O
static	O
void	O
gdImageTileApply	function
(	O
gdImagePtr	pointer
im	pointer
,	O
int	O
x	int
,	O
int	O
y	int
)	O
{	O
int	O
srcx	int
,	O
srcy	int
;	O
int	O
p	pointer
;	O
if	O
(	O
!	O
im	pointer
->	O
tile	pointer
)	O
{	O
return	O
;	O
}	O
srcx	int
=	O
x	int
%	O
gdImageSX	O
(	O
im	pointer
->	O
tile	pointer
)	O
;	O
srcy	int
=	O
y	int
%	O
gdImageSY	O
(	O
im	pointer
->	O
tile	pointer
)	O
;	O
p	pointer
=	O
gdImageGetPixel	function
(	O
im	pointer
->	O
tile	pointer
,	O
srcx	int
,	O
srcy	int
)	O
;	O
if	O
(	O
p	pointer
!=	O
gdImageGetTransparent	O
(	O
im	pointer
->	O
tile	pointer
)	O
)	O
{	O
gdImageSetPixel	function
(	O
im	pointer
,	O
x	int
,	O
y	int
,	O
im	pointer
->	O
tileColorMap	array
[	O
p	pointer
]	O
)	O
;	O
}	O
}	O
int	O
gdImageGetPixel	function
(	O
gdImagePtr	pointer
im	pointer
,	O
int	O
x	int
,	O
int	O
y	int
)	O
{	O
if	O
(	O
gdImageBoundsSafe	function
(	O
im	pointer
,	O
x	int
,	O
y	int
)	O
)	O
{	O
return	O
im	pointer
->	O
pixels	pointer
[	O
y	int
]	O
[	O
x	int
]	O
;	O
}	O
else	O
{	O
return	O
0	int
;	O
}	O
}	O
void	O
gdImageLine	function
(	O
gdImagePtr	pointer
im	pointer
,	O
int	O
x1	int
,	O
int	O
y1	function
,	O
int	O
x2	int
,	O
int	O
y2	int
,	O
int	O
color	int
)	O
{	O
int	O
dx	int
,	O
dy	int
,	O
incr1	int
,	O
incr2	int
,	O
d	int
,	O
x	int
,	O
y	int
,	O
xend	int
,	O
yend	int
,	O
xdirflag	int
,	O
ydirflag	int
;	O
dx	int
=	O
abs	function
(	O
x2	int
-	O
x1	int
)	O
;	O
dy	int
=	O
abs	function
(	O
y2	int
-	O
y1	function
)	O
;	O
if	O
(	O
dy	int
<=	O
dx	int
)	O
{	O
d	int
=	O
2	int
*	O
dy	int
-	O
dx	int
;	O
incr1	int
=	O
2	int
*	O
dy	int
;	O
incr2	int
=	O
2	int
*	O
(	O
dy	int
-	O
dx	int
)	O
;	O
if	O
(	O
x1	int
>	O
x2	int
)	O
{	O
x	int
=	O
x2	int
;	O
y	int
=	O
y2	int
;	O
ydirflag	int
=	O
(	O
-	O
1	int
)	O
;	O
xend	int
=	O
x1	int
;	O
}	O
else	O
{	O
x	int
=	O
x1	int
;	O
y	int
=	O
y1	function
;	O
ydirflag	int
=	O
1	int
;	O
xend	int
=	O
x2	int
;	O
}	O
gdImageSetPixel	function
(	O
im	pointer
,	O
x	int
,	O
y	int
,	O
color	int
)	O
;	O
if	O
(	O
(	O
(	O
y2	int
-	O
y1	function
)	O
*	O
ydirflag	int
)	O
>	O
0	int
)	O
{	O
while	O
(	O
x	int
<	O
xend	int
)	O
{	O
x	int
++	O
;	O
if	O
(	O
d	int
<	O
0	int
)	O
{	O
d	int
+=	O
incr1	int
;	O
}	O
else	O
{	O
y	int
++	O
;	O
d	int
+=	O
incr2	int
;	O
}	O
gdImageSetPixel	function
(	O
im	pointer
,	O
x	int
,	O
y	int
,	O
color	int
)	O
;	O
}	O
}	O
else	O
{	O
while	O
(	O
x	int
<	O
xend	int
)	O
{	O
x	int
++	O
;	O
if	O
(	O
d	int
<	O
0	int
)	O
{	O
d	int
+=	O
incr1	int
;	O
}	O
else	O
{	O
y	int
--	O
;	O
d	int
+=	O
incr2	int
;	O
}	O
gdImageSetPixel	function
(	O
im	pointer
,	O
x	int
,	O
y	int
,	O
color	int
)	O
;	O
}	O
}	O
}	O
else	O
{	O
d	int
=	O
2	int
*	O
dx	int
-	O
dy	int
;	O
incr1	int
=	O
2	int
*	O
dx	int
;	O
incr2	int
=	O
2	int
*	O
(	O
dx	int
-	O
dy	int
)	O
;	O
if	O
(	O
y1	function
>	O
y2	int
)	O
{	O
y	int
=	O
y2	int
;	O
x	int
=	O
x2	int
;	O
yend	int
=	O
y1	function
;	O
xdirflag	int
=	O
(	O
-	O
1	int
)	O
;	O
}	O
else	O
{	O
y	int
=	O
y1	function
;	O
x	int
=	O
x1	int
;	O
yend	int
=	O
y2	int
;	O
xdirflag	int
=	O
1	int
;	O
}	O
gdImageSetPixel	function
(	O
im	pointer
,	O
x	int
,	O
y	int
,	O
color	int
)	O
;	O
if	O
(	O
(	O
(	O
x2	int
-	O
x1	int
)	O
*	O
xdirflag	int
)	O
>	O
0	int
)	O
{	O
while	O
(	O
y	int
<	O
yend	int
)	O
{	O
y	int
++	O
;	O
if	O
(	O
d	int
<	O
0	int
)	O
{	O
d	int
+=	O
incr1	int
;	O
}	O
else	O
{	O
x	int
++	O
;	O
d	int
+=	O
incr2	int
;	O
}	O
gdImageSetPixel	function
(	O
im	pointer
,	O
x	int
,	O
y	int
,	O
color	int
)	O
;	O
}	O
}	O
else	O
{	O
while	O
(	O
y	int
<	O
yend	int
)	O
{	O
y	int
++	O
;	O
if	O
(	O
d	int
<	O
0	int
)	O
{	O
d	int
+=	O
incr1	int
;	O
}	O
else	O
{	O
x	int
--	O
;	O
d	int
+=	O
incr2	int
;	O
}	O
gdImageSetPixel	function
(	O
im	pointer
,	O
x	int
,	O
y	int
,	O
color	int
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
dashedSet	function
(	O
gdImagePtr	pointer
im	pointer
,	O
int	O
x	int
,	O
int	O
y	int
,	O
int	O
color	int
,	O
int	O
*	O
onP	pointer
,	O
int	O
*	O
dashStepP	pointer
)	O
;	O
void	O
gdImageDashedLine	function
(	O
gdImagePtr	pointer
im	pointer
,	O
int	O
x1	int
,	O
int	O
y1	function
,	O
int	O
x2	int
,	O
int	O
y2	int
,	O
int	O
color	int
)	O
{	O
int	O
dx	int
,	O
dy	int
,	O
incr1	int
,	O
incr2	int
,	O
d	int
,	O
x	int
,	O
y	int
,	O
xend	int
,	O
yend	int
,	O
xdirflag	int
,	O
ydirflag	int
;	O
int	O
dashStep	int
=	O
0	int
;	O
int	O
on	int
=	O
1	int
;	O
dx	int
=	O
abs	function
(	O
x2	int
-	O
x1	int
)	O
;	O
dy	int
=	O
abs	function
(	O
y2	int
-	O
y1	function
)	O
;	O
if	O
(	O
dy	int
<=	O
dx	int
)	O
{	O
d	int
=	O
2	int
*	O
dy	int
-	O
dx	int
;	O
incr1	int
=	O
2	int
*	O
dy	int
;	O
incr2	int
=	O
2	int
*	O
(	O
dy	int
-	O
dx	int
)	O
;	O
if	O
(	O
x1	int
>	O
x2	int
)	O
{	O
x	int
=	O
x2	int
;	O
y	int
=	O
y2	int
;	O
ydirflag	int
=	O
(	O
-	O
1	int
)	O
;	O
xend	int
=	O
x1	int
;	O
}	O
else	O
{	O
x	int
=	O
x1	int
;	O
y	int
=	O
y1	function
;	O
ydirflag	int
=	O
1	int
;	O
xend	int
=	O
x2	int
;	O
}	O
dashedSet	function
(	O
im	pointer
,	O
x	int
,	O
y	int
,	O
color	int
,	O
&	O
on	int
,	O
&	O
dashStep	int
)	O
;	O
if	O
(	O
(	O
(	O
y2	int
-	O
y1	function
)	O
*	O
ydirflag	int
)	O
>	O
0	int
)	O
{	O
while	O
(	O
x	int
<	O
xend	int
)	O
{	O
x	int
++	O
;	O
if	O
(	O
d	int
<	O
0	int
)	O
{	O
d	int
+=	O
incr1	int
;	O
}	O
else	O
{	O
y	int
++	O
;	O
d	int
+=	O
incr2	int
;	O
}	O
dashedSet	function
(	O
im	pointer
,	O
x	int
,	O
y	int
,	O
color	int
,	O
&	O
on	int
,	O
&	O
dashStep	int
)	O
;	O
}	O
}	O
else	O
{	O
while	O
(	O
x	int
<	O
xend	int
)	O
{	O
x	int
++	O
;	O
if	O
(	O
d	int
<	O
0	int
)	O
{	O
d	int
+=	O
incr1	int
;	O
}	O
else	O
{	O
y	int
--	O
;	O
d	int
+=	O
incr2	int
;	O
}	O
dashedSet	function
(	O
im	pointer
,	O
x	int
,	O
y	int
,	O
color	int
,	O
&	O
on	int
,	O
&	O
dashStep	int
)	O
;	O
}	O
}	O
}	O
else	O
{	O
d	int
=	O
2	int
*	O
dx	int
-	O
dy	int
;	O
incr1	int
=	O
2	int
*	O
dx	int
;	O
incr2	int
=	O
2	int
*	O
(	O
dx	int
-	O
dy	int
)	O
;	O
if	O
(	O
y1	function
>	O
y2	int
)	O
{	O
y	int
=	O
y2	int
;	O
x	int
=	O
x2	int
;	O
yend	int
=	O
y1	function
;	O
xdirflag	int
=	O
(	O
-	O
1	int
)	O
;	O
}	O
else	O
{	O
y	int
=	O
y1	function
;	O
x	int
=	O
x1	int
;	O
yend	int
=	O
y2	int
;	O
xdirflag	int
=	O
1	int
;	O
}	O
dashedSet	function
(	O
im	pointer
,	O
x	int
,	O
y	int
,	O
color	int
,	O
&	O
on	int
,	O
&	O
dashStep	int
)	O
;	O
if	O
(	O
(	O
(	O
x2	int
-	O
x1	int
)	O
*	O
xdirflag	int
)	O
>	O
0	int
)	O
{	O
while	O
(	O
y	int
<	O
yend	int
)	O
{	O
y	int
++	O
;	O
if	O
(	O
d	int
<	O
0	int
)	O
{	O
d	int
+=	O
incr1	int
;	O
}	O
else	O
{	O
x	int
++	O
;	O
d	int
+=	O
incr2	int
;	O
}	O
dashedSet	function
(	O
im	pointer
,	O
x	int
,	O
y	int
,	O
color	int
,	O
&	O
on	int
,	O
&	O
dashStep	int
)	O
;	O
}	O
}	O
else	O
{	O
while	O
(	O
y	int
<	O
yend	int
)	O
{	O
y	int
++	O
;	O
if	O
(	O
d	int
<	O
0	int
)	O
{	O
d	int
+=	O
incr1	int
;	O
}	O
else	O
{	O
x	int
--	O
;	O
d	int
+=	O
incr2	int
;	O
}	O
dashedSet	function
(	O
im	pointer
,	O
x	int
,	O
y	int
,	O
color	int
,	O
&	O
on	int
,	O
&	O
dashStep	int
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
dashedSet	function
(	O
gdImagePtr	pointer
im	pointer
,	O
int	O
x	int
,	O
int	O
y	int
,	O
int	O
color	int
,	O
int	O
*	O
onP	pointer
,	O
int	O
*	O
dashStepP	pointer
)	O
{	O
int	O
dashStep	int
=	O
*	O
dashStepP	pointer
;	O
int	O
on	int
=	O
*	O
onP	pointer
;	O
dashStep	int
++	O
;	O
if	O
(	O
dashStep	int
==	O
gdDashSize	int
)	O
{	O
dashStep	int
=	O
0	int
;	O
on	int
=	O
!	O
on	int
;	O
}	O
if	O
(	O
on	int
)	O
{	O
gdImageSetPixel	function
(	O
im	pointer
,	O
x	int
,	O
y	int
,	O
color	int
)	O
;	O
}	O
*	O
dashStepP	pointer
=	O
dashStep	int
;	O
*	O
onP	pointer
=	O
on	int
;	O
}	O
int	O
gdImageBoundsSafe	function
(	O
gdImagePtr	pointer
im	pointer
,	O
int	O
x	int
,	O
int	O
y	int
)	O
{	O
return	O
(	O
!	O
(	O
(	O
(	O
y	int
<	O
0	int
)	O
||	O
(	O
y	int
>=	O
im	pointer
->	O
sy	int
)	O
)	O
||	O
(	O
(	O
x	int
<	O
0	int
)	O
||	O
(	O
x	int
>=	O
im	pointer
->	O
sx	int
)	O
)	O
)	O
)	O
;	O
}	O
void	O
gdImageChar	function
(	O
gdImagePtr	pointer
im	pointer
,	O
gdFontPtr	pointer
f	pointer
,	O
int	O
x	int
,	O
int	O
y	int
,	O
int	O
c	int
,	O
int	O
color	int
)	O
{	O
int	O
cx	int
,	O
cy	int
;	O
int	O
px	int
,	O
py	int
;	O
int	O
fline	int
;	O
cx	int
=	O
0	int
;	O
cy	int
=	O
0	int
;	O
if	O
(	O
(	O
c	int
<	O
f	pointer
->	O
offset	int
)	O
||	O
(	O
c	int
>=	O
(	O
f	pointer
->	O
offset	int
+	O
f	pointer
->	O
nchars	int
)	O
)	O
)	O
{	O
return	O
;	O
}	O
fline	int
=	O
(	O
c	int
-	O
f	pointer
->	O
offset	int
)	O
*	O
f	pointer
->	O
h	int
*	O
f	pointer
->	O
w	int
;	O
for	O
(	O
py	int
=	O
y	int
;	O
(	O
py	int
<	O
(	O
y	int
+	O
f	pointer
->	O
h	int
)	O
)	O
;	O
py	int
++	O
)	O
{	O
for	O
(	O
px	int
=	O
x	int
;	O
(	O
px	int
<	O
(	O
x	int
+	O
f	pointer
->	O
w	int
)	O
)	O
;	O
px	int
++	O
)	O
{	O
if	O
(	O
f	pointer
->	O
data	pointer
[	O
fline	int
+	O
cy	int
*	O
f	pointer
->	O
w	int
+	O
cx	int
]	O
)	O
{	O
gdImageSetPixel	function
(	O
im	pointer
,	O
px	int
,	O
py	int
,	O
color	int
)	O
;	O
}	O
cx	int
++	O
;	O
}	O
cx	int
=	O
0	int
;	O
cy	int
++	O
;	O
}	O
}	O
void	O
gdImageCharUp	function
(	O
gdImagePtr	pointer
im	pointer
,	O
gdFontPtr	pointer
f	pointer
,	O
int	O
x	int
,	O
int	O
y	int
,	O
int	O
c	int
,	O
int	O
color	int
)	O
{	O
int	O
cx	int
,	O
cy	int
;	O
int	O
px	int
,	O
py	int
;	O
int	O
fline	int
;	O
cx	int
=	O
0	int
;	O
cy	int
=	O
0	int
;	O
if	O
(	O
(	O
c	int
<	O
f	pointer
->	O
offset	int
)	O
||	O
(	O
c	int
>=	O
(	O
f	pointer
->	O
offset	int
+	O
f	pointer
->	O
nchars	int
)	O
)	O
)	O
{	O
return	O
;	O
}	O
fline	int
=	O
(	O
c	int
-	O
f	pointer
->	O
offset	int
)	O
*	O
f	pointer
->	O
h	int
*	O
f	pointer
->	O
w	int
;	O
for	O
(	O
py	int
=	O
y	int
;	O
(	O
py	int
>	O
(	O
y	int
-	O
f	pointer
->	O
w	int
)	O
)	O
;	O
py	int
--	O
)	O
{	O
for	O
(	O
px	int
=	O
x	int
;	O
(	O
px	int
<	O
(	O
x	int
+	O
f	pointer
->	O
h	int
)	O
)	O
;	O
px	int
++	O
)	O
{	O
if	O
(	O
f	pointer
->	O
data	pointer
[	O
fline	int
+	O
cy	int
*	O
f	pointer
->	O
w	int
+	O
cx	int
]	O
)	O
{	O
gdImageSetPixel	function
(	O
im	pointer
,	O
px	int
,	O
py	int
,	O
color	int
)	O
;	O
}	O
cy	int
++	O
;	O
}	O
cy	int
=	O
0	int
;	O
cx	int
++	O
;	O
}	O
}	O
void	O
gdImageString	function
(	O
gdImagePtr	pointer
im	pointer
,	O
gdFontPtr	pointer
f	pointer
,	O
int	O
x	int
,	O
int	O
y	int
,	O
unsigned	O
char	O
*	O
s	pointer
,	O
int	O
color	int
)	O
{	O
int	O
i	int
;	O
int	O
l	int
;	O
l	int
=	O
strlen	function
(	O
s	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
i	int
<	O
l	int
)	O
;	O
i	int
++	O
)	O
{	O
gdImageChar	function
(	O
im	pointer
,	O
f	pointer
,	O
x	int
,	O
y	int
,	O
s	pointer
[	O
i	int
]	O
,	O
color	int
)	O
;	O
x	int
+=	O
f	pointer
->	O
w	int
;	O
}	O
}	O
void	O
gdImageStringUp	function
(	O
gdImagePtr	pointer
im	pointer
,	O
gdFontPtr	pointer
f	pointer
,	O
int	O
x	int
,	O
int	O
y	int
,	O
unsigned	O
char	O
*	O
s	pointer
,	O
int	O
color	int
)	O
{	O
int	O
i	int
;	O
int	O
l	int
;	O
l	int
=	O
strlen	function
(	O
s	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
i	int
<	O
l	int
)	O
;	O
i	int
++	O
)	O
{	O
gdImageCharUp	function
(	O
im	pointer
,	O
f	pointer
,	O
x	int
,	O
y	int
,	O
s	pointer
[	O
i	int
]	O
,	O
color	int
)	O
;	O
y	int
-=	O
f	pointer
->	O
w	int
;	O
}	O
}	O
static	O
int	O
strlen16	function
(	O
unsigned	O
short	O
*	O
s	pointer
)	O
;	O
void	O
gdImageString16	function
(	O
gdImagePtr	pointer
im	pointer
,	O
gdFontPtr	pointer
f	pointer
,	O
int	O
x	int
,	O
int	O
y	int
,	O
unsigned	O
short	O
*	O
s	pointer
,	O
int	O
color	int
)	O
{	O
int	O
i	int
;	O
int	O
l	int
;	O
l	int
=	O
strlen16	function
(	O
s	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
i	int
<	O
l	int
)	O
;	O
i	int
++	O
)	O
{	O
gdImageChar	function
(	O
im	pointer
,	O
f	pointer
,	O
x	int
,	O
y	int
,	O
s	pointer
[	O
i	int
]	O
,	O
color	int
)	O
;	O
x	int
+=	O
f	pointer
->	O
w	int
;	O
}	O
}	O
void	O
gdImageStringUp16	function
(	O
gdImagePtr	pointer
im	pointer
,	O
gdFontPtr	pointer
f	pointer
,	O
int	O
x	int
,	O
int	O
y	int
,	O
unsigned	O
short	O
*	O
s	pointer
,	O
int	O
color	int
)	O
{	O
int	O
i	int
;	O
int	O
l	int
;	O
l	int
=	O
strlen16	function
(	O
s	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
i	int
<	O
l	int
)	O
;	O
i	int
++	O
)	O
{	O
gdImageCharUp	function
(	O
im	pointer
,	O
f	pointer
,	O
x	int
,	O
y	int
,	O
s	pointer
[	O
i	int
]	O
,	O
color	int
)	O
;	O
y	int
-=	O
f	pointer
->	O
w	int
;	O
}	O
}	O
static	O
int	O
strlen16	function
(	O
unsigned	O
short	O
*	O
s	pointer
)	O
{	O
int	O
len	int
=	O
0	int
;	O
while	O
(	O
*	O
s	pointer
)	O
{	O
s	pointer
++	O
;	O
len	int
++	O
;	O
}	O
return	O
len	int
;	O
}	O
void	O
gdImageArc	function
(	O
gdImagePtr	pointer
im	pointer
,	O
int	O
cx	int
,	O
int	O
cy	int
,	O
int	O
w	int
,	O
int	O
h	int
,	O
int	O
s	pointer
,	O
int	O
e	int
,	O
int	O
color	int
)	O
{	O
int	O
i	int
;	O
int	O
lx	int
=	O
0	int
,	O
ly	int
=	O
0	int
;	O
int	O
w2	int
,	O
h2	int
;	O
w2	int
=	O
w	int
/	O
2	int
;	O
h2	int
=	O
h	int
/	O
2	int
;	O
while	O
(	O
e	int
<	O
s	pointer
)	O
{	O
e	int
+=	O
360	int
;	O
}	O
for	O
(	O
i	int
=	O
s	pointer
;	O
(	O
i	int
<=	O
e	int
)	O
;	O
i	int
++	O
)	O
{	O
int	O
x	int
,	O
y	int
;	O
x	int
=	O
(	O
(	O
long	O
)	O
cost	array
[	O
i	int
%	O
360	int
]	O
*	O
(	O
long	O
)	O
w2	int
/	O
costScale	int
)	O
+	O
cx	int
;	O
y	int
=	O
(	O
(	O
long	O
)	O
sint	array
[	O
i	int
%	O
360	int
]	O
*	O
(	O
long	O
)	O
h2	int
/	O
sintScale	int
)	O
+	O
cy	int
;	O
if	O
(	O
i	int
!=	O
s	pointer
)	O
{	O
gdImageLine	function
(	O
im	pointer
,	O
lx	int
,	O
ly	int
,	O
x	int
,	O
y	int
,	O
color	int
)	O
;	O
}	O
lx	int
=	O
x	int
;	O
ly	int
=	O
y	int
;	O
}	O
}	O
void	O
gdImageFillToBorder	function
(	O
gdImagePtr	pointer
im	pointer
,	O
int	O
x	int
,	O
int	O
y	int
,	O
int	O
border	int
,	O
int	O
color	int
)	O
{	O
int	O
lastBorder	int
;	O
int	O
leftLimit	int
,	O
rightLimit	int
;	O
int	O
i	int
;	O
leftLimit	int
=	O
(	O
-	O
1	int
)	O
;	O
if	O
(	O
border	int
<	O
0	int
)	O
{	O
return	O
;	O
}	O
for	O
(	O
i	int
=	O
x	int
;	O
(	O
i	int
>=	O
0	int
)	O
;	O
i	int
--	O
)	O
{	O
if	O
(	O
gdImageGetPixel	function
(	O
im	pointer
,	O
i	int
,	O
y	int
)	O
==	O
border	int
)	O
{	O
break	O
;	O
}	O
gdImageSetPixel	function
(	O
im	pointer
,	O
i	int
,	O
y	int
,	O
color	int
)	O
;	O
leftLimit	int
=	O
i	int
;	O
}	O
if	O
(	O
leftLimit	int
==	O
(	O
-	O
1	int
)	O
)	O
{	O
return	O
;	O
}	O
rightLimit	int
=	O
x	int
;	O
for	O
(	O
i	int
=	O
(	O
x	int
+	O
1	int
)	O
;	O
(	O
i	int
<	O
im	pointer
->	O
sx	int
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
gdImageGetPixel	function
(	O
im	pointer
,	O
i	int
,	O
y	int
)	O
==	O
border	int
)	O
{	O
break	O
;	O
}	O
gdImageSetPixel	function
(	O
im	pointer
,	O
i	int
,	O
y	int
,	O
color	int
)	O
;	O
rightLimit	int
=	O
i	int
;	O
}	O
if	O
(	O
y	int
>	O
0	int
)	O
{	O
lastBorder	int
=	O
1	int
;	O
for	O
(	O
i	int
=	O
leftLimit	int
;	O
(	O
i	int
<=	O
rightLimit	int
)	O
;	O
i	int
++	O
)	O
{	O
int	O
c	int
;	O
c	int
=	O
gdImageGetPixel	function
(	O
im	pointer
,	O
i	int
,	O
y	int
-	O
1	int
)	O
;	O
if	O
(	O
lastBorder	int
)	O
{	O
if	O
(	O
(	O
c	int
!=	O
border	int
)	O
&&	O
(	O
c	int
!=	O
color	int
)	O
)	O
{	O
gdImageFillToBorder	function
(	O
im	pointer
,	O
i	int
,	O
y	int
-	O
1	int
,	O
border	int
,	O
color	int
)	O
;	O
lastBorder	int
=	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
(	O
c	int
==	O
border	int
)	O
||	O
(	O
c	int
==	O
color	int
)	O
)	O
{	O
lastBorder	int
=	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
y	int
<	O
(	O
(	O
im	pointer
->	O
sy	int
)	O
-	O
1	int
)	O
)	O
{	O
lastBorder	int
=	O
1	int
;	O
for	O
(	O
i	int
=	O
leftLimit	int
;	O
(	O
i	int
<=	O
rightLimit	int
)	O
;	O
i	int
++	O
)	O
{	O
int	O
c	int
;	O
c	int
=	O
gdImageGetPixel	function
(	O
im	pointer
,	O
i	int
,	O
y	int
+	O
1	int
)	O
;	O
if	O
(	O
lastBorder	int
)	O
{	O
if	O
(	O
(	O
c	int
!=	O
border	int
)	O
&&	O
(	O
c	int
!=	O
color	int
)	O
)	O
{	O
gdImageFillToBorder	function
(	O
im	pointer
,	O
i	int
,	O
y	int
+	O
1	int
,	O
border	int
,	O
color	int
)	O
;	O
lastBorder	int
=	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
(	O
c	int
==	O
border	int
)	O
||	O
(	O
c	int
==	O
color	int
)	O
)	O
{	O
lastBorder	int
=	O
1	int
;	O
}	O
}	O
}	O
}	O
void	O
gdImageFill	function
(	O
gdImagePtr	pointer
im	pointer
,	O
int	O
x	int
,	O
int	O
y	int
,	O
int	O
color	int
)	O
{	O
int	O
lastBorder	int
;	O
int	O
old	int
;	O
int	O
leftLimit	int
,	O
rightLimit	int
;	O
int	O
i	int
;	O
old	int
=	O
gdImageGetPixel	function
(	O
im	pointer
,	O
x	int
,	O
y	int
)	O
;	O
if	O
(	O
color	int
==	O
gdTiled	O
)	O
{	O
int	O
p	pointer
,	O
tileColor	int
;	O
int	O
srcx	int
,	O
srcy	int
;	O
if	O
(	O
!	O
im	pointer
->	O
tile	pointer
)	O
{	O
return	O
;	O
}	O
if	O
(	O
gdImageGetTransparent	O
(	O
im	pointer
->	O
tile	pointer
)	O
!=	O
(	O
-	O
1	int
)	O
)	O
{	O
return	O
;	O
}	O
srcx	int
=	O
x	int
%	O
gdImageSX	O
(	O
im	pointer
->	O
tile	pointer
)	O
;	O
srcy	int
=	O
y	int
%	O
gdImageSY	O
(	O
im	pointer
->	O
tile	pointer
)	O
;	O
p	pointer
=	O
gdImageGetPixel	function
(	O
im	pointer
->	O
tile	pointer
,	O
srcx	int
,	O
srcy	int
)	O
;	O
tileColor	int
=	O
im	pointer
->	O
tileColorMap	array
[	O
p	pointer
]	O
;	O
if	O
(	O
old	int
==	O
tileColor	int
)	O
{	O
return	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
old	int
==	O
color	int
)	O
{	O
return	O
;	O
}	O
}	O
leftLimit	int
=	O
(	O
-	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
x	int
;	O
(	O
i	int
>=	O
0	int
)	O
;	O
i	int
--	O
)	O
{	O
if	O
(	O
gdImageGetPixel	function
(	O
im	pointer
,	O
i	int
,	O
y	int
)	O
!=	O
old	int
)	O
{	O
break	O
;	O
}	O
gdImageSetPixel	function
(	O
im	pointer
,	O
i	int
,	O
y	int
,	O
color	int
)	O
;	O
leftLimit	int
=	O
i	int
;	O
}	O
if	O
(	O
leftLimit	int
==	O
(	O
-	O
1	int
)	O
)	O
{	O
return	O
;	O
}	O
rightLimit	int
=	O
x	int
;	O
for	O
(	O
i	int
=	O
(	O
x	int
+	O
1	int
)	O
;	O
(	O
i	int
<	O
im	pointer
->	O
sx	int
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
gdImageGetPixel	function
(	O
im	pointer
,	O
i	int
,	O
y	int
)	O
!=	O
old	int
)	O
{	O
break	O
;	O
}	O
gdImageSetPixel	function
(	O
im	pointer
,	O
i	int
,	O
y	int
,	O
color	int
)	O
;	O
rightLimit	int
=	O
i	int
;	O
}	O
if	O
(	O
y	int
>	O
0	int
)	O
{	O
lastBorder	int
=	O
1	int
;	O
for	O
(	O
i	int
=	O
leftLimit	int
;	O
(	O
i	int
<=	O
rightLimit	int
)	O
;	O
i	int
++	O
)	O
{	O
int	O
c	int
;	O
c	int
=	O
gdImageGetPixel	function
(	O
im	pointer
,	O
i	int
,	O
y	int
-	O
1	int
)	O
;	O
if	O
(	O
lastBorder	int
)	O
{	O
if	O
(	O
c	int
==	O
old	int
)	O
{	O
gdImageFill	function
(	O
im	pointer
,	O
i	int
,	O
y	int
-	O
1	int
,	O
color	int
)	O
;	O
lastBorder	int
=	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
c	int
!=	O
old	int
)	O
{	O
lastBorder	int
=	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
y	int
<	O
(	O
(	O
im	pointer
->	O
sy	int
)	O
-	O
1	int
)	O
)	O
{	O
lastBorder	int
=	O
1	int
;	O
for	O
(	O
i	int
=	O
leftLimit	int
;	O
(	O
i	int
<=	O
rightLimit	int
)	O
;	O
i	int
++	O
)	O
{	O
int	O
c	int
;	O
c	int
=	O
gdImageGetPixel	function
(	O
im	pointer
,	O
i	int
,	O
y	int
+	O
1	int
)	O
;	O
if	O
(	O
lastBorder	int
)	O
{	O
if	O
(	O
c	int
==	O
old	int
)	O
{	O
gdImageFill	function
(	O
im	pointer
,	O
i	int
,	O
y	int
+	O
1	int
,	O
color	int
)	O
;	O
lastBorder	int
=	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
c	int
!=	O
old	int
)	O
{	O
lastBorder	int
=	O
1	int
;	O
}	O
}	O
}	O
}	O
typedef	O
int	O
code_int	int
;	O
static	O
int	O
colorstobpp	function
(	O
int	O
colors	int
)	O
;	O
static	O
void	O
BumpPixel	function
(	O
void	O
)	O
;	O
static	O
int	O
GIFNextPixel	function
(	O
gdImagePtr	pointer
im	pointer
)	O
;	O
static	O
void	O
GIFEncode	function
(	O
FILE	struct
*	O
fp	pointer
,	O
int	O
GWidth	int
,	O
int	O
GHeight	int
,	O
int	O
GInterlace	int
,	O
int	O
Background	int
,	O
int	O
Transparent	int
,	O
int	O
BitsPerPixel	int
,	O
int	O
*	O
Red	pointer
,	O
int	O
*	O
Green	pointer
,	O
int	O
*	O
Blue	pointer
,	O
gdImagePtr	pointer
im	pointer
)	O
;	O
static	O
void	O
Putword	function
(	O
int	O
w	int
,	O
FILE	struct
*	O
fp	pointer
)	O
;	O
static	O
void	O
compress	function
(	O
int	O
,	O
FILE	struct
*	O
,	O
gdImagePtr	pointer
,	O
int	O
)	O
;	O
static	O
void	O
output	function
(	O
code_int	int
code	int
)	O
;	O
static	O
void	O
char_init	function
(	O
void	O
)	O
;	O
static	O
void	O
char_out	function
(	O
int	O
c	int
)	O
;	O
static	O
void	O
init_statics	function
(	O
void	O
)	O
;	O
void	O
gdImageGif	function
(	O
gdImagePtr	pointer
im	pointer
,	O
FILE	struct
*	O
out	pointer
)	O
{	O
int	O
interlace	int
,	O
transparent	int
,	O
BitsPerPixel	int
;	O
interlace	int
=	O
im	pointer
->	O
interlace	int
;	O
transparent	int
=	O
im	pointer
->	O
transparent	int
;	O
BitsPerPixel	int
=	O
colorstobpp	function
(	O
im	pointer
->	O
colorsTotal	int
)	O
;	O
init_statics	function
(	O
)	O
;	O
GIFEncode	function
(	O
out	pointer
,	O
im	pointer
->	O
sx	int
,	O
im	pointer
->	O
sy	int
,	O
interlace	int
,	O
0	int
,	O
transparent	int
,	O
BitsPerPixel	int
,	O
im	pointer
->	O
red	array
,	O
im	pointer
->	O
green	array
,	O
im	pointer
->	O
blue	array
,	O
im	pointer
)	O
;	O
}	O
static	O
int	O
colorstobpp	function
(	O
int	O
colors	int
)	O
{	O
int	O
bpp	int
=	O
0	int
;	O
if	O
(	O
colors	int
<=	O
2	int
)	O
bpp	int
=	O
1	int
;	O
else	O
if	O
(	O
colors	int
<=	O
4	int
)	O
bpp	int
=	O
2	int
;	O
else	O
if	O
(	O
colors	int
<=	O
8	int
)	O
bpp	int
=	O
3	int
;	O
else	O
if	O
(	O
colors	int
<=	O
16	int
)	O
bpp	int
=	O
4	int
;	O
else	O
if	O
(	O
colors	int
<=	O
32	int
)	O
bpp	int
=	O
5	int
;	O
else	O
if	O
(	O
colors	int
<=	O
64	int
)	O
bpp	int
=	O
6	int
;	O
else	O
if	O
(	O
colors	int
<=	O
128	int
)	O
bpp	int
=	O
7	int
;	O
else	O
if	O
(	O
colors	int
<=	O
256	int
)	O
bpp	int
=	O
8	int
;	O
return	O
bpp	int
;	O
}	O
static	O
int	O
Width	int
,	O
Height	int
;	O
static	O
int	O
curx	int
,	O
cury	int
;	O
static	O
long	O
CountDown	long
;	O
static	O
int	O
Pass	int
=	O
0	int
;	O
static	O
int	O
Interlace	int
;	O
static	O
void	O
BumpPixel	function
(	O
void	O
)	O
{	O
++	O
curx	int
;	O
if	O
(	O
curx	int
==	O
Width	int
)	O
{	O
curx	int
=	O
0	int
;	O
if	O
(	O
!	O
Interlace	int
)	O
++	O
cury	int
;	O
else	O
{	O
switch	O
(	O
Pass	int
)	O
{	O
case	O
0	int
:	O
cury	int
+=	O
8	int
;	O
if	O
(	O
cury	int
>=	O
Height	int
)	O
{	O
++	O
Pass	int
;	O
cury	int
=	O
4	int
;	O
}	O
break	O
;	O
case	O
1	int
:	O
cury	int
+=	O
8	int
;	O
if	O
(	O
cury	int
>=	O
Height	int
)	O
{	O
++	O
Pass	int
;	O
cury	int
=	O
2	int
;	O
}	O
break	O
;	O
case	O
2	int
:	O
cury	int
+=	O
4	int
;	O
if	O
(	O
cury	int
>=	O
Height	int
)	O
{	O
++	O
Pass	int
;	O
cury	int
=	O
1	int
;	O
}	O
break	O
;	O
case	O
3	int
:	O
cury	int
+=	O
2	int
;	O
break	O
;	O
}	O
}	O
}	O
}	O
static	O
int	O
GIFNextPixel	function
(	O
gdImagePtr	pointer
im	pointer
)	O
{	O
int	O
r	int
;	O
if	O
(	O
CountDown	long
==	O
0	int
)	O
return	O
EOF	O
;	O
--	O
CountDown	long
;	O
r	int
=	O
gdImageGetPixel	function
(	O
im	pointer
,	O
curx	int
,	O
cury	int
)	O
;	O
BumpPixel	function
(	O
)	O
;	O
return	O
r	int
;	O
}	O
static	O
void	O
GIFEncode	function
(	O
FILE	struct
*	O
fp	pointer
,	O
int	O
GWidth	int
,	O
int	O
GHeight	int
,	O
int	O
GInterlace	int
,	O
int	O
Background	int
,	O
int	O
Transparent	int
,	O
int	O
BitsPerPixel	int
,	O
int	O
*	O
Red	pointer
,	O
int	O
*	O
Green	pointer
,	O
int	O
*	O
Blue	pointer
,	O
gdImagePtr	pointer
im	pointer
)	O
{	O
int	O
B	int
;	O
int	O
RWidth	int
,	O
RHeight	int
;	O
int	O
LeftOfs	int
,	O
TopOfs	int
;	O
int	O
Resolution	int
;	O
int	O
ColorMapSize	int
;	O
int	O
InitCodeSize	int
;	O
int	O
i	int
;	O
Interlace	int
=	O
GInterlace	int
;	O
ColorMapSize	int
=	O
1	int
<<	O
BitsPerPixel	int
;	O
RWidth	int
=	O
Width	int
=	O
GWidth	int
;	O
RHeight	int
=	O
Height	int
=	O
GHeight	int
;	O
LeftOfs	int
=	O
TopOfs	int
=	O
0	int
;	O
Resolution	int
=	O
BitsPerPixel	int
;	O
CountDown	long
=	O
(	O
long	O
)	O
Width	int
*	O
(	O
long	O
)	O
Height	int
;	O
Pass	int
=	O
0	int
;	O
if	O
(	O
BitsPerPixel	int
<=	O
1	int
)	O
InitCodeSize	int
=	O
2	int
;	O
else	O
InitCodeSize	int
=	O
BitsPerPixel	int
;	O
curx	int
=	O
cury	int
=	O
0	int
;	O
fwrite	function
(	O
Transparent	int
<	O
0	int
?	O
"GIF87a"	pointer
:	O
"GIF89a"	pointer
,	O
1	int
,	O
6	int
,	O
fp	pointer
)	O
;	O
Putword	function
(	O
RWidth	int
,	O
fp	pointer
)	O
;	O
Putword	function
(	O
RHeight	int
,	O
fp	pointer
)	O
;	O
B	int
=	O
0x80	int
;	O
B	int
|=	O
(	O
Resolution	int
-	O
1	int
)	O
<<	O
4	int
;	O
B	int
|=	O
(	O
BitsPerPixel	int
-	O
1	int
)	O
;	O
fputc	function
(	O
B	int
,	O
fp	pointer
)	O
;	O
fputc	function
(	O
Background	int
,	O
fp	pointer
)	O
;	O
fputc	function
(	O
0	int
,	O
fp	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ColorMapSize	int
;	O
++	O
i	int
)	O
{	O
fputc	function
(	O
Red	pointer
[	O
i	int
]	O
,	O
fp	pointer
)	O
;	O
fputc	function
(	O
Green	pointer
[	O
i	int
]	O
,	O
fp	pointer
)	O
;	O
fputc	function
(	O
Blue	pointer
[	O
i	int
]	O
,	O
fp	pointer
)	O
;	O
}	O
if	O
(	O
Transparent	int
>=	O
0	int
)	O
{	O
fputc	function
(	O
'!'	O
,	O
fp	pointer
)	O
;	O
fputc	function
(	O
0xf9	int
,	O
fp	pointer
)	O
;	O
fputc	function
(	O
4	int
,	O
fp	pointer
)	O
;	O
fputc	function
(	O
1	int
,	O
fp	pointer
)	O
;	O
fputc	function
(	O
0	int
,	O
fp	pointer
)	O
;	O
fputc	function
(	O
0	int
,	O
fp	pointer
)	O
;	O
fputc	function
(	O
(	O
unsigned	O
char	O
)	O
Transparent	int
,	O
fp	pointer
)	O
;	O
fputc	function
(	O
0	int
,	O
fp	pointer
)	O
;	O
}	O
fputc	function
(	O
','	O
,	O
fp	pointer
)	O
;	O
Putword	function
(	O
LeftOfs	int
,	O
fp	pointer
)	O
;	O
Putword	function
(	O
TopOfs	int
,	O
fp	pointer
)	O
;	O
Putword	function
(	O
Width	int
,	O
fp	pointer
)	O
;	O
Putword	function
(	O
Height	int
,	O
fp	pointer
)	O
;	O
if	O
(	O
Interlace	int
)	O
fputc	function
(	O
0x40	int
,	O
fp	pointer
)	O
;	O
else	O
fputc	function
(	O
0x00	int
,	O
fp	pointer
)	O
;	O
fputc	function
(	O
InitCodeSize	int
,	O
fp	pointer
)	O
;	O
compress	function
(	O
InitCodeSize	int
+	O
1	int
,	O
fp	pointer
,	O
im	pointer
,	O
Background	int
)	O
;	O
fputc	function
(	O
0	int
,	O
fp	pointer
)	O
;	O
fputc	function
(	O
';'	O
,	O
fp	pointer
)	O
;	O
}	O
static	O
void	O
Putword	function
(	O
int	O
w	int
,	O
FILE	struct
*	O
fp	pointer
)	O
{	O
fputc	function
(	O
w	int
&	O
0xff	int
,	O
fp	pointer
)	O
;	O
fputc	function
(	O
(	O
w	int
/	O
256	int
)	O
&	O
0xff	int
,	O
fp	pointer
)	O
;	O
}	O
static	O
int	O
rl_pixel	int
;	O
static	O
int	O
rl_basecode	int
;	O
static	O
int	O
rl_count	int
;	O
static	O
int	O
rl_table_pixel	int
;	O
static	O
int	O
rl_table_max	int
;	O
static	O
int	O
just_cleared	int
;	O
static	O
int	O
out_bits	int
;	O
static	O
int	O
out_bits_init	int
;	O
static	O
int	O
out_count	int
;	O
static	O
int	O
out_bump	int
;	O
static	O
int	O
out_bump_init	int
;	O
static	O
int	O
out_clear	int
;	O
static	O
int	O
out_clear_init	int
;	O
static	O
int	O
max_ocodes	int
;	O
static	O
int	O
code_clear	int
;	O
static	O
int	O
code_eof	int
;	O
static	O
unsigned	O
int	O
obuf	int
;	O
static	O
int	O
obits	int
;	O
static	O
FILE	struct
*	O
ofile	pointer
;	O
static	O
unsigned	O
char	O
oblock	array
[	O
256	int
]	O
;	O
static	O
int	O
oblen	int
;	O
static	O
const	O
char	O
*	O
binformat	function
(	O
unsigned	O
int	O
v	int
,	O
int	O
nbits	int
)	O
{	O
static	O
char	O
bufs	array
[	O
8	int
]	O
[	O
64	int
]	O
;	O
static	O
int	O
bhand	int
=	O
0	int
;	O
unsigned	O
int	O
bit	int
;	O
int	O
bno	int
;	O
char	O
*	O
bp	pointer
;	O
bhand	int
--	O
;	O
if	O
(	O
bhand	int
<	O
0	int
)	O
bhand	int
=	O
(	O
sizeof	O
(	O
bufs	array
)	O
/	O
sizeof	O
(	O
bufs	array
[	O
0	int
]	O
)	O
)	O
-	O
1	int
;	O
bp	pointer
=	O
&	O
bufs	array
[	O
bhand	int
]	O
[	O
0	int
]	O
;	O
for	O
(	O
bno	int
=	O
nbits	int
-	O
1	int
,	O
bit	int
=	O
1U	int
<<	O
bno	int
;	O
bno	int
>=	O
0	int
;	O
bno	int
--	O
,	O
bit	int
>>=	O
1	int
)	O
{	O
*	O
bp	pointer
++	O
=	O
(	O
v	int
&	O
bit	int
)	O
?	O
'1'	O
:	O
'0'	O
;	O
if	O
(	O
(	O
(	O
bno	int
&	O
3	int
)	O
==	O
0	int
)	O
&&	O
(	O
bno	int
!=	O
0	int
)	O
)	O
*	O
bp	pointer
++	O
=	O
'.'	O
;	O
}	O
*	O
bp	pointer
=	O
'\0'	O
;	O
return	O
(	O
&	O
bufs	array
[	O
bhand	int
]	O
[	O
0	int
]	O
)	O
;	O
}	O
static	O
void	O
write_block	function
(	O
void	O
)	O
{	O
int	O
i	int
;	O
if	O
(	O
VERBOSE	int
)	O
{	O
printf	function
(	O
"write_block %d:"	pointer
,	O
oblen	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
oblen	int
;	O
i	int
++	O
)	O
printf	function
(	O
" %02x"	pointer
,	O
oblock	array
[	O
i	int
]	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
fputc	function
(	O
oblen	int
,	O
ofile	pointer
)	O
;	O
fwrite	function
(	O
&	O
oblock	array
[	O
0	int
]	O
,	O
1	int
,	O
oblen	int
,	O
ofile	pointer
)	O
;	O
oblen	int
=	O
0	int
;	O
}	O
static	O
void	O
block_out	function
(	O
unsigned	O
char	O
c	int
)	O
{	O
if	O
(	O
VERBOSE	int
)	O
printf	function
(	O
"block_out %s\n"	pointer
,	O
binformat	function
(	O
c	int
,	O
8	int
)	O
)	O
;	O
oblock	array
[	O
oblen	int
++	O
]	O
=	O
c	int
;	O
if	O
(	O
oblen	int
>=	O
255	int
)	O
write_block	function
(	O
)	O
;	O
}	O
static	O
void	O
block_flush	function
(	O
void	O
)	O
{	O
if	O
(	O
VERBOSE	int
)	O
printf	function
(	O
"block_flush\n"	pointer
)	O
;	O
if	O
(	O
oblen	int
>	O
0	int
)	O
write_block	function
(	O
)	O
;	O
}	O
static	O
void	O
output	function
(	O
int	O
val	int
)	O
{	O
if	O
(	O
VERBOSE	int
)	O
printf	function
(	O
"output %s [%s %d %d]\n"	pointer
,	O
binformat	function
(	O
val	int
,	O
out_bits	int
)	O
,	O
binformat	function
(	O
obuf	int
,	O
obits	int
)	O
,	O
obits	int
,	O
out_bits	int
)	O
;	O
obuf	int
|=	O
val	int
<<	O
obits	int
;	O
obits	int
+=	O
out_bits	int
;	O
while	O
(	O
obits	int
>=	O
8	int
)	O
{	O
block_out	function
(	O
obuf	int
&	O
0xff	int
)	O
;	O
obuf	int
>>=	O
8	int
;	O
obits	int
-=	O
8	int
;	O
}	O
if	O
(	O
VERBOSE	int
)	O
printf	function
(	O
"output leaving [%s %d]\n"	pointer
,	O
binformat	function
(	O
obuf	int
,	O
obits	int
)	O
,	O
obits	int
)	O
;	O
}	O
static	O
void	O
output_flush	function
(	O
void	O
)	O
{	O
if	O
(	O
VERBOSE	int
)	O
printf	function
(	O
"output_flush\n"	pointer
)	O
;	O
if	O
(	O
obits	int
>	O
0	int
)	O
block_out	function
(	O
obuf	int
)	O
;	O
block_flush	function
(	O
)	O
;	O
}	O
static	O
void	O
did_clear	function
(	O
void	O
)	O
{	O
if	O
(	O
VERBOSE	int
)	O
printf	function
(	O
"did_clear\n"	pointer
)	O
;	O
out_bits	int
=	O
out_bits_init	int
;	O
out_bump	int
=	O
out_bump_init	int
;	O
out_clear	int
=	O
out_clear_init	int
;	O
out_count	int
=	O
0	int
;	O
rl_table_max	int
=	O
0	int
;	O
just_cleared	int
=	O
1	int
;	O
}	O
static	O
void	O
output_plain	function
(	O
int	O
c	int
)	O
{	O
if	O
(	O
VERBOSE	int
)	O
printf	function
(	O
"output_plain %s\n"	pointer
,	O
binformat	function
(	O
c	int
,	O
out_bits	int
)	O
)	O
;	O
just_cleared	int
=	O
0	int
;	O
output	function
(	O
c	int
)	O
;	O
out_count	int
++	O
;	O
if	O
(	O
out_count	int
>=	O
out_bump	int
)	O
{	O
out_bits	int
++	O
;	O
out_bump	int
+=	O
1	int
<<	O
(	O
out_bits	int
-	O
1	int
)	O
;	O
}	O
if	O
(	O
out_count	int
>=	O
out_clear	int
)	O
{	O
output	function
(	O
code_clear	int
)	O
;	O
did_clear	function
(	O
)	O
;	O
}	O
}	O
static	O
unsigned	O
int	O
isqrt	function
(	O
unsigned	O
int	O
x	int
)	O
{	O
unsigned	O
int	O
r	int
;	O
unsigned	O
int	O
v	int
;	O
if	O
(	O
x	int
<	O
2	int
)	O
return	O
(	O
x	int
)	O
;	O
for	O
(	O
v	int
=	O
x	int
,	O
r	int
=	O
1	int
;	O
v	int
;	O
v	int
>>=	O
2	int
,	O
r	int
<<=	O
1	int
)	O
;	O
while	O
(	O
1	int
)	O
{	O
v	int
=	O
(	O
(	O
x	int
/	O
r	int
)	O
+	O
r	int
)	O
/	O
2	int
;	O
if	O
(	O
(	O
v	int
==	O
r	int
)	O
||	O
(	O
v	int
==	O
r	int
+	O
1	int
)	O
)	O
return	O
(	O
r	int
)	O
;	O
r	int
=	O
v	int
;	O
}	O
}	O
static	O
unsigned	O
int	O
compute_triangle_count	function
(	O
unsigned	O
int	O
count	int
,	O
unsigned	O
int	O
nrepcodes	int
)	O
{	O
unsigned	O
int	O
perrep	int
;	O
unsigned	O
int	O
cost_result	int
;	O
cost_result	int
=	O
0	int
;	O
perrep	int
=	O
(	O
nrepcodes	int
*	O
(	O
nrepcodes	int
+	O
1	int
)	O
)	O
/	O
2	int
;	O
while	O
(	O
count	int
>=	O
perrep	int
)	O
{	O
cost_result	int
+=	O
nrepcodes	int
;	O
count	int
-=	O
perrep	int
;	O
}	O
if	O
(	O
count	int
>	O
0	int
)	O
{	O
unsigned	O
int	O
n	int
;	O
n	int
=	O
isqrt	function
(	O
count	int
)	O
;	O
while	O
(	O
(	O
n	int
*	O
(	O
n	int
+	O
1	int
)	O
)	O
>=	O
2	int
*	O
count	int
)	O
n	int
--	O
;	O
while	O
(	O
(	O
n	int
*	O
(	O
n	int
+	O
1	int
)	O
)	O
<	O
2	int
*	O
count	int
)	O
n	int
++	O
;	O
cost_result	int
+=	O
n	int
;	O
}	O
return	O
(	O
cost_result	int
)	O
;	O
}	O
static	O
void	O
max_out_clear	function
(	O
void	O
)	O
{	O
out_clear	int
=	O
max_ocodes	int
;	O
}	O
static	O
void	O
reset_out_clear	function
(	O
void	O
)	O
{	O
out_clear	int
=	O
out_clear_init	int
;	O
if	O
(	O
out_count	int
>=	O
out_clear	int
)	O
{	O
output	function
(	O
code_clear	int
)	O
;	O
did_clear	function
(	O
)	O
;	O
}	O
}	O
static	O
void	O
rl_flush_fromclear	function
(	O
int	O
count	int
)	O
{	O
int	O
n	int
;	O
if	O
(	O
VERBOSE	int
)	O
printf	function
(	O
"rl_flush_fromclear %d\n"	pointer
,	O
count	int
)	O
;	O
max_out_clear	function
(	O
)	O
;	O
rl_table_pixel	int
=	O
rl_pixel	int
;	O
n	int
=	O
1	int
;	O
while	O
(	O
count	int
>	O
0	int
)	O
{	O
if	O
(	O
n	int
==	O
1	int
)	O
{	O
rl_table_max	int
=	O
1	int
;	O
output_plain	function
(	O
rl_pixel	int
)	O
;	O
count	int
--	O
;	O
}	O
else	O
if	O
(	O
count	int
>=	O
n	int
)	O
{	O
rl_table_max	int
=	O
n	int
;	O
output_plain	function
(	O
rl_basecode	int
+	O
n	int
-	O
2	int
)	O
;	O
count	int
-=	O
n	int
;	O
}	O
else	O
if	O
(	O
count	int
==	O
1	int
)	O
{	O
rl_table_max	int
++	O
;	O
output_plain	function
(	O
rl_pixel	int
)	O
;	O
count	int
=	O
0	int
;	O
}	O
else	O
{	O
rl_table_max	int
++	O
;	O
output_plain	function
(	O
rl_basecode	int
+	O
count	int
-	O
2	int
)	O
;	O
count	int
=	O
0	int
;	O
}	O
if	O
(	O
out_count	int
==	O
0	int
)	O
n	int
=	O
1	int
;	O
else	O
n	int
++	O
;	O
}	O
reset_out_clear	function
(	O
)	O
;	O
if	O
(	O
VERBOSE	int
)	O
printf	function
(	O
"rl_flush_fromclear leaving table_max=%d\n"	pointer
,	O
rl_table_max	int
)	O
;	O
}	O
static	O
void	O
rl_flush_clearorrep	function
(	O
int	O
count	int
)	O
{	O
int	O
withclr	int
;	O
if	O
(	O
VERBOSE	int
)	O
printf	function
(	O
"rl_flush_clearorrep %d\n"	pointer
,	O
count	int
)	O
;	O
withclr	int
=	O
1	int
+	O
compute_triangle_count	function
(	O
count	int
,	O
max_ocodes	int
)	O
;	O
if	O
(	O
withclr	int
<	O
count	int
)	O
{	O
output	function
(	O
code_clear	int
)	O
;	O
did_clear	function
(	O
)	O
;	O
rl_flush_fromclear	function
(	O
count	int
)	O
;	O
}	O
else	O
{	O
for	O
(	O
;	O
count	int
>	O
0	int
;	O
count	int
--	O
)	O
output_plain	function
(	O
rl_pixel	int
)	O
;	O
}	O
}	O
static	O
void	O
rl_flush_withtable	function
(	O
int	O
count	int
)	O
{	O
int	O
repmax	int
;	O
int	O
repleft	int
;	O
int	O
leftover	int
;	O
if	O
(	O
VERBOSE	int
)	O
printf	function
(	O
"rl_flush_withtable %d\n"	pointer
,	O
count	int
)	O
;	O
repmax	int
=	O
count	int
/	O
rl_table_max	int
;	O
leftover	int
=	O
count	int
%	O
rl_table_max	int
;	O
repleft	int
=	O
(	O
leftover	int
?	O
1	int
:	O
0	int
)	O
;	O
if	O
(	O
out_count	int
+	O
repmax	int
+	O
repleft	int
>	O
max_ocodes	int
)	O
{	O
repmax	int
=	O
max_ocodes	int
-	O
out_count	int
;	O
leftover	int
=	O
count	int
-	O
(	O
repmax	int
*	O
rl_table_max	int
)	O
;	O
repleft	int
=	O
1	int
+	O
compute_triangle_count	function
(	O
leftover	int
,	O
max_ocodes	int
)	O
;	O
}	O
if	O
(	O
VERBOSE	int
)	O
printf	function
(	O
"rl_flush_withtable repmax=%d leftover=%d repleft=%d\n"	pointer
,	O
repmax	int
,	O
leftover	int
,	O
repleft	int
)	O
;	O
if	O
(	O
1	int
+	O
compute_triangle_count	function
(	O
count	int
,	O
max_ocodes	int
)	O
<	O
repmax	int
+	O
repleft	int
)	O
{	O
output	function
(	O
code_clear	int
)	O
;	O
did_clear	function
(	O
)	O
;	O
rl_flush_fromclear	function
(	O
count	int
)	O
;	O
return	O
;	O
}	O
max_out_clear	function
(	O
)	O
;	O
for	O
(	O
;	O
repmax	int
>	O
0	int
;	O
repmax	int
--	O
)	O
output_plain	function
(	O
rl_basecode	int
+	O
rl_table_max	int
-	O
2	int
)	O
;	O
if	O
(	O
leftover	int
)	O
{	O
if	O
(	O
just_cleared	int
)	O
{	O
rl_flush_fromclear	function
(	O
leftover	int
)	O
;	O
}	O
else	O
if	O
(	O
leftover	int
==	O
1	int
)	O
{	O
output_plain	function
(	O
rl_pixel	int
)	O
;	O
}	O
else	O
{	O
output_plain	function
(	O
rl_basecode	int
+	O
leftover	int
-	O
2	int
)	O
;	O
}	O
}	O
reset_out_clear	function
(	O
)	O
;	O
}	O
static	O
void	O
rl_flush	function
(	O
void	O
)	O
{	O
if	O
(	O
VERBOSE	int
)	O
printf	function
(	O
"rl_flush [ %d %d\n"	pointer
,	O
rl_count	int
,	O
rl_pixel	int
)	O
;	O
if	O
(	O
rl_count	int
==	O
1	int
)	O
{	O
output_plain	function
(	O
rl_pixel	int
)	O
;	O
rl_count	int
=	O
0	int
;	O
if	O
(	O
VERBOSE	int
)	O
printf	function
(	O
"rl_flush ]\n"	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
just_cleared	int
)	O
{	O
rl_flush_fromclear	function
(	O
rl_count	int
)	O
;	O
}	O
else	O
if	O
(	O
(	O
rl_table_max	int
<	O
2	int
)	O
||	O
(	O
rl_table_pixel	int
!=	O
rl_pixel	int
)	O
)	O
{	O
rl_flush_clearorrep	function
(	O
rl_count	int
)	O
;	O
}	O
else	O
{	O
rl_flush_withtable	function
(	O
rl_count	int
)	O
;	O
}	O
if	O
(	O
VERBOSE	int
)	O
printf	function
(	O
"rl_flush ]\n"	pointer
)	O
;	O
rl_count	int
=	O
0	int
;	O
}	O
static	O
void	O
compress	function
(	O
int	O
init_bits	int
,	O
FILE	struct
*	O
outfile	pointer
,	O
gdImagePtr	pointer
im	pointer
,	O
int	O
background	int
)	O
{	O
int	O
c	int
;	O
ofile	pointer
=	O
outfile	pointer
;	O
obuf	int
=	O
0	int
;	O
obits	int
=	O
0	int
;	O
oblen	int
=	O
0	int
;	O
code_clear	int
=	O
1	int
<<	O
(	O
init_bits	int
-	O
1	int
)	O
;	O
code_eof	int
=	O
code_clear	int
+	O
1	int
;	O
rl_basecode	int
=	O
code_eof	int
+	O
1	int
;	O
out_bump_init	int
=	O
(	O
1	int
<<	O
(	O
init_bits	int
-	O
1	int
)	O
)	O
-	O
1	int
;	O
out_clear_init	int
=	O
(	O
init_bits	int
<=	O
3	int
)	O
?	O
9	int
:	O
(	O
out_bump_init	int
-	O
1	int
)	O
;	O
out_bits_init	int
=	O
init_bits	int
;	O
max_ocodes	int
=	O
(	O
1	int
<<	O
GIFBITS	int
)	O
-	O
(	O
(	O
1	int
<<	O
(	O
out_bits_init	int
-	O
1	int
)	O
)	O
+	O
3	int
)	O
;	O
did_clear	function
(	O
)	O
;	O
output	function
(	O
code_clear	int
)	O
;	O
rl_count	int
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
c	int
=	O
GIFNextPixel	function
(	O
im	pointer
)	O
;	O
if	O
(	O
(	O
rl_count	int
>	O
0	int
)	O
&&	O
(	O
c	int
!=	O
rl_pixel	int
)	O
)	O
rl_flush	function
(	O
)	O
;	O
if	O
(	O
c	int
==	O
EOF	O
)	O
break	O
;	O
if	O
(	O
rl_pixel	int
==	O
c	int
)	O
{	O
rl_count	int
++	O
;	O
}	O
else	O
{	O
rl_pixel	int
=	O
c	int
;	O
rl_count	int
=	O
1	int
;	O
}	O
}	O
output	function
(	O
code_eof	int
)	O
;	O
output_flush	function
(	O
)	O
;	O
}	O
static	O
int	O
a_count	int
;	O
static	O
void	O
char_init	function
(	O
void	O
)	O
{	O
a_count	int
=	O
0	int
;	O
}	O
static	O
void	O
init_statics	function
(	O
void	O
)	O
{	O
Width	int
=	O
0	int
;	O
Height	int
=	O
0	int
;	O
curx	int
=	O
0	int
;	O
cury	int
=	O
0	int
;	O
CountDown	long
=	O
0	int
;	O
Pass	int
=	O
0	int
;	O
Interlace	int
=	O
0	int
;	O
a_count	int
=	O
0	int
;	O
}	O
static	O
struct	O
{	O
int	O
transparent	int
;	O
int	O
delayTime	int
;	O
int	O
inputFlag	int
;	O
int	O
disposal	int
;	O
}	O
Gif89	struct
=	O
{	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
0	int
}	O
;	O
static	O
int	O
ReadColorMap	function
(	O
FILE	struct
*	O
fd	pointer
,	O
int	O
number	int
,	O
unsigned	O
char	O
(	O
*	O
buffer	pointer
)	O
[	O
256	int
]	O
)	O
;	O
static	O
int	O
DoExtension	function
(	O
FILE	struct
*	O
fd	pointer
,	O
int	O
label	int
,	O
int	O
*	O
Transparent	int
)	O
;	O
static	O
int	O
GetDataBlock	function
(	O
FILE	struct
*	O
fd	pointer
,	O
unsigned	O
char	O
*	O
buf	pointer
)	O
;	O
static	O
int	O
GetCode	function
(	O
FILE	struct
*	O
fd	pointer
,	O
int	O
code_size	int
,	O
int	O
flag	int
)	O
;	O
static	O
int	O
LWZReadByte	function
(	O
FILE	struct
*	O
fd	pointer
,	O
int	O
flag	int
,	O
int	O
input_code_size	int
)	O
;	O
static	O
void	O
ReadImage	function
(	O
gdImagePtr	pointer
im	pointer
,	O
FILE	struct
*	O
fd	pointer
,	O
int	O
len	int
,	O
int	O
height	int
,	O
unsigned	O
char	O
(	O
*	O
cmap	pointer
)	O
[	O
256	int
]	O
,	O
int	O
interlace	int
,	O
int	O
ignore	int
)	O
;	O
int	O
ZeroDataBlock	int
;	O
gdImagePtr	pointer
gdImageCreateFromGif	function
(	O
FILE	struct
*	O
fd	pointer
)	O
{	O
int	O
imageNumber	int
;	O
int	O
BitPixel	int
;	O
int	O
ColorResolution	int
;	O
int	O
Background	int
;	O
int	O
AspectRatio	int
;	O
int	O
Transparent	int
=	O
(	O
-	O
1	int
)	O
;	O
unsigned	O
char	O
buf	pointer
[	O
16	int
]	O
;	O
unsigned	O
char	O
c	int
;	O
unsigned	O
char	O
ColorMap	array
[	O
3	int
]	O
[	O
MAXCOLORMAPSIZE	int
]	O
;	O
unsigned	O
char	O
localColorMap	array
[	O
3	int
]	O
[	O
MAXCOLORMAPSIZE	int
]	O
;	O
int	O
imw	int
,	O
imh	int
;	O
int	O
useGlobalColormap	int
;	O
int	O
bitPixel	int
;	O
int	O
imageCount	int
=	O
0	int
;	O
char	O
version	array
[	O
4	int
]	O
;	O
gdImagePtr	pointer
im	pointer
=	O
0	int
;	O
ZeroDataBlock	int
=	O
FALSE	int
;	O
imageNumber	int
=	O
1	int
;	O
if	O
(	O
!	O
ReadOK	O
(	O
fd	pointer
,	O
buf	pointer
,	O
6	int
)	O
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
strncmp	function
(	O
(	O
char	O
*	O
)	O
buf	pointer
,	O
"GIF"	pointer
,	O
3	int
)	O
!=	O
0	int
)	O
{	O
return	O
0	int
;	O
}	O
strncpy	function
(	O
version	array
,	O
(	O
char	O
*	O
)	O
buf	pointer
+	O
3	int
,	O
3	int
)	O
;	O
version	array
[	O
3	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
(	O
strcmp	function
(	O
version	array
,	O
"87a"	pointer
)	O
!=	O
0	int
)	O
&&	O
(	O
strcmp	function
(	O
version	array
,	O
"89a"	pointer
)	O
!=	O
0	int
)	O
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
ReadOK	O
(	O
fd	pointer
,	O
buf	pointer
,	O
7	int
)	O
)	O
{	O
return	O
0	int
;	O
}	O
BitPixel	int
=	O
2	int
<<	O
(	O
buf	pointer
[	O
4	int
]	O
&	O
0x07	int
)	O
;	O
ColorResolution	int
=	O
(	O
int	O
)	O
(	O
(	O
(	O
buf	pointer
[	O
4	int
]	O
&	O
0x70	int
)	O
>>	O
3	int
)	O
+	O
1	int
)	O
;	O
Background	int
=	O
buf	pointer
[	O
5	int
]	O
;	O
AspectRatio	int
=	O
buf	pointer
[	O
6	int
]	O
;	O
if	O
(	O
BitSet	O
(	O
buf	pointer
[	O
4	int
]	O
,	O
LOCALCOLORMAP	int
)	O
)	O
{	O
if	O
(	O
ReadColorMap	function
(	O
fd	pointer
,	O
BitPixel	int
,	O
ColorMap	array
)	O
)	O
{	O
return	O
0	int
;	O
}	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
!	O
ReadOK	O
(	O
fd	pointer
,	O
&	O
c	int
,	O
1	int
)	O
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
c	int
==	O
';'	O
)	O
{	O
int	O
i	int
;	O
if	O
(	O
imageCount	int
<	O
imageNumber	int
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
im	pointer
)	O
{	O
return	O
0	int
;	O
}	O
for	O
(	O
i	int
=	O
(	O
(	O
im	pointer
->	O
colorsTotal	int
-	O
1	int
)	O
)	O
;	O
(	O
i	int
>=	O
0	int
)	O
;	O
i	int
--	O
)	O
{	O
if	O
(	O
im	pointer
->	O
open	array
[	O
i	int
]	O
)	O
{	O
im	pointer
->	O
colorsTotal	int
--	O
;	O
}	O
else	O
{	O
break	O
;	O
}	O
}	O
return	O
im	pointer
;	O
}	O
if	O
(	O
c	int
==	O
'!'	O
)	O
{	O
if	O
(	O
!	O
ReadOK	O
(	O
fd	pointer
,	O
&	O
c	int
,	O
1	int
)	O
)	O
{	O
return	O
0	int
;	O
}	O
DoExtension	function
(	O
fd	pointer
,	O
c	int
,	O
&	O
Transparent	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
c	int
!=	O
','	O
)	O
{	O
continue	O
;	O
}	O
++	O
imageCount	int
;	O
if	O
(	O
!	O
ReadOK	O
(	O
fd	pointer
,	O
buf	pointer
,	O
9	int
)	O
)	O
{	O
return	O
0	int
;	O
}	O
useGlobalColormap	int
=	O
!	O
BitSet	O
(	O
buf	pointer
[	O
8	int
]	O
,	O
LOCALCOLORMAP	int
)	O
;	O
bitPixel	int
=	O
1	int
<<	O
(	O
(	O
buf	pointer
[	O
8	int
]	O
&	O
0x07	int
)	O
+	O
1	int
)	O
;	O
imw	int
=	O
LM_to_uint	O
(	O
buf	pointer
[	O
4	int
]	O
,	O
buf	pointer
[	O
5	int
]	O
)	O
;	O
imh	int
=	O
LM_to_uint	O
(	O
buf	pointer
[	O
6	int
]	O
,	O
buf	pointer
[	O
7	int
]	O
)	O
;	O
if	O
(	O
!	O
(	O
im	pointer
=	O
gdImageCreate	function
(	O
imw	int
,	O
imh	int
)	O
)	O
)	O
{	O
return	O
0	int
;	O
}	O
im	pointer
->	O
interlace	int
=	O
BitSet	O
(	O
buf	pointer
[	O
8	int
]	O
,	O
INTERLACE	int
)	O
;	O
if	O
(	O
!	O
useGlobalColormap	int
)	O
{	O
if	O
(	O
ReadColorMap	function
(	O
fd	pointer
,	O
bitPixel	int
,	O
localColorMap	array
)	O
)	O
{	O
return	O
0	int
;	O
}	O
ReadImage	function
(	O
im	pointer
,	O
fd	pointer
,	O
imw	int
,	O
imh	int
,	O
localColorMap	array
,	O
BitSet	O
(	O
buf	pointer
[	O
8	int
]	O
,	O
INTERLACE	int
)	O
,	O
imageCount	int
!=	O
imageNumber	int
)	O
;	O
}	O
else	O
{	O
ReadImage	function
(	O
im	pointer
,	O
fd	pointer
,	O
imw	int
,	O
imh	int
,	O
ColorMap	array
,	O
BitSet	O
(	O
buf	pointer
[	O
8	int
]	O
,	O
INTERLACE	int
)	O
,	O
imageCount	int
!=	O
imageNumber	int
)	O
;	O
}	O
if	O
(	O
Transparent	int
!=	O
(	O
-	O
1	int
)	O
)	O
{	O
gdImageColorTransparent	function
(	O
im	pointer
,	O
Transparent	int
)	O
;	O
}	O
}	O
}	O
static	O
int	O
ReadColorMap	function
(	O
FILE	struct
*	O
fd	pointer
,	O
int	O
number	int
,	O
unsigned	O
char	O
(	O
*	O
buffer	pointer
)	O
[	O
256	int
]	O
)	O
{	O
int	O
i	int
;	O
unsigned	O
char	O
rgb	array
[	O
3	int
]	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
number	int
;	O
++	O
i	int
)	O
{	O
if	O
(	O
!	O
ReadOK	O
(	O
fd	pointer
,	O
rgb	array
,	O
sizeof	O
(	O
rgb	array
)	O
)	O
)	O
{	O
return	O
TRUE	int
;	O
}	O
buffer	pointer
[	O
CM_RED	int
]	O
[	O
i	int
]	O
=	O
rgb	array
[	O
0	int
]	O
;	O
buffer	pointer
[	O
CM_GREEN	int
]	O
[	O
i	int
]	O
=	O
rgb	array
[	O
1	int
]	O
;	O
buffer	pointer
[	O
CM_BLUE	int
]	O
[	O
i	int
]	O
=	O
rgb	array
[	O
2	int
]	O
;	O
}	O
return	O
FALSE	int
;	O
}	O
static	O
int	O
DoExtension	function
(	O
FILE	struct
*	O
fd	pointer
,	O
int	O
label	int
,	O
int	O
*	O
Transparent	int
)	O
{	O
static	O
unsigned	O
char	O
buf	pointer
[	O
256	int
]	O
;	O
switch	O
(	O
label	int
)	O
{	O
case	O
0xf9	int
:	O
(	O
void	O
)	O
GetDataBlock	function
(	O
fd	pointer
,	O
(	O
unsigned	O
char	O
*	O
)	O
buf	pointer
)	O
;	O
Gif89	struct
.	O
disposal	int
=	O
(	O
buf	pointer
[	O
0	int
]	O
>>	O
2	int
)	O
&	O
0x7	int
;	O
Gif89	struct
.	O
inputFlag	int
=	O
(	O
buf	pointer
[	O
0	int
]	O
>>	O
1	int
)	O
&	O
0x1	int
;	O
Gif89	struct
.	O
delayTime	int
=	O
LM_to_uint	O
(	O
buf	pointer
[	O
1	int
]	O
,	O
buf	pointer
[	O
2	int
]	O
)	O
;	O
if	O
(	O
(	O
buf	pointer
[	O
0	int
]	O
&	O
0x1	int
)	O
!=	O
0	int
)	O
*	O
Transparent	int
=	O
buf	pointer
[	O
3	int
]	O
;	O
while	O
(	O
GetDataBlock	function
(	O
fd	pointer
,	O
(	O
unsigned	O
char	O
*	O
)	O
buf	pointer
)	O
!=	O
0	int
)	O
;	O
return	O
FALSE	int
;	O
default	O
:	O
break	O
;	O
}	O
while	O
(	O
GetDataBlock	function
(	O
fd	pointer
,	O
(	O
unsigned	O
char	O
*	O
)	O
buf	pointer
)	O
!=	O
0	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
static	O
int	O
GetDataBlock_	function
(	O
FILE	struct
*	O
fd	pointer
,	O
unsigned	O
char	O
*	O
buf	pointer
)	O
{	O
unsigned	O
char	O
count	int
;	O
if	O
(	O
!	O
ReadOK	O
(	O
fd	pointer
,	O
&	O
count	int
,	O
1	int
)	O
)	O
{	O
return	O
-	O
1	int
;	O
}	O
ZeroDataBlock	int
=	O
count	int
==	O
0	int
;	O
if	O
(	O
(	O
count	int
!=	O
0	int
)	O
&&	O
(	O
!	O
ReadOK	O
(	O
fd	pointer
,	O
buf	pointer
,	O
count	int
)	O
)	O
)	O
{	O
return	O
-	O
1	int
;	O
}	O
return	O
count	int
;	O
}	O
static	O
int	O
GetDataBlock	function
(	O
FILE	struct
*	O
fd	pointer
,	O
unsigned	O
char	O
*	O
buf	pointer
)	O
{	O
int	O
rv	int
;	O
int	O
i	int
;	O
rv	int
=	O
GetDataBlock_	function
(	O
fd	pointer
,	O
buf	pointer
)	O
;	O
if	O
(	O
VERBOSE	int
)	O
{	O
printf	function
(	O
"[GetDataBlock returning %d"	pointer
,	O
rv	int
)	O
;	O
if	O
(	O
rv	int
>	O
0	int
)	O
{	O
printf	function
(	O
":"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
rv	int
;	O
i	int
++	O
)	O
printf	function
(	O
" %02x"	pointer
,	O
buf	pointer
[	O
i	int
]	O
)	O
;	O
}	O
printf	function
(	O
"]\n"	pointer
)	O
;	O
}	O
return	O
(	O
rv	int
)	O
;	O
}	O
static	O
int	O
GetCode_	function
(	O
FILE	struct
*	O
fd	pointer
,	O
int	O
code_size	int
,	O
int	O
flag	int
)	O
{	O
static	O
unsigned	O
char	O
buf	pointer
[	O
280	int
]	O
;	O
static	O
int	O
curbit	int
,	O
lastbit	int
,	O
done	int
,	O
last_byte	int
;	O
int	O
i	int
,	O
j	int
,	O
ret	int
;	O
unsigned	O
char	O
count	int
;	O
if	O
(	O
flag	int
)	O
{	O
curbit	int
=	O
0	int
;	O
lastbit	int
=	O
0	int
;	O
done	int
=	O
FALSE	int
;	O
return	O
0	int
;	O
}	O
if	O
(	O
(	O
curbit	int
+	O
code_size	int
)	O
>=	O
lastbit	int
)	O
{	O
if	O
(	O
done	int
)	O
{	O
if	O
(	O
curbit	int
>=	O
lastbit	int
)	O
{	O
}	O
return	O
-	O
1	int
;	O
}	O
buf	pointer
[	O
0	int
]	O
=	O
buf	pointer
[	O
last_byte	int
-	O
2	int
]	O
;	O
buf	pointer
[	O
1	int
]	O
=	O
buf	pointer
[	O
last_byte	int
-	O
1	int
]	O
;	O
if	O
(	O
(	O
count	int
=	O
GetDataBlock	function
(	O
fd	pointer
,	O
&	O
buf	pointer
[	O
2	int
]	O
)	O
)	O
==	O
0	int
)	O
done	int
=	O
TRUE	int
;	O
last_byte	int
=	O
2	int
+	O
count	int
;	O
curbit	int
=	O
(	O
curbit	int
-	O
lastbit	int
)	O
+	O
16	int
;	O
lastbit	int
=	O
(	O
2	int
+	O
count	int
)	O
*	O
8	int
;	O
}	O
ret	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
curbit	int
,	O
j	int
=	O
0	int
;	O
j	int
<	O
code_size	int
;	O
++	O
i	int
,	O
++	O
j	int
)	O
ret	int
|=	O
(	O
(	O
buf	pointer
[	O
i	int
/	O
8	int
]	O
&	O
(	O
1	int
<<	O
(	O
i	int
%	O
8	int
)	O
)	O
)	O
!=	O
0	int
)	O
<<	O
j	int
;	O
curbit	int
+=	O
code_size	int
;	O
return	O
ret	int
;	O
}	O
static	O
int	O
GetCode	function
(	O
FILE	struct
*	O
fd	pointer
,	O
int	O
code_size	int
,	O
int	O
flag	int
)	O
{	O
int	O
rv	int
;	O
rv	int
=	O
GetCode_	function
(	O
fd	pointer
,	O
code_size	int
,	O
flag	int
)	O
;	O
if	O
(	O
VERBOSE	int
)	O
printf	function
(	O
"[GetCode(,%d,%d) returning %d]\n"	pointer
,	O
code_size	int
,	O
flag	int
,	O
rv	int
)	O
;	O
return	O
(	O
rv	int
)	O
;	O
}	O
static	O
int	O
LWZReadByte_	function
(	O
FILE	struct
*	O
fd	pointer
,	O
int	O
flag	int
,	O
int	O
input_code_size	int
)	O
{	O
static	O
int	O
fresh	int
=	O
FALSE	int
;	O
int	O
code	int
,	O
incode	int
;	O
static	O
int	O
code_size	int
,	O
set_code_size	int
;	O
static	O
int	O
max_code	int
,	O
max_code_size	int
;	O
static	O
int	O
firstcode	int
,	O
oldcode	int
;	O
static	O
int	O
clear_code	int
,	O
end_code	int
;	O
static	O
int	O
table	array
[	O
2	int
]	O
[	O
(	O
1	int
<<	O
MAX_LWZ_BITS	int
)	O
]	O
;	O
static	O
int	O
stack	array
[	O
(	O
1	int
<<	O
(	O
MAX_LWZ_BITS	int
)	O
)	O
*	O
2	int
]	O
,	O
*	O
sp	pointer
;	O
register	O
int	O
i	int
;	O
if	O
(	O
flag	int
)	O
{	O
set_code_size	int
=	O
input_code_size	int
;	O
code_size	int
=	O
set_code_size	int
+	O
1	int
;	O
clear_code	int
=	O
1	int
<<	O
set_code_size	int
;	O
end_code	int
=	O
clear_code	int
+	O
1	int
;	O
max_code_size	int
=	O
2	int
*	O
clear_code	int
;	O
max_code	int
=	O
clear_code	int
+	O
2	int
;	O
GetCode	function
(	O
fd	pointer
,	O
0	int
,	O
TRUE	int
)	O
;	O
fresh	int
=	O
TRUE	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
clear_code	int
;	O
++	O
i	int
)	O
{	O
table	array
[	O
0	int
]	O
[	O
i	int
]	O
=	O
0	int
;	O
table	array
[	O
1	int
]	O
[	O
i	int
]	O
=	O
i	int
;	O
}	O
for	O
(	O
;	O
i	int
<	O
(	O
1	int
<<	O
MAX_LWZ_BITS	int
)	O
;	O
++	O
i	int
)	O
table	array
[	O
0	int
]	O
[	O
i	int
]	O
=	O
table	array
[	O
1	int
]	O
[	O
0	int
]	O
=	O
0	int
;	O
sp	pointer
=	O
stack	array
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
fresh	int
)	O
{	O
fresh	int
=	O
FALSE	int
;	O
do	O
{	O
firstcode	int
=	O
oldcode	int
=	O
GetCode	function
(	O
fd	pointer
,	O
code_size	int
,	O
FALSE	int
)	O
;	O
}	O
while	O
(	O
firstcode	int
==	O
clear_code	int
)	O
;	O
return	O
firstcode	int
;	O
}	O
if	O
(	O
sp	pointer
>	O
stack	array
)	O
return	O
*	O
--	O
sp	pointer
;	O
while	O
(	O
(	O
code	int
=	O
GetCode	function
(	O
fd	pointer
,	O
code_size	int
,	O
FALSE	int
)	O
)	O
>=	O
0	int
)	O
{	O
if	O
(	O
code	int
==	O
clear_code	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
clear_code	int
;	O
++	O
i	int
)	O
{	O
table	array
[	O
0	int
]	O
[	O
i	int
]	O
=	O
0	int
;	O
table	array
[	O
1	int
]	O
[	O
i	int
]	O
=	O
i	int
;	O
}	O
for	O
(	O
;	O
i	int
<	O
(	O
1	int
<<	O
MAX_LWZ_BITS	int
)	O
;	O
++	O
i	int
)	O
table	array
[	O
0	int
]	O
[	O
i	int
]	O
=	O
table	array
[	O
1	int
]	O
[	O
i	int
]	O
=	O
0	int
;	O
code_size	int
=	O
set_code_size	int
+	O
1	int
;	O
max_code_size	int
=	O
2	int
*	O
clear_code	int
;	O
max_code	int
=	O
clear_code	int
+	O
2	int
;	O
sp	pointer
=	O
stack	array
;	O
firstcode	int
=	O
oldcode	int
=	O
GetCode	function
(	O
fd	pointer
,	O
code_size	int
,	O
FALSE	int
)	O
;	O
return	O
firstcode	int
;	O
}	O
else	O
if	O
(	O
code	int
==	O
end_code	int
)	O
{	O
int	O
count	int
;	O
unsigned	O
char	O
buf	pointer
[	O
260	int
]	O
;	O
if	O
(	O
ZeroDataBlock	int
)	O
return	O
-	O
2	int
;	O
while	O
(	O
(	O
count	int
=	O
GetDataBlock	function
(	O
fd	pointer
,	O
buf	pointer
)	O
)	O
>	O
0	int
)	O
;	O
if	O
(	O
count	int
!=	O
0	int
)	O
return	O
-	O
2	int
;	O
}	O
incode	int
=	O
code	int
;	O
if	O
(	O
code	int
>=	O
max_code	int
)	O
{	O
*	O
sp	pointer
++	O
=	O
firstcode	int
;	O
code	int
=	O
oldcode	int
;	O
}	O
while	O
(	O
code	int
>=	O
clear_code	int
)	O
{	O
*	O
sp	pointer
++	O
=	O
table	array
[	O
1	int
]	O
[	O
code	int
]	O
;	O
if	O
(	O
code	int
==	O
table	array
[	O
0	int
]	O
[	O
code	int
]	O
)	O
{	O
}	O
code	int
=	O
table	array
[	O
0	int
]	O
[	O
code	int
]	O
;	O
}	O
*	O
sp	pointer
++	O
=	O
firstcode	int
=	O
table	array
[	O
1	int
]	O
[	O
code	int
]	O
;	O
if	O
(	O
(	O
code	int
=	O
max_code	int
)	O
<	O
(	O
1	int
<<	O
MAX_LWZ_BITS	int
)	O
)	O
{	O
table	array
[	O
0	int
]	O
[	O
code	int
]	O
=	O
oldcode	int
;	O
table	array
[	O
1	int
]	O
[	O
code	int
]	O
=	O
firstcode	int
;	O
++	O
max_code	int
;	O
if	O
(	O
(	O
max_code	int
>=	O
max_code_size	int
)	O
&&	O
(	O
max_code_size	int
<	O
(	O
1	int
<<	O
MAX_LWZ_BITS	int
)	O
)	O
)	O
{	O
max_code_size	int
*=	O
2	int
;	O
++	O
code_size	int
;	O
}	O
}	O
oldcode	int
=	O
incode	int
;	O
if	O
(	O
sp	pointer
>	O
stack	array
)	O
return	O
*	O
--	O
sp	pointer
;	O
}	O
return	O
code	int
;	O
}	O
static	O
int	O
LWZReadByte	function
(	O
FILE	struct
*	O
fd	pointer
,	O
int	O
flag	int
,	O
int	O
input_code_size	int
)	O
{	O
int	O
rv	int
;	O
rv	int
=	O
LWZReadByte_	function
(	O
fd	pointer
,	O
flag	int
,	O
input_code_size	int
)	O
;	O
if	O
(	O
VERBOSE	int
)	O
printf	function
(	O
"[LWZReadByte(,%d,%d) returning %d]\n"	pointer
,	O
flag	int
,	O
input_code_size	int
,	O
rv	int
)	O
;	O
return	O
(	O
rv	int
)	O
;	O
}	O
static	O
void	O
ReadImage	function
(	O
gdImagePtr	pointer
im	pointer
,	O
FILE	struct
*	O
fd	pointer
,	O
int	O
len	int
,	O
int	O
height	int
,	O
unsigned	O
char	O
(	O
*	O
cmap	pointer
)	O
[	O
256	int
]	O
,	O
int	O
interlace	int
,	O
int	O
ignore	int
)	O
{	O
unsigned	O
char	O
c	int
;	O
int	O
v	int
;	O
int	O
xpos	int
=	O
0	int
,	O
ypos	int
=	O
0	int
,	O
pass	int
=	O
0	int
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
i	int
<	O
gdMaxColors	int
)	O
;	O
i	int
++	O
)	O
{	O
im	pointer
->	O
red	array
[	O
i	int
]	O
=	O
cmap	pointer
[	O
CM_RED	int
]	O
[	O
i	int
]	O
;	O
im	pointer
->	O
green	array
[	O
i	int
]	O
=	O
cmap	pointer
[	O
CM_GREEN	int
]	O
[	O
i	int
]	O
;	O
im	pointer
->	O
blue	array
[	O
i	int
]	O
=	O
cmap	pointer
[	O
CM_BLUE	int
]	O
[	O
i	int
]	O
;	O
im	pointer
->	O
open	array
[	O
i	int
]	O
=	O
1	int
;	O
}	O
im	pointer
->	O
colorsTotal	int
=	O
gdMaxColors	int
;	O
if	O
(	O
!	O
ReadOK	O
(	O
fd	pointer
,	O
&	O
c	int
,	O
1	int
)	O
)	O
{	O
return	O
;	O
}	O
if	O
(	O
LWZReadByte	function
(	O
fd	pointer
,	O
TRUE	int
,	O
c	int
)	O
<	O
0	int
)	O
{	O
return	O
;	O
}	O
if	O
(	O
ignore	int
)	O
{	O
while	O
(	O
LWZReadByte	function
(	O
fd	pointer
,	O
FALSE	int
,	O
c	int
)	O
>=	O
0	int
)	O
;	O
return	O
;	O
}	O
while	O
(	O
(	O
v	int
=	O
LWZReadByte	function
(	O
fd	pointer
,	O
FALSE	int
,	O
c	int
)	O
)	O
>=	O
0	int
)	O
{	O
if	O
(	O
im	pointer
->	O
open	array
[	O
v	int
]	O
)	O
{	O
im	pointer
->	O
open	array
[	O
v	int
]	O
=	O
0	int
;	O
}	O
gdImageSetPixel	function
(	O
im	pointer
,	O
xpos	int
,	O
ypos	int
,	O
v	int
)	O
;	O
++	O
xpos	int
;	O
if	O
(	O
xpos	int
==	O
len	int
)	O
{	O
xpos	int
=	O
0	int
;	O
if	O
(	O
interlace	int
)	O
{	O
switch	O
(	O
pass	int
)	O
{	O
case	O
0	int
:	O
case	O
1	int
:	O
ypos	int
+=	O
8	int
;	O
break	O
;	O
case	O
2	int
:	O
ypos	int
+=	O
4	int
;	O
break	O
;	O
case	O
3	int
:	O
ypos	int
+=	O
2	int
;	O
break	O
;	O
}	O
if	O
(	O
ypos	int
>=	O
height	int
)	O
{	O
++	O
pass	int
;	O
switch	O
(	O
pass	int
)	O
{	O
case	O
1	int
:	O
ypos	int
=	O
4	int
;	O
break	O
;	O
case	O
2	int
:	O
ypos	int
=	O
2	int
;	O
break	O
;	O
case	O
3	int
:	O
ypos	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
goto	O
fini	O
;	O
}	O
}	O
}	O
else	O
{	O
++	O
ypos	int
;	O
}	O
}	O
if	O
(	O
ypos	int
>=	O
height	int
)	O
break	O
;	O
}	O
fini	O
:	O
if	O
(	O
LWZReadByte	function
(	O
fd	pointer
,	O
FALSE	int
,	O
c	int
)	O
>=	O
0	int
)	O
{	O
}	O
}	O
void	O
gdImageRectangle	function
(	O
gdImagePtr	pointer
im	pointer
,	O
int	O
x1	int
,	O
int	O
y1	function
,	O
int	O
x2	int
,	O
int	O
y2	int
,	O
int	O
color	int
)	O
{	O
gdImageLine	function
(	O
im	pointer
,	O
x1	int
,	O
y1	function
,	O
x2	int
,	O
y1	function
,	O
color	int
)	O
;	O
gdImageLine	function
(	O
im	pointer
,	O
x1	int
,	O
y2	int
,	O
x2	int
,	O
y2	int
,	O
color	int
)	O
;	O
gdImageLine	function
(	O
im	pointer
,	O
x1	int
,	O
y1	function
,	O
x1	int
,	O
y2	int
,	O
color	int
)	O
;	O
gdImageLine	function
(	O
im	pointer
,	O
x2	int
,	O
y1	function
,	O
x2	int
,	O
y2	int
,	O
color	int
)	O
;	O
}	O
void	O
gdImageFilledRectangle	function
(	O
gdImagePtr	pointer
im	pointer
,	O
int	O
x1	int
,	O
int	O
y1	function
,	O
int	O
x2	int
,	O
int	O
y2	int
,	O
int	O
color	int
)	O
{	O
int	O
x	int
,	O
y	int
;	O
for	O
(	O
y	int
=	O
y1	function
;	O
(	O
y	int
<=	O
y2	int
)	O
;	O
y	int
++	O
)	O
{	O
for	O
(	O
x	int
=	O
x1	int
;	O
(	O
x	int
<=	O
x2	int
)	O
;	O
x	int
++	O
)	O
{	O
gdImageSetPixel	function
(	O
im	pointer
,	O
x	int
,	O
y	int
,	O
color	int
)	O
;	O
}	O
}	O
}	O
void	O
gdImageCopy	function
(	O
gdImagePtr	pointer
dst	pointer
,	O
gdImagePtr	pointer
src	pointer
,	O
int	O
dstX	int
,	O
int	O
dstY	int
,	O
int	O
srcX	int
,	O
int	O
srcY	int
,	O
int	O
w	int
,	O
int	O
h	int
)	O
{	O
int	O
c	int
;	O
int	O
x	int
,	O
y	int
;	O
int	O
tox	int
,	O
toy	int
;	O
int	O
i	int
;	O
int	O
colorMap	array
[	O
gdMaxColors	int
]	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
i	int
<	O
gdMaxColors	int
)	O
;	O
i	int
++	O
)	O
{	O
colorMap	array
[	O
i	int
]	O
=	O
(	O
-	O
1	int
)	O
;	O
}	O
toy	int
=	O
dstY	int
;	O
for	O
(	O
y	int
=	O
srcY	int
;	O
(	O
y	int
<	O
(	O
srcY	int
+	O
h	int
)	O
)	O
;	O
y	int
++	O
)	O
{	O
tox	int
=	O
dstX	int
;	O
for	O
(	O
x	int
=	O
srcX	int
;	O
(	O
x	int
<	O
(	O
srcX	int
+	O
w	int
)	O
)	O
;	O
x	int
++	O
)	O
{	O
int	O
nc	int
;	O
c	int
=	O
gdImageGetPixel	function
(	O
src	pointer
,	O
x	int
,	O
y	int
)	O
;	O
if	O
(	O
gdImageGetTransparent	O
(	O
src	pointer
)	O
==	O
c	int
)	O
{	O
tox	int
++	O
;	O
continue	O
;	O
}	O
if	O
(	O
colorMap	array
[	O
c	int
]	O
==	O
(	O
-	O
1	int
)	O
)	O
{	O
if	O
(	O
dst	pointer
==	O
src	pointer
)	O
{	O
nc	int
=	O
c	int
;	O
}	O
else	O
{	O
nc	int
=	O
gdImageColorExact	function
(	O
dst	pointer
,	O
src	pointer
->	O
red	array
[	O
c	int
]	O
,	O
src	pointer
->	O
green	array
[	O
c	int
]	O
,	O
src	pointer
->	O
blue	array
[	O
c	int
]	O
)	O
;	O
}	O
if	O
(	O
nc	int
==	O
(	O
-	O
1	int
)	O
)	O
{	O
nc	int
=	O
gdImageColorAllocate	function
(	O
dst	pointer
,	O
src	pointer
->	O
red	array
[	O
c	int
]	O
,	O
src	pointer
->	O
green	array
[	O
c	int
]	O
,	O
src	pointer
->	O
blue	array
[	O
c	int
]	O
)	O
;	O
if	O
(	O
nc	int
==	O
(	O
-	O
1	int
)	O
)	O
{	O
nc	int
=	O
gdImageColorClosest	function
(	O
dst	pointer
,	O
src	pointer
->	O
red	array
[	O
c	int
]	O
,	O
src	pointer
->	O
green	array
[	O
c	int
]	O
,	O
src	pointer
->	O
blue	array
[	O
c	int
]	O
)	O
;	O
}	O
}	O
colorMap	array
[	O
c	int
]	O
=	O
nc	int
;	O
}	O
gdImageSetPixel	function
(	O
dst	pointer
,	O
tox	int
,	O
toy	int
,	O
colorMap	array
[	O
c	int
]	O
)	O
;	O
tox	int
++	O
;	O
}	O
toy	int
++	O
;	O
}	O
}	O
void	O
gdImageCopyResized	function
(	O
gdImagePtr	pointer
dst	pointer
,	O
gdImagePtr	pointer
src	pointer
,	O
int	O
dstX	int
,	O
int	O
dstY	int
,	O
int	O
srcX	int
,	O
int	O
srcY	int
,	O
int	O
dstW	int
,	O
int	O
dstH	int
,	O
int	O
srcW	int
,	O
int	O
srcH	int
)	O
{	O
int	O
c	int
;	O
int	O
x	int
,	O
y	int
;	O
int	O
tox	int
,	O
toy	int
;	O
int	O
ydest	int
;	O
int	O
i	int
;	O
int	O
colorMap	array
[	O
gdMaxColors	int
]	O
;	O
int	O
*	O
stx	pointer
;	O
int	O
*	O
sty	pointer
;	O
double	O
my_accum	double
;	O
stx	pointer
=	O
(	O
int	O
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
srcW	int
)	O
;	O
sty	pointer
=	O
(	O
int	O
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
srcH	int
)	O
;	O
my_accum	double
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
i	int
<	O
srcW	int
)	O
;	O
i	int
++	O
)	O
{	O
int	O
got	int
;	O
my_accum	double
+=	O
(	O
double	O
)	O
dstW	int
/	O
(	O
double	O
)	O
srcW	int
;	O
got	int
=	O
floor	function
(	O
my_accum	double
)	O
;	O
stx	pointer
[	O
i	int
]	O
=	O
got	int
;	O
my_accum	double
-=	O
got	int
;	O
}	O
my_accum	double
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
i	int
<	O
srcH	int
)	O
;	O
i	int
++	O
)	O
{	O
int	O
got	int
;	O
my_accum	double
+=	O
(	O
double	O
)	O
dstH	int
/	O
(	O
double	O
)	O
srcH	int
;	O
got	int
=	O
floor	function
(	O
my_accum	double
)	O
;	O
sty	pointer
[	O
i	int
]	O
=	O
got	int
;	O
my_accum	double
-=	O
got	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
i	int
<	O
gdMaxColors	int
)	O
;	O
i	int
++	O
)	O
{	O
colorMap	array
[	O
i	int
]	O
=	O
(	O
-	O
1	int
)	O
;	O
}	O
toy	int
=	O
dstY	int
;	O
for	O
(	O
y	int
=	O
srcY	int
;	O
(	O
y	int
<	O
(	O
srcY	int
+	O
srcH	int
)	O
)	O
;	O
y	int
++	O
)	O
{	O
for	O
(	O
ydest	int
=	O
0	int
;	O
(	O
ydest	int
<	O
sty	pointer
[	O
y	int
-	O
srcY	int
]	O
)	O
;	O
ydest	int
++	O
)	O
{	O
tox	int
=	O
dstX	int
;	O
for	O
(	O
x	int
=	O
srcX	int
;	O
(	O
x	int
<	O
(	O
srcX	int
+	O
srcW	int
)	O
)	O
;	O
x	int
++	O
)	O
{	O
int	O
nc	int
;	O
if	O
(	O
!	O
stx	pointer
[	O
x	int
-	O
srcX	int
]	O
)	O
{	O
continue	O
;	O
}	O
c	int
=	O
gdImageGetPixel	function
(	O
src	pointer
,	O
x	int
,	O
y	int
)	O
;	O
if	O
(	O
gdImageGetTransparent	O
(	O
src	pointer
)	O
==	O
c	int
)	O
{	O
tox	int
+=	O
stx	pointer
[	O
x	int
-	O
srcX	int
]	O
;	O
continue	O
;	O
}	O
if	O
(	O
colorMap	array
[	O
c	int
]	O
==	O
(	O
-	O
1	int
)	O
)	O
{	O
if	O
(	O
dst	pointer
==	O
src	pointer
)	O
{	O
nc	int
=	O
c	int
;	O
}	O
else	O
{	O
nc	int
=	O
gdImageColorExact	function
(	O
dst	pointer
,	O
src	pointer
->	O
red	array
[	O
c	int
]	O
,	O
src	pointer
->	O
green	array
[	O
c	int
]	O
,	O
src	pointer
->	O
blue	array
[	O
c	int
]	O
)	O
;	O
}	O
if	O
(	O
nc	int
==	O
(	O
-	O
1	int
)	O
)	O
{	O
nc	int
=	O
gdImageColorAllocate	function
(	O
dst	pointer
,	O
src	pointer
->	O
red	array
[	O
c	int
]	O
,	O
src	pointer
->	O
green	array
[	O
c	int
]	O
,	O
src	pointer
->	O
blue	array
[	O
c	int
]	O
)	O
;	O
if	O
(	O
nc	int
==	O
(	O
-	O
1	int
)	O
)	O
{	O
nc	int
=	O
gdImageColorClosest	function
(	O
dst	pointer
,	O
src	pointer
->	O
red	array
[	O
c	int
]	O
,	O
src	pointer
->	O
green	array
[	O
c	int
]	O
,	O
src	pointer
->	O
blue	array
[	O
c	int
]	O
)	O
;	O
}	O
}	O
colorMap	array
[	O
c	int
]	O
=	O
nc	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
i	int
<	O
stx	pointer
[	O
x	int
-	O
srcX	int
]	O
)	O
;	O
i	int
++	O
)	O
{	O
gdImageSetPixel	function
(	O
dst	pointer
,	O
tox	int
,	O
toy	int
,	O
colorMap	array
[	O
c	int
]	O
)	O
;	O
tox	int
++	O
;	O
}	O
}	O
toy	int
++	O
;	O
}	O
}	O
free	function
(	O
stx	pointer
)	O
;	O
free	function
(	O
sty	pointer
)	O
;	O
}	O
int	O
gdGetWord	function
(	O
int	O
*	O
result	pointer
,	O
FILE	struct
*	O
in	pointer
)	O
{	O
int	O
r	int
;	O
r	int
=	O
getc	function
(	O
in	pointer
)	O
;	O
if	O
(	O
r	int
==	O
EOF	O
)	O
{	O
return	O
0	int
;	O
}	O
*	O
result	pointer
=	O
r	int
<<	O
8	int
;	O
r	int
=	O
getc	function
(	O
in	pointer
)	O
;	O
if	O
(	O
r	int
==	O
EOF	O
)	O
{	O
return	O
0	int
;	O
}	O
*	O
result	pointer
+=	O
r	int
;	O
return	O
1	int
;	O
}	O
void	O
gdPutWord	function
(	O
int	O
w	int
,	O
FILE	struct
*	O
out	pointer
)	O
{	O
putc	function
(	O
(	O
unsigned	O
char	O
)	O
(	O
w	int
>>	O
8	int
)	O
,	O
out	pointer
)	O
;	O
putc	function
(	O
(	O
unsigned	O
char	O
)	O
(	O
w	int
&	O
0xFF	int
)	O
,	O
out	pointer
)	O
;	O
}	O
int	O
gdGetByte	function
(	O
int	O
*	O
result	pointer
,	O
FILE	struct
*	O
in	pointer
)	O
{	O
int	O
r	int
;	O
r	int
=	O
getc	function
(	O
in	pointer
)	O
;	O
if	O
(	O
r	int
==	O
EOF	O
)	O
{	O
return	O
0	int
;	O
}	O
*	O
result	pointer
=	O
r	int
;	O
return	O
1	int
;	O
}	O
gdImagePtr	pointer
gdImageCreateFromGd	function
(	O
FILE	struct
*	O
in	pointer
)	O
{	O
int	O
sx	int
,	O
sy	int
;	O
int	O
x	int
,	O
y	int
;	O
int	O
i	int
;	O
gdImagePtr	pointer
im	pointer
;	O
if	O
(	O
!	O
gdGetWord	function
(	O
&	O
sx	int
,	O
in	pointer
)	O
)	O
{	O
goto	O
fail1	O
;	O
}	O
if	O
(	O
!	O
gdGetWord	function
(	O
&	O
sy	int
,	O
in	pointer
)	O
)	O
{	O
goto	O
fail1	O
;	O
}	O
im	pointer
=	O
gdImageCreate	function
(	O
sx	int
,	O
sy	int
)	O
;	O
if	O
(	O
!	O
gdGetByte	function
(	O
&	O
im	pointer
->	O
colorsTotal	int
,	O
in	pointer
)	O
)	O
{	O
goto	O
fail2	O
;	O
}	O
if	O
(	O
!	O
gdGetWord	function
(	O
&	O
im	pointer
->	O
transparent	int
,	O
in	pointer
)	O
)	O
{	O
goto	O
fail2	O
;	O
}	O
if	O
(	O
im	pointer
->	O
transparent	int
==	O
257	int
)	O
{	O
im	pointer
->	O
transparent	int
=	O
(	O
-	O
1	int
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
i	int
<	O
gdMaxColors	int
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
!	O
gdGetByte	function
(	O
&	O
im	pointer
->	O
red	array
[	O
i	int
]	O
,	O
in	pointer
)	O
)	O
{	O
goto	O
fail2	O
;	O
}	O
if	O
(	O
!	O
gdGetByte	function
(	O
&	O
im	pointer
->	O
green	array
[	O
i	int
]	O
,	O
in	pointer
)	O
)	O
{	O
goto	O
fail2	O
;	O
}	O
if	O
(	O
!	O
gdGetByte	function
(	O
&	O
im	pointer
->	O
blue	array
[	O
i	int
]	O
,	O
in	pointer
)	O
)	O
{	O
goto	O
fail2	O
;	O
}	O
}	O
for	O
(	O
y	int
=	O
0	int
;	O
(	O
y	int
<	O
sy	int
)	O
;	O
y	int
++	O
)	O
{	O
for	O
(	O
x	int
=	O
0	int
;	O
(	O
x	int
<	O
sx	int
)	O
;	O
x	int
++	O
)	O
{	O
int	O
ch	int
;	O
ch	int
=	O
getc	function
(	O
in	pointer
)	O
;	O
if	O
(	O
ch	int
==	O
EOF	O
)	O
{	O
gdImageDestroy	function
(	O
im	pointer
)	O
;	O
return	O
0	int
;	O
}	O
im	pointer
->	O
pixels	pointer
[	O
y	int
]	O
[	O
x	int
]	O
=	O
ch	int
;	O
}	O
}	O
return	O
im	pointer
;	O
fail2	O
:	O
gdImageDestroy	function
(	O
im	pointer
)	O
;	O
fail1	O
:	O
return	O
0	int
;	O
}	O
void	O
gdImageGd	function
(	O
gdImagePtr	pointer
im	pointer
,	O
FILE	struct
*	O
out	pointer
)	O
{	O
int	O
x	int
,	O
y	int
;	O
int	O
i	int
;	O
int	O
trans	int
;	O
gdPutWord	function
(	O
im	pointer
->	O
sx	int
,	O
out	pointer
)	O
;	O
gdPutWord	function
(	O
im	pointer
->	O
sy	int
,	O
out	pointer
)	O
;	O
putc	function
(	O
(	O
unsigned	O
char	O
)	O
im	pointer
->	O
colorsTotal	int
,	O
out	pointer
)	O
;	O
trans	int
=	O
im	pointer
->	O
transparent	int
;	O
if	O
(	O
trans	int
==	O
(	O
-	O
1	int
)	O
)	O
{	O
trans	int
=	O
257	int
;	O
}	O
gdPutWord	function
(	O
trans	int
,	O
out	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
i	int
<	O
gdMaxColors	int
)	O
;	O
i	int
++	O
)	O
{	O
putc	function
(	O
(	O
unsigned	O
char	O
)	O
im	pointer
->	O
red	array
[	O
i	int
]	O
,	O
out	pointer
)	O
;	O
putc	function
(	O
(	O
unsigned	O
char	O
)	O
im	pointer
->	O
green	array
[	O
i	int
]	O
,	O
out	pointer
)	O
;	O
putc	function
(	O
(	O
unsigned	O
char	O
)	O
im	pointer
->	O
blue	array
[	O
i	int
]	O
,	O
out	pointer
)	O
;	O
}	O
for	O
(	O
y	int
=	O
0	int
;	O
(	O
y	int
<	O
im	pointer
->	O
sy	int
)	O
;	O
y	int
++	O
)	O
{	O
for	O
(	O
x	int
=	O
0	int
;	O
(	O
x	int
<	O
im	pointer
->	O
sx	int
)	O
;	O
x	int
++	O
)	O
{	O
putc	function
(	O
(	O
unsigned	O
char	O
)	O
im	pointer
->	O
pixels	pointer
[	O
y	int
]	O
[	O
x	int
]	O
,	O
out	pointer
)	O
;	O
}	O
}	O
}	O
gdImagePtr	pointer
gdImageCreateFromXbm	function
(	O
FILE	struct
*	O
fd	pointer
)	O
{	O
gdImagePtr	pointer
im	pointer
;	O
int	O
bit	int
;	O
int	O
w	int
,	O
h	int
;	O
int	O
bytes	int
;	O
int	O
ch	int
;	O
int	O
i	int
,	O
x	int
,	O
y	int
;	O
char	O
*	O
sp	pointer
;	O
char	O
s	pointer
[	O
161	int
]	O
;	O
if	O
(	O
!	O
fgets	function
(	O
s	pointer
,	O
160	int
,	O
fd	pointer
)	O
)	O
{	O
return	O
0	int
;	O
}	O
sp	pointer
=	O
&	O
s	pointer
[	O
0	int
]	O
;	O
sp	pointer
=	O
strchr	function
(	O
sp	pointer
,	O
' '	O
)	O
;	O
if	O
(	O
!	O
sp	pointer
)	O
{	O
return	O
0	int
;	O
}	O
sp	pointer
++	O
;	O
sp	pointer
=	O
strchr	function
(	O
sp	pointer
,	O
' '	O
)	O
;	O
if	O
(	O
!	O
sp	pointer
)	O
{	O
return	O
0	int
;	O
}	O
w	int
=	O
atoi	function
(	O
sp	pointer
+	O
1	int
)	O
;	O
if	O
(	O
!	O
w	int
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
fgets	function
(	O
s	pointer
,	O
160	int
,	O
fd	pointer
)	O
)	O
{	O
return	O
0	int
;	O
}	O
sp	pointer
=	O
s	pointer
;	O
sp	pointer
=	O
strchr	function
(	O
sp	pointer
,	O
' '	O
)	O
;	O
if	O
(	O
!	O
sp	pointer
)	O
{	O
return	O
0	int
;	O
}	O
sp	pointer
++	O
;	O
sp	pointer
=	O
strchr	function
(	O
sp	pointer
,	O
' '	O
)	O
;	O
if	O
(	O
!	O
sp	pointer
)	O
{	O
return	O
0	int
;	O
}	O
h	int
=	O
atoi	function
(	O
sp	pointer
+	O
1	int
)	O
;	O
if	O
(	O
!	O
h	int
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
fgets	function
(	O
s	pointer
,	O
160	int
,	O
fd	pointer
)	O
)	O
{	O
return	O
0	int
;	O
}	O
bytes	int
=	O
(	O
w	int
*	O
h	int
/	O
8	int
)	O
+	O
1	int
;	O
im	pointer
=	O
gdImageCreate	function
(	O
w	int
,	O
h	int
)	O
;	O
gdImageColorAllocate	function
(	O
im	pointer
,	O
255	int
,	O
255	int
,	O
255	int
)	O
;	O
gdImageColorAllocate	function
(	O
im	pointer
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
x	int
=	O
0	int
;	O
y	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
i	int
<	O
bytes	int
)	O
;	O
i	int
++	O
)	O
{	O
char	O
h	int
[	O
3	int
]	O
;	O
int	O
b	int
;	O
while	O
(	O
1	int
)	O
{	O
ch	int
=	O
getc	function
(	O
fd	pointer
)	O
;	O
if	O
(	O
ch	int
==	O
EOF	O
)	O
{	O
goto	O
fail	O
;	O
}	O
if	O
(	O
ch	int
==	O
'x'	O
)	O
{	O
break	O
;	O
}	O
}	O
ch	int
=	O
getc	function
(	O
fd	pointer
)	O
;	O
if	O
(	O
ch	int
==	O
EOF	O
)	O
{	O
goto	O
fail	O
;	O
}	O
h	int
[	O
0	int
]	O
=	O
ch	int
;	O
ch	int
=	O
getc	function
(	O
fd	pointer
)	O
;	O
if	O
(	O
ch	int
==	O
EOF	O
)	O
{	O
goto	O
fail	O
;	O
}	O
h	int
[	O
1	int
]	O
=	O
ch	int
;	O
h	int
[	O
2	int
]	O
=	O
'\0'	O
;	O
sscanf	function
(	O
h	int
,	O
"%x"	pointer
,	O
&	O
b	int
)	O
;	O
for	O
(	O
bit	int
=	O
1	int
;	O
(	O
bit	int
<=	O
128	int
)	O
;	O
(	O
bit	int
=	O
bit	int
<<	O
1	int
)	O
)	O
{	O
gdImageSetPixel	function
(	O
im	pointer
,	O
x	int
++	O
,	O
y	int
,	O
(	O
b	int
&	O
bit	int
)	O
?	O
1	int
:	O
0	int
)	O
;	O
if	O
(	O
x	int
==	O
im	pointer
->	O
sx	int
)	O
{	O
x	int
=	O
0	int
;	O
y	int
++	O
;	O
if	O
(	O
y	int
==	O
im	pointer
->	O
sy	int
)	O
{	O
return	O
im	pointer
;	O
}	O
break	O
;	O
}	O
}	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"Error: bug in gdImageCreateFromXbm!\n"	pointer
)	O
;	O
return	O
0	int
;	O
fail	O
:	O
gdImageDestroy	function
(	O
im	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
gdImagePolygon	function
(	O
gdImagePtr	pointer
im	pointer
,	O
gdPointPtr	pointer
p	pointer
,	O
int	O
n	int
,	O
int	O
c	int
)	O
{	O
int	O
i	int
;	O
int	O
lx	int
,	O
ly	int
;	O
if	O
(	O
!	O
n	int
)	O
{	O
return	O
;	O
}	O
lx	int
=	O
p	pointer
->	O
x	int
;	O
ly	int
=	O
p	pointer
->	O
y	int
;	O
gdImageLine	function
(	O
im	pointer
,	O
lx	int
,	O
ly	int
,	O
p	pointer
[	O
n	int
-	O
1	int
]	O
.	O
x	int
,	O
p	pointer
[	O
n	int
-	O
1	int
]	O
.	O
y	int
,	O
c	int
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
(	O
i	int
<	O
n	int
)	O
;	O
i	int
++	O
)	O
{	O
p	pointer
++	O
;	O
gdImageLine	function
(	O
im	pointer
,	O
lx	int
,	O
ly	int
,	O
p	pointer
->	O
x	int
,	O
p	pointer
->	O
y	int
,	O
c	int
)	O
;	O
lx	int
=	O
p	pointer
->	O
x	int
;	O
ly	int
=	O
p	pointer
->	O
y	int
;	O
}	O
}	O
int	O
gdCompareInt	function
(	O
const	O
void	O
*	O
a	pointer
,	O
const	O
void	O
*	O
b	int
)	O
;	O
void	O
gdImageFilledPolygon	function
(	O
gdImagePtr	pointer
im	pointer
,	O
gdPointPtr	pointer
p	pointer
,	O
int	O
n	int
,	O
int	O
c	int
)	O
{	O
int	O
i	int
;	O
int	O
y	int
;	O
int	O
y1	function
,	O
y2	int
;	O
int	O
ints	int
;	O
if	O
(	O
!	O
n	int
)	O
{	O
return	O
;	O
}	O
if	O
(	O
!	O
im	pointer
->	O
polyAllocated	int
)	O
{	O
im	pointer
->	O
polyInts	pointer
=	O
(	O
int	O
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
n	int
)	O
;	O
im	pointer
->	O
polyAllocated	int
=	O
n	int
;	O
}	O
if	O
(	O
im	pointer
->	O
polyAllocated	int
<	O
n	int
)	O
{	O
while	O
(	O
im	pointer
->	O
polyAllocated	int
<	O
n	int
)	O
{	O
im	pointer
->	O
polyAllocated	int
*=	O
2	int
;	O
}	O
im	pointer
->	O
polyInts	pointer
=	O
(	O
int	O
*	O
)	O
realloc	function
(	O
im	pointer
->	O
polyInts	pointer
,	O
sizeof	O
(	O
int	O
)	O
*	O
im	pointer
->	O
polyAllocated	int
)	O
;	O
}	O
y1	function
=	O
p	pointer
[	O
0	int
]	O
.	O
y	int
;	O
y2	int
=	O
p	pointer
[	O
0	int
]	O
.	O
y	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
(	O
i	int
<	O
n	int
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
p	pointer
[	O
i	int
]	O
.	O
y	int
<	O
y1	function
)	O
{	O
y1	function
=	O
p	pointer
[	O
i	int
]	O
.	O
y	int
;	O
}	O
if	O
(	O
p	pointer
[	O
i	int
]	O
.	O
y	int
>	O
y2	int
)	O
{	O
y2	int
=	O
p	pointer
[	O
i	int
]	O
.	O
y	int
;	O
}	O
}	O
for	O
(	O
y	int
=	O
y1	function
;	O
(	O
y	int
<	O
y2	int
)	O
;	O
y	int
++	O
)	O
{	O
int	O
interLast	int
=	O
0	int
;	O
int	O
dirLast	int
=	O
0	int
;	O
int	O
interFirst	int
=	O
1	int
;	O
ints	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
i	int
<=	O
n	int
)	O
;	O
i	int
++	O
)	O
{	O
int	O
x1	int
,	O
x2	int
;	O
int	O
y1	function
,	O
y2	int
;	O
int	O
dir	int
;	O
int	O
ind1	int
,	O
ind2	int
;	O
int	O
lastInd1	int
=	O
0	int
;	O
if	O
(	O
(	O
i	int
==	O
n	int
)	O
||	O
(	O
!	O
i	int
)	O
)	O
{	O
ind1	int
=	O
n	int
-	O
1	int
;	O
ind2	int
=	O
0	int
;	O
}	O
else	O
{	O
ind1	int
=	O
i	int
-	O
1	int
;	O
ind2	int
=	O
i	int
;	O
}	O
y1	function
=	O
p	pointer
[	O
ind1	int
]	O
.	O
y	int
;	O
y2	int
=	O
p	pointer
[	O
ind2	int
]	O
.	O
y	int
;	O
if	O
(	O
y1	function
<	O
y2	int
)	O
{	O
y1	function
=	O
p	pointer
[	O
ind1	int
]	O
.	O
y	int
;	O
y2	int
=	O
p	pointer
[	O
ind2	int
]	O
.	O
y	int
;	O
x1	int
=	O
p	pointer
[	O
ind1	int
]	O
.	O
x	int
;	O
x2	int
=	O
p	pointer
[	O
ind2	int
]	O
.	O
x	int
;	O
dir	int
=	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
y1	function
>	O
y2	int
)	O
{	O
y2	int
=	O
p	pointer
[	O
ind1	int
]	O
.	O
y	int
;	O
y1	function
=	O
p	pointer
[	O
ind2	int
]	O
.	O
y	int
;	O
x2	int
=	O
p	pointer
[	O
ind1	int
]	O
.	O
x	int
;	O
x1	int
=	O
p	pointer
[	O
ind2	int
]	O
.	O
x	int
;	O
dir	int
=	O
1	int
;	O
}	O
else	O
{	O
gdImageLine	function
(	O
im	pointer
,	O
p	pointer
[	O
ind1	int
]	O
.	O
x	int
,	O
y1	function
,	O
p	pointer
[	O
ind2	int
]	O
.	O
x	int
,	O
y1	function
,	O
c	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
(	O
y	int
>=	O
y1	function
)	O
&&	O
(	O
y	int
<=	O
y2	int
)	O
)	O
{	O
int	O
inter	int
=	O
(	O
y	int
-	O
y1	function
)	O
*	O
(	O
x2	int
-	O
x1	int
)	O
/	O
(	O
y2	int
-	O
y1	function
)	O
+	O
x1	int
;	O
if	O
(	O
!	O
interFirst	int
)	O
{	O
if	O
(	O
(	O
p	pointer
[	O
ind1	int
]	O
.	O
y	int
==	O
p	pointer
[	O
lastInd1	int
]	O
.	O
y	int
)	O
&&	O
(	O
p	pointer
[	O
ind1	int
]	O
.	O
x	int
!=	O
p	pointer
[	O
lastInd1	int
]	O
.	O
x	int
)	O
)	O
{	O
if	O
(	O
dir	int
==	O
dirLast	int
)	O
{	O
if	O
(	O
inter	int
>	O
interLast	int
)	O
{	O
im	pointer
->	O
polyInts	pointer
[	O
ints	int
]	O
=	O
inter	int
;	O
}	O
else	O
{	O
}	O
continue	O
;	O
}	O
}	O
if	O
(	O
inter	int
==	O
interLast	int
)	O
{	O
if	O
(	O
dir	int
==	O
dirLast	int
)	O
{	O
continue	O
;	O
}	O
}	O
}	O
if	O
(	O
i	int
>	O
0	int
)	O
{	O
im	pointer
->	O
polyInts	pointer
[	O
ints	int
++	O
]	O
=	O
inter	int
;	O
}	O
lastInd1	int
=	O
i	int
;	O
dirLast	int
=	O
dir	int
;	O
interLast	int
=	O
inter	int
;	O
interFirst	int
=	O
0	int
;	O
}	O
}	O
qsort	function
(	O
im	pointer
->	O
polyInts	pointer
,	O
ints	int
,	O
sizeof	O
(	O
int	O
)	O
,	O
gdCompareInt	function
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
i	int
<	O
(	O
ints	int
-	O
1	int
)	O
)	O
;	O
i	int
+=	O
2	int
)	O
{	O
gdImageLine	function
(	O
im	pointer
,	O
im	pointer
->	O
polyInts	pointer
[	O
i	int
]	O
,	O
y	int
,	O
im	pointer
->	O
polyInts	pointer
[	O
i	int
+	O
1	int
]	O
,	O
y	int
,	O
c	int
)	O
;	O
}	O
}	O
}	O
int	O
gdCompareInt	function
(	O
const	O
void	O
*	O
a	pointer
,	O
const	O
void	O
*	O
b	int
)	O
{	O
return	O
(	O
*	O
(	O
const	O
int	O
*	O
)	O
a	pointer
)	O
-	O
(	O
*	O
(	O
const	O
int	O
*	O
)	O
b	int
)	O
;	O
}	O
void	O
gdImageSetStyle	function
(	O
gdImagePtr	pointer
im	pointer
,	O
int	O
*	O
style	pointer
,	O
int	O
noOfPixels	int
)	O
{	O
if	O
(	O
im	pointer
->	O
style	pointer
)	O
{	O
free	function
(	O
im	pointer
->	O
style	pointer
)	O
;	O
}	O
im	pointer
->	O
style	pointer
=	O
(	O
int	O
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
noOfPixels	int
)	O
;	O
memcpy	function
(	O
im	pointer
->	O
style	pointer
,	O
style	pointer
,	O
sizeof	O
(	O
int	O
)	O
*	O
noOfPixels	int
)	O
;	O
im	pointer
->	O
styleLength	int
=	O
noOfPixels	int
;	O
im	pointer
->	O
stylePos	int
=	O
0	int
;	O
}	O
void	O
gdImageSetBrush	function
(	O
gdImagePtr	pointer
im	pointer
,	O
gdImagePtr	pointer
brush	pointer
)	O
{	O
int	O
i	int
;	O
im	pointer
->	O
brush	pointer
=	O
brush	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
i	int
<	O
gdImageColorsTotal	O
(	O
brush	pointer
)	O
)	O
;	O
i	int
++	O
)	O
{	O
int	O
index	function
;	O
index	function
=	O
gdImageColorExact	function
(	O
im	pointer
,	O
gdImageRed	O
(	O
brush	pointer
,	O
i	int
)	O
,	O
gdImageGreen	O
(	O
brush	pointer
,	O
i	int
)	O
,	O
gdImageBlue	O
(	O
brush	pointer
,	O
i	int
)	O
)	O
;	O
if	O
(	O
index	function
==	O
(	O
-	O
1	int
)	O
)	O
{	O
index	function
=	O
gdImageColorAllocate	function
(	O
im	pointer
,	O
gdImageRed	O
(	O
brush	pointer
,	O
i	int
)	O
,	O
gdImageGreen	O
(	O
brush	pointer
,	O
i	int
)	O
,	O
gdImageBlue	O
(	O
brush	pointer
,	O
i	int
)	O
)	O
;	O
if	O
(	O
index	function
==	O
(	O
-	O
1	int
)	O
)	O
{	O
index	function
=	O
gdImageColorClosest	function
(	O
im	pointer
,	O
gdImageRed	O
(	O
brush	pointer
,	O
i	int
)	O
,	O
gdImageGreen	O
(	O
brush	pointer
,	O
i	int
)	O
,	O
gdImageBlue	O
(	O
brush	pointer
,	O
i	int
)	O
)	O
;	O
}	O
}	O
im	pointer
->	O
brushColorMap	array
[	O
i	int
]	O
=	O
index	function
;	O
}	O
}	O
void	O
gdImageSetTile	function
(	O
gdImagePtr	pointer
im	pointer
,	O
gdImagePtr	pointer
tile	pointer
)	O
{	O
int	O
i	int
;	O
im	pointer
->	O
tile	pointer
=	O
tile	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
i	int
<	O
gdImageColorsTotal	O
(	O
tile	pointer
)	O
)	O
;	O
i	int
++	O
)	O
{	O
int	O
index	function
;	O
index	function
=	O
gdImageColorExact	function
(	O
im	pointer
,	O
gdImageRed	O
(	O
tile	pointer
,	O
i	int
)	O
,	O
gdImageGreen	O
(	O
tile	pointer
,	O
i	int
)	O
,	O
gdImageBlue	O
(	O
tile	pointer
,	O
i	int
)	O
)	O
;	O
if	O
(	O
index	function
==	O
(	O
-	O
1	int
)	O
)	O
{	O
index	function
=	O
gdImageColorAllocate	function
(	O
im	pointer
,	O
gdImageRed	O
(	O
tile	pointer
,	O
i	int
)	O
,	O
gdImageGreen	O
(	O
tile	pointer
,	O
i	int
)	O
,	O
gdImageBlue	O
(	O
tile	pointer
,	O
i	int
)	O
)	O
;	O
if	O
(	O
index	function
==	O
(	O
-	O
1	int
)	O
)	O
{	O
index	function
=	O
gdImageColorClosest	function
(	O
im	pointer
,	O
gdImageRed	O
(	O
tile	pointer
,	O
i	int
)	O
,	O
gdImageGreen	O
(	O
tile	pointer
,	O
i	int
)	O
,	O
gdImageBlue	O
(	O
tile	pointer
,	O
i	int
)	O
)	O
;	O
}	O
}	O
im	pointer
->	O
tileColorMap	array
[	O
i	int
]	O
=	O
index	function
;	O
}	O
}	O
void	O
gdImageInterlace	function
(	O
gdImagePtr	pointer
im	pointer
,	O
int	O
interlaceArg	int
)	O
{	O
im	pointer
->	O
interlace	int
=	O
interlaceArg	int
;	O
}	O
