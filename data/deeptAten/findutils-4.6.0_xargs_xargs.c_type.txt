extern	O
char	O
*	O
version_string	pointer
;	O
static	O
FILE	struct
*	O
input_stream	pointer
;	O
static	O
char	O
*	O
linebuf	pointer
;	O
static	O
int	O
keep_stdin	int
=	O
0	int
;	O
static	O
size_t	long
lineno	long
=	O
0	int
;	O
static	O
struct	O
buildcmd_state	struct
bc_state	struct
;	O
static	O
struct	O
buildcmd_control	struct
bc_ctl	struct
;	O
static	O
int	O
nullwarning_given	int
=	O
0	int
;	O
static	O
char	O
*	O
eof_str	pointer
=	O
NULL	O
;	O
static	O
bool	bool
initial_args	int
=	O
true	int
;	O
static	O
volatile	O
sig_atomic_t	int
proc_max	int
=	O
1	int
;	O
static	O
bool	bool
procs_executed	bool
=	O
false	int
;	O
static	O
unsigned	O
long	O
int	O
procs_executing	long
=	O
0uL	int
;	O
static	O
pid_t	int
*	O
pids	pointer
=	O
NULL	O
;	O
static	O
size_t	long
pids_alloc	long
=	O
0u	int
;	O
static	O
pid_t	int
parent	int
;	O
static	O
volatile	O
sig_atomic_t	int
stop_waiting	int
=	O
0	int
;	O
static	O
volatile	O
int	O
child_error	int
=	O
EXIT_SUCCESS	int
;	O
static	O
volatile	O
int	O
original_exit_value	int
;	O
static	O
bool	bool
print_command	bool
=	O
false	int
;	O
static	O
bool	bool
query_before_executing	bool
=	O
false	int
;	O
static	O
char	O
input_delimiter	char
=	O
'\0'	O
;	O
static	O
char	O
*	O
slot_var_name	pointer
=	O
NULL	O
;	O
enum	O
LongOptionIdentifier	enum
{	O
PROCESS_SLOT_VAR	int
=	O
CHAR_MAX	O
+	O
1	int
}	O
;	O
static	O
struct	O
option	struct
const	O
longopts	array
[	O
]	O
=	O
{	O
{	O
"null"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'0'	O
}	O
,	O
{	O
"arg-file"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'a'	O
}	O
,	O
{	O
"delimiter"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'd'	O
}	O
,	O
{	O
"eof"	pointer
,	O
optional_argument	int
,	O
NULL	O
,	O
'e'	O
}	O
,	O
{	O
"replace"	pointer
,	O
optional_argument	int
,	O
NULL	O
,	O
'I'	O
}	O
,	O
{	O
"max-lines"	pointer
,	O
optional_argument	int
,	O
NULL	O
,	O
'l'	O
}	O
,	O
{	O
"max-args"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'n'	O
}	O
,	O
{	O
"interactive"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'p'	O
}	O
,	O
{	O
"no-run-if-empty"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'r'	O
}	O
,	O
{	O
"max-chars"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
's'	O
}	O
,	O
{	O
"verbose"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
't'	O
}	O
,	O
{	O
"show-limits"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'S'	O
}	O
,	O
{	O
"exit"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'x'	O
}	O
,	O
{	O
"max-procs"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'P'	O
}	O
,	O
{	O
"process-slot-var"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
PROCESS_SLOT_VAR	int
}	O
,	O
{	O
"version"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'v'	O
}	O
,	O
{	O
"help"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'h'	O
}	O
,	O
{	O
NULL	O
,	O
no_argument	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
enum	O
XargsStatusValues	enum
{	O
XARGS_EXIT_CLIENT_EXIT_NONZERO	int
=	O
123	int
,	O
XARGS_EXIT_CLIENT_EXIT_255	int
=	O
124	int
,	O
XARGS_EXIT_CLIENT_FATAL_SIG	int
=	O
125	int
,	O
XARGS_EXIT_COMMAND_CANNOT_BE_RUN	int
=	O
126	int
,	O
XARGS_EXIT_COMMAND_NOT_FOUND	int
=	O
127	int
,	O
}	O
;	O
enum	O
ClientStatusValues	enum
{	O
CHILD_EXIT_PLEASE_STOP_IMMEDIATELY	int
=	O
255	int
}	O
;	O
static	O
int	O
read_line	function
(	O
void	O
)	O
;	O
static	O
int	O
read_string	function
(	O
void	O
)	O
;	O
static	O
bool	bool
print_args	function
(	O
bool	bool
ask	bool
)	O
;	O
static	O
int	O
xargs_do_exec	function
(	O
struct	O
buildcmd_control	struct
*	O
ctl	pointer
,	O
void	O
*	O
usercontext	pointer
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
;	O
static	O
void	O
exec_if_possible	function
(	O
void	O
)	O
;	O
static	O
unsigned	O
int	O
add_proc	function
(	O
pid_t	int
pid	int
)	O
;	O
static	O
void	O
wait_for_proc	function
(	O
bool	bool
all	bool
,	O
unsigned	O
int	O
minreap	int
)	O
;	O
static	O
void	O
wait_for_proc_all	function
(	O
void	O
)	O
;	O
static	O
void	O
increment_proc_max	function
(	O
int	O
)	O
;	O
static	O
void	O
decrement_proc_max	function
(	O
int	O
)	O
;	O
static	O
long	O
parse_num	function
(	O
char	O
*	O
str	pointer
,	O
int	O
option	struct
,	O
long	O
min	long
,	O
long	O
max	long
,	O
int	O
fatal	int
)	O
;	O
static	O
void	O
usage	function
(	O
FILE	struct
*	O
stream	pointer
)	O
;	O
static	O
char	O
get_char_oct_or_hex_escape	function
(	O
const	O
char	O
*	O
s	enum
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
int	O
base	int
=	O
8	int
;	O
unsigned	O
long	O
val	int
;	O
char	O
*	O
endp	pointer
;	O
assert	O
(	O
'\\'	O
==	O
s	enum
[	O
0	int
]	O
)	O
;	O
if	O
(	O
'x'	O
==	O
s	enum
[	O
1	int
]	O
)	O
{	O
p	pointer
=	O
s	enum
+	O
2	int
;	O
base	int
=	O
16	int
;	O
}	O
else	O
if	O
(	O
isdigit	function
(	O
(	O
unsigned	O
char	O
)	O
s	enum
[	O
1	int
]	O
)	O
)	O
{	O
p	pointer
=	O
s	enum
+	O
1	int
;	O
base	int
=	O
8	int
;	O
}	O
else	O
{	O
p	pointer
=	O
NULL	O
;	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"Invalid escape sequence %s in input delimiter specification."	pointer
)	O
,	O
s	enum
)	O
;	O
}	O
errno	O
=	O
0	int
;	O
endp	pointer
=	O
NULL	O
;	O
val	int
=	O
strtoul	function
(	O
p	pointer
,	O
&	O
endp	pointer
,	O
base	int
)	O
;	O
if	O
(	O
(	O
ULONG_MAX	O
==	O
val	int
&&	O
ERANGE	int
==	O
errno	O
)	O
||	O
(	O
val	int
>	O
UCHAR_MAX	O
)	O
)	O
{	O
if	O
(	O
16	int
==	O
base	int
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"Invalid escape sequence %s in input delimiter specification; character values must not exceed %lx."	pointer
)	O
,	O
s	enum
,	O
(	O
unsigned	O
long	O
)	O
UCHAR_MAX	O
)	O
;	O
}	O
else	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"Invalid escape sequence %s in input delimiter specification; character values must not exceed %lo."	pointer
)	O
,	O
s	enum
,	O
(	O
unsigned	O
long	O
)	O
UCHAR_MAX	O
)	O
;	O
}	O
}	O
if	O
(	O
0	int
!=	O
*	O
endp	pointer
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"Invalid escape sequence %s in input delimiter specification; trailing characters %s not recognised."	pointer
)	O
,	O
s	enum
,	O
endp	pointer
)	O
;	O
}	O
return	O
(	O
char	O
)	O
val	int
;	O
}	O
static	O
char	O
get_input_delimiter	function
(	O
const	O
char	O
*	O
s	enum
)	O
{	O
if	O
(	O
1	int
==	O
strlen	function
(	O
s	enum
)	O
)	O
{	O
return	O
s	enum
[	O
0	int
]	O
;	O
}	O
else	O
{	O
if	O
(	O
'\\'	O
==	O
s	enum
[	O
0	int
]	O
)	O
{	O
switch	O
(	O
s	enum
[	O
1	int
]	O
)	O
{	O
case	O
'a'	O
:	O
return	O
'\a'	O
;	O
case	O
'b'	O
:	O
return	O
'\b'	O
;	O
case	O
'f'	O
:	O
return	O
'\f'	O
;	O
case	O
'n'	O
:	O
return	O
'\n'	O
;	O
case	O
'r'	O
:	O
return	O
'\r'	O
;	O
case	O
't'	O
:	O
return	O
'\t'	O
;	O
case	O
'v'	O
:	O
return	O
'\v'	O
;	O
case	O
'\\'	O
:	O
return	O
'\\'	O
;	O
default	O
:	O
return	O
get_char_oct_or_hex_escape	function
(	O
s	enum
)	O
;	O
}	O
}	O
else	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"Invalid input delimiter specification %s: the delimiter must be either a single character or an escape sequence starting with \\."	pointer
)	O
,	O
s	enum
)	O
;	O
return	O
0	int
;	O
}	O
}	O
}	O
static	O
void	O
noop	function
(	O
void	O
)	O
{	O
}	O
static	O
void	O
fail_due_to_env_size	function
(	O
void	O
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"environment is too large for exec"	pointer
)	O
)	O
;	O
}	O
static	O
size_t	long
smaller_of	function
(	O
size_t	long
a	long
,	O
size_t	long
b	long
)	O
{	O
if	O
(	O
a	long
<	O
b	long
)	O
return	O
a	long
;	O
else	O
return	O
b	long
;	O
}	O
static	O
FILE	struct
*	O
fopen_cloexec_for_read_only	function
(	O
const	O
char	O
*	O
file_name	pointer
)	O
{	O
int	O
fd	int
=	O
open_cloexec	function
(	O
file_name	pointer
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
{	O
return	O
NULL	O
;	O
}	O
else	O
{	O
FILE	struct
*	O
result	pointer
=	O
fdopen	function
(	O
fd	int
,	O
"r"	pointer
)	O
;	O
if	O
(	O
!	O
result	pointer
)	O
{	O
int	O
saved_errno	int
=	O
errno	O
;	O
close	pointer
(	O
fd	int
)	O
;	O
errno	O
=	O
saved_errno	int
;	O
return	O
NULL	O
;	O
}	O
return	O
result	pointer
;	O
}	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
optc	int
,	O
option_index	int
;	O
int	O
show_limits	int
=	O
0	int
;	O
int	O
always_run_command	int
=	O
1	int
;	O
const	O
char	O
*	O
input_file	pointer
=	O
"-"	pointer
;	O
char	O
default_cmd	array
[	O
]	O
=	O
"echo"	pointer
;	O
char	O
*	O
default_arglist	array
[	O
1	int
]	O
;	O
int	O
(	O
*	O
read_args	pointer
)	O
(	O
void	O
)	O
=	O
read_line	function
;	O
void	O
(	O
*	O
act_on_init_result	pointer
)	O
(	O
void	O
)	O
=	O
noop	function
;	O
enum	O
BC_INIT_STATUS	enum
bcstatus	enum
;	O
enum	O
{	O
XARGS_POSIX_HEADROOM	int
=	O
2048u	int
}	O
;	O
struct	O
sigaction	struct
sigact	struct
;	O
if	O
(	O
argv	pointer
[	O
0	int
]	O
)	O
set_program_name	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
else	O
set_program_name	function
(	O
"xargs"	pointer
)	O
;	O
remember_non_cloexec_fds	function
(	O
)	O
;	O
parent	int
=	O
getpid	function
(	O
)	O
;	O
original_exit_value	int
=	O
EXIT_SUCCESS	int
;	O
setlocale	function
(	O
LC_ALL	O
,	O
""	pointer
)	O
;	O
bindtextdomain	function
(	O
PACKAGE	pointer
,	O
LOCALEDIR	O
)	O
;	O
textdomain	function
(	O
PACKAGE	pointer
)	O
;	O
if	O
(	O
atexit	function
(	O
close_stdin	function
)	O
||	O
atexit	function
(	O
wait_for_proc_all	function
)	O
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"The atexit library function failed"	pointer
)	O
)	O
;	O
}	O
bcstatus	enum
=	O
bc_init_controlinfo	function
(	O
&	O
bc_ctl	struct
,	O
XARGS_POSIX_HEADROOM	int
)	O
;	O
if	O
(	O
BC_INIT_ENV_TOO_BIG	int
==	O
bcstatus	enum
)	O
{	O
act_on_init_result	pointer
=	O
fail_due_to_env_size	function
;	O
}	O
else	O
if	O
(	O
BC_INIT_CANNOT_ACCOMODATE_HEADROOM	int
==	O
bcstatus	enum
)	O
{	O
act_on_init_result	pointer
=	O
fail_due_to_env_size	function
;	O
}	O
else	O
{	O
long	O
val	int
;	O
val	int
=	O
sysconf	function
(	O
_SC_ARG_MAX	int
)	O
;	O
if	O
(	O
val	int
>	O
0	int
)	O
{	O
assert	O
(	O
val	int
>	O
XARGS_POSIX_HEADROOM	int
)	O
;	O
bc_ctl	struct
.	O
arg_max	long
=	O
smaller_of	function
(	O
bc_ctl	struct
.	O
arg_max	long
,	O
(	O
size_t	long
)	O
val	int
-	O
XARGS_POSIX_HEADROOM	int
)	O
;	O
}	O
else	O
{	O
}	O
assert	O
(	O
bc_ctl	struct
.	O
arg_max	long
>=	O
LINE_MAX	O
)	O
;	O
bc_ctl	struct
.	O
exec_callback	pointer
=	O
xargs_do_exec	function
;	O
bc_use_sensible_arg_max	function
(	O
&	O
bc_ctl	struct
)	O
;	O
}	O
while	O
(	O
(	O
optc	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
"+0a:E:e::i::I:l::L:n:prs:txP:d:"	pointer
,	O
longopts	array
,	O
&	O
option_index	int
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
switch	O
(	O
optc	int
)	O
{	O
case	O
'0'	O
:	O
read_args	pointer
=	O
read_string	function
;	O
input_delimiter	char
=	O
'\0'	O
;	O
break	O
;	O
case	O
'd'	O
:	O
read_args	pointer
=	O
read_string	function
;	O
input_delimiter	char
=	O
get_input_delimiter	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'E'	O
:	O
case	O
'e'	O
:	O
if	O
(	O
optarg	pointer
&&	O
(	O
strlen	function
(	O
optarg	pointer
)	O
>	O
0	int
)	O
)	O
eof_str	pointer
=	O
optarg	pointer
;	O
else	O
eof_str	pointer
=	O
0	int
;	O
break	O
;	O
case	O
'h'	O
:	O
usage	function
(	O
stdout	pointer
)	O
;	O
return	O
0	int
;	O
case	O
'I'	O
:	O
case	O
'i'	O
:	O
if	O
(	O
optarg	pointer
)	O
bc_ctl	struct
.	O
replace_pat	pointer
=	O
optarg	pointer
;	O
else	O
bc_ctl	struct
.	O
replace_pat	pointer
=	O
"{}"	pointer
;	O
bc_ctl	struct
.	O
args_per_exec	long
=	O
0	int
;	O
bc_ctl	struct
.	O
lines_per_exec	long
=	O
0	int
;	O
break	O
;	O
case	O
'L'	O
:	O
bc_ctl	struct
.	O
lines_per_exec	long
=	O
parse_num	function
(	O
optarg	pointer
,	O
'L'	O
,	O
1L	int
,	O
-	O
1L	int
,	O
1	int
)	O
;	O
bc_ctl	struct
.	O
args_per_exec	long
=	O
0	int
;	O
bc_ctl	struct
.	O
replace_pat	pointer
=	O
NULL	O
;	O
break	O
;	O
case	O
'l'	O
:	O
if	O
(	O
optarg	pointer
)	O
bc_ctl	struct
.	O
lines_per_exec	long
=	O
parse_num	function
(	O
optarg	pointer
,	O
'l'	O
,	O
1L	int
,	O
-	O
1L	int
,	O
1	int
)	O
;	O
else	O
bc_ctl	struct
.	O
lines_per_exec	long
=	O
1	int
;	O
bc_ctl	struct
.	O
args_per_exec	long
=	O
0	int
;	O
bc_ctl	struct
.	O
replace_pat	pointer
=	O
NULL	O
;	O
break	O
;	O
case	O
'n'	O
:	O
bc_ctl	struct
.	O
args_per_exec	long
=	O
parse_num	function
(	O
optarg	pointer
,	O
'n'	O
,	O
1L	int
,	O
-	O
1L	int
,	O
1	int
)	O
;	O
bc_ctl	struct
.	O
lines_per_exec	long
=	O
0	int
;	O
if	O
(	O
bc_ctl	struct
.	O
args_per_exec	long
==	O
1	int
&&	O
bc_ctl	struct
.	O
replace_pat	pointer
)	O
bc_ctl	struct
.	O
args_per_exec	long
=	O
0	int
;	O
else	O
bc_ctl	struct
.	O
replace_pat	pointer
=	O
NULL	O
;	O
break	O
;	O
case	O
's'	O
:	O
{	O
size_t	long
arg_size	long
;	O
act_on_init_result	pointer
(	O
)	O
;	O
arg_size	long
=	O
parse_num	function
(	O
optarg	pointer
,	O
's'	O
,	O
1L	int
,	O
bc_ctl	struct
.	O
posix_arg_size_max	long
,	O
0	int
)	O
;	O
if	O
(	O
arg_size	long
>	O
bc_ctl	struct
.	O
posix_arg_size_max	long
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"warning: value %ld for -s option is too large, "	pointer
"using %ld instead"	pointer
)	O
,	O
(	O
long	O
)	O
arg_size	long
,	O
(	O
long	O
)	O
bc_ctl	struct
.	O
posix_arg_size_max	long
)	O
;	O
arg_size	long
=	O
bc_ctl	struct
.	O
posix_arg_size_max	long
;	O
}	O
bc_ctl	struct
.	O
arg_max	long
=	O
arg_size	long
;	O
}	O
break	O
;	O
case	O
'S'	O
:	O
show_limits	int
=	O
true	int
;	O
break	O
;	O
case	O
't'	O
:	O
print_command	bool
=	O
true	int
;	O
break	O
;	O
case	O
'x'	O
:	O
bc_ctl	struct
.	O
exit_if_size_exceeded	int
=	O
true	int
;	O
break	O
;	O
case	O
'p'	O
:	O
query_before_executing	bool
=	O
true	int
;	O
print_command	bool
=	O
true	int
;	O
break	O
;	O
case	O
'r'	O
:	O
always_run_command	int
=	O
0	int
;	O
break	O
;	O
case	O
'P'	O
:	O
proc_max	int
=	O
parse_num	function
(	O
optarg	pointer
,	O
'P'	O
,	O
0L	int
,	O
MAX_PROC_MAX	O
,	O
1	int
)	O
;	O
break	O
;	O
case	O
'a'	O
:	O
input_file	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'v'	O
:	O
display_findutils_version	function
(	O
"xargs"	pointer
)	O
;	O
return	O
0	int
;	O
case	O
PROCESS_SLOT_VAR	int
:	O
if	O
(	O
strchr	function
(	O
optarg	pointer
,	O
'='	O
)	O
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"option --%s may not be set to a value which includes `='"	pointer
)	O
,	O
longopts	array
[	O
option_index	int
]	O
.	O
name	pointer
)	O
;	O
}	O
slot_var_name	pointer
=	O
optarg	pointer
;	O
if	O
(	O
0	int
!=	O
unsetenv	function
(	O
slot_var_name	pointer
)	O
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"failed to unset environment variable %s"	pointer
)	O
,	O
slot_var_name	pointer
)	O
;	O
}	O
break	O
;	O
default	O
:	O
usage	function
(	O
stderr	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
if	O
(	O
eof_str	pointer
&&	O
(	O
read_args	pointer
==	O
read_string	function
)	O
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"warning: the -E option has no effect if -0 or -d is used.\n"	pointer
)	O
)	O
;	O
}	O
act_on_init_result	pointer
(	O
)	O
;	O
assert	O
(	O
BC_INIT_OK	int
==	O
bcstatus	enum
)	O
;	O
sigact	struct
.	O
sa_handler	pointer
=	O
increment_proc_max	function
;	O
sigemptyset	function
(	O
&	O
sigact	struct
.	O
sa_mask	struct
)	O
;	O
sigact	struct
.	O
sa_flags	int
=	O
0	int
;	O
if	O
(	O
0	int
!=	O
sigaction	struct
(	O
SIGUSR1	int
,	O
&	O
sigact	struct
,	O
(	O
struct	O
sigaction	struct
*	O
)	O
NULL	O
)	O
)	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"Cannot set SIGUSR1 signal handler"	pointer
)	O
)	O
;	O
sigact	struct
.	O
sa_handler	pointer
=	O
decrement_proc_max	function
;	O
sigemptyset	function
(	O
&	O
sigact	struct
.	O
sa_mask	struct
)	O
;	O
sigact	struct
.	O
sa_flags	int
=	O
0	int
;	O
if	O
(	O
0	int
!=	O
sigaction	struct
(	O
SIGUSR2	int
,	O
&	O
sigact	struct
,	O
(	O
struct	O
sigaction	struct
*	O
)	O
NULL	O
)	O
)	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"Cannot set SIGUSR2 signal handler"	pointer
)	O
)	O
;	O
if	O
(	O
0	int
==	O
strcmp	function
(	O
input_file	pointer
,	O
"-"	pointer
)	O
)	O
{	O
input_stream	pointer
=	O
stdin	pointer
;	O
}	O
else	O
{	O
keep_stdin	int
=	O
1	int
;	O
input_stream	pointer
=	O
fopen_cloexec_for_read_only	function
(	O
input_file	pointer
)	O
;	O
if	O
(	O
NULL	O
==	O
input_stream	pointer
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"Cannot open input file %s"	pointer
)	O
,	O
quotearg_n_style	function
(	O
0	int
,	O
locale_quoting_style	int
,	O
input_file	pointer
)	O
)	O
;	O
}	O
}	O
if	O
(	O
bc_ctl	struct
.	O
replace_pat	pointer
||	O
bc_ctl	struct
.	O
lines_per_exec	long
)	O
bc_ctl	struct
.	O
exit_if_size_exceeded	int
=	O
true	int
;	O
if	O
(	O
optind	int
==	O
argc	int
)	O
{	O
optind	int
=	O
0	int
;	O
argc	int
=	O
1	int
;	O
default_arglist	array
[	O
0	int
]	O
=	O
default_cmd	array
;	O
argv	pointer
=	O
default_arglist	array
;	O
}	O
if	O
(	O
show_limits	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Your environment variables take up %"	pointer
PRIuMAX	O
" bytes\n"	pointer
)	O
,	O
(	O
uintmax_t	long
)	O
bc_size_of_environment	function
(	O
)	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"POSIX upper limit on argument length (this system): %"	pointer
PRIuMAX	O
"\n"	pointer
)	O
,	O
(	O
uintmax_t	long
)	O
bc_ctl	struct
.	O
posix_arg_size_max	long
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"POSIX smallest allowable upper limit on argument length (all systems): %"	pointer
PRIuMAX	O
"\n"	pointer
)	O
,	O
(	O
uintmax_t	long
)	O
bc_ctl	struct
.	O
posix_arg_size_min	long
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Maximum length of command we could actually use: %"	pointer
PRIuMAX	O
"\n"	pointer
)	O
,	O
(	O
uintmax_t	long
)	O
(	O
bc_ctl	struct
.	O
posix_arg_size_max	long
-	O
bc_size_of_environment	function
(	O
)	O
)	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Size of command buffer we are actually using: %"	pointer
PRIuMAX	O
"\n"	pointer
)	O
,	O
(	O
uintmax_t	long
)	O
bc_ctl	struct
.	O
arg_max	long
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Maximum parallelism (--max-procs must be no greater): %"	pointer
PRIuMAX	O
"\n"	pointer
)	O
,	O
(	O
uintmax_t	long
)	O
MAX_PROC_MAX	O
)	O
;	O
if	O
(	O
isatty	function
(	O
STDIN_FILENO	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"\n"	pointer
"Execution of xargs will continue now, and it will "	pointer
"try to read its input and run commands; if this is "	pointer
"not what you wanted to happen, please type the "	pointer
"end-of-file keystroke.\n"	pointer
)	O
)	O
;	O
if	O
(	O
always_run_command	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Warning: %s will be run at least once.  "	pointer
"If you do not want that to happen, then press "	pointer
"the interrupt keystroke.\n"	pointer
)	O
,	O
argv	pointer
[	O
optind	int
]	O
)	O
;	O
}	O
}	O
}	O
linebuf	pointer
=	O
xmalloc	function
(	O
bc_ctl	struct
.	O
arg_max	long
+	O
1	int
)	O
;	O
bc_state	struct
.	O
argbuf	pointer
=	O
xmalloc	function
(	O
bc_ctl	struct
.	O
arg_max	long
+	O
1	int
)	O
;	O
signal	function
(	O
SIGCHLD	int
,	O
SIG_DFL	O
)	O
;	O
if	O
(	O
!	O
bc_ctl	struct
.	O
replace_pat	pointer
)	O
{	O
for	O
(	O
;	O
optind	int
<	O
argc	int
;	O
optind	int
++	O
)	O
bc_push_arg	function
(	O
&	O
bc_ctl	struct
,	O
&	O
bc_state	struct
,	O
argv	pointer
[	O
optind	int
]	O
,	O
strlen	function
(	O
argv	pointer
[	O
optind	int
]	O
)	O
+	O
1	int
,	O
NULL	O
,	O
0	int
,	O
initial_args	int
)	O
;	O
initial_args	int
=	O
false	int
;	O
bc_ctl	struct
.	O
initial_argc	long
=	O
bc_state	struct
.	O
cmd_argc	long
;	O
bc_state	struct
.	O
cmd_initial_argv_chars	long
=	O
bc_state	struct
.	O
cmd_argv_chars	long
;	O
bc_ctl	struct
.	O
initial_argc	long
=	O
bc_state	struct
.	O
cmd_argc	long
;	O
while	O
(	O
(	O
*	O
read_args	pointer
)	O
(	O
)	O
!=	O
-	O
1	int
)	O
if	O
(	O
bc_ctl	struct
.	O
lines_per_exec	long
&&	O
lineno	long
>=	O
bc_ctl	struct
.	O
lines_per_exec	long
)	O
{	O
bc_do_exec	function
(	O
&	O
bc_ctl	struct
,	O
&	O
bc_state	struct
)	O
;	O
lineno	long
=	O
0	int
;	O
}	O
if	O
(	O
bc_state	struct
.	O
cmd_argc	long
!=	O
bc_ctl	struct
.	O
initial_argc	long
||	O
(	O
always_run_command	int
&&	O
procs_executed	bool
==	O
0	int
)	O
)	O
bc_do_exec	function
(	O
&	O
bc_ctl	struct
,	O
&	O
bc_state	struct
)	O
;	O
}	O
else	O
{	O
int	O
i	int
,	O
args	int
;	O
size_t	long
*	O
arglen	long
=	O
xmalloc	function
(	O
sizeof	O
(	O
size_t	long
)	O
*	O
argc	int
)	O
;	O
for	O
(	O
i	int
=	O
optind	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
arglen	long
[	O
i	int
]	O
=	O
strlen	function
(	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
bc_ctl	struct
.	O
rplen	long
=	O
strlen	function
(	O
bc_ctl	struct
.	O
replace_pat	pointer
)	O
;	O
while	O
(	O
(	O
args	int
=	O
(	O
*	O
read_args	pointer
)	O
(	O
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
size_t	long
len	long
=	O
(	O
size_t	long
)	O
args	int
;	O
bc_clear_args	function
(	O
&	O
bc_ctl	struct
,	O
&	O
bc_state	struct
)	O
;	O
bc_state	struct
.	O
cmd_argv_chars	long
=	O
0	int
;	O
bc_push_arg	function
(	O
&	O
bc_ctl	struct
,	O
&	O
bc_state	struct
,	O
argv	pointer
[	O
optind	int
]	O
,	O
arglen	long
[	O
optind	int
]	O
+	O
1	int
,	O
NULL	O
,	O
0	int
,	O
initial_args	int
)	O
;	O
len	long
--	O
;	O
initial_args	int
=	O
false	int
;	O
for	O
(	O
i	int
=	O
optind	int
+	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
bc_do_insert	function
(	O
&	O
bc_ctl	struct
,	O
&	O
bc_state	struct
,	O
argv	pointer
[	O
i	int
]	O
,	O
arglen	long
[	O
i	int
]	O
,	O
NULL	O
,	O
0	int
,	O
linebuf	pointer
,	O
len	long
,	O
initial_args	int
)	O
;	O
bc_do_exec	function
(	O
&	O
bc_ctl	struct
,	O
&	O
bc_state	struct
)	O
;	O
}	O
}	O
original_exit_value	int
=	O
child_error	int
;	O
return	O
child_error	int
;	O
}	O
static	O
int	O
read_line	function
(	O
void	O
)	O
{	O
enum	O
read_line_state	enum
{	O
NORM	int
=	O
0	int
,	O
SPACE	int
=	O
1	int
,	O
QUOTE	int
=	O
2	int
,	O
BACKSLASH	int
=	O
3	int
}	O
;	O
static	O
bool	bool
eof	bool
=	O
false	int
;	O
enum	O
read_line_state	enum
state	pointer
=	O
SPACE	int
;	O
int	O
prevc	int
;	O
int	O
quotc	int
=	O
0	int
;	O
int	O
c	char
=	O
EOF	O
;	O
bool	bool
first	bool
=	O
true	int
;	O
bool	bool
seen_arg	bool
=	O
false	int
;	O
int	O
len	long
;	O
char	O
*	O
p	pointer
=	O
linebuf	pointer
;	O
char	O
*	O
endbuf	pointer
=	O
linebuf	pointer
+	O
bc_ctl	struct
.	O
arg_max	long
-	O
bc_state	struct
.	O
cmd_initial_argv_chars	long
-	O
1	int
;	O
if	O
(	O
eof	bool
)	O
return	O
-	O
1	int
;	O
while	O
(	O
1	int
)	O
{	O
prevc	int
=	O
c	char
;	O
c	char
=	O
getc	function
(	O
input_stream	pointer
)	O
;	O
if	O
(	O
c	char
==	O
EOF	O
)	O
{	O
eof	bool
=	O
true	int
;	O
if	O
(	O
p	pointer
==	O
linebuf	pointer
)	O
return	O
-	O
1	int
;	O
*	O
p	pointer
++	O
=	O
'\0'	O
;	O
len	long
=	O
p	pointer
-	O
linebuf	pointer
;	O
if	O
(	O
state	pointer
==	O
QUOTE	int
)	O
{	O
exec_if_possible	function
(	O
)	O
;	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"unmatched %s quote; by default quotes are special to xargs unless you use the -0 option"	pointer
)	O
,	O
quotc	int
==	O
'"'	O
?	O
_	O
(	O
"double"	pointer
)	O
:	O
_	O
(	O
"single"	pointer
)	O
)	O
;	O
}	O
if	O
(	O
first	bool
&&	O
EOF_STR	O
(	O
linebuf	pointer
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
!	O
bc_ctl	struct
.	O
replace_pat	pointer
)	O
bc_push_arg	function
(	O
&	O
bc_ctl	struct
,	O
&	O
bc_state	struct
,	O
linebuf	pointer
,	O
len	long
,	O
NULL	O
,	O
0	int
,	O
initial_args	int
)	O
;	O
return	O
len	long
;	O
}	O
switch	O
(	O
state	pointer
)	O
{	O
case	O
SPACE	int
:	O
if	O
(	O
ISSPACE	O
(	O
c	char
)	O
)	O
continue	O
;	O
state	pointer
=	O
NORM	int
;	O
case	O
NORM	int
:	O
if	O
(	O
c	char
==	O
'\n'	O
)	O
{	O
if	O
(	O
!	O
ISBLANK	O
(	O
prevc	int
)	O
)	O
lineno	long
++	O
;	O
if	O
(	O
p	pointer
==	O
linebuf	pointer
)	O
{	O
if	O
(	O
seen_arg	bool
)	O
{	O
}	O
else	O
{	O
state	pointer
=	O
SPACE	int
;	O
continue	O
;	O
}	O
}	O
*	O
p	pointer
++	O
=	O
'\0'	O
;	O
len	long
=	O
p	pointer
-	O
linebuf	pointer
;	O
if	O
(	O
EOF_STR	O
(	O
linebuf	pointer
)	O
)	O
{	O
eof	bool
=	O
true	int
;	O
return	O
first	bool
?	O
-	O
1	int
:	O
len	long
;	O
}	O
if	O
(	O
!	O
bc_ctl	struct
.	O
replace_pat	pointer
)	O
bc_push_arg	function
(	O
&	O
bc_ctl	struct
,	O
&	O
bc_state	struct
,	O
linebuf	pointer
,	O
len	long
,	O
NULL	O
,	O
0	int
,	O
initial_args	int
)	O
;	O
return	O
len	long
;	O
}	O
seen_arg	bool
=	O
true	int
;	O
if	O
(	O
!	O
bc_ctl	struct
.	O
replace_pat	pointer
&&	O
ISBLANK	O
(	O
c	char
)	O
)	O
{	O
*	O
p	pointer
++	O
=	O
'\0'	O
;	O
len	long
=	O
p	pointer
-	O
linebuf	pointer
;	O
if	O
(	O
EOF_STR	O
(	O
linebuf	pointer
)	O
)	O
{	O
eof	bool
=	O
true	int
;	O
return	O
first	bool
?	O
-	O
1	int
:	O
len	long
;	O
}	O
bc_push_arg	function
(	O
&	O
bc_ctl	struct
,	O
&	O
bc_state	struct
,	O
linebuf	pointer
,	O
len	long
,	O
NULL	O
,	O
0	int
,	O
initial_args	int
)	O
;	O
p	pointer
=	O
linebuf	pointer
;	O
state	pointer
=	O
SPACE	int
;	O
first	bool
=	O
false	int
;	O
continue	O
;	O
}	O
switch	O
(	O
c	char
)	O
{	O
case	O
'\\'	O
:	O
state	pointer
=	O
BACKSLASH	int
;	O
continue	O
;	O
case	O
'\''	O
:	O
case	O
'"'	O
:	O
state	pointer
=	O
QUOTE	int
;	O
quotc	int
=	O
c	char
;	O
continue	O
;	O
}	O
break	O
;	O
case	O
QUOTE	int
:	O
if	O
(	O
c	char
==	O
'\n'	O
)	O
{	O
exec_if_possible	function
(	O
)	O
;	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"unmatched %s quote; by default quotes are special to xargs unless you use the -0 option"	pointer
)	O
,	O
quotc	int
==	O
'"'	O
?	O
_	O
(	O
"double"	pointer
)	O
:	O
_	O
(	O
"single"	pointer
)	O
)	O
;	O
}	O
if	O
(	O
c	char
==	O
quotc	int
)	O
{	O
state	pointer
=	O
NORM	int
;	O
seen_arg	bool
=	O
true	int
;	O
continue	O
;	O
}	O
break	O
;	O
case	O
BACKSLASH	int
:	O
state	pointer
=	O
NORM	int
;	O
break	O
;	O
}	O
if	O
(	O
(	O
0	int
==	O
c	char
)	O
&&	O
!	O
nullwarning_given	int
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"WARNING: a NUL character occurred in the input.  "	pointer
"It cannot be passed through in the argument list.  "	pointer
"Did you mean to use the --null option?"	pointer
)	O
)	O
;	O
nullwarning_given	int
=	O
1	int
;	O
}	O
if	O
(	O
p	pointer
>=	O
endbuf	pointer
)	O
{	O
exec_if_possible	function
(	O
)	O
;	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"argument line too long"	pointer
)	O
)	O
;	O
}	O
*	O
p	pointer
++	O
=	O
c	char
;	O
}	O
}	O
static	O
int	O
read_string	function
(	O
void	O
)	O
{	O
static	O
bool	bool
eof	bool
=	O
false	int
;	O
int	O
len	long
;	O
char	O
*	O
p	pointer
=	O
linebuf	pointer
;	O
char	O
*	O
endbuf	pointer
=	O
linebuf	pointer
+	O
bc_ctl	struct
.	O
arg_max	long
-	O
bc_state	struct
.	O
cmd_initial_argv_chars	long
-	O
1	int
;	O
if	O
(	O
eof	bool
)	O
return	O
-	O
1	int
;	O
while	O
(	O
1	int
)	O
{	O
int	O
c	char
=	O
getc	function
(	O
input_stream	pointer
)	O
;	O
if	O
(	O
c	char
==	O
EOF	O
)	O
{	O
eof	bool
=	O
true	int
;	O
if	O
(	O
p	pointer
==	O
linebuf	pointer
)	O
return	O
-	O
1	int
;	O
*	O
p	pointer
++	O
=	O
'\0'	O
;	O
len	long
=	O
p	pointer
-	O
linebuf	pointer
;	O
if	O
(	O
!	O
bc_ctl	struct
.	O
replace_pat	pointer
)	O
bc_push_arg	function
(	O
&	O
bc_ctl	struct
,	O
&	O
bc_state	struct
,	O
linebuf	pointer
,	O
len	long
,	O
NULL	O
,	O
0	int
,	O
initial_args	int
)	O
;	O
return	O
len	long
;	O
}	O
if	O
(	O
c	char
==	O
input_delimiter	char
)	O
{	O
lineno	long
++	O
;	O
*	O
p	pointer
++	O
=	O
'\0'	O
;	O
len	long
=	O
p	pointer
-	O
linebuf	pointer
;	O
if	O
(	O
!	O
bc_ctl	struct
.	O
replace_pat	pointer
)	O
bc_push_arg	function
(	O
&	O
bc_ctl	struct
,	O
&	O
bc_state	struct
,	O
linebuf	pointer
,	O
len	long
,	O
NULL	O
,	O
0	int
,	O
initial_args	int
)	O
;	O
return	O
len	long
;	O
}	O
if	O
(	O
p	pointer
>=	O
endbuf	pointer
)	O
{	O
exec_if_possible	function
(	O
)	O
;	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"argument line too long"	pointer
)	O
)	O
;	O
}	O
*	O
p	pointer
++	O
=	O
c	char
;	O
}	O
}	O
static	O
bool	bool
print_args	function
(	O
bool	bool
ask	bool
)	O
{	O
size_t	long
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
bc_state	struct
.	O
cmd_argc	long
-	O
1	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
fprintf	function
(	O
stderr	pointer
,	O
"%s "	pointer
,	O
bc_state	struct
.	O
cmd_argv	pointer
[	O
i	int
]	O
)	O
<	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"Failed to write to stderr"	pointer
)	O
)	O
;	O
}	O
if	O
(	O
ask	bool
)	O
{	O
static	O
FILE	struct
*	O
tty_stream	pointer
;	O
int	O
c	char
,	O
savec	int
;	O
if	O
(	O
!	O
tty_stream	pointer
)	O
{	O
tty_stream	pointer
=	O
fopen_cloexec_for_read_only	function
(	O
"/dev/tty"	pointer
)	O
;	O
if	O
(	O
!	O
tty_stream	pointer
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"failed to open /dev/tty for reading"	pointer
)	O
)	O
;	O
}	O
fputs	function
(	O
"?..."	pointer
,	O
stderr	pointer
)	O
;	O
if	O
(	O
fflush	function
(	O
stderr	pointer
)	O
!=	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"Failed to write to stderr"	pointer
)	O
)	O
;	O
c	char
=	O
savec	int
=	O
getc	function
(	O
tty_stream	pointer
)	O
;	O
while	O
(	O
c	char
!=	O
EOF	O
&&	O
c	char
!=	O
'\n'	O
)	O
c	char
=	O
getc	function
(	O
tty_stream	pointer
)	O
;	O
if	O
(	O
EOF	O
==	O
c	char
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"Failed to read from stdin"	pointer
)	O
)	O
;	O
if	O
(	O
savec	int
==	O
'y'	O
||	O
savec	int
==	O
'Y'	O
)	O
return	O
true	int
;	O
}	O
else	O
putc	function
(	O
'\n'	O
,	O
stderr	pointer
)	O
;	O
return	O
false	int
;	O
}	O
static	O
void	O
set_slot_var	function
(	O
unsigned	O
int	O
n	long
)	O
{	O
static	O
const	O
char	O
*	O
fmt	pointer
=	O
"%u"	pointer
;	O
int	O
size	pointer
;	O
char	O
*	O
buf	pointer
;	O
size	pointer
=	O
snprintf	function
(	O
NULL	O
,	O
0u	int
,	O
fmt	pointer
,	O
n	long
)	O
;	O
assert	O
(	O
size	pointer
>	O
0	int
)	O
;	O
if	O
(	O
NULL	O
==	O
(	O
buf	pointer
=	O
malloc	function
(	O
size	pointer
+	O
1	int
)	O
)	O
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
snprintf	function
(	O
buf	pointer
,	O
size	pointer
+	O
1	int
,	O
fmt	pointer
,	O
n	long
)	O
;	O
if	O
(	O
slot_var_name	pointer
)	O
{	O
if	O
(	O
setenv	function
(	O
slot_var_name	pointer
,	O
buf	pointer
,	O
1	int
)	O
<	O
0	int
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"failed to set environment variable %s"	pointer
)	O
,	O
slot_var_name	pointer
)	O
;	O
}	O
}	O
free	function
(	O
buf	pointer
)	O
;	O
}	O
}	O
static	O
void	O
prep_child_for_exec	function
(	O
void	O
)	O
{	O
complain_about_leaky_fds	function
(	O
)	O
;	O
unsigned	O
int	O
slot	int
=	O
add_proc	function
(	O
0	int
)	O
;	O
set_slot_var	function
(	O
slot	int
)	O
;	O
if	O
(	O
!	O
keep_stdin	int
)	O
{	O
const	O
char	O
inputfile	array
[	O
]	O
=	O
"/dev/null"	pointer
;	O
close	pointer
(	O
0	int
)	O
;	O
if	O
(	O
open	function
(	O
inputfile	array
,	O
O_RDONLY	int
)	O
<	O
0	int
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
"%s"	pointer
,	O
quotearg_n_style	function
(	O
0	int
,	O
locale_quoting_style	int
,	O
inputfile	array
)	O
)	O
;	O
}	O
}	O
}	O
static	O
int	O
xargs_do_exec	function
(	O
struct	O
buildcmd_control	struct
*	O
ctl	pointer
,	O
void	O
*	O
usercontext	pointer
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
pid_t	int
child	int
;	O
int	O
fd	int
[	O
2	int
]	O
;	O
int	O
buf	pointer
;	O
size_t	long
r	long
;	O
(	O
void	O
)	O
ctl	pointer
;	O
(	O
void	O
)	O
argc	int
;	O
(	O
void	O
)	O
usercontext	pointer
;	O
if	O
(	O
proc_max	int
)	O
{	O
while	O
(	O
procs_executing	long
>=	O
proc_max	int
)	O
{	O
wait_for_proc	function
(	O
false	int
,	O
1u	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
query_before_executing	bool
||	O
print_args	function
(	O
true	int
)	O
)	O
{	O
if	O
(	O
!	O
query_before_executing	bool
&&	O
print_command	bool
)	O
print_args	function
(	O
false	int
)	O
;	O
wait_for_proc	function
(	O
false	int
,	O
0u	int
)	O
;	O
if	O
(	O
pipe	function
(	O
fd	int
)	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"could not create pipe before fork"	pointer
)	O
)	O
;	O
fcntl	function
(	O
fd	int
[	O
1	int
]	O
,	O
F_SETFD	int
,	O
FD_CLOEXEC	int
)	O
;	O
while	O
(	O
(	O
child	int
=	O
fork	function
(	O
)	O
)	O
<	O
0	int
&&	O
errno	O
==	O
EAGAIN	int
&&	O
procs_executing	long
)	O
wait_for_proc	function
(	O
false	int
,	O
1u	int
)	O
;	O
switch	O
(	O
child	int
)	O
{	O
case	O
-	O
1	int
:	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"cannot fork"	pointer
)	O
)	O
;	O
case	O
0	int
:	O
{	O
close	pointer
(	O
fd	int
[	O
0	int
]	O
)	O
;	O
child_error	int
=	O
EXIT_SUCCESS	int
;	O
prep_child_for_exec	function
(	O
)	O
;	O
if	O
(	O
bc_args_exceed_testing_limit	function
(	O
argv	pointer
)	O
)	O
errno	O
=	O
E2BIG	int
;	O
else	O
execvp	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argv	pointer
)	O
;	O
if	O
(	O
errno	O
)	O
{	O
write	pointer
(	O
fd	int
[	O
1	int
]	O
,	O
&	O
errno	O
,	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
}	O
close	pointer
(	O
fd	int
[	O
1	int
]	O
)	O
;	O
if	O
(	O
E2BIG	int
!=	O
errno	O
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
"%s"	pointer
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
}	O
_exit	function
(	O
errno	O
==	O
ENOENT	int
?	O
XARGS_EXIT_COMMAND_NOT_FOUND	int
:	O
XARGS_EXIT_COMMAND_CANNOT_BE_RUN	int
)	O
;	O
}	O
default	O
:	O
{	O
close	pointer
(	O
fd	int
[	O
1	int
]	O
)	O
;	O
}	O
}	O
switch	O
(	O
r	long
=	O
safe_read	function
(	O
fd	int
[	O
0	int
]	O
,	O
&	O
buf	pointer
,	O
sizeof	O
(	O
int	O
)	O
)	O
)	O
{	O
case	O
SAFE_READ_ERROR	O
:	O
{	O
close	pointer
(	O
fd	int
[	O
0	int
]	O
)	O
;	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"errno-buffer safe_read failed in xargs_do_exec "	pointer
"(this is probably a bug, please report it)"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
case	O
sizeof	O
(	O
int	O
)	O
:	O
{	O
int	O
childstatus	int
;	O
close	pointer
(	O
fd	int
[	O
0	int
]	O
)	O
;	O
waitpid	function
(	O
child	int
,	O
&	O
childstatus	int
,	O
0	int
)	O
;	O
if	O
(	O
E2BIG	int
==	O
buf	pointer
)	O
{	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
ENOENT	int
==	O
buf	pointer
)	O
{	O
exit	function
(	O
XARGS_EXIT_COMMAND_NOT_FOUND	int
)	O
;	O
}	O
else	O
{	O
exit	function
(	O
XARGS_EXIT_COMMAND_CANNOT_BE_RUN	int
)	O
;	O
}	O
break	O
;	O
}	O
case	O
0	int
:	O
{	O
add_proc	function
(	O
child	int
)	O
;	O
break	O
;	O
}	O
default	O
:	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"read returned unexpected value %zu; "	pointer
"this is probably a bug, please report it"	pointer
)	O
,	O
r	long
)	O
;	O
}	O
}	O
close	pointer
(	O
fd	int
[	O
0	int
]	O
)	O
;	O
}	O
return	O
1	int
;	O
}	O
static	O
void	O
exec_if_possible	function
(	O
void	O
)	O
{	O
if	O
(	O
bc_ctl	struct
.	O
replace_pat	pointer
||	O
initial_args	int
||	O
bc_state	struct
.	O
cmd_argc	long
==	O
bc_ctl	struct
.	O
initial_argc	long
||	O
bc_ctl	struct
.	O
exit_if_size_exceeded	int
)	O
return	O
;	O
bc_do_exec	function
(	O
&	O
bc_ctl	struct
,	O
&	O
bc_state	struct
)	O
;	O
}	O
static	O
unsigned	O
int	O
add_proc	function
(	O
pid_t	int
pid	int
)	O
{	O
unsigned	O
int	O
i	int
,	O
j	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
pids_alloc	long
&&	O
pids	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
;	O
if	O
(	O
i	int
==	O
pids_alloc	long
)	O
{	O
pids	pointer
=	O
x2nrealloc	function
(	O
pids	pointer
,	O
&	O
pids_alloc	long
,	O
sizeof	O
*	O
pids	pointer
)	O
;	O
for	O
(	O
j	int
=	O
i	int
;	O
j	int
<	O
pids_alloc	long
;	O
++	O
j	int
)	O
pids	pointer
[	O
j	int
]	O
=	O
(	O
pid_t	int
)	O
0	int
;	O
}	O
assert	O
(	O
0	int
==	O
pids	pointer
[	O
i	int
]	O
)	O
;	O
pids	pointer
[	O
i	int
]	O
=	O
pid	int
;	O
procs_executing	long
++	O
;	O
procs_executed	bool
=	O
true	int
;	O
return	O
i	int
;	O
}	O
static	O
void	O
wait_for_proc	function
(	O
bool	bool
all	bool
,	O
unsigned	O
int	O
minreap	int
)	O
{	O
unsigned	O
int	O
reaped	int
=	O
0	int
;	O
while	O
(	O
procs_executing	long
)	O
{	O
unsigned	O
int	O
i	int
;	O
int	O
status	int
;	O
pid_t	int
pid	int
;	O
int	O
wflags	int
=	O
0	int
;	O
if	O
(	O
!	O
all	bool
)	O
{	O
if	O
(	O
reaped	int
>=	O
minreap	int
)	O
{	O
wflags	int
=	O
WNOHANG	int
;	O
}	O
}	O
stop_waiting	int
=	O
0	int
;	O
do	O
{	O
while	O
(	O
(	O
pid	int
=	O
waitpid	function
(	O
-	O
1	int
,	O
&	O
status	int
,	O
wflags	int
)	O
)	O
==	O
(	O
pid_t	int
)	O
-	O
1	int
)	O
{	O
if	O
(	O
errno	O
!=	O
EINTR	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"error waiting for child process"	pointer
)	O
)	O
;	O
if	O
(	O
stop_waiting	int
&&	O
!	O
all	bool
)	O
{	O
wflags	int
=	O
WNOHANG	int
;	O
}	O
}	O
if	O
(	O
pid	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
pids_alloc	long
&&	O
pid	int
!=	O
pids	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
;	O
}	O
}	O
while	O
(	O
pid	int
&&	O
i	int
==	O
pids_alloc	long
)	O
;	O
if	O
(	O
!	O
pid	int
)	O
{	O
if	O
(	O
!	O
(	O
wflags	int
&	O
WNOHANG	int
)	O
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"WARNING: Lost track of %lu child processes"	pointer
)	O
,	O
procs_executing	long
)	O
;	O
}	O
else	O
{	O
}	O
break	O
;	O
}	O
pids	pointer
[	O
i	int
]	O
=	O
0	int
;	O
procs_executing	long
--	O
;	O
reaped	int
++	O
;	O
if	O
(	O
WEXITSTATUS	O
(	O
status	int
)	O
==	O
CHILD_EXIT_PLEASE_STOP_IMMEDIATELY	int
)	O
error	function
(	O
XARGS_EXIT_CLIENT_EXIT_255	int
,	O
0	int
,	O
_	O
(	O
"%s: exited with status 255; aborting"	pointer
)	O
,	O
bc_state	struct
.	O
cmd_argv	pointer
[	O
0	int
]	O
)	O
;	O
if	O
(	O
WIFSTOPPED	O
(	O
status	int
)	O
)	O
error	function
(	O
XARGS_EXIT_CLIENT_FATAL_SIG	int
,	O
0	int
,	O
_	O
(	O
"%s: stopped by signal %d"	pointer
)	O
,	O
bc_state	struct
.	O
cmd_argv	pointer
[	O
0	int
]	O
,	O
WSTOPSIG	O
(	O
status	int
)	O
)	O
;	O
if	O
(	O
WIFSIGNALED	O
(	O
status	int
)	O
)	O
error	function
(	O
XARGS_EXIT_CLIENT_FATAL_SIG	int
,	O
0	int
,	O
_	O
(	O
"%s: terminated by signal %d"	pointer
)	O
,	O
bc_state	struct
.	O
cmd_argv	pointer
[	O
0	int
]	O
,	O
WTERMSIG	O
(	O
status	int
)	O
)	O
;	O
if	O
(	O
WEXITSTATUS	O
(	O
status	int
)	O
!=	O
0	int
)	O
child_error	int
=	O
XARGS_EXIT_CLIENT_EXIT_NONZERO	int
;	O
}	O
}	O
static	O
void	O
wait_for_proc_all	function
(	O
void	O
)	O
{	O
static	O
bool	bool
waiting	bool
=	O
false	int
;	O
assert	O
(	O
getpid	function
(	O
)	O
==	O
parent	int
)	O
;	O
if	O
(	O
waiting	bool
)	O
return	O
;	O
waiting	bool
=	O
true	int
;	O
wait_for_proc	function
(	O
true	int
,	O
0u	int
)	O
;	O
waiting	bool
=	O
false	int
;	O
if	O
(	O
original_exit_value	int
!=	O
child_error	int
)	O
{	O
_exit	function
(	O
child_error	int
)	O
;	O
}	O
}	O
static	O
void	O
increment_proc_max	function
(	O
int	O
ignore	int
)	O
{	O
(	O
void	O
)	O
ignore	int
;	O
if	O
(	O
proc_max	int
<	O
MAX_PROC_MAX	O
)	O
proc_max	int
++	O
;	O
stop_waiting	int
=	O
1	int
;	O
}	O
static	O
void	O
decrement_proc_max	function
(	O
int	O
ignore	int
)	O
{	O
(	O
void	O
)	O
ignore	int
;	O
if	O
(	O
proc_max	int
>	O
1	int
)	O
proc_max	int
--	O
;	O
}	O
static	O
long	O
parse_num	function
(	O
char	O
*	O
str	pointer
,	O
int	O
option	struct
,	O
long	O
int	O
min	long
,	O
long	O
int	O
max	long
,	O
int	O
fatal	int
)	O
{	O
char	O
*	O
eptr	pointer
;	O
long	O
val	int
;	O
val	int
=	O
strtol	function
(	O
str	pointer
,	O
&	O
eptr	pointer
,	O
10	int
)	O
;	O
if	O
(	O
eptr	pointer
==	O
str	pointer
||	O
*	O
eptr	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: invalid number for -%c option\n"	pointer
)	O
,	O
program_name	pointer
,	O
option	struct
)	O
;	O
usage	function
(	O
stderr	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
else	O
if	O
(	O
val	int
<	O
min	long
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: value for -%c option should be >= %ld\n"	pointer
)	O
,	O
program_name	pointer
,	O
option	struct
,	O
min	long
)	O
;	O
if	O
(	O
fatal	int
)	O
{	O
usage	function
(	O
stderr	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
else	O
{	O
val	int
=	O
min	long
;	O
}	O
}	O
else	O
if	O
(	O
max	long
>=	O
0	int
&&	O
val	int
>	O
max	long
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: value for -%c option should be <= %ld\n"	pointer
)	O
,	O
program_name	pointer
,	O
option	struct
,	O
max	long
)	O
;	O
if	O
(	O
fatal	int
)	O
{	O
usage	function
(	O
stderr	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
else	O
{	O
val	int
=	O
max	long
;	O
}	O
}	O
return	O
val	int
;	O
}	O
static	O
void	O
usage	function
(	O
FILE	struct
*	O
stream	pointer
)	O
{	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"Usage: %s [OPTION]... COMMAND [INITIAL-ARGS]...\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
HTL	O
(	O
_	O
(	O
"Run COMMAND with arguments INITIAL-ARGS and more arguments read from input.\n"	pointer
"\n"	pointer
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"Mandatory and optional arguments to long options are also\n"	pointer
"mandatory or optional for the corresponding short option.\n"	pointer
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"  -0, --null                   items are separated by a null, not whitespace;\n"	pointer
"                                 disables quote and backslash processing and\n"	pointer
"                                 logical EOF processing\n"	pointer
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"  -a, --arg-file=FILE          read arguments from FILE, not standard input\n"	pointer
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"  -d, --delimiter=CHARACTER    items in input stream are separated by CHARACTER,\n"	pointer
"                                 not by whitespace; disables quote and backslash\n"	pointer
"                                 processing and logical EOF processing\n"	pointer
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"  -E END                       set logical EOF string; if END occurs as a line\n"	pointer
"                                 of input, the rest of the input is ignored\n"	pointer
"                                 (ignored if -0 or -d was specified)\n"	pointer
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"  -e, --eof[=END]              equivalent to -E END if END is specified;\n"	pointer
"                                 otherwise, there is no end-of-file string\n"	pointer
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"  -I R                         same as --replace=R\n"	pointer
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"  -i, --replace[=R]            replace R in INITIAL-ARGS with names read\n"	pointer
"                                 from standard input; if R is unspecified,\n"	pointer
"                                 assume {}\n"	pointer
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"  -L, --max-lines=MAX-LINES    use at most MAX-LINES non-blank input lines per\n"	pointer
"                                 command line\n"	pointer
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"  -l[MAX-LINES]                similar to -L but defaults to at most one non-\n"	pointer
"                                 blank input line if MAX-LINES is not specified\n"	pointer
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"  -n, --max-args=MAX-ARGS      use at most MAX-ARGS arguments per command line\n"	pointer
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"  -P, --max-procs=MAX-PROCS    run at most MAX-PROCS processes at a time\n"	pointer
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"  -p, --interactive            prompt before running commands\n"	pointer
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"      --process-slot-var=VAR   set environment variable VAR in child processes\n"	pointer
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"  -r, --no-run-if-empty        if there are no arguments, then do not run COMMAND;\n"	pointer
"                                 if this option is not given, COMMAND will be\n"	pointer
"                                 run at least once\n"	pointer
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"  -s, --max-chars=MAX-CHARS    limit length of command line to MAX-CHARS\n"	pointer
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"      --show-limits            show limits on command-line length\n"	pointer
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"  -t, --verbose                print commands before executing them\n"	pointer
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"  -x, --exit                   exit if the size (see -s) is exceeded\n"	pointer
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"      --help                   display this help and exit\n"	pointer
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"      --version                output version information and exit\n"	pointer
)	O
)	O
;	O
HTL	O
(	O
_	O
(	O
"\n"	pointer
"Report bugs to <bug-findutils@gnu.org>.\n"	pointer
)	O
)	O
;	O
}	O
