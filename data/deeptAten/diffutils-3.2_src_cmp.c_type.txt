static	O
int	O
cmp	function
(	O
void	O
)	O
;	O
static	O
off_t	long
file_position	function
(	O
int	O
)	O
;	O
static	O
size_t	long
block_compare	function
(	O
word	O
const	O
*	O
,	O
word	O
const	O
*	O
)	O
;	O
static	O
size_t	long
block_compare_and_count	function
(	O
word	O
const	O
*	O
,	O
word	O
const	O
*	O
,	O
off_t	long
*	O
)	O
;	O
static	O
void	O
sprintc	function
(	O
char	O
*	O
,	O
unsigned	O
char	O
)	O
;	O
static	O
char	O
const	O
*	O
file	array
[	O
2	int
]	O
;	O
static	O
int	O
file_desc	array
[	O
2	int
]	O
;	O
static	O
struct	O
stat	struct
stat_buf	array
[	O
2	int
]	O
;	O
static	O
word	O
*	O
buffer	array
[	O
2	int
]	O
;	O
static	O
size_t	long
buf_size	long
;	O
static	O
off_t	long
ignore_initial	array
[	O
2	int
]	O
;	O
static	O
uintmax_t	long
bytes	long
=	O
UINTMAX_MAX	O
;	O
static	O
enum	O
comparison_type	enum
{	O
type_first_diff	int
,	O
type_all_diffs	int
,	O
type_no_stdout	int
,	O
type_status	int
}	O
comparison_type	enum
;	O
static	O
bool	bool
opt_print_bytes	bool
;	O
enum	O
{	O
HELP_OPTION	int
=	O
CHAR_MAX	O
+	O
1	int
}	O
;	O
static	O
struct	O
option	struct
const	O
long_options	array
[	O
]	O
=	O
{	O
{	O
"print-bytes"	pointer
,	O
0	int
,	O
0	int
,	O
'b'	O
}	O
,	O
{	O
"print-chars"	pointer
,	O
0	int
,	O
0	int
,	O
'c'	O
}	O
,	O
{	O
"ignore-initial"	pointer
,	O
1	int
,	O
0	int
,	O
'i'	O
}	O
,	O
{	O
"verbose"	pointer
,	O
0	int
,	O
0	int
,	O
'l'	O
}	O
,	O
{	O
"bytes"	pointer
,	O
1	int
,	O
0	int
,	O
'n'	O
}	O
,	O
{	O
"silent"	pointer
,	O
0	int
,	O
0	int
,	O
's'	O
}	O
,	O
{	O
"quiet"	pointer
,	O
0	int
,	O
0	int
,	O
's'	O
}	O
,	O
{	O
"version"	pointer
,	O
0	int
,	O
0	int
,	O
'v'	O
}	O
,	O
{	O
"help"	pointer
,	O
0	int
,	O
0	int
,	O
HELP_OPTION	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
void	O
try_help	function
(	O
char	O
const	O
*	O
,	O
char	O
const	O
*	O
)	O
__attribute__	O
(	O
(	O
noreturn	O
)	O
)	O
;	O
static	O
void	O
try_help	function
(	O
char	O
const	O
*	O
reason_msgid	pointer
,	O
char	O
const	O
*	O
operand	pointer
)	O
{	O
if	O
(	O
reason_msgid	pointer
)	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
reason_msgid	pointer
)	O
,	O
operand	pointer
)	O
;	O
error	function
(	O
EXIT_TROUBLE	int
,	O
0	int
,	O
_	O
(	O
"Try `%s --help' for more information."	pointer
)	O
,	O
program_name	pointer
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
static	O
char	O
const	O
valid_suffixes	array
[	O
]	O
=	O
"kKMGTPEZY0"	pointer
;	O
static	O
void	O
specify_ignore_initial	function
(	O
int	O
f	int
,	O
char	O
*	O
*	O
argptr	pointer
,	O
char	O
delimiter	char
)	O
{	O
uintmax_t	long
val	array
;	O
char	O
const	O
*	O
arg	pointer
=	O
*	O
argptr	pointer
;	O
strtol_error	enum
e	enum
=	O
xstrtoumax	function
(	O
arg	pointer
,	O
argptr	pointer
,	O
0	int
,	O
&	O
val	array
,	O
valid_suffixes	array
)	O
;	O
if	O
(	O
!	O
(	O
e	enum
==	O
LONGINT_OK	int
||	O
(	O
e	enum
==	O
LONGINT_INVALID_SUFFIX_CHAR	int
&&	O
*	O
*	O
argptr	pointer
==	O
delimiter	char
)	O
)	O
||	O
TYPE_MAXIMUM	O
(	O
off_t	long
)	O
<	O
val	array
)	O
try_help	function
(	O
"invalid --ignore-initial value `%s'"	pointer
,	O
arg	pointer
)	O
;	O
if	O
(	O
ignore_initial	array
[	O
f	int
]	O
<	O
val	array
)	O
ignore_initial	array
[	O
f	int
]	O
=	O
val	array
;	O
}	O
static	O
void	O
specify_comparison_type	function
(	O
enum	O
comparison_type	enum
t	enum
)	O
{	O
if	O
(	O
comparison_type	enum
&&	O
comparison_type	enum
!=	O
t	enum
)	O
try_help	function
(	O
"options -l and -s are incompatible"	pointer
,	O
0	int
)	O
;	O
comparison_type	enum
=	O
t	enum
;	O
}	O
static	O
void	O
check_stdout	function
(	O
void	O
)	O
{	O
if	O
(	O
ferror	function
(	O
stdout	pointer
)	O
)	O
error	function
(	O
EXIT_TROUBLE	int
,	O
0	int
,	O
"%s"	pointer
,	O
_	O
(	O
"write failed"	pointer
)	O
)	O
;	O
else	O
if	O
(	O
fclose	function
(	O
stdout	pointer
)	O
!=	O
0	int
)	O
error	function
(	O
EXIT_TROUBLE	int
,	O
errno	O
,	O
"%s"	pointer
,	O
_	O
(	O
"standard output"	pointer
)	O
)	O
;	O
}	O
static	O
char	O
const	O
*	O
const	O
option_help_msgid	array
[	O
]	O
=	O
{	O
N_	O
(	O
"-b, --print-bytes          print differing bytes"	pointer
)	O
,	O
N_	O
(	O
"-i, --ignore-initial=SKIP         skip first SKIP bytes of both inputs"	pointer
)	O
,	O
N_	O
(	O
"-i, --ignore-initial=SKIP1:SKIP2  skip first SKIP1 bytes of FILE1 and\n"	pointer
"                                      first SKIP2 bytes of FILE2"	pointer
)	O
,	O
N_	O
(	O
"-l, --verbose              output byte numbers and differing byte values"	pointer
)	O
,	O
N_	O
(	O
"-n, --bytes=LIMIT          compare at most LIMIT bytes"	pointer
)	O
,	O
N_	O
(	O
"-s, --quiet, --silent      suppress all normal output"	pointer
)	O
,	O
N_	O
(	O
"    --help                 display this help and exit"	pointer
)	O
,	O
N_	O
(	O
"-v, --version              output version information and exit"	pointer
)	O
,	O
0	int
}	O
;	O
static	O
void	O
usage	function
(	O
void	O
)	O
{	O
char	O
const	O
*	O
const	O
*	O
p	pointer
;	O
printf	function
(	O
_	O
(	O
"Usage: %s [OPTION]... FILE1 [FILE2 [SKIP1 [SKIP2]]]\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
printf	function
(	O
"%s\n"	pointer
,	O
_	O
(	O
"Compare two files byte by byte."	pointer
)	O
)	O
;	O
printf	function
(	O
"\n%s\n\n"	pointer
,	O
_	O
(	O
"The optional SKIP1 and SKIP2 specify the number of bytes to skip\n"	pointer
"at the beginning of each file (zero by default)."	pointer
)	O
)	O
;	O
fputs	function
(	O
_	O
(	O
"Mandatory arguments to long options are mandatory for short options too.\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
for	O
(	O
p	pointer
=	O
option_help_msgid	array
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
printf	function
(	O
"  %s\n"	pointer
,	O
_	O
(	O
*	O
p	pointer
)	O
)	O
;	O
printf	function
(	O
"\n%s\n\n%s\n%s\n"	pointer
,	O
_	O
(	O
"SKIP values may be followed by the following multiplicative suffixes:\nkB 1000, K 1024, MB 1,000,000, M 1,048,576,\nGB 1,000,000,000, G 1,073,741,824, and so on for T, P, E, Z, Y."	pointer
)	O
,	O
_	O
(	O
"If a FILE is `-' or missing, read standard input."	pointer
)	O
,	O
_	O
(	O
"Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."	pointer
)	O
)	O
;	O
emit_bug_reporting_address	function
(	O
)	O
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
c	int
,	O
f	int
,	O
exit_status	int
;	O
size_t	long
words_per_buffer	long
;	O
exit_failure	int
=	O
EXIT_TROUBLE	int
;	O
initialize_main	O
(	O
&	O
argc	int
,	O
&	O
argv	pointer
)	O
;	O
set_program_name	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
setlocale	function
(	O
LC_ALL	O
,	O
""	pointer
)	O
;	O
bindtextdomain	function
(	O
PACKAGE	pointer
,	O
LOCALEDIR	pointer
)	O
;	O
textdomain	function
(	O
PACKAGE	pointer
)	O
;	O
c_stack_action	function
(	O
0	int
)	O
;	O
while	O
(	O
(	O
c	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
"bci:ln:sv"	pointer
,	O
long_options	array
,	O
0	int
)	O
)	O
!=	O
-	O
1	int
)	O
switch	O
(	O
c	int
)	O
{	O
case	O
'b'	O
:	O
case	O
'c'	O
:	O
opt_print_bytes	bool
=	O
true	int
;	O
break	O
;	O
case	O
'i'	O
:	O
specify_ignore_initial	function
(	O
0	int
,	O
&	O
optarg	pointer
,	O
':'	O
)	O
;	O
if	O
(	O
*	O
optarg	pointer
++	O
==	O
':'	O
)	O
specify_ignore_initial	function
(	O
1	int
,	O
&	O
optarg	pointer
,	O
0	int
)	O
;	O
else	O
if	O
(	O
ignore_initial	array
[	O
1	int
]	O
<	O
ignore_initial	array
[	O
0	int
]	O
)	O
ignore_initial	array
[	O
1	int
]	O
=	O
ignore_initial	array
[	O
0	int
]	O
;	O
break	O
;	O
case	O
'l'	O
:	O
specify_comparison_type	function
(	O
type_all_diffs	int
)	O
;	O
break	O
;	O
case	O
'n'	O
:	O
{	O
uintmax_t	long
n	long
;	O
if	O
(	O
xstrtoumax	function
(	O
optarg	pointer
,	O
0	int
,	O
0	int
,	O
&	O
n	long
,	O
valid_suffixes	array
)	O
!=	O
LONGINT_OK	int
)	O
try_help	function
(	O
"invalid --bytes value `%s'"	pointer
,	O
optarg	pointer
)	O
;	O
if	O
(	O
n	long
<	O
bytes	long
)	O
bytes	long
=	O
n	long
;	O
}	O
break	O
;	O
case	O
's'	O
:	O
specify_comparison_type	function
(	O
type_status	int
)	O
;	O
break	O
;	O
case	O
'v'	O
:	O
version_etc	function
(	O
stdout	pointer
,	O
PROGRAM_NAME	pointer
,	O
PACKAGE_NAME	pointer
,	O
Version	pointer
,	O
AUTHORS	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
check_stdout	function
(	O
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
case	O
HELP_OPTION	int
:	O
usage	function
(	O
)	O
;	O
check_stdout	function
(	O
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
default	O
:	O
try_help	function
(	O
0	int
,	O
0	int
)	O
;	O
}	O
if	O
(	O
optind	int
==	O
argc	int
)	O
try_help	function
(	O
"missing operand after `%s'"	pointer
,	O
argv	pointer
[	O
argc	int
-	O
1	int
]	O
)	O
;	O
file	array
[	O
0	int
]	O
=	O
argv	pointer
[	O
optind	int
++	O
]	O
;	O
file	array
[	O
1	int
]	O
=	O
optind	int
<	O
argc	int
?	O
argv	pointer
[	O
optind	int
++	O
]	O
:	O
"-"	pointer
;	O
for	O
(	O
f	int
=	O
0	int
;	O
f	int
<	O
2	int
&&	O
optind	int
<	O
argc	int
;	O
f	int
++	O
)	O
{	O
char	O
*	O
arg	pointer
=	O
argv	pointer
[	O
optind	int
++	O
]	O
;	O
specify_ignore_initial	function
(	O
f	int
,	O
&	O
arg	pointer
,	O
0	int
)	O
;	O
}	O
if	O
(	O
optind	int
<	O
argc	int
)	O
try_help	function
(	O
"extra operand `%s'"	pointer
,	O
argv	pointer
[	O
optind	int
]	O
)	O
;	O
for	O
(	O
f	int
=	O
0	int
;	O
f	int
<	O
2	int
;	O
f	int
++	O
)	O
{	O
int	O
f1	int
=	O
f	int
^	O
(	O
STREQ	O
(	O
file	array
[	O
1	int
]	O
,	O
"-"	pointer
)	O
)	O
;	O
if	O
(	O
f	int
&&	O
ignore_initial	array
[	O
0	int
]	O
==	O
ignore_initial	array
[	O
1	int
]	O
&&	O
file_name_cmp	O
(	O
file	array
[	O
0	int
]	O
,	O
file	array
[	O
1	int
]	O
)	O
==	O
0	int
)	O
return	O
EXIT_SUCCESS	int
;	O
if	O
(	O
STREQ	O
(	O
file	array
[	O
f1	int
]	O
,	O
"-"	pointer
)	O
)	O
{	O
file_desc	array
[	O
f1	int
]	O
=	O
STDIN_FILENO	int
;	O
if	O
(	O
O_BINARY	int
&&	O
!	O
isatty	function
(	O
STDIN_FILENO	int
)	O
)	O
xfreopen	function
(	O
NULL	O
,	O
"rb"	pointer
,	O
stdin	pointer
)	O
;	O
}	O
else	O
file_desc	array
[	O
f1	int
]	O
=	O
open	function
(	O
file	array
[	O
f1	int
]	O
,	O
O_RDONLY	int
|	O
O_BINARY	int
,	O
0	int
)	O
;	O
if	O
(	O
file_desc	array
[	O
f1	int
]	O
<	O
0	int
||	O
fstat	function
(	O
file_desc	array
[	O
f1	int
]	O
,	O
stat_buf	array
+	O
f1	int
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
file_desc	array
[	O
f1	int
]	O
<	O
0	int
&&	O
comparison_type	enum
==	O
type_status	int
)	O
exit	function
(	O
EXIT_TROUBLE	int
)	O
;	O
else	O
error	function
(	O
EXIT_TROUBLE	int
,	O
errno	O
,	O
"%s"	pointer
,	O
file	array
[	O
f1	int
]	O
)	O
;	O
}	O
}	O
if	O
(	O
0	int
<	O
same_file	O
(	O
&	O
stat_buf	array
[	O
0	int
]	O
,	O
&	O
stat_buf	array
[	O
1	int
]	O
)	O
&&	O
same_file_attributes	O
(	O
&	O
stat_buf	array
[	O
0	int
]	O
,	O
&	O
stat_buf	array
[	O
1	int
]	O
)	O
&&	O
file_position	function
(	O
0	int
)	O
==	O
file_position	function
(	O
1	int
)	O
)	O
return	O
EXIT_SUCCESS	int
;	O
if	O
(	O
comparison_type	enum
!=	O
type_status	int
)	O
{	O
struct	O
stat	struct
outstat	struct
,	O
nullstat	struct
;	O
if	O
(	O
fstat	function
(	O
STDOUT_FILENO	int
,	O
&	O
outstat	struct
)	O
==	O
0	int
&&	O
stat	struct
(	O
NULL_DEVICE	pointer
,	O
&	O
nullstat	struct
)	O
==	O
0	int
&&	O
0	int
<	O
same_file	O
(	O
&	O
outstat	struct
,	O
&	O
nullstat	struct
)	O
)	O
comparison_type	enum
=	O
type_no_stdout	int
;	O
}	O
if	O
(	O
comparison_type	enum
==	O
type_status	int
&&	O
S_ISREG	O
(	O
stat_buf	array
[	O
0	int
]	O
.	O
st_mode	int
)	O
&&	O
S_ISREG	O
(	O
stat_buf	array
[	O
1	int
]	O
.	O
st_mode	int
)	O
)	O
{	O
off_t	long
s0	long
=	O
stat_buf	array
[	O
0	int
]	O
.	O
st_size	long
-	O
file_position	function
(	O
0	int
)	O
;	O
off_t	long
s1	pointer
=	O
stat_buf	array
[	O
1	int
]	O
.	O
st_size	long
-	O
file_position	function
(	O
1	int
)	O
;	O
if	O
(	O
s0	long
<	O
0	int
)	O
s0	long
=	O
0	int
;	O
if	O
(	O
s1	pointer
<	O
0	int
)	O
s1	pointer
=	O
0	int
;	O
if	O
(	O
s0	long
!=	O
s1	pointer
&&	O
MIN	O
(	O
s0	long
,	O
s1	pointer
)	O
<	O
bytes	long
)	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
buf_size	long
=	O
buffer_lcm	function
(	O
STAT_BLOCKSIZE	O
(	O
stat_buf	array
[	O
0	int
]	O
)	O
,	O
STAT_BLOCKSIZE	O
(	O
stat_buf	array
[	O
1	int
]	O
)	O
,	O
PTRDIFF_MAX	O
-	O
sizeof	O
(	O
word	O
)	O
)	O
;	O
words_per_buffer	long
=	O
(	O
buf_size	long
+	O
2	int
*	O
sizeof	O
(	O
word	O
)	O
-	O
1	int
)	O
/	O
sizeof	O
(	O
word	O
)	O
;	O
buffer	array
[	O
0	int
]	O
=	O
xmalloc	function
(	O
2	int
*	O
sizeof	O
(	O
word	O
)	O
*	O
words_per_buffer	long
)	O
;	O
buffer	array
[	O
1	int
]	O
=	O
buffer	array
[	O
0	int
]	O
+	O
words_per_buffer	long
;	O
exit_status	int
=	O
cmp	function
(	O
)	O
;	O
for	O
(	O
f	int
=	O
0	int
;	O
f	int
<	O
2	int
;	O
f	int
++	O
)	O
if	O
(	O
close	function
(	O
file_desc	array
[	O
f	int
]	O
)	O
!=	O
0	int
)	O
error	function
(	O
EXIT_TROUBLE	int
,	O
errno	O
,	O
"%s"	pointer
,	O
file	array
[	O
f	int
]	O
)	O
;	O
if	O
(	O
exit_status	int
!=	O
EXIT_SUCCESS	int
&&	O
comparison_type	enum
<	O
type_no_stdout	int
)	O
check_stdout	function
(	O
)	O
;	O
exit	function
(	O
exit_status	int
)	O
;	O
return	O
exit_status	int
;	O
}	O
static	O
int	O
cmp	function
(	O
void	O
)	O
{	O
off_t	long
line_number	long
=	O
1	int
;	O
off_t	long
byte_number	long
=	O
1	int
;	O
uintmax_t	long
remaining	long
=	O
bytes	long
;	O
size_t	long
read0	long
,	O
read1	long
;	O
size_t	long
first_diff	long
;	O
size_t	long
smaller	long
;	O
word	O
*	O
buffer0	pointer
=	O
buffer	array
[	O
0	int
]	O
;	O
word	O
*	O
buffer1	pointer
=	O
buffer	array
[	O
1	int
]	O
;	O
char	O
*	O
buf0	pointer
=	O
(	O
char	O
*	O
)	O
buffer0	pointer
;	O
char	O
*	O
buf1	pointer
=	O
(	O
char	O
*	O
)	O
buffer1	pointer
;	O
int	O
differing	int
=	O
0	int
;	O
int	O
f	int
;	O
int	O
offset_width	int
IF_LINT	O
(	O
=	O
0	int
)	O
;	O
if	O
(	O
comparison_type	enum
==	O
type_all_diffs	int
)	O
{	O
off_t	long
byte_number_max	long
=	O
MIN	O
(	O
bytes	long
,	O
TYPE_MAXIMUM	O
(	O
off_t	long
)	O
)	O
;	O
for	O
(	O
f	int
=	O
0	int
;	O
f	int
<	O
2	int
;	O
f	int
++	O
)	O
if	O
(	O
S_ISREG	O
(	O
stat_buf	array
[	O
f	int
]	O
.	O
st_mode	int
)	O
)	O
{	O
off_t	long
file_bytes	long
=	O
stat_buf	array
[	O
f	int
]	O
.	O
st_size	long
-	O
file_position	function
(	O
f	int
)	O
;	O
if	O
(	O
file_bytes	long
<	O
byte_number_max	long
)	O
byte_number_max	long
=	O
file_bytes	long
;	O
}	O
for	O
(	O
offset_width	int
=	O
1	int
;	O
(	O
byte_number_max	long
/=	O
10	int
)	O
!=	O
0	int
;	O
offset_width	int
++	O
)	O
continue	O
;	O
}	O
for	O
(	O
f	int
=	O
0	int
;	O
f	int
<	O
2	int
;	O
f	int
++	O
)	O
{	O
off_t	long
ig	long
=	O
ignore_initial	array
[	O
f	int
]	O
;	O
if	O
(	O
ig	long
&&	O
file_position	function
(	O
f	int
)	O
==	O
-	O
1	int
)	O
{	O
do	O
{	O
size_t	long
bytes_to_read	long
=	O
MIN	O
(	O
ig	long
,	O
buf_size	long
)	O
;	O
size_t	long
r	long
=	O
block_read	function
(	O
file_desc	array
[	O
f	int
]	O
,	O
buf0	pointer
,	O
bytes_to_read	long
)	O
;	O
if	O
(	O
r	long
!=	O
bytes_to_read	long
)	O
{	O
if	O
(	O
r	long
==	O
SIZE_MAX	O
)	O
error	function
(	O
EXIT_TROUBLE	int
,	O
errno	O
,	O
"%s"	pointer
,	O
file	array
[	O
f	int
]	O
)	O
;	O
break	O
;	O
}	O
ig	long
-=	O
r	long
;	O
}	O
while	O
(	O
ig	long
)	O
;	O
}	O
}	O
do	O
{	O
size_t	long
bytes_to_read	long
=	O
buf_size	long
;	O
if	O
(	O
remaining	long
!=	O
UINTMAX_MAX	O
)	O
{	O
if	O
(	O
remaining	long
<	O
bytes_to_read	long
)	O
bytes_to_read	long
=	O
remaining	long
;	O
remaining	long
-=	O
bytes_to_read	long
;	O
}	O
read0	long
=	O
block_read	function
(	O
file_desc	array
[	O
0	int
]	O
,	O
buf0	pointer
,	O
bytes_to_read	long
)	O
;	O
if	O
(	O
read0	long
==	O
SIZE_MAX	O
)	O
error	function
(	O
EXIT_TROUBLE	int
,	O
errno	O
,	O
"%s"	pointer
,	O
file	array
[	O
0	int
]	O
)	O
;	O
read1	long
=	O
block_read	function
(	O
file_desc	array
[	O
1	int
]	O
,	O
buf1	pointer
,	O
bytes_to_read	long
)	O
;	O
if	O
(	O
read1	long
==	O
SIZE_MAX	O
)	O
error	function
(	O
EXIT_TROUBLE	int
,	O
errno	O
,	O
"%s"	pointer
,	O
file	array
[	O
1	int
]	O
)	O
;	O
buf0	pointer
[	O
read0	long
]	O
=	O
~	O
buf1	pointer
[	O
read0	long
]	O
;	O
buf1	pointer
[	O
read1	long
]	O
=	O
~	O
buf0	pointer
[	O
read1	long
]	O
;	O
first_diff	long
=	O
(	O
comparison_type	enum
==	O
type_first_diff	int
?	O
block_compare_and_count	function
(	O
buffer0	pointer
,	O
buffer1	pointer
,	O
&	O
line_number	long
)	O
:	O
block_compare	function
(	O
buffer0	pointer
,	O
buffer1	pointer
)	O
)	O
;	O
byte_number	long
+=	O
first_diff	long
;	O
smaller	long
=	O
MIN	O
(	O
read0	long
,	O
read1	long
)	O
;	O
if	O
(	O
first_diff	long
<	O
smaller	long
)	O
{	O
switch	O
(	O
comparison_type	enum
)	O
{	O
case	O
type_first_diff	int
:	O
{	O
char	O
byte_buf	array
[	O
INT_BUFSIZE_BOUND	O
(	O
off_t	long
)	O
]	O
;	O
char	O
line_buf	array
[	O
INT_BUFSIZE_BOUND	O
(	O
off_t	long
)	O
]	O
;	O
char	O
const	O
*	O
byte_num	pointer
=	O
offtostr	function
(	O
byte_number	long
,	O
byte_buf	array
)	O
;	O
char	O
const	O
*	O
line_num	pointer
=	O
offtostr	function
(	O
line_number	long
,	O
line_buf	array
)	O
;	O
if	O
(	O
!	O
opt_print_bytes	bool
)	O
{	O
static	O
char	O
const	O
char_message	array
[	O
]	O
=	O
"%s %s differ: char %s, line %s\n"	pointer
;	O
static	O
char	O
const	O
byte_msgid	array
[	O
]	O
=	O
N_	O
(	O
"%s %s differ: byte %s, line %s\n"	pointer
)	O
;	O
char	O
const	O
*	O
byte_message	pointer
=	O
_	O
(	O
byte_msgid	array
)	O
;	O
bool	bool
use_byte_message	bool
=	O
(	O
byte_message	pointer
!=	O
byte_msgid	array
||	O
hard_locale_LC_MESSAGES	O
)	O
;	O
printf	function
(	O
use_byte_message	bool
?	O
byte_message	pointer
:	O
char_message	array
,	O
file	array
[	O
0	int
]	O
,	O
file	array
[	O
1	int
]	O
,	O
byte_num	pointer
,	O
line_num	pointer
)	O
;	O
}	O
else	O
{	O
unsigned	O
char	O
c0	char
=	O
buf0	pointer
[	O
first_diff	long
]	O
;	O
unsigned	O
char	O
c1	char
=	O
buf1	pointer
[	O
first_diff	long
]	O
;	O
char	O
s0	long
[	O
5	int
]	O
;	O
char	O
s1	pointer
[	O
5	int
]	O
;	O
sprintc	function
(	O
s0	long
,	O
c0	char
)	O
;	O
sprintc	function
(	O
s1	pointer
,	O
c1	char
)	O
;	O
printf	function
(	O
_	O
(	O
"%s %s differ: byte %s, line %s is %3o %s %3o %s\n"	pointer
)	O
,	O
file	array
[	O
0	int
]	O
,	O
file	array
[	O
1	int
]	O
,	O
byte_num	pointer
,	O
line_num	pointer
,	O
c0	char
,	O
s0	long
,	O
c1	char
,	O
s1	pointer
)	O
;	O
}	O
}	O
case	O
type_status	int
:	O
return	O
EXIT_FAILURE	int
;	O
case	O
type_all_diffs	int
:	O
do	O
{	O
unsigned	O
char	O
c0	char
=	O
buf0	pointer
[	O
first_diff	long
]	O
;	O
unsigned	O
char	O
c1	char
=	O
buf1	pointer
[	O
first_diff	long
]	O
;	O
if	O
(	O
c0	char
!=	O
c1	char
)	O
{	O
char	O
byte_buf	array
[	O
INT_BUFSIZE_BOUND	O
(	O
off_t	long
)	O
]	O
;	O
char	O
const	O
*	O
byte_num	pointer
=	O
offtostr	function
(	O
byte_number	long
,	O
byte_buf	array
)	O
;	O
if	O
(	O
!	O
opt_print_bytes	bool
)	O
{	O
printf	function
(	O
"%*s %3o %3o\n"	pointer
,	O
offset_width	int
,	O
byte_num	pointer
,	O
c0	char
,	O
c1	char
)	O
;	O
}	O
else	O
{	O
char	O
s0	long
[	O
5	int
]	O
;	O
char	O
s1	pointer
[	O
5	int
]	O
;	O
sprintc	function
(	O
s0	long
,	O
c0	char
)	O
;	O
sprintc	function
(	O
s1	pointer
,	O
c1	char
)	O
;	O
printf	function
(	O
"%*s %3o %-4s %3o %s\n"	pointer
,	O
offset_width	int
,	O
byte_num	pointer
,	O
c0	char
,	O
s0	long
,	O
c1	char
,	O
s1	pointer
)	O
;	O
}	O
}	O
byte_number	long
++	O
;	O
first_diff	long
++	O
;	O
}	O
while	O
(	O
first_diff	long
<	O
smaller	long
)	O
;	O
differing	int
=	O
-	O
1	int
;	O
break	O
;	O
case	O
type_no_stdout	int
:	O
differing	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
read0	long
!=	O
read1	long
)	O
{	O
if	O
(	O
differing	int
<=	O
0	int
&&	O
comparison_type	enum
!=	O
type_status	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"cmp: EOF on %s\n"	pointer
)	O
,	O
file	array
[	O
read1	long
<	O
read0	long
]	O
)	O
;	O
}	O
return	O
EXIT_FAILURE	int
;	O
}	O
}	O
while	O
(	O
differing	int
<=	O
0	int
&&	O
read0	long
==	O
buf_size	long
)	O
;	O
return	O
differing	int
==	O
0	int
?	O
EXIT_SUCCESS	int
:	O
EXIT_FAILURE	int
;	O
}	O
static	O
size_t	long
block_compare_and_count	function
(	O
word	O
const	O
*	O
p0	pointer
,	O
word	O
const	O
*	O
p1	pointer
,	O
off_t	long
*	O
count	pointer
)	O
{	O
word	O
l	long
;	O
word	O
const	O
*	O
l0	pointer
,	O
*	O
l1	pointer
;	O
char	O
const	O
*	O
c0	char
,	O
*	O
c1	char
;	O
size_t	long
cnt	long
=	O
0	int
;	O
word	O
nnnn	long
;	O
int	O
i	int
;	O
nnnn	long
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
nnnn	long
;	O
i	int
++	O
)	O
nnnn	long
=	O
(	O
nnnn	long
<<	O
CHAR_BIT	O
)	O
|	O
'\n'	O
;	O
for	O
(	O
l0	pointer
=	O
p0	pointer
,	O
l1	pointer
=	O
p1	pointer
;	O
(	O
l	long
=	O
*	O
l0	pointer
)	O
==	O
*	O
l1	pointer
;	O
l0	pointer
++	O
,	O
l1	pointer
++	O
)	O
{	O
l	long
^=	O
nnnn	long
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
l	long
;	O
i	int
++	O
)	O
{	O
unsigned	O
char	O
uc	char
=	O
l	long
;	O
cnt	long
+=	O
!	O
uc	char
;	O
l	long
>>=	O
CHAR_BIT	O
;	O
}	O
}	O
for	O
(	O
c0	char
=	O
(	O
char	O
const	O
*	O
)	O
l0	pointer
,	O
c1	char
=	O
(	O
char	O
const	O
*	O
)	O
l1	pointer
;	O
*	O
c0	char
==	O
*	O
c1	char
;	O
c0	char
++	O
,	O
c1	char
++	O
)	O
cnt	long
+=	O
*	O
c0	char
==	O
'\n'	O
;	O
*	O
count	pointer
+=	O
cnt	long
;	O
return	O
c0	char
-	O
(	O
char	O
const	O
*	O
)	O
p0	pointer
;	O
}	O
static	O
size_t	long
block_compare	function
(	O
word	O
const	O
*	O
p0	pointer
,	O
word	O
const	O
*	O
p1	pointer
)	O
{	O
word	O
const	O
*	O
l0	pointer
,	O
*	O
l1	pointer
;	O
char	O
const	O
*	O
c0	char
,	O
*	O
c1	char
;	O
for	O
(	O
l0	pointer
=	O
p0	pointer
,	O
l1	pointer
=	O
p1	pointer
;	O
*	O
l0	pointer
==	O
*	O
l1	pointer
;	O
l0	pointer
++	O
,	O
l1	pointer
++	O
)	O
continue	O
;	O
for	O
(	O
c0	char
=	O
(	O
char	O
const	O
*	O
)	O
l0	pointer
,	O
c1	char
=	O
(	O
char	O
const	O
*	O
)	O
l1	pointer
;	O
*	O
c0	char
==	O
*	O
c1	char
;	O
c0	char
++	O
,	O
c1	char
++	O
)	O
continue	O
;	O
return	O
c0	char
-	O
(	O
char	O
const	O
*	O
)	O
p0	pointer
;	O
}	O
static	O
void	O
sprintc	function
(	O
char	O
*	O
buf	pointer
,	O
unsigned	O
char	O
c	int
)	O
{	O
if	O
(	O
!	O
isprint	function
(	O
c	int
)	O
)	O
{	O
if	O
(	O
c	int
>=	O
128	int
)	O
{	O
*	O
buf	pointer
++	O
=	O
'M'	O
;	O
*	O
buf	pointer
++	O
=	O
'-'	O
;	O
c	int
-=	O
128	int
;	O
}	O
if	O
(	O
c	int
<	O
32	int
)	O
{	O
*	O
buf	pointer
++	O
=	O
'^'	O
;	O
c	int
+=	O
64	int
;	O
}	O
else	O
if	O
(	O
c	int
==	O
127	int
)	O
{	O
*	O
buf	pointer
++	O
=	O
'^'	O
;	O
c	int
=	O
'?'	O
;	O
}	O
}	O
*	O
buf	pointer
++	O
=	O
c	int
;	O
*	O
buf	pointer
=	O
0	int
;	O
}	O
static	O
off_t	long
file_position	function
(	O
int	O
f	int
)	O
{	O
static	O
bool	bool
positioned	array
[	O
2	int
]	O
;	O
static	O
off_t	long
position	array
[	O
2	int
]	O
;	O
if	O
(	O
!	O
positioned	array
[	O
f	int
]	O
)	O
{	O
positioned	array
[	O
f	int
]	O
=	O
true	int
;	O
position	array
[	O
f	int
]	O
=	O
lseek	function
(	O
file_desc	array
[	O
f	int
]	O
,	O
ignore_initial	array
[	O
f	int
]	O
,	O
SEEK_CUR	int
)	O
;	O
}	O
return	O
position	array
[	O
f	int
]	O
;	O
}	O
