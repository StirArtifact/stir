static	O
void	O
mouse_event_handler	function
(	O
void	O
)	O
;	O
static	O
FILE	struct
*	O
info_input_stream	pointer
=	O
NULL	O
;	O
static	O
int	O
quit_info_immediately	int
=	O
0	int
;	O
static	O
NODE	struct
*	O
allfiles_node	pointer
=	O
0	int
;	O
DECLARE_INFO_COMMAND	O
(	O
info_all_files	function
,	O
_	O
(	O
"Show all matching files"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
allfiles_node	pointer
)	O
{	O
info_error	function
(	O
_	O
(	O
"No file index"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
info_set_node_of_window	function
(	O
window	pointer
,	O
allfiles_node	pointer
)	O
;	O
}	O
static	O
void	O
allfiles_create_node	function
(	O
char	O
*	O
term	pointer
,	O
REFERENCE	struct
*	O
*	O
fref	pointer
)	O
{	O
int	O
i	int
;	O
struct	O
text_buffer	struct
text	pointer
;	O
text_buffer_init	function
(	O
&	O
text	pointer
)	O
;	O
text_buffer_printf	function
(	O
&	O
text	pointer
,	O
"%s File names matching '%s'\n\n"	pointer
"Info File Index\n"	pointer
"***************\n\n"	pointer
"File names that match '%s':\n"	pointer
,	O
INFO_NODE_LABEL	pointer
,	O
term	pointer
,	O
term	pointer
)	O
;	O
text_buffer_add_string	function
(	O
&	O
text	pointer
,	O
"\0\b[index\0\b]"	pointer
,	O
11	int
)	O
;	O
text_buffer_printf	function
(	O
&	O
text	pointer
,	O
"\n* Menu:\n\n"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
fref	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
text_buffer_printf	function
(	O
&	O
text	pointer
,	O
"* %4i: (%s)"	pointer
,	O
i	int
+	O
1	int
,	O
fref	pointer
[	O
i	int
]	O
->	O
filename	pointer
)	O
;	O
if	O
(	O
fref	pointer
[	O
i	int
]	O
->	O
nodename	pointer
)	O
text_buffer_printf	function
(	O
&	O
text	pointer
,	O
"%s"	pointer
,	O
fref	pointer
[	O
i	int
]	O
->	O
nodename	pointer
)	O
;	O
text_buffer_printf	function
(	O
&	O
text	pointer
,	O
".\n"	pointer
)	O
;	O
}	O
allfiles_node	pointer
=	O
info_create_node	function
(	O
)	O
;	O
allfiles_node	pointer
->	O
fullpath	pointer
=	O
xstrdup	function
(	O
""	pointer
)	O
;	O
allfiles_node	pointer
->	O
nodename	pointer
=	O
xstrdup	function
(	O
"*Info File Index*"	pointer
)	O
;	O
allfiles_node	pointer
->	O
contents	pointer
=	O
text_buffer_base	O
(	O
&	O
text	pointer
)	O
;	O
allfiles_node	pointer
->	O
nodelen	long
=	O
text_buffer_off	O
(	O
&	O
text	pointer
)	O
;	O
allfiles_node	pointer
->	O
body_start	long
=	O
strcspn	function
(	O
allfiles_node	pointer
->	O
contents	pointer
,	O
"\n"	pointer
)	O
;	O
scan_node_contents	function
(	O
allfiles_node	pointer
,	O
0	int
,	O
0	int
)	O
;	O
}	O
static	O
void	O
begin_multiple_window_info_session	function
(	O
REFERENCE	struct
*	O
*	O
references	pointer
,	O
char	O
*	O
error	pointer
)	O
{	O
register	O
int	O
i	int
;	O
WINDOW	struct
*	O
window	pointer
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
references	pointer
&&	O
references	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
!	O
window	pointer
)	O
{	O
window	pointer
=	O
active_window	pointer
;	O
info_select_reference	function
(	O
window	pointer
,	O
references	pointer
[	O
i	int
]	O
)	O
;	O
if	O
(	O
!	O
window	pointer
->	O
node	pointer
)	O
window	pointer
=	O
0	int
;	O
}	O
else	O
{	O
WINDOW	struct
*	O
win	pointer
,	O
*	O
largest	pointer
=	O
NULL	O
;	O
int	O
max_height	int
=	O
0	int
;	O
for	O
(	O
win	pointer
=	O
windows	pointer
;	O
win	pointer
;	O
win	pointer
=	O
win	pointer
->	O
next	pointer
)	O
if	O
(	O
win	pointer
->	O
height	long
>	O
max_height	int
)	O
{	O
max_height	int
=	O
win	pointer
->	O
height	long
;	O
largest	pointer
=	O
win	pointer
;	O
}	O
if	O
(	O
!	O
largest	pointer
)	O
{	O
display_update_display	function
(	O
)	O
;	O
info_error	function
(	O
"%s"	pointer
,	O
msg_cant_find_window	pointer
)	O
;	O
return	O
;	O
}	O
active_window	pointer
=	O
largest	pointer
;	O
window	pointer
=	O
window_make_window	function
(	O
)	O
;	O
info_select_reference	function
(	O
window	pointer
,	O
references	pointer
[	O
i	int
]	O
)	O
;	O
if	O
(	O
!	O
window	pointer
->	O
node	pointer
)	O
{	O
window_delete_window	function
(	O
window	pointer
)	O
;	O
window	pointer
=	O
0	int
;	O
}	O
if	O
(	O
window	pointer
)	O
window_tile_windows	function
(	O
TILE_INTERNALS	int
)	O
;	O
else	O
{	O
display_update_display	function
(	O
)	O
;	O
info_error	function
(	O
"%s"	pointer
,	O
msg_win_too_small	pointer
)	O
;	O
return	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
window	pointer
)	O
{	O
info_set_node_of_window	function
(	O
active_window	pointer
,	O
get_dir_node	function
(	O
)	O
)	O
;	O
return	O
;	O
}	O
}	O
static	O
void	O
display_startup_message	function
(	O
void	O
)	O
{	O
char	O
*	O
format	pointer
;	O
format	pointer
=	O
replace_in_documentation	function
(	O
_	O
(	O
"Welcome to Info version %s.  Type \\[get-help-window] for help, \\[get-info-help-node] for tutorial."	pointer
)	O
,	O
0	int
)	O
;	O
window_message_in_echo_area	function
(	O
format	pointer
,	O
VERSION	pointer
,	O
NULL	O
)	O
;	O
}	O
void	O
info_session	function
(	O
REFERENCE	struct
*	O
*	O
ref_list	pointer
,	O
char	O
*	O
user_filename	pointer
,	O
char	O
*	O
error	pointer
)	O
{	O
initialize_info_session	function
(	O
)	O
;	O
if	O
(	O
!	O
error	pointer
)	O
display_startup_message	function
(	O
)	O
;	O
else	O
show_error_node	function
(	O
error	pointer
)	O
;	O
if	O
(	O
!	O
user_filename	pointer
)	O
begin_multiple_window_info_session	function
(	O
ref_list	pointer
,	O
error	pointer
)	O
;	O
else	O
{	O
allfiles_create_node	function
(	O
user_filename	pointer
,	O
ref_list	pointer
)	O
;	O
info_set_node_of_window	function
(	O
active_window	pointer
,	O
allfiles_node	pointer
)	O
;	O
}	O
info_read_and_dispatch	function
(	O
)	O
;	O
close_info_session	function
(	O
)	O
;	O
}	O
void	O
info_next_line	function
(	O
WINDOW	struct
*	O
,	O
int	O
count	pointer
)	O
;	O
void	O
info_prev_line	function
(	O
WINDOW	struct
*	O
,	O
int	O
count	pointer
)	O
;	O
static	O
int	O
info_keyseq_displayed_p	int
;	O
void	O
info_read_and_dispatch	function
(	O
void	O
)	O
{	O
VFunction	function
*	O
cmd	pointer
;	O
int	O
count	pointer
;	O
for	O
(	O
quit_info_immediately	int
=	O
0	int
;	O
!	O
quit_info_immediately	int
;	O
)	O
{	O
if	O
(	O
!	O
info_any_buffered_input_p	function
(	O
)	O
)	O
display_update_display	function
(	O
)	O
;	O
if	O
(	O
hl_ref_rendition	struct
.	O
mask	long
)	O
display_update_one_window	function
(	O
active_window	pointer
)	O
;	O
display_cursor_at_point	function
(	O
active_window	pointer
)	O
;	O
cmd	pointer
=	O
read_key_sequence	function
(	O
info_keymap	pointer
,	O
1	int
,	O
1	int
,	O
0	int
,	O
&	O
count	pointer
)	O
;	O
if	O
(	O
cmd	pointer
)	O
{	O
if	O
(	O
!	O
info_keyseq_displayed_p	int
)	O
window_clear_echo_area	function
(	O
)	O
;	O
(	O
*	O
cmd	pointer
)	O
(	O
active_window	pointer
,	O
count	pointer
)	O
;	O
if	O
(	O
!	O
(	O
cmd	pointer
==	O
&	O
info_next_line	function
||	O
cmd	pointer
==	O
&	O
info_prev_line	function
)	O
)	O
active_window	pointer
->	O
goal_column	long
=	O
-	O
1	int
;	O
}	O
}	O
}	O
extern	O
void	O
initialize_info_signal_handler	function
(	O
void	O
)	O
;	O
void	O
initialize_terminal_and_keymaps	function
(	O
char	O
*	O
init_file	pointer
)	O
{	O
char	O
*	O
term_name	pointer
=	O
getenv	function
(	O
"TERM"	pointer
)	O
;	O
terminal_initialize_terminal	function
(	O
term_name	pointer
)	O
;	O
read_init_file	function
(	O
init_file	pointer
)	O
;	O
}	O
void	O
initialize_info_session	function
(	O
void	O
)	O
{	O
if	O
(	O
!	O
terminal_prep_terminal	function
(	O
)	O
)	O
{	O
char	O
*	O
term_name	pointer
=	O
getenv	function
(	O
"TERM"	pointer
)	O
;	O
info_error	function
(	O
msg_term_too_dumb	pointer
,	O
term_name	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
terminal_clear_screen	function
(	O
)	O
;	O
window_initialize_windows	function
(	O
screenwidth	int
,	O
screenheight	int
)	O
;	O
initialize_info_signal_handler	function
(	O
)	O
;	O
display_initialize_display	function
(	O
screenwidth	int
,	O
screenheight	int
)	O
;	O
if	O
(	O
!	O
info_input_stream	pointer
)	O
{	O
setbuf	function
(	O
stdin	pointer
,	O
NULL	O
)	O
;	O
info_input_stream	pointer
=	O
stdin	pointer
;	O
}	O
info_windows_initialized_p	int
=	O
1	int
;	O
}	O
void	O
close_info_session	function
(	O
void	O
)	O
{	O
terminal_goto_xy	function
(	O
0	int
,	O
screenheight	int
-	O
1	int
)	O
;	O
terminal_clear_to_eol	function
(	O
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
terminal_unprep_terminal	function
(	O
)	O
;	O
close_dribble_file	function
(	O
)	O
;	O
}	O
void	O
info_set_input_from_file	function
(	O
char	O
*	O
filename	pointer
)	O
{	O
FILE	struct
*	O
stream	pointer
;	O
stream	pointer
=	O
fopen	function
(	O
filename	pointer
,	O
FOPEN_RBIN	pointer
)	O
;	O
if	O
(	O
!	O
stream	pointer
)	O
return	O
;	O
if	O
(	O
(	O
info_input_stream	pointer
!=	O
NULL	O
)	O
&&	O
(	O
info_input_stream	pointer
!=	O
stdin	pointer
)	O
)	O
fclose	function
(	O
info_input_stream	pointer
)	O
;	O
info_input_stream	pointer
=	O
stream	pointer
;	O
if	O
(	O
stream	pointer
!=	O
stdin	pointer
)	O
display_inhibited	int
=	O
1	int
;	O
}	O
static	O
void	O
fill_input_buffer	function
(	O
int	O
wait	int
)	O
;	O
static	O
int	O
info_gather_typeahead	function
(	O
int	O
)	O
;	O
static	O
int	O
pop_index	int
=	O
0	int
;	O
static	O
int	O
push_index	int
=	O
0	int
;	O
static	O
unsigned	O
char	O
info_input_buffer	array
[	O
MAX_INFO_INPUT_BUFFERING	int
]	O
;	O
static	O
int	O
get_byte_from_input_buffer	function
(	O
unsigned	O
char	O
*	O
key	int
)	O
{	O
if	O
(	O
push_index	int
==	O
pop_index	int
)	O
return	O
0	int
;	O
*	O
key	int
=	O
info_input_buffer	array
[	O
pop_index	int
++	O
]	O
;	O
if	O
(	O
pop_index	int
>=	O
MAX_INFO_INPUT_BUFFERING	int
)	O
pop_index	int
=	O
0	int
;	O
return	O
1	int
;	O
}	O
int	O
info_any_buffered_input_p	function
(	O
void	O
)	O
{	O
fill_input_buffer	function
(	O
0	int
)	O
;	O
return	O
push_index	int
!=	O
pop_index	int
;	O
}	O
static	O
void	O
fill_input_buffer	function
(	O
int	O
wait	int
)	O
{	O
while	O
(	O
1	int
)	O
{	O
int	O
success	int
;	O
do	O
{	O
success	int
=	O
info_gather_typeahead	function
(	O
wait	int
)	O
;	O
}	O
while	O
(	O
!	O
success	int
&&	O
errno	O
==	O
EINTR	int
)	O
;	O
if	O
(	O
success	int
||	O
!	O
wait	int
)	O
return	O
;	O
if	O
(	O
info_input_stream	pointer
!=	O
stdin	pointer
)	O
{	O
fclose	function
(	O
info_input_stream	pointer
)	O
;	O
info_input_stream	pointer
=	O
stdin	pointer
;	O
display_inhibited	int
=	O
0	int
;	O
display_update_display	function
(	O
)	O
;	O
display_cursor_at_point	function
(	O
active_window	pointer
)	O
;	O
}	O
else	O
{	O
close_info_session	function
(	O
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
}	O
}	O
static	O
int	O
info_gather_typeahead	function
(	O
int	O
wait	int
)	O
{	O
register	O
int	O
i	int
=	O
0	int
;	O
int	O
tty	int
,	O
space_avail	int
;	O
long	O
chars_avail	long
;	O
unsigned	O
char	O
input	array
[	O
MAX_INFO_INPUT_BUFFERING	int
]	O
;	O
tty	int
=	O
fileno	function
(	O
info_input_stream	pointer
)	O
;	O
chars_avail	long
=	O
0	int
;	O
errno	O
=	O
0	int
;	O
if	O
(	O
wait	int
&&	O
pop_index	int
==	O
push_index	int
)	O
{	O
char	O
c	int
;	O
if	O
(	O
read	pointer
(	O
tty	int
,	O
&	O
c	int
,	O
1	int
)	O
<=	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
info_dribble_file	pointer
)	O
dribble	function
(	O
c	int
)	O
;	O
info_input_buffer	array
[	O
push_index	int
++	O
]	O
=	O
c	int
;	O
if	O
(	O
push_index	int
>=	O
MAX_INFO_INPUT_BUFFERING	int
)	O
push_index	int
=	O
0	int
;	O
}	O
if	O
(	O
pop_index	int
>	O
push_index	int
)	O
space_avail	int
=	O
pop_index	int
-	O
push_index	int
;	O
else	O
space_avail	int
=	O
sizeof	O
(	O
info_input_buffer	array
)	O
-	O
(	O
push_index	int
-	O
pop_index	int
)	O
;	O
{	O
ioctl	function
(	O
tty	int
,	O
FIONREAD	int
,	O
&	O
chars_avail	long
)	O
;	O
if	O
(	O
chars_avail	long
>	O
space_avail	int
)	O
chars_avail	long
=	O
space_avail	int
;	O
if	O
(	O
chars_avail	long
)	O
chars_avail	long
=	O
read	pointer
(	O
tty	int
,	O
&	O
input	array
[	O
0	int
]	O
,	O
chars_avail	long
)	O
;	O
}	O
while	O
(	O
i	int
<	O
chars_avail	long
)	O
{	O
if	O
(	O
info_dribble_file	pointer
)	O
dribble	function
(	O
input	array
[	O
i	int
]	O
)	O
;	O
if	O
(	O
input	array
[	O
i	int
]	O
!=	O
Control	O
(	O
'g'	O
)	O
)	O
{	O
info_input_buffer	array
[	O
push_index	int
++	O
]	O
=	O
input	array
[	O
i	int
]	O
;	O
if	O
(	O
push_index	int
>=	O
MAX_INFO_INPUT_BUFFERING	int
)	O
push_index	int
=	O
0	int
;	O
}	O
else	O
push_index	int
=	O
pop_index	int
;	O
i	int
++	O
;	O
}	O
if	O
(	O
chars_avail	long
<=	O
0	int
&&	O
!	O
wait	int
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
int	O
get_input_key_internal	function
(	O
void	O
)	O
;	O
static	O
void	O
_scroll_forward	function
(	O
WINDOW	struct
*	O
window	pointer
,	O
int	O
count	pointer
,	O
int	O
nodeonly	int
)	O
;	O
static	O
void	O
_scroll_backward	function
(	O
WINDOW	struct
*	O
window	pointer
,	O
int	O
count	pointer
,	O
int	O
nodeonly	int
)	O
;	O
unsigned	O
char	O
mouse_cb	char
,	O
mouse_cx	char
,	O
mouse_cy	char
;	O
void	O
mouse_event_handler	function
(	O
void	O
)	O
{	O
if	O
(	O
mouse_cb	char
&	O
0x40	int
)	O
{	O
switch	O
(	O
mouse_cb	char
&	O
0x03	int
)	O
{	O
case	O
0	int
:	O
_scroll_backward	function
(	O
active_window	pointer
,	O
3	int
,	O
1	int
)	O
;	O
break	O
;	O
case	O
1	int
:	O
_scroll_forward	function
(	O
active_window	pointer
,	O
3	int
,	O
1	int
)	O
;	O
break	O
;	O
}	O
}	O
}	O
int	O
get_input_key	function
(	O
void	O
)	O
{	O
int	O
ret	int
=	O
-	O
1	int
;	O
while	O
(	O
ret	int
==	O
-	O
1	int
)	O
{	O
ret	int
=	O
get_input_key_internal	function
(	O
)	O
;	O
if	O
(	O
ret	int
==	O
KEY_MOUSE	int
)	O
{	O
get_byte_from_input_buffer	function
(	O
&	O
mouse_cb	char
)	O
;	O
get_byte_from_input_buffer	function
(	O
&	O
mouse_cx	char
)	O
;	O
get_byte_from_input_buffer	function
(	O
&	O
mouse_cy	char
)	O
;	O
}	O
}	O
return	O
ret	int
;	O
}	O
int	O
key_time	int
=	O
100	int
;	O
static	O
int	O
get_input_key_internal	function
(	O
void	O
)	O
{	O
BYTEMAP_ENTRY	struct
*	O
b	pointer
;	O
unsigned	O
char	O
c	int
;	O
int	O
esc_seen	int
=	O
0	int
;	O
int	O
pop_start	int
;	O
int	O
byte_count	int
=	O
0	int
;	O
fill_input_buffer	function
(	O
1	int
)	O
;	O
if	O
(	O
pop_index	int
==	O
push_index	int
)	O
return	O
-	O
1	int
;	O
b	pointer
=	O
byte_seq_to_key	pointer
;	O
pop_start	int
=	O
pop_index	int
;	O
while	O
(	O
pop_index	int
!=	O
push_index	int
)	O
{	O
int	O
in_map	int
=	O
0	int
;	O
int	O
unknown	int
=	O
0	int
;	O
if	O
(	O
!	O
get_byte_from_input_buffer	function
(	O
&	O
c	int
)	O
)	O
break	O
;	O
byte_count	int
++	O
;	O
switch	O
(	O
b	pointer
[	O
c	int
]	O
.	O
type	enum
)	O
{	O
case	O
BYTEMAP_KEY	int
:	O
return	O
b	pointer
[	O
c	int
]	O
.	O
key	int
;	O
case	O
BYTEMAP_ESC	int
:	O
esc_seen	int
=	O
1	int
;	O
case	O
BYTEMAP_MAP	int
:	O
in_map	int
=	O
1	int
;	O
b	pointer
=	O
b	pointer
[	O
c	int
]	O
.	O
next	pointer
;	O
break	O
;	O
case	O
BYTEMAP_NONE	int
:	O
unknown	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
unknown	int
)	O
break	O
;	O
if	O
(	O
in_map	int
&&	O
pop_index	int
==	O
push_index	int
)	O
{	O
int	O
ready	int
=	O
0	int
;	O
struct	O
timeval	struct
timer	struct
,	O
*	O
timerp	pointer
=	O
0	int
;	O
fd_set	struct
readfds	struct
;	O
FD_ZERO	O
(	O
&	O
readfds	struct
)	O
;	O
FD_SET	O
(	O
fileno	function
(	O
info_input_stream	pointer
)	O
,	O
&	O
readfds	struct
)	O
;	O
timer	struct
.	O
tv_sec	long
=	O
0	int
;	O
timer	struct
.	O
tv_usec	long
=	O
key_time	int
*	O
1000	int
;	O
timerp	pointer
=	O
&	O
timer	struct
;	O
ready	int
=	O
select	function
(	O
fileno	function
(	O
info_input_stream	pointer
)	O
+	O
1	int
,	O
&	O
readfds	struct
,	O
NULL	O
,	O
NULL	O
,	O
timerp	pointer
)	O
;	O
if	O
(	O
ready	int
)	O
fill_input_buffer	function
(	O
0	int
)	O
;	O
}	O
}	O
pop_index	int
=	O
pop_start	int
;	O
if	O
(	O
!	O
esc_seen	int
||	O
(	O
byte_count	int
>=	O
3	int
&&	O
key_time	int
==	O
0	int
)	O
)	O
{	O
pop_index	int
=	O
pop_start	int
;	O
get_byte_from_input_buffer	function
(	O
&	O
c	int
)	O
;	O
return	O
c	int
;	O
}	O
else	O
{	O
get_byte_from_input_buffer	function
(	O
&	O
c	int
)	O
;	O
if	O
(	O
pop_index	int
==	O
push_index	int
)	O
return	O
033	int
;	O
get_byte_from_input_buffer	function
(	O
&	O
c	int
)	O
;	O
if	O
(	O
c	int
==	O
'O'	O
)	O
{	O
if	O
(	O
!	O
info_any_buffered_input_p	function
(	O
)	O
)	O
return	O
'O'	O
+	O
KEYMAP_META_BASE	int
;	O
get_byte_from_input_buffer	function
(	O
&	O
c	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'['	O
)	O
{	O
if	O
(	O
!	O
get_byte_from_input_buffer	function
(	O
&	O
c	int
)	O
)	O
return	O
'['	O
+	O
KEYMAP_META_BASE	int
;	O
while	O
(	O
c	int
>=	O
0x30	int
&&	O
c	int
<=	O
0x3f	int
)	O
if	O
(	O
!	O
get_byte_from_input_buffer	function
(	O
&	O
c	int
)	O
)	O
break	O
;	O
while	O
(	O
c	int
>=	O
0x20	int
&&	O
c	int
<=	O
0x2f	int
)	O
if	O
(	O
!	O
get_byte_from_input_buffer	function
(	O
&	O
c	int
)	O
)	O
break	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
return	O
c	int
+	O
KEYMAP_META_BASE	int
;	O
}	O
}	O
}	O
void	O
pause_or_input	function
(	O
void	O
)	O
{	O
struct	O
timeval	struct
timer	struct
;	O
fd_set	struct
readfds	struct
;	O
if	O
(	O
pop_index	int
!=	O
push_index	int
)	O
return	O
;	O
FD_ZERO	O
(	O
&	O
readfds	struct
)	O
;	O
FD_SET	O
(	O
fileno	function
(	O
stdin	pointer
)	O
,	O
&	O
readfds	struct
)	O
;	O
timer	struct
.	O
tv_sec	long
=	O
2	int
;	O
timer	struct
.	O
tv_usec	long
=	O
0	int
;	O
select	function
(	O
fileno	function
(	O
stdin	pointer
)	O
+	O
1	int
,	O
&	O
readfds	struct
,	O
NULL	O
,	O
NULL	O
,	O
&	O
timer	struct
)	O
;	O
}	O
unsigned	O
debug_level	int
;	O
static	O
void	O
vinfo_debug	function
(	O
const	O
char	O
*	O
format	pointer
,	O
va_list	array
ap	array
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: "	pointer
,	O
program_name	pointer
)	O
;	O
vfprintf	function
(	O
stderr	pointer
,	O
format	pointer
,	O
ap	array
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
}	O
void	O
info_debug	function
(	O
const	O
char	O
*	O
format	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
format	pointer
)	O
;	O
vinfo_debug	function
(	O
format	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
}	O
int	O
info_error_rings_bell_p	int
=	O
1	int
;	O
static	O
void	O
vinfo_error	function
(	O
const	O
char	O
*	O
format	pointer
,	O
va_list	array
ap	array
)	O
{	O
if	O
(	O
!	O
info_windows_initialized_p	int
||	O
display_inhibited	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: "	pointer
,	O
program_name	pointer
)	O
;	O
vfprintf	function
(	O
stderr	pointer
,	O
format	pointer
,	O
ap	array
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
echo_area_is_active	int
)	O
{	O
if	O
(	O
info_error_rings_bell_p	int
)	O
terminal_ring_bell	function
(	O
)	O
;	O
vwindow_message_in_echo_area	function
(	O
format	pointer
,	O
ap	array
)	O
;	O
}	O
else	O
{	O
NODE	struct
*	O
temp	pointer
=	O
build_message_node	function
(	O
format	pointer
,	O
ap	array
)	O
;	O
if	O
(	O
info_error_rings_bell_p	int
)	O
terminal_ring_bell	function
(	O
)	O
;	O
inform_in_echo_area	function
(	O
temp	pointer
->	O
contents	pointer
)	O
;	O
free	function
(	O
temp	pointer
->	O
contents	pointer
)	O
;	O
free	function
(	O
temp	pointer
)	O
;	O
}	O
}	O
}	O
void	O
info_error	function
(	O
const	O
char	O
*	O
format	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
format	pointer
)	O
;	O
vinfo_error	function
(	O
format	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
}	O
void	O
show_error_node	function
(	O
char	O
*	O
error	pointer
)	O
{	O
if	O
(	O
info_error_rings_bell_p	int
)	O
terminal_ring_bell	function
(	O
)	O
;	O
if	O
(	O
!	O
info_windows_initialized_p	int
)	O
{	O
info_error	function
(	O
"%s"	pointer
,	O
error	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
echo_area_is_active	int
)	O
{	O
window_message_in_echo_area	function
(	O
"%s"	pointer
,	O
error	pointer
)	O
;	O
}	O
else	O
inform_in_echo_area	function
(	O
error	pointer
)	O
;	O
}	O
void	O
free_history_node	function
(	O
NODE	struct
*	O
n	long
)	O
{	O
if	O
(	O
n	long
&&	O
(	O
n	long
->	O
flags	int
&	O
N_IsInternal	int
)	O
)	O
{	O
free	function
(	O
n	long
->	O
contents	pointer
)	O
;	O
info_free_references	function
(	O
n	long
->	O
references	pointer
)	O
;	O
free	function
(	O
n	long
->	O
next	pointer
)	O
;	O
free	function
(	O
n	long
->	O
prev	pointer
)	O
;	O
free	function
(	O
n	long
->	O
up	pointer
)	O
;	O
free	function
(	O
n	long
->	O
nodename	pointer
)	O
;	O
}	O
free	function
(	O
n	long
)	O
;	O
}	O
static	O
void	O
put_node_in_window	function
(	O
WINDOW	struct
*	O
win	pointer
,	O
NODE	struct
*	O
node	pointer
)	O
{	O
win	pointer
->	O
node	pointer
=	O
node	pointer
;	O
win	pointer
->	O
pagetop	long
=	O
0	int
;	O
win	pointer
->	O
point	long
=	O
0	int
;	O
free_matches	function
(	O
&	O
win	pointer
->	O
matches	pointer
)	O
;	O
free	function
(	O
win	pointer
->	O
line_starts	pointer
)	O
;	O
win	pointer
->	O
line_starts	pointer
=	O
0	int
;	O
free	function
(	O
win	pointer
->	O
log_line_no	pointer
)	O
;	O
win	pointer
->	O
log_line_no	pointer
=	O
0	int
;	O
win	pointer
->	O
flags	int
|=	O
W_UpdateWindow	int
;	O
}	O
int	O
forget_node_fast	function
(	O
WINDOW	struct
*	O
win	pointer
)	O
{	O
int	O
i	int
=	O
win	pointer
->	O
hist_index	long
;	O
if	O
(	O
i	int
==	O
0	int
)	O
return	O
0	int
;	O
free_history_node	function
(	O
win	pointer
->	O
hist	pointer
[	O
i	int
-	O
1	int
]	O
->	O
node	pointer
)	O
;	O
free	function
(	O
win	pointer
->	O
hist	pointer
[	O
i	int
-	O
1	int
]	O
)	O
;	O
win	pointer
->	O
hist	pointer
[	O
i	int
-	O
1	int
]	O
=	O
0	int
;	O
i	int
=	O
--	O
win	pointer
->	O
hist_index	long
;	O
if	O
(	O
i	int
==	O
0	int
)	O
win	pointer
->	O
node	pointer
=	O
0	int
;	O
else	O
{	O
put_node_in_window	function
(	O
win	pointer
,	O
win	pointer
->	O
hist	pointer
[	O
i	int
-	O
1	int
]	O
->	O
node	pointer
)	O
;	O
win	pointer
->	O
point	long
=	O
win	pointer
->	O
hist	pointer
[	O
i	int
-	O
1	int
]	O
->	O
point	long
;	O
}	O
return	O
i	int
;	O
}	O
void	O
forget_node	function
(	O
WINDOW	struct
*	O
win	pointer
)	O
{	O
int	O
i	int
=	O
forget_node_fast	function
(	O
win	pointer
)	O
;	O
if	O
(	O
i	int
==	O
0	int
)	O
{	O
win	pointer
->	O
node	pointer
=	O
0	int
;	O
return	O
;	O
}	O
window_set_node_of_window	function
(	O
win	pointer
,	O
win	pointer
->	O
hist	pointer
[	O
i	int
-	O
1	int
]	O
->	O
node	pointer
)	O
;	O
if	O
(	O
auto_footnotes_p	int
)	O
info_get_or_remove_footnotes	function
(	O
win	pointer
)	O
;	O
set_window_pagetop	function
(	O
win	pointer
,	O
win	pointer
->	O
hist	pointer
[	O
i	int
-	O
1	int
]	O
->	O
pagetop	long
)	O
;	O
win	pointer
->	O
point	long
=	O
win	pointer
->	O
hist	pointer
[	O
i	int
-	O
1	int
]	O
->	O
point	long
;	O
window_compute_line_map	function
(	O
win	pointer
)	O
;	O
win	pointer
->	O
node	pointer
->	O
display_pos	long
=	O
win	pointer
->	O
point	long
;	O
}	O
void	O
forget_window_and_nodes	function
(	O
WINDOW	struct
*	O
win	pointer
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
win	pointer
->	O
hist_index	long
;	O
i	int
++	O
)	O
{	O
free_history_node	function
(	O
win	pointer
->	O
hist	pointer
[	O
i	int
]	O
->	O
node	pointer
)	O
;	O
free	function
(	O
win	pointer
->	O
hist	pointer
[	O
i	int
]	O
)	O
;	O
}	O
free	function
(	O
win	pointer
->	O
hist	pointer
)	O
;	O
}	O
void	O
info_set_node_of_window_fast	function
(	O
WINDOW	struct
*	O
win	pointer
,	O
NODE	struct
*	O
node	pointer
)	O
{	O
WINDOW_STATE	struct
*	O
new	pointer
;	O
if	O
(	O
win	pointer
->	O
hist_index	long
&&	O
win	pointer
->	O
hist	pointer
[	O
win	pointer
->	O
hist_index	long
-	O
1	int
]	O
->	O
node	pointer
==	O
win	pointer
->	O
node	pointer
)	O
{	O
win	pointer
->	O
hist	pointer
[	O
win	pointer
->	O
hist_index	long
-	O
1	int
]	O
->	O
pagetop	long
=	O
win	pointer
->	O
pagetop	long
;	O
win	pointer
->	O
hist	pointer
[	O
win	pointer
->	O
hist_index	long
-	O
1	int
]	O
->	O
point	long
=	O
win	pointer
->	O
point	long
;	O
}	O
put_node_in_window	function
(	O
win	pointer
,	O
node	pointer
)	O
;	O
new	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
WINDOW_STATE	struct
)	O
)	O
;	O
new	pointer
->	O
node	pointer
=	O
win	pointer
->	O
node	pointer
;	O
new	pointer
->	O
pagetop	long
=	O
win	pointer
->	O
pagetop	long
;	O
new	pointer
->	O
point	long
=	O
win	pointer
->	O
point	long
;	O
add_pointer_to_array	O
(	O
new	pointer
,	O
win	pointer
->	O
hist_index	long
,	O
win	pointer
->	O
hist	pointer
,	O
win	pointer
->	O
hist_slots	long
,	O
16	int
)	O
;	O
}	O
void	O
info_set_node_of_window	function
(	O
WINDOW	struct
*	O
win	pointer
,	O
NODE	struct
*	O
node	pointer
)	O
{	O
WINDOW_STATE	struct
*	O
new	pointer
;	O
if	O
(	O
win	pointer
->	O
hist_index	long
&&	O
win	pointer
->	O
hist	pointer
[	O
win	pointer
->	O
hist_index	long
-	O
1	int
]	O
->	O
node	pointer
==	O
win	pointer
->	O
node	pointer
)	O
{	O
win	pointer
->	O
hist	pointer
[	O
win	pointer
->	O
hist_index	long
-	O
1	int
]	O
->	O
pagetop	long
=	O
win	pointer
->	O
pagetop	long
;	O
win	pointer
->	O
hist	pointer
[	O
win	pointer
->	O
hist_index	long
-	O
1	int
]	O
->	O
point	long
=	O
win	pointer
->	O
point	long
;	O
}	O
window_set_node_of_window	function
(	O
win	pointer
,	O
node	pointer
)	O
;	O
new	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
WINDOW_STATE	struct
)	O
)	O
;	O
new	pointer
->	O
node	pointer
=	O
win	pointer
->	O
node	pointer
;	O
new	pointer
->	O
pagetop	long
=	O
win	pointer
->	O
pagetop	long
;	O
new	pointer
->	O
point	long
=	O
win	pointer
->	O
point	long
;	O
add_pointer_to_array	O
(	O
new	pointer
,	O
win	pointer
->	O
hist_index	long
,	O
win	pointer
->	O
hist	pointer
,	O
win	pointer
->	O
hist_slots	long
,	O
16	int
)	O
;	O
if	O
(	O
auto_footnotes_p	int
&&	O
!	O
(	O
(	O
win	pointer
->	O
node	pointer
->	O
flags	int
&	O
N_IsInternal	int
)	O
&&	O
!	O
strcmp	function
(	O
win	pointer
->	O
node	pointer
->	O
nodename	pointer
,	O
"*Footnotes*"	pointer
)	O
)	O
)	O
info_get_or_remove_footnotes	function
(	O
win	pointer
)	O
;	O
}	O
static	O
int	O
forward_move_node_structure	function
(	O
WINDOW	struct
*	O
window	pointer
,	O
int	O
behaviour	int
)	O
;	O
static	O
int	O
backward_move_node_structure	function
(	O
WINDOW	struct
*	O
window	pointer
,	O
int	O
behaviour	int
)	O
;	O
int	O
cursor_movement_scrolls_p	int
=	O
1	int
;	O
int	O
window_scroll_step	int
=	O
1	int
;	O
static	O
void	O
info_show_point	function
(	O
WINDOW	struct
*	O
window	pointer
)	O
{	O
if	O
(	O
window_scroll_step	int
==	O
0	int
)	O
window_adjust_pagetop	function
(	O
window	pointer
)	O
;	O
else	O
{	O
int	O
new_pagetop	int
=	O
window	pointer
->	O
pagetop	long
;	O
int	O
line	pointer
=	O
window_line_of_point	function
(	O
window	pointer
)	O
;	O
if	O
(	O
line	pointer
<	O
window	pointer
->	O
pagetop	long
)	O
new_pagetop	int
-=	O
window_scroll_step	int
;	O
else	O
if	O
(	O
line	pointer
>=	O
window	pointer
->	O
pagetop	long
+	O
window	pointer
->	O
height	long
)	O
new_pagetop	int
+=	O
window_scroll_step	int
;	O
if	O
(	O
line	pointer
>=	O
new_pagetop	int
&&	O
line	pointer
<	O
new_pagetop	int
+	O
window	pointer
->	O
height	long
)	O
set_window_pagetop	function
(	O
window	pointer
,	O
new_pagetop	int
)	O
;	O
else	O
window_adjust_pagetop	function
(	O
window	pointer
)	O
;	O
}	O
if	O
(	O
window	pointer
->	O
flags	int
&	O
W_UpdateWindow	int
)	O
display_update_one_window	function
(	O
window	pointer
)	O
;	O
display_cursor_at_point	function
(	O
window	pointer
)	O
;	O
}	O
static	O
int	O
point_next_line	function
(	O
WINDOW	struct
*	O
win	pointer
)	O
{	O
int	O
line	pointer
=	O
window_line_of_point	function
(	O
win	pointer
)	O
;	O
if	O
(	O
line	pointer
+	O
1	int
<	O
win	pointer
->	O
line_count	long
)	O
{	O
win	pointer
->	O
point	long
=	O
win	pointer
->	O
line_starts	pointer
[	O
line	pointer
+	O
1	int
]	O
;	O
window_compute_line_map	function
(	O
win	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
cursor_movement_scrolls_p	int
&&	O
forward_move_node_structure	function
(	O
win	pointer
,	O
info_scroll_behaviour	int
)	O
==	O
0	int
)	O
{	O
win	pointer
->	O
point	long
=	O
0	int
;	O
window_compute_line_map	function
(	O
win	pointer
)	O
;	O
return	O
1	int
;	O
}	O
win	pointer
->	O
point	long
=	O
win	pointer
->	O
node	pointer
->	O
nodelen	long
-	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
point_prev_line	function
(	O
WINDOW	struct
*	O
win	pointer
)	O
{	O
int	O
line	pointer
=	O
window_line_of_point	function
(	O
win	pointer
)	O
;	O
if	O
(	O
line	pointer
>	O
0	int
)	O
{	O
win	pointer
->	O
point	long
=	O
win	pointer
->	O
line_starts	pointer
[	O
line	pointer
-	O
1	int
]	O
;	O
window_compute_line_map	function
(	O
win	pointer
)	O
;	O
win	pointer
->	O
point	long
=	O
win	pointer
->	O
line_map	struct
.	O
map	pointer
[	O
win	pointer
->	O
line_map	struct
.	O
used	long
-	O
1	int
]	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
cursor_movement_scrolls_p	int
&&	O
backward_move_node_structure	function
(	O
win	pointer
,	O
info_scroll_behaviour	int
)	O
==	O
0	int
)	O
{	O
win	pointer
->	O
point	long
=	O
win	pointer
->	O
node	pointer
->	O
nodelen	long
-	O
1	int
;	O
if	O
(	O
win	pointer
->	O
line_count	long
>	O
win	pointer
->	O
height	long
)	O
set_window_pagetop	function
(	O
win	pointer
,	O
win	pointer
->	O
line_count	long
-	O
win	pointer
->	O
height	long
)	O
;	O
window_compute_line_map	function
(	O
win	pointer
)	O
;	O
return	O
1	int
;	O
}	O
win	pointer
->	O
point	long
=	O
0	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
looking_at_newline	function
(	O
WINDOW	struct
*	O
win	pointer
,	O
long	O
point	long
)	O
{	O
mbi_iterator_t	struct
iter	pointer
;	O
mbi_init	O
(	O
iter	pointer
,	O
win	pointer
->	O
node	pointer
->	O
contents	pointer
+	O
point	long
,	O
win	pointer
->	O
node	pointer
->	O
nodelen	long
-	O
point	long
)	O
;	O
mbi_avail	O
(	O
iter	pointer
)	O
;	O
return	O
mbi_cur	O
(	O
iter	pointer
)	O
.	O
wc_valid	bool
&&	O
mbi_cur	O
(	O
iter	pointer
)	O
.	O
wc	int
==	O
'\n'	O
;	O
}	O
static	O
int	O
looking_at_alnum	function
(	O
WINDOW	struct
*	O
win	pointer
)	O
{	O
mbi_iterator_t	struct
iter	pointer
;	O
mbi_init	O
(	O
iter	pointer
,	O
win	pointer
->	O
node	pointer
->	O
contents	pointer
+	O
win	pointer
->	O
point	long
,	O
win	pointer
->	O
node	pointer
->	O
nodelen	long
-	O
win	pointer
->	O
point	long
)	O
;	O
mbi_avail	O
(	O
iter	pointer
)	O
;	O
return	O
mbi_cur	O
(	O
iter	pointer
)	O
.	O
wc_valid	bool
&&	O
iswalnum	function
(	O
mbi_cur	O
(	O
iter	pointer
)	O
.	O
wc	int
)	O
;	O
}	O
static	O
void	O
point_forward_char	function
(	O
WINDOW	struct
*	O
win	pointer
)	O
{	O
long	O
point	long
=	O
win	pointer
->	O
point	long
;	O
int	O
col	int
;	O
col	int
=	O
window_point_to_column	function
(	O
win	pointer
,	O
point	long
,	O
0	int
)	O
+	O
1	int
;	O
for	O
(	O
;	O
col	int
<	O
win	pointer
->	O
line_map	struct
.	O
used	long
&&	O
win	pointer
->	O
line_map	struct
.	O
map	pointer
[	O
col	int
]	O
==	O
point	long
;	O
col	int
++	O
)	O
;	O
if	O
(	O
col	int
<	O
win	pointer
->	O
line_map	struct
.	O
used	long
)	O
win	pointer
->	O
point	long
=	O
win	pointer
->	O
line_map	struct
.	O
map	pointer
[	O
col	int
]	O
;	O
else	O
point_next_line	function
(	O
win	pointer
)	O
;	O
}	O
static	O
int	O
point_backward_char	function
(	O
WINDOW	struct
*	O
win	pointer
)	O
{	O
long	O
point	long
=	O
win	pointer
->	O
point	long
;	O
int	O
col	int
;	O
col	int
=	O
window_point_to_column	function
(	O
win	pointer
,	O
point	long
,	O
0	int
)	O
-	O
1	int
;	O
for	O
(	O
;	O
col	int
>=	O
0	int
&&	O
win	pointer
->	O
line_map	struct
.	O
map	pointer
[	O
col	int
]	O
==	O
point	long
;	O
col	int
--	O
)	O
;	O
if	O
(	O
col	int
>=	O
0	int
)	O
{	O
win	pointer
->	O
point	long
=	O
win	pointer
->	O
line_map	struct
.	O
map	pointer
[	O
col	int
]	O
;	O
return	O
1	int
;	O
}	O
else	O
return	O
point_prev_line	function
(	O
win	pointer
)	O
;	O
}	O
static	O
void	O
point_forward_word	function
(	O
WINDOW	struct
*	O
win	pointer
)	O
{	O
int	O
col	int
;	O
col	int
=	O
window_point_to_column	function
(	O
win	pointer
,	O
win	pointer
->	O
point	long
,	O
&	O
win	pointer
->	O
point	long
)	O
;	O
while	O
(	O
1	int
)	O
{	O
for	O
(	O
;	O
col	int
<	O
win	pointer
->	O
line_map	struct
.	O
used	long
;	O
col	int
++	O
)	O
{	O
win	pointer
->	O
point	long
=	O
win	pointer
->	O
line_map	struct
.	O
map	pointer
[	O
col	int
]	O
;	O
if	O
(	O
looking_at_alnum	function
(	O
win	pointer
)	O
)	O
goto	O
skipped_whitespace	O
;	O
}	O
if	O
(	O
!	O
point_next_line	function
(	O
win	pointer
)	O
)	O
return	O
;	O
col	int
=	O
0	int
;	O
}	O
skipped_whitespace	O
:	O
while	O
(	O
1	int
)	O
{	O
for	O
(	O
;	O
col	int
<	O
win	pointer
->	O
line_map	struct
.	O
used	long
;	O
col	int
++	O
)	O
{	O
win	pointer
->	O
point	long
=	O
win	pointer
->	O
line_map	struct
.	O
map	pointer
[	O
col	int
]	O
;	O
if	O
(	O
!	O
looking_at_alnum	function
(	O
win	pointer
)	O
)	O
return	O
;	O
}	O
if	O
(	O
!	O
point_next_line	function
(	O
win	pointer
)	O
)	O
return	O
;	O
col	int
=	O
0	int
;	O
}	O
}	O
static	O
void	O
point_backward_word	function
(	O
WINDOW	struct
*	O
win	pointer
)	O
{	O
while	O
(	O
point_backward_char	function
(	O
win	pointer
)	O
)	O
{	O
if	O
(	O
looking_at_alnum	function
(	O
win	pointer
)	O
)	O
goto	O
back_to_word_start	O
;	O
}	O
back_to_word_start	O
:	O
while	O
(	O
point_backward_char	function
(	O
win	pointer
)	O
)	O
{	O
if	O
(	O
!	O
looking_at_alnum	function
(	O
win	pointer
)	O
)	O
{	O
point_forward_char	function
(	O
win	pointer
)	O
;	O
return	O
;	O
}	O
}	O
}	O
void	O
info_prev_line	function
(	O
WINDOW	struct
*	O
,	O
int	O
count	pointer
)	O
;	O
static	O
void	O
move_to_goal_column	function
(	O
WINDOW	struct
*	O
window	pointer
)	O
{	O
long	O
goal	long
;	O
goal	long
=	O
window	pointer
->	O
goal_column	long
;	O
if	O
(	O
goal	long
>=	O
window	pointer
->	O
line_map	struct
.	O
used	long
)	O
goal	long
=	O
window	pointer
->	O
line_map	struct
.	O
used	long
-	O
1	int
;	O
window	pointer
->	O
point	long
=	O
window	pointer
->	O
line_map	struct
.	O
map	pointer
[	O
goal	long
]	O
;	O
info_show_point	function
(	O
window	pointer
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_next_line	function
,	O
_	O
(	O
"Move down to the next line"	pointer
)	O
)	O
{	O
if	O
(	O
count	pointer
<	O
0	int
)	O
info_prev_line	function
(	O
window	pointer
,	O
-	O
count	pointer
)	O
;	O
else	O
{	O
if	O
(	O
window	pointer
->	O
goal_column	long
==	O
-	O
1	int
)	O
window	pointer
->	O
goal_column	long
=	O
window_get_cursor_column	function
(	O
window	pointer
)	O
;	O
while	O
(	O
count	pointer
--	O
)	O
point_next_line	function
(	O
window	pointer
)	O
;	O
move_to_goal_column	function
(	O
window	pointer
)	O
;	O
}	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_prev_line	function
,	O
_	O
(	O
"Move up to the previous line"	pointer
)	O
)	O
{	O
if	O
(	O
count	pointer
<	O
0	int
)	O
info_next_line	function
(	O
window	pointer
,	O
-	O
count	pointer
)	O
;	O
else	O
{	O
if	O
(	O
window	pointer
->	O
goal_column	long
==	O
-	O
1	int
)	O
window	pointer
->	O
goal_column	long
=	O
window_get_cursor_column	function
(	O
window	pointer
)	O
;	O
while	O
(	O
count	pointer
--	O
)	O
point_prev_line	function
(	O
window	pointer
)	O
;	O
move_to_goal_column	function
(	O
window	pointer
)	O
;	O
}	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_move_to_window_line	function
,	O
_	O
(	O
"Move the cursor to a specific line of the window"	pointer
)	O
)	O
{	O
int	O
line	pointer
;	O
if	O
(	O
!	O
info_explicit_arg	int
&&	O
count	pointer
==	O
1	int
)	O
line	pointer
=	O
(	O
window	pointer
->	O
height	long
/	O
2	int
)	O
+	O
window	pointer
->	O
pagetop	long
;	O
else	O
{	O
if	O
(	O
count	pointer
<	O
0	int
)	O
line	pointer
=	O
(	O
window	pointer
->	O
height	long
+	O
count	pointer
)	O
+	O
window	pointer
->	O
pagetop	long
;	O
else	O
line	pointer
=	O
window	pointer
->	O
pagetop	long
+	O
count	pointer
;	O
}	O
if	O
(	O
line	pointer
-	O
window	pointer
->	O
pagetop	long
>=	O
window	pointer
->	O
height	long
)	O
line	pointer
=	O
window	pointer
->	O
pagetop	long
+	O
(	O
window	pointer
->	O
height	long
-	O
1	int
)	O
;	O
if	O
(	O
line	pointer
<	O
window	pointer
->	O
pagetop	long
)	O
line	pointer
=	O
window	pointer
->	O
pagetop	long
;	O
if	O
(	O
line	pointer
>=	O
window	pointer
->	O
line_count	long
)	O
line	pointer
=	O
window	pointer
->	O
line_count	long
-	O
1	int
;	O
window	pointer
->	O
point	long
=	O
window	pointer
->	O
line_starts	pointer
[	O
line	pointer
]	O
;	O
info_show_point	function
(	O
window	pointer
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_end_of_line	function
,	O
_	O
(	O
"Move to the end of the line"	pointer
)	O
)	O
{	O
long	O
point	long
;	O
if	O
(	O
!	O
window	pointer
->	O
node	pointer
)	O
return	O
;	O
while	O
(	O
!	O
looking_at_newline	function
(	O
window	pointer
,	O
window	pointer
->	O
line_map	struct
.	O
map	pointer
[	O
window	pointer
->	O
line_map	struct
.	O
used	long
-	O
1	int
]	O
)	O
)	O
point_next_line	function
(	O
window	pointer
)	O
;	O
if	O
(	O
window	pointer
->	O
line_map	struct
.	O
used	long
==	O
0	int
)	O
return	O
;	O
point	long
=	O
window	pointer
->	O
line_map	struct
.	O
map	pointer
[	O
window	pointer
->	O
line_map	struct
.	O
used	long
-	O
1	int
]	O
;	O
if	O
(	O
point	long
!=	O
window	pointer
->	O
point	long
)	O
{	O
window	pointer
->	O
point	long
=	O
point	long
;	O
info_show_point	function
(	O
window	pointer
)	O
;	O
}	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_beginning_of_line	function
,	O
_	O
(	O
"Move to the start of the line"	pointer
)	O
)	O
{	O
int	O
old_point	int
=	O
window	pointer
->	O
point	long
;	O
int	O
point	long
;	O
while	O
(	O
1	int
)	O
{	O
point	long
=	O
window	pointer
->	O
line_map	struct
.	O
map	pointer
[	O
0	int
]	O
;	O
if	O
(	O
point	long
==	O
0	int
||	O
looking_at_newline	function
(	O
window	pointer
,	O
point	long
-	O
1	int
)	O
)	O
break	O
;	O
point_prev_line	function
(	O
window	pointer
)	O
;	O
}	O
if	O
(	O
point	long
!=	O
old_point	int
)	O
{	O
window	pointer
->	O
point	long
=	O
point	long
;	O
info_show_point	function
(	O
window	pointer
)	O
;	O
}	O
else	O
window	pointer
->	O
point	long
=	O
old_point	int
;	O
}	O
void	O
info_backward_char	function
(	O
WINDOW	struct
*	O
,	O
int	O
count	pointer
)	O
;	O
DECLARE_INFO_COMMAND	O
(	O
info_forward_char	function
,	O
_	O
(	O
"Move forward a character"	pointer
)	O
)	O
{	O
if	O
(	O
count	pointer
<	O
0	int
)	O
info_backward_char	function
(	O
window	pointer
,	O
-	O
count	pointer
)	O
;	O
else	O
{	O
while	O
(	O
count	pointer
--	O
)	O
point_forward_char	function
(	O
window	pointer
)	O
;	O
info_show_point	function
(	O
window	pointer
)	O
;	O
}	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_backward_char	function
,	O
_	O
(	O
"Move backward a character"	pointer
)	O
)	O
{	O
if	O
(	O
count	pointer
<	O
0	int
)	O
info_forward_char	function
(	O
window	pointer
,	O
-	O
count	pointer
)	O
;	O
else	O
{	O
while	O
(	O
count	pointer
--	O
)	O
point_backward_char	function
(	O
window	pointer
)	O
;	O
info_show_point	function
(	O
window	pointer
)	O
;	O
}	O
}	O
void	O
info_backward_word	function
(	O
WINDOW	struct
*	O
,	O
int	O
count	pointer
)	O
;	O
DECLARE_INFO_COMMAND	O
(	O
info_forward_word	function
,	O
_	O
(	O
"Move forward a word"	pointer
)	O
)	O
{	O
if	O
(	O
count	pointer
<	O
0	int
)	O
{	O
info_backward_word	function
(	O
window	pointer
,	O
-	O
count	pointer
)	O
;	O
return	O
;	O
}	O
while	O
(	O
count	pointer
--	O
)	O
point_forward_word	function
(	O
window	pointer
)	O
;	O
info_show_point	function
(	O
window	pointer
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_backward_word	function
,	O
_	O
(	O
"Move backward a word"	pointer
)	O
)	O
{	O
if	O
(	O
count	pointer
<	O
0	int
)	O
{	O
info_forward_word	function
(	O
window	pointer
,	O
-	O
count	pointer
)	O
;	O
return	O
;	O
}	O
while	O
(	O
count	pointer
--	O
)	O
point_backward_word	function
(	O
window	pointer
)	O
;	O
info_show_point	function
(	O
window	pointer
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_beginning_of_node	function
,	O
_	O
(	O
"Move to the start of this node"	pointer
)	O
)	O
{	O
window	pointer
->	O
point	long
=	O
0	int
;	O
info_show_point	function
(	O
window	pointer
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_end_of_node	function
,	O
_	O
(	O
"Move to the end of this node"	pointer
)	O
)	O
{	O
window	pointer
->	O
point	long
=	O
window	pointer
->	O
node	pointer
->	O
nodelen	long
-	O
1	int
;	O
info_show_point	function
(	O
window	pointer
)	O
;	O
}	O
int	O
info_scroll_behaviour	int
=	O
IS_Continuous	int
;	O
static	O
void	O
_scroll_forward	function
(	O
WINDOW	struct
*	O
window	pointer
,	O
int	O
count	pointer
,	O
int	O
nodeonly	int
)	O
;	O
static	O
void	O
_scroll_backward	function
(	O
WINDOW	struct
*	O
window	pointer
,	O
int	O
count	pointer
,	O
int	O
nodeonly	int
)	O
;	O
static	O
void	O
_scroll_forward	function
(	O
WINDOW	struct
*	O
window	pointer
,	O
int	O
count	pointer
,	O
int	O
nodeonly	int
)	O
{	O
if	O
(	O
count	pointer
<	O
0	int
)	O
_scroll_backward	function
(	O
window	pointer
,	O
-	O
count	pointer
,	O
nodeonly	int
)	O
;	O
else	O
{	O
if	O
(	O
window	pointer
->	O
pagetop	long
>=	O
window	pointer
->	O
line_count	long
-	O
window	pointer
->	O
height	long
)	O
{	O
if	O
(	O
!	O
nodeonly	int
)	O
{	O
if	O
(	O
forward_move_node_structure	function
(	O
window	pointer
,	O
info_scroll_behaviour	int
)	O
==	O
0	int
)	O
window	pointer
->	O
point	long
=	O
0	int
;	O
else	O
info_end_of_node	function
(	O
window	pointer
,	O
1	int
)	O
;	O
}	O
return	O
;	O
}	O
set_window_pagetop	function
(	O
window	pointer
,	O
window	pointer
->	O
pagetop	long
+	O
count	pointer
)	O
;	O
}	O
}	O
static	O
void	O
_scroll_backward	function
(	O
WINDOW	struct
*	O
window	pointer
,	O
int	O
count	pointer
,	O
int	O
nodeonly	int
)	O
{	O
if	O
(	O
count	pointer
<	O
0	int
)	O
_scroll_backward	function
(	O
window	pointer
,	O
-	O
count	pointer
,	O
nodeonly	int
)	O
;	O
else	O
{	O
int	O
desired_top	int
;	O
if	O
(	O
window	pointer
->	O
pagetop	long
<=	O
0	int
)	O
{	O
if	O
(	O
!	O
nodeonly	int
)	O
{	O
if	O
(	O
backward_move_node_structure	function
(	O
window	pointer
,	O
info_scroll_behaviour	int
)	O
==	O
0	int
)	O
{	O
info_end_of_node	function
(	O
window	pointer
,	O
1	int
)	O
;	O
window	pointer
->	O
point	long
=	O
window	pointer
->	O
line_starts	pointer
[	O
window	pointer
->	O
pagetop	long
]	O
;	O
}	O
else	O
window	pointer
->	O
point	long
=	O
0	int
;	O
}	O
return	O
;	O
}	O
desired_top	int
=	O
window	pointer
->	O
pagetop	long
-	O
count	pointer
;	O
if	O
(	O
desired_top	int
<	O
0	int
)	O
desired_top	int
=	O
0	int
;	O
set_window_pagetop	function
(	O
window	pointer
,	O
desired_top	int
)	O
;	O
}	O
}	O
int	O
default_window_size	int
=	O
-	O
1	int
;	O
DECLARE_INFO_COMMAND	O
(	O
info_scroll_forward	function
,	O
_	O
(	O
"Scroll forward in this window"	pointer
)	O
)	O
{	O
int	O
lines	int
;	O
if	O
(	O
info_explicit_arg	int
)	O
lines	int
=	O
count	pointer
;	O
else	O
if	O
(	O
default_window_size	int
>	O
0	int
)	O
lines	int
=	O
default_window_size	int
*	O
count	pointer
;	O
else	O
lines	int
=	O
(	O
window	pointer
->	O
height	long
-	O
2	int
)	O
*	O
count	pointer
;	O
_scroll_forward	function
(	O
window	pointer
,	O
lines	int
,	O
0	int
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_scroll_backward	function
,	O
_	O
(	O
"Scroll backward in this window"	pointer
)	O
)	O
{	O
info_scroll_forward	function
(	O
window	pointer
,	O
-	O
count	pointer
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_scroll_forward_set_window	function
,	O
_	O
(	O
"Scroll forward in this window and set default window size"	pointer
)	O
)	O
{	O
if	O
(	O
info_explicit_arg	int
)	O
{	O
default_window_size	int
=	O
count	pointer
;	O
if	O
(	O
default_window_size	int
<	O
0	int
)	O
default_window_size	int
*=	O
-	O
1	int
;	O
}	O
info_scroll_forward	function
(	O
window	pointer
,	O
count	pointer
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_scroll_backward_set_window	function
,	O
_	O
(	O
"Scroll backward in this window and set default window size"	pointer
)	O
)	O
{	O
info_scroll_forward_set_window	function
(	O
window	pointer
,	O
-	O
count	pointer
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_scroll_forward_page_only	function
,	O
_	O
(	O
"Scroll forward in this window staying within node"	pointer
)	O
)	O
{	O
int	O
lines	int
;	O
if	O
(	O
info_explicit_arg	int
)	O
lines	int
=	O
count	pointer
;	O
else	O
if	O
(	O
default_window_size	int
>	O
0	int
)	O
lines	int
=	O
default_window_size	int
*	O
count	pointer
;	O
else	O
lines	int
=	O
(	O
window	pointer
->	O
height	long
-	O
2	int
)	O
*	O
count	pointer
;	O
_scroll_forward	function
(	O
window	pointer
,	O
lines	int
,	O
1	int
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_scroll_backward_page_only	function
,	O
_	O
(	O
"Scroll backward in this window staying within node"	pointer
)	O
)	O
{	O
info_scroll_forward_page_only	function
(	O
window	pointer
,	O
-	O
count	pointer
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_scroll_forward_page_only_set_window	function
,	O
_	O
(	O
"Scroll forward in this window staying within node and set default window size"	pointer
)	O
)	O
{	O
int	O
lines	int
;	O
if	O
(	O
info_explicit_arg	int
)	O
{	O
default_window_size	int
=	O
count	pointer
;	O
count	pointer
=	O
1	int
;	O
if	O
(	O
default_window_size	int
<	O
0	int
)	O
{	O
default_window_size	int
*=	O
-	O
1	int
;	O
count	pointer
=	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
default_window_size	int
>	O
0	int
)	O
lines	int
=	O
default_window_size	int
*	O
count	pointer
;	O
else	O
lines	int
=	O
(	O
window	pointer
->	O
height	long
-	O
2	int
)	O
*	O
count	pointer
;	O
_scroll_forward	function
(	O
window	pointer
,	O
lines	int
,	O
1	int
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_scroll_backward_page_only_set_window	function
,	O
_	O
(	O
"Scroll backward in this window staying within node and set default window size"	pointer
)	O
)	O
{	O
info_scroll_forward_page_only_set_window	function
(	O
window	pointer
,	O
-	O
count	pointer
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_down_line	function
,	O
_	O
(	O
"Scroll down by lines"	pointer
)	O
)	O
{	O
_scroll_forward	function
(	O
window	pointer
,	O
count	pointer
,	O
0	int
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_up_line	function
,	O
_	O
(	O
"Scroll up by lines"	pointer
)	O
)	O
{	O
_scroll_backward	function
(	O
window	pointer
,	O
count	pointer
,	O
0	int
)	O
;	O
}	O
int	O
default_scroll_size	int
=	O
0	int
;	O
DECLARE_INFO_COMMAND	O
(	O
info_scroll_half_screen_down	function
,	O
_	O
(	O
"Scroll down by half screen size"	pointer
)	O
)	O
{	O
int	O
lines	int
;	O
if	O
(	O
info_explicit_arg	int
)	O
{	O
default_scroll_size	int
=	O
count	pointer
;	O
count	pointer
=	O
1	int
;	O
if	O
(	O
default_scroll_size	int
<	O
0	int
)	O
{	O
default_scroll_size	int
*=	O
-	O
1	int
;	O
count	pointer
=	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
default_scroll_size	int
!=	O
0	int
)	O
lines	int
=	O
default_scroll_size	int
*	O
count	pointer
;	O
else	O
lines	int
=	O
(	O
window	pointer
->	O
height	long
+	O
1	int
)	O
/	O
2	int
*	O
count	pointer
;	O
_scroll_forward	function
(	O
window	pointer
,	O
lines	int
,	O
1	int
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_scroll_half_screen_up	function
,	O
_	O
(	O
"Scroll up by half screen size"	pointer
)	O
)	O
{	O
info_scroll_half_screen_down	function
(	O
window	pointer
,	O
-	O
count	pointer
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_scroll_other_window	function
,	O
_	O
(	O
"Scroll the other window"	pointer
)	O
)	O
{	O
WINDOW	struct
*	O
other	pointer
;	O
if	O
(	O
!	O
windows	pointer
->	O
next	pointer
)	O
{	O
info_error	function
(	O
"%s"	pointer
,	O
msg_one_window	pointer
)	O
;	O
return	O
;	O
}	O
other	pointer
=	O
window	pointer
->	O
next	pointer
;	O
if	O
(	O
!	O
other	pointer
)	O
other	pointer
=	O
window	pointer
->	O
prev	pointer
;	O
info_scroll_forward	function
(	O
other	pointer
,	O
count	pointer
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_scroll_other_window_backward	function
,	O
_	O
(	O
"Scroll the other window backward"	pointer
)	O
)	O
{	O
info_scroll_other_window	function
(	O
window	pointer
,	O
-	O
count	pointer
)	O
;	O
}	O
static	O
void	O
gc_file_buffers_and_nodes	function
(	O
void	O
)	O
{	O
int	O
*	O
fb_referenced	pointer
=	O
xcalloc	function
(	O
info_loaded_files_index	long
,	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
WINDOW	struct
*	O
win	pointer
;	O
int	O
i	int
;	O
int	O
fb_index	int
;	O
for	O
(	O
win	pointer
=	O
windows	pointer
;	O
win	pointer
;	O
win	pointer
=	O
win	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
!	O
win	pointer
->	O
hist	pointer
)	O
continue	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
win	pointer
->	O
hist	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
NODE	struct
*	O
n	long
=	O
win	pointer
->	O
hist	pointer
[	O
i	int
]	O
->	O
node	pointer
;	O
for	O
(	O
fb_index	int
=	O
0	int
;	O
fb_index	int
<	O
info_loaded_files_index	long
;	O
fb_index	int
++	O
)	O
{	O
FILE_BUFFER	struct
*	O
fb	pointer
=	O
info_loaded_files	pointer
[	O
fb_index	int
]	O
;	O
if	O
(	O
fb	pointer
->	O
flags	int
&	O
N_Subfile	int
)	O
{	O
if	O
(	O
n	long
->	O
subfile	pointer
&&	O
!	O
FILENAME_CMP	O
(	O
fb	pointer
->	O
fullpath	pointer
,	O
n	long
->	O
subfile	pointer
)	O
)	O
{	O
fb_referenced	pointer
[	O
fb_index	int
]	O
=	O
1	int
;	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
(	O
fb	pointer
->	O
flags	int
&	O
N_TagsIndirect	int
)	O
)	O
{	O
if	O
(	O
n	long
->	O
fullpath	pointer
&&	O
!	O
FILENAME_CMP	O
(	O
fb	pointer
->	O
fullpath	pointer
,	O
n	long
->	O
fullpath	pointer
)	O
)	O
{	O
fb_referenced	pointer
[	O
fb_index	int
]	O
=	O
1	int
;	O
break	O
;	O
}	O
}	O
}	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
info_loaded_files_index	long
;	O
i	int
++	O
)	O
{	O
if	O
(	O
!	O
fb_referenced	pointer
[	O
i	int
]	O
)	O
{	O
FILE_BUFFER	struct
*	O
fb	pointer
=	O
info_loaded_files	pointer
[	O
i	int
]	O
;	O
TAG	struct
*	O
*	O
t	pointer
;	O
if	O
(	O
fb	pointer
->	O
flags	int
&	O
N_TagsIndirect	int
)	O
continue	O
;	O
if	O
(	O
!	O
fb	pointer
->	O
contents	pointer
)	O
continue	O
;	O
if	O
(	O
(	O
fb	pointer
->	O
flags	int
&	O
N_IsCompressed	int
)	O
&&	O
!	O
gc_compressed_files	int
)	O
continue	O
;	O
if	O
(	O
fb	pointer
->	O
flags	int
&	O
N_CannotGC	int
)	O
continue	O
;	O
if	O
(	O
fb	pointer
->	O
flags	int
&	O
N_Gone	int
)	O
continue	O
;	O
free	function
(	O
fb	pointer
->	O
contents	pointer
)	O
;	O
fb	pointer
->	O
contents	pointer
=	O
0	int
;	O
if	O
(	O
fb	pointer
->	O
tags	pointer
)	O
for	O
(	O
t	pointer
=	O
fb	pointer
->	O
tags	pointer
;	O
(	O
*	O
t	pointer
)	O
;	O
t	pointer
++	O
)	O
{	O
if	O
(	O
!	O
(	O
(	O
*	O
t	pointer
)	O
->	O
cache	struct
.	O
flags	int
&	O
N_WasRewritten	int
)	O
)	O
(	O
*	O
t	pointer
)	O
->	O
cache	struct
.	O
contents	pointer
=	O
0	int
;	O
}	O
}	O
}	O
free	function
(	O
fb_referenced	pointer
)	O
;	O
}	O
void	O
info_prev_window	function
(	O
WINDOW	struct
*	O
,	O
int	O
count	pointer
)	O
;	O
DECLARE_INFO_COMMAND	O
(	O
info_next_window	function
,	O
_	O
(	O
"Select the next window"	pointer
)	O
)	O
{	O
if	O
(	O
count	pointer
<	O
0	int
)	O
{	O
info_prev_window	function
(	O
window	pointer
,	O
-	O
count	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
windows	pointer
->	O
next	pointer
||	O
echo_area_is_active	int
)	O
{	O
info_error	function
(	O
"%s"	pointer
,	O
msg_one_window	pointer
)	O
;	O
return	O
;	O
}	O
while	O
(	O
count	pointer
--	O
)	O
{	O
if	O
(	O
window	pointer
->	O
next	pointer
)	O
window	pointer
=	O
window	pointer
->	O
next	pointer
;	O
else	O
window	pointer
=	O
windows	pointer
;	O
}	O
if	O
(	O
active_window	pointer
!=	O
window	pointer
)	O
{	O
if	O
(	O
auto_footnotes_p	int
)	O
info_get_or_remove_footnotes	function
(	O
window	pointer
)	O
;	O
window_adjust_pagetop	function
(	O
window	pointer
)	O
;	O
window	pointer
->	O
flags	int
|=	O
W_UpdateWindow	int
;	O
active_window	pointer
=	O
window	pointer
;	O
}	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_prev_window	function
,	O
_	O
(	O
"Select the previous window"	pointer
)	O
)	O
{	O
if	O
(	O
count	pointer
<	O
0	int
)	O
{	O
info_next_window	function
(	O
window	pointer
,	O
-	O
count	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
windows	pointer
->	O
next	pointer
||	O
echo_area_is_active	int
)	O
{	O
info_error	function
(	O
"%s"	pointer
,	O
msg_one_window	pointer
)	O
;	O
return	O
;	O
}	O
while	O
(	O
count	pointer
--	O
)	O
{	O
if	O
(	O
window	pointer
!=	O
windows	pointer
&&	O
window	pointer
->	O
prev	pointer
)	O
window	pointer
=	O
window	pointer
->	O
prev	pointer
;	O
else	O
if	O
(	O
window	pointer
==	O
windows	pointer
)	O
{	O
while	O
(	O
window	pointer
->	O
next	pointer
)	O
window	pointer
=	O
window	pointer
->	O
next	pointer
;	O
}	O
}	O
if	O
(	O
active_window	pointer
!=	O
window	pointer
)	O
{	O
if	O
(	O
auto_footnotes_p	int
)	O
info_get_or_remove_footnotes	function
(	O
window	pointer
)	O
;	O
window_adjust_pagetop	function
(	O
window	pointer
)	O
;	O
window	pointer
->	O
flags	int
|=	O
W_UpdateWindow	int
;	O
active_window	pointer
=	O
window	pointer
;	O
}	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_split_window	function
,	O
_	O
(	O
"Split the current window"	pointer
)	O
)	O
{	O
WINDOW	struct
*	O
split	pointer
=	O
window_make_window	function
(	O
)	O
;	O
if	O
(	O
!	O
split	pointer
)	O
info_error	function
(	O
"%s"	pointer
,	O
msg_win_too_small	pointer
)	O
;	O
else	O
{	O
NODE	struct
*	O
copy	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
NODE	struct
)	O
)	O
;	O
*	O
copy	pointer
=	O
*	O
window	pointer
->	O
node	pointer
;	O
if	O
(	O
copy	pointer
->	O
flags	int
&	O
N_IsInternal	int
)	O
{	O
copy	pointer
->	O
references	pointer
=	O
info_copy_references	function
(	O
copy	pointer
->	O
references	pointer
)	O
;	O
copy	pointer
->	O
nodename	pointer
=	O
xstrdup	function
(	O
copy	pointer
->	O
nodename	pointer
)	O
;	O
if	O
(	O
copy	pointer
->	O
up	pointer
)	O
copy	pointer
->	O
up	pointer
=	O
xstrdup	function
(	O
copy	pointer
->	O
up	pointer
)	O
;	O
if	O
(	O
copy	pointer
->	O
next	pointer
)	O
copy	pointer
->	O
next	pointer
=	O
xstrdup	function
(	O
copy	pointer
->	O
next	pointer
)	O
;	O
if	O
(	O
copy	pointer
->	O
prev	pointer
)	O
copy	pointer
->	O
prev	pointer
=	O
xstrdup	function
(	O
copy	pointer
->	O
prev	pointer
)	O
;	O
copy	pointer
->	O
contents	pointer
=	O
xstrdup	function
(	O
copy	pointer
->	O
contents	pointer
)	O
;	O
}	O
info_set_node_of_window	function
(	O
split	pointer
,	O
copy	pointer
)	O
;	O
info_show_point	function
(	O
window	pointer
)	O
;	O
split	pointer
->	O
pagetop	long
=	O
window	pointer
->	O
pagetop	long
;	O
if	O
(	O
auto_tiling_p	int
)	O
window_tile_windows	function
(	O
DONT_TILE_INTERNALS	int
)	O
;	O
else	O
window_adjust_pagetop	function
(	O
split	pointer
)	O
;	O
}	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_delete_window	function
,	O
_	O
(	O
"Delete the current window"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
windows	pointer
->	O
next	pointer
)	O
info_error	function
(	O
"%s"	pointer
,	O
msg_cant_kill_last	pointer
)	O
;	O
else	O
if	O
(	O
window	pointer
->	O
flags	int
&	O
W_WindowIsPerm	int
)	O
info_error	function
(	O
"%s"	pointer
,	O
_	O
(	O
"Cannot delete a permanent window"	pointer
)	O
)	O
;	O
else	O
{	O
info_delete_window_internal	function
(	O
window	pointer
)	O
;	O
if	O
(	O
auto_footnotes_p	int
)	O
info_get_or_remove_footnotes	function
(	O
active_window	pointer
)	O
;	O
if	O
(	O
auto_tiling_p	int
)	O
window_tile_windows	function
(	O
DONT_TILE_INTERNALS	int
)	O
;	O
gc_file_buffers_and_nodes	function
(	O
)	O
;	O
}	O
}	O
void	O
info_delete_window_internal	function
(	O
WINDOW	struct
*	O
window	pointer
)	O
{	O
if	O
(	O
windows	pointer
->	O
next	pointer
&&	O
(	O
(	O
window	pointer
->	O
flags	int
&	O
W_WindowIsPerm	int
)	O
==	O
0	int
)	O
)	O
{	O
forget_window_and_nodes	function
(	O
window	pointer
)	O
;	O
window_delete_window	function
(	O
window	pointer
)	O
;	O
if	O
(	O
echo_area_is_active	int
)	O
echo_area_inform_of_deleted_window	function
(	O
window	pointer
)	O
;	O
}	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_keep_one_window	function
,	O
_	O
(	O
"Delete all other windows"	pointer
)	O
)	O
{	O
int	O
num_deleted	int
;	O
int	O
pagetop	long
,	O
start	int
,	O
end	int
;	O
pagetop	long
=	O
window	pointer
->	O
pagetop	long
;	O
start	int
=	O
window	pointer
->	O
first_row	long
;	O
end	int
=	O
start	int
+	O
window	pointer
->	O
height	long
;	O
num_deleted	int
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
WINDOW	struct
*	O
win	pointer
;	O
for	O
(	O
win	pointer
=	O
windows	pointer
;	O
win	pointer
;	O
win	pointer
=	O
win	pointer
->	O
next	pointer
)	O
if	O
(	O
win	pointer
!=	O
window	pointer
&&	O
(	O
(	O
win	pointer
->	O
flags	int
&	O
W_WindowIsPerm	int
)	O
==	O
0	int
)	O
)	O
break	O
;	O
if	O
(	O
!	O
win	pointer
)	O
break	O
;	O
info_delete_window_internal	function
(	O
win	pointer
)	O
;	O
num_deleted	int
++	O
;	O
}	O
if	O
(	O
num_deleted	int
)	O
{	O
int	O
amount	int
;	O
amount	int
=	O
(	O
window	pointer
->	O
first_row	long
-	O
start	int
)	O
;	O
amount	int
-=	O
(	O
window	pointer
->	O
pagetop	long
-	O
pagetop	long
)	O
;	O
display_scroll_display	function
(	O
start	int
,	O
end	int
,	O
amount	int
)	O
;	O
}	O
window	pointer
->	O
flags	int
|=	O
W_UpdateWindow	int
;	O
gc_file_buffers_and_nodes	function
(	O
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_grow_window	function
,	O
_	O
(	O
"Grow (or shrink) this window"	pointer
)	O
)	O
{	O
window_change_window_height	function
(	O
window	pointer
,	O
count	pointer
)	O
;	O
}	O
int	O
auto_tiling_p	int
=	O
0	int
;	O
DECLARE_INFO_COMMAND	O
(	O
info_tile_windows	function
,	O
_	O
(	O
"Divide the available screen space among the visible windows"	pointer
)	O
)	O
{	O
window_tile_windows	function
(	O
TILE_INTERNALS	int
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_toggle_wrap	function
,	O
_	O
(	O
"Toggle the state of line wrapping in the current window"	pointer
)	O
)	O
{	O
window_toggle_wrap	function
(	O
window	pointer
)	O
;	O
}	O
int	O
info_select_reference	function
(	O
WINDOW	struct
*	O
window	pointer
,	O
REFERENCE	struct
*	O
entry	pointer
)	O
{	O
NODE	struct
*	O
node	pointer
;	O
char	O
*	O
file_system_error	pointer
=	O
NULL	O
;	O
char	O
*	O
filename	pointer
=	O
entry	pointer
->	O
filename	pointer
;	O
char	O
*	O
nodename	pointer
=	O
entry	pointer
->	O
nodename	pointer
;	O
char	O
*	O
label	pointer
=	O
entry	pointer
->	O
label	pointer
;	O
int	O
line_number	long
=	O
entry	pointer
->	O
line_number	long
;	O
node	pointer
=	O
info_get_node_with_defaults	function
(	O
filename	pointer
,	O
nodename	pointer
,	O
window	pointer
->	O
node	pointer
)	O
;	O
if	O
(	O
!	O
node	pointer
)	O
{	O
if	O
(	O
info_recent_file_error	pointer
)	O
file_system_error	pointer
=	O
xstrdup	function
(	O
info_recent_file_error	pointer
)	O
;	O
if	O
(	O
nodename	pointer
&&	O
label	pointer
&&	O
!	O
strcmp	function
(	O
nodename	pointer
,	O
label	pointer
)	O
)	O
{	O
free	function
(	O
file_system_error	pointer
)	O
;	O
file_system_error	pointer
=	O
NULL	O
;	O
node	pointer
=	O
info_get_node	function
(	O
label	pointer
,	O
"Top"	pointer
)	O
;	O
if	O
(	O
!	O
node	pointer
&&	O
info_recent_file_error	pointer
)	O
file_system_error	pointer
=	O
xstrdup	function
(	O
info_recent_file_error	pointer
)	O
;	O
}	O
}	O
if	O
(	O
!	O
node	pointer
)	O
{	O
if	O
(	O
file_system_error	pointer
)	O
{	O
info_error	function
(	O
"%s"	pointer
,	O
file_system_error	pointer
)	O
;	O
free	function
(	O
file_system_error	pointer
)	O
;	O
}	O
else	O
info_error	function
(	O
msg_cant_find_node	pointer
,	O
nodename	pointer
?	O
nodename	pointer
:	O
"Top"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
window	pointer
->	O
node	pointer
&&	O
(	O
window	pointer
->	O
node	pointer
->	O
flags	int
&	O
N_IsInternal	int
)	O
&&	O
!	O
strcmp	function
(	O
window	pointer
->	O
node	pointer
->	O
nodename	pointer
,	O
"*Footnotes*"	pointer
)	O
)	O
{	O
WINDOW	struct
*	O
w	int
;	O
for	O
(	O
w	int
=	O
windows	pointer
;	O
w	int
;	O
w	int
=	O
windows	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
w	int
->	O
node	pointer
->	O
fullpath	pointer
,	O
window	pointer
->	O
node	pointer
->	O
fullpath	pointer
)	O
&&	O
!	O
(	O
w	int
->	O
flags	int
&	O
W_TempWindow	int
)	O
)	O
{	O
active_window	pointer
=	O
window	pointer
=	O
w	int
;	O
break	O
;	O
}	O
}	O
}	O
info_set_node_of_window	function
(	O
window	pointer
,	O
node	pointer
)	O
;	O
if	O
(	O
line_number	long
>	O
0	int
)	O
{	O
long	O
line	pointer
=	O
window_log_to_phys_line	function
(	O
window	pointer
,	O
line_number	long
-	O
1	int
)	O
;	O
if	O
(	O
line	pointer
>=	O
0	int
&&	O
line	pointer
<	O
window	pointer
->	O
line_count	long
)	O
{	O
window	pointer
->	O
point	long
=	O
window	pointer
->	O
line_starts	pointer
[	O
line	pointer
]	O
;	O
window_adjust_pagetop	function
(	O
window	pointer
)	O
;	O
}	O
}	O
return	O
1	int
;	O
}	O
static	O
void	O
info_parse_and_select	function
(	O
char	O
*	O
line	pointer
,	O
WINDOW	struct
*	O
window	pointer
)	O
{	O
REFERENCE	struct
entry	pointer
;	O
info_parse_node	function
(	O
line	pointer
)	O
;	O
entry	pointer
.	O
filename	pointer
=	O
info_parsed_filename	pointer
;	O
entry	pointer
.	O
nodename	pointer
=	O
info_parsed_nodename	pointer
;	O
entry	pointer
.	O
line_number	long
=	O
0	int
;	O
entry	pointer
.	O
label	pointer
=	O
"*info-parse-and-select*"	pointer
;	O
info_select_reference	function
(	O
window	pointer
,	O
&	O
entry	pointer
)	O
;	O
}	O
static	O
REFERENCE	struct
*	O
select_menu_digit	function
(	O
WINDOW	struct
*	O
window	pointer
,	O
unsigned	O
char	O
key	int
)	O
{	O
register	O
int	O
i	int
,	O
item	int
;	O
register	O
REFERENCE	struct
*	O
*	O
menu	int
;	O
menu	int
=	O
window	pointer
->	O
node	pointer
->	O
references	pointer
;	O
if	O
(	O
!	O
menu	int
)	O
return	O
0	int
;	O
item	int
=	O
key	int
-	O
'0'	O
;	O
if	O
(	O
item	int
==	O
0	int
)	O
{	O
int	O
j	int
;	O
i	int
=	O
-	O
1	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
menu	int
[	O
j	int
]	O
;	O
j	int
++	O
)	O
if	O
(	O
menu	int
[	O
j	int
]	O
->	O
type	enum
==	O
REFERENCE_MENU_ITEM	int
)	O
i	int
=	O
j	int
;	O
}	O
else	O
{	O
int	O
k	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
menu	int
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
menu	int
[	O
i	int
]	O
->	O
type	enum
==	O
REFERENCE_MENU_ITEM	int
)	O
k	int
++	O
;	O
if	O
(	O
k	int
==	O
item	int
)	O
break	O
;	O
}	O
}	O
if	O
(	O
i	int
==	O
-	O
1	int
)	O
return	O
0	int
;	O
return	O
menu	int
[	O
i	int
]	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_menu_digit	function
,	O
_	O
(	O
"Select this menu item"	pointer
)	O
)	O
{	O
}	O
void	O
menu_digit	function
(	O
WINDOW	struct
*	O
window	pointer
,	O
int	O
key	int
)	O
{	O
int	O
item	int
=	O
key	int
-	O
'0'	O
;	O
REFERENCE	struct
*	O
entry	pointer
;	O
REFERENCE	struct
*	O
*	O
references	pointer
=	O
window	pointer
->	O
node	pointer
->	O
references	pointer
;	O
if	O
(	O
references	pointer
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
references	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
if	O
(	O
references	pointer
[	O
i	int
]	O
->	O
type	enum
==	O
REFERENCE_MENU_ITEM	int
)	O
goto	O
has_menu	O
;	O
}	O
info_error	function
(	O
"%s"	pointer
,	O
msg_no_menu_node	pointer
)	O
;	O
return	O
;	O
has_menu	O
:	O
if	O
(	O
entry	pointer
=	O
select_menu_digit	function
(	O
window	pointer
,	O
key	int
)	O
)	O
info_select_reference	function
(	O
window	pointer
,	O
entry	pointer
)	O
;	O
else	O
if	O
(	O
key	int
==	O
'0'	O
)	O
info_error	function
(	O
"%s"	pointer
,	O
msg_no_menu_node	pointer
)	O
;	O
else	O
info_error	function
(	O
ngettext	function
(	O
"There isn't %d item in this menu"	pointer
,	O
"There aren't %d items in this menu"	pointer
,	O
item	int
)	O
,	O
item	int
)	O
;	O
return	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_last_menu_item	function
,	O
_	O
(	O
"Select the last item in this node's menu"	pointer
)	O
)	O
{	O
menu_digit	function
(	O
window	pointer
,	O
'0'	O
)	O
;	O
}	O
static	O
int	O
exclude_cross_references	function
(	O
REFERENCE	struct
*	O
r	pointer
)	O
{	O
return	O
r	pointer
->	O
type	enum
==	O
REFERENCE_XREF	int
;	O
}	O
static	O
int	O
exclude_menu_items	function
(	O
REFERENCE	struct
*	O
r	pointer
)	O
{	O
return	O
r	pointer
->	O
type	enum
==	O
REFERENCE_MENU_ITEM	int
;	O
}	O
static	O
int	O
exclude_nothing	function
(	O
REFERENCE	struct
*	O
r	pointer
)	O
{	O
return	O
1	int
;	O
}	O
static	O
void	O
info_menu_or_ref_item	function
(	O
WINDOW	struct
*	O
window	pointer
,	O
int	O
menu_item	int
,	O
int	O
xref	int
,	O
int	O
ask_p	int
)	O
{	O
REFERENCE	struct
*	O
defentry	pointer
=	O
NULL	O
;	O
REFERENCE	struct
*	O
*	O
refs	pointer
=	O
window	pointer
->	O
node	pointer
->	O
references	pointer
;	O
REFERENCE	struct
*	O
entry	pointer
;	O
char	O
*	O
line	pointer
;	O
int	O
line_no	int
;	O
int	O
this_line	int
,	O
next_line	int
;	O
int	O
which	int
,	O
closest	int
=	O
-	O
1	int
;	O
reference_bool_fn	pointer
exclude	pointer
;	O
if	O
(	O
!	O
refs	pointer
)	O
return	O
;	O
if	O
(	O
menu_item	int
&&	O
!	O
xref	int
)	O
{	O
exclude	pointer
=	O
&	O
exclude_cross_references	function
;	O
}	O
else	O
if	O
(	O
!	O
menu_item	int
&&	O
xref	int
)	O
{	O
exclude	pointer
=	O
&	O
exclude_menu_items	function
;	O
}	O
else	O
if	O
(	O
menu_item	int
&&	O
xref	int
)	O
{	O
exclude	pointer
=	O
&	O
exclude_nothing	function
;	O
}	O
else	O
return	O
;	O
line_no	int
=	O
window_line_of_point	function
(	O
window	pointer
)	O
;	O
this_line	int
=	O
window	pointer
->	O
line_starts	pointer
[	O
line_no	int
]	O
;	O
if	O
(	O
window	pointer
->	O
line_starts	pointer
[	O
line_no	int
+	O
1	int
]	O
)	O
next_line	int
=	O
window	pointer
->	O
line_starts	pointer
[	O
line_no	int
+	O
1	int
]	O
;	O
else	O
next_line	int
=	O
window	pointer
->	O
node	pointer
->	O
nodelen	long
;	O
for	O
(	O
which	int
=	O
0	int
;	O
refs	pointer
[	O
which	int
]	O
;	O
which	int
++	O
)	O
{	O
if	O
(	O
refs	pointer
[	O
which	int
]	O
->	O
start	int
>=	O
next_line	int
)	O
break	O
;	O
if	O
(	O
!	O
(	O
(	O
menu_item	int
&&	O
refs	pointer
[	O
which	int
]	O
->	O
type	enum
==	O
REFERENCE_MENU_ITEM	int
)	O
||	O
(	O
xref	int
&&	O
refs	pointer
[	O
which	int
]	O
->	O
type	enum
==	O
REFERENCE_XREF	int
)	O
)	O
)	O
continue	O
;	O
if	O
(	O
refs	pointer
[	O
which	int
]	O
->	O
start	int
>=	O
this_line	int
&&	O
refs	pointer
[	O
which	int
]	O
->	O
start	int
<	O
next_line	int
||	O
refs	pointer
[	O
which	int
]	O
->	O
start	int
<	O
this_line	int
&&	O
refs	pointer
[	O
which	int
]	O
->	O
end	int
>	O
this_line	int
)	O
{	O
closest	int
=	O
which	int
;	O
if	O
(	O
refs	pointer
[	O
which	int
]	O
->	O
end	int
>	O
window	pointer
->	O
point	long
)	O
break	O
;	O
}	O
}	O
if	O
(	O
closest	int
!=	O
-	O
1	int
)	O
defentry	pointer
=	O
refs	pointer
[	O
closest	int
]	O
;	O
if	O
(	O
ask_p	int
)	O
{	O
char	O
*	O
prompt	pointer
;	O
if	O
(	O
menu_item	int
&&	O
!	O
xref	int
)	O
{	O
if	O
(	O
defentry	pointer
)	O
{	O
prompt	pointer
=	O
xmalloc	function
(	O
strlen	function
(	O
defentry	pointer
->	O
label	pointer
)	O
+	O
strlen	function
(	O
_	O
(	O
"Menu item (%s): "	pointer
)	O
)	O
)	O
;	O
sprintf	function
(	O
prompt	pointer
,	O
_	O
(	O
"Menu item (%s): "	pointer
)	O
,	O
defentry	pointer
->	O
label	pointer
)	O
;	O
}	O
else	O
prompt	pointer
=	O
xstrdup	function
(	O
_	O
(	O
"Menu item: "	pointer
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
defentry	pointer
)	O
{	O
prompt	pointer
=	O
xmalloc	function
(	O
strlen	function
(	O
defentry	pointer
->	O
label	pointer
)	O
+	O
strlen	function
(	O
_	O
(	O
"Follow xref (%s): "	pointer
)	O
)	O
)	O
;	O
sprintf	function
(	O
prompt	pointer
,	O
_	O
(	O
"Follow xref (%s): "	pointer
)	O
,	O
defentry	pointer
->	O
label	pointer
)	O
;	O
}	O
else	O
prompt	pointer
=	O
xstrdup	function
(	O
_	O
(	O
"Follow xref: "	pointer
)	O
)	O
;	O
}	O
line	pointer
=	O
info_read_completing_in_echo_area_with_exclusions	function
(	O
prompt	pointer
,	O
refs	pointer
,	O
exclude	pointer
)	O
;	O
free	function
(	O
prompt	pointer
)	O
;	O
window	pointer
=	O
active_window	pointer
;	O
if	O
(	O
!	O
line	pointer
)	O
{	O
info_abort_key	function
(	O
window	pointer
,	O
0	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
*	O
line	pointer
)	O
{	O
free	function
(	O
line	pointer
)	O
;	O
if	O
(	O
defentry	pointer
)	O
line	pointer
=	O
xstrdup	function
(	O
defentry	pointer
->	O
label	pointer
)	O
;	O
else	O
line	pointer
=	O
NULL	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
defentry	pointer
)	O
return	O
;	O
else	O
line	pointer
=	O
xstrdup	function
(	O
defentry	pointer
->	O
label	pointer
)	O
;	O
}	O
if	O
(	O
line	pointer
)	O
{	O
if	O
(	O
defentry	pointer
&&	O
strcmp	function
(	O
line	pointer
,	O
defentry	pointer
->	O
label	pointer
)	O
==	O
0	int
)	O
entry	pointer
=	O
defentry	pointer
;	O
else	O
{	O
register	O
int	O
i	int
;	O
int	O
best	int
=	O
-	O
1	int
,	O
min_dist	int
=	O
window	pointer
->	O
node	pointer
->	O
nodelen	long
;	O
REFERENCE	struct
*	O
ref	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
refs	pointer
&&	O
(	O
ref	pointer
=	O
refs	pointer
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
mbscasecmp	function
(	O
line	pointer
,	O
ref	pointer
->	O
label	pointer
)	O
==	O
0	int
)	O
{	O
int	O
dist	int
=	O
abs	function
(	O
window	pointer
->	O
point	long
-	O
ref	pointer
->	O
end	int
)	O
;	O
if	O
(	O
dist	int
<	O
min_dist	int
)	O
{	O
min_dist	int
=	O
dist	int
;	O
best	int
=	O
i	int
;	O
}	O
}	O
}	O
if	O
(	O
best	int
!=	O
-	O
1	int
)	O
entry	pointer
=	O
refs	pointer
[	O
best	int
]	O
;	O
else	O
entry	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
!	O
entry	pointer
&&	O
defentry	pointer
)	O
info_error	function
(	O
_	O
(	O
"The reference disappeared! (%s)"	pointer
)	O
,	O
line	pointer
)	O
;	O
else	O
{	O
info_select_reference	function
(	O
window	pointer
,	O
entry	pointer
)	O
;	O
}	O
free	function
(	O
line	pointer
)	O
;	O
}	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_menu_item	function
,	O
_	O
(	O
"Read a menu item and select its node"	pointer
)	O
)	O
{	O
if	O
(	O
window	pointer
->	O
node	pointer
->	O
references	pointer
)	O
{	O
REFERENCE	struct
*	O
*	O
r	pointer
;	O
for	O
(	O
r	pointer
=	O
window	pointer
->	O
node	pointer
->	O
references	pointer
;	O
*	O
r	pointer
;	O
r	pointer
++	O
)	O
if	O
(	O
(	O
*	O
r	pointer
)	O
->	O
type	enum
==	O
REFERENCE_MENU_ITEM	int
)	O
break	O
;	O
if	O
(	O
*	O
r	pointer
)	O
{	O
info_menu_or_ref_item	function
(	O
window	pointer
,	O
1	int
,	O
0	int
,	O
1	int
)	O
;	O
return	O
;	O
}	O
}	O
info_error	function
(	O
"%s"	pointer
,	O
msg_no_menu_node	pointer
)	O
;	O
return	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_xref_item	function
,	O
_	O
(	O
"Read a footnote or cross reference and select its node"	pointer
)	O
)	O
{	O
if	O
(	O
window	pointer
->	O
node	pointer
->	O
references	pointer
)	O
{	O
REFERENCE	struct
*	O
*	O
r	pointer
;	O
for	O
(	O
r	pointer
=	O
window	pointer
->	O
node	pointer
->	O
references	pointer
;	O
*	O
r	pointer
;	O
r	pointer
++	O
)	O
if	O
(	O
(	O
*	O
r	pointer
)	O
->	O
type	enum
==	O
REFERENCE_XREF	int
)	O
break	O
;	O
if	O
(	O
*	O
r	pointer
)	O
{	O
info_menu_or_ref_item	function
(	O
window	pointer
,	O
0	int
,	O
1	int
,	O
1	int
)	O
;	O
return	O
;	O
}	O
}	O
info_error	function
(	O
"%s"	pointer
,	O
msg_no_xref_node	pointer
)	O
;	O
return	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_find_menu	function
,	O
_	O
(	O
"Move to the start of this node's menu"	pointer
)	O
)	O
{	O
SEARCH_BINDING	struct
binding	pointer
;	O
long	O
position	long
;	O
binding	pointer
.	O
buffer	pointer
=	O
window	pointer
->	O
node	pointer
->	O
contents	pointer
;	O
binding	pointer
.	O
start	int
=	O
0	int
;	O
binding	pointer
.	O
end	int
=	O
window	pointer
->	O
node	pointer
->	O
nodelen	long
;	O
binding	pointer
.	O
flags	int
=	O
S_FoldCase	int
|	O
S_SkipDest	int
;	O
if	O
(	O
search	function
(	O
INFO_MENU_LABEL	pointer
,	O
&	O
binding	pointer
,	O
&	O
position	long
)	O
==	O
search_success	int
)	O
{	O
window	pointer
->	O
point	long
=	O
position	long
;	O
window_adjust_pagetop	function
(	O
window	pointer
)	O
;	O
window	pointer
->	O
flags	int
|=	O
W_UpdateWindow	int
;	O
}	O
else	O
info_error	function
(	O
"%s"	pointer
,	O
msg_no_menu_node	pointer
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_visit_menu	function
,	O
_	O
(	O
"Visit as many menu items at once as possible"	pointer
)	O
)	O
{	O
register	O
int	O
i	int
;	O
REFERENCE	struct
*	O
entry	pointer
,	O
*	O
*	O
menu	int
;	O
menu	int
=	O
window	pointer
->	O
node	pointer
->	O
references	pointer
;	O
if	O
(	O
!	O
menu	int
)	O
{	O
info_error	function
(	O
"%s"	pointer
,	O
msg_no_menu_node	pointer
)	O
;	O
return	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
entry	pointer
=	O
menu	int
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
{	O
WINDOW	struct
*	O
new	pointer
;	O
if	O
(	O
entry	pointer
->	O
type	enum
!=	O
REFERENCE_MENU_ITEM	int
)	O
continue	O
;	O
new	pointer
=	O
window_make_window	function
(	O
)	O
;	O
info_set_node_of_window	function
(	O
new	pointer
,	O
window	pointer
->	O
node	pointer
)	O
;	O
window_tile_windows	function
(	O
TILE_INTERNALS	int
)	O
;	O
if	O
(	O
!	O
new	pointer
)	O
{	O
info_error	function
(	O
"%s"	pointer
,	O
msg_win_too_small	pointer
)	O
;	O
break	O
;	O
}	O
else	O
{	O
active_window	pointer
=	O
new	pointer
;	O
if	O
(	O
!	O
info_select_reference	function
(	O
new	pointer
,	O
entry	pointer
)	O
)	O
break	O
;	O
}	O
}	O
}	O
static	O
int	O
info_move_to_xref	function
(	O
WINDOW	struct
*	O
window	pointer
,	O
int	O
dir	int
)	O
{	O
long	O
placement	long
=	O
-	O
1	int
;	O
NODE	struct
*	O
node	pointer
=	O
window	pointer
->	O
node	pointer
;	O
REFERENCE	struct
*	O
*	O
ref	pointer
;	O
if	O
(	O
!	O
node	pointer
->	O
references	pointer
||	O
!	O
node	pointer
->	O
references	pointer
[	O
0	int
]	O
)	O
return	O
0	int
;	O
if	O
(	O
dir	int
==	O
1	int
)	O
for	O
(	O
ref	pointer
=	O
node	pointer
->	O
references	pointer
;	O
*	O
ref	pointer
!=	O
0	int
;	O
ref	pointer
++	O
)	O
{	O
if	O
(	O
(	O
*	O
ref	pointer
)	O
->	O
start	int
>	O
window	pointer
->	O
point	long
)	O
{	O
placement	long
=	O
(	O
*	O
ref	pointer
)	O
->	O
start	int
;	O
break	O
;	O
}	O
}	O
else	O
for	O
(	O
ref	pointer
=	O
node	pointer
->	O
references	pointer
;	O
*	O
ref	pointer
!=	O
0	int
;	O
ref	pointer
++	O
)	O
{	O
if	O
(	O
(	O
*	O
ref	pointer
)	O
->	O
start	int
>=	O
window	pointer
->	O
point	long
)	O
break	O
;	O
placement	long
=	O
(	O
*	O
ref	pointer
)	O
->	O
start	int
;	O
}	O
if	O
(	O
placement	long
==	O
-	O
1	int
)	O
{	O
return	O
0	int
;	O
}	O
window	pointer
->	O
point	long
=	O
placement	long
;	O
window_adjust_pagetop	function
(	O
window	pointer
)	O
;	O
return	O
1	int
;	O
}	O
void	O
info_move_to_next_xref	function
(	O
WINDOW	struct
*	O
,	O
int	O
count	pointer
)	O
;	O
static	O
void	O
cleanup_history	function
(	O
WINDOW	struct
*	O
window	pointer
,	O
int	O
start	int
,	O
int	O
end	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
start	int
;	O
i	int
<	O
end	int
;	O
i	int
++	O
)	O
{	O
free_history_node	function
(	O
window	pointer
->	O
hist	pointer
[	O
i	int
]	O
->	O
node	pointer
)	O
;	O
free	function
(	O
window	pointer
->	O
hist	pointer
[	O
i	int
]	O
)	O
;	O
}	O
memmove	function
(	O
&	O
window	pointer
->	O
hist	pointer
[	O
start	int
]	O
,	O
&	O
window	pointer
->	O
hist	pointer
[	O
end	int
]	O
,	O
(	O
window	pointer
->	O
hist_index	long
-	O
end	int
)	O
*	O
sizeof	O
(	O
WINDOW_STATE	struct
*	O
)	O
)	O
;	O
window	pointer
->	O
hist_index	long
-=	O
end	int
-	O
start	int
;	O
window	pointer
->	O
hist	pointer
[	O
window	pointer
->	O
hist_index	long
]	O
=	O
0	int
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_move_to_prev_xref	function
,	O
_	O
(	O
"Move to the previous cross reference"	pointer
)	O
)	O
{	O
if	O
(	O
count	pointer
<	O
0	int
)	O
info_move_to_next_xref	function
(	O
window	pointer
,	O
-	O
count	pointer
)	O
;	O
else	O
{	O
size_t	long
last_hist_index	long
,	O
starting_hist_index	long
;	O
char	O
*	O
initial_nodename	pointer
=	O
window	pointer
->	O
node	pointer
->	O
nodename	pointer
;	O
last_hist_index	long
=	O
starting_hist_index	long
=	O
window	pointer
->	O
hist_index	long
-	O
1	int
;	O
while	O
(	O
count	pointer
>	O
0	int
)	O
{	O
if	O
(	O
info_move_to_xref	function
(	O
window	pointer
,	O
-	O
1	int
)	O
)	O
{	O
last_hist_index	long
=	O
window	pointer
->	O
hist_index	long
-	O
1	int
;	O
count	pointer
--	O
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
cursor_movement_scrolls_p	int
)	O
{	O
REFERENCE	struct
*	O
*	O
r	pointer
=	O
window	pointer
->	O
node	pointer
->	O
references	pointer
;	O
if	O
(	O
r	pointer
&&	O
r	pointer
[	O
0	int
]	O
)	O
{	O
int	O
i	int
=	O
0	int
;	O
while	O
(	O
r	pointer
[	O
i	int
+	O
1	int
]	O
)	O
i	int
++	O
;	O
window	pointer
->	O
point	long
=	O
r	pointer
[	O
i	int
]	O
->	O
start	int
;	O
window_adjust_pagetop	function
(	O
window	pointer
)	O
;	O
count	pointer
--	O
;	O
continue	O
;	O
}	O
info_error	function
(	O
"%s"	pointer
,	O
msg_no_xref_node	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
backward_move_node_structure	function
(	O
window	pointer
,	O
info_scroll_behaviour	int
!=	O
0	int
)	O
||	O
!	O
strcmp	function
(	O
window	pointer
->	O
node	pointer
->	O
nodename	pointer
,	O
initial_nodename	pointer
)	O
)	O
{	O
break	O
;	O
}	O
window	pointer
->	O
point	long
=	O
window	pointer
->	O
node	pointer
->	O
nodelen	long
-	O
1	int
;	O
}	O
while	O
(	O
window	pointer
->	O
hist_index	long
>	O
last_hist_index	long
+	O
1	int
)	O
forget_node	function
(	O
window	pointer
)	O
;	O
if	O
(	O
last_hist_index	long
!=	O
starting_hist_index	long
)	O
cleanup_history	function
(	O
window	pointer
,	O
starting_hist_index	long
+	O
1	int
,	O
last_hist_index	long
)	O
;	O
}	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_move_to_next_xref	function
,	O
_	O
(	O
"Move to the next cross reference"	pointer
)	O
)	O
{	O
if	O
(	O
count	pointer
<	O
0	int
)	O
info_move_to_prev_xref	function
(	O
window	pointer
,	O
-	O
count	pointer
)	O
;	O
else	O
{	O
size_t	long
last_hist_index	long
,	O
starting_hist_index	long
;	O
char	O
*	O
initial_nodename	pointer
=	O
window	pointer
->	O
node	pointer
->	O
nodename	pointer
;	O
last_hist_index	long
=	O
starting_hist_index	long
=	O
window	pointer
->	O
hist_index	long
-	O
1	int
;	O
while	O
(	O
count	pointer
>	O
0	int
)	O
{	O
if	O
(	O
info_move_to_xref	function
(	O
window	pointer
,	O
1	int
)	O
)	O
{	O
last_hist_index	long
=	O
window	pointer
->	O
hist_index	long
-	O
1	int
;	O
count	pointer
--	O
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
cursor_movement_scrolls_p	int
)	O
{	O
REFERENCE	struct
*	O
*	O
r	pointer
=	O
window	pointer
->	O
node	pointer
->	O
references	pointer
;	O
if	O
(	O
r	pointer
&&	O
r	pointer
[	O
0	int
]	O
)	O
{	O
window	pointer
->	O
point	long
=	O
r	pointer
[	O
0	int
]	O
->	O
start	int
;	O
window_adjust_pagetop	function
(	O
window	pointer
)	O
;	O
count	pointer
--	O
;	O
continue	O
;	O
}	O
info_error	function
(	O
"%s"	pointer
,	O
msg_no_xref_node	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
forward_move_node_structure	function
(	O
window	pointer
,	O
info_scroll_behaviour	int
)	O
!=	O
0	int
||	O
!	O
strcmp	function
(	O
window	pointer
->	O
node	pointer
->	O
nodename	pointer
,	O
initial_nodename	pointer
)	O
)	O
{	O
break	O
;	O
}	O
}	O
while	O
(	O
window	pointer
->	O
hist_index	long
>	O
last_hist_index	long
+	O
1	int
)	O
forget_node	function
(	O
window	pointer
)	O
;	O
if	O
(	O
last_hist_index	long
!=	O
starting_hist_index	long
)	O
cleanup_history	function
(	O
window	pointer
,	O
starting_hist_index	long
+	O
1	int
,	O
last_hist_index	long
)	O
;	O
}	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_select_reference_this_line	function
,	O
_	O
(	O
"Select reference or menu item appearing on this line"	pointer
)	O
)	O
{	O
REFERENCE	struct
*	O
*	O
ref	pointer
=	O
window	pointer
->	O
node	pointer
->	O
references	pointer
;	O
if	O
(	O
!	O
ref	pointer
||	O
!	O
*	O
ref	pointer
)	O
return	O
;	O
info_menu_or_ref_item	function
(	O
window	pointer
,	O
1	int
,	O
1	int
,	O
0	int
)	O
;	O
}	O
NODE	struct
*	O
info_follow_menus	function
(	O
NODE	struct
*	O
initial_node	pointer
,	O
char	O
*	O
*	O
menus	pointer
,	O
char	O
*	O
*	O
error	pointer
,	O
int	O
strict	int
)	O
{	O
NODE	struct
*	O
node	pointer
=	O
NULL	O
;	O
for	O
(	O
;	O
*	O
menus	pointer
;	O
menus	pointer
++	O
)	O
{	O
REFERENCE	struct
*	O
entry	pointer
;	O
char	O
*	O
arg	pointer
=	O
*	O
menus	pointer
;	O
debug	O
(	O
3	int
,	O
(	O
"looking for %s in %s:%s"	pointer
,	O
arg	pointer
,	O
initial_node	pointer
->	O
fullpath	pointer
,	O
initial_node	pointer
->	O
nodename	pointer
)	O
)	O
;	O
if	O
(	O
!	O
initial_node	pointer
->	O
references	pointer
)	O
{	O
if	O
(	O
error	pointer
)	O
{	O
free	function
(	O
*	O
error	pointer
)	O
;	O
asprintf	function
(	O
error	pointer
,	O
_	O
(	O
"No menu in node '%s'"	pointer
)	O
,	O
node_printed_rep	function
(	O
initial_node	pointer
)	O
)	O
;	O
}	O
debug	O
(	O
3	int
,	O
(	O
"no menu found"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
strict	int
)	O
return	O
initial_node	pointer
;	O
else	O
{	O
free_history_node	function
(	O
initial_node	pointer
)	O
;	O
return	O
0	int
;	O
}	O
}	O
entry	pointer
=	O
info_get_menu_entry_by_label	function
(	O
initial_node	pointer
,	O
arg	pointer
,	O
!	O
strict	int
)	O
;	O
if	O
(	O
!	O
entry	pointer
)	O
{	O
if	O
(	O
error	pointer
)	O
{	O
free	function
(	O
*	O
error	pointer
)	O
;	O
asprintf	function
(	O
error	pointer
,	O
_	O
(	O
"No menu item '%s' in node '%s'"	pointer
)	O
,	O
arg	pointer
,	O
node_printed_rep	function
(	O
initial_node	pointer
)	O
)	O
;	O
}	O
debug	O
(	O
3	int
,	O
(	O
"no entry found"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
strict	int
)	O
return	O
initial_node	pointer
;	O
else	O
{	O
free_history_node	function
(	O
initial_node	pointer
)	O
;	O
return	O
0	int
;	O
}	O
}	O
debug	O
(	O
3	int
,	O
(	O
"entry: %s, %s"	pointer
,	O
entry	pointer
->	O
filename	pointer
,	O
entry	pointer
->	O
nodename	pointer
)	O
)	O
;	O
node	pointer
=	O
info_get_node_with_defaults	function
(	O
entry	pointer
->	O
filename	pointer
,	O
entry	pointer
->	O
nodename	pointer
,	O
initial_node	pointer
)	O
;	O
if	O
(	O
!	O
node	pointer
)	O
{	O
debug	O
(	O
3	int
,	O
(	O
"no matching node found"	pointer
)	O
)	O
;	O
if	O
(	O
error	pointer
)	O
{	O
free	function
(	O
*	O
error	pointer
)	O
;	O
asprintf	function
(	O
error	pointer
,	O
_	O
(	O
"Unable to find node referenced by '%s' in '%s'"	pointer
)	O
,	O
entry	pointer
->	O
label	pointer
,	O
node_printed_rep	function
(	O
initial_node	pointer
)	O
)	O
;	O
}	O
if	O
(	O
strict	int
)	O
{	O
free_history_node	function
(	O
initial_node	pointer
)	O
;	O
return	O
0	int
;	O
}	O
else	O
return	O
initial_node	pointer
;	O
}	O
debug	O
(	O
3	int
,	O
(	O
"node: %s, %s"	pointer
,	O
node	pointer
->	O
fullpath	pointer
,	O
node	pointer
->	O
nodename	pointer
)	O
)	O
;	O
free_history_node	function
(	O
initial_node	pointer
)	O
;	O
initial_node	pointer
=	O
node	pointer
;	O
}	O
return	O
initial_node	pointer
;	O
}	O
static	O
char	O
*	O
*	O
split_list_of_nodenames	function
(	O
char	O
*	O
str	pointer
)	O
{	O
unsigned	O
len	long
=	O
2	int
;	O
char	O
*	O
*	O
nodes	pointer
=	O
xmalloc	function
(	O
len	long
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
nodes	pointer
[	O
len	long
-	O
2	int
]	O
=	O
str	pointer
;	O
while	O
(	O
*	O
str	pointer
++	O
)	O
{	O
if	O
(	O
*	O
str	pointer
==	O
','	O
)	O
{	O
*	O
str	pointer
++	O
=	O
0	int
;	O
len	long
++	O
;	O
nodes	pointer
=	O
xrealloc	function
(	O
nodes	pointer
,	O
len	long
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
nodes	pointer
[	O
len	long
-	O
2	int
]	O
=	O
str	pointer
;	O
}	O
}	O
nodes	pointer
[	O
len	long
-	O
1	int
]	O
=	O
NULL	O
;	O
return	O
nodes	pointer
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_menu_sequence	function
,	O
_	O
(	O
"Read a list of menus starting from dir and follow them"	pointer
)	O
)	O
{	O
char	O
*	O
line	pointer
=	O
info_read_in_echo_area	function
(	O
_	O
(	O
"Follow menus: "	pointer
)	O
)	O
;	O
if	O
(	O
!	O
line	pointer
)	O
{	O
info_abort_key	function
(	O
window	pointer
,	O
0	int
)	O
;	O
return	O
;	O
}	O
canonicalize_whitespace	function
(	O
line	pointer
)	O
;	O
if	O
(	O
*	O
line	pointer
)	O
{	O
char	O
*	O
error	pointer
=	O
0	int
;	O
NODE	struct
*	O
dir_node	pointer
=	O
get_dir_node	function
(	O
)	O
;	O
char	O
*	O
*	O
nodes	pointer
=	O
split_list_of_nodenames	function
(	O
line	pointer
)	O
;	O
NODE	struct
*	O
node	pointer
;	O
if	O
(	O
!	O
dir_node	pointer
)	O
dir_node	pointer
=	O
info_get_node	function
(	O
window	pointer
->	O
node	pointer
->	O
fullpath	pointer
,	O
0	int
)	O
;	O
if	O
(	O
!	O
dir_node	pointer
)	O
info_error	function
(	O
msg_cant_find_node	pointer
,	O
"Top"	pointer
)	O
;	O
else	O
{	O
node	pointer
=	O
info_follow_menus	function
(	O
dir_node	pointer
,	O
nodes	pointer
,	O
&	O
error	pointer
,	O
0	int
)	O
;	O
info_set_node_of_window	function
(	O
window	pointer
,	O
node	pointer
)	O
;	O
if	O
(	O
error	pointer
)	O
show_error_node	function
(	O
error	pointer
)	O
;	O
}	O
free	function
(	O
nodes	pointer
)	O
;	O
}	O
free	function
(	O
line	pointer
)	O
;	O
}	O
static	O
int	O
info_handle_pointer	function
(	O
char	O
*	O
label	pointer
,	O
WINDOW	struct
*	O
window	pointer
)	O
{	O
char	O
*	O
description	pointer
;	O
NODE	struct
*	O
node	pointer
;	O
if	O
(	O
!	O
strcmp	function
(	O
label	pointer
,	O
"Up"	pointer
)	O
)	O
description	pointer
=	O
window	pointer
->	O
node	pointer
->	O
up	pointer
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
label	pointer
,	O
"Next"	pointer
)	O
)	O
description	pointer
=	O
window	pointer
->	O
node	pointer
->	O
next	pointer
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
label	pointer
,	O
"Prev"	pointer
)	O
)	O
description	pointer
=	O
window	pointer
->	O
node	pointer
->	O
prev	pointer
;	O
if	O
(	O
!	O
description	pointer
)	O
{	O
info_error	function
(	O
msg_no_pointer	pointer
,	O
label	pointer
)	O
;	O
return	O
0	int
;	O
}	O
info_parse_node	function
(	O
description	pointer
)	O
;	O
node	pointer
=	O
info_get_node_with_defaults	function
(	O
info_parsed_filename	pointer
,	O
info_parsed_nodename	pointer
,	O
window	pointer
->	O
node	pointer
)	O
;	O
if	O
(	O
!	O
node	pointer
)	O
{	O
if	O
(	O
info_recent_file_error	pointer
)	O
info_error	function
(	O
"%s"	pointer
,	O
info_recent_file_error	pointer
)	O
;	O
else	O
info_error	function
(	O
msg_cant_find_node	pointer
,	O
description	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
strcmp	function
(	O
label	pointer
,	O
"Up"	pointer
)	O
==	O
0	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
window	pointer
->	O
hist_index	long
-	O
1	int
;	O
i	int
>=	O
0	int
;	O
i	int
--	O
)	O
{	O
NODE	struct
*	O
p	pointer
=	O
window	pointer
->	O
hist	pointer
[	O
i	int
]	O
->	O
node	pointer
;	O
if	O
(	O
p	pointer
->	O
fullpath	pointer
&&	O
!	O
strcmp	function
(	O
p	pointer
->	O
fullpath	pointer
,	O
node	pointer
->	O
fullpath	pointer
)	O
&&	O
p	pointer
->	O
nodename	pointer
&&	O
!	O
strcmp	function
(	O
p	pointer
->	O
nodename	pointer
,	O
node	pointer
->	O
nodename	pointer
)	O
)	O
break	O
;	O
}	O
if	O
(	O
i	int
>=	O
0	int
)	O
node	pointer
->	O
display_pos	long
=	O
window	pointer
->	O
hist	pointer
[	O
i	int
]	O
->	O
point	long
;	O
}	O
info_set_node_of_window	function
(	O
window	pointer
,	O
node	pointer
)	O
;	O
return	O
1	int
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_next_node	function
,	O
_	O
(	O
"Select the Next node"	pointer
)	O
)	O
{	O
info_handle_pointer	function
(	O
"Next"	pointer
,	O
window	pointer
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_prev_node	function
,	O
_	O
(	O
"Select the Prev node"	pointer
)	O
)	O
{	O
info_handle_pointer	function
(	O
"Prev"	pointer
,	O
window	pointer
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_up_node	function
,	O
_	O
(	O
"Select the Up node"	pointer
)	O
)	O
{	O
info_handle_pointer	function
(	O
"Up"	pointer
,	O
window	pointer
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_last_node	function
,	O
_	O
(	O
"Select the last node in this file"	pointer
)	O
)	O
{	O
register	O
int	O
i	int
;	O
FILE_BUFFER	struct
*	O
fb	pointer
=	O
file_buffer_of_window	function
(	O
window	pointer
)	O
;	O
NODE	struct
*	O
node	pointer
=	O
NULL	O
;	O
if	O
(	O
fb	pointer
&&	O
fb	pointer
->	O
tags	pointer
)	O
{	O
int	O
last_node_tag_idx	int
=	O
-	O
1	int
;	O
if	O
(	O
count	pointer
==	O
0	int
||	O
(	O
count	pointer
==	O
1	int
&&	O
!	O
info_explicit_arg	int
)	O
)	O
count	pointer
=	O
-	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
count	pointer
&&	O
fb	pointer
->	O
tags	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
if	O
(	O
fb	pointer
->	O
tags	pointer
[	O
i	int
]	O
->	O
cache	struct
.	O
nodelen	long
!=	O
0	int
)	O
{	O
count	pointer
--	O
;	O
last_node_tag_idx	int
=	O
i	int
;	O
}	O
if	O
(	O
count	pointer
>	O
0	int
)	O
i	int
=	O
last_node_tag_idx	int
+	O
1	int
;	O
if	O
(	O
i	int
>	O
0	int
)	O
node	pointer
=	O
info_get_node	function
(	O
fb	pointer
->	O
filename	pointer
,	O
fb	pointer
->	O
tags	pointer
[	O
i	int
-	O
1	int
]	O
->	O
nodename	pointer
)	O
;	O
}	O
if	O
(	O
!	O
node	pointer
)	O
info_error	function
(	O
"%s"	pointer
,	O
_	O
(	O
"This window has no additional nodes"	pointer
)	O
)	O
;	O
else	O
info_set_node_of_window	function
(	O
window	pointer
,	O
node	pointer
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_first_node	function
,	O
_	O
(	O
"Select the first node in this file"	pointer
)	O
)	O
{	O
FILE_BUFFER	struct
*	O
fb	pointer
=	O
file_buffer_of_window	function
(	O
window	pointer
)	O
;	O
NODE	struct
*	O
node	pointer
=	O
NULL	O
;	O
if	O
(	O
count	pointer
==	O
0	int
)	O
count	pointer
=	O
1	int
;	O
if	O
(	O
fb	pointer
&&	O
fb	pointer
->	O
tags	pointer
)	O
{	O
register	O
int	O
i	int
;	O
int	O
last_node_tag_idx	int
=	O
-	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
count	pointer
&&	O
fb	pointer
->	O
tags	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
if	O
(	O
fb	pointer
->	O
tags	pointer
[	O
i	int
]	O
->	O
cache	struct
.	O
nodelen	long
!=	O
0	int
)	O
{	O
count	pointer
--	O
;	O
last_node_tag_idx	int
=	O
i	int
;	O
}	O
if	O
(	O
count	pointer
>	O
0	int
)	O
i	int
=	O
last_node_tag_idx	int
+	O
1	int
;	O
if	O
(	O
i	int
>	O
0	int
)	O
node	pointer
=	O
info_get_node	function
(	O
fb	pointer
->	O
filename	pointer
,	O
fb	pointer
->	O
tags	pointer
[	O
i	int
-	O
1	int
]	O
->	O
nodename	pointer
)	O
;	O
}	O
if	O
(	O
!	O
node	pointer
)	O
info_error	function
(	O
"%s"	pointer
,	O
_	O
(	O
"This window has no additional nodes"	pointer
)	O
)	O
;	O
else	O
info_set_node_of_window	function
(	O
window	pointer
,	O
node	pointer
)	O
;	O
}	O
int	O
scroll_last_node	int
=	O
SLN_Stop	int
;	O
static	O
int	O
forward_move_node_structure	function
(	O
WINDOW	struct
*	O
window	pointer
,	O
int	O
behaviour	int
)	O
{	O
if	O
(	O
window	pointer
->	O
node	pointer
->	O
flags	int
&	O
(	O
N_IsInternal	int
|	O
N_IsManPage	int
)	O
)	O
return	O
1	int
;	O
switch	O
(	O
behaviour	int
)	O
{	O
case	O
IS_PageOnly	int
:	O
info_error	function
(	O
"%s"	pointer
,	O
msg_at_node_bottom	pointer
)	O
;	O
return	O
1	int
;	O
case	O
IS_NextOnly	int
:	O
return	O
!	O
info_handle_pointer	function
(	O
"Next"	pointer
,	O
window	pointer
)	O
;	O
break	O
;	O
case	O
IS_Continuous	int
:	O
{	O
if	O
(	O
!	O
(	O
window	pointer
->	O
node	pointer
->	O
flags	int
&	O
N_IsIndex	int
)	O
&&	O
!	O
(	O
window	pointer
->	O
node	pointer
->	O
flags	int
&	O
N_IsDir	int
)	O
)	O
{	O
REFERENCE	struct
*	O
entry	pointer
;	O
if	O
(	O
entry	pointer
=	O
select_menu_digit	function
(	O
window	pointer
,	O
'1'	O
)	O
)	O
{	O
info_select_reference	function
(	O
window	pointer
,	O
entry	pointer
)	O
;	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
window	pointer
->	O
node	pointer
->	O
next	pointer
)	O
{	O
info_handle_pointer	function
(	O
"Next"	pointer
,	O
window	pointer
)	O
;	O
return	O
0	int
;	O
}	O
{	O
int	O
up_counter	int
;	O
int	O
starting_hist_index	long
=	O
window	pointer
->	O
hist_index	long
;	O
up_counter	int
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
window	pointer
->	O
node	pointer
->	O
up	pointer
)	O
{	O
REFERENCE	struct
*	O
entry	pointer
;	O
if	O
(	O
!	O
info_handle_pointer	function
(	O
"Up"	pointer
,	O
window	pointer
)	O
)	O
return	O
1	int
;	O
up_counter	int
++	O
;	O
if	O
(	O
!	O
window	pointer
->	O
node	pointer
->	O
next	pointer
)	O
continue	O
;	O
entry	pointer
=	O
select_menu_digit	function
(	O
window	pointer
,	O
'1'	O
)	O
;	O
if	O
(	O
entry	pointer
&&	O
!	O
strcmp	function
(	O
window	pointer
->	O
node	pointer
->	O
next	pointer
,	O
entry	pointer
->	O
nodename	pointer
)	O
)	O
continue	O
;	O
info_handle_pointer	function
(	O
"Next"	pointer
,	O
window	pointer
)	O
;	O
cleanup_history	function
(	O
window	pointer
,	O
starting_hist_index	long
,	O
window	pointer
->	O
hist_index	long
-	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
register	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
up_counter	int
;	O
i	int
++	O
)	O
forget_node	function
(	O
window	pointer
)	O
;	O
switch	O
(	O
scroll_last_node	int
)	O
{	O
case	O
SLN_Stop	int
:	O
info_error	function
(	O
"%s"	pointer
,	O
_	O
(	O
"No more nodes within this document"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
case	O
SLN_Top	int
:	O
info_parse_and_select	function
(	O
"Top"	pointer
,	O
window	pointer
)	O
;	O
return	O
0	int
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
}	O
}	O
}	O
break	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
backward_move_node_structure	function
(	O
WINDOW	struct
*	O
window	pointer
,	O
int	O
behaviour	int
)	O
{	O
if	O
(	O
window	pointer
->	O
node	pointer
->	O
flags	int
&	O
(	O
N_IsInternal	int
|	O
N_IsManPage	int
)	O
)	O
return	O
1	int
;	O
switch	O
(	O
behaviour	int
)	O
{	O
case	O
IS_PageOnly	int
:	O
info_error	function
(	O
"%s"	pointer
,	O
msg_at_node_top	pointer
)	O
;	O
return	O
1	int
;	O
case	O
IS_NextOnly	int
:	O
return	O
!	O
info_handle_pointer	function
(	O
"Prev"	pointer
,	O
window	pointer
)	O
;	O
break	O
;	O
case	O
IS_Continuous	int
:	O
if	O
(	O
window	pointer
->	O
node	pointer
->	O
up	pointer
)	O
{	O
if	O
(	O
!	O
strncasecmp	function
(	O
window	pointer
->	O
node	pointer
->	O
up	pointer
,	O
"(dir)"	pointer
,	O
strlen	function
(	O
"(dir)"	pointer
)	O
)	O
)	O
{	O
info_error	function
(	O
"%s"	pointer
,	O
_	O
(	O
"No 'Prev' or 'Up' for this node within this document"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
window	pointer
->	O
node	pointer
->	O
prev	pointer
&&	O
!	O
strcmp	function
(	O
window	pointer
->	O
node	pointer
->	O
prev	pointer
,	O
window	pointer
->	O
node	pointer
->	O
up	pointer
)	O
)	O
{	O
info_handle_pointer	function
(	O
"Up"	pointer
,	O
window	pointer
)	O
;	O
}	O
else	O
if	O
(	O
window	pointer
->	O
node	pointer
->	O
prev	pointer
)	O
{	O
int	O
starting_hist_index	long
=	O
window	pointer
->	O
hist_index	long
;	O
info_handle_pointer	function
(	O
"Prev"	pointer
,	O
window	pointer
)	O
;	O
if	O
(	O
!	O
(	O
window	pointer
->	O
node	pointer
->	O
flags	int
&	O
N_IsIndex	int
)	O
)	O
{	O
while	O
(	O
1	int
)	O
{	O
REFERENCE	struct
*	O
entry	pointer
=	O
select_menu_digit	function
(	O
window	pointer
,	O
'0'	O
)	O
;	O
if	O
(	O
!	O
entry	pointer
)	O
break	O
;	O
if	O
(	O
!	O
info_select_reference	function
(	O
window	pointer
,	O
entry	pointer
)	O
)	O
break	O
;	O
}	O
cleanup_history	function
(	O
window	pointer
,	O
starting_hist_index	long
,	O
window	pointer
->	O
hist_index	long
-	O
1	int
)	O
;	O
}	O
}	O
else	O
info_handle_pointer	function
(	O
"Up"	pointer
,	O
window	pointer
)	O
;	O
}	O
else	O
if	O
(	O
window	pointer
->	O
node	pointer
->	O
prev	pointer
)	O
info_handle_pointer	function
(	O
"Prev"	pointer
,	O
window	pointer
)	O
;	O
else	O
{	O
info_error	function
(	O
"%s"	pointer
,	O
_	O
(	O
"No 'Prev' or 'Up' for this node within this document"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
void	O
info_global_prev_node	function
(	O
WINDOW	struct
*	O
,	O
int	O
count	pointer
)	O
;	O
DECLARE_INFO_COMMAND	O
(	O
info_global_next_node	function
,	O
_	O
(	O
"Move forwards or down through node structure"	pointer
)	O
)	O
{	O
if	O
(	O
count	pointer
<	O
0	int
)	O
info_global_prev_node	function
(	O
window	pointer
,	O
-	O
count	pointer
)	O
;	O
else	O
{	O
while	O
(	O
count	pointer
)	O
{	O
if	O
(	O
forward_move_node_structure	function
(	O
window	pointer
,	O
IS_Continuous	int
)	O
)	O
break	O
;	O
count	pointer
--	O
;	O
}	O
}	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_global_prev_node	function
,	O
_	O
(	O
"Move backwards or up through node structure"	pointer
)	O
)	O
{	O
if	O
(	O
count	pointer
<	O
0	int
)	O
info_global_next_node	function
(	O
window	pointer
,	O
-	O
count	pointer
)	O
;	O
else	O
{	O
while	O
(	O
count	pointer
)	O
{	O
if	O
(	O
backward_move_node_structure	function
(	O
window	pointer
,	O
IS_Continuous	int
)	O
)	O
break	O
;	O
count	pointer
--	O
;	O
}	O
}	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_goto_node	function
,	O
_	O
(	O
"Read a node name and select it"	pointer
)	O
)	O
{	O
char	O
*	O
line	pointer
;	O
{	O
register	O
int	O
fbi	int
,	O
i	int
;	O
FILE_BUFFER	struct
*	O
current	pointer
;	O
REFERENCE	struct
*	O
*	O
items	pointer
=	O
NULL	O
;	O
size_t	long
items_index	long
=	O
0	int
;	O
size_t	long
items_slots	long
=	O
0	int
;	O
current	pointer
=	O
file_buffer_of_window	function
(	O
window	pointer
)	O
;	O
for	O
(	O
fbi	int
=	O
0	int
;	O
info_loaded_files	pointer
&&	O
info_loaded_files	pointer
[	O
fbi	int
]	O
;	O
fbi	int
++	O
)	O
{	O
FILE_BUFFER	struct
*	O
fb	pointer
;	O
REFERENCE	struct
*	O
entry	pointer
;	O
int	O
this_is_the_current_fb	int
;	O
fb	pointer
=	O
info_loaded_files	pointer
[	O
fbi	int
]	O
;	O
this_is_the_current_fb	int
=	O
(	O
current	pointer
==	O
fb	pointer
)	O
;	O
entry	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
REFERENCE	struct
)	O
)	O
;	O
entry	pointer
->	O
filename	pointer
=	O
entry	pointer
->	O
nodename	pointer
=	O
NULL	O
;	O
entry	pointer
->	O
label	pointer
=	O
xmalloc	function
(	O
4	int
+	O
strlen	function
(	O
fb	pointer
->	O
filename	pointer
)	O
)	O
;	O
sprintf	function
(	O
entry	pointer
->	O
label	pointer
,	O
"(%s)*"	pointer
,	O
fb	pointer
->	O
filename	pointer
)	O
;	O
add_pointer_to_array	O
(	O
entry	pointer
,	O
items_index	long
,	O
items	pointer
,	O
items_slots	long
,	O
10	int
)	O
;	O
if	O
(	O
fb	pointer
->	O
tags	pointer
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
fb	pointer
->	O
tags	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
entry	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
REFERENCE	struct
)	O
)	O
;	O
entry	pointer
->	O
filename	pointer
=	O
entry	pointer
->	O
nodename	pointer
=	O
NULL	O
;	O
if	O
(	O
this_is_the_current_fb	int
)	O
entry	pointer
->	O
label	pointer
=	O
xstrdup	function
(	O
fb	pointer
->	O
tags	pointer
[	O
i	int
]	O
->	O
nodename	pointer
)	O
;	O
else	O
{	O
entry	pointer
->	O
label	pointer
=	O
xmalloc	function
(	O
4	int
+	O
strlen	function
(	O
fb	pointer
->	O
filename	pointer
)	O
+	O
strlen	function
(	O
fb	pointer
->	O
tags	pointer
[	O
i	int
]	O
->	O
nodename	pointer
)	O
)	O
;	O
sprintf	function
(	O
entry	pointer
->	O
label	pointer
,	O
"(%s)%s"	pointer
,	O
fb	pointer
->	O
filename	pointer
,	O
fb	pointer
->	O
tags	pointer
[	O
i	int
]	O
->	O
nodename	pointer
)	O
;	O
}	O
add_pointer_to_array	O
(	O
entry	pointer
,	O
items_index	long
,	O
items	pointer
,	O
items_slots	long
,	O
100	int
)	O
;	O
}	O
}	O
}	O
line	pointer
=	O
info_read_maybe_completing	function
(	O
_	O
(	O
"Goto node: "	pointer
)	O
,	O
items	pointer
)	O
;	O
info_free_references	function
(	O
items	pointer
)	O
;	O
}	O
if	O
(	O
!	O
line	pointer
)	O
{	O
info_abort_key	function
(	O
window	pointer
,	O
0	int
)	O
;	O
return	O
;	O
}	O
canonicalize_whitespace	function
(	O
line	pointer
)	O
;	O
if	O
(	O
*	O
line	pointer
)	O
info_parse_and_select	function
(	O
line	pointer
,	O
window	pointer
)	O
;	O
free	function
(	O
line	pointer
)	O
;	O
}	O
static	O
NODE	struct
*	O
find_invocation_node_by_nodename	function
(	O
FILE_BUFFER	struct
*	O
fb	pointer
,	O
char	O
*	O
program	pointer
)	O
{	O
NODE	struct
*	O
node	pointer
=	O
0	int
;	O
TAG	struct
*	O
*	O
n	long
;	O
char	O
*	O
try1	pointer
,	O
*	O
try2	pointer
;	O
n	long
=	O
fb	pointer
->	O
tags	pointer
;	O
if	O
(	O
!	O
n	long
)	O
return	O
0	int
;	O
asprintf	function
(	O
&	O
try1	pointer
,	O
"Invoking %s"	pointer
,	O
program	pointer
)	O
;	O
asprintf	function
(	O
&	O
try2	pointer
,	O
"%s invocation"	pointer
,	O
program	pointer
)	O
;	O
for	O
(	O
;	O
*	O
n	long
;	O
n	long
++	O
)	O
{	O
if	O
(	O
(	O
*	O
n	long
)	O
->	O
nodename	pointer
&&	O
(	O
!	O
strcasecmp	function
(	O
(	O
*	O
n	long
)	O
->	O
nodename	pointer
,	O
try1	pointer
)	O
||	O
!	O
strcasecmp	function
(	O
(	O
*	O
n	long
)	O
->	O
nodename	pointer
,	O
try2	pointer
)	O
)	O
)	O
{	O
node	pointer
=	O
info_get_node_of_file_buffer	function
(	O
fb	pointer
,	O
(	O
*	O
n	long
)	O
->	O
nodename	pointer
)	O
;	O
break	O
;	O
}	O
}	O
free	function
(	O
try1	pointer
)	O
;	O
free	function
(	O
try2	pointer
)	O
;	O
return	O
node	pointer
;	O
}	O
REFERENCE	struct
*	O
info_intuit_options_node	function
(	O
NODE	struct
*	O
node	pointer
,	O
char	O
*	O
program	pointer
)	O
{	O
static	O
const	O
char	O
*	O
invocation_nodes	array
[	O
]	O
=	O
{	O
"%s invocation"	pointer
,	O
"Invoking %s"	pointer
,	O
"Preliminaries"	pointer
,	O
"Invocation"	pointer
,	O
"Command Arguments"	pointer
,	O
"Invoking `%s'"	pointer
,	O
"%s options"	pointer
,	O
"Options"	pointer
,	O
"Option "	pointer
,	O
"Invoking"	pointer
,	O
"All options"	pointer
,	O
"Arguments"	pointer
,	O
"%s cmdline"	pointer
,	O
"%s"	pointer
,	O
(	O
const	O
char	O
*	O
)	O
0	int
}	O
;	O
char	O
*	O
filename	pointer
=	O
node	pointer
->	O
fullpath	pointer
;	O
if	O
(	O
!	O
strcmp	function
(	O
"Top"	pointer
,	O
node	pointer
->	O
nodename	pointer
)	O
)	O
{	O
FILE_BUFFER	struct
*	O
fb	pointer
;	O
NODE	struct
*	O
n	long
;	O
fb	pointer
=	O
info_find_file	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
!	O
fb	pointer
)	O
return	O
0	int
;	O
n	long
=	O
find_invocation_node_by_nodename	function
(	O
fb	pointer
,	O
program	pointer
)	O
;	O
if	O
(	O
n	long
)	O
{	O
free_history_node	function
(	O
node	pointer
)	O
;	O
node	pointer
=	O
n	long
;	O
}	O
}	O
while	O
(	O
1	int
)	O
{	O
const	O
char	O
*	O
*	O
try_node	pointer
;	O
REFERENCE	struct
*	O
entry	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
node	pointer
->	O
references	pointer
)	O
break	O
;	O
for	O
(	O
try_node	pointer
=	O
invocation_nodes	array
;	O
*	O
try_node	pointer
;	O
try_node	pointer
++	O
)	O
{	O
char	O
*	O
nodename	pointer
;	O
nodename	pointer
=	O
xmalloc	function
(	O
strlen	function
(	O
program	pointer
)	O
+	O
strlen	function
(	O
*	O
try_node	pointer
)	O
)	O
;	O
sprintf	function
(	O
nodename	pointer
,	O
*	O
try_node	pointer
,	O
program	pointer
)	O
;	O
entry	pointer
=	O
info_get_menu_entry_by_label	function
(	O
node	pointer
,	O
nodename	pointer
,	O
strcmp	function
(	O
*	O
try_node	pointer
,	O
"%s"	pointer
)	O
)	O
;	O
free	function
(	O
nodename	pointer
)	O
;	O
if	O
(	O
entry	pointer
)	O
break	O
;	O
}	O
if	O
(	O
!	O
entry	pointer
)	O
break	O
;	O
if	O
(	O
!	O
entry	pointer
->	O
filename	pointer
)	O
entry	pointer
->	O
filename	pointer
=	O
xstrdup	function
(	O
filename	pointer
)	O
;	O
{	O
NODE	struct
*	O
node2	pointer
;	O
node2	pointer
=	O
info_get_node	function
(	O
entry	pointer
->	O
filename	pointer
,	O
entry	pointer
->	O
nodename	pointer
)	O
;	O
if	O
(	O
!	O
node2	pointer
)	O
break	O
;	O
free_history_node	function
(	O
node	pointer
)	O
;	O
node	pointer
=	O
node2	pointer
;	O
}	O
}	O
{	O
char	O
*	O
n	long
=	O
node	pointer
->	O
nodename	pointer
;	O
node	pointer
->	O
nodename	pointer
=	O
0	int
;	O
free_history_node	function
(	O
node	pointer
)	O
;	O
return	O
info_new_reference	function
(	O
filename	pointer
,	O
n	long
)	O
;	O
}	O
}	O
char	O
*	O
program_name_from_file_name	function
(	O
char	O
*	O
file_name	pointer
)	O
{	O
int	O
i	int
;	O
char	O
*	O
program_name	pointer
=	O
xstrdup	function
(	O
filename_non_directory	function
(	O
file_name	pointer
)	O
)	O
;	O
for	O
(	O
i	int
=	O
strlen	function
(	O
program_name	pointer
)	O
-	O
1	int
;	O
i	int
>	O
0	int
;	O
i	int
--	O
)	O
if	O
(	O
program_name	pointer
[	O
i	int
]	O
==	O
'.'	O
&&	O
(	O
FILENAME_CMPN	O
(	O
program_name	pointer
+	O
i	int
,	O
".info"	pointer
,	O
5	int
)	O
==	O
0	int
||	O
FILENAME_CMPN	O
(	O
program_name	pointer
+	O
i	int
,	O
".inf"	pointer
,	O
4	int
)	O
==	O
0	int
||	O
isdigit	function
(	O
program_name	pointer
[	O
i	int
+	O
1	int
]	O
)	O
)	O
)	O
{	O
program_name	pointer
[	O
i	int
]	O
=	O
0	int
;	O
break	O
;	O
}	O
return	O
program_name	pointer
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_goto_invocation_node	function
,	O
_	O
(	O
"Find the node describing program invocation"	pointer
)	O
)	O
{	O
const	O
char	O
*	O
invocation_prompt	pointer
=	O
_	O
(	O
"Find Invocation node of [%s]: "	pointer
)	O
;	O
char	O
*	O
program_name	pointer
,	O
*	O
line	pointer
;	O
char	O
*	O
default_program_name	pointer
,	O
*	O
prompt	pointer
,	O
*	O
file_name	pointer
;	O
NODE	struct
*	O
top_node	pointer
;	O
REFERENCE	struct
*	O
invocation_ref	pointer
;	O
file_name	pointer
=	O
window	pointer
->	O
node	pointer
->	O
fullpath	pointer
;	O
default_program_name	pointer
=	O
program_name_from_file_name	function
(	O
file_name	pointer
)	O
;	O
prompt	pointer
=	O
xmalloc	function
(	O
strlen	function
(	O
default_program_name	pointer
)	O
+	O
strlen	function
(	O
invocation_prompt	pointer
)	O
)	O
;	O
sprintf	function
(	O
prompt	pointer
,	O
invocation_prompt	pointer
,	O
default_program_name	pointer
)	O
;	O
line	pointer
=	O
info_read_in_echo_area	function
(	O
prompt	pointer
)	O
;	O
free	function
(	O
prompt	pointer
)	O
;	O
if	O
(	O
!	O
line	pointer
)	O
{	O
info_abort_key	function
(	O
window	pointer
,	O
0	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
*	O
line	pointer
)	O
program_name	pointer
=	O
line	pointer
;	O
else	O
program_name	pointer
=	O
default_program_name	pointer
;	O
top_node	pointer
=	O
info_get_node	function
(	O
file_name	pointer
,	O
0	int
)	O
;	O
if	O
(	O
!	O
top_node	pointer
)	O
info_error	function
(	O
msg_cant_find_node	pointer
,	O
"Top"	pointer
)	O
;	O
invocation_ref	pointer
=	O
info_intuit_options_node	function
(	O
top_node	pointer
,	O
program_name	pointer
)	O
;	O
if	O
(	O
invocation_ref	pointer
)	O
{	O
info_select_reference	function
(	O
window	pointer
,	O
invocation_ref	pointer
)	O
;	O
info_reference_free	function
(	O
invocation_ref	pointer
)	O
;	O
}	O
free	function
(	O
line	pointer
)	O
;	O
free	function
(	O
default_program_name	pointer
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_man	function
,	O
_	O
(	O
"Read a manpage reference and select it"	pointer
)	O
)	O
{	O
char	O
*	O
line	pointer
;	O
line	pointer
=	O
info_read_in_echo_area	function
(	O
_	O
(	O
"Get Manpage: "	pointer
)	O
)	O
;	O
if	O
(	O
!	O
line	pointer
)	O
{	O
info_abort_key	function
(	O
window	pointer
,	O
0	int
)	O
;	O
return	O
;	O
}	O
canonicalize_whitespace	function
(	O
line	pointer
)	O
;	O
if	O
(	O
*	O
line	pointer
)	O
{	O
NODE	struct
*	O
manpage	pointer
=	O
info_get_node	function
(	O
MANPAGE_FILE_BUFFER_NAME	pointer
,	O
line	pointer
)	O
;	O
if	O
(	O
manpage	pointer
)	O
info_set_node_of_window	function
(	O
window	pointer
,	O
manpage	pointer
)	O
;	O
}	O
free	function
(	O
line	pointer
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_top_node	function
,	O
_	O
(	O
"Select the node 'Top' in this file"	pointer
)	O
)	O
{	O
info_parse_and_select	function
(	O
"Top"	pointer
,	O
window	pointer
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_dir_node	function
,	O
_	O
(	O
"Select the node '(dir)'"	pointer
)	O
)	O
{	O
info_parse_and_select	function
(	O
"(dir)Top"	pointer
,	O
window	pointer
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_display_file_info	function
,	O
_	O
(	O
"Show full file name of node being displayed"	pointer
)	O
)	O
{	O
if	O
(	O
window	pointer
->	O
node	pointer
->	O
fullpath	pointer
&&	O
*	O
window	pointer
->	O
node	pointer
->	O
fullpath	pointer
)	O
{	O
int	O
line	pointer
=	O
window_line_of_point	function
(	O
window	pointer
)	O
;	O
window_message_in_echo_area	function
(	O
"File name: %s, line %d of %ld (%ld%%)"	pointer
,	O
window	pointer
->	O
node	pointer
->	O
subfile	pointer
?	O
window	pointer
->	O
node	pointer
->	O
subfile	pointer
:	O
window	pointer
->	O
node	pointer
->	O
fullpath	pointer
,	O
line	pointer
,	O
window	pointer
->	O
line_count	long
,	O
line	pointer
*	O
100	int
/	O
window	pointer
->	O
line_count	long
)	O
;	O
}	O
else	O
window_message_in_echo_area	function
(	O
"Internal node"	pointer
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_history_node	function
,	O
_	O
(	O
"Select the most recently selected node"	pointer
)	O
)	O
{	O
if	O
(	O
window	pointer
->	O
hist_index	long
>	O
1	int
)	O
forget_node	function
(	O
window	pointer
)	O
;	O
else	O
info_error	function
(	O
_	O
(	O
"No earlier node in history"	pointer
)	O
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_view_file	function
,	O
_	O
(	O
"Read the name of a file and select it"	pointer
)	O
)	O
{	O
char	O
*	O
line	pointer
;	O
line	pointer
=	O
info_read_in_echo_area	function
(	O
_	O
(	O
"Find file: "	pointer
)	O
)	O
;	O
if	O
(	O
!	O
line	pointer
)	O
{	O
info_abort_key	function
(	O
active_window	pointer
,	O
1	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
*	O
line	pointer
)	O
{	O
NODE	struct
*	O
node	pointer
;	O
node	pointer
=	O
info_get_node	function
(	O
line	pointer
,	O
"*"	pointer
)	O
;	O
if	O
(	O
!	O
node	pointer
)	O
{	O
if	O
(	O
info_recent_file_error	pointer
)	O
info_error	function
(	O
"%s"	pointer
,	O
info_recent_file_error	pointer
)	O
;	O
else	O
info_error	function
(	O
_	O
(	O
"Cannot find '%s'"	pointer
)	O
,	O
line	pointer
)	O
;	O
}	O
else	O
info_set_node_of_window	function
(	O
window	pointer
,	O
node	pointer
)	O
;	O
free	function
(	O
line	pointer
)	O
;	O
}	O
}	O
enum	O
{	O
DUMP_SUCCESS	int
,	O
DUMP_INFO_ERROR	int
,	O
DUMP_SYS_ERROR	int
}	O
;	O
static	O
int	O
dump_node_to_stream	function
(	O
char	O
*	O
filename	pointer
,	O
char	O
*	O
nodename	pointer
,	O
FILE	struct
*	O
stream	pointer
,	O
int	O
dump_subnodes	int
)	O
;	O
static	O
void	O
initialize_dumping	function
(	O
void	O
)	O
;	O
void	O
dump_nodes_to_file	function
(	O
REFERENCE	struct
*	O
*	O
references	pointer
,	O
char	O
*	O
output_filename	pointer
,	O
int	O
dump_subnodes	int
)	O
{	O
int	O
i	int
;	O
FILE	struct
*	O
output_stream	pointer
;	O
if	O
(	O
!	O
references	pointer
)	O
return	O
;	O
if	O
(	O
strcmp	function
(	O
output_filename	pointer
,	O
"-"	pointer
)	O
==	O
0	int
)	O
output_stream	pointer
=	O
stdout	pointer
;	O
else	O
output_stream	pointer
=	O
fopen	function
(	O
output_filename	pointer
,	O
"w"	pointer
)	O
;	O
if	O
(	O
!	O
output_stream	pointer
)	O
{	O
info_error	function
(	O
_	O
(	O
"Could not create output file '%s'"	pointer
)	O
,	O
output_filename	pointer
)	O
;	O
return	O
;	O
}	O
initialize_dumping	function
(	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
references	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
dump_node_to_stream	function
(	O
references	pointer
[	O
i	int
]	O
->	O
filename	pointer
,	O
references	pointer
[	O
i	int
]	O
->	O
nodename	pointer
,	O
output_stream	pointer
,	O
dump_subnodes	int
)	O
==	O
DUMP_SYS_ERROR	int
)	O
{	O
info_error	function
(	O
_	O
(	O
"error writing to %s: %s"	pointer
)	O
,	O
output_filename	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
if	O
(	O
output_stream	pointer
!=	O
stdout	pointer
)	O
fclose	function
(	O
output_stream	pointer
)	O
;	O
debug	O
(	O
1	int
,	O
(	O
_	O
(	O
"closing %s"	pointer
)	O
,	O
output_filename	pointer
)	O
)	O
;	O
}	O
static	O
struct	O
info_namelist_entry	O
*	O
dumped_already	pointer
;	O
static	O
void	O
initialize_dumping	function
(	O
void	O
)	O
{	O
info_namelist_free	function
(	O
dumped_already	pointer
)	O
;	O
dumped_already	pointer
=	O
NULL	O
;	O
}	O
static	O
int	O
dump_node_to_stream	function
(	O
char	O
*	O
filename	pointer
,	O
char	O
*	O
nodename	pointer
,	O
FILE	struct
*	O
stream	pointer
,	O
int	O
dump_subnodes	int
)	O
{	O
register	O
int	O
i	int
;	O
NODE	struct
*	O
node	pointer
;	O
node	pointer
=	O
info_get_node	function
(	O
filename	pointer
,	O
nodename	pointer
)	O
;	O
if	O
(	O
!	O
node	pointer
)	O
{	O
if	O
(	O
info_recent_file_error	pointer
)	O
info_error	function
(	O
"%s"	pointer
,	O
info_recent_file_error	pointer
)	O
;	O
else	O
{	O
if	O
(	O
filename	pointer
&&	O
*	O
nodename	pointer
!=	O
'('	O
)	O
info_error	function
(	O
msg_cant_file_node	pointer
,	O
filename_non_directory	function
(	O
filename	pointer
)	O
,	O
nodename	pointer
)	O
;	O
else	O
info_error	function
(	O
msg_cant_find_node	pointer
,	O
nodename	pointer
)	O
;	O
}	O
return	O
DUMP_INFO_ERROR	int
;	O
}	O
if	O
(	O
info_namelist_add	function
(	O
&	O
dumped_already	pointer
,	O
node	pointer
->	O
nodename	pointer
)	O
)	O
{	O
free_history_node	function
(	O
node	pointer
)	O
;	O
return	O
DUMP_SUCCESS	int
;	O
}	O
debug	O
(	O
1	int
,	O
(	O
_	O
(	O
"writing node %s..."	pointer
)	O
,	O
node_printed_rep	function
(	O
node	pointer
)	O
)	O
)	O
;	O
if	O
(	O
write_node_to_stream	function
(	O
node	pointer
,	O
stream	pointer
)	O
)	O
{	O
free_history_node	function
(	O
node	pointer
)	O
;	O
return	O
DUMP_SYS_ERROR	int
;	O
}	O
if	O
(	O
dump_subnodes	int
)	O
{	O
REFERENCE	struct
*	O
*	O
menu	int
=	O
NULL	O
;	O
if	O
(	O
string_in_line	function
(	O
"Index"	pointer
,	O
node	pointer
->	O
nodename	pointer
)	O
==	O
-	O
1	int
)	O
menu	int
=	O
node	pointer
->	O
references	pointer
;	O
if	O
(	O
menu	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
menu	int
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
REFERENCE_MENU_ITEM	int
!=	O
menu	int
[	O
i	int
]	O
->	O
type	enum
)	O
continue	O
;	O
if	O
(	O
!	O
menu	int
[	O
i	int
]	O
->	O
filename	pointer
)	O
if	O
(	O
dump_node_to_stream	function
(	O
filename	pointer
,	O
menu	int
[	O
i	int
]	O
->	O
nodename	pointer
,	O
stream	pointer
,	O
dump_subnodes	int
)	O
==	O
DUMP_SYS_ERROR	int
)	O
{	O
free_history_node	function
(	O
node	pointer
)	O
;	O
return	O
DUMP_SYS_ERROR	int
;	O
}	O
}	O
}	O
}	O
free_history_node	function
(	O
node	pointer
)	O
;	O
return	O
DUMP_SUCCESS	int
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_print_node	function
,	O
_	O
(	O
"Pipe the contents of this node through INFO_PRINT_COMMAND"	pointer
)	O
)	O
{	O
FILE	struct
*	O
printer_pipe	pointer
;	O
char	O
*	O
print_command	pointer
=	O
getenv	function
(	O
"INFO_PRINT_COMMAND"	pointer
)	O
;	O
int	O
piping	int
=	O
0	int
;	O
if	O
(	O
!	O
print_command	pointer
||	O
!	O
*	O
print_command	pointer
)	O
print_command	pointer
=	O
DEFAULT_INFO_PRINT_COMMAND	pointer
;	O
if	O
(	O
*	O
print_command	pointer
==	O
'>'	O
)	O
printer_pipe	pointer
=	O
fopen	function
(	O
++	O
print_command	pointer
,	O
"w"	pointer
)	O
;	O
else	O
{	O
printer_pipe	pointer
=	O
popen	function
(	O
print_command	pointer
,	O
"w"	pointer
)	O
;	O
piping	int
=	O
1	int
;	O
}	O
if	O
(	O
!	O
printer_pipe	pointer
)	O
{	O
info_error	function
(	O
_	O
(	O
"Cannot open pipe to '%s'"	pointer
)	O
,	O
print_command	pointer
)	O
;	O
return	O
;	O
}	O
debug	O
(	O
1	int
,	O
(	O
_	O
(	O
"printing node %s..."	pointer
)	O
,	O
node_printed_rep	function
(	O
window	pointer
->	O
node	pointer
)	O
)	O
)	O
;	O
write_node_to_stream	function
(	O
window	pointer
->	O
node	pointer
,	O
printer_pipe	pointer
)	O
;	O
if	O
(	O
piping	int
)	O
pclose	function
(	O
printer_pipe	pointer
)	O
;	O
else	O
fclose	function
(	O
printer_pipe	pointer
)	O
;	O
debug	O
(	O
1	int
,	O
(	O
_	O
(	O
"finished printing node %s"	pointer
)	O
,	O
node_printed_rep	function
(	O
window	pointer
->	O
node	pointer
)	O
)	O
)	O
;	O
}	O
int	O
write_node_to_stream	function
(	O
NODE	struct
*	O
node	pointer
,	O
FILE	struct
*	O
stream	pointer
)	O
{	O
return	O
fwrite	function
(	O
node	pointer
->	O
contents	pointer
,	O
node	pointer
->	O
nodelen	long
,	O
1	int
,	O
stream	pointer
)	O
!=	O
1	int
;	O
}	O
int	O
gc_compressed_files	int
=	O
0	int
;	O
static	O
char	O
*	O
search_string	pointer
=	O
NULL	O
;	O
static	O
int	O
isearch_is_active	int
=	O
0	int
;	O
static	O
int	O
last_search_direction	int
=	O
0	int
;	O
static	O
int	O
last_search_case_sensitive	int
=	O
0	int
;	O
static	O
int	O
use_regex	int
=	O
1	int
;	O
DECLARE_INFO_COMMAND	O
(	O
info_toggle_regexp	function
,	O
_	O
(	O
"Toggle the usage of regular expressions in searches"	pointer
)	O
)	O
{	O
use_regex	int
=	O
!	O
use_regex	int
;	O
window_message_in_echo_area	function
(	O
use_regex	int
?	O
_	O
(	O
"Using regular expressions for searches"	pointer
)	O
:	O
_	O
(	O
"Using literal strings for searches"	pointer
)	O
)	O
;	O
}	O
static	O
enum	O
search_result	enum
info_search_in_node_internal	function
(	O
WINDOW	struct
*	O
window	pointer
,	O
NODE	struct
*	O
node	pointer
,	O
char	O
*	O
string	pointer
,	O
long	O
start	int
,	O
int	O
dir	int
,	O
int	O
case_sensitive	int
,	O
int	O
match_regexp	int
,	O
long	O
*	O
poff	pointer
)	O
{	O
enum	O
search_result	enum
result	enum
=	O
search_not_found	int
;	O
long	O
start1	long
,	O
end1	long
;	O
int	O
match_index	pointer
;	O
long	O
new_point	long
;	O
MATCH_STATE	struct
matches	pointer
;	O
if	O
(	O
!	O
matches_ready	function
(	O
&	O
window	pointer
->	O
matches	pointer
)	O
||	O
strcmp	function
(	O
window	pointer
->	O
search_string	pointer
,	O
string	pointer
)	O
||	O
window	pointer
->	O
search_is_case_sensitive	int
!=	O
case_sensitive	int
)	O
{	O
free_matches	function
(	O
&	O
window	pointer
->	O
matches	pointer
)	O
;	O
free	function
(	O
window	pointer
->	O
search_string	pointer
)	O
;	O
window	pointer
->	O
search_string	pointer
=	O
xstrdup	function
(	O
string	pointer
)	O
;	O
window	pointer
->	O
search_is_case_sensitive	int
=	O
case_sensitive	int
;	O
result	enum
=	O
regexp_search	function
(	O
string	pointer
,	O
!	O
match_regexp	int
,	O
!	O
case_sensitive	int
,	O
node	pointer
->	O
contents	pointer
,	O
node	pointer
->	O
nodelen	long
,	O
&	O
matches	pointer
)	O
;	O
}	O
else	O
{	O
matches	pointer
=	O
window	pointer
->	O
matches	pointer
;	O
result	enum
=	O
search_success	int
;	O
}	O
if	O
(	O
result	enum
!=	O
search_success	int
)	O
return	O
result	enum
;	O
if	O
(	O
node	pointer
->	O
flags	int
&	O
N_Simple	int
)	O
{	O
enum	O
search_result	enum
subresult	enum
;	O
NODE	struct
*	O
full_node	pointer
;	O
free_matches	function
(	O
&	O
matches	pointer
)	O
;	O
full_node	pointer
=	O
info_get_node	function
(	O
node	pointer
->	O
fullpath	pointer
,	O
node	pointer
->	O
nodename	pointer
)	O
;	O
subresult	enum
=	O
info_search_in_node_internal	function
(	O
window	pointer
,	O
full_node	pointer
,	O
string	pointer
,	O
start	int
,	O
dir	int
,	O
case_sensitive	int
,	O
match_regexp	int
,	O
poff	pointer
)	O
;	O
if	O
(	O
window	pointer
->	O
node	pointer
!=	O
full_node	pointer
)	O
free	function
(	O
full_node	pointer
)	O
;	O
return	O
subresult	enum
;	O
}	O
if	O
(	O
dir	int
>	O
0	int
)	O
{	O
start1	long
=	O
start	int
;	O
end1	long
=	O
node	pointer
->	O
nodelen	long
;	O
}	O
else	O
{	O
start1	long
=	O
0	int
;	O
end1	long
=	O
start	int
+	O
1	int
;	O
}	O
if	O
(	O
start1	long
<	O
node	pointer
->	O
body_start	long
)	O
start1	long
=	O
node	pointer
->	O
body_start	long
;	O
if	O
(	O
end1	long
<	O
node	pointer
->	O
body_start	long
)	O
end1	long
=	O
node	pointer
->	O
body_start	long
;	O
result	enum
=	O
match_in_match_list	function
(	O
&	O
matches	pointer
,	O
start1	long
,	O
end1	long
,	O
dir	int
,	O
&	O
match_index	pointer
)	O
;	O
if	O
(	O
result	enum
!=	O
search_success	int
)	O
return	O
result	enum
;	O
*	O
poff	pointer
=	O
match_by_index	function
(	O
&	O
matches	pointer
,	O
match_index	pointer
)	O
.	O
rm_so	long
;	O
window	pointer
->	O
flags	int
|=	O
W_UpdateWindow	int
;	O
if	O
(	O
window	pointer
->	O
node	pointer
!=	O
node	pointer
)	O
info_set_node_of_window	function
(	O
window	pointer
,	O
node	pointer
)	O
;	O
window	pointer
->	O
matches	pointer
=	O
matches	pointer
;	O
if	O
(	O
isearch_is_active	int
&&	O
dir	int
>	O
0	int
)	O
new_point	long
=	O
match_by_index	function
(	O
&	O
matches	pointer
,	O
match_index	pointer
)	O
.	O
rm_eo	long
;	O
else	O
new_point	long
=	O
match_by_index	function
(	O
&	O
matches	pointer
,	O
match_index	pointer
)	O
.	O
rm_so	long
;	O
window	pointer
->	O
point	long
=	O
new_point	long
;	O
return	O
result	enum
;	O
}	O
static	O
int	O
info_search_internal	function
(	O
char	O
*	O
string	pointer
,	O
WINDOW	struct
*	O
window	pointer
,	O
int	O
dir	int
,	O
int	O
case_sensitive	int
,	O
long	O
*	O
start_off	pointer
)	O
{	O
register	O
int	O
i	int
;	O
FILE_BUFFER	struct
*	O
file_buffer	pointer
;	O
long	O
start	int
;	O
enum	O
search_result	enum
result	enum
;	O
int	O
search_other_nodes	int
=	O
1	int
;	O
int	O
number_of_tags	int
=	O
-	O
1	int
,	O
starting_tag	int
=	O
-	O
1	int
,	O
current_tag	int
=	O
-	O
1	int
;	O
NODE	struct
*	O
node	pointer
=	O
window	pointer
->	O
node	pointer
;	O
char	O
*	O
subfile_name	pointer
=	O
0	int
;	O
TAG	struct
*	O
tag	pointer
;	O
char	O
*	O
msg	pointer
=	O
0	int
;	O
int	O
first_time	int
=	O
1	int
;	O
file_buffer	pointer
=	O
file_buffer_of_window	function
(	O
window	pointer
)	O
;	O
if	O
(	O
!	O
file_buffer	pointer
||	O
!	O
file_buffer	pointer
->	O
tags	pointer
||	O
!	O
strcmp	function
(	O
window	pointer
->	O
node	pointer
->	O
nodename	pointer
,	O
"*"	pointer
)	O
)	O
search_other_nodes	int
=	O
0	int
;	O
if	O
(	O
search_other_nodes	int
)	O
{	O
char	O
*	O
initial_nodename	pointer
=	O
window	pointer
->	O
node	pointer
->	O
nodename	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
file_buffer	pointer
->	O
tags	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
if	O
(	O
strcmp	function
(	O
initial_nodename	pointer
,	O
file_buffer	pointer
->	O
tags	pointer
[	O
i	int
]	O
->	O
nodename	pointer
)	O
==	O
0	int
)	O
{	O
starting_tag	int
=	O
i	int
;	O
subfile_name	pointer
=	O
file_buffer	pointer
->	O
tags	pointer
[	O
i	int
]	O
->	O
filename	pointer
;	O
}	O
number_of_tags	int
=	O
i	int
;	O
if	O
(	O
starting_tag	int
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
current_tag	int
=	O
starting_tag	int
;	O
}	O
start	int
=	O
*	O
start_off	pointer
;	O
while	O
(	O
1	int
)	O
{	O
result	enum
=	O
info_search_in_node_internal	function
(	O
window	pointer
,	O
node	pointer
,	O
string	pointer
,	O
start	int
,	O
dir	int
,	O
case_sensitive	int
,	O
use_regex	int
,	O
start_off	pointer
)	O
;	O
if	O
(	O
node	pointer
!=	O
window	pointer
->	O
node	pointer
)	O
free_history_node	function
(	O
node	pointer
)	O
;	O
if	O
(	O
result	enum
==	O
search_invalid	int
)	O
return	O
1	int
;	O
if	O
(	O
result	enum
==	O
search_success	int
)	O
{	O
if	O
(	O
!	O
echo_area_is_active	int
)	O
{	O
if	O
(	O
msg	pointer
)	O
window_message_in_echo_area	function
(	O
"%s"	pointer
,	O
_	O
(	O
msg	pointer
)	O
)	O
;	O
else	O
window_clear_echo_area	function
(	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
search_other_nodes	int
)	O
break	O
;	O
search_next_node	O
:	O
if	O
(	O
current_tag	int
==	O
starting_tag	int
&&	O
!	O
first_time	int
)	O
break	O
;	O
first_time	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
current_tag	int
+	O
dir	int
;	O
;	O
i	int
+=	O
dir	int
)	O
{	O
if	O
(	O
i	int
<	O
0	int
)	O
{	O
msg	pointer
=	O
N_	O
(	O
"Search continued from the end of the document"	pointer
)	O
;	O
i	int
=	O
number_of_tags	int
-	O
1	int
;	O
}	O
else	O
if	O
(	O
i	int
==	O
number_of_tags	int
)	O
{	O
msg	pointer
=	O
N_	O
(	O
"Search continued from the beginning of the document"	pointer
)	O
;	O
i	int
=	O
0	int
;	O
}	O
tag	pointer
=	O
file_buffer	pointer
->	O
tags	pointer
[	O
i	int
]	O
;	O
if	O
(	O
tag	pointer
->	O
cache	struct
.	O
nodelen	long
!=	O
0	int
)	O
break	O
;	O
}	O
current_tag	int
=	O
i	int
;	O
if	O
(	O
!	O
echo_area_is_active	int
&&	O
tag	pointer
->	O
filename	pointer
!=	O
subfile_name	pointer
)	O
{	O
subfile_name	pointer
=	O
tag	pointer
->	O
filename	pointer
;	O
window_message_in_echo_area	function
(	O
_	O
(	O
"Searching subfile %s ..."	pointer
)	O
,	O
filename_non_directory	function
(	O
subfile_name	pointer
)	O
)	O
;	O
}	O
free_matches	function
(	O
&	O
window	pointer
->	O
matches	pointer
)	O
;	O
node	pointer
=	O
info_node_of_tag_fast	function
(	O
file_buffer	pointer
,	O
&	O
tag	pointer
)	O
;	O
if	O
(	O
!	O
node	pointer
)	O
{	O
if	O
(	O
!	O
echo_area_is_active	int
)	O
{	O
if	O
(	O
info_recent_file_error	pointer
)	O
{	O
info_error	function
(	O
"%s"	pointer
,	O
info_recent_file_error	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
info_error	function
(	O
msg_cant_file_node	pointer
,	O
filename_non_directory	function
(	O
file_buffer	pointer
->	O
filename	pointer
)	O
,	O
tag	pointer
->	O
nodename	pointer
)	O
;	O
goto	O
search_next_node	O
;	O
}	O
}	O
}	O
if	O
(	O
dir	int
<	O
0	int
)	O
start	int
=	O
tag	pointer
->	O
cache	struct
.	O
nodelen	long
;	O
else	O
start	int
=	O
0	int
;	O
fill_input_buffer	function
(	O
0	int
)	O
;	O
if	O
(	O
info_input_buffer	array
[	O
pop_index	int
]	O
==	O
Control	O
(	O
'g'	O
)	O
)	O
goto	O
funexit	O
;	O
}	O
if	O
(	O
!	O
echo_area_is_active	int
)	O
info_error	function
(	O
"%s"	pointer
,	O
_	O
(	O
"Search failed"	pointer
)	O
)	O
;	O
funexit	O
:	O
return	O
-	O
1	int
;	O
}	O
int	O
min_search_length	int
=	O
1	int
;	O
static	O
int	O
ask_for_search_string	function
(	O
int	O
case_sensitive	int
,	O
int	O
use_regex	int
,	O
int	O
direction	int
)	O
{	O
char	O
*	O
line	pointer
,	O
*	O
prompt	pointer
;	O
if	O
(	O
search_string	pointer
)	O
asprintf	function
(	O
&	O
prompt	pointer
,	O
_	O
(	O
"%s%s%s [%s]: "	pointer
)	O
,	O
use_regex	int
?	O
_	O
(	O
"Regexp search"	pointer
)	O
:	O
_	O
(	O
"Search"	pointer
)	O
,	O
case_sensitive	int
?	O
_	O
(	O
" case-sensitively"	pointer
)	O
:	O
""	pointer
,	O
direction	int
<	O
0	int
?	O
_	O
(	O
" backward"	pointer
)	O
:	O
""	pointer
,	O
search_string	pointer
)	O
;	O
else	O
asprintf	function
(	O
&	O
prompt	pointer
,	O
_	O
(	O
"%s%s%s: "	pointer
)	O
,	O
use_regex	int
?	O
_	O
(	O
"Regexp search"	pointer
)	O
:	O
_	O
(	O
"Search"	pointer
)	O
,	O
case_sensitive	int
?	O
_	O
(	O
" case-sensitively"	pointer
)	O
:	O
""	pointer
,	O
direction	int
<	O
0	int
?	O
_	O
(	O
" backward"	pointer
)	O
:	O
""	pointer
)	O
;	O
line	pointer
=	O
info_read_in_echo_area	function
(	O
prompt	pointer
)	O
;	O
free	function
(	O
prompt	pointer
)	O
;	O
if	O
(	O
!	O
line	pointer
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
*	O
line	pointer
)	O
{	O
free	function
(	O
line	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
mbslen	function
(	O
line	pointer
)	O
<	O
min_search_length	int
)	O
{	O
info_error	function
(	O
"%s"	pointer
,	O
_	O
(	O
"Search string too short"	pointer
)	O
)	O
;	O
free	function
(	O
line	pointer
)	O
;	O
return	O
1	int
;	O
}	O
free	function
(	O
search_string	pointer
)	O
;	O
search_string	pointer
=	O
line	pointer
;	O
return	O
1	int
;	O
}	O
static	O
void	O
info_search_1	function
(	O
WINDOW	struct
*	O
window	pointer
,	O
int	O
count	pointer
,	O
int	O
case_sensitive	int
)	O
{	O
int	O
result	enum
;	O
int	O
direction	int
;	O
long	O
start_off	pointer
;	O
char	O
*	O
p	pointer
;	O
if	O
(	O
count	pointer
<	O
0	int
)	O
{	O
direction	int
=	O
-	O
1	int
;	O
count	pointer
=	O
-	O
count	pointer
;	O
}	O
else	O
{	O
direction	int
=	O
1	int
;	O
if	O
(	O
count	pointer
==	O
0	int
)	O
count	pointer
=	O
1	int
;	O
}	O
if	O
(	O
!	O
ask_for_search_string	function
(	O
case_sensitive	int
,	O
use_regex	int
,	O
direction	int
)	O
||	O
!	O
search_string	pointer
)	O
return	O
;	O
window	pointer
->	O
node	pointer
->	O
active_menu	int
=	O
0	int
;	O
start_off	pointer
=	O
window	pointer
->	O
point	long
+	O
direction	int
;	O
if	O
(	O
case_sensitive	int
==	O
0	int
)	O
for	O
(	O
p	pointer
=	O
search_string	pointer
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
if	O
(	O
isupper	function
(	O
*	O
p	pointer
)	O
)	O
{	O
case_sensitive	int
=	O
1	int
;	O
break	O
;	O
}	O
last_search_direction	int
=	O
direction	int
;	O
last_search_case_sensitive	int
=	O
case_sensitive	int
;	O
for	O
(	O
result	enum
=	O
0	int
;	O
result	enum
==	O
0	int
&&	O
count	pointer
--	O
;	O
)	O
result	enum
=	O
info_search_internal	function
(	O
search_string	pointer
,	O
active_window	pointer
,	O
direction	int
,	O
case_sensitive	int
,	O
&	O
start_off	pointer
)	O
;	O
window_adjust_pagetop	function
(	O
window	pointer
)	O
;	O
gc_file_buffers_and_nodes	function
(	O
)	O
;	O
}	O
static	O
int	O
tag_of_reference	function
(	O
REFERENCE	struct
*	O
r	pointer
,	O
WINDOW	struct
*	O
window	pointer
,	O
FILE_BUFFER	struct
*	O
*	O
fb	pointer
,	O
TAG	struct
*	O
*	O
*	O
t	pointer
)	O
{	O
char	O
*	O
filename	pointer
,	O
*	O
nodename	pointer
;	O
int	O
i	int
;	O
filename	pointer
=	O
r	pointer
->	O
filename	pointer
;	O
nodename	pointer
=	O
r	pointer
->	O
nodename	pointer
;	O
if	O
(	O
!	O
filename	pointer
)	O
filename	pointer
=	O
window	pointer
->	O
node	pointer
->	O
fullpath	pointer
;	O
if	O
(	O
!	O
nodename	pointer
||	O
!	O
*	O
nodename	pointer
)	O
nodename	pointer
=	O
"Top"	pointer
;	O
*	O
fb	pointer
=	O
info_find_file	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
!	O
*	O
fb	pointer
)	O
return	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
*	O
(	O
*	O
t	pointer
=	O
&	O
(	O
*	O
fb	pointer
)	O
->	O
tags	pointer
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
if	O
(	O
!	O
strcmp	function
(	O
nodename	pointer
,	O
(	O
*	O
*	O
t	pointer
)	O
->	O
nodename	pointer
)	O
)	O
goto	O
found_tag	O
;	O
return	O
0	int
;	O
found_tag	O
:	O
;	O
return	O
1	int
;	O
}	O
static	O
void	O
tree_search_check_node	function
(	O
WINDOW	struct
*	O
window	pointer
)	O
;	O
static	O
void	O
tree_search_check_node_backwards	function
(	O
WINDOW	struct
*	O
window	pointer
)	O
;	O
static	O
void	O
tree_search_check_node	function
(	O
WINDOW	struct
*	O
window	pointer
)	O
{	O
long	O
start_off	pointer
;	O
enum	O
search_result	enum
result	enum
;	O
char	O
*	O
string	pointer
;	O
int	O
previous_match	int
;	O
if	O
(	O
window	pointer
->	O
node	pointer
->	O
active_menu	int
!=	O
0	int
)	O
previous_match	int
=	O
1	int
;	O
else	O
{	O
previous_match	int
=	O
0	int
;	O
window	pointer
->	O
node	pointer
->	O
active_menu	int
=	O
BEFORE_MENU	O
;	O
}	O
string	pointer
=	O
xstrdup	function
(	O
window	pointer
->	O
search_string	pointer
)	O
;	O
goto	O
check_node	O
;	O
check_node	O
:	O
result	enum
=	O
info_search_in_node_internal	function
(	O
window	pointer
,	O
window	pointer
->	O
node	pointer
,	O
string	pointer
,	O
window	pointer
->	O
point	long
+	O
1	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
&	O
start_off	pointer
)	O
;	O
if	O
(	O
result	enum
==	O
search_success	int
)	O
{	O
info_show_point	function
(	O
window	pointer
)	O
;	O
goto	O
funexit	O
;	O
}	O
if	O
(	O
matches_ready	function
(	O
&	O
window	pointer
->	O
matches	pointer
)	O
)	O
window	pointer
->	O
point	long
++	O
;	O
goto	O
check_menus	O
;	O
check_menus	O
:	O
if	O
(	O
!	O
(	O
window	pointer
->	O
node	pointer
->	O
flags	int
&	O
N_IsIndex	int
)	O
)	O
{	O
REFERENCE	struct
*	O
r	pointer
;	O
int	O
ref_index	int
;	O
if	O
(	O
window	pointer
->	O
node	pointer
->	O
active_menu	int
!=	O
BEFORE_MENU	O
)	O
ref_index	int
=	O
window	pointer
->	O
node	pointer
->	O
active_menu	int
;	O
else	O
ref_index	int
=	O
0	int
;	O
for	O
(	O
;	O
(	O
r	pointer
=	O
window	pointer
->	O
node	pointer
->	O
references	pointer
[	O
ref_index	int
]	O
)	O
;	O
ref_index	int
++	O
)	O
if	O
(	O
r	pointer
->	O
type	enum
==	O
REFERENCE_MENU_ITEM	int
)	O
{	O
FILE_BUFFER	struct
*	O
file_buffer	pointer
;	O
TAG	struct
*	O
*	O
tag	pointer
;	O
NODE	struct
*	O
node	pointer
;	O
if	O
(	O
!	O
tag_of_reference	function
(	O
r	pointer
,	O
window	pointer
,	O
&	O
file_buffer	pointer
,	O
&	O
tag	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
(	O
*	O
tag	pointer
)	O
->	O
flags	int
&	O
N_SeenBySearch	int
)	O
continue	O
;	O
(	O
*	O
tag	pointer
)	O
->	O
flags	int
|=	O
N_SeenBySearch	int
;	O
window	pointer
->	O
node	pointer
->	O
active_menu	int
=	O
ref_index	int
+	O
1	int
;	O
node	pointer
=	O
info_node_of_tag	function
(	O
file_buffer	pointer
,	O
tag	pointer
)	O
;	O
if	O
(	O
!	O
node	pointer
)	O
continue	O
;	O
info_set_node_of_window_fast	function
(	O
window	pointer
,	O
node	pointer
)	O
;	O
window	pointer
->	O
node	pointer
->	O
active_menu	int
=	O
BEFORE_MENU	O
;	O
goto	O
check_node	O
;	O
}	O
}	O
goto	O
go_up	O
;	O
go_up	O
:	O
if	O
(	O
window	pointer
->	O
hist_index	long
>=	O
2	int
&&	O
window	pointer
->	O
hist	pointer
[	O
window	pointer
->	O
hist_index	long
-	O
2	int
]	O
->	O
node	pointer
->	O
active_menu	int
!=	O
0	int
)	O
{	O
forget_node_fast	function
(	O
window	pointer
)	O
;	O
goto	O
check_menus	O
;	O
}	O
if	O
(	O
previous_match	int
)	O
{	O
message_in_echo_area	function
(	O
_	O
(	O
"Going back to last match from %s"	pointer
)	O
,	O
window	pointer
->	O
node	pointer
->	O
nodename	pointer
)	O
;	O
{	O
int	O
n	long
=	O
0	int
;	O
while	O
(	O
window	pointer
->	O
node	pointer
->	O
references	pointer
[	O
n	long
]	O
)	O
n	long
++	O
;	O
window	pointer
->	O
node	pointer
->	O
active_menu	int
=	O
n	long
+	O
1	int
;	O
info_parse_and_select	function
(	O
"Top"	pointer
,	O
window	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
window	pointer
->	O
node	pointer
->	O
nodename	pointer
,	O
"Top"	pointer
)	O
)	O
{	O
window	pointer
->	O
node	pointer
->	O
active_menu	int
=	O
0	int
;	O
goto	O
funexit	O
;	O
}	O
window	pointer
->	O
node	pointer
->	O
active_menu	int
=	O
BEFORE_MENU	O
;	O
}	O
window	pointer
->	O
point	long
=	O
window	pointer
->	O
node	pointer
->	O
body_start	long
;	O
tree_search_check_node_backwards	function
(	O
window	pointer
)	O
;	O
}	O
info_error	function
(	O
previous_match	int
?	O
_	O
(	O
"No more matches"	pointer
)	O
:	O
_	O
(	O
"Search failed"	pointer
)	O
)	O
;	O
funexit	O
:	O
free	function
(	O
string	pointer
)	O
;	O
}	O
static	O
void	O
tree_search_check_node_backwards	function
(	O
WINDOW	struct
*	O
window	pointer
)	O
{	O
long	O
start_off	pointer
;	O
enum	O
search_result	enum
result	enum
;	O
char	O
*	O
string	pointer
;	O
int	O
previous_match	int
;	O
previous_match	int
=	O
(	O
window	pointer
->	O
node	pointer
->	O
active_menu	int
!=	O
0	int
)	O
;	O
string	pointer
=	O
xstrdup	function
(	O
window	pointer
->	O
search_string	pointer
)	O
;	O
goto	O
check_node	O
;	O
check_node	O
:	O
result	enum
=	O
info_search_in_node_internal	function
(	O
window	pointer
,	O
window	pointer
->	O
node	pointer
,	O
string	pointer
,	O
window	pointer
->	O
point	long
-	O
1	int
,	O
-	O
1	int
,	O
1	int
,	O
0	int
,	O
&	O
start_off	pointer
)	O
;	O
if	O
(	O
result	enum
==	O
search_success	int
)	O
{	O
info_show_point	function
(	O
window	pointer
)	O
;	O
goto	O
funexit	O
;	O
}	O
goto	O
go_up	O
;	O
check_menus	O
:	O
if	O
(	O
!	O
(	O
window	pointer
->	O
node	pointer
->	O
flags	int
&	O
N_IsIndex	int
)	O
)	O
{	O
REFERENCE	struct
*	O
r	pointer
;	O
int	O
ref_index	int
;	O
if	O
(	O
window	pointer
->	O
node	pointer
->	O
active_menu	int
==	O
BEFORE_MENU	O
)	O
goto	O
check_node	O
;	O
else	O
ref_index	int
=	O
window	pointer
->	O
node	pointer
->	O
active_menu	int
-	O
2	int
;	O
for	O
(	O
;	O
ref_index	int
>=	O
0	int
;	O
ref_index	int
--	O
)	O
{	O
r	pointer
=	O
window	pointer
->	O
node	pointer
->	O
references	pointer
[	O
ref_index	int
]	O
;	O
if	O
(	O
r	pointer
->	O
type	enum
==	O
REFERENCE_MENU_ITEM	int
)	O
{	O
TAG	struct
*	O
*	O
tag	pointer
;	O
FILE_BUFFER	struct
*	O
file_buffer	pointer
;	O
NODE	struct
*	O
node	pointer
;	O
if	O
(	O
!	O
tag_of_reference	function
(	O
r	pointer
,	O
window	pointer
,	O
&	O
file_buffer	pointer
,	O
&	O
tag	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
!	O
(	O
(	O
*	O
tag	pointer
)	O
->	O
flags	int
&	O
N_SeenBySearch	int
)	O
)	O
continue	O
;	O
node	pointer
=	O
info_node_of_tag	function
(	O
file_buffer	pointer
,	O
tag	pointer
)	O
;	O
if	O
(	O
!	O
node	pointer
)	O
continue	O
;	O
window	pointer
->	O
node	pointer
->	O
active_menu	int
=	O
ref_index	int
+	O
1	int
;	O
info_set_node_of_window_fast	function
(	O
window	pointer
,	O
node	pointer
)	O
;	O
window	pointer
->	O
point	long
=	O
window	pointer
->	O
node	pointer
->	O
nodelen	long
;	O
{	O
int	O
i	int
;	O
i	int
=	O
0	int
;	O
while	O
(	O
window	pointer
->	O
node	pointer
->	O
references	pointer
[	O
i	int
]	O
)	O
i	int
++	O
;	O
window	pointer
->	O
node	pointer
->	O
active_menu	int
=	O
i	int
+	O
1	int
;	O
}	O
goto	O
check_menus	O
;	O
}	O
}	O
}	O
window	pointer
->	O
node	pointer
->	O
active_menu	int
=	O
BEFORE_MENU	O
;	O
goto	O
check_node	O
;	O
go_up	O
:	O
if	O
(	O
window	pointer
->	O
hist_index	long
>=	O
2	int
&&	O
window	pointer
->	O
hist	pointer
[	O
window	pointer
->	O
hist_index	long
-	O
2	int
]	O
->	O
node	pointer
->	O
active_menu	int
!=	O
0	int
)	O
{	O
TAG	struct
*	O
*	O
tag	pointer
;	O
REFERENCE	struct
*	O
r	pointer
;	O
FILE_BUFFER	struct
*	O
file_buffer	pointer
;	O
forget_node_fast	function
(	O
window	pointer
)	O
;	O
r	pointer
=	O
window	pointer
->	O
node	pointer
->	O
references	pointer
[	O
window	pointer
->	O
node	pointer
->	O
active_menu	int
-	O
1	int
]	O
;	O
if	O
(	O
r	pointer
&&	O
tag_of_reference	function
(	O
r	pointer
,	O
window	pointer
,	O
&	O
file_buffer	pointer
,	O
&	O
tag	pointer
)	O
)	O
{	O
(	O
*	O
tag	pointer
)	O
->	O
flags	int
&=	O
~	O
N_SeenBySearch	int
;	O
}	O
goto	O
check_menus	O
;	O
}	O
info_error	function
(	O
previous_match	int
?	O
_	O
(	O
"No more matches"	pointer
)	O
:	O
_	O
(	O
"Search failed"	pointer
)	O
)	O
;	O
funexit	O
:	O
free	function
(	O
string	pointer
)	O
;	O
}	O
void	O
wipe_seen_flags	function
(	O
void	O
)	O
{	O
int	O
fb_index	int
;	O
TAG	struct
*	O
*	O
t	pointer
;	O
for	O
(	O
fb_index	int
=	O
0	int
;	O
fb_index	int
<	O
info_loaded_files_index	long
;	O
fb_index	int
++	O
)	O
{	O
t	pointer
=	O
info_loaded_files	pointer
[	O
fb_index	int
]	O
->	O
tags	pointer
;	O
if	O
(	O
!	O
t	pointer
)	O
continue	O
;	O
for	O
(	O
;	O
*	O
t	pointer
;	O
t	pointer
++	O
)	O
{	O
(	O
*	O
t	pointer
)	O
->	O
flags	int
&=	O
~	O
N_SeenBySearch	int
;	O
}	O
}	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_tree_search	function
,	O
_	O
(	O
"Search this node and subnodes for a string"	pointer
)	O
)	O
{	O
char	O
*	O
prompt	pointer
,	O
*	O
line	pointer
;	O
int	O
i	int
;	O
asprintf	function
(	O
&	O
prompt	pointer
,	O
_	O
(	O
"Search under %s: "	pointer
)	O
,	O
window	pointer
->	O
node	pointer
->	O
nodename	pointer
)	O
;	O
line	pointer
=	O
info_read_in_echo_area	function
(	O
prompt	pointer
)	O
;	O
free	function
(	O
prompt	pointer
)	O
;	O
if	O
(	O
!	O
line	pointer
)	O
return	O
;	O
wipe_seen_flags	function
(	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
window	pointer
->	O
hist_index	long
;	O
i	int
++	O
)	O
window	pointer
->	O
hist	pointer
[	O
i	int
]	O
->	O
node	pointer
->	O
active_menu	int
=	O
0	int
;	O
window	pointer
->	O
search_string	pointer
=	O
line	pointer
;	O
tree_search_check_node	function
(	O
window	pointer
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_tree_search_next	function
,	O
_	O
(	O
"Go to next match in Info sub-tree"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
window	pointer
->	O
search_string	pointer
||	O
window	pointer
->	O
node	pointer
->	O
active_menu	int
==	O
0	int
)	O
{	O
info_error	function
(	O
_	O
(	O
"No active search"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
tree_search_check_node	function
(	O
window	pointer
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_tree_search_previous	function
,	O
_	O
(	O
"Go to previous match in Info sub-tree"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
window	pointer
->	O
search_string	pointer
||	O
window	pointer
->	O
node	pointer
->	O
active_menu	int
==	O
0	int
)	O
{	O
info_error	function
(	O
_	O
(	O
"No active search"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
tree_search_check_node_backwards	function
(	O
window	pointer
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_search_case_sensitively	function
,	O
_	O
(	O
"Read a string and search for it case-sensitively"	pointer
)	O
)	O
{	O
info_search_1	function
(	O
window	pointer
,	O
count	pointer
,	O
1	int
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_search	function
,	O
_	O
(	O
"Read a string and search for it"	pointer
)	O
)	O
{	O
info_search_1	function
(	O
window	pointer
,	O
count	pointer
,	O
0	int
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_search_backward	function
,	O
_	O
(	O
"Read a string and search backward for it"	pointer
)	O
)	O
{	O
info_search_1	function
(	O
window	pointer
,	O
-	O
count	pointer
,	O
0	int
)	O
;	O
}	O
int	O
search_skip_screen_p	int
=	O
0	int
;	O
DECLARE_INFO_COMMAND	O
(	O
info_search_next	function
,	O
_	O
(	O
"Repeat last search in the same direction"	pointer
)	O
)	O
{	O
long	O
start_off	pointer
=	O
window	pointer
->	O
point	long
+	O
1	int
;	O
NODE	struct
*	O
starting_node	pointer
=	O
window	pointer
->	O
node	pointer
;	O
int	O
result	enum
;	O
if	O
(	O
window	pointer
->	O
search_string	pointer
&&	O
window	pointer
->	O
node	pointer
->	O
active_menu	int
)	O
{	O
tree_search_check_node	function
(	O
window	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
last_search_direction	int
||	O
!	O
search_string	pointer
)	O
{	O
info_error	function
(	O
"%s"	pointer
,	O
_	O
(	O
"No previous search string"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
search_skip_screen_p	int
)	O
{	O
long	O
n	long
=	O
window	pointer
->	O
height	long
+	O
window	pointer
->	O
pagetop	long
;	O
if	O
(	O
n	long
<	O
window	pointer
->	O
line_count	long
)	O
start_off	pointer
=	O
window	pointer
->	O
line_starts	pointer
[	O
n	long
]	O
;	O
else	O
start_off	pointer
=	O
window	pointer
->	O
node	pointer
->	O
nodelen	long
;	O
}	O
for	O
(	O
result	enum
=	O
0	int
;	O
result	enum
==	O
0	int
&&	O
count	pointer
--	O
;	O
)	O
result	enum
=	O
info_search_internal	function
(	O
search_string	pointer
,	O
active_window	pointer
,	O
1	int
,	O
last_search_case_sensitive	int
,	O
&	O
start_off	pointer
)	O
;	O
if	O
(	O
result	enum
==	O
0	int
&&	O
window	pointer
->	O
node	pointer
==	O
starting_node	pointer
&&	O
search_skip_screen_p	int
)	O
{	O
long	O
match_line	long
=	O
window_line_of_point	function
(	O
window	pointer
)	O
;	O
long	O
new_pagetop	int
;	O
new_pagetop	int
=	O
window	pointer
->	O
pagetop	long
;	O
new_pagetop	int
+=	O
(	O
match_line	long
-	O
window	pointer
->	O
pagetop	long
)	O
/	O
window	pointer
->	O
height	long
*	O
window	pointer
->	O
height	long
;	O
set_window_pagetop	function
(	O
window	pointer
,	O
new_pagetop	int
)	O
;	O
}	O
else	O
window_adjust_pagetop	function
(	O
window	pointer
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_search_previous	function
,	O
_	O
(	O
"Repeat last search in the reverse direction"	pointer
)	O
)	O
{	O
long	O
start_off	pointer
=	O
window	pointer
->	O
point	long
-	O
1	int
;	O
NODE	struct
*	O
starting_node	pointer
=	O
window	pointer
->	O
node	pointer
;	O
int	O
result	enum
;	O
if	O
(	O
window	pointer
->	O
search_string	pointer
&&	O
window	pointer
->	O
node	pointer
->	O
active_menu	int
)	O
{	O
tree_search_check_node_backwards	function
(	O
window	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
last_search_direction	int
||	O
!	O
search_string	pointer
)	O
{	O
info_error	function
(	O
"%s"	pointer
,	O
_	O
(	O
"No previous search string"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
search_skip_screen_p	int
)	O
start_off	pointer
=	O
window	pointer
->	O
line_starts	pointer
[	O
window	pointer
->	O
pagetop	long
]	O
-	O
1	int
;	O
for	O
(	O
result	enum
=	O
0	int
;	O
result	enum
==	O
0	int
&&	O
count	pointer
--	O
;	O
)	O
result	enum
=	O
info_search_internal	function
(	O
search_string	pointer
,	O
active_window	pointer
,	O
-	O
1	int
,	O
last_search_case_sensitive	int
,	O
&	O
start_off	pointer
)	O
;	O
if	O
(	O
result	enum
==	O
0	int
&&	O
window	pointer
->	O
node	pointer
==	O
starting_node	pointer
&&	O
search_skip_screen_p	int
)	O
{	O
long	O
match_line	long
=	O
window_line_of_point	function
(	O
window	pointer
)	O
;	O
long	O
new_pagetop	int
;	O
new_pagetop	int
=	O
window	pointer
->	O
pagetop	long
-	O
window	pointer
->	O
height	long
;	O
new_pagetop	int
-=	O
(	O
window	pointer
->	O
pagetop	long
-	O
match_line	long
-	O
1	int
)	O
/	O
window	pointer
->	O
height	long
*	O
window	pointer
->	O
height	long
;	O
if	O
(	O
new_pagetop	int
<	O
0	int
)	O
new_pagetop	int
=	O
0	int
;	O
set_window_pagetop	function
(	O
window	pointer
,	O
new_pagetop	int
)	O
;	O
}	O
else	O
window_adjust_pagetop	function
(	O
window	pointer
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_clear_search	function
,	O
_	O
(	O
"Clear displayed search matches"	pointer
)	O
)	O
{	O
free_matches	function
(	O
&	O
window	pointer
->	O
matches	pointer
)	O
;	O
window	pointer
->	O
flags	int
|=	O
W_UpdateWindow	int
;	O
}	O
static	O
void	O
incremental_search	function
(	O
WINDOW	struct
*	O
window	pointer
,	O
int	O
count	pointer
)	O
;	O
DECLARE_INFO_COMMAND	O
(	O
isearch_forward	function
,	O
_	O
(	O
"Search interactively for a string as you type it"	pointer
)	O
)	O
{	O
incremental_search	function
(	O
window	pointer
,	O
count	pointer
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
isearch_backward	function
,	O
_	O
(	O
"Search interactively for a string as you type it"	pointer
)	O
)	O
{	O
incremental_search	function
(	O
window	pointer
,	O
-	O
count	pointer
)	O
;	O
}	O
typedef	O
struct	O
{	O
char	O
*	O
fullpath	pointer
;	O
char	O
*	O
nodename	pointer
;	O
long	O
pagetop	long
;	O
long	O
point	long
;	O
long	O
start	int
;	O
int	O
search_index	int
;	O
int	O
direction	int
;	O
enum	O
search_result	enum
failing	enum
;	O
}	O
SEARCH_STATE	struct
;	O
static	O
char	O
*	O
last_isearch_accepted	pointer
=	O
NULL	O
;	O
static	O
char	O
*	O
isearch_string	pointer
=	O
NULL	O
;	O
static	O
int	O
isearch_string_index	int
=	O
0	int
;	O
static	O
int	O
isearch_string_size	int
=	O
0	int
;	O
static	O
SEARCH_STATE	struct
*	O
*	O
isearch_states	pointer
=	O
NULL	O
;	O
static	O
size_t	long
isearch_states_index	long
=	O
0	int
;	O
static	O
size_t	long
isearch_states_slots	long
=	O
0	int
;	O
static	O
void	O
window_get_state	function
(	O
WINDOW	struct
*	O
window	pointer
,	O
SEARCH_STATE	struct
*	O
state	pointer
)	O
{	O
state	pointer
->	O
fullpath	pointer
=	O
window	pointer
->	O
node	pointer
->	O
fullpath	pointer
;	O
state	pointer
->	O
nodename	pointer
=	O
window	pointer
->	O
node	pointer
->	O
nodename	pointer
;	O
state	pointer
->	O
pagetop	long
=	O
window	pointer
->	O
pagetop	long
;	O
state	pointer
->	O
point	long
=	O
window	pointer
->	O
point	long
;	O
}	O
static	O
void	O
window_set_state	function
(	O
WINDOW	struct
*	O
window	pointer
,	O
SEARCH_STATE	struct
*	O
state	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
window	pointer
->	O
node	pointer
->	O
fullpath	pointer
,	O
state	pointer
->	O
fullpath	pointer
)	O
||	O
strcmp	function
(	O
window	pointer
->	O
node	pointer
->	O
nodename	pointer
,	O
state	pointer
->	O
nodename	pointer
)	O
)	O
{	O
NODE	struct
*	O
n	long
=	O
info_get_node	function
(	O
state	pointer
->	O
fullpath	pointer
,	O
state	pointer
->	O
nodename	pointer
)	O
;	O
info_set_node_of_window	function
(	O
window	pointer
,	O
n	long
)	O
;	O
}	O
window	pointer
->	O
pagetop	long
=	O
state	pointer
->	O
pagetop	long
;	O
window	pointer
->	O
point	long
=	O
state	pointer
->	O
point	long
;	O
}	O
static	O
void	O
push_isearch	function
(	O
WINDOW	struct
*	O
window	pointer
,	O
int	O
search_index	int
,	O
int	O
direction	int
,	O
enum	O
search_result	enum
failing	enum
,	O
long	O
start_off	pointer
)	O
{	O
SEARCH_STATE	struct
*	O
state	pointer
;	O
state	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
SEARCH_STATE	struct
)	O
)	O
;	O
window_get_state	function
(	O
window	pointer
,	O
state	pointer
)	O
;	O
state	pointer
->	O
search_index	int
=	O
search_index	int
;	O
state	pointer
->	O
direction	int
=	O
direction	int
;	O
state	pointer
->	O
failing	enum
=	O
failing	enum
;	O
state	pointer
->	O
start	int
=	O
start_off	pointer
;	O
add_pointer_to_array	O
(	O
state	pointer
,	O
isearch_states_index	long
,	O
isearch_states	pointer
,	O
isearch_states_slots	long
,	O
20	int
)	O
;	O
}	O
static	O
void	O
pop_isearch	function
(	O
WINDOW	struct
*	O
window	pointer
,	O
int	O
*	O
search_index	int
,	O
int	O
*	O
direction	int
,	O
enum	O
search_result	enum
*	O
failing	enum
,	O
long	O
*	O
start_off	pointer
)	O
{	O
SEARCH_STATE	struct
*	O
state	pointer
;	O
if	O
(	O
isearch_states_index	long
)	O
{	O
isearch_states_index	long
--	O
;	O
state	pointer
=	O
isearch_states	pointer
[	O
isearch_states_index	long
]	O
;	O
window_set_state	function
(	O
window	pointer
,	O
state	pointer
)	O
;	O
*	O
search_index	int
=	O
state	pointer
->	O
search_index	int
;	O
*	O
direction	int
=	O
state	pointer
->	O
direction	int
;	O
*	O
failing	enum
=	O
state	pointer
->	O
failing	enum
;	O
*	O
start_off	pointer
=	O
state	pointer
->	O
start	int
;	O
free	function
(	O
state	pointer
)	O
;	O
isearch_states	pointer
[	O
isearch_states_index	long
]	O
=	O
NULL	O
;	O
}	O
}	O
static	O
void	O
free_isearch_states	function
(	O
void	O
)	O
{	O
register	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
isearch_states_index	long
;	O
i	int
++	O
)	O
{	O
free	function
(	O
isearch_states	pointer
[	O
i	int
]	O
)	O
;	O
isearch_states	pointer
[	O
i	int
]	O
=	O
NULL	O
;	O
}	O
isearch_states_index	long
=	O
0	int
;	O
}	O
static	O
void	O
show_isearch_prompt	function
(	O
int	O
dir	int
,	O
unsigned	O
char	O
*	O
string	pointer
,	O
enum	O
search_result	enum
failing	enum
)	O
{	O
register	O
int	O
i	int
;	O
const	O
char	O
*	O
prefix	pointer
;	O
char	O
*	O
prompt	pointer
,	O
*	O
p_rep	pointer
;	O
unsigned	O
int	O
prompt_len	int
,	O
p_rep_index	int
,	O
p_rep_size	int
;	O
if	O
(	O
dir	int
<	O
0	int
)	O
prefix	pointer
=	O
use_regex	int
?	O
_	O
(	O
"Regexp I-search backward: "	pointer
)	O
:	O
_	O
(	O
"I-search backward: "	pointer
)	O
;	O
else	O
prefix	pointer
=	O
use_regex	int
?	O
_	O
(	O
"Regexp I-search: "	pointer
)	O
:	O
_	O
(	O
"I-search: "	pointer
)	O
;	O
p_rep_index	int
=	O
p_rep_size	int
=	O
0	int
;	O
p_rep	pointer
=	O
NULL	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
string	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
char	O
*	O
rep	pointer
;	O
switch	O
(	O
string	pointer
[	O
i	int
]	O
)	O
{	O
case	O
' '	O
:	O
rep	pointer
=	O
" "	pointer
;	O
break	O
;	O
case	O
LFD	char
:	O
rep	pointer
=	O
"\\n"	pointer
;	O
break	O
;	O
case	O
TAB	char
:	O
rep	pointer
=	O
"\\t"	pointer
;	O
break	O
;	O
default	O
:	O
rep	pointer
=	O
pretty_keyname	function
(	O
string	pointer
[	O
i	int
]	O
)	O
;	O
}	O
if	O
(	O
(	O
p_rep_index	int
+	O
strlen	function
(	O
rep	pointer
)	O
+	O
1	int
)	O
>=	O
p_rep_size	int
)	O
p_rep	pointer
=	O
xrealloc	function
(	O
p_rep	pointer
,	O
p_rep_size	int
+=	O
100	int
)	O
;	O
strcpy	function
(	O
p_rep	pointer
+	O
p_rep_index	int
,	O
rep	pointer
)	O
;	O
p_rep_index	int
+=	O
strlen	function
(	O
rep	pointer
)	O
;	O
}	O
prompt_len	int
=	O
strlen	function
(	O
prefix	pointer
)	O
+	O
p_rep_index	int
+	O
1	int
;	O
if	O
(	O
failing	enum
!=	O
search_success	int
)	O
prompt_len	int
+=	O
strlen	function
(	O
_	O
(	O
"Failing "	pointer
)	O
)	O
;	O
prompt	pointer
=	O
xmalloc	function
(	O
prompt_len	int
)	O
;	O
sprintf	function
(	O
prompt	pointer
,	O
"%s%s%s"	pointer
,	O
failing	enum
!=	O
search_success	int
?	O
_	O
(	O
"Failing "	pointer
)	O
:	O
""	pointer
,	O
prefix	pointer
,	O
p_rep	pointer
?	O
p_rep	pointer
:	O
""	pointer
)	O
;	O
window_message_in_echo_area	function
(	O
"%s"	pointer
,	O
prompt	pointer
)	O
;	O
free	function
(	O
p_rep	pointer
)	O
;	O
free	function
(	O
prompt	pointer
)	O
;	O
display_cursor_at_point	function
(	O
active_window	pointer
)	O
;	O
}	O
static	O
void	O
incremental_search	function
(	O
WINDOW	struct
*	O
window	pointer
,	O
int	O
count	pointer
)	O
{	O
int	O
key	int
;	O
enum	O
search_result	enum
last_search_result	enum
,	O
search_result	enum
;	O
int	O
dir	int
;	O
SEARCH_STATE	struct
orig_state	struct
;	O
SEARCH_STATE	struct
mystate	struct
;	O
char	O
*	O
p	pointer
;	O
int	O
case_sensitive	int
;	O
long	O
start_off	pointer
=	O
window	pointer
->	O
point	long
;	O
int	O
starting_history_entry	int
=	O
window	pointer
->	O
hist_index	long
-	O
1	int
;	O
if	O
(	O
count	pointer
<	O
0	int
)	O
dir	int
=	O
-	O
1	int
;	O
else	O
dir	int
=	O
1	int
;	O
last_search_result	enum
=	O
search_result	enum
=	O
search_success	int
;	O
window_get_state	function
(	O
window	pointer
,	O
&	O
orig_state	struct
)	O
;	O
isearch_string_index	int
=	O
0	int
;	O
if	O
(	O
!	O
isearch_string_size	int
)	O
isearch_string	pointer
=	O
xmalloc	function
(	O
isearch_string_size	int
=	O
50	int
)	O
;	O
isearch_string	pointer
[	O
isearch_string_index	int
]	O
=	O
'\0'	O
;	O
isearch_is_active	int
=	O
1	int
;	O
push_isearch	function
(	O
window	pointer
,	O
isearch_string_index	int
,	O
dir	int
,	O
search_result	enum
,	O
start_off	pointer
)	O
;	O
while	O
(	O
isearch_is_active	int
)	O
{	O
VFunction	function
*	O
func	pointer
=	O
NULL	O
;	O
int	O
quoted	int
=	O
0	int
;	O
show_isearch_prompt	function
(	O
dir	int
,	O
(	O
unsigned	O
char	O
*	O
)	O
isearch_string	pointer
,	O
search_result	enum
)	O
;	O
if	O
(	O
!	O
info_any_buffered_input_p	function
(	O
)	O
&&	O
display_was_interrupted_p	int
)	O
{	O
display_update_display	function
(	O
)	O
;	O
display_cursor_at_point	function
(	O
active_window	pointer
)	O
;	O
}	O
{	O
Keymap	pointer
info_kp	pointer
,	O
ea_kp	pointer
;	O
info_kp	pointer
=	O
info_keymap	pointer
;	O
ea_kp	pointer
=	O
echo_area_keymap	pointer
;	O
key	int
=	O
get_input_key	function
(	O
)	O
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
key	int
>=	O
32	int
&&	O
key	int
<	O
256	int
)	O
break	O
;	O
if	O
(	O
info_kp	pointer
&&	O
info_kp	pointer
[	O
key	int
]	O
.	O
type	enum
==	O
ISFUNC	int
)	O
{	O
if	O
(	O
info_kp	pointer
[	O
key	int
]	O
.	O
value	union
.	O
function	pointer
)	O
func	pointer
=	O
info_kp	pointer
[	O
key	int
]	O
.	O
value	union
.	O
function	pointer
->	O
func	pointer
;	O
if	O
(	O
func	pointer
==	O
&	O
isearch_forward	function
||	O
func	pointer
==	O
&	O
isearch_backward	function
||	O
func	pointer
==	O
&	O
info_abort_key	function
)	O
{	O
goto	O
gotfunc	O
;	O
}	O
else	O
{	O
func	pointer
=	O
0	int
;	O
info_kp	pointer
=	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
info_kp	pointer
)	O
info_kp	pointer
=	O
info_kp	pointer
[	O
key	int
]	O
.	O
value	union
.	O
keymap	pointer
;	O
if	O
(	O
ea_kp	pointer
&&	O
ea_kp	pointer
[	O
key	int
]	O
.	O
type	enum
==	O
ISFUNC	int
)	O
{	O
if	O
(	O
ea_kp	pointer
[	O
key	int
]	O
.	O
value	union
.	O
function	pointer
)	O
func	pointer
=	O
ea_kp	pointer
[	O
key	int
]	O
.	O
value	union
.	O
function	pointer
->	O
func	pointer
;	O
if	O
(	O
func	pointer
==	O
&	O
ea_abort	function
||	O
func	pointer
==	O
&	O
ea_quoted_insert	function
||	O
func	pointer
==	O
&	O
ea_rubout	function
)	O
{	O
func	pointer
=	O
ea_kp	pointer
[	O
key	int
]	O
.	O
value	union
.	O
function	pointer
->	O
func	pointer
;	O
goto	O
gotfunc	O
;	O
}	O
else	O
{	O
func	pointer
=	O
0	int
;	O
ea_kp	pointer
=	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
ea_kp	pointer
)	O
ea_kp	pointer
=	O
ea_kp	pointer
[	O
key	int
]	O
.	O
value	union
.	O
keymap	pointer
;	O
if	O
(	O
!	O
info_kp	pointer
&&	O
!	O
ea_kp	pointer
)	O
break	O
;	O
key	int
=	O
get_input_key	function
(	O
)	O
;	O
}	O
}	O
gotfunc	O
:	O
if	O
(	O
func	pointer
==	O
&	O
ea_quoted_insert	function
)	O
{	O
key	int
=	O
get_input_key	function
(	O
)	O
;	O
if	O
(	O
key	int
<	O
0	int
||	O
key	int
>=	O
256	int
)	O
continue	O
;	O
quoted	int
=	O
1	int
;	O
}	O
if	O
(	O
quoted	int
||	O
(	O
!	O
func	pointer
&&	O
key	int
>=	O
32	int
&&	O
key	int
<	O
256	int
)	O
)	O
{	O
push_isearch	function
(	O
window	pointer
,	O
isearch_string_index	int
,	O
dir	int
,	O
search_result	enum
,	O
start_off	pointer
)	O
;	O
if	O
(	O
isearch_string_index	int
+	O
2	int
>=	O
isearch_string_size	int
)	O
isearch_string	pointer
=	O
xrealloc	function
(	O
isearch_string	pointer
,	O
isearch_string_size	int
+=	O
100	int
)	O
;	O
isearch_string	pointer
[	O
isearch_string_index	int
++	O
]	O
=	O
key	int
;	O
isearch_string	pointer
[	O
isearch_string_index	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
search_result	enum
!=	O
search_success	int
&&	O
!	O
use_regex	int
)	O
continue	O
;	O
}	O
else	O
if	O
(	O
func	pointer
==	O
&	O
ea_rubout	function
)	O
{	O
if	O
(	O
!	O
isearch_states_index	long
)	O
{	O
terminal_ring_bell	function
(	O
)	O
;	O
continue	O
;	O
}	O
else	O
{	O
int	O
end	int
=	O
isearch_string_index	int
;	O
do	O
{	O
pop_isearch	function
(	O
window	pointer
,	O
&	O
isearch_string_index	int
,	O
&	O
dir	int
,	O
&	O
search_result	enum
,	O
&	O
start_off	pointer
)	O
;	O
}	O
while	O
(	O
isearch_string_index	int
>	O
0	int
&&	O
(	O
long	O
)	O
mbrlen	function
(	O
isearch_string	pointer
+	O
isearch_string_index	int
,	O
end	int
-	O
isearch_string_index	int
,	O
NULL	O
)	O
<=	O
0	int
)	O
;	O
isearch_string	pointer
[	O
isearch_string_index	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
isearch_string_index	int
==	O
0	int
)	O
{	O
free_matches	function
(	O
&	O
window	pointer
->	O
matches	pointer
)	O
;	O
display_update_one_window	function
(	O
window	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
search_result	enum
!=	O
search_success	int
)	O
{	O
display_update_one_window	function
(	O
window	pointer
)	O
;	O
continue	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
func	pointer
==	O
&	O
isearch_forward	function
||	O
func	pointer
==	O
&	O
isearch_backward	function
)	O
{	O
if	O
(	O
func	pointer
==	O
&	O
isearch_forward	function
&&	O
dir	int
>	O
0	int
||	O
func	pointer
==	O
&	O
isearch_backward	function
&&	O
dir	int
<	O
0	int
)	O
{	O
if	O
(	O
isearch_string_index	int
==	O
0	int
)	O
{	O
if	O
(	O
last_isearch_accepted	pointer
)	O
{	O
if	O
(	O
strlen	function
(	O
(	O
char	O
*	O
)	O
last_isearch_accepted	pointer
)	O
+	O
1	int
>=	O
(	O
unsigned	O
int	O
)	O
isearch_string_size	int
)	O
isearch_string	pointer
=	O
(	O
char	O
*	O
)	O
xrealloc	function
(	O
isearch_string	pointer
,	O
isearch_string_size	int
+=	O
10	int
+	O
strlen	function
(	O
last_isearch_accepted	pointer
)	O
)	O
;	O
strcpy	function
(	O
isearch_string	pointer
,	O
last_isearch_accepted	pointer
)	O
;	O
isearch_string_index	int
=	O
strlen	function
(	O
isearch_string	pointer
)	O
;	O
}	O
else	O
continue	O
;	O
}	O
else	O
{	O
if	O
(	O
search_result	enum
==	O
search_success	int
)	O
{	O
start_off	pointer
=	O
window	pointer
->	O
point	long
;	O
if	O
(	O
dir	int
<	O
0	int
)	O
start_off	pointer
--	O
;	O
}	O
}	O
}	O
else	O
{	O
dir	int
=	O
-	O
dir	int
;	O
}	O
}	O
else	O
if	O
(	O
func	pointer
==	O
&	O
info_abort_key	function
&&	O
isearch_states_index	long
&&	O
search_result	enum
!=	O
search_success	int
)	O
{	O
terminal_ring_bell	function
(	O
)	O
;	O
while	O
(	O
isearch_states_index	long
&&	O
search_result	enum
!=	O
search_success	int
)	O
pop_isearch	function
(	O
window	pointer
,	O
&	O
isearch_string_index	int
,	O
&	O
dir	int
,	O
&	O
search_result	enum
,	O
&	O
start_off	pointer
)	O
;	O
isearch_string	pointer
[	O
isearch_string_index	int
]	O
=	O
'\0'	O
;	O
show_isearch_prompt	function
(	O
dir	int
,	O
(	O
unsigned	O
char	O
*	O
)	O
isearch_string	pointer
,	O
search_result	enum
)	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
func	pointer
==	O
&	O
info_abort_key	function
||	O
func	pointer
==	O
&	O
ea_abort	function
||	O
!	O
func	pointer
)	O
{	O
if	O
(	O
isearch_string_index	int
&&	O
func	pointer
!=	O
&	O
info_abort_key	function
)	O
{	O
free	function
(	O
last_isearch_accepted	pointer
)	O
;	O
last_isearch_accepted	pointer
=	O
xstrdup	function
(	O
isearch_string	pointer
)	O
;	O
}	O
if	O
(	O
func	pointer
==	O
&	O
info_abort_key	function
)	O
{	O
if	O
(	O
isearch_states_index	long
)	O
window_set_state	function
(	O
window	pointer
,	O
&	O
orig_state	struct
)	O
;	O
}	O
if	O
(	O
!	O
echo_area_is_active	int
)	O
window_clear_echo_area	function
(	O
)	O
;	O
if	O
(	O
auto_footnotes_p	int
)	O
info_get_or_remove_footnotes	function
(	O
active_window	pointer
)	O
;	O
isearch_is_active	int
=	O
0	int
;	O
continue	O
;	O
}	O
show_isearch_prompt	function
(	O
dir	int
,	O
(	O
unsigned	O
char	O
*	O
)	O
isearch_string	pointer
,	O
search_result	enum
)	O
;	O
case_sensitive	int
=	O
0	int
;	O
for	O
(	O
p	pointer
=	O
isearch_string	pointer
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
if	O
(	O
isupper	function
(	O
*	O
p	pointer
)	O
)	O
{	O
case_sensitive	int
=	O
1	int
;	O
break	O
;	O
}	O
last_search_result	enum
=	O
search_result	enum
;	O
window_get_state	function
(	O
window	pointer
,	O
&	O
mystate	struct
)	O
;	O
search_result	enum
=	O
info_search_internal	function
(	O
isearch_string	pointer
,	O
window	pointer
,	O
dir	int
,	O
case_sensitive	int
,	O
&	O
start_off	pointer
)	O
;	O
if	O
(	O
search_result	enum
!=	O
search_success	int
&&	O
last_search_result	enum
==	O
search_success	int
)	O
{	O
terminal_ring_bell	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
search_result	enum
==	O
search_success	int
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
window	pointer
->	O
node	pointer
->	O
fullpath	pointer
,	O
mystate	struct
.	O
fullpath	pointer
)	O
&&	O
!	O
strcmp	function
(	O
window	pointer
->	O
node	pointer
->	O
nodename	pointer
,	O
mystate	struct
.	O
nodename	pointer
)	O
&&	O
mystate	struct
.	O
pagetop	long
!=	O
window	pointer
->	O
pagetop	long
)	O
{	O
int	O
newtop	int
=	O
window	pointer
->	O
pagetop	long
;	O
window	pointer
->	O
pagetop	long
=	O
mystate	struct
.	O
pagetop	long
;	O
set_window_pagetop	function
(	O
window	pointer
,	O
newtop	int
)	O
;	O
}	O
window_adjust_pagetop	function
(	O
window	pointer
)	O
;	O
display_update_display	function
(	O
)	O
;	O
display_cursor_at_point	function
(	O
window	pointer
)	O
;	O
}	O
}	O
free_isearch_states	function
(	O
)	O
;	O
{	O
int	O
i	int
=	O
window	pointer
->	O
hist_index	long
-	O
1	int
;	O
int	O
j	int
=	O
starting_history_entry	int
;	O
if	O
(	O
i	int
>	O
j	int
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
window	pointer
->	O
hist	pointer
[	O
i	int
]	O
->	O
node	pointer
->	O
nodename	pointer
,	O
window	pointer
->	O
hist	pointer
[	O
j	int
]	O
->	O
node	pointer
->	O
nodename	pointer
)	O
&&	O
!	O
strcmp	function
(	O
window	pointer
->	O
hist	pointer
[	O
j	int
]	O
->	O
node	pointer
->	O
fullpath	pointer
,	O
window	pointer
->	O
hist	pointer
[	O
i	int
]	O
->	O
node	pointer
->	O
fullpath	pointer
)	O
)	O
{	O
cleanup_history	function
(	O
window	pointer
,	O
j	int
,	O
i	int
)	O
;	O
}	O
else	O
{	O
cleanup_history	function
(	O
window	pointer
,	O
j	int
+	O
1	int
,	O
i	int
)	O
;	O
}	O
}	O
}	O
gc_file_buffers_and_nodes	function
(	O
)	O
;	O
if	O
(	O
!	O
echo_area_is_active	int
)	O
window_clear_echo_area	function
(	O
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_abort_key	function
,	O
_	O
(	O
"Cancel current operation"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
info_error_rings_bell_p	int
)	O
terminal_ring_bell	function
(	O
)	O
;	O
info_error	function
(	O
"%s"	pointer
,	O
_	O
(	O
"Quit"	pointer
)	O
)	O
;	O
info_initialize_numeric_arg	function
(	O
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_info_version	function
,	O
_	O
(	O
"Display version of Info being run"	pointer
)	O
)	O
{	O
window_message_in_echo_area	function
(	O
_	O
(	O
"GNU Info version %s"	pointer
)	O
,	O
VERSION	pointer
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_redraw_display	function
,	O
_	O
(	O
"Redraw the display"	pointer
)	O
)	O
{	O
if	O
(	O
(	O
!	O
info_explicit_arg	int
&&	O
count	pointer
==	O
1	int
)	O
||	O
echo_area_is_active	int
)	O
{	O
terminal_clear_screen	function
(	O
)	O
;	O
display_clear_display	function
(	O
the_display	pointer
)	O
;	O
window_mark_chain	function
(	O
windows	pointer
,	O
W_UpdateWindow	int
)	O
;	O
display_update_display	function
(	O
)	O
;	O
}	O
else	O
{	O
int	O
desired_line	int
,	O
point_line	int
;	O
int	O
new_pagetop	int
;	O
point_line	int
=	O
window_line_of_point	function
(	O
window	pointer
)	O
-	O
window	pointer
->	O
pagetop	long
;	O
if	O
(	O
count	pointer
<	O
0	int
)	O
desired_line	int
=	O
window	pointer
->	O
height	long
+	O
count	pointer
;	O
else	O
desired_line	int
=	O
count	pointer
;	O
if	O
(	O
desired_line	int
<	O
0	int
)	O
desired_line	int
=	O
0	int
;	O
if	O
(	O
desired_line	int
>=	O
window	pointer
->	O
height	long
)	O
desired_line	int
=	O
window	pointer
->	O
height	long
-	O
1	int
;	O
if	O
(	O
desired_line	int
==	O
point_line	int
)	O
return	O
;	O
new_pagetop	int
=	O
window	pointer
->	O
pagetop	long
+	O
(	O
point_line	int
-	O
desired_line	int
)	O
;	O
set_window_pagetop	function
(	O
window	pointer
,	O
new_pagetop	int
)	O
;	O
}	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_quit	function
,	O
_	O
(	O
"Quit using Info"	pointer
)	O
)	O
{	O
if	O
(	O
window	pointer
->	O
next	pointer
||	O
window	pointer
->	O
prev	pointer
)	O
info_delete_window	function
(	O
window	pointer
,	O
count	pointer
)	O
;	O
else	O
quit_info_immediately	int
=	O
1	int
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_do_lowercase_version	function
,	O
_	O
(	O
"Run command bound to this key's lowercase variant"	pointer
)	O
)	O
{	O
}	O
static	O
void	O
dispatch_error	function
(	O
int	O
*	O
keyseq	pointer
)	O
{	O
char	O
*	O
rep	pointer
;	O
rep	pointer
=	O
pretty_keyseq	function
(	O
keyseq	pointer
)	O
;	O
if	O
(	O
!	O
echo_area_is_active	int
)	O
info_error	function
(	O
_	O
(	O
"Unknown command (%s)"	pointer
)	O
,	O
rep	pointer
)	O
;	O
else	O
{	O
char	O
*	O
temp	pointer
=	O
xmalloc	function
(	O
1	int
+	O
strlen	function
(	O
rep	pointer
)	O
+	O
strlen	function
(	O
_	O
(	O
"\"%s\" is invalid"	pointer
)	O
)	O
)	O
;	O
sprintf	function
(	O
temp	pointer
,	O
_	O
(	O
"'%s' is invalid"	pointer
)	O
,	O
rep	pointer
)	O
;	O
terminal_ring_bell	function
(	O
)	O
;	O
inform_in_echo_area	function
(	O
temp	pointer
)	O
;	O
free	function
(	O
temp	pointer
)	O
;	O
}	O
}	O
static	O
int	O
*	O
info_keyseq	pointer
=	O
NULL	O
;	O
static	O
int	O
info_keyseq_index	int
=	O
0	int
;	O
static	O
int	O
info_keyseq_size	int
=	O
0	int
;	O
static	O
int	O
info_keyseq_displayed_p	int
=	O
0	int
;	O
void	O
initialize_keyseq	function
(	O
void	O
)	O
{	O
info_keyseq_index	int
=	O
0	int
;	O
info_keyseq_displayed_p	int
=	O
0	int
;	O
}	O
void	O
add_char_to_keyseq	function
(	O
int	O
character	int
)	O
{	O
if	O
(	O
info_keyseq_index	int
+	O
2	int
>=	O
info_keyseq_size	int
)	O
info_keyseq	pointer
=	O
xrealloc	function
(	O
info_keyseq	pointer
,	O
sizeof	O
(	O
int	O
)	O
*	O
(	O
info_keyseq_size	int
+=	O
10	int
)	O
)	O
;	O
info_keyseq	pointer
[	O
info_keyseq_index	int
++	O
]	O
=	O
character	int
;	O
info_keyseq	pointer
[	O
info_keyseq_index	int
]	O
=	O
'\0'	O
;	O
}	O
static	O
void	O
display_info_keyseq	function
(	O
int	O
expecting_future_input	int
)	O
{	O
char	O
*	O
rep	pointer
;	O
if	O
(	O
!	O
info_keyseq	pointer
||	O
info_keyseq_index	int
==	O
0	int
)	O
return	O
;	O
rep	pointer
=	O
pretty_keyseq	function
(	O
info_keyseq	pointer
)	O
;	O
if	O
(	O
expecting_future_input	int
)	O
strcat	function
(	O
rep	pointer
,	O
"-"	pointer
)	O
;	O
if	O
(	O
echo_area_is_active	int
)	O
inform_in_echo_area	function
(	O
rep	pointer
)	O
;	O
else	O
{	O
window_message_in_echo_area	function
(	O
rep	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
display_cursor_at_point	function
(	O
active_window	pointer
)	O
;	O
}	O
info_keyseq_displayed_p	int
=	O
1	int
;	O
}	O
int	O
get_another_input_key	function
(	O
void	O
)	O
{	O
int	O
ready	int
=	O
!	O
info_keyseq_displayed_p	int
;	O
if	O
(	O
!	O
info_keyseq_displayed_p	int
)	O
{	O
ready	int
=	O
1	int
;	O
if	O
(	O
!	O
info_any_buffered_input_p	function
(	O
)	O
)	O
{	O
struct	O
timeval	struct
timer	struct
;	O
fd_set	struct
readfds	struct
;	O
FD_ZERO	O
(	O
&	O
readfds	struct
)	O
;	O
FD_SET	O
(	O
fileno	function
(	O
info_input_stream	pointer
)	O
,	O
&	O
readfds	struct
)	O
;	O
timer	struct
.	O
tv_sec	long
=	O
1	int
;	O
timer	struct
.	O
tv_usec	long
=	O
750	int
;	O
ready	int
=	O
select	function
(	O
fileno	function
(	O
info_input_stream	pointer
)	O
+	O
1	int
,	O
&	O
readfds	struct
,	O
NULL	O
,	O
NULL	O
,	O
&	O
timer	struct
)	O
;	O
}	O
}	O
if	O
(	O
!	O
ready	int
)	O
display_info_keyseq	function
(	O
1	int
)	O
;	O
return	O
get_input_key	function
(	O
)	O
;	O
}	O
int	O
info_explicit_arg	int
=	O
0	int
;	O
int	O
ea_explicit_arg	int
=	O
0	int
;	O
void	O
info_universal_argument	function
(	O
WINDOW	struct
*	O
,	O
int	O
count	pointer
)	O
;	O
void	O
info_add_digit_to_numeric_arg	function
(	O
WINDOW	struct
*	O
,	O
int	O
count	pointer
)	O
;	O
VFunction	function
*	O
read_key_sequence	function
(	O
Keymap	pointer
map	pointer
,	O
int	O
menu	int
,	O
int	O
mouse	int
,	O
int	O
insert	int
,	O
int	O
*	O
count	pointer
)	O
{	O
int	O
key	int
;	O
int	O
reading_universal_argument	int
=	O
0	int
;	O
int	O
numeric_arg	int
=	O
1	int
,	O
numeric_arg_sign	int
=	O
1	int
,	O
*	O
which_explicit_arg	pointer
;	O
VFunction	function
*	O
func	pointer
;	O
if	O
(	O
!	O
echo_area_is_active	int
)	O
which_explicit_arg	pointer
=	O
&	O
info_explicit_arg	int
;	O
else	O
which_explicit_arg	pointer
=	O
&	O
ea_explicit_arg	int
;	O
*	O
which_explicit_arg	pointer
=	O
0	int
;	O
initialize_keyseq	function
(	O
)	O
;	O
key	int
=	O
get_input_key	function
(	O
)	O
;	O
if	O
(	O
key	int
==	O
KEY_MOUSE	int
)	O
{	O
if	O
(	O
mouse	int
)	O
mouse_event_handler	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
insert	int
&&	O
(	O
key	int
>=	O
040	int
&&	O
key	int
<	O
0200	int
||	O
ISO_Latin_p	int
&&	O
key	int
>=	O
0200	int
&&	O
key	int
<	O
0400	int
)	O
)	O
{	O
ea_insert	function
(	O
the_echo_area	pointer
,	O
1	int
,	O
key	int
)	O
;	O
return	O
0	int
;	O
}	O
add_char_to_keyseq	function
(	O
key	int
)	O
;	O
while	O
(	O
1	int
)	O
{	O
int	O
dash_typed	int
=	O
0	int
,	O
digit_typed	int
=	O
0	int
;	O
func	pointer
=	O
0	int
;	O
if	O
(	O
display_was_interrupted_p	int
&&	O
!	O
info_any_buffered_input_p	function
(	O
)	O
)	O
display_update_display	function
(	O
)	O
;	O
if	O
(	O
active_window	pointer
!=	O
the_echo_area	pointer
)	O
display_cursor_at_point	function
(	O
active_window	pointer
)	O
;	O
if	O
(	O
reading_universal_argument	int
)	O
{	O
int	O
k	int
=	O
key	int
;	O
if	O
(	O
k	int
>=	O
KEYMAP_META_BASE	int
)	O
k	int
-=	O
KEYMAP_META_BASE	int
;	O
if	O
(	O
k	int
==	O
'-'	O
)	O
{	O
dash_typed	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
isdigit	function
(	O
k	int
)	O
)	O
{	O
digit_typed	int
=	O
1	int
;	O
}	O
else	O
reading_universal_argument	int
=	O
0	int
;	O
}	O
if	O
(	O
!	O
dash_typed	int
&&	O
!	O
digit_typed	int
&&	O
map	pointer
[	O
key	int
]	O
.	O
type	enum
==	O
ISFUNC	int
)	O
{	O
func	pointer
=	O
map	pointer
[	O
key	int
]	O
.	O
value	union
.	O
function	pointer
?	O
map	pointer
[	O
key	int
]	O
.	O
value	union
.	O
function	pointer
->	O
func	pointer
:	O
0	int
;	O
if	O
(	O
!	O
func	pointer
)	O
{	O
dispatch_error	function
(	O
info_keyseq	pointer
)	O
;	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
dash_typed	int
||	O
digit_typed	int
||	O
func	pointer
==	O
&	O
info_add_digit_to_numeric_arg	function
)	O
{	O
int	O
k	int
=	O
key	int
;	O
if	O
(	O
k	int
>	O
KEYMAP_META_BASE	int
)	O
k	int
-=	O
KEYMAP_META_BASE	int
;	O
reading_universal_argument	int
=	O
1	int
;	O
if	O
(	O
dash_typed	int
||	O
k	int
==	O
'-'	O
)	O
{	O
if	O
(	O
!	O
*	O
which_explicit_arg	pointer
)	O
{	O
numeric_arg_sign	int
=	O
-	O
1	int
;	O
numeric_arg	int
=	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
digit_typed	int
||	O
isdigit	function
(	O
k	int
)	O
)	O
{	O
if	O
(	O
*	O
which_explicit_arg	pointer
)	O
numeric_arg	int
=	O
numeric_arg	int
*	O
10	int
+	O
(	O
k	int
-	O
'0'	O
)	O
;	O
else	O
numeric_arg	int
=	O
(	O
k	int
-	O
'0'	O
)	O
;	O
*	O
which_explicit_arg	pointer
=	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
func	pointer
==	O
info_do_lowercase_version	function
)	O
{	O
int	O
lowerkey	int
;	O
if	O
(	O
key	int
>=	O
KEYMAP_META_BASE	int
)	O
{	O
lowerkey	int
=	O
key	int
;	O
lowerkey	int
-=	O
KEYMAP_META_BASE	int
;	O
lowerkey	int
=	O
tolower	function
(	O
lowerkey	int
)	O
;	O
lowerkey	int
+=	O
KEYMAP_META_BASE	int
;	O
}	O
else	O
lowerkey	int
=	O
tolower	function
(	O
key	int
)	O
;	O
if	O
(	O
lowerkey	int
==	O
key	int
)	O
{	O
dispatch_error	function
(	O
info_keyseq	pointer
)	O
;	O
return	O
0	int
;	O
}	O
key	int
=	O
lowerkey	int
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
func	pointer
==	O
&	O
info_universal_argument	function
)	O
{	O
if	O
(	O
!	O
*	O
which_explicit_arg	pointer
)	O
numeric_arg	int
*=	O
4	int
;	O
reading_universal_argument	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
menu	int
&&	O
func	pointer
==	O
&	O
info_menu_digit	function
)	O
{	O
int	O
k	int
=	O
key	int
;	O
if	O
(	O
k	int
>	O
KEYMAP_META_BASE	int
)	O
k	int
-=	O
KEYMAP_META_BASE	int
;	O
window_clear_echo_area	function
(	O
)	O
;	O
menu_digit	function
(	O
active_window	pointer
,	O
k	int
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
insert	int
&&	O
(	O
func	pointer
==	O
&	O
ea_possible_completions	function
||	O
func	pointer
==	O
&	O
ea_complete	function
)	O
&&	O
!	O
echo_area_completion_items	pointer
)	O
{	O
ea_insert	function
(	O
the_echo_area	pointer
,	O
1	int
,	O
key	int
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
func	pointer
)	O
{	O
if	O
(	O
!	O
echo_area_is_active	int
&&	O
info_keyseq_displayed_p	int
)	O
display_info_keyseq	function
(	O
0	int
)	O
;	O
if	O
(	O
count	pointer
)	O
*	O
count	pointer
=	O
numeric_arg	int
*	O
numeric_arg_sign	int
;	O
if	O
(	O
*	O
count	pointer
!=	O
1	int
&&	O
!	O
*	O
which_explicit_arg	pointer
)	O
*	O
which_explicit_arg	pointer
=	O
1	int
;	O
return	O
func	pointer
;	O
}	O
else	O
if	O
(	O
map	pointer
[	O
key	int
]	O
.	O
type	enum
==	O
ISKMAP	int
)	O
{	O
if	O
(	O
map	pointer
[	O
key	int
]	O
.	O
value	union
.	O
keymap	pointer
!=	O
NULL	O
)	O
map	pointer
=	O
map	pointer
[	O
key	int
]	O
.	O
value	union
.	O
keymap	pointer
;	O
else	O
{	O
dispatch_error	function
(	O
info_keyseq	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
info_keyseq_displayed_p	int
)	O
display_info_keyseq	function
(	O
1	int
)	O
;	O
}	O
do	O
key	int
=	O
get_another_input_key	function
(	O
)	O
;	O
while	O
(	O
key	int
==	O
KEY_MOUSE	int
)	O
;	O
add_char_to_keyseq	function
(	O
key	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_add_digit_to_numeric_arg	function
,	O
_	O
(	O
"Add this digit to the current numeric argument"	pointer
)	O
)	O
{	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_universal_argument	function
,	O
_	O
(	O
"Start (or multiply by 4) the current numeric argument"	pointer
)	O
)	O
{	O
}	O
void	O
info_initialize_numeric_arg	function
(	O
void	O
)	O
{	O
if	O
(	O
!	O
echo_area_is_active	int
)	O
{	O
info_explicit_arg	int
=	O
0	int
;	O
}	O
else	O
{	O
ea_explicit_arg	int
=	O
0	int
;	O
}	O
}	O
