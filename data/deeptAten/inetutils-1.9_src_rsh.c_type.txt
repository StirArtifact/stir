int	O
debug_option	int
=	O
0	int
;	O
int	O
null_input_option	int
=	O
0	int
;	O
char	O
*	O
user	pointer
=	O
NULL	O
;	O
int	O
rfd2	int
;	O
char	O
*	O
copyargs	function
(	O
char	O
*	O
*	O
)	O
;	O
void	O
sendsig	function
(	O
int	O
)	O
;	O
void	O
talk	function
(	O
int	O
,	O
sigset_t	struct
*	O
,	O
pid_t	int
,	O
int	O
)	O
;	O
void	O
warning	function
(	O
const	O
char	O
*	O
,	O
...	O
)	O
;	O
const	O
char	O
args_doc	pointer
[	O
]	O
=	O
"[USER@]HOST [COMMAND [ARG...]]"	pointer
;	O
const	O
char	O
doc	pointer
[	O
]	O
=	O
"remote shell"	pointer
;	O
static	O
struct	O
argp_option	struct
options	pointer
[	O
]	O
=	O
{	O
{	O
"debug"	pointer
,	O
'd'	O
,	O
NULL	O
,	O
0	int
,	O
"turns on socket debugging (see setsockopt(2))"	pointer
}	O
,	O
{	O
"user"	pointer
,	O
'l'	O
,	O
"USER"	pointer
,	O
0	int
,	O
"run as USER on the remote system"	pointer
}	O
,	O
{	O
"escape"	pointer
,	O
'e'	O
,	O
"CHAR"	pointer
,	O
0	int
,	O
"allows user specification of the escape character (``~'' by default)"	pointer
}	O
,	O
{	O
"8-bit"	pointer
,	O
'8'	O
,	O
NULL	O
,	O
0	int
,	O
"allows an eight-bit input data path at all times"	pointer
}	O
,	O
{	O
"no-input"	pointer
,	O
'n'	O
,	O
NULL	O
,	O
0	int
,	O
"use /dev/null as input"	pointer
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
error_t	int
parse_opt	function
(	O
int	O
key	int
,	O
char	O
*	O
arg	pointer
,	O
struct	O
argp_state	struct
*	O
state	pointer
)	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
'L'	O
:	O
case	O
'e'	O
:	O
case	O
'w'	O
:	O
case	O
'8'	O
:	O
break	O
;	O
case	O
'd'	O
:	O
debug_option	int
=	O
1	int
;	O
break	O
;	O
case	O
'l'	O
:	O
user	pointer
=	O
arg	pointer
;	O
break	O
;	O
case	O
'n'	O
:	O
null_input_option	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
argp	struct
argp	struct
=	O
{	O
options	pointer
,	O
parse_opt	function
,	O
args_doc	pointer
,	O
doc	pointer
}	O
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
index	function
;	O
struct	O
passwd	struct
*	O
pw	pointer
;	O
struct	O
servent	struct
*	O
sp	pointer
;	O
sigset_t	struct
sigs	struct
,	O
osigs	struct
;	O
int	O
asrsh	int
,	O
rem	int
;	O
pid_t	int
pid	int
=	O
0	int
;	O
uid_t	int
uid	int
;	O
char	O
*	O
args	pointer
,	O
*	O
host	pointer
;	O
set_program_name	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
asrsh	int
=	O
0	int
;	O
host	pointer
=	O
user	pointer
=	O
NULL	O
;	O
{	O
char	O
*	O
p	pointer
=	O
strrchr	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
'/'	O
)	O
;	O
if	O
(	O
p	pointer
)	O
++	O
p	pointer
;	O
else	O
p	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"rsh"	pointer
)	O
)	O
host	pointer
=	O
p	pointer
;	O
else	O
asrsh	int
=	O
1	int
;	O
}	O
iu_argp_init	O
(	O
"rsh"	pointer
,	O
default_program_authors	array
)	O
;	O
argp_parse	function
(	O
&	O
argp	struct
,	O
argc	int
,	O
argv	pointer
,	O
ARGP_IN_ORDER	int
,	O
&	O
index	function
,	O
NULL	O
)	O
;	O
if	O
(	O
index	function
<	O
argc	int
)	O
host	pointer
=	O
argv	pointer
[	O
index	function
++	O
]	O
;	O
if	O
(	O
!	O
host	pointer
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"host not specified"	pointer
)	O
;	O
if	O
(	O
!	O
argv	pointer
[	O
index	function
]	O
)	O
{	O
if	O
(	O
asrsh	int
)	O
*	O
argv	pointer
=	O
(	O
char	O
*	O
)	O
"rlogin"	pointer
;	O
seteuid	function
(	O
getuid	function
(	O
)	O
)	O
;	O
setuid	function
(	O
getuid	function
(	O
)	O
)	O
;	O
execv	function
(	O
PATH_RLOGIN	O
,	O
argv	pointer
)	O
;	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"cannot execute %s"	pointer
,	O
PATH_RLOGIN	O
)	O
;	O
}	O
argc	int
-=	O
index	function
;	O
argv	pointer
+=	O
index	function
;	O
if	O
(	O
geteuid	function
(	O
)	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"must be setuid root.\n"	pointer
)	O
;	O
if	O
(	O
!	O
(	O
pw	pointer
=	O
getpwuid	function
(	O
uid	int
=	O
getuid	function
(	O
)	O
)	O
)	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"unknown user id"	pointer
)	O
;	O
{	O
char	O
*	O
p	pointer
=	O
strchr	function
(	O
host	pointer
,	O
'@'	O
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
*	O
p	pointer
=	O
'\0'	O
;	O
if	O
(	O
!	O
user	pointer
&&	O
p	pointer
>	O
host	pointer
)	O
user	pointer
=	O
host	pointer
;	O
host	pointer
=	O
p	pointer
+	O
1	int
;	O
if	O
(	O
*	O
host	pointer
==	O
'\0'	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"empty host name"	pointer
)	O
;	O
}	O
}	O
args	pointer
=	O
copyargs	function
(	O
argv	pointer
)	O
;	O
sp	pointer
=	O
NULL	O
;	O
if	O
(	O
sp	pointer
==	O
NULL	O
)	O
sp	pointer
=	O
getservbyname	function
(	O
"shell"	pointer
,	O
"tcp"	pointer
)	O
;	O
if	O
(	O
sp	pointer
==	O
NULL	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"shell/tcp: unknown service"	pointer
)	O
;	O
if	O
(	O
!	O
user	pointer
)	O
user	pointer
=	O
pw	pointer
->	O
pw_name	pointer
;	O
rem	int
=	O
rcmd	function
(	O
&	O
host	pointer
,	O
sp	pointer
->	O
s_port	int
,	O
pw	pointer
->	O
pw_name	pointer
,	O
user	pointer
,	O
args	pointer
,	O
&	O
rfd2	int
)	O
;	O
if	O
(	O
rem	int
<	O
0	int
)	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
if	O
(	O
rfd2	int
<	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"can't establish stderr"	pointer
)	O
;	O
if	O
(	O
debug_option	int
)	O
{	O
int	O
one	int
=	O
1	int
;	O
if	O
(	O
setsockopt	function
(	O
rem	int
,	O
SOL_SOCKET	int
,	O
SO_DEBUG	int
,	O
(	O
char	O
*	O
)	O
&	O
one	int
,	O
sizeof	O
one	int
)	O
<	O
0	int
)	O
error	function
(	O
0	int
,	O
errno	O
,	O
"setsockopt"	pointer
)	O
;	O
if	O
(	O
setsockopt	function
(	O
rfd2	int
,	O
SOL_SOCKET	int
,	O
SO_DEBUG	int
,	O
(	O
char	O
*	O
)	O
&	O
one	int
,	O
sizeof	O
one	int
)	O
<	O
0	int
)	O
error	function
(	O
0	int
,	O
errno	O
,	O
"setsockopt"	pointer
)	O
;	O
}	O
seteuid	function
(	O
uid	int
)	O
;	O
setuid	function
(	O
uid	int
)	O
;	O
sigemptyset	function
(	O
&	O
sigs	struct
)	O
;	O
sigaddset	function
(	O
&	O
sigs	struct
,	O
SIGINT	int
)	O
;	O
sigaddset	function
(	O
&	O
sigs	struct
,	O
SIGQUIT	int
)	O
;	O
sigaddset	function
(	O
&	O
sigs	struct
,	O
SIGTERM	int
)	O
;	O
sigprocmask	function
(	O
SIG_BLOCK	int
,	O
&	O
sigs	struct
,	O
&	O
osigs	struct
)	O
;	O
if	O
(	O
signal	function
(	O
SIGINT	int
,	O
SIG_IGN	O
)	O
!=	O
SIG_IGN	O
)	O
signal	function
(	O
SIGINT	int
,	O
sendsig	function
)	O
;	O
if	O
(	O
signal	function
(	O
SIGQUIT	int
,	O
SIG_IGN	O
)	O
!=	O
SIG_IGN	O
)	O
signal	function
(	O
SIGQUIT	int
,	O
sendsig	function
)	O
;	O
if	O
(	O
signal	function
(	O
SIGTERM	int
,	O
SIG_IGN	O
)	O
!=	O
SIG_IGN	O
)	O
signal	function
(	O
SIGTERM	int
,	O
sendsig	function
)	O
;	O
if	O
(	O
!	O
null_input_option	int
)	O
{	O
pid	int
=	O
fork	function
(	O
)	O
;	O
if	O
(	O
pid	int
<	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"fork"	pointer
)	O
;	O
}	O
{	O
int	O
one	int
=	O
1	int
;	O
ioctl	function
(	O
rfd2	int
,	O
FIONBIO	int
,	O
&	O
one	int
)	O
;	O
ioctl	function
(	O
rem	int
,	O
FIONBIO	int
,	O
&	O
one	int
)	O
;	O
}	O
talk	function
(	O
null_input_option	int
,	O
&	O
osigs	struct
,	O
pid	int
,	O
rem	int
)	O
;	O
if	O
(	O
!	O
null_input_option	int
)	O
kill	function
(	O
pid	int
,	O
SIGKILL	int
)	O
;	O
return	O
0	int
;	O
}	O
void	O
talk	function
(	O
int	O
null_input_option	int
,	O
sigset_t	struct
*	O
osigs	struct
,	O
pid_t	int
pid	int
,	O
int	O
rem	int
)	O
{	O
int	O
cc	int
,	O
wc	int
;	O
fd_set	struct
readfrom	struct
,	O
ready	struct
,	O
rembits	struct
;	O
char	O
*	O
bp	pointer
,	O
buf	array
[	O
BUFSIZ	int
]	O
;	O
if	O
(	O
!	O
null_input_option	int
&&	O
pid	int
==	O
0	int
)	O
{	O
close	pointer
(	O
rfd2	int
)	O
;	O
reread	O
:	O
errno	O
=	O
0	int
;	O
if	O
(	O
(	O
cc	int
=	O
read	pointer
(	O
STDIN_FILENO	int
,	O
buf	array
,	O
sizeof	O
buf	array
)	O
)	O
<=	O
0	int
)	O
goto	O
done	O
;	O
bp	pointer
=	O
buf	array
;	O
rewrite	O
:	O
FD_ZERO	O
(	O
&	O
rembits	struct
)	O
;	O
FD_SET	O
(	O
rem	int
,	O
&	O
rembits	struct
)	O
;	O
if	O
(	O
select	function
(	O
rem	int
+	O
1	int
,	O
0	int
,	O
&	O
rembits	struct
,	O
0	int
,	O
0	int
)	O
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
!=	O
EINTR	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"select"	pointer
)	O
;	O
goto	O
rewrite	O
;	O
}	O
if	O
(	O
!	O
FD_ISSET	O
(	O
rem	int
,	O
&	O
rembits	struct
)	O
)	O
goto	O
rewrite	O
;	O
wc	int
=	O
write	pointer
(	O
rem	int
,	O
bp	pointer
,	O
cc	int
)	O
;	O
if	O
(	O
wc	int
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
EWOULDBLOCK	O
)	O
goto	O
rewrite	O
;	O
goto	O
done	O
;	O
}	O
bp	pointer
+=	O
wc	int
;	O
cc	int
-=	O
wc	int
;	O
if	O
(	O
cc	int
==	O
0	int
)	O
goto	O
reread	O
;	O
goto	O
rewrite	O
;	O
done	O
:	O
shutdown	function
(	O
rem	int
,	O
1	int
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
sigprocmask	function
(	O
SIG_SETMASK	int
,	O
osigs	struct
,	O
NULL	O
)	O
;	O
FD_ZERO	O
(	O
&	O
readfrom	struct
)	O
;	O
FD_SET	O
(	O
rfd2	int
,	O
&	O
readfrom	struct
)	O
;	O
FD_SET	O
(	O
rem	int
,	O
&	O
readfrom	struct
)	O
;	O
do	O
{	O
int	O
maxfd	int
=	O
rem	int
;	O
if	O
(	O
rfd2	int
>	O
maxfd	int
)	O
maxfd	int
=	O
rfd2	int
;	O
ready	struct
=	O
readfrom	struct
;	O
if	O
(	O
select	function
(	O
maxfd	int
+	O
1	int
,	O
&	O
ready	struct
,	O
0	int
,	O
0	int
,	O
0	int
)	O
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
!=	O
EINTR	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"select"	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
FD_ISSET	O
(	O
rfd2	int
,	O
&	O
ready	struct
)	O
)	O
{	O
errno	O
=	O
0	int
;	O
cc	int
=	O
read	pointer
(	O
rfd2	int
,	O
buf	array
,	O
sizeof	O
buf	array
)	O
;	O
if	O
(	O
cc	int
<=	O
0	int
)	O
{	O
if	O
(	O
errno	O
!=	O
EWOULDBLOCK	O
)	O
FD_CLR	O
(	O
rfd2	int
,	O
&	O
readfrom	struct
)	O
;	O
}	O
else	O
write	pointer
(	O
2	int
,	O
buf	array
,	O
cc	int
)	O
;	O
}	O
if	O
(	O
FD_ISSET	O
(	O
rem	int
,	O
&	O
ready	struct
)	O
)	O
{	O
errno	O
=	O
0	int
;	O
cc	int
=	O
read	pointer
(	O
rem	int
,	O
buf	array
,	O
sizeof	O
buf	array
)	O
;	O
if	O
(	O
cc	int
<=	O
0	int
)	O
{	O
if	O
(	O
errno	O
!=	O
EWOULDBLOCK	O
)	O
FD_CLR	O
(	O
rem	int
,	O
&	O
readfrom	struct
)	O
;	O
}	O
else	O
write	pointer
(	O
1	int
,	O
buf	array
,	O
cc	int
)	O
;	O
}	O
}	O
while	O
(	O
FD_ISSET	O
(	O
rfd2	int
,	O
&	O
readfrom	struct
)	O
||	O
FD_ISSET	O
(	O
rem	int
,	O
&	O
readfrom	struct
)	O
)	O
;	O
}	O
void	O
sendsig	function
(	O
int	O
sig	int
)	O
{	O
char	O
signo	char
;	O
signo	char
=	O
sig	int
;	O
write	pointer
(	O
rfd2	int
,	O
&	O
signo	char
,	O
1	int
)	O
;	O
}	O
char	O
*	O
copyargs	function
(	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
cc	int
;	O
char	O
*	O
*	O
ap	pointer
,	O
*	O
args	pointer
,	O
*	O
p	pointer
;	O
cc	int
=	O
0	int
;	O
for	O
(	O
ap	pointer
=	O
argv	pointer
;	O
*	O
ap	pointer
;	O
++	O
ap	pointer
)	O
cc	int
+=	O
strlen	function
(	O
*	O
ap	pointer
)	O
+	O
1	int
;	O
if	O
(	O
!	O
(	O
args	pointer
=	O
malloc	function
(	O
(	O
u_int	int
)	O
cc	int
)	O
)	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"copyargs"	pointer
)	O
;	O
for	O
(	O
p	pointer
=	O
args	pointer
,	O
ap	pointer
=	O
argv	pointer
;	O
*	O
ap	pointer
;	O
++	O
ap	pointer
)	O
{	O
strcpy	function
(	O
p	pointer
,	O
*	O
ap	pointer
)	O
;	O
for	O
(	O
p	pointer
=	O
strcpy	function
(	O
p	pointer
,	O
*	O
ap	pointer
)	O
;	O
*	O
p	pointer
;	O
++	O
p	pointer
)	O
;	O
if	O
(	O
ap	pointer
[	O
1	int
]	O
)	O
*	O
p	pointer
++	O
=	O
' '	O
;	O
}	O
return	O
args	pointer
;	O
}	O
