extern	O
FILE	struct
*	O
option_usage_fp	pointer
;	O
char	O
const	O
*	O
const	O
program_name	pointer
=	O
"shar"	pointer
;	O
bool	bool
initialization_done	bool
=	O
false	int
;	O
int	O
optidx	int
=	O
0	int
;	O
static	O
char	O
const	O
shar_opt_strs	array
[	O
10323	int
]	O
=	O
"shar (GNU sharutils) 4.15\n"	pointer
"Copyright (C) 1994-2015 Free Software Foundation, Inc., all rights reserved.\n"	pointer
"This is free software. It is licensed for use, modification and\n"	pointer
"redistribution under the terms of the GNU General Public License,\n"	pointer
"version 3 or later <http://gnu.org/licenses/gpl.html>\n\0"	pointer
"shar is free software: you can redistribute it and/or modify it under the\n"	pointer
"terms of the GNU General Public License as published by the Free Software\n"	pointer
"Foundation, either version 3 of the License, or (at your option) any later\n"	pointer
"version.\n\n"	pointer
"shar is distributed in the hope that it will be useful, but WITHOUT ANY\n"	pointer
"WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n"	pointer
"FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n"	pointer
"details.\n\n"	pointer
"You should have received a copy of the GNU General Public License along\n"	pointer
"with this program.  If not, see <http://www.gnu.org/licenses/>.\n\0"	pointer
"Specifying compression:\0"	pointer
"specify compression for input files\0"	pointer
"INTERMIX_TYPE\0"	pointer
"intermix-type\0"	pointer
"specify compaction (compression) program\0"	pointer
"COMPACTOR\0"	pointer
"compactor\0"	pointer
"pass LEVEL for compression\0"	pointer
"LEVEL_OF_COMPRESSION\0"	pointer
"level-of-compression\0"	pointer
"bzip2 and uuencode files (deprecated)\0"	pointer
"BZIP2\0"	pointer
"bzip2\0"	pointer
"gzip and uuencode files (deprecated)\0"	pointer
"GZIP\0"	pointer
"gzip\0"	pointer
"compress and uuencode files (deprecated)\0"	pointer
"COMPRESS\0"	pointer
"compress\0"	pointer
"an alias for the 'level-of-compression' option (deprecated)\0"	pointer
"level-for-gzip\0"	pointer
"pass bits (default 12) to compress (deprecated)\0"	pointer
"BITS_PER_CODE\0"	pointer
"bits-per-code\0"	pointer
"12\0"	pointer
"Specifying file encoding methodology:\0"	pointer
"decide uuencoding for each file\0"	pointer
"MIXED_UUENCODE\0"	pointer
"mixed-uuencode\0"	pointer
"treat all files as binary\0"	pointer
"UUENCODE\0"	pointer
"uuencode\0"	pointer
"treat all files as text\0"	pointer
"TEXT_FILES\0"	pointer
"text-files\0"	pointer
"Specifying file selection and output modes:\0"	pointer
"print output to file PREFIX.nn\0"	pointer
"OUTPUT_PREFIX\0"	pointer
"output-prefix\0"	pointer
"split archive, not files, to size\0"	pointer
"WHOLE_SIZE_LIMIT\0"	pointer
"whole-size-limit\0"	pointer
"split archive or files to size\0"	pointer
"SPLIT_SIZE_LIMIT\0"	pointer
"split-size-limit\0"	pointer
"read file list from a file\0"	pointer
"INPUT_FILE_LIST\0"	pointer
"input-file-list\0"	pointer
"read file list from standard input (deprecated)\0"	pointer
"STDIN_FILE_LIST\0"	pointer
"stdin-file-list\0"	pointer
"Controlling the shar headers:\0"	pointer
"use name to document the archive\0"	pointer
"ARCHIVE_NAME\0"	pointer
"archive-name\0"	pointer
"override the submitter name\0"	pointer
"SUBMITTER\0"	pointer
"submitter\0"	pointer
"output Submitted-by: & Archive-name: headers\0"	pointer
"NET_HEADERS\0"	pointer
"net-headers\0"	pointer
"start the shar with a cut line\0"	pointer
"CUT_MARK\0"	pointer
"cut-mark\0"	pointer
"translate messages in the script\0"	pointer
"TRANSLATE\0"	pointer
"translate\0"	pointer
"Protecting against transmission issues:\0"	pointer
"do not use `wc -c' to check size\0"	pointer
"NO_CHARACTER_COUNT\0"	pointer
"no-character-count\0"	pointer
"do not use md5sum digest to verify\0"	pointer
"NO_MD5_DIGEST\0"	pointer
"no-md5-digest\0"	pointer
"apply the prefix character on every line\0"	pointer
"FORCE_PREFIX\0"	pointer
"force-prefix\0"	pointer
"use delim to delimit the files\0"	pointer
"HERE_DELIMITER\0"	pointer
"here-delimiter\0"	pointer
"SHAR_EOF\0"	pointer
"Producing different kinds of shars:\0"	pointer
"produce very simple shars\0"	pointer
"VANILLA_OPERATION\0"	pointer
"vanilla-operation\0"	pointer
"use temporary files between programs\0"	pointer
"NO_PIPING\0"	pointer
"no-piping\0"	pointer
"blindly overwrite existing files\0"	pointer
"NO_CHECK_EXISTING\0"	pointer
"no-check-existing\0"	pointer
"ask user before overwriting files\0"	pointer
"QUERY_USER\0"	pointer
"query-user\0"	pointer
"do not restore modification times\0"	pointer
"NO_TIMESTAMP\0"	pointer
"no-timestamp\0"	pointer
"avoid verbose messages at unshar time\0"	pointer
"QUIET_UNSHAR\0"	pointer
"quiet-unshar\0"	pointer
"restore in one directory, despite hierarchy\0"	pointer
"BASENAME\0"	pointer
"basename\0"	pointer
"Internationalization options:\0"	pointer
"do not internationalize\0"	pointer
"NO_I18N\0"	pointer
"no-i18n\0"	pointer
"print directory with shar messages\0"	pointer
"PRINT_TEXT_DOMAIN_DIR\0"	pointer
"print-text-domain-dir\0"	pointer
"User feedback/entertainment:\0"	pointer
"do not output verbose messages\0"	pointer
"QUIET\0"	pointer
"quiet\0"	pointer
"an alias for the 'quiet' option\0"	pointer
"silent\0"	pointer
"display extended usage information and exit\0"	pointer
"help\0"	pointer
"extended usage information passed thru pager\0"	pointer
"more-help\0"	pointer
"output version information and exit\0"	pointer
"version\0"	pointer
"save the option state to a config file\0"	pointer
"save-opts\0"	pointer
"load options from a config file\0"	pointer
"LOAD_OPTS\0"	pointer
"no-load-opts\0"	pointer
"no\0"	pointer
"SHAR\0"	pointer
"shar (GNU sharutils) - create a shell archive\n"	pointer
"Usage:  %s [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [<file>...]\n\0"	pointer
"$HOME\0"	pointer
".sharrc\0"	pointer
"bug-gnu-utils@gnu.org\0"	pointer
"If no 'file's are specified, the list of input files is read from standard\n"	pointer
"input.  Standard input must not be a terminal.\n\0"	pointer
"'shar' creates \"shell archives\" (or shar files) which are in text format\n"	pointer
"and can be emailed.  These files may be unpacked later by executing them\n"	pointer
"with '/bin/sh'.  The resulting archive is sent to standard out unless the\n"	pointer
"'-o' option is given.  A wide range of features provide extensive\n"	pointer
"flexibility in manufacturing shars and in specifying 'shar' \"smartness\".\n"	pointer
"Archives may be fairly simple ('--vanilla-operation') or essentially a\n"	pointer
"mailable 'tar' archive.\n\n"	pointer
"Options may be specified in any order until a 'file' argument is\n"	pointer
"recognized.  If the '--intermix-type' option has been specified, more\n"	pointer
"compression and encoding options will be recognized between the 'file'\n"	pointer
"arguments.\n\n"	pointer
"Though this program supports 'uuencode'-d files, they are deprecated.  If\n"	pointer
"you are emailing files, please consider mime-encoded files.  If you do\n"	pointer
"'uuencode', base64 is the preferred encoding method.\n\0"	pointer
"shar (GNU sharutils) 4.15\0"	pointer
"shar (GNU sharutils) - create a shell archive\n"	pointer
"Usage:  shar [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [<file>...]\n\n"	pointer
"Specify compression:\n"	pointer
"   -p, --intermix-type        specify compression for input files\n"	pointer
"                                - prohibits the option 'vanilla-operation'\n"	pointer
"   -C, --compactor=PROG       specify compaction (compression) program PROG\n"	pointer
"                                - prohibits the option 'vanilla-operation'\n"	pointer
"                                - may appear multiple times\n"	pointer
"                                - it must be known to shar: xz gzip bzip2\n"	pointer
"   -g, --level-of-compression=LEVEL\n"	pointer
"                              pass LEVEL for compression\n"	pointer
"                                - it must be in the range: 1 to 9\n\n"	pointer
"Specify file encoding methodology:\n"	pointer
"   -M, --mixed-uuencode       decide uuencoding for each file\n"	pointer
"   -B, --uuencode             treat all files as binary\n"	pointer
"                                - an alternate for mixed-uuencode\n"	pointer
"   -T, --text-files           treat all files as text\n"	pointer
"                                - an alternate for mixed-uuencode\n\n"	pointer
"Specifying file selection and output modes:\n"	pointer
"   -o, --output-prefix=str    print output to file PREFIX.nn\n"	pointer
"   -l, --whole-size-limit=SIZE\n"	pointer
"                              split archive, not files, to SIZE\n"	pointer
"                                - requires the option 'output-prefix'\n"	pointer
"                                - is scalable with a suffix: k/K/m/M/g/G/t/T\n"	pointer
"                                - it must lie in one of the ranges:\n"	pointer
"                                  8 to 1023, or 8192 to 4194304\n"	pointer
"   -L, --split-size-limit=SIZE\n"	pointer
"                              split archive or files to SIZE\n"	pointer
"                                - requires the option 'output-prefix'\n"	pointer
"                                - is scalable with a suffix: k/K/m/M/g/G/t/T\n"	pointer
"                                - it must lie in one of the ranges:\n"	pointer
"                                  8 to 1023, or 8192 to 4194304\n"	pointer
"                                - an alternate for 'whole-size-limit'\n"	pointer
"   -I, --input-file-list=FILE read file list from FILE\n\n"	pointer
"Controlling the shar headers:\n"	pointer
"   -n, --archive-name=NAME    use NAME to document the archive\n"	pointer
"   -s, --submitter=NAME       override the submitter name with NAME\n"	pointer
"   -a, --net-headers          output Submitted-by: & Archive-name: headers\n"	pointer
"                                - requires the option 'archive-name'\n"	pointer
"   -c, --cut-mark             start the shar with a cut line\n"	pointer
"   -t, --translate            translate messages in the script\n\n"	pointer
"Protecting against transmission issues:\n"	pointer
"       --no-character-count   do not use `wc -c' to check size\n"	pointer
"   -D, --no-md5-digest        do not use md5sum digest to verify\n"	pointer
"   -F, --force-prefix         apply the prefix character on every line\n"	pointer
"   -d, --here-delimiter=DELIM use DELIM to delimit the files\n\n"	pointer
"Producing different kinds of shars:\n"	pointer
"   -V, --vanilla-operation    produce very simple shars\n"	pointer
"   -P, --no-piping            use temporary files between programs\n"	pointer
"   -x, --no-check-existing    blindly overwrite existing files\n"	pointer
"   -X, --query-user           ask user before overwriting files\n"	pointer
"                                - prohibits the option 'vanilla-operation'\n"	pointer
"   -m, --no-timestamp         do not restore modification times\n"	pointer
"   -Q, --quiet-unshar         avoid verbose messages at unshar time\n"	pointer
"   -f, --basename             restore in one directory, despite hierarchy\n\n"	pointer
"Internationalization options:\n"	pointer
"       --no-i18n              do not internationalize\n"	pointer
"       --print-text-domain-dir  print directory with shar messages\n\n"	pointer
"User feedback/entertainment:\n"	pointer
"   -q, --quiet                do not output verbose messages\n"	pointer
"       --silent               an alias for the 'quiet' option\n\n"	pointer
"Version, usage and configuration options:\n"	pointer
"   -v, --version[=MODE]       output version information and exit\n"	pointer
"   -h, --help                 display extended usage information and exit\n"	pointer
"   -!, --more-help            extended usage information passed thru pager\n"	pointer
"   -R, --save-opts[=FILE]     save the option state to a config file FILE\n"	pointer
"   -r, --load-opts=FILE       load options from the config file FILE\n"	pointer
"                                - disabled with '--no-load-opts'\n"	pointer
"                                - may appear multiple times\n\n"	pointer
"Options are specified by doubled hyphens and their name or by a single\n"	pointer
"hyphen and the flag character.\n"	pointer
"If no 'file's are specified, the list of input files is read from a\n"	pointer
"standard input.  Standard input must not be a terminal.\n\n"	pointer
"The following option preset mechanisms are supported:\n"	pointer
" - reading file $HOME/.sharrc\n\n"	pointer
"'shar' creates \"shell archives\" (or shar files) which are in text format\n"	pointer
"and can be emailed.  These files may be unpacked later by executing them\n"	pointer
"with '/bin/sh'.  The resulting archive is sent to standard out unless the\n"	pointer
"'-o' option is given.  A wide range of features provide extensive\n"	pointer
"flexibility in manufacturing shars and in specifying 'shar' \"smartness\".\n"	pointer
"Archives may be fairly simple ('--vanilla-operation') or essentially a\n"	pointer
"mailable 'tar' archive.\n\n"	pointer
"Options may be specified in any order until a 'file' argument is\n"	pointer
"recognized.  If the '--intermix-type' option has been specified, more\n"	pointer
"compression and encoding options will be recognized between the 'file'\n"	pointer
"arguments.\n\n"	pointer
"Though this program supports 'uuencode'-d files, they are deprecated.  If\n"	pointer
"you are emailing files, please consider mime-encoded files.  If you do\n"	pointer
"'uuencode', base64 is the preferred encoding method.\n\n"	pointer
"Please send bug reports to:  <bug-gnu-utils@gnu.org>\n\0"	pointer
"shar (GNU sharutils) - create a shell archive\n"	pointer
"Usage:  shar [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [<file>...]\n"	pointer
"Try 'shar --help' for more information.\n"	pointer
;	O
static	O
int	O
const	O
aIntermix_TypeCantList	array
[	O
]	O
=	O
{	O
INDEX_OPT_VANILLA_OPERATION	int
,	O
NO_EQUIVALENT	O
}	O
;	O
static	O
int	O
const	O
aCompactorCantList	array
[	O
]	O
=	O
{	O
INDEX_OPT_VANILLA_OPERATION	int
,	O
NO_EQUIVALENT	O
}	O
;	O
static	O
int	O
const	O
aWhole_Size_LimitMustList	array
[	O
]	O
=	O
{	O
INDEX_OPT_OUTPUT_PREFIX	int
,	O
NO_EQUIVALENT	O
}	O
;	O
static	O
int	O
const	O
aSplit_Size_LimitMustList	array
[	O
]	O
=	O
{	O
INDEX_OPT_OUTPUT_PREFIX	int
,	O
NO_EQUIVALENT	O
}	O
;	O
static	O
int	O
const	O
aNet_HeadersMustList	array
[	O
]	O
=	O
{	O
INDEX_OPT_ARCHIVE_NAME	int
,	O
NO_EQUIVALENT	O
}	O
;	O
static	O
int	O
const	O
aQuery_UserCantList	array
[	O
]	O
=	O
{	O
INDEX_OPT_VANILLA_OPERATION	int
,	O
NO_EQUIVALENT	O
}	O
;	O
extern	O
tOptProc	function
check_intermixing	function
,	O
optionBooleanVal	function
,	O
optionNestedVal	function
,	O
optionNumericVal	function
,	O
optionPagedUsage	function
,	O
optionPrintVersion	function
,	O
optionResetOpt	function
,	O
optionStackArg	function
,	O
optionTimeDate	function
,	O
optionTimeVal	function
,	O
optionUnstackArg	function
,	O
optionVendorOption	function
,	O
set_compaction	function
,	O
validate_opt_context	function
;	O
static	O
tOptProc	function
doOptBzip2	function
,	O
doOptGzip	function
,	O
doOptInput_File_List	function
,	O
doOptLevel_For_Gzip	function
,	O
doOptLevel_Of_Compression	function
,	O
doOptPrint_Text_Domain_Dir	function
,	O
doOptSilent	function
,	O
doOptSplit_Size_Limit	function
,	O
doOptStdin_File_List	function
,	O
doOptVanilla_Operation	function
,	O
doOptWhole_Size_Limit	function
,	O
doUsageOpt	function
;	O
static	O
tOptDesc	struct
optDesc	array
[	O
OPTION_CT	int
]	O
=	O
{	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
COMPRESSION_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
COMPRESSION_DESC	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
1	int
,	O
VALUE_OPT_INTERMIX_TYPE	char
,	O
1	int
,	O
VALUE_OPT_INTERMIX_TYPE	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
INTERMIX_TYPE_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
aIntermix_TypeCantList	array
,	O
validate_opt_context	function
,	O
INTERMIX_TYPE_DESC	O
,	O
INTERMIX_TYPE_NAME	O
,	O
INTERMIX_TYPE_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
2	int
,	O
VALUE_OPT_COMPACTOR	char
,	O
2	int
,	O
VALUE_OPT_COMPACTOR	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
NOLIMIT	O
,	O
0	int
,	O
COMPACTOR_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
aCompactorCantList	array
,	O
set_compaction	function
,	O
COMPACTOR_DESC	O
,	O
COMPACTOR_NAME	O
,	O
COMPACTOR_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
3	int
,	O
VALUE_OPT_LEVEL_OF_COMPRESSION	char
,	O
3	int
,	O
VALUE_OPT_LEVEL_OF_COMPRESSION	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
LEVEL_OF_COMPRESSION_FLAGS	O
,	O
0	int
,	O
{	O
LEVEL_OF_COMPRESSION_DFT_ARG	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
doOptLevel_Of_Compression	function
,	O
LEVEL_OF_COMPRESSION_DESC	O
,	O
LEVEL_OF_COMPRESSION_NAME	O
,	O
LEVEL_OF_COMPRESSION_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
4	int
,	O
VALUE_OPT_BZIP2	char
,	O
4	int
,	O
VALUE_OPT_BZIP2	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
NOLIMIT	O
,	O
0	int
,	O
BZIP2_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
doOptBzip2	function
,	O
BZIP2_DESC	O
,	O
BZIP2_NAME	O
,	O
BZIP2_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
5	int
,	O
VALUE_OPT_GZIP	char
,	O
5	int
,	O
VALUE_OPT_GZIP	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
NOLIMIT	O
,	O
0	int
,	O
GZIP_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
doOptGzip	function
,	O
GZIP_DESC	O
,	O
GZIP_NAME	O
,	O
GZIP_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
6	int
,	O
VALUE_OPT_COMPRESS	char
,	O
6	int
,	O
VALUE_OPT_COMPRESS	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
NOLIMIT	O
,	O
0	int
,	O
COMPRESS_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
doOptCompress	O
,	O
COMPRESS_DESC	O
,	O
COMPRESS_NAME	O
,	O
COMPRESS_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
7	int
,	O
VALUE_OPT_LEVEL_FOR_GZIP	int
,	O
7	int
,	O
VALUE_OPT_LEVEL_FOR_GZIP	int
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
LEVEL_FOR_GZIP_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
doOptLevel_For_Gzip	function
,	O
LEVEL_FOR_GZIP_DESC	O
,	O
LEVEL_FOR_GZIP_NAME	O
,	O
LEVEL_FOR_GZIP_name	O
,	O
0	int
,	O
0	int
}	O
,	O
{	O
8	int
,	O
VALUE_OPT_BITS_PER_CODE	char
,	O
8	int
,	O
VALUE_OPT_BITS_PER_CODE	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
BITS_PER_CODE_FLAGS	O
,	O
0	int
,	O
{	O
BITS_PER_CODE_DFT_ARG	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
doOptBits_Per_Code	O
,	O
BITS_PER_CODE_DESC	O
,	O
BITS_PER_CODE_NAME	O
,	O
BITS_PER_CODE_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
ENCODING_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
ENCODING_DESC	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
10	int
,	O
VALUE_OPT_MIXED_UUENCODE	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
MIXED_UUENCODE_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
check_intermixing	function
,	O
MIXED_UUENCODE_DESC	O
,	O
MIXED_UUENCODE_NAME	O
,	O
MIXED_UUENCODE_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
11	int
,	O
VALUE_OPT_UUENCODE	char
,	O
NOLIMIT	O
,	O
NOLIMIT	O
,	O
INDEX_OPT_MIXED_UUENCODE	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
UUENCODE_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
check_intermixing	function
,	O
UUENCODE_DESC	O
,	O
UUENCODE_NAME	O
,	O
UUENCODE_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
12	int
,	O
VALUE_OPT_TEXT_FILES	char
,	O
NOLIMIT	O
,	O
NOLIMIT	O
,	O
INDEX_OPT_MIXED_UUENCODE	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
TEXT_FILES_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
check_intermixing	function
,	O
TEXT_FILES_DESC	O
,	O
TEXT_FILES_NAME	O
,	O
TEXT_FILES_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
IN_OUT_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
IN_OUT_DESC	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
14	int
,	O
VALUE_OPT_OUTPUT_PREFIX	char
,	O
14	int
,	O
VALUE_OPT_OUTPUT_PREFIX	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
OUTPUT_PREFIX_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
validate_opt_context	function
,	O
OUTPUT_PREFIX_DESC	O
,	O
OUTPUT_PREFIX_NAME	O
,	O
OUTPUT_PREFIX_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
15	int
,	O
VALUE_OPT_WHOLE_SIZE_LIMIT	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
WHOLE_SIZE_LIMIT_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
aWhole_Size_LimitMustList	array
,	O
NULL	O
,	O
doOptWhole_Size_Limit	function
,	O
WHOLE_SIZE_LIMIT_DESC	O
,	O
WHOLE_SIZE_LIMIT_NAME	O
,	O
WHOLE_SIZE_LIMIT_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
16	int
,	O
VALUE_OPT_SPLIT_SIZE_LIMIT	char
,	O
NOLIMIT	O
,	O
NOLIMIT	O
,	O
INDEX_OPT_WHOLE_SIZE_LIMIT	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
SPLIT_SIZE_LIMIT_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
aSplit_Size_LimitMustList	array
,	O
NULL	O
,	O
doOptSplit_Size_Limit	function
,	O
SPLIT_SIZE_LIMIT_DESC	O
,	O
SPLIT_SIZE_LIMIT_NAME	O
,	O
SPLIT_SIZE_LIMIT_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
17	int
,	O
VALUE_OPT_INPUT_FILE_LIST	char
,	O
17	int
,	O
VALUE_OPT_INPUT_FILE_LIST	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
INPUT_FILE_LIST_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
doOptInput_File_List	function
,	O
INPUT_FILE_LIST_DESC	O
,	O
INPUT_FILE_LIST_NAME	O
,	O
INPUT_FILE_LIST_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
18	int
,	O
VALUE_OPT_STDIN_FILE_LIST	char
,	O
18	int
,	O
VALUE_OPT_STDIN_FILE_LIST	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
STDIN_FILE_LIST_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
doOptStdin_File_List	function
,	O
STDIN_FILE_LIST_DESC	O
,	O
STDIN_FILE_LIST_NAME	O
,	O
STDIN_FILE_LIST_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
HEADERS_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
HEADERS_DESC	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
20	int
,	O
VALUE_OPT_ARCHIVE_NAME	char
,	O
20	int
,	O
VALUE_OPT_ARCHIVE_NAME	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
ARCHIVE_NAME_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
validate_opt_context	function
,	O
ARCHIVE_NAME_DESC	O
,	O
ARCHIVE_NAME_NAME	O
,	O
ARCHIVE_NAME_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
21	int
,	O
VALUE_OPT_SUBMITTER	char
,	O
21	int
,	O
VALUE_OPT_SUBMITTER	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
SUBMITTER_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
validate_opt_context	function
,	O
SUBMITTER_DESC	O
,	O
SUBMITTER_NAME	O
,	O
SUBMITTER_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
22	int
,	O
VALUE_OPT_NET_HEADERS	char
,	O
22	int
,	O
VALUE_OPT_NET_HEADERS	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
NET_HEADERS_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
aNet_HeadersMustList	array
,	O
NULL	O
,	O
validate_opt_context	function
,	O
NET_HEADERS_DESC	O
,	O
NET_HEADERS_NAME	O
,	O
NET_HEADERS_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
23	int
,	O
VALUE_OPT_CUT_MARK	char
,	O
23	int
,	O
VALUE_OPT_CUT_MARK	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
CUT_MARK_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
validate_opt_context	function
,	O
CUT_MARK_DESC	O
,	O
CUT_MARK_NAME	O
,	O
CUT_MARK_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
24	int
,	O
VALUE_OPT_TRANSLATE	char
,	O
24	int
,	O
VALUE_OPT_TRANSLATE	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
TRANSLATE_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
validate_opt_context	function
,	O
TRANSLATE_DESC	O
,	O
TRANSLATE_NAME	O
,	O
TRANSLATE_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
XMIT_DEFENSES_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
XMIT_DEFENSES_DESC	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
26	int
,	O
VALUE_OPT_NO_CHARACTER_COUNT	int
,	O
26	int
,	O
VALUE_OPT_NO_CHARACTER_COUNT	int
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
NO_CHARACTER_COUNT_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
validate_opt_context	function
,	O
NO_CHARACTER_COUNT_DESC	O
,	O
NO_CHARACTER_COUNT_NAME	O
,	O
NO_CHARACTER_COUNT_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
27	int
,	O
VALUE_OPT_NO_MD5_DIGEST	char
,	O
27	int
,	O
VALUE_OPT_NO_MD5_DIGEST	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
NO_MD5_DIGEST_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
validate_opt_context	function
,	O
NO_MD5_DIGEST_DESC	O
,	O
NO_MD5_DIGEST_NAME	O
,	O
NO_MD5_DIGEST_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
28	int
,	O
VALUE_OPT_FORCE_PREFIX	char
,	O
28	int
,	O
VALUE_OPT_FORCE_PREFIX	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
FORCE_PREFIX_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
validate_opt_context	function
,	O
FORCE_PREFIX_DESC	O
,	O
FORCE_PREFIX_NAME	O
,	O
FORCE_PREFIX_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
29	int
,	O
VALUE_OPT_HERE_DELIMITER	char
,	O
29	int
,	O
VALUE_OPT_HERE_DELIMITER	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
HERE_DELIMITER_FLAGS	O
,	O
0	int
,	O
{	O
HERE_DELIMITER_DFT_ARG	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
validate_opt_context	function
,	O
HERE_DELIMITER_DESC	O
,	O
HERE_DELIMITER_NAME	O
,	O
HERE_DELIMITER_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
SHAR_FLAVORS_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
SHAR_FLAVORS_DESC	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
31	int
,	O
VALUE_OPT_VANILLA_OPERATION	char
,	O
31	int
,	O
VALUE_OPT_VANILLA_OPERATION	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
VANILLA_OPERATION_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
doOptVanilla_Operation	function
,	O
VANILLA_OPERATION_DESC	O
,	O
VANILLA_OPERATION_NAME	O
,	O
VANILLA_OPERATION_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
32	int
,	O
VALUE_OPT_NO_PIPING	char
,	O
32	int
,	O
VALUE_OPT_NO_PIPING	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
NO_PIPING_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
validate_opt_context	function
,	O
NO_PIPING_DESC	O
,	O
NO_PIPING_NAME	O
,	O
NO_PIPING_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
33	int
,	O
VALUE_OPT_NO_CHECK_EXISTING	char
,	O
33	int
,	O
VALUE_OPT_NO_CHECK_EXISTING	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
NO_CHECK_EXISTING_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
validate_opt_context	function
,	O
NO_CHECK_EXISTING_DESC	O
,	O
NO_CHECK_EXISTING_NAME	O
,	O
NO_CHECK_EXISTING_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
34	int
,	O
VALUE_OPT_QUERY_USER	char
,	O
34	int
,	O
VALUE_OPT_QUERY_USER	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
QUERY_USER_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
aQuery_UserCantList	array
,	O
validate_opt_context	function
,	O
QUERY_USER_DESC	O
,	O
QUERY_USER_NAME	O
,	O
QUERY_USER_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
35	int
,	O
VALUE_OPT_NO_TIMESTAMP	char
,	O
35	int
,	O
VALUE_OPT_NO_TIMESTAMP	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
NO_TIMESTAMP_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
validate_opt_context	function
,	O
NO_TIMESTAMP_DESC	O
,	O
NO_TIMESTAMP_NAME	O
,	O
NO_TIMESTAMP_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
36	int
,	O
VALUE_OPT_QUIET_UNSHAR	char
,	O
36	int
,	O
VALUE_OPT_QUIET_UNSHAR	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
QUIET_UNSHAR_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
validate_opt_context	function
,	O
QUIET_UNSHAR_DESC	O
,	O
QUIET_UNSHAR_NAME	O
,	O
QUIET_UNSHAR_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
37	int
,	O
VALUE_OPT_BASENAME	char
,	O
37	int
,	O
VALUE_OPT_BASENAME	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
BASENAME_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
validate_opt_context	function
,	O
BASENAME_DESC	O
,	O
BASENAME_NAME	O
,	O
BASENAME_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
INTERNATIONALIZATION_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
INTERNATIONALIZATION_DESC	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
39	int
,	O
VALUE_OPT_NO_I18N	int
,	O
39	int
,	O
VALUE_OPT_NO_I18N	int
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
NO_I18N_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
validate_opt_context	function
,	O
NO_I18N_DESC	O
,	O
NO_I18N_NAME	O
,	O
NO_I18N_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
40	int
,	O
VALUE_OPT_PRINT_TEXT_DOMAIN_DIR	int
,	O
40	int
,	O
VALUE_OPT_PRINT_TEXT_DOMAIN_DIR	int
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
PRINT_TEXT_DOMAIN_DIR_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
doOptPrint_Text_Domain_Dir	function
,	O
PRINT_TEXT_DOMAIN_DIR_DESC	O
,	O
PRINT_TEXT_DOMAIN_DIR_NAME	O
,	O
PRINT_TEXT_DOMAIN_DIR_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
FEEDBACK_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
FEEDBACK_DESC	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
42	int
,	O
VALUE_OPT_QUIET	char
,	O
42	int
,	O
VALUE_OPT_QUIET	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
QUIET_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
validate_opt_context	function
,	O
QUIET_DESC	O
,	O
QUIET_NAME	O
,	O
QUIET_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
43	int
,	O
VALUE_OPT_SILENT	int
,	O
43	int
,	O
VALUE_OPT_SILENT	int
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
SILENT_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
doOptSilent	function
,	O
SILENT_DESC	O
,	O
SILENT_NAME	O
,	O
SILENT_name	O
,	O
0	int
,	O
0	int
}	O
,	O
{	O
INDEX_OPT_VERSION	int
,	O
VALUE_OPT_VERSION	char
,	O
NO_EQUIVALENT	O
,	O
VALUE_OPT_VERSION	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
VER_FLAGS	O
,	O
AOUSE_VERSION	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
VER_PROC	O
,	O
VER_DESC	O
,	O
NULL	O
,	O
VER_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
INDEX_OPT_HELP	int
,	O
VALUE_OPT_HELP	char
,	O
NO_EQUIVALENT	O
,	O
VALUE_OPT_HELP	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
OPTST_IMM	int
|	O
OPTST_NO_INIT	int
,	O
AOUSE_HELP	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
doUsageOpt	function
,	O
HELP_DESC	O
,	O
NULL	O
,	O
HELP_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
INDEX_OPT_MORE_HELP	int
,	O
VALUE_OPT_MORE_HELP	char
,	O
NO_EQUIVALENT	O
,	O
VALUE_OPT_MORE_HELP	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
MORE_HELP_FLAGS	O
,	O
AOUSE_MORE_HELP	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
optionPagedUsage	function
,	O
MORE_HELP_DESC	O
,	O
NULL	O
,	O
MORE_HELP_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
INDEX_OPT_SAVE_OPTS	int
,	O
VALUE_OPT_SAVE_OPTS	char
,	O
NO_EQUIVALENT	O
,	O
VALUE_OPT_SAVE_OPTS	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
OPTST_SET_ARGTYPE	O
(	O
OPARG_TYPE_STRING	int
)	O
|	O
OPTST_ARG_OPTIONAL	int
|	O
OPTST_NO_INIT	int
,	O
AOUSE_SAVE_OPTS	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
SAVE_OPTS_DESC	O
,	O
NULL	O
,	O
SAVE_OPTS_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
INDEX_OPT_LOAD_OPTS	int
,	O
VALUE_OPT_LOAD_OPTS	char
,	O
NO_EQUIVALENT	O
,	O
VALUE_OPT_LOAD_OPTS	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
NOLIMIT	O
,	O
0	int
,	O
OPTST_SET_ARGTYPE	O
(	O
OPARG_TYPE_STRING	int
)	O
|	O
OPTST_DISABLE_IMM	int
,	O
AOUSE_LOAD_OPTS	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
optionLoadOpt	function
,	O
LOAD_OPTS_DESC	O
,	O
LOAD_OPTS_NAME	O
,	O
LOAD_OPTS_name	O
,	O
NO_LOAD_OPTS_name	O
,	O
LOAD_OPTS_pfx	O
}	O
}	O
;	O
static	O
char	O
const	O
*	O
const	O
apzHomeList	array
[	O
2	int
]	O
=	O
{	O
shar_opt_strs	array
+	O
3699	int
,	O
NULL	O
}	O
;	O
static	O
tOptionXlateProc	function
translate_option_strings	function
;	O
static	O
void	O
doUsageOpt	function
(	O
tOptions	struct
*	O
opts	pointer
,	O
tOptDesc	struct
*	O
od	pointer
)	O
{	O
int	O
ex_code	int
;	O
ex_code	int
=	O
SHAR_EXIT_SUCCESS	int
;	O
optionUsage	function
(	O
&	O
sharOptions	struct
,	O
ex_code	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
(	O
void	O
)	O
opts	pointer
;	O
(	O
void	O
)	O
od	pointer
;	O
}	O
static	O
void	O
doOptLevel_Of_Compression	function
(	O
tOptions	struct
*	O
pOptions	pointer
,	O
tOptDesc	struct
*	O
pOptDesc	pointer
)	O
{	O
static	O
struct	O
{	O
long	O
rmin	long
,	O
rmax	long
;	O
}	O
const	O
rng	array
[	O
1	int
]	O
=	O
{	O
{	O
1	int
,	O
9	int
}	O
}	O
;	O
int	O
ix	int
;	O
if	O
(	O
pOptions	pointer
<=	O
OPTPROC_EMIT_LIMIT	O
)	O
goto	O
emit_ranges	O
;	O
optionNumericVal	function
(	O
pOptions	pointer
,	O
pOptDesc	pointer
)	O
;	O
for	O
(	O
ix	int
=	O
0	int
;	O
ix	int
<	O
1	int
;	O
ix	int
++	O
)	O
{	O
if	O
(	O
pOptDesc	pointer
->	O
optArg	union
.	O
argInt	long
<	O
rng	array
[	O
ix	int
]	O
.	O
rmin	long
)	O
continue	O
;	O
if	O
(	O
pOptDesc	pointer
->	O
optArg	union
.	O
argInt	long
==	O
rng	array
[	O
ix	int
]	O
.	O
rmin	long
)	O
return	O
;	O
if	O
(	O
rng	array
[	O
ix	int
]	O
.	O
rmax	long
==	O
LONG_MIN	O
)	O
continue	O
;	O
if	O
(	O
pOptDesc	pointer
->	O
optArg	union
.	O
argInt	long
<=	O
rng	array
[	O
ix	int
]	O
.	O
rmax	long
)	O
return	O
;	O
}	O
option_usage_fp	pointer
=	O
stderr	pointer
;	O
emit_ranges	O
:	O
optionShowRange	function
(	O
pOptions	pointer
,	O
pOptDesc	pointer
,	O
VOIDP	O
(	O
rng	array
)	O
,	O
1	int
)	O
;	O
}	O
static	O
void	O
doOptBzip2	function
(	O
tOptions	struct
*	O
pOptions	pointer
,	O
tOptDesc	struct
*	O
pOptDesc	pointer
)	O
{	O
SET_OPT_COMPACTOR	O
(	O
"bzip2"	pointer
)	O
;	O
(	O
void	O
)	O
pOptDesc	pointer
;	O
(	O
void	O
)	O
pOptions	pointer
;	O
}	O
static	O
void	O
doOptGzip	function
(	O
tOptions	struct
*	O
pOptions	pointer
,	O
tOptDesc	struct
*	O
pOptDesc	pointer
)	O
{	O
SET_OPT_COMPACTOR	O
(	O
"gzip"	pointer
)	O
;	O
(	O
void	O
)	O
pOptDesc	pointer
;	O
(	O
void	O
)	O
pOptions	pointer
;	O
}	O
static	O
void	O
doOptLevel_For_Gzip	function
(	O
tOptions	struct
*	O
pOptions	pointer
,	O
tOptDesc	struct
*	O
pOptDesc	pointer
)	O
{	O
int	O
res	int
=	O
optionAlias	function
(	O
pOptions	pointer
,	O
pOptDesc	pointer
,	O
INDEX_OPT_LEVEL_OF_COMPRESSION	int
)	O
;	O
if	O
(	O
(	O
res	int
!=	O
0	int
)	O
&&	O
(	O
(	O
pOptions	pointer
->	O
fOptSet	int
&	O
OPTPROC_ERRSTOP	int
)	O
!=	O
0	int
)	O
)	O
USAGE	O
(	O
SHAR_EXIT_USAGE_ERROR	int
)	O
;	O
}	O
static	O
void	O
doOptWhole_Size_Limit	function
(	O
tOptions	struct
*	O
pOptions	pointer
,	O
tOptDesc	struct
*	O
pOptDesc	pointer
)	O
{	O
static	O
struct	O
{	O
long	O
rmin	long
,	O
rmax	long
;	O
}	O
const	O
rng	array
[	O
2	int
]	O
=	O
{	O
{	O
8	int
,	O
1023	int
}	O
,	O
{	O
8192	int
,	O
4194304	int
}	O
}	O
;	O
int	O
ix	int
;	O
if	O
(	O
pOptions	pointer
<=	O
OPTPROC_EMIT_LIMIT	O
)	O
goto	O
emit_ranges	O
;	O
optionNumericVal	function
(	O
pOptions	pointer
,	O
pOptDesc	pointer
)	O
;	O
for	O
(	O
ix	int
=	O
0	int
;	O
ix	int
<	O
2	int
;	O
ix	int
++	O
)	O
{	O
if	O
(	O
pOptDesc	pointer
->	O
optArg	union
.	O
argInt	long
<	O
rng	array
[	O
ix	int
]	O
.	O
rmin	long
)	O
continue	O
;	O
if	O
(	O
pOptDesc	pointer
->	O
optArg	union
.	O
argInt	long
==	O
rng	array
[	O
ix	int
]	O
.	O
rmin	long
)	O
return	O
;	O
if	O
(	O
rng	array
[	O
ix	int
]	O
.	O
rmax	long
==	O
LONG_MIN	O
)	O
continue	O
;	O
if	O
(	O
pOptDesc	pointer
->	O
optArg	union
.	O
argInt	long
<=	O
rng	array
[	O
ix	int
]	O
.	O
rmax	long
)	O
return	O
;	O
}	O
option_usage_fp	pointer
=	O
stderr	pointer
;	O
emit_ranges	O
:	O
optionShowRange	function
(	O
pOptions	pointer
,	O
pOptDesc	pointer
,	O
VOIDP	O
(	O
rng	array
)	O
,	O
2	int
)	O
;	O
}	O
static	O
void	O
doOptSplit_Size_Limit	function
(	O
tOptions	struct
*	O
pOptions	pointer
,	O
tOptDesc	struct
*	O
pOptDesc	pointer
)	O
{	O
static	O
struct	O
{	O
long	O
rmin	long
,	O
rmax	long
;	O
}	O
const	O
rng	array
[	O
2	int
]	O
=	O
{	O
{	O
8	int
,	O
1023	int
}	O
,	O
{	O
8192	int
,	O
4194304	int
}	O
}	O
;	O
int	O
ix	int
;	O
if	O
(	O
pOptions	pointer
<=	O
OPTPROC_EMIT_LIMIT	O
)	O
goto	O
emit_ranges	O
;	O
optionNumericVal	function
(	O
pOptions	pointer
,	O
pOptDesc	pointer
)	O
;	O
for	O
(	O
ix	int
=	O
0	int
;	O
ix	int
<	O
2	int
;	O
ix	int
++	O
)	O
{	O
if	O
(	O
pOptDesc	pointer
->	O
optArg	union
.	O
argInt	long
<	O
rng	array
[	O
ix	int
]	O
.	O
rmin	long
)	O
continue	O
;	O
if	O
(	O
pOptDesc	pointer
->	O
optArg	union
.	O
argInt	long
==	O
rng	array
[	O
ix	int
]	O
.	O
rmin	long
)	O
return	O
;	O
if	O
(	O
rng	array
[	O
ix	int
]	O
.	O
rmax	long
==	O
LONG_MIN	O
)	O
continue	O
;	O
if	O
(	O
pOptDesc	pointer
->	O
optArg	union
.	O
argInt	long
<=	O
rng	array
[	O
ix	int
]	O
.	O
rmax	long
)	O
return	O
;	O
}	O
option_usage_fp	pointer
=	O
stderr	pointer
;	O
emit_ranges	O
:	O
optionShowRange	function
(	O
pOptions	pointer
,	O
pOptDesc	pointer
,	O
VOIDP	O
(	O
rng	array
)	O
,	O
2	int
)	O
;	O
}	O
static	O
void	O
doOptInput_File_List	function
(	O
tOptions	struct
*	O
pOptions	pointer
,	O
tOptDesc	struct
*	O
pOptDesc	pointer
)	O
{	O
char	O
const	O
*	O
fnm	pointer
=	O
pOptDesc	pointer
->	O
optArg	union
.	O
argString	pointer
;	O
validate_opt_context	function
(	O
pOptions	pointer
,	O
pOptDesc	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
fnm	pointer
,	O
"-"	pointer
)	O
!=	O
0	int
)	O
{	O
FILE	struct
*	O
fp	pointer
=	O
freopen	function
(	O
fnm	pointer
,	O
"r"	pointer
,	O
stdin	pointer
)	O
;	O
if	O
(	O
fp	pointer
!=	O
stdin	pointer
)	O
usage_message	function
(	O
_	O
(	O
"Cannot reopen %s as stdin"	pointer
)	O
,	O
fnm	pointer
)	O
;	O
}	O
}	O
static	O
void	O
doOptStdin_File_List	function
(	O
tOptions	struct
*	O
pOptions	pointer
,	O
tOptDesc	struct
*	O
pOptDesc	pointer
)	O
{	O
SET_OPT_INPUT_FILE_LIST	O
(	O
"-"	pointer
)	O
;	O
(	O
void	O
)	O
pOptDesc	pointer
;	O
(	O
void	O
)	O
pOptions	pointer
;	O
}	O
static	O
void	O
doOptVanilla_Operation	function
(	O
tOptions	struct
*	O
pOptions	pointer
,	O
tOptDesc	struct
*	O
pOptDesc	pointer
)	O
{	O
validate_opt_context	function
(	O
pOptions	pointer
,	O
pOptDesc	pointer
)	O
;	O
SET_OPT_NO_CHARACTER_COUNT	O
;	O
SET_OPT_NO_TIMESTAMP	O
;	O
SET_OPT_NO_MD5_DIGEST	O
;	O
SET_OPT_NO_I18N	O
;	O
SET_OPT_NO_PIPING	O
;	O
SET_OPT_FORCE_PREFIX	O
;	O
}	O
static	O
void	O
doOptPrint_Text_Domain_Dir	function
(	O
tOptions	struct
*	O
pOptions	pointer
,	O
tOptDesc	struct
*	O
pOptDesc	pointer
)	O
{	O
validate_opt_context	function
(	O
pOptions	pointer
,	O
pOptDesc	pointer
)	O
;	O
puts	function
(	O
LOCALEDIR	O
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
static	O
void	O
doOptSilent	function
(	O
tOptions	struct
*	O
pOptions	pointer
,	O
tOptDesc	struct
*	O
pOptDesc	pointer
)	O
{	O
int	O
res	int
=	O
optionAlias	function
(	O
pOptions	pointer
,	O
pOptDesc	pointer
,	O
INDEX_OPT_QUIET	int
)	O
;	O
if	O
(	O
(	O
res	int
!=	O
0	int
)	O
&&	O
(	O
(	O
pOptions	pointer
->	O
fOptSet	int
&	O
OPTPROC_ERRSTOP	int
)	O
!=	O
0	int
)	O
)	O
USAGE	O
(	O
SHAR_EXIT_USAGE_ERROR	int
)	O
;	O
}	O
void	O
vusage_message	function
(	O
char	O
const	O
*	O
fmt	pointer
,	O
va_list	array
ap	array
)	O
{	O
char	O
const	O
*	O
er_leader	pointer
=	O
_	O
(	O
"shar usage error:\n"	pointer
)	O
;	O
fputs	function
(	O
er_leader	pointer
,	O
stderr	pointer
)	O
;	O
vfprintf	function
(	O
stderr	pointer
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
optionUsage	function
(	O
&	O
sharOptions	struct
,	O
SHAR_EXIT_USAGE_ERROR	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
void	O
usage_message	function
(	O
char	O
const	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
vusage_message	function
(	O
fmt	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
}	O
void	O
vdie	function
(	O
int	O
exit_code	int
,	O
char	O
const	O
*	O
fmt	pointer
,	O
va_list	array
ap	array
)	O
{	O
char	O
const	O
*	O
die_leader	pointer
=	O
_	O
(	O
"shar fatal error:\n"	pointer
)	O
;	O
fputs	function
(	O
die_leader	pointer
,	O
stderr	pointer
)	O
;	O
vfprintf	function
(	O
stderr	pointer
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
exit	function
(	O
exit_code	int
)	O
;	O
}	O
void	O
die	function
(	O
int	O
exit_code	int
,	O
char	O
const	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
vdie	function
(	O
exit_code	int
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
}	O
void	O
fserr	function
(	O
int	O
exit_code	int
,	O
char	O
const	O
*	O
op	pointer
,	O
char	O
const	O
*	O
fname	pointer
)	O
{	O
char	O
const	O
*	O
fserr_fmt	pointer
=	O
_	O
(	O
"fserr %d (%s) performing '%s' on %s\n"	pointer
)	O
;	O
die	function
(	O
exit_code	int
,	O
fserr_fmt	pointer
,	O
errno	O
,	O
strerror	function
(	O
errno	O
)	O
,	O
op	pointer
,	O
fname	pointer
)	O
;	O
}	O
tOptions	struct
sharOptions	struct
=	O
{	O
OPTIONS_STRUCT_VERSION	int
,	O
0	int
,	O
NULL	O
,	O
(	O
OPTPROC_BASE	O
+	O
OPTPROC_ERRSTOP	int
+	O
OPTPROC_SHORTOPT	int
+	O
OPTPROC_LONGOPT	int
+	O
OPTPROC_NO_REQ_OPT	int
+	O
OPTPROC_GNUUSAGE	int
+	O
OPTPROC_MISUSE	int
)	O
,	O
0	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
zPROGNAME	O
,	O
zRcName	O
,	O
zCopyright	O
,	O
zLicenseDescrip	O
,	O
zFullVersion	O
,	O
apzHomeList	array
,	O
zUsageTitle	O
,	O
zExplain	O
,	O
zDetail	O
,	O
optDesc	array
,	O
zBugsAddr	O
,	O
NULL	O
,	O
NULL	O
,	O
optionUsage	function
,	O
translate_option_strings	function
,	O
{	O
INDEX_OPT_MORE_HELP	int
,	O
INDEX_OPT_SAVE_OPTS	int
,	O
NO_EQUIVALENT	O
,	O
NO_EQUIVALENT	O
}	O
,	O
49	int
,	O
44	int
,	O
shar_full_usage	O
,	O
shar_short_usage	O
,	O
NULL	O
,	O
NULL	O
,	O
PKGDATADIR	pointer
,	O
shar_packager_info	O
}	O
;	O
static	O
char	O
*	O
AO_gettext	function
(	O
char	O
const	O
*	O
pz	pointer
)	O
;	O
static	O
void	O
coerce_it	function
(	O
void	O
*	O
*	O
s	enum
)	O
;	O
static	O
char	O
*	O
AO_gettext	function
(	O
char	O
const	O
*	O
pz	pointer
)	O
{	O
char	O
*	O
res	int
;	O
if	O
(	O
pz	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
option_xlateable_txt	struct
.	O
field_ct	int
!=	O
0	int
)	O
{	O
res	int
=	O
dgettext	function
(	O
"libopts"	pointer
,	O
pz	pointer
)	O
;	O
if	O
(	O
res	int
==	O
pz	pointer
)	O
res	int
=	O
(	O
char	O
*	O
)	O
VOIDP	O
(	O
_	O
(	O
pz	pointer
)	O
)	O
;	O
}	O
else	O
res	int
=	O
(	O
char	O
*	O
)	O
VOIDP	O
(	O
_	O
(	O
pz	pointer
)	O
)	O
;	O
if	O
(	O
res	int
==	O
pz	pointer
)	O
return	O
res	int
;	O
res	int
=	O
strdup	function
(	O
res	int
)	O
;	O
if	O
(	O
res	int
==	O
NULL	O
)	O
{	O
fputs	function
(	O
_	O
(	O
"No memory for duping translated strings\n"	pointer
)	O
,	O
stderr	pointer
)	O
;	O
exit	function
(	O
SHAR_EXIT_OPTION_ERROR	int
)	O
;	O
}	O
return	O
res	int
;	O
}	O
static	O
void	O
coerce_it	function
(	O
void	O
*	O
*	O
s	enum
)	O
{	O
*	O
s	enum
=	O
AO_gettext	function
(	O
*	O
s	enum
)	O
;	O
}	O
static	O
void	O
translate_option_strings	function
(	O
void	O
)	O
{	O
tOptions	struct
*	O
const	O
opts	pointer
=	O
&	O
sharOptions	struct
;	O
if	O
(	O
option_xlateable_txt	struct
.	O
field_ct	int
!=	O
0	int
)	O
{	O
char	O
*	O
*	O
ppz	pointer
=	O
(	O
char	O
*	O
*	O
)	O
VOIDP	O
(	O
&	O
(	O
option_xlateable_txt	struct
)	O
)	O
;	O
int	O
ix	int
=	O
option_xlateable_txt	struct
.	O
field_ct	int
;	O
do	O
{	O
ppz	pointer
++	O
;	O
*	O
ppz	pointer
=	O
AO_gettext	function
(	O
*	O
ppz	pointer
)	O
;	O
}	O
while	O
(	O
--	O
ix	int
>	O
0	int
)	O
;	O
option_xlateable_txt	struct
.	O
field_ct	int
=	O
0	int
;	O
coerce_it	function
(	O
VOIDP	O
(	O
&	O
(	O
opts	pointer
->	O
pzCopyright	pointer
)	O
)	O
)	O
;	O
coerce_it	function
(	O
VOIDP	O
(	O
&	O
(	O
opts	pointer
->	O
pzCopyNotice	pointer
)	O
)	O
)	O
;	O
coerce_it	function
(	O
VOIDP	O
(	O
&	O
(	O
opts	pointer
->	O
pzFullVersion	pointer
)	O
)	O
)	O
;	O
}	O
}	O
