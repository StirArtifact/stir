DCHAR_T	char
*	O
VASNPRINTF	O
(	O
DCHAR_T	char
*	O
resultbuf	O
,	O
size_t	O
*	O
lengthp	O
,	O
const	O
FCHAR_T	char
*	O
format	O
,	O
va_list	O
args	O
)	O
{	O
DIRECTIVES	O
d	O
;	O
arguments	O
a	O
;	O
if	O
(	O
PRINTF_PARSE	O
(	O
format	O
,	O
&	O
d	O
,	O
&	O
a	O
)	O
<	O
0	int
)	O
return	O
NULL	O
;	O
if	O
(	O
PRINTF_FETCHARGS	O
(	O
args	O
,	O
&	O
a	O
)	O
<	O
0	int
)	O
{	O
CLEANUP	O
(	O
)	O
;	O
errno	O
=	O
EINVAL	O
;	O
return	O
NULL	O
;	O
}	O
{	O
size_t	O
buf_neededlength	O
;	O
TCHAR_T	char
*	O
buf	O
;	O
TCHAR_T	char
*	O
buf_malloced	O
;	O
const	O
FCHAR_T	char
*	O
cp	O
;	O
size_t	O
i	O
;	O
DIRECTIVE	O
*	O
dp	O
;	O
DCHAR_T	char
*	O
result	O
;	O
size_t	O
allocated	O
;	O
size_t	O
length	O
;	O
buf_neededlength	O
=	O
xsum4	O
(	O
7	int
,	O
d	O
.	O
max_width_length	O
,	O
d	O
.	O
max_precision_length	O
,	O
6	int
)	O
;	O
if	O
(	O
buf_neededlength	O
<	O
4000	int
/	O
sizeof	O
(	O
TCHAR_T	char
)	O
)	O
{	O
buf	O
=	O
(	O
TCHAR_T	char
*	O
)	O
alloca	O
(	O
buf_neededlength	O
*	O
sizeof	O
(	O
TCHAR_T	char
)	O
)	O
;	O
buf_malloced	O
=	O
NULL	O
;	O
}	O
else	O
{	O
size_t	O
buf_memsize	O
=	O
xtimes	O
(	O
buf_neededlength	O
,	O
sizeof	O
(	O
TCHAR_T	char
)	O
)	O
;	O
if	O
(	O
size_overflow_p	O
(	O
buf_memsize	O
)	O
)	O
goto	O
out_of_memory_1	O
;	O
buf	O
=	O
(	O
TCHAR_T	char
*	O
)	O
malloc	O
(	O
buf_memsize	O
)	O
;	O
if	O
(	O
buf	O
==	O
NULL	O
)	O
goto	O
out_of_memory_1	O
;	O
buf_malloced	O
=	O
buf	O
;	O
}	O
if	O
(	O
resultbuf	O
!=	O
NULL	O
)	O
{	O
result	O
=	O
resultbuf	O
;	O
allocated	O
=	O
*	O
lengthp	O
;	O
}	O
else	O
{	O
result	O
=	O
NULL	O
;	O
allocated	O
=	O
0	int
;	O
}	O
length	O
=	O
0	int
;	O
for	O
(	O
cp	O
=	O
format	O
,	O
i	O
=	O
0	int
,	O
dp	O
=	O
&	O
d	O
.	O
dir	O
[	O
0	int
]	O
;	O
;	O
cp	O
=	O
dp	O
->	O
dir_end	O
,	O
i	O
++	O
,	O
dp	O
++	O
)	O
{	O
if	O
(	O
cp	O
!=	O
dp	O
->	O
dir_start	O
)	O
{	O
size_t	O
n	O
=	O
dp	O
->	O
dir_start	O
-	O
cp	O
;	O
size_t	O
augmented_length	O
=	O
xsum	O
(	O
length	O
,	O
n	O
)	O
;	O
ENSURE_ALLOCATION	O
(	O
augmented_length	O
)	O
;	O
if	O
(	O
sizeof	O
(	O
FCHAR_T	char
)	O
==	O
sizeof	O
(	O
DCHAR_T	char
)	O
)	O
{	O
DCHAR_CPY	O
(	O
result	O
+	O
length	O
,	O
(	O
const	O
DCHAR_T	char
*	O
)	O
cp	O
,	O
n	O
)	O
;	O
length	O
=	O
augmented_length	O
;	O
}	O
else	O
{	O
do	O
result	O
[	O
length	O
++	O
]	O
=	O
*	O
cp	O
++	O
;	O
while	O
(	O
--	O
n	O
>	O
0	int
)	O
;	O
}	O
}	O
if	O
(	O
i	O
==	O
d	O
.	O
count	O
)	O
break	O
;	O
if	O
(	O
dp	O
->	O
conversion	O
==	O
'%'	O
)	O
{	O
size_t	O
augmented_length	O
;	O
if	O
(	O
!	O
(	O
dp	O
->	O
arg_index	O
==	O
ARG_NONE	O
)	O
)	O
abort	O
(	O
)	O
;	O
augmented_length	O
=	O
xsum	O
(	O
length	O
,	O
1	int
)	O
;	O
ENSURE_ALLOCATION	O
(	O
augmented_length	O
)	O
;	O
result	O
[	O
length	O
]	O
=	O
'%'	O
;	O
length	O
=	O
augmented_length	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
(	O
dp	O
->	O
arg_index	O
!=	O
ARG_NONE	O
)	O
)	O
abort	O
(	O
)	O
;	O
if	O
(	O
dp	O
->	O
conversion	O
==	O
'n'	O
)	O
{	O
switch	O
(	O
a	O
.	O
arg	O
[	O
dp	O
->	O
arg_index	O
]	O
.	O
type	O
)	O
{	O
case	O
TYPE_COUNT_SCHAR_POINTER	O
:	O
*	O
a	O
.	O
arg	O
[	O
dp	O
->	O
arg_index	O
]	O
.	O
a	O
.	O
a_count_schar_pointer	O
=	O
length	O
;	O
break	O
;	O
case	O
TYPE_COUNT_SHORT_POINTER	O
:	O
*	O
a	O
.	O
arg	O
[	O
dp	O
->	O
arg_index	O
]	O
.	O
a	O
.	O
a_count_short_pointer	O
=	O
length	O
;	O
break	O
;	O
case	O
TYPE_COUNT_INT_POINTER	O
:	O
*	O
a	O
.	O
arg	O
[	O
dp	O
->	O
arg_index	O
]	O
.	O
a	O
.	O
a_count_int_pointer	O
=	O
length	O
;	O
break	O
;	O
case	O
TYPE_COUNT_LONGINT_POINTER	O
:	O
*	O
a	O
.	O
arg	O
[	O
dp	O
->	O
arg_index	O
]	O
.	O
a	O
.	O
a_count_longint_pointer	O
=	O
length	O
;	O
break	O
;	O
case	O
TYPE_COUNT_LONGLONGINT_POINTER	O
:	O
*	O
a	O
.	O
arg	O
[	O
dp	O
->	O
arg_index	O
]	O
.	O
a	O
.	O
a_count_longlongint_pointer	O
=	O
length	O
;	O
break	O
;	O
default	O
:	O
abort	O
(	O
)	O
;	O
}	O
}	O
else	O
{	O
arg_type	O
type	O
=	O
a	O
.	O
arg	O
[	O
dp	O
->	O
arg_index	O
]	O
.	O
type	O
;	O
int	O
flags	O
=	O
dp	O
->	O
flags	O
;	O
TCHAR_T	char
*	O
fbp	O
;	O
unsigned	O
int	O
prefix_count	O
;	O
int	O
prefixes	O
[	O
2	int
]	O
IF_LINT	O
(	O
=	O
{	O
0	int
}	O
)	O
;	O
int	O
orig_errno	O
;	O
fbp	O
=	O
buf	O
;	O
*	O
fbp	O
++	O
=	O
'%'	O
;	O
if	O
(	O
flags	O
&	O
FLAG_GROUP	O
)	O
*	O
fbp	O
++	O
=	O
'\''	O
;	O
if	O
(	O
flags	O
&	O
FLAG_LEFT	O
)	O
*	O
fbp	O
++	O
=	O
'-'	O
;	O
if	O
(	O
flags	O
&	O
FLAG_SHOWSIGN	O
)	O
*	O
fbp	O
++	O
=	O
'+'	O
;	O
if	O
(	O
flags	O
&	O
FLAG_SPACE	O
)	O
*	O
fbp	O
++	O
=	O
' '	O
;	O
if	O
(	O
flags	O
&	O
FLAG_ALT	O
)	O
*	O
fbp	O
++	O
=	O
'#'	O
;	O
if	O
(	O
!	O
pad_ourselves	int
)	O
{	O
if	O
(	O
flags	O
&	O
FLAG_ZERO	O
)	O
*	O
fbp	O
++	O
=	O
'0'	O
;	O
if	O
(	O
dp	O
->	O
width_start	O
!=	O
dp	O
->	O
width_end	O
)	O
{	O
size_t	O
n	O
=	O
dp	O
->	O
width_end	O
-	O
dp	O
->	O
width_start	O
;	O
if	O
(	O
sizeof	O
(	O
FCHAR_T	char
)	O
==	O
sizeof	O
(	O
TCHAR_T	char
)	O
)	O
{	O
memcpy	O
(	O
fbp	O
,	O
dp	O
->	O
width_start	O
,	O
n	O
*	O
sizeof	O
(	O
TCHAR_T	char
)	O
)	O
;	O
fbp	O
+=	O
n	O
;	O
}	O
else	O
{	O
const	O
FCHAR_T	char
*	O
mp	O
=	O
dp	O
->	O
width_start	O
;	O
do	O
*	O
fbp	O
++	O
=	O
*	O
mp	O
++	O
;	O
while	O
(	O
--	O
n	O
>	O
0	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
prec_ourselves	int
)	O
{	O
if	O
(	O
dp	O
->	O
precision_start	O
!=	O
dp	O
->	O
precision_end	O
)	O
{	O
size_t	O
n	O
=	O
dp	O
->	O
precision_end	O
-	O
dp	O
->	O
precision_start	O
;	O
if	O
(	O
sizeof	O
(	O
FCHAR_T	char
)	O
==	O
sizeof	O
(	O
TCHAR_T	char
)	O
)	O
{	O
memcpy	O
(	O
fbp	O
,	O
dp	O
->	O
precision_start	O
,	O
n	O
*	O
sizeof	O
(	O
TCHAR_T	char
)	O
)	O
;	O
fbp	O
+=	O
n	O
;	O
}	O
else	O
{	O
const	O
FCHAR_T	char
*	O
mp	O
=	O
dp	O
->	O
precision_start	O
;	O
do	O
*	O
fbp	O
++	O
=	O
*	O
mp	O
++	O
;	O
while	O
(	O
--	O
n	O
>	O
0	int
)	O
;	O
}	O
}	O
}	O
switch	O
(	O
type	O
)	O
{	O
case	O
TYPE_LONGLONGINT	O
:	O
case	O
TYPE_ULONGLONGINT	O
:	O
*	O
fbp	O
++	O
=	O
'l'	O
;	O
FALLTHROUGH	O
;	O
case	O
TYPE_LONGINT	O
:	O
case	O
TYPE_ULONGINT	O
:	O
case	O
TYPE_WIDE_CHAR	O
:	O
case	O
TYPE_WIDE_STRING	O
:	O
*	O
fbp	O
++	O
=	O
'l'	O
;	O
break	O
;	O
case	O
TYPE_LONGDOUBLE	O
:	O
*	O
fbp	O
++	O
=	O
'L'	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
*	O
fbp	O
=	O
dp	O
->	O
conversion	O
;	O
fbp	O
[	O
1	int
]	O
=	O
'%'	O
;	O
fbp	O
[	O
2	int
]	O
=	O
'n'	O
;	O
fbp	O
[	O
3	int
]	O
=	O
'\0'	O
;	O
prefix_count	O
=	O
0	int
;	O
if	O
(	O
!	O
pad_ourselves	int
&&	O
dp	O
->	O
width_arg_index	O
!=	O
ARG_NONE	O
)	O
{	O
if	O
(	O
!	O
(	O
a	O
.	O
arg	O
[	O
dp	O
->	O
width_arg_index	O
]	O
.	O
type	O
==	O
TYPE_INT	O
)	O
)	O
abort	O
(	O
)	O
;	O
prefixes	O
[	O
prefix_count	O
++	O
]	O
=	O
a	O
.	O
arg	O
[	O
dp	O
->	O
width_arg_index	O
]	O
.	O
a	O
.	O
a_int	O
;	O
}	O
if	O
(	O
!	O
prec_ourselves	int
&&	O
dp	O
->	O
precision_arg_index	O
!=	O
ARG_NONE	O
)	O
{	O
if	O
(	O
!	O
(	O
a	O
.	O
arg	O
[	O
dp	O
->	O
precision_arg_index	O
]	O
.	O
type	O
==	O
TYPE_INT	O
)	O
)	O
abort	O
(	O
)	O
;	O
prefixes	O
[	O
prefix_count	O
++	O
]	O
=	O
a	O
.	O
arg	O
[	O
dp	O
->	O
precision_arg_index	O
]	O
.	O
a	O
.	O
a_int	O
;	O
}	O
ENSURE_ALLOCATION	O
(	O
xsum	O
(	O
length	O
,	O
(	O
2	int
+	O
TCHARS_PER_DCHAR	O
-	O
1	int
)	O
/	O
TCHARS_PER_DCHAR	O
)	O
)	O
;	O
*	O
(	O
TCHAR_T	char
*	O
)	O
(	O
result	O
+	O
length	O
)	O
=	O
'\0'	O
;	O
orig_errno	O
=	O
errno	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
count	O
=	O
-	O
1	int
;	O
int	O
retcount	O
=	O
0	int
;	O
size_t	O
maxlen	O
=	O
allocated	O
-	O
length	O
;	O
if	O
(	O
maxlen	O
>	O
INT_MAX	O
/	O
TCHARS_PER_DCHAR	O
)	O
maxlen	O
=	O
INT_MAX	O
/	O
TCHARS_PER_DCHAR	O
;	O
maxlen	O
=	O
maxlen	O
*	O
TCHARS_PER_DCHAR	O
;	O
errno	O
=	O
0	int
;	O
switch	O
(	O
type	O
)	O
{	O
case	O
TYPE_SCHAR	O
:	O
{	O
int	O
arg	O
=	O
a	O
.	O
arg	O
[	O
dp	O
->	O
arg_index	O
]	O
.	O
a	O
.	O
a_schar	O
;	O
SNPRINTF_BUF	O
(	O
arg	O
)	O
;	O
}	O
break	O
;	O
case	O
TYPE_UCHAR	O
:	O
{	O
unsigned	O
int	O
arg	O
=	O
a	O
.	O
arg	O
[	O
dp	O
->	O
arg_index	O
]	O
.	O
a	O
.	O
a_uchar	O
;	O
SNPRINTF_BUF	O
(	O
arg	O
)	O
;	O
}	O
break	O
;	O
case	O
TYPE_SHORT	O
:	O
{	O
int	O
arg	O
=	O
a	O
.	O
arg	O
[	O
dp	O
->	O
arg_index	O
]	O
.	O
a	O
.	O
a_short	O
;	O
SNPRINTF_BUF	O
(	O
arg	O
)	O
;	O
}	O
break	O
;	O
case	O
TYPE_USHORT	O
:	O
{	O
unsigned	O
int	O
arg	O
=	O
a	O
.	O
arg	O
[	O
dp	O
->	O
arg_index	O
]	O
.	O
a	O
.	O
a_ushort	O
;	O
SNPRINTF_BUF	O
(	O
arg	O
)	O
;	O
}	O
break	O
;	O
case	O
TYPE_INT	O
:	O
{	O
int	O
arg	O
=	O
a	O
.	O
arg	O
[	O
dp	O
->	O
arg_index	O
]	O
.	O
a	O
.	O
a_int	O
;	O
SNPRINTF_BUF	O
(	O
arg	O
)	O
;	O
}	O
break	O
;	O
case	O
TYPE_UINT	O
:	O
{	O
unsigned	O
int	O
arg	O
=	O
a	O
.	O
arg	O
[	O
dp	O
->	O
arg_index	O
]	O
.	O
a	O
.	O
a_uint	O
;	O
SNPRINTF_BUF	O
(	O
arg	O
)	O
;	O
}	O
break	O
;	O
case	O
TYPE_LONGINT	O
:	O
{	O
long	O
int	O
arg	O
=	O
a	O
.	O
arg	O
[	O
dp	O
->	O
arg_index	O
]	O
.	O
a	O
.	O
a_longint	O
;	O
SNPRINTF_BUF	O
(	O
arg	O
)	O
;	O
}	O
break	O
;	O
case	O
TYPE_ULONGINT	O
:	O
{	O
unsigned	O
long	O
int	O
arg	O
=	O
a	O
.	O
arg	O
[	O
dp	O
->	O
arg_index	O
]	O
.	O
a	O
.	O
a_ulongint	O
;	O
SNPRINTF_BUF	O
(	O
arg	O
)	O
;	O
}	O
break	O
;	O
case	O
TYPE_LONGLONGINT	O
:	O
{	O
long	O
long	O
int	O
arg	O
=	O
a	O
.	O
arg	O
[	O
dp	O
->	O
arg_index	O
]	O
.	O
a	O
.	O
a_longlongint	O
;	O
SNPRINTF_BUF	O
(	O
arg	O
)	O
;	O
}	O
break	O
;	O
case	O
TYPE_ULONGLONGINT	O
:	O
{	O
unsigned	O
long	O
long	O
int	O
arg	O
=	O
a	O
.	O
arg	O
[	O
dp	O
->	O
arg_index	O
]	O
.	O
a	O
.	O
a_ulonglongint	O
;	O
SNPRINTF_BUF	O
(	O
arg	O
)	O
;	O
}	O
break	O
;	O
case	O
TYPE_DOUBLE	O
:	O
{	O
double	O
arg	O
=	O
a	O
.	O
arg	O
[	O
dp	O
->	O
arg_index	O
]	O
.	O
a	O
.	O
a_double	O
;	O
SNPRINTF_BUF	O
(	O
arg	O
)	O
;	O
}	O
break	O
;	O
case	O
TYPE_LONGDOUBLE	O
:	O
{	O
long	O
double	O
arg	O
=	O
a	O
.	O
arg	O
[	O
dp	O
->	O
arg_index	O
]	O
.	O
a	O
.	O
a_longdouble	O
;	O
SNPRINTF_BUF	O
(	O
arg	O
)	O
;	O
}	O
break	O
;	O
case	O
TYPE_CHAR	O
:	O
{	O
int	O
arg	O
=	O
a	O
.	O
arg	O
[	O
dp	O
->	O
arg_index	O
]	O
.	O
a	O
.	O
a_char	O
;	O
SNPRINTF_BUF	O
(	O
arg	O
)	O
;	O
}	O
break	O
;	O
case	O
TYPE_WIDE_CHAR	O
:	O
{	O
wint_t	O
arg	O
=	O
a	O
.	O
arg	O
[	O
dp	O
->	O
arg_index	O
]	O
.	O
a	O
.	O
a_wide_char	O
;	O
SNPRINTF_BUF	O
(	O
arg	O
)	O
;	O
}	O
break	O
;	O
case	O
TYPE_STRING	O
:	O
{	O
const	O
char	O
*	O
arg	O
=	O
a	O
.	O
arg	O
[	O
dp	O
->	O
arg_index	O
]	O
.	O
a	O
.	O
a_string	O
;	O
SNPRINTF_BUF	O
(	O
arg	O
)	O
;	O
}	O
break	O
;	O
case	O
TYPE_WIDE_STRING	O
:	O
{	O
const	O
wchar_t	O
*	O
arg	O
=	O
a	O
.	O
arg	O
[	O
dp	O
->	O
arg_index	O
]	O
.	O
a	O
.	O
a_wide_string	O
;	O
SNPRINTF_BUF	O
(	O
arg	O
)	O
;	O
}	O
break	O
;	O
case	O
TYPE_POINTER	O
:	O
{	O
void	O
*	O
arg	O
=	O
a	O
.	O
arg	O
[	O
dp	O
->	O
arg_index	O
]	O
.	O
a	O
.	O
a_pointer	O
;	O
SNPRINTF_BUF	O
(	O
arg	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
abort	O
(	O
)	O
;	O
}	O
if	O
(	O
count	O
>=	O
0	int
)	O
{	O
if	O
(	O
(	O
unsigned	O
int	O
)	O
count	O
<	O
maxlen	O
&&	O
(	O
(	O
TCHAR_T	char
*	O
)	O
(	O
result	O
+	O
length	O
)	O
)	O
[	O
count	O
]	O
!=	O
'\0'	O
)	O
abort	O
(	O
)	O
;	O
if	O
(	O
retcount	O
>	O
count	O
)	O
count	O
=	O
retcount	O
;	O
}	O
else	O
{	O
if	O
(	O
fbp	O
[	O
1	int
]	O
!=	O
'\0'	O
)	O
{	O
fbp	O
[	O
1	int
]	O
=	O
'\0'	O
;	O
continue	O
;	O
}	O
else	O
{	O
if	O
(	O
retcount	O
<	O
0	int
)	O
{	O
}	O
else	O
count	O
=	O
retcount	O
;	O
}	O
}	O
if	O
(	O
count	O
<	O
0	int
)	O
{	O
int	O
saved_errno	O
=	O
errno	O
;	O
if	O
(	O
saved_errno	O
==	O
0	int
)	O
{	O
if	O
(	O
dp	O
->	O
conversion	O
==	O
'c'	O
||	O
dp	O
->	O
conversion	O
==	O
's'	O
)	O
saved_errno	O
=	O
EILSEQ	O
;	O
else	O
saved_errno	O
=	O
EINVAL	O
;	O
}	O
if	O
(	O
!	O
(	O
result	O
==	O
resultbuf	O
||	O
result	O
==	O
NULL	O
)	O
)	O
free	O
(	O
result	O
)	O
;	O
if	O
(	O
buf_malloced	O
!=	O
NULL	O
)	O
free	O
(	O
buf_malloced	O
)	O
;	O
CLEANUP	O
(	O
)	O
;	O
errno	O
=	O
saved_errno	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
(	O
unsigned	O
int	O
)	O
count	O
+	O
1	int
>=	O
maxlen	O
)	O
{	O
if	O
(	O
maxlen	O
==	O
INT_MAX	O
/	O
TCHARS_PER_DCHAR	O
)	O
goto	O
overflow	O
;	O
else	O
{	O
size_t	O
n	O
=	O
xmax	O
(	O
xsum	O
(	O
length	O
,	O
(	O
(	O
unsigned	O
int	O
)	O
count	O
+	O
2	int
+	O
TCHARS_PER_DCHAR	O
-	O
1	int
)	O
/	O
TCHARS_PER_DCHAR	O
)	O
,	O
xtimes	O
(	O
allocated	O
,	O
2	int
)	O
)	O
;	O
ENSURE_ALLOCATION	O
(	O
n	O
)	O
;	O
continue	O
;	O
}	O
}	O
length	O
+=	O
count	O
;	O
break	O
;	O
}	O
errno	O
=	O
orig_errno	O
;	O
}	O
}	O
}	O
ENSURE_ALLOCATION	O
(	O
xsum	O
(	O
length	O
,	O
1	int
)	O
)	O
;	O
result	O
[	O
length	O
]	O
=	O
'\0'	O
;	O
if	O
(	O
result	O
!=	O
resultbuf	O
&&	O
length	O
+	O
1	int
<	O
allocated	O
)	O
{	O
DCHAR_T	char
*	O
memory	O
;	O
memory	O
=	O
(	O
DCHAR_T	char
*	O
)	O
realloc	O
(	O
result	O
,	O
(	O
length	O
+	O
1	int
)	O
*	O
sizeof	O
(	O
DCHAR_T	char
)	O
)	O
;	O
if	O
(	O
memory	O
!=	O
NULL	O
)	O
result	O
=	O
memory	O
;	O
}	O
if	O
(	O
buf_malloced	O
!=	O
NULL	O
)	O
free	O
(	O
buf_malloced	O
)	O
;	O
CLEANUP	O
(	O
)	O
;	O
*	O
lengthp	O
=	O
length	O
;	O
return	O
result	O
;	O
overflow	O
:	O
if	O
(	O
!	O
(	O
result	O
==	O
resultbuf	O
||	O
result	O
==	O
NULL	O
)	O
)	O
free	O
(	O
result	O
)	O
;	O
if	O
(	O
buf_malloced	O
!=	O
NULL	O
)	O
free	O
(	O
buf_malloced	O
)	O
;	O
CLEANUP	O
(	O
)	O
;	O
errno	O
=	O
EOVERFLOW	O
;	O
return	O
NULL	O
;	O
out_of_memory	O
:	O
if	O
(	O
!	O
(	O
result	O
==	O
resultbuf	O
||	O
result	O
==	O
NULL	O
)	O
)	O
free	O
(	O
result	O
)	O
;	O
if	O
(	O
buf_malloced	O
!=	O
NULL	O
)	O
free	O
(	O
buf_malloced	O
)	O
;	O
out_of_memory_1	O
:	O
CLEANUP	O
(	O
)	O
;	O
errno	O
=	O
ENOMEM	O
;	O
return	O
NULL	O
;	O
}	O
}	O
