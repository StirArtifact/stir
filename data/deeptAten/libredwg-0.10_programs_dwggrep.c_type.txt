char	O
*	O
pattern	pointer
;	O
char	O
buf	array
[	O
4096	int
]	O
;	O
int	O
options	int
=	O
PCRE2_MULTILINE	int
|	O
PCRE2_NO_AUTO_CAPTURE	int
|	O
PCRE2_NO_DOTSTAR_ANCHOR	int
;	O
int	O
opt_count	int
=	O
0	int
;	O
int	O
opt_text	int
=	O
0	int
;	O
int	O
opt_tables	int
=	O
0	int
;	O
int	O
opt_filename	int
=	O
1	int
;	O
short	O
numdxf	short
=	O
0	int
;	O
short	O
numtype	short
=	O
0	int
;	O
static	O
short	O
dxf	short
[	O
10	int
]	O
;	O
static	O
char	O
*	O
type	short
[	O
10	int
]	O
;	O
static	O
unsigned	O
int	O
cur_ver	int
=	O
0	int
;	O
static	O
int	O
usage	function
(	O
void	O
)	O
{	O
printf	function
(	O
"\nUsage: dwggrep [-cRr] pattern *.dwg\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
opt_version	function
(	O
void	O
)	O
{	O
printf	function
(	O
"dwggrep %s\n"	pointer
,	O
PACKAGE_VERSION	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
help	function
(	O
void	O
)	O
{	O
printf	function
(	O
"\nUsage: dwggrep [OPTIONS]... pattern files\n"	pointer
)	O
;	O
printf	function
(	O
"Search string (no regex) in a list of DWGs.\n\n"	pointer
)	O
;	O
printf	function
(	O
"  -i                        Case-insensitive pattern\n"	pointer
)	O
;	O
printf	function
(	O
"  -c, --count               Print only the count of matched "	pointer
"elements.\n"	pointer
)	O
;	O
printf	function
(	O
"  -h, --no-filename         Print no filename.\n"	pointer
)	O
;	O
printf	function
(	O
"  -y, --type NAME           Search only NAME entities or objects.\n"	pointer
)	O
;	O
printf	function
(	O
"  -d, --dxf NUM             Search only DXF group NUM fields.\n"	pointer
)	O
;	O
printf	function
(	O
"  -t, --text                Search only in TEXT-like entities.\n"	pointer
)	O
;	O
printf	function
(	O
"      --help                Display this help and exit\n"	pointer
)	O
;	O
printf	function
(	O
"      --version             Output version information and exit\n"	pointer
"\n"	pointer
)	O
;	O
printf	function
(	O
"GNU LibreDWG online manual: "	pointer
"<https://www.gnu.org/software/libredwg/>\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
print_match	function
(	O
const	O
int	O
is16	int
,	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
char	O
*	O
restrict	O
entity	long
,	O
const	O
int	O
dxfgroup	int
,	O
char	O
*	O
restrict	O
text	pointer
)	O
{	O
if	O
(	O
is16	int
)	O
text	pointer
=	O
bit_convert_TU	function
(	O
(	O
BITCODE_TU	pointer
)	O
text	pointer
)	O
;	O
printf	function
(	O
"%s %s %d: %s\n"	pointer
,	O
opt_filename	int
?	O
filename	pointer
:	O
""	pointer
,	O
entity	long
,	O
dxfgroup	int
,	O
text	pointer
)	O
;	O
if	O
(	O
is16	int
)	O
free	function
(	O
text	pointer
)	O
;	O
}	O
static	O
int	O
do_match	function
(	O
const	O
int	O
is16	int
,	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
char	O
*	O
restrict	O
entity	long
,	O
const	O
int	O
dxfgroup	int
,	O
char	O
*	O
restrict	O
text	pointer
)	O
{	O
if	O
(	O
options	int
&	O
PCRE2_CASELESS	int
)	O
{	O
if	O
(	O
strcasestr	function
(	O
text	pointer
,	O
pattern	pointer
)	O
)	O
{	O
if	O
(	O
!	O
opt_count	int
)	O
print_match	function
(	O
is16	int
,	O
filename	pointer
,	O
entity	long
,	O
dxfgroup	int
,	O
text	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
strstr	function
(	O
text	pointer
,	O
pattern	pointer
)	O
)	O
{	O
if	O
(	O
!	O
opt_count	int
)	O
print_match	function
(	O
is16	int
,	O
filename	pointer
,	O
entity	long
,	O
dxfgroup	int
,	O
text	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
match_TEXT	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
found	int
=	O
0	int
;	O
MATCH_ENTITY	O
(	O
TEXT	pointer
,	O
text_value	pointer
,	O
1	int
)	O
;	O
if	O
(	O
!	O
opt_text	int
)	O
MATCH_TABLE	O
(	O
TEXT	pointer
,	O
style	pointer
,	O
STYLE	pointer
,	O
7	int
)	O
;	O
return	O
found	int
;	O
}	O
static	O
int	O
match_ATTRIB	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
found	int
=	O
0	int
;	O
MATCH_ENTITY	O
(	O
ATTRIB	pointer
,	O
text_value	pointer
,	O
1	int
)	O
;	O
MATCH_ENTITY	O
(	O
ATTRIB	pointer
,	O
tag	pointer
,	O
2	int
)	O
;	O
if	O
(	O
!	O
opt_text	int
)	O
MATCH_TABLE	O
(	O
ATTRIB	pointer
,	O
style	pointer
,	O
STYLE	pointer
,	O
7	int
)	O
;	O
return	O
found	int
;	O
}	O
static	O
int	O
match_ATTDEF	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
found	int
=	O
0	int
;	O
MATCH_ENTITY	O
(	O
ATTDEF	pointer
,	O
default_value	pointer
,	O
1	int
)	O
;	O
MATCH_ENTITY	O
(	O
ATTDEF	pointer
,	O
tag	pointer
,	O
2	int
)	O
;	O
MATCH_ENTITY	O
(	O
ATTDEF	pointer
,	O
prompt	pointer
,	O
3	int
)	O
;	O
return	O
found	int
;	O
}	O
static	O
int	O
match_MTEXT	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
found	int
=	O
0	int
;	O
MATCH_ENTITY	O
(	O
MTEXT	pointer
,	O
text	pointer
,	O
1	int
)	O
;	O
return	O
found	int
;	O
}	O
static	O
int	O
match_BLOCK	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
found	int
=	O
0	int
;	O
MATCH_ENTITY	O
(	O
BLOCK	pointer
,	O
name	pointer
,	O
2	int
)	O
;	O
return	O
found	int
;	O
}	O
static	O
int	O
match_DIMENSION	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
found	int
=	O
0	int
;	O
text	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
DIMENSION_ORDINATE	pointer
->	O
user_text	pointer
;	O
if	O
(	O
text	pointer
)	O
found	int
+=	O
do_match	function
(	O
0	int
,	O
filename	pointer
,	O
"DIMENSION"	pointer
,	O
1	int
,	O
text	pointer
)	O
;	O
return	O
found	int
;	O
}	O
static	O
int	O
match_VIEWPORT	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
found	int
=	O
0	int
;	O
MATCH_ENTITY	O
(	O
VIEWPORT	pointer
,	O
style_sheet	pointer
,	O
1	int
)	O
;	O
return	O
found	int
;	O
}	O
static	O
int	O
match_3DSOLID	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
text	pointer
=	O
NULL	O
;	O
int	O
found	int
=	O
0	int
;	O
BITCODE_BL	int
j	int
;	O
Dwg_Entity_3DSOLID	O
*	O
_obj	pointer
;	O
if	O
(	O
!	O
obj	pointer
||	O
!	O
obj	pointer
->	O
tio	union
.	O
entity	long
)	O
return	O
0	int
;	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
_3DSOLID	pointer
;	O
if	O
(	O
!	O
_obj	pointer
)	O
return	O
0	int
;	O
if	O
(	O
_obj	pointer
->	O
acis_data	pointer
)	O
{	O
MATCH_NO16	O
(	O
entity	long
,	O
_3DSOLID	pointer
,	O
acis_data	pointer
,	O
1	int
)	O
;	O
}	O
return	O
found	int
;	O
}	O
static	O
int	O
match_DICTIONARY	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
found	int
=	O
0	int
;	O
BITCODE_BL	int
i	int
;	O
Dwg_Object_DICTIONARY	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
DICTIONARY	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
_obj	pointer
->	O
numitems	int
;	O
i	int
++	O
)	O
{	O
MATCH_OBJECT	O
(	O
DICTIONARY	pointer
,	O
texts	pointer
[	O
i	int
]	O
,	O
3	int
)	O
;	O
}	O
return	O
found	int
;	O
}	O
static	O
int	O
match_STYLE	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
found	int
=	O
0	int
;	O
MATCH_OBJECT	O
(	O
STYLE	pointer
,	O
font_name	pointer
,	O
3	int
)	O
;	O
MATCH_OBJECT	O
(	O
STYLE	pointer
,	O
bigfont_name	pointer
,	O
4	int
)	O
;	O
return	O
found	int
;	O
}	O
static	O
int	O
match_LTYPE	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
found	int
=	O
0	int
;	O
MATCH_OBJECT	O
(	O
LTYPE	pointer
,	O
description	pointer
,	O
3	int
)	O
;	O
MATCH_OBJECT	O
(	O
LTYPE	pointer
,	O
strings_area	pointer
,	O
3	int
)	O
;	O
return	O
found	int
;	O
}	O
static	O
int	O
match_DIMSTYLE	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
found	int
=	O
0	int
;	O
MATCH_OBJECT	O
(	O
DIMSTYLE	pointer
,	O
DIMPOST	pointer
,	O
3	int
)	O
;	O
MATCH_OBJECT	O
(	O
DIMSTYLE	pointer
,	O
DIMAPOST	pointer
,	O
4	int
)	O
;	O
MATCH_OBJECT	O
(	O
DIMSTYLE	pointer
,	O
DIMBLK_T	pointer
,	O
5	int
)	O
;	O
MATCH_OBJECT	O
(	O
DIMSTYLE	pointer
,	O
DIMBLK1_T	pointer
,	O
6	int
)	O
;	O
MATCH_OBJECT	O
(	O
DIMSTYLE	pointer
,	O
DIMBLK2_T	pointer
,	O
7	int
)	O
;	O
MATCH_OBJECT	O
(	O
DIMSTYLE	pointer
,	O
DIMMZS	pointer
,	O
0	int
)	O
;	O
MATCH_OBJECT	O
(	O
DIMSTYLE	pointer
,	O
DIMALTMZS	pointer
,	O
0	int
)	O
;	O
return	O
found	int
;	O
}	O
static	O
int	O
match_GROUP	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
found	int
=	O
0	int
;	O
MATCH_OBJECT	O
(	O
GROUP	pointer
,	O
name	pointer
,	O
3	int
)	O
;	O
return	O
found	int
;	O
}	O
static	O
int	O
match_MLINESTYLE	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
found	int
=	O
0	int
;	O
MATCH_OBJECT	O
(	O
MLINESTYLE	pointer
,	O
name	pointer
,	O
2	int
)	O
;	O
MATCH_OBJECT	O
(	O
MLINESTYLE	pointer
,	O
desc	pointer
,	O
3	int
)	O
;	O
return	O
found	int
;	O
}	O
static	O
int	O
match_DICTIONARYVAR	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
found	int
=	O
0	int
;	O
MATCH_OBJECT	O
(	O
DICTIONARYVAR	pointer
,	O
str	struct
,	O
1	int
)	O
;	O
return	O
found	int
;	O
}	O
static	O
int	O
match_HATCH	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
found	int
=	O
0	int
;	O
MATCH_ENTITY	O
(	O
HATCH	pointer
,	O
name	pointer
,	O
2	int
)	O
;	O
MATCH_ENTITY	O
(	O
HATCH	pointer
,	O
gradient_name	pointer
,	O
470	int
)	O
;	O
return	O
found	int
;	O
}	O
static	O
int	O
match_IMAGEDEF	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
found	int
=	O
0	int
;	O
MATCH_OBJECT	O
(	O
IMAGEDEF	pointer
,	O
file_path	pointer
,	O
1	int
)	O
;	O
return	O
found	int
;	O
}	O
static	O
int	O
match_SCALE	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
found	int
=	O
0	int
,	O
i	int
;	O
const	O
Dwg_Object_SCALE	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
SCALE	pointer
;	O
MATCH_OBJECT	O
(	O
SCALE	pointer
,	O
name	pointer
,	O
1	int
)	O
;	O
return	O
found	int
;	O
}	O
static	O
int	O
match_LAYER_INDEX	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
found	int
=	O
0	int
;	O
BITCODE_BL	int
i	int
;	O
const	O
Dwg_Object_LAYER_INDEX	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
LAYER_INDEX	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
_obj	pointer
->	O
num_entries	short
;	O
i	int
++	O
)	O
{	O
MATCH_OBJECT	O
(	O
LAYER_INDEX	pointer
,	O
entries	pointer
[	O
i	int
]	O
.	O
layername	pointer
,	O
8	int
)	O
;	O
}	O
return	O
found	int
;	O
}	O
static	O
int	O
match_LAYOUT	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
found	int
=	O
0	int
;	O
BITCODE_BL	int
i	int
;	O
const	O
Dwg_Object_LAYOUT	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
LAYOUT	pointer
;	O
MATCH_OBJECT	O
(	O
LAYOUT	pointer
,	O
page_setup_name	pointer
,	O
1	int
)	O
;	O
MATCH_OBJECT	O
(	O
LAYOUT	pointer
,	O
printer_or_config	pointer
,	O
2	int
)	O
;	O
MATCH_OBJECT	O
(	O
LAYOUT	pointer
,	O
paper_size	pointer
,	O
4	int
)	O
;	O
MATCH_OBJECT	O
(	O
LAYOUT	pointer
,	O
plot_view_name	pointer
,	O
6	int
)	O
;	O
MATCH_OBJECT	O
(	O
LAYOUT	pointer
,	O
current_style_sheet	pointer
,	O
7	int
)	O
;	O
MATCH_OBJECT	O
(	O
LAYOUT	pointer
,	O
layout_name	pointer
,	O
1	int
)	O
;	O
MATCH_TABLE	O
(	O
LAYOUT	pointer
,	O
plot_view	pointer
,	O
?	O
?	O
,	O
6	int
)	O
;	O
MATCH_TABLE	O
(	O
LAYOUT	pointer
,	O
visual_style	O
,	O
?	O
?	O
,	O
0	int
)	O
;	O
MATCH_TABLE	O
(	O
LAYOUT	pointer
,	O
base_ucs	pointer
,	O
UCS	pointer
,	O
346	int
)	O
;	O
MATCH_TABLE	O
(	O
LAYOUT	pointer
,	O
named_ucs	pointer
,	O
UCS	pointer
,	O
345	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
_obj	pointer
->	O
num_viewports	int
;	O
i	int
++	O
)	O
{	O
MATCH_TABLE	O
(	O
LAYOUT	pointer
,	O
viewports	pointer
[	O
i	int
]	O
,	O
VPORT	pointer
,	O
0	int
)	O
;	O
}	O
return	O
found	int
;	O
}	O
static	O
int	O
match_FIELD	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
found	int
=	O
0	int
;	O
BITCODE_BL	int
i	int
;	O
const	O
Dwg_Object_FIELD	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
FIELD	pointer
;	O
MATCH_OBJECT	O
(	O
FIELD	pointer
,	O
format	pointer
,	O
4	int
)	O
;	O
MATCH_OBJECT	O
(	O
FIELD	pointer
,	O
evaluation_error_msg	pointer
,	O
300	int
)	O
;	O
MATCH_OBJECT	O
(	O
FIELD	pointer
,	O
value	double
.	O
format_string	pointer
,	O
300	int
)	O
;	O
MATCH_OBJECT	O
(	O
FIELD	pointer
,	O
value	double
.	O
value_string	pointer
,	O
300	int
)	O
;	O
MATCH_OBJECT	O
(	O
FIELD	pointer
,	O
value_string	pointer
,	O
301	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
_obj	pointer
->	O
num_childval	int
;	O
i	int
++	O
)	O
{	O
MATCH_OBJECT	O
(	O
FIELD	pointer
,	O
childval	pointer
[	O
i	int
]	O
.	O
key	pointer
,	O
6	int
)	O
;	O
MATCH_OBJECT	O
(	O
FIELD	pointer
,	O
childval	pointer
[	O
i	int
]	O
.	O
value	double
.	O
format_string	pointer
,	O
300	int
)	O
;	O
MATCH_OBJECT	O
(	O
FIELD	pointer
,	O
childval	pointer
[	O
i	int
]	O
.	O
value	double
.	O
value_string	pointer
,	O
302	int
)	O
;	O
}	O
return	O
found	int
;	O
}	O
static	O
int	O
match_TABLE	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
found	int
=	O
0	int
;	O
BITCODE_BL	int
i	int
;	O
const	O
Dwg_Entity_TABLE	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
TABLE	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
_obj	pointer
->	O
num_cells	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
_obj	pointer
->	O
cells	pointer
[	O
i	int
]	O
.	O
type	short
==	O
1	int
)	O
{	O
MATCH_ENTITY	O
(	O
TABLE	pointer
,	O
cells	pointer
[	O
i	int
]	O
.	O
text_string	pointer
,	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
_obj	pointer
->	O
cells	pointer
[	O
i	int
]	O
.	O
type	short
==	O
2	int
&&	O
_obj	pointer
->	O
cells	pointer
[	O
i	int
]	O
.	O
additional_data_flag	char
==	O
1	int
)	O
{	O
MATCH_ENTITY	O
(	O
TABLE	pointer
,	O
cells	pointer
[	O
i	int
]	O
.	O
attr_def_text	pointer
,	O
300	int
)	O
;	O
}	O
}	O
return	O
found	int
;	O
}	O
static	O
int	O
match_TABLECONTENT	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
found	int
=	O
0	int
;	O
BITCODE_BL	int
i	int
,	O
j	int
,	O
k	int
;	O
const	O
Dwg_Object_TABLECONTENT	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
TABLECONTENT	pointer
;	O
MATCH_OBJECT	O
(	O
TABLECONTENT	pointer
,	O
ldata	struct
.	O
name	pointer
,	O
1	int
)	O
;	O
MATCH_OBJECT	O
(	O
TABLECONTENT	pointer
,	O
ldata	struct
.	O
desc	pointer
,	O
300	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
_obj	pointer
->	O
tdata	struct
.	O
num_cols	short
;	O
i	int
++	O
)	O
{	O
MATCH_OBJECT	O
(	O
TABLECONTENT	pointer
,	O
tdata	struct
.	O
cols	pointer
[	O
i	int
]	O
.	O
name	pointer
,	O
300	int
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
_obj	pointer
->	O
tdata	struct
.	O
num_rows	short
;	O
i	int
++	O
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
_obj	pointer
->	O
tdata	struct
.	O
rows	pointer
[	O
i	int
]	O
.	O
num_cells	int
;	O
j	int
++	O
)	O
{	O
MATCH_OBJECT	O
(	O
TABLECONTENT	pointer
,	O
tdata	struct
.	O
rows	pointer
[	O
i	int
]	O
.	O
cells	pointer
[	O
j	int
]	O
.	O
tooltip	pointer
,	O
300	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
_obj	pointer
->	O
tdata	struct
.	O
rows	pointer
[	O
i	int
]	O
.	O
cells	pointer
[	O
j	int
]	O
.	O
num_customdata_items	int
;	O
k	int
++	O
)	O
{	O
MATCH_OBJECT	O
(	O
TABLECONTENT	pointer
,	O
_custom	O
.	O
name	pointer
,	O
300	int
)	O
;	O
if	O
(	O
_obj	pointer
->	O
_custom	O
.	O
value	double
.	O
data_type	int
==	O
4	int
)	O
{	O
MATCH_OBJECT	O
(	O
TABLECONTENT	pointer
,	O
_custom	O
.	O
value	double
.	O
data_string	pointer
,	O
302	int
)	O
;	O
}	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
_obj	pointer
->	O
tdata	struct
.	O
rows	pointer
[	O
i	int
]	O
.	O
cells	pointer
[	O
j	int
]	O
.	O
num_cell_contents	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
_obj	pointer
->	O
_content	O
.	O
type	short
==	O
1	int
&&	O
_obj	pointer
->	O
_content	O
.	O
value	double
.	O
data_type	int
==	O
4	int
)	O
{	O
MATCH_OBJECT	O
(	O
TABLECONTENT	pointer
,	O
_content	O
.	O
value	double
.	O
data_string	pointer
,	O
302	int
)	O
;	O
}	O
}	O
}	O
}	O
return	O
found	int
;	O
}	O
static	O
int	O
match_GEODATA	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
found	int
=	O
0	int
;	O
const	O
Dwg_Object_GEODATA	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
GEODATA	pointer
;	O
MATCH_OBJECT	O
(	O
GEODATA	pointer
,	O
coord_system_def	pointer
,	O
0	int
)	O
;	O
MATCH_OBJECT	O
(	O
GEODATA	pointer
,	O
geo_rss_tag	pointer
,	O
302	int
)	O
;	O
MATCH_OBJECT	O
(	O
GEODATA	pointer
,	O
observation_from_tag	pointer
,	O
305	int
)	O
;	O
MATCH_OBJECT	O
(	O
GEODATA	pointer
,	O
observation_to_tag	pointer
,	O
306	int
)	O
;	O
MATCH_OBJECT	O
(	O
GEODATA	pointer
,	O
observation_coverage_tag	pointer
,	O
0	int
)	O
;	O
MATCH_OBJECT	O
(	O
GEODATA	pointer
,	O
coord_system_datum	pointer
,	O
0	int
)	O
;	O
MATCH_OBJECT	O
(	O
GEODATA	pointer
,	O
coord_system_wkt	pointer
,	O
0	int
)	O
;	O
return	O
found	int
;	O
}	O
static	O
int	O
match_GEOPOSITIONMARKER	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
found	int
=	O
0	int
;	O
const	O
Dwg_Entity_GEOPOSITIONMARKER	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
GEOPOSITIONMARKER	pointer
;	O
MATCH_ENTITY	O
(	O
GEOPOSITIONMARKER	pointer
,	O
text	pointer
,	O
1	int
)	O
;	O
MATCH_ENTITY	O
(	O
GEOPOSITIONMARKER	pointer
,	O
notes	pointer
,	O
3	int
)	O
;	O
return	O
found	int
;	O
}	O
static	O
int	O
match_UNDERLAYDEFINITION	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
found	int
=	O
0	int
;	O
const	O
Dwg_Object_UNDERLAYDEFINITION	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
UNDERLAYDEFINITION	pointer
;	O
MATCH_OBJECT	O
(	O
UNDERLAYDEFINITION	pointer
,	O
filename	pointer
,	O
1	int
)	O
;	O
MATCH_OBJECT	O
(	O
UNDERLAYDEFINITION	pointer
,	O
name	pointer
,	O
2	int
)	O
;	O
return	O
found	int
;	O
}	O
static	O
int	O
match_VISUALSTYLE	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
found	int
=	O
0	int
,	O
i	int
;	O
const	O
Dwg_Object_VISUALSTYLE	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
VISUALSTYLE	pointer
;	O
MATCH_OBJECT	O
(	O
VISUALSTYLE	pointer
,	O
desc	pointer
,	O
1	int
)	O
;	O
return	O
found	int
;	O
}	O
static	O
int	O
match_LIGHT	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
found	int
=	O
0	int
;	O
const	O
Dwg_Entity_LIGHT	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
LIGHT	pointer
;	O
MATCH_ENTITY	O
(	O
LIGHT	pointer
,	O
name	pointer
,	O
1	int
)	O
;	O
return	O
found	int
;	O
}	O
static	O
int	O
match_SUNSTUDY	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
found	int
=	O
0	int
;	O
const	O
Dwg_Object_SUNSTUDY	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
SUNSTUDY	pointer
;	O
MATCH_OBJECT	O
(	O
SUNSTUDY	pointer
,	O
setup_name	pointer
,	O
1	int
)	O
;	O
MATCH_OBJECT	O
(	O
SUNSTUDY	pointer
,	O
desc	pointer
,	O
2	int
)	O
;	O
MATCH_OBJECT	O
(	O
SUNSTUDY	pointer
,	O
sheet_set_name	pointer
,	O
3	int
)	O
;	O
return	O
found	int
;	O
}	O
static	O
int	O
match_LIGHTLIST	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
found	int
=	O
0	int
,	O
i	int
;	O
const	O
Dwg_Object_LIGHTLIST	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
LIGHTLIST	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
_obj	pointer
->	O
num_lights	short
;	O
i	int
++	O
)	O
{	O
}	O
return	O
found	int
;	O
}	O
static	O
int	O
match_DBCOLOR	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
found	int
=	O
0	int
;	O
const	O
Dwg_Object_DBCOLOR	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
DBCOLOR	pointer
;	O
MATCH_OBJECT	O
(	O
DBCOLOR	pointer
,	O
name	pointer
,	O
430	int
)	O
;	O
MATCH_OBJECT	O
(	O
DBCOLOR	pointer
,	O
catalog	pointer
,	O
430	int
)	O
;	O
return	O
found	int
;	O
}	O
static	O
int	O
match_MATERIAL	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
found	int
=	O
0	int
;	O
const	O
Dwg_Object_MATERIAL	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
MATERIAL	pointer
;	O
MATCH_OBJECT	O
(	O
MATERIAL	pointer
,	O
name	pointer
,	O
1	int
)	O
;	O
MATCH_OBJECT	O
(	O
MATERIAL	pointer
,	O
desc	pointer
,	O
2	int
)	O
;	O
MATCH_OBJECT	O
(	O
MATERIAL	pointer
,	O
diffusemap_filename	pointer
,	O
3	int
)	O
;	O
MATCH_OBJECT	O
(	O
MATERIAL	pointer
,	O
specularmap_filename	pointer
,	O
4	int
)	O
;	O
MATCH_OBJECT	O
(	O
MATERIAL	pointer
,	O
reflectionmap_filename	pointer
,	O
6	int
)	O
;	O
MATCH_OBJECT	O
(	O
MATERIAL	pointer
,	O
opacitymap_filename	pointer
,	O
7	int
)	O
;	O
MATCH_OBJECT	O
(	O
MATERIAL	pointer
,	O
bumpmap_filename	pointer
,	O
8	int
)	O
;	O
MATCH_OBJECT	O
(	O
MATERIAL	pointer
,	O
refractionmap_filename	pointer
,	O
9	int
)	O
;	O
MATCH_OBJECT	O
(	O
MATERIAL	pointer
,	O
normalmap_filename	pointer
,	O
3	int
)	O
;	O
MATCH_OBJECT	O
(	O
MATERIAL	pointer
,	O
genprocname	pointer
,	O
300	int
)	O
;	O
MATCH_OBJECT	O
(	O
MATERIAL	pointer
,	O
genprocvaltext	pointer
,	O
301	int
)	O
;	O
MATCH_OBJECT	O
(	O
MATERIAL	pointer
,	O
genprocvalcolorname	pointer
,	O
430	int
)	O
;	O
return	O
found	int
;	O
}	O
static	O
int	O
match_PLOTSETTINGS	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
found	int
=	O
0	int
;	O
const	O
Dwg_Object_PLOTSETTINGS	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
PLOTSETTINGS	pointer
;	O
MATCH_OBJECT	O
(	O
PLOTSETTINGS	pointer
,	O
page_setup_name	pointer
,	O
1	int
)	O
;	O
MATCH_OBJECT	O
(	O
PLOTSETTINGS	pointer
,	O
printer_cfg_file	pointer
,	O
2	int
)	O
;	O
MATCH_OBJECT	O
(	O
PLOTSETTINGS	pointer
,	O
paper_size	pointer
,	O
4	int
)	O
;	O
return	O
found	int
;	O
}	O
static	O
int	O
match_ASSOCACTION	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
found	int
=	O
0	int
;	O
const	O
Dwg_Object_ASSOCACTION	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
ASSOCACTION	pointer
;	O
MATCH_OBJECT	O
(	O
ASSOCACTION	pointer
,	O
body	struct
.	O
evaluatorid	pointer
,	O
0	int
)	O
;	O
MATCH_OBJECT	O
(	O
ASSOCACTION	pointer
,	O
body	struct
.	O
expression	pointer
,	O
0	int
)	O
;	O
return	O
found	int
;	O
}	O
static	O
int	O
match_ASSOCOSNAPPOINTREFACTIONPARAM	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
found	int
=	O
0	int
;	O
const	O
Dwg_Object_ASSOCOSNAPPOINTREFACTIONPARAM	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
ASSOCOSNAPPOINTREFACTIONPARAM	pointer
;	O
MATCH_OBJECT	O
(	O
ASSOCOSNAPPOINTREFACTIONPARAM	pointer
,	O
name	pointer
,	O
1	int
)	O
;	O
return	O
found	int
;	O
}	O
static	O
int	O
match_NAVISWORKSMODELDEF	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
char	O
*	O
text	pointer
;	O
int	O
found	int
=	O
0	int
;	O
const	O
Dwg_Object_NAVISWORKSMODELDEF	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
NAVISWORKSMODELDEF	pointer
;	O
MATCH_OBJECT	O
(	O
NAVISWORKSMODELDEF	pointer
,	O
path	pointer
,	O
1	int
)	O
;	O
return	O
found	int
;	O
}	O
static	O
int	O
match_BLOCK_HEADER	function
(	O
const	O
char	O
*	O
restrict	O
filename	pointer
,	O
Dwg_Object_Ref	struct
*	O
restrict	O
ref	pointer
)	O
{	O
int	O
found	int
=	O
0	int
;	O
Dwg_Object	struct
*	O
hdr	pointer
;	O
Dwg_Object	struct
*	O
obj	pointer
;	O
char	O
*	O
text	pointer
;	O
if	O
(	O
!	O
ref	pointer
)	O
return	O
0	int
;	O
obj	pointer
=	O
hdr	pointer
=	O
ref	pointer
->	O
obj	pointer
;	O
if	O
(	O
!	O
hdr	pointer
||	O
hdr	pointer
->	O
supertype	enum
!=	O
DWG_SUPERTYPE_OBJECT	int
||	O
hdr	pointer
->	O
type	short
!=	O
DWG_TYPE_BLOCK_HEADER	int
)	O
return	O
0	int
;	O
MATCH_OBJECT	O
(	O
BLOCK_HEADER	pointer
,	O
xref_pname	pointer
,	O
1	int
)	O
;	O
MATCH_OBJECT	O
(	O
BLOCK_HEADER	pointer
,	O
description	pointer
,	O
4	int
)	O
;	O
for	O
(	O
obj	pointer
=	O
get_first_owned_entity	function
(	O
hdr	pointer
)	O
;	O
obj	pointer
;	O
obj	pointer
=	O
get_next_owned_entity	function
(	O
hdr	pointer
,	O
obj	pointer
)	O
)	O
{	O
if	O
(	O
numtype	short
)	O
{	O
int	O
typeok	int
=	O
0	int
;	O
for	O
(	O
int	O
i	int
=	O
0	int
;	O
i	int
<	O
numtype	short
;	O
i	int
++	O
)	O
{	O
if	O
(	O
obj	pointer
->	O
dxfname	pointer
&&	O
!	O
strcmp	function
(	O
type	short
[	O
i	int
]	O
,	O
obj	pointer
->	O
dxfname	pointer
)	O
)	O
{	O
typeok	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
typeok	int
)	O
continue	O
;	O
}	O
if	O
(	O
!	O
opt_tables	int
)	O
{	O
if	O
(	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_TEXT	int
)	O
found	int
+=	O
match_TEXT	function
(	O
filename	pointer
,	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_ATTDEF	int
)	O
found	int
+=	O
match_ATTDEF	function
(	O
filename	pointer
,	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_MTEXT	int
)	O
found	int
+=	O
match_MTEXT	function
(	O
filename	pointer
,	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_INSERT	int
)	O
{	O
const	O
Dwg_Data	struct
*	O
dwg	pointer
=	O
obj	pointer
->	O
parent	pointer
;	O
Dwg_Entity_INSERT	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
INSERT	pointer
;	O
if	O
(	O
_obj	pointer
->	O
has_attribs	char
)	O
{	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_13	int
&&	O
dwg	pointer
->	O
header	struct
.	O
version	short
<=	O
R_2000	int
)	O
{	O
Dwg_Object	struct
*	O
last_attrib	pointer
=	O
_obj	pointer
->	O
last_attrib	pointer
->	O
obj	pointer
;	O
Dwg_Object	struct
*	O
o	pointer
=	O
_obj	pointer
->	O
first_attrib	pointer
?	O
_obj	pointer
->	O
first_attrib	pointer
->	O
obj	pointer
:	O
NULL	O
;	O
while	O
(	O
o	pointer
&&	O
o	pointer
->	O
type	short
==	O
DWG_TYPE_ATTRIB	int
)	O
{	O
found	int
+=	O
match_ATTRIB	function
(	O
filename	pointer
,	O
o	pointer
)	O
;	O
o	pointer
=	O
dwg_next_object	function
(	O
o	pointer
)	O
;	O
if	O
(	O
o	pointer
==	O
last_attrib	pointer
)	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_2004	int
)	O
{	O
Dwg_Object	struct
*	O
o	pointer
;	O
for	O
(	O
BITCODE_BL	int
j	int
=	O
0	int
;	O
j	int
<	O
_obj	pointer
->	O
num_owned	int
;	O
j	int
++	O
)	O
{	O
o	pointer
=	O
_obj	pointer
->	O
attrib_handles	pointer
[	O
j	int
]	O
?	O
_obj	pointer
->	O
attrib_handles	pointer
[	O
j	int
]	O
->	O
obj	pointer
:	O
NULL	O
;	O
if	O
(	O
o	pointer
&&	O
o	pointer
->	O
type	short
==	O
DWG_TYPE_ATTRIB	int
)	O
found	int
+=	O
match_ATTRIB	function
(	O
filename	pointer
,	O
o	pointer
)	O
;	O
}	O
}	O
}	O
}	O
else	O
if	O
(	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_MINSERT	int
)	O
{	O
const	O
Dwg_Data	struct
*	O
dwg	pointer
=	O
obj	pointer
->	O
parent	pointer
;	O
Dwg_Entity_MINSERT	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
MINSERT	pointer
;	O
if	O
(	O
_obj	pointer
->	O
has_attribs	char
)	O
{	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_13	int
&&	O
dwg	pointer
->	O
header	struct
.	O
version	short
<=	O
R_2000	int
)	O
{	O
Dwg_Object	struct
*	O
last_attrib	pointer
=	O
_obj	pointer
->	O
last_attrib	pointer
->	O
obj	pointer
;	O
Dwg_Object	struct
*	O
o	pointer
=	O
_obj	pointer
->	O
first_attrib	pointer
?	O
_obj	pointer
->	O
first_attrib	pointer
->	O
obj	pointer
:	O
NULL	O
;	O
while	O
(	O
o	pointer
&&	O
o	pointer
->	O
type	short
==	O
DWG_TYPE_ATTRIB	int
)	O
{	O
found	int
+=	O
match_ATTRIB	function
(	O
filename	pointer
,	O
o	pointer
)	O
;	O
o	pointer
=	O
dwg_next_object	function
(	O
o	pointer
)	O
;	O
if	O
(	O
o	pointer
==	O
last_attrib	pointer
)	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_2004	int
)	O
{	O
Dwg_Object	struct
*	O
o	pointer
;	O
for	O
(	O
BITCODE_BL	int
j	int
=	O
0	int
;	O
j	int
<	O
_obj	pointer
->	O
num_owned	int
;	O
j	int
++	O
)	O
{	O
o	pointer
=	O
_obj	pointer
->	O
attrib_handles	pointer
[	O
j	int
]	O
?	O
_obj	pointer
->	O
attrib_handles	pointer
[	O
j	int
]	O
->	O
obj	pointer
:	O
NULL	O
;	O
if	O
(	O
o	pointer
&&	O
o	pointer
->	O
type	short
==	O
DWG_TYPE_ATTRIB	int
)	O
found	int
+=	O
match_ATTRIB	function
(	O
filename	pointer
,	O
o	pointer
)	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
!	O
opt_text	int
)	O
{	O
if	O
(	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_BLOCK	int
)	O
found	int
+=	O
match_BLOCK	function
(	O
filename	pointer
,	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_DIMENSION_ORDINATE	int
||	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_DIMENSION_LINEAR	int
||	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_DIMENSION_ALIGNED	int
||	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_DIMENSION_ANG3PT	int
||	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_DIMENSION_ANG2LN	int
||	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_DIMENSION_RADIUS	int
||	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_DIMENSION_DIAMETER	int
)	O
found	int
+=	O
match_DIMENSION	function
(	O
filename	pointer
,	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_VIEWPORT	int
)	O
found	int
+=	O
match_VIEWPORT	function
(	O
filename	pointer
,	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE__3DSOLID	int
||	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_BODY	int
||	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_REGION	int
)	O
found	int
+=	O
match_3DSOLID	function
(	O
filename	pointer
,	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_STYLE	int
)	O
found	int
+=	O
match_STYLE	function
(	O
filename	pointer
,	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_LTYPE	int
)	O
found	int
+=	O
match_LTYPE	function
(	O
filename	pointer
,	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_DIMSTYLE	int
)	O
found	int
+=	O
match_DIMSTYLE	function
(	O
filename	pointer
,	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_DICTIONARY	int
||	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_DICTIONARYWDFLT	int
)	O
found	int
+=	O
match_DICTIONARY	function
(	O
filename	pointer
,	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_GROUP	int
)	O
found	int
+=	O
match_GROUP	function
(	O
filename	pointer
,	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_MLINESTYLE	int
)	O
found	int
+=	O
match_MLINESTYLE	function
(	O
filename	pointer
,	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_DICTIONARYVAR	int
)	O
found	int
+=	O
match_DICTIONARYVAR	function
(	O
filename	pointer
,	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_HATCH	int
)	O
found	int
+=	O
match_HATCH	function
(	O
filename	pointer
,	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_IMAGEDEF	int
)	O
found	int
+=	O
match_IMAGEDEF	function
(	O
filename	pointer
,	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_LAYER_INDEX	int
)	O
found	int
+=	O
match_LAYER_INDEX	function
(	O
filename	pointer
,	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
obj	pointer
->	O
type	short
==	O
DWG_TYPE_LAYOUT	int
)	O
found	int
+=	O
match_LAYOUT	function
(	O
filename	pointer
,	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_SCALE	int
)	O
found	int
+=	O
match_SCALE	function
(	O
filename	pointer
,	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_FIELD	int
)	O
found	int
+=	O
match_FIELD	function
(	O
filename	pointer
,	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_TABLE	int
)	O
found	int
+=	O
match_TABLE	function
(	O
filename	pointer
,	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_TABLECONTENT	int
)	O
found	int
+=	O
match_TABLECONTENT	function
(	O
filename	pointer
,	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_GEODATA	int
)	O
found	int
+=	O
match_GEODATA	function
(	O
filename	pointer
,	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_GEOPOSITIONMARKER	int
)	O
found	int
+=	O
match_GEOPOSITIONMARKER	function
(	O
filename	pointer
,	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_UNDERLAYDEFINITION	int
)	O
found	int
+=	O
match_UNDERLAYDEFINITION	function
(	O
filename	pointer
,	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_VISUALSTYLE	int
)	O
found	int
+=	O
match_VISUALSTYLE	function
(	O
filename	pointer
,	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_LIGHT	int
)	O
found	int
+=	O
match_LIGHT	function
(	O
filename	pointer
,	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_SUNSTUDY	int
)	O
found	int
+=	O
match_SUNSTUDY	function
(	O
filename	pointer
,	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_LIGHTLIST	int
)	O
found	int
+=	O
match_LIGHTLIST	function
(	O
filename	pointer
,	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_DBCOLOR	int
)	O
found	int
+=	O
match_DBCOLOR	function
(	O
filename	pointer
,	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_MATERIAL	int
)	O
found	int
+=	O
match_MATERIAL	function
(	O
filename	pointer
,	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_PLOTSETTINGS	int
)	O
found	int
+=	O
match_PLOTSETTINGS	function
(	O
filename	pointer
,	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_ASSOCACTION	int
)	O
found	int
+=	O
match_ASSOCACTION	function
(	O
filename	pointer
,	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_ASSOCOSNAPPOINTREFACTIONPARAM	int
)	O
found	int
+=	O
match_ASSOCOSNAPPOINTREFACTIONPARAM	function
(	O
filename	pointer
,	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_NAVISWORKSMODELDEF	int
)	O
found	int
+=	O
match_NAVISWORKSMODELDEF	function
(	O
filename	pointer
,	O
obj	pointer
)	O
;	O
}	O
}	O
if	O
(	O
!	O
opt_text	int
)	O
{	O
if	O
(	O
obj	pointer
->	O
supertype	enum
==	O
DWG_SUPERTYPE_ENTITY	int
)	O
{	O
MATCH_TABLE	O
(	O
ENTITY	O
,	O
layer	int
,	O
LAYER	pointer
,	O
8	int
)	O
;	O
MATCH_TABLE	O
(	O
ENTITY	O
,	O
ltype	pointer
,	O
LTYPE	pointer
,	O
8	int
)	O
;	O
if	O
(	O
obj	pointer
->	O
parent	pointer
->	O
header	struct
.	O
version	short
>=	O
R_2000	int
)	O
{	O
MATCH_TABLE	O
(	O
ENTITY	O
,	O
plotstyle	pointer
,	O
PLOTSTYLE	O
,	O
8	int
)	O
;	O
}	O
if	O
(	O
obj	pointer
->	O
parent	pointer
->	O
header	struct
.	O
version	short
>=	O
R_2007	int
)	O
{	O
MATCH_TABLE	O
(	O
ENTITY	O
,	O
material	pointer
,	O
MATERIAL	pointer
,	O
8	int
)	O
;	O
MATCH_TABLE	O
(	O
ENTITY	O
,	O
shadow	pointer
,	O
DICTIONARY	pointer
,	O
8	int
)	O
;	O
}	O
if	O
(	O
obj	pointer
->	O
parent	pointer
->	O
header	struct
.	O
version	short
>=	O
R_2010	int
)	O
{	O
MATCH_TABLE	O
(	O
ENTITY	O
,	O
full_visualstyle	pointer
,	O
VISUALSTYLE	pointer
,	O
8	int
)	O
;	O
MATCH_TABLE	O
(	O
ENTITY	O
,	O
face_visualstyle	pointer
,	O
VISUALSTYLE	pointer
,	O
8	int
)	O
;	O
MATCH_TABLE	O
(	O
ENTITY	O
,	O
edge_visualstyle	pointer
,	O
VISUALSTYLE	pointer
,	O
8	int
)	O
;	O
}	O
}	O
}	O
}	O
return	O
found	int
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array
[	O
]	O
)	O
{	O
int	O
error	int
=	O
0	int
;	O
int	O
i	int
=	O
1	int
,	O
j	int
;	O
char	O
*	O
filename	pointer
;	O
Dwg_Data	struct
dwg	pointer
;	O
int	O
plen	int
;	O
int	O
errcode	int
;	O
int	O
opt_recurse	int
=	O
0	int
;	O
int	O
count	int
=	O
0	int
;	O
int	O
c	int
;	O
int	O
option_index	int
=	O
0	int
;	O
static	O
struct	O
option	struct
long_options	array
[	O
]	O
=	O
{	O
{	O
"case"	pointer
,	O
0	int
,	O
0	int
,	O
'i'	O
}	O
,	O
{	O
"extended"	pointer
,	O
0	int
,	O
0	int
,	O
'x'	O
}	O
,	O
{	O
"count"	pointer
,	O
0	int
,	O
0	int
,	O
'c'	O
}	O
,	O
{	O
"no-filename"	pointer
,	O
0	int
,	O
0	int
,	O
'h'	O
}	O
,	O
{	O
"recursive"	pointer
,	O
0	int
,	O
0	int
,	O
'r'	O
}	O
,	O
{	O
"recursive"	pointer
,	O
0	int
,	O
0	int
,	O
'R'	O
}	O
,	O
{	O
"type"	pointer
,	O
1	int
,	O
0	int
,	O
'y'	O
}	O
,	O
{	O
"dxf"	pointer
,	O
1	int
,	O
0	int
,	O
'd'	O
}	O
,	O
{	O
"text"	pointer
,	O
0	int
,	O
0	int
,	O
't'	O
}	O
,	O
{	O
"tables"	pointer
,	O
0	int
,	O
0	int
,	O
'b'	O
}	O
,	O
{	O
"help"	pointer
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"version"	pointer
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
if	O
(	O
argc	int
<	O
2	int
)	O
return	O
usage	function
(	O
)	O
;	O
memset	function
(	O
dxf	short
,	O
0	int
,	O
10	int
*	O
sizeof	O
(	O
short	O
)	O
)	O
;	O
while	O
(	O
(	O
c	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	array
,	O
"ixchrRy:d:tb"	pointer
,	O
long_options	array
,	O
&	O
option_index	int
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
c	int
==	O
-	O
1	int
)	O
break	O
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
0	int
:	O
if	O
(	O
!	O
strcmp	function
(	O
long_options	array
[	O
option_index	int
]	O
.	O
name	pointer
,	O
"help"	pointer
)	O
)	O
return	O
help	function
(	O
)	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
long_options	array
[	O
option_index	int
]	O
.	O
name	pointer
,	O
"version"	pointer
)	O
)	O
return	O
opt_version	function
(	O
)	O
;	O
break	O
;	O
case	O
'i'	O
:	O
options	int
|=	O
PCRE2_CASELESS	int
;	O
break	O
;	O
case	O
'c'	O
:	O
opt_count	int
=	O
1	int
;	O
break	O
;	O
case	O
'h'	O
:	O
opt_filename	int
=	O
0	int
;	O
break	O
;	O
case	O
'r'	O
:	O
case	O
'R'	O
:	O
opt_recurse	int
=	O
1	int
;	O
break	O
;	O
case	O
't'	O
:	O
opt_text	int
=	O
1	int
;	O
break	O
;	O
case	O
'b'	O
:	O
opt_tables	int
=	O
1	int
;	O
break	O
;	O
case	O
'y'	O
:	O
if	O
(	O
numtype	short
>=	O
10	int
)	O
return	O
usage	function
(	O
)	O
;	O
type	short
[	O
numtype	short
++	O
]	O
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'd'	O
:	O
if	O
(	O
numdxf	short
>=	O
10	int
)	O
return	O
usage	function
(	O
)	O
;	O
dxf	short
[	O
numdxf	short
++	O
]	O
=	O
(	O
short	O
)	O
strtol	function
(	O
optarg	pointer
,	O
NULL	O
,	O
10	int
)	O
;	O
break	O
;	O
case	O
'u'	O
:	O
return	O
help	function
(	O
)	O
;	O
case	O
'?'	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: invalid option '-%c' ignored\n"	pointer
,	O
argv	array
[	O
0	int
]	O
,	O
optopt	int
)	O
;	O
break	O
;	O
default	O
:	O
return	O
usage	function
(	O
)	O
;	O
}	O
}	O
i	int
=	O
optind	int
;	O
if	O
(	O
i	int
>	O
argc	int
-	O
2	int
)	O
return	O
usage	function
(	O
)	O
;	O
pattern	pointer
=	O
argv	array
[	O
i	int
]	O
;	O
plen	int
=	O
strlen	function
(	O
pattern	pointer
)	O
;	O
for	O
(	O
j	int
=	O
i	int
+	O
1	int
;	O
j	int
<	O
argc	int
;	O
j	int
++	O
)	O
{	O
long	O
k	int
;	O
filename	pointer
=	O
argv	array
[	O
j	int
]	O
;	O
memset	function
(	O
&	O
dwg	pointer
,	O
0	int
,	O
sizeof	O
(	O
Dwg_Data	struct
)	O
)	O
;	O
dwg	pointer
.	O
opts	int
=	O
0	int
;	O
error	int
=	O
dwg_read_file	function
(	O
filename	pointer
,	O
&	O
dwg	pointer
)	O
;	O
if	O
(	O
error	int
>	O
DWG_ERR_CRITICAL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Error: Could not read DWG file %s, error: 0x%x\n"	pointer
,	O
filename	pointer
,	O
error	int
)	O
;	O
continue	O
;	O
}	O
count	int
+=	O
match_BLOCK_HEADER	function
(	O
filename	pointer
,	O
dwg_model_space_ref	function
(	O
&	O
dwg	pointer
)	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
dwg	pointer
.	O
block_control	struct
.	O
num_entries	short
;	O
k	int
++	O
)	O
{	O
count	int
+=	O
match_BLOCK_HEADER	function
(	O
filename	pointer
,	O
dwg	pointer
.	O
block_control	struct
.	O
entries	pointer
[	O
k	int
]	O
)	O
;	O
}	O
count	int
+=	O
match_BLOCK_HEADER	function
(	O
filename	pointer
,	O
dwg_paper_space_ref	function
(	O
&	O
dwg	pointer
)	O
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
if	O
(	O
j	int
<	O
argc	int
)	O
dwg_free	function
(	O
&	O
dwg	pointer
)	O
;	O
}	O
if	O
(	O
opt_count	int
)	O
printf	function
(	O
"%d\n"	pointer
,	O
count	int
)	O
;	O
return	O
count	int
?	O
0	int
:	O
1	int
;	O
}	O
