static	O
char	O
rcsid	array
[	O
]	O
=	O
"$Id: rpc_scan.c,v 1.1.1.1 2005/10/28 14:46:46 k0ro Exp $"	pointer
;	O
static	O
int	O
pushed	int
=	O
0	int
;	O
static	O
token	struct
lasttok	struct
;	O
static	O
void	O
unget_token	function
(	O
)	O
,	O
findstrconst	function
(	O
)	O
,	O
findconst	function
(	O
)	O
,	O
findkind	function
(	O
)	O
,	O
printdirective	function
(	O
)	O
,	O
docppline	function
(	O
)	O
;	O
static	O
int	O
cppline	function
(	O
)	O
,	O
directive	function
(	O
)	O
;	O
void	O
scan	function
(	O
expect	enum
,	O
tokp	pointer
)	O
tok_kind	enum
expect	enum
;	O
token	struct
*	O
tokp	pointer
;	O
{	O
get_token	function
(	O
tokp	pointer
)	O
;	O
if	O
(	O
tokp	pointer
->	O
kind	enum
!=	O
expect	enum
)	O
{	O
expected1	function
(	O
expect	enum
)	O
;	O
}	O
}	O
void	O
scan2	function
(	O
expect1	enum
,	O
expect2	enum
,	O
tokp	pointer
)	O
tok_kind	enum
expect1	enum
;	O
tok_kind	enum
expect2	enum
;	O
token	struct
*	O
tokp	pointer
;	O
{	O
get_token	function
(	O
tokp	pointer
)	O
;	O
if	O
(	O
tokp	pointer
->	O
kind	enum
!=	O
expect1	enum
&&	O
tokp	pointer
->	O
kind	enum
!=	O
expect2	enum
)	O
{	O
expected2	function
(	O
expect1	enum
,	O
expect2	enum
)	O
;	O
}	O
}	O
void	O
scan3	function
(	O
expect1	enum
,	O
expect2	enum
,	O
expect3	enum
,	O
tokp	pointer
)	O
tok_kind	enum
expect1	enum
;	O
tok_kind	enum
expect2	enum
;	O
tok_kind	enum
expect3	enum
;	O
token	struct
*	O
tokp	pointer
;	O
{	O
get_token	function
(	O
tokp	pointer
)	O
;	O
if	O
(	O
tokp	pointer
->	O
kind	enum
!=	O
expect1	enum
&&	O
tokp	pointer
->	O
kind	enum
!=	O
expect2	enum
&&	O
tokp	pointer
->	O
kind	enum
!=	O
expect3	enum
)	O
{	O
expected3	function
(	O
expect1	enum
,	O
expect2	enum
,	O
expect3	enum
)	O
;	O
}	O
}	O
void	O
scan_num	function
(	O
tokp	pointer
)	O
token	struct
*	O
tokp	pointer
;	O
{	O
get_token	function
(	O
tokp	pointer
)	O
;	O
switch	O
(	O
tokp	pointer
->	O
kind	enum
)	O
{	O
case	O
TOK_IDENT	int
:	O
break	O
;	O
default	O
:	O
error	function
(	O
"constant or identifier expected"	pointer
)	O
;	O
}	O
}	O
void	O
peek	function
(	O
tokp	pointer
)	O
token	struct
*	O
tokp	pointer
;	O
{	O
get_token	function
(	O
tokp	pointer
)	O
;	O
unget_token	function
(	O
tokp	pointer
)	O
;	O
}	O
int	O
peekscan	function
(	O
expect	enum
,	O
tokp	pointer
)	O
tok_kind	enum
expect	enum
;	O
token	struct
*	O
tokp	pointer
;	O
{	O
peek	function
(	O
tokp	pointer
)	O
;	O
if	O
(	O
tokp	pointer
->	O
kind	enum
==	O
expect	enum
)	O
{	O
get_token	function
(	O
tokp	pointer
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
void	O
get_token	function
(	O
tokp	pointer
)	O
token	struct
*	O
tokp	pointer
;	O
{	O
int	O
commenting	int
;	O
if	O
(	O
pushed	int
)	O
{	O
pushed	int
=	O
0	int
;	O
*	O
tokp	pointer
=	O
lasttok	struct
;	O
return	O
;	O
}	O
commenting	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
*	O
where	pointer
==	O
0	int
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
!	O
fgets	function
(	O
curline	array
,	O
MAXLINESIZE	int
,	O
fin	pointer
)	O
)	O
{	O
tokp	pointer
->	O
kind	enum
=	O
TOK_EOF	int
;	O
*	O
where	pointer
=	O
0	int
;	O
return	O
;	O
}	O
linenum	int
++	O
;	O
if	O
(	O
commenting	int
)	O
{	O
break	O
;	O
}	O
else	O
if	O
(	O
cppline	function
(	O
curline	array
)	O
)	O
{	O
docppline	function
(	O
curline	array
,	O
&	O
linenum	int
,	O
&	O
infilename	pointer
)	O
;	O
}	O
else	O
if	O
(	O
directive	function
(	O
curline	array
)	O
)	O
{	O
printdirective	function
(	O
curline	array
)	O
;	O
}	O
else	O
{	O
break	O
;	O
}	O
}	O
where	pointer
=	O
curline	array
;	O
}	O
else	O
if	O
(	O
isspace	function
(	O
*	O
where	pointer
)	O
)	O
{	O
while	O
(	O
isspace	function
(	O
*	O
where	pointer
)	O
)	O
{	O
where	pointer
++	O
;	O
}	O
}	O
else	O
if	O
(	O
commenting	int
)	O
{	O
where	pointer
++	O
;	O
if	O
(	O
endcomment	O
(	O
where	pointer
)	O
)	O
{	O
where	pointer
++	O
;	O
commenting	int
--	O
;	O
}	O
}	O
else	O
if	O
(	O
startcomment	O
(	O
where	pointer
)	O
)	O
{	O
where	pointer
+=	O
2	int
;	O
commenting	int
++	O
;	O
}	O
else	O
{	O
break	O
;	O
}	O
}	O
switch	O
(	O
*	O
where	pointer
)	O
{	O
case	O
':'	O
:	O
tokp	pointer
->	O
kind	enum
=	O
TOK_COLON	int
;	O
where	pointer
++	O
;	O
break	O
;	O
case	O
';'	O
:	O
tokp	pointer
->	O
kind	enum
=	O
TOK_SEMICOLON	int
;	O
where	pointer
++	O
;	O
break	O
;	O
case	O
','	O
:	O
tokp	pointer
->	O
kind	enum
=	O
TOK_COMMA	int
;	O
where	pointer
++	O
;	O
break	O
;	O
case	O
'='	O
:	O
tokp	pointer
->	O
kind	enum
=	O
TOK_EQUAL	int
;	O
where	pointer
++	O
;	O
break	O
;	O
case	O
'*'	O
:	O
tokp	pointer
->	O
kind	enum
=	O
TOK_STAR	int
;	O
where	pointer
++	O
;	O
break	O
;	O
case	O
'['	O
:	O
tokp	pointer
->	O
kind	enum
=	O
TOK_LBRACKET	int
;	O
where	pointer
++	O
;	O
break	O
;	O
case	O
']'	O
:	O
tokp	pointer
->	O
kind	enum
=	O
TOK_RBRACKET	int
;	O
where	pointer
++	O
;	O
break	O
;	O
case	O
'{'	O
:	O
tokp	pointer
->	O
kind	enum
=	O
TOK_LBRACE	int
;	O
where	pointer
++	O
;	O
break	O
;	O
case	O
'}'	O
:	O
tokp	pointer
->	O
kind	enum
=	O
TOK_RBRACE	int
;	O
where	pointer
++	O
;	O
break	O
;	O
case	O
'('	O
:	O
tokp	pointer
->	O
kind	enum
=	O
TOK_LPAREN	int
;	O
where	pointer
++	O
;	O
break	O
;	O
case	O
')'	O
:	O
tokp	pointer
->	O
kind	enum
=	O
TOK_RPAREN	int
;	O
where	pointer
++	O
;	O
break	O
;	O
case	O
'<'	O
:	O
tokp	pointer
->	O
kind	enum
=	O
TOK_LANGLE	int
;	O
where	pointer
++	O
;	O
break	O
;	O
case	O
'>'	O
:	O
tokp	pointer
->	O
kind	enum
=	O
TOK_RANGLE	int
;	O
where	pointer
++	O
;	O
break	O
;	O
case	O
'"'	O
:	O
tokp	pointer
->	O
kind	enum
=	O
TOK_STRCONST	int
;	O
findstrconst	function
(	O
&	O
where	pointer
,	O
&	O
tokp	pointer
->	O
str	pointer
)	O
;	O
break	O
;	O
case	O
'-'	O
:	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
tokp	pointer
->	O
kind	enum
=	O
TOK_IDENT	int
;	O
findconst	function
(	O
&	O
where	pointer
,	O
&	O
tokp	pointer
->	O
str	pointer
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
!	O
(	O
isalpha	function
(	O
*	O
where	pointer
)	O
||	O
*	O
where	pointer
==	O
'_'	O
)	O
)	O
{	O
char	O
buf	array
[	O
100	int
]	O
;	O
char	O
*	O
p	pointer
;	O
s_print	O
(	O
buf	array
,	O
"illegal character in file: "	pointer
)	O
;	O
p	pointer
=	O
buf	array
+	O
strlen	O
(	O
buf	array
)	O
;	O
if	O
(	O
isprint	function
(	O
*	O
where	pointer
)	O
)	O
{	O
s_print	O
(	O
p	pointer
,	O
"%c"	pointer
,	O
*	O
where	pointer
)	O
;	O
}	O
else	O
{	O
s_print	O
(	O
p	pointer
,	O
"%d"	pointer
,	O
*	O
where	pointer
)	O
;	O
}	O
error	function
(	O
buf	array
)	O
;	O
}	O
findkind	function
(	O
&	O
where	pointer
,	O
tokp	pointer
)	O
;	O
break	O
;	O
}	O
}	O
static	O
void	O
unget_token	function
(	O
tokp	pointer
)	O
token	struct
*	O
tokp	pointer
;	O
{	O
lasttok	struct
=	O
*	O
tokp	pointer
;	O
pushed	int
=	O
1	int
;	O
}	O
static	O
void	O
findstrconst	function
(	O
str	pointer
,	O
val	pointer
)	O
char	O
*	O
*	O
str	pointer
;	O
char	O
*	O
*	O
val	pointer
;	O
{	O
char	O
*	O
p	pointer
;	O
int	O
size	int
;	O
p	pointer
=	O
*	O
str	pointer
;	O
do	O
{	O
*	O
p	pointer
++	O
;	O
}	O
while	O
(	O
*	O
p	pointer
&&	O
*	O
p	pointer
!=	O
'"'	O
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
0	int
)	O
{	O
error	function
(	O
"unterminated string constant"	pointer
)	O
;	O
}	O
p	pointer
++	O
;	O
size	int
=	O
p	pointer
-	O
*	O
str	pointer
;	O
*	O
val	pointer
=	O
alloc	O
(	O
size	int
+	O
1	int
)	O
;	O
(	O
void	O
)	O
strncpy	O
(	O
*	O
val	pointer
,	O
*	O
str	pointer
,	O
size	int
)	O
;	O
(	O
*	O
val	pointer
)	O
[	O
size	int
]	O
=	O
0	int
;	O
*	O
str	pointer
=	O
p	pointer
;	O
}	O
static	O
void	O
findconst	function
(	O
str	pointer
,	O
val	pointer
)	O
char	O
*	O
*	O
str	pointer
;	O
char	O
*	O
*	O
val	pointer
;	O
{	O
char	O
*	O
p	pointer
;	O
int	O
size	int
;	O
p	pointer
=	O
*	O
str	pointer
;	O
if	O
(	O
*	O
p	pointer
==	O
'0'	O
&&	O
*	O
(	O
p	pointer
+	O
1	int
)	O
==	O
'x'	O
)	O
{	O
p	pointer
++	O
;	O
do	O
{	O
p	pointer
++	O
;	O
}	O
while	O
(	O
isxdigit	function
(	O
*	O
p	pointer
)	O
)	O
;	O
}	O
else	O
{	O
do	O
{	O
p	pointer
++	O
;	O
}	O
while	O
(	O
isdigit	function
(	O
*	O
p	pointer
)	O
)	O
;	O
}	O
size	int
=	O
p	pointer
-	O
*	O
str	pointer
;	O
*	O
val	pointer
=	O
alloc	O
(	O
size	int
+	O
1	int
)	O
;	O
(	O
void	O
)	O
strncpy	O
(	O
*	O
val	pointer
,	O
*	O
str	pointer
,	O
size	int
)	O
;	O
(	O
*	O
val	pointer
)	O
[	O
size	int
]	O
=	O
0	int
;	O
*	O
str	pointer
=	O
p	pointer
;	O
}	O
static	O
token	struct
symbols	array
[	O
]	O
=	O
{	O
{	O
TOK_CONST	int
,	O
"const"	pointer
}	O
,	O
{	O
TOK_UNION	int
,	O
"union"	pointer
}	O
,	O
{	O
TOK_SWITCH	int
,	O
"switch"	pointer
}	O
,	O
{	O
TOK_CASE	int
,	O
"case"	pointer
}	O
,	O
{	O
TOK_DEFAULT	int
,	O
"default"	pointer
}	O
,	O
{	O
TOK_STRUCT	int
,	O
"struct"	pointer
}	O
,	O
{	O
TOK_TYPEDEF	int
,	O
"typedef"	pointer
}	O
,	O
{	O
TOK_ENUM	int
,	O
"enum"	pointer
}	O
,	O
{	O
TOK_OPAQUE	int
,	O
"opaque"	pointer
}	O
,	O
{	O
TOK_BOOL	int
,	O
"bool"	pointer
}	O
,	O
{	O
TOK_VOID	int
,	O
"void"	pointer
}	O
,	O
{	O
TOK_CHAR	int
,	O
"char"	pointer
}	O
,	O
{	O
TOK_INT	int
,	O
"int"	pointer
}	O
,	O
{	O
TOK_UNSIGNED	int
,	O
"unsigned"	pointer
}	O
,	O
{	O
TOK_SHORT	int
,	O
"short"	pointer
}	O
,	O
{	O
TOK_LONG	int
,	O
"long"	pointer
}	O
,	O
{	O
TOK_FLOAT	int
,	O
"float"	pointer
}	O
,	O
{	O
TOK_DOUBLE	int
,	O
"double"	pointer
}	O
,	O
{	O
TOK_STRING	int
,	O
"string"	pointer
}	O
,	O
{	O
TOK_PROGRAM	int
,	O
"program"	pointer
}	O
,	O
{	O
TOK_VERSION	int
,	O
"version"	pointer
}	O
,	O
{	O
TOK_EOF	int
,	O
"??????"	pointer
}	O
,	O
}	O
;	O
static	O
void	O
findkind	function
(	O
mark	pointer
,	O
tokp	pointer
)	O
char	O
*	O
*	O
mark	pointer
;	O
token	struct
*	O
tokp	pointer
;	O
{	O
int	O
len	int
;	O
token	struct
*	O
s	pointer
;	O
char	O
*	O
str	pointer
;	O
str	pointer
=	O
*	O
mark	pointer
;	O
for	O
(	O
s	pointer
=	O
symbols	array
;	O
s	pointer
->	O
kind	enum
!=	O
TOK_EOF	int
;	O
s	pointer
++	O
)	O
{	O
len	int
=	O
strlen	O
(	O
s	pointer
->	O
str	pointer
)	O
;	O
if	O
(	O
strncmp	O
(	O
str	pointer
,	O
s	pointer
->	O
str	pointer
,	O
len	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
!	O
isalnum	function
(	O
str	pointer
[	O
len	int
]	O
)	O
&&	O
str	pointer
[	O
len	int
]	O
!=	O
'_'	O
)	O
{	O
tokp	pointer
->	O
kind	enum
=	O
s	pointer
->	O
kind	enum
;	O
tokp	pointer
->	O
str	pointer
=	O
s	pointer
->	O
str	pointer
;	O
*	O
mark	pointer
=	O
str	pointer
+	O
len	int
;	O
return	O
;	O
}	O
}	O
}	O
tokp	pointer
->	O
kind	enum
=	O
TOK_IDENT	int
;	O
for	O
(	O
len	int
=	O
0	int
;	O
isalnum	function
(	O
str	pointer
[	O
len	int
]	O
)	O
||	O
str	pointer
[	O
len	int
]	O
==	O
'_'	O
;	O
len	int
++	O
)	O
;	O
tokp	pointer
->	O
str	pointer
=	O
alloc	O
(	O
len	int
+	O
1	int
)	O
;	O
(	O
void	O
)	O
strncpy	O
(	O
tokp	pointer
->	O
str	pointer
,	O
str	pointer
,	O
len	int
)	O
;	O
tokp	pointer
->	O
str	pointer
[	O
len	int
]	O
=	O
0	int
;	O
*	O
mark	pointer
=	O
str	pointer
+	O
len	int
;	O
}	O
static	O
int	O
cppline	function
(	O
line	pointer
)	O
char	O
*	O
line	pointer
;	O
{	O
return	O
(	O
line	pointer
==	O
curline	array
&&	O
*	O
line	pointer
==	O
'#'	O
)	O
;	O
}	O
static	O
int	O
directive	function
(	O
line	pointer
)	O
char	O
*	O
line	pointer
;	O
{	O
return	O
(	O
line	pointer
==	O
curline	array
&&	O
*	O
line	pointer
==	O
'%'	O
)	O
;	O
}	O
static	O
void	O
printdirective	function
(	O
line	pointer
)	O
char	O
*	O
line	pointer
;	O
{	O
f_print	O
(	O
fout	pointer
,	O
"%s"	pointer
,	O
line	pointer
+	O
1	int
)	O
;	O
}	O
static	O
void	O
docppline	function
(	O
line	pointer
,	O
lineno	pointer
,	O
fname	pointer
)	O
char	O
*	O
line	pointer
;	O
int	O
*	O
lineno	pointer
;	O
char	O
*	O
*	O
fname	pointer
;	O
{	O
char	O
*	O
file	pointer
;	O
int	O
num	int
;	O
char	O
*	O
p	pointer
;	O
if	O
(	O
strncmp	O
(	O
line	pointer
,	O
"#line"	pointer
,	O
5	int
)	O
==	O
0	int
)	O
{	O
line	pointer
+=	O
5	int
;	O
}	O
line	pointer
++	O
;	O
while	O
(	O
isspace	function
(	O
*	O
line	pointer
)	O
)	O
{	O
line	pointer
++	O
;	O
}	O
num	int
=	O
atoi	function
(	O
line	pointer
)	O
;	O
while	O
(	O
isdigit	function
(	O
*	O
line	pointer
)	O
)	O
{	O
line	pointer
++	O
;	O
}	O
while	O
(	O
isspace	function
(	O
*	O
line	pointer
)	O
)	O
{	O
line	pointer
++	O
;	O
}	O
if	O
(	O
*	O
line	pointer
!=	O
'"'	O
)	O
{	O
error	function
(	O
"preprocessor error"	pointer
)	O
;	O
}	O
line	pointer
++	O
;	O
p	pointer
=	O
file	pointer
=	O
alloc	O
(	O
strlen	O
(	O
line	pointer
)	O
+	O
1	int
)	O
;	O
while	O
(	O
*	O
line	pointer
&&	O
*	O
line	pointer
!=	O
'"'	O
)	O
{	O
*	O
p	pointer
++	O
=	O
*	O
line	pointer
++	O
;	O
}	O
if	O
(	O
*	O
line	pointer
==	O
0	int
)	O
{	O
error	function
(	O
"preprocessor error"	pointer
)	O
;	O
}	O
*	O
p	pointer
=	O
0	int
;	O
if	O
(	O
*	O
file	pointer
==	O
0	int
)	O
{	O
*	O
fname	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
*	O
fname	pointer
=	O
file	pointer
;	O
}	O
*	O
lineno	pointer
=	O
num	int
-	O
1	int
;	O
}	O
