static	O
inline	O
struct	O
pgrp	O
*	O
new_pgrp	function
(	O
pid_t	int
pgid	int
,	O
struct	O
session	O
*	O
sess	pointer
)	O
{	O
struct	O
pgrp	O
*	O
pg	pointer
;	O
pg	pointer
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
pgrp	O
)	O
)	O
;	O
if	O
(	O
!	O
pg	pointer
)	O
return	O
NULL	O
;	O
pg	pointer
->	O
pg_plist	O
=	O
0	int
;	O
pg	pointer
->	O
pg_pgid	O
=	O
pgid	int
;	O
pg	pointer
->	O
pg_orphcnt	O
=	O
0	int
;	O
pg	pointer
->	O
pg_session	O
=	O
sess	pointer
;	O
pg	pointer
->	O
pg_next	O
=	O
sess	pointer
->	O
s_pgrps	O
;	O
if	O
(	O
pg	pointer
->	O
pg_next	O
)	O
pg	pointer
->	O
pg_next	O
->	O
pg_prevp	O
=	O
&	O
pg	pointer
->	O
pg_next	O
;	O
sess	pointer
->	O
s_pgrps	O
=	O
pg	pointer
;	O
pg	pointer
->	O
pg_prevp	O
=	O
&	O
sess	pointer
->	O
s_pgrps	O
;	O
add_pgrp_to_hash	function
(	O
pg	pointer
)	O
;	O
return	O
pg	pointer
;	O
}	O
static	O
inline	O
struct	O
session	O
*	O
new_session	function
(	O
struct	O
proc	O
*	O
p	pointer
)	O
{	O
struct	O
session	O
*	O
sess	pointer
;	O
sess	pointer
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
session	O
)	O
)	O
;	O
if	O
(	O
!	O
sess	pointer
)	O
return	O
NULL	O
;	O
sess	pointer
->	O
s_sid	O
=	O
p	pointer
->	O
p_pid	O
;	O
sess	pointer
->	O
s_pgrps	O
=	O
0	int
;	O
sess	pointer
->	O
s_sessionid	O
=	O
MACH_PORT_NULL	O
;	O
add_session_to_hash	function
(	O
sess	pointer
)	O
;	O
return	O
sess	pointer
;	O
}	O
static	O
inline	O
void	O
free_session	function
(	O
struct	O
session	O
*	O
s	pointer
)	O
{	O
if	O
(	O
s	pointer
->	O
s_sessionid	O
)	O
mach_port_mod_refs	function
(	O
mach_task_self	function
(	O
)	O
,	O
s	pointer
->	O
s_sessionid	O
,	O
MACH_PORT_RIGHT_RECEIVE	O
,	O
-	O
1	int
)	O
;	O
remove_session_from_hash	function
(	O
s	pointer
)	O
;	O
free	function
(	O
s	pointer
)	O
;	O
}	O
static	O
inline	O
void	O
free_pgrp	function
(	O
struct	O
pgrp	O
*	O
pg	pointer
)	O
{	O
*	O
pg	pointer
->	O
pg_prevp	O
=	O
pg	pointer
->	O
pg_next	O
;	O
if	O
(	O
pg	pointer
->	O
pg_next	O
)	O
pg	pointer
->	O
pg_next	O
->	O
pg_prevp	O
=	O
pg	pointer
->	O
pg_prevp	O
;	O
if	O
(	O
!	O
pg	pointer
->	O
pg_session	O
->	O
s_pgrps	O
)	O
free_session	function
(	O
pg	pointer
->	O
pg_session	O
)	O
;	O
remove_pgrp_from_hash	function
(	O
pg	pointer
)	O
;	O
free	function
(	O
pg	pointer
)	O
;	O
}	O
kern_return_t	O
S_proc_setsid	function
(	O
struct	O
proc	O
*	O
p	pointer
)	O
{	O
struct	O
session	O
*	O
sess	pointer
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
EOPNOTSUPP	O
;	O
if	O
(	O
p	pointer
->	O
p_pgrp	O
->	O
pg_pgid	O
==	O
p	pointer
->	O
p_pid	O
||	O
pgrp_find	function
(	O
p	pointer
->	O
p_pid	O
)	O
)	O
return	O
EPERM	O
;	O
leave_pgrp	function
(	O
p	pointer
)	O
;	O
sess	pointer
=	O
new_session	function
(	O
p	pointer
)	O
;	O
p	pointer
->	O
p_pgrp	O
=	O
new_pgrp	function
(	O
p	pointer
->	O
p_pid	O
,	O
sess	pointer
)	O
;	O
join_pgrp	function
(	O
p	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
boot_setsid	function
(	O
struct	O
proc	O
*	O
p	pointer
)	O
{	O
struct	O
session	O
*	O
sess	pointer
;	O
sess	pointer
=	O
new_session	function
(	O
p	pointer
)	O
;	O
p	pointer
->	O
p_pgrp	O
=	O
new_pgrp	function
(	O
p	pointer
->	O
p_pid	O
,	O
sess	pointer
)	O
;	O
assert	function
(	O
p	pointer
->	O
p_pgrp	O
)	O
;	O
join_pgrp	function
(	O
p	pointer
)	O
;	O
return	O
;	O
}	O
kern_return_t	O
S_proc_getsid	function
(	O
struct	O
proc	O
*	O
callerp	pointer
,	O
pid_t	int
pid	int
,	O
pid_t	int
*	O
sid	pointer
)	O
{	O
struct	O
proc	O
*	O
p	pointer
=	O
pid_find	function
(	O
pid	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
ESRCH	O
;	O
*	O
sid	pointer
=	O
p	pointer
->	O
p_pgrp	O
->	O
pg_session	O
->	O
s_sid	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_getsessionpids	function
(	O
struct	O
proc	O
*	O
callerp	pointer
,	O
pid_t	int
sid	pointer
,	O
pid_t	int
*	O
*	O
pids	pointer
,	O
size_t	long
*	O
npidsp	pointer
)	O
{	O
int	O
count	int
;	O
struct	O
pgrp	O
*	O
pg	pointer
;	O
struct	O
proc	O
*	O
p	pointer
;	O
struct	O
session	O
*	O
s	pointer
;	O
pid_t	int
*	O
pp	pointer
=	O
*	O
pids	pointer
;	O
u_int	int
npids	int
=	O
*	O
npidsp	pointer
;	O
s	pointer
=	O
session_find	function
(	O
sid	pointer
)	O
;	O
if	O
(	O
!	O
s	pointer
)	O
return	O
ESRCH	O
;	O
count	int
=	O
0	int
;	O
for	O
(	O
pg	pointer
=	O
s	pointer
->	O
s_pgrps	O
;	O
pg	pointer
;	O
pg	pointer
=	O
pg	pointer
->	O
pg_next	O
)	O
for	O
(	O
p	pointer
=	O
pg	pointer
->	O
pg_plist	O
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
p_gnext	O
)	O
{	O
if	O
(	O
++	O
count	int
<=	O
npids	int
)	O
*	O
pp	pointer
++	O
=	O
p	pointer
->	O
p_pid	O
;	O
}	O
if	O
(	O
count	int
>	O
npids	int
)	O
{	O
*	O
pids	pointer
=	O
mmap	function
(	O
0	int
,	O
count	int
*	O
sizeof	O
(	O
pid_t	int
)	O
,	O
PROT_READ	O
|	O
PROT_WRITE	O
,	O
MAP_ANON	O
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
*	O
pids	pointer
==	O
MAP_FAILED	O
)	O
return	O
errno	O
;	O
pp	pointer
=	O
*	O
pids	pointer
;	O
for	O
(	O
pg	pointer
=	O
s	pointer
->	O
s_pgrps	O
;	O
pg	pointer
;	O
pg	pointer
=	O
pg	pointer
->	O
pg_next	O
)	O
for	O
(	O
p	pointer
=	O
pg	pointer
->	O
pg_plist	O
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
p_gnext	O
)	O
*	O
pp	pointer
++	O
=	O
p	pointer
->	O
p_pid	O
;	O
}	O
*	O
npidsp	pointer
=	O
count	int
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_getsessionpgids	function
(	O
struct	O
proc	O
*	O
callerp	pointer
,	O
pid_t	int
sid	pointer
,	O
pid_t	int
*	O
*	O
pgids	pointer
,	O
size_t	long
*	O
npgidsp	pointer
)	O
{	O
int	O
count	int
;	O
struct	O
pgrp	O
*	O
pg	pointer
;	O
struct	O
session	O
*	O
s	pointer
;	O
pid_t	int
*	O
pp	pointer
=	O
*	O
pgids	pointer
;	O
int	O
npgids	int
=	O
*	O
npgidsp	pointer
;	O
s	pointer
=	O
session_find	function
(	O
sid	pointer
)	O
;	O
if	O
(	O
!	O
s	pointer
)	O
return	O
ESRCH	O
;	O
count	int
=	O
0	int
;	O
for	O
(	O
pg	pointer
=	O
s	pointer
->	O
s_pgrps	O
;	O
pg	pointer
;	O
pg	pointer
=	O
pg	pointer
->	O
pg_next	O
)	O
if	O
(	O
++	O
count	int
<=	O
npgids	int
)	O
*	O
pp	pointer
++	O
=	O
pg	pointer
->	O
pg_pgid	O
;	O
if	O
(	O
count	int
>	O
npgids	int
)	O
{	O
*	O
pgids	pointer
=	O
mmap	function
(	O
0	int
,	O
count	int
*	O
sizeof	O
(	O
pid_t	int
)	O
,	O
PROT_READ	O
|	O
PROT_WRITE	O
,	O
MAP_ANON	O
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
*	O
pgids	pointer
==	O
MAP_FAILED	O
)	O
return	O
errno	O
;	O
pp	pointer
=	O
*	O
pgids	pointer
;	O
for	O
(	O
pg	pointer
=	O
s	pointer
->	O
s_pgrps	O
;	O
pg	pointer
;	O
pg	pointer
=	O
pg	pointer
->	O
pg_next	O
)	O
*	O
pp	pointer
++	O
=	O
pg	pointer
->	O
pg_pgid	O
;	O
}	O
*	O
npgidsp	pointer
=	O
count	int
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_getpgrppids	function
(	O
struct	O
proc	O
*	O
callerp	pointer
,	O
pid_t	int
pgid	int
,	O
pid_t	int
*	O
*	O
pids	pointer
,	O
size_t	long
*	O
npidsp	pointer
)	O
{	O
struct	O
proc	O
*	O
p	pointer
;	O
struct	O
pgrp	O
*	O
pg	pointer
;	O
pid_t	int
*	O
pp	pointer
=	O
*	O
pids	pointer
;	O
unsigned	O
int	O
npids	int
=	O
*	O
npidsp	pointer
,	O
count	int
;	O
if	O
(	O
pgid	int
==	O
0	int
)	O
pg	pointer
=	O
callerp	pointer
->	O
p_pgrp	O
;	O
else	O
{	O
pg	pointer
=	O
pgrp_find	function
(	O
pgid	int
)	O
;	O
if	O
(	O
!	O
pg	pointer
)	O
return	O
ESRCH	O
;	O
}	O
count	int
=	O
0	int
;	O
for	O
(	O
p	pointer
=	O
pg	pointer
->	O
pg_plist	O
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
p_gnext	O
)	O
if	O
(	O
!	O
p	pointer
->	O
p_important	O
&&	O
++	O
count	int
<=	O
npids	int
)	O
*	O
pp	pointer
++	O
=	O
p	pointer
->	O
p_pid	O
;	O
if	O
(	O
count	int
>	O
npids	int
)	O
{	O
*	O
pids	pointer
=	O
mmap	function
(	O
0	int
,	O
count	int
*	O
sizeof	O
(	O
pid_t	int
)	O
,	O
PROT_READ	O
|	O
PROT_WRITE	O
,	O
MAP_ANON	O
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
*	O
pids	pointer
==	O
MAP_FAILED	O
)	O
return	O
errno	O
;	O
pp	pointer
=	O
*	O
pids	pointer
;	O
for	O
(	O
p	pointer
=	O
pg	pointer
->	O
pg_plist	O
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
p_gnext	O
)	O
if	O
(	O
!	O
p	pointer
->	O
p_important	O
)	O
*	O
pp	pointer
++	O
=	O
p	pointer
->	O
p_pid	O
;	O
}	O
*	O
npidsp	pointer
=	O
count	int
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_getsidport	function
(	O
struct	O
proc	O
*	O
p	pointer
,	O
mach_port_t	O
*	O
sessport	pointer
,	O
mach_msg_type_name_t	O
*	O
sessport_type	pointer
)	O
{	O
error_t	O
err	O
=	O
0	int
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
EOPNOTSUPP	O
;	O
if	O
(	O
!	O
p	pointer
->	O
p_pgrp	O
)	O
*	O
sessport	pointer
=	O
MACH_PORT_NULL	O
;	O
else	O
{	O
if	O
(	O
p	pointer
->	O
p_pgrp	O
->	O
pg_session	O
->	O
s_sessionid	O
==	O
MACH_PORT_NULL	O
)	O
err	O
=	O
mach_port_allocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
MACH_PORT_RIGHT_RECEIVE	O
,	O
&	O
p	pointer
->	O
p_pgrp	O
->	O
pg_session	O
->	O
s_sessionid	O
)	O
;	O
*	O
sessport	pointer
=	O
p	pointer
->	O
p_pgrp	O
->	O
pg_session	O
->	O
s_sessionid	O
;	O
}	O
*	O
sessport_type	pointer
=	O
MACH_MSG_TYPE_MAKE_SEND	O
;	O
return	O
err	O
;	O
}	O
kern_return_t	O
S_proc_setpgrp	function
(	O
struct	O
proc	O
*	O
callerp	pointer
,	O
pid_t	int
pid	int
,	O
pid_t	int
pgid	int
)	O
{	O
struct	O
proc	O
*	O
p	pointer
;	O
struct	O
pgrp	O
*	O
pg	pointer
;	O
if	O
(	O
!	O
callerp	pointer
)	O
return	O
EOPNOTSUPP	O
;	O
p	pointer
=	O
pid	int
?	O
pid_find	function
(	O
pid	int
)	O
:	O
callerp	pointer
;	O
if	O
(	O
!	O
p	pointer
||	O
(	O
p	pointer
!=	O
callerp	pointer
&&	O
p	pointer
->	O
p_parent	O
!=	O
callerp	pointer
)	O
)	O
return	O
ESRCH	O
;	O
if	O
(	O
p	pointer
->	O
p_parent	O
==	O
callerp	pointer
&&	O
p	pointer
->	O
p_exec	O
)	O
return	O
EACCES	O
;	O
if	O
(	O
!	O
pgid	int
)	O
pgid	int
=	O
p	pointer
->	O
p_pid	O
;	O
pg	pointer
=	O
pgrp_find	function
(	O
pgid	int
)	O
;	O
if	O
(	O
p	pointer
->	O
p_pgrp	O
->	O
pg_session	O
->	O
s_sid	O
==	O
p	pointer
->	O
p_pid	O
||	O
p	pointer
->	O
p_pgrp	O
->	O
pg_session	O
!=	O
callerp	pointer
->	O
p_pgrp	O
->	O
pg_session	O
||	O
(	O
(	O
pgid	int
!=	O
p	pointer
->	O
p_pid	O
&&	O
(	O
!	O
pg	pointer
||	O
pg	pointer
->	O
pg_session	O
!=	O
callerp	pointer
->	O
p_pgrp	O
->	O
pg_session	O
)	O
)	O
)	O
)	O
return	O
EPERM	O
;	O
if	O
(	O
p	pointer
->	O
p_pgrp	O
!=	O
pg	pointer
)	O
{	O
struct	O
pgrp	O
*	O
new	pointer
=	O
pg	pointer
?	O
pg	pointer
:	O
new_pgrp	function
(	O
pgid	int
,	O
p	pointer
->	O
p_pgrp	O
->	O
pg_session	O
)	O
;	O
leave_pgrp	function
(	O
p	pointer
)	O
;	O
p	pointer
->	O
p_pgrp	O
=	O
new	pointer
;	O
join_pgrp	function
(	O
p	pointer
)	O
;	O
}	O
else	O
nowait_msg_proc_newids	function
(	O
p	pointer
->	O
p_msgport	O
,	O
p	pointer
->	O
p_task	O
,	O
p	pointer
->	O
p_parent	O
->	O
p_pid	O
,	O
pg	pointer
->	O
pg_pgid	O
,	O
!	O
pg	pointer
->	O
pg_orphcnt	O
)	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_getpgrp	function
(	O
struct	O
proc	O
*	O
callerp	pointer
,	O
pid_t	int
pid	int
,	O
pid_t	int
*	O
pgid	int
)	O
{	O
struct	O
proc	O
*	O
p	pointer
=	O
pid_find	function
(	O
pid	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
ESRCH	O
;	O
if	O
(	O
p	pointer
->	O
p_pgrp	O
)	O
*	O
pgid	int
=	O
p	pointer
->	O
p_pgrp	O
->	O
pg_pgid	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_mark_exec	function
(	O
struct	O
proc	O
*	O
p	pointer
)	O
{	O
if	O
(	O
!	O
p	pointer
)	O
return	O
EOPNOTSUPP	O
;	O
p	pointer
->	O
p_exec	O
=	O
1	int
;	O
return	O
0	int
;	O
}	O
void	O
leave_pgrp	function
(	O
struct	O
proc	O
*	O
p	pointer
)	O
{	O
struct	O
pgrp	O
*	O
pg	pointer
=	O
p	pointer
->	O
p_pgrp	O
;	O
*	O
p	pointer
->	O
p_gprevp	O
=	O
p	pointer
->	O
p_gnext	O
;	O
if	O
(	O
p	pointer
->	O
p_gnext	O
)	O
p	pointer
->	O
p_gnext	O
->	O
p_gprevp	O
=	O
p	pointer
->	O
p_gprevp	O
;	O
if	O
(	O
!	O
pg	pointer
->	O
pg_plist	O
)	O
free_pgrp	function
(	O
pg	pointer
)	O
;	O
else	O
if	O
(	O
p	pointer
->	O
p_parent	O
->	O
p_pgrp	O
!=	O
pg	pointer
&&	O
p	pointer
->	O
p_parent	O
->	O
p_pgrp	O
->	O
pg_session	O
==	O
pg	pointer
->	O
pg_session	O
&&	O
!	O
--	O
pg	pointer
->	O
pg_orphcnt	O
)	O
{	O
struct	O
proc	O
*	O
ip	pointer
;	O
int	O
dosignal	int
=	O
0	int
;	O
for	O
(	O
ip	pointer
=	O
pg	pointer
->	O
pg_plist	O
;	O
ip	pointer
;	O
ip	pointer
=	O
ip	pointer
->	O
p_gnext	O
)	O
{	O
if	O
(	O
ip	pointer
->	O
p_stopped	O
)	O
dosignal	int
=	O
1	int
;	O
if	O
(	O
ip	pointer
->	O
p_msgport	O
!=	O
MACH_PORT_NULL	O
)	O
nowait_msg_proc_newids	function
(	O
ip	pointer
->	O
p_msgport	O
,	O
ip	pointer
->	O
p_task	O
,	O
ip	pointer
->	O
p_parent	O
->	O
p_pid	O
,	O
ip	pointer
->	O
p_pid	O
,	O
1	int
)	O
;	O
}	O
if	O
(	O
dosignal	int
)	O
for	O
(	O
ip	pointer
=	O
pg	pointer
->	O
pg_plist	O
;	O
ip	pointer
;	O
ip	pointer
=	O
ip	pointer
->	O
p_gnext	O
)	O
{	O
send_signal	function
(	O
ip	pointer
->	O
p_msgport	O
,	O
SIGHUP	O
,	O
ip	pointer
->	O
p_task	O
)	O
;	O
send_signal	function
(	O
ip	pointer
->	O
p_msgport	O
,	O
SIGCONT	O
,	O
ip	pointer
->	O
p_task	O
)	O
;	O
}	O
}	O
}	O
void	O
join_pgrp	function
(	O
struct	O
proc	O
*	O
p	pointer
)	O
{	O
struct	O
pgrp	O
*	O
pg	pointer
=	O
p	pointer
->	O
p_pgrp	O
;	O
struct	O
proc	O
*	O
tp	pointer
;	O
int	O
origorphcnt	int
;	O
p	pointer
->	O
p_gnext	O
=	O
pg	pointer
->	O
pg_plist	O
;	O
p	pointer
->	O
p_gprevp	O
=	O
&	O
pg	pointer
->	O
pg_plist	O
;	O
if	O
(	O
pg	pointer
->	O
pg_plist	O
)	O
pg	pointer
->	O
pg_plist	O
->	O
p_gprevp	O
=	O
&	O
p	pointer
->	O
p_gnext	O
;	O
pg	pointer
->	O
pg_plist	O
=	O
p	pointer
;	O
origorphcnt	int
=	O
!	O
!	O
pg	pointer
->	O
pg_orphcnt	O
;	O
if	O
(	O
p	pointer
->	O
p_parent	O
->	O
p_pgrp	O
!=	O
pg	pointer
&&	O
p	pointer
->	O
p_parent	O
->	O
p_pgrp	O
->	O
pg_session	O
==	O
pg	pointer
->	O
pg_session	O
)	O
pg	pointer
->	O
pg_orphcnt	O
++	O
;	O
if	O
(	O
origorphcnt	int
!=	O
!	O
!	O
pg	pointer
->	O
pg_orphcnt	O
)	O
{	O
for	O
(	O
tp	pointer
=	O
pg	pointer
->	O
pg_plist	O
;	O
tp	pointer
;	O
tp	pointer
=	O
tp	pointer
->	O
p_gnext	O
)	O
if	O
(	O
tp	pointer
->	O
p_msgport	O
!=	O
MACH_PORT_NULL	O
)	O
nowait_msg_proc_newids	function
(	O
tp	pointer
->	O
p_msgport	O
,	O
tp	pointer
->	O
p_task	O
,	O
tp	pointer
->	O
p_parent	O
->	O
p_pid	O
,	O
pg	pointer
->	O
pg_pgid	O
,	O
!	O
pg	pointer
->	O
pg_orphcnt	O
)	O
;	O
}	O
else	O
if	O
(	O
p	pointer
->	O
p_msgport	O
!=	O
MACH_PORT_NULL	O
)	O
nowait_msg_proc_newids	function
(	O
p	pointer
->	O
p_msgport	O
,	O
p	pointer
->	O
p_task	O
,	O
p	pointer
->	O
p_parent	O
->	O
p_pid	O
,	O
pg	pointer
->	O
pg_pgid	O
,	O
!	O
pg	pointer
->	O
pg_orphcnt	O
)	O
;	O
}	O
