void	O
_pl_h_set_pen_color	function
(	O
R___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
int	O
hpgl_object_type	int
)	O
{	O
bool	enum
found	enum
;	O
int	O
longred	int
,	O
longgreen	int
,	O
longblue	int
;	O
int	O
red	int
,	O
green	int
,	O
blue	int
;	O
int	O
i	int
;	O
plColor	struct
color	struct
;	O
color	struct
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fgcolor	struct
;	O
longred	int
=	O
color	struct
.	O
red	int
;	O
longgreen	int
=	O
color	struct
.	O
green	int
;	O
longblue	int
=	O
color	struct
.	O
blue	int
;	O
red	int
=	O
(	O
longred	int
>>	O
8	int
)	O
&	O
ONEBYTE	O
;	O
green	int
=	O
(	O
longgreen	int
>>	O
8	int
)	O
&	O
ONEBYTE	O
;	O
blue	int
=	O
(	O
longblue	int
>>	O
8	int
)	O
&	O
ONEBYTE	O
;	O
found	enum
=	O
false	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
HPGL2_MAX_NUM_PENS	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
_plotter	pointer
->	O
hpgl_pen_defined	array
[	O
i	int
]	O
!=	O
0	int
&&	O
_plotter	pointer
->	O
hpgl_pen_color	array
[	O
i	int
]	O
.	O
red	int
==	O
red	int
&&	O
_plotter	pointer
->	O
hpgl_pen_color	array
[	O
i	int
]	O
.	O
green	int
==	O
green	int
&&	O
_plotter	pointer
->	O
hpgl_pen_color	array
[	O
i	int
]	O
.	O
blue	int
==	O
blue	int
)	O
{	O
found	enum
=	O
true	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
found	enum
)	O
{	O
if	O
(	O
i	int
!=	O
0	int
||	O
(	O
i	int
==	O
0	int
&&	O
USE_PEN_ZERO	O
)	O
)	O
{	O
_pl_h_set_hpgl_pen	function
(	O
R___	O
(	O
_plotter	pointer
)	O
i	int
)	O
;	O
switch	O
(	O
hpgl_object_type	int
)	O
{	O
case	O
HPGL_OBJECT_PATH	int
:	O
if	O
(	O
_plotter	pointer
->	O
hpgl_version	int
==	O
2	int
&&	O
_plotter	pointer
->	O
hpgl_have_screened_vectors	enum
==	O
true	int
)	O
_pl_h_set_hpgl_pen_type	function
(	O
R___	O
(	O
_plotter	pointer
)	O
HPGL_PEN_SOLID	int
,	O
0.0	int
,	O
0.0	int
)	O
;	O
break	O
;	O
case	O
HPGL_OBJECT_LABEL	int
:	O
if	O
(	O
_plotter	pointer
->	O
hpgl_version	int
==	O
2	int
&&	O
_plotter	pointer
->	O
hpgl_have_char_fill	enum
==	O
true	int
)	O
if	O
(	O
_plotter	pointer
->	O
hpgl_char_rendering_type	int
!=	O
HPGL_CHAR_FILL_SOLID_AND_MAYBE_EDGE	int
)	O
{	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"CF;"	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_plotter	pointer
->	O
hpgl_char_rendering_type	int
=	O
HPGL_CHAR_FILL_SOLID_AND_MAYBE_EDGE	int
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
_plotter	pointer
->	O
hpgl_bad_pen	enum
=	O
false	int
;	O
}	O
else	O
_plotter	pointer
->	O
hpgl_bad_pen	enum
=	O
true	int
;	O
}	O
else	O
if	O
(	O
_plotter	pointer
->	O
hpgl_version	int
==	O
2	int
&&	O
_plotter	pointer
->	O
hpgl_can_assign_colors	enum
)	O
{	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"PC%d,%d,%d,%d;"	pointer
,	O
_plotter	pointer
->	O
hpgl_free_pen	int
,	O
red	int
,	O
green	int
,	O
blue	int
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_plotter	pointer
->	O
hpgl_pen_color	array
[	O
_plotter	pointer
->	O
hpgl_free_pen	int
]	O
.	O
red	int
=	O
red	int
;	O
_plotter	pointer
->	O
hpgl_pen_color	array
[	O
_plotter	pointer
->	O
hpgl_free_pen	int
]	O
.	O
green	int
=	O
green	int
;	O
_plotter	pointer
->	O
hpgl_pen_color	array
[	O
_plotter	pointer
->	O
hpgl_free_pen	int
]	O
.	O
blue	int
=	O
blue	int
;	O
_plotter	pointer
->	O
hpgl_pen_defined	array
[	O
_plotter	pointer
->	O
hpgl_free_pen	int
]	O
=	O
1	int
;	O
_pl_h_set_hpgl_pen	function
(	O
R___	O
(	O
_plotter	pointer
)	O
_plotter	pointer
->	O
hpgl_free_pen	int
)	O
;	O
do	O
_plotter	pointer
->	O
hpgl_free_pen	int
=	O
(	O
_plotter	pointer
->	O
hpgl_free_pen	int
+	O
1	int
)	O
%	O
HPGL2_MAX_NUM_PENS	int
;	O
while	O
(	O
_plotter	pointer
->	O
hpgl_pen_defined	array
[	O
_plotter	pointer
->	O
hpgl_free_pen	int
]	O
==	O
2	int
)	O
;	O
switch	O
(	O
hpgl_object_type	int
)	O
{	O
case	O
HPGL_OBJECT_PATH	int
:	O
if	O
(	O
_plotter	pointer
->	O
hpgl_version	int
==	O
2	int
&&	O
_plotter	pointer
->	O
hpgl_have_screened_vectors	enum
==	O
true	int
)	O
_pl_h_set_hpgl_pen_type	function
(	O
R___	O
(	O
_plotter	pointer
)	O
HPGL_PEN_SOLID	int
,	O
0.0	int
,	O
0.0	int
)	O
;	O
break	O
;	O
case	O
HPGL_OBJECT_LABEL	int
:	O
if	O
(	O
_plotter	pointer
->	O
hpgl_version	int
==	O
2	int
&&	O
_plotter	pointer
->	O
hpgl_have_char_fill	enum
==	O
true	int
)	O
if	O
(	O
_plotter	pointer
->	O
hpgl_char_rendering_type	int
!=	O
HPGL_CHAR_FILL_SOLID_AND_MAYBE_EDGE	int
)	O
{	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"CF;"	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_plotter	pointer
->	O
hpgl_char_rendering_type	int
=	O
HPGL_CHAR_FILL_SOLID_AND_MAYBE_EDGE	int
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
_plotter	pointer
->	O
hpgl_bad_pen	enum
=	O
false	int
;	O
}	O
else	O
if	O
(	O
_plotter	pointer
->	O
hpgl_version	int
==	O
2	int
&&	O
_plotter	pointer
->	O
hpgl_have_screened_vectors	enum
==	O
true	int
&&	O
hpgl_object_type	int
==	O
HPGL_OBJECT_PATH	int
)	O
{	O
double	O
shading	pointer
;	O
_pl_h_hpgl_shaded_pseudocolor	function
(	O
R___	O
(	O
_plotter	pointer
)	O
red	int
,	O
green	int
,	O
blue	int
,	O
&	O
i	int
,	O
&	O
shading	pointer
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
||	O
(	O
i	int
==	O
0	int
&&	O
USE_PEN_ZERO	O
)	O
)	O
{	O
_pl_h_set_hpgl_pen	function
(	O
R___	O
(	O
_plotter	pointer
)	O
i	int
)	O
;	O
_pl_h_set_hpgl_pen_type	function
(	O
R___	O
(	O
_plotter	pointer
)	O
HPGL_PEN_SHADED	int
,	O
100.0	int
*	O
shading	pointer
,	O
0.0	int
)	O
;	O
_plotter	pointer
->	O
hpgl_bad_pen	enum
=	O
false	int
;	O
}	O
else	O
_plotter	pointer
->	O
hpgl_bad_pen	enum
=	O
true	int
;	O
}	O
else	O
if	O
(	O
_plotter	pointer
->	O
hpgl_version	int
==	O
2	int
&&	O
_plotter	pointer
->	O
hpgl_have_char_fill	enum
==	O
true	int
&&	O
hpgl_object_type	int
==	O
HPGL_OBJECT_LABEL	int
)	O
{	O
double	O
shading	pointer
;	O
_pl_h_hpgl_shaded_pseudocolor	function
(	O
R___	O
(	O
_plotter	pointer
)	O
red	int
,	O
green	int
,	O
blue	int
,	O
&	O
i	int
,	O
&	O
shading	pointer
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
||	O
(	O
i	int
==	O
0	int
&&	O
USE_PEN_ZERO	O
)	O
)	O
{	O
_pl_h_set_hpgl_pen	function
(	O
R___	O
(	O
_plotter	pointer
)	O
i	int
)	O
;	O
if	O
(	O
_plotter	pointer
->	O
hpgl_char_rendering_type	int
!=	O
HPGL_CHAR_FILL	int
)	O
{	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"CF%d;"	pointer
,	O
HPGL_CHAR_FILL	int
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_plotter	pointer
->	O
hpgl_char_rendering_type	int
=	O
HPGL_CHAR_FILL	int
;	O
}	O
_pl_h_set_hpgl_fill_type	function
(	O
R___	O
(	O
_plotter	pointer
)	O
HPGL_FILL_SHADED	int
,	O
100.0	int
*	O
shading	pointer
,	O
0.0	int
)	O
;	O
_plotter	pointer
->	O
hpgl_bad_pen	enum
=	O
false	int
;	O
}	O
else	O
_plotter	pointer
->	O
hpgl_bad_pen	enum
=	O
true	int
;	O
}	O
else	O
{	O
i	int
=	O
_pl_h_hpgl_pseudocolor	function
(	O
R___	O
(	O
_plotter	pointer
)	O
red	int
,	O
green	int
,	O
blue	int
,	O
true	int
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
||	O
(	O
i	int
==	O
0	int
&&	O
USE_PEN_ZERO	O
)	O
)	O
{	O
_pl_h_set_hpgl_pen	function
(	O
R___	O
(	O
_plotter	pointer
)	O
i	int
)	O
;	O
switch	O
(	O
hpgl_object_type	int
)	O
{	O
case	O
HPGL_OBJECT_PATH	int
:	O
if	O
(	O
_plotter	pointer
->	O
hpgl_version	int
==	O
2	int
&&	O
_plotter	pointer
->	O
hpgl_have_screened_vectors	enum
==	O
true	int
)	O
_pl_h_set_hpgl_pen_type	function
(	O
R___	O
(	O
_plotter	pointer
)	O
HPGL_PEN_SOLID	int
,	O
0.0	int
,	O
0.0	int
)	O
;	O
break	O
;	O
case	O
HPGL_OBJECT_LABEL	int
:	O
if	O
(	O
_plotter	pointer
->	O
hpgl_version	int
==	O
2	int
&&	O
_plotter	pointer
->	O
hpgl_have_char_fill	enum
==	O
true	int
)	O
if	O
(	O
_plotter	pointer
->	O
hpgl_char_rendering_type	int
!=	O
HPGL_CHAR_FILL_SOLID_AND_MAYBE_EDGE	int
)	O
{	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"CF;"	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_plotter	pointer
->	O
hpgl_char_rendering_type	int
=	O
HPGL_CHAR_FILL_SOLID_AND_MAYBE_EDGE	int
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
_plotter	pointer
->	O
hpgl_bad_pen	enum
=	O
false	int
;	O
}	O
else	O
_plotter	pointer
->	O
hpgl_bad_pen	enum
=	O
true	int
;	O
}	O
}	O
void	O
_pl_h_set_fill_color	function
(	O
R___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
bool	enum
force_pen_color	enum
)	O
{	O
bool	enum
found	enum
;	O
int	O
longred	int
,	O
longgreen	int
,	O
longblue	int
;	O
int	O
red	int
,	O
green	int
,	O
blue	int
;	O
int	O
i	int
;	O
if	O
(	O
force_pen_color	enum
==	O
false	int
&&	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fill_type	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
force_pen_color	enum
)	O
{	O
longred	int
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fgcolor	struct
.	O
red	int
;	O
longgreen	int
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fgcolor	struct
.	O
green	int
;	O
longblue	int
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fgcolor	struct
.	O
blue	int
;	O
}	O
else	O
{	O
longred	int
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fillcolor	struct
.	O
red	int
;	O
longgreen	int
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fillcolor	struct
.	O
green	int
;	O
longblue	int
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fillcolor	struct
.	O
blue	int
;	O
}	O
red	int
=	O
(	O
longred	int
>>	O
8	int
)	O
&	O
ONEBYTE	O
;	O
green	int
=	O
(	O
longgreen	int
>>	O
8	int
)	O
&	O
ONEBYTE	O
;	O
blue	int
=	O
(	O
longblue	int
>>	O
8	int
)	O
&	O
ONEBYTE	O
;	O
found	enum
=	O
false	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
HPGL2_MAX_NUM_PENS	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
_plotter	pointer
->	O
hpgl_pen_defined	array
[	O
i	int
]	O
!=	O
0	int
&&	O
_plotter	pointer
->	O
hpgl_pen_color	array
[	O
i	int
]	O
.	O
red	int
==	O
red	int
&&	O
_plotter	pointer
->	O
hpgl_pen_color	array
[	O
i	int
]	O
.	O
green	int
==	O
green	int
&&	O
_plotter	pointer
->	O
hpgl_pen_color	array
[	O
i	int
]	O
.	O
blue	int
==	O
blue	int
)	O
{	O
found	enum
=	O
true	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
found	enum
)	O
{	O
if	O
(	O
i	int
!=	O
0	int
||	O
(	O
i	int
==	O
0	int
&&	O
USE_PEN_ZERO	O
)	O
)	O
{	O
_pl_h_set_hpgl_pen	function
(	O
R___	O
(	O
_plotter	pointer
)	O
i	int
)	O
;	O
_pl_h_set_hpgl_fill_type	function
(	O
R___	O
(	O
_plotter	pointer
)	O
HPGL_FILL_SOLID_UNI	int
,	O
0.0	int
,	O
0.0	int
)	O
;	O
_plotter	pointer
->	O
hpgl_bad_pen	enum
=	O
false	int
;	O
}	O
else	O
_plotter	pointer
->	O
hpgl_bad_pen	enum
=	O
true	int
;	O
}	O
else	O
if	O
(	O
_plotter	pointer
->	O
hpgl_version	int
==	O
2	int
&&	O
_plotter	pointer
->	O
hpgl_can_assign_colors	enum
)	O
{	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"PC%d,%d,%d,%d;"	pointer
,	O
_plotter	pointer
->	O
hpgl_free_pen	int
,	O
red	int
,	O
green	int
,	O
blue	int
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_plotter	pointer
->	O
hpgl_pen_color	array
[	O
_plotter	pointer
->	O
hpgl_free_pen	int
]	O
.	O
red	int
=	O
red	int
;	O
_plotter	pointer
->	O
hpgl_pen_color	array
[	O
_plotter	pointer
->	O
hpgl_free_pen	int
]	O
.	O
green	int
=	O
green	int
;	O
_plotter	pointer
->	O
hpgl_pen_color	array
[	O
_plotter	pointer
->	O
hpgl_free_pen	int
]	O
.	O
blue	int
=	O
blue	int
;	O
_plotter	pointer
->	O
hpgl_pen_defined	array
[	O
_plotter	pointer
->	O
hpgl_free_pen	int
]	O
=	O
1	int
;	O
_pl_h_set_hpgl_pen	function
(	O
R___	O
(	O
_plotter	pointer
)	O
_plotter	pointer
->	O
hpgl_free_pen	int
)	O
;	O
do	O
_plotter	pointer
->	O
hpgl_free_pen	int
=	O
(	O
_plotter	pointer
->	O
hpgl_free_pen	int
+	O
1	int
)	O
%	O
HPGL2_MAX_NUM_PENS	int
;	O
while	O
(	O
_plotter	pointer
->	O
hpgl_pen_defined	array
[	O
_plotter	pointer
->	O
hpgl_free_pen	int
]	O
==	O
2	int
)	O
;	O
_pl_h_set_hpgl_fill_type	function
(	O
R___	O
(	O
_plotter	pointer
)	O
HPGL_FILL_SOLID_UNI	int
,	O
0.0	int
,	O
0.0	int
)	O
;	O
_plotter	pointer
->	O
hpgl_bad_pen	enum
=	O
false	int
;	O
}	O
else	O
if	O
(	O
_plotter	pointer
->	O
hpgl_version	int
==	O
2	int
&&	O
_plotter	pointer
->	O
hpgl_can_assign_colors	enum
==	O
false	int
)	O
{	O
double	O
shading	pointer
;	O
_pl_h_hpgl_shaded_pseudocolor	function
(	O
R___	O
(	O
_plotter	pointer
)	O
red	int
,	O
green	int
,	O
blue	int
,	O
&	O
i	int
,	O
&	O
shading	pointer
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
||	O
(	O
i	int
==	O
0	int
&&	O
USE_PEN_ZERO	O
)	O
)	O
{	O
_pl_h_set_hpgl_pen	function
(	O
R___	O
(	O
_plotter	pointer
)	O
i	int
)	O
;	O
_pl_h_set_hpgl_fill_type	function
(	O
R___	O
(	O
_plotter	pointer
)	O
HPGL_FILL_SHADED	int
,	O
100.0	int
*	O
shading	pointer
,	O
0.0	int
)	O
;	O
_plotter	pointer
->	O
hpgl_bad_pen	enum
=	O
false	int
;	O
}	O
else	O
_plotter	pointer
->	O
hpgl_bad_pen	enum
=	O
true	int
;	O
}	O
else	O
{	O
double	O
shading	pointer
;	O
_pl_h_hpgl_shaded_pseudocolor	function
(	O
R___	O
(	O
_plotter	pointer
)	O
red	int
,	O
green	int
,	O
blue	int
,	O
&	O
i	int
,	O
&	O
shading	pointer
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
&&	O
shading	pointer
>	O
0.01	int
)	O
{	O
double	O
interline_distance	double
;	O
_pl_h_set_hpgl_pen	function
(	O
R___	O
(	O
_plotter	pointer
)	O
i	int
)	O
;	O
interline_distance	double
=	O
HPGL_NOMINAL_PEN_WIDTH	int
*	O
(	O
1.0	int
+	O
sqrt	function
(	O
1.0	int
-	O
shading	pointer
)	O
)	O
/	O
shading	pointer
;	O
_pl_h_set_hpgl_fill_type	function
(	O
R___	O
(	O
_plotter	pointer
)	O
HPGL_FILL_CROSSHATCHED_LINES	int
,	O
interline_distance	double
,	O
45.0	int
)	O
;	O
_plotter	pointer
->	O
hpgl_bad_pen	enum
=	O
false	int
;	O
}	O
else	O
_plotter	pointer
->	O
hpgl_bad_pen	enum
=	O
true	int
;	O
}	O
}	O
void	O
_pl_h_set_hpgl_pen	function
(	O
R___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
int	O
new_pen	int
)	O
{	O
if	O
(	O
new_pen	int
!=	O
_plotter	pointer
->	O
hpgl_pen	int
)	O
{	O
if	O
(	O
_plotter	pointer
->	O
hpgl_pendown	enum
)	O
{	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"PU;"	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_plotter	pointer
->	O
hpgl_pendown	enum
=	O
false	int
;	O
}	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"SP%d;"	pointer
,	O
new_pen	int
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_plotter	pointer
->	O
hpgl_pen	int
=	O
new_pen	int
;	O
}	O
}	O
void	O
_pl_h_set_hpgl_pen_type	function
(	O
R___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
int	O
new_hpgl_pen_type	int
,	O
double	O
option1	double
,	O
double	O
option2	double
)	O
{	O
if	O
(	O
new_hpgl_pen_type	int
!=	O
_plotter	pointer
->	O
hpgl_pen_type	int
||	O
(	O
new_hpgl_pen_type	int
==	O
HPGL_PEN_SHADED	int
&&	O
_plotter	pointer
->	O
hpgl_pen_option1	double
!=	O
option1	double
)	O
||	O
(	O
new_hpgl_pen_type	int
==	O
HPGL_PEN_PREDEFINED_CROSSHATCH	int
&&	O
_plotter	pointer
->	O
hpgl_pen_option1	double
!=	O
option1	double
)	O
)	O
{	O
switch	O
(	O
new_hpgl_pen_type	int
)	O
{	O
case	O
HPGL_PEN_SOLID	int
:	O
default	O
:	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"SV;"	pointer
)	O
;	O
break	O
;	O
case	O
HPGL_PEN_SHADED	int
:	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"SV%d,%.1f;"	pointer
,	O
new_hpgl_pen_type	int
,	O
option1	double
)	O
;	O
_plotter	pointer
->	O
hpgl_pen_option1	double
=	O
option1	double
;	O
break	O
;	O
case	O
HPGL_PEN_PREDEFINED_CROSSHATCH	int
:	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"SV%d,%d;"	pointer
,	O
new_hpgl_pen_type	int
,	O
IROUND	O
(	O
option1	double
)	O
)	O
;	O
_plotter	pointer
->	O
hpgl_pen_option1	double
=	O
option1	double
;	O
break	O
;	O
}	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_plotter	pointer
->	O
hpgl_pen_type	int
=	O
new_hpgl_pen_type	int
;	O
}	O
}	O
void	O
_pl_h_set_hpgl_fill_type	function
(	O
R___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
int	O
new_hpgl_fill_type	int
,	O
double	O
option1	double
,	O
double	O
option2	double
)	O
{	O
if	O
(	O
new_hpgl_fill_type	int
!=	O
_plotter	pointer
->	O
hpgl_fill_type	int
||	O
(	O
new_hpgl_fill_type	int
==	O
HPGL_FILL_SHADED	int
&&	O
_plotter	pointer
->	O
hpgl_fill_option1	double
!=	O
option1	double
)	O
||	O
(	O
(	O
new_hpgl_fill_type	int
==	O
HPGL_FILL_CROSSHATCHED_LINES	int
||	O
new_hpgl_fill_type	int
==	O
HPGL_FILL_PARALLEL_LINES	int
)	O
&&	O
(	O
_plotter	pointer
->	O
hpgl_fill_option1	double
!=	O
option1	double
||	O
_plotter	pointer
->	O
hpgl_fill_option2	double
!=	O
option2	double
)	O
)	O
||	O
(	O
new_hpgl_fill_type	int
==	O
HPGL_FILL_PREDEFINED_CROSSHATCH	int
&&	O
_plotter	pointer
->	O
hpgl_fill_option1	double
!=	O
option1	double
)	O
)	O
{	O
switch	O
(	O
new_hpgl_fill_type	int
)	O
{	O
case	O
HPGL_FILL_SOLID_BI	int
:	O
case	O
HPGL_FILL_SOLID_UNI	int
:	O
default	O
:	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"FT%d;"	pointer
,	O
new_hpgl_fill_type	int
)	O
;	O
break	O
;	O
case	O
HPGL_FILL_SHADED	int
:	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"FT%d,%.1f;"	pointer
,	O
new_hpgl_fill_type	int
,	O
option1	double
)	O
;	O
_plotter	pointer
->	O
hpgl_fill_option1	double
=	O
option1	double
;	O
break	O
;	O
case	O
HPGL_FILL_CROSSHATCHED_LINES	int
:	O
case	O
HPGL_FILL_PARALLEL_LINES	int
:	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"LT;SC;FT%d,%d,%d;SC%d,%d,%d,%d;"	pointer
,	O
new_hpgl_fill_type	int
,	O
IROUND	O
(	O
option1	double
)	O
,	O
IROUND	O
(	O
option2	double
)	O
,	O
IROUND	O
(	O
_plotter	pointer
->	O
data	pointer
->	O
xmin	double
)	O
,	O
IROUND	O
(	O
_plotter	pointer
->	O
data	pointer
->	O
xmax	double
)	O
,	O
IROUND	O
(	O
_plotter	pointer
->	O
data	pointer
->	O
ymin	double
)	O
,	O
IROUND	O
(	O
_plotter	pointer
->	O
data	pointer
->	O
ymax	double
)	O
)	O
;	O
_plotter	pointer
->	O
hpgl_line_type	int
=	O
HPGL_L_SOLID	O
;	O
_plotter	pointer
->	O
hpgl_fill_option1	double
=	O
option1	double
;	O
_plotter	pointer
->	O
hpgl_fill_option2	double
=	O
option2	double
;	O
break	O
;	O
case	O
HPGL_FILL_PREDEFINED_CROSSHATCH	int
:	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"FT%d,%d;"	pointer
,	O
new_hpgl_fill_type	int
,	O
IROUND	O
(	O
option1	double
)	O
)	O
;	O
_plotter	pointer
->	O
hpgl_fill_option1	double
=	O
option1	double
;	O
break	O
;	O
}	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_plotter	pointer
->	O
hpgl_fill_type	int
=	O
new_hpgl_fill_type	int
;	O
}	O
}	O
int	O
_pl_h_hpgl_pseudocolor	function
(	O
R___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
int	O
red	int
,	O
int	O
green	int
,	O
int	O
blue	int
,	O
bool	enum
restrict_white	enum
)	O
{	O
unsigned	O
long	O
int	O
difference	long
=	O
INT_MAX	O
;	O
int	O
i	int
;	O
int	O
best	int
=	O
0	int
;	O
if	O
(	O
red	int
==	O
0xff	int
&&	O
green	int
==	O
0xff	int
&&	O
blue	int
==	O
0xff	int
)	O
return	O
0	int
;	O
for	O
(	O
i	int
=	O
(	O
restrict_white	enum
?	O
1	int
:	O
0	int
)	O
;	O
i	int
<	O
HPGL2_MAX_NUM_PENS	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
_plotter	pointer
->	O
hpgl_pen_defined	array
[	O
i	int
]	O
!=	O
0	int
)	O
{	O
unsigned	O
long	O
int	O
newdifference	long
;	O
int	O
ored	int
,	O
ogreen	int
,	O
oblue	int
;	O
ored	int
=	O
_plotter	pointer
->	O
hpgl_pen_color	array
[	O
i	int
]	O
.	O
red	int
;	O
ogreen	int
=	O
_plotter	pointer
->	O
hpgl_pen_color	array
[	O
i	int
]	O
.	O
green	int
;	O
oblue	int
=	O
_plotter	pointer
->	O
hpgl_pen_color	array
[	O
i	int
]	O
.	O
blue	int
;	O
newdifference	long
=	O
(	O
(	O
red	int
-	O
ored	int
)	O
*	O
(	O
red	int
-	O
ored	int
)	O
+	O
(	O
green	int
-	O
ogreen	int
)	O
*	O
(	O
green	int
-	O
ogreen	int
)	O
+	O
(	O
blue	int
-	O
oblue	int
)	O
*	O
(	O
blue	int
-	O
oblue	int
)	O
)	O
;	O
if	O
(	O
newdifference	long
<	O
difference	long
)	O
{	O
difference	long
=	O
newdifference	long
;	O
best	int
=	O
i	int
;	O
}	O
}	O
}	O
return	O
best	int
;	O
}	O
void	O
_pl_h_hpgl_shaded_pseudocolor	function
(	O
R___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
int	O
red	int
,	O
int	O
green	int
,	O
int	O
blue	int
,	O
int	O
*	O
pen_ptr	pointer
,	O
double	O
*	O
shading_ptr	pointer
)	O
{	O
int	O
best	int
=	O
0	int
;	O
int	O
i	int
;	O
double	O
best_shading	double
=	O
0.0	int
;	O
double	O
difference	long
=	O
INT_MAX	O
;	O
double	O
red_shifted	double
,	O
green_shifted	double
,	O
blue_shifted	double
;	O
red_shifted	double
=	O
(	O
double	O
)	O
(	O
red	int
-	O
0xff	int
)	O
;	O
green_shifted	double
=	O
(	O
double	O
)	O
(	O
green	int
-	O
0xff	int
)	O
;	O
blue_shifted	double
=	O
(	O
double	O
)	O
(	O
blue	int
-	O
0xff	int
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
HPGL2_MAX_NUM_PENS	int
;	O
i	int
++	O
)	O
{	O
int	O
ored	int
,	O
ogreen	int
,	O
oblue	int
;	O
double	O
ored_shifted	double
,	O
ogreen_shifted	double
,	O
oblue_shifted	double
;	O
double	O
red_proj_shifted	double
,	O
green_proj_shifted	double
,	O
blue_proj_shifted	double
;	O
double	O
reciprocal_normsquared	double
,	O
dotproduct	double
;	O
double	O
newdifference	long
,	O
shading	pointer
;	O
if	O
(	O
_plotter	pointer
->	O
hpgl_pen_defined	array
[	O
i	int
]	O
==	O
0	int
)	O
continue	O
;	O
ored	int
=	O
_plotter	pointer
->	O
hpgl_pen_color	array
[	O
i	int
]	O
.	O
red	int
;	O
ogreen	int
=	O
_plotter	pointer
->	O
hpgl_pen_color	array
[	O
i	int
]	O
.	O
green	int
;	O
oblue	int
=	O
_plotter	pointer
->	O
hpgl_pen_color	array
[	O
i	int
]	O
.	O
blue	int
;	O
if	O
(	O
ored	int
==	O
0xff	int
&&	O
ogreen	int
==	O
0xff	int
&&	O
oblue	int
==	O
0xff	int
)	O
continue	O
;	O
ored_shifted	double
=	O
(	O
double	O
)	O
(	O
ored	int
-	O
0xff	int
)	O
;	O
ogreen_shifted	double
=	O
(	O
double	O
)	O
(	O
ogreen	int
-	O
0xff	int
)	O
;	O
oblue_shifted	double
=	O
(	O
double	O
)	O
(	O
oblue	int
-	O
0xff	int
)	O
;	O
reciprocal_normsquared	double
=	O
1.0	int
/	O
(	O
ored_shifted	double
*	O
ored_shifted	double
+	O
ogreen_shifted	double
*	O
ogreen_shifted	double
+	O
oblue_shifted	double
*	O
oblue_shifted	double
)	O
;	O
dotproduct	double
=	O
(	O
red_shifted	double
*	O
ored_shifted	double
+	O
green_shifted	double
*	O
ogreen_shifted	double
+	O
blue_shifted	double
*	O
oblue_shifted	double
)	O
;	O
shading	pointer
=	O
reciprocal_normsquared	double
*	O
dotproduct	double
;	O
red_proj_shifted	double
=	O
shading	pointer
*	O
ored_shifted	double
;	O
green_proj_shifted	double
=	O
shading	pointer
*	O
ogreen_shifted	double
;	O
blue_proj_shifted	double
=	O
shading	pointer
*	O
oblue_shifted	double
;	O
newdifference	long
=	O
(	O
(	O
(	O
red_proj_shifted	double
-	O
red_shifted	double
)	O
*	O
(	O
red_proj_shifted	double
-	O
red_shifted	double
)	O
)	O
+	O
(	O
(	O
green_proj_shifted	double
-	O
green_shifted	double
)	O
*	O
(	O
green_proj_shifted	double
-	O
green_shifted	double
)	O
)	O
+	O
(	O
(	O
blue_proj_shifted	double
-	O
blue_shifted	double
)	O
*	O
(	O
blue_proj_shifted	double
-	O
blue_shifted	double
)	O
)	O
)	O
;	O
if	O
(	O
newdifference	long
<	O
difference	long
)	O
{	O
difference	long
=	O
newdifference	long
;	O
best	int
=	O
i	int
;	O
best_shading	double
=	O
shading	pointer
;	O
}	O
}	O
if	O
(	O
best_shading	double
<=	O
0.0	int
)	O
best_shading	double
=	O
0.0	int
;	O
*	O
pen_ptr	pointer
=	O
best	int
;	O
*	O
shading_ptr	pointer
=	O
best_shading	double
;	O
}	O
