static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: mp_fget.c,v 1.5 2000/06/30 08:35:12 loic Exp $"	pointer
;	O
int	O
CDB_memp_fget	function
(	O
dbmfp	pointer
,	O
pgnoaddr	pointer
,	O
flags	int
,	O
addrp	pointer
)	O
DB_MPOOLFILE	struct
*	O
dbmfp	pointer
;	O
db_pgno_t	int
*	O
pgnoaddr	pointer
;	O
u_int32_t	int
flags	int
;	O
void	O
*	O
addrp	pointer
;	O
{	O
BH	struct
*	O
bhp	pointer
;	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_MPOOL	struct
*	O
dbmp	pointer
;	O
DB_HASHTAB	struct
*	O
dbht	pointer
;	O
MPOOL	struct
*	O
c_mp	pointer
,	O
*	O
mp	pointer
;	O
MPOOLFILE	struct
*	O
mfp	pointer
;	O
size_t	long
n_bucket	long
,	O
n_cache	long
,	O
mf_offset	int
;	O
u_int32_t	int
st_hsearch	int
;	O
int	O
b_incr	int
,	O
first	int
,	O
ret	int
;	O
dbmp	pointer
=	O
dbmfp	pointer
->	O
dbmp	pointer
;	O
dbenv	pointer
=	O
dbmp	pointer
->	O
dbenv	pointer
;	O
mp	pointer
=	O
dbmp	pointer
->	O
reginfo	pointer
[	O
0	int
]	O
.	O
primary	int
;	O
mfp	pointer
=	O
dbmfp	pointer
->	O
mfp	pointer
;	O
PANIC_CHECK	O
(	O
dbenv	pointer
)	O
;	O
if	O
(	O
flags	int
!=	O
0	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_fchk	function
(	O
dbenv	pointer
,	O
"CDB_memp_fget"	pointer
,	O
flags	int
,	O
OKFLAGS	O
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
switch	O
(	O
flags	int
)	O
{	O
case	O
DB_MPOOL_CREATE	int
:	O
case	O
DB_MPOOL_LAST	int
:	O
case	O
DB_MPOOL_NEW	int
:	O
case	O
DB_MPOOL_NEW_GROUP	int
:	O
case	O
0	int
:	O
break	O
;	O
default	O
:	O
return	O
(	O
CDB___db_ferr	function
(	O
dbenv	pointer
,	O
"CDB_memp_fget"	pointer
,	O
1	int
)	O
)	O
;	O
}	O
}	O
mf_offset	int
=	O
R_OFFSET	O
(	O
dbmp	pointer
->	O
reginfo	pointer
,	O
mfp	pointer
)	O
;	O
bhp	pointer
=	O
NULL	O
;	O
st_hsearch	int
=	O
0	int
;	O
b_incr	int
=	O
ret	int
=	O
0	int
;	O
R_LOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_MPOOL_LAST	int
|	O
DB_MPOOL_NEW	int
|	O
DB_MPOOL_NEW_GROUP	int
)	O
)	O
{	O
if	O
(	O
LF_ISSET	O
(	O
DB_MPOOL_NEW	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_fpinit	function
(	O
dbenv	pointer
,	O
&	O
dbmfp	pointer
->	O
fh	struct
,	O
mfp	pointer
->	O
last_pgno	int
+	O
1	int
,	O
1	int
,	O
mfp	pointer
->	O
stat	pointer
.	O
st_pagesize	long
)	O
)	O
!=	O
0	int
)	O
{	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
++	O
mfp	pointer
->	O
last_pgno	int
;	O
}	O
if	O
(	O
LF_ISSET	O
(	O
DB_MPOOL_NEW_GROUP	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_fpinit	function
(	O
dbenv	pointer
,	O
&	O
dbmfp	pointer
->	O
fh	struct
,	O
mfp	pointer
->	O
last_pgno	int
+	O
1	int
,	O
(	O
int	O
)	O
*	O
pgnoaddr	pointer
,	O
mfp	pointer
->	O
stat	pointer
.	O
st_pagesize	long
)	O
)	O
!=	O
0	int
)	O
{	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
mfp	pointer
->	O
last_pgno	int
+=	O
*	O
pgnoaddr	pointer
;	O
}	O
*	O
pgnoaddr	pointer
=	O
mfp	pointer
->	O
last_pgno	int
;	O
}	O
n_cache	long
=	O
NCACHE	O
(	O
mp	pointer
,	O
*	O
pgnoaddr	pointer
)	O
;	O
c_mp	pointer
=	O
dbmp	pointer
->	O
reginfo	pointer
[	O
n_cache	long
]	O
.	O
primary	int
;	O
n_bucket	long
=	O
NBUCKET	O
(	O
c_mp	pointer
,	O
mf_offset	int
,	O
*	O
pgnoaddr	pointer
)	O
;	O
dbht	pointer
=	O
R_ADDR	O
(	O
&	O
dbmp	pointer
->	O
reginfo	pointer
[	O
n_cache	long
]	O
,	O
c_mp	pointer
->	O
htab	int
)	O
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_MPOOL_NEW	int
|	O
DB_MPOOL_NEW_GROUP	int
)	O
)	O
goto	O
alloc	O
;	O
if	O
(	O
dbmfp	pointer
->	O
addr	pointer
!=	O
NULL	O
&&	O
F_ISSET	O
(	O
mfp	pointer
,	O
MP_CAN_MMAP	int
)	O
)	O
{	O
if	O
(	O
*	O
pgnoaddr	pointer
>	O
mfp	pointer
->	O
orig_last_pgno	int
)	O
{	O
if	O
(	O
!	O
LF_ISSET	O
(	O
DB_MPOOL_CREATE	int
)	O
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"%s: page %lu doesn't exist"	pointer
,	O
CDB___memp_fn	function
(	O
dbmfp	pointer
)	O
,	O
(	O
u_long	long
)	O
*	O
pgnoaddr	pointer
)	O
;	O
ret	int
=	O
EINVAL	int
;	O
goto	O
err	pointer
;	O
}	O
}	O
else	O
{	O
*	O
(	O
void	O
*	O
*	O
)	O
addrp	pointer
=	O
R_ADDR	O
(	O
dbmfp	pointer
,	O
*	O
pgnoaddr	pointer
*	O
mfp	pointer
->	O
stat	pointer
.	O
st_pagesize	long
)	O
;	O
++	O
mfp	pointer
->	O
stat	pointer
.	O
st_map	int
;	O
goto	O
done	O
;	O
}	O
}	O
for	O
(	O
bhp	pointer
=	O
SH_TAILQ_FIRST	O
(	O
&	O
dbht	pointer
[	O
n_bucket	long
]	O
,	O
__bh	struct
)	O
;	O
bhp	pointer
!=	O
NULL	O
;	O
bhp	pointer
=	O
SH_TAILQ_NEXT	O
(	O
bhp	pointer
,	O
hq	struct
,	O
__bh	struct
)	O
)	O
{	O
++	O
st_hsearch	int
;	O
if	O
(	O
bhp	pointer
->	O
pgno	int
!=	O
*	O
pgnoaddr	pointer
||	O
bhp	pointer
->	O
mf_offset	int
!=	O
mf_offset	int
)	O
continue	O
;	O
if	O
(	O
bhp	pointer
->	O
ref	int
==	O
UINT16_T_MAX	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"%s: page %lu: reference count overflow"	pointer
,	O
CDB___memp_fn	function
(	O
dbmfp	pointer
)	O
,	O
(	O
u_long	long
)	O
bhp	pointer
->	O
pgno	int
)	O
;	O
ret	int
=	O
EINVAL	int
;	O
goto	O
err	pointer
;	O
}	O
++	O
bhp	pointer
->	O
ref	int
;	O
b_incr	int
=	O
1	int
;	O
for	O
(	O
first	int
=	O
1	int
;	O
F_ISSET	O
(	O
bhp	pointer
,	O
BH_LOCKED	int
)	O
;	O
first	int
=	O
0	int
)	O
{	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
if	O
(	O
!	O
first	int
)	O
CDB___os_yield	function
(	O
dbenv	pointer
,	O
1	int
)	O
;	O
MUTEX_LOCK	O
(	O
&	O
bhp	pointer
->	O
mutex	union
,	O
dbenv	pointer
->	O
lockfhp	pointer
)	O
;	O
MUTEX_UNLOCK	O
(	O
&	O
bhp	pointer
->	O
mutex	union
)	O
;	O
R_LOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
}	O
if	O
(	O
F_ISSET	O
(	O
bhp	pointer
,	O
BH_TRASH	int
)	O
)	O
goto	O
reread	O
;	O
if	O
(	O
F_ISSET	O
(	O
bhp	pointer
,	O
BH_CALLPGIN	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___memp_pg	function
(	O
dbmfp	pointer
,	O
bhp	pointer
,	O
1	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
F_CLR	O
(	O
bhp	pointer
,	O
BH_CALLPGIN	int
)	O
;	O
}	O
++	O
mfp	pointer
->	O
stat	pointer
.	O
st_cache_hit	int
;	O
*	O
(	O
void	O
*	O
*	O
)	O
addrp	pointer
=	O
bhp	pointer
->	O
buf	pointer
;	O
goto	O
done	O
;	O
}	O
alloc	O
:	O
if	O
(	O
(	O
ret	int
=	O
CDB___memp_alloc	function
(	O
dbmp	pointer
,	O
&	O
dbmp	pointer
->	O
reginfo	pointer
[	O
n_cache	long
]	O
,	O
mfp	pointer
,	O
0	int
,	O
NULL	O
,	O
&	O
bhp	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
++	O
c_mp	pointer
->	O
stat	pointer
.	O
st_page_clean	int
;	O
memset	function
(	O
bhp	pointer
,	O
0	int
,	O
sizeof	O
(	O
BH	struct
)	O
)	O
;	O
bhp	pointer
->	O
ref	int
=	O
1	int
;	O
bhp	pointer
->	O
pgno	int
=	O
*	O
pgnoaddr	pointer
;	O
bhp	pointer
->	O
mf_offset	int
=	O
mf_offset	int
;	O
++	O
mfp	pointer
->	O
ref_cnt	int
;	O
SH_TAILQ_INSERT_HEAD	O
(	O
&	O
dbht	pointer
[	O
n_bucket	long
]	O
,	O
bhp	pointer
,	O
hq	struct
,	O
__bh	struct
)	O
;	O
SH_TAILQ_INSERT_TAIL	O
(	O
&	O
c_mp	pointer
->	O
bhq	struct
,	O
bhp	pointer
,	O
q	struct
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
__db_mutex_init	O
(	O
dbenv	pointer
,	O
&	O
bhp	pointer
->	O
mutex	union
,	O
R_OFFSET	O
(	O
dbmp	pointer
->	O
reginfo	pointer
,	O
&	O
bhp	pointer
->	O
mutex	union
)	O
+	O
DB_FCNTL_OFF_MPOOL	O
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
{	O
CDB___memp_bhfree	function
(	O
dbmp	pointer
,	O
bhp	pointer
,	O
1	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
LF_ISSET	O
(	O
DB_MPOOL_NEW	int
|	O
DB_MPOOL_NEW_GROUP	int
)	O
)	O
{	O
if	O
(	O
mfp	pointer
->	O
clear_len	int
==	O
0	int
)	O
memset	function
(	O
bhp	pointer
->	O
buf	pointer
,	O
0	int
,	O
mfp	pointer
->	O
stat	pointer
.	O
st_pagesize	long
)	O
;	O
else	O
{	O
memset	function
(	O
bhp	pointer
->	O
buf	pointer
,	O
0	int
,	O
mfp	pointer
->	O
clear_len	int
)	O
;	O
}	O
++	O
mfp	pointer
->	O
stat	pointer
.	O
st_page_create	int
;	O
}	O
else	O
{	O
reread	O
:	O
if	O
(	O
(	O
ret	int
=	O
CDB___memp_pgread	function
(	O
dbmfp	pointer
,	O
bhp	pointer
,	O
LF_ISSET	O
(	O
DB_MPOOL_CREATE	int
)	O
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
bhp	pointer
->	O
ref	int
==	O
1	int
)	O
CDB___memp_bhfree	function
(	O
dbmp	pointer
,	O
bhp	pointer
,	O
1	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
++	O
mfp	pointer
->	O
stat	pointer
.	O
st_cache_miss	int
;	O
}	O
if	O
(	O
bhp	pointer
->	O
pgno	int
>	O
mfp	pointer
->	O
last_pgno	int
)	O
mfp	pointer
->	O
last_pgno	int
=	O
bhp	pointer
->	O
pgno	int
;	O
*	O
(	O
void	O
*	O
*	O
)	O
addrp	pointer
=	O
bhp	pointer
->	O
buf	pointer
;	O
done	O
:	O
if	O
(	O
st_hsearch	int
)	O
{	O
++	O
c_mp	pointer
->	O
stat	pointer
.	O
st_hash_searches	int
;	O
if	O
(	O
st_hsearch	int
>	O
c_mp	pointer
->	O
stat	pointer
.	O
st_hash_longest	int
)	O
c_mp	pointer
->	O
stat	pointer
.	O
st_hash_longest	int
=	O
st_hsearch	int
;	O
c_mp	pointer
->	O
stat	pointer
.	O
st_hash_examined	int
+=	O
st_hsearch	int
;	O
}	O
++	O
dbmfp	pointer
->	O
pinref	int
;	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
err	pointer
:	O
if	O
(	O
b_incr	int
)	O
--	O
bhp	pointer
->	O
ref	int
;	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
*	O
(	O
void	O
*	O
*	O
)	O
addrp	pointer
=	O
NULL	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
