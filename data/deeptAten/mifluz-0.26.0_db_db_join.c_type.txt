static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: db_join.c,v 1.5 2014/04/17 20:27:27 sebdiaz Exp $"	pointer
;	O
static	O
int	O
__db_join_close	function
__P	O
(	O
(	O
DBC	struct
*	O
)	O
)	O
;	O
static	O
int	O
__db_join_cmp	function
__P	O
(	O
(	O
const	O
void	O
*	O
,	O
const	O
void	O
*	O
)	O
)	O
;	O
static	O
int	O
__db_join_del	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
int	O
__db_join_get	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
DBT	struct
*	O
,	O
DBT	struct
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
int	O
__db_join_getnext	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
DBT	struct
*	O
,	O
DBT	struct
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
int	O
__db_join_put	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
DBT	struct
*	O
,	O
DBT	struct
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
int	O
CDB___db_join	function
(	O
primary	int
,	O
curslist	pointer
,	O
dbcp	pointer
,	O
flags	int
)	O
DB	struct
*	O
primary	int
;	O
DBC	struct
*	O
*	O
curslist	pointer
,	O
*	O
*	O
dbcp	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DBC	struct
*	O
dbc	pointer
;	O
JOIN_CURSOR	struct
*	O
jc	pointer
;	O
int	O
ret	int
;	O
u_int32_t	int
i	int
,	O
ncurs	int
,	O
nslots	int
;	O
COMPQUIET	O
(	O
nslots	int
,	O
0	int
)	O
;	O
PANIC_CHECK	O
(	O
primary	int
->	O
dbenv	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_joinchk	function
(	O
primary	int
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
curslist	pointer
==	O
NULL	O
||	O
curslist	pointer
[	O
0	int
]	O
==	O
NULL	O
)	O
return	O
(	O
EINVAL	int
)	O
;	O
dbc	pointer
=	O
NULL	O
;	O
jc	pointer
=	O
NULL	O
;	O
dbenv	pointer
=	O
primary	int
->	O
dbenv	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_calloc	function
(	O
dbenv	pointer
,	O
1	int
,	O
sizeof	O
(	O
DBC	struct
)	O
,	O
&	O
dbc	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_calloc	function
(	O
dbenv	pointer
,	O
1	int
,	O
sizeof	O
(	O
JOIN_CURSOR	struct
)	O
,	O
&	O
jc	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbenv	pointer
,	O
256	int
,	O
NULL	O
,	O
&	O
jc	pointer
->	O
j_key	struct
.	O
data	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
jc	pointer
->	O
j_key	struct
.	O
ulen	int
=	O
256	int
;	O
F_SET	O
(	O
&	O
jc	pointer
->	O
j_key	struct
,	O
DB_DBT_USERMEM	int
)	O
;	O
for	O
(	O
jc	pointer
->	O
j_curslist	pointer
=	O
curslist	pointer
;	O
*	O
jc	pointer
->	O
j_curslist	pointer
!=	O
NULL	O
;	O
jc	pointer
->	O
j_curslist	pointer
++	O
)	O
;	O
ncurs	int
=	O
jc	pointer
->	O
j_curslist	pointer
-	O
curslist	pointer
;	O
nslots	int
=	O
ncurs	int
+	O
1	int
;	O
jc	pointer
->	O
j_curslist	pointer
=	O
NULL	O
;	O
jc	pointer
->	O
j_workcurs	pointer
=	O
NULL	O
;	O
jc	pointer
->	O
j_fdupcurs	pointer
=	O
NULL	O
;	O
jc	pointer
->	O
j_exhausted	pointer
=	O
NULL	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_calloc	function
(	O
dbenv	pointer
,	O
nslots	int
,	O
sizeof	O
(	O
DBC	struct
*	O
)	O
,	O
&	O
jc	pointer
->	O
j_curslist	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_calloc	function
(	O
dbenv	pointer
,	O
nslots	int
,	O
sizeof	O
(	O
DBC	struct
*	O
)	O
,	O
&	O
jc	pointer
->	O
j_workcurs	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_calloc	function
(	O
dbenv	pointer
,	O
nslots	int
,	O
sizeof	O
(	O
DBC	struct
*	O
)	O
,	O
&	O
jc	pointer
->	O
j_fdupcurs	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_calloc	function
(	O
dbenv	pointer
,	O
nslots	int
,	O
sizeof	O
(	O
u_int8_t	char
)	O
,	O
&	O
jc	pointer
->	O
j_exhausted	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
curslist	pointer
[	O
i	int
]	O
!=	O
NULL	O
;	O
i	int
++	O
)	O
{	O
jc	pointer
->	O
j_curslist	pointer
[	O
i	int
]	O
=	O
curslist	pointer
[	O
i	int
]	O
;	O
jc	pointer
->	O
j_workcurs	pointer
[	O
i	int
]	O
=	O
NULL	O
;	O
jc	pointer
->	O
j_fdupcurs	pointer
[	O
i	int
]	O
=	O
NULL	O
;	O
jc	pointer
->	O
j_exhausted	pointer
[	O
i	int
]	O
=	O
0	int
;	O
}	O
jc	pointer
->	O
j_ncurs	int
=	O
ncurs	int
;	O
if	O
(	O
!	O
LF_ISSET	O
(	O
DB_JOIN_NOSORT	int
)	O
)	O
qsort	function
(	O
jc	pointer
->	O
j_curslist	pointer
,	O
ncurs	int
,	O
sizeof	O
(	O
DBC	struct
*	O
)	O
,	O
__db_join_cmp	function
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
jc	pointer
->	O
j_curslist	pointer
[	O
0	int
]	O
->	O
c_dup	pointer
(	O
jc	pointer
->	O
j_curslist	pointer
[	O
0	int
]	O
,	O
jc	pointer
->	O
j_workcurs	pointer
,	O
DB_POSITIONI	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
dbc	pointer
->	O
c_close	pointer
=	O
__db_join_close	function
;	O
dbc	pointer
->	O
c_del	pointer
=	O
__db_join_del	function
;	O
dbc	pointer
->	O
c_get	pointer
=	O
__db_join_get	function
;	O
dbc	pointer
->	O
c_put	pointer
=	O
__db_join_put	function
;	O
dbc	pointer
->	O
internal	pointer
=	O
(	O
DBC_INTERNAL	struct
*	O
)	O
jc	pointer
;	O
dbc	pointer
->	O
dbp	pointer
=	O
primary	int
;	O
jc	pointer
->	O
j_primary	pointer
=	O
primary	int
;	O
*	O
dbcp	pointer
=	O
dbc	pointer
;	O
MUTEX_THREAD_LOCK	O
(	O
primary	int
->	O
mutexp	pointer
)	O
;	O
TAILQ_INSERT_TAIL	O
(	O
&	O
primary	int
->	O
join_queue	struct
,	O
dbc	pointer
,	O
links	struct
)	O
;	O
MUTEX_THREAD_UNLOCK	O
(	O
primary	int
->	O
mutexp	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
err	pointer
:	O
if	O
(	O
jc	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
jc	pointer
->	O
j_curslist	pointer
!=	O
NULL	O
)	O
CDB___os_free	function
(	O
jc	pointer
->	O
j_curslist	pointer
,	O
nslots	int
*	O
sizeof	O
(	O
DBC	struct
*	O
)	O
)	O
;	O
if	O
(	O
jc	pointer
->	O
j_workcurs	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
jc	pointer
->	O
j_workcurs	pointer
[	O
0	int
]	O
!=	O
NULL	O
)	O
CDB___os_free	function
(	O
jc	pointer
->	O
j_workcurs	pointer
[	O
0	int
]	O
,	O
sizeof	O
(	O
DBC	struct
)	O
)	O
;	O
CDB___os_free	function
(	O
jc	pointer
->	O
j_workcurs	pointer
,	O
nslots	int
*	O
sizeof	O
(	O
DBC	struct
*	O
)	O
)	O
;	O
}	O
if	O
(	O
jc	pointer
->	O
j_fdupcurs	pointer
!=	O
NULL	O
)	O
CDB___os_free	function
(	O
jc	pointer
->	O
j_fdupcurs	pointer
,	O
nslots	int
*	O
sizeof	O
(	O
DBC	struct
*	O
)	O
)	O
;	O
if	O
(	O
jc	pointer
->	O
j_exhausted	pointer
!=	O
NULL	O
)	O
CDB___os_free	function
(	O
jc	pointer
->	O
j_exhausted	pointer
,	O
nslots	int
*	O
sizeof	O
(	O
u_int8_t	char
)	O
)	O
;	O
CDB___os_free	function
(	O
jc	pointer
,	O
sizeof	O
(	O
JOIN_CURSOR	struct
)	O
)	O
;	O
}	O
if	O
(	O
dbc	pointer
!=	O
NULL	O
)	O
CDB___os_free	function
(	O
dbc	pointer
,	O
sizeof	O
(	O
DBC	struct
)	O
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__db_join_put	function
(	O
dbc	pointer
,	O
key	struct
,	O
data	pointer
,	O
flags	int
)	O
DBC	struct
*	O
dbc	pointer
;	O
DBT	struct
*	O
key	struct
;	O
DBT	struct
*	O
data	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
if	O
(	O
key	struct
||	O
data	pointer
||	O
flags	int
)	O
{	O
}	O
PANIC_CHECK	O
(	O
dbc	pointer
->	O
dbp	pointer
->	O
dbenv	pointer
)	O
;	O
COMPQUIET	O
(	O
key	struct
,	O
NULL	O
)	O
;	O
COMPQUIET	O
(	O
data	pointer
,	O
NULL	O
)	O
;	O
COMPQUIET	O
(	O
flags	int
,	O
0	int
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
static	O
int	O
__db_join_del	function
(	O
dbc	pointer
,	O
flags	int
)	O
DBC	struct
*	O
dbc	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
if	O
(	O
flags	int
)	O
{	O
}	O
PANIC_CHECK	O
(	O
dbc	pointer
->	O
dbp	pointer
->	O
dbenv	pointer
)	O
;	O
COMPQUIET	O
(	O
flags	int
,	O
0	int
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
static	O
int	O
__db_join_get	function
(	O
dbc	pointer
,	O
key_arg	pointer
,	O
data_arg	pointer
,	O
flags	int
)	O
DBC	struct
*	O
dbc	pointer
;	O
DBT	struct
*	O
key_arg	pointer
,	O
*	O
data_arg	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
DBT	struct
*	O
key_n	pointer
,	O
key_n_mem	struct
;	O
DB	struct
*	O
dbp	pointer
;	O
DBC	struct
*	O
cp	pointer
;	O
JOIN_CURSOR	struct
*	O
jc	pointer
;	O
int	O
ret	int
;	O
u_int32_t	int
i	int
,	O
j	int
,	O
operation	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
jc	pointer
=	O
(	O
JOIN_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
PANIC_CHECK	O
(	O
dbp	pointer
->	O
dbenv	pointer
)	O
;	O
operation	int
=	O
LF_ISSET	O
(	O
DB_OPFLAGS_MASK	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_joingetchk	function
(	O
dbp	pointer
,	O
key_arg	pointer
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
key_arg	pointer
,	O
DB_DBT_USERMEM	int
)	O
||	O
F_ISSET	O
(	O
key_arg	pointer
,	O
DB_DBT_MALLOC	int
)	O
)	O
{	O
key_n	pointer
=	O
&	O
key_n_mem	struct
;	O
memset	function
(	O
key_n	pointer
,	O
0	int
,	O
sizeof	O
(	O
DBT	struct
)	O
)	O
;	O
}	O
else	O
{	O
key_n	pointer
=	O
key_arg	pointer
;	O
}	O
if	O
(	O
F_ISSET	O
(	O
jc	pointer
,	O
JOIN_RETRY	int
)	O
)	O
goto	O
samekey	O
;	O
F_CLR	O
(	O
jc	pointer
,	O
JOIN_RETRY	int
)	O
;	O
retry	O
:	O
ret	int
=	O
jc	pointer
->	O
j_workcurs	pointer
[	O
0	int
]	O
->	O
c_get	pointer
(	O
jc	pointer
->	O
j_workcurs	pointer
[	O
0	int
]	O
,	O
&	O
jc	pointer
->	O
j_key	struct
,	O
key_n	pointer
,	O
jc	pointer
->	O
j_exhausted	pointer
[	O
0	int
]	O
?	O
DB_NEXT_DUP	int
:	O
DB_CURRENT	int
)	O
;	O
if	O
(	O
ret	int
==	O
ENOMEM	int
)	O
{	O
jc	pointer
->	O
j_key	struct
.	O
ulen	int
<<=	O
1	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_realloc	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
jc	pointer
->	O
j_key	struct
.	O
ulen	int
,	O
NULL	O
,	O
&	O
jc	pointer
->	O
j_key	struct
.	O
data	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
mem_err	O
;	O
goto	O
retry	O
;	O
}	O
if	O
(	O
ret	int
!=	O
0	int
)	O
goto	O
err	pointer
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
jc	pointer
->	O
j_ncurs	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
jc	pointer
->	O
j_fdupcurs	pointer
[	O
i	int
]	O
!=	O
NULL	O
&&	O
(	O
ret	int
=	O
jc	pointer
->	O
j_fdupcurs	pointer
[	O
i	int
]	O
->	O
c_close	pointer
(	O
jc	pointer
->	O
j_fdupcurs	pointer
[	O
i	int
]	O
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
jc	pointer
->	O
j_fdupcurs	pointer
[	O
i	int
]	O
=	O
NULL	O
;	O
}	O
if	O
(	O
jc	pointer
->	O
j_curslist	pointer
[	O
1	int
]	O
==	O
NULL	O
)	O
jc	pointer
->	O
j_exhausted	pointer
[	O
0	int
]	O
=	O
1	int
;	O
else	O
jc	pointer
->	O
j_exhausted	pointer
[	O
0	int
]	O
=	O
0	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
jc	pointer
->	O
j_ncurs	int
;	O
i	int
++	O
)	O
{	O
DB_ASSERT	O
(	O
jc	pointer
->	O
j_curslist	pointer
[	O
i	int
]	O
!=	O
NULL	O
)	O
;	O
if	O
(	O
jc	pointer
->	O
j_workcurs	pointer
[	O
i	int
]	O
==	O
NULL	O
)	O
if	O
(	O
(	O
ret	int
=	O
jc	pointer
->	O
j_curslist	pointer
[	O
i	int
]	O
->	O
c_dup	pointer
(	O
jc	pointer
->	O
j_curslist	pointer
[	O
i	int
]	O
,	O
jc	pointer
->	O
j_workcurs	pointer
+	O
i	int
,	O
DB_POSITIONI	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
retry2	O
:	O
cp	pointer
=	O
jc	pointer
->	O
j_workcurs	pointer
[	O
i	int
]	O
;	O
if	O
(	O
(	O
ret	int
=	O
__db_join_getnext	function
(	O
cp	pointer
,	O
&	O
jc	pointer
->	O
j_key	struct
,	O
key_n	pointer
,	O
jc	pointer
->	O
j_exhausted	pointer
[	O
i	int
]	O
)	O
)	O
==	O
DB_NOTFOUND	O
)	O
{	O
--	O
i	int
;	O
jc	pointer
->	O
j_exhausted	pointer
[	O
i	int
]	O
=	O
1	int
;	O
if	O
(	O
i	int
==	O
0	int
)	O
{	O
for	O
(	O
j	int
=	O
1	int
;	O
jc	pointer
->	O
j_workcurs	pointer
[	O
j	int
]	O
!=	O
NULL	O
;	O
j	int
++	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
jc	pointer
->	O
j_workcurs	pointer
[	O
j	int
]	O
->	O
c_close	pointer
(	O
jc	pointer
->	O
j_workcurs	pointer
[	O
j	int
]	O
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
!	O
SORTED_SET	O
(	O
jc	pointer
,	O
0	int
)	O
||	O
!	O
SORTED_SET	O
(	O
jc	pointer
,	O
j	int
)	O
||	O
jc	pointer
->	O
j_fdupcurs	pointer
[	O
j	int
]	O
==	O
NULL	O
)	O
jc	pointer
->	O
j_workcurs	pointer
[	O
j	int
]	O
=	O
NULL	O
;	O
else	O
if	O
(	O
(	O
jc	pointer
->	O
j_fdupcurs	pointer
[	O
j	int
]	O
->	O
c_dup	pointer
(	O
jc	pointer
->	O
j_fdupcurs	pointer
[	O
j	int
]	O
,	O
&	O
jc	pointer
->	O
j_workcurs	pointer
[	O
j	int
]	O
,	O
DB_POSITIONI	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
jc	pointer
->	O
j_exhausted	pointer
[	O
j	int
]	O
=	O
0	int
;	O
}	O
goto	O
retry	O
;	O
}	O
for	O
(	O
j	int
=	O
i	int
+	O
1	int
;	O
jc	pointer
->	O
j_workcurs	pointer
[	O
j	int
]	O
!=	O
NULL	O
;	O
j	int
++	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
jc	pointer
->	O
j_workcurs	pointer
[	O
j	int
]	O
->	O
c_close	pointer
(	O
jc	pointer
->	O
j_workcurs	pointer
[	O
j	int
]	O
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
jc	pointer
->	O
j_exhausted	pointer
[	O
j	int
]	O
=	O
0	int
;	O
if	O
(	O
jc	pointer
->	O
j_fdupcurs	pointer
[	O
j	int
]	O
!=	O
NULL	O
&&	O
(	O
ret	int
=	O
jc	pointer
->	O
j_fdupcurs	pointer
[	O
j	int
]	O
->	O
c_dup	pointer
(	O
jc	pointer
->	O
j_fdupcurs	pointer
[	O
j	int
]	O
,	O
&	O
jc	pointer
->	O
j_workcurs	pointer
[	O
j	int
]	O
,	O
DB_POSITIONI	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
else	O
jc	pointer
->	O
j_workcurs	pointer
[	O
j	int
]	O
=	O
NULL	O
;	O
}	O
goto	O
retry2	O
;	O
}	O
if	O
(	O
ret	int
==	O
ENOMEM	int
)	O
{	O
jc	pointer
->	O
j_key	struct
.	O
ulen	int
<<=	O
1	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_realloc	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
jc	pointer
->	O
j_key	struct
.	O
ulen	int
,	O
NULL	O
,	O
&	O
jc	pointer
->	O
j_key	struct
.	O
data	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
mem_err	O
:	O
CDB___db_err	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Allocation failed for join key, len = %lu"	pointer
,	O
(	O
u_long	long
)	O
jc	pointer
->	O
j_key	struct
.	O
ulen	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
goto	O
retry2	O
;	O
}	O
if	O
(	O
ret	int
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
i	int
+	O
1	int
!=	O
jc	pointer
->	O
j_ncurs	int
)	O
jc	pointer
->	O
j_exhausted	pointer
[	O
i	int
]	O
=	O
0	int
;	O
else	O
jc	pointer
->	O
j_exhausted	pointer
[	O
i	int
]	O
=	O
1	int
;	O
if	O
(	O
SORTED_SET	O
(	O
jc	pointer
,	O
i	int
)	O
&&	O
jc	pointer
->	O
j_fdupcurs	pointer
[	O
i	int
]	O
==	O
NULL	O
&&	O
(	O
ret	int
=	O
cp	pointer
->	O
c_dup	pointer
(	O
cp	pointer
,	O
&	O
jc	pointer
->	O
j_fdupcurs	pointer
[	O
i	int
]	O
,	O
DB_POSITIONI	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
err	pointer
:	O
if	O
(	O
ret	int
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
0	int
)	O
{	O
samekey	O
:	O
if	O
(	O
(	O
ret	int
=	O
jc	pointer
->	O
j_workcurs	pointer
[	O
0	int
]	O
->	O
c_get	pointer
(	O
jc	pointer
->	O
j_workcurs	pointer
[	O
0	int
]	O
,	O
&	O
jc	pointer
->	O
j_key	struct
,	O
key_n	pointer
,	O
DB_CURRENT	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
F_CLR	O
(	O
jc	pointer
,	O
JOIN_RETRY	int
)	O
;	O
}	O
if	O
(	O
F_ISSET	O
(	O
key_arg	pointer
,	O
DB_DBT_USERMEM	int
)	O
||	O
F_ISSET	O
(	O
key_arg	pointer
,	O
DB_DBT_MALLOC	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_retcopy	function
(	O
dbp	pointer
,	O
key_arg	pointer
,	O
key_n	pointer
->	O
data	pointer
,	O
key_n	pointer
->	O
size	int
,	O
NULL	O
,	O
NULL	O
)	O
)	O
!=	O
0	int
)	O
{	O
F_SET	O
(	O
jc	pointer
,	O
JOIN_RETRY	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
}	O
else	O
DB_ASSERT	O
(	O
key_n	pointer
==	O
key_arg	pointer
)	O
;	O
if	O
(	O
operation	int
==	O
DB_JOIN_ITEM	int
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
jc	pointer
->	O
j_primary	pointer
->	O
get	pointer
(	O
jc	pointer
->	O
j_primary	pointer
,	O
jc	pointer
->	O
j_curslist	pointer
[	O
0	int
]	O
->	O
txn	pointer
,	O
key_arg	pointer
,	O
data_arg	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
F_SET	O
(	O
jc	pointer
,	O
JOIN_RETRY	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__db_join_close	function
(	O
dbc	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
JOIN_CURSOR	struct
*	O
jc	pointer
;	O
int	O
ret	int
,	O
t_ret	int
;	O
u_int32_t	int
i	int
;	O
jc	pointer
=	O
(	O
JOIN_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
ret	int
=	O
t_ret	int
=	O
0	int
;	O
MUTEX_THREAD_LOCK	O
(	O
dbp	pointer
->	O
mutexp	pointer
)	O
;	O
TAILQ_REMOVE	O
(	O
&	O
dbp	pointer
->	O
join_queue	struct
,	O
dbc	pointer
,	O
links	struct
)	O
;	O
MUTEX_THREAD_UNLOCK	O
(	O
dbp	pointer
->	O
mutexp	pointer
)	O
;	O
PANIC_CHECK	O
(	O
dbc	pointer
->	O
dbp	pointer
->	O
dbenv	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
jc	pointer
->	O
j_ncurs	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
jc	pointer
->	O
j_workcurs	pointer
[	O
i	int
]	O
!=	O
NULL	O
&&	O
(	O
t_ret	int
=	O
jc	pointer
->	O
j_workcurs	pointer
[	O
i	int
]	O
->	O
c_close	pointer
(	O
jc	pointer
->	O
j_workcurs	pointer
[	O
i	int
]	O
)	O
)	O
!=	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
jc	pointer
->	O
j_fdupcurs	pointer
[	O
i	int
]	O
!=	O
NULL	O
&&	O
(	O
t_ret	int
=	O
jc	pointer
->	O
j_fdupcurs	pointer
[	O
i	int
]	O
->	O
c_close	pointer
(	O
jc	pointer
->	O
j_fdupcurs	pointer
[	O
i	int
]	O
)	O
)	O
!=	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
}	O
CDB___os_free	function
(	O
jc	pointer
->	O
j_exhausted	pointer
,	O
0	int
)	O
;	O
CDB___os_free	function
(	O
jc	pointer
->	O
j_curslist	pointer
,	O
0	int
)	O
;	O
CDB___os_free	function
(	O
jc	pointer
->	O
j_workcurs	pointer
,	O
0	int
)	O
;	O
CDB___os_free	function
(	O
jc	pointer
->	O
j_fdupcurs	pointer
,	O
0	int
)	O
;	O
CDB___os_free	function
(	O
jc	pointer
->	O
j_key	struct
.	O
data	pointer
,	O
jc	pointer
->	O
j_key	struct
.	O
ulen	int
)	O
;	O
CDB___os_free	function
(	O
jc	pointer
,	O
sizeof	O
(	O
JOIN_CURSOR	struct
)	O
)	O
;	O
CDB___os_free	function
(	O
dbc	pointer
,	O
sizeof	O
(	O
DBC	struct
)	O
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__db_join_getnext	function
(	O
dbc	pointer
,	O
key	struct
,	O
data	pointer
,	O
exhausted	int
)	O
DBC	struct
*	O
dbc	pointer
;	O
DBT	struct
*	O
key	struct
,	O
*	O
data	pointer
;	O
u_int32_t	int
exhausted	int
;	O
{	O
int	O
ret	int
,	O
cmp	int
;	O
DB	struct
*	O
dbp	pointer
;	O
DBT	struct
ldata	struct
;	O
int	O
(	O
*	O
func	pointer
)	O
__P	O
(	O
(	O
const	O
DBT	struct
*	O
,	O
const	O
DBT	struct
*	O
)	O
)	O
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
func	pointer
=	O
(	O
dbp	pointer
->	O
dup_compare	pointer
==	O
NULL	O
)	O
?	O
CDB___bam_defcmp	function
:	O
dbp	pointer
->	O
dup_compare	pointer
;	O
switch	O
(	O
exhausted	int
)	O
{	O
case	O
0	int
:	O
memset	function
(	O
&	O
ldata	struct
,	O
0	int
,	O
sizeof	O
(	O
DBT	struct
)	O
)	O
;	O
F_SET	O
(	O
&	O
ldata	struct
,	O
DB_DBT_MALLOC	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
dbc	pointer
->	O
c_get	pointer
(	O
dbc	pointer
,	O
key	struct
,	O
&	O
ldata	struct
,	O
DB_CURRENT	int
)	O
)	O
!=	O
0	int
)	O
break	O
;	O
cmp	int
=	O
func	pointer
(	O
data	pointer
,	O
&	O
ldata	struct
)	O
;	O
if	O
(	O
cmp	int
==	O
0	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_retcopy	function
(	O
dbp	pointer
,	O
data	pointer
,	O
ldata	struct
.	O
data	pointer
,	O
ldata	struct
.	O
size	int
,	O
&	O
data	pointer
->	O
data	pointer
,	O
&	O
data	pointer
->	O
size	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
CDB___os_free	function
(	O
ldata	struct
.	O
data	pointer
,	O
0	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
CDB___os_free	function
(	O
ldata	struct
.	O
data	pointer
,	O
0	int
)	O
;	O
case	O
1	int
:	O
ret	int
=	O
dbc	pointer
->	O
c_get	pointer
(	O
dbc	pointer
,	O
key	struct
,	O
data	pointer
,	O
DB_GET_BOTHC	int
)	O
;	O
break	O
;	O
default	O
:	O
ret	int
=	O
EINVAL	int
;	O
break	O
;	O
}	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__db_join_cmp	function
(	O
a	pointer
,	O
b	pointer
)	O
const	O
void	O
*	O
a	pointer
,	O
*	O
b	pointer
;	O
{	O
DBC	struct
*	O
dbca	pointer
,	O
*	O
dbcb	pointer
;	O
db_recno_t	int
counta	int
,	O
countb	int
;	O
counta	int
=	O
countb	int
=	O
0	int
;	O
dbca	pointer
=	O
*	O
(	O
(	O
DBC	struct
*	O
const	O
*	O
)	O
a	pointer
)	O
;	O
dbcb	pointer
=	O
*	O
(	O
(	O
DBC	struct
*	O
const	O
*	O
)	O
b	pointer
)	O
;	O
if	O
(	O
dbca	pointer
->	O
c_count	pointer
(	O
dbca	pointer
,	O
&	O
counta	int
,	O
0	int
)	O
!=	O
0	int
||	O
dbcb	pointer
->	O
c_count	pointer
(	O
dbcb	pointer
,	O
&	O
countb	int
,	O
0	int
)	O
!=	O
0	int
)	O
return	O
(	O
0	int
)	O
;	O
return	O
(	O
counta	int
-	O
countb	int
)	O
;	O
}	O
