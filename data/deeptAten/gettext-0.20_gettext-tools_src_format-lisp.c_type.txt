enum	O
format_cdr_type	enum
{	O
FCT_REQUIRED	int
,	O
FCT_OPTIONAL	int
}	O
;	O
enum	O
format_arg_type	enum
{	O
FAT_OBJECT	int
,	O
FAT_CHARACTER_INTEGER_NULL	int
,	O
FAT_CHARACTER_NULL	int
,	O
FAT_CHARACTER	int
,	O
FAT_INTEGER_NULL	int
,	O
FAT_INTEGER	int
,	O
FAT_REAL	int
,	O
FAT_LIST	int
,	O
FAT_FORMATSTRING	int
,	O
FAT_FUNCTION	int
}	O
;	O
struct	O
format_arg	struct
{	O
unsigned	O
int	O
repcount	int
;	O
enum	O
format_cdr_type	enum
presence	enum
;	O
enum	O
format_arg_type	enum
type	enum
;	O
struct	O
format_arg_list	struct
*	O
list	pointer
;	O
}	O
;	O
struct	O
segment	struct
{	O
unsigned	O
int	O
count	int
;	O
unsigned	O
int	O
allocated	int
;	O
struct	O
format_arg	struct
*	O
element	array
;	O
unsigned	O
int	O
length	int
;	O
}	O
;	O
struct	O
format_arg_list	struct
{	O
struct	O
segment	struct
initial	struct
;	O
struct	O
segment	struct
repeated	struct
;	O
}	O
;	O
struct	O
spec	struct
{	O
unsigned	O
int	O
directives	int
;	O
struct	O
format_arg_list	struct
*	O
list	pointer
;	O
}	O
;	O
enum	O
param_type	enum
{	O
PT_NIL	int
,	O
PT_CHARACTER	int
,	O
PT_INTEGER	int
,	O
PT_ARGCOUNT	int
,	O
PT_V	int
}	O
;	O
struct	O
param	struct
{	O
enum	O
param_type	enum
type	enum
;	O
int	O
value	int
;	O
}	O
;	O
static	O
void	O
verify_list	function
(	O
const	O
struct	O
format_arg_list	struct
*	O
list	pointer
)	O
;	O
static	O
void	O
free_list	function
(	O
struct	O
format_arg_list	struct
*	O
list	pointer
)	O
;	O
static	O
struct	O
format_arg_list	struct
*	O
copy_list	function
(	O
const	O
struct	O
format_arg_list	struct
*	O
list	pointer
)	O
;	O
static	O
bool	bool
equal_list	function
(	O
const	O
struct	O
format_arg_list	struct
*	O
list1	pointer
,	O
const	O
struct	O
format_arg_list	struct
*	O
list2	pointer
)	O
;	O
static	O
struct	O
format_arg_list	struct
*	O
make_intersected_list	function
(	O
struct	O
format_arg_list	struct
*	O
list1	pointer
,	O
struct	O
format_arg_list	struct
*	O
list2	pointer
)	O
;	O
static	O
struct	O
format_arg_list	struct
*	O
make_intersection_with_empty_list	function
(	O
struct	O
format_arg_list	struct
*	O
list	pointer
)	O
;	O
static	O
struct	O
format_arg_list	struct
*	O
make_union_list	function
(	O
struct	O
format_arg_list	struct
*	O
list1	pointer
,	O
struct	O
format_arg_list	struct
*	O
list2	pointer
)	O
;	O
static	O
void	O
verify_element	function
(	O
const	O
struct	O
format_arg	struct
*	O
e	pointer
)	O
{	O
ASSERT	O
(	O
e	pointer
->	O
repcount	int
>	O
0	int
)	O
;	O
if	O
(	O
e	pointer
->	O
type	enum
==	O
FAT_LIST	int
)	O
verify_list	function
(	O
e	pointer
->	O
list	pointer
)	O
;	O
}	O
static	O
void	O
verify_list	function
(	O
const	O
struct	O
format_arg_list	struct
*	O
list	pointer
)	O
{	O
unsigned	O
int	O
i	long
;	O
unsigned	O
int	O
total_repcount	int
;	O
ASSERT	O
(	O
list	pointer
->	O
initial	struct
.	O
count	int
<=	O
list	pointer
->	O
initial	struct
.	O
allocated	int
)	O
;	O
total_repcount	int
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
list	pointer
->	O
initial	struct
.	O
count	int
;	O
i	long
++	O
)	O
{	O
verify_element	function
(	O
&	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
)	O
;	O
total_repcount	int
+=	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
.	O
repcount	int
;	O
}	O
ASSERT	O
(	O
total_repcount	int
==	O
list	pointer
->	O
initial	struct
.	O
length	int
)	O
;	O
ASSERT	O
(	O
list	pointer
->	O
repeated	struct
.	O
count	int
<=	O
list	pointer
->	O
repeated	struct
.	O
allocated	int
)	O
;	O
total_repcount	int
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
list	pointer
->	O
repeated	struct
.	O
count	int
;	O
i	long
++	O
)	O
{	O
verify_element	function
(	O
&	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
i	long
]	O
)	O
;	O
total_repcount	int
+=	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
i	long
]	O
.	O
repcount	int
;	O
}	O
ASSERT	O
(	O
total_repcount	int
==	O
list	pointer
->	O
repeated	struct
.	O
length	int
)	O
;	O
}	O
static	O
inline	O
void	O
free_element	function
(	O
struct	O
format_arg	struct
*	O
element	array
)	O
{	O
if	O
(	O
element	array
->	O
type	enum
==	O
FAT_LIST	int
)	O
free_list	function
(	O
element	array
->	O
list	pointer
)	O
;	O
}	O
static	O
void	O
free_list	function
(	O
struct	O
format_arg_list	struct
*	O
list	pointer
)	O
{	O
unsigned	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
list	pointer
->	O
initial	struct
.	O
count	int
;	O
i	long
++	O
)	O
free_element	function
(	O
&	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
)	O
;	O
if	O
(	O
list	pointer
->	O
initial	struct
.	O
element	array
!=	O
NULL	O
)	O
free	function
(	O
list	pointer
->	O
initial	struct
.	O
element	array
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
list	pointer
->	O
repeated	struct
.	O
count	int
;	O
i	long
++	O
)	O
free_element	function
(	O
&	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
i	long
]	O
)	O
;	O
if	O
(	O
list	pointer
->	O
repeated	struct
.	O
element	array
!=	O
NULL	O
)	O
free	function
(	O
list	pointer
->	O
repeated	struct
.	O
element	array
)	O
;	O
}	O
static	O
inline	O
void	O
copy_element	function
(	O
struct	O
format_arg	struct
*	O
newelement	pointer
,	O
const	O
struct	O
format_arg	struct
*	O
oldelement	pointer
)	O
{	O
newelement	pointer
->	O
repcount	int
=	O
oldelement	pointer
->	O
repcount	int
;	O
newelement	pointer
->	O
presence	enum
=	O
oldelement	pointer
->	O
presence	enum
;	O
newelement	pointer
->	O
type	enum
=	O
oldelement	pointer
->	O
type	enum
;	O
if	O
(	O
oldelement	pointer
->	O
type	enum
==	O
FAT_LIST	int
)	O
newelement	pointer
->	O
list	pointer
=	O
copy_list	function
(	O
oldelement	pointer
->	O
list	pointer
)	O
;	O
}	O
static	O
struct	O
format_arg_list	struct
*	O
copy_list	function
(	O
const	O
struct	O
format_arg_list	struct
*	O
list	pointer
)	O
{	O
struct	O
format_arg_list	struct
*	O
newlist	pointer
;	O
unsigned	O
int	O
length	int
;	O
unsigned	O
int	O
i	long
;	O
VERIFY_LIST	O
(	O
list	pointer
)	O
;	O
newlist	pointer
=	O
XMALLOC	O
(	O
struct	O
format_arg_list	struct
)	O
;	O
newlist	pointer
->	O
initial	struct
.	O
count	int
=	O
newlist	pointer
->	O
initial	struct
.	O
allocated	int
=	O
list	pointer
->	O
initial	struct
.	O
count	int
;	O
length	int
=	O
0	int
;	O
if	O
(	O
list	pointer
->	O
initial	struct
.	O
count	int
==	O
0	int
)	O
newlist	pointer
->	O
initial	struct
.	O
element	array
=	O
NULL	O
;	O
else	O
{	O
newlist	pointer
->	O
initial	struct
.	O
element	array
=	O
XNMALLOC	O
(	O
newlist	pointer
->	O
initial	struct
.	O
allocated	int
,	O
struct	O
format_arg	struct
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
list	pointer
->	O
initial	struct
.	O
count	int
;	O
i	long
++	O
)	O
{	O
copy_element	function
(	O
&	O
newlist	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
,	O
&	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
)	O
;	O
length	int
+=	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
.	O
repcount	int
;	O
}	O
}	O
ASSERT	O
(	O
length	int
==	O
list	pointer
->	O
initial	struct
.	O
length	int
)	O
;	O
newlist	pointer
->	O
initial	struct
.	O
length	int
=	O
length	int
;	O
newlist	pointer
->	O
repeated	struct
.	O
count	int
=	O
newlist	pointer
->	O
repeated	struct
.	O
allocated	int
=	O
list	pointer
->	O
repeated	struct
.	O
count	int
;	O
length	int
=	O
0	int
;	O
if	O
(	O
list	pointer
->	O
repeated	struct
.	O
count	int
==	O
0	int
)	O
newlist	pointer
->	O
repeated	struct
.	O
element	array
=	O
NULL	O
;	O
else	O
{	O
newlist	pointer
->	O
repeated	struct
.	O
element	array
=	O
XNMALLOC	O
(	O
newlist	pointer
->	O
repeated	struct
.	O
allocated	int
,	O
struct	O
format_arg	struct
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
list	pointer
->	O
repeated	struct
.	O
count	int
;	O
i	long
++	O
)	O
{	O
copy_element	function
(	O
&	O
newlist	pointer
->	O
repeated	struct
.	O
element	array
[	O
i	long
]	O
,	O
&	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
i	long
]	O
)	O
;	O
length	int
+=	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
i	long
]	O
.	O
repcount	int
;	O
}	O
}	O
ASSERT	O
(	O
length	int
==	O
list	pointer
->	O
repeated	struct
.	O
length	int
)	O
;	O
newlist	pointer
->	O
repeated	struct
.	O
length	int
=	O
length	int
;	O
VERIFY_LIST	O
(	O
newlist	pointer
)	O
;	O
return	O
newlist	pointer
;	O
}	O
static	O
bool	bool
equal_element	function
(	O
const	O
struct	O
format_arg	struct
*	O
e1	pointer
,	O
const	O
struct	O
format_arg	struct
*	O
e2	pointer
)	O
{	O
return	O
(	O
e1	pointer
->	O
presence	enum
==	O
e2	pointer
->	O
presence	enum
&&	O
e1	pointer
->	O
type	enum
==	O
e2	pointer
->	O
type	enum
&&	O
(	O
e1	pointer
->	O
type	enum
==	O
FAT_LIST	int
?	O
equal_list	function
(	O
e1	pointer
->	O
list	pointer
,	O
e2	pointer
->	O
list	pointer
)	O
:	O
true	int
)	O
)	O
;	O
}	O
static	O
bool	bool
equal_list	function
(	O
const	O
struct	O
format_arg_list	struct
*	O
list1	pointer
,	O
const	O
struct	O
format_arg_list	struct
*	O
list2	pointer
)	O
{	O
unsigned	O
int	O
n	long
,	O
i	long
;	O
VERIFY_LIST	O
(	O
list1	pointer
)	O
;	O
VERIFY_LIST	O
(	O
list2	pointer
)	O
;	O
n	long
=	O
list1	pointer
->	O
initial	struct
.	O
count	int
;	O
if	O
(	O
n	long
!=	O
list2	pointer
->	O
initial	struct
.	O
count	int
)	O
return	O
false	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
)	O
{	O
const	O
struct	O
format_arg	struct
*	O
e1	pointer
=	O
&	O
list1	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
;	O
const	O
struct	O
format_arg	struct
*	O
e2	pointer
=	O
&	O
list2	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
;	O
if	O
(	O
!	O
(	O
e1	pointer
->	O
repcount	int
==	O
e2	pointer
->	O
repcount	int
&&	O
equal_element	function
(	O
e1	pointer
,	O
e2	pointer
)	O
)	O
)	O
return	O
false	int
;	O
}	O
n	long
=	O
list1	pointer
->	O
repeated	struct
.	O
count	int
;	O
if	O
(	O
n	long
!=	O
list2	pointer
->	O
repeated	struct
.	O
count	int
)	O
return	O
false	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
)	O
{	O
const	O
struct	O
format_arg	struct
*	O
e1	pointer
=	O
&	O
list1	pointer
->	O
repeated	struct
.	O
element	array
[	O
i	long
]	O
;	O
const	O
struct	O
format_arg	struct
*	O
e2	pointer
=	O
&	O
list2	pointer
->	O
repeated	struct
.	O
element	array
[	O
i	long
]	O
;	O
if	O
(	O
!	O
(	O
e1	pointer
->	O
repcount	int
==	O
e2	pointer
->	O
repcount	int
&&	O
equal_element	function
(	O
e1	pointer
,	O
e2	pointer
)	O
)	O
)	O
return	O
false	int
;	O
}	O
return	O
true	int
;	O
}	O
static	O
inline	O
void	O
ensure_initial_alloc	function
(	O
struct	O
format_arg_list	struct
*	O
list	pointer
,	O
unsigned	O
int	O
newcount	int
)	O
{	O
if	O
(	O
newcount	int
>	O
list	pointer
->	O
initial	struct
.	O
allocated	int
)	O
{	O
list	pointer
->	O
initial	struct
.	O
allocated	int
=	O
MAX	O
(	O
2	int
*	O
list	pointer
->	O
initial	struct
.	O
allocated	int
+	O
1	int
,	O
newcount	int
)	O
;	O
list	pointer
->	O
initial	struct
.	O
element	array
=	O
(	O
struct	O
format_arg	struct
*	O
)	O
xrealloc	function
(	O
list	pointer
->	O
initial	struct
.	O
element	array
,	O
list	pointer
->	O
initial	struct
.	O
allocated	int
*	O
sizeof	O
(	O
struct	O
format_arg	struct
)	O
)	O
;	O
}	O
}	O
static	O
inline	O
void	O
grow_initial_alloc	function
(	O
struct	O
format_arg_list	struct
*	O
list	pointer
)	O
{	O
if	O
(	O
list	pointer
->	O
initial	struct
.	O
count	int
>=	O
list	pointer
->	O
initial	struct
.	O
allocated	int
)	O
{	O
list	pointer
->	O
initial	struct
.	O
allocated	int
=	O
MAX	O
(	O
2	int
*	O
list	pointer
->	O
initial	struct
.	O
allocated	int
+	O
1	int
,	O
list	pointer
->	O
initial	struct
.	O
count	int
+	O
1	int
)	O
;	O
list	pointer
->	O
initial	struct
.	O
element	array
=	O
(	O
struct	O
format_arg	struct
*	O
)	O
xrealloc	function
(	O
list	pointer
->	O
initial	struct
.	O
element	array
,	O
list	pointer
->	O
initial	struct
.	O
allocated	int
*	O
sizeof	O
(	O
struct	O
format_arg	struct
)	O
)	O
;	O
}	O
}	O
static	O
inline	O
void	O
ensure_repeated_alloc	function
(	O
struct	O
format_arg_list	struct
*	O
list	pointer
,	O
unsigned	O
int	O
newcount	int
)	O
{	O
if	O
(	O
newcount	int
>	O
list	pointer
->	O
repeated	struct
.	O
allocated	int
)	O
{	O
list	pointer
->	O
repeated	struct
.	O
allocated	int
=	O
MAX	O
(	O
2	int
*	O
list	pointer
->	O
repeated	struct
.	O
allocated	int
+	O
1	int
,	O
newcount	int
)	O
;	O
list	pointer
->	O
repeated	struct
.	O
element	array
=	O
(	O
struct	O
format_arg	struct
*	O
)	O
xrealloc	function
(	O
list	pointer
->	O
repeated	struct
.	O
element	array
,	O
list	pointer
->	O
repeated	struct
.	O
allocated	int
*	O
sizeof	O
(	O
struct	O
format_arg	struct
)	O
)	O
;	O
}	O
}	O
static	O
inline	O
void	O
grow_repeated_alloc	function
(	O
struct	O
format_arg_list	struct
*	O
list	pointer
)	O
{	O
if	O
(	O
list	pointer
->	O
repeated	struct
.	O
count	int
>=	O
list	pointer
->	O
repeated	struct
.	O
allocated	int
)	O
{	O
list	pointer
->	O
repeated	struct
.	O
allocated	int
=	O
MAX	O
(	O
2	int
*	O
list	pointer
->	O
repeated	struct
.	O
allocated	int
+	O
1	int
,	O
list	pointer
->	O
repeated	struct
.	O
count	int
+	O
1	int
)	O
;	O
list	pointer
->	O
repeated	struct
.	O
element	array
=	O
(	O
struct	O
format_arg	struct
*	O
)	O
xrealloc	function
(	O
list	pointer
->	O
repeated	struct
.	O
element	array
,	O
list	pointer
->	O
repeated	struct
.	O
allocated	int
*	O
sizeof	O
(	O
struct	O
format_arg	struct
)	O
)	O
;	O
}	O
}	O
static	O
void	O
normalize_outermost_list	function
(	O
struct	O
format_arg_list	struct
*	O
list	pointer
)	O
{	O
unsigned	O
int	O
n	long
,	O
i	long
,	O
j	long
;	O
n	long
=	O
list	pointer
->	O
initial	struct
.	O
count	int
;	O
for	O
(	O
i	long
=	O
j	long
=	O
0	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
)	O
if	O
(	O
j	long
>	O
0	int
&&	O
equal_element	function
(	O
&	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
,	O
&	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
j	long
-	O
1	int
]	O
)	O
)	O
{	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
j	long
-	O
1	int
]	O
.	O
repcount	int
+=	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
.	O
repcount	int
;	O
free_element	function
(	O
&	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
j	long
<	O
i	long
)	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
j	long
]	O
=	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
;	O
j	long
++	O
;	O
}	O
list	pointer
->	O
initial	struct
.	O
count	int
=	O
j	long
;	O
n	long
=	O
list	pointer
->	O
repeated	struct
.	O
count	int
;	O
for	O
(	O
i	long
=	O
j	long
=	O
0	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
)	O
if	O
(	O
j	long
>	O
0	int
&&	O
equal_element	function
(	O
&	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
i	long
]	O
,	O
&	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
j	long
-	O
1	int
]	O
)	O
)	O
{	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
j	long
-	O
1	int
]	O
.	O
repcount	int
+=	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
i	long
]	O
.	O
repcount	int
;	O
free_element	function
(	O
&	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
i	long
]	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
j	long
<	O
i	long
)	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
j	long
]	O
=	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
i	long
]	O
;	O
j	long
++	O
;	O
}	O
list	pointer
->	O
repeated	struct
.	O
count	int
=	O
j	long
;	O
if	O
(	O
list	pointer
->	O
repeated	struct
.	O
count	int
>	O
0	int
)	O
{	O
unsigned	O
int	O
m	int
,	O
repcount0_extra	int
;	O
n	long
=	O
list	pointer
->	O
repeated	struct
.	O
count	int
;	O
repcount0_extra	int
=	O
0	int
;	O
if	O
(	O
n	long
>	O
1	int
&&	O
equal_element	function
(	O
&	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
0	int
]	O
,	O
&	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
n	long
-	O
1	int
]	O
)	O
)	O
{	O
repcount0_extra	int
=	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
n	long
-	O
1	int
]	O
.	O
repcount	int
;	O
n	long
--	O
;	O
}	O
for	O
(	O
m	int
=	O
2	int
;	O
m	int
<=	O
n	long
/	O
2	int
;	O
n	long
++	O
)	O
if	O
(	O
(	O
n	long
%	O
m	int
)	O
==	O
0	int
)	O
{	O
bool	bool
ok	bool
=	O
true	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	long
-	O
m	int
;	O
i	long
++	O
)	O
if	O
(	O
!	O
(	O
(	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
i	long
]	O
.	O
repcount	int
+	O
(	O
i	long
==	O
0	int
?	O
repcount0_extra	int
:	O
0	int
)	O
==	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
i	long
+	O
m	int
]	O
.	O
repcount	int
)	O
&&	O
equal_element	function
(	O
&	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
i	long
]	O
,	O
&	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
i	long
+	O
m	int
]	O
)	O
)	O
)	O
{	O
ok	bool
=	O
false	int
;	O
break	O
;	O
}	O
if	O
(	O
ok	bool
)	O
{	O
for	O
(	O
i	long
=	O
m	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
)	O
free_element	function
(	O
&	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
i	long
]	O
)	O
;	O
if	O
(	O
n	long
<	O
list	pointer
->	O
repeated	struct
.	O
count	int
)	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
m	int
]	O
=	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
n	long
]	O
;	O
list	pointer
->	O
repeated	struct
.	O
count	int
=	O
list	pointer
->	O
repeated	struct
.	O
count	int
-	O
n	long
+	O
m	int
;	O
list	pointer
->	O
repeated	struct
.	O
length	int
/=	O
n	long
/	O
m	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
list	pointer
->	O
repeated	struct
.	O
count	int
==	O
1	int
)	O
{	O
if	O
(	O
list	pointer
->	O
initial	struct
.	O
count	int
>	O
0	int
&&	O
equal_element	function
(	O
&	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
list	pointer
->	O
initial	struct
.	O
count	int
-	O
1	int
]	O
,	O
&	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
0	int
]	O
)	O
)	O
{	O
list	pointer
->	O
initial	struct
.	O
length	int
-=	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
list	pointer
->	O
initial	struct
.	O
count	int
-	O
1	int
]	O
.	O
repcount	int
;	O
list	pointer
->	O
initial	struct
.	O
count	int
--	O
;	O
}	O
}	O
else	O
{	O
while	O
(	O
list	pointer
->	O
initial	struct
.	O
count	int
>	O
0	int
&&	O
equal_element	function
(	O
&	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
list	pointer
->	O
initial	struct
.	O
count	int
-	O
1	int
]	O
,	O
&	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
list	pointer
->	O
repeated	struct
.	O
count	int
-	O
1	int
]	O
)	O
)	O
{	O
unsigned	O
int	O
moved_repcount	int
=	O
MIN	O
(	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
list	pointer
->	O
initial	struct
.	O
count	int
-	O
1	int
]	O
.	O
repcount	int
,	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
list	pointer
->	O
repeated	struct
.	O
count	int
-	O
1	int
]	O
.	O
repcount	int
)	O
;	O
if	O
(	O
equal_element	function
(	O
&	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
0	int
]	O
,	O
&	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
list	pointer
->	O
repeated	struct
.	O
count	int
-	O
1	int
]	O
)	O
)	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
0	int
]	O
.	O
repcount	int
+=	O
moved_repcount	int
;	O
else	O
{	O
unsigned	O
int	O
newcount	int
=	O
list	pointer
->	O
repeated	struct
.	O
count	int
+	O
1	int
;	O
ensure_repeated_alloc	function
(	O
list	pointer
,	O
newcount	int
)	O
;	O
for	O
(	O
i	long
=	O
newcount	int
-	O
1	int
;	O
i	long
>	O
0	int
;	O
i	long
--	O
)	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
i	long
]	O
=	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
i	long
-	O
1	int
]	O
;	O
list	pointer
->	O
repeated	struct
.	O
count	int
=	O
newcount	int
;	O
copy_element	function
(	O
&	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
0	int
]	O
,	O
&	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
list	pointer
->	O
repeated	struct
.	O
count	int
-	O
1	int
]	O
)	O
;	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
0	int
]	O
.	O
repcount	int
=	O
moved_repcount	int
;	O
}	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
list	pointer
->	O
repeated	struct
.	O
count	int
-	O
1	int
]	O
.	O
repcount	int
-=	O
moved_repcount	int
;	O
if	O
(	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
list	pointer
->	O
repeated	struct
.	O
count	int
-	O
1	int
]	O
.	O
repcount	int
==	O
0	int
)	O
{	O
free_element	function
(	O
&	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
list	pointer
->	O
repeated	struct
.	O
count	int
-	O
1	int
]	O
)	O
;	O
list	pointer
->	O
repeated	struct
.	O
count	int
--	O
;	O
}	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
list	pointer
->	O
initial	struct
.	O
count	int
-	O
1	int
]	O
.	O
repcount	int
-=	O
moved_repcount	int
;	O
if	O
(	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
list	pointer
->	O
initial	struct
.	O
count	int
-	O
1	int
]	O
.	O
repcount	int
==	O
0	int
)	O
{	O
free_element	function
(	O
&	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
list	pointer
->	O
initial	struct
.	O
count	int
-	O
1	int
]	O
)	O
;	O
list	pointer
->	O
initial	struct
.	O
count	int
--	O
;	O
}	O
list	pointer
->	O
initial	struct
.	O
length	int
-=	O
moved_repcount	int
;	O
}	O
}	O
}	O
}	O
static	O
void	O
normalize_list	function
(	O
struct	O
format_arg_list	struct
*	O
list	pointer
)	O
{	O
unsigned	O
int	O
n	long
,	O
i	long
;	O
VERIFY_LIST	O
(	O
list	pointer
)	O
;	O
n	long
=	O
list	pointer
->	O
initial	struct
.	O
count	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
)	O
if	O
(	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
.	O
type	enum
==	O
FAT_LIST	int
)	O
normalize_list	function
(	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
.	O
list	pointer
)	O
;	O
n	long
=	O
list	pointer
->	O
repeated	struct
.	O
count	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
)	O
if	O
(	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
i	long
]	O
.	O
type	enum
==	O
FAT_LIST	int
)	O
normalize_list	function
(	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
i	long
]	O
.	O
list	pointer
)	O
;	O
normalize_outermost_list	function
(	O
list	pointer
)	O
;	O
VERIFY_LIST	O
(	O
list	pointer
)	O
;	O
}	O
static	O
struct	O
format_arg_list	struct
*	O
make_unconstrained_list	function
(	O
)	O
{	O
struct	O
format_arg_list	struct
*	O
list	pointer
;	O
list	pointer
=	O
XMALLOC	O
(	O
struct	O
format_arg_list	struct
)	O
;	O
list	pointer
->	O
initial	struct
.	O
count	int
=	O
0	int
;	O
list	pointer
->	O
initial	struct
.	O
allocated	int
=	O
0	int
;	O
list	pointer
->	O
initial	struct
.	O
element	array
=	O
NULL	O
;	O
list	pointer
->	O
initial	struct
.	O
length	int
=	O
0	int
;	O
list	pointer
->	O
repeated	struct
.	O
count	int
=	O
1	int
;	O
list	pointer
->	O
repeated	struct
.	O
allocated	int
=	O
1	int
;	O
list	pointer
->	O
repeated	struct
.	O
element	array
=	O
XNMALLOC	O
(	O
1	int
,	O
struct	O
format_arg	struct
)	O
;	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
0	int
]	O
.	O
repcount	int
=	O
1	int
;	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
0	int
]	O
.	O
presence	enum
=	O
FCT_OPTIONAL	int
;	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
0	int
]	O
.	O
type	enum
=	O
FAT_OBJECT	int
;	O
list	pointer
->	O
repeated	struct
.	O
length	int
=	O
1	int
;	O
VERIFY_LIST	O
(	O
list	pointer
)	O
;	O
return	O
list	pointer
;	O
}	O
static	O
struct	O
format_arg_list	struct
*	O
make_empty_list	function
(	O
)	O
{	O
struct	O
format_arg_list	struct
*	O
list	pointer
;	O
list	pointer
=	O
XMALLOC	O
(	O
struct	O
format_arg_list	struct
)	O
;	O
list	pointer
->	O
initial	struct
.	O
count	int
=	O
0	int
;	O
list	pointer
->	O
initial	struct
.	O
allocated	int
=	O
0	int
;	O
list	pointer
->	O
initial	struct
.	O
element	array
=	O
NULL	O
;	O
list	pointer
->	O
initial	struct
.	O
length	int
=	O
0	int
;	O
list	pointer
->	O
repeated	struct
.	O
count	int
=	O
0	int
;	O
list	pointer
->	O
repeated	struct
.	O
allocated	int
=	O
0	int
;	O
list	pointer
->	O
repeated	struct
.	O
element	array
=	O
NULL	O
;	O
list	pointer
->	O
repeated	struct
.	O
length	int
=	O
0	int
;	O
VERIFY_LIST	O
(	O
list	pointer
)	O
;	O
return	O
list	pointer
;	O
}	O
static	O
bool	bool
is_empty_list	function
(	O
const	O
struct	O
format_arg_list	struct
*	O
list	pointer
)	O
{	O
return	O
(	O
list	pointer
->	O
initial	struct
.	O
count	int
==	O
0	int
&&	O
list	pointer
->	O
repeated	struct
.	O
count	int
==	O
0	int
)	O
;	O
}	O
static	O
void	O
unfold_loop	function
(	O
struct	O
format_arg_list	struct
*	O
list	pointer
,	O
unsigned	O
int	O
m	int
)	O
{	O
unsigned	O
int	O
i	long
,	O
j	long
,	O
k	int
;	O
if	O
(	O
m	int
>	O
1	int
)	O
{	O
unsigned	O
int	O
newcount	int
=	O
list	pointer
->	O
repeated	struct
.	O
count	int
*	O
m	int
;	O
ensure_repeated_alloc	function
(	O
list	pointer
,	O
newcount	int
)	O
;	O
i	long
=	O
list	pointer
->	O
repeated	struct
.	O
count	int
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<	O
m	int
;	O
k	int
++	O
)	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
list	pointer
->	O
repeated	struct
.	O
count	int
;	O
j	long
++	O
,	O
i	long
++	O
)	O
copy_element	function
(	O
&	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
i	long
]	O
,	O
&	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
j	long
]	O
)	O
;	O
list	pointer
->	O
repeated	struct
.	O
count	int
=	O
newcount	int
;	O
list	pointer
->	O
repeated	struct
.	O
length	int
=	O
list	pointer
->	O
repeated	struct
.	O
length	int
*	O
m	int
;	O
}	O
}	O
static	O
void	O
rotate_loop	function
(	O
struct	O
format_arg_list	struct
*	O
list	pointer
,	O
unsigned	O
int	O
m	int
)	O
{	O
if	O
(	O
m	int
==	O
list	pointer
->	O
initial	struct
.	O
length	int
)	O
return	O
;	O
if	O
(	O
list	pointer
->	O
repeated	struct
.	O
count	int
==	O
1	int
)	O
{	O
unsigned	O
int	O
i	long
,	O
newcount	int
;	O
newcount	int
=	O
list	pointer
->	O
initial	struct
.	O
count	int
+	O
1	int
;	O
ensure_initial_alloc	function
(	O
list	pointer
,	O
newcount	int
)	O
;	O
i	long
=	O
list	pointer
->	O
initial	struct
.	O
count	int
;	O
copy_element	function
(	O
&	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
,	O
&	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
0	int
]	O
)	O
;	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
.	O
repcount	int
=	O
m	int
-	O
list	pointer
->	O
initial	struct
.	O
length	int
;	O
list	pointer
->	O
initial	struct
.	O
count	int
=	O
newcount	int
;	O
list	pointer
->	O
initial	struct
.	O
length	int
=	O
m	int
;	O
}	O
else	O
{	O
unsigned	O
int	O
n	long
=	O
list	pointer
->	O
repeated	struct
.	O
length	int
;	O
unsigned	O
int	O
q	int
=	O
(	O
m	int
-	O
list	pointer
->	O
initial	struct
.	O
length	int
)	O
/	O
n	long
;	O
unsigned	O
int	O
r	int
=	O
(	O
m	int
-	O
list	pointer
->	O
initial	struct
.	O
length	int
)	O
%	O
n	long
;	O
unsigned	O
int	O
s	pointer
;	O
unsigned	O
int	O
t	int
;	O
for	O
(	O
t	int
=	O
r	int
,	O
s	pointer
=	O
0	int
;	O
s	pointer
<	O
list	pointer
->	O
repeated	struct
.	O
count	int
&&	O
t	int
>=	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
s	pointer
]	O
.	O
repcount	int
;	O
t	int
-=	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
s	pointer
]	O
.	O
repcount	int
,	O
s	pointer
++	O
)	O
;	O
ASSERT	O
(	O
s	pointer
<	O
list	pointer
->	O
repeated	struct
.	O
count	int
)	O
;	O
{	O
unsigned	O
int	O
i	long
,	O
j	long
,	O
k	int
,	O
newcount	int
;	O
i	long
=	O
list	pointer
->	O
initial	struct
.	O
count	int
;	O
newcount	int
=	O
i	long
+	O
q	int
*	O
list	pointer
->	O
repeated	struct
.	O
count	int
+	O
s	pointer
+	O
(	O
t	int
>	O
0	int
?	O
1	int
:	O
0	int
)	O
;	O
ensure_initial_alloc	function
(	O
list	pointer
,	O
newcount	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
q	int
;	O
k	int
++	O
)	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
list	pointer
->	O
repeated	struct
.	O
count	int
;	O
j	long
++	O
,	O
i	long
++	O
)	O
copy_element	function
(	O
&	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
,	O
&	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
j	long
]	O
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
s	pointer
;	O
j	long
++	O
,	O
i	long
++	O
)	O
copy_element	function
(	O
&	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
,	O
&	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
j	long
]	O
)	O
;	O
if	O
(	O
t	int
>	O
0	int
)	O
{	O
copy_element	function
(	O
&	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
,	O
&	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
j	long
]	O
)	O
;	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
.	O
repcount	int
=	O
t	int
;	O
i	long
++	O
;	O
}	O
ASSERT	O
(	O
i	long
==	O
newcount	int
)	O
;	O
list	pointer
->	O
initial	struct
.	O
count	int
=	O
newcount	int
;	O
list	pointer
->	O
initial	struct
.	O
length	int
=	O
m	int
;	O
}	O
if	O
(	O
r	int
>	O
0	int
)	O
{	O
unsigned	O
int	O
i	long
,	O
j	long
,	O
oldcount	int
,	O
newcount	int
;	O
struct	O
format_arg	struct
*	O
newelement	pointer
;	O
oldcount	int
=	O
list	pointer
->	O
repeated	struct
.	O
count	int
;	O
newcount	int
=	O
list	pointer
->	O
repeated	struct
.	O
count	int
+	O
(	O
t	int
>	O
0	int
?	O
1	int
:	O
0	int
)	O
;	O
newelement	pointer
=	O
XNMALLOC	O
(	O
newcount	int
,	O
struct	O
format_arg	struct
)	O
;	O
i	long
=	O
0	int
;	O
for	O
(	O
j	long
=	O
s	pointer
;	O
j	long
<	O
oldcount	int
;	O
j	long
++	O
,	O
i	long
++	O
)	O
newelement	pointer
[	O
i	long
]	O
=	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
j	long
]	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
s	pointer
;	O
j	long
++	O
,	O
i	long
++	O
)	O
newelement	pointer
[	O
i	long
]	O
=	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
j	long
]	O
;	O
if	O
(	O
t	int
>	O
0	int
)	O
{	O
copy_element	function
(	O
&	O
newelement	pointer
[	O
oldcount	int
]	O
,	O
&	O
newelement	pointer
[	O
0	int
]	O
)	O
;	O
newelement	pointer
[	O
0	int
]	O
.	O
repcount	int
-=	O
t	int
;	O
newelement	pointer
[	O
oldcount	int
]	O
.	O
repcount	int
=	O
t	int
;	O
}	O
free	function
(	O
list	pointer
->	O
repeated	struct
.	O
element	array
)	O
;	O
list	pointer
->	O
repeated	struct
.	O
element	array
=	O
newelement	pointer
;	O
}	O
}	O
}	O
static	O
unsigned	O
int	O
initial_splitelement	function
(	O
struct	O
format_arg_list	struct
*	O
list	pointer
,	O
unsigned	O
int	O
n	long
)	O
{	O
unsigned	O
int	O
s	pointer
;	O
unsigned	O
int	O
t	int
;	O
unsigned	O
int	O
oldrepcount	int
;	O
unsigned	O
int	O
newcount	int
;	O
unsigned	O
int	O
i	long
;	O
VERIFY_LIST	O
(	O
list	pointer
)	O
;	O
if	O
(	O
n	long
>	O
list	pointer
->	O
initial	struct
.	O
length	int
)	O
{	O
ASSERT	O
(	O
list	pointer
->	O
repeated	struct
.	O
count	int
>	O
0	int
)	O
;	O
rotate_loop	function
(	O
list	pointer
,	O
n	long
)	O
;	O
ASSERT	O
(	O
n	long
<=	O
list	pointer
->	O
initial	struct
.	O
length	int
)	O
;	O
}	O
for	O
(	O
t	int
=	O
n	long
,	O
s	pointer
=	O
0	int
;	O
s	pointer
<	O
list	pointer
->	O
initial	struct
.	O
count	int
&&	O
t	int
>=	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
]	O
.	O
repcount	int
;	O
t	int
-=	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
]	O
.	O
repcount	int
,	O
s	pointer
++	O
)	O
;	O
if	O
(	O
t	int
==	O
0	int
)	O
return	O
s	pointer
;	O
ASSERT	O
(	O
s	pointer
<	O
list	pointer
->	O
initial	struct
.	O
count	int
)	O
;	O
oldrepcount	int
=	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
]	O
.	O
repcount	int
;	O
newcount	int
=	O
list	pointer
->	O
initial	struct
.	O
count	int
+	O
1	int
;	O
ensure_initial_alloc	function
(	O
list	pointer
,	O
newcount	int
)	O
;	O
for	O
(	O
i	long
=	O
list	pointer
->	O
initial	struct
.	O
count	int
-	O
1	int
;	O
i	long
>	O
s	pointer
;	O
i	long
--	O
)	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
+	O
1	int
]	O
=	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
;	O
copy_element	function
(	O
&	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
+	O
1	int
]	O
,	O
&	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
]	O
)	O
;	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
]	O
.	O
repcount	int
=	O
t	int
;	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
+	O
1	int
]	O
.	O
repcount	int
=	O
oldrepcount	int
-	O
t	int
;	O
list	pointer
->	O
initial	struct
.	O
count	int
=	O
newcount	int
;	O
VERIFY_LIST	O
(	O
list	pointer
)	O
;	O
return	O
s	pointer
+	O
1	int
;	O
}	O
static	O
unsigned	O
int	O
initial_unshare	function
(	O
struct	O
format_arg_list	struct
*	O
list	pointer
,	O
unsigned	O
int	O
n	long
)	O
{	O
unsigned	O
int	O
s	pointer
;	O
unsigned	O
int	O
t	int
;	O
VERIFY_LIST	O
(	O
list	pointer
)	O
;	O
if	O
(	O
n	long
>=	O
list	pointer
->	O
initial	struct
.	O
length	int
)	O
{	O
ASSERT	O
(	O
list	pointer
->	O
repeated	struct
.	O
count	int
>	O
0	int
)	O
;	O
rotate_loop	function
(	O
list	pointer
,	O
n	long
+	O
1	int
)	O
;	O
ASSERT	O
(	O
n	long
<	O
list	pointer
->	O
initial	struct
.	O
length	int
)	O
;	O
}	O
for	O
(	O
t	int
=	O
n	long
,	O
s	pointer
=	O
0	int
;	O
s	pointer
<	O
list	pointer
->	O
initial	struct
.	O
count	int
&&	O
t	int
>=	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
]	O
.	O
repcount	int
;	O
t	int
-=	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
]	O
.	O
repcount	int
,	O
s	pointer
++	O
)	O
;	O
ASSERT	O
(	O
s	pointer
<	O
list	pointer
->	O
initial	struct
.	O
count	int
)	O
;	O
if	O
(	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
]	O
.	O
repcount	int
>	O
1	int
)	O
{	O
unsigned	O
int	O
oldrepcount	int
=	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
]	O
.	O
repcount	int
;	O
unsigned	O
int	O
newcount	int
=	O
list	pointer
->	O
initial	struct
.	O
count	int
+	O
(	O
t	int
==	O
0	int
||	O
t	int
==	O
oldrepcount	int
-	O
1	int
?	O
1	int
:	O
2	int
)	O
;	O
ensure_initial_alloc	function
(	O
list	pointer
,	O
newcount	int
)	O
;	O
if	O
(	O
t	int
==	O
0	int
||	O
t	int
==	O
oldrepcount	int
-	O
1	int
)	O
{	O
unsigned	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
list	pointer
->	O
initial	struct
.	O
count	int
-	O
1	int
;	O
i	long
>	O
s	pointer
;	O
i	long
--	O
)	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
+	O
1	int
]	O
=	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
;	O
copy_element	function
(	O
&	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
+	O
1	int
]	O
,	O
&	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
]	O
)	O
;	O
if	O
(	O
t	int
==	O
0	int
)	O
{	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
]	O
.	O
repcount	int
=	O
1	int
;	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
+	O
1	int
]	O
.	O
repcount	int
=	O
oldrepcount	int
-	O
1	int
;	O
}	O
else	O
{	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
]	O
.	O
repcount	int
=	O
oldrepcount	int
-	O
1	int
;	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
+	O
1	int
]	O
.	O
repcount	int
=	O
1	int
;	O
}	O
}	O
else	O
{	O
unsigned	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
list	pointer
->	O
initial	struct
.	O
count	int
-	O
1	int
;	O
i	long
>	O
s	pointer
;	O
i	long
--	O
)	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
+	O
2	int
]	O
=	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
;	O
copy_element	function
(	O
&	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
+	O
2	int
]	O
,	O
&	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
]	O
)	O
;	O
copy_element	function
(	O
&	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
+	O
1	int
]	O
,	O
&	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
]	O
)	O
;	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
]	O
.	O
repcount	int
=	O
t	int
;	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
+	O
1	int
]	O
.	O
repcount	int
=	O
1	int
;	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
+	O
2	int
]	O
.	O
repcount	int
=	O
oldrepcount	int
-	O
1	int
-	O
t	int
;	O
}	O
list	pointer
->	O
initial	struct
.	O
count	int
=	O
newcount	int
;	O
if	O
(	O
t	int
>	O
0	int
)	O
s	pointer
++	O
;	O
}	O
ASSERT	O
(	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
]	O
.	O
repcount	int
==	O
1	int
)	O
;	O
VERIFY_LIST	O
(	O
list	pointer
)	O
;	O
return	O
s	pointer
;	O
}	O
static	O
void	O
shift_list	function
(	O
struct	O
format_arg_list	struct
*	O
list	pointer
,	O
unsigned	O
int	O
n	long
)	O
{	O
VERIFY_LIST	O
(	O
list	pointer
)	O
;	O
if	O
(	O
n	long
>	O
0	int
)	O
{	O
unsigned	O
int	O
i	long
;	O
grow_initial_alloc	function
(	O
list	pointer
)	O
;	O
for	O
(	O
i	long
=	O
list	pointer
->	O
initial	struct
.	O
count	int
;	O
i	long
>	O
0	int
;	O
i	long
--	O
)	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
=	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
-	O
1	int
]	O
;	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
0	int
]	O
.	O
repcount	int
=	O
n	long
;	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
0	int
]	O
.	O
presence	enum
=	O
FCT_REQUIRED	int
;	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
0	int
]	O
.	O
type	enum
=	O
FAT_OBJECT	int
;	O
list	pointer
->	O
initial	struct
.	O
count	int
++	O
;	O
list	pointer
->	O
initial	struct
.	O
length	int
+=	O
n	long
;	O
normalize_outermost_list	function
(	O
list	pointer
)	O
;	O
}	O
VERIFY_LIST	O
(	O
list	pointer
)	O
;	O
}	O
static	O
bool	bool
make_intersected_element	function
(	O
struct	O
format_arg	struct
*	O
re	pointer
,	O
const	O
struct	O
format_arg	struct
*	O
e1	pointer
,	O
const	O
struct	O
format_arg	struct
*	O
e2	pointer
)	O
{	O
if	O
(	O
e1	pointer
->	O
presence	enum
==	O
FCT_REQUIRED	int
||	O
e2	pointer
->	O
presence	enum
==	O
FCT_REQUIRED	int
)	O
re	pointer
->	O
presence	enum
=	O
FCT_REQUIRED	int
;	O
else	O
re	pointer
->	O
presence	enum
=	O
FCT_OPTIONAL	int
;	O
if	O
(	O
e1	pointer
->	O
type	enum
==	O
FAT_OBJECT	int
)	O
{	O
re	pointer
->	O
type	enum
=	O
e2	pointer
->	O
type	enum
;	O
if	O
(	O
re	pointer
->	O
type	enum
==	O
FAT_LIST	int
)	O
re	pointer
->	O
list	pointer
=	O
copy_list	function
(	O
e2	pointer
->	O
list	pointer
)	O
;	O
}	O
else	O
if	O
(	O
e2	pointer
->	O
type	enum
==	O
FAT_OBJECT	int
)	O
{	O
re	pointer
->	O
type	enum
=	O
e1	pointer
->	O
type	enum
;	O
if	O
(	O
re	pointer
->	O
type	enum
==	O
FAT_LIST	int
)	O
re	pointer
->	O
list	pointer
=	O
copy_list	function
(	O
e1	pointer
->	O
list	pointer
)	O
;	O
}	O
else	O
if	O
(	O
e1	pointer
->	O
type	enum
==	O
FAT_LIST	int
&&	O
(	O
e2	pointer
->	O
type	enum
==	O
FAT_CHARACTER_INTEGER_NULL	int
||	O
e2	pointer
->	O
type	enum
==	O
FAT_CHARACTER_NULL	int
||	O
e2	pointer
->	O
type	enum
==	O
FAT_INTEGER_NULL	int
)	O
)	O
{	O
re	pointer
->	O
type	enum
=	O
e1	pointer
->	O
type	enum
;	O
re	pointer
->	O
list	pointer
=	O
make_intersection_with_empty_list	function
(	O
e1	pointer
->	O
list	pointer
)	O
;	O
if	O
(	O
re	pointer
->	O
list	pointer
==	O
NULL	O
)	O
return	O
false	int
;	O
}	O
else	O
if	O
(	O
e2	pointer
->	O
type	enum
==	O
FAT_LIST	int
&&	O
(	O
e1	pointer
->	O
type	enum
==	O
FAT_CHARACTER_INTEGER_NULL	int
||	O
e1	pointer
->	O
type	enum
==	O
FAT_CHARACTER_NULL	int
||	O
e1	pointer
->	O
type	enum
==	O
FAT_INTEGER_NULL	int
)	O
)	O
{	O
re	pointer
->	O
type	enum
=	O
e2	pointer
->	O
type	enum
;	O
re	pointer
->	O
list	pointer
=	O
make_intersection_with_empty_list	function
(	O
e2	pointer
->	O
list	pointer
)	O
;	O
if	O
(	O
re	pointer
->	O
list	pointer
==	O
NULL	O
)	O
return	O
false	int
;	O
}	O
else	O
if	O
(	O
e1	pointer
->	O
type	enum
==	O
FAT_CHARACTER_INTEGER_NULL	int
&&	O
(	O
e2	pointer
->	O
type	enum
==	O
FAT_CHARACTER_NULL	int
||	O
e2	pointer
->	O
type	enum
==	O
FAT_CHARACTER	int
||	O
e2	pointer
->	O
type	enum
==	O
FAT_INTEGER_NULL	int
||	O
e2	pointer
->	O
type	enum
==	O
FAT_INTEGER	int
)	O
)	O
{	O
re	pointer
->	O
type	enum
=	O
e2	pointer
->	O
type	enum
;	O
}	O
else	O
if	O
(	O
e2	pointer
->	O
type	enum
==	O
FAT_CHARACTER_INTEGER_NULL	int
&&	O
(	O
e1	pointer
->	O
type	enum
==	O
FAT_CHARACTER_NULL	int
||	O
e1	pointer
->	O
type	enum
==	O
FAT_CHARACTER	int
||	O
e1	pointer
->	O
type	enum
==	O
FAT_INTEGER_NULL	int
||	O
e1	pointer
->	O
type	enum
==	O
FAT_INTEGER	int
)	O
)	O
{	O
re	pointer
->	O
type	enum
=	O
e1	pointer
->	O
type	enum
;	O
}	O
else	O
if	O
(	O
e1	pointer
->	O
type	enum
==	O
FAT_CHARACTER_NULL	int
&&	O
e2	pointer
->	O
type	enum
==	O
FAT_CHARACTER	int
)	O
{	O
re	pointer
->	O
type	enum
=	O
e2	pointer
->	O
type	enum
;	O
}	O
else	O
if	O
(	O
e2	pointer
->	O
type	enum
==	O
FAT_CHARACTER_NULL	int
&&	O
e1	pointer
->	O
type	enum
==	O
FAT_CHARACTER	int
)	O
{	O
re	pointer
->	O
type	enum
=	O
e1	pointer
->	O
type	enum
;	O
}	O
else	O
if	O
(	O
e1	pointer
->	O
type	enum
==	O
FAT_INTEGER_NULL	int
&&	O
e2	pointer
->	O
type	enum
==	O
FAT_INTEGER	int
)	O
{	O
re	pointer
->	O
type	enum
=	O
e2	pointer
->	O
type	enum
;	O
}	O
else	O
if	O
(	O
e2	pointer
->	O
type	enum
==	O
FAT_INTEGER_NULL	int
&&	O
e1	pointer
->	O
type	enum
==	O
FAT_INTEGER	int
)	O
{	O
re	pointer
->	O
type	enum
=	O
e1	pointer
->	O
type	enum
;	O
}	O
else	O
if	O
(	O
e1	pointer
->	O
type	enum
==	O
FAT_REAL	int
&&	O
e2	pointer
->	O
type	enum
==	O
FAT_INTEGER	int
)	O
{	O
re	pointer
->	O
type	enum
=	O
e2	pointer
->	O
type	enum
;	O
}	O
else	O
if	O
(	O
e2	pointer
->	O
type	enum
==	O
FAT_REAL	int
&&	O
e1	pointer
->	O
type	enum
==	O
FAT_INTEGER	int
)	O
{	O
re	pointer
->	O
type	enum
=	O
e1	pointer
->	O
type	enum
;	O
}	O
else	O
if	O
(	O
e1	pointer
->	O
type	enum
==	O
e2	pointer
->	O
type	enum
)	O
{	O
re	pointer
->	O
type	enum
=	O
e1	pointer
->	O
type	enum
;	O
if	O
(	O
re	pointer
->	O
type	enum
==	O
FAT_LIST	int
)	O
{	O
re	pointer
->	O
list	pointer
=	O
make_intersected_list	function
(	O
copy_list	function
(	O
e1	pointer
->	O
list	pointer
)	O
,	O
copy_list	function
(	O
e2	pointer
->	O
list	pointer
)	O
)	O
;	O
if	O
(	O
re	pointer
->	O
list	pointer
==	O
NULL	O
)	O
return	O
false	int
;	O
}	O
}	O
else	O
return	O
false	int
;	O
return	O
true	int
;	O
}	O
static	O
void	O
append_repeated_to_initial	function
(	O
struct	O
format_arg_list	struct
*	O
list	pointer
)	O
{	O
if	O
(	O
list	pointer
->	O
repeated	struct
.	O
count	int
>	O
0	int
)	O
{	O
unsigned	O
int	O
i	long
,	O
j	long
,	O
newcount	int
;	O
newcount	int
=	O
list	pointer
->	O
initial	struct
.	O
count	int
+	O
list	pointer
->	O
repeated	struct
.	O
count	int
;	O
ensure_initial_alloc	function
(	O
list	pointer
,	O
newcount	int
)	O
;	O
i	long
=	O
list	pointer
->	O
initial	struct
.	O
count	int
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
list	pointer
->	O
repeated	struct
.	O
count	int
;	O
j	long
++	O
,	O
i	long
++	O
)	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
=	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
j	long
]	O
;	O
list	pointer
->	O
initial	struct
.	O
count	int
=	O
newcount	int
;	O
list	pointer
->	O
initial	struct
.	O
length	int
=	O
list	pointer
->	O
initial	struct
.	O
length	int
+	O
list	pointer
->	O
repeated	struct
.	O
length	int
;	O
free	function
(	O
list	pointer
->	O
repeated	struct
.	O
element	array
)	O
;	O
list	pointer
->	O
repeated	struct
.	O
element	array
=	O
NULL	O
;	O
list	pointer
->	O
repeated	struct
.	O
allocated	int
=	O
0	int
;	O
list	pointer
->	O
repeated	struct
.	O
count	int
=	O
0	int
;	O
list	pointer
->	O
repeated	struct
.	O
length	int
=	O
0	int
;	O
}	O
}	O
static	O
struct	O
format_arg_list	struct
*	O
backtrack_in_initial	function
(	O
struct	O
format_arg_list	struct
*	O
list	pointer
)	O
{	O
ASSERT	O
(	O
list	pointer
->	O
repeated	struct
.	O
count	int
==	O
0	int
)	O
;	O
while	O
(	O
list	pointer
->	O
initial	struct
.	O
count	int
>	O
0	int
)	O
{	O
unsigned	O
int	O
i	long
=	O
list	pointer
->	O
initial	struct
.	O
count	int
-	O
1	int
;	O
if	O
(	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
.	O
presence	enum
==	O
FCT_REQUIRED	int
)	O
{	O
list	pointer
->	O
initial	struct
.	O
length	int
-=	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
.	O
repcount	int
;	O
free_element	function
(	O
&	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
)	O
;	O
list	pointer
->	O
initial	struct
.	O
count	int
=	O
i	long
;	O
}	O
else	O
{	O
list	pointer
->	O
initial	struct
.	O
length	int
--	O
;	O
if	O
(	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
.	O
repcount	int
>	O
1	int
)	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
.	O
repcount	int
--	O
;	O
else	O
{	O
free_element	function
(	O
&	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
)	O
;	O
list	pointer
->	O
initial	struct
.	O
count	int
=	O
i	long
;	O
}	O
VERIFY_LIST	O
(	O
list	pointer
)	O
;	O
return	O
list	pointer
;	O
}	O
}	O
free_list	function
(	O
list	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
static	O
struct	O
format_arg_list	struct
*	O
make_intersected_list	function
(	O
struct	O
format_arg_list	struct
*	O
list1	pointer
,	O
struct	O
format_arg_list	struct
*	O
list2	pointer
)	O
{	O
struct	O
format_arg_list	struct
*	O
result	pointer
;	O
VERIFY_LIST	O
(	O
list1	pointer
)	O
;	O
VERIFY_LIST	O
(	O
list2	pointer
)	O
;	O
if	O
(	O
list1	pointer
->	O
repeated	struct
.	O
length	int
>	O
0	int
&&	O
list2	pointer
->	O
repeated	struct
.	O
length	int
>	O
0	int
)	O
{	O
unsigned	O
int	O
n1	int
=	O
list1	pointer
->	O
repeated	struct
.	O
length	int
;	O
unsigned	O
int	O
n2	int
=	O
list2	pointer
->	O
repeated	struct
.	O
length	int
;	O
unsigned	O
int	O
g	int
=	O
gcd	function
(	O
n1	int
,	O
n2	int
)	O
;	O
unsigned	O
int	O
m1	int
=	O
n2	int
/	O
g	int
;	O
unsigned	O
int	O
m2	int
=	O
n1	int
/	O
g	int
;	O
unfold_loop	function
(	O
list1	pointer
,	O
m1	int
)	O
;	O
unfold_loop	function
(	O
list2	pointer
,	O
m2	int
)	O
;	O
}	O
if	O
(	O
list1	pointer
->	O
repeated	struct
.	O
length	int
>	O
0	int
||	O
list2	pointer
->	O
repeated	struct
.	O
length	int
>	O
0	int
)	O
{	O
unsigned	O
int	O
m	int
=	O
MAX	O
(	O
list1	pointer
->	O
initial	struct
.	O
length	int
,	O
list2	pointer
->	O
initial	struct
.	O
length	int
)	O
;	O
if	O
(	O
list1	pointer
->	O
repeated	struct
.	O
length	int
>	O
0	int
)	O
rotate_loop	function
(	O
list1	pointer
,	O
m	int
)	O
;	O
if	O
(	O
list2	pointer
->	O
repeated	struct
.	O
length	int
>	O
0	int
)	O
rotate_loop	function
(	O
list2	pointer
,	O
m	int
)	O
;	O
}	O
if	O
(	O
list1	pointer
->	O
repeated	struct
.	O
length	int
>	O
0	int
&&	O
list2	pointer
->	O
repeated	struct
.	O
length	int
>	O
0	int
)	O
{	O
ASSERT	O
(	O
list1	pointer
->	O
initial	struct
.	O
length	int
==	O
list2	pointer
->	O
initial	struct
.	O
length	int
)	O
;	O
ASSERT	O
(	O
list1	pointer
->	O
repeated	struct
.	O
length	int
==	O
list2	pointer
->	O
repeated	struct
.	O
length	int
)	O
;	O
}	O
result	pointer
=	O
XMALLOC	O
(	O
struct	O
format_arg_list	struct
)	O
;	O
result	pointer
->	O
initial	struct
.	O
count	int
=	O
0	int
;	O
result	pointer
->	O
initial	struct
.	O
allocated	int
=	O
0	int
;	O
result	pointer
->	O
initial	struct
.	O
element	array
=	O
NULL	O
;	O
result	pointer
->	O
initial	struct
.	O
length	int
=	O
0	int
;	O
result	pointer
->	O
repeated	struct
.	O
count	int
=	O
0	int
;	O
result	pointer
->	O
repeated	struct
.	O
allocated	int
=	O
0	int
;	O
result	pointer
->	O
repeated	struct
.	O
element	array
=	O
NULL	O
;	O
result	pointer
->	O
repeated	struct
.	O
length	int
=	O
0	int
;	O
{	O
struct	O
format_arg	struct
*	O
e1	pointer
;	O
struct	O
format_arg	struct
*	O
e2	pointer
;	O
unsigned	O
int	O
c1	int
;	O
unsigned	O
int	O
c2	int
;	O
e1	pointer
=	O
list1	pointer
->	O
initial	struct
.	O
element	array
;	O
c1	int
=	O
list1	pointer
->	O
initial	struct
.	O
count	int
;	O
e2	pointer
=	O
list2	pointer
->	O
initial	struct
.	O
element	array
;	O
c2	int
=	O
list2	pointer
->	O
initial	struct
.	O
count	int
;	O
while	O
(	O
c1	int
>	O
0	int
&&	O
c2	int
>	O
0	int
)	O
{	O
struct	O
format_arg	struct
*	O
re	pointer
;	O
grow_initial_alloc	function
(	O
result	pointer
)	O
;	O
re	pointer
=	O
&	O
result	pointer
->	O
initial	struct
.	O
element	array
[	O
result	pointer
->	O
initial	struct
.	O
count	int
]	O
;	O
re	pointer
->	O
repcount	int
=	O
MIN	O
(	O
e1	pointer
->	O
repcount	int
,	O
e2	pointer
->	O
repcount	int
)	O
;	O
if	O
(	O
!	O
make_intersected_element	function
(	O
re	pointer
,	O
e1	pointer
,	O
e2	pointer
)	O
)	O
{	O
if	O
(	O
re	pointer
->	O
presence	enum
==	O
FCT_REQUIRED	int
)	O
result	pointer
=	O
backtrack_in_initial	function
(	O
result	pointer
)	O
;	O
goto	O
done	O
;	O
}	O
result	pointer
->	O
initial	struct
.	O
count	int
++	O
;	O
result	pointer
->	O
initial	struct
.	O
length	int
+=	O
re	pointer
->	O
repcount	int
;	O
e1	pointer
->	O
repcount	int
-=	O
re	pointer
->	O
repcount	int
;	O
if	O
(	O
e1	pointer
->	O
repcount	int
==	O
0	int
)	O
{	O
e1	pointer
++	O
;	O
c1	int
--	O
;	O
}	O
e2	pointer
->	O
repcount	int
-=	O
re	pointer
->	O
repcount	int
;	O
if	O
(	O
e2	pointer
->	O
repcount	int
==	O
0	int
)	O
{	O
e2	pointer
++	O
;	O
c2	int
--	O
;	O
}	O
}	O
if	O
(	O
list1	pointer
->	O
repeated	struct
.	O
count	int
==	O
0	int
&&	O
list2	pointer
->	O
repeated	struct
.	O
count	int
==	O
0	int
)	O
{	O
if	O
(	O
c1	int
>	O
0	int
)	O
{	O
if	O
(	O
e1	pointer
->	O
presence	enum
==	O
FCT_REQUIRED	int
)	O
result	pointer
=	O
backtrack_in_initial	function
(	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
c2	int
>	O
0	int
)	O
{	O
if	O
(	O
e2	pointer
->	O
presence	enum
==	O
FCT_REQUIRED	int
)	O
result	pointer
=	O
backtrack_in_initial	function
(	O
result	pointer
)	O
;	O
}	O
goto	O
done	O
;	O
}	O
else	O
if	O
(	O
list1	pointer
->	O
repeated	struct
.	O
count	int
==	O
0	int
)	O
{	O
ASSERT	O
(	O
c1	int
==	O
0	int
)	O
;	O
if	O
(	O
(	O
c2	int
>	O
0	int
?	O
e2	pointer
->	O
presence	enum
:	O
list2	pointer
->	O
repeated	struct
.	O
element	array
[	O
0	int
]	O
.	O
presence	enum
)	O
==	O
FCT_REQUIRED	int
)	O
result	pointer
=	O
backtrack_in_initial	function
(	O
result	pointer
)	O
;	O
goto	O
done	O
;	O
}	O
else	O
if	O
(	O
list2	pointer
->	O
repeated	struct
.	O
count	int
==	O
0	int
)	O
{	O
ASSERT	O
(	O
c2	int
==	O
0	int
)	O
;	O
if	O
(	O
(	O
c1	int
>	O
0	int
?	O
e1	pointer
->	O
presence	enum
:	O
list1	pointer
->	O
repeated	struct
.	O
element	array
[	O
0	int
]	O
.	O
presence	enum
)	O
==	O
FCT_REQUIRED	int
)	O
result	pointer
=	O
backtrack_in_initial	function
(	O
result	pointer
)	O
;	O
goto	O
done	O
;	O
}	O
ASSERT	O
(	O
c1	int
==	O
0	int
&&	O
c2	int
==	O
0	int
)	O
;	O
}	O
{	O
struct	O
format_arg	struct
*	O
e1	pointer
;	O
struct	O
format_arg	struct
*	O
e2	pointer
;	O
unsigned	O
int	O
c1	int
;	O
unsigned	O
int	O
c2	int
;	O
e1	pointer
=	O
list1	pointer
->	O
repeated	struct
.	O
element	array
;	O
c1	int
=	O
list1	pointer
->	O
repeated	struct
.	O
count	int
;	O
e2	pointer
=	O
list2	pointer
->	O
repeated	struct
.	O
element	array
;	O
c2	int
=	O
list2	pointer
->	O
repeated	struct
.	O
count	int
;	O
while	O
(	O
c1	int
>	O
0	int
&&	O
c2	int
>	O
0	int
)	O
{	O
struct	O
format_arg	struct
*	O
re	pointer
;	O
grow_repeated_alloc	function
(	O
result	pointer
)	O
;	O
re	pointer
=	O
&	O
result	pointer
->	O
repeated	struct
.	O
element	array
[	O
result	pointer
->	O
repeated	struct
.	O
count	int
]	O
;	O
re	pointer
->	O
repcount	int
=	O
MIN	O
(	O
e1	pointer
->	O
repcount	int
,	O
e2	pointer
->	O
repcount	int
)	O
;	O
if	O
(	O
!	O
make_intersected_element	function
(	O
re	pointer
,	O
e1	pointer
,	O
e2	pointer
)	O
)	O
{	O
bool	bool
re_is_required	bool
=	O
re	pointer
->	O
presence	enum
==	O
FCT_REQUIRED	int
;	O
append_repeated_to_initial	function
(	O
result	pointer
)	O
;	O
if	O
(	O
re_is_required	bool
)	O
result	pointer
=	O
backtrack_in_initial	function
(	O
result	pointer
)	O
;	O
goto	O
done	O
;	O
}	O
result	pointer
->	O
repeated	struct
.	O
count	int
++	O
;	O
result	pointer
->	O
repeated	struct
.	O
length	int
+=	O
re	pointer
->	O
repcount	int
;	O
e1	pointer
->	O
repcount	int
-=	O
re	pointer
->	O
repcount	int
;	O
if	O
(	O
e1	pointer
->	O
repcount	int
==	O
0	int
)	O
{	O
e1	pointer
++	O
;	O
c1	int
--	O
;	O
}	O
e2	pointer
->	O
repcount	int
-=	O
re	pointer
->	O
repcount	int
;	O
if	O
(	O
e2	pointer
->	O
repcount	int
==	O
0	int
)	O
{	O
e2	pointer
++	O
;	O
c2	int
--	O
;	O
}	O
}	O
ASSERT	O
(	O
c1	int
==	O
0	int
&&	O
c2	int
==	O
0	int
)	O
;	O
}	O
done	O
:	O
free_list	function
(	O
list1	pointer
)	O
;	O
free_list	function
(	O
list2	pointer
)	O
;	O
if	O
(	O
result	pointer
!=	O
NULL	O
)	O
{	O
normalize_outermost_list	function
(	O
result	pointer
)	O
;	O
VERIFY_LIST	O
(	O
result	pointer
)	O
;	O
}	O
return	O
result	pointer
;	O
}	O
static	O
struct	O
format_arg_list	struct
*	O
make_intersection_with_empty_list	function
(	O
struct	O
format_arg_list	struct
*	O
list	pointer
)	O
{	O
if	O
(	O
list	pointer
->	O
initial	struct
.	O
count	int
>	O
0	int
?	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
0	int
]	O
.	O
presence	enum
==	O
FCT_REQUIRED	int
:	O
list	pointer
->	O
repeated	struct
.	O
count	int
>	O
0	int
&&	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
0	int
]	O
.	O
presence	enum
==	O
FCT_REQUIRED	int
)	O
return	O
NULL	O
;	O
else	O
return	O
make_empty_list	function
(	O
)	O
;	O
}	O
static	O
void	O
make_union_element	function
(	O
struct	O
format_arg	struct
*	O
re	pointer
,	O
const	O
struct	O
format_arg	struct
*	O
e1	pointer
,	O
const	O
struct	O
format_arg	struct
*	O
e2	pointer
)	O
{	O
if	O
(	O
e1	pointer
->	O
presence	enum
==	O
FCT_REQUIRED	int
&&	O
e2	pointer
->	O
presence	enum
==	O
FCT_REQUIRED	int
)	O
re	pointer
->	O
presence	enum
=	O
FCT_REQUIRED	int
;	O
else	O
re	pointer
->	O
presence	enum
=	O
FCT_OPTIONAL	int
;	O
if	O
(	O
e1	pointer
->	O
type	enum
==	O
e2	pointer
->	O
type	enum
)	O
{	O
re	pointer
->	O
type	enum
=	O
e1	pointer
->	O
type	enum
;	O
if	O
(	O
re	pointer
->	O
type	enum
==	O
FAT_LIST	int
)	O
re	pointer
->	O
list	pointer
=	O
make_union_list	function
(	O
copy_list	function
(	O
e1	pointer
->	O
list	pointer
)	O
,	O
copy_list	function
(	O
e2	pointer
->	O
list	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
e1	pointer
->	O
type	enum
==	O
FAT_CHARACTER_INTEGER_NULL	int
&&	O
(	O
e2	pointer
->	O
type	enum
==	O
FAT_CHARACTER_NULL	int
||	O
e2	pointer
->	O
type	enum
==	O
FAT_CHARACTER	int
||	O
e2	pointer
->	O
type	enum
==	O
FAT_INTEGER_NULL	int
||	O
e2	pointer
->	O
type	enum
==	O
FAT_INTEGER	int
)	O
)	O
{	O
re	pointer
->	O
type	enum
=	O
e1	pointer
->	O
type	enum
;	O
}	O
else	O
if	O
(	O
e2	pointer
->	O
type	enum
==	O
FAT_CHARACTER_INTEGER_NULL	int
&&	O
(	O
e1	pointer
->	O
type	enum
==	O
FAT_CHARACTER_NULL	int
||	O
e1	pointer
->	O
type	enum
==	O
FAT_CHARACTER	int
||	O
e1	pointer
->	O
type	enum
==	O
FAT_INTEGER_NULL	int
||	O
e1	pointer
->	O
type	enum
==	O
FAT_INTEGER	int
)	O
)	O
{	O
re	pointer
->	O
type	enum
=	O
e2	pointer
->	O
type	enum
;	O
}	O
else	O
if	O
(	O
e1	pointer
->	O
type	enum
==	O
FAT_CHARACTER_NULL	int
&&	O
e2	pointer
->	O
type	enum
==	O
FAT_CHARACTER	int
)	O
{	O
re	pointer
->	O
type	enum
=	O
e1	pointer
->	O
type	enum
;	O
}	O
else	O
if	O
(	O
e2	pointer
->	O
type	enum
==	O
FAT_CHARACTER_NULL	int
&&	O
e1	pointer
->	O
type	enum
==	O
FAT_CHARACTER	int
)	O
{	O
re	pointer
->	O
type	enum
=	O
e2	pointer
->	O
type	enum
;	O
}	O
else	O
if	O
(	O
e1	pointer
->	O
type	enum
==	O
FAT_INTEGER_NULL	int
&&	O
e2	pointer
->	O
type	enum
==	O
FAT_INTEGER	int
)	O
{	O
re	pointer
->	O
type	enum
=	O
e1	pointer
->	O
type	enum
;	O
}	O
else	O
if	O
(	O
e2	pointer
->	O
type	enum
==	O
FAT_INTEGER_NULL	int
&&	O
e1	pointer
->	O
type	enum
==	O
FAT_INTEGER	int
)	O
{	O
re	pointer
->	O
type	enum
=	O
e2	pointer
->	O
type	enum
;	O
}	O
else	O
if	O
(	O
e1	pointer
->	O
type	enum
==	O
FAT_REAL	int
&&	O
e2	pointer
->	O
type	enum
==	O
FAT_INTEGER	int
)	O
{	O
re	pointer
->	O
type	enum
=	O
e1	pointer
->	O
type	enum
;	O
}	O
else	O
if	O
(	O
e2	pointer
->	O
type	enum
==	O
FAT_REAL	int
&&	O
e1	pointer
->	O
type	enum
==	O
FAT_INTEGER	int
)	O
{	O
re	pointer
->	O
type	enum
=	O
e2	pointer
->	O
type	enum
;	O
}	O
else	O
if	O
(	O
e1	pointer
->	O
type	enum
==	O
FAT_LIST	int
&&	O
is_empty_list	function
(	O
e1	pointer
->	O
list	pointer
)	O
)	O
{	O
if	O
(	O
e2	pointer
->	O
type	enum
==	O
FAT_CHARACTER_INTEGER_NULL	int
||	O
e2	pointer
->	O
type	enum
==	O
FAT_CHARACTER_NULL	int
||	O
e2	pointer
->	O
type	enum
==	O
FAT_INTEGER_NULL	int
)	O
re	pointer
->	O
type	enum
=	O
e2	pointer
->	O
type	enum
;	O
else	O
if	O
(	O
e2	pointer
->	O
type	enum
==	O
FAT_CHARACTER	int
)	O
re	pointer
->	O
type	enum
=	O
FAT_CHARACTER_NULL	int
;	O
else	O
if	O
(	O
e2	pointer
->	O
type	enum
==	O
FAT_INTEGER	int
)	O
re	pointer
->	O
type	enum
=	O
FAT_INTEGER_NULL	int
;	O
else	O
re	pointer
->	O
type	enum
=	O
FAT_OBJECT	int
;	O
}	O
else	O
if	O
(	O
e2	pointer
->	O
type	enum
==	O
FAT_LIST	int
&&	O
is_empty_list	function
(	O
e2	pointer
->	O
list	pointer
)	O
)	O
{	O
if	O
(	O
e1	pointer
->	O
type	enum
==	O
FAT_CHARACTER_INTEGER_NULL	int
||	O
e1	pointer
->	O
type	enum
==	O
FAT_CHARACTER_NULL	int
||	O
e1	pointer
->	O
type	enum
==	O
FAT_INTEGER_NULL	int
)	O
re	pointer
->	O
type	enum
=	O
e1	pointer
->	O
type	enum
;	O
else	O
if	O
(	O
e1	pointer
->	O
type	enum
==	O
FAT_CHARACTER	int
)	O
re	pointer
->	O
type	enum
=	O
FAT_CHARACTER_NULL	int
;	O
else	O
if	O
(	O
e1	pointer
->	O
type	enum
==	O
FAT_INTEGER	int
)	O
re	pointer
->	O
type	enum
=	O
FAT_INTEGER_NULL	int
;	O
else	O
re	pointer
->	O
type	enum
=	O
FAT_OBJECT	int
;	O
}	O
else	O
if	O
(	O
(	O
e1	pointer
->	O
type	enum
==	O
FAT_CHARACTER	int
||	O
e1	pointer
->	O
type	enum
==	O
FAT_CHARACTER_NULL	int
)	O
&&	O
(	O
e2	pointer
->	O
type	enum
==	O
FAT_INTEGER	int
||	O
e2	pointer
->	O
type	enum
==	O
FAT_INTEGER_NULL	int
)	O
)	O
{	O
re	pointer
->	O
type	enum
=	O
FAT_CHARACTER_INTEGER_NULL	int
;	O
}	O
else	O
if	O
(	O
(	O
e2	pointer
->	O
type	enum
==	O
FAT_CHARACTER	int
||	O
e2	pointer
->	O
type	enum
==	O
FAT_CHARACTER_NULL	int
)	O
&&	O
(	O
e1	pointer
->	O
type	enum
==	O
FAT_INTEGER	int
||	O
e1	pointer
->	O
type	enum
==	O
FAT_INTEGER_NULL	int
)	O
)	O
{	O
re	pointer
->	O
type	enum
=	O
FAT_CHARACTER_INTEGER_NULL	int
;	O
}	O
else	O
{	O
re	pointer
->	O
type	enum
=	O
FAT_OBJECT	int
;	O
}	O
}	O
static	O
struct	O
format_arg_list	struct
*	O
make_union_list	function
(	O
struct	O
format_arg_list	struct
*	O
list1	pointer
,	O
struct	O
format_arg_list	struct
*	O
list2	pointer
)	O
{	O
struct	O
format_arg_list	struct
*	O
result	pointer
;	O
VERIFY_LIST	O
(	O
list1	pointer
)	O
;	O
VERIFY_LIST	O
(	O
list2	pointer
)	O
;	O
if	O
(	O
list1	pointer
->	O
repeated	struct
.	O
length	int
>	O
0	int
&&	O
list2	pointer
->	O
repeated	struct
.	O
length	int
>	O
0	int
)	O
{	O
{	O
unsigned	O
int	O
n1	int
=	O
list1	pointer
->	O
repeated	struct
.	O
length	int
;	O
unsigned	O
int	O
n2	int
=	O
list2	pointer
->	O
repeated	struct
.	O
length	int
;	O
unsigned	O
int	O
g	int
=	O
gcd	function
(	O
n1	int
,	O
n2	int
)	O
;	O
unsigned	O
int	O
m1	int
=	O
n2	int
/	O
g	int
;	O
unsigned	O
int	O
m2	int
=	O
n1	int
/	O
g	int
;	O
unfold_loop	function
(	O
list1	pointer
,	O
m1	int
)	O
;	O
unfold_loop	function
(	O
list2	pointer
,	O
m2	int
)	O
;	O
}	O
{	O
unsigned	O
int	O
m	int
=	O
MAX	O
(	O
list1	pointer
->	O
initial	struct
.	O
length	int
,	O
list2	pointer
->	O
initial	struct
.	O
length	int
)	O
;	O
rotate_loop	function
(	O
list1	pointer
,	O
m	int
)	O
;	O
rotate_loop	function
(	O
list2	pointer
,	O
m	int
)	O
;	O
}	O
ASSERT	O
(	O
list1	pointer
->	O
initial	struct
.	O
length	int
==	O
list2	pointer
->	O
initial	struct
.	O
length	int
)	O
;	O
ASSERT	O
(	O
list1	pointer
->	O
repeated	struct
.	O
length	int
==	O
list2	pointer
->	O
repeated	struct
.	O
length	int
)	O
;	O
}	O
else	O
if	O
(	O
list1	pointer
->	O
repeated	struct
.	O
length	int
>	O
0	int
)	O
{	O
if	O
(	O
list2	pointer
->	O
initial	struct
.	O
length	int
>=	O
list1	pointer
->	O
initial	struct
.	O
length	int
)	O
{	O
rotate_loop	function
(	O
list1	pointer
,	O
list2	pointer
->	O
initial	struct
.	O
length	int
)	O
;	O
if	O
(	O
list1	pointer
->	O
repeated	struct
.	O
element	array
[	O
0	int
]	O
.	O
presence	enum
==	O
FCT_REQUIRED	int
)	O
rotate_loop	function
(	O
list1	pointer
,	O
list1	pointer
->	O
initial	struct
.	O
length	int
+	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
list2	pointer
->	O
repeated	struct
.	O
length	int
>	O
0	int
)	O
{	O
if	O
(	O
list1	pointer
->	O
initial	struct
.	O
length	int
>=	O
list2	pointer
->	O
initial	struct
.	O
length	int
)	O
{	O
rotate_loop	function
(	O
list2	pointer
,	O
list1	pointer
->	O
initial	struct
.	O
length	int
)	O
;	O
if	O
(	O
list2	pointer
->	O
repeated	struct
.	O
element	array
[	O
0	int
]	O
.	O
presence	enum
==	O
FCT_REQUIRED	int
)	O
rotate_loop	function
(	O
list2	pointer
,	O
list2	pointer
->	O
initial	struct
.	O
length	int
+	O
1	int
)	O
;	O
}	O
}	O
result	pointer
=	O
XMALLOC	O
(	O
struct	O
format_arg_list	struct
)	O
;	O
result	pointer
->	O
initial	struct
.	O
count	int
=	O
0	int
;	O
result	pointer
->	O
initial	struct
.	O
allocated	int
=	O
0	int
;	O
result	pointer
->	O
initial	struct
.	O
element	array
=	O
NULL	O
;	O
result	pointer
->	O
initial	struct
.	O
length	int
=	O
0	int
;	O
result	pointer
->	O
repeated	struct
.	O
count	int
=	O
0	int
;	O
result	pointer
->	O
repeated	struct
.	O
allocated	int
=	O
0	int
;	O
result	pointer
->	O
repeated	struct
.	O
element	array
=	O
NULL	O
;	O
result	pointer
->	O
repeated	struct
.	O
length	int
=	O
0	int
;	O
{	O
struct	O
format_arg	struct
*	O
e1	pointer
;	O
struct	O
format_arg	struct
*	O
e2	pointer
;	O
unsigned	O
int	O
c1	int
;	O
unsigned	O
int	O
c2	int
;	O
e1	pointer
=	O
list1	pointer
->	O
initial	struct
.	O
element	array
;	O
c1	int
=	O
list1	pointer
->	O
initial	struct
.	O
count	int
;	O
e2	pointer
=	O
list2	pointer
->	O
initial	struct
.	O
element	array
;	O
c2	int
=	O
list2	pointer
->	O
initial	struct
.	O
count	int
;	O
while	O
(	O
c1	int
>	O
0	int
&&	O
c2	int
>	O
0	int
)	O
{	O
struct	O
format_arg	struct
*	O
re	pointer
;	O
grow_initial_alloc	function
(	O
result	pointer
)	O
;	O
re	pointer
=	O
&	O
result	pointer
->	O
initial	struct
.	O
element	array
[	O
result	pointer
->	O
initial	struct
.	O
count	int
]	O
;	O
re	pointer
->	O
repcount	int
=	O
MIN	O
(	O
e1	pointer
->	O
repcount	int
,	O
e2	pointer
->	O
repcount	int
)	O
;	O
make_union_element	function
(	O
re	pointer
,	O
e1	pointer
,	O
e2	pointer
)	O
;	O
result	pointer
->	O
initial	struct
.	O
count	int
++	O
;	O
result	pointer
->	O
initial	struct
.	O
length	int
+=	O
re	pointer
->	O
repcount	int
;	O
e1	pointer
->	O
repcount	int
-=	O
re	pointer
->	O
repcount	int
;	O
if	O
(	O
e1	pointer
->	O
repcount	int
==	O
0	int
)	O
{	O
e1	pointer
++	O
;	O
c1	int
--	O
;	O
}	O
e2	pointer
->	O
repcount	int
-=	O
re	pointer
->	O
repcount	int
;	O
if	O
(	O
e2	pointer
->	O
repcount	int
==	O
0	int
)	O
{	O
e2	pointer
++	O
;	O
c2	int
--	O
;	O
}	O
}	O
if	O
(	O
c1	int
>	O
0	int
)	O
{	O
ASSERT	O
(	O
list2	pointer
->	O
repeated	struct
.	O
count	int
==	O
0	int
)	O
;	O
if	O
(	O
e1	pointer
->	O
presence	enum
==	O
FCT_REQUIRED	int
)	O
{	O
struct	O
format_arg	struct
*	O
re	pointer
;	O
grow_initial_alloc	function
(	O
result	pointer
)	O
;	O
re	pointer
=	O
&	O
result	pointer
->	O
initial	struct
.	O
element	array
[	O
result	pointer
->	O
initial	struct
.	O
count	int
]	O
;	O
copy_element	function
(	O
re	pointer
,	O
e1	pointer
)	O
;	O
re	pointer
->	O
presence	enum
=	O
FCT_OPTIONAL	int
;	O
re	pointer
->	O
repcount	int
=	O
1	int
;	O
result	pointer
->	O
initial	struct
.	O
count	int
++	O
;	O
result	pointer
->	O
initial	struct
.	O
length	int
+=	O
1	int
;	O
e1	pointer
->	O
repcount	int
-=	O
1	int
;	O
if	O
(	O
e1	pointer
->	O
repcount	int
==	O
0	int
)	O
{	O
e1	pointer
++	O
;	O
c1	int
--	O
;	O
}	O
}	O
ensure_initial_alloc	function
(	O
result	pointer
,	O
result	pointer
->	O
initial	struct
.	O
count	int
+	O
c1	int
)	O
;	O
while	O
(	O
c1	int
>	O
0	int
)	O
{	O
struct	O
format_arg	struct
*	O
re	pointer
;	O
re	pointer
=	O
&	O
result	pointer
->	O
initial	struct
.	O
element	array
[	O
result	pointer
->	O
initial	struct
.	O
count	int
]	O
;	O
copy_element	function
(	O
re	pointer
,	O
e1	pointer
)	O
;	O
result	pointer
->	O
initial	struct
.	O
count	int
++	O
;	O
result	pointer
->	O
initial	struct
.	O
length	int
+=	O
re	pointer
->	O
repcount	int
;	O
e1	pointer
++	O
;	O
c1	int
--	O
;	O
}	O
}	O
else	O
if	O
(	O
c2	int
>	O
0	int
)	O
{	O
ASSERT	O
(	O
list1	pointer
->	O
repeated	struct
.	O
count	int
==	O
0	int
)	O
;	O
if	O
(	O
e2	pointer
->	O
presence	enum
==	O
FCT_REQUIRED	int
)	O
{	O
struct	O
format_arg	struct
*	O
re	pointer
;	O
grow_initial_alloc	function
(	O
result	pointer
)	O
;	O
re	pointer
=	O
&	O
result	pointer
->	O
initial	struct
.	O
element	array
[	O
result	pointer
->	O
initial	struct
.	O
count	int
]	O
;	O
copy_element	function
(	O
re	pointer
,	O
e2	pointer
)	O
;	O
re	pointer
->	O
presence	enum
=	O
FCT_OPTIONAL	int
;	O
re	pointer
->	O
repcount	int
=	O
1	int
;	O
result	pointer
->	O
initial	struct
.	O
count	int
++	O
;	O
result	pointer
->	O
initial	struct
.	O
length	int
+=	O
1	int
;	O
e2	pointer
->	O
repcount	int
-=	O
1	int
;	O
if	O
(	O
e2	pointer
->	O
repcount	int
==	O
0	int
)	O
{	O
e2	pointer
++	O
;	O
c2	int
--	O
;	O
}	O
}	O
ensure_initial_alloc	function
(	O
result	pointer
,	O
result	pointer
->	O
initial	struct
.	O
count	int
+	O
c2	int
)	O
;	O
while	O
(	O
c2	int
>	O
0	int
)	O
{	O
struct	O
format_arg	struct
*	O
re	pointer
;	O
re	pointer
=	O
&	O
result	pointer
->	O
initial	struct
.	O
element	array
[	O
result	pointer
->	O
initial	struct
.	O
count	int
]	O
;	O
copy_element	function
(	O
re	pointer
,	O
e2	pointer
)	O
;	O
result	pointer
->	O
initial	struct
.	O
count	int
++	O
;	O
result	pointer
->	O
initial	struct
.	O
length	int
+=	O
re	pointer
->	O
repcount	int
;	O
e2	pointer
++	O
;	O
c2	int
--	O
;	O
}	O
}	O
ASSERT	O
(	O
c1	int
==	O
0	int
&&	O
c2	int
==	O
0	int
)	O
;	O
}	O
if	O
(	O
list1	pointer
->	O
repeated	struct
.	O
length	int
>	O
0	int
&&	O
list2	pointer
->	O
repeated	struct
.	O
length	int
>	O
0	int
)	O
{	O
struct	O
format_arg	struct
*	O
e1	pointer
;	O
struct	O
format_arg	struct
*	O
e2	pointer
;	O
unsigned	O
int	O
c1	int
;	O
unsigned	O
int	O
c2	int
;	O
e1	pointer
=	O
list1	pointer
->	O
repeated	struct
.	O
element	array
;	O
c1	int
=	O
list1	pointer
->	O
repeated	struct
.	O
count	int
;	O
e2	pointer
=	O
list2	pointer
->	O
repeated	struct
.	O
element	array
;	O
c2	int
=	O
list2	pointer
->	O
repeated	struct
.	O
count	int
;	O
while	O
(	O
c1	int
>	O
0	int
&&	O
c2	int
>	O
0	int
)	O
{	O
struct	O
format_arg	struct
*	O
re	pointer
;	O
grow_repeated_alloc	function
(	O
result	pointer
)	O
;	O
re	pointer
=	O
&	O
result	pointer
->	O
repeated	struct
.	O
element	array
[	O
result	pointer
->	O
repeated	struct
.	O
count	int
]	O
;	O
re	pointer
->	O
repcount	int
=	O
MIN	O
(	O
e1	pointer
->	O
repcount	int
,	O
e2	pointer
->	O
repcount	int
)	O
;	O
make_union_element	function
(	O
re	pointer
,	O
e1	pointer
,	O
e2	pointer
)	O
;	O
result	pointer
->	O
repeated	struct
.	O
count	int
++	O
;	O
result	pointer
->	O
repeated	struct
.	O
length	int
+=	O
re	pointer
->	O
repcount	int
;	O
e1	pointer
->	O
repcount	int
-=	O
re	pointer
->	O
repcount	int
;	O
if	O
(	O
e1	pointer
->	O
repcount	int
==	O
0	int
)	O
{	O
e1	pointer
++	O
;	O
c1	int
--	O
;	O
}	O
e2	pointer
->	O
repcount	int
-=	O
re	pointer
->	O
repcount	int
;	O
if	O
(	O
e2	pointer
->	O
repcount	int
==	O
0	int
)	O
{	O
e2	pointer
++	O
;	O
c2	int
--	O
;	O
}	O
}	O
ASSERT	O
(	O
c1	int
==	O
0	int
&&	O
c2	int
==	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
list1	pointer
->	O
repeated	struct
.	O
length	int
>	O
0	int
)	O
{	O
unsigned	O
int	O
i	long
;	O
result	pointer
->	O
repeated	struct
.	O
count	int
=	O
list1	pointer
->	O
repeated	struct
.	O
count	int
;	O
result	pointer
->	O
repeated	struct
.	O
allocated	int
=	O
result	pointer
->	O
repeated	struct
.	O
count	int
;	O
result	pointer
->	O
repeated	struct
.	O
element	array
=	O
XNMALLOC	O
(	O
result	pointer
->	O
repeated	struct
.	O
allocated	int
,	O
struct	O
format_arg	struct
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
list1	pointer
->	O
repeated	struct
.	O
count	int
;	O
i	long
++	O
)	O
copy_element	function
(	O
&	O
result	pointer
->	O
repeated	struct
.	O
element	array
[	O
i	long
]	O
,	O
&	O
list1	pointer
->	O
repeated	struct
.	O
element	array
[	O
i	long
]	O
)	O
;	O
result	pointer
->	O
repeated	struct
.	O
length	int
=	O
list1	pointer
->	O
repeated	struct
.	O
length	int
;	O
}	O
else	O
if	O
(	O
list2	pointer
->	O
repeated	struct
.	O
length	int
>	O
0	int
)	O
{	O
unsigned	O
int	O
i	long
;	O
result	pointer
->	O
repeated	struct
.	O
count	int
=	O
list2	pointer
->	O
repeated	struct
.	O
count	int
;	O
result	pointer
->	O
repeated	struct
.	O
allocated	int
=	O
result	pointer
->	O
repeated	struct
.	O
count	int
;	O
result	pointer
->	O
repeated	struct
.	O
element	array
=	O
XNMALLOC	O
(	O
result	pointer
->	O
repeated	struct
.	O
allocated	int
,	O
struct	O
format_arg	struct
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
list2	pointer
->	O
repeated	struct
.	O
count	int
;	O
i	long
++	O
)	O
copy_element	function
(	O
&	O
result	pointer
->	O
repeated	struct
.	O
element	array
[	O
i	long
]	O
,	O
&	O
list2	pointer
->	O
repeated	struct
.	O
element	array
[	O
i	long
]	O
)	O
;	O
result	pointer
->	O
repeated	struct
.	O
length	int
=	O
list2	pointer
->	O
repeated	struct
.	O
length	int
;	O
}	O
free_list	function
(	O
list1	pointer
)	O
;	O
free_list	function
(	O
list2	pointer
)	O
;	O
normalize_outermost_list	function
(	O
result	pointer
)	O
;	O
VERIFY_LIST	O
(	O
result	pointer
)	O
;	O
return	O
result	pointer
;	O
}	O
static	O
struct	O
format_arg_list	struct
*	O
make_union_with_empty_list	function
(	O
struct	O
format_arg_list	struct
*	O
list	pointer
)	O
{	O
VERIFY_LIST	O
(	O
list	pointer
)	O
;	O
if	O
(	O
list	pointer
->	O
initial	struct
.	O
count	int
>	O
0	int
?	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
0	int
]	O
.	O
presence	enum
==	O
FCT_REQUIRED	int
:	O
list	pointer
->	O
repeated	struct
.	O
count	int
>	O
0	int
&&	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
0	int
]	O
.	O
presence	enum
==	O
FCT_REQUIRED	int
)	O
{	O
initial_splitelement	function
(	O
list	pointer
,	O
1	int
)	O
;	O
ASSERT	O
(	O
list	pointer
->	O
initial	struct
.	O
count	int
>	O
0	int
)	O
;	O
ASSERT	O
(	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
0	int
]	O
.	O
repcount	int
==	O
1	int
)	O
;	O
ASSERT	O
(	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
0	int
]	O
.	O
presence	enum
==	O
FCT_REQUIRED	int
)	O
;	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
0	int
]	O
.	O
presence	enum
=	O
FCT_OPTIONAL	int
;	O
normalize_outermost_list	function
(	O
list	pointer
)	O
;	O
}	O
VERIFY_LIST	O
(	O
list	pointer
)	O
;	O
return	O
list	pointer
;	O
}	O
static	O
struct	O
format_arg_list	struct
*	O
union	O
(	O
struct	O
format_arg_list	struct
*	O
list1	pointer
,	O
struct	O
format_arg_list	struct
*	O
list2	pointer
)	O
{	O
if	O
(	O
list1	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
list2	pointer
!=	O
NULL	O
)	O
return	O
make_union_list	function
(	O
list1	pointer
,	O
list2	pointer
)	O
;	O
else	O
return	O
list1	pointer
;	O
}	O
else	O
{	O
if	O
(	O
list2	pointer
!=	O
NULL	O
)	O
return	O
list2	pointer
;	O
else	O
return	O
NULL	O
;	O
}	O
}	O
static	O
bool	bool
is_required	function
(	O
const	O
struct	O
format_arg_list	struct
*	O
list	pointer
,	O
unsigned	O
int	O
n	long
)	O
{	O
unsigned	O
int	O
s	pointer
;	O
unsigned	O
int	O
t	int
;	O
t	int
=	O
n	long
+	O
1	int
;	O
for	O
(	O
s	pointer
=	O
0	int
;	O
s	pointer
<	O
list	pointer
->	O
initial	struct
.	O
count	int
&&	O
t	int
>=	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
]	O
.	O
repcount	int
;	O
t	int
-=	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
]	O
.	O
repcount	int
,	O
s	pointer
++	O
)	O
if	O
(	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
]	O
.	O
presence	enum
!=	O
FCT_REQUIRED	int
)	O
return	O
false	int
;	O
if	O
(	O
t	int
==	O
0	int
)	O
return	O
true	int
;	O
if	O
(	O
s	pointer
<	O
list	pointer
->	O
initial	struct
.	O
count	int
)	O
{	O
if	O
(	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
]	O
.	O
presence	enum
!=	O
FCT_REQUIRED	int
)	O
return	O
false	int
;	O
else	O
return	O
true	int
;	O
}	O
if	O
(	O
list	pointer
->	O
repeated	struct
.	O
count	int
==	O
0	int
)	O
return	O
false	int
;	O
for	O
(	O
s	pointer
=	O
0	int
;	O
s	pointer
<	O
list	pointer
->	O
repeated	struct
.	O
count	int
&&	O
t	int
>=	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
s	pointer
]	O
.	O
repcount	int
;	O
t	int
-=	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
s	pointer
]	O
.	O
repcount	int
,	O
s	pointer
++	O
)	O
if	O
(	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
s	pointer
]	O
.	O
presence	enum
!=	O
FCT_REQUIRED	int
)	O
return	O
false	int
;	O
if	O
(	O
t	int
==	O
0	int
)	O
return	O
true	int
;	O
if	O
(	O
s	pointer
<	O
list	pointer
->	O
repeated	struct
.	O
count	int
)	O
{	O
if	O
(	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
s	pointer
]	O
.	O
presence	enum
!=	O
FCT_REQUIRED	int
)	O
return	O
false	int
;	O
else	O
return	O
true	int
;	O
}	O
return	O
true	int
;	O
}	O
static	O
struct	O
format_arg_list	struct
*	O
add_required_constraint	function
(	O
struct	O
format_arg_list	struct
*	O
list	pointer
,	O
unsigned	O
int	O
n	long
)	O
{	O
unsigned	O
int	O
i	long
,	O
rest	int
;	O
if	O
(	O
list	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
VERIFY_LIST	O
(	O
list	pointer
)	O
;	O
if	O
(	O
list	pointer
->	O
repeated	struct
.	O
count	int
==	O
0	int
&&	O
list	pointer
->	O
initial	struct
.	O
length	int
<=	O
n	long
)	O
{	O
free_list	function
(	O
list	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
initial_splitelement	function
(	O
list	pointer
,	O
n	long
+	O
1	int
)	O
;	O
for	O
(	O
i	long
=	O
0	int
,	O
rest	int
=	O
n	long
+	O
1	int
;	O
rest	int
>	O
0	int
;	O
)	O
{	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
.	O
presence	enum
=	O
FCT_REQUIRED	int
;	O
rest	int
-=	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
.	O
repcount	int
;	O
i	long
++	O
;	O
}	O
VERIFY_LIST	O
(	O
list	pointer
)	O
;	O
return	O
list	pointer
;	O
}	O
static	O
struct	O
format_arg_list	struct
*	O
add_end_constraint	function
(	O
struct	O
format_arg_list	struct
*	O
list	pointer
,	O
unsigned	O
int	O
n	long
)	O
{	O
unsigned	O
int	O
s	pointer
,	O
i	long
;	O
enum	O
format_cdr_type	enum
n_presence	enum
;	O
if	O
(	O
list	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
VERIFY_LIST	O
(	O
list	pointer
)	O
;	O
if	O
(	O
list	pointer
->	O
repeated	struct
.	O
count	int
==	O
0	int
&&	O
list	pointer
->	O
initial	struct
.	O
length	int
<=	O
n	long
)	O
return	O
list	pointer
;	O
s	pointer
=	O
initial_splitelement	function
(	O
list	pointer
,	O
n	long
)	O
;	O
n_presence	enum
=	O
(	O
s	pointer
<	O
list	pointer
->	O
initial	struct
.	O
count	int
?	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
]	O
.	O
presence	enum
:	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
0	int
]	O
.	O
presence	enum
)	O
;	O
for	O
(	O
i	long
=	O
s	pointer
;	O
i	long
<	O
list	pointer
->	O
initial	struct
.	O
count	int
;	O
i	long
++	O
)	O
{	O
list	pointer
->	O
initial	struct
.	O
length	int
-=	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
.	O
repcount	int
;	O
free_element	function
(	O
&	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
)	O
;	O
}	O
list	pointer
->	O
initial	struct
.	O
count	int
=	O
s	pointer
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
list	pointer
->	O
repeated	struct
.	O
count	int
;	O
i	long
++	O
)	O
free_element	function
(	O
&	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
i	long
]	O
)	O
;	O
if	O
(	O
list	pointer
->	O
repeated	struct
.	O
element	array
!=	O
NULL	O
)	O
free	function
(	O
list	pointer
->	O
repeated	struct
.	O
element	array
)	O
;	O
list	pointer
->	O
repeated	struct
.	O
element	array
=	O
NULL	O
;	O
list	pointer
->	O
repeated	struct
.	O
allocated	int
=	O
0	int
;	O
list	pointer
->	O
repeated	struct
.	O
count	int
=	O
0	int
;	O
list	pointer
->	O
repeated	struct
.	O
length	int
=	O
0	int
;	O
if	O
(	O
n_presence	enum
==	O
FCT_REQUIRED	int
)	O
return	O
backtrack_in_initial	function
(	O
list	pointer
)	O
;	O
else	O
return	O
list	pointer
;	O
}	O
static	O
struct	O
format_arg_list	struct
*	O
add_type_constraint	function
(	O
struct	O
format_arg_list	struct
*	O
list	pointer
,	O
unsigned	O
int	O
n	long
,	O
enum	O
format_arg_type	enum
type	enum
)	O
{	O
unsigned	O
int	O
s	pointer
;	O
struct	O
format_arg	struct
newconstraint	struct
;	O
struct	O
format_arg	struct
tmpelement	struct
;	O
if	O
(	O
list	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
s	pointer
=	O
initial_unshare	function
(	O
list	pointer
,	O
n	long
)	O
;	O
newconstraint	struct
.	O
presence	enum
=	O
FCT_OPTIONAL	int
;	O
newconstraint	struct
.	O
type	enum
=	O
type	enum
;	O
if	O
(	O
!	O
make_intersected_element	function
(	O
&	O
tmpelement	struct
,	O
&	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
]	O
,	O
&	O
newconstraint	struct
)	O
)	O
return	O
add_end_constraint	function
(	O
list	pointer
,	O
n	long
)	O
;	O
free_element	function
(	O
&	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
]	O
)	O
;	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
]	O
.	O
type	enum
=	O
tmpelement	struct
.	O
type	enum
;	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
]	O
.	O
list	pointer
=	O
tmpelement	struct
.	O
list	pointer
;	O
VERIFY_LIST	O
(	O
list	pointer
)	O
;	O
return	O
list	pointer
;	O
}	O
static	O
struct	O
format_arg_list	struct
*	O
add_listtype_constraint	function
(	O
struct	O
format_arg_list	struct
*	O
list	pointer
,	O
unsigned	O
int	O
n	long
,	O
enum	O
format_arg_type	enum
type	enum
,	O
struct	O
format_arg_list	struct
*	O
sublist	pointer
)	O
{	O
unsigned	O
int	O
s	pointer
;	O
struct	O
format_arg	struct
newconstraint	struct
;	O
struct	O
format_arg	struct
tmpelement	struct
;	O
if	O
(	O
list	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
s	pointer
=	O
initial_unshare	function
(	O
list	pointer
,	O
n	long
)	O
;	O
newconstraint	struct
.	O
presence	enum
=	O
FCT_OPTIONAL	int
;	O
newconstraint	struct
.	O
type	enum
=	O
type	enum
;	O
newconstraint	struct
.	O
list	pointer
=	O
sublist	pointer
;	O
if	O
(	O
!	O
make_intersected_element	function
(	O
&	O
tmpelement	struct
,	O
&	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
]	O
,	O
&	O
newconstraint	struct
)	O
)	O
return	O
add_end_constraint	function
(	O
list	pointer
,	O
n	long
)	O
;	O
free_element	function
(	O
&	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
]	O
)	O
;	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
]	O
.	O
type	enum
=	O
tmpelement	struct
.	O
type	enum
;	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
s	pointer
]	O
.	O
list	pointer
=	O
tmpelement	struct
.	O
list	pointer
;	O
VERIFY_LIST	O
(	O
list	pointer
)	O
;	O
return	O
list	pointer
;	O
}	O
static	O
void	O
add_req_type_constraint	function
(	O
struct	O
format_arg_list	struct
*	O
*	O
listp	pointer
,	O
unsigned	O
int	O
position	int
,	O
enum	O
format_arg_type	enum
type	enum
)	O
{	O
*	O
listp	pointer
=	O
add_required_constraint	function
(	O
*	O
listp	pointer
,	O
position	int
)	O
;	O
*	O
listp	pointer
=	O
add_type_constraint	function
(	O
*	O
listp	pointer
,	O
position	int
,	O
type	enum
)	O
;	O
}	O
static	O
void	O
add_req_listtype_constraint	function
(	O
struct	O
format_arg_list	struct
*	O
*	O
listp	pointer
,	O
unsigned	O
int	O
position	int
,	O
enum	O
format_arg_type	enum
type	enum
,	O
struct	O
format_arg_list	struct
*	O
sublist	pointer
)	O
{	O
*	O
listp	pointer
=	O
add_required_constraint	function
(	O
*	O
listp	pointer
,	O
position	int
)	O
;	O
*	O
listp	pointer
=	O
add_listtype_constraint	function
(	O
*	O
listp	pointer
,	O
position	int
,	O
type	enum
,	O
sublist	pointer
)	O
;	O
}	O
static	O
struct	O
format_arg_list	struct
*	O
make_repeated_list_of_lists	function
(	O
struct	O
format_arg_list	struct
*	O
sublist	pointer
)	O
{	O
if	O
(	O
sublist	pointer
==	O
NULL	O
)	O
return	O
make_empty_list	function
(	O
)	O
;	O
else	O
{	O
struct	O
format_arg_list	struct
*	O
listlist	pointer
;	O
listlist	pointer
=	O
XMALLOC	O
(	O
struct	O
format_arg_list	struct
)	O
;	O
listlist	pointer
->	O
initial	struct
.	O
count	int
=	O
0	int
;	O
listlist	pointer
->	O
initial	struct
.	O
allocated	int
=	O
0	int
;	O
listlist	pointer
->	O
initial	struct
.	O
element	array
=	O
NULL	O
;	O
listlist	pointer
->	O
initial	struct
.	O
length	int
=	O
0	int
;	O
listlist	pointer
->	O
repeated	struct
.	O
count	int
=	O
1	int
;	O
listlist	pointer
->	O
repeated	struct
.	O
allocated	int
=	O
1	int
;	O
listlist	pointer
->	O
repeated	struct
.	O
element	array
=	O
XNMALLOC	O
(	O
1	int
,	O
struct	O
format_arg	struct
)	O
;	O
listlist	pointer
->	O
repeated	struct
.	O
element	array
[	O
0	int
]	O
.	O
repcount	int
=	O
1	int
;	O
listlist	pointer
->	O
repeated	struct
.	O
element	array
[	O
0	int
]	O
.	O
presence	enum
=	O
FCT_OPTIONAL	int
;	O
listlist	pointer
->	O
repeated	struct
.	O
element	array
[	O
0	int
]	O
.	O
type	enum
=	O
FAT_LIST	int
;	O
listlist	pointer
->	O
repeated	struct
.	O
element	array
[	O
0	int
]	O
.	O
list	pointer
=	O
sublist	pointer
;	O
listlist	pointer
->	O
repeated	struct
.	O
length	int
=	O
1	int
;	O
VERIFY_LIST	O
(	O
listlist	pointer
)	O
;	O
return	O
listlist	pointer
;	O
}	O
}	O
static	O
struct	O
format_arg_list	struct
*	O
make_repeated_list	function
(	O
struct	O
format_arg_list	struct
*	O
sublist	pointer
,	O
unsigned	O
int	O
period	int
)	O
{	O
struct	O
segment	struct
tmp	pointer
;	O
struct	O
segment	struct
*	O
srcseg	pointer
;	O
struct	O
format_arg_list	struct
*	O
list	pointer
;	O
unsigned	O
int	O
p	pointer
,	O
n	long
,	O
i	long
,	O
si	int
,	O
ti	int
,	O
j	long
,	O
sj	int
,	O
tj	int
,	O
splitindex	int
,	O
newcount	int
;	O
bool	bool
ended	bool
;	O
VERIFY_LIST	O
(	O
sublist	pointer
)	O
;	O
ASSERT	O
(	O
period	int
>	O
0	int
)	O
;	O
if	O
(	O
sublist	pointer
->	O
repeated	struct
.	O
count	int
==	O
0	int
)	O
{	O
if	O
(	O
sublist	pointer
->	O
initial	struct
.	O
length	int
<	O
period	int
)	O
return	O
make_union_with_empty_list	function
(	O
sublist	pointer
)	O
;	O
srcseg	pointer
=	O
&	O
sublist	pointer
->	O
initial	struct
;	O
p	pointer
=	O
period	int
;	O
}	O
else	O
{	O
unsigned	O
int	O
Lp	int
=	O
sublist	pointer
->	O
repeated	struct
.	O
length	int
;	O
unsigned	O
int	O
m	int
=	O
period	int
/	O
gcd	function
(	O
period	int
,	O
Lp	int
)	O
;	O
unfold_loop	function
(	O
sublist	pointer
,	O
m	int
)	O
;	O
p	pointer
=	O
m	int
*	O
Lp	int
;	O
tmp	pointer
.	O
count	int
=	O
sublist	pointer
->	O
initial	struct
.	O
count	int
+	O
sublist	pointer
->	O
repeated	struct
.	O
count	int
;	O
tmp	pointer
.	O
allocated	int
=	O
tmp	pointer
.	O
count	int
;	O
tmp	pointer
.	O
element	array
=	O
XNMALLOC	O
(	O
tmp	pointer
.	O
allocated	int
,	O
struct	O
format_arg	struct
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
sublist	pointer
->	O
initial	struct
.	O
count	int
;	O
i	long
++	O
)	O
tmp	pointer
.	O
element	array
[	O
i	long
]	O
=	O
sublist	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
sublist	pointer
->	O
repeated	struct
.	O
count	int
;	O
i	long
++	O
,	O
j	long
++	O
)	O
tmp	pointer
.	O
element	array
[	O
i	long
]	O
=	O
sublist	pointer
->	O
initial	struct
.	O
element	array
[	O
j	long
]	O
;	O
tmp	pointer
.	O
length	int
=	O
sublist	pointer
->	O
initial	struct
.	O
length	int
+	O
sublist	pointer
->	O
repeated	struct
.	O
length	int
;	O
srcseg	pointer
=	O
&	O
tmp	pointer
;	O
}	O
n	long
=	O
srcseg	pointer
->	O
length	int
;	O
list	pointer
=	O
XMALLOC	O
(	O
struct	O
format_arg_list	struct
)	O
;	O
list	pointer
->	O
initial	struct
.	O
count	int
=	O
0	int
;	O
list	pointer
->	O
initial	struct
.	O
allocated	int
=	O
0	int
;	O
list	pointer
->	O
initial	struct
.	O
element	array
=	O
NULL	O
;	O
list	pointer
->	O
initial	struct
.	O
length	int
=	O
0	int
;	O
list	pointer
->	O
repeated	struct
.	O
count	int
=	O
0	int
;	O
list	pointer
->	O
repeated	struct
.	O
allocated	int
=	O
0	int
;	O
list	pointer
->	O
repeated	struct
.	O
element	array
=	O
NULL	O
;	O
list	pointer
->	O
repeated	struct
.	O
length	int
=	O
0	int
;	O
ended	bool
=	O
false	int
;	O
i	long
=	O
0	int
,	O
ti	int
=	O
0	int
,	O
si	int
=	O
0	int
;	O
while	O
(	O
i	long
<	O
p	pointer
)	O
{	O
unsigned	O
int	O
k	int
=	O
MIN	O
(	O
srcseg	pointer
->	O
element	array
[	O
si	int
]	O
.	O
repcount	int
-	O
ti	int
,	O
p	pointer
-	O
i	long
)	O
;	O
grow_initial_alloc	function
(	O
list	pointer
)	O
;	O
copy_element	function
(	O
&	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
list	pointer
->	O
initial	struct
.	O
count	int
]	O
,	O
&	O
srcseg	pointer
->	O
element	array
[	O
si	int
]	O
)	O
;	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
list	pointer
->	O
initial	struct
.	O
count	int
]	O
.	O
repcount	int
=	O
k	int
;	O
list	pointer
->	O
initial	struct
.	O
count	int
++	O
;	O
list	pointer
->	O
initial	struct
.	O
length	int
+=	O
k	int
;	O
i	long
+=	O
k	int
;	O
ti	int
+=	O
k	int
;	O
if	O
(	O
ti	int
==	O
srcseg	pointer
->	O
element	array
[	O
si	int
]	O
.	O
repcount	int
)	O
{	O
ti	int
=	O
0	int
;	O
si	int
++	O
;	O
}	O
}	O
ASSERT	O
(	O
list	pointer
->	O
initial	struct
.	O
count	int
>	O
0	int
)	O
;	O
if	O
(	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
0	int
]	O
.	O
presence	enum
==	O
FCT_REQUIRED	int
)	O
{	O
initial_splitelement	function
(	O
list	pointer
,	O
1	int
)	O
;	O
ASSERT	O
(	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
0	int
]	O
.	O
presence	enum
==	O
FCT_REQUIRED	int
)	O
;	O
ASSERT	O
(	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
0	int
]	O
.	O
repcount	int
==	O
1	int
)	O
;	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
0	int
]	O
.	O
presence	enum
=	O
FCT_OPTIONAL	int
;	O
}	O
j	long
=	O
0	int
,	O
tj	int
=	O
0	int
,	O
sj	int
=	O
0	int
;	O
while	O
(	O
i	long
<	O
n	long
)	O
{	O
unsigned	O
int	O
k	int
=	O
MIN	O
(	O
srcseg	pointer
->	O
element	array
[	O
si	int
]	O
.	O
repcount	int
-	O
ti	int
,	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
sj	int
]	O
.	O
repcount	int
-	O
tj	int
)	O
;	O
grow_initial_alloc	function
(	O
list	pointer
)	O
;	O
if	O
(	O
!	O
make_intersected_element	function
(	O
&	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
list	pointer
->	O
initial	struct
.	O
count	int
]	O
,	O
&	O
srcseg	pointer
->	O
element	array
[	O
si	int
]	O
,	O
&	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
sj	int
]	O
)	O
)	O
{	O
if	O
(	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
list	pointer
->	O
initial	struct
.	O
count	int
]	O
.	O
presence	enum
==	O
FCT_REQUIRED	int
)	O
{	O
list	pointer
=	O
backtrack_in_initial	function
(	O
list	pointer
)	O
;	O
ASSERT	O
(	O
list	pointer
!=	O
NULL	O
)	O
;	O
return	O
list	pointer
;	O
}	O
else	O
{	O
ended	bool
=	O
true	int
;	O
break	O
;	O
}	O
}	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
list	pointer
->	O
initial	struct
.	O
count	int
]	O
.	O
repcount	int
=	O
k	int
;	O
list	pointer
->	O
initial	struct
.	O
count	int
++	O
;	O
list	pointer
->	O
initial	struct
.	O
length	int
+=	O
k	int
;	O
i	long
+=	O
k	int
;	O
ti	int
+=	O
k	int
;	O
if	O
(	O
ti	int
==	O
srcseg	pointer
->	O
element	array
[	O
si	int
]	O
.	O
repcount	int
)	O
{	O
ti	int
=	O
0	int
;	O
si	int
++	O
;	O
}	O
j	long
+=	O
k	int
;	O
tj	int
+=	O
k	int
;	O
if	O
(	O
tj	int
==	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
sj	int
]	O
.	O
repcount	int
)	O
{	O
tj	int
=	O
0	int
;	O
sj	int
++	O
;	O
}	O
}	O
if	O
(	O
!	O
ended	bool
)	O
ASSERT	O
(	O
list	pointer
->	O
initial	struct
.	O
length	int
==	O
n	long
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
list	pointer
->	O
initial	struct
.	O
length	int
;	O
i	long
+=	O
period	int
)	O
{	O
si	int
=	O
initial_unshare	function
(	O
list	pointer
,	O
i	long
)	O
;	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
si	int
]	O
.	O
presence	enum
=	O
FCT_OPTIONAL	int
;	O
}	O
if	O
(	O
!	O
ended	bool
)	O
{	O
splitindex	int
=	O
initial_splitelement	function
(	O
list	pointer
,	O
n	long
-	O
p	pointer
)	O
;	O
newcount	int
=	O
list	pointer
->	O
initial	struct
.	O
count	int
-	O
splitindex	int
;	O
if	O
(	O
newcount	int
>	O
list	pointer
->	O
repeated	struct
.	O
allocated	int
)	O
{	O
list	pointer
->	O
repeated	struct
.	O
allocated	int
=	O
newcount	int
;	O
list	pointer
->	O
repeated	struct
.	O
element	array
=	O
XNMALLOC	O
(	O
newcount	int
,	O
struct	O
format_arg	struct
)	O
;	O
}	O
for	O
(	O
i	long
=	O
splitindex	int
,	O
j	long
=	O
0	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
,	O
j	long
++	O
)	O
list	pointer
->	O
repeated	struct
.	O
element	array
[	O
j	long
]	O
=	O
list	pointer
->	O
initial	struct
.	O
element	array
[	O
i	long
]	O
;	O
list	pointer
->	O
repeated	struct
.	O
count	int
=	O
newcount	int
;	O
list	pointer
->	O
repeated	struct
.	O
length	int
=	O
p	pointer
;	O
list	pointer
->	O
initial	struct
.	O
count	int
=	O
splitindex	int
;	O
list	pointer
->	O
initial	struct
.	O
length	int
=	O
n	long
-	O
p	pointer
;	O
}	O
VERIFY_LIST	O
(	O
list	pointer
)	O
;	O
return	O
list	pointer
;	O
}	O
static	O
const	O
enum	O
format_arg_type	enum
I	array
[	O
1	int
]	O
=	O
{	O
FAT_INTEGER_NULL	int
}	O
;	O
static	O
const	O
enum	O
format_arg_type	enum
II	array
[	O
2	int
]	O
=	O
{	O
FAT_INTEGER_NULL	int
,	O
FAT_INTEGER_NULL	int
}	O
;	O
static	O
const	O
enum	O
format_arg_type	enum
ICCI	array
[	O
4	int
]	O
=	O
{	O
FAT_INTEGER_NULL	int
,	O
FAT_CHARACTER_NULL	int
,	O
FAT_CHARACTER_NULL	int
,	O
FAT_INTEGER_NULL	int
}	O
;	O
static	O
const	O
enum	O
format_arg_type	enum
IIIC	array
[	O
4	int
]	O
=	O
{	O
FAT_INTEGER_NULL	int
,	O
FAT_INTEGER_NULL	int
,	O
FAT_INTEGER_NULL	int
,	O
FAT_CHARACTER_NULL	int
}	O
;	O
static	O
const	O
enum	O
format_arg_type	enum
IICCI	array
[	O
5	int
]	O
=	O
{	O
FAT_INTEGER_NULL	int
,	O
FAT_INTEGER_NULL	int
,	O
FAT_CHARACTER_NULL	int
,	O
FAT_CHARACTER_NULL	int
,	O
FAT_INTEGER_NULL	int
}	O
;	O
static	O
const	O
enum	O
format_arg_type	enum
IIICC	array
[	O
5	int
]	O
=	O
{	O
FAT_INTEGER_NULL	int
,	O
FAT_INTEGER_NULL	int
,	O
FAT_INTEGER_NULL	int
,	O
FAT_CHARACTER_NULL	int
,	O
FAT_CHARACTER_NULL	int
}	O
;	O
static	O
const	O
enum	O
format_arg_type	enum
IIIICCC	array
[	O
7	int
]	O
=	O
{	O
FAT_INTEGER_NULL	int
,	O
FAT_INTEGER_NULL	int
,	O
FAT_INTEGER_NULL	int
,	O
FAT_INTEGER_NULL	int
,	O
FAT_CHARACTER_NULL	int
,	O
FAT_CHARACTER_NULL	int
,	O
FAT_CHARACTER_NULL	int
}	O
;	O
static	O
const	O
enum	O
format_arg_type	enum
THREE	array
[	O
3	int
]	O
=	O
{	O
FAT_CHARACTER_INTEGER_NULL	int
,	O
FAT_CHARACTER_INTEGER_NULL	int
,	O
FAT_CHARACTER_INTEGER_NULL	int
}	O
;	O
static	O
bool	bool
check_params	function
(	O
struct	O
format_arg_list	struct
*	O
*	O
listp	pointer
,	O
unsigned	O
int	O
paramcount	int
,	O
struct	O
param	struct
*	O
params	pointer
,	O
unsigned	O
int	O
t_count	int
,	O
const	O
enum	O
format_arg_type	enum
*	O
t_types	pointer
,	O
unsigned	O
int	O
directives	int
,	O
char	O
*	O
*	O
invalid_reason	pointer
)	O
{	O
unsigned	O
int	O
orig_paramcount	int
=	O
paramcount	int
;	O
unsigned	O
int	O
orig_t_count	int
=	O
t_count	int
;	O
for	O
(	O
;	O
paramcount	int
>	O
0	int
&&	O
t_count	int
>	O
0	int
;	O
params	pointer
++	O
,	O
paramcount	int
--	O
,	O
t_types	pointer
++	O
,	O
t_count	int
--	O
)	O
{	O
switch	O
(	O
*	O
t_types	pointer
)	O
{	O
case	O
FAT_CHARACTER_INTEGER_NULL	int
:	O
break	O
;	O
case	O
FAT_CHARACTER_NULL	int
:	O
switch	O
(	O
params	pointer
->	O
type	enum
)	O
{	O
case	O
PT_NIL	int
:	O
case	O
PT_CHARACTER	int
:	O
case	O
PT_V	int
:	O
break	O
;	O
case	O
PT_INTEGER	int
:	O
case	O
PT_ARGCOUNT	int
:	O
*	O
invalid_reason	pointer
=	O
xasprintf	function
(	O
_	O
(	O
"In the directive number %u, parameter %u is of type '%s' but a parameter of type '%s' is expected."	pointer
)	O
,	O
directives	int
,	O
orig_paramcount	int
-	O
paramcount	int
+	O
1	int
,	O
"integer"	pointer
,	O
"character"	pointer
)	O
;	O
return	O
false	int
;	O
}	O
break	O
;	O
case	O
FAT_INTEGER_NULL	int
:	O
switch	O
(	O
params	pointer
->	O
type	enum
)	O
{	O
case	O
PT_NIL	int
:	O
case	O
PT_INTEGER	int
:	O
case	O
PT_ARGCOUNT	int
:	O
case	O
PT_V	int
:	O
break	O
;	O
case	O
PT_CHARACTER	int
:	O
*	O
invalid_reason	pointer
=	O
xasprintf	function
(	O
_	O
(	O
"In the directive number %u, parameter %u is of type '%s' but a parameter of type '%s' is expected."	pointer
)	O
,	O
directives	int
,	O
orig_paramcount	int
-	O
paramcount	int
+	O
1	int
,	O
"character"	pointer
,	O
"integer"	pointer
)	O
;	O
return	O
false	int
;	O
}	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
if	O
(	O
params	pointer
->	O
type	enum
==	O
PT_V	int
)	O
{	O
int	O
position	int
=	O
params	pointer
->	O
value	int
;	O
if	O
(	O
position	int
>=	O
0	int
)	O
add_req_type_constraint	function
(	O
listp	pointer
,	O
position	int
,	O
*	O
t_types	pointer
)	O
;	O
}	O
}	O
for	O
(	O
;	O
paramcount	int
>	O
0	int
;	O
params	pointer
++	O
,	O
paramcount	int
--	O
)	O
switch	O
(	O
params	pointer
->	O
type	enum
)	O
{	O
case	O
PT_NIL	int
:	O
break	O
;	O
case	O
PT_CHARACTER	int
:	O
case	O
PT_INTEGER	int
:	O
case	O
PT_ARGCOUNT	int
:	O
*	O
invalid_reason	pointer
=	O
xasprintf	function
(	O
ngettext	function
(	O
"In the directive number %u, too many parameters are given; expected at most %u parameter."	pointer
,	O
"In the directive number %u, too many parameters are given; expected at most %u parameters."	pointer
,	O
orig_t_count	int
)	O
,	O
directives	int
,	O
orig_t_count	int
)	O
;	O
return	O
false	int
;	O
case	O
PT_V	int
:	O
{	O
int	O
position	int
=	O
params	pointer
->	O
value	int
;	O
if	O
(	O
position	int
>=	O
0	int
)	O
{	O
struct	O
format_arg_list	struct
*	O
empty_list	pointer
=	O
make_empty_list	function
(	O
)	O
;	O
add_req_listtype_constraint	function
(	O
listp	pointer
,	O
position	int
,	O
FAT_LIST	int
,	O
empty_list	pointer
)	O
;	O
free_list	function
(	O
empty_list	pointer
)	O
;	O
}	O
}	O
break	O
;	O
}	O
return	O
true	int
;	O
}	O
static	O
bool	bool
nocheck_params	function
(	O
struct	O
format_arg_list	struct
*	O
*	O
listp	pointer
,	O
unsigned	O
int	O
paramcount	int
,	O
struct	O
param	struct
*	O
params	pointer
,	O
unsigned	O
int	O
directives	int
,	O
char	O
*	O
*	O
invalid_reason	pointer
)	O
{	O
(	O
void	O
)	O
directives	int
;	O
(	O
void	O
)	O
invalid_reason	pointer
;	O
for	O
(	O
;	O
paramcount	int
>	O
0	int
;	O
params	pointer
++	O
,	O
paramcount	int
--	O
)	O
if	O
(	O
params	pointer
->	O
type	enum
==	O
PT_V	int
)	O
{	O
int	O
position	int
=	O
params	pointer
->	O
value	int
;	O
add_req_type_constraint	function
(	O
listp	pointer
,	O
position	int
,	O
FAT_CHARACTER_INTEGER_NULL	int
)	O
;	O
}	O
return	O
true	int
;	O
}	O
static	O
bool	bool
parse_upto	function
(	O
const	O
char	O
*	O
*	O
formatp	pointer
,	O
int	O
*	O
positionp	pointer
,	O
struct	O
format_arg_list	struct
*	O
*	O
listp	pointer
,	O
struct	O
format_arg_list	struct
*	O
*	O
escapep	pointer
,	O
int	O
*	O
separatorp	pointer
,	O
struct	O
spec	struct
*	O
spec	struct
,	O
char	O
terminator	char
,	O
bool	bool
separator	pointer
,	O
char	O
*	O
fdi	pointer
,	O
char	O
*	O
*	O
invalid_reason	pointer
)	O
{	O
const	O
char	O
*	O
format	pointer
=	O
*	O
formatp	pointer
;	O
const	O
char	O
*	O
const	O
format_start	pointer
=	O
format	pointer
;	O
int	O
position	int
=	O
*	O
positionp	pointer
;	O
struct	O
format_arg_list	struct
*	O
list	pointer
=	O
*	O
listp	pointer
;	O
struct	O
format_arg_list	struct
*	O
escape	pointer
=	O
*	O
escapep	pointer
;	O
for	O
(	O
;	O
*	O
format	pointer
!=	O
'\0'	O
;	O
)	O
if	O
(	O
*	O
format	pointer
++	O
==	O
'~'	O
)	O
{	O
bool	bool
colon_p	bool
=	O
false	int
;	O
bool	bool
atsign_p	bool
=	O
false	int
;	O
unsigned	O
int	O
paramcount	int
=	O
0	int
;	O
struct	O
param	struct
*	O
params	pointer
=	O
NULL	O
;	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_START	int
)	O
;	O
spec	struct
->	O
directives	int
++	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
enum	O
param_type	enum
type	enum
=	O
PT_NIL	int
;	O
int	O
value	int
=	O
0	int
;	O
if	O
(	O
c_isdigit	function
(	O
*	O
format	pointer
)	O
)	O
{	O
type	enum
=	O
PT_INTEGER	int
;	O
do	O
{	O
value	int
=	O
10	int
*	O
value	int
+	O
(	O
*	O
format	pointer
-	O
'0'	O
)	O
;	O
format	pointer
++	O
;	O
}	O
while	O
(	O
c_isdigit	function
(	O
*	O
format	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
*	O
format	pointer
==	O
'+'	O
||	O
*	O
format	pointer
==	O
'-'	O
)	O
{	O
bool	bool
negative	bool
=	O
(	O
*	O
format	pointer
==	O
'-'	O
)	O
;	O
type	enum
=	O
PT_INTEGER	int
;	O
format	pointer
++	O
;	O
if	O
(	O
!	O
c_isdigit	function
(	O
*	O
format	pointer
)	O
)	O
{	O
if	O
(	O
*	O
format	pointer
==	O
'\0'	O
)	O
{	O
*	O
invalid_reason	pointer
=	O
INVALID_UNTERMINATED_DIRECTIVE	O
(	O
)	O
;	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
}	O
else	O
{	O
*	O
invalid_reason	pointer
=	O
xasprintf	function
(	O
_	O
(	O
"In the directive number %u, '%c' is not followed by a digit."	pointer
)	O
,	O
spec	struct
->	O
directives	int
,	O
format	pointer
[	O
-	O
1	int
]	O
)	O
;	O
FDI_SET	O
(	O
format	pointer
,	O
FMTDIR_ERROR	int
)	O
;	O
}	O
return	O
false	int
;	O
}	O
do	O
{	O
value	int
=	O
10	int
*	O
value	int
+	O
(	O
*	O
format	pointer
-	O
'0'	O
)	O
;	O
format	pointer
++	O
;	O
}	O
while	O
(	O
c_isdigit	function
(	O
*	O
format	pointer
)	O
)	O
;	O
if	O
(	O
negative	bool
)	O
value	int
=	O
-	O
value	int
;	O
}	O
else	O
if	O
(	O
*	O
format	pointer
==	O
'\''	O
)	O
{	O
type	enum
=	O
PT_CHARACTER	int
;	O
format	pointer
++	O
;	O
if	O
(	O
*	O
format	pointer
==	O
'\0'	O
)	O
{	O
*	O
invalid_reason	pointer
=	O
INVALID_UNTERMINATED_DIRECTIVE	O
(	O
)	O
;	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
format	pointer
++	O
;	O
}	O
else	O
if	O
(	O
*	O
format	pointer
==	O
'V'	O
||	O
*	O
format	pointer
==	O
'v'	O
)	O
{	O
type	enum
=	O
PT_V	int
;	O
format	pointer
++	O
;	O
value	int
=	O
position	int
;	O
if	O
(	O
position	int
>=	O
0	int
)	O
position	int
++	O
;	O
}	O
else	O
if	O
(	O
*	O
format	pointer
==	O
'#'	O
)	O
{	O
type	enum
=	O
PT_ARGCOUNT	int
;	O
format	pointer
++	O
;	O
}	O
params	pointer
=	O
(	O
struct	O
param	struct
*	O
)	O
xrealloc	function
(	O
params	pointer
,	O
(	O
paramcount	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
struct	O
param	struct
)	O
)	O
;	O
params	pointer
[	O
paramcount	int
]	O
.	O
type	enum
=	O
type	enum
;	O
params	pointer
[	O
paramcount	int
]	O
.	O
value	int
=	O
value	int
;	O
paramcount	int
++	O
;	O
if	O
(	O
*	O
format	pointer
==	O
','	O
)	O
format	pointer
++	O
;	O
else	O
break	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
*	O
format	pointer
==	O
':'	O
)	O
{	O
format	pointer
++	O
;	O
colon_p	bool
=	O
true	int
;	O
}	O
else	O
if	O
(	O
*	O
format	pointer
==	O
'@'	O
)	O
{	O
format	pointer
++	O
;	O
atsign_p	bool
=	O
true	int
;	O
}	O
else	O
break	O
;	O
}	O
switch	O
(	O
*	O
format	pointer
++	O
)	O
{	O
case	O
'A'	O
:	O
case	O
'a'	O
:	O
case	O
'S'	O
:	O
case	O
's'	O
:	O
if	O
(	O
!	O
check_params	function
(	O
&	O
list	pointer
,	O
paramcount	int
,	O
params	pointer
,	O
4	int
,	O
IIIC	array
,	O
spec	struct
->	O
directives	int
,	O
invalid_reason	pointer
)	O
)	O
{	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
position	int
>=	O
0	int
)	O
add_req_type_constraint	function
(	O
&	O
list	pointer
,	O
position	int
++	O
,	O
FAT_OBJECT	int
)	O
;	O
break	O
;	O
case	O
'W'	O
:	O
case	O
'w'	O
:	O
if	O
(	O
!	O
check_params	function
(	O
&	O
list	pointer
,	O
paramcount	int
,	O
params	pointer
,	O
0	int
,	O
NULL	O
,	O
spec	struct
->	O
directives	int
,	O
invalid_reason	pointer
)	O
)	O
{	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
position	int
>=	O
0	int
)	O
add_req_type_constraint	function
(	O
&	O
list	pointer
,	O
position	int
++	O
,	O
FAT_OBJECT	int
)	O
;	O
break	O
;	O
case	O
'D'	O
:	O
case	O
'd'	O
:	O
case	O
'B'	O
:	O
case	O
'b'	O
:	O
case	O
'O'	O
:	O
case	O
'o'	O
:	O
case	O
'X'	O
:	O
case	O
'x'	O
:	O
if	O
(	O
!	O
check_params	function
(	O
&	O
list	pointer
,	O
paramcount	int
,	O
params	pointer
,	O
4	int
,	O
ICCI	array
,	O
spec	struct
->	O
directives	int
,	O
invalid_reason	pointer
)	O
)	O
{	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
position	int
>=	O
0	int
)	O
add_req_type_constraint	function
(	O
&	O
list	pointer
,	O
position	int
++	O
,	O
FAT_INTEGER	int
)	O
;	O
break	O
;	O
case	O
'R'	O
:	O
case	O
'r'	O
:	O
if	O
(	O
!	O
check_params	function
(	O
&	O
list	pointer
,	O
paramcount	int
,	O
params	pointer
,	O
5	int
,	O
IICCI	array
,	O
spec	struct
->	O
directives	int
,	O
invalid_reason	pointer
)	O
)	O
{	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
position	int
>=	O
0	int
)	O
add_req_type_constraint	function
(	O
&	O
list	pointer
,	O
position	int
++	O
,	O
FAT_INTEGER	int
)	O
;	O
break	O
;	O
case	O
'P'	O
:	O
case	O
'p'	O
:	O
if	O
(	O
!	O
check_params	function
(	O
&	O
list	pointer
,	O
paramcount	int
,	O
params	pointer
,	O
0	int
,	O
NULL	O
,	O
spec	struct
->	O
directives	int
,	O
invalid_reason	pointer
)	O
)	O
{	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
colon_p	bool
)	O
{	O
if	O
(	O
position	int
>	O
0	int
)	O
position	int
--	O
;	O
}	O
if	O
(	O
position	int
>=	O
0	int
)	O
add_req_type_constraint	function
(	O
&	O
list	pointer
,	O
position	int
++	O
,	O
FAT_OBJECT	int
)	O
;	O
break	O
;	O
case	O
'C'	O
:	O
case	O
'c'	O
:	O
if	O
(	O
!	O
check_params	function
(	O
&	O
list	pointer
,	O
paramcount	int
,	O
params	pointer
,	O
0	int
,	O
NULL	O
,	O
spec	struct
->	O
directives	int
,	O
invalid_reason	pointer
)	O
)	O
{	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
position	int
>=	O
0	int
)	O
add_req_type_constraint	function
(	O
&	O
list	pointer
,	O
position	int
++	O
,	O
FAT_CHARACTER	int
)	O
;	O
break	O
;	O
case	O
'F'	O
:	O
case	O
'f'	O
:	O
if	O
(	O
!	O
check_params	function
(	O
&	O
list	pointer
,	O
paramcount	int
,	O
params	pointer
,	O
5	int
,	O
IIICC	array
,	O
spec	struct
->	O
directives	int
,	O
invalid_reason	pointer
)	O
)	O
{	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
position	int
>=	O
0	int
)	O
add_req_type_constraint	function
(	O
&	O
list	pointer
,	O
position	int
++	O
,	O
FAT_REAL	int
)	O
;	O
break	O
;	O
case	O
'E'	O
:	O
case	O
'e'	O
:	O
case	O
'G'	O
:	O
case	O
'g'	O
:	O
if	O
(	O
!	O
check_params	function
(	O
&	O
list	pointer
,	O
paramcount	int
,	O
params	pointer
,	O
7	int
,	O
IIIICCC	array
,	O
spec	struct
->	O
directives	int
,	O
invalid_reason	pointer
)	O
)	O
{	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
position	int
>=	O
0	int
)	O
add_req_type_constraint	function
(	O
&	O
list	pointer
,	O
position	int
++	O
,	O
FAT_REAL	int
)	O
;	O
break	O
;	O
case	O
'$'	O
:	O
if	O
(	O
!	O
check_params	function
(	O
&	O
list	pointer
,	O
paramcount	int
,	O
params	pointer
,	O
4	int
,	O
IIIC	array
,	O
spec	struct
->	O
directives	int
,	O
invalid_reason	pointer
)	O
)	O
{	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
position	int
>=	O
0	int
)	O
add_req_type_constraint	function
(	O
&	O
list	pointer
,	O
position	int
++	O
,	O
FAT_REAL	int
)	O
;	O
break	O
;	O
case	O
'%'	O
:	O
case	O
'&'	O
:	O
case	O
'|'	O
:	O
case	O
'~'	O
:	O
case	O
'I'	O
:	O
case	O
'i'	O
:	O
if	O
(	O
!	O
check_params	function
(	O
&	O
list	pointer
,	O
paramcount	int
,	O
params	pointer
,	O
1	int
,	O
I	array
,	O
spec	struct
->	O
directives	int
,	O
invalid_reason	pointer
)	O
)	O
{	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
break	O
;	O
case	O
'\n'	O
:	O
case	O
'_'	O
:	O
if	O
(	O
!	O
check_params	function
(	O
&	O
list	pointer
,	O
paramcount	int
,	O
params	pointer
,	O
0	int
,	O
NULL	O
,	O
spec	struct
->	O
directives	int
,	O
invalid_reason	pointer
)	O
)	O
{	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
break	O
;	O
case	O
'T'	O
:	O
case	O
't'	O
:	O
if	O
(	O
!	O
check_params	function
(	O
&	O
list	pointer
,	O
paramcount	int
,	O
params	pointer
,	O
2	int
,	O
II	array
,	O
spec	struct
->	O
directives	int
,	O
invalid_reason	pointer
)	O
)	O
{	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
break	O
;	O
case	O
'*'	O
:	O
if	O
(	O
!	O
check_params	function
(	O
&	O
list	pointer
,	O
paramcount	int
,	O
params	pointer
,	O
1	int
,	O
I	array
,	O
spec	struct
->	O
directives	int
,	O
invalid_reason	pointer
)	O
)	O
{	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
{	O
int	O
n	long
;	O
if	O
(	O
paramcount	int
==	O
0	int
||	O
(	O
paramcount	int
>=	O
1	int
&&	O
params	pointer
[	O
0	int
]	O
.	O
type	enum
==	O
PT_NIL	int
)	O
)	O
n	long
=	O
(	O
atsign_p	bool
?	O
0	int
:	O
1	int
)	O
;	O
else	O
if	O
(	O
paramcount	int
>=	O
1	int
&&	O
params	pointer
[	O
0	int
]	O
.	O
type	enum
==	O
PT_INTEGER	int
)	O
n	long
=	O
params	pointer
[	O
0	int
]	O
.	O
value	int
;	O
else	O
{	O
position	int
=	O
-	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
n	long
<	O
0	int
)	O
{	O
*	O
invalid_reason	pointer
=	O
xasprintf	function
(	O
_	O
(	O
"In the directive number %u, the argument %d is negative."	pointer
)	O
,	O
spec	struct
->	O
directives	int
,	O
n	long
)	O
;	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
atsign_p	bool
)	O
{	O
position	int
=	O
n	long
;	O
}	O
else	O
if	O
(	O
colon_p	bool
)	O
{	O
if	O
(	O
n	long
>	O
0	int
)	O
{	O
if	O
(	O
position	int
>=	O
0	int
)	O
{	O
if	O
(	O
position	int
>=	O
n	long
)	O
position	int
-=	O
n	long
;	O
else	O
position	int
=	O
0	int
;	O
}	O
else	O
position	int
=	O
-	O
1	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
position	int
>=	O
0	int
)	O
position	int
+=	O
n	long
;	O
}	O
}	O
break	O
;	O
case	O
'?'	O
:	O
if	O
(	O
!	O
check_params	function
(	O
&	O
list	pointer
,	O
paramcount	int
,	O
params	pointer
,	O
0	int
,	O
NULL	O
,	O
spec	struct
->	O
directives	int
,	O
invalid_reason	pointer
)	O
)	O
{	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
position	int
>=	O
0	int
)	O
add_req_type_constraint	function
(	O
&	O
list	pointer
,	O
position	int
++	O
,	O
FAT_FORMATSTRING	int
)	O
;	O
if	O
(	O
atsign_p	bool
)	O
position	int
=	O
-	O
1	int
;	O
else	O
if	O
(	O
position	int
>=	O
0	int
)	O
{	O
struct	O
format_arg_list	struct
*	O
sublist	pointer
=	O
make_unconstrained_list	function
(	O
)	O
;	O
add_req_listtype_constraint	function
(	O
&	O
list	pointer
,	O
position	int
++	O
,	O
FAT_LIST	int
,	O
sublist	pointer
)	O
;	O
free_list	function
(	O
sublist	pointer
)	O
;	O
}	O
break	O
;	O
case	O
'/'	O
:	O
if	O
(	O
!	O
check_params	function
(	O
&	O
list	pointer
,	O
paramcount	int
,	O
params	pointer
,	O
0	int
,	O
NULL	O
,	O
spec	struct
->	O
directives	int
,	O
invalid_reason	pointer
)	O
)	O
{	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
position	int
>=	O
0	int
)	O
add_req_type_constraint	function
(	O
&	O
list	pointer
,	O
position	int
++	O
,	O
FAT_OBJECT	int
)	O
;	O
while	O
(	O
*	O
format	pointer
!=	O
'\0'	O
&&	O
*	O
format	pointer
!=	O
'/'	O
)	O
format	pointer
++	O
;	O
if	O
(	O
*	O
format	pointer
==	O
'\0'	O
)	O
{	O
*	O
invalid_reason	pointer
=	O
xstrdup	function
(	O
_	O
(	O
"The string ends in the middle of a ~/.../ directive."	pointer
)	O
)	O
;	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
format	pointer
++	O
;	O
break	O
;	O
case	O
'('	O
:	O
if	O
(	O
!	O
check_params	function
(	O
&	O
list	pointer
,	O
paramcount	int
,	O
params	pointer
,	O
0	int
,	O
NULL	O
,	O
spec	struct
->	O
directives	int
,	O
invalid_reason	pointer
)	O
)	O
{	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
*	O
formatp	pointer
=	O
format	pointer
;	O
*	O
positionp	pointer
=	O
position	int
;	O
*	O
listp	pointer
=	O
list	pointer
;	O
*	O
escapep	pointer
=	O
escape	pointer
;	O
{	O
if	O
(	O
!	O
parse_upto	function
(	O
formatp	pointer
,	O
positionp	pointer
,	O
listp	pointer
,	O
escapep	pointer
,	O
NULL	O
,	O
spec	struct
,	O
')'	O
,	O
false	int
,	O
NULL	O
,	O
invalid_reason	pointer
)	O
)	O
{	O
FDI_SET	O
(	O
*	O
*	O
formatp	pointer
==	O
'\0'	O
?	O
*	O
formatp	pointer
-	O
1	int
:	O
*	O
formatp	pointer
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
}	O
format	pointer
=	O
*	O
formatp	pointer
;	O
position	int
=	O
*	O
positionp	pointer
;	O
list	pointer
=	O
*	O
listp	pointer
;	O
escape	pointer
=	O
*	O
escapep	pointer
;	O
break	O
;	O
case	O
')'	O
:	O
if	O
(	O
terminator	char
!=	O
')'	O
)	O
{	O
*	O
invalid_reason	pointer
=	O
xasprintf	function
(	O
_	O
(	O
"Found '~%c' without matching '~%c'."	pointer
)	O
,	O
')'	O
,	O
'('	O
)	O
;	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
!	O
check_params	function
(	O
&	O
list	pointer
,	O
paramcount	int
,	O
params	pointer
,	O
0	int
,	O
NULL	O
,	O
spec	struct
->	O
directives	int
,	O
invalid_reason	pointer
)	O
)	O
{	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
*	O
formatp	pointer
=	O
format	pointer
;	O
*	O
positionp	pointer
=	O
position	int
;	O
*	O
listp	pointer
=	O
list	pointer
;	O
*	O
escapep	pointer
=	O
escape	pointer
;	O
return	O
true	int
;	O
case	O
'['	O
:	O
if	O
(	O
atsign_p	bool
&&	O
colon_p	bool
)	O
{	O
*	O
invalid_reason	pointer
=	O
xasprintf	function
(	O
_	O
(	O
"In the directive number %u, both the @ and the : modifiers are given."	pointer
)	O
,	O
spec	struct
->	O
directives	int
)	O
;	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
else	O
if	O
(	O
atsign_p	bool
)	O
{	O
struct	O
format_arg_list	struct
*	O
nil_list	pointer
;	O
struct	O
format_arg_list	struct
*	O
union_list	pointer
;	O
if	O
(	O
!	O
check_params	function
(	O
&	O
list	pointer
,	O
paramcount	int
,	O
params	pointer
,	O
0	int
,	O
NULL	O
,	O
spec	struct
->	O
directives	int
,	O
invalid_reason	pointer
)	O
)	O
{	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
*	O
formatp	pointer
=	O
format	pointer
;	O
*	O
escapep	pointer
=	O
escape	pointer
;	O
nil_list	pointer
=	O
(	O
list	pointer
!=	O
NULL	O
?	O
copy_list	function
(	O
list	pointer
)	O
:	O
NULL	O
)	O
;	O
if	O
(	O
position	int
>=	O
0	int
)	O
{	O
struct	O
format_arg_list	struct
*	O
empty_list	pointer
=	O
make_empty_list	function
(	O
)	O
;	O
add_req_listtype_constraint	function
(	O
&	O
nil_list	pointer
,	O
position	int
,	O
FAT_LIST	int
,	O
empty_list	pointer
)	O
;	O
free_list	function
(	O
empty_list	pointer
)	O
;	O
}	O
{	O
int	O
sub_position	int
=	O
position	int
;	O
struct	O
format_arg_list	struct
*	O
sub_list	pointer
=	O
(	O
list	pointer
!=	O
NULL	O
?	O
copy_list	function
(	O
list	pointer
)	O
:	O
NULL	O
)	O
;	O
if	O
(	O
!	O
parse_upto	function
(	O
formatp	pointer
,	O
&	O
sub_position	int
,	O
&	O
sub_list	pointer
,	O
escapep	pointer
,	O
NULL	O
,	O
spec	struct
,	O
']'	O
,	O
false	int
,	O
NULL	O
,	O
invalid_reason	pointer
)	O
)	O
{	O
FDI_SET	O
(	O
*	O
*	O
formatp	pointer
==	O
'\0'	O
?	O
*	O
formatp	pointer
-	O
1	int
:	O
*	O
formatp	pointer
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
sub_list	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
position	int
>=	O
0	int
)	O
{	O
if	O
(	O
sub_position	int
==	O
position	int
+	O
1	int
)	O
position	int
=	O
position	int
+	O
1	int
;	O
else	O
position	int
=	O
-	O
1	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
position	int
>=	O
0	int
)	O
position	int
=	O
position	int
+	O
1	int
;	O
}	O
union_list	pointer
=	O
union	O
(	O
nil_list	pointer
,	O
sub_list	pointer
)	O
;	O
}	O
format	pointer
=	O
*	O
formatp	pointer
;	O
escape	pointer
=	O
*	O
escapep	pointer
;	O
if	O
(	O
list	pointer
!=	O
NULL	O
)	O
free_list	function
(	O
list	pointer
)	O
;	O
list	pointer
=	O
union_list	pointer
;	O
}	O
else	O
if	O
(	O
colon_p	bool
)	O
{	O
int	O
union_position	int
;	O
struct	O
format_arg_list	struct
*	O
union_list	pointer
;	O
if	O
(	O
!	O
check_params	function
(	O
&	O
list	pointer
,	O
paramcount	int
,	O
params	pointer
,	O
0	int
,	O
NULL	O
,	O
spec	struct
->	O
directives	int
,	O
invalid_reason	pointer
)	O
)	O
{	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
position	int
>=	O
0	int
)	O
add_req_type_constraint	function
(	O
&	O
list	pointer
,	O
position	int
++	O
,	O
FAT_OBJECT	int
)	O
;	O
*	O
formatp	pointer
=	O
format	pointer
;	O
*	O
escapep	pointer
=	O
escape	pointer
;	O
union_position	int
=	O
-	O
2	int
;	O
union_list	pointer
=	O
NULL	O
;	O
{	O
int	O
sub_position	int
=	O
position	int
;	O
struct	O
format_arg_list	struct
*	O
sub_list	pointer
=	O
(	O
list	pointer
!=	O
NULL	O
?	O
copy_list	function
(	O
list	pointer
)	O
:	O
NULL	O
)	O
;	O
int	O
sub_separator	int
=	O
0	int
;	O
if	O
(	O
position	int
>=	O
0	int
)	O
{	O
struct	O
format_arg_list	struct
*	O
empty_list	pointer
=	O
make_empty_list	function
(	O
)	O
;	O
add_req_listtype_constraint	function
(	O
&	O
sub_list	pointer
,	O
position	int
-	O
1	int
,	O
FAT_LIST	int
,	O
empty_list	pointer
)	O
;	O
free_list	function
(	O
empty_list	pointer
)	O
;	O
}	O
if	O
(	O
!	O
parse_upto	function
(	O
formatp	pointer
,	O
&	O
sub_position	int
,	O
&	O
sub_list	pointer
,	O
escapep	pointer
,	O
&	O
sub_separator	int
,	O
spec	struct
,	O
']'	O
,	O
true	int
,	O
NULL	O
,	O
invalid_reason	pointer
)	O
)	O
{	O
FDI_SET	O
(	O
*	O
*	O
formatp	pointer
==	O
'\0'	O
?	O
*	O
formatp	pointer
-	O
1	int
:	O
*	O
formatp	pointer
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
!	O
sub_separator	int
)	O
{	O
*	O
invalid_reason	pointer
=	O
xasprintf	function
(	O
_	O
(	O
"In the directive number %u, '~:[' is not followed by two clauses, separated by '~;'."	pointer
)	O
,	O
spec	struct
->	O
directives	int
)	O
;	O
FDI_SET	O
(	O
*	O
*	O
formatp	pointer
==	O
'\0'	O
?	O
*	O
formatp	pointer
-	O
1	int
:	O
*	O
formatp	pointer
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
sub_list	pointer
!=	O
NULL	O
)	O
union_position	int
=	O
sub_position	int
;	O
union_list	pointer
=	O
union	O
(	O
union_list	pointer
,	O
sub_list	pointer
)	O
;	O
}	O
{	O
int	O
sub_position	int
=	O
position	int
;	O
struct	O
format_arg_list	struct
*	O
sub_list	pointer
=	O
(	O
list	pointer
!=	O
NULL	O
?	O
copy_list	function
(	O
list	pointer
)	O
:	O
NULL	O
)	O
;	O
if	O
(	O
!	O
parse_upto	function
(	O
formatp	pointer
,	O
&	O
sub_position	int
,	O
&	O
sub_list	pointer
,	O
escapep	pointer
,	O
NULL	O
,	O
spec	struct
,	O
']'	O
,	O
false	int
,	O
NULL	O
,	O
invalid_reason	pointer
)	O
)	O
{	O
FDI_SET	O
(	O
*	O
*	O
formatp	pointer
==	O
'\0'	O
?	O
*	O
formatp	pointer
-	O
1	int
:	O
*	O
formatp	pointer
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
sub_list	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
union_position	int
==	O
-	O
2	int
)	O
union_position	int
=	O
sub_position	int
;	O
else	O
if	O
(	O
sub_position	int
<	O
0	int
||	O
sub_position	int
!=	O
union_position	int
)	O
union_position	int
=	O
-	O
1	int
;	O
}	O
union_list	pointer
=	O
union	O
(	O
union_list	pointer
,	O
sub_list	pointer
)	O
;	O
}	O
format	pointer
=	O
*	O
formatp	pointer
;	O
escape	pointer
=	O
*	O
escapep	pointer
;	O
if	O
(	O
union_position	int
!=	O
-	O
2	int
)	O
position	int
=	O
union_position	int
;	O
if	O
(	O
list	pointer
!=	O
NULL	O
)	O
free_list	function
(	O
list	pointer
)	O
;	O
list	pointer
=	O
union_list	pointer
;	O
}	O
else	O
{	O
int	O
arg_position	int
;	O
int	O
union_position	int
;	O
struct	O
format_arg_list	struct
*	O
union_list	pointer
;	O
bool	bool
last_alternative	bool
;	O
if	O
(	O
!	O
check_params	function
(	O
&	O
list	pointer
,	O
paramcount	int
,	O
params	pointer
,	O
1	int
,	O
I	array
,	O
spec	struct
->	O
directives	int
,	O
invalid_reason	pointer
)	O
)	O
{	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
arg_position	int
=	O
-	O
1	int
;	O
if	O
(	O
!	O
(	O
paramcount	int
>=	O
1	int
&&	O
params	pointer
[	O
0	int
]	O
.	O
type	enum
!=	O
PT_NIL	int
)	O
)	O
if	O
(	O
position	int
>=	O
0	int
)	O
{	O
arg_position	int
=	O
position	int
;	O
add_req_type_constraint	function
(	O
&	O
list	pointer
,	O
position	int
++	O
,	O
FAT_OBJECT	int
)	O
;	O
}	O
*	O
formatp	pointer
=	O
format	pointer
;	O
*	O
escapep	pointer
=	O
escape	pointer
;	O
union_position	int
=	O
-	O
2	int
;	O
union_list	pointer
=	O
NULL	O
;	O
last_alternative	bool
=	O
false	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
sub_position	int
=	O
position	int
;	O
struct	O
format_arg_list	struct
*	O
sub_list	pointer
=	O
(	O
list	pointer
!=	O
NULL	O
?	O
copy_list	function
(	O
list	pointer
)	O
:	O
NULL	O
)	O
;	O
int	O
sub_separator	int
=	O
0	int
;	O
if	O
(	O
!	O
parse_upto	function
(	O
formatp	pointer
,	O
&	O
sub_position	int
,	O
&	O
sub_list	pointer
,	O
escapep	pointer
,	O
&	O
sub_separator	int
,	O
spec	struct
,	O
']'	O
,	O
!	O
last_alternative	bool
,	O
NULL	O
,	O
invalid_reason	pointer
)	O
)	O
{	O
FDI_SET	O
(	O
*	O
*	O
formatp	pointer
==	O
'\0'	O
?	O
*	O
formatp	pointer
-	O
1	int
:	O
*	O
formatp	pointer
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
!	O
last_alternative	bool
&&	O
arg_position	int
>=	O
0	int
)	O
add_req_type_constraint	function
(	O
&	O
sub_list	pointer
,	O
arg_position	int
,	O
FAT_INTEGER	int
)	O
;	O
if	O
(	O
sub_list	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
union_position	int
==	O
-	O
2	int
)	O
union_position	int
=	O
sub_position	int
;	O
else	O
if	O
(	O
sub_position	int
<	O
0	int
||	O
sub_position	int
!=	O
union_position	int
)	O
union_position	int
=	O
-	O
1	int
;	O
}	O
union_list	pointer
=	O
union	O
(	O
union_list	pointer
,	O
sub_list	pointer
)	O
;	O
if	O
(	O
sub_separator	int
==	O
2	int
)	O
last_alternative	bool
=	O
true	int
;	O
if	O
(	O
!	O
sub_separator	int
)	O
break	O
;	O
}	O
if	O
(	O
!	O
last_alternative	bool
)	O
{	O
if	O
(	O
union_position	int
==	O
-	O
2	int
)	O
union_position	int
=	O
position	int
;	O
else	O
if	O
(	O
position	int
<	O
0	int
||	O
position	int
!=	O
union_position	int
)	O
union_position	int
=	O
-	O
1	int
;	O
if	O
(	O
list	pointer
!=	O
NULL	O
)	O
union_list	pointer
=	O
union	O
(	O
union_list	pointer
,	O
copy_list	function
(	O
list	pointer
)	O
)	O
;	O
}	O
format	pointer
=	O
*	O
formatp	pointer
;	O
escape	pointer
=	O
*	O
escapep	pointer
;	O
if	O
(	O
union_position	int
!=	O
-	O
2	int
)	O
position	int
=	O
union_position	int
;	O
if	O
(	O
list	pointer
!=	O
NULL	O
)	O
free_list	function
(	O
list	pointer
)	O
;	O
list	pointer
=	O
union_list	pointer
;	O
}	O
break	O
;	O
case	O
']'	O
:	O
if	O
(	O
terminator	char
!=	O
']'	O
)	O
{	O
*	O
invalid_reason	pointer
=	O
xasprintf	function
(	O
_	O
(	O
"Found '~%c' without matching '~%c'."	pointer
)	O
,	O
']'	O
,	O
'['	O
)	O
;	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
!	O
check_params	function
(	O
&	O
list	pointer
,	O
paramcount	int
,	O
params	pointer
,	O
0	int
,	O
NULL	O
,	O
spec	struct
->	O
directives	int
,	O
invalid_reason	pointer
)	O
)	O
{	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
*	O
formatp	pointer
=	O
format	pointer
;	O
*	O
positionp	pointer
=	O
position	int
;	O
*	O
listp	pointer
=	O
list	pointer
;	O
*	O
escapep	pointer
=	O
escape	pointer
;	O
return	O
true	int
;	O
case	O
'{'	O
:	O
if	O
(	O
!	O
check_params	function
(	O
&	O
list	pointer
,	O
paramcount	int
,	O
params	pointer
,	O
1	int
,	O
I	array
,	O
spec	struct
->	O
directives	int
,	O
invalid_reason	pointer
)	O
)	O
{	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
*	O
formatp	pointer
=	O
format	pointer
;	O
{	O
int	O
sub_position	int
=	O
0	int
;	O
struct	O
format_arg_list	struct
*	O
sub_list	pointer
=	O
make_unconstrained_list	function
(	O
)	O
;	O
struct	O
format_arg_list	struct
*	O
sub_escape	pointer
=	O
NULL	O
;	O
struct	O
spec	struct
sub_spec	struct
;	O
sub_spec	struct
.	O
directives	int
=	O
0	int
;	O
sub_spec	struct
.	O
list	pointer
=	O
sub_list	pointer
;	O
if	O
(	O
!	O
parse_upto	function
(	O
formatp	pointer
,	O
&	O
sub_position	int
,	O
&	O
sub_list	pointer
,	O
&	O
sub_escape	pointer
,	O
NULL	O
,	O
&	O
sub_spec	struct
,	O
'}'	O
,	O
false	int
,	O
NULL	O
,	O
invalid_reason	pointer
)	O
)	O
{	O
FDI_SET	O
(	O
*	O
*	O
formatp	pointer
==	O
'\0'	O
?	O
*	O
formatp	pointer
-	O
1	int
:	O
*	O
formatp	pointer
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
spec	struct
->	O
directives	int
+=	O
sub_spec	struct
.	O
directives	int
;	O
if	O
(	O
*	O
format	pointer
==	O
'~'	O
&&	O
sub_spec	struct
.	O
directives	int
==	O
1	int
)	O
if	O
(	O
position	int
>=	O
0	int
)	O
add_req_type_constraint	function
(	O
&	O
list	pointer
,	O
position	int
++	O
,	O
FAT_FORMATSTRING	int
)	O
;	O
if	O
(	O
colon_p	bool
)	O
{	O
struct	O
format_arg_list	struct
*	O
listlist	pointer
;	O
sub_list	pointer
=	O
union	O
(	O
sub_list	pointer
,	O
sub_escape	pointer
)	O
;	O
listlist	pointer
=	O
make_repeated_list_of_lists	function
(	O
sub_list	pointer
)	O
;	O
sub_list	pointer
=	O
listlist	pointer
;	O
}	O
else	O
{	O
struct	O
format_arg_list	struct
*	O
looplist	pointer
;	O
sub_list	pointer
=	O
union	O
(	O
sub_list	pointer
,	O
sub_escape	pointer
)	O
;	O
if	O
(	O
sub_list	pointer
==	O
NULL	O
)	O
looplist	pointer
=	O
make_empty_list	function
(	O
)	O
;	O
else	O
if	O
(	O
sub_position	int
<	O
0	int
||	O
sub_position	int
==	O
0	int
)	O
looplist	pointer
=	O
make_union_with_empty_list	function
(	O
sub_list	pointer
)	O
;	O
else	O
looplist	pointer
=	O
make_repeated_list	function
(	O
sub_list	pointer
,	O
sub_position	int
)	O
;	O
sub_list	pointer
=	O
looplist	pointer
;	O
}	O
if	O
(	O
atsign_p	bool
)	O
{	O
if	O
(	O
list	pointer
!=	O
NULL	O
&&	O
position	int
>=	O
0	int
)	O
{	O
shift_list	function
(	O
sub_list	pointer
,	O
position	int
)	O
;	O
list	pointer
=	O
make_intersected_list	function
(	O
list	pointer
,	O
sub_list	pointer
)	O
;	O
}	O
position	int
=	O
-	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
position	int
>=	O
0	int
)	O
add_req_listtype_constraint	function
(	O
&	O
list	pointer
,	O
position	int
++	O
,	O
FAT_LIST	int
,	O
sub_list	pointer
)	O
;	O
}	O
}	O
format	pointer
=	O
*	O
formatp	pointer
;	O
break	O
;	O
case	O
'}'	O
:	O
if	O
(	O
terminator	char
!=	O
'}'	O
)	O
{	O
*	O
invalid_reason	pointer
=	O
xasprintf	function
(	O
_	O
(	O
"Found '~%c' without matching '~%c'."	pointer
)	O
,	O
'}'	O
,	O
'{'	O
)	O
;	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
!	O
check_params	function
(	O
&	O
list	pointer
,	O
paramcount	int
,	O
params	pointer
,	O
0	int
,	O
NULL	O
,	O
spec	struct
->	O
directives	int
,	O
invalid_reason	pointer
)	O
)	O
{	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
*	O
formatp	pointer
=	O
format	pointer
;	O
*	O
positionp	pointer
=	O
position	int
;	O
*	O
listp	pointer
=	O
list	pointer
;	O
*	O
escapep	pointer
=	O
escape	pointer
;	O
return	O
true	int
;	O
case	O
'<'	O
:	O
if	O
(	O
!	O
check_params	function
(	O
&	O
list	pointer
,	O
paramcount	int
,	O
params	pointer
,	O
4	int
,	O
IIIC	array
,	O
spec	struct
->	O
directives	int
,	O
invalid_reason	pointer
)	O
)	O
{	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
{	O
struct	O
format_arg_list	struct
*	O
sub_escape	pointer
=	O
NULL	O
;	O
*	O
formatp	pointer
=	O
format	pointer
;	O
*	O
positionp	pointer
=	O
position	int
;	O
*	O
listp	pointer
=	O
list	pointer
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
sub_separator	int
=	O
0	int
;	O
if	O
(	O
!	O
parse_upto	function
(	O
formatp	pointer
,	O
positionp	pointer
,	O
listp	pointer
,	O
&	O
sub_escape	pointer
,	O
&	O
sub_separator	int
,	O
spec	struct
,	O
'>'	O
,	O
true	int
,	O
NULL	O
,	O
invalid_reason	pointer
)	O
)	O
{	O
FDI_SET	O
(	O
*	O
*	O
formatp	pointer
==	O
'\0'	O
?	O
*	O
formatp	pointer
-	O
1	int
:	O
*	O
formatp	pointer
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
!	O
sub_separator	int
)	O
break	O
;	O
}	O
format	pointer
=	O
*	O
formatp	pointer
;	O
position	int
=	O
*	O
positionp	pointer
;	O
list	pointer
=	O
*	O
listp	pointer
;	O
if	O
(	O
sub_escape	pointer
!=	O
NULL	O
)	O
position	int
=	O
-	O
1	int
;	O
list	pointer
=	O
union	O
(	O
list	pointer
,	O
sub_escape	pointer
)	O
;	O
}	O
break	O
;	O
case	O
'>'	O
:	O
if	O
(	O
terminator	char
!=	O
'>'	O
)	O
{	O
*	O
invalid_reason	pointer
=	O
xasprintf	function
(	O
_	O
(	O
"Found '~%c' without matching '~%c'."	pointer
)	O
,	O
'>'	O
,	O
'<'	O
)	O
;	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
!	O
check_params	function
(	O
&	O
list	pointer
,	O
paramcount	int
,	O
params	pointer
,	O
0	int
,	O
NULL	O
,	O
spec	struct
->	O
directives	int
,	O
invalid_reason	pointer
)	O
)	O
{	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
*	O
formatp	pointer
=	O
format	pointer
;	O
*	O
positionp	pointer
=	O
position	int
;	O
*	O
listp	pointer
=	O
list	pointer
;	O
*	O
escapep	pointer
=	O
escape	pointer
;	O
return	O
true	int
;	O
case	O
'^'	O
:	O
if	O
(	O
!	O
check_params	function
(	O
&	O
list	pointer
,	O
paramcount	int
,	O
params	pointer
,	O
3	int
,	O
THREE	array
,	O
spec	struct
->	O
directives	int
,	O
invalid_reason	pointer
)	O
)	O
{	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
position	int
>=	O
0	int
&&	O
list	pointer
!=	O
NULL	O
&&	O
is_required	function
(	O
list	pointer
,	O
position	int
)	O
)	O
break	O
;	O
if	O
(	O
list	pointer
!=	O
NULL	O
)	O
{	O
struct	O
format_arg_list	struct
*	O
this_escape	pointer
=	O
copy_list	function
(	O
list	pointer
)	O
;	O
if	O
(	O
position	int
>=	O
0	int
)	O
this_escape	pointer
=	O
add_end_constraint	function
(	O
this_escape	pointer
,	O
position	int
)	O
;	O
escape	pointer
=	O
union	O
(	O
escape	pointer
,	O
this_escape	pointer
)	O
;	O
}	O
if	O
(	O
position	int
>=	O
0	int
)	O
list	pointer
=	O
add_required_constraint	function
(	O
list	pointer
,	O
position	int
)	O
;	O
break	O
;	O
case	O
';'	O
:	O
if	O
(	O
!	O
separator	pointer
)	O
{	O
*	O
invalid_reason	pointer
=	O
xasprintf	function
(	O
_	O
(	O
"In the directive number %u, '~;' is used in an invalid position."	pointer
)	O
,	O
spec	struct
->	O
directives	int
)	O
;	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
terminator	char
==	O
'>'	O
)	O
{	O
if	O
(	O
!	O
check_params	function
(	O
&	O
list	pointer
,	O
paramcount	int
,	O
params	pointer
,	O
1	int
,	O
I	array
,	O
spec	struct
->	O
directives	int
,	O
invalid_reason	pointer
)	O
)	O
{	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
check_params	function
(	O
&	O
list	pointer
,	O
paramcount	int
,	O
params	pointer
,	O
0	int
,	O
NULL	O
,	O
spec	struct
->	O
directives	int
,	O
invalid_reason	pointer
)	O
)	O
{	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
}	O
*	O
formatp	pointer
=	O
format	pointer
;	O
*	O
positionp	pointer
=	O
position	int
;	O
*	O
listp	pointer
=	O
list	pointer
;	O
*	O
escapep	pointer
=	O
escape	pointer
;	O
*	O
separatorp	pointer
=	O
(	O
colon_p	bool
?	O
2	int
:	O
1	int
)	O
;	O
return	O
true	int
;	O
case	O
'!'	O
:	O
if	O
(	O
!	O
nocheck_params	function
(	O
&	O
list	pointer
,	O
paramcount	int
,	O
params	pointer
,	O
spec	struct
->	O
directives	int
,	O
invalid_reason	pointer
)	O
)	O
{	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
position	int
>=	O
0	int
)	O
{	O
add_req_type_constraint	function
(	O
&	O
list	pointer
,	O
position	int
++	O
,	O
FAT_FUNCTION	int
)	O
;	O
add_req_type_constraint	function
(	O
&	O
list	pointer
,	O
position	int
++	O
,	O
FAT_OBJECT	int
)	O
;	O
}	O
break	O
;	O
default	O
:	O
--	O
format	pointer
;	O
if	O
(	O
*	O
format	pointer
==	O
'\0'	O
)	O
{	O
*	O
invalid_reason	pointer
=	O
INVALID_UNTERMINATED_DIRECTIVE	O
(	O
)	O
;	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_ERROR	int
)	O
;	O
}	O
else	O
{	O
*	O
invalid_reason	pointer
=	O
INVALID_CONVERSION_SPECIFIER	O
(	O
spec	struct
->	O
directives	int
,	O
*	O
format	pointer
)	O
;	O
FDI_SET	O
(	O
format	pointer
,	O
FMTDIR_ERROR	int
)	O
;	O
}	O
return	O
false	int
;	O
}	O
FDI_SET	O
(	O
format	pointer
-	O
1	int
,	O
FMTDIR_END	int
)	O
;	O
free	function
(	O
params	pointer
)	O
;	O
}	O
*	O
formatp	pointer
=	O
format	pointer
;	O
*	O
positionp	pointer
=	O
position	int
;	O
*	O
listp	pointer
=	O
list	pointer
;	O
*	O
escapep	pointer
=	O
escape	pointer
;	O
if	O
(	O
terminator	char
!=	O
'\0'	O
)	O
{	O
*	O
invalid_reason	pointer
=	O
xasprintf	function
(	O
_	O
(	O
"Found '~%c' without matching '~%c'."	pointer
)	O
,	O
terminator	char
-	O
1	int
,	O
terminator	char
)	O
;	O
return	O
false	int
;	O
}	O
return	O
true	int
;	O
}	O
static	O
void	O
*	O
format_parse	function
(	O
const	O
char	O
*	O
format	pointer
,	O
bool	bool
translated	bool
,	O
char	O
*	O
fdi	pointer
,	O
char	O
*	O
*	O
invalid_reason	pointer
)	O
{	O
struct	O
spec	struct
spec	struct
;	O
struct	O
spec	struct
*	O
result	pointer
;	O
int	O
position	int
=	O
0	int
;	O
struct	O
format_arg_list	struct
*	O
escape	pointer
;	O
spec	struct
.	O
directives	int
=	O
0	int
;	O
spec	struct
.	O
list	pointer
=	O
make_unconstrained_list	function
(	O
)	O
;	O
escape	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
parse_upto	function
(	O
&	O
format	pointer
,	O
&	O
position	int
,	O
&	O
spec	struct
.	O
list	pointer
,	O
&	O
escape	pointer
,	O
NULL	O
,	O
&	O
spec	struct
,	O
'\0'	O
,	O
false	int
,	O
fdi	pointer
,	O
invalid_reason	pointer
)	O
)	O
return	O
NULL	O
;	O
spec	struct
.	O
list	pointer
=	O
union	O
(	O
spec	struct
.	O
list	pointer
,	O
escape	pointer
)	O
;	O
if	O
(	O
spec	struct
.	O
list	pointer
==	O
NULL	O
)	O
{	O
*	O
invalid_reason	pointer
=	O
xstrdup	function
(	O
_	O
(	O
"The string refers to some argument in incompatible ways."	pointer
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
normalize_list	function
(	O
spec	struct
.	O
list	pointer
)	O
;	O
result	pointer
=	O
XMALLOC	O
(	O
struct	O
spec	struct
)	O
;	O
*	O
result	pointer
=	O
spec	struct
;	O
return	O
result	pointer
;	O
}	O
static	O
void	O
format_free	function
(	O
void	O
*	O
descr	pointer
)	O
{	O
struct	O
spec	struct
*	O
spec	struct
=	O
(	O
struct	O
spec	struct
*	O
)	O
descr	pointer
;	O
free_list	function
(	O
spec	struct
->	O
list	pointer
)	O
;	O
}	O
static	O
int	O
format_get_number_of_directives	function
(	O
void	O
*	O
descr	pointer
)	O
{	O
struct	O
spec	struct
*	O
spec	struct
=	O
(	O
struct	O
spec	struct
*	O
)	O
descr	pointer
;	O
return	O
spec	struct
->	O
directives	int
;	O
}	O
static	O
bool	bool
format_check	function
(	O
void	O
*	O
msgid_descr	pointer
,	O
void	O
*	O
msgstr_descr	pointer
,	O
bool	bool
equality	bool
,	O
formatstring_error_logger_t	pointer
error_logger	pointer
,	O
const	O
char	O
*	O
pretty_msgid	pointer
,	O
const	O
char	O
*	O
pretty_msgstr	pointer
)	O
{	O
struct	O
spec	struct
*	O
spec1	pointer
=	O
(	O
struct	O
spec	struct
*	O
)	O
msgid_descr	pointer
;	O
struct	O
spec	struct
*	O
spec2	pointer
=	O
(	O
struct	O
spec	struct
*	O
)	O
msgstr_descr	pointer
;	O
bool	bool
err	long
=	O
false	int
;	O
if	O
(	O
equality	bool
)	O
{	O
if	O
(	O
!	O
equal_list	function
(	O
spec1	pointer
->	O
list	pointer
,	O
spec2	pointer
->	O
list	pointer
)	O
)	O
{	O
if	O
(	O
error_logger	pointer
)	O
error_logger	pointer
(	O
_	O
(	O
"format specifications in '%s' and '%s' are not equivalent"	pointer
)	O
,	O
pretty_msgid	pointer
,	O
pretty_msgstr	pointer
)	O
;	O
err	long
=	O
true	int
;	O
}	O
}	O
else	O
{	O
struct	O
format_arg_list	struct
*	O
intersection	pointer
=	O
make_intersected_list	function
(	O
copy_list	function
(	O
spec1	pointer
->	O
list	pointer
)	O
,	O
copy_list	function
(	O
spec2	pointer
->	O
list	pointer
)	O
)	O
;	O
if	O
(	O
!	O
(	O
intersection	pointer
!=	O
NULL	O
&&	O
(	O
normalize_list	function
(	O
intersection	pointer
)	O
,	O
equal_list	function
(	O
intersection	pointer
,	O
spec2	pointer
->	O
list	pointer
)	O
)	O
)	O
)	O
{	O
if	O
(	O
error_logger	pointer
)	O
error_logger	pointer
(	O
_	O
(	O
"format specifications in '%s' are not a subset of those in '%s'"	pointer
)	O
,	O
pretty_msgstr	pointer
,	O
pretty_msgid	pointer
)	O
;	O
err	long
=	O
true	int
;	O
}	O
}	O
return	O
err	long
;	O
}	O
struct	O
formatstring_parser	struct
formatstring_lisp	struct
=	O
{	O
format_parse	function
,	O
format_free	function
,	O
format_get_number_of_directives	function
,	O
NULL	O
,	O
format_check	function
}	O
;	O
