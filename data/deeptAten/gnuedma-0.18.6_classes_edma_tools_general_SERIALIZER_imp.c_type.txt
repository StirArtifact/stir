typedef	O
struct	O
{	O
EDMAT_BUFFER	struct
buffer	struct
;	O
}	O
DtSERIALIZER	struct
;	O
typedef	O
struct	O
{	O
ESint32	int
type	long
;	O
ESint32	int
size	int
;	O
unsigned	O
char	O
data	array
[	O
1	int
]	O
;	O
}	O
PROP_RECORD	struct
;	O
typedef	O
struct	O
{	O
EChar	char
class_name	array
[	O
EDMA_CLASS_NAME_LEN	int
]	O
;	O
PROP_RECORD	struct
data	array
[	O
1	int
]	O
;	O
}	O
OBJECT_RECORD	struct
;	O
ESint32	int
EDMAPROC	O
SERIALIZERmarshallOrS32	function
(	O
OBJID	int
IdObj	int
,	O
OBJID	int
id	int
)	O
{	O
DtSERIALIZER	struct
*	O
m	pointer
;	O
CLASSID	int
cid	int
;	O
ESint32	int
n_prop	int
;	O
unsigned	O
char	O
*	O
data	array
;	O
EUint32	long
type	long
,	O
size	int
,	O
new_size	long
,	O
old_size	long
,	O
i	int
;	O
EChar	char
prop_name	array
[	O
EDMA_PROP_NAME_LEN	O
]	O
;	O
EDMAT_BUFFER	struct
aux	struct
;	O
unsigned	O
char	O
base_type	array
[	O
8	int
]	O
;	O
PROP_RECORD	struct
*	O
item	pointer
;	O
m	pointer
=	O
(	O
DtSERIALIZER	struct
*	O
)	O
edma_get_data_ref	function
(	O
IdObj	int
)	O
;	O
if	O
(	O
(	O
cid	int
=	O
edma_get_obj_class_id	function
(	O
id	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	function
(	O
IdObj	int
,	O
"** ERROR ** Can't get class id for object %d"	pointer
,	O
id	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
n_prop	int
=	O
edma_get_prop_num	function
(	O
cid	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	function
(	O
IdObj	int
,	O
"** ERROR ** Can't get number of properties "	pointer
"for class id %ld"	pointer
,	O
cid	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
edma_buffer_alloc	function
(	O
&	O
m	pointer
->	O
buffer	struct
,	O
sizeof	O
(	O
OBJECT_RECORD	struct
)	O
)	O
;	O
edma_get_class_name	function
(	O
cid	int
,	O
(	O
(	O
OBJECT_RECORD	struct
*	O
)	O
m	pointer
->	O
buffer	struct
.	O
dat	pointer
)	O
->	O
class_name	array
)	O
;	O
new_size	long
=	O
0	int
;	O
old_size	long
=	O
EDMA_CLASS_NAME_LEN	int
;	O
m	pointer
->	O
buffer	struct
.	O
dat	pointer
=	O
NULL	O
;	O
m	pointer
->	O
buffer	struct
.	O
Size	long
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_prop	int
;	O
i	int
++	O
)	O
{	O
edma_get_prop_name	function
(	O
cid	int
,	O
i	int
,	O
prop_name	array
)	O
;	O
type	long
=	O
edma_get_prop_type_id	function
(	O
cid	int
,	O
i	int
)	O
;	O
size	int
=	O
edma_get_type_size	function
(	O
type	long
)	O
;	O
switch	O
(	O
type	long
)	O
{	O
case	O
DT_EBUFFER	int
:	O
edma_rprop3	function
(	O
id	int
,	O
prop_name	array
,	O
&	O
aux	struct
)	O
;	O
size	int
=	O
aux	struct
.	O
Size	long
;	O
break	O
;	O
}	O
new_size	long
=	O
old_size	long
+	O
sizeof	O
(	O
PROP_RECORD	struct
)	O
+	O
size	int
;	O
edma_buffer_realloc	function
(	O
&	O
m	pointer
->	O
buffer	struct
,	O
new_size	long
)	O
;	O
item	pointer
=	O
(	O
PROP_RECORD	struct
*	O
)	O
(	O
(	O
EPByte	pointer
)	O
m	pointer
->	O
buffer	struct
.	O
dat	pointer
+	O
old_size	long
)	O
;	O
item	pointer
->	O
type	long
=	O
type	long
;	O
item	pointer
->	O
size	int
=	O
size	int
;	O
switch	O
(	O
type	long
)	O
{	O
case	O
DT_EBUFFER	int
:	O
data	array
=	O
(	O
unsigned	O
char	O
*	O
)	O
aux	struct
.	O
dat	pointer
;	O
memcpy	function
(	O
item	pointer
->	O
data	array
,	O
data	array
,	O
size	int
)	O
;	O
break	O
;	O
default	O
:	O
edma_rprop3	function
(	O
id	int
,	O
prop_name	array
,	O
&	O
base_type	array
)	O
;	O
data	array
=	O
base_type	array
;	O
memcpy	function
(	O
item	pointer
->	O
data	array
,	O
data	array
,	O
size	int
)	O
;	O
break	O
;	O
}	O
old_size	long
=	O
new_size	long
;	O
}	O
edma_printf_obj	function
(	O
IdObj	int
,	O
"%s"	pointer
,	O
"-------------------------------------------"	pointer
)	O
;	O
edma_printf_obj	function
(	O
IdObj	int
,	O
"Class name : %s"	pointer
,	O
(	O
EPChar	pointer
)	O
m	pointer
->	O
buffer	struct
.	O
dat	pointer
)	O
;	O
item	pointer
=	O
(	O
PROP_RECORD	struct
*	O
)	O
(	O
(	O
OBJECT_RECORD	struct
*	O
)	O
m	pointer
->	O
buffer	struct
.	O
dat	pointer
)	O
->	O
data	array
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_prop	int
;	O
i	int
++	O
)	O
{	O
edma_printf_obj	function
(	O
IdObj	int
,	O
"Type = %ld Size = %ld"	pointer
,	O
item	pointer
->	O
type	long
,	O
item	pointer
->	O
size	int
)	O
;	O
item	pointer
=	O
(	O
PROP_RECORD	struct
*	O
)	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
item	pointer
+	O
item	pointer
->	O
size	int
+	O
sizeof	O
(	O
PROP_RECORD	struct
)	O
)	O
;	O
}	O
edma_printf_obj	function
(	O
IdObj	int
,	O
"Marshall done!!! <------------------------->"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	int
EDMAPROC	O
SERIALIZERunmarshallsOrS32	function
(	O
OBJID	int
IdObj	int
,	O
OBJID	int
*	O
id	int
)	O
{	O
DtSERIALIZER	struct
*	O
m	pointer
;	O
PROP_RECORD	struct
*	O
item	pointer
;	O
ESint32	int
i	int
,	O
n_prop	int
;	O
EDMAT_BUFFER	struct
*	O
aux	struct
;	O
CLASSID	int
cid	int
;	O
m	pointer
=	O
(	O
DtSERIALIZER	struct
*	O
)	O
edma_get_data_ref	function
(	O
IdObj	int
)	O
;	O
edma_printf_obj	function
(	O
IdObj	int
,	O
"Class name : %s"	pointer
,	O
(	O
EPChar	pointer
)	O
m	pointer
->	O
buffer	struct
.	O
dat	pointer
)	O
;	O
if	O
(	O
(	O
cid	int
=	O
edma_get_class_id	function
(	O
(	O
EPChar	pointer
)	O
m	pointer
->	O
buffer	struct
.	O
dat	pointer
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	function
(	O
IdObj	int
,	O
"Wrong class name. Data inconsistent"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
n_prop	int
=	O
edma_get_prop_num	function
(	O
cid	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	function
(	O
IdObj	int
,	O
"** ERROR ** Can't get number of properties "	pointer
"for class id %ld"	pointer
,	O
cid	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
item	pointer
=	O
(	O
PROP_RECORD	struct
*	O
)	O
(	O
(	O
OBJECT_RECORD	struct
*	O
)	O
m	pointer
->	O
buffer	struct
.	O
dat	pointer
)	O
->	O
data	array
;	O
edma_printf_obj	function
(	O
IdObj	int
,	O
"Pointer : %p [%d] properties to read"	pointer
,	O
item	pointer
,	O
n_prop	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_prop	int
;	O
i	int
++	O
)	O
{	O
edma_printf_obj	function
(	O
IdObj	int
,	O
"Type = %ld Size = %ld"	pointer
,	O
item	pointer
->	O
type	long
,	O
item	pointer
->	O
size	int
)	O
;	O
switch	O
(	O
item	pointer
->	O
type	long
)	O
{	O
case	O
DT_EBUFFER	int
:	O
aux	struct
=	O
(	O
EDMAT_BUFFER	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
EDMAT_BUFFER	struct
)	O
)	O
;	O
edma_buffer_alloc	function
(	O
aux	struct
,	O
item	pointer
->	O
size	int
)	O
;	O
memcpy	function
(	O
aux	struct
->	O
dat	pointer
,	O
item	pointer
->	O
data	array
,	O
item	pointer
->	O
size	int
)	O
;	O
_edma_wprop1_pargs	function
(	O
*	O
id	int
,	O
i	int
,	O
aux	struct
)	O
;	O
break	O
;	O
default	O
:	O
_edma_wprop1_pargs	function
(	O
*	O
id	int
,	O
i	int
,	O
item	pointer
->	O
data	array
)	O
;	O
}	O
item	pointer
=	O
(	O
PROP_RECORD	struct
*	O
)	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
item	pointer
+	O
item	pointer
->	O
size	int
+	O
sizeof	O
(	O
PROP_RECORD	struct
)	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
ESint32	int
EDMAPROC	O
SERIALIZERsaveZrS32	function
(	O
OBJID	int
IdObj	int
,	O
EPChar	pointer
fname	pointer
)	O
{	O
DtSERIALIZER	struct
*	O
m	pointer
;	O
OBJID	int
id	int
;	O
ESint32	int
len	int
;	O
m	pointer
=	O
(	O
DtSERIALIZER	struct
*	O
)	O
edma_get_data_ref	function
(	O
IdObj	int
)	O
;	O
if	O
(	O
(	O
id	int
=	O
edma_new_obj	function
(	O
"NFILE"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	function
(	O
IdObj	int
,	O
"[ERROR] Can't create 'NFILE' object"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
edma_met3	function
(	O
id	int
,	O
"open"	pointer
,	O
fname	pointer
,	O
"wb"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	function
(	O
IdObj	int
,	O
"Can't open %s file to save data"	pointer
,	O
fname	pointer
)	O
;	O
edma_free_obj	function
(	O
id	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
len	int
=	O
m	pointer
->	O
buffer	struct
.	O
Size	long
;	O
if	O
(	O
(	O
edma_met3	function
(	O
id	int
,	O
"write"	pointer
,	O
m	pointer
->	O
buffer	struct
,	O
&	O
len	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	function
(	O
IdObj	int
,	O
"Can't write data to file"	pointer
)	O
;	O
edma_free_obj	function
(	O
id	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
edma_met3	function
(	O
id	int
,	O
"close"	pointer
)	O
;	O
edma_free_obj	function
(	O
id	int
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	int
EDMAPROC	O
SERIALIZERloadZrS32	function
(	O
OBJID	int
IdObj	int
,	O
EPChar	pointer
fname	pointer
)	O
{	O
DtSERIALIZER	struct
*	O
m	pointer
;	O
OBJID	int
id	int
;	O
ESint32	int
len	int
;	O
m	pointer
=	O
(	O
DtSERIALIZER	struct
*	O
)	O
edma_get_data_ref	function
(	O
IdObj	int
)	O
;	O
if	O
(	O
(	O
id	int
=	O
edma_new_obj	function
(	O
"NFILE"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	function
(	O
IdObj	int
,	O
"[ERROR] Can't create 'NFILE' object"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
edma_met3	function
(	O
id	int
,	O
"open"	pointer
,	O
fname	pointer
,	O
"rb"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	function
(	O
IdObj	int
,	O
"Can't open %s file to read data"	pointer
,	O
fname	pointer
)	O
;	O
edma_free_obj	function
(	O
id	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
len	int
=	O
(	O
ESint32	int
)	O
edma_smet3	function
(	O
"FILESYSTEM"	pointer
,	O
"GetFileSize"	pointer
,	O
fname	pointer
)	O
;	O
edma_printf_obj	function
(	O
IdObj	int
,	O
"[INFO] About to read %ld bytes from file %s"	pointer
,	O
len	int
,	O
fname	pointer
)	O
;	O
if	O
(	O
m	pointer
->	O
buffer	struct
.	O
dat	pointer
)	O
edma_buffer_free	function
(	O
&	O
m	pointer
->	O
buffer	struct
)	O
;	O
edma_buffer_alloc	function
(	O
&	O
m	pointer
->	O
buffer	struct
,	O
len	int
)	O
;	O
if	O
(	O
(	O
edma_met3	function
(	O
id	int
,	O
"read"	pointer
,	O
&	O
m	pointer
->	O
buffer	struct
,	O
&	O
len	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	function
(	O
IdObj	int
,	O
"Can't write data to file"	pointer
)	O
;	O
edma_free_obj	function
(	O
id	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
edma_met3	function
(	O
id	int
,	O
"close"	pointer
)	O
;	O
edma_free_obj	function
(	O
id	int
)	O
;	O
return	O
0	int
;	O
}	O
