static	O
BOOL	int
vbSwitchGauss	int
=	O
FALSE	int
;	O
typedef	O
struct	O
tagRANDREC	struct
{	O
double	O
seed	double
;	O
}	O
RANDREC	struct
,	O
*	O
PRANDREC	pointer
;	O
static	O
BOOL	int
vbNoSeed	int
=	O
TRUE	int
;	O
static	O
BOOL	int
vbNotInitd	int
=	O
TRUE	int
;	O
static	O
RANDREC	struct
vRandRec	struct
;	O
double	O
GetSeed	function
(	O
void	O
)	O
{	O
return	O
(	O
vRandRec	struct
.	O
seed	double
)	O
;	O
}	O
void	O
SetSeed	function
(	O
double	O
dSeed	double
)	O
{	O
int	O
bCorrected	int
=	O
0	int
;	O
if	O
(	O
dSeed	double
==	O
0.0	int
)	O
{	O
dSeed	double
=	O
SEED_DEFAULT	int
;	O
bCorrected	int
++	O
;	O
}	O
if	O
(	O
dSeed	double
<	O
0	int
)	O
dSeed	double
=	O
-	O
dSeed	double
;	O
if	O
(	O
dSeed	double
<	O
SEED_MIN	int
)	O
{	O
dSeed	double
=	O
SEED_MIN	int
+	O
(	O
dSeed	double
/	O
SEED_MIN	int
)	O
/	O
(	O
SEED_MAX	int
-	O
SEED_MIN	int
)	O
;	O
bCorrected	int
++	O
;	O
}	O
if	O
(	O
dSeed	double
>	O
SEED_MAX	int
)	O
{	O
dSeed	double
=	O
SEED_MIN	int
+	O
(	O
SEED_MAX	int
/	O
dSeed	double
)	O
/	O
(	O
SEED_MAX	int
-	O
SEED_MIN	int
)	O
;	O
bCorrected	int
++	O
;	O
}	O
assert	O
(	O
(	O
dSeed	double
>=	O
SEED_MIN	int
&&	O
dSeed	double
<=	O
SEED_MAX	int
)	O
)	O
;	O
if	O
(	O
bCorrected	int
)	O
printf	function
(	O
"SetSeed():  corrected out of range random number seed\n"	pointer
"Seed must lie in the range [%g, %g]\n"	pointer
"New seed --> %g\n"	pointer
,	O
SEED_MIN	int
,	O
SEED_MAX	int
,	O
dSeed	double
)	O
;	O
vRandRec	struct
.	O
seed	double
=	O
dSeed	double
;	O
vbNoSeed	int
=	O
FALSE	int
;	O
vbSwitchGauss	int
=	O
FALSE	int
;	O
}	O
void	O
InitRandom	function
(	O
int	O
rank	int
,	O
double	O
dSeed	double
,	O
int	O
bWarmUp	int
)	O
{	O
long	O
i	long
;	O
if	O
(	O
vbNoSeed	int
||	O
dSeed	double
!=	O
SEED_DEFAULT	int
)	O
SetSeed	function
(	O
dSeed	double
)	O
;	O
if	O
(	O
bWarmUp	int
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
50	int
;	O
i	long
++	O
)	O
(	O
void	O
)	O
Randoms	function
(	O
)	O
;	O
vbNotInitd	int
=	O
FALSE	int
;	O
}	O
}	O
double	O
Randoms	function
(	O
void	O
)	O
{	O
double	O
hi	double
,	O
test	double
;	O
if	O
(	O
vbNoSeed	int
)	O
SetSeed	function
(	O
SEED_DEFAULT	int
)	O
;	O
hi	double
=	O
(	O
long	O
)	O
(	O
vRandRec	struct
.	O
seed	double
/	O
q	int
)	O
;	O
test	double
=	O
a	double
*	O
(	O
vRandRec	struct
.	O
seed	double
-	O
q	int
*	O
hi	double
)	O
-	O
r	int
*	O
hi	double
;	O
if	O
(	O
test	double
>	O
0.0	int
)	O
vRandRec	struct
.	O
seed	double
=	O
test	double
;	O
else	O
vRandRec	struct
.	O
seed	double
=	O
test	double
+	O
m	int
;	O
return	O
(	O
vRandRec	struct
.	O
seed	double
/	O
m	int
)	O
;	O
}	O
double	O
BetaRandom	function
(	O
double	O
alpha	double
,	O
double	O
beta	double
,	O
double	O
a	double
,	O
double	O
b	double
)	O
{	O
double	O
u1	double
,	O
u2	double
,	O
w	pointer
;	O
if	O
(	O
b	double
<=	O
a	double
||	O
alpha	double
<=	O
0	int
||	O
beta	double
<=	O
0	int
)	O
{	O
printf	function
(	O
"Error: bad shape or range for a beta variate - Exiting\n\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
if	O
(	O
(	O
alpha	double
<	O
1	int
)	O
&&	O
(	O
beta	double
<	O
1	int
)	O
)	O
do	O
{	O
u1	double
=	O
Randoms	function
(	O
)	O
;	O
u2	double
=	O
Randoms	function
(	O
)	O
;	O
u1	double
=	O
pow	function
(	O
u1	double
,	O
1	int
/	O
alpha	double
)	O
;	O
u2	double
=	O
pow	function
(	O
u2	double
,	O
1	int
/	O
beta	double
)	O
;	O
w	pointer
=	O
u1	double
+	O
u2	double
;	O
}	O
while	O
(	O
w	pointer
>	O
1.0	int
)	O
;	O
else	O
{	O
u1	double
=	O
GammaRandom	function
(	O
alpha	double
)	O
;	O
u2	double
=	O
GammaRandom	function
(	O
beta	double
)	O
;	O
w	pointer
=	O
u1	double
+	O
u2	double
;	O
}	O
return	O
(	O
a	double
+	O
(	O
u1	double
/	O
w	pointer
)	O
*	O
(	O
b	double
-	O
a	double
)	O
)	O
;	O
}	O
double	O
BinomialBetaRandom	function
(	O
double	O
Expectation	double
,	O
double	O
alpha	double
,	O
double	O
beta	double
)	O
{	O
double	O
dTmp	double
=	O
Expectation	double
+	O
Expectation	double
*	O
beta	double
/	O
alpha	double
;	O
if	O
(	O
dTmp	double
<	O
LONG_MAX	O
)	O
return	O
BinomialRandom	function
(	O
BetaRandom	function
(	O
alpha	double
,	O
beta	double
,	O
0	int
,	O
1	int
)	O
,	O
(	O
long	O
)	O
dTmp	double
)	O
;	O
else	O
{	O
printf	function
(	O
"BinomialBetaRandom: N (= %g) too large - Exiting..."	pointer
,	O
dTmp	double
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
}	O
double	O
BinomialRandom	function
(	O
double	O
p	double
,	O
long	O
N	long
)	O
{	O
long	O
j	long
;	O
static	O
long	O
iOldN	long
=	O
-	O
1	int
;	O
double	O
dAngle	double
,	O
dDeviate	double
,	O
dMean	double
,	O
dPtemp	double
,	O
dSqrt	double
,	O
dTangent	double
,	O
dTemp1	double
,	O
dTemp2	double
;	O
static	O
double	O
dLnFactN	double
,	O
dPold	double
=	O
-	O
1	int
,	O
dLnP	double
,	O
dQ	double
,	O
dLnQ	double
;	O
if	O
(	O
p	double
<	O
0	int
||	O
p	double
>	O
1	int
||	O
N	long
<	O
0	int
)	O
{	O
printf	function
(	O
"Error: parameters out of bounds for a binomial variate "	pointer
"- Exiting\n\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
dPtemp	double
=	O
(	O
p	double
<=	O
0.5	int
?	O
p	double
:	O
1	int
-	O
p	double
)	O
;	O
dMean	double
=	O
N	long
*	O
dPtemp	double
;	O
if	O
(	O
N	long
<	O
25	int
)	O
{	O
dDeviate	double
=	O
0	int
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
N	long
;	O
j	long
++	O
)	O
if	O
(	O
Randoms	function
(	O
)	O
<	O
dPtemp	double
)	O
dDeviate	double
=	O
dDeviate	double
+	O
1	int
;	O
}	O
else	O
if	O
(	O
dMean	double
<	O
1	int
)	O
{	O
dTemp1	double
=	O
exp	function
(	O
-	O
dMean	double
)	O
;	O
dTemp2	double
=	O
1.0	int
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<=	O
N	long
;	O
j	long
++	O
)	O
{	O
dTemp2	double
=	O
dTemp2	double
*	O
Randoms	function
(	O
)	O
;	O
if	O
(	O
dTemp2	double
<	O
dTemp1	double
)	O
break	O
;	O
}	O
dDeviate	double
=	O
(	O
j	long
<=	O
N	long
?	O
j	long
:	O
N	long
)	O
;	O
}	O
else	O
{	O
if	O
(	O
N	long
!=	O
iOldN	long
)	O
{	O
dLnFactN	double
=	O
lnGamma	function
(	O
(	O
double	O
)	O
N	long
+	O
1	int
)	O
;	O
iOldN	long
=	O
N	long
;	O
}	O
if	O
(	O
dPtemp	double
!=	O
dPold	double
)	O
{	O
dPold	double
=	O
dPtemp	double
;	O
dQ	double
=	O
1	int
-	O
dPtemp	double
;	O
dLnP	double
=	O
log	function
(	O
dPtemp	double
)	O
;	O
dLnQ	double
=	O
log	function
(	O
dQ	double
)	O
;	O
}	O
dSqrt	double
=	O
sqrt	function
(	O
2	int
*	O
dMean	double
*	O
dQ	double
)	O
;	O
do	O
{	O
do	O
{	O
dAngle	double
=	O
PI	int
*	O
Randoms	function
(	O
)	O
;	O
dTangent	double
=	O
tan	function
(	O
dAngle	double
)	O
;	O
dTemp1	double
=	O
dSqrt	double
*	O
dTangent	double
+	O
dMean	double
;	O
}	O
while	O
(	O
dTemp1	double
<	O
0	int
||	O
dTemp1	double
>=	O
(	O
N	long
+	O
1	int
)	O
)	O
;	O
dTemp1	double
=	O
floor	function
(	O
dTemp1	double
)	O
;	O
dTemp2	double
=	O
1.2	int
*	O
dSqrt	double
*	O
(	O
1	int
+	O
dTangent	double
*	O
dTangent	double
)	O
*	O
exp	function
(	O
dLnFactN	double
-	O
lnGamma	function
(	O
dTemp1	double
+	O
1	int
)	O
-	O
lnGamma	function
(	O
N	long
-	O
dTemp1	double
+	O
1	int
)	O
+	O
dTemp1	double
*	O
dLnP	double
+	O
(	O
N	long
-	O
dTemp1	double
)	O
*	O
dLnQ	double
)	O
;	O
}	O
while	O
(	O
Randoms	function
(	O
)	O
>	O
dTemp2	double
)	O
;	O
dDeviate	double
=	O
dTemp1	double
;	O
}	O
if	O
(	O
dPtemp	double
!=	O
p	double
)	O
dDeviate	double
=	O
N	long
-	O
dDeviate	double
;	O
return	O
(	O
dDeviate	double
)	O
;	O
}	O
double	O
CauchyRandom	function
(	O
double	O
dScale	double
)	O
{	O
double	O
z	double
,	O
x	pointer
;	O
z	double
=	O
NormalRandom	function
(	O
0	int
,	O
dScale	double
)	O
;	O
x	pointer
=	O
GGammaRandom	function
(	O
0.5	int
,	O
0.5	int
)	O
;	O
return	O
(	O
z	double
/	O
sqrt	function
(	O
x	pointer
)	O
)	O
;	O
}	O
double	O
Chi2Random	function
(	O
double	O
dof	double
)	O
{	O
return	O
(	O
GGammaRandom	function
(	O
dof	double
/	O
2.0	int
,	O
0.5	int
)	O
)	O
;	O
}	O
double	O
ExpRandom	function
(	O
double	O
beta	double
)	O
{	O
if	O
(	O
beta	double
<=	O
0	int
)	O
{	O
printf	function
(	O
"Error: negative or null inverse scale for an exponential variate "	pointer
"- Exiting\n\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
return	O
-	O
log	function
(	O
Randoms	function
(	O
)	O
)	O
/	O
beta	double
;	O
}	O
double	O
GammaRandom	function
(	O
double	O
alpha	double
)	O
{	O
static	O
double	O
aprev	double
=	O
0.0	int
,	O
c1	double
,	O
c2	double
,	O
c3	double
,	O
c4	double
,	O
c5	double
;	O
double	O
b	double
,	O
u1	double
,	O
u2	double
,	O
w	pointer
,	O
x	pointer
;	O
if	O
(	O
alpha	double
<=	O
0	int
)	O
{	O
printf	function
(	O
"Error: negative or null shape parameter for a gamma variate "	pointer
"- Exiting\n\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
alpha	double
<	O
1	int
)	O
{	O
b	double
=	O
(	O
alpha	double
+	O
E	int
)	O
/	O
E	int
;	O
do	O
{	O
u1	double
=	O
b	double
*	O
Randoms	function
(	O
)	O
;	O
if	O
(	O
u1	double
<=	O
1.0	int
)	O
{	O
x	pointer
=	O
pow	function
(	O
u1	double
,	O
1.	int
/	O
alpha	double
)	O
;	O
if	O
(	O
(	O
x	pointer
>	O
DBL_MIN	O
)	O
&&	O
(	O
x	pointer
<=	O
-	O
log	function
(	O
Randoms	function
(	O
)	O
)	O
)	O
)	O
return	O
(	O
x	pointer
)	O
;	O
}	O
else	O
{	O
x	pointer
=	O
-	O
log	function
(	O
(	O
b	double
-	O
u1	double
)	O
/	O
alpha	double
)	O
;	O
if	O
(	O
pow	function
(	O
x	pointer
,	O
alpha	double
-	O
1	int
)	O
>=	O
Randoms	function
(	O
)	O
)	O
return	O
(	O
x	pointer
)	O
;	O
}	O
}	O
while	O
(	O
1	int
==	O
1	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
alpha	double
>	O
1	int
)	O
{	O
if	O
(	O
alpha	double
!=	O
aprev	double
)	O
{	O
aprev	double
=	O
alpha	double
;	O
c1	double
=	O
alpha	double
-	O
1	int
;	O
b	double
=	O
1.0	int
/	O
c1	double
;	O
c2	double
=	O
b	double
*	O
(	O
alpha	double
-	O
(	O
1	int
/	O
(	O
6.0	int
*	O
alpha	double
)	O
)	O
)	O
;	O
c3	double
=	O
2	int
*	O
b	double
;	O
c4	double
=	O
c3	double
+	O
2.0	int
;	O
if	O
(	O
alpha	double
>	O
2.5	int
)	O
c5	double
=	O
1.0	int
/	O
sqrt	function
(	O
alpha	double
)	O
;	O
}	O
do	O
{	O
do	O
{	O
u1	double
=	O
Randoms	function
(	O
)	O
;	O
u2	double
=	O
Randoms	function
(	O
)	O
;	O
if	O
(	O
alpha	double
>	O
2.5	int
)	O
u1	double
=	O
u2	double
+	O
c5	double
*	O
(	O
1	int
-	O
1.86	int
*	O
u1	double
)	O
;	O
}	O
while	O
(	O
(	O
u1	double
>=	O
1	int
)	O
||	O
(	O
u1	double
<=	O
0	int
)	O
)	O
;	O
w	pointer
=	O
c2	double
*	O
u2	double
/	O
u1	double
;	O
if	O
(	O
(	O
(	O
c3	double
*	O
u1	double
+	O
w	pointer
+	O
1	int
/	O
w	pointer
)	O
<=	O
c4	double
)	O
||	O
(	O
(	O
c3	double
*	O
log	function
(	O
u1	double
)	O
-	O
log	function
(	O
w	pointer
)	O
+	O
w	pointer
)	O
<	O
1	int
)	O
)	O
return	O
(	O
c1	double
*	O
w	pointer
)	O
;	O
}	O
while	O
(	O
1	int
==	O
1	int
)	O
;	O
}	O
else	O
return	O
ExpRandom	function
(	O
1.0	int
)	O
;	O
}	O
}	O
double	O
GenLogNormalRandom	function
(	O
double	O
dMean	double
,	O
double	O
dStdDevNorm	double
,	O
double	O
dStdDevLogNorm	double
)	O
{	O
double	O
dmuz	double
,	O
dSLogNorm	double
,	O
dLambda	double
,	O
dz	double
;	O
if	O
(	O
dMean	double
<	O
0	int
)	O
{	O
char	O
str	array
[	O
10	int
]	O
;	O
sprintf	function
(	O
str	array
,	O
"%5.2e"	pointer
,	O
dMean	double
)	O
;	O
ReportRunTimeError	function
(	O
NULL	O
,	O
RE_BADLOGNORMALMEAN	int
|	O
RE_FATAL	int
,	O
""	pointer
,	O
str	array
,	O
"GenLogNormalRandom"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
dStdDevLogNorm	double
<=	O
0	int
)	O
{	O
char	O
str	array
[	O
10	int
]	O
;	O
sprintf	function
(	O
str	array
,	O
"%5.2e"	pointer
,	O
dStdDevLogNorm	double
)	O
;	O
ReportRunTimeError	function
(	O
NULL	O
,	O
RE_BADLOGNORMALSD	int
|	O
RE_FATAL	int
,	O
""	pointer
,	O
str	array
,	O
"GenLogNormalRandom"	pointer
)	O
;	O
}	O
dSLogNorm	double
=	O
sqrt	function
(	O
exp	function
(	O
pow	function
(	O
dStdDevLogNorm	double
,	O
2	int
)	O
)	O
*	O
(	O
exp	function
(	O
pow	function
(	O
dStdDevLogNorm	double
,	O
2	int
)	O
)	O
-	O
1	int
)	O
)	O
;	O
dLambda	double
=	O
pow	function
(	O
dStdDevNorm	double
/	O
dSLogNorm	double
,	O
2	int
)	O
;	O
dmuz	double
=	O
log	function
(	O
dMean	double
+	O
sqrt	function
(	O
pow	function
(	O
dMean	double
,	O
2	int
)	O
+	O
dLambda	double
)	O
)	O
;	O
dz	double
=	O
NormalRandom	function
(	O
dmuz	double
,	O
dSLogNorm	double
)	O
;	O
return	O
(	O
exp	function
(	O
dz	double
)	O
-	O
dLambda	double
*	O
exp	function
(	O
-	O
dz	double
)	O
)	O
/	O
2	int
;	O
}	O
double	O
GGammaRandom	function
(	O
double	O
alpha	double
,	O
double	O
beta	double
)	O
{	O
if	O
(	O
beta	double
<=	O
0	int
)	O
{	O
printf	function
(	O
"Error: negative or null inverse scale for a gamma variate "	pointer
"- Exiting\n\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
return	O
GammaRandom	function
(	O
alpha	double
)	O
/	O
beta	double
;	O
}	O
double	O
InvGGammaRandom	function
(	O
double	O
alpha	double
,	O
double	O
beta	double
)	O
{	O
if	O
(	O
beta	double
<=	O
0	int
)	O
{	O
printf	function
(	O
"Error: negative or null scale for an inverse gamma variate "	pointer
"- Exiting\n\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
return	O
beta	double
/	O
GammaRandom	function
(	O
alpha	double
)	O
;	O
}	O
double	O
LogNormalRandom	function
(	O
double	O
dMean	double
,	O
double	O
dStdDev	double
)	O
{	O
if	O
(	O
dMean	double
<=	O
0	int
)	O
{	O
char	O
str	array
[	O
10	int
]	O
;	O
sprintf	function
(	O
str	array
,	O
"%5.2e"	pointer
,	O
dMean	double
)	O
;	O
ReportRunTimeError	function
(	O
NULL	O
,	O
RE_BADLOGNORMALMEAN	int
|	O
RE_FATAL	int
,	O
""	pointer
,	O
str	array
,	O
"LogNormalRandom"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
dStdDev	double
<	O
1	int
)	O
{	O
char	O
str	array
[	O
10	int
]	O
;	O
sprintf	function
(	O
str	array
,	O
"%5.2e"	pointer
,	O
dStdDev	double
)	O
;	O
ReportRunTimeError	function
(	O
NULL	O
,	O
RE_BADLOGNORMALSD	int
|	O
RE_FATAL	int
,	O
""	pointer
,	O
str	array
,	O
"LogNormalRandom"	pointer
)	O
;	O
}	O
return	O
exp	function
(	O
NormalRandom	function
(	O
log	function
(	O
dMean	double
)	O
,	O
log	function
(	O
dStdDev	double
)	O
)	O
)	O
;	O
}	O
double	O
LogUniformRandom	function
(	O
double	O
a	double
,	O
double	O
b	double
)	O
{	O
if	O
(	O
b	double
<	O
a	double
)	O
{	O
printf	function
(	O
"Error: bad range a for uniform variate - Exiting\n\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
return	O
(	O
a	double
*	O
pow	function
(	O
b	double
/	O
a	double
,	O
Randoms	function
(	O
)	O
)	O
)	O
;	O
}	O
void	O
Multinomial	function
(	O
long	O
n	int
,	O
int	O
dim	int
,	O
double	O
*	O
p	double
,	O
double	O
*	O
x	pointer
)	O
{	O
int	O
i	long
;	O
double	O
sum	double
,	O
ptemp	double
;	O
sum	double
=	O
1	int
;	O
for	O
(	O
i	long
=	O
1	int
;	O
i	long
<=	O
dim	int
;	O
i	long
++	O
)	O
{	O
if	O
(	O
p	double
[	O
i	long
]	O
)	O
{	O
ptemp	double
=	O
p	double
[	O
i	long
]	O
/	O
sum	double
;	O
x	pointer
[	O
i	long
]	O
=	O
BinomialRandom	function
(	O
ptemp	double
,	O
n	int
)	O
;	O
n	int
=	O
n	int
-	O
(	O
long	O
)	O
x	pointer
[	O
i	long
]	O
;	O
sum	double
=	O
sum	double
-	O
p	double
[	O
i	long
]	O
;	O
}	O
else	O
x	pointer
[	O
i	long
]	O
=	O
0.0	int
;	O
}	O
}	O
double	O
NormalRandom	function
(	O
double	O
dMean	double
,	O
double	O
dStdDev	double
)	O
{	O
double	O
dRacine	double
,	O
dTemp1	double
,	O
dTemp2	double
,	O
dTemp3	double
;	O
static	O
double	O
memGauss	double
;	O
if	O
(	O
vbSwitchGauss	int
)	O
{	O
vbSwitchGauss	int
=	O
FALSE	int
;	O
return	O
(	O
dMean	double
+	O
dStdDev	double
*	O
memGauss	double
)	O
;	O
}	O
do	O
{	O
dTemp1	double
=	O
2	int
*	O
Randoms	function
(	O
)	O
-	O
1	int
;	O
dTemp2	double
=	O
2	int
*	O
Randoms	function
(	O
)	O
-	O
1	int
;	O
dRacine	double
=	O
dTemp1	double
*	O
dTemp1	double
+	O
dTemp2	double
*	O
dTemp2	double
;	O
}	O
while	O
(	O
(	O
dRacine	double
>=	O
1	int
)	O
||	O
(	O
dRacine	double
==	O
0	int
)	O
)	O
;	O
dTemp3	double
=	O
sqrt	function
(	O
-	O
2	int
*	O
log	function
(	O
dRacine	double
)	O
/	O
dRacine	double
)	O
;	O
vbSwitchGauss	int
=	O
TRUE	int
;	O
memGauss	double
=	O
dTemp1	double
*	O
dTemp3	double
;	O
return	O
(	O
dMean	double
+	O
dStdDev	double
*	O
(	O
dTemp2	double
*	O
dTemp3	double
)	O
)	O
;	O
}	O
long	O
PoissonRandom	function
(	O
double	O
mu	double
)	O
{	O
double	O
u1	double
,	O
x	pointer
,	O
u2	double
,	O
lnfact	double
,	O
s	double
,	O
t	pointer
;	O
static	O
double	O
prev_mu	double
=	O
0	int
,	O
c	double
,	O
beta	double
,	O
alpha	double
,	O
k	double
;	O
long	O
n	int
=	O
0	int
;	O
if	O
(	O
mu	double
<=	O
0	int
)	O
{	O
printf	function
(	O
"Error: negative or null rate for a Poisson variate "	pointer
"- Exiting\n\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
if	O
(	O
mu	double
<=	O
60	int
)	O
{	O
s	double
=	O
1	int
;	O
t	pointer
=	O
1	int
;	O
u1	double
=	O
Randoms	function
(	O
)	O
*	O
exp	function
(	O
mu	double
)	O
;	O
while	O
(	O
s	double
<	O
u1	double
)	O
{	O
n	int
++	O
;	O
t	pointer
=	O
t	pointer
*	O
mu	double
/	O
n	int
;	O
s	double
=	O
s	double
+	O
t	pointer
;	O
}	O
}	O
else	O
{	O
if	O
(	O
mu	double
!=	O
prev_mu	double
)	O
{	O
c	double
=	O
0.767	int
-	O
3.36	int
/	O
mu	double
;	O
beta	double
=	O
PI	int
/	O
sqrt	function
(	O
3	int
*	O
mu	double
)	O
;	O
alpha	double
=	O
beta	double
*	O
mu	double
;	O
k	double
=	O
log	function
(	O
c	double
)	O
-	O
mu	double
-	O
log	function
(	O
beta	double
)	O
;	O
}	O
do	O
{	O
do	O
{	O
u1	double
=	O
Randoms	function
(	O
)	O
;	O
x	pointer
=	O
(	O
alpha	double
-	O
log	function
(	O
(	O
1	int
-	O
u1	double
)	O
/	O
u1	double
)	O
)	O
/	O
beta	double
;	O
}	O
while	O
(	O
x	pointer
<=	O
-	O
0.5	int
)	O
;	O
n	int
=	O
(	O
long	O
)	O
(	O
x	pointer
+	O
0.5	int
)	O
;	O
u2	double
=	O
Randoms	function
(	O
)	O
;	O
lnfact	double
=	O
0.918938533	int
-	O
n	int
+	O
(	O
n	int
+	O
0.5	int
)	O
*	O
log	function
(	O
n	int
)	O
;	O
}	O
while	O
(	O
alpha	double
-	O
beta	double
*	O
x	pointer
+	O
log	function
(	O
u2	double
/	O
pow	function
(	O
(	O
1	int
+	O
exp	function
(	O
alpha	double
-	O
beta	double
*	O
x	pointer
)	O
)	O
,	O
2	int
)	O
)	O
>	O
k	double
+	O
n	int
*	O
log	function
(	O
mu	double
)	O
-	O
lnfact	double
)	O
;	O
}	O
return	O
n	int
;	O
}	O
double	O
StudentTRandom	function
(	O
double	O
dof	double
,	O
double	O
dMean	double
,	O
double	O
dStdDev	double
)	O
{	O
double	O
z	double
,	O
x	pointer
;	O
if	O
(	O
dof	double
<=	O
0	int
)	O
{	O
printf	function
(	O
"Error: StudentTRandom: dof <= 0\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
z	double
=	O
NormalRandom	function
(	O
0	int
,	O
1	int
)	O
;	O
x	pointer
=	O
Chi2Random	function
(	O
dof	double
)	O
;	O
return	O
(	O
dMean	double
+	O
dStdDev	double
*	O
z	double
*	O
sqrt	function
(	O
dof	double
/	O
x	pointer
)	O
)	O
;	O
}	O
double	O
TruncInvGGammaRandom	function
(	O
double	O
alpha	double
,	O
double	O
beta	double
,	O
double	O
a	double
,	O
double	O
b	double
)	O
{	O
double	O
X	double
=	O
0.0	int
;	O
int	O
iter	int
=	O
0	int
;	O
if	O
(	O
a	double
>=	O
b	double
)	O
printf	function
(	O
"TruncLogNormalRandom: min >= max  [%g %g]\n"	pointer
,	O
a	double
,	O
b	double
)	O
;	O
else	O
do	O
{	O
if	O
(	O
++	O
iter	int
==	O
25	int
)	O
{	O
printf	function
(	O
"TruncInvGGammaRandom: problem with range: "	pointer
)	O
;	O
printf	function
(	O
"min %g, max %g, alpha %g, beta %g\n"	pointer
,	O
a	double
,	O
b	double
,	O
alpha	double
,	O
beta	double
)	O
;	O
}	O
X	double
=	O
InvGGammaRandom	function
(	O
alpha	double
,	O
beta	double
)	O
;	O
}	O
while	O
(	O
X	double
<	O
a	double
||	O
X	double
>	O
b	double
)	O
;	O
return	O
X	double
;	O
}	O
double	O
TruncLogNormalRandom	function
(	O
double	O
dMean	double
,	O
double	O
dStdDev	double
,	O
double	O
a	double
,	O
double	O
b	double
)	O
{	O
double	O
X	double
=	O
0.0	int
;	O
int	O
iter	int
=	O
0	int
;	O
if	O
(	O
a	double
>=	O
b	double
)	O
printf	function
(	O
"TruncLogNormalRandom: min >= max  [%g %g]\n"	pointer
,	O
a	double
,	O
b	double
)	O
;	O
else	O
do	O
{	O
if	O
(	O
++	O
iter	int
==	O
25	int
)	O
{	O
printf	function
(	O
"TruncLogNormalRandom: problem with range: "	pointer
)	O
;	O
printf	function
(	O
"min %g, max %g, ave %g, sd %g\n"	pointer
,	O
a	double
,	O
b	double
,	O
dMean	double
,	O
dStdDev	double
)	O
;	O
}	O
X	double
=	O
LogNormalRandom	function
(	O
dMean	double
,	O
dStdDev	double
)	O
;	O
}	O
while	O
(	O
X	double
<	O
a	double
||	O
X	double
>	O
b	double
)	O
;	O
return	O
X	double
;	O
}	O
double	O
TruncNormalRandom	function
(	O
double	O
dMean	double
,	O
double	O
dStdDev	double
,	O
double	O
a	double
,	O
double	O
b	double
)	O
{	O
double	O
X	double
=	O
0.0	int
;	O
int	O
iter	int
=	O
0	int
;	O
if	O
(	O
a	double
>=	O
b	double
)	O
{	O
printf	function
(	O
"Error: TruncNormalRandom: min >= max  [%g %g]\n"	pointer
,	O
a	double
,	O
b	double
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
else	O
do	O
{	O
if	O
(	O
++	O
iter	int
==	O
25	int
)	O
{	O
printf	function
(	O
"Warning: TruncNormalRandom: problem with range: "	pointer
)	O
;	O
printf	function
(	O
"min %g, max %g, ave %g, sd %g\n"	pointer
,	O
a	double
,	O
b	double
,	O
dMean	double
,	O
dStdDev	double
)	O
;	O
}	O
X	double
=	O
NormalRandom	function
(	O
dMean	double
,	O
dStdDev	double
)	O
;	O
}	O
while	O
(	O
X	double
<	O
a	double
||	O
X	double
>	O
b	double
)	O
;	O
return	O
X	double
;	O
}	O
double	O
UniformRandom	function
(	O
double	O
a	double
,	O
double	O
b	double
)	O
{	O
if	O
(	O
b	double
<	O
a	double
)	O
{	O
printf	function
(	O
"Error: bad range a for uniform variate - Exiting\n\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
return	O
(	O
Randoms	function
(	O
)	O
*	O
(	O
b	double
-	O
a	double
)	O
+	O
a	double
)	O
;	O
}	O
void	O
WishartRandom	function
(	O
long	O
n	int
,	O
long	O
p	double
,	O
double	O
*	O
t	pointer
,	O
double	O
*	O
w	pointer
,	O
double	O
*	O
work	pointer
)	O
{	O
double	O
eta	double
,	O
sum	double
;	O
long	O
i	long
,	O
j	long
,	O
k	double
,	O
m	int
,	O
k1	long
,	O
k2	long
,	O
k3	long
;	O
printf	function
(	O
"WishartRandom not tested - Exiting..."	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
for	O
(	O
j	long
=	O
0	int
,	O
k	double
=	O
0	int
;	O
j	long
<	O
p	double
;	O
j	long
++	O
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
j	long
;	O
i	long
++	O
)	O
w	pointer
[	O
k	double
++	O
]	O
=	O
NormalRandom	function
(	O
0	int
,	O
1	int
)	O
;	O
w	pointer
[	O
k	double
++	O
]	O
=	O
GGammaRandom	function
(	O
(	O
n	int
-	O
i	long
)	O
/	O
2.0	int
,	O
0.5	int
)	O
;	O
}	O
for	O
(	O
j	long
=	O
p	double
-	O
1	int
,	O
m	int
=	O
k	double
-	O
1	int
,	O
k2	long
=	O
(	O
p	double
*	O
(	O
p	double
-	O
1	int
)	O
)	O
/	O
2	int
;	O
j	long
>=	O
0	int
;	O
k2	long
=	O
k2	long
-	O
(	O
j	long
--	O
)	O
)	O
{	O
eta	double
=	O
w	pointer
[	O
m	int
]	O
;	O
for	O
(	O
i	long
=	O
j	long
,	O
k1	long
=	O
(	O
i	long
*	O
(	O
i	long
+	O
1	int
)	O
)	O
/	O
2	int
;	O
i	long
>=	O
0	int
;	O
k1	long
=	O
k1	long
-	O
(	O
i	long
--	O
)	O
,	O
m	int
--	O
)	O
{	O
for	O
(	O
k	double
=	O
0	int
,	O
sum	double
=	O
0.0	int
;	O
k	double
<	O
i	long
;	O
k	double
++	O
)	O
sum	double
=	O
sum	double
+	O
w	pointer
[	O
k1	long
+	O
k	double
]	O
*	O
w	pointer
[	O
k2	long
+	O
k	double
]	O
;	O
if	O
(	O
i	long
==	O
j	long
)	O
w	pointer
[	O
m	int
]	O
=	O
sum	double
+	O
eta	double
;	O
else	O
w	pointer
[	O
m	int
]	O
=	O
sum	double
+	O
sqrt	function
(	O
eta	double
)	O
*	O
w	pointer
[	O
m	int
]	O
;	O
}	O
}	O
for	O
(	O
i	long
=	O
0	int
,	O
k1	long
=	O
0	int
,	O
m	int
=	O
0	int
;	O
i	long
<	O
p	double
;	O
k1	long
=	O
k1	long
+	O
(	O
++	O
i	long
)	O
)	O
{	O
for	O
(	O
j	long
=	O
0	int
,	O
k2	long
=	O
0	int
;	O
j	long
<	O
p	double
;	O
k2	long
=	O
k2	long
+	O
(	O
++	O
j	long
)	O
,	O
m	int
++	O
)	O
{	O
for	O
(	O
k	double
=	O
0	int
,	O
sum	double
=	O
0.0	int
;	O
k	double
<	O
j	long
;	O
k	double
++	O
)	O
sum	double
=	O
sum	double
+	O
t	pointer
[	O
k1	long
+	O
k	double
]	O
*	O
w	pointer
[	O
k2	long
+	O
k	double
]	O
;	O
for	O
(	O
k	double
=	O
j	long
,	O
k3	long
=	O
j	long
;	O
k	double
<=	O
i	long
;	O
k3	long
=	O
k3	long
+	O
(	O
++	O
k	double
)	O
)	O
sum	double
=	O
sum	double
+	O
t	pointer
[	O
k1	long
+	O
k	double
]	O
*	O
w	pointer
[	O
k2	long
+	O
k3	long
]	O
;	O
work	pointer
[	O
m	int
]	O
=	O
sum	double
;	O
}	O
}	O
for	O
(	O
i	long
=	O
0	int
,	O
m	int
=	O
0	int
,	O
k1	long
=	O
0	int
;	O
i	long
<	O
p	double
;	O
i	long
++	O
,	O
k1	long
=	O
k1	long
+	O
p	double
)	O
{	O
for	O
(	O
j	long
=	O
0	int
,	O
k2	long
=	O
0	int
;	O
j	long
<=	O
i	long
;	O
k2	long
=	O
k2	long
+	O
(	O
++	O
j	long
)	O
,	O
m	int
++	O
)	O
{	O
for	O
(	O
k	double
=	O
0	int
,	O
sum	double
=	O
0.0	int
;	O
k	double
<=	O
j	long
;	O
k	double
++	O
)	O
sum	double
=	O
sum	double
+	O
work	pointer
[	O
k1	long
+	O
k	double
]	O
*	O
t	pointer
[	O
k2	long
+	O
k	double
]	O
;	O
w	pointer
[	O
m	int
]	O
=	O
sum	double
;	O
}	O
}	O
}	O
BOOL	int
and	function
(	O
BOOL	int
A	int
,	O
BOOL	int
B	int
)	O
{	O
return	O
(	O
A	int
&&	O
B	int
)	O
;	O
}	O
void	O
CalcCumulative	function
(	O
long	O
cDim	long
,	O
double	O
*	O
rg_x	array
,	O
double	O
*	O
rg_pdf	array
,	O
double	O
*	O
rg_Cdf	array
,	O
int	O
iOrder	int
)	O
{	O
long	O
i	long
;	O
if	O
(	O
iOrder	int
>	O
1	int
)	O
{	O
printf	function
(	O
"CalcCumulative: Order %d not supported"	pointer
"-> using piecewise-linear\n"	pointer
,	O
iOrder	int
)	O
;	O
iOrder	int
=	O
1	int
;	O
}	O
rg_Cdf	array
[	O
0	int
]	O
=	O
0.0	int
;	O
switch	O
(	O
iOrder	int
)	O
{	O
case	O
0	int
:	O
for	O
(	O
i	long
=	O
1	int
;	O
i	long
<	O
cDim	long
;	O
i	long
++	O
)	O
rg_Cdf	array
[	O
i	long
]	O
=	O
rg_Cdf	array
[	O
i	long
-	O
1	int
]	O
+	O
rg_pdf	array
[	O
i	long
]	O
*	O
(	O
rg_x	array
[	O
i	long
]	O
-	O
rg_x	array
[	O
i	long
-	O
1	int
]	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
for	O
(	O
i	long
=	O
1	int
;	O
i	long
<	O
cDim	long
;	O
i	long
++	O
)	O
rg_Cdf	array
[	O
i	long
]	O
=	O
rg_Cdf	array
[	O
i	long
-	O
1	int
]	O
+	O
(	O
(	O
rg_x	array
[	O
i	long
]	O
-	O
rg_x	array
[	O
i	long
-	O
1	int
]	O
)	O
*	O
(	O
rg_pdf	array
[	O
i	long
]	O
+	O
rg_pdf	array
[	O
i	long
-	O
1	int
]	O
)	O
/	O
2	int
)	O
;	O
break	O
;	O
default	O
:	O
assert	O
(	O
0	int
)	O
;	O
break	O
;	O
}	O
}	O
double	O
CDFNormal	function
(	O
double	O
z	double
)	O
{	O
register	O
double	O
tmp	double
;	O
tmp	double
=	O
z	double
/	O
SQRT_2	int
;	O
if	O
(	O
tmp	double
>=	O
0	int
)	O
return	O
(	O
0.5	int
*	O
(	O
2	int
-	O
erfc	function
(	O
tmp	double
)	O
)	O
)	O
;	O
else	O
return	O
(	O
0.5	int
*	O
erfc	function
(	O
-	O
tmp	double
)	O
)	O
;	O
}	O
double	O
erfc	function
(	O
double	O
x	pointer
)	O
{	O
double	O
dAbsX	double
,	O
t	pointer
,	O
dVal	double
;	O
dAbsX	double
=	O
fabs	function
(	O
x	pointer
)	O
;	O
if	O
(	O
dAbsX	double
>	O
20	int
)	O
{	O
return	O
(	O
x	pointer
>=	O
0	int
?	O
0	int
:	O
2	int
)	O
;	O
}	O
else	O
{	O
t	pointer
=	O
1	int
/	O
(	O
1	int
+	O
0.5	int
*	O
dAbsX	double
)	O
;	O
dVal	double
=	O
t	pointer
*	O
exp	function
(	O
-	O
dAbsX	double
*	O
dAbsX	double
-	O
1.26551223	int
+	O
t	pointer
*	O
(	O
1.00002368	int
+	O
t	pointer
*	O
(	O
0.37409196	int
+	O
t	pointer
*	O
(	O
0.09678418	int
+	O
t	pointer
*	O
(	O
-	O
0.18628806	int
+	O
t	pointer
*	O
(	O
0.27886807	int
+	O
t	pointer
*	O
(	O
-	O
1.13520398	int
+	O
t	pointer
*	O
(	O
1.48851587	int
+	O
t	pointer
*	O
(	O
-	O
0.82215223	int
+	O
t	pointer
*	O
(	O
0.17087277	int
)	O
)	O
)	O
)	O
)	O
)	O
)	O
)	O
)	O
)	O
;	O
return	O
(	O
x	pointer
>=	O
0	int
?	O
dVal	double
:	O
2	int
-	O
dVal	double
)	O
;	O
}	O
}	O
double	O
InterpolateX	function
(	O
double	O
rgX	array
[	O
]	O
,	O
double	O
rgY	array
[	O
]	O
,	O
long	O
lLower	long
,	O
double	O
dY	double
)	O
{	O
return	O
rgX	array
[	O
lLower	long
]	O
+	O
(	O
dY	double
-	O
rgY	array
[	O
lLower	long
]	O
)	O
*	O
(	O
rgX	array
[	O
lLower	long
+	O
1	int
]	O
-	O
rgX	array
[	O
lLower	long
]	O
)	O
/	O
(	O
rgY	array
[	O
lLower	long
+	O
1	int
]	O
-	O
rgY	array
[	O
lLower	long
]	O
)	O
;	O
}	O
double	O
lnDFBeta	function
(	O
double	O
x	pointer
,	O
double	O
alpha	double
,	O
double	O
beta	double
,	O
double	O
min	double
,	O
double	O
max	double
)	O
{	O
if	O
(	O
max	double
<=	O
min	double
)	O
{	O
printf	function
(	O
"Error: bad range for beta variate in lnDFBeta\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
if	O
(	O
alpha	double
<=	O
0	int
)	O
{	O
printf	function
(	O
"Error: bad alpha for beta variate in LnDensity\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
if	O
(	O
beta	double
<=	O
0	int
)	O
{	O
printf	function
(	O
"Error: bad beta for beta variate in LnDensity\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
x	pointer
=	O
(	O
x	pointer
-	O
min	double
)	O
/	O
(	O
max	double
-	O
min	double
)	O
;	O
return	O
(	O
alpha	double
-	O
1	int
)	O
*	O
log	function
(	O
x	pointer
)	O
+	O
(	O
beta	double
-	O
1	int
)	O
*	O
log	function
(	O
1	int
-	O
x	pointer
)	O
+	O
lnGamma	function
(	O
alpha	double
+	O
beta	double
)	O
-	O
lnGamma	function
(	O
alpha	double
)	O
-	O
lnGamma	function
(	O
beta	double
)	O
-	O
log	function
(	O
max	double
-	O
min	double
)	O
;	O
}	O
double	O
lnDFNormal	function
(	O
double	O
x	pointer
,	O
double	O
mu	double
,	O
double	O
sd	double
)	O
{	O
if	O
(	O
sd	double
<=	O
0.0	int
)	O
{	O
printf	function
(	O
"Error: negative or null SD in lnDFNormal\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
return	O
(	O
-	O
0.918938533204672669541	int
-	O
log	function
(	O
sd	double
)	O
-	O
0.5	int
*	O
pow	function
(	O
(	O
mu	double
-	O
x	pointer
)	O
/	O
sd	double
,	O
2	int
)	O
)	O
;	O
}	O
double	O
lnGamma	function
(	O
double	O
x	pointer
)	O
{	O
double	O
dSeries	double
,	O
dTemp	double
;	O
if	O
(	O
x	pointer
<=	O
0.0	int
)	O
{	O
printf	function
(	O
"Error: negative or null parameter for lnGamma function\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
dSeries	double
=	O
1.000000000190015	int
+	O
76.18009172947146	int
/	O
x	pointer
-	O
86.50532032141677	int
/	O
(	O
x	pointer
+	O
1	int
)	O
+	O
24.01409824083091	int
/	O
(	O
x	pointer
+	O
2	int
)	O
-	O
1.231739572450155	int
/	O
(	O
x	pointer
+	O
3	int
)	O
+	O
1.20865097386617E-3	int
/	O
(	O
x	pointer
+	O
4	int
)	O
-	O
5.39523938495E-6	int
/	O
(	O
x	pointer
+	O
5	int
)	O
;	O
dTemp	double
=	O
x	pointer
+	O
4.5	int
;	O
dTemp	double
=	O
-	O
dTemp	double
+	O
(	O
x	pointer
-	O
0.5	int
)	O
*	O
log	function
(	O
dTemp	double
)	O
+	O
log	function
(	O
2.50662827465	int
*	O
dSeries	double
)	O
;	O
return	O
dTemp	double
;	O
}	O
double	O
PiecewiseRandom	function
(	O
double	O
min	double
,	O
double	O
a	double
,	O
double	O
b	double
,	O
double	O
max	double
)	O
{	O
double	O
dTemp	double
;	O
static	O
double	O
Grille	array
[	O
4	int
]	O
;	O
static	O
double	O
densite	array
[	O
4	int
]	O
;	O
static	O
double	O
densiteCum	array
[	O
4	int
]	O
;	O
double	O
nvlle_densite	double
;	O
Grille	array
[	O
0	int
]	O
=	O
min	double
;	O
Grille	array
[	O
1	int
]	O
=	O
a	double
;	O
Grille	array
[	O
2	int
]	O
=	O
b	double
;	O
Grille	array
[	O
3	int
]	O
=	O
max	double
;	O
densite	array
[	O
0	int
]	O
=	O
0	int
;	O
densite	array
[	O
1	int
]	O
=	O
1	int
/	O
(	O
max	double
/	O
2	int
+	O
b	double
/	O
2	int
-	O
a	double
/	O
2	int
-	O
min	double
/	O
2	int
)	O
;	O
densite	array
[	O
2	int
]	O
=	O
1	int
/	O
(	O
max	double
/	O
2	int
+	O
b	double
/	O
2	int
-	O
a	double
/	O
2	int
-	O
min	double
/	O
2	int
)	O
;	O
densite	array
[	O
3	int
]	O
=	O
0	int
;	O
CalcCumulative	function
(	O
4	int
,	O
Grille	array
,	O
densite	array
,	O
densiteCum	array
,	O
1	int
)	O
;	O
dTemp	double
=	O
PiecewiseVariate	function
(	O
4	int
,	O
Grille	array
,	O
densite	array
,	O
densiteCum	array
,	O
1	int
,	O
&	O
nvlle_densite	double
)	O
;	O
return	O
(	O
dTemp	double
)	O
;	O
}	O
double	O
PiecewiseVariate	function
(	O
long	O
cDim	long
,	O
double	O
rg_x	array
[	O
]	O
,	O
double	O
rg_pdf	array
[	O
]	O
,	O
double	O
rg_Cdf	array
[	O
]	O
,	O
int	O
iOrder	int
,	O
double	O
*	O
pVal_pdf	pointer
)	O
{	O
double	O
dPWVariate	double
;	O
double	O
dValPdf	double
;	O
double	O
dUniform	double
=	O
UniformRandom	function
(	O
0	int
,	O
rg_Cdf	array
[	O
cDim	long
-	O
1	int
]	O
)	O
;	O
long	O
lUpper	long
,	O
lLower	long
,	O
lIndex	long
;	O
if	O
(	O
iOrder	int
>	O
1	int
)	O
{	O
printf	function
(	O
"CalcCumulative: Order %d not supported"	pointer
"-> using piecewise-linear\n"	pointer
,	O
iOrder	int
)	O
;	O
iOrder	int
=	O
1	int
;	O
}	O
lUpper	long
=	O
cDim	long
;	O
lLower	long
=	O
0	int
;	O
lIndex	long
=	O
0	int
;	O
while	O
(	O
lUpper	long
-	O
lLower	long
>	O
1	int
)	O
{	O
lIndex	long
=	O
(	O
lUpper	long
+	O
lLower	long
)	O
/	O
2	int
;	O
if	O
(	O
dUniform	double
>	O
rg_Cdf	array
[	O
lIndex	long
]	O
)	O
lLower	long
=	O
lIndex	long
;	O
else	O
if	O
(	O
dUniform	double
<	O
rg_Cdf	array
[	O
lIndex	long
]	O
)	O
lUpper	long
=	O
lIndex	long
;	O
else	O
lUpper	long
=	O
lLower	long
=	O
lIndex	long
;	O
}	O
if	O
(	O
lUpper	long
==	O
lLower	long
)	O
{	O
dValPdf	double
=	O
rg_pdf	array
[	O
lLower	long
]	O
;	O
dPWVariate	double
=	O
rg_x	array
[	O
lLower	long
]	O
;	O
}	O
else	O
switch	O
(	O
iOrder	int
)	O
{	O
case	O
0	int
:	O
dValPdf	double
=	O
rg_pdf	array
[	O
lLower	long
]	O
;	O
dPWVariate	double
=	O
InterpolateX	function
(	O
rg_x	array
,	O
rg_Cdf	array
,	O
lLower	long
,	O
dUniform	double
)	O
;	O
break	O
;	O
case	O
1	int
:	O
{	O
if	O
(	O
rg_pdf	array
[	O
lLower	long
]	O
==	O
rg_pdf	array
[	O
lUpper	long
]	O
)	O
{	O
dValPdf	double
=	O
rg_pdf	array
[	O
lLower	long
]	O
;	O
dPWVariate	double
=	O
InterpolateX	function
(	O
rg_x	array
,	O
rg_Cdf	array
,	O
lLower	long
,	O
dUniform	double
)	O
;	O
}	O
else	O
{	O
double	O
a	double
,	O
b	double
,	O
c	double
,	O
dRadical	double
;	O
a	double
=	O
(	O
rg_pdf	array
[	O
lUpper	long
]	O
-	O
rg_pdf	array
[	O
lLower	long
]	O
)	O
/	O
(	O
rg_x	array
[	O
lUpper	long
]	O
-	O
rg_x	array
[	O
lLower	long
]	O
)	O
;	O
b	double
=	O
rg_pdf	array
[	O
lLower	long
]	O
-	O
a	double
*	O
rg_x	array
[	O
lLower	long
]	O
;	O
c	double
=	O
rg_Cdf	array
[	O
lLower	long
]	O
-	O
(	O
a	double
*	O
rg_x	array
[	O
lLower	long
]	O
/	O
2.0	int
+	O
b	double
)	O
*	O
rg_x	array
[	O
lLower	long
]	O
;	O
dRadical	double
=	O
sqrt	function
(	O
b	double
*	O
b	double
-	O
2	int
*	O
a	double
*	O
(	O
c	double
-	O
dUniform	double
)	O
)	O
;	O
dPWVariate	double
=	O
(	O
-	O
b	double
+	O
dRadical	double
)	O
/	O
a	double
;	O
assert	O
(	O
dPWVariate	double
>=	O
rg_x	array
[	O
lLower	long
]	O
&&	O
dPWVariate	double
<=	O
rg_x	array
[	O
lUpper	long
]	O
)	O
;	O
dValPdf	double
=	O
a	double
*	O
dPWVariate	double
+	O
b	double
;	O
if	O
(	O
a	double
>	O
0	int
)	O
assert	O
(	O
dValPdf	double
>=	O
rg_pdf	array
[	O
lLower	long
]	O
&&	O
dValPdf	double
<=	O
rg_pdf	array
[	O
lUpper	long
]	O
)	O
;	O
else	O
assert	O
(	O
dValPdf	double
<=	O
rg_pdf	array
[	O
lLower	long
]	O
&&	O
dValPdf	double
>=	O
rg_pdf	array
[	O
lUpper	long
]	O
)	O
;	O
}	O
}	O
break	O
;	O
default	O
:	O
dValPdf	double
=	O
0	int
;	O
dPWVariate	double
=	O
0	int
;	O
assert	O
(	O
0	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
pVal_pdf	pointer
)	O
*	O
pVal_pdf	pointer
=	O
dValPdf	double
;	O
return	O
dPWVariate	double
;	O
}	O
