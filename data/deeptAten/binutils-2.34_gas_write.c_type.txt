int	O
finalize_syms	int
=	O
0	int
;	O
int	O
symbol_table_frozen	int
;	O
symbolS	struct
*	O
abs_section_sym	pointer
;	O
addressT	long
dot_value	long
;	O
fragS	struct
*	O
dot_frag	pointer
;	O
struct	O
reloc_list	struct
*	O
reloc_list	struct
;	O
void	O
print_fixup	function
(	O
fixS	struct
*	O
)	O
;	O
static	O
int	O
frags_chained	int
=	O
0	int
;	O
static	O
int	O
n_fixups	int
;	O
static	O
fixS	struct
*	O
fix_new_internal	function
(	O
fragS	struct
*	O
frag	struct
,	O
unsigned	O
long	O
where	long
,	O
unsigned	O
long	O
size	int
,	O
symbolS	struct
*	O
add_symbol	pointer
,	O
symbolS	struct
*	O
sub_symbol	pointer
,	O
offsetT	long
offset	long
,	O
int	O
pcrel	int
,	O
RELOC_ENUM	O
r_type	enum
,	O
int	O
at_beginning	int
)	O
{	O
fixS	struct
*	O
fixP	pointer
;	O
n_fixups	int
++	O
;	O
fixP	pointer
=	O
(	O
fixS	struct
*	O
)	O
obstack_alloc	O
(	O
&	O
notes	struct
,	O
sizeof	O
(	O
fixS	struct
)	O
)	O
;	O
fixP	pointer
->	O
fx_frag	pointer
=	O
frag	struct
;	O
fixP	pointer
->	O
fx_where	long
=	O
where	long
;	O
fixP	pointer
->	O
fx_size	int
=	O
size	int
;	O
if	O
(	O
fixP	pointer
->	O
fx_size	int
!=	O
size	int
)	O
{	O
as_bad	function
(	O
_	O
(	O
"field fx_size too small to hold %lu"	pointer
)	O
,	O
size	int
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
fixP	pointer
->	O
fx_addsy	pointer
=	O
add_symbol	pointer
;	O
fixP	pointer
->	O
fx_subsy	pointer
=	O
sub_symbol	pointer
;	O
fixP	pointer
->	O
fx_offset	long
=	O
offset	long
;	O
fixP	pointer
->	O
fx_dot_value	long
=	O
dot_value	long
;	O
fixP	pointer
->	O
fx_dot_frag	pointer
=	O
dot_frag	pointer
;	O
fixP	pointer
->	O
fx_pcrel	int
=	O
pcrel	int
;	O
fixP	pointer
->	O
fx_r_type	enum
=	O
r_type	enum
;	O
fixP	pointer
->	O
fx_pcrel_adjust	int
=	O
0	int
;	O
fixP	pointer
->	O
fx_addnumber	long
=	O
0	int
;	O
fixP	pointer
->	O
fx_tcbit	int
=	O
0	int
;	O
fixP	pointer
->	O
fx_tcbit2	int
=	O
0	int
;	O
fixP	pointer
->	O
fx_done	int
=	O
0	int
;	O
fixP	pointer
->	O
fx_no_overflow	int
=	O
0	int
;	O
fixP	pointer
->	O
fx_signed	int
=	O
0	int
;	O
fixP	pointer
->	O
fx_file	pointer
=	O
as_where	function
(	O
&	O
fixP	pointer
->	O
fx_line	int
)	O
;	O
{	O
fixS	struct
*	O
*	O
seg_fix_rootP	pointer
=	O
(	O
frags_chained	int
?	O
&	O
seg_info	O
(	O
now_seg	pointer
)	O
->	O
fix_root	pointer
:	O
&	O
frchain_now	pointer
->	O
fix_root	pointer
)	O
;	O
fixS	struct
*	O
*	O
seg_fix_tailP	pointer
=	O
(	O
frags_chained	int
?	O
&	O
seg_info	O
(	O
now_seg	pointer
)	O
->	O
fix_tail	pointer
:	O
&	O
frchain_now	pointer
->	O
fix_tail	pointer
)	O
;	O
if	O
(	O
at_beginning	int
)	O
{	O
fixP	pointer
->	O
fx_next	pointer
=	O
*	O
seg_fix_rootP	pointer
;	O
*	O
seg_fix_rootP	pointer
=	O
fixP	pointer
;	O
if	O
(	O
fixP	pointer
->	O
fx_next	pointer
==	O
NULL	O
)	O
*	O
seg_fix_tailP	pointer
=	O
fixP	pointer
;	O
}	O
else	O
{	O
fixP	pointer
->	O
fx_next	pointer
=	O
NULL	O
;	O
if	O
(	O
*	O
seg_fix_tailP	pointer
)	O
(	O
*	O
seg_fix_tailP	pointer
)	O
->	O
fx_next	pointer
=	O
fixP	pointer
;	O
else	O
*	O
seg_fix_rootP	pointer
=	O
fixP	pointer
;	O
*	O
seg_fix_tailP	pointer
=	O
fixP	pointer
;	O
}	O
}	O
return	O
fixP	pointer
;	O
}	O
fixS	struct
*	O
fix_new	function
(	O
fragS	struct
*	O
frag	struct
,	O
unsigned	O
long	O
where	long
,	O
unsigned	O
long	O
size	int
,	O
symbolS	struct
*	O
add_symbol	pointer
,	O
offsetT	long
offset	long
,	O
int	O
pcrel	int
,	O
RELOC_ENUM	O
r_type	enum
)	O
{	O
return	O
fix_new_internal	function
(	O
frag	struct
,	O
where	long
,	O
size	int
,	O
add_symbol	pointer
,	O
(	O
symbolS	struct
*	O
)	O
NULL	O
,	O
offset	long
,	O
pcrel	int
,	O
r_type	enum
,	O
FALSE	int
)	O
;	O
}	O
fixS	struct
*	O
fix_new_exp	function
(	O
fragS	struct
*	O
frag	struct
,	O
unsigned	O
long	O
where	long
,	O
unsigned	O
long	O
size	int
,	O
expressionS	struct
*	O
exp	pointer
,	O
int	O
pcrel	int
,	O
RELOC_ENUM	O
r_type	enum
)	O
{	O
symbolS	struct
*	O
add	pointer
=	O
NULL	O
;	O
symbolS	struct
*	O
sub	pointer
=	O
NULL	O
;	O
offsetT	long
off	long
=	O
0	int
;	O
switch	O
(	O
exp	pointer
->	O
X_op	enum
)	O
{	O
case	O
O_absent	int
:	O
break	O
;	O
case	O
O_register	int
:	O
as_bad	function
(	O
_	O
(	O
"register value used as expression"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
O_add	int
:	O
{	O
symbolS	struct
*	O
stmp	pointer
=	O
make_expr_symbol	function
(	O
exp	pointer
)	O
;	O
exp	pointer
->	O
X_op	enum
=	O
O_symbol	int
;	O
exp	pointer
->	O
X_op_symbol	pointer
=	O
0	int
;	O
exp	pointer
->	O
X_add_symbol	pointer
=	O
stmp	pointer
;	O
exp	pointer
->	O
X_add_number	long
=	O
0	int
;	O
return	O
fix_new_exp	function
(	O
frag	struct
,	O
where	long
,	O
size	int
,	O
exp	pointer
,	O
pcrel	int
,	O
r_type	enum
)	O
;	O
}	O
case	O
O_symbol_rva	int
:	O
add	pointer
=	O
exp	pointer
->	O
X_add_symbol	pointer
;	O
off	long
=	O
exp	pointer
->	O
X_add_number	long
;	O
r_type	enum
=	O
BFD_RELOC_RVA	int
;	O
break	O
;	O
case	O
O_uminus	int
:	O
sub	pointer
=	O
exp	pointer
->	O
X_add_symbol	pointer
;	O
off	long
=	O
exp	pointer
->	O
X_add_number	long
;	O
break	O
;	O
case	O
O_subtract	int
:	O
sub	pointer
=	O
exp	pointer
->	O
X_op_symbol	pointer
;	O
case	O
O_symbol	int
:	O
add	pointer
=	O
exp	pointer
->	O
X_add_symbol	pointer
;	O
case	O
O_constant	int
:	O
off	long
=	O
exp	pointer
->	O
X_add_number	long
;	O
break	O
;	O
default	O
:	O
add	pointer
=	O
make_expr_symbol	function
(	O
exp	pointer
)	O
;	O
break	O
;	O
}	O
return	O
fix_new_internal	function
(	O
frag	struct
,	O
where	long
,	O
size	int
,	O
add	pointer
,	O
sub	pointer
,	O
off	long
,	O
pcrel	int
,	O
r_type	enum
,	O
FALSE	int
)	O
;	O
}	O
fixS	struct
*	O
fix_at_start	function
(	O
fragS	struct
*	O
frag	struct
,	O
unsigned	O
long	O
size	int
,	O
symbolS	struct
*	O
add_symbol	pointer
,	O
offsetT	long
offset	long
,	O
int	O
pcrel	int
,	O
RELOC_ENUM	O
r_type	enum
)	O
{	O
return	O
fix_new_internal	function
(	O
frag	struct
,	O
0	int
,	O
size	int
,	O
add_symbol	pointer
,	O
(	O
symbolS	struct
*	O
)	O
NULL	O
,	O
offset	long
,	O
pcrel	int
,	O
r_type	enum
,	O
TRUE	int
)	O
;	O
}	O
int	O
generic_force_reloc	function
(	O
fixS	struct
*	O
fix	struct
)	O
{	O
if	O
(	O
fix	struct
->	O
fx_r_type	enum
==	O
BFD_RELOC_VTABLE_INHERIT	int
||	O
fix	struct
->	O
fx_r_type	enum
==	O
BFD_RELOC_VTABLE_ENTRY	int
)	O
return	O
1	int
;	O
if	O
(	O
fix	struct
->	O
fx_addsy	pointer
==	O
NULL	O
)	O
return	O
0	int
;	O
return	O
S_FORCE_RELOC	function
(	O
fix	struct
->	O
fx_addsy	pointer
,	O
fix	struct
->	O
fx_subsy	pointer
==	O
NULL	O
)	O
;	O
}	O
void	O
append	function
(	O
char	O
*	O
*	O
charPP	pointer
,	O
char	O
*	O
fromP	pointer
,	O
unsigned	O
long	O
length	char
)	O
{	O
if	O
(	O
length	char
==	O
0	int
)	O
return	O
;	O
memcpy	function
(	O
*	O
charPP	pointer
,	O
fromP	pointer
,	O
length	char
)	O
;	O
*	O
charPP	pointer
+=	O
length	char
;	O
}	O
void	O
record_alignment	function
(	O
segT	pointer
seg	pointer
,	O
unsigned	O
int	O
align	int
)	O
{	O
if	O
(	O
seg	pointer
==	O
absolute_section	O
)	O
return	O
;	O
if	O
(	O
align	int
>	O
bfd_section_alignment	function
(	O
seg	pointer
)	O
)	O
bfd_set_section_alignment	function
(	O
seg	pointer
,	O
align	int
)	O
;	O
}	O
int	O
get_recorded_alignment	function
(	O
segT	pointer
seg	pointer
)	O
{	O
if	O
(	O
seg	pointer
==	O
absolute_section	O
)	O
return	O
0	int
;	O
return	O
bfd_section_alignment	function
(	O
seg	pointer
)	O
;	O
}	O
static	O
void	O
renumber_sections	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
asection	struct
*	O
sec	pointer
,	O
void	O
*	O
countparg	pointer
)	O
{	O
int	O
*	O
countp	pointer
=	O
(	O
int	O
*	O
)	O
countparg	pointer
;	O
sec	pointer
->	O
index	function
=	O
*	O
countp	pointer
;	O
++	O
*	O
countp	pointer
;	O
}	O
static	O
fragS	struct
*	O
chain_frchains_together_1	function
(	O
segT	pointer
section	pointer
,	O
struct	O
frchain	struct
*	O
frchp	pointer
)	O
{	O
fragS	struct
dummy	struct
,	O
*	O
prev_frag	pointer
=	O
&	O
dummy	struct
;	O
fixS	struct
fix_dummy	struct
,	O
*	O
prev_fix	pointer
=	O
&	O
fix_dummy	struct
;	O
for	O
(	O
;	O
frchp	pointer
;	O
frchp	pointer
=	O
frchp	pointer
->	O
frch_next	pointer
)	O
{	O
prev_frag	pointer
->	O
fr_next	pointer
=	O
frchp	pointer
->	O
frch_root	pointer
;	O
prev_frag	pointer
=	O
frchp	pointer
->	O
frch_last	pointer
;	O
gas_assert	O
(	O
prev_frag	pointer
->	O
fr_type	enum
!=	O
0	int
)	O
;	O
if	O
(	O
frchp	pointer
->	O
fix_root	pointer
!=	O
(	O
fixS	struct
*	O
)	O
NULL	O
)	O
{	O
if	O
(	O
seg_info	O
(	O
section	pointer
)	O
->	O
fix_root	pointer
==	O
(	O
fixS	struct
*	O
)	O
NULL	O
)	O
seg_info	O
(	O
section	pointer
)	O
->	O
fix_root	pointer
=	O
frchp	pointer
->	O
fix_root	pointer
;	O
prev_fix	pointer
->	O
fx_next	pointer
=	O
frchp	pointer
->	O
fix_root	pointer
;	O
seg_info	O
(	O
section	pointer
)	O
->	O
fix_tail	pointer
=	O
frchp	pointer
->	O
fix_tail	pointer
;	O
prev_fix	pointer
=	O
frchp	pointer
->	O
fix_tail	pointer
;	O
}	O
}	O
gas_assert	O
(	O
prev_frag	pointer
!=	O
&	O
dummy	struct
&&	O
prev_frag	pointer
->	O
fr_type	enum
!=	O
0	int
)	O
;	O
prev_frag	pointer
->	O
fr_next	pointer
=	O
0	int
;	O
return	O
prev_frag	pointer
;	O
}	O
static	O
void	O
chain_frchains_together	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
segT	pointer
section	pointer
,	O
void	O
*	O
xxx	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
segment_info_type	struct
*	O
info	pointer
;	O
info	pointer
=	O
seg_info	O
(	O
section	pointer
)	O
;	O
if	O
(	O
info	pointer
!=	O
(	O
segment_info_type	struct
*	O
)	O
NULL	O
)	O
info	pointer
->	O
frchainP	pointer
->	O
frch_last	pointer
=	O
chain_frchains_together_1	function
(	O
section	pointer
,	O
info	pointer
->	O
frchainP	pointer
)	O
;	O
frags_chained	int
=	O
1	int
;	O
}	O
static	O
void	O
cvt_frag_to_fill	function
(	O
segT	pointer
sec	pointer
ATTRIBUTE_UNUSED	O
,	O
fragS	struct
*	O
fragP	pointer
)	O
{	O
switch	O
(	O
fragP	pointer
->	O
fr_type	enum
)	O
{	O
case	O
rs_space_nop	int
:	O
goto	O
skip_align	O
;	O
case	O
rs_align	int
:	O
case	O
rs_align_code	int
:	O
case	O
rs_align_test	int
:	O
case	O
rs_org	int
:	O
case	O
rs_space	int
:	O
HANDLE_ALIGN	O
(	O
fragP	pointer
)	O
;	O
skip_align	O
:	O
know	O
(	O
fragP	pointer
->	O
fr_next	pointer
!=	O
NULL	O
)	O
;	O
fragP	pointer
->	O
fr_offset	long
=	O
(	O
fragP	pointer
->	O
fr_next	pointer
->	O
fr_address	long
-	O
fragP	pointer
->	O
fr_address	long
-	O
fragP	pointer
->	O
fr_fix	long
)	O
/	O
fragP	pointer
->	O
fr_var	long
;	O
if	O
(	O
fragP	pointer
->	O
fr_offset	long
<	O
0	int
)	O
{	O
as_bad_where	function
(	O
fragP	pointer
->	O
fr_file	pointer
,	O
fragP	pointer
->	O
fr_line	int
,	O
_	O
(	O
"attempt to .org/.space/.nops backwards? (%ld)"	pointer
)	O
,	O
(	O
long	O
)	O
fragP	pointer
->	O
fr_offset	long
)	O
;	O
fragP	pointer
->	O
fr_offset	long
=	O
0	int
;	O
}	O
if	O
(	O
fragP	pointer
->	O
fr_type	enum
==	O
rs_space_nop	int
)	O
fragP	pointer
->	O
fr_type	enum
=	O
rs_fill_nop	int
;	O
else	O
fragP	pointer
->	O
fr_type	enum
=	O
rs_fill	int
;	O
break	O
;	O
case	O
rs_fill	int
:	O
case	O
rs_fill_nop	int
:	O
break	O
;	O
case	O
rs_leb128	int
:	O
{	O
valueT	long
value	long
=	O
S_GET_VALUE	function
(	O
fragP	pointer
->	O
fr_symbol	pointer
)	O
;	O
int	O
size	int
;	O
if	O
(	O
!	O
S_IS_DEFINED	function
(	O
fragP	pointer
->	O
fr_symbol	pointer
)	O
)	O
{	O
as_bad_where	function
(	O
fragP	pointer
->	O
fr_file	pointer
,	O
fragP	pointer
->	O
fr_line	int
,	O
_	O
(	O
"leb128 operand is an undefined symbol: %s"	pointer
)	O
,	O
S_GET_NAME	function
(	O
fragP	pointer
->	O
fr_symbol	pointer
)	O
)	O
;	O
}	O
size	int
=	O
output_leb128	function
(	O
fragP	pointer
->	O
fr_literal	array
+	O
fragP	pointer
->	O
fr_fix	long
,	O
value	long
,	O
fragP	pointer
->	O
fr_subtype	int
)	O
;	O
fragP	pointer
->	O
fr_fix	long
+=	O
size	int
;	O
fragP	pointer
->	O
fr_type	enum
=	O
rs_fill	int
;	O
fragP	pointer
->	O
fr_var	long
=	O
0	int
;	O
fragP	pointer
->	O
fr_offset	long
=	O
0	int
;	O
fragP	pointer
->	O
fr_symbol	pointer
=	O
NULL	O
;	O
}	O
break	O
;	O
case	O
rs_cfa	int
:	O
eh_frame_convert_frag	function
(	O
fragP	pointer
)	O
;	O
break	O
;	O
case	O
rs_dwarf2dbg	int
:	O
dwarf2dbg_convert_frag	function
(	O
fragP	pointer
)	O
;	O
break	O
;	O
case	O
rs_machine_dependent	int
:	O
md_convert_frag	function
(	O
stdoutput	pointer
,	O
sec	pointer
,	O
fragP	pointer
)	O
;	O
gas_assert	O
(	O
fragP	pointer
->	O
fr_next	pointer
==	O
NULL	O
||	O
(	O
fragP	pointer
->	O
fr_next	pointer
->	O
fr_address	long
-	O
fragP	pointer
->	O
fr_address	long
==	O
fragP	pointer
->	O
fr_fix	long
)	O
)	O
;	O
frag_wane	function
(	O
fragP	pointer
)	O
;	O
break	O
;	O
default	O
:	O
BAD_CASE	O
(	O
fragP	pointer
->	O
fr_type	enum
)	O
;	O
break	O
;	O
}	O
}	O
struct	O
relax_seg_info	struct
{	O
int	O
pass	int
;	O
int	O
changed	int
;	O
}	O
;	O
static	O
void	O
relax_seg	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
asection	struct
*	O
sec	pointer
,	O
void	O
*	O
xxx	pointer
)	O
{	O
segment_info_type	struct
*	O
seginfo	pointer
=	O
seg_info	O
(	O
sec	pointer
)	O
;	O
struct	O
relax_seg_info	struct
*	O
info	pointer
=	O
(	O
struct	O
relax_seg_info	struct
*	O
)	O
xxx	pointer
;	O
if	O
(	O
seginfo	pointer
&&	O
seginfo	pointer
->	O
frchainP	pointer
&&	O
relax_segment	function
(	O
seginfo	pointer
->	O
frchainP	pointer
->	O
frch_root	pointer
,	O
sec	pointer
,	O
info	pointer
->	O
pass	int
)	O
)	O
info	pointer
->	O
changed	int
=	O
1	int
;	O
}	O
static	O
void	O
size_seg	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
asection	struct
*	O
sec	pointer
,	O
void	O
*	O
xxx	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
flagword	int
flags	int
;	O
fragS	struct
*	O
fragp	pointer
;	O
segment_info_type	struct
*	O
seginfo	pointer
;	O
int	O
x	int
;	O
valueT	long
size	int
,	O
newsize	long
;	O
subseg_change	function
(	O
sec	pointer
,	O
0	int
)	O
;	O
seginfo	pointer
=	O
seg_info	O
(	O
sec	pointer
)	O
;	O
if	O
(	O
seginfo	pointer
&&	O
seginfo	pointer
->	O
frchainP	pointer
)	O
{	O
for	O
(	O
fragp	pointer
=	O
seginfo	pointer
->	O
frchainP	pointer
->	O
frch_root	pointer
;	O
fragp	pointer
;	O
fragp	pointer
=	O
fragp	pointer
->	O
fr_next	pointer
)	O
cvt_frag_to_fill	function
(	O
sec	pointer
,	O
fragp	pointer
)	O
;	O
for	O
(	O
fragp	pointer
=	O
seginfo	pointer
->	O
frchainP	pointer
->	O
frch_root	pointer
;	O
fragp	pointer
->	O
fr_next	pointer
;	O
fragp	pointer
=	O
fragp	pointer
->	O
fr_next	pointer
)	O
;	O
size	int
=	O
fragp	pointer
->	O
fr_address	long
+	O
fragp	pointer
->	O
fr_fix	long
;	O
}	O
else	O
size	int
=	O
0	int
;	O
flags	int
=	O
bfd_section_flags	function
(	O
sec	pointer
)	O
;	O
if	O
(	O
size	int
==	O
0	int
&&	O
bfd_section_size	function
(	O
sec	pointer
)	O
!=	O
0	int
&&	O
(	O
flags	int
&	O
SEC_HAS_CONTENTS	int
)	O
!=	O
0	int
)	O
return	O
;	O
if	O
(	O
size	int
>	O
0	int
&&	O
!	O
seginfo	pointer
->	O
bss	int
)	O
flags	int
|=	O
SEC_HAS_CONTENTS	int
;	O
flags	int
&=	O
~	O
SEC_RELOC	int
;	O
x	int
=	O
bfd_set_section_flags	function
(	O
sec	pointer
,	O
flags	int
)	O
;	O
gas_assert	O
(	O
x	int
)	O
;	O
if	O
(	O
do_not_pad_sections_to_alignment	int
)	O
newsize	long
=	O
size	int
;	O
else	O
newsize	long
=	O
md_section_align	function
(	O
sec	pointer
,	O
size	int
)	O
;	O
x	int
=	O
bfd_set_section_size	function
(	O
sec	pointer
,	O
newsize	long
)	O
;	O
gas_assert	O
(	O
x	int
)	O
;	O
gas_assert	O
(	O
newsize	long
>=	O
size	int
)	O
;	O
if	O
(	O
size	int
!=	O
newsize	long
)	O
{	O
fragS	struct
*	O
last	pointer
=	O
seginfo	pointer
->	O
frchainP	pointer
->	O
frch_last	pointer
;	O
fragp	pointer
=	O
seginfo	pointer
->	O
frchainP	pointer
->	O
frch_root	pointer
;	O
while	O
(	O
fragp	pointer
->	O
fr_next	pointer
!=	O
last	pointer
)	O
fragp	pointer
=	O
fragp	pointer
->	O
fr_next	pointer
;	O
last	pointer
->	O
fr_address	long
=	O
size	int
;	O
if	O
(	O
(	O
newsize	long
-	O
size	int
)	O
%	O
fragp	pointer
->	O
fr_var	long
==	O
0	int
)	O
fragp	pointer
->	O
fr_offset	long
+=	O
(	O
newsize	long
-	O
size	int
)	O
/	O
fragp	pointer
->	O
fr_var	long
;	O
else	O
abort	function
(	O
)	O
;	O
}	O
}	O
static	O
void	O
resolve_reloc_expr_symbols	function
(	O
void	O
)	O
{	O
bfd_vma	long
addr_mask	long
=	O
1	int
;	O
struct	O
reloc_list	struct
*	O
r	struct
;	O
addr_mask	long
<<=	O
bfd_arch_bits_per_address	function
(	O
stdoutput	pointer
)	O
-	O
1	int
;	O
addr_mask	long
<<=	O
1	int
;	O
addr_mask	long
-=	O
1	int
;	O
for	O
(	O
r	struct
=	O
reloc_list	struct
;	O
r	struct
;	O
r	struct
=	O
r	struct
->	O
next	pointer
)	O
{	O
reloc_howto_type	struct
*	O
howto	pointer
=	O
r	struct
->	O
u	union
.	O
a	pointer
.	O
howto	pointer
;	O
expressionS	struct
*	O
symval	pointer
;	O
symbolS	struct
*	O
sym	pointer
;	O
bfd_vma	long
offset	long
,	O
addend	long
;	O
asection	struct
*	O
sec	pointer
;	O
resolve_symbol_value	function
(	O
r	struct
->	O
u	union
.	O
a	pointer
.	O
offset_sym	pointer
)	O
;	O
symval	pointer
=	O
symbol_get_value_expression	function
(	O
r	struct
->	O
u	union
.	O
a	pointer
.	O
offset_sym	pointer
)	O
;	O
offset	long
=	O
0	int
;	O
sym	pointer
=	O
NULL	O
;	O
if	O
(	O
symval	pointer
->	O
X_op	enum
==	O
O_constant	int
)	O
sym	pointer
=	O
r	struct
->	O
u	union
.	O
a	pointer
.	O
offset_sym	pointer
;	O
else	O
if	O
(	O
symval	pointer
->	O
X_op	enum
==	O
O_symbol	int
)	O
{	O
sym	pointer
=	O
symval	pointer
->	O
X_add_symbol	pointer
;	O
offset	long
=	O
symval	pointer
->	O
X_add_number	long
;	O
symval	pointer
=	O
symbol_get_value_expression	function
(	O
symval	pointer
->	O
X_add_symbol	pointer
)	O
;	O
}	O
if	O
(	O
sym	pointer
==	O
NULL	O
||	O
symval	pointer
->	O
X_op	enum
!=	O
O_constant	int
||	O
(	O
sec	pointer
=	O
S_GET_SEGMENT	function
(	O
sym	pointer
)	O
)	O
==	O
NULL	O
||	O
!	O
SEG_NORMAL	O
(	O
sec	pointer
)	O
)	O
{	O
as_bad_where	function
(	O
r	struct
->	O
file	pointer
,	O
r	struct
->	O
line	int
,	O
_	O
(	O
"invalid offset expression"	pointer
)	O
)	O
;	O
sec	pointer
=	O
NULL	O
;	O
}	O
else	O
offset	long
+=	O
S_GET_VALUE	function
(	O
sym	pointer
)	O
;	O
sym	pointer
=	O
NULL	O
;	O
addend	long
=	O
r	struct
->	O
u	union
.	O
a	pointer
.	O
addend	long
;	O
if	O
(	O
r	struct
->	O
u	union
.	O
a	pointer
.	O
sym	pointer
!=	O
NULL	O
)	O
{	O
resolve_symbol_value	function
(	O
r	struct
->	O
u	union
.	O
a	pointer
.	O
sym	pointer
)	O
;	O
symval	pointer
=	O
symbol_get_value_expression	function
(	O
r	struct
->	O
u	union
.	O
a	pointer
.	O
sym	pointer
)	O
;	O
if	O
(	O
symval	pointer
->	O
X_op	enum
==	O
O_constant	int
)	O
sym	pointer
=	O
r	struct
->	O
u	union
.	O
a	pointer
.	O
sym	pointer
;	O
else	O
if	O
(	O
symval	pointer
->	O
X_op	enum
==	O
O_symbol	int
)	O
{	O
sym	pointer
=	O
symval	pointer
->	O
X_add_symbol	pointer
;	O
addend	long
+=	O
symval	pointer
->	O
X_add_number	long
;	O
symval	pointer
=	O
symbol_get_value_expression	function
(	O
symval	pointer
->	O
X_add_symbol	pointer
)	O
;	O
}	O
if	O
(	O
symval	pointer
->	O
X_op	enum
!=	O
O_constant	int
)	O
{	O
as_bad_where	function
(	O
r	struct
->	O
file	pointer
,	O
r	struct
->	O
line	int
,	O
_	O
(	O
"invalid reloc expression"	pointer
)	O
)	O
;	O
sec	pointer
=	O
NULL	O
;	O
}	O
else	O
if	O
(	O
sym	pointer
!=	O
NULL	O
&&	O
sec	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
S_IS_LOCAL	function
(	O
sym	pointer
)	O
&&	O
!	O
symbol_section_p	function
(	O
sym	pointer
)	O
&&	O
(	O
sec	pointer
->	O
use_rela_p	int
||	O
(	O
howto	pointer
->	O
partial_inplace	int
&&	O
(	O
!	O
howto	pointer
->	O
pc_relative	int
||	O
howto	pointer
->	O
src_mask	long
==	O
addr_mask	long
)	O
)	O
)	O
)	O
{	O
asection	struct
*	O
symsec	pointer
=	O
S_GET_SEGMENT	function
(	O
sym	pointer
)	O
;	O
if	O
(	O
!	O
(	O
(	O
(	O
symsec	pointer
->	O
flags	int
&	O
SEC_MERGE	int
)	O
!=	O
0	int
&&	O
addend	long
!=	O
0	int
)	O
||	O
(	O
symsec	pointer
->	O
flags	int
&	O
SEC_THREAD_LOCAL	int
)	O
!=	O
0	int
)	O
)	O
{	O
addend	long
+=	O
S_GET_VALUE	function
(	O
sym	pointer
)	O
;	O
sym	pointer
=	O
section_symbol	function
(	O
symsec	pointer
)	O
;	O
}	O
}	O
symbol_mark_used_in_reloc	function
(	O
sym	pointer
)	O
;	O
}	O
}	O
if	O
(	O
sym	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
abs_section_sym	pointer
==	O
NULL	O
)	O
abs_section_sym	pointer
=	O
section_symbol	function
(	O
absolute_section	O
)	O
;	O
sym	pointer
=	O
abs_section_sym	pointer
;	O
}	O
r	struct
->	O
u	union
.	O
b	pointer
.	O
sec	pointer
=	O
sec	pointer
;	O
r	struct
->	O
u	union
.	O
b	pointer
.	O
s	pointer
=	O
symbol_get_bfdsym	function
(	O
sym	pointer
)	O
;	O
r	struct
->	O
u	union
.	O
b	pointer
.	O
r	struct
.	O
sym_ptr_ptr	pointer
=	O
&	O
r	struct
->	O
u	union
.	O
b	pointer
.	O
s	pointer
;	O
r	struct
->	O
u	union
.	O
b	pointer
.	O
r	struct
.	O
address	long
=	O
offset	long
;	O
r	struct
->	O
u	union
.	O
b	pointer
.	O
r	struct
.	O
addend	long
=	O
addend	long
;	O
r	struct
->	O
u	union
.	O
b	pointer
.	O
r	struct
.	O
howto	pointer
=	O
howto	pointer
;	O
}	O
}	O
static	O
void	O
adjust_reloc_syms	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
asection	struct
*	O
sec	pointer
,	O
void	O
*	O
xxx	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
segment_info_type	struct
*	O
seginfo	pointer
=	O
seg_info	O
(	O
sec	pointer
)	O
;	O
fixS	struct
*	O
fixp	pointer
;	O
if	O
(	O
seginfo	pointer
==	O
NULL	O
)	O
return	O
;	O
dump_section_relocs	O
(	O
abfd	pointer
,	O
sec	pointer
,	O
stderr	pointer
)	O
;	O
for	O
(	O
fixp	pointer
=	O
seginfo	pointer
->	O
fix_root	pointer
;	O
fixp	pointer
;	O
fixp	pointer
=	O
fixp	pointer
->	O
fx_next	pointer
)	O
if	O
(	O
fixp	pointer
->	O
fx_done	int
)	O
;	O
else	O
if	O
(	O
fixp	pointer
->	O
fx_addsy	pointer
)	O
{	O
symbolS	struct
*	O
sym	pointer
;	O
asection	struct
*	O
symsec	pointer
;	O
sym	pointer
=	O
fixp	pointer
->	O
fx_addsy	pointer
;	O
resolve_symbol_value	function
(	O
sym	pointer
)	O
;	O
if	O
(	O
fixp	pointer
->	O
fx_subsy	pointer
!=	O
NULL	O
)	O
resolve_symbol_value	function
(	O
fixp	pointer
->	O
fx_subsy	pointer
)	O
;	O
while	O
(	O
symbol_equated_reloc_p	function
(	O
sym	pointer
)	O
||	O
S_IS_WEAKREFR	function
(	O
sym	pointer
)	O
)	O
{	O
symbolS	struct
*	O
newsym	pointer
=	O
symbol_get_value_expression	function
(	O
sym	pointer
)	O
->	O
X_add_symbol	pointer
;	O
if	O
(	O
sym	pointer
==	O
newsym	pointer
)	O
break	O
;	O
fixp	pointer
->	O
fx_offset	long
+=	O
symbol_get_value_expression	function
(	O
sym	pointer
)	O
->	O
X_add_number	long
;	O
fixp	pointer
->	O
fx_addsy	pointer
=	O
newsym	pointer
;	O
sym	pointer
=	O
newsym	pointer
;	O
}	O
if	O
(	O
symbol_mri_common_p	function
(	O
sym	pointer
)	O
)	O
{	O
fixp	pointer
->	O
fx_offset	long
+=	O
S_GET_VALUE	function
(	O
sym	pointer
)	O
;	O
fixp	pointer
->	O
fx_addsy	pointer
=	O
symbol_get_value_expression	function
(	O
sym	pointer
)	O
->	O
X_add_symbol	pointer
;	O
continue	O
;	O
}	O
if	O
(	O
S_FORCE_RELOC	function
(	O
fixp	pointer
->	O
fx_addsy	pointer
,	O
1	int
)	O
)	O
continue	O
;	O
if	O
(	O
!	O
tc_fix_adjustable	O
(	O
fixp	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
symbol_section_p	function
(	O
sym	pointer
)	O
)	O
continue	O
;	O
symsec	pointer
=	O
S_GET_SEGMENT	function
(	O
sym	pointer
)	O
;	O
if	O
(	O
symsec	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
bfd_is_abs_section	function
(	O
symsec	pointer
)	O
||	O
symsec	pointer
==	O
reg_section	pointer
)	O
{	O
continue	O
;	O
}	O
if	O
(	O
symsec	pointer
!=	O
sec	pointer
&&	O
!	O
S_IS_LOCAL	function
(	O
sym	pointer
)	O
)	O
{	O
if	O
(	O
(	O
symsec	pointer
->	O
flags	int
&	O
SEC_LINK_ONCE	int
)	O
!=	O
0	int
||	O
(	O
IS_ELF	int
&&	O
strncmp	function
(	O
segment_name	O
(	O
symsec	pointer
)	O
,	O
".gnu.linkonce"	pointer
,	O
sizeof	O
".gnu.linkonce"	pointer
-	O
1	int
)	O
==	O
0	int
)	O
)	O
continue	O
;	O
}	O
if	O
(	O
(	O
symsec	pointer
->	O
flags	int
&	O
SEC_MERGE	int
)	O
!=	O
0	int
&&	O
(	O
fixp	pointer
->	O
fx_offset	long
!=	O
0	int
||	O
fixp	pointer
->	O
fx_subsy	pointer
!=	O
NULL	O
)	O
)	O
continue	O
;	O
if	O
(	O
(	O
symsec	pointer
->	O
flags	int
&	O
SEC_THREAD_LOCAL	int
)	O
!=	O
0	int
)	O
continue	O
;	O
fixp	pointer
->	O
fx_offset	long
+=	O
S_GET_VALUE	function
(	O
sym	pointer
)	O
;	O
fixp	pointer
->	O
fx_addsy	pointer
=	O
section_symbol	function
(	O
S_GET_SEGMENT	function
(	O
sym	pointer
)	O
)	O
;	O
}	O
dump_section_relocs	O
(	O
abfd	pointer
,	O
sec	pointer
,	O
stderr	pointer
)	O
;	O
}	O
static	O
void	O
fixup_segment	function
(	O
fixS	struct
*	O
fixP	pointer
,	O
segT	pointer
this_segment	pointer
)	O
{	O
valueT	long
add_number	long
;	O
fragS	struct
*	O
fragP	pointer
;	O
segT	pointer
add_symbol_segment	pointer
=	O
absolute_section	O
;	O
if	O
(	O
fixP	pointer
!=	O
NULL	O
&&	O
abs_section_sym	pointer
==	O
NULL	O
)	O
abs_section_sym	pointer
=	O
section_symbol	function
(	O
absolute_section	O
)	O
;	O
if	O
(	O
linkrelax	int
&&	O
TC_LINKRELAX_FIXUP	int
(	O
this_segment	pointer
)	O
)	O
{	O
for	O
(	O
;	O
fixP	pointer
;	O
fixP	pointer
=	O
fixP	pointer
->	O
fx_next	pointer
)	O
if	O
(	O
!	O
fixP	pointer
->	O
fx_done	int
)	O
{	O
if	O
(	O
fixP	pointer
->	O
fx_addsy	pointer
==	O
NULL	O
)	O
{	O
fixP	pointer
->	O
fx_addsy	pointer
=	O
abs_section_sym	pointer
;	O
}	O
symbol_mark_used_in_reloc	function
(	O
fixP	pointer
->	O
fx_addsy	pointer
)	O
;	O
if	O
(	O
fixP	pointer
->	O
fx_subsy	pointer
!=	O
NULL	O
)	O
symbol_mark_used_in_reloc	function
(	O
fixP	pointer
->	O
fx_subsy	pointer
)	O
;	O
}	O
return	O
;	O
}	O
for	O
(	O
;	O
fixP	pointer
;	O
fixP	pointer
=	O
fixP	pointer
->	O
fx_next	pointer
)	O
{	O
fragP	pointer
=	O
fixP	pointer
->	O
fx_frag	pointer
;	O
know	O
(	O
fragP	pointer
)	O
;	O
TC_VALIDATE_FIX	O
(	O
fixP	pointer
,	O
this_segment	pointer
,	O
skip	O
)	O
;	O
add_number	long
=	O
fixP	pointer
->	O
fx_offset	long
;	O
if	O
(	O
fixP	pointer
->	O
fx_addsy	pointer
!=	O
NULL	O
)	O
add_symbol_segment	pointer
=	O
S_GET_SEGMENT	function
(	O
fixP	pointer
->	O
fx_addsy	pointer
)	O
;	O
if	O
(	O
fixP	pointer
->	O
fx_subsy	pointer
!=	O
NULL	O
)	O
{	O
segT	pointer
sub_symbol_segment	pointer
;	O
resolve_symbol_value	function
(	O
fixP	pointer
->	O
fx_subsy	pointer
)	O
;	O
sub_symbol_segment	pointer
=	O
S_GET_SEGMENT	function
(	O
fixP	pointer
->	O
fx_subsy	pointer
)	O
;	O
if	O
(	O
fixP	pointer
->	O
fx_addsy	pointer
!=	O
NULL	O
&&	O
sub_symbol_segment	pointer
==	O
add_symbol_segment	pointer
&&	O
!	O
S_FORCE_RELOC	function
(	O
fixP	pointer
->	O
fx_addsy	pointer
,	O
0	int
)	O
&&	O
!	O
S_FORCE_RELOC	function
(	O
fixP	pointer
->	O
fx_subsy	pointer
,	O
0	int
)	O
&&	O
!	O
TC_FORCE_RELOCATION_SUB_SAME	O
(	O
fixP	pointer
,	O
add_symbol_segment	pointer
)	O
)	O
{	O
add_number	long
+=	O
S_GET_VALUE	function
(	O
fixP	pointer
->	O
fx_addsy	pointer
)	O
;	O
add_number	long
-=	O
S_GET_VALUE	function
(	O
fixP	pointer
->	O
fx_subsy	pointer
)	O
;	O
fixP	pointer
->	O
fx_offset	long
=	O
add_number	long
;	O
fixP	pointer
->	O
fx_addsy	pointer
=	O
NULL	O
;	O
fixP	pointer
->	O
fx_subsy	pointer
=	O
NULL	O
;	O
}	O
else	O
if	O
(	O
sub_symbol_segment	pointer
==	O
absolute_section	O
&&	O
!	O
S_FORCE_RELOC	function
(	O
fixP	pointer
->	O
fx_subsy	pointer
,	O
0	int
)	O
&&	O
!	O
TC_FORCE_RELOCATION_SUB_ABS	O
(	O
fixP	pointer
,	O
add_symbol_segment	pointer
)	O
)	O
{	O
add_number	long
-=	O
S_GET_VALUE	function
(	O
fixP	pointer
->	O
fx_subsy	pointer
)	O
;	O
fixP	pointer
->	O
fx_offset	long
=	O
add_number	long
;	O
fixP	pointer
->	O
fx_subsy	pointer
=	O
NULL	O
;	O
}	O
else	O
if	O
(	O
sub_symbol_segment	pointer
==	O
this_segment	pointer
&&	O
!	O
S_FORCE_RELOC	function
(	O
fixP	pointer
->	O
fx_subsy	pointer
,	O
0	int
)	O
&&	O
!	O
TC_FORCE_RELOCATION_SUB_LOCAL	O
(	O
fixP	pointer
,	O
add_symbol_segment	pointer
)	O
)	O
{	O
add_number	long
-=	O
S_GET_VALUE	function
(	O
fixP	pointer
->	O
fx_subsy	pointer
)	O
;	O
fixP	pointer
->	O
fx_offset	long
=	O
(	O
add_number	long
+	O
fixP	pointer
->	O
fx_dot_value	long
+	O
fixP	pointer
->	O
fx_dot_frag	pointer
->	O
fr_address	long
)	O
;	O
if	O
(	O
0	int
||	O
!	O
fixP	pointer
->	O
fx_pcrel	int
)	O
add_number	long
+=	O
MD_PCREL_FROM_SECTION	O
(	O
fixP	pointer
,	O
this_segment	pointer
)	O
;	O
fixP	pointer
->	O
fx_subsy	pointer
=	O
NULL	O
;	O
fixP	pointer
->	O
fx_pcrel	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
!	O
TC_VALIDATE_FIX_SUB	O
(	O
fixP	pointer
,	O
add_symbol_segment	pointer
)	O
)	O
{	O
if	O
(	O
!	O
md_register_arithmetic	int
&&	O
(	O
add_symbol_segment	pointer
==	O
reg_section	pointer
||	O
sub_symbol_segment	pointer
==	O
reg_section	pointer
)	O
)	O
as_bad_where	function
(	O
fixP	pointer
->	O
fx_file	pointer
,	O
fixP	pointer
->	O
fx_line	int
,	O
_	O
(	O
"register value used as expression"	pointer
)	O
)	O
;	O
else	O
as_bad_where	function
(	O
fixP	pointer
->	O
fx_file	pointer
,	O
fixP	pointer
->	O
fx_line	int
,	O
_	O
(	O
"can't resolve `%s' {%s section} - `%s' {%s section}"	pointer
)	O
,	O
fixP	pointer
->	O
fx_addsy	pointer
?	O
S_GET_NAME	function
(	O
fixP	pointer
->	O
fx_addsy	pointer
)	O
:	O
"0"	pointer
,	O
segment_name	O
(	O
add_symbol_segment	pointer
)	O
,	O
S_GET_NAME	function
(	O
fixP	pointer
->	O
fx_subsy	pointer
)	O
,	O
segment_name	O
(	O
sub_symbol_segment	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
sub_symbol_segment	pointer
!=	O
undefined_section	O
&&	O
!	O
bfd_is_com_section	function
(	O
sub_symbol_segment	pointer
)	O
&&	O
MD_APPLY_SYM_VALUE	int
(	O
fixP	pointer
)	O
)	O
add_number	long
-=	O
S_GET_VALUE	function
(	O
fixP	pointer
->	O
fx_subsy	pointer
)	O
;	O
}	O
if	O
(	O
fixP	pointer
->	O
fx_addsy	pointer
)	O
{	O
if	O
(	O
add_symbol_segment	pointer
==	O
this_segment	pointer
&&	O
!	O
S_FORCE_RELOC	function
(	O
fixP	pointer
->	O
fx_addsy	pointer
,	O
0	int
)	O
&&	O
!	O
TC_FORCE_RELOCATION_LOCAL	O
(	O
fixP	pointer
)	O
)	O
{	O
add_number	long
+=	O
S_GET_VALUE	function
(	O
fixP	pointer
->	O
fx_addsy	pointer
)	O
;	O
fixP	pointer
->	O
fx_offset	long
=	O
add_number	long
;	O
if	O
(	O
fixP	pointer
->	O
fx_pcrel	int
)	O
add_number	long
-=	O
MD_PCREL_FROM_SECTION	O
(	O
fixP	pointer
,	O
this_segment	pointer
)	O
;	O
fixP	pointer
->	O
fx_addsy	pointer
=	O
NULL	O
;	O
fixP	pointer
->	O
fx_pcrel	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
add_symbol_segment	pointer
==	O
absolute_section	O
&&	O
!	O
S_FORCE_RELOC	function
(	O
fixP	pointer
->	O
fx_addsy	pointer
,	O
0	int
)	O
&&	O
!	O
TC_FORCE_RELOCATION_ABS	O
(	O
fixP	pointer
)	O
)	O
{	O
add_number	long
+=	O
S_GET_VALUE	function
(	O
fixP	pointer
->	O
fx_addsy	pointer
)	O
;	O
fixP	pointer
->	O
fx_offset	long
=	O
add_number	long
;	O
fixP	pointer
->	O
fx_addsy	pointer
=	O
NULL	O
;	O
}	O
else	O
if	O
(	O
add_symbol_segment	pointer
!=	O
undefined_section	O
&&	O
!	O
bfd_is_com_section	function
(	O
add_symbol_segment	pointer
)	O
&&	O
MD_APPLY_SYM_VALUE	int
(	O
fixP	pointer
)	O
)	O
add_number	long
+=	O
S_GET_VALUE	function
(	O
fixP	pointer
->	O
fx_addsy	pointer
)	O
;	O
}	O
if	O
(	O
fixP	pointer
->	O
fx_pcrel	int
)	O
{	O
add_number	long
-=	O
MD_PCREL_FROM_SECTION	O
(	O
fixP	pointer
,	O
this_segment	pointer
)	O
;	O
if	O
(	O
!	O
fixP	pointer
->	O
fx_done	int
&&	O
fixP	pointer
->	O
fx_addsy	pointer
==	O
NULL	O
)	O
{	O
fixP	pointer
->	O
fx_addsy	pointer
=	O
abs_section_sym	pointer
;	O
}	O
}	O
if	O
(	O
!	O
fixP	pointer
->	O
fx_done	int
)	O
md_apply_fix	function
(	O
fixP	pointer
,	O
&	O
add_number	long
,	O
this_segment	pointer
)	O
;	O
if	O
(	O
!	O
fixP	pointer
->	O
fx_done	int
)	O
{	O
if	O
(	O
fixP	pointer
->	O
fx_addsy	pointer
==	O
NULL	O
)	O
fixP	pointer
->	O
fx_addsy	pointer
=	O
abs_section_sym	pointer
;	O
symbol_mark_used_in_reloc	function
(	O
fixP	pointer
->	O
fx_addsy	pointer
)	O
;	O
if	O
(	O
fixP	pointer
->	O
fx_subsy	pointer
!=	O
NULL	O
)	O
symbol_mark_used_in_reloc	function
(	O
fixP	pointer
->	O
fx_subsy	pointer
)	O
;	O
}	O
if	O
(	O
!	O
fixP	pointer
->	O
fx_no_overflow	int
&&	O
fixP	pointer
->	O
fx_size	int
!=	O
0	int
)	O
{	O
if	O
(	O
fixP	pointer
->	O
fx_size	int
<	O
sizeof	O
(	O
valueT	long
)	O
)	O
{	O
valueT	long
mask	int
;	O
mask	int
=	O
0	int
;	O
mask	int
--	O
;	O
mask	int
<<=	O
fixP	pointer
->	O
fx_size	int
*	O
8	int
-	O
(	O
fixP	pointer
->	O
fx_signed	int
?	O
1	int
:	O
0	int
)	O
;	O
if	O
(	O
(	O
add_number	long
&	O
mask	int
)	O
!=	O
0	int
&&	O
(	O
add_number	long
&	O
mask	int
)	O
!=	O
mask	int
)	O
{	O
char	O
buf	pointer
[	O
50	int
]	O
,	O
buf2	array
[	O
50	int
]	O
;	O
sprint_value	function
(	O
buf	pointer
,	O
fragP	pointer
->	O
fr_address	long
+	O
fixP	pointer
->	O
fx_where	long
)	O
;	O
if	O
(	O
add_number	long
>	O
1000	int
)	O
sprint_value	function
(	O
buf2	array
,	O
add_number	long
)	O
;	O
else	O
sprintf	function
(	O
buf2	array
,	O
"%ld"	pointer
,	O
(	O
long	O
)	O
add_number	long
)	O
;	O
as_bad_where	function
(	O
fixP	pointer
->	O
fx_file	pointer
,	O
fixP	pointer
->	O
fx_line	int
,	O
ngettext	function
(	O
"value of %s too large for field "	pointer
"of %d byte at %s"	pointer
,	O
"value of %s too large for field "	pointer
"of %d bytes at %s"	pointer
,	O
fixP	pointer
->	O
fx_size	int
)	O
,	O
buf2	array
,	O
fixP	pointer
->	O
fx_size	int
,	O
buf	pointer
)	O
;	O
}	O
}	O
}	O
skip	O
:	O
ATTRIBUTE_UNUSED_LABEL	O
;	O
}	O
}	O
static	O
void	O
fix_segment	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
asection	struct
*	O
sec	pointer
,	O
void	O
*	O
xxx	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
segment_info_type	struct
*	O
seginfo	pointer
=	O
seg_info	O
(	O
sec	pointer
)	O
;	O
fixup_segment	function
(	O
seginfo	pointer
->	O
fix_root	pointer
,	O
sec	pointer
)	O
;	O
}	O
static	O
void	O
install_reloc	function
(	O
asection	struct
*	O
sec	pointer
,	O
arelent	struct
*	O
reloc	enum
,	O
fragS	struct
*	O
fragp	pointer
,	O
const	O
char	O
*	O
file	pointer
,	O
unsigned	O
int	O
line	int
)	O
{	O
char	O
*	O
err	pointer
;	O
bfd_reloc_status_type	enum
s	pointer
;	O
asymbol	struct
*	O
sym	pointer
;	O
if	O
(	O
reloc	enum
->	O
sym_ptr_ptr	pointer
!=	O
NULL	O
&&	O
(	O
sym	pointer
=	O
*	O
reloc	enum
->	O
sym_ptr_ptr	pointer
)	O
!=	O
NULL	O
&&	O
(	O
sym	pointer
->	O
flags	int
&	O
BSF_KEEP	O
)	O
==	O
0	int
&&	O
(	O
(	O
sym	pointer
->	O
flags	int
&	O
BSF_SECTION_SYM	O
)	O
==	O
0	int
||	O
(	O
EMIT_SECTION_SYMBOLS	int
&&	O
!	O
bfd_is_abs_section	function
(	O
sym	pointer
->	O
section	pointer
)	O
)	O
)	O
)	O
as_bad_where	function
(	O
file	pointer
,	O
line	int
,	O
_	O
(	O
"redefined symbol cannot be used on reloc"	pointer
)	O
)	O
;	O
s	pointer
=	O
bfd_install_relocation	function
(	O
stdoutput	pointer
,	O
reloc	enum
,	O
fragp	pointer
->	O
fr_literal	array
,	O
fragp	pointer
->	O
fr_address	long
,	O
sec	pointer
,	O
&	O
err	pointer
)	O
;	O
switch	O
(	O
s	pointer
)	O
{	O
case	O
bfd_reloc_ok	int
:	O
break	O
;	O
case	O
bfd_reloc_overflow	int
:	O
as_bad_where	function
(	O
file	pointer
,	O
line	int
,	O
_	O
(	O
"relocation overflow"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
bfd_reloc_outofrange	int
:	O
as_bad_where	function
(	O
file	pointer
,	O
line	int
,	O
_	O
(	O
"relocation out of range"	pointer
)	O
)	O
;	O
break	O
;	O
default	O
:	O
as_fatal	function
(	O
_	O
(	O
"%s:%u: bad return from bfd_install_relocation: %x"	pointer
)	O
,	O
file	pointer
,	O
line	int
,	O
s	pointer
)	O
;	O
}	O
}	O
static	O
fragS	struct
*	O
get_frag_for_reloc	function
(	O
fragS	struct
*	O
last_frag	pointer
,	O
const	O
segment_info_type	struct
*	O
seginfo	pointer
,	O
const	O
struct	O
reloc_list	struct
*	O
r	struct
)	O
{	O
fragS	struct
*	O
f	pointer
;	O
for	O
(	O
f	pointer
=	O
last_frag	pointer
;	O
f	pointer
!=	O
NULL	O
;	O
f	pointer
=	O
f	pointer
->	O
fr_next	pointer
)	O
if	O
(	O
f	pointer
->	O
fr_address	long
<=	O
r	struct
->	O
u	union
.	O
b	pointer
.	O
r	struct
.	O
address	long
&&	O
r	struct
->	O
u	union
.	O
b	pointer
.	O
r	struct
.	O
address	long
<	O
f	pointer
->	O
fr_address	long
+	O
f	pointer
->	O
fr_fix	long
)	O
return	O
f	pointer
;	O
for	O
(	O
f	pointer
=	O
seginfo	pointer
->	O
frchainP	pointer
->	O
frch_root	pointer
;	O
f	pointer
!=	O
NULL	O
;	O
f	pointer
=	O
f	pointer
->	O
fr_next	pointer
)	O
if	O
(	O
f	pointer
->	O
fr_address	long
<=	O
r	struct
->	O
u	union
.	O
b	pointer
.	O
r	struct
.	O
address	long
&&	O
r	struct
->	O
u	union
.	O
b	pointer
.	O
r	struct
.	O
address	long
<	O
f	pointer
->	O
fr_address	long
+	O
f	pointer
->	O
fr_fix	long
)	O
return	O
f	pointer
;	O
for	O
(	O
f	pointer
=	O
seginfo	pointer
->	O
frchainP	pointer
->	O
frch_root	pointer
;	O
f	pointer
!=	O
NULL	O
;	O
f	pointer
=	O
f	pointer
->	O
fr_next	pointer
)	O
if	O
(	O
f	pointer
->	O
fr_address	long
<=	O
r	struct
->	O
u	union
.	O
b	pointer
.	O
r	struct
.	O
address	long
&&	O
r	struct
->	O
u	union
.	O
b	pointer
.	O
r	struct
.	O
address	long
<=	O
f	pointer
->	O
fr_address	long
+	O
f	pointer
->	O
fr_fix	long
)	O
return	O
f	pointer
;	O
as_bad_where	function
(	O
r	struct
->	O
file	pointer
,	O
r	struct
->	O
line	int
,	O
_	O
(	O
"reloc not within (fixed part of) section"	pointer
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
static	O
void	O
write_relocs	pointer
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
asection	struct
*	O
sec	pointer
,	O
void	O
*	O
xxx	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
segment_info_type	struct
*	O
seginfo	pointer
=	O
seg_info	O
(	O
sec	pointer
)	O
;	O
unsigned	O
int	O
n	int
;	O
struct	O
reloc_list	struct
*	O
my_reloc_list	pointer
,	O
*	O
*	O
rp	pointer
,	O
*	O
r	struct
;	O
arelent	struct
*	O
*	O
relocs	pointer
;	O
fixS	struct
*	O
fixp	pointer
;	O
fragS	struct
*	O
last_frag	pointer
;	O
if	O
(	O
seginfo	pointer
==	O
NULL	O
)	O
return	O
;	O
n	int
=	O
0	int
;	O
for	O
(	O
fixp	pointer
=	O
seginfo	pointer
->	O
fix_root	pointer
;	O
fixp	pointer
;	O
fixp	pointer
=	O
fixp	pointer
->	O
fx_next	pointer
)	O
if	O
(	O
!	O
fixp	pointer
->	O
fx_done	int
)	O
n	int
++	O
;	O
rp	pointer
=	O
&	O
reloc_list	struct
;	O
my_reloc_list	pointer
=	O
NULL	O
;	O
while	O
(	O
(	O
r	struct
=	O
*	O
rp	pointer
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
r	struct
->	O
u	union
.	O
b	pointer
.	O
sec	pointer
==	O
sec	pointer
)	O
{	O
*	O
rp	pointer
=	O
r	struct
->	O
next	pointer
;	O
r	struct
->	O
next	pointer
=	O
my_reloc_list	pointer
;	O
my_reloc_list	pointer
=	O
r	struct
;	O
n	int
++	O
;	O
}	O
else	O
rp	pointer
=	O
&	O
r	struct
->	O
next	pointer
;	O
}	O
relocs	pointer
=	O
XCNEWVEC	O
(	O
arelent	struct
*	O
,	O
n	int
)	O
;	O
n	int
=	O
0	int
;	O
r	struct
=	O
my_reloc_list	pointer
;	O
last_frag	pointer
=	O
NULL	O
;	O
for	O
(	O
fixp	pointer
=	O
seginfo	pointer
->	O
fix_root	pointer
;	O
fixp	pointer
!=	O
(	O
fixS	struct
*	O
)	O
NULL	O
;	O
fixp	pointer
=	O
fixp	pointer
->	O
fx_next	pointer
)	O
{	O
int	O
fx_size	int
,	O
slack	int
;	O
valueT	long
loc	pointer
;	O
arelent	struct
*	O
*	O
reloc	enum
;	O
arelent	struct
*	O
rel	pointer
;	O
reloc	enum
=	O
&	O
rel	pointer
;	O
if	O
(	O
fixp	pointer
->	O
fx_done	int
)	O
continue	O
;	O
fx_size	int
=	O
fixp	pointer
->	O
fx_size	int
;	O
slack	int
=	O
TC_FX_SIZE_SLACK	int
(	O
fixp	pointer
)	O
;	O
if	O
(	O
slack	int
>	O
0	int
)	O
fx_size	int
=	O
fx_size	int
>	O
slack	int
?	O
fx_size	int
-	O
slack	int
:	O
0	int
;	O
loc	pointer
=	O
fixp	pointer
->	O
fx_where	long
+	O
fx_size	int
;	O
if	O
(	O
slack	int
>=	O
0	int
&&	O
loc	pointer
>	O
fixp	pointer
->	O
fx_frag	pointer
->	O
fr_fix	long
)	O
as_bad_where	function
(	O
fixp	pointer
->	O
fx_file	pointer
,	O
fixp	pointer
->	O
fx_line	int
,	O
_	O
(	O
"internal error: fixup not contained within frag"	pointer
)	O
)	O
;	O
*	O
reloc	enum
=	O
tc_gen_reloc	function
(	O
sec	pointer
,	O
fixp	pointer
)	O
;	O
while	O
(	O
*	O
reloc	enum
)	O
{	O
while	O
(	O
r	struct
!=	O
NULL	O
&&	O
r	struct
->	O
u	union
.	O
b	pointer
.	O
r	struct
.	O
address	long
<	O
(	O
*	O
reloc	enum
)	O
->	O
address	long
)	O
{	O
fragS	struct
*	O
f	pointer
=	O
get_frag_for_reloc	function
(	O
last_frag	pointer
,	O
seginfo	pointer
,	O
r	struct
)	O
;	O
if	O
(	O
f	pointer
!=	O
NULL	O
)	O
{	O
last_frag	pointer
=	O
f	pointer
;	O
relocs	pointer
[	O
n	int
++	O
]	O
=	O
&	O
r	struct
->	O
u	union
.	O
b	pointer
.	O
r	struct
;	O
install_reloc	function
(	O
sec	pointer
,	O
&	O
r	struct
->	O
u	union
.	O
b	pointer
.	O
r	struct
,	O
f	pointer
,	O
r	struct
->	O
file	pointer
,	O
r	struct
->	O
line	int
)	O
;	O
}	O
r	struct
=	O
r	struct
->	O
next	pointer
;	O
}	O
relocs	pointer
[	O
n	int
++	O
]	O
=	O
*	O
reloc	enum
;	O
install_reloc	function
(	O
sec	pointer
,	O
*	O
reloc	enum
,	O
fixp	pointer
->	O
fx_frag	pointer
,	O
fixp	pointer
->	O
fx_file	pointer
,	O
fixp	pointer
->	O
fx_line	int
)	O
;	O
break	O
;	O
}	O
}	O
while	O
(	O
r	struct
!=	O
NULL	O
)	O
{	O
fragS	struct
*	O
f	pointer
=	O
get_frag_for_reloc	function
(	O
last_frag	pointer
,	O
seginfo	pointer
,	O
r	struct
)	O
;	O
if	O
(	O
f	pointer
!=	O
NULL	O
)	O
{	O
last_frag	pointer
=	O
f	pointer
;	O
relocs	pointer
[	O
n	int
++	O
]	O
=	O
&	O
r	struct
->	O
u	union
.	O
b	pointer
.	O
r	struct
;	O
install_reloc	function
(	O
sec	pointer
,	O
&	O
r	struct
->	O
u	union
.	O
b	pointer
.	O
r	struct
,	O
f	pointer
,	O
r	struct
->	O
file	pointer
,	O
r	struct
->	O
line	int
)	O
;	O
}	O
r	struct
=	O
r	struct
->	O
next	pointer
;	O
}	O
if	O
(	O
n	int
)	O
{	O
flagword	int
flags	int
=	O
bfd_section_flags	function
(	O
sec	pointer
)	O
;	O
flags	int
|=	O
SEC_RELOC	int
;	O
bfd_set_section_flags	function
(	O
sec	pointer
,	O
flags	int
)	O
;	O
bfd_set_reloc	function
(	O
stdoutput	pointer
,	O
sec	pointer
,	O
relocs	pointer
,	O
n	int
)	O
;	O
}	O
}	O
static	O
int	O
compress_frag	function
(	O
struct	O
z_stream_s	O
*	O
strm	pointer
,	O
const	O
char	O
*	O
contents	pointer
,	O
int	O
in_size	int
,	O
fragS	struct
*	O
*	O
last_newf	pointer
,	O
struct	O
obstack	struct
*	O
ob	pointer
)	O
{	O
int	O
out_size	int
;	O
int	O
total_out_size	int
=	O
0	int
;	O
fragS	struct
*	O
f	pointer
=	O
*	O
last_newf	pointer
;	O
char	O
*	O
next_out	pointer
;	O
int	O
avail_out	int
;	O
while	O
(	O
in_size	int
>	O
0	int
)	O
{	O
avail_out	int
=	O
obstack_room	O
(	O
ob	pointer
)	O
;	O
if	O
(	O
avail_out	int
<=	O
0	int
)	O
{	O
obstack_finish	O
(	O
ob	pointer
)	O
;	O
f	pointer
=	O
frag_alloc	function
(	O
ob	pointer
)	O
;	O
f	pointer
->	O
fr_type	enum
=	O
rs_fill	int
;	O
(	O
*	O
last_newf	pointer
)	O
->	O
fr_next	pointer
=	O
f	pointer
;	O
*	O
last_newf	pointer
=	O
f	pointer
;	O
avail_out	int
=	O
obstack_room	O
(	O
ob	pointer
)	O
;	O
}	O
if	O
(	O
avail_out	int
<=	O
0	int
)	O
as_fatal	function
(	O
_	O
(	O
"can't extend frag"	pointer
)	O
)	O
;	O
next_out	pointer
=	O
obstack_next_free	O
(	O
ob	pointer
)	O
;	O
obstack_blank_fast	O
(	O
ob	pointer
,	O
avail_out	int
)	O
;	O
out_size	int
=	O
compress_data	function
(	O
strm	pointer
,	O
&	O
contents	pointer
,	O
&	O
in_size	int
,	O
&	O
next_out	pointer
,	O
&	O
avail_out	int
)	O
;	O
if	O
(	O
out_size	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
f	pointer
->	O
fr_fix	long
+=	O
out_size	int
;	O
total_out_size	int
+=	O
out_size	int
;	O
if	O
(	O
avail_out	int
>	O
0	int
)	O
obstack_blank_fast	O
(	O
ob	pointer
,	O
-	O
avail_out	int
)	O
;	O
}	O
return	O
total_out_size	int
;	O
}	O
static	O
void	O
compress_debug	enum
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
void	O
*	O
xxx	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
segment_info_type	struct
*	O
seginfo	pointer
=	O
seg_info	O
(	O
sec	pointer
)	O
;	O
fragS	struct
*	O
f	pointer
;	O
fragS	struct
*	O
first_newf	pointer
;	O
fragS	struct
*	O
last_newf	pointer
;	O
struct	O
obstack	struct
*	O
ob	pointer
=	O
&	O
seginfo	pointer
->	O
frchainP	pointer
->	O
frch_obstack	struct
;	O
bfd_size_type	long
uncompressed_size	pointer
=	O
(	O
bfd_size_type	long
)	O
sec	pointer
->	O
size	int
;	O
bfd_size_type	long
compressed_size	long
;	O
const	O
char	O
*	O
section_name	pointer
;	O
char	O
*	O
compressed_name	pointer
;	O
char	O
*	O
header	pointer
;	O
struct	O
z_stream_s	O
*	O
strm	pointer
;	O
int	O
x	int
;	O
flagword	int
flags	int
=	O
bfd_section_flags	function
(	O
sec	pointer
)	O
;	O
unsigned	O
int	O
header_size	int
,	O
compression_header_size	int
;	O
if	O
(	O
seginfo	pointer
==	O
NULL	O
||	O
sec	pointer
->	O
size	int
<	O
32	int
||	O
(	O
flags	int
&	O
(	O
SEC_ALLOC	int
|	O
SEC_HAS_CONTENTS	int
)	O
)	O
==	O
SEC_ALLOC	int
)	O
return	O
;	O
section_name	pointer
=	O
bfd_section_name	function
(	O
sec	pointer
)	O
;	O
if	O
(	O
strncmp	function
(	O
section_name	pointer
,	O
".debug_"	pointer
,	O
7	int
)	O
!=	O
0	int
)	O
return	O
;	O
strm	pointer
=	O
compress_init	function
(	O
)	O
;	O
if	O
(	O
strm	pointer
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
flag_compress_debug	enum
==	O
COMPRESS_DEBUG_GABI_ZLIB	int
)	O
{	O
compression_header_size	int
=	O
bfd_get_compression_header_size	function
(	O
stdoutput	pointer
,	O
NULL	O
)	O
;	O
header_size	int
=	O
compression_header_size	int
;	O
}	O
else	O
{	O
compression_header_size	int
=	O
0	int
;	O
header_size	int
=	O
12	int
;	O
}	O
first_newf	pointer
=	O
frag_alloc	function
(	O
ob	pointer
)	O
;	O
if	O
(	O
obstack_room	O
(	O
ob	pointer
)	O
<	O
header_size	int
)	O
first_newf	pointer
=	O
frag_alloc	function
(	O
ob	pointer
)	O
;	O
if	O
(	O
obstack_room	O
(	O
ob	pointer
)	O
<	O
header_size	int
)	O
as_fatal	function
(	O
ngettext	function
(	O
"can't extend frag %lu char"	pointer
,	O
"can't extend frag %lu chars"	pointer
,	O
(	O
unsigned	O
long	O
)	O
header_size	int
)	O
,	O
(	O
unsigned	O
long	O
)	O
header_size	int
)	O
;	O
last_newf	pointer
=	O
first_newf	pointer
;	O
obstack_blank_fast	O
(	O
ob	pointer
,	O
header_size	int
)	O
;	O
last_newf	pointer
->	O
fr_type	enum
=	O
rs_fill	int
;	O
last_newf	pointer
->	O
fr_fix	long
=	O
header_size	int
;	O
header	pointer
=	O
last_newf	pointer
->	O
fr_literal	array
;	O
compressed_size	long
=	O
header_size	int
;	O
for	O
(	O
f	pointer
=	O
seginfo	pointer
->	O
frchainP	pointer
->	O
frch_root	pointer
;	O
f	pointer
;	O
f	pointer
=	O
f	pointer
->	O
fr_next	pointer
)	O
{	O
offsetT	long
fill_size	long
;	O
char	O
*	O
fill_literal	pointer
;	O
offsetT	long
count	int
;	O
int	O
out_size	int
;	O
gas_assert	O
(	O
f	pointer
->	O
fr_type	enum
==	O
rs_fill	int
)	O
;	O
if	O
(	O
f	pointer
->	O
fr_fix	long
)	O
{	O
out_size	int
=	O
compress_frag	function
(	O
strm	pointer
,	O
f	pointer
->	O
fr_literal	array
,	O
f	pointer
->	O
fr_fix	long
,	O
&	O
last_newf	pointer
,	O
ob	pointer
)	O
;	O
if	O
(	O
out_size	int
<	O
0	int
)	O
return	O
;	O
compressed_size	long
+=	O
out_size	int
;	O
}	O
fill_literal	pointer
=	O
f	pointer
->	O
fr_literal	array
+	O
f	pointer
->	O
fr_fix	long
;	O
fill_size	long
=	O
f	pointer
->	O
fr_var	long
;	O
count	int
=	O
f	pointer
->	O
fr_offset	long
;	O
gas_assert	O
(	O
count	int
>=	O
0	int
)	O
;	O
if	O
(	O
fill_size	long
&&	O
count	int
)	O
{	O
while	O
(	O
count	int
--	O
)	O
{	O
out_size	int
=	O
compress_frag	function
(	O
strm	pointer
,	O
fill_literal	pointer
,	O
(	O
int	O
)	O
fill_size	long
,	O
&	O
last_newf	pointer
,	O
ob	pointer
)	O
;	O
if	O
(	O
out_size	int
<	O
0	int
)	O
return	O
;	O
compressed_size	long
+=	O
out_size	int
;	O
}	O
}	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
avail_out	int
;	O
char	O
*	O
next_out	pointer
;	O
int	O
out_size	int
;	O
avail_out	int
=	O
obstack_room	O
(	O
ob	pointer
)	O
;	O
if	O
(	O
avail_out	int
<=	O
0	int
)	O
{	O
fragS	struct
*	O
newf	pointer
;	O
obstack_finish	O
(	O
ob	pointer
)	O
;	O
newf	pointer
=	O
frag_alloc	function
(	O
ob	pointer
)	O
;	O
newf	pointer
->	O
fr_type	enum
=	O
rs_fill	int
;	O
last_newf	pointer
->	O
fr_next	pointer
=	O
newf	pointer
;	O
last_newf	pointer
=	O
newf	pointer
;	O
avail_out	int
=	O
obstack_room	O
(	O
ob	pointer
)	O
;	O
}	O
if	O
(	O
avail_out	int
<=	O
0	int
)	O
as_fatal	function
(	O
_	O
(	O
"can't extend frag"	pointer
)	O
)	O
;	O
next_out	pointer
=	O
obstack_next_free	O
(	O
ob	pointer
)	O
;	O
obstack_blank_fast	O
(	O
ob	pointer
,	O
avail_out	int
)	O
;	O
x	int
=	O
compress_finish	function
(	O
strm	pointer
,	O
&	O
next_out	pointer
,	O
&	O
avail_out	int
,	O
&	O
out_size	int
)	O
;	O
if	O
(	O
x	int
<	O
0	int
)	O
return	O
;	O
last_newf	pointer
->	O
fr_fix	long
+=	O
out_size	int
;	O
compressed_size	long
+=	O
out_size	int
;	O
if	O
(	O
avail_out	int
>	O
0	int
)	O
obstack_blank_fast	O
(	O
ob	pointer
,	O
-	O
avail_out	int
)	O
;	O
if	O
(	O
x	int
==	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
compressed_size	long
>=	O
uncompressed_size	pointer
)	O
return	O
;	O
seginfo	pointer
->	O
frchainP	pointer
->	O
frch_root	pointer
=	O
first_newf	pointer
;	O
seginfo	pointer
->	O
frchainP	pointer
->	O
frch_last	pointer
=	O
last_newf	pointer
;	O
bfd_update_compression_header	function
(	O
abfd	pointer
,	O
(	O
bfd_byte	char
*	O
)	O
header	pointer
,	O
sec	pointer
)	O
;	O
x	int
=	O
bfd_set_section_size	function
(	O
sec	pointer
,	O
compressed_size	long
)	O
;	O
gas_assert	O
(	O
x	int
)	O
;	O
if	O
(	O
!	O
compression_header_size	int
)	O
{	O
compressed_name	pointer
=	O
concat	function
(	O
".z"	pointer
,	O
section_name	pointer
+	O
1	int
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
bfd_rename_section	function
(	O
sec	pointer
,	O
compressed_name	pointer
)	O
;	O
}	O
}	O
static	O
void	O
write_contents	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
asection	struct
*	O
sec	pointer
,	O
void	O
*	O
xxx	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
segment_info_type	struct
*	O
seginfo	pointer
=	O
seg_info	O
(	O
sec	pointer
)	O
;	O
addressT	long
offset	long
=	O
0	int
;	O
fragS	struct
*	O
f	pointer
;	O
if	O
(	O
seginfo	pointer
==	O
NULL	O
||	O
!	O
(	O
bfd_section_flags	function
(	O
sec	pointer
)	O
&	O
SEC_HAS_CONTENTS	int
)	O
)	O
return	O
;	O
for	O
(	O
f	pointer
=	O
seginfo	pointer
->	O
frchainP	pointer
->	O
frch_root	pointer
;	O
f	pointer
;	O
f	pointer
=	O
f	pointer
->	O
fr_next	pointer
)	O
{	O
int	O
x	int
;	O
addressT	long
fill_size	long
;	O
char	O
*	O
fill_literal	pointer
;	O
offsetT	long
count	int
;	O
gas_assert	O
(	O
f	pointer
->	O
fr_type	enum
==	O
rs_fill	int
||	O
f	pointer
->	O
fr_type	enum
==	O
rs_fill_nop	int
)	O
;	O
if	O
(	O
f	pointer
->	O
fr_fix	long
)	O
{	O
x	int
=	O
bfd_set_section_contents	function
(	O
stdoutput	pointer
,	O
sec	pointer
,	O
f	pointer
->	O
fr_literal	array
,	O
(	O
file_ptr	long
)	O
offset	long
,	O
(	O
bfd_size_type	long
)	O
f	pointer
->	O
fr_fix	long
)	O
;	O
if	O
(	O
!	O
x	int
)	O
as_fatal	function
(	O
ngettext	function
(	O
"can't write %ld byte "	pointer
"to section %s of %s: '%s'"	pointer
,	O
"can't write %ld bytes "	pointer
"to section %s of %s: '%s'"	pointer
,	O
(	O
long	O
)	O
f	pointer
->	O
fr_fix	long
)	O
,	O
(	O
long	O
)	O
f	pointer
->	O
fr_fix	long
,	O
sec	pointer
->	O
name	pointer
,	O
stdoutput	pointer
->	O
filename	pointer
,	O
bfd_errmsg	function
(	O
bfd_get_error	function
(	O
)	O
)	O
)	O
;	O
offset	long
+=	O
f	pointer
->	O
fr_fix	long
;	O
}	O
fill_size	long
=	O
f	pointer
->	O
fr_var	long
;	O
count	int
=	O
f	pointer
->	O
fr_offset	long
;	O
fill_literal	pointer
=	O
f	pointer
->	O
fr_literal	array
+	O
f	pointer
->	O
fr_fix	long
;	O
if	O
(	O
f	pointer
->	O
fr_type	enum
==	O
rs_fill_nop	int
)	O
{	O
gas_assert	O
(	O
count	int
>=	O
0	int
&&	O
fill_size	long
==	O
1	int
)	O
;	O
if	O
(	O
count	int
>	O
0	int
)	O
{	O
char	O
*	O
buf	pointer
=	O
xmalloc	function
(	O
count	int
)	O
;	O
md_generate_nops	O
(	O
f	pointer
,	O
buf	pointer
,	O
count	int
,	O
*	O
fill_literal	pointer
)	O
;	O
x	int
=	O
bfd_set_section_contents	function
(	O
stdoutput	pointer
,	O
sec	pointer
,	O
buf	pointer
,	O
(	O
file_ptr	long
)	O
offset	long
,	O
(	O
bfd_size_type	long
)	O
count	int
)	O
;	O
if	O
(	O
!	O
x	int
)	O
as_fatal	function
(	O
ngettext	function
(	O
"can't fill %ld byte "	pointer
"in section %s of %s: '%s'"	pointer
,	O
"can't fill %ld bytes "	pointer
"in section %s of %s: '%s'"	pointer
,	O
(	O
long	O
)	O
count	int
)	O
,	O
(	O
long	O
)	O
count	int
,	O
sec	pointer
->	O
name	pointer
,	O
stdoutput	pointer
->	O
filename	pointer
,	O
bfd_errmsg	function
(	O
bfd_get_error	function
(	O
)	O
)	O
)	O
;	O
offset	long
+=	O
count	int
;	O
free	function
(	O
buf	pointer
)	O
;	O
}	O
continue	O
;	O
}	O
gas_assert	O
(	O
count	int
>=	O
0	int
)	O
;	O
if	O
(	O
fill_size	long
&&	O
count	int
)	O
{	O
char	O
buf	pointer
[	O
256	int
]	O
;	O
if	O
(	O
fill_size	long
>	O
sizeof	O
(	O
buf	pointer
)	O
)	O
{	O
while	O
(	O
count	int
--	O
)	O
{	O
x	int
=	O
bfd_set_section_contents	function
(	O
stdoutput	pointer
,	O
sec	pointer
,	O
fill_literal	pointer
,	O
(	O
file_ptr	long
)	O
offset	long
,	O
(	O
bfd_size_type	long
)	O
fill_size	long
)	O
;	O
if	O
(	O
!	O
x	int
)	O
as_fatal	function
(	O
ngettext	function
(	O
"can't fill %ld byte "	pointer
"in section %s of %s: '%s'"	pointer
,	O
"can't fill %ld bytes "	pointer
"in section %s of %s: '%s'"	pointer
,	O
(	O
long	O
)	O
fill_size	long
)	O
,	O
(	O
long	O
)	O
fill_size	long
,	O
sec	pointer
->	O
name	pointer
,	O
stdoutput	pointer
->	O
filename	pointer
,	O
bfd_errmsg	function
(	O
bfd_get_error	function
(	O
)	O
)	O
)	O
;	O
offset	long
+=	O
fill_size	long
;	O
}	O
}	O
else	O
{	O
int	O
n_per_buf	int
,	O
i	pointer
;	O
if	O
(	O
fill_size	long
==	O
1	int
)	O
{	O
n_per_buf	int
=	O
sizeof	O
(	O
buf	pointer
)	O
;	O
memset	function
(	O
buf	pointer
,	O
*	O
fill_literal	pointer
,	O
n_per_buf	int
)	O
;	O
}	O
else	O
{	O
char	O
*	O
bufp	pointer
;	O
n_per_buf	int
=	O
sizeof	O
(	O
buf	pointer
)	O
/	O
fill_size	long
;	O
for	O
(	O
i	pointer
=	O
n_per_buf	int
,	O
bufp	pointer
=	O
buf	pointer
;	O
i	pointer
;	O
i	pointer
--	O
,	O
bufp	pointer
+=	O
fill_size	long
)	O
memcpy	function
(	O
bufp	pointer
,	O
fill_literal	pointer
,	O
fill_size	long
)	O
;	O
}	O
for	O
(	O
;	O
count	int
>	O
0	int
;	O
count	int
-=	O
n_per_buf	int
)	O
{	O
n_per_buf	int
=	O
n_per_buf	int
>	O
count	int
?	O
count	int
:	O
n_per_buf	int
;	O
x	int
=	O
bfd_set_section_contents	function
(	O
stdoutput	pointer
,	O
sec	pointer
,	O
buf	pointer
,	O
(	O
file_ptr	long
)	O
offset	long
,	O
(	O
bfd_size_type	long
)	O
n_per_buf	int
*	O
fill_size	long
)	O
;	O
if	O
(	O
!	O
x	int
)	O
as_fatal	function
(	O
ngettext	function
(	O
"can't fill %ld byte "	pointer
"in section %s of %s: '%s'"	pointer
,	O
"can't fill %ld bytes "	pointer
"in section %s of %s: '%s'"	pointer
,	O
(	O
long	O
)	O
(	O
n_per_buf	int
*	O
fill_size	long
)	O
)	O
,	O
(	O
long	O
)	O
(	O
n_per_buf	int
*	O
fill_size	long
)	O
,	O
sec	pointer
->	O
name	pointer
,	O
stdoutput	pointer
->	O
filename	pointer
,	O
bfd_errmsg	function
(	O
bfd_get_error	function
(	O
)	O
)	O
)	O
;	O
offset	long
+=	O
n_per_buf	int
*	O
fill_size	long
;	O
}	O
}	O
}	O
}	O
}	O
static	O
void	O
merge_data_into_text	function
(	O
void	O
)	O
{	O
seg_info	O
(	O
text_section	pointer
)	O
->	O
frchainP	pointer
->	O
frch_last	pointer
->	O
fr_next	pointer
=	O
seg_info	O
(	O
data_section	pointer
)	O
->	O
frchainP	pointer
->	O
frch_root	pointer
;	O
seg_info	O
(	O
text_section	pointer
)	O
->	O
frchainP	pointer
->	O
frch_last	pointer
=	O
seg_info	O
(	O
data_section	pointer
)	O
->	O
frchainP	pointer
->	O
frch_last	pointer
;	O
seg_info	O
(	O
data_section	pointer
)	O
->	O
frchainP	pointer
=	O
0	int
;	O
}	O
static	O
void	O
set_symtab	function
(	O
void	O
)	O
{	O
int	O
nsyms	int
;	O
asymbol	struct
*	O
*	O
asympp	pointer
;	O
symbolS	struct
*	O
symp	pointer
;	O
bfd_boolean	int
result	int
;	O
nsyms	int
=	O
0	int
;	O
for	O
(	O
symp	pointer
=	O
symbol_rootP	pointer
;	O
symp	pointer
;	O
symp	pointer
=	O
symbol_next	function
(	O
symp	pointer
)	O
)	O
nsyms	int
++	O
;	O
if	O
(	O
nsyms	int
)	O
{	O
int	O
i	pointer
;	O
bfd_size_type	long
amt	long
=	O
(	O
bfd_size_type	long
)	O
nsyms	int
*	O
sizeof	O
(	O
asymbol	struct
*	O
)	O
;	O
asympp	pointer
=	O
(	O
asymbol	struct
*	O
*	O
)	O
bfd_alloc	function
(	O
stdoutput	pointer
,	O
amt	long
)	O
;	O
symp	pointer
=	O
symbol_rootP	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
nsyms	int
;	O
i	pointer
++	O
,	O
symp	pointer
=	O
symbol_next	function
(	O
symp	pointer
)	O
)	O
{	O
asympp	pointer
[	O
i	pointer
]	O
=	O
symbol_get_bfdsym	function
(	O
symp	pointer
)	O
;	O
if	O
(	O
asympp	pointer
[	O
i	pointer
]	O
->	O
flags	int
!=	O
BSF_SECTION_SYM	O
||	O
!	O
(	O
bfd_is_const_section	function
(	O
asympp	pointer
[	O
i	pointer
]	O
->	O
section	pointer
)	O
&&	O
asympp	pointer
[	O
i	pointer
]	O
->	O
section	pointer
->	O
symbol	pointer
==	O
asympp	pointer
[	O
i	pointer
]	O
)	O
)	O
asympp	pointer
[	O
i	pointer
]	O
->	O
flags	int
|=	O
BSF_KEEP	O
;	O
symbol_mark_written	function
(	O
symp	pointer
)	O
;	O
}	O
}	O
else	O
asympp	pointer
=	O
0	int
;	O
result	int
=	O
bfd_set_symtab	function
(	O
stdoutput	pointer
,	O
asympp	pointer
,	O
nsyms	int
)	O
;	O
gas_assert	O
(	O
result	int
)	O
;	O
symbol_table_frozen	int
=	O
1	int
;	O
}	O
static	O
void	O
subsegs_finish_section	function
(	O
asection	struct
*	O
s	pointer
)	O
{	O
struct	O
frchain	struct
*	O
frchainP	pointer
;	O
segment_info_type	struct
*	O
seginfo	pointer
=	O
seg_info	O
(	O
s	pointer
)	O
;	O
if	O
(	O
!	O
seginfo	pointer
)	O
return	O
;	O
for	O
(	O
frchainP	pointer
=	O
seginfo	pointer
->	O
frchainP	pointer
;	O
frchainP	pointer
!=	O
NULL	O
;	O
frchainP	pointer
=	O
frchainP	pointer
->	O
frch_next	pointer
)	O
{	O
int	O
alignment	int
;	O
subseg_set	function
(	O
s	pointer
,	O
frchainP	pointer
->	O
frch_subseg	int
)	O
;	O
if	O
(	O
had_errors	function
(	O
)	O
)	O
do_not_pad_sections_to_alignment	int
=	O
1	int
;	O
alignment	int
=	O
SUB_SEGMENT_ALIGN	int
(	O
now_seg	pointer
,	O
frchainP	pointer
)	O
;	O
if	O
(	O
(	O
bfd_section_flags	function
(	O
now_seg	pointer
)	O
&	O
SEC_MERGE	int
)	O
&&	O
now_seg	pointer
->	O
entsize	int
)	O
{	O
unsigned	O
int	O
entsize	int
=	O
now_seg	pointer
->	O
entsize	int
;	O
int	O
entalign	int
=	O
0	int
;	O
while	O
(	O
(	O
entsize	int
&	O
1	int
)	O
==	O
0	int
)	O
{	O
++	O
entalign	int
;	O
entsize	int
>>=	O
1	int
;	O
}	O
if	O
(	O
entalign	int
>	O
alignment	int
)	O
alignment	int
=	O
entalign	int
;	O
}	O
if	O
(	O
subseg_text_p	function
(	O
now_seg	pointer
)	O
)	O
frag_align_code	function
(	O
alignment	int
,	O
0	int
)	O
;	O
else	O
frag_align	function
(	O
alignment	int
,	O
0	int
,	O
0	int
)	O
;	O
frag_wane	function
(	O
frag_now	pointer
)	O
;	O
frag_now	pointer
->	O
fr_fix	long
=	O
0	int
;	O
know	O
(	O
frag_now	pointer
->	O
fr_next	pointer
==	O
NULL	O
)	O
;	O
}	O
}	O
static	O
void	O
subsegs_finish	function
(	O
void	O
)	O
{	O
asection	struct
*	O
s	pointer
;	O
for	O
(	O
s	pointer
=	O
stdoutput	pointer
->	O
sections	pointer
;	O
s	pointer
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
subsegs_finish_section	function
(	O
s	pointer
)	O
;	O
}	O
static	O
void	O
create_obj_attrs_section	function
(	O
void	O
)	O
{	O
segT	pointer
s	pointer
;	O
char	O
*	O
p	pointer
;	O
offsetT	long
size	int
;	O
const	O
char	O
*	O
name	pointer
;	O
size	int
=	O
bfd_elf_obj_attr_size	function
(	O
stdoutput	pointer
)	O
;	O
if	O
(	O
size	int
==	O
0	int
)	O
return	O
;	O
name	pointer
=	O
get_elf_backend_data	O
(	O
stdoutput	pointer
)	O
->	O
obj_attrs_section	pointer
;	O
if	O
(	O
!	O
name	pointer
)	O
name	pointer
=	O
".gnu.attributes"	pointer
;	O
s	pointer
=	O
subseg_new	function
(	O
name	pointer
,	O
0	int
)	O
;	O
elf_section_type	O
(	O
s	pointer
)	O
=	O
get_elf_backend_data	O
(	O
stdoutput	pointer
)	O
->	O
obj_attrs_section_type	int
;	O
bfd_set_section_flags	function
(	O
s	pointer
,	O
SEC_READONLY	int
|	O
SEC_DATA	int
)	O
;	O
frag_now_fix	function
(	O
)	O
;	O
p	pointer
=	O
frag_more	function
(	O
size	int
)	O
;	O
bfd_elf_set_obj_attr_contents	function
(	O
stdoutput	pointer
,	O
(	O
bfd_byte	char
*	O
)	O
p	pointer
,	O
size	int
)	O
;	O
subsegs_finish_section	function
(	O
s	pointer
)	O
;	O
relax_segment	function
(	O
seg_info	O
(	O
s	pointer
)	O
->	O
frchainP	pointer
->	O
frch_root	pointer
,	O
s	pointer
,	O
0	int
)	O
;	O
size_seg	function
(	O
stdoutput	pointer
,	O
s	pointer
,	O
NULL	O
)	O
;	O
}	O
static	O
void	O
create_note_reloc	function
(	O
segT	pointer
sec	pointer
,	O
symbolS	struct
*	O
sym	pointer
,	O
bfd_size_type	long
note_offset	long
,	O
bfd_size_type	long
desc2_offset	long
,	O
int	O
reloc_type	int
,	O
bfd_vma	long
addend	long
,	O
char	O
*	O
note	pointer
)	O
{	O
struct	O
reloc_list	struct
*	O
reloc	enum
;	O
reloc	enum
=	O
XNEW	O
(	O
struct	O
reloc_list	struct
)	O
;	O
reloc	enum
->	O
u	union
.	O
b	pointer
.	O
sec	pointer
=	O
sec	pointer
;	O
reloc	enum
->	O
u	union
.	O
b	pointer
.	O
s	pointer
=	O
symbol_get_bfdsym	function
(	O
sym	pointer
)	O
;	O
reloc	enum
->	O
u	union
.	O
b	pointer
.	O
r	struct
.	O
sym_ptr_ptr	pointer
=	O
&	O
reloc	enum
->	O
u	union
.	O
b	pointer
.	O
s	pointer
;	O
reloc	enum
->	O
u	union
.	O
b	pointer
.	O
r	struct
.	O
address	long
=	O
note_offset	long
+	O
desc2_offset	long
;	O
reloc	enum
->	O
u	union
.	O
b	pointer
.	O
r	struct
.	O
addend	long
=	O
addend	long
;	O
reloc	enum
->	O
u	union
.	O
b	pointer
.	O
r	struct
.	O
howto	pointer
=	O
bfd_reloc_type_lookup	function
(	O
stdoutput	pointer
,	O
reloc_type	int
)	O
;	O
if	O
(	O
reloc	enum
->	O
u	union
.	O
b	pointer
.	O
r	struct
.	O
howto	pointer
==	O
NULL	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"unable to create reloc for build note"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
reloc	enum
->	O
file	pointer
=	O
N_	O
(	O
"<gnu build note>"	pointer
)	O
;	O
reloc	enum
->	O
line	int
=	O
0	int
;	O
reloc	enum
->	O
next	pointer
=	O
reloc_list	struct
;	O
reloc_list	struct
=	O
reloc	enum
;	O
if	O
(	O
!	O
sec	pointer
->	O
use_rela_p	int
||	O
strstr	function
(	O
bfd_get_target	function
(	O
stdoutput	pointer
)	O
,	O
"-sh"	pointer
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
target_big_endian	int
)	O
{	O
if	O
(	O
bfd_arch_bits_per_address	function
(	O
stdoutput	pointer
)	O
<=	O
32	int
)	O
note	pointer
[	O
desc2_offset	long
+	O
3	int
]	O
=	O
addend	long
;	O
else	O
note	pointer
[	O
desc2_offset	long
+	O
7	int
]	O
=	O
addend	long
;	O
}	O
else	O
note	pointer
[	O
desc2_offset	long
]	O
=	O
addend	long
;	O
}	O
}	O
static	O
void	O
maybe_generate_build_notes	function
(	O
void	O
)	O
{	O
segT	pointer
sec	pointer
;	O
char	O
*	O
note	pointer
;	O
offsetT	long
note_size	long
;	O
offsetT	long
total_size	long
;	O
offsetT	long
desc_size	long
;	O
offsetT	long
desc2_offset	long
;	O
int	O
desc_reloc	int
;	O
symbolS	struct
*	O
sym	pointer
;	O
asymbol	struct
*	O
bsym	pointer
;	O
if	O
(	O
!	O
flag_generate_build_notes	int
||	O
bfd_get_section_by_name	function
(	O
stdoutput	pointer
,	O
GNU_BUILD_ATTRS_SECTION_NAME	pointer
)	O
!=	O
NULL	O
)	O
return	O
;	O
sec	pointer
=	O
subseg_new	function
(	O
GNU_BUILD_ATTRS_SECTION_NAME	pointer
,	O
FALSE	int
)	O
;	O
elf_section_type	O
(	O
sec	pointer
)	O
=	O
SHT_NOTE	int
;	O
bfd_set_section_flags	function
(	O
sec	pointer
,	O
(	O
SEC_READONLY	int
|	O
SEC_HAS_CONTENTS	int
|	O
SEC_DATA	int
|	O
SEC_OCTETS	O
)	O
)	O
;	O
bfd_set_section_alignment	function
(	O
sec	pointer
,	O
2	int
)	O
;	O
if	O
(	O
bfd_arch_bits_per_address	function
(	O
stdoutput	pointer
)	O
<=	O
32	int
)	O
{	O
note_size	long
=	O
28	int
;	O
desc_size	long
=	O
8	int
;	O
desc2_offset	long
=	O
24	int
;	O
if	O
(	O
strstr	function
(	O
bfd_get_target	function
(	O
stdoutput	pointer
)	O
,	O
"-crx"	pointer
)	O
!=	O
NULL	O
)	O
desc_reloc	int
=	O
BFD_RELOC_CRX_NUM32	int
;	O
else	O
if	O
(	O
strstr	function
(	O
bfd_get_target	function
(	O
stdoutput	pointer
)	O
,	O
"-cr16"	pointer
)	O
!=	O
NULL	O
)	O
desc_reloc	int
=	O
BFD_RELOC_CR16_NUM32	int
;	O
else	O
desc_reloc	int
=	O
BFD_RELOC_32	int
;	O
}	O
else	O
{	O
note_size	long
=	O
36	int
;	O
desc_size	long
=	O
16	int
;	O
desc2_offset	long
=	O
28	int
;	O
if	O
(	O
strstr	function
(	O
bfd_get_target	function
(	O
stdoutput	pointer
)	O
,	O
"-ia64"	pointer
)	O
!=	O
NULL	O
)	O
desc_reloc	int
=	O
target_big_endian	int
?	O
BFD_RELOC_IA64_DIR32MSB	int
:	O
BFD_RELOC_IA64_DIR32LSB	int
;	O
else	O
if	O
(	O
strstr	function
(	O
bfd_get_target	function
(	O
stdoutput	pointer
)	O
,	O
"-hppa"	pointer
)	O
!=	O
NULL	O
)	O
desc_reloc	int
=	O
80	int
;	O
else	O
desc_reloc	int
=	O
BFD_RELOC_64	int
;	O
}	O
total_size	long
=	O
0	int
;	O
note	pointer
=	O
NULL	O
;	O
for	O
(	O
sym	pointer
=	O
symbol_rootP	pointer
;	O
sym	pointer
!=	O
NULL	O
;	O
sym	pointer
=	O
symbol_next	function
(	O
sym	pointer
)	O
)	O
if	O
(	O
(	O
bsym	pointer
=	O
symbol_get_bfdsym	function
(	O
sym	pointer
)	O
)	O
!=	O
NULL	O
&&	O
bsym	pointer
->	O
flags	int
&	O
BSF_SECTION_SYM	O
&&	O
bsym	pointer
->	O
section	pointer
!=	O
NULL	O
&&	O
(	O
bsym	pointer
->	O
section	pointer
->	O
flags	int
&	O
(	O
SEC_CODE	int
|	O
SEC_LINK_ONCE	int
)	O
)	O
==	O
SEC_CODE	int
&&	O
strncmp	function
(	O
S_GET_NAME	function
(	O
sym	pointer
)	O
,	O
".gnu.linkonce"	pointer
,	O
sizeof	O
".gnu.linkonce"	pointer
-	O
1	int
)	O
!=	O
0	int
)	O
{	O
frag_now_fix	function
(	O
)	O
;	O
note	pointer
=	O
frag_more	function
(	O
note_size	long
)	O
;	O
memset	function
(	O
note	pointer
,	O
0	int
,	O
note_size	long
)	O
;	O
if	O
(	O
target_big_endian	int
)	O
{	O
note	pointer
[	O
3	int
]	O
=	O
8	int
;	O
note	pointer
[	O
7	int
]	O
=	O
desc_size	long
;	O
note	pointer
[	O
10	int
]	O
=	O
NT_GNU_BUILD_ATTRIBUTE_OPEN	int
>>	O
8	int
;	O
note	pointer
[	O
11	int
]	O
=	O
NT_GNU_BUILD_ATTRIBUTE_OPEN	int
&	O
0xff	int
;	O
}	O
else	O
{	O
note	pointer
[	O
0	int
]	O
=	O
8	int
;	O
note	pointer
[	O
4	int
]	O
=	O
desc_size	long
;	O
note	pointer
[	O
8	int
]	O
=	O
NT_GNU_BUILD_ATTRIBUTE_OPEN	int
&	O
0xff	int
;	O
note	pointer
[	O
9	int
]	O
=	O
NT_GNU_BUILD_ATTRIBUTE_OPEN	int
>>	O
8	int
;	O
}	O
memcpy	function
(	O
note	pointer
+	O
12	int
,	O
"GA$3a1"	pointer
,	O
8	int
)	O
;	O
create_note_reloc	function
(	O
sec	pointer
,	O
sym	pointer
,	O
total_size	long
,	O
20	int
,	O
desc_reloc	int
,	O
0	int
,	O
note	pointer
)	O
;	O
create_note_reloc	function
(	O
sec	pointer
,	O
sym	pointer
,	O
total_size	long
,	O
desc2_offset	long
,	O
desc_reloc	int
,	O
bfd_section_size	function
(	O
bsym	pointer
->	O
section	pointer
)	O
,	O
note	pointer
)	O
;	O
total_size	long
+=	O
note_size	long
;	O
}	O
if	O
(	O
total_size	long
)	O
bfd_set_section_contents	function
(	O
stdoutput	pointer
,	O
sec	pointer
,	O
(	O
bfd_byte	char
*	O
)	O
note	pointer
,	O
0	int
,	O
total_size	long
)	O
;	O
subsegs_finish_section	function
(	O
sec	pointer
)	O
;	O
relax_segment	function
(	O
seg_info	O
(	O
sec	pointer
)	O
->	O
frchainP	pointer
->	O
frch_root	pointer
,	O
sec	pointer
,	O
0	int
)	O
;	O
size_seg	function
(	O
stdoutput	pointer
,	O
sec	pointer
,	O
NULL	O
)	O
;	O
}	O
void	O
write_object_file	function
(	O
void	O
)	O
{	O
struct	O
relax_seg_info	struct
rsi	struct
;	O
subsegs_finish	function
(	O
)	O
;	O
{	O
int	O
i	pointer
;	O
bfd_section_list_remove	function
(	O
stdoutput	pointer
,	O
reg_section	pointer
)	O
;	O
bfd_section_list_remove	function
(	O
stdoutput	pointer
,	O
expr_section	pointer
)	O
;	O
stdoutput	pointer
->	O
section_count	int
-=	O
2	int
;	O
i	pointer
=	O
0	int
;	O
bfd_map_over_sections	function
(	O
stdoutput	pointer
,	O
renumber_sections	function
,	O
&	O
i	pointer
)	O
;	O
}	O
bfd_map_over_sections	function
(	O
stdoutput	pointer
,	O
chain_frchains_together	function
,	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
if	O
(	O
flag_readonly_data_in_text	char
)	O
{	O
merge_data_into_text	function
(	O
)	O
;	O
}	O
rsi	struct
.	O
pass	int
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
rsi	struct
.	O
changed	int
=	O
0	int
;	O
bfd_map_over_sections	function
(	O
stdoutput	pointer
,	O
relax_seg	function
,	O
&	O
rsi	struct
)	O
;	O
rsi	struct
.	O
pass	int
++	O
;	O
if	O
(	O
!	O
rsi	struct
.	O
changed	int
)	O
break	O
;	O
}	O
finalize_syms	int
=	O
TC_FINALIZE_SYMS_BEFORE_SIZE_SEG	int
;	O
bfd_map_over_sections	function
(	O
stdoutput	pointer
,	O
size_seg	function
,	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
finalize_syms	int
=	O
1	int
;	O
dwarf2dbg_final_check	function
(	O
)	O
;	O
if	O
(	O
IS_ELF	int
)	O
create_obj_attrs_section	function
(	O
)	O
;	O
if	O
(	O
symbol_rootP	pointer
)	O
{	O
symbolS	struct
*	O
symp	pointer
;	O
for	O
(	O
symp	pointer
=	O
symbol_rootP	pointer
;	O
symp	pointer
;	O
symp	pointer
=	O
symbol_next	function
(	O
symp	pointer
)	O
)	O
resolve_symbol_value	function
(	O
symp	pointer
)	O
;	O
}	O
resolve_local_symbol_values	function
(	O
)	O
;	O
resolve_reloc_expr_symbols	function
(	O
)	O
;	O
if	O
(	O
IS_ELF	int
)	O
maybe_generate_build_notes	function
(	O
)	O
;	O
PROGRESS	O
(	O
1	int
)	O
;	O
obj_frob_file_before_adjust	O
(	O
)	O
;	O
bfd_map_over_sections	function
(	O
stdoutput	pointer
,	O
adjust_reloc_syms	function
,	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
bfd_map_over_sections	function
(	O
stdoutput	pointer
,	O
fix_segment	function
,	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
if	O
(	O
symbol_rootP	pointer
)	O
{	O
symbolS	struct
*	O
symp	pointer
;	O
bfd_boolean	int
skip_next_symbol	int
=	O
FALSE	int
;	O
for	O
(	O
symp	pointer
=	O
symbol_rootP	pointer
;	O
symp	pointer
;	O
symp	pointer
=	O
symbol_next	function
(	O
symp	pointer
)	O
)	O
{	O
int	O
punt	int
=	O
0	int
;	O
const	O
char	O
*	O
name	pointer
;	O
if	O
(	O
skip_next_symbol	int
)	O
{	O
symbol_get_bfdsym	function
(	O
symp	pointer
)	O
->	O
value	long
=	O
S_GET_VALUE	function
(	O
symp	pointer
)	O
;	O
skip_next_symbol	int
=	O
FALSE	int
;	O
continue	O
;	O
}	O
if	O
(	O
symbol_mri_common_p	function
(	O
symp	pointer
)	O
)	O
{	O
if	O
(	O
S_IS_EXTERNAL	function
(	O
symp	pointer
)	O
)	O
as_bad	function
(	O
_	O
(	O
"%s: global symbols not supported in common sections"	pointer
)	O
,	O
S_GET_NAME	function
(	O
symp	pointer
)	O
)	O
;	O
symbol_remove	function
(	O
symp	pointer
,	O
&	O
symbol_rootP	pointer
,	O
&	O
symbol_lastP	pointer
)	O
;	O
continue	O
;	O
}	O
name	pointer
=	O
S_GET_NAME	function
(	O
symp	pointer
)	O
;	O
if	O
(	O
name	pointer
)	O
{	O
const	O
char	O
*	O
name2	pointer
=	O
decode_local_label_name	function
(	O
(	O
char	O
*	O
)	O
S_GET_NAME	function
(	O
symp	pointer
)	O
)	O
;	O
if	O
(	O
name2	pointer
!=	O
name	pointer
&&	O
!	O
S_IS_DEFINED	function
(	O
symp	pointer
)	O
)	O
as_bad	function
(	O
_	O
(	O
"local label `%s' is not defined"	pointer
)	O
,	O
name2	pointer
)	O
;	O
}	O
resolve_symbol_value	function
(	O
symp	pointer
)	O
;	O
if	O
(	O
symbol_equated_reloc_p	function
(	O
symp	pointer
)	O
||	O
S_IS_WEAKREFR	function
(	O
symp	pointer
)	O
)	O
{	O
const	O
char	O
*	O
sname	pointer
=	O
S_GET_NAME	function
(	O
symp	pointer
)	O
;	O
if	O
(	O
S_IS_COMMON	function
(	O
symp	pointer
)	O
&&	O
!	O
TC_FAKE_LABEL	O
(	O
sname	pointer
)	O
&&	O
!	O
S_IS_WEAKREFR	function
(	O
symp	pointer
)	O
)	O
{	O
expressionS	struct
*	O
e	pointer
=	O
symbol_get_value_expression	function
(	O
symp	pointer
)	O
;	O
as_bad	function
(	O
_	O
(	O
"`%s' can't be equated to common symbol `%s'"	pointer
)	O
,	O
sname	pointer
,	O
S_GET_NAME	function
(	O
e	pointer
->	O
X_add_symbol	pointer
)	O
)	O
;	O
}	O
if	O
(	O
S_GET_SEGMENT	function
(	O
symp	pointer
)	O
==	O
reg_section	pointer
)	O
{	O
if	O
(	O
S_GET_NAME	function
(	O
symp	pointer
)	O
!=	O
reg_section	pointer
->	O
name	pointer
)	O
as_bad	function
(	O
_	O
(	O
"can't make global register symbol `%s'"	pointer
)	O
,	O
sname	pointer
)	O
;	O
}	O
symbol_remove	function
(	O
symp	pointer
,	O
&	O
symbol_rootP	pointer
,	O
&	O
symbol_lastP	pointer
)	O
;	O
continue	O
;	O
}	O
obj_frob_symbol	O
(	O
symp	pointer
,	O
punt	int
)	O
;	O
if	O
(	O
symp	pointer
==	O
abs_section_sym	pointer
||	O
(	O
!	O
EMIT_SECTION_SYMBOLS	int
&&	O
symbol_section_p	function
(	O
symp	pointer
)	O
)	O
||	O
(	O
!	O
S_IS_EXTERNAL	function
(	O
symp	pointer
)	O
&&	O
(	O
punt	int
||	O
S_IS_LOCAL	function
(	O
symp	pointer
)	O
||	O
(	O
S_IS_WEAKREFD	function
(	O
symp	pointer
)	O
&&	O
!	O
symbol_used_p	function
(	O
symp	pointer
)	O
)	O
)	O
&&	O
!	O
symbol_used_in_reloc_p	function
(	O
symp	pointer
)	O
)	O
)	O
{	O
symbol_remove	function
(	O
symp	pointer
,	O
&	O
symbol_rootP	pointer
,	O
&	O
symbol_lastP	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
symbol_resolved_p	function
(	O
symp	pointer
)	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"can't resolve value for symbol `%s'"	pointer
)	O
,	O
S_GET_NAME	function
(	O
symp	pointer
)	O
)	O
;	O
symbol_mark_resolved	function
(	O
symp	pointer
)	O
;	O
}	O
symbol_get_bfdsym	function
(	O
symp	pointer
)	O
->	O
value	long
=	O
S_GET_VALUE	function
(	O
symp	pointer
)	O
;	O
if	O
(	O
symbol_get_bfdsym	function
(	O
symp	pointer
)	O
->	O
flags	int
&	O
BSF_WARNING	O
)	O
skip_next_symbol	int
=	O
TRUE	int
;	O
}	O
}	O
PROGRESS	O
(	O
1	int
)	O
;	O
obj_adjust_symtab	O
(	O
)	O
;	O
if	O
(	O
had_errors	function
(	O
)	O
)	O
return	O
;	O
set_symtab	function
(	O
)	O
;	O
obj_frob_file	O
(	O
)	O
;	O
bfd_map_over_sections	function
(	O
stdoutput	pointer
,	O
write_relocs	pointer
,	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
obj_frob_file_after_relocs	O
(	O
)	O
;	O
if	O
(	O
IS_ELF	int
&&	O
flag_use_elf_stt_common	int
)	O
stdoutput	pointer
->	O
flags	int
|=	O
BFD_CONVERT_ELF_COMMON	int
|	O
BFD_USE_ELF_STT_COMMON	int
;	O
if	O
(	O
flag_compress_debug	enum
)	O
{	O
if	O
(	O
flag_compress_debug	enum
==	O
COMPRESS_DEBUG_GABI_ZLIB	int
)	O
stdoutput	pointer
->	O
flags	int
|=	O
BFD_COMPRESS	int
|	O
BFD_COMPRESS_GABI	int
;	O
else	O
stdoutput	pointer
->	O
flags	int
|=	O
BFD_COMPRESS	int
;	O
bfd_map_over_sections	function
(	O
stdoutput	pointer
,	O
compress_debug	enum
,	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
}	O
bfd_map_over_sections	function
(	O
stdoutput	pointer
,	O
write_contents	function
,	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
}	O
long	O
relax_frag	function
(	O
segT	pointer
segment	pointer
,	O
fragS	struct
*	O
fragP	pointer
,	O
long	O
stretch	long
)	O
{	O
const	O
relax_typeS	struct
*	O
this_type	pointer
;	O
const	O
relax_typeS	struct
*	O
start_type	pointer
;	O
relax_substateT	int
next_state	int
;	O
relax_substateT	int
this_state	int
;	O
offsetT	long
growth	long
;	O
offsetT	long
aim	long
;	O
addressT	long
target	pointer
;	O
addressT	long
address	long
;	O
symbolS	struct
*	O
symbolP	pointer
;	O
const	O
relax_typeS	struct
*	O
table	pointer
;	O
target	pointer
=	O
fragP	pointer
->	O
fr_offset	long
;	O
address	long
=	O
fragP	pointer
->	O
fr_address	long
+	O
fragP	pointer
->	O
fr_fix	long
;	O
table	pointer
=	O
TC_GENERIC_RELAX_TABLE	O
;	O
this_state	int
=	O
fragP	pointer
->	O
fr_subtype	int
;	O
start_type	pointer
=	O
this_type	pointer
=	O
table	pointer
+	O
this_state	int
;	O
symbolP	pointer
=	O
fragP	pointer
->	O
fr_symbol	pointer
;	O
if	O
(	O
symbolP	pointer
)	O
{	O
fragS	struct
*	O
sym_frag	pointer
;	O
sym_frag	pointer
=	O
symbol_get_frag	function
(	O
symbolP	pointer
)	O
;	O
know	O
(	O
S_GET_SEGMENT	function
(	O
symbolP	pointer
)	O
!=	O
absolute_section	O
||	O
sym_frag	pointer
==	O
&	O
zero_address_frag	struct
)	O
;	O
target	pointer
+=	O
S_GET_VALUE	function
(	O
symbolP	pointer
)	O
;	O
if	O
(	O
stretch	long
!=	O
0	int
&&	O
sym_frag	pointer
->	O
relax_marker	int
!=	O
fragP	pointer
->	O
relax_marker	int
&&	O
S_GET_SEGMENT	function
(	O
symbolP	pointer
)	O
==	O
segment	pointer
)	O
{	O
if	O
(	O
stretch	long
<	O
0	int
||	O
sym_frag	pointer
->	O
region	int
==	O
fragP	pointer
->	O
region	int
)	O
target	pointer
+=	O
stretch	long
;	O
else	O
if	O
(	O
target	pointer
<	O
address	long
)	O
return	O
0	int
;	O
}	O
}	O
aim	long
=	O
target	pointer
-	O
address	long
;	O
if	O
(	O
aim	long
<	O
0	int
)	O
{	O
for	O
(	O
next_state	int
=	O
this_type	pointer
->	O
rlx_more	int
;	O
next_state	int
;	O
)	O
if	O
(	O
aim	long
>=	O
this_type	pointer
->	O
rlx_backward	long
)	O
next_state	int
=	O
0	int
;	O
else	O
{	O
this_state	int
=	O
next_state	int
;	O
this_type	pointer
=	O
table	pointer
+	O
this_state	int
;	O
next_state	int
=	O
this_type	pointer
->	O
rlx_more	int
;	O
}	O
}	O
else	O
{	O
for	O
(	O
next_state	int
=	O
this_type	pointer
->	O
rlx_more	int
;	O
next_state	int
;	O
)	O
if	O
(	O
aim	long
<=	O
this_type	pointer
->	O
rlx_forward	long
)	O
next_state	int
=	O
0	int
;	O
else	O
{	O
this_state	int
=	O
next_state	int
;	O
this_type	pointer
=	O
table	pointer
+	O
this_state	int
;	O
next_state	int
=	O
this_type	pointer
->	O
rlx_more	int
;	O
}	O
}	O
growth	long
=	O
this_type	pointer
->	O
rlx_length	char
-	O
start_type	pointer
->	O
rlx_length	char
;	O
if	O
(	O
growth	long
!=	O
0	int
)	O
fragP	pointer
->	O
fr_subtype	int
=	O
this_state	int
;	O
return	O
growth	long
;	O
}	O
static	O
relax_addressT	long
relax_align	function
(	O
relax_addressT	long
address	long
,	O
int	O
alignment	int
)	O
{	O
relax_addressT	long
mask	int
;	O
relax_addressT	long
new_address	long
;	O
mask	int
=	O
~	O
(	O
(	O
relax_addressT	long
)	O
~	O
0	int
<<	O
alignment	int
)	O
;	O
new_address	long
=	O
(	O
address	long
+	O
mask	int
)	O
&	O
(	O
~	O
mask	int
)	O
;	O
return	O
(	O
new_address	long
-	O
address	long
)	O
;	O
}	O
int	O
relax_segment	function
(	O
struct	O
frag	struct
*	O
segment_frag_root	pointer
,	O
segT	pointer
segment	pointer
,	O
int	O
pass	int
)	O
{	O
unsigned	O
long	O
frag_count	long
;	O
struct	O
frag	struct
*	O
fragP	pointer
;	O
relax_addressT	long
address	long
;	O
int	O
region	int
;	O
int	O
ret	pointer
;	O
subseg_change	function
(	O
segment	pointer
,	O
0	int
)	O
;	O
address	long
=	O
0	int
;	O
region	int
=	O
0	int
;	O
for	O
(	O
frag_count	long
=	O
0	int
,	O
fragP	pointer
=	O
segment_frag_root	pointer
;	O
fragP	pointer
;	O
fragP	pointer
=	O
fragP	pointer
->	O
fr_next	pointer
,	O
frag_count	long
++	O
)	O
{	O
fragP	pointer
->	O
region	int
=	O
region	int
;	O
fragP	pointer
->	O
relax_marker	int
=	O
0	int
;	O
fragP	pointer
->	O
fr_address	long
=	O
address	long
;	O
address	long
+=	O
fragP	pointer
->	O
fr_fix	long
;	O
switch	O
(	O
fragP	pointer
->	O
fr_type	enum
)	O
{	O
case	O
rs_fill	int
:	O
address	long
+=	O
fragP	pointer
->	O
fr_offset	long
*	O
fragP	pointer
->	O
fr_var	long
;	O
break	O
;	O
case	O
rs_align	int
:	O
case	O
rs_align_code	int
:	O
case	O
rs_align_test	int
:	O
{	O
addressT	long
offset	long
=	O
relax_align	function
(	O
address	long
,	O
(	O
int	O
)	O
fragP	pointer
->	O
fr_offset	long
)	O
;	O
if	O
(	O
fragP	pointer
->	O
fr_subtype	int
!=	O
0	int
&&	O
offset	long
>	O
fragP	pointer
->	O
fr_subtype	int
)	O
offset	long
=	O
0	int
;	O
if	O
(	O
offset	long
%	O
fragP	pointer
->	O
fr_var	long
!=	O
0	int
)	O
{	O
as_bad_where	function
(	O
fragP	pointer
->	O
fr_file	pointer
,	O
fragP	pointer
->	O
fr_line	int
,	O
ngettext	function
(	O
"alignment padding (%lu byte) "	pointer
"not a multiple of %ld"	pointer
,	O
"alignment padding (%lu bytes) "	pointer
"not a multiple of %ld"	pointer
,	O
(	O
unsigned	O
long	O
)	O
offset	long
)	O
,	O
(	O
unsigned	O
long	O
)	O
offset	long
,	O
(	O
long	O
)	O
fragP	pointer
->	O
fr_var	long
)	O
;	O
offset	long
-=	O
(	O
offset	long
%	O
fragP	pointer
->	O
fr_var	long
)	O
;	O
}	O
address	long
+=	O
offset	long
;	O
region	int
+=	O
1	int
;	O
}	O
break	O
;	O
case	O
rs_org	int
:	O
region	int
+=	O
1	int
;	O
break	O
;	O
case	O
rs_space	int
:	O
case	O
rs_space_nop	int
:	O
break	O
;	O
case	O
rs_machine_dependent	int
:	O
if	O
(	O
fragP	pointer
->	O
fr_symbol	pointer
)	O
resolve_symbol_value	function
(	O
fragP	pointer
->	O
fr_symbol	pointer
)	O
;	O
address	long
+=	O
md_estimate_size_before_relax	function
(	O
fragP	pointer
,	O
segment	pointer
)	O
;	O
break	O
;	O
case	O
rs_leb128	int
:	O
address	long
+=	O
fragP	pointer
->	O
fr_offset	long
=	O
1	int
;	O
break	O
;	O
case	O
rs_cfa	int
:	O
address	long
+=	O
eh_frame_estimate_size_before_relax	function
(	O
fragP	pointer
)	O
;	O
break	O
;	O
case	O
rs_dwarf2dbg	int
:	O
address	long
+=	O
dwarf2dbg_estimate_size_before_relax	function
(	O
fragP	pointer
)	O
;	O
break	O
;	O
default	O
:	O
BAD_CASE	O
(	O
fragP	pointer
->	O
fr_type	enum
)	O
;	O
break	O
;	O
}	O
}	O
{	O
unsigned	O
long	O
max_iterations	long
;	O
offsetT	long
stretch	long
;	O
int	O
stretched	int
;	O
int	O
rs_leb128_fudge	int
=	O
0	int
;	O
max_iterations	long
=	O
frag_count	long
*	O
frag_count	long
;	O
if	O
(	O
max_iterations	long
<	O
frag_count	long
)	O
max_iterations	long
=	O
frag_count	long
;	O
ret	pointer
=	O
0	int
;	O
do	O
{	O
stretch	long
=	O
0	int
;	O
stretched	int
=	O
0	int
;	O
for	O
(	O
fragP	pointer
=	O
segment_frag_root	pointer
;	O
fragP	pointer
;	O
fragP	pointer
=	O
fragP	pointer
->	O
fr_next	pointer
)	O
{	O
offsetT	long
growth	long
=	O
0	int
;	O
addressT	long
was_address	long
;	O
offsetT	long
offset	long
;	O
symbolS	struct
*	O
symbolP	pointer
;	O
fragP	pointer
->	O
relax_marker	int
^=	O
1	int
;	O
was_address	long
=	O
fragP	pointer
->	O
fr_address	long
;	O
address	long
=	O
fragP	pointer
->	O
fr_address	long
+=	O
stretch	long
;	O
symbolP	pointer
=	O
fragP	pointer
->	O
fr_symbol	pointer
;	O
offset	long
=	O
fragP	pointer
->	O
fr_offset	long
;	O
switch	O
(	O
fragP	pointer
->	O
fr_type	enum
)	O
{	O
case	O
rs_fill	int
:	O
growth	long
=	O
0	int
;	O
break	O
;	O
case	O
rs_align	int
:	O
case	O
rs_align_code	int
:	O
case	O
rs_align_test	int
:	O
{	O
addressT	long
oldoff	long
,	O
newoff	long
;	O
oldoff	long
=	O
relax_align	function
(	O
was_address	long
+	O
fragP	pointer
->	O
fr_fix	long
,	O
(	O
int	O
)	O
offset	long
)	O
;	O
newoff	long
=	O
relax_align	function
(	O
address	long
+	O
fragP	pointer
->	O
fr_fix	long
,	O
(	O
int	O
)	O
offset	long
)	O
;	O
if	O
(	O
fragP	pointer
->	O
fr_subtype	int
!=	O
0	int
)	O
{	O
if	O
(	O
oldoff	long
>	O
fragP	pointer
->	O
fr_subtype	int
)	O
oldoff	long
=	O
0	int
;	O
if	O
(	O
newoff	long
>	O
fragP	pointer
->	O
fr_subtype	int
)	O
newoff	long
=	O
0	int
;	O
}	O
growth	long
=	O
newoff	long
-	O
oldoff	long
;	O
if	O
(	O
growth	long
<	O
0	int
&&	O
(	O
rs_leb128_fudge	int
&	O
16	int
)	O
!=	O
0	int
&&	O
(	O
rs_leb128_fudge	int
&	O
15	int
)	O
>=	O
2	int
)	O
{	O
segment_info_type	struct
*	O
seginfo	pointer
=	O
seg_info	O
(	O
segment	pointer
)	O
;	O
struct	O
obstack	struct
*	O
ob	pointer
=	O
&	O
seginfo	pointer
->	O
frchainP	pointer
->	O
frch_obstack	struct
;	O
struct	O
frag	struct
*	O
newf	pointer
;	O
newf	pointer
=	O
frag_alloc	function
(	O
ob	pointer
)	O
;	O
obstack_blank_fast	O
(	O
ob	pointer
,	O
fragP	pointer
->	O
fr_var	long
)	O
;	O
obstack_finish	O
(	O
ob	pointer
)	O
;	O
memcpy	function
(	O
newf	pointer
,	O
fragP	pointer
,	O
SIZEOF_STRUCT_FRAG	O
)	O
;	O
memcpy	function
(	O
newf	pointer
->	O
fr_literal	array
,	O
fragP	pointer
->	O
fr_literal	array
+	O
fragP	pointer
->	O
fr_fix	long
,	O
fragP	pointer
->	O
fr_var	long
)	O
;	O
newf	pointer
->	O
fr_type	enum
=	O
rs_fill	int
;	O
newf	pointer
->	O
fr_address	long
=	O
address	long
+	O
fragP	pointer
->	O
fr_fix	long
+	O
newoff	long
;	O
newf	pointer
->	O
fr_fix	long
=	O
0	int
;	O
newf	pointer
->	O
fr_offset	long
=	O
(	O
(	O
(	O
offsetT	long
)	O
1	int
<<	O
fragP	pointer
->	O
fr_offset	long
)	O
/	O
fragP	pointer
->	O
fr_var	long
)	O
;	O
if	O
(	O
newf	pointer
->	O
fr_offset	long
*	O
newf	pointer
->	O
fr_var	long
!=	O
(	O
offsetT	long
)	O
1	int
<<	O
fragP	pointer
->	O
fr_offset	long
)	O
{	O
newf	pointer
->	O
fr_offset	long
=	O
(	O
offsetT	long
)	O
1	int
<<	O
fragP	pointer
->	O
fr_offset	long
;	O
newf	pointer
->	O
fr_var	long
=	O
1	int
;	O
}	O
growth	long
+=	O
newf	pointer
->	O
fr_offset	long
*	O
newf	pointer
->	O
fr_var	long
;	O
newf	pointer
->	O
fr_address	long
-=	O
stretch	long
+	O
growth	long
;	O
newf	pointer
->	O
relax_marker	int
^=	O
1	int
;	O
fragP	pointer
->	O
fr_next	pointer
=	O
newf	pointer
;	O
}	O
}	O
break	O
;	O
case	O
rs_org	int
:	O
{	O
addressT	long
target	pointer
=	O
offset	long
;	O
addressT	long
after	long
;	O
if	O
(	O
symbolP	pointer
)	O
{	O
know	O
(	O
S_GET_SEGMENT	function
(	O
symbolP	pointer
)	O
->	O
vma	long
==	O
0	int
)	O
;	O
target	pointer
+=	O
S_GET_VALUE	function
(	O
symbolP	pointer
)	O
*	O
OCTETS_PER_BYTE	O
;	O
}	O
know	O
(	O
fragP	pointer
->	O
fr_next	pointer
)	O
;	O
after	long
=	O
fragP	pointer
->	O
fr_next	pointer
->	O
fr_address	long
+	O
stretch	long
;	O
growth	long
=	O
target	pointer
-	O
after	long
;	O
if	O
(	O
address	long
+	O
fragP	pointer
->	O
fr_fix	long
>	O
target	pointer
)	O
{	O
growth	long
=	O
0	int
;	O
if	O
(	O
pass	int
<	O
2	int
)	O
{	O
ret	pointer
=	O
1	int
;	O
break	O
;	O
}	O
as_bad_where	function
(	O
fragP	pointer
->	O
fr_file	pointer
,	O
fragP	pointer
->	O
fr_line	int
,	O
_	O
(	O
"attempt to move .org backwards"	pointer
)	O
)	O
;	O
fragP	pointer
->	O
fr_type	enum
=	O
rs_align	int
;	O
fragP	pointer
->	O
fr_subtype	int
=	O
0	int
;	O
fragP	pointer
->	O
fr_offset	long
=	O
0	int
;	O
fragP	pointer
->	O
fr_fix	long
=	O
after	long
-	O
address	long
;	O
}	O
}	O
break	O
;	O
case	O
rs_space	int
:	O
case	O
rs_space_nop	int
:	O
growth	long
=	O
0	int
;	O
if	O
(	O
symbolP	pointer
)	O
{	O
offsetT	long
amount	long
;	O
amount	long
=	O
S_GET_VALUE	function
(	O
symbolP	pointer
)	O
;	O
if	O
(	O
S_GET_SEGMENT	function
(	O
symbolP	pointer
)	O
!=	O
absolute_section	O
||	O
S_IS_COMMON	function
(	O
symbolP	pointer
)	O
||	O
!	O
S_IS_DEFINED	function
(	O
symbolP	pointer
)	O
)	O
{	O
as_bad_where	function
(	O
fragP	pointer
->	O
fr_file	pointer
,	O
fragP	pointer
->	O
fr_line	int
,	O
_	O
(	O
".space specifies non-absolute value"	pointer
)	O
)	O
;	O
fragP	pointer
->	O
fr_symbol	pointer
=	O
0	int
;	O
}	O
else	O
if	O
(	O
amount	long
<	O
0	int
)	O
{	O
if	O
(	O
pass	int
<	O
2	int
)	O
{	O
ret	pointer
=	O
1	int
;	O
break	O
;	O
}	O
as_warn_where	function
(	O
fragP	pointer
->	O
fr_file	pointer
,	O
fragP	pointer
->	O
fr_line	int
,	O
_	O
(	O
".space, .nops or .fill with negative value, ignored"	pointer
)	O
)	O
;	O
fragP	pointer
->	O
fr_symbol	pointer
=	O
0	int
;	O
}	O
else	O
growth	long
=	O
(	O
was_address	long
+	O
fragP	pointer
->	O
fr_fix	long
+	O
amount	long
-	O
fragP	pointer
->	O
fr_next	pointer
->	O
fr_address	long
)	O
;	O
}	O
break	O
;	O
case	O
rs_machine_dependent	int
:	O
growth	long
=	O
md_generic_table_relax_frag	O
(	O
segment	pointer
,	O
fragP	pointer
,	O
stretch	long
)	O
;	O
break	O
;	O
case	O
rs_leb128	int
:	O
{	O
valueT	long
value	long
;	O
offsetT	long
size	int
;	O
value	long
=	O
resolve_symbol_value	function
(	O
fragP	pointer
->	O
fr_symbol	pointer
)	O
;	O
size	int
=	O
sizeof_leb128	function
(	O
value	long
,	O
fragP	pointer
->	O
fr_subtype	int
)	O
;	O
growth	long
=	O
size	int
-	O
fragP	pointer
->	O
fr_offset	long
;	O
fragP	pointer
->	O
fr_offset	long
=	O
size	int
;	O
}	O
break	O
;	O
case	O
rs_cfa	int
:	O
growth	long
=	O
eh_frame_relax_frag	function
(	O
fragP	pointer
)	O
;	O
break	O
;	O
case	O
rs_dwarf2dbg	int
:	O
growth	long
=	O
dwarf2dbg_relax_frag	function
(	O
fragP	pointer
)	O
;	O
break	O
;	O
default	O
:	O
BAD_CASE	O
(	O
fragP	pointer
->	O
fr_type	enum
)	O
;	O
break	O
;	O
}	O
if	O
(	O
growth	long
)	O
{	O
stretch	long
+=	O
growth	long
;	O
stretched	int
=	O
1	int
;	O
if	O
(	O
fragP	pointer
->	O
fr_type	enum
==	O
rs_leb128	int
)	O
rs_leb128_fudge	int
+=	O
16	int
;	O
else	O
if	O
(	O
fragP	pointer
->	O
fr_type	enum
==	O
rs_align	int
&&	O
(	O
rs_leb128_fudge	int
&	O
16	int
)	O
!=	O
0	int
&&	O
stretch	long
==	O
0	int
)	O
rs_leb128_fudge	int
+=	O
16	int
;	O
else	O
rs_leb128_fudge	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
stretch	long
==	O
0	int
&&	O
(	O
rs_leb128_fudge	int
&	O
16	int
)	O
==	O
0	int
&&	O
(	O
rs_leb128_fudge	int
&	O
-	O
16	int
)	O
!=	O
0	int
)	O
rs_leb128_fudge	int
+=	O
1	int
;	O
else	O
rs_leb128_fudge	int
=	O
0	int
;	O
}	O
while	O
(	O
stretched	int
&&	O
--	O
max_iterations	long
)	O
;	O
if	O
(	O
stretched	int
)	O
as_fatal	function
(	O
_	O
(	O
"Infinite loop encountered whilst attempting to compute the addresses of symbols in section %s"	pointer
)	O
,	O
segment_name	O
(	O
segment	pointer
)	O
)	O
;	O
}	O
for	O
(	O
fragP	pointer
=	O
segment_frag_root	pointer
;	O
fragP	pointer
;	O
fragP	pointer
=	O
fragP	pointer
->	O
fr_next	pointer
)	O
if	O
(	O
fragP	pointer
->	O
last_fr_address	long
!=	O
fragP	pointer
->	O
fr_address	long
)	O
{	O
fragP	pointer
->	O
last_fr_address	long
=	O
fragP	pointer
->	O
fr_address	long
;	O
ret	pointer
=	O
1	int
;	O
}	O
return	O
ret	pointer
;	O
}	O
void	O
number_to_chars_bigendian	function
(	O
char	O
*	O
buf	pointer
,	O
valueT	long
val	int
,	O
int	O
n	int
)	O
{	O
if	O
(	O
n	int
<=	O
0	int
)	O
abort	function
(	O
)	O
;	O
while	O
(	O
n	int
--	O
)	O
{	O
buf	pointer
[	O
n	int
]	O
=	O
val	int
&	O
0xff	int
;	O
val	int
>>=	O
8	int
;	O
}	O
}	O
void	O
number_to_chars_littleendian	function
(	O
char	O
*	O
buf	pointer
,	O
valueT	long
val	int
,	O
int	O
n	int
)	O
{	O
if	O
(	O
n	int
<=	O
0	int
)	O
abort	function
(	O
)	O
;	O
while	O
(	O
n	int
--	O
)	O
{	O
*	O
buf	pointer
++	O
=	O
val	int
&	O
0xff	int
;	O
val	int
>>=	O
8	int
;	O
}	O
}	O
void	O
write_print_statistics	function
(	O
FILE	struct
*	O
file	pointer
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
"fixups: %d\n"	pointer
,	O
n_fixups	int
)	O
;	O
}	O
extern	O
int	O
indent_level	int
;	O
void	O
print_fixup	function
(	O
fixS	struct
*	O
fixp	pointer
)	O
{	O
indent_level	int
=	O
1	int
;	O
fprintf	function
(	O
stderr	pointer
,	O
"fix "	pointer
)	O
;	O
fprintf_vma	O
(	O
stderr	pointer
,	O
(	O
bfd_vma	long
)	O
(	O
(	O
bfd_hostptr_t	long
)	O
fixp	pointer
)	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
" %s:%d"	pointer
,	O
fixp	pointer
->	O
fx_file	pointer
,	O
fixp	pointer
->	O
fx_line	int
)	O
;	O
if	O
(	O
fixp	pointer
->	O
fx_pcrel	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
" pcrel"	pointer
)	O
;	O
if	O
(	O
fixp	pointer
->	O
fx_pcrel_adjust	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
" pcrel_adjust=%d"	pointer
,	O
fixp	pointer
->	O
fx_pcrel_adjust	int
)	O
;	O
if	O
(	O
fixp	pointer
->	O
fx_tcbit	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
" tcbit"	pointer
)	O
;	O
if	O
(	O
fixp	pointer
->	O
fx_done	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
" done"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n    size=%d frag="	pointer
,	O
fixp	pointer
->	O
fx_size	int
)	O
;	O
fprintf_vma	O
(	O
stderr	pointer
,	O
(	O
bfd_vma	long
)	O
(	O
(	O
bfd_hostptr_t	long
)	O
fixp	pointer
->	O
fx_frag	pointer
)	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
" where=%ld offset=%lx addnumber=%lx"	pointer
,	O
(	O
long	O
)	O
fixp	pointer
->	O
fx_where	long
,	O
(	O
unsigned	O
long	O
)	O
fixp	pointer
->	O
fx_offset	long
,	O
(	O
unsigned	O
long	O
)	O
fixp	pointer
->	O
fx_addnumber	long
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n    %s (%d)"	pointer
,	O
bfd_get_reloc_code_name	function
(	O
fixp	pointer
->	O
fx_r_type	enum
)	O
,	O
fixp	pointer
->	O
fx_r_type	enum
)	O
;	O
if	O
(	O
fixp	pointer
->	O
fx_addsy	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"\n   +<"	pointer
)	O
;	O
print_symbol_value_1	function
(	O
stderr	pointer
,	O
fixp	pointer
->	O
fx_addsy	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
">"	pointer
)	O
;	O
}	O
if	O
(	O
fixp	pointer
->	O
fx_subsy	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"\n   -<"	pointer
)	O
;	O
print_symbol_value_1	function
(	O
stderr	pointer
,	O
fixp	pointer
->	O
fx_subsy	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
">"	pointer
)	O
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
