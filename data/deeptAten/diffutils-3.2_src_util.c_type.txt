char	O
const	O
pr_program	array
[	O
]	O
=	O
PR_PROGRAM	pointer
;	O
struct	O
msg	struct
{	O
struct	O
msg	struct
*	O
next	pointer
;	O
char	O
args	array
[	O
1	int
]	O
;	O
}	O
;	O
static	O
struct	O
msg	struct
*	O
msg_chain	pointer
;	O
static	O
struct	O
msg	struct
*	O
*	O
msg_chain_end	pointer
=	O
&	O
msg_chain	pointer
;	O
void	O
perror_with_name	function
(	O
char	O
const	O
*	O
name	pointer
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
"%s"	pointer
,	O
name	pointer
)	O
;	O
}	O
void	O
pfatal_with_name	function
(	O
char	O
const	O
*	O
name	pointer
)	O
{	O
int	O
e	int
=	O
errno	O
;	O
print_message_queue	function
(	O
)	O
;	O
error	function
(	O
EXIT_TROUBLE	int
,	O
e	int
,	O
"%s"	pointer
,	O
name	pointer
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
void	O
fatal	function
(	O
char	O
const	O
*	O
msgid	pointer
)	O
{	O
print_message_queue	function
(	O
)	O
;	O
error	function
(	O
EXIT_TROUBLE	int
,	O
0	int
,	O
"%s"	pointer
,	O
_	O
(	O
msgid	pointer
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
void	O
message	function
(	O
char	O
const	O
*	O
format_msgid	pointer
,	O
char	O
const	O
*	O
arg1	pointer
,	O
char	O
const	O
*	O
arg2	pointer
)	O
{	O
message5	function
(	O
format_msgid	pointer
,	O
arg1	pointer
,	O
arg2	pointer
,	O
0	int
,	O
0	int
)	O
;	O
}	O
void	O
message5	function
(	O
char	O
const	O
*	O
format_msgid	pointer
,	O
char	O
const	O
*	O
arg1	pointer
,	O
char	O
const	O
*	O
arg2	pointer
,	O
char	O
const	O
*	O
arg3	pointer
,	O
char	O
const	O
*	O
arg4	pointer
)	O
{	O
if	O
(	O
paginate	bool
)	O
{	O
char	O
*	O
p	pointer
;	O
char	O
const	O
*	O
arg	array
[	O
5	int
]	O
;	O
int	O
i	int
;	O
size_t	long
size	array
[	O
5	int
]	O
;	O
size_t	long
total_size	long
=	O
offsetof	O
(	O
struct	O
msg	struct
,	O
args	array
)	O
;	O
struct	O
msg	struct
*	O
new	pointer
;	O
arg	array
[	O
0	int
]	O
=	O
format_msgid	pointer
;	O
arg	array
[	O
1	int
]	O
=	O
arg1	pointer
;	O
arg	array
[	O
2	int
]	O
=	O
arg2	pointer
;	O
arg	array
[	O
3	int
]	O
=	O
arg3	pointer
?	O
arg3	pointer
:	O
""	pointer
;	O
arg	array
[	O
4	int
]	O
=	O
arg4	pointer
?	O
arg4	pointer
:	O
""	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
5	int
;	O
i	int
++	O
)	O
total_size	long
+=	O
size	array
[	O
i	int
]	O
=	O
strlen	function
(	O
arg	array
[	O
i	int
]	O
)	O
+	O
1	int
;	O
new	pointer
=	O
xmalloc	function
(	O
total_size	long
)	O
;	O
for	O
(	O
i	int
=	O
0	int
,	O
p	pointer
=	O
new	pointer
->	O
args	array
;	O
i	int
<	O
5	int
;	O
p	pointer
+=	O
size	array
[	O
i	int
++	O
]	O
)	O
memcpy	function
(	O
p	pointer
,	O
arg	array
[	O
i	int
]	O
,	O
size	array
[	O
i	int
]	O
)	O
;	O
*	O
msg_chain_end	pointer
=	O
new	pointer
;	O
new	pointer
->	O
next	pointer
=	O
0	int
;	O
msg_chain_end	pointer
=	O
&	O
new	pointer
->	O
next	pointer
;	O
}	O
else	O
{	O
if	O
(	O
sdiff_merge_assist	bool
)	O
putchar	function
(	O
' '	O
)	O
;	O
printf	function
(	O
_	O
(	O
format_msgid	pointer
)	O
,	O
arg1	pointer
,	O
arg2	pointer
,	O
arg3	pointer
,	O
arg4	pointer
)	O
;	O
}	O
}	O
void	O
print_message_queue	function
(	O
void	O
)	O
{	O
char	O
const	O
*	O
arg	array
[	O
5	int
]	O
;	O
int	O
i	int
;	O
struct	O
msg	struct
*	O
m	pointer
=	O
msg_chain	pointer
;	O
while	O
(	O
m	pointer
)	O
{	O
struct	O
msg	struct
*	O
next	pointer
=	O
m	pointer
->	O
next	pointer
;	O
arg	array
[	O
0	int
]	O
=	O
m	pointer
->	O
args	array
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
;	O
i	int
++	O
)	O
arg	array
[	O
i	int
+	O
1	int
]	O
=	O
arg	array
[	O
i	int
]	O
+	O
strlen	function
(	O
arg	array
[	O
i	int
]	O
)	O
+	O
1	int
;	O
printf	function
(	O
_	O
(	O
arg	array
[	O
0	int
]	O
)	O
,	O
arg	array
[	O
1	int
]	O
,	O
arg	array
[	O
2	int
]	O
,	O
arg	array
[	O
3	int
]	O
,	O
arg	array
[	O
4	int
]	O
)	O
;	O
free	function
(	O
m	pointer
)	O
;	O
m	pointer
=	O
next	pointer
;	O
}	O
}	O
static	O
char	O
const	O
*	O
current_name0	pointer
;	O
static	O
char	O
const	O
*	O
current_name1	pointer
;	O
static	O
bool	bool
currently_recursive	bool
;	O
void	O
setup_output	function
(	O
char	O
const	O
*	O
name0	pointer
,	O
char	O
const	O
*	O
name1	pointer
,	O
bool	bool
recursive	bool
)	O
{	O
current_name0	pointer
=	O
name0	pointer
;	O
current_name1	pointer
=	O
name1	pointer
;	O
currently_recursive	bool
=	O
recursive	bool
;	O
outfile	pointer
=	O
0	int
;	O
}	O
static	O
pid_t	int
pr_pid	int
;	O
void	O
begin_output	function
(	O
void	O
)	O
{	O
char	O
*	O
name	pointer
;	O
if	O
(	O
outfile	pointer
!=	O
0	int
)	O
return	O
;	O
name	pointer
=	O
xmalloc	function
(	O
strlen	function
(	O
current_name0	pointer
)	O
+	O
strlen	function
(	O
current_name1	pointer
)	O
+	O
strlen	function
(	O
switch_string	pointer
)	O
+	O
7	int
)	O
;	O
sprintf	function
(	O
name	pointer
,	O
"diff%s %s %s"	pointer
,	O
switch_string	pointer
,	O
current_name0	pointer
,	O
current_name1	pointer
)	O
;	O
if	O
(	O
paginate	bool
)	O
{	O
if	O
(	O
fflush	function
(	O
stdout	pointer
)	O
!=	O
0	int
)	O
pfatal_with_name	function
(	O
_	O
(	O
"write failed"	pointer
)	O
)	O
;	O
{	O
int	O
pipes	array
[	O
2	int
]	O
;	O
if	O
(	O
pipe	function
(	O
pipes	array
)	O
!=	O
0	int
)	O
pfatal_with_name	function
(	O
"pipe"	pointer
)	O
;	O
pr_pid	int
=	O
fork	function
(	O
)	O
;	O
if	O
(	O
pr_pid	int
<	O
0	int
)	O
pfatal_with_name	function
(	O
"fork"	pointer
)	O
;	O
if	O
(	O
pr_pid	int
==	O
0	int
)	O
{	O
close	function
(	O
pipes	array
[	O
1	int
]	O
)	O
;	O
if	O
(	O
pipes	array
[	O
0	int
]	O
!=	O
STDIN_FILENO	int
)	O
{	O
if	O
(	O
dup2	function
(	O
pipes	array
[	O
0	int
]	O
,	O
STDIN_FILENO	int
)	O
<	O
0	int
)	O
pfatal_with_name	function
(	O
"dup2"	pointer
)	O
;	O
close	function
(	O
pipes	array
[	O
0	int
]	O
)	O
;	O
}	O
execl	function
(	O
pr_program	array
,	O
pr_program	array
,	O
"-h"	pointer
,	O
name	pointer
,	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
_exit	function
(	O
errno	O
==	O
ENOENT	int
?	O
127	int
:	O
126	int
)	O
;	O
}	O
else	O
{	O
close	function
(	O
pipes	array
[	O
0	int
]	O
)	O
;	O
outfile	pointer
=	O
fdopen	function
(	O
pipes	array
[	O
1	int
]	O
,	O
"w"	pointer
)	O
;	O
if	O
(	O
!	O
outfile	pointer
)	O
pfatal_with_name	function
(	O
"fdopen"	pointer
)	O
;	O
}	O
}	O
}	O
else	O
{	O
outfile	pointer
=	O
stdout	pointer
;	O
if	O
(	O
currently_recursive	bool
)	O
printf	function
(	O
"%s\n"	pointer
,	O
name	pointer
)	O
;	O
}	O
free	function
(	O
name	pointer
)	O
;	O
switch	O
(	O
output_style	enum
)	O
{	O
case	O
OUTPUT_CONTEXT	int
:	O
print_context_header	function
(	O
files	array
,	O
false	int
)	O
;	O
break	O
;	O
case	O
OUTPUT_UNIFIED	int
:	O
print_context_header	function
(	O
files	array
,	O
true	int
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
void	O
finish_output	function
(	O
void	O
)	O
{	O
if	O
(	O
outfile	pointer
!=	O
0	int
&&	O
outfile	pointer
!=	O
stdout	pointer
)	O
{	O
int	O
status	int
;	O
int	O
wstatus	int
;	O
int	O
werrno	int
=	O
0	int
;	O
if	O
(	O
ferror	function
(	O
outfile	pointer
)	O
)	O
fatal	function
(	O
"write failed"	pointer
)	O
;	O
if	O
(	O
fclose	function
(	O
outfile	pointer
)	O
!=	O
0	int
)	O
pfatal_with_name	function
(	O
_	O
(	O
"write failed"	pointer
)	O
)	O
;	O
if	O
(	O
waitpid	function
(	O
pr_pid	int
,	O
&	O
wstatus	int
,	O
0	int
)	O
<	O
0	int
)	O
pfatal_with_name	function
(	O
"waitpid"	pointer
)	O
;	O
status	int
=	O
(	O
!	O
werrno	int
&&	O
WIFEXITED	O
(	O
wstatus	int
)	O
?	O
WEXITSTATUS	O
(	O
wstatus	int
)	O
:	O
INT_MAX	O
)	O
;	O
if	O
(	O
status	int
)	O
error	function
(	O
EXIT_TROUBLE	int
,	O
werrno	int
,	O
_	O
(	O
status	int
==	O
126	int
?	O
"subsidiary program `%s' could not be invoked"	pointer
:	O
status	int
==	O
127	int
?	O
"subsidiary program `%s' not found"	pointer
:	O
status	int
==	O
INT_MAX	O
?	O
"subsidiary program `%s' failed"	pointer
:	O
"subsidiary program `%s' failed (exit status %d)"	pointer
)	O
,	O
pr_program	array
,	O
status	int
)	O
;	O
}	O
outfile	pointer
=	O
0	int
;	O
}	O
bool	bool
lines_differ	function
(	O
char	O
const	O
*	O
s1	pointer
,	O
char	O
const	O
*	O
s2	pointer
)	O
{	O
register	O
char	O
const	O
*	O
t1	pointer
=	O
s1	pointer
;	O
register	O
char	O
const	O
*	O
t2	pointer
=	O
s2	pointer
;	O
size_t	long
column	long
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
register	O
unsigned	O
char	O
c1	char
=	O
*	O
t1	pointer
++	O
;	O
register	O
unsigned	O
char	O
c2	char
=	O
*	O
t2	pointer
++	O
;	O
if	O
(	O
c1	char
!=	O
c2	char
)	O
{	O
switch	O
(	O
ignore_white_space	enum
)	O
{	O
case	O
IGNORE_ALL_SPACE	int
:	O
while	O
(	O
isspace	function
(	O
c1	char
)	O
&&	O
c1	char
!=	O
'\n'	O
)	O
c1	char
=	O
*	O
t1	pointer
++	O
;	O
while	O
(	O
isspace	function
(	O
c2	char
)	O
&&	O
c2	char
!=	O
'\n'	O
)	O
c2	char
=	O
*	O
t2	pointer
++	O
;	O
break	O
;	O
case	O
IGNORE_SPACE_CHANGE	int
:	O
if	O
(	O
isspace	function
(	O
c1	char
)	O
)	O
{	O
while	O
(	O
c1	char
!=	O
'\n'	O
)	O
{	O
c1	char
=	O
*	O
t1	pointer
++	O
;	O
if	O
(	O
!	O
isspace	function
(	O
c1	char
)	O
)	O
{	O
--	O
t1	pointer
;	O
c1	char
=	O
' '	O
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
isspace	function
(	O
c2	char
)	O
)	O
{	O
while	O
(	O
c2	char
!=	O
'\n'	O
)	O
{	O
c2	char
=	O
*	O
t2	pointer
++	O
;	O
if	O
(	O
!	O
isspace	function
(	O
c2	char
)	O
)	O
{	O
--	O
t2	pointer
;	O
c2	char
=	O
' '	O
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
c1	char
!=	O
c2	char
)	O
{	O
if	O
(	O
c2	char
==	O
' '	O
&&	O
c1	char
!=	O
'\n'	O
&&	O
s1	pointer
+	O
1	int
<	O
t1	pointer
&&	O
isspace	function
(	O
(	O
unsigned	O
char	O
)	O
t1	pointer
[	O
-	O
2	int
]	O
)	O
)	O
{	O
--	O
t1	pointer
;	O
continue	O
;	O
}	O
if	O
(	O
c1	char
==	O
' '	O
&&	O
c2	char
!=	O
'\n'	O
&&	O
s2	pointer
+	O
1	int
<	O
t2	pointer
&&	O
isspace	function
(	O
(	O
unsigned	O
char	O
)	O
t2	pointer
[	O
-	O
2	int
]	O
)	O
)	O
{	O
--	O
t2	pointer
;	O
continue	O
;	O
}	O
}	O
break	O
;	O
case	O
IGNORE_TRAILING_SPACE	int
:	O
case	O
IGNORE_TAB_EXPANSION_AND_TRAILING_SPACE	int
:	O
if	O
(	O
isspace	function
(	O
c1	char
)	O
&&	O
isspace	function
(	O
c2	char
)	O
)	O
{	O
unsigned	O
char	O
c	char
;	O
if	O
(	O
c1	char
!=	O
'\n'	O
)	O
{	O
char	O
const	O
*	O
p	pointer
=	O
t1	pointer
;	O
while	O
(	O
(	O
c	char
=	O
*	O
p	pointer
)	O
!=	O
'\n'	O
&&	O
isspace	function
(	O
c	char
)	O
)	O
++	O
p	pointer
;	O
if	O
(	O
c	char
!=	O
'\n'	O
)	O
break	O
;	O
}	O
if	O
(	O
c2	char
!=	O
'\n'	O
)	O
{	O
char	O
const	O
*	O
p	pointer
=	O
t2	pointer
;	O
while	O
(	O
(	O
c	char
=	O
*	O
p	pointer
)	O
!=	O
'\n'	O
&&	O
isspace	function
(	O
c	char
)	O
)	O
++	O
p	pointer
;	O
if	O
(	O
c	char
!=	O
'\n'	O
)	O
break	O
;	O
}	O
return	O
false	int
;	O
}	O
if	O
(	O
ignore_white_space	enum
==	O
IGNORE_TRAILING_SPACE	int
)	O
break	O
;	O
case	O
IGNORE_TAB_EXPANSION	int
:	O
if	O
(	O
(	O
c1	char
==	O
' '	O
&&	O
c2	char
==	O
'\t'	O
)	O
||	O
(	O
c1	char
==	O
'\t'	O
&&	O
c2	char
==	O
' '	O
)	O
)	O
{	O
size_t	long
column2	long
=	O
column	long
;	O
for	O
(	O
;	O
;	O
c1	char
=	O
*	O
t1	pointer
++	O
)	O
{	O
if	O
(	O
c1	char
==	O
' '	O
)	O
column	long
++	O
;	O
else	O
if	O
(	O
c1	char
==	O
'\t'	O
)	O
column	long
+=	O
tabsize	long
-	O
column	long
%	O
tabsize	long
;	O
else	O
break	O
;	O
}	O
for	O
(	O
;	O
;	O
c2	char
=	O
*	O
t2	pointer
++	O
)	O
{	O
if	O
(	O
c2	char
==	O
' '	O
)	O
column2	long
++	O
;	O
else	O
if	O
(	O
c2	char
==	O
'\t'	O
)	O
column2	long
+=	O
tabsize	long
-	O
column2	long
%	O
tabsize	long
;	O
else	O
break	O
;	O
}	O
if	O
(	O
column	long
!=	O
column2	long
)	O
return	O
true	int
;	O
}	O
break	O
;	O
case	O
IGNORE_NO_WHITE_SPACE	int
:	O
break	O
;	O
}	O
if	O
(	O
ignore_case	bool
)	O
{	O
c1	char
=	O
tolower	function
(	O
c1	char
)	O
;	O
c2	char
=	O
tolower	function
(	O
c2	char
)	O
;	O
}	O
if	O
(	O
c1	char
!=	O
c2	char
)	O
break	O
;	O
}	O
if	O
(	O
c1	char
==	O
'\n'	O
)	O
return	O
false	int
;	O
column	long
+=	O
c1	char
==	O
'\t'	O
?	O
tabsize	long
-	O
column	long
%	O
tabsize	long
:	O
1	int
;	O
}	O
return	O
true	int
;	O
}	O
struct	O
change	struct
*	O
find_change	function
(	O
struct	O
change	struct
*	O
start	pointer
)	O
{	O
return	O
start	pointer
;	O
}	O
struct	O
change	struct
*	O
find_reverse_change	function
(	O
struct	O
change	struct
*	O
start	pointer
)	O
{	O
return	O
start	pointer
;	O
}	O
void	O
print_script	function
(	O
struct	O
change	struct
*	O
script	pointer
,	O
struct	O
change	struct
*	O
(	O
*	O
hunkfun	pointer
)	O
(	O
struct	O
change	struct
*	O
)	O
,	O
void	O
(	O
*	O
printfun	pointer
)	O
(	O
struct	O
change	struct
*	O
)	O
)	O
{	O
struct	O
change	struct
*	O
next	pointer
=	O
script	pointer
;	O
while	O
(	O
next	pointer
)	O
{	O
struct	O
change	struct
*	O
this	pointer
,	O
*	O
end	pointer
;	O
this	pointer
=	O
next	pointer
;	O
end	pointer
=	O
(	O
*	O
hunkfun	pointer
)	O
(	O
next	pointer
)	O
;	O
next	pointer
=	O
end	pointer
->	O
link	function
;	O
end	pointer
->	O
link	function
=	O
0	int
;	O
(	O
*	O
printfun	pointer
)	O
(	O
this	pointer
)	O
;	O
end	pointer
->	O
link	function
=	O
next	pointer
;	O
}	O
}	O
void	O
print_1_line	function
(	O
char	O
const	O
*	O
line_flag	pointer
,	O
char	O
const	O
*	O
const	O
*	O
line	pointer
)	O
{	O
char	O
const	O
*	O
base	int
=	O
line	pointer
[	O
0	int
]	O
,	O
*	O
limit	pointer
=	O
line	pointer
[	O
1	int
]	O
;	O
FILE	struct
*	O
out	pointer
=	O
outfile	pointer
;	O
char	O
const	O
*	O
flag_format	pointer
=	O
0	int
;	O
if	O
(	O
line_flag	pointer
&&	O
*	O
line_flag	pointer
)	O
{	O
char	O
const	O
*	O
flag_format_1	pointer
=	O
flag_format	pointer
=	O
initial_tab	bool
?	O
"%s\t"	pointer
:	O
"%s "	pointer
;	O
char	O
const	O
*	O
line_flag_1	pointer
=	O
line_flag	pointer
;	O
if	O
(	O
suppress_blank_empty	bool
&&	O
*	O
*	O
line	pointer
==	O
'\n'	O
)	O
{	O
flag_format_1	pointer
=	O
"%s"	pointer
;	O
line_flag_1	pointer
+=	O
*	O
line_flag_1	pointer
==	O
' '	O
;	O
}	O
fprintf	function
(	O
out	pointer
,	O
flag_format_1	pointer
,	O
line_flag_1	pointer
)	O
;	O
}	O
output_1_line	function
(	O
base	int
,	O
limit	pointer
,	O
flag_format	pointer
,	O
line_flag	pointer
)	O
;	O
if	O
(	O
(	O
!	O
line_flag	pointer
||	O
line_flag	pointer
[	O
0	int
]	O
)	O
&&	O
limit	pointer
[	O
-	O
1	int
]	O
!=	O
'\n'	O
)	O
fprintf	function
(	O
out	pointer
,	O
"\n\\ %s\n"	pointer
,	O
_	O
(	O
"No newline at end of file"	pointer
)	O
)	O
;	O
}	O
void	O
output_1_line	function
(	O
char	O
const	O
*	O
base	int
,	O
char	O
const	O
*	O
limit	pointer
,	O
char	O
const	O
*	O
flag_format	pointer
,	O
char	O
const	O
*	O
line_flag	pointer
)	O
{	O
if	O
(	O
!	O
expand_tabs	bool
)	O
fwrite	function
(	O
base	int
,	O
sizeof	O
(	O
char	O
)	O
,	O
limit	pointer
-	O
base	int
,	O
outfile	pointer
)	O
;	O
else	O
{	O
register	O
FILE	struct
*	O
out	pointer
=	O
outfile	pointer
;	O
register	O
unsigned	O
char	O
c	char
;	O
register	O
char	O
const	O
*	O
t	pointer
=	O
base	int
;	O
register	O
size_t	long
column	long
=	O
0	int
;	O
size_t	long
tab_size	long
=	O
tabsize	long
;	O
while	O
(	O
t	pointer
<	O
limit	pointer
)	O
switch	O
(	O
(	O
c	char
=	O
*	O
t	pointer
++	O
)	O
)	O
{	O
case	O
'\t'	O
:	O
{	O
size_t	long
spaces	long
=	O
tab_size	long
-	O
column	long
%	O
tab_size	long
;	O
column	long
+=	O
spaces	long
;	O
do	O
putc	function
(	O
' '	O
,	O
out	pointer
)	O
;	O
while	O
(	O
--	O
spaces	long
)	O
;	O
}	O
break	O
;	O
case	O
'\r'	O
:	O
putc	function
(	O
c	char
,	O
out	pointer
)	O
;	O
if	O
(	O
flag_format	pointer
&&	O
t	pointer
<	O
limit	pointer
&&	O
*	O
t	pointer
!=	O
'\n'	O
)	O
fprintf	function
(	O
out	pointer
,	O
flag_format	pointer
,	O
line_flag	pointer
)	O
;	O
column	long
=	O
0	int
;	O
break	O
;	O
case	O
'\b'	O
:	O
if	O
(	O
column	long
==	O
0	int
)	O
continue	O
;	O
column	long
--	O
;	O
putc	function
(	O
c	char
,	O
out	pointer
)	O
;	O
break	O
;	O
default	O
:	O
column	long
+=	O
isprint	function
(	O
c	char
)	O
!=	O
0	int
;	O
putc	function
(	O
c	char
,	O
out	pointer
)	O
;	O
break	O
;	O
}	O
}	O
}	O
char	O
const	O
change_letter	array
[	O
]	O
=	O
{	O
0	int
,	O
'd'	O
,	O
'a'	O
,	O
'c'	O
}	O
;	O
lin	long
translate_line_number	function
(	O
struct	O
file_data	struct
const	O
*	O
file	array
,	O
lin	long
i	int
)	O
{	O
return	O
i	int
+	O
file	array
->	O
prefix_lines	long
+	O
1	int
;	O
}	O
void	O
translate_range	function
(	O
struct	O
file_data	struct
const	O
*	O
file	array
,	O
lin	long
a	long
,	O
lin	long
b	long
,	O
long	O
int	O
*	O
aptr	pointer
,	O
long	O
int	O
*	O
bptr	pointer
)	O
{	O
*	O
aptr	pointer
=	O
translate_line_number	function
(	O
file	array
,	O
a	long
-	O
1	int
)	O
+	O
1	int
;	O
*	O
bptr	pointer
=	O
translate_line_number	function
(	O
file	array
,	O
b	long
+	O
1	int
)	O
-	O
1	int
;	O
}	O
void	O
print_number_range	function
(	O
char	O
sepchar	char
,	O
struct	O
file_data	struct
*	O
file	array
,	O
lin	long
a	long
,	O
lin	long
b	long
)	O
{	O
long	O
int	O
trans_a	long
,	O
trans_b	long
;	O
translate_range	function
(	O
file	array
,	O
a	long
,	O
b	long
,	O
&	O
trans_a	long
,	O
&	O
trans_b	long
)	O
;	O
if	O
(	O
trans_b	long
>	O
trans_a	long
)	O
fprintf	function
(	O
outfile	pointer
,	O
"%ld%c%ld"	pointer
,	O
trans_a	long
,	O
sepchar	char
,	O
trans_b	long
)	O
;	O
else	O
fprintf	function
(	O
outfile	pointer
,	O
"%ld"	pointer
,	O
trans_b	long
)	O
;	O
}	O
enum	O
changes	enum
analyze_hunk	function
(	O
struct	O
change	struct
*	O
hunk	pointer
,	O
lin	long
*	O
first0	pointer
,	O
lin	long
*	O
last0	pointer
,	O
lin	long
*	O
first1	pointer
,	O
lin	long
*	O
last1	pointer
)	O
{	O
struct	O
change	struct
*	O
next	pointer
;	O
lin	long
l0	long
,	O
l1	long
;	O
lin	long
show_from	long
,	O
show_to	long
;	O
lin	long
i	int
;	O
bool	bool
trivial	bool
=	O
ignore_blank_lines	bool
||	O
ignore_regexp	struct
.	O
fastmap	pointer
;	O
size_t	long
trivial_length	long
=	O
ignore_blank_lines	bool
-	O
1	int
;	O
bool	bool
skip_white_space	bool
=	O
ignore_blank_lines	bool
&&	O
IGNORE_TRAILING_SPACE	int
<=	O
ignore_white_space	enum
;	O
bool	bool
skip_leading_white_space	bool
=	O
skip_white_space	bool
&&	O
IGNORE_SPACE_CHANGE	int
<=	O
ignore_white_space	enum
;	O
char	O
const	O
*	O
const	O
*	O
linbuf0	pointer
=	O
files	array
[	O
0	int
]	O
.	O
linbuf	pointer
;	O
char	O
const	O
*	O
const	O
*	O
linbuf1	pointer
=	O
files	array
[	O
1	int
]	O
.	O
linbuf	pointer
;	O
show_from	long
=	O
show_to	long
=	O
0	int
;	O
*	O
first0	pointer
=	O
hunk	pointer
->	O
line0	long
;	O
*	O
first1	pointer
=	O
hunk	pointer
->	O
line1	long
;	O
next	pointer
=	O
hunk	pointer
;	O
do	O
{	O
l0	long
=	O
next	pointer
->	O
line0	long
+	O
next	pointer
->	O
deleted	long
-	O
1	int
;	O
l1	long
=	O
next	pointer
->	O
line1	long
+	O
next	pointer
->	O
inserted	long
-	O
1	int
;	O
show_from	long
+=	O
next	pointer
->	O
deleted	long
;	O
show_to	long
+=	O
next	pointer
->	O
inserted	long
;	O
for	O
(	O
i	int
=	O
next	pointer
->	O
line0	long
;	O
i	int
<=	O
l0	long
&&	O
trivial	bool
;	O
i	int
++	O
)	O
{	O
char	O
const	O
*	O
line	pointer
=	O
linbuf0	pointer
[	O
i	int
]	O
;	O
char	O
const	O
*	O
newline	pointer
=	O
linbuf0	pointer
[	O
i	int
+	O
1	int
]	O
-	O
1	int
;	O
size_t	long
len	long
=	O
newline	pointer
-	O
line	pointer
;	O
char	O
const	O
*	O
p	pointer
=	O
line	pointer
;	O
if	O
(	O
skip_white_space	bool
)	O
for	O
(	O
;	O
*	O
p	pointer
!=	O
'\n'	O
;	O
p	pointer
++	O
)	O
if	O
(	O
!	O
isspace	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
p	pointer
)	O
)	O
{	O
if	O
(	O
!	O
skip_leading_white_space	bool
)	O
p	pointer
=	O
line	pointer
;	O
break	O
;	O
}	O
if	O
(	O
newline	pointer
-	O
p	pointer
!=	O
trivial_length	long
&&	O
(	O
!	O
ignore_regexp	struct
.	O
fastmap	pointer
||	O
re_search	function
(	O
&	O
ignore_regexp	struct
,	O
line	pointer
,	O
len	long
,	O
0	int
,	O
len	long
,	O
0	int
)	O
<	O
0	int
)	O
)	O
trivial	bool
=	O
0	int
;	O
}	O
for	O
(	O
i	int
=	O
next	pointer
->	O
line1	long
;	O
i	int
<=	O
l1	long
&&	O
trivial	bool
;	O
i	int
++	O
)	O
{	O
char	O
const	O
*	O
line	pointer
=	O
linbuf1	pointer
[	O
i	int
]	O
;	O
char	O
const	O
*	O
newline	pointer
=	O
linbuf1	pointer
[	O
i	int
+	O
1	int
]	O
-	O
1	int
;	O
size_t	long
len	long
=	O
newline	pointer
-	O
line	pointer
;	O
char	O
const	O
*	O
p	pointer
=	O
line	pointer
;	O
if	O
(	O
skip_white_space	bool
)	O
for	O
(	O
;	O
*	O
p	pointer
!=	O
'\n'	O
;	O
p	pointer
++	O
)	O
if	O
(	O
!	O
isspace	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
p	pointer
)	O
)	O
{	O
if	O
(	O
!	O
skip_leading_white_space	bool
)	O
p	pointer
=	O
line	pointer
;	O
break	O
;	O
}	O
if	O
(	O
newline	pointer
-	O
p	pointer
!=	O
trivial_length	long
&&	O
(	O
!	O
ignore_regexp	struct
.	O
fastmap	pointer
||	O
re_search	function
(	O
&	O
ignore_regexp	struct
,	O
line	pointer
,	O
len	long
,	O
0	int
,	O
len	long
,	O
0	int
)	O
<	O
0	int
)	O
)	O
trivial	bool
=	O
0	int
;	O
}	O
}	O
while	O
(	O
(	O
next	pointer
=	O
next	pointer
->	O
link	function
)	O
!=	O
0	int
)	O
;	O
*	O
last0	pointer
=	O
l0	long
;	O
*	O
last1	pointer
=	O
l1	long
;	O
if	O
(	O
trivial	bool
)	O
return	O
UNCHANGED	int
;	O
return	O
(	O
show_from	long
?	O
OLD	int
:	O
UNCHANGED	int
)	O
|	O
(	O
show_to	long
?	O
NEW	int
:	O
UNCHANGED	int
)	O
;	O
}	O
char	O
*	O
concat	function
(	O
char	O
const	O
*	O
s1	pointer
,	O
char	O
const	O
*	O
s2	pointer
,	O
char	O
const	O
*	O
s3	pointer
)	O
{	O
char	O
*	O
new	pointer
=	O
xmalloc	function
(	O
strlen	function
(	O
s1	pointer
)	O
+	O
strlen	function
(	O
s2	pointer
)	O
+	O
strlen	function
(	O
s3	pointer
)	O
+	O
1	int
)	O
;	O
sprintf	function
(	O
new	pointer
,	O
"%s%s%s"	pointer
,	O
s1	pointer
,	O
s2	pointer
,	O
s3	pointer
)	O
;	O
return	O
new	pointer
;	O
}	O
void	O
*	O
zalloc	function
(	O
size_t	long
size	array
)	O
{	O
void	O
*	O
p	pointer
=	O
xmalloc	function
(	O
size	array
)	O
;	O
memset	function
(	O
p	pointer
,	O
0	int
,	O
size	array
)	O
;	O
return	O
p	pointer
;	O
}	O
void	O
debug_script	function
(	O
struct	O
change	struct
*	O
sp	pointer
)	O
{	O
fflush	function
(	O
stdout	pointer
)	O
;	O
for	O
(	O
;	O
sp	pointer
;	O
sp	pointer
=	O
sp	pointer
->	O
link	function
)	O
{	O
long	O
int	O
line0	long
=	O
sp	pointer
->	O
line0	long
;	O
long	O
int	O
line1	long
=	O
sp	pointer
->	O
line1	long
;	O
long	O
int	O
deleted	long
=	O
sp	pointer
->	O
deleted	long
;	O
long	O
int	O
inserted	long
=	O
sp	pointer
->	O
inserted	long
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%3ld %3ld delete %ld insert %ld\n"	pointer
,	O
line0	long
,	O
line1	long
,	O
deleted	long
,	O
inserted	long
)	O
;	O
}	O
fflush	function
(	O
stderr	pointer
)	O
;	O
}	O
