error_t	O
pager_read_page	function
(	O
struct	O
user_pager_info	O
*	O
upi	pointer
,	O
vm_offset_t	O
page	int
,	O
vm_address_t	O
*	O
buf	pointer
,	O
int	O
*	O
writelock	pointer
)	O
{	O
error_t	O
err	O
;	O
size_t	O
read	O
=	O
0	int
;	O
int	O
want	int
=	O
vm_page_size	O
;	O
struct	O
dev	pointer
*	O
dev	pointer
=	O
(	O
struct	O
dev	pointer
*	O
)	O
upi	pointer
;	O
struct	O
store	pointer
*	O
store	pointer
=	O
dev	pointer
->	O
store	pointer
;	O
if	O
(	O
page	int
+	O
want	int
>	O
store	pointer
->	O
size	pointer
)	O
want	int
=	O
store	pointer
->	O
size	pointer
-	O
page	int
;	O
err	O
=	O
dev_read	function
(	O
dev	pointer
,	O
page	int
,	O
want	int
,	O
(	O
void	O
*	O
*	O
)	O
buf	pointer
,	O
&	O
read	O
)	O
;	O
if	O
(	O
!	O
err	O
&&	O
want	int
<	O
vm_page_size	O
)	O
memset	O
(	O
(	O
char	O
*	O
)	O
*	O
buf	pointer
+	O
want	int
,	O
'\0'	O
,	O
vm_page_size	O
-	O
want	int
)	O
;	O
*	O
writelock	pointer
=	O
(	O
store	pointer
->	O
flags	O
&	O
STORE_READONLY	O
)	O
;	O
if	O
(	O
err	O
||	O
read	O
<	O
want	int
)	O
return	O
EIO	O
;	O
else	O
return	O
0	int
;	O
}	O
error_t	O
pager_write_page	function
(	O
struct	O
user_pager_info	O
*	O
upi	pointer
,	O
vm_offset_t	O
page	int
,	O
vm_address_t	O
buf	pointer
)	O
{	O
struct	O
dev	pointer
*	O
dev	pointer
=	O
(	O
struct	O
dev	pointer
*	O
)	O
upi	pointer
;	O
struct	O
store	pointer
*	O
store	pointer
=	O
dev	pointer
->	O
store	pointer
;	O
if	O
(	O
store	pointer
->	O
flags	O
&	O
STORE_READONLY	O
)	O
return	O
EROFS	O
;	O
else	O
{	O
error_t	O
err	O
;	O
size_t	O
written	O
;	O
int	O
want	int
=	O
vm_page_size	O
;	O
if	O
(	O
page	int
+	O
want	int
>	O
store	pointer
->	O
size	pointer
)	O
want	int
=	O
store	pointer
->	O
size	pointer
-	O
page	int
;	O
err	O
=	O
dev_write	function
(	O
dev	pointer
,	O
page	int
,	O
(	O
char	O
*	O
)	O
buf	pointer
,	O
want	int
,	O
&	O
written	O
)	O
;	O
munmap	function
(	O
(	O
caddr_t	O
)	O
buf	pointer
,	O
vm_page_size	O
)	O
;	O
if	O
(	O
err	O
||	O
written	O
<	O
want	int
)	O
return	O
EIO	O
;	O
else	O
return	O
0	int
;	O
}	O
}	O
error_t	O
pager_unlock_page	function
(	O
struct	O
user_pager_info	O
*	O
upi	pointer
,	O
vm_offset_t	O
address	int
)	O
{	O
struct	O
dev	pointer
*	O
dev	pointer
=	O
(	O
struct	O
dev	pointer
*	O
)	O
upi	pointer
;	O
if	O
(	O
dev	pointer
->	O
store	pointer
->	O
flags	O
&	O
STORE_READONLY	O
)	O
return	O
EROFS	O
;	O
else	O
return	O
0	int
;	O
}	O
void	O
pager_notify_evict	function
(	O
struct	O
user_pager_info	O
*	O
pager	pointer
,	O
vm_offset_t	O
page	int
)	O
{	O
assert	function
(	O
!	O
"unrequested notification on eviction"	pointer
)	O
;	O
}	O
error_t	O
pager_report_extent	function
(	O
struct	O
user_pager_info	O
*	O
upi	pointer
,	O
vm_address_t	O
*	O
offset	pointer
,	O
vm_size_t	O
*	O
size	pointer
)	O
{	O
*	O
offset	pointer
=	O
0	int
;	O
*	O
size	pointer
=	O
(	O
(	O
struct	O
dev	pointer
*	O
)	O
upi	pointer
)	O
->	O
store	pointer
->	O
size	pointer
;	O
return	O
0	int
;	O
}	O
void	O
pager_clear_user_data	function
(	O
struct	O
user_pager_info	O
*	O
upi	pointer
)	O
{	O
struct	O
dev	pointer
*	O
dev	pointer
=	O
(	O
struct	O
dev	pointer
*	O
)	O
upi	pointer
;	O
pthread_mutex_lock	function
(	O
&	O
dev	pointer
->	O
pager_lock	O
)	O
;	O
dev	pointer
->	O
pager	pointer
=	O
0	int
;	O
pthread_mutex_unlock	function
(	O
&	O
dev	pointer
->	O
pager_lock	O
)	O
;	O
}	O
static	O
struct	O
port_bucket	O
*	O
pager_port_bucket	pointer
=	O
0	int
;	O
static	O
struct	O
pager_requests	pointer
*	O
pager_requests	pointer
;	O
static	O
void	O
init_dev_paging	function
(	O
)	O
{	O
if	O
(	O
!	O
pager_port_bucket	pointer
)	O
{	O
static	O
pthread_mutex_t	O
pager_global_lock	int
=	O
PTHREAD_MUTEX_INITIALIZER	O
;	O
pthread_mutex_lock	function
(	O
&	O
pager_global_lock	int
)	O
;	O
if	O
(	O
pager_port_bucket	pointer
==	O
NULL	O
)	O
{	O
error_t	O
err	O
;	O
pager_port_bucket	pointer
=	O
ports_create_bucket	function
(	O
)	O
;	O
err	O
=	O
pager_start_workers	function
(	O
pager_port_bucket	pointer
,	O
&	O
pager_requests	pointer
)	O
;	O
if	O
(	O
err	O
)	O
{	O
errno	O
=	O
err	O
;	O
error	function
(	O
0	int
,	O
err	O
,	O
"pager_start_workers"	pointer
)	O
;	O
}	O
}	O
pthread_mutex_unlock	function
(	O
&	O
pager_global_lock	int
)	O
;	O
}	O
}	O
void	O
pager_dropweak	function
(	O
struct	O
user_pager_info	O
*	O
upi	pointer
__attribute__	O
(	O
(	O
unused	O
)	O
)	O
)	O
{	O
}	O
int	O
dev_stop_paging	function
(	O
struct	O
dev	pointer
*	O
dev	pointer
,	O
int	O
nosync	int
)	O
{	O
size_t	O
num_pagers	O
=	O
(	O
pager_port_bucket	pointer
?	O
ports_count_bucket	function
(	O
pager_port_bucket	pointer
)	O
:	O
0	int
)	O
;	O
if	O
(	O
num_pagers	O
>	O
0	int
&&	O
!	O
nosync	int
)	O
{	O
error_t	O
block_cache	O
(	O
void	O
*	O
arg	O
)	O
{	O
struct	O
pager	pointer
*	O
p	O
=	O
arg	O
;	O
pager_change_attributes	O
(	O
p	O
,	O
0	int
,	O
MEMORY_OBJECT_COPY_DELAY	O
,	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
error_t	O
enable_cache	O
(	O
void	O
*	O
arg	O
)	O
{	O
struct	O
pager	pointer
*	O
p	O
=	O
arg	O
;	O
pager_change_attributes	O
(	O
p	O
,	O
1	int
,	O
MEMORY_OBJECT_COPY_DELAY	O
,	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
ports_bucket_iterate	function
(	O
pager_port_bucket	pointer
,	O
block_cache	O
)	O
;	O
sleep	function
(	O
1	int
)	O
;	O
num_pagers	O
=	O
ports_count_bucket	function
(	O
pager_port_bucket	pointer
)	O
;	O
if	O
(	O
num_pagers	O
>	O
0	int
)	O
ports_bucket_iterate	function
(	O
pager_port_bucket	pointer
,	O
enable_cache	O
)	O
;	O
}	O
return	O
num_pagers	O
==	O
0	int
;	O
}	O
error_t	O
dev_get_memory_object	function
(	O
struct	O
dev	pointer
*	O
dev	pointer
,	O
vm_prot_t	O
prot	int
,	O
memory_object_t	O
*	O
memobj	pointer
)	O
{	O
error_t	O
err	O
=	O
store_map	O
(	O
dev	pointer
->	O
store	pointer
,	O
prot	int
,	O
memobj	pointer
)	O
;	O
if	O
(	O
err	O
==	O
EOPNOTSUPP	O
&&	O
!	O
dev	pointer
->	O
inhibit_cache	O
)	O
{	O
int	O
created	int
=	O
0	int
;	O
init_dev_paging	function
(	O
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
dev	pointer
->	O
pager_lock	O
)	O
;	O
if	O
(	O
dev	pointer
->	O
pager	pointer
==	O
NULL	O
)	O
{	O
dev	pointer
->	O
pager	pointer
=	O
pager_create	function
(	O
(	O
struct	O
user_pager_info	O
*	O
)	O
dev	pointer
,	O
pager_port_bucket	pointer
,	O
1	int
,	O
MEMORY_OBJECT_COPY_DELAY	O
,	O
0	int
)	O
;	O
if	O
(	O
dev	pointer
->	O
pager	pointer
==	O
NULL	O
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
dev	pointer
->	O
pager_lock	O
)	O
;	O
return	O
errno	O
;	O
}	O
created	int
=	O
1	int
;	O
}	O
*	O
memobj	pointer
=	O
pager_get_port	function
(	O
dev	pointer
->	O
pager	pointer
)	O
;	O
if	O
(	O
*	O
memobj	pointer
==	O
MACH_PORT_NULL	O
)	O
{	O
dev	pointer
->	O
pager	pointer
=	O
0	int
;	O
pthread_mutex_unlock	function
(	O
&	O
dev	pointer
->	O
pager_lock	O
)	O
;	O
return	O
dev_get_memory_object	function
(	O
dev	pointer
,	O
prot	int
,	O
memobj	pointer
)	O
;	O
}	O
else	O
err	O
=	O
mach_port_insert_right	function
(	O
mach_task_self	function
(	O
)	O
,	O
*	O
memobj	pointer
,	O
*	O
memobj	pointer
,	O
MACH_MSG_TYPE_MAKE_SEND	O
)	O
;	O
if	O
(	O
created	int
)	O
ports_port_deref	function
(	O
dev	pointer
->	O
pager	pointer
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
dev	pointer
->	O
pager_lock	O
)	O
;	O
}	O
return	O
err	O
;	O
}	O
