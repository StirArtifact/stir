typedef	O
struct	O
ctf_dump_item	struct
{	O
ctf_list_t	struct
cdi_list	struct
;	O
char	O
*	O
cdi_item	pointer
;	O
}	O
ctf_dump_item_t	struct
;	O
struct	O
ctf_dump_state	struct
{	O
ctf_sect_names_t	enum
cds_sect	enum
;	O
ctf_file_t	struct
*	O
cds_fp	pointer
;	O
ctf_dump_item_t	struct
*	O
cds_current	pointer
;	O
ctf_list_t	struct
cds_items	struct
;	O
}	O
;	O
typedef	O
struct	O
ctf_dump_membstate	struct
{	O
char	O
*	O
*	O
cdm_str	pointer
;	O
ctf_file_t	struct
*	O
cdm_fp	pointer
;	O
}	O
ctf_dump_membstate_t	struct
;	O
static	O
int	O
ctf_dump_append	function
(	O
ctf_dump_state_t	struct
*	O
state	pointer
,	O
char	O
*	O
str	pointer
)	O
{	O
ctf_dump_item_t	struct
*	O
cdi	pointer
;	O
if	O
(	O
(	O
cdi	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
struct	O
ctf_dump_item	struct
)	O
)	O
)	O
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
state	pointer
->	O
cds_fp	pointer
,	O
ENOMEM	int
)	O
)	O
;	O
cdi	pointer
->	O
cdi_item	pointer
=	O
str	pointer
;	O
ctf_list_append	function
(	O
&	O
state	pointer
->	O
cds_items	struct
,	O
cdi	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
ctf_dump_free	function
(	O
ctf_dump_state_t	struct
*	O
state	pointer
)	O
{	O
ctf_dump_item_t	struct
*	O
cdi	pointer
,	O
*	O
next_cdi	pointer
;	O
if	O
(	O
state	pointer
==	O
NULL	O
)	O
return	O
;	O
for	O
(	O
cdi	pointer
=	O
ctf_list_next	O
(	O
&	O
state	pointer
->	O
cds_items	struct
)	O
;	O
cdi	pointer
!=	O
NULL	O
;	O
cdi	pointer
=	O
next_cdi	pointer
)	O
{	O
free	function
(	O
cdi	pointer
->	O
cdi_item	pointer
)	O
;	O
next_cdi	pointer
=	O
ctf_list_next	O
(	O
cdi	pointer
)	O
;	O
free	function
(	O
cdi	pointer
)	O
;	O
}	O
}	O
static	O
int	O
ctf_is_slice	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
ctf_id_t	long
id	int
,	O
ctf_encoding_t	struct
*	O
enc	pointer
)	O
{	O
int	O
kind	int
=	O
ctf_type_kind	function
(	O
fp	pointer
,	O
id	int
)	O
;	O
return	O
(	O
(	O
(	O
kind	int
==	O
CTF_K_INTEGER	int
)	O
||	O
(	O
kind	int
==	O
CTF_K_ENUM	int
)	O
||	O
(	O
kind	int
==	O
CTF_K_FLOAT	int
)	O
)	O
&&	O
ctf_type_reference	function
(	O
fp	pointer
,	O
id	int
)	O
!=	O
CTF_ERR	O
&&	O
ctf_type_encoding	function
(	O
fp	pointer
,	O
id	int
,	O
enc	pointer
)	O
==	O
0	int
)	O
;	O
}	O
static	O
char	O
*	O
ctf_dump_format_type	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
ctf_id_t	long
id	int
,	O
int	O
flag	int
)	O
{	O
ctf_id_t	long
new_id	long
;	O
char	O
*	O
str	pointer
=	O
NULL	O
,	O
*	O
bit	pointer
=	O
NULL	O
,	O
*	O
buf	pointer
=	O
NULL	O
;	O
new_id	long
=	O
id	int
;	O
do	O
{	O
ctf_encoding_t	struct
enc	pointer
;	O
const	O
char	O
*	O
nonroot_leader	pointer
=	O
""	pointer
;	O
const	O
char	O
*	O
nonroot_trailer	pointer
=	O
""	pointer
;	O
id	int
=	O
new_id	long
;	O
if	O
(	O
flag	int
==	O
CTF_ADD_NONROOT	int
)	O
{	O
nonroot_leader	pointer
=	O
"{"	pointer
;	O
nonroot_trailer	pointer
=	O
"}"	pointer
;	O
}	O
buf	pointer
=	O
ctf_type_aname	function
(	O
fp	pointer
,	O
id	int
)	O
;	O
if	O
(	O
!	O
buf	pointer
)	O
{	O
if	O
(	O
id	int
==	O
0	int
||	O
ctf_errno	function
(	O
fp	pointer
)	O
==	O
ECTF_NONREPRESENTABLE	int
)	O
{	O
str	pointer
=	O
str_append	O
(	O
str	pointer
,	O
" (type not represented in CTF)"	pointer
)	O
;	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ECTF_NOTREF	int
)	O
;	O
break	O
;	O
}	O
goto	O
err	long
;	O
}	O
if	O
(	O
ctf_is_slice	function
(	O
fp	pointer
,	O
id	int
,	O
&	O
enc	pointer
)	O
)	O
{	O
ctf_type_encoding	function
(	O
fp	pointer
,	O
id	int
,	O
&	O
enc	pointer
)	O
;	O
if	O
(	O
asprintf	function
(	O
&	O
bit	pointer
,	O
" %s%lx: [slice 0x%x:0x%x]%s"	pointer
,	O
nonroot_leader	pointer
,	O
id	int
,	O
enc	pointer
.	O
cte_offset	int
,	O
enc	pointer
.	O
cte_bits	int
,	O
nonroot_trailer	pointer
)	O
<	O
0	int
)	O
goto	O
oom	O
;	O
}	O
else	O
{	O
if	O
(	O
asprintf	function
(	O
&	O
bit	pointer
,	O
" %s%lx: %s (size 0x%lx)%s"	pointer
,	O
nonroot_leader	pointer
,	O
id	int
,	O
buf	pointer
[	O
0	int
]	O
==	O
'\0'	O
?	O
"(nameless)"	pointer
:	O
buf	pointer
,	O
(	O
unsigned	O
long	O
)	O
ctf_type_size	function
(	O
fp	pointer
,	O
id	int
)	O
,	O
nonroot_trailer	pointer
)	O
<	O
0	int
)	O
goto	O
oom	O
;	O
}	O
free	function
(	O
buf	pointer
)	O
;	O
buf	pointer
=	O
NULL	O
;	O
str	pointer
=	O
str_append	O
(	O
str	pointer
,	O
bit	pointer
)	O
;	O
free	function
(	O
bit	pointer
)	O
;	O
bit	pointer
=	O
NULL	O
;	O
new_id	long
=	O
ctf_type_reference	function
(	O
fp	pointer
,	O
id	int
)	O
;	O
if	O
(	O
new_id	long
!=	O
CTF_ERR	O
)	O
str	pointer
=	O
str_append	O
(	O
str	pointer
,	O
" ->"	pointer
)	O
;	O
}	O
while	O
(	O
new_id	long
!=	O
CTF_ERR	O
)	O
;	O
if	O
(	O
ctf_errno	function
(	O
fp	pointer
)	O
!=	O
ECTF_NOTREF	int
)	O
{	O
free	function
(	O
str	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
str	pointer
;	O
oom	O
:	O
ctf_set_errno	function
(	O
fp	pointer
,	O
errno	O
)	O
;	O
err	long
:	O
free	function
(	O
buf	pointer
)	O
;	O
free	function
(	O
str	pointer
)	O
;	O
free	function
(	O
bit	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
static	O
int	O
ctf_dump_header_strfield	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
ctf_dump_state_t	struct
*	O
state	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
uint32_t	int
value	int
)	O
{	O
char	O
*	O
str	pointer
;	O
if	O
(	O
value	int
)	O
{	O
if	O
(	O
asprintf	function
(	O
&	O
str	pointer
,	O
"%s: %s\n"	pointer
,	O
name	pointer
,	O
ctf_strptr	function
(	O
fp	pointer
,	O
value	int
)	O
)	O
<	O
0	int
)	O
goto	O
err	long
;	O
ctf_dump_append	function
(	O
state	pointer
,	O
str	pointer
)	O
;	O
}	O
return	O
0	int
;	O
err	long
:	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
errno	O
)	O
)	O
;	O
}	O
static	O
int	O
ctf_dump_header_sectfield	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
ctf_dump_state_t	struct
*	O
state	pointer
,	O
const	O
char	O
*	O
sect	enum
,	O
uint32_t	int
off	int
,	O
uint32_t	int
nextoff	int
)	O
{	O
char	O
*	O
str	pointer
;	O
if	O
(	O
nextoff	int
-	O
off	int
)	O
{	O
if	O
(	O
asprintf	function
(	O
&	O
str	pointer
,	O
"%s:\t0x%lx -- 0x%lx (0x%lx bytes)\n"	pointer
,	O
sect	enum
,	O
(	O
unsigned	O
long	O
)	O
off	int
,	O
(	O
unsigned	O
long	O
)	O
(	O
nextoff	int
-	O
1	int
)	O
,	O
(	O
unsigned	O
long	O
)	O
(	O
nextoff	int
-	O
off	int
)	O
)	O
<	O
0	int
)	O
goto	O
err	long
;	O
ctf_dump_append	function
(	O
state	pointer
,	O
str	pointer
)	O
;	O
}	O
return	O
0	int
;	O
err	long
:	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
errno	O
)	O
)	O
;	O
}	O
static	O
int	O
ctf_dump_header	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
ctf_dump_state_t	struct
*	O
state	pointer
)	O
{	O
char	O
*	O
str	pointer
;	O
const	O
ctf_header_t	struct
*	O
hp	pointer
=	O
fp	pointer
->	O
ctf_header	struct
;	O
const	O
char	O
*	O
vertab	array
[	O
]	O
=	O
{	O
NULL	O
,	O
"CTF_VERSION_1"	pointer
,	O
"CTF_VERSION_1_UPGRADED_3 (latest format, version 1 type "	pointer
"boundaries)"	pointer
,	O
"CTF_VERSION_2"	pointer
,	O
"CTF_VERSION_3"	pointer
,	O
NULL	O
}	O
;	O
const	O
char	O
*	O
verstr	pointer
=	O
NULL	O
;	O
if	O
(	O
asprintf	function
(	O
&	O
str	pointer
,	O
"Magic number: %x\n"	pointer
,	O
hp	pointer
->	O
cth_magic	O
)	O
<	O
0	int
)	O
goto	O
err	long
;	O
ctf_dump_append	function
(	O
state	pointer
,	O
str	pointer
)	O
;	O
if	O
(	O
hp	pointer
->	O
cth_version	O
<=	O
CTF_VERSION	O
)	O
verstr	pointer
=	O
vertab	array
[	O
hp	pointer
->	O
cth_version	O
]	O
;	O
if	O
(	O
verstr	pointer
==	O
NULL	O
)	O
verstr	pointer
=	O
"(not a valid version)"	pointer
;	O
if	O
(	O
asprintf	function
(	O
&	O
str	pointer
,	O
"Version: %i (%s)\n"	pointer
,	O
hp	pointer
->	O
cth_version	O
,	O
verstr	pointer
)	O
<	O
0	int
)	O
goto	O
err	long
;	O
ctf_dump_append	function
(	O
state	pointer
,	O
str	pointer
)	O
;	O
if	O
(	O
fp	pointer
->	O
ctf_openflags	char
>	O
0	int
)	O
{	O
if	O
(	O
fp	pointer
->	O
ctf_openflags	char
)	O
if	O
(	O
asprintf	function
(	O
&	O
str	pointer
,	O
"Flags: 0x%x (%s)"	pointer
,	O
fp	pointer
->	O
ctf_openflags	char
,	O
fp	pointer
->	O
ctf_openflags	char
&	O
CTF_F_COMPRESS	int
?	O
"CTF_F_COMPRESS"	pointer
:	O
""	pointer
)	O
<	O
0	int
)	O
goto	O
err	long
;	O
ctf_dump_append	function
(	O
state	pointer
,	O
str	pointer
)	O
;	O
}	O
if	O
(	O
ctf_dump_header_strfield	function
(	O
fp	pointer
,	O
state	pointer
,	O
"Parent label"	pointer
,	O
hp	pointer
->	O
cth_parlabel	int
)	O
<	O
0	int
)	O
goto	O
err	long
;	O
if	O
(	O
ctf_dump_header_strfield	function
(	O
fp	pointer
,	O
state	pointer
,	O
"Parent name"	pointer
,	O
hp	pointer
->	O
cth_parname	int
)	O
<	O
0	int
)	O
goto	O
err	long
;	O
if	O
(	O
ctf_dump_header_strfield	function
(	O
fp	pointer
,	O
state	pointer
,	O
"Compilation unit name"	pointer
,	O
hp	pointer
->	O
cth_cuname	int
)	O
<	O
0	int
)	O
goto	O
err	long
;	O
if	O
(	O
ctf_dump_header_sectfield	function
(	O
fp	pointer
,	O
state	pointer
,	O
"Label section"	pointer
,	O
hp	pointer
->	O
cth_lbloff	int
,	O
hp	pointer
->	O
cth_objtoff	int
)	O
<	O
0	int
)	O
goto	O
err	long
;	O
if	O
(	O
ctf_dump_header_sectfield	function
(	O
fp	pointer
,	O
state	pointer
,	O
"Data object section"	pointer
,	O
hp	pointer
->	O
cth_objtoff	int
,	O
hp	pointer
->	O
cth_funcoff	int
)	O
<	O
0	int
)	O
goto	O
err	long
;	O
if	O
(	O
ctf_dump_header_sectfield	function
(	O
fp	pointer
,	O
state	pointer
,	O
"Function info section"	pointer
,	O
hp	pointer
->	O
cth_funcoff	int
,	O
hp	pointer
->	O
cth_varoff	int
)	O
<	O
0	int
)	O
goto	O
err	long
;	O
if	O
(	O
ctf_dump_header_sectfield	function
(	O
fp	pointer
,	O
state	pointer
,	O
"Variable section"	pointer
,	O
hp	pointer
->	O
cth_varoff	int
,	O
hp	pointer
->	O
cth_typeoff	int
)	O
<	O
0	int
)	O
goto	O
err	long
;	O
if	O
(	O
ctf_dump_header_sectfield	function
(	O
fp	pointer
,	O
state	pointer
,	O
"Type section"	pointer
,	O
hp	pointer
->	O
cth_typeoff	int
,	O
hp	pointer
->	O
cth_stroff	int
)	O
<	O
0	int
)	O
goto	O
err	long
;	O
if	O
(	O
ctf_dump_header_sectfield	function
(	O
fp	pointer
,	O
state	pointer
,	O
"String section"	pointer
,	O
hp	pointer
->	O
cth_stroff	int
,	O
hp	pointer
->	O
cth_stroff	int
+	O
hp	pointer
->	O
cth_strlen	int
+	O
1	int
)	O
<	O
0	int
)	O
goto	O
err	long
;	O
return	O
0	int
;	O
err	long
:	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
errno	O
)	O
)	O
;	O
}	O
static	O
int	O
ctf_dump_label	function
(	O
const	O
char	O
*	O
name	pointer
,	O
const	O
ctf_lblinfo_t	struct
*	O
info	pointer
,	O
void	O
*	O
arg	pointer
)	O
{	O
char	O
*	O
str	pointer
;	O
char	O
*	O
typestr	pointer
;	O
ctf_dump_state_t	struct
*	O
state	pointer
=	O
arg	pointer
;	O
if	O
(	O
asprintf	function
(	O
&	O
str	pointer
,	O
"%s -> "	pointer
,	O
name	pointer
)	O
<	O
0	int
)	O
return	O
(	O
ctf_set_errno	function
(	O
state	pointer
->	O
cds_fp	pointer
,	O
errno	O
)	O
)	O
;	O
if	O
(	O
(	O
typestr	pointer
=	O
ctf_dump_format_type	function
(	O
state	pointer
->	O
cds_fp	pointer
,	O
info	pointer
->	O
ctb_type	long
,	O
CTF_ADD_ROOT	int
)	O
)	O
==	O
NULL	O
)	O
{	O
free	function
(	O
str	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
str	pointer
=	O
str_append	O
(	O
str	pointer
,	O
typestr	pointer
)	O
;	O
free	function
(	O
typestr	pointer
)	O
;	O
ctf_dump_append	function
(	O
state	pointer
,	O
str	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
ctf_dump_objts	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
ctf_dump_state_t	struct
*	O
state	pointer
)	O
{	O
size_t	long
i	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
fp	pointer
->	O
ctf_nsyms	long
;	O
i	pointer
++	O
)	O
{	O
char	O
*	O
str	pointer
;	O
char	O
*	O
typestr	pointer
;	O
const	O
char	O
*	O
sym_name	pointer
;	O
ctf_id_t	long
type	long
;	O
if	O
(	O
(	O
type	long
=	O
ctf_lookup_by_symbol	function
(	O
state	pointer
->	O
cds_fp	pointer
,	O
i	pointer
)	O
)	O
==	O
CTF_ERR	O
)	O
switch	O
(	O
ctf_errno	function
(	O
state	pointer
->	O
cds_fp	pointer
)	O
)	O
{	O
case	O
ECTF_NOSYMTAB	int
:	O
return	O
-	O
1	int
;	O
case	O
ECTF_NOTDATA	int
:	O
case	O
ECTF_NOTYPEDAT	int
:	O
continue	O
;	O
}	O
sym_name	pointer
=	O
ctf_lookup_symbol_name	function
(	O
fp	pointer
,	O
i	pointer
)	O
;	O
if	O
(	O
sym_name	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
if	O
(	O
asprintf	function
(	O
&	O
str	pointer
,	O
"%lx -> "	pointer
,	O
(	O
unsigned	O
long	O
)	O
i	pointer
)	O
<	O
0	int
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
errno	O
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
asprintf	function
(	O
&	O
str	pointer
,	O
"%s (%lx) -> "	pointer
,	O
sym_name	pointer
,	O
(	O
unsigned	O
long	O
)	O
i	pointer
)	O
<	O
0	int
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
errno	O
)	O
)	O
;	O
}	O
if	O
(	O
(	O
typestr	pointer
=	O
ctf_dump_format_type	function
(	O
state	pointer
->	O
cds_fp	pointer
,	O
type	long
,	O
CTF_ADD_ROOT	int
)	O
)	O
==	O
NULL	O
)	O
{	O
free	function
(	O
str	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
str	pointer
=	O
str_append	O
(	O
str	pointer
,	O
typestr	pointer
)	O
;	O
free	function
(	O
typestr	pointer
)	O
;	O
ctf_dump_append	function
(	O
state	pointer
,	O
str	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
ctf_dump_funcs	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
ctf_dump_state_t	struct
*	O
state	pointer
)	O
{	O
size_t	long
i	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
fp	pointer
->	O
ctf_nsyms	long
;	O
i	pointer
++	O
)	O
{	O
char	O
*	O
str	pointer
;	O
char	O
*	O
bit	pointer
;	O
const	O
char	O
*	O
err	long
;	O
const	O
char	O
*	O
sym_name	pointer
;	O
ctf_funcinfo_t	struct
fi	struct
;	O
ctf_id_t	long
type	long
;	O
size_t	long
j	long
;	O
ctf_id_t	long
*	O
args	pointer
;	O
if	O
(	O
(	O
type	long
=	O
ctf_func_info	function
(	O
state	pointer
->	O
cds_fp	pointer
,	O
i	pointer
,	O
&	O
fi	struct
)	O
)	O
==	O
CTF_ERR	O
)	O
switch	O
(	O
ctf_errno	function
(	O
state	pointer
->	O
cds_fp	pointer
)	O
)	O
{	O
case	O
ECTF_NOSYMTAB	int
:	O
return	O
-	O
1	int
;	O
case	O
ECTF_NOTDATA	int
:	O
case	O
ECTF_NOTFUNC	int
:	O
case	O
ECTF_NOFUNCDAT	int
:	O
continue	O
;	O
}	O
if	O
(	O
(	O
args	pointer
=	O
calloc	function
(	O
fi	struct
.	O
ctc_argc	int
,	O
sizeof	O
(	O
ctf_id_t	long
)	O
)	O
)	O
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ENOMEM	int
)	O
)	O
;	O
if	O
(	O
(	O
str	pointer
=	O
ctf_type_aname	function
(	O
state	pointer
->	O
cds_fp	pointer
,	O
type	long
)	O
)	O
==	O
NULL	O
)	O
{	O
err	long
=	O
"look up return type"	pointer
;	O
goto	O
err	long
;	O
}	O
str	pointer
=	O
str_append	O
(	O
str	pointer
,	O
" "	pointer
)	O
;	O
sym_name	pointer
=	O
ctf_lookup_symbol_name	function
(	O
fp	pointer
,	O
i	pointer
)	O
;	O
if	O
(	O
sym_name	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
if	O
(	O
asprintf	function
(	O
&	O
bit	pointer
,	O
"0x%lx "	pointer
,	O
(	O
unsigned	O
long	O
)	O
i	pointer
)	O
<	O
0	int
)	O
goto	O
oom	O
;	O
}	O
else	O
{	O
if	O
(	O
asprintf	function
(	O
&	O
bit	pointer
,	O
"%s (0x%lx) "	pointer
,	O
sym_name	pointer
,	O
(	O
unsigned	O
long	O
)	O
i	pointer
)	O
<	O
0	int
)	O
goto	O
oom	O
;	O
}	O
str	pointer
=	O
str_append	O
(	O
str	pointer
,	O
bit	pointer
)	O
;	O
str	pointer
=	O
str_append	O
(	O
str	pointer
,	O
" ("	pointer
)	O
;	O
free	function
(	O
bit	pointer
)	O
;	O
if	O
(	O
ctf_func_args	function
(	O
state	pointer
->	O
cds_fp	pointer
,	O
i	pointer
,	O
fi	struct
.	O
ctc_argc	int
,	O
args	pointer
)	O
<	O
0	int
)	O
{	O
err	long
=	O
"look up argument type"	pointer
;	O
goto	O
err	long
;	O
}	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
fi	struct
.	O
ctc_argc	int
;	O
j	long
++	O
)	O
{	O
if	O
(	O
(	O
bit	pointer
=	O
ctf_type_aname	function
(	O
state	pointer
->	O
cds_fp	pointer
,	O
args	pointer
[	O
j	long
]	O
)	O
)	O
==	O
NULL	O
)	O
{	O
err	long
=	O
"look up argument type name"	pointer
;	O
goto	O
err	long
;	O
}	O
str	pointer
=	O
str_append	O
(	O
str	pointer
,	O
bit	pointer
)	O
;	O
if	O
(	O
(	O
j	long
<	O
fi	struct
.	O
ctc_argc	int
-	O
1	int
)	O
||	O
(	O
fi	struct
.	O
ctc_flags	int
&	O
CTF_FUNC_VARARG	int
)	O
)	O
str	pointer
=	O
str_append	O
(	O
str	pointer
,	O
", "	pointer
)	O
;	O
free	function
(	O
bit	pointer
)	O
;	O
}	O
if	O
(	O
fi	struct
.	O
ctc_flags	int
&	O
CTF_FUNC_VARARG	int
)	O
str	pointer
=	O
str_append	O
(	O
str	pointer
,	O
"..."	pointer
)	O
;	O
str	pointer
=	O
str_append	O
(	O
str	pointer
,	O
")"	pointer
)	O
;	O
free	function
(	O
args	pointer
)	O
;	O
ctf_dump_append	function
(	O
state	pointer
,	O
str	pointer
)	O
;	O
continue	O
;	O
oom	O
:	O
free	function
(	O
args	pointer
)	O
;	O
free	function
(	O
str	pointer
)	O
;	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
errno	O
)	O
)	O
;	O
err	long
:	O
ctf_dprintf	function
(	O
"Cannot %s dumping function type for symbol 0x%li: %s\n"	pointer
,	O
err	long
,	O
(	O
unsigned	O
long	O
)	O
i	pointer
,	O
ctf_errmsg	function
(	O
ctf_errno	function
(	O
state	pointer
->	O
cds_fp	pointer
)	O
)	O
)	O
;	O
free	function
(	O
args	pointer
)	O
;	O
free	function
(	O
str	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
ctf_dump_var	function
(	O
const	O
char	O
*	O
name	pointer
,	O
ctf_id_t	long
type	long
,	O
void	O
*	O
arg	pointer
)	O
{	O
char	O
*	O
str	pointer
;	O
char	O
*	O
typestr	pointer
;	O
ctf_dump_state_t	struct
*	O
state	pointer
=	O
arg	pointer
;	O
if	O
(	O
asprintf	function
(	O
&	O
str	pointer
,	O
"%s -> "	pointer
,	O
name	pointer
)	O
<	O
0	int
)	O
return	O
(	O
ctf_set_errno	function
(	O
state	pointer
->	O
cds_fp	pointer
,	O
errno	O
)	O
)	O
;	O
if	O
(	O
(	O
typestr	pointer
=	O
ctf_dump_format_type	function
(	O
state	pointer
->	O
cds_fp	pointer
,	O
type	long
,	O
CTF_ADD_ROOT	int
)	O
)	O
==	O
NULL	O
)	O
{	O
free	function
(	O
str	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
str	pointer
=	O
str_append	O
(	O
str	pointer
,	O
typestr	pointer
)	O
;	O
free	function
(	O
typestr	pointer
)	O
;	O
ctf_dump_append	function
(	O
state	pointer
,	O
str	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
ctf_dump_member	function
(	O
const	O
char	O
*	O
name	pointer
,	O
ctf_id_t	long
id	int
,	O
unsigned	O
long	O
offset	long
,	O
int	O
depth	int
,	O
void	O
*	O
arg	pointer
)	O
{	O
ctf_dump_membstate_t	struct
*	O
state	pointer
=	O
arg	pointer
;	O
char	O
*	O
typestr	pointer
=	O
NULL	O
;	O
char	O
*	O
bit	pointer
=	O
NULL	O
;	O
ctf_encoding_t	struct
ep	struct
;	O
ssize_t	long
i	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
depth	int
;	O
i	pointer
++	O
)	O
*	O
state	pointer
->	O
cdm_str	pointer
=	O
str_append	O
(	O
*	O
state	pointer
->	O
cdm_str	pointer
,	O
"    "	pointer
)	O
;	O
if	O
(	O
(	O
typestr	pointer
=	O
ctf_type_aname	function
(	O
state	pointer
->	O
cdm_fp	pointer
,	O
id	int
)	O
)	O
==	O
NULL	O
)	O
{	O
if	O
(	O
id	int
==	O
0	int
||	O
ctf_errno	function
(	O
state	pointer
->	O
cdm_fp	pointer
)	O
==	O
ECTF_NONREPRESENTABLE	int
)	O
{	O
if	O
(	O
asprintf	function
(	O
&	O
bit	pointer
,	O
"    [0x%lx] (type not represented in CTF)"	pointer
,	O
offset	long
)	O
<	O
0	int
)	O
goto	O
oom	O
;	O
*	O
state	pointer
->	O
cdm_str	pointer
=	O
str_append	O
(	O
*	O
state	pointer
->	O
cdm_str	pointer
,	O
bit	pointer
)	O
;	O
free	function
(	O
typestr	pointer
)	O
;	O
free	function
(	O
bit	pointer
)	O
;	O
return	O
0	int
;	O
}	O
goto	O
oom	O
;	O
}	O
if	O
(	O
asprintf	function
(	O
&	O
bit	pointer
,	O
"    [0x%lx] (ID 0x%lx) (kind %i) %s %s (aligned at 0x%lx"	pointer
,	O
offset	long
,	O
id	int
,	O
ctf_type_kind	function
(	O
state	pointer
->	O
cdm_fp	pointer
,	O
id	int
)	O
,	O
typestr	pointer
,	O
name	pointer
,	O
(	O
unsigned	O
long	O
)	O
ctf_type_align	function
(	O
state	pointer
->	O
cdm_fp	pointer
,	O
id	int
)	O
)	O
<	O
0	int
)	O
goto	O
oom	O
;	O
*	O
state	pointer
->	O
cdm_str	pointer
=	O
str_append	O
(	O
*	O
state	pointer
->	O
cdm_str	pointer
,	O
bit	pointer
)	O
;	O
free	function
(	O
typestr	pointer
)	O
;	O
free	function
(	O
bit	pointer
)	O
;	O
typestr	pointer
=	O
NULL	O
;	O
bit	pointer
=	O
NULL	O
;	O
if	O
(	O
(	O
ctf_type_kind	function
(	O
state	pointer
->	O
cdm_fp	pointer
,	O
id	int
)	O
==	O
CTF_K_INTEGER	int
)	O
||	O
(	O
ctf_type_kind	function
(	O
state	pointer
->	O
cdm_fp	pointer
,	O
id	int
)	O
==	O
CTF_K_FLOAT	int
)	O
||	O
(	O
ctf_is_slice	function
(	O
state	pointer
->	O
cdm_fp	pointer
,	O
id	int
,	O
&	O
ep	struct
)	O
==	O
CTF_K_ENUM	int
)	O
)	O
{	O
ctf_type_encoding	function
(	O
state	pointer
->	O
cdm_fp	pointer
,	O
id	int
,	O
&	O
ep	struct
)	O
;	O
if	O
(	O
asprintf	function
(	O
&	O
bit	pointer
,	O
", format 0x%x, offset:bits 0x%x:0x%x"	pointer
,	O
ep	struct
.	O
cte_format	int
,	O
ep	struct
.	O
cte_offset	int
,	O
ep	struct
.	O
cte_bits	int
)	O
<	O
0	int
)	O
goto	O
oom	O
;	O
*	O
state	pointer
->	O
cdm_str	pointer
=	O
str_append	O
(	O
*	O
state	pointer
->	O
cdm_str	pointer
,	O
bit	pointer
)	O
;	O
free	function
(	O
bit	pointer
)	O
;	O
bit	pointer
=	O
NULL	O
;	O
}	O
*	O
state	pointer
->	O
cdm_str	pointer
=	O
str_append	O
(	O
*	O
state	pointer
->	O
cdm_str	pointer
,	O
")\n"	pointer
)	O
;	O
return	O
0	int
;	O
oom	O
:	O
free	function
(	O
typestr	pointer
)	O
;	O
free	function
(	O
bit	pointer
)	O
;	O
return	O
(	O
ctf_set_errno	function
(	O
state	pointer
->	O
cdm_fp	pointer
,	O
errno	O
)	O
)	O
;	O
}	O
static	O
int	O
ctf_dump_type	function
(	O
ctf_id_t	long
id	int
,	O
int	O
flag	int
,	O
void	O
*	O
arg	pointer
)	O
{	O
char	O
*	O
str	pointer
;	O
const	O
char	O
*	O
err	long
;	O
ctf_dump_state_t	struct
*	O
state	pointer
=	O
arg	pointer
;	O
ctf_dump_membstate_t	struct
membstate	struct
=	O
{	O
&	O
str	pointer
,	O
state	pointer
->	O
cds_fp	pointer
}	O
;	O
size_t	long
len	int
;	O
if	O
(	O
(	O
str	pointer
=	O
ctf_dump_format_type	function
(	O
state	pointer
->	O
cds_fp	pointer
,	O
id	int
,	O
flag	int
)	O
)	O
==	O
NULL	O
)	O
{	O
err	long
=	O
"format type"	pointer
;	O
goto	O
err	long
;	O
}	O
str	pointer
=	O
str_append	O
(	O
str	pointer
,	O
"\n"	pointer
)	O
;	O
if	O
(	O
(	O
ctf_type_visit	function
(	O
state	pointer
->	O
cds_fp	pointer
,	O
id	int
,	O
ctf_dump_member	function
,	O
&	O
membstate	struct
)	O
)	O
<	O
0	int
)	O
{	O
if	O
(	O
id	int
==	O
0	int
||	O
ctf_errno	function
(	O
state	pointer
->	O
cds_fp	pointer
)	O
==	O
ECTF_NONREPRESENTABLE	int
)	O
{	O
ctf_dump_append	function
(	O
state	pointer
,	O
str	pointer
)	O
;	O
return	O
0	int
;	O
}	O
err	long
=	O
"visit members"	pointer
;	O
goto	O
err	long
;	O
}	O
len	int
=	O
strlen	function
(	O
str	pointer
)	O
;	O
if	O
(	O
str	pointer
[	O
len	int
-	O
1	int
]	O
==	O
'\n'	O
)	O
str	pointer
[	O
len	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
ctf_dump_append	function
(	O
state	pointer
,	O
str	pointer
)	O
;	O
return	O
0	int
;	O
err	long
:	O
ctf_dprintf	function
(	O
"Cannot %s dumping type 0x%lx: %s\n"	pointer
,	O
err	long
,	O
id	int
,	O
ctf_errmsg	function
(	O
ctf_errno	function
(	O
state	pointer
->	O
cds_fp	pointer
)	O
)	O
)	O
;	O
free	function
(	O
str	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
static	O
int	O
ctf_dump_str	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
ctf_dump_state_t	struct
*	O
state	pointer
)	O
{	O
const	O
char	O
*	O
s	pointer
=	O
fp	pointer
->	O
ctf_str	array
[	O
CTF_STRTAB_0	int
]	O
.	O
cts_strs	pointer
;	O
for	O
(	O
;	O
s	pointer
<	O
fp	pointer
->	O
ctf_str	array
[	O
CTF_STRTAB_0	int
]	O
.	O
cts_strs	pointer
+	O
fp	pointer
->	O
ctf_str	array
[	O
CTF_STRTAB_0	int
]	O
.	O
cts_len	long
;	O
)	O
{	O
char	O
*	O
str	pointer
;	O
if	O
(	O
asprintf	function
(	O
&	O
str	pointer
,	O
"%lx: %s"	pointer
,	O
(	O
unsigned	O
long	O
)	O
(	O
s	pointer
-	O
fp	pointer
->	O
ctf_str	array
[	O
CTF_STRTAB_0	int
]	O
.	O
cts_strs	pointer
)	O
,	O
s	pointer
)	O
<	O
0	int
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
errno	O
)	O
)	O
;	O
ctf_dump_append	function
(	O
state	pointer
,	O
str	pointer
)	O
;	O
s	pointer
+=	O
strlen	function
(	O
s	pointer
)	O
+	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
char	O
*	O
ctf_dump	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
ctf_dump_state_t	struct
*	O
*	O
statep	pointer
,	O
ctf_sect_names_t	enum
sect	enum
,	O
ctf_dump_decorate_f	function
*	O
func	pointer
,	O
void	O
*	O
arg	pointer
)	O
{	O
char	O
*	O
str	pointer
;	O
char	O
*	O
line	pointer
;	O
ctf_dump_state_t	struct
*	O
state	pointer
=	O
NULL	O
;	O
if	O
(	O
*	O
statep	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
(	O
*	O
statep	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
struct	O
ctf_dump_state	struct
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ENOMEM	int
)	O
;	O
goto	O
end	pointer
;	O
}	O
state	pointer
=	O
*	O
statep	pointer
;	O
memset	function
(	O
state	pointer
,	O
0	int
,	O
sizeof	O
(	O
struct	O
ctf_dump_state	struct
)	O
)	O
;	O
state	pointer
->	O
cds_fp	pointer
=	O
fp	pointer
;	O
state	pointer
->	O
cds_sect	enum
=	O
sect	enum
;	O
switch	O
(	O
sect	enum
)	O
{	O
case	O
CTF_SECT_HEADER	int
:	O
ctf_dump_header	function
(	O
fp	pointer
,	O
state	pointer
)	O
;	O
break	O
;	O
case	O
CTF_SECT_LABEL	int
:	O
if	O
(	O
ctf_label_iter	function
(	O
fp	pointer
,	O
ctf_dump_label	function
,	O
state	pointer
)	O
<	O
0	int
)	O
{	O
if	O
(	O
ctf_errno	function
(	O
fp	pointer
)	O
!=	O
ECTF_NOLABELDATA	int
)	O
goto	O
end	pointer
;	O
ctf_set_errno	function
(	O
fp	pointer
,	O
0	int
)	O
;	O
}	O
break	O
;	O
case	O
CTF_SECT_OBJT	int
:	O
if	O
(	O
ctf_dump_objts	function
(	O
fp	pointer
,	O
state	pointer
)	O
<	O
0	int
)	O
goto	O
end	pointer
;	O
break	O
;	O
case	O
CTF_SECT_FUNC	int
:	O
if	O
(	O
ctf_dump_funcs	function
(	O
fp	pointer
,	O
state	pointer
)	O
<	O
0	int
)	O
goto	O
end	pointer
;	O
break	O
;	O
case	O
CTF_SECT_VAR	int
:	O
if	O
(	O
ctf_variable_iter	function
(	O
fp	pointer
,	O
ctf_dump_var	function
,	O
state	pointer
)	O
<	O
0	int
)	O
goto	O
end	pointer
;	O
break	O
;	O
case	O
CTF_SECT_TYPE	int
:	O
if	O
(	O
ctf_type_iter_all	function
(	O
fp	pointer
,	O
ctf_dump_type	function
,	O
state	pointer
)	O
<	O
0	int
)	O
goto	O
end	pointer
;	O
break	O
;	O
case	O
CTF_SECT_STR	int
:	O
ctf_dump_str	function
(	O
fp	pointer
,	O
state	pointer
)	O
;	O
break	O
;	O
default	O
:	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ECTF_DUMPSECTUNKNOWN	int
)	O
;	O
goto	O
end	pointer
;	O
}	O
}	O
else	O
{	O
state	pointer
=	O
*	O
statep	pointer
;	O
if	O
(	O
state	pointer
->	O
cds_sect	enum
!=	O
sect	enum
)	O
{	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ECTF_DUMPSECTCHANGED	int
)	O
;	O
goto	O
end	pointer
;	O
}	O
}	O
if	O
(	O
state	pointer
->	O
cds_current	pointer
==	O
NULL	O
)	O
state	pointer
->	O
cds_current	pointer
=	O
ctf_list_next	O
(	O
&	O
state	pointer
->	O
cds_items	struct
)	O
;	O
else	O
state	pointer
->	O
cds_current	pointer
=	O
ctf_list_next	O
(	O
state	pointer
->	O
cds_current	pointer
)	O
;	O
if	O
(	O
state	pointer
->	O
cds_current	pointer
==	O
NULL	O
)	O
goto	O
end	pointer
;	O
if	O
(	O
func	pointer
)	O
{	O
size_t	long
len	int
;	O
str	pointer
=	O
NULL	O
;	O
for	O
(	O
line	pointer
=	O
state	pointer
->	O
cds_current	pointer
->	O
cdi_item	pointer
;	O
line	pointer
&&	O
*	O
line	pointer
;	O
)	O
{	O
char	O
*	O
nline	pointer
=	O
line	pointer
;	O
char	O
*	O
ret	pointer
;	O
nline	pointer
=	O
strchr	function
(	O
line	pointer
,	O
'\n'	O
)	O
;	O
if	O
(	O
nline	pointer
)	O
nline	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
ret	pointer
=	O
func	pointer
(	O
sect	enum
,	O
line	pointer
,	O
arg	pointer
)	O
;	O
str	pointer
=	O
str_append	O
(	O
str	pointer
,	O
ret	pointer
)	O
;	O
str	pointer
=	O
str_append	O
(	O
str	pointer
,	O
"\n"	pointer
)	O
;	O
if	O
(	O
ret	pointer
!=	O
line	pointer
)	O
free	function
(	O
ret	pointer
)	O
;	O
if	O
(	O
nline	pointer
)	O
{	O
nline	pointer
[	O
0	int
]	O
=	O
'\n'	O
;	O
nline	pointer
++	O
;	O
}	O
line	pointer
=	O
nline	pointer
;	O
}	O
len	int
=	O
strlen	function
(	O
str	pointer
)	O
;	O
if	O
(	O
str	pointer
[	O
len	int
-	O
1	int
]	O
==	O
'\n'	O
)	O
str	pointer
[	O
len	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
{	O
str	pointer
=	O
strdup	function
(	O
state	pointer
->	O
cds_current	pointer
->	O
cdi_item	pointer
)	O
;	O
if	O
(	O
!	O
str	pointer
)	O
{	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ENOMEM	int
)	O
;	O
return	O
str	pointer
;	O
}	O
}	O
ctf_set_errno	function
(	O
fp	pointer
,	O
0	int
)	O
;	O
return	O
str	pointer
;	O
end	pointer
:	O
ctf_dump_free	function
(	O
state	pointer
)	O
;	O
free	function
(	O
state	pointer
)	O
;	O
ctf_set_errno	function
(	O
fp	pointer
,	O
0	int
)	O
;	O
*	O
statep	pointer
=	O
NULL	O
;	O
return	O
NULL	O
;	O
}	O
