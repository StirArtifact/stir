int	O
atof_generic	function
(	O
char	O
*	O
*	O
address_of_string_pointer	pointer
,	O
const	O
char	O
*	O
string_of_decimal_marks	pointer
,	O
const	O
char	O
*	O
string_of_decimal_exponent_marks	pointer
,	O
FLONUM_TYPE	struct
*	O
address_of_generic_floating_point_number	pointer
)	O
{	O
int	O
return_value	int
;	O
char	O
*	O
first_digit	pointer
;	O
unsigned	O
int	O
number_of_digits_before_decimal	int
;	O
unsigned	O
int	O
number_of_digits_after_decimal	int
;	O
long	O
decimal_exponent	long
;	O
unsigned	O
int	O
number_of_digits_available	int
;	O
char	O
digits_sign_char	char
;	O
char	O
*	O
p	pointer
;	O
char	O
c	struct
;	O
int	O
seen_significant_digit	int
;	O
gas_assert	O
(	O
string_of_decimal_marks	pointer
[	O
0	int
]	O
==	O
'.'	O
&&	O
string_of_decimal_marks	pointer
[	O
1	int
]	O
==	O
0	int
)	O
;	O
first_digit	pointer
=	O
*	O
address_of_string_pointer	pointer
;	O
c	struct
=	O
*	O
first_digit	pointer
;	O
if	O
(	O
c	struct
==	O
'-'	O
||	O
c	struct
==	O
'+'	O
)	O
{	O
digits_sign_char	char
=	O
c	struct
;	O
first_digit	pointer
++	O
;	O
}	O
else	O
digits_sign_char	char
=	O
'+'	O
;	O
switch	O
(	O
first_digit	pointer
[	O
0	int
]	O
)	O
{	O
case	O
'n'	O
:	O
case	O
'N'	O
:	O
if	O
(	O
!	O
strncasecmp	function
(	O
"nan"	pointer
,	O
first_digit	pointer
,	O
3	int
)	O
)	O
{	O
address_of_generic_floating_point_number	pointer
->	O
sign	char
=	O
0	int
;	O
address_of_generic_floating_point_number	pointer
->	O
exponent	long
=	O
0	int
;	O
address_of_generic_floating_point_number	pointer
->	O
leader	pointer
=	O
address_of_generic_floating_point_number	pointer
->	O
low	pointer
;	O
*	O
address_of_string_pointer	pointer
=	O
first_digit	pointer
+	O
3	int
;	O
return	O
0	int
;	O
}	O
break	O
;	O
case	O
'i'	O
:	O
case	O
'I'	O
:	O
if	O
(	O
!	O
strncasecmp	function
(	O
"inf"	pointer
,	O
first_digit	pointer
,	O
3	int
)	O
)	O
{	O
address_of_generic_floating_point_number	pointer
->	O
sign	char
=	O
digits_sign_char	char
==	O
'+'	O
?	O
'P'	O
:	O
'N'	O
;	O
address_of_generic_floating_point_number	pointer
->	O
exponent	long
=	O
0	int
;	O
address_of_generic_floating_point_number	pointer
->	O
leader	pointer
=	O
address_of_generic_floating_point_number	pointer
->	O
low	pointer
;	O
first_digit	pointer
+=	O
3	int
;	O
if	O
(	O
!	O
strncasecmp	function
(	O
"inity"	pointer
,	O
first_digit	pointer
,	O
5	int
)	O
)	O
first_digit	pointer
+=	O
5	int
;	O
*	O
address_of_string_pointer	pointer
=	O
first_digit	pointer
;	O
return	O
0	int
;	O
}	O
break	O
;	O
}	O
number_of_digits_before_decimal	int
=	O
0	int
;	O
number_of_digits_after_decimal	int
=	O
0	int
;	O
decimal_exponent	long
=	O
0	int
;	O
seen_significant_digit	int
=	O
0	int
;	O
for	O
(	O
p	pointer
=	O
first_digit	pointer
;	O
(	O
(	O
(	O
c	struct
=	O
*	O
p	pointer
)	O
!=	O
'\0'	O
)	O
&&	O
(	O
!	O
c	struct
||	O
!	O
IS_DECIMAL_MARK	O
(	O
c	struct
)	O
)	O
&&	O
(	O
!	O
c	struct
||	O
!	O
strchr	function
(	O
string_of_decimal_exponent_marks	pointer
,	O
c	struct
)	O
)	O
)	O
;	O
p	pointer
++	O
)	O
{	O
if	O
(	O
ISDIGIT	O
(	O
c	struct
)	O
)	O
{	O
if	O
(	O
seen_significant_digit	int
||	O
c	struct
>	O
'0'	O
)	O
{	O
++	O
number_of_digits_before_decimal	int
;	O
seen_significant_digit	int
=	O
1	int
;	O
}	O
else	O
{	O
first_digit	pointer
++	O
;	O
}	O
}	O
else	O
{	O
break	O
;	O
}	O
}	O
seen_significant_digit	int
=	O
0	int
;	O
signed	O
long	O
subtract_decimal_exponent	long
=	O
0	int
;	O
if	O
(	O
c	struct
&&	O
IS_DECIMAL_MARK	O
(	O
c	struct
)	O
)	O
{	O
unsigned	O
int	O
zeros	int
=	O
0	int
;	O
if	O
(	O
number_of_digits_before_decimal	int
==	O
0	int
)	O
first_digit	pointer
++	O
;	O
for	O
(	O
p	pointer
++	O
;	O
(	O
c	struct
=	O
*	O
p	pointer
)	O
&&	O
ISDIGIT	O
(	O
c	struct
)	O
;	O
p	pointer
++	O
)	O
{	O
if	O
(	O
c	struct
==	O
'0'	O
)	O
{	O
if	O
(	O
number_of_digits_before_decimal	int
==	O
0	int
&&	O
!	O
seen_significant_digit	int
)	O
{	O
first_digit	pointer
++	O
;	O
subtract_decimal_exponent	long
--	O
;	O
}	O
else	O
zeros	int
++	O
;	O
}	O
else	O
{	O
seen_significant_digit	int
=	O
1	int
;	O
number_of_digits_after_decimal	int
+=	O
1	int
+	O
zeros	int
;	O
zeros	int
=	O
0	int
;	O
}	O
}	O
}	O
if	O
(	O
flag_m68k_mri	int
)	O
{	O
while	O
(	O
c	struct
==	O
'_'	O
)	O
c	struct
=	O
*	O
++	O
p	pointer
;	O
}	O
if	O
(	O
c	struct
&&	O
strchr	function
(	O
string_of_decimal_exponent_marks	pointer
,	O
c	struct
)	O
)	O
{	O
char	O
digits_exponent_sign_char	char
;	O
c	struct
=	O
*	O
++	O
p	pointer
;	O
if	O
(	O
flag_m68k_mri	int
)	O
{	O
while	O
(	O
c	struct
==	O
'_'	O
)	O
c	struct
=	O
*	O
++	O
p	pointer
;	O
}	O
if	O
(	O
c	struct
&&	O
strchr	function
(	O
"+-"	pointer
,	O
c	struct
)	O
)	O
{	O
digits_exponent_sign_char	char
=	O
c	struct
;	O
c	struct
=	O
*	O
++	O
p	pointer
;	O
}	O
else	O
{	O
digits_exponent_sign_char	char
=	O
'+'	O
;	O
}	O
for	O
(	O
;	O
(	O
c	struct
)	O
;	O
c	struct
=	O
*	O
++	O
p	pointer
)	O
{	O
if	O
(	O
ISDIGIT	O
(	O
c	struct
)	O
)	O
{	O
decimal_exponent	long
=	O
decimal_exponent	long
*	O
10	int
+	O
c	struct
-	O
'0'	O
;	O
}	O
else	O
{	O
break	O
;	O
}	O
}	O
if	O
(	O
digits_exponent_sign_char	char
==	O
'-'	O
)	O
{	O
decimal_exponent	long
=	O
-	O
decimal_exponent	long
;	O
}	O
}	O
decimal_exponent	long
+=	O
subtract_decimal_exponent	long
;	O
*	O
address_of_string_pointer	pointer
=	O
p	pointer
;	O
number_of_digits_available	int
=	O
number_of_digits_before_decimal	int
+	O
number_of_digits_after_decimal	int
;	O
return_value	int
=	O
0	int
;	O
if	O
(	O
number_of_digits_available	int
==	O
0	int
)	O
{	O
address_of_generic_floating_point_number	pointer
->	O
exponent	long
=	O
0	int
;	O
address_of_generic_floating_point_number	pointer
->	O
leader	pointer
=	O
-	O
1	int
+	O
address_of_generic_floating_point_number	pointer
->	O
low	pointer
;	O
address_of_generic_floating_point_number	pointer
->	O
sign	char
=	O
digits_sign_char	char
;	O
}	O
else	O
{	O
int	O
count	int
;	O
LITTLENUM_TYPE	short
*	O
temporary_binary_low	pointer
=	O
NULL	O
;	O
LITTLENUM_TYPE	short
*	O
power_binary_low	pointer
=	O
NULL	O
;	O
LITTLENUM_TYPE	short
*	O
digits_binary_low	pointer
;	O
unsigned	O
int	O
precision	int
;	O
unsigned	O
int	O
maximum_useful_digits	int
;	O
unsigned	O
int	O
number_of_digits_to_use	int
;	O
unsigned	O
int	O
more_than_enough_bits_for_digits	int
;	O
unsigned	O
int	O
more_than_enough_littlenums_for_digits	int
;	O
unsigned	O
int	O
size_of_digits_in_littlenums	int
;	O
unsigned	O
int	O
size_of_digits_in_chars	int
;	O
FLONUM_TYPE	struct
power_of_10_flonum	struct
;	O
FLONUM_TYPE	struct
digits_flonum	struct
;	O
precision	int
=	O
(	O
address_of_generic_floating_point_number	pointer
->	O
high	pointer
-	O
address_of_generic_floating_point_number	pointer
->	O
low	pointer
+	O
1	int
)	O
;	O
maximum_useful_digits	int
=	O
(	O
precision	int
*	O
LITTLENUM_NUMBER_OF_BITS	O
*	O
1000000	int
/	O
3321928	int
+	O
1	int
)	O
;	O
if	O
(	O
number_of_digits_available	int
>	O
maximum_useful_digits	int
)	O
{	O
number_of_digits_to_use	int
=	O
maximum_useful_digits	int
;	O
}	O
else	O
{	O
number_of_digits_to_use	int
=	O
number_of_digits_available	int
;	O
}	O
decimal_exponent	long
+=	O
(	O
(	O
long	O
)	O
number_of_digits_before_decimal	int
-	O
(	O
long	O
)	O
number_of_digits_to_use	int
)	O
;	O
more_than_enough_bits_for_digits	int
=	O
(	O
number_of_digits_to_use	int
*	O
3321928	int
/	O
1000000	int
+	O
1	int
)	O
;	O
more_than_enough_littlenums_for_digits	int
=	O
(	O
more_than_enough_bits_for_digits	int
/	O
LITTLENUM_NUMBER_OF_BITS	O
)	O
+	O
2	int
;	O
size_of_digits_in_littlenums	int
=	O
more_than_enough_littlenums_for_digits	int
;	O
size_of_digits_in_chars	int
=	O
size_of_digits_in_littlenums	int
*	O
sizeof	O
(	O
LITTLENUM_TYPE	short
)	O
;	O
digits_binary_low	pointer
=	O
(	O
LITTLENUM_TYPE	short
*	O
)	O
xmalloc	function
(	O
size_of_digits_in_chars	int
)	O
;	O
memset	function
(	O
(	O
char	O
*	O
)	O
digits_binary_low	pointer
,	O
'\0'	O
,	O
size_of_digits_in_chars	int
)	O
;	O
for	O
(	O
p	pointer
=	O
first_digit	pointer
,	O
count	int
=	O
number_of_digits_to_use	int
;	O
count	int
;	O
p	pointer
++	O
,	O
--	O
count	int
)	O
{	O
c	struct
=	O
*	O
p	pointer
;	O
if	O
(	O
ISDIGIT	O
(	O
c	struct
)	O
)	O
{	O
long	O
carry	long
;	O
LITTLENUM_TYPE	short
*	O
littlenum_pointer	pointer
;	O
LITTLENUM_TYPE	short
*	O
littlenum_limit	pointer
;	O
littlenum_limit	pointer
=	O
digits_binary_low	pointer
+	O
more_than_enough_littlenums_for_digits	int
-	O
1	int
;	O
carry	long
=	O
c	struct
-	O
'0'	O
;	O
for	O
(	O
littlenum_pointer	pointer
=	O
digits_binary_low	pointer
;	O
littlenum_pointer	pointer
<=	O
littlenum_limit	pointer
;	O
littlenum_pointer	pointer
++	O
)	O
{	O
long	O
work	long
;	O
work	long
=	O
carry	long
+	O
10	int
*	O
(	O
long	O
)	O
(	O
*	O
littlenum_pointer	pointer
)	O
;	O
*	O
littlenum_pointer	pointer
=	O
work	long
&	O
LITTLENUM_MASK	O
;	O
carry	long
=	O
work	long
>>	O
LITTLENUM_NUMBER_OF_BITS	O
;	O
}	O
if	O
(	O
carry	long
!=	O
0	int
)	O
{	O
as_fatal	function
(	O
_	O
(	O
"failed sanity check"	pointer
)	O
)	O
;	O
}	O
}	O
else	O
{	O
++	O
count	int
;	O
}	O
}	O
while	O
(	O
digits_binary_low	pointer
[	O
size_of_digits_in_littlenums	int
-	O
1	int
]	O
==	O
0	int
&&	O
size_of_digits_in_littlenums	int
>=	O
2	int
)	O
size_of_digits_in_littlenums	int
--	O
;	O
digits_flonum	struct
.	O
low	pointer
=	O
digits_binary_low	pointer
;	O
digits_flonum	struct
.	O
high	pointer
=	O
digits_binary_low	pointer
+	O
size_of_digits_in_littlenums	int
-	O
1	int
;	O
digits_flonum	struct
.	O
leader	pointer
=	O
digits_flonum	struct
.	O
high	pointer
;	O
digits_flonum	struct
.	O
exponent	long
=	O
0	int
;	O
digits_flonum	struct
.	O
sign	char
=	O
'+'	O
;	O
{	O
int	O
decimal_exponent_is_negative	int
;	O
FLONUM_TYPE	struct
temporary_flonum	struct
;	O
unsigned	O
int	O
size_of_power_in_littlenums	int
;	O
unsigned	O
int	O
size_of_power_in_chars	int
;	O
size_of_power_in_littlenums	int
=	O
precision	int
;	O
decimal_exponent_is_negative	int
=	O
decimal_exponent	long
<	O
0	int
;	O
if	O
(	O
decimal_exponent_is_negative	int
)	O
{	O
decimal_exponent	long
=	O
-	O
decimal_exponent	long
;	O
}	O
size_of_power_in_chars	int
=	O
size_of_power_in_littlenums	int
*	O
sizeof	O
(	O
LITTLENUM_TYPE	short
)	O
+	O
2	int
;	O
power_binary_low	pointer
=	O
(	O
LITTLENUM_TYPE	short
*	O
)	O
xmalloc	function
(	O
size_of_power_in_chars	int
)	O
;	O
temporary_binary_low	pointer
=	O
(	O
LITTLENUM_TYPE	short
*	O
)	O
xmalloc	function
(	O
size_of_power_in_chars	int
)	O
;	O
memset	function
(	O
(	O
char	O
*	O
)	O
power_binary_low	pointer
,	O
'\0'	O
,	O
size_of_power_in_chars	int
)	O
;	O
*	O
power_binary_low	pointer
=	O
1	int
;	O
power_of_10_flonum	struct
.	O
exponent	long
=	O
0	int
;	O
power_of_10_flonum	struct
.	O
low	pointer
=	O
power_binary_low	pointer
;	O
power_of_10_flonum	struct
.	O
leader	pointer
=	O
power_binary_low	pointer
;	O
power_of_10_flonum	struct
.	O
high	pointer
=	O
power_binary_low	pointer
+	O
size_of_power_in_littlenums	int
-	O
1	int
;	O
power_of_10_flonum	struct
.	O
sign	char
=	O
'+'	O
;	O
temporary_flonum	struct
.	O
low	pointer
=	O
temporary_binary_low	pointer
;	O
temporary_flonum	struct
.	O
high	pointer
=	O
temporary_binary_low	pointer
+	O
size_of_power_in_littlenums	int
-	O
1	int
;	O
{	O
int	O
place_number_limit	int
;	O
int	O
place_number	int
;	O
const	O
FLONUM_TYPE	struct
*	O
multiplicand	pointer
;	O
place_number_limit	int
=	O
table_size_of_flonum_powers_of_ten	int
;	O
multiplicand	pointer
=	O
(	O
decimal_exponent_is_negative	int
?	O
flonum_negative_powers_of_ten	array
:	O
flonum_positive_powers_of_ten	array
)	O
;	O
for	O
(	O
place_number	int
=	O
1	int
;	O
decimal_exponent	long
;	O
decimal_exponent	long
>>=	O
1	int
,	O
place_number	int
++	O
)	O
{	O
if	O
(	O
decimal_exponent	long
&	O
1	int
)	O
{	O
if	O
(	O
place_number	int
>	O
place_number_limit	int
)	O
{	O
return_value	int
=	O
ERROR_EXPONENT_OVERFLOW	O
;	O
decimal_exponent	long
=	O
0	int
;	O
}	O
else	O
{	O
flonum_multip	function
(	O
multiplicand	pointer
+	O
place_number	int
,	O
&	O
power_of_10_flonum	struct
,	O
&	O
temporary_flonum	struct
)	O
;	O
flonum_copy	function
(	O
&	O
temporary_flonum	struct
,	O
&	O
power_of_10_flonum	struct
)	O
;	O
}	O
}	O
}	O
}	O
}	O
flonum_multip	function
(	O
&	O
power_of_10_flonum	struct
,	O
&	O
digits_flonum	struct
,	O
address_of_generic_floating_point_number	pointer
)	O
;	O
address_of_generic_floating_point_number	pointer
->	O
sign	char
=	O
digits_sign_char	char
;	O
if	O
(	O
temporary_binary_low	pointer
)	O
free	function
(	O
temporary_binary_low	pointer
)	O
;	O
if	O
(	O
power_binary_low	pointer
)	O
free	function
(	O
power_binary_low	pointer
)	O
;	O
free	function
(	O
digits_binary_low	pointer
)	O
;	O
}	O
return	O
return_value	int
;	O
}	O
