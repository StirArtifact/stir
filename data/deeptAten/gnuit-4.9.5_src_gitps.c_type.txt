static	O
char	O
*	O
PSFields	array
[	O
PS_FIELDS	int
]	O
=	O
{	O
"TitleForeground"	pointer
,	O
"TitleBackground"	pointer
,	O
"TitleBrightness"	pointer
,	O
"HeaderForeground"	pointer
,	O
"HeaderBackground"	pointer
,	O
"HeaderBrightness"	pointer
,	O
"ScreenForeground"	pointer
,	O
"ScreenBackground"	pointer
,	O
"ScreenBrightness"	pointer
,	O
"StatusForeground"	pointer
,	O
"StatusBackground"	pointer
,	O
"StatusBrightness"	pointer
}	O
;	O
static	O
int	O
PSColors	array
[	O
PS_FIELDS	int
]	O
=	O
{	O
CYAN	int
,	O
BLUE	int
,	O
ON	int
,	O
CYAN	int
,	O
RED	int
,	O
ON	int
,	O
BLACK	int
,	O
CYAN	int
,	O
OFF	int
,	O
CYAN	int
,	O
BLUE	int
,	O
ON	int
}	O
;	O
extern	O
int	O
LinuxConsole	int
;	O
int	O
AnsiColors	int
=	O
ON	int
;	O
char	O
color_section	array
[	O
]	O
=	O
"[GITPS-Color]"	pointer
;	O
char	O
monochrome_section	array
[	O
]	O
=	O
"[GITPS-Monochrome]"	pointer
;	O
int	O
processes	int
;	O
int	O
PID_index	int
;	O
char	O
*	O
g_home	pointer
;	O
char	O
*	O
g_program	pointer
;	O
char	O
*	O
program_name	pointer
;	O
char	O
*	O
ps_cmd	pointer
;	O
char	O
*	O
temporary_directory	pointer
;	O
char	O
header_text	array
[	O
MAX_LINE	int
]	O
;	O
int	O
UseLastScreenChar	int
;	O
int	O
StartupScrollStep	int
;	O
int	O
RefreshAfterKill	int
;	O
char	O
*	O
stdout_log_name	pointer
;	O
char	O
*	O
stderr_log_name	pointer
;	O
char	O
*	O
stdout_log_template	pointer
;	O
char	O
*	O
stderr_log_template	pointer
;	O
char	O
*	O
*	O
ps_vect	pointer
;	O
char	O
*	O
screen	pointer
;	O
char	O
*	O
global_buf	pointer
;	O
int	O
first_on_screen	int
,	O
current_process	int
,	O
scroll_step	int
;	O
static	O
int	O
horizontal_offset	int
=	O
0	int
;	O
window_t	struct
*	O
title_window	pointer
,	O
*	O
header_window	pointer
,	O
*	O
processes_window	pointer
,	O
*	O
status_window	pointer
;	O
static	O
char	O
*	O
title_text	pointer
;	O
static	O
char	O
*	O
help	pointer
;	O
static	O
char	O
no_perm	array
[	O
]	O
=	O
"not owner !"	pointer
;	O
static	O
char	O
no_proc	array
[	O
]	O
=	O
"no such process ! (REFRESH recommended)"	pointer
;	O
typedef	O
struct	O
{	O
char	O
signame	array
[	O
10	int
]	O
;	O
int	O
signal	function
;	O
}	O
xsignal_t	struct
;	O
int	O
signal_type	int
=	O
0	int
;	O
static	O
xsignal_t	struct
sigdesc	array
[	O
]	O
=	O
{	O
{	O
"SIGALRM  "	pointer
,	O
SIGALRM	int
}	O
,	O
{	O
"SIGABRT  "	pointer
,	O
SIGABRT	int
}	O
,	O
{	O
"SIGBUS   "	pointer
,	O
SIGBUS	int
}	O
,	O
{	O
"SIGCHLD  "	pointer
,	O
SIGCHLD	int
}	O
,	O
{	O
"SIGCLD   "	pointer
,	O
SIGCLD	O
}	O
,	O
{	O
"SIGCONT  "	pointer
,	O
SIGCONT	int
}	O
,	O
{	O
"SIGFPE   "	pointer
,	O
SIGFPE	int
}	O
,	O
{	O
"SIGHUP   "	pointer
,	O
SIGHUP	int
}	O
,	O
{	O
"SIGILL   "	pointer
,	O
SIGILL	int
}	O
,	O
{	O
"SIGINT   "	pointer
,	O
SIGINT	int
}	O
,	O
{	O
"SIGIO    "	pointer
,	O
SIGIO	O
}	O
,	O
{	O
"SIGIOT   "	pointer
,	O
SIGIOT	O
}	O
,	O
{	O
"SIGKILL  "	pointer
,	O
SIGKILL	int
}	O
,	O
{	O
"SIGPIPE  "	pointer
,	O
SIGPIPE	int
}	O
,	O
{	O
"SIGPOLL  "	pointer
,	O
SIGPOLL	int
}	O
,	O
{	O
"SIGPROF  "	pointer
,	O
SIGPROF	int
}	O
,	O
{	O
"SIGPWR   "	pointer
,	O
SIGPWR	int
}	O
,	O
{	O
"SIGQUIT  "	pointer
,	O
SIGQUIT	int
}	O
,	O
{	O
"SIGSEGV  "	pointer
,	O
SIGSEGV	int
}	O
,	O
{	O
"SIGSTOP  "	pointer
,	O
SIGSTOP	int
}	O
,	O
{	O
"SIGSYS   "	pointer
,	O
SIGSYS	int
}	O
,	O
{	O
"SIGTERM  "	pointer
,	O
SIGTERM	int
}	O
,	O
{	O
"SIGSTKFLT"	pointer
,	O
SIGSTKFLT	int
}	O
,	O
{	O
"SIGTRAP  "	pointer
,	O
SIGTRAP	int
}	O
,	O
{	O
"SIGTSTP  "	pointer
,	O
SIGTSTP	int
}	O
,	O
{	O
"SIGTTIN  "	pointer
,	O
SIGTTIN	int
}	O
,	O
{	O
"SIGTTOU  "	pointer
,	O
SIGTTOU	int
}	O
,	O
{	O
"SIGURG   "	pointer
,	O
SIGURG	int
}	O
,	O
{	O
"SIGUSR1  "	pointer
,	O
SIGUSR1	int
}	O
,	O
{	O
"SIGUSR2  "	pointer
,	O
SIGUSR2	int
}	O
,	O
{	O
"SIGVTALRM"	pointer
,	O
SIGVTALRM	int
}	O
,	O
{	O
"SIGWINCH "	pointer
,	O
SIGWINCH	int
}	O
,	O
{	O
"SIGXCPU  "	pointer
,	O
SIGXCPU	int
}	O
,	O
{	O
"SIGXFSZ  "	pointer
,	O
SIGXFSZ	int
}	O
,	O
}	O
;	O
char	O
built_in	array
[	O
BUILTIN_OPERATIONS	int
]	O
[	O
MAX_BUILTIN_NAME	int
]	O
=	O
{	O
"previous-line"	pointer
,	O
"next-line"	pointer
,	O
"scroll-down"	pointer
,	O
"scroll-up"	pointer
,	O
"beginning-of-list"	pointer
,	O
"end-of-list"	pointer
,	O
"next-signal"	pointer
,	O
"SIGALRM"	pointer
,	O
"SIGABRT"	pointer
,	O
"SIGBUS"	pointer
,	O
"SIGCHLD"	pointer
,	O
"SIGCLD"	pointer
,	O
"SIGCONT"	pointer
,	O
"SIGEMT"	pointer
,	O
"SIGFPE"	pointer
,	O
"SIGHUP"	pointer
,	O
"SIGILL"	pointer
,	O
"SIGINFO"	pointer
,	O
"SIGINT"	pointer
,	O
"SIGIO"	pointer
,	O
"SIGIOT"	pointer
,	O
"SIGKILL"	pointer
,	O
"SIGPIPE"	pointer
,	O
"SIGPOLL"	pointer
,	O
"SIGPROF"	pointer
,	O
"SIGPWR"	pointer
,	O
"SIGQUIT"	pointer
,	O
"SIGSEGV"	pointer
,	O
"SIGSTOP"	pointer
,	O
"SIGSYS"	pointer
,	O
"SIGTERM"	pointer
,	O
"SIGTRAP"	pointer
,	O
"SIGTSTP"	pointer
,	O
"SIGTTIN"	pointer
,	O
"SIGTTOU"	pointer
,	O
"SIGURG"	pointer
,	O
"SIGUSR1"	pointer
,	O
"SIGUSR2"	pointer
,	O
"SIGVTALRM"	pointer
,	O
"SIGWINCH"	pointer
,	O
"SIGXCPU"	pointer
,	O
"SIGXFSZ"	pointer
,	O
"kill-process"	pointer
,	O
"refresh"	pointer
,	O
"exit"	pointer
,	O
"hard-refresh"	pointer
,	O
"SIGSTKFLT"	pointer
,	O
"horizontal-scroll-left"	pointer
,	O
"horizontal-scroll-right"	pointer
,	O
}	O
;	O
void	O
remove_log	function
(	O
)	O
{	O
if	O
(	O
stdout_log_name	pointer
)	O
unlink	function
(	O
stdout_log_name	pointer
)	O
;	O
if	O
(	O
stderr_log_name	pointer
)	O
unlink	function
(	O
stderr_log_name	pointer
)	O
;	O
}	O
void	O
set_title	function
(	O
)	O
{	O
memset	function
(	O
global_buf	pointer
,	O
' '	O
,	O
tty_columns	int
)	O
;	O
memcpy	function
(	O
global_buf	pointer
,	O
title_text	pointer
,	O
min	O
(	O
tty_columns	int
,	O
(	O
int	O
)	O
strlen	function
(	O
title_text	pointer
)	O
)	O
)	O
;	O
tty_colors	function
(	O
TitleBrightness	O
,	O
TitleForeground	O
,	O
TitleBackground	O
)	O
;	O
window_goto	function
(	O
title_window	pointer
,	O
0	int
,	O
0	int
)	O
;	O
window_puts	function
(	O
title_window	pointer
,	O
global_buf	pointer
,	O
tty_columns	int
)	O
;	O
}	O
void	O
set_header	function
(	O
)	O
{	O
memset	function
(	O
global_buf	pointer
,	O
' '	O
,	O
tty_columns	int
)	O
;	O
memcpy	function
(	O
global_buf	pointer
+	O
2	int
,	O
header_text	array
,	O
min	O
(	O
tty_columns	int
-	O
2	int
,	O
(	O
int	O
)	O
strlen	function
(	O
header_text	array
)	O
)	O
)	O
;	O
tty_colors	function
(	O
HeaderBrightness	O
,	O
HeaderForeground	O
,	O
HeaderBackground	O
)	O
;	O
window_goto	function
(	O
header_window	pointer
,	O
0	int
,	O
0	int
)	O
;	O
window_puts	function
(	O
header_window	pointer
,	O
global_buf	pointer
,	O
tty_columns	int
)	O
;	O
}	O
void	O
set_status	function
(	O
what	pointer
)	O
char	O
*	O
what	pointer
;	O
{	O
memset	function
(	O
global_buf	pointer
,	O
' '	O
,	O
tty_columns	int
)	O
;	O
if	O
(	O
what	pointer
)	O
memcpy	function
(	O
global_buf	pointer
,	O
what	pointer
,	O
min	O
(	O
tty_columns	int
,	O
(	O
int	O
)	O
strlen	function
(	O
what	pointer
)	O
)	O
)	O
;	O
else	O
memcpy	function
(	O
global_buf	pointer
,	O
help	pointer
,	O
min	O
(	O
tty_columns	int
,	O
(	O
int	O
)	O
strlen	function
(	O
help	pointer
)	O
)	O
)	O
;	O
tty_colors	function
(	O
StatusBrightness	O
,	O
StatusForeground	O
,	O
StatusBackground	O
)	O
;	O
window_goto	function
(	O
status_window	pointer
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
tty_columns	int
<	O
(	O
int	O
)	O
(	O
(	O
sizeof	O
(	O
sigdesc	array
[	O
0	int
]	O
.	O
signame	array
)	O
-	O
1	int
)	O
+	O
1	int
)	O
)	O
window_puts	function
(	O
status_window	pointer
,	O
global_buf	pointer
,	O
tty_columns	int
)	O
;	O
else	O
{	O
global_buf	pointer
[	O
tty_columns	int
-	O
1	int
-	O
(	O
sizeof	O
(	O
sigdesc	array
[	O
0	int
]	O
.	O
signame	array
)	O
-	O
1	int
)	O
-	O
1	int
]	O
=	O
' '	O
;	O
window_puts	function
(	O
status_window	pointer
,	O
global_buf	pointer
,	O
tty_columns	int
-	O
(	O
sizeof	O
(	O
sigdesc	array
[	O
0	int
]	O
.	O
signame	array
)	O
-	O
1	int
)	O
-	O
1	int
)	O
;	O
}	O
}	O
void	O
set_signal	function
(	O
index	function
)	O
int	O
index	function
;	O
{	O
int	O
i	int
,	O
len	int
=	O
sizeof	O
(	O
sigdesc	array
[	O
0	int
]	O
.	O
signame	array
)	O
-	O
1	int
;	O
if	O
(	O
index	function
>=	O
0	int
)	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
(	O
int	O
)	O
(	O
sizeof	O
(	O
sigdesc	array
)	O
/	O
sizeof	O
(	O
xsignal_t	struct
)	O
)	O
;	O
i	int
++	O
)	O
if	O
(	O
sigdesc	array
[	O
i	int
]	O
.	O
signal	function
==	O
index	function
)	O
{	O
signal_type	int
=	O
i	int
;	O
break	O
;	O
}	O
if	O
(	O
tty_columns	int
>	O
len	int
)	O
{	O
tty_colors	function
(	O
StatusBrightness	O
,	O
WHITE	int
,	O
StatusBackground	O
)	O
;	O
window_goto	function
(	O
status_window	pointer
,	O
0	int
,	O
tty_columns	int
-	O
len	int
-	O
1	int
)	O
;	O
window_puts	function
(	O
status_window	pointer
,	O
sigdesc	array
[	O
signal_type	int
]	O
.	O
signame	array
,	O
len	int
)	O
;	O
window_putc	function
(	O
status_window	pointer
,	O
' '	O
)	O
;	O
}	O
window_goto	function
(	O
status_window	pointer
,	O
0	int
,	O
tty_columns	int
-	O
1	int
)	O
;	O
}	O
void	O
report_undefined_key	function
(	O
)	O
{	O
char	O
*	O
prev	pointer
=	O
tty_get_previous_key_seq	function
(	O
)	O
;	O
size_t	long
length	long
=	O
strlen	function
(	O
prev	pointer
)	O
;	O
if	O
(	O
length	long
&&	O
(	O
prev	pointer
[	O
length	long
-	O
1	int
]	O
!=	O
key_INTERRUPT	O
)	O
)	O
{	O
char	O
*	O
str	pointer
=	O
(	O
char	O
*	O
)	O
tty_key_machine2human	function
(	O
tty_get_previous_key_seq	function
(	O
)	O
)	O
;	O
char	O
*	O
buf	pointer
=	O
xmalloc	function
(	O
128	int
+	O
strlen	function
(	O
str	pointer
)	O
)	O
;	O
sprintf	function
(	O
buf	pointer
,	O
"%s: not defined."	pointer
,	O
str	pointer
)	O
;	O
memset	function
(	O
global_buf	pointer
,	O
' '	O
,	O
tty_columns	int
)	O
;	O
memcpy	function
(	O
global_buf	pointer
,	O
buf	pointer
,	O
min	O
(	O
tty_columns	int
,	O
(	O
int	O
)	O
strlen	function
(	O
buf	pointer
)	O
)	O
)	O
;	O
xfree	function
(	O
buf	pointer
)	O
;	O
tty_colors	function
(	O
ON	int
,	O
WHITE	int
,	O
RED	int
)	O
;	O
window_goto	function
(	O
status_window	pointer
,	O
0	int
,	O
0	int
)	O
;	O
window_puts	function
(	O
status_window	pointer
,	O
global_buf	pointer
,	O
tty_columns	int
)	O
;	O
tty_beep	function
(	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
sleep	function
(	O
1	int
)	O
;	O
}	O
else	O
tty_beep	function
(	O
)	O
;	O
set_status	function
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
set_signal	function
(	O
-	O
1	int
)	O
;	O
tty_update	function
(	O
)	O
;	O
}	O
void	O
free_ps_list	function
(	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
processes	int
;	O
i	int
++	O
)	O
{	O
xfree	function
(	O
ps_vect	pointer
[	O
i	int
]	O
)	O
;	O
ps_vect	pointer
[	O
i	int
]	O
=	O
NULL	O
;	O
}	O
}	O
char	O
*	O
read_ps_line	function
(	O
ps_output	pointer
,	O
line	pointer
)	O
FILE	struct
*	O
ps_output	pointer
;	O
char	O
*	O
line	pointer
;	O
{	O
int	O
c	int
;	O
char	O
*	O
ok	pointer
;	O
size_t	long
lastchar	long
;	O
ok	pointer
=	O
fgets	function
(	O
line	pointer
,	O
MAX_LINE	int
-	O
1	int
,	O
ps_output	pointer
)	O
;	O
if	O
(	O
ok	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
line	pointer
[	O
lastchar	long
=	O
strlen	function
(	O
line	pointer
)	O
-	O
1	int
]	O
==	O
'\n'	O
)	O
line	pointer
[	O
lastchar	long
]	O
=	O
0	int
;	O
else	O
while	O
(	O
(	O
c	int
=	O
fgetc	function
(	O
ps_output	pointer
)	O
)	O
!=	O
'\n'	O
&&	O
c	int
!=	O
EOF	O
)	O
;	O
return	O
ok	pointer
;	O
}	O
int	O
get_PID_index	function
(	O
ps_output	pointer
)	O
FILE	struct
*	O
ps_output	pointer
;	O
{	O
int	O
i	int
;	O
char	O
*	O
h	pointer
=	O
header_text	array
;	O
if	O
(	O
read_ps_line	function
(	O
ps_output	pointer
,	O
header_text	array
)	O
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
strstr	function
(	O
header_text	array
,	O
"PID"	pointer
)	O
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
;	O
i	int
++	O
)	O
{	O
while	O
(	O
isspace	function
(	O
(	O
int	O
)	O
*	O
h	pointer
)	O
)	O
h	pointer
++	O
;	O
if	O
(	O
memcmp	function
(	O
h	pointer
,	O
"PID"	pointer
,	O
3	int
)	O
==	O
0	int
)	O
return	O
i	int
;	O
while	O
(	O
!	O
isspace	function
(	O
(	O
int	O
)	O
*	O
h	pointer
)	O
)	O
h	pointer
++	O
;	O
}	O
}	O
int	O
kill_process	function
(	O
process_index	int
)	O
int	O
process_index	int
;	O
{	O
int	O
i	int
;	O
char	O
*	O
p	pointer
;	O
char	O
pidstr	array
[	O
128	int
]	O
;	O
int	O
pidnum	int
;	O
assert	O
(	O
process_index	int
<	O
processes	int
)	O
;	O
p	pointer
=	O
ps_vect	pointer
[	O
process_index	int
]	O
;	O
assert	O
(	O
p	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
PID_index	int
;	O
i	int
++	O
)	O
{	O
while	O
(	O
isspace	function
(	O
(	O
int	O
)	O
*	O
p	pointer
)	O
)	O
p	pointer
++	O
;	O
while	O
(	O
!	O
isspace	function
(	O
(	O
int	O
)	O
*	O
p	pointer
)	O
)	O
p	pointer
++	O
;	O
}	O
i	int
=	O
0	int
;	O
while	O
(	O
isspace	function
(	O
(	O
int	O
)	O
*	O
p	pointer
)	O
)	O
p	pointer
++	O
;	O
while	O
(	O
!	O
isspace	function
(	O
(	O
int	O
)	O
*	O
p	pointer
)	O
)	O
pidstr	array
[	O
i	int
++	O
]	O
=	O
*	O
p	pointer
++	O
;	O
pidstr	array
[	O
i	int
]	O
=	O
0	int
;	O
pidnum	int
=	O
atoi	function
(	O
pidstr	array
)	O
;	O
if	O
(	O
pidnum	int
)	O
return	O
!	O
kill	function
(	O
atoi	function
(	O
pidstr	array
)	O
,	O
sigdesc	array
[	O
signal_type	int
]	O
.	O
signal	function
)	O
;	O
else	O
return	O
-	O
1	int
;	O
}	O
void	O
build_ps_list	function
(	O
ps_output	pointer
)	O
FILE	struct
*	O
ps_output	pointer
;	O
{	O
int	O
i	int
;	O
char	O
line	pointer
[	O
MAX_LINE	int
]	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
read_ps_line	function
(	O
ps_output	pointer
,	O
line	pointer
)	O
;	O
i	int
++	O
)	O
{	O
ps_vect	pointer
=	O
(	O
char	O
*	O
*	O
)	O
xrealloc	function
(	O
ps_vect	pointer
,	O
(	O
i	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
ps_vect	pointer
[	O
i	int
]	O
=	O
xstrdup	function
(	O
line	pointer
)	O
;	O
}	O
processes	int
=	O
i	int
;	O
}	O
void	O
update_process	function
(	O
process	int
,	O
update_color	int
)	O
int	O
process	int
,	O
update_color	int
;	O
{	O
assert	O
(	O
process	int
<	O
processes	int
)	O
;	O
int	O
ps_length	int
,	O
visible_length	int
,	O
offset	long
;	O
ps_length	int
=	O
(	O
int	O
)	O
strlen	function
(	O
ps_vect	pointer
[	O
process	int
]	O
)	O
;	O
visible_length	int
=	O
(	O
tty_columns	int
-	O
2	int
)	O
;	O
if	O
(	O
visible_length	int
>=	O
ps_length	int
)	O
offset	long
=	O
0	int
;	O
else	O
offset	long
=	O
min	O
(	O
horizontal_offset	int
,	O
(	O
ps_length	int
-	O
visible_length	int
)	O
)	O
;	O
memset	function
(	O
global_buf	pointer
,	O
' '	O
,	O
tty_columns	int
)	O
;	O
memcpy	function
(	O
global_buf	pointer
+	O
2	int
,	O
(	O
ps_vect	pointer
[	O
process	int
]	O
+	O
offset	long
)	O
,	O
min	O
(	O
visible_length	int
,	O
strlen	function
(	O
ps_vect	pointer
[	O
process	int
]	O
+	O
offset	long
)	O
)	O
)	O
;	O
global_buf	pointer
[	O
0	int
]	O
=	O
(	O
process	int
==	O
current_process	int
)	O
?	O
'>'	O
:	O
' '	O
;	O
global_buf	pointer
[	O
1	int
]	O
=	O
' '	O
;	O
if	O
(	O
update_color	int
)	O
{	O
tty_brightness	function
(	O
ScreenBrightness	O
)	O
;	O
if	O
(	O
process	int
==	O
current_process	int
)	O
{	O
tty_foreground	function
(	O
ScreenBackground	O
)	O
;	O
tty_background	function
(	O
ScreenForeground	O
)	O
;	O
}	O
else	O
{	O
tty_foreground	function
(	O
ScreenForeground	O
)	O
;	O
tty_background	function
(	O
ScreenBackground	O
)	O
;	O
}	O
}	O
window_goto	function
(	O
processes_window	pointer
,	O
process	int
-	O
first_on_screen	int
,	O
0	int
)	O
;	O
window_puts	function
(	O
processes_window	pointer
,	O
global_buf	pointer
,	O
tty_columns	int
)	O
;	O
window_goto	function
(	O
status_window	pointer
,	O
0	int
,	O
tty_columns	int
-	O
1	int
)	O
;	O
}	O
void	O
update_all	function
(	O
)	O
{	O
int	O
i	int
;	O
tty_colors	function
(	O
ScreenBrightness	O
,	O
ScreenForeground	O
,	O
ScreenBackground	O
)	O
;	O
if	O
(	O
tty_lines	int
<=	O
4	int
)	O
return	O
;	O
window_goto	function
(	O
processes_window	pointer
,	O
0	int
,	O
0	int
)	O
;	O
for	O
(	O
i	int
=	O
first_on_screen	int
;	O
i	int
<	O
processes	int
&&	O
(	O
i	int
-	O
first_on_screen	int
<	O
tty_lines	int
-	O
3	int
)	O
;	O
i	int
++	O
)	O
if	O
(	O
i	int
!=	O
current_process	int
)	O
update_process	function
(	O
i	int
,	O
OFF	int
)	O
;	O
else	O
window_goto	function
(	O
processes_window	pointer
,	O
i	int
-	O
first_on_screen	int
,	O
0	int
)	O
;	O
update_process	function
(	O
current_process	int
,	O
ON	int
)	O
;	O
tty_colors	function
(	O
ScreenBrightness	O
,	O
ScreenForeground	O
,	O
ScreenBackground	O
)	O
;	O
memset	function
(	O
global_buf	pointer
,	O
' '	O
,	O
tty_columns	int
)	O
;	O
for	O
(	O
;	O
i	int
-	O
first_on_screen	int
<	O
tty_lines	int
-	O
3	int
;	O
i	int
++	O
)	O
{	O
window_goto	function
(	O
processes_window	pointer
,	O
i	int
-	O
first_on_screen	int
,	O
0	int
)	O
;	O
window_puts	function
(	O
processes_window	pointer
,	O
global_buf	pointer
,	O
tty_columns	int
)	O
;	O
}	O
window_goto	function
(	O
status_window	pointer
,	O
0	int
,	O
tty_columns	int
-	O
1	int
)	O
;	O
}	O
void	O
clean_up	function
(	O
)	O
{	O
tty_end_cursorapp	function
(	O
)	O
;	O
tty_end	function
(	O
NULL	O
)	O
;	O
remove_log	function
(	O
)	O
;	O
}	O
void	O
fatal	function
(	O
postmsg	pointer
)	O
char	O
*	O
postmsg	pointer
;	O
{	O
clean_up	function
(	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: fatal error: %s.\n"	pointer
,	O
g_program	pointer
,	O
postmsg	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
int	O
ps	function
(	O
args	pointer
)	O
char	O
*	O
*	O
args	pointer
;	O
{	O
FILE	struct
*	O
stdout_log	pointer
=	O
NULL	O
,	O
*	O
stderr_log	pointer
=	O
NULL	O
;	O
int	O
stdout_log_fd	int
,	O
stderr_log_fd	int
;	O
remove_log	function
(	O
)	O
;	O
int	O
old_stdout	int
=	O
dup	function
(	O
1	int
)	O
;	O
int	O
old_stderr	int
=	O
dup	function
(	O
2	int
)	O
;	O
close	pointer
(	O
1	int
)	O
;	O
close	pointer
(	O
2	int
)	O
;	O
strcpy	function
(	O
stdout_log_name	pointer
,	O
stdout_log_template	pointer
)	O
;	O
stdout_log_fd	int
=	O
mkstemp	function
(	O
stdout_log_name	pointer
)	O
;	O
if	O
(	O
stdout_log_fd	int
!=	O
-	O
1	int
)	O
stdout_log	pointer
=	O
fdopen	function
(	O
stdout_log_fd	int
,	O
"w"	pointer
)	O
;	O
strcpy	function
(	O
stderr_log_name	pointer
,	O
stderr_log_template	pointer
)	O
;	O
stderr_log_fd	int
=	O
mkstemp	function
(	O
stderr_log_name	pointer
)	O
;	O
if	O
(	O
stderr_log_fd	int
!=	O
-	O
1	int
)	O
stderr_log	pointer
=	O
fdopen	function
(	O
stderr_log_fd	int
,	O
"w"	pointer
)	O
;	O
if	O
(	O
!	O
stdout_log	pointer
||	O
!	O
stderr_log	pointer
)	O
{	O
if	O
(	O
stdout_log	pointer
)	O
fclose	function
(	O
stdout_log	pointer
)	O
;	O
if	O
(	O
stderr_log	pointer
)	O
fclose	function
(	O
stderr_log	pointer
)	O
;	O
remove_log	function
(	O
)	O
;	O
dup	function
(	O
old_stdout	int
)	O
;	O
dup	function
(	O
old_stderr	int
)	O
;	O
close	pointer
(	O
old_stdout	int
)	O
;	O
close	pointer
(	O
old_stderr	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: cannot write temp file: %s.\n"	pointer
,	O
g_program	pointer
,	O
(	O
(	O
stdout_log	pointer
==	O
NULL	O
)	O
?	O
stdout_log_name	pointer
:	O
stderr_log_name	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
ps_cmd	pointer
)	O
xfree	function
(	O
ps_cmd	pointer
)	O
;	O
if	O
(	O
args	pointer
)	O
{	O
int	O
i	int
,	O
bytes	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
args	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
bytes	int
+=	O
1	int
+	O
strlen	function
(	O
args	pointer
[	O
i	int
]	O
)	O
;	O
ps_cmd	pointer
=	O
xmalloc	function
(	O
16	int
+	O
bytes	int
+	O
1	int
)	O
;	O
strcpy	function
(	O
ps_cmd	pointer
,	O
"ps"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
args	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
strcat	function
(	O
ps_cmd	pointer
,	O
" "	pointer
)	O
;	O
strcat	function
(	O
ps_cmd	pointer
,	O
args	pointer
[	O
i	int
]	O
)	O
;	O
}	O
}	O
else	O
ps_cmd	pointer
=	O
xstrdup	function
(	O
"ps"	pointer
)	O
;	O
if	O
(	O
system	function
(	O
ps_cmd	pointer
)	O
!=	O
0	int
)	O
{	O
fclose	function
(	O
stdout_log	pointer
)	O
;	O
fclose	function
(	O
stderr_log	pointer
)	O
;	O
remove_log	function
(	O
)	O
;	O
dup	function
(	O
old_stdout	int
)	O
;	O
dup	function
(	O
old_stderr	int
)	O
;	O
close	pointer
(	O
old_stdout	int
)	O
;	O
close	pointer
(	O
old_stderr	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: invalid command line for ps(1).\n"	pointer
,	O
g_program	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: the command was: `%s'.\n"	pointer
,	O
g_program	pointer
,	O
ps_cmd	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: see the ps(1) man page for details.\n"	pointer
,	O
g_program	pointer
)	O
;	O
return	O
0	int
;	O
}	O
fclose	function
(	O
stdout_log	pointer
)	O
;	O
fclose	function
(	O
stderr_log	pointer
)	O
;	O
dup	function
(	O
old_stdout	int
)	O
;	O
dup	function
(	O
old_stderr	int
)	O
;	O
close	pointer
(	O
old_stdout	int
)	O
;	O
close	pointer
(	O
old_stderr	int
)	O
;	O
return	O
1	int
;	O
}	O
int	O
read_keys	function
(	O
keys	int
)	O
int	O
keys	int
;	O
{	O
char	O
*	O
contents	pointer
;	O
char	O
key_seq	pointer
[	O
80	int
]	O
;	O
int	O
i	int
,	O
j	int
,	O
need_conversion	int
;	O
for	O
(	O
i	int
=	O
keys	int
;	O
i	int
<	O
MAX_KEYS	int
;	O
i	int
++	O
)	O
{	O
configuration_getvarinfo	function
(	O
key_seq	pointer
,	O
&	O
contents	pointer
,	O
1	int
,	O
NO_SEEK	int
)	O
;	O
if	O
(	O
*	O
key_seq	pointer
==	O
0	int
)	O
break	O
;	O
if	O
(	O
*	O
key_seq	pointer
!=	O
'^'	O
)	O
{	O
char	O
*	O
key_seq_ptr	pointer
=	O
tty_get_symbol_key_seq	function
(	O
key_seq	pointer
)	O
;	O
if	O
(	O
key_seq_ptr	pointer
)	O
{	O
if	O
(	O
*	O
key_seq_ptr	pointer
==	O
'\0'	O
)	O
continue	O
;	O
strcpy	function
(	O
key_seq	pointer
,	O
key_seq_ptr	pointer
)	O
;	O
need_conversion	int
=	O
0	int
;	O
}	O
else	O
{	O
need_conversion	int
=	O
1	int
;	O
}	O
}	O
else	O
need_conversion	int
=	O
1	int
;	O
if	O
(	O
contents	pointer
==	O
NULL	O
)	O
continue	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
BUILTIN_OPERATIONS	int
;	O
j	int
++	O
)	O
if	O
(	O
strcmp	function
(	O
contents	pointer
,	O
built_in	array
[	O
j	int
]	O
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
j	int
<	O
BUILTIN_OPERATIONS	int
)	O
{	O
if	O
(	O
!	O
need_conversion	int
||	O
tty_key_human2machine	function
(	O
(	O
unsigned	O
char	O
*	O
)	O
key_seq	pointer
)	O
)	O
tty_key_list_insert	function
(	O
(	O
unsigned	O
char	O
*	O
)	O
key_seq	pointer
,	O
built_in	array
[	O
j	int
]	O
)	O
;	O
}	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: invalid built-in operation: %s.\n"	pointer
,	O
g_program	pointer
,	O
contents	pointer
)	O
;	O
}	O
return	O
i	int
;	O
}	O
void	O
resize	function
(	O
resize_required	int
)	O
int	O
resize_required	int
;	O
{	O
int	O
display_title	int
=	O
OFF	int
;	O
int	O
display_header	int
=	O
OFF	int
;	O
int	O
display_processes	int
=	O
OFF	int
;	O
int	O
old_tty_lines	int
=	O
tty_lines	int
;	O
int	O
old_tty_columns	int
=	O
tty_columns	int
;	O
tty_resize	function
(	O
)	O
;	O
if	O
(	O
!	O
resize_required	int
)	O
if	O
(	O
tty_lines	int
==	O
old_tty_lines	int
&&	O
tty_columns	int
==	O
old_tty_columns	int
)	O
return	O
;	O
if	O
(	O
LinuxConsole	int
)	O
screen	pointer
=	O
xrealloc	function
(	O
screen	pointer
,	O
4	int
+	O
tty_columns	int
*	O
tty_lines	int
*	O
2	int
)	O
;	O
global_buf	pointer
=	O
xrealloc	function
(	O
global_buf	pointer
,	O
tty_columns	int
+	O
1	int
)	O
;	O
current_process	int
=	O
min	O
(	O
current_process	int
,	O
processes	int
-	O
1	int
)	O
;	O
first_on_screen	int
=	O
max	O
(	O
0	int
,	O
current_process	int
-	O
(	O
tty_lines	int
-	O
3	int
)	O
+	O
1	int
)	O
;	O
assert	O
(	O
first_on_screen	int
>=	O
0	int
)	O
;	O
window_resize	function
(	O
status_window	pointer
,	O
0	int
,	O
tty_lines	int
-	O
1	int
,	O
1	int
,	O
tty_columns	int
)	O
;	O
if	O
(	O
tty_lines	int
>=	O
2	int
)	O
display_title	int
=	O
ON	int
;	O
if	O
(	O
tty_lines	int
>=	O
3	int
)	O
display_header	int
=	O
ON	int
;	O
if	O
(	O
tty_lines	int
>=	O
5	int
)	O
{	O
display_processes	int
=	O
ON	int
;	O
if	O
(	O
StartupScrollStep	int
<=	O
0	int
||	O
StartupScrollStep	int
>=	O
(	O
tty_lines	int
-	O
3	int
)	O
-	O
1	int
)	O
scroll_step	int
=	O
(	O
tty_lines	int
-	O
3	int
)	O
/	O
2	int
;	O
else	O
scroll_step	int
=	O
StartupScrollStep	int
;	O
}	O
window_resize	function
(	O
title_window	pointer
,	O
0	int
,	O
0	int
,	O
display_title	int
?	O
1	int
:	O
0	int
,	O
tty_columns	int
)	O
;	O
window_resize	function
(	O
header_window	pointer
,	O
0	int
,	O
1	int
,	O
display_header	int
?	O
1	int
:	O
0	int
,	O
tty_columns	int
)	O
;	O
window_resize	function
(	O
processes_window	pointer
,	O
0	int
,	O
2	int
,	O
display_processes	int
?	O
(	O
tty_lines	int
-	O
3	int
)	O
:	O
0	int
,	O
tty_columns	int
)	O
;	O
}	O
void	O
refresh	function
(	O
signum	int
)	O
int	O
signum	int
;	O
{	O
current_process	int
=	O
min	O
(	O
current_process	int
,	O
processes	int
-	O
1	int
)	O
;	O
resize	function
(	O
0	int
)	O
;	O
if	O
(	O
signum	int
==	O
SIGCONT	int
)	O
{	O
tty_set_mode	function
(	O
TTY_NONCANONIC	int
)	O
;	O
tty_defaults	function
(	O
)	O
;	O
}	O
if	O
(	O
tty_lines	int
==	O
4	int
)	O
{	O
tty_defaults	function
(	O
)	O
;	O
tty_clear	function
(	O
)	O
;	O
}	O
set_title	function
(	O
)	O
;	O
set_header	function
(	O
)	O
;	O
set_status	function
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
set_signal	function
(	O
-	O
1	int
)	O
;	O
update_all	function
(	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
if	O
(	O
signum	int
==	O
SIGCONT	int
)	O
tty_update_title	function
(	O
ps_cmd	pointer
)	O
;	O
}	O
void	O
hide	function
(	O
)	O
{	O
tty_set_mode	function
(	O
TTY_CANONIC	int
)	O
;	O
tty_defaults	function
(	O
)	O
;	O
tty_put_screen	function
(	O
screen	pointer
)	O
;	O
}	O
void	O
clock_refresh	function
(	O
)	O
{	O
}	O
void	O
usage	function
(	O
)	O
{	O
printf	function
(	O
"usage: %s [-hvilcbp]\n"	pointer
,	O
g_program	pointer
)	O
;	O
printf	function
(	O
" -h         print this help message\n"	pointer
)	O
;	O
printf	function
(	O
" -v         print the version number\n"	pointer
)	O
;	O
printf	function
(	O
" -c         use ANSI colors\n"	pointer
)	O
;	O
printf	function
(	O
" -b         don't use ANSI colors\n"	pointer
)	O
;	O
printf	function
(	O
" -l         don't use the last screen character\n"	pointer
)	O
;	O
printf	function
(	O
" -p         pass the remaining arguments to ps(1)\n"	pointer
)	O
;	O
}	O
int	O
main	function
(	O
argc	int
,	O
argv	array
)	O
int	O
argc	int
;	O
char	O
*	O
argv	array
[	O
]	O
;	O
{	O
char	O
*	O
tmp	pointer
;	O
int	O
key	int
,	O
keys	int
;	O
tty_key_t	struct
*	O
ks	pointer
;	O
FILE	struct
*	O
stdout_log	pointer
;	O
int	O
repeat_count	int
;	O
char	O
*	O
*	O
arguments	pointer
;	O
int	O
i	int
,	O
no_of_arguments	int
,	O
exit_code	int
=	O
0	int
;	O
int	O
need_update	int
,	O
need_update_all	int
,	O
old_current_process	int
;	O
int	O
c	int
,	O
ansi_colors	int
=	O
-	O
1	int
,	O
use_last_screen_character	int
=	O
ON	int
;	O
setlocale	function
(	O
LC_ALL	O
,	O
""	pointer
)	O
;	O
signals_init	function
(	O
)	O
;	O
program_name	pointer
=	O
g_program	pointer
=	O
argv	array
[	O
0	int
]	O
;	O
g_home	pointer
=	O
getenv	function
(	O
"HOME"	pointer
)	O
;	O
if	O
(	O
g_home	pointer
==	O
NULL	O
)	O
g_home	pointer
=	O
"."	pointer
;	O
compute_directories	function
(	O
)	O
;	O
get_login_name	function
(	O
)	O
;	O
if	O
(	O
getenv	function
(	O
"COLORTERM"	pointer
)	O
!=	O
NULL	O
)	O
ansi_colors	int
=	O
ON	int
;	O
while	O
(	O
(	O
c	int
=	O
getopt	function
(	O
argc	int
,	O
argv	array
,	O
"hvcblp"	pointer
)	O
)	O
!=	O
-	O
1	int
)	O
switch	O
(	O
c	int
)	O
{	O
case	O
'h'	O
:	O
usage	function
(	O
)	O
;	O
return	O
0	int
;	O
case	O
'v'	O
:	O
printf	function
(	O
"%s %s\n"	pointer
,	O
PRODUCT	pointer
,	O
VERSION	pointer
)	O
;	O
return	O
0	int
;	O
case	O
'c'	O
:	O
ansi_colors	int
=	O
ON	int
;	O
break	O
;	O
case	O
'b'	O
:	O
ansi_colors	int
=	O
OFF	int
;	O
break	O
;	O
case	O
'l'	O
:	O
use_last_screen_character	int
=	O
OFF	int
;	O
break	O
;	O
case	O
'p'	O
:	O
goto	O
done	O
;	O
case	O
'?'	O
:	O
return	O
1	int
;	O
default	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: unknown error\n"	pointer
,	O
g_program	pointer
)	O
;	O
return	O
1	int
;	O
}	O
done	O
:	O
if	O
(	O
optind	int
<	O
argc	int
)	O
{	O
no_of_arguments	int
=	O
argc	int
-	O
optind	int
;	O
arguments	pointer
=	O
(	O
char	O
*	O
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
no_of_arguments	int
+	O
1	int
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
no_of_arguments	int
;	O
i	int
++	O
)	O
arguments	pointer
[	O
i	int
]	O
=	O
argv	array
[	O
optind	int
++	O
]	O
;	O
arguments	pointer
[	O
i	int
]	O
=	O
NULL	O
;	O
}	O
else	O
arguments	pointer
=	O
NULL	O
;	O
title_text	pointer
=	O
xmalloc	function
(	O
strlen	function
(	O
PRODUCT	pointer
)	O
+	O
strlen	function
(	O
VERSION	pointer
)	O
+	O
64	int
)	O
;	O
sprintf	function
(	O
title_text	pointer
,	O
" %s %s - Process Viewer/Killer"	pointer
,	O
PRODUCT	pointer
,	O
VERSION	pointer
)	O
;	O
tty_init	function
(	O
TTY_FULL_INPUT	int
)	O
;	O
common_configuration_init	function
(	O
)	O
;	O
use_section	function
(	O
"[GITPS-Keys]"	pointer
)	O
;	O
keys	int
=	O
read_keys	function
(	O
0	int
)	O
;	O
configuration_end	function
(	O
)	O
;	O
specific_configuration_init	function
(	O
)	O
;	O
use_section	function
(	O
"[Setup]"	pointer
)	O
;	O
temporary_directory	pointer
=	O
getenv	function
(	O
"TMPDIR"	pointer
)	O
;	O
if	O
(	O
temporary_directory	pointer
==	O
NULL	O
)	O
temporary_directory	pointer
=	O
"/tmp"	pointer
;	O
if	O
(	O
ansi_colors	int
==	O
-	O
1	int
)	O
AnsiColors	int
=	O
get_flag_var	function
(	O
"AnsiColors"	pointer
,	O
OFF	int
)	O
;	O
else	O
AnsiColors	int
=	O
ansi_colors	int
;	O
if	O
(	O
use_last_screen_character	int
)	O
UseLastScreenChar	int
=	O
get_flag_var	function
(	O
"UseLastScreenChar"	pointer
,	O
OFF	int
)	O
;	O
else	O
UseLastScreenChar	int
=	O
OFF	int
;	O
tty_set_last_char_flag	function
(	O
UseLastScreenChar	int
)	O
;	O
StartupScrollStep	int
=	O
get_int_var	function
(	O
"StartupScrollStep"	pointer
,	O
(	O
tty_lines	int
-	O
3	int
)	O
/	O
2	int
)	O
;	O
use_section	function
(	O
"[GITPS-Setup]"	pointer
)	O
;	O
help	pointer
=	O
get_string_var	function
(	O
"Help"	pointer
,	O
""	pointer
)	O
;	O
RefreshAfterKill	int
=	O
get_flag_var	function
(	O
"RefreshAfterKill"	pointer
,	O
ON	int
)	O
;	O
use_section	function
(	O
AnsiColors	int
?	O
color_section	array
:	O
monochrome_section	array
)	O
;	O
get_colorset_var	function
(	O
PSColors	array
,	O
PSFields	array
,	O
PS_FIELDS	int
)	O
;	O
use_section	function
(	O
"[GITPS-Keys]"	pointer
)	O
;	O
keys	int
=	O
read_keys	function
(	O
keys	int
)	O
;	O
if	O
(	O
keys	int
==	O
MAX_KEYS	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: too many key sequences; only %d are allowed.\n"	pointer
,	O
g_program	pointer
,	O
MAX_KEYS	int
)	O
;	O
configuration_end	function
(	O
)	O
;	O
stdout_log_template	pointer
=	O
xmalloc	function
(	O
32	int
+	O
strlen	function
(	O
temporary_directory	pointer
)	O
+	O
1	int
)	O
;	O
stderr_log_template	pointer
=	O
xmalloc	function
(	O
32	int
+	O
strlen	function
(	O
temporary_directory	pointer
)	O
+	O
1	int
)	O
;	O
stdout_log_name	pointer
=	O
xmalloc	function
(	O
32	int
+	O
strlen	function
(	O
temporary_directory	pointer
)	O
+	O
1	int
)	O
;	O
stderr_log_name	pointer
=	O
xmalloc	function
(	O
32	int
+	O
strlen	function
(	O
temporary_directory	pointer
)	O
+	O
1	int
)	O
;	O
sprintf	function
(	O
stdout_log_template	pointer
,	O
"%s/gitps.1.XXXXXX"	pointer
,	O
temporary_directory	pointer
)	O
;	O
sprintf	function
(	O
stderr_log_template	pointer
,	O
"%s/gitps.2.XXXXXX"	pointer
,	O
temporary_directory	pointer
)	O
;	O
if	O
(	O
ps	function
(	O
arguments	pointer
)	O
==	O
0	int
)	O
return	O
1	int
;	O
tty_start_cursorapp	function
(	O
)	O
;	O
title_window	pointer
=	O
window_init	function
(	O
)	O
;	O
header_window	pointer
=	O
window_init	function
(	O
)	O
;	O
processes_window	pointer
=	O
window_init	function
(	O
)	O
;	O
status_window	pointer
=	O
window_init	function
(	O
)	O
;	O
resize	function
(	O
0	int
)	O
;	O
tty_get_screen	function
(	O
screen	pointer
)	O
;	O
tty_set_mode	function
(	O
TTY_NONCANONIC	int
)	O
;	O
tty_defaults	function
(	O
)	O
;	O
signal_handlers	function
(	O
ON	int
)	O
;	O
first_on_screen	int
=	O
current_process	int
=	O
0	int
;	O
tty_update_title	function
(	O
ps_cmd	pointer
)	O
;	O
set_signal	function
(	O
SIGTERM	int
)	O
;	O
restart	O
:	O
stdout_log	pointer
=	O
fopen	function
(	O
stdout_log_name	pointer
,	O
"r"	pointer
)	O
;	O
remove_log	function
(	O
)	O
;	O
if	O
(	O
(	O
PID_index	int
=	O
get_PID_index	function
(	O
stdout_log	pointer
)	O
)	O
==	O
-	O
1	int
)	O
{	O
exit_code	int
=	O
1	int
;	O
goto	O
end	O
;	O
}	O
free_ps_list	function
(	O
)	O
;	O
build_ps_list	function
(	O
stdout_log	pointer
)	O
;	O
fclose	function
(	O
stdout_log	pointer
)	O
;	O
refresh	function
(	O
0	int
)	O
;	O
while	O
(	O
1	int
)	O
{	O
while	O
(	O
(	O
ks	pointer
=	O
tty_get_key	function
(	O
&	O
repeat_count	int
)	O
)	O
==	O
NULL	O
)	O
report_undefined_key	function
(	O
)	O
;	O
set_status	function
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
set_signal	function
(	O
-	O
1	int
)	O
;	O
key	int
=	O
(	O
(	O
char	O
*	O
)	O
ks	pointer
->	O
aux_data	pointer
-	O
(	O
char	O
*	O
)	O
built_in	array
)	O
/	O
MAX_BUILTIN_NAME	int
;	O
switch	O
(	O
key	int
)	O
{	O
case	O
BUILTIN_previous_line	int
:	O
need_update_all	int
=	O
need_update	int
=	O
0	int
;	O
while	O
(	O
repeat_count	int
--	O
)	O
{	O
if	O
(	O
current_process	int
!=	O
0	int
)	O
current_process	int
--	O
;	O
else	O
break	O
;	O
if	O
(	O
current_process	int
+	O
1	int
==	O
first_on_screen	int
)	O
{	O
first_on_screen	int
=	O
max	O
(	O
0	int
,	O
first_on_screen	int
-	O
scroll_step	int
)	O
;	O
need_update_all	int
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
need_update	int
)	O
update_process	function
(	O
current_process	int
+	O
1	int
,	O
ON	int
)	O
;	O
need_update	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
need_update_all	int
)	O
update_all	function
(	O
)	O
;	O
else	O
if	O
(	O
need_update	int
)	O
update_process	function
(	O
current_process	int
,	O
ON	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_next_line	int
:	O
need_update_all	int
=	O
need_update	int
=	O
0	int
;	O
while	O
(	O
repeat_count	int
--	O
)	O
{	O
if	O
(	O
current_process	int
<	O
processes	int
-	O
1	int
)	O
current_process	int
++	O
;	O
else	O
break	O
;	O
if	O
(	O
current_process	int
-	O
first_on_screen	int
>=	O
tty_lines	int
-	O
3	int
)	O
{	O
first_on_screen	int
=	O
min	O
(	O
first_on_screen	int
+	O
scroll_step	int
,	O
processes	int
-	O
1	int
-	O
(	O
tty_lines	int
-	O
3	int
)	O
+	O
1	int
)	O
;	O
need_update_all	int
=	O
1	int
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
need_update	int
)	O
update_process	function
(	O
current_process	int
-	O
1	int
,	O
ON	int
)	O
;	O
need_update	int
=	O
1	int
;	O
}	O
if	O
(	O
need_update_all	int
)	O
update_all	function
(	O
)	O
;	O
else	O
if	O
(	O
need_update	int
)	O
update_process	function
(	O
current_process	int
,	O
ON	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_scroll_down	int
:	O
if	O
(	O
current_process	int
==	O
0	int
)	O
break	O
;	O
old_current_process	int
=	O
current_process	int
;	O
if	O
(	O
current_process	int
<	O
tty_lines	int
-	O
3	int
)	O
current_process	int
=	O
first_on_screen	int
=	O
0	int
;	O
else	O
{	O
current_process	int
-=	O
tty_lines	int
-	O
3	int
;	O
first_on_screen	int
=	O
max	O
(	O
0	int
,	O
first_on_screen	int
-	O
(	O
tty_lines	int
-	O
3	int
)	O
)	O
;	O
}	O
if	O
(	O
processes	int
>	O
tty_lines	int
-	O
3	int
)	O
update_all	function
(	O
)	O
;	O
else	O
{	O
update_process	function
(	O
old_current_process	int
,	O
ON	int
)	O
;	O
update_process	function
(	O
current_process	int
,	O
ON	int
)	O
;	O
}	O
break	O
;	O
case	O
BUILTIN_scroll_up	int
:	O
if	O
(	O
current_process	int
==	O
processes	int
-	O
1	int
)	O
break	O
;	O
old_current_process	int
=	O
current_process	int
;	O
if	O
(	O
processes	int
-	O
1	int
-	O
first_on_screen	int
<	O
tty_lines	int
-	O
3	int
)	O
current_process	int
=	O
processes	int
-	O
1	int
;	O
else	O
if	O
(	O
processes	int
-	O
1	int
-	O
current_process	int
<	O
tty_lines	int
-	O
3	int
)	O
{	O
current_process	int
=	O
processes	int
-	O
1	int
;	O
first_on_screen	int
=	O
processes	int
-	O
1	int
-	O
(	O
tty_lines	int
-	O
3	int
)	O
+	O
1	int
;	O
}	O
else	O
{	O
current_process	int
+=	O
tty_lines	int
-	O
3	int
;	O
first_on_screen	int
=	O
min	O
(	O
first_on_screen	int
+	O
tty_lines	int
-	O
3	int
,	O
(	O
processes	int
-	O
1	int
)	O
-	O
(	O
tty_lines	int
-	O
3	int
)	O
+	O
1	int
)	O
;	O
}	O
if	O
(	O
processes	int
>	O
tty_lines	int
-	O
3	int
)	O
update_all	function
(	O
)	O
;	O
else	O
{	O
update_process	function
(	O
old_current_process	int
,	O
ON	int
)	O
;	O
update_process	function
(	O
current_process	int
,	O
ON	int
)	O
;	O
}	O
break	O
;	O
case	O
BUILTIN_horizontal_scroll_left	int
:	O
horizontal_offset	int
--	O
;	O
if	O
(	O
horizontal_offset	int
<	O
0	int
)	O
horizontal_offset	int
=	O
0	int
;	O
update_all	function
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_horizontal_scroll_right	int
:	O
horizontal_offset	int
++	O
;	O
update_all	function
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_beginning_of_list	int
:	O
if	O
(	O
current_process	int
==	O
0	int
)	O
break	O
;	O
current_process	int
=	O
first_on_screen	int
=	O
0	int
;	O
update_all	function
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_end_of_list	int
:	O
if	O
(	O
current_process	int
==	O
processes	int
-	O
1	int
)	O
break	O
;	O
current_process	int
=	O
processes	int
-	O
1	int
;	O
first_on_screen	int
=	O
max	O
(	O
0	int
,	O
(	O
processes	int
-	O
1	int
)	O
-	O
(	O
tty_lines	int
-	O
3	int
)	O
+	O
1	int
)	O
;	O
update_all	function
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_next_signal	int
:	O
signal_type	int
++	O
;	O
signal_type	int
%=	O
sizeof	O
(	O
sigdesc	array
)	O
/	O
sizeof	O
(	O
xsignal_t	struct
)	O
;	O
set_signal	function
(	O
-	O
1	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGALRM	int
:	O
set_signal	function
(	O
SIGALRM	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGABRT	int
:	O
set_signal	function
(	O
SIGABRT	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGBUS	int
:	O
set_signal	function
(	O
SIGBUS	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGCHLD	int
:	O
set_signal	function
(	O
SIGCHLD	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGCLD	int
:	O
set_signal	function
(	O
SIGCLD	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGCONT	int
:	O
set_signal	function
(	O
SIGCONT	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGFPE	int
:	O
set_signal	function
(	O
SIGFPE	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGHUP	int
:	O
set_signal	function
(	O
SIGHUP	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGILL	int
:	O
set_signal	function
(	O
SIGILL	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGINT	int
:	O
set_signal	function
(	O
SIGINT	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGIO	int
:	O
set_signal	function
(	O
SIGIO	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGIOT	int
:	O
set_signal	function
(	O
SIGIOT	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGKILL	int
:	O
set_signal	function
(	O
SIGKILL	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGPIPE	int
:	O
set_signal	function
(	O
SIGPIPE	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGPOLL	int
:	O
set_signal	function
(	O
SIGPOLL	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGPROF	int
:	O
set_signal	function
(	O
SIGPROF	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGPWR	int
:	O
set_signal	function
(	O
SIGPWR	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGQUIT	int
:	O
set_signal	function
(	O
SIGQUIT	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGSEGV	int
:	O
set_signal	function
(	O
SIGSEGV	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGSTOP	int
:	O
set_signal	function
(	O
SIGSTOP	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGSYS	int
:	O
set_signal	function
(	O
SIGSYS	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGTERM	int
:	O
set_signal	function
(	O
SIGTERM	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGTRAP	int
:	O
set_signal	function
(	O
SIGTRAP	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGTSTP	int
:	O
set_signal	function
(	O
SIGTSTP	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGTTIN	int
:	O
set_signal	function
(	O
SIGTTIN	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGTTOU	int
:	O
set_signal	function
(	O
SIGTTOU	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGURG	int
:	O
set_signal	function
(	O
SIGURG	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGUSR1	int
:	O
set_signal	function
(	O
SIGUSR1	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGUSR2	int
:	O
set_signal	function
(	O
SIGUSR2	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGVTALRM	int
:	O
set_signal	function
(	O
SIGVTALRM	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGWINCH	int
:	O
set_signal	function
(	O
SIGWINCH	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGXCPU	int
:	O
set_signal	function
(	O
SIGXCPU	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGXFSZ	int
:	O
set_signal	function
(	O
SIGXFSZ	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGSTKFLT	int
:	O
set_signal	function
(	O
SIGSTKFLT	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_hard_refresh	int
:	O
tty_touch	function
(	O
)	O
;	O
case	O
BUILTIN_refresh	int
:	O
ps	function
(	O
arguments	pointer
)	O
;	O
goto	O
restart	O
;	O
case	O
BUILTIN_exit	int
:	O
goto	O
end	O
;	O
case	O
BUILTIN_kill_process	int
:	O
if	O
(	O
kill_process	function
(	O
current_process	int
)	O
)	O
{	O
if	O
(	O
RefreshAfterKill	int
)	O
{	O
struct	O
timespec	struct
tv	struct
;	O
tv	struct
.	O
tv_sec	long
=	O
0	int
;	O
tv	struct
.	O
tv_nsec	long
=	O
5	int
*	O
1000	int
*	O
1000	int
;	O
nanosleep	function
(	O
&	O
tv	struct
,	O
NULL	O
)	O
;	O
ps	function
(	O
arguments	pointer
)	O
;	O
goto	O
restart	O
;	O
}	O
}	O
else	O
{	O
int	O
e	int
=	O
errno	O
;	O
tty_beep	function
(	O
)	O
;	O
memset	function
(	O
global_buf	pointer
,	O
' '	O
,	O
tty_columns	int
)	O
;	O
tmp	pointer
=	O
xmalloc	function
(	O
16	int
+	O
strlen	function
(	O
(	O
e	int
==	O
EPERM	int
)	O
?	O
no_perm	array
:	O
no_proc	array
)	O
)	O
;	O
sprintf	function
(	O
tmp	pointer
,	O
"Error: %s"	pointer
,	O
(	O
e	int
==	O
EPERM	int
)	O
?	O
no_perm	array
:	O
no_proc	array
)	O
;	O
set_status	function
(	O
tmp	pointer
)	O
;	O
tty_update	function
(	O
)	O
;	O
xfree	function
(	O
tmp	pointer
)	O
;	O
errno	O
=	O
0	int
;	O
tty_get_key	function
(	O
NULL	O
)	O
;	O
set_status	function
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
set_signal	function
(	O
-	O
1	int
)	O
;	O
}	O
break	O
;	O
default	O
:	O
report_undefined_key	function
(	O
)	O
;	O
break	O
;	O
}	O
}	O
end	O
:	O
remove_log	function
(	O
)	O
;	O
tty_set_mode	function
(	O
TTY_CANONIC	int
)	O
;	O
tty_end	function
(	O
screen	pointer
)	O
;	O
return	O
exit_code	int
;	O
}	O
