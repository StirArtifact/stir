char	O
*	O
program_name	pointer
=	O
"elfedit"	pointer
;	O
static	O
long	O
archive_file_offset	long
;	O
static	O
unsigned	O
long	O
archive_file_size	long
;	O
static	O
Elf_Internal_Ehdr	struct
elf_header	struct
;	O
static	O
Elf32_External_Ehdr	struct
ehdr32	struct
;	O
static	O
Elf64_External_Ehdr	struct
ehdr64	struct
;	O
static	O
int	O
input_elf_machine	int
=	O
-	O
1	int
;	O
static	O
int	O
output_elf_machine	int
=	O
-	O
1	int
;	O
static	O
int	O
input_elf_type	int
=	O
-	O
1	int
;	O
static	O
int	O
output_elf_type	int
=	O
-	O
1	int
;	O
static	O
int	O
input_elf_osabi	int
=	O
-	O
1	int
;	O
static	O
int	O
output_elf_osabi	int
=	O
-	O
1	int
;	O
enum	O
elfclass	enum
{	O
ELF_CLASS_UNKNOWN	int
=	O
-	O
1	int
,	O
ELF_CLASS_NONE	int
=	O
ELFCLASSNONE	int
,	O
ELF_CLASS_32	int
=	O
ELFCLASS32	int
,	O
ELF_CLASS_64	int
=	O
ELFCLASS64	int
,	O
ELF_CLASS_BOTH	int
}	O
;	O
static	O
enum	O
elfclass	enum
input_elf_class	enum
=	O
ELF_CLASS_UNKNOWN	int
;	O
static	O
enum	O
elfclass	enum
output_elf_class	enum
=	O
ELF_CLASS_BOTH	int
;	O
static	O
unsigned	O
int	O
enable_x86_features	int
;	O
static	O
unsigned	O
int	O
disable_x86_features	int
;	O
static	O
int	O
update_gnu_property	function
(	O
const	O
char	O
*	O
file_name	pointer
,	O
FILE	struct
*	O
file	pointer
)	O
{	O
char	O
*	O
map	pointer
;	O
Elf_Internal_Phdr	struct
*	O
phdrs	pointer
;	O
struct	O
stat	struct
st_buf	struct
;	O
unsigned	O
int	O
i	pointer
;	O
int	O
ret	pointer
;	O
if	O
(	O
!	O
enable_x86_features	int
&&	O
!	O
disable_x86_features	int
)	O
return	O
0	int
;	O
if	O
(	O
elf_header	struct
.	O
e_machine	array
!=	O
EM_386	int
&&	O
elf_header	struct
.	O
e_machine	array
!=	O
EM_X86_64	int
)	O
{	O
error	function
(	O
_	O
(	O
"%s: Not an i386 nor x86-64 ELF file\n"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
fstat	function
(	O
fileno	function
(	O
file	pointer
)	O
,	O
&	O
st_buf	struct
)	O
<	O
0	int
)	O
{	O
error	function
(	O
_	O
(	O
"%s: stat () failed\n"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
return	O
1	int
;	O
}	O
map	pointer
=	O
mmap	function
(	O
NULL	O
,	O
st_buf	struct
.	O
st_size	long
,	O
PROT_READ	int
|	O
PROT_WRITE	int
,	O
MAP_SHARED	int
,	O
fileno	function
(	O
file	pointer
)	O
,	O
0	int
)	O
;	O
if	O
(	O
map	pointer
==	O
MAP_FAILED	O
)	O
{	O
error	function
(	O
_	O
(	O
"%s: mmap () failed\n"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
phdrs	pointer
=	O
xmalloc	function
(	O
elf_header	struct
.	O
e_phnum	array
*	O
sizeof	O
(	O
*	O
phdrs	pointer
)	O
)	O
;	O
if	O
(	O
elf_header	struct
.	O
e_ident	array
[	O
EI_CLASS	int
]	O
==	O
ELFCLASS32	int
)	O
{	O
Elf32_External_Phdr	struct
*	O
phdrs32	pointer
=	O
(	O
Elf32_External_Phdr	struct
*	O
)	O
(	O
map	pointer
+	O
elf_header	struct
.	O
e_phoff	array
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
elf_header	struct
.	O
e_phnum	array
;	O
i	pointer
++	O
)	O
{	O
phdrs	pointer
[	O
i	pointer
]	O
.	O
p_type	array
=	O
BYTE_GET	O
(	O
phdrs32	pointer
[	O
i	pointer
]	O
.	O
p_type	array
)	O
;	O
phdrs	pointer
[	O
i	pointer
]	O
.	O
p_offset	array
=	O
BYTE_GET	O
(	O
phdrs32	pointer
[	O
i	pointer
]	O
.	O
p_offset	array
)	O
;	O
phdrs	pointer
[	O
i	pointer
]	O
.	O
p_vaddr	array
=	O
BYTE_GET	O
(	O
phdrs32	pointer
[	O
i	pointer
]	O
.	O
p_vaddr	array
)	O
;	O
phdrs	pointer
[	O
i	pointer
]	O
.	O
p_paddr	array
=	O
BYTE_GET	O
(	O
phdrs32	pointer
[	O
i	pointer
]	O
.	O
p_paddr	array
)	O
;	O
phdrs	pointer
[	O
i	pointer
]	O
.	O
p_filesz	array
=	O
BYTE_GET	O
(	O
phdrs32	pointer
[	O
i	pointer
]	O
.	O
p_filesz	array
)	O
;	O
phdrs	pointer
[	O
i	pointer
]	O
.	O
p_memsz	array
=	O
BYTE_GET	O
(	O
phdrs32	pointer
[	O
i	pointer
]	O
.	O
p_memsz	array
)	O
;	O
phdrs	pointer
[	O
i	pointer
]	O
.	O
p_flags	array
=	O
BYTE_GET	O
(	O
phdrs32	pointer
[	O
i	pointer
]	O
.	O
p_flags	array
)	O
;	O
phdrs	pointer
[	O
i	pointer
]	O
.	O
p_align	array
=	O
BYTE_GET	O
(	O
phdrs32	pointer
[	O
i	pointer
]	O
.	O
p_align	array
)	O
;	O
}	O
}	O
else	O
{	O
Elf64_External_Phdr	struct
*	O
phdrs64	pointer
=	O
(	O
Elf64_External_Phdr	struct
*	O
)	O
(	O
map	pointer
+	O
elf_header	struct
.	O
e_phoff	array
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
elf_header	struct
.	O
e_phnum	array
;	O
i	pointer
++	O
)	O
{	O
phdrs	pointer
[	O
i	pointer
]	O
.	O
p_type	array
=	O
BYTE_GET	O
(	O
phdrs64	pointer
[	O
i	pointer
]	O
.	O
p_type	array
)	O
;	O
phdrs	pointer
[	O
i	pointer
]	O
.	O
p_offset	array
=	O
BYTE_GET	O
(	O
phdrs64	pointer
[	O
i	pointer
]	O
.	O
p_offset	array
)	O
;	O
phdrs	pointer
[	O
i	pointer
]	O
.	O
p_vaddr	array
=	O
BYTE_GET	O
(	O
phdrs64	pointer
[	O
i	pointer
]	O
.	O
p_vaddr	array
)	O
;	O
phdrs	pointer
[	O
i	pointer
]	O
.	O
p_paddr	array
=	O
BYTE_GET	O
(	O
phdrs64	pointer
[	O
i	pointer
]	O
.	O
p_paddr	array
)	O
;	O
phdrs	pointer
[	O
i	pointer
]	O
.	O
p_filesz	array
=	O
BYTE_GET	O
(	O
phdrs64	pointer
[	O
i	pointer
]	O
.	O
p_filesz	array
)	O
;	O
phdrs	pointer
[	O
i	pointer
]	O
.	O
p_memsz	array
=	O
BYTE_GET	O
(	O
phdrs64	pointer
[	O
i	pointer
]	O
.	O
p_memsz	array
)	O
;	O
phdrs	pointer
[	O
i	pointer
]	O
.	O
p_flags	array
=	O
BYTE_GET	O
(	O
phdrs64	pointer
[	O
i	pointer
]	O
.	O
p_flags	array
)	O
;	O
phdrs	pointer
[	O
i	pointer
]	O
.	O
p_align	array
=	O
BYTE_GET	O
(	O
phdrs64	pointer
[	O
i	pointer
]	O
.	O
p_align	array
)	O
;	O
}	O
}	O
ret	pointer
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
elf_header	struct
.	O
e_phnum	array
;	O
i	pointer
++	O
)	O
if	O
(	O
phdrs	pointer
[	O
i	pointer
]	O
.	O
p_type	array
==	O
PT_NOTE	int
)	O
{	O
size_t	long
offset	long
=	O
phdrs	pointer
[	O
i	pointer
]	O
.	O
p_offset	array
;	O
size_t	long
size	int
=	O
phdrs	pointer
[	O
i	pointer
]	O
.	O
p_filesz	array
;	O
size_t	long
align	long
=	O
phdrs	pointer
[	O
i	pointer
]	O
.	O
p_align	array
;	O
char	O
*	O
buf	pointer
=	O
map	pointer
+	O
offset	long
;	O
char	O
*	O
p	pointer
=	O
buf	pointer
;	O
while	O
(	O
p	pointer
<	O
buf	pointer
+	O
size	int
)	O
{	O
Elf_External_Note	struct
*	O
xnp	pointer
=	O
(	O
Elf_External_Note	struct
*	O
)	O
p	pointer
;	O
Elf_Internal_Note	struct
in	struct
;	O
if	O
(	O
offsetof	O
(	O
Elf_External_Note	struct
,	O
name	pointer
)	O
>	O
buf	pointer
-	O
p	pointer
+	O
size	int
)	O
{	O
ret	pointer
=	O
1	int
;	O
goto	O
out	O
;	O
}	O
in	struct
.	O
type	enum
=	O
BYTE_GET	O
(	O
xnp	pointer
->	O
type	enum
)	O
;	O
in	struct
.	O
namesz	array
=	O
BYTE_GET	O
(	O
xnp	pointer
->	O
namesz	array
)	O
;	O
in	struct
.	O
namedata	pointer
=	O
xnp	pointer
->	O
name	pointer
;	O
if	O
(	O
in	struct
.	O
namesz	array
>	O
buf	pointer
-	O
in	struct
.	O
namedata	pointer
+	O
size	int
)	O
{	O
ret	pointer
=	O
1	int
;	O
goto	O
out	O
;	O
}	O
in	struct
.	O
descsz	array
=	O
BYTE_GET	O
(	O
xnp	pointer
->	O
descsz	array
)	O
;	O
in	struct
.	O
descdata	pointer
=	O
p	pointer
+	O
ELF_NOTE_DESC_OFFSET	O
(	O
in	struct
.	O
namesz	array
,	O
align	long
)	O
;	O
in	struct
.	O
descpos	long
=	O
offset	long
+	O
(	O
in	struct
.	O
descdata	pointer
-	O
buf	pointer
)	O
;	O
if	O
(	O
in	struct
.	O
descsz	array
!=	O
0	int
&&	O
(	O
in	struct
.	O
descdata	pointer
>=	O
buf	pointer
+	O
size	int
||	O
in	struct
.	O
descsz	array
>	O
buf	pointer
-	O
in	struct
.	O
descdata	pointer
+	O
size	int
)	O
)	O
{	O
ret	pointer
=	O
1	int
;	O
goto	O
out	O
;	O
}	O
if	O
(	O
in	struct
.	O
namesz	array
==	O
sizeof	O
"GNU"	pointer
&&	O
strcmp	function
(	O
in	struct
.	O
namedata	pointer
,	O
"GNU"	pointer
)	O
==	O
0	int
&&	O
in	struct
.	O
type	enum
==	O
NT_GNU_PROPERTY_TYPE_0	int
)	O
{	O
unsigned	O
char	O
*	O
ptr	pointer
;	O
unsigned	O
char	O
*	O
ptr_end	pointer
;	O
if	O
(	O
in	struct
.	O
descsz	array
<	O
8	int
||	O
(	O
in	struct
.	O
descsz	array
%	O
align	long
)	O
!=	O
0	int
)	O
{	O
ret	pointer
=	O
1	int
;	O
goto	O
out	O
;	O
}	O
ptr	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
in	struct
.	O
descdata	pointer
;	O
ptr_end	pointer
=	O
ptr	pointer
+	O
in	struct
.	O
descsz	array
;	O
do	O
{	O
unsigned	O
int	O
type	enum
=	O
byte_get	pointer
(	O
ptr	pointer
,	O
4	int
)	O
;	O
unsigned	O
int	O
datasz	int
=	O
byte_get	pointer
(	O
ptr	pointer
+	O
4	int
,	O
4	int
)	O
;	O
unsigned	O
int	O
bitmask	int
,	O
old_bitmask	int
;	O
ptr	pointer
+=	O
8	int
;	O
if	O
(	O
(	O
ptr	pointer
+	O
datasz	int
)	O
>	O
ptr_end	pointer
)	O
{	O
ret	pointer
=	O
1	int
;	O
goto	O
out	O
;	O
}	O
if	O
(	O
type	enum
==	O
GNU_PROPERTY_X86_FEATURE_1_AND	O
)	O
{	O
if	O
(	O
datasz	int
!=	O
4	int
)	O
{	O
ret	pointer
=	O
1	int
;	O
goto	O
out	O
;	O
}	O
old_bitmask	int
=	O
byte_get	pointer
(	O
ptr	pointer
,	O
4	int
)	O
;	O
bitmask	int
=	O
old_bitmask	int
;	O
if	O
(	O
enable_x86_features	int
)	O
bitmask	int
|=	O
enable_x86_features	int
;	O
if	O
(	O
disable_x86_features	int
)	O
bitmask	int
&=	O
~	O
disable_x86_features	int
;	O
if	O
(	O
old_bitmask	int
!=	O
bitmask	int
)	O
byte_put	pointer
(	O
ptr	pointer
,	O
bitmask	int
,	O
4	int
)	O
;	O
goto	O
out	O
;	O
}	O
ptr	pointer
+=	O
ELF_ALIGN_UP	O
(	O
datasz	int
,	O
align	long
)	O
;	O
}	O
while	O
(	O
(	O
ptr_end	pointer
-	O
ptr	pointer
)	O
>=	O
8	int
)	O
;	O
}	O
p	pointer
+=	O
ELF_NOTE_NEXT_OFFSET	O
(	O
in	struct
.	O
namesz	array
,	O
in	struct
.	O
descsz	array
,	O
align	long
)	O
;	O
}	O
}	O
out	O
:	O
if	O
(	O
ret	pointer
!=	O
0	int
)	O
error	function
(	O
_	O
(	O
"%s: Invalid PT_NOTE segment\n"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
free	function
(	O
phdrs	pointer
)	O
;	O
munmap	function
(	O
map	pointer
,	O
st_buf	struct
.	O
st_size	long
)	O
;	O
return	O
ret	pointer
;	O
}	O
static	O
int	O
elf_x86_feature	function
(	O
const	O
char	O
*	O
feature	pointer
,	O
int	O
enable	int
)	O
{	O
unsigned	O
int	O
x86_feature	int
;	O
if	O
(	O
strcasecmp	function
(	O
feature	pointer
,	O
"ibt"	pointer
)	O
==	O
0	int
)	O
x86_feature	int
=	O
GNU_PROPERTY_X86_FEATURE_1_IBT	O
;	O
else	O
if	O
(	O
strcasecmp	function
(	O
feature	pointer
,	O
"shstk"	pointer
)	O
==	O
0	int
)	O
x86_feature	int
=	O
GNU_PROPERTY_X86_FEATURE_1_SHSTK	O
;	O
else	O
{	O
error	function
(	O
_	O
(	O
"Unknown x86 feature: %s\n"	pointer
)	O
,	O
feature	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
enable	int
)	O
{	O
enable_x86_features	int
|=	O
x86_feature	int
;	O
disable_x86_features	int
&=	O
~	O
x86_feature	int
;	O
}	O
else	O
{	O
disable_x86_features	int
|=	O
x86_feature	int
;	O
enable_x86_features	int
&=	O
~	O
x86_feature	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
enum	O
elfclass	enum
elf_class	function
(	O
int	O
mach	long
)	O
{	O
switch	O
(	O
mach	long
)	O
{	O
case	O
EM_386	int
:	O
case	O
EM_IAMCU	int
:	O
return	O
ELF_CLASS_32	int
;	O
case	O
EM_L1OM	int
:	O
case	O
EM_K1OM	int
:	O
return	O
ELF_CLASS_64	int
;	O
case	O
EM_X86_64	int
:	O
case	O
EM_NONE	int
:	O
return	O
ELF_CLASS_BOTH	int
;	O
default	O
:	O
return	O
ELF_CLASS_BOTH	int
;	O
}	O
}	O
static	O
int	O
update_elf_header	function
(	O
const	O
char	O
*	O
file_name	pointer
,	O
FILE	struct
*	O
file	pointer
)	O
{	O
int	O
class	int
,	O
machine	long
,	O
type	enum
,	O
status	int
,	O
osabi	int
;	O
if	O
(	O
elf_header	struct
.	O
e_ident	array
[	O
EI_VERSION	int
]	O
!=	O
EV_CURRENT	int
)	O
{	O
error	function
(	O
_	O
(	O
"%s: Unsupported EI_VERSION: %d is not %d\n"	pointer
)	O
,	O
file_name	pointer
,	O
elf_header	struct
.	O
e_ident	array
[	O
EI_VERSION	int
]	O
,	O
EV_CURRENT	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
output_elf_machine	int
==	O
elf_header	struct
.	O
e_machine	array
)	O
return	O
1	int
;	O
class	int
=	O
elf_header	struct
.	O
e_ident	array
[	O
EI_CLASS	int
]	O
;	O
machine	long
=	O
elf_header	struct
.	O
e_machine	array
;	O
if	O
(	O
input_elf_class	enum
==	O
ELF_CLASS_UNKNOWN	int
)	O
input_elf_class	enum
=	O
elf_class	function
(	O
machine	long
)	O
;	O
if	O
(	O
input_elf_class	enum
!=	O
ELF_CLASS_BOTH	int
&&	O
(	O
int	O
)	O
input_elf_class	enum
!=	O
class	int
)	O
{	O
error	function
(	O
_	O
(	O
"%s: Unmatched input EI_CLASS: %d is not %d\n"	pointer
)	O
,	O
file_name	pointer
,	O
class	int
,	O
input_elf_class	enum
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
output_elf_class	enum
!=	O
ELF_CLASS_BOTH	int
&&	O
(	O
int	O
)	O
output_elf_class	enum
!=	O
class	int
)	O
{	O
error	function
(	O
_	O
(	O
"%s: Unmatched output EI_CLASS: %d is not %d\n"	pointer
)	O
,	O
file_name	pointer
,	O
class	int
,	O
output_elf_class	enum
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
input_elf_machine	int
!=	O
-	O
1	int
&&	O
machine	long
!=	O
input_elf_machine	int
)	O
{	O
error	function
(	O
_	O
(	O
"%s: Unmatched e_machine: %d is not %d\n"	pointer
)	O
,	O
file_name	pointer
,	O
machine	long
,	O
input_elf_machine	int
)	O
;	O
return	O
0	int
;	O
}	O
type	enum
=	O
elf_header	struct
.	O
e_type	array
;	O
if	O
(	O
input_elf_type	int
!=	O
-	O
1	int
&&	O
type	enum
!=	O
input_elf_type	int
)	O
{	O
error	function
(	O
_	O
(	O
"%s: Unmatched e_type: %d is not %d\n"	pointer
)	O
,	O
file_name	pointer
,	O
type	enum
,	O
input_elf_type	int
)	O
;	O
return	O
0	int
;	O
}	O
osabi	int
=	O
elf_header	struct
.	O
e_ident	array
[	O
EI_OSABI	int
]	O
;	O
if	O
(	O
input_elf_osabi	int
!=	O
-	O
1	int
&&	O
osabi	int
!=	O
input_elf_osabi	int
)	O
{	O
error	function
(	O
_	O
(	O
"%s: Unmatched EI_OSABI: %d is not %d\n"	pointer
)	O
,	O
file_name	pointer
,	O
osabi	int
,	O
input_elf_osabi	int
)	O
;	O
return	O
0	int
;	O
}	O
switch	O
(	O
class	int
)	O
{	O
default	O
:	O
abort	function
(	O
)	O
;	O
break	O
;	O
case	O
ELFCLASS32	int
:	O
if	O
(	O
output_elf_machine	int
!=	O
-	O
1	int
)	O
BYTE_PUT	O
(	O
ehdr32	struct
.	O
e_machine	array
,	O
output_elf_machine	int
)	O
;	O
if	O
(	O
output_elf_type	int
!=	O
-	O
1	int
)	O
BYTE_PUT	O
(	O
ehdr32	struct
.	O
e_type	array
,	O
output_elf_type	int
)	O
;	O
if	O
(	O
output_elf_osabi	int
!=	O
-	O
1	int
)	O
ehdr32	struct
.	O
e_ident	array
[	O
EI_OSABI	int
]	O
=	O
output_elf_osabi	int
;	O
status	int
=	O
fwrite	function
(	O
&	O
ehdr32	struct
,	O
sizeof	O
(	O
ehdr32	struct
)	O
,	O
1	int
,	O
file	pointer
)	O
==	O
1	int
;	O
break	O
;	O
case	O
ELFCLASS64	int
:	O
if	O
(	O
output_elf_machine	int
!=	O
-	O
1	int
)	O
BYTE_PUT	O
(	O
ehdr64	struct
.	O
e_machine	array
,	O
output_elf_machine	int
)	O
;	O
if	O
(	O
output_elf_type	int
!=	O
-	O
1	int
)	O
BYTE_PUT	O
(	O
ehdr64	struct
.	O
e_type	array
,	O
output_elf_type	int
)	O
;	O
if	O
(	O
output_elf_osabi	int
!=	O
-	O
1	int
)	O
ehdr64	struct
.	O
e_ident	array
[	O
EI_OSABI	int
]	O
=	O
output_elf_osabi	int
;	O
status	int
=	O
fwrite	function
(	O
&	O
ehdr64	struct
,	O
sizeof	O
(	O
ehdr64	struct
)	O
,	O
1	int
,	O
file	pointer
)	O
==	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
status	int
!=	O
1	int
)	O
error	function
(	O
_	O
(	O
"%s: Failed to update ELF header: %s\n"	pointer
)	O
,	O
file_name	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
status	int
;	O
}	O
static	O
int	O
get_file_header	function
(	O
FILE	struct
*	O
file	pointer
)	O
{	O
if	O
(	O
fread	function
(	O
elf_header	struct
.	O
e_ident	array
,	O
EI_NIDENT	int
,	O
1	int
,	O
file	pointer
)	O
!=	O
1	int
)	O
return	O
0	int
;	O
if	O
(	O
elf_header	struct
.	O
e_ident	array
[	O
EI_MAG0	int
]	O
!=	O
ELFMAG0	int
||	O
elf_header	struct
.	O
e_ident	array
[	O
EI_MAG1	int
]	O
!=	O
ELFMAG1	char
||	O
elf_header	struct
.	O
e_ident	array
[	O
EI_MAG2	int
]	O
!=	O
ELFMAG2	char
||	O
elf_header	struct
.	O
e_ident	array
[	O
EI_MAG3	int
]	O
!=	O
ELFMAG3	char
)	O
return	O
0	int
;	O
switch	O
(	O
elf_header	struct
.	O
e_ident	array
[	O
EI_DATA	int
]	O
)	O
{	O
default	O
:	O
case	O
ELFDATANONE	int
:	O
case	O
ELFDATA2LSB	int
:	O
byte_get	pointer
=	O
byte_get_little_endian	function
;	O
byte_put	pointer
=	O
byte_put_little_endian	function
;	O
break	O
;	O
case	O
ELFDATA2MSB	int
:	O
byte_get	pointer
=	O
byte_get_big_endian	function
;	O
byte_put	pointer
=	O
byte_put_big_endian	function
;	O
break	O
;	O
}	O
switch	O
(	O
elf_header	struct
.	O
e_ident	array
[	O
EI_CLASS	int
]	O
)	O
{	O
default	O
:	O
return	O
0	int
;	O
case	O
ELFCLASS32	int
:	O
if	O
(	O
fread	function
(	O
ehdr32	struct
.	O
e_type	array
,	O
sizeof	O
(	O
ehdr32	struct
)	O
-	O
EI_NIDENT	int
,	O
1	int
,	O
file	pointer
)	O
!=	O
1	int
)	O
return	O
0	int
;	O
elf_header	struct
.	O
e_type	array
=	O
BYTE_GET	O
(	O
ehdr32	struct
.	O
e_type	array
)	O
;	O
elf_header	struct
.	O
e_machine	array
=	O
BYTE_GET	O
(	O
ehdr32	struct
.	O
e_machine	array
)	O
;	O
elf_header	struct
.	O
e_version	array
=	O
BYTE_GET	O
(	O
ehdr32	struct
.	O
e_version	array
)	O
;	O
elf_header	struct
.	O
e_entry	array
=	O
BYTE_GET	O
(	O
ehdr32	struct
.	O
e_entry	array
)	O
;	O
elf_header	struct
.	O
e_phoff	array
=	O
BYTE_GET	O
(	O
ehdr32	struct
.	O
e_phoff	array
)	O
;	O
elf_header	struct
.	O
e_shoff	array
=	O
BYTE_GET	O
(	O
ehdr32	struct
.	O
e_shoff	array
)	O
;	O
elf_header	struct
.	O
e_flags	array
=	O
BYTE_GET	O
(	O
ehdr32	struct
.	O
e_flags	array
)	O
;	O
elf_header	struct
.	O
e_ehsize	array
=	O
BYTE_GET	O
(	O
ehdr32	struct
.	O
e_ehsize	array
)	O
;	O
elf_header	struct
.	O
e_phentsize	array
=	O
BYTE_GET	O
(	O
ehdr32	struct
.	O
e_phentsize	array
)	O
;	O
elf_header	struct
.	O
e_phnum	array
=	O
BYTE_GET	O
(	O
ehdr32	struct
.	O
e_phnum	array
)	O
;	O
elf_header	struct
.	O
e_shentsize	array
=	O
BYTE_GET	O
(	O
ehdr32	struct
.	O
e_shentsize	array
)	O
;	O
elf_header	struct
.	O
e_shnum	array
=	O
BYTE_GET	O
(	O
ehdr32	struct
.	O
e_shnum	array
)	O
;	O
elf_header	struct
.	O
e_shstrndx	array
=	O
BYTE_GET	O
(	O
ehdr32	struct
.	O
e_shstrndx	array
)	O
;	O
memcpy	function
(	O
&	O
ehdr32	struct
,	O
&	O
elf_header	struct
,	O
EI_NIDENT	int
)	O
;	O
break	O
;	O
case	O
ELFCLASS64	int
:	O
if	O
(	O
sizeof	O
(	O
bfd_vma	long
)	O
<	O
8	int
)	O
{	O
error	function
(	O
_	O
(	O
"This executable has been built without support for a\n64 bit data type and so it cannot process 64 bit ELF files.\n"	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
fread	function
(	O
ehdr64	struct
.	O
e_type	array
,	O
sizeof	O
(	O
ehdr64	struct
)	O
-	O
EI_NIDENT	int
,	O
1	int
,	O
file	pointer
)	O
!=	O
1	int
)	O
return	O
0	int
;	O
elf_header	struct
.	O
e_type	array
=	O
BYTE_GET	O
(	O
ehdr64	struct
.	O
e_type	array
)	O
;	O
elf_header	struct
.	O
e_machine	array
=	O
BYTE_GET	O
(	O
ehdr64	struct
.	O
e_machine	array
)	O
;	O
elf_header	struct
.	O
e_version	array
=	O
BYTE_GET	O
(	O
ehdr64	struct
.	O
e_version	array
)	O
;	O
elf_header	struct
.	O
e_entry	array
=	O
BYTE_GET	O
(	O
ehdr64	struct
.	O
e_entry	array
)	O
;	O
elf_header	struct
.	O
e_phoff	array
=	O
BYTE_GET	O
(	O
ehdr64	struct
.	O
e_phoff	array
)	O
;	O
elf_header	struct
.	O
e_shoff	array
=	O
BYTE_GET	O
(	O
ehdr64	struct
.	O
e_shoff	array
)	O
;	O
elf_header	struct
.	O
e_flags	array
=	O
BYTE_GET	O
(	O
ehdr64	struct
.	O
e_flags	array
)	O
;	O
elf_header	struct
.	O
e_ehsize	array
=	O
BYTE_GET	O
(	O
ehdr64	struct
.	O
e_ehsize	array
)	O
;	O
elf_header	struct
.	O
e_phentsize	array
=	O
BYTE_GET	O
(	O
ehdr64	struct
.	O
e_phentsize	array
)	O
;	O
elf_header	struct
.	O
e_phnum	array
=	O
BYTE_GET	O
(	O
ehdr64	struct
.	O
e_phnum	array
)	O
;	O
elf_header	struct
.	O
e_shentsize	array
=	O
BYTE_GET	O
(	O
ehdr64	struct
.	O
e_shentsize	array
)	O
;	O
elf_header	struct
.	O
e_shnum	array
=	O
BYTE_GET	O
(	O
ehdr64	struct
.	O
e_shnum	array
)	O
;	O
elf_header	struct
.	O
e_shstrndx	array
=	O
BYTE_GET	O
(	O
ehdr64	struct
.	O
e_shstrndx	array
)	O
;	O
memcpy	function
(	O
&	O
ehdr64	struct
,	O
&	O
elf_header	struct
,	O
EI_NIDENT	int
)	O
;	O
break	O
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
process_object	function
(	O
const	O
char	O
*	O
file_name	pointer
,	O
FILE	struct
*	O
file	pointer
)	O
{	O
long	O
offset	long
=	O
ftell	function
(	O
file	pointer
)	O
;	O
if	O
(	O
!	O
get_file_header	function
(	O
file	pointer
)	O
)	O
{	O
error	function
(	O
_	O
(	O
"%s: Failed to read ELF header\n"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
fseek	function
(	O
file	pointer
,	O
offset	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
{	O
error	function
(	O
_	O
(	O
"%s: Failed to seek to ELF header\n"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
}	O
if	O
(	O
!	O
update_elf_header	function
(	O
file_name	pointer
,	O
file	pointer
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
process_archive	function
(	O
const	O
char	O
*	O
file_name	pointer
,	O
FILE	struct
*	O
file	pointer
,	O
bfd_boolean	int
is_thin_archive	int
)	O
{	O
struct	O
archive_info	struct
arch	enum
;	O
struct	O
archive_info	struct
nested_arch	struct
;	O
size_t	long
got	long
;	O
int	O
ret	pointer
;	O
arch	enum
.	O
file_name	pointer
=	O
NULL	O
;	O
arch	enum
.	O
file	pointer
=	O
NULL	O
;	O
arch	enum
.	O
index_array	pointer
=	O
NULL	O
;	O
arch	enum
.	O
sym_table	pointer
=	O
NULL	O
;	O
arch	enum
.	O
longnames	pointer
=	O
NULL	O
;	O
nested_arch	struct
.	O
file_name	pointer
=	O
NULL	O
;	O
nested_arch	struct
.	O
file	pointer
=	O
NULL	O
;	O
nested_arch	struct
.	O
index_array	pointer
=	O
NULL	O
;	O
nested_arch	struct
.	O
sym_table	pointer
=	O
NULL	O
;	O
nested_arch	struct
.	O
longnames	pointer
=	O
NULL	O
;	O
if	O
(	O
setup_archive	function
(	O
&	O
arch	enum
,	O
file_name	pointer
,	O
file	pointer
,	O
is_thin_archive	int
,	O
FALSE	int
)	O
!=	O
0	int
)	O
{	O
ret	pointer
=	O
1	int
;	O
goto	O
out	O
;	O
}	O
ret	pointer
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
char	O
*	O
name	pointer
;	O
size_t	long
namelen	long
;	O
char	O
*	O
qualified_name	pointer
;	O
if	O
(	O
fseek	function
(	O
file	pointer
,	O
arch	enum
.	O
next_arhdr_offset	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
{	O
error	function
(	O
_	O
(	O
"%s: failed to seek to next archive header\n"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
return	O
1	int
;	O
}	O
got	long
=	O
fread	function
(	O
&	O
arch	enum
.	O
arhdr	struct
,	O
1	int
,	O
sizeof	O
arch	enum
.	O
arhdr	struct
,	O
file	pointer
)	O
;	O
if	O
(	O
got	long
!=	O
sizeof	O
arch	enum
.	O
arhdr	struct
)	O
{	O
if	O
(	O
got	long
==	O
0	int
)	O
break	O
;	O
error	function
(	O
_	O
(	O
"%s: failed to read archive header\n"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
ret	pointer
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
memcmp	function
(	O
arch	enum
.	O
arhdr	struct
.	O
ar_fmag	array
,	O
ARFMAG	pointer
,	O
2	int
)	O
!=	O
0	int
)	O
{	O
error	function
(	O
_	O
(	O
"%s: did not find a valid archive header\n"	pointer
)	O
,	O
arch	enum
.	O
file_name	pointer
)	O
;	O
ret	pointer
=	O
1	int
;	O
break	O
;	O
}	O
arch	enum
.	O
next_arhdr_offset	long
+=	O
sizeof	O
arch	enum
.	O
arhdr	struct
;	O
archive_file_size	long
=	O
strtoul	function
(	O
arch	enum
.	O
arhdr	struct
.	O
ar_size	array
,	O
NULL	O
,	O
10	int
)	O
;	O
if	O
(	O
archive_file_size	long
&	O
01	int
)	O
++	O
archive_file_size	long
;	O
name	pointer
=	O
get_archive_member_name	function
(	O
&	O
arch	enum
,	O
&	O
nested_arch	struct
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"%s: bad archive file name\n"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
ret	pointer
=	O
1	int
;	O
break	O
;	O
}	O
namelen	long
=	O
strlen	function
(	O
name	pointer
)	O
;	O
qualified_name	pointer
=	O
make_qualified_name	function
(	O
&	O
arch	enum
,	O
&	O
nested_arch	struct
,	O
name	pointer
)	O
;	O
if	O
(	O
qualified_name	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"%s: bad archive file name\n"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
ret	pointer
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
is_thin_archive	int
&&	O
arch	enum
.	O
nested_member_origin	long
==	O
0	int
)	O
{	O
FILE	struct
*	O
member_file	pointer
;	O
char	O
*	O
member_file_name	pointer
=	O
adjust_relative_path	function
(	O
file_name	pointer
,	O
name	pointer
,	O
namelen	long
)	O
;	O
if	O
(	O
member_file_name	pointer
==	O
NULL	O
)	O
{	O
ret	pointer
=	O
1	int
;	O
break	O
;	O
}	O
member_file	pointer
=	O
fopen	function
(	O
member_file_name	pointer
,	O
"r+b"	pointer
)	O
;	O
if	O
(	O
member_file	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Input file '%s' is not readable\n"	pointer
)	O
,	O
member_file_name	pointer
)	O
;	O
free	function
(	O
member_file_name	pointer
)	O
;	O
ret	pointer
=	O
1	int
;	O
break	O
;	O
}	O
archive_file_offset	long
=	O
arch	enum
.	O
nested_member_origin	long
;	O
ret	pointer
|=	O
process_object	function
(	O
qualified_name	pointer
,	O
member_file	pointer
)	O
;	O
fclose	function
(	O
member_file	pointer
)	O
;	O
free	function
(	O
member_file_name	pointer
)	O
;	O
}	O
else	O
if	O
(	O
is_thin_archive	int
)	O
{	O
archive_file_offset	long
=	O
arch	enum
.	O
nested_member_origin	long
+	O
sizeof	O
arch	enum
.	O
arhdr	struct
;	O
if	O
(	O
fseek	function
(	O
nested_arch	struct
.	O
file	pointer
,	O
archive_file_offset	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
{	O
error	function
(	O
_	O
(	O
"%s: failed to seek to archive member\n"	pointer
)	O
,	O
nested_arch	struct
.	O
file_name	pointer
)	O
;	O
ret	pointer
=	O
1	int
;	O
break	O
;	O
}	O
ret	pointer
|=	O
process_object	function
(	O
qualified_name	pointer
,	O
nested_arch	struct
.	O
file	pointer
)	O
;	O
}	O
else	O
{	O
archive_file_offset	long
=	O
arch	enum
.	O
next_arhdr_offset	long
;	O
arch	enum
.	O
next_arhdr_offset	long
+=	O
archive_file_size	long
;	O
ret	pointer
|=	O
process_object	function
(	O
qualified_name	pointer
,	O
file	pointer
)	O
;	O
}	O
free	function
(	O
qualified_name	pointer
)	O
;	O
}	O
out	O
:	O
if	O
(	O
nested_arch	struct
.	O
file	pointer
!=	O
NULL	O
)	O
fclose	function
(	O
nested_arch	struct
.	O
file	pointer
)	O
;	O
release_archive	function
(	O
&	O
nested_arch	struct
)	O
;	O
release_archive	function
(	O
&	O
arch	enum
)	O
;	O
return	O
ret	pointer
;	O
}	O
static	O
int	O
check_file	function
(	O
const	O
char	O
*	O
file_name	pointer
,	O
struct	O
stat	struct
*	O
statbuf_p	pointer
)	O
{	O
struct	O
stat	struct
statbuf	struct
;	O
if	O
(	O
statbuf_p	pointer
==	O
NULL	O
)	O
statbuf_p	pointer
=	O
&	O
statbuf	struct
;	O
if	O
(	O
stat	struct
(	O
file_name	pointer
,	O
statbuf_p	pointer
)	O
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
ENOENT	int
)	O
error	function
(	O
_	O
(	O
"'%s': No such file\n"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
else	O
error	function
(	O
_	O
(	O
"Could not locate '%s'.  System error message: %s\n"	pointer
)	O
,	O
file_name	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
!	O
S_ISREG	O
(	O
statbuf_p	pointer
->	O
st_mode	int
)	O
)	O
{	O
error	function
(	O
_	O
(	O
"'%s' is not an ordinary file\n"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
process_file	function
(	O
const	O
char	O
*	O
file_name	pointer
)	O
{	O
FILE	struct
*	O
file	pointer
;	O
char	O
armag	array
[	O
SARMAG	int
]	O
;	O
int	O
ret	pointer
;	O
if	O
(	O
check_file	function
(	O
file_name	pointer
,	O
NULL	O
)	O
)	O
return	O
1	int
;	O
file	pointer
=	O
fopen	function
(	O
file_name	pointer
,	O
"r+b"	pointer
)	O
;	O
if	O
(	O
file	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
_	O
(	O
"Input file '%s' is not readable\n"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
fread	function
(	O
armag	array
,	O
SARMAG	int
,	O
1	int
,	O
file	pointer
)	O
!=	O
1	int
)	O
{	O
error	function
(	O
_	O
(	O
"%s: Failed to read file's magic number\n"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
fclose	function
(	O
file	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
memcmp	function
(	O
armag	array
,	O
ARMAG	pointer
,	O
SARMAG	int
)	O
==	O
0	int
)	O
ret	pointer
=	O
process_archive	function
(	O
file_name	pointer
,	O
file	pointer
,	O
FALSE	int
)	O
;	O
else	O
if	O
(	O
memcmp	function
(	O
armag	array
,	O
ARMAGT	pointer
,	O
SARMAG	int
)	O
==	O
0	int
)	O
ret	pointer
=	O
process_archive	function
(	O
file_name	pointer
,	O
file	pointer
,	O
TRUE	int
)	O
;	O
else	O
{	O
rewind	function
(	O
file	pointer
)	O
;	O
archive_file_size	long
=	O
archive_file_offset	long
=	O
0	int
;	O
ret	pointer
=	O
process_object	function
(	O
file_name	pointer
,	O
file	pointer
)	O
;	O
if	O
(	O
!	O
ret	pointer
&&	O
(	O
elf_header	struct
.	O
e_type	array
==	O
ET_EXEC	int
||	O
elf_header	struct
.	O
e_type	array
==	O
ET_DYN	int
)	O
)	O
ret	pointer
=	O
update_gnu_property	function
(	O
file_name	pointer
,	O
file	pointer
)	O
;	O
}	O
fclose	function
(	O
file	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
static	O
const	O
struct	O
{	O
int	O
osabi	int
;	O
const	O
char	O
*	O
name	pointer
;	O
}	O
osabis	array
[	O
]	O
=	O
{	O
{	O
ELFOSABI_NONE	int
,	O
"none"	pointer
}	O
,	O
{	O
ELFOSABI_HPUX	int
,	O
"HPUX"	pointer
}	O
,	O
{	O
ELFOSABI_NETBSD	int
,	O
"NetBSD"	pointer
}	O
,	O
{	O
ELFOSABI_GNU	int
,	O
"GNU"	pointer
}	O
,	O
{	O
ELFOSABI_GNU	int
,	O
"Linux"	pointer
}	O
,	O
{	O
ELFOSABI_SOLARIS	int
,	O
"Solaris"	pointer
}	O
,	O
{	O
ELFOSABI_AIX	int
,	O
"AIX"	pointer
}	O
,	O
{	O
ELFOSABI_IRIX	int
,	O
"Irix"	pointer
}	O
,	O
{	O
ELFOSABI_FREEBSD	int
,	O
"FreeBSD"	pointer
}	O
,	O
{	O
ELFOSABI_TRU64	int
,	O
"TRU64"	pointer
}	O
,	O
{	O
ELFOSABI_MODESTO	int
,	O
"Modesto"	pointer
}	O
,	O
{	O
ELFOSABI_OPENBSD	int
,	O
"OpenBSD"	pointer
}	O
,	O
{	O
ELFOSABI_OPENVMS	int
,	O
"OpenVMS"	pointer
}	O
,	O
{	O
ELFOSABI_NSK	int
,	O
"NSK"	pointer
}	O
,	O
{	O
ELFOSABI_AROS	int
,	O
"AROS"	pointer
}	O
,	O
{	O
ELFOSABI_FENIXOS	int
,	O
"FenixOS"	pointer
}	O
}	O
;	O
static	O
int	O
elf_osabi	function
(	O
const	O
char	O
*	O
osabi	int
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
ARRAY_SIZE	O
(	O
osabis	array
)	O
;	O
i	pointer
++	O
)	O
if	O
(	O
strcasecmp	function
(	O
osabi	int
,	O
osabis	array
[	O
i	pointer
]	O
.	O
name	pointer
)	O
==	O
0	int
)	O
return	O
osabis	array
[	O
i	pointer
]	O
.	O
osabi	int
;	O
error	function
(	O
_	O
(	O
"Unknown OSABI: %s\n"	pointer
)	O
,	O
osabi	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
static	O
int	O
elf_machine	function
(	O
const	O
char	O
*	O
mach	long
)	O
{	O
if	O
(	O
strcasecmp	function
(	O
mach	long
,	O
"i386"	pointer
)	O
==	O
0	int
)	O
return	O
EM_386	int
;	O
if	O
(	O
strcasecmp	function
(	O
mach	long
,	O
"iamcu"	pointer
)	O
==	O
0	int
)	O
return	O
EM_IAMCU	int
;	O
if	O
(	O
strcasecmp	function
(	O
mach	long
,	O
"l1om"	pointer
)	O
==	O
0	int
)	O
return	O
EM_L1OM	int
;	O
if	O
(	O
strcasecmp	function
(	O
mach	long
,	O
"k1om"	pointer
)	O
==	O
0	int
)	O
return	O
EM_K1OM	int
;	O
if	O
(	O
strcasecmp	function
(	O
mach	long
,	O
"x86_64"	pointer
)	O
==	O
0	int
)	O
return	O
EM_X86_64	int
;	O
if	O
(	O
strcasecmp	function
(	O
mach	long
,	O
"x86-64"	pointer
)	O
==	O
0	int
)	O
return	O
EM_X86_64	int
;	O
if	O
(	O
strcasecmp	function
(	O
mach	long
,	O
"none"	pointer
)	O
==	O
0	int
)	O
return	O
EM_NONE	int
;	O
error	function
(	O
_	O
(	O
"Unknown machine type: %s\n"	pointer
)	O
,	O
mach	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
static	O
int	O
elf_type	function
(	O
const	O
char	O
*	O
type	enum
)	O
{	O
if	O
(	O
strcasecmp	function
(	O
type	enum
,	O
"rel"	pointer
)	O
==	O
0	int
)	O
return	O
ET_REL	int
;	O
if	O
(	O
strcasecmp	function
(	O
type	enum
,	O
"exec"	pointer
)	O
==	O
0	int
)	O
return	O
ET_EXEC	int
;	O
if	O
(	O
strcasecmp	function
(	O
type	enum
,	O
"dyn"	pointer
)	O
==	O
0	int
)	O
return	O
ET_DYN	int
;	O
if	O
(	O
strcasecmp	function
(	O
type	enum
,	O
"none"	pointer
)	O
==	O
0	int
)	O
return	O
ET_NONE	int
;	O
error	function
(	O
_	O
(	O
"Unknown type: %s\n"	pointer
)	O
,	O
type	enum
)	O
;	O
return	O
-	O
1	int
;	O
}	O
enum	O
command_line_switch	enum
{	O
OPTION_INPUT_MACH	int
=	O
150	int
,	O
OPTION_OUTPUT_MACH	int
,	O
OPTION_INPUT_TYPE	int
,	O
OPTION_OUTPUT_TYPE	int
,	O
OPTION_INPUT_OSABI	int
,	O
OPTION_OUTPUT_OSABI	int
,	O
OPTION_ENABLE_X86_FEATURE	int
,	O
OPTION_DISABLE_X86_FEATURE	int
,	O
}	O
;	O
static	O
struct	O
option	struct
options	array
[	O
]	O
=	O
{	O
{	O
"input-mach"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_INPUT_MACH	int
}	O
,	O
{	O
"output-mach"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_OUTPUT_MACH	int
}	O
,	O
{	O
"input-type"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_INPUT_TYPE	int
}	O
,	O
{	O
"output-type"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_OUTPUT_TYPE	int
}	O
,	O
{	O
"input-osabi"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_INPUT_OSABI	int
}	O
,	O
{	O
"output-osabi"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_OUTPUT_OSABI	int
}	O
,	O
{	O
"enable-x86-feature"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_ENABLE_X86_FEATURE	int
}	O
,	O
{	O
"disable-x86-feature"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPTION_DISABLE_X86_FEATURE	int
}	O
,	O
{	O
"version"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'v'	O
}	O
,	O
{	O
"help"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'h'	O
}	O
,	O
{	O
0	int
,	O
no_argument	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
ATTRIBUTE_NORETURN	O
static	O
void	O
usage	function
(	O
FILE	struct
*	O
stream	pointer
,	O
int	O
exit_status	int
)	O
{	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"Usage: %s <option(s)> elffile(s)\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
" Update the ELF header of ELF files\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
" The options are:\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"  --input-mach <machine>      Set input machine type to <machine>\n  --output-mach <machine>     Set output machine type to <machine>\n  --input-type <type>         Set input file type to <type>\n  --output-type <type>        Set output file type to <type>\n  --input-osabi <osabi>       Set input OSABI to <osabi>\n  --output-osabi <osabi>      Set output OSABI to <osabi>\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"  --enable-x86-feature <feature>\n                              Enable x86 feature <feature>\n  --disable-x86-feature <feature>\n                              Disable x86 feature <feature>\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"  -h --help                   Display this information\n  -v --version                Display the version number of %s\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
if	O
(	O
REPORT_BUGS_TO	pointer
[	O
0	int
]	O
&&	O
exit_status	int
==	O
0	int
)	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"Report bugs to %s\n"	pointer
)	O
,	O
REPORT_BUGS_TO	pointer
)	O
;	O
exit	function
(	O
exit_status	int
)	O
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
c	int
,	O
status	int
;	O
setlocale	function
(	O
LC_MESSAGES	O
,	O
""	pointer
)	O
;	O
setlocale	function
(	O
LC_CTYPE	O
,	O
""	pointer
)	O
;	O
bindtextdomain	function
(	O
PACKAGE	pointer
,	O
LOCALEDIR	O
)	O
;	O
textdomain	function
(	O
PACKAGE	pointer
)	O
;	O
expandargv	function
(	O
&	O
argc	int
,	O
&	O
argv	pointer
)	O
;	O
while	O
(	O
(	O
c	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
"hv"	pointer
,	O
options	array
,	O
(	O
int	O
*	O
)	O
0	int
)	O
)	O
!=	O
EOF	O
)	O
{	O
switch	O
(	O
c	int
)	O
{	O
case	O
OPTION_INPUT_MACH	int
:	O
input_elf_machine	int
=	O
elf_machine	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
input_elf_machine	int
<	O
0	int
)	O
return	O
1	int
;	O
input_elf_class	enum
=	O
elf_class	function
(	O
input_elf_machine	int
)	O
;	O
if	O
(	O
input_elf_class	enum
==	O
ELF_CLASS_UNKNOWN	int
)	O
return	O
1	int
;	O
break	O
;	O
case	O
OPTION_OUTPUT_MACH	int
:	O
output_elf_machine	int
=	O
elf_machine	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
output_elf_machine	int
<	O
0	int
)	O
return	O
1	int
;	O
output_elf_class	enum
=	O
elf_class	function
(	O
output_elf_machine	int
)	O
;	O
if	O
(	O
output_elf_class	enum
==	O
ELF_CLASS_UNKNOWN	int
)	O
return	O
1	int
;	O
break	O
;	O
case	O
OPTION_INPUT_TYPE	int
:	O
input_elf_type	int
=	O
elf_type	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
input_elf_type	int
<	O
0	int
)	O
return	O
1	int
;	O
break	O
;	O
case	O
OPTION_OUTPUT_TYPE	int
:	O
output_elf_type	int
=	O
elf_type	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
output_elf_type	int
<	O
0	int
)	O
return	O
1	int
;	O
break	O
;	O
case	O
OPTION_INPUT_OSABI	int
:	O
input_elf_osabi	int
=	O
elf_osabi	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
input_elf_osabi	int
<	O
0	int
)	O
return	O
1	int
;	O
break	O
;	O
case	O
OPTION_OUTPUT_OSABI	int
:	O
output_elf_osabi	int
=	O
elf_osabi	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
output_elf_osabi	int
<	O
0	int
)	O
return	O
1	int
;	O
break	O
;	O
case	O
OPTION_ENABLE_X86_FEATURE	int
:	O
if	O
(	O
elf_x86_feature	function
(	O
optarg	pointer
,	O
1	int
)	O
<	O
0	int
)	O
return	O
1	int
;	O
break	O
;	O
case	O
OPTION_DISABLE_X86_FEATURE	int
:	O
if	O
(	O
elf_x86_feature	function
(	O
optarg	pointer
,	O
0	int
)	O
<	O
0	int
)	O
return	O
1	int
;	O
break	O
;	O
case	O
'h'	O
:	O
usage	function
(	O
stdout	pointer
,	O
0	int
)	O
;	O
case	O
'v'	O
:	O
print_version	function
(	O
program_name	pointer
)	O
;	O
break	O
;	O
default	O
:	O
usage	function
(	O
stderr	pointer
,	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
optind	int
==	O
argc	int
||	O
(	O
output_elf_machine	int
==	O
-	O
1	int
&&	O
!	O
enable_x86_features	int
&&	O
!	O
disable_x86_features	int
&&	O
output_elf_type	int
==	O
-	O
1	int
&&	O
output_elf_osabi	int
==	O
-	O
1	int
)	O
)	O
usage	function
(	O
stderr	pointer
,	O
1	int
)	O
;	O
status	int
=	O
0	int
;	O
while	O
(	O
optind	int
<	O
argc	int
)	O
status	int
|=	O
process_file	function
(	O
argv	pointer
[	O
optind	int
++	O
]	O
)	O
;	O
return	O
status	int
;	O
}	O
