static	O
bool	bool
multi_domain_mode	bool
=	O
false	int
;	O
static	O
bool	bool
use_fuzzy_matching	bool
=	O
true	int
;	O
static	O
bool	bool
include_fuzzies	bool
=	O
false	int
;	O
static	O
bool	bool
include_untranslated	bool
=	O
false	int
;	O
static	O
const	O
struct	O
option	struct
long_options	array
[	O
]	O
=	O
{	O
{	O
"directory"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'D'	O
}	O
,	O
{	O
"help"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'h'	O
}	O
,	O
{	O
"multi-domain"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'm'	O
}	O
,	O
{	O
"no-fuzzy-matching"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'N'	O
}	O
,	O
{	O
"properties-input"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'P'	O
}	O
,	O
{	O
"stringtable-input"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
1	int
}	O
,	O
{	O
"use-fuzzy"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
2	int
}	O
,	O
{	O
"use-untranslated"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
3	int
}	O
,	O
{	O
"version"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'V'	O
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
void	O
usage	function
(	O
int	O
status	int
)	O
__attribute__	O
(	O
(	O
noreturn	O
)	O
)	O
;	O
static	O
void	O
compare	function
(	O
const	O
char	O
*	O
fn1	pointer
,	O
const	O
char	O
*	O
fn2	pointer
,	O
catalog_input_format_ty	pointer
input_syntax	pointer
)	O
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array
[	O
]	O
)	O
{	O
int	O
optchar	int
;	O
bool	bool
do_help	bool
;	O
bool	bool
do_version	bool
;	O
catalog_input_format_ty	pointer
input_syntax	pointer
=	O
&	O
input_format_po	struct
;	O
set_program_name	function
(	O
argv	array
[	O
0	int
]	O
)	O
;	O
error_print_progname	pointer
=	O
maybe_print_progname	function
;	O
gram_max_allowed_errors	int
=	O
UINT_MAX	O
;	O
setlocale	function
(	O
LC_ALL	O
,	O
""	pointer
)	O
;	O
bindtextdomain	function
(	O
PACKAGE	pointer
,	O
relocate	O
(	O
LOCALEDIR	O
)	O
)	O
;	O
bindtextdomain	function
(	O
"bison-runtime"	pointer
,	O
relocate	O
(	O
BISON_LOCALEDIR	O
)	O
)	O
;	O
textdomain	function
(	O
PACKAGE	pointer
)	O
;	O
atexit	function
(	O
close_stdout	function
)	O
;	O
do_help	bool
=	O
false	int
;	O
do_version	bool
=	O
false	int
;	O
while	O
(	O
(	O
optchar	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	array
,	O
"D:hmNPV"	pointer
,	O
long_options	array
,	O
NULL	O
)	O
)	O
!=	O
EOF	O
)	O
switch	O
(	O
optchar	int
)	O
{	O
case	O
'\0'	O
:	O
break	O
;	O
case	O
'D'	O
:	O
dir_list_append	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'h'	O
:	O
do_help	bool
=	O
true	int
;	O
break	O
;	O
case	O
'm'	O
:	O
multi_domain_mode	bool
=	O
true	int
;	O
break	O
;	O
case	O
'N'	O
:	O
use_fuzzy_matching	bool
=	O
false	int
;	O
break	O
;	O
case	O
'P'	O
:	O
input_syntax	pointer
=	O
&	O
input_format_properties	struct
;	O
break	O
;	O
case	O
'V'	O
:	O
do_version	bool
=	O
true	int
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
1	int
:	O
input_syntax	pointer
=	O
&	O
input_format_stringtable	struct
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
2	int
:	O
include_fuzzies	bool
=	O
true	int
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
3	int
:	O
include_untranslated	bool
=	O
true	int
;	O
break	O
;	O
default	O
:	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
do_version	bool
)	O
{	O
printf	function
(	O
"%s (GNU %s) %s\n"	pointer
,	O
basename	function
(	O
program_name	pointer
)	O
,	O
PACKAGE	pointer
,	O
VERSION	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Copyright (C) %s Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n"	pointer
)	O
,	O
"1995-2019"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Written by %s.\n"	pointer
)	O
,	O
proper_name	function
(	O
"Peter Miller"	pointer
)	O
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
if	O
(	O
do_help	bool
)	O
usage	function
(	O
EXIT_SUCCESS	int
)	O
;	O
if	O
(	O
optind	int
>=	O
argc	int
)	O
{	O
error	function
(	O
EXIT_SUCCESS	int
,	O
0	int
,	O
_	O
(	O
"no input files given"	pointer
)	O
)	O
;	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
optind	int
+	O
2	int
!=	O
argc	int
)	O
{	O
error	function
(	O
EXIT_SUCCESS	int
,	O
0	int
,	O
_	O
(	O
"exactly 2 input files required"	pointer
)	O
)	O
;	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
compare	function
(	O
argv	array
[	O
optind	int
]	O
,	O
argv	array
[	O
optind	int
+	O
1	int
]	O
,	O
input_syntax	pointer
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
static	O
void	O
usage	function
(	O
int	O
status	int
)	O
{	O
if	O
(	O
status	int
!=	O
EXIT_SUCCESS	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Try '%s --help' for more information.\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
else	O
{	O
printf	function
(	O
_	O
(	O
"Usage: %s [OPTION] def.po ref.pot\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Compare two Uniforum style .po files to check that both contain the same\nset of msgid strings.  The def.po file is an existing PO file with the\ntranslations.  The ref.pot file is the last created PO file, or a PO Template\nfile (generally created by xgettext).  This is useful for checking that\nyou have translated each and every message in your program.  Where an exact\nmatch cannot be found, fuzzy matching is used to produce better diagnostics.\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Mandatory arguments to long options are mandatory for short options too.\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Input file location:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  def.po                      translations\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  ref.pot                     references to the sources\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -D, --directory=DIRECTORY   add DIRECTORY to list for input files search\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Operation modifiers:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -m, --multi-domain          apply ref.pot to each of the domains in def.po\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -N, --no-fuzzy-matching     do not use fuzzy matching\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --use-fuzzy             consider fuzzy entries\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --use-untranslated      consider untranslated entries\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Input file syntax:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -P, --properties-input      input files are in Java .properties syntax\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --stringtable-input     input files are in NeXTstep/GNUstep .strings\n                              syntax\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Informative output:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -h, --help                  display this help and exit\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -V, --version               output version information and exit\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
fputs	function
(	O
_	O
(	O
"Report bugs to <bug-gnu-gettext@gnu.org>.\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
}	O
exit	function
(	O
status	int
)	O
;	O
}	O
static	O
bool	bool
is_message_selected	function
(	O
const	O
message_ty	struct
*	O
mp	pointer
)	O
{	O
if	O
(	O
is_header	O
(	O
mp	pointer
)	O
)	O
return	O
true	int
;	O
return	O
!	O
mp	pointer
->	O
obsolete	bool
;	O
}	O
static	O
msgdomain_list_ty	struct
*	O
remove_obsoletes	function
(	O
msgdomain_list_ty	struct
*	O
mdlp	pointer
)	O
{	O
size_t	long
k	long
;	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
mdlp	pointer
->	O
nitems	long
;	O
k	long
++	O
)	O
message_list_remove_if_not	function
(	O
mdlp	pointer
->	O
item	pointer
[	O
k	long
]	O
->	O
messages	pointer
,	O
is_message_selected	function
)	O
;	O
return	O
mdlp	pointer
;	O
}	O
static	O
void	O
match_domain	function
(	O
const	O
char	O
*	O
fn1	pointer
,	O
const	O
char	O
*	O
fn2	pointer
,	O
message_list_ty	struct
*	O
defmlp	pointer
,	O
message_fuzzy_index_ty	struct
*	O
*	O
defmlp_findex	pointer
,	O
const	O
char	O
*	O
def_canon_charset	pointer
,	O
message_list_ty	struct
*	O
refmlp	pointer
,	O
int	O
*	O
nerrors	pointer
)	O
{	O
size_t	long
j	long
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
refmlp	pointer
->	O
nitems	long
;	O
j	long
++	O
)	O
{	O
message_ty	struct
*	O
refmsg	pointer
;	O
message_ty	struct
*	O
defmsg	pointer
;	O
refmsg	pointer
=	O
refmlp	pointer
->	O
item	pointer
[	O
j	long
]	O
;	O
defmsg	pointer
=	O
message_list_search	function
(	O
defmlp	pointer
,	O
refmsg	pointer
->	O
msgctxt	pointer
,	O
refmsg	pointer
->	O
msgid	pointer
)	O
;	O
if	O
(	O
defmsg	pointer
)	O
{	O
if	O
(	O
!	O
include_untranslated	bool
&&	O
defmsg	pointer
->	O
msgstr	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
(	O
*	O
nerrors	pointer
)	O
++	O
;	O
po_gram_error_at_line	function
(	O
&	O
defmsg	pointer
->	O
pos	struct
,	O
_	O
(	O
"this message is untranslated"	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
include_fuzzies	bool
&&	O
defmsg	pointer
->	O
is_fuzzy	bool
&&	O
!	O
is_header	O
(	O
defmsg	pointer
)	O
)	O
{	O
(	O
*	O
nerrors	pointer
)	O
++	O
;	O
po_gram_error_at_line	function
(	O
&	O
defmsg	pointer
->	O
pos	struct
,	O
_	O
(	O
"this message needs to be reviewed by the translator"	pointer
)	O
)	O
;	O
}	O
else	O
defmsg	pointer
->	O
used	int
=	O
1	int
;	O
}	O
else	O
{	O
(	O
*	O
nerrors	pointer
)	O
++	O
;	O
if	O
(	O
use_fuzzy_matching	bool
)	O
{	O
if	O
(	O
false	int
)	O
{	O
defmsg	pointer
=	O
message_list_search_fuzzy	function
(	O
defmlp	pointer
,	O
refmsg	pointer
->	O
msgctxt	pointer
,	O
refmsg	pointer
->	O
msgid	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
*	O
defmlp_findex	pointer
==	O
NULL	O
)	O
*	O
defmlp_findex	pointer
=	O
message_fuzzy_index_alloc	function
(	O
defmlp	pointer
,	O
def_canon_charset	pointer
)	O
;	O
defmsg	pointer
=	O
message_fuzzy_index_search	function
(	O
*	O
defmlp_findex	pointer
,	O
refmsg	pointer
->	O
msgctxt	pointer
,	O
refmsg	pointer
->	O
msgid	pointer
,	O
FUZZY_THRESHOLD	int
,	O
false	int
)	O
;	O
}	O
}	O
else	O
defmsg	pointer
=	O
NULL	O
;	O
if	O
(	O
defmsg	pointer
)	O
{	O
po_gram_error_at_line	function
(	O
&	O
refmsg	pointer
->	O
pos	struct
,	O
_	O
(	O
"this message is used but not defined..."	pointer
)	O
)	O
;	O
error_message_count	int
--	O
;	O
po_gram_error_at_line	function
(	O
&	O
defmsg	pointer
->	O
pos	struct
,	O
_	O
(	O
"...but this definition is similar"	pointer
)	O
)	O
;	O
defmsg	pointer
->	O
used	int
=	O
1	int
;	O
}	O
else	O
po_gram_error_at_line	function
(	O
&	O
refmsg	pointer
->	O
pos	struct
,	O
_	O
(	O
"this message is used but not defined in %s"	pointer
)	O
,	O
fn1	pointer
)	O
;	O
}	O
}	O
}	O
static	O
void	O
compare	function
(	O
const	O
char	O
*	O
fn1	pointer
,	O
const	O
char	O
*	O
fn2	pointer
,	O
catalog_input_format_ty	pointer
input_syntax	pointer
)	O
{	O
msgdomain_list_ty	struct
*	O
def	pointer
;	O
msgdomain_list_ty	struct
*	O
ref	pointer
;	O
int	O
nerrors	pointer
;	O
size_t	long
j	long
,	O
k	long
;	O
const	O
char	O
*	O
def_canon_charset	pointer
;	O
message_list_ty	struct
*	O
empty_list	pointer
;	O
def	pointer
=	O
remove_obsoletes	function
(	O
read_catalog_file	function
(	O
fn1	pointer
,	O
input_syntax	pointer
)	O
)	O
;	O
ref	pointer
=	O
remove_obsoletes	function
(	O
read_catalog_file	function
(	O
fn2	pointer
,	O
input_syntax	pointer
)	O
)	O
;	O
{	O
bool	bool
was_utf8	bool
=	O
false	int
;	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
ref	pointer
->	O
nitems	long
;	O
k	long
++	O
)	O
{	O
message_list_ty	struct
*	O
mlp	pointer
=	O
ref	pointer
->	O
item	pointer
[	O
k	long
]	O
->	O
messages	pointer
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
mlp	pointer
->	O
nitems	long
;	O
j	long
++	O
)	O
if	O
(	O
is_header	O
(	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
)	O
)	O
{	O
const	O
char	O
*	O
header	pointer
=	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
->	O
msgstr	pointer
;	O
if	O
(	O
header	pointer
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
charsetstr	pointer
=	O
c_strstr	function
(	O
header	pointer
,	O
"charset="	pointer
)	O
;	O
if	O
(	O
charsetstr	pointer
!=	O
NULL	O
)	O
{	O
size_t	long
len	long
;	O
charsetstr	pointer
+=	O
strlen	function
(	O
"charset="	pointer
)	O
;	O
len	long
=	O
strcspn	function
(	O
charsetstr	pointer
,	O
" \t\n"	pointer
)	O
;	O
if	O
(	O
len	long
==	O
strlen	function
(	O
"UTF-8"	pointer
)	O
&&	O
c_strncasecmp	function
(	O
charsetstr	pointer
,	O
"UTF-8"	pointer
,	O
len	long
)	O
==	O
0	int
)	O
was_utf8	bool
=	O
true	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
was_utf8	bool
)	O
def	pointer
=	O
iconv_msgdomain_list	function
(	O
def	pointer
,	O
"UTF-8"	pointer
,	O
true	int
,	O
fn1	pointer
)	O
;	O
}	O
if	O
(	O
use_fuzzy_matching	bool
)	O
{	O
def_canon_charset	pointer
=	O
def	pointer
->	O
encoding	pointer
;	O
if	O
(	O
def_canon_charset	pointer
==	O
NULL	O
)	O
{	O
char	O
*	O
charset	pointer
=	O
NULL	O
;	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
def	pointer
->	O
nitems	long
;	O
k	long
++	O
)	O
{	O
message_list_ty	struct
*	O
mlp	pointer
=	O
def	pointer
->	O
item	pointer
[	O
k	long
]	O
->	O
messages	pointer
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
mlp	pointer
->	O
nitems	long
;	O
j	long
++	O
)	O
if	O
(	O
is_header	O
(	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
)	O
&&	O
!	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
->	O
obsolete	bool
)	O
{	O
const	O
char	O
*	O
header	pointer
=	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
->	O
msgstr	pointer
;	O
if	O
(	O
header	pointer
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
charsetstr	pointer
=	O
c_strstr	function
(	O
header	pointer
,	O
"charset="	pointer
)	O
;	O
if	O
(	O
charsetstr	pointer
!=	O
NULL	O
)	O
{	O
size_t	long
len	long
;	O
charsetstr	pointer
+=	O
strlen	function
(	O
"charset="	pointer
)	O
;	O
len	long
=	O
strcspn	function
(	O
charsetstr	pointer
,	O
" \t\n"	pointer
)	O
;	O
charset	pointer
=	O
(	O
char	O
*	O
)	O
xmalloca	O
(	O
len	long
+	O
1	int
)	O
;	O
memcpy	function
(	O
charset	pointer
,	O
charsetstr	pointer
,	O
len	long
)	O
;	O
charset	pointer
[	O
len	long
]	O
=	O
'\0'	O
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
charset	pointer
!=	O
NULL	O
)	O
break	O
;	O
}	O
if	O
(	O
charset	pointer
!=	O
NULL	O
)	O
def_canon_charset	pointer
=	O
po_charset_canonicalize	function
(	O
charset	pointer
)	O
;	O
if	O
(	O
def_canon_charset	pointer
==	O
NULL	O
)	O
def_canon_charset	pointer
=	O
po_charset_ascii	pointer
;	O
}	O
}	O
else	O
def_canon_charset	pointer
=	O
NULL	O
;	O
empty_list	pointer
=	O
message_list_alloc	function
(	O
false	int
)	O
;	O
nerrors	pointer
=	O
0	int
;	O
if	O
(	O
!	O
multi_domain_mode	bool
)	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
ref	pointer
->	O
nitems	long
;	O
k	long
++	O
)	O
{	O
const	O
char	O
*	O
domain	pointer
=	O
ref	pointer
->	O
item	pointer
[	O
k	long
]	O
->	O
domain	pointer
;	O
message_list_ty	struct
*	O
refmlp	pointer
=	O
ref	pointer
->	O
item	pointer
[	O
k	long
]	O
->	O
messages	pointer
;	O
message_list_ty	struct
*	O
defmlp	pointer
;	O
message_fuzzy_index_ty	struct
*	O
defmlp_findex	pointer
;	O
defmlp	pointer
=	O
msgdomain_list_sublist	function
(	O
def	pointer
,	O
domain	pointer
,	O
false	int
)	O
;	O
if	O
(	O
defmlp	pointer
==	O
NULL	O
)	O
defmlp	pointer
=	O
empty_list	pointer
;	O
defmlp_findex	pointer
=	O
NULL	O
;	O
match_domain	function
(	O
fn1	pointer
,	O
fn2	pointer
,	O
defmlp	pointer
,	O
&	O
defmlp_findex	pointer
,	O
def_canon_charset	pointer
,	O
refmlp	pointer
,	O
&	O
nerrors	pointer
)	O
;	O
if	O
(	O
defmlp_findex	pointer
!=	O
NULL	O
)	O
message_fuzzy_index_free	function
(	O
defmlp_findex	pointer
)	O
;	O
}	O
else	O
{	O
message_list_ty	struct
*	O
refmlp	pointer
=	O
ref	pointer
->	O
item	pointer
[	O
0	int
]	O
->	O
messages	pointer
;	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
def	pointer
->	O
nitems	long
;	O
k	long
++	O
)	O
{	O
message_list_ty	struct
*	O
defmlp	pointer
=	O
def	pointer
->	O
item	pointer
[	O
k	long
]	O
->	O
messages	pointer
;	O
if	O
(	O
k	long
>	O
0	int
||	O
defmlp	pointer
->	O
nitems	long
>	O
0	int
)	O
{	O
message_fuzzy_index_ty	struct
*	O
defmlp_findex	pointer
=	O
NULL	O
;	O
match_domain	function
(	O
fn1	pointer
,	O
fn2	pointer
,	O
defmlp	pointer
,	O
&	O
defmlp_findex	pointer
,	O
def_canon_charset	pointer
,	O
refmlp	pointer
,	O
&	O
nerrors	pointer
)	O
;	O
if	O
(	O
defmlp_findex	pointer
!=	O
NULL	O
)	O
message_fuzzy_index_free	function
(	O
defmlp_findex	pointer
)	O
;	O
}	O
}	O
}	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
def	pointer
->	O
nitems	long
;	O
++	O
k	long
)	O
{	O
message_list_ty	struct
*	O
defmlp	pointer
=	O
def	pointer
->	O
item	pointer
[	O
k	long
]	O
->	O
messages	pointer
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
defmlp	pointer
->	O
nitems	long
;	O
j	long
++	O
)	O
{	O
message_ty	struct
*	O
defmsg	pointer
=	O
defmlp	pointer
->	O
item	pointer
[	O
j	long
]	O
;	O
if	O
(	O
!	O
defmsg	pointer
->	O
used	int
)	O
po_gram_error_at_line	function
(	O
&	O
defmsg	pointer
->	O
pos	struct
,	O
_	O
(	O
"warning: this message is not used"	pointer
)	O
)	O
;	O
}	O
}	O
if	O
(	O
nerrors	pointer
>	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
ngettext	function
(	O
"found %d fatal error"	pointer
,	O
"found %d fatal errors"	pointer
,	O
nerrors	pointer
)	O
,	O
nerrors	pointer
)	O
;	O
}	O
