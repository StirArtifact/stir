error_t	O
S_socket_connect2	function
(	O
struct	O
sock_user	struct
*	O
user1	pointer
,	O
struct	O
sock_user	struct
*	O
user2	pointer
)	O
{	O
error_t	O
err	O
;	O
if	O
(	O
!	O
user1	pointer
||	O
!	O
user2	pointer
)	O
return	O
EOPNOTSUPP	O
;	O
err	O
=	O
sock_connect	function
(	O
user1	pointer
->	O
sock	pointer
,	O
user2	pointer
->	O
sock	pointer
)	O
;	O
if	O
(	O
!	O
err	O
&&	O
user1	pointer
->	O
sock	pointer
->	O
pipe_class	pointer
->	O
flags	int
&	O
PIPE_CLASS_CONNECTIONLESS	O
)	O
err	O
=	O
sock_connect	function
(	O
user2	pointer
->	O
sock	pointer
,	O
user1	pointer
->	O
sock	pointer
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
user2	pointer
->	O
pi	struct
.	O
port_right	O
)	O
;	O
return	O
err	O
;	O
}	O
static	O
error_t	O
ensure_connq	function
(	O
struct	O
sock	pointer
*	O
sock	pointer
)	O
{	O
error_t	O
err	O
=	O
0	int
;	O
pthread_mutex_lock	function
(	O
&	O
sock	pointer
->	O
lock	union
)	O
;	O
if	O
(	O
!	O
sock	pointer
->	O
listen_queue	pointer
)	O
err	O
=	O
connq_create	function
(	O
&	O
sock	pointer
->	O
listen_queue	pointer
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
sock	pointer
->	O
lock	union
)	O
;	O
return	O
err	O
;	O
}	O
error_t	O
S_socket_listen	function
(	O
struct	O
sock_user	struct
*	O
user	pointer
,	O
int	O
queue_limit	int
)	O
{	O
error_t	O
err	O
;	O
if	O
(	O
!	O
user	pointer
)	O
return	O
EOPNOTSUPP	O
;	O
if	O
(	O
queue_limit	int
<	O
0	int
)	O
return	O
EINVAL	O
;	O
err	O
=	O
ensure_connq	function
(	O
user	pointer
->	O
sock	pointer
)	O
;	O
if	O
(	O
!	O
err	O
)	O
err	O
=	O
connq_set_length	function
(	O
user	pointer
->	O
sock	pointer
->	O
listen_queue	pointer
,	O
queue_limit	int
)	O
;	O
return	O
err	O
;	O
}	O
error_t	O
S_socket_connect	function
(	O
struct	O
sock_user	struct
*	O
user	pointer
,	O
struct	O
addr	pointer
*	O
addr	pointer
)	O
{	O
error_t	O
err	O
;	O
struct	O
sock	pointer
*	O
peer	pointer
;	O
if	O
(	O
!	O
addr	pointer
)	O
return	O
ECONNREFUSED	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
(	O
(	O
struct	O
port_info	O
*	O
)	O
addr	pointer
)	O
->	O
port_right	O
)	O
;	O
if	O
(	O
!	O
user	pointer
)	O
return	O
EOPNOTSUPP	O
;	O
err	O
=	O
addr_get_sock	function
(	O
addr	pointer
,	O
&	O
peer	pointer
)	O
;	O
if	O
(	O
err	O
==	O
EADDRNOTAVAIL	O
)	O
err	O
=	O
ECONNREFUSED	O
;	O
else	O
if	O
(	O
!	O
err	O
)	O
{	O
struct	O
sock	pointer
*	O
sock	pointer
=	O
user	pointer
->	O
sock	pointer
;	O
struct	O
connq	O
*	O
cq	pointer
=	O
peer	pointer
->	O
listen_queue	pointer
;	O
if	O
(	O
sock	pointer
->	O
pipe_class	pointer
->	O
flags	int
&	O
PIPE_CLASS_CONNECTIONLESS	O
)	O
err	O
=	O
sock_connect	function
(	O
sock	pointer
,	O
peer	pointer
)	O
;	O
else	O
if	O
(	O
cq	pointer
)	O
{	O
pthread_mutex_lock	function
(	O
&	O
sock	pointer
->	O
lock	union
)	O
;	O
if	O
(	O
sock	pointer
->	O
connect_queue	pointer
)	O
err	O
=	O
EALREADY	O
;	O
else	O
if	O
(	O
sock	pointer
->	O
flags	int
&	O
PFLOCAL_SOCK_CONNECTED	int
)	O
err	O
=	O
EISCONN	O
;	O
else	O
{	O
sock	pointer
->	O
connect_queue	pointer
=	O
cq	pointer
;	O
pthread_mutex_unlock	function
(	O
&	O
sock	pointer
->	O
lock	union
)	O
;	O
err	O
=	O
connq_connect	function
(	O
peer	pointer
->	O
listen_queue	pointer
,	O
sock	pointer
->	O
flags	int
&	O
PFLOCAL_SOCK_NONBLOCK	int
)	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
struct	O
sock	pointer
*	O
server	pointer
;	O
err	O
=	O
sock_clone	function
(	O
peer	pointer
,	O
&	O
server	pointer
)	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
err	O
=	O
sock_connect	function
(	O
sock	pointer
,	O
server	pointer
)	O
;	O
if	O
(	O
!	O
err	O
)	O
connq_connect_complete	function
(	O
peer	pointer
->	O
listen_queue	pointer
,	O
server	pointer
)	O
;	O
else	O
sock_free	function
(	O
server	pointer
)	O
;	O
}	O
if	O
(	O
err	O
)	O
connq_connect_cancel	function
(	O
peer	pointer
->	O
listen_queue	pointer
)	O
;	O
}	O
pthread_mutex_lock	function
(	O
&	O
sock	pointer
->	O
lock	union
)	O
;	O
sock	pointer
->	O
connect_queue	pointer
=	O
NULL	O
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
sock	pointer
->	O
lock	union
)	O
;	O
}	O
else	O
err	O
=	O
ECONNREFUSED	O
;	O
sock_deref	function
(	O
peer	pointer
)	O
;	O
}	O
return	O
err	O
;	O
}	O
error_t	O
S_socket_accept	function
(	O
struct	O
sock_user	struct
*	O
user	pointer
,	O
mach_port_t	O
*	O
port	pointer
,	O
mach_msg_type_name_t	O
*	O
port_type	pointer
,	O
mach_port_t	O
*	O
peer_addr_port	pointer
,	O
mach_msg_type_name_t	O
*	O
peer_addr_port_type	pointer
)	O
{	O
error_t	O
err	O
;	O
struct	O
sock	pointer
*	O
sock	pointer
;	O
if	O
(	O
!	O
user	pointer
)	O
return	O
EOPNOTSUPP	O
;	O
sock	pointer
=	O
user	pointer
->	O
sock	pointer
;	O
err	O
=	O
ensure_connq	function
(	O
sock	pointer
)	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
struct	O
timespec	struct
noblock	struct
=	O
{	O
0	int
,	O
0	int
}	O
;	O
struct	O
sock	pointer
*	O
peer_sock	pointer
;	O
err	O
=	O
connq_listen	function
(	O
sock	pointer
->	O
listen_queue	pointer
,	O
(	O
sock	pointer
->	O
flags	int
&	O
PFLOCAL_SOCK_NONBLOCK	int
)	O
?	O
&	O
noblock	struct
:	O
NULL	O
,	O
&	O
peer_sock	pointer
)	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
struct	O
addr	pointer
*	O
peer_addr	pointer
;	O
*	O
port_type	pointer
=	O
MACH_MSG_TYPE_MAKE_SEND	O
;	O
err	O
=	O
sock_create_port	function
(	O
peer_sock	pointer
,	O
port	pointer
)	O
;	O
if	O
(	O
!	O
err	O
)	O
err	O
=	O
sock_get_addr	function
(	O
peer_sock	pointer
,	O
&	O
peer_addr	pointer
)	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
*	O
peer_addr_port	pointer
=	O
ports_get_right	function
(	O
peer_addr	pointer
)	O
;	O
*	O
peer_addr_port_type	pointer
=	O
MACH_MSG_TYPE_MAKE_SEND	O
;	O
ports_port_deref	function
(	O
peer_addr	pointer
)	O
;	O
}	O
else	O
{	O
}	O
}	O
}	O
return	O
err	O
;	O
}	O
error_t	O
S_socket_bind	function
(	O
struct	O
sock_user	struct
*	O
user	pointer
,	O
struct	O
addr	pointer
*	O
addr	pointer
)	O
{	O
if	O
(	O
!	O
addr	pointer
)	O
return	O
EADDRNOTAVAIL	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
(	O
(	O
struct	O
port_info	O
*	O
)	O
addr	pointer
)	O
->	O
port_right	O
)	O
;	O
if	O
(	O
!	O
user	pointer
)	O
return	O
EOPNOTSUPP	O
;	O
return	O
sock_bind	function
(	O
user	pointer
->	O
sock	pointer
,	O
addr	pointer
)	O
;	O
}	O
error_t	O
S_socket_shutdown	function
(	O
struct	O
sock_user	struct
*	O
user	pointer
,	O
int	O
what	int
)	O
{	O
if	O
(	O
!	O
user	pointer
)	O
return	O
EOPNOTSUPP	O
;	O
sock_shutdown	function
(	O
user	pointer
->	O
sock	pointer
,	O
(	O
what	int
!=	O
1	int
?	O
PFLOCAL_SOCK_SHUTDOWN_READ	int
:	O
0	int
)	O
|	O
(	O
what	int
!=	O
0	int
?	O
PFLOCAL_SOCK_SHUTDOWN_WRITE	int
:	O
0	int
)	O
)	O
;	O
return	O
0	int
;	O
}	O
error_t	O
S_socket_name	function
(	O
struct	O
sock_user	struct
*	O
user	pointer
,	O
mach_port_t	O
*	O
addr_port	pointer
,	O
mach_msg_type_name_t	O
*	O
addr_port_type	pointer
)	O
{	O
error_t	O
err	O
;	O
struct	O
addr	pointer
*	O
addr	pointer
;	O
if	O
(	O
!	O
user	pointer
)	O
return	O
EOPNOTSUPP	O
;	O
err	O
=	O
sock_get_addr	function
(	O
user	pointer
->	O
sock	pointer
,	O
&	O
addr	pointer
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
*	O
addr_port	pointer
=	O
ports_get_right	function
(	O
addr	pointer
)	O
;	O
*	O
addr_port_type	pointer
=	O
MACH_MSG_TYPE_MAKE_SEND	O
;	O
ports_port_deref	function
(	O
addr	pointer
)	O
;	O
return	O
0	int
;	O
}	O
error_t	O
S_socket_peername	function
(	O
struct	O
sock_user	struct
*	O
user	pointer
,	O
mach_port_t	O
*	O
addr_port	pointer
,	O
mach_msg_type_name_t	O
*	O
addr_port_type	pointer
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
if	O
(	O
!	O
user	pointer
)	O
return	O
EOPNOTSUPP	O
;	O
*	O
addr_port_type	pointer
=	O
MACH_MSG_TYPE_MAKE_SEND	O
;	O
}	O
error_t	O
S_socket_send	function
(	O
struct	O
sock_user	struct
*	O
user	pointer
,	O
struct	O
addr	pointer
*	O
dest_addr	pointer
,	O
int	O
flags	int
,	O
char	O
*	O
data	pointer
,	O
size_t	long
data_len	long
,	O
mach_port_t	O
*	O
ports	pointer
,	O
size_t	long
num_ports	long
,	O
char	O
*	O
control	pointer
,	O
size_t	long
control_len	long
,	O
size_t	long
*	O
amount	pointer
)	O
{	O
error_t	O
err	O
=	O
0	int
;	O
int	O
noblock	struct
;	O
struct	O
pipe	pointer
*	O
pipe	pointer
;	O
struct	O
sock	pointer
*	O
sock	pointer
,	O
*	O
dest_sock	pointer
;	O
struct	O
addr	pointer
*	O
source_addr	pointer
;	O
if	O
(	O
!	O
user	pointer
)	O
return	O
EOPNOTSUPP	O
;	O
sock	pointer
=	O
user	pointer
->	O
sock	pointer
;	O
if	O
(	O
flags	int
&	O
MSG_OOB	int
)	O
return	O
EOPNOTSUPP	O
;	O
if	O
(	O
dest_addr	pointer
)	O
{	O
err	O
=	O
addr_get_sock	function
(	O
dest_addr	pointer
,	O
&	O
dest_sock	pointer
)	O
;	O
if	O
(	O
err	O
==	O
EADDRNOTAVAIL	O
)	O
err	O
=	O
ECONNREFUSED	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
if	O
(	O
sock	pointer
->	O
pipe_class	pointer
!=	O
dest_sock	pointer
->	O
pipe_class	pointer
)	O
err	O
=	O
EINVAL	O
;	O
}	O
else	O
dest_sock	pointer
=	O
0	int
;	O
if	O
(	O
!	O
err	O
&&	O
sock	pointer
->	O
pipe_class	pointer
->	O
flags	int
&	O
PIPE_CLASS_CONNECTIONLESS	O
)	O
err	O
=	O
sock_get_addr	function
(	O
sock	pointer
,	O
&	O
source_addr	pointer
)	O
;	O
else	O
source_addr	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
if	O
(	O
dest_sock	pointer
)	O
err	O
=	O
sock_acquire_read_pipe	function
(	O
dest_sock	pointer
,	O
&	O
pipe	pointer
)	O
;	O
else	O
err	O
=	O
sock_acquire_write_pipe	function
(	O
sock	pointer
,	O
&	O
pipe	pointer
)	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
noblock	struct
=	O
(	O
user	pointer
->	O
sock	pointer
->	O
flags	int
&	O
PFLOCAL_SOCK_NONBLOCK	int
)	O
||	O
(	O
flags	int
&	O
MSG_DONTWAIT	int
)	O
;	O
err	O
=	O
pipe_send	function
(	O
pipe	pointer
,	O
noblock	struct
,	O
source_addr	pointer
,	O
data	pointer
,	O
data_len	long
,	O
control	pointer
,	O
control_len	long
,	O
ports	pointer
,	O
num_ports	long
,	O
amount	pointer
)	O
;	O
if	O
(	O
dest_sock	pointer
)	O
pipe_release_reader	function
(	O
pipe	pointer
)	O
;	O
else	O
pipe_release_writer	function
(	O
pipe	pointer
)	O
;	O
}	O
if	O
(	O
err	O
)	O
{	O
if	O
(	O
source_addr	pointer
)	O
ports_port_deref	function
(	O
source_addr	pointer
)	O
;	O
while	O
(	O
num_ports	long
--	O
>	O
0	int
)	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
*	O
ports	pointer
++	O
)	O
;	O
}	O
}	O
if	O
(	O
dest_sock	pointer
)	O
sock_deref	function
(	O
dest_sock	pointer
)	O
;	O
return	O
err	O
;	O
}	O
error_t	O
S_socket_recv	function
(	O
struct	O
sock_user	struct
*	O
user	pointer
,	O
mach_port_t	O
*	O
addr	pointer
,	O
mach_msg_type_name_t	O
*	O
addr_type	pointer
,	O
int	O
in_flags	int
,	O
char	O
*	O
*	O
data	pointer
,	O
size_t	long
*	O
data_len	long
,	O
mach_port_t	O
*	O
*	O
ports	pointer
,	O
mach_msg_type_name_t	O
*	O
ports_type	pointer
,	O
size_t	long
*	O
num_ports	long
,	O
char	O
*	O
*	O
control	pointer
,	O
size_t	long
*	O
control_len	long
,	O
int	O
*	O
out_flags	pointer
,	O
size_t	long
amount	pointer
)	O
{	O
error_t	O
err	O
;	O
unsigned	O
flags	int
;	O
int	O
noblock	struct
;	O
struct	O
pipe	pointer
*	O
pipe	pointer
;	O
void	O
*	O
source_addr	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
user	pointer
)	O
return	O
EOPNOTSUPP	O
;	O
if	O
(	O
in_flags	int
&	O
MSG_OOB	int
)	O
return	O
EINVAL	O
;	O
flags	int
=	O
in_flags	int
&	O
MSG_PEEK	int
;	O
err	O
=	O
sock_acquire_read_pipe	function
(	O
user	pointer
->	O
sock	pointer
,	O
&	O
pipe	pointer
)	O
;	O
if	O
(	O
err	O
==	O
EPIPE	O
)	O
{	O
*	O
data_len	long
=	O
0	int
;	O
if	O
(	O
num_ports	long
)	O
*	O
num_ports	long
=	O
0	int
;	O
if	O
(	O
control_len	long
)	O
*	O
control_len	long
=	O
0	int
;	O
}	O
else	O
if	O
(	O
!	O
err	O
)	O
{	O
noblock	struct
=	O
(	O
user	pointer
->	O
sock	pointer
->	O
flags	int
&	O
PFLOCAL_SOCK_NONBLOCK	int
)	O
||	O
(	O
in_flags	int
&	O
MSG_DONTWAIT	int
)	O
;	O
err	O
=	O
pipe_recv	function
(	O
pipe	pointer
,	O
noblock	struct
,	O
&	O
flags	int
,	O
&	O
source_addr	pointer
,	O
data	pointer
,	O
data_len	long
,	O
amount	pointer
,	O
control	pointer
,	O
control_len	long
,	O
ports	pointer
,	O
num_ports	long
)	O
;	O
pipe_release_reader	function
(	O
pipe	pointer
)	O
;	O
}	O
if	O
(	O
!	O
err	O
)	O
{	O
*	O
addr_type	pointer
=	O
MACH_MSG_TYPE_MAKE_SEND	O
;	O
*	O
ports_type	pointer
=	O
MACH_MSG_TYPE_MOVE_SEND	O
;	O
if	O
(	O
source_addr	pointer
)	O
{	O
*	O
addr	pointer
=	O
ports_get_right	function
(	O
source_addr	pointer
)	O
;	O
ports_port_deref	function
(	O
source_addr	pointer
)	O
;	O
}	O
else	O
*	O
addr	pointer
=	O
MACH_PORT_NULL	O
;	O
}	O
*	O
out_flags	pointer
=	O
0	int
;	O
return	O
err	O
;	O
}	O
error_t	O
S_socket_getopt	function
(	O
struct	O
sock_user	struct
*	O
user	pointer
,	O
int	O
level	int
,	O
int	O
opt	int
,	O
char	O
*	O
*	O
value	pointer
,	O
size_t	long
*	O
value_len	pointer
)	O
{	O
int	O
ret	int
=	O
0	int
;	O
if	O
(	O
!	O
user	pointer
)	O
return	O
EOPNOTSUPP	O
;	O
pthread_mutex_lock	function
(	O
&	O
user	pointer
->	O
sock	pointer
->	O
lock	union
)	O
;	O
switch	O
(	O
level	int
)	O
{	O
case	O
SOL_SOCKET	int
:	O
switch	O
(	O
opt	int
)	O
{	O
case	O
SO_TYPE	int
:	O
if	O
(	O
*	O
value_len	pointer
<	O
sizeof	O
(	O
int	O
)	O
)	O
{	O
ret	int
=	O
EINVAL	O
;	O
break	O
;	O
}	O
*	O
(	O
int	O
*	O
)	O
*	O
value	pointer
=	O
user	pointer
->	O
sock	pointer
->	O
pipe_class	pointer
->	O
sock_type	O
;	O
*	O
value_len	pointer
=	O
sizeof	O
(	O
int	O
)	O
;	O
break	O
;	O
case	O
SO_ERROR	int
:	O
if	O
(	O
*	O
value_len	pointer
<	O
sizeof	O
(	O
short	O
)	O
)	O
{	O
*	O
(	O
char	O
*	O
)	O
*	O
value	pointer
=	O
0	int
;	O
*	O
value_len	pointer
=	O
sizeof	O
(	O
char	O
)	O
;	O
}	O
else	O
if	O
(	O
*	O
value_len	pointer
<	O
sizeof	O
(	O
int	O
)	O
)	O
{	O
*	O
(	O
short	O
*	O
)	O
*	O
value	pointer
=	O
0	int
;	O
*	O
value_len	pointer
=	O
sizeof	O
(	O
short	O
)	O
;	O
}	O
else	O
{	O
*	O
(	O
int	O
*	O
)	O
*	O
value	pointer
=	O
0	int
;	O
*	O
value_len	pointer
=	O
sizeof	O
(	O
int	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
ret	int
=	O
ENOPROTOOPT	O
;	O
break	O
;	O
}	O
break	O
;	O
default	O
:	O
ret	int
=	O
ENOPROTOOPT	O
;	O
break	O
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
user	pointer
->	O
sock	pointer
->	O
lock	union
)	O
;	O
return	O
ret	int
;	O
}	O
error_t	O
S_socket_setopt	function
(	O
struct	O
sock_user	struct
*	O
user	pointer
,	O
int	O
level	int
,	O
int	O
opt	int
,	O
char	O
*	O
value	pointer
,	O
size_t	long
value_len	pointer
)	O
{	O
int	O
ret	int
=	O
0	int
;	O
if	O
(	O
!	O
user	pointer
)	O
return	O
EOPNOTSUPP	O
;	O
pthread_mutex_lock	function
(	O
&	O
user	pointer
->	O
sock	pointer
->	O
lock	union
)	O
;	O
switch	O
(	O
level	int
)	O
{	O
default	O
:	O
ret	int
=	O
ENOPROTOOPT	O
;	O
break	O
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
user	pointer
->	O
sock	pointer
->	O
lock	union
)	O
;	O
return	O
ret	int
;	O
}	O
