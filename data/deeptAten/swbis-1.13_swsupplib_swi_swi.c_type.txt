static	O
int	O
show_nopen	function
(	O
void	O
)	O
{	O
int	O
ret	int
;	O
ret	int
=	O
open	function
(	O
"/dev/null"	pointer
,	O
O_RDWR	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"fcntl error: %s\n"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
close	pointer
(	O
ret	int
)	O
;	O
return	O
ret	int
;	O
}	O
static	O
int	O
find_swdef_in_INFO	function
(	O
SWI_XFILE	struct
*	O
xfile	pointer
,	O
char	O
*	O
tag	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
int	O
ret	int
;	O
char	O
*	O
p	pointer
;	O
ret	int
=	O
-	O
1	int
;	O
p	pointer
=	O
swheader_get_object_by_tag	function
(	O
xfile	pointer
->	O
info_headerM	pointer
,	O
SW_A_control_file	pointer
,	O
tag	pointer
)	O
;	O
E_DEBUG3	O
(	O
"tag==[%s] name=[%s]"	pointer
,	O
tag	pointer
,	O
name	pointer
)	O
;	O
E_DEBUG2	O
(	O
"p=[%p]"	pointer
,	O
(	O
void	O
*	O
)	O
p	pointer
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
ret	int
=	O
p	pointer
-	O
swheader_get_image_head	function
(	O
xfile	pointer
->	O
info_headerM	pointer
)	O
;	O
E_DEBUG2	O
(	O
"ret=%d"	pointer
,	O
ret	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: error: invalid value calculated in find_swdef_in_INFO: %d\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
ret	int
)	O
;	O
ret	int
=	O
-	O
1	int
;	O
}	O
if	O
(	O
ret	int
>	O
987654321	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: error: possible invalid value calculated in find_swdef_in_INFO: %d\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
ret	int
)	O
;	O
ret	int
=	O
-	O
1	int
;	O
}	O
}	O
return	O
ret	int
;	O
}	O
static	O
SWPATH_EX	struct
*	O
swi_get_last_swpath_ex	function
(	O
SWI	struct
*	O
swi	pointer
)	O
{	O
SWPATH_EX	struct
*	O
ret	int
;	O
CPLOB	struct
*	O
list	pointer
=	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
exlistM	pointer
;	O
int	O
index	function
;	O
index	function
=	O
cplob_get_nused	function
(	O
list	pointer
)	O
-	O
2	int
;	O
ret	int
=	O
(	O
SWPATH_EX	struct
*	O
)	O
cplob_val	function
(	O
list	pointer
,	O
index	function
)	O
;	O
return	O
ret	int
;	O
}	O
static	O
SWI_BASE	struct
*	O
find_object_by_swsel	function
(	O
void	O
*	O
parent	pointer
,	O
char	O
*	O
swsel	pointer
,	O
char	O
*	O
number	pointer
,	O
int	O
*	O
p_index	pointer
)	O
{	O
int	O
i	int
;	O
SWI_PACKAGE	struct
*	O
package	pointer
;	O
SWI_BASE	struct
*	O
object	pointer
;	O
char	O
*	O
verid_delim	pointer
;	O
if	O
(	O
p_index	pointer
)	O
*	O
p_index	pointer
=	O
-	O
1	int
;	O
package	pointer
=	O
(	O
SWI_PACKAGE	struct
*	O
)	O
(	O
parent	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
SWI_MAX_OBJ	int
;	O
i	int
++	O
)	O
{	O
object	pointer
=	O
(	O
SWI_BASE	struct
*	O
)	O
(	O
&	O
(	O
package	pointer
->	O
swi_coM	array
[	O
i	int
]	O
->	O
p_baseM	struct
)	O
)	O
;	O
if	O
(	O
object	pointer
)	O
{	O
verid_delim	pointer
=	O
strchr	function
(	O
swsel	pointer
,	O
','	O
)	O
;	O
if	O
(	O
!	O
verid_delim	pointer
)	O
{	O
verid_delim	pointer
=	O
swsel	pointer
+	O
strlen	function
(	O
swsel	pointer
)	O
;	O
}	O
if	O
(	O
strncmp	function
(	O
swsel	pointer
,	O
object	pointer
->	O
b_tagM	pointer
,	O
(	O
size_t	long
)	O
(	O
verid_delim	pointer
-	O
swsel	pointer
)	O
)	O
==	O
0	int
)	O
{	O
if	O
(	O
number	pointer
&&	O
object	pointer
->	O
numberM	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
number	pointer
,	O
object	pointer
->	O
numberM	pointer
)	O
!=	O
0	int
)	O
{	O
continue	O
;	O
}	O
}	O
if	O
(	O
p_index	pointer
)	O
*	O
p_index	pointer
=	O
i	int
;	O
return	O
object	pointer
;	O
}	O
}	O
else	O
{	O
return	O
NULL	O
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
static	O
int	O
need_new_pfiles	function
(	O
SWI	struct
*	O
swi	pointer
)	O
{	O
SWPATH	struct
*	O
swpath	pointer
=	O
swi	pointer
->	O
swpathM	pointer
;	O
char	O
*	O
pfiles_dir	pointer
;	O
char	O
*	O
pfiles_attribute	pointer
;	O
char	O
*	O
prod_dir	pointer
;	O
pfiles_dir	pointer
=	O
swpath_get_pfiles	function
(	O
swpath	pointer
)	O
;	O
prod_dir	pointer
=	O
swpath_get_product_control_dir	function
(	O
swpath	pointer
)	O
;	O
pfiles_attribute	pointer
=	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
pfiles_attributeM	pointer
;	O
if	O
(	O
(	O
strlen	function
(	O
pfiles_dir	pointer
)	O
&&	O
strcmp	function
(	O
pfiles_attribute	pointer
,	O
pfiles_dir	pointer
)	O
)	O
||	O
(	O
strlen	function
(	O
prod_dir	pointer
)	O
==	O
0	int
)	O
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
strlen	function
(	O
pfiles_dir	pointer
)	O
&&	O
strcmp	function
(	O
pfiles_attribute	pointer
,	O
pfiles_dir	pointer
)	O
==	O
0	int
&&	O
strlen	function
(	O
swpath_get_basename	function
(	O
swpath	pointer
)	O
)	O
)	O
{	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
swi_audit_all_compatible_products	function
(	O
SWI	struct
*	O
swi	pointer
,	O
SWUTS	struct
*	O
target_uts	pointer
,	O
int	O
*	O
pn_products	pointer
,	O
int	O
*	O
p_swi_index	pointer
)	O
{	O
SWI_PRODUCT	struct
*	O
product	pointer
;	O
SWHEADER	struct
*	O
global_index	pointer
;	O
SWUTS	struct
*	O
product_uts	pointer
;	O
int	O
product_number	int
;	O
int	O
ret	int
;	O
int	O
n_matches	int
;	O
if	O
(	O
p_swi_index	pointer
)	O
*	O
p_swi_index	pointer
=	O
-	O
1	int
;	O
if	O
(	O
pn_products	pointer
)	O
*	O
pn_products	pointer
=	O
0	int
;	O
n_matches	int
=	O
0	int
;	O
global_index	pointer
=	O
swi_get_global_index_header	function
(	O
swi	pointer
)	O
;	O
swheader_store_state	function
(	O
global_index	pointer
,	O
NULL	O
)	O
;	O
product_number	int
=	O
0	int
;	O
while	O
(	O
(	O
product	pointer
=	O
swi_package_get_product	function
(	O
swi	pointer
->	O
swi_pkgM	pointer
,	O
product_number	int
++	O
)	O
)	O
)	O
{	O
if	O
(	O
pn_products	pointer
)	O
++	O
(	O
*	O
pn_products	pointer
)	O
;	O
swheader_reset	function
(	O
global_index	pointer
)	O
;	O
swheader_set_current_offset	function
(	O
global_index	pointer
,	O
product	pointer
->	O
p_baseM	struct
.	O
header_indexM	int
)	O
;	O
product_uts	pointer
=	O
swuts_create	function
(	O
)	O
;	O
swi_get_uts_attributes_from_current	function
(	O
swi	pointer
,	O
product_uts	pointer
,	O
global_index	pointer
)	O
;	O
ret	int
=	O
swuts_compare	function
(	O
target_uts	pointer
,	O
product_uts	pointer
,	O
0	int
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
{	O
n_matches	int
++	O
;	O
product	pointer
->	O
is_compatibleM	int
=	O
SW_TRUE	int
;	O
if	O
(	O
p_swi_index	pointer
)	O
*	O
p_swi_index	pointer
=	O
product_number	int
-	O
1	int
;	O
}	O
swuts_delete	function
(	O
product_uts	pointer
)	O
;	O
}	O
swheader_restore_state	function
(	O
global_index	pointer
,	O
NULL	O
)	O
;	O
return	O
n_matches	int
;	O
}	O
void	O
swi_set_utility_id	function
(	O
SWI	struct
*	O
swi	pointer
,	O
int	O
swc_u_id	int
)	O
{	O
swi	pointer
->	O
swc_idM	int
=	O
swc_u_id	int
;	O
}	O
int	O
swi_is_definition_file	function
(	O
SWI	struct
*	O
swi	pointer
,	O
char	O
*	O
name	pointer
,	O
int	O
*	O
swdeffile_type_p	pointer
)	O
{	O
char	O
*	O
s	pointer
;	O
if	O
(	O
(	O
s	pointer
=	O
strstr	function
(	O
name	pointer
,	O
"/"	pointer
SW_A_INDEX	pointer
)	O
)	O
&&	O
*	O
(	O
s	pointer
+	O
6	int
)	O
==	O
'\0'	O
)	O
{	O
if	O
(	O
swi_is_global_index	function
(	O
swi	pointer
->	O
swpathM	pointer
,	O
name	pointer
)	O
)	O
{	O
if	O
(	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
did_parse_def_fileM	int
)	O
{	O
swi_com_fatal_error	function
(	O
"loc=index"	pointer
,	O
__LINE__	O
)	O
;	O
}	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
did_parse_def_fileM	int
=	O
1	int
;	O
*	O
swdeffile_type_p	pointer
=	O
SWPARSE_SWDEF_FILETYPE_INDEX	int
;	O
return	O
1	int
;	O
}	O
else	O
{	O
;	O
}	O
}	O
else	O
if	O
(	O
(	O
s	pointer
=	O
strstr	function
(	O
name	pointer
,	O
"/"	pointer
SW_A_INFO	pointer
)	O
)	O
&&	O
*	O
(	O
s	pointer
+	O
5	int
)	O
==	O
'\0'	O
)	O
{	O
if	O
(	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
current_xfileM	pointer
->	O
did_parse_def_fileM	int
)	O
{	O
swi_com_fatal_error	function
(	O
"loc=info"	pointer
,	O
__LINE__	O
)	O
;	O
}	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
current_xfileM	pointer
->	O
did_parse_def_fileM	int
=	O
1	int
;	O
*	O
swdeffile_type_p	pointer
=	O
SWPARSE_SWDEF_FILETYPE_INFO	int
;	O
return	O
1	int
;	O
}	O
*	O
swdeffile_type_p	pointer
=	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
void	O
swi_xfile_add_control_script	function
(	O
SWI	struct
*	O
swi	pointer
,	O
SWI_XFILE	struct
*	O
xfile	pointer
,	O
char	O
*	O
name	pointer
,	O
int	O
fd	int
,	O
char	O
*	O
tag	pointer
)	O
{	O
SWI_CONTROL_SCRIPT	struct
*	O
sc	pointer
;	O
SWI_FILE_MEMBER	struct
*	O
s	pointer
;	O
int	O
offset	int
;	O
sc	pointer
=	O
swi_control_script_create	function
(	O
)	O
;	O
s	pointer
=	O
swi_xfile_construct_file_member	function
(	O
xfile	pointer
,	O
name	pointer
,	O
fd	int
,	O
swi	pointer
->	O
xformatM	pointer
->	O
swvarfsM	pointer
)	O
;	O
sc	pointer
->	O
baseM	struct
.	O
b_tagM	pointer
=	O
strdup	function
(	O
tag	pointer
)	O
;	O
swi_com_check_clean_relative_path	function
(	O
sc	pointer
->	O
baseM	struct
.	O
b_tagM	pointer
)	O
;	O
sc	pointer
->	O
afileM	pointer
=	O
s	pointer
;	O
sc	pointer
->	O
swi_xfileM	pointer
=	O
(	O
void	O
*	O
)	O
xfile	pointer
;	O
offset	int
=	O
find_swdef_in_INFO	function
(	O
xfile	pointer
,	O
tag	pointer
,	O
name	pointer
)	O
;	O
sc	pointer
->	O
INFO_offsetM	int
=	O
offset	int
;	O
if	O
(	O
offset	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"warning: find_swdef_in_INFO returned %d\n"	pointer
,	O
offset	int
)	O
;	O
}	O
swi_add_script	function
(	O
xfile	pointer
->	O
swi_scM	pointer
,	O
sc	pointer
)	O
;	O
return	O
;	O
}	O
void	O
swi_xfile_add_file_member	function
(	O
SWI	struct
*	O
swi	pointer
,	O
SWI_XFILE	struct
*	O
xfile	pointer
,	O
char	O
*	O
name	pointer
,	O
int	O
fd	int
)	O
{	O
SWI_FILE_MEMBER	struct
*	O
s	pointer
;	O
s	pointer
=	O
swi_xfile_construct_file_member	function
(	O
xfile	pointer
,	O
name	pointer
,	O
fd	int
,	O
swi	pointer
->	O
xformatM	pointer
->	O
swvarfsM	pointer
)	O
;	O
cplob_add_nta	function
(	O
xfile	pointer
->	O
archive_filesM	pointer
,	O
(	O
char	O
*	O
)	O
s	pointer
)	O
;	O
return	O
;	O
}	O
int	O
swi_get_distribution_attributes	function
(	O
SWI	struct
*	O
swi	pointer
,	O
SWHEADER	struct
*	O
swheader	pointer
)	O
{	O
char	O
*	O
value	int
;	O
char	O
*	O
obj	pointer
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swi_com_header_manifold_reset	function
(	O
swheader	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
obj	pointer
=	O
swheader_get_object_by_tag	function
(	O
swheader	pointer
,	O
SW_A_distribution	pointer
,	O
"*"	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
!	O
obj	pointer
)	O
{	O
return	O
-	O
1	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
value	int
=	O
swheader_get_single_attribute_value	function
(	O
swheader	pointer
,	O
SW_A_dfiles	pointer
)	O
;	O
if	O
(	O
value	int
)	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
dfiles_attributeM	pointer
=	O
strdup	function
(	O
value	int
)	O
;	O
else	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
dfiles_attributeM	pointer
=	O
strdup	function
(	O
SW_A_dfiles	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
value	int
=	O
swheader_get_single_attribute_value	function
(	O
swheader	pointer
,	O
SW_A_pfiles	pointer
)	O
;	O
if	O
(	O
value	int
)	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
pfiles_attributeM	pointer
=	O
strdup	function
(	O
value	int
)	O
;	O
else	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
pfiles_attributeM	pointer
=	O
strdup	function
(	O
SW_A_pfiles	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
swi_package_delete	function
(	O
SWI_PACKAGE	struct
*	O
s	pointer
)	O
{	O
SWPATH_EX	struct
*	O
expath	pointer
;	O
int	O
index	function
;	O
int	O
i	int
;	O
index	function
=	O
0	int
;	O
expath	pointer
=	O
(	O
SWPATH_EX	struct
*	O
)	O
cplob_val	function
(	O
s	pointer
->	O
exlistM	pointer
,	O
index	function
++	O
)	O
;	O
while	O
(	O
expath	pointer
)	O
{	O
swpath_delete_export	function
(	O
expath	pointer
)	O
;	O
expath	pointer
=	O
(	O
SWPATH_EX	struct
*	O
)	O
cplob_val	function
(	O
s	pointer
->	O
exlistM	pointer
,	O
index	function
++	O
)	O
;	O
}	O
free	function
(	O
(	O
void	O
*	O
)	O
(	O
cplob_release	function
(	O
s	pointer
->	O
exlistM	pointer
)	O
)	O
)	O
;	O
if	O
(	O
s	pointer
->	O
catalog_entryM	pointer
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
free	function
(	O
s	pointer
->	O
catalog_entryM	pointer
)	O
;	O
if	O
(	O
s	pointer
->	O
target_pathM	pointer
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
free	function
(	O
s	pointer
->	O
target_pathM	pointer
)	O
;	O
if	O
(	O
s	pointer
->	O
target_hostM	pointer
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
free	function
(	O
s	pointer
->	O
target_hostM	pointer
)	O
;	O
if	O
(	O
s	pointer
->	O
installed_software_catalogM	pointer
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
free	function
(	O
s	pointer
->	O
installed_software_catalogM	pointer
)	O
;	O
}	O
if	O
(	O
s	pointer
->	O
dfilesM	pointer
)	O
swi_xfile_delete	function
(	O
s	pointer
->	O
dfilesM	pointer
)	O
;	O
if	O
(	O
s	pointer
->	O
baseM	struct
.	O
global_headerM	pointer
)	O
swheader_close	function
(	O
s	pointer
->	O
baseM	struct
.	O
global_headerM	pointer
)	O
;	O
if	O
(	O
s	pointer
->	O
swdef_fdM	int
>	O
0	int
)	O
uxfio_close	function
(	O
s	pointer
->	O
swdef_fdM	int
)	O
;	O
if	O
(	O
s	pointer
->	O
installer_sigM	pointer
)	O
free	function
(	O
s	pointer
->	O
installer_sigM	pointer
)	O
;	O
s	pointer
->	O
swdef_fdM	int
=	O
-	O
1	int
;	O
swi_scripts_delete	function
(	O
s	pointer
->	O
swi_scM	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
SWI_MAX_OBJ	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
s	pointer
->	O
swi_coM	array
[	O
i	int
]	O
)	O
swi_product_delete	function
(	O
s	pointer
->	O
swi_coM	array
[	O
i	int
]	O
)	O
;	O
}	O
free	function
(	O
s	pointer
)	O
;	O
return	O
;	O
}	O
SWI_PACKAGE	struct
*	O
swi_package_create	function
(	O
void	O
)	O
{	O
SWI_PACKAGE	struct
*	O
s	pointer
=	O
(	O
SWI_PACKAGE	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
SWI_PACKAGE	struct
)	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swi_com_assert_pointer	function
(	O
(	O
void	O
*	O
)	O
s	pointer
,	O
__FILE__	O
,	O
__LINE__	O
)	O
;	O
swiInitListOfObjects	function
(	O
(	O
void	O
*	O
*	O
)	O
(	O
s	pointer
->	O
swi_coM	array
)	O
)	O
;	O
swi_vbase_init	function
(	O
s	pointer
,	O
SWI_I_TYPE_PACKAGE	char
,	O
NULL	O
,	O
NULL	O
)	O
;	O
s	pointer
->	O
swi_scM	pointer
=	O
swi_scripts_create	function
(	O
)	O
;	O
s	pointer
->	O
exlistM	pointer
=	O
cplob_open	function
(	O
1	int
)	O
;	O
s	pointer
->	O
baseM	struct
.	O
global_headerM	pointer
=	O
NULL	O
;	O
s	pointer
->	O
swdef_fdM	int
=	O
-	O
1	int
;	O
s	pointer
->	O
current_productM	pointer
=	O
NULL	O
;	O
s	pointer
->	O
dfilesM	pointer
=	O
NULL	O
;	O
s	pointer
->	O
current_xfileM	pointer
=	O
NULL	O
;	O
s	pointer
->	O
did_parse_def_fileM	int
=	O
0	int
;	O
s	pointer
->	O
prev_swpath_exM	pointer
=	O
NULL	O
;	O
s	pointer
->	O
catalog_lengthM	int
=	O
0	int
;	O
s	pointer
->	O
catalog_entryM	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
s	pointer
->	O
target_pathM	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
s	pointer
->	O
target_hostM	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
s	pointer
->	O
installed_software_catalogM	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
s	pointer
->	O
locationM	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
s	pointer
->	O
qualifierM	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
s	pointer
->	O
is_minimal_layoutM	int
=	O
0	int
;	O
s	pointer
->	O
installer_sigM	pointer
=	O
NULL	O
;	O
s	pointer
->	O
installed_catalog_ownerM	pointer
=	O
NULL	O
;	O
s	pointer
->	O
installed_catalog_groupM	pointer
=	O
NULL	O
;	O
s	pointer
->	O
installed_catalog_modeM	int
=	O
(	O
mode_t	int
)	O
(	O
0	int
)	O
;	O
return	O
s	pointer
;	O
}	O
void	O
swi_delete	function
(	O
SWI	struct
*	O
s	pointer
)	O
{	O
E_DEBUG2	O
(	O
"Entering swi_delete LOWEST FD=%d"	pointer
,	O
show_nopen	function
(	O
)	O
)	O
;	O
swbis_devnull_close	O
(	O
s	pointer
->	O
nullfdM	int
)	O
;	O
swi_package_delete	function
(	O
s	pointer
->	O
swi_pkgM	pointer
)	O
;	O
swicol_delete	function
(	O
s	pointer
->	O
swicolM	pointer
)	O
;	O
E_DEBUG2	O
(	O
"LOWEST FD=%d"	pointer
,	O
show_nopen	function
(	O
)	O
)	O
;	O
if	O
(	O
s	pointer
->	O
distdataM	pointer
)	O
{	O
swi_distdata_delete	function
(	O
s	pointer
->	O
distdataM	pointer
)	O
;	O
}	O
E_DEBUG2	O
(	O
"LOWEST FD=%d"	pointer
,	O
show_nopen	function
(	O
)	O
)	O
;	O
if	O
(	O
s	pointer
->	O
xformat_close_on_deleteM	int
)	O
{	O
E_DEBUG	O
(	O
"calling xformat_close"	pointer
)	O
;	O
xformat_close	function
(	O
s	pointer
->	O
xformatM	pointer
)	O
;	O
}	O
E_DEBUG2	O
(	O
"LOWEST FD=%d"	pointer
,	O
show_nopen	function
(	O
)	O
)	O
;	O
if	O
(	O
s	pointer
->	O
swvarfs_close_on_deleteM	int
)	O
{	O
E_DEBUG	O
(	O
"calling swvarfs_close"	pointer
)	O
;	O
swvarfs_close	function
(	O
s	pointer
->	O
swvarfsM	pointer
)	O
;	O
}	O
E_DEBUG2	O
(	O
"LOWEST FD=%d"	pointer
,	O
show_nopen	function
(	O
)	O
)	O
;	O
if	O
(	O
s	pointer
->	O
uinformat_close_on_deleteM	int
)	O
{	O
E_DEBUG	O
(	O
"calling uinfile_close"	pointer
)	O
;	O
uinfile_close	function
(	O
s	pointer
->	O
uinformatM	pointer
)	O
;	O
}	O
E_DEBUG2	O
(	O
"LEAVING swi_delete: LOWEST FD=%d"	pointer
,	O
show_nopen	function
(	O
)	O
)	O
;	O
uxfio_close	function
(	O
s	pointer
->	O
excluded_file_conflicts_fdM	int
)	O
;	O
uxfio_close	function
(	O
s	pointer
->	O
replaced_file_conflicts_fdM	int
)	O
;	O
uxfio_close	function
(	O
s	pointer
->	O
pending_file_conflicts_fdM	int
)	O
;	O
free	function
(	O
s	pointer
)	O
;	O
}	O
SWI	struct
*	O
swi_create	function
(	O
void	O
)	O
{	O
SWI	struct
*	O
swi	pointer
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swi	pointer
=	O
(	O
SWI	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
SWI	struct
)	O
)	O
;	O
swi_com_assert_pointer	function
(	O
(	O
void	O
*	O
)	O
swi	pointer
,	O
__FILE__	O
,	O
__LINE__	O
)	O
;	O
swi	pointer
->	O
xformatM	pointer
=	O
NULL	O
;	O
swi	pointer
->	O
swvarfsM	pointer
=	O
NULL	O
;	O
swi	pointer
->	O
uinformatM	pointer
=	O
NULL	O
;	O
swi	pointer
->	O
swpathM	pointer
=	O
NULL	O
;	O
swi	pointer
->	O
swi_pkgM	pointer
=	O
swi_package_create	function
(	O
)	O
;	O
swi	pointer
->	O
nullfdM	int
=	O
swbis_devnull_open	O
(	O
"/dev/null"	pointer
,	O
O_RDWR	int
,	O
0	int
)	O
;	O
memset	function
(	O
swi	pointer
->	O
tarbufM	array
,	O
'\0'	O
,	O
sizeof	O
(	O
swi	pointer
->	O
tarbufM	array
)	O
)	O
;	O
swi	pointer
->	O
distdataM	pointer
=	O
NULL	O
;	O
swi	pointer
->	O
opt_alt_catalog_rootM	int
=	O
0	int
;	O
swi	pointer
->	O
swicolM	pointer
=	O
swicol_create	function
(	O
)	O
;	O
swi	pointer
->	O
exported_catalog_prefixM	pointer
=	O
NULL	O
;	O
swi	pointer
->	O
verboseM	int
=	O
0	int
;	O
swi	pointer
->	O
debug_eventsM	int
=	O
0	int
;	O
swi	pointer
->	O
target_version_idM	pointer
=	O
swverid_open	function
(	O
"HOST"	pointer
,	O
NULL	O
)	O
;	O
swi	pointer
->	O
does_have_payloadM	int
=	O
-	O
1	int
;	O
swi	pointer
->	O
xformat_close_on_deleteM	int
=	O
0	int
;	O
swi	pointer
->	O
swvarfs_close_on_deleteM	int
=	O
0	int
;	O
swi	pointer
->	O
uinformat_close_on_deleteM	int
=	O
0	int
;	O
swi	pointer
->	O
excluded_file_conflicts_fdM	int
=	O
-	O
1	int
;	O
swi	pointer
->	O
replaced_file_conflicts_fdM	int
=	O
-	O
1	int
;	O
swi	pointer
->	O
pending_file_conflicts_fdM	int
=	O
-	O
1	int
;	O
return	O
swi	pointer
;	O
}	O
void	O
swi_product_delete	function
(	O
SWI_PRODUCT	struct
*	O
s	pointer
)	O
{	O
int	O
i	int
;	O
if	O
(	O
s	pointer
->	O
p_baseM	struct
.	O
b_tagM	pointer
)	O
free	function
(	O
s	pointer
->	O
p_baseM	struct
.	O
b_tagM	pointer
)	O
;	O
if	O
(	O
s	pointer
->	O
package_pathM	pointer
)	O
free	function
(	O
s	pointer
->	O
package_pathM	pointer
)	O
;	O
if	O
(	O
s	pointer
->	O
control_dirM	pointer
)	O
free	function
(	O
s	pointer
->	O
control_dirM	pointer
)	O
;	O
if	O
(	O
s	pointer
->	O
filesetsM	pointer
)	O
strar_close	function
(	O
s	pointer
->	O
filesetsM	pointer
)	O
;	O
if	O
(	O
s	pointer
->	O
xfileM	pointer
)	O
swi_xfile_delete	function
(	O
s	pointer
->	O
xfileM	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
SWI_MAX_OBJ	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
s	pointer
->	O
swi_coM	array
[	O
i	int
]	O
)	O
swi_xfile_delete	function
(	O
s	pointer
->	O
swi_coM	array
[	O
i	int
]	O
)	O
;	O
}	O
free	function
(	O
s	pointer
)	O
;	O
}	O
SWI_PRODUCT	struct
*	O
swi_product_create	function
(	O
SWHEADER	struct
*	O
global_index_header	pointer
,	O
SWPATH_EX	struct
*	O
current	pointer
)	O
{	O
SWI_PRODUCT	struct
*	O
s	pointer
=	O
(	O
SWI_PRODUCT	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
SWI_PRODUCT	struct
)	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swi_com_assert_pointer	function
(	O
(	O
void	O
*	O
)	O
s	pointer
,	O
__FILE__	O
,	O
__LINE__	O
)	O
;	O
swi_vbase_init	function
(	O
s	pointer
,	O
SWI_I_TYPE_PROD	char
,	O
global_index_header	pointer
,	O
current	pointer
)	O
;	O
s	pointer
->	O
package_pathM	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
s	pointer
->	O
control_dirM	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
s	pointer
->	O
filesetsM	pointer
=	O
(	O
STRAR	struct
*	O
)	O
NULL	O
;	O
swiInitListOfObjects	function
(	O
(	O
void	O
*	O
*	O
)	O
(	O
s	pointer
->	O
swi_coM	array
)	O
)	O
;	O
s	pointer
->	O
xfileM	pointer
=	O
NULL	O
;	O
s	pointer
->	O
is_selectedM	int
=	O
1	int
;	O
s	pointer
->	O
is_compatibleM	int
=	O
0	int
;	O
return	O
s	pointer
;	O
}	O
void	O
swi_product_add_fileset	function
(	O
SWI_PRODUCT	struct
*	O
thisis	pointer
,	O
SWI_XFILE	struct
*	O
v	int
)	O
{	O
E_DEBUG	O
(	O
"ENTERING"	pointer
)	O
;	O
swiAddObjectToList	function
(	O
(	O
void	O
*	O
*	O
)	O
(	O
thisis	pointer
->	O
swi_coM	array
)	O
,	O
(	O
void	O
*	O
)	O
v	int
)	O
;	O
E_DEBUG	O
(	O
"LEAVING"	pointer
)	O
;	O
}	O
void	O
swi_package_add_product	function
(	O
SWI_PACKAGE	struct
*	O
thisis	pointer
,	O
SWI_PRODUCT	struct
*	O
v	int
)	O
{	O
E_DEBUG	O
(	O
"ENTERING"	pointer
)	O
;	O
swiAddObjectToList	function
(	O
(	O
void	O
*	O
*	O
)	O
(	O
thisis	pointer
->	O
swi_coM	array
)	O
,	O
(	O
void	O
*	O
)	O
v	int
)	O
;	O
E_DEBUG	O
(	O
"LEAVING"	pointer
)	O
;	O
}	O
int	O
swi_store_file	function
(	O
SWI	struct
*	O
swi	pointer
,	O
char	O
*	O
name	pointer
,	O
SWI_XFILE	struct
*	O
current_xfile	pointer
)	O
{	O
int	O
fd	int
;	O
char	O
*	O
tag	pointer
;	O
XFORMAT	struct
*	O
xformat	pointer
=	O
swi	pointer
->	O
xformatM	pointer
;	O
E_DEBUG2	O
(	O
"ENTERING name=[%s]"	pointer
,	O
name	pointer
)	O
;	O
swi_com_assert_pointer	function
(	O
(	O
void	O
*	O
)	O
current_xfile	pointer
,	O
__FILE__	O
,	O
__LINE__	O
)	O
;	O
fd	int
=	O
xformat_u_open_file	function
(	O
xformat	pointer
,	O
name	pointer
)	O
;	O
swi_com_assert_value	function
(	O
fd	int
>=	O
0	int
,	O
__FILE__	O
,	O
__LINE__	O
)	O
;	O
if	O
(	O
swi_afile_is_ieee_control_script	function
(	O
name	pointer
)	O
)	O
{	O
tag	pointer
=	O
swlib_basename	function
(	O
NULL	O
,	O
name	pointer
)	O
;	O
swi_xfile_add_control_script	function
(	O
swi	pointer
,	O
current_xfile	pointer
,	O
name	pointer
,	O
fd	int
,	O
tag	pointer
)	O
;	O
}	O
else	O
{	O
swi_xfile_add_file_member	function
(	O
swi	pointer
,	O
current_xfile	pointer
,	O
name	pointer
,	O
fd	int
)	O
;	O
}	O
xformat_u_close_file	function
(	O
xformat	pointer
,	O
fd	int
)	O
;	O
E_DEBUG	O
(	O
"LEAVING"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
swi_expand_shared_file_control_sripts	function
(	O
SWI	struct
*	O
swi	pointer
,	O
SWI_XFILE	struct
*	O
xfile	pointer
)	O
{	O
SWHEADER	struct
*	O
swheader	pointer
=	O
xfile	pointer
->	O
info_headerM	pointer
;	O
SWI_CONTROL_SCRIPT	struct
*	O
script	pointer
;	O
SWI_CONTROL_SCRIPT	struct
*	O
new_script	pointer
;	O
SWI_FILE_MEMBER	struct
*	O
afile	pointer
;	O
char	O
*	O
next_line	pointer
;	O
char	O
*	O
path_attr	pointer
;	O
char	O
*	O
path_value	pointer
;	O
char	O
*	O
tag_attr	pointer
;	O
char	O
*	O
tag_value	pointer
;	O
E_DEBUG	O
(	O
"ENTERING"	pointer
)	O
;	O
swheader_reset	function
(	O
swheader	pointer
)	O
;	O
swheader_set_current_offset_p_value	function
(	O
swheader	pointer
,	O
0	int
)	O
;	O
next_line	pointer
=	O
swheader_get_next_object	function
(	O
swheader	pointer
,	O
(	O
int	O
)	O
UCHAR_MAX	O
,	O
(	O
int	O
)	O
UCHAR_MAX	O
)	O
;	O
while	O
(	O
next_line	pointer
)	O
{	O
swheader_goto_next_line	function
(	O
(	O
void	O
*	O
)	O
swheader	pointer
,	O
swheader_get_current_offset_p	function
(	O
swheader	pointer
)	O
,	O
SWHEADER_PEEK_NEXT	int
)	O
;	O
path_attr	pointer
=	O
swheader_get_attribute	function
(	O
swheader	pointer
,	O
SW_A_path	pointer
,	O
NULL	O
)	O
;	O
SWLIB_ASSERT	O
(	O
path_attr	pointer
!=	O
NULL	O
)	O
;	O
tag_attr	pointer
=	O
swheader_get_attribute	function
(	O
swheader	pointer
,	O
SW_A_tag	pointer
,	O
NULL	O
)	O
;	O
SWLIB_ASSERT	O
(	O
tag_attr	pointer
!=	O
NULL	O
)	O
;	O
swi_com_assert_value	function
(	O
tag_attr	pointer
!=	O
NULL	O
,	O
__FILE__	O
,	O
__LINE__	O
)	O
;	O
tag_value	pointer
=	O
swheaderline_get_value	function
(	O
tag_attr	pointer
,	O
NULL	O
)	O
;	O
path_value	pointer
=	O
swheaderline_get_value	function
(	O
path_attr	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
swi_afile_is_ieee_control_script	function
(	O
tag_value	pointer
)	O
)	O
{	O
script	pointer
=	O
swi_xfile_get_control_script_by_tag	function
(	O
xfile	pointer
,	O
tag_value	pointer
)	O
;	O
if	O
(	O
script	pointer
==	O
NULL	O
)	O
{	O
swi_com_assert_value	function
(	O
path_value	pointer
!=	O
NULL	O
,	O
__FILE__	O
,	O
__LINE__	O
)	O
;	O
script	pointer
=	O
swi_xfile_get_control_script_by_path	function
(	O
xfile	pointer
,	O
path_value	pointer
)	O
;	O
if	O
(	O
script	pointer
)	O
{	O
afile	pointer
=	O
script	pointer
->	O
afileM	pointer
;	O
}	O
else	O
{	O
afile	pointer
=	O
swi_xfile_get_control_file_by_path	function
(	O
xfile	pointer
,	O
path_value	pointer
)	O
;	O
}	O
SWLIB_ASSERT	O
(	O
afile	pointer
!=	O
NULL	O
)	O
;	O
new_script	pointer
=	O
swi_control_script_create	function
(	O
)	O
;	O
new_script	pointer
->	O
baseM	struct
.	O
b_tagM	pointer
=	O
strdup	function
(	O
tag_value	pointer
)	O
;	O
swi_com_check_clean_relative_path	function
(	O
new_script	pointer
->	O
baseM	struct
.	O
b_tagM	pointer
)	O
;	O
new_script	pointer
->	O
afileM	pointer
=	O
afile	pointer
;	O
(	O
afile	pointer
->	O
refcountM	int
)	O
++	O
;	O
swi_add_script	function
(	O
xfile	pointer
->	O
swi_scM	pointer
,	O
new_script	pointer
)	O
;	O
}	O
}	O
else	O
{	O
;	O
}	O
next_line	pointer
=	O
swheader_get_next_object	function
(	O
swheader	pointer
,	O
(	O
int	O
)	O
UCHAR_MAX	O
,	O
(	O
int	O
)	O
UCHAR_MAX	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
swi_parse_file	function
(	O
SWI	struct
*	O
swi	pointer
,	O
char	O
*	O
name	pointer
,	O
int	O
swdeffile_type	int
)	O
{	O
XFORMAT	struct
*	O
xformat	pointer
=	O
swi	pointer
->	O
xformatM	pointer
;	O
char	O
*	O
base	int
;	O
char	O
*	O
newbase	pointer
;	O
SWHEADER	struct
*	O
swheader	pointer
;	O
SWPATH	struct
*	O
swpath	pointer
=	O
swi	pointer
->	O
swpathM	pointer
;	O
int	O
ret	int
;	O
int	O
ufd	int
;	O
int	O
curfd	int
=	O
swlib_open_memfd	function
(	O
)	O
;	O
int	O
ofd	int
=	O
swlib_open_memfd	function
(	O
)	O
;	O
int	O
len	int
;	O
E_DEBUG	O
(	O
"ENTERING"	pointer
)	O
;	O
ufd	int
=	O
xformat_u_open_file	function
(	O
xformat	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
ufd	int
<	O
0	int
)	O
{	O
swi_com_fatal_error	function
(	O
__FILE__	O
,	O
__LINE__	O
)	O
;	O
}	O
swlib_pipe_pump	function
(	O
curfd	int
,	O
ufd	int
)	O
;	O
xformat_u_close_file	function
(	O
xformat	pointer
,	O
ufd	int
)	O
;	O
uxfio_lseek	function
(	O
curfd	int
,	O
(	O
off_t	long
)	O
0	int
,	O
SEEK_SET	int
)	O
;	O
ret	int
=	O
sw_yyparse	function
(	O
curfd	int
,	O
ofd	int
,	O
name	pointer
,	O
0	int
,	O
SWPARSE_FORM_MKUP_LEN	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
ret	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: error parsing %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
name	pointer
)	O
;	O
return	O
ret	int
;	O
swi_com_fatal_error	function
(	O
__FILE__	O
,	O
__LINE__	O
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
uxfio_write	function
(	O
ofd	int
,	O
"\x00"	pointer
,	O
1	int
)	O
;	O
base	int
=	O
swi_com_get_fd_mem	function
(	O
ofd	int
,	O
&	O
len	int
)	O
;	O
newbase	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
len	int
)	O
;	O
swi_com_assert_pointer	function
(	O
(	O
void	O
*	O
)	O
(	O
newbase	pointer
)	O
,	O
__FILE__	O
,	O
__LINE__	O
)	O
;	O
memcpy	function
(	O
newbase	pointer
,	O
base	int
,	O
len	int
)	O
;	O
swi_com_close_memfd	function
(	O
ofd	int
)	O
;	O
swheader	pointer
=	O
swheader_open	function
(	O
(	O
char	O
*	O
(	O
*	O
)	O
(	O
void	O
*	O
,	O
int	O
*	O
,	O
int	O
)	O
)	O
(	O
NULL	O
)	O
,	O
NULL	O
)	O
;	O
swheader_set_image_head	function
(	O
swheader	pointer
,	O
newbase	pointer
)	O
;	O
uxfio_lseek	function
(	O
curfd	int
,	O
(	O
off_t	long
)	O
0	int
,	O
SEEK_SET	int
)	O
;	O
swi_com_assert_pointer	function
(	O
(	O
void	O
*	O
)	O
(	O
swi	pointer
->	O
swi_pkgM	pointer
)	O
,	O
__FILE__	O
,	O
__LINE__	O
)	O
;	O
switch	O
(	O
swdeffile_type	int
)	O
{	O
case	O
SWPARSE_SWDEF_FILETYPE_INFO	int
:	O
E_DEBUG	O
(	O
"case SWPARSE_SWDEF_FILETYPE_INFO"	pointer
)	O
;	O
E_DEBUG2	O
(	O
"xfile: %p"	pointer
,	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
current_xfileM	pointer
)	O
;	O
swi_com_assert_pointer	function
(	O
(	O
void	O
*	O
)	O
(	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
current_xfileM	pointer
)	O
,	O
__FILE__	O
,	O
__LINE__	O
)	O
;	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
current_xfileM	pointer
->	O
info_headerM	pointer
=	O
swheader	pointer
;	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
current_xfileM	pointer
->	O
INFO_header_indexM	int
=	O
0	int
;	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
current_xfileM	pointer
->	O
swdef_fdM	int
=	O
curfd	int
;	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
current_xfileM	pointer
->	O
did_parse_def_fileM	int
=	O
1	int
;	O
swheader_set_current_offset_p	function
(	O
swheader	pointer
,	O
&	O
(	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
current_xfileM	pointer
->	O
INFO_header_indexM	int
)	O
)	O
;	O
swheader_set_current_offset_p_value	function
(	O
swheader	pointer
,	O
0	int
)	O
;	O
swheader_reset	function
(	O
swheader	pointer
)	O
;	O
swheader_goto_next_line	function
(	O
swheader	pointer
,	O
swheader_get_current_offset_p	function
(	O
swheader	pointer
)	O
,	O
SWHEADER_GET_NEXT	int
)	O
;	O
break	O
;	O
case	O
SWPARSE_SWDEF_FILETYPE_INDEX	int
:	O
E_DEBUG	O
(	O
"SWPARSE_SWDEF_FILETYPE_INDEX"	pointer
)	O
;	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
baseM	struct
.	O
global_headerM	pointer
=	O
swheader	pointer
;	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
baseM	struct
.	O
header_indexM	int
=	O
0	int
;	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
swdef_fdM	int
=	O
curfd	int
;	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
did_parse_def_fileM	int
=	O
1	int
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swheader_set_current_offset_p	function
(	O
swheader	pointer
,	O
&	O
(	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
baseM	struct
.	O
header_indexM	int
)	O
)	O
;	O
swheader_set_current_offset_p_value	function
(	O
swheader	pointer
,	O
0	int
)	O
;	O
swheader_reset	function
(	O
swheader	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swheader_goto_next_line	function
(	O
swheader	pointer
,	O
swheader_get_current_offset_p	function
(	O
swheader	pointer
)	O
,	O
SWHEADER_GET_NEXT	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
swi_get_distribution_attributes	function
(	O
swi	pointer
,	O
swheader	pointer
)	O
!=	O
0	int
)	O
swi_com_fatal_error	function
(	O
__FILE__	O
,	O
__LINE__	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swpath_set_dfiles	function
(	O
swpath	pointer
,	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
dfiles_attributeM	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swpath_set_pfiles	function
(	O
swpath	pointer
,	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
pfiles_attributeM	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
break	O
;	O
default	O
:	O
swi_com_fatal_error	function
(	O
__FILE__	O
":invalid case"	pointer
,	O
__LINE__	O
)	O
;	O
break	O
;	O
}	O
E_DEBUG	O
(	O
"LEAVING"	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
swi_update_current_context	function
(	O
SWI	struct
*	O
swi	pointer
,	O
SWPATH_EX	struct
*	O
swpath_ex	pointer
)	O
{	O
return	O
0	int
;	O
}	O
int	O
swi_add_swpath_ex	function
(	O
SWI	struct
*	O
swi	pointer
)	O
{	O
CPLOB	struct
*	O
list	pointer
=	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
exlistM	pointer
;	O
SWPATH	struct
*	O
swpath	pointer
=	O
swi	pointer
->	O
swpathM	pointer
;	O
SWPATH_EX	struct
*	O
swpath_ex	pointer
;	O
E_DEBUG	O
(	O
"ENTERING"	pointer
)	O
;	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
prev_swpath_exM	pointer
=	O
swi_get_last_swpath_ex	function
(	O
swi	pointer
)	O
;	O
swpath_ex	pointer
=	O
swpath_create_export	function
(	O
swpath	pointer
)	O
;	O
swi_com_assert_pointer	function
(	O
(	O
void	O
*	O
)	O
swpath_ex	pointer
,	O
__FILE__	O
,	O
__LINE__	O
)	O
;	O
cplob_add_nta	function
(	O
list	pointer
,	O
(	O
char	O
*	O
)	O
(	O
swpath_ex	pointer
)	O
)	O
;	O
E_DEBUG	O
(	O
"LEAVING"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
swi_handle_control_transition	function
(	O
SWI	struct
*	O
swi	pointer
)	O
{	O
SWI_PACKAGE	struct
*	O
package	pointer
=	O
swi	pointer
->	O
swi_pkgM	pointer
;	O
SWPATH_EX	struct
*	O
current	pointer
;	O
SWPATH_EX	struct
*	O
previous	pointer
;	O
SWI_XFILE	struct
*	O
fileset	pointer
;	O
SWI_XFILE	struct
*	O
pfiles	pointer
;	O
int	O
tret	int
;	O
int	O
detect	int
;	O
int	O
found_edge	int
=	O
0	int
;	O
E_DEBUG	O
(	O
"ENTERING"	pointer
)	O
;	O
previous	pointer
=	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
prev_swpath_exM	pointer
;	O
current	pointer
=	O
swi_get_last_swpath_ex	function
(	O
swi	pointer
)	O
;	O
E_DEBUG	O
(	O
"ENTERING"	pointer
)	O
;	O
if	O
(	O
!	O
previous	pointer
)	O
{	O
previous	pointer
=	O
swpath_create_export	function
(	O
(	O
SWPATH	struct
*	O
)	O
NULL	O
)	O
;	O
}	O
detect	int
=	O
swi_com_field_edge_detect	function
(	O
current	pointer
->	O
dfiles	pointer
,	O
previous	pointer
->	O
dfiles	pointer
)	O
;	O
if	O
(	O
found_edge	int
==	O
0	int
&&	O
detect	int
)	O
{	O
E_DEBUG	O
(	O
"New dfiles"	pointer
)	O
;	O
package	pointer
->	O
dfilesM	pointer
=	O
swi_xfile_create	function
(	O
SWI_XFILE_TYPE_DFILES	int
,	O
SWI_INDEX_HEADER	O
(	O
swi	pointer
)	O
,	O
current	pointer
)	O
;	O
package	pointer
->	O
current_xfileM	pointer
=	O
package	pointer
->	O
dfilesM	pointer
;	O
package	pointer
->	O
dfilesM	pointer
->	O
package_pathM	pointer
=	O
strdup	function
(	O
current	pointer
->	O
pkgpathname	pointer
)	O
;	O
E_DEBUG2	O
(	O
"Setting Current XFILE (dfiles) [%p]"	pointer
,	O
(	O
void	O
*	O
)	O
(	O
package	pointer
->	O
current_xfileM	pointer
)	O
)	O
;	O
found_edge	int
=	O
1	int
;	O
}	O
detect	int
=	O
swi_com_field_edge_detect	function
(	O
current	pointer
->	O
product_control_dir	pointer
,	O
previous	pointer
->	O
product_control_dir	pointer
)	O
;	O
if	O
(	O
found_edge	int
==	O
0	int
&&	O
detect	int
)	O
{	O
E_DEBUG	O
(	O
"New Product"	pointer
)	O
;	O
package	pointer
->	O
current_productM	pointer
=	O
swi_product_create	function
(	O
SWI_INDEX_HEADER	O
(	O
swi	pointer
)	O
,	O
current	pointer
)	O
;	O
swi_package_add_product	function
(	O
package	pointer
,	O
package	pointer
->	O
current_productM	pointer
)	O
;	O
package	pointer
->	O
current_xfileM	pointer
=	O
NULL	O
;	O
package	pointer
->	O
current_productM	pointer
->	O
package_pathM	pointer
=	O
strdup	function
(	O
current	pointer
->	O
pkgpathname	pointer
)	O
;	O
if	O
(	O
(	O
tret	int
=	O
need_new_pfiles	function
(	O
swi	pointer
)	O
)	O
>	O
0	int
)	O
{	O
pfiles	pointer
=	O
swi_xfile_create	function
(	O
SWI_XFILE_TYPE_FILESET	int
,	O
SWI_INDEX_HEADER	O
(	O
swi	pointer
)	O
,	O
current	pointer
)	O
;	O
pfiles	pointer
->	O
package_pathM	pointer
=	O
strdup	function
(	O
current	pointer
->	O
pkgpathname	pointer
)	O
;	O
package	pointer
->	O
current_productM	pointer
->	O
xfileM	pointer
=	O
pfiles	pointer
;	O
package	pointer
->	O
current_xfileM	pointer
=	O
pfiles	pointer
;	O
}	O
else	O
if	O
(	O
tret	int
<	O
0	int
)	O
{	O
SWI_internal_error	O
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
;	O
}	O
E_DEBUG2	O
(	O
"Setting Current Product [%p]"	pointer
,	O
(	O
void	O
*	O
)	O
(	O
package	pointer
->	O
current_productM	pointer
)	O
)	O
;	O
E_DEBUG2	O
(	O
"Setting Current XFILE (NULL) [%p]"	pointer
,	O
(	O
void	O
*	O
)	O
(	O
package	pointer
->	O
current_xfileM	pointer
)	O
)	O
;	O
found_edge	int
=	O
1	int
;	O
}	O
detect	int
=	O
swi_com_field_edge_detect_fileset	function
(	O
current	pointer
,	O
previous	pointer
)	O
;	O
if	O
(	O
found_edge	int
==	O
0	int
&&	O
detect	int
)	O
{	O
E_DEBUG	O
(	O
"New Fileset"	pointer
)	O
;	O
fileset	pointer
=	O
swi_xfile_create	function
(	O
SWI_XFILE_TYPE_FILESET	int
,	O
SWI_INDEX_HEADER	O
(	O
swi	pointer
)	O
,	O
current	pointer
)	O
;	O
swi_product_add_fileset	function
(	O
package	pointer
->	O
current_productM	pointer
,	O
fileset	pointer
)	O
;	O
package	pointer
->	O
current_xfileM	pointer
=	O
fileset	pointer
;	O
package	pointer
->	O
current_xfileM	pointer
->	O
package_pathM	pointer
=	O
strdup	function
(	O
current	pointer
->	O
pkgpathname	pointer
)	O
;	O
E_DEBUG2	O
(	O
"        Current Product [%p]"	pointer
,	O
(	O
void	O
*	O
)	O
(	O
package	pointer
->	O
current_productM	pointer
)	O
)	O
;	O
E_DEBUG2	O
(	O
"Setting Current XFILE (fileset) [%p]"	pointer
,	O
(	O
void	O
*	O
)	O
(	O
package	pointer
->	O
current_xfileM	pointer
)	O
)	O
;	O
found_edge	int
=	O
1	int
;	O
}	O
detect	int
=	O
swi_com_field_edge_detect	function
(	O
current	pointer
->	O
pfiles	pointer
,	O
previous	pointer
->	O
pfiles	pointer
)	O
;	O
if	O
(	O
found_edge	int
==	O
0	int
&&	O
detect	int
)	O
{	O
E_DEBUG	O
(	O
"New pfiles"	pointer
)	O
;	O
pfiles	pointer
=	O
swi_xfile_create	function
(	O
SWI_XFILE_TYPE_PFILES	int
,	O
SWI_INDEX_HEADER	O
(	O
swi	pointer
)	O
,	O
current	pointer
)	O
;	O
if	O
(	O
package	pointer
->	O
current_productM	pointer
==	O
NULL	O
)	O
{	O
package	pointer
->	O
current_productM	pointer
=	O
swi_product_create	function
(	O
SWI_INDEX_HEADER	O
(	O
swi	pointer
)	O
,	O
current	pointer
)	O
;	O
swi_package_add_product	function
(	O
package	pointer
,	O
package	pointer
->	O
current_productM	pointer
)	O
;	O
package	pointer
->	O
current_xfileM	pointer
=	O
NULL	O
;	O
}	O
pfiles	pointer
->	O
package_pathM	pointer
=	O
strdup	function
(	O
current	pointer
->	O
pkgpathname	pointer
)	O
;	O
package	pointer
->	O
current_productM	pointer
->	O
xfileM	pointer
=	O
pfiles	pointer
;	O
package	pointer
->	O
current_xfileM	pointer
=	O
pfiles	pointer
;	O
E_DEBUG2	O
(	O
"   Current Product [%p]"	pointer
,	O
(	O
void	O
*	O
)	O
(	O
package	pointer
->	O
current_productM	pointer
)	O
)	O
;	O
E_DEBUG2	O
(	O
"Setting Current XFILE (pfiles) [%p]"	pointer
,	O
(	O
void	O
*	O
)	O
(	O
package	pointer
->	O
current_xfileM	pointer
)	O
)	O
;	O
found_edge	int
=	O
1	int
;	O
}	O
E_DEBUG2	O
(	O
"LEAVING return value = [%d]"	pointer
,	O
found_edge	int
)	O
;	O
return	O
found_edge	int
;	O
}	O
int	O
swi_decode_catalog	function
(	O
SWI	struct
*	O
swi	pointer
)	O
{	O
XFORMAT	struct
*	O
xformat	pointer
=	O
swi	pointer
->	O
xformatM	pointer
;	O
SWPATH	struct
*	O
swpath	pointer
=	O
swi	pointer
->	O
swpathM	pointer
;	O
STROB	struct
*	O
tmp	pointer
=	O
strob_open	function
(	O
24	int
)	O
;	O
struct	O
stat	struct
st	pointer
;	O
int	O
nullfd	int
;	O
int	O
copyret	int
=	O
0	int
;	O
int	O
ret	int
;	O
int	O
handle_ret	int
;	O
int	O
swpath_ret	int
;	O
int	O
retval	int
;	O
int	O
is_catalog	int
;	O
char	O
*	O
name	pointer
;	O
int	O
swdef_ret	int
=	O
0	int
;	O
int	O
swdeffile_type	int
;	O
int	O
ifd	int
;	O
int	O
offset	int
=	O
0	int
;	O
int	O
oldoffset	int
=	O
0	int
;	O
int	O
catalog_start_offset	int
=	O
-	O
1	int
;	O
int	O
catalog_end_offset	int
=	O
0	int
;	O
retval	int
=	O
0	int
;	O
nullfd	int
=	O
swi	pointer
->	O
nullfdM	int
;	O
if	O
(	O
nullfd	int
<	O
0	int
)	O
return	O
-	O
22	int
;	O
ifd	int
=	O
xformat_get_ifd	function
(	O
xformat	pointer
)	O
;	O
name	pointer
=	O
xformat_get_next_dirent	function
(	O
xformat	pointer
,	O
&	O
st	pointer
)	O
;	O
if	O
(	O
ifd	int
>=	O
0	int
)	O
{	O
offset	int
=	O
uxfio_lseek	function
(	O
ifd	int
,	O
(	O
off_t	long
)	O
0	int
,	O
SEEK_CUR	int
)	O
;	O
}	O
while	O
(	O
name	pointer
)	O
{	O
E_DEBUG2	O
(	O
"ENTERING LOOP: name=[%s]"	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
xformat_is_end_of_archive	function
(	O
xformat	pointer
)	O
)	O
{	O
E_DEBUG	O
(	O
"EOA found before storage section: break"	pointer
)	O
;	O
retval	int
=	O
-	O
1	int
;	O
break	O
;	O
}	O
swi_com_check_clean_relative_path	function
(	O
name	pointer
)	O
;	O
E_DEBUG2	O
(	O
"name=[%s]"	pointer
,	O
name	pointer
)	O
;	O
swpath_ret	int
=	O
swpath_parse_path	function
(	O
swpath	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
swpath_ret	int
<	O
0	int
)	O
{	O
E_DEBUG	O
(	O
"swpath_parse_path error"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: error parsing pathname [%s]\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
name	pointer
)	O
;	O
retval	int
=	O
-	O
2	int
;	O
break	O
;	O
}	O
is_catalog	int
=	O
swpath_get_is_catalog	function
(	O
swpath	pointer
)	O
;	O
if	O
(	O
is_catalog	int
!=	O
SWPATH_CTYPE_STORE	int
)	O
{	O
if	O
(	O
is_catalog	int
==	O
1	int
&&	O
catalog_start_offset	int
<	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
catalog_start_offset	int
=	O
offset	int
;	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
catalog_start_offsetM	int
=	O
offset	int
;	O
}	O
if	O
(	O
swi	pointer
->	O
exported_catalog_prefixM	pointer
==	O
NULL	O
&&	O
is_catalog	int
==	O
1	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
strob_strcpy	function
(	O
tmp	pointer
,	O
swpath_get_prepath	function
(	O
swpath	pointer
)	O
)	O
;	O
swlib_unix_dircat	function
(	O
tmp	pointer
,	O
SW_A_catalog	pointer
)	O
;	O
swi	pointer
->	O
exported_catalog_prefixM	pointer
=	O
strdup	function
(	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
swi_com_check_clean_relative_path	function
(	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
}	O
swi_add_swpath_ex	function
(	O
swi	pointer
)	O
;	O
handle_ret	int
=	O
swi_handle_control_transition	function
(	O
swi	pointer
)	O
;	O
if	O
(	O
handle_ret	int
<	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swi_com_assert_pointer	function
(	O
(	O
void	O
*	O
)	O
NULL	O
,	O
__FILE__	O
,	O
__LINE__	O
)	O
;	O
}	O
if	O
(	O
swi_is_definition_file	function
(	O
swi	pointer
,	O
name	pointer
,	O
&	O
swdeffile_type	int
)	O
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swdef_ret	int
=	O
swi_parse_file	function
(	O
swi	pointer
,	O
name	pointer
,	O
swdeffile_type	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
swdef_ret	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"error parsing %s\n"	pointer
,	O
name	pointer
)	O
;	O
retval	int
=	O
-	O
3	int
;	O
break	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
copyret	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
xformat_file_has_data	function
(	O
xformat	pointer
)	O
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swi_store_file	function
(	O
swi	pointer
,	O
name	pointer
,	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
current_xfileM	pointer
)	O
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
copyret	int
=	O
0	int
;	O
;	O
}	O
if	O
(	O
copyret	int
<	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
SWI_internal_error	O
(	O
)	O
;	O
retval	int
=	O
-	O
4	int
;	O
break	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
catalog_end_offset	int
=	O
uxfio_lseek	function
(	O
ifd	int
,	O
(	O
off_t	long
)	O
0	int
,	O
SEEK_CUR	int
)	O
;	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
catalog_end_offsetM	int
=	O
catalog_end_offset	int
;	O
E_DEBUG2	O
(	O
"catalog end offset = [%d]"	pointer
,	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
catalog_end_offsetM	int
)	O
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
"STORAGE SECTION found: break"	pointer
)	O
;	O
swi	pointer
->	O
does_have_payloadM	int
=	O
1	int
;	O
break	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
oldoffset	int
=	O
offset	int
;	O
name	pointer
=	O
xformat_get_next_dirent	function
(	O
xformat	pointer
,	O
&	O
st	pointer
)	O
;	O
offset	int
=	O
uxfio_lseek	function
(	O
ifd	int
,	O
(	O
off_t	long
)	O
0	int
,	O
SEEK_CUR	int
)	O
;	O
E_DEBUG2	O
(	O
"NAME=[%s]"	pointer
,	O
name	pointer
?	O
name	pointer
:	O
"<NIL>"	pointer
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
retval	int
<	O
0	int
)	O
{	O
E_DEBUG2	O
(	O
"ERROR: retval = [%d]"	pointer
,	O
retval	int
)	O
;	O
return	O
retval	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
swi	pointer
->	O
does_have_payloadM	int
<	O
0	int
)	O
{	O
swi	pointer
->	O
does_have_payloadM	int
=	O
0	int
;	O
catalog_end_offset	int
=	O
uxfio_lseek	function
(	O
ifd	int
,	O
(	O
off_t	long
)	O
0	int
,	O
SEEK_CUR	int
)	O
;	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
catalog_end_offsetM	int
=	O
catalog_end_offset	int
;	O
E_DEBUG2	O
(	O
"NO PAYLOAD: NOW catalog end offset = [%d]"	pointer
,	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
catalog_end_offsetM	int
)	O
;	O
E_DEBUG2	O
(	O
"EOA bytes = [%d]"	pointer
,	O
xformat	pointer
->	O
eoaM	int
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
catalog_start_offset	int
<	O
0	int
)	O
{	O
catalog_start_offset	int
=	O
0	int
;	O
fprintf	function
(	O
stderr	pointer
,	O
"internal error: %s:%d\n"	pointer
,	O
__FILE__	O
,	O
__LINE__	O
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
catalog_lengthM	int
=	O
catalog_end_offset	int
-	O
catalog_start_offset	int
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
swi	pointer
->	O
swi_pkgM	pointer
==	O
NULL	O
)	O
{	O
return	O
-	O
8	int
;	O
}	O
if	O
(	O
swi	pointer
->	O
swi_pkgM	pointer
&&	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
swi_coM	array
[	O
0	int
]	O
)	O
{	O
ret	int
=	O
swi_expand_shared_file_control_sripts	function
(	O
swi	pointer
,	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
swi_coM	array
[	O
0	int
]	O
->	O
xfileM	pointer
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: internal error swi->swi_pkgM && swi->swi_pkgM->swi_coM[0]\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
ret	int
=	O
0	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swi_com_assert_value	function
(	O
ret	int
==	O
0	int
,	O
__FILE__	O
,	O
__LINE__	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swi_recurse_swi_tree	function
(	O
swi	pointer
,	O
(	O
char	O
*	O
)	O
(	O
NULL	O
)	O
,	O
swi_vbase_set_verbose_level	function
,	O
(	O
void	O
*	O
)	O
(	O
&	O
(	O
swi	pointer
->	O
verboseM	int
)	O
)	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swi_recurse_swi_tree	function
(	O
swi	pointer
,	O
(	O
char	O
*	O
)	O
(	O
NULL	O
)	O
,	O
swi_vbase_update	function
,	O
NULL	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	int
=	O
swi_recurse_swi_tree	function
(	O
swi	pointer
,	O
(	O
char	O
*	O
)	O
(	O
NULL	O
)	O
,	O
swi_vbase_generate_swverid	function
,	O
NULL	O
)	O
;	O
if	O
(	O
ret	int
)	O
{	O
if	O
(	O
retval	int
==	O
0	int
)	O
retval	int
=	O
-	O
1	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
is_minimal_layoutM	int
=	O
swpath_get_is_minimal_layout	function
(	O
swpath	pointer
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
return	O
retval	int
;	O
}	O
SWI_PRODUCT	struct
*	O
swi_package_get_product	function
(	O
SWI_PACKAGE	struct
*	O
swi_pkg	pointer
,	O
int	O
index	function
)	O
{	O
SWI_PRODUCT	struct
*	O
ret	int
;	O
ret	int
=	O
swi_pkg	pointer
->	O
swi_coM	array
[	O
index	function
]	O
;	O
return	O
ret	int
;	O
}	O
SWI_XFILE	struct
*	O
swi_product_get_fileset	function
(	O
SWI_PRODUCT	struct
*	O
swi_prod	pointer
,	O
int	O
index	function
)	O
{	O
SWI_XFILE	struct
*	O
ret	int
;	O
ret	int
=	O
swi_prod	pointer
->	O
swi_coM	array
[	O
index	function
]	O
;	O
return	O
ret	int
;	O
}	O
int	O
swi_product_has_control_file	function
(	O
SWI_PRODUCT	struct
*	O
swi_prod	pointer
,	O
char	O
*	O
control_file_name	pointer
)	O
{	O
int	O
ret	int
;	O
ret	int
=	O
swi_xfile_has_posix_control_file	function
(	O
swi_prod	pointer
->	O
xfileM	pointer
,	O
control_file_name	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
SWI_CONTROL_SCRIPT	struct
*	O
swi_product_get_control_script_by_tag	function
(	O
SWI_PRODUCT	struct
*	O
prod	pointer
,	O
char	O
*	O
tag	pointer
)	O
{	O
SWI_CONTROL_SCRIPT	struct
*	O
ret	int
;	O
ret	int
=	O
swi_xfile_get_control_script_by_tag	function
(	O
prod	pointer
->	O
xfileM	pointer
,	O
tag	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
SWI_CONTROL_SCRIPT	struct
*	O
swi_get_control_script_by_swsel	function
(	O
SWI	struct
*	O
swi	pointer
,	O
char	O
*	O
swsel	pointer
,	O
char	O
*	O
script_tag	pointer
)	O
{	O
return	O
NULL	O
;	O
}	O
int	O
swi_recurse_swi_tree	function
(	O
SWI	struct
*	O
swi	pointer
,	O
char	O
*	O
sw_selections	pointer
,	O
int	O
(	O
*	O
payload	pointer
)	O
(	O
void	O
*	O
,	O
void	O
*	O
)	O
,	O
void	O
*	O
uptr	pointer
)	O
{	O
int	O
i	int
;	O
int	O
j	int
;	O
SWI_PACKAGE	struct
*	O
package	pointer
;	O
SWI_PRODUCT	struct
*	O
product	pointer
;	O
SWI_XFILE	struct
*	O
fileset	pointer
;	O
int	O
ret	int
;	O
int	O
retval	int
=	O
0	int
;	O
package	pointer
=	O
swi	pointer
->	O
swi_pkgM	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
SWI_MAX_OBJ	int
;	O
i	int
++	O
)	O
{	O
product	pointer
=	O
package	pointer
->	O
swi_coM	array
[	O
i	int
]	O
;	O
if	O
(	O
product	pointer
)	O
{	O
if	O
(	O
payload	pointer
)	O
{	O
ret	int
=	O
(	O
*	O
payload	pointer
)	O
(	O
(	O
void	O
*	O
)	O
(	O
product	pointer
)	O
,	O
uptr	pointer
)	O
;	O
if	O
(	O
ret	int
)	O
retval	int
++	O
;	O
}	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
SWI_MAX_OBJ	int
;	O
j	int
++	O
)	O
{	O
fileset	pointer
=	O
product	pointer
->	O
swi_coM	array
[	O
j	int
]	O
;	O
if	O
(	O
fileset	pointer
)	O
{	O
if	O
(	O
payload	pointer
)	O
{	O
ret	int
=	O
(	O
*	O
payload	pointer
)	O
(	O
(	O
void	O
*	O
)	O
(	O
fileset	pointer
)	O
,	O
uptr	pointer
)	O
;	O
if	O
(	O
ret	int
)	O
retval	int
++	O
;	O
}	O
}	O
else	O
break	O
;	O
}	O
}	O
else	O
break	O
;	O
}	O
return	O
retval	int
;	O
}	O
SWI_PRODUCT	struct
*	O
swi_find_product_by_swsel	function
(	O
SWI_PACKAGE	struct
*	O
parent	pointer
,	O
char	O
*	O
swsel	pointer
,	O
char	O
*	O
number	pointer
,	O
int	O
*	O
p_index	pointer
)	O
{	O
SWI_BASE	struct
*	O
base	int
;	O
base	int
=	O
find_object_by_swsel	function
(	O
parent	pointer
,	O
swsel	pointer
,	O
number	pointer
,	O
p_index	pointer
)	O
;	O
if	O
(	O
!	O
base	int
)	O
return	O
(	O
SWI_PRODUCT	struct
*	O
)	O
base	int
;	O
swi_base_assert	function
(	O
base	int
)	O
;	O
SWLIB_ASSERT	O
(	O
base	int
->	O
type_idM	char
==	O
SWI_I_TYPE_PROD	char
)	O
;	O
return	O
(	O
SWI_PRODUCT	struct
*	O
)	O
(	O
base	int
)	O
;	O
}	O
SWI_XFILE	struct
*	O
swi_find_fileset_by_swsel	function
(	O
SWI_PRODUCT	struct
*	O
parent	pointer
,	O
char	O
*	O
swsel	pointer
,	O
int	O
*	O
p_index	pointer
)	O
{	O
SWI_BASE	struct
*	O
base	int
;	O
base	int
=	O
find_object_by_swsel	function
(	O
parent	pointer
,	O
swsel	pointer
,	O
NULL	O
,	O
p_index	pointer
)	O
;	O
if	O
(	O
!	O
base	int
)	O
return	O
(	O
SWI_XFILE	struct
*	O
)	O
base	int
;	O
swi_base_assert	function
(	O
base	int
)	O
;	O
SWLIB_ASSERT	O
(	O
base	int
->	O
type_idM	char
==	O
SWI_I_TYPE_XFILE	char
)	O
;	O
SWLIB_ASSERT	O
(	O
(	O
(	O
SWI_XFILE	struct
*	O
)	O
base	int
)	O
->	O
typeM	int
==	O
SWI_XFILE_TYPE_FILESET	int
||	O
(	O
(	O
SWI_XFILE	struct
*	O
)	O
base	int
)	O
->	O
typeM	int
==	O
SWI_XFILE_TYPE_PFILES	int
)	O
;	O
return	O
(	O
SWI_XFILE	struct
*	O
)	O
(	O
base	int
)	O
;	O
}	O
void	O
swi_get_uts_attributes_from_current	function
(	O
SWI	struct
*	O
swi	pointer
,	O
SWUTS	struct
*	O
uts	pointer
,	O
SWHEADER	struct
*	O
swheader	pointer
)	O
{	O
char	O
*	O
value	int
;	O
value	int
=	O
swheader_get_single_attribute_value	function
(	O
swheader	pointer
,	O
SW_A_os_name	pointer
)	O
;	O
if	O
(	O
value	int
)	O
{	O
swuts_add_attribute	function
(	O
uts	pointer
,	O
SW_A_os_name	pointer
,	O
value	int
)	O
;	O
}	O
else	O
{	O
swuts_add_attribute	function
(	O
uts	pointer
,	O
SW_A_os_name	pointer
,	O
""	pointer
)	O
;	O
}	O
value	int
=	O
swheader_get_single_attribute_value	function
(	O
swheader	pointer
,	O
SW_A_os_version	pointer
)	O
;	O
if	O
(	O
value	int
)	O
{	O
swuts_add_attribute	function
(	O
uts	pointer
,	O
SW_A_os_version	pointer
,	O
value	int
)	O
;	O
}	O
else	O
{	O
swuts_add_attribute	function
(	O
uts	pointer
,	O
SW_A_os_version	pointer
,	O
""	pointer
)	O
;	O
}	O
value	int
=	O
swheader_get_single_attribute_value	function
(	O
swheader	pointer
,	O
SW_A_os_release	pointer
)	O
;	O
if	O
(	O
value	int
)	O
{	O
swuts_add_attribute	function
(	O
uts	pointer
,	O
SW_A_os_release	pointer
,	O
value	int
)	O
;	O
}	O
else	O
{	O
swuts_add_attribute	function
(	O
uts	pointer
,	O
SW_A_os_release	pointer
,	O
""	pointer
)	O
;	O
}	O
value	int
=	O
swheader_get_single_attribute_value	function
(	O
swheader	pointer
,	O
SW_A_machine_type	pointer
)	O
;	O
if	O
(	O
value	int
)	O
{	O
swuts_add_attribute	function
(	O
uts	pointer
,	O
SW_A_machine_type	pointer
,	O
value	int
)	O
;	O
}	O
else	O
{	O
swuts_add_attribute	function
(	O
uts	pointer
,	O
SW_A_machine_type	pointer
,	O
""	pointer
)	O
;	O
}	O
return	O
;	O
}	O
int	O
swi_do_decode	function
(	O
SWI	struct
*	O
swi	pointer
,	O
SWLOG	struct
*	O
swutil	pointer
,	O
int	O
target_fd1	int
,	O
int	O
source_fd0	int
,	O
char	O
*	O
target_path	pointer
,	O
char	O
*	O
source_path	pointer
,	O
VPLOB	union
*	O
swspecs	pointer
,	O
char	O
*	O
target_host	pointer
,	O
struct	O
extendedOptions	struct
*	O
opta	pointer
,	O
int	O
is_seekable	int
,	O
int	O
do_debug_events	int
,	O
int	O
verboseG	int
,	O
struct	O
sw_logspec	struct
*	O
g_logspec	pointer
,	O
int	O
uinfile_open_flags	int
)	O
{	O
int	O
ret	int
;	O
int	O
ifd	int
;	O
int	O
retval	int
;	O
XFORMAT	struct
*	O
xformat	pointer
;	O
SWPATH	struct
*	O
swpath	pointer
;	O
UINFORMAT	struct
*	O
uinformat	pointer
;	O
SWVARFS	struct
*	O
swvarfs	pointer
;	O
char	O
*	O
rpm_newname	pointer
;	O
int	O
format	pointer
;	O
int	O
flags	int
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
SWLIB_ASSERT	O
(	O
source_fd0	int
>=	O
0	int
)	O
;	O
swlib_doif_writef	O
(	O
verboseG	int
,	O
SWC_VERBOSE_IDB	int
,	O
g_logspec	pointer
,	O
swutil	pointer
->	O
swu_efdM	int
,	O
"run audit: start setup_xformat\n"	pointer
)	O
;	O
format	pointer
=	O
arf_ustar	int
;	O
xformat	pointer
=	O
xformat_open	function
(	O
-	O
1	int
,	O
-	O
1	int
,	O
format	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
uinfile_open_flags	int
<	O
0	int
)	O
{	O
flags	int
=	O
UINFILE_DETECT_FORCEUXFIOFD	O
|	O
UINFILE_DETECT_UNCPIO	O
|	O
UINFILE_DETECT_IEEE	O
;	O
}	O
else	O
{	O
flags	int
=	O
uinfile_open_flags	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
xformat	pointer
=	O
swutil_setup_xformat	function
(	O
swutil	pointer
,	O
xformat	pointer
,	O
source_fd0	int
,	O
source_path	pointer
,	O
opta	pointer
,	O
is_seekable	int
,	O
verboseG	int
,	O
g_logspec	pointer
,	O
flags	int
)	O
;	O
if	O
(	O
xformat	pointer
==	O
(	O
XFORMAT	struct
*	O
)	O
NULL	O
)	O
{	O
E_DEBUG	O
(	O
"error"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swlib_doif_writef	O
(	O
verboseG	int
,	O
SWC_VERBOSE_IDB2	int
,	O
g_logspec	pointer
,	O
swutil	pointer
->	O
swu_efdM	int
,	O
"run audit: finished setup_xformat\n"	pointer
)	O
;	O
xformat_set_ofd	function
(	O
xformat	pointer
,	O
target_fd1	int
)	O
;	O
swlib_doif_writef	O
(	O
verboseG	int
,	O
SWC_VERBOSE_IDB2	int
,	O
g_logspec	pointer
,	O
swutil	pointer
->	O
swu_efdM	int
,	O
"run audit: starting swlib_audit_distribution\n"	pointer
)	O
;	O
swvarfs	pointer
=	O
xformat_get_swvarfs	function
(	O
xformat	pointer
)	O
;	O
uinformat	pointer
=	O
swvarfs_get_uinformat	function
(	O
swvarfs	pointer
)	O
;	O
swpath	pointer
=	O
uinfile_get_swpath	function
(	O
uinformat	pointer
)	O
;	O
swpath_reset	function
(	O
swpath	pointer
)	O
;	O
xformat_set_tarheader_flag	function
(	O
xformat	pointer
,	O
TARU_TAR_FRAGILE_FORMAT	O
,	O
1	int
)	O
;	O
xformat_set_tarheader_flag	function
(	O
xformat	pointer
,	O
TARU_TAR_RETAIN_HEADER_IDS	O
,	O
1	int
)	O
;	O
if	O
(	O
uinfile_get_ztype	function
(	O
uinformat	pointer
)	O
==	O
UINFILE_COMPRESSED_RPM	int
)	O
{	O
if	O
(	O
opta	pointer
)	O
{	O
set_opta	function
(	O
opta	pointer
,	O
SW_E_swbis_install_volatile	int
,	O
"true"	pointer
)	O
;	O
rpm_newname	pointer
=	O
get_opta	function
(	O
opta	pointer
,	O
SW_E_swbis_volatile_newname	int
)	O
;	O
if	O
(	O
swextopt_is_option_set	function
(	O
SW_E_swbis_volatile_newname	int
,	O
opta	pointer
)	O
==	O
0	int
&&	O
(	O
!	O
rpm_newname	pointer
||	O
!	O
strlen	function
(	O
rpm_newname	pointer
)	O
)	O
)	O
{	O
set_opta	function
(	O
opta	pointer
,	O
SW_E_swbis_volatile_newname	int
,	O
".rpmnew"	pointer
)	O
;	O
}	O
else	O
{	O
;	O
}	O
}	O
}	O
swi	pointer
->	O
xformatM	pointer
=	O
xformat	pointer
;	O
swi	pointer
->	O
swvarfsM	pointer
=	O
swvarfs	pointer
;	O
swi	pointer
->	O
uinformatM	pointer
=	O
uinformat	pointer
;	O
swi	pointer
->	O
swpathM	pointer
=	O
swpath	pointer
;	O
swi	pointer
->	O
verboseM	int
=	O
verboseG	int
;	O
if	O
(	O
target_host	pointer
)	O
{	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
target_hostM	pointer
=	O
strdup	function
(	O
target_host	pointer
)	O
;	O
}	O
else	O
{	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
target_hostM	pointer
=	O
strdup	function
(	O
"localhost"	pointer
)	O
;	O
}	O
ifd	int
=	O
xformat_get_ifd	function
(	O
xformat	pointer
)	O
;	O
swi	pointer
->	O
optaM	pointer
=	O
(	O
void	O
*	O
)	O
opta	pointer
;	O
swi	pointer
->	O
debug_eventsM	int
=	O
do_debug_events	int
;	O
ret	int
=	O
swi_decode_catalog	function
(	O
swi	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swvarfs_uxfio_fcntl	function
(	O
swvarfs	pointer
,	O
UXFIO_F_ARM_AUTO_DISABLE	O
,	O
1	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
uxfio_lseek	function
(	O
ifd	int
,	O
0	int
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"uxfio_lseek error: %s : %d\n"	pointer
,	O
__FILE__	O
,	O
__LINE__	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swpath_reset	function
(	O
swpath	pointer
)	O
;	O
if	O
(	O
ret	int
)	O
{	O
swlib_doif_writef	O
(	O
verboseG	int
,	O
SWC_VERBOSE_1	int
,	O
g_logspec	pointer
,	O
swutil	pointer
->	O
swu_efdM	int
,	O
"swi_decode_catalog: return code %d\n"	pointer
,	O
ret	int
)	O
;	O
retval	int
=	O
-	O
1	int
;	O
swi	pointer
=	O
(	O
SWI	struct
*	O
)	O
(	O
NULL	O
)	O
;	O
}	O
else	O
{	O
retval	int
=	O
0	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
return	O
retval	int
;	O
}	O
int	O
swi_find_compatible_product	function
(	O
SWI	struct
*	O
swi	pointer
,	O
SWUTS	struct
*	O
target_uts	pointer
,	O
int	O
disallow_incompat	int
)	O
{	O
SWI_PRODUCT	struct
*	O
product	pointer
;	O
SWHEADER	struct
*	O
global_index	pointer
;	O
SWUTS	struct
*	O
product_uts	pointer
;	O
int	O
check_found	int
;	O
int	O
retval	int
;	O
int	O
ret	int
;	O
int	O
product_number	int
;	O
int	O
n_matches	int
;	O
int	O
n_products	int
;	O
n_matches	int
=	O
swi_audit_all_compatible_products	function
(	O
swi	pointer
,	O
target_uts	pointer
,	O
&	O
n_products	int
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
;	O
if	O
(	O
disallow_incompat	int
==	O
0	int
&&	O
n_matches	int
==	O
0	int
&&	O
n_products	int
==	O
1	int
)	O
return	O
0	int
;	O
if	O
(	O
n_matches	int
==	O
1	int
&&	O
n_products	int
==	O
1	int
)	O
return	O
0	int
;	O
check_found	int
=	O
0	int
;	O
product_number	int
=	O
0	int
;	O
while	O
(	O
(	O
product	pointer
=	O
swi_package_get_product	function
(	O
swi	pointer
->	O
swi_pkgM	pointer
,	O
product_number	int
)	O
)	O
)	O
{	O
if	O
(	O
product	pointer
->	O
is_compatibleM	int
==	O
SW_TRUE	int
)	O
{	O
check_found	int
=	O
1	int
;	O
break	O
;	O
}	O
product_number	int
++	O
;	O
}	O
if	O
(	O
product_number	int
>=	O
n_products	int
)	O
return	O
-	O
1	int
;	O
return	O
product_number	int
;	O
}	O
SWHEADER	struct
*	O
swi_get_global_index_header	function
(	O
SWI	struct
*	O
swi	pointer
)	O
{	O
SWHEADER	struct
*	O
ret	int
;	O
ret	int
=	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
baseM	struct
.	O
global_headerM	pointer
;	O
return	O
ret	int
;	O
}	O
SWHEADER	struct
*	O
swi_get_fileset_info_header	function
(	O
SWI	struct
*	O
swi	pointer
,	O
int	O
product_index	int
,	O
int	O
fileset_index	int
)	O
{	O
SWHEADER	struct
*	O
ret	int
;	O
ret	int
=	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
swi_coM	array
[	O
product_index	int
]	O
->	O
swi_coM	array
[	O
fileset_index	int
]	O
->	O
info_headerM	pointer
;	O
return	O
ret	int
;	O
}	O
SWI_FILELIST	union
*	O
swi_make_fileset_file_list	function
(	O
SWI	struct
*	O
swi	pointer
,	O
int	O
product_num	int
,	O
int	O
fileset_num	int
,	O
char	O
*	O
location	pointer
)	O
{	O
int	O
ret	int
;	O
char	O
*	O
object_line	pointer
;	O
char	O
*	O
object_keyword	pointer
;	O
char	O
*	O
directory	pointer
;	O
char	O
*	O
path	pointer
;	O
char	O
*	O
prefix	pointer
;	O
char	O
*	O
store	pointer
;	O
char	O
*	O
filetype	pointer
;	O
char	O
*	O
is_volatile	int
;	O
int	O
tar_filetype	int
;	O
STROB	struct
*	O
tmp	pointer
;	O
STROB	struct
*	O
relocated_path	pointer
;	O
SWI_FILELIST	union
*	O
flist	pointer
;	O
SWI_PRODUCT	struct
*	O
product	pointer
;	O
SWHEADER	struct
*	O
infoheader	pointer
;	O
SWHEADER	struct
*	O
global_index	pointer
;	O
SWHEADER_STATE	struct
state	pointer
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
flist	pointer
=	O
swi_fl_create	function
(	O
)	O
;	O
tmp	pointer
=	O
strob_open	function
(	O
12	int
)	O
;	O
relocated_path	pointer
=	O
strob_open	function
(	O
12	int
)	O
;	O
if	O
(	O
swi	pointer
==	O
NULL	O
)	O
{	O
SWLIB_ERROR	O
(	O
""	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
product	pointer
=	O
swi_package_get_product	function
(	O
swi	pointer
->	O
swi_pkgM	pointer
,	O
product_num	int
)	O
;	O
if	O
(	O
product	pointer
==	O
NULL	O
)	O
{	O
SWLIB_ERROR	O
(	O
""	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
infoheader	pointer
=	O
swi_get_fileset_info_header	function
(	O
swi	pointer
,	O
product_num	int
,	O
fileset_num	int
)	O
;	O
if	O
(	O
infoheader	pointer
==	O
NULL	O
)	O
{	O
SWLIB_ERROR	O
(	O
""	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
global_index	pointer
=	O
swi_get_global_index_header	function
(	O
swi	pointer
)	O
;	O
swheader_set_current_offset	function
(	O
global_index	pointer
,	O
product	pointer
->	O
p_baseM	struct
.	O
header_indexM	int
)	O
;	O
directory	pointer
=	O
swheader_get_single_attribute_value	function
(	O
global_index	pointer
,	O
SW_A_directory	pointer
)	O
;	O
directory	pointer
=	O
swlib_attribute_check_default	function
(	O
SW_A_product	pointer
,	O
SW_A_directory	pointer
,	O
directory	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swheader_store_state	function
(	O
infoheader	pointer
,	O
&	O
state	pointer
)	O
;	O
swheader_reset	function
(	O
infoheader	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
while	O
(	O
(	O
object_line	pointer
=	O
swheader_get_next_object	function
(	O
infoheader	pointer
,	O
(	O
int	O
)	O
(	O
UCHAR_MAX	O
)	O
,	O
(	O
int	O
)	O
UCHAR_MAX	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
E_DEBUG	O
(	O
"---------------------------------------------------------------"	pointer
)	O
;	O
if	O
(	O
swheaderline_get_type	function
(	O
object_line	pointer
)	O
!=	O
SWPARSE_MD_TYPE_OBJ	char
)	O
{	O
SWLIB_ERROR	O
(	O
""	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
object_keyword	pointer
=	O
swheaderline_get_keyword	function
(	O
object_line	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
object_keyword	pointer
,	O
SW_A_control_file	pointer
)	O
==	O
0	int
)	O
{	O
continue	O
;	O
}	O
path	pointer
=	O
swheader_get_single_attribute_value	function
(	O
infoheader	pointer
,	O
SW_A_path	pointer
)	O
;	O
if	O
(	O
path	pointer
==	O
NULL	O
||	O
strlen	function
(	O
path	pointer
)	O
==	O
0	int
)	O
{	O
SWLIB_ERROR	O
(	O
"unexpected null path"	pointer
)	O
;	O
}	O
E_DEBUG2	O
(	O
"location=[%s]"	pointer
,	O
location	pointer
)	O
;	O
E_DEBUG2	O
(	O
"path=[%s]"	pointer
,	O
path	pointer
)	O
;	O
E_DEBUG2	O
(	O
"directory=[%s]"	pointer
,	O
directory	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
location	pointer
,	O
"/"	pointer
)	O
!=	O
0	int
)	O
{	O
E_DEBUG2	O
(	O
"APPLY LOCATION:  path=[%s]"	pointer
,	O
path	pointer
)	O
;	O
swlib_apply_location	function
(	O
relocated_path	pointer
,	O
path	pointer
,	O
location	pointer
,	O
directory	pointer
)	O
;	O
path	pointer
=	O
strob_str	function
(	O
relocated_path	pointer
)	O
;	O
E_DEBUG2	O
(	O
"AFTER path=[%s]"	pointer
,	O
path	pointer
)	O
;	O
}	O
if	O
(	O
*	O
path	pointer
==	O
'.'	O
&&	O
*	O
(	O
path	pointer
+	O
1	int
)	O
==	O
'/'	O
)	O
{	O
prefix	pointer
=	O
""	pointer
;	O
}	O
else	O
{	O
E_DEBUG2	O
(	O
"path=[%s]"	pointer
,	O
path	pointer
)	O
;	O
path	pointer
=	O
swlib_return_relative_path	function
(	O
path	pointer
)	O
;	O
E_DEBUG2	O
(	O
"path=[%s]"	pointer
,	O
path	pointer
)	O
;	O
prefix	pointer
=	O
"./"	pointer
;	O
}	O
E_DEBUG2	O
(	O
"path=[%s]"	pointer
,	O
path	pointer
)	O
;	O
store	pointer
=	O
swi_fl_add_store	function
(	O
flist	pointer
,	O
strlen	function
(	O
path	pointer
)	O
+	O
strlen	function
(	O
prefix	pointer
)	O
)	O
;	O
swi_fl_set_path	function
(	O
flist	pointer
,	O
store	pointer
,	O
prefix	pointer
,	O
path	pointer
)	O
;	O
E_DEBUG2	O
(	O
"path=[%s]"	pointer
,	O
path	pointer
)	O
;	O
filetype	pointer
=	O
swheader_get_single_attribute_value	function
(	O
infoheader	pointer
,	O
SW_A_type	pointer
)	O
;	O
if	O
(	O
filetype	pointer
==	O
NULL	O
||	O
strlen	function
(	O
filetype	pointer
)	O
==	O
0	int
)	O
{	O
filetype	pointer
=	O
"0"	pointer
;	O
SWLIB_ERROR	O
(	O
"unexpected error, type attribute not present"	pointer
)	O
;	O
}	O
tar_filetype	int
=	O
swheader_getTarTypeFromTypeAttribute	function
(	O
*	O
filetype	pointer
)	O
;	O
swi_fl_set_type	function
(	O
flist	pointer
,	O
store	pointer
,	O
tar_filetype	int
)	O
;	O
is_volatile	int
=	O
swheader_get_single_attribute_value	function
(	O
infoheader	pointer
,	O
SW_A_is_volatile	pointer
)	O
;	O
ret	int
=	O
swlib_is_option_true	function
(	O
is_volatile	int
)	O
;	O
swi_fl_set_is_volatile	function
(	O
flist	pointer
,	O
store	pointer
,	O
-	O
1	int
,	O
ret	int
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
out	O
:	O
swheader_restore_state	function
(	O
infoheader	pointer
,	O
&	O
state	pointer
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
strob_close	function
(	O
relocated_path	pointer
)	O
;	O
return	O
flist	pointer
;	O
}	O
SWI_FILELIST	union
*	O
swi_make_file_list	function
(	O
SWI	struct
*	O
swi	pointer
,	O
SWUTS	struct
*	O
swuts	pointer
,	O
char	O
*	O
location	pointer
,	O
int	O
disallow_incompatible	int
)	O
{	O
int	O
n_compat	int
;	O
int	O
check_found	int
;	O
int	O
product_number	int
;	O
int	O
n_products	int
;	O
STROB	struct
*	O
relocated_path	pointer
;	O
SWI_FILELIST	union
*	O
flist	pointer
;	O
SWI_PRODUCT	struct
*	O
product	pointer
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
flist	pointer
=	O
swi_fl_create	function
(	O
)	O
;	O
relocated_path	pointer
=	O
strob_open	function
(	O
12	int
)	O
;	O
if	O
(	O
swi	pointer
==	O
NULL	O
)	O
{	O
SWLIB_ERROR	O
(	O
""	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
product_number	int
=	O
swi_find_compatible_product	function
(	O
swi	pointer
,	O
swuts	pointer
,	O
disallow_incompatible	int
)	O
;	O
if	O
(	O
product_number	int
<	O
0	int
)	O
{	O
SWLIB_WARN	O
(	O
"no compatible product found in entry"	pointer
)	O
;	O
return	O
NULL	O
;	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
flist	pointer
=	O
swi_make_fileset_file_list	function
(	O
swi	pointer
,	O
product_number	int
,	O
SWI_FILESET_0	int
,	O
location	pointer
)	O
;	O
return	O
flist	pointer
;	O
}	O
SWI_FILELIST	union
*	O
swi_fl_create	function
(	O
void	O
)	O
{	O
return	O
(	O
SWI_FILELIST	union
*	O
)	O
strar_open	function
(	O
)	O
;	O
}	O
void	O
swi_fl_delete	function
(	O
SWI_FILELIST	union
*	O
fl	pointer
)	O
{	O
strar_close	function
(	O
(	O
STRAR	struct
*	O
)	O
fl	pointer
)	O
;	O
}	O
char	O
*	O
swi_fl_add_store	function
(	O
SWI_FILELIST	union
*	O
fl	pointer
,	O
int	O
len	int
)	O
{	O
STRAR	struct
*	O
ar	pointer
=	O
(	O
STRAR	struct
*	O
)	O
fl	pointer
;	O
char	O
*	O
s	pointer
;	O
s	pointer
=	O
strar_return_store	function
(	O
ar	pointer
,	O
len	int
+	O
SWI_FL_HEADER_LEN	int
)	O
;	O
return	O
s	pointer
;	O
}	O
void	O
swi_fl_set_path	function
(	O
SWI_FILELIST	union
*	O
fl	pointer
,	O
char	O
*	O
s	pointer
,	O
char	O
*	O
prefix	pointer
,	O
char	O
*	O
path	pointer
)	O
{	O
E_DEBUG2	O
(	O
"path=[%s]"	pointer
,	O
path	pointer
)	O
;	O
E_DEBUG2	O
(	O
"prefix=[%s]"	pointer
,	O
prefix	pointer
)	O
;	O
if	O
(	O
prefix	pointer
==	O
NULL	O
)	O
prefix	pointer
=	O
""	pointer
;	O
if	O
(	O
strlen	function
(	O
prefix	pointer
)	O
>	O
0	int
)	O
{	O
strncpy	function
(	O
s	pointer
+	O
(	O
SWI_FL_HEADER_LEN	int
)	O
,	O
prefix	pointer
,	O
strlen	function
(	O
prefix	pointer
)	O
)	O
;	O
E_DEBUG2	O
(	O
"s=[%s]"	pointer
,	O
s	pointer
)	O
;	O
}	O
strncpy	function
(	O
s	pointer
+	O
(	O
SWI_FL_HEADER_LEN	int
+	O
strlen	function
(	O
prefix	pointer
)	O
)	O
,	O
path	pointer
,	O
strlen	function
(	O
path	pointer
)	O
)	O
;	O
E_DEBUG2	O
(	O
"s=[%s]"	pointer
,	O
s	pointer
)	O
;	O
}	O
void	O
swi_fl_set_user_flag	function
(	O
SWI_FILELIST	union
*	O
fl	pointer
,	O
char	O
*	O
hdr	pointer
,	O
int	O
msg	pointer
)	O
{	O
*	O
(	O
hdr	pointer
+	O
SWI_FL_OFFSET_USER_FLAG	int
)	O
=	O
msg	pointer
;	O
}	O
int	O
swi_fl_get_user_flag	function
(	O
SWI_FILELIST	union
*	O
fl	pointer
,	O
int	O
index	function
)	O
{	O
STRAR	struct
*	O
ar	pointer
=	O
(	O
STRAR	struct
*	O
)	O
fl	pointer
;	O
char	O
*	O
s	pointer
;	O
s	pointer
=	O
strar_get	function
(	O
ar	pointer
,	O
index	function
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
return	O
0	int
;	O
return	O
(	O
int	O
)	O
(	O
*	O
(	O
s	pointer
+	O
SWI_FL_OFFSET_USER_FLAG	int
)	O
)	O
;	O
}	O
void	O
swi_fl_set_is_volatile	function
(	O
SWI_FILELIST	union
*	O
fl	pointer
,	O
char	O
*	O
hdr	pointer
,	O
int	O
index	function
,	O
int	O
is_vol	int
)	O
{	O
if	O
(	O
hdr	pointer
==	O
NULL	O
)	O
{	O
STRAR	struct
*	O
ar	pointer
=	O
(	O
STRAR	struct
*	O
)	O
fl	pointer
;	O
char	O
*	O
s	pointer
;	O
s	pointer
=	O
strar_get	function
(	O
ar	pointer
,	O
index	function
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
return	O
;	O
hdr	pointer
=	O
s	pointer
;	O
}	O
if	O
(	O
is_vol	int
)	O
*	O
(	O
hdr	pointer
+	O
SWI_FL_OFFSET_IS_VOLATILE	int
)	O
=	O
'T'	O
;	O
else	O
*	O
(	O
hdr	pointer
+	O
SWI_FL_OFFSET_IS_VOLATILE	int
)	O
=	O
'F'	O
;	O
}	O
void	O
swi_fl_set_type	function
(	O
SWI_FILELIST	union
*	O
fl	pointer
,	O
char	O
*	O
hdr	pointer
,	O
int	O
tartype	int
)	O
{	O
*	O
(	O
hdr	pointer
+	O
SWI_FL_OFFSET_TARTYPE	int
)	O
=	O
(	O
unsigned	O
char	O
)	O
tartype	int
;	O
}	O
int	O
swi_fl_get_type	function
(	O
SWI_FILELIST	union
*	O
fl	pointer
,	O
int	O
index	function
)	O
{	O
STRAR	struct
*	O
ar	pointer
=	O
(	O
STRAR	struct
*	O
)	O
fl	pointer
;	O
char	O
*	O
s	pointer
;	O
s	pointer
=	O
strar_get	function
(	O
ar	pointer
,	O
index	function
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
return	O
0	int
;	O
return	O
(	O
int	O
)	O
(	O
*	O
(	O
s	pointer
+	O
SWI_FL_OFFSET_TARTYPE	int
)	O
)	O
;	O
}	O
char	O
*	O
swi_fl_get_path	function
(	O
SWI_FILELIST	union
*	O
fl	pointer
,	O
int	O
index	function
)	O
{	O
STRAR	struct
*	O
ar	pointer
=	O
(	O
STRAR	struct
*	O
)	O
fl	pointer
;	O
char	O
*	O
s	pointer
;	O
s	pointer
=	O
strar_get	function
(	O
ar	pointer
,	O
index	function
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
return	O
s	pointer
+	O
SWI_FL_OFFSET_PATH	int
;	O
}	O
int	O
swi_fl_is_volatile	function
(	O
SWI_FILELIST	union
*	O
fl	pointer
,	O
int	O
index	function
)	O
{	O
STRAR	struct
*	O
ar	pointer
=	O
(	O
STRAR	struct
*	O
)	O
fl	pointer
;	O
char	O
*	O
s	pointer
;	O
s	pointer
=	O
strar_get	function
(	O
ar	pointer
,	O
index	function
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
return	O
0	int
;	O
if	O
(	O
(	O
int	O
)	O
(	O
*	O
(	O
s	pointer
+	O
SWI_FL_OFFSET_IS_VOLATILE	int
)	O
)	O
==	O
'T'	O
)	O
{	O
return	O
1	int
;	O
}	O
else	O
{	O
return	O
0	int
;	O
}	O
}	O
int	O
swi_fl_compare_reverse	function
(	O
const	O
void	O
*	O
vf1	pointer
,	O
const	O
void	O
*	O
vf2	pointer
)	O
{	O
return	O
-	O
swi_fl_compare	function
(	O
vf1	pointer
,	O
vf2	pointer
)	O
;	O
}	O
int	O
swi_fl_compare	function
(	O
const	O
void	O
*	O
vf1	pointer
,	O
const	O
void	O
*	O
vf2	pointer
)	O
{	O
char	O
*	O
f1	pointer
;	O
char	O
*	O
f2	pointer
;	O
f1	pointer
=	O
*	O
(	O
(	O
char	O
*	O
*	O
)	O
(	O
vf1	pointer
)	O
)	O
;	O
f2	pointer
=	O
*	O
(	O
(	O
char	O
*	O
*	O
)	O
(	O
vf2	pointer
)	O
)	O
;	O
return	O
strcmp	function
(	O
f1	pointer
+	O
SWI_FL_HEADER_LEN	int
,	O
f2	pointer
+	O
SWI_FL_HEADER_LEN	int
)	O
;	O
}	O
void	O
swi_fl_qsort_forward	function
(	O
SWI_FILELIST	union
*	O
fl	pointer
)	O
{	O
STRAR	struct
*	O
ar	pointer
=	O
(	O
STRAR	struct
*	O
)	O
fl	pointer
;	O
strar_qsort	function
(	O
ar	pointer
,	O
swi_fl_compare	function
)	O
;	O
}	O
void	O
swi_fl_qsort_reverse	function
(	O
SWI_FILELIST	union
*	O
fl	pointer
)	O
{	O
STRAR	struct
*	O
ar	pointer
=	O
(	O
STRAR	struct
*	O
)	O
fl	pointer
;	O
strar_qsort	function
(	O
ar	pointer
,	O
swi_fl_compare_reverse	function
)	O
;	O
}	O
