typedef	O
enum	O
{	O
product	int
,	O
reactant	int
,	O
parameter	int
}	O
VARTYPES	enum
;	O
typedef	O
enum	O
{	O
plus	int
,	O
minus	int
}	O
OPSIGNS	enum
;	O
typedef	O
struct	O
tagFORSV	struct
{	O
PINPUTBUF	pointer
pibIn	pointer
;	O
PSTR	pointer
szName	pointer
;	O
PSTR	pointer
szVal	pointer
;	O
PVMMAPSTRCT	pointer
pTarget	pointer
;	O
}	O
FORSV	struct
,	O
*	O
PFORSV	pointer
;	O
KM	struct
vrgSBMLKW	array
[	O
]	O
=	O
{	O
{	O
"sbml"	pointer
,	O
KM_SBML	int
,	O
CN_SBML	int
}	O
,	O
{	O
"model"	pointer
,	O
KM_MODEL	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"listOfFunctionDefinitions"	pointer
,	O
KM_FUNCLIST	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"functionDefinition"	pointer
,	O
KM_FUNC	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"listOfCompartments"	pointer
,	O
KM_CPTLIST	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"compartment"	pointer
,	O
KM_CPT	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"listOfSpecies"	pointer
,	O
KM_SPECIESLIST	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"specie"	pointer
,	O
KM_SPECIES	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"species"	pointer
,	O
KM_SPECIES	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"listOfParameters"	pointer
,	O
KM_PARAMS	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"parameter"	pointer
,	O
KM_PARAM	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"listOfRules"	pointer
,	O
KM_RULESLIST	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"rateRule"	pointer
,	O
KM_RATERULE	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"listOfReactions"	pointer
,	O
KM_REACTIONS	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"reaction"	pointer
,	O
KM_REACTION	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"listOfReactants"	pointer
,	O
KM_REACTANTS	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"listOfProducts"	pointer
,	O
KM_PRODUCTS	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"specieReference"	pointer
,	O
KM_SPECIES_REF	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"speciesReference"	pointer
,	O
KM_SPECIES_REF	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"stoichiometry"	pointer
,	O
KM_STOICHIO	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"kineticLaw"	pointer
,	O
KM_LAW	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"math"	pointer
,	O
KM_MATH	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"apply"	pointer
,	O
KM_APPLY	int
,	O
CN_GLOBAL	int
}	O
,	O
{	O
"plus"	pointer
,	O
KM_PLUS	int
,	O
CN_APPLY	int
}	O
,	O
{	O
"minus"	pointer
,	O
KM_MINUS	int
,	O
CN_APPLY	int
}	O
,	O
{	O
"times"	pointer
,	O
KM_TIMES	int
,	O
CN_APPLY	int
}	O
,	O
{	O
"divide"	pointer
,	O
KM_DIVIDE	int
,	O
CN_APPLY	int
}	O
,	O
{	O
"power"	pointer
,	O
KM_POWER	int
,	O
CN_APPLY	int
}	O
,	O
{	O
"ci"	pointer
,	O
KM_CI	int
,	O
CN_APPLY	int
}	O
,	O
{	O
""	pointer
,	O
0	int
,	O
CN_ALL	int
}	O
}	O
;	O
void	O
AugmentEquation	function
(	O
PVMMAPSTRCT	pointer
pvm	pointer
,	O
PSTR	pointer
szEqn	pointer
,	O
PSTR	pointer
szStoi	pointer
,	O
OPSIGNS	enum
sign	enum
)	O
{	O
PSTR	pointer
szBuf	pointer
;	O
PSTRLEX	array
szSymbol	array
;	O
if	O
(	O
!	O
pvm	pointer
||	O
!	O
szEqn	pointer
||	O
!	O
szStoi	pointer
)	O
return	O
;	O
if	O
(	O
sign	enum
==	O
plus	int
)	O
sprintf	function
(	O
szSymbol	array
,	O
" + "	pointer
)	O
;	O
if	O
(	O
sign	enum
==	O
minus	int
)	O
sprintf	function
(	O
szSymbol	array
,	O
" - "	pointer
)	O
;	O
if	O
(	O
(	O
szBuf	pointer
=	O
(	O
PSTR	pointer
)	O
malloc	function
(	O
strlen	function
(	O
pvm	pointer
->	O
szEqn	pointer
)	O
+	O
strlen	function
(	O
szSymbol	array
)	O
+	O
strlen	function
(	O
szStoi	pointer
)	O
+	O
strlen	function
(	O
szEqn	pointer
)	O
+	O
5	int
)	O
)	O
)	O
if	O
(	O
!	O
strcmp	function
(	O
szStoi	pointer
,	O
"1"	pointer
)	O
)	O
sprintf	function
(	O
szBuf	pointer
,	O
"%s%s%s"	pointer
,	O
pvm	pointer
->	O
szEqn	pointer
,	O
szSymbol	array
,	O
szEqn	pointer
)	O
;	O
else	O
sprintf	function
(	O
szBuf	pointer
,	O
"%s%s %s * %s"	pointer
,	O
pvm	pointer
->	O
szEqn	pointer
,	O
szSymbol	array
,	O
szStoi	pointer
,	O
szEqn	pointer
)	O
;	O
else	O
ReportError	function
(	O
NULL	O
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
szEqn	pointer
,	O
"* .. defining equation in AugmentEquation"	pointer
)	O
;	O
if	O
(	O
pvm	pointer
->	O
szEqn	pointer
)	O
free	function
(	O
pvm	pointer
->	O
szEqn	pointer
)	O
;	O
pvm	pointer
->	O
szEqn	pointer
=	O
szBuf	pointer
;	O
}	O
void	O
ConstructEqn	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PSTR	pointer
szRName	pointer
,	O
VARTYPES	enum
eType	enum
)	O
{	O
int	O
iLexType	int
;	O
HANDLE	long
hType	long
;	O
PSTRLEX	array
szSName	array
;	O
PSTRLEX	array
szStoichio	array
;	O
PVMMAPSTRCT	pointer
pvm	pointer
;	O
PINPUTINFO	pointer
pinfo	pointer
=	O
(	O
PINPUTINFO	pointer
)	O
pibIn	pointer
->	O
pInfo	pointer
;	O
while	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
!=	O
'"'	O
)	O
;	O
GetIdentifier	function
(	O
pibIn	pointer
,	O
szSName	array
)	O
;	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
=	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
+	O
1	int
;	O
while	O
(	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
!=	O
'"'	O
)	O
&&	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
!=	O
'>'	O
)	O
)	O
{	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
;	O
}	O
if	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
==	O
'"'	O
)	O
{	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
;	O
GetNumber	function
(	O
pibIn	pointer
,	O
szStoichio	array
,	O
&	O
iLexType	int
)	O
;	O
}	O
else	O
sprintf	function
(	O
szStoichio	array
,	O
"1"	pointer
)	O
;	O
printf	function
(	O
"%s stoichio: %s\n"	pointer
,	O
szSName	array
,	O
szStoichio	array
)	O
;	O
if	O
(	O
!	O
GetVarPTR	function
(	O
pinfo	pointer
->	O
pvmGloVars	pointer
,	O
szSName	array
)	O
)	O
sprintf	function
(	O
szSName	array
,	O
"%s_%s"	pointer
,	O
szSName	array
,	O
pinfo	pointer
->	O
pvmLocalCpts	pointer
->	O
szName	pointer
)	O
;	O
hType	long
=	O
GetVarType	function
(	O
pinfo	pointer
->	O
pvmGloVars	pointer
,	O
szSName	array
)	O
;	O
if	O
(	O
hType	long
==	O
ID_STATE	int
)	O
{	O
pvm	pointer
=	O
GetVarPTR	function
(	O
pinfo	pointer
->	O
pvmDynEqns	pointer
,	O
szSName	array
)	O
;	O
if	O
(	O
!	O
pvm	pointer
)	O
{	O
DefineVariable	function
(	O
pibIn	pointer
,	O
szSName	array
,	O
""	pointer
,	O
KM_DXDT	int
)	O
;	O
pvm	pointer
=	O
GetVarPTR	function
(	O
pinfo	pointer
->	O
pvmDynEqns	pointer
,	O
szSName	array
)	O
;	O
}	O
AugmentEquation	function
(	O
pvm	pointer
,	O
szRName	pointer
,	O
szStoichio	array
,	O
(	O
eType	enum
==	O
reactant	int
?	O
minus	int
:	O
plus	int
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
hType	long
!=	O
ID_PARM	int
)	O
ReportError	function
(	O
NULL	O
,	O
RE_BADSTATE	O
|	O
RE_FATAL	int
,	O
szSName	array
,	O
NULL	O
)	O
;	O
}	O
}	O
long	O
CountLines	function
(	O
PFILE	pointer
pFileIn	pointer
)	O
{	O
int	O
nLines	int
=	O
0	int
;	O
char	O
szDummy	array
[	O
2	int
]	O
;	O
fscanf	function
(	O
pFileIn	pointer
,	O
"%*[^\n]"	pointer
)	O
;	O
getc	function
(	O
pFileIn	pointer
)	O
;	O
while	O
(	O
!	O
(	O
feof	function
(	O
pFileIn	pointer
)	O
)	O
)	O
{	O
if	O
(	O
fscanf	function
(	O
pFileIn	pointer
,	O
"%1s"	pointer
,	O
szDummy	array
)	O
>	O
0	int
)	O
nLines	int
++	O
;	O
fscanf	function
(	O
pFileIn	pointer
,	O
"%*[^\n]"	pointer
)	O
;	O
getc	function
(	O
pFileIn	pointer
)	O
;	O
}	O
rewind	function
(	O
pFileIn	pointer
)	O
;	O
return	O
(	O
nLines	int
)	O
;	O
}	O
int	O
GetSBMLKeywordCode	function
(	O
PSTR	pointer
szKeyword	pointer
)	O
{	O
PKM	pointer
pkm	pointer
=	O
&	O
vrgSBMLKW	array
[	O
0	int
]	O
;	O
while	O
(	O
*	O
pkm	pointer
->	O
szKeyword	pointer
&&	O
strcmp	function
(	O
szKeyword	pointer
,	O
pkm	pointer
->	O
szKeyword	pointer
)	O
)	O
pkm	pointer
++	O
;	O
return	O
(	O
pkm	pointer
->	O
iKWCode	int
)	O
;	O
}	O
int	O
GetSBMLLex	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
int	O
iEnding	int
,	O
int	O
iKWCode	int
)	O
{	O
PSTRLEX	array
szLex	pointer
;	O
char	O
c	char
;	O
BOOL	int
bDone	int
=	O
FALSE	int
;	O
BOOL	int
bFound	int
=	O
FALSE	int
;	O
if	O
(	O
!	O
pibIn	pointer
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
!	O
pibIn	pointer
->	O
pbufCur	pointer
)	O
return	O
(	O
0	int
)	O
;	O
while	O
(	O
!	O
bDone	int
)	O
{	O
c	char
=	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
;	O
if	O
(	O
c	char
==	O
'<'	O
)	O
{	O
szLex	pointer
[	O
0	int
]	O
=	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
;	O
c	char
=	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
;	O
if	O
(	O
(	O
c	char
==	O
'!'	O
)	O
||	O
(	O
c	char
==	O
'?'	O
)	O
||	O
(	O
c	char
==	O
'/'	O
)	O
)	O
{	O
if	O
(	O
c	char
==	O
'/'	O
)	O
{	O
szLex	pointer
[	O
0	int
]	O
=	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
;	O
GetIdentifier	function
(	O
pibIn	pointer
,	O
szLex	pointer
)	O
;	O
bDone	int
=	O
(	O
GetSBMLKeywordCode	function
(	O
szLex	pointer
)	O
==	O
iEnding	int
)	O
;	O
}	O
else	O
while	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
!=	O
'>'	O
)	O
;	O
}	O
else	O
{	O
GetIdentifier	function
(	O
pibIn	pointer
,	O
szLex	pointer
)	O
;	O
bFound	int
=	O
(	O
iKWCode	int
==	O
GetSBMLKeywordCode	function
(	O
szLex	pointer
)	O
)	O
;	O
bDone	int
=	O
bFound	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
c	char
==	O
0	int
)	O
bDone	int
=	O
TRUE	int
;	O
else	O
pibIn	pointer
->	O
pbufCur	pointer
=	O
pibIn	pointer
->	O
pbufCur	pointer
+	O
1	int
;	O
}	O
}	O
return	O
(	O
bFound	int
)	O
;	O
}	O
void	O
SetVar	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PSTR	pointer
szName	pointer
,	O
PSTR	pointer
szVal	pointer
,	O
HANDLE	long
hType	long
)	O
{	O
PVMMAPSTRCT	pointer
pvm	pointer
;	O
PINPUTINFO	pointer
pinfo	pointer
=	O
(	O
PINPUTINFO	pointer
)	O
pibIn	pointer
->	O
pInfo	pointer
;	O
int	O
iKWCode	int
;	O
if	O
(	O
!	O
(	O
GetVarPTR	function
(	O
pinfo	pointer
->	O
pvmGloVars	pointer
,	O
szName	pointer
)	O
)	O
)	O
{	O
iKWCode	int
=	O
(	O
(	O
hType	long
==	O
ID_STATE	int
?	O
KM_STATES	int
:	O
(	O
hType	long
==	O
ID_INPUT	int
?	O
KM_INPUTS	int
:	O
(	O
hType	long
==	O
ID_OUTPUT	int
?	O
KM_OUTPUTS	int
:	O
KM_NULL	int
)	O
)	O
)	O
)	O
;	O
if	O
(	O
(	O
hType	long
==	O
ID_PARM	int
)	O
||	O
(	O
hType	long
==	O
(	O
ID_LOCALDYN	int
|	O
ID_SPACEFLAG	int
)	O
)	O
||	O
(	O
hType	long
==	O
(	O
ID_LOCALCALCOUT	int
|	O
ID_SPACEFLAG	int
)	O
)	O
||	O
(	O
hType	long
==	O
(	O
ID_LOCALSCALE	int
|	O
ID_SPACEFLAG	int
)	O
)	O
)	O
{	O
AddEquation	function
(	O
&	O
pinfo	pointer
->	O
pvmGloVars	pointer
,	O
szName	pointer
,	O
szVal	pointer
,	O
hType	long
)	O
;	O
if	O
(	O
hType	long
==	O
ID_PARM	int
)	O
printf	function
(	O
"param.   %s = %s\n"	pointer
,	O
szName	pointer
,	O
szVal	pointer
)	O
;	O
}	O
else	O
{	O
DeclareModelVar	function
(	O
pibIn	pointer
,	O
szName	pointer
,	O
iKWCode	int
)	O
;	O
pvm	pointer
=	O
GetVarPTR	function
(	O
pinfo	pointer
->	O
pvmGloVars	pointer
,	O
szName	pointer
)	O
;	O
DefineGlobalVar	function
(	O
pibIn	pointer
,	O
pvm	pointer
,	O
szName	pointer
,	O
szVal	pointer
,	O
hType	long
)	O
;	O
if	O
(	O
hType	long
==	O
ID_STATE	int
)	O
printf	function
(	O
"species  %s = %s\n"	pointer
,	O
szName	pointer
,	O
szVal	pointer
)	O
;	O
if	O
(	O
hType	long
==	O
ID_INPUT	int
)	O
printf	function
(	O
"input    %s = %s\n"	pointer
,	O
szName	pointer
,	O
szVal	pointer
)	O
;	O
if	O
(	O
hType	long
==	O
ID_OUTPUT	int
)	O
printf	function
(	O
"output   %s = %s\n"	pointer
,	O
szName	pointer
,	O
szVal	pointer
)	O
;	O
}	O
}	O
}	O
int	O
Create1Var	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvm	pointer
,	O
PVOID	pointer
pInfo	pointer
)	O
{	O
PFORSV	pointer
pV	pointer
=	O
(	O
PFORSV	pointer
)	O
pInfo	pointer
;	O
PSTRLEX	array
szTmp	array
;	O
if	O
(	O
pvm	pointer
->	O
szName	pointer
[	O
0	int
]	O
==	O
'_'	O
)	O
{	O
sprintf	function
(	O
szTmp	array
,	O
"%s%s"	pointer
,	O
pV	pointer
->	O
szName	pointer
,	O
pvm	pointer
->	O
szName	pointer
)	O
;	O
if	O
(	O
pvm	pointer
->	O
hType	long
==	O
(	O
ID_LOCALDYN	int
|	O
ID_SPACEFLAG	int
)	O
)	O
SetVar	function
(	O
pV	pointer
->	O
pibIn	pointer
,	O
szTmp	array
,	O
pvm	pointer
->	O
szEqn	pointer
,	O
pvm	pointer
->	O
hType	long
)	O
;	O
else	O
SetVar	function
(	O
pV	pointer
->	O
pibIn	pointer
,	O
szTmp	array
,	O
pV	pointer
->	O
szVal	pointer
,	O
pvm	pointer
->	O
hType	long
)	O
;	O
}	O
else	O
SetVar	function
(	O
pV	pointer
->	O
pibIn	pointer
,	O
pvm	pointer
->	O
szName	pointer
,	O
pvm	pointer
->	O
szEqn	pointer
,	O
pvm	pointer
->	O
hType	long
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
int	O
Transcribe1AlgEqn	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvm	pointer
,	O
PVOID	pointer
pInfo	pointer
)	O
{	O
PFORSV	pointer
pV	pointer
=	O
(	O
PFORSV	pointer
)	O
pInfo	pointer
;	O
PSTRLEX	array
szTmpName	array
=	O
""	pointer
;	O
PSTREQN	array
szTmpEq	array
=	O
""	pointer
;	O
INPUTBUF	struct
ibDummy	struct
;	O
PSTRLEX	array
szLex	pointer
;	O
int	O
iType	int
;	O
if	O
(	O
pvm	pointer
->	O
szName	pointer
[	O
0	int
]	O
==	O
'_'	O
)	O
{	O
sprintf	function
(	O
szTmpName	array
,	O
"%s%s"	pointer
,	O
pV	pointer
->	O
szName	pointer
,	O
pvm	pointer
->	O
szName	pointer
)	O
;	O
}	O
else	O
sprintf	function
(	O
szTmpName	array
,	O
"%s"	pointer
,	O
pvm	pointer
->	O
szName	pointer
)	O
;	O
MakeStringBuffer	function
(	O
NULL	O
,	O
&	O
ibDummy	struct
,	O
pvm	pointer
->	O
szEqn	pointer
)	O
;	O
while	O
(	O
!	O
EOB	O
(	O
&	O
ibDummy	struct
)	O
)	O
{	O
NextLex	function
(	O
&	O
ibDummy	struct
,	O
szLex	pointer
,	O
&	O
iType	int
)	O
;	O
if	O
(	O
(	O
iType	int
==	O
LX_IDENTIFIER	int
)	O
&&	O
!	O
(	O
IsMathFunc	function
(	O
szLex	pointer
)	O
)	O
&&	O
(	O
szLex	pointer
[	O
0	int
]	O
==	O
'_'	O
)	O
)	O
sprintf	function
(	O
szTmpEq	array
,	O
"%s%s%s"	pointer
,	O
szTmpEq	array
,	O
pV	pointer
->	O
szName	pointer
,	O
szLex	pointer
)	O
;	O
else	O
sprintf	function
(	O
szTmpEq	array
,	O
"%s%s"	pointer
,	O
szTmpEq	array
,	O
szLex	pointer
)	O
;	O
}	O
if	O
(	O
!	O
(	O
GetVarPTR	function
(	O
pV	pointer
->	O
pTarget	pointer
,	O
szTmpName	array
)	O
)	O
)	O
{	O
if	O
(	O
pvm	pointer
->	O
hType	long
<	O
ID_DERIV	int
)	O
{	O
DefineVariable	function
(	O
pV	pointer
->	O
pibIn	pointer
,	O
szTmpName	array
,	O
szTmpEq	array
,	O
KM_NULL	int
)	O
;	O
printf	function
(	O
"local v. %s = %s\n"	pointer
,	O
szTmpName	array
,	O
szTmpEq	array
)	O
;	O
}	O
else	O
{	O
if	O
(	O
pvm	pointer
->	O
hType	long
==	O
ID_INLINE	int
)	O
{	O
DefineVariable	function
(	O
pV	pointer
->	O
pibIn	pointer
,	O
szTmpName	array
,	O
szTmpEq	array
,	O
KM_INLINE	int
)	O
;	O
printf	function
(	O
"inline   %s\n"	pointer
,	O
szTmpEq	array
)	O
;	O
}	O
}	O
}	O
return	O
(	O
1	int
)	O
;	O
}	O
int	O
Transcribe1DiffEqn	function
(	O
PFILE	pointer
pfile	pointer
,	O
PVMMAPSTRCT	pointer
pvm	pointer
,	O
PVOID	pointer
pInfo	pointer
)	O
{	O
PFORSV	pointer
pV	pointer
=	O
(	O
PFORSV	pointer
)	O
pInfo	pointer
;	O
PSTRLEX	array
szTmpName	array
=	O
""	pointer
;	O
PSTREQN	array
szTmpEq	array
=	O
""	pointer
;	O
INPUTBUF	struct
ibDummy	struct
;	O
PSTRLEX	array
szLex	pointer
;	O
int	O
iType	int
;	O
if	O
(	O
(	O
pvm	pointer
->	O
hType	long
&	O
ID_TYPEMASK	int
)	O
!=	O
ID_DERIV	int
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
pvm	pointer
->	O
szName	pointer
[	O
0	int
]	O
==	O
'_'	O
)	O
{	O
sprintf	function
(	O
szTmpName	array
,	O
"%s%s"	pointer
,	O
pV	pointer
->	O
szName	pointer
,	O
pvm	pointer
->	O
szName	pointer
)	O
;	O
}	O
else	O
sprintf	function
(	O
szTmpName	array
,	O
"%s"	pointer
,	O
pvm	pointer
->	O
szName	pointer
)	O
;	O
MakeStringBuffer	function
(	O
NULL	O
,	O
&	O
ibDummy	struct
,	O
pvm	pointer
->	O
szEqn	pointer
)	O
;	O
while	O
(	O
!	O
EOB	O
(	O
&	O
ibDummy	struct
)	O
)	O
{	O
NextLex	function
(	O
&	O
ibDummy	struct
,	O
szLex	pointer
,	O
&	O
iType	int
)	O
;	O
if	O
(	O
(	O
iType	int
==	O
LX_IDENTIFIER	int
)	O
&&	O
!	O
(	O
IsMathFunc	function
(	O
szLex	pointer
)	O
)	O
&&	O
(	O
szLex	pointer
[	O
0	int
]	O
==	O
'_'	O
)	O
)	O
sprintf	function
(	O
szTmpEq	array
,	O
"%s%s%s"	pointer
,	O
szTmpEq	array
,	O
pV	pointer
->	O
szName	pointer
,	O
szLex	pointer
)	O
;	O
else	O
sprintf	function
(	O
szTmpEq	array
,	O
"%s%s"	pointer
,	O
szTmpEq	array
,	O
szLex	pointer
)	O
;	O
}	O
if	O
(	O
!	O
(	O
GetVarPTR	function
(	O
pV	pointer
->	O
pTarget	pointer
,	O
szTmpName	array
)	O
)	O
)	O
{	O
DefineVariable	function
(	O
pV	pointer
->	O
pibIn	pointer
,	O
szTmpName	array
,	O
szTmpEq	array
,	O
KM_DXDT	int
)	O
;	O
printf	function
(	O
"template ODE term for %s = %s\n"	pointer
,	O
szTmpName	array
,	O
szTmpEq	array
)	O
;	O
}	O
return	O
(	O
1	int
)	O
;	O
}	O
void	O
ReadCpt	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
BOOL	int
bTell	int
)	O
{	O
PSTRLEX	array
szName	pointer
;	O
PSTREQN	array
szEqn	pointer
;	O
int	O
iLexType	int
;	O
PINPUTINFO	pointer
pinfo	pointer
=	O
(	O
PINPUTINFO	pointer
)	O
pibIn	pointer
->	O
pInfo	pointer
;	O
pinfo	pointer
->	O
wContext	int
=	O
CN_GLOBAL	int
;	O
while	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
!=	O
'"'	O
)	O
;	O
GetIdentifier	function
(	O
pibIn	pointer
,	O
szName	pointer
)	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
szName	pointer
,	O
"compartment"	pointer
)	O
)	O
return	O
;	O
if	O
(	O
!	O
(	O
GetVarPTR	function
(	O
pinfo	pointer
->	O
pvmLocalCpts	pointer
,	O
szName	pointer
)	O
)	O
)	O
{	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
=	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
+	O
1	int
;	O
while	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
!=	O
'"'	O
)	O
;	O
GetNumber	function
(	O
pibIn	pointer
,	O
szEqn	pointer
,	O
&	O
iLexType	int
)	O
;	O
if	O
(	O
!	O
iLexType	int
)	O
sprintf	function
(	O
szEqn	pointer
,	O
"0.0"	pointer
)	O
;	O
AddEquation	function
(	O
&	O
pinfo	pointer
->	O
pvmLocalCpts	pointer
,	O
szName	pointer
,	O
szEqn	pointer
,	O
ID_COMPARTMENT	int
)	O
;	O
if	O
(	O
bTell	int
)	O
printf	function
(	O
"compart. %s = %s\n"	pointer
,	O
szName	pointer
,	O
szEqn	pointer
)	O
;	O
}	O
while	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
!=	O
'>'	O
)	O
;	O
}	O
void	O
ReadCpts	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
BOOL	int
bTell	int
)	O
{	O
PINPUTINFO	pointer
pinfo	pointer
=	O
(	O
PINPUTINFO	pointer
)	O
pibIn	pointer
->	O
pInfo	pointer
;	O
pinfo	pointer
->	O
pvmLocalCpts	pointer
=	O
NULL	O
;	O
while	O
(	O
GetSBMLLex	function
(	O
pibIn	pointer
,	O
KM_CPTLIST	int
,	O
KM_CPT	int
)	O
)	O
ReadCpt	function
(	O
pibIn	pointer
,	O
bTell	int
)	O
;	O
}	O
void	O
ReadFunction	function
(	O
PINPUTBUF	pointer
pibIn	pointer
)	O
{	O
PSTRLEX	array
szRName	pointer
;	O
PSTREQN	array
szEqn	pointer
;	O
int	O
bInited	pointer
=	O
FALSE	int
;	O
PINPUTINFO	pointer
pinfo	pointer
=	O
(	O
PINPUTINFO	pointer
)	O
pibIn	pointer
->	O
pInfo	pointer
;	O
pinfo	pointer
->	O
wContext	int
=	O
CN_DYNAMICS	int
;	O
while	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
!=	O
'"'	O
)	O
;	O
GetIdentifier	function
(	O
pibIn	pointer
,	O
szRName	pointer
)	O
;	O
while	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
!=	O
'>'	O
)	O
;	O
GetSBMLLex	function
(	O
pibIn	pointer
,	O
KM_SBML	int
,	O
KM_APPLY	int
)	O
;	O
ReadApply	function
(	O
pibIn	pointer
,	O
&	O
bInited	pointer
,	O
szEqn	pointer
)	O
;	O
printf	function
(	O
"rate for %s = %s\n"	pointer
,	O
szRName	pointer
,	O
szEqn	pointer
)	O
;	O
DefineVariable	function
(	O
pibIn	pointer
,	O
szRName	pointer
,	O
szEqn	pointer
,	O
KM_DXDT	int
)	O
;	O
while	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
!=	O
'>'	O
)	O
;	O
}	O
void	O
ReadFunctions	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
int	O
iSBML_level	int
)	O
{	O
if	O
(	O
iSBML_level	int
==	O
1	int
)	O
printf	function
(	O
"mod: ignoring function definitions in level 1...\n"	pointer
)	O
;	O
else	O
while	O
(	O
GetSBMLLex	function
(	O
pibIn	pointer
,	O
KM_FUNCLIST	int
,	O
KM_FUNC	int
)	O
)	O
ReadFunction	function
(	O
pibIn	pointer
)	O
;	O
}	O
void	O
ReadDifferentials	function
(	O
PINPUTBUF	pointer
pibIn	pointer
)	O
{	O
PSTRLEX	array
szRName	pointer
;	O
PINPUTINFO	pointer
pinfo	pointer
=	O
(	O
PINPUTINFO	pointer
)	O
pibIn	pointer
->	O
pInfo	pointer
;	O
pinfo	pointer
->	O
wContext	int
=	O
CN_DYNAMICS	int
;	O
while	O
(	O
GetSBMLLex	function
(	O
pibIn	pointer
,	O
KM_SBML	int
,	O
KM_REACTION	int
)	O
)	O
{	O
while	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
!=	O
'"'	O
)	O
;	O
GetIdentifier	function
(	O
pibIn	pointer
,	O
szRName	pointer
)	O
;	O
while	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
!=	O
'>'	O
)	O
;	O
GetSBMLLex	function
(	O
pibIn	pointer
,	O
KM_REACTION	int
,	O
KM_REACTANTS	int
)	O
;	O
while	O
(	O
GetSBMLLex	function
(	O
pibIn	pointer
,	O
KM_REACTANTS	int
,	O
KM_SPECIES_REF	int
)	O
)	O
{	O
ConstructEqn	function
(	O
pibIn	pointer
,	O
szRName	pointer
,	O
reactant	int
)	O
;	O
}	O
GetSBMLLex	function
(	O
pibIn	pointer
,	O
KM_REACTION	int
,	O
KM_PRODUCTS	int
)	O
;	O
while	O
(	O
GetSBMLLex	function
(	O
pibIn	pointer
,	O
KM_PRODUCTS	int
,	O
KM_SPECIES_REF	int
)	O
)	O
{	O
ConstructEqn	function
(	O
pibIn	pointer
,	O
szRName	pointer
,	O
product	int
)	O
;	O
}	O
}	O
}	O
void	O
ReadParameter	function
(	O
PINPUTBUF	pointer
pibIn	pointer
)	O
{	O
PSTRLEX	array
szName	pointer
;	O
PSTREQN	array
szEqn	pointer
;	O
int	O
iLexType	int
;	O
PVMMAPSTRCT	pointer
pvm	pointer
;	O
HANDLE	long
hType	long
;	O
PINPUTINFO	pointer
pinfo	pointer
=	O
(	O
PINPUTINFO	pointer
)	O
pibIn	pointer
->	O
pInfo	pointer
;	O
pinfo	pointer
->	O
wContext	int
=	O
CN_GLOBAL	int
;	O
while	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
!=	O
'"'	O
)	O
;	O
GetIdentifier	function
(	O
pibIn	pointer
,	O
szName	pointer
)	O
;	O
if	O
(	O
!	O
(	O
hType	long
=	O
GetVarType	function
(	O
pinfo	pointer
->	O
pvmGloVars	pointer
,	O
szName	pointer
)	O
)	O
)	O
{	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
=	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
+	O
1	int
;	O
while	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
!=	O
'"'	O
)	O
;	O
GetNumber	function
(	O
pibIn	pointer
,	O
szEqn	pointer
,	O
&	O
iLexType	int
)	O
;	O
if	O
(	O
!	O
iLexType	int
)	O
{	O
sprintf	function
(	O
szEqn	pointer
,	O
"0.0"	pointer
)	O
;	O
}	O
DefineGlobalVar	function
(	O
pibIn	pointer
,	O
pvm	pointer
,	O
szName	pointer
,	O
szEqn	pointer
,	O
hType	long
)	O
;	O
printf	function
(	O
"param.   %s = %s\n"	pointer
,	O
szName	pointer
,	O
szEqn	pointer
)	O
;	O
}	O
else	O
{	O
printf	function
(	O
"***Error: redeclaration of parameter %s\n"	pointer
,	O
szName	pointer
)	O
;	O
printf	function
(	O
"Exiting...\n\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
while	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
!=	O
'>'	O
)	O
;	O
}	O
void	O
ReadParameters	function
(	O
PINPUTBUF	pointer
pibIn	pointer
)	O
{	O
while	O
(	O
GetSBMLLex	function
(	O
pibIn	pointer
,	O
KM_PARAMS	int
,	O
KM_PARAM	int
)	O
)	O
ReadParameter	function
(	O
pibIn	pointer
)	O
;	O
}	O
void	O
ReadReaction_L1	function
(	O
PINPUTBUF	pointer
pibIn	pointer
)	O
{	O
PSTRLEX	array
szRName	pointer
;	O
PSTREQN	array
szEqn	pointer
;	O
PINPUTINFO	pointer
pinfo	pointer
=	O
(	O
PINPUTINFO	pointer
)	O
pibIn	pointer
->	O
pInfo	pointer
;	O
pinfo	pointer
->	O
wContext	int
=	O
CN_DYNAMICS	int
;	O
while	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
!=	O
'"'	O
)	O
;	O
GetIdentifier	function
(	O
pibIn	pointer
,	O
szRName	pointer
)	O
;	O
while	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
!=	O
'>'	O
)	O
;	O
GetSBMLLex	function
(	O
pibIn	pointer
,	O
KM_SBML	int
,	O
KM_LAW	int
)	O
;	O
while	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
!=	O
'"'	O
)	O
;	O
pibIn	pointer
->	O
pbufCur	pointer
=	O
pibIn	pointer
->	O
pbufCur	pointer
-	O
1	int
;	O
GetaString	function
(	O
pibIn	pointer
,	O
szEqn	pointer
)	O
;	O
printf	function
(	O
"reaction %s = %s\n"	pointer
,	O
szRName	pointer
,	O
szEqn	pointer
)	O
;	O
DefineVariable	function
(	O
pibIn	pointer
,	O
szRName	pointer
,	O
szEqn	pointer
,	O
0	int
)	O
;	O
while	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
!=	O
'>'	O
)	O
;	O
}	O
void	O
TranscribeOpSymbol	function
(	O
PSTR	pointer
szOp	pointer
)	O
{	O
switch	O
(	O
GetSBMLKeywordCode	function
(	O
szOp	pointer
)	O
)	O
{	O
case	O
KM_PLUS	int
:	O
sprintf	function
(	O
szOp	pointer
,	O
"%s"	pointer
,	O
"+"	pointer
)	O
;	O
break	O
;	O
case	O
KM_MINUS	int
:	O
sprintf	function
(	O
szOp	pointer
,	O
"%s"	pointer
,	O
"-"	pointer
)	O
;	O
break	O
;	O
case	O
KM_TIMES	int
:	O
sprintf	function
(	O
szOp	pointer
,	O
"%s"	pointer
,	O
"*"	pointer
)	O
;	O
break	O
;	O
case	O
KM_DIVIDE	int
:	O
sprintf	function
(	O
szOp	pointer
,	O
"%s"	pointer
,	O
"/"	pointer
)	O
;	O
break	O
;	O
case	O
KM_POWER	int
:	O
sprintf	function
(	O
szOp	pointer
,	O
"%s"	pointer
,	O
"pow"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
"***Error: unknown mathXML operation '%s' - exiting...\n\n"	pointer
,	O
szOp	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
}	O
void	O
ReadApply	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PINT	pointer
bInited	pointer
,	O
PSTR	pointer
szEqn	pointer
)	O
{	O
PSTRLEX	array
szOp	pointer
;	O
PSTRLEX	array
szLex	pointer
;	O
int	O
iKw	int
;	O
int	O
ithTerm	int
=	O
0	int
;	O
BOOL	int
bDone	int
=	O
FALSE	int
;	O
char	O
c	char
;	O
PINPUTINFO	pointer
pinfo	pointer
=	O
(	O
PINPUTINFO	pointer
)	O
pibIn	pointer
->	O
pInfo	pointer
;	O
if	O
(	O
*	O
bInited	pointer
)	O
sprintf	function
(	O
szEqn	pointer
,	O
"%s("	pointer
,	O
szEqn	pointer
)	O
;	O
else	O
{	O
sprintf	function
(	O
szEqn	pointer
,	O
"("	pointer
)	O
;	O
*	O
bInited	pointer
=	O
TRUE	int
;	O
}	O
while	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
!=	O
'<'	O
)	O
;	O
c	char
=	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
;	O
if	O
(	O
c	char
==	O
'!'	O
)	O
while	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
!=	O
'<'	O
)	O
;	O
GetIdentifier	function
(	O
pibIn	pointer
,	O
szOp	pointer
)	O
;	O
TranscribeOpSymbol	function
(	O
szOp	pointer
)	O
;	O
do	O
{	O
while	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
!=	O
'<'	O
)	O
;	O
c	char
=	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
;	O
if	O
(	O
c	char
==	O
'/'	O
)	O
{	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
;	O
GetIdentifier	function
(	O
pibIn	pointer
,	O
szLex	pointer
)	O
;	O
iKw	int
=	O
GetSBMLKeywordCode	function
(	O
szLex	pointer
)	O
;	O
if	O
(	O
(	O
iKw	int
==	O
KM_APPLY	int
)	O
||	O
(	O
iKw	int
==	O
KM_MATH	int
)	O
)	O
{	O
sprintf	function
(	O
szEqn	pointer
,	O
"%s)"	pointer
,	O
szEqn	pointer
)	O
;	O
return	O
;	O
}	O
}	O
else	O
GetIdentifier	function
(	O
pibIn	pointer
,	O
szLex	pointer
)	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
szLex	pointer
,	O
"apply"	pointer
)	O
)	O
{	O
ithTerm	int
++	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
szOp	pointer
,	O
"pow"	pointer
)	O
)	O
{	O
if	O
(	O
ithTerm	int
>	O
1	int
)	O
sprintf	function
(	O
szEqn	pointer
,	O
"%s)"	pointer
,	O
szEqn	pointer
)	O
;	O
else	O
sprintf	function
(	O
szEqn	pointer
,	O
"%s%s(,"	pointer
,	O
szEqn	pointer
,	O
szOp	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
ithTerm	int
>	O
1	int
)	O
sprintf	function
(	O
szEqn	pointer
,	O
"%s%s"	pointer
,	O
szEqn	pointer
,	O
szOp	pointer
)	O
;	O
}	O
ReadApply	function
(	O
pibIn	pointer
,	O
bInited	pointer
,	O
szEqn	pointer
)	O
;	O
}	O
else	O
{	O
do	O
{	O
pibIn	pointer
->	O
pbufCur	pointer
=	O
pibIn	pointer
->	O
pbufCur	pointer
+	O
1	int
;	O
SkipWhitespace	function
(	O
pibIn	pointer
)	O
;	O
GetIdentifier	function
(	O
pibIn	pointer
,	O
szLex	pointer
)	O
;	O
if	O
(	O
(	O
pinfo	pointer
->	O
bTemplateInUse	int
)	O
&&	O
(	O
!	O
GetVarPTR	function
(	O
pinfo	pointer
->	O
pvmGloVars	pointer
,	O
szLex	pointer
)	O
)	O
)	O
sprintf	function
(	O
szLex	pointer
,	O
"%s_%s"	pointer
,	O
szLex	pointer
,	O
pinfo	pointer
->	O
pvmLocalCpts	pointer
->	O
szName	pointer
)	O
;	O
ithTerm	int
++	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
szOp	pointer
,	O
"pow"	pointer
)	O
)	O
{	O
if	O
(	O
ithTerm	int
>	O
1	int
)	O
sprintf	function
(	O
szEqn	pointer
,	O
"%s%s)"	pointer
,	O
szEqn	pointer
,	O
szLex	pointer
)	O
;	O
else	O
sprintf	function
(	O
szEqn	pointer
,	O
"%s%s(%s,"	pointer
,	O
szEqn	pointer
,	O
szOp	pointer
,	O
szLex	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
ithTerm	int
>	O
1	int
)	O
sprintf	function
(	O
szEqn	pointer
,	O
"%s%s%s"	pointer
,	O
szEqn	pointer
,	O
szOp	pointer
,	O
szLex	pointer
)	O
;	O
else	O
sprintf	function
(	O
szEqn	pointer
,	O
"%s%s"	pointer
,	O
szEqn	pointer
,	O
szLex	pointer
)	O
;	O
}	O
}	O
while	O
(	O
GetSBMLLex	function
(	O
pibIn	pointer
,	O
KM_APPLY	int
,	O
KM_CI	int
)	O
)	O
;	O
sprintf	function
(	O
szEqn	pointer
,	O
"%s)"	pointer
,	O
szEqn	pointer
)	O
;	O
return	O
;	O
}	O
}	O
while	O
(	O
!	O
bDone	int
)	O
;	O
}	O
void	O
ReadReaction_L2	function
(	O
PINPUTBUF	pointer
pibIn	pointer
)	O
{	O
PSTRLEX	array
szRName	pointer
;	O
PSTREQN	array
szEqn	pointer
;	O
int	O
bInited	pointer
=	O
FALSE	int
;	O
PINPUTINFO	pointer
pinfo	pointer
=	O
(	O
PINPUTINFO	pointer
)	O
pibIn	pointer
->	O
pInfo	pointer
;	O
pinfo	pointer
->	O
wContext	int
=	O
CN_DYNAMICS	int
;	O
while	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
!=	O
'"'	O
)	O
;	O
GetIdentifier	function
(	O
pibIn	pointer
,	O
szRName	pointer
)	O
;	O
while	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
!=	O
'>'	O
)	O
;	O
GetSBMLLex	function
(	O
pibIn	pointer
,	O
KM_SBML	int
,	O
KM_APPLY	int
)	O
;	O
ReadApply	function
(	O
pibIn	pointer
,	O
&	O
bInited	pointer
,	O
szEqn	pointer
)	O
;	O
printf	function
(	O
"reaction %s = %s\n"	pointer
,	O
szRName	pointer
,	O
szEqn	pointer
)	O
;	O
DefineVariable	function
(	O
pibIn	pointer
,	O
szRName	pointer
,	O
szEqn	pointer
,	O
0	int
)	O
;	O
while	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
!=	O
'>'	O
)	O
;	O
}	O
void	O
ReadReactions	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
int	O
iSBML_level	int
)	O
{	O
while	O
(	O
GetSBMLLex	function
(	O
pibIn	pointer
,	O
KM_REACTIONS	int
,	O
KM_REACTION	int
)	O
)	O
{	O
if	O
(	O
iSBML_level	int
==	O
1	int
)	O
ReadReaction_L1	function
(	O
pibIn	pointer
)	O
;	O
else	O
ReadReaction_L2	function
(	O
pibIn	pointer
)	O
;	O
}	O
}	O
void	O
ReadRule	function
(	O
PINPUTBUF	pointer
pibIn	pointer
)	O
{	O
PSTRLEX	array
szRName	pointer
;	O
PSTREQN	array
szEqn	pointer
;	O
int	O
bInited	pointer
=	O
FALSE	int
;	O
PINPUTINFO	pointer
pinfo	pointer
=	O
(	O
PINPUTINFO	pointer
)	O
pibIn	pointer
->	O
pInfo	pointer
;	O
pinfo	pointer
->	O
wContext	int
=	O
CN_DYNAMICS	int
;	O
while	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
!=	O
'"'	O
)	O
;	O
GetIdentifier	function
(	O
pibIn	pointer
,	O
szRName	pointer
)	O
;	O
while	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
!=	O
'>'	O
)	O
;	O
GetSBMLLex	function
(	O
pibIn	pointer
,	O
KM_SBML	int
,	O
KM_APPLY	int
)	O
;	O
ReadApply	function
(	O
pibIn	pointer
,	O
&	O
bInited	pointer
,	O
szEqn	pointer
)	O
;	O
printf	function
(	O
"rate for %s = %s\n"	pointer
,	O
szRName	pointer
,	O
szEqn	pointer
)	O
;	O
DefineVariable	function
(	O
pibIn	pointer
,	O
szRName	pointer
,	O
szEqn	pointer
,	O
KM_DXDT	int
)	O
;	O
while	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
!=	O
'>'	O
)	O
;	O
}	O
void	O
ReadRules	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
int	O
iSBML_level	int
)	O
{	O
if	O
(	O
iSBML_level	int
==	O
1	int
)	O
printf	function
(	O
"mod: ignoring rate rules definitions in level 1...\n"	pointer
)	O
;	O
else	O
while	O
(	O
GetSBMLLex	function
(	O
pibIn	pointer
,	O
KM_RULESLIST	int
,	O
KM_RATERULE	int
)	O
)	O
ReadRule	function
(	O
pibIn	pointer
)	O
;	O
}	O
int	O
ReadSBMLLevel	function
(	O
PINPUTBUF	pointer
pibIn	pointer
)	O
{	O
PSTREQN	array
szEqn	pointer
;	O
int	O
iLexType	int
;	O
while	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
!=	O
'"'	O
)	O
;	O
while	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
!=	O
'"'	O
)	O
;	O
while	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
!=	O
'"'	O
)	O
;	O
GetNumber	function
(	O
pibIn	pointer
,	O
szEqn	pointer
,	O
&	O
iLexType	int
)	O
;	O
if	O
(	O
!	O
iLexType	int
)	O
{	O
printf	function
(	O
"***Error: cannot read the sbml level - exiting...\n\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
while	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
!=	O
'>'	O
)	O
;	O
switch	O
(	O
szEqn	pointer
[	O
0	int
]	O
)	O
{	O
case	O
'1'	O
:	O
printf	function
(	O
"sbml level 1\n"	pointer
)	O
;	O
return	O
(	O
1	int
)	O
;	O
case	O
'2'	O
:	O
printf	function
(	O
"sbml level 2\n"	pointer
)	O
;	O
return	O
(	O
2	int
)	O
;	O
default	O
:	O
printf	function
(	O
"***Error: unknown sbml level %s - exiting...\n\n"	pointer
,	O
szEqn	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
}	O
void	O
Read1Species	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
BOOL	int
bProcessPK_ODEs	int
)	O
{	O
PSTRLEX	array
szName	pointer
;	O
PSTRLEX	array
szBoundary	array
;	O
PSTRLEX	array
szCpt	array
;	O
PSTREQN	array
szEqn	pointer
;	O
int	O
iLexType	int
;	O
BOOL	int
bBoundary	int
;	O
FORSV	struct
sVar	struct
;	O
HANDLE	long
hType	long
;	O
PINPUTINFO	pointer
pinfo	pointer
=	O
(	O
PINPUTINFO	pointer
)	O
pibIn	pointer
->	O
pInfo	pointer
;	O
PINPUTINFO	pointer
ptempinfo	pointer
=	O
(	O
PINPUTINFO	pointer
)	O
pibIn	pointer
->	O
pTempInfo	pointer
;	O
PVMMAPSTRCT	pointer
pvm	pointer
;	O
pinfo	pointer
->	O
wContext	int
=	O
CN_GLOBAL	int
;	O
while	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
!=	O
'"'	O
)	O
;	O
GetIdentifier	function
(	O
pibIn	pointer
,	O
szName	pointer
)	O
;	O
pibIn	pointer
->	O
pbufCur	pointer
=	O
pibIn	pointer
->	O
pbufCur	pointer
+	O
1	int
;	O
while	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
!=	O
'"'	O
)	O
;	O
GetIdentifier	function
(	O
pibIn	pointer
,	O
szBoundary	array
)	O
;	O
pibIn	pointer
->	O
pbufCur	pointer
=	O
pibIn	pointer
->	O
pbufCur	pointer
+	O
1	int
;	O
bBoundary	int
=	O
!	O
strcmp	function
(	O
szBoundary	array
,	O
"true"	pointer
)	O
;	O
while	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
!=	O
'"'	O
)	O
;	O
GetNumber	function
(	O
pibIn	pointer
,	O
szEqn	pointer
,	O
&	O
iLexType	int
)	O
;	O
if	O
(	O
pinfo	pointer
->	O
bTemplateInUse	int
)	O
{	O
sprintf	function
(	O
szEqn	pointer
,	O
"0"	pointer
)	O
;	O
pibIn	pointer
->	O
pbufCur	pointer
=	O
pibIn	pointer
->	O
pbufCur	pointer
+	O
1	int
;	O
while	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
!=	O
'"'	O
)	O
;	O
GetIdentifier	function
(	O
pibIn	pointer
,	O
szCpt	array
)	O
;	O
if	O
(	O
strcmp	function
(	O
szCpt	array
,	O
"compartment"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
(	O
GetVarPTR	function
(	O
ptempinfo	pointer
->	O
pvmCpts	pointer
,	O
szCpt	array
)	O
)	O
)	O
{	O
printf	function
(	O
"***Error: template did not defined"	pointer
)	O
;	O
printf	function
(	O
" compartment '%s' - exiting...\n\n"	pointer
,	O
szCpt	array
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
else	O
sprintf	function
(	O
szName	pointer
,	O
"%s_%s"	pointer
,	O
szName	pointer
,	O
szCpt	array
)	O
;	O
if	O
(	O
bBoundary	int
)	O
{	O
if	O
(	O
!	O
(	O
hType	long
=	O
GetVarType	function
(	O
pinfo	pointer
->	O
pvmGloVars	pointer
,	O
szName	pointer
)	O
)	O
)	O
{	O
DefineGlobalVar	function
(	O
pibIn	pointer
,	O
pvm	pointer
,	O
szName	pointer
,	O
szEqn	pointer
,	O
hType	long
)	O
;	O
printf	function
(	O
"param.   %s = %s  (was boundary species)\n"	pointer
,	O
szName	pointer
,	O
szEqn	pointer
)	O
;	O
}	O
}	O
else	O
SetVar	function
(	O
pibIn	pointer
,	O
szName	pointer
,	O
szEqn	pointer
,	O
ID_STATE	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
bBoundary	int
)	O
{	O
printf	function
(	O
"***Error: Species %s is set to boundary;\n"	pointer
,	O
szName	pointer
)	O
;	O
printf	function
(	O
"          It has to be inside a meaningful compartment -"	pointer
)	O
;	O
printf	function
(	O
"exiting.\n\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
sVar	struct
.	O
pibIn	pointer
=	O
pibIn	pointer
;	O
sVar	struct
.	O
szName	pointer
=	O
szName	pointer
;	O
sVar	struct
.	O
szVal	pointer
=	O
szEqn	pointer
;	O
ForAllVar	function
(	O
NULL	O
,	O
ptempinfo	pointer
->	O
pvmGloVars	pointer
,	O
&	O
Create1Var	function
,	O
ID_NULL	int
,	O
(	O
PVOID	pointer
)	O
&	O
sVar	struct
)	O
;	O
pinfo	pointer
->	O
wContext	int
=	O
CN_DYNAMICS	int
;	O
sVar	struct
.	O
pTarget	pointer
=	O
pinfo	pointer
->	O
pvmDynEqns	pointer
;	O
ForAllVar	function
(	O
NULL	O
,	O
ptempinfo	pointer
->	O
pvmGloVars	pointer
,	O
&	O
Create1Var	function
,	O
ID_LOCALDYN	int
,	O
(	O
PVOID	pointer
)	O
&	O
sVar	struct
)	O
;	O
ForAllVar	function
(	O
NULL	O
,	O
ptempinfo	pointer
->	O
pvmDynEqns	pointer
,	O
&	O
Transcribe1AlgEqn	function
,	O
ID_NULL	int
,	O
(	O
PVOID	pointer
)	O
&	O
sVar	struct
)	O
;	O
if	O
(	O
bProcessPK_ODEs	int
)	O
ForAllVar	function
(	O
NULL	O
,	O
ptempinfo	pointer
->	O
pvmDynEqns	pointer
,	O
&	O
Transcribe1DiffEqn	function
,	O
ID_NULL	int
,	O
(	O
PVOID	pointer
)	O
&	O
sVar	struct
)	O
;	O
pinfo	pointer
->	O
wContext	int
=	O
CN_SCALE	int
;	O
sVar	struct
.	O
pTarget	pointer
=	O
pinfo	pointer
->	O
pvmScaleEqns	pointer
;	O
ForAllVar	function
(	O
NULL	O
,	O
ptempinfo	pointer
->	O
pvmGloVars	pointer
,	O
&	O
Create1Var	function
,	O
ID_LOCALSCALE	int
,	O
(	O
PVOID	pointer
)	O
&	O
sVar	struct
)	O
;	O
ForAllVar	function
(	O
NULL	O
,	O
ptempinfo	pointer
->	O
pvmScaleEqns	pointer
,	O
&	O
Transcribe1AlgEqn	function
,	O
ID_NULL	int
,	O
(	O
PVOID	pointer
)	O
&	O
sVar	struct
)	O
;	O
pinfo	pointer
->	O
wContext	int
=	O
CN_CALCOUTPUTS	int
;	O
sVar	struct
.	O
pTarget	pointer
=	O
pinfo	pointer
->	O
pvmCalcOutEqns	pointer
;	O
ForAllVar	function
(	O
NULL	O
,	O
ptempinfo	pointer
->	O
pvmGloVars	pointer
,	O
&	O
Create1Var	function
,	O
ID_LOCALCALCOUT	int
,	O
(	O
PVOID	pointer
)	O
&	O
sVar	struct
)	O
;	O
ForAllVar	function
(	O
NULL	O
,	O
ptempinfo	pointer
->	O
pvmCalcOutEqns	pointer
,	O
&	O
Transcribe1AlgEqn	function
,	O
ID_NULL	int
,	O
(	O
PVOID	pointer
)	O
&	O
sVar	struct
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
iLexType	int
)	O
sprintf	function
(	O
szEqn	pointer
,	O
"0.0"	pointer
)	O
;	O
if	O
(	O
bBoundary	int
)	O
{	O
if	O
(	O
!	O
(	O
hType	long
=	O
GetVarType	function
(	O
pinfo	pointer
->	O
pvmGloVars	pointer
,	O
szName	pointer
)	O
)	O
)	O
{	O
DefineGlobalVar	function
(	O
pibIn	pointer
,	O
pvm	pointer
,	O
szName	pointer
,	O
szEqn	pointer
,	O
hType	long
)	O
;	O
printf	function
(	O
"param.   %s = %s  (was boundary species)\n"	pointer
,	O
szName	pointer
,	O
szEqn	pointer
)	O
;	O
}	O
}	O
else	O
SetVar	function
(	O
pibIn	pointer
,	O
szName	pointer
,	O
szEqn	pointer
,	O
ID_STATE	int
)	O
;	O
}	O
while	O
(	O
*	O
pibIn	pointer
->	O
pbufCur	pointer
++	O
!=	O
'>'	O
)	O
;	O
}	O
void	O
ReadSpecies	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
int	O
iSBML_level	int
,	O
BOOL	int
bProcessPK_ODEs	int
)	O
{	O
while	O
(	O
GetSBMLLex	function
(	O
pibIn	pointer
,	O
KM_SPECIESLIST	int
,	O
KM_SPECIES	int
)	O
)	O
Read1Species	function
(	O
pibIn	pointer
,	O
bProcessPK_ODEs	int
)	O
;	O
}	O
void	O
ReadFileNames	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PLONG	pointer
nFiles	pointer
,	O
PSTR	pointer
*	O
*	O
pszNames	pointer
)	O
{	O
long	O
i	long
;	O
int	O
iLexType	int
,	O
iErr	int
=	O
0	int
;	O
char	O
szLex	pointer
[	O
MAX_FILENAMESIZE	int
]	O
;	O
PSTRLEX	array
szPunct	array
;	O
PSTR	pointer
pbufStore	pointer
;	O
pbufStore	pointer
=	O
pibIn	pointer
->	O
pbufCur	pointer
;	O
do	O
{	O
GetaString	function
(	O
pibIn	pointer
,	O
szLex	pointer
)	O
;	O
*	O
nFiles	pointer
=	O
*	O
nFiles	pointer
+	O
1	int
;	O
NextLex	function
(	O
pibIn	pointer
,	O
szPunct	array
,	O
&	O
iLexType	int
)	O
;	O
SkipWhitespace	function
(	O
pibIn	pointer
)	O
;	O
if	O
(	O
!	O
(	O
iLexType	int
&	O
LX_IDENTIFIER	int
)	O
)	O
{	O
if	O
(	O
(	O
szPunct	array
[	O
0	int
]	O
!=	O
','	O
)	O
&&	O
(	O
szPunct	array
[	O
0	int
]	O
!=	O
CH_RBRACE	O
)	O
)	O
iErr	int
=	O
szPunct	array
[	O
1	int
]	O
=	O
CH_RBRACE	O
;	O
}	O
}	O
while	O
(	O
(	O
szPunct	array
[	O
0	int
]	O
!=	O
CH_RBRACE	O
)	O
&&	O
(	O
!	O
iErr	int
)	O
)	O
;	O
if	O
(	O
!	O
(	O
*	O
pszNames	pointer
=	O
(	O
PSTR	pointer
*	O
)	O
malloc	function
(	O
*	O
nFiles	pointer
*	O
sizeof	O
(	O
PSTR	pointer
)	O
)	O
)	O
)	O
ReportError	function
(	O
NULL	O
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"ReadJModels"	pointer
,	O
NULL	O
)	O
;	O
pibIn	pointer
->	O
pbufCur	pointer
=	O
pbufStore	pointer
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
*	O
nFiles	pointer
;	O
i	long
++	O
)	O
{	O
GetaString	function
(	O
pibIn	pointer
,	O
szLex	pointer
)	O
;	O
NextLex	function
(	O
pibIn	pointer
,	O
szPunct	array
,	O
&	O
iLexType	int
)	O
;	O
SkipWhitespace	function
(	O
pibIn	pointer
)	O
;	O
if	O
(	O
!	O
(	O
(	O
*	O
pszNames	pointer
)	O
[	O
i	long
]	O
=	O
(	O
PSTR	pointer
)	O
malloc	function
(	O
strlen	function
(	O
szLex	pointer
)	O
+	O
1	int
)	O
)	O
)	O
ReportError	function
(	O
NULL	O
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"ReadFileNames"	pointer
,	O
NULL	O
)	O
;	O
else	O
strcpy	function
(	O
(	O
*	O
pszNames	pointer
)	O
[	O
i	long
]	O
,	O
szLex	pointer
)	O
;	O
}	O
}	O
void	O
ReadSBMLModels	function
(	O
PINPUTBUF	pointer
pibIn	pointer
)	O
{	O
long	O
i	long
,	O
nFiles	pointer
=	O
0	int
;	O
PSTR	pointer
*	O
pszFileNames	pointer
=	O
NULL	O
;	O
INPUTBUF	struct
ibInLocal	struct
;	O
int	O
iSBML_level	int
;	O
PINPUTINFO	pointer
pinfo	pointer
=	O
(	O
PINPUTINFO	pointer
)	O
pibIn	pointer
->	O
pInfo	pointer
;	O
ReadFileNames	function
(	O
pibIn	pointer
,	O
&	O
nFiles	pointer
,	O
&	O
pszFileNames	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nFiles	pointer
;	O
i	long
++	O
)	O
{	O
printf	function
(	O
"\nreading model %s\n"	pointer
,	O
pszFileNames	pointer
[	O
i	long
]	O
)	O
;	O
if	O
(	O
!	O
InitBuffer	function
(	O
&	O
ibInLocal	struct
,	O
-	O
1	int
,	O
pszFileNames	pointer
[	O
i	long
]	O
)	O
)	O
ReportError	function
(	O
&	O
ibInLocal	struct
,	O
RE_INIT	int
|	O
RE_FATAL	int
,	O
"ReadJModels"	pointer
,	O
NULL	O
)	O
;	O
ibInLocal	struct
.	O
pInfo	pointer
=	O
pibIn	pointer
->	O
pInfo	pointer
;	O
ibInLocal	struct
.	O
pTempInfo	pointer
=	O
pibIn	pointer
->	O
pTempInfo	pointer
;	O
if	O
(	O
GetSBMLLex	function
(	O
&	O
ibInLocal	struct
,	O
KM_SBML	int
,	O
KM_SBML	int
)	O
)	O
iSBML_level	int
=	O
ReadSBMLLevel	function
(	O
&	O
ibInLocal	struct
)	O
;	O
if	O
(	O
(	O
pinfo	pointer
->	O
bTemplateInUse	int
)	O
&&	O
(	O
iSBML_level	int
<	O
2	int
)	O
)	O
{	O
printf	function
(	O
"***Error: use of a PK template requires "	pointer
)	O
;	O
printf	function
(	O
"SBML level 2 - exiting.\n\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
if	O
(	O
pinfo	pointer
->	O
bTemplateInUse	int
)	O
{	O
ibInLocal	struct
.	O
pbufCur	pointer
=	O
ibInLocal	struct
.	O
pbufOrg	pointer
;	O
if	O
(	O
GetSBMLLex	function
(	O
&	O
ibInLocal	struct
,	O
KM_SBML	int
,	O
KM_CPTLIST	int
)	O
)	O
ReadCpts	function
(	O
&	O
ibInLocal	struct
,	O
TRUE	int
)	O
;	O
}	O
else	O
{	O
printf	function
(	O
"no PK template given: ignoring SBML compartments\n"	pointer
)	O
;	O
}	O
ibInLocal	struct
.	O
pbufCur	pointer
=	O
ibInLocal	struct
.	O
pbufOrg	pointer
;	O
if	O
(	O
GetSBMLLex	function
(	O
&	O
ibInLocal	struct
,	O
KM_SBML	int
,	O
KM_FUNCLIST	int
)	O
)	O
ReadFunctions	function
(	O
&	O
ibInLocal	struct
,	O
iSBML_level	int
)	O
;	O
ibInLocal	struct
.	O
pbufCur	pointer
=	O
ibInLocal	struct
.	O
pbufOrg	pointer
;	O
while	O
(	O
GetSBMLLex	function
(	O
&	O
ibInLocal	struct
,	O
KM_SBML	int
,	O
KM_PARAMS	int
)	O
)	O
ReadParameters	function
(	O
&	O
ibInLocal	struct
)	O
;	O
ibInLocal	struct
.	O
pbufCur	pointer
=	O
ibInLocal	struct
.	O
pbufOrg	pointer
;	O
if	O
(	O
GetSBMLLex	function
(	O
&	O
ibInLocal	struct
,	O
KM_SBML	int
,	O
KM_SPECIESLIST	int
)	O
)	O
ReadSpecies	function
(	O
&	O
ibInLocal	struct
,	O
iSBML_level	int
,	O
FALSE	int
)	O
;	O
ibInLocal	struct
.	O
pbufCur	pointer
=	O
ibInLocal	struct
.	O
pbufOrg	pointer
;	O
if	O
(	O
GetSBMLLex	function
(	O
&	O
ibInLocal	struct
,	O
KM_SBML	int
,	O
KM_RULESLIST	int
)	O
)	O
ReadRules	function
(	O
&	O
ibInLocal	struct
,	O
iSBML_level	int
)	O
;	O
ibInLocal	struct
.	O
pbufCur	pointer
=	O
ibInLocal	struct
.	O
pbufOrg	pointer
;	O
if	O
(	O
GetSBMLLex	function
(	O
&	O
ibInLocal	struct
,	O
KM_SBML	int
,	O
KM_REACTIONS	int
)	O
)	O
ReadReactions	function
(	O
&	O
ibInLocal	struct
,	O
iSBML_level	int
)	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nFiles	pointer
;	O
i	long
++	O
)	O
{	O
if	O
(	O
!	O
InitBuffer	function
(	O
&	O
ibInLocal	struct
,	O
-	O
1	int
,	O
pszFileNames	pointer
[	O
i	long
]	O
)	O
)	O
ReportError	function
(	O
&	O
ibInLocal	struct
,	O
RE_INIT	int
|	O
RE_FATAL	int
,	O
"ReadJModels"	pointer
,	O
NULL	O
)	O
;	O
ibInLocal	struct
.	O
pInfo	pointer
=	O
pibIn	pointer
->	O
pInfo	pointer
;	O
ibInLocal	struct
.	O
pTempInfo	pointer
=	O
pibIn	pointer
->	O
pTempInfo	pointer
;	O
if	O
(	O
pinfo	pointer
->	O
bTemplateInUse	int
)	O
{	O
if	O
(	O
GetSBMLLex	function
(	O
&	O
ibInLocal	struct
,	O
KM_SBML	int
,	O
KM_CPTLIST	int
)	O
)	O
ReadCpts	function
(	O
&	O
ibInLocal	struct
,	O
FALSE	int
)	O
;	O
}	O
printf	function
(	O
"\nmod: reading differentials in model %s\n"	pointer
,	O
pszFileNames	pointer
[	O
i	long
]	O
)	O
;	O
ibInLocal	struct
.	O
pbufCur	pointer
=	O
ibInLocal	struct
.	O
pbufOrg	pointer
;	O
if	O
(	O
GetSBMLLex	function
(	O
&	O
ibInLocal	struct
,	O
KM_SBML	int
,	O
KM_SPECIESLIST	int
)	O
)	O
ReadSpecies	function
(	O
&	O
ibInLocal	struct
,	O
iSBML_level	int
,	O
TRUE	int
)	O
;	O
ReadDifferentials	function
(	O
&	O
ibInLocal	struct
)	O
;	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nFiles	pointer
;	O
i	long
++	O
)	O
free	function
(	O
pszFileNames	pointer
[	O
i	long
]	O
)	O
;	O
free	function
(	O
pszFileNames	pointer
)	O
;	O
pinfo	pointer
->	O
wContext	int
=	O
CN_END	int
;	O
}	O
void	O
ReadPKTemplate	function
(	O
PINPUTBUF	pointer
pibIn	pointer
)	O
{	O
INPUTBUF	struct
ibInLocal	struct
;	O
PSTRLEX	array
szLex	pointer
;	O
PSTREQN	array
szEqn	pointer
;	O
int	O
iLexType	int
;	O
long	O
nFiles	pointer
=	O
0	int
;	O
PSTR	pointer
*	O
pszFileNames	pointer
;	O
PINPUTINFO	pointer
pinfo	pointer
;	O
pinfo	pointer
=	O
(	O
PINPUTINFO	pointer
)	O
pibIn	pointer
->	O
pTempInfo	pointer
;	O
pinfo	pointer
->	O
wContext	int
=	O
CN_GLOBAL	int
;	O
ReadFileNames	function
(	O
pibIn	pointer
,	O
&	O
nFiles	pointer
,	O
&	O
pszFileNames	pointer
)	O
;	O
if	O
(	O
nFiles	pointer
>	O
1	int
)	O
printf	function
(	O
"mod: cannot use more that one template - using only the 1st\n\n"	pointer
)	O
;	O
printf	function
(	O
"%s\n"	pointer
,	O
pszFileNames	pointer
[	O
0	int
]	O
)	O
;	O
if	O
(	O
!	O
InitBuffer	function
(	O
&	O
ibInLocal	struct
,	O
BUFFER_SIZE	int
,	O
pszFileNames	pointer
[	O
0	int
]	O
)	O
)	O
ReportError	function
(	O
&	O
ibInLocal	struct
,	O
RE_INIT	int
|	O
RE_FATAL	int
,	O
"ReadModel"	pointer
,	O
NULL	O
)	O
;	O
ibInLocal	struct
.	O
pInfo	pointer
=	O
(	O
PVOID	pointer
)	O
pinfo	pointer
;	O
do	O
{	O
NextLex	function
(	O
&	O
ibInLocal	struct
,	O
szLex	pointer
,	O
&	O
iLexType	int
)	O
;	O
switch	O
(	O
iLexType	int
)	O
{	O
case	O
LX_NULL	int
:	O
pinfo	pointer
->	O
wContext	int
=	O
CN_END	int
;	O
break	O
;	O
case	O
LX_IDENTIFIER	int
:	O
ProcessWord	function
(	O
&	O
ibInLocal	struct
,	O
szLex	pointer
,	O
szEqn	pointer
)	O
;	O
break	O
;	O
case	O
LX_PUNCT	int
:	O
case	O
LX_EQNPUNCT	int
:	O
if	O
(	O
szLex	pointer
[	O
0	int
]	O
==	O
CH_STMTTERM	O
)	O
{	O
break	O
;	O
}	O
else	O
{	O
if	O
(	O
szLex	pointer
[	O
0	int
]	O
==	O
CH_RBRACE	O
&&	O
(	O
pinfo	pointer
->	O
wContext	int
&	O
(	O
CN_DYNAMICS	int
|	O
CN_JACOB	int
|	O
CN_SCALE	int
)	O
)	O
)	O
{	O
pinfo	pointer
->	O
wContext	int
=	O
CN_GLOBAL	int
;	O
break	O
;	O
}	O
else	O
{	O
if	O
(	O
szLex	pointer
[	O
0	int
]	O
==	O
CH_COMMENT	O
)	O
{	O
SkipComment	function
(	O
&	O
ibInLocal	struct
)	O
;	O
break	O
;	O
}	O
}	O
}	O
default	O
:	O
ReportError	function
(	O
&	O
ibInLocal	struct
,	O
RE_UNEXPECTED	int
,	O
szLex	pointer
,	O
"* Ignoring"	pointer
)	O
;	O
break	O
;	O
case	O
LX_INTEGER	int
:	O
case	O
LX_FLOAT	int
:	O
ReportError	function
(	O
&	O
ibInLocal	struct
,	O
RE_UNEXPNUMBER	int
,	O
szLex	pointer
,	O
"* Ignoring"	pointer
)	O
;	O
break	O
;	O
}	O
}	O
while	O
(	O
pinfo	pointer
->	O
wContext	int
!=	O
CN_END	int
&&	O
(	O
*	O
ibInLocal	struct
.	O
pbufCur	pointer
||	O
FillBuffer	function
(	O
&	O
ibInLocal	struct
,	O
BUFFER_SIZE	int
)	O
!=	O
EOF	O
)	O
)	O
;	O
fclose	function
(	O
ibInLocal	struct
.	O
pfileIn	pointer
)	O
;	O
ReversePointers	function
(	O
&	O
pinfo	pointer
->	O
pvmGloVars	pointer
)	O
;	O
ReversePointers	function
(	O
&	O
pinfo	pointer
->	O
pvmDynEqns	pointer
)	O
;	O
ReversePointers	function
(	O
&	O
pinfo	pointer
->	O
pvmScaleEqns	pointer
)	O
;	O
ReversePointers	function
(	O
&	O
pinfo	pointer
->	O
pvmCalcOutEqns	pointer
)	O
;	O
ReversePointers	function
(	O
&	O
pinfo	pointer
->	O
pvmJacobEqns	pointer
)	O
;	O
pinfo	pointer
=	O
(	O
PINPUTINFO	pointer
)	O
pibIn	pointer
->	O
pInfo	pointer
;	O
pinfo	pointer
->	O
wContext	int
=	O
CN_TEMPLATE_DEFINED	int
;	O
pinfo	pointer
->	O
bTemplateInUse	int
=	O
TRUE	int
;	O
}	O
