const	O
char	O
*	O
argp_program_version	pointer
=	O
STANDARD_HURD_VERSION	function
(	O
term	O
)	O
;	O
int	O
trivfs_fstype	int
=	O
FSTYPE_TERM	O
;	O
int	O
trivfs_fsid	int
=	O
0	int
;	O
int	O
trivfs_support_read	int
=	O
1	int
;	O
int	O
trivfs_support_write	int
=	O
1	int
;	O
int	O
trivfs_support_exec	int
=	O
0	int
;	O
int	O
trivfs_allow_open	int
=	O
O_READ	O
|	O
O_WRITE	O
;	O
enum	O
tty_type	enum
{	O
T_NONE	int
=	O
0	int
,	O
T_DEVICE	int
,	O
T_HURDIO	int
,	O
T_PTYMASTER	int
,	O
T_PTYSLAVE	int
}	O
;	O
static	O
const	O
char	O
*	O
const	O
tty_type_names	array
[	O
]	O
=	O
{	O
[	O
T_DEVICE	int
]	O
=	O
"device"	pointer
,	O
[	O
T_HURDIO	int
]	O
=	O
"hurdio"	pointer
,	O
[	O
T_PTYMASTER	int
]	O
=	O
"pty-master"	pointer
,	O
[	O
T_PTYSLAVE	int
]	O
=	O
"pty-slave"	pointer
,	O
}	O
;	O
char	O
*	O
tty_name	pointer
;	O
enum	O
tty_type	enum
tty_type	enum
;	O
char	O
*	O
tty_arg	pointer
;	O
dev_t	long
rdev	long
;	O
int	O
demuxer	function
(	O
mach_msg_header_t	O
*	O
inp	pointer
,	O
mach_msg_header_t	O
*	O
outp	pointer
)	O
{	O
mig_routine_t	O
routine	O
;	O
if	O
(	O
(	O
routine	O
=	O
NULL	O
,	O
trivfs_demuxer	function
(	O
inp	pointer
,	O
outp	pointer
)	O
)	O
||	O
(	O
routine	O
=	O
term_server_routine	function
(	O
inp	pointer
)	O
)	O
||	O
(	O
routine	O
=	O
tioctl_server_routine	function
(	O
inp	pointer
)	O
)	O
||	O
(	O
routine	O
=	O
device_reply_server_routine	function
(	O
inp	pointer
)	O
)	O
)	O
{	O
if	O
(	O
routine	O
)	O
(	O
*	O
routine	O
)	O
(	O
inp	pointer
,	O
outp	pointer
)	O
;	O
return	O
TRUE	O
;	O
}	O
else	O
return	O
FALSE	O
;	O
}	O
static	O
struct	O
argp_option	O
options	int
[	O
]	O
=	O
{	O
{	O
"rdev"	pointer
,	O
'n'	O
,	O
"ID"	pointer
,	O
0	int
,	O
"The stat rdev number for this node; may be either a"	pointer
" single integer, or of the form MAJOR,MINOR"	pointer
}	O
,	O
{	O
"name"	pointer
,	O
'N'	O
,	O
"NAME"	pointer
,	O
0	int
,	O
"The name of this node, to be returned by term_get_nodename."	pointer
}	O
,	O
{	O
"type"	pointer
,	O
'T'	O
,	O
"TYPE"	pointer
,	O
0	int
,	O
"Backend type, see below.  This determines the meaning of the argument."	pointer
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
error_t	int
parse_opt	function
(	O
int	O
opt	int
,	O
char	O
*	O
arg	pointer
,	O
struct	O
argp_state	O
*	O
state	pointer
)	O
{	O
struct	O
{	O
dev_t	long
rdev	long
;	O
int	O
rdev_set	int
;	O
enum	O
tty_type	enum
type	enum
;	O
char	O
*	O
name	pointer
;	O
char	O
*	O
arg	pointer
;	O
}	O
*	O
const	O
v	pointer
=	O
state	pointer
->	O
hook	O
;	O
switch	O
(	O
opt	int
)	O
{	O
default	O
:	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
case	O
ARGP_KEY_INIT	O
:	O
state	pointer
->	O
hook	O
=	O
calloc	O
(	O
1	int
,	O
sizeof	O
*	O
v	pointer
)	O
;	O
break	O
;	O
case	O
ARGP_KEY_FINI	O
:	O
free	function
(	O
v	pointer
)	O
;	O
state	pointer
->	O
hook	O
=	O
0	int
;	O
break	O
;	O
case	O
'n'	O
:	O
{	O
char	O
*	O
start	pointer
=	O
arg	pointer
;	O
char	O
*	O
end	pointer
;	O
v	pointer
->	O
rdev	long
=	O
strtoumax	function
(	O
start	pointer
,	O
&	O
end	pointer
,	O
0	int
)	O
;	O
if	O
(	O
*	O
end	pointer
==	O
','	O
)	O
{	O
start	pointer
=	O
end	pointer
;	O
v	pointer
->	O
rdev	long
=	O
(	O
rdev	long
<<	O
8	int
)	O
+	O
strtoul	O
(	O
start	pointer
,	O
&	O
end	pointer
,	O
0	int
)	O
;	O
}	O
if	O
(	O
end	pointer
==	O
start	pointer
||	O
*	O
end	pointer
!=	O
'\0'	O
)	O
{	O
argp_error	function
(	O
state	pointer
,	O
"%s: Invalid argument to --rdev"	pointer
,	O
arg	pointer
)	O
;	O
return	O
EINVAL	int
;	O
}	O
v	pointer
->	O
rdev_set	int
=	O
1	int
;	O
}	O
break	O
;	O
case	O
'N'	O
:	O
v	pointer
->	O
name	pointer
=	O
arg	pointer
;	O
break	O
;	O
case	O
ARGP_KEY_ARG	O
:	O
if	O
(	O
!	O
v	pointer
->	O
name	pointer
&&	O
state	pointer
->	O
input	O
==	O
0	int
)	O
v	pointer
->	O
name	pointer
=	O
arg	pointer
;	O
else	O
if	O
(	O
!	O
v	pointer
->	O
type	enum
&&	O
state	pointer
->	O
input	O
==	O
0	int
)	O
{	O
case	O
'T'	O
:	O
if	O
(	O
!	O
strcmp	O
(	O
arg	pointer
,	O
"device"	pointer
)	O
)	O
v	pointer
->	O
type	enum
=	O
T_DEVICE	int
;	O
else	O
if	O
(	O
!	O
strcmp	O
(	O
arg	pointer
,	O
"hurdio"	pointer
)	O
)	O
v	pointer
->	O
type	enum
=	O
T_HURDIO	int
;	O
else	O
if	O
(	O
!	O
strcmp	O
(	O
arg	pointer
,	O
"pty-master"	pointer
)	O
)	O
v	pointer
->	O
type	enum
=	O
T_PTYMASTER	int
;	O
else	O
if	O
(	O
!	O
strcmp	O
(	O
arg	pointer
,	O
"pty-slave"	pointer
)	O
)	O
v	pointer
->	O
type	enum
=	O
T_PTYSLAVE	int
;	O
else	O
{	O
argp_error	function
(	O
state	pointer
,	O
"Invalid terminal type"	pointer
)	O
;	O
return	O
EINVAL	int
;	O
}	O
}	O
else	O
if	O
(	O
!	O
v	pointer
->	O
arg	pointer
)	O
v	pointer
->	O
arg	pointer
=	O
arg	pointer
;	O
else	O
{	O
argp_error	function
(	O
state	pointer
,	O
"Too many arguments"	pointer
)	O
;	O
return	O
EINVAL	int
;	O
}	O
break	O
;	O
case	O
ARGP_KEY_END	O
:	O
if	O
(	O
(	O
v	pointer
->	O
type	enum
&&	O
v	pointer
->	O
type	enum
!=	O
T_HURDIO	int
&&	O
v	pointer
->	O
arg	pointer
==	O
0	int
)	O
||	O
(	O
state	pointer
->	O
input	O
==	O
0	int
&&	O
v	pointer
->	O
name	pointer
==	O
0	int
)	O
)	O
{	O
argp_error	function
(	O
state	pointer
,	O
"Too few arguments"	pointer
)	O
;	O
return	O
EINVAL	int
;	O
}	O
break	O
;	O
case	O
ARGP_KEY_SUCCESS	O
:	O
if	O
(	O
v	pointer
->	O
rdev_set	int
)	O
rdev	long
=	O
v	pointer
->	O
rdev	long
;	O
if	O
(	O
v	pointer
->	O
name	pointer
)	O
{	O
free	function
(	O
tty_name	pointer
)	O
;	O
tty_name	pointer
=	O
strdup	O
(	O
v	pointer
->	O
name	pointer
)	O
;	O
}	O
if	O
(	O
state	pointer
->	O
input	O
==	O
0	int
)	O
{	O
tty_type	enum
=	O
v	pointer
->	O
type	enum
?	O
:	O
T_HURDIO	int
;	O
tty_arg	pointer
=	O
v	pointer
->	O
arg	pointer
?	O
strdup	O
(	O
v	pointer
->	O
arg	pointer
)	O
:	O
0	int
;	O
}	O
else	O
if	O
(	O
v	pointer
->	O
type	enum
||	O
v	pointer
->	O
arg	pointer
)	O
{	O
if	O
(	O
!	O
v	pointer
->	O
type	enum
)	O
v	pointer
->	O
type	enum
=	O
T_HURDIO	int
;	O
switch	O
(	O
v	pointer
->	O
type	enum
)	O
{	O
case	O
T_PTYMASTER	int
:	O
case	O
T_PTYSLAVE	int
:	O
return	O
EINVAL	int
;	O
default	O
:	O
break	O
;	O
}	O
switch	O
(	O
tty_type	enum
)	O
{	O
case	O
T_PTYMASTER	int
:	O
case	O
T_PTYSLAVE	int
:	O
return	O
EINVAL	int
;	O
default	O
:	O
break	O
;	O
}	O
pthread_mutex_lock	function
(	O
&	O
global_lock	union
)	O
;	O
(	O
*	O
bottom	pointer
->	O
fini	pointer
)	O
(	O
)	O
;	O
tty_type	enum
=	O
v	pointer
->	O
type	enum
;	O
switch	O
(	O
tty_type	enum
)	O
{	O
case	O
T_DEVICE	int
:	O
bottom	pointer
=	O
&	O
devio_bottom	struct
;	O
break	O
;	O
case	O
T_HURDIO	int
:	O
bottom	pointer
=	O
&	O
hurdio_bottom	struct
;	O
break	O
;	O
default	O
:	O
assert	O
(	O
!	O
"impossible type"	pointer
)	O
;	O
break	O
;	O
}	O
free	function
(	O
tty_arg	pointer
)	O
;	O
tty_arg	pointer
=	O
strdup	O
(	O
v	pointer
->	O
arg	pointer
)	O
;	O
error_t	int
err	int
=	O
(	O
*	O
bottom	pointer
->	O
init	pointer
)	O
(	O
)	O
;	O
if	O
(	O
err	int
==	O
0	int
&&	O
(	O
termflags	long
&	O
TTY_OPEN	int
)	O
)	O
err	int
=	O
(	O
*	O
bottom	pointer
->	O
assert_dtr	pointer
)	O
(	O
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	union
)	O
;	O
return	O
err	int
;	O
}	O
break	O
;	O
case	O
ARGP_KEY_ERROR	O
:	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
argp	O
term_argp	struct
=	O
{	O
options	int
,	O
parse_opt	function
,	O
"NAME TYPE ARG"	pointer
,	O
"A translator that implements POSIX termios discipline.\v"	pointer
"Possible values for TYPE:\n"	pointer
"  device      Use Mach device ARG for underlying i/o.\n"	pointer
"  hurdio      Use file ARG for i/o, underlying node if no ARG.\n"	pointer
"  pty-master  Master for slave at ARG.\n"	pointer
"  pty-slave   Slave for master at ARG.\n"	pointer
"\n"	pointer
"The default type is `hurdio', so no arguments uses the underlying node.\n"	pointer
"The filename of the node that the translator is attached to should be\n"	pointer
"supplied in NAME.\n"	pointer
}	O
;	O
struct	O
argp	O
*	O
trivfs_runtime_argp	pointer
=	O
&	O
term_argp	struct
;	O
error_t	int
trivfs_append_args	function
(	O
struct	O
trivfs_control	O
*	O
fsys	pointer
,	O
char	O
*	O
*	O
argz	pointer
,	O
size_t	long
*	O
argz_len	pointer
)	O
{	O
error_t	int
err	int
=	O
0	int
;	O
if	O
(	O
rdev	long
)	O
{	O
char	O
buf	array
[	O
64	int
]	O
;	O
snprintf	O
(	O
buf	array
,	O
sizeof	O
buf	array
,	O
"--rdev=%#jx"	pointer
,	O
(	O
uintmax_t	O
)	O
rdev	long
)	O
;	O
err	int
=	O
argz_add	function
(	O
argz	pointer
,	O
argz_len	pointer
,	O
buf	array
)	O
;	O
}	O
if	O
(	O
!	O
err	int
&&	O
tty_name	pointer
)	O
err	int
=	O
argz_add	function
(	O
argz	pointer
,	O
argz_len	pointer
,	O
"--name"	pointer
)	O
?	O
:	O
argz_add	function
(	O
argz	pointer
,	O
argz_len	pointer
,	O
tty_name	pointer
)	O
;	O
if	O
(	O
!	O
err	int
&&	O
tty_type	enum
!=	O
T_HURDIO	int
)	O
err	int
=	O
argz_add	function
(	O
argz	pointer
,	O
argz_len	pointer
,	O
"--type"	pointer
)	O
?	O
:	O
argz_add	function
(	O
argz	pointer
,	O
argz_len	pointer
,	O
tty_type_names	array
[	O
tty_type	enum
]	O
)	O
;	O
if	O
(	O
!	O
err	int
&&	O
tty_arg	pointer
)	O
err	int
=	O
argz_add	function
(	O
argz	pointer
,	O
argz_len	pointer
,	O
tty_arg	pointer
)	O
;	O
return	O
err	int
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
struct	O
port_class	O
*	O
ourclass	pointer
,	O
*	O
ourcntlclass	pointer
;	O
struct	O
port_class	O
*	O
peerclass	pointer
,	O
*	O
peercntlclass	pointer
;	O
struct	O
trivfs_control	O
*	O
*	O
ourcntl	pointer
,	O
*	O
*	O
peercntl	pointer
;	O
mach_port_t	int
bootstrap	O
,	O
right	O
;	O
struct	O
stat	O
st	struct
;	O
error_t	int
err	int
;	O
int	O
openmode	int
;	O
term_bucket	pointer
=	O
ports_create_bucket	function
(	O
)	O
;	O
trivfs_add_control_port_class	function
(	O
&	O
tty_cntl_class	pointer
)	O
;	O
trivfs_add_control_port_class	function
(	O
&	O
pty_cntl_class	pointer
)	O
;	O
trivfs_add_protid_port_class	function
(	O
&	O
tty_class	pointer
)	O
;	O
trivfs_add_protid_port_class	function
(	O
&	O
pty_class	pointer
)	O
;	O
cttyid_class	pointer
=	O
ports_create_class	function
(	O
0	int
,	O
0	int
)	O
;	O
init_users	function
(	O
)	O
;	O
argp_parse	function
(	O
&	O
term_argp	struct
,	O
argc	int
,	O
argv	pointer
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
switch	O
(	O
tty_type	enum
)	O
{	O
case	O
T_DEVICE	int
:	O
bottom	pointer
=	O
&	O
devio_bottom	struct
;	O
ourclass	pointer
=	O
tty_class	pointer
;	O
ourcntlclass	pointer
=	O
tty_cntl_class	pointer
;	O
ourcntl	pointer
=	O
&	O
termctl	pointer
;	O
peerclass	pointer
=	O
0	int
;	O
peercntlclass	pointer
=	O
0	int
;	O
peercntl	pointer
=	O
0	int
;	O
openmode	int
=	O
0	int
;	O
break	O
;	O
case	O
T_HURDIO	int
:	O
bottom	pointer
=	O
&	O
hurdio_bottom	struct
;	O
ourclass	pointer
=	O
tty_class	pointer
;	O
ourcntlclass	pointer
=	O
tty_cntl_class	pointer
;	O
ourcntl	pointer
=	O
&	O
termctl	pointer
;	O
peerclass	pointer
=	O
0	int
;	O
peercntlclass	pointer
=	O
0	int
;	O
peercntl	pointer
=	O
0	int
;	O
openmode	int
=	O
O_RDWR	int
;	O
break	O
;	O
case	O
T_PTYMASTER	int
:	O
bottom	pointer
=	O
&	O
ptyio_bottom	struct
;	O
ourclass	pointer
=	O
pty_class	pointer
;	O
ourcntlclass	pointer
=	O
pty_cntl_class	pointer
;	O
ourcntl	pointer
=	O
&	O
ptyctl	pointer
;	O
peerclass	pointer
=	O
tty_class	pointer
;	O
peercntlclass	pointer
=	O
tty_cntl_class	pointer
;	O
peercntl	pointer
=	O
&	O
termctl	pointer
;	O
openmode	int
=	O
0	int
;	O
break	O
;	O
case	O
T_PTYSLAVE	int
:	O
bottom	pointer
=	O
&	O
ptyio_bottom	struct
;	O
ourclass	pointer
=	O
tty_class	pointer
;	O
ourcntlclass	pointer
=	O
tty_cntl_class	pointer
;	O
ourcntl	pointer
=	O
&	O
termctl	pointer
;	O
peerclass	pointer
=	O
pty_class	pointer
;	O
peercntlclass	pointer
=	O
pty_cntl_class	pointer
;	O
peercntl	pointer
=	O
&	O
ptyctl	pointer
;	O
openmode	int
=	O
0	int
;	O
break	O
;	O
default	O
:	O
error	function
(	O
1	int
,	O
0	int
,	O
"Unknown terminal type"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
task_get_bootstrap_port	function
(	O
mach_task_self	function
(	O
)	O
,	O
&	O
bootstrap	O
)	O
;	O
if	O
(	O
bootstrap	O
==	O
MACH_PORT_NULL	O
)	O
error	function
(	O
1	int
,	O
0	int
,	O
"Must be started as a translator"	pointer
)	O
;	O
err	int
=	O
trivfs_startup	function
(	O
bootstrap	O
,	O
openmode	int
,	O
ourcntlclass	pointer
,	O
term_bucket	pointer
,	O
ourclass	pointer
,	O
term_bucket	pointer
,	O
ourcntl	pointer
)	O
;	O
if	O
(	O
err	int
)	O
error	function
(	O
1	int
,	O
err	int
,	O
"Starting translator"	pointer
)	O
;	O
(	O
*	O
ourcntl	pointer
)	O
->	O
hook	O
=	O
tty_name	pointer
;	O
if	O
(	O
peerclass	pointer
)	O
{	O
char	O
*	O
peer_name	pointer
=	O
tty_arg	pointer
;	O
file_t	O
file	O
=	O
file_name_lookup	O
(	O
peer_name	pointer
,	O
O_CREAT	int
|	O
O_NOTRANS	O
,	O
0666	int
)	O
;	O
if	O
(	O
file	O
==	O
MACH_PORT_NULL	O
)	O
err	int
=	O
errno	O
;	O
if	O
(	O
!	O
err	int
)	O
err	int
=	O
trivfs_create_control	function
(	O
file	O
,	O
peercntlclass	pointer
,	O
term_bucket	pointer
,	O
peerclass	pointer
,	O
term_bucket	pointer
,	O
peercntl	pointer
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
right	O
=	O
ports_get_send_right	function
(	O
*	O
peercntl	pointer
)	O
;	O
err	int
=	O
file_set_translator	function
(	O
file	O
,	O
0	int
,	O
FS_TRANS_EXCL	O
|	O
FS_TRANS_SET	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
right	O
,	O
MACH_MSG_TYPE_COPY_SEND	O
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
right	O
)	O
;	O
}	O
if	O
(	O
err	int
)	O
error	function
(	O
1	int
,	O
err	int
,	O
"%s"	pointer
,	O
peer_name	pointer
)	O
;	O
(	O
*	O
peercntl	pointer
)	O
->	O
hook	O
=	O
peer_name	pointer
;	O
ports_port_deref	function
(	O
*	O
peercntl	pointer
)	O
;	O
}	O
memset	O
(	O
&	O
termstate	struct
,	O
0	int
,	O
sizeof	O
(	O
termstate	struct
)	O
)	O
;	O
termflags	long
=	O
NO_CARRIER	int
|	O
NO_OWNER	int
;	O
pthread_mutex_init	function
(	O
&	O
global_lock	union
,	O
NULL	O
)	O
;	O
err	int
=	O
io_stat	function
(	O
(	O
*	O
ourcntl	pointer
)	O
->	O
underlying	O
,	O
&	O
st	struct
)	O
;	O
if	O
(	O
err	int
)	O
{	O
term_owner	int
=	O
term_group	int
=	O
0	int
;	O
term_mode	int
=	O
(	O
bottom	pointer
==	O
&	O
ptyio_bottom	struct
?	O
DEFFILEMODE	O
:	O
S_IRUSR	O
|	O
S_IWUSR	O
)	O
;	O
}	O
else	O
{	O
term_owner	int
=	O
st	struct
.	O
st_uid	O
;	O
term_group	int
=	O
st	struct
.	O
st_gid	O
;	O
term_mode	int
=	O
(	O
st	struct
.	O
st_mode	O
&	O
ACCESSPERMS	O
)	O
;	O
}	O
term_mode	int
|=	O
S_IFCHR	O
|	O
S_IROOT	O
;	O
inputq	pointer
=	O
create_queue	function
(	O
256	int
,	O
QUEUE_LOWAT	int
,	O
QUEUE_HIWAT	int
)	O
;	O
rawq	pointer
=	O
create_queue	function
(	O
256	int
,	O
QUEUE_LOWAT	int
,	O
QUEUE_HIWAT	int
)	O
;	O
outputq	pointer
=	O
create_queue	function
(	O
256	int
,	O
QUEUE_LOWAT	int
,	O
QUEUE_HIWAT	int
)	O
;	O
err	int
=	O
(	O
*	O
bottom	pointer
->	O
init	pointer
)	O
(	O
)	O
;	O
if	O
(	O
err	int
)	O
error	function
(	O
1	int
,	O
err	int
,	O
"Initializing bottom handler"	pointer
)	O
;	O
pthread_cond_init	function
(	O
&	O
carrier_alert	union
,	O
NULL	O
)	O
;	O
pthread_cond_init	function
(	O
&	O
select_alert	union
,	O
NULL	O
)	O
;	O
ports_manage_port_operations_multithread	function
(	O
term_bucket	pointer
,	O
demuxer	function
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
