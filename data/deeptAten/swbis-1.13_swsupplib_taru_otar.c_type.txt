static	O
int	O
dbpair_user_nset	int
=	O
0	int
;	O
static	O
int	O
dbpair_group_nset	int
=	O
0	int
;	O
static	O
char	O
*	O
g_pwent_msg	array
[	O
]	O
=	O
{	O
"user"	pointer
,	O
"group"	pointer
}	O
;	O
typedef	O
struct	O
{	O
long	O
int	O
idM	char
;	O
STROB	struct
*	O
snameM	pointer
;	O
int	O
in_sysM	int
;	O
}	O
SYSDBPAIR	struct
;	O
static	O
SYSDBPAIR	struct
userCacheM	array
[	O
CACHE_LEN	int
]	O
=	O
{	O
{	O
0	int
,	O
NULL	O
,	O
-	O
1	int
}	O
,	O
{	O
0	int
,	O
NULL	O
,	O
-	O
1	int
}	O
,	O
{	O
0	int
,	O
NULL	O
,	O
-	O
1	int
}	O
,	O
{	O
0	int
,	O
NULL	O
,	O
-	O
1	int
}	O
,	O
{	O
0	int
,	O
NULL	O
,	O
-	O
1	int
}	O
,	O
{	O
0	int
,	O
NULL	O
,	O
-	O
1	int
}	O
,	O
{	O
0	int
,	O
NULL	O
,	O
-	O
1	int
}	O
,	O
{	O
0	int
,	O
NULL	O
,	O
-	O
1	int
}	O
,	O
{	O
0	int
,	O
NULL	O
,	O
-	O
1	int
}	O
,	O
{	O
0	int
,	O
NULL	O
,	O
-	O
1	int
}	O
}	O
;	O
static	O
SYSDBPAIR	struct
groupCacheM	array
[	O
CACHE_LEN	int
]	O
=	O
{	O
{	O
0	int
,	O
NULL	O
,	O
-	O
1	int
}	O
,	O
{	O
0	int
,	O
NULL	O
,	O
-	O
1	int
}	O
,	O
{	O
0	int
,	O
NULL	O
,	O
-	O
1	int
}	O
,	O
{	O
0	int
,	O
NULL	O
,	O
-	O
1	int
}	O
,	O
{	O
0	int
,	O
NULL	O
,	O
-	O
1	int
}	O
,	O
{	O
0	int
,	O
NULL	O
,	O
-	O
1	int
}	O
,	O
{	O
0	int
,	O
NULL	O
,	O
-	O
1	int
}	O
,	O
{	O
0	int
,	O
NULL	O
,	O
-	O
1	int
}	O
,	O
{	O
0	int
,	O
NULL	O
,	O
-	O
1	int
}	O
,	O
{	O
0	int
,	O
NULL	O
,	O
-	O
1	int
}	O
}	O
;	O
static	O
size_t	long
split_long_name	function
(	O
const	O
char	O
*	O
name	pointer
,	O
size_t	long
length	short
)	O
{	O
size_t	long
i	int
;	O
if	O
(	O
length	short
>	O
PREFIX_FIELD_SIZE	int
)	O
length	short
=	O
PREFIX_FIELD_SIZE	int
+	O
1	int
;	O
for	O
(	O
i	int
=	O
length	short
-	O
1	int
;	O
i	int
>	O
0	int
;	O
i	int
--	O
)	O
if	O
(	O
ISSLASH	O
(	O
name	pointer
[	O
i	int
]	O
)	O
)	O
break	O
;	O
return	O
i	int
;	O
}	O
static	O
void	O
error_msg_control	function
(	O
char	O
*	O
name	pointer
,	O
int	O
id	pointer
,	O
char	O
*	O
dbname	pointer
)	O
{	O
static	O
STROB	struct
*	O
tmp	pointer
=	O
NULL	O
;	O
static	O
STROB	struct
*	O
store	pointer
=	O
NULL	O
;	O
if	O
(	O
tmp	pointer
==	O
NULL	O
)	O
tmp	pointer
=	O
strob_open	function
(	O
80	int
)	O
;	O
if	O
(	O
store	pointer
==	O
NULL	O
)	O
store	pointer
=	O
strob_open	function
(	O
80	int
)	O
;	O
if	O
(	O
name	pointer
)	O
{	O
strob_sprintf	function
(	O
tmp	pointer
,	O
0	int
,	O
"%s: %s name [%s] not found in system db\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
dbname	pointer
,	O
name	pointer
)	O
;	O
}	O
else	O
{	O
strob_sprintf	function
(	O
tmp	pointer
,	O
0	int
,	O
"%s: %s id [%d] not found in system db\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
dbname	pointer
,	O
(	O
int	O
)	O
(	O
id	pointer
)	O
)	O
;	O
}	O
if	O
(	O
strstr	function
(	O
strob_str	function
(	O
store	pointer
)	O
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
)	O
{	O
;	O
}	O
else	O
{	O
strob_strcat	function
(	O
store	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s"	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
}	O
}	O
static	O
int	O
null_block	function
(	O
long	O
*	O
block	pointer
,	O
int	O
size	long
)	O
{	O
register	O
long	O
*	O
p	pointer
=	O
block	pointer
;	O
register	O
int	O
i	int
=	O
size	long
/	O
sizeof	O
(	O
long	O
)	O
;	O
while	O
(	O
i	int
--	O
)	O
if	O
(	O
*	O
p	pointer
++	O
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
void	O
dbcache_set	function
(	O
int	O
*	O
dbpair_plen	pointer
,	O
SYSDBPAIR	struct
*	O
cache	pointer
,	O
char	O
*	O
name	pointer
,	O
int	O
id	pointer
,	O
int	O
in_sys	int
)	O
{	O
int	O
cell	int
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
*	O
dbpair_plen	pointer
>=	O
CACHE_LEN	int
)	O
{	O
*	O
dbpair_plen	pointer
=	O
1	int
;	O
cell	int
=	O
0	int
;	O
}	O
else	O
{	O
cell	int
=	O
*	O
dbpair_plen	pointer
;	O
(	O
*	O
dbpair_plen	pointer
)	O
++	O
;	O
}	O
cache	pointer
[	O
cell	int
]	O
.	O
idM	char
=	O
id	pointer
;	O
if	O
(	O
cache	pointer
[	O
cell	int
]	O
.	O
snameM	pointer
==	O
NULL	O
)	O
{	O
cache	pointer
[	O
cell	int
]	O
.	O
snameM	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
}	O
E_DEBUG3	O
(	O
"strcpy cell=[%d] id=[%d]"	pointer
,	O
cell	int
,	O
(	O
int	O
)	O
id	pointer
)	O
;	O
E_DEBUG3	O
(	O
"strcpy cell=[%d] name=[%s]"	pointer
,	O
cell	int
,	O
name	pointer
)	O
;	O
E_DEBUG3	O
(	O
"strcpy cell=[%d] in_sys=[%d]"	pointer
,	O
cell	int
,	O
in_sys	int
)	O
;	O
strob_strcpy	function
(	O
cache	pointer
[	O
cell	int
]	O
.	O
snameM	pointer
,	O
name	pointer
)	O
;	O
cache	pointer
[	O
cell	int
]	O
.	O
in_sysM	int
=	O
in_sys	int
;	O
}	O
static	O
SYSDBPAIR	struct
*	O
dbcache_lookup	function
(	O
int	O
*	O
dbpair_len	pointer
,	O
SYSDBPAIR	struct
*	O
cache	pointer
,	O
char	O
*	O
name	pointer
,	O
int	O
id	pointer
)	O
{	O
int	O
i	int
;	O
SYSDBPAIR	struct
*	O
pair	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
*	O
dbpair_len	pointer
;	O
i	int
++	O
)	O
{	O
pair	pointer
=	O
cache	pointer
+	O
i	int
;	O
if	O
(	O
name	pointer
)	O
{	O
if	O
(	O
pair	pointer
->	O
snameM	pointer
==	O
NULL	O
)	O
pair	pointer
->	O
snameM	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
if	O
(	O
strob_strcmp	function
(	O
pair	pointer
->	O
snameM	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
{	O
E_DEBUG2	O
(	O
"found by name: %s in cache"	pointer
,	O
name	pointer
)	O
;	O
return	O
pair	pointer
;	O
}	O
}	O
if	O
(	O
id	pointer
>=	O
0	int
&&	O
pair	pointer
->	O
idM	char
==	O
id	pointer
)	O
{	O
E_DEBUG2	O
(	O
"found by id: %d in cache"	pointer
,	O
(	O
int	O
)	O
id	pointer
)	O
;	O
return	O
pair	pointer
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
static	O
char	O
*	O
return_name_by_cache	function
(	O
int	O
*	O
dbpair_len	pointer
,	O
SYSDBPAIR	struct
*	O
cache	pointer
,	O
int	O
id	pointer
,	O
int	O
*	O
is_in_sysdb	pointer
)	O
{	O
SYSDBPAIR	struct
*	O
pair	pointer
;	O
pair	pointer
=	O
dbcache_lookup	function
(	O
dbpair_len	pointer
,	O
cache	pointer
,	O
NULL	O
,	O
id	pointer
)	O
;	O
if	O
(	O
!	O
pair	pointer
)	O
return	O
NULL	O
;	O
*	O
is_in_sysdb	pointer
=	O
pair	pointer
->	O
in_sysM	int
;	O
return	O
strob_str	function
(	O
pair	pointer
->	O
snameM	pointer
)	O
;	O
}	O
static	O
int	O
return_id_by_cache	function
(	O
int	O
*	O
dbpair_len	pointer
,	O
SYSDBPAIR	struct
*	O
cache	pointer
,	O
char	O
*	O
name	pointer
,	O
int	O
*	O
is_in_sysdb	pointer
)	O
{	O
SYSDBPAIR	struct
*	O
pair	pointer
;	O
pair	pointer
=	O
dbcache_lookup	function
(	O
dbpair_len	pointer
,	O
cache	pointer
,	O
name	pointer
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
pair	pointer
)	O
return	O
-	O
1	int
;	O
*	O
is_in_sysdb	pointer
=	O
pair	pointer
->	O
in_sysM	int
;	O
return	O
pair	pointer
->	O
idM	char
;	O
}	O
static	O
char	O
*	O
l_tar_sysdata_getuser	function
(	O
long	O
uid	int
,	O
char	O
*	O
tarbuf	pointer
,	O
STROB	struct
*	O
paxbuf	pointer
)	O
{	O
struct	O
passwd	struct
*	O
pwent	pointer
;	O
pwent	pointer
=	O
getpwuid	function
(	O
uid	int
)	O
;	O
if	O
(	O
!	O
pwent	pointer
)	O
{	O
if	O
(	O
tarbuf	pointer
)	O
memset	function
(	O
tarbuf	pointer
,	O
'\0'	O
,	O
SNAME_LEN	int
)	O
;	O
if	O
(	O
paxbuf	pointer
)	O
strob_strcpy	function
(	O
paxbuf	pointer
,	O
""	pointer
)	O
;	O
return	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
if	O
(	O
tarbuf	pointer
)	O
swlib_strncpy	function
(	O
tarbuf	pointer
,	O
pwent	pointer
->	O
pw_name	pointer
,	O
SNAME_LEN	int
)	O
;	O
if	O
(	O
paxbuf	pointer
)	O
strob_strcpy	function
(	O
paxbuf	pointer
,	O
pwent	pointer
->	O
pw_name	pointer
)	O
;	O
return	O
pwent	pointer
->	O
pw_name	pointer
;	O
}	O
static	O
int	O
l_cache_tar_getuidbyname	function
(	O
char	O
*	O
user	pointer
,	O
long	O
*	O
puid	pointer
)	O
{	O
int	O
ret	int
;	O
uid_t	int
id	pointer
;	O
ret	int
=	O
taru_get_uid_by_name	function
(	O
user	pointer
,	O
&	O
id	pointer
)	O
;	O
*	O
puid	pointer
=	O
(	O
long	O
)	O
id	pointer
;	O
return	O
ret	int
;	O
}	O
static	O
int	O
l_getuidbyname	function
(	O
char	O
*	O
user	pointer
,	O
long	O
*	O
puid	pointer
)	O
{	O
struct	O
passwd	struct
*	O
pwent	pointer
;	O
pwent	pointer
=	O
getpwnam	function
(	O
user	pointer
)	O
;	O
if	O
(	O
!	O
pwent	pointer
)	O
{	O
return	O
-	O
1	int
;	O
}	O
*	O
puid	pointer
=	O
pwent	pointer
->	O
pw_uid	int
;	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
l_tar_sysdata_getgroup	function
(	O
long	O
gid	int
,	O
char	O
*	O
tarbuf	pointer
,	O
STROB	struct
*	O
paxbuf	pointer
)	O
{	O
struct	O
group	struct
*	O
pwent	pointer
;	O
pwent	pointer
=	O
getgrgid	function
(	O
gid	int
)	O
;	O
if	O
(	O
!	O
pwent	pointer
)	O
{	O
if	O
(	O
tarbuf	pointer
)	O
memset	function
(	O
tarbuf	pointer
,	O
'\0'	O
,	O
SNAME_LEN	int
)	O
;	O
if	O
(	O
paxbuf	pointer
)	O
strob_strcpy	function
(	O
paxbuf	pointer
,	O
""	pointer
)	O
;	O
return	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
if	O
(	O
tarbuf	pointer
)	O
swlib_strncpy	function
(	O
tarbuf	pointer
,	O
pwent	pointer
->	O
gr_name	pointer
,	O
SNAME_LEN	int
)	O
;	O
if	O
(	O
paxbuf	pointer
)	O
strob_strcpy	function
(	O
paxbuf	pointer
,	O
pwent	pointer
->	O
gr_name	pointer
)	O
;	O
return	O
pwent	pointer
->	O
gr_name	pointer
;	O
}	O
static	O
int	O
l_cache_tar_getgidbyname	function
(	O
char	O
*	O
user	pointer
,	O
long	O
*	O
pgid	pointer
)	O
{	O
int	O
ret	int
;	O
gid_t	int
id	pointer
;	O
ret	int
=	O
taru_get_gid_by_name	function
(	O
user	pointer
,	O
&	O
id	pointer
)	O
;	O
*	O
pgid	pointer
=	O
(	O
long	O
)	O
id	pointer
;	O
return	O
ret	int
;	O
}	O
static	O
int	O
l_getgidbyname	function
(	O
char	O
*	O
group	struct
,	O
long	O
*	O
pgid	pointer
)	O
{	O
struct	O
group	struct
*	O
pwent	pointer
;	O
pwent	pointer
=	O
getgrnam	function
(	O
group	struct
)	O
;	O
if	O
(	O
!	O
pwent	pointer
)	O
{	O
return	O
-	O
1	int
;	O
}	O
*	O
pgid	pointer
=	O
pwent	pointer
->	O
gr_gid	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
get_pwent	function
(	O
int	O
idx	int
,	O
long	O
id	pointer
,	O
char	O
*	O
userkey	pointer
,	O
char	O
*	O
tarbuf	pointer
,	O
STROB	struct
*	O
paxbuf	pointer
,	O
long	O
*	O
ppid	pointer
,	O
int	O
(	O
*	O
v_get_id	pointer
)	O
(	O
char	O
*	O
,	O
long	O
*	O
)	O
,	O
char	O
*	O
(	O
*	O
v_get_name	pointer
)	O
(	O
long	O
,	O
char	O
*	O
,	O
STROB	struct
*	O
)	O
,	O
int	O
*	O
dbpair_len	pointer
,	O
SYSDBPAIR	struct
*	O
cache	pointer
)	O
{	O
char	O
*	O
cname	pointer
;	O
int	O
is_in_sysdb	pointer
=	O
0	int
;	O
int	O
n	long
;	O
int	O
retval	int
=	O
0	int
;	O
if	O
(	O
userkey	pointer
)	O
{	O
if	O
(	O
strlen	function
(	O
userkey	pointer
)	O
==	O
0	int
)	O
return	O
-	O
1	int
;	O
n	long
=	O
return_id_by_cache	function
(	O
dbpair_len	pointer
,	O
cache	pointer
,	O
userkey	pointer
,	O
&	O
is_in_sysdb	pointer
)	O
;	O
if	O
(	O
n	long
>=	O
0	int
)	O
{	O
*	O
ppid	pointer
=	O
n	long
;	O
return	O
is_in_sysdb	pointer
;	O
}	O
n	long
=	O
(	O
*	O
(	O
v_get_id	pointer
)	O
)	O
(	O
userkey	pointer
,	O
ppid	pointer
)	O
;	O
if	O
(	O
n	long
==	O
0	int
)	O
{	O
dbcache_set	function
(	O
dbpair_len	pointer
,	O
cache	pointer
,	O
userkey	pointer
,	O
*	O
ppid	pointer
,	O
0	int
)	O
;	O
}	O
else	O
{	O
*	O
ppid	pointer
=	O
AHS_UID_NOBODY	O
;	O
error_msg_control	function
(	O
userkey	pointer
,	O
-	O
1	int
,	O
g_pwent_msg	array
[	O
idx	int
]	O
)	O
;	O
dbcache_set	function
(	O
dbpair_len	pointer
,	O
cache	pointer
,	O
userkey	pointer
,	O
*	O
ppid	pointer
,	O
-	O
1	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
n	long
;	O
}	O
else	O
{	O
cname	pointer
=	O
return_name_by_cache	function
(	O
dbpair_len	pointer
,	O
cache	pointer
,	O
id	pointer
,	O
&	O
is_in_sysdb	pointer
)	O
;	O
if	O
(	O
cname	pointer
)	O
{	O
if	O
(	O
strlen	function
(	O
cname	pointer
)	O
>	O
TARU_SYSDBNAME_LEN	int
-	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: user name too long for ustar headers: %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
cname	pointer
)	O
;	O
}	O
retval	int
=	O
is_in_sysdb	pointer
;	O
}	O
else	O
{	O
cname	pointer
=	O
(	O
*	O
(	O
v_get_name	pointer
)	O
)	O
(	O
id	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
cname	pointer
)	O
{	O
dbcache_set	function
(	O
dbpair_len	pointer
,	O
cache	pointer
,	O
cname	pointer
,	O
id	pointer
,	O
0	int
)	O
;	O
retval	int
=	O
0	int
;	O
}	O
else	O
{	O
cname	pointer
=	O
AHS_USERNAME_NOBODY	pointer
;	O
dbcache_set	function
(	O
dbpair_len	pointer
,	O
cache	pointer
,	O
AHS_USERNAME_NOBODY	pointer
,	O
id	pointer
,	O
-	O
1	int
)	O
;	O
error_msg_control	function
(	O
(	O
char	O
*	O
)	O
NULL	O
,	O
id	pointer
,	O
g_pwent_msg	array
[	O
idx	int
]	O
)	O
;	O
retval	int
=	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
cname	pointer
&&	O
tarbuf	pointer
)	O
{	O
strncpy	function
(	O
tarbuf	pointer
,	O
cname	pointer
,	O
TARU_SYSDBNAME_LEN	int
-	O
1	int
)	O
;	O
tarbuf	pointer
[	O
TARU_SYSDBNAME_LEN	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
cname	pointer
&&	O
paxbuf	pointer
)	O
{	O
strob_strcpy	function
(	O
paxbuf	pointer
,	O
cname	pointer
)	O
;	O
}	O
return	O
retval	int
;	O
}	O
}	O
void	O
taru_set_filehdr_sysdb_nameid_by_policy	function
(	O
char	O
*	O
vselect	pointer
,	O
struct	O
new_cpio_header	struct
*	O
file_hdr	pointer
,	O
int	O
termch	int
,	O
int	O
tar_iflags_numeric_uids	int
)	O
{	O
unsigned	O
long	O
psid	long
;	O
unsigned	O
long	O
c_id	long
;	O
unsigned	O
char	O
c_c	char
;	O
gid_t	int
pgid	pointer
;	O
uid_t	int
puid	pointer
;	O
int	O
G	int
;	O
char	O
*	O
sysusername	pointer
;	O
if	O
(	O
strncasecmp	function
(	O
"G"	pointer
,	O
vselect	pointer
,	O
1	int
)	O
==	O
0	int
)	O
{	O
G	int
=	O
1	int
;	O
c_id	long
=	O
file_hdr	pointer
->	O
c_gid	short
;	O
c_c	char
=	O
file_hdr	pointer
->	O
c_cg	char
;	O
sysusername	pointer
=	O
ahsStaticGetTarGroupname	function
(	O
file_hdr	pointer
)	O
;	O
}	O
else	O
{	O
G	int
=	O
0	int
;	O
c_id	long
=	O
file_hdr	pointer
->	O
c_uid	short
;	O
c_c	char
=	O
file_hdr	pointer
->	O
c_cu	char
;	O
sysusername	pointer
=	O
ahsStaticGetTarUsername	function
(	O
file_hdr	pointer
)	O
;	O
}	O
if	O
(	O
(	O
sysusername	pointer
==	O
NULL	O
||	O
strlen	function
(	O
sysusername	pointer
)	O
==	O
0	int
)	O
&&	O
c_c	char
!=	O
TARU_C_BY_UNONE	int
)	O
{	O
E_DEBUG	O
(	O
"sysusername nil"	pointer
)	O
;	O
if	O
(	O
G	int
)	O
{	O
l_tar_sysdata_getgroup	function
(	O
c_id	long
,	O
NULL	O
,	O
(	O
STROB	struct
*	O
)	O
(	O
file_hdr	pointer
->	O
c_groupname	pointer
)	O
)	O
;	O
}	O
else	O
{	O
l_tar_sysdata_getuser	function
(	O
c_id	long
,	O
NULL	O
,	O
(	O
STROB	struct
*	O
)	O
(	O
file_hdr	pointer
->	O
c_username	pointer
)	O
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
c_c	char
==	O
TARU_C_BY_USYS	int
||	O
c_c	char
==	O
TARU_C_BY_UNAME	int
)	O
{	O
E_DEBUG2	O
(	O
"finding id for sysusername = %s"	pointer
,	O
sysusername	pointer
)	O
;	O
if	O
(	O
G	int
)	O
{	O
if	O
(	O
taru_get_gid_by_name	function
(	O
sysusername	pointer
,	O
&	O
pgid	pointer
)	O
)	O
{	O
pgid	pointer
=	O
NOBODY_ID	O
;	O
E_DEBUG3	O
(	O
"user name [%s] not found setting uid to %d"	pointer
,	O
sysusername	pointer
,	O
(	O
int	O
)	O
pgid	pointer
)	O
;	O
}	O
psid	long
=	O
(	O
unsigned	O
long	O
)	O
pgid	pointer
;	O
}	O
else	O
{	O
if	O
(	O
taru_get_uid_by_name	function
(	O
sysusername	pointer
,	O
&	O
puid	pointer
)	O
)	O
{	O
puid	pointer
=	O
NOBODY_ID	O
;	O
E_DEBUG3	O
(	O
"user name [%s] not found setting uid to %d"	pointer
,	O
sysusername	pointer
,	O
(	O
int	O
)	O
puid	pointer
)	O
;	O
}	O
psid	long
=	O
(	O
unsigned	O
long	O
)	O
puid	pointer
;	O
}	O
}	O
else	O
if	O
(	O
c_c	char
==	O
TARU_C_BY_UID	int
)	O
{	O
psid	long
=	O
c_id	long
;	O
E_DEBUG2	O
(	O
"finding user for uid  %d"	pointer
,	O
(	O
int	O
)	O
psid	long
)	O
;	O
if	O
(	O
tar_iflags_numeric_uids	int
==	O
0	int
)	O
{	O
if	O
(	O
G	int
)	O
{	O
l_tar_sysdata_getgroup	function
(	O
c_id	long
,	O
NULL	O
,	O
(	O
STROB	struct
*	O
)	O
(	O
file_hdr	pointer
->	O
c_groupname	pointer
)	O
)	O
;	O
}	O
else	O
{	O
l_tar_sysdata_getuser	function
(	O
c_id	long
,	O
NULL	O
,	O
(	O
STROB	struct
*	O
)	O
(	O
file_hdr	pointer
->	O
c_username	pointer
)	O
)	O
;	O
}	O
}	O
else	O
{	O
}	O
}	O
else	O
{	O
E_DEBUG	O
(	O
"Using user and uid with no lookups"	pointer
)	O
;	O
psid	long
=	O
c_id	long
;	O
}	O
if	O
(	O
G	int
)	O
{	O
}	O
else	O
{	O
}	O
}	O
}	O
void	O
taru_set_sysdb_nameid_by_policy	function
(	O
struct	O
tar_header	struct
*	O
tar_hdr	pointer
,	O
char	O
*	O
vselect	pointer
,	O
char	O
*	O
sysusername	pointer
,	O
char	O
*	O
tarbuf	pointer
,	O
STROB	struct
*	O
paxbuf	pointer
,	O
struct	O
new_cpio_header	struct
*	O
file_hdr	pointer
,	O
int	O
termch	int
,	O
int	O
tar_iflags_numeric_uids	int
)	O
{	O
char	O
*	O
tar_hdr_dest	pointer
;	O
char	O
*	O
tar_hdr_id	pointer
;	O
unsigned	O
long	O
psid	long
;	O
unsigned	O
long	O
c_id	long
;	O
unsigned	O
char	O
c_c	char
;	O
gid_t	int
pgid	pointer
;	O
uid_t	int
puid	pointer
;	O
int	O
G	int
;	O
tar_hdr_id	pointer
=	O
NULL	O
;	O
tar_hdr_dest	pointer
=	O
NULL	O
;	O
if	O
(	O
strncasecmp	function
(	O
"G"	pointer
,	O
vselect	pointer
,	O
1	int
)	O
==	O
0	int
)	O
{	O
G	int
=	O
1	int
;	O
if	O
(	O
tar_hdr	pointer
)	O
tar_hdr_dest	pointer
=	O
tar_hdr	pointer
->	O
gname	array
;	O
if	O
(	O
tar_hdr	pointer
)	O
tar_hdr_id	pointer
=	O
tar_hdr	pointer
->	O
gid	int
;	O
c_id	long
=	O
file_hdr	pointer
->	O
c_gid	short
;	O
c_c	char
=	O
file_hdr	pointer
->	O
c_cg	char
;	O
}	O
else	O
{	O
G	int
=	O
0	int
;	O
if	O
(	O
tar_hdr	pointer
)	O
tar_hdr_dest	pointer
=	O
tar_hdr	pointer
->	O
uname	array
;	O
if	O
(	O
tar_hdr	pointer
)	O
tar_hdr_id	pointer
=	O
tar_hdr	pointer
->	O
uid	int
;	O
c_id	long
=	O
file_hdr	pointer
->	O
c_uid	short
;	O
c_c	char
=	O
file_hdr	pointer
->	O
c_cu	char
;	O
}	O
if	O
(	O
(	O
sysusername	pointer
==	O
NULL	O
||	O
strlen	function
(	O
sysusername	pointer
)	O
==	O
0	int
)	O
&&	O
c_c	char
!=	O
TARU_C_BY_UNONE	int
)	O
{	O
E_DEBUG	O
(	O
"sysusername nil"	pointer
)	O
;	O
if	O
(	O
G	int
)	O
{	O
l_tar_sysdata_getgroup	function
(	O
c_id	long
,	O
tarbuf	pointer
,	O
paxbuf	pointer
)	O
;	O
}	O
else	O
{	O
l_tar_sysdata_getuser	function
(	O
c_id	long
,	O
tarbuf	pointer
,	O
paxbuf	pointer
)	O
;	O
}	O
if	O
(	O
tar_hdr	pointer
)	O
swlib_strncpy	function
(	O
tar_hdr_dest	pointer
,	O
tarbuf	pointer
,	O
SNAME_LEN	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
c_c	char
==	O
TARU_C_BY_USYS	int
||	O
c_c	char
==	O
TARU_C_BY_UNAME	int
)	O
{	O
E_DEBUG2	O
(	O
"finding id for sysusername = %s"	pointer
,	O
sysusername	pointer
)	O
;	O
if	O
(	O
G	int
)	O
{	O
if	O
(	O
taru_get_gid_by_name	function
(	O
sysusername	pointer
,	O
&	O
pgid	pointer
)	O
)	O
{	O
pgid	pointer
=	O
NOBODY_ID	O
;	O
E_DEBUG3	O
(	O
"user name [%s] not found setting uid to %d"	pointer
,	O
sysusername	pointer
,	O
(	O
int	O
)	O
pgid	pointer
)	O
;	O
}	O
psid	long
=	O
(	O
unsigned	O
long	O
)	O
pgid	pointer
;	O
}	O
else	O
{	O
if	O
(	O
taru_get_uid_by_name	function
(	O
sysusername	pointer
,	O
&	O
puid	pointer
)	O
)	O
{	O
puid	pointer
=	O
NOBODY_ID	O
;	O
E_DEBUG3	O
(	O
"user name [%s] not found setting uid to %d"	pointer
,	O
sysusername	pointer
,	O
(	O
int	O
)	O
puid	pointer
)	O
;	O
}	O
psid	long
=	O
(	O
unsigned	O
long	O
)	O
puid	pointer
;	O
}	O
if	O
(	O
tar_hdr	pointer
)	O
swlib_strncpy	function
(	O
tar_hdr_dest	pointer
,	O
sysusername	pointer
,	O
SNAME_LEN	int
)	O
;	O
}	O
else	O
if	O
(	O
c_c	char
==	O
TARU_C_BY_UID	int
)	O
{	O
psid	long
=	O
c_id	long
;	O
E_DEBUG2	O
(	O
"finding user for uid  %d"	pointer
,	O
(	O
int	O
)	O
psid	long
)	O
;	O
if	O
(	O
tar_iflags_numeric_uids	int
==	O
0	int
)	O
{	O
if	O
(	O
G	int
)	O
{	O
taru_get_tar_group_by_gid	function
(	O
psid	long
,	O
tarbuf	pointer
)	O
;	O
if	O
(	O
paxbuf	pointer
)	O
taru_get_pax_group_by_gid	function
(	O
psid	long
,	O
paxbuf	pointer
)	O
;	O
}	O
else	O
{	O
taru_get_tar_user_by_uid	function
(	O
psid	long
,	O
tarbuf	pointer
)	O
;	O
if	O
(	O
paxbuf	pointer
)	O
taru_get_pax_user_by_uid	function
(	O
psid	long
,	O
paxbuf	pointer
)	O
;	O
}	O
if	O
(	O
tar_hdr	pointer
)	O
swlib_strncpy	function
(	O
tar_hdr_dest	pointer
,	O
tarbuf	pointer
,	O
SNAME_LEN	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
tar_hdr	pointer
)	O
memset	function
(	O
tar_hdr_dest	pointer
,	O
'\0'	O
,	O
SNAME_LEN	int
)	O
;	O
}	O
}	O
else	O
{	O
E_DEBUG	O
(	O
"Using user and uid with no lookups"	pointer
)	O
;	O
psid	long
=	O
c_id	long
;	O
if	O
(	O
tar_hdr	pointer
)	O
swlib_strncpy	function
(	O
tar_hdr_dest	pointer
,	O
sysusername	pointer
,	O
SNAME_LEN	int
)	O
;	O
}	O
if	O
(	O
G	int
)	O
{	O
if	O
(	O
tar_hdr	pointer
)	O
GID_TO_CHARS	O
(	O
psid	long
,	O
tar_hdr_id	pointer
,	O
termch	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
tar_hdr	pointer
)	O
UID_TO_CHARS	O
(	O
psid	long
,	O
tar_hdr_id	pointer
,	O
termch	int
)	O
;	O
}	O
}	O
}	O
void	O
taru_mode_to_chars	function
(	O
mode_t	int
v	int
,	O
char	O
*	O
p	pointer
,	O
size_t	long
s	pointer
,	O
int	O
termch	int
)	O
{	O
mode_to_chars	function
(	O
v	int
,	O
p	pointer
,	O
s	pointer
,	O
POSIX_FORMAT	int
,	O
termch	int
)	O
;	O
}	O
int	O
taru_get_uid_by_name	function
(	O
char	O
*	O
username	pointer
,	O
uid_t	int
*	O
puid	pointer
)	O
{	O
long	O
pid	int
;	O
int	O
ret	int
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	int
=	O
get_pwent	function
(	O
0	int
,	O
0	int
,	O
username	pointer
,	O
NULL	O
,	O
NULL	O
,	O
&	O
pid	int
,	O
l_getuidbyname	function
,	O
l_tar_sysdata_getuser	function
,	O
&	O
dbpair_user_nset	int
,	O
userCacheM	array
)	O
;	O
*	O
puid	pointer
=	O
(	O
uid_t	int
)	O
(	O
pid	int
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
taru_get_pax_user_by_uid	function
(	O
uid_t	int
uid	int
,	O
STROB	struct
*	O
buf	pointer
)	O
{	O
int	O
ret	int
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	int
=	O
get_pwent	function
(	O
0	int
,	O
uid	int
,	O
NULL	O
,	O
NULL	O
,	O
buf	pointer
,	O
NULL	O
,	O
l_getuidbyname	function
,	O
l_tar_sysdata_getuser	function
,	O
&	O
dbpair_user_nset	int
,	O
userCacheM	array
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
taru_get_tar_user_by_uid	function
(	O
uid_t	int
uid	int
,	O
char	O
*	O
buf	pointer
)	O
{	O
int	O
ret	int
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	int
=	O
get_pwent	function
(	O
0	int
,	O
uid	int
,	O
NULL	O
,	O
buf	pointer
,	O
NULL	O
,	O
NULL	O
,	O
l_getuidbyname	function
,	O
l_tar_sysdata_getuser	function
,	O
&	O
dbpair_user_nset	int
,	O
userCacheM	array
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
taru_get_gid_by_name	function
(	O
char	O
*	O
groupname	pointer
,	O
gid_t	int
*	O
guid	pointer
)	O
{	O
int	O
ret	int
;	O
long	O
pid	int
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	int
=	O
get_pwent	function
(	O
1	int
,	O
0	int
,	O
groupname	pointer
,	O
NULL	O
,	O
NULL	O
,	O
&	O
pid	int
,	O
l_getgidbyname	function
,	O
l_tar_sysdata_getgroup	function
,	O
&	O
dbpair_group_nset	int
,	O
groupCacheM	array
)	O
;	O
*	O
guid	pointer
=	O
(	O
gid_t	int
)	O
(	O
pid	int
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
taru_get_pax_group_by_gid	function
(	O
gid_t	int
gid	int
,	O
STROB	struct
*	O
buf	pointer
)	O
{	O
int	O
ret	int
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	int
=	O
get_pwent	function
(	O
1	int
,	O
gid	int
,	O
NULL	O
,	O
NULL	O
,	O
buf	pointer
,	O
NULL	O
,	O
l_getgidbyname	function
,	O
l_tar_sysdata_getgroup	function
,	O
&	O
dbpair_group_nset	int
,	O
groupCacheM	array
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
taru_get_tar_group_by_gid	function
(	O
gid_t	int
gid	int
,	O
char	O
*	O
tarbuf	pointer
)	O
{	O
int	O
ret	int
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	int
=	O
get_pwent	function
(	O
1	int
,	O
gid	int
,	O
NULL	O
,	O
tarbuf	pointer
,	O
NULL	O
,	O
NULL	O
,	O
l_getgidbyname	function
,	O
l_tar_sysdata_getgroup	function
,	O
&	O
dbpair_group_nset	int
,	O
groupCacheM	array
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
taru_split_name_ustar	function
(	O
struct	O
tar_header	struct
*	O
tar_hdr	pointer
,	O
char	O
*	O
name	pointer
,	O
int	O
tar_iflags	int
)	O
{	O
size_t	long
length	short
=	O
strlen	function
(	O
name	pointer
)	O
;	O
size_t	long
i	int
;	O
char	O
*	O
uh	pointer
=	O
(	O
char	O
*	O
)	O
tar_hdr	pointer
;	O
memset	function
(	O
uh	pointer
+	O
THB_BO_name	int
,	O
'\0'	O
,	O
NAME_FIELD_SIZE	int
)	O
;	O
memset	function
(	O
uh	pointer
+	O
THB_BO_prefix	int
,	O
'\0'	O
,	O
PREFIX_FIELD_SIZE	int
)	O
;	O
if	O
(	O
length	short
>	O
PREFIX_FIELD_SIZE	int
+	O
NAME_FIELD_SIZE	int
+	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: name too long (max): %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
name	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
i	int
=	O
split_long_name	function
(	O
name	pointer
,	O
length	short
)	O
;	O
if	O
(	O
length	short
-	O
i	int
-	O
1	int
>	O
NAME_FIELD_SIZE	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: name too long (cannot be split): (i=%d) [%s]\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
(	O
int	O
)	O
i	int
,	O
name	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
i	int
==	O
0	int
)	O
{	O
return	O
0	int
;	O
}	O
memcpy	function
(	O
(	O
void	O
*	O
)	O
(	O
uh	pointer
+	O
THB_BO_name	int
)	O
,	O
name	pointer
+	O
i	int
+	O
1	int
,	O
length	short
-	O
i	int
-	O
1	int
)	O
;	O
memcpy	function
(	O
(	O
void	O
*	O
)	O
(	O
uh	pointer
+	O
THB_BO_prefix	int
)	O
,	O
name	pointer
,	O
i	int
)	O
;	O
return	O
0	int
;	O
}	O
int	O
taru_set_filetype_from_tartype	function
(	O
char	O
ch	int
,	O
mode_t	int
*	O
mode	int
,	O
char	O
*	O
filename	pointer
)	O
{	O
(	O
*	O
mode	int
)	O
&=	O
(	O
~	O
(	O
S_IFMT	O
)	O
)	O
;	O
switch	O
(	O
ch	int
)	O
{	O
case	O
REGTYPE	char
:	O
case	O
CONTTYPE	char
:	O
(	O
*	O
mode	int
)	O
|=	O
CP_IFREG	int
;	O
break	O
;	O
case	O
DIRTYPE	char
:	O
(	O
*	O
mode	int
)	O
|=	O
CP_IFDIR	int
;	O
break	O
;	O
case	O
CHRTYPE	char
:	O
(	O
*	O
mode	int
)	O
|=	O
CP_IFCHR	int
;	O
break	O
;	O
case	O
BLKTYPE	char
:	O
(	O
*	O
mode	int
)	O
|=	O
CP_IFBLK	int
;	O
break	O
;	O
case	O
FIFOTYPE	char
:	O
(	O
*	O
mode	int
)	O
|=	O
CP_IFIFO	int
;	O
break	O
;	O
case	O
SYMTYPE	char
:	O
(	O
*	O
mode	int
)	O
|=	O
CP_IFLNK	int
;	O
break	O
;	O
case	O
LNKTYPE	char
:	O
(	O
*	O
mode	int
)	O
|=	O
CP_IFREG	int
;	O
break	O
;	O
case	O
AREGTYPE	char
:	O
if	O
(	O
filename	pointer
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"taru_set_filetype_from_tartype():"	pointer
" warning: AREGTYPE: filename not given, assuming REGTYPE.\n"	pointer
)	O
;	O
(	O
*	O
mode	int
)	O
|=	O
CP_IFREG	int
;	O
}	O
else	O
{	O
if	O
(	O
filename	pointer
[	O
strlen	function
(	O
filename	pointer
)	O
-	O
1	int
]	O
==	O
'/'	O
)	O
(	O
*	O
mode	int
)	O
|=	O
CP_IFDIR	int
;	O
else	O
(	O
*	O
mode	int
)	O
|=	O
CP_IFREG	int
;	O
}	O
break	O
;	O
case	O
NOTDUMPEDTYPE	char
:	O
(	O
*	O
mode	int
)	O
|=	O
CP_IFSOCK	int
;	O
break	O
;	O
default	O
:	O
(	O
*	O
mode	int
)	O
|=	O
CP_IFREG	int
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: warning:  typeflag [%c] not supported, ignoring file\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
ch	int
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
tarui_get_filetypes	function
(	O
mode_t	int
mode	int
,	O
int	O
*	O
cpio_mode	pointer
,	O
char	O
*	O
tarflag	pointer
)	O
{	O
if	O
(	O
S_ISREG	O
(	O
mode	int
)	O
)	O
{	O
*	O
tarflag	pointer
=	O
REGTYPE	char
;	O
*	O
cpio_mode	pointer
=	O
CP_IFREG	int
;	O
}	O
else	O
if	O
(	O
S_ISDOOR	int
(	O
mode	int
)	O
)	O
{	O
*	O
tarflag	pointer
=	O
NOTDUMPEDTYPE	char
;	O
*	O
cpio_mode	pointer
=	O
CP_IFSOCK	int
;	O
}	O
else	O
if	O
(	O
S_ISDIR	O
(	O
mode	int
)	O
)	O
{	O
*	O
tarflag	pointer
=	O
DIRTYPE	char
;	O
*	O
cpio_mode	pointer
=	O
CP_IFDIR	int
;	O
}	O
else	O
if	O
(	O
S_ISBLK	O
(	O
mode	int
)	O
)	O
{	O
*	O
tarflag	pointer
=	O
BLKTYPE	char
;	O
*	O
cpio_mode	pointer
=	O
CP_IFBLK	int
;	O
}	O
else	O
if	O
(	O
S_ISCHR	O
(	O
mode	int
)	O
)	O
{	O
*	O
tarflag	pointer
=	O
CHRTYPE	char
;	O
*	O
cpio_mode	pointer
=	O
CP_IFCHR	int
;	O
}	O
else	O
if	O
(	O
S_ISFIFO	O
(	O
mode	int
)	O
)	O
{	O
*	O
tarflag	pointer
=	O
FIFOTYPE	char
;	O
*	O
cpio_mode	pointer
=	O
CP_IFIFO	int
;	O
}	O
else	O
if	O
(	O
S_ISLNK	O
(	O
mode	int
)	O
)	O
{	O
*	O
tarflag	pointer
=	O
SYMTYPE	char
;	O
*	O
cpio_mode	pointer
=	O
CP_IFLNK	int
;	O
}	O
else	O
if	O
(	O
S_ISSOCK	O
(	O
mode	int
)	O
)	O
{	O
*	O
tarflag	pointer
=	O
NOTDUMPEDTYPE	char
;	O
*	O
cpio_mode	pointer
=	O
CP_IFSOCK	int
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: unrecognized type in mode: %d\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
(	O
int	O
)	O
mode	int
)	O
;	O
*	O
tarflag	pointer
=	O
(	O
char	O
)	O
(	O
-	O
1	int
)	O
;	O
*	O
cpio_mode	pointer
=	O
-	O
1	int
;	O
}	O
}	O
int	O
taru_get_tar_filetype	function
(	O
mode_t	int
mode	int
)	O
{	O
char	O
c	int
;	O
int	O
cm	int
;	O
tarui_get_filetypes	function
(	O
mode	int
,	O
&	O
cm	int
,	O
&	O
c	int
)	O
;	O
return	O
(	O
int	O
)	O
c	int
;	O
}	O
int	O
taru_get_cpio_filetype	function
(	O
mode_t	int
mode	int
)	O
{	O
char	O
c	int
;	O
int	O
cm	int
;	O
tarui_get_filetypes	function
(	O
mode	int
,	O
&	O
cm	int
,	O
&	O
c	int
)	O
;	O
return	O
cm	int
;	O
}	O
static	O
int	O
i_taru_read_in_tar_header2	function
(	O
TARU	struct
*	O
taru	pointer
,	O
struct	O
new_cpio_header	struct
*	O
file_hdr	pointer
,	O
int	O
in_des	int
,	O
char	O
*	O
fsource_buffer	pointer
,	O
int	O
*	O
eoa	pointer
,	O
int	O
tarheaderflags	int
,	O
int	O
fsource_buffer_len	int
,	O
int	O
fp_retval	int
)	O
{	O
mode_t	int
modet	int
;	O
int	O
retval	int
=	O
0	int
;	O
unsigned	O
char	O
*	O
ext_data_buffer	pointer
;	O
int	O
ext_data_buffer_len	int
;	O
long	O
bytes_skipped	long
=	O
0	int
;	O
int	O
warned	int
=	O
FALSE	int
;	O
union	O
tar_record	union
tar_rec	union
;	O
struct	O
tar_header	struct
*	O
tar_hdr	pointer
;	O
char	O
*	O
aregfilename	pointer
;	O
char	O
*	O
tmpname	pointer
;	O
char	O
*	O
read_buffer	pointer
;	O
int	O
do_record_header	int
=	O
0	int
;	O
int	O
tar_iflags_retain_header_id	int
=	O
0	int
;	O
int	O
buffer_offset	int
;	O
int	O
xhd_errorcode	int
;	O
int	O
eoaret	int
;	O
int	O
tmpret	int
;	O
int	O
tmpret_ustar	int
;	O
int	O
tmpret_extdata	int
;	O
int	O
read_so_far	int
=	O
0	int
;	O
long	O
uidp	long
;	O
long	O
gidp	long
;	O
E_DEBUG	O
(	O
"BEGIN"	pointer
)	O
;	O
buffer_offset	int
=	O
0	int
;	O
if	O
(	O
taru	pointer
)	O
{	O
tar_iflags_retain_header_id	int
=	O
(	O
tarheaderflags	int
&	O
TARU_TAR_RETAIN_HEADER_IDS	O
)	O
;	O
}	O
if	O
(	O
eoa	pointer
)	O
{	O
*	O
eoa	pointer
=	O
0	int
;	O
}	O
ext_data_buffer	pointer
=	O
NULL	O
;	O
if	O
(	O
taru	pointer
)	O
{	O
do_record_header	int
=	O
taru	pointer
->	O
do_record_headerM	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
strob_set_length	function
(	O
taru	pointer
->	O
read_bufferM	pointer
,	O
taru	pointer
->	O
read_buffer_posM	int
+	O
TARRECORDSIZE	int
)	O
;	O
read_buffer	pointer
=	O
strob_str	function
(	O
taru	pointer
->	O
read_bufferM	pointer
)	O
;	O
if	O
(	O
fsource_buffer	pointer
==	O
NULL	O
)	O
{	O
tmpret_ustar	int
=	O
taru_tape_buffered_read	function
(	O
in_des	int
,	O
(	O
void	O
*	O
)	O
(	O
read_buffer	pointer
)	O
,	O
TARRECORDSIZE	int
)	O
;	O
if	O
(	O
tmpret_ustar	int
>	O
0	int
&&	O
tmpret_ustar	int
!=	O
TARRECORDSIZE	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: otar.c: short read in read_in_tar_header2 return=%d\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
tmpret_ustar	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
tmpret_ustar	int
==	O
0	int
)	O
{	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
tmpret_ustar	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: otar.c: read error from read_in_tar_header2 return=%d\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
tmpret_ustar	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
;	O
}	O
}	O
else	O
{	O
memcpy	function
(	O
(	O
void	O
*	O
)	O
(	O
read_buffer	pointer
)	O
,	O
fsource_buffer	pointer
+	O
taru	pointer
->	O
read_buffer_posM	int
,	O
TARRECORDSIZE	int
)	O
;	O
fsource_buffer_len	int
-=	O
TARRECORDSIZE	int
;	O
tmpret_ustar	int
=	O
TARRECORDSIZE	int
;	O
}	O
taru	pointer
->	O
read_buffer_posM	int
+=	O
TARRECORDSIZE	int
;	O
strob_set_length	function
(	O
taru	pointer
->	O
read_bufferM	pointer
,	O
taru	pointer
->	O
read_buffer_posM	int
+	O
TARRECORDSIZE	int
)	O
;	O
read_buffer	pointer
=	O
strob_str	function
(	O
taru	pointer
->	O
read_bufferM	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
do_record_header	int
)	O
{	O
strob_set_memlength	function
(	O
taru	pointer
->	O
headerM	pointer
,	O
taru	pointer
->	O
header_lengthM	int
+	O
512	int
)	O
;	O
memcpy	function
(	O
(	O
void	O
*	O
)	O
(	O
strob_str	function
(	O
taru	pointer
->	O
headerM	pointer
)	O
+	O
taru	pointer
->	O
header_lengthM	int
)	O
,	O
(	O
void	O
*	O
)	O
(	O
read_buffer	pointer
)	O
,	O
512	int
)	O
;	O
taru	pointer
->	O
header_lengthM	int
+=	O
512	int
;	O
}	O
retval	int
+=	O
512	int
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
null_block	function
(	O
(	O
long	O
*	O
)	O
read_buffer	pointer
,	O
TARRECORDSIZE	int
)	O
)	O
{	O
ahsStaticSetTarFilename	function
(	O
file_hdr	pointer
,	O
CPIO_INBAND_EOA_FILENAME	pointer
)	O
;	O
if	O
(	O
fsource_buffer	pointer
==	O
NULL	O
)	O
{	O
eoaret	int
=	O
taru_tape_buffered_read	function
(	O
in_des	int
,	O
(	O
void	O
*	O
)	O
read_buffer	pointer
,	O
TARRECORDSIZE	int
)	O
;	O
}	O
else	O
{	O
eoaret	int
=	O
TARRECORDSIZE	int
;	O
memset	function
(	O
read_buffer	pointer
,	O
'\0'	O
,	O
TARRECORDSIZE	int
)	O
;	O
}	O
if	O
(	O
eoaret	int
!=	O
TARRECORDSIZE	int
||	O
null_block	function
(	O
(	O
long	O
*	O
)	O
read_buffer	pointer
,	O
TARRECORDSIZE	int
)	O
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: possible corrupt archive, non-null block found after one null block\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
retval	int
=	O
-	O
1	int
;	O
}	O
else	O
{	O
retval	int
=	O
1024	int
;	O
}	O
taru	pointer
->	O
read_buffer_posM	int
+=	O
TARRECORDSIZE	int
;	O
if	O
(	O
eoa	pointer
)	O
*	O
eoa	pointer
=	O
retval	int
;	O
return	O
retval	int
;	O
}	O
tar_hdr	pointer
=	O
(	O
struct	O
tar_header	struct
*	O
)	O
(	O
read_buffer	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
tar_hdr	pointer
->	O
typeflag	char
==	O
GNUTYPE_LONGNAME	char
||	O
tar_hdr	pointer
->	O
typeflag	char
==	O
GNUTYPE_LONGLINK	char
||	O
tar_hdr	pointer
->	O
typeflag	char
==	O
XHDTYPE	char
||	O
tar_hdr	pointer
->	O
typeflag	char
==	O
XGLTYPE	char
)	O
{	O
E_DEBUG2	O
(	O
"GOT Extened Header data type:[%c]"	pointer
,	O
tar_hdr	pointer
->	O
typeflag	char
)	O
;	O
taru_otoumax	function
(	O
tar_hdr	pointer
->	O
size	long
,	O
&	O
file_hdr	pointer
->	O
c_filesize	long
)	O
;	O
if	O
(	O
fsource_buffer	pointer
)	O
{	O
E_DEBUG	O
(	O
"in fsource_buffer"	pointer
)	O
;	O
if	O
(	O
(	O
unsigned	O
long	O
)	O
fsource_buffer_len	int
<	O
file_hdr	pointer
->	O
c_filesize	long
)	O
{	O
E_DEBUG3	O
(	O
"fsource_buffer_len < file_hdr->c_filesize: %d < %d"	pointer
,	O
(	O
int	O
)	O
fsource_buffer_len	int
,	O
(	O
int	O
)	O
file_hdr	pointer
->	O
c_filesize	long
)	O
;	O
tmpret_extdata	int
=	O
-	O
1	int
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
"reading pax data blocks"	pointer
)	O
;	O
tmpret_extdata	int
=	O
taru_read_pax_data_blocks	function
(	O
taru	pointer
,	O
-	O
1	int
,	O
fsource_buffer	pointer
,	O
file_hdr	pointer
->	O
c_filesize	long
,	O
taru_tape_buffered_read	function
)	O
;	O
}	O
if	O
(	O
tmpret_extdata	int
>	O
0	int
)	O
{	O
fsource_buffer_len	int
-=	O
tmpret_extdata	int
;	O
}	O
}	O
else	O
{	O
E_DEBUG	O
(	O
"fsource_buffer is NULL"	pointer
)	O
;	O
tmpret_extdata	int
=	O
taru_read_pax_data_blocks	function
(	O
taru	pointer
,	O
in_des	int
,	O
NULL	O
,	O
file_hdr	pointer
->	O
c_filesize	long
,	O
taru_tape_buffered_read	function
)	O
;	O
}	O
if	O
(	O
tmpret_extdata	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"fatal error reading extended header data blocks\n"	pointer
)	O
;	O
exit	function
(	O
24	int
)	O
;	O
}	O
ext_data_buffer	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
strob_str	function
(	O
taru	pointer
->	O
read_bufferM	pointer
)	O
+	O
taru	pointer
->	O
read_buffer_posM	int
-	O
tmpret_extdata	int
;	O
ext_data_buffer_len	int
=	O
file_hdr	pointer
->	O
c_filesize	long
;	O
switch	O
(	O
tar_hdr	pointer
->	O
typeflag	char
)	O
{	O
case	O
GNUTYPE_LONGNAME	char
:	O
ahsStaticSetTarFilename	function
(	O
file_hdr	pointer
,	O
(	O
char	O
*	O
)	O
ext_data_buffer	pointer
)	O
;	O
E_DEBUG2	O
(	O
"Setting LongName Data: [%s]"	pointer
,	O
ahsStaticGetTarFilename	function
(	O
file_hdr	pointer
)	O
)	O
;	O
file_hdr	pointer
->	O
extHeader_usage_maskM	int
|=	O
TARU_EHUM_PATH	O
;	O
break	O
;	O
case	O
GNUTYPE_LONGLINK	char
:	O
ahsStaticSetPaxLinkname	function
(	O
file_hdr	pointer
,	O
(	O
char	O
*	O
)	O
ext_data_buffer	pointer
)	O
;	O
E_DEBUG2	O
(	O
"Setting LongLink Data: [%s]"	pointer
,	O
ahsStaticGetTarLinkname	function
(	O
file_hdr	pointer
)	O
)	O
;	O
file_hdr	pointer
->	O
extHeader_usage_maskM	int
|=	O
TARU_EHUM_LINKPATH	O
;	O
break	O
;	O
case	O
XGLTYPE	char
:	O
fprintf	function
(	O
stderr	pointer
,	O
"type XGLTYPE (Pax Global Header) not supported\n"	pointer
)	O
;	O
exit	function
(	O
26	int
)	O
;	O
break	O
;	O
case	O
XHDTYPE	char
:	O
tmpret	int
=	O
taru_read_all_ext_header_records	function
(	O
file_hdr	pointer
,	O
(	O
char	O
*	O
)	O
ext_data_buffer	pointer
,	O
ext_data_buffer_len	int
,	O
&	O
xhd_errorcode	int
)	O
;	O
if	O
(	O
tmpret	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: error reading Pax extended header, errorcode=%d\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
xhd_errorcode	int
)	O
;	O
return	O
-	O
11	int
;	O
}	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
"fatal internal error\n"	pointer
)	O
;	O
exit	function
(	O
26	int
)	O
;	O
break	O
;	O
}	O
E_DEBUG	O
(	O
"Calling i_taru_read_in_tar_header2"	pointer
)	O
;	O
read_so_far	int
=	O
tmpret_ustar	int
+	O
tmpret_extdata	int
;	O
retval	int
=	O
i_taru_read_in_tar_header2	function
(	O
taru	pointer
,	O
file_hdr	pointer
,	O
in_des	int
,	O
fsource_buffer	pointer
?	O
fsource_buffer	pointer
+	O
read_so_far	int
:	O
(	O
char	O
*	O
)	O
NULL	O
,	O
eoa	pointer
,	O
tarheaderflags	int
,	O
fsource_buffer_len	int
,	O
fp_retval	int
+	O
read_so_far	int
)	O
;	O
return	O
retval	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
while	O
(	O
1	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
taru_otoul	function
(	O
tar_hdr	pointer
->	O
chksum	array
,	O
&	O
file_hdr	pointer
->	O
c_chksum	long
)	O
;	O
if	O
(	O
file_hdr	pointer
->	O
c_chksum	long
!=	O
taru_tar_checksum	function
(	O
tar_hdr	pointer
)	O
)	O
{	O
if	O
(	O
!	O
fsource_buffer	pointer
)	O
{	O
if	O
(	O
!	O
warned	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: invalid header: checksum error\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
warned	int
=	O
TRUE	int
;	O
}	O
if	O
(	O
tarheaderflags	int
&	O
TARU_TAR_FRAGILE_FORMAT	O
)	O
return	O
-	O
2	int
;	O
bcopy	function
(	O
(	O
(	O
char	O
*	O
)	O
&	O
tar_rec	union
)	O
+	O
1	int
,	O
(	O
char	O
*	O
)	O
&	O
tar_rec	union
,	O
TARRECORDSIZE	int
-	O
1	int
)	O
;	O
taru_tape_buffered_read	function
(	O
in_des	int
,	O
(	O
void	O
*	O
)	O
(	O
(	O
(	O
char	O
*	O
)	O
(	O
&	O
tar_rec	union
)	O
)	O
+	O
(	O
TARRECORDSIZE	int
-	O
1	int
)	O
)	O
,	O
1	int
)	O
;	O
++	O
bytes_skipped	long
;	O
continue	O
;	O
}	O
else	O
{	O
return	O
-	O
3	int
;	O
}	O
}	O
if	O
(	O
(	O
(	O
file_hdr	pointer
->	O
extHeader_usage_maskM	int
)	O
&	O
TARU_EHUM_PATH	O
)	O
==	O
0	int
)	O
{	O
tmpname	pointer
=	O
taru_dup_tar_name	function
(	O
(	O
void	O
*	O
)	O
tar_hdr	pointer
)	O
;	O
ahsStaticSetTarFilename	function
(	O
file_hdr	pointer
,	O
tmpname	pointer
)	O
;	O
}	O
else	O
{	O
;	O
tmpname	pointer
=	O
NULL	O
;	O
E_DEBUG	O
(	O
"Path set by extended headers"	pointer
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
file_hdr	pointer
->	O
c_namesize	short
=	O
strlen	function
(	O
ahsStaticGetTarFilename	function
(	O
file_hdr	pointer
)	O
)	O
+	O
1	int
;	O
if	O
(	O
(	O
char	O
)	O
(	O
tar_hdr	pointer
->	O
typeflag	char
)	O
==	O
LNKTYPE	char
)	O
{	O
E_DEBUG	O
(	O
"setting file_hdr->c_nlink = 2"	pointer
)	O
;	O
file_hdr	pointer
->	O
c_nlink	short
=	O
2	int
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
"setting file_hdr->c_nlink = 1"	pointer
)	O
;	O
file_hdr	pointer
->	O
c_nlink	short
=	O
1	int
;	O
}	O
taru_otoul	function
(	O
tar_hdr	pointer
->	O
mode	int
,	O
&	O
(	O
file_hdr	pointer
->	O
c_mode	short
)	O
)	O
;	O
file_hdr	pointer
->	O
c_mode	short
=	O
file_hdr	pointer
->	O
c_mode	short
&	O
07777	int
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ahsStaticSetTarUsername	function
(	O
file_hdr	pointer
,	O
tar_hdr	pointer
->	O
uname	array
)	O
;	O
if	O
(	O
tar_iflags_retain_header_id	int
==	O
0	int
&&	O
l_cache_tar_getuidbyname	function
(	O
tar_hdr	pointer
->	O
uname	array
,	O
&	O
uidp	long
)	O
==	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
file_hdr	pointer
->	O
c_uid	short
=	O
uidp	long
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
taru_otoul	function
(	O
tar_hdr	pointer
->	O
uid	int
,	O
&	O
file_hdr	pointer
->	O
c_uid	short
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
taru_set_filetype_from_tartype	function
(	O
(	O
char	O
)	O
(	O
tar_hdr	pointer
->	O
typeflag	char
)	O
,	O
(	O
modet	int
=	O
(	O
mode_t	int
)	O
(	O
file_hdr	pointer
->	O
c_mode	short
)	O
,	O
&	O
modet	int
)	O
,	O
tmpname	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
switch	O
(	O
(	O
int	O
)	O
(	O
tar_hdr	pointer
->	O
typeflag	char
)	O
)	O
{	O
case	O
LNKTYPE	char
:	O
file_hdr	pointer
->	O
c_is_tar_lnktype	char
=	O
1	int
;	O
break	O
;	O
default	O
:	O
file_hdr	pointer
->	O
c_is_tar_lnktype	char
=	O
0	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ahsStaticSetTarGroupname	function
(	O
file_hdr	pointer
,	O
tar_hdr	pointer
->	O
gname	array
)	O
;	O
if	O
(	O
tar_iflags_retain_header_id	int
==	O
0	int
&&	O
l_cache_tar_getgidbyname	function
(	O
tar_hdr	pointer
->	O
gname	array
,	O
&	O
gidp	long
)	O
==	O
0	int
)	O
{	O
file_hdr	pointer
->	O
c_gid	short
=	O
gidp	long
;	O
}	O
else	O
{	O
taru_otoul	function
(	O
tar_hdr	pointer
->	O
gid	int
,	O
&	O
file_hdr	pointer
->	O
c_gid	short
)	O
;	O
}	O
taru_otoumax	function
(	O
tar_hdr	pointer
->	O
size	long
,	O
&	O
file_hdr	pointer
->	O
c_filesize	long
)	O
;	O
taru_otoul	function
(	O
tar_hdr	pointer
->	O
mtime	long
,	O
&	O
file_hdr	pointer
->	O
c_mtime	long
)	O
;	O
taru_otoul	function
(	O
tar_hdr	pointer
->	O
devmajor	array
,	O
(	O
unsigned	O
long	O
*	O
)	O
&	O
file_hdr	pointer
->	O
c_rdev_maj	long
)	O
;	O
taru_otoul	function
(	O
tar_hdr	pointer
->	O
devminor	array
,	O
(	O
unsigned	O
long	O
*	O
)	O
&	O
file_hdr	pointer
->	O
c_rdev_min	long
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
switch	O
(	O
tar_hdr	pointer
->	O
typeflag	char
)	O
{	O
case	O
REGTYPE	char
:	O
case	O
CONTTYPE	char
:	O
default	O
:	O
file_hdr	pointer
->	O
c_mode	short
|=	O
CP_IFREG	int
;	O
break	O
;	O
case	O
DIRTYPE	char
:	O
file_hdr	pointer
->	O
c_mode	short
|=	O
CP_IFDIR	int
;	O
break	O
;	O
case	O
CHRTYPE	char
:	O
file_hdr	pointer
->	O
c_mode	short
|=	O
CP_IFCHR	int
;	O
ahsStaticSetTarLinkname	function
(	O
file_hdr	pointer
,	O
tar_hdr	pointer
->	O
linkname	pointer
)	O
;	O
file_hdr	pointer
->	O
c_filesize	long
=	O
0	int
;	O
break	O
;	O
case	O
BLKTYPE	char
:	O
file_hdr	pointer
->	O
c_mode	short
|=	O
CP_IFBLK	int
;	O
ahsStaticSetTarLinkname	function
(	O
file_hdr	pointer
,	O
tar_hdr	pointer
->	O
linkname	pointer
)	O
;	O
file_hdr	pointer
->	O
c_filesize	long
=	O
0	int
;	O
break	O
;	O
case	O
FIFOTYPE	char
:	O
file_hdr	pointer
->	O
c_mode	short
|=	O
CP_IFIFO	int
;	O
ahsStaticSetTarLinkname	function
(	O
file_hdr	pointer
,	O
tar_hdr	pointer
->	O
linkname	pointer
)	O
;	O
file_hdr	pointer
->	O
c_filesize	long
=	O
0	int
;	O
break	O
;	O
case	O
SYMTYPE	char
:	O
E_DEBUG	O
(	O
"at SYMLINK"	pointer
)	O
;	O
file_hdr	pointer
->	O
c_mode	short
|=	O
CP_IFLNK	int
;	O
if	O
(	O
(	O
(	O
file_hdr	pointer
->	O
extHeader_usage_maskM	int
)	O
&	O
TARU_EHUM_LINKPATH	O
)	O
==	O
0	int
)	O
{	O
E_DEBUG2	O
(	O
"linkname=[%s]"	pointer
,	O
tar_hdr	pointer
->	O
linkname	pointer
)	O
;	O
ahsStaticSetTarLinkname	function
(	O
file_hdr	pointer
,	O
tar_hdr	pointer
->	O
linkname	pointer
)	O
;	O
E_DEBUG2	O
(	O
"ahs linkname=[%s]"	pointer
,	O
ahsStaticGetTarLinkname	function
(	O
file_hdr	pointer
)	O
)	O
;	O
}	O
else	O
{	O
;	O
E_DEBUG	O
(	O
"Path set by extended headers"	pointer
)	O
;	O
}	O
file_hdr	pointer
->	O
c_filesize	long
=	O
0	int
;	O
break	O
;	O
case	O
LNKTYPE	char
:	O
file_hdr	pointer
->	O
c_mode	short
|=	O
CP_IFREG	int
;	O
ahsStaticSetTarLinkname	function
(	O
file_hdr	pointer
,	O
tar_hdr	pointer
->	O
linkname	pointer
)	O
;	O
file_hdr	pointer
->	O
c_filesize	long
=	O
0	int
;	O
break	O
;	O
case	O
AREGTYPE	char
:	O
aregfilename	pointer
=	O
ahsStaticGetTarFilename	function
(	O
file_hdr	pointer
)	O
;	O
if	O
(	O
aregfilename	pointer
[	O
strlen	function
(	O
aregfilename	pointer
)	O
-	O
1	int
]	O
==	O
'/'	O
)	O
file_hdr	pointer
->	O
c_mode	short
|=	O
CP_IFDIR	int
;	O
else	O
file_hdr	pointer
->	O
c_mode	short
|=	O
CP_IFREG	int
;	O
break	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
bytes_skipped	long
>	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: warning: skipped %ld bytes of junk\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
bytes_skipped	long
)	O
;	O
if	O
(	O
tarheaderflags	int
&	O
TARU_TAR_FRAGILE_FORMAT	O
)	O
return	O
-	O
4	int
;	O
}	O
return	O
retval	int
+	O
fp_retval	int
;	O
}	O
int	O
taru_read_in_tar_header2	function
(	O
TARU	struct
*	O
taru	pointer
,	O
struct	O
new_cpio_header	struct
*	O
file_hdr	pointer
,	O
int	O
in_des	int
,	O
char	O
*	O
fsource_buffer	pointer
,	O
int	O
*	O
eoa	pointer
,	O
int	O
tarheaderflags	int
,	O
int	O
fsource_buffer_len	int
)	O
{	O
EXATT	struct
*	O
p	pointer
;	O
CPLOB	struct
*	O
extlist	pointer
;	O
int	O
index	function
;	O
int	O
ret	int
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
taru	pointer
)	O
taru	pointer
->	O
read_buffer_posM	int
=	O
0	int
;	O
if	O
(	O
taru	pointer
&&	O
taru	pointer
->	O
do_record_headerM	int
)	O
{	O
taru	pointer
->	O
header_lengthM	int
=	O
0	int
;	O
}	O
file_hdr	pointer
->	O
extHeader_usage_maskM	int
=	O
0	int
;	O
taru_exattlist_init	function
(	O
file_hdr	pointer
)	O
;	O
ahsStaticSetTarFilename	function
(	O
file_hdr	pointer
,	O
""	pointer
)	O
;	O
ahsStaticSetPaxLinkname	function
(	O
file_hdr	pointer
,	O
""	pointer
)	O
;	O
E_DEBUG2	O
(	O
"fsource_buffer=%p"	pointer
,	O
fsource_buffer	pointer
)	O
;	O
E_DEBUG2	O
(	O
"fsource_buffer_len=%d"	pointer
,	O
fsource_buffer_len	int
)	O
;	O
ret	int
=	O
i_taru_read_in_tar_header2	function
(	O
taru	pointer
,	O
file_hdr	pointer
,	O
in_des	int
,	O
fsource_buffer	pointer
,	O
eoa	pointer
,	O
tarheaderflags	int
,	O
fsource_buffer_len	int
,	O
0	int
)	O
;	O
if	O
(	O
file_hdr	pointer
->	O
extHeader_usage_maskM	int
)	O
{	O
extlist	pointer
=	O
(	O
CPLOB	struct
*	O
)	O
(	O
file_hdr	pointer
->	O
extattlistM	pointer
)	O
;	O
if	O
(	O
extlist	pointer
)	O
{	O
index	function
=	O
0	int
;	O
while	O
(	O
(	O
p	pointer
=	O
(	O
EXATT	struct
*	O
)	O
cplob_val	function
(	O
file_hdr	pointer
->	O
extattlistM	pointer
,	O
index	function
)	O
)	O
)	O
{	O
taru_exatt_override_ustar	function
(	O
file_hdr	pointer
,	O
p	pointer
)	O
;	O
index	function
++	O
;	O
}	O
}	O
}	O
return	O
ret	int
;	O
}	O
int	O
taru_write_out_tar_header2	function
(	O
TARU	struct
*	O
taru	pointer
,	O
struct	O
new_cpio_header	struct
*	O
file_hdr	pointer
,	O
int	O
out_des	int
,	O
char	O
*	O
header_buffer	pointer
,	O
char	O
*	O
username	pointer
,	O
char	O
*	O
groupname	pointer
,	O
int	O
tar_iflags	int
)	O
{	O
int	O
ret	int
;	O
union	O
tar_record	union
tar_rec	union
;	O
struct	O
tar_header	struct
*	O
tar_hdr	pointer
=	O
(	O
struct	O
tar_header	struct
*	O
)	O
&	O
tar_rec	union
;	O
char	O
*	O
u_name_buffer	pointer
;	O
char	O
*	O
u_ent_buffer	pointer
;	O
unsigned	O
long	O
sum	long
;	O
int	O
termch	int
;	O
char	O
*	O
tmpp	pointer
;	O
int	O
tar_iflags_like_star	int
;	O
int	O
tar_iflags_like_pax	int
;	O
int	O
tar_iflags_numeric_uids	int
;	O
int	O
tar_iflags_like_oldgnu	int
;	O
int	O
tar_iflags_like_oldgnuposix	int
;	O
int	O
tar_iflags_like_gnu	int
;	O
int	O
do_record_header	int
=	O
0	int
;	O
if	O
(	O
!	O
taru	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"fatal internal error: taru is NULL, this needs to be fixed\n"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
*	O
(	O
(	O
char	O
*	O
)	O
(	O
taru	pointer
)	O
)	O
!=	O
'A'	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: fatal error: taru is uninitialized, this needs to be fixed\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
E_DEBUG3	O
(	O
"ENTERING fd=%d, name=[%s]"	pointer
,	O
out_des	int
,	O
ahsStaticGetTarFilename	function
(	O
file_hdr	pointer
)	O
)	O
;	O
E_DEBUG3	O
(	O
"username=[%s] groupname=[%s]"	pointer
,	O
username	pointer
,	O
groupname	pointer
)	O
;	O
E_DEBUG3	O
(	O
"file_hdr: uid=[%d] gid=[%d]"	pointer
,	O
(	O
int	O
)	O
(	O
file_hdr	pointer
->	O
c_uid	short
)	O
,	O
(	O
int	O
)	O
(	O
file_hdr	pointer
->	O
c_gid	short
)	O
)	O
;	O
bzero	function
(	O
(	O
char	O
*	O
)	O
&	O
tar_rec	union
,	O
TARRECORDSIZE	int
)	O
;	O
tar_iflags_like_star	int
=	O
(	O
tar_iflags	int
&	O
TARU_TAR_BE_LIKE_STAR	O
)	O
;	O
tar_iflags_like_pax	int
=	O
(	O
tar_iflags	int
&	O
TARU_TAR_BE_LIKE_PAX	O
)	O
;	O
tar_iflags_numeric_uids	int
=	O
(	O
tar_iflags	int
&	O
TARU_TAR_NUMERIC_UIDS	O
)	O
;	O
tar_iflags_like_gnu	int
=	O
(	O
tar_iflags	int
&	O
TARU_TAR_GNU_GNUTAR	O
)	O
;	O
tar_iflags_like_oldgnu	int
=	O
(	O
tar_iflags	int
&	O
TARU_TAR_GNU_OLDGNUTAR	O
)	O
;	O
tar_iflags_like_oldgnuposix	int
=	O
(	O
tar_iflags	int
&	O
TARU_TAR_GNU_OLDGNUPOSIX	O
)	O
;	O
E_DEBUG2	O
(	O
"tar_iflags_numeric_uids is %d"	pointer
,	O
tar_iflags_numeric_uids	int
)	O
;	O
do_record_header	int
=	O
taru	pointer
->	O
do_record_headerM	int
;	O
if	O
(	O
tar_iflags_like_star	int
)	O
{	O
termch	int
=	O
'\040'	O
;	O
}	O
else	O
{	O
termch	int
=	O
0	int
;	O
}	O
strob_strcpy	function
(	O
taru	pointer
->	O
u_name_bufferM	pointer
,	O
ahsStaticGetTarFilename	function
(	O
file_hdr	pointer
)	O
)	O
;	O
if	O
(	O
strob_strlen	function
(	O
taru	pointer
->	O
u_name_bufferM	pointer
)	O
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: internal error: taru->u_name_bufferM zero length\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
switch	O
(	O
file_hdr	pointer
->	O
c_mode	short
&	O
CP_IFMT	int
)	O
{	O
case	O
CP_IFDIR	int
:	O
if	O
(	O
*	O
(	O
strob_str	function
(	O
taru	pointer
->	O
u_name_bufferM	pointer
)	O
+	O
strob_strlen	function
(	O
taru	pointer
->	O
u_name_bufferM	pointer
)	O
-	O
1	int
)	O
!=	O
'/'	O
)	O
{	O
if	O
(	O
(	O
strob_strlen	function
(	O
taru	pointer
->	O
u_name_bufferM	pointer
)	O
>=	O
TARNAMESIZE	int
-	O
1	int
)	O
&&	O
(	O
tar_iflags_like_oldgnu	int
||	O
tar_iflags_like_oldgnuposix	int
)	O
)	O
{	O
;	O
}	O
else	O
{	O
strob_strcat	function
(	O
taru	pointer
->	O
u_name_bufferM	pointer
,	O
"/"	pointer
)	O
;	O
}	O
}	O
break	O
;	O
}	O
u_name_buffer	pointer
=	O
strob_str	function
(	O
taru	pointer
->	O
u_name_bufferM	pointer
)	O
;	O
u_ent_buffer	pointer
=	O
strob_str	function
(	O
taru	pointer
->	O
u_ent_bufferM	pointer
)	O
;	O
if	O
(	O
taru_set_new_name	function
(	O
tar_hdr	pointer
,	O
-	O
1	int
,	O
u_name_buffer	pointer
,	O
taru	pointer
->	O
taru_tarheaderflagsM	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: %s not dumped\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
u_name_buffer	pointer
)	O
;	O
return	O
-	O
13	int
;	O
}	O
if	O
(	O
tar_iflags_like_oldgnu	int
)	O
{	O
MODE_TO_OLDGNU_CHARS	O
(	O
file_hdr	pointer
->	O
c_mode	short
,	O
tar_hdr	pointer
->	O
mode	int
,	O
termch	int
)	O
;	O
}	O
else	O
{	O
MODE_TO_CHARS	O
(	O
file_hdr	pointer
->	O
c_mode	short
,	O
tar_hdr	pointer
->	O
mode	int
,	O
termch	int
)	O
;	O
}	O
UID_TO_CHARS	O
(	O
file_hdr	pointer
->	O
c_uid	short
,	O
tar_hdr	pointer
->	O
uid	int
,	O
termch	int
)	O
;	O
GID_TO_CHARS	O
(	O
file_hdr	pointer
->	O
c_gid	short
,	O
tar_hdr	pointer
->	O
gid	int
,	O
termch	int
)	O
;	O
OFF_TO_CHARS	O
(	O
file_hdr	pointer
->	O
c_filesize	long
,	O
tar_hdr	pointer
->	O
size	long
,	O
termch	int
)	O
;	O
TIME_TO_CHARS	O
(	O
file_hdr	pointer
->	O
c_mtime	long
,	O
tar_hdr	pointer
->	O
mtime	long
,	O
termch	int
)	O
;	O
*	O
(	O
tar_hdr	pointer
->	O
version	array
)	O
=	O
'0'	O
;	O
*	O
(	O
tar_hdr	pointer
->	O
version	array
+	O
1	int
)	O
=	O
'0'	O
;	O
switch	O
(	O
file_hdr	pointer
->	O
c_mode	short
&	O
CP_IFMT	int
)	O
{	O
case	O
CP_IFREG	int
:	O
tmpp	pointer
=	O
ahsStaticGetTarLinkname	function
(	O
file_hdr	pointer
)	O
;	O
if	O
(	O
tmpp	pointer
&&	O
strlen	function
(	O
tmpp	pointer
)	O
)	O
{	O
if	O
(	O
strlen	function
(	O
tmpp	pointer
)	O
>	O
TARLINKNAMESIZE	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s, link name [%s] too long for tar (returning -4).\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
tmpp	pointer
)	O
;	O
E_DEBUG	O
(	O
"LEAVING"	pointer
)	O
;	O
return	O
-	O
4	int
;	O
}	O
strncpy	function
(	O
tar_hdr	pointer
->	O
linkname	pointer
,	O
tmpp	pointer
,	O
TARLINKNAMESIZE	int
)	O
;	O
SIZE_TO_CHARS	O
(	O
0	int
,	O
tar_hdr	pointer
->	O
size	long
,	O
termch	int
)	O
;	O
tar_hdr	pointer
->	O
typeflag	char
=	O
LNKTYPE	char
;	O
}	O
else	O
{	O
tar_hdr	pointer
->	O
typeflag	char
=	O
REGTYPE	char
;	O
}	O
break	O
;	O
case	O
CP_IFDIR	int
:	O
tar_hdr	pointer
->	O
typeflag	char
=	O
DIRTYPE	char
;	O
break	O
;	O
case	O
CP_IFCHR	int
:	O
tar_hdr	pointer
->	O
typeflag	char
=	O
CHRTYPE	char
;	O
break	O
;	O
case	O
CP_IFBLK	int
:	O
tar_hdr	pointer
->	O
typeflag	char
=	O
BLKTYPE	char
;	O
break	O
;	O
case	O
CP_IFSOCK	int
:	O
case	O
CP_IFIFO	int
:	O
tar_hdr	pointer
->	O
typeflag	char
=	O
FIFOTYPE	char
;	O
break	O
;	O
case	O
CP_IFLNK	int
:	O
tmpp	pointer
=	O
ahsStaticGetTarLinkname	function
(	O
file_hdr	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
ahsStaticGetTarFilename	function
(	O
file_hdr	pointer
)	O
,	O
GNU_LONG_LINK	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
strlen	function
(	O
tmpp	pointer
)	O
>	O
510	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: link name [%s] too long this implementation at this time.\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
tmpp	pointer
)	O
;	O
return	O
-	O
5	int
;	O
}	O
tar_hdr	pointer
->	O
typeflag	char
=	O
GNUTYPE_LONGLINK	char
;	O
SIZE_TO_CHARS	O
(	O
strlen	function
(	O
tmpp	pointer
)	O
,	O
tar_hdr	pointer
->	O
size	long
,	O
termch	int
)	O
;	O
}	O
else	O
{	O
tar_hdr	pointer
->	O
typeflag	char
=	O
SYMTYPE	char
;	O
if	O
(	O
strlen	function
(	O
tmpp	pointer
)	O
>	O
TARLINKNAMESIZE	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: link name [%s] too long for tar.\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
tmpp	pointer
)	O
;	O
E_DEBUG	O
(	O
"LEAVING"	pointer
)	O
;	O
return	O
-	O
5	int
;	O
}	O
SIZE_TO_CHARS	O
(	O
0	int
,	O
tar_hdr	pointer
->	O
size	long
,	O
termch	int
)	O
;	O
}	O
strncpy	function
(	O
tar_hdr	pointer
->	O
linkname	pointer
,	O
tmpp	pointer
,	O
TARLINKNAMESIZE	int
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
file_hdr	pointer
->	O
c_mode	short
==	O
0	int
&&	O
strcmp	function
(	O
ahsStaticGetTarFilename	function
(	O
file_hdr	pointer
)	O
,	O
GNU_LONG_LINK	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
strlen	function
(	O
ahsStaticGetTarLinkname	function
(	O
file_hdr	pointer
)	O
)	O
==	O
0	int
)	O
{	O
tar_hdr	pointer
->	O
typeflag	char
=	O
GNUTYPE_LONGNAME	char
;	O
}	O
else	O
{	O
tar_hdr	pointer
->	O
typeflag	char
=	O
GNUTYPE_LONGLINK	char
;	O
}	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"bad CP_?? filetype in taru_write_out_tar_header2: mode = %d\n"	pointer
,	O
(	O
int	O
)	O
(	O
file_hdr	pointer
->	O
c_mode	short
)	O
)	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
tar_iflags_like_gnu	int
==	O
0	int
&&	O
tar_iflags_like_oldgnu	int
==	O
0	int
)	O
{	O
strncpy	function
(	O
tar_hdr	pointer
->	O
magic	array
,	O
TMAGIC	pointer
,	O
TMAGLEN	int
)	O
;	O
strncpy	function
(	O
tar_hdr	pointer
->	O
magic	array
+	O
TMAGLEN	int
,	O
TVERSION	pointer
,	O
TVERSLEN	int
)	O
;	O
}	O
else	O
{	O
strncpy	function
(	O
tar_hdr	pointer
->	O
magic	array
,	O
"ustar "	pointer
,	O
6	int
)	O
;	O
strncpy	function
(	O
tar_hdr	pointer
->	O
magic	array
+	O
6	int
,	O
" "	pointer
,	O
2	int
)	O
;	O
}	O
if	O
(	O
(	O
username	pointer
==	O
NULL	O
||	O
strlen	function
(	O
username	pointer
)	O
==	O
0	int
)	O
&&	O
file_hdr	pointer
->	O
c_cu	char
!=	O
TARU_C_BY_UNONE	int
)	O
{	O
E_DEBUG	O
(	O
"username nil"	pointer
)	O
;	O
l_tar_sysdata_getuser	function
(	O
file_hdr	pointer
->	O
c_uid	short
,	O
u_ent_buffer	pointer
,	O
NULL	O
)	O
;	O
swlib_strncpy	function
(	O
tar_hdr	pointer
->	O
uname	array
,	O
u_ent_buffer	pointer
,	O
SNAME_LEN	int
)	O
;	O
}	O
else	O
{	O
uid_t	int
puid	pointer
;	O
if	O
(	O
file_hdr	pointer
->	O
c_cu	char
==	O
TARU_C_BY_USYS	int
||	O
file_hdr	pointer
->	O
c_cu	char
==	O
TARU_C_BY_UNAME	int
)	O
{	O
E_DEBUG2	O
(	O
"finding uid for username = %s"	pointer
,	O
username	pointer
)	O
;	O
if	O
(	O
taru_get_uid_by_name	function
(	O
username	pointer
,	O
&	O
puid	pointer
)	O
)	O
{	O
puid	pointer
=	O
NOBODY_ID	O
;	O
E_DEBUG3	O
(	O
"user name [%s] not found setting uid to %d"	pointer
,	O
username	pointer
,	O
(	O
int	O
)	O
puid	pointer
)	O
;	O
}	O
swlib_strncpy	function
(	O
tar_hdr	pointer
->	O
uname	array
,	O
username	pointer
,	O
SNAME_LEN	int
)	O
;	O
}	O
else	O
if	O
(	O
file_hdr	pointer
->	O
c_cu	char
==	O
TARU_C_BY_UID	int
)	O
{	O
puid	pointer
=	O
file_hdr	pointer
->	O
c_uid	short
;	O
E_DEBUG2	O
(	O
"finding user for uid  %d"	pointer
,	O
(	O
int	O
)	O
puid	pointer
)	O
;	O
if	O
(	O
tar_iflags_numeric_uids	int
==	O
0	int
)	O
{	O
taru_get_tar_user_by_uid	function
(	O
puid	pointer
,	O
u_ent_buffer	pointer
)	O
;	O
swlib_strncpy	function
(	O
tar_hdr	pointer
->	O
uname	array
,	O
u_ent_buffer	pointer
,	O
SNAME_LEN	int
)	O
;	O
}	O
else	O
{	O
swlib_strncpy	function
(	O
tar_hdr	pointer
->	O
uname	array
,	O
""	pointer
,	O
SNAME_LEN	int
)	O
;	O
}	O
}	O
else	O
{	O
E_DEBUG	O
(	O
"Using user and uid with no lookups"	pointer
)	O
;	O
puid	pointer
=	O
file_hdr	pointer
->	O
c_uid	short
;	O
swlib_strncpy	function
(	O
tar_hdr	pointer
->	O
uname	array
,	O
username	pointer
,	O
SNAME_LEN	int
)	O
;	O
}	O
UID_TO_CHARS	O
(	O
puid	pointer
,	O
tar_hdr	pointer
->	O
uid	int
,	O
termch	int
)	O
;	O
}	O
if	O
(	O
(	O
groupname	pointer
==	O
NULL	O
||	O
strlen	function
(	O
groupname	pointer
)	O
==	O
0	int
)	O
&&	O
file_hdr	pointer
->	O
c_cg	char
!=	O
TARU_C_BY_GNONE	int
)	O
{	O
E_DEBUG	O
(	O
"groupname nil"	pointer
)	O
;	O
l_tar_sysdata_getgroup	function
(	O
file_hdr	pointer
->	O
c_gid	short
,	O
u_ent_buffer	pointer
,	O
NULL	O
)	O
;	O
strncpy	function
(	O
tar_hdr	pointer
->	O
gname	array
,	O
u_ent_buffer	pointer
,	O
SNAME_LEN	int
)	O
;	O
}	O
else	O
{	O
gid_t	int
pgid	pointer
;	O
if	O
(	O
file_hdr	pointer
->	O
c_cg	char
==	O
TARU_C_BY_GSYS	int
||	O
file_hdr	pointer
->	O
c_cg	char
==	O
TARU_C_BY_GNAME	int
)	O
{	O
E_DEBUG2	O
(	O
"finding gid for groupname=%s"	pointer
,	O
groupname	pointer
)	O
;	O
swlib_strncpy	function
(	O
tar_hdr	pointer
->	O
gname	array
,	O
groupname	pointer
,	O
SNAME_LEN	int
)	O
;	O
if	O
(	O
taru_get_gid_by_name	function
(	O
groupname	pointer
,	O
&	O
pgid	pointer
)	O
)	O
{	O
pgid	pointer
=	O
NOBODY_ID	O
;	O
E_DEBUG3	O
(	O
"group name [%s] not found setting uid to %d"	pointer
,	O
groupname	pointer
,	O
(	O
int	O
)	O
pgid	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
file_hdr	pointer
->	O
c_cg	char
==	O
TARU_C_BY_GID	int
)	O
{	O
pgid	pointer
=	O
file_hdr	pointer
->	O
c_gid	short
;	O
E_DEBUG2	O
(	O
"finding gname for gid  %d"	pointer
,	O
(	O
int	O
)	O
pgid	pointer
)	O
;	O
if	O
(	O
tar_iflags_numeric_uids	int
==	O
0	int
)	O
{	O
taru_get_tar_group_by_gid	function
(	O
pgid	pointer
,	O
u_ent_buffer	pointer
)	O
;	O
swlib_strncpy	function
(	O
tar_hdr	pointer
->	O
gname	array
,	O
u_ent_buffer	pointer
,	O
SNAME_LEN	int
)	O
;	O
}	O
else	O
{	O
swlib_strncpy	function
(	O
tar_hdr	pointer
->	O
gname	array
,	O
""	pointer
,	O
SNAME_LEN	int
)	O
;	O
}	O
}	O
else	O
{	O
E_DEBUG	O
(	O
"Using user and gid with no lookups"	pointer
)	O
;	O
pgid	pointer
=	O
file_hdr	pointer
->	O
c_gid	short
;	O
swlib_strncpy	function
(	O
tar_hdr	pointer
->	O
gname	array
,	O
groupname	pointer
,	O
SNAME_LEN	int
)	O
;	O
}	O
GID_TO_CHARS	O
(	O
pgid	pointer
,	O
tar_hdr	pointer
->	O
gid	int
,	O
termch	int
)	O
;	O
}	O
if	O
(	O
tar_iflags_numeric_uids	int
)	O
{	O
memset	function
(	O
(	O
void	O
*	O
)	O
tar_hdr	pointer
->	O
uname	array
,	O
'\0'	O
,	O
SNAME_LEN	int
)	O
;	O
memset	function
(	O
(	O
void	O
*	O
)	O
tar_hdr	pointer
->	O
gname	array
,	O
'\0'	O
,	O
SNAME_LEN	int
)	O
;	O
}	O
if	O
(	O
tar_hdr	pointer
->	O
typeflag	char
==	O
CHRTYPE	char
||	O
tar_hdr	pointer
->	O
typeflag	char
==	O
BLKTYPE	char
)	O
{	O
MAJOR_TO_CHARS	O
(	O
file_hdr	pointer
->	O
c_rdev_maj	long
,	O
tar_hdr	pointer
->	O
devmajor	array
,	O
termch	int
)	O
;	O
MINOR_TO_CHARS	O
(	O
file_hdr	pointer
->	O
c_rdev_min	long
,	O
tar_hdr	pointer
->	O
devminor	array
,	O
termch	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
tar_iflags_like_pax	int
)	O
{	O
strncpy	function
(	O
tar_hdr	pointer
->	O
devmajor	array
,	O
"0000000"	pointer
,	O
8	int
)	O
;	O
strncpy	function
(	O
tar_hdr	pointer
->	O
devminor	array
,	O
"0000000"	pointer
,	O
8	int
)	O
;	O
}	O
else	O
if	O
(	O
tar_iflags_like_star	int
)	O
{	O
strncpy	function
(	O
tar_hdr	pointer
->	O
devmajor	array
,	O
"0000000 "	pointer
,	O
8	int
)	O
;	O
strncpy	function
(	O
tar_hdr	pointer
->	O
devminor	array
,	O
"0000000 "	pointer
,	O
8	int
)	O
;	O
}	O
else	O
if	O
(	O
tar_iflags_like_gnu	int
||	O
tar_iflags_like_oldgnu	int
||	O
tar_iflags_like_oldgnuposix	int
)	O
{	O
;	O
}	O
else	O
{	O
strncpy	function
(	O
tar_hdr	pointer
->	O
devmajor	array
,	O
"0000000"	pointer
,	O
8	int
)	O
;	O
strncpy	function
(	O
tar_hdr	pointer
->	O
devminor	array
,	O
"0000000"	pointer
,	O
8	int
)	O
;	O
}	O
}	O
memcpy	function
(	O
tar_hdr	pointer
->	O
chksum	array
,	O
CHKBLANKS	pointer
,	O
sizeof	O
(	O
tar_hdr	pointer
->	O
chksum	array
)	O
)	O
;	O
sum	long
=	O
taru_tar_checksum	function
(	O
tar_hdr	pointer
)	O
;	O
if	O
(	O
tar_iflags_like_pax	int
||	O
tar_iflags_like_star	int
)	O
{	O
uintmax_to_chars	function
(	O
sum	long
,	O
tar_hdr	pointer
->	O
chksum	array
,	O
8	int
,	O
POSIX_FORMAT	int
,	O
termch	int
)	O
;	O
}	O
else	O
{	O
uintmax_to_chars	function
(	O
sum	long
,	O
tar_hdr	pointer
->	O
chksum	array
,	O
7	int
,	O
POSIX_FORMAT	int
,	O
termch	int
)	O
;	O
}	O
if	O
(	O
header_buffer	pointer
)	O
{	O
if	O
(	O
do_record_header	int
)	O
{	O
strob_set_memlength	function
(	O
taru	pointer
->	O
headerM	pointer
,	O
TARRECORDSIZE	int
)	O
;	O
memcpy	function
(	O
(	O
void	O
*	O
)	O
(	O
strob_str	function
(	O
taru	pointer
->	O
headerM	pointer
)	O
)	O
,	O
(	O
void	O
*	O
)	O
(	O
&	O
tar_rec	union
)	O
,	O
TARRECORDSIZE	int
)	O
;	O
taru	pointer
->	O
header_lengthM	int
=	O
TARRECORDSIZE	int
;	O
}	O
memcpy	function
(	O
header_buffer	pointer
,	O
(	O
void	O
*	O
)	O
&	O
tar_rec	union
,	O
512	int
)	O
;	O
E_DEBUG	O
(	O
"LEAVING"	pointer
)	O
;	O
return	O
512	int
;	O
}	O
else	O
{	O
if	O
(	O
do_record_header	int
)	O
{	O
strob_set_memlength	function
(	O
taru	pointer
->	O
headerM	pointer
,	O
TARRECORDSIZE	int
)	O
;	O
memcpy	function
(	O
(	O
void	O
*	O
)	O
(	O
strob_str	function
(	O
taru	pointer
->	O
headerM	pointer
)	O
)	O
,	O
(	O
void	O
*	O
)	O
(	O
&	O
tar_rec	union
)	O
,	O
TARRECORDSIZE	int
)	O
;	O
taru	pointer
->	O
header_lengthM	int
=	O
TARRECORDSIZE	int
;	O
}	O
ret	int
=	O
taru_safewrite	function
(	O
out_des	int
,	O
(	O
void	O
*	O
)	O
&	O
tar_rec	union
,	O
TARRECORDSIZE	int
)	O
;	O
E_DEBUG	O
(	O
"LEAVING"	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
}	O
long	O
taru_from_oct	function
(	O
int	O
digs	pointer
,	O
char	O
*	O
where	pointer
)	O
{	O
long	O
value	int
;	O
while	O
(	O
ISSPACE	O
(	O
*	O
where	pointer
)	O
)	O
{	O
where	pointer
++	O
;	O
if	O
(	O
--	O
digs	pointer
<=	O
0	int
)	O
return	O
-	O
1	int
;	O
}	O
value	int
=	O
0	int
;	O
while	O
(	O
digs	pointer
>	O
0	int
&&	O
ISODIGIT	O
(	O
*	O
where	pointer
)	O
)	O
{	O
value	int
=	O
(	O
value	int
<<	O
3	int
)	O
|	O
(	O
*	O
where	pointer
++	O
-	O
'0'	O
)	O
;	O
--	O
digs	pointer
;	O
}	O
if	O
(	O
digs	pointer
>	O
0	int
&&	O
*	O
where	pointer
&&	O
!	O
ISSPACE	O
(	O
*	O
where	pointer
)	O
)	O
return	O
-	O
1	int
;	O
return	O
value	int
;	O
}	O
void	O
taru_to_oct	function
(	O
register	O
long	O
value	int
,	O
register	O
int	O
digits	int
,	O
register	O
char	O
*	O
where	pointer
)	O
{	O
--	O
digits	int
;	O
where	pointer
[	O
--	O
digits	int
]	O
=	O
' '	O
;	O
do	O
{	O
where	pointer
[	O
--	O
digits	int
]	O
=	O
'0'	O
+	O
(	O
char	O
)	O
(	O
value	int
&	O
7	int
)	O
;	O
value	int
>>=	O
3	int
;	O
}	O
while	O
(	O
digits	int
>	O
0	int
&&	O
value	int
!=	O
0	int
)	O
;	O
while	O
(	O
digits	int
>	O
0	int
)	O
where	pointer
[	O
--	O
digits	int
]	O
=	O
' '	O
;	O
}	O
int	O
taru_datoul	function
(	O
char	O
*	O
s	pointer
,	O
unsigned	O
long	O
*	O
n	long
)	O
{	O
unsigned	O
long	O
oldval	long
=	O
0	int
;	O
unsigned	O
long	O
val	array
=	O
0	int
;	O
while	O
(	O
*	O
s	pointer
==	O
' '	O
)	O
++	O
s	pointer
;	O
while	O
(	O
*	O
s	pointer
>=	O
'0'	O
&&	O
*	O
s	pointer
<=	O
'9'	O
&&	O
val	array
>=	O
oldval	long
)	O
{	O
oldval	long
=	O
val	array
;	O
val	array
=	O
10	int
*	O
val	array
+	O
*	O
s	pointer
++	O
-	O
'0'	O
;	O
}	O
if	O
(	O
oldval	long
&&	O
(	O
(	O
val	array
/	O
oldval	long
)	O
<	O
10	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s, taru_datoul : conversion overflow\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
return	O
2	int
;	O
}	O
while	O
(	O
*	O
s	pointer
==	O
' '	O
)	O
++	O
s	pointer
;	O
*	O
n	long
=	O
val	array
;	O
return	O
(	O
!	O
(	O
*	O
s	pointer
==	O
'\0'	O
)	O
)	O
;	O
}	O
int	O
taru_otoul	function
(	O
char	O
*	O
s	pointer
,	O
unsigned	O
long	O
*	O
n	long
)	O
{	O
unsigned	O
long	O
val	array
=	O
0	int
;	O
while	O
(	O
*	O
s	pointer
==	O
' '	O
)	O
++	O
s	pointer
;	O
while	O
(	O
*	O
s	pointer
>=	O
'0'	O
&&	O
*	O
s	pointer
<=	O
'7'	O
)	O
val	array
=	O
8	int
*	O
val	array
+	O
*	O
s	pointer
++	O
-	O
'0'	O
;	O
while	O
(	O
*	O
s	pointer
==	O
' '	O
)	O
++	O
s	pointer
;	O
*	O
n	long
=	O
val	array
;	O
return	O
*	O
s	pointer
==	O
'\0'	O
;	O
}	O
int	O
taru_otoumax	function
(	O
char	O
*	O
s	pointer
,	O
uintmax_t	long
*	O
n	long
)	O
{	O
uintmax_t	long
val	array
=	O
0	int
;	O
while	O
(	O
*	O
s	pointer
==	O
' '	O
)	O
++	O
s	pointer
;	O
while	O
(	O
*	O
s	pointer
>=	O
'0'	O
&&	O
*	O
s	pointer
<=	O
'7'	O
)	O
val	array
=	O
8	int
*	O
val	array
+	O
*	O
s	pointer
++	O
-	O
'0'	O
;	O
while	O
(	O
*	O
s	pointer
==	O
' '	O
)	O
++	O
s	pointer
;	O
*	O
n	long
=	O
val	array
;	O
return	O
*	O
s	pointer
==	O
'\0'	O
;	O
}	O
int	O
taru_tarheader_check	function
(	O
char	O
*	O
buffer	array
)	O
{	O
unsigned	O
long	O
sumis	long
,	O
sum	long
;	O
if	O
(	O
strncmp	function
(	O
buffer	array
+	O
257	int
,	O
TMAGIC	pointer
,	O
5	int
)	O
)	O
{	O
return	O
1	int
;	O
}	O
sumis	long
=	O
(	O
unsigned	O
long	O
)	O
taru_from_oct	function
(	O
8	int
,	O
buffer	array
+	O
148	int
)	O
;	O
sum	long
=	O
taru_tar_checksum	function
(	O
(	O
void	O
*	O
)	O
buffer	array
)	O
;	O
if	O
(	O
sum	long
!=	O
sumis	long
)	O
{	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
unsigned	O
long	O
taru_tar_checksum	function
(	O
void	O
*	O
hdr	pointer
)	O
{	O
struct	O
tar_header	struct
*	O
tar_hdr	pointer
=	O
(	O
struct	O
tar_header	struct
*	O
)	O
(	O
hdr	pointer
)	O
;	O
unsigned	O
long	O
sum	long
=	O
0	int
;	O
char	O
*	O
p	pointer
=	O
(	O
char	O
*	O
)	O
tar_hdr	pointer
;	O
char	O
*	O
q	pointer
=	O
p	pointer
+	O
TARRECORDSIZE	int
;	O
int	O
i	int
;	O
while	O
(	O
p	pointer
<	O
tar_hdr	pointer
->	O
chksum	array
)	O
sum	long
+=	O
*	O
p	pointer
++	O
&	O
0xff	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
8	int
;	O
++	O
i	int
)	O
{	O
sum	long
+=	O
' '	O
;	O
++	O
p	pointer
;	O
}	O
while	O
(	O
p	pointer
<	O
q	pointer
)	O
sum	long
+=	O
*	O
p	pointer
++	O
&	O
0xff	int
;	O
return	O
sum	long
;	O
}	O
int	O
taru_tape_skip_padding	function
(	O
int	O
in_file_des	int
,	O
uintmax_t	long
offset	long
,	O
enum	O
archive_format	enum
archive_format_in	enum
)	O
{	O
int	O
pad	int
;	O
if	O
(	O
archive_format_in	enum
==	O
arf_crcascii	int
||	O
archive_format_in	enum
==	O
arf_newascii	int
)	O
pad	int
=	O
(	O
4	int
-	O
(	O
offset	long
%	O
4	int
)	O
)	O
%	O
4	int
;	O
else	O
if	O
(	O
archive_format_in	enum
==	O
arf_binary	int
||	O
archive_format_in	enum
==	O
arf_hpbinary	int
)	O
pad	int
=	O
(	O
2	int
-	O
(	O
offset	long
%	O
2	int
)	O
)	O
%	O
2	int
;	O
else	O
if	O
(	O
archive_format_in	enum
==	O
arf_tar	int
||	O
archive_format_in	enum
==	O
arf_ustar	int
)	O
pad	int
=	O
(	O
512	int
-	O
(	O
offset	long
%	O
512	int
)	O
)	O
%	O
512	int
;	O
else	O
pad	int
=	O
0	int
;	O
if	O
(	O
pad	int
!=	O
0	int
)	O
{	O
if	O
(	O
in_file_des	int
<	O
0	int
)	O
{	O
return	O
pad	int
;	O
}	O
else	O
{	O
return	O
taru_read_amount	function
(	O
in_file_des	int
,	O
pad	int
)	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
