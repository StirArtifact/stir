int	O
init_wb	function
(	O
int	O
max_num_ents_cnt	int
,	O
int	O
max_num_buks	int
,	O
int	O
max_blk_size	int
)	O
{	O
if	O
(	O
!	O
(	O
0xc	int
<=	O
(	O
max_num_ents_cnt	int
)	O
)	O
)	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< %s: %s (%d) must be %d or greater.\n"	pointer
,	O
"init_wb"	pointer
,	O
"max_num_ents_cnt"	pointer
,	O
max_num_ents_cnt	int
,	O
0xc	int
)	O
)	O
;	O
return	O
argerr	O
;	O
}	O
else	O
if	O
(	O
!	O
(	O
0xc	int
<=	O
(	O
max_num_buks	int
)	O
)	O
)	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< %s: %s (%d) must be %d or greater.\n"	pointer
,	O
"init_wb"	pointer
,	O
"max_num_buks"	pointer
,	O
max_num_buks	int
,	O
0xc	int
)	O
)	O
;	O
return	O
argerr	O
;	O
}	O
else	O
if	O
(	O
!	O
(	O
0x80	int
<=	O
(	O
max_blk_size	int
)	O
)	O
)	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< %s: %s (%d) must be %d or greater.\n"	pointer
,	O
"init_wb"	pointer
,	O
"max_blk_size"	pointer
,	O
max_blk_size	int
,	O
0x80	int
)	O
)	O
;	O
return	O
argerr	O
;	O
}	O
else	O
if	O
(	O
(	O
lck	function
(	O
seg_chain_lck	pointer
)	O
,	O
try_lck_P	function
(	O
seg_chain_lck	pointer
)	O
)	O
)	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< %s: lck (mutex) is not self-blocking!\n"	pointer
,	O
"init_wb"	pointer
)	O
)	O
;	O
return	O
strangerr	O
;	O
}	O
else	O
if	O
(	O
!	O
(	O
lck_tab	pointer
)	O
)	O
{	O
blkio_init	function
(	O
)	O
;	O
clear_stats	function
(	O
)	O
;	O
seg_cntr	int
=	O
4	int
;	O
num_buks	int
=	O
max_num_buks	int
;	O
blk_size	int
=	O
max_blk_size	int
;	O
free_buk_cntr	int
=	O
0	int
;	O
flush_ent_cntr	int
=	O
0	int
;	O
buk_tab	pointer
=	O
calloc	function
(	O
num_buks	int
,	O
(	O
sizeof	O
(	O
void	O
*	O
)	O
)	O
)	O
;	O
lck_tab	pointer
=	O
calloc	function
(	O
num_buks	int
,	O
(	O
sizeof	O
(	O
void	O
*	O
)	O
)	O
)	O
;	O
ent_tab	pointer
=	O
calloc	function
(	O
ent_tab_inc	int
,	O
(	O
sizeof	O
(	O
void	O
*	O
)	O
)	O
)	O
;	O
{	O
int	O
i	int
=	O
num_buks	int
;	O
while	O
(	O
i	int
)	O
{	O
lck_tab	pointer
[	O
(	O
i	int
)	O
-	O
1	int
]	O
=	O
make_lck	function
(	O
(	O
i	int
)	O
-	O
1	int
)	O
;	O
{	O
i	int
=	O
(	O
i	int
)	O
-	O
1	int
;	O
}	O
}	O
}	O
lck	function
(	O
free_ent_lck	pointer
)	O
;	O
{	O
int	O
i	int
=	O
max_num_ents_cnt	int
;	O
ENTRY	struct
*	O
bent	pointer
=	O
0	int
;	O
while	O
(	O
i	int
)	O
{	O
{	O
ENTRY	struct
*	O
newent	pointer
=	O
ent_make_ent	function
(	O
num_ents_ct	long
)	O
;	O
if	O
(	O
newent	pointer
)	O
{	O
ent_set_next	O
(	O
newent	pointer
,	O
bent	pointer
)	O
;	O
bent	pointer
=	O
newent	pointer
;	O
ent_tab	pointer
[	O
num_ents_ct	long
]	O
=	O
newent	pointer
;	O
ent_set_tag	O
(	O
newent	pointer
,	O
num_ents_ct	long
)	O
;	O
num_ents_ct	long
=	O
0x1L	int
+	O
(	O
num_ents_ct	long
)	O
;	O
if	O
(	O
!	O
(	O
(	O
num_ents_ct	long
)	O
%	O
(	O
ent_tab_inc	int
)	O
)	O
)	O
{	O
ENTRY	struct
*	O
*	O
tmp_ent_tab	pointer
=	O
realloc	function
(	O
ent_tab	pointer
,	O
(	O
(	O
ent_tab_inc	int
)	O
+	O
(	O
num_ents_ct	long
)	O
)	O
*	O
(	O
sizeof	O
(	O
void	O
*	O
)	O
)	O
)	O
;	O
if	O
(	O
tmp_ent_tab	pointer
)	O
{	O
ent_tab	pointer
=	O
tmp_ent_tab	pointer
;	O
}	O
else	O
i	int
=	O
1	int
;	O
}	O
}	O
else	O
i	int
=	O
1	int
;	O
}	O
{	O
i	int
=	O
(	O
i	int
)	O
-	O
1	int
;	O
}	O
}	O
free_ents	pointer
=	O
bent	pointer
;	O
}	O
unlck	function
(	O
free_ent_lck	pointer
)	O
;	O
unlck	function
(	O
seg_chain_lck	pointer
)	O
;	O
return	O
num_ents_ct	long
;	O
}	O
else	O
if	O
(	O
(	O
max_blk_size	int
)	O
>	O
(	O
blk_size	int
)	O
)	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< %s: already initialized with smaller blk-size: %d>%d\n"	pointer
,	O
"init_wb"	pointer
,	O
max_blk_size	int
,	O
blk_size	int
)	O
)	O
;	O
unlck	function
(	O
seg_chain_lck	pointer
)	O
;	O
return	O
argerr	O
;	O
}	O
else	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
"%s: already initialized\n"	pointer
,	O
"init_wb"	pointer
)	O
)	O
;	O
unlck	function
(	O
seg_chain_lck	pointer
)	O
;	O
return	O
notpres	O
;	O
}	O
}	O
int	O
final_wb	function
(	O
void	O
)	O
{	O
if	O
(	O
lck_tab	pointer
)	O
{	O
{	O
SEGD	struct
*	O
seg	pointer
=	O
seg_chain	pointer
;	O
while	O
(	O
seg	pointer
)	O
{	O
lck	function
(	O
seg_chain_lck	pointer
)	O
;	O
close_seg	function
(	O
seg	pointer
,	O
!	O
0	int
)	O
;	O
unlck	function
(	O
seg_chain_lck	pointer
)	O
;	O
{	O
seg	pointer
=	O
seg_chain	pointer
;	O
}	O
}	O
}	O
{	O
int	O
i	int
=	O
num_ents_ct	long
;	O
while	O
(	O
i	int
)	O
{	O
free	function
(	O
ent_tab	pointer
[	O
-	O
1	int
+	O
(	O
i	int
)	O
]	O
)	O
;	O
ent_tab	pointer
[	O
-	O
1	int
+	O
(	O
i	int
)	O
]	O
=	O
0	int
;	O
num_ents_ct	long
=	O
-	O
1	int
+	O
(	O
num_ents_ct	long
)	O
;	O
{	O
i	int
=	O
(	O
i	int
)	O
-	O
1	int
;	O
}	O
}	O
}	O
{	O
int	O
i	int
=	O
num_buks	int
;	O
while	O
(	O
i	int
)	O
{	O
free	function
(	O
lck_tab	pointer
[	O
(	O
i	int
)	O
-	O
1	int
]	O
)	O
;	O
lck_tab	pointer
[	O
(	O
i	int
)	O
-	O
1	int
]	O
=	O
0	int
;	O
{	O
i	int
=	O
(	O
i	int
)	O
-	O
1	int
;	O
}	O
}	O
}	O
free	function
(	O
ent_tab	pointer
)	O
;	O
ent_tab	pointer
=	O
0	int
;	O
free	function
(	O
lck_tab	pointer
)	O
;	O
lck_tab	pointer
=	O
0	int
;	O
free	function
(	O
buk_tab	pointer
)	O
;	O
buk_tab	pointer
=	O
0	int
;	O
blkio_final	function
(	O
)	O
;	O
return	O
success	int
;	O
}	O
else	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
"%s: already finaled\n"	pointer
,	O
"final_wb"	pointer
)	O
)	O
;	O
blkio_final	function
(	O
)	O
;	O
return	O
success	int
;	O
}	O
}	O
int	O
seg_cntr	int
=	O
4	int
;	O
SEGD	struct
*	O
seg_chain	pointer
=	O
0	int
;	O
LCK	struct
seg_chain_lock	struct
=	O
{	O
0	int
,	O
-	O
3	int
,	O
PTHREAD_MUTEX_INITIALIZER	O
}	O
;	O
LCK	struct
*	O
seg_chain_lck	pointer
=	O
&	O
seg_chain_lock	struct
;	O
SEGD	struct
*	O
new_seg	function
(	O
unsigned	O
char	O
*	O
filename	pointer
,	O
char	O
*	O
caller	pointer
)	O
{	O
if	O
(	O
lck_tab	pointer
)	O
{	O
lck	function
(	O
seg_chain_lck	pointer
)	O
;	O
{	O
SEGD	struct
*	O
sseg	pointer
=	O
seg_chain	pointer
;	O
L_loop	O
:	O
{	O
if	O
(	O
!	O
(	O
sseg	pointer
)	O
)	O
goto	O
L_make_it	O
;	O
else	O
if	O
(	O
(	O
seg_str	O
(	O
sseg	pointer
)	O
)	O
&&	O
(	O
!	O
strcmp	function
(	O
(	O
filename	pointer
)	O
,	O
(	O
seg_str	O
(	O
sseg	pointer
)	O
)	O
)	O
)	O
)	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< %s: segment already open to \"%s\"\n"	pointer
,	O
caller	pointer
,	O
filename	pointer
)	O
)	O
;	O
unlck	function
(	O
seg_chain_lck	pointer
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
(	O
seg_chain	pointer
)	O
==	O
(	O
seg_nxt	O
(	O
sseg	pointer
)	O
)	O
)	O
goto	O
L_make_it	O
;	O
else	O
{	O
sseg	pointer
=	O
seg_nxt	O
(	O
sseg	pointer
)	O
;	O
goto	O
L_loop	O
;	O
}	O
L_make_it	O
:	O
{	O
SEGD	struct
*	O
seg	pointer
=	O
new_segd	function
(	O
seg_cntr	int
)	O
;	O
seg_set_str	O
(	O
seg	pointer
,	O
strdup	function
(	O
filename	pointer
)	O
)	O
;	O
if	O
(	O
seg_chain	pointer
)	O
{	O
SEGD	struct
*	O
prev_seg	pointer
=	O
seg_prv	O
(	O
seg_chain	pointer
)	O
;	O
seg_set_nxt	O
(	O
prev_seg	pointer
,	O
seg	pointer
)	O
;	O
seg_set_prv	O
(	O
seg	pointer
,	O
prev_seg	pointer
)	O
;	O
seg_set_nxt	O
(	O
seg	pointer
,	O
seg_chain	pointer
)	O
;	O
seg_set_prv	O
(	O
seg_chain	pointer
,	O
seg	pointer
)	O
;	O
}	O
else	O
{	O
seg_set_nxt	O
(	O
seg	pointer
,	O
seg	pointer
)	O
;	O
seg_set_prv	O
(	O
seg	pointer
,	O
seg	pointer
)	O
;	O
}	O
seg_set_flc	O
(	O
seg	pointer
,	O
calloc	function
(	O
flc_len	int
,	O
(	O
sizeof	O
(	O
void	O
*	O
)	O
)	O
)	O
)	O
;	O
seg_set_flc_len	O
(	O
seg	pointer
,	O
0	int
)	O
;	O
seg_cntr	int
=	O
1	int
+	O
(	O
seg_cntr	int
)	O
;	O
seg_chain	pointer
=	O
seg	pointer
;	O
unlck	function
(	O
seg_chain_lck	pointer
)	O
;	O
return	O
seg	pointer
;	O
}	O
}	O
}	O
}	O
else	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< %s: WB not initialized (need to call %s)\n"	pointer
,	O
caller	pointer
,	O
"init_wb"	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
void	O
free_seg	function
(	O
SEGD	struct
*	O
seg	pointer
)	O
{	O
seg_set_port	O
(	O
seg	pointer
,	O
0	int
)	O
;	O
free	function
(	O
seg_str	O
(	O
seg	pointer
)	O
)	O
;	O
seg_set_str	O
(	O
seg	pointer
,	O
0	int
)	O
;	O
free	function
(	O
seg_flc	O
(	O
seg	pointer
)	O
)	O
;	O
seg_set_flc	O
(	O
seg	pointer
,	O
0	int
)	O
;	O
seg_set_flc_len	O
(	O
seg	pointer
,	O
0	int
)	O
;	O
seg_set_used	O
(	O
seg	pointer
,	O
0	int
)	O
;	O
if	O
(	O
!	O
(	O
seg_chain	pointer
)	O
)	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< %s: %s already empty!\n"	pointer
,	O
"free_seg"	pointer
,	O
"seg_chain"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
else	O
if	O
(	O
(	O
seg_prv	O
(	O
seg	pointer
)	O
)	O
==	O
(	O
seg	pointer
)	O
)	O
{	O
if	O
(	O
(	O
seg	pointer
)	O
!=	O
(	O
seg_chain	pointer
)	O
)	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< %s: corrupted %s.\n"	pointer
,	O
"free_seg"	pointer
,	O
"seg_chain"	pointer
)	O
)	O
;	O
seg_chain	pointer
=	O
0	int
;	O
return	O
;	O
}	O
else	O
{	O
SEGD	struct
*	O
next_seg	pointer
=	O
seg_nxt	O
(	O
seg	pointer
)	O
;	O
SEGD	struct
*	O
prev_seg	pointer
=	O
seg_prv	O
(	O
seg	pointer
)	O
;	O
seg_set_nxt	O
(	O
prev_seg	pointer
,	O
next_seg	pointer
)	O
;	O
seg_set_prv	O
(	O
next_seg	pointer
,	O
prev_seg	pointer
)	O
;	O
if	O
(	O
(	O
seg	pointer
)	O
==	O
(	O
seg_chain	pointer
)	O
)	O
seg_chain	pointer
=	O
(	O
(	O
seg_chain	pointer
)	O
==	O
(	O
next_seg	pointer
)	O
?	O
0	int
:	O
next_seg	pointer
)	O
;	O
return	O
;	O
}	O
}	O
int	O
check_file_P	function
(	O
unsigned	O
char	O
*	O
filename	pointer
)	O
{	O
int	O
file	int
=	O
blkio_open_read_only_file	function
(	O
filename	pointer
,	O
0x80	int
)	O
;	O
unsigned	O
char	O
tblk	array
[	O
0x80	int
]	O
;	O
if	O
(	O
file	int
)	O
{	O
int	O
allok_P	int
=	O
(	O
blkio_read	function
(	O
file	int
,	O
tblk	array
,	O
0x80	int
,	O
0	int
)	O
)	O
&&	O
(	O
!	O
(	O
str2long	function
(	O
tblk	array
,	O
0	int
)	O
)	O
)	O
&&	O
(	O
!	O
(	O
str2long	function
(	O
tblk	array
,	O
4	int
)	O
)	O
)	O
&&	O
(	O
!	O
(	O
str2long	function
(	O
tblk	array
,	O
8	int
)	O
)	O
)	O
&&	O
(	O
0x77	int
==	O
(	O
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
tblk	array
)	O
)	O
[	O
0x17	int
]	O
)	O
)	O
)	O
&&	O
(	O
0x62	int
==	O
(	O
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
tblk	array
)	O
)	O
[	O
0x18	int
]	O
)	O
)	O
)	O
;	O
blkio_file_close	function
(	O
file	int
,	O
0x80	int
,	O
!	O
(	O
!	O
0	int
)	O
)	O
;	O
return	O
allok_P	int
;	O
}	O
else	O
return	O
0	int
;	O
}	O
SEGD	struct
*	O
open_seg	function
(	O
unsigned	O
char	O
*	O
filename	pointer
,	O
int	O
mutable_P	int
)	O
{	O
return	O
open_segd	function
(	O
filename	pointer
,	O
mutable_P	int
,	O
!	O
(	O
!	O
0	int
)	O
)	O
;	O
}	O
SEGD	struct
*	O
open_segd	function
(	O
unsigned	O
char	O
*	O
filename	pointer
,	O
int	O
mutable_P	int
,	O
int	O
even_if_dirty_P	int
)	O
{	O
int	O
bsiz	int
=	O
3	int
*	O
0x80	int
;	O
if	O
(	O
(	O
bsiz	int
)	O
>	O
(	O
blk_size	int
)	O
)	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< unsupported %s %d > %d\n"	pointer
,	O
"bsiz"	pointer
,	O
bsiz	int
,	O
blk_size	int
)	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
!	O
(	O
check_file_P	function
(	O
filename	pointer
)	O
)	O
)	O
return	O
0	int
;	O
else	O
{	O
SEGD	struct
*	O
seg	pointer
=	O
new_seg	function
(	O
filename	pointer
,	O
"open_seg"	pointer
)	O
;	O
char	O
*	O
reason	pointer
;	O
if	O
(	O
!	O
(	O
seg	pointer
)	O
)	O
return	O
seg	pointer
;	O
else	O
{	O
int	O
file	int
=	O
mutable_P	int
?	O
blkio_open_modify_file	function
(	O
filename	pointer
,	O
bsiz	int
)	O
:	O
blkio_open_read_only_file	function
(	O
filename	pointer
,	O
bsiz	int
)	O
;	O
L_loop	O
:	O
if	O
(	O
blkio_port_open_P	function
(	O
file	int
,	O
mutable_P	int
)	O
)	O
{	O
seg_set_port	O
(	O
seg	pointer
,	O
file	int
)	O
;	O
seg_set_bsiz	O
(	O
seg	pointer
,	O
bsiz	int
)	O
;	O
seg_set_used	O
(	O
seg	pointer
,	O
2	int
)	O
;	O
seg_set_flc_len	O
(	O
seg	pointer
,	O
(	O
mutable_P	int
?	O
-	O
1	int
:	O
-	O
2	int
)	O
)	O
;	O
{	O
HAND	struct
*	O
han	pointer
=	O
seg_rt_han	O
(	O
seg	pointer
)	O
;	O
unsigned	O
char	O
tmp_str	array
[	O
0x100	int
]	O
;	O
if	O
(	O
err_P	O
(	O
bt_open	function
(	O
seg	pointer
,	O
0	int
,	O
han	pointer
,	O
(	O
wcb_sap	int
)	O
+	O
(	O
wcb_sar	int
)	O
)	O
)	O
)	O
{	O
reason	pointer
=	O
"bt-open 0"	pointer
;	O
goto	O
L_errout	O
;	O
}	O
else	O
if	O
(	O
2	int
!=	O
(	O
bt_get	function
(	O
han	pointer
,	O
bsiz_byts	pointer
,	O
4	int
,	O
tmp_str	array
)	O
)	O
)	O
{	O
reason	pointer
=	O
"BSIZ"	pointer
;	O
goto	O
L_errout	O
;	O
}	O
else	O
if	O
(	O
(	O
bsiz	int
)	O
!=	O
(	O
str2short	function
(	O
tmp_str	array
,	O
0	int
)	O
)	O
)	O
{	O
blkio_file_close	function
(	O
file	int
,	O
bsiz	int
,	O
mutable_P	int
)	O
;	O
bsiz	int
=	O
str2short	function
(	O
tmp_str	array
,	O
0	int
)	O
;	O
if	O
(	O
(	O
bsiz	int
)	O
>	O
(	O
blk_size	int
)	O
)	O
{	O
reason	pointer
=	O
"BSIZ too big."	pointer
;	O
goto	O
L_errout	O
;	O
}	O
else	O
{	O
file	int
=	O
mutable_P	int
?	O
blkio_open_modify_file	function
(	O
filename	pointer
,	O
bsiz	int
)	O
:	O
blkio_open_read_only_file	function
(	O
filename	pointer
,	O
bsiz	int
)	O
;	O
goto	O
L_loop	O
;	O
}	O
}	O
else	O
{	O
int	O
dty_P	int
=	O
(	O
mutable_P	int
)	O
&&	O
(	O
err_P	O
(	O
bt_rem	function
(	O
han	pointer
,	O
cln_byts	pointer
,	O
3	int
,	O
tmp_str	array
)	O
)	O
)	O
;	O
if	O
(	O
(	O
dty_P	int
)	O
&&	O
(	O
!	O
(	O
even_if_dirty_P	int
)	O
)	O
)	O
{	O
reason	pointer
=	O
"not cleanly saved; use wbcheck to repair."	pointer
;	O
goto	O
L_errout	O
;	O
}	O
else	O
{	O
if	O
(	O
dty_P	int
)	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
"WARNING: File \"%s\" not cleanly saved.\n"	pointer
,	O
filename	pointer
)	O
)	O
;	O
if	O
(	O
4	int
!=	O
(	O
bt_get	function
(	O
han	pointer
,	O
used_byts	pointer
,	O
4	int
,	O
tmp_str	array
)	O
)	O
)	O
{	O
reason	pointer
=	O
"USED"	pointer
;	O
goto	O
L_errout	O
;	O
}	O
else	O
{	O
seg_set_used	O
(	O
seg	pointer
,	O
str2long	function
(	O
tmp_str	array
,	O
0	int
)	O
)	O
;	O
if	O
(	O
5	int
!=	O
(	O
bt_get	function
(	O
han	pointer
,	O
fld_byts	pointer
,	O
3	int
,	O
tmp_str	array
)	O
)	O
)	O
{	O
reason	pointer
=	O
"FLD"	pointer
;	O
goto	O
L_errout	O
;	O
}	O
else	O
if	O
(	O
err_P	O
(	O
bt_open	function
(	O
seg	pointer
,	O
str2long	function
(	O
tmp_str	array
,	O
1	int
)	O
,	O
seg_fl_han	O
(	O
seg	pointer
)	O
,	O
wcb_sar	int
)	O
)	O
)	O
{	O
reason	pointer
=	O
"FLC"	pointer
;	O
goto	O
L_errout	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
han_typ	O
(	O
seg_fl_han	O
(	O
seg	pointer
)	O
)	O
)	O
!=	O
(	O
frl_typ	int
)	O
)	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
"Older type freelist - still supported.\n"	pointer
)	O
)	O
;	O
han_set_wcb	O
(	O
seg_fl_han	O
(	O
seg	pointer
)	O
,	O
wcb_sar	int
)	O
;	O
return	O
seg	pointer
;	O
}	O
}	O
}	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
blkio_port_open_P	function
(	O
file	int
,	O
mutable_P	int
)	O
)	O
blkio_file_close	function
(	O
file	int
,	O
bsiz	int
,	O
mutable_P	int
)	O
;	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< could not open file %s\n"	pointer
,	O
filename	pointer
)	O
)	O
;	O
free_seg	function
(	O
seg	pointer
)	O
;	O
return	O
0	int
;	O
}	O
}	O
L_errout	O
:	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< File \"%s\" %s\n"	pointer
,	O
filename	pointer
,	O
reason	pointer
)	O
)	O
;	O
if	O
(	O
seg	pointer
)	O
{	O
blkio_file_close	function
(	O
seg_port	O
(	O
seg	pointer
)	O
,	O
bsiz	int
,	O
mutable_P	int
)	O
;	O
free_seg	function
(	O
seg	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
}	O
int	O
close_seg	function
(	O
SEGD	struct
*	O
seg	pointer
,	O
int	O
hammer_P	int
)	O
{	O
if	O
(	O
(	O
!	O
(	O
seg	pointer
)	O
)	O
||	O
(	O
!	O
(	O
seg_port	O
(	O
seg	pointer
)	O
)	O
)	O
||	O
(	O
!	O
(	O
seg_str	O
(	O
seg	pointer
)	O
)	O
)	O
||	O
(	O
!	O
(	O
seg_used	O
(	O
seg	pointer
)	O
)	O
)	O
)	O
return	O
notpres	O
;	O
else	O
{	O
flush_flc	function
(	O
seg	pointer
,	O
5	int
)	O
;	O
if	O
(	O
(	O
seg_flc_len	O
(	O
seg	pointer
)	O
)	O
>=	O
0	int
)	O
{	O
unsigned	O
char	O
tmp_str	array
[	O
0x14	int
]	O
;	O
{	O
int	O
i	int
=	O
-	O
1	int
+	O
(	O
seg_flc_len	O
(	O
seg	pointer
)	O
)	O
;	O
while	O
(	O
!	O
(	O
0	int
>	O
(	O
i	int
)	O
)	O
)	O
{	O
long2str	function
(	O
tmp_str	array
,	O
4	int
*	O
(	O
i	int
)	O
,	O
seg_flc	O
(	O
seg	pointer
)	O
[	O
i	int
]	O
)	O
;	O
{	O
i	int
=	O
-	O
1	int
+	O
(	O
i	int
)	O
;	O
}	O
}	O
}	O
bt_put	function
(	O
seg_rt_han	O
(	O
seg	pointer
)	O
,	O
flc_byts	pointer
,	O
3	int
,	O
tmp_str	array
,	O
4	int
*	O
(	O
seg_flc_len	O
(	O
seg	pointer
)	O
)	O
)	O
;	O
seg_set_flc_len	O
(	O
seg	pointer
,	O
-	O
1	int
)	O
;	O
}	O
{	O
int	O
mutable_P	int
=	O
seg_mutable_P	O
(	O
seg	pointer
)	O
;	O
int	O
ans	int
=	O
do_seg_buffers	function
(	O
seg	pointer
,	O
flush_buffer	function
)	O
;	O
if	O
(	O
(	O
success_P	O
(	O
ans	int
)	O
)	O
||	O
(	O
hammer_P	int
)	O
)	O
{	O
if	O
(	O
!	O
(	O
success_P	O
(	O
ans	int
)	O
)	O
)	O
ans	int
=	O
notpres	O
;	O
do_seg_buffers	function
(	O
seg	pointer
,	O
purge_buffer	function
)	O
;	O
if	O
(	O
mutable_P	int
)	O
{	O
blkio_flush_to_file	function
(	O
seg_port	O
(	O
seg	pointer
)	O
,	O
!	O
(	O
!	O
0	int
)	O
)	O
;	O
if	O
(	O
err_P	O
(	O
bt_write	function
(	O
seg_rt_han	O
(	O
seg	pointer
)	O
,	O
cln_byts	pointer
,	O
3	int
,	O
no_byts	pointer
,	O
0	int
)	O
)	O
)	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
"WARNING: mutable file \"%s\" already clean?\n"	pointer
,	O
seg_str	O
(	O
seg	pointer
)	O
)	O
)	O
;	O
}	O
bt_close	function
(	O
seg_rt_han	O
(	O
seg	pointer
)	O
)	O
;	O
bt_close	function
(	O
seg_fl_han	O
(	O
seg	pointer
)	O
)	O
;	O
blkio_file_close	function
(	O
seg_port	O
(	O
seg	pointer
)	O
,	O
seg_bsiz	O
(	O
seg	pointer
)	O
,	O
mutable_P	int
)	O
;	O
free_seg	function
(	O
seg	pointer
)	O
;	O
}	O
return	O
ans	int
;	O
}	O
}	O
}	O
unsigned	O
char	O
db_version_str	array
[	O
]	O
=	O
"wb-2b3"	pointer
;	O
unsigned	O
char	O
db_authors_str	array
[	O
]	O
=	O
"A. Jaffer, J. Finger, R. Zito-Wolf"	pointer
;	O
SEGD	struct
*	O
make_seg	function
(	O
unsigned	O
char	O
*	O
filename	pointer
,	O
int	O
bsiz	int
)	O
{	O
SEGD	struct
*	O
seg	pointer
=	O
new_seg	function
(	O
filename	pointer
,	O
"make_seg"	pointer
)	O
;	O
if	O
(	O
!	O
(	O
seg	pointer
)	O
)	O
return	O
seg	pointer
;	O
else	O
if	O
(	O
(	O
bsiz	int
)	O
>	O
(	O
blk_size	int
)	O
)	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< unsupported %s %d > %d\n"	pointer
,	O
"bsiz"	pointer
,	O
bsiz	int
,	O
blk_size	int
)	O
)	O
;	O
unlck	function
(	O
seg_lck	O
(	O
seg	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
int	O
file	int
=	O
blkio_create_file	function
(	O
filename	pointer
,	O
bsiz	int
)	O
;	O
if	O
(	O
blkio_port_open_P	function
(	O
file	int
,	O
!	O
0	int
)	O
)	O
{	O
seg_set_port	O
(	O
seg	pointer
,	O
file	int
)	O
;	O
seg_set_bsiz	O
(	O
seg	pointer
,	O
bsiz	int
)	O
;	O
seg_set_used	O
(	O
seg	pointer
,	O
3	int
)	O
;	O
seg_set_str	O
(	O
seg	pointer
,	O
strdup	function
(	O
filename	pointer
)	O
)	O
;	O
seg_set_flc_len	O
(	O
seg	pointer
,	O
-	O
1	int
)	O
;	O
{	O
HAND	struct
*	O
rt_han	pointer
=	O
seg_rt_han	O
(	O
seg	pointer
)	O
;	O
HAND	struct
*	O
han	pointer
=	O
seg_fl_han	O
(	O
seg	pointer
)	O
;	O
unsigned	O
char	O
tmp_str	array
[	O
5	int
]	O
;	O
if	O
(	O
(	O
bt_open_new	function
(	O
seg	pointer
,	O
0	int
,	O
rt_han	pointer
,	O
(	O
wcb_sap	int
)	O
+	O
(	O
wcb_sar	int
)	O
,	O
dir_typ	int
)	O
)	O
&&	O
(	O
bt_open_new	function
(	O
seg	pointer
,	O
1	int
,	O
han	pointer
,	O
wcb_sap	int
,	O
dir_typ	int
)	O
)	O
&&	O
(	O
bt_open_new	function
(	O
seg	pointer
,	O
2	int
,	O
han	pointer
,	O
wcb_sar	int
,	O
frl_typ	int
)	O
)	O
)	O
{	O
bt_put	function
(	O
rt_han	pointer
,	O
no_byts	pointer
,	O
0	int
,	O
db_version_str	array
,	O
strlen	function
(	O
db_version_str	array
)	O
)	O
;	O
long2str	function
(	O
tmp_str	array
,	O
0	int
,	O
seg_used	O
(	O
seg	pointer
)	O
)	O
;	O
bt_put	function
(	O
rt_han	pointer
,	O
used_byts	pointer
,	O
4	int
,	O
tmp_str	array
,	O
4	int
)	O
;	O
short2str	function
(	O
tmp_str	array
,	O
0	int
,	O
seg_bsiz	O
(	O
seg	pointer
)	O
)	O
;	O
bt_put	function
(	O
rt_han	pointer
,	O
bsiz_byts	pointer
,	O
4	int
,	O
tmp_str	array
,	O
2	int
)	O
;	O
tmp_str	array
[	O
0	int
]	O
=	O
4	int
;	O
long2str	function
(	O
tmp_str	array
,	O
1	int
,	O
1	int
)	O
;	O
bt_put	function
(	O
rt_han	pointer
,	O
root_byts	pointer
,	O
4	int
,	O
tmp_str	array
,	O
5	int
)	O
;	O
long2str	function
(	O
tmp_str	array
,	O
1	int
,	O
2	int
)	O
;	O
bt_put	function
(	O
rt_han	pointer
,	O
fld_byts	pointer
,	O
3	int
,	O
tmp_str	array
,	O
5	int
)	O
;	O
bt_put	function
(	O
rt_han	pointer
,	O
flc_byts	pointer
,	O
3	int
,	O
no_byts	pointer
,	O
0	int
)	O
;	O
if	O
(	O
(	O
bsiz	int
)	O
>	O
0x80	int
)	O
bt_put	function
(	O
rt_han	pointer
,	O
authors_byts	pointer
,	O
7	int
,	O
db_authors_str	array
,	O
strlen	function
(	O
db_authors_str	array
)	O
)	O
;	O
return	O
seg	pointer
;	O
}	O
else	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< couldn't allocate ents for file %s\n"	pointer
,	O
filename	pointer
)	O
)	O
;	O
unlck	function
(	O
seg_lck	O
(	O
seg	pointer
)	O
)	O
;	O
close_seg	function
(	O
seg	pointer
,	O
!	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
}	O
}	O
else	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< couldn't create new file %s\n"	pointer
,	O
filename	pointer
)	O
)	O
;	O
unlck	function
(	O
seg_lck	O
(	O
seg	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
}	O
int	O
bt_open	function
(	O
SEGD	struct
*	O
seg	pointer
,	O
long	O
blk_num	long
,	O
HAND	struct
*	O
han	pointer
,	O
int	O
wcb	int
)	O
{	O
if	O
(	O
(	O
seg	pointer
)	O
&&	O
(	O
seg_str	O
(	O
seg	pointer
)	O
)	O
)	O
{	O
ENTRY	struct
*	O
ent	pointer
=	O
get_ent	function
(	O
seg	pointer
,	O
blk_num	long
,	O
accread	O
)	O
;	O
if	O
(	O
!	O
(	O
ent	pointer
)	O
)	O
return	O
argerr	O
;	O
else	O
if	O
(	O
!	O
(	O
root_P	O
(	O
ent_blk	O
(	O
ent	pointer
)	O
)	O
)	O
)	O
{	O
release_ent	function
(	O
ent	pointer
,	O
accread	O
)	O
;	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< %s: not a root %ld:%ld\n"	pointer
,	O
"bt_open"	pointer
,	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blk_num	long
)	O
)	O
;	O
return	O
argerr	O
;	O
}	O
else	O
{	O
bt_open_init_han	function
(	O
han	pointer
,	O
ent	pointer
,	O
wcb	int
)	O
;	O
release_ent	function
(	O
ent	pointer
,	O
accread	O
)	O
;	O
return	O
han_typ	O
(	O
han	pointer
)	O
;	O
}	O
}	O
else	O
return	O
argerr	O
;	O
}	O
void	O
bt_open_init_han	function
(	O
HAND	struct
*	O
han	pointer
,	O
ENTRY	struct
*	O
ent	pointer
,	O
int	O
wcb	int
)	O
{	O
int	O
typ	int
=	O
blk_typ	O
(	O
ent_blk	O
(	O
ent	pointer
)	O
)	O
;	O
SEGD	struct
*	O
seg	pointer
=	O
ent_seg	O
(	O
ent	pointer
)	O
;	O
long	O
blk_num	long
=	O
ent_id	O
(	O
ent	pointer
)	O
;	O
han_set_seg	O
(	O
han	pointer
,	O
seg	pointer
)	O
;	O
han_set_num	O
(	O
han	pointer
,	O
blk_num	long
)	O
;	O
han_set_last	O
(	O
han	pointer
,	O
blk_num	long
)	O
;	O
han_set_typ	O
(	O
han	pointer
,	O
typ	int
)	O
;	O
if	O
(	O
(	O
typ	int
)	O
==	O
(	O
dir_typ	int
)	O
)	O
wcb	int
=	O
(	O
wcb	int
)	O
|	O
(	O
(	O
wcb_sap	int
)	O
+	O
(	O
wcb_sar	int
)	O
)	O
;	O
han_set_wcb	O
(	O
han	pointer
,	O
wcb	int
)	O
;	O
return	O
;	O
}	O
int	O
bt_open_new	function
(	O
SEGD	struct
*	O
seg	pointer
,	O
long	O
blk_num	long
,	O
HAND	struct
*	O
han	pointer
,	O
int	O
wcb	int
,	O
int	O
typ	int
)	O
{	O
if	O
(	O
0	int
>	O
(	O
blk_num	long
)	O
)	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< negative block number %ld\n"	pointer
,	O
blk_num	long
)	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
ENTRY	struct
*	O
ent	pointer
=	O
try_get_free_ent	function
(	O
0	int
,	O
-	O
1	int
)	O
;	O
while	O
(	O
!	O
(	O
ent	pointer
)	O
)	O
{	O
{	O
ent	pointer
=	O
try_get_free_ent	function
(	O
0	int
,	O
-	O
1	int
)	O
;	O
}	O
}	O
init_leaf_blk	function
(	O
ent_blk	O
(	O
ent	pointer
)	O
,	O
blk_num	long
,	O
typ	int
)	O
;	O
blk_set_time	O
(	O
ent_blk	O
(	O
ent	pointer
)	O
,	O
time	function
(	O
0L	int
)	O
)	O
;	O
ent_set_next	O
(	O
ent	pointer
,	O
get_buk_wait	O
(	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blk_num	long
)	O
)	O
;	O
set_buk	O
(	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blk_num	long
,	O
ent	pointer
)	O
;	O
ent_set_acc	O
(	O
ent	pointer
,	O
accwrite	O
)	O
;	O
ent_set_seg	O
(	O
ent	pointer
,	O
seg	pointer
)	O
;	O
ent_set_id	O
(	O
ent	pointer
,	O
blk_num	long
)	O
;	O
ent_set_age	O
(	O
ent	pointer
,	O
-	O
127	int
)	O
;	O
ent_set_dty	O
(	O
ent	pointer
,	O
!	O
0	int
)	O
;	O
ent_set_pus	O
(	O
ent	pointer
,	O
0	int
)	O
;	O
ent_set_ref	O
(	O
ent	pointer
,	O
1	int
)	O
;	O
rel_buk	O
(	O
seg_id	O
(	O
seg	pointer
)	O
,	O
blk_num	long
)	O
;	O
bt_open_init_han	function
(	O
han	pointer
,	O
ent	pointer
,	O
wcb	int
)	O
;	O
ents_ent_write	function
(	O
ent	pointer
)	O
;	O
release_ent	function
(	O
ent	pointer
,	O
accwrite	O
)	O
;	O
return	O
!	O
0	int
;	O
}	O
}	O
int	O
bt_create	function
(	O
SEGD	struct
*	O
seg	pointer
,	O
int	O
typ	int
,	O
HAND	struct
*	O
han	pointer
,	O
int	O
wcb	int
)	O
{	O
if	O
(	O
(	O
seg	pointer
)	O
&&	O
(	O
han	pointer
)	O
)	O
{	O
ENTRY	struct
*	O
ent	pointer
=	O
create_new_blk_ent	function
(	O
seg	pointer
)	O
;	O
if	O
(	O
ent	pointer
)	O
{	O
long	O
blk_num	long
=	O
ent_id	O
(	O
ent	pointer
)	O
;	O
init_leaf_blk	function
(	O
ent_blk	O
(	O
ent	pointer
)	O
,	O
blk_num	long
,	O
typ	int
)	O
;	O
ent_set_pus	O
(	O
ent	pointer
,	O
0	int
)	O
;	O
bt_open_init_han	function
(	O
han	pointer
,	O
ent	pointer
,	O
wcb	int
)	O
;	O
ents_ent_write	function
(	O
ent	pointer
)	O
;	O
release_ent	function
(	O
ent	pointer
,	O
accwrite	O
)	O
;	O
return	O
success	int
;	O
}	O
else	O
return	O
noroom	O
;	O
}	O
else	O
return	O
argerr	O
;	O
}	O
int	O
bt_close	function
(	O
HAND	struct
*	O
han	pointer
)	O
{	O
if	O
(	O
han	pointer
)	O
{	O
han_set_seg	O
(	O
han	pointer
,	O
0	int
)	O
;	O
han_set_num	O
(	O
han	pointer
,	O
0	int
)	O
;	O
han_set_typ	O
(	O
han	pointer
,	O
0	int
)	O
;	O
han_set_last	O
(	O
han	pointer
,	O
0	int
)	O
;	O
return	O
success	int
;	O
}	O
else	O
return	O
argerr	O
;	O
}	O
