static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: db_iface.c,v 1.4 2014/04/17 20:27:26 sebdiaz Exp $"	pointer
;	O
static	O
int	O
__db_curinval	function
__P	O
(	O
(	O
const	O
DB_ENV	struct
*	O
)	O
)	O
;	O
static	O
int	O
__db_rdonly	function
__P	O
(	O
(	O
const	O
DB_ENV	struct
*	O
,	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
__dbt_ferr	function
__P	O
(	O
(	O
const	O
DB	struct
*	O
,	O
const	O
char	O
*	O
,	O
const	O
DBT	struct
*	O
,	O
int	O
)	O
)	O
;	O
int	O
CDB___db_cursorchk	function
(	O
dbp	pointer
,	O
flags	int
,	O
isrdonly	int
)	O
const	O
DB	struct
*	O
dbp	pointer
;	O
u_int32_t	int
flags	int
;	O
int	O
isrdonly	int
;	O
{	O
switch	O
(	O
flags	int
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
DB_WRITECURSOR	int
:	O
if	O
(	O
isrdonly	int
)	O
return	O
(	O
__db_rdonly	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"DB->cursor"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
LOCKING	O
(	O
dbp	pointer
->	O
dbenv	pointer
)	O
)	O
return	O
(	O
CDB___db_ferr	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"DB->cursor"	pointer
,	O
0	int
)	O
)	O
;	O
break	O
;	O
case	O
DB_WRITELOCK	int
:	O
if	O
(	O
isrdonly	int
)	O
return	O
(	O
__db_rdonly	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"DB->cursor"	pointer
)	O
)	O
;	O
break	O
;	O
default	O
:	O
return	O
(	O
CDB___db_ferr	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"DB->cursor"	pointer
,	O
0	int
)	O
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___db_ccountchk	function
(	O
dbp	pointer
,	O
flags	int
,	O
isvalid	int
)	O
const	O
DB	struct
*	O
dbp	pointer
;	O
u_int32_t	int
flags	int
;	O
int	O
isvalid	int
;	O
{	O
switch	O
(	O
flags	int
)	O
{	O
case	O
0	int
:	O
break	O
;	O
default	O
:	O
return	O
(	O
CDB___db_ferr	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"DBcursor->c_count"	pointer
,	O
0	int
)	O
)	O
;	O
}	O
return	O
(	O
isvalid	int
?	O
0	int
:	O
__db_curinval	function
(	O
dbp	pointer
->	O
dbenv	pointer
)	O
)	O
;	O
}	O
int	O
CDB___db_cdelchk	function
(	O
dbp	pointer
,	O
flags	int
,	O
isrdonly	int
,	O
isvalid	int
)	O
const	O
DB	struct
*	O
dbp	pointer
;	O
u_int32_t	int
flags	int
;	O
int	O
isrdonly	int
,	O
isvalid	int
;	O
{	O
if	O
(	O
isrdonly	int
)	O
return	O
(	O
__db_rdonly	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"c_del"	pointer
)	O
)	O
;	O
switch	O
(	O
flags	int
)	O
{	O
case	O
0	int
:	O
break	O
;	O
default	O
:	O
return	O
(	O
CDB___db_ferr	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"DBcursor->c_del"	pointer
,	O
0	int
)	O
)	O
;	O
}	O
return	O
(	O
isvalid	int
?	O
0	int
:	O
__db_curinval	function
(	O
dbp	pointer
->	O
dbenv	pointer
)	O
)	O
;	O
}	O
int	O
CDB___db_cgetchk	function
(	O
dbp	pointer
,	O
key	struct
,	O
data	pointer
,	O
flags	int
,	O
isvalid	int
)	O
const	O
DB	struct
*	O
dbp	pointer
;	O
DBT	struct
*	O
key	struct
,	O
*	O
data	pointer
;	O
u_int32_t	int
flags	int
;	O
int	O
isvalid	int
;	O
{	O
int	O
ret	int
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_RMW	int
)	O
)	O
{	O
if	O
(	O
!	O
LOCKING_ON	O
(	O
dbp	pointer
->	O
dbenv	pointer
)	O
)	O
{	O
CDB___db_err	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"the DB_RMW flag requires locking"	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
LF_CLR	O
(	O
DB_RMW	int
)	O
;	O
}	O
switch	O
(	O
flags	int
)	O
{	O
case	O
DB_CONSUME	int
:	O
if	O
(	O
dbp	pointer
->	O
type	enum
!=	O
DB_QUEUE	int
)	O
goto	O
err	pointer
;	O
break	O
;	O
case	O
DB_CURRENT	int
:	O
case	O
DB_FIRST	int
:	O
case	O
DB_LAST	int
:	O
case	O
DB_NEXT	int
:	O
case	O
DB_NEXT_DUP	int
:	O
case	O
DB_NEXT_NODUP	int
:	O
case	O
DB_PREV	int
:	O
case	O
DB_PREV_NODUP	int
:	O
break	O
;	O
case	O
DB_GET_BOTHC	int
:	O
if	O
(	O
dbp	pointer
->	O
type	enum
==	O
DB_QUEUE	int
)	O
goto	O
err	pointer
;	O
case	O
DB_GET_BOTH	int
:	O
case	O
DB_SET	int
:	O
case	O
DB_SET_RANGE	int
:	O
break	O
;	O
case	O
DB_GET_RECNO	int
:	O
if	O
(	O
!	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_BT_RECNUM	int
)	O
)	O
goto	O
err	pointer
;	O
break	O
;	O
case	O
DB_SET_RECNO	int
:	O
if	O
(	O
!	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_BT_RECNUM	int
)	O
)	O
goto	O
err	pointer
;	O
break	O
;	O
default	O
:	O
err	pointer
:	O
return	O
(	O
CDB___db_ferr	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"DBcursor->c_get"	pointer
,	O
0	int
)	O
)	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
__dbt_ferr	function
(	O
dbp	pointer
,	O
"key"	pointer
,	O
key	struct
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
__dbt_ferr	function
(	O
dbp	pointer
,	O
"data"	pointer
,	O
data	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
isvalid	int
||	O
(	O
flags	int
!=	O
DB_CURRENT	int
&&	O
flags	int
!=	O
DB_NEXT_DUP	int
)	O
)	O
return	O
(	O
0	int
)	O
;	O
return	O
(	O
__db_curinval	function
(	O
dbp	pointer
->	O
dbenv	pointer
)	O
)	O
;	O
}	O
int	O
CDB___db_cputchk	function
(	O
dbp	pointer
,	O
key	struct
,	O
data	pointer
,	O
flags	int
,	O
isrdonly	int
,	O
isvalid	int
)	O
const	O
DB	struct
*	O
dbp	pointer
;	O
const	O
DBT	struct
*	O
key	struct
;	O
DBT	struct
*	O
data	pointer
;	O
u_int32_t	int
flags	int
;	O
int	O
isrdonly	int
,	O
isvalid	int
;	O
{	O
int	O
key_flags	int
,	O
ret	int
;	O
key_flags	int
=	O
0	int
;	O
if	O
(	O
isrdonly	int
)	O
return	O
(	O
__db_rdonly	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"c_put"	pointer
)	O
)	O
;	O
switch	O
(	O
flags	int
)	O
{	O
case	O
DB_AFTER	int
:	O
case	O
DB_BEFORE	int
:	O
switch	O
(	O
dbp	pointer
->	O
type	enum
)	O
{	O
case	O
DB_BTREE	int
:	O
case	O
DB_HASH	int
:	O
if	O
(	O
!	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_DUP	int
)	O
)	O
goto	O
err	pointer
;	O
if	O
(	O
dbp	pointer
->	O
dup_compare	pointer
!=	O
NULL	O
)	O
goto	O
err	pointer
;	O
break	O
;	O
case	O
DB_QUEUE	int
:	O
goto	O
err	pointer
;	O
case	O
DB_RECNO	int
:	O
if	O
(	O
!	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_RE_RENUMBER	int
)	O
)	O
goto	O
err	pointer
;	O
key_flags	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
goto	O
err	pointer
;	O
}	O
break	O
;	O
case	O
DB_CURRENT	int
:	O
break	O
;	O
case	O
DB_NODUPDATA	int
:	O
if	O
(	O
!	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_DUPSORT	int
)	O
)	O
goto	O
err	pointer
;	O
case	O
DB_KEYFIRST	int
:	O
case	O
DB_KEYLAST	int
:	O
if	O
(	O
dbp	pointer
->	O
type	enum
==	O
DB_QUEUE	int
||	O
dbp	pointer
->	O
type	enum
==	O
DB_RECNO	int
)	O
goto	O
err	pointer
;	O
key_flags	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
err	pointer
:	O
return	O
(	O
CDB___db_ferr	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"DBcursor->c_put"	pointer
,	O
0	int
)	O
)	O
;	O
}	O
if	O
(	O
key_flags	int
&&	O
(	O
ret	int
=	O
__dbt_ferr	function
(	O
dbp	pointer
,	O
"key"	pointer
,	O
key	struct
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
__dbt_ferr	function
(	O
dbp	pointer
,	O
"data"	pointer
,	O
data	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
isvalid	int
||	O
flags	int
==	O
DB_KEYFIRST	int
||	O
flags	int
==	O
DB_KEYLAST	int
||	O
flags	int
==	O
DB_NODUPDATA	int
)	O
return	O
(	O
0	int
)	O
;	O
return	O
(	O
__db_curinval	function
(	O
dbp	pointer
->	O
dbenv	pointer
)	O
)	O
;	O
}	O
int	O
CDB___db_closechk	function
(	O
dbp	pointer
,	O
flags	int
)	O
const	O
DB	struct
*	O
dbp	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
switch	O
(	O
flags	int
)	O
{	O
case	O
0	int
:	O
case	O
DB_NOSYNC	int
:	O
break	O
;	O
default	O
:	O
return	O
(	O
CDB___db_ferr	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"DB->close"	pointer
,	O
0	int
)	O
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___db_delchk	function
(	O
dbp	pointer
,	O
key	struct
,	O
flags	int
,	O
isrdonly	int
)	O
const	O
DB	struct
*	O
dbp	pointer
;	O
DBT	struct
*	O
key	struct
;	O
u_int32_t	int
flags	int
;	O
int	O
isrdonly	int
;	O
{	O
if	O
(	O
key	struct
)	O
{	O
}	O
COMPQUIET	O
(	O
key	struct
,	O
NULL	O
)	O
;	O
if	O
(	O
isrdonly	int
)	O
return	O
(	O
__db_rdonly	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"delete"	pointer
)	O
)	O
;	O
switch	O
(	O
flags	int
)	O
{	O
case	O
0	int
:	O
break	O
;	O
default	O
:	O
return	O
(	O
CDB___db_ferr	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"DB->del"	pointer
,	O
0	int
)	O
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___db_getchk	function
(	O
dbp	pointer
,	O
key	struct
,	O
data	pointer
,	O
flags	int
)	O
const	O
DB	struct
*	O
dbp	pointer
;	O
const	O
DBT	struct
*	O
key	struct
;	O
DBT	struct
*	O
data	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
int	O
ret	int
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_RMW	int
)	O
)	O
{	O
if	O
(	O
!	O
LOCKING_ON	O
(	O
dbp	pointer
->	O
dbenv	pointer
)	O
)	O
{	O
CDB___db_err	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"the DB_RMW flag requires locking"	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
LF_CLR	O
(	O
DB_RMW	int
)	O
;	O
}	O
switch	O
(	O
flags	int
)	O
{	O
case	O
0	int
:	O
case	O
DB_GET_BOTH	int
:	O
break	O
;	O
case	O
DB_SET_RECNO	int
:	O
if	O
(	O
!	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_BT_RECNUM	int
)	O
)	O
goto	O
err	pointer
;	O
break	O
;	O
default	O
:	O
err	pointer
:	O
return	O
(	O
CDB___db_ferr	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"DB->get"	pointer
,	O
0	int
)	O
)	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
__dbt_ferr	function
(	O
dbp	pointer
,	O
"key"	pointer
,	O
key	struct
,	O
flags	int
==	O
DB_SET_RECNO	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
__dbt_ferr	function
(	O
dbp	pointer
,	O
"data"	pointer
,	O
data	pointer
,	O
1	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___db_joinchk	function
(	O
dbp	pointer
,	O
flags	int
)	O
const	O
DB	struct
*	O
dbp	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
switch	O
(	O
flags	int
)	O
{	O
case	O
0	int
:	O
case	O
DB_JOIN_NOSORT	int
:	O
break	O
;	O
default	O
:	O
return	O
(	O
CDB___db_ferr	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"DB->join"	pointer
,	O
0	int
)	O
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___db_joingetchk	function
(	O
dbp	pointer
,	O
key	struct
,	O
flags	int
)	O
const	O
DB	struct
*	O
dbp	pointer
;	O
DBT	struct
*	O
key	struct
;	O
u_int32_t	int
flags	int
;	O
{	O
if	O
(	O
LF_ISSET	O
(	O
DB_RMW	int
)	O
)	O
{	O
if	O
(	O
!	O
LOCKING_ON	O
(	O
dbp	pointer
->	O
dbenv	pointer
)	O
)	O
{	O
CDB___db_err	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"the DB_RMW flag requires locking"	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
LF_CLR	O
(	O
DB_RMW	int
)	O
;	O
}	O
switch	O
(	O
flags	int
)	O
{	O
case	O
0	int
:	O
case	O
DB_JOIN_ITEM	int
:	O
break	O
;	O
default	O
:	O
return	O
(	O
CDB___db_ferr	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"DBcursor->c_get"	pointer
,	O
0	int
)	O
)	O
;	O
}	O
if	O
(	O
F_ISSET	O
(	O
key	struct
,	O
DB_DBT_PARTIAL	int
)	O
)	O
{	O
CDB___db_err	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"DB_DBT_PARTIAL may not be set on key during join_get"	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___db_putchk	function
(	O
dbp	pointer
,	O
key	struct
,	O
data	pointer
,	O
flags	int
,	O
isrdonly	int
,	O
isdup	int
)	O
const	O
DB	struct
*	O
dbp	pointer
;	O
DBT	struct
*	O
key	struct
;	O
const	O
DBT	struct
*	O
data	pointer
;	O
u_int32_t	int
flags	int
;	O
int	O
isrdonly	int
,	O
isdup	int
;	O
{	O
int	O
key_flags	int
,	O
ret	int
;	O
key_flags	int
=	O
0	int
;	O
if	O
(	O
isrdonly	int
)	O
return	O
(	O
__db_rdonly	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"put"	pointer
)	O
)	O
;	O
switch	O
(	O
flags	int
)	O
{	O
case	O
0	int
:	O
case	O
DB_NOOVERWRITE	int
:	O
key_flags	int
=	O
1	int
;	O
break	O
;	O
case	O
DB_APPEND	int
:	O
if	O
(	O
dbp	pointer
->	O
type	enum
!=	O
DB_RECNO	int
&&	O
dbp	pointer
->	O
type	enum
!=	O
DB_QUEUE	int
)	O
goto	O
err	pointer
;	O
key_flags	int
=	O
1	int
;	O
break	O
;	O
case	O
DB_NODUPDATA	int
:	O
if	O
(	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_DUPSORT	int
)	O
)	O
break	O
;	O
default	O
:	O
err	pointer
:	O
return	O
(	O
CDB___db_ferr	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"DB->put"	pointer
,	O
0	int
)	O
)	O
;	O
}	O
if	O
(	O
key_flags	int
&&	O
(	O
ret	int
=	O
__dbt_ferr	function
(	O
dbp	pointer
,	O
"key"	pointer
,	O
key	struct
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
__dbt_ferr	function
(	O
dbp	pointer
,	O
"data"	pointer
,	O
data	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
isdup	int
&&	O
F_ISSET	O
(	O
data	pointer
,	O
DB_DBT_PARTIAL	int
)	O
)	O
{	O
CDB___db_err	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"a partial put in the presence of duplicates requires a cursor operation"	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___db_removechk	function
(	O
dbp	pointer
,	O
flags	int
)	O
const	O
DB	struct
*	O
dbp	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
switch	O
(	O
flags	int
)	O
{	O
case	O
0	int
:	O
break	O
;	O
default	O
:	O
return	O
(	O
CDB___db_ferr	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"DB->remove"	pointer
,	O
0	int
)	O
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___db_statchk	function
(	O
dbp	pointer
,	O
flags	int
)	O
const	O
DB	struct
*	O
dbp	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
switch	O
(	O
flags	int
)	O
{	O
case	O
0	int
:	O
case	O
DB_CACHED_COUNTS	int
:	O
break	O
;	O
case	O
DB_RECORDCOUNT	int
:	O
if	O
(	O
dbp	pointer
->	O
type	enum
==	O
DB_RECNO	int
)	O
break	O
;	O
if	O
(	O
dbp	pointer
->	O
type	enum
==	O
DB_BTREE	int
&&	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_BT_RECNUM	int
)	O
)	O
break	O
;	O
goto	O
err	pointer
;	O
default	O
:	O
err	pointer
:	O
return	O
(	O
CDB___db_ferr	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"DB->stat"	pointer
,	O
0	int
)	O
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___db_syncchk	function
(	O
dbp	pointer
,	O
flags	int
)	O
const	O
DB	struct
*	O
dbp	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
switch	O
(	O
flags	int
)	O
{	O
case	O
0	int
:	O
break	O
;	O
default	O
:	O
return	O
(	O
CDB___db_ferr	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"DB->sync"	pointer
,	O
0	int
)	O
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__dbt_ferr	function
(	O
dbp	pointer
,	O
name	pointer
,	O
dbt	struct
,	O
check_thread	int
)	O
const	O
DB	struct
*	O
dbp	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
const	O
DBT	struct
*	O
dbt	struct
;	O
int	O
check_thread	int
;	O
{	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
int	O
ret	int
;	O
dbenv	pointer
=	O
dbp	pointer
->	O
dbenv	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_fchk	function
(	O
dbenv	pointer
,	O
name	pointer
,	O
dbt	struct
->	O
flags	int
,	O
DB_DBT_MALLOC	int
|	O
DB_DBT_DUPOK	int
|	O
DB_DBT_REALLOC	int
|	O
DB_DBT_USERMEM	int
|	O
DB_DBT_PARTIAL	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
switch	O
(	O
F_ISSET	O
(	O
dbt	struct
,	O
DB_DBT_MALLOC	int
|	O
DB_DBT_REALLOC	int
|	O
DB_DBT_USERMEM	int
)	O
)	O
{	O
case	O
0	int
:	O
case	O
DB_DBT_MALLOC	int
:	O
case	O
DB_DBT_REALLOC	int
:	O
case	O
DB_DBT_USERMEM	int
:	O
break	O
;	O
default	O
:	O
return	O
(	O
CDB___db_ferr	function
(	O
dbenv	pointer
,	O
name	pointer
,	O
1	int
)	O
)	O
;	O
}	O
if	O
(	O
check_thread	int
&&	O
DB_IS_THREADED	O
(	O
dbp	pointer
)	O
&&	O
!	O
F_ISSET	O
(	O
dbt	struct
,	O
DB_DBT_MALLOC	int
|	O
DB_DBT_REALLOC	int
|	O
DB_DBT_USERMEM	int
)	O
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"DB_THREAD mandates memory allocation flag on DBT %s"	pointer
,	O
name	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__db_rdonly	function
(	O
dbenv	pointer
,	O
name	pointer
)	O
const	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"%s: attempt to modify a read-only tree"	pointer
,	O
name	pointer
)	O
;	O
return	O
(	O
EACCES	int
)	O
;	O
}	O
static	O
int	O
__db_curinval	function
(	O
dbenv	pointer
)	O
const	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"Cursor position must be set before performing this operation"	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
