char	O
version	array
[	O
60	int
]	O
;	O
extern	O
struct	O
layer	struct
*	O
flayer	pointer
;	O
extern	O
struct	O
display	struct
*	O
display	struct
,	O
*	O
displays	pointer
;	O
extern	O
struct	O
win	struct
*	O
windows	pointer
;	O
extern	O
int	O
maxwin	int
;	O
extern	O
char	O
*	O
noargs	array
[	O
]	O
;	O
extern	O
struct	O
mchar	struct
mchar_blank	struct
,	O
mchar_so	struct
;	O
extern	O
int	O
renditions	array
[	O
]	O
;	O
extern	O
unsigned	O
char	O
*	O
blank	pointer
;	O
extern	O
struct	O
win	struct
*	O
*	O
wtab	pointer
;	O
extern	O
struct	O
term	struct
term	struct
[	O
]	O
;	O
extern	O
struct	O
LayFuncs	struct
ListLf	struct
;	O
static	O
void	O
PadStr	function
__P	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
extern	O
char	O
*	O
wliststr	pointer
;	O
extern	O
char	O
*	O
wlisttit	pointer
;	O
void	O
exit_with_usage	function
(	O
char	O
*	O
myname	pointer
,	O
char	O
*	O
message	array
,	O
char	O
*	O
arg	pointer
)	O
{	O
printf	function
(	O
"Use: %s [-opts] [cmd [args]]\n"	pointer
,	O
myname	pointer
)	O
;	O
printf	function
(	O
" or: %s -r [host.tty]\n\nOptions:\n"	pointer
,	O
myname	pointer
)	O
;	O
printf	function
(	O
"-a            Force all capabilities into each window's termcap.\n"	pointer
)	O
;	O
printf	function
(	O
"-A -[r|R]     Adapt all windows to the new display width & height.\n"	pointer
)	O
;	O
printf	function
(	O
"-c file       Read configuration file instead of '.screenrc'.\n"	pointer
)	O
;	O
printf	function
(	O
"-d (-r)       Detach the elsewhere running screen (and reattach here).\n"	pointer
)	O
;	O
printf	function
(	O
"-dmS name     Start as daemon: Screen session in detached mode.\n"	pointer
)	O
;	O
printf	function
(	O
"-D (-r)       Detach and logout remote (and reattach here).\n"	pointer
)	O
;	O
printf	function
(	O
"-D -RR        Do whatever is needed to get a screen session.\n"	pointer
)	O
;	O
printf	function
(	O
"-e xy         Change command characters.\n"	pointer
)	O
;	O
printf	function
(	O
"-f            Flow control on, -fn = off, -fa = auto.\n"	pointer
)	O
;	O
printf	function
(	O
"-h lines      Set the size of the scrollback history buffer.\n"	pointer
)	O
;	O
printf	function
(	O
"-i            Interrupt output sooner when flow control is on.\n"	pointer
)	O
;	O
printf	function
(	O
"-l            Login mode on (update %s), -ln = off.\n"	pointer
,	O
UTMPFILE	O
)	O
;	O
printf	function
(	O
"-ls [match]   or\n"	pointer
)	O
;	O
printf	function
(	O
"-list         Do nothing, just list our SockDir [on possible matches].\n"	pointer
)	O
;	O
printf	function
(	O
"-L            Turn on output logging.\n"	pointer
)	O
;	O
printf	function
(	O
"-Logfile file Set logfile name.\n"	pointer
)	O
;	O
printf	function
(	O
"-m            ignore $STY variable, do create a new screen session.\n"	pointer
)	O
;	O
printf	function
(	O
"-O            Choose optimal output rather than exact vt100 emulation.\n"	pointer
)	O
;	O
printf	function
(	O
"-p window     Preselect the named window if it exists.\n"	pointer
)	O
;	O
printf	function
(	O
"-q            Quiet startup. Exits with non-zero return code if unsuccessful.\n"	pointer
)	O
;	O
printf	function
(	O
"-Q            Commands will send the response to the stdout of the querying process.\n"	pointer
)	O
;	O
printf	function
(	O
"-r [session]  Reattach to a detached screen process.\n"	pointer
)	O
;	O
printf	function
(	O
"-R            Reattach if possible, otherwise start a new session.\n"	pointer
)	O
;	O
printf	function
(	O
"-s shell      Shell to execute rather than $SHELL.\n"	pointer
)	O
;	O
printf	function
(	O
"-S sockname   Name this session <pid>.sockname instead of <pid>.<tty>.<host>.\n"	pointer
)	O
;	O
printf	function
(	O
"-t title      Set title. (window's name).\n"	pointer
)	O
;	O
printf	function
(	O
"-T term       Use term as $TERM for windows, rather than \"screen\".\n"	pointer
)	O
;	O
printf	function
(	O
"-U            Tell screen to use UTF-8 encoding.\n"	pointer
)	O
;	O
printf	function
(	O
"-v            Print \"Screen version %s\".\n"	pointer
,	O
version	array
)	O
;	O
printf	function
(	O
"-wipe [match] Do nothing, just clean up SockDir [on possible matches].\n"	pointer
)	O
;	O
printf	function
(	O
"-x            Attach to a not detached screen. (Multi display mode).\n"	pointer
)	O
;	O
printf	function
(	O
"-X            Execute <cmd> as a screen command in the specified session.\n"	pointer
)	O
;	O
if	O
(	O
message	array
&&	O
*	O
message	array
)	O
{	O
printf	function
(	O
"\nError: "	pointer
)	O
;	O
printf	function
(	O
message	array
,	O
arg	pointer
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
exit	function
(	O
1	int
)	O
;	O
}	O
extern	O
struct	O
comm	struct
comms	array
[	O
]	O
;	O
extern	O
struct	O
action	struct
ktab	array
[	O
]	O
;	O
static	O
void	O
HelpProcess	function
__P	O
(	O
(	O
char	O
*	O
*	O
,	O
int	O
*	O
)	O
)	O
;	O
static	O
void	O
HelpAbort	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
HelpRedisplayLine	function
__P	O
(	O
(	O
int	O
,	O
int	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
add_key_to_buf	function
__P	O
(	O
(	O
char	O
*	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
AddAction	function
__P	O
(	O
(	O
struct	O
action	struct
*	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
int	O
helppage	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
struct	O
helpdata	struct
{	O
char	O
*	O
class	pointer
;	O
struct	O
action	struct
*	O
ktabp	pointer
;	O
int	O
maxrow	int
,	O
grow	int
,	O
numcols	int
,	O
numrows	int
,	O
num_names	int
;	O
int	O
numskip	int
,	O
numpages	int
;	O
int	O
command_search	int
,	O
command_bindings	int
;	O
int	O
refgrow	int
,	O
refcommand_search	int
;	O
int	O
inter	int
,	O
mcom	int
,	O
mkey	int
;	O
int	O
nact	array
[	O
RC_LAST	int
+	O
1	int
]	O
;	O
}	O
;	O
static	O
struct	O
LayFuncs	struct
HelpLf	struct
=	O
{	O
HelpProcess	function
,	O
HelpAbort	function
,	O
HelpRedisplayLine	function
,	O
DefClearLine	function
,	O
DefRewrite	function
,	O
DefResize	function
,	O
DefRestore	function
,	O
0	int
}	O
;	O
void	O
display_help	function
(	O
char	O
*	O
class	pointer
,	O
struct	O
action	struct
*	O
ktabp	pointer
)	O
{	O
int	O
i	int
,	O
n	int
,	O
key	int
,	O
mcom	int
,	O
mkey	int
,	O
l	int
,	O
used	array
[	O
RC_LAST	int
+	O
1	int
]	O
;	O
struct	O
helpdata	struct
*	O
helpdata	struct
;	O
if	O
(	O
flayer	pointer
->	O
l_height	int
<	O
6	int
)	O
{	O
LMsg	function
(	O
0	int
,	O
"Window height too small for help page"	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
InitOverlayPage	function
(	O
sizeof	O
(	O
*	O
helpdata	struct
)	O
,	O
&	O
HelpLf	struct
,	O
0	int
)	O
)	O
return	O
;	O
helpdata	struct
=	O
(	O
struct	O
helpdata	struct
*	O
)	O
flayer	pointer
->	O
l_data	pointer
;	O
helpdata	struct
->	O
class	pointer
=	O
class	pointer
;	O
helpdata	struct
->	O
ktabp	pointer
=	O
ktabp	pointer
;	O
helpdata	struct
->	O
num_names	int
=	O
helpdata	struct
->	O
command_bindings	int
=	O
0	int
;	O
helpdata	struct
->	O
command_search	int
=	O
0	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<=	O
RC_LAST	int
;	O
n	int
++	O
)	O
used	array
[	O
n	int
]	O
=	O
0	int
;	O
mcom	int
=	O
0	int
;	O
mkey	int
=	O
0	int
;	O
for	O
(	O
key	int
=	O
0	int
;	O
key	int
<	O
256	int
+	O
KMAP_KEYS	O
;	O
key	int
++	O
)	O
{	O
n	int
=	O
ktabp	pointer
[	O
key	int
]	O
.	O
nr	int
;	O
if	O
(	O
n	int
==	O
RC_ILLEGAL	O
)	O
continue	O
;	O
if	O
(	O
ktabp	pointer
[	O
key	int
]	O
.	O
args	pointer
==	O
noargs	array
)	O
{	O
used	array
[	O
n	int
]	O
+=	O
(	O
key	int
<=	O
' '	O
||	O
key	int
==	O
0x7f	int
)	O
?	O
3	int
:	O
(	O
key	int
>	O
0x7f	int
)	O
?	O
5	int
:	O
2	int
;	O
}	O
else	O
helpdata	struct
->	O
command_bindings	int
++	O
;	O
}	O
for	O
(	O
n	int
=	O
i	int
=	O
0	int
;	O
n	int
<=	O
RC_LAST	int
;	O
n	int
++	O
)	O
if	O
(	O
used	array
[	O
n	int
]	O
)	O
{	O
l	int
=	O
strlen	function
(	O
comms	array
[	O
n	int
]	O
.	O
name	pointer
)	O
;	O
if	O
(	O
l	int
>	O
mcom	int
)	O
mcom	int
=	O
l	int
;	O
if	O
(	O
used	array
[	O
n	int
]	O
>	O
mkey	int
)	O
mkey	int
=	O
used	array
[	O
n	int
]	O
;	O
helpdata	struct
->	O
nact	array
[	O
i	int
++	O
]	O
=	O
n	int
;	O
}	O
debug1	O
(	O
"help: %d commands bound to keys with no arguments\n"	pointer
,	O
i	int
)	O
;	O
debug2	O
(	O
"mcom: %d  mkey: %d\n"	pointer
,	O
mcom	int
,	O
mkey	int
)	O
;	O
helpdata	struct
->	O
num_names	int
=	O
i	int
;	O
if	O
(	O
mkey	int
>	O
MAXKLEN	int
)	O
mkey	int
=	O
MAXKLEN	int
;	O
helpdata	struct
->	O
numcols	int
=	O
flayer	pointer
->	O
l_width	int
/	O
(	O
mcom	int
+	O
mkey	int
+	O
1	int
)	O
;	O
if	O
(	O
helpdata	struct
->	O
numcols	int
==	O
0	int
)	O
{	O
HelpAbort	function
(	O
)	O
;	O
LMsg	function
(	O
0	int
,	O
"Width too small"	pointer
)	O
;	O
return	O
;	O
}	O
helpdata	struct
->	O
inter	int
=	O
(	O
flayer	pointer
->	O
l_width	int
-	O
(	O
mcom	int
+	O
mkey	int
)	O
*	O
helpdata	struct
->	O
numcols	int
)	O
/	O
(	O
helpdata	struct
->	O
numcols	int
+	O
1	int
)	O
;	O
if	O
(	O
helpdata	struct
->	O
inter	int
<=	O
0	int
)	O
helpdata	struct
->	O
inter	int
=	O
1	int
;	O
debug1	O
(	O
"inter: %d\n"	pointer
,	O
helpdata	struct
->	O
inter	int
)	O
;	O
helpdata	struct
->	O
mcom	int
=	O
mcom	int
;	O
helpdata	struct
->	O
mkey	int
=	O
mkey	int
;	O
helpdata	struct
->	O
numrows	int
=	O
(	O
helpdata	struct
->	O
num_names	int
+	O
helpdata	struct
->	O
numcols	int
-	O
1	int
)	O
/	O
helpdata	struct
->	O
numcols	int
;	O
debug1	O
(	O
"Numrows: %d\n"	pointer
,	O
helpdata	struct
->	O
numrows	int
)	O
;	O
helpdata	struct
->	O
numskip	int
=	O
flayer	pointer
->	O
l_height	int
-	O
5	int
-	O
(	O
2	int
+	O
helpdata	struct
->	O
numrows	int
)	O
;	O
while	O
(	O
helpdata	struct
->	O
numskip	int
<	O
0	int
)	O
helpdata	struct
->	O
numskip	int
+=	O
flayer	pointer
->	O
l_height	int
-	O
5	int
;	O
helpdata	struct
->	O
numskip	int
%=	O
flayer	pointer
->	O
l_height	int
-	O
5	int
;	O
debug1	O
(	O
"Numskip: %d\n"	pointer
,	O
helpdata	struct
->	O
numskip	int
)	O
;	O
if	O
(	O
helpdata	struct
->	O
numskip	int
>	O
flayer	pointer
->	O
l_height	int
/	O
3	int
||	O
helpdata	struct
->	O
numskip	int
>	O
helpdata	struct
->	O
command_bindings	int
)	O
helpdata	struct
->	O
numskip	int
=	O
1	int
;	O
helpdata	struct
->	O
maxrow	int
=	O
2	int
+	O
helpdata	struct
->	O
numrows	int
+	O
helpdata	struct
->	O
numskip	int
+	O
helpdata	struct
->	O
command_bindings	int
;	O
helpdata	struct
->	O
grow	int
=	O
0	int
;	O
helpdata	struct
->	O
numpages	int
=	O
(	O
helpdata	struct
->	O
maxrow	int
+	O
flayer	pointer
->	O
l_height	int
-	O
6	int
)	O
/	O
(	O
flayer	pointer
->	O
l_height	int
-	O
5	int
)	O
;	O
flayer	pointer
->	O
l_x	int
=	O
0	int
;	O
flayer	pointer
->	O
l_y	int
=	O
flayer	pointer
->	O
l_height	int
-	O
1	int
;	O
helppage	function
(	O
)	O
;	O
}	O
static	O
void	O
HelpProcess	function
(	O
char	O
*	O
*	O
ppbuf	pointer
,	O
int	O
*	O
plen	pointer
)	O
{	O
int	O
done	int
=	O
0	int
;	O
while	O
(	O
!	O
done	int
&&	O
*	O
plen	pointer
>	O
0	int
)	O
{	O
switch	O
(	O
*	O
*	O
ppbuf	pointer
)	O
{	O
case	O
' '	O
:	O
if	O
(	O
helppage	function
(	O
)	O
==	O
0	int
)	O
break	O
;	O
case	O
'\r'	O
:	O
case	O
'\n'	O
:	O
done	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
++	O
*	O
ppbuf	pointer
;	O
--	O
*	O
plen	pointer
;	O
}	O
if	O
(	O
done	int
)	O
HelpAbort	function
(	O
)	O
;	O
}	O
static	O
void	O
HelpAbort	function
(	O
)	O
{	O
LAY_CALL_UP	O
(	O
LRefreshAll	function
(	O
flayer	pointer
,	O
0	int
)	O
)	O
;	O
ExitOverlayPage	function
(	O
)	O
;	O
}	O
static	O
int	O
helppage	function
(	O
)	O
{	O
struct	O
helpdata	struct
*	O
helpdata	struct
;	O
int	O
col	int
,	O
crow	int
,	O
n	int
,	O
key	int
,	O
x	int
;	O
char	O
buf	pointer
[	O
MAXKLEN	int
]	O
,	O
Esc_buf	array
[	O
5	int
]	O
,	O
cbuf	array
[	O
256	int
]	O
;	O
struct	O
action	struct
*	O
ktabp	pointer
;	O
helpdata	struct
=	O
(	O
struct	O
helpdata	struct
*	O
)	O
flayer	pointer
->	O
l_data	pointer
;	O
ktabp	pointer
=	O
helpdata	struct
->	O
ktabp	pointer
;	O
if	O
(	O
helpdata	struct
->	O
grow	int
>=	O
helpdata	struct
->	O
maxrow	int
)	O
return	O
-	O
1	int
;	O
helpdata	struct
->	O
refgrow	int
=	O
helpdata	struct
->	O
grow	int
;	O
helpdata	struct
->	O
refcommand_search	int
=	O
helpdata	struct
->	O
command_search	int
;	O
LClearAll	function
(	O
flayer	pointer
,	O
0	int
)	O
;	O
sprintf	function
(	O
cbuf	array
,	O
"Screen key bindings, page %d of %d."	pointer
,	O
helpdata	struct
->	O
grow	int
/	O
(	O
flayer	pointer
->	O
l_height	int
-	O
5	int
)	O
+	O
1	int
,	O
helpdata	struct
->	O
numpages	int
)	O
;	O
centerline	function
(	O
cbuf	array
,	O
0	int
)	O
;	O
crow	int
=	O
2	int
;	O
*	O
Esc_buf	array
=	O
'\0'	O
;	O
*	O
buf	pointer
=	O
'\0'	O
;	O
if	O
(	O
flayer	pointer
->	O
l_cvlist	pointer
&&	O
flayer	pointer
->	O
l_cvlist	pointer
->	O
c_display	pointer
)	O
{	O
add_key_to_buf	function
(	O
buf	pointer
,	O
flayer	pointer
->	O
l_cvlist	pointer
->	O
c_display	pointer
->	O
d_user	pointer
->	O
u_MetaEsc	int
)	O
;	O
add_key_to_buf	function
(	O
Esc_buf	array
,	O
flayer	pointer
->	O
l_cvlist	pointer
->	O
c_display	pointer
->	O
d_user	pointer
->	O
u_Esc	int
)	O
;	O
}	O
else	O
{	O
strcpy	function
(	O
Esc_buf	array
,	O
"??"	pointer
)	O
;	O
strcpy	function
(	O
buf	pointer
,	O
"??"	pointer
)	O
;	O
}	O
for	O
(	O
;	O
crow	int
<	O
flayer	pointer
->	O
l_height	int
-	O
3	int
;	O
crow	int
++	O
)	O
{	O
if	O
(	O
helpdata	struct
->	O
grow	int
<	O
1	int
)	O
{	O
if	O
(	O
ktabp	pointer
==	O
ktab	array
)	O
sprintf	function
(	O
cbuf	array
,	O
"Command key:  %s   Literal %s:  %s"	pointer
,	O
Esc_buf	array
,	O
Esc_buf	array
,	O
buf	pointer
)	O
;	O
else	O
sprintf	function
(	O
cbuf	array
,	O
"Command class: '%.80s'"	pointer
,	O
helpdata	struct
->	O
class	pointer
)	O
;	O
centerline	function
(	O
cbuf	array
,	O
crow	int
)	O
;	O
helpdata	struct
->	O
grow	int
++	O
;	O
}	O
else	O
if	O
(	O
helpdata	struct
->	O
grow	int
>=	O
2	int
&&	O
helpdata	struct
->	O
grow	int
-	O
2	int
<	O
helpdata	struct
->	O
numrows	int
)	O
{	O
x	int
=	O
0	int
;	O
for	O
(	O
col	int
=	O
0	int
;	O
col	int
<	O
helpdata	struct
->	O
numcols	int
&&	O
(	O
n	int
=	O
helpdata	struct
->	O
numrows	int
*	O
col	int
+	O
(	O
helpdata	struct
->	O
grow	int
-	O
2	int
)	O
)	O
<	O
helpdata	struct
->	O
num_names	int
;	O
col	int
++	O
)	O
{	O
x	int
+=	O
helpdata	struct
->	O
inter	int
-	O
!	O
col	int
;	O
n	int
=	O
helpdata	struct
->	O
nact	array
[	O
n	int
]	O
;	O
buf	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
for	O
(	O
key	int
=	O
0	int
;	O
key	int
<	O
256	int
+	O
KMAP_KEYS	O
;	O
key	int
++	O
)	O
if	O
(	O
ktabp	pointer
[	O
key	int
]	O
.	O
nr	int
==	O
n	int
&&	O
ktabp	pointer
[	O
key	int
]	O
.	O
args	pointer
==	O
noargs	array
&&	O
strlen	function
(	O
buf	pointer
)	O
<	O
sizeof	O
(	O
buf	pointer
)	O
-	O
7	int
)	O
{	O
strcat	function
(	O
buf	pointer
,	O
" "	pointer
)	O
;	O
add_key_to_buf	function
(	O
buf	pointer
,	O
key	int
)	O
;	O
}	O
PadStr	function
(	O
comms	array
[	O
n	int
]	O
.	O
name	pointer
,	O
helpdata	struct
->	O
mcom	int
,	O
x	int
,	O
crow	int
)	O
;	O
x	int
+=	O
helpdata	struct
->	O
mcom	int
;	O
PadStr	function
(	O
buf	pointer
,	O
helpdata	struct
->	O
mkey	int
,	O
x	int
,	O
crow	int
)	O
;	O
x	int
+=	O
helpdata	struct
->	O
mkey	int
;	O
}	O
helpdata	struct
->	O
grow	int
++	O
;	O
}	O
else	O
if	O
(	O
helpdata	struct
->	O
grow	int
-	O
2	int
-	O
helpdata	struct
->	O
numrows	int
>=	O
helpdata	struct
->	O
numskip	int
&&	O
helpdata	struct
->	O
grow	int
-	O
2	int
-	O
helpdata	struct
->	O
numrows	int
-	O
helpdata	struct
->	O
numskip	int
<	O
helpdata	struct
->	O
command_bindings	int
)	O
{	O
while	O
(	O
(	O
n	int
=	O
ktabp	pointer
[	O
helpdata	struct
->	O
command_search	int
]	O
.	O
nr	int
)	O
==	O
RC_ILLEGAL	O
||	O
ktabp	pointer
[	O
helpdata	struct
->	O
command_search	int
]	O
.	O
args	pointer
==	O
noargs	array
)	O
{	O
if	O
(	O
++	O
helpdata	struct
->	O
command_search	int
>=	O
256	int
+	O
KMAP_KEYS	O
)	O
return	O
-	O
1	int
;	O
}	O
buf	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
add_key_to_buf	function
(	O
buf	pointer
,	O
helpdata	struct
->	O
command_search	int
)	O
;	O
PadStr	function
(	O
buf	pointer
,	O
5	int
,	O
0	int
,	O
crow	int
)	O
;	O
AddAction	function
(	O
&	O
ktabp	pointer
[	O
helpdata	struct
->	O
command_search	int
++	O
]	O
,	O
5	int
,	O
crow	int
)	O
;	O
helpdata	struct
->	O
grow	int
++	O
;	O
}	O
else	O
helpdata	struct
->	O
grow	int
++	O
;	O
}	O
sprintf	function
(	O
cbuf	array
,	O
"[Press Space %s Return to end.]"	pointer
,	O
helpdata	struct
->	O
grow	int
<	O
helpdata	struct
->	O
maxrow	int
?	O
"for next page;"	pointer
:	O
"or"	pointer
)	O
;	O
centerline	function
(	O
cbuf	array
,	O
flayer	pointer
->	O
l_height	int
-	O
2	int
)	O
;	O
LaySetCursor	O
(	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
AddAction	function
(	O
struct	O
action	struct
*	O
act	pointer
,	O
int	O
x	int
,	O
int	O
y	int
)	O
{	O
char	O
buf	pointer
[	O
256	int
]	O
;	O
int	O
del	int
,	O
l	int
,	O
fr	int
;	O
char	O
*	O
bp	pointer
,	O
*	O
cp	pointer
,	O
*	O
*	O
pp	pointer
;	O
int	O
*	O
lp	pointer
,	O
ll	int
;	O
struct	O
mchar	struct
mchar_dol	struct
;	O
mchar_dol	struct
=	O
mchar_blank	struct
;	O
mchar_dol	struct
.	O
image	char
=	O
'$'	O
;	O
fr	int
=	O
flayer	pointer
->	O
l_width	int
-	O
1	int
-	O
x	int
;	O
if	O
(	O
fr	int
<=	O
0	int
)	O
return	O
;	O
l	int
=	O
strlen	function
(	O
comms	array
[	O
act	pointer
->	O
nr	int
]	O
.	O
name	pointer
)	O
;	O
if	O
(	O
l	int
+	O
1	int
>	O
fr	int
)	O
l	int
=	O
fr	int
-	O
1	int
;	O
PadStr	function
(	O
comms	array
[	O
act	pointer
->	O
nr	int
]	O
.	O
name	pointer
,	O
l	int
,	O
x	int
,	O
y	int
)	O
;	O
x	int
+=	O
l	int
;	O
fr	int
-=	O
l	int
+	O
1	int
;	O
LPutChar	function
(	O
flayer	pointer
,	O
fr	int
?	O
&	O
mchar_blank	struct
:	O
&	O
mchar_dol	struct
,	O
x	int
++	O
,	O
y	int
)	O
;	O
pp	pointer
=	O
act	pointer
->	O
args	pointer
;	O
lp	pointer
=	O
act	pointer
->	O
argl	pointer
;	O
while	O
(	O
pp	pointer
&&	O
(	O
cp	pointer
=	O
*	O
pp	pointer
)	O
!=	O
NULL	O
)	O
{	O
del	int
=	O
0	int
;	O
bp	pointer
=	O
buf	pointer
;	O
ll	int
=	O
*	O
lp	pointer
++	O
;	O
if	O
(	O
!	O
ll	int
||	O
(	O
index	function
(	O
cp	pointer
,	O
' '	O
)	O
!=	O
NULL	O
)	O
)	O
{	O
if	O
(	O
index	function
(	O
cp	pointer
,	O
'\''	O
)	O
!=	O
NULL	O
)	O
*	O
bp	pointer
++	O
=	O
del	int
=	O
'"'	O
;	O
else	O
*	O
bp	pointer
++	O
=	O
del	int
=	O
'\''	O
;	O
}	O
while	O
(	O
ll	int
--	O
&&	O
bp	pointer
<	O
buf	pointer
+	O
250	int
)	O
bp	pointer
+=	O
AddXChar	function
(	O
bp	pointer
,	O
*	O
(	O
unsigned	O
char	O
*	O
)	O
cp	pointer
++	O
)	O
;	O
if	O
(	O
del	int
)	O
*	O
bp	pointer
++	O
=	O
del	int
;	O
*	O
bp	pointer
=	O
0	int
;	O
if	O
(	O
(	O
fr	int
-=	O
(	O
bp	pointer
-	O
buf	pointer
)	O
+	O
1	int
)	O
<	O
0	int
)	O
{	O
fr	int
+=	O
bp	pointer
-	O
buf	pointer
;	O
if	O
(	O
fr	int
>	O
0	int
)	O
PadStr	function
(	O
buf	pointer
,	O
fr	int
,	O
x	int
,	O
y	int
)	O
;	O
if	O
(	O
fr	int
==	O
0	int
)	O
LPutChar	function
(	O
flayer	pointer
,	O
&	O
mchar_dol	struct
,	O
x	int
,	O
y	int
)	O
;	O
return	O
;	O
}	O
PadStr	function
(	O
buf	pointer
,	O
strlen	function
(	O
buf	pointer
)	O
,	O
x	int
,	O
y	int
)	O
;	O
x	int
+=	O
strlen	function
(	O
buf	pointer
)	O
;	O
pp	pointer
++	O
;	O
if	O
(	O
*	O
pp	pointer
)	O
LPutChar	function
(	O
flayer	pointer
,	O
fr	int
?	O
&	O
mchar_blank	struct
:	O
&	O
mchar_dol	struct
,	O
x	int
++	O
,	O
y	int
)	O
;	O
}	O
}	O
static	O
void	O
add_key_to_buf	function
(	O
char	O
*	O
buf	pointer
,	O
int	O
key	int
)	O
{	O
buf	pointer
+=	O
strlen	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
key	int
<	O
0	int
)	O
strcpy	function
(	O
buf	pointer
,	O
"unset"	pointer
)	O
;	O
else	O
if	O
(	O
key	int
==	O
' '	O
)	O
strcpy	function
(	O
buf	pointer
,	O
"sp"	pointer
)	O
;	O
else	O
if	O
(	O
key	int
>=	O
256	int
)	O
{	O
key	int
=	O
key	int
-	O
256	int
+	O
T_CAPS	int
;	O
buf	pointer
[	O
0	int
]	O
=	O
':'	O
;	O
buf	pointer
[	O
1	int
]	O
=	O
term	struct
[	O
key	int
]	O
.	O
tcname	pointer
[	O
0	int
]	O
;	O
buf	pointer
[	O
2	int
]	O
=	O
term	struct
[	O
key	int
]	O
.	O
tcname	pointer
[	O
1	int
]	O
;	O
buf	pointer
[	O
3	int
]	O
=	O
':'	O
;	O
buf	pointer
[	O
4	int
]	O
=	O
0	int
;	O
}	O
else	O
buf	pointer
[	O
AddXChar	function
(	O
buf	pointer
,	O
key	int
)	O
]	O
=	O
0	int
;	O
}	O
static	O
void	O
HelpRedisplayLine	function
(	O
int	O
y	int
,	O
int	O
xs	int
,	O
int	O
xe	int
,	O
int	O
isblank	int
)	O
{	O
if	O
(	O
y	int
<	O
0	int
)	O
{	O
struct	O
helpdata	struct
*	O
helpdata	struct
;	O
helpdata	struct
=	O
(	O
struct	O
helpdata	struct
*	O
)	O
flayer	pointer
->	O
l_data	pointer
;	O
helpdata	struct
->	O
grow	int
=	O
helpdata	struct
->	O
refgrow	int
;	O
helpdata	struct
->	O
command_search	int
=	O
helpdata	struct
->	O
refcommand_search	int
;	O
helppage	function
(	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
y	int
!=	O
0	int
&&	O
y	int
!=	O
flayer	pointer
->	O
l_height	int
-	O
1	int
)	O
return	O
;	O
if	O
(	O
!	O
isblank	int
)	O
LClearArea	function
(	O
flayer	pointer
,	O
xs	int
,	O
y	int
,	O
xe	int
,	O
y	int
,	O
0	int
,	O
0	int
)	O
;	O
}	O
static	O
void	O
CopyrightProcess	function
__P	O
(	O
(	O
char	O
*	O
*	O
,	O
int	O
*	O
)	O
)	O
;	O
static	O
void	O
CopyrightRedisplayLine	function
__P	O
(	O
(	O
int	O
,	O
int	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
CopyrightAbort	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
copypage	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
struct	O
copydata	struct
{	O
char	O
*	O
cps	pointer
,	O
*	O
savedcps	pointer
;	O
char	O
*	O
refcps	pointer
,	O
*	O
refsavedcps	pointer
;	O
}	O
;	O
static	O
struct	O
LayFuncs	struct
CopyrightLf	struct
=	O
{	O
CopyrightProcess	function
,	O
CopyrightAbort	function
,	O
CopyrightRedisplayLine	function
,	O
DefClearLine	function
,	O
DefRewrite	function
,	O
DefResize	function
,	O
DefRestore	function
,	O
0	int
}	O
;	O
static	O
const	O
char	O
cpmsg	array
[	O
]	O
=	O
"\nGNU Screen version %v\n\nCopyright (c) 2018-2020 Alexander Naumov, Amadeusz Slawinski\nCopyright (c) 2015-2017 Juergen Weigert, Alexander Naumov, Amadeusz Slawinski\nCopyright (c) 2010-2014 Juergen Weigert, Sadrul Habib Chowdhury\nCopyright (c) 2008-2009 Juergen Weigert, Michael Schroeder, Micah Cowan, Sadrul Habib Chowdhury\nCopyright (c) 1993-2007 Juergen Weigert, Michael Schroeder\nCopyright (c) 1987 Oliver Laumann\n\nThis program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 3, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License along with this program (see the file COPYING); if not, see https://www.gnu.org/licenses/, or contact Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111-1301  USA.\n\nSend bugreports, fixes, enhancements, t-shirts, money, beer & pizza to screen-devel@gnu.org\n\n\n"	pointer
"Capabilities:\n"	pointer
"+copy "	pointer
"+remote-detach "	pointer
"+power-detach "	pointer
"+multi-attach "	pointer
"+multi-user "	pointer
"+font "	pointer
"+color-16 "	pointer
"+utf8 "	pointer
"-rxvt "	pointer
"-builtin-telnet "	pointer
;	O
static	O
void	O
CopyrightProcess	function
(	O
char	O
*	O
*	O
ppbuf	pointer
,	O
int	O
*	O
plen	pointer
)	O
{	O
int	O
done	int
=	O
0	int
;	O
struct	O
copydata	struct
*	O
copydata	struct
;	O
copydata	struct
=	O
(	O
struct	O
copydata	struct
*	O
)	O
flayer	pointer
->	O
l_data	pointer
;	O
while	O
(	O
!	O
done	int
&&	O
*	O
plen	pointer
>	O
0	int
)	O
{	O
switch	O
(	O
*	O
*	O
ppbuf	pointer
)	O
{	O
case	O
' '	O
:	O
if	O
(	O
*	O
copydata	struct
->	O
cps	pointer
)	O
{	O
copypage	function
(	O
)	O
;	O
break	O
;	O
}	O
case	O
'\r'	O
:	O
case	O
'\n'	O
:	O
CopyrightAbort	function
(	O
)	O
;	O
done	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
++	O
*	O
ppbuf	pointer
;	O
--	O
*	O
plen	pointer
;	O
}	O
}	O
static	O
void	O
CopyrightAbort	function
(	O
)	O
{	O
LAY_CALL_UP	O
(	O
LRefreshAll	function
(	O
flayer	pointer
,	O
0	int
)	O
)	O
;	O
ExitOverlayPage	function
(	O
)	O
;	O
}	O
void	O
display_copyright	function
(	O
)	O
{	O
struct	O
copydata	struct
*	O
copydata	struct
;	O
if	O
(	O
flayer	pointer
->	O
l_width	int
<	O
10	int
||	O
flayer	pointer
->	O
l_height	int
<	O
5	int
)	O
{	O
LMsg	function
(	O
0	int
,	O
"Window size too small for copyright page"	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
InitOverlayPage	function
(	O
sizeof	O
(	O
*	O
copydata	struct
)	O
,	O
&	O
CopyrightLf	struct
,	O
0	int
)	O
)	O
return	O
;	O
copydata	struct
=	O
(	O
struct	O
copydata	struct
*	O
)	O
flayer	pointer
->	O
l_data	pointer
;	O
copydata	struct
->	O
cps	pointer
=	O
(	O
char	O
*	O
)	O
cpmsg	array
;	O
copydata	struct
->	O
savedcps	pointer
=	O
0	int
;	O
flayer	pointer
->	O
l_x	int
=	O
0	int
;	O
flayer	pointer
->	O
l_y	int
=	O
flayer	pointer
->	O
l_height	int
-	O
1	int
;	O
copypage	function
(	O
)	O
;	O
}	O
static	O
void	O
copypage	function
(	O
)	O
{	O
register	O
char	O
*	O
cps	pointer
;	O
char	O
*	O
ws	pointer
;	O
int	O
x	int
,	O
y	int
,	O
l	int
;	O
char	O
cbuf	array
[	O
80	int
]	O
;	O
struct	O
copydata	struct
*	O
copydata	struct
;	O
ASSERT	O
(	O
flayer	pointer
)	O
;	O
copydata	struct
=	O
(	O
struct	O
copydata	struct
*	O
)	O
flayer	pointer
->	O
l_data	pointer
;	O
LClearAll	function
(	O
flayer	pointer
,	O
0	int
)	O
;	O
x	int
=	O
y	int
=	O
0	int
;	O
cps	pointer
=	O
copydata	struct
->	O
cps	pointer
;	O
copydata	struct
->	O
refcps	pointer
=	O
cps	pointer
;	O
copydata	struct
->	O
refsavedcps	pointer
=	O
copydata	struct
->	O
savedcps	pointer
;	O
while	O
(	O
*	O
cps	pointer
&&	O
y	int
<	O
flayer	pointer
->	O
l_height	int
-	O
3	int
)	O
{	O
ws	pointer
=	O
cps	pointer
;	O
while	O
(	O
*	O
cps	pointer
==	O
' '	O
)	O
cps	pointer
++	O
;	O
if	O
(	O
strncmp	function
(	O
cps	pointer
,	O
"%v"	pointer
,	O
2	int
)	O
==	O
0	int
)	O
{	O
copydata	struct
->	O
savedcps	pointer
=	O
cps	pointer
+	O
2	int
;	O
cps	pointer
=	O
version	array
;	O
continue	O
;	O
}	O
while	O
(	O
*	O
cps	pointer
&&	O
*	O
cps	pointer
!=	O
' '	O
&&	O
*	O
cps	pointer
!=	O
'\n'	O
)	O
cps	pointer
++	O
;	O
l	int
=	O
cps	pointer
-	O
ws	pointer
;	O
cps	pointer
=	O
ws	pointer
;	O
if	O
(	O
l	int
>	O
flayer	pointer
->	O
l_width	int
-	O
1	int
)	O
l	int
=	O
flayer	pointer
->	O
l_width	int
-	O
1	int
;	O
if	O
(	O
x	int
&&	O
x	int
+	O
l	int
>=	O
flayer	pointer
->	O
l_width	int
-	O
2	int
)	O
{	O
x	int
=	O
0	int
;	O
y	int
++	O
;	O
continue	O
;	O
}	O
if	O
(	O
x	int
)	O
{	O
LPutChar	function
(	O
flayer	pointer
,	O
&	O
mchar_blank	struct
,	O
x	int
,	O
y	int
)	O
;	O
x	int
++	O
;	O
}	O
if	O
(	O
l	int
)	O
LPutStr	function
(	O
flayer	pointer
,	O
ws	pointer
,	O
l	int
,	O
&	O
mchar_blank	struct
,	O
x	int
,	O
y	int
)	O
;	O
x	int
+=	O
l	int
;	O
cps	pointer
+=	O
l	int
;	O
if	O
(	O
*	O
cps	pointer
==	O
0	int
&&	O
copydata	struct
->	O
savedcps	pointer
)	O
{	O
cps	pointer
=	O
copydata	struct
->	O
savedcps	pointer
;	O
copydata	struct
->	O
savedcps	pointer
=	O
0	int
;	O
}	O
if	O
(	O
*	O
cps	pointer
==	O
'\n'	O
)	O
{	O
x	int
=	O
0	int
;	O
y	int
++	O
;	O
}	O
if	O
(	O
*	O
cps	pointer
==	O
' '	O
||	O
*	O
cps	pointer
==	O
'\n'	O
)	O
cps	pointer
++	O
;	O
}	O
while	O
(	O
*	O
cps	pointer
==	O
'\n'	O
)	O
cps	pointer
++	O
;	O
sprintf	function
(	O
cbuf	array
,	O
"[Press Space %s Return to end.]"	pointer
,	O
*	O
cps	pointer
?	O
"for next page;"	pointer
:	O
"or"	pointer
)	O
;	O
centerline	function
(	O
cbuf	array
,	O
flayer	pointer
->	O
l_height	int
-	O
2	int
)	O
;	O
copydata	struct
->	O
cps	pointer
=	O
cps	pointer
;	O
LaySetCursor	O
(	O
)	O
;	O
}	O
static	O
void	O
CopyrightRedisplayLine	function
(	O
int	O
y	int
,	O
int	O
xs	int
,	O
int	O
xe	int
,	O
int	O
isblank	int
)	O
{	O
ASSERT	O
(	O
flayer	pointer
)	O
;	O
if	O
(	O
y	int
<	O
0	int
)	O
{	O
struct	O
copydata	struct
*	O
copydata	struct
;	O
copydata	struct
=	O
(	O
struct	O
copydata	struct
*	O
)	O
flayer	pointer
->	O
l_data	pointer
;	O
copydata	struct
->	O
cps	pointer
=	O
copydata	struct
->	O
refcps	pointer
;	O
copydata	struct
->	O
savedcps	pointer
=	O
copydata	struct
->	O
refsavedcps	pointer
;	O
copypage	function
(	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
y	int
!=	O
0	int
&&	O
y	int
!=	O
flayer	pointer
->	O
l_height	int
-	O
1	int
)	O
return	O
;	O
if	O
(	O
isblank	int
)	O
return	O
;	O
LClearArea	function
(	O
flayer	pointer
,	O
xs	int
,	O
y	int
,	O
xe	int
,	O
y	int
,	O
0	int
,	O
0	int
)	O
;	O
}	O
extern	O
struct	O
kmap_ext	struct
*	O
kmap_exts	pointer
;	O
extern	O
int	O
kmap_extn	int
;	O
extern	O
struct	O
action	struct
dmtab	array
[	O
]	O
;	O
extern	O
struct	O
action	struct
mmtab	array
[	O
]	O
;	O
static	O
void	O
BindkeyProcess	function
__P	O
(	O
(	O
char	O
*	O
*	O
,	O
int	O
*	O
)	O
)	O
;	O
static	O
void	O
BindkeyAbort	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
BindkeyRedisplayLine	function
__P	O
(	O
(	O
int	O
,	O
int	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
bindkeypage	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
struct	O
bindkeydata	struct
{	O
char	O
*	O
title	pointer
;	O
struct	O
action	struct
*	O
tab	pointer
;	O
int	O
pos	int
;	O
int	O
last	int
;	O
int	O
page	int
;	O
int	O
pages	int
;	O
}	O
;	O
static	O
struct	O
LayFuncs	struct
BindkeyLf	struct
=	O
{	O
BindkeyProcess	function
,	O
BindkeyAbort	function
,	O
BindkeyRedisplayLine	function
,	O
DefClearLine	function
,	O
DefRewrite	function
,	O
DefResize	function
,	O
DefRestore	function
,	O
0	int
}	O
;	O
void	O
display_bindkey	function
(	O
char	O
*	O
title	pointer
,	O
struct	O
action	struct
*	O
tab	pointer
)	O
{	O
struct	O
bindkeydata	struct
*	O
bindkeydata	struct
;	O
int	O
i	int
,	O
n	int
;	O
if	O
(	O
flayer	pointer
->	O
l_height	int
<	O
6	int
)	O
{	O
LMsg	function
(	O
0	int
,	O
"Window height too small for bindkey page"	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
InitOverlayPage	function
(	O
sizeof	O
(	O
*	O
bindkeydata	struct
)	O
,	O
&	O
BindkeyLf	struct
,	O
0	int
)	O
)	O
return	O
;	O
bindkeydata	struct
=	O
(	O
struct	O
bindkeydata	struct
*	O
)	O
flayer	pointer
->	O
l_data	pointer
;	O
bindkeydata	struct
->	O
title	pointer
=	O
title	pointer
;	O
bindkeydata	struct
->	O
tab	pointer
=	O
tab	pointer
;	O
n	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
KMAP_KEYS	O
+	O
KMAP_AKEYS	O
+	O
kmap_extn	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
tab	pointer
[	O
i	int
]	O
.	O
nr	int
!=	O
RC_ILLEGAL	O
)	O
n	int
++	O
;	O
}	O
bindkeydata	struct
->	O
pos	int
=	O
0	int
;	O
bindkeydata	struct
->	O
page	int
=	O
1	int
;	O
bindkeydata	struct
->	O
pages	int
=	O
(	O
n	int
+	O
flayer	pointer
->	O
l_height	int
-	O
6	int
)	O
/	O
(	O
flayer	pointer
->	O
l_height	int
-	O
5	int
)	O
;	O
if	O
(	O
bindkeydata	struct
->	O
pages	int
==	O
0	int
)	O
bindkeydata	struct
->	O
pages	int
=	O
1	int
;	O
flayer	pointer
->	O
l_x	int
=	O
0	int
;	O
flayer	pointer
->	O
l_y	int
=	O
flayer	pointer
->	O
l_height	int
-	O
1	int
;	O
bindkeypage	function
(	O
)	O
;	O
}	O
static	O
void	O
BindkeyAbort	function
(	O
)	O
{	O
LAY_CALL_UP	O
(	O
LRefreshAll	function
(	O
flayer	pointer
,	O
0	int
)	O
)	O
;	O
ExitOverlayPage	function
(	O
)	O
;	O
}	O
static	O
void	O
bindkeypage	function
(	O
)	O
{	O
struct	O
bindkeydata	struct
*	O
bindkeydata	struct
;	O
struct	O
kmap_ext	struct
*	O
kme	pointer
;	O
char	O
tbuf	array
[	O
256	int
]	O
;	O
int	O
del	int
,	O
i	int
,	O
y	int
,	O
sl	int
;	O
struct	O
action	struct
*	O
act	pointer
;	O
char	O
*	O
xch	pointer
,	O
*	O
s	pointer
,	O
*	O
p	pointer
;	O
bindkeydata	struct
=	O
(	O
struct	O
bindkeydata	struct
*	O
)	O
flayer	pointer
->	O
l_data	pointer
;	O
LClearAll	function
(	O
flayer	pointer
,	O
0	int
)	O
;	O
sprintf	function
(	O
tbuf	array
,	O
"%s key bindings, page %d of %d."	pointer
,	O
bindkeydata	struct
->	O
title	pointer
,	O
bindkeydata	struct
->	O
page	int
,	O
bindkeydata	struct
->	O
pages	int
)	O
;	O
centerline	function
(	O
tbuf	array
,	O
0	int
)	O
;	O
y	int
=	O
2	int
;	O
for	O
(	O
i	int
=	O
bindkeydata	struct
->	O
pos	int
;	O
i	int
<	O
KMAP_KEYS	O
+	O
KMAP_AKEYS	O
+	O
kmap_extn	int
&&	O
y	int
<	O
flayer	pointer
->	O
l_height	int
-	O
3	int
;	O
i	int
++	O
)	O
{	O
p	pointer
=	O
tbuf	array
;	O
xch	pointer
=	O
"   "	pointer
;	O
if	O
(	O
i	int
<	O
KMAP_KEYS	O
)	O
{	O
act	pointer
=	O
&	O
bindkeydata	struct
->	O
tab	pointer
[	O
i	int
]	O
;	O
if	O
(	O
act	pointer
->	O
nr	int
==	O
RC_ILLEGAL	O
)	O
continue	O
;	O
del	int
=	O
*	O
p	pointer
++	O
=	O
':'	O
;	O
s	pointer
=	O
term	struct
[	O
i	int
+	O
T_CAPS	int
]	O
.	O
tcname	pointer
;	O
sl	int
=	O
s	pointer
?	O
strlen	function
(	O
s	pointer
)	O
:	O
0	int
;	O
}	O
else	O
if	O
(	O
i	int
<	O
KMAP_KEYS	O
+	O
KMAP_AKEYS	O
)	O
{	O
act	pointer
=	O
&	O
bindkeydata	struct
->	O
tab	pointer
[	O
i	int
]	O
;	O
if	O
(	O
act	pointer
->	O
nr	int
==	O
RC_ILLEGAL	O
)	O
continue	O
;	O
del	int
=	O
*	O
p	pointer
++	O
=	O
':'	O
;	O
s	pointer
=	O
term	struct
[	O
i	int
+	O
(	O
T_CAPS	int
-	O
T_OCAPS	int
+	O
T_CURSOR	int
)	O
]	O
.	O
tcname	pointer
;	O
sl	int
=	O
s	pointer
?	O
strlen	function
(	O
s	pointer
)	O
:	O
0	int
;	O
xch	pointer
=	O
"[A]"	pointer
;	O
}	O
else	O
{	O
kme	pointer
=	O
kmap_exts	pointer
+	O
(	O
i	int
-	O
(	O
KMAP_KEYS	O
+	O
KMAP_AKEYS	O
)	O
)	O
;	O
del	int
=	O
0	int
;	O
s	pointer
=	O
kme	pointer
->	O
str	pointer
;	O
sl	int
=	O
kme	pointer
->	O
fl	int
&	O
~	O
KMAP_NOTIMEOUT	int
;	O
if	O
(	O
(	O
kme	pointer
->	O
fl	int
&	O
KMAP_NOTIMEOUT	int
)	O
!=	O
0	int
)	O
xch	pointer
=	O
"[T]"	pointer
;	O
act	pointer
=	O
bindkeydata	struct
->	O
tab	pointer
==	O
dmtab	array
?	O
&	O
kme	pointer
->	O
dm	struct
:	O
bindkeydata	struct
->	O
tab	pointer
==	O
mmtab	array
?	O
&	O
kme	pointer
->	O
mm	struct
:	O
&	O
kme	pointer
->	O
um	struct
;	O
if	O
(	O
act	pointer
->	O
nr	int
==	O
RC_ILLEGAL	O
)	O
continue	O
;	O
}	O
while	O
(	O
sl	int
--	O
>	O
0	int
)	O
p	pointer
+=	O
AddXChar	function
(	O
p	pointer
,	O
*	O
(	O
unsigned	O
char	O
*	O
)	O
s	pointer
++	O
)	O
;	O
if	O
(	O
del	int
)	O
*	O
p	pointer
++	O
=	O
del	int
;	O
*	O
p	pointer
++	O
=	O
' '	O
;	O
while	O
(	O
p	pointer
<	O
tbuf	array
+	O
15	int
)	O
*	O
p	pointer
++	O
=	O
' '	O
;	O
sprintf	function
(	O
p	pointer
,	O
"%s -> "	pointer
,	O
xch	pointer
)	O
;	O
p	pointer
+=	O
7	int
;	O
if	O
(	O
p	pointer
-	O
tbuf	array
>	O
flayer	pointer
->	O
l_width	int
-	O
1	int
)	O
{	O
tbuf	array
[	O
flayer	pointer
->	O
l_width	int
-	O
2	int
]	O
=	O
'$'	O
;	O
tbuf	array
[	O
flayer	pointer
->	O
l_width	int
-	O
1	int
]	O
=	O
0	int
;	O
}	O
PadStr	function
(	O
tbuf	array
,	O
strlen	function
(	O
tbuf	array
)	O
,	O
0	int
,	O
y	int
)	O
;	O
AddAction	function
(	O
act	pointer
,	O
strlen	function
(	O
tbuf	array
)	O
,	O
y	int
)	O
;	O
y	int
++	O
;	O
}	O
y	int
++	O
;	O
bindkeydata	struct
->	O
last	int
=	O
i	int
;	O
sprintf	function
(	O
tbuf	array
,	O
"[Press Space %s Return to end.]"	pointer
,	O
bindkeydata	struct
->	O
page	int
<	O
bindkeydata	struct
->	O
pages	int
?	O
"for next page;"	pointer
:	O
"or"	pointer
)	O
;	O
centerline	function
(	O
tbuf	array
,	O
flayer	pointer
->	O
l_height	int
-	O
2	int
)	O
;	O
LaySetCursor	O
(	O
)	O
;	O
}	O
static	O
void	O
BindkeyProcess	function
(	O
char	O
*	O
*	O
ppbuf	pointer
,	O
int	O
*	O
plen	pointer
)	O
{	O
int	O
done	int
=	O
0	int
;	O
struct	O
bindkeydata	struct
*	O
bindkeydata	struct
;	O
bindkeydata	struct
=	O
(	O
struct	O
bindkeydata	struct
*	O
)	O
flayer	pointer
->	O
l_data	pointer
;	O
while	O
(	O
!	O
done	int
&&	O
*	O
plen	pointer
>	O
0	int
)	O
{	O
switch	O
(	O
*	O
*	O
ppbuf	pointer
)	O
{	O
case	O
' '	O
:	O
if	O
(	O
bindkeydata	struct
->	O
page	int
<	O
bindkeydata	struct
->	O
pages	int
)	O
{	O
bindkeydata	struct
->	O
pos	int
=	O
bindkeydata	struct
->	O
last	int
;	O
bindkeydata	struct
->	O
page	int
++	O
;	O
bindkeypage	function
(	O
)	O
;	O
break	O
;	O
}	O
case	O
'\r'	O
:	O
case	O
'\n'	O
:	O
done	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
++	O
*	O
ppbuf	pointer
;	O
--	O
*	O
plen	pointer
;	O
}	O
if	O
(	O
done	int
)	O
BindkeyAbort	function
(	O
)	O
;	O
}	O
static	O
void	O
BindkeyRedisplayLine	function
(	O
int	O
y	int
,	O
int	O
xs	int
,	O
int	O
xe	int
,	O
int	O
isblank	int
)	O
{	O
if	O
(	O
y	int
<	O
0	int
)	O
{	O
bindkeypage	function
(	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
y	int
!=	O
0	int
&&	O
y	int
!=	O
flayer	pointer
->	O
l_height	int
-	O
1	int
)	O
return	O
;	O
if	O
(	O
!	O
isblank	int
)	O
LClearArea	function
(	O
flayer	pointer
,	O
xs	int
,	O
y	int
,	O
xe	int
,	O
y	int
,	O
0	int
,	O
0	int
)	O
;	O
}	O
static	O
void	O
ZmodemRedisplayLine	function
__P	O
(	O
(	O
int	O
,	O
int	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
int	O
ZmodemResize	function
__P	O
(	O
(	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
struct	O
LayFuncs	struct
ZmodemLf	struct
=	O
{	O
DefProcess	function
,	O
0	int
,	O
ZmodemRedisplayLine	function
,	O
DefClearLine	function
,	O
DefRewrite	function
,	O
ZmodemResize	function
,	O
DefRestore	function
,	O
0	int
}	O
;	O
static	O
int	O
ZmodemResize	function
(	O
int	O
wi	int
,	O
int	O
he	int
)	O
{	O
flayer	pointer
->	O
l_width	int
=	O
wi	int
;	O
flayer	pointer
->	O
l_height	int
=	O
he	int
;	O
flayer	pointer
->	O
l_x	int
=	O
flayer	pointer
->	O
l_width	int
>	O
32	int
?	O
32	int
:	O
0	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
ZmodemRedisplayLine	function
(	O
int	O
y	int
,	O
int	O
xs	int
,	O
int	O
xe	int
,	O
int	O
isblank	int
)	O
{	O
DefRedisplayLine	function
(	O
y	int
,	O
xs	int
,	O
xe	int
,	O
isblank	int
)	O
;	O
if	O
(	O
y	int
==	O
0	int
&&	O
xs	int
==	O
0	int
)	O
LPutStr	function
(	O
flayer	pointer
,	O
"Zmodem active on another display"	pointer
,	O
flayer	pointer
->	O
l_width	int
>	O
32	int
?	O
32	int
:	O
flayer	pointer
->	O
l_width	int
,	O
&	O
mchar_blank	struct
,	O
0	int
,	O
0	int
)	O
;	O
}	O
void	O
ZmodemPage	function
(	O
)	O
{	O
if	O
(	O
InitOverlayPage	function
(	O
1	int
,	O
&	O
ZmodemLf	struct
,	O
1	int
)	O
)	O
return	O
;	O
LRefreshAll	function
(	O
flayer	pointer
,	O
0	int
)	O
;	O
flayer	pointer
->	O
l_x	int
=	O
flayer	pointer
->	O
l_width	int
>	O
32	int
?	O
32	int
:	O
0	int
;	O
flayer	pointer
->	O
l_y	int
=	O
0	int
;	O
}	O
static	O
void	O
PadStr	function
(	O
char	O
*	O
str	pointer
,	O
int	O
n	int
,	O
int	O
x	int
,	O
int	O
y	int
)	O
{	O
int	O
l	int
;	O
l	int
=	O
strlen	function
(	O
str	pointer
)	O
;	O
if	O
(	O
l	int
>	O
n	int
)	O
l	int
=	O
n	int
;	O
LPutStr	function
(	O
flayer	pointer
,	O
str	pointer
,	O
l	int
,	O
&	O
mchar_blank	struct
,	O
x	int
,	O
y	int
)	O
;	O
if	O
(	O
l	int
<	O
n	int
)	O
LPutStr	function
(	O
flayer	pointer
,	O
(	O
char	O
*	O
)	O
blank	pointer
,	O
n	int
-	O
l	int
,	O
&	O
mchar_blank	struct
,	O
x	int
+	O
l	int
,	O
y	int
)	O
;	O
}	O
