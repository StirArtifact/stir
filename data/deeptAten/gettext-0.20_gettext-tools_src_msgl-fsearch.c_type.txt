typedef	O
unsigned	O
int	O
index_ty	int
;	O
typedef	O
index_ty	int
*	O
index_list_ty	pointer
;	O
static	O
inline	O
index_list_ty	pointer
new_index	function
(	O
index_ty	int
idx	int
)	O
{	O
index_ty	int
*	O
list	pointer
=	O
XNMALLOC	O
(	O
2	int
+	O
1	int
,	O
index_ty	int
)	O
;	O
list	pointer
[	O
IL_ALLOCATED	int
]	O
=	O
1	int
;	O
list	pointer
[	O
IL_LENGTH	int
]	O
=	O
1	int
;	O
list	pointer
[	O
2	int
]	O
=	O
idx	int
;	O
return	O
list	pointer
;	O
}	O
static	O
inline	O
index_list_ty	pointer
addlast_index	function
(	O
index_list_ty	pointer
list	pointer
,	O
index_ty	int
idx	int
)	O
{	O
index_list_ty	pointer
result	pointer
;	O
size_t	long
length	long
=	O
list	pointer
[	O
IL_LENGTH	int
]	O
;	O
if	O
(	O
length	long
>	O
0	int
&&	O
list	pointer
[	O
2	int
+	O
(	O
length	long
-	O
1	int
)	O
]	O
==	O
idx	int
)	O
return	O
NULL	O
;	O
result	pointer
=	O
NULL	O
;	O
if	O
(	O
length	long
==	O
list	pointer
[	O
IL_ALLOCATED	int
]	O
)	O
{	O
size_t	long
new_allocated	long
=	O
2	int
*	O
length	long
-	O
(	O
length	long
>>	O
6	int
)	O
;	O
list	pointer
=	O
(	O
index_ty	int
*	O
)	O
xrealloc	function
(	O
list	pointer
,	O
(	O
2	int
+	O
new_allocated	long
)	O
*	O
sizeof	O
(	O
index_ty	int
)	O
)	O
;	O
list	pointer
[	O
IL_ALLOCATED	int
]	O
=	O
new_allocated	long
;	O
result	pointer
=	O
list	pointer
;	O
}	O
list	pointer
[	O
2	int
+	O
length	long
]	O
=	O
idx	int
;	O
list	pointer
[	O
IL_LENGTH	int
]	O
=	O
length	long
+	O
1	int
;	O
return	O
result	pointer
;	O
}	O
static	O
inline	O
index_list_ty	pointer
add_index	function
(	O
index_list_ty	pointer
list	pointer
,	O
index_ty	int
idx	int
)	O
{	O
index_list_ty	pointer
result	pointer
;	O
size_t	long
length	long
=	O
list	pointer
[	O
IL_LENGTH	int
]	O
;	O
size_t	long
lo	long
=	O
0	int
;	O
size_t	long
hi	long
=	O
length	long
;	O
while	O
(	O
lo	long
<	O
hi	long
)	O
{	O
size_t	long
mid	long
=	O
(	O
lo	long
+	O
hi	long
)	O
/	O
2	int
;	O
index_ty	int
val	int
=	O
list	pointer
[	O
2	int
+	O
mid	long
]	O
;	O
if	O
(	O
val	int
<	O
idx	int
)	O
lo	long
=	O
mid	long
+	O
1	int
;	O
else	O
if	O
(	O
val	int
>	O
idx	int
)	O
hi	long
=	O
mid	long
;	O
else	O
return	O
NULL	O
;	O
}	O
result	pointer
=	O
NULL	O
;	O
if	O
(	O
length	long
==	O
list	pointer
[	O
IL_ALLOCATED	int
]	O
)	O
{	O
size_t	long
new_allocated	long
=	O
2	int
*	O
length	long
-	O
(	O
length	long
>>	O
6	int
)	O
;	O
list	pointer
=	O
(	O
index_ty	int
*	O
)	O
xrealloc	function
(	O
list	pointer
,	O
(	O
2	int
+	O
new_allocated	long
)	O
*	O
sizeof	O
(	O
index_ty	int
)	O
)	O
;	O
list	pointer
[	O
IL_ALLOCATED	int
]	O
=	O
new_allocated	long
;	O
result	pointer
=	O
list	pointer
;	O
}	O
list	pointer
[	O
IL_LENGTH	int
]	O
=	O
length	long
+	O
1	int
;	O
for	O
(	O
;	O
length	long
>	O
hi	long
;	O
length	long
--	O
)	O
list	pointer
[	O
2	int
+	O
length	long
]	O
=	O
list	pointer
[	O
1	int
+	O
length	long
]	O
;	O
list	pointer
[	O
2	int
+	O
length	long
]	O
=	O
idx	int
;	O
return	O
result	pointer
;	O
}	O
struct	O
message_fuzzy_index_ty	struct
{	O
message_ty	struct
*	O
*	O
messages	pointer
;	O
character_iterator_t	pointer
iterator	pointer
;	O
hash_table	struct
gram4	struct
;	O
size_t	long
firstfew	long
;	O
message_list_ty	struct
*	O
*	O
short_messages	pointer
;	O
}	O
;	O
message_fuzzy_index_ty	struct
*	O
message_fuzzy_index_alloc	function
(	O
const	O
message_list_ty	struct
*	O
mlp	pointer
,	O
const	O
char	O
*	O
canon_charset	pointer
)	O
{	O
message_fuzzy_index_ty	struct
*	O
findex	pointer
=	O
XMALLOC	O
(	O
message_fuzzy_index_ty	struct
)	O
;	O
size_t	long
count	long
=	O
mlp	pointer
->	O
nitems	long
;	O
size_t	long
j	long
;	O
size_t	long
l	long
;	O
findex	pointer
->	O
messages	pointer
=	O
mlp	pointer
->	O
item	pointer
;	O
findex	pointer
->	O
iterator	pointer
=	O
po_charset_character_iterator	function
(	O
canon_charset	pointer
)	O
;	O
if	O
(	O
hash_init	function
(	O
&	O
findex	pointer
->	O
gram4	struct
,	O
10	int
*	O
count	long
)	O
<	O
0	int
)	O
xalloc_die	function
(	O
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
count	long
;	O
j	long
++	O
)	O
{	O
message_ty	struct
*	O
mp	pointer
=	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
;	O
if	O
(	O
mp	pointer
->	O
msgstr	pointer
!=	O
NULL	O
&&	O
mp	pointer
->	O
msgstr	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
const	O
char	O
*	O
str	pointer
=	O
mp	pointer
->	O
msgid	pointer
;	O
const	O
char	O
*	O
p0	pointer
=	O
str	pointer
;	O
if	O
(	O
*	O
p0	pointer
!=	O
'\0'	O
)	O
{	O
const	O
char	O
*	O
p1	pointer
=	O
p0	pointer
+	O
findex	pointer
->	O
iterator	pointer
(	O
p0	pointer
)	O
;	O
if	O
(	O
*	O
p1	pointer
!=	O
'\0'	O
)	O
{	O
const	O
char	O
*	O
p2	pointer
=	O
p1	pointer
+	O
findex	pointer
->	O
iterator	pointer
(	O
p1	pointer
)	O
;	O
if	O
(	O
*	O
p2	pointer
!=	O
'\0'	O
)	O
{	O
const	O
char	O
*	O
p3	pointer
=	O
p2	pointer
+	O
findex	pointer
->	O
iterator	pointer
(	O
p2	pointer
)	O
;	O
if	O
(	O
*	O
p3	pointer
!=	O
'\0'	O
)	O
{	O
const	O
char	O
*	O
p4	pointer
=	O
p3	pointer
+	O
findex	pointer
->	O
iterator	pointer
(	O
p3	pointer
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
void	O
*	O
found	pointer
;	O
if	O
(	O
hash_find_entry	function
(	O
&	O
findex	pointer
->	O
gram4	struct
,	O
p0	pointer
,	O
p4	pointer
-	O
p0	pointer
,	O
&	O
found	pointer
)	O
==	O
0	int
)	O
{	O
index_list_ty	pointer
list	pointer
=	O
(	O
index_list_ty	pointer
)	O
found	pointer
;	O
list	pointer
=	O
addlast_index	function
(	O
list	pointer
,	O
j	long
)	O
;	O
if	O
(	O
list	pointer
!=	O
NULL	O
)	O
hash_set_value	function
(	O
&	O
findex	pointer
->	O
gram4	struct
,	O
p0	pointer
,	O
p4	pointer
-	O
p0	pointer
,	O
list	pointer
)	O
;	O
}	O
else	O
hash_insert_entry	function
(	O
&	O
findex	pointer
->	O
gram4	struct
,	O
p0	pointer
,	O
p4	pointer
-	O
p0	pointer
,	O
new_index	function
(	O
j	long
)	O
)	O
;	O
if	O
(	O
*	O
p4	pointer
==	O
'\0'	O
)	O
break	O
;	O
p0	pointer
=	O
p1	pointer
;	O
p1	pointer
=	O
p2	pointer
;	O
p2	pointer
=	O
p3	pointer
;	O
p3	pointer
=	O
p4	pointer
;	O
p4	pointer
=	O
p4	pointer
+	O
findex	pointer
->	O
iterator	pointer
(	O
p4	pointer
)	O
;	O
}	O
}	O
}	O
}	O
}	O
}	O
}	O
{	O
void	O
*	O
iter	pointer
;	O
const	O
void	O
*	O
key	pointer
;	O
size_t	long
keylen	long
;	O
void	O
*	O
*	O
valuep	pointer
;	O
iter	pointer
=	O
NULL	O
;	O
while	O
(	O
hash_iterate_modify	function
(	O
&	O
findex	pointer
->	O
gram4	struct
,	O
&	O
iter	pointer
,	O
&	O
key	pointer
,	O
&	O
keylen	long
,	O
&	O
valuep	pointer
)	O
==	O
0	int
)	O
{	O
index_list_ty	pointer
list	pointer
=	O
(	O
index_list_ty	pointer
)	O
*	O
valuep	pointer
;	O
index_ty	int
length	long
=	O
list	pointer
[	O
IL_LENGTH	int
]	O
;	O
if	O
(	O
length	long
<	O
list	pointer
[	O
IL_ALLOCATED	int
]	O
)	O
{	O
list	pointer
[	O
IL_ALLOCATED	int
]	O
=	O
length	long
;	O
*	O
valuep	pointer
=	O
xrealloc	function
(	O
list	pointer
,	O
(	O
2	int
+	O
length	long
)	O
*	O
sizeof	O
(	O
index_ty	int
)	O
)	O
;	O
}	O
}	O
}	O
findex	pointer
->	O
firstfew	long
=	O
(	O
int	O
)	O
sqrt	function
(	O
(	O
double	O
)	O
count	long
)	O
;	O
if	O
(	O
findex	pointer
->	O
firstfew	long
<	O
10	int
)	O
findex	pointer
->	O
firstfew	long
=	O
10	int
;	O
findex	pointer
->	O
short_messages	pointer
=	O
XNMALLOC	O
(	O
SHORT_MSG_MAX	O
+	O
1	int
,	O
message_list_ty	struct
*	O
)	O
;	O
for	O
(	O
l	long
=	O
0	int
;	O
l	long
<=	O
SHORT_MSG_MAX	O
;	O
l	long
++	O
)	O
findex	pointer
->	O
short_messages	pointer
[	O
l	long
]	O
=	O
message_list_alloc	function
(	O
false	int
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
count	long
;	O
j	long
++	O
)	O
{	O
message_ty	struct
*	O
mp	pointer
=	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
;	O
if	O
(	O
mp	pointer
->	O
msgstr	pointer
!=	O
NULL	O
&&	O
mp	pointer
->	O
msgstr	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
const	O
char	O
*	O
str	pointer
=	O
mp	pointer
->	O
msgid	pointer
;	O
size_t	long
len	long
=	O
strlen	function
(	O
str	pointer
)	O
;	O
if	O
(	O
len	long
<=	O
SHORT_MSG_MAX	O
)	O
message_list_append	function
(	O
findex	pointer
->	O
short_messages	pointer
[	O
len	long
]	O
,	O
mp	pointer
)	O
;	O
}	O
}	O
for	O
(	O
l	long
=	O
0	int
;	O
l	long
<=	O
SHORT_MSG_MAX	O
;	O
l	long
++	O
)	O
{	O
message_list_ty	struct
*	O
mlp	pointer
=	O
findex	pointer
->	O
short_messages	pointer
[	O
l	long
]	O
;	O
if	O
(	O
mlp	pointer
->	O
nitems	long
<	O
mlp	pointer
->	O
nitems_max	long
)	O
{	O
mlp	pointer
->	O
nitems_max	long
=	O
mlp	pointer
->	O
nitems	long
;	O
mlp	pointer
->	O
item	pointer
=	O
(	O
message_ty	struct
*	O
*	O
)	O
xrealloc	function
(	O
mlp	pointer
->	O
item	pointer
,	O
mlp	pointer
->	O
nitems_max	long
*	O
sizeof	O
(	O
message_ty	struct
*	O
)	O
)	O
;	O
}	O
}	O
return	O
findex	pointer
;	O
}	O
struct	O
mult_index	struct
{	O
index_ty	int
index	function
;	O
unsigned	O
int	O
count	long
;	O
}	O
;	O
struct	O
mult_index_list	struct
{	O
struct	O
mult_index	struct
*	O
item	pointer
;	O
size_t	long
nitems	long
;	O
size_t	long
nitems_max	long
;	O
struct	O
mult_index	struct
*	O
item2	pointer
;	O
size_t	long
nitems2_max	long
;	O
}	O
;	O
static	O
inline	O
void	O
mult_index_list_init	function
(	O
struct	O
mult_index_list	struct
*	O
accu	pointer
)	O
{	O
accu	pointer
->	O
nitems	long
=	O
0	int
;	O
accu	pointer
->	O
nitems_max	long
=	O
0	int
;	O
accu	pointer
->	O
item	pointer
=	O
NULL	O
;	O
accu	pointer
->	O
nitems2_max	long
=	O
0	int
;	O
accu	pointer
->	O
item2	pointer
=	O
NULL	O
;	O
}	O
static	O
inline	O
void	O
mult_index_list_accumulate	function
(	O
struct	O
mult_index_list	struct
*	O
accu	pointer
,	O
index_list_ty	pointer
list	pointer
)	O
{	O
size_t	long
len1	long
=	O
accu	pointer
->	O
nitems	long
;	O
size_t	long
len2	long
=	O
list	pointer
[	O
IL_LENGTH	int
]	O
;	O
size_t	long
need	long
=	O
len1	long
+	O
len2	long
;	O
struct	O
mult_index	struct
*	O
ptr1	pointer
;	O
struct	O
mult_index	struct
*	O
ptr1_end	pointer
;	O
index_ty	int
*	O
ptr2	pointer
;	O
index_ty	int
*	O
ptr2_end	pointer
;	O
struct	O
mult_index	struct
*	O
destptr	pointer
;	O
if	O
(	O
accu	pointer
->	O
nitems2_max	long
<	O
need	long
)	O
{	O
size_t	long
new_max	long
=	O
2	int
*	O
accu	pointer
->	O
nitems2_max	long
+	O
1	int
;	O
if	O
(	O
new_max	long
<	O
need	long
)	O
new_max	long
=	O
need	long
;	O
if	O
(	O
accu	pointer
->	O
item2	pointer
!=	O
NULL	O
)	O
free	function
(	O
accu	pointer
->	O
item2	pointer
)	O
;	O
accu	pointer
->	O
item2	pointer
=	O
XNMALLOC	O
(	O
new_max	long
,	O
struct	O
mult_index	struct
)	O
;	O
accu	pointer
->	O
nitems2_max	long
=	O
new_max	long
;	O
}	O
ptr1	pointer
=	O
accu	pointer
->	O
item	pointer
;	O
ptr1_end	pointer
=	O
ptr1	pointer
+	O
len1	long
;	O
ptr2	pointer
=	O
list	pointer
+	O
2	int
;	O
ptr2_end	pointer
=	O
ptr2	pointer
+	O
len2	long
;	O
destptr	pointer
=	O
accu	pointer
->	O
item2	pointer
;	O
while	O
(	O
ptr1	pointer
<	O
ptr1_end	pointer
&&	O
ptr2	pointer
<	O
ptr2_end	pointer
)	O
{	O
if	O
(	O
ptr1	pointer
->	O
index	function
<	O
*	O
ptr2	pointer
)	O
{	O
*	O
destptr	pointer
=	O
*	O
ptr1	pointer
;	O
ptr1	pointer
++	O
;	O
}	O
else	O
if	O
(	O
ptr1	pointer
->	O
index	function
>	O
*	O
ptr2	pointer
)	O
{	O
destptr	pointer
->	O
index	function
=	O
*	O
ptr2	pointer
;	O
destptr	pointer
->	O
count	long
=	O
1	int
;	O
ptr2	pointer
++	O
;	O
}	O
else	O
{	O
destptr	pointer
->	O
index	function
=	O
ptr1	pointer
->	O
index	function
;	O
destptr	pointer
->	O
count	long
=	O
ptr1	pointer
->	O
count	long
+	O
1	int
;	O
ptr1	pointer
++	O
;	O
ptr2	pointer
++	O
;	O
}	O
destptr	pointer
++	O
;	O
}	O
while	O
(	O
ptr1	pointer
<	O
ptr1_end	pointer
)	O
{	O
*	O
destptr	pointer
=	O
*	O
ptr1	pointer
;	O
ptr1	pointer
++	O
;	O
destptr	pointer
++	O
;	O
}	O
while	O
(	O
ptr2	pointer
<	O
ptr2_end	pointer
)	O
{	O
destptr	pointer
->	O
index	function
=	O
*	O
ptr2	pointer
;	O
destptr	pointer
->	O
count	long
=	O
1	int
;	O
ptr2	pointer
++	O
;	O
destptr	pointer
++	O
;	O
}	O
{	O
struct	O
mult_index	struct
*	O
dest	pointer
=	O
accu	pointer
->	O
item2	pointer
;	O
size_t	long
dest_max	long
=	O
accu	pointer
->	O
nitems2_max	long
;	O
accu	pointer
->	O
item2	pointer
=	O
accu	pointer
->	O
item	pointer
;	O
accu	pointer
->	O
nitems2_max	long
=	O
accu	pointer
->	O
nitems_max	long
;	O
accu	pointer
->	O
item	pointer
=	O
dest	pointer
;	O
accu	pointer
->	O
nitems	long
=	O
destptr	pointer
-	O
dest	pointer
;	O
accu	pointer
->	O
nitems_max	long
=	O
dest_max	long
;	O
}	O
}	O
static	O
int	O
mult_index_compare	function
(	O
const	O
void	O
*	O
p1	pointer
,	O
const	O
void	O
*	O
p2	pointer
)	O
{	O
const	O
struct	O
mult_index	struct
*	O
ptr1	pointer
=	O
(	O
const	O
struct	O
mult_index	struct
*	O
)	O
p1	pointer
;	O
const	O
struct	O
mult_index	struct
*	O
ptr2	pointer
=	O
(	O
const	O
struct	O
mult_index	struct
*	O
)	O
p2	pointer
;	O
if	O
(	O
ptr1	pointer
->	O
count	long
<	O
ptr2	pointer
->	O
count	long
)	O
return	O
1	int
;	O
if	O
(	O
ptr1	pointer
->	O
count	long
>	O
ptr2	pointer
->	O
count	long
)	O
return	O
-	O
1	int
;	O
if	O
(	O
ptr1	pointer
->	O
index	function
>	O
ptr2	pointer
->	O
index	function
)	O
return	O
1	int
;	O
if	O
(	O
ptr1	pointer
->	O
index	function
<	O
ptr2	pointer
->	O
index	function
)	O
return	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
inline	O
void	O
mult_index_list_sort	function
(	O
struct	O
mult_index_list	struct
*	O
accu	pointer
)	O
{	O
if	O
(	O
accu	pointer
->	O
nitems	long
>	O
1	int
)	O
qsort	function
(	O
accu	pointer
->	O
item	pointer
,	O
accu	pointer
->	O
nitems	long
,	O
sizeof	O
(	O
struct	O
mult_index	struct
)	O
,	O
mult_index_compare	function
)	O
;	O
}	O
static	O
inline	O
void	O
mult_index_list_free	function
(	O
struct	O
mult_index_list	struct
*	O
accu	pointer
)	O
{	O
if	O
(	O
accu	pointer
->	O
item	pointer
!=	O
NULL	O
)	O
free	function
(	O
accu	pointer
->	O
item	pointer
)	O
;	O
if	O
(	O
accu	pointer
->	O
item2	pointer
!=	O
NULL	O
)	O
free	function
(	O
accu	pointer
->	O
item2	pointer
)	O
;	O
}	O
message_ty	struct
*	O
message_fuzzy_index_search	function
(	O
message_fuzzy_index_ty	struct
*	O
findex	pointer
,	O
const	O
char	O
*	O
msgctxt	pointer
,	O
const	O
char	O
*	O
msgid	pointer
,	O
double	O
lower_bound	double
,	O
bool	bool
heuristic	bool
)	O
{	O
const	O
char	O
*	O
str	pointer
=	O
msgid	pointer
;	O
const	O
char	O
*	O
p0	pointer
=	O
str	pointer
;	O
if	O
(	O
*	O
p0	pointer
!=	O
'\0'	O
)	O
{	O
const	O
char	O
*	O
p1	pointer
=	O
p0	pointer
+	O
findex	pointer
->	O
iterator	pointer
(	O
p0	pointer
)	O
;	O
if	O
(	O
*	O
p1	pointer
!=	O
'\0'	O
)	O
{	O
const	O
char	O
*	O
p2	pointer
=	O
p1	pointer
+	O
findex	pointer
->	O
iterator	pointer
(	O
p1	pointer
)	O
;	O
if	O
(	O
*	O
p2	pointer
!=	O
'\0'	O
)	O
{	O
const	O
char	O
*	O
p3	pointer
=	O
p2	pointer
+	O
findex	pointer
->	O
iterator	pointer
(	O
p2	pointer
)	O
;	O
if	O
(	O
*	O
p3	pointer
!=	O
'\0'	O
)	O
{	O
const	O
char	O
*	O
p4	pointer
=	O
p3	pointer
+	O
findex	pointer
->	O
iterator	pointer
(	O
p3	pointer
)	O
;	O
struct	O
mult_index_list	struct
accu	pointer
;	O
mult_index_list_init	function
(	O
&	O
accu	pointer
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
void	O
*	O
found	pointer
;	O
if	O
(	O
hash_find_entry	function
(	O
&	O
findex	pointer
->	O
gram4	struct
,	O
p0	pointer
,	O
p4	pointer
-	O
p0	pointer
,	O
&	O
found	pointer
)	O
==	O
0	int
)	O
{	O
index_list_ty	pointer
list	pointer
=	O
(	O
index_list_ty	pointer
)	O
found	pointer
;	O
mult_index_list_accumulate	function
(	O
&	O
accu	pointer
,	O
list	pointer
)	O
;	O
}	O
if	O
(	O
*	O
p4	pointer
==	O
'\0'	O
)	O
break	O
;	O
p0	pointer
=	O
p1	pointer
;	O
p1	pointer
=	O
p2	pointer
;	O
p2	pointer
=	O
p3	pointer
;	O
p3	pointer
=	O
p4	pointer
;	O
p4	pointer
=	O
p4	pointer
+	O
findex	pointer
->	O
iterator	pointer
(	O
p4	pointer
)	O
;	O
}	O
mult_index_list_sort	function
(	O
&	O
accu	pointer
)	O
;	O
{	O
size_t	long
count	long
;	O
struct	O
mult_index	struct
*	O
ptr	pointer
;	O
message_ty	struct
*	O
best_mp	pointer
;	O
double	O
best_weight	double
;	O
count	long
=	O
accu	pointer
.	O
nitems	long
;	O
if	O
(	O
heuristic	bool
)	O
{	O
if	O
(	O
count	long
>	O
findex	pointer
->	O
firstfew	long
)	O
count	long
=	O
findex	pointer
->	O
firstfew	long
;	O
}	O
best_weight	double
=	O
lower_bound	double
;	O
best_mp	pointer
=	O
NULL	O
;	O
for	O
(	O
ptr	pointer
=	O
accu	pointer
.	O
item	pointer
;	O
count	long
>	O
0	int
;	O
ptr	pointer
++	O
,	O
count	long
--	O
)	O
{	O
message_ty	struct
*	O
mp	pointer
=	O
findex	pointer
->	O
messages	pointer
[	O
ptr	pointer
->	O
index	function
]	O
;	O
double	O
weight	double
=	O
fuzzy_search_goal_function	function
(	O
mp	pointer
,	O
msgctxt	pointer
,	O
msgid	pointer
,	O
best_weight	double
)	O
;	O
if	O
(	O
weight	double
>	O
best_weight	double
)	O
{	O
best_weight	double
=	O
weight	double
;	O
best_mp	pointer
=	O
mp	pointer
;	O
}	O
}	O
mult_index_list_free	function
(	O
&	O
accu	pointer
)	O
;	O
return	O
best_mp	pointer
;	O
}	O
}	O
}	O
}	O
}	O
{	O
size_t	long
l	long
=	O
strlen	function
(	O
str	pointer
)	O
;	O
size_t	long
lmin	long
,	O
lmax	long
;	O
message_ty	struct
*	O
best_mp	pointer
;	O
double	O
best_weight	double
;	O
if	O
(	O
!	O
(	O
l	long
<=	O
SHORT_STRING_MAX_BYTES	O
)	O
)	O
abort	function
(	O
)	O
;	O
lmin	long
=	O
(	O
int	O
)	O
ceil	function
(	O
l	long
/	O
(	O
2	int
/	O
FUZZY_THRESHOLD	int
-	O
1	int
)	O
)	O
;	O
lmax	long
=	O
(	O
int	O
)	O
(	O
l	long
*	O
(	O
2	int
/	O
FUZZY_THRESHOLD	int
-	O
1	int
)	O
)	O
;	O
if	O
(	O
!	O
(	O
lmax	long
<=	O
SHORT_MSG_MAX	O
)	O
)	O
abort	function
(	O
)	O
;	O
best_weight	double
=	O
lower_bound	double
;	O
best_mp	pointer
=	O
NULL	O
;	O
for	O
(	O
l	long
=	O
lmin	long
;	O
l	long
<=	O
lmax	long
;	O
l	long
++	O
)	O
{	O
message_list_ty	struct
*	O
mlp	pointer
=	O
findex	pointer
->	O
short_messages	pointer
[	O
l	long
]	O
;	O
size_t	long
j	long
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
mlp	pointer
->	O
nitems	long
;	O
j	long
++	O
)	O
{	O
message_ty	struct
*	O
mp	pointer
=	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
;	O
double	O
weight	double
=	O
fuzzy_search_goal_function	function
(	O
mp	pointer
,	O
msgctxt	pointer
,	O
msgid	pointer
,	O
best_weight	double
)	O
;	O
if	O
(	O
weight	double
>	O
best_weight	double
)	O
{	O
best_weight	double
=	O
weight	double
;	O
best_mp	pointer
=	O
mp	pointer
;	O
}	O
}	O
}	O
return	O
best_mp	pointer
;	O
}	O
}	O
void	O
message_fuzzy_index_free	function
(	O
message_fuzzy_index_ty	struct
*	O
findex	pointer
)	O
{	O
size_t	long
l	long
;	O
void	O
*	O
iter	pointer
;	O
const	O
void	O
*	O
key	pointer
;	O
size_t	long
keylen	long
;	O
void	O
*	O
data	pointer
;	O
for	O
(	O
l	long
=	O
0	int
;	O
l	long
<=	O
SHORT_MSG_MAX	O
;	O
l	long
++	O
)	O
message_list_free	function
(	O
findex	pointer
->	O
short_messages	pointer
[	O
l	long
]	O
,	O
1	int
)	O
;	O
free	function
(	O
findex	pointer
->	O
short_messages	pointer
)	O
;	O
iter	pointer
=	O
NULL	O
;	O
while	O
(	O
hash_iterate	function
(	O
&	O
findex	pointer
->	O
gram4	struct
,	O
&	O
iter	pointer
,	O
&	O
key	pointer
,	O
&	O
keylen	long
,	O
&	O
data	pointer
)	O
==	O
0	int
)	O
free	function
(	O
(	O
index_list_ty	pointer
*	O
)	O
data	pointer
)	O
;	O
hash_destroy	function
(	O
&	O
findex	pointer
->	O
gram4	struct
)	O
;	O
free	function
(	O
findex	pointer
)	O
;	O
}	O
