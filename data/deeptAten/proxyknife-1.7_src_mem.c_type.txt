void	O
xfree	function
(	O
void	O
*	O
*	O
p	pointer
)	O
{	O
assert	O
(	O
p	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
*	O
p	pointer
!=	O
NULL	O
)	O
free	function
(	O
*	O
p	pointer
)	O
;	O
*	O
p	pointer
=	O
NULL	O
;	O
}	O
void	O
mem_init	function
(	O
)	O
{	O
user_agent	pointer
=	O
NULL	O
;	O
logfilename	pointer
=	O
NULL	O
;	O
proxyknife_in	pointer
=	O
NULL	O
;	O
proxyknife_out	pointer
=	O
NULL	O
;	O
proxyknife_in_buffer	pointer
=	O
NULL	O
;	O
my	struct
.	O
myhost	pointer
=	O
NULL	O
;	O
my	struct
.	O
myuser	pointer
=	O
NULL	O
;	O
my	struct
.	O
mypass	pointer
=	O
NULL	O
;	O
my	struct
.	O
myuserpass	pointer
=	O
NULL	O
;	O
my	struct
.	O
header_auth	pointer
=	O
NULL	O
;	O
my	struct
.	O
socks5authreq	pointer
=	O
NULL	O
;	O
my	struct
.	O
buffer	pointer
=	O
NULL	O
;	O
target	struct
.	O
target	struct
=	O
NULL	O
;	O
target	struct
.	O
targethost	pointer
=	O
NULL	O
;	O
target	struct
.	O
targetport	pointer
=	O
NULL	O
;	O
target	struct
.	O
targetpath	pointer
=	O
NULL	O
;	O
target	struct
.	O
protocol	pointer
=	O
NULL	O
;	O
target	struct
.	O
key	pointer
=	O
NULL	O
;	O
target	struct
.	O
checkreqin	pointer
=	O
NULL	O
;	O
target	struct
.	O
req	pointer
=	O
NULL	O
;	O
target	struct
.	O
req_get_via_http_proxy	pointer
=	O
NULL	O
;	O
target	struct
.	O
con_via_http_proxy	pointer
=	O
NULL	O
;	O
}	O
void	O
xexit	function
(	O
int	O
status	int
)	O
{	O
if	O
(	O
logfilename	pointer
)	O
free	function
(	O
logfilename	pointer
)	O
;	O
if	O
(	O
user_agent	pointer
)	O
free	function
(	O
user_agent	pointer
)	O
;	O
if	O
(	O
target	struct
.	O
key	pointer
)	O
free	function
(	O
target	struct
.	O
key	pointer
)	O
;	O
if	O
(	O
proxyknife_in	pointer
)	O
free	function
(	O
proxyknife_in	pointer
)	O
;	O
if	O
(	O
proxyknife_out	pointer
)	O
free	function
(	O
proxyknife_out	pointer
)	O
;	O
if	O
(	O
proxyknife_in_buffer	pointer
)	O
free	function
(	O
proxyknife_in_buffer	pointer
)	O
;	O
if	O
(	O
my	struct
.	O
myhost	pointer
)	O
free	function
(	O
my	struct
.	O
myhost	pointer
)	O
;	O
if	O
(	O
my	struct
.	O
myuser	pointer
)	O
free	function
(	O
my	struct
.	O
myuser	pointer
)	O
;	O
if	O
(	O
my	struct
.	O
mypass	pointer
)	O
free	function
(	O
my	struct
.	O
mypass	pointer
)	O
;	O
if	O
(	O
my	struct
.	O
myuserpass	pointer
)	O
free	function
(	O
my	struct
.	O
myuserpass	pointer
)	O
;	O
if	O
(	O
my	struct
.	O
header_auth	pointer
)	O
free	function
(	O
my	struct
.	O
header_auth	pointer
)	O
;	O
if	O
(	O
my	struct
.	O
socks5authreq	pointer
)	O
free	function
(	O
my	struct
.	O
socks5authreq	pointer
)	O
;	O
if	O
(	O
my	struct
.	O
buffer	pointer
)	O
free	function
(	O
my	struct
.	O
buffer	pointer
)	O
;	O
if	O
(	O
target	struct
.	O
target	struct
)	O
free	function
(	O
target	struct
.	O
target	struct
)	O
;	O
if	O
(	O
target	struct
.	O
targethost	pointer
)	O
free	function
(	O
target	struct
.	O
targethost	pointer
)	O
;	O
if	O
(	O
target	struct
.	O
targetport	pointer
)	O
free	function
(	O
target	struct
.	O
targetport	pointer
)	O
;	O
if	O
(	O
target	struct
.	O
targetpath	pointer
)	O
free	function
(	O
target	struct
.	O
targetpath	pointer
)	O
;	O
if	O
(	O
target	struct
.	O
protocol	pointer
)	O
free	function
(	O
target	struct
.	O
protocol	pointer
)	O
;	O
if	O
(	O
target	struct
.	O
req	pointer
)	O
free	function
(	O
target	struct
.	O
req	pointer
)	O
;	O
if	O
(	O
target	struct
.	O
checkreqin	pointer
)	O
free	function
(	O
target	struct
.	O
checkreqin	pointer
)	O
;	O
if	O
(	O
target	struct
.	O
req_get_via_http_proxy	pointer
)	O
free	function
(	O
target	struct
.	O
req_get_via_http_proxy	pointer
)	O
;	O
if	O
(	O
target	struct
.	O
con_via_http_proxy	pointer
)	O
free	function
(	O
target	struct
.	O
con_via_http_proxy	pointer
)	O
;	O
exit	function
(	O
status	int
)	O
;	O
}	O
void	O
*	O
xmalloc	function
(	O
size_t	long
size	long
)	O
{	O
void	O
*	O
p	pointer
;	O
p	pointer
=	O
malloc	function
(	O
size	long
)	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: xmalloc:Need more memory\n"	pointer
,	O
progname	pointer
)	O
;	O
xexit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
else	O
{	O
return	O
p	pointer
;	O
}	O
}	O
void	O
*	O
xrealloc	function
(	O
void	O
*	O
ptr	pointer
,	O
size_t	long
size	long
)	O
{	O
void	O
*	O
p	pointer
;	O
p	pointer
=	O
realloc	function
(	O
ptr	pointer
,	O
size	long
)	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
{	O
xexit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
else	O
{	O
return	O
p	pointer
;	O
}	O
}	O
void	O
*	O
prealloc	function
(	O
void	O
*	O
ptr	pointer
,	O
size_t	long
size	long
,	O
struct	O
thread_mem	struct
*	O
thread_mem	struct
)	O
{	O
void	O
*	O
p	pointer
;	O
pthread_mutex_lock	function
(	O
&	O
counter_mutex_malloc	union
)	O
;	O
p	pointer
=	O
realloc	function
(	O
ptr	pointer
,	O
size	long
)	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
counter_mutex_malloc	union
)	O
;	O
return	O
NULL	O
;	O
}	O
else	O
{	O
pthread_mutex_unlock	function
(	O
&	O
counter_mutex_malloc	union
)	O
;	O
return	O
p	pointer
;	O
}	O
}	O
void	O
*	O
pmalloc	function
(	O
size_t	long
size	long
,	O
struct	O
thread_mem	struct
*	O
thread_mem	struct
)	O
{	O
void	O
*	O
p	pointer
;	O
pthread_mutex_lock	function
(	O
&	O
counter_mutex_malloc	union
)	O
;	O
p	pointer
=	O
malloc	function
(	O
size	long
)	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
counter_mutex_malloc	union
)	O
;	O
return	O
NULL	O
;	O
}	O
else	O
{	O
pthread_mutex_unlock	function
(	O
&	O
counter_mutex_malloc	union
)	O
;	O
return	O
p	pointer
;	O
}	O
}	O
void	O
thread_mem_init	function
(	O
struct	O
thread_mem	struct
*	O
thread_mem	struct
)	O
{	O
thread_mem	struct
->	O
line	pointer
=	O
NULL	O
;	O
thread_mem	struct
->	O
queue	struct
.	O
testproxy	pointer
=	O
NULL	O
;	O
thread_mem	struct
->	O
request	pointer
=	O
NULL	O
;	O
thread_mem	struct
->	O
reply	pointer
=	O
NULL	O
;	O
thread_mem	struct
->	O
queue	struct
.	O
proto_out	pointer
=	O
NULL	O
;	O
}	O
void	O
thread_mem_clean	function
(	O
struct	O
thread_mem	struct
*	O
thread_mem	struct
)	O
{	O
if	O
(	O
thread_mem	struct
->	O
line	pointer
)	O
pxfree	function
(	O
(	O
void	O
*	O
*	O
)	O
&	O
(	O
thread_mem	struct
->	O
line	pointer
)	O
)	O
;	O
if	O
(	O
thread_mem	struct
->	O
queue	struct
.	O
testproxy	pointer
)	O
pxfree	function
(	O
(	O
void	O
*	O
*	O
)	O
&	O
(	O
thread_mem	struct
->	O
queue	struct
.	O
testproxy	pointer
)	O
)	O
;	O
if	O
(	O
thread_mem	struct
->	O
request	pointer
)	O
pxfree	function
(	O
(	O
void	O
*	O
*	O
)	O
&	O
(	O
thread_mem	struct
->	O
request	pointer
)	O
)	O
;	O
if	O
(	O
thread_mem	struct
->	O
reply	pointer
)	O
pxfree	function
(	O
(	O
void	O
*	O
*	O
)	O
&	O
(	O
thread_mem	struct
->	O
reply	pointer
)	O
)	O
;	O
if	O
(	O
thread_mem	struct
->	O
queue	struct
.	O
proto_out	pointer
)	O
pxfree	function
(	O
(	O
void	O
*	O
*	O
)	O
&	O
(	O
thread_mem	struct
->	O
queue	struct
.	O
proto_out	pointer
)	O
)	O
;	O
}	O
void	O
pxfree	function
(	O
void	O
*	O
*	O
p	pointer
)	O
{	O
assert	O
(	O
p	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
*	O
p	pointer
)	O
free	function
(	O
*	O
p	pointer
)	O
;	O
*	O
p	pointer
=	O
NULL	O
;	O
}	O
void	O
x_pthread_exit	function
(	O
void	O
*	O
retval	pointer
,	O
struct	O
thread_mem	struct
*	O
thread_mem	struct
)	O
{	O
if	O
(	O
thread_mem	struct
->	O
line	pointer
)	O
free	function
(	O
thread_mem	struct
->	O
line	pointer
)	O
;	O
if	O
(	O
thread_mem	struct
->	O
queue	struct
.	O
testproxy	pointer
)	O
free	function
(	O
thread_mem	struct
->	O
queue	struct
.	O
testproxy	pointer
)	O
;	O
if	O
(	O
thread_mem	struct
->	O
request	pointer
)	O
free	function
(	O
thread_mem	struct
->	O
request	pointer
)	O
;	O
if	O
(	O
thread_mem	struct
->	O
reply	pointer
)	O
free	function
(	O
thread_mem	struct
->	O
reply	pointer
)	O
;	O
if	O
(	O
thread_mem	struct
->	O
queue	struct
.	O
proto_out	pointer
)	O
free	function
(	O
thread_mem	struct
->	O
queue	struct
.	O
proto_out	pointer
)	O
;	O
pthread_exit	function
(	O
retval	pointer
)	O
;	O
}	O
void	O
*	O
update_string_thread	function
(	O
char	O
*	O
*	O
dst	pointer
,	O
char	O
*	O
value	int
,	O
struct	O
thread_mem	struct
*	O
thread_mem	struct
)	O
{	O
int	O
size	long
;	O
if	O
(	O
*	O
dst	pointer
!=	O
NULL	O
)	O
pxfree	function
(	O
(	O
void	O
*	O
*	O
)	O
dst	pointer
)	O
;	O
size	long
=	O
strlen	function
(	O
value	int
)	O
+	O
1	int
;	O
*	O
dst	pointer
=	O
pmalloc	function
(	O
size	long
,	O
thread_mem	struct
)	O
;	O
if	O
(	O
*	O
dst	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
memmove	function
(	O
*	O
dst	pointer
,	O
value	int
,	O
size	long
)	O
;	O
return	O
*	O
dst	pointer
;	O
}	O
void	O
x_update_string_thread	function
(	O
char	O
*	O
*	O
dst	pointer
,	O
char	O
*	O
value	int
,	O
struct	O
thread_mem	struct
*	O
thread_mem	struct
)	O
{	O
int	O
ret	int
=	O
EXIT_FAILURE	int
;	O
if	O
(	O
update_string_thread	function
(	O
dst	pointer
,	O
value	int
,	O
thread_mem	struct
)	O
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s %s: x_update_string_thread: "	pointer
"fail to allocate memory!\n"	pointer
,	O
progname	pointer
,	O
__FILE__	O
)	O
;	O
x_pthread_exit	function
(	O
(	O
void	O
*	O
)	O
&	O
ret	int
,	O
thread_mem	struct
)	O
;	O
}	O
}	O
